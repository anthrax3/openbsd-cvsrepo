head	1.68;
access;
symbols
	OPENBSD_6_2:1.68.0.2
	OPENBSD_6_2_BASE:1.68
	OPENBSD_6_1:1.68.0.4
	OPENBSD_6_1_BASE:1.68
	OPENBSD_6_0:1.58.0.2
	OPENBSD_6_0_BASE:1.58
	OPENBSD_5_9:1.34.0.2
	OPENBSD_5_9_BASE:1.34
	OPENBSD_5_8:1.34.0.4
	OPENBSD_5_8_BASE:1.34
	OPENBSD_5_7:1.31.0.2
	OPENBSD_5_7_BASE:1.31
	OPENBSD_5_6:1.28.0.6
	OPENBSD_5_6_BASE:1.28
	OPENBSD_5_5:1.28.0.4
	OPENBSD_5_5_BASE:1.28
	OPENBSD_5_4:1.24.0.2
	OPENBSD_5_4_BASE:1.24
	OPENBSD_5_3:1.19.0.10
	OPENBSD_5_3_BASE:1.19
	OPENBSD_5_2:1.19.0.8
	OPENBSD_5_2_BASE:1.19
	OPENBSD_5_1_BASE:1.19
	OPENBSD_5_1:1.19.0.6
	OPENBSD_5_0:1.19.0.4
	OPENBSD_5_0_BASE:1.19
	OPENBSD_4_9:1.19.0.2
	OPENBSD_4_9_BASE:1.19
	OPENBSD_4_8:1.13.0.2
	OPENBSD_4_8_BASE:1.13
	OPENBSD_4_7:1.7.0.2
	OPENBSD_4_7_BASE:1.7
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2;
locks; strict;
comment	@ * @;


1.68
date	2017.03.04.00.15.35;	author renato;	state Exp;
branches;
next	1.67;
commitid	BOl8emh4A0ljUk3b;

1.67
date	2017.03.04.00.12.25;	author renato;	state Exp;
branches;
next	1.66;
commitid	bHPjS8k63pM8XVeR;

1.66
date	2017.03.04.00.09.17;	author renato;	state Exp;
branches;
next	1.65;
commitid	tAFME29r3wKSl8xr;

1.65
date	2017.03.04.00.06.10;	author renato;	state Exp;
branches;
next	1.64;
commitid	GMDFIgs8eMuH7Rxe;

1.64
date	2017.03.03.23.50.45;	author renato;	state Exp;
branches;
next	1.63;
commitid	2u5VjeFQJD7hTJEX;

1.63
date	2017.03.03.23.44.35;	author renato;	state Exp;
branches;
next	1.62;
commitid	mV5MMkodXlL2okSe;

1.62
date	2017.03.03.23.41.27;	author renato;	state Exp;
branches;
next	1.61;
commitid	lvj5kMm2TzZDSXqr;

1.61
date	2016.09.02.17.16.24;	author renato;	state Exp;
branches;
next	1.60;
commitid	8A8atcXGbtwiVb5Y;

1.60
date	2016.09.02.17.08.02;	author renato;	state Exp;
branches;
next	1.59;
commitid	BOhRdj3Gcm8K4Ipy;

1.59
date	2016.08.08.16.45.51;	author renato;	state Exp;
branches;
next	1.58;
commitid	wXIuSV6JZlfbC22E;

1.58
date	2016.07.16.19.20.16;	author renato;	state Exp;
branches;
next	1.57;
commitid	YLPvWL4I6VM5sc5a;

1.57
date	2016.07.15.17.09.25;	author renato;	state Exp;
branches;
next	1.56;
commitid	VGEMIeHBWOrVJjkU;

1.56
date	2016.07.15.17.05.50;	author renato;	state Exp;
branches;
next	1.55;
commitid	X6CPdHLNlygZ6jUf;

1.55
date	2016.07.01.23.36.38;	author renato;	state Exp;
branches;
next	1.54;
commitid	h9Qy21EPYXbAFnoh;

1.54
date	2016.07.01.23.33.46;	author renato;	state Exp;
branches;
next	1.53;
commitid	o5yBQ1cPVCcMZ7gA;

1.53
date	2016.07.01.23.29.55;	author renato;	state Exp;
branches;
next	1.52;
commitid	OkOx7tFZtmlIlivU;

1.52
date	2016.06.27.19.06.33;	author renato;	state Exp;
branches;
next	1.51;
commitid	OXyvybFBtSb4ppHx;

1.51
date	2016.06.18.01.29.05;	author renato;	state Exp;
branches;
next	1.50;
commitid	uibFJsTlGAQwmzl4;

1.50
date	2016.06.11.02.01.46;	author renato;	state Exp;
branches;
next	1.49;
commitid	QLddN9COTbHqBmBf;

1.49
date	2016.06.11.01.55.35;	author renato;	state Exp;
branches;
next	1.48;
commitid	GgWpGoWeBPM557df;

1.48
date	2016.06.11.01.52.33;	author renato;	state Exp;
branches;
next	1.47;
commitid	XfOzUytCPs9UnIQ9;

1.47
date	2016.06.11.01.44.02;	author renato;	state Exp;
branches;
next	1.46;
commitid	vwBDqzjY8KdySFgq;

1.46
date	2016.05.23.19.14.03;	author renato;	state Exp;
branches;
next	1.45;
commitid	TLlfi1Pk0Z97z8HM;

1.45
date	2016.05.23.19.11.42;	author renato;	state Exp;
branches;
next	1.44;
commitid	AQBoOveMRKjtVfFv;

1.44
date	2016.05.23.19.09.25;	author renato;	state Exp;
branches;
next	1.43;
commitid	t07H0Mk6WGdVWB0W;

1.43
date	2016.05.23.18.58.48;	author renato;	state Exp;
branches;
next	1.42;
commitid	D7VvXbswyzx5Ahb2;

1.42
date	2016.05.23.18.51.52;	author renato;	state Exp;
branches;
next	1.41;
commitid	LNuzMvIsQaZjMMrO;

1.41
date	2016.05.23.17.43.42;	author renato;	state Exp;
branches;
next	1.40;
commitid	VpAym8dVR6eY4drQ;

1.40
date	2016.05.23.16.43.57;	author renato;	state Exp;
branches;
next	1.39;
commitid	yXgTKNKOaRXeBjel;

1.39
date	2016.05.23.16.41.52;	author renato;	state Exp;
branches;
next	1.38;
commitid	Tr3dI4hLiCyJxEwf;

1.38
date	2016.05.23.16.25.11;	author renato;	state Exp;
branches;
next	1.37;
commitid	rbQYKxfpthpZ0H0X;

1.37
date	2016.05.23.16.12.28;	author renato;	state Exp;
branches;
next	1.36;
commitid	vVUYnEJVjv7IWE6u;

1.36
date	2016.05.23.16.04.04;	author renato;	state Exp;
branches;
next	1.35;
commitid	sfghEB6dR4Eaf77g;

1.35
date	2016.05.23.15.14.07;	author renato;	state Exp;
branches;
next	1.34;
commitid	l3e6PhvoAh8C7elc;

1.34
date	2015.07.21.05.02.57;	author renato;	state Exp;
branches;
next	1.33;
commitid	HgM2vLtnZjFgxhpg;

1.33
date	2015.07.21.04.52.29;	author renato;	state Exp;
branches;
next	1.32;
commitid	puLLDX1XPNc3GxB9;

1.32
date	2015.07.19.20.54.16;	author renato;	state Exp;
branches;
next	1.31;
commitid	AcGJH529uphBS2D2;

1.31
date	2015.02.09.11.53.25;	author claudio;	state Exp;
branches;
next	1.30;
commitid	abCovo6pNyUZo1Lg;

1.30
date	2015.01.20.18.09.12;	author deraadt;	state Exp;
branches;
next	1.29;
commitid	zPQ1sRsca5qhWngE;

1.29
date	2014.10.25.03.23.49;	author lteo;	state Exp;
branches;
next	1.28;
commitid	2uw1UTO4k6erpWzK;

1.28
date	2013.10.17.17.52.20;	author renato;	state Exp;
branches;
next	1.27;

1.27
date	2013.10.17.17.47.03;	author renato;	state Exp;
branches;
next	1.26;

1.26
date	2013.10.15.20.27.40;	author renato;	state Exp;
branches;
next	1.25;

1.25
date	2013.10.15.19.59.53;	author renato;	state Exp;
branches;
next	1.24;

1.24
date	2013.06.04.02.34.48;	author claudio;	state Exp;
branches;
next	1.23;

1.23
date	2013.06.01.19.42.07;	author claudio;	state Exp;
branches;
next	1.22;

1.22
date	2013.06.01.19.01.32;	author claudio;	state Exp;
branches;
next	1.21;

1.21
date	2013.06.01.18.47.07;	author claudio;	state Exp;
branches;
next	1.20;

1.20
date	2013.06.01.18.35.02;	author claudio;	state Exp;
branches;
next	1.19;

1.19
date	2011.01.10.11.52.04;	author claudio;	state Exp;
branches;
next	1.18;

1.18
date	2010.12.31.21.22.42;	author guenther;	state Exp;
branches;
next	1.17;

1.17
date	2010.11.04.09.52.16;	author claudio;	state Exp;
branches;
next	1.16;

1.16
date	2010.10.26.12.59.03;	author claudio;	state Exp;
branches;
next	1.15;

1.15
date	2010.10.26.12.35.25;	author claudio;	state Exp;
branches;
next	1.14;

1.14
date	2010.10.26.12.22.35;	author claudio;	state Exp;
branches;
next	1.13;

1.13
date	2010.06.30.01.47.11;	author claudio;	state Exp;
branches;
next	1.12;

1.12
date	2010.06.09.14.01.03;	author claudio;	state Exp;
branches;
next	1.11;

1.11
date	2010.05.26.13.56.07;	author nicm;	state Exp;
branches;
next	1.10;

1.10
date	2010.05.25.09.40.10;	author claudio;	state Exp;
branches;
next	1.9;

1.9
date	2010.05.17.08.07.04;	author claudio;	state Exp;
branches;
next	1.8;

1.8
date	2010.04.15.14.47.12;	author claudio;	state Exp;
branches;
next	1.7;

1.7
date	2010.02.25.17.40.46;	author claudio;	state Exp;
branches;
next	1.6;

1.6
date	2010.02.22.09.44.04;	author claudio;	state Exp;
branches;
next	1.5;

1.5
date	2010.02.20.21.28.39;	author michele;	state Exp;
branches;
next	1.4;

1.4
date	2009.12.30.11.05.58;	author michele;	state Exp;
branches;
next	1.3;

1.3
date	2009.12.10.21.47.11;	author michele;	state Exp;
branches;
next	1.2;

1.2
date	2009.06.05.22.34.45;	author michele;	state Exp;
branches;
next	1.1;

1.1
date	2009.06.01.20.59.45;	author michele;	state Exp;
branches;
next	;


desc
@@


1.68
log
@Implement RFC 5919 (LDP End-of-LIB).
@
text
@/*	$OpenBSD: labelmapping.c,v 1.67 2017/03/04 00:12:25 renato Exp $ */

/*
 * Copyright (c) 2014, 2015 Renato Westphal <renato@@openbsd.org>
 * Copyright (c) 2009 Michele Marchetto <michele@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <netmpls/mpls.h>
#include <limits.h>
#include <stdlib.h>
#include <string.h>

#include "ldpd.h"
#include "ldpe.h"
#include "log.h"

static void	 enqueue_pdu(struct nbr *, struct ibuf *, uint16_t);
static int	 gen_label_tlv(struct ibuf *, uint32_t);
static int	 tlv_decode_label(struct nbr *, struct ldp_msg *, char *,
		    uint16_t, uint32_t *);
static int	 gen_reqid_tlv(struct ibuf *, uint32_t);
static void	 log_msg_mapping(int, uint16_t, struct nbr *, struct map *);

static void
enqueue_pdu(struct nbr *nbr, struct ibuf *buf, uint16_t size)
{
	struct ldp_hdr		*ldp_hdr;

	ldp_hdr = ibuf_seek(buf, 0, sizeof(struct ldp_hdr));
	ldp_hdr->length = htons(size);
	evbuf_enqueue(&nbr->tcp->wbuf, buf);
}

/* Generic function that handles all Label Message types */
void
send_labelmessage(struct nbr *nbr, uint16_t type, struct mapping_head *mh)
{
	struct ibuf		*buf = NULL;
	struct mapping_entry	*me;
	uint16_t		 msg_size, size = 0;
	int			 first = 1;
	int			 err = 0;

	/* nothing to send */
	if (TAILQ_EMPTY(mh))
		return;

	while ((me = TAILQ_FIRST(mh)) != NULL) {
		/* generate pdu */
		if (first) {
			if ((buf = ibuf_open(nbr->max_pdu_len +
			    LDP_HDR_DEAD_LEN)) == NULL)
				fatal(__func__);

			/* real size will be set up later */
			err |= gen_ldp_hdr(buf, 0);

			size = LDP_HDR_PDU_LEN;
			first = 0;
		}

		/* calculate size */
		msg_size = LDP_MSG_SIZE;
		msg_size += len_fec_tlv(&me->map);
		if (me->map.label != NO_LABEL)
			msg_size += LABEL_TLV_SIZE;
		if (me->map.flags & F_MAP_REQ_ID)
			msg_size += REQID_TLV_SIZE;
		if (me->map.flags & F_MAP_STATUS)
			msg_size += STATUS_SIZE;

		/* maximum pdu length exceeded, we need a new ldp pdu */
		if (size + msg_size > nbr->max_pdu_len) {
			enqueue_pdu(nbr, buf, size);
			first = 1;
			continue;
		}

		size += msg_size;

		/* append message and tlvs */
		err |= gen_msg_hdr(buf, type, msg_size);
		err |= gen_fec_tlv(buf, &me->map);
		if (me->map.label != NO_LABEL)
			err |= gen_label_tlv(buf, me->map.label);
		if (me->map.flags & F_MAP_REQ_ID)
			err |= gen_reqid_tlv(buf, me->map.requestid);
	    	if (me->map.flags & F_MAP_PW_STATUS)
			err |= gen_pw_status_tlv(buf, me->map.pw_status);
		if (me->map.flags & F_MAP_STATUS)
			err |= gen_status_tlv(buf, me->map.st.status_code,
			    me->map.st.msg_id, me->map.st.msg_type);
		if (err) {
			ibuf_free(buf);
			mapping_list_clr(mh);
			return;
		}

		log_msg_mapping(1, type, nbr, &me->map);

		TAILQ_REMOVE(mh, me, entry);
		free(me);
	}

	enqueue_pdu(nbr, buf, size);

	nbr_fsm(nbr, NBR_EVT_PDU_SENT);
}

/* Generic function that handles all Label Message types */
int
recv_labelmessage(struct nbr *nbr, char *buf, uint16_t len, uint16_t type)
{
	struct ldp_msg		 msg;
	struct tlv		 ft;
	uint32_t		 label = NO_LABEL, reqid = 0;
	uint32_t		 pw_status = 0;
	uint8_t			 flags = 0;
	int			 feclen, lbllen, tlen;
	struct mapping_entry	*me;
	struct mapping_head	 mh;
	struct map		 map;

	memcpy(&msg, buf, sizeof(msg));
	buf += LDP_MSG_SIZE;
	len -= LDP_MSG_SIZE;

	/* FEC TLV */
	if (len < sizeof(ft)) {
		session_shutdown(nbr, S_BAD_TLV_LEN, msg.id, msg.type);
		return (-1);
	}

	memcpy(&ft, buf, sizeof(ft));
	if (ntohs(ft.type) != TLV_TYPE_FEC) {
		send_notification(nbr->tcp, S_MISS_MSG, msg.id, msg.type);
		return (-1);
	}
	feclen = ntohs(ft.length);
	if (feclen > len - TLV_HDR_SIZE) {
		session_shutdown(nbr, S_BAD_TLV_LEN, msg.id, msg.type);
		return (-1);
	}

	buf += TLV_HDR_SIZE;	/* just advance to the end of the fec header */
	len -= TLV_HDR_SIZE;

	TAILQ_INIT(&mh);
	do {
		memset(&map, 0, sizeof(map));
		map.msg_id = msg.id;

		if ((tlen = tlv_decode_fec_elm(nbr, &msg, buf, feclen,
		    &map)) == -1)
			goto err;
		if (map.type == MAP_TYPE_PWID &&
		    !(map.flags & F_MAP_PW_ID) &&
		    type != MSG_TYPE_LABELWITHDRAW &&
		    type != MSG_TYPE_LABELRELEASE) {
			send_notification(nbr->tcp, S_MISS_MSG, msg.id,
			    msg.type);
			return (-1);
		}

		/*
		 * The Wildcard FEC Element can be used only in the
		 * Label Withdraw and Label Release messages.
		 */
		if (map.type == MAP_TYPE_WILDCARD) {
			switch (type) {
			case MSG_TYPE_LABELMAPPING:
			case MSG_TYPE_LABELREQUEST:
			case MSG_TYPE_LABELABORTREQ:
				session_shutdown(nbr, S_UNKNOWN_FEC, msg.id,
				    msg.type);
				goto err;
			default:
				break;
			}
		}

		/*
		 * RFC 5561 - Section 4:
		 * "An LDP implementation that supports the Typed Wildcard
		 * FEC Element MUST support its use in Label Request, Label
		 * Withdraw, and Label Release messages".
		 */
		if (map.type == MAP_TYPE_TYPED_WCARD) {
			switch (type) {
			case MSG_TYPE_LABELMAPPING:
			case MSG_TYPE_LABELABORTREQ:
				session_shutdown(nbr, S_UNKNOWN_FEC, msg.id,
				    msg.type);
				goto err;
			default:
				break;
			}
		}

		/*
		 * LDP supports the use of multiple FEC Elements per
		 * FEC for the Label Mapping message only.
		 */
		if (type != MSG_TYPE_LABELMAPPING &&
		    tlen != feclen) {
			session_shutdown(nbr, S_BAD_TLV_VAL, msg.id, msg.type);
			goto err;
		}

		mapping_list_add(&mh, &map);

		buf += tlen;
		len -= tlen;
		feclen -= tlen;
	} while (feclen > 0);

	/* Mandatory Label TLV */
	if (type == MSG_TYPE_LABELMAPPING) {
		lbllen = tlv_decode_label(nbr, &msg, buf, len, &label);
		if (lbllen == -1)
			goto err;

		buf += lbllen;
		len -= lbllen;
	}

	/* Optional Parameters */
	while (len > 0) {
		struct tlv 	tlv;
		uint16_t	tlv_type;
		uint16_t	tlv_len;
		uint32_t	reqbuf, labelbuf, statusbuf;

		if (len < sizeof(tlv)) {
			session_shutdown(nbr, S_BAD_TLV_LEN, msg.id, msg.type);
			goto err;
		}

		memcpy(&tlv, buf, TLV_HDR_SIZE);
		tlv_type = ntohs(tlv.type);
		tlv_len = ntohs(tlv.length);
		if (tlv_len + TLV_HDR_SIZE > len) {
			session_shutdown(nbr, S_BAD_TLV_LEN, msg.id, msg.type);
			goto err;
		}
		buf += TLV_HDR_SIZE;
		len -= TLV_HDR_SIZE;

		switch (tlv_type) {
		case TLV_TYPE_LABELREQUEST:
			switch (type) {
			case MSG_TYPE_LABELMAPPING:
			case MSG_TYPE_LABELREQUEST:
				if (tlv_len != REQID_TLV_LEN) {
					session_shutdown(nbr, S_BAD_TLV_LEN,
					    msg.id, msg.type);
					goto err;
				}

				flags |= F_MAP_REQ_ID;
				memcpy(&reqbuf, buf, sizeof(reqbuf));
				reqid = ntohl(reqbuf);
				break;
			default:
				/* ignore */
				break;
			}
			break;
		case TLV_TYPE_HOPCOUNT:
		case TLV_TYPE_PATHVECTOR:
			/* ignore */
			break;
		case TLV_TYPE_GENERICLABEL:
			switch (type) {
			case MSG_TYPE_LABELWITHDRAW:
			case MSG_TYPE_LABELRELEASE:
				if (tlv_len != LABEL_TLV_LEN) {
					session_shutdown(nbr, S_BAD_TLV_LEN,
					    msg.id, msg.type);
					goto err;
				}

				memcpy(&labelbuf, buf, sizeof(labelbuf));
				label = ntohl(labelbuf);
				break;
			default:
				/* ignore */
				break;
			}
			break;
		case TLV_TYPE_ATMLABEL:
		case TLV_TYPE_FRLABEL:
			switch (type) {
			case MSG_TYPE_LABELWITHDRAW:
			case MSG_TYPE_LABELRELEASE:
				/* unsupported */
				session_shutdown(nbr, S_BAD_TLV_VAL, msg.id,
				    msg.type);
				goto err;
				break;
			default:
				/* ignore */
				break;
			}
			break;
		case TLV_TYPE_STATUS:
			if (tlv_len != STATUS_TLV_LEN) {
				session_shutdown(nbr, S_BAD_TLV_LEN, msg.id,
				    msg.type);
				goto err;
			}
			/* ignore */
			break;
		case TLV_TYPE_PW_STATUS:
			switch (type) {
			case MSG_TYPE_LABELMAPPING:
				if (tlv_len != PW_STATUS_TLV_LEN) {
					session_shutdown(nbr, S_BAD_TLV_LEN,
					    msg.id, msg.type);
					goto err;
				}

				flags |= F_MAP_PW_STATUS;
				memcpy(&statusbuf, buf, sizeof(statusbuf));
				pw_status = ntohl(statusbuf);
				break;
			default:
				/* ignore */
				break;
			}
			break;
		default:
			if (!(ntohs(tlv.type) & UNKNOWN_FLAG))
				send_notification_rtlvs(nbr, S_UNKNOWN_TLV,
				    msg.id, msg.type, tlv_type, tlv_len, buf);
			/* ignore unknown tlv */
			break;
		}
		buf += tlv_len;
		len -= tlv_len;
	}

	/* notify lde about the received message. */
	while ((me = TAILQ_FIRST(&mh)) != NULL) {
		int imsg_type = IMSG_NONE;

		me->map.flags |= flags;
		switch (me->map.type) {
		case MAP_TYPE_PREFIX:
			switch (me->map.fec.prefix.af) {
			case AF_INET:
				if (label == MPLS_LABEL_IPV6NULL) {
					session_shutdown(nbr, S_BAD_TLV_VAL,
					    msg.id, msg.type);
					goto err;
				}
				if (!nbr->v4_enabled)
					goto next;
				break;
			case AF_INET6:
				if (label == MPLS_LABEL_IPV4NULL) {
					session_shutdown(nbr, S_BAD_TLV_VAL,
					    msg.id, msg.type);
					goto err;
				}
				if (!nbr->v6_enabled)
					goto next;
				break;
			default:
				fatalx("recv_labelmessage: unknown af");
			}
			break;
		case MAP_TYPE_PWID:
			if (label <= MPLS_LABEL_RESERVED_MAX) {
				session_shutdown(nbr, S_BAD_TLV_VAL, msg.id,
				    msg.type);
				goto err;
			}
			if (me->map.flags & F_MAP_PW_STATUS)
				me->map.pw_status = pw_status;
			break;
		default:
			break;
		}
		me->map.label = label;
		if (me->map.flags & F_MAP_REQ_ID)
			me->map.requestid = reqid;

		log_msg_mapping(0, type, nbr, &me->map);

		switch (type) {
		case MSG_TYPE_LABELMAPPING:
			imsg_type = IMSG_LABEL_MAPPING;
			break;
		case MSG_TYPE_LABELREQUEST:
			imsg_type = IMSG_LABEL_REQUEST;
			break;
		case MSG_TYPE_LABELWITHDRAW:
			imsg_type = IMSG_LABEL_WITHDRAW;
			break;
		case MSG_TYPE_LABELRELEASE:
			imsg_type = IMSG_LABEL_RELEASE;
			break;
		case MSG_TYPE_LABELABORTREQ:
			imsg_type = IMSG_LABEL_ABORT;
			break;
		default:
			break;
		}

		ldpe_imsg_compose_lde(imsg_type, nbr->peerid, 0, &me->map,
		    sizeof(struct map));

 next:
		TAILQ_REMOVE(&mh, me, entry);
		free(me);
	}

	return (0);

 err:
	mapping_list_clr(&mh);

	return (-1);
}

/* Other TLV related functions */
static int
gen_label_tlv(struct ibuf *buf, uint32_t label)
{
	struct label_tlv	lt;

	lt.type = htons(TLV_TYPE_GENERICLABEL);
	lt.length = htons(LABEL_TLV_LEN);
	lt.label = htonl(label);

	return (ibuf_add(buf, &lt, sizeof(lt)));
}

static int
tlv_decode_label(struct nbr *nbr, struct ldp_msg *msg, char *buf,
    uint16_t len, uint32_t *label)
{
	struct label_tlv lt;

	if (len < sizeof(lt)) {
		session_shutdown(nbr, S_BAD_TLV_LEN, msg->id, msg->type);
		return (-1);
	}
	memcpy(&lt, buf, sizeof(lt));

	if (!(ntohs(lt.type) & TLV_TYPE_GENERICLABEL)) {
		send_notification(nbr->tcp, S_MISS_MSG, msg->id, msg->type);
		return (-1);
	}

	switch (htons(lt.type)) {
	case TLV_TYPE_GENERICLABEL:
		if (ntohs(lt.length) != sizeof(lt) - TLV_HDR_SIZE) {
			session_shutdown(nbr, S_BAD_TLV_LEN, msg->id,
			    msg->type);
			return (-1);
		}

		*label = ntohl(lt.label);
		if (*label > MPLS_LABEL_MAX ||
		    (*label <= MPLS_LABEL_RESERVED_MAX &&
		     *label != MPLS_LABEL_IPV4NULL &&
		     *label != MPLS_LABEL_IPV6NULL &&
		     *label != MPLS_LABEL_IMPLNULL)) {
			session_shutdown(nbr, S_BAD_TLV_VAL, msg->id,
			    msg->type);
			return (-1);
		}
		break;
	case TLV_TYPE_ATMLABEL:
	case TLV_TYPE_FRLABEL:
	default:
		/* unsupported */
		session_shutdown(nbr, S_BAD_TLV_VAL, msg->id, msg->type);
		return (-1);
	}

	return (sizeof(lt));
}

static int
gen_reqid_tlv(struct ibuf *buf, uint32_t reqid)
{
	struct reqid_tlv	rt;

	rt.type = htons(TLV_TYPE_LABELREQUEST);
	rt.length = htons(REQID_TLV_LEN);
	rt.reqid = htonl(reqid);

	return (ibuf_add(buf, &rt, sizeof(rt)));
}

int
gen_pw_status_tlv(struct ibuf *buf, uint32_t status)
{
	struct pw_status_tlv	st;

	st.type = htons(TLV_TYPE_PW_STATUS);
	st.length = htons(PW_STATUS_TLV_LEN);
	st.value = htonl(status);

	return (ibuf_add(buf, &st, sizeof(st)));
}

uint16_t
len_fec_tlv(struct map *map)
{
	uint16_t	 len = TLV_HDR_SIZE;

	switch (map->type) {
	case MAP_TYPE_WILDCARD:
		len += FEC_ELM_WCARD_LEN;
		break;
	case MAP_TYPE_PREFIX:
		len += FEC_ELM_PREFIX_MIN_LEN +
		    PREFIX_SIZE(map->fec.prefix.prefixlen);
		break;
	case MAP_TYPE_PWID:
		len += FEC_PWID_ELM_MIN_LEN;
		if (map->flags & F_MAP_PW_ID)
			len += PW_STATUS_TLV_LEN;
		if (map->flags & F_MAP_PW_IFMTU)
			len += FEC_SUBTLV_IFMTU_SIZE;
    		if (map->flags & F_MAP_PW_STATUS)
			len += PW_STATUS_TLV_SIZE;
		break;
	case MAP_TYPE_TYPED_WCARD:
		len += FEC_ELM_TWCARD_MIN_LEN;
		switch (map->fec.twcard.type) {
		case MAP_TYPE_PREFIX:
		case MAP_TYPE_PWID:
			len += sizeof(uint16_t);
			break;
		default:
			fatalx("len_fec_tlv: unexpected fec type");
		}
		break;
	default:
		fatalx("len_fec_tlv: unexpected fec type");
	}

	return (len);
}

int
gen_fec_tlv(struct ibuf *buf, struct map *map)
{
	struct tlv	ft;
	uint16_t	family, len, pw_type, ifmtu;
	uint8_t		pw_len = 0, twcard_len;
	uint32_t	group_id, pwid;
	int		err = 0;

	ft.type = htons(TLV_TYPE_FEC);

	switch (map->type) {
	case MAP_TYPE_WILDCARD:
		ft.length = htons(sizeof(uint8_t));
		err |= ibuf_add(buf, &ft, sizeof(ft));
		err |= ibuf_add(buf, &map->type, sizeof(map->type));
		break;
	case MAP_TYPE_PREFIX:
		len = PREFIX_SIZE(map->fec.prefix.prefixlen);
		ft.length = htons(sizeof(map->type) + sizeof(family) +
		    sizeof(map->fec.prefix.prefixlen) + len);
		err |= ibuf_add(buf, &ft, sizeof(ft));
		err |= ibuf_add(buf, &map->type, sizeof(map->type));
		switch (map->fec.prefix.af) {
		case AF_INET:
			family = htons(AF_IPV4);
			break;
		case AF_INET6:
			family = htons(AF_IPV6);
			break;
		default:
			fatalx("gen_fec_tlv: unknown af");
			break;
		}
		err |= ibuf_add(buf, &family, sizeof(family));
		err |= ibuf_add(buf, &map->fec.prefix.prefixlen,
		    sizeof(map->fec.prefix.prefixlen));
		if (len)
			err |= ibuf_add(buf, &map->fec.prefix.prefix, len);
		break;
	case MAP_TYPE_PWID:
		if (map->flags & F_MAP_PW_ID)
			pw_len += FEC_PWID_SIZE;
		if (map->flags & F_MAP_PW_IFMTU)
			pw_len += FEC_SUBTLV_IFMTU_SIZE;

		len = FEC_PWID_ELM_MIN_LEN + pw_len;

		ft.length = htons(len);
		err |= ibuf_add(buf, &ft, sizeof(ft));

		err |= ibuf_add(buf, &map->type, sizeof(uint8_t));
		pw_type = map->fec.pwid.type;
		if (map->flags & F_MAP_PW_CWORD)
			pw_type |= CONTROL_WORD_FLAG;
		pw_type = htons(pw_type);
		err |= ibuf_add(buf, &pw_type, sizeof(uint16_t));
		err |= ibuf_add(buf, &pw_len, sizeof(uint8_t));
		group_id = htonl(map->fec.pwid.group_id);
		err |= ibuf_add(buf, &group_id, sizeof(uint32_t));
		if (map->flags & F_MAP_PW_ID) {
			pwid = htonl(map->fec.pwid.pwid);
			err |= ibuf_add(buf, &pwid, sizeof(uint32_t));
		}
		if (map->flags & F_MAP_PW_IFMTU) {
			struct subtlv 	stlv;

			stlv.type = SUBTLV_IFMTU;
			stlv.length = FEC_SUBTLV_IFMTU_SIZE;
			err |= ibuf_add(buf, &stlv, sizeof(uint16_t));

			ifmtu = htons(map->fec.pwid.ifmtu);
			err |= ibuf_add(buf, &ifmtu, sizeof(uint16_t));
		}
		break;
	case MAP_TYPE_TYPED_WCARD:
		len = FEC_ELM_TWCARD_MIN_LEN;
		switch (map->fec.twcard.type) {
		case MAP_TYPE_PREFIX:
		case MAP_TYPE_PWID:
			len += sizeof(uint16_t);
			break;
		default:
			fatalx("gen_fec_tlv: unexpected fec type");
		}
		ft.length = htons(len);
		err |= ibuf_add(buf, &ft, sizeof(ft));
		err |= ibuf_add(buf, &map->type, sizeof(uint8_t));
		err |= ibuf_add(buf, &map->fec.twcard.type, sizeof(uint8_t));

		switch (map->fec.twcard.type) {
		case MAP_TYPE_PREFIX:
			twcard_len = sizeof(uint16_t);
			err |= ibuf_add(buf, &twcard_len, sizeof(uint8_t));

			switch (map->fec.twcard.u.prefix_af) {
			case AF_INET:
				family = htons(AF_IPV4);
				break;
			case AF_INET6:
				family = htons(AF_IPV6);
				break;
			default:
				fatalx("gen_fec_tlv: unknown af");
				break;
			}

			err |= ibuf_add(buf, &family, sizeof(uint16_t));
			break;
		case MAP_TYPE_PWID:
			twcard_len = sizeof(uint16_t);
			err |= ibuf_add(buf, &twcard_len, sizeof(uint8_t));
			pw_type = htons(map->fec.twcard.u.pw_type);
			err |= ibuf_add(buf, &pw_type, sizeof(uint16_t));
			break;
		default:
			fatalx("gen_fec_tlv: unexpected fec type");
		}
		break;
	default:
		break;
	}

	return (err);
}

int
tlv_decode_fec_elm(struct nbr *nbr, struct ldp_msg *msg, char *buf,
    uint16_t len, struct map *map)
{
	uint16_t	off = 0;
	uint8_t		pw_len, twcard_len;

	map->type = *buf;
	off += sizeof(uint8_t);

	switch (map->type) {
	case MAP_TYPE_WILDCARD:
		if (len == FEC_ELM_WCARD_LEN)
			return (off);
		else {
			session_shutdown(nbr, S_BAD_TLV_VAL, msg->id,
			    msg->type);
			return (-1);
		}
		break;
	case MAP_TYPE_PREFIX:
		if (len < FEC_ELM_PREFIX_MIN_LEN) {
			session_shutdown(nbr, S_BAD_TLV_LEN, msg->id,
			    msg->type);
			return (-1);
		}

		/* Address Family */
		memcpy(&map->fec.prefix.af, buf + off,
		    sizeof(map->fec.prefix.af));
		off += sizeof(map->fec.prefix.af);
		map->fec.prefix.af = ntohs(map->fec.prefix.af);
		switch (map->fec.prefix.af) {
		case AF_IPV4:
			map->fec.prefix.af = AF_INET;
			break;
		case AF_IPV6:
			map->fec.prefix.af = AF_INET6;
			break;
		default:
			send_notification(nbr->tcp, S_UNSUP_ADDR, msg->id,
			    msg->type);
			return (-1);
		}

		/* Prefix Length */
		map->fec.prefix.prefixlen = buf[off];
		off += sizeof(uint8_t);
		if (len < off + PREFIX_SIZE(map->fec.prefix.prefixlen)) {
			session_shutdown(nbr, S_BAD_TLV_LEN, msg->id,
			    msg->type);
			return (-1);
		}

		/* Prefix */
		memset(&map->fec.prefix.prefix, 0,
		    sizeof(map->fec.prefix.prefix));
		memcpy(&map->fec.prefix.prefix, buf + off,
		    PREFIX_SIZE(map->fec.prefix.prefixlen));

		/* Just in case... */
		ldp_applymask(map->fec.prefix.af, &map->fec.prefix.prefix,
		    &map->fec.prefix.prefix, map->fec.prefix.prefixlen);

		return (off + PREFIX_SIZE(map->fec.prefix.prefixlen));
	case MAP_TYPE_PWID:
		if (len < FEC_PWID_ELM_MIN_LEN) {
			session_shutdown(nbr, S_BAD_TLV_LEN, msg->id,
			    msg->type);
			return (-1);
		}

		/* PW type */
		memcpy(&map->fec.pwid.type, buf + off, sizeof(uint16_t));
		map->fec.pwid.type = ntohs(map->fec.pwid.type);
		if (map->fec.pwid.type & CONTROL_WORD_FLAG) {
			map->flags |= F_MAP_PW_CWORD;
			map->fec.pwid.type &= ~CONTROL_WORD_FLAG;
		}
		off += sizeof(uint16_t);

		/* PW info Length */
		pw_len = buf[off];
		off += sizeof(uint8_t);

		if (len != FEC_PWID_ELM_MIN_LEN + pw_len) {
			session_shutdown(nbr, S_BAD_TLV_LEN, msg->id,
			    msg->type);
			return (-1);
		}

		/* Group ID */
		memcpy(&map->fec.pwid.group_id, buf + off, sizeof(uint32_t));
		map->fec.pwid.group_id = ntohl(map->fec.pwid.group_id);
		off += sizeof(uint32_t);

		/* PW ID */
		if (pw_len == 0)
			return (off);

		if (pw_len < sizeof(uint32_t)) {
			session_shutdown(nbr, S_BAD_TLV_LEN, msg->id,
			    msg->type);
			return (-1);
		}

		memcpy(&map->fec.pwid.pwid, buf + off, sizeof(uint32_t));
		map->fec.pwid.pwid = ntohl(map->fec.pwid.pwid);
		map->flags |= F_MAP_PW_ID;
		off += sizeof(uint32_t);
		pw_len -= sizeof(uint32_t);

		/* Optional Interface Parameter Sub-TLVs */
		while (pw_len > 0) {
			struct subtlv 	stlv;

			if (pw_len < sizeof(stlv)) {
				session_shutdown(nbr, S_BAD_TLV_LEN, msg->id,
				    msg->type);
				return (-1);
			}

			memcpy(&stlv, buf + off, sizeof(stlv));
			if (stlv.length > pw_len) {
				session_shutdown(nbr, S_BAD_TLV_LEN, msg->id,
				    msg->type);
				return (-1);
			}

			switch (stlv.type) {
			case SUBTLV_IFMTU:
				if (stlv.length != FEC_SUBTLV_IFMTU_SIZE) {
					session_shutdown(nbr, S_BAD_TLV_LEN,
					    msg->id, msg->type);
					return (-1);
				}
				memcpy(&map->fec.pwid.ifmtu, buf + off +
				    SUBTLV_HDR_SIZE, sizeof(uint16_t));
				map->fec.pwid.ifmtu = ntohs(map->fec.pwid.ifmtu);
				map->flags |= F_MAP_PW_IFMTU;
				break;
			default:
				/* ignore */
				break;
			}
			off += stlv.length;
			pw_len -= stlv.length;
		}

		return (off);
	case MAP_TYPE_TYPED_WCARD:
		if (len < FEC_ELM_TWCARD_MIN_LEN) {
			session_shutdown(nbr, S_BAD_TLV_LEN, msg->id,
			    msg->type);
			return (-1);
		}

		memcpy(&map->fec.twcard.type, buf + off, sizeof(uint8_t));
		off += sizeof(uint8_t);
		memcpy(&twcard_len, buf + off, sizeof(uint8_t));
		off += sizeof(uint8_t);
		if (len != FEC_ELM_TWCARD_MIN_LEN + twcard_len) {
			session_shutdown(nbr, S_BAD_TLV_LEN, msg->id,
			    msg->type);
			return (-1);
		}

		switch (map->fec.twcard.type) {
		case MAP_TYPE_PREFIX:
			if (twcard_len != sizeof(uint16_t)) {
				session_shutdown(nbr, S_BAD_TLV_LEN, msg->id,
				    msg->type);
				return (-1);
			}

			memcpy(&map->fec.twcard.u.prefix_af, buf + off,
			    sizeof(uint16_t));
			map->fec.twcard.u.prefix_af =
			    ntohs(map->fec.twcard.u.prefix_af);
			off += sizeof(uint16_t);

			switch (map->fec.twcard.u.prefix_af) {
			case AF_IPV4:
				map->fec.twcard.u.prefix_af = AF_INET;
				break;
			case AF_IPV6:
				map->fec.twcard.u.prefix_af = AF_INET6;
				break;
			default:
				session_shutdown(nbr, S_BAD_TLV_VAL, msg->id,
				    msg->type);
				return (-1);
			}
			break;
		case MAP_TYPE_PWID:
			if (twcard_len != sizeof(uint16_t)) {
				session_shutdown(nbr, S_BAD_TLV_LEN, msg->id,
				    msg->type);
				return (-1);
			}

			memcpy(&map->fec.twcard.u.pw_type, buf + off,
			    sizeof(uint16_t));
			map->fec.twcard.u.pw_type =
			    ntohs(map->fec.twcard.u.pw_type);
			/* ignore the reserved bit as per RFC 6667 */
			map->fec.twcard.u.pw_type &= ~PW_TWCARD_RESERVED_BIT;
			off += sizeof(uint16_t);
			break;
		default:
			send_notification(nbr->tcp, S_UNKNOWN_FEC, msg->id,
			    msg->type);
			return (-1);
		}

		return (off);
	default:
		send_notification(nbr->tcp, S_UNKNOWN_FEC, msg->id, msg->type);
		break;
	}

	return (-1);
}

static void
log_msg_mapping(int out, uint16_t msg_type, struct nbr *nbr, struct map *map)
{
	log_debug("msg-%s: %s: lsr-id %s, fec %s, label %s",
	    (out) ? "out" : "in", msg_name(msg_type), inet_ntoa(nbr->id),
	    log_map(map), log_label(map->label));
}
@


1.67
log
@Implement RFC 6667 (Typed Wildcard FEC for PWid).
@
text
@d1 1
a1 1
/*	$OpenBSD: labelmapping.c,v 1.66 2017/03/04 00:09:17 renato Exp $ */
d78 2
a79 30
		msg_size = LDP_MSG_SIZE + TLV_HDR_SIZE;
		switch (me->map.type) {
		case MAP_TYPE_WILDCARD:
			msg_size += FEC_ELM_WCARD_LEN;
			break;
		case MAP_TYPE_PREFIX:
			msg_size += FEC_ELM_PREFIX_MIN_LEN +
			    PREFIX_SIZE(me->map.fec.prefix.prefixlen);
			break;
		case MAP_TYPE_PWID:
			msg_size += FEC_PWID_ELM_MIN_LEN;
			if (me->map.flags & F_MAP_PW_ID)
				msg_size += PW_STATUS_TLV_LEN;
			if (me->map.flags & F_MAP_PW_IFMTU)
				msg_size += FEC_SUBTLV_IFMTU_SIZE;
	    		if (me->map.flags & F_MAP_PW_STATUS)
				msg_size += PW_STATUS_TLV_SIZE;
			break;
		case MAP_TYPE_TYPED_WCARD:
			msg_size += FEC_ELM_TWCARD_MIN_LEN;
			switch (me->map.fec.twcard.type) {
			case MAP_TYPE_PREFIX:
			case MAP_TYPE_PWID:
				msg_size += sizeof(uint16_t);
				break;
			default:
				fatalx("send_labelmessage: unexpected fec type");
			}
			break;
		}
d524 40
@


1.66
log
@Implement RFC 5918 (Typed Wildcard FEC).
@
text
@d1 1
a1 1
/*	$OpenBSD: labelmapping.c,v 1.65 2017/03/04 00:06:10 renato Exp $ */
d100 1
d633 1
d663 6
d873 15
@


1.65
log
@Implement RFC 5561 (LDP Capabilities).

This patch per-se doesn't introduce any useful functionality, but prepares
the ground for new enhancements to ldpd (i.e. implementation of new RFCs
that make use of LDP capabilities).
@
text
@d1 1
a1 1
/*	$OpenBSD: labelmapping.c,v 1.64 2017/03/03 23:50:45 renato Exp $ */
d96 10
d225 18
d558 1
a558 1
	uint8_t		pw_len = 0;
d628 37
d677 1
a677 1
	uint8_t		pw_len;
d819 51
@


1.64
log
@Create helper functions to log sent/received messages.
@
text
@d1 1
a1 1
/*	$OpenBSD: labelmapping.c,v 1.63 2017/03/03 23:44:35 renato Exp $ */
d244 1
d254 1
d263 1
a263 1
		switch (ntohs(tlv.type)) {
d348 2
a349 2
				send_notification(nbr->tcp, S_UNKNOWN_TLV,
				    msg.id, msg.type);
@


1.63
log
@Kill send_notification_nbr().

Be more clever and trigger the PDU SENT event inside send_notification()
when tcp->nbr is set. This way we can eliminate send_notification_nbr()
and always use send_notification() instead.
@
text
@d1 1
a1 1
/*	$OpenBSD: labelmapping.c,v 1.62 2017/03/03 23:41:27 renato Exp $ */
d37 1
d131 1
a131 3
		log_debug("msg-out: %s: lsr-id %s, fec %s, label %s",
		    msg_name(type), inet_ntoa(nbr->id), log_map(&me->map),
		    log_label(me->map.label));
d401 1
a401 3
		log_debug("msg-in: %s: lsr-id %s, fec %s, label %s",
		    msg_name(type), inet_ntoa(nbr->id), log_map(&me->map),
		    log_label(me->map.label));
d761 8
@


1.62
log
@Minor tweaks.
@
text
@d1 1
a1 1
/*	$OpenBSD: labelmapping.c,v 1.61 2016/09/02 17:16:24 renato Exp $ */
d169 1
a169 1
		send_notification_nbr(nbr, S_MISS_MSG, msg.id, msg.type);
d193 1
a193 1
			send_notification_nbr(nbr, S_MISS_MSG, msg.id,
d347 1
a347 1
				send_notification_nbr(nbr, S_UNKNOWN_TLV,
d468 1
a468 1
		send_notification_nbr(nbr, S_MISS_MSG, msg->id, msg->type);
d648 1
a648 1
			send_notification_nbr(nbr, S_UNSUP_ADDR, msg->id,
d759 1
a759 1
		send_notification_nbr(nbr, S_UNKNOWN_FEC, msg->id, msg->type);
@


1.61
log
@Fix small memleak on error path.
@
text
@d1 1
a1 1
/*	$OpenBSD: labelmapping.c,v 1.60 2016/09/02 17:08:02 renato Exp $ */
d402 2
a403 2
		log_debug("msg-in: label mapping: lsr-id %s, fec %s, label %s",
		    inet_ntoa(nbr->id), log_map(&me->map),
d429 1
a429 1
next:
d436 1
a436 1
err:
d568 1
a568 1
			pw_len += PW_STATUS_TLV_LEN;
@


1.60
log
@Improve logging of sent and received messages.

* Standardize the logging format of sent and received messages:
  "msg-[in|out]: message type: lsr-id A.B.C.D [additional info]";

* Log sent label messages as well, not only the received ones;

* Move the logging of sent notification messages from
  send_notification_nbr() to send_notification_full(), this way notification
  triggered by the lde process are logged as well;

* Minor clean-up.
@
text
@d1 1
a1 1
/*	$OpenBSD: labelmapping.c,v 1.59 2016/08/08 16:45:51 renato Exp $ */
d126 1
@


1.59
log
@Normalize the received prefixes.

We need to use ldp_applymask() to normalize the received
prefixes. Example: 10.1.1.0/16 -> 10.1.0.0/16.

Additionally, stop using IANA's AF numbers in map->fec.prefix.af and use
AF_INET/AF_INET6 instead. This makes the code much simpler, use AF_IPV[46]
only when necessary (decoding/encoding prefixes).

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: labelmapping.c,v 1.58 2016/07/16 19:20:16 renato Exp $ */
d129 4
d401 4
a406 3
			log_debug("label mapping from lsr-id %s, FEC %s, "
			    "label %s", inet_ntoa(nbr->id),
			    log_map(&me->map), log_label(me->map.label));
a409 2
			log_debug("label request from lsr-id %s, FEC %s",
			    inet_ntoa(nbr->id), log_map(&me->map));
a412 2
			log_debug("label withdraw from lsr-id %s, FEC %s",
			    inet_ntoa(nbr->id), log_map(&me->map));
a415 2
			log_debug("label release from lsr-id %s, FEC %s",
			    inet_ntoa(nbr->id), log_map(&me->map));
a418 2
			log_debug("label abort from lsr-id %s, FEC %s",
			    inet_ntoa(nbr->id), log_map(&me->map));
@


1.58
log
@Fix parsing of mal-formed optional TLVs/Sub-TLVs.

We must detect if a TLV's length extends beyond the end of the containing
message. And, if so, send a fatal "Bad TLV Length" notification message.

Found with the Mu Dynamics Mu-8000 protocol fuzzer.
@
text
@d1 1
a1 1
/*	$OpenBSD: labelmapping.c,v 1.57 2016/07/15 17:09:25 renato Exp $ */
d359 1
a359 1
			case AF_IPV4:
d368 1
a368 1
			case AF_IPV6:
a549 1

d551 11
a561 1
		family = htons(map->fec.prefix.af);
d640 1
d642 8
a649 3
		off += sizeof(map->fec.prefix.af);
		if (map->fec.prefix.af != AF_IPV4 &&
		    map->fec.prefix.af != AF_IPV6) {
d669 4
@


1.57
log
@Improve logging of reserved labels.

Print "exp-null" and "imp-null" instead of "0" and "3", for example. Also,
remove print_label() and print_pw_type() from ldpctl.c and use the
equivalent functions from ldpd's log.c.

While here, be more paranoid and use UINT32_MAX instead of UINT_MAX
for NO_LABEL.
@
text
@d1 1
a1 1
/*	$OpenBSD: labelmapping.c,v 1.56 2016/07/15 17:05:50 renato Exp $ */
d249 5
a255 1
		tlv_len = ntohs(tlv.length);
d341 1
a341 1
			if (!(ntohs(tlv.type) & UNKNOWN_FLAG)) {
a343 1
			}
d714 6
@


1.56
log
@Explicitly ignore the Hop Count and Path Vector TLVs.

Since these are "well known" TLVs, we have to explicitly ignore them
otherwise ldpd would send "Unknown TLV" Notification messages when it
shouldn't.

Fixes regression caused by rev1.51.
@
text
@d1 1
a1 1
/*	$OpenBSD: labelmapping.c,v 1.55 2016/07/01 23:36:38 renato Exp $ */
d397 2
a398 2
			    "label %u", inet_ntoa(nbr->id),
			    log_map(&me->map), me->map.label);
@


1.55
log
@More renaming and whitespace cleanup.

No binary change after "strip -s".
@
text
@d1 1
a1 1
/*	$OpenBSD: labelmapping.c,v 1.54 2016/07/01 23:33:46 renato Exp $ */
d272 4
@


1.54
log
@Be more compliant with RFC 4447.

When sending a label withdraw during the pseudowire Control Word
negotiation, append a "Wrong C-bit" status TLV after the FEC TLV (in
conformance to RFC 4447 section 6.2). Apparently this has no use other
than aiding in troubleshooting.

Also, extend the recv_labelmessage() function to accept Status TLVs and
ignore them instead of shutting down the session.
@
text
@d1 1
a1 1
/*	$OpenBSD: labelmapping.c,v 1.53 2016/07/01 23:29:55 renato Exp $ */
d77 1
a77 1
		msg_size = LDP_MSG_SIZE + TLV_HDR_LEN;
a87 1

d89 1
a89 1
				msg_size += sizeof(uint32_t);
d91 1
a91 1
				msg_size += FEC_SUBTLV_IFMTU_LEN;
d93 1
a93 1
				msg_size += PW_STATUS_TLV_LEN;
d97 1
a97 1
			msg_size += LABEL_TLV_LEN;
d99 1
a99 1
			msg_size += REQID_TLV_LEN;
d122 2
a123 2
			err |= gen_status_tlv(buf, me->map.status.code,
			    me->map.status.msg_id, me->map.status.msg_type);
d142 1
a142 1
	struct ldp_msg		 lm;
d152 1
a152 1
	memcpy(&lm, buf, sizeof(lm));
d158 1
a158 1
		session_shutdown(nbr, S_BAD_TLV_LEN, lm.msgid, lm.type);
d164 1
a164 1
		send_notification_nbr(nbr, S_MISS_MSG, lm.msgid, lm.type);
d168 2
a169 3

	if (feclen > len - TLV_HDR_LEN) {
		session_shutdown(nbr, S_BAD_TLV_LEN, lm.msgid, lm.type);
d173 2
a174 2
	buf += TLV_HDR_LEN;	/* just advance to the end of the fec header */
	len -= TLV_HDR_LEN;
d179 1
a179 1
		map.messageid = lm.msgid;
d181 1
a181 1
		if ((tlen = tlv_decode_fec_elm(nbr, &lm, buf, feclen,
d188 2
a189 2
			send_notification_nbr(nbr, S_MISS_MSG, lm.msgid,
			    lm.type);
d202 2
a203 2
				session_shutdown(nbr, S_UNKNOWN_FEC, lm.msgid,
				    lm.type);
d216 1
a216 2
			session_shutdown(nbr, S_BAD_TLV_VAL, lm.msgid,
			    lm.type);
d229 1
a229 1
		lbllen = tlv_decode_label(nbr, &lm, buf, len, &label);
d244 1
a244 2
			session_shutdown(nbr, S_BAD_TLV_LEN, lm.msgid,
			    lm.type);
d248 3
a250 3
		memcpy(&tlv, buf, TLV_HDR_LEN);
		buf += TLV_HDR_LEN;
		len -= TLV_HDR_LEN;
d258 1
a258 1
				if (tlv_len != 4) {
d260 1
a260 1
					    lm.msgid, lm.type);
d277 1
a277 1
				if (tlv_len != 4) {
d279 1
a279 1
					    lm.msgid, lm.type);
d297 2
a298 2
				session_shutdown(nbr, S_BAD_TLV_VAL, lm.msgid,
				    lm.type);
d308 2
a309 2
				session_shutdown(nbr, S_BAD_TLV_LEN,
				    lm.msgid, lm.type);
d317 1
a317 1
				if (tlv_len != 4) {
d319 1
a319 1
					    lm.msgid, lm.type);
d335 1
a335 1
				    lm.msgid, lm.type);
d355 1
a355 1
					    lm.msgid, lm.type);
d364 1
a364 1
					    lm.msgid, lm.type);
d376 2
a377 2
				session_shutdown(nbr, S_BAD_TLV_VAL, lm.msgid,
				    lm.type);
d444 1
a444 1
	lt.length = htons(sizeof(label));
d451 1
a451 1
tlv_decode_label(struct nbr *nbr, struct ldp_msg *lm, char *buf,
d457 1
a457 1
		session_shutdown(nbr, S_BAD_TLV_LEN, lm->msgid, lm->type);
d463 1
a463 1
		send_notification_nbr(nbr, S_MISS_MSG, lm->msgid, lm->type);
d469 3
a471 3
		if (ntohs(lt.length) != sizeof(lt) - TLV_HDR_LEN) {
			session_shutdown(nbr, S_BAD_TLV_LEN, lm->msgid,
			    lm->type);
d481 2
a482 2
			session_shutdown(nbr, S_BAD_TLV_VAL, lm->msgid,
			    lm->type);
d490 1
a490 1
		session_shutdown(nbr, S_BAD_TLV_VAL, lm->msgid, lm->type);
d503 1
a503 1
	rt.length = htons(sizeof(reqid));
d515 1
a515 1
	st.length = htons(sizeof(status));
d554 1
a554 1
			pw_len += sizeof(uint32_t);
d556 1
a556 1
			pw_len += FEC_SUBTLV_IFMTU_LEN;
d580 1
a580 1
			stlv.length = FEC_SUBTLV_IFMTU_LEN;
d595 1
a595 1
tlv_decode_fec_elm(struct nbr *nbr, struct ldp_msg *lm, char *buf,
d609 2
a610 2
			session_shutdown(nbr, S_BAD_TLV_VAL, lm->msgid,
			    lm->type);
d616 2
a617 2
			session_shutdown(nbr, S_BAD_TLV_LEN, lm->msgid,
			    lm->type);
d628 2
a629 2
			send_notification_nbr(nbr, S_UNSUP_ADDR, lm->msgid,
			    lm->type);
d637 2
a638 2
			session_shutdown(nbr, S_BAD_TLV_LEN, lm->msgid,
			    lm->type);
d651 2
a652 2
			session_shutdown(nbr, S_BAD_TLV_LEN, lm->msgid,
			    lm->type);
d670 2
a671 2
			session_shutdown(nbr, S_BAD_TLV_LEN, lm->msgid,
			    lm->type);
d685 2
a686 2
			session_shutdown(nbr, S_BAD_TLV_LEN, lm->msgid,
			    lm->type);
d701 2
a702 2
				session_shutdown(nbr, S_BAD_TLV_LEN,
				    lm->msgid, lm->type);
d709 1
a709 1
				if (stlv.length != FEC_SUBTLV_IFMTU_LEN) {
d711 1
a711 1
					    lm->msgid, lm->type);
d715 1
a715 1
				    SUBTLV_HDR_LEN, sizeof(uint16_t));
d729 1
a729 1
		send_notification_nbr(nbr, S_UNKNOWN_FEC, lm->msgid, lm->type);
@


1.53
log
@Several minor tweaks.
@
text
@d1 1
a1 1
/*	$OpenBSD: labelmapping.c,v 1.52 2016/06/27 19:06:33 renato Exp $ */
a77 1

a96 1

d101 2
d122 3
d309 8
@


1.52
log
@Handle ibuf_add() errors.

tweaks from claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: labelmapping.c,v 1.51 2016/06/18 01:29:05 renato Exp $ */
d385 1
a385 1
			log_debug("label mapping from nbr %s, FEC %s, "
d391 1
a391 1
			log_debug("label request from nbr %s, FEC %s",
d396 1
a396 1
			log_debug("label withdraw from nbr %s, FEC %s",
d401 1
a401 1
			log_debug("label release from nbr %s, FEC %s",
d406 1
a406 1
			log_debug("label abort from nbr %s, FEC %s",
a699 3
			off += SUBTLV_HDR_LEN;
			pw_len -= SUBTLV_HDR_LEN;

d707 2
a708 2
				memcpy(&map->fec.pwid.ifmtu, buf + off,
				    sizeof(uint16_t));
d716 2
a717 2
			off += stlv.length - SUBTLV_HDR_LEN;
			pw_len -= stlv.length - SUBTLV_HDR_LEN;
@


1.51
log
@Remove TODO comments about loop detection.

LDP loop detection is only necessary for ATM LSRs running in cell mode. We
are never going to implement this "feature".

Also, add two more comments in lde_check_request().
@
text
@d1 1
a1 1
/*	$OpenBSD: labelmapping.c,v 1.50 2016/06/11 02:01:46 renato Exp $ */
d33 1
a33 1
static void	 gen_label_tlv(struct ibuf *, uint32_t);
d36 1
a36 1
static void	 gen_reqid_tlv(struct ibuf *, uint32_t);
d56 1
d70 1
a70 1
			gen_ldp_hdr(buf, 0);
d114 2
a115 2
		gen_msg_hdr(buf, type, msg_size);
		gen_fec_tlv(buf, &me->map);
d117 1
a117 1
			gen_label_tlv(buf, me->map.label);
d119 1
a119 1
			gen_reqid_tlv(buf, me->map.requestid);
d121 5
a125 1
			gen_pw_status_tlv(buf, me->map.pw_status);
d431 1
a431 1
static void
d440 1
a440 1
	ibuf_add(buf, &lt, sizeof(lt));
d490 1
a490 1
static void
d499 1
a499 1
	ibuf_add(buf, &rt, sizeof(rt));
d502 1
a502 1
void
d511 1
a511 1
	ibuf_add(buf, &st, sizeof(st));
d514 1
a514 1
void
d521 1
d528 2
a529 2
		ibuf_add(buf, &ft, sizeof(ft));
		ibuf_add(buf, &map->type, sizeof(map->type));
d535 1
a535 1
		ibuf_add(buf, &ft, sizeof(ft));
d537 1
a537 1
		ibuf_add(buf, &map->type, sizeof(map->type));
d539 2
a540 2
		ibuf_add(buf, &family, sizeof(family));
		ibuf_add(buf, &map->fec.prefix.prefixlen,
d543 1
a543 1
			ibuf_add(buf, &map->fec.prefix.prefix, len);
d554 1
a554 1
		ibuf_add(buf, &ft, sizeof(ft));
d556 1
a556 1
		ibuf_add(buf, &map->type, sizeof(uint8_t));
d561 2
a562 2
		ibuf_add(buf, &pw_type, sizeof(uint16_t));
		ibuf_add(buf, &pw_len, sizeof(uint8_t));
d564 1
a564 1
		ibuf_add(buf, &group_id, sizeof(uint32_t));
d567 1
a567 1
			ibuf_add(buf, &pwid, sizeof(uint32_t));
d574 1
a574 1
			ibuf_add(buf, &stlv, sizeof(uint16_t));
d577 1
a577 1
			ibuf_add(buf, &ifmtu, sizeof(uint16_t));
d583 2
@


1.50
log
@Send an 'Unknown FEC' Notification for unexpected wildcard FECs.

This is basically just to make ANVL happy, there's not much difference
between sending an 'Unknown FEC' or a 'Malformed TLV' Notification.

Fixes ANVL LDP test 15.6.
@
text
@d1 1
a1 1
/*	$OpenBSD: labelmapping.c,v 1.49 2016/06/11 01:55:35 renato Exp $ */
a267 4
			break;
		case TLV_TYPE_HOPCOUNT:
		case TLV_TYPE_PATHVECTOR:
			/* TODO just ignore for now */
@


1.49
log
@Make all TLV parsing functions look the same for consistency.

Also, add one more safety check in recv_init().
@
text
@d1 1
a1 1
/*	$OpenBSD: labelmapping.c,v 1.48 2016/06/11 01:52:33 renato Exp $ */
d196 1
a196 1
				session_shutdown(nbr, S_BAD_TLV_VAL, lm.msgid,
@


1.48
log
@Make it possible to parse unknown TLVs in the future.

In the parsing of label and notification messages, we were always
unsetting the first bit of the TLV type before comparing it against the
types we know. We should not do this because our type constants can have
this bit set when appropriate.

By now the only unknown TLV supported by ldpd(8) is TLV_TYPE_DUALSTACK,
which is only used in Hello messages. But we might change this in the
future with support for MAC List TLVs and maybe RFC 7473.
@
text
@d1 1
a1 1
/*	$OpenBSD: labelmapping.c,v 1.47 2016/06/11 01:44:02 renato Exp $ */
d235 1
d244 1
a244 1
		memcpy(&tlv, buf, sizeof(tlv));
d247 1
d254 1
a254 1
				if (ntohs(tlv.length) != 4) {
d277 1
a277 1
				if (ntohs(tlv.length) != 4) {
d309 1
a309 1
				if (ntohs(tlv.length) != 4) {
d332 2
a333 2
		buf += ntohs(tlv.length);
		len -= ntohs(tlv.length);
@


1.47
log
@Fix parsing of multiple optional TLVs in label and notification messages.

We were accepting at most one optional TLV.

Fixes IxANVL LDP test 15.3.
@
text
@d1 1
a1 1
/*	$OpenBSD: labelmapping.c,v 1.46 2016/05/23 19:14:03 renato Exp $ */
d247 1
a247 1
		switch (ntohs(tlv.type) & ~UNKNOWN_FLAG) {
@


1.46
log
@Update copyright information.
@
text
@d1 1
a1 1
/*	$OpenBSD: labelmapping.c,v 1.45 2016/05/23 19:11:42 renato Exp $ */
a243 5
		if (ntohs(tlv.length) != len - TLV_HDR_LEN) {
			session_shutdown(nbr, S_BAD_TLV_LEN, lm.msgid,
			    lm.type);
			goto err;
		}
@


1.45
log
@Remove superfluous includes.
@
text
@d1 1
a1 1
/*	$OpenBSD: labelmapping.c,v 1.44 2016/05/23 19:09:25 renato Exp $ */
d4 1
@


1.44
log
@Make functions and variables static whenever possible.

The benefits of this include:
* clean up of the ldpd global namespace;
* improved readability;
* more hints to the compiler/linker to generate more efficient code.

Whenever possible, move global static variables to a smaller scope
(function).

All extern variables are now declared in header files to avoid unnecessary
duplication.

This patch also cleans up the indentation of all function prototypes
and global variables.
@
text
@d1 1
a1 1
/*	$OpenBSD: labelmapping.c,v 1.43 2016/05/23 18:58:48 renato Exp $ */
a20 4
#include <sys/uio.h>

#include <netinet/in.h>
#include <netinet/ip.h>
a21 1
#include <net/if_dl.h>
a22 4
#include <unistd.h>

#include <errno.h>
#include <event.h>
d28 1
a28 1
#include "ldp.h"
a29 1
#include "ldpe.h"
@


1.43
log
@Add support for IPv6 (RFC 7552).

This includes:
* Full compliance to RFC 7552;
* Support for MD5 on LDPov6 sessions;
* Support for pseudowires over IPv6 LSPs (we're probably the world's
  first implementation doing this);
* Support for the IPv6 explicit-null label;
* Knob to specify the prefered address-family for TCP transport
  connections;
* Knob to use cisco non-compliant format to send and interpret the
  Dual-Stack capability TLV.
@
text
@d1 1
a1 1
/*	$OpenBSD: labelmapping.c,v 1.42 2016/05/23 18:51:52 renato Exp $ */
d41 5
a45 5
void		gen_label_tlv(struct ibuf *, uint32_t);
void		gen_reqid_tlv(struct ibuf *, uint32_t);

int	tlv_decode_label(struct nbr *, struct ldp_msg *, char *, uint16_t,
	    uint32_t *);
d442 1
a442 1
void
d454 1
a454 1
int
d501 1
a501 1
void
@


1.42
log
@Reject null labels for PW-ID FECs.
@
text
@d1 1
a1 1
/*	$OpenBSD: labelmapping.c,v 1.41 2016/05/23 17:43:42 renato Exp $ */
d93 1
a93 1
			    PREFIX_SIZE(me->map.fec.ipv4.prefixlen);
d353 26
a378 1
		if (me->map.type == MAP_TYPE_PWID) {
d386 3
d428 1
d483 1
d542 1
a542 1
		len = PREFIX_SIZE(map->fec.ipv4.prefixlen);
d544 1
a544 1
		    sizeof(map->fec.ipv4.prefixlen) + len);
d548 1
a548 1
		family = htons(AF_IPV4);
d550 2
a551 2
		ibuf_add(buf, &map->fec.ipv4.prefixlen,
		    sizeof(map->fec.ipv4.prefixlen));
d553 1
a553 1
			ibuf_add(buf, &map->fec.ipv4.prefix, len);
d599 1
a599 1
	uint16_t	family, off = 0;
d623 6
a628 4
		memcpy(&family, buf + off, sizeof(family));
		off += sizeof(family);

		if (family != htons(AF_IPV4)) {
d634 2
a635 2
		/* PreLen */
		map->fec.ipv4.prefixlen = buf[off];
d637 1
a637 2

		if (len < off + PREFIX_SIZE(map->fec.ipv4.prefixlen)) {
d644 4
a647 3
		map->fec.ipv4.prefix.s_addr = 0;
		memcpy(&map->fec.ipv4.prefix, buf + off,
		    PREFIX_SIZE(map->fec.ipv4.prefixlen));
d649 1
a649 1
		return (off + PREFIX_SIZE(map->fec.ipv4.prefixlen));
@


1.41
log
@Fix mess caused by my commit script.

I screwed up everything... trying to fix now.
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d353 9
a364 2
		if (me->map.flags & F_MAP_PW_STATUS)
			me->map.pw_status = pw_status;
@


1.40
log
@Make send_labelmessage() more robust.

Immediately return from this function if the given list of mappings
is empty. This way we have more freedom when sending label messages,
not having to care with corner cases.
@
text
@d1 1
a1 1
/*	$OpenBSD: labelmapping.c,v 1.39 2016/05/23 16:41:52 renato Exp $ */
d41 2
a42 2
void		gen_label_tlv(struct ibuf *, u_int32_t);
void		gen_reqid_tlv(struct ibuf *, u_int32_t);
d44 2
a45 2
int	tlv_decode_label(struct nbr *, struct ldp_msg *, char *, u_int16_t,
    u_int32_t *);
d48 1
a48 1
enqueue_pdu(struct nbr *nbr, struct ibuf *buf, u_int16_t size)
d59 1
a59 1
send_labelmessage(struct nbr *nbr, u_int16_t type, struct mapping_head *mh)
d63 1
a63 1
	u_int16_t		 tlv_size, size = 0;
d73 2
a74 1
			if ((buf = ibuf_open(LDP_MAX_LEN)) == NULL)
d85 1
a85 1
		tlv_size = LDP_MSG_LEN + TLV_HDR_LEN;
d88 2
a89 2
		case FEC_WILDCARD:
			tlv_size += FEC_ELM_WCARD_LEN;
d91 2
a92 2
		case FEC_PREFIX:
			tlv_size += FEC_ELM_PREFIX_MIN_LEN +
d95 2
a96 2
		case FEC_PWID:
			tlv_size += FEC_PWID_ELM_MIN_LEN;
d99 1
a99 1
				tlv_size += sizeof(u_int32_t);
d101 1
a101 1
				tlv_size += FEC_SUBTLV_IFMTU_LEN;
d103 1
a103 1
				tlv_size += PW_STATUS_TLV_LEN;
d108 1
a108 1
			tlv_size += LABEL_TLV_LEN;
d110 1
a110 1
			tlv_size += REQID_TLV_LEN;
d113 1
a113 1
		if (size + tlv_size > LDP_MAX_LEN) {
d119 1
a119 1
		size += tlv_size;
d122 1
a122 1
		gen_msg_tlv(buf, type, tlv_size);
d142 1
a142 1
recv_labelmessage(struct nbr *nbr, char *buf, u_int16_t len, u_int16_t type)
d144 9
a152 11
	struct ldp_msg		 	 lm;
	struct tlv			 ft;
	u_int32_t			 label = NO_LABEL, reqid = 0;
	u_int32_t			 pw_status = 0;
	u_int8_t			 flags = 0;
	int				 feclen, lbllen, tlen;
	struct mapping_entry		*me;
	struct mapping_head		 mh;
	struct map			 map;

	bcopy(buf, &lm, sizeof(lm));
d154 3
a156 2
	buf += sizeof(struct ldp_msg);
	len -= sizeof(struct ldp_msg);
d164 1
a164 1
	bcopy(buf, &ft, sizeof(ft));
d244 1
a244 1
		u_int32_t reqbuf, labelbuf, statusbuf;
d252 2
a253 2
		bcopy(buf, &tlv, sizeof(tlv));
		if (ntohs(tlv.length) > len - TLV_HDR_LEN) {
d407 1
a407 1
gen_label_tlv(struct ibuf *buf, u_int32_t label)
d420 1
a420 1
    u_int16_t len, u_int32_t *label)
d428 1
a428 1
	bcopy(buf, &lt, sizeof(lt));
d465 1
a465 1
gen_reqid_tlv(struct ibuf *buf, u_int32_t reqid)
d477 1
a477 1
gen_pw_status_tlv(struct ibuf *buf, u_int32_t status)
d492 3
a494 3
	u_int16_t	family, len, pw_type, ifmtu;
	u_int8_t	pw_len = 0;
	u_int32_t	group_id, pwid;
d499 2
a500 2
	case FEC_WILDCARD:
		ft.length = htons(sizeof(u_int8_t));
d504 1
a504 1
	case FEC_PREFIX:
d520 1
a520 1
			pw_len += sizeof(u_int32_t);
d529 1
a529 1
		ibuf_add(buf, &map->type, sizeof(u_int8_t));
d534 2
a535 2
		ibuf_add(buf, &pw_type, sizeof(u_int16_t));
		ibuf_add(buf, &pw_len, sizeof(u_int8_t));
d537 1
a537 1
		ibuf_add(buf, &group_id, sizeof(u_int32_t));
d540 1
a540 1
			ibuf_add(buf, &pwid, sizeof(u_int32_t));
d547 1
a547 1
			ibuf_add(buf, &stlv, sizeof(u_int16_t));
d550 1
a550 1
			ibuf_add(buf, &ifmtu, sizeof(u_int16_t));
d560 1
a560 1
    u_int16_t len, struct map *map)
d562 2
a563 2
	u_int16_t	family, off = 0;
	u_int8_t	pw_len;
d566 1
a566 1
	off += sizeof(u_int8_t);
d586 1
a586 1
		bcopy(buf + off, &family, sizeof(family));
d597 1
a597 1
		off += sizeof(u_int8_t);
d607 1
a607 1
		bcopy(buf + off, &map->fec.ipv4.prefix,
d619 1
a619 1
		bcopy(buf + off, &map->fec.pwid.type, sizeof(u_int16_t));
d625 1
a625 1
		off += sizeof(u_int16_t);
d629 1
a629 1
		off += sizeof(u_int8_t);
d638 1
a638 1
		bcopy(buf + off, &map->fec.pwid.group_id, sizeof(u_int32_t));
d640 1
a640 1
		off += sizeof(u_int32_t);
d646 1
a646 1
		if (pw_len < sizeof(u_int32_t)) {
d652 1
a652 1
		bcopy(buf + off, &map->fec.pwid.pwid, sizeof(u_int32_t));
d655 2
a656 2
		off += sizeof(u_int32_t);
		pw_len -= sizeof(u_int32_t);
d668 1
a668 1
			bcopy(buf + off, &stlv, sizeof(stlv));
d679 2
a680 2
				bcopy(buf + off, &map->fec.pwid.ifmtu,
				    sizeof(u_int16_t));
@


1.39
log
@Fix check of when a wildcard group PW-ID FEC is valid or not.

In addition to label mappings, wildcard group PW-ID FECs are invalid in
label requests and label abort requests too.
@
text
@d1 1
a1 1
/*	$OpenBSD: labelmapping.c,v 1.38 2016/05/23 16:25:11 renato Exp $ */
d65 4
@


1.38
log
@Remove unnecessary break statements.
@
text
@d1 1
a1 1
/*	$OpenBSD: labelmapping.c,v 1.37 2016/05/23 16:12:28 renato Exp $ */
d184 3
a186 2
		    type == MSG_TYPE_LABELMAPPING &&
		    !(map.flags & F_MAP_PW_ID)) {
@


1.37
log
@Rename a few constants to avoid confusion.

In ldpd we have the map structure, which is used to represent a label message,
and the fec structure, used to store FECs in the LIB.

As of now, ldpd supports two type of FECs:
* IPv4 prefix (FEC_TYPE_IPV4);
* PWID (FEC_TYPE_PWID).

For the label messages, the following contants were being used:
* FEC_WILDCARD;
* FEC_PREFIX (IPv4 or IPv6);
* FEC_PWID.

Since these contants have similar names to the previous ones, rename
them to:
* MAP_TYPE_WILDCARD;
* MAP_TYPE_PREFIX;
* MAP_TYPE_PWID.
@
text
@d1 1
a1 1
/*	$OpenBSD: labelmapping.c,v 1.36 2016/05/23 16:04:04 renato Exp $ */
a605 1
		break;
a687 1
		break;
@


1.36
log
@Improve the parser of TCP/session packets.

Add more safeguards against malformed packets and fix existing ones. Also,
rename a few variables and constants to match their real meaning. For
example, rename gen_msg_tlv() to gen_msg_hdr() because this function
generates an LDP header, not a TLV.

Finally, clean-up all the send_* functions so they all follow the same
pattern.
@
text
@d1 1
a1 1
/*	$OpenBSD: labelmapping.c,v 1.35 2016/05/23 15:14:07 renato Exp $ */
d183 1
a183 1
		if (map.type == FEC_PWID &&
d195 1
a195 1
		if (map.type == FEC_WILDCARD) {
d513 1
a513 1
	case FEC_PWID:
d564 1
a564 1
	case FEC_WILDCARD:
d573 1
a573 1
	case FEC_PREFIX:
d607 1
a607 1
	case FEC_PWID:
@


1.35
log
@Replace manually written function names with __func__.
@
text
@d1 1
a1 1
/*	$OpenBSD: labelmapping.c,v 1.34 2015/07/21 05:02:57 renato Exp $ */
d392 1
a392 1
	return (ntohs(lm.length));
@


1.34
log
@Rename, move and reuse mapping list functions.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: labelmapping.c,v 1.33 2015/07/21 04:52:29 renato Exp $ */
d70 1
a70 1
				fatal("send_labelmapping");
@


1.33
log
@VPLS signaling support.

This patch introduces full support for pseudowire signaling in ldpd(8),
including Control Word and Status TLV negotiation.

As of now it's not possible to configure a VPWS, but the signaling is
the same. In the future, when VPWS support is available in the kernel,
ldpd(8) can be extended to support VPWS with only a few modifications.

Limitations:
* No support for FEC 129, only FEC 128 (more widely deployed);
* No support for group withdraws (not widely deployed);
* No support for MAC withdraws (not widely deployed).

Related RFCs:
* RFC 3916: Requirements for Pseudo-Wire Emulation Edge-to-Edge (PWE3)
* RFC 3985: Pseudo Wire Emulation Edge-to-Edge (PWE3) Architecture
* RFC 4385: Pseudowire Emulation Edge-to-Edge (PWE3) Control Word for
  Use over an MPLS PSN
* RFC 4446: IANA Allocations for Pseudowire Edge to Edge Emulation (PWE3)
* RFC 4447: Pseudowire Setup and Maintenance Using the Label Distribution
  Protocol (LDP)
* RFC 4448: Encapsulation Methods for Transport of Ethernet over MPLS
  Networks
* RFC 4905: Encapsulation Methods for Transport of Layer 2 Frames over
  MPLS Networks
* RFC 4906: Transport of Layer 2 Frames Over MPLS

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: labelmapping.c,v 1.32 2015/07/19 20:54:16 renato Exp $ */
d147 1
d177 2
a178 3
		me = calloc(1, sizeof(*me));
		me->map.messageid = lm.msgid;
		TAILQ_INSERT_HEAD(&mh, me, entry);
d181 1
a181 1
		    &me->map)) == -1)
d183 1
a183 1
		if (me->map.type == FEC_PWID &&
d185 1
a185 1
		    !(me->map.flags & F_MAP_PW_ID)) {
d195 1
a195 1
		if (me->map.type == FEC_WILDCARD) {
d218 2
@


1.32
log
@Rework label mapping algorithms to be more in line with the RFC.

This patch presents a thoroughly review of the label mapping
algorithms. Most of the changes are minor bug fixes in the handling of
received label messages.

Additional improvements:
* Add a few more references to the Appendix A of the RFC5036 ("LDP
  Label Distribution Procedures") into the code;
* Add full multipath support;
* Send label withdraws when appropriate;
* Add label withdraw/release wildcard support.

NOTE: As a result of implementing only the "Liberal Label Retention" and
"Downstream Unsolicited" modes, we will never send a label request
("Request  Never"). And that means that we can ignore the following
notification messages: "Label Request Aborted", "No Label Resources",
"No Route" and "Label Resources Available". The following algorithms
mentioned in the RFC can also be ignored: "Timeout of Deferred Label
Request", "Detect Local Label Resources Have Become Available" and
"Receive Label Abort Request".

Now, considering that we only support one combination of all modes of
operation, we can say that we have an almost complete implementation of
the protocol.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: labelmapping.c,v 1.31 2015/02/09 11:53:25 claudio Exp $ */
a42 2
void		gen_fec_tlv(struct ibuf *, struct in_addr, u_int8_t);
void		gen_wcard_fec_tlv(struct ibuf *);
a45 2
int	tlv_decode_fec_elm(struct nbr *, struct ldp_msg *, char *, u_int16_t,
    u_int8_t *, u_int32_t *, u_int8_t *);
d81 3
a83 1
		if (me->map.flags & F_MAP_WILDCARD)
d85 2
a86 1
		else
d88 14
a101 1
			    PREFIX_SIZE(me->map.prefixlen);
d118 1
a118 4
		if (me->map.flags & F_MAP_WILDCARD)
			gen_wcard_fec_tlv(buf);
		else
			gen_fec_tlv(buf, me->map.prefix, me->map.prefixlen);
d123 2
d142 1
a143 1

a144 1
	u_int8_t			 addr_type;
d181 1
a181 1
		    &addr_type, &me->map.prefix.s_addr, &me->map.prefixlen)) == -1)
d183 7
d195 1
a195 1
		if (addr_type == FEC_WILDCARD) {
d197 3
a199 5
			case MSG_TYPE_LABELWITHDRAW:
			case MSG_TYPE_LABELRELEASE:
				me->map.flags |= F_MAP_WILDCARD;
				break;
			default:
d203 1
d237 1
a237 1
		u_int32_t reqbuf, labelbuf;
d246 5
d254 1
a254 1
		switch (ntohs(tlv.type)) {
d311 18
d349 2
d356 1
a356 1
			    log_fec(&me->map), me->map.label);
d361 1
a361 1
			    inet_ntoa(nbr->id), log_fec(&me->map));
d366 1
a366 1
			    inet_ntoa(nbr->id), log_fec(&me->map));
d371 1
a371 1
			    inet_ntoa(nbr->id), log_fec(&me->map));
d376 1
a376 1
			    inet_ntoa(nbr->id), log_fec(&me->map));
d470 1
a470 1
gen_fec_tlv(struct ibuf *buf, struct in_addr prefix, u_int8_t prefixlen)
d472 1
a472 11
	struct tlv	ft;
	u_int8_t	type;
	u_int16_t	family;
	u_int8_t	len;

	len = PREFIX_SIZE(prefixlen);
	ft.type = htons(TLV_TYPE_FEC);
	ft.length = htons(sizeof(type) + sizeof(family) + sizeof(prefixlen) +
	    len);

	ibuf_add(buf, &ft, sizeof(ft));
d474 3
a476 2
	type = FEC_PREFIX;
	family = htons(FEC_IPV4);
d478 1
a478 5
	ibuf_add(buf, &type, sizeof(type));
	ibuf_add(buf, &family, sizeof(family));
	ibuf_add(buf, &prefixlen, sizeof(prefixlen));
	if (len)
		ibuf_add(buf, &prefix, len);
d482 1
a482 1
gen_wcard_fec_tlv(struct ibuf *buf)
d485 3
a487 1
	u_int8_t	type;
a489 2
	ft.length = htons(sizeof(type));
	ibuf_add(buf, &ft, sizeof(ft));
d491 58
a548 2
	type = FEC_WILDCARD;
	ibuf_add(buf, &type, sizeof(type));
d553 1
a553 1
    u_int16_t len, u_int8_t *type, u_int32_t *prefix, u_int8_t *prefixlen)
d556 1
d558 1
a558 1
	*type = *buf;
d561 2
a562 1
	if (*type == FEC_WILDCARD) {
d570 60
a629 1
	}
d631 4
a634 4
	if (*type != FEC_PREFIX) {
		send_notification_nbr(nbr, S_UNKNOWN_FEC, lm->msgid, lm->type);
		return (-1);
	}
d636 3
a638 4
	if (len < FEC_ELM_PREFIX_MIN_LEN) {
		session_shutdown(nbr, S_BAD_TLV_LEN, lm->msgid, lm->type);
		return (-1);
	}
d640 5
a644 2
	bcopy(buf + off, &family, sizeof(family));
	off += sizeof(family);
d646 15
a660 4
	if (family != htons(FEC_IPV4)) {
		send_notification_nbr(nbr, S_UNSUP_ADDR, lm->msgid, lm->type);
		return (-1);
	}
d662 23
a684 2
	*prefixlen = buf[off];
	off += sizeof(u_int8_t);
d686 5
a690 3
	if (len < off + PREFIX_SIZE(*prefixlen)) {
		session_shutdown(nbr, S_BAD_TLV_LEN, lm->msgid, lm->type);
		return (-1);
d693 1
a693 4
	*prefix = 0;
	bcopy(buf + off, prefix, PREFIX_SIZE(*prefixlen));

	return (off + PREFIX_SIZE(*prefixlen));
@


1.31
log
@Initialise a variable to please gcc.
@
text
@d1 1
a1 1
/*	$OpenBSD: labelmapping.c,v 1.30 2015/01/20 18:09:12 deraadt Exp $ */
d44 1
d84 7
a90 4
		tlv_size = LDP_MSG_LEN + TLV_HDR_LEN + FEC_ELM_MIN_LEN +
		    PREFIX_SIZE(me->map.prefixlen);
		if (type == MSG_TYPE_LABELMAPPING ||
		    me->map.flags & F_MAP_OPTLABEL)
d106 5
a110 3
		gen_fec_tlv(buf, me->map.prefix, me->map.prefixlen);
		if (type == MSG_TYPE_LABELMAPPING ||
		    me->map.flags & F_MAP_OPTLABEL)
d130 1
a130 1
	u_int32_t			 label, reqid = 0;
d237 1
a237 1
			case MSG_TYPE_LABELABORTREQ:
a268 1
				flags |= F_MAP_OPTLABEL;
d307 1
a307 3
		if (type == MSG_TYPE_LABELMAPPING ||
		    me->map.flags & F_MAP_OPTLABEL)
			me->map.label = label;
d313 3
d319 2
d324 2
d329 2
d334 2
d453 14
d477 1
a477 1
		if (len == 0)
d491 1
a491 1
	if (len < FEC_ELM_MIN_LEN) {
@


1.30
log
@Do not assume a read buffer coming from libevent is aligned.  Copy the
int to an aligned variable before operating on it.
ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: labelmapping.c,v 1.29 2014/10/25 03:23:49 lteo Exp $ */
d124 1
a124 1
	u_int32_t			 label, reqid;
@


1.29
log
@Remove unnecessary netinet/in_systm.h include.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: labelmapping.c,v 1.28 2013/10/17 17:52:20 renato Exp $ */
d215 1
d239 2
a240 1
				reqid = ntohl(*(u_int32_t *)buf);
d261 2
a262 1
				label = ntohl(*(u_int32_t *)buf);
@


1.28
log
@Respect the max pdu length and merge all send_label* functions into
a single generic function.
@
text
@d1 1
a1 1
/*	$OpenBSD: labelmapping.c,v 1.27 2013/10/17 17:47:03 renato Exp $ */
a23 1
#include <netinet/in_systm.h>
@


1.27
log
@Improve parsing of label mapping messages and merge all recv_label*
functions into a single generic function.

Add a few error checks and implement parsing of optional tlvs.
Putting it all together helps avoid to code duplication and improve
maintainability.
@
text
@d1 1
a1 1
/*	$OpenBSD: labelmapping.c,v 1.26 2013/10/15 20:27:40 renato Exp $ */
d51 2
a52 3
/* Label Mapping Message */
void
send_labelmapping(struct nbr *nbr)
a53 2
	struct ibuf		*buf;
	struct mapping_entry	*me;
a54 25
	u_int16_t		 tlv_size, size;

	if ((buf = ibuf_open(LDP_MAX_LEN)) == NULL)
		fatal("send_labelmapping");

	/* real size will be set up later */
	gen_ldp_hdr(buf, 0);

	size = LDP_HDR_SIZE - TLV_HDR_LEN;

	TAILQ_FOREACH(me, &nbr->mapping_list, entry) {
		tlv_size = BASIC_LABEL_MAP_LEN + PREFIX_SIZE(me->map.prefixlen);
		if (me->map.flags & F_MAP_REQ_ID)
			tlv_size += REQID_TLV_LEN;
		size += tlv_size;

		gen_msg_tlv(buf, MSG_TYPE_LABELMAPPING, tlv_size);
		gen_fec_tlv(buf, me->map.prefix, me->map.prefixlen);
		gen_label_tlv(buf, me->map.label);
		if (me->map.flags & F_MAP_REQ_ID)
			gen_reqid_tlv(buf, me->map.requestid);
	}

	/* XXX: should we remove them first? */
	mapping_list_clr(&nbr->mapping_list);
a57 1

a58 1
	nbr_fsm(nbr, NBR_EVT_PDU_SENT);
d61 1
a61 1
/* Label Request Message */
d63 1
a63 1
send_labelrequest(struct nbr *nbr)
d65 1
a65 1
	struct ibuf		*buf;
d67 2
a68 2
	struct ldp_hdr		*ldp_hdr;
	u_int16_t		 tlv_size, size;
d70 21
a90 40
	if ((buf = ibuf_open(LDP_MAX_LEN)) == NULL)
		fatal("send_labelrequest");

	/* real size will be set up later */
	gen_ldp_hdr(buf, 0);

	size = LDP_HDR_SIZE - TLV_HDR_LEN;

	TAILQ_FOREACH(me, &nbr->request_list, entry) {
		tlv_size = PREFIX_SIZE(me->map.prefixlen);
		size += tlv_size;

		gen_msg_tlv(buf, MSG_TYPE_LABELREQUEST, tlv_size);
		gen_fec_tlv(buf, me->map.prefix, me->map.prefixlen);
	}

	/* XXX: should we remove them first? */
	mapping_list_clr(&nbr->request_list);

	ldp_hdr = ibuf_seek(buf, 0, sizeof(struct ldp_hdr));
	ldp_hdr->length = htons(size);

	evbuf_enqueue(&nbr->tcp->wbuf, buf);
	nbr_fsm(nbr, NBR_EVT_PDU_SENT);
}

/* Label Withdraw Message */
void
send_labelwithdraw(struct nbr *nbr)
{
	struct ibuf		*buf;
	struct mapping_entry	*me;
	struct ldp_hdr		*ldp_hdr;
	u_int16_t		 tlv_size, size;

	if ((buf = ibuf_open(LDP_MAX_LEN)) == NULL)
		fatal("send_labelwithdraw");

	/* real size will be set up later */
	gen_ldp_hdr(buf, 0);
d92 6
a97 8
	size = LDP_HDR_SIZE - TLV_HDR_LEN;

	TAILQ_FOREACH(me, &nbr->withdraw_list, entry) {
		if (me->map.label == NO_LABEL)
			tlv_size = PREFIX_SIZE(me->map.prefixlen);
		else
			tlv_size = BASIC_LABEL_MAP_LEN +
			    PREFIX_SIZE(me->map.prefixlen);
d101 2
a102 1
		gen_msg_tlv(buf, MSG_TYPE_LABELWITHDRAW, tlv_size);
d104 2
a105 2

		if (me->map.label != NO_LABEL)
d107 2
a108 40
	}

	/* XXX: should we remove them first? */
	mapping_list_clr(&nbr->withdraw_list);

	ldp_hdr = ibuf_seek(buf, 0, sizeof(struct ldp_hdr));
	ldp_hdr->length = htons(size);

	evbuf_enqueue(&nbr->tcp->wbuf, buf);
	nbr_fsm(nbr, NBR_EVT_PDU_SENT);
}

/* Label Release Message */
void
send_labelrelease(struct nbr *nbr)
{
	struct ibuf		*buf;
	struct mapping_entry	*me;
	struct ldp_hdr		*ldp_hdr;
	u_int16_t		 tlv_size, size;

	if ((buf = ibuf_open(LDP_MAX_LEN)) == NULL)
		fatal("send_labelrelease");

	/* real size will be set up later */
	gen_ldp_hdr(buf, 0);

	size = LDP_HDR_SIZE - TLV_HDR_LEN;

	TAILQ_FOREACH(me, &nbr->release_list, entry) {
		if (me->map.label == NO_LABEL)
			tlv_size = PREFIX_SIZE(me->map.prefixlen);
		else
			tlv_size = BASIC_LABEL_MAP_LEN +
			    PREFIX_SIZE(me->map.prefixlen);

		size += tlv_size;

		gen_msg_tlv(buf, MSG_TYPE_LABELRELEASE, tlv_size);
		gen_fec_tlv(buf, me->map.prefix, me->map.prefixlen);
d110 2
a111 2
		if (me->map.label != NO_LABEL)
			gen_label_tlv(buf, me->map.label);
d114 1
a114 2
	/* XXX: should we remove them first? */
	mapping_list_clr(&nbr->release_list);
a115 26
	ldp_hdr = ibuf_seek(buf, 0, sizeof(struct ldp_hdr));
	ldp_hdr->length = htons(size);

	evbuf_enqueue(&nbr->tcp->wbuf, buf);
	nbr_fsm(nbr, NBR_EVT_PDU_SENT);
}

/* Label Abort Req Message */
void
send_labelabortreq(struct nbr *nbr)
{
	struct ibuf	*buf;
	u_int16_t	 size;

	if ((buf = ibuf_open(LDP_MAX_LEN)) == NULL)
		fatal("send_labelabortreq");

	size = LDP_HDR_SIZE + sizeof(struct ldp_msg);

	gen_ldp_hdr(buf, size);

	size -= LDP_HDR_SIZE;

	gen_msg_tlv(buf, MSG_TYPE_LABELABORTREQ, size);

	evbuf_enqueue(&nbr->tcp->wbuf, buf);
d127 1
@


1.26
log
@Generate the NBR_EVT_PDU_RCVD event in a single point.
OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: labelmapping.c,v 1.25 2013/10/15 19:59:53 renato Exp $ */
a47 1
int	tlv_decode_reqid(char *, u_int16_t, u_int32_t *);
d82 1
a82 1
	nbr_mapping_list_clr(nbr, &nbr->mapping_list);
a90 64
int
recv_labelmapping(struct nbr *nbr, char *buf, u_int16_t len)
{
	struct ldp_msg		lm;
	struct tlv		ft;
	struct map		map;
	u_int32_t		label;
	int			feclen, lbllen, tlen;
	u_int8_t		addr_type;

	bcopy(buf, &lm, sizeof(lm));

	buf += sizeof(struct ldp_msg);
	len -= sizeof(struct ldp_msg);

	if (len < sizeof(ft)) {
		session_shutdown(nbr, S_BAD_TLV_LEN, lm.msgid, lm.type);
		return (-1);
	}

	bcopy(buf, &ft, sizeof(ft));
	if (ntohs(ft.type) != TLV_TYPE_FEC) {
		send_notification_nbr(nbr, S_MISS_MSG, lm.msgid, lm.type);
		return (-1);
	}
	feclen = ntohs(ft.length);

	if (feclen > len - TLV_HDR_LEN) {
		session_shutdown(nbr, S_BAD_TLV_LEN, lm.msgid, lm.type);
		return (-1);
	}

	buf += TLV_HDR_LEN;	/* just advance to the end of the fec header */
	len -= TLV_HDR_LEN;

	lbllen = tlv_decode_label(nbr, &lm, buf + feclen, len - feclen,
	    &label);
	if (lbllen == -1)
		return (-1);

	/* TODO opt label request msg id, hop cnt and path vektor TLV */

	bzero(&map, sizeof(map));
	map.messageid = lm.msgid;
	map.label = label;
	do {
		if ((tlen = tlv_decode_fec_elm(nbr, &lm, buf, feclen,
		    &addr_type, &map.prefix.s_addr, &map.prefixlen)) == -1)
			return (-1);
		if (addr_type == FEC_WILDCARD) {
			session_shutdown(nbr, S_BAD_TLV_VAL, lm.msgid, lm.type);
			return (-1);
		}

		ldpe_imsg_compose_lde(IMSG_LABEL_MAPPING, nbr->peerid, 0, &map,
		    sizeof(map));

		buf += tlen;
		feclen -= tlen;
	} while (feclen > 0);

	return (ntohs(lm.length));
}

d117 1
a117 1
	nbr_mapping_list_clr(nbr, &nbr->request_list);
a125 57
int
recv_labelrequest(struct nbr *nbr, char *buf, u_int16_t len)
{
	struct ldp_msg	lr;
	struct tlv	ft;
	struct map	map;
	int		feclen, tlen;
	u_int8_t	addr_type;

	bcopy(buf, &lr, sizeof(lr));

	buf += sizeof(struct ldp_msg);
	len -= sizeof(struct ldp_msg);

	if (len < sizeof(ft)) {
		session_shutdown(nbr, S_BAD_MSG_LEN, lr.msgid, lr.type);
		return (-1);
	}

	bcopy(buf, &ft, sizeof(ft));
	if (ntohs(ft.type) != TLV_TYPE_FEC) {
		send_notification_nbr(nbr, S_MISS_MSG, lr.msgid, lr.type);
		return (-1);
	}
	feclen = ntohs(ft.length);

	if (feclen > len - TLV_HDR_LEN) {
		session_shutdown(nbr, S_BAD_TLV_LEN, lr.msgid, lr.type);
		return (-1);
	}

	buf += TLV_HDR_LEN;	/* just advance to the end of the fec header */
	len -= TLV_HDR_LEN;

	/* TODO opt hop cnt and path vektor TLV */

	bzero(&map, sizeof(map));
	map.messageid = lr.msgid;
	do {
		if ((tlen = tlv_decode_fec_elm(nbr, &lr, buf, feclen,
		    &addr_type, &map.prefix.s_addr, &map.prefixlen)) == -1)
			return (-1);
		if (addr_type == FEC_WILDCARD) {
			session_shutdown(nbr, S_BAD_TLV_VAL, lr.msgid, lr.type);
			return (-1);
		}

		ldpe_imsg_compose_lde(IMSG_LABEL_REQUEST, nbr->peerid, 0, &map,
		    sizeof(map));

		buf += tlen;
		feclen -= tlen;
	} while (feclen > 0);

	return (ntohs(lr.length));
}

d160 1
a160 1
	nbr_mapping_list_clr(nbr, &nbr->withdraw_list);
a168 91
int
recv_labelwithdraw(struct nbr *nbr, char *buf, u_int16_t len)
{
	struct map	map;
	struct ldp_msg	lw;
	struct tlv	ft;
	u_int32_t	label = NO_LABEL;
	int		feclen, tlen, numfec = 0;
	u_int8_t	addr_type;

	bcopy(buf, &lw, sizeof(lw));

	buf += sizeof(struct ldp_msg);
	len -= sizeof(struct ldp_msg);

	if (len < sizeof(ft)) {
		session_shutdown(nbr, S_BAD_MSG_LEN, lw.msgid, lw.type);
		return (-1);
	}

	bcopy(buf, &ft, sizeof(ft));
	if (ntohs(ft.type) != TLV_TYPE_FEC) {
		send_notification_nbr(nbr, S_MISS_MSG, lw.msgid, lw.type);
		return (-1);
	}
	feclen = ntohs(ft.length);

	if (feclen > len - TLV_HDR_LEN) {
		session_shutdown(nbr, S_BAD_TLV_LEN, lw.msgid, lw.type);
		return (-1);
	}

	buf += TLV_HDR_LEN;	/* just advance to the end of the fec header */
	len -= TLV_HDR_LEN;

	/* withdraw may include optional label */
	if (len > feclen) {
		int r;

		r = tlv_decode_label(nbr, &lw, buf + feclen, len - feclen,
		    &label);
		if (r == -1 || len != feclen + r) {
			session_shutdown(nbr, S_BAD_TLV_VAL, lw.msgid,
			    lw.type);
			return (-1);
		}
	}

	bzero(&map, sizeof(map));
	map.messageid = lw.msgid;
	if (label != NO_LABEL) {
		map.label = label;
		map.flags = F_MAP_OPTLABEL;
	}
	do {
		if ((tlen = tlv_decode_fec_elm(nbr, &lw, buf, feclen,
		    &addr_type, &map.prefix.s_addr, &map.prefixlen)) == -1)
			return (-1);

		if (addr_type == FEC_WILDCARD) {
			/* Wildcard FEC must be the only FEC element */
			if (numfec != 0) {
				session_shutdown(nbr, S_BAD_TLV_VAL, lw.msgid,
				    lw.type);
				return (-1);
			}
			map.prefix.s_addr = 0;
			map.prefixlen = 0;
			map.flags |= F_MAP_WILDCARD;
			numfec = -1;
		} else {
			/* Wildcard FEC must be the only FEC element */
			if (numfec == -1) {
				session_shutdown(nbr, S_BAD_TLV_VAL, lw.msgid,
				    lw.type);
				return (-1);
			}
			numfec++;
			map.flags &= ~F_MAP_WILDCARD;
		}

		ldpe_imsg_compose_lde(IMSG_LABEL_WITHDRAW, nbr->peerid, 0, &map,
		    sizeof(map));

		buf += tlen;
		feclen -= tlen;
	} while (feclen > 0);

	return (ntohs(lw.length));
}

d203 1
a203 1
	nbr_mapping_list_clr(nbr, &nbr->release_list);
a211 90
int
recv_labelrelease(struct nbr *nbr, char *buf, u_int16_t len)
{
	struct map	map;
	struct ldp_msg	lr;
	struct tlv	ft;
	u_int32_t	label = NO_LABEL;
	int		feclen, tlen, numfec = 0;
	u_int8_t	addr_type;

	bcopy(buf, &lr, sizeof(lr));

	buf += sizeof(struct ldp_msg);
	len -= sizeof(struct ldp_msg);

	if (len < sizeof(ft)) {
		session_shutdown(nbr, S_BAD_MSG_LEN, lr.msgid, lr.type);
		return (-1);
	}

	bcopy(buf, &ft, sizeof(ft));
	if (ntohs(ft.type) != TLV_TYPE_FEC) {
		send_notification_nbr(nbr, S_MISS_MSG, lr.msgid, lr.type);
		return (-1);
	}
	feclen = ntohs(ft.length);

	if (feclen > len - TLV_HDR_LEN) {
		session_shutdown(nbr, S_BAD_TLV_LEN, lr.msgid, lr.type);
		return (-1);
	}

	buf += TLV_HDR_LEN;	/* just advance to the end of the fec header */
	len -= TLV_HDR_LEN;

	/* release may include optional label */
	if (len > feclen) {
		int r;

		r = tlv_decode_label(nbr, &lr, buf + feclen, len - feclen,
		    &label);
		if (r == -1 || len != feclen + r) {
			session_shutdown(nbr, S_BAD_TLV_VAL, lr.msgid,
			    lr.type);
			return (-1);
		}
	}

	bzero(&map, sizeof(map));
	map.messageid = lr.msgid;
	if (label != NO_LABEL) {
		map.label = label;
		map.flags = F_MAP_OPTLABEL;
	}
	do {
		if ((tlen = tlv_decode_fec_elm(nbr, &lr, buf, feclen,
		    &addr_type, &map.prefix.s_addr, &map.prefixlen)) == -1)
			return (-1);

		if (addr_type == FEC_WILDCARD) {
			/* Wildcard FEC must be the only FEC element */
			if (numfec != 0) {
				session_shutdown(nbr, S_BAD_TLV_VAL, lr.msgid,
				    lr.type);
				return (-1);
			}
			map.prefix.s_addr = 0;
			map.prefixlen = 0;
			map.flags |= F_MAP_WILDCARD;

		} else {
			/* Wildcard FEC must be the only FEC element */
			if (numfec == -1) {
				session_shutdown(nbr, S_BAD_TLV_VAL, lr.msgid,
				    lr.type);
				return (-1);
			}
			map.flags &= ~F_MAP_WILDCARD;
		}

		ldpe_imsg_compose_lde(IMSG_LABEL_RELEASE, nbr->peerid, 0, &map,
		    sizeof(map));

		buf += tlen;
		feclen -= tlen;
	} while (feclen > 0);

	return (ntohs(lr.length));
}

d234 1
d236 1
a236 1
recv_labelabortreq(struct nbr *nbr, char *buf, u_int16_t len)
d238 8
a245 5
	struct map	map;
	struct ldp_msg	la;
	struct tlv	ft;
	int		feclen, tlen;
	u_int8_t	addr_type;
d247 1
a247 3
	log_debug("recv_labelabortreq: neighbor ID %s", inet_ntoa(nbr->id));

	bcopy(buf, &la, sizeof(la));
d252 1
d254 1
a254 1
		session_shutdown(nbr, S_BAD_MSG_LEN, la.msgid, la.type);
d260 1
a260 1
		send_notification_nbr(nbr, S_MISS_MSG, la.msgid, la.type);
d266 1
a266 1
		session_shutdown(nbr, S_BAD_TLV_LEN, la.msgid, la.type);
d273 5
a277 2
	bzero(&map, sizeof(map));
	map.messageid = la.msgid;
d279 3
a281 13
	/* abort request may include optional request msg id */
	if (len > feclen) {
		int r;

		r = tlv_decode_reqid(buf + feclen, len - feclen,
		    &map.requestid);
		if (r == -1 || len != feclen + r) {
			session_shutdown(nbr, S_BAD_TLV_VAL, la.msgid,
			    la.type);
			return (-1);
		}
		map.flags = F_MAP_REQ_ID;
	}
d283 4
a286 4
	do {
		if ((tlen = tlv_decode_fec_elm(nbr, &la, buf, feclen,
		    &addr_type, &map.prefix.s_addr, &map.prefixlen)) == -1)
			return (-1);
d288 11
a298 2
			session_shutdown(nbr, S_BAD_TLV_VAL, la.msgid, la.type);
			return (-1);
d301 10
a310 2
		ldpe_imsg_compose_lde(IMSG_LABEL_ABORT, nbr->peerid, 0, &map,
		    sizeof(map));
d313 1
d317 136
a452 1
	return (ntohs(la.length));
a523 20
}

int
tlv_decode_reqid(char *buf, u_int16_t len, u_int32_t *reqid)
{
	struct reqid_tlv rt;

	if (len < sizeof(rt))
		return (-1);
	bcopy(buf, &rt, sizeof(rt));

	if (ntohs(rt.length) != sizeof(rt) - TLV_HDR_LEN)
		return (-1);

	if (rt.type != htons(TLV_TYPE_LABELREQUEST))
		return (-1);

	*reqid = ntohl(rt.reqid);

	return (sizeof(rt));
@


1.25
log
@Improve parsing of LDP messages.
Add more sanity checks and send proper notification messages on error
conditions.
OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: labelmapping.c,v 1.24 2013/06/04 02:34:48 claudio Exp $ */
a152 2
	nbr_fsm(nbr, NBR_EVT_PDU_RCVD);

a244 2
	nbr_fsm(nbr, NBR_EVT_PDU_RCVD);

a378 2
	nbr_fsm(nbr, NBR_EVT_PDU_RCVD);

a511 2
	nbr_fsm(nbr, NBR_EVT_PDU_RCVD);

a604 2

	nbr_fsm(nbr, NBR_EVT_PDU_RCVD);
@


1.24
log
@Always accept TCP connection requests and identify to which neighbor
it belongs only _after_ receiving an Initialization message containing
the information we need. Before an Initialization message is received,
the TCP connection shouldn't be associated with any neighbor/adjacency.
Therefor refactor that part into a own module.
From Renato Westphal
@
text
@d1 1
a1 1
/*	$OpenBSD: labelmapping.c,v 1.23 2013/06/01 19:42:07 claudio Exp $ */
d28 1
d46 2
a47 1
int	tlv_decode_label(char *, u_int16_t, u_int32_t *);
d49 2
a50 2
int	tlv_decode_fec_elm(char *, u_int16_t, u_int8_t *, u_int32_t *,
	    u_int8_t *);
d113 4
d127 3
a129 3
	lbllen = tlv_decode_label(buf + feclen, len - feclen, &label);
	if (lbllen == -1) {
		session_shutdown(nbr, S_BAD_TLV_LEN, lm.msgid, lm.type);
a130 5
	}
	if (label == NO_LABEL) {
		session_shutdown(nbr, S_BAD_TLV_VAL, lm.msgid, lm.type);
		return (-1);
	}
d138 4
a141 3
		if ((tlen = tlv_decode_fec_elm(buf, feclen, &addr_type,
		    &map.prefix.s_addr, &map.prefixlen)) == -1 ||
		    addr_type == FEC_WILDCARD) {
d213 4
d232 4
a235 3
		if ((tlen = tlv_decode_fec_elm(buf, feclen, &addr_type,
		    &map.prefix.s_addr, &map.prefixlen)) == -1 ||
		    addr_type == FEC_WILDCARD) {
d316 4
d334 2
a335 1
		r = tlv_decode_label(buf + feclen, len - feclen, &label);
d350 2
a351 3
		if ((tlen = tlv_decode_fec_elm(buf, feclen, &addr_type,
		    &map.prefix.s_addr, &map.prefixlen)) == -1) {
			session_shutdown(nbr, S_BAD_TLV_VAL, lw.msgid, lw.type);
a352 1
		}
d452 4
d470 2
a471 1
		r = tlv_decode_label(buf + feclen, len - feclen, &label);
d486 2
a487 3
		if ((tlen = tlv_decode_fec_elm(buf, feclen, &addr_type,
		    &map.prefix.s_addr, &map.prefixlen)) == -1) {
			session_shutdown(nbr, S_BAD_TLV_VAL, lr.msgid, lr.type);
a488 1
		}
d567 4
d599 4
a602 3
		if ((tlen = tlv_decode_fec_elm(buf, feclen, &addr_type,
		    &map.prefix.s_addr, &map.prefixlen)) == -1 ||
		    addr_type == FEC_WILDCARD) {
d633 2
a634 1
tlv_decode_label(char *buf, u_int16_t len, u_int32_t *label)
d638 2
a639 1
	if (len < sizeof(lt))
d641 1
d644 2
a645 1
	if (ntohs(lt.length) != sizeof(lt) - TLV_HDR_LEN)
d647 9
d657 15
a671 1
	if (lt.type != htons(TLV_TYPE_GENERICLABEL))
d673 1
a673 2

	*label = ntohl(lt.label);
a709 1

d736 2
a737 2
tlv_decode_fec_elm(char *buf, u_int16_t len, u_int8_t *type, u_int32_t *prefix,
    u_int8_t *prefixlen)
d747 5
a751 2
		else
			return (-1); /* XXX Malformed TLV Value */
d754 4
a757 2
	if (*type != FEC_PREFIX)
		return (-1);	/* XXX "Unknown FEC" Notification */
d759 4
a762 2
	if (len < FEC_ELM_MIN_LEN)
		return (-1);	/* XXX Bad TLV Length */
d767 4
a770 2
	if (family != htons(FEC_IPV4))
		return (-1);	/* XXX "Unsupported Address Family" */
d775 4
a778 2
	if (len < off + PREFIX_SIZE(*prefixlen))
		return (-1);	/* XXX Bad TLV Length */
@


1.23
log
@Restart the keepalive timer whenever a LDP PDU is sent. There is no need
to send a keepalive packet when a other PDU was sent out.
Also add a missing NBR_EVT_PDU_RCVD call to recv_address() which restarts
the session keepalive timeout. All other places already do that.
Diff by Renato Westphal
@
text
@d1 1
a1 1
/*	$OpenBSD: labelmapping.c,v 1.22 2013/06/01 19:01:32 claudio Exp $ */
d86 1
a86 1
	evbuf_enqueue(&nbr->wbuf, buf);
d187 1
a187 1
	evbuf_enqueue(&nbr->wbuf, buf);
d284 1
a284 1
	evbuf_enqueue(&nbr->wbuf, buf);
d417 1
a417 1
	evbuf_enqueue(&nbr->wbuf, buf);
d528 1
a528 1
	evbuf_enqueue(&nbr->wbuf, buf);
@


1.22
log
@Improve error handling on session_read
* Don't try to send a Shutdown message if the connection is already
  closed or a read error occured;
* As per RFC 5036, send a Shutdown message if an unexpected message is
  received during the initialization process;
* Check if the whole LSR ID of received messages is correct;
* On ldpe_dispatch_main(), ignore the messages from the lde process
  whose associated neighbor is not in the operational state.
Diff from Renato Westphal
@
text
@d1 1
a1 1
/*	$OpenBSD: labelmapping.c,v 1.21 2013/06/01 18:47:07 claudio Exp $ */
d87 1
d188 1
d285 1
d418 1
d529 1
@


1.21
log
@Drop support for per-interface labelspaces.
Support for per-interface labelspaces is only necessary for legacy ATM/FR
interfaces running in cell-mode. We shouldn't worry about this.
For platform-wide label spaces the label space id is always 0.
Diff by Renato Westphal
@
text
@d1 1
a1 1
/*	$OpenBSD: labelmapping.c,v 1.20 2013/06/01 18:35:02 claudio Exp $ */
a98 6
	if (nbr->state != NBR_STA_OPER) {
		log_debug("recv_labelmapping: neighbor ID %s not operational",
		    inet_ntoa(nbr->id));
		return (-1);
	}

a197 6
	if (nbr->state != NBR_STA_OPER) {
		log_debug("recv_labelrequest: neighbor ID %s not operational",
		    inet_ntoa(nbr->id));
		return (-1);
	}

a294 6
	if (nbr->state != NBR_STA_OPER) {
		log_debug("recv_labelwithdraw: neighbor ID %s not operational",
		    inet_ntoa(nbr->id));
		return (-1);
	}

a426 6
	if (nbr->state != NBR_STA_OPER) {
		log_debug("recv_labelrelease: neighbor ID %s not operational",
		    inet_ntoa(nbr->id));
		return (-1);
	}

a534 6

	if (nbr->state != NBR_STA_OPER) {
		log_debug("recv_labelabortreq: neighbor ID %s not operational",
		    inet_ntoa(nbr->id));
		return (-1);
	}
@


1.20
log
@Drop support for passive interfaces.
Support for passive interfaces was inherited from ospfd but it doesn't
make any sense at all for ldpd.
Diff from Renato Westphal
@
text
@d1 1
a1 1
/*	$OpenBSD: labelmapping.c,v 1.19 2011/01/10 11:52:04 claudio Exp $ */
d63 1
a63 1
	gen_ldp_hdr(buf, nbr->iface, 0);
d174 1
a174 1
	gen_ldp_hdr(buf, nbr->iface, 0);
d268 1
a268 1
	gen_ldp_hdr(buf, nbr->iface, 0);
d406 1
a406 1
	gen_ldp_hdr(buf, nbr->iface, 0);
d542 1
a542 1
	gen_ldp_hdr(buf, nbr->iface, size);
@


1.19
log
@Rename struct fec_tlv to struct tlv since it is just the generic
TLV header which will be used in different places shortly.
Cleanup the ldp.h header file a tiny bit.
@
text
@d1 1
a1 1
/*	$OpenBSD: labelmapping.c,v 1.18 2010/12/31 21:22:42 guenther Exp $ */
a58 3
	if (nbr->iface->passive)
		return;

a169 3
	if (nbr->iface->passive)
		return;

a263 3
	if (nbr->iface->passive)
		return;

a401 3
	if (nbr->iface->passive)
		return;

a535 3

	if (nbr->iface->passive)
		return;
@


1.18
log
@Add missing #includes instead of assuming that some system header pulls in
the needed bits

ok deraadt@@, millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: labelmapping.c,v 1.17 2010/11/04 09:52:16 claudio Exp $ */
d96 1
a96 1
	struct fec_tlv		ft;
d205 1
a205 1
	struct fec_tlv	ft;
d311 1
a311 1
	struct fec_tlv	ft;
d452 1
a452 1
	struct fec_tlv	ft;
d571 1
a571 1
	struct fec_tlv	ft;
d710 1
a710 1
	struct fec_tlv	ft;
@


1.17
log
@Rewrite all packet parsers to be more careful about alignment. Until
now ldpd had no chance to run on a strict alignment architecture but
this makes ldpd happy on sparc64. Be careful to do all needed overflow
checks and try to make all parsing functions look similar.
OK michele@@
@
text
@d1 1
a1 1
/*	$OpenBSD: labelmapping.c,v 1.16 2010/10/26 12:59:03 claudio Exp $ */
d32 1
@


1.16
log
@Implement the optional label request message ID TLV.
Currently on the genaration side is done.
@
text
@d1 1
a1 1
/*	$OpenBSD: labelmapping.c,v 1.15 2010/10/26 12:35:25 claudio Exp $ */
d44 4
a47 4
u_int32_t	tlv_decode_label(struct label_tlv *);
u_int32_t	tlv_decode_reqid(struct reqid_tlv *);
int		tlv_decode_fec_elm(char *, u_int16_t, u_int8_t *, u_int32_t *,
		    u_int8_t *);
d94 6
a99 6
	struct ldp_msg		*lm;
	struct fec_tlv		*ft;
	struct label_tlv	*lt;
	struct map		 map;
	int			 feclen, tlen;
	u_int8_t		 addr_type;
d101 3
a103 1
	if (nbr->state != NBR_STA_OPER)
d105 1
d107 1
a107 6
	lm = (struct ldp_msg *)buf;

	if ((len - TLV_HDR_LEN) < ntohs(lm->length)) {
		session_shutdown(nbr, S_BAD_MSG_LEN, lm->msgid, lm->type);
		return (-1);
	}
d112 2
a113 5
	ft = (struct fec_tlv *)buf;

	if (len < sizeof(*ft) ||
	    (len - TLV_HDR_LEN) < ntohs(ft->length)) {
		session_shutdown(nbr, S_BAD_TLV_LEN, lm->msgid, lm->type);
d117 2
a118 3
	feclen = ntohs(ft->length);
	buf += sizeof(struct fec_tlv);
	len -= sizeof(struct fec_tlv);
d120 2
a121 2
	if (len < feclen + LABEL_TLV_LEN) {
		session_shutdown(nbr, S_BAD_TLV_LEN, lm->msgid, lm->type);
d125 2
a126 2
	bzero(&map, sizeof(map));
	map.messageid = lm->msgid;
d128 7
a134 4
	lt = (struct label_tlv *)(buf + feclen);
	map.label = tlv_decode_label(lt);
	if (map.label == NO_LABEL) {
		session_shutdown(nbr, S_BAD_TLV_VAL, lm->msgid, lm->type);
a136 1
	/* TODO opt label request msg id */
d138 5
d147 1
a147 2
			session_shutdown(nbr, S_BAD_TLV_VAL, lm->msgid,
			    lm->type);
d160 1
a160 1
	return (ntohs(lm->length));
d203 5
a207 5
	struct ldp_msg	*lr;
	struct fec_tlv	*ft;
	struct map	 map;
	int		 feclen, tlen;
	u_int8_t	 addr_type;
d209 3
a211 1
	if (nbr->state != NBR_STA_OPER)
d213 1
d215 1
a215 1
	lr = (struct ldp_msg *)buf;
d217 5
a221 2
	if ((len - TLV_HDR_LEN) < ntohs(lr->length)) {
		session_shutdown(nbr, S_BAD_MSG_LEN, lr->msgid, lr->type);
d225 2
a226 4
	buf += sizeof(struct ldp_msg);
	len -= sizeof(struct ldp_msg);

	ft = (struct fec_tlv *)buf;
d228 2
a229 3
	if (len < sizeof(*ft) ||
	    (len - TLV_HDR_LEN) < ntohs(ft->length)) {
		session_shutdown(nbr, S_BAD_TLV_LEN, lr->msgid, lr->type);
d233 4
a236 3
	feclen = ntohs(ft->length);
	buf += sizeof(struct fec_tlv);
	len -= sizeof(struct fec_tlv);
d239 1
a239 2
	map.messageid = lr->msgid;

d244 1
a244 2
			session_shutdown(nbr, S_BAD_TLV_VAL, lr->msgid,
			    lr->type);
d257 1
a257 1
	return (ntohs(lr->length));
d308 6
a313 6
	struct map	 map;
	struct ldp_msg	*lw;
	struct fec_tlv	*ft;
	u_int32_t	 optlabel = NO_LABEL;
	int		 feclen, tlen, numfec = 0;
	u_int8_t	 addr_type;
d315 3
a317 1
	if (nbr->state != NBR_STA_OPER)
d319 1
d321 1
a321 1
	lw = (struct ldp_msg *)buf;
d323 5
a327 2
	if ((len - TLV_HDR_LEN) < ntohs(lw->length)) {
		session_shutdown(nbr, S_BAD_MSG_LEN, lw->msgid, lw->type);
d331 2
a332 4
	buf += sizeof(struct ldp_msg);
	len -= sizeof(struct ldp_msg);

	ft = (struct fec_tlv *)buf;
d334 2
a335 3
	if (len < sizeof(*ft) ||
	    (len - TLV_HDR_LEN) < ntohs(ft->length)) {
		session_shutdown(nbr, S_BAD_TLV_LEN, lw->msgid, lw->type);
d339 2
a340 3
	feclen = ntohs(ft->length);
	buf += sizeof(struct fec_tlv);
	len -= sizeof(struct fec_tlv);
d342 3
a344 3
	/* release may include optional label */
	if (len >= feclen) {
		struct label_tlv	*lt;
d346 4
a349 5
		lt = (struct label_tlv *)(buf + feclen);
		optlabel = tlv_decode_label(lt);
		if (optlabel == NO_LABEL) {
			session_shutdown(nbr, S_BAD_TLV_VAL, lw->msgid,
			    lw->type);
d355 3
a357 3
	map.messageid = lw->msgid;
	if (optlabel != NO_LABEL) {
		map.label = optlabel;
d363 1
a363 2
			session_shutdown(nbr, S_BAD_TLV_VAL, lw->msgid,
			    lw->type);
d370 2
a371 2
				session_shutdown(nbr, S_BAD_TLV_VAL, lw->msgid,
				    lw->type);
d381 2
a382 2
				session_shutdown(nbr, S_BAD_TLV_VAL, lw->msgid,
				    lw->type);
d398 1
a398 1
	return (ntohs(lw->length));
d449 6
a454 6
	struct map	 map;
	struct ldp_msg	*lr;
	struct fec_tlv	*ft;
	u_int32_t	 optlabel = NO_LABEL;
	int		 feclen, tlen, numfec = 0;
	u_int8_t	 addr_type;
d456 3
a458 1
	if (nbr->state != NBR_STA_OPER)
d460 1
d462 1
a462 1
	lr = (struct ldp_msg *)buf;
d464 5
a468 2
	if ((len - TLV_HDR_LEN) < ntohs(lr->length)) {
		session_shutdown(nbr, S_BAD_MSG_LEN, lr->msgid, lr->type);
d472 2
a473 4
	buf += sizeof(struct ldp_msg);
	len -= sizeof(struct ldp_msg);

	ft = (struct fec_tlv *)buf;
d475 2
a476 3
	if (len < sizeof(*ft) ||
	    (len - TLV_HDR_LEN) < ntohs(ft->length)) {
		session_shutdown(nbr, S_BAD_TLV_LEN, lr->msgid, lr->type);
d480 2
a481 3
	feclen = ntohs(ft->length);
	buf += sizeof(struct fec_tlv);
	len -= sizeof(struct fec_tlv);
d484 2
a485 2
	if (len >= feclen) {
		struct label_tlv	*lt;
d487 4
a490 5
		lt = (struct label_tlv *)(buf + feclen);
		optlabel = tlv_decode_label(lt);
		if (optlabel == NO_LABEL) {
			session_shutdown(nbr, S_BAD_TLV_VAL, lr->msgid,
			    lr->type);
d496 3
a498 3
	map.messageid = lr->msgid;
	if (optlabel != NO_LABEL) {
		map.label = optlabel;
d504 1
a504 2
			session_shutdown(nbr, S_BAD_TLV_VAL, lr->msgid,
			    lr->type);
d511 2
a512 2
				session_shutdown(nbr, S_BAD_TLV_VAL, lr->msgid,
				    lr->type);
d522 2
a523 2
				session_shutdown(nbr, S_BAD_TLV_VAL, lr->msgid,
				    lr->type);
d538 1
a538 1
	return (ntohs(lr->length));
d568 11
a578 1
	struct ldp_msg	*la;
d582 7
a588 1
	if (nbr->state != NBR_STA_OPER)
d590 1
d592 2
a593 1
	la = (struct ldp_msg *)buf;
d595 2
a596 2
	if ((len - TLV_HDR_LEN) < ntohs(la->length)) {
		session_shutdown(nbr, S_BAD_MSG_LEN, la->msgid, la->type);
d600 30
a629 2
	buf += sizeof(struct ldp_msg);
	len -= sizeof(struct ldp_msg);
d631 3
a633 1
	/* XXX XXX XXX */
d637 1
a637 1
	return (ntohs(la->length));
d653 2
a654 2
u_int32_t
tlv_decode_label(struct label_tlv *lt)
d656 1
a656 2
	if (lt->type != htons(TLV_TYPE_GENERICLABEL))
		return (NO_LABEL);
d658 9
a666 2
	if (ntohs(lt->length) != sizeof(lt->label))
		return (NO_LABEL);
d668 3
a670 1
	return (ntohl(lt->label));
d685 2
a686 2
u_int32_t
tlv_decode_reqid(struct reqid_tlv *rt)
d688 1
a688 2
	if (rt->type != htons(TLV_TYPE_LABELREQUEST))
		return (NO_LABEL);
d690 6
a695 2
	if (ntohs(rt->length) != sizeof(rt->reqid))
		return (NO_LABEL);
d697 6
a702 1
	return (ntohl(rt->reqid));
d704 1
@


1.15
log
@For label release and withdraw messages make sure that a wildcard
FEC is the one and only FEC of that message. This is required by
the RFC. While it is not correct to have multiple FEC in anything
but label mapping messages ldpd will accept those since the RFC
is extra vague about this feature and it does not hurt.
@
text
@d1 1
a1 1
/*	$OpenBSD: labelmapping.c,v 1.14 2010/10/26 12:22:35 claudio Exp $ */
d40 2
a42 1
void		gen_label_tlv(struct ibuf *, u_int32_t);
d45 1
d71 2
d78 2
d140 1
d592 48
a661 24
}

void
gen_label_tlv(struct ibuf *buf, u_int32_t label)
{
	struct label_tlv	lt;

	lt.type = htons(TLV_TYPE_GENERICLABEL);
	lt.length = htons(sizeof(label));
	lt.label = htonl(label);

	ibuf_add(buf, &lt, sizeof(lt));
}

u_int32_t
tlv_decode_label(struct label_tlv *lt)
{
	if (lt->type != htons(TLV_TYPE_GENERICLABEL))
		return (NO_LABEL);

	if (ntohs(lt->length) != sizeof(lt->label))
		return (NO_LABEL);

	return (ntohl(lt->label));
@


1.14
log
@struct mapping_entry should just have a struct map instead of own
definition of a FEC mapping. This makes extending struct map simpler
and makes it possible to access the additional data in struct map.
@
text
@d1 1
a1 1
/*	$OpenBSD: labelmapping.c,v 1.13 2010/06/30 01:47:11 claudio Exp $ */
d303 1
a303 1
	int		 feclen, tlen;
d359 6
d368 9
a376 2

		} else
d378 1
d444 1
a444 1
	int		 feclen, tlen;
d500 6
d510 7
a516 1
		} else
d518 1
@


1.13
log
@Switch prefix in struct map to a struct in_addr instead of a u_int32_t.
Needed for further clean etc.
@
text
@d1 1
a1 1
/*	$OpenBSD: labelmapping.c,v 1.12 2010/06/09 14:01:03 claudio Exp $ */
d40 1
a40 1
void		gen_fec_tlv(struct ibuf *, u_int32_t, u_int8_t);
d68 1
a68 1
		tlv_size = BASIC_LABEL_MAP_LEN + PREFIX_SIZE(me->prefixlen);
d72 2
a73 2
		gen_fec_tlv(buf, me->prefix, me->prefixlen);
		gen_label_tlv(buf, me->label);
d177 1
a177 1
		tlv_size = PREFIX_SIZE(me->prefixlen);
d181 1
a181 1
		gen_fec_tlv(buf, me->prefix, me->prefixlen);
d272 2
a273 2
		if (me->label == NO_LABEL)
			tlv_size = PREFIX_SIZE(me->prefixlen);
d276 1
a276 1
			    PREFIX_SIZE(me->prefixlen);
d281 1
a281 1
		gen_fec_tlv(buf, me->prefix, me->prefixlen);
d283 2
a284 2
		if (me->label != NO_LABEL)
			gen_label_tlv(buf, me->label);
d399 2
a400 2
		if (me->label == NO_LABEL)
			tlv_size = PREFIX_SIZE(me->prefixlen);
d403 1
a403 1
			    PREFIX_SIZE(me->prefixlen);
d408 1
a408 1
		gen_fec_tlv(buf, me->prefix, me->prefixlen);
d410 2
a411 2
		if (me->label != NO_LABEL)
			gen_label_tlv(buf, me->label);
d558 1
a558 1
gen_fec_tlv(struct ibuf *buf, u_int32_t prefix, u_int8_t prefixlen)
@


1.12
log
@Move the logging of FEC changes to the LDE and print the FEC and label
information. This is more useful.
OK michele
@
text
@d1 1
a1 1
/*	$OpenBSD: labelmapping.c,v 1.11 2010/05/26 13:56:07 nicm Exp $ */
d137 1
a137 1
		    &map.prefix, &map.prefixlen)) == -1 ||
d232 1
a232 1
		    &map.prefix, &map.prefixlen)) == -1 ||
d352 1
a352 1
		    &map.prefix, &map.prefixlen)) == -1) {
d359 1
a359 1
			map.prefix = 0;
d479 1
a479 1
		    &map.prefix, &map.prefixlen)) == -1) {
d486 1
a486 1
			map.prefix = 0;
@


1.11
log
@Rename some imsg bits to make namespace collisions less likely buf to
ibuf, buf_read to ibuf_read, READ_BUF_SIZE to IBUF_READ_SIZE.

ok henning gilles claudio jacekm deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: labelmapping.c,v 1.10 2010/05/25 09:40:10 claudio Exp $ */
a58 2
	log_debug("send_labelmapping: neighbor ID %s", inet_ntoa(nbr->id));

a94 2
	log_debug("recv_labelmapping: neighbor ID %s", inet_ntoa(nbr->id));

a167 2
	log_debug("send_labelrequest: neighbor ID %s", inet_ntoa(nbr->id));

a201 2
	log_debug("recv_labelrequest: neighbor ID %s", inet_ntoa(nbr->id));

a262 2
	log_debug("send_labelwithdraw: neighbor ID %s", inet_ntoa(nbr->id));

a305 2
	log_debug("recv_labelwithdraw: neighbor ID %s", inet_ntoa(nbr->id));

a389 2
	log_debug("send_labelrelease: neighbor ID %s", inet_ntoa(nbr->id));

a432 2
	log_debug("recv_labelrelease: neighbor ID %s", inet_ntoa(nbr->id));

a513 2

	log_debug("send_labelabortreq: neighbor ID %s", inet_ntoa(nbr->id));
@


1.10
log
@Implement the missing label map recv functions and cleanup the other recv
functions a bit to make them all look more similar. All but the label req
abort message are now parsed and passed to the lde.
@
text
@d1 1
a1 1
/*	$OpenBSD: labelmapping.c,v 1.9 2010/05/17 08:07:04 claudio Exp $ */
d40 2
a41 2
void		gen_fec_tlv(struct buf *, u_int32_t, u_int8_t);
void		gen_label_tlv(struct buf *, u_int32_t);
d51 1
a51 1
	struct buf		*buf;
d61 1
a61 1
	if ((buf = buf_open(LDP_MAX_LEN)) == NULL)
d81 1
a81 1
	ldp_hdr = buf_seek(buf, 0, sizeof(struct ldp_hdr));
d164 1
a164 1
	struct buf		*buf;
d174 1
a174 1
	if ((buf = buf_open(LDP_MAX_LEN)) == NULL)
d193 1
a193 1
	ldp_hdr = buf_seek(buf, 0, sizeof(struct ldp_hdr));
d263 1
a263 1
	struct buf		*buf;
d273 1
a273 1
	if ((buf = buf_open(LDP_MAX_LEN)) == NULL)
d300 1
a300 1
	ldp_hdr = buf_seek(buf, 0, sizeof(struct ldp_hdr));
d394 1
a394 1
	struct buf		*buf;
d404 1
a404 1
	if ((buf = buf_open(LDP_MAX_LEN)) == NULL)
d431 1
a431 1
	ldp_hdr = buf_seek(buf, 0, sizeof(struct ldp_hdr));
d525 1
a525 1
	struct buf	*buf;
d533 1
a533 1
	if ((buf = buf_open(LDP_MAX_LEN)) == NULL)
d576 1
a576 1
gen_fec_tlv(struct buf *buf, u_int32_t prefix, u_int8_t prefixlen)
d588 1
a588 1
	buf_add(buf, &ft, sizeof(ft));
d593 3
a595 3
	buf_add(buf, &type, sizeof(type));
	buf_add(buf, &family, sizeof(family));
	buf_add(buf, &prefixlen, sizeof(prefixlen));
d597 1
a597 1
		buf_add(buf, &prefix, len);
d601 1
a601 1
gen_label_tlv(struct buf *buf, u_int32_t label)
d609 1
a609 1
	buf_add(buf, &lt, sizeof(lt));
@


1.9
log
@The host address encoding of FEC was killed in RFC5036 and we're happy
about that. OK michele@@
@
text
@d1 1
a1 1
/*	$OpenBSD: labelmapping.c,v 1.8 2010/04/15 14:47:12 claudio Exp $ */
d44 2
a45 3
u_int32_t	decode_fec_elm(char *);
int		decode_fec_len_elm(char *, u_int8_t);
int		validate_fec_elm(char *);
d94 2
a95 1
	int			 feclen, addr_type;
a101 1
	bzero(&map, sizeof(map));
a112 1
	lt = (struct label_tlv *)(buf + TLV_HDR_LEN + ntohs(ft->length));
d114 2
a115 1
	if (len < (sizeof(*ft) + LABEL_TLV_LEN)) {
d121 4
a124 1
	if (len - TLV_HDR_LEN < feclen) {
d129 4
d139 4
a142 6
	buf += sizeof(struct fec_tlv);
	len -= sizeof(struct fec_tlv);

	while (feclen >= FEC_ELM_MIN_LEN) {
		addr_type = validate_fec_elm(buf);
		if (addr_type < 0) {
a147 4
		map.prefix = decode_fec_elm(buf);
		map.prefixlen = decode_fec_len_elm(buf, addr_type);
		map.prefix &= prefixlen2mask(map.prefixlen);

d151 3
a153 3
		buf += FEC_ELM_MIN_LEN + PREFIX_SIZE(map.prefixlen);
		feclen -= (FEC_ELM_MIN_LEN + PREFIX_SIZE(map.prefixlen));
	}
d205 2
a206 1
	int		 feclen, addr_type;
a212 1
	bzero(&map, sizeof(map));
a231 1

d235 7
a241 3
	while (feclen >= FEC_ELM_MIN_LEN) {
		addr_type = validate_fec_elm(buf);
		if (addr_type < 0) {
a246 5
		map.prefix = decode_fec_elm(buf);
		map.prefixlen = decode_fec_len_elm(buf, addr_type);
		map.prefix &= prefixlen2mask(map.prefixlen);
		map.messageid = lr->msgid;

d250 3
a252 3
		buf += FEC_ELM_MIN_LEN + PREFIX_SIZE(map.prefixlen);
		feclen -= (FEC_ELM_MIN_LEN + PREFIX_SIZE(map.prefixlen));
	}
d309 6
a314 1
	struct ldp_msg		*lw;
d331 53
a383 1
	/* XXX XXX */
d440 6
a445 1
	struct ldp_msg		*lr;
d462 53
a514 1
	/* XXX XXX XXX */
d625 2
a626 1
validate_fec_elm(char *buf)
d628 1
a628 2
	u_int16_t	*family;
	u_int8_t	 type;
d630 2
a631 1
	type = *buf;
d633 6
a638 2
	if (type != FEC_WILDCARD && type != FEC_PREFIX)
		return (-1);
d640 2
a641 2
	buf += sizeof(u_int8_t);
	family = (u_int16_t *)buf;
d643 2
a644 2
	if (*family != htons(FEC_IPV4))
		return (-1);
d646 2
a647 2
	return (type);
}
d649 2
a650 4
u_int32_t
decode_fec_elm(char *buf)
{
	struct fec_elm *fe = (struct fec_elm *)buf;
d652 2
a653 2
	return (fe->addr);
}
d655 2
a656 8
int
decode_fec_len_elm(char *buf, u_int8_t type)
{
	u_int8_t len;

	/* Skip type and family */
	buf += sizeof(u_int8_t);
	buf += sizeof(u_int16_t);
d658 2
a659 1
	len = *buf;
d661 1
a661 10
	switch (type) {
	case FEC_PREFIX:
		return (len);
	case FEC_WILDCARD:
		return (0);
	default:
		/* Should not happen */
		return (-1);
	}
	/* NOTREACHED */
@


1.8
log
@Even though label withdraw, release, and abort requests are not fully
implemented use a correct return value so that ldpd has a chance to survive
when one of those messages are received.
OK michele@@
@
text
@d1 1
a1 1
/*	$OpenBSD: labelmapping.c,v 1.7 2010/02/25 17:40:46 claudio Exp $ */
d520 1
a520 2
	if (type != FEC_WILDCARD && type != FEC_PREFIX &&
	    type != FEC_ADDRESS)
a553 2
	case FEC_ADDRESS:
		return (len * 8);
d555 1
a555 1
		/* XXX: not handled for now */
a559 1

a560 1
	return (-1);
@


1.7
log
@Do not use bufferevent for something that's already covered in the imsg
buffer API. This fixes a few possible problems in session_read and does
some further cleanup in various places. Wrap msgbuf into evbuf to add
libevent functionality and use buf_read to handle the read side of a
session.  OK michele@@ and dlg@@ did not see anything evil
@
text
@d1 1
a1 1
/*	$OpenBSD: labelmapping.c,v 1.6 2010/02/22 09:44:04 claudio Exp $ */
d258 1
a258 1
	return (0);
d328 2
d332 1
a332 1
	return (0);
d402 2
d406 1
a406 1
	return (0);
d455 2
d459 1
a459 1
	return (0);
@


1.6
log
@Correctly encode FEC prefixes. This makes my test setup much happyer.
OK michele
@
text
@d1 1
a1 1
/*	$OpenBSD: labelmapping.c,v 1.5 2010/02/20 21:28:39 michele Exp $ */
d85 1
a85 2
	bufferevent_write(nbr->bev, buf->buf, buf->wpos);
	buf_free(buf);
d196 1
a196 2
	bufferevent_write(nbr->bev, buf->buf, buf->wpos);
	buf_free(buf);
d305 1
a305 3
	bufferevent_write(nbr->bev, buf->buf, buf->wpos);

	buf_free(buf);
d377 1
a377 2
	bufferevent_write(nbr->bev, buf->buf, buf->wpos);
	buf_free(buf);
d428 1
a428 3
	bufferevent_write(nbr->bev, buf->buf, buf->wpos);

	buf_free(buf);
@


1.5
log
@Make send_* functions return void (and not int) as they can just succeed
or fatal().

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: labelmapping.c,v 1.4 2009/12/30 11:05:58 michele Exp $ */
d71 1
a71 1
		tlv_size = BASIC_LABEL_MAP_LEN + me->prefixlen/8;
d152 2
a153 2
		buf += FEC_ELM_MIN_LEN + map.prefixlen/8;
		feclen -= (FEC_ELM_MIN_LEN + map.prefixlen/8);
d184 1
a184 1
		tlv_size = me->prefixlen/8;
d254 2
a255 2
		buf += FEC_ELM_MIN_LEN + map.prefixlen/8;
		feclen -= (FEC_ELM_MIN_LEN + map.prefixlen/8);
d287 1
a287 1
			tlv_size = me->prefixlen/8;
d289 2
a290 1
			tlv_size = BASIC_LABEL_MAP_LEN + me->prefixlen/8;
d361 1
a361 1
			tlv_size = me->prefixlen/8;
d363 2
a364 1
			tlv_size = BASIC_LABEL_MAP_LEN + me->prefixlen/8;
a470 1
	u_int32_t	addr;
d472 1
d474 2
a475 1
	ft.length = htons(sizeof(ft) + (int)(prefixlen/8));
d479 1
a479 7
	if (prefixlen == 32) {
		type = FEC_ADDRESS;
		len = prefixlen/8;
	} else {
		type = FEC_PREFIX;
		len = prefixlen;
	}
a480 1
	addr = prefix;
d484 3
a486 2
	buf_add(buf, &len, sizeof(len));
	buf_add(buf, &addr, (int)(prefixlen/8));
@


1.4
log
@Correctly parse the host address in the FEC TLV.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: labelmapping.c,v 1.3 2009/12/10 21:47:11 michele Exp $ */
d49 1
a49 1
int
d58 1
a58 1
		return (0);
a86 2

	return (0);
d162 1
a162 1
int
d171 1
a171 1
		return (0);
a198 2

	return (0);
d264 1
a264 1
int
d273 1
a273 1
		return (0);
a308 2

	return (0);
d337 1
a337 1
int
d346 1
a346 1
		return (0);
a380 2

	return (0);
d409 1
a409 1
int
d416 1
a416 1
		return (0);
a433 2

	return (0);
@


1.3
log
@Length of the host address in the FEC TLV must be encoded in number
of octets.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: labelmapping.c,v 1.2 2009/06/05 22:34:45 michele Exp $ */
d45 1
a45 1
u_int8_t	decode_fec_len_elm(char *);
d98 1
a98 1
	int			 feclen;
d140 2
a141 1
		if (validate_fec_elm(buf) < 0) {
d148 1
a148 1
		map.prefixlen = decode_fec_len_elm(buf);
d211 1
a211 1
	int		 feclen;
d243 2
a244 1
		if (validate_fec_elm(buf) < 0) {
d251 1
a251 1
		map.prefixlen = decode_fec_len_elm(buf);
d530 1
d532 4
a535 2
	if (*buf != FEC_WILDCARD && *buf != FEC_PREFIX && *buf !=
	    FEC_ADDRESS)
d544 1
a544 1
	return (0);
d555 2
a556 2
u_int8_t
decode_fec_len_elm(char *buf)
d558 2
d564 16
a579 1
	return (*buf);
@


1.2
log
@Correctly send notification messages when errors occur.

ok claudio@@ laurent@@
@
text
@d1 1
a1 1
/*	$OpenBSD: labelmapping.c,v 1.1 2009/06/01 20:59:45 michele Exp $ */
d484 1
a484 1
	if (prefixlen == 32)
d486 2
a487 1
	else
d489 2
a491 1
	len = prefixlen;
@


1.1
log
@Welcome ldpd, the Label Distribution Protocol daemon.
Built using the imsg/three process framework, its main aim
is to redistribute MPLS labels between peers.

Right now it has some really basic functionalities,
the basic protocol works and peers are able to exchange
labels and insert them in the kernel.
It still does not react to changes of topology.

Not yet connected to the builds.

ok claudio@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
a97 1
	u_int32_t		 messageid;
d109 1
a109 1
		/* XXX: send notification */
a112 2
	messageid = lm->msgid;

d120 1
a120 1
		/* XXX: send notification */
d126 1
a126 1
		/* XXX: send notification */
d132 1
a132 3
		log_debug("recv_labelmapping: packet malformed from "
		    "neighbor ID %s", inet_ntoa(nbr->id));
		/* XXX: send notification */
d141 2
a142 1
			/* XXX: send notification */
a209 1
	u_int32_t	 messageid;
d221 1
a221 1
		/* XXX: send notification */
a224 2
	messageid = lr->msgid;

d232 1
a232 1
		/* XXX: send notification */
d243 2
a244 1
			/* XXX: send notification */
d251 1
a251 1
		map.messageid = messageid;
a318 1
	u_int32_t		 messageid;
d328 1
a328 1
		/* XXX: send notification */
a331 2
	messageid = lw->msgid;

a392 1
	u_int32_t		 messageid;
d402 1
a402 1
		/* XXX: send notification */
a405 2
	messageid = lr->msgid;

a447 1
	u_int32_t	 messageid;
d457 1
a457 1
		/* XXX: send notification */
a460 2
	messageid = la->msgid;

d513 1
a513 2
	if (lt->type != htons(TLV_TYPE_GENERICLABEL)) {
		/* XXX: send notification */
a514 1
	}
d516 1
a516 2
	if (ntohs(lt->length) != sizeof(lt->label)) {
		/* XXX: send notification */
a517 1
	}
d528 1
a528 2
	    FEC_ADDRESS) {
		/* XXX: send notification */
a529 1
	}
d534 1
a534 2
	if (*family != htons(FEC_IPV4)) {
		/* XXX: send notification */
a535 1
	}
@

