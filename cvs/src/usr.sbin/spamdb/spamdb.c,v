head	1.31;
access;
symbols
	OPENBSD_6_1_BASE:1.31
	OPENBSD_6_0:1.30.0.4
	OPENBSD_6_0_BASE:1.30
	OPENBSD_5_9:1.30.0.2
	OPENBSD_5_9_BASE:1.30
	OPENBSD_5_8:1.29.0.10
	OPENBSD_5_8_BASE:1.29
	OPENBSD_5_7:1.29.0.2
	OPENBSD_5_7_BASE:1.29
	OPENBSD_5_6:1.29.0.6
	OPENBSD_5_6_BASE:1.29
	OPENBSD_5_5:1.29.0.4
	OPENBSD_5_5_BASE:1.29
	OPENBSD_5_4:1.26.0.2
	OPENBSD_5_4_BASE:1.26
	OPENBSD_5_3:1.25.0.2
	OPENBSD_5_3_BASE:1.25
	OPENBSD_5_2:1.24.0.18
	OPENBSD_5_2_BASE:1.24
	OPENBSD_5_1_BASE:1.24
	OPENBSD_5_1:1.24.0.16
	OPENBSD_5_0:1.24.0.14
	OPENBSD_5_0_BASE:1.24
	OPENBSD_4_9:1.24.0.12
	OPENBSD_4_9_BASE:1.24
	OPENBSD_4_8:1.24.0.10
	OPENBSD_4_8_BASE:1.24
	OPENBSD_4_7:1.24.0.6
	OPENBSD_4_7_BASE:1.24
	OPENBSD_4_6:1.24.0.8
	OPENBSD_4_6_BASE:1.24
	OPENBSD_4_5:1.24.0.4
	OPENBSD_4_5_BASE:1.24
	OPENBSD_4_4:1.24.0.2
	OPENBSD_4_4_BASE:1.24
	OPENBSD_4_3:1.23.0.4
	OPENBSD_4_3_BASE:1.23
	OPENBSD_4_2:1.23.0.2
	OPENBSD_4_2_BASE:1.23
	OPENBSD_4_1:1.22.0.2
	OPENBSD_4_1_BASE:1.22
	OPENBSD_4_0:1.16.0.2
	OPENBSD_4_0_BASE:1.16
	OPENBSD_3_9:1.14.0.6
	OPENBSD_3_9_BASE:1.14
	OPENBSD_3_8:1.14.0.4
	OPENBSD_3_8_BASE:1.14
	OPENBSD_3_7:1.14.0.2
	OPENBSD_3_7_BASE:1.14
	OPENBSD_3_6:1.11.0.2
	OPENBSD_3_6_BASE:1.11
	OPENBSD_3_5:1.7.0.2
	OPENBSD_3_5_BASE:1.7;
locks; strict;
comment	@ * @;


1.31
date	2016.11.29.17.21.52;	author mestre;	state Exp;
branches;
next	1.30;
commitid	kkyMvhtSwMliSuvB;

1.30
date	2015.11.11.16.10.21;	author deraadt;	state Exp;
branches;
next	1.29;
commitid	jTGyznw1AVY3vliA;

1.29
date	2013.11.24.01.06.19;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	2013.11.15.22.20.04;	author millert;	state Exp;
branches;
next	1.27;

1.27
date	2013.08.21.16.13.29;	author millert;	state Exp;
branches;
next	1.26;

1.26
date	2013.04.22.19.49.36;	author otto;	state Exp;
branches;
next	1.25;

1.25
date	2012.10.02.15.26.17;	author okan;	state Exp;
branches;
next	1.24;

1.24
date	2008.05.17.10.48.06;	author millert;	state Exp;
branches;
next	1.23;

1.23
date	2007.05.31.20.00.16;	author cnst;	state Exp;
branches;
next	1.22;

1.22
date	2007.02.27.16.22.11;	author otto;	state Exp;
branches;
next	1.21;

1.21
date	2007.02.26.22.50.52;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2007.02.23.22.40.50;	author beck;	state Exp;
branches;
next	1.19;

1.19
date	2007.01.04.21.41.37;	author beck;	state Exp;
branches;
next	1.18;

1.18
date	2006.12.09.20.04.27;	author jmc;	state Exp;
branches;
next	1.17;

1.17
date	2006.12.09.17.13.07;	author beck;	state Exp;
branches;
next	1.16;

1.16
date	2006.04.12.12.53.04;	author dhill;	state Exp;
branches;
next	1.15;

1.15
date	2006.03.15.01.32.08;	author dhill;	state Exp;
branches;
next	1.14;

1.14
date	2005.03.11.23.45.45;	author beck;	state Exp;
branches;
next	1.13;

1.13
date	2005.03.11.23.27.12;	author beck;	state Exp;
branches;
next	1.12;

1.12
date	2005.03.11.23.09.53;	author beck;	state Exp;
branches;
next	1.11;

1.11
date	2004.04.27.21.25.11;	author itojun;	state Exp;
branches;
next	1.10;

1.10
date	2004.04.26.18.21.20;	author itojun;	state Exp;
branches;
next	1.9;

1.9
date	2004.04.25.17.32.17;	author itojun;	state Exp;
branches;
next	1.8;

1.8
date	2004.04.19.18.21.09;	author otto;	state Exp;
branches;
next	1.7;

1.7
date	2004.03.11.18.14.21;	author beck;	state Exp;
branches;
next	1.6;

1.6
date	2004.03.11.18.09.43;	author beck;	state Exp;
branches;
next	1.5;

1.5
date	2004.03.11.17.48.59;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2004.03.01.17.47.07;	author beck;	state Exp;
branches;
next	1.3;

1.3
date	2004.02.26.08.28.57;	author beck;	state Exp;
branches;
next	1.2;

1.2
date	2004.02.26.08.18.56;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	2004.02.26.07.28.55;	author beck;	state Exp;
branches;
next	;


desc
@@


1.31
log
@When action == 0 (spamdb(8) without arguments) it only reads the DB so it only
needs to pledge for "rpath" and for all other cases since it needs to write as
well then give it "rpath wpath".

"seems right" deraadt@@
@
text
@/*	$OpenBSD: spamdb.c,v 1.30 2015/11/11 16:10:21 deraadt Exp $	*/

/*
 * Copyright (c) 2004 Bob Beck.  All rights reserved.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <db.h>
#include <err.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <netdb.h>
#include <ctype.h>
#include <errno.h>
#include <unistd.h>

#include "grey.h"

/* things we may add/delete from the db */
#define WHITE 0
#define TRAPHIT 1
#define SPAMTRAP 2

int	dblist(DB *);
int	dbupdate(DB *, char *, int, int);

int
dbupdate(DB *db, char *ip, int add, int type)
{
	DBT		dbk, dbd;
	struct gdata	gd;
	time_t		now;
	int		r;
	struct addrinfo hints, *res;

	now = time(NULL);
	memset(&hints, 0, sizeof(hints));
	hints.ai_family = PF_UNSPEC;
	hints.ai_socktype = SOCK_DGRAM;	/*dummy*/
	hints.ai_flags = AI_NUMERICHOST;
	if (add && (type == TRAPHIT || type == WHITE)) {
		if (getaddrinfo(ip, NULL, &hints, &res) != 0) {
			warnx("invalid ip address %s", ip);
			goto bad;
		}
		freeaddrinfo(res);
	}
	memset(&dbk, 0, sizeof(dbk));
	dbk.size = strlen(ip);
	dbk.data = ip;
	memset(&dbd, 0, sizeof(dbd));
	if (!add) {
		/* remove entry */
		r = db->get(db, &dbk, &dbd, 0);
		if (r == -1) {
			warn("db->get failed");
			goto bad;
		}
		if (r) {
			warnx("no entry for %s", ip);
			goto bad;
		} else if (db->del(db, &dbk, 0)) {
			warn("db->del failed");
			goto bad;
		}
	} else {
		/* add or update entry */
		r = db->get(db, &dbk, &dbd, 0);
		if (r == -1) {
			warn("db->get failed");
			goto bad;
		}
		if (r) {
			int i;

			/* new entry */
			memset(&gd, 0, sizeof(gd));
			gd.first = now;
			gd.bcount = 1;
			switch (type) {
			case WHITE:
				gd.pass = now;
				gd.expire = now + WHITEEXP;
				break;
			case TRAPHIT:
				gd.expire = now + TRAPEXP;
				gd.pcount = -1;
				break;
			case SPAMTRAP:
				gd.expire = 0;
				gd.pcount = -2;
				/* ensure address is of the form user@@host */
				if (strchr(ip, '@@') == NULL)
					errx(-1, "not an email address: %s", ip);
				/* ensure address is lower case*/
				for (i = 0; ip[i] != '\0'; i++)
					if (isupper((unsigned char)ip[i]))
						ip[i] = tolower((unsigned char)ip[i]);
				break;
			default:
				errx(-1, "unknown type %d", type);
			}
			memset(&dbk, 0, sizeof(dbk));
			dbk.size = strlen(ip);
			dbk.data = ip;
			memset(&dbd, 0, sizeof(dbd));
			dbd.size = sizeof(gd);
			dbd.data = &gd;
			r = db->put(db, &dbk, &dbd, 0);
			if (r) {
				warn("db->put failed");
				goto bad;
			}
		} else {
			if (gdcopyin(&dbd, &gd) == -1) {
				/* whatever this is, it doesn't belong */
				db->del(db, &dbk, 0);
				goto bad;
			}
			gd.pcount++;
			switch (type) {
			case WHITE:
				gd.pass = now;
				gd.expire = now + WHITEEXP;
				break;
			case TRAPHIT:
				gd.expire = now + TRAPEXP;
				gd.pcount = -1;
				break;
			case SPAMTRAP:
				gd.expire = 0; /* XXX */
				gd.pcount = -2;
				break;
			default:
				errx(-1, "unknown type %d", type);
			}

			memset(&dbk, 0, sizeof(dbk));
			dbk.size = strlen(ip);
			dbk.data = ip;
			memset(&dbd, 0, sizeof(dbd));
			dbd.size = sizeof(gd);
			dbd.data = &gd;
			r = db->put(db, &dbk, &dbd, 0);
			if (r) {
				warn("db->put failed");
				goto bad;
			}
		}
	}
	return (0);
 bad:
	return (1);
}

int
dblist(DB *db)
{
	DBT		dbk, dbd;
	struct gdata	gd;
	int		r;

	/* walk db, list in text format */
	memset(&dbk, 0, sizeof(dbk));
	memset(&dbd, 0, sizeof(dbd));
	for (r = db->seq(db, &dbk, &dbd, R_FIRST); !r;
	    r = db->seq(db, &dbk, &dbd, R_NEXT)) {
		char *a, *cp;

		if ((dbk.size < 1) || gdcopyin(&dbd, &gd) == -1) {
			db->close(db);
			errx(1, "bogus size db entry - bad db file?");
		}
		a = malloc(dbk.size + 1);
		if (a == NULL)
			err(1, "malloc");
		memcpy(a, dbk.data, dbk.size);
		a[dbk.size]='\0';
		cp = strchr(a, '\n');
		if (cp == NULL) {
			/* this is a non-greylist entry */
			switch (gd.pcount) {
			case -1: /* spamtrap hit, with expiry time */
				printf("TRAPPED|%s|%lld\n", a,
				    (long long)gd.expire);
				break;
			case -2: /* spamtrap address */
				printf("SPAMTRAP|%s\n", a);
				break;
			default: /* whitelist */
				printf("WHITE|%s|||%lld|%lld|%lld|%d|%d\n", a,
				    (long long)gd.first, (long long)gd.pass,
				    (long long)gd.expire, gd.bcount,
				    gd.pcount);
				break;
			}
		} else {
			char *helo, *from, *to;

			/* greylist entry */
			*cp = '\0';
			helo = cp + 1;
			from = strchr(helo, '\n');
			if (from == NULL) {
				warnx("No from part in grey key %s", a);
				free(a);
				goto bad;
			}
			*from = '\0';
			from++;
			to = strchr(from, '\n');
			if (to == NULL) {
				/* probably old format - print it the
				 * with an empty HELO field instead 
				 * of erroring out.
				 */			  
				printf("GREY|%s|%s|%s|%s|%lld|%lld|%lld|%d|%d\n",
				    a, "", helo, from, (long long)gd.first,
				    (long long)gd.pass, (long long)gd.expire,
				    gd.bcount, gd.pcount);
			
			} else {
				*to = '\0';
				to++;
				printf("GREY|%s|%s|%s|%s|%lld|%lld|%lld|%d|%d\n",
				    a, helo, from, to, (long long)gd.first,
				    (long long)gd.pass, (long long)gd.expire,
				    gd.bcount, gd.pcount);
			}
		}
		free(a);
	}
	db->close(db);
	db = NULL;
	return (0);
 bad:
	db->close(db);
	db = NULL;
	errx(1, "incorrect db format entry");
	/* NOTREACHED */
	return (1);
}

extern char *__progname;

static int
usage(void)
{
	fprintf(stderr, "usage: %s [[-Tt] -a keys] [[-Tt] -d keys]\n", __progname);
	exit(1);
	/* NOTREACHED */
}

int
main(int argc, char **argv)
{
	int i, ch, action = 0, type = WHITE, r = 0, c = 0;
	HASHINFO	hashinfo;
	DB		*db;

	while ((ch = getopt(argc, argv, "adtT")) != -1) {
		switch (ch) {
		case 'a':
			action = 1;
			break;
		case 'd':
			action = 2;
			break;
		case 't':
			type = TRAPHIT;
			break;
		case 'T':
			type = SPAMTRAP;
			break;
		default:
			usage();
			break;
		}
	}
	argc -= optind;
	argv += optind;
	if (action == 0 && type != WHITE)
		usage();
	
	memset(&hashinfo, 0, sizeof(hashinfo));
	db = dbopen(PATH_SPAMD_DB, O_EXLOCK | (action ? O_RDWR : O_RDONLY),
	    0600, DB_HASH, &hashinfo);
	if (db == NULL) {
		err(1, "cannot open %s for %s", PATH_SPAMD_DB,
		    action ? "writing" : "reading");
	}

	if (action == 0) {
		if (pledge("stdio rpath", NULL) == -1)
			err(1, "pledge");
	} else {
		if (pledge("stdio rpath wpath", NULL) == -1)
			err(1, "pledge");
	}

	switch (action) {
	case 0:
		return dblist(db);
	case 1:
		for (i=0; i<argc; i++)
			if (argv[i][0] != '\0') {
				c++;
				r += dbupdate(db, argv[i], 1, type);
			}
		if (c == 0)
			errx(2, "no addresses specified");
		break;
	case 2:
		for (i=0; i<argc; i++)
			if (argv[i][0] != '\0') {
				c++;
				r += dbupdate(db, argv[i], 0, type);
			}
		if (c == 0)
			errx(2, "no addresses specified");
		break;
	default:
		errx(-1, "bad action");
	}
	db->close(db);
	return (r);
}
@


1.30
log
@bottom end of spamdb is just "stdio rpath wpath"
originally from ricardo mestre, but diff was cut down a bit
@
text
@d1 1
a1 1
/*	$OpenBSD: spamdb.c,v 1.29 2013/11/24 01:06:19 deraadt Exp $	*/
d311 7
a317 2
	if (pledge("stdio rpath wpath", NULL) == -1)
		err(1, "pledge");
@


1.29
log
@more unsigned char casts for ctype
ok jca
@
text
@d1 1
a1 1
/*	$OpenBSD: spamdb.c,v 1.28 2013/11/15 22:20:04 millert Exp $	*/
d310 3
@


1.28
log
@Include unistd.h as it is the standard location for getopt().
@
text
@d1 1
a1 1
/*	$OpenBSD: spamdb.c,v 1.27 2013/08/21 16:13:29 millert Exp $	*/
d115 2
a116 2
					if (isupper(ip[i]))
						ip[i] = (char)tolower(ip[i]);
@


1.27
log
@Remove the use of time_t in the greylist db file and use int64_t instead
with backwards compatibility for records with 32-bit times.
OK deraadt@@ beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: spamdb.c,v 1.26 2013/04/22 19:49:36 otto Exp $	*/
d33 1
@


1.26
log
@prepare for more time bits; ok millert@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: spamdb.c,v 1.25 2012/10/02 15:26:17 okan Exp $	*/
d132 1
a132 1
			if (dbd.size != sizeof(gd)) {
a136 1
			memcpy(&gd, dbd.data, sizeof(gd));
d187 1
a187 1
		if ((dbk.size < 1) || dbd.size != sizeof(struct gdata)) {
a190 1
		memcpy(&gd, dbd.data, sizeof(gd));
@


1.25
log
@while it's of little harm, it's also been 5.5 years (and 8 releases),
remove the db conversion from BTREE to HASH.

ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: spamdb.c,v 1.24 2008/05/17 10:48:06 millert Exp $	*/
d203 2
a204 1
				printf("TRAPPED|%s|%d\n", a, gd.expire);
d210 3
a212 2
				printf("WHITE|%s|||%d|%d|%d|%d|%d\n", a,
				    gd.first, gd.pass, gd.expire, gd.bcount,
d236 4
a239 3
				printf("GREY|%s|%s|%s|%s|%d|%d|%d|%d|%d\n",
				    a, "", helo, from, gd.first, gd.pass,
				    gd.expire, gd.bcount, gd.pcount);
d244 4
a247 3
				printf("GREY|%s|%s|%s|%s|%d|%d|%d|%d|%d\n",
				    a, helo, from, to, gd.first, gd.pass,
				    gd.expire, gd.bcount, gd.pcount);
@


1.24
log
@If the -T or -t flag is given, the key must be an email address so check
that it contains an @@ sign.  Prompted by jmc@@, OK beck@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: spamdb.c,v 1.23 2007/05/31 20:00:16 cnst Exp $	*/
d304 2
a305 7
		if (errno == EFTYPE)	
			err(1,
			    "%s is old, run current spamd to convert it",
			    PATH_SPAMD_DB);
		else 
			err(1, "cannot open %s for %s", PATH_SPAMD_DB,
			    action ? "writing" : "reading");
@


1.23
log
@fix PR 5475: 'empty spamtrap address makes corrupted database'; ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: spamdb.c,v 1.22 2007/02/27 16:22:11 otto Exp $	*/
d109 3
@


1.22
log
@open the db read-only if we're only looking. ok millert@@ beck@@
deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: spamdb.c,v 1.21 2007/02/26 22:50:52 millert Exp $	*/
d269 1
a269 1
	int i, ch, action = 0, type = WHITE, r = 0;
d315 6
a320 1
			r += dbupdate(db, argv[i], 1, type);
d324 6
a329 1
			r += dbupdate(db, argv[i], 0, type);
@


1.21
log
@Error out if the -t or -T options are specified without -a or -d.
OK beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: spamdb.c,v 1.20 2007/02/23 22:40:50 beck Exp $	*/
d298 2
a299 2
	db = dbopen(PATH_SPAMD_DB, O_EXLOCK|O_RDWR, 0600, DB_HASH,
	    &hashinfo);
d306 2
a307 1
			err(1, "cannot open %s for writing", PATH_SPAMD_DB);
@


1.20
log
@Make spamd include the HELO/EHLO identification string sent by
the connecting hosts in the tuple key when greylisting. catches
a few more bogus hosts and will let us trap based on HELO later.

Changes spamdb(8) output to include the new field.

ok deraadt@@, jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: spamdb.c,v 1.19 2007/01/04 21:41:37 beck Exp $	*/
d294 2
@


1.19
log
@        Using DB_BTREE for spamd is wrong, order is never required
and the rebalancing really slags big databases. Make spamd use DB_HASH
instead, and convert if the old type is noticed on startup.

Testing by me, djm, ian, others
ok deraadt@@, millert@@, djm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: spamdb.c,v 1.18 2006/12/09 20:04:27 jmc Exp $	*/
d212 1
a212 1
			char *from, *to;
d216 3
a218 3
			from = cp + 1;
			to = strchr(from, '\n');
			if (to == NULL) {
d223 19
a241 5
			*to = '\0';
			to++;
			printf("GREY|%s|%s|%s|%d|%d|%d|%d|%d\n",
			    a, from, to, gd.first, gd.pass, gd.expire,
			    gd.bcount, gd.pcount);
@


1.18
log
@better synopsis/usage and a couple wee fixes;
mostly ok beck
@
text
@d1 1
a1 1
/*	$OpenBSD: spamdb.c,v 1.17 2006/12/09 17:13:07 beck Exp $	*/
d32 1
d256 1
a256 1
	BTREEINFO	btreeinfo;
d281 11
a291 6
	memset(&btreeinfo, 0, sizeof(btreeinfo));
	btreeinfo.cachesize = 8192 * 128;
	db = dbopen(PATH_SPAMD_DB, O_EXLOCK|O_RDWR, 0600, DB_BTREE,
	    &btreeinfo);
	if (db == NULL)
		err(1, "cannot open %s for writing", PATH_SPAMD_DB);
@


1.17
log
@make spamdb take multiple add/delete arguments, thus making it
much easier to do bulk add/deletes without opening and locking the
database for each one. testing by scads of people on tech@@

Ok deraadt@@ jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: spamdb.c,v 1.16 2006/04/12 12:53:04 dhill Exp $	*/
d246 1
a246 1
	fprintf(stderr, "usage: %s [-Tt] [-ad] key [key ...]\n", __progname);
@


1.16
log
@delint

ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: spamdb.c,v 1.15 2006/03/15 01:32:08 dhill Exp $	*/
d40 2
a41 2
int	dblist(const char *);
int	dbupdate(const char *, char *, int, int);
d44 1
a44 1
dbupdate(const char *dbname, char *ip, int add, int type)
a45 1
	BTREEINFO	btreeinfo;
a46 1
	DB		*db;
a52 4
	memset(&btreeinfo, 0, sizeof(btreeinfo));
	db = dbopen(dbname, O_EXLOCK|O_RDWR, 0600, DB_BTREE, &btreeinfo);
	if (db == NULL)
		err(1, "cannot open %s for writing", dbname);
d57 1
a57 1
	if (type == TRAPHIT || type == WHITE) {
a164 2
	db->close(db);
	db = NULL;
a166 2
	db->close(db);
	db = NULL;
d171 1
a171 1
dblist(const char *dbname)
a172 1
	BTREEINFO	btreeinfo;
a173 1
	DB		*db;
a177 4
	memset(&btreeinfo, 0, sizeof(btreeinfo));
	db = dbopen(dbname, O_EXLOCK|O_RDONLY, 0600, DB_BTREE, &btreeinfo);
	if (db == NULL)
		err(1, "cannot open %s for reading", dbname);
d246 1
a246 1
	fprintf(stderr, "usage: %s [-Tt] [-a key] [-d key]\n", __progname);
d254 3
a256 2
	int ch, action = 0, type = WHITE;
	char *ip = NULL;
d258 1
a258 1
	while ((ch = getopt(argc, argv, "a:d:tT")) != -1) {
a261 1
			ip = optarg;
a264 1
			ip = optarg;
d277 9
d289 1
a289 1
		return dblist(PATH_SPAMD_DB);
d291 3
a293 1
		return dbupdate(PATH_SPAMD_DB, ip, 1, type);
d295 3
a297 1
		return dbupdate(PATH_SPAMD_DB, ip, 0, type);
d301 2
a302 2
	/* NOTREACHED */
	return (0);
@


1.15
log
@Add missing function declarations
Sprinkle some const

OK beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: spamdb.c,v 1.14 2005/03/11 23:45:45 beck Exp $	*/
d117 1
a117 1
						ip[i] = tolower(ip[i]);
d264 1
d305 1
a305 1
	/* NOT REACHED */
@


1.14
log
@freeaddrinfo() isn't needed on the error path from getaddrinfo().
ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: spamdb.c,v 1.13 2005/03/11 23:27:12 beck Exp $	*/
d40 3
d44 1
a44 1
dbupdate(char *dbname, char *ip, int add, int type)
d181 1
a181 1
dblist(char *dbname)
@


1.13
log
@fix usage to reflect new reality, ok jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: spamdb.c,v 1.12 2005/03/11 23:09:53 beck Exp $	*/
a62 1
			freeaddrinfo(res);
@


1.12
log
@"Greytrapping" for spamd - allow for spamd greylisting to maintain
a list of spamtrap destination addresses in the spamd database. When
a spamtrap address gets an attempted greylist delivery, blacklist the
offending host for a day. Does not affect hosts already whitelisted.

ok deraadt@@, jmc@@, dhartmei@@ to get it in so it can be whacked on
@
text
@d1 1
a1 1
/*	$OpenBSD: spamdb.c,v 1.11 2004/04/27 21:25:11 itojun Exp $	*/
d260 1
a260 1
	fprintf(stderr, "usage: %s [-a ip] [-d ip]\n", __progname);
@


1.11
log
@getaddrinfo 4th arg has to be non-null.  Gerard gerritsen
@
text
@d1 1
a1 1
/*	$OpenBSD: spamdb.c,v 1.10 2004/04/26 18:21:20 itojun Exp $	*/
d31 1
d35 5
d41 1
a41 1
dbupdate(char *dbname, char *ip, int add)
d60 7
a66 3
	if (getaddrinfo(ip, NULL, &hints, &res) != 0) {
		warnx("invalid ip address %s", ip);
		goto bad;
a67 1
	freeaddrinfo(res);
d73 1
a73 1
		/* remove whitelist entry */
d87 1
a87 1
		/* add or update whitelist entry */
d94 2
d100 20
a119 2
			gd.pass = now;
			gd.expire = now + WHITEEXP;
d139 17
a155 1
			gd.expire = now + WHITEEXP;
d209 16
a224 5
		if (cp == NULL)
			/* this is a whitelist entry */
			printf("WHITE|%s|||%d|%d|%d|%d|%d\n", a, gd.first,
			    gd.pass, gd.expire, gd.bcount, gd.pcount);
		else {
d267 1
a267 1
	int ch, action = 0;
d270 1
a270 1
	while ((ch = getopt(argc, argv, "a:d:")) != -1) {
d280 6
d296 1
a296 1
		return dbupdate(PATH_SPAMD_DB, ip, 1);
d298 1
a298 1
		return dbupdate(PATH_SPAMD_DB, ip, 0);
@


1.10
log
@bzero hint before use.
@
text
@d1 1
a1 1
/*	$OpenBSD: spamdb.c,v 1.9 2004/04/25 17:32:17 itojun Exp $	*/
d43 1
a43 1
	struct addrinfo hints;
d54 1
a54 1
	if (getaddrinfo(ip, NULL, &hints, NULL) != 0) {
d58 1
@


1.9
log
@use '|' as field separator, not ':' - for future IPv6 support
@
text
@d1 1
a1 1
/*	$OpenBSD: spamdb.c,v 1.8 2004/04/19 18:21:09 otto Exp $	*/
d50 1
@


1.8
log
@Remove unused stuff; give error message if the db cannot be openened; set
exit code.

ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: spamdb.c,v 1.7 2004/03/11 18:14:21 beck Exp $	*/
d30 1
d43 1
a43 1
	struct in_addr	ia;
d50 4
a53 1
	if (inet_pton(AF_INET, ip, &ia) != 1) {
d164 1
a164 1
			printf("WHITE:%s:::%d:%d:%d:%d:%d\n", a, gd.first,
d180 1
a180 1
			printf("GREY:%s:%s:%s:%d:%d:%d:%d:%d\n",
@


1.7
log
@fix leak, found by Patrick Latifi <pat@@eyeo.org>
ok millert@@, dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: spamdb.c,v 1.6 2004/03/11 18:09:43 beck Exp $	*/
a20 4
#include <sys/ioctl.h>
#include <sys/fcntl.h>
#include <sys/wait.h>
#include <net/if.h>
a21 1
#include <net/pfvar.h>
a24 1
#include <errno.h>
a25 1
#include <pwd.h>
a29 1
#include <unistd.h>
a32 22
extern struct passwd *pw;
extern FILE * grey;
extern int debug;

size_t whitecount, whitealloc;
char **whitelist;
int pfdev;

/* borrowed from dhartmei.. */
static int
address_valid_v4(const char *a)
{
	if (!*a)
		return (0);
	while (*a)
		if ((*a >= '0' && *a <= '9') || *a == '.')
			a++;
		else
			return (0);
	return (1);
}

d42 1
d48 3
a50 3
		return(-1);
	if (!address_valid_v4(ip)) {
		warnx("invalid ip address %s\n", ip);
d124 1
a124 1
	return(-1);
d140 1
a140 1
		err(1, "dbopen");
d184 1
a184 1
	return(0);
d190 1
a190 1
	return(-1);
d193 2
d198 1
a198 1
	fprintf(stderr, "usage: spamdb [-a ip] [-d ip]\n");
d226 1
a226 2
		dblist(PATH_SPAMD_DB);
		break;
d228 1
a228 2
		dbupdate(PATH_SPAMD_DB, ip, 1);
		break;
d230 1
a230 2
		dbupdate(PATH_SPAMD_DB, ip, 0);
		break;
d234 2
a235 1
	return(0);
@


1.6
log
@open O_RDONLY when listing
ok millert@@, dharmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: spamdb.c,v 1.5 2004/03/11 17:48:59 millert Exp $	*/
d200 1
d209 1
@


1.5
log
@Remove sync() calls that immediately precede databse close().  Since
close() calls sync() itself the standalone sync() is a no-op.  OK beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: spamdb.c,v 1.4 2004/03/01 17:47:07 beck Exp $	*/
d167 1
a167 1
	db = dbopen(dbname, O_EXLOCK|O_RDWR, 0600, DB_BTREE, &btreeinfo);
@


1.4
log
@paranoia and cleanup, document output format
ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: spamdb.c,v 1.3 2004/02/26 08:28:57 beck Exp $	*/
a146 1
	db->sync(db, 0);
a150 1
	db->sync(db, 0);
a208 1
	db->sync(db, 0);
a212 1
	db->sync(db, 0);
@


1.3
log
@don't double define PATH_SPAMD_DB - notice by pb
@
text
@d1 1
a1 1
/*	$OpenBSD: spamdb.c,v 1.2 2004/02/26 08:18:56 deraadt Exp $	*/
a48 4
DB		*db;
DBT		dbk, dbd;
BTREEINFO	btreeinfo;

d66 6
a71 3
	struct gdata gd;
	time_t now;
	int r;
d161 5
a165 2
	struct gdata gd;
	int r;
d191 1
a191 1
			printf("WHITE:%s:%d:%d:%d:%d:%d\n", a, gd.first,
d255 1
a255 1
		dblist("/var/db/spamd");
d258 1
a258 1
		dbupdate("/var/db/spamd", ip, 1);
d261 1
a261 1
		dbupdate("/var/db/spamd", ip, 0);
@


1.2
log
@paranoia; beck ok
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a39 1
#define PATH_SPAMD_DB "/var/db/spamd"
@


1.1
log
@Add -g option for greylisting support for spamd. The greylisting techinque
originates from a paper by Evan Harris which can be found at
http://projects.puremagic.com/greylisting/. This implementation makes
spamd allow for non-blacklisted addresses to be treated as "greylisted".
where they are tracked in a db file, and whitelisted by addition to a
pf table when the same envelope from and to are retried from the same
source IP address. Testing by many, ok deraadt@@
@
text
@d1 2
d151 1
d156 1
a159 2


d212 1
d217 1
a222 1

d227 1
a227 1
	exit(-1);
@

