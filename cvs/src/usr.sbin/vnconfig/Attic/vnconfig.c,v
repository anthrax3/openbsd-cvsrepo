head	1.28;
access;
symbols
	OPENBSD_4_1:1.25.0.2
	OPENBSD_4_1_BASE:1.25
	OPENBSD_4_0:1.18.0.2
	OPENBSD_4_0_BASE:1.18
	OPENBSD_3_9:1.16.0.6
	OPENBSD_3_9_BASE:1.16
	OPENBSD_3_8:1.16.0.4
	OPENBSD_3_8_BASE:1.16
	OPENBSD_3_7:1.16.0.2
	OPENBSD_3_7_BASE:1.16
	OPENBSD_3_6:1.15.0.2
	OPENBSD_3_6_BASE:1.15
	OPENBSD_3_5:1.12.0.4
	OPENBSD_3_5_BASE:1.12
	OPENBSD_3_4:1.12.0.2
	OPENBSD_3_4_BASE:1.12
	OPENBSD_3_3:1.9.0.6
	OPENBSD_3_3_BASE:1.9
	OPENBSD_3_2:1.9.0.4
	OPENBSD_3_2_BASE:1.9
	OPENBSD_3_1:1.9.0.2
	OPENBSD_3_1_BASE:1.9
	OPENBSD_3_0:1.6.0.6
	OPENBSD_3_0_BASE:1.6
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_9:1.6.0.4
	OPENBSD_2_8:1.6.0.2
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.4.0.4
	OPENBSD_2_7_BASE:1.4
	OPENBSD_2_6:1.4.0.2
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.3.0.10
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.8
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.6
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.4
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.3.0.2
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.28
date	2007.05.26.21.39.46;	author grunk;	state dead;
branches;
next	1.27;

1.27
date	2007.04.10.15.28.55;	author tedu;	state Exp;
branches;
next	1.26;

1.26
date	2007.03.14.17.59.41;	author grunk;	state Exp;
branches;
next	1.25;

1.25
date	2007.02.23.11.00.02;	author grunk;	state Exp;
branches;
next	1.24;

1.24
date	2007.02.17.10.52.28;	author thib;	state Exp;
branches;
next	1.23;

1.23
date	2007.02.08.16.21.09;	author grunk;	state Exp;
branches;
next	1.22;

1.22
date	2007.02.02.08.54.43;	author grunk;	state Exp;
branches;
next	1.21;

1.21
date	2007.01.27.10.34.46;	author grunk;	state Exp;
branches;
next	1.20;

1.20
date	2006.12.26.22.55.20;	author grunk;	state Exp;
branches;
next	1.19;

1.19
date	2006.09.20.13.51.19;	author pedro;	state Exp;
branches;
next	1.18;

1.18
date	2006.07.01.07.36.27;	author jmc;	state Exp;
branches;
next	1.17;

1.17
date	2006.06.30.16.09.27;	author tedu;	state Exp;
branches;
next	1.16;

1.16
date	2004.09.14.22.35.51;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2004.06.27.22.14.38;	author jolan;	state Exp;
branches;
next	1.14;

1.14
date	2004.06.20.19.16.37;	author pedro;	state Exp;
branches;
next	1.13;

1.13
date	2004.06.20.18.04.54;	author pedro;	state Exp;
branches;
next	1.12;

1.12
date	2003.06.24.23.26.58;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2003.06.02.23.36.55;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2003.03.30.12.59.11;	author hugh;	state Exp;
branches;
next	1.9;

1.9
date	2002.02.16.21.28.10;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2001.12.07.00.11.53;	author niklas;	state Exp;
branches;
next	1.7;

1.7
date	2001.11.08.11.20.48;	author mpech;	state Exp;
branches;
next	1.6;

1.6
date	2000.06.30.16.00.27;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2000.06.20.21.29.20;	author provos;	state Exp;
branches;
next	1.4;

1.4
date	99.08.16.19.23.14;	author art;	state Exp;
branches
	1.4.4.1;
next	1.3;

1.3
date	96.12.22.01.46.46;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.12.21.05.07.43;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.48.31;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.48.31;	author deraadt;	state Exp;
branches;
next	;

1.4.4.1
date	2000.10.06.21.24.22;	author jason;	state Exp;
branches;
next	;


desc
@@


1.28
log
@link mount_vnd to the build, and remove usr.sbin/vnconfig, which is now
completely contained at the new place.  provide a legacy link to /usr/sbin
to go away after next release.

ok deraadt@@
@
text
@/*	$OpenBSD: vnconfig.c,v 1.27 2007/04/10 15:28:55 tedu Exp $	*/
/*
 * Copyright (c) 1993 University of Utah.
 * Copyright (c) 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * the Systems Programming Group of the University of Utah Computer
 * Science Department.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * from: Utah $Hdr: vnconfig.c 1.1 93/12/15$
 *
 *	@@(#)vnconfig.c	8.1 (Berkeley) 12/15/93
 */

#include <sys/param.h>
#include <sys/ioctl.h>
#include <sys/mount.h>
#include <sys/stat.h>

#include <dev/vndioctl.h>

#include <blf.h>
#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <pwd.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <util.h>

#include "pkcs5_pbkdf2.h"

#define DEFAULT_VND	"vnd0"

#define VND_CONFIG	1
#define VND_UNCONFIG	2
#define VND_GET		3

int verbose = 0;

__dead void usage(void);
int config(char *, char *, int, char *, size_t);
int getinfo(const char *);
char	*get_pkcs_key(char *, char *);

int
main(int argc, char **argv)
{
	int ch, rv, action = VND_CONFIG;
	char *key = NULL;
	char *rounds = NULL;
	char *saltopt = NULL;
	size_t keylen = 0;
	int opt_c = 0, opt_k = 0;
	int opt_K = 0, opt_l = 0, opt_u = 0;

	while ((ch = getopt(argc, argv, "ckK:luS:v")) != -1) {
		switch (ch) {
		case 'c':
			opt_c = 1;
			break;
		case 'l':
			opt_l = 1;
			break;
		case 'k':
			opt_k = 1;
			break;
		case 'K':
			opt_K = 1;
			rounds = optarg;
			break;
		case 'S':
			saltopt = optarg;
			break;
		case 'u':
			opt_u = 1;
			break;
		case 'v':
			verbose = 1;
			break;
		default:
			usage();
			/* NOTREACHED */
		}
	}

	argc -= optind;
	argv += optind;

	if (opt_c + opt_l + opt_u > 1)
		errx(1, "-c, -l and -u are mutually exclusive options");

	if (opt_l)
		action = VND_GET;
	else if (opt_u)
		action = VND_UNCONFIG;
	else
		action = VND_CONFIG;	/* default behavior */

	if (saltopt && (!opt_K))
		errx(1, "-S only makes sense when used with -K");

	if (action == VND_CONFIG && argc == 2) {
		if (opt_k) {
			if (opt_K)
				errx(1, "-k and -K are mutually exclusive");
			key = getpass("Encryption key: ");
			if (key == NULL || (keylen = strlen(key)) == 0)
				errx(1, "Need an encryption key");
		} else if (opt_K) {
			key = get_pkcs_key(rounds, saltopt);
			keylen = BLF_MAXUTILIZED;
		}
		rv = config(argv[0], argv[1], action, key, keylen);
	} else if (action == VND_UNCONFIG && argc == 1)
		rv = config(argv[0], NULL, action, NULL, 0);
	else if (action == VND_GET)
		rv = getinfo(argc ? argv[0] : NULL);
	else
		usage();

	exit(rv);
}

char *
get_pkcs_key(char *arg, char *saltopt)
{
	char		 keybuf[128], saltbuf[128], saltfilebuf[PATH_MAX];
	char		*saltfile;
	char		*key = NULL;
	const char	*errstr;
	int		 rounds;

	rounds = strtonum(arg, 1000, INT_MAX, &errstr);
	if (errstr)
		err(1, "rounds: %s", errstr);
	key = getpass("Encryption key: ");
	if (!key || strlen(key) == 0)
		errx(1, "Need an encryption key");
	strncpy(keybuf, key, sizeof(keybuf));
	if (saltopt)
		saltfile = saltopt;
	else {
		printf("Salt file: ");
		fflush(stdout);
		saltfile = fgets(saltfilebuf, sizeof(saltfilebuf), stdin);
	}
	if (!saltfile || saltfile[0] == '\n') {
		warnx("Skipping salt file, insecure");
		saltfile = NULL;
	} else {
		size_t len = strlen(saltfile);
		if (saltfile[len - 1] == '\n')
			saltfile[len - 1] = 0;
	}
	if (saltfile) {
		int fd;

		fd = open(saltfile, O_RDONLY);
		if (fd == -1) {
			int *s;

			fprintf(stderr, "Salt file not found, attempting to create one\n");
			fd = open(saltfile, O_RDWR|O_CREAT|O_EXCL, 0600);
			if (fd == -1)
				err(1, "Unable to create salt file: '%s'",
				    saltfile);
			for (s = (int *)saltbuf;
			    s < (int *)(saltbuf + sizeof(saltbuf)); s++)
				*s = arc4random();
			if (write(fd, saltbuf, sizeof(saltbuf))
			    != sizeof(saltbuf))
				err(1, "Unable to write salt file: '%s'", saltfile);
			fprintf(stderr, "Salt file created as '%s'\n", saltfile);
		} else {
			if (read(fd, saltbuf, sizeof(saltbuf))
			    != sizeof(saltbuf))
				err(1, "Unable to read salt file: '%s'", saltfile);
		}
		close(fd);
	} else {
		memset(saltbuf, 0, sizeof(saltbuf));
	}
	if (pkcs5_pbkdf2((u_int8_t**)&key, BLF_MAXUTILIZED, keybuf,
	    sizeof(keybuf), saltbuf, sizeof(saltbuf), rounds, 0))
		errx(1, "pkcs5_pbkdf2 failed");

	return (key);
}

int
getinfo(const char *vname)
{
	int vd, print_all = 0;
	struct vnd_user vnu;

	if (vname == NULL) {
		vname = DEFAULT_VND;
		print_all = 1;
	}

	vd = opendev((char *)vname, O_RDONLY, OPENDEV_PART, NULL);
	if (vd < 0)
		err(1, "open: %s", vname);

	vnu.vnu_unit = -1;

query:
	if (ioctl(vd, VNDIOCGET, &vnu) == -1) {
		if (print_all && errno == ENXIO && vnu.vnu_unit > 0) {
			close(vd);
			return (0);
		} else {
			err(1, "ioctl: %s", vname);
		}
	}

	fprintf(stdout, "vnd%d: ", vnu.vnu_unit);

	if (!vnu.vnu_ino)
		fprintf(stdout, "not in use\n");
	else
		fprintf(stdout, "covering %s on %s, inode %d\n", vnu.vnu_file,
		    devname(vnu.vnu_dev, S_IFBLK), vnu.vnu_ino);

	if (print_all) {
		vnu.vnu_unit++;
		goto query;
	}

	close(vd);

	return (0);
}

int
config(char *dev, char *file, int action, char *key, size_t keylen)
{
	struct vnd_ioctl vndio;
	FILE *f;
	char *rdev;
	int rv;

	if (opendev(dev, O_RDONLY, OPENDEV_PART, &rdev) < 0)
		err(4, "%s", rdev);
	f = fopen(rdev, "r");
	if (f == NULL) {
		warn("%s", rdev);
		rv = -1;
		goto out;
	}
	vndio.vnd_file = file;
	vndio.vnd_key = (u_char *)key;
	vndio.vnd_keylen = keylen;

	/*
	 * Clear (un-configure) the device
	 */
	if (action == VND_UNCONFIG) {
		rv = ioctl(fileno(f), VNDIOCCLR, &vndio);
		if (rv)
			warn("VNDIOCCLR");
		else if (verbose)
			printf("%s: cleared\n", dev);
	}
	/*
	 * Configure the device
	 */
	if (action == VND_CONFIG) {
		rv = ioctl(fileno(f), VNDIOCSET, &vndio);
		if (rv)
			warn("VNDIOCSET");
		else if (verbose)
			printf("%s: %llu bytes on %s\n", dev, vndio.vnd_size,
			    file);
	}

	fclose(f);
	fflush(stdout);
 out:
	if (key)
		memset(key, 0, keylen);
	return (rv < 0);
}

__dead void
usage(void)
{
	extern char *__progname;

	(void)fprintf(stderr,
	    "usage: %s [-ckluv] [-K rounds] [-S saltfile] rawdev regular_file\n",
	    __progname);
	exit(1);
}
@


1.27
log
@if vnconfig can't get the info, it should say so, not just print nothing.
ok grunk pedro
@
text
@d1 1
a1 1
/*	$OpenBSD: vnconfig.c,v 1.26 2007/03/14 17:59:41 grunk Exp $	*/
@


1.26
log
@do the adjustment of arbitrary 128 -> BLF_MAXUTILIZED in userland as well,
also discussed on tech@@ a while ago.

ok pedro@@ tedu@@ thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vnconfig.c,v 1.25 2007/02/23 11:00:02 grunk Exp $	*/
d237 6
a242 2
		close(vd);
		return (!(errno == ENXIO && print_all));
@


1.25
log
@use correct variable in error message:  print the filename, not the key

ok ray@@ thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vnconfig.c,v 1.24 2007/02/17 10:52:28 thib Exp $	*/
d47 1
d139 1
a139 1
			keylen = 128;
d211 2
a212 2
	if (pkcs5_pbkdf2((u_int8_t**)&key, 128, keybuf, sizeof(keybuf),
	    saltbuf, sizeof(saltbuf), rounds, 0))
@


1.24
log
@for -k option, bail out immediately if getpass()
doesnt return sth usefull.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vnconfig.c,v 1.23 2007/02/08 16:21:09 grunk Exp $	*/
d199 1
a199 1
				err(1, "Unable to write salt file: '%s'", key);
@


1.23
log
@prevent vnconfig from asking for a key when unconfiguring or listing devices.
even clarify this further by supplying NULL and 0 to action() for -u case

ok pedro@@, no objections bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vnconfig.c,v 1.22 2007/02/02 08:54:43 grunk Exp $	*/
d134 2
a135 1
			keylen = strlen(key);
@


1.22
log
@Make -c, -l and -u mutually exclusive, they indicate the mode of operation.
Point out that using -S with anything else than -K is useless.

"looks good" pedro@@, no objections otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vnconfig.c,v 1.21 2007/01/27 10:34:46 grunk Exp $	*/
d129 10
a138 11
	if (opt_k) {
		if (opt_K)
			errx(1, "-k and -K are mutually exclusive options");
		key = getpass("Encryption key: ");
		keylen = strlen(key);
	} else if (opt_K) {
		key = get_pkcs_key(rounds, saltopt);
		keylen = 128;
	}

	if (action == VND_CONFIG && argc == 2)
d140 2
a141 2
	else if (action == VND_UNCONFIG && argc == 1)
		rv = config(argv[0], NULL, action, key, keylen);
@


1.21
log
@add an option -S for specifying the salt file for -K .  If not given, user
is prompted like before.

ok tedu@@ pedro@@ otto@@
manpage help and ok jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vnconfig.c,v 1.20 2006/12/26 22:55:20 grunk Exp $	*/
d80 2
a81 2
	int opt_k = 0;
	int opt_K = 0;
d86 1
a86 1
			action = VND_CONFIG;
d89 1
a89 1
			action = VND_GET;
d102 1
a102 1
			action = VND_UNCONFIG;
d115 13
@


1.20
log
@make -k and -K mutually exclusive, and ignore multiple invocations of them.
put pcks key initialization into a separate routine instead of bloating the
getopt() loop.

ok pedro@@ deraadt@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vnconfig.c,v 1.19 2006/09/20 13:51:19 pedro Exp $	*/
d70 1
a70 1
char	*get_pkcs_key(char *);
d78 1
d83 1
a83 1
	while ((ch = getopt(argc, argv, "cluvK:k")) != -1) {
d98 3
d122 1
a122 1
		key = get_pkcs_key(rounds);
d139 1
a139 1
get_pkcs_key(char *arg)
d154 7
a160 3
	printf("Salt file: ");
	fflush(stdout);
	saltfile = fgets(saltfilebuf, sizeof(saltfilebuf), stdin);
d163 1
a163 1
		saltfile = 0;
d301 1
a301 1
	    "usage: %s [-ckluv] [-K rounds] rawdev regular_file\n",
@


1.19
log
@Make vnd(4) work on read-only file systems, from Paul Stoeber, okay tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vnconfig.c,v 1.18 2006/07/01 07:36:27 jmc Exp $	*/
d70 1
d75 1
a75 1
	int ch, rv, rounds, action = VND_CONFIG;
d77 1
d79 2
a80 1
	const char *errstr;
d90 7
a102 66
		case 'K':
		{
			char keybuf[128];
			char saltbuf[128];
			char saltfilebuf[PATH_MAX];
			char *saltfile;

			rounds = strtonum(optarg, 1000, INT_MAX, &errstr);
			if (errstr)
				err(1, "rounds: %s", errstr);
			key = getpass("Encryption key: ");
			if (!key || strlen(key) == 0)
				errx(1, "Need an encryption key");
			strncpy(keybuf, key, sizeof(keybuf));
			printf("Salt file: ");
			fflush(stdout);
			saltfile = fgets(saltfilebuf, sizeof(saltfilebuf),
			    stdin);
			if (!saltfile || saltfile[0] == '\n') {
				warnx("Skipping salt file, insecure");
				saltfile = 0;
			} else {
				size_t len = strlen(saltfile);
				if (saltfile[len - 1] == '\n')
					saltfile[len - 1] = 0;
			}
			if (saltfile) {
				int fd;
				
				fd = open(saltfile, O_RDONLY);
				if (fd == -1) {
					int *s;

					fprintf(stderr, "Salt file not found, attempting to create one\n");
					fd = open(saltfile,
					    O_RDWR|O_CREAT|O_EXCL, 0600);
					if (fd == -1)
						err(1, "Unable to create salt file: '%s'", saltfile);
					for (s = (int *)saltbuf; s <
					    (int *)(saltbuf + sizeof(saltbuf));
					    s++)
						*s = arc4random();
					if (write(fd, saltbuf, sizeof(saltbuf))
					    != sizeof(saltbuf))
						err(1, "Unable to write salt file: '%s'", key);
					fprintf(stderr, "Salt file created as '%s'\n", saltfile);
				} else {
					if (read(fd, saltbuf, sizeof(saltbuf))
					    != sizeof(saltbuf))
						err(1, "Unable to read salt file: '%s'", saltfile);
				}
				close(fd);
			} else {
				memset(saltbuf, 0, sizeof(saltbuf));
			}
			if (pkcs5_pbkdf2((u_int8_t**)&key, 128, keybuf,
			    sizeof(keybuf), saltbuf, sizeof(saltbuf),
			    rounds, 0))
				errx(1, "pkcs5_pbkdf2 failed");
			keylen = 128;
			break;
		}
		case 'k':
			key = getpass("Encryption key: ");
			keylen = strlen(key);
			break;
d112 10
d132 62
@


1.18
log
@simplify synopsis/usage(); ok tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: vnconfig.c,v 1.17 2006/06/30 16:09:27 tedu Exp $	*/
d229 1
a229 1
	if (opendev(dev, O_RDWR, OPENDEV_PART, &rdev) < 0)
d231 1
a231 1
	f = fopen(rdev, "rw");
@


1.17
log
@add -K option which uses a salt file and pkcs5 pbkdf2 to create a
more secure key.  with feedback from djm and markus
pkcs5 pbkdf2 code from netbsd's cgdconfig
@
text
@d1 1
a1 1
/*	$OpenBSD: vnconfig.c,v 1.16 2004/09/14 22:35:51 deraadt Exp $	*/
d277 2
a278 3
	    "usage: %s [-c] [-vk] [-K rounds] rawdev regular-file\n"
	    "       %s -u [-v] rawdev\n"
	    "       %s -l [rawdev]\n", __progname, __progname, __progname);
@


1.16
log
@vnd key is u_char *
@
text
@d1 1
a1 1
/*	$OpenBSD: vnconfig.c,v 1.15 2004/06/27 22:14:38 jolan Exp $	*/
d57 2
d68 1
a68 1
int config(char *, char *, int, char *);
d74 1
a74 1
	int ch, rv, action = VND_CONFIG;
d76 2
d79 1
a79 1
	while ((ch = getopt(argc, argv, "cluvk")) != -1) {
d93 62
d157 1
d169 1
a169 1
		rv = config(argv[0], argv[1], action, key);
d171 1
a171 1
		rv = config(argv[0], NULL, action, key);
d222 1
a222 1
config(char *dev, char *file, int action, char *key)
d239 1
a239 1
	vndio.vnd_keylen = key == NULL ? 0 : strlen(key);
d267 1
a267 1
		memset(key, 0, strlen(key));
d277 1
a277 1
	    "usage: %s [-c] [-vk] rawdev regular-file\n"
@


1.15
log
@cast to quell a warning, ok pedro@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vnconfig.c,v 1.14 2004/06/20 19:16:37 pedro Exp $	*/
d171 1
a171 1
	vndio.vnd_key = key;
@


1.14
log
@mention new -l option, some nitpicks
mdoc tutoring and ok jfb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vnconfig.c,v 1.13 2004/06/20 18:04:54 pedro Exp $	*/
d124 1
a124 1
	vd = opendev(vname, O_RDONLY, OPENDEV_PART, NULL);
@


1.13
log
@make vnconfig use the new VNDIOCGET ioctl to retrieve information about
the status of vnode disks, ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vnconfig.c,v 1.12 2003/06/24 23:26:58 millert Exp $	*/
d211 2
a212 1
	    "       %s -u [-v] rawdev\n", __progname, __progname);
@


1.12
log
@o don't need to include <sys/stat.h>
o include <fcntl.h>, not <sys/fcntl.h>
o mark usage() __dead
o kill '?' in getopt switch
o use __progname in usage()
o ANSI function declarations
Most from Andrey Matveev
@
text
@d1 1
a1 1
/*	$OpenBSD: vnconfig.c,v 1.11 2003/06/02 23:36:55 millert Exp $	*/
d43 1
d57 2
d61 1
d67 1
d75 1
a75 1
	while ((ch = getopt(argc, argv, "cuvk")) != -1) {
d80 3
d97 1
d105 2
d109 1
d111 41
@


1.11
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: vnconfig.c,v 1.10 2003/03/30 12:59:11 hugh Exp $	*/
a42 2
#include <sys/stat.h>
#include <sys/fcntl.h>
d48 1
d61 1
a61 1
void usage(void);
d65 1
a65 3
main(argc, argv)
	int argc;
	char **argv;
a84 1
		case '?':
d102 1
a102 5
config(dev, file, action, key)
	char *dev;
	char *file;
	int action;
	char *key;
d151 2
a152 2
void
usage()
d154 1
d156 3
a158 3
	(void)fprintf(stderr, "%s%s",
	    "usage: vnconfig [-c] [-vk] rawdev regular-file\n",
	    "       vnconfig -u [-v] rawdev\n");
@


1.10
log
@Add rcs tag.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d19 1
a19 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.9
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
@


1.8
log
@Make vnds larger than 2G work, mostly by Daniel Lucq <daniel@@lucq.org>.
@
text
@d65 2
a66 2
void usage __P((void));
int config __P((char *, char *, int, char *));
@


1.7
log
@-c is defualt. minor mdoc changes.
Spotted by form@@.

millert@@ ok +help
@
text
@d150 1
a150 1
			printf("%s: %d bytes on %s\n", dev, vndio.vnd_size,
@


1.6
log
@warnx?/errx? paranoia (use "%s" not a bare string unless it is a
constant).  These are not security holes but it is worth fixing
them anyway both for robustness and so folks looking for examples
in the tree are not misled into doing something potentially dangerous.
Furthermore, it is a bad idea to assume that pathnames will not
include '%' in them and that error routines don't return strings
with '%' in them (especially in light of the possibility of locales).
@
text
@d167 1
a167 1
	    "usage: vnconfig -c [-vk] rawdev regular-file\n",
@


1.5
log
@add encryption for svnd's for Erich <hh@@cyberpass.net>.  You can do a
poor man's encrypted file system with this.  Blame the Greek. okay niklas@@
@
text
@d124 1
a124 1
		warn(rdev);
@


1.4
log
@slight cleanup
@
text
@d53 1
d57 1
d66 1
a66 1
int config __P((char *, char *, int));
d74 1
d76 1
a76 1
	while ((ch = getopt(argc, argv, "cuv")) != -1) {
d87 3
d100 1
a100 1
		rv = config(argv[0], argv[1], action);
d102 1
a102 1
		rv = config(argv[0], NULL, action);
d109 1
a109 1
config(dev, file, action)
d113 1
d125 2
a126 1
		return (1);
d129 2
d156 3
d167 1
a167 1
	    "usage: vnconfig -c [-v] rawdev regular-file\n",
@


1.4.4.1
log
@Pull in patch from current:
Fix (millert):
warnx?/errx? paranoia (use "%s" not a bare string unless it is a
constant).  These are not security holes but it is worth fixing
them anyway both for robustness and so folks looking for examples
in the tree are not misled into doing something potentially dangerous.
Furthermore, it is a bad idea to assume that pathnames will not
include '%' in them and that error routines don't return strings
with '%' in them (especially in light of the possibility of locales).
@
text
@d117 1
a117 1
		warn("%s", rdev);
@


1.3
log
@document that "vnd0" works
@
text
@d64 1
d66 1
d102 1
d143 1
a143 1
done:
@


1.2
log
@use opendev()
@
text
@d151 2
a152 2
	    "usage: vnconfig -c [-v] special-file regular-file\n",
	    "       vnconfig -u [-v] special-file\n");
@


1.1
log
@Initial revision
@
text
@d47 1
d56 1
a62 1
char *rawdevice __P((char *));
d110 2
a111 1
	rdev = rawdevice(dev);
a143 22
}

char *
rawdevice(dev)
	char *dev;
{
	register char *rawbuf, *dp, *ep;
	struct stat sb;
	int len;

	len = strlen(dev);
	rawbuf = malloc(len + 2);
	strcpy(rawbuf, dev);
	if (stat(rawbuf, &sb) != 0 || !S_ISCHR(sb.st_mode)) {
		dp = rindex(rawbuf, '/');
		if (dp) {
			for (ep = &rawbuf[len]; ep > dp; --ep)
				*(ep+1) = *ep;
			*++ep = 'r';
		}
	}
	return (rawbuf);
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
