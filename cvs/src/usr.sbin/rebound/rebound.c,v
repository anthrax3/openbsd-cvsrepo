head	1.89;
access;
symbols
	OPENBSD_6_1:1.80.0.4
	OPENBSD_6_1_BASE:1.80
	OPENBSD_6_0:1.65.0.2
	OPENBSD_6_0_BASE:1.65
	OPENBSD_5_9:1.60.0.2
	OPENBSD_5_9_BASE:1.60;
locks; strict;
comment	@ * @;


1.89
date	2017.07.19.22.51.30;	author tedu;	state Exp;
branches;
next	1.88;
commitid	XW2zVjKpOW60XtMC;

1.88
date	2017.07.13.17.12.51;	author tedu;	state Exp;
branches;
next	1.87;
commitid	5NTApK4Fl6IW1qxz;

1.87
date	2017.07.04.00.30.45;	author tedu;	state Exp;
branches;
next	1.86;
commitid	LfC8SBqmH66QWV1f;

1.86
date	2017.07.03.16.36.48;	author tedu;	state Exp;
branches;
next	1.85;
commitid	GEGCJzwE4OaSBeoz;

1.85
date	2017.07.03.09.39.48;	author tedu;	state Exp;
branches;
next	1.84;
commitid	3lG8kH1jX79HMfSX;

1.84
date	2017.05.31.04.52.11;	author deraadt;	state Exp;
branches;
next	1.83;
commitid	WNyc0RFkydfLYHcc;

1.83
date	2017.04.27.16.09.32;	author tedu;	state Exp;
branches;
next	1.82;
commitid	Lk1nL8V6tDTxIWhJ;

1.82
date	2017.04.13.15.32.15;	author tedu;	state Exp;
branches;
next	1.81;
commitid	lkeNYNB0vTAQir7E;

1.81
date	2017.04.06.21.16.14;	author tedu;	state Exp;
branches;
next	1.80;
commitid	rnOen2iWRfDMCJ5z;

1.80
date	2016.10.23.17.06.41;	author naddy;	state Exp;
branches;
next	1.79;
commitid	XxepW1WJNjLrJfB1;

1.79
date	2016.10.23.00.40.39;	author tedu;	state Exp;
branches;
next	1.78;
commitid	9ZtIDbA62bKVys2y;

1.78
date	2016.10.16.00.08.31;	author tedu;	state Exp;
branches;
next	1.77;
commitid	68g4sdVoJ2tO5K2z;

1.77
date	2016.10.15.22.09.51;	author tedu;	state Exp;
branches;
next	1.76;
commitid	r3ji0BoLB6cvdfxo;

1.76
date	2016.10.15.21.56.40;	author tedu;	state Exp;
branches;
next	1.75;
commitid	ezn9GdI5PUt7Oy7l;

1.75
date	2016.10.15.21.50.59;	author tedu;	state Exp;
branches;
next	1.74;
commitid	UolhNx8hHNGnHmXS;

1.74
date	2016.10.08.06.33.59;	author tedu;	state Exp;
branches;
next	1.73;
commitid	2xE2OjobXqgysI9N;

1.73
date	2016.10.08.03.46.58;	author tedu;	state Exp;
branches;
next	1.72;
commitid	nddthH10dF0SqkgF;

1.72
date	2016.10.07.19.14.56;	author tedu;	state Exp;
branches;
next	1.71;
commitid	Xm3vDIMnoeTHFPmo;

1.71
date	2016.10.07.19.07.36;	author tedu;	state Exp;
branches;
next	1.70;
commitid	eVoMe9htg7uvfwea;

1.70
date	2016.09.01.10.57.24;	author tedu;	state Exp;
branches;
next	1.69;
commitid	tNOOyBYEa2r0Z2Iy;

1.69
date	2016.09.01.10.55.21;	author tedu;	state Exp;
branches;
next	1.68;
commitid	fjSwOkwULRUibgbr;

1.68
date	2016.09.01.10.54.36;	author tedu;	state Exp;
branches;
next	1.67;
commitid	blbN8O7whdH5SmQ0;

1.67
date	2016.08.21.21.23.48;	author tedu;	state Exp;
branches;
next	1.66;
commitid	nChoqwDmcVwFdNEW;

1.66
date	2016.08.06.19.56.51;	author tedu;	state Exp;
branches;
next	1.65;
commitid	wY3rAo0zHWNHBQLS;

1.65
date	2016.07.02.17.09.09;	author tedu;	state Exp;
branches;
next	1.64;
commitid	ArPzhL3ZZWF6j0Ti;

1.64
date	2016.06.05.22.41.41;	author tedu;	state Exp;
branches;
next	1.63;
commitid	Qxz4oORPNfrRB7JV;

1.63
date	2016.05.31.16.50.11;	author tedu;	state Exp;
branches;
next	1.62;
commitid	kSJz2nTlqdaL9PXJ;

1.62
date	2016.05.13.00.19.02;	author tedu;	state Exp;
branches;
next	1.61;
commitid	wPReFuou7iWZIhrW;

1.61
date	2016.05.02.06.21.26;	author semarie;	state Exp;
branches;
next	1.60;
commitid	wPCo8vMOb25LC7ZV;

1.60
date	2016.01.03.18.15.17;	author tedu;	state Exp;
branches;
next	1.59;
commitid	ZKry1KYIJgUbwD8F;

1.59
date	2015.12.17.18.24.57;	author tedu;	state Exp;
branches;
next	1.58;
commitid	mnUMZ1cxPlE5gfJk;

1.58
date	2015.12.12.17.19.51;	author tedu;	state Exp;
branches;
next	1.57;
commitid	SHwb5lk2O0XdWhLf;

1.57
date	2015.12.11.13.47.08;	author tedu;	state Exp;
branches;
next	1.56;
commitid	2baNbf377fb9bhRI;

1.56
date	2015.12.08.18.03.49;	author tedu;	state Exp;
branches;
next	1.55;
commitid	qVzLitCY6wPhpxtT;

1.55
date	2015.12.05.11.51.23;	author tedu;	state Exp;
branches;
next	1.54;
commitid	nynVeaOlYM144Mzs;

1.54
date	2015.12.05.10.24.17;	author tedu;	state Exp;
branches;
next	1.53;
commitid	EJOO3W3ygc4jSctj;

1.53
date	2015.12.04.16.44.20;	author tedu;	state Exp;
branches;
next	1.52;
commitid	Os5o5EkwvkLFxA8x;

1.52
date	2015.12.04.16.33.40;	author tedu;	state Exp;
branches;
next	1.51;
commitid	J2OBKpcqNNpCmndI;

1.51
date	2015.12.04.10.59.36;	author tedu;	state Exp;
branches;
next	1.50;
commitid	b93kbnGS7dheis2g;

1.50
date	2015.12.04.09.13.05;	author tedu;	state Exp;
branches;
next	1.49;
commitid	Mp2fvbQWxuRVx79T;

1.49
date	2015.12.04.04.50.43;	author gsoares;	state Exp;
branches;
next	1.48;
commitid	VhbBSO5FGW61tkJ9;

1.48
date	2015.12.03.08.19.25;	author tedu;	state Exp;
branches;
next	1.47;
commitid	k8lWutCpILgmCgbr;

1.47
date	2015.12.01.23.43.55;	author gsoares;	state Exp;
branches;
next	1.46;
commitid	QsdwXvsqj3XUPBiS;

1.46
date	2015.11.27.21.12.08;	author tedu;	state Exp;
branches;
next	1.45;
commitid	1h7R5uh0PCG4R51g;

1.45
date	2015.11.24.00.21.55;	author deraadt;	state Exp;
branches;
next	1.44;
commitid	WARLwDtGqWw0R4So;

1.44
date	2015.11.16.21.27.42;	author tedu;	state Exp;
branches;
next	1.43;
commitid	0Y8YpJZiq7qm34NN;

1.43
date	2015.11.16.20.56.56;	author tedu;	state Exp;
branches;
next	1.42;
commitid	cRNKpo13CZwtaHzo;

1.42
date	2015.11.10.07.24.38;	author deraadt;	state Exp;
branches;
next	1.41;
commitid	Y9fTc14enR9yqHOV;

1.41
date	2015.11.01.13.59.44;	author reyk;	state Exp;
branches;
next	1.40;
commitid	63qUZek0wr3f6Da7;

1.40
date	2015.10.30.15.44.12;	author tedu;	state Exp;
branches;
next	1.39;
commitid	CA3LLqOvdtMBD8PR;

1.39
date	2015.10.29.14.01.01;	author tedu;	state Exp;
branches;
next	1.38;
commitid	6zkBMWsGAgSuDRLM;

1.38
date	2015.10.29.14.00.06;	author tedu;	state Exp;
branches;
next	1.37;
commitid	HccZzju59uwYNEUI;

1.37
date	2015.10.29.13.54.43;	author tedu;	state Exp;
branches;
next	1.36;
commitid	UwA55dQt1vZDqIdh;

1.36
date	2015.10.29.12.58.10;	author tedu;	state Exp;
branches;
next	1.35;
commitid	r0kZE79Q1ngEJAL1;

1.35
date	2015.10.28.20.56.43;	author tedu;	state Exp;
branches;
next	1.34;
commitid	TKp8RwXsJyQU1KvC;

1.34
date	2015.10.28.20.43.12;	author tedu;	state Exp;
branches;
next	1.33;
commitid	lgJA65BhfySea1qz;

1.33
date	2015.10.28.20.25.46;	author tedu;	state Exp;
branches;
next	1.32;
commitid	hxZR102E11cgtGqm;

1.32
date	2015.10.28.20.20.35;	author tedu;	state Exp;
branches;
next	1.31;
commitid	ZAOFfFUgizuC6uaw;

1.31
date	2015.10.28.19.32.29;	author tedu;	state Exp;
branches;
next	1.30;
commitid	bUUt4i1vNusY7vNG;

1.30
date	2015.10.28.19.09.58;	author tedu;	state Exp;
branches;
next	1.29;
commitid	fOwrrzONiXHlkL7m;

1.29
date	2015.10.28.18.48.03;	author tedu;	state Exp;
branches;
next	1.28;
commitid	Du7S88t6aRWdmvGu;

1.28
date	2015.10.26.12.24.48;	author tedu;	state Exp;
branches;
next	1.27;
commitid	XRSK3FP6ew2yRG7X;

1.27
date	2015.10.26.12.23.40;	author tedu;	state Exp;
branches;
next	1.26;
commitid	5QNZpLU1cenFKiQX;

1.26
date	2015.10.17.00.38.57;	author tedu;	state Exp;
branches;
next	1.25;
commitid	0GAdDsd1CRSYOIiL;

1.25
date	2015.10.16.20.25.09;	author tedu;	state Exp;
branches;
next	1.24;
commitid	SHcESbs1lX9uuSES;

1.24
date	2015.10.16.20.12.06;	author tedu;	state Exp;
branches;
next	1.23;
commitid	ycCM6JVTtoEjAOyV;

1.23
date	2015.10.16.18.47.52;	author tedu;	state Exp;
branches;
next	1.22;
commitid	rym4JXUQ5d9SCW3L;

1.22
date	2015.10.16.18.38.53;	author tedu;	state Exp;
branches;
next	1.21;
commitid	DuTEhv5div4SnjvW;

1.21
date	2015.10.16.18.29.05;	author tedu;	state Exp;
branches;
next	1.20;
commitid	NPKqocGOtNXt9A5g;

1.20
date	2015.10.16.15.35.05;	author tedu;	state Exp;
branches;
next	1.19;
commitid	u6FmRsEipkYXaH36;

1.19
date	2015.10.16.02.09.31;	author tedu;	state Exp;
branches;
next	1.18;
commitid	BgOMAKSwpH9P6zKn;

1.18
date	2015.10.16.01.58.28;	author tedu;	state Exp;
branches;
next	1.17;
commitid	ZXW5iZl44pyK5rIE;

1.17
date	2015.10.16.01.55.19;	author tedu;	state Exp;
branches;
next	1.16;
commitid	866rkGNG1mDnBH5L;

1.16
date	2015.10.16.01.50.39;	author tedu;	state Exp;
branches;
next	1.15;
commitid	E8fh7lmsrWlMXEoK;

1.15
date	2015.10.16.01.37.14;	author tedu;	state Exp;
branches;
next	1.14;
commitid	QNBHyEa0ECZdyHMK;

1.14
date	2015.10.15.22.21.28;	author tedu;	state Exp;
branches;
next	1.13;
commitid	cummcr7jisArMiIa;

1.13
date	2015.10.15.22.17.43;	author tedu;	state Exp;
branches;
next	1.12;
commitid	aQs4uGcT6QERQd6z;

1.12
date	2015.10.15.22.12.26;	author tedu;	state Exp;
branches;
next	1.11;
commitid	VjWB9xwVTFiKGGko;

1.11
date	2015.10.15.21.59.54;	author tedu;	state Exp;
branches;
next	1.10;
commitid	Aj074mrWPjxsZRSB;

1.10
date	2015.10.15.21.56.52;	author tedu;	state Exp;
branches;
next	1.9;
commitid	r7jB0WMi7xfIbXEq;

1.9
date	2015.10.15.21.39.15;	author tedu;	state Exp;
branches;
next	1.8;
commitid	WahEdiNtFldJLHKI;

1.8
date	2015.10.15.21.35.27;	author tedu;	state Exp;
branches;
next	1.7;
commitid	t4P4KWFJzheTaLcD;

1.7
date	2015.10.15.21.25.05;	author tedu;	state Exp;
branches;
next	1.6;
commitid	oLVAyFRHmdMAJeDu;

1.6
date	2015.10.15.21.20.09;	author tedu;	state Exp;
branches;
next	1.5;
commitid	i0lZLU1ddFsd6MzA;

1.5
date	2015.10.15.20.58.14;	author tedu;	state Exp;
branches;
next	1.4;
commitid	D2Hji8gnjkvZn8ny;

1.4
date	2015.10.15.20.47.11;	author deraadt;	state Exp;
branches;
next	1.3;
commitid	RYRri5fP64CDlie4;

1.3
date	2015.10.15.20.13.57;	author tedu;	state Exp;
branches;
next	1.2;
commitid	UhtPcAYBo8RA5xZ6;

1.2
date	2015.10.15.19.49.22;	author tedu;	state Exp;
branches;
next	1.1;
commitid	5chq4JKaZAYRrk0v;

1.1
date	2015.10.15.19.43.30;	author tedu;	state Exp;
branches;
next	;
commitid	crUMkY8EYRGBVfPY;


desc
@@


1.89
log
@there's no nul byte after a name that ends in a crazy compression pointer.
@
text
@/* $OpenBSD: rebound.c,v 1.88 2017/07/13 17:12:51 tedu Exp $ */
/*
 * Copyright (c) 2015 Ted Unangst <tedu@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
#include <sys/types.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <netinet/in.h>
#include <sys/queue.h>
#include <sys/tree.h>
#include <sys/event.h>
#include <sys/resource.h>
#include <sys/time.h>
#include <sys/wait.h>
#include <sys/sysctl.h>

#include <signal.h>
#include <syslog.h>
#include <stdlib.h>
#include <stdio.h>
#include <limits.h>
#include <string.h>
#include <ctype.h>
#include <err.h>
#include <unistd.h>
#include <fcntl.h>
#include <pwd.h>
#include <errno.h>
#include <getopt.h>
#include <stdarg.h>
#include <ctype.h>

#define MINIMUM(a,b) (((a)<(b))?(a):(b))

uint16_t randomid(void);

union sockun {
	struct sockaddr a;
	struct sockaddr_storage s;
	struct sockaddr_in i;
	struct sockaddr_in6 i6;
};

static struct timespec now;
static int debug;
static int daemonized;

struct dnspacket {
	uint16_t id;
	uint16_t flags;
	uint16_t qdcount;
	uint16_t ancount;
	uint16_t nscount;
	uint16_t arcount;
	char qname[];
	/* ... */
};
#define NAMELEN 256

/*
 * requests will point to cache entries until a response is received.
 * until then, the request owns the entry and must free it.
 * after the response is set, the request must not free it.
 */
struct dnscache {
	TAILQ_ENTRY(dnscache) fifo;
	RB_ENTRY(dnscache) cachenode;
	struct dnspacket *req;
	size_t reqlen;
	struct dnspacket *resp;
	size_t resplen;
	struct timespec ts;
	struct timespec basetime;
};
static TAILQ_HEAD(, dnscache) cachefifo;
static RB_HEAD(cachetree, dnscache) cachetree;
RB_PROTOTYPE_STATIC(cachetree, dnscache, cachenode, cachecmp)

static int cachecount;
static int cachemax;
static uint64_t cachehits;

/*
 * requests are kept on a fifo list, but only after socket s is set.
 */
struct request {
	int s;
	int client;
	int tcp;
	union sockun from;
	socklen_t fromlen;
	struct timespec ts;
	TAILQ_ENTRY(request) fifo;
	uint16_t clientid;
	uint16_t reqid;
	struct dnscache *cacheent;
	char origname[NAMELEN];
	char newname[NAMELEN];
};
static TAILQ_HEAD(, request) reqfifo;

static int conncount;
static int connmax;
static uint64_t conntotal;
static int stopaccepting;

static void
logmsg(int prio, const char *msg, ...)
{
	va_list ap;

	if (debug || !daemonized) {
		va_start(ap, msg);
		vfprintf(stdout, msg, ap);
		fprintf(stdout, "\n");
		va_end(ap);
	}
	if (!debug) {
		va_start(ap, msg);
		vsyslog(LOG_DAEMON | prio, msg, ap);
		va_end(ap);
	}
}

static void __dead
logerr(const char *msg, ...)
{
	va_list ap;

	if (debug || !daemonized) {
		va_start(ap, msg);
		fprintf(stderr, "rebound: ");
		vfprintf(stderr, msg, ap);
		fprintf(stderr, "\n");
		va_end(ap);
	}
	if (!debug) {
		va_start(ap, msg);
		vsyslog(LOG_DAEMON | LOG_ERR, msg, ap);
		va_end(ap);
	}
	exit(1);
}

static int
cachecmp(struct dnscache *c1, struct dnscache *c2)
{
	if (c1->reqlen == c2->reqlen)
		return memcmp(c1->req, c2->req, c1->reqlen);
	return c1->reqlen < c2->reqlen ? -1 : 1;
}
RB_GENERATE_STATIC(cachetree, dnscache, cachenode, cachecmp)

static void
lowercase(unsigned char *s)
{
	while (*s) {
		*s = tolower(*s);
		s++;
	}
}

static void
randomcase(unsigned char *s)
{
	unsigned char bits[NAMELEN / 8], *b;
	u_int i = 0;

	arc4random_buf(bits, (strlen(s) + 7) / 8);
	b = bits;
	while (*s) {
		*s = (*b & (1 << i)) ? toupper(*s) : tolower(*s);
		s++;
		i++;
		if (i == 8) {
			b++;
			i = 0;
		}
	}
}

static void
freecacheent(struct dnscache *ent)
{
	cachecount -= 1;
	RB_REMOVE(cachetree, &cachetree, ent);
	TAILQ_REMOVE(&cachefifo, ent, fifo);
	free(ent->req);
	free(ent->resp);
	free(ent);
}

/*
 * names end with either a nul byte, or a two byte 0xc0 pointer
 */
static size_t
dnamelen(const unsigned char *p, size_t len)
{
	size_t n = 0;

	for (n = 0; n < len; n++) {
		if (p[n] == 0)
			return n + 1;
		if ((p[n] & 0xc0) == 0xc0)
			return n + 2;
	}
	return len + 1;
}

static int
adjustttl(struct dnscache *ent)
{
	struct dnspacket *resp = ent->resp;
	char *p = (char *)resp;
	u_int rlen = ent->resplen;
	u_int used = 0;
	uint32_t ttl, cnt, i;
	uint16_t len;
	time_t diff;

	diff = now.tv_sec - ent->basetime.tv_sec;
	if (diff <= 0)
		return 0;

	/* checks are redundant; checked when cacheent is created */
	/* skip past packet header */
	used += sizeof(struct dnspacket);
	if (used >= rlen)
		return -1;
	if (ntohs(resp->qdcount) != 1)
		return -1;
	/* skip past query name, type, and class */
	used += dnamelen(p + used, rlen - used);
	used += 2;
	used += 2;
	cnt = ntohs(resp->ancount);
	for (i = 0; i < cnt; i++) {
		if (used >= rlen)
			return -1;
		/* skip past answer name, type, and class */
		used += dnamelen(p + used, rlen - used);
		used += 2;
		used += 2;
		if (used + 4 >= rlen)
			return -1;
		memcpy(&ttl, p + used, 4);
		ttl = ntohl(ttl);
		/* expired */
		if (diff >= ttl)
			return -1;
		ttl -= diff;
		ttl = ntohl(ttl);
		memcpy(p + used, &ttl, 4);
		used += 4;
		if (used + 2 >= rlen)
			return -1;
		memcpy(&len, p + used, 2);
		used += 2;
		used += ntohs(len);
	}
	ent->basetime.tv_sec += diff;
	return 0;
}

static struct dnscache *
cachelookup(struct dnspacket *dnsreq, size_t reqlen)
{
	struct dnscache *hit, key;
	unsigned char origname[NAMELEN];
	uint16_t origid;
	size_t namelen;

	if (ntohs(dnsreq->qdcount) != 1)
		return NULL;

	namelen = strlcpy(origname, dnsreq->qname, sizeof(origname));
	if (namelen >= sizeof(origname))
		return NULL;
	lowercase(dnsreq->qname);

	origid = dnsreq->id;
	dnsreq->id = 0;

	key.reqlen = reqlen;
	key.req = dnsreq;
	hit = RB_FIND(cachetree, &cachetree, &key);
	if (hit) {
		if (adjustttl(hit) != 0) {
			freecacheent(hit);
			hit = NULL;
		} else
			cachehits += 1;
	}

	memcpy(dnsreq->qname, origname, namelen + 1);
	dnsreq->id = origid;
	return hit;
}

static void
freerequest(struct request *req)
{
	struct dnscache *ent;

	if (req->tcp)
		conncount -= 2;
	else
		conncount -= 1;
	if (req->s != -1) {
		TAILQ_REMOVE(&reqfifo, req, fifo);
		close(req->s);
	}
	if (req->tcp && req->client != -1)
		close(req->client);
	if ((ent = req->cacheent) && !ent->resp) {
		free(ent->req);
		free(ent);
	}
	free(req);
}

static void
servfail(int ud, uint16_t id, struct sockaddr *fromaddr, socklen_t fromlen)
{
	struct dnspacket pkt;

	memset(&pkt, 0, sizeof(pkt));
	pkt.id = id;
	pkt.flags = htons(1 << 15 | 0x2);
	sendto(ud, &pkt, sizeof(pkt), 0, fromaddr, fromlen);
}

static struct request *
newrequest(int ud, struct sockaddr *remoteaddr)
{
	union sockun from;
	socklen_t fromlen;
	struct request *req;
	uint8_t buf[65536];
	struct dnspacket *dnsreq;
	struct dnscache *hit;
	size_t r;

	dnsreq = (struct dnspacket *)buf;

	fromlen = sizeof(from);
	r = recvfrom(ud, buf, sizeof(buf), 0, &from.a, &fromlen);
	if (r == 0 || r == -1 || r < sizeof(struct dnspacket))
		return NULL;
	if (ntohs(dnsreq->qdcount) == 1) {
		/* some more checking */
		if (!memchr(dnsreq->qname, '\0', r - sizeof(struct dnspacket)))
			return NULL;
	}

	conntotal += 1;
	if ((hit = cachelookup(dnsreq, r))) {
		hit->resp->id = dnsreq->id;
		memcpy(hit->resp->qname, dnsreq->qname, strlen(hit->resp->qname) + 1);
		sendto(ud, hit->resp, hit->resplen, 0, &from.a, fromlen);
		return NULL;
	}

	if (!(req = calloc(1, sizeof(*req))))
		return NULL;

	conncount += 1;
	req->ts = now;
	req->ts.tv_sec += 30;
	req->s = -1;

	req->client = ud;
	memcpy(&req->from, &from, fromlen);
	req->fromlen = fromlen;

	req->clientid = dnsreq->id;
	req->reqid = randomid();
	dnsreq->id = req->reqid;
	if (ntohs(dnsreq->qdcount) == 1) {
		size_t namelen;
		namelen = strlcpy(req->origname, dnsreq->qname, sizeof(req->origname));
		if (namelen >= sizeof(req->origname))
			goto fail;
		randomcase(dnsreq->qname);
		memcpy(req->newname, dnsreq->qname, namelen + 1);

		hit = calloc(1, sizeof(*hit));
		if (hit) {
			hit->req = malloc(r);
			if (hit->req) {
				memcpy(hit->req, dnsreq, r);
				hit->reqlen = r;
				hit->req->id = 0;
				lowercase(hit->req->qname);
			} else {
				free(hit);
				hit = NULL;

			}
		}
		req->cacheent = hit;
	}

	req->s = socket(remoteaddr->sa_family, SOCK_DGRAM, 0);
	if (req->s == -1)
		goto fail;

	TAILQ_INSERT_TAIL(&reqfifo, req, fifo);

	if (connect(req->s, remoteaddr, remoteaddr->sa_len) == -1) {
		logmsg(LOG_NOTICE, "failed to connect (%d)", errno);
		if (errno == EADDRNOTAVAIL)
			servfail(ud, req->clientid, &from.a, fromlen);
		goto fail;
	}
	if (send(req->s, buf, r, 0) != r) {
		logmsg(LOG_NOTICE, "failed to send (%d)", errno);
		goto fail;
	}

	return req;

fail:
	freerequest(req);
	return NULL;
}

static uint32_t
minttl(struct dnspacket *resp, u_int rlen)
{
	uint32_t minttl = -1, ttl, cnt, i;
	uint16_t len;
	char *p = (char *)resp;
	u_int used = 0;

	/* skip past packet header */
	used += sizeof(struct dnspacket);
	if (used >= rlen)
		return -1;
	if (ntohs(resp->qdcount) != 1)
		return -1;
	/* skip past query name, type, and class */
	used += dnamelen(p + used, rlen - used);
	used += 2;
	used += 2;
	cnt = ntohs(resp->ancount);
	for (i = 0; i < cnt; i++) {
		if (used >= rlen)
			return -1;
		/* skip past answer name, type, and class */
		used += dnamelen(p + used, rlen - used);
		used += 2;
		used += 2;
		if (used + 4 >= rlen)
			return -1;
		memcpy(&ttl, p + used, 4);
		used += 4;
		if (used + 2 >= rlen)
			return -1;
		ttl = ntohl(ttl);
		if (ttl < minttl)
			minttl = ttl;
		memcpy(&len, p + used, 2);
		used += 2;
		used += ntohs(len);
	}
	return minttl;
}

static void
sendreply(struct request *req)
{
	uint8_t buf[65536];
	struct dnspacket *resp;
	struct dnscache *ent;
	size_t r;
	uint32_t ttl;

	resp = (struct dnspacket *)buf;

	r = recv(req->s, buf, sizeof(buf), 0);
	if (r == 0 || r == -1 || r < sizeof(struct dnspacket))
		return;
	if (resp->id != req->reqid)
		return;
	resp->id = req->clientid;
	if (ntohs(resp->qdcount) == 1) {
		/* some more checking */
		if (!memchr(resp->qname, '\0', r - sizeof(struct dnspacket)))
			return;
		if (strcmp(resp->qname, req->newname) != 0)
			return;
		memcpy(resp->qname, req->origname, strlen(resp->qname) + 1);
	}
	sendto(req->client, buf, r, 0, &req->from.a, req->fromlen);
	if ((ent = req->cacheent)) {
		/* check that the response is worth caching */
		ttl = minttl(resp, r);
		if (ttl == -1 || ttl == 0)
			return;
		/*
		 * we do this next, because there's a potential race against
		 * other requests made at the same time. if we lose, abort.
		 * if anything else goes wrong, though, we need to reverse.
		 */
		if (RB_INSERT(cachetree, &cachetree, ent))
			return;
		ent->ts = now;
		ent->ts.tv_sec += MINIMUM(ttl, 300);
		ent->basetime = now;
		ent->resp = malloc(r);
		if (!ent->resp) {
			RB_REMOVE(cachetree, &cachetree, ent);
			return;
		}
		memcpy(ent->resp, buf, r);
		ent->resplen = r;
		cachecount += 1;
		TAILQ_INSERT_TAIL(&cachefifo, ent, fifo);
	}
}

static struct request *
tcpphasetwo(struct request *req)
{
	int error;
	socklen_t len = sizeof(error);

	req->tcp = 2;

	if (getsockopt(req->s, SOL_SOCKET, SO_ERROR, &error, &len) == -1 ||
	    error != 0)
		goto fail;
	if (setsockopt(req->client, SOL_SOCKET, SO_SPLICE, &req->s,
	    sizeof(req->s)) == -1)
		goto fail;
	if (setsockopt(req->s, SOL_SOCKET, SO_SPLICE, &req->client,
	    sizeof(req->client)) == -1)
		goto fail;

	return req;

fail:
	freerequest(req);
	return NULL;
}

static struct request *
newtcprequest(int ld, struct sockaddr *remoteaddr)
{
	struct request *req;
	int client;

	client = accept(ld, NULL, 0);
	if (client == -1) {
		if (errno == ENFILE || errno == EMFILE)
			stopaccepting = 1;
		return NULL;
	}

	if (!(req = calloc(1, sizeof(*req)))) {
		close(client);
		return NULL;
	}

	conntotal += 1;
	conncount += 2;
	req->ts = now;
	req->ts.tv_sec += 30;
	req->tcp = 1;
	req->client = client;

	req->s = socket(remoteaddr->sa_family, SOCK_STREAM | SOCK_NONBLOCK, 0);
	if (req->s == -1)
		goto fail;

	TAILQ_INSERT_TAIL(&reqfifo, req, fifo);

	if (connect(req->s, remoteaddr, remoteaddr->sa_len) == -1) {
		if (errno != EINPROGRESS)
			goto fail;
	} else {
		return tcpphasetwo(req);
	}

	return req;

fail:
	freerequest(req);
	return NULL;
}

static int
readconfig(int conffd, union sockun *remoteaddr)
{
	const char ns[] = "nameserver";
	char buf[1024];
	char *p;
	struct sockaddr_in *sin = &remoteaddr->i;
	struct sockaddr_in6 *sin6 = &remoteaddr->i6;
	FILE *conf;
	int rv = -1;

	conf = fdopen(conffd, "r");

	while (fgets(buf, sizeof(buf), conf) != NULL) {
		buf[strcspn(buf, "\n")] = '\0';

		if (strncmp(buf, ns, strlen(ns)) != 0)
			continue;
		p = buf + strlen(ns) + 1;
		while (isspace((unsigned char)*p))
			p++;

		/* this will not end well */
		if (strcmp(p, "127.0.0.1") == 0)
			continue;

		memset(remoteaddr, 0, sizeof(*remoteaddr));
		if (inet_pton(AF_INET, p, &sin->sin_addr) == 1) {
			sin->sin_len = sizeof(*sin);
			sin->sin_family = AF_INET;
			sin->sin_port = htons(53);
			rv = AF_INET;
		} else if (inet_pton(AF_INET6, p, &sin6->sin6_addr) == 1) {
			sin6->sin6_len = sizeof(*sin6);
			sin6->sin6_family = AF_INET6;
			sin6->sin6_port = htons(53);
			rv = AF_INET6;
		}
		break;
	}
	fclose(conf);
	return rv;
}

static void
workerinit(void)
{
	struct rlimit rlim;
	struct passwd *pwd;

	if (getrlimit(RLIMIT_NOFILE, &rlim) == -1)
		logerr("getrlimit: %s", strerror(errno));
	rlim.rlim_cur = rlim.rlim_max;
	if (setrlimit(RLIMIT_NOFILE, &rlim) == -1)
		logerr("setrlimit: %s", strerror(errno));
	connmax = rlim.rlim_cur - 10;
	if (connmax > 512)
		connmax = 512;

	cachemax = 10000; /* something big, but not huge */

	TAILQ_INIT(&reqfifo);
	TAILQ_INIT(&cachefifo);
	RB_INIT(&cachetree);

	if (!(pwd = getpwnam("_rebound")))
		logerr("getpwnam failed");

	if (chroot(pwd->pw_dir) == -1)
		logerr("chroot: %s", strerror(errno));
	if (chdir("/") == -1)
		logerr("chdir: %s", strerror(errno));

	setproctitle("worker");
	if (setgroups(1, &pwd->pw_gid) ||
	    setresgid(pwd->pw_gid, pwd->pw_gid, pwd->pw_gid) ||
	    setresuid(pwd->pw_uid, pwd->pw_uid, pwd->pw_uid))
		logerr("failed to privdrop");

	if (pledge("stdio inet", NULL) == -1)
		logerr("pledge failed");
}

static int
workerloop(int conffd, int ud, int ld, int ud6, int ld6)
{
	union sockun remoteaddr;
	struct kevent ch[2], kev[4];
	struct timespec ts, *timeout = NULL;
	struct request *req;
	struct dnscache *ent;
	int i, r, af, kq;

	kq = kqueue();

	if (!debug) {
		pid_t parent = getppid();
		/* would need pledge(proc) to do this below */
		EV_SET(&kev[0], parent, EVFILT_PROC, EV_ADD, NOTE_EXIT, 0, NULL);
		if (kevent(kq, kev, 1, NULL, 0, NULL) == -1)
			logerr("kevent1: %d", errno);
	}

	workerinit();

	af = readconfig(conffd, &remoteaddr);
	if (af == -1)
		logerr("parse error in config file");

	EV_SET(&kev[0], ud, EVFILT_READ, EV_ADD, 0, 0, NULL);
	EV_SET(&kev[1], ld, EVFILT_READ, EV_ADD, 0, 0, NULL);
	EV_SET(&kev[2], ud6, EVFILT_READ, EV_ADD, 0, 0, NULL);
	EV_SET(&kev[3], ld6, EVFILT_READ, EV_ADD, 0, 0, NULL);
	if (kevent(kq, kev, 4, NULL, 0, NULL) == -1)
		logerr("kevent4: %d", errno);
	EV_SET(&kev[0], SIGHUP, EVFILT_SIGNAL, EV_ADD, 0, 0, NULL);
	EV_SET(&kev[1], SIGUSR1, EVFILT_SIGNAL, EV_ADD, 0, 0, NULL);
	if (kevent(kq, kev, 2, NULL, 0, NULL) == -1)
		logerr("kevent2: %d", errno);
	logmsg(LOG_INFO, "worker process going to work");
	while (1) {
		r = kevent(kq, NULL, 0, kev, 4, timeout);
		if (r == -1)
			logerr("kevent failed (%d)", errno);

		clock_gettime(CLOCK_MONOTONIC, &now);

		if (stopaccepting) {
			EV_SET(&ch[0], ld, EVFILT_READ, EV_ADD, 0, 0, NULL);
			kevent(kq, ch, 1, NULL, 0, NULL);
			stopaccepting = 0;
		}

		for (i = 0; i < r; i++) {
			struct kevent *ke = &kev[i];
			switch (ke->filter) {
			case EVFILT_SIGNAL:
				if (ke->ident == SIGHUP) {
					logmsg(LOG_INFO, "hupped, exiting");
					exit(0);
				} else {
					logmsg(LOG_INFO, "connection stats: "
					    "%d active, %llu total",
					    conncount, conntotal);
					logmsg(LOG_INFO, "cache stats: "
					    "%d active, %llu hits",
					    cachecount, cachehits);
				}
				break;
			case EVFILT_PROC:
				logmsg(LOG_INFO, "parent died");
				exit(0);
				break;
			case EVFILT_WRITE:
				req = ke->udata;
				req = tcpphasetwo(req);
				if (req) {
					EV_SET(&ch[0], req->s, EVFILT_WRITE,
					    EV_DELETE, 0, 0, NULL);
					EV_SET(&ch[1], req->s, EVFILT_READ,
					    EV_ADD, 0, 0, req);
					kevent(kq, ch, 2, NULL, 0, NULL);
				}
				break;
			case EVFILT_READ:
				if (ke->ident == ud || ke->ident == ud6) {
					if ((req = newrequest(ke->ident, &remoteaddr.a))) {
						EV_SET(&ch[0], req->s, EVFILT_READ,
						    EV_ADD, 0, 0, req);
						kevent(kq, ch, 1, NULL, 0, NULL);
					}
				} else if (ke->ident == ld || ke->ident == ld6) {
					if ((req = newtcprequest(ke->ident, &remoteaddr.a))) {
						EV_SET(&ch[0], req->s,
						    req->tcp == 1 ? EVFILT_WRITE :
						    EVFILT_READ, EV_ADD, 0, 0, req);
						kevent(kq, ch, 1, NULL, 0, NULL);
					}
				} else {
					req = ke->udata;
					if (req->tcp == 0)
						sendreply(req);
					freerequest(req);
				}
				break;
			default:
				logerr("don't know what happened");
				break;
			}
		}

		timeout = NULL;

		if (stopaccepting) {
			EV_SET(&ch[0], ld, EVFILT_READ, EV_DELETE, 0, 0, NULL);
			kevent(kq, ch, 1, NULL, 0, NULL);
			memset(&ts, 0, sizeof(ts));
			/* one second added below */
			timeout = &ts;
		}

		while (conncount > connmax)
			freerequest(TAILQ_FIRST(&reqfifo));
		while (cachecount > cachemax)
			freecacheent(TAILQ_FIRST(&cachefifo));

		/* burn old cache entries */
		while ((ent = TAILQ_FIRST(&cachefifo))) {
			if (timespeccmp(&ent->ts, &now, <=))
				freecacheent(ent);
			else
				break;
		}
		if (ent) {
			timespecsub(&ent->ts, &now, &ts);
			timeout = &ts;
		}

		/* burn stalled requests */
		while ((req = TAILQ_FIRST(&reqfifo))) {
			if (timespeccmp(&req->ts, &now, <=))
				freerequest(req);
			else
				break;
		}
		if (req && (!ent || timespeccmp(&req->ts, &ent->ts, <=))) {
			timespecsub(&req->ts, &now, &ts);
			timeout = &ts;
		}
		/* one second grace to avoid spinning */
		if (timeout)
			timeout->tv_sec += 1;

	}
	/* not reached */
	exit(1);
}

static int
openconfig(const char *confname, int kq)
{
	struct kevent kev;
	int conffd;

	conffd = open(confname, O_RDONLY);
	if (conffd == -1)
		logerr("failed to open config %s", confname);
	if (kq != -1) {
		EV_SET(&kev, conffd, EVFILT_VNODE, EV_ADD,
		    NOTE_DELETE | NOTE_ATTRIB, 0, NULL);
		kevent(kq, &kev, 1, NULL, 0, NULL);
	}
	return conffd;
}

static pid_t
reexec(int conffd, int ud, int ld, int ud6, int ld6)
{
	pid_t child;

	if (conffd != 8 || ud != 3 || ld != 4 || ud6 != 5 || ld6 != 6)
		logerr("can't re-exec, fds are wrong");

	switch ((child = fork())) {
	case -1:
		logerr("failed to fork");
		break;
	case 0:
		execl("/usr/sbin/rebound", "rebound", "-W", NULL);
		logerr("re-exec failed");
	default:
		break;
	}
	return child;
}

static int
monitorloop(int ud, int ld, int ud6, int ld6, const char *confname)
{
	pid_t child;
	struct kevent kev;
	int r, kq;
	int conffd = -1;
	struct timespec ts, *timeout = NULL;

	kq = kqueue();

	/* catch these signals with kevent */
	signal(SIGHUP, SIG_IGN);
	EV_SET(&kev, SIGHUP, EVFILT_SIGNAL, EV_ADD, 0, 0, NULL);
	kevent(kq, &kev, 1, NULL, 0, NULL);
	signal(SIGTERM, SIG_IGN);
	EV_SET(&kev, SIGTERM, EVFILT_SIGNAL, EV_ADD, 0, 0, NULL);
	kevent(kq, &kev, 1, NULL, 0, NULL);
	while (1) {
		int hupped = 0;
		int childdead = 0;
	
		if (conffd == -1)
			conffd = openconfig(confname, kq);

		child = reexec(conffd, ud, ld, ud6, ld6);

		/* monitor child */
		EV_SET(&kev, child, EVFILT_PROC, EV_ADD, NOTE_EXIT, 0, NULL);
		kevent(kq, &kev, 1, NULL, 0, NULL);

		/* wait for something to happen: HUP or child exiting */
		timeout = NULL;
		while (1) {
			r = kevent(kq, NULL, 0, &kev, 1, timeout);
			if (r == -1)
				logerr("kevent failed (%d)", errno);
			if (r == 0) {
				/* timeout expired */
				logerr("child died without HUP");
			}
			switch (kev.filter) {
			case EVFILT_VNODE:
				/* config file changed */
				logmsg(LOG_INFO, "config changed, reloading");
				close(conffd);
				conffd = -1;
				sleep(1);
				raise(SIGHUP);
				break;
			case EVFILT_SIGNAL:
				if (kev.ident == SIGHUP) {
					/* signaled. kill child. */
					logmsg(LOG_INFO, "received HUP, restarting");
					hupped = 1;
					if (childdead)
						goto doublebreak;
					kill(child, SIGHUP);
				} else if (kev.ident == SIGTERM) {
					/* good bye */
					logmsg(LOG_INFO, "received TERM, quitting");
					kill(child, SIGTERM);
					exit(0);
				}
				break;
			case EVFILT_PROC:
				/* child died. wait for our own HUP. */
				logmsg(LOG_INFO, "observed child exit");
				childdead = 1;
				if (hupped)
					goto doublebreak;
				memset(&ts, 0, sizeof(ts));
				ts.tv_sec = 1;
				timeout = &ts;
				break;
			default:
				logerr("don't know what happened");
				break;
			}
		}
doublebreak:
		wait(NULL);
	}
	return 1;
}

static void
resetport(void)
{
	int dnsjacking[2] = { CTL_KERN, KERN_DNSJACKPORT };
	int jackport = 0;

	sysctl(dnsjacking, 2, NULL, NULL, &jackport, sizeof(jackport));
}

static void __dead
usage(void)
{
	fprintf(stderr, "usage: rebound [-d] [-c config] [-l address]\n");
	exit(1);
}

int
main(int argc, char **argv)
{
	int dnsjacking[2] = { CTL_KERN, KERN_DNSJACKPORT };
	int jackport = 54;
	union sockun bindaddr;
	int ld, ld6, ud, ud6, ch;
	int one = 1;
	const char *confname = "/etc/resolv.conf";
	const char *bindname = "127.0.0.1";

	tzset();
	openlog("rebound", LOG_PID | LOG_NDELAY, LOG_DAEMON);

	signal(SIGPIPE, SIG_IGN);
	signal(SIGUSR1, SIG_IGN);

	while ((ch = getopt(argc, argv, "c:dl:W")) != -1) {
		switch (ch) {
		case 'c':
			confname = optarg;
			break;
		case 'd':
			debug = 1;
			break;
		case 'l':
			bindname = optarg;
			jackport = 0;
			break;
		case 'W':
			daemonized = 1;
			/* parent responsible for setting up fds */
			return workerloop(8, 3, 4, 5, 6);
		default:
			usage();
			break;
		}
	}
	argv += optind;
	argc -= optind;

	if (argc)
		usage();

	/* make sure we consistently open fds */
	closefrom(3);

	memset(&bindaddr, 0, sizeof(bindaddr));
	bindaddr.i.sin_len = sizeof(bindaddr.i);
	bindaddr.i.sin_family = AF_INET;
	bindaddr.i.sin_port = htons(jackport ? jackport : 53);
	inet_aton(bindname, &bindaddr.i.sin_addr);

	ud = socket(AF_INET, SOCK_DGRAM, 0);
	if (ud == -1)
		logerr("socket: %s", strerror(errno));
	if (bind(ud, &bindaddr.a, bindaddr.a.sa_len) == -1)
		logerr("bind: %s", strerror(errno));

	ld = socket(AF_INET, SOCK_STREAM, 0);
	if (ld == -1)
		logerr("socket: %s", strerror(errno));
	setsockopt(ld, SOL_SOCKET, SO_REUSEADDR, &one, sizeof(one));
	if (bind(ld, &bindaddr.a, bindaddr.a.sa_len) == -1)
		logerr("bind: %s", strerror(errno));
	if (listen(ld, 10) == -1)
		logerr("listen: %s", strerror(errno));

	memset(&bindaddr, 0, sizeof(bindaddr));
	bindaddr.i6.sin6_len = sizeof(bindaddr.i6);
	bindaddr.i6.sin6_family = AF_INET6;
	bindaddr.i6.sin6_port = htons(jackport ? jackport : 53);
	bindaddr.i6.sin6_addr = in6addr_loopback;

	ud6 = socket(AF_INET6, SOCK_DGRAM, 0);
	if (ud6 == -1)
		logerr("socket: %s", strerror(errno));
	if (bind(ud6, &bindaddr.a, bindaddr.a.sa_len) == -1)
		logerr("bind: %s", strerror(errno));

	ld6 = socket(AF_INET6, SOCK_STREAM, 0);
	if (ld6 == -1)
		logerr("socket: %s", strerror(errno));
	setsockopt(ld6, SOL_SOCKET, SO_REUSEADDR, &one, sizeof(one));
	if (bind(ld6, &bindaddr.a, bindaddr.a.sa_len) == -1)
		logerr("bind: %s", strerror(errno));
	if (listen(ld6, 10) == -1)
		logerr("listen: %s", strerror(errno));

	if (jackport) {
		atexit(resetport);
		sysctl(dnsjacking, 2, NULL, NULL, &jackport, sizeof(jackport));
	}
	
	if (debug) {
		int conffd = openconfig(confname, -1);
		return workerloop(conffd, ud, ld, ud6, ld6);
	}

	if (daemon(0, 0) == -1)
		logerr("daemon: %s", strerror(errno));
	daemonized = 1;

	return monitorloop(ud, ld, ud6, ld6, confname);
}
@


1.88
log
@add an option to listen to an address other than localhost,
upgrading to a mini recursive resolver for small networks.
@
text
@d1 1
a1 1
/* $OpenBSD: rebound.c,v 1.87 2017/07/04 00:30:45 tedu Exp $ */
d205 17
d245 1
a245 1
	used += strnlen(p + used, rlen - used);
d253 1
a253 1
		used += strnlen(p + used, rlen - used);
d455 1
a455 1
	used += strnlen(p + used, rlen - used);
d463 1
a463 1
		used += strnlen(p + used, rlen - used);
@


1.87
log
@properly adjust the ttl of replies instead of freezing them in time
@
text
@d1 1
a1 1
/* $OpenBSD: rebound.c,v 1.86 2017/07/03 16:36:48 tedu Exp $ */
d962 1
a962 1
	fprintf(stderr, "usage: rebound [-d] [-c config]\n");
d975 1
d983 1
a983 1
	while ((ch = getopt(argc, argv, "c:dW")) != -1) {
d991 4
d1016 2
a1017 2
	bindaddr.i.sin_port = htons(jackport);
	inet_aton("127.0.0.1", &bindaddr.i.sin_addr);
d1037 1
a1037 1
	bindaddr.i6.sin6_port = htons(jackport);
d1055 4
a1058 2
	atexit(resetport);
	sysctl(dnsjacking, 2, NULL, NULL, &jackport, sizeof(jackport));
@


1.86
log
@don't bother caching invalid or very short lived responses
@
text
@d1 1
a1 1
/* $OpenBSD: rebound.c,v 1.85 2017/07/03 09:39:48 tedu Exp $ */
d85 1
d205 55
d283 1
a283 1
		if (timespeccmp(&hit->ts, &now, <=)) {
d505 1
@


1.85
log
@check that a cachehit hasn't expired before using it.
@
text
@d1 1
a1 1
/* $OpenBSD: rebound.c,v 1.84 2017/05/31 04:52:11 deraadt Exp $ */
d75 1
a75 1
 * after it's on the list, the request must not free it.
d436 4
d441 1
a441 1
		 * we do this first, because there's a potential race against
a446 3
		ttl = minttl(resp, r);
		if (ttl == -1)
			ttl = 0;
@


1.84
log
@use strerror; from Edgar Pettijohn
@
text
@d1 1
a1 1
/* $OpenBSD: rebound.c,v 1.83 2017/04/27 16:09:32 tedu Exp $ */
d193 11
d226 7
a232 2
	if (hit)
		cachehits += 1;
a258 11
}

static void
freecacheent(struct dnscache *ent)
{
	cachecount -= 1;
	RB_REMOVE(cachetree, &cachetree, ent);
	TAILQ_REMOVE(&cachefifo, ent, fifo);
	free(ent->req);
	free(ent->resp);
	free(ent);
@


1.83
log
@clang warns about some of the strlcpy arguments here, which aren't the
typical idiom because there's invisible size dependencies. rewrite some
of it to use memcpy, which makes clear the lengths are the same.
@
text
@d1 1
a1 1
/* $OpenBSD: rebound.c,v 1.82 2017/04/13 15:32:15 tedu Exp $ */
d594 1
a594 1
		logerr("chroot failed (%d)", errno);
d596 1
a596 1
		logerr("chdir failed (%d)", errno);
@


1.82
log
@moving some code into a switch meant that break no longer stopped the loop.
try harder with a goto. diagnosis and original fix by tb.
@
text
@d1 1
a1 1
/* $OpenBSD: rebound.c,v 1.81 2017/04/06 21:16:14 tedu Exp $ */
d199 1
d204 3
a206 1
	strlcpy(origname, dnsreq->qname, sizeof(origname));
d218 1
a218 1
	strlcpy(dnsreq->qname, origname, sizeof(origname));
d293 1
a293 1
		strlcpy(hit->resp->qname, dnsreq->qname, strlen(hit->resp->qname) + 1);
d314 4
a317 1
		strlcpy(req->origname, dnsreq->qname, sizeof(req->origname));
d319 1
a319 1
		strlcpy(req->newname, dnsreq->qname, sizeof(req->newname));
d427 1
a427 1
		strlcpy(resp->qname, req->origname, strlen(resp->qname) + 1);
@


1.81
log
@replace some long if/else chains with a switch
@
text
@d1 1
a1 1
/* $OpenBSD: rebound.c,v 1.80 2016/10/23 17:06:41 naddy Exp $ */
d851 1
a851 1
						break;
d865 1
a865 1
					break;
d875 1
@


1.80
log
@unbreak by fixing obvious pastos
@
text
@d1 1
a1 1
/* $OpenBSD: rebound.c,v 1.79 2016/10/23 00:40:39 tedu Exp $ */
d653 4
a656 2
			if (kev[i].filter == EVFILT_SIGNAL) {
				if (kev[i].ident == SIGHUP) {
d667 2
a668 1
			} else if (kev[i].filter == EVFILT_PROC) {
d671 3
a673 2
			} else if (kev[i].filter == EVFILT_WRITE) {
				req = kev[i].udata;
d682 23
a704 1
			} else if (kev[i].filter != EVFILT_READ) {
d706 1
a706 18
			} else if (kev[i].ident == ud || kev[i].ident == ud6) {
				if ((req = newrequest(kev[i].ident, &remoteaddr.a))) {
					EV_SET(&ch[0], req->s, EVFILT_READ,
					    EV_ADD, 0, 0, req);
					kevent(kq, ch, 1, NULL, 0, NULL);
				}
			} else if (kev[i].ident == ld || kev[i].ident == ld6) {
				if ((req = newtcprequest(kev[i].ident, &remoteaddr.a))) {
					EV_SET(&ch[0], req->s,
					    req->tcp == 1 ? EVFILT_WRITE :
					    EVFILT_READ, EV_ADD, 0, 0, req);
					kevent(kq, ch, 1, NULL, 0, NULL);
				}
			} else {
				req = kev[i].udata;
				if (req->tcp == 0)
					sendreply(req);
				freerequest(req);
a831 1

d835 3
a837 1
			} else if (kev.filter == EVFILT_VNODE) {
d844 17
a860 15
			} else if (kev.filter == EVFILT_SIGNAL &&
			    kev.ident == SIGHUP) {
				/* signaled. kill child. */
				logmsg(LOG_INFO, "received HUP, restarting");
				hupped = 1;
				if (childdead)
					break;
				kill(child, SIGHUP);
			} else if (kev.filter == EVFILT_SIGNAL &&
			    kev.ident == SIGTERM) {
				/* good bye */
				logmsg(LOG_INFO, "received TERM, quitting");
				kill(child, SIGTERM);
				exit(0);
			} else if (kev.filter == EVFILT_PROC) {
d869 2
a870 1
			} else {
d872 1
@


1.79
log
@listen on inet6 sockets as well. we need this because stolen inet6 sockets
can't be redirected to inet4 listeners.
@
text
@d1 1
a1 1
/* $OpenBSD: rebound.c,v 1.78 2016/10/16 00:08:31 tedu Exp $ */
d630 2
a631 2
	EV_SET(&kev[2], ud6, EVFILT_SIGNAL, EV_ADD, 0, 0, NULL);
	EV_SET(&kev[3], ld6, EVFILT_SIGNAL, EV_ADD, 0, 0, NULL);
@


1.78
log
@switch to a re-exec model instead of plain forking to reduce sharing.
this shuffles about some of the initialization code and consolidates all
the worker initialization in one place.
the parent process runs the monitor loop and execs workers via -W, which
then drop immediately into the worker loop.
file descriptors currently inherited across exec, which probably exceeds
safe magic levels, but fits the existing model without too many changes.
@
text
@d1 1
a1 1
/* $OpenBSD: rebound.c,v 1.77 2016/10/15 22:09:51 tedu Exp $ */
d233 1
a233 1
	if (req->client != -1)
d303 1
a303 1
	req->client = -1;
d399 1
a399 1
sendreply(int ud, struct request *req)
d423 1
a423 1
	sendto(ud, buf, r, 0, &req->from.a, req->fromlen);
d603 1
a603 1
workerloop(int conffd, int ud, int ld)
d630 2
a631 2
	EV_SET(&kev[2], SIGHUP, EVFILT_SIGNAL, EV_ADD, 0, 0, NULL);
	EV_SET(&kev[3], SIGUSR1, EVFILT_SIGNAL, EV_ADD, 0, 0, NULL);
d634 4
d680 2
a681 2
			} else if (kev[i].ident == ud) {
				if ((req = newrequest(ud, &remoteaddr.a))) {
d686 2
a687 2
			} else if (kev[i].ident == ld) {
				if ((req = newtcprequest(ld, &remoteaddr.a))) {
d696 1
a696 1
					sendreply(ud, req);
d766 1
a766 1
reexec(int conffd, int ud, int ld)
d770 1
a770 1
	if (conffd != 6 || ud != 3 || ld != 4)
d787 1
a787 1
monitorloop(int ud, int ld, const char *confname)
d811 1
a811 1
		child = reexec(conffd, ud, ld);
d888 1
a888 1
	int ld, ud, ch;
d909 1
a909 1
			return workerloop(6, 3, 4);
d945 21
d971 1
a971 1
		return workerloop(conffd, ud, ld);
d978 1
a978 1
	return monitorloop(ud, ld, confname);
@


1.77
log
@refactor the worker and monitor loops a little to make room for re-exec
@
text
@d1 1
a1 1
/* $OpenBSD: rebound.c,v 1.76 2016/10/15 21:56:40 tedu Exp $ */
d563 2
a564 2
static int
workerloop(int conffd, int ud, int ld)
d566 1
a566 5
	union sockun remoteaddr;
	struct kevent ch[2], kev[4];
	struct timespec ts, *timeout = NULL;
	struct request *req;
	struct dnscache *ent;
a567 1
	int i, r, af, kq;
d569 10
a578 1
	kq = kqueue();
d580 3
a582 7
	if (!debug) {
		pid_t parent = getppid();
		/* would need pledge(proc) to do this below */
		EV_SET(&kev[0], parent, EVFILT_PROC, EV_ADD, NOTE_EXIT, 0, NULL);
		if (kevent(kq, kev, 1, NULL, 0, NULL) == -1)
			logerr("kevent1: %d", errno);
	}
d600 23
d761 21
d807 1
a807 9
		switch ((child = fork())) {
		case -1:
			logerr("failed to fork");
			break;
		case 0:
			return workerloop(conffd, ud, ld);
		default:
			break;
		}
a885 1
	struct rlimit rlim;
d888 7
a894 1
	while ((ch = getopt(argc, argv, "c:d")) != -1) {
d902 4
d917 2
a918 17
	if (getrlimit(RLIMIT_NOFILE, &rlim) == -1)
		logerr("getrlimit: %s", strerror(errno));
	rlim.rlim_cur = rlim.rlim_max;
	if (setrlimit(RLIMIT_NOFILE, &rlim) == -1)
		logerr("setrlimit: %s", strerror(errno));
	connmax = rlim.rlim_cur - 10;
	if (connmax > 512)
		connmax = 512;

	cachemax = 10000; /* something big, but not huge */

	tzset();
	openlog("rebound", LOG_PID | LOG_NDELAY, LOG_DAEMON);

	TAILQ_INIT(&reqfifo);
	TAILQ_INIT(&cachefifo);
	RB_INIT(&cachetree);
a943 3
	signal(SIGPIPE, SIG_IGN);
	signal(SIGUSR1, SIG_IGN);

@


1.76
log
@be more cautious about inspecting packets. use integer offsets instead of
advancing pointers which may go past the end.
@
text
@d1 1
a1 1
/* $OpenBSD: rebound.c,v 1.75 2016/10/15 21:50:59 tedu Exp $ */
d564 1
a564 1
launch(int conffd, int ud, int ld)
a572 1
	pid_t parent, child;
d574 2
a575 1
	parent = getpid();
d577 5
a581 2
		if ((child = fork()))
			return child;
a583 2
	kq = kqueue();

a597 5
	/* would need pledge(proc) to do this below */
	EV_SET(&kev[0], parent, EVFILT_PROC, EV_ADD, NOTE_EXIT, 0, NULL);
	if (kevent(kq, kev, 1, NULL, 0, NULL) == -1)
		logerr("kevent1: %d", errno);

d738 88
d848 1
a848 1
	int r, kq, ld, ud, ch, conffd = -1;
a849 2
	pid_t child;
	struct kevent kev;
a850 1
	struct timespec ts, *timeout = NULL;
d918 2
a919 2
		conffd = openconfig(confname, -1);
		return launch(conffd, ud, ld);
d926 1
a926 71
	kq = kqueue();

	/* catch these signals with kevent */
	signal(SIGHUP, SIG_IGN);
	EV_SET(&kev, SIGHUP, EVFILT_SIGNAL, EV_ADD, 0, 0, NULL);
	kevent(kq, &kev, 1, NULL, 0, NULL);
	signal(SIGTERM, SIG_IGN);
	EV_SET(&kev, SIGTERM, EVFILT_SIGNAL, EV_ADD, 0, 0, NULL);
	kevent(kq, &kev, 1, NULL, 0, NULL);
	while (1) {
		int hupped = 0;
		int childdead = 0;
	
		if (conffd == -1)
			conffd = openconfig(confname, kq);

		child = launch(conffd, ud, ld);
		if (child == -1)
			logerr("failed to launch");

		/* monitor child */
		EV_SET(&kev, child, EVFILT_PROC, EV_ADD, NOTE_EXIT, 0, NULL);
		kevent(kq, &kev, 1, NULL, 0, NULL);

		/* wait for something to happen: HUP or child exiting */
		timeout = NULL;
		while (1) {
			r = kevent(kq, NULL, 0, &kev, 1, timeout);
			if (r == -1)
				logerr("kevent failed (%d)", errno);

			if (r == 0) {
				/* timeout expired */
				logerr("child died without HUP");
			} else if (kev.filter == EVFILT_VNODE) {
				/* config file changed */
				logmsg(LOG_INFO, "config changed, reloading");
				close(conffd);
				conffd = -1;
				sleep(1);
				raise(SIGHUP);
			} else if (kev.filter == EVFILT_SIGNAL &&
			    kev.ident == SIGHUP) {
				/* signaled. kill child. */
				logmsg(LOG_INFO, "received HUP, restarting");
				hupped = 1;
				if (childdead)
					break;
				kill(child, SIGHUP);
			} else if (kev.filter == EVFILT_SIGNAL &&
			    kev.ident == SIGTERM) {
				/* good bye */
				logmsg(LOG_INFO, "received TERM, quitting");
				kill(child, SIGTERM);
				exit(0);
			} else if (kev.filter == EVFILT_PROC) {
				/* child died. wait for our own HUP. */
				logmsg(LOG_INFO, "observed child exit");
				childdead = 1;
				if (hupped)
					break;
				memset(&ts, 0, sizeof(ts));
				ts.tv_sec = 1;
				timeout = &ts;
			} else {
				logerr("don't know what happened");
			}
		}
		wait(NULL);
	}
	return 1;
@


1.75
log
@implement random casing for query names, also known as 0x20 hardening.
this *should* work everywhere, and i consider minimum necessary protection
for a program like rebound. in the event it doesn't work, rebound can be
bypassed by disabling the port stealing sysctl.
@
text
@d1 1
a1 1
/* $OpenBSD: rebound.c,v 1.74 2016/10/08 06:33:59 tedu Exp $ */
d357 1
a357 1
minttl(struct dnspacket *resp, size_t rlen)
d359 1
a359 1
	uint32_t minttl = UINT_MAX, ttl, cnt, i;
d362 1
a362 1
	char *end = p + rlen;
d365 2
a366 2
	p += sizeof(struct dnspacket);
	if (p >= end)
d371 3
a373 3
	p += strnlen(p, end - p);
	p += 2;
	p += 2;
d376 1
a376 1
		if (p >= end)
d379 4
a382 4
		p += strnlen(p, end - p);
		p += 2;
		p += 2;
		if (p + 4 >= end)
d384 3
a386 3
		memcpy(&ttl, p, 4);
		p += 4;
		if (p + 2 >= end)
d391 3
a393 3
		memcpy(&len, p, 2);
		p += 2;
		p += ntohs(len);
@


1.74
log
@a little more precision about reloading config. only reopen if it changed
@
text
@d1 1
a1 1
/* $OpenBSD: rebound.c,v 1.73 2016/10/08 03:46:58 tedu Exp $ */
d35 1
d67 1
d70 1
d108 2
d165 28
d197 1
d200 6
d215 1
d281 5
d290 1
d310 16
d327 1
a327 11
	hit = calloc(1, sizeof(*hit));
	if (hit) {
		hit->req = malloc(r);
		if (hit->req) {
			memcpy(hit->req, dnsreq, r);
			hit->reqlen = r;
			hit->req->id = 0;
		} else {
			free(hit);
			hit = NULL;

d329 1
a330 1
	req->cacheent = hit;
d415 8
@


1.73
log
@too many blank lines
@
text
@d1 1
a1 1
/* $OpenBSD: rebound.c,v 1.72 2016/10/07 19:14:56 tedu Exp $ */
d703 1
a703 1
	int r, kq, ld, ud, ch, conffd;
d797 2
a798 1
		conffd = openconfig(confname, kq);
d821 2
a851 1
		close(conffd);
@


1.72
log
@the parent mostly never crashes, but the child might. or the config file
disappears. in such cases, the parent will exit. make sure to always
reset the jackport, not just when receiving sigterm.
(doesn't protect against parent crashing, but that shouldn't happen.)
@
text
@d1 1
a1 1
/* $OpenBSD: rebound.c,v 1.71 2016/10/07 19:07:36 tedu Exp $ */
a343 2


@


1.71
log
@several big changes, tied together.
switch to reading resolv.conf to find upstream name servers.
moitor this file and automatically restart if it changes.
use the dnsjackport sysctl to steal DNS connections from libc.
listen on port 54 to avoid collisions with other DNS servers.
@
text
@d1 1
a1 1
/* $OpenBSD: rebound.c,v 1.70 2016/09/01 10:57:24 tedu Exp $ */
d683 9
d771 1
a836 3
				jackport = 0;
				sysctl(dnsjacking, 2, NULL, NULL, &jackport,
				    sizeof(jackport));
@


1.70
log
@naming a union 'sockthing' was a bit silly. sockun will do for now.
@
text
@d1 1
a1 1
/* $OpenBSD: rebound.c,v 1.69 2016/09/01 10:55:21 tedu Exp $ */
d27 1
d37 1
d42 1
d461 1
a461 1
readconfig(FILE *conf, union sockun *remoteaddr)
d463 1
d465 1
d468 4
d473 2
a474 3
	if (fgets(buf, sizeof(buf), conf) == NULL)
		return -1;
	buf[strcspn(buf, "\n")] = '\0';
d476 23
a498 13
	memset(remoteaddr, 0, sizeof(*remoteaddr));
	if (inet_pton(AF_INET, buf, &sin->sin_addr) == 1) {
		sin->sin_len = sizeof(*sin);
		sin->sin_family = AF_INET;
		sin->sin_port = htons(53);
		return AF_INET;
	} else if (inet_pton(AF_INET6, buf, &sin6->sin6_addr) == 1) {
		sin6->sin6_len = sizeof(*sin6);
		sin6->sin6_family = AF_INET6;
		sin6->sin6_port = htons(53);
		return AF_INET6;
	} else {
		return -1;
d500 2
d505 1
a505 1
launch(FILE *conf, int ud, int ld, int kq)
d513 1
a513 1
	int i, r, af;
d518 1
a518 2
		if ((child = fork())) {
			fclose(conf);
a519 2
		}
		close(kq);
d546 1
a546 2
	af = readconfig(conf, &remoteaddr);
	fclose(conf);
d666 17
d693 2
d696 2
a697 3
	int r, kq, ld, ud, ch;
	int one;
	int childdead, hupped;
d702 1
a702 2
	const char *confname = "/etc/rebound.conf";
	FILE *conf;
d744 1
a744 1
	bindaddr.i.sin_port = htons(53);
a755 1
	one = 1;
d762 2
a763 4
	conf = fopen(confname, "r");
	if (!conf)
		logerr("failed to open config %s", confname);

a765 1
	signal(SIGHUP, SIG_IGN);
d767 4
a770 2
	if (debug)
		return launch(conf, ud, ld, -1);
d778 2
d782 3
d786 6
a791 3
		hupped = 0;
		childdead = 0;
		child = launch(conf, ud, ld, kq);
d809 7
a815 1
			} else if (kev.filter == EVFILT_SIGNAL) {
d822 9
a830 4
				conf = fopen(confname, "r");
				if (!conf)
					logerr("failed to open config %s",
					    confname);
d844 1
@


1.69
log
@print regular messages to stdout, not err
@
text
@d1 1
a1 1
/* $OpenBSD: rebound.c,v 1.68 2016/09/01 10:54:36 tedu Exp $ */
d45 1
a45 1
union sockthing {
d95 1
a95 1
	union sockthing from;
d223 1
a223 1
	union sockthing from;
d458 1
a458 1
readconfig(FILE *conf, union sockthing *remoteaddr)
d487 1
a487 1
	union sockthing remoteaddr;
d660 1
a660 1
	union sockthing bindaddr;
@


1.68
log
@scan responses for minimum ttl, and cache for min(ttl, 300) instead of
a fixed amount
@
text
@d1 1
a1 1
/* $OpenBSD: rebound.c,v 1.67 2016/08/21 21:23:48 tedu Exp $ */
d117 2
a118 2
		vfprintf(stderr, msg, ap);
		fprintf(stderr, "\n");
@


1.67
log
@introduce a union of sockaddr types and eliminate a lot of casts.
@
text
@d1 1
a1 1
/* $OpenBSD: rebound.c,v 1.66 2016/08/06 19:56:51 tedu Exp $ */
d32 1
d41 2
a65 8
struct dnsrr {
	uint16_t type;
	uint16_t class;
	uint32_t ttl;
	uint16_t rdatalen;
	/* ... */
};

d300 44
d351 1
d370 3
d374 1
a374 1
		ent->ts.tv_sec += 10;
@


1.66
log
@reset timeout to null when relooping
@
text
@d1 1
a1 1
/* $OpenBSD: rebound.c,v 1.65 2016/07/02 17:09:09 tedu Exp $ */
d42 7
d100 1
a100 1
	struct sockaddr from;
d228 1
a228 1
	struct sockaddr from;
d239 1
a239 1
	r = recvfrom(ud, buf, sizeof(buf), 0, &from, &fromlen);
d246 1
a246 1
		sendto(ud, hit->resp, hit->resplen, 0, &from, fromlen);
d290 1
a290 1
			servfail(ud, req->clientid, &from, fromlen);
d321 1
a321 1
	sendto(ud, buf, r, 0, &req->from, req->fromlen);
d415 1
a415 1
readconfig(FILE *conf, struct sockaddr_storage *remoteaddr)
d418 2
a419 2
	struct sockaddr_in *sin = (struct sockaddr_in *)remoteaddr;
	struct sockaddr_in6 *sin6 = (struct sockaddr_in6 *)remoteaddr;
d444 1
a444 1
	struct sockaddr_storage remoteaddr;
d540 1
a540 2
				if ((req = newrequest(ud,
				    (struct sockaddr *)&remoteaddr))) {
d546 1
a546 2
				if ((req = newtcprequest(ld,
				    (struct sockaddr *)&remoteaddr))) {
d617 1
a617 1
	struct sockaddr_in bindaddr;
d666 4
a669 4
	bindaddr.sin_len = sizeof(bindaddr);
	bindaddr.sin_family = AF_INET;
	bindaddr.sin_port = htons(53);
	inet_aton("127.0.0.1", &bindaddr.sin_addr);
d674 1
a674 1
	if (bind(ud, (struct sockaddr *)&bindaddr, sizeof(bindaddr)) == -1)
d682 1
a682 1
	if (bind(ld, (struct sockaddr *)&bindaddr, sizeof(bindaddr)) == -1)
@


1.65
log
@check cache tree for collisions when inserting replies.
if two identical requests are sent out, the first will create a cache
entry. the second will not go into the cache tree, but will linger around,
causing a crash when we free it and try to remove from the tree. instead,
give up if insert fails.
diagnosis and initial patch from Duncan.
@
text
@d1 1
a1 1
/* $OpenBSD: rebound.c,v 1.64 2016/06/05 22:41:41 tedu Exp $ */
d713 1
@


1.64
log
@previous change (r1.27) converted to using non blocking sockets and
spinning on them, trying to preemptively avoid kevent. i've come to
conclude this is a poor design. it is exceedingly rare for there to be
two requests waiting. instead, we end up burning useless syscalls.
@
text
@d1 1
a1 1
/* $OpenBSD: rebound.c,v 1.63 2016/05/31 16:50:11 tedu Exp $ */
d316 7
d326 2
a327 1
		if (!ent->resp)
d329 1
a333 1
		RB_INSERT(cachetree, &cachetree, ent);
@


1.63
log
@with the kernel perm check fixed, we can do this kevent after setuid,
but still needs to be before pledge. also check for failure.
@
text
@d1 1
a1 1
/* $OpenBSD: rebound.c,v 1.62 2016/05/13 00:19:02 tedu Exp $ */
d218 2
a219 2
static int
newrequest(int ud, struct request **reqp, struct sockaddr *remoteaddr)
a228 2
	*reqp = NULL;

d234 1
a234 1
		return -1;
d240 1
a240 1
		return 0;
d244 1
a244 1
		return -1;
d291 1
a291 2
	*reqp = req;
	return 0;
d295 1
a295 1
	return -1;
d358 1
d360 9
a368 1
	if (!(req = calloc(1, sizeof(*req))))
d370 1
d377 1
a377 9

	req->s = -1;
	req->fromlen = sizeof(req->from);
	req->client = accept(ld, &req->from, &req->fromlen);
	if (req->client == -1) {
		if (errno == ENFILE || errno == EMFILE)
			stopaccepting = 1;
		goto fail;
	}
d525 2
a526 4
				while (newrequest(ud, &req,
				    (struct sockaddr *)&remoteaddr) == 0) {
					if (!req)
						continue;
a529 2
					if (conncount > connmax)
						break;
d532 1
a532 1
				while ((req = newtcprequest(ld,
a537 2
					if (conncount > connmax)
						break;
d658 1
a658 1
	ud = socket(AF_INET, SOCK_DGRAM | SOCK_NONBLOCK, 0);
d664 1
a664 1
	ld = socket(AF_INET, SOCK_STREAM | SOCK_NONBLOCK, 0);
@


1.62
log
@fix logging.
1. va must be restarted before reuse.
2. don't syslog in debug. assume someone is watching stderr.
@
text
@d1 1
a1 1
/* $OpenBSD: rebound.c,v 1.61 2016/05/02 06:21:26 semarie Exp $ */
a458 2
	EV_SET(&kev[0], parent, EVFILT_PROC, EV_ADD, NOTE_EXIT, 0, NULL);
	kevent(kq, kev, 1, NULL, 0, NULL);
d464 5
d481 2
a482 1
	kevent(kq, kev, 4, NULL, 0, NULL);
@


1.61
log
@prepare userland for removing chroot(2) from allowed syscalls under pledge(2).

in rebound(8), the worker is still chrooted (and pledged). The supervisor
process remains unpledged in order to create workers.

ok tedu@@
@
text
@d1 1
a1 1
/* $OpenBSD: rebound.c,v 1.60 2016/01/03 18:15:17 tedu Exp $ */
a112 1
	va_start(ap, msg);
d114 1
d117 6
a123 2
	vsyslog(LOG_DAEMON | prio, msg, ap);
	va_end(ap);
a130 1
	va_start(ap, msg);
d132 1
d136 6
a142 2
	vsyslog(LOG_DAEMON | LOG_ERR, msg, ap);
	va_end(ap);
@


1.60
log
@forgot to call RB_INIT. but yet things mostly worked...
@
text
@d1 1
a1 1
/* $OpenBSD: rebound.c,v 1.59 2015/12/17 18:24:57 tedu Exp $ */
a608 3

	if (pledge("stdio rpath getpw inet proc id", NULL) == -1)
		logerr("pledge failed");
@


1.59
log
@add return code to newrequest to distinguish between cache hit and error.
we want to keep looping for more requests after a hit, not stop.
(though i'm reconsidering if the looping is worthwhile. maybe should just
return to kevent() after each request.)
@
text
@d1 1
a1 1
/* $OpenBSD: rebound.c,v 1.58 2015/12/12 17:19:51 tedu Exp $ */
d648 1
@


1.58
log
@correct comment
@
text
@d1 1
a1 1
/* $OpenBSD: rebound.c,v 1.57 2015/12/11 13:47:08 tedu Exp $ */
d210 2
a211 2
static struct request *
newrequest(int ud, struct sockaddr *remoteaddr)
d221 2
d228 1
a228 1
		return NULL;
d234 1
a234 1
		return NULL;
d238 1
a238 1
		return NULL;
d285 2
a286 1
	return req;
d290 1
a290 1
	return NULL;
d514 4
a517 2
				while ((req = newrequest(ud,
				    (struct sockaddr *)&remoteaddr))) {
@


1.57
log
@it's not necessary to use a tree to track requests if kevent can do this.
@
text
@d1 1
a1 1
/* $OpenBSD: rebound.c,v 1.56 2015/12/08 18:03:49 tedu Exp $ */
a68 1

d87 1
a87 1
 * requests are kept on both fifo and tree, but only after socket s is set.
@


1.56
log
@more better fake replies. servfail is the correct response.
@
text
@d1 1
a1 1
/* $OpenBSD: rebound.c,v 1.55 2015/12/05 11:51:23 tedu Exp $ */
a97 1
	RB_ENTRY(request) reqnode;
a102 2
static RB_HEAD(reqtree, request) reqtree;
RB_PROTOTYPE_STATIC(reqtree, request, reqnode, reqcmp)
a177 1
		RB_REMOVE(reqtree, &reqtree, req);
a199 7
static int
reqcmp(struct request *r1, struct request *r2)
{
	return (r1->s < r2->s ? -1 : r1->s > r2->s);
}
RB_GENERATE_STATIC(reqtree, request, reqnode, reqcmp)

a271 1
	RB_INSERT(reqtree, &reqtree, req);
a374 1
	RB_INSERT(reqtree, &reqtree, req);
d423 1
a423 1
	struct request reqkey, *req;
d500 1
a500 4
				reqkey.s = kev[i].ident;
				req = RB_FIND(reqtree, &reqtree, &reqkey);
				if (!req)
					logerr("lost partial tcp request");
d506 1
a506 1
					    EV_ADD, 0, 0, NULL);
d515 1
a515 1
					    EV_ADD, 0, 0, NULL);
d525 1
a525 1
					    EVFILT_READ, EV_ADD, 0, 0, NULL);
d531 1
a531 4
				reqkey.s = kev[i].ident;
				req = RB_FIND(reqtree, &reqtree, &reqkey);
				if (!req)
					logerr("lost request");
a641 1
	RB_INIT(&reqtree);
@


1.55
log
@all the signal ignoring can be done in one place
@
text
@d1 1
a1 1
/* $OpenBSD: rebound.c,v 1.54 2015/12/05 10:24:17 tedu Exp $ */
d212 1
a212 1
fakereply(int ud, uint16_t id, struct sockaddr *fromaddr, socklen_t fromlen)
d218 1
d288 1
a288 1
			fakereply(ud, req->clientid, &from, fromlen);
@


1.54
log
@pull the config file opening up considerably earlier to fail fast.
parsing is still done in the child, so we can't guarantee success, but if
the file is missing entirely we won't daemonize in that state.
@
text
@d1 1
a1 1
/* $OpenBSD: rebound.c,v 1.53 2015/12/04 16:44:20 tedu Exp $ */
a480 2
	signal(SIGUSR1, SIG_IGN);
	signal(SIGHUP, SIG_IGN);
a645 2
	signal(SIGPIPE, SIG_IGN);

d690 6
a695 4
	if (debug) {
		launch(conf, ud, ld, -1);
		return 1;
	}
a704 2
	signal(SIGUSR1, SIG_IGN);
	signal(SIGHUP, SIG_IGN);
@


1.53
log
@refine some logging and error messages. errors will now always go to stderr
until daemonized and syslog as well. make logerr() work more like err().
@
text
@d1 1
a1 1
/* $OpenBSD: rebound.c,v 1.52 2015/12/04 16:33:40 tedu Exp $ */
d430 1
a430 1
launch(const char *confname, int ud, int ld, int kq)
a437 1
	FILE *conf;
a440 6
	conf = fopen(confname, "r");
	if (!conf) {
		logmsg(LOG_ERR, "failed to open config %s", confname);
		return -1;
	}

d474 1
a474 1
		logerr("failed to read config %s", confname);
d623 2
a624 1
	const char *conffile = "/etc/rebound.conf";
d632 1
a632 1
			conffile = optarg;
d690 4
d695 1
a695 1
		launch(conffile, ud, ld, -1);
d712 1
a712 1
		child = launch(conffile, ud, ld, kq);
d736 4
@


1.52
log
@push daemon call a little later so if the address is in use we see the
error message
@
text
@d1 1
a1 1
/* $OpenBSD: rebound.c,v 1.51 2015/12/04 10:59:36 tedu Exp $ */
d44 1
d118 1
a118 1
	if (debug) {
a120 2
	} else {
		vsyslog(LOG_DAEMON | prio, msg, ap);
d122 1
d132 2
a133 1
	if (debug) {
a135 2
	} else {
		vsyslog(LOG_DAEMON | LOG_ERR, msg, ap);
d137 1
d657 1
a657 1
		err(1, "getrlimit");
d660 1
a660 1
		err(1, "setrlimit");
d682 1
a682 1
		err(1, "socket");
d684 1
a684 1
		err(1, "bind");
d688 1
a688 1
		err(1, "socket");
d692 1
a692 1
		err(1, "bind");
d694 1
a694 1
		err(1, "listen");
d701 3
a703 1
	daemon(0, 0);
@


1.51
log
@one signal.h should suffice
@
text
@d1 1
a1 1
/* $OpenBSD: rebound.c,v 1.50 2015/12/04 09:13:05 tedu Exp $ */
a669 3
	if (!debug)
		daemon(0, 0);

d700 2
@


1.50
log
@ignore SIGPIPE. i don't see any way for it to happen, but nevertheless we
definitely don't want to receive it unexpectedly.
@
text
@d1 1
a1 1
/* $OpenBSD: rebound.c,v 1.49 2015/12/04 04:50:43 gsoares Exp $ */
a25 1
#include <sys/signal.h>
@


1.49
log
@- sync usage

- add a bit more detail about config alternative file
and add -d while here.

manpage help from jmc@@ schwarze@@ thanks a lot!

OK tedu jmc schwarze
@
text
@d1 1
a1 1
/* $OpenBSD: rebound.c,v 1.48 2015/12/03 08:19:25 tedu Exp $ */
d654 2
@


1.48
log
@when running on a machine without net, rebound will still receive queries
from localhost, but then fail to forward them. this causes the resolver
to stall waiting for timeouts in situations where it would otherwise fail
quickly. we don't know this happens until it's too late, but we can push
the resolver forward by sending back empty replies.
ok deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: rebound.c,v 1.47 2015/12/01 23:43:55 gsoares Exp $ */
d616 1
a616 1
	fprintf(stderr, "usage: rebound [-c config]\n");
@


1.47
log
@add missing fclose(3)
ok tedu@@
@
text
@d1 1
a1 1
/* $OpenBSD: rebound.c,v 1.46 2015/11/27 21:12:08 tedu Exp $ */
d212 10
d287 2
@


1.46
log
@add getpw to pledge. rpath would normally suffice, but there's some double
checking code in snapshots, and it serves as a useful annotation.
from Carlin Bingham
@
text
@d1 1
a1 1
/* $OpenBSD: rebound.c,v 1.45 2015/11/24 00:21:55 deraadt Exp $ */
d439 2
a440 1
		if ((child = fork()))
d442 1
@


1.45
log
@use canonical pledge argument ordering
@
text
@d1 1
a1 1
/* $OpenBSD: rebound.c,v 1.44 2015/11/16 21:27:42 tedu Exp $ */
d619 1
a619 1
	if (pledge("stdio rpath inet proc id", NULL) == -1)
@


1.44
log
@improve logging slightly
@
text
@d1 1
a1 1
/* $OpenBSD: rebound.c,v 1.43 2015/11/16 20:56:56 tedu Exp $ */
d619 1
a619 1
	if (pledge("stdio inet proc id rpath", NULL) == -1)
@


1.43
log
@the list insertion needs to occur right after we get a valid socket,
as that is the hint that the request is on the list.
@
text
@d1 1
a1 1
/* $OpenBSD: rebound.c,v 1.42 2015/11/10 07:24:38 deraadt Exp $ */
d276 1
a276 1
		logmsg(LOG_NOTICE, "failed to connect");
d279 2
a280 1
	if (send(req->s, buf, r, 0) != r)
d282 1
@


1.42
log
@kill the whitespace.. kill the whitespace..
@
text
@d1 1
a1 1
/* $OpenBSD: rebound.c,v 1.41 2015/11/01 13:59:44 reyk Exp $ */
d271 4
a281 2
	TAILQ_INSERT_TAIL(&reqfifo, req, fifo);
	RB_INSERT(reqtree, &reqtree, req);
d371 4
a381 2
	TAILQ_INSERT_TAIL(&reqfifo, req, fifo);
	RB_INSERT(reqtree, &reqtree, req);
@


1.41
log
@chroot to pw_dir instead of the hard-coded /var/empty.  Also make the
chroot+chdir step look more like in the other privsep daemons.

OK tedu@@
@
text
@d1 1
a1 1
/* $OpenBSD: rebound.c,v 1.40 2015/10/30 15:44:12 tedu Exp $ */
d325 1
a325 1
	
@


1.40
log
@it is necessary to call tzset() to get syslog timestamps correct.
i am quite surprised by this, but it's the way things are, so do it.
reported by naddy
@
text
@d1 1
a1 1
/* $OpenBSD: rebound.c,v 1.39 2015/10/29 14:01:01 tedu Exp $ */
d443 1
a443 1
	if (chroot("/var/empty") || chdir("/"))
d445 2
@


1.39
log
@put timeout nullification in correct spot
@
text
@d1 1
a1 1
/* $OpenBSD: rebound.c,v 1.38 2015/10/29 14:00:06 tedu Exp $ */
d644 1
@


1.38
log
@be a little more precise about checking filters
@
text
@d1 1
a1 1
/* $OpenBSD: rebound.c,v 1.37 2015/10/29 13:54:43 tedu Exp $ */
d544 2
a558 1
		timeout = NULL;
@


1.37
log
@refold a few lines
@
text
@d1 1
a1 1
/* $OpenBSD: rebound.c,v 1.36 2015/10/29 12:58:10 tedu Exp $ */
d499 15
d533 1
a533 14
			} else if (kev[i].filter == EVFILT_WRITE) {
				reqkey.s = kev[i].ident;
				req = RB_FIND(reqtree, &reqtree, &reqkey);
				if (!req)
					logerr("lost partial tcp request");
				req = tcpphasetwo(req);
				if (req) {
					EV_SET(&ch[0], req->s, EVFILT_WRITE,
					    EV_DELETE, 0, 0, NULL);
					EV_SET(&ch[1], req->s, EVFILT_READ,
					    EV_ADD, 0, 0, NULL);
					kevent(kq, ch, 2, NULL, 0, NULL);
				}
			} else if (kev[i].filter == EVFILT_READ) {
a540 2
			} else {
				logerr("don't know what happened");
d703 1
@


1.36
log
@collect some cool stats and print them out with SIGUSR1
@
text
@d1 1
a1 1
/* $OpenBSD: rebound.c,v 1.35 2015/10/28 20:56:43 tedu Exp $ */
d416 1
a416 1
	struct kevent chlist[2], kev[4];
d435 1
a437 1
	close(kq);
d478 2
a479 2
			EV_SET(&chlist[0], ld, EVFILT_READ, EV_ADD, 0, 0, NULL);
			kevent(kq, chlist, 1, NULL, 0, NULL);
d502 1
a502 1
					EV_SET(&chlist[0], req->s, EVFILT_READ,
d504 1
a504 1
					kevent(kq, chlist, 1, NULL, 0, NULL);
d511 1
a511 1
					EV_SET(&chlist[0], req->s,
d514 1
a514 1
					kevent(kq, chlist, 1, NULL, 0, NULL);
d525 1
a525 1
					EV_SET(&chlist[0], req->s, EVFILT_WRITE,
d527 1
a527 1
					EV_SET(&chlist[1], req->s, EVFILT_READ,
d529 1
a529 1
					kevent(kq, chlist, 2, NULL, 0, NULL);
d545 2
a546 2
			EV_SET(&chlist[0], ld, EVFILT_READ, EV_DELETE, 0, 0, NULL);
			kevent(kq, chlist, 1, NULL, 0, NULL);
d706 1
a706 2
				logmsg(LOG_INFO,
				    "received HUP, restarting");
d713 1
a713 2
				logmsg(LOG_INFO,
				    "observed child exit");
@


1.35
log
@impose some limit on the cache size as well.
@
text
@d1 1
a1 1
/* $OpenBSD: rebound.c,v 1.34 2015/10/28 20:43:12 tedu Exp $ */
d85 1
d109 1
d164 2
d230 1
d351 1
d465 3
a467 1
	kevent(kq, kev, 3, NULL, 0, NULL);
d485 11
a495 2
				logmsg(LOG_INFO, "hupped, exiting");
				exit(0);
d683 1
@


1.34
log
@if accept() fails due to fd exhaustion, stop accepting for one second.
should only happen for ENFILE, but check for EMFILE too.
@
text
@d1 1
a1 1
/* $OpenBSD: rebound.c,v 1.33 2015/10/28 20:25:46 tedu Exp $ */
d83 3
d107 1
a107 1
static int connmax = 500;
d193 1
d307 1
d537 2
d623 2
@


1.33
log
@bug in the request tree code: requests were being added to the tree before
the socket (the key) was being set. move the enqueue code later, and fix
freerequest to only dequeue if socket is set.
@
text
@d1 1
a1 1
/* $OpenBSD: rebound.c,v 1.32 2015/10/28 20:20:35 tedu Exp $ */
d105 1
a105 1

d349 3
a351 1
	if (req->client == -1)
d353 1
d464 6
d522 8
d557 1
@


1.32
log
@twiddle with rlimit to give us a few more files. use rlimit as a hint as
to how many requests to allow open at once. start closing old ones as we
approach the limit, which means we track the number of outstanding requests
(and count tcp as two).
also rename tcp "phase" to tcp, and use it as a more direct indicator.
@
text
@d1 1
a1 1
/* $OpenBSD: rebound.c,v 1.31 2015/10/28 19:32:29 tedu Exp $ */
d83 3
d173 5
a177 2
	TAILQ_REMOVE(&reqfifo, req, fifo);
	RB_REMOVE(reqtree, &reqtree, req);
a179 2
	if (req->s != -1)
		close(req->s);
a231 2
	TAILQ_INSERT_TAIL(&reqfifo, req, fifo);
	RB_INSERT(reqtree, &reqtree, req);
d234 1
d269 2
a341 2
	TAILQ_INSERT_TAIL(&reqfifo, req, fifo);
	RB_INSERT(reqtree, &reqtree, req);
d362 2
d568 1
a568 1
	if (0 && pledge("stdio inet proc id rpath", NULL) == -1)
@


1.31
log
@add pledge to main process, though it needs a few more options
@
text
@d1 1
a1 1
/* $OpenBSD: rebound.c,v 1.30 2015/10/28 19:09:58 tedu Exp $ */
d24 1
d86 1
a86 1
	int phase;
d100 3
d166 4
d227 1
d309 1
a309 1
	req->phase = 2;
d336 1
d341 1
a351 1
	req->phase = 1;
d469 2
d476 1
a476 1
					    req->phase == 1 ? EVFILT_WRITE :
d479 2
d486 1
a486 1
					logerr("lost request");
d500 1
a500 1
				if (req->client == -1)
d508 3
d559 1
d563 1
a563 1
	if (pledge("stdio inet proc id rpath", NULL) == -1)
d584 9
@


1.30
log
@use an rb tree for the cache too. modelled after the reqtree.
@
text
@d1 1
a1 1
/* $OpenBSD: rebound.c,v 1.29 2015/10/28 18:48:03 tedu Exp $ */
d544 3
@


1.29
log
@use an rb tree for finding requests. from Dimitris Papastamos
@
text
@d1 1
a1 1
/* $OpenBSD: rebound.c,v 1.28 2015/10/26 12:24:48 tedu Exp $ */
d70 2
a71 1
	TAILQ_ENTRY(dnscache) cache;
d78 3
a80 1
static TAILQ_HEAD(, dnscache) cache;
d131 9
d143 1
a143 1
	struct dnscache *hit;
d148 5
a152 5
	TAILQ_FOREACH(hit, &cache, cache) {
		if (hit->reqlen == reqlen &&
		    memcmp(hit->req, dnsreq, reqlen) == 0)
			break;
	}
d178 2
a179 1
	TAILQ_REMOVE(&cache, ent, cache);
d289 2
a290 1
		TAILQ_INSERT_TAIL(&cache, ent, cache);
d496 1
a496 1
		while ((ent = TAILQ_FIRST(&cache))) {
d571 1
a571 1
	TAILQ_INIT(&cache);
@


1.28
log
@one second amnesty for timeouts so we don't spin with short timeouts
@
text
@d1 1
a1 1
/* $OpenBSD: rebound.c,v 1.27 2015/10/26 12:23:40 tedu Exp $ */
d22 1
d87 1
d93 2
d151 1
d172 7
d207 1
d314 1
d375 1
a375 1
	struct request *req;
d455 2
a456 6
				req = TAILQ_FIRST(&reqfifo);
				while (req) {
					if (req->s == kev[i].ident)
						break;
					req = TAILQ_NEXT(req, fifo);
				}
d468 2
a469 7
				/* use a tree here? */
				req = TAILQ_FIRST(&reqfifo);
				while (req) {
					if (req->s == kev[i].ident)
						break;
					req = TAILQ_NEXT(req, fifo);
				}
d555 1
@


1.27
log
@set listening sockets to nonblocking, then handle as many incoming requests
as we can in the loop instead of keventing per request.
@
text
@d1 1
a1 1
/* $OpenBSD: rebound.c,v 1.26 2015/10/17 00:38:57 tedu Exp $ */
d499 2
@


1.26
log
@don't need fcntl for non blocking socket, just ask for it upfront
@
text
@d1 1
a1 1
/* $OpenBSD: rebound.c,v 1.25 2015/10/16 20:25:09 tedu Exp $ */
d426 2
a427 3
				req = newrequest(ud,
				    (struct sockaddr *)&remoteaddr);
				if (req) {
d433 2
a434 3
				req = newtcprequest(ld,
				    (struct sockaddr *)&remoteaddr);
				if (req) {
d557 1
a557 1
	ud = socket(AF_INET, SOCK_DGRAM, 0);
d563 1
a563 1
	ld = socket(AF_INET, SOCK_STREAM, 0);
@


1.25
log
@save some file descriptors. instead of a pipe, use kevent to watch parent
@
text
@d1 1
a1 1
/* $OpenBSD: rebound.c,v 1.24 2015/10/16 20:12:06 tedu Exp $ */
a26 1
#include <fcntl.h>
d310 1
a310 1
	req->s = socket(remoteaddr->sa_family, SOCK_STREAM, 0);
a311 2
		goto fail;
	if (fcntl(req->s, F_SETFL, O_NONBLOCK) == -1)
@


1.24
log
@naddy would like the child to exit when the parent dies.
hook up a pipe between them and watch for eof in the child.
@
text
@d1 1
a1 1
/* $OpenBSD: rebound.c,v 1.23 2015/10/16 18:47:52 tedu Exp $ */
d359 1
a359 1
launch(const char *confname, int ud, int ld, int kq, int *pfd)
d369 1
a369 1
	pid_t child;
d377 1
a380 1
		close(pfd[1]);
d383 3
d393 2
a399 2
	close(kq);

a407 2
	kq = kqueue();

d411 1
a411 2
	EV_SET(&kev[3], pfd[0], EVFILT_READ, EV_ADD, 0, 0, NULL);
	kevent(kq, kev, 4, NULL, 0, NULL);
d425 3
a427 5
			} else if (kev[i].ident == pfd[0]) {
				if (kev[i].flags & EV_EOF) {
					logmsg(LOG_INFO, "parent died");
					exit(0);
				}
a522 1
	int pfd[2];
a577 2
	pipe(pfd);

d579 1
a579 1
		launch(conffile, ud, ld, -1, pfd);
d591 1
a591 1
		child = launch(conffile, ud, ld, kq, pfd);
@


1.23
log
@life is simpler if all requests go in the fifo, and then just remove them
in the error case instead of duplicating code.
@
text
@d1 1
a1 1
/* $OpenBSD: rebound.c,v 1.22 2015/10/16 18:38:53 tedu Exp $ */
d359 1
a359 1
launch(const char *confname, int ud, int ld, int kq)
d380 1
d410 2
a411 1
	kevent(kq, kev, 3, NULL, 0, NULL);
d425 5
d525 1
d581 2
d584 1
a584 1
		launch(conffile, ud, ld, -1);
d596 1
a596 1
		child = launch(conffile, ud, ld, kq);
@


1.22
log
@deraadt tells me i'm supposed to check if connect() actually worked.
@
text
@d1 1
a1 1
/* $OpenBSD: rebound.c,v 1.21 2015/10/16 18:29:05 tedu Exp $ */
d142 26
d195 1
d233 1
d235 1
a235 4
	free(hit);
	if (req->s != -1)
		close(req->s);
	free(req);
a267 26
static void
freerequest(struct request *req)
{
	struct dnscache *ent;

	TAILQ_REMOVE(&reqfifo, req, fifo);
	if (req->client != -1)
		close(req->client);
	if (req->s != -1)
		close(req->s);
	if ((ent = req->cacheent) && !ent->resp) {
		free(ent->req);
		free(ent);
	}
	free(req);
}

static void
freecacheent(struct dnscache *ent)
{
	TAILQ_REMOVE(&cache, ent, cache);
	free(ent->req);
	free(ent->resp);
	free(ent);
}

d301 1
a320 1
		TAILQ_INSERT_TAIL(&reqfifo, req, fifo);
a323 1
	TAILQ_INSERT_TAIL(&reqfifo, req, fifo);
d327 1
a327 5
	if (req->s != -1)
		close(req->s);
	if (req->client != -1)
		close(req->client);
	free(req);
a429 1
					TAILQ_INSERT_TAIL(&reqfifo, req, fifo);
@


1.21
log
@two phase handling for tcp so that slow connects don't stall the process
@
text
@d1 1
a1 1
/* $OpenBSD: rebound.c,v 1.20 2015/10/16 15:35:05 tedu Exp $ */
d272 3
d276 4
@


1.20
log
@save request length in cache. naddy noticed we weren't getting any hits.
@
text
@d1 1
a1 1
/* $OpenBSD: rebound.c,v 1.19 2015/10/16 02:09:31 tedu Exp $ */
d27 1
d82 1
d169 3
a203 2
	req->ts = now;
	req->ts.tv_sec += 30;
d270 18
d295 3
d307 1
a307 1
	if (connect(req->s, remoteaddr, remoteaddr->sa_len) == -1)
d309 8
a316 8
	if (setsockopt(req->client, SOL_SOCKET, SO_SPLICE, &req->s,
	    sizeof(req->s)) == -1)
		goto fail;
	if (setsockopt(req->s, SOL_SOCKET, SO_SPLICE, &req->client,
	    sizeof(req->client)) == -1)
		goto fail;
	req->ts = now;
	req->ts.tv_sec += 30;
d318 1
d361 1
a361 1
	struct kevent chlist[1], kev[4];
d435 19
a453 1
					EV_SET(&chlist[0], req->s, EVFILT_READ,
d455 1
a455 2
					kevent(kq, chlist, 1, NULL, 0, NULL);
					TAILQ_INSERT_TAIL(&reqfifo, req, fifo);
@


1.19
log
@fine tune the logging some more
@
text
@d1 1
a1 1
/* $OpenBSD: rebound.c,v 1.18 2015/10/16 01:58:28 tedu Exp $ */
d180 1
@


1.18
log
@simplify logging functions. once a daemon, always a daemon
@
text
@d1 1
a1 1
/* $OpenBSD: rebound.c,v 1.17 2015/10/16 01:55:19 tedu Exp $ */
d384 1
d394 1
d500 2
d554 3
@


1.17
log
@safety check that we're dealing with the filter we expect
@
text
@d1 1
a1 1
/* $OpenBSD: rebound.c,v 1.16 2015/10/16 01:50:39 tedu Exp $ */
d102 1
a102 1
		vsyslog(prio, msg, ap);
d108 1
a108 1
logerr(int prio, const char *msg, ...)
d117 1
a117 1
		vsyslog(prio, msg, ap);
d193 1
a193 1
		logmsg(LOG_DAEMON | LOG_NOTICE, "failed to connect");
d346 1
a346 1
		logmsg(LOG_DAEMON | LOG_ERR, "failed to open config %s", confname);
d356 1
a356 1
		logerr(LOG_DAEMON | LOG_ERR, "getpwnam failed");
d359 1
a359 1
		logerr(LOG_DAEMON | LOG_ERR, "chroot failed (%d)", errno);
d365 1
a365 1
		logerr(LOG_DAEMON | LOG_ERR, "failed to privdrop");
d370 1
a370 1
		logerr(LOG_DAEMON | LOG_ERR, "pledge failed");
d375 1
a375 1
		logerr(LOG_DAEMON | LOG_ERR, "failed to read config %s", confname);
d387 1
a387 1
			logerr(LOG_DAEMON | LOG_ERR, "kevent failed (%d)", errno);
d421 1
a421 2
					logerr(LOG_DAEMON | LOG_ERR,
					    "lost request");
d426 1
a426 2
				logerr(LOG_DAEMON | LOG_ERR,
				    "don't know what happened");
d541 1
a541 1
			logerr(LOG_DAEMON | LOG_ERR, "failed to launch");
d551 1
a551 2
				logerr(LOG_DAEMON | LOG_ERR,
				    "child died without HUP");
d554 1
a554 1
				logmsg(LOG_DAEMON | LOG_INFO,
d562 1
a562 1
				logmsg(LOG_DAEMON | LOG_INFO,
d571 1
a571 2
				logerr(LOG_DAEMON | LOG_ERR,
				    "don't know what happened");
@


1.16
log
@most things should be static
@
text
@d1 1
a1 1
/* $OpenBSD: rebound.c,v 1.15 2015/10/16 01:37:14 tedu Exp $ */
d412 1
a412 1
			} else {
d426 3
@


1.15
log
@exit(1) is better for the impossible condition
@
text
@d1 1
a1 1
/* $OpenBSD: rebound.c,v 1.14 2015/10/15 22:21:28 tedu Exp $ */
d41 2
a42 2
struct timespec now;
int debug;
d76 1
a76 1
TAILQ_HEAD(, dnscache) cache;
d89 1
a89 1
TAILQ_HEAD(, request) reqfifo;
d92 1
a92 1
void
d107 1
a107 1
void __dead
d123 1
a123 1
struct dnscache *
d140 1
a140 1
struct request *
d210 1
a210 1
void
d239 1
a239 1
void
d256 1
a256 1
void
d265 1
a265 1
struct request *
d304 1
a304 1
int
d331 1
a331 1
int
@


1.14
log
@it is perhaps better style to not call close() on -1, even if harmless
@
text
@d1 1
a1 1
/* $OpenBSD: rebound.c,v 1.13 2015/10/15 22:17:43 tedu Exp $ */
d455 2
a456 1
	exit(0);
@


1.13
log
@make sure req is zeroed in tcp case
@
text
@d1 1
a1 1
/* $OpenBSD: rebound.c,v 1.12 2015/10/15 22:12:26 tedu Exp $ */
d204 2
a205 1
	close(req->s);
d245 4
a248 2
	close(req->client);
	close(req->s);
d294 1
d296 4
a299 2
	close(req->s);
	close(req->client);
@


1.12
log
@better memory handling of the request/cache chain
@
text
@d1 1
a1 1
/* $OpenBSD: rebound.c,v 1.11 2015/10/15 21:59:54 tedu Exp $ */
d267 1
a267 1
	if (!(req = malloc(sizeof(*req))))
@


1.11
log
@do not insert entry into cache until it's fully formed
@
text
@d1 1
a1 1
/* $OpenBSD: rebound.c,v 1.10 2015/10/15 21:56:52 tedu Exp $ */
d62 6
d203 1
d214 1
d226 5
a230 5
	if (req->cacheent) {
		req->cacheent->ts = now;
		req->cacheent->ts.tv_sec += 10;
		req->cacheent->resp = malloc(r);
		if (!req->cacheent->resp)
d232 3
a234 3
		memcpy(req->cacheent->resp, buf, r);
		req->cacheent->resplen = r;
		TAILQ_INSERT_TAIL(&cache, req->cacheent, cache);
d241 2
d246 4
@


1.10
log
@doh, not all requests are the same size. check len first.
@
text
@d1 1
a1 1
/* $OpenBSD: rebound.c,v 1.9 2015/10/15 21:39:15 tedu Exp $ */
a220 1
		TAILQ_INSERT_TAIL(&cache, req->cacheent, cache);
d226 1
@


1.9
log
@assert is the wrong tool
@
text
@d1 1
a1 1
/* $OpenBSD: rebound.c,v 1.8 2015/10/15 21:35:27 tedu Exp $ */
d126 2
a127 1
		if (memcmp(hit->req, dnsreq, reqlen) == 0)
@


1.8
log
@the inet sockets don't work well with inet6 addrs. pick family from addr.
detected by naddy
@
text
@d1 1
a1 1
/* $OpenBSD: rebound.c,v 1.7 2015/10/15 21:25:05 tedu Exp $ */
a33 1
#include <assert.h>
d399 3
a401 1
				assert(req);
@


1.7
log
@introduce logerr, since most logging is followed by exit
@
text
@d1 1
a1 1
/* $OpenBSD: rebound.c,v 1.6 2015/10/15 21:20:09 tedu Exp $ */
d183 1
a183 1
	req->s = socket(AF_INET, SOCK_DGRAM, 0);
d262 1
a262 1
	req->s = socket(AF_INET, SOCK_STREAM, 0);
@


1.6
log
@now with _rebound user, we can try a little harder at privdrop
@
text
@d1 1
a1 1
/* $OpenBSD: rebound.c,v 1.5 2015/10/15 20:58:14 tedu Exp $ */
d102 16
d187 1
a187 1
		logmsg(0, "failed to connect");
d335 2
a336 4
	if (!(pwd = getpwnam("_rebound"))) {
		logmsg(LOG_DAEMON | LOG_ERR, "getpwnam failed");
		exit(1);
	}
d338 2
a339 4
	if (chroot("/var/empty") || chdir("/")) {
		logmsg(LOG_DAEMON | LOG_ERR, "chroot failed (%d)", errno);
		exit(1);
	}
d344 2
a345 4
	    setresuid(pwd->pw_uid, pwd->pw_uid, pwd->pw_uid)) {
		logmsg(LOG_DAEMON | LOG_ERR, "failed to privdrop");
		exit(1);
	}
d349 2
a350 4
	if (pledge("stdio inet", NULL) == -1) {
		logmsg(LOG_DAEMON | LOG_ERR, "pledge failed");
		exit(1);
	}
d354 2
a355 4
	if (af == -1) {
		logmsg(LOG_DAEMON | LOG_ERR, "failed to read config %s", confname);
		exit(1);
	}
d366 3
a368 4
		if (r == -1) {
			logmsg(LOG_DAEMON | LOG_ERR, "kevent failed (%d)", errno);
			exit(1);
		}
d516 3
a518 4
		if (child == -1) {
			logmsg(LOG_DAEMON | LOG_ERR, "failed to launch");
			return 1;
		}
d527 1
a527 1
				logmsg(LOG_DAEMON | LOG_ERR,
a528 1
				return 1;
d548 1
a548 1
				logmsg(LOG_DAEMON | LOG_ERR,
@


1.5
log
@make the HUP interlocking in the parent work better.
@
text
@d1 1
a1 1
/* $OpenBSD: rebound.c,v 1.4 2015/10/15 20:47:11 deraadt Exp $ */
d319 4
a322 1
	pwd = getpwnam("nobody");
d330 6
a335 1
	setresuid(pwd->pw_uid, pwd->pw_uid, pwd->pw_uid);
@


1.4
log
@trivial KNF
@
text
@d1 1
a1 1
/* $OpenBSD: rebound.c,v 1.3 2015/10/15 20:13:57 tedu Exp $ */
d436 1
a438 1
	int hupped = 0;
d500 2
d515 2
a516 1
				logmsg(LOG_DAEMON | LOG_ERR, "child died without HUP");
d518 1
a518 2
			}
			if (kev.filter == EVFILT_SIGNAL) {
d520 2
d523 2
d526 13
a538 1
				break;
a539 4
			/* child died. wait one second for our own HUP. */
			memset(&ts, 0, sizeof(ts));
			ts.tv_sec = 1;
			timeout = &ts;
@


1.3
log
@just a space in usage, from deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: rebound.c,v 1.2 2015/10/15 19:49:22 tedu Exp $ */
d215 2
a216 1
freerequest(struct request *req) {
d224 2
a225 1
freecacheent(struct dnscache *ent) {
@


1.2
log
@child can be pledged down a bit to just sockets and io
@
text
@d1 1
a1 1
/* $OpenBSD: rebound.c,v 1.1 2015/10/15 19:43:30 tedu Exp $ */
d424 1
a424 1
	fprintf(stderr, "usage:\trebound [-c config]\n");
@


1.1
log
@import rebound, a lightweight dns proxy, for further polishing
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d328 5
@

