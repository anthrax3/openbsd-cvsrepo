head	1.32;
access;
symbols
	OPENBSD_6_0:1.32.0.2
	OPENBSD_6_0_BASE:1.32
	OPENBSD_5_9:1.25.0.2
	OPENBSD_5_9_BASE:1.25
	OPENBSD_5_8:1.21.0.4
	OPENBSD_5_8_BASE:1.21
	OPENBSD_5_7:1.17.0.2
	OPENBSD_5_7_BASE:1.17
	OPENBSD_5_6:1.16.0.6
	OPENBSD_5_6_BASE:1.16
	OPENBSD_5_5:1.16.0.4
	OPENBSD_5_5_BASE:1.16
	OPENBSD_5_4:1.15.0.2
	OPENBSD_5_4_BASE:1.15
	OPENBSD_5_3:1.12.0.10
	OPENBSD_5_3_BASE:1.12
	OPENBSD_5_2:1.12.0.8
	OPENBSD_5_2_BASE:1.12
	OPENBSD_5_1_BASE:1.12
	OPENBSD_5_1:1.12.0.6
	OPENBSD_5_0:1.12.0.4
	OPENBSD_5_0_BASE:1.12
	OPENBSD_4_9:1.12.0.2
	OPENBSD_4_9_BASE:1.12
	OPENBSD_4_8:1.11.0.2
	OPENBSD_4_8_BASE:1.11
	OPENBSD_4_7:1.8.0.2
	OPENBSD_4_7_BASE:1.8
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2;
locks; strict;
comment	@ * @;


1.32
date	2016.07.15.17.09.25;	author renato;	state Exp;
branches;
next	1.31;
commitid	VGEMIeHBWOrVJjkU;

1.31
date	2016.05.23.19.06.03;	author renato;	state Exp;
branches;
next	1.30;
commitid	92odz4Q2491RkKUo;

1.30
date	2016.05.23.19.04.55;	author renato;	state Exp;
branches;
next	1.29;
commitid	jK8Nhdc9G4Vfgvfh;

1.29
date	2016.05.23.19.03.52;	author renato;	state Exp;
branches;
next	1.28;
commitid	y8Lf2n2b2JKzxJhX;

1.28
date	2016.05.23.19.02.49;	author renato;	state Exp;
branches;
next	1.27;
commitid	ZOmKtugTZIW20zTz;

1.27
date	2016.05.23.19.01.08;	author renato;	state Exp;
branches;
next	1.26;
commitid	y9RrB4GquJHVOOcc;

1.26
date	2016.05.23.17.53.11;	author renato;	state Exp;
branches;
next	1.25;
commitid	N3pOoaChGeP2HegE;

1.25
date	2015.12.05.13.11.48;	author claudio;	state Exp;
branches;
next	1.24;
commitid	c8UgZO1MU5iqaNd3;

1.24
date	2015.10.23.10.11.20;	author renato;	state Exp;
branches;
next	1.23;
commitid	PxBFa3HAVsix8oI8;

1.23
date	2015.09.27.17.30.38;	author stsp;	state Exp;
branches;
next	1.22;
commitid	pKhBZfZX0D7hOGSk;

1.22
date	2015.09.13.11.13.12;	author deraadt;	state Exp;
branches;
next	1.21;
commitid	HmZqjbpn4mjxGSj3;

1.21
date	2015.07.21.09.34.57;	author claudio;	state Exp;
branches;
next	1.20;
commitid	M6IOl3rwEY5JLAh4;

1.20
date	2015.07.21.05.44.50;	author renato;	state Exp;
branches;
next	1.19;
commitid	h1uxwLTDb1rFheT9;

1.19
date	2015.07.21.05.42.50;	author renato;	state Exp;
branches;
next	1.18;
commitid	zElzUcSkVcgqY4Vt;

1.18
date	2015.04.04.16.29.48;	author renato;	state Exp;
branches;
next	1.17;
commitid	uu2sOmUZ7XkkqMrH;

1.17
date	2015.01.15.23.51.04;	author deraadt;	state Exp;
branches;
next	1.16;
commitid	tWXYkCpwvaEBzxa0;

1.16
date	2013.11.14.20.48.52;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2013.06.04.02.40.17;	author claudio;	state Exp;
branches;
next	1.14;

1.14
date	2013.06.04.02.28.58;	author claudio;	state Exp;
branches;
next	1.13;

1.13
date	2013.06.01.19.29.23;	author claudio;	state Exp;
branches;
next	1.12;

1.12
date	2010.09.01.13.59.17;	author claudio;	state Exp;
branches;
next	1.11;

1.11
date	2010.07.08.09.42.32;	author claudio;	state Exp;
branches;
next	1.10;

1.10
date	2010.06.07.13.24.23;	author claudio;	state Exp;
branches;
next	1.9;

1.9
date	2010.04.13.15.42.09;	author michele;	state Exp;
branches;
next	1.8;

1.8
date	2010.03.03.10.18.35;	author claudio;	state Exp;
branches;
next	1.7;

1.7
date	2010.01.02.14.56.02;	author michele;	state Exp;
branches;
next	1.6;

1.6
date	2009.11.02.20.35.20;	author claudio;	state Exp;
branches;
next	1.5;

1.5
date	2009.09.14.11.49.25;	author claudio;	state Exp;
branches;
next	1.4;

1.4
date	2009.08.02.16.19.17;	author michele;	state Exp;
branches;
next	1.3;

1.3
date	2009.08.01.12.47.02;	author michele;	state Exp;
branches;
next	1.2;

1.2
date	2009.06.13.16.47.32;	author michele;	state Exp;
branches;
next	1.1;

1.1
date	2009.06.01.20.59.45;	author michele;	state Exp;
branches;
next	;


desc
@@


1.32
log
@Improve logging of reserved labels.

Print "exp-null" and "imp-null" instead of "0" and "3", for example. Also,
remove print_label() and print_pw_type() from ldpctl.c and use the
equivalent functions from ldpd's log.c.

While here, be more paranoid and use UINT32_MAX instead of UINT_MAX
for NO_LABEL.
@
text
@/*	$OpenBSD: ldpctl.c,v 1.31 2016/05/23 19:06:03 renato Exp $
 *
 * Copyright (c) 2009 Michele Marchetto <michele@@openbsd.org>
 * Copyright (c) 2005 Claudio Jeker <claudio@@openbsd.org>
 * Copyright (c) 2004, 2005 Esben Norby <norby@@openbsd.org>
 * Copyright (c) 2003 Henning Brauer <henning@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/socket.h>
#include <sys/un.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <net/if_media.h>
#include <net/if_types.h>
#include <netmpls/mpls.h>

#include <err.h>
#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <limits.h>

#include "ldp.h"
#include "ldpd.h"
#include "ldpe.h"
#include "log.h"
#include "parser.h"

__dead void	 usage(void);
const char	*fmt_timeframe_core(time_t);
const char	*get_linkstate(uint8_t, int);
int		 show_interface_msg(struct imsg *, struct parse_result *);
int		 show_discovery_msg(struct imsg *, struct parse_result *);
uint64_t	 get_ifms_type(uint8_t);
int		 show_lib_msg(struct imsg *, struct parse_result *);
int		 show_nbr_msg(struct imsg *, struct parse_result *);
void		 show_fib_head(void);
int		 show_fib_msg(struct imsg *, struct parse_result *);
void		 show_interface_head(void);
int		 show_fib_interface_msg(struct imsg *);
int		 show_l2vpn_pw_msg(struct imsg *);
int		 show_l2vpn_binding_msg(struct imsg *);
const char	*get_media_descr(uint64_t);
void		 print_baudrate(uint64_t);

struct imsgbuf	*ibuf;

__dead void
usage(void)
{
	extern char *__progname;

	fprintf(stderr, "usage: %s command [argument ...]\n", __progname);
	exit(1);
}

int
main(int argc, char *argv[])
{
	struct sockaddr_un	 sun;
	struct parse_result	*res;
	struct imsg		 imsg;
	unsigned int		 ifidx = 0;
	struct kroute		 kr;
	int			 ctl_sock;
	int			 done = 0, verbose = 0;
	int			 n;
	struct ctl_nbr		 nbr;

	/* parse options */
	if ((res = parse(argc - 1, argv + 1)) == NULL)
		exit(1);

	/* connect to ldpd control socket */
	if ((ctl_sock = socket(AF_UNIX, SOCK_STREAM, 0)) == -1)
		err(1, "socket");

	memset(&sun, 0, sizeof(sun));
	sun.sun_family = AF_UNIX;
	strlcpy(sun.sun_path, LDPD_SOCKET, sizeof(sun.sun_path));
	if (connect(ctl_sock, (struct sockaddr *)&sun, sizeof(sun)) == -1)
		err(1, "connect: %s", LDPD_SOCKET);

	if (pledge("stdio", NULL) == -1)
		err(1, "pledge");

	if ((ibuf = malloc(sizeof(struct imsgbuf))) == NULL)
		err(1, NULL);
	imsg_init(ibuf, ctl_sock);
	done = 0;

	/* process user request */
	switch (res->action) {
	case NONE:
		usage();
		/* not reached */
	case SHOW:
	case SHOW_IFACE:
		printf("%-4s %-11s %-6s %-10s %-8s %-12s %3s\n",
		    "AF", "Interface", "State", "Linkstate", "Uptime",
		    "Hello Timers", "ac");
		if (*res->ifname) {
			ifidx = if_nametoindex(res->ifname);
			if (ifidx == 0)
				errx(1, "no such interface %s", res->ifname);
		}
		imsg_compose(ibuf, IMSG_CTL_SHOW_INTERFACE, 0, 0, -1,
		    &ifidx, sizeof(ifidx));
		break;
	case SHOW_DISC:
		printf("%-4s %-15s %-8s %-15s %9s\n",
		    "AF", "ID", "Type", "Source", "Holdtime");
		imsg_compose(ibuf, IMSG_CTL_SHOW_DISCOVERY, 0, 0, -1,
		    NULL, 0);
		break;
	case SHOW_NBR:
		printf("%-4s %-15s %-11s %-15s %8s\n",
		    "AF", "ID", "State", "Remote Address", "Uptime");
		imsg_compose(ibuf, IMSG_CTL_SHOW_NBR, 0, 0, -1, NULL, 0);
		break;
	case SHOW_LIB:
		printf("%-4s %-20s %-15s %-11s %-13s %6s\n", "AF",
		    "Destination", "Nexthop", "Local Label", "Remote Label",
		    "In Use");
		imsg_compose(ibuf, IMSG_CTL_SHOW_LIB, 0, 0, -1, NULL, 0);
		break;
	case SHOW_FIB:
		if (!ldp_addrisset(res->family, &res->addr))
			imsg_compose(ibuf, IMSG_CTL_KROUTE, 0, 0, -1,
			    &res->flags, sizeof(res->flags));
		else {
			memset(&kr, 0, sizeof(kr));
			kr.af = res->family;
			kr.prefix = res->addr;
			imsg_compose(ibuf, IMSG_CTL_KROUTE_ADDR, 0, 0, -1,
			    &kr, sizeof(kr));
		}
		show_fib_head();
		break;
	case SHOW_FIB_IFACE:
		if (*res->ifname)
			imsg_compose(ibuf, IMSG_CTL_IFINFO, 0, 0, -1,
			    res->ifname, sizeof(res->ifname));
		else
			imsg_compose(ibuf, IMSG_CTL_IFINFO, 0, 0, -1, NULL, 0);
		show_interface_head();
		break;
	case SHOW_L2VPN_PW:
		printf("%-11s %-15s %-14s %-10s\n",
		    "Interface", "Neighbor", "PWID", "Status");
		imsg_compose(ibuf, IMSG_CTL_SHOW_L2VPN_PW, 0, 0, -1, NULL, 0);
		break;
	case SHOW_L2VPN_BINDING:
		imsg_compose(ibuf, IMSG_CTL_SHOW_L2VPN_BINDING, 0, 0, -1,
		    NULL, 0);
		break;
	case CLEAR_NBR:
		memset(&nbr, 0, sizeof(nbr));
		nbr.af = res->family;
		memcpy(&nbr.raddr, &res->addr, sizeof(nbr.raddr));
		imsg_compose(ibuf, IMSG_CTL_CLEAR_NBR, 0, 0, -1, &nbr,
		    sizeof(nbr));
		done = 1;
		break;
	case FIB:
		errx(1, "fib couple|decouple");
		break;
	case FIB_COUPLE:
		imsg_compose(ibuf, IMSG_CTL_FIB_COUPLE, 0, 0, -1, NULL, 0);
		printf("couple request sent.\n");
		done = 1;
		break;
	case FIB_DECOUPLE:
		imsg_compose(ibuf, IMSG_CTL_FIB_DECOUPLE, 0, 0, -1, NULL, 0);
		printf("decouple request sent.\n");
		done = 1;
		break;
	case LOG_VERBOSE:
		verbose = 1;
		/* FALLTHROUGH */
	case LOG_BRIEF:
		imsg_compose(ibuf, IMSG_CTL_LOG_VERBOSE, 0, 0, -1,
		    &verbose, sizeof(verbose));
		printf("logging request sent.\n");
		done = 1;
		break;
	case RELOAD:
		imsg_compose(ibuf, IMSG_CTL_RELOAD, 0, 0, -1, NULL, 0);
		printf("reload request sent.\n");
		done = 1;
		break;
	}

	while (ibuf->w.queued)
		if (msgbuf_write(&ibuf->w) <= 0 && errno != EAGAIN)
			err(1, "write error");

	while (!done) {
		if ((n = imsg_read(ibuf)) == -1 && errno != EAGAIN)
			errx(1, "imsg_read error");
		if (n == 0)
			errx(1, "pipe closed");

		while (!done) {
			if ((n = imsg_get(ibuf, &imsg)) == -1)
				errx(1, "imsg_get error");
			if (n == 0)
				break;
			switch (res->action) {
			case SHOW:
			case SHOW_IFACE:
				done = show_interface_msg(&imsg, res);
				break;
			case SHOW_DISC:
				done = show_discovery_msg(&imsg, res);
				break;
			case SHOW_NBR:
				done = show_nbr_msg(&imsg, res);
				break;
			case SHOW_LIB:
				done = show_lib_msg(&imsg, res);
				break;
			case SHOW_FIB:
				done = show_fib_msg(&imsg, res);
				break;
			case SHOW_FIB_IFACE:
				done = show_fib_interface_msg(&imsg);
				break;
			case SHOW_L2VPN_PW:
				done = show_l2vpn_pw_msg(&imsg);
				break;
			case SHOW_L2VPN_BINDING:
				done = show_l2vpn_binding_msg(&imsg);
				break;
			case NONE:
			case CLEAR_NBR:
			case FIB:
			case FIB_COUPLE:
			case FIB_DECOUPLE:
			case LOG_VERBOSE:
			case LOG_BRIEF:
			case RELOAD:
				break;
			}
			imsg_free(&imsg);
		}
	}
	close(ctl_sock);
	free(ibuf);

	return (0);
}

uint64_t
get_ifms_type(uint8_t if_type)
{
	switch (if_type) {
	case IFT_ETHER:
		return (IFM_ETHER);
		break;
	case IFT_FDDI:
		return (IFM_FDDI);
		break;
	case IFT_CARP:
		return (IFM_CARP);
		break;
	default:
		return (0);
		break;
	}
}

#define	TF_BUFS	8
#define	TF_LEN	9

const char *
fmt_timeframe_core(time_t t)
{
	char		*buf;
	static char	 tfbuf[TF_BUFS][TF_LEN];	/* ring buffer */
	static int	 idx = 0;
	unsigned int	 sec, min, hrs, day, week;

	if (t == 0)
		return ("Stopped");

	buf = tfbuf[idx++];
	if (idx == TF_BUFS)
		idx = 0;

	week = t;

	sec = week % 60;
	week /= 60;
	min = week % 60;
	week /= 60;
	hrs = week % 24;
	week /= 24;
	day = week % 7;
	week /= 7;

	if (week > 0)
		snprintf(buf, TF_LEN, "%02uw%01ud%02uh", week, day, hrs);
	else if (day > 0)
		snprintf(buf, TF_LEN, "%01ud%02uh%02um", day, hrs, min);
	else
		snprintf(buf, TF_LEN, "%02u:%02u:%02u", hrs, min, sec);

	return (buf);
}

int
show_interface_msg(struct imsg *imsg, struct parse_result *res)
{
	struct ctl_iface	*iface;
	char			*timers;

	switch (imsg->hdr.type) {
	case IMSG_CTL_SHOW_INTERFACE:
		iface = imsg->data;

		if (res->family != AF_UNSPEC && res->family != iface->af)
			break;

		if (asprintf(&timers, "%u/%u", iface->hello_interval,
		    iface->hello_holdtime) == -1)
			err(1, NULL);

		printf("%-4s %-11s %-6s %-10s %-8s %-12s %3u\n",
		    af_name(iface->af), iface->name,
		    if_state_name(iface->state), get_linkstate(iface->if_type,
		    iface->linkstate), iface->uptime == 0 ? "00:00:00" :
		    fmt_timeframe_core(iface->uptime), timers, iface->adj_cnt);
		free(timers);
		break;
	case IMSG_CTL_END:
		printf("\n");
		return (1);
	default:
		break;
	}

	return (0);
}

int
show_discovery_msg(struct imsg *imsg, struct parse_result *res)
{
	struct ctl_adj	*adj;
	const char	*addr;

	switch (imsg->hdr.type) {
	case IMSG_CTL_SHOW_DISCOVERY:
		adj = imsg->data;

		if (res->family != AF_UNSPEC && res->family != adj->af)
			break;

		printf("%-4s %-15s ", af_name(adj->af), inet_ntoa(adj->id));
		switch(adj->type) {
		case HELLO_LINK:
			printf("%-8s %-15s ", "Link", adj->ifname);
			break;
		case HELLO_TARGETED:
			addr = log_addr(adj->af, &adj->src_addr);

			printf("%-8s %-15s ", "Targeted", addr);
			if (strlen(addr) > 15)
				printf("\n%46s", " ");
			break;
		}
		printf("%9u\n", adj->holdtime);
		break;
	case IMSG_CTL_END:
		printf("\n");
		return (1);
	default:
		break;
	}

	return (0);
}

int
show_lib_msg(struct imsg *imsg, struct parse_result *res)
{
	struct ctl_rt	*rt;
	char		*dstnet;

	switch (imsg->hdr.type) {
	case IMSG_CTL_SHOW_LIB:
		rt = imsg->data;

		if (res->family != AF_UNSPEC && res->family != rt->af)
			break;

		if (asprintf(&dstnet, "%s/%d", log_addr(rt->af, &rt->prefix),
		    rt->prefixlen) == -1)
			err(1, NULL);

		printf("%-4s %-20s", af_name(rt->af), dstnet);
		if (strlen(dstnet) > 20)
			printf("\n%25s", " ");
		printf(" %-15s %-11s %-13s %6s\n", inet_ntoa(rt->nexthop),
		    log_label(rt->local_label), log_label(rt->remote_label),
		    rt->in_use ? "yes" : "no");

		free(dstnet);
		break;
	case IMSG_CTL_END:
		printf("\n");
		return (1);
	default:
		break;
	}

	return (0);
}

int
show_nbr_msg(struct imsg *imsg, struct parse_result *res)
{
	struct ctl_nbr	*nbr;
	const char	*addr;

	switch (imsg->hdr.type) {
	case IMSG_CTL_SHOW_NBR:
		nbr = imsg->data;

		if (res->family != AF_UNSPEC && res->family != nbr->af)
			break;

		addr = log_addr(nbr->af, &nbr->raddr);

		printf("%-4s %-15s %-11s %-15s",
		    af_name(nbr->af), inet_ntoa(nbr->id),
		    nbr_state_name(nbr->nbr_state), addr);
		if (strlen(addr) > 15)
			printf("\n%48s", " ");
		printf(" %8s\n", nbr->uptime == 0 ? "-" :
		    fmt_timeframe_core(nbr->uptime));
		break;
	case IMSG_CTL_END:
		printf("\n");
		return (1);
	default:
		break;
	}

	return (0);
}

void
show_fib_head(void)
{
	printf("Flags: C = Connected, S = Static\n");
	printf(" %-4s %-20s %-17s %-17s %s\n", "Prio", "Destination",
	    "Nexthop", "Local Label", "Remote Label");
}

int
show_fib_msg(struct imsg *imsg, struct parse_result *res)
{
	struct kroute	*k;
	char		*p;
	const char	*nexthop;

	switch (imsg->hdr.type) {
	case IMSG_CTL_KROUTE:
		if (imsg->hdr.len < IMSG_HEADER_SIZE + sizeof(struct kroute))
			errx(1, "wrong imsg len");
		k = imsg->data;

		if (res->family != AF_UNSPEC && res->family != k->af)
			break;

		if (k->flags & F_CONNECTED)
			printf("C");
		else if (k->flags & F_STATIC)
			printf("S");
		else
			printf(" ");

		printf(" %3d ", k->priority);
		if (asprintf(&p, "%s/%u", log_addr(k->af, &k->prefix),
		    k->prefixlen) == -1)
			err(1, NULL);
		printf("%-20s ", p);
		if (strlen(p) > 20)
			printf("\n%27s", " ");
		free(p);

		if (ldp_addrisset(k->af, &k->nexthop)) {
			switch (k->af) {
			case AF_INET:
				printf("%-18s", inet_ntoa(k->nexthop.v4));
				break;
			case AF_INET6:
				nexthop = log_in6addr_scope(&k->nexthop.v6,
				    k->ifindex);
				printf("%-18s", nexthop);
				if (strlen(nexthop) > 18)
					printf("\n%45s", " ");
				break;
			default:
				printf("%-18s", " ");
				break;
			}
		} else if (k->flags & F_CONNECTED)
			printf("link#%-13u", k->ifindex);

		printf("%-18s", log_label(k->local_label));
		printf("%s", log_label(k->remote_label));
		printf("\n");
		break;
	case IMSG_CTL_END:
		printf("\n");
		return (1);
	default:
		break;
	}

	return (0);
}

void
show_interface_head(void)
{
	printf("%-15s%-15s%s\n", "Interface", "Flags",
	    "Link state");
}

int
show_fib_interface_msg(struct imsg *imsg)
{
	struct kif	*k;
	uint64_t	 ifms_type;

	switch (imsg->hdr.type) {
	case IMSG_CTL_IFINFO:
		k = imsg->data;
		printf("%-15s", k->ifname);
		printf("%-15s", k->flags & IFF_UP ? "UP" : "");
		ifms_type = get_ifms_type(k->if_type);
		if (ifms_type)
			printf("%s, ", get_media_descr(ifms_type));

		printf("%s", get_linkstate(k->if_type, k->link_state));

		if (k->link_state != LINK_STATE_DOWN && k->baudrate > 0) {
			printf(", ");
			print_baudrate(k->baudrate);
		}
		printf("\n");
		break;
	case IMSG_CTL_END:
		printf("\n");
		return (1);
	default:
		break;
	}

	return (0);
}

int
show_l2vpn_pw_msg(struct imsg *imsg)
{
	struct ctl_pw	*pw;

	switch (imsg->hdr.type) {
	case IMSG_CTL_SHOW_L2VPN_PW:
		pw = imsg->data;

		printf("%-11s %-15s %-14u %-10s\n", pw->ifname,
		    inet_ntoa(pw->lsr_id), pw->pwid,
		    (pw->status ? "UP" : "DOWN"));
		break;
	case IMSG_CTL_END:
		printf("\n");
		return (1);
	default:
		break;
	}

	return (0);
}

int
show_l2vpn_binding_msg(struct imsg *imsg)
{
	struct ctl_pw	*pw;

	switch (imsg->hdr.type) {
	case IMSG_CTL_SHOW_L2VPN_BINDING:
		pw = imsg->data;

		printf("Neighbor: %s - PWID: %u (%s)\n",
		    inet_ntoa(pw->lsr_id), pw->pwid,
		    pw_type_name(pw->type));
		printf("%-12s%-15s%-15s%-10s\n", "", "Label", "Group-ID",
		    "MTU");
		if (pw->local_label != NO_LABEL)
			printf("  %-10s%-15u%-15u%u\n", "Local",
			    pw->local_label, pw->local_gid, pw->local_ifmtu);
		else
			printf("  %-10s%-15s%-15s%s\n", "Local", "-",
			    "-", "-");
		if (pw->remote_label != NO_LABEL)
			printf("  %-10s%-15u%-15u%u\n", "Remote",
			    pw->remote_label, pw->remote_gid,
			    pw->remote_ifmtu);
		else
			printf("  %-10s%-15s%-15s%s\n", "Remote", "-",
			    "-", "-");
		break;
	case IMSG_CTL_END:
		printf("\n");
		return (1);
	default:
		break;
	}

	return (0);
}

const struct if_status_description
		if_status_descriptions[] = LINK_STATE_DESCRIPTIONS;
const struct ifmedia_description
		ifm_type_descriptions[] = IFM_TYPE_DESCRIPTIONS;

const char *
get_media_descr(uint64_t media_type)
{
	const struct ifmedia_description	*p;

	for (p = ifm_type_descriptions; p->ifmt_string != NULL; p++)
		if (media_type == p->ifmt_word)
			return (p->ifmt_string);

	return ("unknown");
}

const char *
get_linkstate(uint8_t if_type, int link_state)
{
	const struct if_status_description *p;
	static char buf[8];

	for (p = if_status_descriptions; p->ifs_string != NULL; p++) {
		if (LINK_STATE_DESC_MATCH(p, if_type, link_state))
			return (p->ifs_string);
	}
	snprintf(buf, sizeof(buf), "[#%d]", link_state);
	return (buf);
}

void
print_baudrate(uint64_t baudrate)
{
	if (baudrate > IF_Gbps(1))
		printf("%llu GBit/s", baudrate / IF_Gbps(1));
	else if (baudrate > IF_Mbps(1))
		printf("%llu MBit/s", baudrate / IF_Mbps(1));
	else if (baudrate > IF_Kbps(1))
		printf("%llu KBit/s", baudrate / IF_Kbps(1));
	else
		printf("%llu Bit/s", baudrate);
}
@


1.31
log
@Introduce the 'ldpctl clear neighbors' command.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpctl.c,v 1.30 2016/05/23 19:04:55 renato Exp $
a59 2
char		*print_label(char **, uint32_t);
const char	*print_pw_type(uint16_t);
d403 1
a403 1
	char		*dstnet, *local = NULL, *remote = NULL;
d420 1
a420 2
		    print_label(&local, rt->local_label),
		    print_label(&remote, rt->remote_label),
a422 2
		free(remote);
		free(local);
a480 1
	char		*local = NULL, *remote = NULL;
d527 2
a528 2
		printf("%-18s", print_label(&local, k->local_label));
		printf("%s", print_label(&local, k->remote_label));
a529 3

		free(remote);
		free(local);
d615 1
a615 1
		    print_pw_type(pw->type));
a683 37
}

char *
print_label(char **string, uint32_t label)
{
	if (label == NO_LABEL) {
		if (asprintf(string, "-") == -1)
			err(1, NULL);
	} else if (label == MPLS_LABEL_IMPLNULL) {
		if (asprintf(string, "imp-null") == -1)
			err(1, NULL);
	} else if (label == MPLS_LABEL_IPV4NULL ||
	    label == MPLS_LABEL_IPV6NULL) {
		if (asprintf(string, "exp-null") == -1)
			err(1, NULL);
	} else {
		if (asprintf(string, "%u", label) == -1)
			err(1, NULL);
	}

	return (*string);
}

const char *
print_pw_type(uint16_t pw_type)
{
	static char buf[64];

	switch (pw_type) {
	case PW_TYPE_ETHERNET_TAGGED:
		return ("Eth Tagged");
	case PW_TYPE_ETHERNET:
		return ("Ethernet");
	default:
		snprintf(buf, sizeof(buf), "[%0x]", pw_type);
		return (buf);
	}
@


1.30
log
@Sync with the latest IPv6 bits in ldpd(8).
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpctl.c,v 1.29 2016/05/23 19:03:52 renato Exp $
d85 1
d174 8
d253 1
@


1.29
log
@Add function that print labels to avoid code duplication.

In addition to that, print "exp-null" instead of "0" or "2".
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpctl.c,v 1.28 2016/05/23 19:02:49 renato Exp $
d41 1
d47 2
a48 2
int		 show_interface_msg(struct imsg *);
int		 show_discovery_msg(struct imsg *);
d50 2
a51 2
int		 show_lib_msg(struct imsg *);
int		 show_nbr_msg(struct imsg *);
d53 1
a53 1
int		 show_fib_msg(struct imsg *);
d81 1
d115 2
a116 2
		printf("%-11s %-10s %-10s %-8s %-12s %3s\n",
		    "Interface", "State", "Linkstate", "Uptime",
d127 2
a128 2
		printf("%-15s %-9s %-15s %-9s\n",
		    "ID", "Type", "Source", "Holdtime");
d133 2
a134 2
		printf("%-15s %-18s %-15s %-10s\n", "ID",
		    "State", "Address", "Uptime");
d138 3
a140 2
		printf("%-20s %-17s %-14s %-14s %-10s\n", "Destination",
		    "Nexthop", "Local Label", "Remote Label", "In Use");
d144 1
a144 1
		if (!res->addr.s_addr)
d147 4
a150 1
		else
d152 2
a153 1
			    &res->addr, sizeof(res->addr));
d220 1
a220 1
				done = show_interface_msg(&imsg);
d223 1
a223 1
				done = show_discovery_msg(&imsg);
d226 1
a226 1
				done = show_nbr_msg(&imsg);
d229 1
a229 1
				done = show_lib_msg(&imsg);
d232 1
a232 1
				done = show_fib_msg(&imsg);
a318 10
/* prototype defined in ldpd.h and shared with the kroute.c version */
uint8_t
mask2prefixlen(in_addr_t ina)
{
	if (ina == 0)
		return (0);
	else
		return (33 - ffs(ntohl(ina)));
}

d320 1
a320 1
show_interface_msg(struct imsg *imsg)
d329 3
d336 5
a340 6
		printf("%-11s %-10s %-10s %-8s %12s %3u\n",
		    iface->name, if_state_name(iface->state),
		    get_linkstate(iface->if_type, iface->linkstate),
		    iface->uptime == 0 ? "00:00:00" :
		    fmt_timeframe_core(iface->uptime), timers,
		    iface->adj_cnt);
d354 1
a354 1
show_discovery_msg(struct imsg *imsg)
d356 2
a357 1
	struct ctl_adj		*adj;
d363 4
a366 1
		printf("%-15s ", inet_ntoa(adj->id));
d369 1
a369 1
			printf("%-9s %-15s ", "Link", adj->ifname);
d372 5
a376 2
			printf("%-9s %-15s ", "Targeted",
			    inet_ntoa(adj->src_addr));
d379 1
a379 1
		printf("%-9u\n", adj->holdtime);
d392 1
a392 1
show_lib_msg(struct imsg *imsg)
d400 5
a404 1
		if (asprintf(&dstnet, "%s/%d", inet_ntoa(rt->prefix),
d408 4
a411 2
		printf("%-20s %-17s %-14s %-14s %s\n", dstnet,
		    inet_ntoa(rt->nexthop),
d415 1
d431 1
a431 1
show_nbr_msg(struct imsg *imsg)
d434 1
d439 13
a451 4
		printf("%-15s %-19s", inet_ntoa(nbr->id),
		    nbr_state_name(nbr->nbr_state));
		printf("%-15s %-15s\n", inet_ntoa(nbr->addr),
		    nbr->uptime == 0 ? "-" : fmt_timeframe_core(nbr->uptime));
d472 1
a472 1
show_fib_msg(struct imsg *imsg)
d477 1
d485 3
d496 1
a496 1
		if (asprintf(&p, "%s/%u", inet_ntoa(k->prefix),
d500 2
d504 17
a520 3
		if (k->nexthop.s_addr)
			printf("%-18s", inet_ntoa(k->nexthop));
		else if (k->flags & F_CONNECTED)
@


1.28
log
@Replace legacy bzero and bcopy by memset and memcpy.

bzero(), bcopy() and bcmp() were deprecated in POSIX.1-2001 and removed
in POSIX.1-2008 in deference to memset(), memcpy() and memcmp().
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpctl.c,v 1.27 2016/05/23 19:01:08 renato Exp $
d59 1
d389 1
a389 1
	char		*dstnet, *remote;
a396 13
		if (!rt->in_use) {
			if (asprintf(&remote, "-") == -1)
				err(1, NULL);
		} else if (rt->remote_label == NO_LABEL) {
			if (asprintf(&remote, "Untagged") == -1)
				err(1, NULL);
		} else if (rt->remote_label == MPLS_LABEL_IMPLNULL) {
			if (asprintf(&remote, "Pop tag") == -1)
				err(1, NULL);
		} else {
			if (asprintf(&remote, "%u", rt->remote_label) == -1)
				err(1, NULL);
		}
d398 4
a401 2
		printf("%-20s %-17s %-14u %-14s %s\n", dstnet,
		    inet_ntoa(rt->nexthop), rt->local_label, remote,
d404 1
a405 1

d451 3
a453 2
	struct kroute		*k;
	char			*p;
d480 2
a481 15
		if (k->local_label == NO_LABEL) {
			printf("%-18s", "-");
		} else if (k->local_label == MPLS_LABEL_IMPLNULL) {
			printf("%-18s", "imp-null");
		} else
			printf("%-18u", k->local_label);

		if (k->remote_label == NO_LABEL) {
			printf("-");
		} else if (k->remote_label == MPLS_LABEL_IMPLNULL) {
			printf("Pop");
		} else {
			printf("%u", k->remote_label);
		}

d484 2
d640 21
@


1.27
log
@Change ldpctl(8) to use C99-style fixed-width integers.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpctl.c,v 1.26 2016/05/23 17:53:11 renato Exp $
d91 1
a91 1
	bzero(&sun, sizeof(sun));
@


1.26
log
@Sync with ldpd.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpctl.c,v 1.25 2015/12/05 13:11:48 claudio Exp $
d58 2
a59 2
void		 print_baudrate(u_int64_t);
const char	*print_pw_type(u_int16_t);
d312 1
a312 1
u_int8_t
d650 1
a650 1
print_baudrate(u_int64_t baudrate)
d663 1
a663 1
print_pw_type(u_int16_t pw_type)
@


1.25
log
@EAGAIN handling for imsg_read. OK henning@@ benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpctl.c,v 1.24 2015/10/23 10:11:20 renato Exp $
d567 1
a567 1
		    inet_ntoa(pw->nexthop), pw->pwid,
d590 1
a590 1
		    inet_ntoa(pw->nexthop), pw->pwid,
@


1.24
log
@Make use of pledge(2).

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpctl.c,v 1.23 2015/09/27 17:30:38 stsp Exp $
d199 1
a199 1
		if ((n = imsg_read(ibuf)) == -1)
@


1.23
log
@As done for bgpd recently, rename if_mediatype to if_type in ldpd.
And some ifmedia64 fixes.
"move forward" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpctl.c,v 1.22 2015/09/13 11:13:12 deraadt Exp $
d96 3
@


1.22
log
@match a few if_media uint64_t conversions; ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpctl.c,v 1.21 2015/07/21 09:34:57 claudio Exp $
d45 1
a45 1
const char	*get_linkstate(uint64_t, int);
d48 1
a48 1
int		 get_ifms_type(int);
d250 2
a251 2
int
get_ifms_type(int mediatype)
d253 1
a253 1
	switch (mediatype) {
d334 1
a334 1
		    get_linkstate(iface->mediatype, iface->linkstate),
d525 1
a525 1
	int		 ifms_type;
d532 1
a532 1
		ifms_type = get_ifms_type(k->media_type);
d536 1
a536 1
		printf("%s", get_linkstate(k->media_type, k->link_state));
d633 1
a633 1
get_linkstate(uint64_t media_type, int link_state)
d639 1
a639 1
		if (LINK_STATE_DESC_MATCH(p, media_type, link_state))
@


1.21
log
@Remove the check for the connected flag since it is no longer around.
Minimal fix to unbreak the tree.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpctl.c,v 1.20 2015/07/21 05:44:50 renato Exp $
d45 1
a45 1
const char	*get_linkstate(int, int);
d57 1
a57 1
const char	*get_media_descr(int);
d621 1
a621 1
get_media_descr(int media_type)
d633 1
a633 1
get_linkstate(int media_type, int link_state)
@


1.20
log
@Introduce two show commands for l2vpns.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpctl.c,v 1.19 2015/07/21 05:42:50 renato Exp $
d396 1
a396 1
		} else if (rt->connected || rt->remote_label == NO_LABEL) {
@


1.19
log
@Improve the show lib command.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpctl.c,v 1.18 2015/04/04 16:29:48 renato Exp $
d55 2
d59 1
d153 9
d226 6
d554 61
d657 16
@


1.18
log
@Show the remote labels in "ldpctl show lib" even if they are not installed in the FIB.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpctl.c,v 1.17 2015/01/15 23:51:04 deraadt Exp $
d375 5
a379 3

		if (rt->remote_label == NO_LABEL) {
			if (asprintf(&remote, "No Label") == -1)
@


1.17
log
@do not assume <netmls/mpls.h> will pull in <limits.h> via <sys/param.h>
get <limits.h> directly.
ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpctl.c,v 1.16 2013/11/14 20:48:52 deraadt Exp $
d375 3
a377 5
		if (!rt->in_use) {
			if (asprintf(&remote, "-") == -1)
				err(1, NULL);
		} else if (rt->connected || rt->remote_label == NO_LABEL) {
			if (asprintf(&remote, "Untagged") == -1)
@


1.16
log
@cope with the EAGAIN API change for msgbuf_write()
ok benno
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpctl.c,v 1.15 2013/06/04 02:40:17 claudio Exp $
d36 1
@


1.15
log
@Introduce the 'ldpctl show discovery' command
Diff by Renato Westphal
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpctl.c,v 1.14 2013/06/04 02:28:58 claudio Exp $
d31 1
d179 1
a179 1
		if (msgbuf_write(&ibuf->w) < 0)
@


1.14
log
@Adjust to the latest changes on the ctl_iface struct
From Renato Westphal
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpctl.c,v 1.13 2013/06/01 19:29:23 claudio Exp $
d45 1
d115 6
d197 3
d319 31
@


1.13
log
@Adjust ldpctl to the latest ldpd changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpctl.c,v 1.12 2010/09/01 13:59:17 claudio Exp $
d103 3
a105 3
		printf("%-11s %-18s %-10s %-10s %-8s\n",
		    "Interface", "Address", "State", "Linkstate",
		    "Uptime");
d292 1
a292 1
	char			*netid;
d298 2
a299 2
		if (asprintf(&netid, "%s/%d", inet_ntoa(iface->addr),
		    mask2prefixlen(iface->mask.s_addr)) == -1)
d301 3
a303 2
		printf("%-11s %-18s %-10s %-10s %-8s\n",
		    iface->name, netid, if_state_name(iface->state),
d306 3
a308 2
		    fmt_timeframe_core(iface->uptime));
		free(netid);
@


1.12
log
@s/lfib/fib/ for more consistency with the other routing ctl tools.
While I also made the code more consistent the most noticable change
is the rename of the commandline arguments for fib coupling and viewing.
OK michele@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpctl.c,v 1.11 2010/07/08 09:42:32 claudio Exp $
d115 2
a116 2
		printf("%-15s %-18s %-15s %-9s %-10s\n", "ID",
		    "State", "Address", "Iface", "Uptime");
a364 1
	char		*state;
a368 3
		if (asprintf(&state, "%s/%s", nbr_state_name(nbr->nbr_state),
		    if_state_name(nbr->iface_state)) == -1)
			err(1, NULL);
d370 3
a372 5
		    state);
		printf("%-15s %-10s", inet_ntoa(nbr->addr), nbr->name);
		printf("%-15s\n", nbr->uptime == 0 ? "-" :
		    fmt_timeframe_core(nbr->uptime));
		free(state);
@


1.11
log
@Update after kroute.c change. As a goody print the route priority.
OK michele@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpctl.c,v 1.10 2010/06/07 13:24:23 claudio Exp $
d48 2
a49 2
void		 show_lfib_head(void);
int		 show_lfib_msg(struct imsg *);
d51 1
a51 1
int		 show_lfib_interface_msg(struct imsg *);
d124 1
a124 1
	case SHOW_LFIB:
d131 1
a131 1
		show_lfib_head();
d133 1
a133 1
	case SHOW_LFIB_IFACE:
d141 2
a142 2
	case LFIB:
		errx(1, "lfib couple|decouple");
d144 2
a145 2
	case LFIB_COUPLE:
		imsg_compose(ibuf, IMSG_CTL_LFIB_COUPLE, 0, 0, -1, NULL, 0);
d149 2
a150 2
	case LFIB_DECOUPLE:
		imsg_compose(ibuf, IMSG_CTL_LFIB_DECOUPLE, 0, 0, -1, NULL, 0);
d196 2
a197 2
			case SHOW_LFIB:
				done = show_lfib_msg(&imsg);
d199 2
a200 2
			case SHOW_LFIB_IFACE:
				done = show_lfib_interface_msg(&imsg);
d203 3
a205 3
			case LFIB:
			case LFIB_COUPLE:
			case LFIB_DECOUPLE:
d391 1
a391 1
show_lfib_head(void)
d399 1
a399 1
show_lfib_msg(struct imsg *imsg)
d465 1
a465 1
show_lfib_interface_msg(struct imsg *imsg)
@


1.10
log
@Store all labels in ldpd in host byte order without any additional shifting.
Add the necessary ntohl() and shifts in various places and cleanup the byte
order mess we had before. michele@@ agrees.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpctl.c,v 1.9 2010/04/13 15:42:09 michele Exp $
d393 3
a395 3
	printf("flags: * = valid, C = Connected, S = Static\n");
	printf("%-6s %-20s %-17s %-17s %s\n", "Flags", "Destination", "Nexthop",
	    "Local Label", "Remote Label");
d410 1
a410 8
		if (k->flags & F_DOWN)
			printf(" ");
		else
			printf("*");

		if (!(k->flags & F_KERNEL))
			printf("R");
		else if (k->flags & F_CONNECTED)
d417 1
a417 1
		printf("     ");
@


1.9
log
@Use a more appropriate wording in ldpctl show lib and lfib outputs.

In particular print "Untagged" when there is no label, and "imp-null" instead
of label 3.

Initial diff from Thomas Habets, commited a slightly modified one.
ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpctl.c,v 1.8 2010/03/03 10:18:35 claudio Exp $
a322 1
	int             remote_label;
a329 1
		remote_label = ntohl(rt->remote_label) >> MPLS_LABEL_OFFSET;
d333 1
a333 2
		} else if (rt->connected ||
		    (remote_label == (NO_LABEL >> MPLS_LABEL_OFFSET))) {
d336 1
a336 1
		} else if (remote_label == MPLS_LABEL_IMPLNULL) {
d340 1
a340 1
			if (asprintf(&remote, "%u", remote_label) == -1)
d345 2
a346 3
		    inet_ntoa(rt->nexthop),
		    (ntohl(rt->local_label) >> MPLS_LABEL_OFFSET),
		    remote, rt->in_use ? "yes" : "no");
d438 1
a438 2
		} else if (ntohl(k->local_label) >> MPLS_LABEL_OFFSET ==
		    MPLS_LABEL_IMPLNULL) {
d441 1
a441 2
			printf("%-18u", (ntohl(k->local_label) >>
			    MPLS_LABEL_OFFSET));
d445 1
a445 2
		} else if (htonl(k->remote_label) >> MPLS_LABEL_OFFSET ==
		    MPLS_LABEL_IMPLNULL) {
d448 1
a448 2
			printf("%u", (ntohl(k->remote_label) >>
			    MPLS_LABEL_OFFSET));
@


1.8
log
@Must check for NO_LABEL here as well or we print strange label numbers.
OK michele@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpctl.c,v 1.7 2010/01/02 14:56:02 michele Exp $
d323 1
d331 2
a332 2

		if (rt->connected || !rt->in_use) {
d335 7
d343 1
a343 1
			if (asprintf(&remote, "%u", (ntohl(rt->remote_label) >> MPLS_LABEL_OFFSET)) == -1)
d440 6
a445 1
		if (k->local_label != NO_LABEL) {
a447 2
		} else
			printf("-                 ");
d449 6
a454 1
		if (k->remote_label != NO_LABEL) {
d457 1
a457 2
		} else
			printf("-");
@


1.7
log
@In the "ldpctl show lib" output print every known label and make clear if it
is currently in use or not.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpctl.c,v 1.6 2009/11/02 20:35:20 claudio Exp $
d432 1
a432 1
		if (k->local_label) {
d438 1
a438 1
		if (k->remote_label) {
@


1.6
log
@Implement "log verbose" and "log brief" to enable or disable verbose debug
logging. henning, sthen, michele like the idea
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpctl.c,v 1.5 2009/09/14 11:49:25 claudio Exp $
d120 2
a121 2
		printf("%-20s %-17s %-17s %s\n", "Destination",
		    "Nexthop", "Local Label", "Remote Label");
d331 1
a331 1
		if (rt->connected) {
d339 1
a339 1
		printf("%-20s %-17s %-17u %s\n", dstnet,
d342 1
a342 1
		    remote);
@


1.5
log
@Switch the various link state printing codes to use the new if_media
independent LINK_STATE_DESCRIPTIONS. Code is now more or less a one to
one copy of get_linkstate() in route/route.c.
OK henning, michele, sthen, deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpctl.c,v 1.4 2009/08/02 16:19:17 michele Exp $
d74 1
a74 1
	int			 done = 0;
d154 9
d206 2
@


1.4
log
@"ldpctl show lib" output cleanup.

- Show only the remote/local labels of the prefixes currently present
in fib.

- Write a "-" instead of "0" when a remote label is not present (the
prefix is directly connected). It avoids confusion with explicit null label.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpctl.c,v 1.3 2009/08/01 12:47:02 michele Exp $
d292 2
a293 2
		    get_linkstate(get_ifms_type(iface->mediatype),
		    iface->linkstate), iface->uptime == 0 ? "00:00:00" :
d464 3
a466 14
		switch (k->media_type) {
		case IFT_ETHER:
			ifms_type = IFM_ETHER;
			break;
		case IFT_FDDI:
			ifms_type = IFM_FDDI;
			break;
		case IFT_CARP:
			ifms_type = IFM_CARP;
			break;
		default:
			ifms_type = 0;
			break;
		}
d468 1
a468 7
		if (ifms_type)
			printf("%s, %s", get_media_descr(ifms_type),
			    get_linkstate(ifms_type, k->link_state));
		else if (k->link_state == LINK_STATE_UNKNOWN)
			printf("unknown");
		else
			printf("link state %u", k->link_state);
d486 2
a487 3
const int	ifm_status_valid_list[] = IFM_STATUS_VALID_LIST;
const struct ifmedia_status_description
		ifm_status_descriptions[] = IFM_STATUS_DESCRIPTIONS;
d506 2
a507 2
	const struct ifmedia_status_description	*p;
	int					 i;
d509 6
a514 14
	if (link_state == LINK_STATE_UNKNOWN)
		return ("unknown");

	for (i = 0; ifm_status_valid_list[i] != 0; i++)
		for (p = ifm_status_descriptions; p->ifms_valid != 0; p++) {
			if (p->ifms_type != media_type ||
			    p->ifms_valid != ifm_status_valid_list[i])
				continue;
			if (LINK_STATE_IS_UP(link_state))
				return (p->ifms_string[1]);
			return (p->ifms_string[0]);
		}

	return ("unknown link state");
@


1.3
log
@Correctly print interface state and neighbor uptime in ldpctl show neighbor.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpctl.c,v 1.2 2009/06/13 16:47:32 michele Exp $
d311 1
a311 1
	char		*dstnet;
d320 9
a328 1
		printf("%-20s %-17s %-17u %u\n", dstnet,
d331 2
a332 1
		    (ntohl(rt->remote_label) >> MPLS_LABEL_OFFSET));
@


1.2
log
@Make ldpctl imsg-in-a-lib ready too.

ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldpctl.c,v 1.1 2009/06/01 20:59:45 michele Exp $
d115 1
a115 1
		printf("%-15s %-15s %-15s %-9s %-10s\n", "ID",
d349 1
a349 1
		printf("%-15s %-16s", inet_ntoa(nbr->id),
@


1.1
log
@Welcome ldpd, the Label Distribution Protocol daemon.
Built using the imsg/three process framework, its main aim
is to redistribute MPLS labels between peers.

Right now it has some really basic functionalities,
the basic protocol works and peers are able to exchange
labels and insert them in the kernel.
It still does not react to changes of topology.

Not yet connected to the builds.

ok claudio@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD$
a65 6
/* dummy function to allow ldpctl to run without libevent */
void
imsg_event_add(struct imsgbuf *i)
{
}

d93 1
a93 1
	imsg_init(ibuf, ctl_sock, NULL);
d111 1
a111 1
		imsg_compose(ibuf, IMSG_CTL_SHOW_INTERFACE, 0, 0,
d117 1
a117 1
		imsg_compose(ibuf, IMSG_CTL_SHOW_NBR, 0, 0, NULL, 0);
d122 1
a122 1
		imsg_compose(ibuf, IMSG_CTL_SHOW_LIB, 0, 0, NULL, 0);
d126 1
a126 1
			imsg_compose(ibuf, IMSG_CTL_KROUTE, 0, 0,
d129 1
a129 1
			imsg_compose(ibuf, IMSG_CTL_KROUTE_ADDR, 0, 0,
d135 1
a135 1
			imsg_compose(ibuf, IMSG_CTL_IFINFO, 0, 0,
d138 1
a138 1
			imsg_compose(ibuf, IMSG_CTL_IFINFO, 0, 0, NULL, 0);
d145 1
a145 1
		imsg_compose(ibuf, IMSG_CTL_LFIB_COUPLE, 0, 0, NULL, 0);
d150 1
a150 1
		imsg_compose(ibuf, IMSG_CTL_LFIB_DECOUPLE, 0, 0, NULL, 0);
d155 1
a155 1
		imsg_compose(ibuf, IMSG_CTL_RELOAD, 0, 0, NULL, 0);
@

