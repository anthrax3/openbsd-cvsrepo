head	1.5;
access;
symbols
	OPENBSD_3_2:1.4.0.4
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.4.0.2
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.3.0.8
	OPENBSD_3_0_BASE:1.3
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_9:1.3.0.6
	OPENBSD_2_8:1.3.0.4
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.2
	OPENBSD_2_7_BASE:1.3
	OPENBSD_2_6:1.2.0.14
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.12
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.10
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.8
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.6
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.5
date	2002.12.31.16.35.42;	author miod;	state dead;
branches;
next	1.4;

1.4
date	2002.02.16.21.28.03;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2000.01.19.16.33.00;	author espie;	state Exp;
branches;
next	1.2;

1.2
date	96.06.10.04.51.33;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.47.37;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.47.37;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.5
log
@amiga and sun3 turned out to not be y2k+3 compliant here. Remove them, as
well as the few userland tools which were only used on these platforms.
@
text
@/* $OpenBSD: iteconfig.c,v 1.4 2002/02/16 21:28:03 millert Exp $ */
/*	$NetBSD: iteconfig.c,v 1.4.6.1 1996/06/04 16:48:24 is Exp $	*/
/* Copyright (c) 1999 Marc Espie
 * All rights reserved.
 *
 * This code is derived from software developped by Christian E. Hopps.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Marc Espie.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Copyright (c) 1994 Christian E. Hopps
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Christian E. Hopps
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

#include <sys/types.h>
#include <sys/stat.h>
#include <sys/ioctl.h>
#include <sys/queue.h>

#if !defined(amiga) && !defined(atari)
#error "This source is not suitable for this architecture!"
#endif

#if defined(amiga)
#include <amiga/dev/grfabs_reg.h>
#include <amiga/dev/viewioctl.h>
#include <amiga/dev/iteioctl.h>
#endif /* defined(amiga)	*/

#if defined(atari)
#include <atari/dev/grfabs_reg.h>
#include <atari/dev/viewioctl.h>
#include <atari/dev/iteioctl.h>
#endif /* defined(atari)	*/

#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <limits.h>
#include <stdio.h>
#include <stdlib.h>
#include <termios.h>
#include <unistd.h>
#include <ctype.h>

#include "pathnames.h"

void	printcmap(colormap_t *, int);
void	usage(void);
void	xioctl(int, int, void *);
colormap_t *xgetcmap(int, int);
long	xstrtol(char *);
int main(int, char **);

int
main(argc, argv)
	int argc;
	char **argv;
{
	struct itewinsize is, newis;
	struct itebell ib, newib;
	int bt;
	struct winsize ws;
	char *file = _PATH_CONSOLE;
	int ch, fd, iflag, max_colors;
	int use_is, use_ib;

	max_colors = use_is = use_ib = iflag = 0;

		/* need two passes through options */
	while ((ch = getopt(argc, argv, "B:D:H:P:T:V:W:X:Y:b:d:f:h:ip:t:v:w:x:y:"))
	    != -1) {
		switch (tolower(ch)) {
		case 'd':
		case 'h':
		case 'w':
		case 'x':
		case 'y':
			use_is = 1;
			break;
		case 'f':
			file = optarg;
			break;
		case 'p':
		case 't':
		case 'v':
			use_ib = 1;
			break;
		case 'b':
		case 'i':
			break;
		default:
			usage();
		}
	}

	fd = open(file, O_RDONLY, O_NONBLOCK);
	if(fd == -1)
		err(1, "open \"%s\"", file);

	if (argc > optind) 
		use_is = 1;

	if (use_is) {
		xioctl(fd, ITEIOCGWINSZ, &is);
		memcpy(&newis, &is, sizeof is);
		max_colors = 1 << is.depth;
	}
	if (use_ib) {
		xioctl(fd, ITEIOCGBELL, &ib);
		memcpy(&newib, &ib, sizeof ib);
	}

	optind = 1;
	optreset = 1;
	
		
	while ((ch = getopt(argc, argv, "B:D:H:P:T:V:W:X:Y:b:d:f:h:ip:t:v:w:x:y:"))
	    != -1) {
		switch (tolower(ch)) {
		case 'i':
			iflag = 1;
			break;
		case 'f':
			break;
		case 'd':
			newis.depth = xstrtol(optarg);
			break;
		case 'h':
			newis.height = xstrtol(optarg);
			break;
		case 'w':
			newis.width = xstrtol(optarg);
			break;
		case 'x':
			newis.x = xstrtol(optarg);
			break;
		case 'y':
			newis.y = xstrtol(optarg);
			break;
		case 'p':
			newib.pitch = xstrtol(optarg);
			break;
		case 't':
			newib.msec = xstrtol(optarg);
			break;
		case 'v':
			newib.volume = xstrtol(optarg);
			break;
		case 'b':
#ifdef  ITEIOCSBLKTIME
			bt = xstrtol(optarg);
			xioctl(fd, ITEIOCSBLKTIME, &bt);
			break;
#else
			/*FALLTHRU*/
#endif
		case '?':
		default:
			usage();
			/* NOTREACHED */
		}
	}

	if (use_is && memcmp(&is, &newis, sizeof is) != 0) {
		xioctl(fd, ITEIOCSWINSZ, &newis);
		xioctl(fd, ITEIOCGWINSZ, &is);
		max_colors = 1 << is.depth;
	}
	if (use_ib && memcmp(&ib, &newib, sizeof ib) != 0) {
		xioctl(fd, ITEIOCSBELL, &newib);
		xioctl(fd, ITEIOCGBELL, &ib);
	}
	
	argc -= optind;
	argv += optind;


	if (argc) {
		int i;
		long val;
		colormap_t *cm;
		/*
		 * get, set and get colors again
		 */
		cm = xgetcmap(fd, max_colors);
		for (i = 0; i < argc; i++) {
			val = xstrtol(argv[i]);
			if (i >= max_colors) {
				warnx("warning: too many colors");
				break;
			}
			cm->entry[i] = val;
		}
		xioctl(fd, VIOCSCMAP, cm);
		free(cm);
	}

	/* do tty stuff to get it to register the changes. */
	xioctl(fd, TIOCGWINSZ, &ws);

	if (iflag) {
		printf("tty size: rows %d cols %d\n", ws.ws_row, ws.ws_col);
		if (use_is || ioctl(fd, ITEIOCGWINSZ, &is) != -1) {
			printf("ite size: w: %d  h: %d  d: %d  [x: %d  y: %d]\n",
			    is.width, is.height, is.depth, is.x, is.y);
			max_colors = 1 << is.depth;
		}
		if (use_ib || ioctl(fd, ITEIOCGBELL, &ib) != -1)
			printf("ite bell: vol: %d  millisec: %d  pitch: %d\n",
			    ib.volume, ib.msec, ib.pitch);
#ifdef ITEIOCGBLKTIME
		if (ioctl(fd, ITEIOCGBLKTIME, &bt) != -1) {
			printf("ite screenblanker: ");
			if (bt != 0)
				printf("%d seconds\n", bt);
			else
				printf("off\n");
		}
#endif
		if (max_colors) {
			colormap_t *cm;
			cm = xgetcmap(fd, max_colors);
			printcmap(cm, ws.ws_col);
			free(cm);
		}
	}
	close(fd);
	exit(0);
}

void
xioctl(fd, cmd, addr)
	int fd, cmd;
	void *addr;
{
	if (ioctl(fd, cmd, addr) == -1) 
		err(1, "ioctl");
}

long
xstrtol(s)
	char *s;
{
	long rv;

	rv = strtol(s, NULL, 0);
	if (errno == ERANGE && (rv == LONG_MIN || rv == LONG_MAX))
		err(1, "bad format: \"%s\"", s);
	return(rv);
}

colormap_t *
xgetcmap(fd, ncolors)
	int fd;
	int ncolors;
{
	colormap_t *cm;

	cm = malloc(sizeof(colormap_t) + ncolors * sizeof(u_long));
	if (cm == NULL)
		err(1, "malloc");
	cm->first = 0;
	cm->size = ncolors;
	cm->entry = (u_long *) & cm[1];
	xioctl(fd, VIOCGCMAP, cm);
	return(cm);
}

void
printcmap(cm, ncols)
	colormap_t *cm;
	int ncols;
{
	int i, nel;

	switch (cm->type) {
	case CM_MONO:
		printf("monochrome");
		return;
	case CM_COLOR:
		printf("color levels: red: %d  green: %d  blue: %d",
		    cm->red_mask + 1, cm->green_mask + 1, cm->blue_mask + 1);
		break;
	case CM_GREYSCALE:
		printf("greyscale levels: %d", cm->grey_mask + 1);
		break;
	}
	printf("\n");
	
	nel = ncols / 11 - 1;
	for (i = 0; i < cm->size; i++) {
		printf("0x%08lx ", cm->entry[i]);
		if ((i + 1) % nel == 0)
			printf("\n");
	}
	if ((i + 1) % nel)
		printf("\n");
}

void
usage()
{
	fprintf(stderr, "%s\n\t\t%s%s\n\t\t%s\n",
	    "usage: iteconfig [-i] [-f file] [-v volume] [-p pitch] [-t msec]",
#ifdef ITEIOCSBLKTIME
	    "[-b timeout]",
#else
	    "",
#endif
	    "[-w width] [-h height] [-d depth] [-x off] [-y off]",
	    "[color ...]");
	exit(1);
}
@


1.4
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/* $OpenBSD: iteconfig.c,v 1.3 2000/01/19 16:33:00 espie Exp $ */
@


1.3
log
@Bug-fix: iteconfig was performing lots of iotcl on the console, but it
turns out all amiga sub-console handlers don't implement all those ioctl,
but still could use iteconfig.

So:
* rework iteconfig's logic to only perform strictly required ioctl,
* turn on -Wall and fix a few details,
* add -b option to handle console blanker.

Approved by niklas@@
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d96 6
a101 6
void	printcmap __P((colormap_t *, int));
void	usage __P((void));
void	xioctl __P((int, int, void *));
colormap_t *xgetcmap __P((int, int));
long	xstrtol __P((char *));
int main __P((int, char **));
@


1.2
log
@fix "iteconfig -h" message, from Hubert Feyrer, netbsd pr#2444
@
text
@d1 1
d3 30
a32 1
/*
d92 1
d101 1
a101 2
int	initialize __P((char *, struct itewinsize *, struct itebell *,
			struct itewinsize *, struct itebell *));
d110 1
a111 1
	colormap_t *cm;
d113 2
a114 5
	int ch, fd, i, iflag, max_colors, did_reset;
	long val;

	iflag = 0;
	did_reset = 0;
d116 1
a116 1
	fd = initialize(_PATH_CONSOLE, &is, &ib, &newis, &newib);
d118 4
a121 4
	while ((ch = getopt(argc, argv, "D:H:P:T:V:W:X:Y:d:f:h:ip:t:v:w:x:y:"))
	    != EOF) {
		switch (ch) {
		case 'D':		/* undocumented backward compat */
d123 5
a127 1
			newis.depth = xstrtol(optarg);
a129 4
			if (did_reset)
				break;
			if (fd != -1)
				close(fd);
a130 2
			fd = initialize(optarg, &is, &ib, &newis, &newib);
			did_reset = optreset = optind = 1;
d132 7
a138 3
		case 'H':		/* undocumented backward compat */
		case 'h':
			newis.height = xstrtol(optarg);
d140 29
d172 1
a172 2
		case 'p':
			newib.pitch = xstrtol(optarg);
d174 2
a175 2
		case 't':
			newib.msec = xstrtol(optarg);
d177 2
a178 3
		case 'V':		/* undocumented backward compat */
		case 'v':
			newib.volume = xstrtol(optarg);
a179 1
		case 'W':		/* undocumented backward compat */
a182 1
		case 'X':		/* undocumented backward compat */
a185 1
		case 'Y':		/* undocumented backward compat */
d189 17
a211 4
	argc -= optind;
	argv += optind;
	if(fd == -1)
		err(1, "open \"%s\"", file);
d213 1
a213 1
	if (memcmp(&newis, &is, sizeof(is))) {
d216 1
d218 1
a218 1
	if (memcmp(&newib, &ib, sizeof(ib))) {
d223 19
a241 11
	/*
	 * get, set and get colors again
	 */
	i = 0;
	max_colors = 1 << is.depth;
	cm = xgetcmap(fd, max_colors);
	while (argc--) {
		val = xstrtol(*argv++);
		if (i >= max_colors) {
			warnx("warning: too many colors");
			break;
d243 2
a244 2
		cm->entry[i] = val;
		i++;
a245 3
	xioctl(fd, VIOCSCMAP, cm);
	free(cm);
	cm = xgetcmap(fd, max_colors);
d252 23
a274 5
		printf("ite size: w: %d  h: %d  d: %d  [x: %d  y: %d]\n",
		    is.width, is.height, is.depth, is.x, is.y);
		printf("ite bell: vol: %d  millisec: %d  pitch: %d\n",
		    ib.volume, ib.msec, ib.pitch);
		printcmap(cm, ws.ws_col);
a348 20
int
initialize(file, is, ib, newis, newib)
	char	*file;
	struct itewinsize *is, *newis;
	struct itebell *ib, *newib;
{
	int fd;

	fd = open(file, O_RDONLY | O_NONBLOCK);
	if (fd == -1)
		return(-1);

	xioctl(fd, ITEIOCGWINSZ, is);
	xioctl(fd, ITEIOCGBELL, ib);

	memcpy(newis, is, sizeof(*is));
	memcpy(newib, ib, sizeof(*ib));
	return(fd);
}

d352 1
a352 1
	fprintf(stderr, "%s\n\t\t%s\n\t\t%s\n",
d354 5
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: iteconfig.c,v 1.4 1995/05/12 21:04:29 leo Exp $	*/
d282 4
a285 3
	fprintf(stderr, "%s\n\t\t%s\n",
	    "usage: iteconfig [-i] [-v volume] [-p period] [-t count]",
	    "[-w width] [-h height] [-d depth] [-x off] [-y off] [color ...]");
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
