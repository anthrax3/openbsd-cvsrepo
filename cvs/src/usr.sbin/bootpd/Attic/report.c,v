head	1.5;
access;
symbols
	OPENBSD_3_5:1.4.0.2
	OPENBSD_3_5_BASE:1.4
	OPENBSD_3_4:1.3.0.2
	OPENBSD_3_4_BASE:1.3
	OPENBSD_3_3:1.2.0.18
	OPENBSD_3_3_BASE:1.2
	OPENBSD_3_2:1.2.0.16
	OPENBSD_3_2_BASE:1.2
	OPENBSD_3_1:1.2.0.14
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.12
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_9:1.2.0.10
	OPENBSD_2_8:1.2.0.8
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.6
	OPENBSD_2_7_BASE:1.2
	OPENBSD_2_6:1.2.0.4
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.2
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.1.1.1.0.10
	OPENBSD_2_4_BASE:1.1.1.1
	OPENBSD_2_3:1.1.1.1.0.8
	OPENBSD_2_3_BASE:1.1.1.1
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.5
date	2004.05.04.23.37.07;	author deraadt;	state dead;
branches;
next	1.4;

1.4
date	2004.03.16.01.11.09;	author tedu;	state Exp;
branches;
next	1.3;

1.3
date	2003.07.08.20.41.13;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	98.12.20.21.16.51;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.47.27;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.47.27;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.5
log
@bye bye bootpd.  You will not be missed.
@
text
@/*
 * report() - calls syslog
 */

#ifdef	__STDC__
#include <stdarg.h>
#else
#include <varargs.h>
#endif

#include <stdio.h>
#include <string.h>
#include <syslog.h>
#include <errno.h>

#include "report.h"

#ifndef LOG_NDELAY
#define LOG_NDELAY	0
#endif
#ifndef LOG_DAEMON
#define LOG_DAEMON	0
#endif
#ifndef	LOG_BOOTP
#define LOG_BOOTP	LOG_DAEMON
#endif

extern int debug;
extern char *progname;

/*
 * This is initialized so you get stderr until you call
 *	report_init()
 */
static int stderr_only = 1;

void
report_init(int nolog)
{
	stderr_only = nolog;
#ifdef SYSLOG
	if (!stderr_only) {
		openlog(progname, LOG_PID | LOG_NDELAY, LOG_BOOTP);
	}
#endif
}

/*
 * This routine reports errors and such via stderr and syslog() if
 * appopriate.  It just helps avoid a lot of "#ifdef SYSLOG" constructs
 * from being scattered throughout the code.
 *
 * The syntax is identical to syslog(3), but %m is not considered special
 * for output to stderr (i.e. you'll see "%m" in the output. . .).  Also,
 * control strings should normally end with \n since newlines aren't
 * automatically generated for stderr output (whereas syslog strips out all
 * newlines and adds its own at the end).
 */

static char *levelnames[] = {
#ifdef LOG_SALERT
	"level(0): ",
	"alert(1): ",
	"alert(2): ",
	"emerg(3): ",
	"error(4): ",
	"crit(5):  ",
	"warn(6):  ",
	"note(7):  ",
	"info(8):  ",
	"debug(9): ",
	"level(?): "
#else
	"emerg(0): ",
	"alert(1): ",
	"crit(2):  ",
	"error(3): ",
	"warn(4):  ",
	"note(5):  ",
	"info(6):  ",
	"debug(7): ",
	"level(?): "
#endif
};
static int numlevels = sizeof(levelnames) / sizeof(levelnames[0]);


/*
 * Print a log message using syslog(3) and/or stderr.
 * The message passed in should not include a newline.
 */
void
report(int priority, char *fmt,...)
{
	va_list ap;
	static char buf[256];

	if ((priority < 0) || (priority >= numlevels)) {
		priority = numlevels - 1;
	}
	va_start(ap, fmt);
	vsnprintf(buf, sizeof(buf), fmt, ap);
	va_end(ap);

	/*
	 * Print the message
	 */
	if (stderr_only || (debug > 2)) {
		fprintf(stderr, "%s: %s %s\n",
				progname, levelnames[priority], buf);
	}
#ifdef SYSLOG
	if (!stderr_only)
		syslog((priority | LOG_BOOTP), "%s", buf);
#endif
}



/*
 * Return pointer to static string which gives full filesystem error message.
 */
char *
get_errmsg(void)
{

	return strerror(errno);
}

/*
 * Local Variables:
 * tab-width: 4
 * c-indent-level: 4
 * c-argdecl-indent: 4
 * c-continued-statement-offset: 4
 * c-continued-brace-offset: -4
 * c-label-offset: -4
 * c-brace-offset: 0
 * End:
 */
@


1.4
log
@errno is not specified to be int, but something from errno.h.  ok millert@@
@
text
@@


1.3
log
@protos; avsm ok
@
text
@d14 1
a125 1
	extern int errno;
@


1.2
log
@o make sure C-style strings in packet are NUL-terminated and increase size of
  buf in report() for 256; W.H.J.Pinckaers@@CPEDU.RUG.NL
o kill sprintf in favor of snprintf everywhere (paranoia...)
@
text
@d12 1
d37 1
a37 2
report_init(nolog)
	int nolog;
a90 1
#ifdef	__STDC__
a92 8
#else
/*VARARGS2*/
void
report(priority, fmt, va_alist)
	int priority;
	char *fmt;
	va_dcl
#endif
a99 1
#ifdef	__STDC__
a100 3
#else
	va_start(ap);
#endif
d123 1
a123 1
get_errmsg()
a125 1
	extern char *strerror();
@


1.1
log
@Initial revision
@
text
@d104 1
a104 1
	static char buf[128];
d114 1
a114 1
	vsprintf(buf, fmt, ap);
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
