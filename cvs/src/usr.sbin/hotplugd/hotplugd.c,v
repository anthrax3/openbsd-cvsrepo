head	1.14;
access;
symbols
	OPENBSD_6_1:1.14.0.2
	OPENBSD_6_1_BASE:1.14
	OPENBSD_6_0:1.13.0.4
	OPENBSD_6_0_BASE:1.13
	OPENBSD_5_9:1.13.0.2
	OPENBSD_5_9_BASE:1.13
	OPENBSD_5_8:1.12.0.26
	OPENBSD_5_8_BASE:1.12
	OPENBSD_5_7:1.12.0.18
	OPENBSD_5_7_BASE:1.12
	OPENBSD_5_6:1.12.0.22
	OPENBSD_5_6_BASE:1.12
	OPENBSD_5_5:1.12.0.20
	OPENBSD_5_5_BASE:1.12
	OPENBSD_5_4:1.12.0.16
	OPENBSD_5_4_BASE:1.12
	OPENBSD_5_3:1.12.0.14
	OPENBSD_5_3_BASE:1.12
	OPENBSD_5_2:1.12.0.12
	OPENBSD_5_2_BASE:1.12
	OPENBSD_5_1_BASE:1.12
	OPENBSD_5_1:1.12.0.10
	OPENBSD_5_0:1.12.0.8
	OPENBSD_5_0_BASE:1.12
	OPENBSD_4_9:1.12.0.6
	OPENBSD_4_9_BASE:1.12
	OPENBSD_4_8:1.12.0.4
	OPENBSD_4_8_BASE:1.12
	OPENBSD_4_7:1.12.0.2
	OPENBSD_4_7_BASE:1.12
	OPENBSD_4_6:1.11.0.4
	OPENBSD_4_6_BASE:1.11
	OPENBSD_4_5:1.9.0.4
	OPENBSD_4_5_BASE:1.9
	OPENBSD_4_4:1.9.0.2
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3:1.7.0.8
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.7.0.6
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.4
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.2
	OPENBSD_4_0_BASE:1.7
	OPENBSD_3_9:1.3.0.8
	OPENBSD_3_9_BASE:1.3
	OPENBSD_3_8:1.3.0.6
	OPENBSD_3_8_BASE:1.3
	OPENBSD_3_7:1.3.0.4
	OPENBSD_3_7_BASE:1.3
	OPENBSD_3_6:1.3.0.2
	OPENBSD_3_6_BASE:1.3;
locks; strict;
comment	@ * @;


1.14
date	2016.07.31.20.13.12;	author natano;	state Exp;
branches;
next	1.13;
commitid	VC3yMnSlmJ2oB9Zc;

1.13
date	2015.11.19.06.05.40;	author deraadt;	state Exp;
branches;
next	1.12;
commitid	LuddL1fDqji1tI6q;

1.12
date	2010.01.10.13.20.41;	author grange;	state Exp;
branches;
next	1.11;

1.11
date	2009.06.26.01.06.04;	author kurt;	state Exp;
branches;
next	1.10;

1.10
date	2009.06.10.18.50.43;	author guenther;	state Exp;
branches;
next	1.9;

1.9
date	2008.05.25.16.49.04;	author jasper;	state Exp;
branches;
next	1.8;

1.8
date	2008.05.12.19.15.02;	author pyr;	state Exp;
branches;
next	1.7;

1.7
date	2006.05.28.16.44.52;	author mk;	state Exp;
branches;
next	1.6;

1.6
date	2006.05.28.01.35.38;	author mk;	state Exp;
branches;
next	1.5;

1.5
date	2006.04.05.08.22.21;	author grange;	state Exp;
branches;
next	1.4;

1.4
date	2006.04.05.08.10.29;	author grange;	state Exp;
branches;
next	1.3;

1.3
date	2004.05.30.16.35.22;	author grange;	state Exp;
branches;
next	1.2;

1.2
date	2004.05.30.16.29.41;	author grange;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.30.08.28.28;	author grange;	state Exp;
branches;
next	;


desc
@@


1.14
log
@Close /dev/hotplug on exec(). Otherwise a restart of the daemon may
fail, because the device is occupied by a child process.

from Alexey Vatchenko
ok jca
@
text
@/*	$OpenBSD: hotplugd.c,v 1.13 2015/11/19 06:05:40 deraadt Exp $	*/
/*
 * Copyright (c) 2004 Alexander Yurchenko <grange@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/*
 * Devices hot plugging daemon.
 */

#include <sys/types.h>
#include <sys/device.h>
#include <sys/hotplug.h>
#include <sys/wait.h>

#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <libgen.h>
#include <signal.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <syslog.h>
#include <unistd.h>

#define _PATH_DEV_HOTPLUG		"/dev/hotplug"
#define _PATH_ETC_HOTPLUG		"/etc/hotplug"
#define _PATH_ETC_HOTPLUG_ATTACH	_PATH_ETC_HOTPLUG "/attach"
#define _PATH_ETC_HOTPLUG_DETACH	_PATH_ETC_HOTPLUG "/detach"
#define _LOG_TAG			"hotplugd"
#define _LOG_FACILITY			LOG_DAEMON
#define _LOG_OPT			(LOG_NDELAY | LOG_PID)

volatile sig_atomic_t quit = 0;
char *device = _PATH_DEV_HOTPLUG;
int devfd = -1;

void exec_script(const char *, int, char *);

void sigchild(int);
void sigquit(int);
__dead void usage(void);

int
main(int argc, char *argv[])
{
	int ch;
	struct sigaction sact;
	struct hotplug_event he;

	if (pledge("stdio rpath proc exec", NULL) == -1)
		err(1, "pledge");

	while ((ch = getopt(argc, argv, "d:")) != -1)
		switch (ch) {
		case 'd':
			device = optarg;
			break;
		case '?':
		default:
			usage();
			/* NOTREACHED */
		}

	argc -= optind;
	argv += optind;
	if (argc > 0)
		usage();

	if ((devfd = open(device, O_RDONLY | O_CLOEXEC)) == -1)
		err(1, "%s", device);

	bzero(&sact, sizeof(sact));
	sigemptyset(&sact.sa_mask);
	sact.sa_flags = 0;
	sact.sa_handler = sigquit;
	sigaction(SIGINT, &sact, NULL);
	sigaction(SIGQUIT, &sact, NULL);
	sigaction(SIGTERM, &sact, NULL);
	sact.sa_handler = SIG_IGN;
	sigaction(SIGHUP, &sact, NULL);
	sact.sa_handler = sigchild;
	sact.sa_flags = SA_NOCLDSTOP;
	sigaction(SIGCHLD, &sact, NULL);

	openlog(_LOG_TAG, _LOG_OPT, _LOG_FACILITY);
	if (daemon(0, 0) == -1)
		err(1, "daemon");

	syslog(LOG_INFO, "started");

	while (!quit) {
		if (read(devfd, &he, sizeof(he)) == -1) {
			if (errno == EINTR)
				/* ignore */
				continue;
			syslog(LOG_ERR, "read: %m");
			exit(1);
		}

		switch (he.he_type) {
		case HOTPLUG_DEVAT:
			syslog(LOG_INFO, "%s attached, class %d",
			    he.he_devname, he.he_devclass);
			exec_script(_PATH_ETC_HOTPLUG_ATTACH, he.he_devclass,
			    he.he_devname);
			break;
		case HOTPLUG_DEVDT:
			syslog(LOG_INFO, "%s detached, class %d",
			    he.he_devname, he.he_devclass);
			exec_script(_PATH_ETC_HOTPLUG_DETACH, he.he_devclass,
			    he.he_devname);
			break;
		default:
			syslog(LOG_NOTICE, "unknown event (0x%x)", he.he_type);
		}
	}

	syslog(LOG_INFO, "terminated");

	closelog();
	close(devfd);

	return (0);
}

void
exec_script(const char *file, int class, char *name)
{
	char strclass[8];
	pid_t pid;

	snprintf(strclass, sizeof(strclass), "%d", class);

	if (access(file, X_OK | R_OK) == -1) {
		if (errno != ENOENT)
			syslog(LOG_ERR, "%s: %m", file);
		return;
	}

	if ((pid = fork()) == -1) {
		syslog(LOG_ERR, "fork: %m");
		return;
	}
	if (pid == 0) {
		/* child process */
		execl(file, basename(file), strclass, name, (char *)NULL);
		syslog(LOG_ERR, "execl %s: %m", file);
		_exit(1);
		/* NOTREACHED */
	}
}

/* ARGSUSED */
void
sigchild(int signum)
{
	struct syslog_data sdata = SYSLOG_DATA_INIT;
	int saved_errno, status;
	pid_t pid;

	saved_errno = errno;

	sdata.log_tag = _LOG_TAG;
	sdata.log_fac = _LOG_FACILITY;
	sdata.log_stat = _LOG_OPT;

	while ((pid = waitpid(WAIT_ANY, &status, WNOHANG)) != 0) {
		if (pid == -1) {
			if (errno == EINTR)
				continue;
			if (errno != ECHILD)
				syslog_r(LOG_ERR, &sdata, "waitpid: %m");
			break;
		}

		if (WIFEXITED(status)) {
			if (WEXITSTATUS(status) != 0) {
				syslog_r(LOG_NOTICE, &sdata,
				    "child exit status: %d",
				    WEXITSTATUS(status));
			}
		} else {
			syslog_r(LOG_NOTICE, &sdata,
			    "child is terminated abnormally");
		}
	}

	errno = saved_errno;
}

/* ARGSUSED */
void
sigquit(int signum)
{
	quit = 1;
}

__dead void
usage(void)
{
	extern char *__progname;

	fprintf(stderr, "usage: %s [-d device]\n", __progname);
	exit(1);
}
@


1.13
log
@pledge "stdio rpath proc exec" for entire lifetime.  rpath must remain
even late, because of access() before doing wasteful fork+execs.
@
text
@d1 1
a1 1
/*	$OpenBSD: hotplugd.c,v 1.12 2010/01/10 13:20:41 grange Exp $	*/
d83 1
a83 1
	if ((devfd = open(device, O_RDONLY)) == -1)
@


1.12
log
@Make hotplugd to not complain if any of attach or detach script
doesn't exist.

ok stsp@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hotplugd.c,v 1.11 2009/06/26 01:06:04 kurt Exp $	*/
d63 3
@


1.11
log
@If two or more children exit before hotplugd is scheduled only one SIGCHLD
will be delivered, so deal with this case in the SIGCHLD handler. Also
retry if waitpid() fails with EINTR. looks good deraadt@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hotplugd.c,v 1.10 2009/06/10 18:50:43 guenther Exp $	*/
d145 3
a147 2
	if (access(file, X_OK | R_OK)) {
		syslog(LOG_ERR, "could not access %s", file);
@


1.10
log
@Ignore ECHILD returns from waitpid() in the signal handler; it appears we
generate SIGCHLD spuriously in some cases.  Also, hotplugd doesn't care
if a child is stopped, so set SA_NOCLDSTOP to suppress SIGCHLDs from that.
Problem reported by Thomas Pfaff.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hotplugd.c,v 1.9 2008/05/25 16:49:04 jasper Exp $	*/
d177 9
a185 2
	pid = waitpid(WAIT_ANY, &status, 0);
	if (pid != -1) {
a195 2
	} else if (errno != ECHILD) {
		syslog_r(LOG_ERR, &sdata, "waitpid: %m");
@


1.9
log
@- chat to syslog if the script file can't be read or executed.

ok otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hotplugd.c,v 1.8 2008/05/12 19:15:02 pyr Exp $	*/
d93 1
d189 1
a189 1
	} else {
@


1.8
log
@Error out with usage line if additional arguments are given after the
option parsing. Found out the hard way by jdixon on ifstated.

ok sobrado@@, jdixon@@, millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hotplugd.c,v 1.7 2006/05/28 16:44:52 mk Exp $	*/
d144 2
a145 2
	if (access(file, X_OK | R_OK))
		/* do nothing if file can't be accessed */
d147 1
@


1.7
log
@Device id was removed from hotplug events so cope with this.
@
text
@d1 1
a1 1
/*	$OpenBSD: hotplugd.c,v 1.5 2006/04/05 08:22:21 grange Exp $	*/
d74 5
@


1.6
log
@Include device id in hotplug event logging.  id is passed as new
script parameter so only scripts that are picky about arg count
needs updating.

ok henning.
@
text
@d51 1
a51 1
void exec_script(const char *, int, char *, int);
d107 2
a108 2
			syslog(LOG_INFO, "%s attached, class %d, id %d",
			    he.he_devname, he.he_devclass, he.he_devid);
d110 1
a110 1
			    he.he_devname, he.he_devid);
d113 2
a114 2
			syslog(LOG_INFO, "%s detached, class %d id %d",
			    he.he_devname, he.he_devclass, he.he_devid);
d116 1
a116 1
			    he.he_devname, he.he_devid);
d132 1
a132 1
exec_script(const char *file, int class, char *name, int id)
a134 1
	char strid[8];
a137 1
	snprintf(strid, sizeof(strid), "%d", id);
d149 1
a149 1
		execl(file, basename(file), strclass, name, strid, (char *)NULL);
@


1.5
log
@Reap childs asynchronously in the signal handler.
Diff from Alexey Vatchenko <avv@@mail.zp.ua>.
@
text
@d1 1
a1 1
/*	$OpenBSD: hotplugd.c,v 1.4 2006/04/05 08:10:29 grange Exp $	*/
d51 1
a51 1
void exec_script(const char *, int, char *);
d107 2
a108 2
			syslog(LOG_INFO, "%s attached, class %d",
			    he.he_devname, he.he_devclass);
d110 1
a110 1
			    he.he_devname);
d113 2
a114 2
			syslog(LOG_INFO, "%s detached, class %d",
			    he.he_devname, he.he_devclass);
d116 1
a116 1
			    he.he_devname);
d132 1
a132 1
exec_script(const char *file, int class, char *name)
d135 1
d139 1
d151 1
a151 1
		execl(file, basename(file), strclass, name, (char *)NULL);
@


1.4
log
@ARGSUSED for signal handler to please lint.
@
text
@d1 1
a1 1
/*	$OpenBSD: hotplugd.c,v 1.3 2004/05/30 16:35:22 grange Exp $	*/
d43 3
d53 1
d87 2
d90 1
a90 1
	openlog("hotplugd", LOG_NDELAY | LOG_PID, LOG_DAEMON);
a135 1
	int status;
d153 19
a171 6
	} else {
		/* parent process */
		if (waitpid(pid, &status, 0) == -1) {
			syslog(LOG_ERR, "waitpid: %m");
			return;
		}
d173 3
a175 2
			if (WEXITSTATUS(status) != 0)
				syslog(LOG_NOTICE, "%s: exit status %d", file,
d177 1
d179 2
a180 1
			syslog(LOG_NOTICE, "%s: terminated abnormally", file);
d182 2
d185 2
@


1.3
log
@Better error message.
@
text
@d1 1
a1 1
/*	$OpenBSD: hotplugd.c,v 1.2 2004/05/30 16:29:41 grange Exp $	*/
d164 1
@


1.2
log
@Missing waitpid, noticed by Gregory Steuck <greg@@y2004.nest.cx>.
@
text
@d1 1
a1 1
/*	$OpenBSD: hotplugd.c,v 1.1 2004/05/30 08:28:28 grange Exp $	*/
d145 1
a145 1
		syslog(LOG_ERR, "execl: %m");
@


1.1
log
@hotplugd -- devices hot plugging monitor daemon.
The hotplugd daemon monitors the hotplug(4) pseudo-device, acting on
signaled events by executing the scripts in the /etc/hotplug directory.

Not linked to the build yet.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d130 1
d148 13
@

