head	1.11;
access;
symbols
	OPENBSD_6_1:1.11.0.8
	OPENBSD_6_1_BASE:1.11
	OPENBSD_6_0:1.11.0.4
	OPENBSD_6_0_BASE:1.11
	OPENBSD_5_9:1.11.0.2
	OPENBSD_5_9_BASE:1.11
	OPENBSD_5_8:1.10.0.42
	OPENBSD_5_8_BASE:1.10
	OPENBSD_5_7:1.10.0.34
	OPENBSD_5_7_BASE:1.10
	OPENBSD_5_6:1.10.0.38
	OPENBSD_5_6_BASE:1.10
	OPENBSD_5_5:1.10.0.36
	OPENBSD_5_5_BASE:1.10
	OPENBSD_5_4:1.10.0.32
	OPENBSD_5_4_BASE:1.10
	OPENBSD_5_3:1.10.0.30
	OPENBSD_5_3_BASE:1.10
	OPENBSD_5_2:1.10.0.28
	OPENBSD_5_2_BASE:1.10
	OPENBSD_5_1_BASE:1.10
	OPENBSD_5_1:1.10.0.26
	OPENBSD_5_0:1.10.0.24
	OPENBSD_5_0_BASE:1.10
	OPENBSD_4_9:1.10.0.22
	OPENBSD_4_9_BASE:1.10
	OPENBSD_4_8:1.10.0.20
	OPENBSD_4_8_BASE:1.10
	OPENBSD_4_7:1.10.0.16
	OPENBSD_4_7_BASE:1.10
	OPENBSD_4_6:1.10.0.18
	OPENBSD_4_6_BASE:1.10
	OPENBSD_4_5:1.10.0.14
	OPENBSD_4_5_BASE:1.10
	OPENBSD_4_4:1.10.0.12
	OPENBSD_4_4_BASE:1.10
	OPENBSD_4_3:1.10.0.10
	OPENBSD_4_3_BASE:1.10
	OPENBSD_4_2:1.10.0.8
	OPENBSD_4_2_BASE:1.10
	OPENBSD_4_1:1.10.0.6
	OPENBSD_4_1_BASE:1.10
	OPENBSD_4_0:1.10.0.4
	OPENBSD_4_0_BASE:1.10
	OPENBSD_3_9:1.10.0.2
	OPENBSD_3_9_BASE:1.10
	OPENBSD_3_8:1.9.0.2
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.8.0.4
	OPENBSD_3_7_BASE:1.8
	OPENBSD_3_6:1.8.0.2
	OPENBSD_3_6_BASE:1.8;
locks; strict;
comment	@ * @;


1.11
date	2016.02.06.23.50.10;	author krw;	state Exp;
branches;
next	1.10;
commitid	8GMcSAoPYCa1rXN3;

1.10
date	2005.11.13.20.25.59;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2005.04.18.16.39.25;	author moritz;	state Exp;
branches;
next	1.8;

1.8
date	2004.05.04.21.25.27;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2004.05.04.20.28.40;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2004.04.20.05.35.33;	author henning;	state Exp;
branches;
next	1.5;

1.5
date	2004.04.18.00.43.27;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2004.04.16.04.30.09;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2004.04.15.22.22.21;	author hshoexer;	state Exp;
branches;
next	1.2;

1.2
date	2004.04.14.04.34.19;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	2004.04.13.23.41.49;	author henning;	state Exp;
branches;
next	;


desc
@@


1.11
log
@Eliminate #include inside *.h files and include only needed headers in
each *.c file.

Inspired by mention of header silliness by Edgar Pettijohn and mmcc@@
on tech@@.
@
text
@/*	$OpenBSD: print.c,v 1.10 2005/11/13 20:25:59 deraadt Exp $ */

/* Turn data structures into printable text. */

/*
 * Copyright (c) 1995, 1996, 1997, 1998 The Internet Software Consortium.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of The Internet Software Consortium nor the names
 *    of its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INTERNET SOFTWARE CONSORTIUM AND
 * CONTRIBUTORS ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE INTERNET SOFTWARE CONSORTIUM OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This software has been written for the Internet Software Consortium
 * by Ted Lemon <mellon@@fugue.com> in cooperation with Vixie
 * Enterprises.  To learn more about the Internet Software Consortium,
 * see ``http://www.vix.com/isc''.  To learn more about Vixie
 * Enterprises, see ``http://www.vix.com''.
 */

#include <sys/types.h>
#include <sys/socket.h>

#include <net/if.h>

#include <netinet/in.h>

#include <stdio.h>
#include <string.h>

#include "dhcp.h"
#include "tree.h"
#include "dhcpd.h"

char *
print_hw_addr(int htype, int hlen, unsigned char *data)
{
	static char	habuf[49];
	int		i, j, slen = sizeof(habuf);
	char		*s = habuf;

	if (htype == 0 || hlen == 0) {
bad:
		strlcpy(habuf, "<null>", sizeof habuf);
		return habuf;
	}

	for (i = 0; i < hlen; i++) {
		j = snprintf(s, slen, "%02x", data[i]);
		if (j <= 0 || j >= slen)
			goto bad;
		j = strlen(s);
		s += j;
		slen -= (j + 1);
		*s++ = ':';
	}
	*--s = '\0';
	return habuf;
}
@


1.10
log
@pretty up print_hw_addr(), and even fix a teeny buffer overflow; ok otto
@
text
@d1 1
a1 1
/*	$OpenBSD: print.c,v 1.9 2005/04/18 16:39:25 moritz Exp $ */
d43 12
@


1.9
log
@snprintf() return value handling. ok cloder@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print.c,v 1.8 2004/05/04 21:25:27 deraadt Exp $ */
d49 2
a50 2
	char	*s;
	int	i;
d53 13
a65 15
		goto bad;
	} else {
		int	slen = sizeof(habuf);
		s = habuf;
		for (i = 0; i < hlen; i++) {
			int	j;
			j = snprintf(s, slen, "%02x", data[i]);
			if (j <= 0 || j >= slen)
				goto bad;

			s += strlen(s);
			slen -= (strlen(s) + 1);
			*s++ = ':';
		}
		*--s = 0;
d67 1
a68 4
bad:
	strlcpy(habuf, "<null>", sizeof habuf);
	return habuf;

@


1.8
log
@remove DEBUG_PACKET stuff; henning ok
@
text
@d1 1
a1 1
/*	$OpenBSD: print.c,v 1.7 2004/05/04 20:28:40 deraadt Exp $ */
d60 1
a60 1
			if (j <= 0)
@


1.7
log
@remove things not used, spotted by lint mostly; ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: print.c,v 1.6 2004/04/20 05:35:33 henning Exp $ */
a74 68

#ifdef DEBUG_PACKET
void
dump_packet(struct packet *tp)
{
	struct dhcp_packet *tdp = tp->raw;

	debug("packet length %d", tp->packet_length);
	debug("op = %d  htype = %d  hlen = %d  hops = %d", tdp->op, tdp->htype,
	    tdp->hlen, tdp->hops);
	debug("xid = %x  secs = %d  flags = %x", tdp->xid, tdp->secs,
	    tdp->flags);
	debug("ciaddr = %s", inet_ntoa(tdp->ciaddr));
	debug("yiaddr = %s", inet_ntoa(tdp->yiaddr));
	debug("siaddr = %s", inet_ntoa(tdp->siaddr));
	debug("giaddr = %s", inet_ntoa(tdp->giaddr));
	debug("chaddr = %02x:%02x:%02x:%02x:%02x:%02x",
	    ((unsigned char *)(tdp->chaddr))[0],
	    ((unsigned char *)(tdp->chaddr))[1],
	    ((unsigned char *)(tdp->chaddr))[2],
	    ((unsigned char *)(tdp->chaddr))[3],
	    ((unsigned char *)(tdp->chaddr))[4],
	    ((unsigned char *)(tdp->chaddr))[5]);
	debug("filename = %s", tdp->file);
	debug("server_name = %s", tdp->sname);
	if (tp->options_valid) {
		int	i;

		for (i = 0; i < 256; i++) {
			if (tp->options[i].data)
				debug("  %s = %s", dhcp_options[i].name,
				    pretty_print_option(i, tp->options[i].data,
				    tp->options[i].len, 1, 1));
		}
	}
	debug("%s", "");
}

void
dump_raw(unsigned char *buf, int len)
{
	char	lbuf[80];
	int	i, j, llen = sizeof(lbuf), lbix = 0;

	lbuf[0] = 0;

	for (i = 0; i < len; i++) {
		if ((i & 15) == 0) {
			if (lbix)
				note("%s", lbuf);
			j = snprintf(lbuf, llen, "%03x:", i);
			if (j >= llen)
				return;
			lbix += j;
			llen -= j;
		} else if ((i & 7) == 0) {
			lbuf[lbix++] = ' ';
			len--;
		}
		j = snprintf(&lbuf[lbix], llen, " %02x", buf[i]);
		if (j >= llen)
			return;
		lbix += j;
		llen -= j;
	}
	note("%s", lbuf);
}
#endif /* DEBUG_PACKET */
@


1.6
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d76 1
a76 26
void
print_lease(struct lease *lease)
{
	struct tm	*t;
	char	tbuf[32];

	debug("      Lease %s", piaddr(lease->ip_addr));

	t = gmtime(&lease->starts);
	strftime(tbuf, sizeof tbuf, "%Y/%m/%d %H:%M:%S", t);
	debug("        start %s", tbuf);

	t = gmtime(&lease->ends);
	strftime(tbuf, sizeof tbuf, "%Y/%m/%d %H:%M:%S", t);
	debug("        end %s", tbuf);

	t = gmtime(&lease->timestamp);
	strftime(tbuf, sizeof tbuf, "%Y/%m/%d %H:%M:%S", t);
	debug("        stamp %s", tbuf);

	debug("        hardware addr = %s",
	    print_hw_addr(lease->hardware_addr.htype,
	    lease->hardware_addr.hlen, lease->hardware_addr.haddr));
	debug("        host %s  ", lease->host ? lease->host->name : "<none>");
}

d142 1
a142 22

void
hash_dump(struct hash_table *table)
{
	struct hash_bucket *bp;
	int	i;

	if (!table)
		return;

	for (i = 0; i < table->hash_count; i++) {
		if (!table->buckets[i])
			continue;
		note("hash bucket %d:", i);
		for (bp = table->buckets[i]; bp; bp = bp->next) {
			if (bp->len)
				dump_raw(bp->name, bp->len);
			else
				note("%s", (char *)bp->name);
		}
	}
}
@


1.5
log
@various knf; henning ok
@
text
@d1 1
a1 1
/*	$Id: print.c,v 1.4 2004/04/16 04:30:09 deraadt Exp $	 */
@


1.4
log
@a bunch of knf, ok henning
@
text
@d1 1
a1 1
/*	$Id: print.c,v 1.3 2004/04/15 22:22:21 hshoexer Exp $	 */
d76 1
a76 1
void 
d102 1
a102 1
void 
d117 1
a117 1
    	    ((unsigned char *)(tdp->chaddr))[0],
d138 1
a138 1
void 
d149 1
a149 1
				note(lbuf);
d165 1
a165 1
	note(lbuf);
d168 1
a168 1
void 
d185 1
a185 1
				note((char *) bp->name);
@


1.3
log
@knf + ansi

ok henning@@
@
text
@d1 1
a1 1
/*	$Id:$	 */
d48 3
a50 3
	static char     habuf[49];
	char           *s;
	int             i;
d79 2
a80 2
	struct tm      *t;
	char            tbuf[32];
d126 1
a126 1
		int             i;
d141 2
a142 4
	int             i, j;
	char            lbuf[80];
	int             llen = sizeof(lbuf);
	int             lbix = 0;
a170 1
	int             i;
d172 1
@


1.2
log
@spaces
@
text
@d1 1
a1 1
/* print.c
d3 1
a3 1
   Turn data structures into printable text. */
d45 2
a46 4
char *print_hw_addr (htype, hlen, data)
	int htype;
	int hlen;
	unsigned char *data;
d48 3
a50 3
	static char habuf [49];
	char *s;
	int i;
d55 1
a55 1
		int slen = sizeof(habuf);
d58 2
a59 2
			int j;
			j = snprintf (s, slen, "%02x", data [i]);
d63 1
a63 1
			s += strlen (s);
d70 2
a71 2
 bad:
	strlcpy (habuf, "<null>", sizeof habuf);
d76 2
a77 2
void print_lease (lease)
	struct lease *lease;
d79 2
a80 2
	struct tm *t;
	char tbuf [32];
d82 1
a82 2
	debug ("      Lease %s",
	       piaddr (lease -> ip_addr));
d84 16
a99 18
	t = gmtime (&lease -> starts);
	strftime (tbuf, sizeof tbuf, "%Y/%m/%d %H:%M:%S", t);
	debug ("        start %s", tbuf);

	t = gmtime (&lease -> ends);
	strftime (tbuf, sizeof tbuf, "%Y/%m/%d %H:%M:%S", t);
	debug ("        end %s", tbuf);

	t = gmtime (&lease -> timestamp);
	strftime (tbuf, sizeof tbuf, "%Y/%m/%d %H:%M:%S", t);
	debug ("        stamp %s", tbuf);

	debug ("        hardware addr = %s",
	       print_hw_addr (lease -> hardware_addr.htype,
			       lease -> hardware_addr.hlen,
			       lease -> hardware_addr.haddr));
	debug ("        host %s  ",
	       lease -> host ? lease -> host -> name : "<none>");
d102 2
a103 2
void dump_packet (tp)
	struct packet *tp;
d105 1
a105 1
	struct dhcp_packet *tdp = tp -> raw;
d107 20
a126 20
	debug ("packet length %d", tp -> packet_length);
	debug ("op = %d  htype = %d  hlen = %d  hops = %d",
	       tdp -> op, tdp -> htype, tdp -> hlen, tdp -> hops);
	debug ("xid = %x  secs = %d  flags = %x",
	       tdp -> xid, tdp -> secs, tdp -> flags);
	debug ("ciaddr = %s", inet_ntoa (tdp -> ciaddr));
	debug ("yiaddr = %s", inet_ntoa (tdp -> yiaddr));
	debug ("siaddr = %s", inet_ntoa (tdp -> siaddr));
	debug ("giaddr = %s", inet_ntoa (tdp -> giaddr));
	debug ("chaddr = %02x:%02x:%02x:%02x:%02x:%02x",
	       ((unsigned char *)(tdp -> chaddr)) [0],
	       ((unsigned char *)(tdp -> chaddr)) [1],
	       ((unsigned char *)(tdp -> chaddr)) [2],
	       ((unsigned char *)(tdp -> chaddr)) [3],
	       ((unsigned char *)(tdp -> chaddr)) [4],
	       ((unsigned char *)(tdp -> chaddr)) [5]);
	debug ("filename = %s", tdp -> file);
	debug ("server_name = %s", tdp -> sname);
	if (tp -> options_valid) {
		int i;
d129 4
a132 6
			if (tp -> options [i].data)
				debug ("  %s = %s",
					dhcp_options [i].name,
					pretty_print_option
					(i, tp -> options [i].data,
					 tp -> options [i].len, 1, 1));
d135 1
a135 1
	debug ("%s", "");
d138 2
a139 3
void dump_raw (buf, len)
	unsigned char *buf;
	int len;
d141 4
a144 4
	int i, j;
	char lbuf [80];
	int llen = sizeof(lbuf);
	int lbix = 0;
d146 1
a146 1
	lbuf [0] = 0;
d151 2
a152 2
				note (lbuf);
			j = snprintf (lbuf, llen, "%03x:", i);
d155 2
a156 2
			lbix+=j;
			llen-=j;
d158 1
a158 1
			lbuf [lbix++] = ' ';
d161 1
a161 1
		j = snprintf (&lbuf [lbix], llen, " %02x", buf [i]);
d167 1
a167 1
	note (lbuf);
d170 2
a171 2
void hash_dump (table)
	struct hash_table *table;
d173 1
a173 1
	int i;
d179 2
a180 2
	for (i = 0; i < table -> hash_count; i++) {
		if (!table -> buckets [i])
d182 4
a185 4
		note ("hash bucket %d:", i);
		for (bp = table -> buckets [i]; bp; bp = bp -> next) {
			if (bp -> len)
				dump_raw (bp -> name, bp -> len);
d187 1
a187 1
				note ((char *)bp -> name);
@


1.1
log
@may the whacking begin
@
text
@d67 1
a67 1
 			*s++ = ':';
d72 1
a72 1
 bad:	
d86 1
a86 1
	
d90 1
a90 1
	
d94 1
a94 1
	
d98 1
a98 1
	
d105 1
a105 1
}	
d165 1
a165 1
		} else if ((i & 7) == 0) { 
@

