head	1.13;
access;
symbols
	OPENBSD_6_1:1.12.0.4
	OPENBSD_6_1_BASE:1.12
	OPENBSD_6_0:1.11.0.4
	OPENBSD_6_0_BASE:1.11
	OPENBSD_5_9:1.11.0.2
	OPENBSD_5_9_BASE:1.11
	OPENBSD_5_8:1.9.0.6
	OPENBSD_5_8_BASE:1.9
	OPENBSD_5_7:1.9.0.2
	OPENBSD_5_7_BASE:1.9
	OPENBSD_5_6:1.7.0.4
	OPENBSD_5_6_BASE:1.7
	OPENBSD_5_5:1.6.0.4
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.5.0.4
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.2
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.3.0.34
	OPENBSD_5_2_BASE:1.3
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.32
	OPENBSD_5_0:1.3.0.30
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.28
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.3.0.26
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.3.0.22
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.24
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.3.0.20
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.3.0.18
	OPENBSD_4_4_BASE:1.3
	OPENBSD_4_3:1.3.0.16
	OPENBSD_4_3_BASE:1.3
	OPENBSD_4_2:1.3.0.14
	OPENBSD_4_2_BASE:1.3
	OPENBSD_4_1:1.3.0.12
	OPENBSD_4_1_BASE:1.3
	OPENBSD_4_0:1.3.0.10
	OPENBSD_4_0_BASE:1.3
	OPENBSD_3_9:1.3.0.8
	OPENBSD_3_9_BASE:1.3
	OPENBSD_3_8:1.3.0.6
	OPENBSD_3_8_BASE:1.3
	OPENBSD_3_7:1.3.0.4
	OPENBSD_3_7_BASE:1.3
	OPENBSD_3_6:1.3.0.2
	OPENBSD_3_6_BASE:1.3;
locks; strict;
comment	@ * @;


1.13
date	2017.04.17.18.31.08;	author krw;	state Exp;
branches;
next	1.12;
commitid	ty0UWHtzgExZQRGh;

1.12
date	2017.02.13.19.13.14;	author krw;	state Exp;
branches;
next	1.11;
commitid	syYFt6P4XI7prXRF;

1.11
date	2016.02.06.23.50.10;	author krw;	state Exp;
branches;
next	1.10;
commitid	8GMcSAoPYCa1rXN3;

1.10
date	2016.02.03.14.48.36;	author krw;	state Exp;
branches;
next	1.9;
commitid	IE5ZAwOumxPJ0eHN;

1.9
date	2014.10.25.03.23.49;	author lteo;	state Exp;
branches;
next	1.8;
commitid	2uw1UTO4k6erpWzK;

1.8
date	2014.08.18.20.58.56;	author tobias;	state Exp;
branches;
next	1.7;
commitid	UakKZhYSjUY94PiS;

1.7
date	2014.07.26.07.48.49;	author tobias;	state Exp;
branches;
next	1.6;
commitid	3whnDWfpQYcw44OF;

1.6
date	2013.12.05.21.03.40;	author krw;	state Exp;
branches;
next	1.5;

1.5
date	2013.02.03.21.04.19;	author krw;	state Exp;
branches;
next	1.4;

1.4
date	2013.01.05.12.34.53;	author krw;	state Exp;
branches;
next	1.3;

1.3
date	2004.04.21.09.11.58;	author canacar;	state Exp;
branches;
next	1.2;

1.2
date	2004.04.14.00.56.02;	author henning;	state Exp;
branches;
next	1.1;

1.1
date	2004.04.13.23.41.49;	author henning;	state Exp;
branches;
next	;


desc
@@


1.13
log
@Use better types for checksum() parameters and local var from
dhclient. Eliminate extra prototypes for checksum() and wrapsum().
@
text
@/*	$OpenBSD: packet.c,v 1.12 2017/02/13 19:13:14 krw Exp $	*/

/* Packet assembly code, originally contributed by Archie Cobbs. */

/*
 * Copyright (c) 1995, 1996, 1999 The Internet Software Consortium.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of The Internet Software Consortium nor the names
 *    of its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INTERNET SOFTWARE CONSORTIUM AND
 * CONTRIBUTORS ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE INTERNET SOFTWARE CONSORTIUM OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This software has been written for the Internet Software Consortium
 * by Ted Lemon <mellon@@fugue.com> in cooperation with Vixie
 * Enterprises.  To learn more about the Internet Software Consortium,
 * see ``http://www.vix.com/isc''.  To learn more about Vixie
 * Enterprises, see ``http://www.vix.com''.
 */

#include <sys/types.h>
#include <sys/socket.h>

#include <net/if.h>

#include <netinet/in.h>
#include <netinet/ip.h>
#include <netinet/udp.h>
#include <netinet/if_ether.h>

#include <stdio.h>
#include <string.h>

#include "dhcp.h"
#include "tree.h"
#include "dhcpd.h"
#include "log.h"

u_int32_t
checksum(unsigned char *buf, u_int32_t nbytes, u_int32_t sum)
{
	unsigned int i;

	/* Checksum all the pairs of bytes first... */
	for (i = 0; i < (nbytes & ~1U); i += 2) {
		sum += (u_int16_t)ntohs(*((u_int16_t *)(buf + i)));
		if (sum > 0xFFFF)
			sum -= 0xFFFF;
	}

	/*
	 * If there's a single byte left over, checksum it, too.
	 * Network byte order is big-endian, so the remaining byte is
	 * the high byte.
	 */
	if (i < nbytes) {
		sum += buf[i] << 8;
		if (sum > 0xFFFF)
			sum -= 0xFFFF;
	}

	return (sum);
}

u_int32_t
wrapsum(u_int32_t sum)
{
	sum = ~sum & 0xFFFF;
	return (htons(sum));
}

void
assemble_hw_header(struct interface_info *interface, unsigned char *buf,
    int *bufix, struct hardware *to)
{
	struct ether_header eh;

	if (to != NULL && to->hlen == 6) /* XXX */
		memcpy(eh.ether_dhost, to->haddr, sizeof(eh.ether_dhost));
	else
		memset(eh.ether_dhost, 0xff, sizeof(eh.ether_dhost));

	/* source address is filled in by the kernel */
	memset(eh.ether_shost, 0x00, sizeof(eh.ether_shost));

	eh.ether_type = htons(ETHERTYPE_IP);

	memcpy(&buf[*bufix], &eh, ETHER_HDR_LEN);
	*bufix += ETHER_HDR_LEN;
}

void
assemble_udp_ip_header(struct interface_info *interface, unsigned char *buf,
    int *bufix, u_int32_t from, u_int32_t to, unsigned int port,
    unsigned char *data, int len)
{
	struct ip ip;
	struct udphdr udp;

	ip.ip_v = 4;
	ip.ip_hl = 5;
	ip.ip_tos = IPTOS_LOWDELAY;
	ip.ip_len = htons(sizeof(ip) + sizeof(udp) + len);
	ip.ip_id = 0;
	ip.ip_off = 0;
	ip.ip_ttl = 16;
	ip.ip_p = IPPROTO_UDP;
	ip.ip_sum = 0;
	ip.ip_src.s_addr = from;
	ip.ip_dst.s_addr = to;

	ip.ip_sum = wrapsum(checksum((unsigned char *)&ip, sizeof(ip), 0));
	memcpy(&buf[*bufix], &ip, sizeof(ip));
	*bufix += sizeof(ip);

	udp.uh_sport = server_port;	/* XXX */
	udp.uh_dport = port;			/* XXX */
	udp.uh_ulen = htons(sizeof(udp) + len);
	memset(&udp.uh_sum, 0, sizeof(udp.uh_sum));

	udp.uh_sum = wrapsum(checksum((unsigned char *)&udp, sizeof(udp),
	    checksum(data, len, checksum((unsigned char *)&ip.ip_src,
	    2 * sizeof(ip.ip_src),
	    IPPROTO_UDP + (u_int32_t)ntohs(udp.uh_ulen)))));

	memcpy(&buf[*bufix], &udp, sizeof(udp));
	*bufix += sizeof(udp);
}

ssize_t
decode_hw_header(struct interface_info *interface, unsigned char *buf,
    int bufix, struct hardware *from)
{
	struct ether_header eh;

	memcpy(&eh, buf + bufix, ETHER_HDR_LEN);

	memcpy(from->haddr, eh.ether_shost, sizeof(eh.ether_shost));
	from->htype = ARPHRD_ETHER;
	from->hlen = sizeof(eh.ether_shost);

	return (sizeof(eh));
}

ssize_t
decode_udp_ip_header(struct interface_info *interface, unsigned char *buf,
    int bufix, struct sockaddr_in *from, int buflen)
{
	struct ip *ip;
	struct udphdr *udp;
	unsigned char *data;
	u_int32_t ip_len;
	u_int32_t sum, usum;
	static unsigned int ip_packets_seen;
	static unsigned int ip_packets_bad_checksum;
	static unsigned int udp_packets_seen;
	static unsigned int udp_packets_bad_checksum;
	static unsigned int udp_packets_length_checked;
	static unsigned int udp_packets_length_overflow;
	int len;

	/* Assure that an entire IP header is within the buffer. */
	if (sizeof(*ip) > buflen)
		return (-1);
	ip_len = (buf[bufix] & 0xf) << 2;
	if (ip_len > buflen)
		return (-1);

	ip = (struct ip *)(buf + bufix);
	ip_packets_seen++;

	/* Check the IP header checksum - it should be zero. */
	if (wrapsum(checksum(buf + bufix, ip_len, 0)) != 0) {
		ip_packets_bad_checksum++;
		if (ip_packets_seen > 4 && ip_packets_bad_checksum != 0 &&
		    (ip_packets_seen / ip_packets_bad_checksum) < 2) {
			log_info("%u bad IP checksums seen in %u packets",
			    ip_packets_bad_checksum, ip_packets_seen);
			ip_packets_seen = ip_packets_bad_checksum = 0;
		}
		return (-1);
	}

	memcpy(&from->sin_addr, &ip->ip_src, sizeof(from->sin_addr));

#ifdef DEBUG
	if (ntohs(ip->ip_len) != buflen)
		log_debug("ip length %d disagrees with bytes received %d.",
		    ntohs(ip->ip_len), buflen);
#endif


	/* Assure that the entire IP packet is within the buffer. */
	if (ntohs(ip->ip_len) > buflen)
		return (-1);

	/* Assure that the UDP header is within the buffer. */
	if (ip_len + sizeof(*udp) > buflen)
		return (-1);
	udp = (struct udphdr *)(buf + bufix + ip_len);
	udp_packets_seen++;

	/* Assure that the entire UDP packet is within the buffer. */
	if (ip_len + ntohs(udp->uh_ulen) > buflen)
		return (-1);
	data = buf + bufix + ip_len + sizeof(*udp);

	/*
	 * Compute UDP checksums, including the ``pseudo-header'', the
	 * UDP header and the data. If the UDP checksum field is zero,
	 * we're not supposed to do a checksum.
	 */
	udp_packets_length_checked++;
	len = ntohs(udp->uh_ulen) - sizeof(*udp);
	if ((len < 0) || (len + data > buf + bufix + buflen)) {
		udp_packets_length_overflow++;
		if (udp_packets_length_checked > 4 &&
		    udp_packets_length_overflow != 0 &&
		    (udp_packets_length_checked /
		    udp_packets_length_overflow) < 2) {
			log_info("%u udp packets in %u too long - dropped",
			    udp_packets_length_overflow,
			    udp_packets_length_checked);
			udp_packets_length_overflow =
			    udp_packets_length_checked = 0;
		}
		return (-1);
	}
	if (len + data != buf + bufix + buflen)
		log_debug("accepting packet with data after udp payload.");

	usum = udp->uh_sum;
	udp->uh_sum = 0;

	sum = wrapsum(checksum((unsigned char *)udp, sizeof(*udp),
	    checksum(data, len, checksum((unsigned char *)&ip->ip_src,
	    2 * sizeof(ip->ip_src),
	    IPPROTO_UDP + (u_int32_t)ntohs(udp->uh_ulen)))));

	udp_packets_seen++;
	if (usum && usum != sum) {
		udp_packets_bad_checksum++;
		if (udp_packets_seen > 4 && udp_packets_bad_checksum != 0 &&
		    (udp_packets_seen / udp_packets_bad_checksum) < 2) {
			log_info("%u bad udp checksums in %u packets",
			    udp_packets_bad_checksum, udp_packets_seen);
			udp_packets_seen = udp_packets_bad_checksum = 0;
		}
		return (-1);
	}

	memcpy(&from->sin_port, &udp->uh_sport, sizeof(udp->uh_sport));

	return (ip_len + sizeof(*udp));
}
@


1.12
log
@Switch from old errwarn.c logging to shiny new log.[ch].

ok benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.11 2016/02/06 23:50:10 krw Exp $	*/
a60 3
u_int32_t	checksum(unsigned char *, unsigned, u_int32_t);
u_int32_t	wrapsum(u_int32_t);

d62 1
a62 1
checksum(unsigned char *buf, unsigned nbytes, u_int32_t sum)
d64 1
a64 1
	int i;
@


1.11
log
@Eliminate #include inside *.h files and include only needed headers in
each *.c file.

Inspired by mention of header silliness by Edgar Pettijohn and mmcc@@
on tech@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.10 2016/02/03 14:48:36 krw Exp $	*/
d59 1
d202 1
a202 1
			note("%u bad IP checksums seen in %u packets",
d213 1
a213 1
		debug("ip length %d disagrees with bytes received %d.",
d246 1
a246 1
			note("%u udp packets in %u too long - dropped",
d255 1
a255 1
		debug("accepting packet with data after udp payload.");
d270 1
a270 1
			note("%u bad udp checksums in %u packets",
@


1.10
log
@be very careful accepting packets via bpf. First check that the
fixed part of the IP header is completely present before using its
header length field.  Then use the data in the IP header to ensure
the entire IP packet is present. Then check that the entire UDP header
is present. Then use the data in the UDP header to ensure all the
data it thinks is present is actually present.

Started when tj@@ and a few others noticed ISC "DHCP CVE-2015-8605:
UDP payload length not properly checked".

ok sthen@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.9 2014/10/25 03:23:49 lteo Exp $	*/
d43 4
a46 1
#include "dhcpd.h"
d48 1
d52 7
@


1.9
log
@Remove unnecessary netinet/in_systm.h include.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.8 2014/08/18 20:58:56 tobias Exp $	*/
d165 1
a165 1
	u_int32_t ip_len = (buf[bufix] & 0xf) << 2;
d175 7
d183 1
a183 1
	udp = (struct udphdr *)(buf + bufix + ip_len);
a185 1
	ip_packets_seen++;
d197 3
d203 6
d210 10
a219 1
	memcpy(&from->sin_addr, &ip->ip_src, 4);
d226 1
a226 1
	data = buf + bufix + ip_len + sizeof(*udp);
a227 1
	udp_packets_length_checked++;
@


1.8
log
@Variables to count seen packets should be unsigned.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.7 2014/07/26 07:48:49 tobias Exp $	*/
a44 1
#include <netinet/in_systm.h>
@


1.7
log
@Fix very hard to reach DoS attack vector, which would involve more than
8 billion network packets.  Mixture of many many malformed and proper
packets could result in a division by zero.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.6 2013/12/05 21:03:40 krw Exp $	*/
d168 6
a173 6
	static int ip_packets_seen;
	static int ip_packets_bad_checksum;
	static int udp_packets_seen;
	static int udp_packets_bad_checksum;
	static int udp_packets_length_checked;
	static int udp_packets_length_overflow;
d185 1
a185 1
			note("%d bad IP checksums seen in %d packets",
d212 1
a212 1
			note("%d udp packets in %d too long - dropped",
d236 1
a236 1
			note("%d bad udp checksums in %d packets",
@


1.6
log
@Nuke local #define ETHER_HEADER_SIZE and use the identical value'd
ETHER_HDR_LEN from if_ether.h. dhclient change ok matthew@@ as part
of larger diff.
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.5 2013/02/03 21:04:19 krw Exp $	*/
d183 1
a183 1
		if (ip_packets_seen > 4 &&
d209 1
d234 1
a234 1
		if (udp_packets_seen > 4 &&
@


1.5
log
@Remove unused (a.k.a. always passed NULL) parameter 'data' from
decode_udp_ip_header() and the useless check of it. Part of original
diff from pelikan about udp length errors.
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.4 2013/01/05 12:34:53 krw Exp $	*/
a49 2
#define ETHER_HEADER_SIZE (ETHER_ADDR_LEN * 2 + sizeof(u_int16_t))

d102 2
a103 2
	memcpy(&buf[*bufix], &eh, ETHER_HEADER_SIZE);
	*bufix += ETHER_HEADER_SIZE;
d150 1
a150 1
	memcpy(&eh, buf + bufix, ETHER_HEADER_SIZE);
@


1.4
log
@Check UDP length field for short as well as long values. Fixes a
dhcpd crash when a UDP packet arrives saying it has 0 length.

Spotted by Martin Pelikan, who also noted it was fixed a while ago
in ISC DHCP 3.0b2p17.

Fix tested by Martin. Thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.3 2004/04/21 09:11:58 canacar Exp $	*/
d163 1
a163 1
    int bufix, struct sockaddr_in *from, unsigned char *data, int buflen)
d167 1
d176 1
a176 1
	int len = 0;
d202 1
a202 1
	 * UDP header and the data.   If the UDP checksum field is zero,
d205 13
a217 16
	if (!data) {
		data = buf + bufix + ip_len + sizeof(*udp);
		len = ntohs(udp->uh_ulen) - sizeof(*udp);
		udp_packets_length_checked++;
		if ((len < 0) || (len + data > buf + bufix + buflen)) {
			udp_packets_length_overflow++;
			if (udp_packets_length_checked > 4 &&
			    (udp_packets_length_checked /
			    udp_packets_length_overflow) < 2) {
				note("%d udp packets in %d too long - dropped",
				    udp_packets_length_overflow,
				    udp_packets_length_checked);
				udp_packets_length_overflow =
				    udp_packets_length_checked = 0;
			}
			return (-1);
d219 1
a219 2
		if (len + data != buf + bufix + buflen)
			debug("accepting packet with data after udp payload.");
d221 2
@


1.3
log
@filter writes and lock bpf descriptor, ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.2 2004/04/14 00:56:02 henning Exp $	*/
d208 1
a208 1
		if (len + data > buf + bufix + buflen) {
@


1.2
log
@more crap bites the dust
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.1 2004/04/13 23:41:49 henning Exp $	*/
d52 2
a53 4
void	assemble_ethernet_header(struct interface_info *, unsigned char *,
	    int *, struct hardware *);
ssize_t	decode_ethernet_header(struct interface_info *, unsigned char *,
	    int bufix, struct hardware *);
d98 3
a100 5
	if (interface->hw_address.hlen == sizeof(eh.ether_shost))
		memcpy(eh.ether_shost, interface->hw_address.haddr,
		    sizeof(eh.ether_shost));
	else
		memset(eh.ether_shost, 0x00, sizeof(eh.ether_shost));
d132 1
a132 1
	udp.uh_sport = htons(LOCAL_PORT);	/* XXX */
@


1.1
log
@may the whacking begin
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.8 2004/02/25 14:22:12 henning Exp $	*/
a50 3

u_int32_t	checksum(unsigned char *, unsigned, u_int32_t);
u_int32_t	wrapsum(u_int32_t);
@

