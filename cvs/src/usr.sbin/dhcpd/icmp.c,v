head	1.18;
access;
symbols
	OPENBSD_6_1:1.18.0.2
	OPENBSD_6_1_BASE:1.18
	OPENBSD_6_0:1.14.0.4
	OPENBSD_6_0_BASE:1.14
	OPENBSD_5_9:1.14.0.2
	OPENBSD_5_9_BASE:1.14
	OPENBSD_5_8:1.13.0.6
	OPENBSD_5_8_BASE:1.13
	OPENBSD_5_7:1.13.0.2
	OPENBSD_5_7_BASE:1.13
	OPENBSD_5_6:1.12.0.4
	OPENBSD_5_6_BASE:1.12
	OPENBSD_5_5:1.10.0.24
	OPENBSD_5_5_BASE:1.10
	OPENBSD_5_4:1.10.0.20
	OPENBSD_5_4_BASE:1.10
	OPENBSD_5_3:1.10.0.18
	OPENBSD_5_3_BASE:1.10
	OPENBSD_5_2:1.10.0.16
	OPENBSD_5_2_BASE:1.10
	OPENBSD_5_1_BASE:1.10
	OPENBSD_5_1:1.10.0.14
	OPENBSD_5_0:1.10.0.12
	OPENBSD_5_0_BASE:1.10
	OPENBSD_4_9:1.10.0.10
	OPENBSD_4_9_BASE:1.10
	OPENBSD_4_8:1.10.0.8
	OPENBSD_4_8_BASE:1.10
	OPENBSD_4_7:1.10.0.4
	OPENBSD_4_7_BASE:1.10
	OPENBSD_4_6:1.10.0.6
	OPENBSD_4_6_BASE:1.10
	OPENBSD_4_5:1.10.0.2
	OPENBSD_4_5_BASE:1.10
	OPENBSD_4_4:1.9.0.16
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3:1.9.0.14
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.9.0.12
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.9.0.10
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.9.0.8
	OPENBSD_4_0_BASE:1.9
	OPENBSD_3_9:1.9.0.6
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.9.0.4
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.9.0.2
	OPENBSD_3_7_BASE:1.9
	OPENBSD_3_6:1.8.0.2
	OPENBSD_3_6_BASE:1.8;
locks; strict;
comment	@ * @;


1.18
date	2017.02.13.23.04.05;	author krw;	state Exp;
branches;
next	1.17;
commitid	amfLXbU964CBXnkr;

1.17
date	2017.02.13.22.33.39;	author krw;	state Exp;
branches;
next	1.16;
commitid	aD6aChUv7GEv3CLZ;

1.16
date	2017.02.13.19.13.14;	author krw;	state Exp;
branches;
next	1.15;
commitid	syYFt6P4XI7prXRF;

1.15
date	2016.11.15.10.49.37;	author mestre;	state Exp;
branches;
next	1.14;
commitid	MJxFs9s3mqdgRyMT;

1.14
date	2016.02.06.23.50.10;	author krw;	state Exp;
branches;
next	1.13;
commitid	8GMcSAoPYCa1rXN3;

1.13
date	2014.10.25.03.23.49;	author lteo;	state Exp;
branches;
next	1.12;
commitid	2uw1UTO4k6erpWzK;

1.12
date	2014.05.07.13.20.47;	author pelikan;	state Exp;
branches;
next	1.11;

1.11
date	2014.05.05.18.27.57;	author pelikan;	state Exp;
branches;
next	1.10;

1.10
date	2008.09.15.20.38.17;	author claudio;	state Exp;
branches;
next	1.9;

1.9
date	2004.09.16.18.35.43;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2004.04.22.15.22.48;	author henning;	state Exp;
branches;
next	1.7;

1.7
date	2004.04.21.22.44.35;	author henning;	state Exp;
branches;
next	1.6;

1.6
date	2004.04.20.05.35.33;	author henning;	state Exp;
branches;
next	1.5;

1.5
date	2004.04.18.00.43.27;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2004.04.14.04.44.22;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2004.04.14.04.34.19;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2004.04.14.00.56.02;	author henning;	state Exp;
branches;
next	1.1;

1.1
date	2004.04.13.23.41.48;	author henning;	state Exp;
branches;
next	;


desc
@@


1.18
log
@Eliminate pointless'%m' (a.k.a. hand rolled strerror()) by using fatal() and
log_warn(). Zap a couple of explicit 'syslog()' calls.
@
text
@/*	$OpenBSD: icmp.c,v 1.17 2017/02/13 22:33:39 krw Exp $ */

/*
 * Copyright (c) 1997, 1998 The Internet Software Consortium.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of The Internet Software Consortium nor the names
 *    of its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INTERNET SOFTWARE CONSORTIUM AND
 * CONTRIBUTORS ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE INTERNET SOFTWARE CONSORTIUM OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This software has been written for the Internet Software Consortium
 * by Ted Lemon <mellon@@fugue.com> in cooperation with Vixie
 * Enterprises.  To learn more about the Internet Software Consortium,
 * see ``http://www.vix.com/isc''.  To learn more about Vixie
 * Enterprises, see ``http://www.vix.com''.
 */

#include <sys/types.h>
#include <sys/socket.h>

#include <arpa/inet.h>

#include <net/if.h>

#include <netinet/ip.h>
#include <netinet/ip_icmp.h>

#include <netdb.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>

#include "dhcp.h"
#include "tree.h"
#include "dhcpd.h"
#include "log.h"

static int icmp_protocol_initialized;
static int icmp_protocol_fd;

/* Initialize the ICMP protocol. */

void
icmp_startup(int routep, void (*handler)(struct iaddr, u_int8_t *, int))
{
	struct protoent *proto;
	int protocol = 1, state;

	/* Only initialize icmp once. */
	if (icmp_protocol_initialized)
		fatalx("attempted to reinitialize icmp protocol");
	icmp_protocol_initialized = 1;

	/* Get the protocol number (should be 1). */
	if ((proto = getprotobyname("icmp")) != NULL)
		protocol = proto->p_proto;

	/* Get a raw socket for the ICMP protocol. */
	if ((icmp_protocol_fd = socket(AF_INET, SOCK_RAW, protocol)) == -1)
		fatal("unable to create icmp socket");

	/* Make sure it does routing... */
	state = 0;
	if (setsockopt(icmp_protocol_fd, SOL_SOCKET, SO_DONTROUTE,
	    &state, sizeof(state)) == -1)
		fatal("Unable to disable SO_DONTROUTE on ICMP socket");

	add_protocol("icmp", icmp_protocol_fd, icmp_echoreply,
	    (void *)handler);
}

int
icmp_echorequest(struct iaddr *addr)
{
	struct sockaddr_in to;
	struct icmp icmp;
	int status;

	if (!icmp_protocol_initialized)
		fatalx("attempt to use ICMP protocol before initialization.");

	memset(&to, 0, sizeof(to));
	to.sin_len = sizeof to;
	to.sin_family = AF_INET;
	memcpy(&to.sin_addr, addr->iabuf, sizeof to.sin_addr);	/* XXX */

	icmp.icmp_type = ICMP_ECHO;
	icmp.icmp_code = 0;
	icmp.icmp_cksum = 0;
	icmp.icmp_seq = 0;
	icmp.icmp_id = getpid() & 0xffff;

	icmp.icmp_cksum = wrapsum(checksum((unsigned char *)&icmp,
	    sizeof(icmp), 0));

	/* Send the ICMP packet... */
	status = sendto(icmp_protocol_fd, &icmp, sizeof(icmp), 0,
	    (struct sockaddr *)&to, sizeof(to));
	if (status == -1)
		log_warn("icmp_echorequest %s", inet_ntoa(to.sin_addr));

	if (status != sizeof icmp)
		return 0;
	return 1;
}

void
icmp_echoreply(struct protocol *protocol)
{
	void (*handler)(struct iaddr, u_int8_t *, int);
	struct sockaddr_in from;
	u_int8_t icbuf[1500];
	struct icmp *icfrom;
	int status, len;
	socklen_t salen;
	struct iaddr ia;

	salen = sizeof from;
	status = recvfrom(protocol->fd, icbuf, sizeof(icbuf), 0,
	    (struct sockaddr *)&from, &salen);
	if (status == -1) {
		log_warn("icmp_echoreply");
		return;
	}

	/* Probably not for us. */
	if (status < (sizeof(struct ip)) + (sizeof *icfrom))
		return;

	len = status - sizeof(struct ip);
	icfrom = (struct icmp *)(icbuf + sizeof(struct ip));

	/* Silently discard ICMP packets that aren't echoreplies. */
	if (icfrom->icmp_type != ICMP_ECHOREPLY)
		return;

	/* If we were given a second-stage handler, call it. */
	if (protocol->local) {
		handler = ((void (*)(struct iaddr, u_int8_t *, int))
		    protocol->local);
		memcpy(ia.iabuf, &from.sin_addr, sizeof from.sin_addr);
		ia.len = sizeof from.sin_addr;
		(*handler)(ia, icbuf, len);
	}
}
@


1.17
log
@Adjust some long lines.
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp.c,v 1.16 2017/02/13 19:13:14 krw Exp $ */
d83 1
a83 1
		fatalx("unable to create icmp socket: %m");
d89 1
a89 1
		fatalx("Unable to disable SO_DONTROUTE on ICMP socket: %m");
d123 1
a123 1
		log_warnx("icmp_echorequest %s: %m", inet_ntoa(to.sin_addr));
d145 1
a145 1
		log_warnx("icmp_echoreply: %m");
@


1.16
log
@Switch from old errwarn.c logging to shiny new log.[ch].

ok benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp.c,v 1.15 2016/11/15 10:49:37 mestre Exp $ */
d91 2
a92 1
	add_protocol("icmp", icmp_protocol_fd, icmp_echoreply, (void *)handler);
@


1.15
log
@Replace bzero(3) with memset(3)

"Looks good" to deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp.c,v 1.14 2016/02/06 23:50:10 krw Exp $ */
d59 1
d74 1
a74 1
		error("attempted to reinitialize icmp protocol");
d83 1
a83 1
		error("unable to create icmp socket: %m");
d89 1
a89 1
		error("Unable to disable SO_DONTROUTE on ICMP socket: %m");
d102 1
a102 1
		error("attempt to use ICMP protocol before initialization.");
d122 1
a122 1
		warning("icmp_echorequest %s: %m", inet_ntoa(to.sin_addr));
d144 1
a144 1
		warning("icmp_echoreply: %m");
@


1.14
log
@Eliminate #include inside *.h files and include only needed headers in
each *.c file.

Inspired by mention of header silliness by Edgar Pettijohn and mmcc@@
on tech@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp.c,v 1.13 2014/10/25 03:23:49 lteo Exp $ */
d103 1
a103 1
	bzero(&to, sizeof(to));
@


1.13
log
@Remove unnecessary netinet/in_systm.h include.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp.c,v 1.12 2014/05/07 13:20:47 pelikan Exp $ */
d41 7
a47 1
#include "dhcpd.h"
d50 9
@


1.12
log
@back out the previous ICMP simplifying diff, it caused livelocks.

reported by Mikolaj Kucharski, thanks!
ok krw
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp.c,v 1.11 2014/05/05 18:27:57 pelikan Exp $ */
a41 1
#include <netinet/in_systm.h>
@


1.11
log
@Don't call the ICMP handler indirectly + clean up a bit.

ok krw
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp.c,v 1.10 2008/09/15 20:38:17 claudio Exp $ */
d52 1
a52 1
icmp_startup(void)
d76 1
a76 1
	add_protocol("icmp", icmp_protocol_fd, icmp_echoreply, NULL);
d117 1
d144 8
a151 3
	memcpy(ia.iabuf, &from.sin_addr, sizeof from.sin_addr);
	ia.len = sizeof from.sin_addr;
	lease_pinged(ia, icbuf, len);
@


1.10
log
@When checking if a syscall like open(), ioctl() or writev() failed compare
directly against -1 and do not use a < 0 test. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp.c,v 1.9 2004/09/16 18:35:43 deraadt Exp $ */
d52 1
a52 1
icmp_startup(int routep, void (*handler)(struct iaddr, u_int8_t *, int))
d76 1
a76 1
	add_protocol("icmp", icmp_protocol_fd, icmp_echoreply, (void *)handler);
a116 1
	void (*handler)(struct iaddr, u_int8_t *, int);
d143 3
a145 8
	/* If we were given a second-stage handler, call it. */
	if (protocol->local) {
		handler = ((void (*)(struct iaddr, u_int8_t *, int))
		    protocol->local);
		memcpy(ia.iabuf, &from.sin_addr, sizeof from.sin_addr);
		ia.len = sizeof from.sin_addr;
		(*handler)(ia, icbuf, len);
	}
@


1.9
log
@avoid aliasing with libc functions; ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp.c,v 1.8 2004/04/22 15:22:48 henning Exp $ */
d73 1
a73 1
	    &state, sizeof(state)) < 0)
d106 1
a106 1
	if (status < 0)
d128 1
a128 1
	if (status < 0) {
@


1.8
log
@instead of using some lower 16 bits of some address on the stack that
even requires knowledge about wether the machine is 32 or 64 bit, use getpid()
for the icmp id. that is not optimal, but matches what ping does and the
way to go for now.
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp.c,v 1.7 2004/04/21 22:44:35 henning Exp $ */
d107 1
a107 1
		warn("icmp_echorequest %s: %m", inet_ntoa(to.sin_addr));
d129 1
a129 1
		warn("icmp_echoreply: %m");
@


1.7
log
@cleaning; Ryan ok
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d98 1
a98 6
#ifdef PTRSIZE_64BIT
	icmp.icmp_id = (((u_int32_t) (u_int64_t) addr) ^
	    (u_int32_t) (((u_int64_t) addr) >> 32));
#else
	icmp.icmp_id = (u_int32_t) addr;
#endif
@


1.6
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD */
d63 1
a63 2
	proto = getprotobyname("icmp");
	if (proto)
d67 1
a67 2
	icmp_protocol_fd = socket(AF_INET, SOCK_RAW, protocol);
	if (icmp_protocol_fd < 0)
d73 1
a73 1
	    (char *)&state, sizeof state) < 0)
d76 1
a76 2
	add_protocol("icmp", icmp_protocol_fd, icmp_echoreply,
	    (void *)handler);
d89 1
a89 1
	memset(&to, 0, sizeof to);
a91 1
	to.sin_port = 0;	/* unused. */
d106 1
a106 1
	    sizeof icmp, 0));
d109 2
a110 2
	status = sendto(icmp_protocol_fd, (char *)&icmp, sizeof icmp, 0,
	    (struct sockaddr *)& to, sizeof to);
d131 1
a131 1
	status = recvfrom(protocol->fd, (char *)icbuf, sizeof icbuf, 0,
@


1.5
log
@various knf; henning ok
@
text
@d1 1
a1 5
/*
 * icmp.c
 *
 * ICMP Protocol engine - for sending out pings and receiving responses.
 */
@


1.4
log
@ansi
@
text
@d3 1
a3 1
 * 
d56 1
a56 1
icmp_startup(int routep, void (*handler) (struct iaddr, u_int8_t *, int))
d79 1
a79 1
	    (char *) &state, sizeof state) < 0)
d83 1
a83 1
	    (void *) handler);
d86 1
a86 1
int 
d113 1
a113 1
	icmp.icmp_cksum = wrapsum(checksum((unsigned char *) &icmp,
d117 2
a118 2
	status = sendto(icmp_protocol_fd, (char *) &icmp, sizeof icmp, 0,
	    (struct sockaddr *) & to, sizeof to);
d127 1
a127 1
void 
d151 1
a151 1
	icfrom = (struct icmp *) (icbuf + sizeof(struct ip));
@


1.3
log
@spaces
@
text
@d1 5
a5 4
/* icmp.c

   ICMP Protocol engine - for sending out pings and receiving
   responses. */
d55 2
a56 3
void icmp_startup (routep, handler)
	int routep;
	void (*handler)(struct iaddr, u_int8_t *, int);
d59 1
a59 2
	int protocol = 1;
	int state;
d63 1
a63 1
		error ("attempted to reinitialize icmp protocol");
d67 1
a67 1
	proto = getprotobyname ("icmp");
d69 1
a69 1
		protocol = proto -> p_proto;
d72 1
a72 1
	icmp_protocol_fd = socket (AF_INET, SOCK_RAW, protocol);
d74 1
a74 1
		error ("unable to create icmp socket: %m");
d78 3
a80 3
	if (setsockopt (icmp_protocol_fd, SOL_SOCKET, SO_DONTROUTE,
			(char *)&state, sizeof state) < 0)
		error ("Unable to disable SO_DONTROUTE on ICMP socket: %m");
d82 2
a83 2
	add_protocol ("icmp", icmp_protocol_fd, icmp_echoreply,
		      (void *)handler);
d86 2
a87 2
int icmp_echorequest (addr)
	struct iaddr *addr;
d94 1
a94 1
		error ("attempt to use ICMP protocol before initialization.");
d99 2
a100 2
	to.sin_port = 0; /* unused. */
	memcpy (&to.sin_addr, addr -> iabuf, sizeof to.sin_addr); /* XXX */
d107 2
a108 2
	icmp.icmp_id = (((u_int32_t)(u_int64_t)addr) ^
	    (u_int32_t)(((u_int64_t)addr) >> 32));
d110 1
a110 1
	icmp.icmp_id = (u_int32_t)addr;
d113 2
a114 2
	icmp.icmp_cksum = wrapsum (checksum ((unsigned char *)&icmp,
					     sizeof icmp, 0));
d117 2
a118 2
	status = sendto (icmp_protocol_fd, (char *)&icmp, sizeof icmp, 0,
			 (struct sockaddr *)&to, sizeof to);
d120 1
a120 1
		warn ("icmp_echorequest %s: %m", inet_ntoa(to.sin_addr));
d127 2
a128 2
void icmp_echoreply (protocol)
	struct protocol *protocol;
d130 3
a133 2
	struct sockaddr_in from;
	u_int8_t icbuf [1500];
a136 1
	void (*handler)(struct iaddr, u_int8_t *, int);
d139 2
a140 2
	status = recvfrom (protocol -> fd, (char *)icbuf, sizeof icbuf, 0,
			  (struct sockaddr *)&from, &salen);
d142 1
a142 1
		warn ("icmp_echoreply: %m");
d147 1
a147 1
	if (status < (sizeof (struct ip)) + (sizeof *icfrom)) {
a148 1
	}
d150 2
a151 2
	len = status - sizeof (struct ip);
	icfrom = (struct icmp *)(icbuf + sizeof (struct ip));
d154 1
a154 1
	if (icfrom -> icmp_type != ICMP_ECHOREPLY) {
a155 1
	}
d158 1
a158 1
	if (protocol -> local) {
d160 2
a161 2
		    protocol -> local);
		memcpy (ia.iabuf, &from.sin_addr, sizeof from.sin_addr);
d163 1
a163 2

		(*handler) (ia, icbuf, len);
@


1.2
log
@more crap bites the dust
@
text
@d109 1
a109 1
  			(u_int32_t)(((u_int64_t)addr) >> 32));
@


1.1
log
@may the whacking begin
@
text
@d56 1
a56 1
	void (*handler) PROTO ((struct iaddr, u_int8_t *, int));
d137 1
a137 1
	void (*handler) PROTO ((struct iaddr, u_int8_t *, int));
d162 2
a163 3
		handler = ((void (*) PROTO ((struct iaddr,
					    u_int8_t *, int)))
			   protocol -> local);
@

