head	1.26;
access;
symbols
	OPENBSD_6_0:1.20.0.4
	OPENBSD_6_0_BASE:1.20
	OPENBSD_5_9:1.20.0.2
	OPENBSD_5_9_BASE:1.20
	OPENBSD_5_8:1.18.0.4
	OPENBSD_5_8_BASE:1.18
	OPENBSD_5_7:1.17.0.2
	OPENBSD_5_7_BASE:1.17
	OPENBSD_5_6:1.17.0.6
	OPENBSD_5_6_BASE:1.17
	OPENBSD_5_5:1.17.0.4
	OPENBSD_5_5_BASE:1.17
	OPENBSD_5_4:1.14.0.2
	OPENBSD_5_4_BASE:1.14
	OPENBSD_5_3:1.13.0.12
	OPENBSD_5_3_BASE:1.13
	OPENBSD_5_2:1.13.0.10
	OPENBSD_5_2_BASE:1.13
	OPENBSD_5_1_BASE:1.13
	OPENBSD_5_1:1.13.0.8
	OPENBSD_5_0:1.13.0.6
	OPENBSD_5_0_BASE:1.13
	OPENBSD_4_9:1.13.0.4
	OPENBSD_4_9_BASE:1.13
	OPENBSD_4_8:1.13.0.2
	OPENBSD_4_8_BASE:1.13
	OPENBSD_4_7:1.12.0.2
	OPENBSD_4_7_BASE:1.12
	OPENBSD_4_6:1.11.0.14
	OPENBSD_4_6_BASE:1.11
	OPENBSD_4_5:1.11.0.10
	OPENBSD_4_5_BASE:1.11
	OPENBSD_4_4:1.11.0.8
	OPENBSD_4_4_BASE:1.11
	OPENBSD_4_3:1.11.0.6
	OPENBSD_4_3_BASE:1.11
	OPENBSD_4_2:1.11.0.4
	OPENBSD_4_2_BASE:1.11
	OPENBSD_4_1:1.11.0.2
	OPENBSD_4_1_BASE:1.11
	OPENBSD_4_0:1.8.0.2
	OPENBSD_4_0_BASE:1.8
	OPENBSD_3_9:1.7.0.6
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.7.0.4
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.2
	OPENBSD_3_7_BASE:1.7
	OPENBSD_3_6:1.6.0.2
	OPENBSD_3_6_BASE:1.6;
locks; strict;
comment	@ * @;


1.26
date	2017.02.16.00.24.43;	author krw;	state Exp;
branches;
next	1.25;
commitid	5UCb9jKiZwXsFyNg;

1.25
date	2017.02.13.23.04.05;	author krw;	state Exp;
branches;
next	1.24;
commitid	amfLXbU964CBXnkr;

1.24
date	2017.02.13.22.33.39;	author krw;	state Exp;
branches;
next	1.23;
commitid	aD6aChUv7GEv3CLZ;

1.23
date	2017.02.13.19.13.14;	author krw;	state Exp;
branches;
next	1.22;
commitid	syYFt6P4XI7prXRF;

1.22
date	2017.02.11.16.12.36;	author krw;	state Exp;
branches;
next	1.21;
commitid	eWsyZlm9X0T2fxXC;

1.21
date	2016.08.27.01.26.22;	author guenther;	state Exp;
branches;
next	1.20;
commitid	mLhDPn5m6RI81k8n;

1.20
date	2016.02.06.23.50.10;	author krw;	state Exp;
branches;
next	1.19;
commitid	8GMcSAoPYCa1rXN3;

1.19
date	2015.12.11.14.09.48;	author krw;	state Exp;
branches;
next	1.18;
commitid	Zwe9vQYqVati9SMC;

1.18
date	2015.05.18.17.51.21;	author krw;	state Exp;
branches;
next	1.17;
commitid	SjQKXPdyGuKrZRc7;

1.17
date	2013.12.18.20.37.04;	author krw;	state Exp;
branches;
next	1.16;

1.16
date	2013.12.05.22.31.35;	author krw;	state Exp;
branches;
next	1.15;

1.15
date	2013.11.22.04.47.40;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2013.04.17.19.26.10;	author krw;	state Exp;
branches;
next	1.13;

1.13
date	2010.03.27.14.11.38;	author krw;	state Exp;
branches;
next	1.12;

1.12
date	2009.09.01.08.42.31;	author reyk;	state Exp;
branches;
next	1.11;

1.11
date	2007.02.26.00.49.53;	author stevesk;	state Exp;
branches;
next	1.10;

1.10
date	2006.11.22.21.35.56;	author stevesk;	state Exp;
branches;
next	1.9;

1.9
date	2006.11.22.18.07.52;	author stevesk;	state Exp;
branches;
next	1.8;

1.8
date	2006.04.18.19.18.32;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2004.09.16.18.35.43;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2004.05.04.20.28.40;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2004.04.18.00.43.27;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2004.04.15.22.22.21;	author hshoexer;	state Exp;
branches;
next	1.3;

1.3
date	2004.04.14.01.27.49;	author henning;	state Exp;
branches;
next	1.2;

1.2
date	2004.04.13.23.57.49;	author henning;	state Exp;
branches;
next	1.1;

1.1
date	2004.04.13.23.41.49;	author henning;	state Exp;
branches;
next	;


desc
@@


1.26
log
@Bring parse_warn() into the log.[ch] 21st century and adopt the "^"
placement logic from dhclient.
@
text
@/*	$OpenBSD: parse.c,v 1.25 2017/02/13 23:04:05 krw Exp $	*/

/* Common parser code for dhcpd and dhclient. */

/*
 * Copyright (c) 1995, 1996, 1997, 1998 The Internet Software Consortium.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of The Internet Software Consortium nor the names
 *    of its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INTERNET SOFTWARE CONSORTIUM AND
 * CONTRIBUTORS ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE INTERNET SOFTWARE CONSORTIUM OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This software has been written for the Internet Software Consortium
 * by Ted Lemon <mellon@@fugue.com> in cooperation with Vixie
 * Enterprises.  To learn more about the Internet Software Consortium,
 * see ``http://www.vix.com/isc''.  To learn more about Vixie
 * Enterprises, see ``http://www.vix.com''.
 */

#include <sys/types.h>
#include <sys/socket.h>

#include <net/if.h>

#include <netinet/in.h>

#include <ctype.h>
#include <errno.h>
#include <stdarg.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <syslog.h>
#include <time.h>
#include <unistd.h>

#include "dhcp.h"
#include "tree.h"
#include "dhcpd.h"
#include "dhctoken.h"
#include "log.h"

/*
 * Skip to the semicolon ending the current statement.   If we encounter
 * braces, the matching closing brace terminates the statement.   If we
 * encounter a right brace but haven't encountered a left brace, return
 * leaving the brace in the token buffer for the caller.   If we see a
 * semicolon and haven't seen a left brace, return.   This lets us skip
 * over:
 *
 *	statement;
 *	statement foo bar { }
 *	statement foo bar { statement { } }
 *	statement}
 *
 *	...et cetera.
 */
void
skip_to_semi(FILE *cfile)
{
	int		 token;
	char		*val;
	int		 brace_count = 0;

	do {
		token = peek_token(&val, cfile);
		if (token == '}') {
			if (brace_count) {
				token = next_token(&val, cfile);
				if (!--brace_count)
					return;
			} else
				return;
		} else if (token == '{') {
			brace_count++;
		} else if (token == ';' && !brace_count) {
			token = next_token(&val, cfile);
			return;
		} else if (token == '\n') {
			/*
			 * EOL only happens when parsing
			 * /etc/resolv.conf, and we treat it like a
			 * semicolon because the resolv.conf file is
			 * line-oriented.
			 */
			token = next_token(&val, cfile);
			return;
		}
		token = next_token(&val, cfile);
	} while (token != EOF);
}

int
parse_semi(FILE *cfile)
{
	int token;
	char *val;

	token = next_token(&val, cfile);
	if (token != ';') {
		parse_warn("semicolon expected.");
		skip_to_semi(cfile);
		return (0);
	}
	return (1);
}

/*
 * string-parameter :== STRING SEMI
 */
char *
parse_string(FILE *cfile)
{
	char *val, *s;
	int token;

	token = next_token(&val, cfile);
	if (token != TOK_STRING) {
		parse_warn("filename must be a string");
		skip_to_semi(cfile);
		return (NULL);
	}
	s = strdup(val);
	if (s == NULL)
		fatalx("no memory for string %s.", val);

	if (!parse_semi(cfile)) {
		free(s);
		return (NULL);
	}
	return (s);
}

/*
 * hostname :== identifier | hostname DOT identifier
 */
char *
parse_host_name(FILE *cfile)
{
	char *val, *s, *t;
	int token, len = 0;
	pair c = NULL;

	/* Read a dotted hostname... */
	do {
		/* Read a token, which should be an identifier. */
		token = next_token(&val, cfile);
		if (!is_identifier(token)) {
			parse_warn("expecting an identifier in hostname");
			skip_to_semi(cfile);
			return (NULL);
		}
		/* Store this identifier... */
		s = strdup(val);
		if (s == NULL)
			fatalx("can't allocate temp space for hostname.");
		c = cons((caddr_t) s, c);
		len += strlen(s) + 1;
		/*
		 * Look for a dot; if it's there, keep going, otherwise
		 * we're done.
		 */
		token = peek_token(&val, cfile);
		if (token == '.')
			token = next_token(&val, cfile);
	} while (token == '.');

	/* Assemble the hostname together into a string. */
	if (!(s = malloc(len)))
		fatalx("can't allocate space for hostname.");
	t = s + len;
	*--t = '\0';
	while (c) {
		pair cdr = c->cdr;
		int l = strlen((char *)c->car);

		t -= l;
		memcpy(t, (char *)c->car, l);
		/* Free up temp space. */
		free(c->car);
		free(c);
		c = cdr;
		if (t != s)
			*--t = '.';
	}
	return (s);
}

/*
 * hardware-parameter :== HARDWARE ETHERNET csns SEMI
 * csns :== NUMBER | csns COLON NUMBER
 */
void
parse_hardware_param(FILE *cfile, struct hardware *hardware)
{
	char *val;
	int token, hlen;
	unsigned char *t;

	token = next_token(&val, cfile);
	switch (token) {
	case TOK_ETHERNET:
		hardware->htype = HTYPE_ETHER;
		break;
	case TOK_IPSEC_TUNNEL:
		hardware->htype = HTYPE_IPSEC_TUNNEL;
		break;
	default:
		parse_warn("expecting a network hardware type");
		skip_to_semi(cfile);
		return;
	}

	/*
	 * Parse the hardware address information.   Technically, it
	 * would make a lot of sense to restrict the length of the data
	 * we'll accept here to the length of a particular hardware
	 * address type.   Unfortunately, there are some broken clients
	 * out there that put bogus data in the chaddr buffer, and we
	 * accept that data in the lease file rather than simply failing
	 * on such clients.   Yuck.
	 */
	hlen = 0;
	t = parse_numeric_aggregate(cfile, NULL, &hlen, ':', 16, 8);
	if (!t)
		return;
	if (hlen > sizeof(hardware->haddr)) {
		free(t);
		parse_warn("hardware address too long");
	} else {
		hardware->hlen = hlen;
		memcpy((unsigned char *)&hardware->haddr[0], t,
		    hardware->hlen);
		if (hlen < sizeof(hardware->haddr))
			memset(&hardware->haddr[hlen], 0,
			    sizeof(hardware->haddr) - hlen);
		free(t);
	}

	token = next_token(&val, cfile);
	if (token != ';') {
		parse_warn("expecting semicolon.");
		skip_to_semi(cfile);
	}
}

/*
 * lease-time :== NUMBER SEMI
 */
void
parse_lease_time(FILE *cfile, time_t *timep)
{
	const char *errstr;
	char *val;
	uint32_t value;
	int token;

	token = next_token(&val, cfile);

	value = strtonum(val, 0, UINT32_MAX, &errstr);
	if (errstr) {
		parse_warn("lease time is %s: %s", errstr, val);
		skip_to_semi(cfile);
		return;
	}

	*timep = value;

	parse_semi(cfile);
}

/*
 * No BNF for numeric aggregates - that's defined by the caller.  What
 * this function does is to parse a sequence of numbers separated by the
 * token specified in separator.  If max is zero, any number of numbers
 * will be parsed; otherwise, exactly max numbers are expected.  Base
 * and size tell us how to internalize the numbers once they've been
 * tokenized.
 */
unsigned char *
parse_numeric_aggregate(FILE *cfile, unsigned char *buf, int *max,
    int separator, int base, int size)
{
	char *val, *t;
	int token, count = 0;
	unsigned char *bufp = buf, *s = NULL;
	pair c = NULL;

	if (!bufp && *max) {
		bufp = malloc(*max * size / 8);
		if (!bufp)
			fatalx("can't allocate space for numeric aggregate");
	} else
		s = bufp;

	do {
		if (count) {
			token = peek_token(&val, cfile);
			if (token != separator) {
				if (!*max)
					break;
				if (token != '{' && token != '}')
					token = next_token(&val, cfile);
				parse_warn("too few numbers.");
				if (token != ';')
					skip_to_semi(cfile);
				return (NULL);
			}
			token = next_token(&val, cfile);
		}
		token = next_token(&val, cfile);

		if (token == EOF) {
			parse_warn("unexpected end of file");
			break;
		}
		if (token != TOK_NUMBER && token != TOK_NUMBER_OR_NAME) {
			parse_warn("expecting numeric value.");
			skip_to_semi(cfile);
			return (NULL);
		}
		/*
		 * If we can, convert the number now; otherwise, build a
		 * linked list of all the numbers.
		 */
		if (s) {
			convert_num(s, val, base, size);
			s += size / 8;
		} else {
			t = strdup(val);
			if (t == NULL)
				fatalx("no temp space for number.");
			c = cons(t, c);
		}
	} while (++count != *max);

	/* If we had to cons up a list, convert it now. */
	if (c) {
		bufp = malloc(count * size / 8);
		if (!bufp)
			fatalx("can't allocate space for numeric aggregate.");
		s = bufp + count - size / 8;
		*max = count;
	}
	while (c) {
		pair		cdr = c->cdr;
		convert_num(s, (char *)c->car, base, size);
		s -= size / 8;
		/* Free up temp space. */
		free(c->car);
		free(c);
		c = cdr;
	}
	return (bufp);
}

void
convert_num(unsigned char *buf, char *str, int base, int size)
{
	int negative = 0, tval, max;
	u_int32_t val = 0;
	char *ptr = str;

	if (*ptr == '-') {
		negative = 1;
		ptr++;
	}

	/* If base wasn't specified, figure it out from the data. */
	if (!base) {
		if (ptr[0] == '0') {
			if (ptr[1] == 'x') {
				base = 16;
				ptr += 2;
			} else if (isascii((unsigned char)ptr[1]) &&
			    isdigit((unsigned char)ptr[1])) {
				base = 8;
				ptr += 1;
			} else
				base = 10;
		} else
			base = 10;
	}

	do {
		tval = *ptr++;
		/* XXX assumes ASCII... */
		if (tval >= 'a')
			tval = tval - 'a' + 10;
		else if (tval >= 'A')
			tval = tval - 'A' + 10;
		else if (tval >= '0')
			tval -= '0';
		else {
			log_warnx("Bogus number: %s.", str);
			break;
		}
		if (tval >= base) {
			log_warnx("Bogus number: %s: digit %d not in base %d",
			    str, tval, base);
			break;
		}
		val = val * base + tval;
	} while (*ptr);

	if (negative)
		max = (1 << (size - 1));
	else
		max = (1 << (size - 1)) + ((1 << (size - 1)) - 1);
	if (val > max) {
		switch (base) {
		case 8:
			log_warnx("value %s%o exceeds max (%d) for precision.",
			    negative ? "-" : "", val, max);
			break;
		case 16:
			log_warnx("value %s%x exceeds max (%d) for precision.",
			    negative ? "-" : "", val, max);
			break;
		default:
			log_warnx("value %s%u exceeds max (%d) for precision.",
			    negative ? "-" : "", val, max);
			break;
		}
	}

	if (negative) {
		switch (size) {
		case 8:
			*buf = -(unsigned long)val;
			break;
		case 16:
			putShort(buf, -(unsigned long)val);
			break;
		case 32:
			putLong(buf, -(unsigned long)val);
			break;
		default:
			log_warnx("Unexpected integer size: %d", size);
			break;
		}
	} else {
		switch (size) {
		case 8:
			*buf = (u_int8_t)val;
			break;
		case 16:
			putUShort(buf, (u_int16_t)val);
			break;
		case 32:
			putULong(buf, val);
			break;
		default:
			log_warnx("Unexpected integer size: %d", size);
			break;
		}
	}
}

/*
 * date :== NUMBER NUMBER SLASH NUMBER SLASH NUMBER
 *		NUMBER COLON NUMBER COLON NUMBER UTC SEMI
 *
 * Dates are always in UTC; first number is day of week; next is
 * year/month/day; next is hours:minutes:seconds on a 24-hour
 * clock.
 */
time_t
parse_date(FILE *cfile)
{
	struct tm tm;
	char timestr[26]; /* "w yyyy/mm/dd hh:mm:ss UTC" */
	char *val, *p;
	size_t n;
	time_t guess;
	int token;

	memset(timestr, 0, sizeof(timestr));

	do {
		token = peek_token(NULL, cfile);
		switch (token) {
		case TOK_NAME:
		case TOK_NUMBER:
		case TOK_NUMBER_OR_NAME:
		case '/':
		case ':':
			token = next_token(&val, cfile);
			n = strlcat(timestr, val, sizeof(timestr));
			if (n >= sizeof(timestr)) {
				/* XXX Will break after year 9999! */
				parse_warn("time string too long");
				skip_to_semi(cfile);
				return (0);
			}
			break;
		case';':
			break;
		default:
			parse_warn("invalid time string");
			skip_to_semi(cfile);
			return (0);
		}
	} while (token != ';');

	parse_semi(cfile);

	memset(&tm, 0, sizeof(tm));	/* 'cuz strptime ignores tm_isdt. */
	p = strptime(timestr, DB_TIMEFMT, &tm);
	if (p == NULL || *p != '\0') {
		p = strptime(timestr, OLD_DB_TIMEFMT, &tm);
		if (p == NULL || *p != '\0') {
			parse_warn("unparseable time string");
			return (0);
		}
	}

	guess = timegm(&tm);
	if (guess == -1) {
		parse_warn("time could not be represented");
		return (0);
	}

	return (guess);
}

int warnings_occurred;

int
parse_warn(char *fmt, ...)
{
	static char fbuf[1024];
	static char mbuf[1024];
	static char spaces[81];
	va_list list;
	int i;

	snprintf(fbuf, sizeof(fbuf), "%s line %d: %s", tlname, lexline, mbuf);
	va_start(list, fmt);
	vsnprintf(mbuf, sizeof(mbuf), fbuf, list);
	va_end(list);

	log_warnx("%s", mbuf);
	log_warnx("%s", token_line);
	if (lexchar < sizeof(spaces)) {
		memset(spaces, 0, sizeof(spaces));
		for (i = 0; i < lexchar - 1; i++) {
			if (token_line[i] == '\t')
				spaces[i] = '\t';
			else
				spaces[i] = ' ';
		}
	}
	log_warnx("%s^", spaces);

	warnings_occurred = 1;

	return (0);
}
@


1.25
log
@Eliminate pointless'%m' (a.k.a. hand rolled strerror()) by using fatal() and
log_warn(). Zap a couple of explicit 'syslog()' calls.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.24 2017/02/13 22:33:39 krw Exp $	*/
d558 1
d560 1
a560 5
	static char spaces[] =
	    "                                        "
	    "                                        "; /* 80 spaces */
	struct iovec iov[6];
	size_t iovcnt;
d567 9
a575 16
	if (log_perror) {
		iov[0].iov_base = mbuf;
		iov[0].iov_len = strlen(mbuf);
		iov[1].iov_base = "\n";
		iov[1].iov_len = 1;
		iov[2].iov_base = token_line;
		iov[2].iov_len = strlen(token_line);
		iov[3].iov_base = "\n";
		iov[3].iov_len = 1;
		iovcnt = 4;
		if (lexchar < 81) {
			iov[4].iov_base = spaces;
			iov[4].iov_len = lexchar - 1;
			iov[5].iov_base = "^\n";
			iov[5].iov_len = 2;
			iovcnt += 2;
a576 6
		writev(STDERR_FILENO, iov, iovcnt);
	} else {
		log_warnx("%s", mbuf);
		log_warnx("%s", token_line);
		if (lexchar < 81)
			log_warnx("%*c", lexchar, '^');
d578 1
@


1.24
log
@Adjust some long lines.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.23 2017/02/13 19:13:14 krw Exp $	*/
a550 37
/*
 * Find %m in the input string and substitute an error message string.
 */
void
do_percentm(char *obuf, size_t size, char *ibuf)
{
	char ch;
	char *s = ibuf;
	char *t = obuf;
	size_t prlen;
	size_t fmt_left;
	int saved_errno = errno;

	/*
	 * We wouldn't need this mess if printf handled %m, or if
	 * strerror() had been invented before syslog_r().
	 */
	for (fmt_left = size; (ch = *s); ++s) {
		if (ch == '%' && s[1] == 'm') {
			++s;
			prlen = snprintf(t, fmt_left, "%s",
			    strerror(saved_errno));
			if (prlen == -1)
				prlen = 0;
			if (prlen >= fmt_left)
				prlen = fmt_left - 1;
			t += prlen;
			fmt_left -= prlen;
		} else {
			if (fmt_left > 1) {
				*t++ = ch;
				fmt_left--;
			}
		}
	}
	*t = '\0';
}
a564 1
	do_percentm(mbuf, sizeof(mbuf), fmt);
@


1.23
log
@Switch from old errwarn.c logging to shiny new log.[ch].

ok benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.22 2017/02/11 16:12:36 krw Exp $	*/
d256 2
a257 1
		memcpy((unsigned char *)&hardware->haddr[0], t, hardware->hlen);
@


1.22
log
@Move parse_warning() into parse.c to prepare to replace errwarn.c
with standard daemon log.[ch].

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.21 2016/08/27 01:26:22 guenther Exp $	*/
d51 1
d65 1
d149 1
a149 1
		error("no memory for string %s.", val);
d180 1
a180 1
			error("can't allocate temp space for hostname.");
d194 1
a194 1
		error("can't allocate space for hostname.");
d315 1
a315 1
			error("can't allocate space for numeric aggregate");
d355 1
a355 1
				error("no temp space for number.");
d364 1
a364 1
			error("can't allocate space for numeric aggregate.");
d418 1
a418 1
			warning("Bogus number: %s.", str);
d422 1
a422 1
			warning("Bogus number: %s: digit %d not in base %d",
d436 1
a436 1
			warning("value %s%o exceeds max (%d) for precision.",
d440 1
a440 1
			warning("value %s%x exceeds max (%d) for precision.",
d444 1
a444 1
			warning("value %s%u exceeds max (%d) for precision.",
d462 1
a462 1
			warning("Unexpected integer size: %d", size);
d477 1
a477 1
			warning("Unexpected integer size: %d", size);
d550 39
d592 2
a593 2
	extern char mbuf[1024];
	extern char fbuf[1024];
d626 2
a627 2
		syslog_r(log_priority | LOG_ERR, &sdata, "%s", mbuf);
		syslog_r(log_priority | LOG_ERR, &sdata, "%s", token_line);
d629 1
a629 2
			syslog_r(log_priority | LOG_ERR, &sdata, "%*c", lexchar,
			    '^');
@


1.21
log
@Pull in <time.h> for one or more of gmtime, strftime, strptime, time,
timegm, and tzset

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.20 2016/02/06 23:50:10 krw Exp $	*/
d51 1
d56 1
d58 1
d546 49
@


1.20
log
@Eliminate #include inside *.h files and include only needed headers in
each *.c file.

Inspired by mention of header silliness by Edgar Pettijohn and mmcc@@
on tech@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.19 2015/12/11 14:09:48 krw Exp $	*/
d55 1
@


1.19
log
@Actually use default-lease-time, max-lease-time, bootp-lease-length
specified in dhcpd.conf. Broken in -r1.18.

Problem noted by Arne on bugs@@, identical fix independently developed
by Serguey Parkhomovsky.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.18 2015/05/18 17:51:21 krw Exp $	*/
d43 2
a44 1
#include  <stdint.h>
d46 12
@


1.18
log
@Tweak parsing so that hostnames starting with 0-9 are accepted.

Reported long ago by matthieu@@. Also Jacob Berkman via the lists.

Tests and suggestions from Jacob and Matthieu.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.17 2013/12/18 20:37:04 krw Exp $	*/
d270 2
@


1.17
log
@Two 'break;'s in a row seems excessive.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.16 2013/12/05 22:31:35 krw Exp $	*/
d43 2
d153 1
a153 1
		if (!is_identifier(token) && token != TOK_NUMBER) {
d257 1
d263 4
a266 2
	if (token != TOK_NUMBER) {
		parse_warn("Expecting numeric lease time");
a269 3
	convert_num((unsigned char *)&value, val, 10, 32);
	/* Unswap the number - convert_num returns stuff in NBO. */
	*timep = ntohl(value);	/* XXX */
d319 1
a319 3
		/* Allow NUMBER_OR_NAME if base is 16. */
		if (token != TOK_NUMBER &&
		    (base != 16 || token != TOK_NUMBER_OR_NAME)) {
d487 1
@


1.16
log
@Stop pretending we still support FDDI or token ring hardware types.

idea ok deraadt@@ matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.15 2013/11/22 04:47:40 deraadt Exp $	*/
a206 1
		break;
@


1.15
log
@unsigned char cast for some ctype calls
ok krw
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.14 2013/04/17 19:26:10 krw Exp $	*/
a207 5
	case TOK_TOKEN_RING:
		hardware->htype = HTYPE_IEEE802;
		break;
	case TOK_FDDI:
		hardware->htype = HTYPE_FDDI;
@


1.14
log
@Replace hand-rolled date printing/parsing code with strftime()/strptime().
Use timegm() because all the dates are in UTC and the 'standard'
routines can't handle the truth.

Remove some 'time_t is 32bits' assumptions.

Print 'UTC' at the end of dates in the leases file, rather than
mentioning that all dates are UTC in a comment at the top of the
file.

Feedback and suggestions from guenther@@, kettenis@@, otto@@, tedu@@,
deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.13 2010/03/27 14:11:38 krw Exp $	*/
d383 2
a384 1
			} else if (isascii(ptr[1]) && isdigit(ptr[1])) {
@


1.13
log
@malloc/strlcpy -> strdup. Use consistent idiom.

ok (as part of larger diff) blambert@@ kettenis@@ stsp@@ zinovik@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.12 2009/09/01 08:42:31 reyk Exp $	*/
d262 1
d271 1
a271 1
	convert_num((unsigned char *)timep, val, 10, 32);
d273 1
a273 1
	*timep = ntohl(*timep);	/* XXX */
d469 1
a469 1
 *		NUMBER COLON NUMBER COLON NUMBER SEMI
d471 1
a471 1
 * Dates are always in GMT; first number is day of week; next is
a477 3
	static int months[11] = { 31, 59, 90, 120, 151, 181,
	    212, 243, 273, 304, 334 };
	int guess, token;
d479 5
a483 1
	char *val;
d485 1
a485 9
	/* Day of week... */
	token = next_token(&val, cfile);
	if (token != TOK_NUMBER) {
		parse_warn("numeric day of week expected.");
		if (token != ';')
			skip_to_semi(cfile);
		return (0);
	}
	tm.tm_wday = atoi(val);
d487 20
a506 5
	/* Year... */
	token = next_token(&val, cfile);
	if (token != TOK_NUMBER) {
		parse_warn("numeric year expected.");
		if (token != ';')
d508 3
a510 5
		return (0);
	}
	tm.tm_year = atoi(val);
	if (tm.tm_year > 1900)
		tm.tm_year -= 1900;
d512 1
a512 8
	/* Slash separating year from month... */
	token = next_token(&val, cfile);
	if (token != '/') {
		parse_warn("expected slash separating year from month.");
		if (token != ';')
			skip_to_semi(cfile);
		return (0);
	}
d514 8
a521 7
	/* Month... */
	token = next_token(&val, cfile);
	if (token != TOK_NUMBER) {
		parse_warn("numeric month expected.");
		if (token != ';')
			skip_to_semi(cfile);
		return (0);
a522 1
	tm.tm_mon = atoi(val) - 1;
d524 3
a526 6
	/* Slash separating month from day... */
	token = next_token(&val, cfile);
	if (token != '/') {
		parse_warn("expected slash separating month from day.");
		if (token != ';')
			skip_to_semi(cfile);
a529 90
	/* Day... */
	token = next_token(&val, cfile);
	if (token != TOK_NUMBER) {
		parse_warn("numeric day of month expected.");
		if (token != ';')
			skip_to_semi(cfile);
		return (0);
	}
	tm.tm_mday = atoi(val);

	/* Hour... */
	token = next_token(&val, cfile);
	if (token != TOK_NUMBER) {
		parse_warn("numeric hour expected.");
		if (token != ';')
			skip_to_semi(cfile);
		return (0);
	}
	tm.tm_hour = atoi(val);

	/* Colon separating hour from minute... */
	token = next_token(&val, cfile);
	if (token != ':') {
		parse_warn("expected colon separating hour from minute.");
		if (token != ';')
			skip_to_semi(cfile);
		return (0);
	}

	/* Minute... */
	token = next_token(&val, cfile);
	if (token != TOK_NUMBER) {
		parse_warn("numeric minute expected.");
		if (token != ';')
			skip_to_semi(cfile);
		return (0);
	}
	tm.tm_min = atoi(val);

	/* Colon separating minute from second... */
	token = next_token(&val, cfile);
	if (token != ':') {
		parse_warn("expected colon separating minute from second.");
		if (token != ';')
			skip_to_semi(cfile);
		return (0);
	}

	/* Second... */
	token = next_token(&val, cfile);
	if (token != TOK_NUMBER) {
		parse_warn("numeric second expected.");
		if (token != ';')
			skip_to_semi(cfile);
		return (0);
	}
	tm.tm_sec = atoi(val);
	tm.tm_isdst = 0;

	/* XXX: We assume that mktime does not use tm_yday. */
	tm.tm_yday = 0;

	/* Make sure the date ends in a semicolon... */
	token = next_token(&val, cfile);
	if (token != ';') {
		parse_warn("semicolon expected.");
		skip_to_semi(cfile);
		return (0);
	}

	/* Guess the time value... */
	guess = ((((((365 * (tm.tm_year - 70) +	/* Days in years since '70 */
	    (tm.tm_year - 69) / 4 +	/* Leap days since '70 */
	    (tm.tm_mon			/* Days in months this year */
	    ? months[tm.tm_mon - 1] : 0) +
	    (tm.tm_mon > 1 &&		/* Leap day this year */
	    !((tm.tm_year - 72) & 3)) +
	    tm.tm_mday - 1) * 24) +	/* Day of month */
	    tm.tm_hour) * 60) + tm.tm_min) * 60) + tm.tm_sec;

	/*
	 * This guess could be wrong because of leap seconds or other
	 * weirdness we don't know about that the system does.   For
	 * now, we're just going to accept the guess, but at some point
	 * it might be nice to do a successive approximation here to get
	 * an exact value.   Even if the error is small, if the server
	 * is restarted frequently (and thus the lease database is
	 * reread), the error could accumulate into something
	 * significant.
	 */
@


1.12
log
@Echo back the Relay Agent Information option if present (RFC 3046).
Also add support for the "ipsec-tunnel" hardware type as described in
RFC 3456.

ok henning@@ krw@@ (but needs more testing from others)
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.11 2007/02/26 00:49:53 stevesk Exp $	*/
d126 2
a127 2
	s = malloc(strlen(val) + 1);
	if (!s)
a128 1
	strlcpy(s, val, strlen(val) + 1);
d157 2
a158 1
		if (!(s = malloc(strlen(val) + 1)))
a159 1
		strlcpy(s, val, strlen(val) + 1);
d337 2
a338 2
			t = malloc(strlen(val) + 1);
			if (!t)
a339 1
			strlcpy(t, val, strlen(val) + 1);
@


1.11
log
@don't leak memory, from dhclient; ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.10 2006/11/22 21:35:56 stevesk Exp $	*/
d214 3
@


1.10
log
@sync dhclient and dhcpd parse.c areas where we can.
mainly formatting, whitespace; ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.9 2006/11/22 18:07:52 stevesk Exp $	*/
d131 2
a132 1
	if (!parse_semi(cfile))
d134 1
@


1.9
log
@fix some warning messages and comments in parse_date(); ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.8 2006/04/18 19:18:32 deraadt Exp $	*/
d365 1
a366 1
	u_int32_t val = 0;
d372 1
d387 1
d429 1
d472 1
a472 1
parse_date(FILE * cfile)
d474 3
a477 1
	int guess, token;
a478 2
	static int months[11] = {31, 59, 90, 120, 151, 181,
	    212, 243, 273, 304, 334};
d486 1
a486 1
		return (NULL);
d496 1
a496 1
		return (NULL);
d508 1
a508 1
		return (NULL);
d510 1
d517 1
a517 1
		return (NULL);
d527 1
a527 1
		return (NULL);
d529 1
d536 1
a536 1
		return (NULL);
d546 1
a546 1
		return (NULL);
d556 1
a556 1
		return (NULL);
d558 1
d565 1
a565 1
		return (NULL);
d575 1
a575 1
		return (NULL);
d577 2
a578 1
	/* second... */
d584 1
a584 1
		return (NULL);
d597 1
a597 1
		return (NULL);
d599 1
@


1.8
log
@cleanup keyword lookup for the lexer, and remove keywords not valid in
either dhclient or dhcpd context; tested by many
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.7 2004/09/16 18:35:43 deraadt Exp $	*/
d525 1
a525 1
	/* Month... */
d566 1
a566 1
		parse_warn("expected colon separating hour from minute.");
d571 1
a571 1
	/* Minute... */
d574 1
a574 1
		parse_warn("numeric minute expected.");
@


1.7
log
@avoid aliasing with libc functions; ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.6 2004/05/04 20:28:40 deraadt Exp $	*/
d70 1
a70 1
		if (token == RBRACE) {
d77 1
a77 1
		} else if (token == LBRACE) {
d79 1
a79 1
		} else if (token == SEMI && !brace_count) {
d103 1
a103 1
	if (token != SEMI) {
d121 1
a121 1
	if (token != STRING) {
d150 1
a150 1
		if (!is_identifier(token) && token != NUMBER) {
d166 1
a166 1
		if (token == DOT)
d168 1
a168 1
	} while (token == DOT);
d204 1
a204 1
	case ETHERNET:
d207 1
a207 1
	case TOKEN_RING:
d210 1
a210 1
	case FDDI:
d229 1
a229 1
	t = parse_numeric_aggregate(cfile, NULL, &hlen, COLON, 16, 8);
d245 1
a245 1
	if (token != SEMI) {
d261 1
a261 1
	if (token != NUMBER) {
d303 1
a303 1
				if (token != RBRACE && token != LBRACE)
d306 1
a306 1
				if (token != SEMI)
d319 2
a320 2
		if (token != NUMBER &&
		    (base != 16 || token != NUMBER_OR_NAME)) {
d479 1
a479 1
	if (token != NUMBER) {
d481 1
a481 1
		if (token != SEMI)
d489 1
a489 1
	if (token != NUMBER) {
d491 1
a491 1
		if (token != SEMI)
d501 1
a501 1
	if (token != SLASH) {
d503 1
a503 1
		if (token != SEMI)
d509 1
a509 1
	if (token != NUMBER) {
d511 1
a511 1
		if (token != SEMI)
d519 1
a519 1
	if (token != SLASH) {
d521 1
a521 1
		if (token != SEMI)
d527 1
a527 1
	if (token != NUMBER) {
d529 1
a529 1
		if (token != SEMI)
d537 1
a537 1
	if (token != NUMBER) {
d539 1
a539 1
		if (token != SEMI)
d547 1
a547 1
	if (token != COLON) {
d549 1
a549 1
		if (token != SEMI)
d555 1
a555 1
	if (token != NUMBER) {
d557 1
a557 1
		if (token != SEMI)
d565 1
a565 1
	if (token != COLON) {
d567 1
a567 1
		if (token != SEMI)
d573 1
a573 1
	if (token != NUMBER) {
d575 1
a575 1
		if (token != SEMI)
d587 1
a587 1
	if (token != SEMI) {
@


1.6
log
@remove things not used, spotted by lint mostly; ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.5 2004/04/18 00:43:27 deraadt Exp $	*/
d396 1
a396 1
			warn("Bogus number: %s.", str);
d400 1
a400 1
			warn("Bogus number: %s: digit %d not in base %d",
d414 1
a414 1
			warn("value %s%o exceeds max (%d) for precision.",
d418 1
a418 1
			warn("value %s%x exceeds max (%d) for precision.",
d422 1
a422 1
			warn("value %s%u exceeds max (%d) for precision.",
d439 1
a439 1
			warn("Unexpected integer size: %d", size);
d454 1
a454 1
			warn("Unexpected integer size: %d", size);
@


1.5
log
@various knf; henning ok
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.4 2004/04/15 22:22:21 hshoexer Exp $	*/
a188 10
}

int
parse_ip_addr(FILE *cfile, struct iaddr *addr)
{
	addr->len = 4;
	if (parse_numeric_aggregate(cfile, addr->iabuf,
	    &addr->len, DOT, 10, 8))
		return (1);
	return (0);
@


1.4
log
@knf + ansi

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.3 2004/04/14 01:27:49 henning Exp $	*/
d46 1
a46 1
/* 
d99 2
a100 2
	int             token;
	char           *val;
d117 2
a118 3
	char           *val;
	int             token;
	char           *s;
d142 3
a144 6
	char           *val;
	int             token;
	int             len = 0;
	char           *s;
	char           *t;
	pair            c = NULL;
d176 3
a178 2
		pair            cdr = c->cdr;
		int             l = strlen((char *)c->car);
d208 3
a210 4
	char           *val;
	int             token;
	int             hlen;
	unsigned char  *t;
d247 1
a247 2
		memcpy((unsigned char *)&hardware->haddr[0], t,
		     hardware->hlen);
d267 2
a268 2
	char           *val;
	int             token;
d295 4
a298 6
	char           *val;
	int             token;
	unsigned char  *bufp = buf, *s = NULL;
	char           *t;
	int             count = 0;
	pair            c = NULL;
d374 3
a376 5
	char           *ptr = str;
	int             negative = 0;
	u_int32_t       val = 0;
	int             tval;
	int             max;
d437 1
a437 1
	if (negative)
d452 1
a452 1
	else
d467 1
d481 4
a484 5
	struct tm       tm;
	int             guess;
	char           *val;
	int             token;
	static int      months[11] = {31, 59, 90, 120, 151, 181,
@


1.3
log
@the ones from dhclient do, and they're already KNF'd and annsified...
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.c,v 1.7 2004/02/24 13:08:26 henning Exp $	*/
d46 2
a47 1
/* Skip to the semicolon ending the current statement.   If we encounter
d64 3
a66 3
	int token;
	char *val;
	int brace_count = 0;
d99 2
a100 2
	int token;
	char *val;
d117 3
a119 3
	char *val;
	int token;
	char *s;
d143 6
a148 6
	char *val;
	int token;
	int len = 0;
	char *s;
	char *t;
	pair c = NULL;
d163 1
a163 1
		c = cons((caddr_t)s, c);
d180 2
a181 2
		pair cdr = c->cdr;
		int l = strlen((char *)c->car);
d211 4
a214 4
	char *val;
	int token;
	int hlen;
	unsigned char *t;
d251 2
a252 2
		memcpy((unsigned char *)&hardware->haddr[0],
		    t, hardware->hlen);
d272 2
a273 2
	char *val;
	int token;
d283 1
a283 1
	*timep = ntohl(*timep); /* XXX */
d300 6
a305 6
	char *val;
	int token;
	unsigned char *bufp = buf, *s = NULL;
	char *t;
	int count = 0;
	pair c = NULL;
a334 1

d367 1
a367 1
		pair cdr = c->cdr;
d381 5
a385 5
	char *ptr = str;
	int negative = 0;
	u_int32_t val = 0;
	int tval;
	int max;
a390 1

a404 1

a445 1

d487 1
a487 1
parse_date(FILE *cfile)
d489 6
a494 6
	struct tm tm;
	int guess;
	char *val;
	int token;
	static int months[11] = { 31, 59, 90, 120, 151, 181,
	    212, 243, 273, 304, 334 };
a525 1

a543 1

a571 1

a589 1

a610 1

d613 7
a619 9
		    (tm.tm_year - 69) / 4 +	/* Leap days since '70 */
		    (tm.tm_mon			/* Days in months this year */
		    ? months[tm.tm_mon - 1]
		    : 0) +
		    (tm.tm_mon > 1 &&		/* Leap day this year */
		    !((tm.tm_year - 72) & 3)) +
		    tm.tm_mday - 1) * 24) +	/* Day of month */
		    tm.tm_hour) * 60) +
		    tm.tm_min) * 60) + tm.tm_sec;
@


1.2
log
@time_t and kill a few dumb defines
@
text
@d1 1
a1 1
/* parse.c
d3 1
a3 1
   Common parser code for dhcpd and dhclient. */
d47 15
a61 15
   braces, the matching closing brace terminates the statement.   If we
   encounter a right brace but haven't encountered a left brace, return
   leaving the brace in the token buffer for the caller.   If we see a
   semicolon and haven't seen a left brace, return.   This lets us skip
   over:

   	statement;
	statement foo bar { }
	statement foo bar { statement { } }
	statement}
 
	...et cetera. */

void skip_to_semi (cfile)
	FILE *cfile;
d68 1
a68 1
		token = peek_token (&val, cfile);
d71 1
a71 1
				token = next_token (&val, cfile);
d79 1
a79 1
			token = next_token (&val, cfile);
d82 7
a88 4
			/* EOL only happens when parsing /etc/resolv.conf,
			   and we treat it like a semicolon because the
			   resolv.conf file is line-oriented. */
			token = next_token (&val, cfile);
d91 1
a91 1
		token = next_token (&val, cfile);
d95 2
a96 2
int parse_semi (cfile)
	FILE *cfile;
d101 1
a101 1
	token = next_token (&val, cfile);
d103 3
a105 3
		parse_warn ("semicolon expected.");
		skip_to_semi (cfile);
		return 0;
d107 1
a107 1
	return 1;
d110 5
a114 4
/* string-parameter :== STRING SEMI */

char *parse_string (cfile)
	FILE *cfile;
d120 1
a120 1
	token = next_token (&val, cfile);
d122 3
a124 3
		parse_warn ("filename must be a string");
		skip_to_semi (cfile);
		return (char *)0;
d126 1
a126 4
	if (!parse_semi (cfile))
		return (char *)0;

	s = (char *)malloc (strlen (val) + 1);
d128 2
a129 2
		error ("no memory for string %s.", val);
	strlcpy (s, val, strlen(val) + 1);
d131 3
a133 1
	return s;
d136 5
a140 4
/* hostname :== identifier | hostname DOT identifier */

char *parse_host_name (cfile)
	FILE *cfile;
d147 2
a148 2
	pair c = (pair)0;
	
d152 5
a156 5
		token = next_token (&val, cfile);
		if (!is_identifier (token) && token != NUMBER) {
			parse_warn ("expecting an identifier in hostname");
			skip_to_semi (cfile);
			return (char *)0;
d159 10
a168 8
		if (!(s = (char *)malloc (strlen (val) + 1)))
			error ("can't allocate temp space for hostname.");
		strlcpy (s, val, strlen(val) + 1);
		c = cons ((caddr_t)s, c);
		len += strlen (s) + 1;
		/* Look for a dot; if it's there, keep going, otherwise
		   we're done. */
		token = peek_token (&val, cfile);
d170 1
a170 1
			token = next_token (&val, cfile);
d174 2
a175 2
	if (!(s = (char *)malloc (len)))
		error ("can't allocate space for hostname.");
d177 1
a177 1
	*--t = 0;
d179 2
a180 2
		pair cdr = c -> cdr;
		int l = strlen ((char *)(c -> car));
d182 1
a182 1
		memcpy (t, (char *)(c -> car), l);
d184 2
a185 2
		free (c -> car);
		free (c);
d190 1
a190 1
	return s;
d193 2
a194 3
int parse_ip_addr (cfile, addr)
	FILE *cfile;
	struct iaddr *addr;
d196 13
a208 13
	addr -> len = 4;
	if (parse_numeric_aggregate (cfile, addr -> iabuf,
				     &addr -> len, DOT, 10, 8))
		return 1;
	return 0;
}	

/* hardware-parameter :== HARDWARE ETHERNET csns SEMI
   csns :== NUMBER | csns COLON NUMBER */

void parse_hardware_param (cfile, hardware)
	FILE *cfile;
	struct hardware *hardware;
d215 1
a215 1
	token = next_token (&val, cfile);
d217 2
a218 2
	      case ETHERNET:
		hardware -> htype = HTYPE_ETHER;
d220 2
a221 2
	      case TOKEN_RING:
		hardware -> htype = HTYPE_IEEE802;
d223 2
a224 2
	      case FDDI:
		hardware -> htype = HTYPE_FDDI;
d226 3
a228 3
	      default:
		parse_warn ("expecting a network hardware type");
		skip_to_semi (cfile);
d232 9
a240 7
	/* Parse the hardware address information.   Technically,
	   it would make a lot of sense to restrict the length of the
	   data we'll accept here to the length of a particular hardware
	   address type.   Unfortunately, there are some broken clients
	   out there that put bogus data in the chaddr buffer, and we accept
	   that data in the lease file rather than simply failing on such
	   clients.   Yuck. */
d242 1
a242 2
	t = parse_numeric_aggregate (cfile, (unsigned char *)0, &hlen,
				     COLON, 16, 8);
d245 3
a247 3
	if (hlen > sizeof hardware -> haddr) {
		free (t);
		parse_warn ("hardware address too long");
d249 7
a255 7
		hardware -> hlen = hlen;
		memcpy ((unsigned char *)&hardware -> haddr [0],
			t, hardware -> hlen);
		if (hlen < sizeof hardware -> haddr)
			memset (&hardware -> haddr [hlen], 0,
				(sizeof hardware -> haddr) - hlen);
		free (t);
d257 2
a258 2
	
	token = next_token (&val, cfile);
d260 2
a261 2
		parse_warn ("expecting semicolon.");
		skip_to_semi (cfile);
d265 5
a269 5
/* lease-time :== NUMBER SEMI */

void parse_lease_time (cfile, timep)
	FILE *cfile;
	time_t *timep;
d274 1
a274 1
	token = next_token (&val, cfile);
d276 2
a277 2
		parse_warn ("Expecting numeric lease time");
		skip_to_semi (cfile);
d280 1
a280 1
	convert_num ((unsigned char *)timep, val, 10, 32);
d282 1
a282 1
	*timep = ntohl (*timep); /* XXX */
d284 1
a284 1
	parse_semi (cfile);
d287 11
a297 15
/* No BNF for numeric aggregates - that's defined by the caller.  What
   this function does is to parse a sequence of numbers separated by
   the token specified in separator.  If max is zero, any number of
   numbers will be parsed; otherwise, exactly max numbers are
   expected.  Base and size tell us how to internalize the numbers
   once they've been tokenized. */

unsigned char *parse_numeric_aggregate (cfile, buf,
					max, separator, base, size)
	FILE *cfile;
	unsigned char *buf;
	int *max;
	int separator;
	int base;
	int size;
d304 1
a304 1
	pair c = (pair)0;
d307 1
a307 1
		bufp = (unsigned char *)malloc (*max * size / 8);
d309 1
a309 1
			error ("can't allocate space for numeric aggregate");
d315 1
a315 1
			token = peek_token (&val, cfile);
d320 2
a321 2
					token = next_token (&val, cfile);
				parse_warn ("too few numbers.");
d323 2
a324 2
					skip_to_semi (cfile);
				return (unsigned char *)0;
d326 1
a326 1
			token = next_token (&val, cfile);
d328 1
a328 1
		token = next_token (&val, cfile);
d331 1
a331 1
			parse_warn ("unexpected end of file");
d338 8
a345 6
			parse_warn ("expecting numeric value.");
			skip_to_semi (cfile);
			return (unsigned char *)0;
		}
		/* If we can, convert the number now; otherwise, build
		   a linked list of all the numbers. */
d347 1
a347 1
			convert_num (s, val, base, size);
d350 1
a350 1
			t = (char *)malloc (strlen (val) + 1);
d352 3
a354 3
				error ("no temp space for number.");
			strlcpy (t, val, strlen(val)+1);
			c = cons (t, c);
d360 1
a360 1
		bufp = (unsigned char *)malloc (count * size / 8);
d362 1
a362 1
			error ("can't allocate space for numeric aggregate.");
d367 2
a368 2
		pair cdr = c -> cdr;
		convert_num (s, (char *)(c -> car), base, size);
d371 2
a372 2
		free (c -> car);
		free (c);
d375 1
a375 1
	return bufp;
d378 2
a379 5
void convert_num (buf, str, base, size)
	unsigned char *buf;
	char *str;
	int base;
	int size;
d389 1
a389 1
		++ptr;
d394 2
a395 2
		if (ptr [0] == '0') {
			if (ptr [1] == 'x') {
d398 1
a398 1
			} else if (isascii (ptr [1]) && isdigit (ptr [1])) {
d401 1
a401 1
			} else {
d403 1
a403 2
			}
		} else {
a404 1
		}
d417 1
a417 1
			warn ("Bogus number: %s.", str);
d421 2
a422 2
			warn ("Bogus number: %s: digit %d not in base %d",
			      str, tval, base);
d434 11
a444 11
		      case 8:
			warn ("value %s%o exceeds max (%d) for precision.",
			      negative ? "-" : "", val, max);
			break;
		      case 16:
			warn ("value %s%x exceeds max (%d) for precision.",
			      negative ? "-" : "", val, max);
			break;
		      default:
			warn ("value %s%u exceeds max (%d) for precision.",
			      negative ? "-" : "", val, max);
d449 1
a449 1
	if (negative) {
d451 1
a451 1
		      case 8:
d454 2
a455 2
		      case 16:
			putShort (buf, -(unsigned long)val);
d457 2
a458 2
		      case 32:
			putLong (buf, -(unsigned long)val);
d460 2
a461 2
		      default:
			warn ("Unexpected integer size: %d", size);
d464 1
a464 1
	} else {
d466 1
a466 1
		      case 8:
d469 2
a470 2
		      case 16:
			putUShort (buf, (u_int16_t)val);
d472 2
a473 2
		      case 32:
			putULong (buf, val);
d475 2
a476 2
		      default:
			warn ("Unexpected integer size: %d", size);
a478 1
	}
d481 10
a490 9
/* date :== NUMBER NUMBER SLASH NUMBER SLASH NUMBER 
   		NUMBER COLON NUMBER COLON NUMBER SEMI

   Dates are always in GMT; first number is day of week; next is
   year/month/day; next is hours:minutes:seconds on a 24-hour
   clock. */

time_t parse_date (cfile)
	FILE *cfile;
d496 2
a497 2
	static int months [11] = { 31, 59, 90, 120, 151, 181,
					  212, 243, 273, 304, 334 };
d500 1
a500 1
	token = next_token (&val, cfile);
d502 1
a502 1
		parse_warn ("numeric day of week expected.");
d504 1
a504 1
			skip_to_semi (cfile);
d507 1
a507 1
	tm.tm_wday = atoi (val);
d510 1
a510 1
	token = next_token (&val, cfile);
d512 1
a512 1
		parse_warn ("numeric year expected.");
d514 1
a514 1
			skip_to_semi (cfile);
d517 1
a517 1
	tm.tm_year = atoi (val);
d522 1
a522 1
	token = next_token (&val, cfile);
d524 1
a524 1
		parse_warn ("expected slash separating year from month.");
d526 1
a526 1
			skip_to_semi (cfile);
d531 1
a531 1
	token = next_token (&val, cfile);
d533 1
a533 1
		parse_warn ("numeric month expected.");
d535 1
a535 1
			skip_to_semi (cfile);
d538 1
a538 1
	tm.tm_mon = atoi (val) - 1;
d541 1
a541 1
	token = next_token (&val, cfile);
d543 1
a543 1
		parse_warn ("expected slash separating month from day.");
d545 1
a545 1
			skip_to_semi (cfile);
d550 1
a550 1
	token = next_token (&val, cfile);
d552 1
a552 1
		parse_warn ("numeric day of month expected.");
d554 1
a554 1
			skip_to_semi (cfile);
d557 1
a557 1
	tm.tm_mday = atoi (val);
d560 1
a560 1
	token = next_token (&val, cfile);
d562 1
a562 1
		parse_warn ("numeric hour expected.");
d564 1
a564 1
			skip_to_semi (cfile);
d567 1
a567 1
	tm.tm_hour = atoi (val);
d570 1
a570 1
	token = next_token (&val, cfile);
d572 1
a572 1
		parse_warn ("expected colon separating hour from minute.");
d574 1
a574 1
			skip_to_semi (cfile);
d579 1
a579 1
	token = next_token (&val, cfile);
d581 1
a581 1
		parse_warn ("numeric minute expected.");
d583 1
a583 1
			skip_to_semi (cfile);
d586 1
a586 1
	tm.tm_min = atoi (val);
d589 1
a589 1
	token = next_token (&val, cfile);
d591 1
a591 1
		parse_warn ("expected colon separating hour from minute.");
d593 1
a593 1
			skip_to_semi (cfile);
d598 1
a598 1
	token = next_token (&val, cfile);
d600 1
a600 1
		parse_warn ("numeric minute expected.");
d602 1
a602 1
			skip_to_semi (cfile);
d605 1
a605 1
	tm.tm_sec = atoi (val);
d608 1
a608 1
	/* XXX */ /* We assume that mktime does not use tm_yday. */
d612 1
a612 1
	token = next_token (&val, cfile);
d614 3
a616 3
		parse_warn ("semicolon expected.");
		skip_to_semi (cfile);
		return 0;
d621 7
a627 7
		      (tm.tm_year - 69) / 4 +	/* Leap days since '70 */
		      (tm.tm_mon		/* Days in months this year */
		       ? months [tm.tm_mon - 1]
		       : 0) +
		      (tm.tm_mon > 1 &&		/* Leap day this year */
		       !((tm.tm_year - 72) & 3)) +
		      tm.tm_mday - 1) * 24) +	/* Day of month */
d629 1
a629 10
		  tm.tm_min) * 60) + tm.tm_sec;

	/* This guess could be wrong because of leap seconds or other
	   weirdness we don't know about that the system does.   For
	   now, we're just going to accept the guess, but at some point
	   it might be nice to do a successive approximation here to
	   get an exact value.   Even if the error is small, if the
	   server is restarted frequently (and thus the lease database
	   is reread), the error could accumulate into something
	   significant. */
d631 11
a641 1
	return guess;
@


1.1
log
@may the whacking begin
@
text
@d81 1
a81 1
		} else if (token == EOL) {
d263 1
a263 1
	TIME *timep;
d490 1
a490 1
TIME parse_date (cfile)
d506 1
a506 1
		return (TIME)0;
d516 1
a516 1
		return (TIME)0;
d528 1
a528 1
		return (TIME)0;
d537 1
a537 1
		return (TIME)0;
d547 1
a547 1
		return (TIME)0;
d556 1
a556 1
		return (TIME)0;
d566 1
a566 1
		return (TIME)0;
d576 1
a576 1
		return (TIME)0;
d585 1
a585 1
		return (TIME)0;
d595 1
a595 1
		return (TIME)0;
d604 1
a604 1
		return (TIME)0;
@

