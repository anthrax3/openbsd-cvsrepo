head	1.23;
access;
symbols
	OPENBSD_6_1:1.23.0.2
	OPENBSD_6_1_BASE:1.23
	OPENBSD_6_0:1.17.0.4
	OPENBSD_6_0_BASE:1.17
	OPENBSD_5_9:1.17.0.2
	OPENBSD_5_9_BASE:1.17
	OPENBSD_5_8:1.16.0.6
	OPENBSD_5_8_BASE:1.16
	OPENBSD_5_7:1.16.0.2
	OPENBSD_5_7_BASE:1.16
	OPENBSD_5_6:1.15.0.6
	OPENBSD_5_6_BASE:1.15
	OPENBSD_5_5:1.15.0.4
	OPENBSD_5_5_BASE:1.15
	OPENBSD_5_4:1.13.0.2
	OPENBSD_5_4_BASE:1.13
	OPENBSD_5_3:1.10.0.10
	OPENBSD_5_3_BASE:1.10
	OPENBSD_5_2:1.10.0.8
	OPENBSD_5_2_BASE:1.10
	OPENBSD_5_1_BASE:1.10
	OPENBSD_5_1:1.10.0.6
	OPENBSD_5_0:1.10.0.4
	OPENBSD_5_0_BASE:1.10
	OPENBSD_4_9:1.10.0.2
	OPENBSD_4_9_BASE:1.10
	OPENBSD_4_8:1.9.0.2
	OPENBSD_4_8_BASE:1.9
	OPENBSD_4_7:1.8.0.2
	OPENBSD_4_7_BASE:1.8
	OPENBSD_4_6:1.7.0.6
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.7.0.2
	OPENBSD_4_5_BASE:1.7
	OPENBSD_4_4:1.6.0.2
	OPENBSD_4_4_BASE:1.6;
locks; strict;
comment	@ * @;


1.23
date	2017.02.13.23.04.05;	author krw;	state Exp;
branches;
next	1.22;
commitid	amfLXbU964CBXnkr;

1.22
date	2017.02.13.22.33.39;	author krw;	state Exp;
branches;
next	1.21;
commitid	aD6aChUv7GEv3CLZ;

1.21
date	2017.02.13.21.53.53;	author krw;	state Exp;
branches;
next	1.20;
commitid	iao5yt5BDQh8mK3C;

1.20
date	2017.02.13.19.13.14;	author krw;	state Exp;
branches;
next	1.19;
commitid	syYFt6P4XI7prXRF;

1.19
date	2016.10.21.11.34.48;	author mestre;	state Exp;
branches;
next	1.18;
commitid	n8FcjA9jf8rFQIu1;

1.18
date	2016.10.04.22.47.51;	author krw;	state Exp;
branches;
next	1.17;
commitid	PTCmBSXhdCRLXLlF;

1.17
date	2016.02.06.23.50.10;	author krw;	state Exp;
branches;
next	1.16;
commitid	8GMcSAoPYCa1rXN3;

1.16
date	2015.01.16.06.40.16;	author deraadt;	state Exp;
branches;
next	1.15;
commitid	Uu5nFG3wCl0LACBb;

1.15
date	2013.10.18.15.19.40;	author krw;	state Exp;
branches;
next	1.14;

1.14
date	2013.10.18.13.44.35;	author krw;	state Exp;
branches;
next	1.13;

1.13
date	2013.04.22.15.02.42;	author krw;	state Exp;
branches;
next	1.12;

1.12
date	2013.04.13.18.08.47;	author krw;	state Exp;
branches;
next	1.11;

1.11
date	2013.04.12.00.27.32;	author krw;	state Exp;
branches;
next	1.10;

1.10
date	2010.12.23.17.38.04;	author claudio;	state Exp;
branches;
next	1.9;

1.9
date	2010.03.27.14.11.38;	author krw;	state Exp;
branches;
next	1.8;

1.8
date	2010.01.03.18.37.06;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2008.09.15.20.38.17;	author claudio;	state Exp;
branches;
next	1.6;

1.6
date	2008.05.30.05.58.20;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2008.05.11.08.50.54;	author beck;	state Exp;
branches;
next	1.4;

1.4
date	2008.05.08.14.15.40;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2008.05.08.07.28.08;	author beck;	state Exp;
branches;
next	1.2;

1.2
date	2008.05.08.05.38.26;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	2008.05.07.12.19.20;	author beck;	state Exp;
branches;
next	;


desc
@@


1.23
log
@Eliminate pointless'%m' (a.k.a. hand rolled strerror()) by using fatal() and
log_warn(). Zap a couple of explicit 'syslog()' calls.
@
text
@/*	$OpenBSD: sync.c,v 1.22 2017/02/13 22:33:39 krw Exp $	*/

/*
 * Copyright (c) 2008 Bob Beck <beck@@openbsd.org>
 * Copyright (c) 2006, 2007 Reyk Floeter <reyk@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/ioctl.h>
#include <sys/queue.h>
#include <sys/socket.h>

#include <net/if.h>

#include <arpa/inet.h>

#include <netinet/in.h>

#include <openssl/hmac.h>

#include <errno.h>
#include <netdb.h>
#include <sha1.h>
#include <string.h>
#include <syslog.h>
#include <unistd.h>

#include "dhcp.h"
#include "tree.h"
#include "dhcpd.h"
#include "log.h"
#include "sync.h"

int sync_debug;

u_int32_t sync_counter;
int syncfd = -1;
int sendmcast;

struct sockaddr_in sync_in;
struct sockaddr_in sync_out;
static char *sync_key;

struct sync_host {
	LIST_ENTRY(sync_host)	h_entry;

	char			*h_name;
	struct sockaddr_in	sh_addr;
};
LIST_HEAD(synchosts, sync_host) sync_hosts = LIST_HEAD_INITIALIZER(sync_hosts);

void	 sync_send(struct iovec *, int);

int
sync_addhost(const char *name, u_short port)
{
	struct addrinfo hints, *res, *res0;
	struct sync_host *shost;
	struct sockaddr_in *addr = NULL;

	memset(&hints, 0, sizeof(hints));
	hints.ai_family = PF_UNSPEC;
	hints.ai_socktype = SOCK_STREAM;
	if (getaddrinfo(name, NULL, &hints, &res0) != 0)
		return (EINVAL);
	for (res = res0; res != NULL; res = res->ai_next) {
		if (addr == NULL && res->ai_family == AF_INET) {
			addr = (struct sockaddr_in *)res->ai_addr;
			break;
		}
	}
	if (addr == NULL) {
		freeaddrinfo(res0);
		return (EINVAL);
	}
	if ((shost = (struct sync_host *)
	    calloc(1, sizeof(struct sync_host))) == NULL) {
		freeaddrinfo(res0);
		return (ENOMEM);
	}
	shost->h_name = strdup(name);
	if (shost->h_name == NULL) {
		free(shost);
		freeaddrinfo(res0);
		return (ENOMEM);
	}

	shost->sh_addr.sin_family = AF_INET;
	shost->sh_addr.sin_port = htons(port);
	shost->sh_addr.sin_addr.s_addr = addr->sin_addr.s_addr;
	freeaddrinfo(res0);

	LIST_INSERT_HEAD(&sync_hosts, shost, h_entry);

	if (sync_debug)
		log_info("added dhcp sync host %s (address %s, port %d)\n",
		    shost->h_name, inet_ntoa(shost->sh_addr.sin_addr), port);

	return (0);
}

int
sync_init(const char *iface, const char *baddr, u_short port)
{
	int one = 1;
	u_int8_t ttl;
	struct ifreq ifr;
	struct ip_mreq mreq;
	struct sockaddr_in *addr;
	char ifnam[IFNAMSIZ], *ttlstr;
	const char *errstr;
	struct in_addr ina;

	if (iface != NULL)
		sendmcast++;

	memset(&ina, 0, sizeof(ina));
	if (baddr != NULL) {
		if (inet_pton(AF_INET, baddr, &ina) != 1) {
			ina.s_addr = htonl(INADDR_ANY);
			if (iface == NULL)
				iface = baddr;
			else if (iface != NULL && strcmp(baddr, iface) != 0) {
				fprintf(stderr, "multicast interface does "
				    "not match");
				return (-1);
			}
		}
	}

	sync_key = SHA1File(DHCP_SYNC_KEY, NULL);
	if (sync_key == NULL) {
		if (errno != ENOENT) {
			log_warn("failed to open sync key");
			return (-1);
		}
		/* Use empty key by default */
		sync_key = "";
	}

	syncfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (syncfd == -1)
		return (-1);

	if (setsockopt(syncfd, SOL_SOCKET, SO_REUSEADDR, &one,
	    sizeof(one)) == -1)
		goto fail;

	memset(&sync_out, 0, sizeof(sync_out));
	sync_out.sin_family = AF_INET;
	sync_out.sin_len = sizeof(sync_out);
	sync_out.sin_addr.s_addr = ina.s_addr;
	if (baddr == NULL && iface == NULL)
		sync_out.sin_port = 0;
	else
		sync_out.sin_port = htons(port);

	if (bind(syncfd, (struct sockaddr *)&sync_out, sizeof(sync_out)) == -1)
		goto fail;

	/* Don't use multicast messages */
	if (iface == NULL)
		return (syncfd);

	strlcpy(ifnam, iface, sizeof(ifnam));
	ttl = DHCP_SYNC_MCASTTTL;
	if ((ttlstr = strchr(ifnam, ':')) != NULL) {
		*ttlstr++ = '\0';
		ttl = (u_int8_t)strtonum(ttlstr, 1, UINT8_MAX, &errstr);
		if (errstr) {
			fprintf(stderr, "invalid multicast ttl %s: %s",
			    ttlstr, errstr);
			goto fail;
		}
	}

	memset(&ifr, 0, sizeof(ifr));
	strlcpy(ifr.ifr_name, ifnam, sizeof(ifr.ifr_name));
	if (ioctl(syncfd, SIOCGIFADDR, &ifr) == -1)
		goto fail;

	memset(&sync_in, 0, sizeof(sync_in));
	addr = (struct sockaddr_in *)&ifr.ifr_addr;
	sync_in.sin_family = AF_INET;
	sync_in.sin_len = sizeof(sync_in);
	sync_in.sin_addr.s_addr = addr->sin_addr.s_addr;
	sync_in.sin_port = htons(port);

	memset(&mreq, 0, sizeof(mreq));
	sync_out.sin_addr.s_addr = inet_addr(DHCP_SYNC_MCASTADDR);
	mreq.imr_multiaddr.s_addr = inet_addr(DHCP_SYNC_MCASTADDR);
	mreq.imr_interface.s_addr = sync_in.sin_addr.s_addr;

	if (setsockopt(syncfd, IPPROTO_IP,
	    IP_ADD_MEMBERSHIP, &mreq, sizeof(mreq)) == -1) {
		log_warn("failed to add multicast membership to %s",
		    DHCP_SYNC_MCASTADDR);
		goto fail;
	}
	if (setsockopt(syncfd, IPPROTO_IP, IP_MULTICAST_TTL, &ttl,
	    sizeof(ttl)) == -1) {
		log_warn("failed to set multicast ttl to %u", ttl);
		setsockopt(syncfd, IPPROTO_IP,
		    IP_DROP_MEMBERSHIP, &mreq, sizeof(mreq));
		goto fail;
	}

	if (sync_debug)
		log_debug("using multicast dhcp sync %smode "
		    "(ttl %u, group %s, port %d)\n",
		    sendmcast ? "" : "receive ",
		    ttl, inet_ntoa(sync_out.sin_addr), port);

	return (syncfd);

 fail:
	close(syncfd);
	return (-1);
}

void
sync_recv(void)
{
	struct dhcp_synchdr *hdr;
	struct sockaddr_in addr;
	struct dhcp_synctlv_hdr *tlv;
	struct dhcp_synctlv_lease *lv;
	struct lease	*lease;
	u_int8_t buf[DHCP_SYNC_MAXSIZE];
	u_int8_t hmac[2][DHCP_SYNC_HMAC_LEN];
	struct lease l, *lp;
	u_int8_t *p;
	socklen_t addr_len;
	ssize_t len;
	u_int hmac_len;

	memset(&addr, 0, sizeof(addr));
	memset(buf, 0, sizeof(buf));

	addr_len = sizeof(addr);
	if ((len = recvfrom(syncfd, buf, sizeof(buf), 0,
	    (struct sockaddr *)&addr, &addr_len)) < 1)
		return;
	if (addr.sin_addr.s_addr != htonl(INADDR_ANY) &&
	    bcmp(&sync_in.sin_addr, &addr.sin_addr,
	    sizeof(addr.sin_addr)) == 0)
		return;

	/* Ignore invalid or truncated packets */
	hdr = (struct dhcp_synchdr *)buf;
	if (len < sizeof(struct dhcp_synchdr) ||
	    hdr->sh_version != DHCP_SYNC_VERSION ||
	    hdr->sh_af != AF_INET ||
	    len < ntohs(hdr->sh_length))
		goto trunc;
	len = ntohs(hdr->sh_length);

	/* Compute and validate HMAC */
	memcpy(hmac[0], hdr->sh_hmac, DHCP_SYNC_HMAC_LEN);
	explicit_bzero(hdr->sh_hmac, DHCP_SYNC_HMAC_LEN);
	HMAC(EVP_sha1(), sync_key, strlen(sync_key), buf, len,
	    hmac[1], &hmac_len);
	if (bcmp(hmac[0], hmac[1], DHCP_SYNC_HMAC_LEN) != 0)
		goto trunc;

	if (sync_debug)
		log_info("%s(sync): received packet of %d bytes\n",
		    inet_ntoa(addr.sin_addr), (int)len);

	p = (u_int8_t *)(hdr + 1);
	while (len) {
		tlv = (struct dhcp_synctlv_hdr *)p;

		if (len < sizeof(struct dhcp_synctlv_hdr) ||
		    len < ntohs(tlv->st_length))
			goto trunc;

		switch (ntohs(tlv->st_type)) {
		case DHCP_SYNC_LEASE:
			lv = (struct dhcp_synctlv_lease *)tlv;
			if (sizeof(*lv) > ntohs(tlv->st_length))
				goto trunc;
			lease = find_lease_by_hw_addr(
			    lv->lv_hardware_addr.haddr,
			    lv->lv_hardware_addr.hlen);
			if (lease == NULL)
				lease = find_lease_by_ip_addr(lv->lv_ip_addr);

			lp = &l;
			memset(lp, 0, sizeof(*lp));
			lp->timestamp = ntohl(lv->lv_timestamp);
			lp->starts = ntohl(lv->lv_starts);
			lp->ends = ntohl(lv->lv_ends);
			memcpy(&lp->ip_addr, &lv->lv_ip_addr,
			    sizeof(lp->ip_addr));
			memcpy(&lp->hardware_addr, &lv->lv_hardware_addr,
			    sizeof(lp->hardware_addr));
			log_info("DHCP_SYNC_LEASE from %s for hw %s -> ip %s, "
			    "start %lld, end %lld",
			    inet_ntoa(addr.sin_addr),
			    print_hw_addr(lp->hardware_addr.htype,
			    lp->hardware_addr.hlen, lp->hardware_addr.haddr),
			    piaddr(lp->ip_addr),
			    (long long)lp->starts, (long long)lp->ends);
			/* now whack the lease in there */
			if (lease == NULL) {
				enter_lease(lp);
				write_leases();
			}
			else if (lease->ends < lp->ends)
				supersede_lease(lease, lp, 1);
			else if (lease->ends > lp->ends)
				/*
				 * our partner sent us a lease
				 * that is older than what we have,
				 * so re-educate them with what we
				 * know is newer.
				 */
				sync_lease(lease);
			break;
		case DHCP_SYNC_END:
			goto done;
		default:
			printf("invalid type: %d\n", ntohs(tlv->st_type));
			goto trunc;
		}
		len -= ntohs(tlv->st_length);
		p = ((u_int8_t *)tlv) + ntohs(tlv->st_length);
	}

 done:
	return;

 trunc:
	if (sync_debug)
		log_info("%s(sync): truncated or invalid packet\n",
		    inet_ntoa(addr.sin_addr));
}

void
sync_send(struct iovec *iov, int iovlen)
{
	struct sync_host *shost;
	struct msghdr msg;

	if (syncfd == -1)
		return;

	/* setup buffer */
	memset(&msg, 0, sizeof(msg));
	msg.msg_iov = iov;
	msg.msg_iovlen = iovlen;

	if (sendmcast) {
		if (sync_debug)
			log_info("sending multicast sync message\n");
		msg.msg_name = &sync_out;
		msg.msg_namelen = sizeof(sync_out);
		if (sendmsg(syncfd, &msg, 0) == -1)
			log_warn("sending multicast sync message failed");
	}

	LIST_FOREACH(shost, &sync_hosts, h_entry) {
		if (sync_debug)
			log_info("sending sync message to %s (%s)\n",
			    shost->h_name, inet_ntoa(shost->sh_addr.sin_addr));
		msg.msg_name = &shost->sh_addr;
		msg.msg_namelen = sizeof(shost->sh_addr);
		if (sendmsg(syncfd, &msg, 0) == -1)
			log_warn("sending sync message failed");
	}
}

void
sync_lease(struct lease *lease)
{
	struct iovec iov[4];
	struct dhcp_synchdr hdr;
	struct dhcp_synctlv_lease lv;
	struct dhcp_synctlv_hdr end;
	char pad[DHCP_ALIGNBYTES];
	u_int16_t leaselen, padlen;
	int i = 0;
	HMAC_CTX ctx;
	u_int hmac_len;

	if (sync_key == NULL)
		return;

	memset(&hdr, 0, sizeof(hdr));
	memset(&lv, 0, sizeof(lv));
	memset(&pad, 0, sizeof(pad));

	HMAC_CTX_init(&ctx);
	HMAC_Init(&ctx, sync_key, strlen(sync_key), EVP_sha1());

	leaselen = sizeof(lv);
	padlen = DHCP_ALIGN(leaselen) - leaselen;

	/* Add DHCP sync packet header */
	hdr.sh_version = DHCP_SYNC_VERSION;
	hdr.sh_af = AF_INET;
	hdr.sh_counter = sync_counter++;
	hdr.sh_length = htons(sizeof(hdr) + sizeof(lv) + padlen + sizeof(end));
	iov[i].iov_base = &hdr;
	iov[i].iov_len = sizeof(hdr);
	HMAC_Update(&ctx, iov[i].iov_base, iov[i].iov_len);
	i++;

	/* Add single DHCP sync address entry */
	lv.lv_type = htons(DHCP_SYNC_LEASE);
	lv.lv_length = htons(leaselen + padlen);
	lv.lv_timestamp = htonl(lease->timestamp);
	lv.lv_starts = htonl(lease->starts);
	lv.lv_ends =  htonl(lease->ends);
	memcpy(&lv.lv_ip_addr, &lease->ip_addr, sizeof(lv.lv_ip_addr));
	memcpy(&lv.lv_hardware_addr, &lease->hardware_addr,
	    sizeof(lv.lv_hardware_addr));
	log_info("sending DHCP_SYNC_LEASE for hw %s -> ip %s, start %d, "
	    "end %d", print_hw_addr(lv.lv_hardware_addr.htype,
	    lv.lv_hardware_addr.hlen, lv.lv_hardware_addr.haddr),
	    piaddr(lease->ip_addr), ntohl(lv.lv_starts), ntohl(lv.lv_ends));
	iov[i].iov_base = &lv;
	iov[i].iov_len = sizeof(lv);
	HMAC_Update(&ctx, iov[i].iov_base, iov[i].iov_len);
	i++;

	iov[i].iov_base = pad;
	iov[i].iov_len = padlen;
	HMAC_Update(&ctx, iov[i].iov_base, iov[i].iov_len);
	i++;

	/* Add end marker */
	end.st_type = htons(DHCP_SYNC_END);
	end.st_length = htons(sizeof(end));
	iov[i].iov_base = &end;
	iov[i].iov_len = sizeof(end);
	HMAC_Update(&ctx, iov[i].iov_base, iov[i].iov_len);
	i++;

	HMAC_Final(&ctx, hdr.sh_hmac, &hmac_len);

	/* Send message to the target hosts */
	sync_send(iov, i);
	HMAC_CTX_cleanup(&ctx);
}
@


1.22
log
@Adjust some long lines.
@
text
@d1 1
a1 1
/*	$OpenBSD: sync.c,v 1.21 2017/02/13 21:53:53 krw Exp $	*/
d372 1
a372 1
			log_warnx("sending multicast sync message failed: %m");
d382 1
a382 1
			log_warnx("sending sync message failed: %m");
@


1.21
log
@Do the strerror() elimination dance with log_warnx() -> log_warn(),
fatalx() -> fatal() and even a couple of fprintf(stderr) -> log_warn().
@
text
@d1 1
a1 1
/*	$OpenBSD: sync.c,v 1.20 2017/02/13 19:13:14 krw Exp $	*/
d431 4
a434 4
	log_info("sending DHCP_SYNC_LEASE for hw %s -> ip %s, start %d, end %d",
	    print_hw_addr(lv.lv_hardware_addr.htype, lv.lv_hardware_addr.hlen,
	    lv.lv_hardware_addr.haddr), piaddr(lease->ip_addr),
	    ntohl(lv.lv_starts), ntohl(lv.lv_ends));
@


1.20
log
@Switch from old errwarn.c logging to shiny new log.[ch].

ok benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sync.c,v 1.19 2016/10/21 11:34:48 mestre Exp $	*/
d146 1
a146 2
			fprintf(stderr, "failed to open sync key: %s\n",
			    strerror(errno));
d208 2
a209 2
		fprintf(stderr, "failed to add multicast membership to %s: %s",
		    DHCP_SYNC_MCASTADDR, strerror(errno));
d214 1
a214 2
		fprintf(stderr, "failed to set multicast ttl to "
		    "%u: %s\n", ttl, strerror(errno));
@


1.19
log
@- Use memset(*b, 0, len) instead of bzero(*b, len)
- Use explicit_bzero(3) instead of bzero(3) to clean temporary HMAC

OK krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sync.c,v 1.18 2016/10/04 22:47:51 krw Exp $	*/
d43 1
d108 1
a108 1
		note("added dhcp sync host %s (address %s, port %d)\n",
d223 1
a223 1
		syslog_r(LOG_DEBUG, &sdata, "using multicast dhcp sync %smode "
d281 1
a281 1
		note("%s(sync): received packet of %d bytes\n",
d312 1
a312 1
			note("DHCP_SYNC_LEASE from %s for hw %s -> ip %s, "
d350 1
a350 1
		note("%s(sync): truncated or invalid packet\n",
d370 1
a370 1
			note("sending multicast sync message\n");
d374 1
a374 1
			warning("sending multicast sync message failed: %m");
d379 1
a379 1
			note("sending sync message to %s (%s)\n",
d384 1
a384 1
			warning("sending sync message failed: %m");
d433 1
a433 1
	note("sending DHCP_SYNC_LEASE for hw %s -> ip %s, start %d, end %d",
@


1.18
log
@Zap stray whitespace.
@
text
@d1 1
a1 1
/*	$OpenBSD: sync.c,v 1.17 2016/02/06 23:50:10 krw Exp $	*/
d72 1
a72 1
	bzero(&hints, sizeof(hints));
d128 1
a128 1
	bzero(&ina, sizeof(ina));
d161 1
a161 1
	bzero(&sync_out, sizeof(sync_out));
d189 1
a189 1
	bzero(&ifr, sizeof(ifr));
d194 1
a194 1
	bzero(&sync_in, sizeof(sync_in));
d201 1
a201 1
	bzero(&mreq, sizeof(mreq));
d250 2
a251 2
	bzero(&addr, sizeof(addr));
	bzero(buf, sizeof(buf));
d273 1
a273 1
	bzero(hdr->sh_hmac, DHCP_SYNC_HMAC_LEN);
d363 1
a363 1
	bzero(&msg, sizeof(msg));
d403 3
a405 3
	bzero(&hdr, sizeof(hdr));
	bzero(&lv, sizeof(lv));
	bzero(&pad, sizeof(pad));
@


1.17
log
@Eliminate #include inside *.h files and include only needed headers in
each *.c file.

Inspired by mention of header silliness by Edgar Pettijohn and mmcc@@
on tech@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: sync.c,v 1.16 2015/01/16 06:40:16 deraadt Exp $	*/
d358 1
a358 1
	
@


1.16
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: sync.c,v 1.15 2013/10/18 15:19:40 krw Exp $	*/
d20 1
a20 6
#include <sys/stdint.h>
#include <sys/file.h>
#include <sys/wait.h>
#include <sys/socket.h>
#include <sys/resource.h>
#include <sys/uio.h>
d23 3
d27 1
a28 1
#include <net/if.h>
a29 1
#include <arpa/inet.h>
d31 2
a32 1
#include <err.h>
d34 2
a35 3
#include <pwd.h>
#include <stdio.h>
#include <stdlib.h>
d37 1
a38 5
#include <sha1.h>

#include <netdb.h>

#include <openssl/hmac.h>
d40 2
@


1.15
log
@Scattering a few bcopy()'s around source using mostly memcpy() is just
asking for confusion. Replace bcopy()'s with memcpy()'s.
@
text
@d1 1
a1 1
/*	$OpenBSD: sync.c,v 1.14 2013/10/18 13:44:35 krw Exp $	*/
a19 1
#include <sys/param.h>
@


1.14
log
@%d -> %lld, add (long long) cast to time_t variables. Make guenther
and gcc happier. Found while looking at something else for dlg@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: sync.c,v 1.13 2013/04/22 15:02:42 krw Exp $	*/
d278 1
a278 1
	bcopy(hdr->sh_hmac, hmac[0], DHCP_SYNC_HMAC_LEN);
@


1.13
log
@When sync'ing, look for lease by hwaddr and then ipaddr. Not hwaddr
twice. Simplify logic. Fixes loops while sync'ing for sthen@@.

Spotted by & fixed tested by sthen@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: sync.c,v 1.12 2013/04/13 18:08:47 krw Exp $	*/
d318 1
a318 1
			    "start %d, end %d",
d322 2
a323 1
			    piaddr(lp->ip_addr), lp->starts, lp->ends);
@


1.12
log
@Give struct dhcp_synctlv_lease fields a prefix (lv_) as the fields
in other structs have. Reduces potential for confusion with fields
of same name but different types in leases. Use consistent variable
name. No change to executable.
@
text
@d1 1
a1 1
/*	$OpenBSD: sync.c,v 1.11 2013/04/12 00:27:32 krw Exp $	*/
d302 5
a306 13
			if ((lease = find_lease_by_hw_addr(
				    lv->lv_hardware_addr.haddr,
				    lv->lv_hardware_addr.hlen)) == NULL) {
				if ((lease = find_lease_by_hw_addr(
					    lv->lv_hardware_addr.haddr,
					    lv->lv_hardware_addr.hlen)) == NULL)
				    {
					lp = &l;
					memset(lp, 0, sizeof(*lp));
				} else
					lp = lease;
			} else
				lp = lease;
@


1.11
log
@Unbreak lease synchronization by making the sync header contain the
correct packet length even when paddding is present. Previously the
HMAC calculated by the receiver would not be based on the whole
packet.

Problem noted and essentially identical diffs from Kapetanakis Giannis
via misc@@ and then Johan Ymerson via bugs@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: sync.c,v 1.10 2010/12/23 17:38:04 claudio Exp $	*/
d303 2
a304 2
				    lv->hardware_addr.haddr,
				    lv->hardware_addr.hlen)) == NULL) {
d306 3
a308 2
					    lv->hardware_addr.haddr,
					    lv->hardware_addr.hlen)) == NULL) {
d318 4
a321 4
			lp->timestamp = ntohl(lv->timestamp);
			lp->starts = ntohl(lv->starts);
			lp->ends = ntohl(lv->ends);
			memcpy(&lp->ip_addr, &lv->ip_addr,
d323 1
a323 1
			memcpy(&lp->hardware_addr, &lv->hardware_addr,
d405 1
a405 1
	struct dhcp_synctlv_lease ld;
d417 1
a417 1
	bzero(&ld, sizeof(ld));
d423 1
a423 1
	leaselen = sizeof(ld);
d430 1
a430 1
	hdr.sh_length = htons(sizeof(hdr) + sizeof(ld) + padlen + sizeof(end));
d437 8
a444 8
	ld.type = htons(DHCP_SYNC_LEASE);
	ld.length = htons(leaselen + padlen);
	ld.timestamp = htonl(lease->timestamp);
	ld.starts = htonl(lease->starts);
	ld.ends =  htonl(lease->ends);
	memcpy(&ld.ip_addr, &lease->ip_addr, sizeof(ld.ip_addr));
	memcpy(&ld.hardware_addr, &lease->hardware_addr,
	    sizeof(ld.hardware_addr));
d446 5
a450 5
	    print_hw_addr(ld.hardware_addr.htype, ld.hardware_addr.hlen,
	    ld.hardware_addr.haddr), piaddr(lease->ip_addr), ntohl(ld.starts),
	    ntohl(ld.ends));
	iov[i].iov_base = &ld;
	iov[i].iov_len = sizeof(ld);
@


1.10
log
@Use the provided note() and warning() functions of dhcpd instead of
calling syslog_r() directly -- this make -d work as expected.
OK reyk@@, stsp@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sync.c,v 1.9 2010/03/27 14:11:38 krw Exp $	*/
d429 1
a429 1
	hdr.sh_length = htons(sizeof(hdr) + sizeof(ld) + sizeof(end));
@


1.9
log
@malloc/strlcpy -> strdup. Use consistent idiom.

ok (as part of larger diff) blambert@@ kettenis@@ stsp@@ zinovik@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sync.c,v 1.8 2010/01/03 18:37:06 deraadt Exp $	*/
a42 1
#include <syslog.h>
d113 2
a114 3
		syslog_r(LOG_DEBUG, &sdata, "added dhcp sync host %s "
		    "(address %s, port %d)\n", shost->h_name,
		    inet_ntoa(shost->sh_addr.sin_addr), port);
d286 1
a286 2
		syslog_r(LOG_DEBUG, &sdata,
		    "%s(sync): received packet of %d bytes\n",
d324 1
a324 2
			syslog_r(LOG_DEBUG, &sdata,
			    "DHCP_SYNC_LEASE from %s for hw %s -> ip %s, "
d328 2
a329 5
				lp->hardware_addr.hlen,
				lp->hardware_addr.haddr),
			    piaddr(lp->ip_addr),
			    lp->starts,
			    lp->ends);
d361 1
a361 2
		syslog_r(LOG_INFO, &sdata,
		    "%s(sync): truncated or invalid packet\n",
d381 1
a381 2
			syslog_r(LOG_DEBUG, &sdata,
			    "sending multicast sync message\n");
d384 2
a385 1
		sendmsg(syncfd, &msg, 0);
d390 1
a390 2
			syslog_r(LOG_DEBUG, &sdata,
			    "sending sync message to %s (%s)\n",
d394 2
a395 1
		sendmsg(syncfd, &msg, 0);
d444 1
a444 2
	syslog_r(LOG_DEBUG, &sdata,
	    "sending DHCP_SYNC_LEASE for hw %s -> ip %s, start %d, end %d",
d446 1
a446 3
		ld.hardware_addr.haddr),
	    piaddr(lease->ip_addr),
	    ntohl(ld.starts),
@


1.8
log
@unused prototype
@
text
@d1 1
a1 1
/*	$OpenBSD: sync.c,v 1.7 2008/09/15 20:38:17 claudio Exp $	*/
d99 2
a100 1
	if ((shost->h_name = strdup(name)) == NULL) {
@


1.7
log
@When checking if a syscall like open(), ioctl() or writev() failed compare
directly against -1 and do not use a < 0 test. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sync.c,v 1.6 2008/05/30 05:58:20 deraadt Exp $	*/
a70 1
void	 sync_addr(time_t, time_t, char *, u_int16_t);
@


1.6
log
@correct size of iov[]; ralf.horstmann@@gmx.de
@
text
@d1 1
a1 1
/*	$OpenBSD: sync.c,v 1.5 2008/05/11 08:50:54 beck Exp $	*/
d221 1
a221 1
	    sizeof(ttl)) < 0) {
@


1.5
log
@
fix sync.c to not puke if sync_lease called without sync_init.
from henric.
@
text
@d1 1
a1 1
/*	$OpenBSD: sync.c,v 1.4 2008/05/08 14:15:40 deraadt Exp $	*/
d410 1
a410 1
	struct iovec iov[3];
@


1.4
log
@Insert pad blocks after sub-messages to keep the structures aligned to
16 byte boundaries for maximum portability (somewhat similar to CMSG's)
ok beck
@
text
@d1 1
a1 1
/*	$OpenBSD: sync.c,v 1.3 2008/05/08 07:28:08 beck Exp $	*/
d419 3
@


1.3
log
@this should really only be in one file.
@
text
@d1 1
a1 1
/*	$OpenBSD: sync.c,v 1.2 2008/05/08 05:38:26 beck Exp $	*/
d414 2
d422 1
d427 3
d442 1
a442 1
	ld.length = htons(sizeof(ld));
d458 5
@


1.2
log
@don't break dhcpd when not using synch mechanisms..
@
text
@d1 1
a1 1
/*	$OpenBSD: sync.c,v 1.1 2008/05/07 12:19:20 beck Exp $	*/
d55 1
a55 1
int syncfd;
@


1.1
log
@Add synchronisation support for dhcpd - this allows for two dhcpd's
with the same configuration to be run on the same net and they will
keep their lease files/state in synch, and therefore allowing you to
run redundant dhcpd's. Synchronization code stolen from spamd, uses
an hmac key in /var/db/dhcpd.key if it exists.
ok krw@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sync.c,v 1.4 2007/12/27 10:50:06 reyk Exp $	*/
d378 3
@

