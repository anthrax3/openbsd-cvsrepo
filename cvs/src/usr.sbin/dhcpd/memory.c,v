head	1.28;
access;
symbols
	OPENBSD_6_1:1.28.0.4
	OPENBSD_6_1_BASE:1.28
	OPENBSD_6_0:1.25.0.4
	OPENBSD_6_0_BASE:1.25
	OPENBSD_5_9:1.25.0.2
	OPENBSD_5_9_BASE:1.25
	OPENBSD_5_8:1.23.0.6
	OPENBSD_5_8_BASE:1.23
	OPENBSD_5_7:1.23.0.2
	OPENBSD_5_7_BASE:1.23
	OPENBSD_5_6:1.22.0.4
	OPENBSD_5_6_BASE:1.22
	OPENBSD_5_5:1.21.0.4
	OPENBSD_5_5_BASE:1.21
	OPENBSD_5_4:1.20.0.14
	OPENBSD_5_4_BASE:1.20
	OPENBSD_5_3:1.20.0.12
	OPENBSD_5_3_BASE:1.20
	OPENBSD_5_2:1.20.0.10
	OPENBSD_5_2_BASE:1.20
	OPENBSD_5_1_BASE:1.20
	OPENBSD_5_1:1.20.0.8
	OPENBSD_5_0:1.20.0.6
	OPENBSD_5_0_BASE:1.20
	OPENBSD_4_9:1.20.0.4
	OPENBSD_4_9_BASE:1.20
	OPENBSD_4_8:1.20.0.2
	OPENBSD_4_8_BASE:1.20
	OPENBSD_4_7:1.19.0.2
	OPENBSD_4_7_BASE:1.19
	OPENBSD_4_6:1.15.0.8
	OPENBSD_4_6_BASE:1.15
	OPENBSD_4_5:1.15.0.4
	OPENBSD_4_5_BASE:1.15
	OPENBSD_4_4:1.15.0.2
	OPENBSD_4_4_BASE:1.15
	OPENBSD_4_3:1.14.0.8
	OPENBSD_4_3_BASE:1.14
	OPENBSD_4_2:1.14.0.6
	OPENBSD_4_2_BASE:1.14
	OPENBSD_4_1:1.14.0.4
	OPENBSD_4_1_BASE:1.14
	OPENBSD_4_0:1.14.0.2
	OPENBSD_4_0_BASE:1.14
	OPENBSD_3_9:1.10.0.6
	OPENBSD_3_9_BASE:1.10
	OPENBSD_3_8:1.10.0.4
	OPENBSD_3_8_BASE:1.10
	OPENBSD_3_7:1.10.0.2
	OPENBSD_3_7_BASE:1.10
	OPENBSD_3_6:1.8.0.2
	OPENBSD_3_6_BASE:1.8;
locks; strict;
comment	@ * @;


1.28
date	2017.02.13.23.04.05;	author krw;	state Exp;
branches;
next	1.27;
commitid	amfLXbU964CBXnkr;

1.27
date	2017.02.13.22.33.39;	author krw;	state Exp;
branches;
next	1.26;
commitid	aD6aChUv7GEv3CLZ;

1.26
date	2017.02.13.19.13.14;	author krw;	state Exp;
branches;
next	1.25;
commitid	syYFt6P4XI7prXRF;

1.25
date	2016.02.07.10.24.04;	author jsg;	state Exp;
branches;
next	1.24;
commitid	VjZu9SYTCbld6IJ5;

1.24
date	2016.02.06.23.50.10;	author krw;	state Exp;
branches;
next	1.23;
commitid	8GMcSAoPYCa1rXN3;

1.23
date	2015.02.10.23.06.13;	author krw;	state Exp;
branches;
next	1.22;
commitid	p36BUdl6pVoUSJM4;

1.22
date	2014.06.11.16.45.15;	author pelikan;	state Exp;
branches;
next	1.21;
commitid	NbG26tGSsKbvQUxZ;

1.21
date	2013.10.18.13.44.35;	author krw;	state Exp;
branches;
next	1.20;

1.20
date	2010.03.27.14.11.38;	author krw;	state Exp;
branches;
next	1.19;

1.19
date	2010.01.01.20.30.25;	author krw;	state Exp;
branches;
next	1.18;

1.18
date	2010.01.01.06.25.37;	author krw;	state Exp;
branches;
next	1.17;

1.17
date	2010.01.01.01.47.41;	author krw;	state Exp;
branches;
next	1.16;

1.16
date	2009.12.10.01.22.09;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2008.05.07.12.19.20;	author beck;	state Exp;
branches;
next	1.14;

1.14
date	2006.08.09.22.23.53;	author cloder;	state Exp;
branches;
next	1.13;

1.13
date	2006.06.14.14.58.52;	author ckuethe;	state Exp;
branches;
next	1.12;

1.12
date	2006.06.14.14.49.46;	author ckuethe;	state Exp;
branches;
next	1.11;

1.11
date	2006.05.31.02.43.15;	author ckuethe;	state Exp;
branches;
next	1.10;

1.10
date	2004.09.21.04.07.04;	author david;	state Exp;
branches
	1.10.4.1
	1.10.6.1;
next	1.9;

1.9
date	2004.09.16.18.35.43;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2004.05.11.04.08.35;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2004.05.04.20.28.40;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2004.04.20.05.35.33;	author henning;	state Exp;
branches;
next	1.5;

1.5
date	2004.04.18.00.43.27;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2004.04.16.04.30.09;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2004.04.14.04.34.19;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2004.04.13.23.57.49;	author henning;	state Exp;
branches;
next	1.1;

1.1
date	2004.04.13.23.41.48;	author henning;	state Exp;
branches;
next	;

1.10.4.1
date	2006.08.10.01.54.02;	author brad;	state Exp;
branches;
next	;

1.10.6.1
date	2006.08.10.01.51.15;	author brad;	state Exp;
branches;
next	;


desc
@@


1.28
log
@Eliminate pointless'%m' (a.k.a. hand rolled strerror()) by using fatal() and
log_warn(). Zap a couple of explicit 'syslog()' calls.
@
text
@/*	$OpenBSD: memory.c,v 1.27 2017/02/13 22:33:39 krw Exp $ */

/*
 * Copyright (c) 1995, 1996, 1997, 1998 The Internet Software Consortium.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of The Internet Software Consortium nor the names
 *    of its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INTERNET SOFTWARE CONSORTIUM AND
 * CONTRIBUTORS ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE INTERNET SOFTWARE CONSORTIUM OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This software has been written for the Internet Software Consortium
 * by Ted Lemon <mellon@@fugue.com> in cooperation with Vixie
 * Enterprises.  To learn more about the Internet Software Consortium,
 * see ``http://www.vix.com/isc''.  To learn more about Vixie
 * Enterprises, see ``http://www.vix.com''.
 */

#include <sys/types.h>
#include <sys/socket.h>

#include <arpa/inet.h>

#include <net/if.h>

#include <netdb.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "dhcp.h"
#include "tree.h"
#include "dhcpd.h"
#include "log.h"
#include "sync.h"

struct subnet *subnets;
static struct shared_network *shared_networks;
static struct hash_table *host_hw_addr_hash;
static struct hash_table *host_uid_hash;
static struct hash_table *lease_uid_hash;
static struct hash_table *lease_ip_addr_hash;
static struct hash_table *lease_hw_addr_hash;
static struct lease *dangling_leases;

static struct hash_table *vendor_class_hash;
static struct hash_table *user_class_hash;

extern int syncsend;

void
enter_host(struct host_decl *hd)
{
	struct host_decl *hp = NULL, *np = NULL;

	hd->n_ipaddr = NULL;
	if (hd->interface.hlen) {
		if (!host_hw_addr_hash)
			host_hw_addr_hash = new_hash();
		else
			hp = (struct host_decl *)hash_lookup(host_hw_addr_hash,
			    hd->interface.haddr, hd->interface.hlen);

		/*
		 * If there isn't already a host decl matching this
		 * address, add it to the hash table.
		 */
		if (!hp)
			add_hash(host_hw_addr_hash, hd->interface.haddr,
			    hd->interface.hlen, (unsigned char *)hd);
	}

	/*
	 * If there was already a host declaration for this hardware
	 * address, add this one to the end of the list.
	 */
	if (hp) {
		for (np = hp; np->n_ipaddr; np = np->n_ipaddr)
			;
		np->n_ipaddr = hd;
	}

	if (hd->group->options[DHO_DHCP_CLIENT_IDENTIFIER]) {
		if (!tree_evaluate(
		    hd->group->options[DHO_DHCP_CLIENT_IDENTIFIER]))
			return;

		/* If there's no uid hash, make one; otherwise, see if
		   there's already an entry in the hash for this host. */
		if (!host_uid_hash) {
			host_uid_hash = new_hash();
			hp = NULL;
		} else
			hp = (struct host_decl *)hash_lookup(host_uid_hash,
			    hd->group->options[DHO_DHCP_CLIENT_IDENTIFIER]->value,
			    hd->group->options[DHO_DHCP_CLIENT_IDENTIFIER]->len);

		/*
		 * If there's already a host declaration for this
		 * client identifier, add this one to the end of the
		 * list.  Otherwise, add it to the hash table.
		 */
		if (hp) {
			/* Don't link it in twice... */
			if (!np) {
				for (np = hp; np->n_ipaddr;
				    np = np->n_ipaddr)
					;
				np->n_ipaddr = hd;
			}
		} else {
			add_hash(host_uid_hash,
			    hd->group->options[DHO_DHCP_CLIENT_IDENTIFIER]->value,
			    hd->group->options[DHO_DHCP_CLIENT_IDENTIFIER]->len,
			    (unsigned char *)hd);
		}
	}
}

struct host_decl *
find_hosts_by_haddr(int htype, unsigned char *haddr, int hlen)
{
	return (struct host_decl *)hash_lookup(host_hw_addr_hash,
	    haddr, hlen);
}

struct host_decl *
find_hosts_by_uid(unsigned char *data, int len)
{
	return (struct host_decl *)hash_lookup(host_uid_hash, data, len);
}

/*
 * More than one host_decl can be returned by find_hosts_by_haddr or
 * find_hosts_by_uid, and each host_decl can have multiple addresses.
 * Loop through the list of hosts, and then for each host, through the
 * list of addresses, looking for an address that's in the same shared
 * network as the one specified.    Store the matching address through
 * the addr pointer, update the host pointer to point at the host_decl
 * that matched, and return the subnet that matched.
 */
struct subnet *
find_host_for_network(struct host_decl **host, struct iaddr *addr,
    struct shared_network *share)
{
	struct subnet *subnet;
	struct iaddr ip_address;
	struct host_decl *hp;
	int i;

	for (hp = *host; hp; hp = hp->n_ipaddr) {
		if (!hp->fixed_addr || !tree_evaluate(hp->fixed_addr))
			continue;
		for (i = 0; i < hp->fixed_addr->len; i += 4) {
			ip_address.len = 4;
			memcpy(ip_address.iabuf, hp->fixed_addr->value + i, 4);
			subnet = find_grouped_subnet(share, ip_address);
			if (subnet) {
				*addr = ip_address;
				*host = hp;
				return subnet;
			}
		}
	}
	return NULL;
}

void
new_address_range(struct iaddr low, struct iaddr high, struct subnet *subnet,
    int dynamic)
{
	struct lease *address_range, *lp, *plp;
	struct iaddr net;
	int min, max, i;
	char lowbuf[16], highbuf[16], netbuf[16];
	struct shared_network *share = subnet->shared_network;
	struct hostent *h;
	struct in_addr ia;

	/* All subnets should have attached shared network structures. */
	if (!share) {
		strlcpy(netbuf, piaddr(subnet->net), sizeof(netbuf));
		fatalx("No shared network for network %s (%s)",
		    netbuf, piaddr(subnet->netmask));
	}

	/* Initialize the hash table if it hasn't been done yet. */
	if (!lease_uid_hash)
		lease_uid_hash = new_hash();
	if (!lease_ip_addr_hash)
		lease_ip_addr_hash = new_hash();
	if (!lease_hw_addr_hash)
		lease_hw_addr_hash = new_hash();

	/* Make sure that high and low addresses are in same subnet. */
	net = subnet_number(low, subnet->netmask);
	if (!addr_eq(net, subnet_number(high, subnet->netmask))) {
		strlcpy(lowbuf, piaddr(low), sizeof(lowbuf));
		strlcpy(highbuf, piaddr(high), sizeof(highbuf));
		strlcpy(netbuf, piaddr(subnet->netmask), sizeof(netbuf));
		fatalx("Address range %s to %s, netmask %s spans %s!",
		    lowbuf, highbuf, netbuf, "multiple subnets");
	}

	/* Make sure that the addresses are on the correct subnet. */
	if (!addr_eq(net, subnet->net)) {
		strlcpy(lowbuf, piaddr(low), sizeof(lowbuf));
		strlcpy(highbuf, piaddr(high), sizeof(highbuf));
		strlcpy(netbuf, piaddr(subnet->netmask), sizeof(netbuf));
		fatalx("Address range %s to %s not on net %s/%s!",
		    lowbuf, highbuf, piaddr(subnet->net), netbuf);
	}

	/* Get the high and low host addresses... */
	max = host_addr(high, subnet->netmask);
	min = host_addr(low, subnet->netmask);

	/* Allow range to be specified high-to-low as well as low-to-high. */
	if (min > max) {
		max = min;
		min = host_addr(high, subnet->netmask);
	}

	/* Get a lease structure for each address in the range. */
	address_range = calloc(max - min + 1, sizeof(struct lease));
	if (!address_range) {
		strlcpy(lowbuf, piaddr(low), sizeof(lowbuf));
		strlcpy(highbuf, piaddr(high), sizeof(highbuf));
		fatalx("No memory for address range %s-%s.", lowbuf, highbuf);
	}
	memset(address_range, 0, (sizeof *address_range) * (max - min + 1));

	/* Fill in the last lease if it hasn't been already... */
	if (!share->last_lease)
		share->last_lease = &address_range[0];

	/* Fill out the lease structures with some minimal information. */
	for (i = 0; i < max - min + 1; i++) {
		address_range[i].ip_addr = ip_addr(subnet->net,
		    subnet->netmask, i + min);
		address_range[i].starts = address_range[i].timestamp =
		    MIN_TIME;
		address_range[i].ends = MIN_TIME;
		address_range[i].subnet = subnet;
		address_range[i].shared_network = share;
		address_range[i].flags = dynamic ? DYNAMIC_BOOTP_OK : 0;

		memcpy(&ia, address_range[i].ip_addr.iabuf, 4);

		if (subnet->group->get_lease_hostnames) {
			h = gethostbyaddr((char *)&ia, sizeof ia, AF_INET);
			if (!h)
				log_warnx("No hostname for %s", inet_ntoa(ia));
			else {
				address_range[i].hostname = strdup(h->h_name);
				if (address_range[i].hostname == NULL)
					fatalx("no memory for hostname %s.",
					    h->h_name);
			}
		}

		/* Link this entry into the list. */
		address_range[i].next = share->leases;
		address_range[i].prev = NULL;
		share->leases = &address_range[i];
		if (address_range[i].next)
			address_range[i].next->prev = share->leases;
		add_hash(lease_ip_addr_hash, address_range[i].ip_addr.iabuf,
		    address_range[i].ip_addr.len,
		    (unsigned char *)&address_range[i]);
	}

	/* Find out if any dangling leases are in range... */
	plp = NULL;
	for (lp = dangling_leases; lp; lp = lp->next) {
		struct iaddr lnet;
		int lhost;

		lnet = subnet_number(lp->ip_addr, subnet->netmask);
		lhost = host_addr(lp->ip_addr, subnet->netmask);

		/* If it's in range, fill in the real lease structure with
		   the dangling lease's values, and remove the lease from
		   the list of dangling leases. */
		if (addr_eq(lnet, subnet->net) && lhost >= i && lhost <= max) {
			if (plp) {
				plp->next = lp->next;
			} else {
				dangling_leases = lp->next;
			}
			lp->next = NULL;
			address_range[lhost - i].hostname = lp->hostname;
			address_range[lhost - i].client_hostname =
			    lp->client_hostname;
			supersede_lease(&address_range[lhost - i], lp, 0);
			free(lp);
			return;
		} else
			plp = lp;
	}
}

struct subnet *
find_subnet(struct iaddr addr)
{
	struct subnet *rv;

	for (rv = subnets; rv; rv = rv->next_subnet) {
		if (addr_eq(subnet_number(addr, rv->netmask), rv->net))
			return rv;
	}
	return NULL;
}

struct subnet *
find_grouped_subnet(struct shared_network *share, struct iaddr addr)
{
	struct subnet *rv;

	for (rv = share->subnets; rv; rv = rv->next_sibling) {
		if (addr_eq(subnet_number(addr, rv->netmask), rv->net))
			return rv;
	}
	return NULL;
}

int
subnet_inner_than(struct subnet *subnet, struct subnet *scan, int warnp)
{
	if (addr_eq(subnet_number(subnet->net, scan->netmask), scan->net) ||
	    addr_eq(subnet_number(scan->net, subnet->netmask), subnet->net)) {
		char n1buf[16];
		int i, j;

		for (i = 0; i < 32; i++)
			if (subnet->netmask.iabuf[3 - (i >> 3)] &
			    (1 << (i & 7)))
				break;
		for (j = 0; j < 32; j++)
			if (scan->netmask.iabuf[3 - (j >> 3)] &
			    (1 << (j & 7)))
				break;
		strlcpy(n1buf, piaddr(subnet->net), sizeof(n1buf));
		if (warnp)
			log_warnx("%ssubnet %s/%d conflicts with subnet %s/%d",
			    "Warning: ", n1buf, 32 - i,
			    piaddr(scan->net), 32 - j);
		if (i < j)
			return 1;
	}
	return 0;
}

/* Enter a new subnet into the subnet list. */
void
enter_subnet(struct subnet *subnet)
{
	struct subnet *scan, *prev = NULL;

	/* Check for duplicates... */
	for (scan = subnets; scan; scan = scan->next_subnet) {
		/*
		 * When we find a conflict, make sure that the
		 * subnet with the narrowest subnet mask comes
		 * first.
		 */
		if (subnet_inner_than(subnet, scan, 1)) {
			if (prev) {
				prev->next_subnet = subnet;
			} else
				subnets = subnet;
			subnet->next_subnet = scan;
			return;
		}
		prev = scan;
	}

	/* XXX use the BSD radix tree code instead of a linked list. */
	subnet->next_subnet = subnets;
	subnets = subnet;
}

/* Enter a new shared network into the shared network list. */
void
enter_shared_network(struct shared_network *share)
{
	/* XXX Sort the nets into a balanced tree to make searching quicker. */
	share->next = shared_networks;
	shared_networks = share;
}

/*
 * Enter a lease into the system.   This is called by the parser each
 * time it reads in a new lease.   If the subnet for that lease has
 * already been read in (usually the case), just update that lease;
 * otherwise, allocate temporary storage for the lease and keep it around
 * until we're done reading in the config file.
 */
void
enter_lease(struct lease *lease)
{
	struct lease *comp = find_lease_by_ip_addr(lease->ip_addr);

	/* If we don't have a place for this lease yet, save it for later. */
	if (!comp) {
		comp = calloc(1, sizeof(struct lease));
		if (!comp)
			fatalx("No memory for lease %s\n",
			    piaddr(lease->ip_addr));
		*comp = *lease;
		comp->next = dangling_leases;
		comp->prev = NULL;
		dangling_leases = comp;
	} else {
		/* Record the hostname information in the lease. */
		comp->hostname = lease->hostname;
		comp->client_hostname = lease->client_hostname;
		supersede_lease(comp, lease, 0);
	}
}

static inline int
hwaddrcmp(struct hardware *a, struct hardware *b)
{
	return ((a->htype != b->htype) || (a->hlen != b->hlen) ||
	    memcmp(a->haddr, b->haddr, b->hlen));
}

static inline int
uidcmp(struct lease *a, struct lease *b)
{
	return (a->uid_len != b->uid_len || memcmp(a->uid, b->uid,
	    b->uid_len));
}

static inline int
uid_or_hwaddr_cmp(struct lease *a, struct lease *b)
{
	if (a->uid && b->uid)
		return uidcmp(a, b);
	return hwaddrcmp(&a->hardware_addr, &b->hardware_addr);
}

/*
 * Replace the data in an existing lease with the data in a new lease;
 * adjust hash tables to suit, and insertion sort the lease into the
 * list of leases by expiry time so that we can always find the oldest
 * lease.
 */
int
supersede_lease(struct lease *comp, struct lease *lease, int commit)
{
	int enter_uid = 0;
	int enter_hwaddr = 0;
	int do_pftable = 0;
	struct lease *lp;

	/* Static leases are not currently kept in the database... */
	if (lease->flags & STATIC_LEASE)
		return 1;

	/*
	 * If the existing lease hasn't expired and has a different
	 * unique identifier or, if it doesn't have a unique
	 * identifier, a different hardware address, then the two
	 * leases are in conflict.  If the existing lease has a uid
	 * and the new one doesn't, but they both have the same
	 * hardware address, and dynamic bootp is allowed on this
	 * lease, then we allow that, in case a dynamic BOOTP lease is
	 * requested *after* a DHCP lease has been assigned.
	 */
	if (!(lease->flags & ABANDONED_LEASE) &&
	    comp->ends > cur_time && uid_or_hwaddr_cmp(comp, lease)) {
		log_warnx("Lease conflict at %s", piaddr(comp->ip_addr));
		return 0;
	} else {
		/* If there's a Unique ID, dissociate it from the hash
		   table and free it if necessary. */
		if (comp->uid) {
			uid_hash_delete(comp);
			enter_uid = 1;
			if (comp->uid != &comp->uid_buf[0]) {
				free(comp->uid);
				comp->uid_max = 0;
				comp->uid_len = 0;
			}
			comp->uid = NULL;
		} else
			enter_uid = 1;

		if (comp->hardware_addr.htype &&
		    hwaddrcmp(&comp->hardware_addr, &lease->hardware_addr)) {
			hw_hash_delete(comp);
			enter_hwaddr = 1;
			do_pftable = 1;
		} else if (!comp->hardware_addr.htype) {
			enter_hwaddr = 1;
			do_pftable = 1;
		}

		/* Copy the data files, but not the linkages. */
		comp->starts = lease->starts;
		if (lease->uid) {
			if (lease->uid_len <= sizeof (lease->uid_buf)) {
				memcpy(comp->uid_buf, lease->uid,
				    lease->uid_len);
				comp->uid = &comp->uid_buf[0];
				comp->uid_max = sizeof comp->uid_buf;
			} else if (lease->uid != &lease->uid_buf[0]) {
				comp->uid = lease->uid;
				comp->uid_max = lease->uid_max;
				lease->uid = NULL;
				lease->uid_max = 0;
			} else {
				fatalx("corrupt lease uid."); /* XXX */
			}
		} else {
			comp->uid = NULL;
			comp->uid_max = 0;
		}
		comp->uid_len = lease->uid_len;
		comp->host = lease->host;
		comp->hardware_addr = lease->hardware_addr;
		comp->flags = ((lease->flags & ~PERSISTENT_FLAGS) |
		    (comp->flags & ~EPHEMERAL_FLAGS));

		/* Record the lease in the uid hash if necessary. */
		if (enter_uid && lease->uid)
			uid_hash_add(comp);

		/* Record it in the hardware address hash if necessary. */
		if (enter_hwaddr && lease->hardware_addr.htype)
			hw_hash_add(comp);

		/* Remove the lease from its current place in the
		   timeout sequence. */
		if (comp->prev)
			comp->prev->next = comp->next;
		else
			comp->shared_network->leases = comp->next;
		if (comp->next)
			comp->next->prev = comp->prev;
		if (comp->shared_network->last_lease == comp)
			comp->shared_network->last_lease = comp->prev;

		/* Find the last insertion point... */
		if (comp == comp->shared_network->insertion_point ||
		    !comp->shared_network->insertion_point)
			lp = comp->shared_network->leases;
		else
			lp = comp->shared_network->insertion_point;

		if (!lp) {
			/* Nothing on the list yet?    Just make comp the
			   head of the list. */
			comp->shared_network->leases = comp;
			comp->shared_network->last_lease = comp;
		} else if (lp->ends > lease->ends) {
			/* Skip down the list until we run out of list
			   or find a place for comp. */
			while (lp->next && lp->ends > lease->ends) {
				lp = lp->next;
			}
			if (lp->ends > lease->ends) {
				/* If we ran out of list, put comp
				   at the end. */
				lp->next = comp;
				comp->prev = lp;
				comp->next = NULL;
				comp->shared_network->last_lease = comp;
			} else {
				/* If we didn't, put it between lp and
				   the previous item on the list. */
				if ((comp->prev = lp->prev))
					comp->prev->next = comp;
				comp->next = lp;
				lp->prev = comp;
			}
		} else {
			/* Skip up the list until we run out of list
			   or find a place for comp. */
			while (lp->prev && lp->ends < lease->ends) {
				lp = lp->prev;
			}
			if (lp->ends < lease->ends) {
				/* If we ran out of list, put comp
				   at the beginning. */
				lp->prev = comp;
				comp->next = lp;
				comp->prev = NULL;
				comp->shared_network->leases = comp;
			} else {
				/* If we didn't, put it between lp and
				   the next item on the list. */
				if ((comp->next = lp->next))
					comp->next->prev = comp;
				comp->prev = lp;
				lp->next = comp;
			}
		}
		comp->shared_network->insertion_point = comp;
		comp->ends = lease->ends;
	}

	pfmsg('L', lease); /* address is leased. remove from purgatory */
	if (do_pftable) /* address changed hwaddr. remove from overload */
		pfmsg('C', lease);

	/* Return zero if we didn't commit the lease to permanent storage;
	   nonzero if we did. */
	return commit && write_lease(comp) && commit_leases();
}

/* Release the specified lease and re-hash it as appropriate. */

void
release_lease(struct lease *lease)
{
	struct lease lt;

	lt = *lease;
	if (lt.ends > cur_time) {
		lt.ends = cur_time;
		supersede_lease(lease, &lt, 1);
		log_info("Released lease for IP address %s",
		    piaddr(lease->ip_addr));
		pfmsg('R', lease);
	}
}


/*
 * Abandon the specified lease for the specified time. sets it's
 * particulars to zero, the end time appropriately and re-hash it as
 * appropriate. abandons permanently if abtime is 0
 */
void
abandon_lease(struct lease *lease, char *message)
{
	struct lease lt;
	time_t abtime;

	abtime = lease->subnet->group->default_lease_time;
	lease->flags |= ABANDONED_LEASE;
	lt = *lease;
	lt.ends = cur_time + abtime;
	log_warnx("Abandoning IP address %s for %lld seconds: %s",
	    piaddr(lease->ip_addr), (long long)abtime, message);
	lt.hardware_addr.htype = 0;
	lt.hardware_addr.hlen = 0;
	lt.uid = NULL;
	lt.uid_len = 0;
	supersede_lease(lease, &lt, 1);

	pfmsg('A', lease); /* address is abandoned. send to purgatory */
	return;
}

/* Locate the lease associated with a given IP address... */
struct lease *
find_lease_by_ip_addr(struct iaddr addr)
{
	return (struct lease *)hash_lookup(lease_ip_addr_hash,
	    addr.iabuf, addr.len);
}

struct lease *find_lease_by_uid(unsigned char *uid, int len)
{
	return (struct lease *)hash_lookup(lease_uid_hash, uid, len);
}

struct lease *
find_lease_by_hw_addr(unsigned char *hwaddr, int hwlen)
{
	return (struct lease *)hash_lookup(lease_hw_addr_hash, hwaddr, hwlen);
}

/* Add the specified lease to the uid hash. */
void
uid_hash_add(struct lease *lease)
{
	struct lease *head = find_lease_by_uid(lease->uid, lease->uid_len);
	struct lease *scan;

	/* If it's not in the hash, just add it. */
	if (!head)
		add_hash(lease_uid_hash, lease->uid,
		    lease->uid_len, (unsigned char *)lease);
	else {
		/* Otherwise, attach it to the end of the list. */
		for (scan = head; scan->n_uid; scan = scan->n_uid)
			;
		scan->n_uid = lease;
	}
}

/* Delete the specified lease from the uid hash. */
void
uid_hash_delete(struct lease *lease)
{
	struct lease *head = find_lease_by_uid(lease->uid, lease->uid_len);
	struct lease *scan;

	/* If it's not in the hash, we have no work to do. */
	if (!head) {
		lease->n_uid = NULL;
		return;
	}

	/* If the lease we're freeing is at the head of the list,
	   remove the hash table entry and add a new one with the
	   next lease on the list (if there is one). */
	if (head == lease) {
		delete_hash_entry(lease_uid_hash, lease->uid, lease->uid_len);
		if (lease->n_uid)
			add_hash(lease_uid_hash, lease->n_uid->uid,
			    lease->n_uid->uid_len,
			    (unsigned char *)(lease->n_uid));
	} else {
		/* Otherwise, look for the lease in the list of leases
		   attached to the hash table entry, and remove it if
		   we find it. */
		for (scan = head; scan->n_uid; scan = scan->n_uid) {
			if (scan->n_uid == lease) {
				scan->n_uid = scan->n_uid->n_uid;
				break;
			}
		}
	}
	lease->n_uid = NULL;
}

/* Add the specified lease to the hardware address hash. */
void
hw_hash_add(struct lease *lease)
{
	struct lease *head = find_lease_by_hw_addr(lease->hardware_addr.haddr,
	    lease->hardware_addr.hlen);
	struct lease *scan;

	/* If it's not in the hash, just add it. */
	if (!head)
		add_hash(lease_hw_addr_hash, lease->hardware_addr.haddr,
		    lease->hardware_addr.hlen, (unsigned char *)lease);
	else {
		/* Otherwise, attach it to the end of the list. */
		for (scan = head; scan->n_hw; scan = scan->n_hw)
			;
		scan->n_hw = lease;
	}
}

/* Delete the specified lease from the hardware address hash. */
void
hw_hash_delete(struct lease *lease)
{
	struct lease *head = find_lease_by_hw_addr(lease->hardware_addr.haddr,
	    lease->hardware_addr.hlen);
	struct lease *scan;

	/* If it's not in the hash, we have no work to do. */
	if (!head) {
		lease->n_hw = NULL;
		return;
	}

	/* If the lease we're freeing is at the head of the list,
	   remove the hash table entry and add a new one with the
	   next lease on the list (if there is one). */
	if (head == lease) {
		delete_hash_entry(lease_hw_addr_hash,
		    lease->hardware_addr.haddr, lease->hardware_addr.hlen);
		if (lease->n_hw)
			add_hash(lease_hw_addr_hash,
			    lease->n_hw->hardware_addr.haddr,
			    lease->n_hw->hardware_addr.hlen,
			    (unsigned char *)(lease->n_hw));
	} else {
		/*
		 * Otherwise, look for the lease in the list of leases
		 * attached to the hash table entry, and remove it if
		 * we find it.
		 */
		for (scan = head; scan->n_hw; scan = scan->n_hw) {
			if (scan->n_hw == lease) {
				scan->n_hw = scan->n_hw->n_hw;
				break;
			}
		}
	}
	lease->n_hw = NULL;
}


struct class *
add_class(int type, char *name)
{
	struct class *class;
	char *tname;

	class = calloc(1, sizeof(*class));
	tname = strdup(name);

	if (!vendor_class_hash)
		vendor_class_hash = new_hash();
	if (!user_class_hash)
		user_class_hash = new_hash();

	if (!tname || !class || !vendor_class_hash || !user_class_hash) {
		log_warnx("No memory for %s.", name);
		free(class);
		free(tname);
		return NULL;
	}

	class->name = tname;

	if (type)
		add_hash(user_class_hash, (unsigned char *)tname,
		    strlen(tname), (unsigned char *)class);
	else
		add_hash(vendor_class_hash, (unsigned char *)tname,
		    strlen(tname), (unsigned char *)class);

	return class;
}

struct class *
find_class(int type, unsigned char *name, int len)
{
	return (struct class *)hash_lookup(type ? user_class_hash :
	    vendor_class_hash, name, len);
}

struct group *
clone_group(struct group *group, char *caller)
{
	struct group *g;

	g = calloc(1, sizeof(struct group));
	if (!g)
		fatalx("%s: can't allocate new group", caller);
	*g = *group;
	return g;
}

/* Write all interesting leases to permanent storage. */

void
write_leases(void)
{
	struct lease *l;
	struct shared_network *s;

	for (s = shared_networks; s; s = s->next) {
		for (l = s->leases; l; l = l->next) {
			if (l->hardware_addr.hlen || l->uid_len ||
			    (l->flags & ABANDONED_LEASE)) {
				if (!write_lease(l))
					fatalx("Can't rewrite lease database");
				if (syncsend)
					sync_lease(l);
			}
		}
	}
	if (!commit_leases())
		fatal("Can't commit leases to new database");
}
@


1.27
log
@Adjust some long lines.
@
text
@d1 1
a1 1
/*	$OpenBSD: memory.c,v 1.26 2017/02/13 19:13:14 krw Exp $ */
d889 1
a889 1
		fatalx("Can't commit leases to new database: %m");
@


1.26
log
@Switch from old errwarn.c logging to shiny new log.[ch].

ok benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: memory.c,v 1.25 2016/02/07 10:24:04 jsg Exp $ */
d106 2
a107 1
		if (!tree_evaluate(hd->group->options[DHO_DHCP_CLIENT_IDENTIFIER]))
d263 2
a264 1
		address_range[i].starts = address_range[i].timestamp = MIN_TIME;
d454 2
a455 1
	return (a->uid_len != b->uid_len || memcmp(a->uid, b->uid, b->uid_len));
d527 2
a528 1
				memcpy(comp->uid_buf, lease->uid, lease->uid_len);
@


1.25
log
@avoid a use after free when parsing address ranges from a config
ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: memory.c,v 1.24 2016/02/06 23:50:10 krw Exp $ */
d56 1
d204 1
a204 1
		error("No shared network for network %s (%s)",
d222 1
a222 1
		error("Address range %s to %s, netmask %s spans %s!",
d231 1
a231 1
		error("Address range %s to %s not on net %s/%s!",
d250 1
a250 1
		error("No memory for address range %s-%s.", lowbuf, highbuf);
d273 1
a273 1
				warning("No hostname for %s", inet_ntoa(ia));
d277 1
a277 1
					error("no memory for hostname %s.",
d365 1
a365 1
			warning("%ssubnet %s/%d conflicts with subnet %s/%d",
d428 1
a428 1
			error("No memory for lease %s\n",
d493 1
a493 1
		warning("Lease conflict at %s", piaddr(comp->ip_addr));
d533 1
a533 1
				error("corrupt lease uid."); /* XXX */
d643 1
a643 1
		note("Released lease for IP address %s",
d665 1
a665 1
	warning("Abandoning IP address %s for %lld seconds: %s",
d828 1
a828 1
		warning("No memory for %s.", name);
d860 1
a860 1
		error("%s: can't allocate new group", caller);
d878 1
a878 1
					error("Can't rewrite lease database");
d885 1
a885 1
		error("Can't commit leases to new database: %m");
@


1.24
log
@Eliminate #include inside *.h files and include only needed headers in
each *.c file.

Inspired by mention of header silliness by Edgar Pettijohn and mmcc@@
on tech@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: memory.c,v 1.23 2015/02/10 23:06:13 krw Exp $ */
d316 1
@


1.23
log
@Keep track of the last time we scanned the leases to find expired
ones that needed to be booted out of the pf table process. This
avoids removing the same addess over and over.

Problem report and original diff from Bertrand Provost.
@
text
@d1 1
a1 1
/*	$OpenBSD: memory.c,v 1.22 2014/06/11 16:45:15 pelikan Exp $ */
d41 14
@


1.22
log
@Prettify & refactor, no functional change.

ok beck
@
text
@d1 1
a1 1
/*	$OpenBSD: memory.c,v 1.21 2013/10/18 13:44:35 krw Exp $ */
d629 1
@


1.21
log
@%d -> %lld, add (long long) cast to time_t variables. Make guenther
and gcc happier. Found while looking at something else for dlg@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: memory.c,v 1.20 2010/03/27 14:11:38 krw Exp $ */
d426 21
d476 1
a476 11
	    comp->ends > cur_time &&
	    (((comp->uid && lease->uid) &&
	    (comp->uid_len != lease->uid_len ||
	    memcmp (comp->uid, lease->uid, comp->uid_len))) ||
	    (!comp->uid &&
	    ((comp->hardware_addr.htype !=
	    lease->hardware_addr.htype) ||
	    (comp->hardware_addr.hlen !=
	    lease->hardware_addr.hlen) ||
	    memcmp(comp->hardware_addr.haddr, lease->hardware_addr.haddr,
	    comp->hardware_addr.hlen))))) {
d495 1
a495 6
		    ((comp->hardware_addr.hlen !=
		    lease->hardware_addr.hlen) ||
		    (comp->hardware_addr.htype !=
		    lease->hardware_addr.htype) ||
		    memcmp(comp->hardware_addr.haddr, lease->hardware_addr.haddr,
		    comp->hardware_addr.hlen))) {
@


1.20
log
@malloc/strlcpy -> strdup. Use consistent idiom.

ok (as part of larger diff) blambert@@ kettenis@@ stsp@@ zinovik@@
@
text
@d1 1
a1 1
/*	$OpenBSD: memory.c,v 1.19 2010/01/01 20:30:25 krw Exp $ */
d642 2
a643 2
	warning("Abandoning IP address %s for %d seconds: %s",
	    piaddr(lease->ip_addr), abtime, message);
@


1.19
log
@Wrappers around a wrapper around free() are of no more use than
wrappers around wrappers around calloc().

The purpose of the free() wrapper is to generate an error message
when free'ing NULL. But free_hash_bucket(), free_lease(), and
free_tree() are all called immediately after dereferencing the
pointer to be freed. Thus the error message will never be issued.
@
text
@d1 1
a1 1
/*	$OpenBSD: memory.c,v 1.18 2010/01/01 06:25:37 krw Exp $ */
d260 2
a261 4
				int len = strlen(h->h_name) + 1;

				address_range[i].hostname = malloc(len);
				if (!address_range[i].hostname)
a263 2
				strlcpy(address_range[i].hostname,
				    h->h_name, len);
@


1.18
log
@Single-use wrapper functions that just call a wrapper function
around calloc() and end up producing duplicate error messages are
just confusing.

Eliminate new_hash_bucket(), new_lease(), new_leases(), new_group().
@
text
@d1 1
a1 1
/*	$OpenBSD: memory.c,v 1.17 2010/01/01 01:47:41 krw Exp $ */
d305 1
a305 1
			free_lease(lp, "new_address_range");
@


1.17
log
@Plug a potential leak similar to the one parfait spotted and Theo
fixed.

Eliminate the function new_class() by expanding the only use

Use strdup() and calloc() rather than manually simulating them.

No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: memory.c,v 1.16 2009/12/10 01:22:09 deraadt Exp $ */
d231 1
a231 1
	address_range = new_leases(max - min + 1, "new_address_range");
d414 1
a414 1
		comp = new_lease("enter_lease");
d837 3
a839 1
	struct group *g = new_group(caller);
@


1.16
log
@plug memory leak, spotted by parfait; ok krw
@
text
@d1 1
a1 1
/*	$OpenBSD: memory.c,v 1.15 2008/05/07 12:19:20 beck Exp $ */
d797 5
a801 2
	struct class *class = new_class("add_class");
	char *tname = malloc(strlen(name) + 1);
d809 2
a814 2
	memset(class, 0, sizeof *class);
	strlcpy(tname, name, strlen(name) + 1);
d823 1
@


1.15
log
@Add synchronisation support for dhcpd - this allows for two dhcpd's
with the same configuration to be run on the same net and they will
keep their lease files/state in synch, and therefore allowing you to
run redundant dhcpd's. Synchronization code stolen from spamd, uses
an hmac key in /var/db/dhcpd.key if it exists.
ok krw@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: memory.c,v 1.14 2006/08/09 22:23:53 cloder Exp $ */
d805 2
a806 1
	if (!tname || !class || !vendor_class_hash || !user_class_hash)
d808 1
@


1.14
log
@Fix a reliability issue in dhcpd where a DHCPDISCOVER packet with a 32-byte
client identifier would cause dhcpd to mistakenly exit. From Debian bug
380273, affecting ISC dhcpd 2.x, upon which our dhcpd is based.

OK beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: memory.c,v 1.13 2006/06/14 14:58:52 ckuethe Exp $ */
d42 1
d56 2
d849 1
a849 1
			    (l->flags & ABANDONED_LEASE))
d852 3
@


1.13
log
@This diff allows dhcpd to put active leases into a pf table. Dhcpd will then
periodically - based on the length of the shortest lease time - walk across
all leases searching for expired leases which are then removed from the pf
table.

ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: memory.c,v 1.12 2006/06/14 14:49:46 ckuethe Exp $ */
d502 1
a502 1
			if (lease->uid_len < sizeof (lease->uid_buf)) {
@


1.12
log
@Move the transmission of privsep messages into its own function. Wherever
we might have conditionally sent a message, we now just call the pfmsg()
function, and let it figure out whether the message should be sent or not.

ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: memory.c,v 1.11 2006/05/31 02:43:15 ckuethe Exp $ */
d43 1
a43 1
static struct subnet *subnets;
@


1.11
log
@This diff makes dhcpd able to manipulate pf tables on certain lease events.

dhcpd is now able to place abandoned addresses into a table (to offer some
protection against machines camping on an address) and remove them from the
table if they are properly leased.

When dhcpd assigns an IP to a new hardware address, it can remove that
address from a table. This is for use with the overload table in pf; newly
arrived machines will not be punished for the actions of a machine that
went away.

beck@@ and krw@@ liked previous versions of this, henning@@ final ok
@
text
@d1 1
a1 1
/*	$OpenBSD: memory.c,v 1.10 2004/09/21 04:07:04 david Exp $ */
a41 4
extern int pfpipe[2];
extern int gotpipe;
extern char *abandoned_tab;
extern char *changedmac_tab;
a439 1
	struct pf_cmd cmd;
d602 3
a604 11
	if (gotpipe && (abandoned_tab != NULL)){
		cmd.type = 'L';
		bcopy(lease->ip_addr.iabuf, &cmd.ip.s_addr, 4);
		(void)atomicio(vwrite, pfpipe[1], &cmd, sizeof(struct pf_cmd));
	}

	if (gotpipe && do_pftable && (changedmac_tab != NULL)){
		cmd.type = 'C';
		bcopy(lease->ip_addr.iabuf, &cmd.ip.s_addr, 4);
		(void)atomicio(vwrite, pfpipe[1], &cmd, sizeof(struct pf_cmd));
	}
a636 1
	struct pf_cmd cmd;
d651 1
a651 5
	if (gotpipe && abandoned_tab != NULL){
		cmd.type = 'A';
		bcopy(lease->ip_addr.iabuf, &cmd.ip.s_addr, 4);
		(void)atomicio(vwrite, pfpipe[1], &cmd, sizeof(struct pf_cmd));
	}
@


1.10
log
@spelling fixes; ok jmc@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: memory.c,v 1.9 2004/09/16 18:35:43 deraadt Exp $ */
d42 4
d442 1
d444 1
d498 2
a499 1
		} else if (!comp->hardware_addr.htype)
d501 2
d607 12
d650 1
d664 7
@


1.10.4.1
log
@MFC:
Fix by cloder@@

Fix a reliability issue in dhcpd where a DHCPDISCOVER packet with a 32-byte
client identifier would cause dhcpd to mistakenly exit. From Debian bug
380273, affecting ISC dhcpd 2.x, upon which our dhcpd is based.

ok cloder@@
@
text
@d1 1
a1 1
/*	$OpenBSD: memory.c,v 1.14 2006/08/09 22:23:53 cloder Exp $ */
d498 1
a498 1
			if (lease->uid_len <= sizeof (lease->uid_buf)) {
@


1.10.6.1
log
@MFC:
Fix by cloder@@

Fix a reliability issue in dhcpd where a DHCPDISCOVER packet with a 32-byte
client identifier would cause dhcpd to mistakenly exit. From Debian bug
380273, affecting ISC dhcpd 2.x, upon which our dhcpd is based.

ok cloder@@
@
text
@d1 1
a1 1
/*	$OpenBSD: memory.c,v 1.14 2006/08/09 22:23:53 cloder Exp $ */
d498 1
a498 1
			if (lease->uid_len <= sizeof (lease->uid_buf)) {
@


1.9
log
@avoid aliasing with libc functions; ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: memory.c,v 1.8 2004/05/11 04:08:35 deraadt Exp $ */
d622 1
a622 1
 * particulars to zero, the end time apropriately and re-hash it as
@


1.8
log
@knf
@
text
@d1 1
a1 1
/*	$OpenBSD: memory.c,v 1.7 2004/05/04 20:28:40 deraadt Exp $ */
d255 1
a255 1
				warn("No hostname for %s", inet_ntoa(ia));
d350 1
a350 1
			warn("%ssubnet %s/%d conflicts with subnet %s/%d",
d466 1
a466 1
		warn("Lease conflict at %s", piaddr(comp->ip_addr));
d635 1
a635 1
	warn("Abandoning IP address %s for %d seconds: %s",
@


1.7
log
@remove things not used, spotted by lint mostly; ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: memory.c,v 1.6 2004/04/20 05:35:33 henning Exp $ */
d172 2
a173 4
new_address_range(low, high, subnet, dynamic)
	struct iaddr low, high;
	struct subnet *subnet;
	int dynamic;
@


1.6
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
a843 25
}

void
dump_subnets(void)
{
	struct lease *l;
	struct shared_network *s;
	struct subnet *n;

	note("Subnets:");
	for (n = subnets; n; n = n->next_subnet) {
		debug("  Subnet %s", piaddr(n->net));
		debug("     netmask %s", piaddr(n->netmask));
	}
	note("Shared networks:");
	for (s = shared_networks; s; s = s->next) {
		note("  %s", s->name);
		for (l = s->leases; l; l = l->next) {
			print_lease(l);
		}
		if (s->last_lease) {
			debug("    Last Lease:");
			print_lease(s->last_lease);
		}
	}
@


1.5
log
@various knf; henning ok
@
text
@d1 2
@


1.4
log
@a bunch of knf, ok henning
@
text
@d851 1
a851 1
	note ("Subnets:");
@


1.3
log
@spaces
@
text
@a0 4
/* memory.c

   Memory-resident database... */

d53 2
a54 2
void enter_host (hd)
	struct host_decl *hd;
d56 1
a56 2
	struct host_decl *hp = (struct host_decl *)0;
	struct host_decl *np = (struct host_decl *)0;
d58 2
a59 3
	hd -> n_ipaddr = (struct host_decl *)0;

	if (hd -> interface.hlen) {
d61 1
a61 1
			host_hw_addr_hash = new_hash ();
d63 2
a64 4
			hp = (struct host_decl *)
				hash_lookup (host_hw_addr_hash,
					     hd -> interface.haddr,
					     hd -> interface.hlen);
d66 4
a69 2
		/* If there isn't already a host decl matching this
		   address, add it to the hash table. */
d71 2
a72 3
			add_hash (host_hw_addr_hash,
				  hd -> interface.haddr, hd -> interface.hlen,
				  (unsigned char *)hd);
d75 4
a78 3
	/* If there was already a host declaration for this hardware
	   address, add this one to the end of the list. */

d80 1
a80 1
		for (np = hp; np -> n_ipaddr; np = np -> n_ipaddr)
d82 1
a82 1
		np -> n_ipaddr = hd;
d85 2
a86 3
	if (hd -> group -> options [DHO_DHCP_CLIENT_IDENTIFIER]) {
		if (!tree_evaluate (hd -> group -> options
				    [DHO_DHCP_CLIENT_IDENTIFIER]))
d92 2
a93 2
			host_uid_hash = new_hash ();
			hp = (struct host_decl *)0;
d95 9
a103 10
			hp = (struct host_decl *) hash_lookup
				(host_uid_hash,
				 hd -> group -> options
				 [DHO_DHCP_CLIENT_IDENTIFIER] -> value,
				 hd -> group -> options
				 [DHO_DHCP_CLIENT_IDENTIFIER] -> len);

		/* If there's already a host declaration for this
		   client identifier, add this one to the end of the
		   list.  Otherwise, add it to the hash table. */
d107 2
a108 2
				for (np = hp; np -> n_ipaddr;
				     np = np -> n_ipaddr)
d110 1
a110 1
				np -> n_ipaddr = hd;
d113 4
a116 6
			add_hash (host_uid_hash,
				  hd -> group -> options
				  [DHO_DHCP_CLIENT_IDENTIFIER] -> value,
				  hd -> group -> options
				  [DHO_DHCP_CLIENT_IDENTIFIER] -> len,
				  (unsigned char *)hd);
d121 2
a122 4
struct host_decl *find_hosts_by_haddr (htype, haddr, hlen)
	int htype;
	unsigned char *haddr;
	int hlen;
d124 2
a125 5
	struct host_decl *foo;

	foo = (struct host_decl *)hash_lookup (host_hw_addr_hash,
					       haddr, hlen);
	return foo;
d128 2
a129 3
struct host_decl *find_hosts_by_uid (data, len)
	unsigned char *data;
	int len;
d131 1
a131 4
	struct host_decl *foo;

	foo = (struct host_decl *)hash_lookup (host_uid_hash, data, len);
	return foo;
d134 12
a145 12
/* More than one host_decl can be returned by find_hosts_by_haddr or
   find_hosts_by_uid, and each host_decl can have multiple addresses.
   Loop through the list of hosts, and then for each host, through the
   list of addresses, looking for an address that's in the same shared
   network as the one specified.    Store the matching address through
   the addr pointer, update the host pointer to point at the host_decl
   that matched, and return the subnet that matched. */

struct subnet *find_host_for_network (host, addr, share)
	struct host_decl **host;
	struct iaddr *addr;
	struct shared_network *share;
a146 1
	int i;
d150 1
d152 2
a153 2
	for (hp = *host; hp; hp = hp -> n_ipaddr) {
		if (!hp -> fixed_addr || !tree_evaluate (hp -> fixed_addr))
d155 1
a155 1
		for (i = 0; i < hp -> fixed_addr -> len; i += 4) {
d157 2
a158 3
			memcpy (ip_address.iabuf,
				hp -> fixed_addr -> value + i, 4);
			subnet = find_grouped_subnet (share, ip_address);
d166 1
a166 1
	return (struct subnet *)0;
d169 2
a170 1
void new_address_range (low, high, subnet, dynamic)
d178 2
a179 2
	char lowbuf [16], highbuf [16], netbuf [16];
	struct shared_network *share = subnet -> shared_network;
d185 3
a187 3
		strlcpy (netbuf, piaddr (subnet -> net), sizeof(netbuf));
		error ("No shared network for network %s (%s)",
		       netbuf, piaddr (subnet -> netmask));
d192 1
a192 1
		lease_uid_hash = new_hash ();
d194 1
a194 1
		lease_ip_addr_hash = new_hash ();
d196 1
a196 1
		lease_hw_addr_hash = new_hash ();
d199 7
a205 7
	net = subnet_number (low, subnet -> netmask);
	if (!addr_eq (net, subnet_number (high, subnet -> netmask))) {
		strlcpy (lowbuf, piaddr (low), sizeof(lowbuf));
		strlcpy (highbuf, piaddr (high), sizeof(highbuf));
		strlcpy (netbuf, piaddr (subnet -> netmask), sizeof(netbuf));
		error ("Address range %s to %s, netmask %s spans %s!",
		       lowbuf, highbuf, netbuf, "multiple subnets");
d209 6
a214 6
	if (!addr_eq (net, subnet -> net)) {
		strlcpy (lowbuf, piaddr (low), sizeof(lowbuf));
		strlcpy (highbuf, piaddr (high), sizeof(highbuf));
		strlcpy (netbuf, piaddr (subnet -> netmask), sizeof(netbuf));
		error ("Address range %s to %s not on net %s/%s!",
		       lowbuf, highbuf, piaddr (subnet -> net), netbuf);
d218 2
a219 2
	max = host_addr (high, subnet -> netmask);
	min = host_addr (low, subnet -> netmask);
d224 1
a224 1
		min = host_addr (high, subnet -> netmask);
d228 1
a228 1
	address_range = new_leases (max - min + 1, "new_address_range");
d230 3
a232 3
		strlcpy (lowbuf, piaddr (low), sizeof(lowbuf));
		strlcpy (highbuf, piaddr (high), sizeof(highbuf));
		error ("No memory for address range %s-%s.", lowbuf, highbuf);
d234 1
a234 1
	memset (address_range, 0, (sizeof *address_range) * (max - min + 1));
d237 2
a238 3
	if (!share -> last_lease) {
		share -> last_lease = &address_range [0];
	}
d242 7
a248 8
		address_range [i].ip_addr =
			ip_addr (subnet -> net, subnet -> netmask, i + min);
		address_range [i].starts =
			address_range [i].timestamp = MIN_TIME;
		address_range [i].ends = MIN_TIME;
		address_range [i].subnet = subnet;
		address_range [i].shared_network = share;
		address_range [i].flags = dynamic ? DYNAMIC_BOOTP_OK : 0;
d250 1
a250 1
		memcpy (&ia, address_range [i].ip_addr.iabuf, 4);
d252 2
a253 2
		if (subnet -> group -> get_lease_hostnames) {
			h = gethostbyaddr ((char *)&ia, sizeof ia, AF_INET);
d255 1
a255 1
				warn ("No hostname for %s", inet_ntoa (ia));
d258 7
a264 7
				address_range [i].hostname =
					malloc (len);
				if (!address_range [i].hostname)
					error ("no memory for hostname %s.",
					       h -> h_name);
				strlcpy (address_range [i].hostname,
					h -> h_name, len);
d269 8
a276 9
		address_range [i].next = share -> leases;
		address_range [i].prev = (struct lease *)0;
		share -> leases = &address_range [i];
		if (address_range [i].next)
			address_range [i].next -> prev = share -> leases;
		add_hash (lease_ip_addr_hash,
			  address_range [i].ip_addr.iabuf,
			  address_range [i].ip_addr.len,
			  (unsigned char *)&address_range [i]);
d280 2
a281 2
	plp = (struct lease *)0;
	for (lp = dangling_leases; lp; lp = lp -> next) {
d285 2
a286 2
		lnet = subnet_number (lp -> ip_addr, subnet -> netmask);
		lhost = host_addr (lp -> ip_addr, subnet -> netmask);
d291 1
a291 2
		if (addr_eq (lnet, subnet -> net) &&
		    lhost >= i && lhost <= max) {
d293 1
a293 1
				plp -> next = lp -> next;
d295 1
a295 1
				dangling_leases = lp -> next;
d297 6
a302 6
			lp -> next = (struct lease *)0;
			address_range [lhost - i].hostname = lp -> hostname;
			address_range [lhost - i].client_hostname =
				lp -> client_hostname;
			supersede_lease (&address_range [lhost - i], lp, 0);
			free_lease (lp, "new_address_range");
d308 2
a309 2
struct subnet *find_subnet (addr)
	struct iaddr addr;
d313 2
a314 2
	for (rv = subnets; rv; rv = rv -> next_subnet) {
		if (addr_eq (subnet_number (addr, rv -> netmask), rv -> net))
d317 1
a317 1
	return (struct subnet *)0;
d320 2
a321 3
struct subnet *find_grouped_subnet (share, addr)
	struct shared_network *share;
	struct iaddr addr;
d325 2
a326 2
	for (rv = share -> subnets; rv; rv = rv -> next_sibling) {
		if (addr_eq (subnet_number (addr, rv -> netmask), rv -> net))
d329 1
a329 1
	return (struct subnet *)0;
d332 6
a337 9
int subnet_inner_than (subnet, scan, warnp)
	struct subnet *subnet, *scan;
	int warnp;
{
	if (addr_eq (subnet_number (subnet -> net, scan -> netmask),
		     scan -> net) ||
	    addr_eq (subnet_number (scan -> net, subnet -> netmask),
		     subnet -> net)) {
		char n1buf [16];
d339 1
d341 2
a342 2
			if (subnet -> netmask.iabuf [3 - (i >> 3)]
			    & (1 << (i & 7)))
d345 1
a345 1
			if (scan -> netmask.iabuf [3 - (j >> 3)] &
d348 1
a348 1
		strlcpy (n1buf, piaddr (subnet -> net), sizeof(n1buf));
d350 3
a352 3
			warn ("%ssubnet %s/%d conflicts with subnet %s/%d",
			      "Warning: ", n1buf, 32 - i,
			      piaddr (scan -> net), 32 - j);
d360 2
a361 3

void enter_subnet (subnet)
	struct subnet *subnet;
d363 1
a363 1
	struct subnet *scan, *prev = (struct subnet *)0;
d366 7
a372 5
	for (scan = subnets; scan; scan = scan -> next_subnet) {
		/* When we find a conflict, make sure that the
		   subnet with the narrowest subnet mask comes
		   first. */
		if (subnet_inner_than (subnet, scan, 1)) {
d374 1
a374 1
				prev -> next_subnet = subnet;
d377 1
a377 1
			subnet -> next_subnet = scan;
d384 1
a384 1
	subnet -> next_subnet = subnets;
d389 2
a390 3

void enter_shared_network (share)
	struct shared_network *share;
d393 1
a393 1
	share -> next = shared_networks;
d397 9
a405 8
/* Enter a lease into the system.   This is called by the parser each
   time it reads in a new lease.   If the subnet for that lease has
   already been read in (usually the case), just update that lease;
   otherwise, allocate temporary storage for the lease and keep it around
   until we're done reading in the config file. */

void enter_lease (lease)
	struct lease *lease;
d407 1
a407 1
	struct lease *comp = find_lease_by_ip_addr (lease -> ip_addr);
d409 1
a409 2
	/* If we don't have a place for this lease yet, save it for
	   later. */
d411 4
a414 5
		comp = new_lease ("enter_lease");
		if (!comp) {
			error ("No memory for lease %s\n",
			       piaddr (lease -> ip_addr));
		}
d416 2
a417 2
		comp -> next = dangling_leases;
		comp -> prev = (struct lease *)0;
d421 3
a423 3
		comp -> hostname = lease -> hostname;
		comp -> client_hostname = lease -> client_hostname;
		supersede_lease (comp, lease, 0);
d427 8
a434 8
/* Replace the data in an existing lease with the data in a new lease;
   adjust hash tables to suit, and insertion sort the lease into the
   list of leases by expiry time so that we can always find the oldest
   lease. */

int supersede_lease (comp, lease, commit)
	struct lease *comp, *lease;
	int commit;
d441 1
a441 1
	if (lease -> flags & STATIC_LEASE)
d444 23
a466 24
	/* If the existing lease hasn't expired and has a different
	   unique identifier or, if it doesn't have a unique
	   identifier, a different hardware address, then the two
	   leases are in conflict.  If the existing lease has a uid
	   and the new one doesn't, but they both have the same
	   hardware address, and dynamic bootp is allowed on this
	   lease, then we allow that, in case a dynamic BOOTP lease is
	   requested *after* a DHCP lease has been assigned. */

	if (!(lease -> flags & ABANDONED_LEASE) &&
	    comp -> ends > cur_time &&
	    (((comp -> uid && lease -> uid) &&
	      (comp -> uid_len != lease -> uid_len ||
	       memcmp (comp -> uid, lease -> uid, comp -> uid_len))) ||
	     (!comp -> uid &&
	      ((comp -> hardware_addr.htype !=
		lease -> hardware_addr.htype) ||
	       (comp -> hardware_addr.hlen !=
		lease -> hardware_addr.hlen) ||
	       memcmp (comp -> hardware_addr.haddr,
		       lease -> hardware_addr.haddr,
		       comp -> hardware_addr.hlen))))) {
		warn ("Lease conflict at %s",
		      piaddr (comp -> ip_addr));
d471 2
a472 2
		if (comp -> uid) {
			uid_hash_delete (comp);
d474 4
a477 4
			if (comp -> uid != &comp -> uid_buf [0]) {
				free (comp -> uid);
				comp -> uid_max = 0;
				comp -> uid_len = 0;
d479 1
a479 1
			comp -> uid = (unsigned char *)0;
d483 8
a490 9
		if (comp -> hardware_addr.htype &&
		    ((comp -> hardware_addr.hlen !=
		      lease -> hardware_addr.hlen) ||
		     (comp -> hardware_addr.htype !=
		      lease -> hardware_addr.htype) ||
		     memcmp (comp -> hardware_addr.haddr,
			     lease -> hardware_addr.haddr,
			     comp -> hardware_addr.hlen))) {
			hw_hash_delete (comp);
d492 1
a492 1
		} else if (!comp -> hardware_addr.htype)
d496 11
a506 12
		comp -> starts = lease -> starts;
		if (lease -> uid) {
			if (lease -> uid_len < sizeof (lease -> uid_buf)) {
				memcpy (comp -> uid_buf,
					lease -> uid, lease -> uid_len);
				comp -> uid = &comp -> uid_buf [0];
				comp -> uid_max = sizeof comp -> uid_buf;
			} else if (lease -> uid != &lease -> uid_buf [0]) {
				comp -> uid = lease -> uid;
				comp -> uid_max = lease -> uid_max;
				lease -> uid = (unsigned char *)0;
				lease -> uid_max = 0;
d508 1
a508 1
				error ("corrupt lease uid."); /* XXX */
d511 2
a512 2
			comp -> uid = (unsigned char *)0;
			comp -> uid_max = 0;
d514 5
a518 5
		comp -> uid_len = lease -> uid_len;
		comp -> host = lease -> host;
		comp -> hardware_addr = lease -> hardware_addr;
		comp -> flags = ((lease -> flags & ~PERSISTENT_FLAGS) |
				 (comp -> flags & ~EPHEMERAL_FLAGS));
d521 2
a522 3
		if (enter_uid && lease -> uid) {
			uid_hash_add (comp);
		}
d525 2
a526 3
		if (enter_hwaddr && lease -> hardware_addr.htype) {
			hw_hash_add (comp);
		}
d530 8
a537 11
		if (comp -> prev) {
			comp -> prev -> next = comp -> next;
		} else {
			comp -> shared_network -> leases = comp -> next;
		}
		if (comp -> next) {
			comp -> next -> prev = comp -> prev;
		}
		if (comp -> shared_network -> last_lease == comp) {
			comp -> shared_network -> last_lease = comp -> prev;
		}
d540 5
a544 6
		if (comp == comp -> shared_network -> insertion_point ||
		    !comp -> shared_network -> insertion_point) {
			lp = comp -> shared_network -> leases;
		} else {
			lp = comp -> shared_network -> insertion_point;
		}
d549 3
a551 3
			comp -> shared_network -> leases = comp;
			comp -> shared_network -> last_lease = comp;
		} else if (lp -> ends > lease -> ends) {
d554 2
a555 2
			while (lp -> next && lp -> ends > lease -> ends) {
				lp = lp -> next;
d557 1
a557 1
			if (lp -> ends > lease -> ends) {
d560 4
a563 4
				lp -> next = comp;
				comp -> prev = lp;
				comp -> next = (struct lease *)0;
				comp -> shared_network -> last_lease = comp;
d567 4
a570 4
				if ((comp -> prev = lp -> prev))
					comp -> prev -> next = comp;
				comp -> next = lp;
				lp -> prev = comp;
d575 2
a576 2
			while (lp -> prev && lp -> ends < lease -> ends) {
				lp = lp -> prev;
d578 1
a578 1
			if (lp -> ends < lease -> ends) {
d581 4
a584 4
				lp -> prev = comp;
				comp -> next = lp;
				comp -> prev = (struct lease *)0;
				comp -> shared_network -> leases = comp;
d588 4
a591 4
				if ((comp -> next = lp -> next))
					comp -> next -> prev = comp;
				comp -> prev = lp;
				lp -> next = comp;
d594 2
a595 2
		comp -> shared_network -> insertion_point = comp;
		comp -> ends = lease -> ends;
d600 1
a600 1
	return commit && write_lease (comp) && commit_leases ();
d605 2
a606 2
void release_lease (lease)
	struct lease *lease;
d613 3
a615 3
		supersede_lease (lease, &lt, 1);
		note ("Released lease for IP address %s",
		      piaddr (lease -> ip_addr));
d620 7
a626 7
/* Abandon the specified lease for the specified time. sets it's
   particulars to zero, the end time apropriately and re-hash it as
   appropriate. abandons permanently if abtime is 0 */

void abandon_lease (lease, message)
	struct lease *lease;
	char *message;
d631 2
a632 2
	abtime = lease -> subnet -> group -> default_lease_time;
	lease -> flags |= ABANDONED_LEASE;
d635 2
a636 2
	warn ("Abandoning IP address %s for %d seconds: %s",
	      piaddr (lease -> ip_addr), abtime, message);
d639 1
a639 1
	lt.uid = (unsigned char *)0;
d641 1
a641 1
	supersede_lease (lease, &lt, 1);
d645 2
a646 3

struct lease *find_lease_by_ip_addr (addr)
	struct iaddr addr;
d648 2
a649 4
	struct lease *lease = (struct lease *)hash_lookup (lease_ip_addr_hash,
							   addr.iabuf,
							   addr.len);
	return lease;
d652 1
a652 3
struct lease *find_lease_by_uid (uid, len)
	unsigned char *uid;
	int len;
d654 1
a654 3
	struct lease *lease = (struct lease *)hash_lookup (lease_uid_hash,
							   uid, len);
	return lease;
d657 2
a658 3
struct lease *find_lease_by_hw_addr (hwaddr, hwlen)
	unsigned char *hwaddr;
	int hwlen;
d660 1
a660 3
	struct lease *lease = (struct lease *)hash_lookup (lease_hw_addr_hash,
							   hwaddr, hwlen);
	return lease;
d664 2
a665 3

void uid_hash_add (lease)
	struct lease *lease;
d667 1
a667 2
	struct lease *head =
		find_lease_by_uid (lease -> uid, lease -> uid_len);
a669 5
#ifdef DEBUG
	if (lease -> n_uid)
		abort ();
#endif

d672 2
a673 2
		add_hash (lease_uid_hash, lease -> uid,
			  lease -> uid_len, (unsigned char *)lease);
d676 3
a678 7
		for (scan = head; scan -> n_uid; scan = scan -> n_uid)
#ifdef DEBUG
			if (scan == lease)
				abort ()
#endif
					;
		scan -> n_uid = lease;
d683 2
a684 3

void uid_hash_delete (lease)
	struct lease *lease;
d686 1
a686 2
	struct lease *head =
		find_lease_by_uid (lease -> uid, lease -> uid_len);
d691 1
a691 1
		lease -> n_uid = (struct lease *)0;
d699 5
a703 7
		delete_hash_entry (lease_uid_hash,
				   lease -> uid, lease -> uid_len);
		if (lease -> n_uid)
			add_hash (lease_uid_hash,
				  lease -> n_uid -> uid,
				  lease -> n_uid -> uid_len,
				  (unsigned char *)(lease -> n_uid));
d708 3
a710 3
		for (scan = head; scan -> n_uid; scan = scan -> n_uid) {
			if (scan -> n_uid == lease) {
				scan -> n_uid = scan -> n_uid -> n_uid;
d715 1
a715 1
	lease -> n_uid = (struct lease *)0;
d719 2
a720 3

void hw_hash_add (lease)
	struct lease *lease;
d722 2
a723 3
	struct lease *head =
		find_lease_by_hw_addr (lease -> hardware_addr.haddr,
				       lease -> hardware_addr.hlen);
d728 2
a729 4
		add_hash (lease_hw_addr_hash,
			  lease -> hardware_addr.haddr,
			  lease -> hardware_addr.hlen,
			  (unsigned char *)lease);
d732 1
a732 1
		for (scan = head; scan -> n_hw; scan = scan -> n_hw)
d734 1
a734 1
		scan -> n_hw = lease;
d739 2
a740 3

void hw_hash_delete (lease)
	struct lease *lease;
d742 2
a743 3
	struct lease *head =
		find_lease_by_hw_addr (lease -> hardware_addr.haddr,
				       lease -> hardware_addr.hlen);
d748 1
a748 1
		lease -> n_hw = (struct lease *)0;
d756 7
a762 8
		delete_hash_entry (lease_hw_addr_hash,
				   lease -> hardware_addr.haddr,
				   lease -> hardware_addr.hlen);
		if (lease -> n_hw)
			add_hash (lease_hw_addr_hash,
				  lease -> n_hw -> hardware_addr.haddr,
				  lease -> n_hw -> hardware_addr.hlen,
				  (unsigned char *)(lease -> n_hw));
d764 8
a771 6
		/* Otherwise, look for the lease in the list of leases
		   attached to the hash table entry, and remove it if
		   we find it. */
		for (scan = head; scan -> n_hw; scan = scan -> n_hw) {
			if (scan -> n_hw == lease) {
				scan -> n_hw = scan -> n_hw -> n_hw;
d776 1
a776 1
	lease -> n_hw = (struct lease *)0;
d780 2
a781 3
struct class *add_class (type, name)
	int type;
	char *name;
d783 2
a784 2
	struct class *class = new_class ("add_class");
	char *tname = (char *)malloc (strlen (name) + 1);
d787 1
a787 1
		vendor_class_hash = new_hash ();
d789 1
a789 1
		user_class_hash = new_hash ();
d792 1
a792 1
		return (struct class *)0;
d794 3
a796 3
	memset (class, 0, sizeof *class);
	strlcpy (tname, name, strlen(name) + 1);
	class -> name = tname;
d799 2
a800 3
		add_hash (user_class_hash,
			  (unsigned char *)tname, strlen (tname),
			  (unsigned char *)class);
d802 2
a803 3
		add_hash (vendor_class_hash,
			  (unsigned char *)tname, strlen (tname),
			  (unsigned char *)class);
d807 5
a811 10
struct class *find_class (type, name, len)
	int type;
	unsigned char *name;
	int len;
{
	struct class *class =
		(struct class *)hash_lookup (type
					     ? user_class_hash
					     : vendor_class_hash, name, len);
	return class;
d814 2
a815 3
struct group *clone_group (group, caller)
	struct group *group;
	char *caller;
d817 1
a817 1
	struct group *g = new_group (caller);
d819 1
a819 1
		error ("%s: can't allocate new group", caller);
d826 2
a827 1
void write_leases ()
d832 6
a837 7
	for (s = shared_networks; s; s = s -> next) {
		for (l = s -> leases; l; l = l -> next) {
			if (l -> hardware_addr.hlen ||
			    l -> uid_len ||
			    (l -> flags & ABANDONED_LEASE))
				if (!write_lease (l))
					error ("Can't rewrite lease database");
d840 2
a841 2
	if (!commit_leases ())
		error ("Can't commit leases to new database: %m");
d844 2
a845 1
void dump_subnets ()
d852 13
a864 14
	for (n = subnets; n; n = n -> next_subnet) {
		debug ("  Subnet %s", piaddr (n -> net));
		debug ("     netmask %s",
		       piaddr (n -> netmask));
	}
	note ("Shared networks:");
	for (s = shared_networks; s; s = s -> next) {
		note ("  %s", s -> name);
		for (l = s -> leases; l; l = l -> next) {
			print_lease (l);
		}
		if (s -> last_lease) {
			debug ("    Last Lease:");
			print_lease (s -> last_lease);
@


1.2
log
@time_t and kill a few dumb defines
@
text
@d95 1
a95 1
			
d399 1
a399 1
				prev -> next_subnet = subnet; 
d412 1
a412 1
	
d422 1
a422 1
	
d560 1
a560 1
		/* Remove the lease from its current place in the 
d656 1
a656 1
/* Abandon the specified lease for the specified time. sets it's 
d886 1
a886 1
}	
@


1.1
log
@may the whacking begin
@
text
@d665 1
a665 1
	TIME abtime;
@

