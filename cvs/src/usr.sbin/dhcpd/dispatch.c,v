head	1.42;
access;
symbols
	OPENBSD_6_0:1.36.0.4
	OPENBSD_6_0_BASE:1.36
	OPENBSD_5_9:1.36.0.2
	OPENBSD_5_9_BASE:1.36
	OPENBSD_5_8:1.34.0.6
	OPENBSD_5_8_BASE:1.34
	OPENBSD_5_7:1.34.0.2
	OPENBSD_5_7_BASE:1.34
	OPENBSD_5_6:1.33.0.4
	OPENBSD_5_6_BASE:1.33
	OPENBSD_5_5:1.32.0.4
	OPENBSD_5_5_BASE:1.32
	OPENBSD_5_4:1.31.0.2
	OPENBSD_5_4_BASE:1.31
	OPENBSD_5_3:1.29.0.6
	OPENBSD_5_3_BASE:1.29
	OPENBSD_5_2:1.29.0.4
	OPENBSD_5_2_BASE:1.29
	OPENBSD_5_1_BASE:1.29
	OPENBSD_5_1:1.29.0.2
	OPENBSD_5_0:1.28.0.4
	OPENBSD_5_0_BASE:1.28
	OPENBSD_4_9:1.28.0.2
	OPENBSD_4_9_BASE:1.28
	OPENBSD_4_8:1.27.0.2
	OPENBSD_4_8_BASE:1.27
	OPENBSD_4_7:1.25.0.2
	OPENBSD_4_7_BASE:1.25
	OPENBSD_4_6:1.24.0.6
	OPENBSD_4_6_BASE:1.24
	OPENBSD_4_5:1.24.0.2
	OPENBSD_4_5_BASE:1.24
	OPENBSD_4_4:1.23.0.2
	OPENBSD_4_4_BASE:1.23
	OPENBSD_4_3:1.22.0.6
	OPENBSD_4_3_BASE:1.22
	OPENBSD_4_2:1.22.0.4
	OPENBSD_4_2_BASE:1.22
	OPENBSD_4_1:1.22.0.2
	OPENBSD_4_1_BASE:1.22
	OPENBSD_4_0:1.21.0.2
	OPENBSD_4_0_BASE:1.21
	OPENBSD_3_9:1.16.0.6
	OPENBSD_3_9_BASE:1.16
	OPENBSD_3_8:1.16.0.4
	OPENBSD_3_8_BASE:1.16
	OPENBSD_3_7:1.16.0.2
	OPENBSD_3_7_BASE:1.16
	OPENBSD_3_6:1.10.0.2
	OPENBSD_3_6_BASE:1.10;
locks; strict;
comment	@ * @;


1.42
date	2017.02.13.23.04.05;	author krw;	state Exp;
branches;
next	1.41;
commitid	amfLXbU964CBXnkr;

1.41
date	2017.02.13.22.33.39;	author krw;	state Exp;
branches;
next	1.40;
commitid	aD6aChUv7GEv3CLZ;

1.40
date	2017.02.13.21.53.53;	author krw;	state Exp;
branches;
next	1.39;
commitid	iao5yt5BDQh8mK3C;

1.39
date	2017.02.13.19.13.14;	author krw;	state Exp;
branches;
next	1.38;
commitid	syYFt6P4XI7prXRF;

1.38
date	2016.11.15.10.49.37;	author mestre;	state Exp;
branches;
next	1.37;
commitid	MJxFs9s3mqdgRyMT;

1.37
date	2016.08.27.01.26.22;	author guenther;	state Exp;
branches;
next	1.36;
commitid	mLhDPn5m6RI81k8n;

1.36
date	2016.02.06.23.50.10;	author krw;	state Exp;
branches;
next	1.35;
commitid	8GMcSAoPYCa1rXN3;

1.35
date	2015.08.20.22.39.29;	author deraadt;	state Exp;
branches;
next	1.34;
commitid	z3HrihslRYb4HqW9;

1.34
date	2014.10.08.04.26.07;	author deraadt;	state Exp;
branches;
next	1.33;
commitid	xmsB7lLxExkM1cWx;

1.33
date	2014.05.05.18.30.44;	author pelikan;	state Exp;
branches;
next	1.32;

1.32
date	2013.10.18.15.19.39;	author krw;	state Exp;
branches;
next	1.31;

1.31
date	2013.05.16.19.24.12;	author gerhard;	state Exp;
branches;
next	1.30;

1.30
date	2013.04.19.21.25.39;	author sthen;	state Exp;
branches;
next	1.29;

1.29
date	2011.11.12.15.39.52;	author krw;	state Exp;
branches;
next	1.28;

1.28
date	2010.11.19.08.00.56;	author ajacoutot;	state Exp;
branches;
next	1.27;

1.27
date	2010.07.03.04.44.51;	author guenther;	state Exp;
branches;
next	1.26;

1.26
date	2010.04.19.12.22.09;	author claudio;	state Exp;
branches;
next	1.25;

1.25
date	2010.01.02.04.21.16;	author krw;	state Exp;
branches;
next	1.24;

1.24
date	2008.09.15.20.38.17;	author claudio;	state Exp;
branches;
next	1.23;

1.23
date	2008.05.07.12.19.20;	author beck;	state Exp;
branches;
next	1.22;

1.22
date	2006.12.12.19.38.55;	author stevesk;	state Exp;
branches;
next	1.21;

1.21
date	2006.05.30.23.43.46;	author ckuethe;	state Exp;
branches;
next	1.20;

1.20
date	2006.05.27.19.52.23;	author krw;	state Exp;
branches;
next	1.19;

1.19
date	2006.05.27.04.01.04;	author krw;	state Exp;
branches;
next	1.18;

1.18
date	2006.05.11.01.19.08;	author krw;	state Exp;
branches;
next	1.17;

1.17
date	2006.03.16.15.44.40;	author claudio;	state Exp;
branches;
next	1.16;

1.16
date	2005.01.31.18.27.38;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2004.10.31.10.43.38;	author canacar;	state Exp;
branches;
next	1.14;

1.14
date	2004.09.21.04.07.04;	author david;	state Exp;
branches;
next	1.13;

1.13
date	2004.09.16.18.35.43;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2004.09.16.09.35.24;	author claudio;	state Exp;
branches;
next	1.11;

1.11
date	2004.09.15.22.12.50;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2004.05.25.17.41.54;	author canacar;	state Exp;
branches;
next	1.9;

1.9
date	2004.05.04.20.28.40;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2004.04.20.05.35.33;	author henning;	state Exp;
branches;
next	1.7;

1.7
date	2004.04.18.01.19.07;	author henning;	state Exp;
branches;
next	1.6;

1.6
date	2004.04.18.00.43.27;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2004.04.16.04.30.09;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2004.04.14.04.34.19;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2004.04.14.00.56.02;	author henning;	state Exp;
branches;
next	1.2;

1.2
date	2004.04.13.23.57.49;	author henning;	state Exp;
branches;
next	1.1;

1.1
date	2004.04.13.23.41.48;	author henning;	state Exp;
branches;
next	;


desc
@@


1.42
log
@Eliminate pointless'%m' (a.k.a. hand rolled strerror()) by using fatal() and
log_warn(). Zap a couple of explicit 'syslog()' calls.
@
text
@/*	$OpenBSD: dispatch.c,v 1.41 2017/02/13 22:33:39 krw Exp $ */

/*
 * Copyright (c) 1995, 1996, 1997, 1998, 1999
 * The Internet Software Consortium.   All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of The Internet Software Consortium nor the names
 *    of its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INTERNET SOFTWARE CONSORTIUM AND
 * CONTRIBUTORS ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE INTERNET SOFTWARE CONSORTIUM OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This software has been written for the Internet Software Consortium
 * by Ted Lemon <mellon@@fugue.com> in cooperation with Vixie
 * Enterprises.  To learn more about the Internet Software Consortium,
 * see ``http://www.vix.com/isc''.  To learn more about Vixie
 * Enterprises, see ``http://www.vix.com''.
 */

#include <sys/types.h>
#include <sys/ioctl.h>
#include <sys/socket.h>

#include <arpa/inet.h>

#include <net/if.h>
#include <net/if_dl.h>
#include <net/if_media.h>

#include <netinet/in.h>

#include <errno.h>
#include <ifaddrs.h>
#include <limits.h>
#include <poll.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <syslog.h>
#include <time.h>
#include <unistd.h>

#include "dhcp.h"
#include "tree.h"
#include "dhcpd.h"
#include "log.h"
#include "sync.h"

extern int syncfd;

struct interface_info *interfaces;
struct protocol *protocols;
struct dhcpd_timeout *timeouts;
static struct dhcpd_timeout *free_timeouts;
static int interfaces_invalidated;

static int interface_status(struct interface_info *ifinfo);
int get_rdomain(char *);

/* Use getifaddrs() to get a list of all the attached interfaces.
   For each interface that's of type INET and not the loopback interface,
   register that interface with the network I/O software, figure out what
   subnet it's on, and add it to the list of interfaces. */

void
discover_interfaces(int *rdomain)
{
	struct interface_info *tmp;
	struct interface_info *last, *next;
	struct subnet *subnet;
	struct shared_network *share;
	struct sockaddr_in foo;
	int ir = 0, ird;
	struct ifreq *tif;
	struct ifaddrs *ifap, *ifa;

	if (getifaddrs(&ifap) != 0)
		fatalx("getifaddrs failed");

	/*
	 * If we already have a list of interfaces, the interfaces were
	 * requested.
	 */
	if (interfaces != NULL)
		ir = 1;
	else
		/* must specify an interface when rdomains are used */
		*rdomain = 0;

	/* Cycle through the list of interfaces looking for IP addresses. */
	for (ifa = ifap; ifa != NULL; ifa = ifa->ifa_next) {
		/*
		 * See if this is the sort of interface we want to
		 * deal with.  Skip loopback, point-to-point and down
		 * interfaces, except don't skip down interfaces if we're
		 * trying to get a list of configurable interfaces.
		 */
		if ((ifa->ifa_flags & IFF_LOOPBACK) ||
		    (ifa->ifa_flags & IFF_POINTOPOINT) ||
		    (!(ifa->ifa_flags & IFF_UP)) ||
		    (!(ifa->ifa_flags & IFF_BROADCAST)))
			continue;

		/* See if we've seen an interface that matches this one. */
		for (tmp = interfaces; tmp; tmp = tmp->next)
			if (!strcmp(tmp->name, ifa->ifa_name))
				break;

		/* If we are looking for specific interfaces, ignore others. */
		if (tmp == NULL && ir)
			continue;

		ird = get_rdomain(ifa->ifa_name);
		if (*rdomain == -1)
			*rdomain = ird;
		else if (*rdomain != ird && ir)
			fatalx("Interface %s is not in rdomain %d",
			    tmp->name, *rdomain);
		else if (*rdomain != ird && !ir)
			continue;

		/* If there isn't already an interface by this name,
		   allocate one. */
		if (tmp == NULL) {
			tmp = calloc(1, sizeof *tmp);
			if (!tmp)
				fatalx("Insufficient memory to %s %s",
				    "record interface", ifa->ifa_name);
			strlcpy(tmp->name, ifa->ifa_name, sizeof(tmp->name));
			tmp->next = interfaces;
			tmp->noifmedia = tmp->dead = tmp->errors = 0;
			interfaces = tmp;
		}

		/* If we have the capability, extract link information
		   and record it in a linked list. */
		if (ifa->ifa_addr->sa_family == AF_LINK) {
			struct sockaddr_dl *foo =
			    ((struct sockaddr_dl *)(ifa->ifa_addr));
			tmp->index = foo->sdl_index;
			tmp->hw_address.hlen = foo->sdl_alen;
			tmp->hw_address.htype = HTYPE_ETHER; /* XXX */
			memcpy(tmp->hw_address.haddr,
			    LLADDR(foo), foo->sdl_alen);
		} else if (ifa->ifa_addr->sa_family == AF_INET) {
			struct iaddr addr;

			/* Get a pointer to the address... */
			memcpy(&foo, ifa->ifa_addr, sizeof(foo));

			/* We don't want the loopback interface. */
			if (foo.sin_addr.s_addr == htonl (INADDR_LOOPBACK))
				continue;

			/* If this is the first real IP address we've
			   found, keep a pointer to ifreq structure in
			   which we found it. */
			if (!tmp->ifp) {
				int len = (IFNAMSIZ + ifa->ifa_addr->sa_len);
				tif = malloc(len);
				if (!tif)
					fatalx("no space to remember ifp.");
				strlcpy(tif->ifr_name, ifa->ifa_name,
				    IFNAMSIZ);
				memcpy(&tif->ifr_addr, ifa->ifa_addr,
				    ifa->ifa_addr->sa_len);
				tmp->ifp = tif;
				tmp->primary_address = foo.sin_addr;
			}

			/* Grab the address... */
			addr.len = 4;
			memcpy(addr.iabuf, &foo.sin_addr.s_addr, addr.len);

			/* If there's a registered subnet for this address,
			   connect it together... */
			if ((subnet = find_subnet(addr))) {
				/* If this interface has multiple aliases
				   on the same subnet, ignore all but the
				   first we encounter. */
				if (!subnet->interface) {
					subnet->interface = tmp;
					subnet->interface_address = addr;
				} else if (subnet->interface != tmp) {
					log_warnx("Multiple %s %s: %s %s",
					    "interfaces match the",
					    "same subnet",
					    subnet->interface->name,
					    tmp->name);
				}
				share = subnet->shared_network;
				if (tmp->shared_network &&
				    tmp->shared_network != share) {
					log_warnx("Interface %s matches %s",
					    tmp->name,
					    "multiple shared networks");
				} else {
					tmp->shared_network = share;
				}

				if (!share->interface) {
					share->interface = tmp;
				} else if (share->interface != tmp) {
					log_warnx("Multiple %s %s: %s %s",
					    "interfaces match the",
					    "same shared network",
					    share->interface->name,
					    tmp->name);
				}
			}
		}
	}

	/* Discard interfaces we can't listen on. */
	last = NULL;
	for (tmp = interfaces; tmp; tmp = next) {
		next = tmp->next;

		if (!tmp->ifp) {
			log_warnx("Can't listen on %s - it has no IP address.",
			    tmp->name);
			/* Remove tmp from the list of interfaces. */
			if (!last)
				interfaces = interfaces->next;
			else
				last->next = tmp->next;
			continue;
		}

		memcpy(&foo, &tmp->ifp->ifr_addr, sizeof tmp->ifp->ifr_addr);

		if (!tmp->shared_network) {
			log_warnx("Can't listen on %s - dhcpd.conf has no "
			    "subnet declaration for %s.", tmp->name,
			    inet_ntoa(foo.sin_addr));
			/* Remove tmp from the list of interfaces. */
			if (!last)
				interfaces = interfaces->next;
			else
				last->next = tmp->next;
			continue;
		}

		last = tmp;

		/* Find subnets that don't have valid interface addresses. */
		for (subnet = (tmp->shared_network ?
		    tmp->shared_network->subnets : NULL); subnet;
		    subnet = subnet->next_sibling) {
			if (!subnet->interface_address.len) {
				/*
				 * Set the interface address for this subnet
				 * to the first address we found.
				 */
				subnet->interface_address.len = 4;
				memcpy(subnet->interface_address.iabuf,
				    &foo.sin_addr.s_addr, 4);
			}
		}

		/* Register the interface... */
		if_register_receive(tmp);
		if_register_send(tmp);
		log_info("Listening on %s (%s).", tmp->name,
		    inet_ntoa(foo.sin_addr));
	}

	if (interfaces == NULL)
		fatalx("No interfaces to listen on.");

	/* Now register all the remaining interfaces as protocols. */
	for (tmp = interfaces; tmp; tmp = tmp->next)
		add_protocol(tmp->name, tmp->rfdesc, got_one, tmp);

	freeifaddrs(ifap);
}

/*
 * Wait for packets to come in using poll().  When a packet comes in,
 * call receive_packet to receive the packet and possibly strip hardware
 * addressing information from it, and then process it in do_packet.
 */
void
dispatch(void)
{
	int nfds, i, to_msec;
	struct protocol *l;
	static struct pollfd *fds;
	static int nfds_max;
	time_t howlong;

	for (nfds = 0, l = protocols; l; l = l->next)
		nfds++;
	if (syncfd != -1)
		nfds++;
	if (nfds > nfds_max) {
		fds = reallocarray(fds, nfds, sizeof(struct pollfd));
		if (fds == NULL)
			fatalx("Can't allocate poll structures.");
		nfds_max = nfds;
	}

	for (;;) {
		/*
		 * Call any expired timeouts, and then if there's
		 * still a timeout registered, time out the poll
		 * call then.
		 */
		time(&cur_time);
another:
		if (timeouts) {
			if (timeouts->when <= cur_time) {
				struct dhcpd_timeout *t = timeouts;
				timeouts = timeouts->next;
				(*(t->func))(t->what);
				t->next = free_timeouts;
				free_timeouts = t;
				goto another;
			}

			/*
			 * Figure timeout in milliseconds, and check for
			 * potential overflow, so we can cram into an int
			 * for poll, while not polling with a negative
			 * timeout and blocking indefinitely.
			 */
			howlong = timeouts->when - cur_time;
			if (howlong > INT_MAX / 1000)
				howlong = INT_MAX / 1000;
			to_msec = howlong * 1000;
		} else
			to_msec = -1;

		/* Set up the descriptors to be polled. */
		for (i = 0, l = protocols; l; l = l->next) {
			struct interface_info *ip = l->local;

			if (ip && (l->handler != got_one || !ip->dead)) {
				fds[i].fd = l->fd;
				fds[i].events = POLLIN;
				++i;
			}
		}

		if (i == 0)
			fatalx("No live interfaces to poll on - exiting.");

		if (syncfd != -1) {
			/* add syncer */
			fds[i].fd = syncfd;
			fds[i].events = POLLIN;
		}

		/* Wait for a packet or a timeout... */
		switch (poll(fds, nfds, to_msec)) {
		case -1:
			if (errno != EAGAIN && errno != EINTR)
				fatal("poll");
			/* FALLTHROUGH */
		case 0:
			continue;	/* no packets */
		}
		time(&cur_time);

		for (i = 0, l = protocols; l; l = l->next) {
			struct interface_info *ip = l->local;

			if ((fds[i].revents & (POLLIN | POLLHUP))) {
				if (ip && (l->handler != got_one ||
				    !ip->dead))
					(*(l->handler))(l);
				if (interfaces_invalidated)
					break;
			}
			++i;
		}
		if ((syncfd != -1) && (fds[i].revents & (POLLIN | POLLHUP)))
			sync_recv();
		interfaces_invalidated = 0;
	}
}


void
got_one(struct protocol *l)
{
	struct sockaddr_in from;
	struct hardware hfrom;
	struct iaddr ifrom;
	ssize_t result;
	union {
		unsigned char packbuf[4095];
		struct dhcp_packet packet;
	} u;
	struct interface_info *ip = l->local;

	memset(&u, 0, sizeof(u));

	if ((result = receive_packet(ip, u.packbuf, sizeof u,
	    &from, &hfrom)) == -1) {
		log_warn("receive_packet failed on %s", ip->name);
		ip->errors++;
		if ((!interface_status(ip)) ||
		    (ip->noifmedia && ip->errors > 20)) {
			/* our interface has gone away. */
			log_warnx("Interface %s no longer appears valid.",
			    ip->name);
			ip->dead = 1;
			interfaces_invalidated = 1;
			close(l->fd);
			remove_protocol(l);
			free(ip);
		}
		return;
	}
	if (result == 0)
		return;

	ifrom.len = 4;
	memcpy(ifrom.iabuf, &from.sin_addr, ifrom.len);

	do_packet(ip, &u.packet, result, from.sin_port, ifrom, &hfrom);
}

int
interface_status(struct interface_info *ifinfo)
{
	char * ifname = ifinfo->name;
	int ifsock = ifinfo->rfdesc;
	struct ifreq ifr;
	struct ifmediareq ifmr;

	/* get interface flags */
	memset(&ifr, 0, sizeof(ifr));
	strlcpy(ifr.ifr_name, ifname, sizeof(ifr.ifr_name));
	if (ioctl(ifsock, SIOCGIFFLAGS, &ifr) == -1) {
		log_warn("ioctl(SIOCGIFFLAGS) on %s", ifname);
		goto inactive;
	}
	/*
	 * if one of UP and RUNNING flags is dropped,
	 * the interface is not active.
	 */
	if ((ifr.ifr_flags & (IFF_UP|IFF_RUNNING)) != (IFF_UP|IFF_RUNNING))
		goto inactive;

	/* Next, check carrier on the interface, if possible */
	if (ifinfo->noifmedia)
		goto active;
	memset(&ifmr, 0, sizeof(ifmr));
	strlcpy(ifmr.ifm_name, ifname, sizeof(ifmr.ifm_name));
	if (ioctl(ifsock, SIOCGIFMEDIA, (caddr_t)&ifmr) == -1) {
		if (errno != EINVAL) {
			log_debug("ioctl(SIOCGIFMEDIA) on %s", ifname);
			ifinfo->noifmedia = 1;
			goto active;
		}
		/*
		 * EINVAL (or ENOTTY) simply means that the interface
		 * does not support the SIOCGIFMEDIA ioctl. We regard it alive.
		 */
		ifinfo->noifmedia = 1;
		goto active;
	}
	if (ifmr.ifm_status & IFM_AVALID) {
		switch (ifmr.ifm_active & IFM_NMASK) {
		case IFM_ETHER:
			if (ifmr.ifm_status & IFM_ACTIVE)
				goto active;
			else
				goto inactive;
			break;
		default:
			goto inactive;
		}
	}
 inactive:
	return (0);
 active:
	return (1);
}

int
locate_network(struct packet *packet)
{
	struct iaddr ia;

	/* If this came through a gateway, find the corresponding subnet... */
	if (packet->raw->giaddr.s_addr) {
		struct subnet *subnet;

		ia.len = 4;
		memcpy(ia.iabuf, &packet->raw->giaddr, 4);
		subnet = find_subnet(ia);
		if (subnet)
			packet->shared_network = subnet->shared_network;
		else
			packet->shared_network = NULL;
	} else {
		packet->shared_network = packet->interface->shared_network;
	}
	if (packet->shared_network)
		return 1;
	return 0;
}

void
add_timeout(time_t when, void (*where)(void *), void *what)
{
	struct dhcpd_timeout *t, *q;

	/* See if this timeout supersedes an existing timeout. */
	t = NULL;
	for (q = timeouts; q; q = q->next) {
		if (q->func == where && q->what == what) {
			if (t)
				t->next = q->next;
			else
				timeouts = q->next;
			break;
		}
		t = q;
	}

	/* If we didn't supersede a timeout, allocate a timeout
	   structure now. */
	if (!q) {
		if (free_timeouts) {
			q = free_timeouts;
			free_timeouts = q->next;
			q->func = where;
			q->what = what;
		} else {
			q = malloc(sizeof (struct dhcpd_timeout));
			if (!q)
				fatalx("Can't allocate timeout structure!");
			q->func = where;
			q->what = what;
		}
	}

	q->when = when;

	/* Now sort this timeout into the timeout list. */

	/* Beginning of list? */
	if (!timeouts || timeouts->when > q->when) {
		q->next = timeouts;
		timeouts = q;
		return;
	}

	/* Middle of list? */
	for (t = timeouts; t->next; t = t->next) {
		if (t->next->when > q->when) {
			q->next = t->next;
			t->next = q;
			return;
		}
	}

	/* End of list. */
	t->next = q;
	q->next = NULL;
}

void
cancel_timeout(void (*where)(void *), void *what)
{
	struct dhcpd_timeout *t, *q;

	/* Look for this timeout on the list, and unlink it if we find it. */
	t = NULL;
	for (q = timeouts; q; q = q->next) {
		if (q->func == where && q->what == what) {
			if (t)
				t->next = q->next;
			else
				timeouts = q->next;
			break;
		}
		t = q;
	}

	/* If we found the timeout, put it on the free list. */
	if (q) {
		q->next = free_timeouts;
		free_timeouts = q;
	}
}

/* Add a protocol to the list of protocols... */
void
add_protocol(char *name, int fd, void (*handler)(struct protocol *),
    void *local)
{
	struct protocol *p;

	p = malloc(sizeof *p);
	if (!p)
		fatalx("can't allocate protocol struct for %s", name);
	p->fd = fd;
	p->handler = handler;
	p->local = local;
	p->next = protocols;
	protocols = p;
}

void
remove_protocol(struct protocol *proto)
{
	struct protocol *p, *next, *prev = NULL;

	for (p = protocols; p; p = next) {
		next = p->next;
		if (p == proto) {
			if (prev)
				prev->next = p->next;
			else
				protocols = p->next;
			free(p);
		}
	}
}

int
get_rdomain(char *name)
{
	int rv = 0, s;
	struct  ifreq ifr;

	if ((s = socket(AF_INET, SOCK_DGRAM, 0)) == -1)
		fatal("get_rdomain socket");

	memset(&ifr, 0, sizeof(ifr));
	strlcpy(ifr.ifr_name, name, sizeof(ifr.ifr_name));
	if (ioctl(s, SIOCGIFRDOMAIN, (caddr_t)&ifr) != -1)
		rv = ifr.ifr_rdomainid;

	close(s);
	return rv;
}
@


1.41
log
@Adjust some long lines.
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.40 2017/02/13 21:53:53 krw Exp $ */
d379 1
a379 1
				fatalx("poll: %m");
d458 1
a458 1
		syslog(LOG_ERR, "ioctl(SIOCGIFFLAGS) on %s: %m", ifname);
d475 1
a475 2
			syslog(LOG_DEBUG, "ioctl(SIOCGIFMEDIA) on %s: %m",
			    ifname);
d654 1
a654 1
		fatalx("get_rdomain socket: %m");
@


1.40
log
@Do the strerror() elimination dance with log_warnx() -> log_warn(),
fatalx() -> fatal() and even a couple of fprintf(stderr) -> log_warn().
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.39 2017/02/13 19:13:14 krw Exp $ */
d184 2
a185 1
				strlcpy(tif->ifr_name, ifa->ifa_name, IFNAMSIZ);
d254 2
a255 2
			log_warnx("Can't listen on %s - dhcpd.conf has no subnet "
			    "declaration for %s.", tmp->name,
d268 3
a270 2
		for (subnet = (tmp->shared_network ? tmp->shared_network->subnets :
		    NULL); subnet; subnet = subnet->next_sibling) {
@


1.39
log
@Switch from old errwarn.c logging to shiny new log.[ch].

ok benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.38 2016/11/15 10:49:37 mestre Exp $ */
d420 1
a420 2
		log_warnx("receive_packet failed on %s: %s", ip->name,
		    strerror(errno));
@


1.38
log
@Replace bzero(3) with memset(3)

"Looks good" to deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.37 2016/08/27 01:26:22 guenther Exp $ */
d67 1
d99 1
a99 1
		error("getifaddrs failed");
d138 1
a138 1
			error("Interface %s is not in rdomain %d",
d148 1
a148 1
				error("Insufficient memory to %s %s",
d183 1
a183 1
					error("no space to remember ifp.");
d205 1
a205 1
					warning("Multiple %s %s: %s %s",
d214 1
a214 1
					warning("Interface %s matches %s",
d224 1
a224 1
					warning("Multiple %s %s: %s %s",
d240 1
a240 1
			warning("Can't listen on %s - it has no IP address.",
d253 1
a253 1
			warning("Can't listen on %s - dhcpd.conf has no subnet "
d283 1
a283 1
		note("Listening on %s (%s).", tmp->name,
d288 1
a288 1
		error("No interfaces to listen on.");
d318 1
a318 1
			error("Can't allocate poll structures.");
d365 1
a365 1
			error("No live interfaces to poll on - exiting.");
d377 1
a377 1
				error("poll: %m");
d420 1
a420 1
		warning("receive_packet failed on %s: %s", ip->name,
d426 1
a426 1
			warning("Interface %s no longer appears valid.",
d557 1
a557 1
				error("Can't allocate timeout structure!");
d622 1
a622 1
		error("can't allocate protocol struct for %s", name);
d654 1
a654 1
		error("get_rdomain socket: %m");
@


1.37
log
@Pull in <time.h> for one or more of gmtime, strftime, strptime, time,
timegm, and tzset

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.36 2016/02/06 23:50:10 krw Exp $ */
d415 1
a415 1
	bzero(&u, sizeof(u));
d655 1
a655 1
	bzero(&ifr, sizeof(ifr));
@


1.36
log
@Eliminate #include inside *.h files and include only needed headers in
each *.c file.

Inspired by mention of header silliness by Edgar Pettijohn and mmcc@@
on tech@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.35 2015/08/20 22:39:29 deraadt Exp $ */
d61 1
@


1.35
log
@stdlib.h is in scope; do not cast malloc/calloc/realloc*
ok millert krw
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.34 2014/10/08 04:26:07 deraadt Exp $ */
d41 24
a66 4
#include <ifaddrs.h>
#include <sys/ioctl.h>
#include <poll.h>
#include <net/if_media.h>
@


1.34
log
@use reallocarray() to cope with multiplicative integer overflow; ok doug
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.33 2014/05/05 18:30:44 pelikan Exp $ */
d159 1
a159 1
				tif = (struct ifreq *)malloc(len);
d533 1
a533 1
			q = (struct dhcpd_timeout *)malloc(sizeof (struct dhcpd_timeout));
d598 1
a598 1
	p = (struct protocol *)malloc(sizeof *p);
@


1.33
log
@Don't call the BOOTP handler indirectly.

ok krw
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.32 2013/10/18 15:19:39 krw Exp $ */
d294 1
a294 1
		fds = realloc(fds, nfds * sizeof(struct pollfd));
@


1.32
log
@Scattering a few bcopy()'s around source using mostly memcpy() is just
asking for confusion. Replace bcopy()'s with memcpy()'s.
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.31 2013/05/16 19:24:12 gerhard Exp $ */
a54 2
void (*bootp_packet_handler)(struct interface_info *,
    struct dhcp_packet *, int, unsigned int, struct iaddr, struct hardware *);
d278 1
a278 2
 * addressing information from it, and then call through the
 * bootp_packet_handler hook to try to do something with it.
d417 2
a418 3
	if (bootp_packet_handler) {
		ifrom.len = 4;
		memcpy(ifrom.iabuf, &from.sin_addr, ifrom.len);
d420 1
a420 3
		(*bootp_packet_handler)(ip, &u.packet, result,
		    from.sin_port, ifrom, &hfrom);
	}
@


1.31
log
@poll(2) might have slept for an arbitrary amount of time. We should
update 'cur_time' after poll(2) returns.

ok otto
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.30 2013/04/19 21:25:39 sthen Exp $ */
d150 1
a150 1
			bcopy(ifa->ifa_addr, &foo, sizeof(foo));
@


1.30
log
@Log (at LOG_INFO) which interfaces dhcpd listens to and (as suggested by
krw) their address. As dhcpd uses BPF, it's not possible to find this
information out from fstat/netstat.  ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.29 2011/11/12 15:39:52 krw Exp $ */
d363 1
@


1.29
log
@Zero option processing stack storage to prevent stack garbage that
happens to look like options from being processed as options when
truncated packets received.

Potential problem pointed out by mikeb@@, from a couple of NIST
reports (CVE-2011-2748 and CVE-2011-2749).
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.28 2010/11/19 08:00:56 ajacoutot Exp $ */
d263 2
@


1.28
log
@Prevent dhcpd(8) from trying to listen on interfaces that don't have a
valid broadcast (e.g. pflog0).

"no objection" krw@@, ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.27 2010/07/03 04:44:51 guenther Exp $ */
d393 2
@


1.27
log
@Fix the naming of interfaces and variables for rdomains and rtables
and make it possible to bind sockets (including listening sockets!)
to rtables and not just rdomains.  This changes the name of the
system calls, socket option, and ioctl.  After building with this
you should remove the files /usr/share/man/cat2/[gs]etrdomain.0.

Since this removes the existing [gs]etrdomain() system calls, the
libc major is bumped.

Written by claudio@@, criticized^Wcritiqued by me
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.26 2010/04/19 12:22:09 claudio Exp $ */
d101 2
a102 1
		    (!(ifa->ifa_flags & IFF_UP)))
@


1.26
log
@If interfaces are specified, get their rdomain and bind dhcpd into the same
domain with setrdomain(). This allows to run dhcpd on multiple rdomains.
OK krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.25 2010/01/02 04:21:16 krw Exp $ */
d636 1
a636 1
	if (ioctl(s, SIOCGIFRTABLEID, (caddr_t)&ifr) != -1)
@


1.25
log
@Eliminate all uses of dmalloc() where the returned pointer
is checked for NULL and a specific error/warning issued. Add
two such manual warning/error checks and kill those dmalloc
calls. And then there were none, so kill dmalloc(). Whew.
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.24 2008/09/15 20:38:17 claudio Exp $ */
d59 1
d67 1
a67 1
discover_interfaces(void)
d74 1
a74 1
	int ir = 0;
d87 3
d113 9
d623 18
@


1.24
log
@When checking if a syscall like open(), ioctl() or writev() failed compare
directly against -1 and do not use a < 0 test. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.23 2008/05/07 12:19:20 beck Exp $ */
d112 1
a112 2
			tmp = ((struct interface_info *)dmalloc(sizeof *tmp,
			    "discover_interfaces"));
@


1.23
log
@Add synchronisation support for dhcpd - this allows for two dhcpd's
with the same configuration to be run on the same net and they will
keep their lease files/state in synch, and therefore allowing you to
run redundant dhcpd's. Synchronization code stolen from spamd, uses
an hmac key in /var/db/dhcpd.key if it exists.
ok krw@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.22 2006/12/12 19:38:55 stevesk Exp $ */
d422 1
a422 1
	if (ioctl(ifsock, SIOCGIFFLAGS, &ifr) < 0) {
d438 1
a438 1
	if (ioctl(ifsock, SIOCGIFMEDIA, (caddr_t)&ifmr) < 0) {
@


1.22
log
@remove unused #defines; no binary change
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.21 2006/05/30 23:43:46 ckuethe Exp $ */
d42 1
d48 2
d279 2
d329 1
d333 6
d361 2
@


1.21
log
@This patch renames dhcpd's "struct timeout" to "struct dhcpd_timeout"
so as not to conflict with "struct timeout" from <sys/timeout.h>.
ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.20 2006/05/27 19:52:23 krw Exp $ */
a46 4

/* Most boxes has less than 16 interfaces, so this might be a good guess.  */
#define INITIAL_IFREQ_COUNT 16

a72 3
#ifdef ALIAS_NAMES_PERMUTED
	char *s;
#endif
@


1.20
log
@Don't exit just because an interface has no subnet configured in
dhcpd.conf. Just don't listen on that interface.

Make warning messages textually consistant.

tested & ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.19 2006/05/27 04:01:04 krw Exp $ */
d53 2
a54 2
struct timeout *timeouts;
static struct timeout *free_timeouts;
d300 1
a300 1
				struct timeout *t = timeouts;
d490 1
a490 1
	struct timeout *t, *q;
d514 1
a514 1
			q = (struct timeout *)malloc(sizeof (struct timeout));
d550 1
a550 1
	struct timeout *t, *q;
@


1.19
log
@When an interface is ignored because it has no IP address, say so.
Don't just say 'not found". And always complain, not just when
specific interfaces were requested.

requested by and ok uwe@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.18 2006/05/11 01:19:08 krw Exp $ */
d205 1
a205 4
	/* Now cycle through all the interfaces we found, looking for
	   hardware addresses. */

	/* Weed out the interfaces that did not have IP addresses. */
d209 1
d211 1
a211 1
			warning("%s: no IP address found, can't listen.",
a219 1
		last = tmp;
a222 1
		/* We must have a subnet declaration for each interface. */
d224 9
a232 6
			warning("No subnet declaration for %s (%s).",
			    tmp->name, inet_ntoa(foo.sin_addr));
			warning("Please write a subnet declaration in your %s",
			    "dhcpd.conf file for the");
			error("network segment to which interface %s %s",
			    tmp->name, "is attached.");
d235 3
a237 2
		/* Find subnets that don't have valid interface
		   addresses... */
@


1.18
log
@If a list of interfaces is supplied via the command line or
dhcpd.interfaces then

a) don't bother looking up information on interfaces that were not
requested;

b) don't exit if a requested interface is not found, just issue a
warning message;

c) exit if none of the interfaces were found.

The command line for dhcpd shown in ps will continue to show requested
but ignored interfaces.

As usual with dhc* code, whack a bunch of unused states, constants,
flags, etc. Since we only invoke discover_interfaces() with
DISCOVER_SERVER, there is no need to keep track of other
possibilities.
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.17 2006/03/16 15:44:40 claudio Exp $ */
d213 3
a215 3
			if (ir)
				warning("%s: not found", tmp->name);
			/* Remove tmp from the list of interfaces. */	
@


1.17
log
@KNF. No binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.16 2005/01/31 18:27:38 millert Exp $ */
d67 1
a67 1
discover_interfaces(int state)
d74 1
a74 1
	int ir;
d84 6
a89 9
	/* If we already have a list of interfaces, and we're running as
	   a DHCP server, the interfaces were requested. */
	if (interfaces && (state == DISCOVER_SERVER ||
	    state == DISCOVER_RELAY || state == DISCOVER_REQUESTED))
		ir = 0;
	else if (state == DISCOVER_UNCONFIGURED)
		ir = INTERFACE_REQUESTED | INTERFACE_AUTOMATIC;
	else
		ir = INTERFACE_REQUESTED;
d101 1
a101 2
		    (!(ifa->ifa_flags & IFF_UP) &&
		    state != DISCOVER_UNCONFIGURED))
d109 4
d115 1
a115 1
		if (!tmp) {
a122 1
			tmp->flags = ir;
a207 5
	/* If we're just trying to get a list of interfaces that we might
	   be able to configure, we can quit now. */
	if (state == DISCOVER_UNCONFIGURED)
		return;

d212 4
a215 7
		if ((tmp->flags & INTERFACE_AUTOMATIC) &&
		    state == DISCOVER_REQUESTED)
			tmp->flags &=
			    ~(INTERFACE_AUTOMATIC | INTERFACE_REQUESTED);
		if (!tmp->ifp || !(tmp->flags & INTERFACE_REQUESTED)) {
			if ((tmp->flags & INTERFACE_REQUESTED) != ir)
				error("%s: not found", tmp->name);
a219 1

d227 1
a227 1
		if (!tmp->shared_network && (state == DISCOVER_SERVER)) {
d255 3
@


1.16
log
@Don't malloc fds each time, just realloc() as needed.
There's no need to clear revents -- poll() does that for us.
Move setting of cur_time to the top of the loop for better accuracy.
When poll returns 0, don't check revents since we know none were set.
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.15 2004/10/31 10:43:38 canacar Exp $ */
d381 1
a381 1
	if ((result = receive_packet (ip, u.packbuf, sizeof u,
@


1.15
log
@change the undocumented -t flag to -n used for configuration testing
and document it. cleanup some unused/unneeded variables while there.
idea & ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.14 2004/09/21 04:07:04 david Exp $ */
d282 1
a282 1
	int count, i, nfds = 0, to_msec;
d284 2
a285 1
	struct pollfd *fds;
d288 8
a295 5
	for (l = protocols; l; l = l->next)
		++nfds;
	fds = (struct pollfd *)malloc((nfds) * sizeof (struct pollfd));
	if (fds == NULL)
		error("Can't allocate poll structures.");
d297 1
a297 1
	do {
d300 1
a300 1
		 * still a timeout registered, time out the select
d303 1
a305 2
			struct timeout *t;

d307 1
a307 1
				t = timeouts;
d329 1
a329 3
		i = 0;

		for (l = protocols; l; l = l->next) {
a334 1
				fds[i].revents = 0;
a337 1

d341 4
a344 9
		/* Wait for a packet or a timeout... XXX */
		count = poll(fds, nfds, to_msec);

		/* Not likely to be transitory... */
		if (count == -1) {
			if (errno == EAGAIN || errno == EINTR) {
				time(&cur_time);
				continue;
			} else
d346 3
d351 1
a351 5
		/* Get the current time... */
		time(&cur_time);

		i = 0;
		for (l = protocols; l; l = l->next) {
a354 1
				fds[i].revents = 0;
d364 1
a364 1
	} while (1);
@


1.14
log
@spelling fixes; ok jmc@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.13 2004/09/16 18:35:43 deraadt Exp $ */
a59 2

int quiet_interface_discovery;
@


1.13
log
@avoid aliasing with libc functions; ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.12 2004/09/16 09:35:24 claudio Exp $ */
d318 1
a318 1
			 * timeout and blocking indefinetely.
@


1.12
log
@Remove the not initialized fallback_interface code and use the normal bpf
interface for that. Also store the hardware (ethernet) address in the state
so that relayed dhcp request are sent to the correct destination.
OK henning@@ requested by deraadt@@ tested otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.11 2004/09/15 22:12:50 deraadt Exp $ */
d179 1
a179 1
					warn("Multiple %s %s: %s %s",
d188 1
a188 1
					warn("Interface %s matches %s",
d198 1
a198 1
					warn("Multiple %s %s: %s %s",
d240 1
a240 1
			warn("No subnet declaration for %s (%s).",
d242 1
a242 1
			warn("Please write a subnet declaration in your %s",
d393 1
a393 1
		warn("receive_packet failed on %s: %s", ip->name,
d399 1
a399 1
			warn("Interface %s no longer appears valid.",
@


1.11
log
@size_t vs ssize_t confusion
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.10 2004/05/25 17:41:54 canacar Exp $ */
d51 1
a51 1
struct interface_info *interfaces, *dummy_interfaces, *fallback_interface;
a231 4
			/* Remember the interface in case we need to know
			   about it later. */
			tmp->next = dummy_interfaces;
			dummy_interfaces = tmp;
@


1.10
log
@handle interface removals gracefully. reported by Oliver J. Morais
ok henning@@, tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.9 2004/05/04 20:28:40 deraadt Exp $ */
d388 1
a388 1
	size_t result;
@


1.9
log
@remove things not used, spotted by lint mostly; ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: dispatch.c,v 1.8 2004/04/20 05:35:33 henning Exp $ */
d367 1
a367 1
			if ((fds[i].revents & POLLIN)) {
@


1.8
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
a276 26
}

struct interface_info *
setup_fallback(void)
{
	fallback_interface = ((struct interface_info *)dmalloc(
	    sizeof *fallback_interface, "discover_interfaces"));

	if (!fallback_interface)
		error("Insufficient memory to record fallback interface.");
	memset(fallback_interface, 0, sizeof *fallback_interface);
	strlcpy(fallback_interface->name, "fallback", IFNAMSIZ);
	fallback_interface->shared_network =
	    new_shared_network("parse_statement");
	if (!fallback_interface->shared_network)
		error("No memory for shared subnet");
	memset(fallback_interface->shared_network, 0,
	    sizeof(struct shared_network));
	fallback_interface->shared_network->name = "fallback-net";
	return fallback_interface;
}

void
reinitialize_interfaces(void)
{
	interfaces_invalidated = 1;
@


1.7
log
@more KNF
@
text
@d1 1
a1 3
/* dispatch.c

   Network input dispatcher... */
@


1.6
log
@various knf; henning ok
@
text
@d141 1
a141 1
			    LLADDR (foo), foo->sdl_alen);
d224 2
a225 1
			tmp->flags &= ~(INTERFACE_AUTOMATIC | INTERFACE_REQUESTED);
d291 2
a292 1
	fallback_interface->shared_network = new_shared_network("parse_statement");
d296 1
a296 1
	    sizeof (struct shared_network));
d507 1
a507 1
	return(0);
d509 1
a509 1
	return(1);
@


1.5
log
@a bunch of knf, ok henning
@
text
@d109 1
a109 1
		     state != DISCOVER_UNCONFIGURED))
d219 1
a219 1
	last = (struct interface_info *)0;
d391 1
a391 1
		        struct interface_info *ip = l->local;
d393 2
a394 2
			if ((fds [i].revents & POLLIN)) {
				fds [i].revents = 0;
d416 1
a416 1
		unsigned char packbuf [4095];
d463 1
a463 2
		syslog(LOG_ERR, "ioctl(SIOCGIFFLAGS) on %s: %m",
		       ifname);
d540 1
a540 1
	t = (struct timeout *)0;
d600 1
a600 1
	t = (struct timeout *)0;
@


1.4
log
@spaces
@
text
@d70 2
a71 2
void discover_interfaces (state)
	int state;
d86 1
a86 1
		error ("getifaddrs failed");
d91 1
a91 2
			   state == DISCOVER_RELAY ||
			   state == DISCOVER_REQUESTED))
d100 6
a105 4
		/* See if this is the sort of interface we want to
		   deal with.  Skip loopback, point-to-point and down
		   interfaces, except don't skip down interfaces if we're
		   trying to get a list of configurable interfaces. */
d113 2
a114 2
		for (tmp = interfaces; tmp; tmp = tmp -> next)
			if (!strcmp (tmp -> name, ifa -> ifa_name))
d120 2
a121 2
			tmp = ((struct interface_info *)
			       dmalloc (sizeof *tmp, "discover_interfaces"));
d123 6
a128 6
				error ("Insufficient memory to %s %s",
				       "record interface", ifa -> ifa_name);
			strlcpy (tmp -> name, ifa -> ifa_name, sizeof(tmp->name));
			tmp -> next = interfaces;
			tmp -> flags = ir;
			tmp -> noifmedia = tmp -> dead = tmp->errors = 0;
d134 9
a142 9
		if (ifa -> ifa_addr->sa_family == AF_LINK) {
			struct sockaddr_dl *foo = ((struct sockaddr_dl *)
						   (ifa -> ifa_addr));
			tmp -> index = foo->sdl_index;
			tmp -> hw_address.hlen = foo -> sdl_alen;
			tmp -> hw_address.htype = HTYPE_ETHER; /* XXX */
			memcpy (tmp -> hw_address.haddr,
				LLADDR (foo), foo -> sdl_alen);
		} else if (ifa -> ifa_addr->sa_family == AF_INET) {
d155 3
a157 4
			if (!tmp -> ifp) {
				int len = (IFNAMSIZ +
					   ifa -> ifa_addr->sa_len);
				tif = (struct ifreq *)malloc (len);
d159 1
a159 1
					error ("no space to remember ifp.");
d163 2
a164 2
				tmp -> ifp = tif;
				tmp -> primary_address = foo.sin_addr;
d169 1
a169 2
			memcpy (addr.iabuf, &foo.sin_addr.s_addr,
				addr.len);
d173 1
a173 1
			if ((subnet = find_subnet (addr))) {
d177 9
a185 9
				if (!subnet -> interface) {
					subnet -> interface = tmp;
					subnet -> interface_address = addr;
				} else if (subnet -> interface != tmp) {
					warn ("Multiple %s %s: %s %s",
					      "interfaces match the",
					      "same subnet",
					      subnet -> interface -> name,
					      tmp -> name);
d187 6
a192 6
				share = subnet -> shared_network;
				if (tmp -> shared_network &&
				    tmp -> shared_network != share) {
					warn ("Interface %s matches %s",
					      tmp -> name,
					      "multiple shared networks");
d194 1
a194 1
					tmp -> shared_network = share;
d197 8
a204 8
				if (!share -> interface) {
					share -> interface = tmp;
				} else if (share -> interface != tmp) {
					warn ("Multiple %s %s: %s %s",
					      "interfaces match the",
					      "same shared network",
					      share -> interface -> name,
					      tmp -> name);
d221 2
a222 2
		next = tmp -> next;
		if ((tmp -> flags & INTERFACE_AUTOMATIC) &&
d224 4
a227 5
			tmp -> flags &= ~(INTERFACE_AUTOMATIC |
					  INTERFACE_REQUESTED);
		if (!tmp -> ifp || !(tmp -> flags & INTERFACE_REQUESTED)) {
			if ((tmp -> flags & INTERFACE_REQUESTED) != ir)
				error ("%s: not found", tmp -> name);
d229 1
a229 1
				interfaces = interfaces -> next;
d231 1
a231 1
				last -> next = tmp -> next;
d235 1
a235 1
			tmp -> next = dummy_interfaces;
d241 1
a241 2
		memcpy (&foo, &tmp -> ifp -> ifr_addr,
			sizeof tmp -> ifp -> ifr_addr);
d244 7
a250 7
		if (!tmp -> shared_network && (state == DISCOVER_SERVER)) {
			warn ("No subnet declaration for %s (%s).",
			      tmp -> name, inet_ntoa (foo.sin_addr));
			warn ("Please write a subnet declaration in your %s",
			      "dhcpd.conf file for the");
			error ("network segment to which interface %s %s",
			       tmp -> name, "is attached.");
d255 10
a264 10
		for (subnet = (tmp -> shared_network
			       ? tmp -> shared_network -> subnets
			       : (struct subnet *)0);
		     subnet; subnet = subnet -> next_sibling) {
			if (!subnet -> interface_address.len) {
				/* Set the interface address for this subnet
				   to the first address we found. */
				subnet -> interface_address.len = 4;
				memcpy (subnet -> interface_address.iabuf,
					&foo.sin_addr.s_addr, 4);
d269 2
a270 2
		if_register_receive (tmp);
		if_register_send (tmp);
d274 2
a275 3
	for (tmp = interfaces; tmp; tmp = tmp -> next) {
		add_protocol (tmp -> name, tmp -> rfdesc, got_one, tmp);
	}
d280 2
a281 1
struct interface_info *setup_fallback ()
d283 3
a285 3
	fallback_interface =
		((struct interface_info *)
		 dmalloc (sizeof *fallback_interface, "discover_interfaces"));
d287 9
a295 10
		error ("Insufficient memory to record fallback interface.");
	memset (fallback_interface, 0, sizeof *fallback_interface);
	strlcpy (fallback_interface -> name, "fallback", IFNAMSIZ);
	fallback_interface -> shared_network =
		new_shared_network ("parse_statement");
	if (!fallback_interface -> shared_network)
		error ("No memory for shared subnet");
	memset (fallback_interface -> shared_network, 0,
		sizeof (struct shared_network));
	fallback_interface -> shared_network -> name = "fallback-net";
d299 2
a300 1
void reinitialize_interfaces ()
d305 8
a312 6
/* Wait for packets to come in using poll().  When a packet comes in,
   call receive_packet to receive the packet and possibly strip hardware
   addressing information from it, and then call through the
   bootp_packet_handler hook to try to do something with it. */

void dispatch ()
d314 1
a315 1
	int nfds = 0;
a316 2
	int count;
	int i;
a317 1
	int to_msec;
d319 1
a319 2
	nfds = 0;
	for (l = protocols; l; l = l -> next) {
d321 1
a321 2
	}
	fds = (struct pollfd *)malloc ((nfds) * sizeof (struct pollfd));
d323 1
a323 1
		error ("Can't allocate poll structures.");
d326 6
a331 4
		/* Call any expired timeouts, and then if there's
		   still a timeout registered, time out the select
		   call then. */
	      another:
d334 2
a335 1
			if (timeouts -> when <= cur_time) {
d337 3
a339 3
				timeouts = timeouts -> next;
				(*(t -> func)) (t -> what);
				t -> next = free_timeouts;
d343 1
d350 1
a350 2

			howlong = timeouts -> when - cur_time;
d360 3
a362 2
		for (l = protocols; l; l = l -> next) {
			struct interface_info *ip = l -> local;
d364 3
a366 3
				fds [i].fd = l -> fd;
				fds [i].events = POLLIN;
				fds [i].revents = 0;
d375 1
a375 1
		count = poll (fds, nfds, to_msec);
d382 2
a383 3
			}
			else
				error ("poll: %m");
d390 3
a392 3
		for (l = protocols; l; l = l -> next) {
		        struct interface_info *ip;
			ip = l->local;
d396 2
a397 2
				     !ip->dead))
					(*(l -> handler)) (l);
d408 2
a409 2
void got_one (l)
	struct protocol *l;
d416 1
a416 3
		unsigned char packbuf [4095]; /* Packet input buffer.
						Must be as large as largest
						 possible MTU. */
d419 1
a419 1
	struct interface_info *ip = l -> local;
d421 4
a424 4
	if ((result =
	     receive_packet (ip, u.packbuf, sizeof u, &from, &hfrom)) == -1) {
		warn ("receive_packet failed on %s: %s", ip -> name,
		      strerror(errno));
d426 2
a427 2
		if ((! interface_status(ip))
		    || (ip->noifmedia && ip->errors > 20)) {
d430 1
a430 1
			     ip->name);
d444 1
a444 1
		memcpy (ifrom.iabuf, &from.sin_addr, ifrom.len);
d446 2
a447 2
		(*bootp_packet_handler) (ip, &u.packet, result,
					 from.sin_port, ifrom, &hfrom);
d471 1
a471 1
	if ((ifr.ifr_flags & (IFF_UP|IFF_RUNNING)) != (IFF_UP|IFF_RUNNING)) {
d473 1
a473 1
	}
d482 1
a482 1
			       ifname);
d494 1
a494 1
		switch(ifmr.ifm_active & IFM_NMASK) {
d511 2
a512 2
int locate_network (packet)
	struct packet *packet;
d517 1
a517 1
	if (packet -> raw -> giaddr.s_addr) {
d519 1
d521 2
a522 2
		memcpy (ia.iabuf, &packet -> raw -> giaddr, 4);
		subnet = find_subnet (ia);
d524 1
a524 1
			packet -> shared_network = subnet -> shared_network;
d526 1
a526 1
			packet -> shared_network = (struct shared_network *)0;
d528 1
a528 2
		packet -> shared_network =
			packet -> interface -> shared_network;
d530 1
a530 1
	if (packet -> shared_network)
d535 2
a536 4
void add_timeout (when, where, what)
	time_t when;
	void (*where)(void *);
	void *what;
d542 2
a543 2
	for (q = timeouts; q; q = q -> next) {
		if (q -> func == where && q -> what == what) {
d545 1
a545 1
				t -> next = q -> next;
d547 1
a547 1
				timeouts = q -> next;
d558 3
a560 3
			free_timeouts = q -> next;
			q -> func = where;
			q -> what = what;
d562 1
a562 1
			q = (struct timeout *)malloc (sizeof (struct timeout));
d564 3
a566 3
				error ("Can't allocate timeout structure!");
			q -> func = where;
			q -> what = what;
d570 1
a570 1
	q -> when = when;
d575 2
a576 2
	if (!timeouts || timeouts -> when > q -> when) {
		q -> next = timeouts;
d582 4
a585 4
	for (t = timeouts; t -> next; t = t -> next) {
		if (t -> next -> when > q -> when) {
			q -> next = t -> next;
			t -> next = q;
d591 2
a592 2
	t -> next = q;
	q -> next = (struct timeout *)0;
d595 2
a596 3
void cancel_timeout (where, what)
	void (*where)(void *);
	void *what;
d602 2
a603 2
	for (q = timeouts; q; q = q -> next) {
		if (q -> func == where && q -> what == what) {
d605 1
a605 1
				t -> next = q -> next;
d607 1
a607 1
				timeouts = q -> next;
d615 1
a615 1
		q -> next = free_timeouts;
d621 3
a623 5
void add_protocol (name, fd, handler, local)
	char *name;
	int fd;
	void (*handler)(struct protocol *);
	void *local;
d627 1
a627 1
	p = (struct protocol *)malloc (sizeof *p);
d629 5
a633 7
		error ("can't allocate protocol struct for %s", name);

	p -> fd = fd;
	p -> handler = handler;
	p -> local = local;

	p -> next = protocols;
d637 2
a638 2
void remove_protocol (proto)
	struct protocol *proto;
d640 1
a640 1
	struct protocol *p, *next, *prev;
a641 1
	prev = (struct protocol *)0;
d643 1
a643 1
		next = p -> next;
d646 1
a646 1
				prev -> next = p -> next;
d648 2
a649 2
				protocols = p -> next;
			free (p);
@


1.3
log
@more crap bites the dust
@
text
@d110 1
a110 1
		
d182 1
a182 1
					warn ("Multiple %s %s: %s %s", 
d201 1
a201 1
					warn ("Multiple %s %s: %s %s", 
a304 2
	struct interface_info *ip;

d349 1
a349 1
			 * for poll, while not polling with a negative 
d362 1
a362 1
		
d373 1
a373 1
		if (i == 0) 
d375 1
a375 1
		
d420 1
a420 1
					 	 Must be as large as largest
d428 1
a428 1
		warn ("receive_packet failed on %s: %s", ip -> name, 
d431 1
a431 1
		if ((! interface_status(ip)) 
d435 1
a435 1
			     ip->name); 
d463 1
a463 1
	
d480 1
a480 1
	if (ifinfo->noifmedia) 
d492 1
a492 1
		 * EINVAL (or ENOTTY) simply means that the interface 
@


1.2
log
@time_t and kill a few dumb defines
@
text
@d58 2
a59 3
void (*bootp_packet_handler) PROTO ((struct interface_info *,
				     struct dhcp_packet *, int, unsigned int,
				     struct iaddr, struct hardware *));
d544 1
a544 1
	void (*where) PROTO ((void *));
d605 1
a605 1
	void (*where) PROTO ((void *));
d634 1
a634 1
	void (*handler) PROTO ((struct protocol *));
@


1.1
log
@may the whacking begin
@
text
@d385 1
a385 1
				GET_TIME (&cur_time);
d393 1
a393 1
		GET_TIME (&cur_time);
d544 1
a544 1
	TIME when;
@

