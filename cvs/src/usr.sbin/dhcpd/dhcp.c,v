head	1.55;
access;
symbols
	OPENBSD_6_0:1.45.0.4
	OPENBSD_6_0_BASE:1.45
	OPENBSD_5_9:1.45.0.2
	OPENBSD_5_9_BASE:1.45
	OPENBSD_5_8:1.42.0.4
	OPENBSD_5_8_BASE:1.42
	OPENBSD_5_7:1.41.0.2
	OPENBSD_5_7_BASE:1.41
	OPENBSD_5_6:1.38.0.4
	OPENBSD_5_6_BASE:1.38
	OPENBSD_5_5:1.36.0.6
	OPENBSD_5_5_BASE:1.36
	OPENBSD_5_4:1.36.0.2
	OPENBSD_5_4_BASE:1.36
	OPENBSD_5_3:1.33.0.2
	OPENBSD_5_3_BASE:1.33
	OPENBSD_5_2:1.32.0.10
	OPENBSD_5_2_BASE:1.32
	OPENBSD_5_1_BASE:1.32
	OPENBSD_5_1:1.32.0.8
	OPENBSD_5_0:1.32.0.6
	OPENBSD_5_0_BASE:1.32
	OPENBSD_4_9:1.32.0.4
	OPENBSD_4_9_BASE:1.32
	OPENBSD_4_8:1.32.0.2
	OPENBSD_4_8_BASE:1.32
	OPENBSD_4_7:1.30.0.2
	OPENBSD_4_7_BASE:1.30
	OPENBSD_4_6:1.27.0.8
	OPENBSD_4_6_BASE:1.27
	OPENBSD_4_5:1.27.0.4
	OPENBSD_4_5_BASE:1.27
	OPENBSD_4_4:1.27.0.2
	OPENBSD_4_4_BASE:1.27
	OPENBSD_4_3:1.25.0.6
	OPENBSD_4_3_BASE:1.25
	OPENBSD_4_2:1.25.0.4
	OPENBSD_4_2_BASE:1.25
	OPENBSD_4_1:1.25.0.2
	OPENBSD_4_1_BASE:1.25
	OPENBSD_4_0:1.24.0.2
	OPENBSD_4_0_BASE:1.24
	OPENBSD_3_9:1.20.0.2
	OPENBSD_3_9_BASE:1.20
	OPENBSD_3_8:1.19.0.4
	OPENBSD_3_8_BASE:1.19
	OPENBSD_3_7:1.19.0.2
	OPENBSD_3_7_BASE:1.19
	OPENBSD_3_6:1.12.0.2
	OPENBSD_3_6_BASE:1.12;
locks; strict;
comment	@ * @;


1.55
date	2017.02.13.23.04.05;	author krw;	state Exp;
branches;
next	1.54;
commitid	amfLXbU964CBXnkr;

1.54
date	2017.02.13.22.33.39;	author krw;	state Exp;
branches;
next	1.53;
commitid	aD6aChUv7GEv3CLZ;

1.53
date	2017.02.13.19.13.14;	author krw;	state Exp;
branches;
next	1.52;
commitid	syYFt6P4XI7prXRF;

1.52
date	2016.10.24.21.05.55;	author krw;	state Exp;
branches;
next	1.51;
commitid	c3V9x5sGZyG7jlFl;

1.51
date	2016.10.12.13.36.39;	author krw;	state Exp;
branches;
next	1.50;
commitid	YRHDPlqzz3jQ70SO;

1.50
date	2016.10.10.15.53.36;	author krw;	state Exp;
branches;
next	1.49;
commitid	iCPsETeSF6aFHy6Y;

1.49
date	2016.10.06.16.12.43;	author krw;	state Exp;
branches;
next	1.48;
commitid	AgdFqJlm4JPQ6iei;

1.48
date	2016.10.05.00.50.00;	author krw;	state Exp;
branches;
next	1.47;
commitid	7G2xpa5WQVxb96sM;

1.47
date	2016.10.04.22.47.51;	author krw;	state Exp;
branches;
next	1.46;
commitid	PTCmBSXhdCRLXLlF;

1.46
date	2016.08.05.14.02.23;	author krw;	state Exp;
branches;
next	1.45;
commitid	EtSNZfEccLQuVs0q;

1.45
date	2016.02.06.23.50.10;	author krw;	state Exp;
branches;
next	1.44;
commitid	8GMcSAoPYCa1rXN3;

1.44
date	2015.12.21.21.39.11;	author mmcc;	state Exp;
branches;
next	1.43;
commitid	qL5PsV7SFwmqz7sG;

1.43
date	2015.08.20.22.39.29;	author deraadt;	state Exp;
branches;
next	1.42;
commitid	z3HrihslRYb4HqW9;

1.42
date	2015.04.15.12.40.57;	author krw;	state Exp;
branches;
next	1.41;
commitid	5CptCrDnsG4iL0xA;

1.41
date	2014.11.11.19.59.47;	author krw;	state Exp;
branches;
next	1.40;
commitid	MeAF5RSY4nMcKZV8;

1.40
date	2014.11.10.13.03.51;	author krw;	state Exp;
branches;
next	1.39;
commitid	DKgrYnq4OYP73JOp;

1.39
date	2014.08.11.18.39.41;	author tobias;	state Exp;
branches;
next	1.38;
commitid	4Hrlq4O3XBA34bCd;

1.38
date	2014.07.11.16.48.29;	author yasuoka;	state Exp;
branches;
next	1.37;
commitid	6tZPPUQwE3KSsUgX;

1.37
date	2014.07.11.09.42.27;	author yasuoka;	state Exp;
branches;
next	1.36;
commitid	7SRccEu66mJK3N60;

1.36
date	2013.04.05.19.31.36;	author krw;	state Exp;
branches;
next	1.35;

1.35
date	2013.03.22.23.45.52;	author krw;	state Exp;
branches;
next	1.34;

1.34
date	2013.03.11.15.43.38;	author krw;	state Exp;
branches;
next	1.33;

1.33
date	2013.02.14.22.06.13;	author krw;	state Exp;
branches;
next	1.32;

1.32
date	2010.03.29.22.22.28;	author krw;	state Exp;
branches;
next	1.31;

1.31
date	2010.03.29.22.09.25;	author krw;	state Exp;
branches;
next	1.30;

1.30
date	2010.01.02.04.21.16;	author krw;	state Exp;
branches;
next	1.29;

1.29
date	2010.01.01.20.46.19;	author krw;	state Exp;
branches;
next	1.28;

1.28
date	2009.09.01.08.42.31;	author reyk;	state Exp;
branches;
next	1.27;

1.27
date	2008.07.21.16.51.18;	author millert;	state Exp;
branches;
next	1.26;

1.26
date	2008.05.07.12.19.20;	author beck;	state Exp;
branches;
next	1.25;

1.25
date	2006.12.15.16.03.16;	author stevesk;	state Exp;
branches;
next	1.24;

1.24
date	2006.06.14.14.49.46;	author ckuethe;	state Exp;
branches;
next	1.23;

1.23
date	2006.05.31.02.43.15;	author ckuethe;	state Exp;
branches;
next	1.22;

1.22
date	2006.03.16.15.44.40;	author claudio;	state Exp;
branches;
next	1.21;

1.21
date	2006.03.13.19.57.42;	author otto;	state Exp;
branches;
next	1.20;

1.20
date	2005.11.22.21.33.56;	author beck;	state Exp;
branches;
next	1.19;

1.19
date	2005.01.31.22.21.44;	author claudio;	state Exp;
branches;
next	1.18;

1.18
date	2005.01.31.21.23.08;	author claudio;	state Exp;
branches;
next	1.17;

1.17
date	2005.01.29.16.29.09;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2004.12.06.17.18.35;	author claudio;	state Exp;
branches;
next	1.15;

1.15
date	2004.12.06.13.51.16;	author claudio;	state Exp;
branches;
next	1.14;

1.14
date	2004.09.16.18.35.42;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2004.09.16.09.35.24;	author claudio;	state Exp;
branches;
next	1.12;

1.12
date	2004.05.24.06.22.45;	author henning;	state Exp;
branches;
next	1.11;

1.11
date	2004.05.04.21.25.27;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2004.05.04.20.28.40;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2004.04.21.09.11.58;	author canacar;	state Exp;
branches;
next	1.8;

1.8
date	2004.04.20.05.35.33;	author henning;	state Exp;
branches;
next	1.7;

1.7
date	2004.04.19.17.05.59;	author tom;	state Exp;
branches;
next	1.6;

1.6
date	2004.04.18.01.32.40;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2004.04.18.00.43.27;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2004.04.16.04.30.09;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2004.04.14.04.34.19;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2004.04.13.23.57.49;	author henning;	state Exp;
branches;
next	1.1;

1.1
date	2004.04.13.23.41.48;	author henning;	state Exp;
branches;
next	;


desc
@@


1.55
log
@Eliminate pointless'%m' (a.k.a. hand rolled strerror()) by using fatal() and
log_warn(). Zap a couple of explicit 'syslog()' calls.
@
text
@/*	$OpenBSD: dhcp.c,v 1.54 2017/02/13 22:33:39 krw Exp $ */

/*
 * Copyright (c) 1995, 1996, 1997, 1998, 1999
 * The Internet Software Consortium.   All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of The Internet Software Consortium nor the names
 *    of its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INTERNET SOFTWARE CONSORTIUM AND
 * CONTRIBUTORS ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE INTERNET SOFTWARE CONSORTIUM OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This software has been written for the Internet Software Consortium
 * by Ted Lemon <mellon@@fugue.com> in cooperation with Vixie
 * Enterprises.  To learn more about the Internet Software Consortium,
 * see ``http://www.vix.com/isc''.  To learn more about Vixie
 * Enterprises, see ``http://www.vix.com''.
 */

#include <sys/types.h>
#include <sys/socket.h>

#include <arpa/inet.h>

#include <net/if.h>

#include <netinet/in.h>

#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "dhcp.h"
#include "tree.h"
#include "dhcpd.h"
#include "log.h"
#include "sync.h"

int outstanding_pings;

static char dhcp_message[256];

void
dhcp(struct packet *packet, int is_udpsock)
{
	if (!locate_network(packet) && packet->packet_type != DHCPREQUEST)
		return;

	if (is_udpsock && packet->packet_type != DHCPINFORM) {
		log_info("Unable to handle a DHCP message type=%d on UDP "
		    "socket", packet->packet_type);
		return;
	}

	switch (packet->packet_type) {
	case DHCPDISCOVER:
		dhcpdiscover(packet);
		break;

	case DHCPREQUEST:
		dhcprequest(packet);
		break;

	case DHCPRELEASE:
		dhcprelease(packet);
		break;

	case DHCPDECLINE:
		dhcpdecline(packet);
		break;

	case DHCPINFORM:
		dhcpinform(packet);
		break;

	default:
		break;
	}
}

void
dhcpdiscover(struct packet *packet)
{
	struct lease *lease = find_lease(packet, packet->shared_network, 0);
	struct host_decl *hp;

	log_info("DHCPDISCOVER from %s via %s",
	    print_hw_addr(packet->raw->htype, packet->raw->hlen,
	    packet->raw->chaddr),
	    packet->raw->giaddr.s_addr ? inet_ntoa(packet->raw->giaddr) :
	    packet->interface->name);

	/* Sourceless packets don't make sense here. */
	if (!packet->shared_network) {
		log_info("Packet from unknown subnet: %s",
		    inet_ntoa(packet->raw->giaddr));
		return;
	}

	/* If we didn't find a lease, try to allocate one... */
	if (!lease) {
		lease = packet->shared_network->last_lease;

		/*
		 * If there are no leases in that subnet that have
		 * expired, we have nothing to offer this client.
		 */
		if (!lease || lease->ends > cur_time) {
			log_info("no free leases on subnet %s",
			    packet->shared_network->name);
			return;
		}

		/*
		 * If we find an abandoned lease, take it, but print a
		 * warning message, so that if it continues to lose,
		 * the administrator will eventually investigate.
		 */
		if ((lease->flags & ABANDONED_LEASE)) {
			struct lease *lp;

			/* See if we can find an unabandoned lease first. */
			for (lp = lease; lp; lp = lp->prev) {
				if (lp->ends > cur_time)
					break;
				if (!(lp->flags & ABANDONED_LEASE)) {
					lease = lp;
					break;
				}
			}

			/*
			 * If we can't find an unabandoned lease,
			 * reclaim the abandoned lease.
			 */
			if ((lease->flags & ABANDONED_LEASE)) {
				log_warnx("Reclaiming abandoned IP address %s.",
				    piaddr(lease->ip_addr));
				lease->flags &= ~ABANDONED_LEASE;

				pfmsg('L', lease); /* unabandon address */
			}
		}

		/* Try to find a host_decl that matches the client
		   identifier or hardware address on the packet, and
		   has no fixed IP address.   If there is one, hang
		   it off the lease so that its option definitions
		   can be used. */
		if (((packet->options[DHO_DHCP_CLIENT_IDENTIFIER].len != 0) &&
		    ((hp = find_hosts_by_uid(
		    packet->options[DHO_DHCP_CLIENT_IDENTIFIER].data,
		    packet->options[DHO_DHCP_CLIENT_IDENTIFIER].len)) !=
		    NULL)) ||
		    ((hp = find_hosts_by_haddr(packet->raw->htype,
		    packet->raw->chaddr, packet->raw->hlen)) != NULL)) {
			for (; hp; hp = hp->n_ipaddr) {
				if (!hp->fixed_addr) {
					lease->host = hp;
					break;
				}
			}
		} else
			lease->host = NULL;
	}

	/* If this subnet won't boot unknown clients, ignore the
	   request. */
	if (!lease->host &&
	    !lease->subnet->group->boot_unknown_clients) {
		log_info("Ignoring unknown client %s",
		    print_hw_addr(packet->raw->htype, packet->raw->hlen,
		    packet->raw->chaddr));
	} else if (lease->host && !lease->host->group->allow_booting) {
		log_info("Declining to boot client %s",
		    lease->host->name ? lease->host->name :
		    print_hw_addr(packet->raw->htype, packet->raw->hlen,
		    packet->raw->chaddr));
	} else
		ack_lease(packet, lease, DHCPOFFER, cur_time + 120);
}

void
dhcprequest(struct packet *packet)
{
	struct lease *lease;
	struct iaddr cip;
	struct subnet *subnet;
	int ours = 0;

	cip.len = 4;
	if (packet->options[DHO_DHCP_REQUESTED_ADDRESS].len == 4)
		memcpy(cip.iabuf,
		    packet->options[DHO_DHCP_REQUESTED_ADDRESS].data, 4);
	else
		memcpy(cip.iabuf, &packet->raw->ciaddr.s_addr, 4);
	subnet = find_subnet(cip);

	/* Find the lease that matches the address requested by the client. */

	if (subnet)
		lease = find_lease(packet, subnet->shared_network, &ours);
	else
		lease = NULL;

	log_info("DHCPREQUEST for %s from %s via %s", piaddr(cip),
	    print_hw_addr(packet->raw->htype, packet->raw->hlen,
	    packet->raw->chaddr),
	    packet->raw->giaddr.s_addr ? inet_ntoa(packet->raw->giaddr) :
	    packet->interface->name);

	/* If a client on a given network REQUESTs a lease on an
	 * address on a different network, NAK it.  If the Requested
	 * Address option was used, the protocol says that it must
	 * have been broadcast, so we can trust the source network
	 * information.
	 *
	 * If ciaddr was specified and Requested Address was not, then
	 * we really only know for sure what network a packet came from
	 * if it came through a BOOTP gateway - if it came through an
	 * IP router, we'll just have to assume that it's cool.
	 *
	 * If we don't think we know where the packet came from, it
	 * came through a gateway from an unknown network, so it's not
	 * from a RENEWING client.  If we recognize the network it
	 * *thinks* it's on, we can NAK it even though we don't
	 * recognize the network it's *actually* on; otherwise we just
	 * have to ignore it.
	 *
	 * We don't currently try to take advantage of access to the
	 * raw packet, because it's not available on all platforms.
	 * So a packet that was unicast to us through a router from a
	 * RENEWING client is going to look exactly like a packet that
	 * was broadcast to us from an INIT-REBOOT client.
	 *
	 * Since we can't tell the difference between these two kinds
	 * of packets, if the packet appears to have come in off the
	 * local wire, we have to treat it as if it's a RENEWING
	 * client.  This means that we can't NAK a RENEWING client on
	 * the local wire that has a bogus address.  The good news is
	 * that we won't ACK it either, so it should revert to INIT
	 * state and send us a DHCPDISCOVER, which we *can* work with.
	 *
	 * Because we can't detect that a RENEWING client is on the
	 * wrong wire, it's going to sit there trying to renew until
	 * it gets to the REBIND state, when we *can* NAK it because
	 * the packet will get to us through a BOOTP gateway.  We
	 * shouldn't actually see DHCPREQUEST packets from RENEWING
	 * clients on the wrong wire anyway, since their idea of their
	 * local router will be wrong.  In any case, the protocol
	 * doesn't really allow us to NAK a DHCPREQUEST from a
	 * RENEWING client, so we can punt on this issue.
	 */
	if (!packet->shared_network ||
	    (packet->raw->ciaddr.s_addr && packet->raw->giaddr.s_addr) ||
	    (packet->options[DHO_DHCP_REQUESTED_ADDRESS].len == 4 &&
	    !packet->raw->ciaddr.s_addr)) {

		/*
		 * If we don't know where it came from but we do know
		 * where it claims to have come from, it didn't come
		 * from there.   Fry it.
		 */
		if (!packet->shared_network) {
			if (subnet &&
			    subnet->shared_network->group->authoritative) {
				nak_lease(packet, &cip);
				return;
			}
			/* Otherwise, ignore it. */
			return;
		}

		/*
		 * If we do know where it came from and it asked for an
		 * address that is not on that shared network, nak it.
		 */
		subnet = find_grouped_subnet(packet->shared_network, cip);
		if (!subnet) {
			if (packet->shared_network->group->authoritative)
				nak_lease(packet, &cip);
			return;
		}
	}

	/*
	 * If we found a lease for the client but it's not the one the
	 * client asked for, don't send it - some other server probably
	 * made the cut.
	 */
	if (lease && !addr_eq(lease->ip_addr, cip)) {
		/*
		 * If we found the address the client asked for, but
		 * it wasn't what got picked, the lease belongs to us,
		 * so we should NAK it.
		 */
		if (ours)
			nak_lease(packet, &cip);
		return;
	}

	/*
	 * If the address the client asked for is ours, but it wasn't
	 * available for the client, NAK it.
	 */
	if (!lease && ours) {
		nak_lease(packet, &cip);
		return;
	}

	/* If we're not allowed to serve this client anymore, don't. */
	if (lease && !lease->host &&
	    !lease->subnet->group->boot_unknown_clients) {
		log_info("Ignoring unknown client %s",
		    print_hw_addr(packet->raw->htype, packet->raw->hlen,
		    packet->raw->chaddr));
		return;
	} else if (lease && lease->host && !lease->host->group->allow_booting)
		{
		log_info("Declining to renew client %s",
		    lease->host->name ? lease->host->name :
		    print_hw_addr(packet->raw->htype, packet->raw->hlen,
		    packet->raw->chaddr));
		return;
	}

	/*
	 * If we own the lease that the client is asking for,
	 * and it's already been assigned to the client, ack it.
	 */
	if (lease &&
	    ((lease->uid_len && lease->uid_len ==
	    packet->options[DHO_DHCP_CLIENT_IDENTIFIER].len &&
	    !memcmp(packet->options[DHO_DHCP_CLIENT_IDENTIFIER].data,
	    lease->uid, lease->uid_len)) ||
	    (lease->hardware_addr.hlen == packet->raw->hlen &&
	    lease->hardware_addr.htype == packet->raw->htype &&
	    !memcmp(lease->hardware_addr.haddr, packet->raw->chaddr,
	    packet->raw->hlen)))) {
		ack_lease(packet, lease, DHCPACK, 0);
		sync_lease(lease);
		return;
	}

	/*
	 * At this point, the client has requested a lease, and it's
	 * available, but it wasn't assigned to the client, which
	 * means that the client probably hasn't gone through the
	 * DHCPDISCOVER part of the protocol.  We are within our
	 * rights to send a DHCPNAK.   We can also send a DHCPACK.
	 * The thing we probably should not do is to remain silent.
	 * For now, we'll just assign the lease to the client anyway.
	 */
	if (lease) {
		ack_lease(packet, lease, DHCPACK, 0);
		sync_lease(lease);
	}
}

void
dhcprelease(struct packet *packet)
{
	char ciaddrbuf[INET_ADDRSTRLEN];
	struct lease *lease;
	struct iaddr cip;
	int i;

	/*
	 * DHCPRELEASE must not specify address in requested-address
	 * option, but old protocol specs weren't explicit about this,
	 * so let it go.
	 */
	if (packet->options[DHO_DHCP_REQUESTED_ADDRESS].len) {
		log_info("DHCPRELEASE from %s specified requested-address.",
		    print_hw_addr(packet->raw->htype, packet->raw->hlen,
		    packet->raw->chaddr));
	}

	i = DHO_DHCP_CLIENT_IDENTIFIER;
	if (packet->options[i].len) {
		lease = find_lease_by_uid(packet->options[i].data,
		    packet->options[i].len);

		/*
		 * See if we can find a lease that matches the
		 * IP address the client is claiming.
		 */
		for (; lease; lease = lease->n_uid) {
			if (!memcmp(&packet->raw->ciaddr,
			    lease->ip_addr.iabuf, 4)) {
				break;
			}
		}
	} else {
		/*
		* The client is supposed to pass a valid client-identifier,
		 * but the spec on this has changed historically, so try the
		 * IP address in ciaddr if the client-identifier fails.
		 */
		cip.len = 4;
		memcpy(cip.iabuf, &packet->raw->ciaddr, 4);
		lease = find_lease_by_ip_addr(cip);
	}

	/* Can't do >1 inet_ntoa() in a printf()! */
	strlcpy(ciaddrbuf, inet_ntoa(packet->raw->ciaddr), sizeof(ciaddrbuf));

	log_info("DHCPRELEASE of %s from %s via %s (%sfound)",
	    ciaddrbuf,
	    print_hw_addr(packet->raw->htype, packet->raw->hlen,
	    packet->raw->chaddr),
	    packet->raw->giaddr.s_addr ? inet_ntoa(packet->raw->giaddr) :
	    packet->interface->name,
	    lease ? "" : "not ");

	/* If we're already acking this lease, don't do it again. */
	if (lease && lease->state) {
		log_info("DHCPRELEASE already acking lease %s",
		    piaddr(lease->ip_addr));
		return;
	}

	/* If we found a lease, release it. */
	if (lease && lease->ends > cur_time) {
		/*
		 * First, we ping this lease to see if it's still
		 * there. if it is, we don't release it. This avoids
		 * the problem of spoofed releases being used to liberate
		 * addresses from the server.
		 */
		if (!lease->releasing) {
			log_info("DHCPRELEASE of %s from %s via %s (found)",
			    ciaddrbuf,
			    print_hw_addr(packet->raw->htype,
			    packet->raw->hlen, packet->raw->chaddr),
			    packet->raw->giaddr.s_addr ?
			    inet_ntoa(packet->raw->giaddr) :
			    packet->interface->name);

			lease->releasing = 1;
			add_timeout(cur_time + 1, lease_ping_timeout, lease);
			icmp_echorequest(&(lease->ip_addr));
			++outstanding_pings;
		} else {
			log_info("DHCPRELEASE of %s from %s via %s ignored "
			    "(release already pending)",
			    ciaddrbuf,
			    print_hw_addr(packet->raw->htype,
			    packet->raw->hlen, packet->raw->chaddr),
			    packet->raw->giaddr.s_addr ?
			    inet_ntoa(packet->raw->giaddr) :
			    packet->interface->name);
		}
	} else {
		log_info("DHCPRELEASE of %s from %s via %s for nonexistent "
		    "lease", ciaddrbuf, print_hw_addr(packet->raw->htype,
		    packet->raw->hlen, packet->raw->chaddr),
		    packet->raw->giaddr.s_addr ?
		    inet_ntoa(packet->raw->giaddr) : packet->interface->name);
	}
}

void
dhcpdecline(struct packet *packet)
{
	struct lease *lease;
	struct iaddr cip;

	/* DHCPDECLINE must specify address. */
	if (packet->options[DHO_DHCP_REQUESTED_ADDRESS].len != 4)
		return;

	cip.len = 4;
	memcpy(cip.iabuf,
	    packet->options[DHO_DHCP_REQUESTED_ADDRESS].data, 4);
	lease = find_lease_by_ip_addr(cip);

	log_info("DHCPDECLINE on %s from %s via %s",
	    piaddr(cip), print_hw_addr(packet->raw->htype,
	    packet->raw->hlen, packet->raw->chaddr),
	    packet->raw->giaddr.s_addr ? inet_ntoa(packet->raw->giaddr) :
	    packet->interface->name);

	/* If we're already acking this lease, don't do it again. */
	if (lease && lease->state) {
		log_info("DHCPDECLINE already acking lease %s",
		    piaddr(lease->ip_addr));
		return;
	}

	/* If we found a lease, mark it as unusable and complain. */
	if (lease)
		abandon_lease(lease, "declined.");
}

void
dhcpinform(struct packet *packet)
{
	struct lease lease;
	struct iaddr cip;
	struct subnet *subnet;

	/*
	 * ciaddr should be set to client's IP address but
	 * not all clients are standards compliant.
	 */
	cip.len = 4;
	if (packet->raw->ciaddr.s_addr) {
		if (memcmp(&packet->raw->ciaddr.s_addr,
		    packet->client_addr.iabuf, 4) != 0) {
			log_info("DHCPINFORM from %s but ciaddr %s is not "
			    "consistent with actual address",
			    piaddr(packet->client_addr),
			    inet_ntoa(packet->raw->ciaddr));
			return;
		}
		memcpy(cip.iabuf, &packet->raw->ciaddr.s_addr, 4);
	} else
		memcpy(cip.iabuf, &packet->client_addr.iabuf, 4);

	log_info("DHCPINFORM from %s", piaddr(cip));

	/* Find the lease that matches the address requested by the client. */
	subnet = find_subnet(cip);
	if (!subnet)
		return;

	/* Sourceless packets don't make sense here. */
	if (!subnet->shared_network) {
		log_info("Packet from unknown subnet: %s",
		    inet_ntoa(packet->raw->giaddr));
		return;
	}

	/* Use a fake lease entry */
	memset(&lease, 0, sizeof(lease));
	lease.subnet = subnet;
	lease.shared_network = subnet->shared_network;

	if (packet->options[DHO_DHCP_CLIENT_IDENTIFIER].len)
		lease.host = find_hosts_by_uid(
		    packet->options[DHO_DHCP_CLIENT_IDENTIFIER].data,
		    packet->options[DHO_DHCP_CLIENT_IDENTIFIER].len);

	lease.starts = lease.timestamp = lease.ends = MIN_TIME;
	lease.flags = INFORM_NOLEASE;
	ack_lease(packet, &lease, DHCPACK, 0);
	if (lease.state != NULL)
		free_lease_state(lease.state, "ack_lease");
}

void
nak_lease(struct packet *packet, struct iaddr *cip)
{
	struct sockaddr_in to;
	struct in_addr from;
	ssize_t result;
	int i;
	struct dhcp_packet raw;
	unsigned char nak = DHCPNAK;
	struct packet outgoing;
	struct tree_cache *options[256];
	struct tree_cache dhcpnak_tree, dhcpmsg_tree;
	struct tree_cache client_tree, server_tree;

	memset(options, 0, sizeof options);
	memset(&outgoing, 0, sizeof outgoing);
	memset(&raw, 0, sizeof raw);
	outgoing.raw = &raw;

	/* Set DHCP_MESSAGE_TYPE to DHCPNAK */
	i = DHO_DHCP_MESSAGE_TYPE;
	options[i] = &dhcpnak_tree;
	options[i]->value = &nak;
	options[i]->len = sizeof nak;
	options[i]->buf_size = sizeof nak;
	options[i]->timeout = -1;
	options[i]->tree = NULL;
	options[i]->flags = 0;

	/* Set DHCP_MESSAGE to whatever the message is */
	i = DHO_DHCP_MESSAGE;
	options[i] = &dhcpmsg_tree;
	options[i]->value = (unsigned char *)dhcp_message;
	options[i]->len = strlen(dhcp_message);
	options[i]->buf_size = strlen(dhcp_message);
	options[i]->timeout = -1;
	options[i]->tree = NULL;
	options[i]->flags = 0;

	/* Include server identifier in the NAK. At least one
	 * router vendor depends on it when using dhcp relay proxy mode.
	 */
	i = DHO_DHCP_SERVER_IDENTIFIER;
	if (packet->options[i].len) {
		options[i] = &server_tree;
		options[i]->value = packet->options[i].data,
		options[i]->len = packet->options[i].len;
		options[i]->buf_size = packet->options[i].len;
		options[i]->timeout = -1;
		options[i]->tree = NULL;
		options[i]->flags = 0;
	}

	/* Echo back the client-identifier as RFC 6842 mandates. */
	i = DHO_DHCP_CLIENT_IDENTIFIER;
	if (packet->options[i].len) {
		options[i] = &client_tree;
		options[i]->value = packet->options[i].data,
		options[i]->len = packet->options[i].len;
		options[i]->buf_size = packet->options[i].len;
		options[i]->timeout = -1;
		options[i]->tree = NULL;
		options[i]->flags = 0;
	}

	/* Do not use the client's requested parameter list. */
	i = DHO_DHCP_PARAMETER_REQUEST_LIST;
	if (packet->options[i].data) {
		packet->options[i].len = 0;
		free(packet->options[i].data);
		packet->options[i].data = NULL;
	}

	/* Set up the option buffer... */
	outgoing.packet_length = cons_options(packet, outgoing.raw,
	    0, options, 0, 0, 0, NULL, 0);

/*	memset(&raw.ciaddr, 0, sizeof raw.ciaddr);*/
	raw.siaddr = packet->interface->primary_address;
	raw.giaddr = packet->raw->giaddr;
	memcpy(raw.chaddr, packet->raw->chaddr, sizeof raw.chaddr);
	raw.hlen = packet->raw->hlen;
	raw.htype = packet->raw->htype;
	raw.xid = packet->raw->xid;
	raw.secs = packet->raw->secs;
	raw.flags = packet->raw->flags | htons(BOOTP_BROADCAST);
	raw.hops = packet->raw->hops;
	raw.op = BOOTREPLY;

	/* Report what we're sending... */
	log_info("DHCPNAK on %s to %s via %s", piaddr(*cip),
	    print_hw_addr(packet->raw->htype, packet->raw->hlen,
	    packet->raw->chaddr), packet->raw->giaddr.s_addr ?
	    inet_ntoa(packet->raw->giaddr) : packet->interface->name);

	/* Set up the common stuff... */
	memset(&to, 0, sizeof to);
	to.sin_family = AF_INET;
	to.sin_len = sizeof to;

	from = packet->interface->primary_address;

	/* Make sure that the packet is at least as big as a BOOTP packet. */
	if (outgoing.packet_length < BOOTP_MIN_LEN)
		outgoing.packet_length = BOOTP_MIN_LEN;

	/*
	 * If this was gatewayed, send it back to the gateway.
	 * Otherwise, broadcast it on the local network.
	 */
	if (raw.giaddr.s_addr) {
		to.sin_addr = raw.giaddr;
		to.sin_port = server_port;

		result = packet->interface->send_packet(packet->interface, &raw,
		    outgoing.packet_length, from, &to, packet->haddr);
		if (result == -1)
			log_warn("send_fallback");
		return;
	} else {
		to.sin_addr.s_addr = htonl(INADDR_BROADCAST);
		to.sin_port = client_port;
	}

	errno = 0;
	result = packet->interface->send_packet(packet->interface, &raw,
	    outgoing.packet_length, from, &to, NULL);
}

void
ack_lease(struct packet *packet, struct lease *lease, unsigned int offer,
    time_t when)
{
	struct lease lt;
	struct lease_state *state;
	time_t lease_time, offered_lease_time, max_lease_time, default_lease_time;
	struct class *vendor_class, *user_class;
	int ulafdr, i;

	/* If we're already acking this lease, don't do it again. */
	if (lease->state) {
		if ((lease->flags & STATIC_LEASE) ||
		    cur_time - lease->timestamp < 60) {
			log_info("already acking lease %s",
			    piaddr(lease->ip_addr));
			return;
		}
		free_lease_state(lease->state, "ACK timed out");
		lease->state = NULL;
	}

	i = DHO_DHCP_CLASS_IDENTIFIER;
	if (packet->options[i].len) {
		vendor_class = find_class(0, packet->options[i].data,
		    packet->options[i].len);
	} else
		vendor_class = NULL;

	i = DHO_DHCP_USER_CLASS_ID;
	if (packet->options[i].len) {
		user_class = find_class(1, packet->options[i].data,
		    packet->options[i].len);
	} else
		user_class = NULL;

	/*
	 * If there is not a specific host entry, and either the
	 * vendor class or user class (if they exist) deny booting,
	 * then bug out.
	 */
	if (!lease->host) {
		if (vendor_class && !vendor_class->group->allow_booting) {
			log_debug("Booting denied by vendor class");
			return;
		}

		if (user_class && !user_class->group->allow_booting) {
			log_debug("Booting denied by user class");
			return;
		}
	}

	/* Allocate a lease state structure... */
	state = new_lease_state("ack_lease");
	if (!state)
		fatalx("unable to allocate lease state!");
	memset(state, 0, sizeof *state);
	state->got_requested_address = packet->got_requested_address;
	state->shared_network = packet->interface->shared_network;

	/* Remember if we got a server identifier option. */
	i = DHO_DHCP_SERVER_IDENTIFIER;
	if (packet->options[i].len)
		state->got_server_identifier = 1;

	/* Replace the old lease hostname with the new one, if it's changed. */
	i = DHO_HOST_NAME;
	if (packet->options[i].len && lease->client_hostname &&
	    (strlen(lease->client_hostname) == packet->options[i].len) &&
	    !memcmp(lease->client_hostname, packet->options[i].data,
	    packet->options[i].len)) {
	} else if (packet->options[i].len) {
		free(lease->client_hostname);
		lease->client_hostname = malloc( packet->options[i].len + 1);
		if (!lease->client_hostname)
			fatalx("no memory for client hostname.\n");
		memcpy(lease->client_hostname, packet->options[i].data,
		    packet->options[i].len);
		lease->client_hostname[packet->options[i].len] = 0;
	} else if (lease->client_hostname) {
		free(lease->client_hostname);
		lease->client_hostname = 0;
	}

	/* Replace the lease client identifier with a new one. */
	i = DHO_DHCP_CLIENT_IDENTIFIER;
	if (packet->options[i].len && lease->client_identifier &&
	    lease->client_identifier_len == packet->options[i].len &&
	    !memcmp(lease->client_identifier, packet->options[i].data,
	    packet->options[i].len)) {
		/* Same client identifier. */
	} else if (packet->options[i].len) {
		free(lease->client_identifier);
		lease->client_identifier = malloc(packet->options[i].len);
		if (!lease->client_identifier)
			fatalx("no memory for client identifier.\n");
		lease->client_identifier_len = packet->options[i].len;
		memcpy(lease->client_identifier, packet->options[i].data,
		    packet->options[i].len);
	} else if (lease->client_identifier) {
		free(lease->client_identifier);
		lease->client_identifier = NULL;
		lease->client_identifier_len = 0;
	}

	/*
	 * Choose a filename; first from the host_decl, if any, then from
	 * the user class, then from the vendor class.
	 */
	if (lease->host && lease->host->group->filename)
		strlcpy(state->filename, lease->host->group->filename,
		    sizeof state->filename);
	else if (user_class && user_class->group->filename)
		strlcpy(state->filename, user_class->group->filename,
		    sizeof state->filename);
	else if (vendor_class && vendor_class->group->filename)
		strlcpy(state->filename, vendor_class->group->filename,
		    sizeof state->filename);
	else if (packet->raw->file[0])
		strlcpy(state->filename, packet->raw->file,
		    sizeof state->filename);
	else if (lease->subnet->group->filename)
		strlcpy(state->filename, lease->subnet->group->filename,
		    sizeof state->filename);
	else
		strlcpy(state->filename, "", sizeof state->filename);

	/* Choose a server name as above. */
	if (lease->host && lease->host->group->server_name)
		state->server_name = lease->host->group->server_name;
	else if (user_class && user_class->group->server_name)
		state->server_name = user_class->group->server_name;
	else if (vendor_class && vendor_class->group->server_name)
		state->server_name = vendor_class->group->server_name;
	else if (lease->subnet->group->server_name)
		state->server_name = lease->subnet->group->server_name;
	else state->server_name = NULL;

	/*
	 * At this point, we have a lease that we can offer the client.
	 * Now we construct a lease structure that contains what we want,
	 * and call supersede_lease to do the right thing with it.
	 */
	memset(&lt, 0, sizeof lt);

	/*
	 * Use the ip address of the lease that we finally found in
	 * the database.
	 */
	lt.ip_addr = lease->ip_addr;

	/* Start now. */
	lt.starts = cur_time;

	/* Figure out maximum lease time. */
	if (lease->host && lease->host->group->max_lease_time)
		max_lease_time = lease->host->group->max_lease_time;
	else
		max_lease_time = lease->subnet->group->max_lease_time;

	/* Figure out default lease time. */
	if (lease->host && lease->host->group->default_lease_time)
		default_lease_time = lease->host->group->default_lease_time;
	else
		default_lease_time = lease->subnet->group->default_lease_time;

	/*
	 * Figure out how long a lease to assign.    If this is a
	 * dynamic BOOTP lease, its duration must be infinite.
	 */
	if (offer) {
		i = DHO_DHCP_LEASE_TIME;
		if (packet->options[i].len == 4) {
			lease_time = getULong( packet->options[i].data);

			/*
			 * Don't let the client ask for a longer lease than
			 * is supported for this subnet or host.
			 *
			 * time_t is signed, so really large numbers come
			 * back as negative.  Don't allow lease_time of 0,
			 * either.
			 */
			if (lease_time < 1 || lease_time > max_lease_time)
				lease_time = max_lease_time;
		} else
			lease_time = default_lease_time;

		state->offered_expiry = cur_time + lease_time;
		if (when)
			lt.ends = when;
		else
			lt.ends = state->offered_expiry;
	} else {
		if (lease->host &&
		    lease->host->group->bootp_lease_length)
			lt.ends = (cur_time +
			    lease->host->group->bootp_lease_length);
		else if (lease->subnet->group->bootp_lease_length)
			lt.ends = (cur_time +
			    lease->subnet->group->bootp_lease_length);
		else if (lease->host &&
		    lease->host->group->bootp_lease_cutoff)
			lt.ends = lease->host->group->bootp_lease_cutoff;
		else
			lt.ends = lease->subnet->group->bootp_lease_cutoff;
		state->offered_expiry = lt.ends;
		lt.flags = BOOTP_LEASE;
	}

	/* Record the uid, if given... */
	i = DHO_DHCP_CLIENT_IDENTIFIER;
	if (packet->options[i].len) {
		if (packet->options[i].len <= sizeof lt.uid_buf) {
			memcpy(lt.uid_buf, packet->options[i].data,
			    packet->options[i].len);
			lt.uid = lt.uid_buf;
			lt.uid_max = sizeof lt.uid_buf;
			lt.uid_len = packet->options[i].len;
		} else {
			lt.uid_max = lt.uid_len = packet->options[i].len;
			lt.uid = malloc(lt.uid_max);
			if (!lt.uid)
				fatalx("can't allocate memory for large uid.");
			memcpy(lt.uid, packet->options[i].data, lt.uid_len);
		}
	}

	lt.host = lease->host;
	lt.subnet = lease->subnet;
	lt.shared_network = lease->shared_network;

	/* Don't call supersede_lease on a mocked-up lease. */
	if (lease->flags & (STATIC_LEASE | INFORM_NOLEASE)) {
		/* Copy the hardware address into the static lease
		   structure. */
		lease->hardware_addr.hlen = packet->raw->hlen;
		lease->hardware_addr.htype = packet->raw->htype;
		memcpy(lease->hardware_addr.haddr, packet->raw->chaddr,
		    sizeof packet->raw->chaddr); /* XXX */
	} else {
		/* Record the hardware address, if given... */
		lt.hardware_addr.hlen = packet->raw->hlen;
		lt.hardware_addr.htype = packet->raw->htype;
		memcpy(lt.hardware_addr.haddr, packet->raw->chaddr,
		    sizeof packet->raw->chaddr);

		/* Install the new information about this lease in the
		   database.  If this is a DHCPACK or a dynamic BOOTREPLY
		   and we can't write the lease, don't ACK it (or BOOTREPLY
		   it) either. */

		if (!(supersede_lease(lease, &lt, !offer ||
		    offer == DHCPACK) || (offer && offer != DHCPACK))) {
			free_lease_state(state, "ack_lease: !supersede_lease");
			return;
		}
	}

	/* Remember the interface on which the packet arrived. */
	state->ip = packet->interface;

	/* Set a flag if this client is a lame Microsoft client that NUL
	   terminates string options and expects us to do likewise. */
	i = DHO_HOST_NAME;
	if (packet->options[i].len &&
	    packet->options[i].data[packet->options[i].len - 1] == '\0')
		lease->flags |= MS_NULL_TERMINATION;
	else
		lease->flags &= ~MS_NULL_TERMINATION;

	/* Remember the giaddr, xid, secs, flags and hops. */
	state->giaddr = packet->raw->giaddr;
	state->ciaddr = packet->raw->ciaddr;
	state->xid = packet->raw->xid;
	state->secs = packet->raw->secs;
	state->bootp_flags = packet->raw->flags;
	state->hops = packet->raw->hops;
	state->offer = offer;
	memcpy(&state->haddr, packet->haddr, sizeof state->haddr);

	/* Figure out what options to send to the client: */

	/* Start out with the subnet options... */
	memcpy(state->options, lease->subnet->group->options,
	    sizeof state->options);

	/* Vendor and user classes are only supported for DHCP clients. */
	if (state->offer) {
		/* If we have a vendor class, install those options,
		   superseding any subnet options. */
		if (vendor_class) {
			for (i = 0; i < 256; i++)
				if (vendor_class->group->options[i])
					state->options[i] =
					    vendor_class->group->options[i];
		}

		/* If we have a user class, install those options,
		   superseding any subnet and vendor class options. */
		if (user_class) {
			for (i = 0; i < 256; i++)
				if (user_class->group->options[i])
					state->options[i] =
					    user_class->group->options[i];
		}

	}

	/* If we have a host_decl structure, install the associated
	   options, superseding anything that's in the way. */
	if (lease->host) {
		for (i = 0; i < 256; i++)
			if (lease->host->group->options[i])
				state->options[i] =
				    lease->host->group->options[i];
	}

	/* Get the Maximum Message Size option from the packet, if one
	   was sent. */
	i = DHO_DHCP_MAX_MESSAGE_SIZE;
	if (packet->options[i].data &&
	    packet->options[i].len == sizeof(u_int16_t))
		state->max_message_size = getUShort(packet->options[i].data);
	/* Otherwise, if a maximum message size was specified, use that. */
	else if (state->options[i] && state->options[i]->value)
		state->max_message_size = getUShort(state->options[i]->value);

	/* Save the parameter request list if there is one. */
	i = DHO_DHCP_PARAMETER_REQUEST_LIST;
	if (packet->options[i].data) {
		state->prl = calloc(1, packet->options[i].len);
		if (!state->prl)
			log_warnx("no memory for parameter request list");
		else {
			memcpy(state->prl, packet->options[i].data,
			    packet->options[i].len);
			state->prl_len = packet->options[i].len;
		}
	}

	/* If we didn't get a hostname from an option somewhere, see if
	   we can get one from the lease. */
	i = DHO_HOST_NAME;
	if (!state->options[i] && lease->hostname) {
		state->options[i] = new_tree_cache("hostname");
		state->options[i]->flags = TC_TEMPORARY;
		state->options[i]->value = (unsigned char *)lease->hostname;
		state->options[i]->len = strlen(lease->hostname);
		state->options[i]->buf_size = state->options[i]->len;
		state->options[i]->timeout = -1;
		state->options[i]->tree = NULL;
	}

	/*
	 * Now, if appropriate, put in DHCP-specific options that
	 * override those.
	 */
	if (state->offer) {
		i = DHO_DHCP_MESSAGE_TYPE;
		state->options[i] = new_tree_cache("message-type");
		state->options[i]->flags = TC_TEMPORARY;
		state->options[i]->value = &state->offer;
		state->options[i]->len = sizeof state->offer;
		state->options[i]->buf_size = sizeof state->offer;
		state->options[i]->timeout = -1;
		state->options[i]->tree = NULL;

		i = DHO_DHCP_SERVER_IDENTIFIER;
		if (!state->options[i]) {
		 use_primary:
			state->options[i] = new_tree_cache("server-id");
			state->options[i]->value =
			    (unsigned char *)&state->ip->primary_address;
			state->options[i]->len =
			    sizeof state->ip->primary_address;
			state->options[i]->buf_size = state->options[i]->len;
			state->options[i]->timeout = -1;
			state->options[i]->tree = NULL;
			state->from.len = sizeof state->ip->primary_address;
			memcpy(state->from.iabuf, &state->ip->primary_address,
			    state->from.len);
		} else {
			/* Find the value of the server identifier... */
			if (!tree_evaluate(state->options[i]))
				goto use_primary;
			if (!state->options[i]->value ||
			    (state->options[i]->len >
			    sizeof state->from.iabuf))
				goto use_primary;

			state->from.len = state->options[i]->len;
			memcpy(state->from.iabuf, state->options[i]->value,
			    state->from.len);
		}
		/*
		 * Do not ACK a REQUEST intended for another server.
		 */
		if (packet->options[i].len == 4) {
			if (state->options[i]->len != 4 ||
			    memcmp(packet->options[i].data,
			    state->options[i]->value, 4) != 0) {
				free_lease_state(state, "ack_lease: "
				    "server identifier");
				return;
			}
		}

		/* If we used the vendor class the client specified, we
		   have to return it. */
		if (vendor_class) {
			i = DHO_DHCP_CLASS_IDENTIFIER;
			state->options[i] = new_tree_cache("class-identifier");
			state->options[i]->flags = TC_TEMPORARY;
			state->options[i]->value =
				(unsigned char *)vendor_class->name;
			state->options[i]->len = strlen(vendor_class->name);
			state->options[i]->buf_size = state->options[i]->len;
			state->options[i]->timeout = -1;
			state->options[i]->tree = NULL;
		}

		/* If we used the user class the client specified, we
		   have to return it. */
		if (user_class) {
			i = DHO_DHCP_USER_CLASS_ID;
			state->options[i] = new_tree_cache("user-class");
			state->options[i]->flags = TC_TEMPORARY;
			state->options[i]->value =
				(unsigned char *)user_class->name;
			state->options[i]->len = strlen(user_class->name);
			state->options[i]->buf_size = state->options[i]->len;
			state->options[i]->timeout = -1;
			state->options[i]->tree = NULL;
		}
	}

	/* for DHCPINFORM, don't include lease time parameters */
	if (state->offer && (lease->flags & INFORM_NOLEASE) == 0) {

		/* Sanity check the lease time. */
		if ((state->offered_expiry - cur_time) < 15)
			offered_lease_time = default_lease_time;
		else if (state->offered_expiry - cur_time > max_lease_time)
			offered_lease_time = max_lease_time;
		else
			offered_lease_time =
			    state->offered_expiry - cur_time;

		putULong((unsigned char *)&state->expiry, offered_lease_time);
		i = DHO_DHCP_LEASE_TIME;
		state->options[i] = new_tree_cache("lease-expiry");
		state->options[i]->flags = TC_TEMPORARY;
		state->options[i]->value = (unsigned char *)&state->expiry;
		state->options[i]->len = sizeof state->expiry;
		state->options[i]->buf_size = sizeof state->expiry;
		state->options[i]->timeout = -1;
		state->options[i]->tree = NULL;

		/* Renewal time is lease time * 0.5. */
		offered_lease_time /= 2;
		putULong((unsigned char *)&state->renewal, offered_lease_time);
		i = DHO_DHCP_RENEWAL_TIME;
		state->options[i] = new_tree_cache("renewal-time");
		state->options[i]->flags = TC_TEMPORARY;
		state->options[i]->value =
			(unsigned char *)&state->renewal;
		state->options[i]->len = sizeof state->renewal;
		state->options[i]->buf_size = sizeof state->renewal;
		state->options[i]->timeout = -1;
		state->options[i]->tree = NULL;


		/* Rebinding time is lease time * 0.875. */
		offered_lease_time += (offered_lease_time / 2 +
		    offered_lease_time / 4);
		putULong((unsigned char *)&state->rebind, offered_lease_time);
		i = DHO_DHCP_REBINDING_TIME;
		state->options[i] = new_tree_cache("rebind-time");
		state->options[i]->flags = TC_TEMPORARY;
		state->options[i]->value = (unsigned char *)&state->rebind;
		state->options[i]->len = sizeof state->rebind;
		state->options[i]->buf_size = sizeof state->rebind;
		state->options[i]->timeout = -1;
		state->options[i]->tree = NULL;
	}

	/* Use the subnet mask from the subnet declaration if no other
	   mask has been provided. */
	i = DHO_SUBNET_MASK;
	if (!state->options[i]) {
		state->options[i] = new_tree_cache("subnet-mask");
		state->options[i]->flags = TC_TEMPORARY;
		state->options[i]->value = lease->subnet->netmask.iabuf;
		state->options[i]->len = lease->subnet->netmask.len;
		state->options[i]->buf_size = lease->subnet->netmask.len;
		state->options[i]->timeout = -1;
		state->options[i]->tree = NULL;
	}

	/* If so directed, use the leased IP address as the router address.
	   This supposedly makes Win95 machines ARP for all IP addresses,
	   so if the local router does proxy arp, you win. */

	ulafdr = 0;
	if (lease->host) {
		if (lease->host->group->use_lease_addr_for_default_route)
			ulafdr = 1;
	} else if (user_class) {
		if (user_class->group->use_lease_addr_for_default_route)
			ulafdr = 1;
	} else if (vendor_class) {
		if (vendor_class->group->use_lease_addr_for_default_route)
			ulafdr = 1;
	} else if (lease->subnet->group->use_lease_addr_for_default_route)
		ulafdr = 1;
	else
		ulafdr = 0;

	i = DHO_ROUTERS;
	if (ulafdr && !state->options[i]) {
		state->options[i] = new_tree_cache("routers");
		state->options[i]->flags = TC_TEMPORARY;
		state->options[i]->value = lease->ip_addr.iabuf;
		state->options[i]->len = lease->ip_addr.len;
		state->options[i]->buf_size = lease->ip_addr.len;
		state->options[i]->timeout = -1;
		state->options[i]->tree = NULL;
	}

	/*
	 * RFC 3046: MUST NOT echo relay agent information if the server
	 * does not understand/use the data. We don't.
	 */
	i = DHO_RELAY_AGENT_INFORMATION;
	memset(&state->options[i], 0, sizeof(state->options[i]));

	/* Echo back the client-identifier as RFC 6842 mandates. */
	i = DHO_DHCP_CLIENT_IDENTIFIER;
	if (lease->client_identifier) {
		state->options[i] = new_tree_cache("dhcp-client-identifier");
		state->options[i]->flags = TC_TEMPORARY;
		state->options[i]->value = lease->client_identifier;
		state->options[i]->len = lease->client_identifier_len;
		state->options[i]->buf_size = lease->client_identifier_len;
		state->options[i]->timeout = -1;
		state->options[i]->tree = NULL;
	} else
		memset(&state->options[i], 0, sizeof(state->options[i]));

	lease->state = state;

	/* If this is a DHCPOFFER, ping the lease address before actually
	   sending the offer. */
	if (offer == DHCPOFFER && !(lease->flags & STATIC_LEASE) &&
	    cur_time - lease->timestamp > 60) {
		lease->timestamp = cur_time;
		icmp_echorequest(&lease->ip_addr);
		add_timeout(cur_time + 1, lease_ping_timeout, lease);
		++outstanding_pings;
	} else {
		lease->timestamp = cur_time;
		dhcp_reply(lease);
	}
}

void
dhcp_reply(struct lease *lease)
{
	char ciaddrbuf[INET_ADDRSTRLEN];
	int bufs = 0, packet_length, i;
	struct dhcp_packet raw;
	struct sockaddr_in to;
	struct in_addr from;
	struct lease_state *state = lease->state;
	int nulltp, bootpp;
	u_int8_t *prl;
	int prl_len;

	if (!state)
		fatalx("dhcp_reply was supplied lease with no state!");

	/* Compose a response for the client... */
	memset(&raw, 0, sizeof raw);

	/* Copy in the filename if given; otherwise, flag the filename
	   buffer as available for options. */
	if (state->filename[0])
		strlcpy(raw.file, state->filename, sizeof raw.file);
	else
		bufs |= 1;

	/* Copy in the server name if given; otherwise, flag the
	   server_name buffer as available for options. */
	if (state->server_name)
		strlcpy(raw.sname, state->server_name, sizeof raw.sname);
	else
		bufs |= 2; /* XXX */

	memcpy(raw.chaddr, lease->hardware_addr.haddr, sizeof raw.chaddr);
	raw.hlen = lease->hardware_addr.hlen;
	raw.htype = lease->hardware_addr.htype;

	/* See if this is a Microsoft client that NUL-terminates its
	   strings and expects us to do likewise... */
	if (lease->flags & MS_NULL_TERMINATION)
		nulltp = 1;
	else
		nulltp = 0;

	/* See if this is a bootp client... */
	if (state->offer)
		bootpp = 0;
	else
		bootpp = 1;

	if (state->options[DHO_DHCP_PARAMETER_REQUEST_LIST] &&
	    state->options[DHO_DHCP_PARAMETER_REQUEST_LIST]->value) {
		prl = state->options[DHO_DHCP_PARAMETER_REQUEST_LIST]->value;
		prl_len = state->options[DHO_DHCP_PARAMETER_REQUEST_LIST]->len;
	} else if (state->prl) {
		prl = state->prl;
		prl_len = state->prl_len;
	} else {
		prl = NULL;
		prl_len = 0;
	}

	/* Insert such options as will fit into the buffer. */
	packet_length = cons_options(NULL, &raw, state->max_message_size,
	    state->options, bufs, nulltp, bootpp, prl, prl_len);

	/* Having done the cons_options(), we can release the tree_cache
	   entries. */
	for (i = 0; i < 256; i++) {
		if (state->options[i] &&
		    state->options[i]->flags & TC_TEMPORARY)
			free_tree_cache(state->options[i]);
	}

	memcpy(&raw.ciaddr, &state->ciaddr, sizeof raw.ciaddr);
	if ((lease->flags & INFORM_NOLEASE) == 0)
		memcpy(&raw.yiaddr, lease->ip_addr.iabuf, 4);

	/* Figure out the address of the next server. */
	if (lease->host && lease->host->group->next_server.len)
		memcpy(&raw.siaddr, lease->host->group->next_server.iabuf, 4);
	else if (lease->subnet->group->next_server.len)
		memcpy(&raw.siaddr, lease->subnet->group->next_server.iabuf,
		    4);
	else if (lease->subnet->interface_address.len)
		memcpy(&raw.siaddr, lease->subnet->interface_address.iabuf, 4);
	else
		raw.siaddr = state->ip->primary_address;

	raw.giaddr = state->giaddr;

	raw.xid = state->xid;
	raw.secs = state->secs;
	raw.flags = state->bootp_flags;
	raw.hops = state->hops;
	raw.op = BOOTREPLY;

	/* Can't do >1 inet_ntoa() in a printf()! */
	strlcpy(ciaddrbuf, inet_ntoa(state->ciaddr), sizeof(ciaddrbuf));

	/* Say what we're doing... */
	if ((state->offer == DHCPACK) && (lease->flags & INFORM_NOLEASE))
		log_info("DHCPACK to %s (%s) via %s",
		    ciaddrbuf,
		    print_hw_addr(lease->hardware_addr.htype,
		        lease->hardware_addr.hlen, lease->hardware_addr.haddr),
		    state->giaddr.s_addr ? inet_ntoa(state->giaddr) :
		        state->ip->name);
	else
		log_info("%s on %s to %s via %s",
		    (state->offer ? (state->offer == DHCPACK ? "DHCPACK" :
			"DHCPOFFER") : "BOOTREPLY"),
		    piaddr(lease->ip_addr),
		    print_hw_addr(lease->hardware_addr.htype,
		        lease->hardware_addr.hlen, lease->hardware_addr.haddr),
		    state->giaddr.s_addr ? inet_ntoa(state->giaddr) :
		        state->ip->name);

	memset(&to, 0, sizeof to);
	to.sin_family = AF_INET;
#ifdef HAVE_SA_LEN
	to.sin_len = sizeof to;
#endif

	/* Make sure outgoing packets are at least as big
	   as a BOOTP packet. */
	if (packet_length < BOOTP_MIN_LEN)
		packet_length = BOOTP_MIN_LEN;

	/* If this was gatewayed, send it back to the gateway... */
	if (raw.giaddr.s_addr) {
		to.sin_addr = raw.giaddr;
		to.sin_port = server_port;

		memcpy(&from, state->from.iabuf, sizeof from);

		(void) state->ip->send_packet(state->ip, &raw,
		    packet_length, from, &to, &state->haddr);

		free_lease_state(state, "dhcp_reply gateway");
		lease->state = NULL;
		return;

	/* If the client is RENEWING, unicast to the client using the
	   regular IP stack.  Some clients, particularly those that
	   follow RFC1541, are buggy, and send both ciaddr and
	   server-identifier.  We deal with this situation by assuming
	   that if we got both dhcp-server-identifier and ciaddr, and
	   giaddr was not set, then the client is on the local
	   network, and we can therefore unicast or broadcast to it
	   successfully.  A client in REQUESTING state on another
	   network that's making this mistake will have set giaddr,
	   and will therefore get a relayed response from the above
	   code. */
	} else if (raw.ciaddr.s_addr &&
	    !((state->got_server_identifier ||
	    (raw.flags & htons(BOOTP_BROADCAST))) &&
	    /* XXX This won't work if giaddr isn't zero, but it is: */
	    (state->shared_network == lease->shared_network)) &&
	    state->offer == DHCPACK) {
		to.sin_addr = raw.ciaddr;
		to.sin_port = client_port;

	/* If it comes from a client that already knows its address
	   and is not requesting a broadcast response, and we can
	   unicast to a client without using the ARP protocol, sent it
	   directly to that client. */
	} else if (!(raw.flags & htons(BOOTP_BROADCAST))) {
		to.sin_addr = raw.yiaddr;
		to.sin_port = client_port;

	/* Otherwise, broadcast it on the local network. */
	} else {
		to.sin_addr.s_addr = htonl(INADDR_BROADCAST);
		to.sin_port = client_port;
		memset(&state->haddr, 0xff, sizeof state->haddr);
	}

	memcpy(&from, state->from.iabuf, sizeof from);

	(void) state->ip->send_packet(state->ip, &raw, packet_length,
	    from, &to, &state->haddr);

	free_lease_state(state, "dhcp_reply");
	lease->state = NULL;
}

struct lease *
find_lease(struct packet *packet, struct shared_network *share,
    int *ours)
{
	struct lease *uid_lease, *ip_lease, *hw_lease;
	struct lease *lease = NULL;
	struct iaddr cip;
	struct host_decl *hp, *host = NULL;
	struct lease *fixed_lease;

	/* Figure out what IP address the client is requesting, if any. */
	if (packet->options[DHO_DHCP_REQUESTED_ADDRESS].len == 4) {
		packet->got_requested_address = 1;
		cip.len = 4;
		memcpy(cip.iabuf,
		    packet->options[DHO_DHCP_REQUESTED_ADDRESS].data,
		    cip.len);
	} else if (packet->raw->ciaddr.s_addr) {
		cip.len = 4;
		memcpy(cip.iabuf, &packet->raw->ciaddr, 4);
	} else
		cip.len = 0;

	/* Try to find a host or lease that's been assigned to the
	   specified unique client identifier. */
	if (packet->options[DHO_DHCP_CLIENT_IDENTIFIER].len) {
		/* First, try to find a fixed host entry for the specified
		   client identifier... */
		hp = find_hosts_by_uid(
		    packet->options[DHO_DHCP_CLIENT_IDENTIFIER].data,
		    packet->options[DHO_DHCP_CLIENT_IDENTIFIER].len);
		if (hp) {
			host = hp;
			fixed_lease = mockup_lease(packet, share, hp);
			uid_lease = NULL;
		} else {
			uid_lease = find_lease_by_uid(
			    packet->options[DHO_DHCP_CLIENT_IDENTIFIER].data,
			    packet->options[DHO_DHCP_CLIENT_IDENTIFIER].len);
			/* Find the lease matching this uid that's on the
			   network the packet came from (if any). */
			for (; uid_lease; uid_lease = uid_lease->n_uid)
				if (uid_lease->shared_network == share)
					break;
			fixed_lease = NULL;
			if (uid_lease && (uid_lease->flags & ABANDONED_LEASE))
				uid_lease = NULL;
		}
	} else {
		uid_lease = NULL;
		fixed_lease = NULL;
	}

	/* If we didn't find a fixed lease using the uid, try doing
	   it with the hardware address... */
	if (!fixed_lease) {
		hp = find_hosts_by_haddr(packet->raw->htype,
		    packet->raw->chaddr, packet->raw->hlen);
		if (hp) {
			host = hp; /* Save it for later. */
			fixed_lease = mockup_lease(packet, share, hp);
		}
	}

	/* If fixed_lease is present but does not match the requested
	   IP address, and this is a DHCPREQUEST, then we can't return
	   any other lease, so we might as well return now. */
	if (packet->packet_type == DHCPREQUEST && fixed_lease &&
	    (fixed_lease->ip_addr.len != cip.len ||
	    memcmp(fixed_lease->ip_addr.iabuf, cip.iabuf, cip.len))) {
		if (ours)
			*ours = 1;
		strlcpy(dhcp_message, "requested address is incorrect",
		    sizeof(dhcp_message));
		return NULL;
	}

	/* Try to find a lease that's been attached to the client's
	   hardware address... */
	hw_lease = find_lease_by_hw_addr(packet->raw->chaddr,
	    packet->raw->hlen);
	/* Find the lease that's on the network the packet came from
	   (if any). */
	for (; hw_lease; hw_lease = hw_lease->n_hw) {
		if (hw_lease->shared_network == share) {
			if ((hw_lease->flags & ABANDONED_LEASE))
				continue;
			if (packet->packet_type)
				break;
			if (hw_lease->flags &
			    (BOOTP_LEASE | DYNAMIC_BOOTP_OK))
				break;
		}
	}

	/* Try to find a lease that's been allocated to the client's
	   IP address. */
	if (cip.len)
		ip_lease = find_lease_by_ip_addr(cip);
	else
		ip_lease = NULL;

	/* If ip_lease is valid at this point, set ours to one, so that
	   even if we choose a different lease, we know that the address
	   the client was requesting was ours, and thus we can NAK it. */
	if (ip_lease && ours)
		*ours = 1;

	/* If the requested IP address isn't on the network the packet
	   came from, don't use it.  Allow abandoned leases to be matched
	   here - if the client is requesting it, there's a decent chance
	   that it's because the lease database got trashed and a client
	   that thought it had this lease answered an ARP or PING, causing the
	   lease to be abandoned.   If so, this request probably came from
	   that client. */
	if (ip_lease && (ip_lease->shared_network != share)) {
		ip_lease = NULL;
		strlcpy(dhcp_message, "requested address on bad subnet",
		    sizeof(dhcp_message));
	}

	/* Toss ip_lease if it hasn't yet expired and isn't owned by the
	   client. */
	if (ip_lease && ip_lease->ends >= cur_time && ip_lease != uid_lease) {
		int i = DHO_DHCP_CLIENT_IDENTIFIER;

		/* Make sure that ip_lease actually belongs to the client,
		   and toss it if not. */
		if ((ip_lease->uid_len && packet->options[i].data &&
		    ip_lease->uid_len == packet->options[i].len &&
		    !memcmp(packet->options[i].data, ip_lease->uid,
		    ip_lease->uid_len)) ||
		    (!ip_lease->uid_len &&
		    ip_lease->hardware_addr.htype == packet->raw->htype &&
		    ip_lease->hardware_addr.hlen == packet->raw->hlen &&
		    !memcmp(ip_lease->hardware_addr.haddr, packet->raw->chaddr,
		    ip_lease->hardware_addr.hlen))) {
			if (uid_lease) {
				if (uid_lease->ends > cur_time) {
					log_warnx("client %s has duplicate "
					    "leases on %s",
					    print_hw_addr(packet->raw->htype,
					    packet->raw->hlen,
					    packet->raw->chaddr),
					    ip_lease->shared_network->name);

					if (uid_lease &&
					   !packet->raw->ciaddr.s_addr)
						release_lease(uid_lease);
				}
				uid_lease = ip_lease;
			}
		} else {
			strlcpy(dhcp_message, "requested address is not "
			    "available", sizeof(dhcp_message));
			ip_lease = NULL;
		}

		/* If we get to here and fixed_lease is not null, that means
		   that there are both a dynamic lease and a fixed-address
		   declaration for the same IP address. */
		if (packet->packet_type == DHCPREQUEST && fixed_lease) {
			fixed_lease = NULL;
db_conflict:
			log_warnx("Both dynamic and static leases present for "
			    "%s.", piaddr(cip));
			log_warnx("Either remove host declaration %s or "
			    "remove %s", (fixed_lease && fixed_lease->host ?
			    (fixed_lease->host->name ?
			    fixed_lease->host->name : piaddr(cip)) :
			    piaddr(cip)), piaddr(cip));
			log_warnx("from the dynamic address pool for %s",
			    share->name);
			if (fixed_lease)
				ip_lease = NULL;
			strlcpy(dhcp_message, "database conflict - call for "
			    "help!", sizeof(dhcp_message));
		}
	}

	/* If we get to here with both fixed_lease and ip_lease not
	   null, then we have a configuration file bug. */
	if (packet->packet_type == DHCPREQUEST && fixed_lease && ip_lease)
		goto db_conflict;

	/* Toss hw_lease if it hasn't yet expired and the uid doesn't
	   match, except that if the hardware address matches and the
	   client is now doing dynamic BOOTP (and thus hasn't provided
	   a uid) we let the client get away with it. */
	if (hw_lease && hw_lease->ends >= cur_time && hw_lease->uid &&
	    packet->options[DHO_DHCP_CLIENT_IDENTIFIER].len &&
	    hw_lease != uid_lease)
		hw_lease = NULL;

	/* Toss extra pointers to the same lease... */
	if (hw_lease == uid_lease)
		hw_lease = NULL;
	if (ip_lease == hw_lease)
		hw_lease = NULL;
	if (ip_lease == uid_lease)
		uid_lease = NULL;

	/* If we've already eliminated the lease, it wasn't there to
	   begin with.   If we have come up with a matching lease,
	   set the message to bad network in case we have to throw it out. */
	if (!ip_lease) {
		strlcpy(dhcp_message, "requested address not available",
		    sizeof(dhcp_message));
	}

	/* Now eliminate leases that are on the wrong network... */
	if (ip_lease && share != ip_lease->shared_network) {
		if (packet->packet_type == DHCPREQUEST)
			release_lease(ip_lease);
		ip_lease = NULL;
	}
	if (uid_lease && share != uid_lease->shared_network) {
		if (packet->packet_type == DHCPREQUEST)
			release_lease(uid_lease);
		uid_lease = NULL;
	}
	if (hw_lease && share != hw_lease->shared_network) {
		if (packet->packet_type == DHCPREQUEST)
			release_lease(hw_lease);
		hw_lease = NULL;
	}

	/* If this is a DHCPREQUEST, make sure the lease we're going to return
	   matches the requested IP address.   If it doesn't, don't return a
	   lease at all. */
	if (packet->packet_type == DHCPREQUEST && !ip_lease && !fixed_lease)
		return NULL;

	/* At this point, if fixed_lease is nonzero, we can assign it to
	   this client. */
	if (fixed_lease)
		lease = fixed_lease;

	/* If we got a lease that matched the ip address and don't have
	   a better offer, use that; otherwise, release it. */
	if (ip_lease) {
		if (lease) {
			if (packet->packet_type == DHCPREQUEST)
				release_lease(ip_lease);
		} else {
			lease = ip_lease;
			lease->host = NULL;
		}
	}

	/* If we got a lease that matched the client identifier, we may want
	   to use it, but if we already have a lease we like, we must free
	   the lease that matched the client identifier. */
	if (uid_lease) {
		if (lease) {
			if (packet->packet_type == DHCPREQUEST)
				release_lease(uid_lease);
		} else {
			lease = uid_lease;
			lease->host = NULL;
		}
	}

	/* The lease that matched the hardware address is treated likewise. */
	if (hw_lease) {
		if (lease) {
			if (packet->packet_type == DHCPREQUEST)
				release_lease(hw_lease);
		} else {
			lease = hw_lease;
			lease->host = NULL;
		}
	}

	/* If we found a host_decl but no matching address, try to
	   find a host_decl that has no address, and if there is one,
	   hang it off the lease so that we can use the supplied
	   options. */
	if (lease && host && !lease->host) {
		for (; host; host = host->n_ipaddr) {
			if (!host->fixed_addr) {
				lease->host = host;
				break;
			}
		}
	}

	/* If we find an abandoned lease, take it, but print a
	   warning message, so that if it continues to lose,
	   the administrator will eventually investigate. */
	if (lease && (lease->flags & ABANDONED_LEASE)) {
		if (packet->packet_type == DHCPREQUEST) {
			log_warnx("Reclaiming REQUESTed abandoned IP address "
			    "%s.", piaddr(lease->ip_addr));
			lease->flags &= ~ABANDONED_LEASE;
		} else
			lease = NULL;
	}
	return lease;
}

/*
 * Search the provided host_decl structure list for an address that's on
 * the specified shared network.  If one is found, mock up and return a
 * lease structure for it; otherwise return the null pointer.
 */
struct lease *
mockup_lease(struct packet *packet, struct shared_network *share,
    struct host_decl *hp)
{
	static struct lease mock;

	mock.subnet = find_host_for_network(&hp, &mock.ip_addr, share);
	if (!mock.subnet)
		return (NULL);
	mock.next = mock.prev = NULL;
	mock.shared_network = mock.subnet->shared_network;
	mock.host = hp;

	if (hp->group->options[DHO_DHCP_CLIENT_IDENTIFIER]) {
		mock.uid =
		    hp->group->options[DHO_DHCP_CLIENT_IDENTIFIER]->value;
		mock.uid_len =
		    hp->group->options[DHO_DHCP_CLIENT_IDENTIFIER]->len;
	} else {
		mock.uid = NULL;
		mock.uid_len = 0;
	}

	mock.hardware_addr = hp->interface;
	mock.starts = mock.timestamp = mock.ends = MIN_TIME;
	mock.flags = STATIC_LEASE;
	return &mock;
}
@


1.54
log
@Adjust some long lines.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcp.c,v 1.53 2017/02/13 19:13:14 krw Exp $ */
d691 1
a691 1
			log_warnx("send_fallback: %m");
@


1.53
log
@Switch from old errwarn.c logging to shiny new log.[ch].

ok benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcp.c,v 1.52 2016/10/24 21:05:55 krw Exp $ */
d175 2
a176 1
		    packet->options[DHO_DHCP_CLIENT_IDENTIFIER].len)) != NULL)) ||
d340 2
a341 1
	} else if (lease && lease->host && !lease->host->group->allow_booting) {
d477 3
a479 4
		log_info("DHCPRELEASE of %s from %s via %s for nonexistent lease",
		    ciaddrbuf,
		    print_hw_addr(packet->raw->htype, packet->raw->hlen,
		    packet->raw->chaddr),
d481 1
a481 2
		    inet_ntoa(packet->raw->giaddr) :
		    packet->interface->name);
d717 2
a718 1
			log_info("already acking lease %s", piaddr(lease->ip_addr));
d956 2
a957 2
		if (!(supersede_lease(lease, &lt, !offer || offer == DHCPACK) ||
		    (offer && offer != DHCPACK))) {
d1091 2
a1092 1
			    (state->options[i]->len > sizeof state->from.iabuf))
d1352 2
a1353 1
		memcpy(&raw.siaddr, lease->subnet->group->next_server.iabuf, 4);
d1596 2
a1597 1
					log_warnx("client %s has duplicate leases on %s",
d1599 2
a1600 1
					    packet->raw->hlen, packet->raw->chaddr),
d1603 2
a1604 1
					if (uid_lease && !packet->raw->ciaddr.s_addr)
d1610 2
a1611 2
			strlcpy(dhcp_message, "requested address is not available",
			    sizeof(dhcp_message));
d1621 7
a1627 6
			log_warnx("Both dynamic and static leases present for %s.",
			    piaddr(cip));
			log_warnx("Either remove host declaration %s or remove %s",
			    (fixed_lease && fixed_lease->host ?
			    (fixed_lease->host->name ? fixed_lease->host->name :
			    piaddr(cip)) : piaddr(cip)), piaddr(cip));
d1632 2
a1633 2
			strlcpy(dhcp_message, "database conflict - call for help!",
			    sizeof(dhcp_message));
d1749 2
a1750 2
			log_warnx("Reclaiming REQUESTed abandoned IP address %s.",
			    piaddr(lease->ip_addr));
d1777 4
a1780 2
		mock.uid = hp->group->options[DHO_DHCP_CLIENT_IDENTIFIER]->value;
		mock.uid_len = hp->group->options[DHO_DHCP_CLIENT_IDENTIFIER]->len;
@


1.52
log
@Compare server-identifiers and reject packets only *after* applying
value specified in dhcpd.conf.

i.e. don't assume it is always the primary address of the interface
the packet arrived on.

Fixes issues with redundant dhcpd servers and CARP'd interfaces.

Issue reported and fix tested by Johan Huldtgren
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcp.c,v 1.51 2016/10/12 13:36:39 krw Exp $ */
d58 1
d72 1
a72 1
		note("Unable to handle a DHCP message type=%d on UDP "
d109 1
a109 1
	note("DHCPDISCOVER from %s via %s",
d117 1
a117 1
		note("Packet from unknown subnet: %s",
d131 1
a131 1
			note("no free leases on subnet %s",
d159 1
a159 1
				warning("Reclaiming abandoned IP address %s.",
d192 1
a192 1
		note("Ignoring unknown client %s",
d196 1
a196 1
		note("Declining to boot client %s",
d227 1
a227 1
	note("DHCPREQUEST for %s from %s via %s", piaddr(cip),
d335 1
a335 1
		note("Ignoring unknown client %s",
d340 1
a340 1
		note("Declining to renew client %s",
d394 1
a394 1
		note("DHCPRELEASE from %s specified requested-address.",
d428 1
a428 1
	note("DHCPRELEASE of %s from %s via %s (%sfound)",
d438 1
a438 1
		note("DHCPRELEASE already acking lease %s",
d452 1
a452 1
			note("DHCPRELEASE of %s from %s via %s (found)",
d465 1
a465 1
			note("DHCPRELEASE of %s from %s via %s ignored "
d475 1
a475 1
		note("DHCPRELEASE of %s from %s via %s for nonexistent lease",
d500 1
a500 1
	note("DHCPDECLINE on %s from %s via %s",
d508 1
a508 1
		note("DHCPDECLINE already acking lease %s",
d533 1
a533 1
			note("DHCPINFORM from %s but ciaddr %s is not "
d543 1
a543 1
	note("DHCPINFORM from %s", piaddr(cip));
d552 1
a552 1
		note("Packet from unknown subnet: %s",
d664 1
a664 1
	note("DHCPNAK on %s to %s via %s", piaddr(*cip),
d691 1
a691 1
			warning("send_fallback: %m");
d717 1
a717 1
			note("already acking lease %s", piaddr(lease->ip_addr));
d745 1
a745 1
			debug("Booting denied by vendor class");
d750 1
a750 1
			debug("Booting denied by user class");
d758 1
a758 1
		error("unable to allocate lease state!");
d778 1
a778 1
			error("no memory for client hostname.\n");
d798 1
a798 1
			error("no memory for client identifier.\n");
d926 1
a926 1
				error("can't allocate memory for large uid.");
d1036 1
a1036 1
			warning("no memory for parameter request list");
d1282 1
a1282 1
		error("dhcp_reply was supplied lease with no state!");
d1369 1
a1369 1
		note("DHCPACK to %s (%s) via %s",
d1376 1
a1376 1
		note("%s on %s to %s via %s",
d1593 1
a1593 1
					warning("client %s has duplicate leases on %s",
d1615 1
a1615 1
			warning("Both dynamic and static leases present for %s.",
d1617 1
a1617 1
			warning("Either remove host declaration %s or remove %s",
d1621 1
a1621 1
			warning("from the dynamic address pool for %s",
d1742 1
a1742 1
			warning("Reclaiming REQUESTed abandoned IP address %s.",
@


1.51
log
@client_identifier is not a string so using strlen() on it is
inappropriate. Which is why client_identifier_len exists.

Replace copy&pasted strlen() with client_identifier_len.

Symptoms (crash) and cause (bad c&p) spotted by sthen@@.

tested & ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcp.c,v 1.50 2016/10/10 15:53:36 krw Exp $ */
a346 9
	 * Do not ACK a REQUEST intended for another server.
	 */
	if (packet->options[DHO_DHCP_SERVER_IDENTIFIER].len == 4) {
		if (memcmp(packet->options[DHO_DHCP_SERVER_IDENTIFIER].data,
		    &packet->interface->primary_address, 4))
			return;
	}

	/*
d1096 13
@


1.50
log
@Stop pretending we use RFC 3046/Option 82/Relay Agent Information.

RFC 3042 says servers that do not understand the option will not
echo it.

Plus, our desultory attempt at echoing was almost certainly broken
for OFFERs (use after free of packet data) and not even attempted
for NACKs.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcp.c,v 1.49 2016/10/06 16:12:43 krw Exp $ */
d798 1
a798 1
	    (strlen(lease->client_identifier) == packet->options[i].len) &&
@


1.49
log
@Add support for RFC 6842. RFC 2131 said the server MUST NOT echo
the client-identifier value. RFC 6842 says the server MUST echo it.

Echoing the information disambiguates packets for relays and clients
when chaddr is 0. Similar to what dhcpv6 does.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcp.c,v 1.48 2016/10/05 00:50:00 krw Exp $ */
d1227 4
a1230 1
	/* Echo back the relay agent information, if present */
d1232 1
a1232 10
	if (state->giaddr.s_addr && !state->options[i] &&
	    packet->options[i].data && packet->options[i].len) {
		state->options[i] = new_tree_cache("relay-agent-information");
		state->options[i]->flags = TC_TEMPORARY;
		state->options[i]->value = packet->options[i].data;
		state->options[i]->len = packet->options[i].len;
		state->options[i]->buf_size = packet->options[i].len;
		state->options[i]->timeout = -1;
		state->options[i]->tree = NULL;
	}
@


1.48
log
@Use consistant idiom (intermediate variable 'i' rather than repeated
uses of very long #define names) to access option data in nak_lease()
and ack_lease().

Shortens a lot of lines, which allows a number of line splits to
be eliminates.

Makes some upcoming diffs easier to integrate.

No intentional functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcp.c,v 1.47 2016/10/04 22:47:51 krw Exp $ */
d592 3
a594 1
	struct tree_cache *options[256], dhcpnak_tree, dhcpmsg_tree, server_tree;
d619 2
a620 1
	options[i]->flags = 0; 
d635 12
d795 21
d1240 1
a1240 1
	/* RFC 2131: MUST NOT send client identifier option in OFFER/ACK! */
d1242 10
a1251 1
	memset(&state->options[i], 0, sizeof(state->options[i]));
@


1.47
log
@Zap stray whitespace.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcp.c,v 1.46 2016/08/05 14:02:23 krw Exp $ */
d600 8
a607 7
	options[DHO_DHCP_MESSAGE_TYPE] = &dhcpnak_tree;
	options[DHO_DHCP_MESSAGE_TYPE]->value = &nak;
	options[DHO_DHCP_MESSAGE_TYPE]->len = sizeof nak;
	options[DHO_DHCP_MESSAGE_TYPE]->buf_size = sizeof nak;
	options[DHO_DHCP_MESSAGE_TYPE]->timeout = -1;
	options[DHO_DHCP_MESSAGE_TYPE]->tree = NULL;
	options[DHO_DHCP_MESSAGE_TYPE]->flags = 0;
d610 8
a617 8
	options[DHO_DHCP_MESSAGE] = &dhcpmsg_tree;
	options[DHO_DHCP_MESSAGE]->value = (unsigned char *)dhcp_message;
	options[DHO_DHCP_MESSAGE]->len = strlen(dhcp_message);
	options[DHO_DHCP_MESSAGE]->buf_size = strlen(dhcp_message);
	options[DHO_DHCP_MESSAGE]->timeout = -1;
	options[DHO_DHCP_MESSAGE]->tree = NULL;
	options[DHO_DHCP_MESSAGE]->flags = 0;

d621 9
a629 11
	if (packet->options[DHO_DHCP_SERVER_IDENTIFIER].len) {
		options[DHO_DHCP_SERVER_IDENTIFIER] = &server_tree;
		options[DHO_DHCP_SERVER_IDENTIFIER]->value =
		    packet->options[DHO_DHCP_SERVER_IDENTIFIER].data,
		options[DHO_DHCP_SERVER_IDENTIFIER]->len =
		    packet->options[DHO_DHCP_SERVER_IDENTIFIER].len;
		options[DHO_DHCP_SERVER_IDENTIFIER]->buf_size =
		    packet->options[DHO_DHCP_SERVER_IDENTIFIER].len;
		options[DHO_DHCP_SERVER_IDENTIFIER]->timeout = -1;
		options[DHO_DHCP_SERVER_IDENTIFIER]->tree = NULL;
		options[DHO_DHCP_SERVER_IDENTIFIER]->flags = 0;
d717 4
a720 4
	if (packet->options[DHO_DHCP_CLASS_IDENTIFIER].len) {
		vendor_class = find_class(0,
		    packet->options[DHO_DHCP_CLASS_IDENTIFIER].data,
		    packet->options[DHO_DHCP_CLASS_IDENTIFIER].len);
d724 4
a727 4
	if (packet->options[DHO_DHCP_USER_CLASS_ID].len) {
		user_class = find_class(1,
		    packet->options[DHO_DHCP_USER_CLASS_ID].data,
		    packet->options[DHO_DHCP_USER_CLASS_ID].len);
d757 2
a758 1
	if (packet->options[DHO_DHCP_SERVER_IDENTIFIER].len)
d762 6
a767 6
	if (packet->options[DHO_HOST_NAME].len &&
	    lease->client_hostname &&
	    (strlen(lease->client_hostname) == packet->options[DHO_HOST_NAME].len) &&
	    !memcmp(lease->client_hostname, packet->options[DHO_HOST_NAME].data,
	    packet->options[DHO_HOST_NAME].len)) {
	} else if (packet->options[DHO_HOST_NAME].len) {
d769 1
a769 2
		lease->client_hostname = malloc(
		    packet->options[DHO_HOST_NAME].len + 1);
d772 3
a774 4
		memcpy(lease->client_hostname,
		    packet->options[DHO_HOST_NAME].data,
		    packet->options[DHO_HOST_NAME].len);
		lease->client_hostname[packet->options[DHO_HOST_NAME].len] = 0;
d846 3
a848 3
		if (packet->options[DHO_DHCP_LEASE_TIME].len == 4) {
			lease_time = getULong(
			    packet->options[DHO_DHCP_LEASE_TIME].data);
d939 3
a941 3
	if (packet->options[DHO_HOST_NAME].len &&
	    packet->options[DHO_HOST_NAME].data[
	    packet->options[DHO_HOST_NAME].len - 1] == '\0')
d1051 1
a1051 2
			state->options[i]->buf_size =
			    state->options[i]->len;
d1073 1
a1073 2
			state->options[i] =
				new_tree_cache("class-identifier");
d1077 2
a1078 4
			state->options[i]->len =
				strlen(vendor_class->name);
			state->options[i]->buf_size =
				state->options[i]->len;
d1091 2
a1092 4
			state->options[i]->len =
				strlen(user_class->name);
			state->options[i]->buf_size =
				state->options[i]->len;
d1110 1
a1110 2
		putULong((unsigned char *)&state->expiry,
		    offered_lease_time);
d1122 1
a1122 2
		putULong((unsigned char *)&state->renewal,
			  offered_lease_time);
d1137 1
a1137 2
		putULong((unsigned char *)&state->rebind,
		    offered_lease_time);
d1141 1
a1141 2
		state->options[i]->value =
			(unsigned char *)&state->rebind;
d1154 1
a1154 2
		state->options[i]->value =
			lease->subnet->netmask.iabuf;
d1156 1
a1156 2
		state->options[i]->buf_size =
			lease->subnet->netmask.len;
@


1.46
log
@Don't leak the option data of non-DHCPINFORM messages received on
the udp socket.

Found by David Carlier.

ok yasuoka@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcp.c,v 1.45 2016/02/06 23:50:10 krw Exp $ */
d346 1
a346 1
 	/*
d348 1
a348 1
 	 */
d353 2
a354 2
 	}
 
@


1.45
log
@Eliminate #include inside *.h files and include only needed headers in
each *.c file.

Inspired by mention of header silliness by Edgar Pettijohn and mmcc@@
on tech@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcp.c,v 1.44 2015/12/21 21:39:11 mmcc Exp $ */
d65 1
a65 1
dhcp(struct packet *packet)
d69 6
@


1.44
log
@remove NULL-checks before free()
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcp.c,v 1.43 2015/08/20 22:39:29 deraadt Exp $ */
d41 16
@


1.43
log
@stdlib.h is in scope; do not cast malloc/calloc/realloc*
ok millert krw
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcp.c,v 1.42 2015/04/15 12:40:57 krw Exp $ */
d746 1
a746 2
		if (lease->client_hostname)
			free(lease->client_hostname);
@


1.42
log
@Avoid using inet_ntoa() twice in a single printf() parameter list
by caching the results from excess inet_ntoa() calls before doing
the printf(). Should improve usefullness (?) of DHCPRELEASE log
entries by actually printing ciaddr and giaddr correctly when
dhcprelays stand between servers and clients.

Looks good to dlg@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcp.c,v 1.41 2014/11/11 19:59:47 krw Exp $ */
d877 1
a877 1
			lt.uid = (unsigned char *)malloc(lt.uid_max);
@


1.41
log
@Tweak the the DHCPACK to DHCPINFORM log entry so that it is
less threatening and more informative.

e.g.

DHCPACK on <null address> to 5c:51:4f:56:81:c3 via em0

changes to

DHCPACK to 192.168.19.62 (3c:97:0e:0c:0c:d7) via em0

Issue noted and diff tested by Marc Peters. Thanks!

ok yasuoka@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcp.c,v 1.40 2014/11/10 13:03:51 krw Exp $ */
d369 1
d411 3
d415 1
a415 1
	    inet_ntoa(packet->raw->ciaddr),
d439 1
a439 1
			    inet_ntoa(packet->raw->ciaddr),
d453 1
a453 1
			    inet_ntoa(packet->raw->ciaddr),
d462 1
a462 1
		    inet_ntoa(packet->raw->ciaddr),
d1220 1
d1313 3
d1319 1
a1319 1
		    inet_ntoa(state->ciaddr),
@


1.40
log
@Typo: consitent -> consistent.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcp.c,v 1.39 2014/08/11 18:39:41 tobias Exp $ */
d1309 16
a1324 7
	note("%s on %s to %s via %s",
	    (state->offer ? (state->offer == DHCPACK ? "DHCPACK" : "DHCPOFFER") :
	    "BOOTREPLY"),
	    piaddr(lease->ip_addr),
	    print_hw_addr(lease->hardware_addr.htype, lease->hardware_addr.hlen,
	    lease->hardware_addr.haddr),
	    state->giaddr.s_addr ? inet_ntoa(state->giaddr) : state->ip->name);
@


1.39
log
@validate len field for proper length, not just "not zero."

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcp.c,v 1.38 2014/07/11 16:48:29 yasuoka Exp $ */
d516 1
a516 1
			    "consitent with actual address",
@


1.38
log
@Fix DHCPINFORM not to lookup the lease database, not to fill the yiaddr
field and not to include the lease time parameters.

ok krw
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcp.c,v 1.37 2014/07/11 09:42:27 yasuoka Exp $ */
d190 1
a190 1
	if (packet->options[DHO_DHCP_REQUESTED_ADDRESS].len)
d254 1
a254 1
	    (packet->options[DHO_DHCP_REQUESTED_ADDRESS].len &&
d474 1
a474 1
	if (!packet->options[DHO_DHCP_REQUESTED_ADDRESS].len)
d916 1
a916 1
	if (packet->options[DHO_HOST_NAME].data &&
d1397 1
a1397 2
	if (packet->options[DHO_DHCP_REQUESTED_ADDRESS].len &&
	    packet->options[DHO_DHCP_REQUESTED_ADDRESS].len == 4) {
@


1.37
log
@Add -u option to bind UDP port as a socket to answer DHCPINFORM from
the clients on non ethernet interfaces (eg. tun(4) or pppx(4)).

input krw
ok krw
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcp.c,v 1.36 2013/04/05 19:31:36 krw Exp $ */
d503 1
a503 1
	struct lease *lease;
d512 9
a520 1
	if (packet->raw->ciaddr.s_addr)
d522 1
a522 1
	else
d539 9
a547 7
	lease = find_lease(packet, subnet->shared_network, 0);
	if (!lease) {
		note("DHCPINFORM packet from %s but no lease present",
		    print_hw_addr(packet->raw->htype, packet->raw->hlen,
		    packet->raw->chaddr));
		return;
	}
d549 5
a553 14
	/* If this subnet won't boot unknown clients, ignore the
	   request. */
	if (!lease->host &&
	    !lease->subnet->group->boot_unknown_clients) {
		note("Ignoring unknown client %s",
		    print_hw_addr(packet->raw->htype, packet->raw->hlen,
		    packet->raw->chaddr));
	} else if (lease->host && !lease->host->group->allow_booting) {
		note("Declining to boot client %s",
		    lease->host->name ? lease->host->name :
		    print_hw_addr(packet->raw->htype, packet->raw->hlen,
		    packet->raw->chaddr));
	} else
		ack_lease(packet, lease, DHCPACK, 0);
d885 1
a885 1
	if (lease->flags & STATIC_LEASE) {
d1047 36
a1132 33

		/* If we used the vendor class the client specified, we
		   have to return it. */
		if (vendor_class) {
			i = DHO_DHCP_CLASS_IDENTIFIER;
			state->options[i] =
				new_tree_cache("class-identifier");
			state->options[i]->flags = TC_TEMPORARY;
			state->options[i]->value =
				(unsigned char *)vendor_class->name;
			state->options[i]->len =
				strlen(vendor_class->name);
			state->options[i]->buf_size =
				state->options[i]->len;
			state->options[i]->timeout = -1;
			state->options[i]->tree = NULL;
		}

		/* If we used the user class the client specified, we
		   have to return it. */
		if (user_class) {
			i = DHO_DHCP_USER_CLASS_ID;
			state->options[i] = new_tree_cache("user-class");
			state->options[i]->flags = TC_TEMPORARY;
			state->options[i]->value =
				(unsigned char *)user_class->name;
			state->options[i]->len =
				strlen(user_class->name);
			state->options[i]->buf_size =
				state->options[i]->len;
			state->options[i]->timeout = -1;
			state->options[i]->tree = NULL;
		}
d1287 2
a1288 1
	memcpy(&raw.yiaddr, lease->ip_addr.iabuf, 4);
@


1.36
log
@send_packet() and writev() return ssize_t, not int. Use correct
type to store the returned value. From dhill.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcp.c,v 1.35 2013/03/22 23:45:52 krw Exp $ */
d655 1
a655 1
		result = send_packet(packet->interface, &raw,
d666 1
a666 1
	result = send_packet(packet->interface, &raw,
d1330 1
a1330 1
		(void) send_packet(state->ip, &raw,
d1374 1
a1374 1
	(void) send_packet(state->ip, &raw, packet_length,
@


1.35
log
@RFC 2131 4.3.1 seems clear that a server MUST NOT include the
client-identifier option in OFFER or ACK messages. So stop
doing so.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcp.c,v 1.34 2013/03/11 15:43:38 krw Exp $ */
d560 2
a561 1
	int result, i;
@


1.34
log
@RFC 2131 says don't ACK any REQUEST messages that contain a
server-identifier option that specifies a different dhcp server.

So don't.

Pointed put and fix tested by Andy via bugs@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcp.c,v 1.33 2013/02/14 22:06:13 krw Exp $ */
d1187 4
@


1.33
log
@Obey RFC 2131 and when the broadcast flag is set send reply back
via udp broadcast and link-local broadcast. Not udp broadcast to
link address of client. Fixes at least some switches who
use the broadcast flag.

Bug submitted by Andy via bugs@@, and fix tested by same. Thanks!

ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcp.c,v 1.32 2010/03/29 22:22:28 krw Exp $ */
d324 9
@


1.32
log
@Initialize 'flags' field of tree_cache stack variables to 0. Paranoia.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcp.c,v 1.31 2010/03/29 22:09:25 krw Exp $ */
d1355 1
@


1.31
log
@Always put server id in NAK's to requests. Some router/switches
need this, as reported in PR#6339.

Fix tested by submitter, Marcel Widget, who also supplied the diff
that I tweaked.

ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcp.c,v 1.30 2010/01/02 04:21:16 krw Exp $ */
d569 1
d578 1
d593 1
@


1.30
log
@Eliminate all uses of dmalloc() where the returned pointer
is checked for NULL and a specific error/warning issued. Add
two such manual warning/error checks and kill those dmalloc
calls. And then there were none, so kill dmalloc(). Whew.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcp.c,v 1.29 2010/01/01 20:46:19 krw Exp $ */
d555 1
a555 1
	struct tree_cache *options[256], dhcpnak_tree, dhcpmsg_tree;
d577 15
@


1.29
log
@Eliminate all uses of dfree() where the pointer is either dereferenced
immediately before the use or the pointer is checked for NULL before
the call. And then there were none, so kill dfree().
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcp.c,v 1.28 2009/09/01 08:42:31 reyk Exp $ */
d954 1
a954 1
		state->prl = dmalloc(packet->options[i].len, "ack_lease: prl");
@


1.28
log
@Echo back the Relay Agent Information option if present (RFC 3046).
Also add support for the "ipsec-tunnel" hardware type as described in
RFC 3456.

ok henning@@ krw@@ (but needs more testing from others)
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcp.c,v 1.27 2008/07/21 16:51:18 millert Exp $ */
d582 1
a582 1
		dfree(packet->options[i].data, "nak_lease");
@


1.27
log
@Initial stab at DHCPINFORM support.  OK phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcp.c,v 1.26 2008/05/07 12:19:20 beck Exp $ */
d1144 13
@


1.26
log
@Add synchronisation support for dhcpd - this allows for two dhcpd's
with the same configuration to be run on the same net and they will
keep their lease files/state in synch, and therefore allowing you to
run redundant dhcpd's. Synchronization code stolen from spamd, uses
an hmac key in /var/db/dhcpd.key if it exists.
ok krw@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcp.c,v 1.25 2006/12/15 16:03:16 stevesk Exp $ */
d494 50
a543 1
	note("DHCPINFORM from %s", inet_ntoa(packet->raw->ciaddr));
@


1.25
log
@small KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcp.c,v 1.24 2006/06/14 14:49:46 ckuethe Exp $ */
d42 1
d338 1
d351 1
a351 1
	if (lease)
d353 2
@


1.24
log
@Move the transmission of privsep messages into its own function. Wherever
we might have conditionally sent a message, we now just call the pfmsg()
function, and let it figure out whether the message should be sent or not.

ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcp.c,v 1.23 2006/05/31 02:43:15 ckuethe Exp $ */
d611 1
a611 1
		vendor_class =find_class(0,
@


1.23
log
@This diff makes dhcpd able to manipulate pf tables on certain lease events.

dhcpd is now able to place abandoned addresses into a table (to offer some
protection against machines camping on an address) and remove them from the
table if they are properly leased.

When dhcpd assigns an IP to a new hardware address, it can remove that
address from a table. This is for use with the overload table in pf; newly
arrived machines will not be punished for the actions of a machine that
went away.

beck@@ and krw@@ liked previous versions of this, henning@@ final ok
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcp.c,v 1.22 2006/03/16 15:44:40 claudio Exp $ */
a41 4
extern int pfpipe[2];
extern int gotpipe;
extern char *abandoned_tab;
extern char *changedmac_tab;
a83 1
	struct pf_cmd cmd;
d139 1
a139 7
				if (gotpipe && (abandoned_tab != NULL)){
					cmd.type = 'L';
					bcopy(lease->ip_addr.iabuf,
					    &cmd.ip.s_addr, 4);
					(void)atomicio(vwrite, pfpipe[1],
					    &cmd, sizeof(struct pf_cmd));
				}
@


1.22
log
@KNF. No binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcp.c,v 1.21 2006/03/13 19:57:42 otto Exp $ */
d42 4
d88 1
d143 8
@


1.21
log
@tiny bit of delinting; ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcp.c,v 1.20 2005/11/22 21:33:56 beck Exp $ */
d654 1
a654 1
	    (strlen (lease->client_hostname) == packet->options[DHO_HOST_NAME].len) &&
d890 1
a890 1
	    packet->options[i].len == sizeof (u_int16_t))
d916 1
a916 1
		state->options[i]->len = strlen (lease->hostname);
d953 1
a953 1
			if (!tree_evaluate (state->options[i]))
d976 1
a976 1
		state->options[i] = new_tree_cache ("lease-expiry");
d986 1
a986 1
		putULong ((unsigned char *)&state->renewal,
d989 1
a989 1
		state->options[i] = new_tree_cache ("renewal-time");
d1002 1
a1002 1
		putULong ((unsigned char *)&state->rebind,
d1005 1
a1005 1
		state->options[i] = new_tree_cache ("rebind-time");
d1019 1
a1019 1
				new_tree_cache ("class-identifier");
d1024 1
a1024 1
				strlen (vendor_class->name);
d1035 1
a1035 1
			state->options[i] = new_tree_cache ("user-class");
d1040 1
a1040 1
				strlen (user_class->name);
d1052 1
a1052 1
		state->options[i] = new_tree_cache ("subnet-mask");
d1084 1
a1084 1
		state->options[i] = new_tree_cache ("routers");
d1100 2
a1101 2
		icmp_echorequest (&lease->ip_addr);
		add_timeout (cur_time + 1, lease_ping_timeout, lease);
d1105 1
a1105 1
		dhcp_reply (lease);
d1261 1
a1261 1
	} else if (!(raw.flags & htons (BOOTP_BROADCAST))) {
d1341 1
a1341 1
			fixed_lease = mockup_lease (packet, share, hp);
d1354 1
a1354 1
		    sizeof (dhcp_message));
d1426 1
a1426 1
						release_lease (uid_lease);
@


1.20
log
@fix problem of dhcp server looping with "already acking lease"
when busy with short lease times. Fix by and discussed with millert
over a year ago, run at u of a for over a year, but never committed.
ok millert@@ cloder@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcp.c,v 1.19 2005/01/31 22:21:44 claudio Exp $ */
d512 1
a512 1
	options[DHO_DHCP_MESSAGE_TYPE]->timeout = 0xFFFFFFFF;
d520 1
a520 1
	options[DHO_DHCP_MESSAGE]->timeout = 0xFFFFFFFF;
d918 1
a918 1
		state->options[i]->timeout = 0xFFFFFFFF;
d933 1
a933 1
		state->options[i]->timeout = 0xFFFFFFFF;
d946 1
a946 1
			state->options[i]->timeout = 0xFFFFFFFF;
d981 1
a981 1
		state->options[i]->timeout = 0xFFFFFFFF;
d995 1
a995 1
		state->options[i]->timeout = 0xFFFFFFFF;
d1011 1
a1011 1
		state->options[i]->timeout = 0xFFFFFFFF;
d1027 1
a1027 1
			state->options[i]->timeout = 0xFFFFFFFF;
d1043 1
a1043 1
			state->options[i]->timeout = 0xFFFFFFFF;
d1059 1
a1059 1
		state->options[i]->timeout = 0xFFFFFFFF;
d1089 1
a1089 1
		state->options[i]->timeout = 0xFFFFFFFF;
@


1.19
log
@Be a bit more paranoid about leases that are currently acked. There is a
small window where it is possible that a lease is acked and simultaniously
removed and so the state is not removed. This may be a cause for the
"already acking" issue. OK millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcp.c,v 1.18 2005/01/31 21:23:08 claudio Exp $ */
d599 7
a605 2
		note("already acking lease %s", piaddr(lease->ip_addr));
		return;
@


1.18
log
@Simply use the ethernet source address of the request as new ethernet
destination instead of the one included in the dhcp packet. Especially
because there are to many cases where the supplied address is wrong.
This hopefully solves all problems with gateways involved, like the
one reported by Dylan Martin.
OK krw@@ henning@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcp.c,v 1.17 2005/01/29 16:29:09 millert Exp $ */
d403 7
d472 7
@


1.17
log
@Fix memory leak when supersede_lease() fails and it is a DHCPACK
or a dynamic BOOTREPLY offer.  OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcp.c,v 1.16 2004/12/06 17:18:35 claudio Exp $ */
a485 1
	struct hardware hto;
a538 4
	hto.htype = packet->raw->htype;
	hto.hlen = packet->raw->hlen;
	memcpy(hto.haddr, packet->raw->chaddr, hto.hlen);

a1096 1
	struct hardware hto;
a1192 5
	/* Set up the hardware address... */
	hto.htype = lease->hardware_addr.htype;
	hto.hlen = lease->hardware_addr.hlen;
	memcpy(hto.haddr, lease->hardware_addr.haddr, hto.hlen);

d1255 1
a1255 1
	    from, &to, &hto);
@


1.16
log
@Bah, unbreak. from not form. Noticed by Dan Harnett.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcp.c,v 1.15 2004/12/06 13:51:16 claudio Exp $ */
d807 2
a808 1
		    (offer && offer != DHCPACK)))
d810 1
@


1.15
log
@Set correct source address for relayed packets. This affects only setups that
use 'next-server' config option. From Hans Kremers. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcp.c,v 1.14 2004/09/16 18:35:42 deraadt Exp $ */
d1221 1
a1221 1
		    packet_length, form, &to, &state->haddr);
@


1.14
log
@avoid aliasing with libc functions; ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcp.c,v 1.13 2004/09/16 09:35:24 claudio Exp $ */
d1218 2
d1221 1
a1221 1
		    packet_length, raw.siaddr, &to, &state->haddr);
@


1.13
log
@Remove the not initialized fallback_interface code and use the normal bpf
interface for that. Also store the hardware (ethernet) address in the state
so that relayed dhcp request are sent to the correct destination.
OK henning@@ requested by deraadt@@ tested otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcp.c,v 1.12 2004/05/24 06:22:45 henning Exp $ */
d135 1
a135 1
				warn("Reclaiming abandoned IP address %s.",
d566 1
a566 1
			warn("send_fallback: %m");
d885 1
a885 1
			warn("no memory for parameter request list");
d1096 1
a1096 1
	int bufs = 0, packet_length, result, i;
d1218 1
a1218 1
		result = send_packet(state->ip, &raw,
d1261 1
a1261 1
	result = send_packet(state->ip, &raw, packet_length,
d1408 1
a1408 1
					warn("client %s has duplicate leases on %s",
d1430 1
a1430 1
			warn("Both dynamic and static leases present for %s.",
d1432 1
a1432 1
			warn("Either remove host declaration %s or remove %s",
d1436 1
a1436 1
			warn("from the dynamic address pool for %s",
d1557 1
a1557 1
			warn("Reclaiming REQUESTed abandoned IP address %s.",
@


1.12
log
@typo; From: Andrey Matveev <andrushock@@korovino.net>
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d563 5
a567 7
		if (fallback_interface) {
			result = send_packet(fallback_interface, &raw,
			    outgoing.packet_length, from, &to, &hto);
			if (result == -1)
				warn("send_fallback: %m");
			return;
		}
d831 1
d1218 2
a1219 3
		if (fallback_interface) {
			result = send_packet(fallback_interface, &raw,
			    packet_length,raw.siaddr, &to, NULL);
d1221 3
a1223 4
			free_lease_state(state, "dhcp_reply fallback 1");
			lease->state = NULL;
			return;
		}
a1243 8

		if (fallback_interface) {
			result = send_packet(fallback_interface, &raw,
			    packet_length, raw.siaddr, &to, NULL);
			free_lease_state(state, "dhcp_reply fallback 2");
			lease->state = NULL;
			return;
		}
@


1.11
log
@remove DEBUG_PACKET stuff; henning ok
@
text
@d1 1
a1 1
/*	$OpenBSD */
@


1.10
log
@remove things not used, spotted by lint mostly; ok henning
@
text
@a539 7
#ifdef DEBUG_PACKET
	dump_packet(packet);
	dump_raw((unsigned char *)packet->raw, packet->packet_length);
	dump_packet(&outgoing);
	dump_raw((unsigned char *)&raw, outgoing.packet_length);
#endif

a1077 5
#ifdef DEBUG_PACKET
	dump_packet(packet);
	dump_raw((unsigned char *)packet->raw, packet->packet_length);
#endif

a1206 4
#endif

#ifdef DEBUG_PACKET
	dump_raw((unsigned char *)&raw, packet_length);
@


1.9
log
@filter writes and lock bpf descriptor, ok henning@@
@
text
@d571 1
a571 1
			result = send_packet(fallback_interface, packet, &raw,
d583 1
a583 1
	result = send_packet(packet->interface, packet, &raw,
d1177 1
a1177 1
			free_tree_cache(state->options[i], "dhcp_reply");
d1236 2
a1237 2
			result = send_packet(fallback_interface, NULL,
			    &raw, packet_length,raw.siaddr, &to, NULL);
d1265 2
a1266 2
			result = send_packet(fallback_interface, NULL,
			    &raw, packet_length, raw.siaddr, &to, NULL);
d1288 1
a1288 1
	result = send_packet(state->ip, NULL, &raw, packet_length,
@


1.8
log
@$OpenBSD$
@
text
@d568 1
a568 1
		to.sin_port = local_port;
d579 1
a579 1
		to.sin_port = remote_port;
d1233 1
a1233 1
		to.sin_port = local_port;
d1262 1
a1262 1
		to.sin_port = remote_port;
d1278 1
a1278 1
		to.sin_port = remote_port;
d1283 1
a1283 1
		to.sin_port = remote_port;
@


1.7
log
@Catch negative lease times.  From openbsd@@nerd-marrow.com in PR 2888,
which this closes (though the PR was for usr.sbin/dhcpd/server/).

ok henning@@
@
text
@d1 1
a1 3
/* dhcp.c

   DHCP Protocol engine. */
@


1.6
log
@spacing
@
text
@d743 4
d748 1
a748 1
			if (lease_time > max_lease_time)
@


1.5
log
@various knf; henning ok
@
text
@d680 1
a680 1
	else if (vendor_class  && vendor_class->group->filename)
d697 1
a697 1
	else if (vendor_class  && vendor_class->group->server_name)
@


1.4
log
@a bunch of knf, ok henning
@
text
@d81 2
a82 2
void dhcpdiscover(packet)
	struct packet *packet;
d88 4
a91 6
	      print_hw_addr(packet->raw->htype,
			     packet->raw->hlen,
			     packet->raw->chaddr),
	      packet->raw->giaddr.s_addr
	      ? inet_ntoa(packet->raw->giaddr)
	      : packet->interface->name);
d96 1
a96 1
		      inet_ntoa(packet->raw->giaddr));
d104 4
a107 2
		/* If there are no leases in that subnet that have
		   expired, we have nothing to offer this client. */
d110 1
a110 1
			      packet->shared_network->name);
d114 5
a118 3
		/* If we find an abandoned lease, take it, but print a
		   warning message, so that if it continues to lose,
		   the administrator will eventually investigate. */
d132 4
a135 2
			/* If we can't find an unabandoned lease, reclaim the
			   abandoned lease. */
d138 1
a138 1
				      piaddr(lease->ip_addr));
d148 4
a151 6
		if (((packet->options[DHO_DHCP_CLIENT_IDENTIFIER].len
		      != 0) &&
		     ((hp = find_hosts_by_uid
		       (packet->options[DHO_DHCP_CLIENT_IDENTIFIER].data,
			packet->options[DHO_DHCP_CLIENT_IDENTIFIER].len))
		      != (struct host_decl *)0)) ||
d153 1
a153 3
						packet->raw->chaddr,
						packet->raw->hlen))
		     != (struct host_decl *)0)) {
d160 2
a161 3
		} else {
			lease->host = (struct host_decl *)0;
		}
d169 3
a171 5
		      print_hw_addr(packet->raw->htype,
				     packet->raw->hlen,
				     packet->raw->chaddr));
	} else if (lease->host &&
		    !lease->host->group->allow_booting) {
d173 3
a175 5
		      lease->host->name
		      ? lease->host->name
		      : print_hw_addr(packet->raw->htype,
				       packet->raw->hlen,
				       packet->raw->chaddr));
d180 2
a181 2
void dhcprequest(packet)
	struct packet *packet;
d188 2
a189 2
	if (packet->options[DHO_DHCP_REQUESTED_ADDRESS].len) {
		cip.len = 4;
d191 2
a192 4
			packet->options[DHO_DHCP_REQUESTED_ADDRESS].data,
			4);
	} else {
		cip.len = 4;
a193 1
	}
d196 1
a196 2
	/* Find the lease that matches the address requested by the
	   client. */
d203 5
a207 8
	note("DHCPREQUEST for %s from %s via %s",
	      piaddr(cip),
	      print_hw_addr(packet->raw->htype,
			     packet->raw->hlen,
			     packet->raw->chaddr),
	      packet->raw->giaddr.s_addr
	      ? inet_ntoa(packet->raw->giaddr)
	      : packet->interface->name);
d210 41
a250 41
	   address on a different network, NAK it.  If the Requested
	   Address option was used, the protocol says that it must
	   have been broadcast, so we can trust the source network
	   information.

	   If ciaddr was specified and Requested Address was not, then
	   we really only know for sure what network a packet came from
	   if it came through a BOOTP gateway - if it came through an
	   IP router, we'll just have to assume that it's cool.

	   If we don't think we know where the packet came from, it
	   came through a gateway from an unknown network, so it's not
	   from a RENEWING client.  If we recognize the network it
	   *thinks* it's on, we can NAK it even though we don't
	   recognize the network it's *actually* on; otherwise we just
	   have to ignore it.

	   We don't currently try to take advantage of access to the
	   raw packet, because it's not available on all platforms.
	   So a packet that was unicast to us through a router from a
	   RENEWING client is going to look exactly like a packet that
	   was broadcast to us from an INIT-REBOOT client.

	   Since we can't tell the difference between these two kinds
	   of packets, if the packet appears to have come in off the
	   local wire, we have to treat it as if it's a RENEWING
	   client.  This means that we can't NAK a RENEWING client on
	   the local wire that has a bogus address.  The good news is
	   that we won't ACK it either, so it should revert to INIT
	   state and send us a DHCPDISCOVER, which we *can* work with.

	   Because we can't detect that a RENEWING client is on the
	   wrong wire, it's going to sit there trying to renew until
	   it gets to the REBIND state, when we *can* NAK it because
	   the packet will get to us through a BOOTP gateway.  We
	   shouldn't actually see DHCPREQUEST packets from RENEWING
	   clients on the wrong wire anyway, since their idea of their
	   local router will be wrong.  In any case, the protocol
	   doesn't really allow us to NAK a DHCPREQUEST from a
	   RENEWING client, so we can punt on this issue. */

d252 1
a252 2
	    (packet->raw->ciaddr.s_addr &&
	     packet->raw->giaddr.s_addr) ||
d254 1
a254 1
	     !packet->raw->ciaddr.s_addr)) {
d256 5
a260 3
		/* If we don't know where it came from but we do know
		   where it claims to have come from, it didn't come
		   from there.   Fry it. */
d263 1
a263 2
			    subnet->shared_network->group->authoritative)
			{
d271 4
a274 2
		/* If we do know where it came from and it asked for an
		   address that is not on that shared network, nak it. */
d283 5
a287 3
	/* If we found a lease for the client but it's not the one the
	   client asked for, don't send it - some other server probably
	   made the cut. */
d289 5
a293 3
		/* If we found the address the client asked for, but
                   it wasn't what got picked, the lease belongs to us,
                   so we should NAK it. */
d299 4
a302 2
	/* If the address the client asked for is ours, but it wasn't
           available for the client, NAK it. */
d309 1
a309 2
	if (lease &&
	    !lease->host &&
d312 2
a313 3
		      print_hw_addr(packet->raw->htype,
				     packet->raw->hlen,
				     packet->raw->chaddr));
d315 1
a315 2
	} else if (lease && lease->host &&
		   !lease->host->group->allow_booting) {
d317 3
a319 5
		      lease->host->name
		      ? lease->host->name
		      : print_hw_addr(packet->raw->htype,
				       packet->raw->hlen,
				       packet->raw->chaddr));
d323 4
a326 2
	/* If we own the lease that the client is asking for,
	   and it's already been assigned to the client, ack it. */
d329 7
a335 9
	      packet->options[DHO_DHCP_CLIENT_IDENTIFIER].len &&
	      !memcmp(packet->options
		      [DHO_DHCP_CLIENT_IDENTIFIER].data,
		       lease->uid, lease->uid_len)) ||
	     (lease->hardware_addr.hlen == packet->raw->hlen &&
	      lease->hardware_addr.htype == packet->raw->htype &&
	      !memcmp(lease->hardware_addr.haddr,
		       packet->raw->chaddr,
		       packet->raw->hlen)))) {
d340 9
a348 7
	/* At this point, the client has requested a lease, and it's
	   available, but it wasn't assigned to the client, which
	   means that the client probably hasn't gone through the
	   DHCPDISCOVER part of the protocol.  We are within our
	   rights to send a DHCPNAK.   We can also send a DHCPACK.
	   The thing we probably should not do is to remain silent.
	   For now, we'll just assign the lease to the client anyway. */
d353 2
a354 2
void dhcprelease(packet)
	struct packet *packet;
d360 5
a364 3
	/* DHCPRELEASE must not specify address in requested-address
           option, but old protocol specs weren't explicit about this,
           so let it go. */
d367 2
a368 3
		      print_hw_addr(packet->raw->htype,
				     packet->raw->hlen,
				     packet->raw->chaddr));
d374 1
a374 1
					   packet->options[i].len);
d376 4
a379 2
		/* See if we can find a lease that matches the IP address
		   the client is claiming. */
d382 1
a382 1
				     lease->ip_addr.iabuf, 4)) {
d387 5
a391 3
		/* The client is supposed to pass a valid client-identifier,
		   but the spec on this has changed historically, so try the
		   IP address in ciaddr if the client-identifier fails. */
d398 6
a403 8
	      inet_ntoa(packet->raw->ciaddr),
	      print_hw_addr(packet->raw->htype,
			     packet->raw->hlen,
			     packet->raw->chaddr),
	      packet->raw->giaddr.s_addr
	      ? inet_ntoa(packet->raw->giaddr)
	      : packet->interface->name,
	      lease ? "" : "not ");
d407 5
a411 5
		/* first, we ping this lease to see if it's still
		 * there. if it is, we don't release it.
		 * this avoids the problem of spoofed releases
		 * being used to liberate addresses from the
		 * server.
d417 4
a420 5
				    packet->raw->hlen,
					     packet->raw->chaddr),
			      packet->raw->giaddr.s_addr
			      ? inet_ntoa(packet->raw->giaddr)
			      : packet->interface->name);
d426 9
d436 1
a436 12
		else {
			note("DHCPRELEASE of %s from %s via %s ignored (release already pending)",
			      inet_ntoa(packet->raw->ciaddr),
			      print_hw_addr(packet->raw->htype,
					     packet->raw->hlen,
					     packet->raw->chaddr),
			      packet->raw->giaddr.s_addr
			      ? inet_ntoa(packet->raw->giaddr)
			      : packet->interface->name);
		}
	}
	else {
d438 6
a443 7
		      inet_ntoa(packet->raw->ciaddr),
		      print_hw_addr(packet->raw->htype,
				     packet->raw->hlen,
				     packet->raw->chaddr),
		      packet->raw->giaddr.s_addr
		      ? inet_ntoa(packet->raw->giaddr)
		      : packet->interface->name);
d447 2
a448 2
void dhcpdecline(packet)
	struct packet *packet;
d454 1
a454 1
	if (!packet->options[DHO_DHCP_REQUESTED_ADDRESS].len) {
a455 1
	}
d459 1
a459 1
		packet->options[DHO_DHCP_REQUESTED_ADDRESS].data, 4);
d463 4
a466 7
	      piaddr(cip),
	      print_hw_addr(packet->raw->htype,
			     packet->raw->hlen,
			     packet->raw->chaddr),
	      packet->raw->giaddr.s_addr
	      ? inet_ntoa(packet->raw->giaddr)
	      : packet->interface->name);
d469 1
a469 1
	if (lease) {
a470 1
	}
d473 2
a474 2
void dhcpinform(packet)
	struct packet *packet;
d476 1
a476 2
	note("DHCPINFORM from %s",
	      inet_ntoa(packet->raw->ciaddr));
d479 2
a480 3
void nak_lease(packet, cip)
	struct packet *packet;
	struct iaddr *cip;
d484 1
a484 1
	int result;
d489 1
a489 5
	int i;

	struct tree_cache *options[256];
	struct tree_cache dhcpnak_tree;
	struct tree_cache dhcpmsg_tree;
d502 1
a502 1
	options[DHO_DHCP_MESSAGE_TYPE]->tree = (struct tree *)0;
d507 2
a508 2
	options[DHO_DHCP_MESSAGE]->len =
		options[DHO_DHCP_MESSAGE]->buf_size = strlen(dhcp_message);
d510 1
a510 1
	options[DHO_DHCP_MESSAGE]->tree = (struct tree *)0;
d517 1
a517 1
		packet->options[i].data = (unsigned char *)0;
d521 2
a522 3
	outgoing.packet_length =
		cons_options(packet, outgoing.raw, 0, options, 0, 0, 0,
			      (u_int8_t *)0, 0);
a529 1

d543 4
a546 4
	dump_packet (packet);
	dump_raw ((unsigned char *)packet->raw, packet->packet_length);
	dump_packet (&outgoing);
	dump_raw ((unsigned char *)&raw, outgoing.packet_length);
d554 1
a554 1
	memset (&to, 0, sizeof to);
d564 4
a567 2
	/* If this was gatewayed, send it back to the gateway.
	   Otherwise, broadcast it on the local network. */
d573 2
a574 4
			result = send_packet (fallback_interface,
					      packet, &raw,
					      outgoing.packet_length,
					      from, &to, &hto);
d580 1
a580 1
		to.sin_addr.s_addr = htonl (INADDR_BROADCAST);
d585 2
a586 3
	result = send_packet (packet->interface,
			      packet, &raw, outgoing.packet_length,
			      from, &to, (struct hardware *)0);
d589 3
a591 5
void ack_lease (packet, lease, offer, when)
	struct packet *packet;
	struct lease *lease;
	unsigned int offer;
	time_t when;
d595 1
a595 6
	time_t lease_time;
	time_t offered_lease_time;
	time_t max_lease_time;
	time_t default_lease_time;
	int ulafdr;

d597 1
a597 1
	int i;
d601 1
a601 1
		note ("already acking lease %s", piaddr (lease->ip_addr));
d606 5
a610 9
		vendor_class =
			find_class (0,
				    packet ->
				    options[DHO_DHCP_CLASS_IDENTIFIER].data,
				    packet ->
				    options[DHO_DHCP_CLASS_IDENTIFIER].len);
	} else {
		vendor_class = (struct class *)0;
	}
d613 5
a617 9
		user_class =
			find_class (1,
				    packet ->
				    options[DHO_DHCP_USER_CLASS_ID].data,
				    packet ->
				    options[DHO_DHCP_USER_CLASS_ID].len);
	} else {
		user_class = (struct class *)0;
	}
d626 1
a626 1
			debug ("Booting denied by vendor class");
d631 1
a631 1
			debug ("Booting denied by user class");
d637 1
a637 1
	state = new_lease_state ("ack_lease");
d640 1
a640 1
	memset (state, 0, sizeof *state);
d651 3
a653 5
	    (strlen (lease->client_hostname) ==
	     packet->options[DHO_HOST_NAME].len) &&
	    !memcmp (lease->client_hostname,
		     packet->options[DHO_HOST_NAME].data,
		     packet->options[DHO_HOST_NAME].len)) {
d656 3
a658 3
			free (lease->client_hostname);
		lease->client_hostname =
			malloc (packet->options[DHO_HOST_NAME].len + 1);
d662 3
a664 4
			packet->options[DHO_HOST_NAME].data,
			packet->options[DHO_HOST_NAME].len);
		lease->client_hostname
			[packet->options[DHO_HOST_NAME].len] = 0;
d666 1
a666 1
		free (lease->client_hostname);
d670 4
a673 2
	/* Choose a filename; first from the host_decl, if any, then from
	   the user class, then from the vendor class. */
d676 1
a676 1
			 sizeof state->filename);
d679 1
a679 1
			 sizeof state->filename);
d682 1
a682 1
			 sizeof state->filename);
d685 1
a685 1
			 sizeof state->filename);
d687 2
a688 3
		strlcpy(state->filename,
			 lease->subnet->group->filename,
			 sizeof state->filename);
d700 2
a701 7
		state->server_name =
			lease->subnet->group->server_name;
	else state->server_name = (char *)0;

	/* At this point, we have a lease that we can offer the client.
	   Now we construct a lease structure that contains what we want,
	   and call supersede_lease to do the right thing with it. */
d703 6
a708 1
	memset (&lt, 0, sizeof lt);
d710 4
a713 2
	/* Use the ip address of the lease that we finally found in
	   the database. */
d720 1
a720 2
	if (lease->host &&
	    lease->host->group->max_lease_time)
d726 2
a727 4
	if (lease->host
	    && lease->host->group->default_lease_time)
		default_lease_time =
			lease->host->group->default_lease_time;
d729 1
a729 2
		default_lease_time =
			lease->subnet->group->default_lease_time;
d731 4
a734 2
	/* Figure out how long a lease to assign.    If this is a
	   dynamic BOOTP lease, its duration must be infinite. */
d737 2
a738 2
			lease_time = getULong
				(packet->options[DHO_DHCP_LEASE_TIME].data);
d740 4
a743 2
			/* Don't let the client ask for a longer lease than
			   is supported for this subnet or host. */
d758 1
a758 2
				   lease->host ->
				   group->bootp_lease_length);
d761 1
a761 2
				   lease->subnet ->
				   group->bootp_lease_length);
d763 1
a763 1
			 lease->host->group->bootp_lease_cutoff)
d766 1
a766 2
			lt.ends = (lease->subnet ->
				   group->bootp_lease_cutoff);
d776 1
a776 1
				packet->options[i].len);
d782 1
a782 1
			lt.uid = (unsigned char *)malloc (lt.uid_max);
d785 1
a785 2
			memcpy(lt.uid,
				packet->options[i].data, lt.uid_len);
d800 1
a800 1
			sizeof packet->raw->chaddr); /* XXX */
d806 1
a806 1
			sizeof packet->raw->chaddr);
d813 2
a814 2
		if (!(supersede_lease (lease, &lt, !offer || offer == DHCPACK)
		      || (offer && offer != DHCPACK)))
d824 2
a825 2
	    packet->options[DHO_HOST_NAME].data
	   [packet->options[DHO_HOST_NAME].len - 1] == '\0')
d842 2
a843 3
	memcpy(state->options,
		lease->subnet->group->options,
		sizeof state->options);
d853 1
a853 2
						(vendor_class->group ->
						 options[i]);
d862 1
a862 2
						(user_class->group ->
						 options[i]);
d872 2
a873 2
				state->options[i] = (lease->host ->
							group->options[i]);
d880 2
a881 3
	    (packet->options[i].len == sizeof (u_int16_t)))
		state->max_message_size =
			getUShort (packet->options[i].data);
d884 1
a884 2
		state->max_message_size =
			getUShort (state->options[i]->value);
d889 1
a889 2
		state->prl = dmalloc (packet->options[i].len,
					"ack_lease: prl");
d893 2
a894 3
			memcpy(state->prl,
				packet->options[i].data,
				packet->options[i].len);
d903 1
a903 1
		state->options[i] = new_tree_cache ("hostname");
d905 1
a905 2
		state->options[i]->value =
			(unsigned char *)lease->hostname;
d909 1
a909 1
		state->options[i]->tree = (struct tree *)0;
d912 4
a915 2
	/* Now, if appropriate, put in DHCP-specific options that
           override those. */
d918 1
a918 1
		state->options[i] = new_tree_cache ("message-type");
d924 1
a924 1
		state->options[i]->tree = (struct tree *)0;
d929 1
a929 1
			state->options[i] = new_tree_cache ("server-id");
d931 1
a931 2
				(unsigned char *)&state ->
					ip->primary_address;
d933 3
a935 3
				sizeof state->ip->primary_address;
			state->options[i]->buf_size
				= state->options[i]->len;
d937 4
a940 6
			state->options[i]->tree = (struct tree *)0;
			state->from.len =
				sizeof state->ip->primary_address;
			memcpy(state->from.iabuf,
				&state->ip->primary_address,
				state->from.len);
d946 1
a946 2
			    (state->options[i]->len >
			     sizeof state->from.iabuf))
d950 2
a951 3
			memcpy(state->from.iabuf,
				state->options[i]->value,
				state->from.len);
d961 1
a961 1
				state->offered_expiry - cur_time;
d963 2
a964 2
		putULong ((unsigned char *)&state->expiry,
			  offered_lease_time);
d968 1
a968 2
		state->options[i]->value =
			(unsigned char *)&state->expiry;
d972 1
a972 1
		state->options[i]->tree = (struct tree *)0;
d986 1
a986 1
		state->options[i]->tree = (struct tree *)0;
d990 2
a991 2
		offered_lease_time += (offered_lease_time / 2
				       + offered_lease_time / 4);
d993 1
a993 1
			  offered_lease_time);
d1002 1
a1002 1
		state->options[i]->tree = (struct tree *)0;
d1018 1
a1018 1
			state->options[i]->tree = (struct tree *)0;
d1034 1
a1034 1
			state->options[i]->tree = (struct tree *)0;
d1050 1
a1050 1
		state->options[i]->tree = (struct tree *)0;
d1067 1
a1067 2
	} else if (lease->subnet->group ->
		   use_lease_addr_for_default_route)
d1076 3
a1078 6
		state->options[i]->value =
			lease->ip_addr.iabuf;
		state->options[i]->len =
			lease->ip_addr.len;
		state->options[i]->buf_size =
			lease->ip_addr.len;
d1080 1
a1080 1
		state->options[i]->tree = (struct tree *)0;
d1084 2
a1085 2
	dump_packet (packet);
	dump_raw ((unsigned char *)packet->raw, packet->packet_length);
d1104 2
a1105 2
void dhcp_reply (lease)
	struct lease *lease;
d1107 1
a1107 2
	int bufs = 0;
	int packet_length;
a1111 2
	int result;
	int i;
d1121 1
a1121 1
	memset (&raw, 0, sizeof raw);
d1156 2
a1157 4
		prl = state->options
			[DHO_DHCP_PARAMETER_REQUEST_LIST]->value;
		prl_len = state->options
			[DHO_DHCP_PARAMETER_REQUEST_LIST]->len;
d1162 1
a1162 1
		prl = (u_int8_t *)0;
d1167 2
a1168 4
	packet_length = cons_options ((struct packet *)0, &raw,
				      state->max_message_size,
				      state->options,
				      bufs, nulltp, bootpp, prl, prl_len);
d1175 1
a1175 1
			free_tree_cache (state->options[i], "dhcp_reply");
d1183 1
a1183 2
		memcpy(&raw.siaddr,
			lease->host->group->next_server.iabuf, 4);
d1185 1
a1185 2
		memcpy(&raw.siaddr,
			lease->subnet->group->next_server.iabuf, 4);
d1187 1
a1187 2
		memcpy(&raw.siaddr,
			lease->subnet->interface_address.iabuf, 4);
d1200 7
a1206 11
	note ("%s on %s to %s via %s",
	      (state->offer
	       ? (state->offer == DHCPACK ? "DHCPACK" : "DHCPOFFER")
	       : "BOOTREPLY"),
	      piaddr (lease->ip_addr),
	      print_hw_addr (lease->hardware_addr.htype,
			     lease->hardware_addr.hlen,
			     lease->hardware_addr.haddr),
	      state->giaddr.s_addr
	      ? inet_ntoa (state->giaddr)
	      : state->ip->name);
d1213 1
a1213 1
	memset (&to, 0, sizeof to);
d1220 1
a1220 1
	dump_raw ((unsigned char *)&raw, packet_length);
d1234 2
a1235 5
			result = send_packet (fallback_interface,
					      (struct packet *)0,
					      &raw, packet_length,
					      raw.siaddr,
					      &to, (struct hardware *)0);
d1237 2
a1238 2
			free_lease_state (state, "dhcp_reply fallback 1");
			lease->state = (struct lease_state *)0;
d1254 5
a1258 5
		   !((state->got_server_identifier ||
		      (raw.flags & htons (BOOTP_BROADCAST))) &&
		     /* XXX This won't work if giaddr isn't zero, but it is: */
		     (state->shared_network == lease->shared_network)) &&
		   state->offer == DHCPACK) {
d1263 4
a1266 8
			result = send_packet (fallback_interface,
					      (struct packet *)0,
					      &raw, packet_length,
					      raw.siaddr, &to,
					      (struct hardware *)0);
			free_lease_state (state,
					  "dhcp_reply fallback 2");
			lease->state = (struct lease_state *)0;
d1280 1
a1280 1
		to.sin_addr.s_addr = htonl (INADDR_BROADCAST);
d1286 2
a1287 3
	result = send_packet (state->ip,
			      (struct packet *)0, &raw, packet_length,
			      from, &to, &hto);
d1289 2
a1290 2
	free_lease_state (state, "dhcp_reply");
	lease->state = (struct lease_state *)0;
d1293 3
a1295 4
struct lease *find_lease (packet, share, ours)
	struct packet *packet;
	struct shared_network *share;
	int *ours;
d1300 1
a1300 1
	struct host_decl *hp, *host = (struct host_decl *)0;
d1309 2
a1310 2
			packet->options[DHO_DHCP_REQUESTED_ADDRESS].data,
			cip.len);
d1322 3
a1324 4
		hp = find_hosts_by_uid (packet->options
					[DHO_DHCP_CLIENT_IDENTIFIER].data,
					packet->options
					[DHO_DHCP_CLIENT_IDENTIFIER].len);
d1327 1
a1327 1
			fixed_lease = mockup_lease (packet, share, hp);
d1330 3
a1332 5
			uid_lease = find_lease_by_uid
				(packet->options
				[DHO_DHCP_CLIENT_IDENTIFIER].data,
				 packet->options
				[DHO_DHCP_CLIENT_IDENTIFIER].len);
d1339 1
a1339 2
			if (uid_lease &&
			    (uid_lease->flags & ABANDONED_LEASE))
d1350 2
a1351 3
		hp = find_hosts_by_haddr (packet->raw->htype,
					  packet->raw->chaddr,
					  packet->raw->hlen);
d1363 1
a1363 2
	     memcmp (fixed_lease->ip_addr.iabuf,
		     cip.iabuf, cip.len))) {
d1367 1
a1367 1
			sizeof (dhcp_message));
d1392 1
a1392 1
		ip_lease = find_lease_by_ip_addr (cip);
d1412 1
a1412 1
			 sizeof(dhcp_message));
d1417 1
a1417 3
	if (ip_lease &&
	    ip_lease->ends >= cur_time &&
	    ip_lease != uid_lease) {
d1419 1
d1422 4
a1425 5
		if ((ip_lease->uid_len &&
		     packet->options[i].data &&
		     ip_lease->uid_len ==  packet->options[i].len &&
		     !memcmp (packet->options[i].data,
			      ip_lease->uid, ip_lease->uid_len)) ||
d1427 4
a1430 6
		     (ip_lease->hardware_addr.htype ==
		      packet->raw->htype) &&
		     ip_lease->hardware_addr.hlen == packet->raw->hlen &&
		     !memcmp (ip_lease->hardware_addr.haddr,
			      packet->raw->chaddr,
			      ip_lease->hardware_addr.hlen))) {
d1432 10
a1441 12
			    if (uid_lease->ends > cur_time) {
				warn("client %s has duplicate leases on %s",
				      print_hw_addr (packet->raw->htype,
						     packet->raw->hlen,
						     packet->raw->chaddr),
				      ip_lease->shared_network->name);

				if (uid_lease &&
				    !packet->raw->ciaddr.s_addr)
					release_lease (uid_lease);
			    }
			    uid_lease = ip_lease;
d1444 2
a1445 3
			strlcpy(dhcp_message,
				"requested address is not available",
				 sizeof(dhcp_message));
d1454 1
a1454 1
		      db_conflict:
d1456 1
a1456 1
			      piaddr (cip));
d1458 3
a1460 5
			      (fixed_lease && fixed_lease->host
			       ? (fixed_lease->host->name
				  ? fixed_lease->host->name : piaddr (cip))
			       : piaddr (cip)),
			      piaddr (cip));
d1462 1
a1462 1
			      share->name);
d1465 2
a1466 3
			strlcpy(dhcp_message,
				"database conflict - call for help!",
				 sizeof(dhcp_message));
d1479 1
a1479 3
	if (hw_lease &&
	    hw_lease->ends >= cur_time &&
	    hw_lease->uid &&
d1501 1
a1501 2
	if (ip_lease &&
	    (share != ip_lease->shared_network)) {
d1506 1
a1506 2
	if (uid_lease &&
	    (share != uid_lease->shared_network)) {
d1508 1
a1508 1
			release_lease (uid_lease);
d1511 1
a1511 2
	if (hw_lease &&
	    (share != hw_lease->shared_network)) {
d1513 1
a1513 1
			release_lease (hw_lease);
d1525 1
a1525 1
	if (fixed_lease) {
a1526 1
	}
d1533 1
a1533 1
				release_lease (ip_lease);
d1536 1
a1536 1
			lease->host = (struct host_decl *)0;
d1546 1
a1546 1
				release_lease (uid_lease);
d1549 1
a1549 1
			lease->host = (struct host_decl *)0;
d1557 1
a1557 1
				release_lease (hw_lease);
d1560 1
a1560 1
			lease->host = (struct host_decl *)0;
d1583 1
a1583 1
			    piaddr (lease->ip_addr));
d1611 1
a1611 1
		mock.uid_len = hp->group ->options[DHO_DHCP_CLIENT_IDENTIFIER]->len;
@


1.3
log
@spaces
@
text
@d47 1
a47 1
static char dhcp_message [256];
d49 2
a50 2
void dhcp (packet)
	struct packet *packet;
d52 1
a52 1
	if (!locate_network (packet) && packet -> packet_type != DHCPREQUEST)
d55 3
a57 3
	switch (packet -> packet_type) {
	      case DHCPDISCOVER:
		dhcpdiscover (packet);
d60 2
a61 2
	      case DHCPREQUEST:
		dhcprequest (packet);
d64 2
a65 2
	      case DHCPRELEASE:
		dhcprelease (packet);
d68 2
a69 2
	      case DHCPDECLINE:
		dhcpdecline (packet);
d72 2
a73 2
	      case DHCPINFORM:
		dhcpinform (packet);
d76 1
a76 1
	      default:
d81 1
a81 1
void dhcpdiscover (packet)
d84 1
a84 1
	struct lease *lease = find_lease (packet, packet -> shared_network, 0);
d87 7
a93 7
	note ("DHCPDISCOVER from %s via %s",
	      print_hw_addr (packet -> raw -> htype,
			     packet -> raw -> hlen,
			     packet -> raw -> chaddr),
	      packet -> raw -> giaddr.s_addr
	      ? inet_ntoa (packet -> raw -> giaddr)
	      : packet -> interface -> name);
d96 3
a98 3
	if (!packet -> shared_network) {
		note ("Packet from unknown subnet: %s",
		      inet_ntoa (packet -> raw -> giaddr));
d104 1
a104 1
		lease = packet -> shared_network -> last_lease;
d108 3
a110 3
		if (!lease || lease -> ends > cur_time) {
			note ("no free leases on subnet %s",
			      packet -> shared_network -> name);
d117 1
a117 1
		if ((lease -> flags & ABANDONED_LEASE)) {
d121 2
a122 2
			for (lp = lease; lp; lp = lp -> prev) {
				if (lp -> ends > cur_time)
d124 1
a124 1
				if (!(lp -> flags & ABANDONED_LEASE)) {
d132 4
a135 4
			if ((lease -> flags & ABANDONED_LEASE)) {
				warn ("Reclaiming abandoned IP address %s.",
				      piaddr (lease -> ip_addr));
				lease -> flags &= ~ABANDONED_LEASE;
d144 1
a144 1
		if (((packet -> options [DHO_DHCP_CLIENT_IDENTIFIER].len
d147 2
a148 2
		       (packet -> options [DHO_DHCP_CLIENT_IDENTIFIER].data,
			packet -> options [DHO_DHCP_CLIENT_IDENTIFIER].len))
d150 3
a152 3
		    ((hp = find_hosts_by_haddr (packet -> raw -> htype,
						packet -> raw -> chaddr,
						packet -> raw -> hlen))
d154 3
a156 3
			for (; hp; hp = hp -> n_ipaddr) {
				if (!hp -> fixed_addr) {
					lease -> host = hp;
d161 1
a161 1
			lease -> host = (struct host_decl *)0;
d167 14
a180 14
	if (!lease -> host &&
	    !lease -> subnet -> group -> boot_unknown_clients) {
		note ("Ignoring unknown client %s",
		      print_hw_addr (packet -> raw -> htype,
				     packet -> raw -> hlen,
				     packet -> raw -> chaddr));
	} else if (lease -> host &&
		    !lease -> host -> group -> allow_booting) {
		note ("Declining to boot client %s",
		      lease -> host -> name
		      ? lease -> host -> name
		      : print_hw_addr (packet -> raw -> htype,
				       packet -> raw -> hlen,
				       packet -> raw -> chaddr));
d182 1
a182 1
		ack_lease (packet, lease, DHCPOFFER, cur_time + 120);
d185 1
a185 1
void dhcprequest (packet)
d193 1
a193 1
	if (packet -> options [DHO_DHCP_REQUESTED_ADDRESS].len) {
d195 2
a196 2
		memcpy (cip.iabuf,
			packet -> options [DHO_DHCP_REQUESTED_ADDRESS].data,
d200 1
a200 1
		memcpy (cip.iabuf, &packet -> raw -> ciaddr.s_addr, 4);
d202 1
a202 1
	subnet = find_subnet (cip);
d208 1
a208 1
		lease = find_lease (packet, subnet -> shared_network, &ours);
d210 1
a210 1
		lease = (struct lease *)0;
d212 8
a219 8
	note ("DHCPREQUEST for %s from %s via %s",
	      piaddr (cip),
	      print_hw_addr (packet -> raw -> htype,
			     packet -> raw -> hlen,
			     packet -> raw -> chaddr),
	      packet -> raw -> giaddr.s_addr
	      ? inet_ntoa (packet -> raw -> giaddr)
	      : packet -> interface -> name);
d263 5
a267 5
	if (!packet -> shared_network ||
	    (packet -> raw -> ciaddr.s_addr &&
	     packet -> raw -> giaddr.s_addr) ||
	    (packet -> options [DHO_DHCP_REQUESTED_ADDRESS].len &&
	     !packet -> raw -> ciaddr.s_addr)) {
d272 1
a272 1
		if (!packet -> shared_network) {
d274 1
a274 1
			    subnet -> shared_network -> group -> authoritative)
d276 1
a276 1
				nak_lease (packet, &cip);
d285 1
a285 1
		subnet = find_grouped_subnet (packet -> shared_network, cip);
d287 2
a288 2
			if (packet -> shared_network -> group -> authoritative)
				nak_lease (packet, &cip);
d296 1
a296 1
	if (lease && !addr_eq (lease -> ip_addr, cip)) {
d301 1
a301 1
			nak_lease (packet, &cip);
d308 1
a308 1
		nak_lease (packet, &cip);
d314 6
a319 6
	    !lease -> host &&
	    !lease -> subnet -> group -> boot_unknown_clients) {
		note ("Ignoring unknown client %s",
		      print_hw_addr (packet -> raw -> htype,
				     packet -> raw -> hlen,
				     packet -> raw -> chaddr));
d321 8
a328 8
	} else if (lease && lease -> host &&
		   !lease -> host -> group -> allow_booting) {
		note ("Declining to renew client %s",
		      lease -> host -> name
		      ? lease -> host -> name
		      : print_hw_addr (packet -> raw -> htype,
				       packet -> raw -> hlen,
				       packet -> raw -> chaddr));
d335 11
a345 11
	    ((lease -> uid_len && lease -> uid_len ==
	      packet -> options [DHO_DHCP_CLIENT_IDENTIFIER].len &&
	      !memcmp (packet -> options
		       [DHO_DHCP_CLIENT_IDENTIFIER].data,
		       lease -> uid, lease -> uid_len)) ||
	     (lease -> hardware_addr.hlen == packet -> raw -> hlen &&
	      lease -> hardware_addr.htype == packet -> raw -> htype &&
	      !memcmp (lease -> hardware_addr.haddr,
		       packet -> raw -> chaddr,
		       packet -> raw -> hlen)))) {
		ack_lease (packet, lease, DHCPACK, 0);
d357 1
a357 1
		ack_lease (packet, lease, DHCPACK, 0);
d360 1
a360 1
void dhcprelease (packet)
d370 5
a374 5
	if (packet -> options [DHO_DHCP_REQUESTED_ADDRESS].len) {
		note ("DHCPRELEASE from %s specified requested-address.",
		      print_hw_addr (packet -> raw -> htype,
				     packet -> raw -> hlen,
				     packet -> raw -> chaddr));
d378 3
a380 3
	if (packet -> options [i].len) {
		lease = find_lease_by_uid (packet -> options [i].data,
					   packet -> options [i].len);
d384 3
a386 3
		for (; lease; lease = lease -> n_uid) {
			if (!memcmp (&packet -> raw -> ciaddr,
				     lease -> ip_addr.iabuf, 4)) {
d395 2
a396 2
		memcpy (cip.iabuf, &packet -> raw -> ciaddr, 4);
		lease = find_lease_by_ip_addr (cip);
d399 8
a406 8
	note ("DHCPRELEASE of %s from %s via %s (%sfound)",
	      inet_ntoa (packet -> raw -> ciaddr),
	      print_hw_addr (packet -> raw -> htype,
			     packet -> raw -> hlen,
			     packet -> raw -> chaddr),
	      packet -> raw -> giaddr.s_addr
	      ? inet_ntoa (packet -> raw -> giaddr)
	      : packet -> interface -> name,
d410 1
a410 1
	if (lease && lease -> ends > cur_time) {
d417 9
a425 9
		if (! lease->releasing) {
			note ("DHCPRELEASE of %s from %s via %s (found)",
			      inet_ntoa (packet -> raw -> ciaddr),
			      print_hw_addr (packet -> raw -> htype,
					     packet -> raw -> hlen,
					     packet -> raw -> chaddr),
			      packet -> raw -> giaddr.s_addr
			      ? inet_ntoa (packet -> raw -> giaddr)
			      : packet -> interface -> name);
d428 2
a429 2
			add_timeout (cur_time + 1, lease_ping_timeout, lease);
			icmp_echorequest (&(lease -> ip_addr));
d433 8
a440 8
			note ("DHCPRELEASE of %s from %s via %s ignored (release already pending)",
			      inet_ntoa (packet -> raw -> ciaddr),
			      print_hw_addr (packet -> raw -> htype,
					     packet -> raw -> hlen,
					     packet -> raw -> chaddr),
			      packet -> raw -> giaddr.s_addr
			      ? inet_ntoa (packet -> raw -> giaddr)
			      : packet -> interface -> name);
d444 8
a451 8
		note ("DHCPRELEASE of %s from %s via %s for nonexistent lease",
		      inet_ntoa (packet -> raw -> ciaddr),
		      print_hw_addr (packet -> raw -> htype,
				     packet -> raw -> hlen,
				     packet -> raw -> chaddr),
		      packet -> raw -> giaddr.s_addr
		      ? inet_ntoa (packet -> raw -> giaddr)
		      : packet -> interface -> name);
d455 1
a455 1
void dhcpdecline (packet)
d462 1
a462 1
	if (!packet -> options [DHO_DHCP_REQUESTED_ADDRESS].len) {
d467 12
a478 12
	memcpy (cip.iabuf,
		packet -> options [DHO_DHCP_REQUESTED_ADDRESS].data, 4);
	lease = find_lease_by_ip_addr (cip);

	note ("DHCPDECLINE on %s from %s via %s",
	      piaddr (cip),
	      print_hw_addr (packet -> raw -> htype,
			     packet -> raw -> hlen,
			     packet -> raw -> chaddr),
	      packet -> raw -> giaddr.s_addr
	      ? inet_ntoa (packet -> raw -> giaddr)
	      : packet -> interface -> name);
d482 1
a482 1
		abandon_lease (lease, "declined.");
d486 1
a486 1
void dhcpinform (packet)
d489 2
a490 2
	note ("DHCPINFORM from %s",
	      inet_ntoa (packet -> raw -> ciaddr));
d493 1
a493 1
void nak_lease (packet, cip)
d506 1
a506 1
	struct tree_cache *options [256];
d510 3
a512 3
	memset (options, 0, sizeof options);
	memset (&outgoing, 0, sizeof outgoing);
	memset (&raw, 0, sizeof raw);
d516 6
a521 6
	options [DHO_DHCP_MESSAGE_TYPE] = &dhcpnak_tree;
	options [DHO_DHCP_MESSAGE_TYPE] -> value = &nak;
	options [DHO_DHCP_MESSAGE_TYPE] -> len = sizeof nak;
	options [DHO_DHCP_MESSAGE_TYPE] -> buf_size = sizeof nak;
	options [DHO_DHCP_MESSAGE_TYPE] -> timeout = 0xFFFFFFFF;
	options [DHO_DHCP_MESSAGE_TYPE] -> tree = (struct tree *)0;
d524 6
a529 6
	options [DHO_DHCP_MESSAGE] = &dhcpmsg_tree;
	options [DHO_DHCP_MESSAGE] -> value = (unsigned char *)dhcp_message;
	options [DHO_DHCP_MESSAGE] -> len =
		options [DHO_DHCP_MESSAGE] -> buf_size = strlen (dhcp_message);
	options [DHO_DHCP_MESSAGE] -> timeout = 0xFFFFFFFF;
	options [DHO_DHCP_MESSAGE] -> tree = (struct tree *)0;
d533 4
a536 4
	if (packet -> options [i].data) {
		packet -> options [i].len = 0;
		dfree (packet -> options [i].data, "nak_lease");
		packet -> options [i].data = (unsigned char *)0;
d541 1
a541 1
		cons_options (packet, outgoing.raw, 0, options, 0, 0, 0,
d544 11
a554 11
/*	memset (&raw.ciaddr, 0, sizeof raw.ciaddr);*/
	raw.siaddr = packet -> interface -> primary_address;
	raw.giaddr = packet -> raw -> giaddr;
	memcpy (raw.chaddr, packet -> raw -> chaddr, sizeof raw.chaddr);
	raw.hlen = packet -> raw -> hlen;
	raw.htype = packet -> raw -> htype;

	raw.xid = packet -> raw -> xid;
	raw.secs = packet -> raw -> secs;
	raw.flags = packet -> raw -> flags | htons (BOOTP_BROADCAST);
	raw.hops = packet -> raw -> hops;
d558 4
a561 10
	note ("DHCPNAK on %s to %s via %s",
	      piaddr (*cip),
	      print_hw_addr (packet -> raw -> htype,
			     packet -> raw -> hlen,
			     packet -> raw -> chaddr),
	      packet -> raw -> giaddr.s_addr
	      ? inet_ntoa (packet -> raw -> giaddr)
	      : packet -> interface -> name);


d565 1
a565 1
	dump_raw ((unsigned char *)packet -> raw, packet -> packet_length);
d570 3
a572 3
	hto.htype = packet -> raw -> htype;
	hto.hlen = packet -> raw -> hlen;
	memcpy (hto.haddr, packet -> raw -> chaddr, hto.hlen);
d579 1
a579 1
	from = packet -> interface -> primary_address;
d597 1
a597 1
				warn ("send_fallback: %m");
d606 1
a606 1
	result = send_packet (packet -> interface,
d629 2
a630 2
	if (lease -> state) {
		note ("already acking lease %s", piaddr (lease -> ip_addr));
d634 1
a634 1
	if (packet -> options [DHO_DHCP_CLASS_IDENTIFIER].len) {
d638 1
a638 1
				    options [DHO_DHCP_CLASS_IDENTIFIER].data,
d640 1
a640 1
				    options [DHO_DHCP_CLASS_IDENTIFIER].len);
d645 1
a645 1
	if (packet -> options [DHO_DHCP_USER_CLASS_ID].len) {
d649 1
a649 1
				    options [DHO_DHCP_USER_CLASS_ID].data,
d651 1
a651 1
				    options [DHO_DHCP_USER_CLASS_ID].len);
d661 2
a662 2
	if (!lease -> host) {
		if (vendor_class && !vendor_class -> group -> allow_booting) {
d667 1
a667 1
		if (user_class && !user_class -> group -> allow_booting) {
d676 1
a676 1
		error ("unable to allocate lease state!");
d678 2
a679 2
	state -> got_requested_address = packet -> got_requested_address;
	state -> shared_network = packet -> interface -> shared_network;
d682 2
a683 2
	if (packet -> options [DHO_DHCP_SERVER_IDENTIFIER].len)
		state -> got_server_identifier = 1;
d686 22
a707 22
	if (packet -> options [DHO_HOST_NAME].len &&
	    lease -> client_hostname &&
	    (strlen (lease -> client_hostname) ==
	     packet -> options [DHO_HOST_NAME].len) &&
	    !memcmp (lease -> client_hostname,
		     packet -> options [DHO_HOST_NAME].data,
		     packet -> options [DHO_HOST_NAME].len)) {
	} else if (packet -> options [DHO_HOST_NAME].len) {
		if (lease -> client_hostname)
			free (lease -> client_hostname);
		lease -> client_hostname =
			malloc (packet -> options [DHO_HOST_NAME].len + 1);
		if (!lease -> client_hostname)
			error ("no memory for client hostname.\n");
		memcpy (lease -> client_hostname,
			packet -> options [DHO_HOST_NAME].data,
			packet -> options [DHO_HOST_NAME].len);
		lease -> client_hostname
			[packet -> options [DHO_HOST_NAME].len] = 0;
	} else if (lease -> client_hostname) {
		free (lease -> client_hostname);
		lease -> client_hostname = 0;
d712 16
a727 16
	if (lease -> host && lease -> host -> group -> filename)
		strlcpy (state -> filename, lease -> host -> group -> filename,
			 sizeof state -> filename);
	else if (user_class && user_class -> group -> filename)
		strlcpy (state -> filename, user_class -> group -> filename,
			 sizeof state -> filename);
	else if (vendor_class  && vendor_class -> group -> filename)
		strlcpy (state -> filename, vendor_class -> group -> filename,
			 sizeof state -> filename);
	else if (packet -> raw -> file [0])
		strlcpy (state -> filename, packet -> raw -> file,
			 sizeof state -> filename);
	else if (lease -> subnet -> group -> filename)
		strlcpy (state -> filename,
			 lease -> subnet -> group -> filename,
			 sizeof state -> filename);
d729 1
a729 1
		strlcpy (state -> filename, "", sizeof state -> filename);
d732 10
a741 10
	if (lease -> host && lease -> host -> group -> server_name)
		state -> server_name = lease -> host -> group -> server_name;
	else if (user_class && user_class -> group -> server_name)
		state -> server_name = user_class -> group -> server_name;
	else if (vendor_class  && vendor_class -> group -> server_name)
		state -> server_name = vendor_class -> group -> server_name;
	else if (lease -> subnet -> group -> server_name)
		state -> server_name =
			lease -> subnet -> group -> server_name;
	else state -> server_name = (char *)0;
d751 1
a751 1
	lt.ip_addr = lease -> ip_addr;
d757 3
a759 3
	if (lease -> host &&
	    lease -> host -> group -> max_lease_time)
		max_lease_time = lease -> host -> group -> max_lease_time;
d761 1
a761 1
		max_lease_time = lease -> subnet -> group -> max_lease_time;
d764 2
a765 2
	if (lease -> host
	    && lease -> host -> group -> default_lease_time)
d767 1
a767 1
			lease -> host -> group -> default_lease_time;
d770 1
a770 1
			lease -> subnet -> group -> default_lease_time;
d775 1
a775 1
		if (packet -> options [DHO_DHCP_LEASE_TIME].len == 4) {
d777 1
a777 1
				(packet -> options [DHO_DHCP_LEASE_TIME].data);
d786 1
a786 1
		state -> offered_expiry = cur_time + lease_time;
d790 1
a790 1
			lt.ends = state -> offered_expiry;
d792 2
a793 2
		if (lease -> host &&
		    lease -> host -> group -> bootp_lease_length)
d795 3
a797 3
				   lease -> host ->
				   group -> bootp_lease_length);
		else if (lease -> subnet -> group -> bootp_lease_length)
d799 5
a803 5
				   lease -> subnet ->
				   group -> bootp_lease_length);
		else if (lease -> host &&
			 lease -> host -> group -> bootp_lease_cutoff)
			lt.ends = lease -> host -> group -> bootp_lease_cutoff;
d805 3
a807 3
			lt.ends = (lease -> subnet ->
				   group -> bootp_lease_cutoff);
		state -> offered_expiry = lt.ends;
d813 4
a816 4
	if (packet -> options [i].len) {
		if (packet -> options [i].len <= sizeof lt.uid_buf) {
			memcpy (lt.uid_buf, packet -> options [i].data,
				packet -> options [i].len);
d819 1
a819 1
			lt.uid_len = packet -> options [i].len;
d821 1
a821 1
			lt.uid_max = lt.uid_len = packet -> options [i].len;
d824 3
a826 3
				error ("can't allocate memory for large uid.");
			memcpy (lt.uid,
				packet -> options [i].data, lt.uid_len);
d830 3
a832 3
	lt.host = lease -> host;
	lt.subnet = lease -> subnet;
	lt.shared_network = lease -> shared_network;
d835 1
a835 1
	if (lease -> flags & STATIC_LEASE) {
d838 4
a841 4
		lease -> hardware_addr.hlen = packet -> raw -> hlen;
		lease -> hardware_addr.htype = packet -> raw -> htype;
		memcpy (lease -> hardware_addr.haddr, packet -> raw -> chaddr,
			sizeof packet -> raw -> chaddr); /* XXX */
d844 4
a847 4
		lt.hardware_addr.hlen = packet -> raw -> hlen;
		lt.hardware_addr.htype = packet -> raw -> htype;
		memcpy (lt.hardware_addr.haddr, packet -> raw -> chaddr,
			sizeof packet -> raw -> chaddr);
d860 1
a860 1
	state -> ip = packet -> interface;
d864 4
a867 4
	if (packet -> options [DHO_HOST_NAME].data &&
	    packet -> options [DHO_HOST_NAME].data
	    [packet -> options [DHO_HOST_NAME].len - 1] == '\0')
		lease -> flags |= MS_NULL_TERMINATION;
d869 1
a869 1
		lease -> flags &= ~MS_NULL_TERMINATION;
d872 7
a878 7
	state -> giaddr = packet -> raw -> giaddr;
	state -> ciaddr = packet -> raw -> ciaddr;
	state -> xid = packet -> raw -> xid;
	state -> secs = packet -> raw -> secs;
	state -> bootp_flags = packet -> raw -> flags;
	state -> hops = packet -> raw -> hops;
	state -> offer = offer;
d883 3
a885 3
	memcpy (state -> options,
		lease -> subnet -> group -> options,
		sizeof state -> options);
d888 1
a888 1
	if (state -> offer) {
d893 4
a896 4
				if (vendor_class -> group -> options [i])
					state -> options [i] =
						(vendor_class -> group ->
						 options [i]);
d903 4
a906 4
				if (user_class -> group -> options [i])
					state -> options [i] =
						(user_class -> group ->
						 options [i]);
d913 1
a913 1
	if (lease -> host) {
d915 3
a917 3
			if (lease -> host -> group -> options [i])
				state -> options [i] = (lease -> host ->
							group -> options [i]);
d923 4
a926 4
	if (packet -> options [i].data &&
	    (packet -> options [i].len == sizeof (u_int16_t)))
		state -> max_message_size =
			getUShort (packet -> options [i].data);
d928 3
a930 3
	else if (state -> options [i] && state -> options [i] -> value)
		state -> max_message_size =
			getUShort (state -> options [i] -> value);
d934 2
a935 2
	if (packet -> options [i].data) {
		state -> prl = dmalloc (packet -> options [i].len,
d937 2
a938 2
		if (!state -> prl)
			warn ("no memory for parameter request list");
d940 4
a943 4
			memcpy (state -> prl,
				packet -> options [i].data,
				packet -> options [i].len);
			state -> prl_len = packet -> options [i].len;
d950 9
a958 9
	if (!state -> options [i] && lease -> hostname) {
		state -> options [i] = new_tree_cache ("hostname");
		state -> options [i] -> flags = TC_TEMPORARY;
		state -> options [i] -> value =
			(unsigned char *)lease -> hostname;
		state -> options [i] -> len = strlen (lease -> hostname);
		state -> options [i] -> buf_size = state -> options [i] -> len;
		state -> options [i] -> timeout = 0xFFFFFFFF;
		state -> options [i] -> tree = (struct tree *)0;
d963 1
a963 1
	if (state -> offer) {
d965 7
a971 7
		state -> options [i] = new_tree_cache ("message-type");
		state -> options [i] -> flags = TC_TEMPORARY;
		state -> options [i] -> value = &state -> offer;
		state -> options [i] -> len = sizeof state -> offer;
		state -> options [i] -> buf_size = sizeof state -> offer;
		state -> options [i] -> timeout = 0xFFFFFFFF;
		state -> options [i] -> tree = (struct tree *)0;
d974 1
a974 1
		if (!state -> options [i]) {
d976 2
a977 2
			state -> options [i] = new_tree_cache ("server-id");
			state -> options [i] -> value =
d979 12
a990 12
					ip -> primary_address;
			state -> options [i] -> len =
				sizeof state -> ip -> primary_address;
			state -> options [i] -> buf_size
				= state -> options [i] -> len;
			state -> options [i] -> timeout = 0xFFFFFFFF;
			state -> options [i] -> tree = (struct tree *)0;
			state -> from.len =
				sizeof state -> ip -> primary_address;
			memcpy (state -> from.iabuf,
				&state -> ip -> primary_address,
				state -> from.len);
d993 1
a993 1
			if (!tree_evaluate (state -> options [i]))
d995 3
a997 3
			if (!state -> options [i] -> value ||
			    (state -> options [i] -> len >
			     sizeof state -> from.iabuf))
d1000 4
a1003 4
			state -> from.len = state -> options [i] -> len;
			memcpy (state -> from.iabuf,
				state -> options [i] -> value,
				state -> from.len);
d1007 1
a1007 1
		if ((state -> offered_expiry - cur_time) < 15)
d1009 1
a1009 1
		else if (state -> offered_expiry - cur_time > max_lease_time)
d1013 1
a1013 1
				state -> offered_expiry - cur_time;
d1015 1
a1015 1
		putULong ((unsigned char *)&state -> expiry,
d1018 8
a1025 8
		state -> options [i] = new_tree_cache ("lease-expiry");
		state -> options [i] -> flags = TC_TEMPORARY;
		state -> options [i] -> value =
			(unsigned char *)&state -> expiry;
		state -> options [i] -> len = sizeof state -> expiry;
		state -> options [i] -> buf_size = sizeof state -> expiry;
		state -> options [i] -> timeout = 0xFFFFFFFF;
		state -> options [i] -> tree = (struct tree *)0;
d1029 1
a1029 1
		putULong ((unsigned char *)&state -> renewal,
d1032 8
a1039 8
		state -> options [i] = new_tree_cache ("renewal-time");
		state -> options [i] -> flags = TC_TEMPORARY;
		state -> options [i] -> value =
			(unsigned char *)&state -> renewal;
		state -> options [i] -> len = sizeof state -> renewal;
		state -> options [i] -> buf_size = sizeof state -> renewal;
		state -> options [i] -> timeout = 0xFFFFFFFF;
		state -> options [i] -> tree = (struct tree *)0;
d1045 1
a1045 1
		putULong ((unsigned char *)&state -> rebind,
d1048 8
a1055 8
		state -> options [i] = new_tree_cache ("rebind-time");
		state -> options [i] -> flags = TC_TEMPORARY;
		state -> options [i] -> value =
			(unsigned char *)&state -> rebind;
		state -> options [i] -> len = sizeof state -> rebind;
		state -> options [i] -> buf_size = sizeof state -> rebind;
		state -> options [i] -> timeout = 0xFFFFFFFF;
		state -> options [i] -> tree = (struct tree *)0;
d1061 1
a1061 1
			state -> options [i] =
d1063 9
a1071 9
			state -> options [i] -> flags = TC_TEMPORARY;
			state -> options [i] -> value =
				(unsigned char *)vendor_class -> name;
			state -> options [i] -> len =
				strlen (vendor_class -> name);
			state -> options [i] -> buf_size =
				state -> options [i] -> len;
			state -> options [i] -> timeout = 0xFFFFFFFF;
			state -> options [i] -> tree = (struct tree *)0;
d1078 10
a1087 10
			state -> options [i] = new_tree_cache ("user-class");
			state -> options [i] -> flags = TC_TEMPORARY;
			state -> options [i] -> value =
				(unsigned char *)user_class -> name;
			state -> options [i] -> len =
				strlen (user_class -> name);
			state -> options [i] -> buf_size =
				state -> options [i] -> len;
			state -> options [i] -> timeout = 0xFFFFFFFF;
			state -> options [i] -> tree = (struct tree *)0;
d1094 10
a1103 10
	if (!state -> options [i]) {
		state -> options [i] = new_tree_cache ("subnet-mask");
		state -> options [i] -> flags = TC_TEMPORARY;
		state -> options [i] -> value =
			lease -> subnet -> netmask.iabuf;
		state -> options [i] -> len = lease -> subnet -> netmask.len;
		state -> options [i] -> buf_size =
			lease -> subnet -> netmask.len;
		state -> options [i] -> timeout = 0xFFFFFFFF;
		state -> options [i] -> tree = (struct tree *)0;
d1111 2
a1112 2
	if (lease -> host) {
		if (lease -> host -> group -> use_lease_addr_for_default_route)
d1115 1
a1115 1
		if (user_class -> group -> use_lease_addr_for_default_route)
d1118 1
a1118 1
		if (vendor_class -> group -> use_lease_addr_for_default_route)
d1120 1
a1120 1
	} else if (lease -> subnet -> group ->
d1127 11
a1137 11
	if (ulafdr && !state -> options [i]) {
		state -> options [i] = new_tree_cache ("routers");
		state -> options [i] -> flags = TC_TEMPORARY;
		state -> options [i] -> value =
			lease -> ip_addr.iabuf;
		state -> options [i] -> len =
			lease -> ip_addr.len;
		state -> options [i] -> buf_size =
			lease -> ip_addr.len;
		state -> options [i] -> timeout = 0xFFFFFFFF;
		state -> options [i] -> tree = (struct tree *)0;
d1142 1
a1142 1
	dump_raw ((unsigned char *)packet -> raw, packet -> packet_length);
d1145 1
a1145 1
	lease -> state = state;
d1149 4
a1152 4
	if (offer == DHCPOFFER && !(lease -> flags & STATIC_LEASE) &&
	    cur_time - lease -> timestamp > 60) {
		lease -> timestamp = cur_time;
		icmp_echorequest (&lease -> ip_addr);
d1156 1
a1156 1
		lease -> timestamp = cur_time;
d1172 1
a1172 1
	struct lease_state *state = lease -> state;
d1178 1
a1178 1
		error ("dhcp_reply was supplied lease with no state!");
d1185 2
a1186 2
	if (state -> filename [0])
		strlcpy (raw.file, state -> filename, sizeof raw.file);
d1192 2
a1193 2
	if (state -> server_name)
		strlcpy (raw.sname, state -> server_name, sizeof raw.sname);
d1197 3
a1199 3
	memcpy (raw.chaddr, lease -> hardware_addr.haddr, sizeof raw.chaddr);
	raw.hlen = lease -> hardware_addr.hlen;
	raw.htype = lease -> hardware_addr.htype;
d1203 1
a1203 1
	if (lease -> flags & MS_NULL_TERMINATION)
d1209 1
a1209 1
	if (state -> offer)
d1214 9
a1222 9
	if (state -> options [DHO_DHCP_PARAMETER_REQUEST_LIST] &&
	    state -> options [DHO_DHCP_PARAMETER_REQUEST_LIST] -> value) {
		prl = state -> options
			[DHO_DHCP_PARAMETER_REQUEST_LIST] -> value;
		prl_len = state -> options
			[DHO_DHCP_PARAMETER_REQUEST_LIST] -> len;
	} else if (state -> prl) {
		prl = state -> prl;
		prl_len = state -> prl_len;
d1230 2
a1231 2
				      state -> max_message_size,
				      state -> options,
d1237 3
a1239 3
		if (state -> options [i] &&
		    state -> options [i] -> flags & TC_TEMPORARY)
			free_tree_cache (state -> options [i], "dhcp_reply");
d1242 2
a1243 2
	memcpy (&raw.ciaddr, &state -> ciaddr, sizeof raw.ciaddr);
	memcpy (&raw.yiaddr, lease -> ip_addr.iabuf, 4);
d1246 9
a1254 9
	if (lease -> host && lease -> host -> group -> next_server.len)
		memcpy (&raw.siaddr,
			lease -> host -> group -> next_server.iabuf, 4);
	else if (lease -> subnet -> group -> next_server.len)
		memcpy (&raw.siaddr,
			lease -> subnet -> group -> next_server.iabuf, 4);
	else if (lease -> subnet -> interface_address.len)
		memcpy (&raw.siaddr,
			lease -> subnet -> interface_address.iabuf, 4);
d1256 1
a1256 1
		raw.siaddr = state -> ip -> primary_address;
d1258 1
a1258 1
	raw.giaddr = state -> giaddr;
d1260 4
a1263 4
	raw.xid = state -> xid;
	raw.secs = state -> secs;
	raw.flags = state -> bootp_flags;
	raw.hops = state -> hops;
d1268 2
a1269 2
	      (state -> offer
	       ? (state -> offer == DHCPACK ? "DHCPACK" : "DHCPOFFER")
d1271 7
a1277 7
	      piaddr (lease -> ip_addr),
	      print_hw_addr (lease -> hardware_addr.htype,
			     lease -> hardware_addr.hlen,
			     lease -> hardware_addr.haddr),
	      state -> giaddr.s_addr
	      ? inet_ntoa (state -> giaddr)
	      : state -> ip -> name);
d1280 3
a1282 3
	hto.htype = lease -> hardware_addr.htype;
	hto.hlen = lease -> hardware_addr.hlen;
	memcpy (hto.haddr, lease -> hardware_addr.haddr, hto.hlen);
d1312 1
a1312 1
			lease -> state = (struct lease_state *)0;
d1328 1
a1328 1
		   !((state -> got_server_identifier ||
d1331 2
a1332 2
		     (state -> shared_network == lease -> shared_network)) &&
		   state -> offer == DHCPACK) {
d1344 1
a1344 1
			lease -> state = (struct lease_state *)0;
d1362 1
a1362 1
	memcpy (&from, state -> from.iabuf, sizeof from);
d1364 1
a1364 1
	result = send_packet (state -> ip,
d1369 1
a1369 1
	lease -> state = (struct lease_state *)0;
d1378 1
a1378 1
	struct lease *lease = (struct lease *)0;
d1384 3
a1386 3
	if (packet -> options [DHO_DHCP_REQUESTED_ADDRESS].len &&
	    packet -> options [DHO_DHCP_REQUESTED_ADDRESS].len == 4) {
		packet -> got_requested_address = 1;
d1388 2
a1389 2
		memcpy (cip.iabuf,
			packet -> options [DHO_DHCP_REQUESTED_ADDRESS].data,
d1391 1
a1391 1
	} else if (packet -> raw -> ciaddr.s_addr) {
d1393 1
a1393 1
		memcpy (cip.iabuf, &packet -> raw -> ciaddr, 4);
d1399 1
a1399 1
	if (packet -> options [DHO_DHCP_CLIENT_IDENTIFIER].len) {
d1402 1
a1402 1
		hp = find_hosts_by_uid (packet -> options
d1404 1
a1404 1
					packet -> options
d1409 1
a1409 1
			uid_lease = (struct lease *)0;
d1412 4
a1415 4
				(packet -> options
				 [DHO_DHCP_CLIENT_IDENTIFIER].data,
				 packet -> options
				 [DHO_DHCP_CLIENT_IDENTIFIER].len);
d1418 2
a1419 2
			for (; uid_lease; uid_lease = uid_lease -> n_uid)
				if (uid_lease -> shared_network == share)
d1421 1
a1421 1
			fixed_lease = (struct lease *)0;
d1423 2
a1424 2
			    (uid_lease -> flags & ABANDONED_LEASE))
				uid_lease = (struct lease *)0;
d1427 2
a1428 2
		uid_lease = (struct lease *)0;
		fixed_lease = (struct lease *)0;
d1434 3
a1436 3
		hp = find_hosts_by_haddr (packet -> raw -> htype,
					  packet -> raw -> chaddr,
					  packet -> raw -> hlen);
d1446 3
a1448 3
	if (packet -> packet_type == DHCPREQUEST && fixed_lease &&
	    (fixed_lease -> ip_addr.len != cip.len ||
	     memcmp (fixed_lease -> ip_addr.iabuf,
d1452 1
a1452 1
		strlcpy (dhcp_message, "requested address is incorrect",
d1454 1
a1454 1
		return (struct lease *)0;
d1459 2
a1460 2
	hw_lease = find_lease_by_hw_addr (packet -> raw -> chaddr,
					  packet -> raw -> hlen);
d1463 3
a1465 3
	for (; hw_lease; hw_lease = hw_lease -> n_hw) {
		if (hw_lease -> shared_network == share) {
			if ((hw_lease -> flags & ABANDONED_LEASE))
d1467 1
a1467 1
			if (packet -> packet_type)
d1469 1
a1469 1
			if (hw_lease -> flags &
d1480 1
a1480 1
		ip_lease = (struct lease *)0;
d1495 3
a1497 3
	if (ip_lease && (ip_lease -> shared_network != share)) {
		ip_lease = (struct lease *)0;
		strlcpy (dhcp_message, "requested address on bad subnet",
d1504 1
a1504 1
	    ip_lease -> ends >= cur_time &&
d1509 12
a1520 12
		if ((ip_lease -> uid_len &&
		     packet -> options [i].data &&
		     ip_lease -> uid_len ==  packet -> options [i].len &&
		     !memcmp (packet -> options [i].data,
			      ip_lease -> uid, ip_lease -> uid_len)) ||
		    (!ip_lease -> uid_len &&
		     (ip_lease -> hardware_addr.htype ==
		      packet -> raw -> htype) &&
		     ip_lease -> hardware_addr.hlen == packet -> raw -> hlen &&
		     !memcmp (ip_lease -> hardware_addr.haddr,
			      packet -> raw -> chaddr,
			      ip_lease -> hardware_addr.hlen))) {
d1522 6
a1527 6
			    if (uid_lease -> ends > cur_time) {
				warn ("client %s has duplicate leases on %s",
				      print_hw_addr (packet -> raw -> htype,
						     packet -> raw -> hlen,
						     packet -> raw -> chaddr),
				      ip_lease -> shared_network -> name);
d1530 1
a1530 1
				    !packet -> raw -> ciaddr.s_addr)
d1536 1
a1536 1
			strlcpy (dhcp_message,
d1539 1
a1539 1
			ip_lease = (struct lease *)0;
d1545 2
a1546 2
		if (packet -> packet_type == DHCPREQUEST && fixed_lease) {
			fixed_lease = (struct lease *)0;
d1548 1
a1548 1
			warn ("Both dynamic and static leases present for %s.",
d1550 4
a1553 4
			warn ("Either remove host declaration %s or remove %s",
			      (fixed_lease && fixed_lease -> host
			       ? (fixed_lease -> host -> name
				  ? fixed_lease -> host -> name : piaddr (cip))
d1556 2
a1557 2
			warn ("from the dynamic address pool for %s",
			      share -> name);
d1559 2
a1560 2
				ip_lease = (struct lease *)0;
			strlcpy (dhcp_message,
d1568 1
a1568 1
	if (packet -> packet_type == DHCPREQUEST && fixed_lease && ip_lease)
d1576 3
a1578 3
	    hw_lease -> ends >= cur_time &&
	    hw_lease -> uid &&
	    packet -> options [DHO_DHCP_CLIENT_IDENTIFIER].len &&
d1580 1
a1580 1
		hw_lease = (struct lease *)0;
d1584 1
a1584 1
		hw_lease = (struct lease *)0;
d1586 1
a1586 1
		hw_lease = (struct lease *)0;
d1588 1
a1588 1
		uid_lease = (struct lease *)0;
d1594 2
a1595 2
		strlcpy (dhcp_message, "requested address not available",
			 sizeof(dhcp_message));
d1600 4
a1603 4
	    (share != ip_lease -> shared_network)) {
		if (packet -> packet_type == DHCPREQUEST)
			release_lease (ip_lease);
		ip_lease = (struct lease *)0;
d1606 2
a1607 2
	    (share != uid_lease -> shared_network)) {
		if (packet -> packet_type == DHCPREQUEST)
d1609 1
a1609 1
		uid_lease = (struct lease *)0;
d1612 2
a1613 2
	    (share != hw_lease -> shared_network)) {
		if (packet -> packet_type == DHCPREQUEST)
d1615 1
a1615 1
		hw_lease = (struct lease *)0;
d1621 2
a1622 2
	if (packet -> packet_type == DHCPREQUEST && !ip_lease && !fixed_lease)
		return (struct lease *)0;
d1634 1
a1634 1
			if (packet -> packet_type == DHCPREQUEST)
d1638 1
a1638 1
			lease -> host = (struct host_decl *)0;
d1647 1
a1647 1
			if (packet -> packet_type == DHCPREQUEST)
d1651 1
a1651 1
			lease -> host = (struct host_decl *)0;
d1658 1
a1658 1
			if (packet -> packet_type == DHCPREQUEST)
d1662 1
a1662 1
			lease -> host = (struct host_decl *)0;
d1670 4
a1673 4
	if (lease && host && !lease -> host) {
		for (; host; host = host -> n_ipaddr) {
			if (!host -> fixed_addr) {
				lease -> host = host;
d1682 5
a1686 5
	if (lease && (lease -> flags & ABANDONED_LEASE)) {
		if (packet -> packet_type == DHCPREQUEST) {
			warn ("Reclaiming REQUESTed abandoned IP address %s.",
			      piaddr (lease -> ip_addr));
			lease -> flags &= ~ABANDONED_LEASE;
d1688 1
a1688 1
			lease = (struct lease *)0;
a1689 1

d1693 8
a1700 8
/* Search the provided host_decl structure list for an address that's on
   the specified shared network.  If one is found, mock up and return a
   lease structure for it; otherwise return the null pointer. */

struct lease *mockup_lease (packet, share, hp)
	struct packet *packet;
	struct shared_network *share;
	struct host_decl *hp;
d1704 1
a1704 1
	mock.subnet = find_host_for_network (&hp, &mock.ip_addr, share);
d1706 3
a1708 3
		return (struct lease *)0;
	mock.next = mock.prev = (struct lease *)0;
	mock.shared_network = mock.subnet -> shared_network;
d1711 3
a1713 5
	if (hp -> group -> options [DHO_DHCP_CLIENT_IDENTIFIER]) {
		mock.uid = hp -> group ->
			options [DHO_DHCP_CLIENT_IDENTIFIER] -> value;
		mock.uid_len = hp -> group ->
			options [DHO_DHCP_CLIENT_IDENTIFIER] -> len;
d1715 1
a1715 1
		mock.uid = (unsigned char *)0;
d1719 1
a1719 1
	mock.hardware_addr = hp -> interface;
@


1.2
log
@time_t and kill a few dumb defines
@
text
@d268 1
a268 1
		
d335 1
a335 1
	    ((lease -> uid_len && lease -> uid_len == 
d411 1
a411 1
		/* first, we ping this lease to see if it's still 
d426 1
a426 1
			
d784 1
a784 1
			
d791 1
a791 1
		
d1005 1
a1005 1
			
d1017 1
a1017 1
		else 
d1458 1
a1458 1
		strlcpy (dhcp_message, "requested address is incorrect", 
d1653 1
a1653 1
			if (packet -> packet_type == DHCPREQUEST)	
d1664 1
a1664 1
			if (packet -> packet_type == DHCPREQUEST)	
d1710 1
a1710 1
	
@


1.1
log
@may the whacking begin
@
text
@d621 1
a621 1
	TIME when;
d625 4
a628 4
	TIME lease_time;
	TIME offered_lease_time;
	TIME max_lease_time;
	TIME default_lease_time;
@

