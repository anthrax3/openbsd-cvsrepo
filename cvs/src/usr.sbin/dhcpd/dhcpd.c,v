head	1.56;
access;
symbols
	OPENBSD_6_0:1.51.0.2
	OPENBSD_6_0_BASE:1.51
	OPENBSD_5_9:1.50.0.2
	OPENBSD_5_9_BASE:1.50
	OPENBSD_5_8:1.48.0.6
	OPENBSD_5_8_BASE:1.48
	OPENBSD_5_7:1.48.0.2
	OPENBSD_5_7_BASE:1.48
	OPENBSD_5_6:1.45.0.4
	OPENBSD_5_6_BASE:1.45
	OPENBSD_5_5:1.41.0.16
	OPENBSD_5_5_BASE:1.41
	OPENBSD_5_4:1.41.0.12
	OPENBSD_5_4_BASE:1.41
	OPENBSD_5_3:1.41.0.10
	OPENBSD_5_3_BASE:1.41
	OPENBSD_5_2:1.41.0.8
	OPENBSD_5_2_BASE:1.41
	OPENBSD_5_1_BASE:1.41
	OPENBSD_5_1:1.41.0.6
	OPENBSD_5_0:1.41.0.4
	OPENBSD_5_0_BASE:1.41
	OPENBSD_4_9:1.41.0.2
	OPENBSD_4_9_BASE:1.41
	OPENBSD_4_8:1.40.0.2
	OPENBSD_4_8_BASE:1.40
	OPENBSD_4_7:1.38.0.6
	OPENBSD_4_7_BASE:1.38
	OPENBSD_4_6:1.38.0.8
	OPENBSD_4_6_BASE:1.38
	OPENBSD_4_5:1.38.0.4
	OPENBSD_4_5_BASE:1.38
	OPENBSD_4_4:1.38.0.2
	OPENBSD_4_4_BASE:1.38
	OPENBSD_4_3:1.34.0.2
	OPENBSD_4_3_BASE:1.34
	OPENBSD_4_2:1.33.0.2
	OPENBSD_4_2_BASE:1.33
	OPENBSD_4_1:1.32.0.2
	OPENBSD_4_1_BASE:1.32
	OPENBSD_4_0:1.29.0.2
	OPENBSD_4_0_BASE:1.29
	OPENBSD_3_9:1.24.0.4
	OPENBSD_3_9_BASE:1.24
	OPENBSD_3_8:1.24.0.2
	OPENBSD_3_8_BASE:1.24
	OPENBSD_3_7:1.22.0.2
	OPENBSD_3_7_BASE:1.22
	OPENBSD_3_6:1.20.0.2
	OPENBSD_3_6_BASE:1.20;
locks; strict;
comment	@ * @;


1.56
date	2017.02.16.00.24.43;	author krw;	state Exp;
branches;
next	1.55;
commitid	5UCb9jKiZwXsFyNg;

1.55
date	2017.02.13.23.04.05;	author krw;	state Exp;
branches;
next	1.54;
commitid	amfLXbU964CBXnkr;

1.54
date	2017.02.13.22.33.39;	author krw;	state Exp;
branches;
next	1.53;
commitid	aD6aChUv7GEv3CLZ;

1.53
date	2017.02.13.19.13.14;	author krw;	state Exp;
branches;
next	1.52;
commitid	syYFt6P4XI7prXRF;

1.52
date	2016.08.27.01.26.22;	author guenther;	state Exp;
branches;
next	1.51;
commitid	mLhDPn5m6RI81k8n;

1.51
date	2016.04.27.10.16.10;	author mestre;	state Exp;
branches;
next	1.50;
commitid	WQSSYw5rrvOlbZbc;

1.50
date	2016.02.06.23.50.10;	author krw;	state Exp;
branches;
next	1.49;
commitid	8GMcSAoPYCa1rXN3;

1.49
date	2015.12.14.01.08.50;	author krw;	state Exp;
branches;
next	1.48;
commitid	vJvor8PLKTXbbTt2;

1.48
date	2015.02.10.23.06.13;	author krw;	state Exp;
branches;
next	1.47;
commitid	p36BUdl6pVoUSJM4;

1.47
date	2015.02.07.10.49.09;	author krw;	state Exp;
branches;
next	1.46;
commitid	Q2IFpCWrtYmII5JK;

1.46
date	2015.01.16.06.40.16;	author deraadt;	state Exp;
branches;
next	1.45;
commitid	Uu5nFG3wCl0LACBb;

1.45
date	2014.07.11.09.42.27;	author yasuoka;	state Exp;
branches;
next	1.44;
commitid	7SRccEu66mJK3N60;

1.44
date	2014.05.07.13.20.47;	author pelikan;	state Exp;
branches;
next	1.43;

1.43
date	2014.05.05.18.30.44;	author pelikan;	state Exp;
branches;
next	1.42;

1.42
date	2014.05.05.18.27.57;	author pelikan;	state Exp;
branches;
next	1.41;

1.41
date	2010.12.15.14.34.17;	author claudio;	state Exp;
branches;
next	1.40;

1.40
date	2010.07.03.04.44.51;	author guenther;	state Exp;
branches;
next	1.39;

1.39
date	2010.04.19.12.22.09;	author claudio;	state Exp;
branches;
next	1.38;

1.38
date	2008.05.29.19.02.47;	author deraadt;	state Exp;
branches;
next	1.37;

1.37
date	2008.05.25.22.36.17;	author millert;	state Exp;
branches;
next	1.36;

1.36
date	2008.05.08.07.28.08;	author beck;	state Exp;
branches;
next	1.35;

1.35
date	2008.05.07.12.19.20;	author beck;	state Exp;
branches;
next	1.34;

1.34
date	2007.12.30.13.38.47;	author sobrado;	state Exp;
branches;
next	1.33;

1.33
date	2007.07.24.15.31.04;	author stevesk;	state Exp;
branches;
next	1.32;

1.32
date	2007.02.17.18.27.38;	author deraadt;	state Exp;
branches;
next	1.31;

1.31
date	2007.02.17.13.32.15;	author jmc;	state Exp;
branches;
next	1.30;

1.30
date	2006.11.22.19.10.39;	author stevesk;	state Exp;
branches;
next	1.29;

1.29
date	2006.06.14.20.19.20;	author jmc;	state Exp;
branches;
next	1.28;

1.28
date	2006.06.14.14.58.52;	author ckuethe;	state Exp;
branches;
next	1.27;

1.27
date	2006.06.01.06.06.27;	author ckuethe;	state Exp;
branches;
next	1.26;

1.26
date	2006.05.31.02.43.15;	author ckuethe;	state Exp;
branches;
next	1.25;

1.25
date	2006.05.11.01.19.08;	author krw;	state Exp;
branches;
next	1.24;

1.24
date	2005.05.23.22.54.55;	author henning;	state Exp;
branches;
next	1.23;

1.23
date	2005.05.02.02.29.27;	author djm;	state Exp;
branches;
next	1.22;

1.22
date	2004.10.31.10.43.38;	author canacar;	state Exp;
branches;
next	1.21;

1.21
date	2004.09.16.18.35.43;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2004.09.09.20.51.57;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2004.05.12.10.20.49;	author henning;	state Exp;
branches;
next	1.18;

1.18
date	2004.05.04.20.28.40;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2004.04.21.09.11.58;	author canacar;	state Exp;
branches;
next	1.16;

1.16
date	2004.04.21.01.44.33;	author henning;	state Exp;
branches;
next	1.15;

1.15
date	2004.04.20.00.27.57;	author henning;	state Exp;
branches;
next	1.14;

1.14
date	2004.04.18.00.43.27;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2004.04.18.00.30.33;	author henning;	state Exp;
branches;
next	1.12;

1.12
date	2004.04.16.04.30.09;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2004.04.15.23.20.42;	author henning;	state Exp;
branches;
next	1.10;

1.10
date	2004.04.15.08.34.20;	author jmc;	state Exp;
branches;
next	1.9;

1.9
date	2004.04.14.04.34.19;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2004.04.14.04.21.32;	author henning;	state Exp;
branches;
next	1.7;

1.7
date	2004.04.14.04.13.58;	author henning;	state Exp;
branches;
next	1.6;

1.6
date	2004.04.14.03.59.17;	author henning;	state Exp;
branches;
next	1.5;

1.5
date	2004.04.14.02.18.41;	author henning;	state Exp;
branches;
next	1.4;

1.4
date	2004.04.14.02.13.37;	author henning;	state Exp;
branches;
next	1.3;

1.3
date	2004.04.14.00.56.02;	author henning;	state Exp;
branches;
next	1.2;

1.2
date	2004.04.13.23.57.49;	author henning;	state Exp;
branches;
next	1.1;

1.1
date	2004.04.13.23.41.48;	author henning;	state Exp;
branches;
next	;


desc
@@


1.56
log
@Bring parse_warn() into the log.[ch] 21st century and adopt the "^"
placement logic from dhclient.
@
text
@/*	$OpenBSD: dhcpd.c,v 1.55 2017/02/13 23:04:05 krw Exp $ */

/*
 * Copyright (c) 2004 Henning Brauer <henning@@cvs.openbsd.org>
 * Copyright (c) 1995, 1996, 1997, 1998, 1999
 * The Internet Software Consortium.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of The Internet Software Consortium nor the names
 *    of its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INTERNET SOFTWARE CONSORTIUM AND
 * CONTRIBUTORS ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE INTERNET SOFTWARE CONSORTIUM OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This software has been written for the Internet Software Consortium
 * by Ted Lemon <mellon@@fugue.com> in cooperation with Vixie
 * Enterprises.  To learn more about the Internet Software Consortium,
 * see ``http://www.vix.com/isc''.  To learn more about Vixie
 * Enterprises, see ``http://www.vix.com''.
 */

#include <sys/types.h>
#include <sys/socket.h>

#include <net/if.h>

#include <arpa/inet.h>

#include <err.h>
#include <netdb.h>
#include <paths.h>
#include <pwd.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <syslog.h>
#include <time.h>
#include <unistd.h>

#include "dhcp.h"
#include "tree.h"
#include "dhcpd.h"
#include "log.h"
#include "sync.h"


__dead void usage(void);

time_t cur_time, last_scan;
struct group root_group;

u_int16_t server_port;
u_int16_t client_port;

struct passwd *pw;
int log_priority;
int pfpipe[2];
int gotpipe = 0;
int syncrecv;
int syncsend;
pid_t pfproc_pid = -1;
char *path_dhcpd_conf = _PATH_DHCPD_CONF;
char *path_dhcpd_db = _PATH_DHCPD_DB;
char *abandoned_tab = NULL;
char *changedmac_tab = NULL;
char *leased_tab = NULL;

int
main(int argc, char *argv[])
{
	int ch, cftest = 0, daemonize = 1, rdomain = -1, udpsockmode = 0;
	char *sync_iface = NULL;
	char *sync_baddr = NULL;
	u_short sync_port = 0;
	struct servent *ent;
	struct in_addr udpaddr;

	log_init(1, LOG_DAEMON);	/* log to stderr until daemonized */
	log_setverbose(1);

	opterr = 0;
	while ((ch = getopt(argc, argv, "A:C:L:c:dfl:nu::Y:y:")) != -1)
		switch (ch) {
		case 'Y':
			syncsend = 1;
			break;
		case 'y':
			syncrecv = 1;
			break;
		}
	if (syncsend || syncrecv) {
		if ((ent = getservbyname("dhcpd-sync", "udp")) == NULL)
			errx(1, "Can't find service \"dhcpd-sync\" in "
			    "/etc/services");
		sync_port = ntohs(ent->s_port);
	}

	udpaddr.s_addr = htonl(INADDR_BROADCAST);

	optreset = optind = opterr = 1;
	while ((ch = getopt(argc, argv, "A:C:L:c:dfl:nu::Y:y:")) != -1)
		switch (ch) {
		case 'A':
			abandoned_tab = optarg;
			break;
		case 'C':
			changedmac_tab = optarg;
			break;
		case 'L':
			leased_tab = optarg;
			break;
		case 'c':
			path_dhcpd_conf = optarg;
			break;
		case 'd':
			daemonize = 0;
			break;
		case 'f':
			daemonize = 0;
			break;
		case 'l':
			path_dhcpd_db = optarg;
			break;
		case 'n':
			daemonize = 0;
			cftest = 1;
			break;
		case 'u':
			udpsockmode = 1;
			if (optarg != NULL) {
				if (inet_aton(optarg, &udpaddr) != 1)
					errx(1, "Cannot parse binding IP "
					    "address: %s", optarg);
			}
			break;
		case 'Y':
			if (sync_addhost(optarg, sync_port) != 0)
				sync_iface = optarg;
			syncsend = 1;
			break;
		case 'y':
			sync_baddr = optarg;
			syncrecv = 1;
			break;
		default:
			usage();
		}

	argc -= optind;
	argv += optind;

	while (argc > 0) {
		struct interface_info *tmp = calloc(1, sizeof(*tmp));
		if (!tmp)
			fatalx("calloc");
		strlcpy(tmp->name, argv[0], sizeof(tmp->name));
		tmp->next = interfaces;
		interfaces = tmp;
		argc--;
		argv++;
	}

	/* Default DHCP/BOOTP ports. */
	server_port = htons(SERVER_PORT);
	client_port = htons(CLIENT_PORT);

	tzset();

	time(&cur_time);
	if (!readconf())
		fatalx("Configuration file errors encountered");

	if (cftest)
		exit(0);

	db_startup();
	if (!udpsockmode || argc > 0)
		discover_interfaces(&rdomain);

	if (rdomain != -1)
		if (setrtable(rdomain) == -1)
			fatal("setrtable");

	if (syncsend || syncrecv) {
		syncfd = sync_init(sync_iface, sync_baddr, sync_port);
		if (syncfd == -1)
			err(1, "sync init");
	}

	if (daemonize)
		daemon(0, 0);

	log_init(0, LOG_DAEMON);	/* stop logging to stderr */
	log_setverbose(0);

	if ((pw = getpwnam("_dhcp")) == NULL)
		fatalx("user \"_dhcp\" not found");

	/* don't go near /dev/pf unless we actually intend to use it */
	if ((abandoned_tab != NULL) ||
	    (changedmac_tab != NULL) ||
	    (leased_tab != NULL)){
		if (pipe(pfpipe) == -1)
			fatal("pipe");
		switch (pfproc_pid = fork()){
		case -1:
			fatal("fork");
			/* NOTREACHED */
			exit(1);
		case 0:
			/* child process. start up table engine */
			close(pfpipe[1]);
			pftable_handler();
			/* NOTREACHED */
			exit(1);
		default:
			close(pfpipe[0]);
			gotpipe = 1;
			break;
		}
	}

	if (udpsockmode)
		udpsock_startup(udpaddr);

	icmp_startup(1, lease_pinged);

	if (chroot(_PATH_VAREMPTY) == -1)
		fatal("chroot %s", _PATH_VAREMPTY);
	if (chdir("/") == -1)
		fatal("chdir(\"/\")");
	if (setgroups(1, &pw->pw_gid) ||
	    setresgid(pw->pw_gid, pw->pw_gid, pw->pw_gid) ||
	    setresuid(pw->pw_uid, pw->pw_uid, pw->pw_uid))
		fatal("can't drop privileges");

	if (udpsockmode) {
		if (pledge("stdio inet route sendfd", NULL) == -1)
			err(1, "pledge");
	} else {
		if (pledge("stdio inet sendfd", NULL) == -1)
			err(1, "pledge");
	}

	add_timeout(cur_time + 5, periodic_scan, NULL);
	dispatch();

	/* not reached */
	exit(0);
}

__dead void
usage(void)
{
	extern char *__progname;

	fprintf(stderr, "usage: %s [-dfn] [-A abandoned_ip_table]",
	    __progname);
	fprintf(stderr, " [-C changed_ip_table]\n");
	fprintf(stderr, "\t[-c config-file] [-L leased_ip_table]");
	fprintf(stderr, " [-l lease-file] [-u[bind_address]]\n");
	fprintf(stderr, "\t[-Y synctarget] [-y synclisten] [if0 [... ifN]]\n");
	exit(1);
}

void
lease_pinged(struct iaddr from, u_int8_t *packet, int length)
{
	struct lease *lp;

	/*
	 * Don't try to look up a pinged lease if we aren't trying to
	 * ping one - otherwise somebody could easily make us churn by
	 * just forging repeated ICMP EchoReply packets for us to look
	 * up.
	 */
	if (!outstanding_pings)
		return;

	lp = find_lease_by_ip_addr(from);

	if (!lp) {
		log_info("unexpected ICMP Echo Reply from %s", piaddr(from));
		return;
	}

	if (!lp->state && !lp->releasing) {
		log_warnx("ICMP Echo Reply for %s arrived late or is "
		    "spurious.", piaddr(from));
		return;
	}

	/* At this point it looks like we pinged a lease and got a
	 * response, which shouldn't have happened.
	 * if it did it's either one of two two cases:
	 * 1 - we pinged this lease before offering it and
	 *     something answered, so we abandon it.
	 * 2 - we pinged this lease before releasing it
	 *     and something answered, so we don't release it.
	 */
	if (lp->releasing) {
		log_warnx("IP address %s answers a ping after sending a "
		    "release", piaddr(lp->ip_addr));
		log_warnx("Possible release spoof - Not releasing address %s",
		    piaddr(lp->ip_addr));
		lp->releasing = 0;
	} else {
		free_lease_state(lp->state, "lease_pinged");
		lp->state = NULL;
		abandon_lease(lp, "pinged before offer");
	}
	cancel_timeout(lease_ping_timeout, lp);
	--outstanding_pings;
}

void
lease_ping_timeout(void *vlp)
{
	struct lease	*lp = vlp;

	--outstanding_pings;
	if (lp->releasing) {
		lp->releasing = 0;
		release_lease(lp);
	} else
		dhcp_reply(lp);
}

/* from memory.c - needed to be able to walk the lease table */
extern struct subnet *subnets;

#define MINIMUM(a,b) (((a)<(b))?(a):(b))

void
periodic_scan(void *p)
{
	time_t x, y;
	struct subnet		*n;
	struct group		*g;
	struct shared_network	*s;
	struct lease		*l;

	/* find the shortest lease this server gives out */
	x = MINIMUM(root_group.default_lease_time, root_group.max_lease_time);
	for (n = subnets; n; n = n->next_subnet)
		for (g = n->group; g; g = g->next)
			x = MINIMUM(x, g->default_lease_time);

	/* use half of the shortest lease as the scan interval */
	y = x / 2;
	if (y < 1)
		y = 1;

	/* walk across all leases to find the exired ones */
	for (n = subnets; n; n = n->next_subnet)
		for (g = n->group; g; g = g->next)
			for (s = g->shared_network; s; s = s->next)
				for (l = s->leases; l && l->ends; l = l->next)
					if (cur_time >= l->ends)
						if (l->ends > last_scan)
							pfmsg('R', l);

	last_scan = cur_time;
	add_timeout(cur_time + y, periodic_scan, NULL);
}
@


1.55
log
@Eliminate pointless'%m' (a.k.a. hand rolled strerror()) by using fatal() and
log_warn(). Zap a couple of explicit 'syslog()' calls.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.c,v 1.54 2017/02/13 22:33:39 krw Exp $ */
a76 1
int log_perror = 0;
a136 1
			log_perror = 1;
a146 1
			log_perror = 1;
@


1.54
log
@Adjust some long lines.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.c,v 1.53 2017/02/13 19:13:14 krw Exp $ */
d205 1
a205 1
			fatalx("setrtable (%m)");
d227 1
a227 1
			fatalx("pipe (%m)");
d230 1
a230 1
			fatalx("fork (%m)");
d252 1
a252 1
		fatalx("chroot %s: %m", _PATH_VAREMPTY);
d254 1
a254 1
		fatalx("chdir(\"/\"): %m");
d258 1
a258 1
		fatalx("can't drop privileges: %m");
@


1.53
log
@Switch from old errwarn.c logging to shiny new log.[ch].

ok benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.c,v 1.52 2016/08/27 01:26:22 guenther Exp $ */
d280 2
a281 1
	fprintf(stderr, "usage: %s [-dfn] [-A abandoned_ip_table]", __progname);
d311 2
a312 2
		log_warnx("ICMP Echo Reply for %s arrived late or is spurious.",
		    piaddr(from));
d325 2
a326 2
		log_warnx("IP address %s answers a ping after sending a release",
		    piaddr(lp->ip_addr));
@


1.52
log
@Pull in <time.h> for one or more of gmtime, strftime, strptime, time,
timegm, and tzset

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.c,v 1.51 2016/04/27 10:16:10 mestre Exp $ */
d63 1
a87 1
struct syslog_data sdata = SYSLOG_DATA_INIT;
a92 1
	extern char *__progname;
d99 2
a100 2
	/* Initially, log errors to stderr as well as to syslogd. */
	openlog_r(__progname, LOG_PID | LOG_NDELAY, DHCPD_LOG_FACILITY, &sdata);
d178 1
a178 1
			error("calloc");
d194 1
a194 1
		error("Configuration file errors encountered");
d205 1
a205 1
			error("setrtable (%m)");
d216 3
d220 1
a220 1
		error("user \"_dhcp\" not found");
d227 1
a227 1
			error("pipe (%m)");
d230 1
a230 1
			error("fork (%m)");
d252 1
a252 1
		error("chroot %s: %m", _PATH_VAREMPTY);
d254 1
a254 1
		error("chdir(\"/\"): %m");
d258 1
a258 1
		error("can't drop privileges: %m");
d305 1
a305 1
		note("unexpected ICMP Echo Reply from %s", piaddr(from));
d310 1
a310 1
		warning("ICMP Echo Reply for %s arrived late or is spurious.",
d324 1
a324 1
		warning("IP address %s answers a ping after sending a release",
d326 1
a326 1
		warning("Possible release spoof - Not releasing address %s",
@


1.51
log
@Remove pledge(2)'s that are called before chroot(2) since in the near future
this will be forbidden. The remaining pledge(2) calls after chroot(2) are still
kept.

OK semarie@@ "it is time now"
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.c,v 1.50 2016/02/06 23:50:10 krw Exp $ */
d57 1
@


1.50
log
@Eliminate #include inside *.h files and include only needed headers in
each *.c file.

Inspired by mention of header silliness by Edgar Pettijohn and mmcc@@
on tech@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.c,v 1.49 2015/12/14 01:08:50 krw Exp $ */
d243 1
a243 1
	if (udpsockmode) {
a244 4
	} else {
		if (pledge("stdio rpath inet sendfd proc id", NULL) == -1)
			err(1, "pledge");
	}
@


1.49
log
@pledge.

Diff from Ricardo Mestre. Test report from sthen@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.c,v 1.48 2015/02/10 23:06:13 krw Exp $ */
d42 19
a63 2
#include <err.h>
#include <pwd.h>
@


1.48
log
@Keep track of the last time we scanned the leases to find expired
ones that needed to be booted out of the pf table process. This
avoids removing the same addess over and over.

Problem report and original diff from Bertrand Provost.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.c,v 1.47 2015/02/07 10:49:09 krw Exp $ */
d48 1
a48 1
void usage(void);
a189 4
	if (udpsockmode)
		udpsock_startup(udpaddr);
	icmp_startup(1, lease_pinged);

d196 3
a201 3
	if (daemonize)
		daemon(0, 0);

d226 9
d244 8
d259 1
a259 1
void
@


1.47
log
@Close appropriate ends of pfpipe. Lets pf table process die when dhcpd
does.

Pointed out by Bertrand Provost.

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.c,v 1.46 2015/01/16 06:40:16 deraadt Exp $ */
d50 1
a50 1
time_t cur_time;
d352 3
a354 4
					if (cur_time >= l->ends){
						release_lease(l);
						pfmsg('R', l);
					}
d356 1
@


1.46
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.c,v 1.45 2014/07/11 09:42:27 yasuoka Exp $ */
d219 1
d224 1
@


1.45
log
@Add -u option to bind UDP port as a socket to answer DHCPINFORM from
the clients on non ethernet interfaces (eg. tun(4) or pppx(4)).

input krw
ok krw
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.c,v 1.44 2014/05/07 13:20:47 pelikan Exp $ */
d323 2
d335 1
a335 1
	x = MIN(root_group.default_lease_time, root_group.max_lease_time);
d338 1
a338 1
			x = MIN(x, g->default_lease_time);
@


1.44
log
@back out the previous ICMP simplifying diff, it caused livelocks.

reported by Mikolaj Kucharski, thanks!
ok krw
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.c,v 1.43 2014/05/05 18:30:44 pelikan Exp $ */
d74 1
a74 1
	int ch, cftest = 0, daemonize = 1, rdomain = -1;
d80 1
d86 1
a86 1
	while ((ch = getopt(argc, argv, "A:C:L:c:dfl:nY:y:")) != -1)
d102 2
d105 1
a105 1
	while ((ch = getopt(argc, argv, "A:C:L:c:dfl:nY:y:")) != -1)
d134 8
d183 2
a184 1
	discover_interfaces(&rdomain);
d190 2
d252 2
a253 2
	fprintf(stderr, " [-l lease-file] [-Y synctarget] [-y synclisten]\n");
	fprintf(stderr, "\t[if0 [... ifN]]\n");
@


1.43
log
@Don't call the BOOTP handler indirectly.

ok krw
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.c,v 1.42 2014/05/05 18:27:57 pelikan Exp $ */
d178 1
a178 1
	icmp_startup();
@


1.42
log
@Don't call the ICMP handler indirectly + clean up a bit.

ok krw
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.c,v 1.41 2010/12/15 14:34:17 claudio Exp $ */
a222 1
	bootp_packet_handler = do_packet;
@


1.41
log
@We run getopt() twice to know if dhcp-sync is used. To make this work
both getopt calls need the same optstring or the first getopt() call
will end before parsing all arguments.
Problem found and fixed supplied by m_athias
OK millert@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.c,v 1.40 2010/07/03 04:44:51 guenther Exp $ */
d178 1
a178 1
	icmp_startup(1, lease_pinged);
@


1.40
log
@Fix the naming of interfaces and variables for rdomains and rtables
and make it possible to bind sockets (including listening sockets!)
to rtables and not just rdomains.  This changes the name of the
system calls, socket option, and ioctl.  After building with this
you should remove the files /usr/share/man/cat2/[gs]etrdomain.0.

Since this removes the existing [gs]etrdomain() system calls, the
libc major is bumped.

Written by claudio@@, criticized^Wcritiqued by me
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.c,v 1.39 2010/04/19 12:22:09 claudio Exp $ */
d85 1
a85 1
	while ((ch = getopt(argc, argv, "Y:y:")) != -1)
@


1.39
log
@If interfaces are specified, get their rdomain and bind dhcpd into the same
domain with setrdomain(). This allows to run dhcpd on multiple rdomains.
OK krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.c,v 1.38 2008/05/29 19:02:47 deraadt Exp $ */
d175 2
a176 2
		if (setrdomain(rdomain) == -1)
			error("setrdomain (%m)");
@


1.38
log
@appease stupid stupid gcc; ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.c,v 1.37 2008/05/25 22:36:17 millert Exp $ */
d74 1
a74 1
	int ch, cftest = 0, daemonize = 1;
d171 9
a184 5

	db_startup();
	discover_interfaces();
	icmp_startup(1, lease_pinged);

@


1.37
log
@Don't error out if dhcpd-sync does not exist in /etc/services and no
sync options were specified.  OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.c,v 1.36 2008/05/08 07:28:08 beck Exp $ */
d78 1
a78 1
	u_short sync_port;
@


1.36
log
@this should really only be in one file.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.c,v 1.35 2008/05/07 12:19:20 beck Exp $ */
a63 1
u_short sync_port;
d78 1
d84 16
a99 3
	if ((ent = getservbyname("dhcpd-sync", "udp")) == NULL)
		errx(1, "Can't find service \"dhcpd-sync\" in /etc/services");
	sync_port = ntohs(ent->s_port);
d101 1
d134 1
a134 1
			syncsend++;
d138 1
a138 1
			syncrecv++;
@


1.35
log
@Add synchronisation support for dhcpd - this allows for two dhcpd's
with the same configuration to be run on the same net and they will
keep their lease files/state in synch, and therefore allowing you to
run redundant dhcpd's. Synchronization code stolen from spamd, uses
an hmac key in /var/db/dhcpd.key if it exists.
ok krw@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.c,v 1.34 2007/12/30 13:38:47 sobrado Exp $ */
a62 1
int syncfd = -1;
@


1.34
log
@add missing space between argument names and ellipsis

ok jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.c,v 1.33 2007/07/24 15:31:04 stevesk Exp $ */
d43 1
d45 1
d61 3
d65 1
d71 1
d78 3
d83 1
a83 2
	openlog(__progname, LOG_NDELAY, DHCPD_LOG_FACILITY);
	setlogmask(LOG_UPTO(LOG_INFO));
d85 5
a89 1
	while ((ch = getopt(argc, argv, "A:C:L:c:dfl:n")) != -1)
d118 9
d158 6
d168 1
d222 1
a222 1
	fprintf(stderr, " [-l lease-file]\n");
@


1.33
log
@use 1 vs. -1 for true; ok henning@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.c,v 1.32 2007/02/17 18:27:38 deraadt Exp $ */
d194 1
a194 1
	fprintf(stderr, "\t[if0 [...ifN]]\n");
@


1.32
log
@-q flag is unused (old shared code from dhclient); spotted by mark@@cyodesigns
ok krw
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.c,v 1.31 2007/02/17 13:32:15 jmc Exp $ */
d92 1
a92 1
			log_perror = -1;
d103 1
a103 1
			log_perror = -1;
@


1.31
log
@no code for -p, so remove from man page and usage();
confirmed by ckuethe;
spotted by Mark Lumsden
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.c,v 1.30 2006/11/22 19:10:39 stevesk Exp $ */
d76 1
a76 1
	while ((ch = getopt(argc, argv, "A:C:L:c:dfl:nq")) != -1)
a103 2
			break;
		case 'q':
@


1.30
log
@small header cleanup:
remove uneeded header
use <foo.h> not "foo.h" for system include

no binary change; ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.c,v 1.29 2006/06/14 20:19:20 jmc Exp $ */
d196 1
a196 1
	fprintf(stderr, "\t[-p pf-device] [if0 [...ifN]]\n");
@


1.29
log
@sort options;
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.c,v 1.28 2006/06/14 14:58:52 ckuethe Exp $ */
d43 2
a44 1
#include "pwd.h"
@


1.28
log
@This diff allows dhcpd to put active leases into a pf table. Dhcpd will then
periodically - based on the length of the shortest lease time - walk across
all leases searching for expired leases which are then removed from the pf
table.

ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.c,v 1.27 2006/06/01 06:06:27 ckuethe Exp $ */
d193 1
a193 1
	fprintf(stderr, "\t[-L leased_ip_table] [-c config-file]");
@


1.27
log
@Sort options in usage. From jmc.
ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.c,v 1.26 2006/05/31 02:43:15 ckuethe Exp $ */
d63 1
d75 1
a75 1
	while ((ch = getopt(argc, argv, "A:C:c:dfl:nq")) != -1)
d83 3
d148 3
a150 1
	if ((abandoned_tab != NULL) || (changedmac_tab != NULL)){
d179 1
d193 3
a195 2
	fprintf(stderr, "\t[-c config-file] [-l lease-file]");
	fprintf(stderr, " [-p pf-device] [if0 [...ifN]]\n");
d260 36
@


1.26
log
@This diff makes dhcpd able to manipulate pf tables on certain lease events.

dhcpd is now able to place abandoned addresses into a table (to offer some
protection against machines camping on an address) and remove them from the
table if they are properly leased.

When dhcpd assigns an IP to a new hardware address, it can remove that
address from a table. This is for use with the overload table in pf; newly
arrived machines will not be punished for the actions of a machine that
went away.

beck@@ and krw@@ liked previous versions of this, henning@@ final ok
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.c,v 1.25 2006/05/11 01:19:08 krw Exp $ */
d184 4
a187 4
	fprintf(stderr, "usage: %s [-dfn] [-c config-file]", __progname);
	fprintf(stderr, " [-l lease-file] [-p pf-device]\n");
	fprintf(stderr, "             [-A abandoned_ip_table]");
	fprintf(stderr, " [-C changed_ip_table] [if0 [...ifN]]\n");
@


1.25
log
@If a list of interfaces is supplied via the command line or
dhcpd.interfaces then

a) don't bother looking up information on interfaces that were not
requested;

b) don't exit if a requested interface is not found, just issue a
warning message;

c) exit if none of the interfaces were found.

The command line for dhcpd shown in ps will continue to show requested
but ignored interfaces.

As usual with dhc* code, whack a bunch of unused states, constants,
flags, etc. Since we only invoke discover_interfaces() with
DISCOVER_SERVER, there is no need to keep track of other
possibilities.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.c,v 1.24 2005/05/23 22:54:55 henning Exp $ */
d53 1
d56 3
d61 2
a67 1
	struct passwd	*pw;
d74 1
a74 1
	while ((ch = getopt(argc, argv, "c:dfl:nq")) != -1)
d76 6
d143 20
d184 4
a187 3
	fprintf(stderr, "usage: %s [-dfn] [-c config-file] [-l lease-file]",
	    __progname);
	fprintf(stderr, " [if0 [...ifN]]\n");
@


1.24
log
@-endpwent
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.c,v 1.23 2005/05/02 02:29:27 djm Exp $ */
a103 1
		tmp->flags = INTERFACE_REQUESTED;
d123 1
a123 1
	discover_interfaces(DISCOVER_SERVER);
@


1.23
log
@more setres[ug]id; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.c,v 1.22 2004/10/31 10:43:38 canacar Exp $ */
a140 1
	endpwent();
@


1.22
log
@change the undocumented -t flag to -n used for configuration testing
and document it. cleanup some unused/unneeded variables while there.
idea & ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.c,v 1.21 2004/09/16 18:35:43 deraadt Exp $ */
d138 2
a139 2
	    setegid(pw->pw_gid) || setgid(pw->pw_gid) ||
	    seteuid(pw->pw_uid) || setuid(pw->pw_uid))
@


1.21
log
@avoid aliasing with libc functions; ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.c,v 1.20 2004/09/09 20:51:57 millert Exp $ */
d54 1
a54 1
int log_perror = 1;
d61 1
a61 1
	int ch, cftest = 0, quiet = 0, daemonize = 1;
d69 1
a69 1
	while ((ch = getopt(argc, argv, "c:dfl:tq")) != -1)
d84 1
a84 5
		case 'q':
			quiet = 1;
			quiet_interface_discovery = 1;
			break;
		case 't':
d89 2
a109 3
	if (quiet)
		log_perror = 0;

a129 1
	log_perror = 0;
d155 1
a155 1
	fprintf(stderr, "usage: %s [-df] [-c config-file] [-l lease-file]",
d157 1
a157 1
	fprintf(stderr, " [-p port] [if0 [...ifN]]\n");
@


1.20
log
@Avoid following a NULL pointer if a hostname lookup fails and
remove an extraneous "exiting" when there is a config file error.
OK henning@@ and mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.c,v 1.19 2004/05/12 10:20:49 henning Exp $ */
d189 1
a189 1
		warn("ICMP Echo Reply for %s arrived late or is spurious.",
d203 1
a203 1
		warn("IP address %s answers a ping after sending a release",
d205 1
a205 1
		warn("Possible release spoof - Not releasing address %s",
@


1.19
log
@like always I missed tzset(); Ben Lovett <ben@@tilderoot.com>
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.c,v 1.18 2004/05/04 20:28:40 deraadt Exp $ */
d123 1
a123 1
		error("Configuration file errors encountered -- exiting");
@


1.18
log
@remove things not used, spotted by lint mostly; ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.c,v 1.17 2004/04/21 09:11:58 canacar Exp $ */
d118 2
@


1.17
log
@filter writes and lock bpf descriptor, ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.c,v 1.16 2004/04/21 01:44:33 henning Exp $ */
a48 3

struct iaddr server_identifier;
int server_identifier_matched;
@


1.16
log
@fix the error message in case the _dhcp user does not exist
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.c,v 1.15 2004/04/20 00:27:57 henning Exp $ */
d53 2
a54 2
u_int16_t local_port;
u_int16_t remote_port;
d118 3
a120 2
	local_port = htons(67);
	remote_port = htons(68);
@


1.15
log
@don't allow the port to be changed here either
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.c,v 1.14 2004/04/18 00:43:27 deraadt Exp $ */
d133 1
a133 1
		error("%m");
@


1.14
log
@various knf; henning ok
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.c,v 1.13 2004/04/18 00:30:33 henning Exp $ */
d64 1
a64 2
	int ch, status, cftest = 0, quiet = 0, daemonize = 1;
	struct servent	*ent;
d72 1
a72 1
	while ((ch = getopt(argc, argv, "c:dfl:p:tq")) != -1)
a86 6
		case 'p':
			status = atoi(optarg);
			if (status < 1 || status > 65535)
				error("%s: not a valid UDP port", optarg);
			local_port = htons(status);
			break;
d118 2
a119 9
	/* Default to the DHCP/BOOTP port. */
	if (!local_port) {
		ent = getservbyname("dhcp", "udp");
		if (!ent)
			local_port = htons(67);
		else
			local_port = ent->s_port;
		endservent();
	}
a120 1
	remote_port = htons(ntohs(local_port) + 1);
@


1.13
log
@dhcpd may be invoked without any interface given
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.c,v 1.12 2004/04/16 04:30:09 deraadt Exp $ */
d64 1
a64 2
	int		 ch, status;
	int		 cftest = 0, quiet = 0, daemonize = 1;
d71 1
a71 1
	setlogmask(LOG_UPTO (LOG_INFO));
d127 1
a127 1
		ent = getservbyname ("dhcp", "udp");
d129 1
a129 1
			local_port = htons (67);
d137 1
a137 1
	if (!readconf ())
d185 1
a185 1
	struct lease	*lp;
@


1.12
log
@a bunch of knf, ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.c,v 1.11 2004/04/15 23:20:42 henning Exp $ */
a109 3

	if (!argc)
		usage();
@


1.11
log
@chroot and drop privileges after startup
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.c,v 1.10 2004/04/15 08:34:20 jmc Exp $ */
d207 1
a207 1
	if (!lp->state && ! lp->releasing) {
@


1.10
log
@- trim/update AUTHORS
- standard options list and correct SYNOPSIS for dhcpd(8)
- sync usage()

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.c,v 1.9 2004/04/14 04:34:19 deraadt Exp $ */
d43 1
d67 1
d151 3
d157 10
@


1.9
log
@spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.c,v 1.8 2004/04/14 04:21:32 henning Exp $ */
d165 1
a165 1
	fprintf(stderr, "usage: %s [-df] [-p <port>] [-c config-file]",
d167 1
a167 1
	fprintf(stderr, " [-l lease-file] [if0 [...ifN]]\n");
@


1.8
log
@KNF, ansi and such
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.c,v 1.7 2004/04/14 04:13:58 henning Exp $ */
d199 1
a199 1
	 * response, which shouldn't have happened. 
d203 1
a203 1
	 * 2 - we pinged this lease before releasing it 
@


1.7
log
@getopt
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.c,v 1.6 2004/04/14 03:59:17 henning Exp $ */
d90 1
a90 1
				error ("%s: not a valid UDP port", optarg);
d133 2
a134 2
			local_port = ent -> s_port;
		endservent ();
d136 1
a136 1
  
a137 2

	/* Get the current time... */
a138 2

	/* Read the dhcpd.conf file... */
d140 1
a140 1
		error ("Configuration file errors encountered -- exiting");
d142 2
a143 3
        /* test option should cause an early exit */
 	if (cftest) 
 		exit(0);
a144 1
	/* Start up the database... */
a145 2

	/* Discover all the network interfaces and initialize them. */
a146 2

	/* Initialize icmp support... */
a152 1
	/* Set up the bootp packet handler... */
a153 2

	/* Receive packets and dispatch them... */
d156 2
a157 2
	/* Not reached */
	return (0);
d166 1
a166 1
	   __progname);
d171 2
a172 4
void lease_pinged (from, packet, length)
	struct iaddr from;
	u_int8_t *packet;
	int length;
d174 1
a174 1
	struct lease *lp;
d176 6
a181 4
	/* Don't try to look up a pinged lease if we aren't trying to
	   ping one - otherwise somebody could easily make us churn by
	   just forging repeated ICMP EchoReply packets for us to look
	   up. */
d185 1
a185 1
	lp = find_lease_by_ip_addr (from);
d188 1
a188 1
		note ("unexpected ICMP Echo Reply from %s", piaddr (from));
d192 3
a194 3
	if (!lp -> state && ! lp -> releasing) {
		warn ("ICMP Echo Reply for %s arrived late or is spurious.",
		      piaddr (from));
d203 1
a203 1
	 * 2 - we pinged this lease before releaseing it 
d206 10
a215 11
	if (lp -> releasing) {
		warn ("IP address %s answers a ping after sending a release",
		      piaddr (lp -> ip_addr));
		warn ("Possible release spoof - Not releasing address %s",
		      piaddr (lp -> ip_addr));
		lp -> releasing = 0;
	}
	else {
		free_lease_state (lp -> state, "lease_pinged");
		lp -> state = (struct lease_state *)0;
		abandon_lease (lp, "pinged before offer");
d217 1
a217 1
	cancel_timeout (lease_ping_timeout, lp);
d221 2
a222 2
void lease_ping_timeout (vlp)
	void *vlp;
d224 2
a225 2
	struct lease *lp = vlp;
	
d230 2
a231 3
	}
	else 
		dhcp_reply (lp);
@


1.6
log
@less pathetic usage(), and I felt free to remove the helpfull
/* print usage message */
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.c,v 1.5 2004/04/14 02:18:41 henning Exp $ */
d63 3
a65 6
	int i, status;
	struct servent *ent;
	char *s;
	int cftest = 0;
	int quiet = 0;
	int daemonize = 1;
d72 6
a77 16
	for (i = 1; i < argc; i++) {
		if (!strcmp (argv [i], "-p")) {
			if (++i == argc)
				usage();
			for (s = argv [i]; *s; s++)
				if (!isdigit (*s))
					error ("%s: not a valid UDP port",
					       argv [i]);
			status = atoi (argv [i]);
			if (status < 1 || status > 65535)
				error ("%s: not a valid UDP port",
				       argv [i]);
			local_port = htons (status);
			debug ("binding to user-specified port %d",
			       ntohs (local_port));
		} else if (!strcmp (argv [i], "-f")) {
d79 3
a81 1
		} else if (!strcmp (argv [i], "-d")) {
d83 15
a97 11
			log_perror = -1;
		} else if (!strcmp (argv [i], "-cf")) {
			if (++i == argc)
				usage();
			path_dhcpd_conf = argv [i];
		} else if (!strcmp (argv [i], "-lf")) {
			if (++i == argc)
				usage();
			path_dhcpd_db = argv [i];
                } else if (!strcmp (argv [i], "-t")) {
			/* test configurations only */
d101 2
a102 4
		} else if (!strcmp (argv [i], "-q")) {
			quiet = 1;
			quiet_interface_discovery = 1;
		} else if (argv [i][0] == '-') {
a103 12
		} else {
			struct interface_info *tmp =
				((struct interface_info *)
				 dmalloc (sizeof *tmp, "get_interface_list"));
			if (!tmp)
				error ("Insufficient memory to %s %s",
				       "record interface", argv [i]);
			memset (tmp, 0, sizeof *tmp);
			strlcpy (tmp->name, argv [i], sizeof(tmp->name));
			tmp->next = interfaces;
			tmp->flags = INTERFACE_REQUESTED;
			interfaces = tmp;
d105 17
d128 1
a128 2
	if (!local_port)
	{
@


1.5
log
@remove pidfile gunk, use daemon, and get rid of some debugging crap
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.c,v 1.4 2004/04/14 02:13:37 henning Exp $ */
d4 1
a41 1

d44 1
a44 1
static void usage(char *);
d60 2
a61 3
int main (argc, argv)
	int argc;
	char **argv;
d65 1
a65 1
	char *s, *appname;
d69 1
a69 6

	appname = strrchr (argv [0], '/');
	if (!appname)
		appname = argv [0];
	else
		appname++;
d72 2
a73 2
	openlog (appname, LOG_NDELAY, DHCPD_LOG_FACILITY);
	setlogmask (LOG_UPTO (LOG_INFO));
d78 1
a78 1
				usage (appname);
d97 1
a97 1
				usage (appname);
d101 1
a101 1
				usage (appname);
d112 1
a112 1
			usage (appname);
d178 2
a179 4
/* Print usage message. */

static void
usage(char *appname)
d181 1
a181 4
	warn ("Usage: %s [-p <UDP port #>] [-d] [-f] [-cf config-file]",
	      appname);
	error("            [-lf lease-file] [-pf pidfile] [if0 [...ifN]]");
}
d183 4
a186 2
void cleanup ()
{
@


1.4
log
@don't print half a terminal worth of vixie advertising at startup and in usage
@
text
@d1 2
a2 1
/*	$OpenBSD$ */
a55 3
#ifdef DEBUG
int log_perror = -1;
#else
a56 2
#endif

a58 1
char *path_dhcpd_pid = _PATH_DHCPD_PID;
a67 6
#ifndef DEBUG
	int pidfilewritten = 0;
	int pid;
	char pbuf [20];
	int daemon = 1;
#endif
d69 1
d97 1
a97 3
#ifndef DEBUG
			daemon = 0;
#endif
d99 1
a99 3
#ifndef DEBUG
			daemon = 0;
#endif
a104 4
		} else if (!strcmp (argv [i], "-pf")) {
			if (++i == argc)
				usage (appname);
			path_dhcpd_pid = argv [i];
d111 1
a111 3
#ifndef DEBUG
			daemon = 0;
#endif
d170 3
a172 63
#ifndef DEBUG
	if (daemon) {
		/* First part of becoming a daemon... */
		if ((pid = fork ()) == -1)
			error ("Can't fork daemon: %m");
		else if (pid)
			exit (0);
	}

	/* Read previous pid file. */
	if ((i = open (path_dhcpd_pid, O_RDONLY)) != -1) {
		status = read (i, pbuf, (sizeof pbuf) - 1);
		close (i);
		pbuf [status] = 0;
		pid = atoi (pbuf);

		/* If the previous server process is not still running,
		   write a new pid file immediately. */
		if (pid && (pid == getpid () || kill (pid, 0) == -1)) {
			unlink (path_dhcpd_pid);
			if ((i = open (path_dhcpd_pid,
				       O_WRONLY | O_CREAT, 0640)) != -1) {
				snprintf (pbuf, sizeof(pbuf), "%d\n",
				  (int)getpid ());
				write (i, pbuf, strlen (pbuf));
				close (i);
				pidfilewritten = 1;
			}
		} else
			error ("There's already a DHCP server running.\n");
	}

	/* If we were requested to log to stdout on the command line,
	   keep doing so; otherwise, stop. */
	if (log_perror == -1)
		log_perror = 1;
	else
		log_perror = 0;

	if (daemon) {
		/* Become session leader and get pid... */
		close (0);
		close (1);
		close (2);
		pid = setsid ();
	}

	/* If we didn't write the pid file earlier because we found a
	   process running the logged pid, but we made it to here,
	   meaning nothing is listening on the bootp port, then write
	   the pid file out - what's in it now is bogus anyway. */
	if (!pidfilewritten) {
		unlink (path_dhcpd_pid);
		if ((i = open (path_dhcpd_pid,
			       O_WRONLY | O_CREAT, 0640)) != -1) {
			snprintf (pbuf, sizeof(pbuf), "%d\n",
			  (int)getpid ());
			write (i, pbuf, strlen (pbuf));
			close (i);
			pidfilewritten = 1;
		}
	}
#endif /* !DEBUG */
@


1.3
log
@more crap bites the dust
@
text
@d1 1
a1 4
/* dhcpd.c

   DHCP Server Daemon. */

a40 7
static char copyright[] =
"Copyright 1995, 1996, 1997, 1998, 1999 The Internet Software Consortium.";
static char arr [] = "All rights reserved.";
static char message [] = "Internet Software Consortium DHCP Server";
static char contrib [] = "Please contribute if you find this software useful.";
static char url [] = "For info, please visit http://www.isc.org/dhcp-contrib.html";

a41 1
#include "version.h"
d154 1
a154 9
	if (!quiet) {
		note ("%s %s", message, DHCP_VERSION);
		note ("%s", copyright);
		note ("%s", arr);
		note ("%s", "");
		note ("%s", contrib);
		note ("%s", url);
		note ("%s", "");
	} else
a164 1
#ifndef __CYGWIN32__ /* XXX */
a165 1
#endif
d168 1
a168 1
	remote_port = htons (ntohs (local_port) + 1);
d182 1
a182 1
	db_startup ();
d185 1
a185 1
	discover_interfaces (DISCOVER_SERVER);
d258 1
a258 1
	dispatch ();
d261 1
a261 1
	return 0;
d266 2
a267 2
static void usage (appname)
	char *appname;
a268 8
	note ("%s", message);
	note ("%s", copyright);
	note ("%s", arr);
	note ("%s", "");
	note ("%s", contrib);
	note ("%s", url);
	note ("%s", "");

@


1.2
log
@time_t and kill a few dumb defines
@
text
@d54 1
a54 1
static void usage PROTO ((char *));
d209 1
a209 1
	icmp_startup (1, lease_pinged);
@


1.1
log
@may the whacking begin
@
text
@d56 1
a56 1
TIME cur_time;
d192 1
a192 1
	GET_TIME (&cur_time);
@

