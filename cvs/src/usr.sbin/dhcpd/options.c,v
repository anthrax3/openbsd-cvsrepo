head	1.35;
access;
symbols
	OPENBSD_6_1:1.35.0.4
	OPENBSD_6_1_BASE:1.35
	OPENBSD_6_0:1.30.0.4
	OPENBSD_6_0_BASE:1.30
	OPENBSD_5_9:1.30.0.2
	OPENBSD_5_9_BASE:1.30
	OPENBSD_5_8:1.29.0.4
	OPENBSD_5_8_BASE:1.29
	OPENBSD_5_7:1.28.0.2
	OPENBSD_5_7_BASE:1.28
	OPENBSD_5_6:1.28.0.4
	OPENBSD_5_6_BASE:1.28
	OPENBSD_5_5:1.26.0.20
	OPENBSD_5_5_BASE:1.26
	OPENBSD_5_4:1.26.0.16
	OPENBSD_5_4_BASE:1.26
	OPENBSD_5_3:1.26.0.14
	OPENBSD_5_3_BASE:1.26
	OPENBSD_5_2:1.26.0.12
	OPENBSD_5_2_BASE:1.26
	OPENBSD_5_1_BASE:1.26
	OPENBSD_5_1:1.26.0.10
	OPENBSD_5_0:1.26.0.8
	OPENBSD_5_0_BASE:1.26
	OPENBSD_4_9:1.26.0.6
	OPENBSD_4_9_BASE:1.26
	OPENBSD_4_8:1.26.0.4
	OPENBSD_4_8_BASE:1.26
	OPENBSD_4_7:1.26.0.2
	OPENBSD_4_7_BASE:1.26
	OPENBSD_4_6:1.24.0.6
	OPENBSD_4_6_BASE:1.24
	OPENBSD_4_5:1.24.0.2
	OPENBSD_4_5_BASE:1.24
	OPENBSD_4_4:1.21.0.2
	OPENBSD_4_4_BASE:1.21
	OPENBSD_4_3:1.20.0.2
	OPENBSD_4_3_BASE:1.20
	OPENBSD_4_2:1.8.0.4
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.8.0.2
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.6.0.8
	OPENBSD_4_0_BASE:1.6
	OPENBSD_3_9:1.6.0.6
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.6.0.4
	OPENBSD_3_8_BASE:1.6
	OPENBSD_3_7:1.6.0.2
	OPENBSD_3_7_BASE:1.6
	OPENBSD_3_6:1.4.0.2
	OPENBSD_3_6_BASE:1.4;
locks; strict;
comment	@ * @;


1.35
date	2017.02.13.22.33.39;	author krw;	state Exp;
branches;
next	1.34;
commitid	aD6aChUv7GEv3CLZ;

1.34
date	2017.02.13.19.13.14;	author krw;	state Exp;
branches;
next	1.33;
commitid	syYFt6P4XI7prXRF;

1.33
date	2016.11.15.10.49.37;	author mestre;	state Exp;
branches;
next	1.32;
commitid	MJxFs9s3mqdgRyMT;

1.32
date	2016.10.04.22.47.51;	author krw;	state Exp;
branches;
next	1.31;
commitid	PTCmBSXhdCRLXLlF;

1.31
date	2016.08.05.14.02.23;	author krw;	state Exp;
branches;
next	1.30;
commitid	EtSNZfEccLQuVs0q;

1.30
date	2016.02.06.23.50.10;	author krw;	state Exp;
branches;
next	1.29;
commitid	8GMcSAoPYCa1rXN3;

1.29
date	2015.06.27.14.29.39;	author krw;	state Exp;
branches;
next	1.28;
commitid	OL4hDjUwJd9TCupA;

1.28
date	2014.07.28.16.45.35;	author tobias;	state Exp;
branches;
next	1.27;
commitid	WPRdWQrx6O0hbxVT;

1.27
date	2014.07.11.09.42.27;	author yasuoka;	state Exp;
branches;
next	1.26;
commitid	7SRccEu66mJK3N60;

1.26
date	2010.01.02.04.21.16;	author krw;	state Exp;
branches
	1.26.16.1
	1.26.20.1;
next	1.25;

1.25
date	2010.01.01.20.46.20;	author krw;	state Exp;
branches;
next	1.24;

1.24
date	2008.11.14.02.00.08;	author krw;	state Exp;
branches;
next	1.23;

1.23
date	2008.11.08.01.42.24;	author krw;	state Exp;
branches;
next	1.22;

1.22
date	2008.09.10.00.22.49;	author reyk;	state Exp;
branches;
next	1.21;

1.21
date	2008.04.16.00.36.48;	author krw;	state Exp;
branches
	1.21.2.1;
next	1.20;

1.20
date	2008.01.18.20.14.03;	author krw;	state Exp;
branches;
next	1.19;

1.19
date	2007.10.29.16.51.02;	author krw;	state Exp;
branches;
next	1.18;

1.18
date	2007.10.27.14.47.38;	author krw;	state Exp;
branches;
next	1.17;

1.17
date	2007.10.21.13.12.31;	author krw;	state Exp;
branches;
next	1.16;

1.16
date	2007.10.21.01.08.17;	author krw;	state Exp;
branches;
next	1.15;

1.15
date	2007.10.21.00.39.28;	author krw;	state Exp;
branches;
next	1.14;

1.14
date	2007.10.19.15.52.20;	author krw;	state Exp;
branches;
next	1.13;

1.13
date	2007.10.19.15.43.33;	author krw;	state Exp;
branches;
next	1.12;

1.12
date	2007.10.19.15.34.55;	author krw;	state Exp;
branches;
next	1.11;

1.11
date	2007.10.19.15.25.07;	author krw;	state Exp;
branches;
next	1.10;

1.10
date	2007.10.19.15.16.34;	author krw;	state Exp;
branches;
next	1.9;

1.9
date	2007.10.09.03.17.34;	author krw;	state Exp;
branches;
next	1.8;

1.8
date	2006.12.15.14.09.13;	author stevesk;	state Exp;
branches
	1.8.2.1
	1.8.4.1;
next	1.7;

1.7
date	2006.12.12.19.38.55;	author stevesk;	state Exp;
branches;
next	1.6;

1.6
date	2004.09.21.04.07.04;	author david;	state Exp;
branches
	1.6.8.1;
next	1.5;

1.5
date	2004.09.16.18.35.43;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2004.05.04.21.25.27;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2004.05.04.20.28.40;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2004.04.14.01.27.49;	author henning;	state Exp;
branches;
next	1.1;

1.1
date	2004.04.13.23.41.48;	author henning;	state Exp;
branches;
next	;

1.6.8.1
date	2007.10.09.16.44.55;	author ckuethe;	state Exp;
branches;
next	;

1.8.2.1
date	2007.10.09.16.46.31;	author ckuethe;	state Exp;
branches;
next	;

1.8.4.1
date	2007.10.10.06.10.27;	author ckuethe;	state Exp;
branches;
next	;

1.21.2.1
date	2008.11.16.06.04.11;	author brad;	state Exp;
branches;
next	;

1.26.16.1
date	2014.07.29.18.23.07;	author tobias;	state Exp;
branches;
next	;
commitid	1AkdeqSw4ibPIUNI;

1.26.20.1
date	2014.07.29.18.21.30;	author tobias;	state Exp;
branches;
next	;
commitid	oaTl3MejDkG0oN5W;


desc
@@


1.35
log
@Adjust some long lines.
@
text
@/*	$OpenBSD: options.c,v 1.34 2017/02/13 19:13:14 krw Exp $	*/

/* DHCP options parsing and reassembly. */

/*
 * Copyright (c) 1995, 1996, 1997, 1998 The Internet Software Consortium.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of The Internet Software Consortium nor the names
 *    of its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INTERNET SOFTWARE CONSORTIUM AND
 * CONTRIBUTORS ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE INTERNET SOFTWARE CONSORTIUM OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This software has been written for the Internet Software Consortium
 * by Ted Lemon <mellon@@fugue.com> in cooperation with Vixie
 * Enterprises.  To learn more about the Internet Software Consortium,
 * see ``http://www.vix.com/isc''.  To learn more about Vixie
 * Enterprises, see ``http://www.vix.com''.
 */

#include <sys/types.h>
#include <sys/socket.h>

#include <net/if.h>

#include <netinet/in.h>

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "dhcp.h"
#include "tree.h"
#include "dhcpd.h"
#include "log.h"

int bad_options = 0;
int bad_options_max = 5;

void	parse_options(struct packet *);
void	parse_option_buffer(struct packet *, unsigned char *, int);
void	create_priority_list(unsigned char *, unsigned char *, int);
int	store_option_fragment(unsigned char *, int, unsigned char,
	    int, unsigned char *);
int	store_options(unsigned char *, int, struct tree_cache **,
	    unsigned char *, int, int);


/*
 * Parse all available options out of the specified packet.
 */
void
parse_options(struct packet *packet)
{
	/* Initially, zero all option pointers. */
	memset(packet->options, 0, sizeof(packet->options));

	/* If we don't see the magic cookie, there's nothing to parse. */
	if (memcmp(packet->raw->options, DHCP_OPTIONS_COOKIE, 4)) {
		packet->options_valid = 0;
		return;
	}

	/*
	 * Go through the options field, up to the end of the packet or
	 * the End field.
	 */
	parse_option_buffer(packet, &packet->raw->options[4],
	    packet->packet_length - DHCP_FIXED_NON_UDP - 4);

	/*
	 * If we parsed a DHCP Option Overload option, parse more
	 * options out of the buffer(s) containing them.
	 */
	if (packet->options_valid &&
	    packet->options[DHO_DHCP_OPTION_OVERLOAD].data) {
		if (packet->options[DHO_DHCP_OPTION_OVERLOAD].data[0] & 1)
			parse_option_buffer(packet,
			    (unsigned char *)packet->raw->file,
			    sizeof(packet->raw->file));
		if (packet->options[DHO_DHCP_OPTION_OVERLOAD].data[0] & 2)
			parse_option_buffer(packet,
			    (unsigned char *)packet->raw->sname,
			    sizeof(packet->raw->sname));
	}
}

/*
 * Parse options out of the specified buffer, storing addresses of
 * option values in packet->options and setting packet->options_valid if
 * no errors are encountered.
 */
void
parse_option_buffer(struct packet *packet,
    unsigned char *buffer, int length)
{
	unsigned char *s, *t;
	unsigned char *end = buffer + length;
	int len;
	int code;

	for (s = buffer; *s != DHO_END && s < end; ) {
		code = s[0];

		/* Pad options don't have a length - just skip them. */
		if (code == DHO_PAD) {
			s++;
			continue;
		}
		if (s + 2 > end) {
			len = 65536;
			goto bogus;
		}

		/*
		 * All other fields (except end, see above) have a
		 * one-byte length.
		 */
		len = s[1];

		/*
		 * If the length is outrageous, silently skip the rest,
		 * and mark the packet bad. Unfortunately some crappy
		 * dhcp servers always seem to give us garbage on the
		 * end of a packet. so rather than keep refusing, give
		 * up and try to take one after seeing a few without
		 * anything good.
		 */
		if (s + len + 2 > end) {
		    bogus:
			bad_options++;
			log_warnx("option %s (%d) %s.",
			    dhcp_options[code].name, len,
			    "larger than buffer");
			if (bad_options == bad_options_max) {
				packet->options_valid = 1;
				bad_options = 0;
				log_warnx("Many bogus options seen in "
				    "offers.");
				log_warnx("Taking this offer in spite of "
				    "bogus");
				log_warnx("options - hope for the best!");
			} else {
				log_warnx("rejecting bogus offer.");
				packet->options_valid = 0;
			}
			return;
		}
		/*
		 * If we haven't seen this option before, just make
		 * space for it and copy it there.
		 */
		if (!packet->options[code].data) {
			t = calloc(1, len + 1);
			if (!t)
				fatalx("Can't allocate storage for option %s.",
				    dhcp_options[code].name);
			/*
			 * Copy and NUL-terminate the option (in case
			 * it's an ASCII string).
			 */
			memcpy(t, &s[2], len);
			t[len] = 0;
			packet->options[code].len = len;
			packet->options[code].data = t;
		} else {
			/*
			 * If it's a repeat, concatenate it to whatever
			 * we last saw.   This is really only required
			 * for clients, but what the heck...
			 */
			t = calloc(1, len + packet->options[code].len + 1);
			if (!t)
				fatalx("Can't expand storage for option %s.",
				    dhcp_options[code].name);
			memcpy(t, packet->options[code].data,
				packet->options[code].len);
			memcpy(t + packet->options[code].len,
				&s[2], len);
			packet->options[code].len += len;
			t[packet->options[code].len] = 0;
			free(packet->options[code].data);
			packet->options[code].data = t;
		}
		s += len + 2;
	}
	packet->options_valid = 1;
}

/*
 * Fill priority_list with a complete list of DHCP options sorted by
 * priority. i.e.
 *     1) Mandatory options.
 *     2) Options from prl that are not already present.
 *     3) Options from the default list that are not already present.
 */
void
create_priority_list(unsigned char *priority_list, unsigned char *prl,
    int prl_len)
{
	unsigned char stored_list[256];
	int i, priority_len = 0;

	/* clear stored_list, priority_list should be cleared before */
	memset(&stored_list, 0, sizeof(stored_list));

	/* Some options we don't want on the priority list. */
	stored_list[DHO_PAD] = 1;
	stored_list[DHO_END] = 1;

	/* Mandatory options. */
	for(i = 0; dhcp_option_default_priority_list[i] != DHO_END; i++) {
		priority_list[priority_len++] =
		    dhcp_option_default_priority_list[i];
		stored_list[dhcp_option_default_priority_list[i]] = 1;
	}

	/* Supplied priority list. */
	if (!prl)
		prl_len = 0;
	for(i = 0; i < prl_len; i++) {
		/* CLASSLESS routes always have priority, sayeth RFC 3442. */
		if (prl[i] == DHO_CLASSLESS_STATIC_ROUTES ||
		    prl[i] == DHO_CLASSLESS_MS_STATIC_ROUTES) {
			priority_list[priority_len++] = prl[i];
			stored_list[prl[i]] = 1;
		}
	}
	for(i = 0; i < prl_len; i++) {
		if (stored_list[prl[i]])
			continue;
		priority_list[priority_len++] = prl[i];
		stored_list[prl[i]] = 1;
	}

	/* Default priority list. */
	prl = dhcp_option_default_priority_list;
	for(i = 0; i < 256; i++) {
		if (stored_list[prl[i]])
			continue;
		priority_list[priority_len++] = prl[i];
		stored_list[prl[i]] = 1;
	}
}
/*
 * cons options into a big buffer, and then split them out into the
 * three separate buffers if needed.  This allows us to cons up a set of
 * vendor options using the same routine.
 */
int
cons_options(struct packet *inpacket, struct dhcp_packet *outpacket,
    int mms, struct tree_cache **options,
    int overload, /* Overload flags that may be set. */
    int terminate, int bootpp, u_int8_t *prl, int prl_len)
{
	unsigned char priority_list[256];
	unsigned char buffer[4096];	/* Really big buffer... */
	int bufix, main_buffer_size, option_size;

	/*
	 * If the client has provided a maximum DHCP message size, use
	 * that; otherwise, if it's BOOTP, only 64 bytes; otherwise use
	 * up to the minimum IP MTU size (576 bytes).
	 *
	 * XXX if a BOOTP client specifies a max message size, we will
	 * honor it.
	 */
	if (!mms &&
	    inpacket &&
	    inpacket->options[DHO_DHCP_MAX_MESSAGE_SIZE].data &&
	    (inpacket->options[DHO_DHCP_MAX_MESSAGE_SIZE].len >=
	    sizeof(u_int16_t))) {
		mms = getUShort(
		    inpacket->options[DHO_DHCP_MAX_MESSAGE_SIZE].data);
	}

	if (mms) {
		if (mms < 576)
			mms = 576;	/* mms must be >= minimum IP MTU */
		main_buffer_size = mms - DHCP_FIXED_LEN;
	} else if (bootpp)
		main_buffer_size = 64;
	else
		main_buffer_size = 576 - DHCP_FIXED_LEN;

	if (main_buffer_size > sizeof(outpacket->options))
		main_buffer_size = sizeof(outpacket->options);

	/*
	 * Initialize the available buffers, some or all of which may not be
	 * used.
	 */
	memset(outpacket->options, DHO_PAD, sizeof(outpacket->options));
	if (overload & 1)
		memset(outpacket->file, DHO_PAD, DHCP_FILE_LEN);
	if (overload & 2)
		memset(outpacket->sname, DHO_PAD, DHCP_SNAME_LEN);
	if (bootpp)
		overload = 0; /* Don't use overload buffers for bootp! */

	/*
	 * Get complete list of possible options in priority order. Use the
	 * list provided in the options. Lacking that use the list provided by
	 * prl. If that is not available just use the default list.
	 */
	memset(&priority_list, 0, sizeof(priority_list));
	if (inpacket &&
	    inpacket->options[DHO_DHCP_PARAMETER_REQUEST_LIST].data)
		create_priority_list(priority_list,
		    inpacket->options[DHO_DHCP_PARAMETER_REQUEST_LIST].data,
		    inpacket->options[DHO_DHCP_PARAMETER_REQUEST_LIST].len);
	else if (prl)
		create_priority_list(priority_list, prl, prl_len);
	else
		create_priority_list(priority_list, NULL, 0);

	/*
	 * Copy the options into the big buffer, including leading cookie and
	 * DHCP_OVERLOAD_OPTION, and DHO_END if it fits. All unused space will
	 * be set to DHO_PAD
	 */
	option_size = store_options(buffer, main_buffer_size, options,
	    priority_list, overload, terminate);
	if (option_size == 0)
		return (DHCP_FIXED_NON_UDP);

	/* Copy the main buffer. */
	memcpy(&outpacket->options[0], buffer, main_buffer_size);
	if (option_size <= main_buffer_size)
		return (DHCP_FIXED_NON_UDP + option_size);

	/* Copy the overflow buffers. */
	bufix = main_buffer_size;
	if (overload & 1) {
		memcpy(outpacket->file, &buffer[bufix], DHCP_FILE_LEN);
		bufix += DHCP_FILE_LEN;
	}
	if (overload & 2)
		memcpy(outpacket->sname, &buffer[bufix], DHCP_SNAME_LEN);

	return (DHCP_FIXED_NON_UDP + main_buffer_size);
}

/*
 * Store a <code><length><data> fragment in buffer. Return the number of
 * characters used. Return 0 if no data could be stored.
 */
int
store_option_fragment(unsigned char *buffer, int buffer_size,
    unsigned char code, int length, unsigned char *data)
{
	buffer_size -= 2; /* Space for option code and option length. */

	if (buffer_size < 1)
		return (0);

	if (buffer_size > 255)
		buffer_size = 255;
	if (length > buffer_size)
		length = buffer_size;

	buffer[0] = code;
	buffer[1] = length;

	memcpy(&buffer[2], data, length);

	return (length + 2);
}

/*
 * Store all the requested options into the requested buffer. Insert the
 * required cookie, DHO_DHCP_OPTION_OVERLOAD options and append a DHO_END if
 * if fits. Ensure all buffer space is set to DHO_PAD if unused.
 */
int
store_options(unsigned char *buffer, int main_buffer_size,
    struct tree_cache **options, unsigned char *priority_list, int overload,
    int terminate)
{
	int buflen, code, cutoff, i, incr, ix, length, optstart, overflow;
	int second_cutoff;
	int bufix = 0;
	int stored_classless = 0;

	overload &= 3; /* Only consider valid bits. */

	cutoff = main_buffer_size;
	second_cutoff = cutoff + ((overload & 1) ? DHCP_FILE_LEN : 0);
	buflen = second_cutoff + ((overload & 2) ? DHCP_SNAME_LEN : 0);

	memset(buffer, DHO_PAD, buflen);
	memcpy(buffer, DHCP_OPTIONS_COOKIE, 4);

	if (overload)
		bufix = 7; /* Reserve space for DHO_DHCP_OPTION_OVERLOAD. */
	else
		bufix = 4;

	/*
	 * Store options in the order they appear in the priority list.
	 */
	for (i = 0; i < 256; i++) {
		/* Code for next option to try to store. */
		code = priority_list[i];
		if (code == DHO_PAD || code == DHO_END)
			continue;

		if (!options[code] || !tree_evaluate(options[code]))
			continue;

		/*
		 * RFC 3442 says:
		 *
		 * When a DHCP client requests the Classless Static
		 * Routes option and also requests either or both of the
		 * Router option and the Static Routes option, and the
		 * DHCP server is sending Classless Static Routes options
		 * to that client, the server SHOULD NOT include the
		 * Router or Static Routes options.
		 */
		if ((code == DHO_ROUTERS || code == DHO_STATIC_ROUTES) &&
		    stored_classless)
			continue;

		/* We should now have a constant length for the option. */
		length = options[code]->len;

		/* Try to store the option. */
		optstart = bufix;
		ix = 0;
		while (length) {
			incr = store_option_fragment(&buffer[bufix],
			    cutoff - bufix, code, length,
			    options[code]->value + ix);

			if (incr > 0) {
				bufix += incr;
				length -= incr - 2;
				ix += incr - 2;
				continue;
			}

			/*
			 * No fragment could be stored in the space before the
			 * cutoff. Fill the unusable space with DHO_PAD and
			 * move cutoff for another attempt.
			 */
			memset(&buffer[bufix], DHO_PAD, cutoff - bufix);
			bufix = cutoff;
			if (cutoff < second_cutoff)
				cutoff = second_cutoff;
			else if (cutoff < buflen)
				cutoff = buflen;
			else
				break;
		}

		if (length > 0) {
zapfrags:
			memset(&buffer[optstart], DHO_PAD, buflen - optstart);
			bufix = optstart;
		} else if (terminate && dhcp_options[code].format[0] == 't') {
			if (bufix < cutoff)
				buffer[bufix++] = '\0';
			else
				goto zapfrags;
		}
		if (code == DHO_CLASSLESS_STATIC_ROUTES ||
		    code == DHO_CLASSLESS_MS_STATIC_ROUTES)
			stored_classless = 1;
	}

	if (bufix == (4 + (overload ? 3 : 0)))
		/* Didn't manage to store any options. */
		return (0);

	if (bufix < buflen)
		buffer[bufix++] = DHO_END;

	/* Fill in overload option value based on space used for options. */
	if (overload) {
		overflow = bufix - main_buffer_size;
		if (overflow > 0) {
			buffer[4] = DHO_DHCP_OPTION_OVERLOAD;
			buffer[5] = 1;
			if (overload & 1) {
				buffer[6] |= 1;
				overflow -= DHCP_FILE_LEN;
			}
			if ((overload & 2) && overflow > 0)
				buffer[6] |= 2;
		} else {
			/*
			 * Compact buffer to eliminate the unused
			 * DHO_DHCP_OPTION_OVERLOAD option. Some clients
			 * choke on DHO_PAD options there.
			 */
			memmove(&buffer[4], &buffer[7], buflen - 7);
			bufix -= 3;
			memset(&buffer[bufix], DHO_PAD, 3);
		}
	}

	return (bufix);
}

void
do_packet(struct interface_info *interface, struct dhcp_packet *packet,
    int len, unsigned int from_port, struct iaddr from, struct hardware *hfrom)
{
	struct packet tp;
	int i;

	if (packet->hlen > sizeof(packet->chaddr)) {
		log_info("Discarding packet with invalid hlen.");
		return;
	}

	memset(&tp, 0, sizeof(tp));
	tp.raw = packet;
	tp.packet_length = len;
	tp.client_port = from_port;
	tp.client_addr = from;
	tp.interface = interface;
	tp.haddr = hfrom;

	parse_options(&tp);
	if (tp.options_valid &&
	    tp.options[DHO_DHCP_MESSAGE_TYPE].data)
		tp.packet_type = tp.options[DHO_DHCP_MESSAGE_TYPE].data[0];

	if (tp.packet_type)
		dhcp(&tp, interface->is_udpsock);
	else
		bootp(&tp);

	/* Free the data associated with the options. */
	for (i = 0; i < 256; i++)
		free(tp.options[i].data);
}
@


1.34
log
@Switch from old errwarn.c logging to shiny new log.[ch].

ok benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.33 2016/11/15 10:49:37 mestre Exp $	*/
d160 4
a163 2
				log_warnx("Many bogus options seen in offers.");
				log_warnx("Taking this offer in spite of bogus");
d329 2
a330 1
	if (inpacket && inpacket->options[DHO_DHCP_PARAMETER_REQUEST_LIST].data)
@


1.33
log
@Replace bzero(3) with memset(3)

"Looks good" to deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.32 2016/10/04 22:47:51 krw Exp $	*/
d57 1
d154 1
a154 1
			warning("option %s (%d) %s.",
d160 3
a162 3
				warning("Many bogus options seen in offers.");
				warning("Taking this offer in spite of bogus");
				warning("options - hope for the best!");
d164 1
a164 1
				warning("rejecting bogus offer.");
d176 1
a176 1
				error("Can't allocate storage for option %s.",
d194 1
a194 1
				error("Can't expand storage for option %s.",
d534 1
a534 1
		note("Discarding packet with invalid hlen.");
@


1.32
log
@Zap stray whitespace.
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.31 2016/08/05 14:02:23 krw Exp $	*/
d224 1
a224 1
	bzero(&stored_list, sizeof(stored_list));
d325 1
a325 1
	bzero(&priority_list, sizeof(priority_list));
@


1.31
log
@Don't leak the option data of non-DHCPINFORM messages received on
the udp socket.

Found by David Carlier.

ok yasuoka@@
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.30 2016/02/06 23:50:10 krw Exp $	*/
d251 1
a251 1
		priority_list[priority_len++] = prl[i];	
d253 1
a253 1
	}	
d260 1
a260 1
		priority_list[priority_len++] = prl[i];	
@


1.30
log
@Eliminate #include inside *.h files and include only needed headers in
each *.c file.

Inspired by mention of header silliness by Edgar Pettijohn and mmcc@@
on tech@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.29 2015/06/27 14:29:39 krw Exp $	*/
a549 7
	if (interface->is_udpsock) {
		if (tp.packet_type != DHCPINFORM) {
			note("Unable to handle a DHCP message type=%d on UDP "
			    "socket", tp.packet_type);
			return;
		}
	}
d551 1
a551 1
		dhcp(&tp);
@


1.29
log
@Do not send routers (option 3) or static routes (option 33) when
classless static routes (option 121, 249) are sent. RFC 3442 says
servers SHOULD NOT send those options.

This avoids confusing clients who fail to ignore the routers or
static routes options in the presence of classless static routes
options. RFC 3442 says clients MUST ignore those options.

Incorrect behavior in MS and Linux clients reported by Juan on
misc@@.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.28 2014/07/28 16:45:35 tobias Exp $	*/
d43 2
a44 1
#include <ctype.h>
d46 10
@


1.28
log
@Fix memory exhaustion occurring on DHCP options with 0 length.

halex@@ and krw@@ pointed out that a NULL check before free can go, too.

ok deraadt@@, halex@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.27 2014/07/11 09:42:27 yasuoka Exp $	*/
d230 8
d390 1
d418 14
d475 3
@


1.27
log
@Add -u option to bind UDP port as a socket to answer DHCPINFORM from
the clients on non ethernet interfaces (eg. tun(4) or pppx(4)).

input krw
ok krw
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.26 2010/01/02 04:21:16 krw Exp $	*/
d527 1
a527 2
		if (tp.options[i].len && tp.options[i].data)
			free(tp.options[i].data);
@


1.26
log
@Eliminate all uses of dmalloc() where the returned pointer
is checked for NULL and a specific error/warning issued. Add
two such manual warning/error checks and kill those dmalloc
calls. And then there were none, so kill dmalloc(). Whew.
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.25 2010/01/01 20:46:20 krw Exp $	*/
d512 8
@


1.26.16.1
log
@Fix memory exhaustion occurring on DHCP options with 0 length.

halex@@ and krw@@ pointed out that a NULL check before free can go, too.

ok deraadt@@, halex@@, krw@@, jasper@@
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.26 2010/01/02 04:21:16 krw Exp $	*/
d519 2
a520 1
		free(tp.options[i].data);
@


1.26.20.1
log
@Fix memory exhaustion occurring on DHCP options with 0 length.

halex@@ and krw@@ pointed out that a NULL check before free can go, too.

ok deraadt@@, halex@@, krw@@, jasper@@
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.26 2010/01/02 04:21:16 krw Exp $	*/
d519 2
a520 1
		free(tp.options[i].data);
@


1.25
log
@Eliminate all uses of dfree() where the pointer is either dereferenced
immediately before the use or the pointer is checked for NULL before
the call. And then there were none, so kill dfree().
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.24 2008/11/14 02:00:08 krw Exp $	*/
d162 2
a163 1
			if (!(t = dmalloc(len + 1, "parse_option_buffer")))
d180 1
a180 2
			t = dmalloc(len + packet->options[code].len + 1,
			    "parse_option_buffer");
@


1.24
log
@Sigh. Some clients can't handle three DHO_PAD options holding space
for an unused overload option. Noticed by mk@@ when netbooting his
G4 mac mini.

So compact the options by shifting them over the unused option and
filling the end by DHO_PAD.

Tested by mk@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.23 2008/11/08 01:42:24 krw Exp $	*/
d190 1
a190 2
			dfree(packet->options[code].data,
			    "parse_option_buffer");
d520 1
a520 1
			dfree(tp.options[i].data, "do_packet");
@


1.23
log
@Some clients don't parse a DHO_DHCP_OPTION_OVERLOAD option the way
I expected. They object if there are no bits set in the option
value. So just use DHO_PAD in the reserved space unless at least
one of the bits is set.

Various versions tested by Tobias Ulmer on OpenSolaris, matthieu@@
on busybox's DHCP client, and Uwe Dippel on Solaris. All of which
failed before.
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.22 2008/09/10 00:22:49 reyk Exp $	*/
d463 20
a482 7
	overflow = bufix - main_buffer_size;
	if (overload && overflow > 0) {
		buffer[4] = DHO_DHCP_OPTION_OVERLOAD;
		buffer[5] = 1;
		if (overload & 1) {
			buffer[6] |= 1;
			overflow -= DHCP_FILE_LEN;
a483 2
		if ((overload & 2) && overflow > 0)
			buffer[6] |= 2;
@


1.22
log
@bzero' the option buffer with the correct buffer size.  this fixes
incomplete buffer initialization and possible incorrect option
handling.

Thanks to Nick Bender
ok krw@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.21 2008/04/16 00:36:48 krw Exp $	*/
d384 2
d389 1
a390 1

a391 1
	bufix = 4;
d393 4
a396 5
	if (overload) {
		buffer[bufix++] = DHO_DHCP_OPTION_OVERLOAD;
		buffer[bufix++] = 1;
		buffer[bufix++] = 0; /* Note: value is at index [6] */
	}
d463 4
a466 2
	if (overload && bufix > main_buffer_size) {
		overflow = bufix - main_buffer_size;
d468 1
a468 1
			buffer[6] = 1;
d471 1
a471 1
		if (overflow > 0)
@


1.21
log
@Redo/clarify the logic for storing options in the various buffers.

While there, bail out quickly if no options can be stored, and avoid
overflow buffers if building a bootp reply.

Henning looked and didn't get upset. millert@@ tested it for a few
days and liked the look of it. canacar@@ glanced at it.
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.20 2008/01/18 20:14:03 krw Exp $	*/
d210 1
a210 1
	int stored_list[256];
d213 2
a214 2
	bzero(stored_list, 256);
	bzero(priority_list, 256);
d307 1
@


1.21.2.1
log
@rev 1.24
Sigh. Some clients can't handle three DHO_PAD options holding space
for an unused overload option. Noticed by mk@@ when netbooting his
G4 mac mini.

So compact the options by shifting them over the unused option and
filling the end by DHO_PAD.

rev 1.23
Some clients don't parse a DHO_DHCP_OPTION_OVERLOAD option the way
I expected. They object if there are no bits set in the option
value. So just use DHO_PAD in the reserved space unless at least
one of the bits is set.

rev 1.22
bzero' the option buffer with the correct buffer size.  this fixes
incomplete buffer initialization and possible incorrect option
handling.
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.21 2008/04/16 00:36:48 krw Exp $	*/
d210 1
a210 1
	unsigned char stored_list[256];
d213 2
a214 2
	/* clear stored_list, priority_list should be cleared before */
	bzero(&stored_list, sizeof(stored_list));
a306 1
	bzero(&priority_list, sizeof(priority_list));
a382 2
	overload &= 3; /* Only consider valid bits. */

d386 1
a387 1
	memset(buffer, DHO_PAD, buflen);
d389 1
d391 5
a395 4
	if (overload)
		bufix = 7; /* Reserve space for DHO_DHCP_OPTION_OVERLOAD. */
	else
		bufix = 4;
d462 1
a462 1
	if (overload) {
d464 3
a466 18
		if (overflow > 0) {
			buffer[4] = DHO_DHCP_OPTION_OVERLOAD;
			buffer[5] = 1;
			if (overload & 1) {
				buffer[6] |= 1;
				overflow -= DHCP_FILE_LEN;
			}
			if ((overload & 2) && overflow > 0)
				buffer[6] |= 2;
		} else {
			/*
			 * Compact buffer to eliminate the unused
			 * DHO_DHCP_OPTION_OVERLOAD option. Some clients
			 * choke on DHO_PAD options there.
			 */
			memmove(&buffer[4], &buffer[7], buflen - 7);
			bufix -= 3;
			memset(&buffer[bufix], DHO_PAD, 3);
d468 2
@


1.20
log
@Call store_options() with correct cutoff values, i.e. ones not 7 bytes
too large. Fixes a problem where a nicely crafted packet could crash
dhcpd. Nuke a superfluous declaration of store_options() while here.

Problem found and fix tested by Peter Hessler.

ok beck@@ millert@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.19 2007/10/29 16:51:02 krw Exp $	*/
d56 1
a56 1
	    unsigned char *, int, int, int);
d259 1
a259 3
	int main_buffer_size;
	int mainbufix, bufix;
	int option_size;
d291 12
a315 19
	/* Copy the options into the big buffer... */
	option_size = store_options(
	    buffer,
	    (main_buffer_size - 7 + ((overload & 1) ? DHCP_FILE_LEN : 0) +
		((overload & 2) ? DHCP_SNAME_LEN : 0)),
	    options, priority_list, main_buffer_size - 7,
	    (main_buffer_size - 7 + ((overload & 1) ? DHCP_FILE_LEN : 0)),
	    terminate);

	/* Initialize the buffers to be used and put the cookie up front. */
	memset(outpacket->options, DHO_PAD, sizeof(outpacket->options));
	if (overload & 1)
		memset(outpacket->file, DHO_PAD, DHCP_FILE_LEN);
	if (overload & 2)
		memset(outpacket->sname, DHO_PAD, DHCP_SNAME_LEN);

	memcpy(outpacket->options, DHCP_OPTIONS_COOKIE, 4);
	mainbufix = 4;

d317 3
a319 2
	 * If we can, just store the whole thing in the packet's option buffer
	 * and leave it at that.
d321 9
a329 21
	if (option_size <= main_buffer_size - mainbufix) {
		memcpy(&outpacket->options[mainbufix], buffer, option_size);
		mainbufix += option_size;
		if (mainbufix < main_buffer_size)
			outpacket->options[mainbufix++] = (char)DHO_END;
		return (DHCP_FIXED_NON_UDP + mainbufix);
	}

	/*
	 * We're going to have to overload. Store the overload option
	 * at the beginning.
	 */
	outpacket->options[mainbufix++] = DHO_DHCP_OPTION_OVERLOAD;
	outpacket->options[mainbufix++] = 1;
	if (option_size > main_buffer_size - mainbufix + DHCP_FILE_LEN)
		outpacket->options[mainbufix++] = 3;
	else
		outpacket->options[mainbufix++] = 1;

	bufix = main_buffer_size - mainbufix;
	memcpy(&outpacket->options[mainbufix], buffer, bufix);
d331 2
d334 2
a335 17
		mainbufix = option_size - bufix;
		if (mainbufix <= DHCP_FILE_LEN) {
			memcpy(outpacket->file, &buffer[bufix], mainbufix);
			if (mainbufix < DHCP_FILE_LEN)
				outpacket->file[mainbufix] = (char)DHO_END;
			bufix = option_size;
		} else {
			memcpy(outpacket->file, &buffer[bufix], DHCP_FILE_LEN);
			bufix += DHCP_FILE_LEN;
		}
	}

	if ((overload & 2) && option_size > bufix) {
		mainbufix = option_size - bufix;
		memcpy(outpacket->sname, &buffer[bufix], mainbufix);
		if (mainbufix < DHCP_SNAME_LEN)
			outpacket->sname[mainbufix] = (char)DHO_END;
d337 2
d370 3
a372 1
 * Store all the requested options into the requested buffer.
d375 2
a376 2
store_options(unsigned char *buffer, int buflen, struct tree_cache **options,
    unsigned char *priority_list, int first_cutoff, int second_cutoff,
d379 2
a380 2
	int code, i, incr, ix, length, optstart;
	int cutoff = first_cutoff;
d383 14
d452 18
@


1.19
log
@More tweaking of option processing, this time around the creation of
the priority list. Add create_priority_list() and use it to
consistantly merge mandatory, supplied and default option priority
lists into a reliable and complete list of options sorted by priority.
No intended functional change other than ensuring all options
available are returned.

"looks good" henning@@ "OK, fair enough" millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.18 2007/10/27 14:47:38 krw Exp $	*/
d311 2
a312 2
	    options, priority_list, main_buffer_size,
	    (main_buffer_size + ((overload & 1) ? DHCP_FILE_LEN : 0)),
@


1.18
log
@Rework option storing so the code is readable, and eliminate odd
behaviour on several edge conditions.

Feedback, suggestion & "I like the approach" millert@@
"excellent" henning@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.17 2007/10/21 13:12:31 krw Exp $	*/
d52 1
d56 1
a56 1
	    unsigned char *, int, int, int, int);
d200 47
d257 1
a257 2
	unsigned char priority_list[300];
	int priority_len;
a291 7
	/* Preload the option priority list with mandatory options. */
	priority_len = 0;
	priority_list[priority_len++] = DHO_DHCP_MESSAGE_TYPE;
	priority_list[priority_len++] = DHO_DHCP_SERVER_IDENTIFIER;
	priority_list[priority_len++] = DHO_DHCP_LEASE_TIME;
	priority_list[priority_len++] = DHO_DHCP_MESSAGE;

d293 3
a295 3
	 * If the client has provided a list of options that it wishes
	 * returned, use it to prioritize.  Otherwise, prioritize based
	 * on the default priority list.
d297 2
a298 8
	if (inpacket &&
	    inpacket->options[DHO_DHCP_PARAMETER_REQUEST_LIST].data) {
		int prlen =
		    inpacket->options[DHO_DHCP_PARAMETER_REQUEST_LIST].len;
		if (prlen + priority_len > sizeof(priority_list))
			prlen = sizeof(priority_list) - priority_len;

		memcpy(&priority_list[priority_len],
d300 5
a304 16
		    prlen);
		priority_len += prlen;
		prl = priority_list;
	} else if (prl) {
		if (prl_len + priority_len > sizeof(priority_list))
			prl_len = sizeof(priority_list) - priority_len;

		memcpy(&priority_list[priority_len], prl, prl_len);
		priority_len += prl_len;
		prl = priority_list;
	} else {
		memcpy(&priority_list[priority_len],
		    dhcp_option_default_priority_list,
		    sizeof_dhcp_option_default_priority_list);
		priority_len += sizeof_dhcp_option_default_priority_list;
	}
d311 1
a311 1
	    options, priority_list, priority_len, main_buffer_size,
d405 2
a406 2
    unsigned char *priority_list, int priority_len, int first_cutoff,
    int second_cutoff, int terminate)
a407 1
	int option_stored[256];
a411 3
	/* Zero out the stored-lengths array. */
	memset(option_stored, 0, sizeof(option_stored));

d415 1
a415 1
	for (i = 0; i < priority_len; i++) {
d418 2
d421 1
a421 2
		if (!options[code] || option_stored[code] ||
		    !tree_evaluate(options[code]))
a422 2

		option_stored[code] = 1; /* XXX Even if it's not stored? */
@


1.17
log
@Take even more care to ensure the max message size is at
least as large as the minimum IP MTU.

ok canacar@@ henning@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.16 2007/10/21 01:08:17 krw Exp $	*/
d52 2
d310 1
a310 1
			outpacket->options[mainbufix++] = DHO_END;
d352 26
d385 3
a388 4
	int option_stored[256];
	int i;
	int ix;
	int tto;
d394 1
a394 2
	 * Copy out the options in the order that they appear in the
	 * priority list...
d398 1
a398 13
		int code = priority_list[i];
		int optstart;

		/*
		 * Number of bytes left to store (some may already have
		 * been stored by a previous pass).
		 */
		int length;

		/* If no data is available for this option, skip it. */
		if (!options[code]) {
			continue;
		}
d400 2
a401 5
		/*
		 * The client could ask for things that are mandatory,
		 * in which case we should avoid storing them twice...
		 */
		if (option_stored[code])
a402 1
		option_stored[code] = 1;
d404 1
a404 3
		/* Find the value of the option... */
		if (!tree_evaluate(options[code]))
			continue;
a408 7
		/* Do we add a NUL? */
		if (terminate && dhcp_options[code].format[0] == 't') {
			length++;
			tto = 1;
		} else
			tto = 0;

d410 1
a410 8

		/*
		 * If the option's length is more than 255, we must
		 * store it in multiple hunks.   Store 255-byte hunks
		 * first.  However, in any case, if the option data will
		 * cross a buffer boundary, split it across that
		 * boundary.
		 */
a411 2

		optstart = bufix;
d413 10
a422 1
			unsigned char incr = length > 255 ? 255 : length;
d425 3
a427 3
			 * If this hunk of the buffer will cross a
			 * boundary, only go up to the boundary in this
			 * pass.
d429 7
a435 13
			if (bufix < first_cutoff &&
			    bufix + incr > first_cutoff)
				incr = first_cutoff - bufix;
			else if (bufix < second_cutoff &&
			    bufix + incr > second_cutoff)
				incr = second_cutoff - bufix;

			/*
			 * If this option is going to overflow the
			 * buffer, skip it.
			 */
			if (bufix + 2 + incr > buflen) {
				bufix = optstart;
d437 1
a437 1
			}
d439 9
a447 13
			/* Everything looks good - copy it in! */
			buffer[bufix] = code;
			buffer[bufix + 1] = incr;
			if (tto && incr == length) {
				memcpy(buffer + bufix + 2,
				    options[code]->value + ix, incr - 1);
				buffer[bufix + 2 + incr - 1] = 0;
			} else
				memcpy(buffer + bufix + 2,
				    options[code]->value + ix, incr);
			length -= incr;
			ix += incr;
			bufix += 2 + incr;
d450 1
@


1.16
log
@Last bit of (planned) tidy up in cons_options(). Join some lines,
delete some blank lines, add some other blank lines, move expressions
so calculations done only once. Eliminate extraneous ++'s.

No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.15 2007/10/21 00:39:28 krw Exp $	*/
d229 3
a233 3
	}

	if (mms)
d235 1
a235 1
	else if (bootpp)
@


1.15
log
@Tidy up, make usual case exit faster, eliminate variable. No functional
change.

ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.14 2007/10/19 15:52:20 krw Exp $	*/
d305 1
a305 2
		memcpy(&outpacket->options[mainbufix],
		    buffer, option_size);
d318 1
a318 2
	if (option_size >
	    main_buffer_size - mainbufix + DHCP_FILE_LEN)
a322 2
	memcpy(&outpacket->options[mainbufix],
	    buffer, main_buffer_size - mainbufix);
d324 2
d327 5
a331 4
		if (option_size - bufix <= DHCP_FILE_LEN) {
			memcpy(outpacket->file,
			    &buffer[bufix], option_size - bufix);
			mainbufix = option_size - bufix;
a332 2
			if (mainbufix < DHCP_FILE_LEN)
				outpacket->file[mainbufix++] = (char)DHO_END;
d334 1
a334 2
			memcpy(outpacket->file,
			    &buffer[bufix], DHCP_FILE_LEN);
d338 1
a339 3
		memcpy(outpacket->sname,
		    &buffer[bufix], option_size - bufix);

d341 1
d343 1
a343 1
			outpacket->sname[mainbufix++] = (char)DHO_END;
@


1.14
log
@Make sure bufix is updated after copying options into the first overflow
buffer. Actually use the second overflow buffer now that bufix is correct
and the test for remaining options will work correctly.

ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.13 2007/10/19 15:43:33 krw Exp $	*/
a212 1
	int length;
d301 2
a302 3
	 * If we're going to have to overload, store the overload option
	 * at the beginning.  If we can, though, just store the whole
	 * thing in the packet's option buffer and leave it at that.
d310 13
a322 3
		length = DHCP_FIXED_NON_UDP + mainbufix;
	} else {
		outpacket->options[mainbufix++] = DHO_DHCP_OPTION_OVERLOAD;
a323 5
		if (option_size >
		    main_buffer_size - mainbufix + DHCP_FILE_LEN)
			outpacket->options[mainbufix++] = 3;
		else
			outpacket->options[mainbufix++] = 1;
d325 6
a330 20
		memcpy(&outpacket->options[mainbufix],
		    buffer, main_buffer_size - mainbufix);
		bufix = main_buffer_size - mainbufix;
		length = DHCP_FIXED_NON_UDP + main_buffer_size;
		if (overload & 1) {
			if (option_size - bufix <= DHCP_FILE_LEN) {
				memcpy(outpacket->file,
				    &buffer[bufix], option_size - bufix);
				mainbufix = option_size - bufix;
				bufix = option_size;
				if (mainbufix < DHCP_FILE_LEN)
					outpacket->file[mainbufix++] = (char)DHO_END;
			} else {
				memcpy(outpacket->file,
				    &buffer[bufix], DHCP_FILE_LEN);
				bufix += DHCP_FILE_LEN;
			}
		}
		if ((overload & 2) && option_size > bufix) {
			memcpy(outpacket->sname,
a331 1

d333 7
a339 2
			if (mainbufix < DHCP_SNAME_LEN)
				outpacket->sname[mainbufix++] = (char)DHO_END;
d342 10
a351 1
	return (length);
@


1.13
log
@Be a bit more paranoid and initialize all valid options buffers with
DHO_PAD (a.k.a. 0). Eliminate manual DHO_PAD'ing after DHO_END is put
into the buffer.

ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.12 2007/10/19 15:34:55 krw Exp $	*/
d331 1
d340 1
a340 1
		if ((overload & 2) && option_size < bufix) {
@


1.12
log
@Fix obvious typos and write DHO_PAD and DHO_END into correct options overflow
buffer. Spotted by canacar@@ and others.

ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.11 2007/10/19 15:25:07 krw Exp $	*/
d291 7
a297 1
	/* Put the cookie up front... */
a332 2
				while (mainbufix < DHCP_FILE_LEN)
					outpacket->file[mainbufix++] = DHO_PAD;
a345 2
			while (mainbufix < DHCP_SNAME_LEN)
				outpacket->sname[mainbufix++] = DHO_PAD;
@


1.11
log
@Correct the value returned by cons_options in the case where overload buffers
are used. It should reflect the end of the main options buffer rather than
the start of the options copied into it.

ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.10 2007/10/19 15:16:34 krw Exp $	*/
d341 1
a341 1
				outpacket->file[mainbufix++] = (char)DHO_END;
d343 1
a343 1
				outpacket->file[mainbufix++] = DHO_PAD;
@


1.10
log
@Ensure that main_buffer_size is set to a value less than or equal to
the size of the outgoing packet's options field. Spotted by canacar@@.

ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.9 2007/10/09 03:17:34 krw Exp $	*/
d319 1
a319 1
		length = DHCP_FIXED_NON_UDP + mainbufix;
@


1.9
log
@"Minimum IP MTU" means what it says. Ensure that packets returned by
dhcpd are the minimum size or larger no matter what the client thinks
the minimum allowable size is. Found by Nahuel Riva and Gera Richarte.
Fix by millert@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.8 2006/12/15 14:09:13 stevesk Exp $	*/
d241 2
a242 2
	if (main_buffer_size > sizeof(buffer))
		main_buffer_size = sizeof(buffer);
@


1.8
log
@typo in comment
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.7 2006/12/12 19:38:55 stevesk Exp $	*/
d227 1
a227 1
	    sizeof(u_int16_t)))
d230 3
@


1.8.4.1
log
@merge fix from current, prompted by deraadt. original commit message:
"Minimum IP MTU" means what it says. Ensure that packets returned by
dhcpd are the minimum size or larger no matter what the client thinks
the minimum allowable size is. Found by Nahuel Riva and Gera Richarte.
Fix by millert@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.9 2007/10/09 03:17:34 krw Exp $	*/
d227 1
a227 1
	    sizeof(u_int16_t))) {
a229 3
		if (mms < 576)
			mms = 576;	/* mms must be >= minimum IP MTU */
	}
@


1.8.2.1
log
@merge fix from current, prompted by deraadt. original commit message:
"Minimum IP MTU" means what it says. Ensure that packets returned by
dhcpd are the minimum size or larger no matter what the client thinks
the minimum allowable size is. Found by Nahuel Riva and Gera Richarte.
Fix by millert@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.9 2007/10/09 03:17:34 krw Exp $	*/
d227 1
a227 1
	    sizeof(u_int16_t))) {
a229 3
		if (mms < 576)
			mms = 576;	/* mms must be >= minimum IP MTU */
	}
@


1.7
log
@remove unused #defines; no binary change
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.6 2004/09/21 04:07:04 david Exp $	*/
d164 1
a164 1
			 * it's an ASCII string.
@


1.6
log
@spelling fixes; ok jmc@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.5 2004/09/16 18:35:43 deraadt Exp $	*/
a44 1
#define DHCP_OPTION_DATA
@


1.6.8.1
log
@merge fix from current, prompted by deraadt. original commit message:
"Minimum IP MTU" means what it says. Ensure that packets returned by
dhcpd are the minimum size or larger no matter what the client thinks
the minimum allowable size is. Found by Nahuel Riva and Gera Richarte.
Fix by millert@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.9 2007/10/09 03:17:34 krw Exp $	*/
d228 1
a228 1
	    sizeof(u_int16_t))) {
a230 3
		if (mms < 576)
			mms = 576;	/* mms must be >= minimum IP MTU */
	}
@


1.5
log
@avoid aliasing with libc functions; ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.4 2004/05/04 21:25:27 deraadt Exp $	*/
d131 1
a131 1
		 * and mark the packet bad. Unfortuntely some crappy
@


1.4
log
@remove DEBUG_PACKET stuff; henning ok
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.3 2004/05/04 20:28:40 deraadt Exp $	*/
d140 1
a140 1
			warn("option %s (%d) %s.",
d146 3
a148 3
				warn("Many bogus options seen in offers.");
				warn("Taking this offer in spite of bogus");
				warn("options - hope for the best!");
d150 1
a150 1
				warn("rejecting bogus offer.");
d324 1
a324 1
					outpacket->file[mainbufix++] = DHO_END;
d339 1
a339 1
				outpacket->file[mainbufix++] = DHO_END;
@


1.3
log
@remove things not used, spotted by lint mostly; ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.2 2004/04/14 01:27:49 henning Exp $	*/
a458 247

#ifdef DEBUG_PACKET
/*
 * Format the specified option so that a human can easily read it.
 */
char *
pretty_print_option(unsigned int code, unsigned char *data, int len,
    int emit_commas, int emit_quotes)
{
	static char optbuf[32768]; /* XXX */
	int hunksize = 0;
	int numhunk = -1;
	int numelem = 0;
	char fmtbuf[32];
	int i, j, k;
	char *op = optbuf;
	int opleft = sizeof(optbuf);
	unsigned char *dp = data;
	struct in_addr foo;
	char comma;


	/* Code should be between 0 and 255. */
	if (code > 255)
		error("pretty_print_option: bad code %d\n", code);

	if (emit_commas)
		comma = ',';
	else
		comma = ' ';

	/* Figure out the size of the data. */
	for (i = 0; dhcp_options[code].format[i]; i++) {
		if (!numhunk) {
			warn("%s: Excess information in format string: %s",
			    dhcp_options[code].name,
			    &(dhcp_options[code].format[i]));
			break;
		}
		numelem++;
		fmtbuf[i] = dhcp_options[code].format[i];
		switch (dhcp_options[code].format[i]) {
		case 'A':
			--numelem;
			fmtbuf[i] = 0;
			numhunk = 0;
			break;
		case 'X':
			for (k = 0; k < len; k++)
				if (!isascii(data[k]) ||
				    !isprint(data[k]))
					break;
			if (k == len) {
				fmtbuf[i] = 't';
				numhunk = -2;
			} else {
				fmtbuf[i] = 'x';
				hunksize++;
				comma = ':';
				numhunk = 0;
			}
			fmtbuf[i + 1] = 0;
			break;
		case 't':
			fmtbuf[i] = 't';
			fmtbuf[i + 1] = 0;
			numhunk = -2;
			break;
		case 'I':
		case 'l':
		case 'L':
			hunksize += 4;
			break;
		case 's':
		case 'S':
			hunksize += 2;
			break;
		case 'b':
		case 'B':
		case 'f':
			hunksize++;
			break;
		case 'e':
			break;
		default:
			warn("%s: garbage in format string: %s",
			    dhcp_options[code].name,
			    &(dhcp_options[code].format[i]));
			break;
		}
	}

	/* Check for too few bytes... */
	if (hunksize > len) {
		warn("%s: expecting at least %d bytes; got %d",
		    dhcp_options[code].name, hunksize, len);
		return ("<error>");
	}
	/* Check for too many bytes... */
	if (numhunk == -1 && hunksize < len)
		warn("%s: %d extra bytes",
		    dhcp_options[code].name, len - hunksize);

	/* If this is an array, compute its size. */
	if (!numhunk)
		numhunk = len / hunksize;
	/* See if we got an exact number of hunks. */
	if (numhunk > 0 && numhunk * hunksize < len)
		warn("%s: %d extra bytes at end of array",
		    dhcp_options[code].name, len - numhunk * hunksize);

	/* A one-hunk array prints the same as a single hunk. */
	if (numhunk < 0)
		numhunk = 1;

	/* Cycle through the array (or hunk) printing the data. */
	for (i = 0; i < numhunk; i++) {
		for (j = 0; j < numelem; j++) {
			int opcount;
			switch (fmtbuf[j]) {
			case 't':
				if (emit_quotes) {
					*op++ = '"';
					opleft--;
				}
				for (; dp < data + len; dp++) {
					if (!isascii(*dp) ||
					    !isprint(*dp)) {
						if (dp + 1 != data + len ||
						    *dp != 0) {
							snprintf(op, opleft,
							    "\\%03o", *dp);
							op += 4;
							opleft -= 4;
						}
					} else if (*dp == '"' ||
					    *dp == '\'' ||
					    *dp == '$' ||
					    *dp == '`' ||
					    *dp == '\\') {
						*op++ = '\\';
						*op++ = *dp;
						opleft -= 2;
					} else {
						*op++ = *dp;
						opleft--;
					}
				}
				if (emit_quotes) {
					*op++ = '"';
					opleft--;
				}

				*op = 0;
				break;
			case 'I':
				foo.s_addr = htonl(getULong(dp));
				opcount = strlcpy(op, inet_ntoa(foo), opleft);
				if (opcount >= opleft)
					goto toobig;
				opleft -= opcount;
				dp += 4;
				break;
			case 'l':
				opcount = snprintf(op, opleft, "%ld",
				    (long)getLong(dp));
				if (opcount >= opleft)
					goto toobig;
				opleft -= opcount;
				dp += 4;
				break;
			case 'L':
				opcount = snprintf(op, opleft, "%ld",
				    (unsigned long)getULong(dp));
				if (opcount >= opleft)
					goto toobig;
				opleft -= opcount;
				dp += 4;
				break;
			case 's':
				opcount = snprintf(op, opleft, "%d",
				    getShort(dp));
				if (opcount >= opleft)
					goto toobig;
				opleft -= opcount;
				dp += 2;
				break;
			case 'S':
				opcount = snprintf(op, opleft, "%d",
				    getUShort(dp));
				if (opcount >= opleft)
					goto toobig;
				opleft -= opcount;
				dp += 2;
				break;
			case 'b':
				opcount = snprintf(op, opleft, "%d",
				    *(char *)dp++);
				if (opcount >= opleft)
					goto toobig;
				opleft -= opcount;
				break;
			case 'B':
				opcount = snprintf(op, opleft, "%d", *dp++);
				if (opcount >= opleft)
					goto toobig;
				opleft -= opcount;
				break;
			case 'x':
				opcount = snprintf(op, opleft, "%x", *dp++);
				if (opcount >= opleft)
					goto toobig;
				opleft -= opcount;
				break;
			case 'f':
				opcount = strlcpy(op,
				    *dp++ ? "true" : "false", opleft);
				if (opcount >= opleft)
					goto toobig;
				opleft -= opcount;
				break;
			default:
				warn("Unexpected format code %c", fmtbuf[j]);
			}
			op += strlen(op);
			opleft -= strlen(op);
			if (opleft < 1)
				goto toobig;
			if (j + 1 < numelem && comma != ':') {
				*op++ = ' ';
				opleft--;
			}
		}
		if (i + 1 < numhunk) {
			*op++ = comma;
			opleft--;
		}
		if (opleft < 1)
			goto toobig;

	}
	return (optbuf);
 toobig:
	warn("dhcp option too large");
	return ("<error>");
}
#endif /* DEBUG_PACKET */
@


1.2
log
@the ones from dhclient do, and they're already KNF'd and annsified...
@
text
@d1 1
a1 1
/*	$OpenBSD: options.c,v 1.7 2004/03/02 18:49:21 deraadt Exp $	*/
d460 1
d705 1
@


1.1
log
@may the whacking begin
@
text
@d1 1
a1 1
/* options.c
d3 1
a3 1
   DHCP options parsing and reassembly. */
d43 2
a46 1
#include <ctype.h>
d51 4
a54 1
/* Parse all available options out of the specified packet. */
d56 6
a61 2
void parse_options (packet)
	struct packet *packet;
d64 1
a64 1
	memset (packet -> options, 0, sizeof (packet -> options));
d67 2
a68 2
	if (memcmp (packet -> raw -> options, DHCP_OPTIONS_COOKIE, 4)) {
		packet -> options_valid = 0;
d72 21
a92 18
	/* Go through the options field, up to the end of the packet
	   or the End field. */
	parse_option_buffer (packet, &packet -> raw -> options [4],
			     packet -> packet_length - DHCP_FIXED_NON_UDP - 4);
	/* If we parsed a DHCP Option Overload option, parse more
	   options out of the buffer(s) containing them. */
	if (packet -> options_valid
	    && packet -> options [DHO_DHCP_OPTION_OVERLOAD].data) {
		if (packet -> options [DHO_DHCP_OPTION_OVERLOAD].data [0] & 1)
			parse_option_buffer (packet,
					     (unsigned char *)
					     packet -> raw -> file,
					     sizeof packet -> raw -> file);
		if (packet -> options [DHO_DHCP_OPTION_OVERLOAD].data [0] & 2)
			parse_option_buffer (packet,
					     (unsigned char *)
					     packet -> raw -> sname,
					     sizeof packet -> raw -> sname);
d96 8
a103 8
/* Parse options out of the specified buffer, storing addresses of option
   values in packet -> options and setting packet -> options_valid if no
   errors are encountered. */

void parse_option_buffer (packet, buffer, length)
	struct packet *packet;
	unsigned char *buffer;
	int length;
d111 1
a111 1
		code = s [0];
d115 1
a115 1
			++s;
d122 14
a135 11
			
		/* All other fields (except end, see above) have a
		   one-byte length. */
		len = s [1];

		/* If the length is outrageous, silently skip the
		 * rest, and mark the packet bad. Unfortuntely
		 * some crappy dhcp servers always seem to give
		 * us garbage on the end of a packet. so rather than
		 * keep refusing, give up and try to take one after
		 * seeing a few without anything good.
d140 3
a142 3
			warn ("option %s (%d) %s.",
			      dhcp_options [code].name, len,
			      "larger than buffer");
d144 1
a144 1
				packet -> options_valid = 1;
d146 3
a148 3
				warn ("Many bogus options seen in offers.");
				warn ("Taking this offer in spite of bogus");
				warn ("options - hope for the best!");
d150 2
a151 2
				warn ("rejecting bogus offer.");
				packet -> options_valid = 0;
d155 16
a170 13
		/* If we haven't seen this option before, just make
		   space for it and copy it there. */
		if (!packet -> options [code].data) {
			if (!(t = ((unsigned char *)
				   dmalloc (len + 1, "parse_option_buffer"))))
				error ("Can't allocate storage for option %s.",
				       dhcp_options [code].name);
			/* Copy and NUL-terminate the option (in case it's an
			   ASCII string. */
			memcpy (t, &s [2], len);
			t [len] = 0;
			packet -> options [code].len = len;
			packet -> options [code].data = t;
d172 7
a178 6
			/* If it's a repeat, concatenate it to whatever
			   we last saw.   This is really only required
			   for clients, but what the heck... */
			t = ((unsigned char *)
			     dmalloc (len + packet -> options [code].len + 1,
				      "parse_option_buffer"));
d180 11
a190 11
				error ("Can't expand storage for option %s.",
				       dhcp_options [code].name);
			memcpy (t, packet -> options [code].data,
				packet -> options [code].len);
			memcpy (t + packet -> options [code].len,
				&s [2], len);
			packet -> options [code].len += len;
			t [packet -> options [code].len] = 0;
			dfree (packet -> options [code].data,
			       "parse_option_buffer");
			packet -> options [code].data = t;
d194 1
a194 1
	packet -> options_valid = 1;
d197 10
a206 15
/* cons options into a big buffer, and then split them out into the
   three separate buffers if needed.  This allows us to cons up a set
   of vendor options using the same routine. */

int cons_options (inpacket, outpacket, mms,
		  options, overload, terminate, bootpp, prl, prl_len)
	struct packet *inpacket;
	struct dhcp_packet *outpacket;
	int mms;
	struct tree_cache **options;
	int overload;	/* Overload flags that may be set. */
	int terminate;
	int bootpp;
	u_int8_t *prl;
	int prl_len;
d208 1
a208 1
	unsigned char priority_list [300];
d210 1
a210 1
	unsigned char buffer [4096];	/* Really big buffer... */
d216 8
a223 5
	/* If the client has provided a maximum DHCP message size,
	   use that; otherwise, if it's BOOTP, only 64 bytes; otherwise
	   use up to the minimum IP MTU size (576 bytes). */
	/* XXX if a BOOTP client specifies a max message size, we will
	   honor it. */
d226 6
a231 11
	    inpacket -> options [DHO_DHCP_MAX_MESSAGE_SIZE].data &&
	    (inpacket -> options [DHO_DHCP_MAX_MESSAGE_SIZE].len >=
	     sizeof (u_int16_t)))
		mms = getUShort (inpacket -> options
				 [DHO_DHCP_MAX_MESSAGE_SIZE].data);

	/* If the client has provided a maximum DHCP message size,
	   use that; otherwise, if it's BOOTP, only 64 bytes; otherwise
	   use up to the minimum IP MTU size (576 bytes). */
	/* XXX if a BOOTP client specifies a max message size, we will
	   honor it. */
d239 2
a240 2
	if (main_buffer_size > sizeof buffer)
		main_buffer_size = sizeof buffer;
d244 10
a253 9
	priority_list [priority_len++] = DHO_DHCP_MESSAGE_TYPE;
	priority_list [priority_len++] = DHO_DHCP_SERVER_IDENTIFIER;
	priority_list [priority_len++] = DHO_DHCP_LEASE_TIME;
	priority_list [priority_len++] = DHO_DHCP_MESSAGE;

	/* If the client has provided a list of options that it wishes
	   returned, use it to prioritize.  Otherwise, prioritize
	   based on the default priority list. */

d255 9
a263 9
	    inpacket -> options [DHO_DHCP_PARAMETER_REQUEST_LIST].data) {
		int prlen = (inpacket ->
			     options [DHO_DHCP_PARAMETER_REQUEST_LIST].len);
		if (prlen + priority_len > sizeof priority_list)
			prlen = (sizeof priority_list) - priority_len;

		memcpy (&priority_list [priority_len],
			(inpacket -> options
			 [DHO_DHCP_PARAMETER_REQUEST_LIST].data), prlen);
d267 4
a270 4
		if (prl_len + priority_len > sizeof priority_list)
			prl_len = (sizeof priority_list) - priority_len;
		
		memcpy (&priority_list [priority_len], prl, prl_len);
d274 3
a276 3
		memcpy (&priority_list [priority_len],
			dhcp_option_default_priority_list,
			sizeof_dhcp_option_default_priority_list);
d281 7
a287 9
	option_size = store_options (buffer,
				     (main_buffer_size - 7 +
				      ((overload & 1) ? DHCP_FILE_LEN : 0) +
				      ((overload & 2) ? DHCP_SNAME_LEN : 0)),
				     options, priority_list, priority_len,
				     main_buffer_size,
				     (main_buffer_size +
				      ((overload & 1) ? DHCP_FILE_LEN : 0)),
				     terminate);
d290 1
a290 1
	memcpy (outpacket -> options, DHCP_OPTIONS_COOKIE, 4);
d293 5
a297 4
	/* If we're going to have to overload, store the overload
	   option at the beginning.  If we can, though, just store the
	   whole thing in the packet's option buffer and leave it at
	   that. */
d299 2
a300 2
		memcpy (&outpacket -> options [mainbufix],
			buffer, option_size);
d303 1
a303 2
			outpacket -> options [mainbufix++]
				= DHO_END;
d306 5
a310 5
		outpacket -> options [mainbufix++] =
			DHO_DHCP_OPTION_OVERLOAD;
		outpacket -> options [mainbufix++] = 1;
		if (option_size > main_buffer_size - mainbufix + DHCP_FILE_LEN)
			outpacket -> options [mainbufix++] = 3;
d312 1
a312 1
			outpacket -> options [mainbufix++] = 1;
d314 2
a315 2
		memcpy (&outpacket -> options [mainbufix],
			buffer, main_buffer_size - mainbufix);
d320 2
a321 2
				memcpy (outpacket -> file,
					&buffer [bufix], option_size - bufix);
d324 1
a324 2
					outpacket -> file [mainbufix++]
						= DHO_END;
d326 1
a326 2
					outpacket -> file [mainbufix++]
						= DHO_PAD;
d328 2
a329 2
				memcpy (outpacket -> file,
					&buffer [bufix], DHCP_FILE_LEN);
d334 2
a335 2
			memcpy (outpacket -> sname,
				&buffer [bufix], option_size - bufix);
d339 1
a339 2
				outpacket -> file [mainbufix++]
					= DHO_END;
d341 1
a341 2
				outpacket -> file [mainbufix++]
					= DHO_PAD;
d344 1
a344 1
	return length;
d347 7
a353 11
/* Store all the requested options into the requested buffer. */

int store_options (buffer, buflen, options, priority_list, priority_len,
		   first_cutoff, second_cutoff, terminate)
	unsigned char *buffer;
	int buflen;
	struct tree_cache **options;
	unsigned char *priority_list;
	int priority_len;
	int first_cutoff, second_cutoff;
	int terminate;
d356 1
a356 1
	int option_stored [256];
d362 1
a362 1
	memset (option_stored, 0, sizeof option_stored);
d364 4
a367 2
	/* Copy out the options in the order that they appear in the
	   priority list... */
d370 1
a370 1
		int code = priority_list [i];
d373 4
a376 2
		/* Number of bytes left to store (some may already
		   have been stored by a previous pass). */
d380 1
a380 1
		if (!options [code]) {
d384 5
a388 3
		/* The client could ask for things that are mandatory,
		   in which case we should avoid storing them twice... */
		if (option_stored [code])
d390 1
a390 1
		option_stored [code] = 1;
d393 1
a393 1
		if (!tree_evaluate (options [code])) {
a394 1
		}
d397 1
a397 1
		length = options [code] -> len;
d400 1
a400 1
		if (terminate && dhcp_options [code].format [0] == 't') {
d403 1
a403 1
		} else {
a404 1
		}
d408 7
a414 5
		/* If the option's length is more than 255, we must store it
		   in multiple hunks.   Store 255-byte hunks first.  However,
		   in any case, if the option data will cross a buffer
		   boundary, split it across that boundary. */

d421 5
a425 3
			/* If this hunk of the buffer will cross a
			   boundary, only go up to the boundary in this
			   pass. */
d430 1
a430 1
				 bufix + incr > second_cutoff)
d433 4
a436 2
			/* If this option is going to overflow the buffer,
			   skip it. */
d443 2
a444 2
			buffer [bufix] = code;
			buffer [bufix + 1] = incr;
d446 6
a451 8
				memcpy (buffer + bufix + 2,
					options [code] -> value + ix,
					incr - 1);
				buffer [bufix + 2 + incr - 1] = 0;
			} else {
				memcpy (buffer + bufix + 2,
					options [code] -> value + ix, incr);
			}
d457 1
a457 1
	return bufix;
d460 6
a465 8
/* Format the specified option so that a human can easily read it. */

char *pretty_print_option (code, data, len, emit_commas, emit_quotes)
	unsigned int code;
	unsigned char *data;
	int len;
	int emit_commas;
	int emit_quotes;
d467 1
a467 1
	static char optbuf [32768]; /* XXX */
d471 1
a471 1
	char fmtbuf [32];
d482 1
a482 1
		error ("pretty_print_option: bad code %d\n", code);
d488 1
a488 1
	
d490 1
a490 1
	for (i = 0; dhcp_options [code].format [i]; i++) {
d492 3
a494 3
			warn ("%s: Excess information in format string: %s",
			      dhcp_options [code].name,
			      &(dhcp_options [code].format [i]));
d498 3
a500 3
		fmtbuf [i] = dhcp_options [code].format [i];
		switch (dhcp_options [code].format [i]) {
		      case 'A':
d502 1
a502 1
			fmtbuf [i] = 0;
d505 4
a508 4
		      case 'X':
			for (k = 0; k < len; k++) {
				if (!isascii (data [k]) ||
				    !isprint (data [k]))
a509 1
			}
d511 1
a511 1
				fmtbuf [i] = 't';
d514 1
a514 1
				fmtbuf [i] = 'x';
d519 1
a519 1
			fmtbuf [i + 1] = 0;
d521 3
a523 3
		      case 't':
			fmtbuf [i] = 't';
			fmtbuf [i + 1] = 0;
d526 3
a528 3
		      case 'I':
		      case 'l':
		      case 'L':
d531 2
a532 2
		      case 's':
		      case 'S':
d535 3
a537 3
		      case 'b':
		      case 'B':
		      case 'f':
d540 1
a540 1
		      case 'e':
d542 4
a545 4
		      default:
			warn ("%s: garbage in format string: %s",
			      dhcp_options [code].name,
			      &(dhcp_options [code].format [i]));
d547 1
a547 1
		} 
d552 3
a554 4
		warn ("%s: expecting at least %d bytes; got %d",
		      dhcp_options [code].name,
		      hunksize, len);
		return "<error>";
d558 2
a559 3
		warn ("%s: %d extra bytes",
		      dhcp_options [code].name,
		      len - hunksize);
d566 2
a567 3
		warn ("%s: %d extra bytes at end of array",
		      dhcp_options [code].name,
		      len - numhunk * hunksize);
d576 3
a578 3
		        int opcount;
			switch (fmtbuf [j]) {
			      case 't':
d584 2
a585 2
					if (!isascii (*dp) ||
					    !isprint (*dp)) {
d594 4
a597 4
						   *dp == '\'' ||
						   *dp == '$' ||
						   *dp == '`' ||
						   *dp == '\\') {
d610 1
a610 1
				
d613 4
a616 5
			      case 'I':
				foo.s_addr = htonl(getULong (dp));
				opcount = strlcpy(op, inet_ntoa (foo),
			          opleft);
				if (opcount >= opleft) 
d621 4
a624 4
			      case 'l':
				opcount = snprintf(op, opleft,"%ld",
				  (long)getLong (dp));
				if (opcount >= opleft) 
d629 1
a629 1
			      case 'L':
d631 2
a632 2
				  (unsigned long)getULong (dp));
				if (opcount >= opleft) 
d637 1
a637 1
			      case 's':
d639 2
a640 2
				  getShort (dp));
				if (opcount >= opleft) 
d645 1
a645 1
			      case 'S':
d647 2
a648 2
				  getUShort (dp));
				if (opcount >= opleft) 
d653 4
a656 4
			      case 'b':
				opcount = snprintf(op, opleft, "%d", 
				  *(char *)dp++);
				if (opcount >= opleft) 
d660 1
a660 1
			      case 'B':
d662 1
a662 1
				if (opcount >= opleft) 
d666 1
a666 1
			      case 'x':
d668 1
a668 1
				if (opcount >= opleft) 
d672 4
a675 4
			      case 'f': 
				opcount = strlcpy(op, 
				  *dp++ ? "true" : "false", opleft);
				if (opcount >= opleft) 
d679 2
a680 2
			      default:
				warn ("Unexpected format code %c", fmtbuf [j]);
d682 1
a682 1
			op += strlen (op);
d697 1
a697 1
		
d699 1
a699 1
	return optbuf;
d701 2
a702 2
	warn ("dhcp option too large");
	return "<error>";			  
d705 3
a707 7
void do_packet (interface, packet, len, from_port, from, hfrom)
	struct interface_info *interface;
	struct dhcp_packet *packet;
	int len;
	unsigned int from_port;
	struct iaddr from;
	struct hardware *hfrom;
d712 2
a713 2
	if (packet -> hlen > sizeof packet -> chaddr) {
		note ("Discarding packet with invalid hlen.");
d717 1
a717 1
	memset (&tp, 0, sizeof tp);
d724 2
a725 2
	
	parse_options (&tp);
d727 2
a728 3
	    tp.options [DHO_DHCP_MESSAGE_TYPE].data)
		tp.packet_type =
			tp.options [DHO_DHCP_MESSAGE_TYPE].data [0];
d730 1
a730 1
		dhcp (&tp);
d732 1
a732 1
		bootp (&tp);
d735 3
a737 4
	for (i = 0; i < 256; i++) {
		if (tp.options [i].len && tp.options [i].data)
			dfree (tp.options [i].data, "do_packet");
	}
a738 1

@

