head	1.33;
access;
symbols
	OPENBSD_6_2_BASE:1.33
	OPENBSD_6_1:1.31.0.4
	OPENBSD_6_1_BASE:1.31
	OPENBSD_6_0:1.26.0.4
	OPENBSD_6_0_BASE:1.26
	OPENBSD_5_9:1.26.0.2
	OPENBSD_5_9_BASE:1.26
	OPENBSD_5_8:1.24.0.4
	OPENBSD_5_8_BASE:1.24
	OPENBSD_5_7:1.23.0.2
	OPENBSD_5_7_BASE:1.23
	OPENBSD_5_6:1.23.0.4
	OPENBSD_5_6_BASE:1.23
	OPENBSD_5_5:1.22.0.4
	OPENBSD_5_5_BASE:1.22
	OPENBSD_5_4:1.20.0.14
	OPENBSD_5_4_BASE:1.20
	OPENBSD_5_3:1.20.0.12
	OPENBSD_5_3_BASE:1.20
	OPENBSD_5_2:1.20.0.10
	OPENBSD_5_2_BASE:1.20
	OPENBSD_5_1_BASE:1.20
	OPENBSD_5_1:1.20.0.8
	OPENBSD_5_0:1.20.0.6
	OPENBSD_5_0_BASE:1.20
	OPENBSD_4_9:1.20.0.4
	OPENBSD_4_9_BASE:1.20
	OPENBSD_4_8:1.20.0.2
	OPENBSD_4_8_BASE:1.20
	OPENBSD_4_7:1.18.0.2
	OPENBSD_4_7_BASE:1.18
	OPENBSD_4_6:1.16.0.14
	OPENBSD_4_6_BASE:1.16
	OPENBSD_4_5:1.16.0.10
	OPENBSD_4_5_BASE:1.16
	OPENBSD_4_4:1.16.0.8
	OPENBSD_4_4_BASE:1.16
	OPENBSD_4_3:1.16.0.6
	OPENBSD_4_3_BASE:1.16
	OPENBSD_4_2:1.16.0.4
	OPENBSD_4_2_BASE:1.16
	OPENBSD_4_1:1.16.0.2
	OPENBSD_4_1_BASE:1.16
	OPENBSD_4_0:1.15.0.2
	OPENBSD_4_0_BASE:1.15
	OPENBSD_3_9:1.12.0.6
	OPENBSD_3_9_BASE:1.12
	OPENBSD_3_8:1.12.0.4
	OPENBSD_3_8_BASE:1.12
	OPENBSD_3_7:1.12.0.2
	OPENBSD_3_7_BASE:1.12
	OPENBSD_3_6:1.10.0.2
	OPENBSD_3_6_BASE:1.10;
locks; strict;
comment	@ * @;


1.33
date	2017.04.24.14.58.36;	author krw;	state Exp;
branches;
next	1.32;
commitid	VdvDIyV6oHLS1zmq;

1.32
date	2017.04.12.19.12.01;	author krw;	state Exp;
branches;
next	1.31;
commitid	lBAKWYnzxqBoxLxB;

1.31
date	2017.02.13.23.04.05;	author krw;	state Exp;
branches
	1.31.4.1;
next	1.30;
commitid	amfLXbU964CBXnkr;

1.30
date	2017.02.13.22.33.39;	author krw;	state Exp;
branches;
next	1.29;
commitid	aD6aChUv7GEv3CLZ;

1.29
date	2017.02.13.19.13.14;	author krw;	state Exp;
branches;
next	1.28;
commitid	syYFt6P4XI7prXRF;

1.28
date	2016.08.17.00.55.33;	author krw;	state Exp;
branches;
next	1.27;
commitid	kQarxBEbUmEjVfpv;

1.27
date	2016.08.17.00.38.26;	author krw;	state Exp;
branches;
next	1.26;
commitid	3FpKSbVoAJKp4Gq8;

1.26
date	2016.02.06.23.50.10;	author krw;	state Exp;
branches;
next	1.25;
commitid	8GMcSAoPYCa1rXN3;

1.25
date	2015.08.20.22.39.29;	author deraadt;	state Exp;
branches;
next	1.24;
commitid	z3HrihslRYb4HqW9;

1.24
date	2015.05.18.17.51.21;	author krw;	state Exp;
branches;
next	1.23;
commitid	SjQKXPdyGuKrZRc7;

1.23
date	2014.07.09.13.42.24;	author yasuoka;	state Exp;
branches;
next	1.22;
commitid	I9ESPThlhzvwGgAS;

1.22
date	2014.01.21.03.07.51;	author krw;	state Exp;
branches;
next	1.21;

1.21
date	2013.10.21.12.02.25;	author krw;	state Exp;
branches;
next	1.20;

1.20
date	2010.04.02.17.03.58;	author zinovik;	state Exp;
branches;
next	1.19;

1.19
date	2010.03.27.14.11.38;	author krw;	state Exp;
branches;
next	1.18;

1.18
date	2010.01.02.04.21.16;	author krw;	state Exp;
branches;
next	1.17;

1.17
date	2010.01.01.08.02.34;	author krw;	state Exp;
branches;
next	1.16;

1.16
date	2006.12.17.18.03.33;	author stevesk;	state Exp;
branches;
next	1.15;

1.15
date	2006.06.13.08.47.57;	author jmc;	state Exp;
branches;
next	1.14;

1.14
date	2006.04.18.19.18.32;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2006.03.13.19.57.42;	author otto;	state Exp;
branches;
next	1.12;

1.12
date	2004.09.16.18.35.42;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2004.09.15.18.15.50;	author henning;	state Exp;
branches;
next	1.10;

1.10
date	2004.09.09.20.51.57;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2004.05.08.06.11.53;	author henning;	state Exp;
branches;
next	1.8;

1.8
date	2004.05.06.22.05.48;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2004.04.20.05.35.33;	author henning;	state Exp;
branches;
next	1.6;

1.6
date	2004.04.18.01.19.07;	author henning;	state Exp;
branches;
next	1.5;

1.5
date	2004.04.18.00.59.52;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2004.04.18.00.43.27;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2004.04.14.04.34.19;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2004.04.13.23.57.49;	author henning;	state Exp;
branches;
next	1.1;

1.1
date	2004.04.13.23.41.48;	author henning;	state Exp;
branches;
next	;

1.31.4.1
date	2017.05.03.02.22.00;	author jsg;	state Exp;
branches;
next	;
commitid	Lc14KH1vjpo2vkRP;


desc
@@


1.33
log
@Add 'echo-client-id' statment, so that RFC 6842 behaviour can be
turned off for those clients and networks that find it impossible to
move past RFC 2131. Modelled on the same statement in recent ISC
versions, though we default to 'on' (a.k.a. RFC 6842) rather that
'off' (a.k.a. RFC 2131).

Problems reported by Bastien Durel (Xerox Phaser 6022 printer) and
Bryan Vyhmeister (Hon Hai Precision router) via misc@@. Thanks!
@
text
@/*	$OpenBSD: confpars.c,v 1.32 2017/04/12 19:12:01 krw Exp $ */

/*
 * Copyright (c) 1995, 1996, 1997 The Internet Software Consortium.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of The Internet Software Consortium nor the names
 *    of its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INTERNET SOFTWARE CONSORTIUM AND
 * CONTRIBUTORS ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE INTERNET SOFTWARE CONSORTIUM OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This software has been written for the Internet Software Consortium
 * by Ted Lemon <mellon@@fugue.com> in cooperation with Vixie
 * Enterprises.  To learn more about the Internet Software Consortium,
 * see ``http://www.vix.com/isc''.  To learn more about Vixie
 * Enterprises, see ``http://www.vix.com''.
 */

#include <sys/types.h>
#include <sys/socket.h>

#include <net/if.h>

#include <netdb.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "dhcp.h"
#include "tree.h"
#include "dhcpd.h"
#include "dhctoken.h"
#include "log.h"

int	parse_cidr(FILE *, unsigned char *, unsigned char *);

/*
 * conf-file :== parameters declarations EOF
 * parameters :== <nil> | parameter | parameters parameter
 * declarations :== <nil> | declaration | declarations declaration
 */
int
readconf(void)
{
	FILE *cfile;
	char *val;
	int token;
	int declaration = 0;

	new_parse(path_dhcpd_conf);

	/* Set up the initial dhcp option universe. */
	initialize_universes();

	/* Set up the global defaults. */
	root_group.default_lease_time = 43200; /* 12 hours. */
	root_group.max_lease_time = 86400; /* 24 hours. */
	root_group.bootp_lease_cutoff = MAX_TIME;
	root_group.boot_unknown_clients = 1;
	root_group.allow_bootp = 1;
	root_group.allow_booting = 1;
	root_group.authoritative = 1;
	root_group.echo_client_id = 1;

	if ((cfile = fopen(path_dhcpd_conf, "r")) == NULL)
		fatal("Can't open %s", path_dhcpd_conf);

	do {
		token = peek_token(&val, cfile);
		if (token == EOF)
			break;
		declaration = parse_statement(cfile, &root_group,
						 ROOT_GROUP,
						 NULL,
						 declaration);
	} while (1);
	token = next_token(&val, cfile); /* Clear the peek buffer */
	fclose(cfile);

	return !warnings_occurred;
}

/*
 * lease-file :== lease-declarations EOF
 * lease-statments :== <nil>
 *		   | lease-declaration
 *		   | lease-declarations lease-declaration
 */
void
read_leases(void)
{
	FILE *cfile;
	char *val;
	int token;

	new_parse(path_dhcpd_db);

	/*
	 * Open the lease file.   If we can't open it, fail.   The reason
	 * for this is that although on initial startup, the absence of
	 * a lease file is perfectly benign, if dhcpd has been running
	 * and this file is absent, it means that dhcpd tried and failed
	 * to rewrite the lease database.   If we proceed and the
	 * problem which caused the rewrite to fail has been fixed, but no
	 * human has corrected the database problem, then we are left
	 * thinking that no leases have been assigned to anybody, which
	 * could create severe network chaos.
	 */
	if ((cfile = fopen(path_dhcpd_db, "r")) == NULL) {
		log_warn("Can't open lease database (%s)", path_dhcpd_db);
		log_warnx("check for failed database rewrite attempt!");
		log_warnx("Please read the dhcpd.leases manual page if you");
		fatalx("don't know what to do about this.");
	}

	do {
		token = next_token(&val, cfile);
		if (token == EOF)
			break;
		if (token != TOK_LEASE) {
			log_warnx("Corrupt lease file - possible data loss!");
			skip_to_semi(cfile);
		} else {
			struct lease *lease;
			lease = parse_lease_declaration(cfile);
			if (lease)
				enter_lease(lease);
			else
				parse_warn("possibly corrupt lease file");
		}

	} while (1);
	fclose(cfile);
}

/*
 * statement :== parameter | declaration
 *
 * parameter :== timestamp
 *	     | DEFAULT_LEASE_TIME lease_time
 *	     | MAX_LEASE_TIME lease_time
 *	     | DYNAMIC_BOOTP_LEASE_CUTOFF date
 *	     | DYNAMIC_BOOTP_LEASE_LENGTH lease_time
 *	     | BOOT_UNKNOWN_CLIENTS boolean
 *	     | GET_LEASE_HOSTNAMES boolean
 *	     | USE_HOST_DECL_NAME boolean
 *	     | NEXT_SERVER ip-addr-or-hostname SEMI
 *	     | option_parameter
 *	     | SERVER-IDENTIFIER ip-addr-or-hostname SEMI
 *	     | FILENAME string-parameter
 *	     | SERVER_NAME string-parameter
 *	     | hardware-parameter
 *	     | fixed-address-parameter
 *	     | ALLOW allow-deny-keyword
 *	     | DENY allow-deny-keyword
 *	     | USE_LEASE_ADDR_FOR_DEFAULT_ROUTE boolean
 *
 * declaration :== host-declaration
 *		 | group-declaration
 *		 | shared-network-declaration
 *		 | subnet-declaration
 *		 | VENDOR_CLASS class-declaration
 *		 | USER_CLASS class-declaration
 *		 | RANGE address-range-declaration
 */
int
parse_statement(FILE *cfile, struct group *group, int type,
	struct host_decl *host_decl, int declaration)
{
	int token;
	char *val;
	struct shared_network *share;
	char *n;
	struct tree *tree;
	struct tree_cache *cache;
	struct hardware hardware;

	switch (next_token(&val, cfile)) {
	case TOK_HOST:
		if (type != HOST_DECL)
			parse_host_declaration(cfile, group);
		else {
			parse_warn("host declarations not allowed here.");
			skip_to_semi(cfile);
		}
		return 1;

	case TOK_GROUP:
		if (type != HOST_DECL)
			parse_group_declaration(cfile, group);
		else {
			parse_warn("host declarations not allowed here.");
			skip_to_semi(cfile);
		}
		return 1;

	case TOK_TIMESTAMP:
		break;

	case TOK_SHARED_NETWORK:
		if (type == SHARED_NET_DECL ||
		    type == HOST_DECL ||
		    type == SUBNET_DECL) {
			parse_warn("shared-network parameters not %s.",
				    "allowed here");
			skip_to_semi(cfile);
			break;
		}

		parse_shared_net_declaration(cfile, group);
		return 1;

	case TOK_SUBNET:
		if (type == HOST_DECL || type == SUBNET_DECL) {
			parse_warn("subnet declarations not allowed here.");
			skip_to_semi(cfile);
			return 1;
		}

		/* If we're in a subnet declaration, just do the parse. */
		if (group->shared_network) {
			parse_subnet_declaration(cfile,
			    group->shared_network);
			break;
		}

		/*
		 * Otherwise, cons up a fake shared network structure
		 * and populate it with the lone subnet.
		 */

		share = calloc(1, sizeof(struct shared_network));
		if (!share)
			fatalx("No memory for shared subnet");
		share->group = clone_group(group, "parse_statement:subnet");
		share->group->shared_network = share;

		parse_subnet_declaration(cfile, share);

		/* share->subnets is the subnet we just parsed. */
		if (share->subnets) {
			share->interface =
				share->subnets->interface;

			/* Make the shared network name from network number. */
			n = piaddr(share->subnets->net);
			share->name = strdup(n);
			if (share->name == NULL)
				fatalx("no memory for subnet name");

			/*
			 * Copy the authoritative parameter from the subnet,
			 * since there is no opportunity to declare it here.
			 */
			share->group->authoritative =
				share->subnets->group->authoritative;
			enter_shared_network(share);
		}
		return 1;

	case TOK_VENDOR_CLASS:
		parse_class_declaration(cfile, group, 0);
		return 1;

	case TOK_USER_CLASS:
		parse_class_declaration(cfile, group, 1);
		return 1;

	case TOK_DEFAULT_LEASE_TIME:
		parse_lease_time(cfile, &group->default_lease_time);
		break;

	case TOK_MAX_LEASE_TIME:
		parse_lease_time(cfile, &group->max_lease_time);
		break;

	case TOK_DYNAMIC_BOOTP_LEASE_CUTOFF:
		group->bootp_lease_cutoff = parse_date(cfile);
		break;

	case TOK_DYNAMIC_BOOTP_LEASE_LENGTH:
		parse_lease_time(cfile, &group->bootp_lease_length);
		break;

	case TOK_BOOT_UNKNOWN_CLIENTS:
		if (type == HOST_DECL)
			parse_warn("boot-unknown-clients not allowed here.");
		group->boot_unknown_clients = parse_boolean(cfile);
		break;

	case TOK_GET_LEASE_HOSTNAMES:
		if (type == HOST_DECL)
			parse_warn("get-lease-hostnames not allowed here.");
		group->get_lease_hostnames = parse_boolean(cfile);
		break;

	case TOK_ALWAYS_REPLY_RFC1048:
		group->always_reply_rfc1048 = parse_boolean(cfile);
		break;

	case TOK_ECHO_CLIENT_ID:
		group->echo_client_id = parse_boolean(cfile);
		break;

	case TOK_USE_HOST_DECL_NAMES:
		if (type == HOST_DECL)
			parse_warn("use-host-decl-names not allowed here.");
		group->use_host_decl_names = parse_boolean(cfile);
		break;

	case TOK_USE_LEASE_ADDR_FOR_DEFAULT_ROUTE:
		group->use_lease_addr_for_default_route =
			parse_boolean(cfile);
		break;

	case TOK_TOKEN_NOT:
		token = next_token(&val, cfile);
		switch (token) {
		case TOK_AUTHORITATIVE:
			if (type == HOST_DECL)
			    parse_warn("authority makes no sense here.");
			group->authoritative = 0;
			parse_semi(cfile);
			break;
		default:
			parse_warn("expecting assertion");
			skip_to_semi(cfile);
			break;
		}
		break;

	case TOK_AUTHORITATIVE:
		if (type == HOST_DECL)
		    parse_warn("authority makes no sense here.");
		group->authoritative = 1;
		parse_semi(cfile);
		break;

	case TOK_NEXT_SERVER:
		tree = parse_ip_addr_or_hostname(cfile, 0);
		if (!tree)
			break;
		cache = tree_cache(tree);
		if (!tree_evaluate (cache))
			fatalx("next-server is not known");
		group->next_server.len = 4;
		memcpy(group->next_server.iabuf,
		    cache->value, group->next_server.len);
		parse_semi(cfile);
		break;

	case TOK_OPTION:
		parse_option_param(cfile, group);
		break;

	case TOK_SERVER_IDENTIFIER:
		tree = parse_ip_addr_or_hostname(cfile, 0);
		if (!tree)
			return declaration;
		group->options[DHO_DHCP_SERVER_IDENTIFIER] = tree_cache(tree);
		token = next_token(&val, cfile);
		break;

	case TOK_FILENAME:
		group->filename = parse_string(cfile);
		break;

	case TOK_SERVER_NAME:
		group->server_name = parse_string(cfile);
		break;

	case TOK_HARDWARE:
		parse_hardware_param(cfile, &hardware);
		if (host_decl)
			host_decl->interface = hardware;
		else
			parse_warn("hardware address parameter %s",
				    "not allowed here.");
		break;

	case TOK_FIXED_ADDR:
		cache = parse_fixed_addr_param(cfile);
		if (host_decl)
			host_decl->fixed_addr = cache;
		else
			parse_warn("fixed-address parameter not %s",
				    "allowed here.");
		break;

	case TOK_RANGE:
		if (type != SUBNET_DECL || !group->subnet) {
			parse_warn("range declaration not allowed here.");
			skip_to_semi(cfile);
			return declaration;
		}
		parse_address_range(cfile, group->subnet);
		return declaration;

	case TOK_ALLOW:
		parse_allow_deny(cfile, group, 1);
		break;

	case TOK_DENY:
		parse_allow_deny(cfile, group, 0);
		break;

	default:
		if (declaration)
			parse_warn("expecting a declaration.");
		else
			parse_warn("expecting a parameter or declaration.");
		skip_to_semi(cfile);
		return declaration;
	}

	if (declaration) {
		parse_warn("parameters not allowed after first declaration.");
		return 1;
	}

	return 0;
}

/*
 * allow-deny-keyword :== BOOTP
 *			| BOOTING
 *			| DYNAMIC_BOOTP
 *			| UNKNOWN_CLIENTS
 */
void
parse_allow_deny(FILE *cfile, struct group *group, int flag)
{
	int token;
	char *val;

	token = next_token(&val, cfile);
	switch (token) {
	case TOK_BOOTP:
		group->allow_bootp = flag;
		break;

	case TOK_BOOTING:
		group->allow_booting = flag;
		break;

	case TOK_DYNAMIC_BOOTP:
		group->dynamic_bootp = flag;
		break;

	case TOK_UNKNOWN_CLIENTS:
		group->boot_unknown_clients = flag;
		break;

	default:
		parse_warn("expecting allow/deny key");
		skip_to_semi(cfile);
		return;
	}
	parse_semi(cfile);
}

/*
 * boolean :== ON SEMI | OFF SEMI | TRUE SEMI | FALSE SEMI
 */
int
parse_boolean(FILE *cfile)
{
	char *val;
	int rv;

	next_token(&val, cfile);
	if (!strcasecmp (val, "true") || !strcasecmp (val, "on"))
		rv = 1;
	else if (!strcasecmp (val, "false") || !strcasecmp (val, "off"))
		rv = 0;
	else {
		parse_warn("boolean value (true/false/on/off) expected");
		skip_to_semi(cfile);
		return 0;
	}
	parse_semi(cfile);
	return rv;
}

/*
 * Expect a left brace; if there isn't one, skip over the rest of the
 * statement and return zero; otherwise, return 1.
 */
int
parse_lbrace(FILE *cfile)
{
	int token;
	char *val;

	token = next_token(&val, cfile);
	if (token != '{') {
		parse_warn("expecting left brace.");
		skip_to_semi(cfile);
		return 0;
	}
	return 1;
}


/*
 * host-declaration :== hostname '{' parameters declarations '}'
 */
void
parse_host_declaration(FILE *cfile, struct group *group)
{
	char *val;
	int token;
	struct host_decl *host;
	char *name = parse_host_name(cfile);
	int declaration = 0;

	if (!name)
		return;

	host = calloc(1, sizeof (struct host_decl));
	if (!host)
		fatalx("can't allocate host decl struct %s.", name);

	host->name = name;
	host->group = clone_group(group, "parse_host_declaration");

	if (!parse_lbrace(cfile)) {
		free(host->name);
		free(host->group);
		free(host);
		return;
	}

	do {
		token = peek_token(&val, cfile);
		if (token == '}') {
			token = next_token(&val, cfile);
			break;
		}
		if (token == EOF) {
			token = next_token(&val, cfile);
			parse_warn("unexpected end of file");
			break;
		}
		declaration = parse_statement(cfile, host->group,
		    HOST_DECL, host, declaration);
	} while (1);

	if (!host->group->options[DHO_HOST_NAME] &&
	    host->group->use_host_decl_names) {
		host->group->options[DHO_HOST_NAME] =
		    new_tree_cache("parse_host_declaration");
		if (!host->group->options[DHO_HOST_NAME])
			fatalx("can't allocate a tree cache for hostname.");
		host->group->options[DHO_HOST_NAME]->len =
			strlen(name);
		host->group->options[DHO_HOST_NAME]->value =
			(unsigned char *)name;
		host->group->options[DHO_HOST_NAME]->buf_size =
			host->group->options[DHO_HOST_NAME]->len;
		host->group->options[DHO_HOST_NAME]->timeout = -1;
		host->group->options[DHO_HOST_NAME]->tree =
			NULL;
	}

	enter_host(host);
}

/*
 * class-declaration :== STRING '{' parameters declarations '}'
 */
void
parse_class_declaration(FILE *cfile, struct group *group, int type)
{
	char *val;
	int token;
	struct class *class;
	int declaration = 0;

	token = next_token(&val, cfile);
	if (token != TOK_STRING) {
		parse_warn("Expecting class name");
		skip_to_semi(cfile);
		return;
	}

	class = add_class (type, val);
	if (!class)
		fatalx("No memory for class %s.", val);
	class->group = clone_group(group, "parse_class_declaration");

	if (!parse_lbrace(cfile)) {
		free(class->name);
		free(class->group);
		free(class);
		return;
	}

	do {
		token = peek_token(&val, cfile);
		if (token == '}') {
			token = next_token(&val, cfile);
			break;
		} else if (token == EOF) {
			token = next_token(&val, cfile);
			parse_warn("unexpected end of file");
			break;
		} else {
			declaration = parse_statement(cfile, class->group,
			    CLASS_DECL, NULL, declaration);
		}
	} while (1);
}

/*
 * shared-network-declaration :==
 *			hostname LBRACE declarations parameters RBRACE
 */
void
parse_shared_net_declaration(FILE *cfile, struct group *group)
{
	char *val;
	int token;
	struct shared_network *share;
	char *name;
	int declaration = 0;

	share = calloc(1, sizeof(struct shared_network));
	if (!share)
		fatalx("No memory for shared subnet");
	share->leases = NULL;
	share->last_lease = NULL;
	share->insertion_point = NULL;
	share->next = NULL;
	share->interface = NULL;
	share->group = clone_group(group, "parse_shared_net_declaration");
	share->group->shared_network = share;

	/* Get the name of the shared network. */
	token = peek_token(&val, cfile);
	if (token == TOK_STRING) {
		token = next_token(&val, cfile);

		if (val[0] == 0) {
			parse_warn("zero-length shared network name");
			val = "<no-name-given>";
		}
		name = strdup(val);
		if (name == NULL)
			fatalx("no memory for shared network name");
	} else {
		name = parse_host_name(cfile);
		if (!name) {
			free(share->group);
			free(share);
			return;
		}
	}
	share->name = name;

	if (!parse_lbrace(cfile)) {
		free(share->group);
		free(share->name);
		free(share);
		return;
	}

	do {
		token = peek_token(&val, cfile);
		if (token == '}') {
			token = next_token(&val, cfile);
			if (!share->subnets) {
				free(share->group);
				free(share->name);
				free(share);
				parse_warn("empty shared-network decl");
				return;
			}
			enter_shared_network(share);
			return;
		} else if (token == EOF) {
			token = next_token(&val, cfile);
			parse_warn("unexpected end of file");
			break;
		}

		declaration = parse_statement(cfile, share->group,
		    SHARED_NET_DECL, NULL, declaration);
	} while (1);
}

/*
 * subnet-declaration :==
 *	net NETMASK netmask RBRACE parameters declarations LBRACE
 */
void
parse_subnet_declaration(FILE *cfile, struct shared_network *share)
{
	char *val;
	int token;
	struct subnet *subnet, *t, *u;
	struct iaddr iaddr;
	unsigned char addr[4];
	int len = sizeof addr;
	int declaration = 0;

	subnet = calloc(1, sizeof(struct subnet));
	if (!subnet)
		fatalx("No memory for new subnet");
	subnet->shared_network = share;
	subnet->group = clone_group(share->group, "parse_subnet_declaration");
	subnet->group->subnet = subnet;

	/* Get the network number. */
	if (!parse_numeric_aggregate(cfile, addr, &len, '.', 10, 8)) {
		free(subnet->group);
		free(subnet);
		return;
	}
	memcpy(iaddr.iabuf, addr, len);
	iaddr.len = len;
	subnet->net = iaddr;

	token = next_token(&val, cfile);
	if (token != TOK_NETMASK) {
		free(subnet->group);
		free(subnet);
		parse_warn("Expecting netmask");
		skip_to_semi(cfile);
		return;
	}

	/* Get the netmask. */
	if (!parse_numeric_aggregate(cfile, addr, &len, '.', 10, 8)) {
		free(subnet->group);
		free(subnet);
		return;
	}
	memcpy(iaddr.iabuf, addr, len);
	iaddr.len = len;
	subnet->netmask = iaddr;

	/* Save only the subnet number. */
	subnet->net = subnet_number(subnet->net, subnet->netmask);

	enter_subnet(subnet);

	if (!parse_lbrace(cfile))
		return;

	do {
		token = peek_token(&val, cfile);
		if (token == '}') {
			token = next_token(&val, cfile);
			break;
		} else if (token == EOF) {
			token = next_token(&val, cfile);
			parse_warn("unexpected end of file");
			break;
		}
		declaration = parse_statement(cfile, subnet->group,
		    SUBNET_DECL, NULL, declaration);
	} while (1);

	/*
	 * If this subnet supports dynamic bootp, flag it so in the
	 * shared_network containing it.
	 */
	if (subnet->group->dynamic_bootp)
		share->group->dynamic_bootp = 1;

	/* Add the subnet to the list of subnets in this shared net. */
	if (!share->subnets)
		share->subnets = subnet;
	else {
		u = NULL;
		for (t = share->subnets; t; t = t->next_sibling) {
			if (subnet_inner_than(subnet, t, 0)) {
				if (u)
					u->next_sibling = subnet;
				else
					share->subnets = subnet;
				subnet->next_sibling = t;
				return;
			}
			u = t;
		}
		u->next_sibling = subnet;
	}
}

/*
 * group-declaration :== RBRACE parameters declarations LBRACE
 */
void
parse_group_declaration(FILE *cfile, struct group *group)
{
	char *val;
	int token;
	struct group *g;
	int declaration = 0;

	g = clone_group(group, "parse_group_declaration");

	if (!parse_lbrace(cfile)) {
		free(g);
		return;
	}

	do {
		token = peek_token(&val, cfile);
		if (token == '}') {
			token = next_token(&val, cfile);
			break;
		} else if (token == EOF) {
			token = next_token(&val, cfile);
			parse_warn("unexpected end of file");
			break;
		}
		declaration = parse_statement(cfile, g, GROUP_DECL, NULL,
		    declaration);
	} while (1);
}

/*
 * cidr :== ip-address "/" bit-count
 * ip-address :== NUMBER [ DOT NUMBER [ DOT NUMBER [ DOT NUMBER ] ] ]
 * bit-count :== 0..32
 */
int
parse_cidr(FILE *cfile, unsigned char *addr, unsigned char *prefix)
{
	const char *errstr;
	char *val;
	int token;
	int len = 4;

	token = peek_token(&val, cfile);

	if (!parse_numeric_aggregate(cfile, addr, &len, '.', 10, 8)) {
		parse_warn("Expecting CIDR subnet");
		goto nocidr;
	}

	token = next_token(&val, cfile);
	if (token != '/') {
		parse_warn("Expecting '/'");
		goto nocidr;
	}

	token = next_token(&val, cfile);

	if (token == TOK_NUMBER_OR_NAME)
		*prefix = strtonum(val, 0, 32, &errstr);

	if (token != TOK_NUMBER_OR_NAME || errstr) {
		*prefix = 0;
		parse_warn("Expecting CIDR prefix length, got '%s'", val);
		goto nocidr;
	}

	return 1;

nocidr:
	if (token != ';')
		skip_to_semi(cfile);
	return 0;
}

/*
 * ip-addr-or-hostname :== ip-address | hostname
 * ip-address :== NUMBER DOT NUMBER DOT NUMBER DOT NUMBER
 *
 * Parse an ip address or a hostname.   If uniform is zero, put in
 * a TREE_LIMIT node to catch hostnames that evaluate to more than
 * one IP address.
 */
struct tree *
parse_ip_addr_or_hostname(FILE *cfile, int uniform)
{
	char *val;
	int token;
	unsigned char addr[4];
	int len = sizeof addr;
	char *name;
	struct tree *rv;
	struct hostent *h;

	name = NULL;
	h = NULL;

	token = peek_token(&val, cfile);
	if (is_identifier(token)) {
		name = parse_host_name(cfile);
		if (name)
			h = gethostbyname(name);
		if (name && h) {
			rv = tree_const(h->h_addr_list[0], h->h_length);
			if (!uniform)
				rv = tree_limit(rv, 4);
			return rv;
		}
	}

	if (token == TOK_NUMBER_OR_NAME) {
		if (!parse_numeric_aggregate(cfile, addr, &len, '.', 10, 8)) {
			parse_warn("%s (%d): expecting IP address or hostname",
				    val, token);
			return NULL;
		}
		rv = tree_const(addr, len);
	} else {
		if (token != '{' && token != '}')
			token = next_token(&val, cfile);
		parse_warn("%s (%d): expecting IP address or hostname",
			    val, token);
		if (token != ';')
			skip_to_semi(cfile);
		return NULL;
	}

	return rv;
}


/*
 * fixed-addr-parameter :== ip-addrs-or-hostnames SEMI
 * ip-addrs-or-hostnames :== ip-addr-or-hostname
 *			   | ip-addrs-or-hostnames ip-addr-or-hostname
 */
struct tree_cache *
parse_fixed_addr_param(FILE *cfile)
{
	char *val;
	int token;
	struct tree *tree = NULL;
	struct tree *tmp;

	do {
		tmp = parse_ip_addr_or_hostname(cfile, 0);
		if (tree)
			tree = tree_concat(tree, tmp);
		else
			tree = tmp;
		token = peek_token(&val, cfile);
		if (token == ',')
			token = next_token(&val, cfile);
	} while (token == ',');

	if (!parse_semi(cfile))
		return NULL;
	return tree_cache(tree);
}

/*
 * option_parameter :== identifier DOT identifier <syntax> SEMI
 *		      | identifier <syntax> SEMI
 *
 * Option syntax is handled specially through format strings, so it
 * would be painful to come up with BNF for it. However, it always
 * starts as above and ends in a SEMI.
 */
void
parse_option_param(FILE *cfile, struct group *group)
{
	char *val;
	int token;
	unsigned char buf[4];
	unsigned char cprefix;
	char *vendor;
	char *fmt;
	struct universe *universe;
	struct option *option;
	struct tree *tree = NULL;
	struct tree *t;

	token = next_token(&val, cfile);
	if (!is_identifier(token)) {
		parse_warn("expecting identifier after option keyword.");
		if (token != ';')
			skip_to_semi(cfile);
		return;
	}
	vendor = strdup(val);
	if (vendor == NULL)
		fatalx("no memory for vendor token.");
	token = peek_token(&val, cfile);
	if (token == '.') {
		/* Go ahead and take the DOT token. */
		token = next_token(&val, cfile);

		/* The next token should be an identifier. */
		token = next_token(&val, cfile);
		if (!is_identifier(token)) {
			parse_warn("expecting identifier after '.'");
			if (token != ';')
				skip_to_semi(cfile);
			free(vendor);
			return;
		}

		/*
		 * Look up the option name hash table for the specified
		 * vendor.
		 */
		universe = ((struct universe *)hash_lookup(&universe_hash,
		    (unsigned char *)vendor, 0));
		/*
		 * If it's not there, we can't parse the rest of the
		 * declaration.
		 */
		if (!universe) {
			parse_warn("no vendor named %s.", vendor);
			skip_to_semi(cfile);
			free(vendor);
			return;
		}
	} else {
		/*
		 * Use the default hash table, which contains all the
		 * standard dhcp option names.
		 */
		val = vendor;
		universe = &dhcp_universe;
	}

	/* Look up the actual option info. */
	option = (struct option *)hash_lookup(universe->hash,
	    (unsigned char *)val, 0);

	/* If we didn't get an option structure, it's an undefined option. */
	if (!option) {
		if (val == vendor)
			parse_warn("no option named %s", val);
		else
			parse_warn("no option named %s for vendor %s",
				    val, vendor);
		skip_to_semi(cfile);
		free(vendor);
		return;
	}

	/* Free the initial identifier token. */
	free(vendor);

	/* Parse the option data. */
	do {
		/*
		 * Set a flag if this is an array of a simple type (i.e.,
		 * not an array of pairs of IP addresses, or something
		 * like that.
		 */
		int uniform = option->format[1] == 'A';

		for (fmt = option->format; *fmt; fmt++) {
			if (*fmt == 'A')
				break;
			switch (*fmt) {
			case 'X':
				token = peek_token(&val, cfile);
				if (token == TOK_NUMBER_OR_NAME) {
					do {
						token = next_token
							(&val, cfile);
						if (token !=
						    TOK_NUMBER_OR_NAME) {
							parse_warn("expecting "
							    "hex number.");
							if (token != ';')
								skip_to_semi(
								    cfile);
							return;
						}
						convert_num(buf, val, 16, 8);
						tree = tree_concat(tree,
						    tree_const(buf, 1));
						token = peek_token(&val,
						    cfile);
						if (token == ':')
							token =
							    next_token(&val,
							    cfile);
					} while (token == ':');
				} else if (token == TOK_STRING) {
					token = next_token(&val, cfile);
					tree = tree_concat(tree,
					    tree_const((unsigned char *)val,
					    strlen(val)));
				} else {
					parse_warn("expecting string %s.",
					    "or hexadecimal data");
					skip_to_semi(cfile);
					return;
				}
				break;

			case 't': /* Text string. */
				token = next_token(&val, cfile);
				if (token != TOK_STRING
				    && !is_identifier(token)) {
					parse_warn("expecting string.");
					if (token != ';')
						skip_to_semi(cfile);
					return;
				}
				tree = tree_concat(tree,
				    tree_const((unsigned char *)val,
				    strlen(val)));
				break;

			case 'I': /* IP address or hostname. */
				t = parse_ip_addr_or_hostname(cfile, uniform);
				if (!t)
					return;
				tree = tree_concat(tree, t);
				break;

			case 'L': /* Unsigned 32-bit integer. */
			case 'l': /* Signed 32-bit integer. */
				token = next_token(&val, cfile);
				if (token != TOK_NUMBER && token !=
				    TOK_NUMBER_OR_NAME) {
					parse_warn("expecting number.");
					if (token != ';')
						skip_to_semi(cfile);
					return;
				}
				convert_num(buf, val, 0, 32);
				tree = tree_concat(tree, tree_const(buf, 4));
				break;
			case 's': /* Signed 16-bit integer. */
			case 'S': /* Unsigned 16-bit integer. */
				token = next_token(&val, cfile);
				if (token != TOK_NUMBER && token !=
				    TOK_NUMBER_OR_NAME) {
					parse_warn("expecting number.");
					if (token != ';')
						skip_to_semi(cfile);
					return;
				}
				convert_num(buf, val, 0, 16);
				tree = tree_concat(tree, tree_const(buf, 2));
				break;
			case 'b': /* Signed 8-bit integer. */
			case 'B': /* Unsigned 8-bit integer. */
				token = next_token(&val, cfile);
				if (token != TOK_NUMBER && token !=
				    TOK_NUMBER_OR_NAME) {
					parse_warn("expecting number.");
					if (token != ';')
						skip_to_semi(cfile);
					return;
				}
				convert_num(buf, val, 0, 8);
				tree = tree_concat(tree, tree_const(buf, 1));
				break;
			case 'f': /* Boolean flag. */
				token = next_token(&val, cfile);
				if (!is_identifier(token)) {
					parse_warn("expecting identifier.");
					if (token != ';')
						skip_to_semi(cfile);
					return;
				}
				if (!strcasecmp(val, "true")
				    || !strcasecmp(val, "on"))
					buf[0] = 1;
				else if (!strcasecmp(val, "false")
					 || !strcasecmp(val, "off"))
					buf[0] = 0;
				else {
					parse_warn("expecting boolean.");
					if (token != ';')
						skip_to_semi(cfile);
					return;
				}
				tree = tree_concat(tree, tree_const(buf, 1));
				break;
			case 'C':
				if (!parse_cidr(cfile, buf, &cprefix))
					return;
				tree = tree_concat(tree, tree_const(&cprefix,
				    sizeof(cprefix)));
				if (cprefix > 0)
					tree = tree_concat(tree, tree_const(
					    buf, (cprefix + 7) / 8));
				break;
			default:
				log_warnx("Bad format %c in "
				    "parse_option_param.", *fmt);
				skip_to_semi(cfile);
				return;
			}
		}
		if (*fmt == 'A') {
			token = peek_token(&val, cfile);
			if (token == ',') {
				token = next_token(&val, cfile);
				continue;
			}
			break;
		}
	} while (*fmt == 'A');

	token = next_token(&val, cfile);
	if (token != ';') {
		parse_warn("semicolon expected.");
		skip_to_semi(cfile);
		return;
	}
	group->options[option->code] = tree_cache(tree);
}

/*
 * lease_declaration :== LEASE ip_address LBRACE lease_parameters RBRACE
 *
 * lease_parameters :== <nil>
 *		      | lease_parameter
 *		      | lease_parameters lease_parameter
 *
 * lease_parameter :== STARTS date
 *		     | ENDS date
 *		     | TIMESTAMP date
 *		     | HARDWARE hardware-parameter
 *		     | UID hex_numbers SEMI
 *		     | HOSTNAME hostname SEMI
 *		     | CLIENT_HOSTNAME hostname SEMI
 *		     | CLASS identifier SEMI
 *		     | DYNAMIC_BOOTP SEMI
 */
struct lease *
parse_lease_declaration(FILE *cfile)
{
	char *val;
	int token;
	unsigned char addr[4];
	int len = sizeof addr;
	int seenmask = 0;
	int seenbit;
	char tbuf[32];
	static struct lease lease;

	/* Zap the lease structure. */
	memset(&lease, 0, sizeof lease);

	/* Get the address for which the lease has been issued. */
	if (!parse_numeric_aggregate(cfile, addr, &len, '.', 10, 8))
		return NULL;
	memcpy(lease.ip_addr.iabuf, addr, len);
	lease.ip_addr.len = len;

	if (!parse_lbrace(cfile))
		return NULL;

	do {
		token = next_token(&val, cfile);
		if (token == '}')
			break;
		else if (token == EOF) {
			parse_warn("unexpected end of file");
			break;
		}
		strlcpy(tbuf, val, sizeof tbuf);

		/* Parse any of the times associated with the lease. */
		if (token == TOK_STARTS || token == TOK_ENDS || token ==
		    TOK_TIMESTAMP) {
			time_t t;
			t = parse_date(cfile);
			switch (token) {
			case TOK_STARTS:
				seenbit = 1;
				lease.starts = t;
				break;

			case TOK_ENDS:
				seenbit = 2;
				lease.ends = t;
				break;

			case TOK_TIMESTAMP:
				seenbit = 4;
				lease.timestamp = t;
				break;

			default:
				/*NOTREACHED*/
				seenbit = 0;
				break;
			}
		} else {
			switch (token) {
				/* Colon-separated hexadecimal octets. */
			case TOK_UID:
				seenbit = 8;
				token = peek_token(&val, cfile);
				if (token == TOK_STRING) {
					token = next_token(&val, cfile);
					lease.uid_len = strlen(val);
					lease.uid = malloc(lease.uid_len);
					if (!lease.uid) {
						log_warnx("no space for uid");
						return NULL;
					}
					memcpy(lease.uid, val, lease.uid_len);
					parse_semi(cfile);
				} else {
					lease.uid_len = 0;
					lease.uid =
					    parse_numeric_aggregate(cfile,
					    NULL, &lease.uid_len, ':', 16, 8);
					if (!lease.uid) {
						log_warnx("no space for uid");
						return NULL;
					}
					if (lease.uid_len == 0) {
						lease.uid = NULL;
						parse_warn("zero-length uid");
						seenbit = 0;
						break;
					}
				}
				if (!lease.uid)
					fatalx("No memory for lease uid");
				break;

			case TOK_CLASS:
				seenbit = 32;
				token = next_token(&val, cfile);
				if (!is_identifier(token)) {
					if (token != ';')
						skip_to_semi(cfile);
					return NULL;
				}
				/* for now, we aren't using this. */
				break;

			case TOK_HARDWARE:
				seenbit = 64;
				parse_hardware_param(cfile,
				    &lease.hardware_addr);
				break;

			case TOK_DYNAMIC_BOOTP:
				seenbit = 128;
				lease.flags |= BOOTP_LEASE;
				break;

			case TOK_ABANDONED:
				seenbit = 256;
				lease.flags |= ABANDONED_LEASE;
				break;

			case TOK_HOSTNAME:
				seenbit = 512;
				token = peek_token(&val, cfile);
				if (token == TOK_STRING)
					lease.hostname = parse_string(cfile);
				else
					lease.hostname =
					    parse_host_name(cfile);
				if (!lease.hostname) {
					seenbit = 0;
					return NULL;
				}
				break;

			case TOK_CLIENT_HOSTNAME:
				seenbit = 1024;
				token = peek_token(&val, cfile);
				if (token == TOK_STRING)
					lease.client_hostname =
					    parse_string(cfile);
				else
					lease.client_hostname =
					    parse_host_name(cfile);
				break;

			default:
				skip_to_semi(cfile);
				seenbit = 0;
				return NULL;
			}

			if (token != TOK_HARDWARE && token != TOK_STRING) {
				token = next_token(&val, cfile);
				if (token != ';') {
					parse_warn("semicolon expected.");
					skip_to_semi(cfile);
					return NULL;
				}
			}
		}
		if (seenmask & seenbit) {
			parse_warn("Too many %s parameters in lease %s\n",
			    tbuf, piaddr(lease.ip_addr));
		} else
			seenmask |= seenbit;

	} while (1);
	return &lease;
}

/*
 * address-range-declaration :== ip-address ip-address SEMI
 *			       | DYNAMIC_BOOTP ip-address ip-address SEMI
 */
void
parse_address_range(FILE *cfile, struct subnet *subnet)
{
	struct iaddr low, high;
	unsigned char addr[4];
	int len = sizeof addr, token, dynamic = 0;
	char *val;

	if ((token = peek_token(&val, cfile)) == TOK_DYNAMIC_BOOTP) {
		token = next_token(&val, cfile);
		subnet->group->dynamic_bootp = dynamic = 1;
	}

	/* Get the bottom address in the range. */
	if (!parse_numeric_aggregate(cfile, addr, &len, '.', 10, 8))
		return;
	memcpy(low.iabuf, addr, len);
	low.len = len;

	/* Only one address? */
	token = peek_token(&val, cfile);
	if (token == ';')
		high = low;
	else {
		/* Get the top address in the range. */
		if (!parse_numeric_aggregate(cfile, addr, &len, '.', 10, 8))
			return;
		memcpy(high.iabuf, addr, len);
		high.len = len;
	}

	token = next_token(&val, cfile);
	if (token != ';') {
		parse_warn("semicolon expected.");
		skip_to_semi(cfile);
		return;
	}

	/* Create the new address range. */
	new_address_range(low, high, subnet, dynamic);
}
@


1.32
log
@Add missing function prototypes. Mark kw_cmp() as static like all
its friends.
@
text
@d1 1
a1 1
/*	$OpenBSD: confpars.c,v 1.31 2017/02/13 23:04:05 krw Exp $ */
d85 1
d321 4
@


1.31
log
@Eliminate pointless'%m' (a.k.a. hand rolled strerror()) by using fatal() and
log_warn(). Zap a couple of explicit 'syslog()' calls.
@
text
@d1 1
a1 1
/*	$OpenBSD: confpars.c,v 1.30 2017/02/13 22:33:39 krw Exp $ */
d56 2
@


1.31.4.1
log
@OpenBSD 6.1 errata 001, May 2, 2017

dhcpd(8) unconditionally echoed client identifier. Add parameter
"echo-client-id" to allow this behaviour to be turned off.
@
text
@d1 1
a1 1
/*	$OpenBSD: confpars.c,v 1.31 2017/02/13 23:04:05 krw Exp $ */
a82 1
	root_group.echo_client_id = 1;
a317 4
		break;

	case TOK_ECHO_CLIENT_ID:
		group->echo_client_id = parse_boolean(cfile);
@


1.30
log
@Adjust some long lines.
@
text
@d1 1
a1 1
/*	$OpenBSD: confpars.c,v 1.29 2017/02/13 19:13:14 krw Exp $ */
d85 1
a85 1
		fatalx("Can't open %s: %m", path_dhcpd_conf);
d129 2
a130 3
		log_warnx("Can't open lease database %s: %m -- %s",
		    path_dhcpd_db,
		    "check for failed database rewrite attempt!");
@


1.29
log
@Switch from old errwarn.c logging to shiny new log.[ch].

ok benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: confpars.c,v 1.28 2016/08/17 00:55:33 krw Exp $ */
d1081 2
a1082 1
						if (token != TOK_NUMBER_OR_NAME) {
d1093 2
a1094 1
						token = peek_token(&val, cfile);
d1096 2
a1097 1
							token = next_token(&val,
d1201 2
a1202 2
					tree = tree_concat(tree, tree_const(buf,
					    (cprefix + 7) / 8));
d1205 2
a1206 2
				log_warnx("Bad format %c in parse_option_param.",
				    *fmt);
d1282 2
a1283 1
		if (token == TOK_STARTS || token == TOK_ENDS || token == TOK_TIMESTAMP) {
@


1.28
log
@KNF and clean up many comments.
@
text
@d1 1
a1 1
/*	$OpenBSD: confpars.c,v 1.27 2016/08/17 00:38:26 krw Exp $ */
d55 1
d85 1
a85 1
		error("Can't open %s: %m", path_dhcpd_conf);
d129 1
a129 1
		warning("Can't open lease database %s: %m -- %s",
d132 2
a133 2
		warning("Please read the dhcpd.leases manual page if you");
		error("don't know what to do about this.");
d141 1
a141 1
			warning("Corrupt lease file - possible data loss!");
d254 1
a254 1
			error("No memory for shared subnet");
d269 1
a269 1
				error("no memory for subnet name");
d361 1
a361 1
			error("next-server is not known");
d538 1
a538 1
		error("can't allocate host decl struct %s.", name);
d570 1
a570 1
			error("can't allocate a tree cache for hostname.");
d605 1
a605 1
		error("No memory for class %s.", val);
d646 1
a646 1
		error("No memory for shared subnet");
d666 1
a666 1
			error("no memory for shared network name");
d725 1
a725 1
		error("No memory for new subnet");
d1002 1
a1002 1
		error("no memory for vendor token.");
d1202 1
a1202 1
				warning("Bad format %c in parse_option_param.",
d1314 1
a1314 1
						warning("no space for uid");
d1325 1
a1325 1
						warning("no space for uid");
d1336 1
a1336 1
					error("No memory for lease uid");
@


1.27
log
@Ansify function definitions.

Diff from Edgar Pettijohn.
@
text
@d1 1
a1 1
/*	$OpenBSD: confpars.c,v 1.26 2016/02/06 23:50:10 krw Exp $ */
d56 5
a60 4
/* conf-file :== parameters declarations EOF
   parameters :== <nil> | parameter | parameters parameter
   declarations :== <nil> | declaration | declarations declaration */

d74 1
a74 1
	/* Set up the global defaults... */
d101 5
a105 4
/* lease-file :== lease-declarations EOF
   lease-statments :== <nil>
		   | lease-declaration
		   | lease-declarations lease-declaration
d116 11
a126 9
	/* Open the lease file.   If we can't open it, fail.   The reason
	   for this is that although on initial startup, the absence of
	   a lease file is perfectly benign, if dhcpd has been running
	   and this file is absent, it means that dhcpd tried and failed
	   to rewrite the lease database.   If we proceed and the
	   problem which caused the rewrite to fail has been fixed, but no
	   human has corrected the database problem, then we are left
	   thinking that no leases have been assigned to anybody, which
	   could create severe network chaos. */
d155 30
a184 28
/* statement :== parameter | declaration

   parameter :== timestamp
	     | DEFAULT_LEASE_TIME lease_time
	     | MAX_LEASE_TIME lease_time
	     | DYNAMIC_BOOTP_LEASE_CUTOFF date
	     | DYNAMIC_BOOTP_LEASE_LENGTH lease_time
	     | BOOT_UNKNOWN_CLIENTS boolean
	     | GET_LEASE_HOSTNAMES boolean
	     | USE_HOST_DECL_NAME boolean
	     | NEXT_SERVER ip-addr-or-hostname SEMI
	     | option_parameter
	     | SERVER-IDENTIFIER ip-addr-or-hostname SEMI
	     | FILENAME string-parameter
	     | SERVER_NAME string-parameter
	     | hardware-parameter
	     | fixed-address-parameter
	     | ALLOW allow-deny-keyword
	     | DENY allow-deny-keyword
	     | USE_LEASE_ADDR_FOR_DEFAULT_ROUTE boolean

   declaration :== host-declaration
		 | group-declaration
		 | shared-network-declaration
		 | subnet-declaration
		 | VENDOR_CLASS class-declaration
		 | USER_CLASS class-declaration
		 | RANGE address-range-declaration */
d246 4
a249 2
		/* Otherwise, cons up a fake shared network structure
		   and populate it with the lone subnet... */
d270 4
a273 2
			/* Copy the authoritative parameter from the subnet,
			   since there is no opportunity to declare it here. */
d439 6
a444 5
/* allow-deny-keyword :== BOOTP
			| BOOTING
			| DYNAMIC_BOOTP
			| UNKNOWN_CLIENTS */

d477 3
a479 2
/* boolean :== ON SEMI | OFF SEMI | TRUE SEMI | FALSE SEMI */

d500 4
a503 3
/* Expect a left brace; if there isn't one, skip over the rest of the
   statement and return zero; otherwise, return 1. */

d520 3
a522 2
/* host-declaration :== hostname '{' parameters declarations '}' */

d584 3
a586 3
/* class-declaration :== STRING '{' parameters declarations '}'
*/

d630 4
a633 3
/* shared-network-declaration :==
			hostname LBRACE declarations parameters RBRACE */

d654 1
a654 1
	/* Get the name of the shared network... */
d707 4
a710 3
/* subnet-declaration :==
	net NETMASK netmask RBRACE parameters declarations LBRACE */

d729 1
a729 1
	/* Get the network number... */
d748 1
a748 1
	/* Get the netmask... */
d780 4
a783 2
	/* If this subnet supports dynamic bootp, flag it so in the
	   shared_network containing it. */
d807 3
a809 2
/* group-declaration :== RBRACE parameters declarations LBRACE */

d840 2
a841 1
/* cidr :== ip-address "/" bit-count
d885 8
a892 7
/* ip-addr-or-hostname :== ip-address | hostname
   ip-address :== NUMBER DOT NUMBER DOT NUMBER DOT NUMBER

   Parse an ip address or a hostname.   If uniform is zero, put in
   a TREE_LIMIT node to catch hostnames that evaluate to more than
   one IP address. */

d941 5
a945 4
/* fixed-addr-parameter :== ip-addrs-or-hostnames SEMI
   ip-addrs-or-hostnames :== ip-addr-or-hostname
			   | ip-addrs-or-hostnames ip-addr-or-hostname */

d970 8
a977 7
/* option_parameter :== identifier DOT identifier <syntax> SEMI
		      | identifier <syntax> SEMI

   Option syntax is handled specially through format strings, so it
   would be painful to come up with BNF for it.   However, it always
   starts as above and ends in a SEMI. */

d1004 1
a1004 1
		/* Go ahead and take the DOT token... */
d1007 1
a1007 1
		/* The next token should be an identifier... */
d1017 4
a1020 2
		/* Look up the option name hash table for the specified
		   vendor. */
d1023 4
a1026 2
		/* If it's not there, we can't parse the rest of the
		   declaration. */
d1034 4
a1037 2
		/* Use the default hash table, which contains all the
		   standard dhcp option names. */
d1042 1
a1042 1
	/* Look up the actual option info... */
d1061 1
a1061 1
	/* Parse the option data... */
d1063 5
a1067 3
		/* Set a flag if this is an array of a simple type (i.e.,
		   not an array of pairs of IP addresses, or something
		   like that. */
d1109 1
a1109 1
			case 't': /* Text string... */
d1130 2
a1131 2
			case 'L': /* Unsigned 32-bit integer... */
			case 'l':	/* Signed 32-bit integer... */
d1143 2
a1144 2
			case 's':	/* Signed 16-bit integer. */
			case 'S':	/* Unsigned 16-bit integer. */
d1156 2
a1157 2
			case 'b':	/* Signed 8-bit integer. */
			case 'B':	/* Unsigned 8-bit integer. */
d1226 17
a1242 16
/* lease_declaration :== LEASE ip_address LBRACE lease_parameters RBRACE

   lease_parameters :== <nil>
		      | lease_parameter
		      | lease_parameters lease_parameter

   lease_parameter :== STARTS date
		     | ENDS date
		     | TIMESTAMP date
		     | HARDWARE hardware-parameter
		     | UID hex_numbers SEMI
		     | HOSTNAME hostname SEMI
		     | CLIENT_HOSTNAME hostname SEMI
		     | CLASS identifier SEMI
		     | DYNAMIC_BOOTP SEMI */

d1255 1
a1255 1
	/* Zap the lease structure... */
d1304 1
a1304 1
				/* Colon-separated hexadecimal octets... */
d1432 1
a1432 1
	/* Get the bottom address in the range... */
d1443 1
a1443 1
		/* Get the top address in the range... */
d1457 1
a1457 1
	/* Create the new address range... */
@


1.26
log
@Eliminate #include inside *.h files and include only needed headers in
each *.c file.

Inspired by mention of header silliness by Edgar Pettijohn and mmcc@@
on tech@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: confpars.c,v 1.25 2015/08/20 22:39:29 deraadt Exp $ */
d179 3
a181 7

int parse_statement(cfile, group, type, host_decl, declaration)
	FILE *cfile;
	struct group *group;
	int type;
	struct host_decl *host_decl;
	int declaration;
d434 2
a435 4
void parse_allow_deny(cfile, group, flag)
	FILE *cfile;
	struct group *group;
	int flag;
d509 2
a510 3
void parse_host_declaration(cfile, group)
	FILE *cfile;
	struct group *group;
d573 2
a574 4
void parse_class_declaration(cfile, group, type)
	FILE *cfile;
	struct group *group;
	int type;
d619 2
a620 3
void parse_shared_net_declaration(cfile, group)
	FILE *cfile;
	struct group *group;
d695 2
a696 3
void parse_subnet_declaration(cfile, share)
	FILE *cfile;
	struct shared_network *share;
d791 2
a792 3
void parse_group_declaration(cfile, group)
	FILE *cfile;
	struct group *group;
d847 1
d872 2
a873 3
struct tree *parse_ip_addr_or_hostname(cfile, uniform)
	FILE *cfile;
	int uniform;
d924 2
a925 2
struct tree_cache *parse_fixed_addr_param(cfile)
	FILE *cfile;
d955 2
a956 3
void parse_option_param(cfile, group)
	FILE *cfile;
	struct group *group;
@


1.25
log
@stdlib.h is in scope; do not cast malloc/calloc/realloc*
ok millert krw
@
text
@d1 1
a1 1
/*	$OpenBSD: confpars.c,v 1.24 2015/05/18 17:51:21 krw Exp $ */
d41 12
@


1.24
log
@Tweak parsing so that hostnames starting with 0-9 are accepted.

Reported long ago by matthieu@@. Also Jacob Berkman via the lists.

Tests and suggestions from Jacob and Matthieu.
@
text
@d1 1
a1 1
/*	$OpenBSD: confpars.c,v 1.23 2014/07/09 13:42:24 yasuoka Exp $ */
d1280 1
a1280 2
					lease.uid = (unsigned char *)
						malloc(lease.uid_len);
@


1.23
log
@Fix classless-{ms-,}static-routes to comply RFC 3442.  Number of
octets should be changed by corresponding to the prefix length.  And 0
should be allowed for the prefix length.  Also fix white spaces.

Based on diff from Yuuichi Someya.

ok krw
@
text
@d1 1
a1 1
/*	$OpenBSD: confpars.c,v 1.22 2014/01/21 03:07:51 krw Exp $ */
d828 1
a845 1
	*prefix = 0;
d847 2
a848 2
	if (token == TOK_NUMBER)
		convert_num(prefix, val, 10, 8);
d850 2
a851 1
	if (token != TOK_NUMBER || *prefix > 32) {
d883 3
d889 14
a902 6
		if (!name)
			return NULL;
		h = gethostbyname(name);
		if (h == NULL) {
			parse_warn("%s (%d): could not resolve hostname",
			    val, token);
a904 6
		rv = tree_const(h->h_addr_list[0], h->h_length);
		if (!uniform)
			rv = tree_limit(rv, 4);
	} else if (token == TOK_NUMBER) {
		if (!parse_numeric_aggregate(cfile, addr, &len, '.', 10, 8))
			return NULL;
d1046 1
a1046 2
				if (token == TOK_NUMBER_OR_NAME ||
				    token == TOK_NUMBER) {
d1050 1
a1050 2
						if (token != TOK_NUMBER &&
						    token != TOK_NUMBER_OR_NAME) {
d1052 1
a1052 1
							    "number.");
d1103 2
a1104 1
				if (token != TOK_NUMBER) {
d1116 2
a1117 1
				if (token != TOK_NUMBER) {
d1129 2
a1130 1
				if (token != TOK_NUMBER) {
@


1.22
log
@Add parsing for options 121 (classless-static-routes) and 249
(classless-ms-static-routes). dhcpd can now specify and serve
these options and dhclient can recognize and use supersede, etc.
statements on them.

Based on a diff from Stefan Rinke. Thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: confpars.c,v 1.21 2013/10/21 12:02:25 krw Exp $ */
d826 1
a826 1
parse_cidr(FILE *cfile, unsigned char *addr, unsigned char *prefix)  
d838 1
a838 1
	
d850 1
a850 1
	if (token != TOK_NUMBER || *prefix < 1 || *prefix > 32) {
d1159 3
a1161 2
				tree = tree_concat(tree, tree_const(buf,
				    sizeof(buf)));
@


1.21
log
@Use the provided netmask on the subnet value provided in 'subnet'
statements, allowing subsequent comparisions with interface
addresses to always work properly.

Problem noted, fix tested & ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: confpars.c,v 1.20 2010/04/02 17:03:58 zinovik Exp $ */
d821 42
d956 1
d1153 8
@


1.20
log
@plug memory leaks on error paths

joint work with krw@@

ok krw@@, stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: confpars.c,v 1.19 2010/03/27 14:11:38 krw Exp $ */
d740 3
@


1.19
log
@malloc/strlcpy -> strdup. Use consistent idiom.

ok (as part of larger diff) blambert@@ kettenis@@ stsp@@ zinovik@@
@
text
@d1 1
a1 1
/*	$OpenBSD: confpars.c,v 1.18 2010/01/02 04:21:16 krw Exp $ */
d523 4
a526 1
	if (!parse_lbrace(cfile))
d528 1
d590 4
a593 1
	if (!parse_lbrace(cfile))
d595 1
d651 3
a653 1
		if (!name)
d655 1
d659 4
a662 1
	if (!parse_lbrace(cfile))
d664 1
d671 3
d713 3
a715 1
	if (!parse_numeric_aggregate(cfile, addr, &len, '.', 10, 8))
d717 1
d724 2
d732 3
a734 1
	if (!parse_numeric_aggregate(cfile, addr, &len, '.', 10, 8))
d736 1
d798 2
a799 1
	if (!parse_lbrace(cfile))
d801 1
d939 1
d952 1
d974 1
@


1.18
log
@Eliminate all uses of dmalloc() where the returned pointer
is checked for NULL and a specific error/warning issued. Add
two such manual warning/error checks and kill those dmalloc
calls. And then there were none, so kill dmalloc(). Whew.
@
text
@d1 1
a1 1
/*	$OpenBSD: confpars.c,v 1.17 2010/01/01 08:02:34 krw Exp $ */
d178 1
a178 1
	char *t, *n;
d250 2
a251 2
			t = malloc(strlen(n) + 1);
			if (!t)
a252 2
			strlcpy(t, n, (strlen(n) + 1));
			share->name = t;
d638 2
a639 2
		name = malloc(strlen(val) + 1);
		if (!name)
a640 1
		strlcpy(name, val, strlen(val) + 1);
d897 2
a898 2
	vendor = malloc(strlen(val) + 1);
	if (!vendor)
a899 1
	strlcpy(vendor, val, strlen(val) + 1);
a1336 2


@


1.17
log
@Two more calloc() wrapper wrappers, new_shared_network() and
new_subnet(), bite the dust.
@
text
@d1 1
a1 1
/*	$OpenBSD: confpars.c,v 1.16 2006/12/17 18:03:33 stevesk Exp $ */
d518 1
a518 2
	host = (struct host_decl *)dmalloc(sizeof (struct host_decl),
	    "parse_host_declaration");
@


1.16
log
@remove one-lease-per-client parameter which was never implemented (it
doesn't do anything and is not documented); ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: confpars.c,v 1.15 2006/06/13 08:47:57 jmc Exp $ */
d235 1
a235 1
		share = new_shared_network("parse_statement");
d621 1
a621 1
	share = new_shared_network("parse_shared_net_declaration");
d691 1
a691 1
	subnet = new_subnet("parse_subnet_declaration");
@


1.15
log
@typo; from sstull
ok ckuethe
@
text
@d1 1
a1 1
/*	$OpenBSD: confpars.c,v 1.14 2006/04/18 19:18:32 deraadt Exp $ */
a146 1
	     | ONE_LEASE_PER_CLIENT boolean
a293 6
	case TOK_ONE_LEASE_PER_CLIENT:
		if (type == HOST_DECL)
			parse_warn("one-lease-per-client not allowed here.");
		group->one_lease_per_client = parse_boolean(cfile);
		break;

a741 2
	if (subnet->group->one_lease_per_client)
		share->group->one_lease_per_client = 1;
@


1.14
log
@cleanup keyword lookup for the lexer, and remove keywords not valid in
either dhclient or dhcpd context; tested by many
@
text
@d1 1
a1 1
/*	$OpenBSD: confpars.c,v 1.13 2006/03/13 19:57:42 otto Exp $ */
d115 1
a115 1
		warning("Please read the dhcpd.leases manual page if you.");
@


1.13
log
@tiny bit of delinting; ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: confpars.c,v 1.12 2004/09/16 18:35:42 deraadt Exp $ */
d123 1
a123 1
		if (token != LEASE) {
d185 1
a185 1
	case HOST:
d194 1
a194 1
	case GROUP:
d203 1
a203 1
	case TIMESTAMP:
d206 1
a206 1
	case SHARED_NETWORK:
d219 1
a219 1
	case SUBNET:
d265 1
a265 1
	case VENDOR_CLASS:
d269 1
a269 1
	case USER_CLASS:
d273 1
a273 1
	case DEFAULT_LEASE_TIME:
d277 1
a277 1
	case MAX_LEASE_TIME:
d281 1
a281 1
	case DYNAMIC_BOOTP_LEASE_CUTOFF:
d285 1
a285 1
	case DYNAMIC_BOOTP_LEASE_LENGTH:
d289 1
a289 1
	case BOOT_UNKNOWN_CLIENTS:
d295 1
a295 1
	case ONE_LEASE_PER_CLIENT:
d301 1
a301 1
	case GET_LEASE_HOSTNAMES:
d307 1
a307 1
	case ALWAYS_REPLY_RFC1048:
d311 1
a311 1
	case USE_HOST_DECL_NAMES:
d317 1
a317 1
	case USE_LEASE_ADDR_FOR_DEFAULT_ROUTE:
d322 1
a322 1
	case TOKEN_NOT:
d325 1
a325 1
		case AUTHORITATIVE:
d338 1
a338 1
	case AUTHORITATIVE:
d345 1
a345 1
	case NEXT_SERVER:
d358 1
a358 1
	case OPTION:
d362 1
a362 1
	case SERVER_IDENTIFIER:
d370 1
a370 1
	case FILENAME:
d374 1
a374 1
	case SERVER_NAME:
d378 1
a378 1
	case HARDWARE:
d387 1
a387 1
	case FIXED_ADDR:
d396 1
a396 1
	case RANGE:
d405 1
a405 1
	case ALLOW:
d409 1
a409 1
	case DENY:
d445 1
a445 1
	case BOOTP:
d449 1
a449 1
	case BOOTING:
d453 1
a453 1
	case DYNAMIC_BOOTP:
d457 1
a457 1
	case UNKNOWN_CLIENTS:
d501 1
a501 1
	if (token != LBRACE) {
d510 1
a510 1
/* host-declaration :== hostname RBRACE parameters declarations LBRACE */
d538 1
a538 1
		if (token == RBRACE) {
d571 1
a571 1
/* class-declaration :== STRING LBRACE parameters declarations RBRACE
d585 1
a585 1
	if (token != STRING) {
d601 1
a601 1
		if (token == RBRACE) {
d641 1
a641 1
	if (token == STRING) {
d664 1
a664 1
		if (token == RBRACE) {
d706 1
a706 1
	if (!parse_numeric_aggregate(cfile, addr, &len, DOT, 10, 8))
d713 1
a713 1
	if (token != NETMASK) {
d720 1
a720 1
	if (!parse_numeric_aggregate(cfile, addr, &len, DOT, 10, 8))
d733 1
a733 1
		if (token == RBRACE) {
d790 1
a790 1
		if (token == RBRACE) {
d836 2
a837 2
	} else if (token == NUMBER) {
		if (!parse_numeric_aggregate(cfile, addr, &len, DOT, 10, 8))
d841 1
a841 1
		if (token != RBRACE && token != LBRACE)
d845 1
a845 1
		if (token != SEMI)
d873 1
a873 1
		if (token == COMMA)
d875 1
a875 1
	} while (token == COMMA);
d906 1
a906 1
		if (token != SEMI)
d915 1
a915 1
	if (token == DOT) {
d923 1
a923 1
			if (token != SEMI)
d977 2
a978 2
				if (token == NUMBER_OR_NAME ||
				    token == NUMBER) {
d982 2
a983 2
						if (token != NUMBER &&
						    token != NUMBER_OR_NAME) {
d986 1
a986 1
							if (token != SEMI)
d995 1
a995 1
						if (token == COLON)
d998 2
a999 2
					} while (token == COLON);
				} else if (token == STRING) {
d1014 1
a1014 1
				if (token != STRING
d1017 1
a1017 1
					if (token != SEMI)
d1036 1
a1036 1
				if (token != NUMBER) {
d1038 1
a1038 1
					if (token != SEMI)
d1048 1
a1048 1
				if (token != NUMBER) {
d1050 1
a1050 1
					if (token != SEMI)
d1060 1
a1060 1
				if (token != NUMBER) {
d1062 1
a1062 1
					if (token != SEMI)
d1073 1
a1073 1
					if (token != SEMI)
d1085 1
a1085 1
					if (token != SEMI)
d1100 1
a1100 1
			if (token == COMMA) {
d1109 1
a1109 1
	if (token != SEMI) {
d1149 1
a1149 1
	if (!parse_numeric_aggregate(cfile, addr, &len, DOT, 10, 8))
d1159 1
a1159 1
		if (token == RBRACE)
d1168 1
a1168 1
		if (token == STARTS || token == ENDS || token == TIMESTAMP) {
d1172 1
a1172 1
			case STARTS:
d1177 1
a1177 1
			case ENDS:
d1182 1
a1182 1
			case TIMESTAMP:
d1195 1
a1195 1
			case UID:
d1198 1
a1198 1
				if (token == STRING) {
d1229 1
a1229 1
			case CLASS:
d1233 1
a1233 1
					if (token != SEMI)
d1240 1
a1240 1
			case HARDWARE:
d1246 1
a1246 1
			case DYNAMIC_BOOTP:
d1251 1
a1251 1
			case ABANDONED:
d1256 1
a1256 1
			case HOSTNAME:
d1259 1
a1259 1
				if (token == STRING)
d1270 1
a1270 1
			case CLIENT_HOSTNAME:
d1273 1
a1273 1
				if (token == STRING)
d1287 1
a1287 1
			if (token != HARDWARE && token != STRING) {
d1289 1
a1289 1
				if (token != SEMI) {
d1318 1
a1318 1
	if ((token = peek_token(&val, cfile)) == DYNAMIC_BOOTP) {
d1324 1
a1324 1
	if (!parse_numeric_aggregate(cfile, addr, &len, DOT, 10, 8))
d1331 1
a1331 1
	if (token == SEMI)
d1335 1
a1335 1
		if (!parse_numeric_aggregate(cfile, addr, &len, DOT, 10, 8))
d1342 1
a1342 1
	if (token != SEMI) {
@


1.12
log
@avoid aliasing with libc functions; ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: confpars.c,v 1.11 2004/09/15 18:15:50 henning Exp $ */
d563 1
a563 2
		host->group->options[DHO_HOST_NAME]->timeout =
			0xFFFFFFFF;
a1114 15
}

/* timestamp :== date

   Timestamps are actually not used in dhcpd.conf, which is a static file,
   but rather in the database file and the journal file.  (Okay, actually
   they're not even used there yet). */

time_t
parse_timestamp(FILE *cfile)
{
	time_t rv;

	rv = parse_date(cfile);
	return rv;
@


1.11
log
@minor KNF, Moritz Jodeit <moritz@@jodeit.org>
@
text
@d1 1
a1 1
/*	$OpenBSD: confpars.c,v 1.10 2004/09/09 20:51:57 millert Exp $ */
a43 2
static time_t parsed_time;

d112 1
a112 1
		warn("Can't open lease database %s: %m -- %s",
d115 1
a115 1
		warn("Please read the dhcpd.leases manual page if you.");
d124 1
a124 1
			warn("Corrupt lease file - possible data loss!");
a203 1
		parsed_time = parse_timestamp(cfile);
d354 1
a354 1
			cache->value, group->next_server.len);
d471 2
a472 2
int parse_boolean(cfile)
	FILE *cfile;
a473 1
	int token;
d477 2
a478 3
	token = next_token(&val, cfile);
	if (!strcasecmp (val, "true")
	    || !strcasecmp (val, "on"))
d480 1
a480 2
	else if (!strcasecmp (val, "false")
		 || !strcasecmp (val, "off"))
d1093 1
a1093 1
				warn("Bad format %c in parse_option_param.",
d1124 2
a1125 2
time_t parse_timestamp(cfile)
	FILE *cfile;
d1149 2
a1150 2
struct lease *parse_lease_declaration(cfile)
	FILE *cfile;
d1220 1
a1220 1
						warn("no space for uid");
d1231 1
a1231 1
						warn("no space for uid");
@


1.10
log
@Avoid following a NULL pointer if a hostname lookup fails and
remove an extraneous "exiting" when there is a config file error.
OK henning@@ and mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: confpars.c,v 1.9 2004/05/08 06:11:53 henning Exp $ */
d118 2
a119 1
		error("don't know what to do about this.");	}
@


1.9
log
@resolve hostnames at parse time, solves PR3771, ok theo
@
text
@d1 1
a1 1
/*	$OpenBSD: confpars.c,v 1.8 2004/05/06 22:05:48 deraadt Exp $ */
d834 1
a834 1
		if (h == NULL)
d837 2
@


1.8
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: confpars.c,v 1.7 2004/04/20 05:35:33 henning Exp $ */
d826 1
d833 5
a837 1
		rv = tree_host_lookup(name);
@


1.7
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d238 1
a238 1
		share = new_shared_network ("parse_statement");
d241 1
a241 1
		share->group = clone_group (group, "parse_statement:subnet");
d252 1
a252 1
			n = piaddr (share->subnets->net);
d351 1
a351 1
		cache = tree_cache (tree);
d536 1
a536 1
	host->group = clone_group (group, "parse_host_declaration");
d600 1
a600 1
	class->group = clone_group (group, "parse_class_declaration");
d634 1
a634 1
	share = new_shared_network ("parse_shared_net_declaration");
d642 1
a642 1
	share->group = clone_group (group, "parse_shared_net_declaration");
d828 1
a828 1
	if (is_identifier (token)) {
d832 1
a832 1
		rv = tree_host_lookup (name);
d834 1
a834 1
			rv = tree_limit (rv, 4);
d838 1
a838 1
		rv = tree_const (addr, len);
d868 1
a868 1
			tree = tree_concat (tree, tmp);
d878 1
a878 1
	return tree_cache (tree);
d903 1
a903 1
	if (!is_identifier (token)) {
d920 1
a920 1
		if (!is_identifier (token)) {
d1014 1
a1014 1
				    && !is_identifier (token)) {
d1029 1
a1029 1
				tree = tree_concat (tree, t);
d1042 1
a1042 1
				tree = tree_concat(tree, tree_const (buf, 4));
d1054 1
a1054 1
				tree = tree_concat(tree, tree_const (buf, 2));
d1066 1
a1066 1
				tree = tree_concat(tree, tree_const (buf, 1));
d1070 1
a1070 1
				if (!is_identifier (token)) {
d1088 1
a1088 1
				tree = tree_concat(tree, tree_const (buf, 1));
d1113 1
a1113 1
	group->options[option->code] = tree_cache (tree);
d1246 1
a1246 1
				if (!is_identifier (token)) {
d1312 1
a1312 1
			    tbuf, piaddr (lease.ip_addr));
@


1.6
log
@more KNF
@
text
@d1 1
a1 3
/* confpars.c

   Parser for dhcpd config file... */
@


1.5
log
@more knf
@
text
@d117 2
a118 2
		      path_dhcpd_db,
		      "check for failed database rewrite attempt!");
d265 1
a265 1
			enter_shared_network (share);
d370 1
a370 2
		group->options[DHO_DHCP_SERVER_IDENTIFIER] =
			tree_cache (tree);
d561 1
a561 1
			new_tree_cache ("parse_host_declaration");
d576 1
a576 1
	enter_host (host);
d678 1
a678 1
			enter_shared_network (share);
d734 1
a734 1
	enter_subnet (subnet);
d931 2
a932 3
		universe = ((struct universe *)
			    hash_lookup (&universe_hash,
					 (unsigned char *)vendor, 0));
d948 2
a949 2
	option = (struct option *)hash_lookup (universe->hash,
					       (unsigned char *)val, 0);
d963 1
a963 1
	free (vendor);
d983 13
a995 9
						if (token != NUMBER
						    && token != NUMBER_OR_NAME)
							goto need_number;
						convert_num (buf, val, 16, 8);
						tree = tree_concat
							(tree,
							 tree_const (buf, 1));
						token = peek_token
							(&val, cfile);
d997 2
a998 2
							token = next_token
								(&val, cfile);
d1002 3
a1004 5
					tree = tree_concat
						(tree,
						 tree_const ((unsigned char *)
							     val,
							     strlen(val)));
d1007 1
a1007 1
						    "or hexadecimal data");
d1022 3
a1024 4
				tree = tree_concat
					(tree,
					 tree_const ((unsigned char *)val,
						     strlen(val)));
a1037 1
				      need_number:
d1043 2
a1044 2
				convert_num (buf, val, 0, 32);
				tree = tree_concat (tree, tree_const (buf, 4));
d1049 8
a1056 4
				if (token != NUMBER)
					goto need_number;
				convert_num (buf, val, 0, 16);
				tree = tree_concat (tree, tree_const (buf, 2));
d1061 8
a1068 4
				if (token != NUMBER)
					goto need_number;
				convert_num (buf, val, 0, 8);
				tree = tree_concat (tree, tree_const (buf, 1));
a1073 1
				      bad_flag:
d1078 2
a1079 2
				if (!strcasecmp (val, "true")
				    || !strcasecmp (val, "on"))
d1081 2
a1082 2
				else if (!strcasecmp (val, "false")
					 || !strcasecmp (val, "off"))
d1086 3
a1088 1
					goto bad_flag;
d1090 1
a1090 1
				tree = tree_concat (tree, tree_const (buf, 1));
d1094 1
a1094 1
				      *fmt);
d1227 2
a1228 1
					lease.uid = parse_numeric_aggregate(cfile,
@


1.4
log
@various knf; henning ok
@
text
@d52 2
a53 1
int readconf ()
d60 1
a60 1
	new_parse (path_dhcpd_conf);
d63 1
a63 1
	initialize_universes ();
d74 2
a75 3
	if ((cfile = fopen (path_dhcpd_conf, "r")) == NULL) {
		error ("Can't open %s: %m", path_dhcpd_conf);
	}
d78 1
a78 1
		token = peek_token (&val, cfile);
d81 1
a81 1
		declaration = parse_statement (cfile, &root_group,
d83 1
a83 1
						 (struct host_decl *)0,
d86 1
a86 1
	token = next_token (&val, cfile); /* Clear the peek buffer */
d95 4
a98 3
		   | lease-declarations lease-declaration */

void read_leases ()
d104 1
a104 1
	new_parse (path_dhcpd_db);
d115 2
a116 2
	if ((cfile = fopen (path_dhcpd_db, "r")) == NULL) {
		warn ("Can't open lease database %s: %m -- %s",
d119 2
a120 2
		warn ("Please read the dhcpd.leases manual page if you.");
		error ("don't know what to do about this.");	}
d123 1
a123 1
		token = next_token (&val, cfile);
d127 2
a128 2
			warn ("Corrupt lease file - possible data loss!");
			skip_to_semi (cfile);
d131 1
a131 1
			lease = parse_lease_declaration (cfile);
d133 1
a133 1
				enter_lease (lease);
d135 1
a135 1
				parse_warn ("possibly corrupt lease file");
d172 1
a172 1
int parse_statement (cfile, group, type, host_decl, declaration)
d187 2
a188 2
	switch (next_token (&val, cfile)) {
	      case HOST:
d190 1
a190 1
			parse_host_declaration (cfile, group);
d192 2
a193 2
			parse_warn ("host declarations not allowed here.");
			skip_to_semi (cfile);
d197 1
a197 1
	      case GROUP:
d199 1
a199 1
			parse_group_declaration (cfile, group);
d201 2
a202 2
			parse_warn ("host declarations not allowed here.");
			skip_to_semi (cfile);
d206 2
a207 2
	      case TIMESTAMP:
		parsed_time = parse_timestamp (cfile);
d210 1
a210 1
	      case SHARED_NETWORK:
d214 1
a214 1
			parse_warn ("shared-network parameters not %s.",
d216 1
a216 1
			skip_to_semi (cfile);
d220 1
a220 1
		parse_shared_net_declaration (cfile, group);
d223 1
a223 1
	      case SUBNET:
d225 2
a226 2
			parse_warn ("subnet declarations not allowed here.");
			skip_to_semi (cfile);
d232 2
a233 2
			parse_subnet_declaration (cfile,
						  group->shared_network);
d242 1
a242 1
			error ("No memory for shared subnet");
d246 1
a246 1
		parse_subnet_declaration (cfile, share);
d255 1
a255 1
			t = malloc (strlen (n) + 1);
d257 2
a258 2
				error ("no memory for subnet name");
			strlcpy (t, n, (strlen(n) + 1));
d269 2
a270 2
	      case VENDOR_CLASS:
		parse_class_declaration (cfile, group, 0);
d273 2
a274 2
	      case USER_CLASS:
		parse_class_declaration (cfile, group, 1);
d277 2
a278 2
	      case DEFAULT_LEASE_TIME:
		parse_lease_time (cfile, &group->default_lease_time);
d281 2
a282 2
	      case MAX_LEASE_TIME:
		parse_lease_time (cfile, &group->max_lease_time);
d285 2
a286 2
	      case DYNAMIC_BOOTP_LEASE_CUTOFF:
		group->bootp_lease_cutoff = parse_date (cfile);
d289 2
a290 2
	      case DYNAMIC_BOOTP_LEASE_LENGTH:
		parse_lease_time (cfile, &group->bootp_lease_length);
d293 1
a293 1
	      case BOOT_UNKNOWN_CLIENTS:
d295 2
a296 2
			parse_warn ("boot-unknown-clients not allowed here.");
		group->boot_unknown_clients = parse_boolean (cfile);
d299 1
a299 1
	      case ONE_LEASE_PER_CLIENT:
d301 2
a302 2
			parse_warn ("one-lease-per-client not allowed here.");
		group->one_lease_per_client = parse_boolean (cfile);
d305 1
a305 1
	      case GET_LEASE_HOSTNAMES:
d307 2
a308 2
			parse_warn ("get-lease-hostnames not allowed here.");
		group->get_lease_hostnames = parse_boolean (cfile);
d311 2
a312 2
	      case ALWAYS_REPLY_RFC1048:
		group->always_reply_rfc1048 = parse_boolean (cfile);
d315 1
a315 1
	      case USE_HOST_DECL_NAMES:
d317 2
a318 2
			parse_warn ("use-host-decl-names not allowed here.");
		group->use_host_decl_names = parse_boolean (cfile);
d321 1
a321 1
	      case USE_LEASE_ADDR_FOR_DEFAULT_ROUTE:
d323 1
a323 1
			parse_boolean (cfile);
d326 2
a327 2
	      case TOKEN_NOT:
		token = next_token (&val, cfile);
d329 1
a329 1
		      case AUTHORITATIVE:
d331 1
a331 1
			    parse_warn ("authority makes no sense here.");
d333 1
a333 1
			parse_semi (cfile);
d335 3
a337 3
		      default:
			parse_warn ("expecting assertion");
			skip_to_semi (cfile);
d342 1
a342 1
	      case AUTHORITATIVE:
d344 1
a344 1
		    parse_warn ("authority makes no sense here.");
d346 1
a346 1
		parse_semi (cfile);
d349 2
a350 2
	      case NEXT_SERVER:
		tree = parse_ip_addr_or_hostname (cfile, 0);
d355 1
a355 1
			error ("next-server is not known");
d357 1
a357 1
		memcpy (group->next_server.iabuf,
d359 1
a359 1
		parse_semi (cfile);
d362 2
a363 2
	      case OPTION:
		parse_option_param (cfile, group);
d366 2
a367 2
	      case SERVER_IDENTIFIER:
		tree = parse_ip_addr_or_hostname (cfile, 0);
d372 1
a372 1
		token = next_token (&val, cfile);
d375 2
a376 2
	      case FILENAME:
		group->filename = parse_string (cfile);
d379 2
a380 2
	      case SERVER_NAME:
		group->server_name = parse_string (cfile);
d383 2
a384 2
	      case HARDWARE:
		parse_hardware_param (cfile, &hardware);
d388 1
a388 1
			parse_warn ("hardware address parameter %s",
d392 2
a393 2
	      case FIXED_ADDR:
		cache = parse_fixed_addr_param (cfile);
d397 1
a397 1
			parse_warn ("fixed-address parameter not %s",
d401 1
a401 1
	      case RANGE:
d403 2
a404 2
			parse_warn ("range declaration not allowed here.");
			skip_to_semi (cfile);
d407 1
a407 1
		parse_address_range (cfile, group->subnet);
d410 2
a411 2
	      case ALLOW:
		parse_allow_deny (cfile, group, 1);
d414 2
a415 2
	      case DENY:
		parse_allow_deny (cfile, group, 0);
d418 1
a418 1
	      default:
d420 1
a420 1
			parse_warn ("expecting a declaration.");
d422 2
a423 2
			parse_warn ("expecting a parameter or declaration.");
		skip_to_semi (cfile);
d428 1
a428 1
		parse_warn ("parameters not allowed after first declaration.");
d440 1
a440 1
void parse_allow_deny (cfile, group, flag)
d448 1
a448 1
	token = next_token (&val, cfile);
d450 1
a450 1
	      case BOOTP:
d454 1
a454 1
	      case BOOTING:
d458 1
a458 1
	      case DYNAMIC_BOOTP:
d462 1
a462 1
	      case UNKNOWN_CLIENTS:
d466 3
a468 3
	      default:
		parse_warn ("expecting allow/deny key");
		skip_to_semi (cfile);
d471 1
a471 1
	parse_semi (cfile);
d476 1
a476 1
int parse_boolean (cfile)
d483 1
a483 1
	token = next_token (&val, cfile);
d491 2
a492 2
		parse_warn ("boolean value (true/false/on/off) expected");
		skip_to_semi (cfile);
d495 1
a495 1
	parse_semi (cfile);
d502 2
a503 2
int parse_lbrace (cfile)
	FILE *cfile;
d508 1
a508 1
	token = next_token (&val, cfile);
d510 2
a511 2
		parse_warn ("expecting left brace.");
		skip_to_semi (cfile);
d520 1
a520 1
void parse_host_declaration (cfile, group)
d527 1
a527 1
	char *name = parse_host_name (cfile);
d533 2
a534 2
	host = (struct host_decl *)dmalloc (sizeof (struct host_decl),
					    "parse_host_declaration");
d536 1
a536 1
		error ("can't allocate host decl struct %s.", name);
d541 1
a541 1
	if (!parse_lbrace (cfile))
d545 1
a545 1
		token = peek_token (&val, cfile);
d547 1
a547 1
			token = next_token (&val, cfile);
d551 2
a552 2
			token = next_token (&val, cfile);
			parse_warn ("unexpected end of file");
d555 2
a556 3
		declaration = parse_statement (cfile, host->group,
					       HOST_DECL, host,
					       declaration);
d564 1
a564 1
			error ("can't allocate a tree cache for hostname.");
d566 1
a566 1
			strlen (name);
d574 1
a574 1
			(struct tree *)0;
d583 1
a583 1
void parse_class_declaration (cfile, group, type)
d593 1
a593 1
	token = next_token (&val, cfile);
d595 2
a596 2
		parse_warn ("Expecting class name");
		skip_to_semi (cfile);
d602 1
a602 1
		error ("No memory for class %s.", val);
d605 1
a605 1
	if (!parse_lbrace (cfile))
d609 1
a609 1
		token = peek_token (&val, cfile);
d611 1
a611 1
			token = next_token (&val, cfile);
d614 2
a615 2
			token = next_token (&val, cfile);
			parse_warn ("unexpected end of file");
d618 2
a619 4
			declaration = parse_statement (cfile, class->group,
						       CLASS_DECL,
						       (struct host_decl *)0,
						       declaration);
d627 1
a627 1
void parse_shared_net_declaration (cfile, group)
d639 6
a644 6
		error ("No memory for shared subnet");
	share->leases = (struct lease *)0;
	share->last_lease = (struct lease *)0;
	share->insertion_point = (struct lease *)0;
	share->next = (struct shared_network *)0;
	share->interface = (struct interface_info *)0;
d649 1
a649 1
	token = peek_token (&val, cfile);
d651 1
a651 1
		token = next_token (&val, cfile);
d654 1
a654 1
			parse_warn ("zero-length shared network name");
d657 1
a657 1
		name = malloc (strlen (val) + 1);
d659 2
a660 2
			error ("no memory for shared network name");
		strlcpy (name, val, strlen(val) + 1);
d662 1
a662 1
		name = parse_host_name (cfile);
d668 1
a668 1
	if (!parse_lbrace (cfile))
d672 1
a672 1
		token = peek_token (&val, cfile);
d674 1
a674 1
			token = next_token (&val, cfile);
d676 1
a676 1
				parse_warn ("empty shared-network decl");
d682 2
a683 2
			token = next_token (&val, cfile);
			parse_warn ("unexpected end of file");
d687 2
a688 4
		declaration = parse_statement (cfile, share->group,
					       SHARED_NET_DECL,
					       (struct host_decl *)0,
					       declaration);
d695 1
a695 1
void parse_subnet_declaration (cfile, share)
d707 1
a707 1
	subnet = new_subnet ("parse_subnet_declaration");
d709 1
a709 1
		error ("No memory for new subnet");
d711 1
a711 2
	subnet->group = clone_group (share->group,
				       "parse_subnet_declaration");
d715 1
a715 1
	if (!parse_numeric_aggregate (cfile, addr, &len, DOT, 10, 8))
d717 1
a717 1
	memcpy (iaddr.iabuf, addr, len);
d721 1
a721 1
	token = next_token (&val, cfile);
d723 2
a724 2
		parse_warn ("Expecting netmask");
		skip_to_semi (cfile);
d729 1
a729 1
	if (!parse_numeric_aggregate (cfile, addr, &len, DOT, 10, 8))
d731 1
a731 1
	memcpy (iaddr.iabuf, addr, len);
d737 1
a737 1
	if (!parse_lbrace (cfile))
d741 1
a741 1
		token = peek_token (&val, cfile);
d743 1
a743 1
			token = next_token (&val, cfile);
d746 2
a747 2
			token = next_token (&val, cfile);
			parse_warn ("unexpected end of file");
d750 2
a751 4
		declaration = parse_statement (cfile, subnet->group,
					       SUBNET_DECL,
					       (struct host_decl *)0,
					       declaration);
d765 1
a765 1
		u = (struct subnet *)0;
d767 1
a767 1
			if (subnet_inner_than (subnet, t, 0)) {
d783 1
a783 1
void parse_group_declaration (cfile, group)
d792 1
a792 1
	g = clone_group (group, "parse_group_declaration");
d794 1
a794 1
	if (!parse_lbrace (cfile))
d798 1
a798 1
		token = peek_token (&val, cfile);
d800 1
a800 1
			token = next_token (&val, cfile);
d803 2
a804 2
			token = next_token (&val, cfile);
			parse_warn ("unexpected end of file");
d807 2
a808 3
		declaration = parse_statement (cfile, g, GROUP_DECL,
					       (struct host_decl *)0,
					       declaration);
d819 1
a819 1
struct tree *parse_ip_addr_or_hostname (cfile, uniform)
d830 1
a830 1
	token = peek_token (&val, cfile);
d832 1
a832 1
		name = parse_host_name (cfile);
d834 1
a834 1
			return (struct tree *)0;
d839 2
a840 2
		if (!parse_numeric_aggregate (cfile, addr, &len, DOT, 10, 8))
			return (struct tree *)0;
d844 2
a845 2
			token = next_token (&val, cfile);
		parse_warn ("%s (%d): expecting IP address or hostname",
d848 2
a849 2
			skip_to_semi (cfile);
		return (struct tree *)0;
d860 1
a860 1
struct tree_cache *parse_fixed_addr_param (cfile)
d865 1
a865 1
	struct tree *tree = (struct tree *)0;
d869 1
a869 1
		tmp = parse_ip_addr_or_hostname (cfile, 0);
d874 1
a874 1
		token = peek_token (&val, cfile);
d876 1
a876 1
			token = next_token (&val, cfile);
d879 2
a880 2
	if (!parse_semi (cfile))
		return (struct tree_cache *)0;
d891 1
a891 1
void parse_option_param (cfile, group)
d902 1
a902 1
	struct tree *tree = (struct tree *)0;
d905 1
a905 1
	token = next_token (&val, cfile);
d907 1
a907 1
		parse_warn ("expecting identifier after option keyword.");
d909 1
a909 1
			skip_to_semi (cfile);
d912 1
a912 1
	vendor = malloc (strlen (val) + 1);
d914 3
a916 3
		error ("no memory for vendor token.");
	strlcpy (vendor, val, strlen(val) + 1);
	token = peek_token (&val, cfile);
d919 1
a919 1
		token = next_token (&val, cfile);
d922 1
a922 1
		token = next_token (&val, cfile);
d924 1
a924 1
			parse_warn ("expecting identifier after '.'");
d926 1
a926 1
				skip_to_semi (cfile);
d938 2
a939 2
			parse_warn ("no vendor named %s.", vendor);
			skip_to_semi (cfile);
d956 1
a956 1
			parse_warn ("no option named %s", val);
d958 1
a958 1
			parse_warn ("no option named %s for vendor %s",
d960 1
a960 1
		skip_to_semi (cfile);
d978 2
a979 2
			      case 'X':
				token = peek_token (&val, cfile);
d999 1
a999 1
					token = next_token (&val, cfile);
d1004 1
a1004 1
							     strlen (val)));
d1006 1
a1006 1
					parse_warn ("expecting string %s.",
d1008 1
a1008 1
					skip_to_semi (cfile);
d1013 2
a1014 2
			      case 't': /* Text string... */
				token = next_token (&val, cfile);
d1017 1
a1017 1
					parse_warn ("expecting string.");
d1019 1
a1019 1
						skip_to_semi (cfile);
d1025 1
a1025 1
						     strlen (val)));
d1028 2
a1029 2
			      case 'I': /* IP address or hostname. */
				t = parse_ip_addr_or_hostname (cfile, uniform);
d1035 3
a1037 3
			      case 'L': /* Unsigned 32-bit integer... */
			      case 'l':	/* Signed 32-bit integer... */
				token = next_token (&val, cfile);
d1040 1
a1040 1
					parse_warn ("expecting number.");
d1042 1
a1042 1
						skip_to_semi (cfile);
d1048 3
a1050 3
			      case 's':	/* Signed 16-bit integer. */
			      case 'S':	/* Unsigned 16-bit integer. */
				token = next_token (&val, cfile);
d1056 3
a1058 3
			      case 'b':	/* Signed 8-bit integer. */
			      case 'B':	/* Unsigned 8-bit integer. */
				token = next_token (&val, cfile);
d1064 2
a1065 2
			      case 'f': /* Boolean flag. */
				token = next_token (&val, cfile);
d1067 1
a1067 1
					parse_warn ("expecting identifier.");
d1070 1
a1070 1
						skip_to_semi (cfile);
d1080 1
a1080 1
					parse_warn ("expecting boolean.");
d1085 2
a1086 2
			      default:
				warn ("Bad format %c in parse_option_param.",
d1088 1
a1088 1
				skip_to_semi (cfile);
d1093 1
a1093 1
			token = peek_token (&val, cfile);
d1095 1
a1095 1
				token = next_token (&val, cfile);
d1102 1
a1102 1
	token = next_token (&val, cfile);
d1104 2
a1105 2
		parse_warn ("semicolon expected.");
		skip_to_semi (cfile);
d1117 1
a1117 1
time_t parse_timestamp (cfile)
d1122 1
a1122 1
	rv = parse_date (cfile);
d1142 1
a1142 1
struct lease *parse_lease_declaration (cfile)
d1155 1
a1155 1
	memset (&lease, 0, sizeof lease);
d1158 3
a1160 3
	if (!parse_numeric_aggregate (cfile, addr, &len, DOT, 10, 8))
		return (struct lease *)0;
	memcpy (lease.ip_addr.iabuf, addr, len);
d1163 2
a1164 2
	if (!parse_lbrace (cfile))
		return (struct lease *)0;
d1167 1
a1167 1
		token = next_token (&val, cfile);
d1171 1
a1171 1
			parse_warn ("unexpected end of file");
d1174 1
a1174 1
		strlcpy (tbuf, val, sizeof tbuf);
d1179 1
a1179 1
			t = parse_date (cfile);
d1181 1
a1181 1
			      case STARTS:
d1186 1
a1186 1
			      case ENDS:
d1191 1
a1191 1
			      case TIMESTAMP:
d1196 1
a1196 1
			      default:
d1204 1
a1204 1
			      case UID:
d1206 1
a1206 1
				token = peek_token (&val, cfile);
d1208 2
a1209 2
					token = next_token (&val, cfile);
					lease.uid_len = strlen (val);
d1211 1
a1211 1
						malloc (lease.uid_len);
d1213 2
a1214 2
						warn ("no space for uid");
						return (struct lease *)0;
d1216 2
a1217 2
					memcpy (lease.uid, val, lease.uid_len);
					parse_semi (cfile);
d1220 2
a1221 3
					lease.uid = parse_numeric_aggregate
						(cfile, (unsigned char *)0,
						 &lease.uid_len, ':', 16, 8);
d1223 2
a1224 2
						warn ("no space for uid");
						return (struct lease *)0;
d1227 2
a1228 2
						lease.uid = (unsigned char *)0;
						parse_warn ("zero-length uid");
d1233 2
a1234 3
				if (!lease.uid) {
					error ("No memory for lease uid");
				}
d1237 1
a1237 1
			      case CLASS:
d1239 1
a1239 1
				token = next_token (&val, cfile);
d1242 2
a1243 2
						skip_to_semi (cfile);
					return (struct lease *)0;
d1248 1
a1248 1
			      case HARDWARE:
d1250 2
a1251 2
				parse_hardware_param (cfile,
						     &lease.hardware_addr);
d1254 1
a1254 1
			      case DYNAMIC_BOOTP:
d1259 1
a1259 1
			      case ABANDONED:
d1264 1
a1264 1
			      case HOSTNAME:
d1266 1
a1266 1
				token = peek_token (&val, cfile);
d1268 1
a1268 1
					lease.hostname = parse_string (cfile);
d1271 1
a1271 1
						parse_host_name (cfile);
d1274 1
a1274 1
					return (struct lease *)0;
d1278 1
a1278 1
			      case CLIENT_HOSTNAME:
d1280 1
a1280 1
				token = peek_token (&val, cfile);
d1283 1
a1283 1
						parse_string (cfile);
d1286 1
a1286 1
						parse_host_name (cfile);
d1289 2
a1290 2
			      default:
				skip_to_semi (cfile);
d1292 1
a1292 1
				return (struct lease *)0;
d1296 1
a1296 1
				token = next_token (&val, cfile);
d1298 3
a1300 3
					parse_warn ("semicolon expected.");
					skip_to_semi (cfile);
					return (struct lease *)0;
d1305 2
a1306 2
			parse_warn ("Too many %s parameters in lease %s\n",
				    tbuf, piaddr (lease.ip_addr));
d1314 6
a1319 6
/* address-range-declaration :== ip-address ip-address SEMI
			       | DYNAMIC_BOOTP ip-address ip-address SEMI */

void parse_address_range (cfile, subnet)
	FILE *cfile;
	struct subnet *subnet;
d1323 1
a1323 2
	int len = sizeof addr;
	int token;
a1324 1
	int dynamic = 0;
d1326 2
a1327 2
	if ((token = peek_token (&val, cfile)) == DYNAMIC_BOOTP) {
		token = next_token (&val, cfile);
d1332 1
a1332 1
	if (!parse_numeric_aggregate (cfile, addr, &len, DOT, 10, 8))
d1334 1
a1334 1
	memcpy (low.iabuf, addr, len);
d1338 1
a1338 1
	token = peek_token (&val, cfile);
d1342 2
a1343 2
	/* Get the top address in the range... */
		if (!parse_numeric_aggregate (cfile, addr, &len, DOT, 10, 8))
d1345 1
a1345 1
		memcpy (high.iabuf, addr, len);
d1349 1
a1349 1
	token = next_token (&val, cfile);
d1351 2
a1352 2
		parse_warn ("semicolon expected.");
		skip_to_semi (cfile);
d1357 1
a1357 1
	new_address_range (low, high, subnet, dynamic);
@


1.3
log
@spaces
@
text
@d230 1
a230 1
		if (group -> shared_network) {
d232 1
a232 1
						  group -> shared_network);
d242 2
a243 2
		share -> group = clone_group (group, "parse_statement:subnet");
		share -> group -> shared_network = share;
d247 4
a250 4
		/* share -> subnets is the subnet we just parsed. */
		if (share -> subnets) {
			share -> interface =
				share -> subnets -> interface;
d253 1
a253 1
			n = piaddr (share -> subnets -> net);
d258 1
a258 1
			share -> name = t;
d262 2
a263 2
			share -> group -> authoritative =
				share -> subnets -> group -> authoritative;
d277 1
a277 1
		parse_lease_time (cfile, &group -> default_lease_time);
d281 1
a281 1
		parse_lease_time (cfile, &group -> max_lease_time);
d285 1
a285 1
		group -> bootp_lease_cutoff = parse_date (cfile);
d289 1
a289 1
		parse_lease_time (cfile, &group -> bootp_lease_length);
d295 1
a295 1
		group -> boot_unknown_clients = parse_boolean (cfile);
d301 1
a301 1
		group -> one_lease_per_client = parse_boolean (cfile);
d307 1
a307 1
		group -> get_lease_hostnames = parse_boolean (cfile);
d311 1
a311 1
		group -> always_reply_rfc1048 = parse_boolean (cfile);
d317 1
a317 1
		group -> use_host_decl_names = parse_boolean (cfile);
d321 1
a321 1
		group -> use_lease_addr_for_default_route =
d331 1
a331 1
			group -> authoritative = 0;
d344 1
a344 1
		group -> authoritative = 1;
d355 3
a357 3
		group -> next_server.len = 4;
		memcpy (group -> next_server.iabuf,
			cache -> value, group -> next_server.len);
d369 1
a369 1
		group -> options [DHO_DHCP_SERVER_IDENTIFIER] =
d375 1
a375 1
		group -> filename = parse_string (cfile);
d379 1
a379 1
		group -> server_name = parse_string (cfile);
d385 1
a385 1
			host_decl -> interface = hardware;
d394 1
a394 1
			host_decl -> fixed_addr = cache;
d401 1
a401 1
		if (type != SUBNET_DECL || !group -> subnet) {
d406 1
a406 1
		parse_address_range (cfile, group -> subnet);
d450 1
a450 1
		group -> allow_bootp = flag;
d454 1
a454 1
		group -> allow_booting = flag;
d458 1
a458 1
		group -> dynamic_bootp = flag;
d462 1
a462 1
		group -> boot_unknown_clients = flag;
d537 2
a538 2
	host -> name = name;
	host -> group = clone_group (group, "parse_host_declaration");
d554 1
a554 1
		declaration = parse_statement (cfile, host -> group,
d559 3
a561 3
	if (!host -> group -> options [DHO_HOST_NAME] &&
	    host -> group -> use_host_decl_names) {
		host -> group -> options [DHO_HOST_NAME] =
d563 1
a563 1
		if (!host -> group -> options [DHO_HOST_NAME])
d565 1
a565 1
		host -> group -> options [DHO_HOST_NAME] -> len =
d567 1
a567 1
		host -> group -> options [DHO_HOST_NAME] -> value =
d569 3
a571 3
		host -> group -> options [DHO_HOST_NAME] -> buf_size =
			host -> group -> options [DHO_HOST_NAME] -> len;
		host -> group -> options [DHO_HOST_NAME] -> timeout =
d573 1
a573 1
		host -> group -> options [DHO_HOST_NAME] -> tree =
d603 1
a603 1
	class -> group = clone_group (group, "parse_class_declaration");
d618 1
a618 1
			declaration = parse_statement (cfile, class -> group,
d642 7
a648 7
	share -> leases = (struct lease *)0;
	share -> last_lease = (struct lease *)0;
	share -> insertion_point = (struct lease *)0;
	share -> next = (struct shared_network *)0;
	share -> interface = (struct interface_info *)0;
	share -> group = clone_group (group, "parse_shared_net_declaration");
	share -> group -> shared_network = share;
d655 1
a655 1
		if (val [0] == 0) {
d668 1
a668 1
	share -> name = name;
d677 1
a677 1
			if (!share -> subnets) {
d689 1
a689 1
		declaration = parse_statement (cfile, share -> group,
d707 1
a707 1
	unsigned char addr [4];
d714 2
a715 2
	subnet -> shared_network = share;
	subnet -> group = clone_group (share -> group,
d717 1
a717 1
	subnet -> group -> subnet = subnet;
d724 1
a724 1
	subnet -> net = iaddr;
d738 1
a738 1
	subnet -> netmask = iaddr;
d755 1
a755 1
		declaration = parse_statement (cfile, subnet -> group,
d763 4
a766 4
	if (subnet -> group -> dynamic_bootp)
		share -> group -> dynamic_bootp = 1;
	if (subnet -> group -> one_lease_per_client)
		share -> group -> one_lease_per_client = 1;
d769 2
a770 2
	if (!share -> subnets)
		share -> subnets = subnet;
d773 1
a773 1
		for (t = share -> subnets; t; t = t -> next_sibling) {
d776 1
a776 1
					u -> next_sibling = subnet;
d778 2
a779 2
					share -> subnets = subnet;
				subnet -> next_sibling = t;
d784 1
a784 1
		u -> next_sibling = subnet;
d833 1
a833 1
	unsigned char addr [4];
d905 1
a905 1
	unsigned char buf [4];
d958 1
a958 1
	option = (struct option *)hash_lookup (universe -> hash,
d980 1
a980 1
		int uniform = option -> format [1] == 'A';
d982 1
a982 1
		for (fmt = option -> format; *fmt; fmt++) {
d1083 1
a1083 1
					buf [0] = 1;
d1086 1
a1086 1
					buf [0] = 0;
d1116 1
a1116 1
	group -> options [option -> code] = tree_cache (tree);
d1155 1
a1155 1
	unsigned char addr [4];
d1159 1
a1159 1
	char tbuf [32];
d1332 1
a1332 1
	unsigned char addr [4];
d1340 1
a1340 1
		subnet -> group -> dynamic_bootp = dynamic = 1;
@


1.2
log
@time_t and kill a few dumb defines
@
text
@d94 2
a95 2
   		     | lease-declaration
		     | lease-declarations lease-declaration */
d107 1
a107 1
	   a lease file is perfectly benign, if dhcpd has been running 
d144 18
a161 18
   	       | DEFAULT_LEASE_TIME lease_time
	       | MAX_LEASE_TIME lease_time
	       | DYNAMIC_BOOTP_LEASE_CUTOFF date
	       | DYNAMIC_BOOTP_LEASE_LENGTH lease_time
	       | BOOT_UNKNOWN_CLIENTS boolean
	       | ONE_LEASE_PER_CLIENT boolean
	       | GET_LEASE_HOSTNAMES boolean
	       | USE_HOST_DECL_NAME boolean
	       | NEXT_SERVER ip-addr-or-hostname SEMI
	       | option_parameter
	       | SERVER-IDENTIFIER ip-addr-or-hostname SEMI
	       | FILENAME string-parameter
	       | SERVER_NAME string-parameter
	       | hardware-parameter
	       | fixed-address-parameter
	       | ALLOW allow-deny-keyword
	       | DENY allow-deny-keyword
	       | USE_LEASE_ADDR_FOR_DEFAULT_ROUTE boolean
d330 1
a330 1
			    parse_warn ("authority makes no sense here."); 
d340 1
a340 1
			
d343 1
a343 1
		    parse_warn ("authority makes no sense here."); 
d360 1
a360 1
			
d373 1
a373 1
			
d435 1
a435 1
   			| BOOTING
d822 1
a822 1
   
d861 2
a862 2
}	
	
d1020 1
a1020 1
					
d1133 1
a1133 1
		
d1193 1
a1193 1
			
d1198 1
a1198 1
				
@


1.1
log
@may the whacking begin
@
text
@d46 1
a46 1
static TIME parsed_time;
d1125 1
a1125 1
TIME parse_timestamp (cfile)
d1128 1
a1128 1
	TIME rv;
d1186 1
a1186 1
			TIME t;
@

