head	1.18;
access;
symbols
	OPENBSD_6_1:1.18.0.4
	OPENBSD_6_1_BASE:1.18
	OPENBSD_6_0:1.17.0.4
	OPENBSD_6_0_BASE:1.17
	OPENBSD_5_9:1.17.0.2
	OPENBSD_5_9_BASE:1.17
	OPENBSD_5_8:1.15.0.26
	OPENBSD_5_8_BASE:1.15
	OPENBSD_5_7:1.15.0.18
	OPENBSD_5_7_BASE:1.15
	OPENBSD_5_6:1.15.0.22
	OPENBSD_5_6_BASE:1.15
	OPENBSD_5_5:1.15.0.20
	OPENBSD_5_5_BASE:1.15
	OPENBSD_5_4:1.15.0.16
	OPENBSD_5_4_BASE:1.15
	OPENBSD_5_3:1.15.0.14
	OPENBSD_5_3_BASE:1.15
	OPENBSD_5_2:1.15.0.12
	OPENBSD_5_2_BASE:1.15
	OPENBSD_5_1_BASE:1.15
	OPENBSD_5_1:1.15.0.10
	OPENBSD_5_0:1.15.0.8
	OPENBSD_5_0_BASE:1.15
	OPENBSD_4_9:1.15.0.6
	OPENBSD_4_9_BASE:1.15
	OPENBSD_4_8:1.15.0.4
	OPENBSD_4_8_BASE:1.15
	OPENBSD_4_7:1.15.0.2
	OPENBSD_4_7_BASE:1.15
	OPENBSD_4_6:1.11.0.16
	OPENBSD_4_6_BASE:1.11
	OPENBSD_4_5:1.11.0.12
	OPENBSD_4_5_BASE:1.11
	OPENBSD_4_4:1.11.0.10
	OPENBSD_4_4_BASE:1.11
	OPENBSD_4_3:1.11.0.8
	OPENBSD_4_3_BASE:1.11
	OPENBSD_4_2:1.11.0.6
	OPENBSD_4_2_BASE:1.11
	OPENBSD_4_1:1.11.0.4
	OPENBSD_4_1_BASE:1.11
	OPENBSD_4_0:1.11.0.2
	OPENBSD_4_0_BASE:1.11
	OPENBSD_3_9:1.10.0.6
	OPENBSD_3_9_BASE:1.10
	OPENBSD_3_8:1.10.0.4
	OPENBSD_3_8_BASE:1.10
	OPENBSD_3_7:1.10.0.2
	OPENBSD_3_7_BASE:1.10
	OPENBSD_3_6:1.9.0.2
	OPENBSD_3_6_BASE:1.9;
locks; strict;
comment	@ * @;


1.18
date	2017.02.13.19.13.14;	author krw;	state Exp;
branches;
next	1.17;
commitid	syYFt6P4XI7prXRF;

1.17
date	2016.02.06.23.50.10;	author krw;	state Exp;
branches;
next	1.16;
commitid	8GMcSAoPYCa1rXN3;

1.16
date	2015.12.21.21.39.11;	author mmcc;	state Exp;
branches;
next	1.15;
commitid	qL5PsV7SFwmqz7sG;

1.15
date	2010.01.02.04.21.16;	author krw;	state Exp;
branches;
next	1.14;

1.14
date	2010.01.01.20.46.20;	author krw;	state Exp;
branches;
next	1.13;

1.13
date	2010.01.01.20.30.25;	author krw;	state Exp;
branches;
next	1.12;

1.12
date	2010.01.01.18.01.44;	author krw;	state Exp;
branches;
next	1.11;

1.11
date	2006.03.13.19.57.42;	author otto;	state Exp;
branches;
next	1.10;

1.10
date	2004.09.16.18.35.43;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2004.05.08.06.12.50;	author henning;	state Exp;
branches;
next	1.8;

1.8
date	2004.04.20.05.35.33;	author henning;	state Exp;
branches;
next	1.7;

1.7
date	2004.04.18.00.43.27;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2004.04.16.04.30.09;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2004.04.15.21.47.13;	author hshoexer;	state Exp;
branches;
next	1.4;

1.4
date	2004.04.14.04.34.19;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2004.04.14.00.56.02;	author henning;	state Exp;
branches;
next	1.2;

1.2
date	2004.04.13.23.57.49;	author henning;	state Exp;
branches;
next	1.1;

1.1
date	2004.04.13.23.41.49;	author henning;	state Exp;
branches;
next	;


desc
@@


1.18
log
@Switch from old errwarn.c logging to shiny new log.[ch].

ok benno@@
@
text
@/*	$OpenBSD: tree.c,v 1.17 2016/02/06 23:50:10 krw Exp $ */

/* Routines for manipulating parse trees... */

/*
 * Copyright (c) 1995, 1996, 1997 The Internet Software Consortium.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of The Internet Software Consortium nor the names
 *    of its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INTERNET SOFTWARE CONSORTIUM AND
 * CONTRIBUTORS ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE INTERNET SOFTWARE CONSORTIUM OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This software has been written for the Internet Software Consortium
 * by Ted Lemon <mellon@@fugue.com> in cooperation with Vixie
 * Enterprises.  To learn more about the Internet Software Consortium,
 * see ``http://www.vix.com/isc''.  To learn more about Vixie
 * Enterprises, see ``http://www.vix.com''.
 */

#include <sys/types.h>
#include <sys/socket.h>

#include <net/if.h>

#include <netinet/in.h>

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "dhcp.h"
#include "tree.h"
#include "dhcpd.h"
#include "log.h"

static time_t tree_evaluate_recurse(int *, unsigned char **, int *,
    struct tree *);
static void do_data_copy(int *, unsigned char **, int *, unsigned char *, int);

pair
cons(caddr_t car, pair cdr)
{
	pair foo;

	foo = calloc(1, sizeof *foo);
	if (!foo)
		fatalx("no memory for cons.");
	foo->car = car;
	foo->cdr = cdr;
	return foo;
}

struct tree_cache *
tree_cache(struct tree *tree)
{
	struct tree_cache	*tc;

	tc = new_tree_cache("tree_cache");
	if (!tc)
		return 0;
	tc->value = NULL;
	tc->len = tc->buf_size = 0;
	tc->timeout = 0;
	tc->tree = tree;
	return tc;
}

struct tree *
tree_const(unsigned char *data, int len)
{
	unsigned char *d;
	struct tree *nt;

	d = calloc(1, len);
	nt = calloc(1, sizeof(struct tree));
	if (!nt || !d)
		fatalx("No memory for constant data tree node.");

	memcpy(d, data, len);

	nt->op = TREE_CONST;
	nt->data.const_val.data = d;
	nt->data.const_val.len = len;

	return nt;
}

struct tree *
tree_concat(struct tree *left, struct tree *right)
{
	struct tree	*nt;

	/*
	 * If we're concatenating a null tree to a non-null tree, just
	 * return the non-null tree; if both trees are null, return
	 * a null tree.
	 */
	if (!left)
		return right;
	if (!right)
		return left;

	/* If both trees are constant, combine them. */
	if (left->op == TREE_CONST && right->op == TREE_CONST) {
		unsigned char *buf;

		buf = calloc(1, left->data.const_val.len
		    + right->data.const_val.len);

		if (!buf)
			fatalx("No memory to concatenate constants.");
		memcpy(buf, left->data.const_val.data,
		    left->data.const_val.len);
		memcpy(buf + left->data.const_val.len,
		    right->data.const_val.data, right->data.const_val.len);
		free(left->data.const_val.data);
		free(right->data.const_val.data);
		left->data.const_val.data = buf;
		left->data.const_val.len += right->data.const_val.len;
		free(right);
		return left;
	}

	/* Otherwise, allocate a new node to concatenate the two. */
	nt = calloc(1, sizeof(struct tree));
	if (!nt)
		fatalx("No memory for data tree concatenation node.");
	nt->op = TREE_CONCAT;
	nt->data.concat.left = left;
	nt->data.concat.right = right;
	return nt;
}

struct tree *
tree_limit(struct tree *tree, int limit)
{
	struct tree	*rv;

	/* If the tree we're limiting is constant, limit it now. */
	if (tree->op == TREE_CONST) {
		if (tree->data.const_val.len > limit)
			tree->data.const_val.len = limit;
		return tree;
	}

	/* Otherwise, put in a node which enforces the limit on evaluation. */
	rv = calloc(1, sizeof(struct tree));
	if (!rv) {
		log_warnx("No memory for data tree limit node.");
		return NULL;
	}
	rv->op = TREE_LIMIT;
	rv->data.limit.tree = tree;
	rv->data.limit.limit = limit;
	return rv;
}

int
tree_evaluate(struct tree_cache *tree_cache)
{
	unsigned char	*bp = tree_cache->value;
	int		 bc = tree_cache->buf_size;
	int		 bufix = 0;

	/*
	 * If there's no tree associated with this cache, it evaluates to a
	 * constant and that was detected at startup.
	 */
	if (!tree_cache->tree)
		return 1;

	/* Try to evaluate the tree without allocating more memory... */
	tree_cache->timeout = tree_evaluate_recurse(&bufix, &bp, &bc,
	    tree_cache->tree);

	/* No additional allocation needed? */
	if (bufix <= bc) {
		tree_cache->len = bufix;
		return 1;
	}

	/*
	 * If we can't allocate more memory, return with what we
	 * have (maybe nothing).
	 */
	bp = calloc(1, bufix);
	if (!bp) {
		log_warnx("no more memory for option data");
		return 0;
	}

	/* Record the change in conditions... */
	bc = bufix;
	bufix = 0;

	/*
	 * Note that the size of the result shouldn't change on the
	 * second call to tree_evaluate_recurse, since we haven't
	 * changed the ``current'' time.
	 */
	tree_evaluate_recurse(&bufix, &bp, &bc, tree_cache->tree);

	/*
	 * Free the old buffer if needed, then store the new buffer
	 * location and size and return.
	 */
	free(tree_cache->value);
	tree_cache->value = bp;
	tree_cache->len = bufix;
	tree_cache->buf_size = bc;
	return 1;
}

static time_t
tree_evaluate_recurse(int *bufix, unsigned char **bufp,
    int *bufcount, struct tree *tree)
{
	int	limit;
	time_t	t1, t2;

	switch (tree->op) {
	case TREE_CONCAT:
		t1 = tree_evaluate_recurse(bufix, bufp, bufcount,
		    tree->data.concat.left);
		t2 = tree_evaluate_recurse(bufix, bufp, bufcount,
		    tree->data.concat.right);
		if (t1 > t2)
			return t2;
		return t1;

	case TREE_CONST:
		do_data_copy(bufix, bufp, bufcount, tree->data.const_val.data,
		    tree->data.const_val.len);
		t1 = MAX_TIME;
		return t1;

	case TREE_LIMIT:
		limit = *bufix + tree->data.limit.limit;
		t1 = tree_evaluate_recurse(bufix, bufp, bufcount,
		    tree->data.limit.tree);
		*bufix = limit;
		return t1;

	default:
		log_warnx("Bad node id in tree: %d.", tree->op);
		t1 = MAX_TIME;
		return t1;
	}
}

static void
do_data_copy(int *bufix, unsigned char **bufp, int *bufcount,
    unsigned char *data, int len)
{
	int	space = *bufcount - *bufix;

	/* If there's more space than we need, use only what we need. */
	if (space > len)
		space = len;

	/*
	 * Copy as much data as will fit, then increment the buffer index
	 * by the amount we actually had to copy, which could be more.
	 */
	if (space > 0)
		memcpy(*bufp + *bufix, data, space);
	*bufix += len;
}
@


1.17
log
@Eliminate #include inside *.h files and include only needed headers in
each *.c file.

Inspired by mention of header silliness by Edgar Pettijohn and mmcc@@
on tech@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: tree.c,v 1.16 2015/12/21 21:39:11 mmcc Exp $ */
d57 1
d70 1
a70 1
		error("no memory for cons.");
d100 1
a100 1
		error("No memory for constant data tree node.");
d134 1
a134 1
			error("No memory to concatenate constants.");
d150 1
a150 1
		error("No memory for data tree concatenation node.");
d172 1
a172 1
		warning("No memory for data tree limit node.");
d211 1
a211 1
		warning("no more memory for option data");
d268 1
a268 1
		warning("Bad node id in tree: %d.", tree->op);
@


1.16
log
@remove NULL-checks before free()
@
text
@d1 1
a1 1
/*	$OpenBSD: tree.c,v 1.15 2010/01/02 04:21:16 krw Exp $ */
d43 13
@


1.15
log
@Eliminate all uses of dmalloc() where the returned pointer
is checked for NULL and a specific error/warning issued. Add
two such manual warning/error checks and kill those dmalloc
calls. And then there were none, so kill dmalloc(). Whew.
@
text
@d1 1
a1 1
/*	$OpenBSD: tree.c,v 1.14 2010/01/01 20:46:20 krw Exp $ */
d216 1
a216 2
	if (tree_cache->value)
		free(tree_cache->value);
@


1.14
log
@Eliminate all uses of dfree() where the pointer is either dereferenced
immediately before the use or the pointer is checked for NULL before
the call. And then there were none, so kill dfree().
@
text
@d1 1
a1 1
/*	$OpenBSD: tree.c,v 1.13 2010/01/01 20:30:25 krw Exp $ */
d52 3
a54 1
	pair	foo = (pair)dmalloc(sizeof *foo, "cons");
d114 4
a117 2
		unsigned char *buf = dmalloc(left->data.const_val.len
		    + right->data.const_val.len, "tree_concat");
d195 3
a197 1
	if (!(bp = (unsigned char *)dmalloc(bufix, "tree_evaluate")))
d199 1
@


1.13
log
@Wrappers around a wrapper around free() are of no more use than
wrappers around wrappers around calloc().

The purpose of the free() wrapper is to generate an error message
when free'ing NULL. But free_hash_bucket(), free_lease(), and
free_tree() are all called immediately after dereferencing the
pointer to be freed. Thus the error message will never be issued.
@
text
@d1 1
a1 1
/*	$OpenBSD: tree.c,v 1.12 2010/01/01 18:01:44 krw Exp $ */
d121 2
a122 2
		dfree(left->data.const_val.data, "tree_concat");
		dfree(right->data.const_val.data, "tree_concat");
d210 1
a210 1
		dfree(tree_cache->value, "tree_evaluate");
@


1.12
log
@Another calloc() wrapper wrapper, new_tree(), bites the dust.
@
text
@d1 1
a1 1
/*	$OpenBSD: tree.c,v 1.11 2006/03/13 19:57:42 otto Exp $ */
d125 1
a125 1
		free_tree(right, "tree_concat");
@


1.11
log
@tiny bit of delinting; ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tree.c,v 1.10 2004/09/16 18:35:43 deraadt Exp $ */
d78 2
a79 1
	struct tree	*nt;
d81 3
a83 2
	if (!(nt = new_tree("tree_const")) || !(nt->data.const_val.data =
	    (unsigned char *)dmalloc(len, "tree_const")))
d85 3
d89 1
a89 1
	memcpy(nt->data.const_val.data, data, len);
d91 1
d130 2
a131 1
	if (!(nt = new_tree("tree_concat")))
d152 3
a154 2
	rv = new_tree("tree_limit");
	if (!rv)
d156 1
@


1.10
log
@avoid aliasing with libc functions; ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: tree.c,v 1.9 2004/05/08 06:12:50 henning Exp $ */
a72 31
}

struct tree *
tree_host_lookup(char *name)
{
	struct tree	*nt;

	nt = new_tree("tree_host_lookup");
	if (!nt)
		error("No memory for host lookup tree node.");
	nt->op = TREE_HOST_LOOKUP;
	nt->data.host_lookup.host = enter_dns_host(name);
	return nt;
}

struct dns_host_entry *
enter_dns_host(char *name)
{
	struct dns_host_entry	*dh;
	int			 len = strlen(name) + 1;

	if (!(dh = (struct dns_host_entry *)dmalloc
	    (sizeof(struct dns_host_entry), "enter_dns_host")) ||
	    !(dh->hostname = dmalloc(len, "enter_dns_host")))
		error("Can't allocate space for new host.");
	strlcpy(dh->hostname, name, len);
	dh->data = NULL;
	dh->data_len = 0;
	dh->buf_len = 0;
	dh->timeout = 0;
	return dh;
@


1.9
log
@remove hostname lookup stuff, done at parse time now, ok theo
@
text
@d1 1
a1 1
/*	$OpenBSD: tree.c,v 1.8 2004/04/20 05:35:33 henning Exp $ */
d270 1
a270 1
		warn("Bad node id in tree: %d.", tree->op);
@


1.8
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
a46 2
static time_t do_host_lookup(int *, unsigned char **, int *,
    struct dns_host_entry *);
a255 4
	case TREE_HOST_LOOKUP:
		return do_host_lookup(bufix, bufp, bufcount,
		    tree->data.host_lookup.host);

a273 103
}

static time_t
do_host_lookup(int *bufix, unsigned char **bufp, int *bufcount,
    struct dns_host_entry *dns)
{
	struct hostent	*h;
	int		 i;
	int		 new_len;

#ifdef DEBUG_EVAL
	debug("time: now = %d  dns = %d %d  diff = %d", cur_time, dns->timeout,
	    cur_time - dns->timeout);
#endif

	/* If the record hasn't timed out, just copy the data and return. */
	if (cur_time <= dns->timeout) {
#ifdef DEBUG_EVAL
		debug("easy copy: %x %d %x", dns->data, dns->data_len,
		    dns->data ? *(int *)(dns->data) : 0);
#endif
		do_data_copy(bufix, bufp, bufcount, dns->data, dns->data_len);
		return dns->timeout;
	}
#ifdef DEBUG_EVAL
	debug("Looking up %s", dns->hostname);
#endif

	/* Otherwise, look it up... */
	h = gethostbyname(dns->hostname);
	if (h == NULL) {
		switch (h_errno) {
		case HOST_NOT_FOUND:
			warn("%s: host unknown.", dns->hostname);
			break;
		case TRY_AGAIN:
			warn("%s: temporary name server failure",
			    dns->hostname);
			break;
		case NO_RECOVERY:
			warn("%s: name server failed", dns->hostname);
			break;
		case NO_DATA:
			warn("%s: no A record associated with address",
			    dns->hostname);
		}
		/* Okay to try again after a minute. */
		return cur_time + 60;
	}

#ifdef DEBUG_EVAL
	debug("Lookup succeeded; first address is %x", h->h_addr_list[0]);
#endif

	/* Count the number of addresses we got... */
	for (i = 0; h->h_addr_list[i]; i++)
		;

	/* Do we need to allocate more memory? */
	new_len = i * h->h_length;
	if (dns->buf_len < i) {
		unsigned char *buf =
			(unsigned char *)dmalloc(new_len, "do_host_lookup");
		/* If we didn't get more memory, use what we have. */
		if (!buf) {
			new_len = dns->buf_len;
			if (!dns->buf_len) {
				dns->timeout = cur_time + 60;
				return dns->timeout;
			}
		} else {
			if (dns->data)
				dfree(dns->data, "do_host_lookup");
			dns->data = buf;
			dns->buf_len = new_len;
		}
	}

	/*
	 * Addresses are conveniently stored one to the buffer, so we
	 * have to copy them out one at a time... :'(
	 */
	for (i = 0; i < new_len / h->h_length; i++)
		memcpy(dns->data + h->h_length * i, h->h_addr_list[i],
		    h->h_length);
#ifdef DEBUG_EVAL
	debug("dns->data: %x  h->h_addr_list[0]: %x",
	    *(int *)(dns->data), h->h_addr_list[0]);
#endif
	dns->data_len = new_len;

	/*
	 * Set the timeout for an hour from now.
	 * XXX This should really use the time on the DNS reply.
	 */
	dns->timeout = cur_time + 3600;

#ifdef DEBUG_EVAL
	debug("hard copy: %x %d %x", dns->data, dns->data_len,
	    *(int *)(dns->data));
#endif
	do_data_copy(bufix, bufp, bufcount, dns->data, dns->data_len);
	return dns->timeout;
@


1.7
log
@various knf; henning ok
@
text
@d1 1
a1 1
/*	$Id: tree.c,v 1.6 2004/04/16 04:30:09 deraadt Exp $	*/
@


1.6
log
@a bunch of knf, ok henning
@
text
@d1 1
a1 1
/*	$Id: tree.c,v 1.5 2004/04/15 21:47:13 hshoexer Exp $	*/
d70 1
a70 1
	tc->value = (unsigned char *)0;
d101 1
a101 1
	dh->data = (unsigned char *)0;
d127 1
a127 1
	/* 
d180 1
a180 1
		return(struct tree *)0;
d194 1
a194 1
	/* 
d222 1
a222 1
	/* 
d317 1
a317 1
			      dns->hostname);
d331 1
a331 2
	debug("Lookup succeeded; first address is %x",
	       h->h_addr_list[0]);
@


1.5
log
@knf + ansi

ok henning@@
@
text
@d1 1
a1 1
/*	$Id:$	*/
d56 1
a56 1
		error ("no memory for cons.");
d141 1
@


1.4
log
@spaces
@
text
@d1 1
a1 1
/* tree.c
d3 1
a3 1
   Routines for manipulating parse trees... */
d51 2
a52 3
pair cons (car, cdr)
	caddr_t car;
	pair cdr;
d54 1
a54 1
	pair foo = (pair)dmalloc (sizeof *foo, "cons");
d57 2
a58 2
	foo -> car = car;
	foo -> cdr = cdr;
d62 2
a63 2
struct tree_cache *tree_cache (tree)
	struct tree *tree;
d65 1
a65 1
	struct tree_cache *tc;
d67 1
a67 1
	tc = new_tree_cache ("tree_cache");
d70 4
a73 4
	tc -> value = (unsigned char *)0;
	tc -> len = tc -> buf_size = 0;
	tc -> timeout = 0;
	tc -> tree = tree;
d77 2
a78 2
struct tree *tree_host_lookup (name)
	char *name;
d80 3
a82 2
	struct tree *nt;
	nt = new_tree ("tree_host_lookup");
d84 3
a86 3
		error ("No memory for host lookup tree node.");
	nt -> op = TREE_HOST_LOOKUP;
	nt -> data.host_lookup.host = enter_dns_host (name);
d90 2
a91 2
struct dns_host_entry *enter_dns_host (name)
	char *name;
d93 2
a94 2
	struct dns_host_entry *dh;
	int len = strlen (name) + 1;
d97 8
a104 8
	      (sizeof (struct dns_host_entry), "enter_dns_host"))
	    || !(dh -> hostname = dmalloc (len, "enter_dns_host")))
		error ("Can't allocate space for new host.");
	strlcpy (dh -> hostname, name, len);
	dh -> data = (unsigned char *)0;
	dh -> data_len = 0;
	dh -> buf_len = 0;
	dh -> timeout = 0;
d108 11
a118 12
struct tree *tree_const (data, len)
	unsigned char *data;
	int len;
{
	struct tree *nt;
	if (!(nt = new_tree ("tree_const"))
	    || !(nt -> data.const_val.data =
		 (unsigned char *)dmalloc (len, "tree_const")))
		error ("No memory for constant data tree node.");
	nt -> op = TREE_CONST;
	memcpy (nt -> data.const_val.data, data, len);
	nt -> data.const_val.len = len;
d122 2
a123 2
struct tree *tree_concat (left, right)
	struct tree *left, *right;
d125 1
a125 1
	struct tree *nt;
d127 5
a131 3
	/* If we're concatenating a null tree to a non-null tree, just
	   return the non-null tree; if both trees are null, return
	   a null tree. */
d138 3
a140 4
	if (left -> op == TREE_CONST && right -> op == TREE_CONST) {
		unsigned char *buf = dmalloc (left -> data.const_val.len
					      + right -> data.const_val.len,
					      "tree_concat");
d142 10
a151 11
			error ("No memory to concatenate constants.");
		memcpy (buf, left -> data.const_val.data,
			left -> data.const_val.len);
		memcpy (buf + left -> data.const_val.len,
			right -> data.const_val.data,
			right -> data.const_val.len);
		dfree (left -> data.const_val.data, "tree_concat");
		dfree (right -> data.const_val.data, "tree_concat");
		left -> data.const_val.data = buf;
		left -> data.const_val.len += right -> data.const_val.len;
		free_tree (right, "tree_concat");
d156 5
a160 5
	if (!(nt = new_tree ("tree_concat")))
		error ("No memory for data tree concatenation node.");
	nt -> op = TREE_CONCAT;
	nt -> data.concat.left = left;
	nt -> data.concat.right = right;
d164 2
a165 3
struct tree *tree_limit (tree, limit)
	struct tree *tree;
	int limit;
d167 1
a167 1
	struct tree *rv;
d170 3
a172 3
	if (tree -> op == TREE_CONST) {
		if (tree -> data.const_val.len > limit)
			tree -> data.const_val.len = limit;
d177 1
a177 1
	rv = new_tree ("tree_limit");
d179 4
a182 4
		return (struct tree *)0;
	rv -> op = TREE_LIMIT;
	rv -> data.limit.tree = tree;
	rv -> data.limit.limit = limit;
d186 2
a187 2
int tree_evaluate (tree_cache)
	struct tree_cache *tree_cache;
d189 9
a197 7
	unsigned char *bp = tree_cache -> value;
	int bc = tree_cache -> buf_size;
	int bufix = 0;

	/* If there's no tree associated with this cache, it evaluates
	   to a constant and that was detected at startup. */
	if (!tree_cache -> tree)
d201 2
a202 2
	tree_cache -> timeout = tree_evaluate_recurse (&bufix, &bp, &bc,
						       tree_cache -> tree);
d206 1
a206 1
		tree_cache -> len = bufix;
d210 5
a214 3
	/* If we can't allocate more memory, return with what we
	   have (maybe nothing). */
	if (!(bp = (unsigned char *)dmalloc (bufix, "tree_evaluate")))
d221 16
a236 12
	/* Note that the size of the result shouldn't change on the
	   second call to tree_evaluate_recurse, since we haven't
	   changed the ``current'' time. */
	tree_evaluate_recurse (&bufix, &bp, &bc, tree_cache -> tree);

	/* Free the old buffer if needed, then store the new buffer
	   location and size and return. */
	if (tree_cache -> value)
		dfree (tree_cache -> value, "tree_evaluate");
	tree_cache -> value = bp;
	tree_cache -> len = bufix;
	tree_cache -> buf_size = bc;
d240 13
a252 15
static time_t tree_evaluate_recurse (bufix, bufp, bufcount, tree)
	int *bufix;
	unsigned char **bufp;
	int *bufcount;
	struct tree *tree;
{
	int limit;
	time_t t1, t2;

	switch (tree -> op) {
	      case TREE_CONCAT:
		t1 = tree_evaluate_recurse (bufix, bufp, bufcount,
					   tree -> data.concat.left);
		t2 = tree_evaluate_recurse (bufix, bufp, bufcount,
					   tree -> data.concat.right);
d257 7
a263 8
	      case TREE_HOST_LOOKUP:
		return do_host_lookup (bufix, bufp, bufcount,
				       tree -> data.host_lookup.host);

	      case TREE_CONST:
		do_data_copy (bufix, bufp, bufcount,
			      tree -> data.const_val.data,
			      tree -> data.const_val.len);
d267 4
a270 4
	      case TREE_LIMIT:
		limit = *bufix + tree -> data.limit.limit;
		t1 = tree_evaluate_recurse (bufix, bufp, bufcount,
					    tree -> data.limit.tree);
d274 2
a275 2
	      default:
		warn ("Bad node id in tree: %d.", tree -> op);
d281 7
a287 9
static time_t do_host_lookup (bufix, bufp, bufcount, dns)
	int *bufix;
	unsigned char **bufp;
	int *bufcount;
	struct dns_host_entry *dns;
{
	struct hostent *h;
	int i;
	int new_len;
d290 2
a291 2
	debug ("time: now = %d  dns = %d %d  diff = %d",
	       cur_time, dns -> timeout, cur_time - dns -> timeout);
d295 1
a295 1
	if (cur_time <= dns -> timeout) {
d297 2
a298 3
		debug ("easy copy: %x %d %x",
		       dns -> data, dns -> data_len,
		       dns -> data ? *(int *)(dns -> data) : 0);
d300 2
a301 3
		do_data_copy (bufix, bufp, bufcount,
			      dns -> data, dns -> data_len);
		return dns -> timeout;
d304 1
a304 1
	debug ("Looking up %s", dns -> hostname);
d308 1
a308 1
	h = gethostbyname (dns -> hostname);
d311 2
a312 2
		      case HOST_NOT_FOUND:
			warn ("%s: host unknown.", dns -> hostname);
d314 3
a316 3
		      case TRY_AGAIN:
			warn ("%s: temporary name server failure",
			      dns -> hostname);
d318 2
a319 2
		      case NO_RECOVERY:
			warn ("%s: name server failed", dns -> hostname);
d321 3
a323 3
		      case NO_DATA:
			warn ("%s: no A record associated with address",
			      dns -> hostname);
d330 2
a331 2
	debug ("Lookup succeeded; first address is %x",
	       h -> h_addr_list [0]);
d335 1
a335 1
	for (i = 0; h -> h_addr_list [i]; i++)
d339 2
a340 2
	new_len = i * h -> h_length;
	if (dns -> buf_len < i) {
d342 1
a342 1
			(unsigned char *)dmalloc (new_len, "do_host_lookup");
d345 4
a348 4
			new_len = dns -> buf_len;
			if (!dns -> buf_len) {
				dns -> timeout = cur_time + 60;
				return dns -> timeout;
d351 4
a354 4
			if (dns -> data)
				dfree (dns -> data, "do_host_lookup");
			dns -> data = buf;
			dns -> buf_len = new_len;
d358 7
a364 6
	/* Addresses are conveniently stored one to the buffer, so we
	   have to copy them out one at a time... :'( */
	for (i = 0; i < new_len / h -> h_length; i++) {
		memcpy (dns -> data + h -> h_length * i,
			h -> h_addr_list [i], h -> h_length);
	}
d366 2
a367 2
	debug ("dns -> data: %x  h -> h_addr_list [0]: %x",
	       *(int *)(dns -> data), h -> h_addr_list [0]);
d369 1
a369 1
	dns -> data_len = new_len;
d371 5
a375 3
	/* Set the timeout for an hour from now.
	   XXX This should really use the time on the DNS reply. */
	dns -> timeout = cur_time + 3600;
d378 2
a379 2
	debug ("hard copy: %x %d %x",
	       dns -> data, dns -> data_len, *(int *)(dns -> data));
d381 2
a382 2
	do_data_copy (bufix, bufp, bufcount, dns -> data, dns -> data_len);
	return dns -> timeout;
d385 3
a387 6
static void do_data_copy (bufix, bufp, bufcount, data, len)
	int *bufix;
	unsigned char **bufp;
	int *bufcount;
	unsigned char *data;
	int len;
d389 1
a389 1
	int space = *bufcount - *bufix;
d395 4
a398 2
	/* Copy as much data as will fit, then increment the buffer index
	   by the amount we actually had to copy, which could be more. */
d400 1
a400 1
		memcpy (*bufp + *bufix, data, space);
@


1.3
log
@more crap bites the dust
@
text
@d155 1
a155 1
			
d338 1
a338 1
	
@


1.2
log
@time_t and kill a few dumb defines
@
text
@d45 5
a49 6
static time_t tree_evaluate_recurse PROTO ((int *, unsigned char **, int *,
					  struct tree *));
static time_t do_host_lookup PROTO ((int *, unsigned char **, int *,
					  struct dns_host_entry *));
static void do_data_copy PROTO ((int *, unsigned char **, int *,
				 unsigned char *, int));
@


1.1
log
@may the whacking begin
@
text
@d45 1
a45 1
static TIME tree_evaluate_recurse PROTO ((int *, unsigned char **, int *,
d47 1
a47 1
static TIME do_host_lookup PROTO ((int *, unsigned char **, int *,
d235 1
a235 1
static TIME tree_evaluate_recurse (bufix, bufp, bufcount, tree)
d242 1
a242 1
	TIME t1, t2;
d279 1
a279 1
static TIME do_host_lookup (bufix, bufp, bufcount, dns)
@

