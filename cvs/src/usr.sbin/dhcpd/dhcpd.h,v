head	1.66;
access;
symbols
	OPENBSD_6_2:1.66.0.4
	OPENBSD_6_2_BASE:1.66
	OPENBSD_6_1:1.60.0.4
	OPENBSD_6_1_BASE:1.60
	OPENBSD_6_0:1.53.0.4
	OPENBSD_6_0_BASE:1.53
	OPENBSD_5_9:1.53.0.2
	OPENBSD_5_9_BASE:1.53
	OPENBSD_5_8:1.52.0.8
	OPENBSD_5_8_BASE:1.52
	OPENBSD_5_7:1.52.0.2
	OPENBSD_5_7_BASE:1.52
	OPENBSD_5_6:1.52.0.4
	OPENBSD_5_6_BASE:1.52
	OPENBSD_5_5:1.47.0.6
	OPENBSD_5_5_BASE:1.47
	OPENBSD_5_4:1.47.0.2
	OPENBSD_5_4_BASE:1.47
	OPENBSD_5_3:1.46.0.2
	OPENBSD_5_3_BASE:1.46
	OPENBSD_5_2:1.45.0.10
	OPENBSD_5_2_BASE:1.45
	OPENBSD_5_1_BASE:1.45
	OPENBSD_5_1:1.45.0.8
	OPENBSD_5_0:1.45.0.6
	OPENBSD_5_0_BASE:1.45
	OPENBSD_4_9:1.45.0.4
	OPENBSD_4_9_BASE:1.45
	OPENBSD_4_8:1.45.0.2
	OPENBSD_4_8_BASE:1.45
	OPENBSD_4_7:1.44.0.2
	OPENBSD_4_7_BASE:1.44
	OPENBSD_4_6:1.36.0.8
	OPENBSD_4_6_BASE:1.36
	OPENBSD_4_5:1.36.0.4
	OPENBSD_4_5_BASE:1.36
	OPENBSD_4_4:1.36.0.2
	OPENBSD_4_4_BASE:1.36
	OPENBSD_4_3:1.35.0.2
	OPENBSD_4_3_BASE:1.35
	OPENBSD_4_2:1.33.0.4
	OPENBSD_4_2_BASE:1.33
	OPENBSD_4_1:1.33.0.2
	OPENBSD_4_1_BASE:1.33
	OPENBSD_4_0:1.21.0.2
	OPENBSD_4_0_BASE:1.21
	OPENBSD_3_9:1.16.0.6
	OPENBSD_3_9_BASE:1.16
	OPENBSD_3_8:1.16.0.4
	OPENBSD_3_8_BASE:1.16
	OPENBSD_3_7:1.16.0.2
	OPENBSD_3_7_BASE:1.16
	OPENBSD_3_6:1.13.0.2
	OPENBSD_3_6_BASE:1.13;
locks; strict;
comment	@ * @;


1.66
date	2017.08.04.02.01.46;	author rob;	state Exp;
branches;
next	1.65;
commitid	Mqf3DuH7owHwGQGX;

1.65
date	2017.07.31.19.00.40;	author rob;	state Exp;
branches;
next	1.64;
commitid	nmK9h1QjLc8qvDfW;

1.64
date	2017.04.24.14.58.36;	author krw;	state Exp;
branches;
next	1.63;
commitid	VdvDIyV6oHLS1zmq;

1.63
date	2017.04.18.13.59.09;	author krw;	state Exp;
branches;
next	1.62;
commitid	cFUzT9OoC4hYJl7A;

1.62
date	2017.04.17.18.31.08;	author krw;	state Exp;
branches;
next	1.61;
commitid	ty0UWHtzgExZQRGh;

1.61
date	2017.04.13.14.59.40;	author krw;	state Exp;
branches;
next	1.60;
commitid	MUVEXu4qkaRvyWwy;

1.60
date	2017.02.16.00.24.43;	author krw;	state Exp;
branches
	1.60.4.1;
next	1.59;
commitid	5UCb9jKiZwXsFyNg;

1.59
date	2017.02.13.23.04.05;	author krw;	state Exp;
branches;
next	1.58;
commitid	amfLXbU964CBXnkr;

1.58
date	2017.02.13.22.33.39;	author krw;	state Exp;
branches;
next	1.57;
commitid	aD6aChUv7GEv3CLZ;

1.57
date	2017.02.13.19.13.14;	author krw;	state Exp;
branches;
next	1.56;
commitid	syYFt6P4XI7prXRF;

1.56
date	2017.02.11.16.12.36;	author krw;	state Exp;
branches;
next	1.55;
commitid	eWsyZlm9X0T2fxXC;

1.55
date	2016.10.06.16.12.43;	author krw;	state Exp;
branches;
next	1.54;
commitid	AgdFqJlm4JPQ6iei;

1.54
date	2016.08.05.14.02.23;	author krw;	state Exp;
branches;
next	1.53;
commitid	EtSNZfEccLQuVs0q;

1.53
date	2016.02.06.23.50.10;	author krw;	state Exp;
branches;
next	1.52;
commitid	8GMcSAoPYCa1rXN3;

1.52
date	2014.07.11.16.48.29;	author yasuoka;	state Exp;
branches;
next	1.51;
commitid	6tZPPUQwE3KSsUgX;

1.51
date	2014.07.11.09.42.27;	author yasuoka;	state Exp;
branches;
next	1.50;
commitid	7SRccEu66mJK3N60;

1.50
date	2014.05.07.13.20.47;	author pelikan;	state Exp;
branches;
next	1.49;

1.49
date	2014.05.05.18.30.44;	author pelikan;	state Exp;
branches;
next	1.48;

1.48
date	2014.05.05.18.27.57;	author pelikan;	state Exp;
branches;
next	1.47;

1.47
date	2013.04.17.19.26.10;	author krw;	state Exp;
branches;
next	1.46;

1.46
date	2013.02.03.21.04.19;	author krw;	state Exp;
branches;
next	1.45;

1.45
date	2010.04.19.12.22.09;	author claudio;	state Exp;
branches;
next	1.44;

1.44
date	2010.01.02.04.21.16;	author krw;	state Exp;
branches;
next	1.43;

1.43
date	2010.01.01.20.30.25;	author krw;	state Exp;
branches;
next	1.42;

1.42
date	2010.01.01.19.10.24;	author krw;	state Exp;
branches;
next	1.41;

1.41
date	2010.01.01.18.01.44;	author krw;	state Exp;
branches;
next	1.40;

1.40
date	2010.01.01.08.02.34;	author krw;	state Exp;
branches;
next	1.39;

1.39
date	2010.01.01.06.25.37;	author krw;	state Exp;
branches;
next	1.38;

1.38
date	2010.01.01.02.38.02;	author krw;	state Exp;
branches;
next	1.37;

1.37
date	2010.01.01.01.47.41;	author krw;	state Exp;
branches;
next	1.36;

1.36
date	2008.05.07.12.19.20;	author beck;	state Exp;
branches;
next	1.35;

1.35
date	2008.01.18.20.14.03;	author krw;	state Exp;
branches;
next	1.34;

1.34
date	2007.10.29.16.51.02;	author krw;	state Exp;
branches;
next	1.33;

1.33
date	2007.02.22.07.02.31;	author henning;	state Exp;
branches;
next	1.32;

1.32
date	2007.02.18.21.19.00;	author henning;	state Exp;
branches;
next	1.31;

1.31
date	2007.02.06.21.12.07;	author stevesk;	state Exp;
branches;
next	1.30;

1.30
date	2007.02.06.17.58.39;	author stevesk;	state Exp;
branches;
next	1.29;

1.29
date	2007.01.04.19.12.41;	author stevesk;	state Exp;
branches;
next	1.28;

1.28
date	2006.12.17.18.03.33;	author stevesk;	state Exp;
branches;
next	1.27;

1.27
date	2006.12.12.19.32.21;	author stevesk;	state Exp;
branches;
next	1.26;

1.26
date	2006.12.11.23.40.30;	author stevesk;	state Exp;
branches;
next	1.25;

1.25
date	2006.11.22.19.10.39;	author stevesk;	state Exp;
branches;
next	1.24;

1.24
date	2006.11.21.16.26.56;	author stevesk;	state Exp;
branches;
next	1.23;

1.23
date	2006.11.21.00.10.06;	author stevesk;	state Exp;
branches;
next	1.22;

1.22
date	2006.11.20.19.14.23;	author stevesk;	state Exp;
branches;
next	1.21;

1.21
date	2006.06.14.14.58.52;	author ckuethe;	state Exp;
branches;
next	1.20;

1.20
date	2006.06.14.14.49.46;	author ckuethe;	state Exp;
branches;
next	1.19;

1.19
date	2006.05.31.02.43.15;	author ckuethe;	state Exp;
branches;
next	1.18;

1.18
date	2006.05.30.23.43.46;	author ckuethe;	state Exp;
branches;
next	1.17;

1.17
date	2006.05.11.01.19.08;	author krw;	state Exp;
branches;
next	1.16;

1.16
date	2004.10.31.10.43.38;	author canacar;	state Exp;
branches;
next	1.15;

1.15
date	2004.09.16.18.35.43;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2004.09.16.09.35.24;	author claudio;	state Exp;
branches;
next	1.13;

1.13
date	2004.05.04.21.25.27;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2004.05.04.20.28.40;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2004.04.22.15.22.48;	author henning;	state Exp;
branches;
next	1.10;

1.10
date	2004.04.21.09.11.58;	author canacar;	state Exp;
branches;
next	1.9;

1.9
date	2004.04.20.05.35.33;	author henning;	state Exp;
branches;
next	1.8;

1.8
date	2004.04.18.00.43.27;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2004.04.14.04.34.19;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2004.04.14.01.09.52;	author henning;	state Exp;
branches;
next	1.5;

1.5
date	2004.04.14.00.56.02;	author henning;	state Exp;
branches;
next	1.4;

1.4
date	2004.04.14.00.24.51;	author henning;	state Exp;
branches;
next	1.3;

1.3
date	2004.04.14.00.06.25;	author henning;	state Exp;
branches;
next	1.2;

1.2
date	2004.04.13.23.57.49;	author henning;	state Exp;
branches;
next	1.1;

1.1
date	2004.04.13.23.41.48;	author henning;	state Exp;
branches;
next	;

1.60.4.1
date	2017.05.03.02.22.00;	author jsg;	state Exp;
branches;
next	;
commitid	Lc14KH1vjpo2vkRP;


desc
@@


1.66
log
@Remove unused structs and defines, from Edgar Pettijohn. ok jca@@
@
text
@/*	$OpenBSD: dhcpd.h,v 1.65 2017/07/31 19:00:40 rob Exp $ */

/*
 * Copyright (c) 1995, 1996, 1997, 1998, 1999
 * The Internet Software Consortium.    All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of The Internet Software Consortium nor the names
 *    of its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INTERNET SOFTWARE CONSORTIUM AND
 * CONTRIBUTORS ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE INTERNET SOFTWARE CONSORTIUM OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This software has been written for the Internet Software Consortium
 * by Ted Lemon <mellon@@fugue.com> in cooperation with Vixie
 * Enterprises.  To learn more about the Internet Software Consortium,
 * see ``http://www.vix.com/isc''.  To learn more about Vixie
 * Enterprises, see ``http://www.vix.com''.
 */

#define ifr_netmask ifr_addr

#define HAVE_SA_LEN
#define HAVE_MKSTEMP

#define DB_TIMEFMT	"%w %Y/%m/%d %T UTC"
#define OLD_DB_TIMEFMT	"%w %Y/%m/%d %T"

#define SERVER_PORT	67
#define CLIENT_PORT	68

struct iaddr {
	int len;
	unsigned char iabuf[16];
};

#define DEFAULT_HASH_SIZE	97

struct hash_bucket {
	struct hash_bucket *next;
	unsigned char *name;
	int len;
	unsigned char *value;
};

struct hash_table {
	int hash_count;
	struct hash_bucket *buckets[DEFAULT_HASH_SIZE];
};

struct option_data {
	int len;
	u_int8_t *data;
};

/* A dhcp packet and the pointers to its option values. */
struct packet {
	struct dhcp_packet *raw;
	int packet_length;
	int packet_type;
	int options_valid;
	int client_port;
	struct iaddr client_addr;
	struct interface_info *interface;	/* Interface on which packet
						   was received. */
	struct hardware *haddr;		/* Physical link address
					   of local sender (maybe gateway). */
	struct shared_network *shared_network;
	struct option_data options[256];
	int got_requested_address;	/* True if client sent the
					   dhcp-requested-address option. */
};

struct hardware {
	u_int8_t htype;
	u_int8_t hlen;
	u_int8_t haddr[16];
};

/* A dhcp lease declaration structure. */
struct lease {
	struct lease *next;
	struct lease *prev;
	struct lease *n_uid, *n_hw;
	struct lease *waitq_next;

	struct iaddr ip_addr;
	time_t starts, ends, timestamp;
	unsigned char *uid;
	int uid_len;
	int uid_max;
	unsigned char uid_buf[32];
	char *hostname;
	char *client_hostname;
	uint8_t *client_identifier;
	struct host_decl *host;
	struct subnet *subnet;
	struct shared_network *shared_network;
	struct hardware hardware_addr;

	int client_identifier_len;
	int flags;
#define STATIC_LEASE		1
#define BOOTP_LEASE		2
#define DYNAMIC_BOOTP_OK	4
#define PERSISTENT_FLAGS	(DYNAMIC_BOOTP_OK)
#define EPHEMERAL_FLAGS		(BOOTP_LEASE)
#define MS_NULL_TERMINATION	8
#define ABANDONED_LEASE		16
#define INFORM_NOLEASE		32

	struct lease_state *state;
	u_int8_t releasing;
};

struct lease_state {
	struct lease_state *next;

	struct interface_info *ip;

	time_t offered_expiry;

	struct tree_cache *options[256];
	u_int32_t expiry, renewal, rebind;
	char filename[DHCP_FILE_LEN];
	char *server_name;

	struct iaddr from;

	int max_message_size;
	u_int8_t *prl;
	int prl_len;
	int got_requested_address;	/* True if client sent the
					   dhcp-requested-address option. */
	int got_server_identifier;	/* True if client sent the
					   dhcp-server-identifier option. */
	struct shared_network *shared_network;	/* Shared network of interface
						   on which request arrived. */

	u_int32_t xid;
	u_int16_t secs;
	u_int16_t bootp_flags;
	struct in_addr ciaddr;
	struct in_addr giaddr;
	u_int8_t hops;
	u_int8_t offer;
	struct hardware haddr;
};

#define	ROOT_GROUP	0
#define HOST_DECL	1
#define SHARED_NET_DECL	2
#define SUBNET_DECL	3
#define CLASS_DECL	4
#define	GROUP_DECL	5

/* Group of declarations that share common parameters. */
struct group {
	struct group *next;

	struct subnet *subnet;
	struct shared_network *shared_network;

	time_t default_lease_time;
	time_t max_lease_time;
	time_t bootp_lease_cutoff;
	time_t bootp_lease_length;

	char *filename;
	char *server_name;
	struct iaddr next_server;

	int boot_unknown_clients;
	int dynamic_bootp;
	int allow_bootp;
	int allow_booting;
	int get_lease_hostnames;
	int use_host_decl_names;
	int use_lease_addr_for_default_route;
	int authoritative;
	int always_reply_rfc1048;
	int echo_client_id;

	struct tree_cache *options[256];
};

/* A dhcp host declaration structure. */
struct host_decl {
	struct host_decl *n_ipaddr;
	char *name;
	struct hardware interface;
	struct tree_cache *fixed_addr;
	struct group *group;
};

struct shared_network {
	struct shared_network *next;
	char *name;
	struct subnet *subnets;
	struct interface_info *interface;
	struct lease *leases;
	struct lease *insertion_point;
	struct lease *last_lease;

	struct group *group;
};

struct subnet {
	struct subnet *next_subnet;
	struct subnet *next_sibling;
	struct shared_network *shared_network;
	struct interface_info *interface;
	struct iaddr interface_address;
	struct iaddr net;
	struct iaddr netmask;

	struct group *group;
};

struct class {
	char *name;

	struct group *group;
};

/* privsep message. fixed length for easy parsing */
struct pf_cmd {
	struct in_addr ip;
	u_int32_t type;
};

/* Information about each network interface. */

struct interface_info {
	struct interface_info *next;	/* Next interface in list... */
	struct shared_network *shared_network;
				/* Networks connected to this interface. */
	struct hardware hw_address;	/* Its physical address. */
	struct in_addr primary_address;	/* Primary interface address. */
	char name[IFNAMSIZ];		/* Its name... */
	int rfdesc;			/* Its read file descriptor. */
	int wfdesc;			/* Its write file descriptor, if
					   different. */
	unsigned char *rbuf;		/* Read buffer, if required. */
	size_t rbuf_max;		/* Size of read buffer. */
	size_t rbuf_offset;		/* Current offset into buffer. */
	size_t rbuf_len;		/* Length of data in buffer. */

	struct ifreq *ifp;		/* Pointer to ifreq struct. */

	int noifmedia;
	int errors;
	int dead;
	u_int16_t	index;
	int is_udpsock;
	ssize_t (*send_packet)(struct interface_info *, struct dhcp_packet *,
	    size_t, struct in_addr, struct sockaddr_in *, struct hardware *);
};

struct dhcpd_timeout {
	struct dhcpd_timeout *next;
	time_t when;
	void (*func)(void *);
	void *what;
};

struct protocol {
	struct protocol *next;
	int fd;
	void (*handler)(struct protocol *);
	void *local;
};

#define _PATH_DHCPD_CONF	"/etc/dhcpd.conf"
#define _PATH_DHCPD_DB		"/var/db/dhcpd.leases"
#define _PATH_DEV_PF		"/dev/pf"
#define DHCPD_LOG_FACILITY	LOG_DAEMON

#define MAX_TIME 0x7fffffff
#define MIN_TIME 0

/* External definitions... */

/* parse.c */
extern int warnings_occurred;
int	parse_warn(char *, ...) __attribute__ ((__format__ (__printf__, 1,
	    2)));

/* options.c */
void	 parse_options(struct packet *);
void	 parse_option_buffer(struct packet *, unsigned char *, int);
int	 cons_options(struct packet *, struct dhcp_packet *, int,
	    struct tree_cache **, int, int, int, u_int8_t *, int);
char	*pretty_print_option(unsigned int, unsigned char *, int, int, int);
void	 do_packet(struct interface_info *, struct dhcp_packet *, int,
	    unsigned int, struct iaddr, struct hardware *);

/* dhcpd.c */
extern time_t		cur_time;
extern struct group	root_group;

extern u_int16_t	server_port;
extern u_int16_t	client_port;

extern char		*path_dhcpd_conf;
extern char		*path_dhcpd_db;

int	main(int, char *[]);
void	cleanup(void);
void	lease_pinged(struct iaddr, u_int8_t *, int);
void	lease_ping_timeout(void *);
void	periodic_scan(void *);

/* conflex.c */
extern int	 lexline, lexchar;
extern char	*token_line, *tlname;
extern char	 comments[4096];
extern int	 comment_index;
extern int	 eol_token;

void	new_parse(char *);
int	next_token(char **, FILE *);
int	peek_token(char **, FILE *);

/* confpars.c */
int	 readconf(void);
void	 read_leases(void);
int	 parse_statement(FILE *, struct group *, int, struct host_decl *, int);
void	 parse_allow_deny(FILE *, struct group *, int);
void	 skip_to_semi(FILE *);
int	 parse_boolean(FILE *);
int	 parse_semi(FILE *);
int	 parse_lbrace(FILE *);
void	 parse_host_declaration(FILE *, struct group *);
char	*parse_host_name(FILE *);
void	 parse_class_declaration(FILE *, struct group *, int);
void	 parse_lease_time(FILE *, time_t *);
void	 parse_shared_net_declaration(FILE *, struct group *);
void	 parse_subnet_declaration(FILE *, struct shared_network *);
void	 parse_group_declaration(FILE *, struct group *);
void	 parse_hardware_param(FILE *, struct hardware *);
char	*parse_string(FILE *);

struct tree		*parse_ip_addr_or_hostname(FILE *, int);
struct tree_cache	*parse_fixed_addr_param(FILE *);
void			 parse_option_param(FILE *, struct group *);
time_t			 parse_timestamp(FILE *);
struct lease		*parse_lease_declaration(FILE *);
void			 parse_address_range(FILE *, struct subnet *);
time_t			 parse_date(FILE *);
unsigned char		*parse_numeric_aggregate(FILE *, unsigned char *,
			    int *, int, int, int);
void			 convert_num(unsigned char *, char *, int, int);

/* tree.c */
pair			 cons(caddr_t, pair);
struct tree_cache	*tree_cache(struct tree *);
struct tree		*tree_host_lookup(char *);
struct dns_host_entry	*enter_dns_host(char *);
struct tree		*tree_const(unsigned char *, int);
struct tree		*tree_concat(struct tree *, struct tree *);
struct tree		*tree_limit(struct tree *, int);
int			 tree_evaluate(struct tree_cache *);

/* dhcp.c */
extern int	outstanding_pings;

void dhcp(struct packet *, int);
void dhcpdiscover(struct packet *);
void dhcprequest(struct packet *);
void dhcprelease(struct packet *);
void dhcpdecline(struct packet *);
void dhcpinform(struct packet *);
void nak_lease(struct packet *, struct iaddr *cip);
void ack_lease(struct packet *, struct lease *, unsigned int, time_t);
void dhcp_reply(struct lease *);
struct lease *find_lease(struct packet *, struct shared_network *, int *);
struct lease *mockup_lease(struct packet *, struct shared_network *,
    struct host_decl *);

/* bootp.c */
void bootp(struct packet *);

/* memory.c */
void enter_host(struct host_decl *);
struct host_decl *find_hosts_by_haddr(int, unsigned char *, int);
struct host_decl *find_hosts_by_uid(unsigned char *, int);
struct subnet *find_host_for_network(struct host_decl **, struct iaddr *,
    struct shared_network *);
void new_address_range(struct iaddr, struct iaddr, struct subnet *, int);
extern struct subnet *find_grouped_subnet(struct shared_network *,
    struct iaddr);
extern struct subnet *find_subnet(struct iaddr);
void enter_shared_network(struct shared_network *);
int subnet_inner_than(struct subnet *, struct subnet *, int);
void enter_subnet(struct subnet *);
void enter_lease(struct lease *);
int supersede_lease(struct lease *, struct lease *, int);
void release_lease(struct lease *);
void abandon_lease(struct lease *, char *);
struct lease *find_lease_by_uid(unsigned char *, int);
struct lease *find_lease_by_hw_addr(unsigned char *, int);
struct lease *find_lease_by_ip_addr(struct iaddr);
void uid_hash_add(struct lease *);
void uid_hash_delete(struct lease *);
void hw_hash_add(struct lease *);
void hw_hash_delete(struct lease *);
struct class *add_class(int, char *);
struct class *find_class(int, unsigned char *, int);
struct group *clone_group(struct group *, char *);
void write_leases(void);

/* alloc.c */
struct tree_cache *new_tree_cache(char *);
struct lease_state *new_lease_state(char *);
void free_lease_state(struct lease_state *, char *);
void free_tree_cache(struct tree_cache *);

/* print.c */
char *print_hw_addr(int, int, unsigned char *);

/* bpf.c */
int if_register_bpf(struct interface_info *);
void if_register_send(struct interface_info *);
void if_register_receive(struct interface_info *);
ssize_t receive_packet(struct interface_info *, unsigned char *, size_t,
    struct sockaddr_in *, struct hardware *);

/* dispatch.c */
extern struct interface_info *interfaces;
extern struct protocol *protocols;
extern struct dhcpd_timeout *timeouts;
void discover_interfaces(int *);
void dispatch(void);
int locate_network(struct packet *);
void got_one(struct protocol *);
void add_timeout(time_t, void (*)(void *), void *);
void cancel_timeout(void (*)(void *), void *);
void add_protocol (char *, int, void (*)(struct protocol *), void *);
void remove_protocol(struct protocol *);

/* hash.c */
struct hash_table *new_hash(void);
void add_hash(struct hash_table *, unsigned char *, int, unsigned char *);
void delete_hash_entry(struct hash_table *, unsigned char *, int);
unsigned char *hash_lookup(struct hash_table *, unsigned char *, int);

/* tables.c */
extern struct option dhcp_options[256];
extern unsigned char dhcp_option_default_priority_list[256];
extern char *hardware_types[256];
extern struct hash_table universe_hash;
extern struct universe dhcp_universe;
void initialize_universes(void);

/* convert.c */
u_int32_t getULong(unsigned char *);
int32_t getLong(unsigned char *);
u_int16_t getUShort(unsigned char *);
int16_t getShort(unsigned char *);
void putULong(unsigned char *, u_int32_t);
void putLong(unsigned char *, int32_t);
void putUShort(unsigned char *, unsigned int);
void putShort(unsigned char *, int);

/* inet.c */
struct iaddr subnet_number(struct iaddr, struct iaddr);
struct iaddr ip_addr(struct iaddr, struct iaddr, u_int32_t);
u_int32_t host_addr(struct iaddr, struct iaddr);
int addr_eq(struct iaddr, struct iaddr);
char *piaddr(struct iaddr);

/* db.c */
int write_lease(struct lease *);
int commit_leases(void);
void db_startup(void);
void new_lease_file(void);

/* packet.c */
void assemble_hw_header(struct interface_info *, unsigned char *,
    int *, struct hardware *);
void assemble_udp_ip_header(struct interface_info *, unsigned char *,
    int *, u_int32_t, u_int32_t, unsigned int, unsigned char *, int);
ssize_t decode_hw_header(unsigned char *, u_int32_t, struct hardware *);
ssize_t decode_udp_ip_header(unsigned char *, u_int32_t, struct sockaddr_in *);
u_int32_t	checksum(unsigned char *, u_int32_t, u_int32_t);
u_int32_t	wrapsum(u_int32_t);

/* icmp.c */
void icmp_startup(int, void (*)(struct iaddr, u_int8_t *, int));
int icmp_echorequest(struct iaddr *);
void icmp_echoreply(struct protocol *);

/* pfutils.c */
__dead void pftable_handler(void);
void pf_change_table(int, int, struct in_addr, char *);
void pf_kill_state(int, struct in_addr);
size_t atomicio(ssize_t (*)(int, void *, size_t), int, void *, size_t);
#define vwrite (ssize_t (*)(int, void *, size_t))write
void pfmsg(char, struct lease *);

/* udpsock.c */
void udpsock_startup(struct in_addr);
@


1.65
log
@Removed unused struct, also noticed by Edgar Pettijohn. ok jca@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.64 2017/04/24 14:58:36 krw Exp $ */
a75 19
struct string_list {
	struct string_list *next;
	char *string;
};

/* A name server, from /etc/resolv.conf. */
struct name_server {
	struct name_server *next;
	struct sockaddr_in addr;
	time_t rcdate;
};

/* A domain search list element. */
struct domain_search_list {
	struct domain_search_list *next;
	char *domain;
	time_t rcdate;
};

a279 6
struct hardware_link {
	struct hardware_link *next;
	char name[IFNAMSIZ];
	struct hardware address;
};

a292 14

/* Bitmask of dhcp option codes. */
typedef unsigned char option_mask[16];

/* DHCP Option mask manipulation macros... */
#define OPTION_ZERO(mask)	(memset (mask, 0, 16))
#define OPTION_SET(mask, bit)	(mask[bit >> 8] |= (1 << (bit & 7)))
#define OPTION_CLR(mask, bit)	(mask[bit >> 8] &= ~(1 << (bit & 7)))
#define OPTION_ISSET(mask, bit)	(mask[bit >> 8] & (1 << (bit & 7)))
#define OPTION_ISCLR(mask, bit)	(!OPTION_ISSET (mask, bit))

/* An option occupies its length plus two header bytes (code and
    length) for every 255 bytes that must be stored. */
#define OPTION_SPACE(x)		((x) + 2 * ((x) / 255 + 1))
@


1.64
log
@Add 'echo-client-id' statment, so that RFC 6842 behaviour can be
turned off for those clients and networks that find it impossible to
move past RFC 2131. Modelled on the same statement in recent ISC
versions, though we default to 'on' (a.k.a. RFC 6842) rather that
'off' (a.k.a. RFC 2131).

Problems reported by Bastien Durel (Xerox Phaser 6022 printer) and
Bryan Vyhmeister (Hon Hai Precision router) via misc@@. Thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.63 2017/04/18 13:59:09 krw Exp $ */
a54 5
};

struct iaddrlist {
	struct iaddrlist *next;
	struct iaddr addr;
@


1.63
log
@Tweak parameters to decode_*, add a check or two, and thus gain most of the
sanity improvements reyk@@ recently put into dhcrelay to ensure no more than
the captured packet is processed.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.62 2017/04/17 18:31:08 krw Exp $ */
d226 1
@


1.62
log
@Use better types for checksum() parameters and local var from
dhclient. Eliminate extra prototypes for checksum() and wrapsum().
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.61 2017/04/13 14:59:40 krw Exp $ */
d547 2
a548 4
ssize_t decode_hw_header(struct interface_info *, unsigned char *,
    int, struct hardware *);
ssize_t decode_udp_ip_header(struct interface_info *, unsigned char *,
    int, struct sockaddr_in *, int);
@


1.61
log
@Remove a bunch of obsolete, unused and irrelevant DHCP client types, fields,
and enums.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.60 2017/02/16 00:24:43 krw Exp $ */
d551 1
a551 1
u_int32_t	checksum(unsigned char *, unsigned, u_int32_t);
@


1.60
log
@Bring parse_warn() into the log.[ch] 21st century and adopt the "^"
placement logic from dhclient.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.59 2017/02/13 23:04:05 krw Exp $ */
a268 15
/* DHCP client lease structure... */
struct client_lease {
	struct client_lease *next;	/* Next lease in list. */
	time_t expiry, renewal, rebind;	/* Lease timeouts. */
	struct iaddr address;		/* Address being leased. */
	char *server_name;		/* Name of boot server. */
	char *filename;			/* File to boot. */
	struct string_list *medium;	/* Network medium. */

	unsigned int is_static : 1;	/* Lease is from config file. */
	unsigned int is_bootp: 1;	/* Lease was aquired with BOOTP. */

	struct option_data options[256];/* Options supplied with lease. */
};

a274 84
/* Possible states in which the client can be. */
enum dhcp_state {
	S_REBOOTING,
	S_INIT,
	S_SELECTING,
	S_REQUESTING,
	S_BOUND,
	S_RENEWING,
	S_REBINDING
};

/* Configuration information from the config file... */
struct client_config {
	struct option_data defaults[256]; /* Default values for options. */
	enum {
		ACTION_DEFAULT,		/* Use server value if present,
					   otherwise default. */
		ACTION_SUPERSEDE,	/* Always use default. */
		ACTION_PREPEND,		/* Prepend default to server. */
		ACTION_APPEND		/* Append default to server. */
	} default_actions[256];

	struct option_data send_options[256]; /* Send these to server. */
	u_int8_t required_options[256]; /* Options server must supply. */
	u_int8_t requested_options[256]; /* Options to request from server. */
	int requested_option_count;	/* Number of requested options. */
	time_t timeout;			/* Start to panic if we don't get a
					   lease in this time period when
					   SELECTING. */
	time_t initial_interval;	/* All exponential backoff intervals
					   start here. */
	time_t retry_interval;		/* If the protocol failed to produce
					   an address before the timeout,
					   try the protocol again after this
					   many seconds. */
	time_t select_interval;		/* Wait this many seconds from the
					   first DHCPDISCOVER before
					   picking an offered lease. */
	time_t reboot_timeout;		/* When in INIT-REBOOT, wait this
					   long before giving up and going
					   to INIT. */
	time_t backoff_cutoff;		/* When doing exponential backoff,
					   never back off to an interval
					   longer than this amount. */
	struct string_list *media;	/* Possible network media values. */
	char *script_name;		/* Name of config script. */
	enum { IGNORE, ACCEPT, PREFER } bootp_policy;
					/* Ignore, accept or prefer BOOTP
					   responses. */
	struct string_list *medium;	/* Current network medium. */

	struct iaddrlist *reject_list;	/* Servers to reject. */
};

/* Per-interface state used in the dhcp client... */
struct client_state {
	struct client_lease *active;		  /* Currently active lease. */
	struct client_lease *new;			       /* New lease. */
	struct client_lease *offered_leases;	    /* Leases offered to us. */
	struct client_lease *leases;		/* Leases we currently hold. */
	struct client_lease *alias;			     /* Alias lease. */

	enum dhcp_state state;		/* Current state for this interface. */
	struct iaddr destination;		    /* Where to send packet. */
	u_int32_t xid;					  /* Transaction ID. */
	u_int16_t secs;			    /* secs value from DHCPDISCOVER. */
	time_t first_sending;			/* When was first copy sent? */
	time_t interval;	      /* What's the current resend interval? */
	struct string_list *medium;		   /* Last media type tried. */

	struct dhcp_packet packet;		    /* Outgoing DHCP packet. */
	int packet_length;	       /* Actual length of generated packet. */

	struct iaddr requested_address;	    /* Address we would like to get. */

	struct client_config *config;	    /* Information from config file. */

	char **scriptEnv;  /* Client script env */
	int scriptEnvsize; /* size of the env table */

	struct string_list *env;	       /* Client script environment. */
	int envc;			/* Number of entries in environment. */
};

a293 2
	/* Only used by DHCP client code. */
	struct client_state *client;
@


1.60.4.1
log
@OpenBSD 6.1 errata 001, May 2, 2017

dhcpd(8) unconditionally echoed client identifier. Add parameter
"echo-client-id" to allow this behaviour to be turned off.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.60 2017/02/16 00:24:43 krw Exp $ */
a225 1
	int echo_client_id;
@


1.59
log
@Eliminate pointless'%m' (a.k.a. hand rolled strerror()) by using fatal() and
log_warn(). Zap a couple of explicit 'syslog()' calls.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.58 2017/02/13 22:33:39 krw Exp $ */
a467 2
extern int		log_priority;
extern int		log_perror;
@


1.58
log
@Adjust some long lines.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.57 2017/02/13 19:13:14 krw Exp $ */
a449 1
void	do_percentm(char *obuf, size_t size, char *ibuf);
@


1.57
log
@Switch from old errwarn.c logging to shiny new log.[ch].

ok benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.56 2017/02/11 16:12:36 krw Exp $ */
d271 6
a276 6
	struct client_lease *next;		/* Next lease in list. */
	time_t expiry, renewal, rebind;		/* Lease timeouts. */
	struct iaddr address;			/* Address being leased. */
	char *server_name;			/* Name of boot server. */
	char *filename;				/* File to boot. */
	struct string_list *medium;		/* Network medium. */
d278 2
a279 2
	unsigned int is_static : 1;	/* If set, lease is from config file. */
	unsigned int is_bootp: 1;	/* If set, lease was aquired with BOOTP. */
d281 1
a281 1
	struct option_data options[256];	/* Options supplied with lease. */
d518 2
a519 2
unsigned char		*parse_numeric_aggregate(FILE *, unsigned char *, int *,
			    int, int, int);
@


1.56
log
@Move parse_warning() into parse.c to prepare to replace errwarn.c
with standard daemon log.[ch].

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.55 2016/10/06 16:12:43 krw Exp $ */
d449 1
a462 7
/* errwarn.c */
extern int warnings_occurred;
void	error(char *, ...) __attribute__ ((__format__ (__printf__, 1, 2)));
int	warning(char *, ...) __attribute__ ((__format__ (__printf__, 1, 2)));
int	note(char *, ...) __attribute__ ((__format__ (__printf__, 1, 2)));
int	debug(char *, ...) __attribute__ ((__format__ (__printf__, 1, 2)));

a669 1
extern struct syslog_data sdata;
@


1.55
log
@Add support for RFC 6842. RFC 2131 said the server MUST NOT echo
the client-identifier value. RFC 6842 says the server MUST echo it.

Echoing the information disambiguates packets for relays and clients
when chaddr is 0. Similar to what dhcpv6 does.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.54 2016/08/05 14:02:23 krw Exp $ */
d448 5
a467 1
int	parse_warn(char *, ...) __attribute__ ((__format__ (__printf__, 1, 2)));
@


1.54
log
@Don't leak the option data of non-DHCPINFORM messages received on
the udp socket.

Found by David Carlier.

ok yasuoka@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.53 2016/02/06 23:50:10 krw Exp $ */
d139 1
d145 1
@


1.53
log
@Eliminate #include inside *.h files and include only needed headers in
each *.c file.

Inspired by mention of header silliness by Edgar Pettijohn and mmcc@@
on tech@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.52 2014/07/11 16:48:29 yasuoka Exp $ */
d535 1
a535 1
void dhcp(struct packet *);
@


1.52
log
@Fix DHCPINFORM not to lookup the lease database, not to fill the yiaddr
field and not to include the lease time parameters.

ok krw
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.51 2014/07/11 09:42:27 yasuoka Exp $ */
a40 28
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/sockio.h>
#include <sys/time.h>

#include <net/if.h>
#include <net/if_dl.h>
#include <net/route.h>

#include <netinet/in.h>
#include <arpa/inet.h>

#include <ctype.h>
#include <errno.h>
#include <fcntl.h>
#include <limits.h>
#include <netdb.h>
#include <paths.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <syslog.h>
#include <time.h>
#include <unistd.h>

a44 3

#include "dhcp.h"
#include "tree.h"
@


1.51
log
@Add -u option to bind UDP port as a socket to answer DHCPINFORM from
the clients on non ethernet interfaces (eg. tun(4) or pppx(4)).

input krw
ok krw
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.50 2014/05/07 13:20:47 pelikan Exp $ */
d183 1
@


1.50
log
@back out the previous ICMP simplifying diff, it caused livelocks.

reported by Mikolaj Kucharski, thanks!
ok krw
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.49 2014/05/05 18:30:44 pelikan Exp $ */
d427 3
a621 2
ssize_t send_packet(struct interface_info *, struct dhcp_packet *, size_t,
    struct in_addr, struct sockaddr_in *, struct hardware *);
d701 3
@


1.49
log
@Don't call the BOOTP handler indirectly.

ok krw
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.48 2014/05/05 18:27:57 pelikan Exp $ */
d688 3
a690 3
void	icmp_startup(void);
int	icmp_echorequest(struct iaddr *);
void	icmp_echoreply(struct protocol *);
@


1.48
log
@Don't call the ICMP handler indirectly + clean up a bit.

ok krw
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.47 2013/04/17 19:26:10 krw Exp $ */
a627 2
extern void (*bootp_packet_handler)(struct interface_info *,
    struct dhcp_packet *, int, unsigned int, struct iaddr, struct hardware *);
@


1.47
log
@Replace hand-rolled date printing/parsing code with strftime()/strptime().
Use timegm() because all the dates are in UTC and the 'standard'
routines can't handle the truth.

Remove some 'time_t is 32bits' assumptions.

Print 'UTC' at the end of dates in the leases file, rather than
mentioning that all dates are UTC in a comment at the top of the
file.

Feedback and suggestions from guenther@@, kettenis@@, otto@@, tedu@@,
deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.46 2013/02/03 21:04:19 krw Exp $ */
d690 3
a692 3
void icmp_startup(int, void (*)(struct iaddr, u_int8_t *, int));
int icmp_echorequest(struct iaddr *);
void icmp_echoreply(struct protocol *);
@


1.46
log
@Remove unused (a.k.a. always passed NULL) parameter 'data' from
decode_udp_ip_header() and the useless check of it. Part of original
diff from pelikan about udp length errors.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.45 2010/04/19 12:22:09 claudio Exp $ */
d76 3
@


1.45
log
@If interfaces are specified, get their rdomain and bind dhcpd into the same
domain with setrdomain(). This allows to run dhcpd on multiple rdomains.
OK krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.44 2010/01/02 04:21:16 krw Exp $ */
d682 1
a682 1
    int, struct sockaddr_in *, unsigned char *, int);
@


1.44
log
@Eliminate all uses of dmalloc() where the returned pointer
is checked for NULL and a specific error/warning issued. Add
two such manual warning/error checks and kill those dmalloc
calls. And then there were none, so kill dmalloc(). Whew.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.43 2010/01/01 20:30:25 krw Exp $ */
d628 1
a628 1
void discover_interfaces(void);
@


1.43
log
@Wrappers around a wrapper around free() are of no more use than
wrappers around wrappers around calloc().

The purpose of the free() wrapper is to generate an error message
when free'ing NULL. But free_hash_bucket(), free_lease(), and
free_tree() are all called immediately after dereferencing the
pointer to be freed. Thus the error message will never be issued.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.42 2010/01/01 19:10:24 krw Exp $ */
a604 2
void * dmalloc(int, char *);
void dfree(void *, char *);
@


1.42
log
@A slightly more complex calloc() wrapper wrapper, new_hash_table(),
bites the dust.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.41 2010/01/01 18:01:44 krw Exp $ */
a609 2
void free_lease(struct lease *, char *);
void free_hash_bucket(struct hash_bucket *, char *);
a610 1
void free_tree(struct tree *, char *);
@


1.41
log
@Another calloc() wrapper wrapper, new_tree(), bites the dust.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.40 2010/01/01 08:02:34 krw Exp $ */
a607 1
struct hash_table *new_hash_table(int, char *);
@


1.40
log
@Two more calloc() wrapper wrappers, new_shared_network() and
new_subnet(), bite the dust.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.39 2010/01/01 06:25:37 krw Exp $ */
a606 1
struct tree *new_tree(char *);
@


1.39
log
@Single-use wrapper functions that just call a wrapper function
around calloc() and end up producing duplicate error messages are
just confusing.

Eliminate new_hash_bucket(), new_lease(), new_leases(), new_group().
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.38 2010/01/01 02:38:02 krw Exp $ */
a609 2
struct subnet *new_subnet(char *);
struct shared_network *new_shared_network(char *);
@


1.38
log
@Delete unused declarations.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.37 2010/01/01 01:47:41 krw Exp $ */
a609 3
struct hash_bucket *new_hash_bucket(char *);
struct lease *new_lease(char *);
struct lease *new_leases(int, char *);
a611 1
struct group *new_group(char *);
@


1.37
log
@Plug a potential leak similar to the one parfait spotted and Theo
fixed.

Eliminate the function new_class() by expanding the only use

Use strdup() and calloc() rather than manually simulating them.

No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.36 2008/05/07 12:19:20 beck Exp $ */
a606 2
struct packet *new_packet(char *);
struct dhcp_packet *new_dhcp_packet(char *);
a615 1
struct protocol *new_protocol(char *);
a616 4
struct domain_search_list *new_domain_search_list(char *);
struct name_server *new_name_server(char *);
void free_name_server(struct name_server *, char *);
void free_domain_search_list(struct domain_search_list *, char *);
a617 5
void free_protocol(struct protocol *, char *);
void free_group(struct group *, char *);
void free_shared_network(struct shared_network *, char *);
void free_class(struct class *, char *);
void free_subnet(struct subnet *, char *);
@


1.36
log
@Add synchronisation support for dhcpd - this allows for two dhcpd's
with the same configuration to be run on the same net and they will
keep their lease files/state in synch, and therefore allowing you to
run redundant dhcpd's. Synchronization code stolen from spamd, uses
an hmac key in /var/db/dhcpd.key if it exists.
ok krw@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.35 2008/01/18 20:14:03 krw Exp $ */
a615 1
struct class *new_class(char *);
@


1.35
log
@Call store_options() with correct cutoff values, i.e. ones not 7 bytes
too large. Fixes a problem where a nicely crafted packet could crash
dhcpd. Nuke a superfluous declaration of store_options() while here.

Problem found and fix tested by Peter Hessler.

ok beck@@ millert@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.34 2007/10/29 16:51:02 krw Exp $ */
d724 1
@


1.34
log
@More tweaking of option processing, this time around the creation of
the priority list. Add create_priority_list() and use it to
consistantly merge mandatory, supplied and default option priority
lists into a reliable and complete list of options sorted by priority.
No intended functional change other than ensuring all options
available are returned.

"looks good" henning@@ "OK, fair enough" millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.33 2007/02/22 07:02:31 henning Exp $ */
a474 2
int	 store_options(unsigned char *, int, struct tree_cache **,
	    unsigned char *, int, int, int);
@


1.33
log
@another dead extern; Mark Lumsden <mark@@cyodesigns.com>
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.32 2007/02/18 21:19:00 henning Exp $ */
d476 1
a476 1
	    unsigned char *, int, int, int, int);
d673 1
a673 2
extern unsigned char dhcp_option_default_priority_list[];
extern int sizeof_dhcp_option_default_priority_list;
@


1.32
log
@unused extern decl
From: Mark Lumsden <mark@@cyodesigns.com>
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.31 2007/02/06 21:12:07 stevesk Exp $ */
a67 2

extern int h_errno;
@


1.31
log
@spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.30 2007/02/06 17:58:39 stevesk Exp $ */
a501 1
extern char		*path_dhcpd_pid;
@


1.30
log
@remove some dangling function prototypes
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.29 2007/01/04 19:12:41 stevesk Exp $ */
d725 2
a726 2
void pf_change_table(int , int , struct in_addr , char *);
void pf_kill_state(int , struct in_addr );
@


1.29
log
@<sys/un.h> not needed
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.28 2006/12/17 18:03:33 stevesk Exp $ */
a642 1
void dump_raw(unsigned char *, int);
a645 1
void if_reinitialize_send(struct interface_info *);
a648 1
void if_reinitialize_receive(struct interface_info *);
a651 3
int can_unicast_without_arp(void);
int can_receive_unicast_unconfigured(struct interface_info *);
void maybe_setup_fallback(void);
@


1.28
log
@remove one-lease-per-client parameter which was never implemented (it
doesn't do anything and is not documented); ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.27 2006/12/12 19:32:21 stevesk Exp $ */
a42 1
#include <sys/un.h>
@


1.27
log
@<signal.h> not needed
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.26 2006/12/11 23:40:30 stevesk Exp $ */
a248 1
	int one_lease_per_client;
@


1.26
log
@spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.25 2006/11/22 19:10:39 stevesk Exp $ */
a61 1
#include <signal.h>
@


1.25
log
@small header cleanup:
remove uneeded header
use <foo.h> not "foo.h" for system include

no binary change; ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.24 2006/11/21 16:26:56 stevesk Exp $ */
d315 1
a315 1
struct pf_cmd{
@


1.24
log
@remove unused #defines;
remove duplicate #defines;
remove DEBUG;
remove useless comment;
no need to #ifdef protect.

no binary change; ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.23 2006/11/21 00:10:06 stevesk Exp $ */
a61 1
#include <setjmp.h>
@


1.23
log
@re-order includes and eliminate duplicates, no binary change; ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.22 2006/11/20 19:14:23 stevesk Exp $ */
a75 11
#ifndef _PATH_DHCPD_PID
#define _PATH_DHCPD_PID	"/var/run/dhcpd.pid"
#endif
#ifndef _PATH_DHCPD_DB
#define _PATH_DHCPD_DB "/var/db/dhcpd.leases"
#endif

#ifndef _PATH_DEV_PF
#define _PATH_DEV_PF "/dev/pf"
#endif

a465 8
/* Default path to dhcpd config file. */
#ifdef DEBUG
#undef _PATH_DHCPD_CONF
#define _PATH_DHCPD_CONF	"dhcpd.conf"
#undef _PATH_DHCPD_DB
#define _PATH_DHCPD_DB		"dhcpd.leases"
#else
#ifndef _PATH_DHCPD_CONF
d467 2
a468 32
#endif

#ifndef _PATH_DHCPD_DB
#define _PATH_DHCPD_DB		"/etc/dhcpd.leases"
#endif

#ifndef _PATH_DHCPD_PID
#define _PATH_DHCPD_PID		"/var/run/dhcpd.pid"
#endif
#endif

#ifndef _PATH_DHCLIENT_CONF
#define _PATH_DHCLIENT_CONF	"/etc/dhclient.conf"
#endif

#ifndef _PATH_DHCLIENT_PID
#define _PATH_DHCLIENT_PID	"/var/run/dhclient.pid"
#endif

#ifndef _PATH_DHCLIENT_DB
#define _PATH_DHCLIENT_DB	"/etc/dhclient.leases"
#endif

#ifndef _PATH_RESOLV_CONF
#define _PATH_RESOLV_CONF	"/etc/resolv.conf"
#endif

#ifndef _PATH_DHCRELAY_PID
#define _PATH_DHCRELAY_PID	"/var/run/dhcrelay.pid"
#endif

#ifndef DHCPD_LOG_FACILITY
a469 1
#endif
@


1.22
log
@KNF (no space before '['); ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.21 2006/06/14 14:58:52 ckuethe Exp $ */
a41 1
#include <netinet/in.h>
d44 10
d55 5
d61 4
a64 1
#include <fcntl.h>
d66 1
a66 1
#include <unistd.h>
d68 1
a68 3
#include <stdlib.h>
#include <sys/stat.h>
#include <ctype.h>
a69 7

#include <syslog.h>
#include <sys/types.h>
#include <string.h>
#include <paths.h>
#include <errno.h>
#include <stdlib.h>
a70 5
#include <setjmp.h>
#include <limits.h>

#include <sys/wait.h>
#include <signal.h>
a73 5
#include <net/if.h>
#include <net/if_dl.h>
#include <net/route.h>
#include <sys/sockio.h>

a75 2
#include <stdarg.h>

a85 3

/* Time stuff... */
#include <sys/time.h>
@


1.21
log
@This diff allows dhcpd to put active leases into a pf table. Dhcpd will then
periodically - based on the length of the shortest lease time - walk across
all leases searching for expired leases which are then removed from the pf
table.

ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.20 2006/06/14 14:49:46 ckuethe Exp $ */
d105 1
a105 1
	unsigned char iabuf [16];
d124 1
a124 1
	struct hash_bucket *buckets [DEFAULT_HASH_SIZE];
d164 1
a164 1
	struct option_data options [256];
d172 1
a172 1
	u_int8_t haddr [16];
d187 1
a187 1
	unsigned char uid_buf [32];
d215 1
a215 1
	struct tree_cache *options [256];
d217 1
a217 1
	char filename [DHCP_FILE_LEN];
d276 1
a276 1
	struct tree_cache *options [256];
d330 1
a330 1
	struct option_data options [256];	/* Options supplied with lease. */
d352 1
a352 1
	struct option_data defaults [256]; /* Default values for options. */
d359 1
a359 1
	} default_actions [256];
d361 3
a363 3
	struct option_data send_options [256]; /* Send these to server. */
	u_int8_t required_options [256]; /* Options server must supply. */
	u_int8_t requested_options [256]; /* Options to request from server. */
d431 1
a431 1
	char name [IFNAMSIZ];		/* Its name... */
d452 1
a452 1
	char name [IFNAMSIZ];
d471 1
a471 1
typedef unsigned char option_mask [16];
d475 3
a477 3
#define OPTION_SET(mask, bit)	(mask [bit >> 8] |= (1 << (bit & 7)))
#define OPTION_CLR(mask, bit)	(mask [bit >> 8] &= ~(1 << (bit & 7)))
#define OPTION_ISSET(mask, bit)	(mask [bit >> 8] & (1 << (bit & 7)))
d574 1
a574 1
extern char	 comments [4096];
d742 2
a743 2
extern struct option dhcp_options [256];
extern unsigned char dhcp_option_default_priority_list [];
d745 1
a745 1
extern char *hardware_types [256];
@


1.20
log
@Move the transmission of privsep messages into its own function. Wherever
we might have conditionally sent a message, we now just call the pfmsg()
function, and let it figure out whether the message should be sent or not.

ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.19 2006/05/31 02:43:15 ckuethe Exp $ */
d569 1
@


1.19
log
@This diff makes dhcpd able to manipulate pf tables on certain lease events.

dhcpd is now able to place abandoned addresses into a table (to offer some
protection against machines camping on an address) and remove them from the
table if they are properly leased.

When dhcpd assigns an IP to a new hardware address, it can remove that
address from a table. This is for use with the overload table in pf; newly
arrived machines will not be punished for the actions of a machine that
went away.

beck@@ and krw@@ liked previous versions of this, henning@@ final ok
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.18 2006/05/30 23:43:46 ckuethe Exp $ */
d795 1
@


1.18
log
@This patch renames dhcpd's "struct timeout" to "struct dhcpd_timeout"
so as not to conflict with "struct timeout" from <sys/timeout.h>.
ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.17 2006/05/11 01:19:08 krw Exp $ */
d87 4
d333 6
d788 7
@


1.17
log
@If a list of interfaces is supplied via the command line or
dhcpd.interfaces then

a) don't bother looking up information on interfaces that were not
requested;

b) don't exit if a requested interface is not found, just issue a
warning message;

c) exit if none of the interfaces were found.

The command line for dhcpd shown in ps will continue to show requested
but ignored interfaces.

As usual with dhc* code, whack a bunch of unused states, constants,
flags, etc. Since we only invoke discover_interfaces() with
DISCOVER_SERVER, there is no need to keep track of other
possibilities.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.16 2004/10/31 10:43:38 canacar Exp $ */
d446 2
a447 2
struct timeout {
	struct timeout *next;
d714 1
a714 1
extern struct timeout *timeouts;
@


1.16
log
@change the undocumented -t flag to -n used for configuration testing
and document it. cleanup some unused/unneeded variables while there.
idea & ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.15 2004/09/16 18:35:43 deraadt Exp $ */
a244 8
/* Possible modes in which discover_interfaces can run. */

#define DISCOVER_RUNNING	0
#define DISCOVER_SERVER		1
#define DISCOVER_UNCONFIGURED	2
#define DISCOVER_RELAY		3
#define DISCOVER_REQUESTED	4

a430 3
	u_int32_t flags;		/* Control flags... */
#define INTERFACE_REQUESTED 1
#define INTERFACE_AUTOMATIC 2
d715 1
a715 1
void discover_interfaces(int);
@


1.15
log
@avoid aliasing with libc functions; ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.14 2004/09/16 09:35:24 claudio Exp $ */
a722 1
extern int quiet_interface_discovery;
@


1.14
log
@Remove the not initialized fallback_interface code and use the normal bpf
interface for that. Also store the hardware (ethernet) address in the state
so that relayed dhcp request are sent to the correct destination.
OK henning@@ requested by deraadt@@ tested otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.13 2004/05/04 21:25:27 deraadt Exp $ */
d548 1
a548 1
int	warn(char *, ...) __attribute__ ((__format__ (__printf__, 1, 2)));
@


1.13
log
@remove DEBUG_PACKET stuff; henning ok
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.12 2004/05/04 20:28:40 deraadt Exp $ */
d235 1
d721 1
a721 2
extern struct interface_info *interfaces,
	*dummy_interfaces, *fallback_interface;
@


1.12
log
@remove things not used, spotted by lint mostly; ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.11 2004/04/22 15:22:48 henning Exp $ */
a703 3
#ifdef DEBUG_PACKET
void dump_packet(struct packet *);
#endif
@


1.11
log
@instead of using some lower 16 bits of some address on the stack that
even requires knowledge about wether the machine is 32 or 64 bit, use getpid()
for the icmp id. that is not optimal, but matches what ping does and the
way to go for now.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.10 2004/04/21 09:11:58 canacar Exp $ */
a667 1
void dump_subnets(void);
a687 1
struct string_list *new_string_list(size_t size, char * name);
d698 1
a698 4
void free_hash_table(struct hash_table *, char *);
void free_tree_cache(struct tree_cache *, char *);
void free_packet(struct packet *, char *);
void free_dhcp_packet(struct dhcp_packet *, char *);
a699 1
void free_string_list(struct string_list *, char *);
a702 1
void print_lease(struct lease *);
d704 1
d706 1
a706 1
void hash_dump(struct hash_table *);
d712 2
a713 3
ssize_t send_packet(struct interface_info *, struct packet *,
    struct dhcp_packet *, size_t, struct in_addr, struct sockaddr_in *,
    struct hardware *);
a730 2
struct interface_info *setup_fallback(void);
void reinitialize_interfaces(void);
a766 1
struct iaddr broadcast_addr(struct iaddr, struct iaddr);
@


1.10
log
@filter writes and lock bpf descriptor, ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcpd.h,v 1.9 2004/04/20 05:35:33 henning Exp $ */
a91 4

#if defined(__alpha__) || (defined(__sparc64__) && defined(__arch64__))
#define PTRSIZE_64BIT
#endif
@


1.9
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d100 2
a101 1
#define LOCAL_PORT	68
d560 2
a561 2
extern u_int16_t	local_port;
extern u_int16_t	remote_port;
@


1.8
log
@various knf; henning ok
@
text
@d1 1
a1 3
/* dhcpd.h

   Definitions for dhcpd... */
@


1.7
log
@spaces
@
text
@d102 1
a102 1
#define LOCAL_PORT      68
d197 7
a203 7
#       define STATIC_LEASE		1
#       define BOOTP_LEASE		2
#	define DYNAMIC_BOOTP_OK		4
#	define PERSISTENT_FLAGS		(DYNAMIC_BOOTP_OK)
#	define EPHEMERAL_FLAGS		(BOOTP_LEASE)
#	define MS_NULL_TERMINATION	8
#	define ABANDONED_LEASE		16
d328 6
a333 6
	struct client_lease *next;		      /* Next lease in list. */
	time_t expiry, renewal, rebind;			  /* Lease timeouts. */
	struct iaddr address;			    /* Address being leased. */
	char *server_name;			     /* Name of boot server. */
	char *filename;		     /* Name of file we're supposed to boot. */
	struct string_list *medium;			  /* Network medium. */
d335 2
a336 2
	unsigned int is_static : 1;    /* If set, lease is from config file. */
	unsigned int is_bootp: 1;   /* If set, lease was aquired with BOOTP. */
d338 1
a338 1
	struct option_data options [256];    /* Options supplied with lease. */
@


1.6
log
@fold in 10liners and clean up other .hs a bit
@
text
@d270 1
a270 1
	char *server_name;	
d346 1
a346 1
	S_REQUESTING, 
@


1.5
log
@more crap bites the dust
@
text
@a100 2
#include "hash.h"
#include "inet.h"
d103 24
@


1.4
log
@bye bye
@
text
@a98 1
#include "cdefs.h"
a102 1
#include "sysconf.h"
d442 1
a442 1
	void (*func) PROTO ((void *));
d449 1
a449 1
	void (*handler) PROTO ((struct protocol *));
d517 9
a525 13

void parse_options PROTO ((struct packet *));
void parse_option_buffer PROTO ((struct packet *, unsigned char *, int));
int cons_options PROTO ((struct packet *, struct dhcp_packet *, int,
			 struct tree_cache **, int, int, int,
			 u_int8_t *, int));
int store_options PROTO ((unsigned char *, int, struct tree_cache **,
			   unsigned char *, int, int, int, int));
char *pretty_print_option PROTO ((unsigned int,
				  unsigned char *, int, int, int));
void do_packet PROTO ((struct interface_info *,
		       struct dhcp_packet *, int,
		       unsigned int, struct iaddr, struct hardware *));
d529 5
a533 5
void error (char *, ...) __attribute__ ((__format__ (__printf__, 1, 2)));
int warn (char *, ...) __attribute__ ((__format__ (__printf__, 1, 2)));
int note (char *, ...) __attribute__ ((__format__ (__printf__, 1, 2)));
int debug (char *, ...) __attribute__ ((__format__ (__printf__, 1, 2)));
int parse_warn (char *, ...) __attribute__ ((__format__ (__printf__, 1, 2)));
d536 2
a537 2
extern time_t cur_time;
extern struct group root_group;
d539 13
a551 13
extern u_int16_t local_port;
extern u_int16_t remote_port;
extern int log_priority;
extern int log_perror;

extern char *path_dhcpd_conf;
extern char *path_dhcpd_db;
extern char *path_dhcpd_pid;

int main PROTO ((int, char **));
void cleanup PROTO ((void));
void lease_pinged PROTO ((struct iaddr, u_int8_t *, int));
void lease_ping_timeout PROTO ((void *));
d554 9
a562 8
extern int lexline, lexchar;
extern char *token_line, *tlname;
extern char comments [4096];
extern int comment_index;
extern int eol_token;
void new_parse PROTO ((char *));
int next_token PROTO ((char **, FILE *));
int peek_token PROTO ((char **, FILE *));
d565 28
a592 29
int readconf PROTO ((void));
void read_leases PROTO ((void));
int parse_statement PROTO ((FILE *,
			    struct group *, int, struct host_decl *, int));
void parse_allow_deny PROTO ((FILE *, struct group *, int));
void skip_to_semi PROTO ((FILE *));
int parse_boolean PROTO ((FILE *));
int parse_semi PROTO ((FILE *));
int parse_lbrace PROTO ((FILE *));
void parse_host_declaration PROTO ((FILE *, struct group *));
char *parse_host_name PROTO ((FILE *));
void parse_class_declaration PROTO ((FILE *, struct group *, int));
void parse_lease_time PROTO ((FILE *, time_t *));
void parse_shared_net_declaration PROTO ((FILE *, struct group *));
void parse_subnet_declaration PROTO ((FILE *, struct shared_network *));
void parse_group_declaration PROTO ((FILE *, struct group *));
void parse_hardware_param PROTO ((FILE *, struct hardware *));
char *parse_string PROTO ((FILE *));
struct tree *parse_ip_addr_or_hostname PROTO ((FILE *, int));
struct tree_cache *parse_fixed_addr_param PROTO ((FILE *));
void parse_option_param PROTO ((FILE *, struct group *));
time_t parse_timestamp PROTO ((FILE *));
struct lease *parse_lease_declaration PROTO ((FILE *));
void parse_address_range PROTO ((FILE *, struct subnet *));
time_t parse_date PROTO ((FILE *));
unsigned char *parse_numeric_aggregate PROTO ((FILE *,
					       unsigned char *, int *,
					       int, int, int));
void convert_num PROTO ((unsigned char *, char *, int, int));
d595 8
a602 8
pair cons PROTO ((caddr_t, pair));
struct tree_cache *tree_cache PROTO ((struct tree *));
struct tree *tree_host_lookup PROTO ((char *));
struct dns_host_entry *enter_dns_host PROTO ((char *));
struct tree *tree_const PROTO ((unsigned char *, int));
struct tree *tree_concat PROTO ((struct tree *, struct tree *));
struct tree *tree_limit PROTO ((struct tree *, int));
int tree_evaluate PROTO ((struct tree_cache *));
d605 1
a605 1
extern int outstanding_pings;
d607 12
a618 14
void dhcp PROTO ((struct packet *));
void dhcpdiscover PROTO ((struct packet *));
void dhcprequest PROTO ((struct packet *));
void dhcprelease PROTO ((struct packet *));
void dhcpdecline PROTO ((struct packet *));
void dhcpinform PROTO ((struct packet *));
void nak_lease PROTO ((struct packet *, struct iaddr *cip));
void ack_lease PROTO ((struct packet *, struct lease *, unsigned int, time_t));
void dhcp_reply PROTO ((struct lease *));
struct lease *find_lease PROTO ((struct packet *,
				 struct shared_network *, int *));
struct lease *mockup_lease PROTO ((struct packet *,
				   struct shared_network *,
				   struct host_decl *));
d621 1
a621 1
void bootp PROTO ((struct packet *));
d624 28
a651 30
void enter_host PROTO ((struct host_decl *));
struct host_decl *find_hosts_by_haddr PROTO ((int, unsigned char *, int));
struct host_decl *find_hosts_by_uid PROTO ((unsigned char *, int));
struct subnet *find_host_for_network PROTO ((struct host_decl **,
					     struct iaddr *,
					     struct shared_network *));
void new_address_range PROTO ((struct iaddr, struct iaddr,
			       struct subnet *, int));
extern struct subnet *find_grouped_subnet PROTO ((struct shared_network *,
						  struct iaddr));
extern struct subnet *find_subnet PROTO ((struct iaddr));
void enter_shared_network PROTO ((struct shared_network *));
int subnet_inner_than PROTO ((struct subnet *, struct subnet *, int));
void enter_subnet PROTO ((struct subnet *));
void enter_lease PROTO ((struct lease *));
int supersede_lease PROTO ((struct lease *, struct lease *, int));
void release_lease PROTO ((struct lease *));
void abandon_lease PROTO ((struct lease *, char *));
struct lease *find_lease_by_uid PROTO ((unsigned char *, int));
struct lease *find_lease_by_hw_addr PROTO ((unsigned char *, int));
struct lease *find_lease_by_ip_addr PROTO ((struct iaddr));
void uid_hash_add PROTO ((struct lease *));
void uid_hash_delete PROTO ((struct lease *));
void hw_hash_add PROTO ((struct lease *));
void hw_hash_delete PROTO ((struct lease *));
struct class *add_class PROTO ((int, char *));
struct class *find_class PROTO ((int, unsigned char *, int));
struct group *clone_group PROTO ((struct group *, char *));
void write_leases PROTO ((void));
void dump_subnets PROTO ((void));
d654 35
a688 35
void * dmalloc PROTO ((int, char *));
void dfree PROTO ((void *, char *));
struct packet *new_packet PROTO ((char *));
struct dhcp_packet *new_dhcp_packet PROTO ((char *));
struct tree *new_tree PROTO ((char *));
struct tree_cache *new_tree_cache PROTO ((char *));
struct hash_table *new_hash_table PROTO ((int, char *));
struct hash_bucket *new_hash_bucket PROTO ((char *));
struct lease *new_lease PROTO ((char *));
struct lease *new_leases PROTO ((int, char *));
struct subnet *new_subnet PROTO ((char *));
struct class *new_class PROTO ((char *));
struct shared_network *new_shared_network PROTO ((char *));
struct group *new_group PROTO ((char *));
struct protocol *new_protocol PROTO ((char *));
struct lease_state *new_lease_state PROTO ((char *));
struct domain_search_list *new_domain_search_list PROTO ((char *));
struct name_server *new_name_server PROTO ((char *));
struct string_list *new_string_list PROTO ((size_t size, char * name));
void free_name_server PROTO ((struct name_server *, char *));
void free_domain_search_list PROTO ((struct domain_search_list *, char *));
void free_lease_state PROTO ((struct lease_state *, char *));
void free_protocol PROTO ((struct protocol *, char *));
void free_group PROTO ((struct group *, char *));
void free_shared_network PROTO ((struct shared_network *, char *));
void free_class PROTO ((struct class *, char *));
void free_subnet PROTO ((struct subnet *, char *));
void free_lease PROTO ((struct lease *, char *));
void free_hash_bucket PROTO ((struct hash_bucket *, char *));
void free_hash_table PROTO ((struct hash_table *, char *));
void free_tree_cache PROTO ((struct tree_cache *, char *));
void free_packet PROTO ((struct packet *, char *));
void free_dhcp_packet PROTO ((struct dhcp_packet *, char *));
void free_tree PROTO ((struct tree *, char *));
void free_string_list PROTO ((struct string_list *, char *));
d691 5
a695 5
char *print_hw_addr PROTO ((int, int, unsigned char *));
void print_lease PROTO ((struct lease *));
void dump_raw PROTO ((unsigned char *, int));
void dump_packet PROTO ((struct packet *));
void hash_dump PROTO ((struct hash_table *));
d698 13
a710 15
int if_register_bpf PROTO ( (struct interface_info *));
void if_reinitialize_send PROTO ((struct interface_info *));
void if_register_send PROTO ((struct interface_info *));
ssize_t send_packet PROTO ((struct interface_info *,
			    struct packet *, struct dhcp_packet *, size_t,
			    struct in_addr,
			    struct sockaddr_in *, struct hardware *));
void if_reinitialize_receive PROTO ((struct interface_info *));
void if_register_receive PROTO ((struct interface_info *));
ssize_t receive_packet PROTO ((struct interface_info *,
			       unsigned char *, size_t,
			       struct sockaddr_in *, struct hardware *));
int can_unicast_without_arp PROTO ((void));
int can_receive_unicast_unconfigured PROTO ((struct interface_info *));
void maybe_setup_fallback PROTO ((void));
d717 2
a718 4
extern void (*bootp_packet_handler) PROTO ((struct interface_info *,
					    struct dhcp_packet *, int,
					    unsigned int,
					    struct iaddr, struct hardware *));
d720 10
a729 12
void discover_interfaces PROTO ((int));
struct interface_info *setup_fallback PROTO ((void));
void reinitialize_interfaces PROTO ((void));
void dispatch PROTO ((void));
int locate_network PROTO ((struct packet *));
void got_one PROTO ((struct protocol *));
void add_timeout PROTO ((time_t, void (*) PROTO ((void *)), void *));
void cancel_timeout PROTO ((void (*) PROTO ((void *)), void *));
void add_protocol PROTO ((char *, int,
			  void (*) PROTO ((struct protocol *)), void *));

void remove_protocol PROTO ((struct protocol *));
d732 4
a735 5
struct hash_table *new_hash PROTO ((void));
void add_hash PROTO ((struct hash_table *, unsigned char *,
		      int, unsigned char *));
void delete_hash_entry PROTO ((struct hash_table *, unsigned char *, int));
unsigned char *hash_lookup PROTO ((struct hash_table *, unsigned char *, int));
d744 1
a744 1
void initialize_universes PROTO ((void));
d747 8
a754 8
u_int32_t getULong PROTO ((unsigned char *));
int32_t getLong PROTO ((unsigned char *));
u_int16_t getUShort PROTO ((unsigned char *));
int16_t getShort PROTO ((unsigned char *));
void putULong PROTO ((unsigned char *, u_int32_t));
void putLong PROTO ((unsigned char *, int32_t));
void putUShort PROTO ((unsigned char *, unsigned int));
void putShort PROTO ((unsigned char *, int));
d757 6
a762 60
struct iaddr subnet_number PROTO ((struct iaddr, struct iaddr));
struct iaddr ip_addr PROTO ((struct iaddr, struct iaddr, u_int32_t));
struct iaddr broadcast_addr PROTO ((struct iaddr, struct iaddr));
u_int32_t host_addr PROTO ((struct iaddr, struct iaddr));
int addr_eq PROTO ((struct iaddr, struct iaddr));
char *piaddr PROTO ((struct iaddr));

/* dhclient.c */
extern char *path_dhclient_conf;
extern char *path_dhclient_db;
extern char *path_dhclient_pid;
extern int interfaces_requested;

extern struct client_config top_level_config;

void dhcpoffer PROTO ((struct packet *));
void dhcpack PROTO ((struct packet *));
void dhcpnak PROTO ((struct packet *));

void send_discover PROTO ((void *));
void send_request PROTO ((void *));
void send_release PROTO ((void *));
void send_decline PROTO ((void *));

void state_reboot PROTO ((void *));
void state_init PROTO ((void *));
void state_selecting PROTO ((void *));
void state_requesting PROTO ((void *));
void state_bound PROTO ((void *));
void state_panic PROTO ((void *));

void bind_lease PROTO ((struct interface_info *));

void make_discover PROTO ((struct interface_info *, struct client_lease *));
void make_request PROTO ((struct interface_info *, struct client_lease *));
void make_decline PROTO ((struct interface_info *, struct client_lease *));
void make_release PROTO ((struct interface_info *, struct client_lease *));

void free_client_lease PROTO ((struct client_lease *));
void rewrite_client_leases PROTO ((void));
void write_client_lease PROTO ((struct interface_info *,
				 struct client_lease *, int));

void script_init PROTO ((struct interface_info *, char *,
			 struct string_list *));
void script_write_params PROTO ((struct interface_info *,
				 char *, struct client_lease *));
int script_go PROTO ((struct interface_info *));
void client_envadd PROTO ((struct client_state *,
			   const char *, const char *, const char *, ...));
void script_set_env (struct client_state *, const char *, const char *,
		     const char *);
void script_flush_env(struct client_state *);
int dhcp_option_ev_name (char *, size_t, struct option *);

struct client_lease *packet_to_lease PROTO ((struct packet *));
void go_daemon PROTO ((void));
void write_client_pid_file PROTO ((void));
void status_message PROTO ((struct sysconf_header *, void *));
void client_location_changed PROTO ((void));
d765 4
a768 4
int write_lease PROTO ((struct lease *));
int commit_leases PROTO ((void));
void db_startup PROTO ((void));
void new_lease_file PROTO ((void));
d771 10
a780 63
u_int32_t checksum PROTO ((unsigned char *, unsigned, u_int32_t));
u_int32_t wrapsum PROTO ((u_int32_t));
void assemble_hw_header PROTO ((struct interface_info *, unsigned char *,
				int *, struct hardware *));
void assemble_udp_ip_header PROTO ((struct interface_info *, unsigned char *,
				    int *, u_int32_t, u_int32_t, unsigned int,
				    unsigned char *, int));
ssize_t decode_hw_header PROTO ((struct interface_info *, unsigned char *,
				 int, struct hardware *));
ssize_t decode_udp_ip_header PROTO ((struct interface_info *, unsigned char *,
				     int, struct sockaddr_in *,
				     unsigned char *, int));

/* ethernet.c */
void assemble_ethernet_header PROTO ((struct interface_info *, unsigned char *,
				      int *, struct hardware *));
ssize_t decode_ethernet_header PROTO ((struct interface_info *,
				       unsigned char *,
				       int, struct hardware *));

/* tr.c */
void assemble_tr_header PROTO ((struct interface_info *, unsigned char *,
				int *, struct hardware *));
ssize_t decode_tr_header PROTO ((struct interface_info *,
				 unsigned char *,
				 int, struct hardware *));

/* route.c */
void add_route_direct PROTO ((struct interface_info *, struct in_addr));
void add_route_net PROTO ((struct interface_info *, struct in_addr,
			   struct in_addr));
void add_route_default_gateway PROTO ((struct interface_info *, 
				       struct in_addr));
void remove_routes PROTO ((struct in_addr));
void remove_if_route PROTO ((struct interface_info *, struct in_addr));
void remove_all_if_routes PROTO ((struct interface_info *));
void set_netmask PROTO ((struct interface_info *, struct in_addr));
void set_broadcast_addr PROTO ((struct interface_info *, struct in_addr));
void set_ip_address PROTO ((struct interface_info *, struct in_addr));

/* clparse.c */
int read_client_conf PROTO ((void));
void read_client_leases PROTO ((void));
void parse_client_statement PROTO ((FILE *, struct interface_info *,
				    struct client_config *));
int parse_X PROTO ((FILE *, u_int8_t *, int));
int parse_option_list PROTO ((FILE *, u_int8_t *));
void parse_interface_declaration PROTO ((FILE *, struct client_config *));
struct interface_info *interface_or_dummy PROTO ((char *));
void make_client_state PROTO ((struct interface_info *));
void make_client_config PROTO ((struct interface_info *,
				struct client_config *));
void parse_client_lease_statement PROTO ((FILE *, int));
void parse_client_lease_declaration PROTO ((FILE *, struct client_lease *,
					    struct interface_info **));
struct option *parse_option_decl PROTO ((FILE *, struct option_data *));
void parse_string_list PROTO ((FILE *, struct string_list **, int));
int parse_ip_addr PROTO ((FILE *, struct iaddr *));
void parse_reject_statement PROTO ((FILE *, struct client_config *));

/* dhcrelay.c */
void relay PROTO ((struct interface_info *, struct dhcp_packet *, int,
		   unsigned int, struct iaddr, struct hardware *));
d783 3
a785 27
void icmp_startup PROTO ((int, void (*) PROTO ((struct iaddr,
						u_int8_t *, int))));
int icmp_echorequest PROTO ((struct iaddr *));
void icmp_echoreply PROTO ((struct protocol *));

/* dns.c */
void dns_startup PROTO ((void));
int ns_inaddr_lookup PROTO ((u_int16_t, struct iaddr));
void dns_packet PROTO ((struct protocol *));

/* resolv.c */
extern char path_resolv_conf [];
struct name_server *name_servers;
struct domain_search_list *domains;

void read_resolv_conf PROTO ((time_t));
struct sockaddr_in *pick_name_server PROTO ((void));

/* inet_addr.c */
#ifdef NEED_INET_ATON
int inet_aton PROTO ((const char *, struct in_addr *));
#endif

/* sysconf.c */
void sysconf_startup PROTO ((void (*) (struct sysconf_header *, void *)));
void sysconf_restart PROTO ((void *));
void sysconf_message PROTO ((struct protocol *proto));
@


1.3
log
@dhcpd may know about a thousand strange things to get packets onto the wire,
but we do not care for them, really
@
text
@a99 1
#include "osdep.h"
a867 25

/* dhxpxlt.c */
void convert_statement PROTO ((FILE *));
void convert_host_statement PROTO ((FILE *, jrefproto));
void convert_host_name PROTO ((FILE *, jrefproto));
void convert_class_statement PROTO ((FILE *, jrefproto, int));
void convert_class_decl PROTO ((FILE *, jrefproto));
void convert_lease_time PROTO ((FILE *, jrefproto, char *));
void convert_shared_net_statement PROTO ((FILE *, jrefproto));
void convert_subnet_statement PROTO ((FILE *, jrefproto));
void convert_subnet_decl PROTO ((FILE *, jrefproto));
void convert_host_decl PROTO ((FILE *, jrefproto));
void convert_hardware_decl PROTO ((FILE *, jrefproto));
void convert_hardware_addr PROTO ((FILE *, jrefproto));
void convert_filename_decl PROTO ((FILE *, jrefproto));
void convert_servername_decl PROTO ((FILE *, jrefproto));
void convert_ip_addr_or_hostname PROTO ((FILE *, jrefproto, int));
void convert_fixed_addr_decl PROTO ((FILE *, jrefproto));
void convert_option_decl PROTO ((FILE *, jrefproto));
void convert_timestamp PROTO ((FILE *, jrefproto));
void convert_lease_statement PROTO ((FILE *, jrefproto));
void convert_address_range PROTO ((FILE *, jrefproto));
void convert_date PROTO ((FILE *, jrefproto, char *));
void convert_numeric_aggregate PROTO ((FILE *, jrefproto, int, int, int, int));
void indent PROTO ((int));
@


1.2
log
@time_t and kill a few dumb defines
@
text
@a94 4
#if defined (USE_DEFAULT_NETWORK)
#  define USE_BPF
#endif

a707 39
/* socket.c */
#if defined (USE_SOCKET_SEND) || defined (USE_SOCKET_RECEIVE) \
	|| defined (USE_SOCKET_FALLBACK)
int if_register_socket PROTO ((struct interface_info *));
#endif

#if defined (USE_SOCKET_FALLBACK) && !defined (USE_SOCKET_SEND)
void if_reinitialize_fallback PROTO ((struct interface_info *));
void if_register_fallback PROTO ((struct interface_info *));
ssize_t send_fallback PROTO ((struct interface_info *,
			      struct packet *, struct dhcp_packet *, size_t, 
			      struct in_addr,
			      struct sockaddr_in *, struct hardware *));
#endif

#ifdef USE_SOCKET_SEND
void if_reinitialize_send PROTO ((struct interface_info *));
void if_register_send PROTO ((struct interface_info *));
ssize_t send_packet PROTO ((struct interface_info *,
			    struct packet *, struct dhcp_packet *, size_t, 
			    struct in_addr,
			    struct sockaddr_in *, struct hardware *));
#endif
#if defined (USE_SOCKET_FALLBACK)
void fallback_discard PROTO ((struct protocol *));
#endif
#ifdef USE_SOCKET_RECEIVE
void if_reinitialize_receive PROTO ((struct interface_info *));
void if_register_receive PROTO ((struct interface_info *));
ssize_t receive_packet PROTO ((struct interface_info *,
			       unsigned char *, size_t,
			       struct sockaddr_in *, struct hardware *));
#endif
#if defined (USE_SOCKET_SEND)
int can_unicast_without_arp PROTO ((void));
int can_receive_unicast_unconfigured PROTO ((struct interface_info *));
void maybe_setup_fallback PROTO ((void));
#endif

a708 1
#if defined (USE_BPF_SEND) || defined (USE_BPF_RECEIVE)
a709 53
#endif
#ifdef USE_BPF_SEND
void if_reinitialize_send PROTO ((struct interface_info *));
void if_register_send PROTO ((struct interface_info *));
ssize_t send_packet PROTO ((struct interface_info *,
			    struct packet *, struct dhcp_packet *, size_t,
			    struct in_addr,
			    struct sockaddr_in *, struct hardware *));
#endif
#ifdef USE_BPF_RECEIVE
void if_reinitialize_receive PROTO ((struct interface_info *));
void if_register_receive PROTO ((struct interface_info *));
ssize_t receive_packet PROTO ((struct interface_info *,
			       unsigned char *, size_t,
			       struct sockaddr_in *, struct hardware *));
#endif
#if defined (USE_BPF_SEND)
int can_unicast_without_arp PROTO ((void));
int can_receive_unicast_unconfigured PROTO ((struct interface_info *));
void maybe_setup_fallback PROTO ((void));
#endif

/* lpf.c */
#if defined (USE_LPF_SEND) || defined (USE_LPF_RECEIVE)
int if_register_lpf PROTO ( (struct interface_info *));
#endif
#ifdef USE_LPF_SEND
void if_reinitialize_send PROTO ((struct interface_info *));
void if_register_send PROTO ((struct interface_info *));
ssize_t send_packet PROTO ((struct interface_info *,
			    struct packet *, struct dhcp_packet *, size_t,
			    struct in_addr,
			    struct sockaddr_in *, struct hardware *));
#endif
#ifdef USE_LPF_RECEIVE
void if_reinitialize_receive PROTO ((struct interface_info *));
void if_register_receive PROTO ((struct interface_info *));
ssize_t receive_packet PROTO ((struct interface_info *,
			       unsigned char *, size_t,
			       struct sockaddr_in *, struct hardware *));
#endif
#if defined (USE_LPF_SEND)
int can_unicast_without_arp PROTO ((void));
int can_receive_unicast_unconfigured PROTO ((struct interface_info *));
void maybe_setup_fallback PROTO ((void));
#endif

/* nit.c */
#if defined (USE_NIT_SEND) || defined (USE_NIT_RECEIVE)
int if_register_nit PROTO ( (struct interface_info *));
#endif

#ifdef USE_NIT_SEND
a715 2
#endif
#ifdef USE_NIT_RECEIVE
a720 2
#endif
#if defined (USE_NIT_SEND)
a723 35
#endif

#ifdef USE_DLPI_SEND
void if_reinitialize_send PROTO ((struct interface_info *));
void if_register_send PROTO ((struct interface_info *));
ssize_t send_packet PROTO ((struct interface_info *,
			    struct packet *, struct dhcp_packet *, size_t,
			    struct in_addr,
			    struct sockaddr_in *, struct hardware *));
#endif
#ifdef USE_DLPI_RECEIVE
void if_reinitialize_receive PROTO ((struct interface_info *));
void if_register_receive PROTO ((struct interface_info *));
ssize_t receive_packet PROTO ((struct interface_info *,
			       unsigned char *, size_t,
			       struct sockaddr_in *, struct hardware *));
#endif
#if defined (USE_DLPI_SEND)
int can_unicast_without_arp PROTO ((void));
int can_receive_unicast_unconfigured PROTO ((struct interface_info *));
void maybe_setup_fallback PROTO ((void));
#endif

/* raw.c */
#ifdef USE_RAW_SEND
void if_reinitialize_send PROTO ((struct interface_info *));
void if_register_send PROTO ((struct interface_info *));
ssize_t send_packet PROTO ((struct interface_info *,
			    struct packet *, struct dhcp_packet *, size_t,
			    struct in_addr,
			    struct sockaddr_in *, struct hardware *));
int can_unicast_without_arp PROTO ((void));
int can_receive_unicast_unconfigured PROTO ((struct interface_info *));
void maybe_setup_fallback PROTO ((void));
#endif
@


1.1
log
@may the whacking begin
@
text
@a79 1
/* Varargs stuff... */
a80 3
#define VA_DOTDOTDOT ...
#define va_dcl
#define VA_start(list, last) va_start (list, last)
a87 9
#ifndef _PATH_DHCLIENT_PID
#define _PATH_DHCLIENT_PID "/var/run/dhclient.pid"
#endif
#ifndef _PATH_DHCLIENT_DB
#define _PATH_DHCLIENT_DB "/var/db/dhclient.leases"
#endif

#define EOL	'\n'
#define VOIDPTR void *
a90 2
#define TIME time_t
#define GET_TIME(x)	time ((x))
d127 1
a127 1
	TIME rcdate;
d134 1
a134 1
	TIME rcdate;
d169 1
a169 1
	TIME starts, ends, timestamp;
d199 1
a199 1
	TIME offered_expiry;
d249 4
a252 4
	TIME default_lease_time;
	TIME max_lease_time;
	TIME bootp_lease_cutoff;
	TIME bootp_lease_length;
d314 1
a314 1
	TIME expiry, renewal, rebind;			  /* Lease timeouts. */
d352 1
a352 1
	TIME timeout;			/* Start to panic if we don't get a
d355 1
a355 1
	TIME initial_interval;		/* All exponential backoff intervals
d357 1
a357 1
	TIME retry_interval;		/* If the protocol failed to produce
d361 1
a361 1
	TIME select_interval;		/* Wait this many seconds from the
d364 1
a364 1
	TIME reboot_timeout;		/* When in INIT-REBOOT, wait this
d367 1
a367 1
	TIME backoff_cutoff;		/* When doing exponential backoff,
d392 2
a393 2
	TIME first_sending;			/* When was first copy sent? */
	TIME interval;		      /* What's the current resend interval? */
d448 1
a448 1
	TIME when;
d547 1
a547 1
extern TIME cur_time;
d587 1
a587 1
void parse_lease_time PROTO ((FILE *, TIME *));
d596 1
a596 1
TIME parse_timestamp PROTO ((FILE *));
d599 1
a599 1
TIME parse_date PROTO ((FILE *));
d625 1
a625 1
void ack_lease PROTO ((struct packet *, struct lease *, unsigned int, TIME));
d669 2
a670 2
VOIDPTR dmalloc PROTO ((int, char *));
void dfree PROTO ((VOIDPTR, char *));
d877 1
a877 1
void add_timeout PROTO ((TIME, void (*) PROTO ((void *)), void *));
d1084 1
a1084 1
void read_resolv_conf PROTO ((TIME));
@

