head	1.95;
access;
symbols
	OPENBSD_4_7:1.93.0.2
	OPENBSD_4_7_BASE:1.93
	OPENBSD_4_6:1.73.0.4
	OPENBSD_4_6_BASE:1.73
	OPENBSD_4_5:1.71.0.2
	OPENBSD_4_5_BASE:1.71
	OPENBSD_4_4:1.68.0.2
	OPENBSD_4_4_BASE:1.68
	OPENBSD_4_3:1.65.0.2
	OPENBSD_4_3_BASE:1.65
	OPENBSD_4_2:1.63.0.2
	OPENBSD_4_2_BASE:1.63
	OPENBSD_4_1:1.41.0.2
	OPENBSD_4_1_BASE:1.41
	OPENBSD_4_0:1.39.0.4
	OPENBSD_4_0_BASE:1.39
	OPENBSD_3_9:1.39.0.2
	OPENBSD_3_9_BASE:1.39
	OPENBSD_3_8:1.30.0.2
	OPENBSD_3_8_BASE:1.30
	OPENBSD_3_7:1.28.0.2
	OPENBSD_3_7_BASE:1.28
	OPENBSD_3_6:1.9.0.2
	OPENBSD_3_6_BASE:1.9
	OPENBSD_3_5:1.3.0.2
	OPENBSD_3_5_BASE:1.3
	pkgtools:1.1.1.1
	espie:1.1.1;
locks; strict;
comment	@# @;


1.95
date	2010.06.04.13.19.39;	author espie;	state dead;
branches;
next	1.94;

1.94
date	2010.05.10.09.17.55;	author espie;	state Exp;
branches;
next	1.93;

1.93
date	2010.01.11.10.16.20;	author jmc;	state Exp;
branches;
next	1.92;

1.92
date	2010.01.10.21.27.59;	author espie;	state Exp;
branches;
next	1.91;

1.91
date	2010.01.10.11.59.57;	author espie;	state Exp;
branches;
next	1.90;

1.90
date	2010.01.09.15.10.17;	author espie;	state Exp;
branches;
next	1.89;

1.89
date	2010.01.09.14.55.53;	author espie;	state Exp;
branches;
next	1.88;

1.88
date	2010.01.09.12.01.57;	author espie;	state Exp;
branches;
next	1.87;

1.87
date	2010.01.09.11.26.58;	author espie;	state Exp;
branches;
next	1.86;

1.86
date	2010.01.09.10.45.32;	author espie;	state Exp;
branches;
next	1.85;

1.85
date	2010.01.08.17.06.00;	author espie;	state Exp;
branches;
next	1.84;

1.84
date	2010.01.05.12.20.47;	author espie;	state Exp;
branches;
next	1.83;

1.83
date	2010.01.02.12.52.18;	author espie;	state Exp;
branches;
next	1.82;

1.82
date	2010.01.01.16.09.35;	author espie;	state Exp;
branches;
next	1.81;

1.81
date	2009.11.10.11.36.56;	author espie;	state Exp;
branches;
next	1.80;

1.80
date	2009.11.10.10.52.44;	author espie;	state Exp;
branches;
next	1.79;

1.79
date	2009.11.10.10.50.34;	author espie;	state Exp;
branches;
next	1.78;

1.78
date	2009.10.15.10.47.07;	author phessler;	state Exp;
branches;
next	1.77;

1.77
date	2009.10.11.20.09.48;	author jmc;	state Exp;
branches;
next	1.76;

1.76
date	2009.10.11.18.41.21;	author espie;	state Exp;
branches;
next	1.75;

1.75
date	2009.10.11.18.15.08;	author espie;	state Exp;
branches;
next	1.74;

1.74
date	2009.09.07.20.39.55;	author landry;	state Exp;
branches;
next	1.73;

1.73
date	2009.04.19.14.58.32;	author espie;	state Exp;
branches;
next	1.72;

1.72
date	2009.04.14.17.53.58;	author espie;	state Exp;
branches;
next	1.71;

1.71
date	2008.12.15.15.56.40;	author espie;	state Exp;
branches;
next	1.70;

1.70
date	2008.10.26.16.16.37;	author espie;	state Exp;
branches;
next	1.69;

1.69
date	2008.10.20.10.25.16;	author espie;	state Exp;
branches;
next	1.68;

1.68
date	2008.06.18.12.05.00;	author espie;	state Exp;
branches;
next	1.67;

1.67
date	2008.06.15.08.24.28;	author espie;	state Exp;
branches;
next	1.66;

1.66
date	2008.03.08.12.07.45;	author espie;	state Exp;
branches;
next	1.65;

1.65
date	2007.12.18.10.58.46;	author espie;	state Exp;
branches;
next	1.64;

1.64
date	2007.12.08.15.54.45;	author espie;	state Exp;
branches;
next	1.63;

1.63
date	2007.06.26.19.11.28;	author espie;	state Exp;
branches;
next	1.62;

1.62
date	2007.06.20.13.44.39;	author espie;	state Exp;
branches;
next	1.61;

1.61
date	2007.06.17.12.34.02;	author espie;	state Exp;
branches;
next	1.60;

1.60
date	2007.06.04.18.15.19;	author jmc;	state Exp;
branches;
next	1.59;

1.59
date	2007.06.04.14.40.39;	author espie;	state Exp;
branches;
next	1.58;

1.58
date	2007.06.04.11.42.03;	author pyr;	state Exp;
branches;
next	1.57;

1.57
date	2007.05.18.12.44.32;	author espie;	state Exp;
branches;
next	1.56;

1.56
date	2007.05.18.12.28.26;	author espie;	state Exp;
branches;
next	1.55;

1.55
date	2007.05.15.19.02.26;	author espie;	state Exp;
branches;
next	1.54;

1.54
date	2007.05.14.11.02.14;	author espie;	state Exp;
branches;
next	1.53;

1.53
date	2007.05.14.10.53.31;	author espie;	state Exp;
branches;
next	1.52;

1.52
date	2007.05.14.10.43.45;	author espie;	state Exp;
branches;
next	1.51;

1.51
date	2007.05.14.10.27.46;	author espie;	state Exp;
branches;
next	1.50;

1.50
date	2007.05.13.13.32.36;	author espie;	state Exp;
branches;
next	1.49;

1.49
date	2007.05.12.14.48.45;	author espie;	state Exp;
branches;
next	1.48;

1.48
date	2007.05.07.14.29.58;	author espie;	state Exp;
branches;
next	1.47;

1.47
date	2007.05.07.14.12.43;	author espie;	state Exp;
branches;
next	1.46;

1.46
date	2007.05.07.14.06.38;	author espie;	state Exp;
branches;
next	1.45;

1.45
date	2007.05.02.13.59.19;	author espie;	state Exp;
branches;
next	1.44;

1.44
date	2007.05.01.18.22.20;	author espie;	state Exp;
branches;
next	1.43;

1.43
date	2007.04.29.11.09.29;	author espie;	state Exp;
branches;
next	1.42;

1.42
date	2007.04.15.10.17.29;	author espie;	state Exp;
branches;
next	1.41;

1.41
date	2007.01.29.10.57.36;	author bernd;	state Exp;
branches;
next	1.40;

1.40
date	2007.01.23.11.40.26;	author bernd;	state Exp;
branches;
next	1.39;

1.39
date	2006.02.23.12.28.22;	author bernd;	state Exp;
branches;
next	1.38;

1.38
date	2006.02.09.09.40.31;	author espie;	state Exp;
branches;
next	1.37;

1.37
date	2005.11.01.17.02.29;	author bernd;	state Exp;
branches;
next	1.36;

1.36
date	2005.10.28.20.16.13;	author espie;	state Exp;
branches;
next	1.35;

1.35
date	2005.09.19.10.16.32;	author espie;	state Exp;
branches;
next	1.34;

1.34
date	2005.09.19.09.51.49;	author espie;	state Exp;
branches;
next	1.33;

1.33
date	2005.09.17.12.10.52;	author espie;	state Exp;
branches;
next	1.32;

1.32
date	2005.09.07.09.40.50;	author jmc;	state Exp;
branches;
next	1.31;

1.31
date	2005.09.04.22.47.56;	author espie;	state Exp;
branches;
next	1.30;

1.30
date	2005.08.16.08.59.38;	author espie;	state Exp;
branches;
next	1.29;

1.29
date	2005.06.08.09.43.40;	author espie;	state Exp;
branches;
next	1.28;

1.28
date	2005.01.16.11.16.23;	author espie;	state Exp;
branches;
next	1.27;

1.27
date	2005.01.14.02.25.12;	author espie;	state Exp;
branches;
next	1.26;

1.26
date	2004.12.22.12.56.25;	author espie;	state Exp;
branches;
next	1.25;

1.25
date	2004.12.16.11.07.33;	author espie;	state Exp;
branches;
next	1.24;

1.24
date	2004.12.12.11.26.16;	author espie;	state Exp;
branches;
next	1.23;

1.23
date	2004.12.06.15.19.11;	author espie;	state Exp;
branches;
next	1.22;

1.22
date	2004.12.06.12.35.36;	author espie;	state Exp;
branches;
next	1.21;

1.21
date	2004.11.15.12.58.48;	author espie;	state Exp;
branches;
next	1.20;

1.20
date	2004.11.15.12.22.59;	author espie;	state Exp;
branches;
next	1.19;

1.19
date	2004.11.15.11.23.10;	author espie;	state Exp;
branches;
next	1.18;

1.18
date	2004.11.14.13.05.02;	author espie;	state Exp;
branches;
next	1.17;

1.17
date	2004.11.11.11.54.09;	author espie;	state Exp;
branches;
next	1.16;

1.16
date	2004.11.11.11.24.15;	author espie;	state Exp;
branches;
next	1.15;

1.15
date	2004.11.11.11.16.39;	author espie;	state Exp;
branches;
next	1.14;

1.14
date	2004.11.10.09.55.43;	author espie;	state Exp;
branches;
next	1.13;

1.13
date	2004.11.10.09.41.16;	author espie;	state Exp;
branches;
next	1.12;

1.12
date	2004.11.09.11.16.53;	author espie;	state Exp;
branches;
next	1.11;

1.11
date	2004.11.09.10.46.57;	author espie;	state Exp;
branches;
next	1.10;

1.10
date	2004.10.11.10.30.33;	author espie;	state Exp;
branches;
next	1.9;

1.9
date	2004.08.12.10.35.06;	author espie;	state Exp;
branches;
next	1.8;

1.8
date	2004.08.06.08.17.40;	author espie;	state Exp;
branches;
next	1.7;

1.7
date	2004.08.06.08.14.52;	author espie;	state Exp;
branches;
next	1.6;

1.6
date	2004.08.06.08.06.01;	author espie;	state Exp;
branches;
next	1.5;

1.5
date	2004.08.06.07.51.17;	author espie;	state Exp;
branches;
next	1.4;

1.4
date	2004.06.21.16.33.45;	author espie;	state Exp;
branches;
next	1.3;

1.3
date	2003.10.23.17.48.07;	author espie;	state Exp;
branches;
next	1.2;

1.2
date	2003.10.19.18.40.11;	author espie;	state Exp;
branches;
next	1.1;

1.1
date	2003.10.16.17.43.34;	author espie;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2003.10.16.17.43.34;	author espie;	state Exp;
branches;
next	;


desc
@@


1.95
log
@move code around, so that commands can be used as modules.
pkg becomes the start hub, which does nothing except require the
correct module.
Saner code wrt Add/Delete, and more sharing.
@
text
@#! /usr/bin/perl
# ex:ts=8 sw=4:
# $OpenBSD: pkg_info,v 1.94 2010/05/10 09:17:55 espie Exp $
#
# Copyright (c) 2003-2010 Marc Espie <espie@@openbsd.org>
#
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

use strict;
use warnings;

use OpenBSD::PackageInfo;
use OpenBSD::PackageName;
use OpenBSD::Getopt;
use OpenBSD::Error;

package OpenBSD::PackingElement;
sub dump_file
{
}

sub hunt_file
{
}

sub sum_up
{
	my ($self, $rsize) = @@_;
	if (defined $self->{size}) {
		$$rsize += $self->{size};
	}
}

package OpenBSD::PackingElement::FileBase;
sub dump_file
{
	my ($item, $opt_K) = @@_;
	if ($opt_K) {
		print '@@', $item->keyword, " ";
	}
	print $item->fullname, "\n";
}

package OpenBSD::PackingElement::FileObject;
sub hunt_file
{
	my ($item, $h, $pkgname, $l) = @@_;
	my $fname = $item->fullname;
	if (defined $h->{$fname}) {
		push(@@{$h->{$fname}}, $pkgname);
		push(@@$l, $pkgname);
	}
}

package main;

my $total_size = 0;
my $pkgs = 0;

sub find_pkg_in
{
	my ($repo, $pkgname, $code) = @@_;

	if (OpenBSD::PackageName::is_stem($pkgname)) {
		require OpenBSD::Search;
		my $l = $repo->match_locations(OpenBSD::Search::Stem->new($pkgname));
		if (@@$l != 0) {
			for my $pkg (sort {$a->name cmp $b->name} @@$l) {
				&$code($pkg->name, $pkg);
				$pkg->close_now;
				$pkg->wipe_info;
			}
			return 1;
		}
	}
	# okay, so we're actually a spec in disguise
	if ($pkgname =~ m/[\*\<\>\=]/) {
		require OpenBSD::Search;
		my $s = OpenBSD::Search::PkgSpec->new($pkgname);
		if (!$s->is_valid) {
			print STDERR "Invalid spec: $pkgname\n";
			return 0;
		}
		my $r = $repo->match_locations($s);
		if (@@$r == 0) {
			return 0;
		} else {
			for my $pkg (@@$r) {
				&$code($pkgname, $pkg);
				$pkg->close_now;
				$pkg->wipe_info;
			}
			return 1;
		}
	} else {
		my $pkg = $repo->find($pkgname);
		if (defined $pkg) {
			&$code($pkgname, $pkg);
			$pkg->close_now;
			$pkg->wipe_info;
			return 1;
		}
		return 0;
	}
}

sub find_pkg
{
	my ($pkgname, $code) = @@_;
	require OpenBSD::PackageRepository::Installed;

	if (find_pkg_in(OpenBSD::PackageRepository::Installed->new, $pkgname,
	    $code)) {
		return;
	}
	require OpenBSD::PackageLocator;

	my $repo;

	if ($pkgname =~ m/[\/\:]/o) {
		($repo, $pkgname) =
		    OpenBSD::PackageLocator->path_parse($pkgname);
	} else {
		$repo = 'OpenBSD::PackageLocator';
	}

	find_pkg_in($repo, $pkgname, $code);
}

sub printfile
{
	my $filename = shift;
	my $_;

	open my $fh, '<', $filename or return;
	while(<$fh>) {
		print;
	}
	close $fh;
}

sub print_description
{
	my $dir = shift;
	my $_;

	open my $fh, '<', $dir.DESC or return;
	$_ = <$fh> unless -f $dir.COMMENT;
	while(<$fh>) {
		print;
	}
	close $fh;
}

sub get_line
{
	open my $fh, '<', shift or return "";
	my $c = <$fh>;
	chomp($c);
	close $fh;
	return $c;
}

sub get_comment
{
	my $d = shift;
	return get_line(-f $d.COMMENT? $d.COMMENT : $d.DESC);
}

sub find_by_spec
{
	my $pat = shift;

	require OpenBSD::Search;
	require OpenBSD::PackageRepository::Installed;

	my $s = OpenBSD::Search::PkgSpec->new($pat);
	if (!$s->is_valid) {
		print STDERR "Invalid spec: $pat\n";
		return ();
	} else {
		my $r = OpenBSD::PackageRepository::Installed->new->match_locations($s);

		return sort (map {$_->name} @@$r);
	}
}

sub filter_files
{
	require OpenBSD::PackingList;

	my $search = shift;
	my @@result = ();
	for my $arg (@@_) {
		find_pkg($arg,
		    sub {
		    	my ($pkgname, $handle) = @@_;

			my $plist = $handle->plist(\&OpenBSD::PackingList::FilesOnly);

			$plist->hunt_file($search, $pkgname, \@@result);
		    });
	}
	return @@result;
}

sub manual_filter
{
	require OpenBSD::PackingList;

	my @@result = ();
	for my $arg (@@_) {
		find_pkg($arg,
		    sub {
		    	my ($pkgname, $handle) = @@_;

			my $plist = $handle->plist(\&OpenBSD::PackingList::ConflictOnly);

			push(@@result, $pkgname) if $plist->has('manual-installation');
		    });
	}
	return @@result;
}

my $path_info;

sub add_to_path_info
{
	my ($path, $pkgname) = @@_;

	$path_info->{$path} = [] unless
	    defined $path_info->{$path};
	push(@@{$path_info->{$path}}, $pkgname);
}

sub find_by_path
{
	my $pat = shift;

	if (!defined $path_info) {
		require OpenBSD::PackingList;

		$path_info = {};
		for my $pkg (installed_packages(1)) {
			my $plist =
				OpenBSD::PackingList->from_installation($pkg,
				    \&OpenBSD::PackingList::ExtraInfoOnly);
			next if !defined $plist;
			if (defined $plist->fullpkgpath) {
				add_to_path_info($plist->fullpkgpath,
				    $plist->pkgname);
			}
			if ($plist->has('pkgpath')) {
				for my $p (@@{$plist->{pkgpath}}) {
					add_to_path_info($p->name,
					    $plist->pkgname);
				}
			}
		}
	}
	if (defined $path_info->{$pat}) {
		return @@{$path_info->{$pat}};
	} else {
		return ();
	}
}

our ($opt_c, $opt_C, $opt_d, $opt_f, $opt_I, $opt_K,
    $opt_L, $opt_Q, $opt_q, $opt_R, $opt_s, $opt_v, $opt_h,
    $opt_l, $opt_a, $opt_m, $opt_M, $opt_U, $opt_A, $opt_S, $opt_P, $opt_t);
my $terse = 0;
my $exit_code = 0;
my $error_e = 0;
my @@sought_files;

sub just_in_time_header
{
	my ($pkg, $handle, $rdone) = @@_;
	return if $$rdone == 1;
	if (!$terse && !$opt_q) {
		print $opt_l, "Information for ", $handle->url, "\n\n";
	}
	$$rdone = 1;
}

sub print_info
{
	my ($pkg, $handle) = @@_;
	unless (defined $handle) {
		print STDERR "Error printing info for $pkg: no info ?\n";
	}
	if ($opt_I) {
		my $l = 20 - length($pkg);
		$l = 1 if $l <= 0;
		print $pkg;
		print " "x$l, get_comment($handle->info) unless $opt_q;
		print "\n";
	} else {
		my $done = 0;
		if ($opt_c) {
			just_in_time_header($pkg, $handle ,\$done);
			print $opt_l, "Comment:\n" unless $opt_q;
			print get_comment($handle->info), "\n";
			print "\n";
		}
		if ($opt_R && -f $handle->info.REQUIRED_BY) {
			just_in_time_header($pkg, $handle ,\$done);
			print $opt_l, "Required by:\n" unless $opt_q;
			printfile($handle->info.REQUIRED_BY);
			print "\n";
		}
		if ($opt_d) {
			just_in_time_header($pkg, $handle ,\$done);
			print $opt_l, "Description:\n" unless $opt_q;
			print_description($handle->info);
			print "\n";
		}
		if ($opt_M && -f $handle->info.DISPLAY) {
			just_in_time_header($pkg, $handle ,\$done);
			print $opt_l, "Install notice:\n" unless $opt_q;
			printfile($handle->info.DISPLAY);
			print "\n";
		}
		if ($opt_U && -f $handle->info.UNDISPLAY) {
			just_in_time_header($pkg, $handle ,\$done);
			print $opt_l, "Deinstall notice:\n" unless $opt_q;
			printfile($handle->info.UNDISPLAY);
			print "\n";
		}
		my $plist;
		if ($opt_f || $opt_L || $opt_s || $opt_S || $opt_C) {
			require OpenBSD::PackingList;

			if ($opt_f || $opt_s || $opt_S || $opt_C) {
				$plist = $handle->plist;
			} else {
				$plist = $handle->plist(\&OpenBSD::PackingList::FilesOnly);
			}
			Fatal "Bad packing list for", $handle->url
			    unless defined $plist;
		}
		if ($opt_L) {
			just_in_time_header($pkg, $handle ,\$done);
			print $opt_l, "Files:\n" unless $opt_q;
			$plist->dump_file($opt_K);
			print "\n";
		}
		if ($opt_C) {
			just_in_time_header($pkg, $handle ,\$done);
			if ($plist->is_signed) {

				require OpenBSD::x509;
				print $opt_l, "Certificate info:\n" unless $opt_q;
				OpenBSD::x509::print_certificate_info($plist);
			} else {
				print $opt_l, "No digital signature\n" unless $opt_q;
			}
		}
		if ($opt_s) {
			just_in_time_header($pkg, $handle ,\$done);
			my $size = 0;
			$plist->sum_up(\$size);
			print "Size: " unless $opt_q;
			print "$size\n";
			$total_size += $size;
			$pkgs++;
		}
		if ($opt_S) {
			just_in_time_header($pkg, $handle ,\$done);
			print "Signature: " unless $opt_q;
			print $plist->signature->string, "\n";
		}
		if ($opt_P) {
			require OpenBSD::PackingList;

			my $plist = $handle->plist(
			    \&OpenBSD::PackingList::ExtraInfoOnly);
			just_in_time_header($pkg, $handle ,\$done);
			print "Pkgpath:\n" unless $opt_q;
			if (defined $plist->fullpkgpath) {
				print $plist->fullpkgpath;
			} else {
				print STDERR $plist->pkgname,
				    " has no FULLPKGPATH\n";
			}
			print "\n";
		}

		if ($opt_f) {
			just_in_time_header($pkg, $handle ,\$done);
			print $opt_l, "Packing list:\n" unless $opt_q;
			$plist->write(\*STDOUT);
			print "\n";
		}
		return unless $done;
		print $opt_l, "\n" unless $opt_q || $terse;
	}
}

set_usage('pkg_info [-AaCcdfIKLMmPqRSstUv] [-E filename] [-e pkg-name] [-l str] [-Q query] [pkg-name] [...]');

my %defines;
my $locked;
try {
	getopts('cCdfF:hIKLmPQ:qRsSUve:E:Ml:aAt',
	    {'e' =>
		    sub {
			    my $pat = shift;
			    my @@list;
			    lock_db(1, $opt_q) unless $defines{nolock};
			    $locked = 1;
			    if ($pat =~ m/\//o) {
				    @@list = find_by_path($pat);
			    } else {
				    @@list = find_by_spec($pat);
			    }
			    if (@@list == 0) {
				    $exit_code = 1;
				    $error_e = 1;
			    }
			    push(@@ARGV, @@list);
			    $terse = 1;
		    },
	     'F' => sub {
			    for my $o (split /\,/o, shift) {
				    $defines{$o} = 1;
			    }
		    },
	     'h' => sub {	Usage(); },
	     'E' =>
		    sub {
			    require File::Spec;

			    push(@@sought_files, File::Spec->rel2abs(shift));

		    }
	});
} catchall {
	Usage($_);
};

lock_db(1, $opt_q) unless $locked or $defines{nolock};

unless ($opt_c || $opt_M || $opt_U || $opt_d || $opt_f || $opt_I ||
	$opt_L || $opt_R || $opt_s ||
	$opt_S || $opt_P || $terse) {
	if (@@ARGV == 0) {
		$opt_I = $opt_a = 1;
	} else {
		$opt_c = $opt_d = $opt_M = $opt_R = 1;
	}
}

if ($opt_Q) {
	require OpenBSD::PackageLocator;
	require OpenBSD::Search;

	print "PKG_PATH=$ENV{PKG_PATH}\n" if $opt_v;
	my $partial = OpenBSD::Search::PartialStem->new($opt_Q);

	my $r = OpenBSD::PackageLocator->match_locations($partial);

	for my $p (sort map {$_->name} @@$r) {
		print $p, is_installed($p) ? " (installed)" : "" , "\n";
	}

	exit 0;
}

if ($opt_v) {
	$opt_c = $opt_d = $opt_f = $opt_M =
	    $opt_U = $opt_R = $opt_s = $opt_S = 1;
}

if (!defined $opt_l) {
	$opt_l = "";
}

if ($opt_K && !$opt_L) {
	Usage "-K only makes sense with -L";
}

if (@@ARGV == 0 && !$opt_a && !$opt_A) {
	Usage "Missing package name(s)" unless $terse || $opt_q;
}

if (@@ARGV > 0 && ($opt_a || $opt_A)) {
	Usage "Can't specify package name(s) with -a";
}

if (@@ARGV > 0 && $opt_t) {
	Usage "Can't specify package name(s) with -t";
}

if (@@ARGV > 0 && $opt_m) {
	Usage "Can't specify package name(s) with -m";
}

if (@@ARGV == 0 && !$error_e) {
	@@ARGV = sort(installed_packages(defined $opt_A ? 0 : 1));
	if ($opt_t) {
		require OpenBSD::RequiredBy;
		@@ARGV = grep { OpenBSD::RequiredBy->new($_)->list == 0 } @@ARGV;
	}
}

if (@@sought_files) {
	my %hash = map { ($_, []) }  @@sought_files;
	@@ARGV = filter_files(\%hash, @@ARGV);
	for my $f (@@sought_files) {
		my $l = $hash{$f};
		if (@@$l) {
			print "$f: ", join(',', @@$l), "\n" unless $opt_q;
		} else {
			$exit_code = 1;
		}
	}
}

if ($opt_m) {
	@@ARGV = manual_filter(@@ARGV);
}

for my $pkg (@@ARGV) {
	if ($terse && !$opt_q) {
		print $opt_l, $pkg, "\n";
	}
	find_pkg($pkg, \&print_info);
}
if ($pkgs > 1) {
	print "Total size: $total_size\n";
}
exit($exit_code);
@


1.94
log
@whitespace fixes
@
text
@d3 1
a3 1
# $OpenBSD$
@


1.93
log
@various cleanup, including a fix from Daniel Dickman;
ok espie
@
text
@d3 1
a3 1
# $OpenBSD: pkg_info,v 1.92 2010/01/10 21:27:59 espie Exp $
d122 1
a122 1
	if (find_pkg_in(OpenBSD::PackageRepository::Installed->new, $pkgname, 
d131 1
a131 1
		($repo, $pkgname) = 
d205 1
a205 1
		find_pkg($arg, 
d210 1
a210 1
				
d223 1
a223 1
		find_pkg($arg, 
d228 1
a228 1
				
d241 1
a241 1
	$path_info->{$path} = [] unless 
d265 1
a265 1
					add_to_path_info($p->name, 
d278 1
a278 1
our ($opt_c, $opt_C, $opt_d, $opt_f, $opt_I, $opt_K, 
d349 1
a349 1
			Fatal "Bad packing list for", $handle->url 
d393 1
a393 1
				print STDERR $plist->pkgname, 
d414 1
a414 1
try { 
d434 2
a435 2
	     'F' => sub { 
			    for my $o (split /\,/o, shift) { 
d447 1
a447 1
	}); 
d454 2
a455 2
unless ($opt_c || $opt_M || $opt_U || $opt_d || $opt_f || $opt_I || 
	$opt_L || $opt_R || $opt_s || 
@


1.92
log
@unify options a bit: use -Dname=value for defines uniformously (e.g., deprecate
-F keyword heavily).
@
text
@d3 1
a3 1
# $OpenBSD$
d410 1
a410 1
set_usage('pkg_info [-AacCdfIKLMmPqRSstUv] [-F opt] [-E filename] [-e pkg-name] [-l str] [-Q query] [pkg-name] [...]');
@


1.91
log
@trick: I can actually recognize specs easily, so why not allow them without
-e ?
@
text
@d278 1
a278 1
our ($opt_c, $opt_C, $opt_D, $opt_d, $opt_f, $opt_I, $opt_K, 
d410 1
a410 1
set_usage('pkg_info [-AacCDdfIKLMmPqRSstUv] [-F opt] [-E filename] [-e pkg-name] [-l str] [-Q query] [pkg-name] [...]');
d415 1
a415 1
	getopts('cCDdfF:hIKLmPQ:qRsSUve:E:Ml:aAt',
a452 4

if ($opt_D) {
	$opt_M = 1;
}
@


1.90
log
@zap unused
@
text
@d86 28
a113 6
	my $pkg = $repo->find($pkgname);
	if (defined $pkg) {
		&$code($pkgname, $pkg);
		$pkg->close_now;
		$pkg->wipe_info;
		return 1;
a114 1
	return 0;
@


1.89
log
@streamline interface
@
text
@d107 1
a107 1
	my ($repo, $path);
d110 1
a110 1
		($repo, $path, $pkgname) = 
@


1.88
log
@fixed version, somehow I forgot that I use parse to do weird things with
PKG_PATH...
@
text
@d111 1
a111 1
		    OpenBSD::PackageLocator::path_parse($pkgname);
@


1.87
log
@temporary revert until I figure this out
@
text
@d109 1
a109 1
	if ($pkgname =~ m/\//o) {
@


1.86
log
@tweak path parsing to handle inst:pkgname and such as well...
@
text
@d109 1
a109 1
	if ($pkgname =~ m/[\/\:]/o) {
@


1.85
log
@remove very old -ikr
@
text
@d109 1
a109 1
	if ($pkgname =~ m/\//o) {
@


1.84
log
@better spec handling: instead of dying, create badspec objects that never
match anything. Add method is_valid (and propagators) to know whether a
spec is valid (to be used in pkg_create in a systematic way).
@
text
@d257 2
a258 2
our ($opt_c, $opt_C, $opt_D, $opt_d, $opt_f, $opt_I, $opt_i, $opt_k, $opt_K, 
    $opt_L, $opt_Q, $opt_q, $opt_R, $opt_r, $opt_s, $opt_v, $opt_h,
a318 18
		if ($opt_i && -f $handle->info.INSTALL) {
			just_in_time_header($pkg, $handle ,\$done);
			print $opt_l, "Install script:\n" unless $opt_q;
			printfile($handle->info.INSTALL);
			print "\n";
		}
		if ($opt_k && -f $handle->info.DEINSTALL) {
			just_in_time_header($pkg, $handle ,\$done);
			print $opt_l, "De-Install script:\n" unless $opt_q;
			printfile($handle->info.DEINSTALL, \*STDOUT);
			print "\n";
		}
		if ($opt_r && -f $handle->info.REQUIRING) {
			just_in_time_header($pkg, $handle ,\$done);
			print $opt_l, "Require script:\n" unless $opt_q;
			printfile($handle->info.REQUIRING, \*STDOUT);
			print "\n";
		}
d389 1
a389 1
set_usage('pkg_info [-AacCDdfIiKkLMmPqRrSstUv] [-F opt] [-E filename] [-e pkg-name] [-l str] [-Q query] [pkg-name] [...]');
d394 1
a394 1
	getopts('cCDdfF:hIikKLmPQ:qRrsSUve:E:Ml:aAt',
d437 2
a438 2
unless ($opt_c || $opt_M || $opt_U || $opt_d || $opt_f || $opt_I || $opt_i ||
	$opt_k || $opt_L || $opt_R || $opt_r || $opt_s || 
d464 1
a464 1
	$opt_c = $opt_d = $opt_f = $opt_i = $opt_k = $opt_r = $opt_M =
@


1.83
log
@first step in comparing full signatures: make them full objects, with
proper sign/compare interfaces.
@
text
@d166 6
a171 1
	my $r = OpenBSD::PackageRepository::Installed->new->match_locations(OpenBSD::Search::PkgSpec->new($pat));
d173 2
a174 1
	return sort (map {$_->name} @@$r);
@


1.82
log
@new method fullpkgpath that accesses the default fullpkgpath.
make use of it, relax pkg_create to allow any of
FULLPKGPATH, PERMIT_PACKAGE_FTP, PERMIT_PACKAGE_CDROM
(store the others as empty).
remove warning in pkg_mklocatedb for newer perl.
@
text
@d372 1
a372 1
			print $plist->signature, "\n";
@


1.81
log
@bad espie: use strict/warnings consistently, and fix two nits and two
actual errors !
@
text
@d5 1
a5 1
# Copyright (c) 2003-2009 Marc Espie <espie@@openbsd.org>
d232 4
a235 2
			add_to_path_info($plist->{extrainfo}->{subdir}, 
			    $plist->pkgname);
d381 7
a387 1
			print $plist->{extrainfo}->{subdir}, "\n";
@


1.80
log
@zap match
@
text
@d21 1
@


1.79
log
@kill one use of old-style match
@
text
@d457 3
a459 1
	for my $p (sort OpenBSD::PackageLocator->match($partial)) {
@


1.78
log
@fix typo that prevented `pkg_info -r` from working.

OK espie@@
@
text
@d3 1
a3 1
# $OpenBSD: pkg_info,v 1.77 2009/10/11 20:09:48 jmc Exp $
d165 3
a167 1
	return sort(OpenBSD::PackageRepository::Installed->new->match(OpenBSD::Search::PkgSpec->new($pat)));
@


1.77
log
@-M before -m
new sentence, new line
@
text
@d3 1
a3 1
# $OpenBSD: pkg_info,v 1.76 2009/10/11 18:41:21 espie Exp $
d320 1
a320 1
		if ($opt_r && -f $handle->info.REQUIRE) {
d323 1
a323 1
			printfile($handle->info.REQUIRE, \*STDOUT);
@


1.76
log
@option -m will show only packages tagged as manual installations.
(there are still some kinks in the setting of @@option manual-install, so
it's not as accurate as it should be).
@
text
@d3 1
a3 1
# $OpenBSD$
d390 1
a390 1
set_usage('pkg_info [-AacCDdfIiKkLmMPqRrSstUv] [-F opt] [-E filename] [-e pkg-name] [-l str] [-Q query] [pkg-name] [...]');
@


1.75
log
@opt_m ? what's that ?
@
text
@d187 18
d248 1
a248 1
    $opt_l, $opt_a, $opt_M, $opt_U, $opt_A, $opt_S, $opt_P, $opt_t);
d390 1
a390 1
set_usage('pkg_info [-AacCDdfIiKkLMPqRrSstUv] [-F opt] [-E filename] [-e pkg-name] [-l str] [-Q query] [pkg-name] [...]');
d487 4
d510 4
@


1.74
log
@Don't print package comment when -q is given, and no other option is
used. This way, pkg_info -q only shows installed pkgnames.. and can
replace `ls /var/db/pkg` in scripts.

ok espie@@
@
text
@d3 1
a3 1
# $OpenBSD: pkg_info,v 1.73 2009/04/19 14:58:32 espie Exp $
d5 1
a5 1
# Copyright (c) 2003-2007 Marc Espie <espie@@openbsd.org>
d229 1
a229 1
    $opt_L, $opt_m, $opt_Q, $opt_q, $opt_R, $opt_r, $opt_s, $opt_v, $opt_h,
d421 1
a421 1
	$opt_k || $opt_L || $opt_m || $opt_R || $opt_r || $opt_s || 
d446 1
a446 1
	    $opt_U = $opt_m = $opt_R = $opt_s = $opt_S = 1;
@


1.73
log
@synch with my new style search/location changes
It's likely there will be some fallout, but it's getting a bit too large
to keep around.
This does kill a few very old oddities as well.
@
text
@d3 1
a3 1
# $OpenBSD$
d255 3
a257 1
		print $pkg, " "x$l, get_comment($handle->info), "\n";
@


1.72
log
@initial implementation of package signatures, based on x509 certificates and
smime detached signatures.
@
text
@d75 4
a78 5
		my @@l = sort ($repo->match(OpenBSD::Search::Stem->new($pkgname)));
		if (@@l != 0) {
			for my $p (@@l) {
				my $pkg = $repo->find($p);
				&$code($p, $pkg);
d215 1
a215 1
					add_to_path_info($p->{name}, 
@


1.71
log
@tweak the defaults to also do -M if you ask for info on a given package.
@
text
@d229 2
a230 2
our ($opt_c, $opt_D, $opt_d, $opt_f, $opt_I, $opt_i, $opt_k, $opt_K, $opt_L, 
    $opt_m, $opt_Q, $opt_q, $opt_R, $opt_r, $opt_s, $opt_v, $opt_h,
d308 1
a308 1
		if ($opt_f || $opt_L || $opt_s || $opt_S) {
d311 1
a311 1
			if ($opt_f || $opt_s || $opt_S) {
d325 11
d371 1
a371 1
set_usage('pkg_info [-AacDdfIiKkLMPqRrSstUv] [-F opt] [-E filename] [-e pkg-name] [-l str] [-Q query] [pkg-name] [...]');
d376 1
a376 1
	getopts('cDdfF:hIikKLmPQ:qRrsSUve:E:Ml:aAt',
@


1.70
log
@zap old code that was a confusion with -l, and didn't ever do anything
in the new pkg_info
problem noticed by landry@@
@
text
@d414 1
a414 1
		$opt_c = $opt_d = $opt_R = 1;
@


1.69
log
@Say goodbye to local $_
lexical scoping is so much neater (courtesy of perl 5.10)
@
text
@d230 1
a230 1
    $opt_m, $opt_p, $opt_Q, $opt_q, $opt_R, $opt_r, $opt_s, $opt_v, $opt_h,
d360 1
a360 1
set_usage('pkg_info [-AacDdfIiKkLMPpqRrSstUv] [-F opt] [-E filename] [-e pkg-name] [-l str] [-Q query] [pkg-name] [...]');
d365 1
a365 1
	getopts('cDdfF:hIikKLmpPQ:qRrsSUve:E:Ml:aAt',
d409 1
a409 1
	$opt_k || $opt_L || $opt_m || $opt_p || $opt_R || $opt_r || $opt_s || 
@


1.68
log
@use path_parse to retrieve pkg_info anywhere
@
text
@d122 1
a122 1
	local $_;
d134 1
a134 1
	local $_;
@


1.67
log
@tweak the code that finds packages to find distant stems
(todo: match pkg_add code better)
@
text
@d107 10
a116 1
	find_pkg_in('OpenBSD::PackageLocator', $pkgname, $code);
@


1.66
log
@rename forced to defines
@
text
@d69 1
a69 1
sub find_pkg
d71 1
a71 4
	my ($pkgname, $code) = @@_;
	require OpenBSD::PackageRepository::Installed;
	my $repo = OpenBSD::PackageRepository::Installed->new;
	my $pkg;
a72 5
	$pkg = $repo->find($pkgname);
	if (defined $pkg) {
		&$code($pkgname, $pkg);
		return;
	}
d78 4
a81 1
				&$code($p, $repo->find($p));
d83 1
a83 1
			return;
d86 1
a86 4
				
	require OpenBSD::PackageLocator;

	$pkg = OpenBSD::PackageLocator->find($pkgname);
d91 1
d93 15
@


1.65
log
@make it possible to run without locking the database. To be used by
SRC: url, which require it.
@
text
@d3 1
a3 1
# $OpenBSD: pkg_info,v 1.64 2007/12/08 15:54:45 espie Exp $
d345 1
a345 1
my %forced;
d353 1
a353 1
			    lock_db(1, $opt_q) unless $forced{nolock};
d369 1
a369 1
				    $forced{$o} = 1;
d385 1
a385 1
lock_db(1, $opt_q) unless $locked or $forced{nolock};
@


1.64
log
@let pkg_info -E see @@sample objects. No sense in hiding them.
@
text
@d3 1
a3 1
# $OpenBSD: pkg_info,v 1.63 2007/06/26 19:11:28 espie Exp $
d343 1
a343 1
set_usage('pkg_info [-AacDdfIiKkLMPpqRrSstUv] [-E filename] [-e pkg-name] [-l str] [-Q query] [pkg-name] [...]');
d345 1
d348 1
a348 1
	getopts('cDdfhIikKLmpPQ:qRrsSUve:E:Ml:aAt',
d353 1
a353 1
			    lock_db(1, $opt_q);
d367 5
d385 1
a385 1
lock_db(1, $opt_q) unless $locked;
@


1.63
log
@fix pkg_info's find_by_path behavior, which I accidentally broke two
versions back...
@
text
@d3 1
a3 1
# $OpenBSD: pkg_info,v 1.62 2007/06/20 13:44:39 espie Exp $
d53 1
@


1.62
log
@sprinkle code to deal gracefully with absent packing-lists.
makes it easier for people to recover after a disk crash that
leaves /var/db/pkg half-empty.
@
text
@d3 1
a3 1
# $OpenBSD: pkg_info,v 1.61 2007/06/17 12:34:02 espie Exp $
d223 2
a224 4
	if ($terse) {
		print $opt_l, $pkg, "\n" unless $opt_q;
	} else {
		print $opt_l, "Information for ", $handle->url, "\n\n" unless $opt_q;
d455 3
@


1.61
log
@only display header if we actually display some information.
Allows saying pkg_info -a -M, and not having 100s of empty lines
corresponding to all packages without a MESSAGE.
@
text
@d3 1
a3 1
# $OpenBSD: pkg_info,v 1.60 2007/06/04 18:15:19 jmc Exp $
d193 1
d300 2
a301 1
			Fatal "Bad packing list" unless defined $plist;
@


1.60
log
@add -t to usage() and SYNOPSIS;
@
text
@d3 1
a3 1
# $OpenBSD: pkg_info,v 1.59 2007/06/04 14:40:39 espie Exp $
d218 12
d241 1
a241 5
		if ($terse) {
			print $opt_l, $pkg, "\n" unless $opt_q;
		} else {
			print $opt_l, "Information for ", $handle->url, "\n\n" unless $opt_q;
		}
d243 1
d249 1
d255 1
d261 1
d267 1
d273 1
d279 1
d285 1
d302 1
d308 1
d317 1
d326 1
d332 1
d337 1
@


1.59
log
@some minor systematic changes.
- mark all regexps I can with /o if they can be compiled once.
- turn $o->method() into $o->method
- remove unneeded prototypes
- reduce split /re/ into split "string" where possible.
@
text
@d3 1
a3 1
# $OpenBSD: pkg_info,v 1.58 2007/06/04 11:42:03 pyr Exp $
d320 1
a320 1
set_usage('pkg_info [-AacDdfIiKkLMPpqRrSsUv] [-E filename] [-e pkg-name] [-l str] [-Q query] [pkg-name] [...]');
@


1.58
log
@add -t flag to pkg_info to enable listing of the ``top level'' packages,
i.e those who are not a dependency of another package.
useful to show the packages you actually use.

ok espie@@
@
text
@d3 1
a3 1
# $OpenBSD: pkg_info,v 1.57 2007/05/18 12:44:32 espie Exp $
d194 1
a194 1
			    $plist->pkgname());
d198 1
a198 1
					    $plist->pkgname());
d331 1
a331 1
			    if ($pat =~ m/\//) {
@


1.57
log
@show the url for the package we're dealing with. Unconfuse installed vs.
uninstalled stuff.
@
text
@d3 1
a3 1
# $OpenBSD: pkg_info,v 1.56 2007/05/18 12:28:26 espie Exp $
d212 1
a212 1
    $opt_l, $opt_a, $opt_M, $opt_U, $opt_A, $opt_S, $opt_P);
d324 1
a324 1
	getopts('cDdfhIikKLmpPQ:qRrsSUve:E:Ml:aA',
d407 4
d413 4
@


1.56
log
@normalize installed names
@
text
@d3 1
a3 1
# $OpenBSD: pkg_info,v 1.55 2007/05/15 19:02:26 espie Exp $
d232 1
a232 1
			print $opt_l, "Information for ", $pkg, "\n\n" unless $opt_q;
@


1.55
log
@require the right code at the right location.
problem noticed by deanna@@
@
text
@d3 1
a3 1
# $OpenBSD: pkg_info,v 1.54 2007/05/14 11:02:14 espie Exp $
d72 1
a72 1
	my $repo = OpenBSD::PackageRepository::Installed->new();
@


1.54
log
@put Search objects into their own file, finally
@
text
@d3 1
a3 1
# $OpenBSD: pkg_info,v 1.53 2007/05/14 10:53:31 espie Exp $
d71 1
a71 1
	require OpenBSD::PackageLocator;
d81 1
d91 2
@


1.53
log
@put search objects into a search class.
@
text
@d3 1
a3 1
# $OpenBSD: pkg_info,v 1.52 2007/05/14 10:43:45 espie Exp $
d142 1
a142 1
	require OpenBSD::PkgSpec;
d371 1
@


1.52
log
@name tweaks: match -> match_list, match_repo -> match
@
text
@d3 1
a3 1
# $OpenBSD: pkg_info,v 1.51 2007/05/14 10:27:46 espie Exp $
d81 1
a81 1
		my @@l = sort ($repo->match(OpenBSD::PackageName::Stem->new($pkgname)));
d145 1
a145 1
	return sort(OpenBSD::PackageRepository::Installed->new->match(OpenBSD::PkgSpec->new($pat)));
d373 1
a373 1
	my $partial = OpenBSD::PackageName::PartialStem->new($opt_Q);
@


1.51
log
@use Repository::Installed a bit more
@
text
@d3 1
a3 1
# $OpenBSD: pkg_info,v 1.50 2007/05/13 13:32:36 espie Exp $
d145 1
a145 1
	return sort(OpenBSD::PkgSpec->new($pat)->match_repo(OpenBSD::PackageRepository::Installed->new));
@


1.50
log
@unify object lookup as locator->match($o) or $repo->match($o)
@
text
@d3 1
a3 1
# $OpenBSD: pkg_info,v 1.49 2007/05/12 14:48:45 espie Exp $
d143 1
d145 1
a145 1
	return sort(OpenBSD::PkgSpec->new($pat)->match(installed_packages()));
@


1.49
log
@use PkgSpec objects most of the time
@
text
@d3 1
a3 1
# $OpenBSD: pkg_info,v 1.48 2007/05/07 14:29:58 espie Exp $
d81 1
a81 1
		my @@l = sort ($repo->findstem($pkgname));
d372 1
d374 1
a374 1
	for my $p (sort OpenBSD::PackageLocator->find_partialstem($opt_Q)) {
@


1.48
log
@use repo->findstem
@
text
@d3 1
a3 1
# $OpenBSD: pkg_info,v 1.47 2007/05/07 14:12:43 espie Exp $
d144 1
a144 1
	return sort(OpenBSD::PkgSpec::match($pat, installed_packages()));
@


1.47
log
@remove dependency on available_stems(), make it go thru PackageLocator
@
text
@d3 1
a3 1
# $OpenBSD: pkg_info,v 1.46 2007/05/07 14:06:38 espie Exp $
d81 1
a81 1
		my @@l = sort (OpenBSD::PackageName::findstem($pkgname, $repo->available()));
@


1.46
log
@do not expose stemlist internals, create find_partialstem function.
@
text
@d3 1
a3 1
# $OpenBSD: pkg_info,v 1.45 2007/05/02 13:59:19 espie Exp $
a370 1
	my $stemlist = OpenBSD::PackageName::available_stems();
d373 1
a373 1
	for my $p (sort $stemlist->find_partialstem($opt_Q)) {
@


1.45
log
@remove extraneous () in method call: $o->method() becomes $o->method
@
text
@d3 1
a3 1
# $OpenBSD: pkg_info,v 1.44 2007/05/01 18:22:20 espie Exp $
d374 2
a375 10
	for my $stem (sort keys %$stemlist) {
		if ($stem =~ /\Q$opt_Q\E/i) {
			for my $p (keys %{$stemlist->{$stem}}) {
				my $text = "$p";
				if (is_installed($p)) {
					$text .= " (installed)";
				}
				print $text."\n";
			}
		}
@


1.44
log
@move the old elements into PackingElements, since the code is now
much shorter.
@
text
@d3 1
a3 1
# $OpenBSD: pkg_info,v 1.43 2007/04/29 11:09:29 espie Exp $
d48 1
a48 1
		print '@@', $item->keyword(), " ";
d50 1
a50 1
	print $item->fullname(), "\n";
d56 1
a56 1
	my $fname = $item->fullname();
d93 2
a94 2
		$pkg->close_now();
		$pkg->wipe_info();
d223 1
a223 1
		print $pkg, " "x$l, get_comment($handle->info()), "\n";
d232 1
a232 1
			print get_comment($handle->info()), "\n";
d235 1
a235 1
		if ($opt_R && -f $handle->info().REQUIRED_BY) {
d237 1
a237 1
			printfile($handle->info().REQUIRED_BY);
d242 1
a242 1
			print_description($handle->info());
d245 1
a245 1
		if ($opt_M && -f $handle->info().DISPLAY) {
d247 1
a247 1
			printfile($handle->info().DISPLAY);
d250 1
a250 1
		if ($opt_U && -f $handle->info().UNDISPLAY) {
d252 1
a252 1
			printfile($handle->info().UNDISPLAY);
d255 1
a255 1
		if ($opt_i && -f $handle->info().INSTALL) {
d257 1
a257 1
			printfile($handle->info().INSTALL);
d260 1
a260 1
		if ($opt_k && -f $handle->info().DEINSTALL) {
d262 1
a262 1
			printfile($handle->info().DEINSTALL, \*STDOUT);
d265 1
a265 1
		if ($opt_r && -f $handle->info().REQUIRE) {
d267 1
a267 1
			printfile($handle->info().REQUIRE, \*STDOUT);
d275 1
a275 1
				$plist = $handle->plist();
d296 1
a296 1
			print $plist->signature(), "\n";
@


1.43
log
@replace $p->visit('method') calls with $p->method
now that it works.
@
text
@d3 1
a3 1
# $OpenBSD: pkg_info,v 1.42 2007/04/15 10:17:29 espie Exp $
a148 1
	require OpenBSD::PackingOld;
a181 1
		require OpenBSD::PackingOld;
a271 1
			require OpenBSD::PackingOld;
@


1.42
log
@update copyright years, standardize licence.
reword the introduction to the stuff originally from FreeBSD to clarify
slightly.
@
text
@d3 1
a3 1
# $OpenBSD: pkg_info,v 1.41 2007/01/29 10:57:36 bernd Exp $
d161 1
a161 1
			$plist->visit('hunt_file', $search, $pkgname, \@@result);
d286 1
a286 1
			$plist->visit('dump_file', $opt_K);
d291 1
a291 1
			$plist->visit('sum_up', \$size);
@


1.41
log
@Three lines in SYNOPSIS are too much. Use only one line and sync usage.

prodded by & ok jmc@@
@
text
@d3 1
a3 1
# $OpenBSD: pkg_info,v 1.40 2007/01/23 11:40:26 bernd Exp $
d5 1
a5 1
# Copyright (c) 2003-2004 Marc Espie <espie@@openbsd.org>
@


1.40
log
@Introduce -Q option:

-Q query
        Show all packages in $PKG_PATH which match the given query.

Example:
$ pkg_info -Q bogofilter
bogofilter-1.0.3-qdbm (installed)
bogofilter-1.0.3-db4
bogofilter-1.0.3-sqlite3
bogofilter-1.0.3
$

Manpage help from sturm@@. ok sturm@@, steven@@, espie@@
@
text
@d3 1
a3 1
# $OpenBSD: pkg_info,v 1.39 2006/02/23 12:28:22 bernd Exp $
d319 1
a319 1
set_usage('pkg_info [-cDdfIiKkLMPpqRrSsUv] [-E filename] [-e pkg-name] [-l str] pkg-name [...]', 'pkg_info [-Aa flags]', 'pkg_info [-v] [-Q query]');
@


1.39
log
@Let 'pkg_info -P' work with package distribution files and URLs to a
package.

ok espie@@
@
text
@d3 1
a3 1
# $OpenBSD: pkg_info,v 1.38 2006/02/09 09:40:31 espie Exp $
d209 2
a210 2
    $opt_m, $opt_p, $opt_q, $opt_R, $opt_r, $opt_s, $opt_v, $opt_h, $opt_l, 
    $opt_a, $opt_M, $opt_U, $opt_A, $opt_S, $opt_P);
d319 1
a319 1
set_usage('pkg_info [-cDdfIiKkLMPpqRrSsUv] [-E filename] [-e pkg-name] [-l str] pkg-name [...]', 'pkg_info [-Aa flags]');
d323 1
a323 1
	getopts('cDdfhIikKLmpPqRrsSUve:E:Ml:aA',
d369 21
@


1.38
log
@use new interface (*close*)
optimization: store dir into state earlier, so that do_script and
other stuff can have access to it.
@
text
@d3 1
a3 1
# $OpenBSD: pkg_info,v 1.37 2005/11/01 17:02:29 bernd Exp $
d304 2
a305 2
			my $plist = OpenBSD::PackingList->from_installation(
			    $pkg, \&OpenBSD::PackingList::ExtraInfoOnly);
@


1.37
log
@Add -P option. This shows the pkgpath for each package. Nice for building
subdirlists.

Document new option.

"commit" espie@@
@
text
@d3 1
a3 1
# $OpenBSD: pkg_info,v 1.36 2005/10/28 20:16:13 espie Exp $
d93 1
a93 1
		$pkg->close();
@


1.36
log
@fix error code path for pkg_info -e pouet
@
text
@d3 1
a3 1
# $OpenBSD: pkg_info,v 1.35 2005/09/19 10:16:32 espie Exp $
d210 1
a210 1
    $opt_a, $opt_M, $opt_U, $opt_A, $opt_S);
d301 8
d319 1
a319 1
set_usage('pkg_info [-cDdfIiKkLMpqRrSsUv] [-E filename] [-e pkg-name] [-l str] pkg-name [...]', 'pkg_info [-Aa flags]');
d323 1
a323 1
	getopts('cDdfhIikKLmpqRrsSUve:E:Ml:aA',
d363 1
a363 1
	$opt_S || $terse) {
@


1.35
log
@simplify pkg_info a great deal, by relying on the lazy properties of
pkghandles to avoid creating directories.

Use PackageRepository::Installed to make code symetric.
@
text
@d3 1
a3 1
# $OpenBSD: pkg_info,v 1.34 2005/09/19 09:51:49 espie Exp $
d213 1
d329 1
d377 1
a377 1
	Usage "Missing package name(s)" unless $terse && $opt_q;
d384 1
a384 1
if (@@ARGV == 0) {
@


1.34
log
@let pkg_info -e see @@pkgpath annotations.
Solves update issues where the pkgpath changed
@
text
@d3 1
a3 1
# $OpenBSD: pkg_info,v 1.33 2005/09/17 12:10:52 espie Exp $
d68 1
a68 1
sub find_pkg_plist
d70 4
a73 4
	my ($pkg, $filter, $code) = @@_;

	require OpenBSD::PackingOld;
	require OpenBSD::PackingList;
d75 3
a77 2
	if (is_installed($pkg)) {
		&$code($pkg, OpenBSD::PackingList->from_installation($pkg, $filter));
d80 2
a81 2
	if (OpenBSD::PackageName::is_stem($pkg)) {
		my @@l = sort (OpenBSD::PackageName::findstem($pkg, installed_packages()));
d84 1
a84 1
				&$code($p, OpenBSD::PackingList->from_installation($p, $filter));
d90 5
a94 22
	require OpenBSD::PackageLocator;

	my $plist = OpenBSD::PackageLocator->grabPlist($pkg, $filter);
	return unless $plist;
	&$code($pkg, $plist);
}

sub find_pkg
{
	my ($pkg, $code) = @@_;
	if (is_installed($pkg)) {
		&$code($pkg, installed_info($pkg));
		return;
	}
	if (OpenBSD::PackageName::is_stem($pkg)) {
		my @@l = sort (OpenBSD::PackageName::findstem($pkg, installed_packages()));
		if (@@l != 0) {
			for my $p (@@l) {
				&$code($p, installed_info($p));
			}
			return;
		}
a95 8
				
	require OpenBSD::PackageLocator;

	my $true_package = OpenBSD::PackageLocator->find($pkg);
	return unless $true_package;
	my $dir = $true_package->info();
	&$code($pkg, $dir, $true_package);
	$true_package->close();
d155 1
a155 1
		find_pkg_plist($arg, \&OpenBSD::PackingList::FilesOnly,
d157 3
a159 1
		    	my ($pkg, $plist) = @@_;
d161 1
a161 1
			$plist->visit('hunt_file', $search, $pkg, \@@result);
d217 2
a218 2
	my ($pkg, $dir, $handle) = @@_;
	unless (-d $dir) {
d224 1
a224 1
		print $pkg, " "x$l, get_comment($dir), "\n";
d233 1
a233 1
			print get_comment($dir), "\n";
d236 1
a236 1
		if ($opt_R && -f $dir.REQUIRED_BY) {
d238 1
a238 1
			printfile($dir.REQUIRED_BY);
d243 1
a243 1
			print_description($dir);
d246 1
a246 1
		if ($opt_M && -f $dir.DISPLAY) {
d248 1
a248 1
			printfile($dir.DISPLAY);
d251 1
a251 1
		if ($opt_U && -f $dir.UNDISPLAY) {
d253 1
a253 1
			printfile($dir.UNDISPLAY);
d256 1
a256 1
		if ($opt_i && -f $dir.INSTALL) {
d258 1
a258 1
			printfile($dir.INSTALL);
d261 1
a261 1
		if ($opt_k && -f $dir.DEINSTALL) {
d263 1
a263 1
			printfile($dir.DEINSTALL, \*STDOUT);
d266 1
a266 1
		if ($opt_r && -f $dir.REQUIRE) {
d268 1
a268 1
			printfile($dir.REQUIRE, \*STDOUT);
a309 37
sub print_plist_info
{
	my ($pkg, $plist) = @@_;
	unless (defined $plist) {
		print STDERR "Error printing info for $pkg: no info ?\n";
	}
	if ($terse) {
		print $opt_l, $pkg, "\n" unless $opt_q;
	} else {
		print $opt_l, "Information for ", $pkg, "\n\n" unless $opt_q;
	}
	if ($opt_L) {
		print $opt_l, "Files:\n" unless $opt_q;
		$plist->visit('dump_file', $opt_K);
		print "\n";
	}
	if ($opt_s) {
		my $size = 0;
		$plist->visit('sum_up', \$size);
		print "Size: " unless $opt_q;
		print "$size\n";
		$total_size += $size;
		$pkgs++;
	}
	if ($opt_S) {
		print "Signature: " unless $opt_q;
		print $plist->signature(), "\n";
	}

	if ($opt_f) {
		print $opt_l, "Packing list:\n" unless $opt_q;
		$plist->write(\*STDOUT);
		print "\n";
	}
	print $opt_l, "\n" unless $opt_q || $terse;
}

d400 1
a400 6
	if ($opt_I || $opt_c || $opt_R || $opt_d || $opt_M || $opt_U ||
	    $opt_i || $opt_k || $opt_r) {
		find_pkg($pkg, \&print_info);
	} else {
		find_pkg_plist($pkg, undef, \&print_plist_info);
	}
@


1.33
log
@special-case when we only need the packing-list.
@
text
@d3 1
a3 1
# $OpenBSD: pkg_info,v 1.32 2005/09/07 09:40:50 jmc Exp $
d118 1
a118 1
	&$code($pkg, $dir);
d191 9
d213 8
a220 4
			my $path = $plist->{extrainfo}->{subdir};
			$path_info->{$path} = [] unless 
			    defined $path_info->{$path};
			push(@@{$path_info->{$path}}, $plist->pkgname());
d239 1
a239 1
	my ($pkg, $dir) = @@_;
d299 1
a299 1
				$plist = OpenBSD::PackingList->fromfile($dir.CONTENTS);
d301 1
a301 1
				$plist = OpenBSD::PackingList->fromfile($dir.CONTENTS, \&OpenBSD::PackingList::FilesOnly);
@


1.32
log
@sort options and sync usage();
@
text
@d3 1
a3 1
# $OpenBSD: pkg_info,v 1.31 2005/09/04 22:47:56 espie Exp $
d68 27
d121 1
d179 1
a179 1
		find_pkg($arg,
d181 1
a181 1
		    	my ($pkg, $dir) = @@_;
a182 2
			my $plist = OpenBSD::PackingList->fromfile($dir.CONTENTS,
			    \&OpenBSD::PackingList::FilesOnly);
d319 37
d446 6
a451 1
	find_pkg($pkg, \&print_info);
@


1.31
log
@* New -i interactive option, that can ask obnoxious questions.
* move the signature code to a packing-list method, prepend the pkgname.
* depend on distant listings, cache these systematically.
* cut the PKG_PATH at :/ systematically, much simpler than parsing URLs.
People should get used to trailing /s.
* let pkg_add -u actually run the update.
* check for signature in more places, for instance, let pkg_add installed_stuff
be a void operation.
* grab enough stuff during updates to check signatures, so that pkg_add -u
can report updates that are not needed right away, instead of waiting
for the more confusing `trying to update'
* beginning of @@module support.
* @@pkgpath support, including updates.
* systematically expand stems when applicable.
* use visitors systematically in pkg_info.
* pkg_info -S reports signature.
* remove hardcoding of categories in PackingList, so that future modules
will be able to expand them.
* add @@updateset and @@incompatibility keywords.
@
text
@d3 1
a3 1
# $OpenBSD: pkg_info,v 1.30 2005/08/16 08:59:38 espie Exp $
d293 1
a293 1
set_usage('pkg_info [-cDdfIiKkLMpqRrsSUv] [-E fname] [-e pkgname] [-l str] pkgname...', 'pkg_info [-Aa flags]');
@


1.30
log
@fix getopt line, noticed by Gerardo Santana
@
text
@d3 1
a3 1
# $OpenBSD: pkg_info,v 1.29 2005/06/08 09:43:40 espie Exp $
d26 39
d157 1
a157 8
			for my $item (@@{$plist->{items}}) {
				next unless $item->IsFile();
				my $fname = $item->fullname();
				if (defined $search->{"$fname"}) {
					push(@@{$search->{$fname}}, $pkg);
					push(@@result, $pkg);
				}
			}
d193 1
a193 1
    $opt_a, $opt_M, $opt_U, $opt_A);
d255 1
a255 1
		if ($opt_f || $opt_L || $opt_s) {
d259 1
a259 1
			if ($opt_f || $opt_s) {
d268 1
a268 7
			for my $item (@@{$plist->{items}}) {
				next unless $item->IsFile();
				if ($opt_K) {
					print '@@', $item->keyword(), " ";
				}
				print $item->fullname(), "\n";
			}
d273 3
a275 7
			for my $item (@@{$plist->{items}}) {
				next unless $item->IsFile();
				if (defined $item->{size}) {
					$size += $item->{size};
				}
			}
			print "Size: $size\n";
d279 4
d293 1
a293 1
set_usage('pkg_info [-cDdfIiKkLMpqRrsUv] [-E fname] [-e pkgname] [-l str] pkgname...', 'pkg_info [-Aa flags]');
d297 1
a297 1
	getopts('cDdfhIikKLmpqRrsUve:E:Ml:aA',
d335 2
a336 1
	$opt_k || $opt_L || $opt_m || $opt_p || $opt_R || $opt_r || $opt_s || $terse) {
d346 1
a346 1
	    $opt_U = $opt_m = $opt_R = $opt_s = 1;
@


1.29
log
@squeeze +COMMENT in front of +DESC.
Transparently handle both package types, until everyone has
transitionned  to new style.

Reasons for the change:
- comment and desc are never written independently
- access to comment necessitates a file read anyways.
- shaves one inode and (mostly) one block from each installed package.

Since this is /var, and there is often a lot of stuff going on in a small
partition, this helps.

Done after griping from tedu@@, okay'd pval@@
@
text
@d3 1
a3 1
# $OpenBSD: pkg_info,v 1.28 2005/01/16 11:16:23 espie Exp $
d271 1
a271 1
	getopts('cDdfhIikKLmpqRrsvhe:E:MU:l:aA',
@


1.28
log
@allow locking of database in quiet mode, where we don't display any
message.
Display the lock message on stderr anyways, so that we don't disturb
normal displays.
postpone locking after we know about -q in pkg_info's case.
Display command line if pkg_create fails, so that we can see what arguments
it found in bsd.port.mk.
@
text
@d3 1
a3 1
# $OpenBSD: pkg_info,v 1.27 2005/01/14 02:25:12 espie Exp $
d67 13
d89 6
d175 1
a175 1
		print $pkg, " "x$l, get_line($dir.COMMENT), "\n";
d184 1
a184 1
			printfile($dir.COMMENT);
d194 1
a194 1
			printfile($dir.DESC);
@


1.27
log
@`big lock' model: lock the whole db for reading/writing.
design checked with millert@@, relying on process termination for unlock
at his suggestion.

Perf optimization: don't try to reinstall installed packages in kitchensink
mode if !-r.
@
text
@d3 1
a3 1
# $OpenBSD: pkg_info,v 1.26 2004/12/22 12:56:25 espie Exp $
d250 1
a250 1
lock_db(1);
d257 2
d282 2
@


1.26
log
@keep less stuff around for -e pkgpath.
@
text
@d3 1
a3 1
# $OpenBSD: pkg_info,v 1.25 2004/12/16 11:07:33 espie Exp $
d250 1
@


1.25
log
@renamed borked_installation from borked.n to partial-<pkgname> ...
partial-<pkgname>.n if needed.

Make borked_installation take a message, to show installation/deinstallation
issues correctly.

Fix handling of ^C: this may lead some system calls to return early, thus
registering as errors: so always mark the last file as done, so that borked
installation will register it correctly.

Kill packing-list cache for anything but depends: we've got a global cache
of libraries now (use it in pkg_add).

Make almost everyone look at $main::not, so that we can call
register_installation
to_installation
RequirementList->add/delete
safely.

Simplify $not logic accordingly, do thing much more closely to what would
happen without -n.

This should allow pkg_add/pkg_delete -n to handle most nasty cases correctly
now, since all the relevant information is kept internally in a compact
format:
- register of shared libraries
- global register of conflicts
- cache of depends.
@
text
@d3 1
a3 1
# $OpenBSD: pkg_info,v 1.24 2004/12/12 11:26:16 espie Exp $
d112 1
a112 1
my $all_plists;
d118 1
a118 1
	if (!defined $all_plists) {
d122 3
a124 3
		$all_plists = [];
		for my $pkg (installed_packages()) {
			push(@@$all_plists, 
d126 5
a130 1
				    \&OpenBSD::PackingList::ExtraInfoOnly));
d133 4
a136 5
	my @@result = ();
	for my $plist (@@$all_plists) {
		if ($plist->{extrainfo}->{subdir} eq $pat) {
			push(@@result, $plist->pkgname());
		}
a137 1
	return @@result;
@


1.24
log
@add somewhat more regular error catching code.
@
text
@d3 1
a3 1
# $OpenBSD: pkg_info,v 1.23 2004/12/06 15:19:11 espie Exp $
a106 1
			$plist->forget();
@


1.23
log
@forgot -h for pkg_info.
@
text
@d3 1
a3 1
# $OpenBSD: pkg_info,v 1.22 2004/12/06 12:35:36 espie Exp $
d249 29
a277 30
eval { getopts('cDdfhIikKLmpqRrsvhe:E:MU:l:aA',
	{'e' =>
		sub {
			my $pat = shift;
			my @@list;
			if ($pat =~ m/\//) {
				@@list = find_by_path($pat);
			} else {
				@@list = find_by_spec($pat);
			}
			if (@@list == 0) {
				$exit_code = 1;
			}
			push(@@ARGV, @@list);
			$terse = 1;
		},
	 'h' => sub {	Usage(); },
	 'E' =>
	 	sub {
			require File::Spec;

			push(@@sought_files, File::Spec->rel2abs(shift));

		}
	}); };
if ($@@) {
	chomp($@@);
	$@@ =~ s/\s+at.*?$//;
	Usage($@@);
}
@


1.22
log
@Usage
@
text
@d3 1
a3 1
# $OpenBSD: pkg_info,v 1.21 2004/11/15 12:58:48 espie Exp $
d249 1
a249 1
eval { getopts('cDdfIikKLmpqRrsvhe:E:MU:l:aA',
d265 1
@


1.21
log
@find_pkg function to iterate through pkgs, wherever they might be.
New -E filename option that looks for a filename through specified
packages (or installed packages if no packages specified). Can be very,
very slow, since it scans all packing-lists, but at least it works...
@
text
@d3 1
a3 1
# $OpenBSD: pkg_info,v 1.20 2004/11/15 12:22:59 espie Exp $
d247 3
a249 1
getopts('cDdfIikKLmpqRrsvhe:E:MU:l:aA',
d272 6
a277 1
	});
d302 1
a302 1
	Fatal "-K only makes sense with -L";
d306 1
a306 1
	Fatal "Missing package name(s)" unless $terse && $opt_q;
d310 1
a310 1
	Fatal "Can't specify package name(s) with -a";
@


1.20
log
@repair -l
@
text
@d3 1
a3 1
# $OpenBSD: pkg_info,v 1.19 2004/11/15 11:23:10 espie Exp $
d29 26
d85 28
d144 1
d247 1
a247 1
getopts('cDdfIikKLmpqRrsvhe:MU:l:aA',
d262 7
d310 9
a318 12
for my $pkg (@@ARGV) {
	if (is_installed($pkg)) {
		print_info($pkg, installed_info($pkg));
		next;
	}
	if (OpenBSD::PackageName::is_stem($pkg)) {
		my @@l = sort (OpenBSD::PackageName::findstem($pkg, installed_packages()));
		if (@@l != 0) {
			for my $p (@@l) {
				print_info($p, installed_info($p));
			}
			next;
d321 1
a321 2
				
	require OpenBSD::PackageLocator;
d323 2
a324 6
	my $true_package = OpenBSD::PackageLocator->find($pkg);
	next unless $true_package;
	my $dir = $true_package->info();
	$true_package->close();

	print_info($pkg, $dir);
@


1.19
log
@don't Fatal out if -e thingy -q, since we're only interested in the
result code.
@
text
@d3 1
a3 1
# $OpenBSD: pkg_info,v 1.18 2004/11/14 13:05:02 espie Exp $
d103 1
a103 1
			print $opt_p, $pkg, "\n" unless $opt_q;
d105 1
a105 1
			print $opt_p, "Information for ", $pkg, "\n\n" unless $opt_q;
d108 1
a108 1
			print $opt_p, "Comment:\n" unless $opt_q;
d113 1
a113 1
			print $opt_p, "Required by:\n" unless $opt_q;
d118 1
a118 1
			print $opt_p, "Description:\n" unless $opt_q;
d123 1
a123 1
			print $opt_p, "Install notice:\n" unless $opt_q;
d128 1
a128 1
			print $opt_p, "Deinstall notice:\n" unless $opt_q;
d133 1
a133 1
			print $opt_p, "Install script:\n" unless $opt_q;
d138 1
a138 1
			print $opt_p, "De-Install script:\n" unless $opt_q;
d143 1
a143 1
			print $opt_p, "Require script:\n" unless $opt_q;
d160 1
a160 1
			print $opt_p, "Files:\n" unless $opt_q;
d184 1
a184 1
			print $opt_p, "Packing list:\n" unless $opt_q;
d188 1
a188 1
		print $opt_p, "\n" unless $opt_q || $terse;
d228 2
a229 2
if (!defined $opt_p) {
	$opt_p = "";
@


1.18
log
@-K -L option that prefixes each file name with keyword.
@
text
@d3 1
a3 1
# $OpenBSD: pkg_info,v 1.17 2004/11/11 11:54:09 espie Exp $
d237 1
a237 1
	Fatal "Missing package name(s)";
@


1.17
log
@package names starting with .  are hidden from pkg_info by default.
-A shows them.
@
text
@d3 1
a3 1
# $OpenBSD: pkg_info,v 1.16 2004/11/11 11:24:15 espie Exp $
d24 1
d85 2
a86 2
our ($opt_c, $opt_D, $opt_d, $opt_f, $opt_I, $opt_i, $opt_k, $opt_L, $opt_m,
    $opt_p, $opt_q, $opt_R, $opt_r, $opt_s, $opt_v, $opt_h, $opt_l, 
d157 1
a157 1
			die "Bad packing list" unless defined $plist;
d163 3
d192 1
a192 1
getopts('cDdfIikLmpqRrsvhe:MU:l:aA',
d232 4
d237 1
a237 1
	die "Missing package name(s)";
d241 1
a241 1
	die "Can't specify package name(s) with -a";
@


1.16
log
@typo
@
text
@d3 1
a3 1
# $OpenBSD: pkg_info,v 1.15 2004/11/11 11:16:39 espie Exp $
d86 1
a86 1
    $opt_a, $opt_M, $opt_U);
d188 1
a188 1
getopts('cDdfIikLmpqRrsvhe:MU:l:a',
d228 1
a228 1
if (@@ARGV == 0 && !$opt_a) {
d232 1
a232 1
if (@@ARGV > 0 && $opt_a) {
d237 1
a237 1
	@@ARGV = sort(installed_packages());
@


1.15
log
@introduce shortcuts to read/write contents from_installation/to_installation

use these to simplify all those packing lists manipulations.

demote non-root detection to a warning in -n mode:
fix a couple of minor bugs, of stuff that was run in -n mode and should not.
Namely, manpages were indexed/unindexed (ouch) and tempfiles were creating
during updates.
@
text
@d3 1
a3 1
# $OpenBSD: pkg_info,v 1.14 2004/11/10 09:55:43 espie Exp $
d72 1
a72 1
				    \&OpenBSD::PackingList::ExtraInfoOnly);
@


1.14
log
@use ExtraInfo, finally: allows pkg_info to report packages according to
PKGPATH, e.g., pkg_info -e x11/kde/base3 will tell you which version
(if any) of kdebase is installed.

Necessary for achieving updates.
@
text
@d3 1
a3 1
# $OpenBSD: pkg_info,v 1.13 2004/11/10 09:41:16 espie Exp $
d71 2
a72 1
				OpenBSD::PackingList->fromfile(installed_info($pkg).CONTENTS, \&OpenBSD::PackingList::ExtraInfoOnly));
@


1.13
log
@resurrect -e, document that it uses packages-specs now.
@
text
@d3 1
a3 1
# $OpenBSD: pkg_info,v 1.12 2004/11/09 11:16:53 espie Exp $
d49 34
d191 6
a196 4
			require OpenBSD::PkgSpec;

			my @@list = sort(OpenBSD::PkgSpec::match($pat, 
					    installed_packages()));
@


1.12
log
@-s seamless with other options: let it work with -a, let it be on for -v.
Count totalsize, and display it at end if > 1 package.
@
text
@d3 1
a3 1
# $OpenBSD: pkg_info,v 1.11 2004/11/09 10:46:57 espie Exp $
d23 1
a23 1
use Getopt::Std;
d50 1
a50 1
    $opt_p, $opt_q, $opt_R, $opt_r, $opt_s, $opt_v, $opt_h, $opt_e, $opt_l, 
d52 2
d66 5
a70 1
		print $opt_p, "Information for ", $pkg, "\n\n" unless $opt_q;
d149 1
a149 1
		print $opt_p, "\n" unless $opt_q;
d153 5
a157 1
getopts('cDdfIikLmpqRrsvheMU:l:a');
d159 9
a167 3
if (defined $opt_e) {
	die "Error: -e is not yet supported";
}
d174 1
a174 1
	$opt_k || $opt_L || $opt_m || $opt_p || $opt_R || $opt_r || $opt_s) {
d230 1
@


1.11
log
@-s option, grange's request.
@
text
@d3 1
a3 1
# $OpenBSD: pkg_info,v 1.10 2004/10/11 10:30:33 espie Exp $
d25 3
d134 2
d158 1
a158 1
	$opt_k || $opt_L || $opt_m || $opt_p || $opt_R || $opt_r) {
d168 1
a168 1
	    $opt_U = $opt_m = $opt_R = 1;
d210 3
@


1.10
log
@add support for undisplay file, to be able to show information at pkg
removal without having to run a DEINSTALL script...
@
text
@d3 1
a3 1
# $OpenBSD: pkg_info,v 1.9 2004/08/12 10:35:06 espie Exp $
d47 2
a48 2
    $opt_p, $opt_q, $opt_R, $opt_r, $opt_v, $opt_h, $opt_e, $opt_l, $opt_a,
    $opt_M, $opt_U);
d103 1
a103 1
		if ($opt_f || $opt_L) {
d107 1
a107 1
			if ($opt_f) {
d122 11
d142 1
a142 1
getopts('cDdfIikLmpqRrvheMU:l:a');
@


1.9
log
@ditch File::Copy so that buffering is consistent.
Problem noticed by niklas@@.
okay and function name suggestion by markus@@
@
text
@d3 1
a3 1
# $OpenBSD: pkg_info,v 1.8 2004/08/06 08:17:40 espie Exp $
d47 2
a48 1
    $opt_p, $opt_q, $opt_R, $opt_r, $opt_v, $opt_h, $opt_e, $opt_l, $opt_a);
d77 1
a77 1
		if ($opt_D && -f $dir.DISPLAY) {
d82 5
d131 1
a131 1
getopts('cDdfIikLmpqRrvhe:l:a');
d137 5
a141 1
unless ($opt_c || $opt_D || $opt_d || $opt_f || $opt_I || $opt_i ||
d151 2
a152 2
	$opt_c = $opt_d = $opt_f = $opt_i = $opt_k = $opt_r = $opt_D =
	    $opt_m = $opt_R = 1;
@


1.8
log
@unneeded switch to main package.
@
text
@d3 1
a3 1
# $OpenBSD: pkg_info,v 1.7 2004/08/06 08:14:52 espie Exp $
d25 12
a61 2
			require File::Copy;

d63 1
a63 1
			File::Copy::copy($dir.COMMENT, \*STDOUT);
a66 2
			require File::Copy;

d68 1
a68 1
			File::Copy::copy($dir.REQUIRED_BY, \*STDOUT);
a71 2
			require File::Copy;

d73 1
a73 1
			File::Copy::copy($dir.DESC, \*STDOUT);
a76 2
			require File::Copy;

d78 1
a78 1
			File::Copy::copy($dir.DISPLAY, \*STDOUT);
a81 2
			require File::Copy;

d83 1
a83 1
			File::Copy::copy($dir.INSTALL, \*STDOUT);
a86 2
			require File::Copy;

d88 1
a88 1
			File::Copy::copy($dir.DEINSTALL, \*STDOUT);
a91 2
			require File::Copy;

d93 1
a93 1
			File::Copy::copy($dir.REQUIRE, \*STDOUT);
@


1.7
log
@avoid pulling in OpenBSD::md5 and File::Copy if we can.
@
text
@d3 1
a3 1
# $OpenBSD: pkg_info,v 1.6 2004/08/06 08:06:01 espie Exp $
a23 2

package main;
@


1.6
log
@block-scoped require is way simpler than weird AUTOLOAD hack.
@
text
@d3 1
a3 1
# $OpenBSD: pkg_info,v 1.5 2004/08/06 07:51:17 espie Exp $
a23 1
use File::Copy;
d52 2
d55 1
a55 1
			copy($dir.COMMENT, \*STDOUT);
d59 2
d62 1
a62 1
			copy($dir.REQUIRED_BY, \*STDOUT);
d66 2
d69 1
a69 1
			copy($dir.DESC, \*STDOUT);
d73 2
d76 1
a76 1
			copy($dir.DISPLAY, \*STDOUT);
d80 2
d83 1
a83 1
			copy($dir.INSTALL, \*STDOUT);
d87 2
d90 1
a90 1
			copy($dir.DEINSTALL, \*STDOUT);
d94 2
d97 1
a97 1
			copy($dir.REQUIRE, \*STDOUT);
@


1.5
log
@unified headers, switch to smaller copyright notice.
@
text
@d3 1
a3 1
# $OpenBSD: pkg_info,v 1.4 2004/06/21 16:33:45 espie Exp $
a24 17
# XXX we don't want to load these packages all the time
package OpenBSD::PackageLocator;
our $AUTOLOAD;
sub AUTOLOAD {
	eval { require OpenBSD::PackageLocator;
	};
	goto &$AUTOLOAD;
}

package OpenBSD::PackingList;
our $AUTOLOAD;
sub AUTOLOAD {
	eval {	require OpenBSD::PackingOld;
		require OpenBSD::PackingList;
	};
	goto &$AUTOLOAD;
}
d89 3
d167 2
@


1.4
log
@support for old stuff in pkg_info/pkg_delete, e.g., @@src
prompted by miod@@, okay miod@@ millert@@.
@
text
@d3 1
a3 1
# $OpenBSD: pkg_info,v 1.3 2003/10/23 17:48:07 espie Exp $
d5 13
a17 22
# Copyright (c) 2003 Marc Espie.
# 
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
# 
# THIS SOFTWARE IS PROVIDED BY THE OPENBSD PROJECT AND CONTRIBUTORS
# ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
# A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OPENBSD
# PROJECT OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
@


1.3
log
@missing space in DEINSTALL message.
allow pkg_delete stem to work, unless ambiguous.
put all pkg_info's work into a single function, so that
pkg_info autoconf will work.

ok fries@@ sturm@@
@
text
@d3 1
a3 1
# $OpenBSD: pkg_info,v 1.2 2003/10/19 18:40:11 espie Exp $
d46 2
a47 1
	eval { require OpenBSD::PackingList;
@


1.2
log
@Add is_stem, findstem and use them in pkg_info.
@
text
@d3 1
a3 1
# $OpenBSD: pkg_info,v 1.1.1.1 2003/10/16 17:43:34 espie Exp $
d65 3
a67 38
getopts('cDdfIikLmpqRrvhe:l:a');

if (defined $opt_e) {
	die "Error: -e is not yet supported";
}

unless ($opt_c || $opt_D || $opt_d || $opt_f || $opt_I || $opt_i ||
	$opt_k || $opt_L || $opt_m || $opt_p || $opt_R || $opt_r) {
	if (@@ARGV == 0) {
		$opt_I = $opt_a = 1;
	} else {
		$opt_c = $opt_d = $opt_R = 1;
	}
}

if ($opt_v) {
	$opt_c = $opt_d = $opt_f = $opt_i = $opt_k = $opt_r = $opt_D =
	    $opt_m = $opt_R = 1;
}

if (!defined $opt_p) {
	$opt_p = "";
}

if (@@ARGV == 0 && !$opt_a) {
	die "Missing package name(s)";
}

if (@@ARGV > 0 && $opt_a) {
	die "Can't specify package name(s) with -a";
}

if (@@ARGV == 0) {
	@@ARGV = sort(installed_packages());
}

for my $pkg (@@ARGV) {
	my $dir = installed_info($pkg);
d69 1
a69 16
		if (OpenBSD::PackageName::is_stem($pkg)) {
			my @@l = OpenBSD::PackageName::findstem($pkg, installed_packages());
			if (@@l == 1) {
				$dir = installed_info($l[0]);
			} elsif (@@l != 0) {
				print STDERR "$pkg: ambiguous (", join(" ",@@l), ")\n";
				next;
			}
		}
	}
				
	unless (-d $dir) {
		my $true_package = OpenBSD::PackageLocator->find($pkg);
		next unless $true_package;
		$dir = $true_package->info();
		$true_package->close();
d136 59
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
# $OpenBSD: pkg_info,v 1.1.1.1 2003/10/16 17:16:30 espie Exp $
d31 1
d103 12
@


1.1.1.1
log
@new import of my pkgtools, after a slight naming disagreement with the
Upper Management...
@
text
@@
