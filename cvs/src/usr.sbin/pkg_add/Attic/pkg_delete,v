head	1.135;
access;
symbols
	OPENBSD_4_7:1.133.0.2
	OPENBSD_4_7_BASE:1.133
	OPENBSD_4_6:1.113.0.8
	OPENBSD_4_6_BASE:1.113
	OPENBSD_4_5:1.113.0.4
	OPENBSD_4_5_BASE:1.113
	OPENBSD_4_4:1.113.0.2
	OPENBSD_4_4_BASE:1.113
	OPENBSD_4_3:1.111.0.2
	OPENBSD_4_3_BASE:1.111
	OPENBSD_4_2:1.110.0.2
	OPENBSD_4_2_BASE:1.110
	OPENBSD_4_1:1.95.0.2
	OPENBSD_4_1_BASE:1.95
	OPENBSD_4_0:1.94.0.2
	OPENBSD_4_0_BASE:1.94
	OPENBSD_3_9:1.93.0.2
	OPENBSD_3_9_BASE:1.93
	OPENBSD_3_8:1.90.0.2
	OPENBSD_3_8_BASE:1.90
	OPENBSD_3_7:1.87.0.2
	OPENBSD_3_7_BASE:1.87
	OPENBSD_3_6:1.41.0.2
	OPENBSD_3_6_BASE:1.41
	OPENBSD_3_5:1.23.0.2
	OPENBSD_3_5_BASE:1.23
	pkgtools:1.1.1.1
	espie:1.1.1;
locks; strict;
comment	@# @;


1.135
date	2010.06.04.13.19.39;	author espie;	state dead;
branches;
next	1.134;

1.134
date	2010.05.10.09.17.55;	author espie;	state Exp;
branches;
next	1.133;

1.133
date	2010.01.10.21.27.59;	author espie;	state Exp;
branches;
next	1.132;

1.132
date	2009.12.21.11.03.00;	author espie;	state Exp;
branches;
next	1.131;

1.131
date	2009.12.21.10.38.58;	author espie;	state Exp;
branches;
next	1.130;

1.130
date	2009.12.20.22.38.45;	author espie;	state Exp;
branches;
next	1.129;

1.129
date	2009.12.19.14.21.14;	author espie;	state Exp;
branches;
next	1.128;

1.128
date	2009.11.28.10.05.58;	author espie;	state Exp;
branches;
next	1.127;

1.127
date	2009.11.28.10.01.50;	author espie;	state Exp;
branches;
next	1.126;

1.126
date	2009.11.28.09.36.32;	author espie;	state Exp;
branches;
next	1.125;

1.125
date	2009.11.17.10.17.21;	author espie;	state Exp;
branches;
next	1.124;

1.124
date	2009.11.16.23.02.36;	author espie;	state Exp;
branches;
next	1.123;

1.123
date	2009.11.16.12.53.27;	author espie;	state Exp;
branches;
next	1.122;

1.122
date	2009.11.16.12.32.16;	author espie;	state Exp;
branches;
next	1.121;

1.121
date	2009.11.16.12.20.32;	author espie;	state Exp;
branches;
next	1.120;

1.120
date	2009.11.14.10.47.17;	author espie;	state Exp;
branches;
next	1.119;

1.119
date	2009.11.11.12.21.20;	author espie;	state Exp;
branches;
next	1.118;

1.118
date	2009.11.11.12.04.18;	author espie;	state Exp;
branches;
next	1.117;

1.117
date	2009.11.11.11.13.16;	author espie;	state Exp;
branches;
next	1.116;

1.116
date	2009.11.10.11.36.56;	author espie;	state Exp;
branches;
next	1.115;

1.115
date	2009.11.10.11.13.59;	author espie;	state Exp;
branches;
next	1.114;

1.114
date	2009.11.03.09.57.27;	author espie;	state Exp;
branches;
next	1.113;

1.113
date	2008.03.08.12.07.45;	author espie;	state Exp;
branches;
next	1.112;

1.112
date	2008.03.08.11.32.38;	author espie;	state Exp;
branches;
next	1.111;

1.111
date	2007.12.18.10.58.46;	author espie;	state Exp;
branches;
next	1.110;

1.110
date	2007.06.30.11.38.38;	author espie;	state Exp;
branches;
next	1.109;

1.109
date	2007.06.16.09.29.37;	author espie;	state Exp;
branches;
next	1.108;

1.108
date	2007.06.04.14.57.33;	author espie;	state Exp;
branches;
next	1.107;

1.107
date	2007.06.04.14.40.39;	author espie;	state Exp;
branches;
next	1.106;

1.106
date	2007.06.01.14.58.29;	author espie;	state Exp;
branches;
next	1.105;

1.105
date	2007.05.31.13.33.17;	author espie;	state Exp;
branches;
next	1.104;

1.104
date	2007.05.30.15.10.07;	author espie;	state Exp;
branches;
next	1.103;

1.103
date	2007.05.22.10.47.40;	author espie;	state Exp;
branches;
next	1.102;

1.102
date	2007.05.22.10.11.59;	author espie;	state Exp;
branches;
next	1.101;

1.101
date	2007.05.20.14.21.33;	author espie;	state Exp;
branches;
next	1.100;

1.100
date	2007.05.20.14.04.39;	author espie;	state Exp;
branches;
next	1.99;

1.99
date	2007.05.20.13.54.30;	author espie;	state Exp;
branches;
next	1.98;

1.98
date	2007.05.14.09.49.27;	author espie;	state Exp;
branches;
next	1.97;

1.97
date	2007.05.01.18.22.20;	author espie;	state Exp;
branches;
next	1.96;

1.96
date	2007.04.15.10.17.29;	author espie;	state Exp;
branches;
next	1.95;

1.95
date	2007.02.22.21.31.41;	author espie;	state Exp;
branches;
next	1.94;

1.94
date	2006.08.01.10.23.38;	author bernd;	state Exp;
branches;
next	1.93;

1.93
date	2005.09.07.14.01.59;	author jmc;	state Exp;
branches;
next	1.92;

1.92
date	2005.09.07.09.24.19;	author jmc;	state Exp;
branches;
next	1.91;

1.91
date	2005.09.04.22.47.56;	author espie;	state Exp;
branches;
next	1.90;

1.90
date	2005.08.17.18.44.24;	author espie;	state Exp;
branches;
next	1.89;

1.89
date	2005.08.17.18.37.10;	author espie;	state Exp;
branches;
next	1.88;

1.88
date	2005.08.17.09.24.53;	author espie;	state Exp;
branches;
next	1.87;

1.87
date	2005.01.22.13.00.35;	author espie;	state Exp;
branches;
next	1.86;

1.86
date	2005.01.14.02.25.12;	author espie;	state Exp;
branches;
next	1.85;

1.85
date	2005.01.03.01.02.45;	author espie;	state Exp;
branches;
next	1.84;

1.84
date	2004.12.27.22.54.25;	author espie;	state Exp;
branches;
next	1.83;

1.83
date	2004.12.27.22.44.29;	author espie;	state Exp;
branches;
next	1.82;

1.82
date	2004.12.15.01.07.10;	author espie;	state Exp;
branches;
next	1.81;

1.81
date	2004.12.12.11.26.16;	author espie;	state Exp;
branches;
next	1.80;

1.80
date	2004.12.06.12.35.36;	author espie;	state Exp;
branches;
next	1.79;

1.79
date	2004.11.15.11.39.05;	author espie;	state Exp;
branches;
next	1.78;

1.78
date	2004.11.14.13.20.07;	author espie;	state Exp;
branches;
next	1.77;

1.77
date	2004.11.14.11.58.43;	author espie;	state Exp;
branches;
next	1.76;

1.76
date	2004.11.14.11.40.08;	author espie;	state Exp;
branches;
next	1.75;

1.75
date	2004.11.11.16.28.57;	author espie;	state Exp;
branches;
next	1.74;

1.74
date	2004.11.11.12.29.20;	author espie;	state Exp;
branches;
next	1.73;

1.73
date	2004.11.11.11.36.26;	author espie;	state Exp;
branches;
next	1.72;

1.72
date	2004.11.11.11.23.04;	author espie;	state Exp;
branches;
next	1.71;

1.71
date	2004.11.11.11.16.39;	author espie;	state Exp;
branches;
next	1.70;

1.70
date	2004.11.11.10.47.26;	author espie;	state Exp;
branches;
next	1.69;

1.69
date	2004.11.09.11.11.01;	author espie;	state Exp;
branches;
next	1.68;

1.68
date	2004.11.07.11.39.10;	author espie;	state Exp;
branches;
next	1.67;

1.67
date	2004.10.31.11.33.50;	author espie;	state Exp;
branches;
next	1.66;

1.66
date	2004.10.31.10.26.17;	author espie;	state Exp;
branches;
next	1.65;

1.65
date	2004.10.31.09.06.04;	author espie;	state Exp;
branches;
next	1.64;

1.64
date	2004.10.26.17.37.04;	author espie;	state Exp;
branches;
next	1.63;

1.63
date	2004.10.26.17.23.15;	author espie;	state Exp;
branches;
next	1.62;

1.62
date	2004.10.23.09.27.48;	author espie;	state Exp;
branches;
next	1.61;

1.61
date	2004.10.20.11.38.57;	author espie;	state Exp;
branches;
next	1.60;

1.60
date	2004.10.19.09.43.40;	author espie;	state Exp;
branches;
next	1.59;

1.59
date	2004.10.18.12.03.19;	author espie;	state Exp;
branches;
next	1.58;

1.58
date	2004.10.18.10.51.03;	author espie;	state Exp;
branches;
next	1.57;

1.57
date	2004.10.17.09.32.21;	author espie;	state Exp;
branches;
next	1.56;

1.56
date	2004.10.11.14.40.04;	author espie;	state Exp;
branches;
next	1.55;

1.55
date	2004.10.11.14.35.08;	author espie;	state Exp;
branches;
next	1.54;

1.54
date	2004.10.11.13.46.17;	author espie;	state Exp;
branches;
next	1.53;

1.53
date	2004.10.11.13.29.05;	author espie;	state Exp;
branches;
next	1.52;

1.52
date	2004.10.11.13.10.25;	author espie;	state Exp;
branches;
next	1.51;

1.51
date	2004.10.11.12.31.02;	author espie;	state Exp;
branches;
next	1.50;

1.50
date	2004.10.11.11.48.18;	author espie;	state Exp;
branches;
next	1.49;

1.49
date	2004.10.11.10.30.33;	author espie;	state Exp;
branches;
next	1.48;

1.48
date	2004.09.24.09.06.50;	author espie;	state Exp;
branches;
next	1.47;

1.47
date	2004.09.24.08.49.27;	author espie;	state Exp;
branches;
next	1.46;

1.46
date	2004.09.21.09.44.09;	author espie;	state Exp;
branches;
next	1.45;

1.45
date	2004.09.21.09.42.33;	author espie;	state Exp;
branches;
next	1.44;

1.44
date	2004.09.20.07.31.42;	author espie;	state Exp;
branches;
next	1.43;

1.43
date	2004.09.18.09.27.05;	author espie;	state Exp;
branches;
next	1.42;

1.42
date	2004.09.14.22.58.30;	author espie;	state Exp;
branches;
next	1.41;

1.41
date	2004.08.11.09.28.26;	author espie;	state Exp;
branches;
next	1.40;

1.40
date	2004.08.10.12.05.52;	author espie;	state Exp;
branches;
next	1.39;

1.39
date	2004.08.10.11.53.27;	author espie;	state Exp;
branches;
next	1.38;

1.38
date	2004.08.09.01.40.57;	author espie;	state Exp;
branches;
next	1.37;

1.37
date	2004.08.07.17.27.26;	author espie;	state Exp;
branches;
next	1.36;

1.36
date	2004.08.06.14.33.02;	author espie;	state Exp;
branches;
next	1.35;

1.35
date	2004.08.06.12.21.11;	author espie;	state Exp;
branches;
next	1.34;

1.34
date	2004.08.06.10.23.45;	author espie;	state Exp;
branches;
next	1.33;

1.33
date	2004.08.06.07.51.17;	author espie;	state Exp;
branches;
next	1.32;

1.32
date	2004.08.06.07.37.34;	author espie;	state Exp;
branches;
next	1.31;

1.31
date	2004.08.06.07.05.16;	author espie;	state Exp;
branches;
next	1.30;

1.30
date	2004.08.05.23.36.39;	author espie;	state Exp;
branches;
next	1.29;

1.29
date	2004.08.03.12.29.45;	author espie;	state Exp;
branches;
next	1.28;

1.28
date	2004.08.02.12.12.36;	author espie;	state Exp;
branches;
next	1.27;

1.27
date	2004.07.20.18.58.41;	author espie;	state Exp;
branches;
next	1.26;

1.26
date	2004.07.18.12.00.21;	author espie;	state Exp;
branches;
next	1.25;

1.25
date	2004.07.14.10.44.03;	author espie;	state Exp;
branches;
next	1.24;

1.24
date	2004.06.21.16.33.45;	author espie;	state Exp;
branches;
next	1.23;

1.23
date	2004.02.25.21.56.12;	author espie;	state Exp;
branches;
next	1.22;

1.22
date	2004.01.28.22.12.01;	author espie;	state Exp;
branches;
next	1.21;

1.21
date	2004.01.27.15.34.31;	author espie;	state Exp;
branches;
next	1.20;

1.20
date	2004.01.27.14.50.52;	author espie;	state Exp;
branches;
next	1.19;

1.19
date	2004.01.27.13.09.16;	author espie;	state Exp;
branches;
next	1.18;

1.18
date	2004.01.27.00.13.04;	author espie;	state Exp;
branches;
next	1.17;

1.17
date	2004.01.27.00.08.31;	author espie;	state Exp;
branches;
next	1.16;

1.16
date	2003.12.21.18.41.23;	author espie;	state Exp;
branches;
next	1.15;

1.15
date	2003.12.10.11.43.52;	author espie;	state Exp;
branches;
next	1.14;

1.14
date	2003.12.10.11.12.22;	author espie;	state Exp;
branches;
next	1.13;

1.13
date	2003.12.09.19.22.36;	author espie;	state Exp;
branches;
next	1.12;

1.12
date	2003.11.09.15.42.48;	author espie;	state Exp;
branches;
next	1.11;

1.11
date	2003.11.06.18.42.01;	author espie;	state Exp;
branches;
next	1.10;

1.10
date	2003.11.06.17.49.31;	author espie;	state Exp;
branches;
next	1.9;

1.9
date	2003.11.04.17.55.17;	author espie;	state Exp;
branches;
next	1.8;

1.8
date	2003.11.03.11.05.55;	author espie;	state Exp;
branches;
next	1.7;

1.7
date	2003.11.03.11.04.21;	author espie;	state Exp;
branches;
next	1.6;

1.6
date	2003.10.28.17.26.01;	author espie;	state Exp;
branches;
next	1.5;

1.5
date	2003.10.27.22.46.23;	author espie;	state Exp;
branches;
next	1.4;

1.4
date	2003.10.23.23.11.22;	author espie;	state Exp;
branches;
next	1.3;

1.3
date	2003.10.23.17.48.07;	author espie;	state Exp;
branches;
next	1.2;

1.2
date	2003.10.19.18.42.55;	author espie;	state Exp;
branches;
next	1.1;

1.1
date	2003.10.16.17.43.34;	author espie;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2003.10.16.17.43.34;	author espie;	state Exp;
branches;
next	;


desc
@@


1.135
log
@move code around, so that commands can be used as modules.
pkg becomes the start hub, which does nothing except require the
correct module.
Saner code wrt Add/Delete, and more sharing.
@
text
@#!/usr/bin/perl
# ex:ts=8 sw=4:
# $OpenBSD: pkg_delete,v 1.134 2010/05/10 09:17:55 espie Exp $
#
# Copyright (c) 2003-2010 Marc Espie <espie@@openbsd.org>
#
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

use strict;
use warnings;

use OpenBSD::AddDelete;

package OpenBSD::State;
our @@ISA=(qw(OpenBSD::UI));

sub todo
{
	my $state = shift;
	return $state->{todo};
}

package OpenBSD::AddDelete;
our ($state, %defines, $bad, $opt_B);

use OpenBSD::PackingList;
use OpenBSD::RequiredBy;
use OpenBSD::Delete;
use OpenBSD::PackageInfo;
use OpenBSD::UpdateSet;

handle_options('chxDnq', {},
    'pkg_delete [-cIinqsvx] [-B pkg-destdir] [-D name[=value]] pkg-name [...]');

local $SIG{'INFO'} = sub { $state->status->print($state); };
$opt_B = $ENV{'PKG_DESTDIR'} unless defined $opt_B;
$opt_B = '' unless defined $opt_B;
if ($opt_B ne '') {
	$opt_B.='/' unless $opt_B =~ m/\/$/o;
}
$ENV{'PKG_DESTDIR'} = $opt_B;

$state->{destdir} = $opt_B;
if ($opt_B eq '') {
    $state->{destdirname} = '';
} else {
    $state->{destdirname} = '${PKG_DESTDIR}';
}

$ENV{'PKG_DELETE_EXTRA'} = $state->{extra} ? "Yes" : "No";


my %done;
my $removed;

# Resolve pkg names
my @@realnames;
my @@todo;

sub process_parameters
{
	OpenBSD::PackageInfo::solve_installed_names(\@@ARGV, \@@realnames,
	    "(removing them all)", $state);

	@@todo = OpenBSD::RequiredBy->compute_closure(@@realnames);

	if (@@todo > @@realnames) {
		my $details = $state->verbose >= 2 || $defines{verbosedeps};
		my $show    = sub {
			my ($p, $d) = @@_;
			$state->say("Can't remove ", join(' ', @@$p),
			    " without also removing:\n",
			    join(' ', @@$d));
		};
		if ($state->{interactive} || !$details) {
			my %deps = map {($_, 1)} @@todo;
			for my $p (@@realnames) {
				delete $deps{$p};
			}
			&$show([@@realnames], [keys %deps]);
			if (@@realnames > 1 && (keys %deps) > 1 &&
			    $state->confirm("Do you want details", 1)) {
				$details = 1;
			}
		}
		if ($details) {
			for my $pkg (@@realnames) {
				my @@deps = OpenBSD::RequiredBy->compute_closure($pkg);
				next unless @@deps > 1;
				@@deps = grep {$_ ne $pkg} @@deps;
				&$show([$pkg], [@@deps]);
			}
		}
		my $them = @@todo > 1 ? 'them' : 'it';
		if ($defines{dependencies} or
		    $state->confirm("Do you want to remove $them as well", 0)) {
			$state->say("(removing $them as well)");
		} else {
			$bad = 1;
		}
	}
}

sub finish_display
{
}

framework(
sub {
	# and finally, handle the removal
	do {
		$removed = 0;
		if ($state->{not}) {
			$state->status->what("Pretending to delete");
		} else {
			$state->status->what("Deleting");
		}
		DELETE: for my $pkgname (@@todo) {
			$state->{todo} = scalar @@todo - scalar keys %done;
			next if $done{$pkgname};
			unless (is_installed($pkgname)) {
				$state->errsay("$pkgname was not installed");
				$done{$pkgname} = 1;
				$removed++;
				next;
			}
			my $r = OpenBSD::RequiredBy->new($pkgname);
			if ($r->list > 0) {
				if ($defines{baddepend}) {
					for my $p ($r->list) {
						if ($done{$p}) {
							$r->delete($p);
						} else {
							next DELETE;
						}
					}
				} else {
					next;
				}
			}
			my $info = sub {
			};

			$state->status->object($pkgname);
			if (!$state->progress->set_header($pkgname)) {
				$state->say($state->{not} ?
				    "Pretending to delete " :
				    "Deleting ",
				    $pkgname) if $state->verbose;
			}
			$state->log->set_context('-'.$pkgname);
			OpenBSD::Delete::delete_package($pkgname, $state);
			$done{$pkgname} = 1;
			$removed++;
		}
	} while ($removed);
});
@


1.134
log
@whitespace fixes
@
text
@d3 1
a3 1
# $OpenBSD$
@


1.133
log
@unify options a bit: use -Dname=value for defines uniformously (e.g., deprecate
-F keyword heavily).
@
text
@d72 1
a72 1
	OpenBSD::PackageInfo::solve_installed_names(\@@ARGV, \@@realnames, 
d81 1
a81 1
			$state->say("Can't remove ", join(' ', @@$p), 
d91 1
a91 1
			if (@@realnames > 1 && (keys %deps) > 1 && 
d105 1
a105 1
		if ($defines{dependencies} or 
d156 3
a158 3
				$state->say($state->{not} ? 
				    "Pretending to delete " : 
				    "Deleting ", 
@


1.132
log
@document recent changes, clean up old pkg_delete options
@
text
@d5 1
a5 1
# Copyright (c) 2003-2007 Marc Espie <espie@@openbsd.org>
d43 1
a43 1
    'pkg_delete [-cIinqsvx] [-B pkg-destdir] [-F keywords] pkg-name [...]');
@


1.131
log
@much simpler SIG{INFO} handling: create a status object in state and
update it when needed. Install a SIG{INFO} handler at start that will do
what's needed.
@
text
@d42 2
a43 4
our ($opt_d, $opt_p, $opt_i);

handle_options('chixDdnqpS:', {},
    'pkg_delete [-cIinqvx] [-B pkg-destdir] [-F keywords] pkg-name [...]');
a51 7

if (defined $opt_p) {
	Usage "Option p is obsolete";
}
if (defined $opt_d) {
	Usage "Option d is obsolete";
}
@


1.130
log
@change verbosity handling: be silent by default, turn on the first level if -v.
Add more levels, specifically, lots of info regarding individual files only
visible if -vvvvv.
Make -n display the same stuff as normal (need -n -v to display more stuff).
Introduce -s, "size-only", turns on -n and does skip any extraction.
Sprinkle handlers for SIG_INFO, not really nice yet.

Note that -n is non functional for complex updates, because of caching
issues I have to fix.
@
text
@d47 1
d132 5
d161 4
d168 1
a168 6
				    $pkgname);
			};

			local $SIG{'INFO'} = $info;
			if (!$state->progress->set_header($pkgname)) {
				&$info if $state->verbose;
d170 1
a170 1
			$state->log->set_context($pkgname);
@


1.129
log
@create a $state->todo method to account for sets to install.
have tracker keep track of sets not done, and ask it directly for how many
there's still to do. Provide an offset into next for cases where we know
we already did a set but haven't accounted for it yet.
-> more accurate number of sets still to do.
@
text
@d86 1
a86 1
		my $details = $state->{very_verbose} || $defines{verbosedeps};
d135 1
a135 1
				$state->say("$pkgname was not installed");
d154 8
d163 1
a163 3
				print $state->{not} ? "Pretending to delete " : 
				    "Deleting ", 
				    "$pkgname\n";
@


1.128
log
@still not right, so revert to original algorithm, and compute @@todo
in a more expensive way...
@
text
@d27 6
@


1.127
log
@oops, if I want to modify @@todo, I should do it right.
@
text
@d125 2
a126 2
		DELETE: while (my $pkgname = shift @@todo) {
			$state->{todo} = scalar @@todo;
a135 1
				push(@@todo, $pkgname);
@


1.126
log
@add (n to go) to pkg_delete as well.
@
text
@d125 1
a125 1
		DELETE: while (my $pkgname = pop @@todo) {
d136 1
@


1.125
log
@revamp interactive stuff: simplify (just one always for everything, per
theo suggestion. Also go through the "state" object which simplifies code
a great deal)
@
text
@d125 2
a126 1
		DELETE: for my $pkgname (@@todo) {
@


1.124
log
@-Vstat (get it from AddDelete)
@
text
@a31 1
use OpenBSD::Interactive;
d94 1
a94 2
			    OpenBSD::Interactive::confirm(
			    "Do you want details", $state->{interactive}, 1)) {
d108 1
a108 1
		    OpenBSD::Interactive::confirm("Do you want to remove $them as well", $state->{interactive}, 0)) {
@


1.123
log
@pull more common code in a "framework" routine.
@
text
@a34 1
use OpenBSD::Vstat;
@


1.122
log
@identical end sequence, to be factorized
@
text
@d24 1
a24 1
package OpenBSD::pkg_delete::State;
a37 2
set_usage('pkg_delete [-cIinqvx] [-B pkg-destdir] [-F keywords] pkg-name [...]');
$state = OpenBSD::pkg_delete::State->new;
d40 2
a41 1
handle_options('chixDdnqpS:');
a56 3
my %done;
my $removed;

a65 2
try {
setup_state();
d67 2
a68 1
# First, resolve pkg names
d70 1
d72 1
d74 26
a99 17
OpenBSD::PackageInfo::solve_installed_names(\@@ARGV, \@@realnames, 
    "(removing them all)", $state);

my @@todo = OpenBSD::RequiredBy->compute_closure(@@realnames);

if (@@todo > @@realnames) {
	my $details = $state->{very_verbose} || $defines{verbosedeps};
	my $show    = sub {
		my ($p, $d) = @@_;
		$state->say("Can't remove ", join(' ', @@$p), 
		    " without also removing:\n",
		    join(' ', @@$d));
	};
	if ($state->{interactive} || !$details) {
		my %deps = map {($_, 1)} @@todo;
		for my $p (@@realnames) {
			delete $deps{$p};
d101 7
a107 5
		&$show([@@realnames], [keys %deps]);
		if (@@realnames > 1 && (keys %deps) > 1 && 
		    OpenBSD::Interactive::confirm(
		    "Do you want details", $state->{interactive}, 1)) {
			$details = 1;
d109 6
a114 7
	}
	if ($details) {
		for my $pkg (@@realnames) {
			my @@deps = OpenBSD::RequiredBy->compute_closure($pkg);
			next unless @@deps > 1;
			@@deps = grep {$_ ne $pkg} @@deps;
			&$show([$pkg], [@@deps]);
a116 7
	my $them = @@todo > 1 ? 'them' : 'it';
	if ($defines{dependencies} or 
	    OpenBSD::Interactive::confirm("Do you want to remove $them as well", $state->{interactive}, 0)) {
		$state->say("(removing $them as well)");
	} else {
		$bad = 1;
	}
d119 5
a123 1
my $dielater = do_the_main_work(
a161 14

rethrow $dielater;
} catch {
	print STDERR "$0: $_\n";
	if ($_ =~ m/^Caught SIG(\w+)/o) {
		kill $1, $$;
	}
	exit(1);
};

if ($bad) {
	exit(1);
}

@


1.121
log
@start pulling all the code that's the same between pkg_add and pkg_delete
into a common AddDelete package... lots of identical options and handling,
actually...
@
text
@d162 3
d167 5
@


1.120
log
@pull the eval {} code into an anonymous sub, so that we can choose to exec
it without the eval (useful for backtraces when I want bug-reports,
since eval {} will show you the backtrace of the eval, not of the
function call)
@
text
@d22 8
a29 1
use OpenBSD::Getopt;
a31 1
use OpenBSD::Error;
a35 1
use OpenBSD::Paths;
a37 8
our %defines = ();
our $not;

package OpenBSD::pkg_delete::State;
our @@ISA=(qw(OpenBSD::pkg_foo::State));

package main;

d39 2
a40 1
our ($opt_v, $opt_D, $opt_d, $opt_n, $opt_q, $opt_p, $opt_c, $opt_L, $opt_B, $opt_I, $opt_i, $opt_x);
d42 1
a42 1
$opt_v = 0;
a43 21
try { 
	getopts('vchixDdnf:F:qpS:L:B:I',
	    {
	     'h' => sub { Usage(); },
	     'F' => sub { 
			    for my $o (split /\,/o, shift) { 
				    $defines{$o} = 1;
			    }
		    },
	     'f' => sub { 
			    for my $o (split /\,/o, shift) { 
				    $defines{$o} = 1;
			    }
	    	}}); 
} catchall {
	Usage($_);
};

if ($opt_D) {
	$opt_I = 1;
}
a50 2
$opt_L = OpenBSD::Paths->localbase unless defined $opt_L;

a60 13
try {
my $state = OpenBSD::pkg_delete::State->new;
$state->{recorder} = OpenBSD::SharedItemsRecorder->new;
$state->{not} = $opt_n;
# XXX RequiredBy
$not = $opt_n;
$state->{quick} = $opt_q;
$state->{very_verbose} = $opt_v >=2;
$state->{verbose} = $opt_v;
$state->{beverbose} = $opt_n || ($opt_v >= 2);
$state->{extra} = $opt_c;
$state->{dont_run_scripts} = $opt_I;
$state->{defines} = \%defines;
a61 1
$state->{interactive} = $opt_i;
d70 2
a71 3
lock_db($opt_n) unless $state->{defines}->{nolock};
$state->setup_progressmeter($opt_x);
$state->check_root;
a75 1
my $bad;
d119 2
a120 12
if ($bad) {
	exit(1);
}

my $handler = sub { my $sig = shift; die "Caught SIG$sig"; };
local $SIG{'INT'} = $handler;
local $SIG{'QUIT'} = $handler;
local $SIG{'HUP'} = $handler;
local $SIG{'KILL'} = $handler;
local $SIG{'TERM'} = $handler;

my $code = sub {
d147 1
a147 1
				print $opt_n ? "Pretending to delete " : 
d157 1
a157 7
};
if ($state->{defines}->{debug}) {
	&$code;
} else { 
	eval { &$code; };
}
my $dielater = $@@;
a158 9
$state->{recorder}->cleanup($state);
OpenBSD::PackingElement::Lib::ensure_ldconfig($state);
OpenBSD::PackingElement::Fontdir::finish_fontdirs($state);

if ($state->{beverbose}) {
	OpenBSD::Vstat::tally();
}
$state->progress->clear;
$state->log->dump;
@


1.119
log
@also get most STDERR messages through the same way
@
text
@d171 21
a191 20
eval {
# and finally, handle the removal
{ do {
	$removed = 0;
	DELETE: for my $pkgname (@@todo) {
		next if $done{$pkgname};
		unless (is_installed($pkgname)) {
			$state->say("$pkgname was not installed");
			$done{$pkgname} = 1;
			$removed++;
			next;
		}
		my $r = OpenBSD::RequiredBy->new($pkgname);
		if ($r->list > 0) {
			if ($defines{baddepend}) {
				for my $p ($r->list) {
					if ($done{$p}) {
						$r->delete($p);
					} else {
						next DELETE;
d193 2
a195 2
			} else {
				next;
d197 9
d207 7
a213 11
		if (!$state->progress->set_header($pkgname)) {
			print $opt_n ? "Pretending to delete " : "Deleting ", 
			    "$pkgname\n";
		}
		$state->log->set_context($pkgname);
		OpenBSD::Delete::delete_package($pkgname, $state);
		$done{$pkgname} = 1;
		$removed++;
	}
} while ($removed); } };

@


1.118
log
@progressmeter puts STDOUT in autoflush if -t, so that it can display to it instead of piping a lot of stuff to STDERR.

Go through state->print for most messages, so they will NOT do weird things
with the progressmeter.
Use a ->say shortcut which does the same thing that perl 5.10 say does...
@
text
@d217 1
@


1.117
log
@remove forwarders, and provide a sensible API that says what's going on
(e.g., we're logging information for later).
@
text
@d127 3
a129 2
		print "Can't remove ".join(' ', @@$p)." without also removing:\n"
		    .join(' ', @@$d)."\n";
d154 1
a154 1
		print "(removing $them as well)\n";
d178 1
a178 1
			print "$pkgname was not installed\n";
@


1.116
log
@bad espie: use strict/warnings consistently, and fix two nits and two
actual errors !
@
text
@d200 1
a200 1
		$state->set_pkgname($pkgname);
d216 1
a216 1
$state->delayed_output;
@


1.115
log
@proposing details when we remove one single package is ridiculous
@
text
@d21 1
@


1.114
log
@catch signals while we're doing something, so that cleanup always happens.
@
text
@d135 2
a136 1
		if ((keys %deps) > 1 && OpenBSD::Interactive::confirm(
@


1.113
log
@rename forced to defines
@
text
@d161 7
@


1.112
log
@let GetOpt count how many times it sees an option, removes special case
for -v, and allow other fun possibilities.
@
text
@d32 1
a32 1
our %forced = ();
d51 1
a51 1
				    $forced{$o} = 1;
d56 1
a56 1
				    $forced{$o} = 1;
d97 1
a97 1
$state->{forced} = \%forced;
d108 1
a108 1
lock_db($opt_n) unless $state->{forced}->{nolock};
d123 1
a123 1
	my $details = $state->{very_verbose} || $forced{verbosedeps};
d149 1
a149 1
	if ($forced{dependencies} or 
d175 1
a175 1
			if ($forced{baddepend}) {
@


1.111
log
@make it possible to run without locking the database. To be used by
SRC: url, which require it.
@
text
@d3 1
a3 1
# $OpenBSD: pkg_delete,v 1.110 2007/06/30 11:38:38 espie Exp $
d47 1
a47 1
	    {'v' => sub {++$opt_v;},
@


1.110
log
@move the UpdateSet stuff into its separate file, leaving Vstat much cleaner.
@
text
@d3 1
a3 1
# $OpenBSD: pkg_delete,v 1.109 2007/06/16 09:29:37 espie Exp $
d108 1
a108 1
lock_db($opt_n);
@


1.109
log
@use OpenBSD::Paths contents
@
text
@d3 1
a3 1
# $OpenBSD: pkg_delete,v 1.108 2007/06/04 14:57:33 espie Exp $
d30 1
a30 1
# use OpenBSD::UpdateSet;
@


1.108
log
@I am on drugs, I don't know where I found split can take strings as
arguments. Repair...
@
text
@d3 1
a3 1
# $OpenBSD: pkg_delete,v 1.107 2007/06/04 14:40:39 espie Exp $
d29 1
d73 1
a73 1
$opt_L = '/usr/local' unless defined $opt_L;
@


1.107
log
@some minor systematic changes.
- mark all regexps I can with /o if they can be compiled once.
- turn $o->method() into $o->method
- remove unneeded prototypes
- reduce split /re/ into split "string" where possible.
@
text
@d3 1
a3 1
# $OpenBSD: pkg_delete,v 1.106 2007/06/01 14:58:29 espie Exp $
d49 1
a49 1
			    for my $o (split ',', shift) { 
d54 1
a54 1
			    for my $o (split ',', shift) { 
@


1.106
log
@refactor ProgressMeter code to create objects, put these into state.
Create a common state class for delete and add, put the progressmeter
creation in there.

neat effect: we don't have a progressmeter, we use a stub class instead
and *never* pull the code in at all.
@
text
@d3 1
a3 1
# $OpenBSD: pkg_delete,v 1.105 2007/05/31 13:33:17 espie Exp $
d49 1
a49 1
			    for my $o (split/,/, shift) { 
d54 1
a54 1
			    for my $o (split/,/, shift) { 
d68 1
a68 1
	$opt_B.='/' unless $opt_B =~ m/\/$/;
d206 1
a206 1
$state->delayed_output();
@


1.105
log
@move set validation earlier (in fact, it probably doesn't belong in
really_add).

move common delete_installed() code inside Delete.pm
@
text
@d3 1
a3 1
# $OpenBSD: pkg_delete,v 1.104 2007/05/30 15:10:07 espie Exp $
a24 1
use OpenBSD::ProgressMeter;
d35 1
a35 1
our @@ISA=(qw(OpenBSD::Error));
d108 2
a109 11
if (!$opt_x && !$state->{beverbose}) {
	OpenBSD::ProgressMeter::enable();
}

if ($< && !$forced{nonroot}) {
	if ($state->{not}) {
		Warn "$0 should be run as root\n";
	} else {
		Fatal "$0 must be run as root";
	}
}
d186 1
a186 1
		if (!OpenBSD::ProgressMeter::set_header($pkgname)) {
@


1.104
log
@fix verbosity.
@
text
@d3 1
a3 1
# $OpenBSD: pkg_delete,v 1.103 2007/05/22 10:47:40 espie Exp $
a201 1
		delete_installed($pkgname);
@


1.103
log
@cleanup shared state a bit earlier. Shouldn't change much, but may help
ensuring we don't reload fontdirs twice with weird fontdirs case.
@
text
@d3 1
a3 1
# $OpenBSD: pkg_delete,v 1.102 2007/05/22 10:11:59 espie Exp $
d92 2
a93 2
$state->{verbose} = $opt_v >= 2;
$state->{very_verbose} = $opt_v;
@


1.102
log
@introduce a SharedItemsRecorder (put it into Vstat, since that's a file
common to Add and Delete, for now).

Use it to have common code that records items to remove / items remaining.

Stash it into pkg_add/pkg_delete state, and abstract the cleaning up
operation into the SharedItemsRecorder (so that pkg_add and pkg_delete no
longer have to know about the internals of SharedItems at all).
@
text
@d3 1
a3 1
# $OpenBSD: pkg_delete,v 1.101 2007/05/20 14:21:33 espie Exp $
d210 1
a211 3
# delayed directory/user/group removal
$state->{recorder}->cleanup($state);

@


1.101
log
@create specific `state' objects for pkg_add and pkg_delete, so that I can
write shortcuts for common behavior, and start hiding some details.
@
text
@d3 1
a3 1
# $OpenBSD: pkg_delete,v 1.100 2007/05/20 14:04:39 espie Exp $
d87 1
d212 1
a212 6
if (defined $state->{dirs_to_rm} or defined $state->{users_to_rm} or
	defined $state->{groups_to_rm}) {
	require OpenBSD::SharedItems;

	OpenBSD::SharedItems::cleanup($state) unless $state->{not};
}
@


1.100
log
@placeholders for UpdateSet, once we have it.
@
text
@d3 1
a3 1
# $OpenBSD: pkg_delete,v 1.99 2007/05/20 13:54:30 espie Exp $
d35 5
d86 1
a86 1
my $state = new OpenBSD::Error;
@


1.99
log
@both pkg_add and pkg_delete use Vstat, make it explicit.
@
text
@d3 1
a3 1
# $OpenBSD: pkg_delete,v 1.98 2007/05/14 09:49:27 espie Exp $
d30 1
@


1.98
log
@tidy
@
text
@d3 1
a3 1
# $OpenBSD: pkg_delete,v 1.97 2007/05/01 18:22:20 espie Exp $
d29 1
@


1.97
log
@move the old elements into PackingElements, since the code is now
much shorter.
@
text
@d3 1
a3 1
# $OpenBSD: pkg_delete,v 1.96 2007/04/15 10:17:29 espie Exp $
d175 1
a175 1
		if ($r->list() > 0) {
d177 1
a177 1
				for my $p ($r->list()) {
@


1.96
log
@update copyright years, standardize licence.
reword the introduction to the stuff originally from FreeBSD to clarify
slightly.
@
text
@d3 1
a3 1
# $OpenBSD: pkg_delete,v 1.95 2007/02/22 21:31:41 espie Exp $
a22 1
use OpenBSD::PackingOld;
@


1.95
log
@Problem noticed by Henrik Hellerstedt <henrik@@kohina.net>

Fix a really fun bug in pkg_delete: solve_installed_names has to
normalize the list of names so that comparing its size vs. its
transitive closure is meaningful. Use the classical hash + list to
preserve the order. While we're there, use the hash to avoid asking
the same questions again and again.

After some back&forth with bernd. okay bernd@@
@
text
@d3 1
a3 1
# $OpenBSD: pkg_delete,v 1.94 2006/08/01 10:23:38 bernd Exp $
d5 1
a5 1
# Copyright (c) 2003-2004 Marc Espie <espie@@openbsd.org>
@


1.94
log
@If pkg_delete is trying to remove more than one package at the same time and
is finding some dependency problems, explain which package depend on what.
(with -v, -i or '-F verbosedeps')

idea & ok espie@@
@
text
@d3 1
a3 1
# $OpenBSD: pkg_delete,v 1.93 2005/09/07 14:01:59 jmc Exp $
d136 1
a136 1
		&$show([@@ARGV], [keys %deps]);
@


1.93
log
@use `pkg-name' rather than `pkgname' here, for consistency with other
pkg_* bits;

ok espie@@
@
text
@d3 1
a3 1
# $OpenBSD: pkg_delete,v 1.92 2005/09/07 09:24:19 jmc Exp $
d125 16
a140 3
	my %extra_rm = map {($_,1)} @@todo;
	for my $p (@@realnames) {
		delete $extra_rm{$p};
d142 9
a150 3
	print "Can't remove ", join(' ', @@ARGV), " without also removing:\n",
	    join(' ', keys(%extra_rm)), "\n";
	my $them = keys(%extra_rm) > 1 ? 'them' : 'it';
a153 1
		push(@@realnames, keys(%extra_rm));
@


1.92
log
@sort options and sync usage();
@
text
@d3 1
a3 1
# $OpenBSD: pkg_delete,v 1.91 2005/09/04 22:47:56 espie Exp $
d34 1
a34 1
set_usage('pkg_delete [-cIinqvx] [-B pkg-destdir] [-F keywords] pkgname [...]');
@


1.91
log
@* New -i interactive option, that can ask obnoxious questions.
* move the signature code to a packing-list method, prepend the pkgname.
* depend on distant listings, cache these systematically.
* cut the PKG_PATH at :/ systematically, much simpler than parsing URLs.
People should get used to trailing /s.
* let pkg_add -u actually run the update.
* check for signature in more places, for instance, let pkg_add installed_stuff
be a void operation.
* grab enough stuff during updates to check signatures, so that pkg_add -u
can report updates that are not needed right away, instead of waiting
for the more confusing `trying to update'
* beginning of @@module support.
* @@pkgpath support, including updates.
* systematically expand stems when applicable.
* use visitors systematically in pkg_info.
* pkg_info -S reports signature.
* remove hardcoding of categories in PackingList, so that future modules
will be able to expand them.
* add @@updateset and @@incompatibility keywords.
@
text
@d3 1
a3 1
# $OpenBSD: pkg_delete,v 1.90 2005/08/17 18:44:24 espie Exp $
d34 1
a34 1
set_usage('pkg_delete [-ciInqvx] [-B pkg-destdir] [-F keywords] pkgname [...]');
@


1.90
log
@reuse compute_closure
@
text
@d3 1
a3 1
# $OpenBSD: pkg_delete,v 1.89 2005/08/17 18:37:10 espie Exp $
d27 1
d34 2
a35 2
set_usage('pkg_delete [-cInqvx] [-B pkg-destdir] [-F keywords] pkgname [...]');
our ($opt_v, $opt_D, $opt_d, $opt_n, $opt_q, $opt_p, $opt_c, $opt_L, $opt_B, $opt_I, $opt_x);
d40 1
a40 1
	getopts('vchxDdnf:F:qpS:L:B:I',
d92 1
d119 2
a120 25
for my $pkgname (@@ARGV) {
    $pkgname =~ s/\.tgz$//;
    if (is_installed($pkgname)) {
	push(@@realnames, installed_name($pkgname));
    } else {
	if (OpenBSD::PackageName::is_stem($pkgname)) {
	    my @@l = OpenBSD::PackageName::findstem($pkgname, 
		installed_packages());
	    if (@@l == 0) {
		print "Can't resolve $pkgname to an installed package name\n";
		$bad = 1 unless $forced{uninstalled};
	    } elsif (@@l == 1) {
		push(@@realnames, $l[0]);
	    } elsif (@@l != 0) {
		print "Ambiguous: $pkgname could be ", join(' ', @@l),"\n";
		if ($forced{ambiguous}) {
		    print "(removing them all)\n";
		    push(@@realnames, @@l);
		} else {
		    $bad = 1;
		}
	    }
	}
    }
}
d131 5
a135 6
	if ($forced{dependencies}) {
		if (keys(%extra_rm) > 1) {
			print "(removing them as well)\n";
		} else {
			print "(removing it as well)\n";
		}
@


1.89
log
@we have a much more accurate image of stuff in -n mode, so we can
ditch this test, pkg_delete -n should no longer loop indefinitely.
@
text
@d3 1
a3 1
# $OpenBSD: pkg_delete,v 1.88 2005/08/17 09:24:53 espie Exp $
d143 1
a143 6
# Then check that dependencies are okay
my (%toremove, %extra_rm);
my @@todo;
for my $pkgname (@@realnames) {
	$toremove{$pkgname} = 1;
}
d145 4
a148 8
push(@@todo, @@realnames);

while (my $pkgname = pop @@todo) {
	for my $dep (OpenBSD::RequiredBy->new($pkgname)->list()) {
		next if defined $toremove{$dep};
		next if defined $extra_rm{$dep};
		$extra_rm{$dep}=$pkgname;
		push(@@todo, $dep);
a149 3
}

if (keys(%extra_rm) != 0) {
a157 1
		push(@@realnames, keys(%extra_rm));
d171 1
a171 1
	DELETE: for my $pkgname (@@realnames) {
@


1.88
log
@restore $main::not that is needed by OpenBSD::RequiredBy,
put an # XXX comment so I won't be tempted to clean it again.
@
text
@d3 1
a3 1
# $OpenBSD: pkg_delete,v 1.87 2005/01/22 13:00:35 espie Exp $
a215 3
	# we're not actually doing anything, so we can't expect this loop 
	# to ever finish
	last if $opt_n;
@


1.87
log
@do not clean-up shared items in pretend mode (for now, need extra logic
to pretend cleaning it up).
@
text
@d3 1
a3 1
# $OpenBSD: pkg_delete,v 1.86 2005/01/14 02:25:12 espie Exp $
d81 1
@


1.86
log
@`big lock' model: lock the whole db for reading/writing.
design checked with millert@@, relying on process termination for unlock
at his suggestion.

Perf optimization: don't try to reinstall installed packages in kitchensink
mode if !-r.
@
text
@d3 1
a3 1
# $OpenBSD: pkg_delete,v 1.85 2005/01/03 01:02:45 espie Exp $
d228 1
a228 1
	OpenBSD::SharedItems::cleanup($state);
@


1.85
log
@rename -f -> -F
okay pvalchev@@, naddy@@, marco@@, deraadt@@

(keep -f around for the transition, will scrap it soon)
@
text
@d3 1
a3 1
# $OpenBSD: pkg_delete,v 1.84 2004/12/27 22:54:25 espie Exp $
d98 1
@


1.84
log
@recover from a nasty problem, allow people to delete package even if
some dependency got badly adjusted.
@
text
@d3 1
a3 1
# $OpenBSD: pkg_delete,v 1.83 2004/12/27 22:44:29 espie Exp $
d33 1
a33 1
set_usage('pkg_delete [-cInqvx] [-B pkg-destdir] [-f keys] pkgname [...]');
d39 1
a39 1
	getopts('vchxDdnf:qpS:L:B:I',
d42 5
@


1.83
log
@better message
@
text
@d3 1
a3 1
# $OpenBSD: pkg_delete,v 1.82 2004/12/15 01:07:10 espie Exp $
d177 1
a177 1
	for my $pkgname (@@realnames) {
d185 13
a197 2
		if (OpenBSD::RequiredBy->new($pkgname)->list() > 0) {
			next;
@


1.82
log
@move -n down into RequiredBy and PackingList (as $main::not, since we
don't want to load RequiredBy all the time).
Remove a few $state->{not} tests that are no longer needed.

pkg_add -n / pkg_delete -n should work much better when they need to
handle multiple dependencies.

(todo: kill plist caches, finish replacing with specialized caches like
libraries).
@
text
@d3 1
a3 1
# $OpenBSD: pkg_delete,v 1.81 2004/12/12 11:26:16 espie Exp $
d158 5
a162 1
		print "(removing them as well)\n";
@


1.81
log
@add somewhat more regular error catching code.
@
text
@d3 1
a3 1
# $OpenBSD: pkg_delete,v 1.80 2004/12/06 12:35:36 espie Exp $
d31 1
d76 1
@


1.80
log
@Usage
@
text
@d3 1
a3 1
# $OpenBSD: pkg_delete,v 1.79 2004/11/15 11:39:05 espie Exp $
d37 12
a48 13
eval { getopts('vchxDdnf:qpS:L:B:I',
	{'v' => sub {++$opt_v;},
	 'h' => sub { Usage(); },
	 'f' => sub { 
	 		for my $o (split/,/, shift) { 
				$forced{$o} = 1;
			}
	    	}}); };
if ($@@) {
	chomp($@@);
	$@@ =~ s/\s+at.*?$//;
	Usage($@@);
}
d72 1
d214 3
a216 2
if ($dielater) {
	print STDERR $dielater;
d218 1
a218 1
}
@


1.79
log
@clean-up: pull all option parsing together.
@
text
@d3 1
a3 1
# $OpenBSD: pkg_delete,v 1.78 2004/11/14 13:20:07 espie Exp $
d32 1
d37 1
a37 1
getopts('vcxDdnf:qpS:L:B:I',
d39 1
d44 7
a50 1
	    	}});
d64 1
a64 1
	Fatal "Option p is obsolete";
d67 1
a67 1
	Fatal "Option d is obsolete";
d215 2
a216 1
	die $dielater;
@


1.78
log
@allows for several -f options, since OpenBSD::Getopt makes this possible
@
text
@d3 1
a3 1
# $OpenBSD: pkg_delete,v 1.77 2004/11/14 11:58:43 espie Exp $
d74 7
a156 7
}

$state->{destdir} = $opt_B;
if ($opt_B eq '') {
    $state->{destdirname} = '';
} else {
    $state->{destdirname} = '${PKG_DESTDIR}';
@


1.77
log
@turn on progress meter by default, use -x to disable it.
document the new stuff, partial reorder of options.
@
text
@d3 1
a3 1
# $OpenBSD: pkg_delete,v 1.76 2004/11/14 11:40:08 espie Exp $
d32 1
a32 1
our ($opt_v, $opt_D, $opt_d, $opt_n, $opt_f, $opt_q, $opt_p, $opt_c, $opt_L, $opt_B, $opt_I, $opt_x);
d37 6
a42 1
	{'v' => sub {++$opt_v;} });
a59 4
}

if ($opt_f) {
	%forced = map {($_, 1)} split(/,/, $opt_f);
@


1.76
log
@let RequiredBy generate lists directly, use hashes to trim down duplicates directly. Optimize for !wantarray, by telling whether the list is empty or not.

prepare for a second similar list (REQUIRING) that will replace pkgdep, since
pkg_add -r spends a hell of a lot of its time reading/writing long
packing-lists...

Use the simplified interface.

Remove quite a few tests that the RequiredBy list is non-empty that do
nothing but obfuscate the code: just deal with the damn list already.
@
text
@d3 1
a3 1
# $OpenBSD: pkg_delete,v 1.75 2004/11/11 16:28:57 espie Exp $
d75 1
a75 1
if ($opt_x && !$state->{beverbose}) {
@


1.75
log
@reversed test.
@
text
@d3 1
a3 1
# $OpenBSD: pkg_delete,v 1.74 2004/11/11 12:29:20 espie Exp $
d128 5
a132 8
	my $deps = OpenBSD::RequiredBy->new($pkgname)->list();
	if (@@$deps > 0) {
		for my $dep (@@$deps) {
			next if defined $toremove{$dep};
			next if defined $extra_rm{$dep};
			$extra_rm{$dep}=$pkgname;
			push(@@todo, $dep);
		}
d170 3
a172 2
		my $deps = OpenBSD::RequiredBy->new($pkgname)->list();
		next if @@$deps > 0;
@


1.74
log
@store a ref to %forced in $state, for access anywhere.
@
text
@d3 1
a3 1
# $OpenBSD: pkg_delete,v 1.73 2004/11/11 11:36:26 espie Exp $
d75 1
a75 1
if ($opt_x && $state->{beverbose}) {
@


1.73
log
@move some code from pkg_add to OpenBSD/Add.pm, for symetry with pkg_delete.

change prototype of validate_plist, ditch globals cdrom_only and ftp_only
(stash this into state).

Use Warn properly.
@
text
@d3 1
a3 1
# $OpenBSD: pkg_delete,v 1.72 2004/11/11 11:23:04 espie Exp $
d72 1
@


1.72
log
@don't touch font directories if -n either...
@
text
@d3 1
a3 1
# $OpenBSD: pkg_delete,v 1.71 2004/11/11 11:16:39 espie Exp $
d80 1
a80 1
		print "$0 should be run as root\n";
@


1.71
log
@introduce shortcuts to read/write contents from_installation/to_installation

use these to simplify all those packing lists manipulations.

demote non-root detection to a warning in -n mode:
fix a couple of minor bugs, of stuff that was run in -n mode and should not.
Namely, manpages were indexed/unindexed (ouch) and tempfiles were creating
during updates.
@
text
@d3 1
a3 1
# $OpenBSD: pkg_delete,v 1.70 2004/11/11 10:47:26 espie Exp $
d200 1
a200 1
OpenBSD::PackingElement::Fontdir::finish_fontdirs();
@


1.70
log
@fix interaction of -n -v -r.
don't enable the progress meter if a very verbose mode is on.
@
text
@d3 1
a3 1
# $OpenBSD: pkg_delete,v 1.69 2004/11/09 11:11:01 espie Exp $
a60 4
if ($< && !$forced{nonroot}) {
	Fatal "$0 must be run as root";
}

d78 8
a178 1
		$state->{pkgname_tolog} = $pkgname;
@


1.69
log
@kill old Logger interface, use $state->print() to report problems at
end exclusively now.
@
text
@d3 1
a3 1
# $OpenBSD: pkg_delete,v 1.68 2004/11/07 11:39:10 espie Exp $
a56 3
if ($opt_x) {
	OpenBSD::ProgressMeter::enable();
}
d77 4
@


1.68
log
@show tally in verbose mode as well, why not ?
@
text
@d3 1
a3 1
# $OpenBSD: pkg_delete,v 1.67 2004/10/31 11:33:50 espie Exp $
a24 1
use OpenBSD::Logger;
a120 2
OpenBSD::Logger::log_as("pkg_delete");

a151 1
    OpenBSD::Logger::annotate("PKG_DESTDIR=\"$opt_B\"; export PKG_DESTDIR\n");
a197 4
my $logname = OpenBSD::Logger::logname();
if (defined $logname) {
	print "Problems logged as $logname\n";
}
@


1.67
log
@Simplify ldconfig handling: one single ensure_ldconfig routine that
reruns ldconfig -R (okay, we don't check that -m would be enough, so what ?)

First hooks for -r: check that replacement should work.
@
text
@d3 1
a3 1
# $OpenBSD: pkg_delete,v 1.66 2004/10/31 10:26:17 espie Exp $
d205 3
@


1.66
log
@Move most of the code of pkg_delete into a separate module so that it will
be usable by pkg_add -r.
@
text
@d3 1
a3 1
# $OpenBSD: pkg_delete,v 1.65 2004/10/31 09:06:04 espie Exp $
a32 5
sub ensure_ldconfig
{
	&OpenBSD::Delete::ensure_ldconfig;
}

d191 1
a191 1
ensure_ldconfig($state);
@


1.65
log
@Erase old code
@
text
@d3 1
a3 1
# $OpenBSD: pkg_delete,v 1.64 2004/10/26 17:37:04 espie Exp $
a23 1
use OpenBSD::PackageInfo;
a25 2
use OpenBSD::Vstat;
use OpenBSD::PackageInfo;
d28 2
a32 1

d35 1
a35 300
	my $state = shift;
	return if $state->{not};
	return unless defined $OpenBSD::PackingElement::Lib::todo;
	VSystem($state->{very_verbose}, 
	    @@OpenBSD::PackingElement::Lib::ldconfig, "-R");
	undef $OpenBSD::PackingElement::Lib::todo;
}

package OpenBSD::PackingElement;
sub delete
{
}

sub log_pkgname
{
	my ($self, $state) = @@_;
	if (defined $state->{pkgname_tolog}) {
		OpenBSD::Logger::log
		    "# package ", $state->{pkgname_tolog}, "\n";
	$state->{pkgname_tolog} = undef;
	}
}

package OpenBSD::PackingElement::NewUser;
sub delete
{
	my ($self, $state) = @@_;

	my $name = $self->{name};

	if ($state->{beverbose}) {
		print "rmuser: $name\n";
	}

	$state->{users_to_rm} = {} unless defined $state->{users_to_rm};

	my $h = $state->{users_to_rm};
	$h->{$name} = $state->{pkgname};
}

package OpenBSD::PackingElement::NewGroup;
sub delete
{
	my ($self, $state) = @@_;

	my $name = $self->{name};

	if ($state->{beverbose}) {
		print "rmgroup: $name\n";
	}

	$state->{groups_to_rm} = {} unless defined $state->{groups_to_rm};

	my $h = $state->{groups_to_rm};
	$h->{$name} = 1;
}

package OpenBSD::PackingElement::DirBase;
sub delete
{
	my ($self, $state) = @@_;

	my $name = $self->fullname();

	if ($state->{beverbose}) {
		print "dirrm: $name\n";
	}

	$state->{dirs_to_rm} = {} unless defined $state->{dirs_to_rm};

	my $h = $state->{dirs_to_rm};
	$h->{$name} = [] unless defined $h->{$name};
	$self->{pkgname} = $state->{pkgname};
	push(@@{$h->{$name}}, $self);
}

package OpenBSD::PackingElement::DirRm;
sub delete
{
	&OpenBSD::PackingElement::DirBase::delete;
}

package OpenBSD::PackingElement::Unexec;

sub delete
{
	my ($self, $state) = @@_;
	$self->run($state);
}

package OpenBSD::PackingElement::FileBase;
use OpenBSD::md5;
sub delete
{
	my ($self, $state) = @@_;
	my $name = $self->fullname();
	my $realname = $state->{destdir}.$name;
	if (-l $realname) {
		if ($state->{beverbose}) {
			print "deleting symlink: $realname\n";
		}
	} else {
		if (! -f $realname) {
			print "File $realname does not exist\n";
			return;
		}
		unless (defined($self->{link}) or $self->{nochecksum} or $state->{quick}) {
			if (!defined $self->{md5}) {
				print "Problem: $name does not have an md5 checksum\n";
				print "NOT deleting: $realname\n";
				$self->log_pkgname($state);
				OpenBSD::Logger::log "rm $state->{destdirname}$name\n";
				return;
			}
			my $md5 = OpenBSD::md5::fromfile($realname);
			if ($md5 ne $self->{md5}) {
				print "Problem: md5 doesn't match for $name\n";
				print "NOT deleting: $realname\n";
				$self->log_pkgname($state);
				OpenBSD::Logger::log "rm $state->{destdirname}$name #MD5\n";
				return;
			}
		}
		if ($state->{beverbose}) {
			print "deleting: $realname\n";
		}
	}
	return if $state->{not};
	if (!unlink $realname) {
		print "Problem deleting $realname\n";
		$self->log_pkgname($state);
		OpenBSD::Logger::log "rm $state->{destdirname}$name\n";
	}
}

package OpenBSD::PackingElement::Sample;
use OpenBSD::md5;
use OpenBSD::Error;

sub delete
{
	my ($self, $state) = @@_;
	my $name = $self->fullname();
	my $realname = $state->{destdir}.$name;

	my $orig = $self->{copyfrom};
	if (!defined $orig) {
		Fatal "\@@sample element does not reference a valid file\n";
	}
	my $origname = $state->{destdir}.$orig->fullname();
	if (! -e $realname) {
		print "File $realname does not exist\n";
		return;
	}
	if (! -f $realname) {
		print "File $realname is not a file\n";
		return;
	}
	if (!defined $orig->{md5}) {
		print "Problem: file $name does not have an md5 checksum\n";
		print "NOT deleting: $realname\n";
		$self->log_pkgname($state);
		OpenBSD::Logger::log "rm $state->{destdirname}$name\n";
		return;
	}

	if ($state->{quick}) {
		unless ($state->{extra}) {
			print "NOT deleting file $realname\n";
			return;
		}
	} else {
		my $md5 = OpenBSD::md5::fromfile($realname);
		if ($md5 eq $orig->{md5}) {
			print "File $realname identical to sample\n" if $state->{not} or $state->{verbose};
		} else {
			print "File $realname NOT identical to sample\n";
			unless ($state->{extra}) {
				print "NOT deleting $realname\n";
				return;
			}
		}
	}
	return if $state->{not};
	print "deleting $realname\n" if $state->{verbose};
	if (!unlink $realname) {
		print "Problem deleting $realname\n";
		$self->log_pkgname($state);
		OpenBSD::Logger::log "rm $state->{destdirname}$name\n";
	}
}
		

package OpenBSD::PackingElement::InfoFile;
use File::Basename;
use OpenBSD::Error;

sub delete
{
	my ($self, $state) = @@_;
	unless ($state->{not}) {
	    my $fullname = $state->{destdir}.$self->fullname();
	    VSystem($state->{very_verbose}, 
	    "install-info", "--delete", "--info-dir=".dirname($fullname), $fullname);
	}
	$self->SUPER::delete($state);
}

package OpenBSD::PackingElement::Shell;
sub delete
{
	my ($self, $state) = @@_;
	unless ($state->{not}) {
		my $destdir = $state->{destdir};
		my $fullname = $self->fullname();
		my @@l=();
		if (open(my $shells, '<', $destdir.'/etc/shells')) {
			local $_;
			while(<$shells>) {
				push(@@l, $_);
				s/^\#.*//;
				if ($_ =~ m/^\Q$fullname\E\s*$/) {
					pop(@@l);
				}
			}
			close($shells);
			open(my $shells2, '>', $destdir.'/etc/shells');
			print $shells2 @@l;
			close $shells2;
			print "Shell $fullname removed from $destdir/etc/shells\n";
		}
	}
	$self->SUPER::delete($state);
}

package OpenBSD::PackingElement::Extra;
sub delete
{
	my ($self, $state) = @@_;
	return unless $state->{extra};
	my $name = $self->fullname();
	my $realname = $state->{destdir}.$name;
	if ($state->{beverbose}) {
		print "deleting extra file: $realname\n";
	}
	return if $state->{not};
	return unless -e $realname;
	unlink($realname) or 
	    print "problem deleting extra file $realname\n";
}

package OpenBSD::PackingElement::Extradir;
sub delete
{
	my ($self, $state) = @@_;
	return unless $state->{extra};
	return unless -e $state->{destdir}.$self->fullname();
	$self->SUPER::delete($state);
}

package OpenBSD::PackingElement::ExtraUnexec;
use OpenBSD::Error;

sub delete
{
	my ($self, $state) = @@_;
	return unless $state->{extra};

	$self->run($state);
}

package OpenBSD::PackingElement::Lib;

sub delete
{
	my ($self, $state) = @@_;
	$self->SUPER::delete($state);
	$self->mark_ldconfig_directory($state->{destdir});
}

package OpenBSD::PackingElement::FREQUIRE;
use OpenBSD::PackageInfo;
use OpenBSD::Error;

sub delete
{
	my ($self, $state) = @@_;

	$self->run($state, "DEINSTALL");
}

package OpenBSD::PackingElement::FDEINSTALL;
use OpenBSD::PackageInfo;
use OpenBSD::Error;

sub delete
{
	my ($self, $state) = @@_;

	$self->run($state, "DEINSTALL");
a37 2
package main;

a40 103
sub remove_packing_info
{
	my $dir = shift;

	for my $fname (info_names()) {
		unlink($dir.$fname);
	}
	rmdir($dir) or Fatal "Can't finish removing directory $dir: $!";
}

sub manpages_unindex
{
	my ($state) = @@_;
	return unless defined $state->{mandirs};
	my $destdir = $state->{destdir};
	require OpenBSD::Makewhatis;

	while (my ($k, $v) = each %{$state->{mandirs}}) {
		my @@l = map { $destdir.$_ } @@$v;
		eval { OpenBSD::Makewhatis::remove($destdir.$k, \@@l); };
		if ($@@) {
			print STDERR "Error in makewhatis: $@@\n";
		}
	}
	undef $state->{mandirs};
}

sub validate_plist($$)
{
	my ($plist, $destdir) = @@_;

	my $problems = 0;
	my $totsize = 0;
	for my $item (@@{$plist->{items}}) {
		next unless $item->IsFile();
		my $fname = $destdir.$item->fullname();
		$totsize += $item->{size} if defined $item->{size};
		my $s = OpenBSD::Vstat::remove($fname, $item->{size});
		next unless defined $s;
		if ($s->{ro}) {
			Warn "Error: ", $s->{mnt}, " is read-only ($fname)\n";
			$problems++;
		}
	}
	Fatal "fatal issues" if $problems;
	return $totsize;
}

sub delete_package
{
	my ($pkgname, $state) = @@_;
	$state->{pkgname} = $pkgname;
	my $dir = installed_info($pkgname);
	$state->{dir} = $dir;
	my $plist = OpenBSD::PackingList->fromfile($dir.CONTENTS) or 
	    Fatal "Bad package";
	if (!defined $plist->pkgname()) {
		Fatal "Package $pkgname has no name";
	}
	if ($plist->pkgname() ne $pkgname) {
		Fatal "Package $pkgname real name does not match";
	}

	my $totsize = validate_plist($plist, $state->{destdir});

	$ENV{'PKG_PREFIX'} = $plist->pkgbase();
	if ($plist->has(REQUIRE)) {
		$plist->get(REQUIRE)->delete($state);
	}
	if ($plist->has(DEINSTALL)) {
		$plist->get(DEINSTALL)->delete($state);
	} 
	$plist->visit('register_manpage', $state);
	manpages_unindex($state);
	my $donesize = 0;
	for my $item (@@{$plist->{groups}}, @@{$plist->{users}}, @@{$plist->{items}}) {
		$item->delete($state);
		if (defined $item->{size}) {
                        $donesize += $item->{size};
                        OpenBSD::ProgressMeter::show($donesize, $totsize);
                }
	}

	OpenBSD::ProgressMeter::next();
	if ($plist->has(UNDISPLAY)) {
		$plist->get(UNDISPLAY)->prepare($state);
	}

	# guard against duplicate pkgdep
	my $removed = {};
	for my $item (@@{$plist->{pkgdep}}) {
		my $name = $item->{name};
		next if defined $removed->{$name};
		print "remove dependency in $name\n" if $opt_v or $opt_n;
		local $@@;
		eval { OpenBSD::RequiredBy->new($name)->delete($pkgname) unless $opt_n; };
		if ($@@) {
			print STDERR "$@@\n";
		}
		$removed->{$name} = 1;
	}
	remove_packing_info($dir) unless $opt_n;
}
d184 1
a184 1
		delete_package($pkgname, $state);
@


1.64
log
@kill old duplicate code.
@
text
@d3 1
a3 1
# $OpenBSD: pkg_delete,v 1.63 2004/10/26 17:23:15 espie Exp $
a612 5
if (defined $state->{display}) {
	close $state->{display};
	my $pager = $ENV{'PAGER'} || "/usr/bin/more";
	System("$pager ".$state->{displayname});
}
@


1.63
log
@move the code that handles shared items into a separate Module.

- It will be used after deletion/adding during updates.
- We might avoid loading it if a package contains no new directories.
Actually a lot of packages don't use it.
@
text
@d3 1
a3 1
# $OpenBSD: pkg_delete,v 1.62 2004/10/23 09:27:48 espie Exp $
a336 13
}

package OpenBSD::PackingElement::FUNDISPLAY;
use OpenBSD::Error;
use OpenBSD::PackageInfo;

sub delete
{
	my ($self, $state) = @@_;
	my $dir = $state->{dir};

	my $pager = $ENV{'PAGER'} || "/usr/bin/more";
	System("$pager $dir".UNDISPLAY);
@


1.62
log
@store pkgname in shared items, so that delayed printing can be used
(and use it).

Optimisation: don't clone() directories
@
text
@d3 1
a3 1
# $OpenBSD: pkg_delete,v 1.61 2004/10/20 11:38:57 espie Exp $
a44 81
sub record_all_shared_items
{
	my $db = {dirs=>{}, users=>{}, groups=>{}};
	my @@list = installed_packages();
	my $total = @@list;
	OpenBSD::ProgressMeter::set_header("Read shared items");
	my $done = 0;
	for my $e (@@list) {
		OpenBSD::ProgressMeter::show($done, $total);
		my $plist = OpenBSD::PackingList->fromfile(installed_info($e).CONTENTS, \&OpenBSD::PackingList::DirrmOnly) or next;
		for my $item (@@{$plist->{users}}, @@{$plist->{groups}}, @@{$plist->{items}}) {
			$item->record_shared_item($e, $db);
		}
		$done++;
	}
	return $db;
}

sub cleanup_shared_items
{
	my $state = shift;

	my $h = $state->{dirs_to_rm};
	my $u = $state->{users_to_rm};
	my $g = $state->{groups_to_rm};
	return unless defined $h or defined $u or defined $g;
	my $remaining = record_all_shared_items();

	OpenBSD::ProgressMeter::clear();
	OpenBSD::ProgressMeter::set_header("Clean shared items");
	my $total = 0;
	$total += keys %$h if defined $h;
	if ($state->{extra}) {
		$total += keys %$u if defined $u;
		$total += keys %$g if defined $g;
	}
	my $done = 0;

	if (defined $h) {
		for my $d (sort {$b cmp $a} keys %$h) {
			OpenBSD::ProgressMeter::show($done, $total);
			my $realname = $state->{destdir}.$d;
			if ($remaining->{dirs}->{$realname}) {
				for my $i (@@{$h->{$d}}) {
					$state->set_pkgname($i->{pkgname});
					$i->reload($state);
				}
			} else {
				for my $i (@@{$h->{$d}}) {
					$state->set_pkgname($i->{pkgname});
					$i->cleanup($state);
				}
				if (!rmdir $realname) {
					$state->print("Error deleting directory $realname: $!\n");
				}
			}
			$done++;
		}
	}
	if ($state->{extra}) {
		if (defined $u) {
			for my $user (keys %$u) {
				OpenBSD::ProgressMeter::show($done, $total);
				next if $remaining->{users}->{$user};
				System("/usr/sbin/userdel", $user);
				$done++;
			}
		}
		if (defined $g) {
			for my $group (keys %$g) {
				OpenBSD::ProgressMeter::show($done, $total);
				next if $remaining->{groups}->{$group};
				System("/usr/sbin/groupdel", $group);
				$done++;
			}
		}
	}
	OpenBSD::ProgressMeter::next();
}


a49 12
sub record_shared_item
{
}

sub cleanup
{
}

sub reload
{
}

a60 7
sub record_shared_item
{
	my ($self, $pkgname, $db) = @@_;
	my $k = $self->{name};
	$db->{users}->{$k} = $pkgname;
}

a77 7
sub record_shared_item
{
	my ($self, $pkgname, $db) = @@_;
	my $k = $self->{name};
	$db->{groups}->{$k} = $pkgname;
}

a94 7
sub record_shared_item
{
	my ($self, $pkgname, $db) = @@_;
	my $k = $self->fullname();
	$db->{dirs}->{$k} = 1;
}

a113 5
sub record_shared_item
{
	&OpenBSD::PackingElement::DirBase::record_shared_item;
}

a296 28
package OpenBSD::PackingElement::Mandir;
sub cleanup
{
	my ($self, $state) = @@_;
	my $fullname = $state->{destdir}.$self->fullname();
	$state->print("You may wish to remove ", $fullname, " from man.conf\n");
	unlink("$fullname/whatis.db");
}

package OpenBSD::PackingElement::Fontdir;
sub cleanup
{
	my ($self, $state) = @@_;
	my $fullname = $state->{destdir}.$self->fullname();
	$state->print("You may wish to remove ", $fullname, " from your font path\n");
	unlink("$fullname/fonts.alias");
	unlink("$fullname/fonts.dir");
	unlink("$fullname/fonts.cache-1");
}

package OpenBSD::PackingElement::Infodir;
sub cleanup
{
	my ($self, $state) = @@_;
	my $fullname = $state->{destdir}.$self->fullname();
	unlink("$fullname/dir");
}

d617 7
a623 1
cleanup_shared_items($state);
@


1.61
log
@basic framework for delayed messages.
@
text
@d3 1
a3 1
# $OpenBSD: pkg_delete,v 1.60 2004/10/19 09:43:40 espie Exp $
d89 1
d94 1
d98 1
a98 1
					print "Error deleting directory $realname: $!\n";
d158 1
a158 1
	$db->{users}->{$k} = 1;
d174 1
a174 1
	$h->{$name} = 1;
d182 1
a182 1
	$db->{groups}->{$k} = 1;
d223 2
a224 1
	push(@@{$h->{$name}}, $self->clone());
d430 1
a430 1
	print "You may wish to remove ", $fullname, " from your font path\n";
@


1.60
log
@Extra progress meter for the handling of shared items: first show
the reading of remaining stuff from installed packages, then the
cleaning-up as it progresses.
@
text
@d3 1
a3 1
# $OpenBSD: pkg_delete,v 1.59 2004/10/18 12:03:19 espie Exp $
d418 1
a418 1
	print "You may wish to remove ", $fullname, " from man.conf\n";
d640 1
a640 1
my $state = {};
d745 1
d773 1
@


1.59
log
@experimental progress meter.
not active unless you specify -x for pkg_add/pkg_delete.
(option is bound to change)
@
text
@d3 1
a3 1
# $OpenBSD: pkg_delete,v 1.58 2004/10/18 10:51:03 espie Exp $
d49 3
d53 1
d58 1
d73 10
d85 1
d99 1
d102 8
a109 5
	return unless $state->{extra};
	if (defined $u) {
		for my $user (keys %$u) {
			next if $remaining->{users}->{$user};
			System("/usr/sbin/userdel", $user);
d111 7
a117 5
	}
	if (defined $g) {
		for my $group (keys %$g) {
			next if $remaining->{groups}->{$group};
			System("/usr/sbin/groupdel", $group);
d120 1
@


1.58
log
@use OpenBSD::Getopt so that we can do -v -v.
Be much terser by default, start showing dependency information and
various things only with at least one -v.

Build a `flattened tree' of dependencies information in pkg_add, and
show why we install a given package (idea from deraadt@@).
@
text
@d3 1
a3 1
# $OpenBSD: pkg_delete,v 1.57 2004/10/17 09:32:21 espie Exp $
d30 1
d475 1
a475 1
our ($opt_v, $opt_D, $opt_d, $opt_n, $opt_f, $opt_q, $opt_p, $opt_c, $opt_L, $opt_B, $opt_I);
d510 1
d514 1
d523 1
d541 1
a541 1
	validate_plist($plist, $state->{destdir});
d552 1
d555 4
d561 1
d582 1
a582 1
getopts('vcDdnf:qpS:L:B:I',
d603 3
d718 4
a721 2
		print $opt_n ? "Pretending to delete " : "Deleting ", 
		    "$pkgname\n";
d750 1
a750 1
	die $@@;
@


1.57
log
@behave according to documentation, e.g., delete groups/users only if -c.
fix typo.
@
text
@d3 1
a3 1
# $OpenBSD: pkg_delete,v 1.56 2004/10/11 14:40:04 espie Exp $
d21 1
a21 1
use Getopt::Std;
d39 1
a39 1
	VSystem($state->{verbose}, 
d303 1
a303 1
			print "File $realname identical to sample\n";
d313 1
a313 1
	print "deleting $realname\n";
d331 1
a331 1
	    VSystem($state->{verbose}, 
d476 1
d572 2
a573 1
getopts('vcDdnf:qpS:L:B:I');
d607 3
a609 2
$state->{verbose} = $opt_v;
$state->{beverbose} = $opt_n || $opt_v;
@


1.56
log
@common code for exec/unexec/extraunexec.
@
text
@d3 1
a3 1
# $OpenBSD: pkg_delete,v 1.55 2004/10/11 14:35:08 espie Exp $
d84 1
d297 1
a297 1
			print "NOT'deleting file $realname\n";
@


1.55
log
@simplify ldconfig now that we run in an uniform way.
@
text
@d3 1
a3 1
# $OpenBSD: pkg_delete,v 1.54 2004/10/11 13:46:17 espie Exp $
a210 1
use OpenBSD::Error;
d215 1
a215 7
	my $cmd = $self->{expanded};
	main::ensure_ldconfig($state);
	if ($state->{beverbose}) {
		print "unexec: $cmd\n";
	}
	return if $state->{not};
	System('/bin/sh', '-c', $cmd);
d424 1
a424 7
	my $cmd = $self->{expanded};
	main::ensure_ldconfig($state);
	if ($state->{beverbose}) {
		print "unexec: $cmd\n";
	}
	return if $state->{not};
	System($cmd);
@


1.54
log
@aggregate all MESSAGES and display them at the end, with proper markers to
separate distinct packages.
@
text
@d3 1
a3 1
# $OpenBSD: pkg_delete,v 1.53 2004/10/11 13:29:05 espie Exp $
d36 2
a37 1
	my $verbose = shift;
d39 2
a40 1
	VSystem($verbose, @@OpenBSD::PackingElement::Lib::ldconfig, "-R");
d217 1
a217 1
	main::ensure_ldconfig($state->{verbose}) unless $state->{not};
d432 1
a432 1
	main::ensure_ldconfig($state->{verbose}) unless $state->{not};
d729 1
a729 1
ensure_ldconfig($opt_v) unless $opt_n;
@


1.53
log
@move mandir handling to pkg_add/delete time, solely.
Adjust stuff so that pkg_add can run makewhatis just once.
pkg_delete cannot, since it has to have the manpages around still
to remove them...
@
text
@d3 1
a3 1
# $OpenBSD: pkg_delete,v 1.52 2004/10/11 13:10:25 espie Exp $
d562 1
a562 1
		$plist->get(UNDISPLAY)->delete($state);
d732 5
@


1.52
log
@common code for all script running.
Common option for not running scripts: -I for both pkg_add and pkg_delete.
@
text
@d3 1
a3 1
# $OpenBSD: pkg_delete,v 1.51 2004/10/11 12:31:02 espie Exp $
d498 3
a500 2
	my ($plist, $destdir) = @@_;
	return unless defined $plist->{state}->{mandirs};
d503 1
a503 1
	while (my ($k, $v) = each %{$plist->{state}->{mandirs}}) {
d510 1
d555 2
a556 1
	manpages_unindex($plist, $state->{destdir});
@


1.51
log
@$state->{beverbose} = $state->{verbose} || $state->{not}
@
text
@d3 1
a3 1
# $OpenBSD: pkg_delete,v 1.50 2004/10/11 11:48:18 espie Exp $
d455 1
a455 12
	my $dir = $state->{dir};
	my $opt_v = $state->{verbose};
	my $opt_n = $state->{not};
	my $pkgname = $state->{pkgname};

	main::ensure_ldconfig($opt_v) unless $opt_n;
	print "Require script: $dir",REQUIRE," $pkgname DEINSTALL\n" if $opt_v or $opt_n;
	unless ($opt_n) {
		chmod 0755, $dir.REQUIRE;
		System($dir.REQUIRE, $pkgname, "DEINSTALL") == 0 or 
		    Fatal "Require script borked";
	}
d466 1
a466 11
	my $dir = $state->{dir};
	my $opt_v = $state->{verbose};
	my $opt_n = $state->{not};
	my $pkgname = $state->{pkgname};
	main::ensure_ldconfig($opt_v) unless $opt_n;
	print "Deinstall script: $dir",DEINSTALL ," $pkgname DEINSTALL\n" if $opt_v or $opt_n;
	unless ($opt_n) {
		chmod 0755, $dir.DEINSTALL;
		System($dir.DEINSTALL, $pkgname, "DEINSTALL") == 0 or 
		    Fatal "deinstall script borked";
	}
d484 1
a484 1
our ($opt_v, $opt_D, $opt_d, $opt_n, $opt_f, $opt_q, $opt_p, $opt_c, $opt_L, $opt_B);
d578 4
a581 1
getopts('vcDdnf:qpS:L:B:');
d615 1
@


1.50
log
@tweak, make it work a bit more like pkg_add
@
text
@d3 1
a3 1
# $OpenBSD: pkg_delete,v 1.49 2004/10/11 10:30:33 espie Exp $
d138 1
a138 1
	if ($state->{verbose} or $state->{not}) {
d162 1
a162 1
	if ($state->{verbose} or $state->{not}) {
d186 1
a186 1
	if ($state->{verbose} or $state->{not}) {
d216 1
a216 1
	if ($state->{verbose} or $state->{not}) {
d231 1
a231 1
		if ($state->{verbose} or $state->{not}) {
d256 1
a256 1
		if ($state->{verbose} or $state->{not}) {
d375 1
a375 1
	if ($state->{verbose} or $state->{not}) {
d431 1
a431 1
	if ($state->{verbose} or $state->{not}) {
d631 1
@


1.49
log
@add support for undisplay file, to be able to show information at pkg
removal without having to run a DEINSTALL script...
@
text
@d3 1
a3 1
# $OpenBSD: pkg_delete,v 1.48 2004/09/24 09:06:50 espie Exp $
d270 2
d280 1
a280 1
		die "\@@sample element does not reference a valid file\n";
d465 1
a465 1
		    die "Require script borked";
d486 1
a486 1
		    die "deinstall script borked";
d514 1
a514 1
	rmdir($dir) or die "Can't finish removing directory $dir: $!";
d532 18
d557 1
a557 1
	    die "Bad package";
d559 1
a559 1
		die "Package $pkgname has no name";
d562 1
a562 1
		die "Package $pkgname real name does not match";
d565 1
a565 12
	my $problems = 0;
	for my $item (@@{$plist->{items}}) {
		next unless $item->IsFile();
		my $fname = $item->fullname();
		my $s = OpenBSD::Vstat::remove($fname, $item->{size});
		next unless defined $s;
		if ($s->{ro}) {
			print "Error: ", $s->{mnt}, " is read-only ($fname)\n";
			$problems++;
		}
	}
	die if $problems;
d610 1
a610 1
	die "Option p is obsolete";
d613 1
a613 1
	die "Option d is obsolete";
d621 1
a621 1
	die "$0 must be run as root";
@


1.48
log
@ditch `config' in the @@sample messages, since this more or less covers
all files installed from templates.
@
text
@d3 1
a3 1
# $OpenBSD: pkg_delete,v 1.47 2004/09/24 08:49:27 espie Exp $
d488 13
d569 5
@


1.47
log
@2nd half of @@newuser/@@newgroup: treat them as shared items, and remove
them along with directories, if extra.
@
text
@d3 1
a3 1
# $OpenBSD: pkg_delete,v 1.46 2004/09/21 09:44:09 espie Exp $
d282 1
a282 1
		print "Config file $realname does not exist\n";
d286 1
a286 1
		print "Config file $realname is not a file\n";
d290 1
a290 1
		print "Problem: config file $name does not have an md5 checksum\n";
d299 1
a299 1
			print "NOT'deleting config file $realname\n";
d305 1
a305 1
			print "Config file $realname identical to sample\n";
d307 1
a307 1
			print "Config file $realname NOT identical to sample\n";
@


1.46
log
@typo
@
text
@d3 1
a3 1
# $OpenBSD: pkg_delete,v 1.45 2004/09/21 09:42:33 espie Exp $
d44 1
a44 1
	my $db = {};
d48 1
a48 1
		for my $item (@@{$plist->{items}}) {
d60 3
a62 2
	return unless defined $h;

d65 14
a78 12
	for my $d (sort {$b cmp $a} keys %$h) {
		my $realname = $state->{destdir}.$d;
		if ($remaining->{$realname}) {
			for my $i (@@{$h->{$d}}) {
				$i->reload($state);
			}
		} else {
			for my $i (@@{$h->{$d}}) {
				$i->cleanup($state);
			}
			if (!rmdir $realname) {
				    print "Error deleting directory $realname: $!\n";
d80 12
d124 47
d177 1
a177 1
	$db->{$k} = 1;
d553 1
a553 1
	for my $item (@@{$plist->{items}}) {
d714 1
a714 1
# delayed directory removal
@


1.45
log
@rename cleanup dirs functions, since they will apply to all shared items
soon.
@
text
@d1 1
a1 1
_#!/usr/bin/perl
d3 1
a3 1
# $OpenBSD: pkg_delete,v 1.44 2004/09/20 07:31:42 espie Exp $
@


1.44
log
@use fullname() in sample, so that absolute names AND relative names work.
problem noticed by sturm@@
@
text
@d1 1
a1 1
#!/usr/bin/perl
d3 1
a3 1
# $OpenBSD: pkg_delete,v 1.43 2004/09/18 09:27:05 espie Exp $
d42 1
a42 1
sub erase_alldirrms
d49 1
a49 1
			$item->erase_dir($e, $db);
d55 1
a55 1
sub remove_dirs
d62 1
a62 1
	my $remaining = erase_alldirrms();
d87 1
a87 1
sub erase_dir
d111 1
a111 1
sub erase_dir
d136 1
a136 1
sub erase_dir
d138 1
a138 1
	&OpenBSD::PackingElement::DirBase::erase_dir;
d653 1
a653 1
remove_dirs($state);
@


1.43
log
@full support for @@shell: insert shells into /etc/shells if they're
not already there, and remove them on deinstall.
@
text
@d3 1
a3 1
# $OpenBSD: pkg_delete,v 1.42 2004/09/14 22:58:30 espie Exp $
d211 1
a211 1
	my $name = $self->{name};
@


1.42
log
@better wording for documentation.
use System more or less everywhere.
prepare to delete info directories properly.
@
text
@d3 1
a3 1
# $OpenBSD: pkg_delete,v 1.41 2004/08/11 09:28:26 espie Exp $
d273 27
@


1.41
log
@protect main loop of pkg_delete with an eval, so that
ldconfig, directory removal, manpage handling, and fontdir handling
always happen.
@
text
@d3 1
a3 1
# $OpenBSD: pkg_delete,v 1.40 2004/08/10 12:05:52 espie Exp $
d29 1
d38 1
a38 2
	print "running ldconfig -R\n" if $verbose;
	system(@@OpenBSD::PackingElement::Lib::ldconfig, "-R");
d147 2
d158 1
a158 1
	system('/bin/sh', '-c', $cmd);
d264 2
d271 2
a272 1
	    system("install-info", "--delete", "--info-dir=".dirname($fullname), $fullname);
d322 8
d331 2
d344 1
a344 1
	system($cmd);
d358 2
d373 1
a373 1
		system($dir.REQUIRE, $pkgname, "DEINSTALL") == 0 or 
d380 2
d394 1
a394 1
		system($dir.DEINSTALL, $pkgname, "DEINSTALL") == 0 or 
@


1.40
log
@typo
@
text
@d3 1
a3 1
# $OpenBSD: pkg_delete,v 1.39 2004/08/10 11:53:27 espie Exp $
d576 1
d601 3
a603 1
} while ($removed); }
d613 3
@


1.39
log
@cosmetic tweak: ensure all dirs always get exactly one / at the end.
cosmetic tweak: do not show a space after a keyword without args.
dir support reworked: keep clones() of dir objects, and call cleanup/reload
routines at end.

@@mandir/fontdir support:
both mandir and fontdir remove extra files on delete.
@@fontdir creates alias files, runs mkfontdir, and uses fc-cache.
@
text
@d3 1
a3 1
# $OpenBSD: pkg_delete,v 1.37 2004/08/07 17:27:26 espie Exp $
d301 1
a301 1
	my $fullname = $state->{destdir}.self->fullname();
@


1.38
log
@record remaining DirRms.
@
text
@d42 1
a42 1
sub find_alldirrms
d49 1
a49 1
			$item->record_dirrm($e, $db);
d62 1
a62 1
	my $remaining = find_alldirrms();
a64 1
		next if defined $remaining->{$d};
d66 11
a76 2
		if (!rmdir $realname) {
			    print "Error deleting directory $realname: $!\n";
d87 9
a95 1
sub record_dirrm
d111 1
a111 1
sub record_dirrm
d115 1
a115 2
	$db->{$k} = [] unless defined $db->{$k};
	push(@@{$db->{$k}}, $pkgname);
d132 1
a132 1
	push(@@{$h->{$name}}, $state->{pkgname});
d136 1
a136 1
sub record_dirrm
d138 1
a138 1
	&OpenBSD::PackingElement::DirBase::record_dirrm;
d297 20
d605 1
@


1.37
log
@use chroot DESTDIR ldconfig in DESTDIR case.
@
text
@d3 1
a3 1
# $OpenBSD: pkg_delete,v 1.36 2004/08/06 14:33:02 espie Exp $
d121 5
@


1.36
log
@protect makewhatis calls inside eval.
failing makewhatis should be a warning at best.
@
text
@d3 1
a3 1
# $OpenBSD: pkg_delete,v 1.35 2004/08/06 12:21:11 espie Exp $
d38 1
a38 1
	system($OpenBSD::PackingElement::Lib::ldconfig, "-R");
@


1.35
log
@use OpenBSD::Makewhatis, avoid forking extra makewhatis.

Note: requires you to update makewhatis to work.
@
text
@d3 1
a3 1
# $OpenBSD: pkg_delete,v 1.34 2004/08/06 10:23:45 espie Exp $
d362 4
a365 1
		OpenBSD::Makewhatis::remove($destdir.$k, \@@l);
@


1.34
log
@@@lib shared library marker.

- runs ldconfig to find out search library path.
- if library is in path, mark directory for updating cache.
- run ldconfig when needed, e.g., right before executing something that
might depend on the library.

Doesn't handle destdir case yet.
@
text
@d3 1
a3 1
# $OpenBSD: pkg_delete,v 1.33 2004/08/06 07:51:17 espie Exp $
d358 2
d361 2
a362 2
		system("/usr/libexec/makewhatis", "-u", $destdir.$k,
		map { $destdir.$_ } @@$v);
@


1.33
log
@unified headers, switch to smaller copyright notice.
@
text
@d3 1
a3 1
# $OpenBSD: pkg_delete,v 1.32 2004/08/06 07:37:34 espie Exp $
d28 1
d32 9
a40 1
use OpenBSD::PackageInfo;
d131 1
d284 1
d292 9
d312 1
d331 1
d557 1
@


1.32
log
@Extradir name.
Don't bother deleting it if it's not there.
@
text
@d3 1
a3 1
# $OpenBSD: pkg_delete,v 1.31 2004/08/06 07:05:16 espie Exp $
d5 13
a17 22
# Copyright (c) 2003 Marc Espie.
# 
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
# 
# THIS SOFTWARE IS PROVIDED BY THE OPENBSD PROJECT AND CONTRIBUTORS
# ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
# A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OPENBSD
# PROJECT OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
@


1.31
log
@deinstall DirRm like DirBase.
@
text
@d3 1
a3 1
# $OpenBSD: pkg_delete,v 1.30 2004/08/05 23:36:39 espie Exp $
d267 1
a267 1
package OpenBSD::PackingElement::ExtraDir;
d272 1
@


1.30
log
@refactor classes in PackingElement to share more code.
- all files go through FileBase, all directories go through DirBase.
- dirclass() is used to switch classes based on final /, so that
@@sample, @@extra, and @@file  all take directories as well.
- set NoDuplicateNames() more thoroughly.
- make sure all no-default-conflict objects are correct.

compute_fullname() checks for absolute paths, allowed for @@sample and
@@extra.

lastfile only gets set for actual files.

special names like INSTALL are only checked for normal files.

add a CVSTag class for @@comment $OpenBSD$, so that these get sorted first.

Changes for make-plist rewrite:

clone() method that can create copies of all hash objects, to specialize
if needed.

add_object() method so that add() is now new() followed by add_object()
for most objects (useful for cloned objects).

Check that plist has a name in pkg_create, allowing PackingList to write
unnamed plists.
@
text
@d3 1
a3 1
# $OpenBSD: pkg_delete,v 1.29 2004/08/03 12:29:45 espie Exp $
d118 6
@


1.29
log
@Support @@sample, tested by fries@@.
@@mandir and @@fontdir keywords recognition.
@
text
@d3 1
a3 1
# $OpenBSD: pkg_delete,v 1.28 2004/08/02 12:12:36 espie Exp $
d94 1
a94 1
package OpenBSD::PackingElement::Dirs;
d132 1
a132 1
package OpenBSD::PackingElement::File;
d252 2
a253 16
	if ($self->{name} =~ m|/$|) {
		if ($state->{verbose} or $state->{not}) {
			print "deleting extra directory: $realname\n";
		}
		return if $state->{not};
		return unless -e $realname;
		rmdir($realname) or 
		    print "problem deleting extra directory $realname\n";
	} else {
		if ($state->{verbose} or $state->{not}) {
			print "deleting extra file: $realname\n";
		}
		return if $state->{not};
		return unless -e $realname;
		unlink($realname) or 
		    print "problem deleting extra file $realname\n";
d255 12
@


1.28
log
@@@man type file for manpages.
@
text
@d3 1
a3 1
# $OpenBSD: pkg_delete,v 1.27 2004/07/20 18:58:41 espie Exp $
d176 56
@


1.27
log
@support for gnu-info, with @@info keyword.
- modify pkg_create so that it will look for info-[0-9]+ and add them
to the packing-list.
- deal with installing the info file/de-installing it at pkg_add/pkg_delete
time.

tested by naddy@@
@
text
@d3 1
a3 1
# $OpenBSD: pkg_delete,v 1.26 2004/07/18 12:00:21 espie Exp $
d280 10
d325 1
@


1.26
log
@when deleting @@link, don't bother checking for md5, since we don't have any.
The check will have been done for the `parent' file anyways.

noticed by krw@@, seems all heavy-duty porters use -q, so we didn't notice
it...
@
text
@d3 1
a3 1
# $OpenBSD: pkg_delete,v 1.25 2004/07/14 10:44:03 espie Exp $
d68 1
a68 1
			    print "Error deleting directory $realname\n";
d175 12
@


1.25
log
@Rework @@dirrm: keep them all, and remove them at the end of pkg_delete.
Add @@dir, more powerful than @@dirrm, so that we can get rid of those
pesky @@exec mkdir -p.

okay naddy@@
@
text
@d3 1
a3 1
# $OpenBSD: pkg_delete,v 1.24 2004/06/21 16:33:45 espie Exp $
d144 5
a148 1
		unless ($self->{nochecksum} or $state->{quick}) {
a153 4
				return;
			}
			if (! -f $realname) {
				print "File $realname does not exist\n";
@


1.24
log
@support for old stuff in pkg_info/pkg_delete, e.g., @@src
prompted by miod@@, okay miod@@ millert@@.
@
text
@d3 1
a3 1
# $OpenBSD: pkg_delete,v 1.23 2004/02/25 21:56:12 espie Exp $
d40 34
a92 2
package OpenBSD::PackingElement::DirRm;
use OpenBSD::PackageInfo;
d94 1
a102 13
sub find_alldirrms
{
	my $db = {};
	my @@list = installed_packages();
	for my $e (@@list) {
		my $plist = OpenBSD::PackingList->fromfile(installed_info($e).CONTENTS, \&OpenBSD::PackingList::DirrmOnly) or next;
		for my $item (@@{$plist->{items}}) {
			$item->record_dirrm($e, $db);
		}
	}
	return $db;
}

d106 1
a107 1
	my $realname = $state->{destdir}.$name;
d112 6
a117 30
	unless (defined $state->{dirrms}) {
		$state->{dirrms} = find_alldirrms();
	}
	return if $state->{not};
	my $entry = $state->{dirrms}->{$name};
	unless (defined $entry) {
		print "Error: dirrm $name was not recorded\n";
		return;
	}
	if (@@$entry == 0) {
		print "Error: no dirrm $name left\n";
	}
	elsif (@@$entry == 1) {
		if ($entry->[0] eq $state->{pkgname}) {
			if (!rmdir $realname) {
			    print "Error deleting directory $realname\n";
			    $self->log_pkgname($state);
			    OpenBSD::Logger::log "rmdir $state->{destdirname}$name\n";
			}
			$state->{dirrms}->{$name} = undef;
		} else {
			print "Error: dirrm $name recorded as ", 
			    $entry->[0], "\n";
		}
	}
	elsif (@@$entry > 1) {
		print "Dirrm $name defined in multiple packages: ",
			join(",", @@$entry), "\n" if $state->{verbose};
	    	@@$entry = grep { $_ ne $state->{pkgname} }  @@$entry;
	}
d459 3
@


1.23
log
@Add -B support to pkg_delete.
new method in Logger, annotate, so that the pkg_delete log script can
set
PKG_DESTDIR=  conditionally, and use ${PKG_DESTDIR} later on in filenames.
@
text
@d3 1
a3 1
# $OpenBSD: pkg_delete,v 1.22 2004/01/28 22:12:01 espie Exp $
d32 1
@


1.22
log
@Add -L to record/enforce localbase.
Okay sturm@@
@
text
@d3 1
a3 1
# $OpenBSD: pkg_delete,v 1.21 2004/01/27 15:34:31 espie Exp $
d86 1
d105 2
a106 2
			if (!rmdir $name) {
			    print "Error deleting directory $name\n";
d108 1
a108 1
			    OpenBSD::Logger::log "rmdir $name\n";
d141 2
a142 1
	if (-l $name) {
d144 1
a144 1
			print "deleting symlink: $name\n";
d150 1
a150 1
				print "NOT deleting: $name\n";
d152 1
a152 1
				OpenBSD::Logger::log "rm $name\n";
d155 2
a156 2
			if (! -f $name) {
				print "File $name does not exist\n";
d159 1
a159 1
			my $md5 = OpenBSD::md5::fromfile($name);
d162 1
a162 1
				print "NOT deleting: $name\n";
d164 1
a164 1
				OpenBSD::Logger::log "rm $name #MD5\n";
d169 1
a169 1
			print "deleting: $name\n";
d173 2
a174 2
	if (!unlink $name) {
		print "problem deleting $name\n";
d176 1
a176 1
		OpenBSD::Logger::log "rm $name\n";
d186 1
d189 1
a189 1
			print "deleting extra directory: $name\n";
d191 4
a194 1
		rmdir($name) unless $state->{not};
d197 1
a197 1
			print "deleting extra file: $name\n";
d200 3
a202 1
		unlink($name) or print "problem deleting $name\n";
d259 1
a259 1
our ($opt_v, $opt_D, $opt_d, $opt_n, $opt_f, $opt_q, $opt_p, $opt_c, $opt_L);
d325 7
a331 1
getopts('vcDdnf:qpS:L:');
d427 8
@


1.21
log
@more forced keywords.
`looks sane' henning@@
@
text
@d3 1
a3 1
# $OpenBSD: pkg_delete,v 1.20 2004/01/27 14:50:52 espie Exp $
d251 1
a251 1
our ($opt_v, $opt_D, $opt_d, $opt_n, $opt_f, $opt_q, $opt_p, $opt_c);
d291 1
a291 1
	$ENV{'PKG_PREFIX'} = '/usr/local';
d317 3
a319 1
getopts('vcDdnf:qpS:');
@


1.20
log
@first series of -forced switches, looks okay to henning@@.
@
text
@d3 1
a3 1
# $OpenBSD: pkg_delete,v 1.19 2004/01/27 13:09:16 espie Exp $
d350 18
a367 9
	$pkgname =~ s/\.tgz$//;
	unless (is_installed($pkgname)) {
	    if (OpenBSD::PackageName::is_stem($pkgname)) {
		my @@l = OpenBSD::PackageName::findstem($pkgname, 
		    installed_packages());
		if (@@l == 1) {
		    $pkgname = $l[0];
		} elsif (@@l != 0) {
		    print "Ambiguous: $pkgname could be ", join(' ', @@l),"\n";
a368 1
		    next;
d372 1
a372 6
	if (is_installed($pkgname)) {
	    push(@@realnames, installed_name($pkgname));
	} else {
	    print "Can't resolve $pkgname to an installed package name\n";
	    $bad = 1;
	}
a393 1
			$bad = 1;
d397 12
a409 3
	print "Can't remove ", join(' ', @@ARGV), " without also removing:\n",
	    join(' ', keys(%extra_rm)), "\n"
		if keys(%extra_rm) != 0;
@


1.19
log
@-f framework, manpage fixes.
comments and okay jmc@@
@
text
@d3 1
a3 1
# $OpenBSD: pkg_delete,v 1.18 2004/01/27 00:13:04 espie Exp $
d328 4
@


1.18
log
@show $! in system related errors.
@
text
@d3 1
a3 1
# $OpenBSD: pkg_delete,v 1.17 2004/01/27 00:08:31 espie Exp $
d37 2
d317 1
a317 1
getopts('vcDdnfqpS:');
d324 4
@


1.17
log
@remove package if RequiredBy file ends up empty too soon.
This allows users to remove packages with bogus dependency registration
that happened at one point in the life of the pkg_*.

This should please henning.
@
text
@d3 1
a3 1
# $OpenBSD: pkg_delete,v 1.16 2003/12/21 18:41:23 espie Exp $
d258 1
a258 1
	rmdir($dir) or die "Can't finish removing directory $dir";
@


1.16
log
@Add virtual file system, so that pkg_add and pkg_delete can check for
read-only status, or size concerns, before even beginning to add/remove
files.

Allows pkg_add -n and pkg_delete -n to be more thorough as well.

Some testing by Todd Millert, comments by Greg Steuck and Sam Smith.
@
text
@d3 1
a3 1
# $OpenBSD: pkg_delete,v 1.15 2003/12/10 11:43:52 espie Exp $
d305 5
a309 1
		OpenBSD::RequiredBy->new($name)->delete($pkgname) unless $opt_n;
@


1.15
log
@Flag unresolved package names as errors.
Help resolution by stripping away .tgz.
@
text
@d3 1
a3 1
# $OpenBSD: pkg_delete,v 1.14 2003/12/10 11:12:22 espie Exp $
d35 1
d276 13
a309 1

@


1.14
log
@Replace Adding/Deleting with "Pretending to add/delete" in -n mode.
Pick up DISPLAY from staging area, so that it gets found even if -n.
@
text
@d3 1
a3 1
# $OpenBSD: pkg_delete,v 1.13 2003/12/09 19:22:36 espie Exp $
d323 1
d337 6
a342 2
	next unless is_installed($pkgname);
	push(@@realnames, installed_name($pkgname));
d364 1
a364 1
			$bad=1;
@


1.13
log
@better management of list of installed packages. Allow pkg_add/delete -n
to proceed correctly in case of dependencies.
@
text
@d3 1
a3 1
# $OpenBSD: pkg_delete,v 1.12 2003/11/09 15:42:48 espie Exp $
d383 2
a384 1
		print "Deleting $pkgname\n";
@


1.12
log
@fix semantics to match old tools. This prefix is what was passed on
the command line, not the first cwd in the archive, sorry.

No way to override this currently.

To be safe,
- packages would need to be built with a specific base.
- packages would need to be installed with the same base.

Somewhat the same semantic difference as with LOCALBASE/PREFIX.
@
text
@d3 1
a3 1
# $OpenBSD: pkg_delete,v 1.11 2003/11/06 18:42:01 espie Exp $
d386 1
@


1.11
log
@set env PKG_PREFIX for compatibility with old tools.
@
text
@d3 1
a3 1
# $OpenBSD: pkg_delete,v 1.10 2003/11/06 17:49:31 espie Exp $
d275 1
a275 1
	$ENV{'PKG_PREFIX'} = $plist->prefix();
@


1.10
log
@Allow the use of full paths to refer to installed packages, so that
pkg_delete /var/db/pkg/zsh-*/  works.
@
text
@d3 1
a3 1
# $OpenBSD: pkg_delete,v 1.9 2003/11/04 17:55:17 espie Exp $
d275 1
@


1.9
log
@let pkg_delete use logging facilities to save issues with deleting files
(mostly md5 problems for now)

okay sturm@@
@
text
@d3 1
a3 1
# $OpenBSD: pkg_delete,v 1.8 2003/11/03 11:05:55 espie Exp $
d336 1
a336 1
	push(@@realnames, $pkgname);
@


1.8
log
@canonpath strips ending /, rely on unstripped name for @@extra.
found out by naddy@@
@
text
@d3 1
a3 1
# $OpenBSD: pkg_delete,v 1.6 2003/10/28 17:26:01 espie Exp $
d34 1
d45 10
d101 5
a105 2
			rmdir($name) 
			    or print "Error deleting directory $name\n";
d146 2
d158 2
d168 5
a172 1
	unlink($name) or print "problem deleting $name\n";
d348 2
d383 1
d392 5
@


1.7
log
@fix logic wrt pkgstems and dependencies.
ok sturm@@
@
text
@d159 1
a159 1
	if ($name =~ s|/$||) {
@


1.6
log
@let pkg_delete evaluate dependencies earlier: check that all packages
that the user wants removed are actually a complete set with respect
to dependencies. Otherwise, report a list of packages that would
have to be removed as well for this pkg_delete to work, and stop right
there.

okay naddy@@
@
text
@d3 1
a3 1
# $OpenBSD: pkg_delete,v 1.5 2003/10/27 22:46:23 espie Exp $
d294 3
a296 1
my (%toremove, %extra_rm);
d298 1
a299 6
	$toremove{$pkgname} = 1;
}
my @@todo;
push(@@todo, @@ARGV);

while (my $pkgname = pop @@todo) {
d314 13
d345 1
d348 1
a348 1
	for my $pkgname (@@ARGV) {
a349 10
		unless (is_installed($pkgname)) {
			if (OpenBSD::PackageName::is_stem($pkgname)) {
			    my @@l = OpenBSD::PackageName::findstem($pkgname, installed_packages());
			    if (@@l == 1) {
			    	$pkgname = $l[0];
			    } elsif (@@l != 0) {
			    	print "Ambiguous: $pkgname could be ", join(' ', @@l),"\n";
			    }
			}
		}
@


1.5
log
@extra block around do while loop.
perl quick: this is needed for last to work.

Found out by sturm@@
@
text
@d3 1
a3 1
# $OpenBSD: pkg_delete,v 1.4 2003/10/23 23:11:22 espie Exp $
d100 1
a100 1
			join(",", @@$entry), "\n";
d293 42
d356 1
a356 5
		if (@@$deps > 0) {
			print "Can't remove $pkgname yet, ";
			print "needed by ", join(',', @@$deps), "\n";
			next;
		}
@


1.4
log
@Typo. Fix removal for multiple times the same dependency.
@
text
@d3 1
a3 1
# $OpenBSD: pkg_delete,v 1.3 2003/10/23 17:48:07 espie Exp $
d293 1
a293 1
do {
d327 1
a327 1
} while ($removed);
@


1.3
log
@missing space in DEINSTALL message.
allow pkg_delete stem to work, unless ambiguous.
put all pkg_info's work into a single function, so that
pkg_info autoconf will work.

ok fries@@ sturm@@
@
text
@d3 1
a3 1
# $OpenBSD: pkg_delete,v 1.2 2003/10/19 18:42:55 espie Exp $
d269 1
a269 1
		$removed->{name} = 1;
@


1.2
log
@plist's has/get methods for accessing elements: perl ->{} has quirks
that make it unusable for looking up constants correctly.
@
text
@d3 1
a3 1
# $OpenBSD: pkg_delete,v 1.1.1.1 2003/10/16 17:43:34 espie Exp $
d216 1
a216 1
	print "Deinstall script: $dir",DEINSTALL ,"$pkgname DEINSTALL\n" if $opt_v or $opt_n;
d297 10
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
# $OpenBSD: pkg_delete,v 1.1.1.1 2003/10/16 17:16:30 espie Exp $
d253 2
a254 5
	if ($plist->{OpenBSD::PackageInfo::REQUIRE}) {
		$plist->{OpenBSD::PackageInfo::REQUIRE}->delete($state);
	}
	if ($plist->{OpenBSD::PackageInfo::DEINSTALL}) {
		$plist->{OpenBSD::PackageInfo::DEINSTALL}->delete($state);
d256 3
@


1.1.1.1
log
@new import of my pkgtools, after a slight naming disagreement with the
Upper Management...
@
text
@@
