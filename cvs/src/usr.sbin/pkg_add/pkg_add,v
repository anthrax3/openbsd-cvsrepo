head	1.483;
access;
symbols
	OPENBSD_6_2_BASE:1.483
	OPENBSD_6_1:1.483.0.12
	OPENBSD_6_1_BASE:1.483
	OPENBSD_6_0:1.483.0.10
	OPENBSD_6_0_BASE:1.483
	OPENBSD_5_9:1.483.0.4
	OPENBSD_5_9_BASE:1.483
	OPENBSD_5_8:1.483.0.6
	OPENBSD_5_8_BASE:1.483
	OPENBSD_5_7:1.483.0.2
	OPENBSD_5_7_BASE:1.483
	OPENBSD_5_6:1.482.0.6
	OPENBSD_5_6_BASE:1.482
	OPENBSD_5_5:1.482.0.4
	OPENBSD_5_5_BASE:1.482
	OPENBSD_5_4:1.481.0.4
	OPENBSD_5_4_BASE:1.481
	OPENBSD_5_3:1.481.0.2
	OPENBSD_5_3_BASE:1.481
	OPENBSD_5_2:1.480.0.2
	OPENBSD_5_2_BASE:1.480
	OPENBSD_4_7:1.473.0.2
	OPENBSD_4_7_BASE:1.473
	OPENBSD_4_6:1.336.0.4
	OPENBSD_4_6_BASE:1.336
	OPENBSD_4_5:1.332.0.4
	OPENBSD_4_5_BASE:1.332
	OPENBSD_4_4:1.332.0.2
	OPENBSD_4_4_BASE:1.332
	OPENBSD_4_3:1.329.0.2
	OPENBSD_4_3_BASE:1.329
	OPENBSD_4_2:1.328.0.2
	OPENBSD_4_2_BASE:1.328
	OPENBSD_4_1:1.224.0.2
	OPENBSD_4_1_BASE:1.224
	OPENBSD_4_0:1.218.0.2
	OPENBSD_4_0_BASE:1.218
	OPENBSD_3_9:1.216.0.2
	OPENBSD_3_9_BASE:1.216
	OPENBSD_3_8:1.196.0.2
	OPENBSD_3_8_BASE:1.196
	OPENBSD_3_7:1.173.0.2
	OPENBSD_3_7_BASE:1.173
	OPENBSD_3_6:1.50.0.2
	OPENBSD_3_6_BASE:1.50
	OPENBSD_3_5:1.29.0.2
	OPENBSD_3_5_BASE:1.29
	pkgtools:1.1.1.1
	espie:1.1.1;
locks; strict;
comment	@# @;


1.483
date	2014.12.27.23.59.44;	author espie;	state Exp;
branches;
next	1.482;
commitid	dHBr3g8Yo4IQjolo;

1.482
date	2014.01.23.11.45.22;	author espie;	state Exp;
branches;
next	1.481;

1.481
date	2012.08.06.00.00.28;	author fgsch;	state Exp;
branches;
next	1.480;

1.480
date	2012.07.13.16.47.49;	author deraadt;	state Exp;
branches;
next	1.479;

1.479
date	2010.06.04.13.19.39;	author espie;	state dead;
branches;
next	1.478;

1.478
date	2010.05.10.09.17.54;	author espie;	state Exp;
branches;
next	1.477;

1.477
date	2010.04.17.16.07.18;	author espie;	state Exp;
branches;
next	1.476;

1.476
date	2010.04.10.10.18.12;	author espie;	state Exp;
branches;
next	1.475;

1.475
date	2010.04.05.13.46.24;	author espie;	state Exp;
branches;
next	1.474;

1.474
date	2010.03.22.20.38.44;	author espie;	state Exp;
branches;
next	1.473;

1.473
date	2010.03.06.11.36.53;	author espie;	state Exp;
branches;
next	1.472;

1.472
date	2010.03.01.12.29.31;	author espie;	state Exp;
branches;
next	1.471;

1.471
date	2010.01.26.11.31.08;	author espie;	state Exp;
branches;
next	1.470;

1.470
date	2010.01.12.20.14.09;	author espie;	state Exp;
branches;
next	1.469;

1.469
date	2010.01.12.10.57.05;	author espie;	state Exp;
branches;
next	1.468;

1.468
date	2010.01.11.13.40.58;	author espie;	state Exp;
branches;
next	1.467;

1.467
date	2010.01.11.12.49.53;	author espie;	state Exp;
branches;
next	1.466;

1.466
date	2010.01.11.12.25.38;	author espie;	state Exp;
branches;
next	1.465;

1.465
date	2010.01.10.21.27.59;	author espie;	state Exp;
branches;
next	1.464;

1.464
date	2010.01.10.16.03.49;	author espie;	state Exp;
branches;
next	1.463;

1.463
date	2010.01.05.12.01.07;	author espie;	state Exp;
branches;
next	1.462;

1.462
date	2010.01.05.11.42.45;	author espie;	state Exp;
branches;
next	1.461;

1.461
date	2010.01.05.11.31.07;	author espie;	state Exp;
branches;
next	1.460;

1.460
date	2010.01.04.00.10.52;	author espie;	state Exp;
branches;
next	1.459;

1.459
date	2010.01.02.16.51.51;	author espie;	state Exp;
branches;
next	1.458;

1.458
date	2010.01.02.12.52.18;	author espie;	state Exp;
branches;
next	1.457;

1.457
date	2010.01.01.13.41.49;	author espie;	state Exp;
branches;
next	1.456;

1.456
date	2010.01.01.11.49.55;	author espie;	state Exp;
branches;
next	1.455;

1.455
date	2010.01.01.02.19.20;	author espie;	state Exp;
branches;
next	1.454;

1.454
date	2009.12.31.13.48.52;	author espie;	state Exp;
branches;
next	1.453;

1.453
date	2009.12.31.12.38.19;	author espie;	state Exp;
branches;
next	1.452;

1.452
date	2009.12.30.23.45.57;	author espie;	state Exp;
branches;
next	1.451;

1.451
date	2009.12.30.09.41.44;	author espie;	state Exp;
branches;
next	1.450;

1.450
date	2009.12.29.20.52.44;	author espie;	state Exp;
branches;
next	1.449;

1.449
date	2009.12.29.18.16.14;	author espie;	state Exp;
branches;
next	1.448;

1.448
date	2009.12.29.14.29.49;	author espie;	state Exp;
branches;
next	1.447;

1.447
date	2009.12.29.14.15.53;	author espie;	state Exp;
branches;
next	1.446;

1.446
date	2009.12.29.14.11.46;	author espie;	state Exp;
branches;
next	1.445;

1.445
date	2009.12.29.13.58.18;	author espie;	state Exp;
branches;
next	1.444;

1.444
date	2009.12.28.21.29.42;	author espie;	state Exp;
branches;
next	1.443;

1.443
date	2009.12.28.19.27.58;	author espie;	state Exp;
branches;
next	1.442;

1.442
date	2009.12.28.14.38.51;	author espie;	state Exp;
branches;
next	1.441;

1.441
date	2009.12.28.12.51.26;	author espie;	state Exp;
branches;
next	1.440;

1.440
date	2009.12.28.10.42.02;	author espie;	state Exp;
branches;
next	1.439;

1.439
date	2009.12.27.22.27.03;	author espie;	state Exp;
branches;
next	1.438;

1.438
date	2009.12.27.01.24.42;	author espie;	state Exp;
branches;
next	1.437;

1.437
date	2009.12.26.21.15.51;	author espie;	state Exp;
branches;
next	1.436;

1.436
date	2009.12.26.17.05.43;	author espie;	state Exp;
branches;
next	1.435;

1.435
date	2009.12.26.17.00.49;	author espie;	state Exp;
branches;
next	1.434;

1.434
date	2009.12.21.17.15.46;	author espie;	state Exp;
branches;
next	1.433;

1.433
date	2009.12.21.11.03.00;	author espie;	state Exp;
branches;
next	1.432;

1.432
date	2009.12.21.10.38.58;	author espie;	state Exp;
branches;
next	1.431;

1.431
date	2009.12.20.22.38.45;	author espie;	state Exp;
branches;
next	1.430;

1.430
date	2009.12.19.14.21.14;	author espie;	state Exp;
branches;
next	1.429;

1.429
date	2009.12.19.09.21.04;	author espie;	state Exp;
branches;
next	1.428;

1.428
date	2009.12.17.21.33.20;	author espie;	state Exp;
branches;
next	1.427;

1.427
date	2009.12.14.18.11.26;	author espie;	state Exp;
branches;
next	1.426;

1.426
date	2009.12.14.09.35.56;	author espie;	state Exp;
branches;
next	1.425;

1.425
date	2009.12.14.09.13.17;	author espie;	state Exp;
branches;
next	1.424;

1.424
date	2009.12.13.17.58.54;	author espie;	state Exp;
branches;
next	1.423;

1.423
date	2009.12.13.17.54.15;	author espie;	state Exp;
branches;
next	1.422;

1.422
date	2009.12.12.16.42.04;	author espie;	state Exp;
branches;
next	1.421;

1.421
date	2009.12.12.07.06.09;	author espie;	state Exp;
branches;
next	1.420;

1.420
date	2009.12.11.21.04.01;	author espie;	state Exp;
branches;
next	1.419;

1.419
date	2009.12.07.13.41.02;	author espie;	state Exp;
branches;
next	1.418;

1.418
date	2009.12.06.07.53.07;	author jmc;	state Exp;
branches;
next	1.417;

1.417
date	2009.12.05.23.13.01;	author espie;	state Exp;
branches;
next	1.416;

1.416
date	2009.12.05.14.41.03;	author espie;	state Exp;
branches;
next	1.415;

1.415
date	2009.12.05.11.19.43;	author espie;	state Exp;
branches;
next	1.414;

1.414
date	2009.12.05.10.54.11;	author espie;	state Exp;
branches;
next	1.413;

1.413
date	2009.12.05.10.10.40;	author espie;	state Exp;
branches;
next	1.412;

1.412
date	2009.12.05.09.26.41;	author espie;	state Exp;
branches;
next	1.411;

1.411
date	2009.12.04.10.52.31;	author espie;	state Exp;
branches;
next	1.410;

1.410
date	2009.12.04.10.48.14;	author espie;	state Exp;
branches;
next	1.409;

1.409
date	2009.12.02.11.36.27;	author espie;	state Exp;
branches;
next	1.408;

1.408
date	2009.12.01.09.53.09;	author espie;	state Exp;
branches;
next	1.407;

1.407
date	2009.12.01.08.13.23;	author espie;	state Exp;
branches;
next	1.406;

1.406
date	2009.11.30.16.15.13;	author espie;	state Exp;
branches;
next	1.405;

1.405
date	2009.11.30.15.49.52;	author espie;	state Exp;
branches;
next	1.404;

1.404
date	2009.11.29.14.07.07;	author espie;	state Exp;
branches;
next	1.403;

1.403
date	2009.11.29.13.19.29;	author espie;	state Exp;
branches;
next	1.402;

1.402
date	2009.11.29.11.22.25;	author espie;	state Exp;
branches;
next	1.401;

1.401
date	2009.11.29.07.54.18;	author espie;	state Exp;
branches;
next	1.400;

1.400
date	2009.11.29.06.51.12;	author espie;	state Exp;
branches;
next	1.399;

1.399
date	2009.11.28.17.16.59;	author espie;	state Exp;
branches;
next	1.398;

1.398
date	2009.11.28.12.50.25;	author espie;	state Exp;
branches;
next	1.397;

1.397
date	2009.11.28.10.27.07;	author espie;	state Exp;
branches;
next	1.396;

1.396
date	2009.11.24.11.41.56;	author espie;	state Exp;
branches;
next	1.395;

1.395
date	2009.11.24.10.39.35;	author espie;	state Exp;
branches;
next	1.394;

1.394
date	2009.11.24.10.32.33;	author espie;	state Exp;
branches;
next	1.393;

1.393
date	2009.11.22.16.52.00;	author espie;	state Exp;
branches;
next	1.392;

1.392
date	2009.11.22.14.08.21;	author espie;	state Exp;
branches;
next	1.391;

1.391
date	2009.11.22.09.18.55;	author espie;	state Exp;
branches;
next	1.390;

1.390
date	2009.11.17.10.54.27;	author espie;	state Exp;
branches;
next	1.389;

1.389
date	2009.11.17.10.17.21;	author espie;	state Exp;
branches;
next	1.388;

1.388
date	2009.11.16.23.02.36;	author espie;	state Exp;
branches;
next	1.387;

1.387
date	2009.11.16.15.01.30;	author espie;	state Exp;
branches;
next	1.386;

1.386
date	2009.11.16.14.47.05;	author espie;	state Exp;
branches;
next	1.385;

1.385
date	2009.11.16.12.53.27;	author espie;	state Exp;
branches;
next	1.384;

1.384
date	2009.11.16.12.32.16;	author espie;	state Exp;
branches;
next	1.383;

1.383
date	2009.11.16.12.20.32;	author espie;	state Exp;
branches;
next	1.382;

1.382
date	2009.11.14.10.47.16;	author espie;	state Exp;
branches;
next	1.381;

1.381
date	2009.11.12.14.44.00;	author espie;	state Exp;
branches;
next	1.380;

1.380
date	2009.11.11.12.42.17;	author espie;	state Exp;
branches;
next	1.379;

1.379
date	2009.11.11.12.32.03;	author espie;	state Exp;
branches;
next	1.378;

1.378
date	2009.11.11.12.21.20;	author espie;	state Exp;
branches;
next	1.377;

1.377
date	2009.11.11.12.04.18;	author espie;	state Exp;
branches;
next	1.376;

1.376
date	2009.11.11.11.13.16;	author espie;	state Exp;
branches;
next	1.375;

1.375
date	2009.11.10.11.36.56;	author espie;	state Exp;
branches;
next	1.374;

1.374
date	2009.11.09.17.47.59;	author espie;	state Exp;
branches;
next	1.373;

1.373
date	2009.11.08.12.16.23;	author espie;	state Exp;
branches;
next	1.372;

1.372
date	2009.11.08.11.18.41;	author espie;	state Exp;
branches;
next	1.371;

1.371
date	2009.11.08.10.46.11;	author espie;	state Exp;
branches;
next	1.370;

1.370
date	2009.11.08.09.39.21;	author espie;	state Exp;
branches;
next	1.369;

1.369
date	2009.11.04.16.50.02;	author espie;	state Exp;
branches;
next	1.368;

1.368
date	2009.11.03.13.00.37;	author espie;	state Exp;
branches;
next	1.367;

1.367
date	2009.11.03.10.15.18;	author espie;	state Exp;
branches;
next	1.366;

1.366
date	2009.10.27.11.43.31;	author espie;	state Exp;
branches;
next	1.365;

1.365
date	2009.10.21.10.26.16;	author espie;	state Exp;
branches;
next	1.364;

1.364
date	2009.10.21.10.22.58;	author espie;	state Exp;
branches;
next	1.363;

1.363
date	2009.10.19.14.20.55;	author espie;	state Exp;
branches;
next	1.362;

1.362
date	2009.10.19.14.15.40;	author espie;	state Exp;
branches;
next	1.361;

1.361
date	2009.10.19.14.07.26;	author espie;	state Exp;
branches;
next	1.360;

1.360
date	2009.10.19.14.00.10;	author espie;	state Exp;
branches;
next	1.359;

1.359
date	2009.10.19.09.29.53;	author espie;	state Exp;
branches;
next	1.358;

1.358
date	2009.10.19.09.19.44;	author espie;	state Exp;
branches;
next	1.357;

1.357
date	2009.10.15.23.23.35;	author espie;	state Exp;
branches;
next	1.356;

1.356
date	2009.10.15.20.51.28;	author espie;	state Exp;
branches;
next	1.355;

1.355
date	2009.10.15.18.32.11;	author espie;	state Exp;
branches;
next	1.354;

1.354
date	2009.10.15.18.17.18;	author espie;	state Exp;
branches;
next	1.353;

1.353
date	2009.10.15.10.45.47;	author espie;	state Exp;
branches;
next	1.352;

1.352
date	2009.10.14.22.59.34;	author espie;	state Exp;
branches;
next	1.351;

1.351
date	2009.10.14.18.22.41;	author espie;	state Exp;
branches;
next	1.350;

1.350
date	2009.10.14.13.46.25;	author espie;	state Exp;
branches;
next	1.349;

1.349
date	2009.10.14.11.16.15;	author espie;	state Exp;
branches;
next	1.348;

1.348
date	2009.10.14.11.08.16;	author espie;	state Exp;
branches;
next	1.347;

1.347
date	2009.10.14.11.06.41;	author espie;	state Exp;
branches;
next	1.346;

1.346
date	2009.10.13.22.16.31;	author espie;	state Exp;
branches;
next	1.345;

1.345
date	2009.10.13.21.21.07;	author espie;	state Exp;
branches;
next	1.344;

1.344
date	2009.10.13.12.57.14;	author espie;	state Exp;
branches;
next	1.343;

1.343
date	2009.10.12.05.17.33;	author jmc;	state Exp;
branches;
next	1.342;

1.342
date	2009.10.11.22.08.27;	author espie;	state Exp;
branches;
next	1.341;

1.341
date	2009.10.11.13.54.41;	author espie;	state Exp;
branches;
next	1.340;

1.340
date	2009.10.11.12.56.13;	author espie;	state Exp;
branches;
next	1.339;

1.339
date	2009.10.11.11.07.55;	author espie;	state Exp;
branches;
next	1.338;

1.338
date	2009.10.11.11.01.44;	author espie;	state Exp;
branches;
next	1.337;

1.337
date	2009.10.11.10.49.05;	author espie;	state Exp;
branches;
next	1.336;

1.336
date	2009.05.24.11.05.24;	author espie;	state Exp;
branches;
next	1.335;

1.335
date	2009.04.20.08.29.02;	author espie;	state Exp;
branches;
next	1.334;

1.334
date	2009.04.19.14.58.32;	author espie;	state Exp;
branches;
next	1.333;

1.333
date	2009.04.14.17.53.58;	author espie;	state Exp;
branches;
next	1.332;

1.332
date	2008.06.21.14.01.10;	author espie;	state Exp;
branches;
next	1.331;

1.331
date	2008.03.08.12.07.45;	author espie;	state Exp;
branches;
next	1.330;

1.330
date	2008.03.08.11.32.38;	author espie;	state Exp;
branches;
next	1.329;

1.329
date	2007.12.18.10.58.46;	author espie;	state Exp;
branches;
next	1.328;

1.328
date	2007.06.30.11.38.38;	author espie;	state Exp;
branches;
next	1.327;

1.327
date	2007.06.26.17.58.23;	author espie;	state Exp;
branches;
next	1.326;

1.326
date	2007.06.26.14.40.25;	author espie;	state Exp;
branches;
next	1.325;

1.325
date	2007.06.17.10.44.01;	author espie;	state Exp;
branches;
next	1.324;

1.324
date	2007.06.16.11.50.48;	author espie;	state Exp;
branches;
next	1.323;

1.323
date	2007.06.16.09.29.37;	author espie;	state Exp;
branches;
next	1.322;

1.322
date	2007.06.11.09.23.20;	author espie;	state Exp;
branches;
next	1.321;

1.321
date	2007.06.11.09.12.27;	author espie;	state Exp;
branches;
next	1.320;

1.320
date	2007.06.10.16.05.49;	author espie;	state Exp;
branches;
next	1.319;

1.319
date	2007.06.10.15.24.36;	author espie;	state Exp;
branches;
next	1.318;

1.318
date	2007.06.10.15.11.05;	author espie;	state Exp;
branches;
next	1.317;

1.317
date	2007.06.10.14.52.29;	author espie;	state Exp;
branches;
next	1.316;

1.316
date	2007.06.09.13.39.31;	author espie;	state Exp;
branches;
next	1.315;

1.315
date	2007.06.09.11.16.54;	author espie;	state Exp;
branches;
next	1.314;

1.314
date	2007.06.09.10.30.53;	author espie;	state Exp;
branches;
next	1.313;

1.313
date	2007.06.07.20.30.03;	author espie;	state Exp;
branches;
next	1.312;

1.312
date	2007.06.07.12.57.33;	author espie;	state Exp;
branches;
next	1.311;

1.311
date	2007.06.05.23.19.00;	author espie;	state Exp;
branches;
next	1.310;

1.310
date	2007.06.04.14.57.33;	author espie;	state Exp;
branches;
next	1.309;

1.309
date	2007.06.04.14.40.39;	author espie;	state Exp;
branches;
next	1.308;

1.308
date	2007.06.02.12.37.37;	author espie;	state Exp;
branches;
next	1.307;

1.307
date	2007.06.02.12.21.14;	author espie;	state Exp;
branches;
next	1.306;

1.306
date	2007.06.02.11.24.22;	author espie;	state Exp;
branches;
next	1.305;

1.305
date	2007.06.02.11.18.46;	author espie;	state Exp;
branches;
next	1.304;

1.304
date	2007.06.02.10.29.44;	author espie;	state Exp;
branches;
next	1.303;

1.303
date	2007.06.01.22.35.46;	author espie;	state Exp;
branches;
next	1.302;

1.302
date	2007.06.01.21.50.46;	author espie;	state Exp;
branches;
next	1.301;

1.301
date	2007.06.01.21.37.56;	author espie;	state Exp;
branches;
next	1.300;

1.300
date	2007.06.01.14.58.29;	author espie;	state Exp;
branches;
next	1.299;

1.299
date	2007.05.31.16.50.43;	author espie;	state Exp;
branches;
next	1.298;

1.298
date	2007.05.31.16.48.18;	author espie;	state Exp;
branches;
next	1.297;

1.297
date	2007.05.31.13.33.17;	author espie;	state Exp;
branches;
next	1.296;

1.296
date	2007.05.31.10.04.03;	author espie;	state Exp;
branches;
next	1.295;

1.295
date	2007.05.30.16.32.14;	author espie;	state Exp;
branches;
next	1.294;

1.294
date	2007.05.30.14.10.08;	author espie;	state Exp;
branches;
next	1.293;

1.293
date	2007.05.30.14.04.51;	author espie;	state Exp;
branches;
next	1.292;

1.292
date	2007.05.30.12.52.06;	author espie;	state Exp;
branches;
next	1.291;

1.291
date	2007.05.30.11.40.07;	author espie;	state Exp;
branches;
next	1.290;

1.290
date	2007.05.29.14.52.48;	author espie;	state Exp;
branches;
next	1.289;

1.289
date	2007.05.29.14.39.03;	author espie;	state Exp;
branches;
next	1.288;

1.288
date	2007.05.29.13.52.07;	author espie;	state Exp;
branches;
next	1.287;

1.287
date	2007.05.29.13.15.23;	author espie;	state Exp;
branches;
next	1.286;

1.286
date	2007.05.28.13.55.34;	author espie;	state Exp;
branches;
next	1.285;

1.285
date	2007.05.28.12.44.41;	author espie;	state Exp;
branches;
next	1.284;

1.284
date	2007.05.28.11.29.09;	author espie;	state Exp;
branches;
next	1.283;

1.283
date	2007.05.28.11.15.10;	author espie;	state Exp;
branches;
next	1.282;

1.282
date	2007.05.27.22.34.24;	author espie;	state Exp;
branches;
next	1.281;

1.281
date	2007.05.27.22.18.14;	author espie;	state Exp;
branches;
next	1.280;

1.280
date	2007.05.27.22.04.17;	author espie;	state Exp;
branches;
next	1.279;

1.279
date	2007.05.27.21.43.06;	author espie;	state Exp;
branches;
next	1.278;

1.278
date	2007.05.27.21.33.55;	author espie;	state Exp;
branches;
next	1.277;

1.277
date	2007.05.27.11.36.21;	author espie;	state Exp;
branches;
next	1.276;

1.276
date	2007.05.27.11.31.35;	author espie;	state Exp;
branches;
next	1.275;

1.275
date	2007.05.27.11.21.55;	author espie;	state Exp;
branches;
next	1.274;

1.274
date	2007.05.27.11.02.03;	author espie;	state Exp;
branches;
next	1.273;

1.273
date	2007.05.27.10.38.12;	author espie;	state Exp;
branches;
next	1.272;

1.272
date	2007.05.27.09.59.41;	author espie;	state Exp;
branches;
next	1.271;

1.271
date	2007.05.27.09.48.05;	author espie;	state Exp;
branches;
next	1.270;

1.270
date	2007.05.26.23.55.53;	author espie;	state Exp;
branches;
next	1.269;

1.269
date	2007.05.26.23.45.44;	author espie;	state Exp;
branches;
next	1.268;

1.268
date	2007.05.26.12.25.29;	author espie;	state Exp;
branches;
next	1.267;

1.267
date	2007.05.26.12.22.38;	author espie;	state Exp;
branches;
next	1.266;

1.266
date	2007.05.26.12.15.45;	author espie;	state Exp;
branches;
next	1.265;

1.265
date	2007.05.25.13.25.50;	author espie;	state Exp;
branches;
next	1.264;

1.264
date	2007.05.25.13.18.56;	author espie;	state Exp;
branches;
next	1.263;

1.263
date	2007.05.25.10.08.12;	author espie;	state Exp;
branches;
next	1.262;

1.262
date	2007.05.25.09.50.31;	author espie;	state Exp;
branches;
next	1.261;

1.261
date	2007.05.23.10.33.45;	author espie;	state Exp;
branches;
next	1.260;

1.260
date	2007.05.22.10.47.40;	author espie;	state Exp;
branches;
next	1.259;

1.259
date	2007.05.22.10.11.58;	author espie;	state Exp;
branches;
next	1.258;

1.258
date	2007.05.20.14.40.50;	author espie;	state Exp;
branches;
next	1.257;

1.257
date	2007.05.20.14.21.33;	author espie;	state Exp;
branches;
next	1.256;

1.256
date	2007.05.20.14.04.39;	author espie;	state Exp;
branches;
next	1.255;

1.255
date	2007.05.20.11.06.44;	author espie;	state Exp;
branches;
next	1.254;

1.254
date	2007.05.19.23.40.46;	author espie;	state Exp;
branches;
next	1.253;

1.253
date	2007.05.18.09.45.18;	author espie;	state Exp;
branches;
next	1.252;

1.252
date	2007.05.17.15.40.06;	author espie;	state Exp;
branches;
next	1.251;

1.251
date	2007.05.17.15.35.58;	author espie;	state Exp;
branches;
next	1.250;

1.250
date	2007.05.17.14.13.40;	author espie;	state Exp;
branches;
next	1.249;

1.249
date	2007.05.17.14.08.49;	author espie;	state Exp;
branches;
next	1.248;

1.248
date	2007.05.17.13.36.21;	author espie;	state Exp;
branches;
next	1.247;

1.247
date	2007.05.14.18.19.25;	author espie;	state Exp;
branches;
next	1.246;

1.246
date	2007.05.14.17.52.08;	author espie;	state Exp;
branches;
next	1.245;

1.245
date	2007.05.14.11.22.00;	author espie;	state Exp;
branches;
next	1.244;

1.244
date	2007.05.14.11.02.14;	author espie;	state Exp;
branches;
next	1.243;

1.243
date	2007.05.14.10.53.31;	author espie;	state Exp;
branches;
next	1.242;

1.242
date	2007.05.14.10.43.45;	author espie;	state Exp;
branches;
next	1.241;

1.241
date	2007.05.14.09.49.27;	author espie;	state Exp;
branches;
next	1.240;

1.240
date	2007.05.13.13.32.36;	author espie;	state Exp;
branches;
next	1.239;

1.239
date	2007.05.13.10.43.33;	author espie;	state Exp;
branches;
next	1.238;

1.238
date	2007.05.12.14.48.45;	author espie;	state Exp;
branches;
next	1.237;

1.237
date	2007.05.07.14.21.39;	author espie;	state Exp;
branches;
next	1.236;

1.236
date	2007.05.07.14.12.43;	author espie;	state Exp;
branches;
next	1.235;

1.235
date	2007.05.07.13.51.58;	author espie;	state Exp;
branches;
next	1.234;

1.234
date	2007.05.07.12.19.04;	author espie;	state Exp;
branches;
next	1.233;

1.233
date	2007.05.07.08.10.45;	author espie;	state Exp;
branches;
next	1.232;

1.232
date	2007.05.07.08.05.23;	author espie;	state Exp;
branches;
next	1.231;

1.231
date	2007.05.03.14.47.29;	author espie;	state Exp;
branches;
next	1.230;

1.230
date	2007.05.02.15.17.36;	author espie;	state Exp;
branches;
next	1.229;

1.229
date	2007.05.02.13.59.19;	author espie;	state Exp;
branches;
next	1.228;

1.228
date	2007.05.01.18.22.20;	author espie;	state Exp;
branches;
next	1.227;

1.227
date	2007.04.21.09.57.22;	author espie;	state Exp;
branches;
next	1.226;

1.226
date	2007.04.15.10.17.29;	author espie;	state Exp;
branches;
next	1.225;

1.225
date	2007.03.27.22.41.07;	author espie;	state Exp;
branches;
next	1.224;

1.224
date	2007.03.07.11.24.07;	author espie;	state Exp;
branches;
next	1.223;

1.223
date	2007.03.07.00.09.46;	author espie;	state Exp;
branches;
next	1.222;

1.222
date	2007.03.06.23.35.01;	author espie;	state Exp;
branches;
next	1.221;

1.221
date	2007.02.04.12.46.54;	author espie;	state Exp;
branches;
next	1.220;

1.220
date	2006.11.17.15.34.15;	author espie;	state Exp;
branches;
next	1.219;

1.219
date	2006.10.17.21.47.22;	author espie;	state Exp;
branches;
next	1.218;

1.218
date	2006.08.25.08.42.38;	author espie;	state Exp;
branches;
next	1.217;

1.217
date	2006.03.04.11.31.18;	author espie;	state Exp;
branches;
next	1.216;

1.216
date	2006.02.10.11.42.51;	author espie;	state Exp;
branches;
next	1.215;

1.215
date	2006.02.10.10.08.16;	author bernd;	state Exp;
branches;
next	1.214;

1.214
date	2006.02.09.09.40.31;	author espie;	state Exp;
branches;
next	1.213;

1.213
date	2006.02.07.10.34.56;	author bernd;	state Exp;
branches;
next	1.212;

1.212
date	2006.01.17.20.46.52;	author espie;	state Exp;
branches;
next	1.211;

1.211
date	2005.11.03.11.50.32;	author espie;	state Exp;
branches;
next	1.210;

1.210
date	2005.10.24.08.55.59;	author espie;	state Exp;
branches;
next	1.209;

1.209
date	2005.10.24.07.16.35;	author espie;	state Exp;
branches;
next	1.208;

1.208
date	2005.10.22.17.44.07;	author espie;	state Exp;
branches;
next	1.207;

1.207
date	2005.10.22.15.01.54;	author espie;	state Exp;
branches;
next	1.206;

1.206
date	2005.10.10.11.06.04;	author espie;	state Exp;
branches;
next	1.205;

1.205
date	2005.10.10.11.02.19;	author espie;	state Exp;
branches;
next	1.204;

1.204
date	2005.10.10.09.33.56;	author espie;	state Exp;
branches;
next	1.203;

1.203
date	2005.09.19.10.19.45;	author espie;	state Exp;
branches;
next	1.202;

1.202
date	2005.09.14.10.16.08;	author espie;	state Exp;
branches;
next	1.201;

1.201
date	2005.09.13.20.57.14;	author espie;	state Exp;
branches;
next	1.200;

1.200
date	2005.09.07.09.11.22;	author jmc;	state Exp;
branches;
next	1.199;

1.199
date	2005.09.05.11.41.03;	author espie;	state Exp;
branches;
next	1.198;

1.198
date	2005.09.04.22.53.51;	author espie;	state Exp;
branches;
next	1.197;

1.197
date	2005.09.04.22.47.56;	author espie;	state Exp;
branches;
next	1.196;

1.196
date	2005.08.29.00.42.58;	author espie;	state Exp;
branches;
next	1.195;

1.195
date	2005.08.22.12.18.06;	author espie;	state Exp;
branches;
next	1.194;

1.194
date	2005.08.22.11.37.23;	author espie;	state Exp;
branches;
next	1.193;

1.193
date	2005.08.17.18.48.10;	author espie;	state Exp;
branches;
next	1.192;

1.192
date	2005.08.17.18.24.52;	author espie;	state Exp;
branches;
next	1.191;

1.191
date	2005.08.17.11.01.07;	author espie;	state Exp;
branches;
next	1.190;

1.190
date	2005.08.17.10.45.13;	author espie;	state Exp;
branches;
next	1.189;

1.189
date	2005.08.17.10.00.18;	author espie;	state Exp;
branches;
next	1.188;

1.188
date	2005.08.17.09.24.53;	author espie;	state Exp;
branches;
next	1.187;

1.187
date	2005.08.16.21.48.34;	author espie;	state Exp;
branches;
next	1.186;

1.186
date	2005.08.16.20.05.12;	author espie;	state Exp;
branches;
next	1.185;

1.185
date	2005.08.16.16.24.23;	author espie;	state Exp;
branches;
next	1.184;

1.184
date	2005.08.16.16.15.28;	author espie;	state Exp;
branches;
next	1.183;

1.183
date	2005.08.16.13.52.15;	author espie;	state Exp;
branches;
next	1.182;

1.182
date	2005.08.16.12.05.58;	author espie;	state Exp;
branches;
next	1.181;

1.181
date	2005.08.16.11.25.48;	author espie;	state Exp;
branches;
next	1.180;

1.180
date	2005.08.16.10.28.53;	author espie;	state Exp;
branches;
next	1.179;

1.179
date	2005.08.14.09.06.53;	author espie;	state Exp;
branches;
next	1.178;

1.178
date	2005.08.14.09.03.37;	author espie;	state Exp;
branches;
next	1.177;

1.177
date	2005.08.07.16.25.35;	author espie;	state Exp;
branches;
next	1.176;

1.176
date	2005.07.24.11.50.03;	author espie;	state Exp;
branches;
next	1.175;

1.175
date	2005.06.29.22.54.31;	author espie;	state Exp;
branches;
next	1.174;

1.174
date	2005.06.26.11.25.11;	author espie;	state Exp;
branches;
next	1.173;

1.173
date	2005.03.09.11.53.57;	author espie;	state Exp;
branches;
next	1.172;

1.172
date	2005.03.09.11.46.07;	author espie;	state Exp;
branches;
next	1.171;

1.171
date	2005.03.09.11.30.59;	author espie;	state Exp;
branches;
next	1.170;

1.170
date	2005.03.09.11.22.27;	author espie;	state Exp;
branches;
next	1.169;

1.169
date	2005.02.07.15.35.23;	author espie;	state Exp;
branches;
next	1.168;

1.168
date	2005.01.22.13.00.35;	author espie;	state Exp;
branches;
next	1.167;

1.167
date	2005.01.14.02.25.12;	author espie;	state Exp;
branches;
next	1.166;

1.166
date	2005.01.13.00.29.37;	author espie;	state Exp;
branches;
next	1.165;

1.165
date	2005.01.03.01.02.45;	author espie;	state Exp;
branches;
next	1.164;

1.164
date	2004.12.28.14.50.38;	author espie;	state Exp;
branches;
next	1.163;

1.163
date	2004.12.28.13.54.13;	author espie;	state Exp;
branches;
next	1.162;

1.162
date	2004.12.27.23.56.48;	author espie;	state Exp;
branches;
next	1.161;

1.161
date	2004.12.26.14.57.19;	author espie;	state Exp;
branches;
next	1.160;

1.160
date	2004.12.21.01.43.58;	author espie;	state Exp;
branches;
next	1.159;

1.159
date	2004.12.20.22.43.25;	author espie;	state Exp;
branches;
next	1.158;

1.158
date	2004.12.20.22.19.24;	author espie;	state Exp;
branches;
next	1.157;

1.157
date	2004.12.20.21.31.22;	author espie;	state Exp;
branches;
next	1.156;

1.156
date	2004.12.20.17.17.32;	author espie;	state Exp;
branches;
next	1.155;

1.155
date	2004.12.20.12.56.19;	author espie;	state Exp;
branches;
next	1.154;

1.154
date	2004.12.20.12.32.01;	author espie;	state Exp;
branches;
next	1.153;

1.153
date	2004.12.20.12.16.09;	author espie;	state Exp;
branches;
next	1.152;

1.152
date	2004.12.19.14.47.33;	author espie;	state Exp;
branches;
next	1.151;

1.151
date	2004.12.19.14.09.53;	author espie;	state Exp;
branches;
next	1.150;

1.150
date	2004.12.18.14.40.27;	author espie;	state Exp;
branches;
next	1.149;

1.149
date	2004.12.18.14.37.30;	author espie;	state Exp;
branches;
next	1.148;

1.148
date	2004.12.18.13.34.36;	author espie;	state Exp;
branches;
next	1.147;

1.147
date	2004.12.18.13.20.53;	author espie;	state Exp;
branches;
next	1.146;

1.146
date	2004.12.17.11.30.28;	author espie;	state Exp;
branches;
next	1.145;

1.145
date	2004.12.16.11.38.27;	author espie;	state Exp;
branches;
next	1.144;

1.144
date	2004.12.16.11.19.58;	author espie;	state Exp;
branches;
next	1.143;

1.143
date	2004.12.16.11.07.33;	author espie;	state Exp;
branches;
next	1.142;

1.142
date	2004.12.15.01.07.10;	author espie;	state Exp;
branches;
next	1.141;

1.141
date	2004.12.13.21.28.08;	author espie;	state Exp;
branches;
next	1.140;

1.140
date	2004.12.13.21.14.16;	author espie;	state Exp;
branches;
next	1.139;

1.139
date	2004.12.13.18.29.51;	author espie;	state Exp;
branches;
next	1.138;

1.138
date	2004.12.12.11.26.15;	author espie;	state Exp;
branches;
next	1.137;

1.137
date	2004.12.09.18.46.00;	author espie;	state Exp;
branches;
next	1.136;

1.136
date	2004.12.07.19.09.04;	author espie;	state Exp;
branches;
next	1.135;

1.135
date	2004.12.07.12.19.34;	author espie;	state Exp;
branches;
next	1.134;

1.134
date	2004.12.06.21.55.01;	author espie;	state Exp;
branches;
next	1.133;

1.133
date	2004.12.06.12.35.36;	author espie;	state Exp;
branches;
next	1.132;

1.132
date	2004.12.02.00.04.38;	author espie;	state Exp;
branches;
next	1.131;

1.131
date	2004.11.27.16.38.26;	author espie;	state Exp;
branches;
next	1.130;

1.130
date	2004.11.27.14.02.50;	author espie;	state Exp;
branches;
next	1.129;

1.129
date	2004.11.23.22.58.02;	author espie;	state Exp;
branches;
next	1.128;

1.128
date	2004.11.22.01.56.13;	author espie;	state Exp;
branches;
next	1.127;

1.127
date	2004.11.21.15.44.55;	author espie;	state Exp;
branches;
next	1.126;

1.126
date	2004.11.21.13.32.18;	author espie;	state Exp;
branches;
next	1.125;

1.125
date	2004.11.21.13.24.41;	author espie;	state Exp;
branches;
next	1.124;

1.124
date	2004.11.20.23.38.51;	author espie;	state Exp;
branches;
next	1.123;

1.123
date	2004.11.18.21.48.02;	author espie;	state Exp;
branches;
next	1.122;

1.122
date	2004.11.14.19.25.45;	author espie;	state Exp;
branches;
next	1.121;

1.121
date	2004.11.14.13.20.07;	author espie;	state Exp;
branches;
next	1.120;

1.120
date	2004.11.14.12.54.30;	author espie;	state Exp;
branches;
next	1.119;

1.119
date	2004.11.14.11.58.43;	author espie;	state Exp;
branches;
next	1.118;

1.118
date	2004.11.13.15.00.48;	author espie;	state Exp;
branches;
next	1.117;

1.117
date	2004.11.13.13.55.02;	author espie;	state Exp;
branches;
next	1.116;

1.116
date	2004.11.13.13.34.02;	author espie;	state Exp;
branches;
next	1.115;

1.115
date	2004.11.13.13.06.11;	author espie;	state Exp;
branches;
next	1.114;

1.114
date	2004.11.13.12.49.58;	author espie;	state Exp;
branches;
next	1.113;

1.113
date	2004.11.13.12.33.01;	author espie;	state Exp;
branches;
next	1.112;

1.112
date	2004.11.13.12.09.01;	author espie;	state Exp;
branches;
next	1.111;

1.111
date	2004.11.13.11.54.30;	author espie;	state Exp;
branches;
next	1.110;

1.110
date	2004.11.13.10.47.21;	author espie;	state Exp;
branches;
next	1.109;

1.109
date	2004.11.12.23.11.41;	author espie;	state Exp;
branches;
next	1.108;

1.108
date	2004.11.12.19.42.01;	author espie;	state Exp;
branches;
next	1.107;

1.107
date	2004.11.12.00.04.34;	author espie;	state Exp;
branches;
next	1.106;

1.106
date	2004.11.11.12.45.15;	author espie;	state Exp;
branches;
next	1.105;

1.105
date	2004.11.11.12.29.20;	author espie;	state Exp;
branches;
next	1.104;

1.104
date	2004.11.11.12.17.25;	author espie;	state Exp;
branches;
next	1.103;

1.103
date	2004.11.11.12.13.57;	author espie;	state Exp;
branches;
next	1.102;

1.102
date	2004.11.11.11.36.26;	author espie;	state Exp;
branches;
next	1.101;

1.101
date	2004.11.11.11.23.04;	author espie;	state Exp;
branches;
next	1.100;

1.100
date	2004.11.11.11.16.39;	author espie;	state Exp;
branches;
next	1.99;

1.99
date	2004.11.11.10.47.26;	author espie;	state Exp;
branches;
next	1.98;

1.98
date	2004.11.09.11.02.42;	author espie;	state Exp;
branches;
next	1.97;

1.97
date	2004.11.09.10.17.51;	author espie;	state Exp;
branches;
next	1.96;

1.96
date	2004.11.09.09.32.17;	author espie;	state Exp;
branches;
next	1.95;

1.95
date	2004.11.07.12.19.20;	author espie;	state Exp;
branches;
next	1.94;

1.94
date	2004.11.06.12.19.16;	author espie;	state Exp;
branches;
next	1.93;

1.93
date	2004.11.02.23.53.20;	author espie;	state Exp;
branches;
next	1.92;

1.92
date	2004.11.01.19.48.58;	author espie;	state Exp;
branches;
next	1.91;

1.91
date	2004.11.01.19.21.58;	author espie;	state Exp;
branches;
next	1.90;

1.90
date	2004.11.01.19.14.26;	author espie;	state Exp;
branches;
next	1.89;

1.89
date	2004.11.01.14.30.00;	author espie;	state Exp;
branches;
next	1.88;

1.88
date	2004.11.01.11.27.50;	author espie;	state Exp;
branches;
next	1.87;

1.87
date	2004.10.31.12.40.00;	author espie;	state Exp;
branches;
next	1.86;

1.86
date	2004.10.31.11.33.50;	author espie;	state Exp;
branches;
next	1.85;

1.85
date	2004.10.31.09.06.04;	author espie;	state Exp;
branches;
next	1.84;

1.84
date	2004.10.20.11.38.57;	author espie;	state Exp;
branches;
next	1.83;

1.83
date	2004.10.19.10.21.49;	author espie;	state Exp;
branches;
next	1.82;

1.82
date	2004.10.18.12.03.19;	author espie;	state Exp;
branches;
next	1.81;

1.81
date	2004.10.18.11.12.21;	author espie;	state Exp;
branches;
next	1.80;

1.80
date	2004.10.18.10.51.03;	author espie;	state Exp;
branches;
next	1.79;

1.79
date	2004.10.18.09.38.35;	author espie;	state Exp;
branches;
next	1.78;

1.78
date	2004.10.17.09.32.21;	author espie;	state Exp;
branches;
next	1.77;

1.77
date	2004.10.16.11.01.29;	author espie;	state Exp;
branches;
next	1.76;

1.76
date	2004.10.13.18.39.07;	author espie;	state Exp;
branches;
next	1.75;

1.75
date	2004.10.12.09.35.15;	author espie;	state Exp;
branches;
next	1.74;

1.74
date	2004.10.11.14.40.04;	author espie;	state Exp;
branches;
next	1.73;

1.73
date	2004.10.11.14.35.07;	author espie;	state Exp;
branches;
next	1.72;

1.72
date	2004.10.11.13.46.17;	author espie;	state Exp;
branches;
next	1.71;

1.71
date	2004.10.11.13.29.05;	author espie;	state Exp;
branches;
next	1.70;

1.70
date	2004.10.11.13.10.25;	author espie;	state Exp;
branches;
next	1.69;

1.69
date	2004.10.11.12.50.09;	author espie;	state Exp;
branches;
next	1.68;

1.68
date	2004.10.11.12.39.04;	author espie;	state Exp;
branches;
next	1.67;

1.67
date	2004.10.11.12.33.59;	author espie;	state Exp;
branches;
next	1.66;

1.66
date	2004.10.11.12.25.18;	author espie;	state Exp;
branches;
next	1.65;

1.65
date	2004.10.11.12.13.46;	author espie;	state Exp;
branches;
next	1.64;

1.64
date	2004.10.11.11.38.35;	author espie;	state Exp;
branches;
next	1.63;

1.63
date	2004.10.11.09.44.06;	author espie;	state Exp;
branches;
next	1.62;

1.62
date	2004.10.11.09.13.20;	author espie;	state Exp;
branches;
next	1.61;

1.61
date	2004.09.24.09.06.50;	author espie;	state Exp;
branches;
next	1.60;

1.60
date	2004.09.21.22.17.49;	author espie;	state Exp;
branches;
next	1.59;

1.59
date	2004.09.20.10.36.39;	author espie;	state Exp;
branches;
next	1.58;

1.58
date	2004.09.20.09.10.21;	author espie;	state Exp;
branches;
next	1.57;

1.57
date	2004.09.20.07.31.42;	author espie;	state Exp;
branches;
next	1.56;

1.56
date	2004.09.18.13.28.19;	author espie;	state Exp;
branches;
next	1.55;

1.55
date	2004.09.18.09.27.05;	author espie;	state Exp;
branches;
next	1.54;

1.54
date	2004.09.14.22.53.17;	author espie;	state Exp;
branches;
next	1.53;

1.53
date	2004.09.14.22.49.36;	author espie;	state Exp;
branches;
next	1.52;

1.52
date	2004.09.14.22.47.48;	author espie;	state Exp;
branches;
next	1.51;

1.51
date	2004.09.14.22.46.12;	author espie;	state Exp;
branches;
next	1.50;

1.50
date	2004.08.12.19.18.03;	author brad;	state Exp;
branches;
next	1.49;

1.49
date	2004.08.10.12.04.53;	author espie;	state Exp;
branches;
next	1.48;

1.48
date	2004.08.10.11.53.27;	author espie;	state Exp;
branches;
next	1.47;

1.47
date	2004.08.07.17.27.26;	author espie;	state Exp;
branches;
next	1.46;

1.46
date	2004.08.06.14.33.02;	author espie;	state Exp;
branches;
next	1.45;

1.45
date	2004.08.06.12.21.11;	author espie;	state Exp;
branches;
next	1.44;

1.44
date	2004.08.06.11.36.25;	author espie;	state Exp;
branches;
next	1.43;

1.43
date	2004.08.06.10.23.45;	author espie;	state Exp;
branches;
next	1.42;

1.42
date	2004.08.06.08.14.51;	author espie;	state Exp;
branches;
next	1.41;

1.41
date	2004.08.06.08.06.01;	author espie;	state Exp;
branches;
next	1.40;

1.40
date	2004.08.06.07.51.17;	author espie;	state Exp;
branches;
next	1.39;

1.39
date	2004.08.05.23.36.39;	author espie;	state Exp;
branches;
next	1.38;

1.38
date	2004.08.03.12.29.44;	author espie;	state Exp;
branches;
next	1.37;

1.37
date	2004.08.02.12.12.36;	author espie;	state Exp;
branches;
next	1.36;

1.36
date	2004.08.02.12.08.25;	author espie;	state Exp;
branches;
next	1.35;

1.35
date	2004.07.20.18.58.41;	author espie;	state Exp;
branches;
next	1.34;

1.34
date	2004.07.14.10.44.03;	author espie;	state Exp;
branches;
next	1.33;

1.33
date	2004.07.11.20.46.08;	author espie;	state Exp;
branches;
next	1.32;

1.32
date	2004.06.21.15.19.33;	author miod;	state Exp;
branches;
next	1.31;

1.31
date	2004.04.28.06.53.17;	author espie;	state Exp;
branches;
next	1.30;

1.30
date	2004.03.30.08.55.56;	author espie;	state Exp;
branches;
next	1.29;

1.29
date	2004.03.18.16.49.50;	author tholo;	state Exp;
branches;
next	1.28;

1.28
date	2004.03.07.19.29.08;	author espie;	state Exp;
branches;
next	1.27;

1.27
date	2004.02.20.19.13.51;	author espie;	state Exp;
branches;
next	1.26;

1.26
date	2004.01.28.22.12.01;	author espie;	state Exp;
branches;
next	1.25;

1.25
date	2004.01.27.17.47.45;	author sturm;	state Exp;
branches;
next	1.24;

1.24
date	2004.01.27.14.50.52;	author espie;	state Exp;
branches;
next	1.23;

1.23
date	2004.01.27.13.09.16;	author espie;	state Exp;
branches;
next	1.22;

1.22
date	2004.01.22.21.11.43;	author espie;	state Exp;
branches;
next	1.21;

1.21
date	2004.01.01.17.20.54;	author espie;	state Exp;
branches;
next	1.20;

1.20
date	2003.12.26.16.34.05;	author espie;	state Exp;
branches;
next	1.19;

1.19
date	2003.12.21.18.41.23;	author espie;	state Exp;
branches;
next	1.18;

1.18
date	2003.12.19.00.29.20;	author espie;	state Exp;
branches;
next	1.17;

1.17
date	2003.12.10.11.12.22;	author espie;	state Exp;
branches;
next	1.16;

1.16
date	2003.12.09.19.10.35;	author espie;	state Exp;
branches;
next	1.15;

1.15
date	2003.12.09.19.08.44;	author espie;	state Exp;
branches;
next	1.14;

1.14
date	2003.11.10.13.25.50;	author espie;	state Exp;
branches;
next	1.13;

1.13
date	2003.11.09.16.13.37;	author espie;	state Exp;
branches;
next	1.12;

1.12
date	2003.11.09.15.42.48;	author espie;	state Exp;
branches;
next	1.11;

1.11
date	2003.11.06.22.05.19;	author espie;	state Exp;
branches;
next	1.10;

1.10
date	2003.11.06.18.42.01;	author espie;	state Exp;
branches;
next	1.9;

1.9
date	2003.11.06.18.13.12;	author espie;	state Exp;
branches;
next	1.8;

1.8
date	2003.11.06.18.12.07;	author espie;	state Exp;
branches;
next	1.7;

1.7
date	2003.11.06.18.06.00;	author espie;	state Exp;
branches;
next	1.6;

1.6
date	2003.11.06.18.04.10;	author espie;	state Exp;
branches;
next	1.5;

1.5
date	2003.11.06.17.59.23;	author espie;	state Exp;
branches;
next	1.4;

1.4
date	2003.10.26.11.09.27;	author espie;	state Exp;
branches;
next	1.3;

1.3
date	2003.10.20.17.29.56;	author espie;	state Exp;
branches;
next	1.2;

1.2
date	2003.10.19.18.42.55;	author espie;	state Exp;
branches;
next	1.1;

1.1
date	2003.10.16.17.43.34;	author espie;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2003.10.16.17.43.34;	author espie;	state Exp;
branches;
next	;


desc
@@


1.483
log
@prepare things slightly further, FwUpdate still not active...
@
text
@#! /usr/bin/perl
# ex:ts=8 sw=4:
# $OpenBSD: pkg_add,v 1.482 2014/01/23 11:45:22 espie Exp $
#
# Copyright (c) 2010 Marc Espie <espie@@openbsd.org>
#
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

use strict;
use warnings;

sub run
{
	my ($cmd, $m) = @@_;
	my $module = "OpenBSD::$m";
	eval "require $module";
	if ($@@) {
		die $@@;
	}
	exit($module->parse_and_run($cmd));
}

my $choices = {
	pkg_add => 'PkgAdd',
	pkg_check => 'PkgCheck',
	pkg_create => 'PkgCreate',
	pkg_delete => 'PkgDelete',
	pkg_info => 'PkgInfo',
	pkg_sign => 'PkgSign',
	fw_update => 'FwUpdate',
};

my @@l = qw(add check create delete info sign);

while (my ($cmd, $module) = each %$choices) {
	if ($0 =~ m/\/?\Q$cmd\E$/) {
		run($cmd, $module);
	}
}

# defaults to pkg_info personality but keeps the command name
run($0, 'PkgInfo');
@


1.482
log
@reorg code: make "signing only" a separate command, as it has nothing in
common with pkg_create.

Move the signing part in its own module, so that PkgCreate can reuse it
for "signing while we build" mode.

naddy@@ agrees
@
text
@d3 1
a3 1
# $OpenBSD: pkg_add,v 1.481 2012/08/06 00:00:28 fgsch Exp $
d24 3
a26 3
	my ($cmd, $name) = @@_;
	my $module = "OpenBSD::Pkg\u$cmd";
	eval "require $module;";
d30 1
a30 1
	exit($module->parse_and_run($name));
d32 11
d45 3
a47 3
for my $i (@@l) {
	if ($0 =~ m/\/?pkg_$i$/) {
		run($i, "pkg_$i");
d52 1
a52 1
run('info', $0);
@


1.481
log
@kill pkg(1) for good. with help from espie.
espie@@ ok.
@
text
@d3 1
a3 1
# $OpenBSD: pkg_add,v 1.480 2012/07/13 16:47:49 deraadt Exp $
d32 1
a32 1
my @@l = qw(add check create delete info);
@


1.480
log
@do not install the pkg(1) front-end stub in /usr/sbin anymore, everyone
uses the '_' variants
ok espie
@
text
@d3 1
a3 1
# $OpenBSD: pkg,v 1.19 2010/12/05 09:41:55 espie Exp $
d40 2
a41 10
if (@@ARGV) {
	for my $i (@@l) {
		if ($ARGV[0] eq $i) {
			shift;
			run($i, "pkg $i");
		}
	}
}
print STDERR "Usage: pkg [",join("|", @@l),"] [args]\n";
exit(1);
@


1.479
log
@move code around, so that commands can be used as modules.
pkg becomes the start hub, which does nothing except require the
correct module.
Saner code wrt Add/Delete, and more sharing.
@
text
@a1 1

d3 1
a3 1
# $OpenBSD: pkg_add,v 1.478 2010/05/10 09:17:54 espie Exp $
d5 1
a5 1
# Copyright (c) 2003-2010 Marc Espie <espie@@openbsd.org>
d22 1
a22 19
use OpenBSD::AddDelete;

package OpenBSD::AddDelete;
use OpenBSD::Dependencies;
use OpenBSD::PackingList;
use OpenBSD::PackageInfo;
use OpenBSD::PackageLocator;
use OpenBSD::PackageName;
use OpenBSD::PkgCfl;
use OpenBSD::Add;
use OpenBSD::SharedLibs;
use OpenBSD::UpdateSet;
use OpenBSD::Handle;

our ($state, %defines, $bad, $opt_B);

package OpenBSD::PackingList;

sub uses_old_libs
d24 5
a28 33
	my $plist = shift;
	require OpenBSD::RequiredBy;

	return  grep {/^\.libs\d*\-/o}
	    OpenBSD::Requiring->new($plist->pkgname)->list;
}

sub has_different_sig
{
	my ($plist, $state) = @@_;
	if (!defined $plist->{different_sig}) {
		my $n = OpenBSD::PackingList->from_installation($plist->pkgname)->signature;
		my $o = $plist->signature;
		my $r = $n->compare($o);
		$state->print("Comparing full signature for ",
		    $plist->pkgname, " \"", $o->string, "\" vs. \"",
		    $n->string,"\": ")
			if $state->verbose >= 3;
		if (defined $r) {
			if ($r == 0) {
				$plist->{different_sig} = 0;
				$state->say("equal") if $state->verbose >= 3;
			} elsif ($r > 0) {
				$plist->{different_sig} = 1;
				$state->say("greater") if $state->verbose >= 3;
			} else {
				$plist->{different_sig} = 1;
				$state->say("less") if $state->verbose >= 3;
			}
		} else {
			$plist->{different_sig} = 1;
			$state->say("non comparable") if $state->verbose >= 3;
		}
d30 1
a30 1
	return $plist->{different_sig};
d32 1
d34 3
a36 10
package OpenBSD::State;
our @@ISA=(qw(OpenBSD::UI));

# one-level dependencies tree, for nicer printouts
sub build_deptree
{
	my ($state, $set, @@deps) = @@_;

	if (defined $state->{deptree}->{$set}) {
		$set = $state->{deptree}->{$set};
a37 10
	for my $dep (@@deps) {
		$state->{deptree}->{$dep} = $set unless
		    defined $state->{deptree}->{$dep};
	}
}

sub todo
{
	my $state = shift;
	return $state->tracker->sets_todo;
d40 5
a44 9
sub deptree_header
{
	my ($state, $pkg) = @@_;
	if (defined $state->{deptree}->{$pkg}) {
		my $s = $state->{deptree}->{$pkg}->real_set;
		if ($s eq $pkg) {
			delete $state->{deptree}->{$pkg};
		} else {
			return $s->short_print.':';
a46 58
	return '';
}

sub set_name_from_handle
{
	my ($state, $h, $extra) = @@_;
	$extra //= '';
	$state->log->set_context($extra.$h->pkgname);
}

OpenBSD::Auto::cache(updater,
    sub {
	require OpenBSD::Update;
	return OpenBSD::Update->new;
    });

OpenBSD::Auto::cache(tracker,
    sub {
	require OpenBSD::Tracker;
	return OpenBSD::Tracker->new;
    });

sub quirks
{
	my $state = shift;

	return $state->{quirks};
}

package OpenBSD::ConflictCache;
our @@ISA = (qw(OpenBSD::Cloner));
sub new
{
	my $class = shift;
	bless {done => {}, c => {}}, $class;
}

sub add
{
	my ($self, $handle) = @@_;
	return if $self->{done}{$handle};
	$self->{done}{$handle} = 1;
	for my $conflict (OpenBSD::PkgCfl::find_all($handle->plist, $state)) {
		$self->{c}{$conflict} = 1;
	}
}

sub list
{
	my $self = shift;
	return keys %{$self->{c}};
}

sub merge
{
	my ($self, @@extra) = @@_;
	$self->clone('c', @@extra);
	$self->clone('done', @@extra);
d48 2
a49 900

package OpenBSD::UpdateSet;
use OpenBSD::PackageInfo;
use OpenBSD::Error;

OpenBSD::Auto::cache(solver,
    sub {
	return OpenBSD::Dependencies::Solver->new(shift);
    });

OpenBSD::Auto::cache(conflict_cache,
    sub {
	return OpenBSD::ConflictCache->new;
    });

sub setup_header
{
	my ($set, $state, $handle, $info) = @@_;

	my $header = $state->deptree_header($set);
	if (defined $handle) {
		$header .= $handle->pkgname;
	} else {
		$header .= $set->print;
	}
	if (defined $info) {
		$header.=" ($info)";
	}

	if (!$state->progress->set_header($header)) {
		return unless $state->verbose;
		if (!defined $info) {
			$header = "Adding $header";
		}
		if (defined $state->{lastheader} &&
		    $header eq $state->{lastheader}) {
			return;
		}
		$state->{lastheader} = $header;
		print $header;
		print "(pretending) " if $state->{not};
		if ($state->{do_faked}) {
			print " under ", $state->{destdir};
		}
		print "\n";
	}
}

sub complete
{
	my ($set, $state) = @@_;

	for my $n ($set->newer) {
		$n->complete($state);
		my $pkgname = $n->pkgname;
		my $plist = $n->plist;
		return 1 if !defined $plist;
		if (is_installed($pkgname) &&
		    (!$state->{allow_replacing} ||
		      !$state->{defines}->{installed} &&
		      !$plist->has_different_sig($state) &&
		      !$plist->uses_old_libs)) {
		      	my $o = $set->{older}->{$pkgname};
			if (!defined $o) {
				$o = OpenBSD::Handle->create_old($pkgname, $state);
				$set->add_older($o);
			}
			$o->{update_found} = $o;
			$set->move_kept($o);
			$o->{tweaked} =
			    OpenBSD::Add::tweak_package_status($pkgname, $state);
			$state->updater->progress_message($state, "No change in $pkgname");
			delete $set->{newer}->{$pkgname};
			$n->cleanup;
		}
		return 1 if $n->has_error;
	}
	for my $o ($set->older) {
		$o->complete_old($state);
	}

	my $check = $set->install_issues($state);
	return 0 if !defined $check;

	if ($check) {
		$bad++;
		$set->cleanup(OpenBSD::Handle::CANT_INSTALL, $check);
		$state->tracker->cant($set);
	}
	return 1;
}

sub find_conflicts
{
	my ($set, $state) = @@_;

	my $c = $set->conflict_cache;

	for my $handle ($set->newer) {
		$c->add($handle);
	}
	return $c->list;
}

sub mark_as_manual_install
{
	my $set = shift;

	for my $handle ($set->newer) {
		my $plist = $handle->plist;
		$plist->has('manual-installation') or
		    OpenBSD::PackingElement::ManualInstallation->add($plist);
	}
}

sub updates
{
	my ($n, $plist) = @@_;
	if (!$n->location->update_info->match_pkgpath($plist)) {
		return 0;
	}
	if (!$n->plist->conflict_list->conflicts_with($plist->pkgname)) {
		return 0;
	}
	my $r = OpenBSD::PackageName->from_string($n->pkgname)->compare(
	    OpenBSD::PackageName->from_string($plist->pkgname));
	if (defined $r && $r < 0) {
		return 0;
	}
	return 1;
}

sub is_an_update_from
{
	my ($set, @@conflicts) = @@_;
LOOP:	for my $c (@@conflicts) {
		next if $c =~ m/^\.libs\d*\-/;
		next if $c =~ m/^partial\-/;
		my $plist = OpenBSD::PackingList->from_installation($c, \&OpenBSD::PackingList::UpdateInfoOnly);
		return 0 unless defined $plist;
		for my $n ($set->newer) {
			if (updates($n, $plist)) {
				next LOOP;
			}
		}
	    	return 0;
	}
	return 1;
}

sub install_issues
{
	my ($set, $state) = @@_;

	my @@conflicts = $set->find_conflicts($state);

	if (@@conflicts == 0) {
		if ($state->{defines}{update_only}) {
			return "only update, no install";
		} else {
			return 0;
		}
	}

	if (!$state->{allow_replacing}) {
		if (grep { !/^.libs\d*\-/ && !/^partial\-/ } @@conflicts) {
			if (!$set->is_an_update_from(@@conflicts)) {
				$state->errsay("Can't install ", $set->print,
				    " because of conflicts (",
				    join(',', @@conflicts), ")");
				return "conflicts";
			}
		}
	}

	my $later = 0;
	for my $toreplace (@@conflicts) {
		if ($state->tracker->is_installed($toreplace)) {
			$state->errsay("Cannot replace $toreplace in ",
			    $set->print, ": just got installed");
			return "replacing just installed";
		}

		next if defined $set->{older}->{$toreplace};
		next if defined $set->{kept}->{$toreplace};

		$later = 1;
		my $s = $state->tracker->is_to_update($toreplace);
		if (defined $s && $s ne $set) {
			$set->merge($state->tracker, $s);
		} else {
			$set->add_older(OpenBSD::Handle->create_old($toreplace,
			    $state));
		}
	}

	return if $later;


	my $manual_install = 0;

	for my $old ($set->older) {
		my $name = $old->pkgname;

		if ($old->has_error(OpenBSD::Handle::NOT_FOUND)) {
			Fatal "Can't find $name as an installed package\n";
		}
		if ($old->has_error(OpenBSD::Handle::BAD_PACKAGE)) {
			Fatal "Couldn't find packing-list for $name\n";
		}

		if ($old->plist->has('manual-installation')) {
			$manual_install = 1;
		}
	}

	$set->mark_as_manual_install if $manual_install;

	return 0;
}

sub try_merging
{
	my ($set, $m, $state) = @@_;

	my $s = $state->tracker->is_to_update($m);
	if (!defined $s) {
		$s = OpenBSD::UpdateSet->new->add_older(
		    OpenBSD::Handle->create_old($m, $state));
	}
	if ($state->updater->process_set($s, $state)) {
		$state->say("Merging ", $s->print, $state->ntogo);
		$set->merge($state->tracker, $s);
		return 1;
	} else {
		$state->errsay("NOT MERGING: can't find update for ", $s->print, $state->ntogo);
		return 0;
	}
}

sub check_forward_dependencies
{
	my ($set, $state) = @@_;

	require OpenBSD::ForwardDependencies;
	$set->{forward} = OpenBSD::ForwardDependencies->find($set);
	my $bad = $set->{forward}->check($state);

	if (%$bad) {
		my $no_merge = 1;
		if (!$state->{defines}->{dontmerge}) {
			my $okay = 1;
			for my $m (keys %$bad) {
				if ($set->try_merging($m, $state)) {
					$no_merge = 0;
				} else {
					$okay = 0;
				}
			}
			return 0 if $okay == 1;
		}
		if ($state->{defines}->{updatedepends}) {
			$state->errsay("Forcing update");
			return $no_merge;
		} elsif ($state->{interactive}) {
			if ($state->confirm("Proceed with update anyways", 0)) {
				return $no_merge;
			} else {
				return undef;
			}
		} else {
			return undef;
		}
	}
	return 1;
}

sub recheck_conflicts
{
	my ($set, $state) = @@_;

	# no conflicts between newer sets nor kept sets
	for my $h ($set->newer, $set->kept) {
		for my $h2 ($set->newer, $set->kept) {
			next if $h2 == $h;
			if ($h->plist->conflict_list->conflicts_with($h2->pkgname)) {
				$state->errsay($set->print, ": internal conflict between ", $h->pkgname, " and ", $h2->pkgname);
				return 0;
			}
		}
	}

	return 1;
}

package OpenBSD::AddDelete;

sub failed_message
{
	my ($base_msg, $interrupted, @@l) = @@_;
	my $msg = $base_msg;
	if ($interrupted) {
		$msg = "Caught SIG$interrupted. $msg";
	}
	if (@@l > 0) {
		$msg.= ", partial installation recorded as ".join(',', @@l);
	}
	return $msg;
}

sub save_partial_set
{
	my ($set, $state) = @@_;

	return () if $state->{not};
	my @@l = ();
	for my $h ($set->newer) {
		next unless defined $h->{partial};
		push(@@l, OpenBSD::Add::record_partial_installation($h->plist, $state, $h->{partial}));
	}
	return @@l;
}

sub partial_install
{
	my ($base_msg, $set, $state) = @@_;
	return failed_message($base_msg, $state->{interrupted}, save_partial_set($set, $state));
}

sub build_before
{
	my %known = map {($_->pkgname, 1)} @@_;
	require OpenBSD::RequiredBy;
	for my $c (@@_) {
		for my $d (OpenBSD::RequiredBy->new($c->pkgname)->list) {
			push(@@{$c->{before}}, $d) if $known{$d};
		}
	}
}

sub okay
{
	my ($h, $c) = @@_;

	for my $d (@@{$c->{before}}) {
		return 0 if !$h->{$d};
	}
	return 1;
}

sub iterate
{
	my $sub = pop @@_;
	my $done = {};
	my $something_done;

	do {
		$something_done = 0;

		for my $c (@@_) {
			next if $done->{$c->pkgname};
			if (okay($done, $c)) {
				&$sub($c);
				$done->{$c->pkgname} = 1;
				$something_done = 1;
			}
		}
	} while ($something_done);
	# if we can't do stuff in order, do it anyways
	for my $c (@@_) {
		next if $done->{$c->pkgname};
		&$sub($c);
	}
}

sub check_x509_signature
{
	my ($set, $state) = @@_;
	for my $handle ($set->newer) {
		$state->set_name_from_handle($handle, '+');
		my $plist = $handle->plist;
		if ($plist->is_signed) {
			if ($state->{defines}->{nosig}) {
				$state->errsay("NOT CHECKING DIGITAL SIGNATURE FOR ",
				    $plist->pkgname);
				$state->{check_digest} = 0;
			} else {
				require OpenBSD::x509;

				if (!OpenBSD::x509::check_signature($plist,
				    $state)) {
					Fatal "fatal issues in ", $set->print;
				}
				$state->{check_digest} = 1;
				$state->{packages_with_sig}++;
			}
		} else {
			$state->{packages_without_sig}{$plist->pkgname} = 1;
			$state->{check_digest} = 0;
		}
	}
}

sub delete_old_packages
{
	my ($set, $state) = @@_;

	build_before($set->older_to_do);
	iterate($set->older_to_do, sub {
		return if $state->{size_only};
		my $o = shift;
		$set->setup_header($state, $o, "deleting");
		my $oldname = $o->pkgname;
		$state->set_name_from_handle($o, '-');
		require OpenBSD::Delete;
		try {
			OpenBSD::Delete::delete_plist($o->plist, $state);
		} catchall {
			$state->errprint($_);
			Fatal partial_install(
			    "Deinstallation of $oldname failed",
			    $set, $state);
		};

		if (defined $state->{updatedepends}) {
			delete $state->{updatedepends}->{$oldname};
		}
		OpenBSD::PkgCfl::unregister($o->plist, $state);
	});
	# Here there should be code to handle old libs
}

sub really_add
{
	my ($set, $state) = @@_;

	my $errors = 0;

	check_x509_signature($set, $state);

	if ($state->{not}) {
		$state->status->what("Pretending to add");
	} else {
		$state->status->what("Adding");
	}
	$set->setup_header($state);

	# XXX in `combined' updates, some dependencies may remove extra
	# packages, so we do a double-take on the list of packages we
	# are actually replacing.
	my $replacing = 0;
	if ($set->older_to_do) {
		$replacing = 1;
	}
#	if (defined $plist->{old_libs}) {
#		$replacing = 1;
#	}
	$state->{replacing} = $replacing;

	$ENV{'PKG_PREFIX'} = $state->{localbase};

	my $handler = sub {
		$state->{interrupted} = shift;
	};
	local $SIG{'INT'} = $handler;
	local $SIG{'QUIT'} = $handler;
	local $SIG{'HUP'} = $handler;
	local $SIG{'KILL'} = $handler;
	local $SIG{'TERM'} = $handler;

	if ($replacing) {
		require OpenBSD::OldLibs;
		OpenBSD::OldLibs->save($set, $state);
	}

	if ($replacing && !$state->{delete_first}) {
		$state->{extracted_first} = 1;
		for my $handle ($set->newer) {
			next if $state->{size_only};
			$set->setup_header($state, $handle, "extracting");

			try {
				OpenBSD::Replace::perform_extraction($handle,
				    $state);
			} catchall {
				unless ($state->{interrupted}) {
					$state->errprint($_);
					$errors++;
				}
			};
			if ($state->{interrupted} || $errors) {
				Fatal partial_install("Installation of ".
				    $handle->pkgname." failed", $set, $state);
			}
		}
	} else {
		$state->{extracted_first} = 0;
	}

	if ($replacing) {
		delete_old_packages($set, $state);
	}

	iterate($set->newer, sub {
		return if $state->{size_only};
		my $handle = shift;

		my $pkgname = $handle->pkgname;
		my $plist = $handle->plist;
		$set->setup_header($state, $handle,
		    $replacing ? "installing" : undef);
		$state->set_name_from_handle($handle, '+');

		try {
			OpenBSD::Add::perform_installation($handle, $state);
			if (!$state->{interrupted} && $plist->has(INSTALL)) {
				$plist->get(INSTALL)->run($state, 'POST-INSTALL');
			}
		} catchall {
			unless ($state->{interrupted}) {
				$state->errprint($_);
				$errors++;
			}
		};

		unlink($plist->infodir.CONTENTS);
		if ($state->{interrupted} || $errors) {
			Fatal partial_install("Installation of $pkgname failed",
			    $set, $state);
		}
	});
	$set->setup_header($state);
	$state->progress->next($state->ntogo(-1));
	for my $handle ($set->newer) {
		my $pkgname = $handle->pkgname;
		my $plist = $handle->plist;
		OpenBSD::SharedLibs::add_libs_from_plist($plist);
		OpenBSD::Add::tweak_plist_status($plist, $state);
		$plist->to_cache;
		OpenBSD::Add::register_installation($plist);
		add_installed($pkgname);
		delete $handle->{partial};
		OpenBSD::PkgCfl::register($plist, $state);
		if ($plist->has(DISPLAY)) {
			$plist->get(DISPLAY)->prepare($state);
		}
	}
	for my $handle ($set->newer) {
		$set->{solver}->register_dependencies($state);
	}
	if ($replacing) {
		$set->{forward}->adjust($state);
	}
	if ($state->{repairdependencies}) {
		$set->{solver}->repair_dependencies($state);
	}
	delete $state->{delete_first};
}

sub newer_has_errors
{
	my ($set, $state) = @@_;

	for my $handle ($set->newer) {
		if ($handle->has_error(OpenBSD::Handle::ALREADY_INSTALLED)) {
			$set->cleanup(OpenBSD::Handle::ALREADY_INSTALLED);
			return 1;
		}
		if ($handle->has_error) {
			$state->set_name_from_handle($handle);
			$state->log("Can't install ", $handle->pkgname, ": ",
				$handle->error_message, "\n");
			$bad++;
			$set->cleanup($handle->has_error);
			$state->tracker->cant($set);
			return 1;
		}

		if ($handle->plist->has('arch')) {
			unless ($handle->plist->{arch}->check($state->{arch})) {
				$state->set_name_from_handle($handle);
				$state->log($handle->pkgname, " is not for the right architecture");
				if (!$defines{arch}) {
					$bad++;
					$set->cleanup(OpenBSD::Handle::CANT_INSTALL);
					$state->tracker->cant($set);
					return 1;
				}
			}
		}
	}
	return 0;
}

sub install_set
{
	my ($set, $state) = @@_;

	$set = $set->real_set;

	if ($set->{finished}) {
		return ();
	}

	if (!$state->updater->process_set($set, $state)) {
		return ();
	}

	for my $handle ($set->newer) {
		if ($state->tracker->is_installed($handle->pkgname)) {
			$set->move_kept($handle);
		}
	}

	if (!$set->complete($state)) {
		return $set;
	}

	if (newer_has_errors($set, $state)) {
		return ();
	}

	my @@deps = $set->solver->solve_depends($state);
	if ($state->verbose >= 2) {
		$set->solver->dump;
	}
	if (@@deps > 0) {
		$state->build_deptree($set, @@deps);
		$set->solver->check_for_loops($state);
		return (@@deps, $set);
	}

	if ($set->older_to_do) {
		my $r = $set->check_forward_dependencies($state);
		if (!defined $r) {
			$bad++;
			$set->cleanup(OpenBSD::Handle::CANT_INSTALL);
			$state->tracker->cant($set);
			return ();
		}
		if ($r == 0) {
			return $set;
		}
	}

	# verify dependencies have been installed
	my @@baddeps = $set->solver->check_depends;

	if (@@baddeps) {
		$state->errsay("Can't install ", $set->print,
		    ": can't resolve ", join(',', @@baddeps));
		$bad++;
		$set->cleanup(OpenBSD::Handle::CANT_INSTALL,"bad dependencies");
		$state->tracker->cant($set);
		return ();
	}

	if (!$set->solver->solve_wantlibs($state)) {
		$bad++;
		$set->cleanup(OpenBSD::Handle::CANT_INSTALL, "libs not found");
		$state->tracker->cant($set);
		return ();
	}
#	if (!$set->solver->solve_tags($state)) {
#		if (!$defines{libdepends}) {
#			$bad++;
#			return ();
#		}
#	}
	if (!$set->recheck_conflicts($state)) {
		$bad++;
		$set->cleanup(OpenBSD::Handle::CANT_INSTALL, "fatal conflicts");
		$state->tracker->cant($set);
		return ();
	}
	if ($set->older_to_do) {
		require OpenBSD::Replace;
		if (!OpenBSD::Replace::is_set_safe($set, $state)) {
			$bad++;
			$set->cleanup(OpenBSD::Handle::CANT_INSTALL, "exec detected");
			$state->tracker->cant($set);
			return ();
		}
	}
	if ($set->newer > 0 || $set->older_to_do > 0) {
		for my $h ($set->newer) {
			$h->plist->set_infodir($h->location->info);
		}

		if (!$set->validate_plists($state)) {
			$bad++;
			$set->cleanup(OpenBSD::Handle::CANT_INSTALL,
			    "file issues");
			$state->tracker->cant($set);
			return ();
		}

		really_add($set, $state);
	}
	$set->cleanup;
	$state->tracker->done($set);
	return ();
}



our ($opt_a, $opt_A, $opt_P, $opt_Q, $opt_r, $opt_u, $opt_U, $opt_l, $opt_z);

handle_options('aqchruUzl:A:P:Q:', {},
    'pkg_add [-acIinqrsUuvxz] [-A arch] [-B pkg-destdir] [-D name[=value]]',
    '[-L localbase] [-l file] [-P type] [-Q quick-destdir] pkg-name [...]');

local $SIG{'INFO'} = sub { $state->status->print($state); };
$state->{do_faked} = 0;
$state->{arch} = $opt_A;

if (defined $opt_Q and defined $opt_B) {
	Usage "-Q and -B are incompatible options";
}
if (defined $opt_Q and defined $opt_r) {
	Usage "-r and -Q are incompatible options";
}
if ($opt_P) {
	if ($opt_P eq 'cdrom') {
		$state->{cdrom_only} = 1;
	}
	elsif ($opt_P eq 'ftp') {
		$state->{ftp_only} = 1;
	}
	else {
	    Usage "bad option: -P $opt_P";
	}
}
if (defined $opt_Q) {
	$state->{destdir} = $opt_Q;
	$state->{do_faked} = 1;
} elsif (defined $opt_B) {
	$state->{destdir} = $opt_B;
} elsif (defined $ENV{'PKG_PREFIX'}) {
	$state->{destdir} = $ENV{'PKG_PREFIX'};
}
if (defined $state->{destdir}) {
	$state->{destdir}.='/';
	$ENV{'PKG_DESTDIR'} = $state->{destdir};
} else {
	$state->{destdir} = '';
	delete $ENV{'PKG_DESTDIR'};
}


$state->{automatic} = $opt_a;
$state->{allow_replacing} = $opt_r || $opt_u || $opt_U;
$state->{hard_replace} = $opt_r;
$state->{newupdates} = $opt_u || $opt_U;

if (@@ARGV == 0 && !$opt_u && !$opt_l) {
	Usage "Missing pkgname";
}

# Here we create the list of packages to install
# actually, an updateset list (@@todo2), and we hope to do this lazily
# later for the most part...
my @@todo2 = ();

sub inform_user_of_problems
{
	my $state = shift;
	my @@cantupdate = $state->tracker->cant_list;
	if (@@cantupdate > 0) {
		$state->print("Couldn't find updates for ", join(', ', @@cantupdate), "\n");
	}
	if (defined $state->{issues}) {
		$state->say("There were some ambiguities. ",
		    "Please run in interactive mode again.");
	}
}

# if we already have quirks, we update it. If not, we try to install it.
sub quirk_set
{
	require OpenBSD::PackageRepository::Installed;
	require OpenBSD::Search;

	my $set = OpenBSD::UpdateSet->new;
	$set->{quirks} = 1;
	my $l = OpenBSD::PackageRepository::Installed->new->match_locations(OpenBSD::Search::Stem->new('quirks'));
	if (@@$l > 0) {
		$set->add_older(map {OpenBSD::Handle->from_location($_)} @@$l);
	} else {
		$set->add_hints2('quirks');
	}
	return $set;
}

sub do_quirks
{
	my $state = shift;

	install_set(quirk_set(), $state);
	eval {
		require OpenBSD::Quirks;
		# interface version number.
		$state->{quirks} = OpenBSD::Quirks->new(1);
	};
}

sub process_parameters
{
	my $add_hints = $opt_z ? "add_hints" : "add_hints2";

	# match fuzzily against a list
	if ($opt_l) {
		open my $f, '<', $opt_l or die "$!: bad list $opt_l";
		my $_;
		while (<$f>) {
			chomp;
			s/\s.*//;
			push(@@todo2, OpenBSD::UpdateSet->new->$add_hints($_));
		}
	}

	# update existing stuff
	if ($opt_u) {
		require OpenBSD::PackageRepository::Installed;

		if (@@ARGV == 0) {
			@@ARGV = sort(installed_packages());
			$state->{allupdates} = 1;
		}
		my $inst = OpenBSD::PackageRepository::Installed->new;
		for my $pkgname (@@ARGV) {
			my $l;

			next if $pkgname =~ m/^quirks\-\d/;
			if (OpenBSD::PackageName::is_stem($pkgname)) {
				$l = $state->updater->stem2location($inst, $pkgname, $state);
			} else {
				$l = $inst->find($pkgname, $state->{arch});
			}
			if (!defined $l) {
				$state->say("Problem finding $pkgname");
			} else {
				push(@@todo2, OpenBSD::UpdateSet->new->add_older(OpenBSD::Handle->from_location($l)));
			}
		}
	} else {

	# actual names
		for my $pkgname (@@ARGV) {
			next if $pkgname =~ m/^quirks\-\d/;
			push(@@todo2,
			    OpenBSD::UpdateSet->new->$add_hints($pkgname));
		}
	}
}

sub finish_display
{
	OpenBSD::Add::manpages_index($state);


	# and display delayed thingies.
	if ($state->{packages_with_sig}) {
		$state->print("Packages with signatures: ",
		    $state->{packages_with_sig});
		if ($state->{packages_without_sig}) {
			print ". UNSIGNED PACKAGES: ",
			    join(', ', keys %{$state->{packages_without_sig}});
		}
		print "\n";
	}
	if (defined $state->{updatedepends} && %{$state->{updatedepends}}) {
		print "Forced updates, bogus dependencies for ",
		    join(' ', sort(keys %{$state->{updatedepends}})),
		    " may remain\n";
	}
	inform_user_of_problems($state);
}


framework(
sub {
	if ($state->{allow_replacing}) {
		$state->progress->set_header("Checking packages");
		do_quirks($state);
	}

	$state->tracker->todo(@@todo2);
	# This is the actual very small loop that adds all packages
	while (my $set = shift @@todo2) {
		$state->progress->set_header("Checking packages");

		$state->status->what->set($set);
		unshift(@@todo2, install_set($set, $state));
		eval {
			$state->quirks->tweak_list(\@@todo2, $state);
		};
	}
});

@


1.478
log
@whitespace fixes
@
text
@d4 1
a4 1
# $OpenBSD$
@


1.477
log
@work-around !found error.
@
text
@d46 1
a46 1
	return  grep {/^\.libs\d*\-/o} 
d57 1
a57 1
		$state->print("Comparing full signature for ", 
d207 1
a207 1
		if (defined $state->{lastheader} && 
d230 2
a231 2
		if (is_installed($pkgname) && 
		    (!$state->{allow_replacing} ||	
d233 1
a233 1
		      !$plist->has_different_sig($state) && 
d242 1
a242 1
			$o->{tweaked} = 
d247 1
a247 1
		} 
d340 1
a340 1
				$state->errsay("Can't install ", $set->print, 
d351 1
a351 1
			$state->errsay("Cannot replace $toreplace in ", 
d364 1
a364 1
			$set->add_older(OpenBSD::Handle->create_old($toreplace, 
d376 1
a376 1
		
d453 1
a453 1
	
d562 1
a562 1
				if (!OpenBSD::x509::check_signature($plist, 
d593 1
a593 1
			    "Deinstallation of $oldname failed", 
d620 2
a621 2
	# XXX in `combined' updates, some dependencies may remove extra 
	# packages, so we do a double-take on the list of packages we 
d626 1
a626 1
	} 
d655 1
a655 1
				OpenBSD::Replace::perform_extraction($handle, 
d744 1
a744 1
				$handle->error_message, "\n"); 
d812 1
a812 1
		} 
d864 1
a864 1
			$set->cleanup(OpenBSD::Handle::CANT_INSTALL, 
d899 1
a899 1
	elsif ($opt_P eq 'ftp') { 
d1023 1
a1023 1
			push(@@todo2, 
d1036 1
a1036 1
		$state->print("Packages with signatures: ", 
d1039 1
a1039 1
			print ". UNSIGNED PACKAGES: ", 
d1045 1
a1045 1
		print "Forced updates, bogus dependencies for ", 
@


1.476
log
@work around a limitation of tracker/updateset: hints are tagged as to_update.
So if we replace an existing package, we may end up merging with ourselves
because of the initial hint. Make sure we create an older handle even in that
case.
@
text
@d229 1
@


1.475
log
@clean-up validate_plists a bit, so that it starts with a clean state.
new feature: if a normal updateset order does not fit, let the user decide
to do a "dangerous update", by deleting older packages first (if they fit).
tweak really_add to do so: move delete old packages out of the way, and add
a new state variable (extracted_first) to distinguish between both replace
modes.
@
text
@d360 1
a360 1
		if (defined $s) {
@


1.474
log
@clean up the ProgressMeter code, create a specific class if a Term
is around.
start using stuff from termcap, specifically, cleareol, and move to hp.
use the full line when we can, cram 100% if we can.
(this should flicker much less on slow terminals).

clean-up the install-and-progress bits to be in progressmeter, this removes
some code.

have pkg_create follow the same pattern as the others, with a state.
This allows us to unify error messages a bit.
@
text
@d575 29
d647 2
a648 1
	if ($replacing) {
d667 3
d671 2
a672 23
		build_before($set->older_to_do);
		iterate($set->older_to_do, sub {
			return if $state->{size_only};
			my $o = shift;
			$set->setup_header($state, $o, "deleting");
			my $oldname = $o->pkgname;
			$state->set_name_from_handle($o, '-');
			require OpenBSD::Delete;
			try {
			    OpenBSD::Delete::delete_plist($o->plist, $state);
			} catchall {
				$state->errprint($_);
				Fatal partial_install(
				    "Deinstallation of $oldname failed", 
				    $set, $state);
			};

			if (defined $state->{updatedepends}) {
				delete $state->{updatedepends}->{$oldname};
			}
			OpenBSD::PkgCfl::unregister($o->plist, $state);
		});
		# Here there should be code to handle old libs
d728 1
@


1.473
log
@consistent error. exit(1) if something bad happened.
(fixes some errors in ports)
@
text
@a617 2
	$set->compute_size;

@


1.472
log
@slightly terser messages, better use of terminal line
@
text
@d257 1
d744 1
d796 1
d819 1
a821 1
		$bad++;
d831 1
d839 1
d851 1
@


1.471
log
@fix merging behavior when merging doesn't occur:
- display message that says "this update didn't merge"
- be more specific in return values, because we want to distinguish between
we merged some stuff -> compute full depends / we didn't -> proceed

thanks to Florent Tribouilloy for being my guinea pig ;)
@
text
@d243 1
a243 1
			$state->updater->progress_message($state, "No need to reinstall $pkgname");
d1038 1
a1038 1
		$state->progress->set_header("Looking for packages");
d1045 1
a1045 1
		$state->progress->set_header("Looking for packages");
@


1.470
log
@allow 'update-only' installs
@
text
@d406 1
d420 1
d424 5
a428 1
				$set->try_merging($m, $state) or $okay = 0;
d434 1
a434 1
			return 1;
d437 1
a437 1
				return 1;
@


1.469
log
@bump this to updater, so that progress is shown again.
@
text
@d327 7
a333 1
	return 0 if @@conflicts == 0;
@


1.468
log
@quirks is special here too, oops.
@
text
@d243 1
a243 2
			$state->say("Not reinstalling $pkgname")
			    if $state->verbose >= 2 and !$n->{tweaked};
@


1.467
log
@allow installation to proceed even without -r if it's an actual update
(all markers match, conflict and pkgpath, and the pkgname is newer if it's
the same stem/flavor combo)
@
text
@d977 1
@


1.466
log
@move the oldlibs code into its separate file, prior to fixing it.
allow replacement if it only touches partial or libs
@
text
@d287 35
d332 6
a337 4
			$state->errsay("Can't install ", $set->print, 
			    " because of conflicts (",
			    join(',', @@conflicts), ")");
			return "conflicts";
@


1.465
log
@unify options a bit: use -Dname=value for defines uniformously (e.g., deprecate
-F keyword heavily).
@
text
@d294 1
d296 6
a301 3
		$state->errsay("Can't install ", $set->print, 
		    " because of conflicts (",join(',', @@conflicts), ")");
		return "conflicts";
a303 1

d565 2
a566 2
		require OpenBSD::Replace;
		OpenBSD::Replace::save_old_libraries($set, $state);
@


1.464
log
@use full signatures to avoid downgrades.
remove double check in update that properly belongs in pkg_add
replace has_new_sig by has_different_sig, with better diagnostic messages.
@
text
@d813 1
a813 1
    'pkg_add [-acIinqrsUuvxz] [-A arch] [-B pkg-destdir] [-F keywords]',
@


1.463
log
@tracker and updater are also auto-cached
@
text
@d50 1
a50 1
sub has_new_sig
d53 1
a53 1
	if (!defined $plist->{new_sig}) {
d56 20
a75 3
		$state->say("Comparing full signature for ", $plist->pkgname, " \"".$o->string."\" vs. \"".$n->string."\": ", $n->compare($o) eq 0 ? "equal" : "different") 
		    if $state->verbose >= 3;
		$plist->{new_sig} = $n->compare($o) ne 0;
d77 1
a77 1
	return $plist->{new_sig};
d232 1
a232 1
		      !$plist->has_new_sig($state) && 
@


1.462
log
@avoid loop if conflict/replace end up finding kept handles.
@
text
@d107 5
a111 9
sub updater
{
	my $state = shift;
	if (!defined $state->{updater}) {
		require OpenBSD::Update;
		$state->{updater} = OpenBSD::Update->new;
	}
	return $state->{updater};
}
d113 5
a117 9
sub tracker
{
	my $state = shift;
	if (!defined $state->{tracker}) {
		require OpenBSD::Tracker;
		$state->{tracker} = OpenBSD::Tracker->new;
	}
	return $state->{tracker};
}
d163 1
a163 1
	    return OpenBSD::Dependencies::Solver->new(shift);
d168 1
a168 1
	    return OpenBSD::ConflictCache->new;
@


1.461
log
@use Auto::cache
@
text
@d301 1
@


1.460
log
@There's no reason for -l to imply -z.

Also, fix a nasty bug: when finding installed packages in a set, don't
remove them silently, just tag them to be kept, and let tracker know about
it (fixes loop1 regress)
@
text
@d169 4
a172 8
sub solver
{
	my $set = shift;
	if (!defined $set->{solver}) {
		$set->{solver} = OpenBSD::Dependencies::Solver->new($set);
	}
	return $set->{solver};
}
d174 4
a177 8
sub conflict_cache
{
	my $set = shift;
	if (!defined $set->{conflict_cache}) {
		$set->{conflict_cache} = OpenBSD::ConflictCache->new;
	}
	return $set->{conflict_cache};
}
@


1.459
log
@keep going after collisions
@
text
@d716 1
a716 2
			$set->cleanup(OpenBSD::Handle::ALREADY_INSTALLED);
			return ();
d910 2
d919 1
a919 1
			push(@@todo2, OpenBSD::UpdateSet->new->add_hints($_));
a948 1
		my $m = $opt_z ? "add_hints" : "add_hints2";
d951 2
a952 1
			push(@@todo2, OpenBSD::UpdateSet->new->$m($pkgname));
@


1.458
log
@first step in comparing full signatures: make them full objects, with
proper sign/compare interfaces.
@
text
@a524 6
	for my $h ($set->newer) {
		$h->plist->set_infodir($h->location->info);
	}

	$set->validate_plists($state);

d789 11
@


1.457
log
@explicit-update support
(also url support, but commented out for now)
@
text
@d56 1
a56 1
		$state->say("Comparing full signature for ", $plist->pkgname, " \"$o\" vs. \"$n\": ", $n eq $o ? "equal" : "different") 
d58 1
a58 1
		$plist->{new_sig} = $n ne $o;
@


1.456
log
@revert the merge flags.
In normal cases, updatedepends should no longer be needed:
pkg_add will merge updates together to make sure depdencies are
always satisfied.
e.g.,

sdlmame-tools-0.130p0->sdlmame-tools-0.132p0 forward dependencies:
| Dependency of sdlmame-0.130p1 on sdlmame-tools-0.130p0 doesn't match
Merging sdlmame-0.130p1->sdlmame-0.132p0
sdlmame-0.130p1+sdlmame-tools-0.130p0->sdlmame-0.132p0+sdlmame-tools-0.132p0: ok
@
text
@d923 1
@


1.455
log
@be slightly smarter about forward deps: check we have updates before
merging. Otherwise, fall back to updatedepends or asking.
@
text
@d372 1
a372 1
		if ($state->{defines}->{mergeupdates}) {
@


1.454
log
@fix for error message logging.
@
text
@d6 1
a6 1
# Copyright (c) 2003-2009 Marc Espie <espie@@openbsd.org>
d345 18
d373 1
d375 1
a375 7
				my $s = $state->tracker->is_to_update($m);
				if (defined $s) {
					$set->merge($state->tracker, $s);
				} else {
					$set->add_older(OpenBSD::Handle->create_old(
					    $m, $state));
				}
d377 3
a379 3
			$state->say("Merging ", $set->print, $state->ntogo);
			return 0;
		} elsif ($state->{defines}->{updatedepends}) {
@


1.453
log
@add meat to the "can't install" stupid handle message
@
text
@d670 1
a670 1
			$state->log("Can't install ", $handle->pkgname, ":",
@


1.452
log
@don't bother clearing the line, since we do that automatically when we
write new info. This lets messages persist a bit longer.
@
text
@d253 1
a253 1
	my $check = $set->can_install($state);
d256 2
a257 2
	if (!$check) {
		$set->cleanup(OpenBSD::Handle::CANT_INSTALL);
d286 1
a286 1
sub can_install
d292 1
a292 1
	return 1 if @@conflicts == 0;
d296 1
a296 1
		return 0;
d305 1
a305 1
			return 0;
d342 1
a342 1
	return 1;
d751 1
a751 1
		$set->cleanup(OpenBSD::Handle::CANT_INSTALL);
d757 1
a757 1
		$set->cleanup(OpenBSD::Handle::CANT_INSTALL);
d769 1
a769 1
		$set->cleanup(OpenBSD::Handle::CANT_INSTALL);
d776 1
a776 1
			$set->cleanup(OpenBSD::Handle::CANT_INSTALL);
@


1.451
log
@take merging of sets into account when creating a header.
@
text
@a572 1
			$state->progress->clear;
a599 1
			$state->progress->clear;
a603 1
	my $first = 1;
a607 4
		if (!$first) {
			$state->progress->next;
			$first = 0;
		}
@


1.450
log
@do "not reinstalling" in a more intelligent way, by moving things into
kept, and then, just nop'ing a set with nothing to do...
@
text
@d90 6
a95 3
		return $state->{deptree}->{$pkg}->short_print.':';
	} else {
		return '';
d97 1
@


1.449
log
@a few more tweaks:
- allow for merged updates if we want them
- deplist becomes a hash, maybe useful for big sets
- simplify loop checking. We don't actually care whether we find any.
- be more aggressive in keeping cached stuff, create solver or conflict_cache
if need be.
@
text
@d229 8
a236 1
			$n->{tweaked} = 
d240 3
a242 4
			$state->tracker->uptodate($set);
			$state->tracker->{uptodate}->{$pkgname} = 1;
			$n->cleanup(OpenBSD::Handle::ALREADY_INSTALLED);
		}
d784 3
a786 1
	really_add($set, $state);
@


1.448
log
@simplify solver handling, rely on cache to avoid recomputing stuff
(large performance gain).
@
text
@d343 16
a358 14
	if (keys %$bad > 0) {
#		for my $m (keys %$bad) {
#			my $s = $state->tracker->is_to_update($m);
#			if (defined $s) {
#				$set->merge($state->tracker, $s);
#			} else {
#				$set->add_older(OpenBSD::Handle->create_old($m, 
#				    $state));
#			}
#		}
#		$state->say("Merging ", $set->print, $state->ntogo);
#		return;
		if ($state->{defines}->{updatedepends}) {
		    $state->errsay("Forcing update");
d361 3
d366 1
a366 1
			return 0;
d725 1
a725 3
		if ($set->solver->check_for_loops($state)) {
			return $set;
		}
d730 2
a731 1
		if (!$set->check_forward_dependencies($state)) {
d735 3
@


1.447
log
@performance gain: cache conflicts.
@
text
@d714 8
a721 13
	if (!defined $set->{solver} || $set->{solver}->{not_ready}) {
		delete $set->{solver};
		$set->{solver} = OpenBSD::Dependencies::Solver->new($set);
		my @@deps = $set->{solver}->solve_depends($state);
		if ($state->verbose >= 2) {
			$set->{solver}->dump;
		}
		if (@@deps > 0) {
			$state->build_deptree($set, @@deps);
			if ($set->{solver}->check_for_loops($state)) {
				return $set;
			}
			return (@@deps, $set);
d723 1
d735 1
a735 1
	my @@baddeps = $set->{solver}->check_depends;
d746 1
a746 2
#	print "Didn't need to process: ", join(',', @@{$set->{solver}->{todo}}), "\n";
	if (!$set->{solver}->solve_wantlibs($state)) {
d752 1
a752 1
#	if (!$set->{solver}->solve_tags($state)) {
@


1.446
log
@prepare to cache conflicts in sets: object to do so, code to merge conflicts
and solver, actual auto-gen of conflict cache and solver.
@
text
@d257 1
a257 1
	my @@conflicts;
d260 1
a260 2
		push(@@conflicts, 
		    OpenBSD::PkgCfl::find_all($handle->plist, $state));
d262 1
a262 2
	my %conflicts = map {($_,1)} @@conflicts;
	return keys %conflicts;
@


1.445
log
@move check for already installed UP, which allows me to deal with UpdateSet
and tracker globally to avoid loops.
@
text
@d130 31
d164 18
@


1.444
log
@use new forward dep adjust.
@
text
@d173 15
@


1.443
log
@prepare to handle forward dependencies in a simpler way
@
text
@a502 1
		$set->{solver}->record_old_dependencies($state);
d582 1
a582 1
#		$set->{forward}->adjust($state);
a583 1
	$set->{solver}->adjust_old_dependencies($state);
@


1.442
log
@move forward dependency checking to very late, so we can reuse the result.
uncache conflict checking, since it might need to be redone now...
@
text
@d279 1
a279 1
	my $bad = $set->{forward}->check($set, $state);
d582 3
d770 1
@


1.441
log
@move code around a bit, more functions. Especially do the exec check
ways later, when we're certain we're not going to change the set any longer,
so we don't need to go back.
@
text
@d179 2
a180 1
	return 1 if defined $set->{installable};
d182 1
a182 4
	$set->{installable} = $set->can_install($state);
	return 0 if !defined $set->{installable};

	if (!$set->{installable}) {
a249 28
	require OpenBSD::ForwardDependencies;
	if (!defined $set->{forward}) {
		$set->{forward} = OpenBSD::ForwardDependencies->find($set);
		my $bad = $set->{forward}->check($set, $state);

		if (keys %$bad > 0) {
#			for my $m (keys %$bad) {
#				my $s = $state->tracker->is_to_update($m);
#				if (defined $s) {
#					$set->merge($state->tracker, $s);
#				} else {
#					$set->add_older(OpenBSD::Handle->create_old($m, 
#					    $state));
#				}
#			}
#			$state->say("Merging ", $set->print, $state->ntogo);
#			return;
			if ($state->{defines}->{updatedepends}) {
			    $state->errsay("Forcing update");
			} elsif ($state->{interactive}) {
				if ($state->confirm("Proceed with update anyways", 0)) {
				}
			} else {
				return 0;
			}
		}
	}

d273 32
d667 8
a680 3
		for my $handle ($set->newer) {
			$handle->location->close_now;
		}
a688 3
		for my $handle ($set->newer) {
			$handle->location->close_now;
		}
a694 1
#		$location->close_now;
@


1.440
log
@nits
@
text
@d300 1
a300 3
	require OpenBSD::Replace;

	return OpenBSD::Replace::is_set_safe($set, $state);
d401 1
a401 1
sub really_add
a403 8

	for my $h ($set->newer) {
		$h->plist->set_infodir($h->location->info);
	}

	$set->validate_plists($state);

	my $errors = 0;
d427 15
d586 1
a586 1
sub install_set
a589 21
	$set = $set->real_set;

	if ($set->{finished}) {
		return ();
	}

	if (!$state->updater->process_set($set, $state)) {
		return ();
	}

	for my $handle ($set->newer) {
		if ($state->tracker->is_installed($handle->pkgname)) {
			$set->cleanup(OpenBSD::Handle::ALREADY_INSTALLED);
			return ();
		}
	}

	if (!$set->complete($state)) {
		return $set;
	}

d593 1
a593 1
			return ();
d602 1
a602 1
			return ();
d612 1
a612 1
					return ();
d617 31
d701 8
@


1.439
log
@tweak forward dep "almost ready" code and activate loop checker.
@
text
@d238 1
a238 1
		next if $set->{older}->{$toreplace};
@


1.438
log
@delete partial solvers later, so I can use their deplist to check for loops.
@
text
@d258 11
a276 11
#		XXX can't do this yet, have to protect updates against loops
#		$later = 1;
#		for my $m (keys %$bad) {
#			my $s = $state->tracker->is_to_update($m);
#			if (defined $s) {
#				$set->merge($state->tracker, $s);
#			} else {
#				$set->add_older(OpenBSD::Handle->create_old($m, 
#				    $state));
#			}
#		}
d643 3
a645 1
			# here I can check for loops
@


1.437
log
@compute forward dependencies later, so that we don't have to do it again,
and show them just once.
@
text
@d634 2
a635 1
	if (!defined $set->{solver}) {
d643 1
a643 3
			if ($set->{solver}->{not_ready}) {
				delete($set->{solver});
			}
@


1.436
log
@better
@
text
@d250 1
d253 3
a255 2
	my $forward = OpenBSD::ForwardDependencies->find($set);
	my $bad = $forward->check($set, $state);
d257 8
a264 5
	if (keys %$bad > 0) {
		if ($state->{defines}->{updatedepends}) {
		    $state->errsay("Forcing update");
		} elsif ($state->{interactive}) {
			if ($state->confirm("Proceed with update anyways", 0)) {
a265 3
		} else {
			return 0;
		}
d277 1
a279 3
	return if $later;

	$set->{forward} = $forward;
@


1.435
log
@Better, more global way of dealing with forward dependencies, and to
ask just once per-set for exec/unexec.

Todo: forward-deps could be merged, but this might lead to dependency
loops, we have to detect them and act first

Todo: rewrite the other part of forward dependency handling (dep adjustment)
@
text
@d302 1
a302 3
	return 0 unless OpenBSD::Replace::is_set_safe($set, $state);

	return 1;
@


1.434
log
@check new package later, after we're sure of the set.
avoid asking the user for @@exec twice, as noticed by kettenis@@
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.433 2009/12/21 11:03:00 espie Exp $
a204 19
sub is_new_stuff_safe
{
	my ($set, $state) = @@_;

	my $r = 1;

	for my $handle ($set->newer) {
		require OpenBSD::Replace;

		my $plist = $handle->plist;
		if (!OpenBSD::Replace::is_new_package_safe($plist, $state)) {
			$state->say("Can't safely update to ", 
			    $handle->pkgname," (use -F update to force it)");
			$r = 0;
		}
	}
	return $r;
}

d250 27
d279 1
a279 3
	if (!$set->is_new_stuff_safe($state)) {
		return 0;
	}
a292 7
		if (!OpenBSD::Replace::can_old_package_be_replaced($old->plist, 
		    $set, $state)) {
			$state->errsay("Can't update $name into ", 
			    $set->print);
			return 0;
		}

d299 5
@


1.433
log
@document recent changes, clean up old pkg_delete options
@
text
@d4 1
a4 1
# $OpenBSD$
a248 4
	if (!$set->is_new_stuff_safe($state)) {
		return 0;
	}

d270 4
@


1.432
log
@much simpler SIG{INFO} handling: create a status object in state and
update it when needed. Install a SIG{INFO} handler at start that will do
what's needed.
@
text
@d695 1
a695 1
    'pkg_add [-acIinqrUuvxz] [-A arch] [-B pkg-destdir] [-F keywords]',
@


1.431
log
@change verbosity handling: be silent by default, turn on the first level if -v.
Add more levels, specifically, lots of info regarding individual files only
visible if -vvvvv.
Make -n display the same stuff as normal (need -n -v to display more stuff).
Introduce -s, "size-only", turns on -n and does skip any extraction.
Sprinkle handlers for SIG_INFO, not really nice yet.

Note that -n is non functional for complex updates, because of caching
issues I have to fix.
@
text
@d98 3
a100 2
	my ($state, $h) = @@_;
	$state->log->set_context($h->pkgname);
a166 29
sub status
{
	my ($set, $state, $handle, $info) = @@_;

	my $header = $state->deptree_header($set);
	if (defined $handle) {
		$header .= $handle->pkgname;
	} else {
		$header .= $set->print;
	}
	if (defined $info) {
		$header.=" ($info)";
	}

	if (!defined $info) {
		$header = "Adding $header";
	}
	if (defined $state->{lastheader} && 
	    $header eq $state->{lastheader}) {
		return;
	}
	$state->{lastheader} = $header;
	$header .= "(pretending) " if $state->{not};
	if ($state->{do_faked}) {
		$header .= " under ".$state->{destdir};
	}
	$state->say($header);
}

d413 1
a413 1
		$state->set_name_from_handle($handle);
d436 5
a441 1
	local $SIG{'INFO'} = sub { $set->status($state); };
d501 1
a501 1
			$state->set_name_from_handle($o);
d534 1
a534 1
		$state->set_name_from_handle($handle);
d621 1
d698 1
a870 1
		local $SIG{INFO} = sub { $state->say($set->print, "(", $state->todo, ")"); };
d872 2
@


1.430
log
@create a $state->todo method to account for sets to install.
have tracker keep track of sets not done, and ask it directly for how many
there's still to do. Provide an offset into next for cases where we know
we already did a set but haven't accounted for it yet.
-> more accurate number of sets still to do.
@
text
@d57 1
a57 1
		    if $state->{very_verbose};
d148 1
d166 29
d465 1
d499 1
d521 1
d547 1
d658 1
a658 1
		if ($state->{verbose}) {
d812 1
d848 1
a849 2

	} else {
d893 1
@


1.429
log
@bye bye old
@
text
@d80 6
d545 1
a545 1
	$state->progress->next($state->ntogo);
a579 1
		$set->{finished} = 1;
a852 1
		$state->{todo} = (scalar @@todo2) + 1;
a859 1
		$state->{todo} = scalar @@todo2;
@


1.428
log
@misplaced change, found it back.
@
text
@a791 1
			$state->{full_update} = 1;
@


1.427
log
@since some packages in updatesets don't need updates, be explicit about it.
This is more complex and simpler at the same time...
@
text
@d720 1
a720 1
$state->{allow_replacing} = $opt_r || $opt_u;
@


1.426
log
@fuss about install msgs: new method state->ntogo, use it to annotate more
messages with global progress information.

Also, when not finding a suitable update, report it if set is not a simple
update. Helps in figuring out cases like gstreamer...
@
text
@d299 3
a301 3
	# no conflicts between newer sets
	for my $h ($set->newer) {
		for my $h2 ($set->newer) {
a309 10
	# and between newer sets and kept sets neither
	for my $h ($set->newer) {
		for my $h2 ($set->older) {
			next unless $h2->{keepit};
			if ($h->plist->conflict_list->conflicts_with($h2->pkgname) || $h2->plist->conflict_list->conflicts_with($h->pkgname)) {
				$state->errsay($set->print, ": internal conflict between ", $h->pkgname, " and ", $h2->pkgname);
				return 0;
 			}
		}
	}
@


1.425
log
@off by one the other way round
@
text
@d549 1
a549 1
	$state->progress->next($state->{todo});
@


1.424
log
@okay, so old libs are not 'kept', keep track of updates correctly instead
@
text
@d549 1
a549 1
	$state->progress->next($state->{todo}-1);
@


1.423
log
@simplify set printing
@
text
@d299 1
d307 11
@


1.422
log
@have pkg_add recheck there are no internal conflicts in an updateset.
provides a different failure for the fam/gamin update (better one actually,
since we go further...)
@
text
@d84 1
a84 1
		return $state->{deptree}->{$pkg}->shorter_print.':';
d135 1
a135 1
		$header .= $set->short_print;
d235 1
a235 1
		$state->errsay("Can't install ", $set->short_print, 
d249 1
a249 1
			    $set->short_print, ": just got installed");
d282 1
a282 1
			    $set->short_print);
d303 1
a303 1
				$state->errsay($set->short_print, ": internal conflict between ", $h->pkgname, " and ", $h2->pkgname);
d633 1
a633 1
		$state->errsay("Can't install ", $set->short_print,
@


1.421
log
@do the same dance with older packages: build before list, and use it when
deleting.
@
text
@d295 16
d661 5
@


1.420
log
@record internal updateset dependencies for new packages, and respect them
while installing (need doing something similar for old packages)
@
text
@d329 1
a329 1
sub iterate
d331 6
a336 3
	my $sub = pop @@_;
	for my $p (@@_) {
		&$sub($p);
d350 1
a350 1
sub iterate2
d463 1
d489 1
a489 1
	iterate2($set->newer, sub {
@


1.419
log
@simplify tracker a bit now we know what we're doing.
kill code that never got used
@
text
@d329 43
d460 2
a461 1
		for my $o ($set->older_to_do) {
d480 1
a480 1
		}
d485 3
a487 1
	for my $handle ($set->newer) {
d515 1
a515 1
	}
@


1.418
log
@-U before -u;
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.417 2009/12/05 23:13:01 espie Exp $
d178 1
a178 1
		$state->tracker->mark_cant_update($set);
a182 24
sub reorder_old
{
	my ($set, $state) = @@_;
	# no need to sort things if there is one package to replace
	# return if $set->older <= 1;

	my $resolved;
	my @@l = ();
	my %todo = map {($_->pkgname, $_)} $set->older;
	do {
		$resolved = 0;
BIGLOOP: 	while (my ($pkg, $h) = each %todo) {
			for my $name (OpenBSD::RequiredBy->new($pkg)->list) {
				next BIGLOOP if defined $todo{$name};
			}
			push(@@l, $h);
			delete $todo{$pkg};
			$resolved++;
		}
	} while ($resolved);
	push(@@l, values %todo);
	$set->{older} = \@@l;
}

d532 1
a532 1
			$state->tracker->mark_cant_update($set);
d541 1
a541 1
					$state->tracker->mark_cant_update($set);
d574 1
a574 1
		$state->tracker->mark_cant_update($set);
d584 1
a584 1
		$state->tracker->mark_cant_update($set);
d597 1
a597 1
	$state->tracker->mark_installed($set);
d662 1
a662 1
	my @@cantupdate = $state->tracker->cant_update;
a773 1
	$state->tracker->add_sets(@@todo2);
d779 2
@


1.417
log
@a bit more documentation, including revisit of OpenBSD::Intro to reflect
the current state of things.
@
text
@d4 1
a4 1
# $OpenBSD$
d630 1
a630 1
    'pkg_add [-acIinqruUvxz] [-A arch] [-B pkg-destdir] [-F keywords]',
@


1.416
log
@use eval {} everywhere around quirks.
also, remove quirks from the list of packages to update, since it deserves
special treatment...
@
text
@d630 1
a630 1
    'pkg_add [-acIinqruvxz] [-A arch] [-B pkg-destdir] [-F keywords]',
@


1.415
log
@avoid progressmeter warning
@
text
@d722 1
a722 1
	}
d766 1
d809 1
a809 1
		if ($state->quirks) {
d811 1
a811 1
		}
@


1.414
log
@better quirks interface: pass the search object that was built, so we can
adjust it (eventually, pass the whole list ?)
@
text
@d799 1
@


1.413
log
@fix quirks object construction. Simplify its handling: just install/update
it first, and try to build the Quirks object. Make ourselves resilient to
errors in there.

For removing sets with only older packages, we have to call complete_old
even if there are no conflicts at all !
@
text
@d713 11
d800 1
a800 6
		install_set(quirk_set(), $state);
		eval {
			require OpenBSD::Quirks;
			# interface version number.
			$state->{quirks} = OpenBSD::Quirks->new(0);
		}
@


1.412
log
@fix off-by-one, noticed by frantisek holop
@
text
@d167 3
a294 1
		$old->complete_old;
a621 7
	# if we have a quirks object, we try to create the object that goes
	# with it.
	if ($set->{quirks}) {
		require OpenBSD::Quirks;
		# interface version number.
		$state->{quirks} = OpenBSD::Quirks->new(0);
	}
d706 1
a706 1
		$set->add_older(@@$l);
a757 3
	if ($state->{allow_replacing}) {
#		unshift(@@todo2, quirk_set());
	}
d787 9
d802 1
a802 1
			$state->quirks->tweak_list(\@@todo2);
@


1.411
log
@fix the case where you look to update one package: the dependencies of the
new package must first be updated too.
@
text
@d493 1
a493 1
	$state->progress->next($state->{todo});
@


1.410
log
@set-up for quirks, just don't do it yet.
@
text
@d632 1
a632 1
our ($opt_a, $opt_A, $opt_P, $opt_Q, $opt_r, $opt_u, $opt_l, $opt_z);
d634 1
a634 1
handle_options('aqchruzl:A:P:Q:', {},
d677 1
@


1.409
log
@fix some inter-dependencies case:
- when we merge updatesets, invalidate the solver (there isn't any, usually).
- look inside set for check_depends.
- do register_dependencies after committing all plists to cache.
@
text
@d116 7
d620 7
d700 17
d762 3
d799 3
@


1.408
log
@okay, this one needs tagging as well
@
text
@a493 1
		$set->{solver}->register_dependencies($state);
d500 3
@


1.407
log
@for every case we can't install stuff, we have to let the tracker now, and
close the set.
@
text
@d596 4
a599 4
		if (!$defines{libdepends}) {
			$bad++;
			return ();
		}
@


1.406
log
@better errors: have $set->cleanup mark set as finished.
in case there is an issue, register set as not updateable with tracker.
@
text
@d586 2
@


1.405
log
@better: have can_install return 0/1 as definitive answer, and return "undef"
for try again later.

Don't bother cleaning up set from can_install, since complete does it too.
@
text
@d168 1
a168 1
		$set->{finished} = 1;
d545 1
d554 1
d607 1
a607 3
	for my $handle ($set->newer) {
		$handle->cleanup;
	}
a608 1
	$set->{finished} = 1;
@


1.404
log
@compute updates on the fly, instead of "at start"
@
text
@d163 2
a164 3
	my $r = $set->can_install($state);
	return 0 if defined $r && $r == 0;
	$set->{installable} = $r;
d168 1
d249 1
a249 1
		$state->say("Can't install ", $set->short_print, 
d251 1
a251 2
		$set->cleanup(OpenBSD::Handle::CANT_INSTALL);
		return;
d256 1
a256 2
		$set->cleanup(OpenBSD::Handle::CANT_INSTALL);
		return;
d264 1
a264 2
			$set->cleanup(OpenBSD::Handle::CANT_INSTALL);
			return;
d279 1
a279 1
	return 0 if $later;
d296 1
a296 1
			$state->say("Can't update $name into ", 
d298 1
a298 2
			$set->cleanup(OpenBSD::Handle::CANT_INSTALL);
			return;
@


1.403
log
@set things up for updates on the fly. In particular, we may have to look
into "to_update" stuff...
@
text
@d760 1
a760 9
	$state->progress->set_header("Looking for packages");
	$state->{todo} = scalar @@todo2;
	for my $set (@@todo2) {
		if (!$state->updater->process_set($set, $state)) {
			$set->{finished} = 1;
		}
		$state->{todo}--;
	}
	$state->progress->next;
d763 1
@


1.402
log
@clean up conflict handling and dependency adjustement: build list
of conflict globally, add it as old handles, and then use it everywhere.
@
text
@d522 5
@


1.401
log
@slightly simpler error handling
@
text
@d197 1
a197 1
sub can_install
d202 1
d204 2
a205 2
		my $plist = $handle->plist;
		push(@@conflicts, OpenBSD::PkgCfl::find_all($plist, $state));
a206 2


d208 2
a209 1
	@@conflicts = keys %conflicts;
d211 3
a213 6
	return 1 if @@conflicts == 0;
	if (!$state->{allow_replacing}) {
		$state->say("Can't install ", $set->short_print, " because of conflicts (",join(',', @@conflicts), ")");
		$set->cleanup(OpenBSD::Handle::CANT_INSTALL);
		return;
	}
d215 1
d224 1
a224 2
			$set->cleanup(OpenBSD::Handle::CANT_INSTALL);
			return;
d227 28
d256 6
a261 1
	my $manual_install = 0;
d264 2
a265 1
			$state->errsay("Cannot replace $toreplace in ", $set->short_print, ": just got installed");
d270 6
a275 3
		my $old_handle = $set->{older}->{$toreplace};
		if (defined $old_handle) {
			$old_handle->complete_old;
d277 2
a278 7
			my $s = $state->tracker->is_to_update($toreplace);
			if (defined $s) {
				$set->merge($state->tracker, $s);
				return 0;
			}
			$old_handle = OpenBSD::Handle->create_old($toreplace, $state);
			# XXX stuff to do
d280 9
d290 2
a291 2
		if ($old_handle->has_error(OpenBSD::Handle::NOT_FOUND)) {
			Fatal "Can't find $toreplace as an installed package\n";
d293 2
a294 2
		if ($old_handle->has_error(OpenBSD::Handle::BAD_PACKAGE)) {
			Fatal "Couldn't find packing-list for $toreplace\n";
d297 4
a300 3
		if (!OpenBSD::Replace::can_old_package_be_replaced($old_handle->plist, 
		    $set, $state, \%conflicts)) {
			$state->say("Can't update $toreplace into ", $set->short_print);
a303 2
		$set->add_older($old_handle) 
		    if !defined $set->{older}->{$toreplace};
d305 1
a305 1
		if ($old_handle->plist->has('manual-installation')) {
d309 2
a310 9
	if ($manual_install) {
		for my $handle ($set->newer) {
			my $plist = $handle->plist;
			if (!$plist->has('manual-installation')) {
				OpenBSD::PackingElement::ManualInstallation->add($plist);
			}
		}
	}
	$set->{skipupdatedeps} = \%conflicts;
@


1.400
log
@handle more general conflicts:
- match old spec against any of the new packages in the set.
- manage conflicts globally if several newer packages are there.
- remove the limit of 5 conflicting packages, it's no longer really relevant.
@
text
@d168 1
a168 3
		for my $n ($set->newer) {
			$n->cleanup(OpenBSD::Handle::CANT_INSTALL);
 		}
d214 1
a214 1
		$set->set_error(OpenBSD::Handle::CANT_INSTALL);
d226 1
a226 1
			$handle->set_error(OpenBSD::Handle::CANT_INSTALL);
d235 1
a235 1
			$set->set_error(OpenBSD::Handle::CANT_INSTALL);
d262 1
a262 1
			$set->set_error(OpenBSD::Handle::CANT_INSTALL);
d494 1
a494 1
			$handle->cleanup(OpenBSD::Handle::ALREADY_INSTALLED);
d505 1
d513 1
d519 5
a523 2
				$state->say($handle->pkgname, " is not for the right architecture");
				return () unless $defines{arch};
@


1.399
log
@oops
@
text
@d158 1
a158 1
		return if $n->has_error;
d161 1
a161 1
	return if defined $set->{installable};
d163 3
a165 1
	$set->{installable} = $set->can_install($state);
d172 1
d202 2
d206 3
a208 3
		my $pkgname = $handle->pkgname;
		my @@conflicts = OpenBSD::PkgCfl::find_all($plist, $state);
		next if @@conflicts == 0;
d210 2
a211 2
		my %conflicts = map {($_,1)} @@conflicts;
		@@conflicts = keys %conflicts;
d213 6
a218 5
		if (!$state->{allow_replacing}) {
			$state->say("Can't install $pkgname because of conflicts (",join(',', @@conflicts), ")");
			$handle->set_error(OpenBSD::Handle::CANT_INSTALL);
			return;
		}
a219 5
		if (@@conflicts >  5) {
			$state->say("Can't install $pkgname because of conflicts (",join(',', @@conflicts), ")");
			$handle->set_error(OpenBSD::Handle::CANT_INSTALL);
			return;
		}
d221 1
d224 1
d226 2
a227 1
			$state->say("Can't safely update to $pkgname (use -F update to force it)");
d231 1
d233 7
a239 6
		for my $toreplace (@@conflicts) {
			if ($state->tracker->is_installed($toreplace)) {
				$state->errsay("Cannot replace $toreplace with $pkgname: just got installed");
				$handle->set_error(OpenBSD::Handle::CANT_INSTALL);
				return;
			}
d241 2
a242 2
			my $old_handle = $set->{older}->{$toreplace};
			$old_handle //= OpenBSD::Handle->create_old($toreplace, $state);
d244 25
a268 7
			
			if ($old_handle->has_error(OpenBSD::Handle::NOT_FOUND)) {
				Fatal "Can't find $toreplace as an installed package\n";
			}
			if ($old_handle->has_error(OpenBSD::Handle::BAD_PACKAGE)) {
				Fatal "Couldn't find packing-list for $toreplace\n";
			}
d270 8
a277 11
			if (!OpenBSD::Replace::can_old_package_be_replaced($old_handle->plist, 
			    $pkgname, $state, \%conflicts)) {
				$state->say("Can't update $toreplace into $pkgname");
				$handle->set_error(OpenBSD::Handle::CANT_INSTALL);
				return;
			}
			$set->add_older($old_handle) 
			    if !defined $set->{older}->{$toreplace};

			if ($old_handle->plist->has('manual-installation') && 
			    !$plist->has('manual-installation')) {
a280 1
		$set->{skipupdatedeps} = \%conflicts;
d282 1
d488 2
d501 3
a503 1
	$set->complete($state);
@


1.398
log
@when resolving conflicts, don't recreate handles for packages being replaced
if we already know they're being replaced.
This requires completing them with a plist.
(some cleanup of api to do later)
@
text
@d666 1
a666 1
			push(@@todo2, OpenBSD::UpdateSet->new->$m($_));
@


1.397
log
@allow -l list more_packages

prepare for incremental updates: avoid reinstalling finished set.
don't display stuff we will install, it's mostly useless.
@
text
@d235 4
a238 1
			my $old_handle = OpenBSD::Handle->create_old($toreplace, $state);
d252 2
a253 1
			$set->add_older($old_handle);
@


1.396
log
@todo all over
@
text
@d504 3
d546 1
a601 5
if ($opt_l && @@ARGV != 0) {
	Usage "No pkgnames after -l";
}


a619 11
sub inform_user_of_pending_install
{
	my $state = shift;

	my @@t = grep { !$_->{finished} } @@todo2;
	if (@@t > 0) {
		$state->say("Installing ", 
		    join(',', map {$_->short_print} @@t));
	}
}

d622 1
d629 1
a629 1
			push(@@ARGV, $_);
d633 2
a634 9
	# three cases: 
	# 1/ match fuzzily against a list
	if ($opt_l || $opt_z) {

		for my $_ (@@ARGV) {
			push(@@todo2, OpenBSD::UpdateSet->new->add_hints($_));
		}
	# 2/ update existing stuff
	} elsif ($opt_u) {
d659 2
a660 1
	# 3/ actual names
d662 1
a662 1
			push(@@todo2, OpenBSD::UpdateSet->new->add_hints2($pkgname));
a701 1
	inform_user_of_pending_install($state);
@


1.395
log
@do not inform user of !updated packages, they usually don't really care...
@
text
@d297 1
a297 1
	my ($set, $state, $todo) = @@_;
d437 1
a437 1
	$state->progress->next($todo);
d461 1
a461 1
	my ($set, $state, $todo) = @@_;
d538 1
a538 1
	really_add($set, $state, $todo);
d711 1
d716 1
d722 2
a723 1
		unshift(@@todo2, install_set($set, $state, scalar @@todo2));
@


1.394
log
@kill some old cruft, in particular -F conflicts has never worked...
@
text
@d608 1
a608 1
sub inform_user_of_pending_update
d613 1
a613 15
		$state->print("Cannot find updates for ", join(', ', (@@cantupdate > 50 ? @@cantupdate[1..50] : @@cantupdate)));
		print " and more" if @@cantupdate > 50;
		print "\n";
		if (@@todo2 == 0) {
			print "No updates found\n";
			exit(1);
		}
		if ($state->{defines}->{alwaysupdate} ||
		    $state->{full_update} && !$state->{interactive}) {
			print "Proceeding anyways\n";
		} else {
			if (!$state->confirm("Proceed", 0)) {
				exit(1);
			}
		}
d616 1
a616 1
		$state->say("There are some ambiguities. ",
d619 6
d627 1
a627 1
		$state->say("Running install ", 
d704 1
d717 1
a717 1
	inform_user_of_pending_update($state);
@


1.393
log
@no need to say we're installing, at the end...
@
text
@a208 4
			if ($state->{defines}->{conflicts}) {
				$state->say("Forcing install of $pkgname in the presence of conflicts (",join(',', @@conflicts), ")");
				return 1;
			}
@


1.392
log
@tweak completion messages: do the next only during the next iteration, so
that at end, we can show a full completion message for the whole set.
pass the number of packages still to-do through, so that the last complete
also says (n to go) during installs...
@
text
@d440 1
a440 1
	$set->setup_header($state, undef, $replacing ? "installing" : undef);
@


1.391
log
@change the timing a bit: create a list of updateset first, and process
them later.

To do that, normal additions go through hint2, and the findtruelocation
code moves to Update.pm

This will allow for more systematic handling of all names (including solving
more stuff on the fly, instead of upfront).
@
text
@d301 1
a301 1
	my ($set, $state) = @@_;
d410 1
d412 4
a416 1
		my $header = $state->deptree_header($set).$pkgname;
a432 1
		$state->progress->next;
d440 2
d465 1
a465 1
	my ($set, $state) = @@_;
d542 1
a542 1
	really_add($set, $state);
d731 1
a731 1
		unshift(@@todo2, install_set($set, $state));
@


1.390
log
@remove dead code
@
text
@a544 10
sub stem2location
{
	my ($repo, $name, $state) = @@_;
	my $l = $repo->match_locations(OpenBSD::Search::Stem->new($name));
	if (@@$l > 1 && !$state->{defines}->{allversions}) {
		$l = OpenBSD::Search::FilterLocation->keep_most_recent->filter_locations($l);
	}
	return $state->choose_location($name, $l);
}
 
a545 29
sub find_truelocations
{
	my ($old, $new, $state) = @@_;

	my $cache = {};
	for my $pkgname (@@$old) {
		if (OpenBSD::PackageName::is_stem($pkgname)) {
			my ($h, $path, $repo);
			if ($pkgname =~ m/\//o) {
				($repo, $path, $pkgname) = OpenBSD::PackageLocator::path_parse($pkgname);
				$h = $repo;
			} else {
				$h = 'OpenBSD::PackageLocator';
				$path = "";
			}
			my $l = stem2location($h, $pkgname, $state);
			if (defined $l) {
				push(@@$new, OpenBSD::UpdateSet->from_location($l));
 			} else {
 				$bad = 1;
			}
		} else {
			if (!defined $cache->{$pkgname}) {
				$cache->{$pkgname} = OpenBSD::UpdateSet->create_new($pkgname);
			}
			push(@@$new, $cache->{$pkgname});
		}
	}
}
d632 5
a636 2
	$state->say("Running update ", 
	    join(',', map {$_->short_print} @@todo2));
a654 1
		$state->progress->set_header("Looking for packages");
d656 1
a656 4
			my $set = OpenBSD::UpdateSet->new->add_hints($_);
			if ($state->updater->process_set($set, $state)) {
				push(@@todo2, $set);
			}
a657 1
		inform_user_of_pending_update($state);
a666 1
		$state->progress->set_header("Looking for updates");
d671 1
a671 1
				$l = stem2location($inst, $pkgname, $state);
d678 1
a678 4
				my $set = OpenBSD::UpdateSet->new->add_older(OpenBSD::Handle->from_location($l));
				if ($state->updater->process_set($set, $state)) {
					push(@@todo2, $set);
				}
a680 1
		$state->progress->next;
a681 1
		inform_user_of_pending_update($state);
d685 3
a687 2
		find_truelocations(\@@ARGV, \@@todo2, $state);
		OpenBSD::Add::tag_user_packages(@@todo2);
d716 8
a724 1
	$state->tracker->add_sets(@@todo2);
@


1.389
log
@revamp interactive stuff: simplify (just one always for everything, per
theo suggestion. Also go through the "state" object which simplifies code
a great deal)
@
text
@a591 1
$state->{cache} = {};
@


1.388
log
@-Vstat (get it from AddDelete)
@
text
@a31 1
use OpenBSD::Interactive;
d663 1
a663 2
			if (!OpenBSD::Interactive::confirm("Proceed", 
			    $state->{interactive}, 0)) {
@


1.387
log
@unify hints and normal updates some more
@
text
@a31 1
use OpenBSD::Vstat;
@


1.386
log
@unify hint and location processing some more.
@
text
@d649 30
d698 2
a699 5
			for my $hint ($set->hints) {
				if ($state->updater->process_hint($set, 
				    $hint, $state)) {
					push(@@todo2, $set);
				}
d702 1
d725 1
a725 5
				my $problem = 0;
				for my $l ($set->older) {
					(defined $state->updater->process_handle($set, $l, $state)) or $problem = 1;
				}
				if ($set->newer > 0) {
a726 5
				} else {
					$state->tracker->mark_uptodate($set);
				}
				if ($problem) {
					$state->tracker->mark_cant_update($set);
d732 2
a733 25
		my @@cantupdate = $state->tracker->cant_update;
		if (@@cantupdate > 0) {
			$state->print("Cannot find updates for ", join(', ', (@@cantupdate > 50 ? @@cantupdate[1..50] : @@cantupdate)));
			print " and more" if @@cantupdate > 50;
			print "\n";
			if (@@todo2 == 0) {
				print "No updates found\n";
				exit(1);
			}
			if ($state->{defines}->{alwaysupdate} ||
			    $state->{full_update} && !$state->{interactive}) {
				print "Proceeding anyways\n";
			} else {
				if (!OpenBSD::Interactive::confirm("Proceed", 
				    $state->{interactive}, 0)) {
					exit(1);
				}
			}
		}
		if (defined $state->{issues}) {
			$state->say("There are some ambiguities. ",
			    "Please run in interactive mode again.");
		}
		$state->say("Running update ", 
		    join(',', map {$_->short_print} @@todo2));
@


1.385
log
@pull more common code in a "framework" routine.
@
text
@d668 5
a672 2
			if ($state->updater->process_hint($set, $_, $state)) {
				push(@@todo2, $set);
@


1.384
log
@identical end sequence, to be factorized
@
text
@d65 1
a65 1
package OpenBSD::pkg_add::State;
a587 5
set_usage('pkg_add [-acIinqruvxz] [-A arch] [-B pkg-destdir] [-F keywords]',
'[-L localbase] [-l file] [-P type] [-Q quick-destdir] pkg-name [...]');

$state = OpenBSD::pkg_add::State->new;

d590 3
a592 1
handle_options('aqchruzl:A:P:Q:');
a593 1
try {
a642 1
setup_state();
d649 10
a658 7
if ($opt_l) {
	open my $f, '<', $opt_l or die "$!: bad list $opt_l";
	my $_;
	while (<$f>) {
		chomp;
		s/\s.*//;
		push(@@ARGV, $_);
a659 1
}
d661 23
a683 23
# three cases: 
# 1/ match fuzzily against a list
if ($opt_l || $opt_z) {

	$state->progress->set_header("Looking for packages");
	for my $_ (@@ARGV) {
		my $set = OpenBSD::UpdateSet->new->add_hints($_);
		if ($state->updater->process_hint($set, $_, $state)) {
			push(@@todo2, $set);
		}
	}
# 2/ update existing stuff
} elsif ($opt_u) {
	require OpenBSD::PackageRepository::Installed;

	if (@@ARGV == 0) {
		@@ARGV = sort(installed_packages());
		$state->{full_update} = 1;
	}
	my $inst = OpenBSD::PackageRepository::Installed->new;
	$state->progress->set_header("Looking for updates");
	for my $pkgname (@@ARGV) {
		my $l;
d685 22
a706 4
		if (OpenBSD::PackageName::is_stem($pkgname)) {
			$l = stem2location($inst, $pkgname, $state);
 		} else {
			$l = $inst->find($pkgname, $state->{arch});
d708 10
a717 7
		if (!defined $l) {
			$state->say("Problem finding $pkgname");
		} else {
			my $set = OpenBSD::UpdateSet->new->add_older(OpenBSD::Handle->from_location($l));
			my $problem = 0;
			for my $l ($set->older) {
				(defined $state->updater->process_handle($set, $l, $state)) or $problem = 1;
d719 3
a721 2
			if ($set->newer > 0) {
				push(@@todo2, $set);
d723 4
a726 4
				$state->tracker->mark_uptodate($set);
			}
			if ($problem) {
				$state->tracker->mark_cant_update($set);
d729 10
d740 5
a744 1
	$state->progress->next;
d746 9
a754 4
	my @@cantupdate = $state->tracker->cant_update;
	if (@@cantupdate > 0) {
		$state->print("Cannot find updates for ", join(', ', (@@cantupdate > 50 ? @@cantupdate[1..50] : @@cantupdate)));
		print " and more" if @@cantupdate > 50;
a755 13
		if (@@todo2 == 0) {
			print "No updates found\n";
			exit(1);
		}
		if ($state->{defines}->{alwaysupdate} ||
		    $state->{full_update} && !$state->{interactive}) {
			print "Proceeding anyways\n";
		} else {
			if (!OpenBSD::Interactive::confirm("Proceed", 
			    $state->{interactive}, 0)) {
				exit(1);
			}
	    	}
d757 4
a760 3
	if (defined $state->{issues}) {
		$state->say("There are some ambiguities. ",
		    "Please run in interactive mode again.");
a761 6
	$state->say("Running update ", 
	    join(',', map {$_->short_print} @@todo2));
} else {
# 3/ actual names
	find_truelocations(\@@ARGV, \@@todo2, $state);
	OpenBSD::Add::tag_user_packages(@@todo2);
d765 1
a765 1
my $dielater = do_the_main_work(
a772 31

OpenBSD::Add::manpages_index($state);


# and display delayed thingies.
if ($state->{packages_with_sig}) {
	$state->print("Packages with signatures: ", $state->{packages_with_sig});
	if ($state->{packages_without_sig}) {
		print ". UNSIGNED PACKAGES: ", join(', ', keys %{$state->{packages_without_sig}});
	}
	print "\n";
}
if (defined $state->{updatedepends} && %{$state->{updatedepends}}) {
	print "Forced updates, bogus dependencies for ", 
	    join(' ', sort(keys %{$state->{updatedepends}})),
	    " may remain\n";
}

# show any error, and show why we died...
rethrow $dielater;
} catch {
	print STDERR "$0: $_\n";
	if ($_ =~ m/^Caught SIG(\w+)/o) {
		kill $1, $$;
	}
	exit(1);
};

if ($bad) {
	exit(1);
}
@


1.383
log
@start pulling all the code that's the same between pkg_add and pkg_delete
into a common AddDelete package... lots of identical options and handling,
actually...
@
text
@a646 1

@


1.382
log
@pull the eval {} code into an anonymous sub, so that we can choose to exec
it without the eval (useful for backtraces when I want bug-reports,
since eval {} will show you the backtrace of the eval, not of the
function call)
@
text
@d23 3
a32 2
use OpenBSD::Getopt;
use OpenBSD::Error;
a35 1
use OpenBSD::Paths;
d39 1
a39 4
my $bad = 0;

our %defines = ();
our $not;
d66 1
a66 1
our @@ISA=(qw(OpenBSD::pkg_foo::State));
d267 1
a267 1
package main;
d591 5
a595 19
our ($opt_a, $opt_v, $opt_n, $opt_I, $opt_L, $opt_B, $opt_A, $opt_P, $opt_Q, $opt_x, $opt_r, $opt_q, $opt_c, $opt_i, $opt_u, $opt_l, $opt_z);
$opt_v = 0;
try { 
	getopts('aqchivnruxzIl:L:f:F:B:A:P:Q:',
	{
	 'h' => sub { Usage(); },
	 'F' => sub { 
	 		for my $o (split /\,/o, shift) { 
				$defines{$o} = 1;
			}
	    	},
	 'f' => sub { 
	 		for my $o (split /\,/o, shift) { 
				$defines{$o} = 1;
			}
	    	}}); 
} catchall {
	Usage($_);
};
a597 3
$opt_L = OpenBSD::Paths->localbase unless defined $opt_L;

my $state = OpenBSD::pkg_add::State->new;
a598 1
$state->{recorder} = OpenBSD::SharedItemsRecorder->new;
a599 1
$state->{localbase} = $opt_L;
a600 1
$state->{defines} = \%defines;
a635 5
$state->{not} = $opt_n;
# XXX RequiredBy
$not = $opt_n;
$state->{quick} = $opt_q;
$state->{extra} = $opt_c;
a636 5
$state->{dont_run_scripts} = $opt_I;
$state->{very_verbose} = $opt_v >= 2;
$state->{verbose} = $opt_v;
$state->{interactive} = $opt_i;
$state->{beverbose} = $opt_n || ($opt_v >= 2);
d648 1
a648 3
lock_db($state->{not}) unless $state->{defines}->{nolock};
$state->setup_progressmeter($opt_x);
$state->check_root;
a744 4
if ($bad) {
	exit(1);
}

d746 2
a747 8
my $handler = sub { my $sig = shift; die "Caught SIG$sig"; };
local $SIG{'INT'} = $handler;
local $SIG{'QUIT'} = $handler;
local $SIG{'HUP'} = $handler;
local $SIG{'KILL'} = $handler;
local $SIG{'TERM'} = $handler;

my $code = sub {
d753 1
a753 1
};
a754 10
if ($state->{defines}->{debug}) {
	&$code;
} else { 
	eval { &$code; };
}
my $dielater = $@@;

# cleanup various things
$state->{recorder}->cleanup($state);
OpenBSD::PackingElement::Fontdir::finish_fontdirs($state);
a755 1
OpenBSD::PackingElement::Lib::ensure_ldconfig($state);
a765 5
if ($state->{beverbose}) {
	OpenBSD::Vstat::tally();
}
$state->progress->clear;
$state->log->dump;
@


1.381
log
@simpler: the whole set fails
@
text
@d792 12
a803 5
# This is the actual very small loop that adds all packages
eval {
$state->tracker->add_sets(@@todo2);
while (my $set = shift @@todo2) {
	unshift(@@todo2, install_set($set, $state));
a804 2
};
# Note how well we performed. We need to clean up BEFORE we exit anyways.
@


1.380
log
@fix setup_header in -vx !-r case: show we are adding a package, and don't
show it twice.
@
text
@d516 2
a518 2
			$state->say("Can't install ", $handle->pkgname,
			    ": can't resolve ", join(',', @@baddeps));
@


1.379
log
@don't use Warn if we've got a $state, get through errprint/errsay.
Also: reset lastdisplay on clear, and don't clear twice.
@
text
@d128 1
a128 1
	
d140 8
a147 1
		$info //= 'add';
@


1.378
log
@also get most STDERR messages through the same way
@
text
@d232 1
a232 1
				Warn "Cannot replace $toreplace with $pkgname: just got installed\n";
d373 1
a373 1
					Warn $_;
d393 1
a393 1
				Warn $_;
d423 1
a423 1
				Warn $_;
@


1.377
log
@progressmeter puts STDOUT in autoflush if -t, so that it can display to it instead of piping a lot of stuff to STDERR.

Go through state->print for most messages, so they will NOT do weird things
with the progressmeter.
Use a ->say shortcut which does the same thing that perl 5.10 say does...
@
text
@d313 2
a314 3
				print STDERR 
				    "NOT CHECKING DIGITAL SIGNATURE FOR ",
				    $plist->pkgname, "\n";
d813 1
@


1.376
log
@remove forwarders, and provide a sensible API that says what's going on
(e.g., we're logging information for later).
@
text
@d61 1
a61 1
		print "Comparing full signature for ", $plist->pkgname, " \"$o\" vs. \"$n\": ", $n eq $o ? "equal\n" : "different\n" 
d208 1
a208 1
				print "Forcing install of $pkgname in the presence of conflicts (",join(',', @@conflicts), ")\n";
d211 1
a211 1
			print "Can't install $pkgname because of conflicts (",join(',', @@conflicts), ")\n";
d217 1
a217 1
			print "Can't install $pkgname because of conflicts (",join(',', @@conflicts), ")\n";
d225 1
a225 1
			print "Can't safely update to $pkgname (use -F update to force it)\n";
d247 1
a247 1
				print "Can't update $toreplace into $pkgname\n";
d488 1
a488 1
				print $handle->pkgname, " is not for the right architecture\n";
d511 2
a512 2
			print "Can't install ", $handle->pkgname,
			    ": can't resolve ", join(',', @@baddeps), "\n";
d724 1
a724 1
			print "Problem finding $pkgname\n";
d745 1
a745 1
		print "Cannot find updates for ", join(', ', (@@cantupdate > 50 ? @@cantupdate[1..50] : @@cantupdate));
d763 2
a764 2
		print "There are some ambiguities. Please run in interactive ".
		    "mode again.\n";
d766 2
a767 1
	print "Running update ", join(',', map {$_->short_print} @@todo2), "\n";
d805 1
a805 1
	print "Packages with signatures: ", $state->{packages_with_sig};
@


1.375
log
@bad espie: use strict/warnings consistently, and fix two nits and two
actual errors !
@
text
@d98 1
a98 1
	$state->set_pkgname($h->pkgname);
d480 1
a480 1
			$state->print("Can't install ", $handle->pkgname, ":",
d813 1
a813 1
$state->delayed_output;
@


1.374
log
@fix. cant_update list is again a simple list of names.
@
text
@a19 1
# this is it ! The hard one
d22 1
@


1.373
log
@let Handle display what went wrong.
Move stuff from being a fatal error to an error that displays at end, together
with an error code.
@
text
@d745 1
a745 1
		print "Cannot find updates for ", join(', ', map {$_->short_print} (@@cantupdate > 50 ? @@cantupdate[1..50] : @@cantupdate));
@


1.372
log
@tracker/updater methods for state that auto-create the object.
@
text
@d479 5
a483 6
			if (!$handle->{tweaked}) {
				$state->set_name_from_handle($handle);
				$state->fatal("Fatal error");
			} else {
				return ();
			}
@


1.371
log
@add the notion of "hints" to UpdateSet, in order to unify -z/-l handling:
create updatesets with nothing but a hint of what to install. Have
Update.pm do the dirty work.

More importantly, make Tracker aware of what's going on.
@
text
@d101 20
d231 1
a231 1
			if ($state->{tracker}->is_installed($toreplace)) {
d466 1
a466 1
		if ($state->{tracker}->is_installed($handle->pkgname)) {
d541 1
a541 1
	$state->{tracker}->mark_installed($set);
a684 3
require OpenBSD::Tracker;
$state->{tracker} = OpenBSD::Tracker->new;

a697 2
	require OpenBSD::Update;
	my $updater = OpenBSD::Update->new;
d702 1
a702 1
		if ($updater->process_hint($set, $_, $state)) {
a707 1
	require OpenBSD::Update;
a713 1
	my $updater = OpenBSD::Update->new;
d730 1
a730 1
				(defined $updater->process_handle($set, $l, $state)) or $problem = 1;
d735 1
a735 1
				$state->{tracker}->mark_uptodate($set);
d738 1
a738 1
				$state->{tracker}->mark_cant_update($set);
d744 1
a744 1
	my @@cantupdate = $state->{tracker}->cant_update;
d788 1
a788 1
$state->{tracker}->add_sets(@@todo2);
@


1.370
log
@put all the state of the current update into the tracker
@
text
@d681 3
a683 1
	my $k = OpenBSD::Search::FilterLocation->keep_most_recent;
d686 3
a688 12
		my $l;
		# first try to find us exactly
		$state->progress->message("Looking for $_");
		$l = OpenBSD::PackageLocator->match_locations(OpenBSD::Search::Exact->new($_), $k);
		if (@@$l == 0) {
			my $t = $_;
			$t =~ s/\-\d([^-]*)\-?/--/;
			$l = OpenBSD::PackageLocator->match_locations(OpenBSD::Search::Stem->new($t), $k);
		}
		my $r = $state->choose_location($_, $l);
		if (defined $r) {
			push(@@todo2, OpenBSD::UpdateSet->from_location($r));
@


1.369
log
@cleanup a bit printouts
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.368 2009/11/03 13:00:37 espie Exp $
d665 3
a709 1
	my @@cantupdate = ();
d728 2
d732 1
a732 1
				push(@@cantupdate, $set);
d738 1
a781 2
require OpenBSD::Tracker;
$state->{tracker} = OpenBSD::Tracker->new;
@


1.368
log
@print the correct info (need some tweaks yet to be shorter).
@
text
@d4 1
a4 1
# $OpenBSD$
d89 1
a89 1
		return $state->{deptree}->{$pkg}->short_print.':';
a100 12
package OpenBSD::Handle;

sub setup_header
{
	my ($handle, $set, $state, $info) = @@_;
	my $header = $state->deptree_header($set).$handle->pkgname;
	if (defined $info) {
		$header.=" ($info)";
	}
	$state->progress->set_header($header);
}

d107 1
a107 1
	my ($set, $state) = @@_;
d109 8
a116 4

	my $header = $state->deptree_header($set).$set->handle->pkgname;
	if ($set->older) {
		$header.=" (replacing ". join(', ', $set->older_names). ")";
d120 1
a120 1
		print $state->{not} ? "Pretending to add " : "Adding ";
d122 1
d347 1
a347 1
			$handle->setup_header($set, $state, "extracting");
d367 1
a367 1
			$o->setup_header($set, $state, "deleting");
d393 1
a393 1
		$handle->setup_header($set, $state, 
@


1.367
log
@simplify deptree handling, since we handle this at the set level.
@
text
@d89 1
a89 1
		return $state->{deptree}->{$pkg}.':';
@


1.366
log
@fix buglet: error out if pkg does not install in all cases.
noticed by Markus Lude.
@
text
@d74 1
a74 1
	my ($state, $pkg, @@deps) = @@_;
d76 2
a77 2
	if (defined $state->{deptree}->{$pkg}) {
		$pkg = $state->{deptree}->{$pkg};
d79 3
a81 6
	for my $i (@@deps) {
		for my $j ($i->newer) {
			my $nj = $j->pkgname;
			$state->{deptree}->{$nj} = $pkg unless 
			    defined $state->{deptree}->{$nj};
		}
d105 2
a106 3
	my ($handle, $state, $info) = @@_;
	my $pkgname = $handle->pkgname;
	my $header = $state->deptree_header($pkgname).$pkgname;
d122 1
a122 3
	my $pkgname = $set->handle->pkgname;

	my $header = $state->deptree_header($pkgname).$pkgname;
d354 1
a354 1
			$handle->setup_header($state, "extracting");
d374 1
a374 1
			$o->setup_header($state, "deleting");
d398 1
a398 1
		my $header = $state->deptree_header($pkgname).$pkgname;
d400 1
a400 1
		$handle->setup_header($state, 
d489 1
a489 3
			for my $handle ($set->newer) {
				$state->build_deptree($handle->pkgname, @@deps);
			}
@


1.365
log
@catch signals when we start doing stuff... so that cleaning up at the
end always occur, unless you insist on ^C.
@
text
@d472 1
a472 2
			if ($handle->has_error(OpenBSD::Handle::BAD_PACKAGE) &&
			    !$handle->{tweaked}) {
@


1.364
log
@minor bug-fix: partial_install is not print.
remove arguments that are no longer used.
@
text
@d784 6
@


1.363
log
@remove almost all references to set->handle, iterate over newer in most
cases (todo: rebuild dependency headers for the complex case...)
@
text
@d373 2
a374 2
				Fatal partial_install("Installation of ",
				    $handle->pkgname, " failed", $set, $state);
d389 1
a389 1
				    "Deinstallation of ".$oldname." failed", 
d452 1
a452 1
	my ($set, $state, @@todo) = @@_;
d791 1
a791 1
	unshift(@@todo2, install_set($set, $state, @@todo2));
@


1.362
log
@iterate over newer instead of 1 single handle
@
text
@d80 5
a84 3
		my $j = $i->handle->pkgname;
		$state->{deptree}->{$j} = $pkg unless 
		    defined $state->{deptree}->{$j};
a300 1
	$state->set_name_from_handle($set->handle);
d302 1
@


1.361
log
@basic routines to handle the merging of updatesets: mark updatesets as
already done, separate remove/mark_installed in tracker, create a merge
method that allows the merging of updatesets.
@
text
@d456 5
a460 4
	my $handle = $set->handle;
	if ($state->{tracker}->is_installed($handle->pkgname)) {
		$handle->cleanup(OpenBSD::Handle::ALREADY_INSTALLED);
		return ();
d464 3
a466 9
	if ($handle->has_error(OpenBSD::Handle::ALREADY_INSTALLED)) {
		return ();
	}
	if ($handle->has_error) {
		if ($handle->has_error(OpenBSD::Handle::BAD_PACKAGE) &&
		    !$handle->{tweaked}) {
			$state->set_name_from_handle($handle);
			$state->fatal("Fatal error");
		} else {
d469 9
a477 4
	}

	my $location = $handle->location;
	my $plist = $handle->plist;
d479 5
a483 4
	if ($plist->has('arch')) {
		unless ($plist->{arch}->check($state->{arch})) {
			print $handle->pkgname, " is not for the right architecture\n";
			return () unless $defines{arch};
d486 1
d494 3
a496 1
			$state->build_deptree($handle->pkgname, @@deps);
d505 5
a509 3
		print "Can't install ", $handle->pkgname,": can't resolve ",
		    join(',', @@baddeps), "\n";
		$location->close_now;
d516 3
a518 1
		$location->close_now;
d532 3
a534 1
	$handle->cleanup;
@


1.360
log
@cleanup method that does more or less what's needed
@
text
@d452 4
@


1.359
log
@syntactic sugar: methods to access plist and location from handle.
@
text
@d156 1
a156 4
			$n->location->close_with_client_error;
			$n->location->wipe_info;
			delete $n->{plist};
			$n->set_error(OpenBSD::Handle::CANT_INSTALL);
d454 1
a454 3
		if (defined $handle->location) {
			$handle->location->close_now;
		}
d520 1
a520 2
	$location->wipe_info;
	delete $handle->{plist};
@


1.358
log
@factor common code, that's a handle specific header
@
text
@d156 2
a157 2
			$n->{location}->close_with_client_error;
			$n->{location}->wipe_info;
d192 1
a192 1
		my $plist = $handle->{plist};
d239 1
a239 1
			if (!OpenBSD::Replace::can_old_package_be_replaced($old_handle->{plist}, 
d247 1
a247 1
			if ($old_handle->{plist}->has('manual-installation') && 
d280 1
a280 1
		push(@@l, OpenBSD::Add::record_partial_installation($h->{plist}, $state, $h->{partial}));
d296 1
a296 1
		$h->{plist}->set_infodir($h->{location}->info);
d304 1
a304 1
		my $plist = $handle->{plist};
d386 1
a386 1
			    OpenBSD::Delete::delete_plist($o->{plist}, $state);
d397 1
a397 1
			OpenBSD::PkgCfl::unregister($o->{plist}, $state);
d406 1
a406 1
		my $plist = $handle->{plist};
d432 1
a432 1
		my $plist = $handle->{plist};
d457 2
a458 2
		if (defined $handle->{location}) {
			$handle->{location}->close_now;
d477 2
a478 2
	my $location = $handle->{location};
	my $plist = $handle->{plist};
@


1.357
log
@fix installation header
@
text
@d102 13
d122 1
d130 1
d132 6
a137 6
	    print $state->{not} ? "Pretending to add " : "Adding ";
	    print $header;
	    if ($state->{do_faked}) {
		    print " under ", $state->{destdir};
	    }
	    print "\n";
d361 1
a361 3
			my $pkgname = $handle->pkgname;
			my $header = $state->deptree_header($pkgname).$pkgname;
			$state->progress->set_header("$header (extracting)");
d374 2
a375 2
				Fatal partial_install("Installation of $pkgname failed",
				    $set, $state);
d381 1
a382 1
			$state->progress->set_header($oldname." (deleting)");
d407 2
a408 5
		if ($replacing) {
			$state->progress->set_header("$header (installing)");
		} else {
			$state->progress->set_header($header);
		}
@


1.356
log
@remove parameter we no longer use
@
text
@d76 2
a77 4
	my $tree = $state->{deptree};
	# flatten info
	if (defined $tree->{$pkg}) {
		$pkg = $tree->{$pkg};
d81 2
a82 1
		$tree->{$j} = $pkg unless defined $tree->{$j};
d347 2
a348 1
			$state->progress->set_header("$pkgname (extracting)");
d392 1
d394 5
a398 1
		$state->progress->set_header("$pkgname (installing)");
@


1.355
log
@move the installed check in Tracker, where they belong
@
text
@d473 1
a473 1
		my @@deps = $set->{solver}->solve_depends($state, @@todo);
@


1.354
log
@pkg_add will need to track installation progress globally, so that we don't
solve dependencies with stuff that we want to update later...
create that information, to be used...
@
text
@a96 18
sub mark_installed
{
	my ($state, $pkg) = @@_;
	$state->{installed}->{$pkg} = 1;
}

sub is_installed
{
	my ($state, $pkg) = @@_;
	return $state->{installed}->{$pkg};
}

sub installed
{
	my $state = shift;
	return keys %{$state->{installed}};
}

d211 1
a211 1
			if ($state->is_installed($toreplace)) {
d441 1
a441 1
	if ($state->is_installed($handle->pkgname)) {
a512 1
	$state->mark_installed($handle->pkgname);
@


1.353
log
@let handle compute pkgnames correctly, simplifies code a bit
@
text
@d530 1
d781 3
@


1.352
log
@move OpenBSD::Handle into its own file. I guess I need to disentangle this
code before I go further....
@
text
@a76 1
	$pkg = OpenBSD::PackageName::url2pkgname($pkg);
d82 1
a82 1
		my $j = $i->handle->{pkgname};
d118 1
a118 1
	$state->set_pkgname($h->{pkgname});
d129 1
a129 1
	my $pkgname = $set->handle->{pkgname};
d176 1
a176 1
	my %todo = map {($_->{pkgname}, $_)} $set->older;
d197 1
a197 1
		my $pkgname = $handle->{pkgname};
d365 1
a365 1
			my $pkgname = $handle->{pkgname};
d386 1
a386 1
			my $oldname = $o->{pkgname};
d409 1
a409 1
		my $pkgname = $handle->{pkgname};
d434 1
a434 1
		my $pkgname = $handle->{pkgname};
d459 1
a459 1
	if ($state->is_installed($handle->{pkgname})) {
d485 1
a485 1
			print "$handle->{pkgname} is not for the right architecture\n";
d496 1
a496 1
			$state->build_deptree($handle->{pkgname}, @@deps);
d505 1
a505 1
		print "Can't install $handle->{pkgname}: can't resolve ",
d530 1
a530 1
	$state->mark_installed($handle->{pkgname});
@


1.351
log
@fix slice that doesn't work as I thought it would...
@
text
@d37 1
a67 87
package OpenBSD::Handle;
use OpenBSD::PackageInfo;

sub get_plist
{
	my ($handle, $state) = @@_;

	my $location = $handle->{location};
	my $pkg = $handle->{pkgname};

	if ($state->{verbose}) {
		print $state->deptree_header($pkg);
		print "parsing $pkg\n";
	}
	my $plist = $location->grabPlist;
	unless (defined $plist) {
		print "Can't find CONTENTS from ", $location->url, "\n";
		$location->close_with_client_error;
		$location->wipe_info;
		$handle->set_error(BAD_PACKAGE);
		return;
	}
	if ($plist->localbase ne $state->{localbase}) {
		print "Localbase mismatch: package has: ", $plist->localbase, " , user wants: ", $state->{localbase}, "\n";
		$location->close_with_client_error;
		$location->wipe_info;
		$handle->set_error(BAD_PACKAGE);
		return;
	}
	my $pkgname = $handle->{pkgname} = $plist->pkgname;

	if (is_installed($pkgname) && 
	    (!$state->{allow_replacing} ||	
	      !$state->{defines}->{installed} &&
	      !$plist->has_new_sig($state) && 
	      !$plist->uses_old_libs)) {
		$handle->{tweaked} = 
		    OpenBSD::Add::tweak_package_status($pkgname, $state);
		print "Not reinstalling $pkgname\n" if $state->{verbose} and
		    !$handle->{tweaked};
		$state->mark_installed($pkgname);
		$location->close_now;
		$location->wipe_info;
		$handle->set_error(ALREADY_INSTALLED);
		return;
	}
	if ($pkg ne '-') {
		if (!defined $pkgname or 
		    OpenBSD::PackageName::url2pkgname($pkg) ne $pkgname) {
			print "Package name is not consistent ???\n";
			$location->close_with_client_error;
			$location->wipe_info;
			$handle->set_error(BAD_PACKAGE);
			return;
		}
	}
	$handle->{plist} = $plist;
}

sub complete
{
	my ($handle, $state) = @@_;

	return if $handle->has_error;

	my $pkgname = $handle->{pkgname};

	if (!defined $handle->{location}) {
		my $location = OpenBSD::PackageLocator->find($pkgname, 
		    $state->{arch});
		if (!$location) {
			print $state->deptree_header($pkgname);
			$handle->set_error(NOT_FOUND);
			$handle->{tweaked} = 
			    OpenBSD::Add::tweak_package_status($pkgname, 
				$state);
			if (!$handle->{tweaked}) {
				print "Can't find $pkgname\n";
			}
			return;
		}
		$handle->{location} = $location;
	}
	if (!defined $handle->{plist}) {
		$handle->get_plist($state);
	}
}
@


1.350
log
@add a few comments, finish killing kitchensink.
@
text
@d831 1
a831 1
		print "Cannot find updates for ", join(', ', map {$_->short_print} @@cantupdate[1..50]);
@


1.349
log
@be a bit more specific, write the list of unsigned packages.
@
text
@d558 1
a558 2
		if ((!$state->{defines}->{kitchensink} ||
		    $handle->has_error(OpenBSD::Handle::BAD_PACKAGE)) &&
d756 3
d771 2
d791 1
d854 1
d863 3
d871 1
a871 1

d874 1
d880 2
d898 2
a899 3
if (defined $state->{defines}->{kitchensink}) {
	print "Added:\n", (map { "\t$_\n" } sort $state->installed), "\n";
}
@


1.348
log
@use choose_location
@
text
@d413 1
a413 1
			$state->{packages_without_sig}++;
d873 1
a873 1
		print " UNSIGNED PACKAGES: ", $state->{packages_without_sig};
@


1.347
log
@make signature checking more quiet: discard openssl's STDERR, keep a tally
of signed packages.
- display a message only if signed packages have been signed.
- show IN BIG CAPS unsigned package numbers if a mixture of signed/unsigned
has been seen.
@
text
@d629 1
a629 17
	if (@@$l == 0) {
		print "Can't resolve $name\n";
		return undef;
	} elsif (@@$l > 1) {
		my %h = map {($_->name, $_)} @@$l;
		if ($state->{interactive}) {
			$h{'<None>'} = undef;
			my $result = OpenBSD::Interactive::ask_list("Ambiguous: choose package for $name", $state->{interactive}, sort keys %h);
			return $h{$result};
		} else {
			print "Ambiguous: $name could be ", 
			    join(' ', keys %h), "\n";
			return undef;
		}
	} elsif (@@$l == 1) {
		return $l->[0];
	}
a756 1
my @@todo = ();
d782 3
a784 15
		if (@@$l == 0) {
			$state->progress->clear;
			print "Can't find $_\n";
		} elsif (@@$l > 1) {
			$state->progress->clear;
			if ($state->{interactive}) {
				my %cnd = map {($_->name, $_)} @@$l;
				my $result = OpenBSD::Interactive::choose1($_, 
				    1, sort keys %cnd);
				push @@todo, $cnd{$result} if defined $result;
			} else {
				print "Ambiguous: $_\n";
			}
		} else {
			push(@@todo, $l->[0]);
a785 1
	@@todo2 = map { OpenBSD::UpdateSet->from_location($_) } @@todo;
@


1.346
log
@oops, oops, oops. todo is not todo2
@
text
@d410 1
d413 1
d900 7
@


1.345
log
@deal with UpdateSets earlier: build an updateset, and ask Update to complete
it.

Tweak the control for updates to move to main program. Eventually, we will
run updates on the fly (there's still some merging code and debugging to go)
@
text
@d857 1
a857 1
		if (@@todo == 0) {
@


1.344
log
@factor out code as stem2location
@
text
@a676 13
sub reorder
{
	my $l = shift;
	my $n = @@$l;
	my ($a, $i, $j);
	for ($i = 0; $i < $n; $i++) {
		$j = int(rand($n-$i));
		$a = $l->[$i];
		$l->[$i] = $l->[$n-$j-1];
		$l->[$n-$j-1] = $a;
	}
}

d791 1
a791 1
		$l = OpenBSD::PackageLocator->match_locations(OpenBSD::Search::Exact->new($_));
a792 1
			my @@search =();
a794 1
			push(@@search, OpenBSD::Search::Stem->new($t));
d801 1
a807 1
				$state->progress->clear;
d817 1
d824 28
a851 2
	$updater->process(\@@ARGV, $state);
	my @@cantupdate = @@{$updater->cant};
d854 7
a860 1
			print "Cannot find updates for ", join(' ', @@cantupdate), "\n";
d875 1
a875 6
	@@todo = @@{$updater->updates};
	if (@@todo > 0 && !$bad) {
		print "Running the equivalent of pkg_add -r ",
		    join(' ', (map {$_->name} @@todo)), "\n";
	}
	@@todo2 = map { OpenBSD::UpdateSet->from_location($_) } @@todo;
a878 7
#	if (defined $state->{defines}->{kitchensink}) {
#		reorder(\@@todo);
#		if (!$opt_r) {
#			@@todo = grep {s/\.tgz$//o; !is_installed($_);} @@todo;
#		}
#		print "Adding in order:\n", (map { "\t$_\n" } @@todo), "\n";
#	}
@


1.343
log
@tweak previous;
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.342 2009/10/11 22:08:27 espie Exp $
d620 26
d654 4
a657 25
		    my ($h, $path, $repo);
		    if ($pkgname =~ m/\//o) {
			($repo, $path, $pkgname) = OpenBSD::PackageLocator::path_parse($pkgname);
			$h = $repo;
		    } else {
			$h = 'OpenBSD::PackageLocator';
			$path = "";
		    }
		    my $l = $h->match_locations(OpenBSD::Search::Stem->new($pkgname));
		    if (@@$l > 1 && !$state->{defines}->{allversions}) {
			$l = OpenBSD::Search::FilterLocation->keep_most_recent->filter_locations($l);
		    }
		    if (@@$l == 0) {
		    	print "Can't resolve $pkgname\n";
			$bad = 1;
		    } elsif (@@$l > 1) {
			my %h = map {($_->name, $_)} @@$l;
		    	if ($state->{interactive}) {
				$h{'<None>'} = undef;
				my $result = OpenBSD::Interactive::ask_list("Ambiguous: choose package for $pkgname", $state->{interactive}, sort keys %h);
				if (defined $h{$result}) {
					push(@@$new, OpenBSD::UpdateSet->from_location($h{$result}));
				} else {
					$bad = 1;
				}
d659 9
a667 7
				print "Ambiguous: $pkgname could be ", 
				    join(' ', keys %h), "\n";
				$bad = 1;
			}
		    } else {
				push(@@$new, OpenBSD::UpdateSet->from_location($l->[0]));
		    }
@


1.342
log
@new mode of operation: fuzzy addition. Allows adding packages even if
you don't know version numbers. Useful for quickly trying to duplicate
an installation on a new machine from the package list as obtained through
pkg_info.

Generally won't give a perfect result, but hey, if you have 300 packages
installed, will get you 95% of the way there.

prompted by problems reported by theo and msf.
@
text
@d4 1
a4 1
# $OpenBSD$
d684 1
a684 1
'[-L localbase] [-l list] [-P type] [-Q quick-destdir] pkg-name [...]');
@


1.341
log
@get really_add to deal with lists of newer packages in updateset
@
text
@d683 2
a684 2
set_usage('pkg_add [-acIinqruvx] [-A arch] [-B pkg-destdir] [-F keywords]',
'[-L localbase] [-P type] [-Q quick-destdir] pkg-name [...]');
d686 1
a686 1
our ($opt_a, $opt_v, $opt_n, $opt_I, $opt_L, $opt_B, $opt_A, $opt_P, $opt_Q, $opt_x, $opt_r, $opt_q, $opt_c, $opt_i, $opt_u);
d689 1
a689 1
	getopts('aqchivnruxIL:f:F:B:A:P:Q:',
d764 1
a764 1
if (@@ARGV == 0 && !$opt_u) {
d768 5
a776 1

d780 44
a823 1
if ($opt_u) {
@


1.340
log
@prepare for full UpdateSet (loop over newer)
@
text
@a391 3
	my $handle = $set->handle;
	my $plist = $handle->{plist};
	my $pkgname = $handle->{pkgname};
d393 19
a411 5
	$state->set_name_from_handle($handle);
	if ($plist->is_signed) {
		if ($state->{defines}->{nosig}) {
			print STDERR "NOT CHECKING DIGITAL SIGNATURE FOR ",
				$plist->pkgname, "\n";
a412 7
		} else {
			require OpenBSD::x509;

			if (!OpenBSD::x509::check_signature($plist, $state)) {
				Fatal "fatal issues in ", $set->print;
			}
			$state->{check_digest} = 1;
a413 2
	} else {
		$state->{check_digest} = 0;
d449 3
a451 1
		$state->progress->set_header("$pkgname (extracting)");
d453 13
a465 6
		try {
			OpenBSD::Replace::perform_extraction($handle, $state);
		} catchall {
			unless ($state->{interrupted}) {
				Warn $_;
				$errors++;
a466 5
		};
		$state->progress->clear;
		if ($state->{interrupted} || $errors) {
			Fatal partial_install("Installation of $pkgname failed",
			    $set, $state);
d491 1
d493 3
a497 1
	}
d499 17
a515 4
	try {
		OpenBSD::Add::perform_installation($handle, $state);
		if (!$state->{interrupted} && $plist->has(INSTALL)) {
			$plist->get(INSTALL)->run($state, 'POST-INSTALL');
d517 14
a530 4
	} catchall {
		unless ($state->{interrupted}) {
			Warn $_;
			$errors++;
a531 18
	};
	$state->progress->next;

	unlink($plist->infodir.CONTENTS);
	if ($state->{interrupted} || $errors) {
		Fatal partial_install("Installation of $pkgname failed",
		    $set, $state);
	}
	OpenBSD::SharedLibs::add_libs_from_plist($plist);
	OpenBSD::Add::tweak_plist_status($plist, $state);
	$plist->to_cache;
	OpenBSD::Add::register_installation($plist);
	$set->{solver}->register_dependencies($state);
	add_installed($pkgname);
	delete $handle->{partial};
	OpenBSD::PkgCfl::register($plist, $state);
	if ($plist->has(DISPLAY)) {
		$plist->get(DISPLAY)->prepare($state);
@


1.339
log
@use older_names
@
text
@d236 5
a240 2
	$set->handle->complete($state);
	return if $set->handle->has_error;
d246 6
a251 4
		$set->handle->{location}->close_with_client_error;
		$set->handle->{location}->wipe_info;
		delete $set->handle->{plist};
		$set->handle->set_error(OpenBSD::Handle::CANT_INSTALL);
d282 17
a298 13
	my $handle = $set->handle;
	my $plist = $handle->{plist};
	my $pkgname = $handle->{pkgname};
	my @@conflicts = OpenBSD::PkgCfl::find_all($plist, $state);
	return 1 if @@conflicts == 0;

	my %conflicts = map {($_,1)} @@conflicts;
	@@conflicts = keys %conflicts;

	if (!$state->{allow_replacing}) {
		if ($state->{defines}->{conflicts}) {
			print "Forcing install of $pkgname in the presence of conflicts (",join(',', @@conflicts), ")\n";
			return 1;
a299 18
		print "Can't install $pkgname because of conflicts (",join(',', @@conflicts), ")\n";
		$handle->set_error(OpenBSD::Handle::CANT_INSTALL);
		return;
	}

	if (@@conflicts >  5) {
		print "Can't install $pkgname because of conflicts (",join(',', @@conflicts), ")\n";
		$handle->set_error(OpenBSD::Handle::CANT_INSTALL);
		return;
	}

	require OpenBSD::Replace;

	if (!OpenBSD::Replace::is_new_package_safe($plist, $state)) {
		print "Can't safely update to $pkgname (use -F update to force it)\n";
		$handle->set_error(OpenBSD::Handle::CANT_INSTALL);
		return;
	}
d301 2
a302 3
	for my $toreplace (@@conflicts) {
		if ($state->is_installed($toreplace)) {
			Warn "Cannot replace $toreplace with $pkgname: just got installed\n";
d307 1
a307 7
		my $old_handle = OpenBSD::Handle->create_old($toreplace, $state);
		if ($old_handle->has_error(OpenBSD::Handle::NOT_FOUND)) {
			Fatal "Can't find $toreplace as an installed package\n";
		}
		if ($old_handle->has_error(OpenBSD::Handle::BAD_PACKAGE)) {
			Fatal "Couldn't find packing-list for $toreplace\n";
		}
d309 2
a310 3
		if (!OpenBSD::Replace::can_old_package_be_replaced($old_handle->{plist}, 
		    $pkgname, $state, \%conflicts)) {
			print "Can't update $toreplace into $pkgname\n";
a313 1
		$set->add_older($old_handle);
d315 27
a341 3
		if ($old_handle->{plist}->has('manual-installation') && 
		    !$plist->has('manual-installation')) {
		    	OpenBSD::PackingElement::ManualInstallation->add($plist);
d343 1
a344 1
	$set->{skipupdatedeps} = \%conflicts;
@


1.338
log
@overlay extract/delete/install messages, for shorter reports in normal mode
@
text
@d220 1
a220 1
		$header.=" (replacing ". join(', ', (map {$_->{pkgname}} $set->older)). ")";
@


1.337
log
@move a bit of code around, update (C)
@
text
@d451 1
a451 1
		$state->progress->next;
d476 1
@


1.336
log
@put back the ambiguous message in non-interactive mode
@
text
@d6 1
a6 1
# Copyright (c) 2003-2007 Marc Espie <espie@@openbsd.org>
d43 111
a841 111
package OpenBSD::PackingList;

sub uses_old_libs
{
	my $plist = shift;
	require OpenBSD::RequiredBy;

	return  grep {/^\.libs\d*\-/o} 
	    OpenBSD::Requiring->new($plist->pkgname)->list;
}

sub has_new_sig
{
	my ($plist, $state) = @@_;
	if (!defined $plist->{new_sig}) {
		my $n = OpenBSD::PackingList->from_installation($plist->pkgname)->signature;
		my $o = $plist->signature;
		print "Comparing full signature for ", $plist->pkgname, " \"$o\" vs. \"$n\": ", $n eq $o ? "equal\n" : "different\n" 
		    if $state->{very_verbose};
		$plist->{new_sig} = $n ne $o;
	}
	return $plist->{new_sig};
}

package OpenBSD::Handle;
use OpenBSD::PackageInfo;

sub get_plist
{
	my ($handle, $state) = @@_;

	my $location = $handle->{location};
	my $pkg = $handle->{pkgname};

	if ($state->{verbose}) {
		print $state->deptree_header($pkg);
		print "parsing $pkg\n";
	}
	my $plist = $location->grabPlist;
	unless (defined $plist) {
		print "Can't find CONTENTS from ", $location->url, "\n";
		$location->close_with_client_error;
		$location->wipe_info;
		$handle->set_error(BAD_PACKAGE);
		return;
	}
	if ($plist->localbase ne $state->{localbase}) {
		print "Localbase mismatch: package has: ", $plist->localbase, " , user wants: ", $state->{localbase}, "\n";
		$location->close_with_client_error;
		$location->wipe_info;
		$handle->set_error(BAD_PACKAGE);
		return;
	}
	my $pkgname = $handle->{pkgname} = $plist->pkgname;

	if (is_installed($pkgname) && 
	    (!$state->{allow_replacing} ||	
	      !$state->{defines}->{installed} &&
	      !$plist->has_new_sig($state) && 
	      !$plist->uses_old_libs)) {
		$handle->{tweaked} = 
		    OpenBSD::Add::tweak_package_status($pkgname, $state);
		print "Not reinstalling $pkgname\n" if $state->{verbose} and
		    !$handle->{tweaked};
		$state->mark_installed($pkgname);
		$location->close_now;
		$location->wipe_info;
		$handle->set_error(ALREADY_INSTALLED);
		return;
	}
	if ($pkg ne '-') {
		if (!defined $pkgname or 
		    OpenBSD::PackageName::url2pkgname($pkg) ne $pkgname) {
			print "Package name is not consistent ???\n";
			$location->close_with_client_error;
			$location->wipe_info;
			$handle->set_error(BAD_PACKAGE);
			return;
		}
	}
	$handle->{plist} = $plist;
}

sub complete
{
	my ($handle, $state) = @@_;

	return if $handle->has_error;

	my $pkgname = $handle->{pkgname};

	if (!defined $handle->{location}) {
		my $location = OpenBSD::PackageLocator->find($pkgname, 
		    $state->{arch});
		if (!$location) {
			print $state->deptree_header($pkgname);
			$handle->set_error(NOT_FOUND);
			$handle->{tweaked} = 
			    OpenBSD::Add::tweak_package_status($pkgname, 
				$state);
			if (!$handle->{tweaked}) {
				print "Can't find $pkgname\n";
			}
			return;
		}
		$handle->{location} = $location;
	}
	if (!defined $handle->{plist}) {
		$handle->get_plist($state);
	}
}
@


1.335
log
@restore tagged user packages to functionality (for now)
@
text
@d512 9
a520 5
		    	my %h = map {($_->name, $_)} @@$l;
			$h{'<None>'} = undef;
		    	my $result = OpenBSD::Interactive::ask_list("Ambiguous choose package for $pkgname", $state->{interactive}, sort keys %h);
			if (defined $h{$result}) {
				push(@@$new, OpenBSD::UpdateSet->from_location($h{$result}));
d522 2
@


1.334
log
@synch with my new style search/location changes
It's likely there will be some fallout, but it's getting a bit too large
to keep around.
This does kill a few very old oddities as well.
@
text
@d673 1
a673 1
#	OpenBSD::Add::tag_user_packages(@@todo);
a686 3
# convert everything to UpdateSets

	
@


1.333
log
@initial implementation of package signatures, based on x509 certificates and
smime detached signatures.
@
text
@a232 14
sub thunderbird_special_case
{
	my $plist = shift;
	for my $item (@@{$plist->{items}}) {
		next unless $item->IsFile;
		my $t = $item->{tempname};
		if (defined $t && $t =~ s/^(.*\/mozilla-thunderbird)\/extensions(.*)\/pkg\./$1\/pkg\./) {
			rename $item->{tempname}, $t;
			rmdir("$1/extensions$2");
			$item->{tempname} = $t;
		}
	}
}

a350 4
			require OpenBSD::Search;
			if (OpenBSD::Search::PkgSpec->new("mozilla-thunderbird-<=1.0.2p0")->filter($oldname)) {
			    	thunderbird_special_case($plist);
			}
d489 1
a489 1
sub find_truenames
d493 1
d504 3
a506 3
		    my @@l = $h->match(OpenBSD::Search::Stem->new($pkgname));
		    if (@@l > 1 && !$state->{defines}->{allversions}) {
			@@l = OpenBSD::PackageName::keep_most_recent(@@l);
d508 12
a519 6
		    my $result = OpenBSD::Interactive::choose1($pkgname, $state->{interactive}, sort @@l);
		    if (defined $result) {
			    if (defined $path) {
				$result = $path.$result;
			    }
			    push(@@$new, $result);
d521 1
a521 1
			    $bad = 1;
d524 4
a527 1
		    push(@@$new, $pkgname);
d636 1
d668 1
a668 1
		    join(' ', @@todo), "\n";
d670 1
d672 9
a680 9
	find_truenames(\@@ARGV, \@@todo, $state);
	OpenBSD::Add::tag_user_packages(@@todo);
	if (defined $state->{defines}->{kitchensink}) {
		reorder(\@@todo);
		if (!$opt_r) {
			@@todo = grep {s/\.tgz$//o; !is_installed($_);} @@todo;
		}
		print "Adding in order:\n", (map { "\t$_\n" } @@todo), "\n";
	}
a688 8
my @@todo2 = ();
my $cache = {};
for my $pkg (@@todo) {
	if (!defined $cache->{$pkg}) {
		$cache->{$pkg} = OpenBSD::UpdateSet->create_new($pkg);
	}
	push(@@todo2, $cache->{$pkg});
}
d766 1
a766 1
	my $plist = $location->plist;
@


1.332
log
@rework collisionreport to allow some limited repair capabilities:
assuming none of the files is registered, we can assume that the
package registration fails, and then we remove the files, and install
the package.

Then we also walk installed packages to restore dependencies that would
have been erased (this is fairly simple-minded and may fail in weird
cases).
@
text
@d294 16
@


1.331
log
@rename forced to defines
@
text
@d404 3
d476 7
@


1.330
log
@let GetOpt count how many times it sees an option, removes special case
for -v, and allow other fun possibilities.
@
text
@d40 1
a40 1
our %forced = ();
d176 1
a176 1
		if ($state->{forced}->{conflicts}) {
d423 1
a423 1
		if ((!$state->{forced}->{kitchensink} ||
d439 1
a439 1
			return () unless $forced{arch};
d468 1
a468 1
		if (!$forced{libdepends}) {
d496 1
a496 1
		    if (@@l > 1 && !$state->{forced}->{allversions}) {
d538 1
a538 1
				$forced{$o} = 1;
d543 1
a543 1
				$forced{$o} = 1;
d559 1
a559 1
$state->{forced} = \%forced;
d612 1
a612 1
lock_db($state->{not}) unless $state->{forced}->{nolock};
d632 1
a632 1
		if ($state->{forced}->{alwaysupdate} ||
d654 1
a654 1
	if (defined $state->{forced}->{kitchensink}) {
d700 1
a700 1
if (defined $state->{forced}->{kitchensink}) {
d773 1
a773 1
	      !$state->{forced}->{installed} &&
@


1.329
log
@make it possible to run without locking the database. To be used by
SRC: url, which require it.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.328 2007/06/30 11:38:38 espie Exp $
d534 1
a534 1
	{'v' => sub {++$opt_v;},
@


1.328
log
@move the UpdateSet stuff into its separate file, leaving Vstat much cleaner.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.327 2007/06/26 17:58:23 espie Exp $
d612 1
a612 1
lock_db($state->{not});
@


1.327
log
@missed one mark_as_installed.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.326 2007/06/26 14:40:25 espie Exp $
d36 1
a36 1
# use OpenBSD::UpdateSet;
@


1.326
log
@the big gap one: create UpdateSet for all packages being installed, and
consider only UpdateSet internally. This involves moving stuff around a
bit to keep pkg_add -n working, adding creators from_location for UpdateSet,
and tweaking dependencies heavily.

More changes later, like sanitizing PackageLocation state engine, or
creating UpdateSet earlier for actual updates.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.325 2007/06/17 10:44:01 espie Exp $
d780 1
a780 1
		$state->mark_as_installed($pkgname);
@


1.325
log
@more scaffolding we don't really use yet.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.324 2007/06/16 11:50:48 espie Exp $
d58 2
a59 1
		$tree->{$i} = $pkg unless defined $tree->{$i};
a78 6
sub mark_as_already_installed
{
	my ($state, $pkg) = @@_;
	$state->mark_installed($pkg);
}

a232 10
sub prepare_to_add
{
	my ($pkg, $state) = @@_;

	my $set = OpenBSD::UpdateSet->create_new($pkg);
	$set->complete($state);
	return $set;
}


d406 1
a406 1
sub install_package
d408 1
a408 2
	my ($pkg, $state, @@todo) = @@_;
	my $cache = $state->{cache};
d410 6
a415 2
	if (!defined $cache->{$pkg}) {
		$cache->{$pkg} = prepare_to_add($pkg, $state);
d418 1
a418 2
	my $set = $cache->{$pkg};
	my $handle = $set->handle;
a433 5
	if ($state->is_installed($handle->{pkgname})) {
		$location->close_now;
		return ();
	}

d438 1
a438 1
			print "$pkg is not for the right architecture\n";
d449 2
a450 2
			$state->build_deptree($pkg, @@deps);
			return (@@deps, $pkg);
d458 1
a458 1
		print "Can't install $pkg: can't resolve ",
d667 11
d679 2
a680 2
while (my $pkg = shift @@todo) {
	unshift(@@todo, install_package($pkg, $state, @@todo));
d756 1
a756 1
		print "Can't find CONTENTS from $pkg\n";
d780 1
a780 1
		$state->mark_as_already_installed($pkgname);
@


1.324
log
@Add variation on exec/unexec:
@@exec-always         @@unexec-always
@@exec-add            @@unexec-delete
@@exec-update         @@unexec-update

with the obvious semantics that *update are only run during updates,
and *add/delete are only run during `pure' additions/removals.

This should solve the problem of those packages that `lose' manual
configuration when you update them (e.g., all the mod_xxx apache stuff
and postfix).

caveat: you will need to go through one finaly broken update before the
new stuff kicks in.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.323 2007/06/16 09:29:37 espie Exp $
d142 24
@


1.323
log
@use OpenBSD::Paths contents
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.322 2007/06/11 09:23:20 espie Exp $
a809 1

@


1.322
log
@prepare more stuff to be able to deal with UpdateSets directly
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.321 2007/06/11 09:12:27 espie Exp $
d35 1
d545 1
a545 1
$opt_L = '/usr/local' unless defined $opt_L;
@


1.321
log
@keep on extracting stuff
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.320 2007/06/10 16:05:49 espie Exp $
d103 1
d125 18
a142 1
package main;
d211 2
d218 1
a218 10
	$set->handle->complete($state);
	if ($set->handle->has_error) {
		return $set;
	}
	if (!can_install($set, $state)) {
		$set->handle->{location}->close_with_client_error;
		$set->handle->{location}->wipe_info;
		delete $set->handle->{plist};
		$set->handle->set_error(OpenBSD::Handle::CANT_INSTALL);
	}
@


1.320
log
@extract constructor to create old handles.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.319 2007/06/10 15:24:36 espie Exp $
a192 9
sub create_handle
{
	my $pkg = shift;
	my $handle = OpenBSD::Handle->new;
	$handle->{pkgname} = $pkg;
	$handle->{tweaked} = 0;
	return $handle;
}

d197 3
a199 5
	my $set = OpenBSD::UpdateSet->new;
	my $handle = create_handle($pkg);
	$set->add_newer($handle);
	$handle->complete($state);
	if ($handle->has_error) {
d203 4
a206 4
		$handle->{location}->close_with_client_error;
		$handle->{location}->wipe_info;
		delete $handle->{plist};
		$handle->set_error(OpenBSD::Handle::CANT_INSTALL);
@


1.319
log
@set_infodir when we can in PackageLocation.
Create a full handle for replaced packages as well.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.318 2007/06/10 15:11:05 espie Exp $
d168 2
a169 4
		my $old_handle = OpenBSD::Handle->new;
		$old_handle->{pkgname} = $toreplace;
		$old_handle->{location} = OpenBSD::PackageRepository::Installed->new->find($toreplace, $state->{arch});
		if (!$old_handle->{location}) {
d172 1
a172 2
		my $rplist = $old_handle->{location}->plist;
		if (!defined $rplist) {
a174 1
		$old_handle->{plist} = $rplist;
d176 1
a176 1
		if (!OpenBSD::Replace::can_old_package_be_replaced($rplist, 
d182 1
d184 1
a184 2
		$set->add_older($old_handle);
		if ($rplist->has('manual-installation') && 
a807 1
		
d809 1
@


1.318
log
@make the replacement check methods slightly clearer, avoid doing two
things at once, mostly.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.317 2007/06/10 14:52:29 espie Exp $
d168 7
a174 1
		my $rplist = OpenBSD::PackingList->from_installation($toreplace);
d178 2
d186 1
a186 3
		my $old_handle = OpenBSD::Handle->new;
		$old_handle->{plist} = $rplist;
		$old_handle->{pkgname} = $toreplace;
@


1.317
log
@split create_handle code, so that we create the object as a trivial
place-holder, then complete it later. This should allow us to create
`empty shell' UpdateSets eventually, in replacement of pkgnames lists.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.316 2007/06/09 13:39:31 espie Exp $
d155 1
a155 1
	if (!OpenBSD::Replace::is_safe($plist, $state)) {
d168 6
a173 3
		my $rplist = OpenBSD::Replace::can_do($toreplace, $pkgname, 
		    $state, \%conflicts);
		if (!$rplist) {
d193 1
a193 1
	my ($pkg, $state) = @@_;
a196 1
	$handle->complete($state);
d205 1
a205 1
	my $handle = create_handle($pkg, $state);
d207 1
@


1.316
log
@tag user installed packages.
- record what's on the command line.
- adjust option depending on -a / !-a
- report `manual-install' status when replacing stuff.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.315 2007/06/09 11:16:54 espie Exp $
d194 1
a194 62
	my $location = OpenBSD::PackageLocator->find($pkg, $state->{arch});
	if (!$location) {
		print $state->deptree_header($pkg);
		$handle->set_error(OpenBSD::Handle::NOT_FOUND);
		$handle->{tweaked} = 
		    OpenBSD::Add::tweak_package_status($pkg, $state);
		if (!$handle->{tweaked}) {
			print "Can't find $pkg\n";
		}
		return $handle;
	}
	$handle->{location} = $location;
	if ($state->{verbose}) {
		print $state->deptree_header($pkg);
		print "parsing $pkg\n";
	}
    	my $plist = $location->plist;
	unless (defined $plist) {
		print "Can't find CONTENTS from $pkg\n";
		$handle->set_error(OpenBSD::Handle::BAD_PACKAGE);
		$location->close_with_client_error;
		$location->wipe_info;
		return $handle;
	}
	$handle->{plist} = $plist;
	if ($plist->localbase ne $state->{localbase}) {
		print "Localbase mismatch: package has: ", $plist->localbase, " , user wants: ", $state->{localbase}, "\n";
		$location->close_with_client_error;
		$location->wipe_info;
		delete $handle->{plist};
		$handle->set_error(OpenBSD::Handle::BAD_PACKAGE);
		return $handle;
	}
	my $pkgname = $handle->{pkgname} = $plist->pkgname;

	if (is_installed($pkgname) && 
	    (!$state->{allow_replacing} ||	
	      !$state->{forced}->{installed} &&
	      !$plist->has_new_sig($state) && 
	      !$plist->uses_old_libs)) {
		$handle->{tweaked} = 
		    OpenBSD::Add::tweak_package_status($pkgname, $state);
		print "Not reinstalling $pkgname\n" if $state->{verbose} and
		    !$handle->{tweaked};
		$state->mark_as_already_installed($pkgname);
		$location->close_now;
		$location->wipe_info;
		delete $handle->{plist};
		$handle->set_error(OpenBSD::Handle::ALREADY_INSTALLED);
		return $handle;
	}
	if ($pkg ne '-') {
		if (!defined $pkgname or 
		    OpenBSD::PackageName::url2pkgname($pkg) ne $pkgname) {
			print "Package name is not consistent ???\n";
			$location->close_with_client_error;
			$location->wipe_info;
			delete $handle->{plist};
			$handle->set_error(OpenBSD::Handle::BAD_PACKAGE);
			return $handle;
		}
	}
d715 89
@


1.315
log
@rework `special' package names a bit.
- do a test to create partial-foo-1.0.1 instead of partial-partial-foo-1.0
when removing partial-foo fails.
- have .libs name generation, e.g., .libs-foo, then .libs1-foo, then .libs2-foo
instead of .libs-.libs-foo.... extend the pkgspec pattern slightly, so
that all these are more or less equivalent for dependencies and conflicts.

With this, we can do practically any scenario of shared libs updates and
downgrades.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.314 2007/06/09 10:30:53 espie Exp $
d179 4
d193 1
a196 1
		print "Can't find $pkg\n";
d198 5
d234 4
a237 1
		print "Not reinstalling $pkgname\n" if $state->{verbose};
d439 1
d467 3
a469 2
		if (!$state->{forced}->{kitchensink} ||
		    $handle->has_error(OpenBSD::Handle::BAD_PACKAGE)) {
d649 1
d702 1
@


1.314
log
@new code is much sturdier with respect to old libraries, we do not have
to consider .libs-* as `special case', saving old libraries should do
the right thing in all cases, more or less...
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.313 2007/06/07 20:30:03 espie Exp $
d745 1
a745 1
	return  grep {/^\.libs\-/o} 
@


1.313
log
@give handle a temporary name, this prevents `undefined' messages.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.312 2007/06/07 12:57:33 espie Exp $
d135 1
a135 10

	my @@libs = ();
	@@conflicts = ();
	for my $k (keys %conflicts) {
		if ($k =~ m/^\.libs\-/o) {
			push(@@libs, $k);
		} else {
			push(@@conflicts, $k);
		}
	}
d139 1
a139 1
			print "Forcing install of $pkgname in the presence of conflicts (",join(',', @@conflicts, @@libs), ")\n";
d142 1
a142 1
		print "Can't install $pkgname because of conflicts (",join(',', @@conflicts, @@libs), ")\n";
d148 1
a148 1
		print "Can't install $pkgname because of conflicts (",join(',', @@conflicts, @@libs), ")\n";
a156 6
		$handle->set_error(OpenBSD::Handle::CANT_INSTALL);
		return;
	}

	if (!OpenBSD::Replace::figure_out_libs($plist, $state, @@libs)) {
		print "Can't update to $pkgname because of collision with old libs\n";
@


1.312
log
@make compute_size explicit. That way, we can do it once, at the right
moment.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.311 2007/06/05 23:19:00 espie Exp $
d203 1
@


1.311
log
@allow accessing all older values (make a semantic distinction), so that
adjust_dependencies gets access to all. This fixes some bogus replacements.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.310 2007/06/04 14:57:33 espie Exp $
d370 4
d375 1
a376 2

		OpenBSD::Replace::save_old_libraries($set, $state);
@


1.310
log
@I am on drugs, I don't know where I found split can take strings as
arguments. Repair...
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.309 2007/06/04 14:40:39 espie Exp $
d349 1
a349 1
	if ($set->older) {
d390 1
a390 1
		for my $o ($set->older) {
@


1.309
log
@some minor systematic changes.
- mark all regexps I can with /o if they can be compiled once.
- turn $o->method() into $o->method
- remove unneeded prototypes
- reduce split /re/ into split "string" where possible.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.308 2007/06/02 12:37:37 espie Exp $
d583 1
a583 1
	 		for my $o (split ',', shift) { 
d588 1
a588 1
	 		for my $o (split ',', shift) { 
@


1.308
log
@move the check that dependencies are satisfied inside the solver object
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.307 2007/06/02 12:21:14 espie Exp $
d139 1
a139 1
		if ($k =~ m/^\.libs\-/) {
d534 1
a534 1
		    if ($pkgname =~ m/\//) {
d583 1
a583 1
	 		for my $o (split/,/, shift) { 
d588 1
a588 1
	 		for my $o (split/,/, shift) { 
d701 1
a701 1
			@@todo = grep {s/\.tgz$//; !is_installed($_);} @@todo;
d727 1
a727 1
$state->delayed_output();
d739 1
a739 1
	if ($_ =~ m/^Caught SIG(\w+)/) {
d756 1
a756 1
	return  grep {/^\.libs\-/} 
@


1.307
log
@slight refactor, move wantlib dependencies handling inside the solver.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.306 2007/06/02 11:24:22 espie Exp $
d500 2
a501 1
	# verify dependencies and register them
d503 3
a505 3
	for my $dep ($set->{solver}->dependencies) {
		next if is_installed($dep);
		print "Can't install $pkg: can't resolve $dep\n";
@


1.306
log
@move most of the code that deals with dependencies in the solver object
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.305 2007/06/02 11:18:46 espie Exp $
d489 2
a490 3
		my $solver = OpenBSD::Dependencies::Solver->new($set);
		my @@deps = $solver->solve($state, @@todo);
		$set->{solver} = $solver;
d492 1
a492 1
			$solver->dump;
a509 8
	my $okay = 1;
	for my $lib (@@{$plist->{wantlib}}) {
		if (!$set->{solver}->lookup_library($state, $lib->{name})) {
		    	Warn "Can't install $pkg: lib not found ", $lib->{name}, "\n";
			$set->{solver}->dump if $okay;
			$okay = 0;
		}
	}
d511 1
a511 1
	if (!$okay) {
@


1.305
log
@move the solver object up to the set level.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.304 2007/06/02 10:29:44 espie Exp $
a326 36
sub record_old_dependencies
{
	my ($set, $state) = @@_;
	for my $o ($set->older) {
		require OpenBSD::RequiredBy;
		my @@wantlist = OpenBSD::RequiredBy->new($o->{pkgname})->list;
		$o->{wantlist} = \@@wantlist;
	}
}

sub adjust_old_dependencies
{
	my ($set, $state) = @@_;
	my $pkgname = $set->handle->{pkgname};
	for my $o ($set->older) {
		require OpenBSD::Replace;
		require OpenBSD::RequiredBy;

		my $oldname = $o->{pkgname};

		print "Adjusting dependencies for $pkgname/$oldname\n" 
		    if $state->{beverbose};
		my $d = OpenBSD::RequiredBy->new($pkgname);
		for my $dep (@@{$o->{wantlist}}) {
			if (defined $set->{skipupdatedeps}->{$dep}) {
				print "\tskipping $dep\n" if $state->{beverbose};
				next;
			}
			print "\t$dep\n" if $state->{beverbose};
			$d->add($dep);
			OpenBSD::Replace::adjust_dependency($dep, $oldname, $pkgname);
		}
	}
}


d389 1
a389 1
		record_old_dependencies($set, $state);
d440 1
a440 1
	$set->{solver}->register_dependencies;
d447 1
a447 1
	adjust_old_dependencies($set, $state);
@


1.304
log
@move the dependency handling into separate functions.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.303 2007/06/01 22:35:46 espie Exp $
d476 1
a476 1
	$handle->{solver}->register_dependencies;
d524 2
a525 2
	if (!defined $handle->{solver}) {
		my $solver = OpenBSD::Dependencies::Solver->new($handle->{plist});
d527 1
a527 1
		$handle->{solver} = $solver;
d539 1
a539 1
	for my $dep ($handle->{solver}->dependencies) {
d549 1
a549 1
		if (!$handle->{solver}->lookup_library($state, $lib->{name})) {
d551 1
a551 1
			$handle->{solver}->dump if $okay;
d555 1
a555 1
#	print "Didn't need to process: ", join(',', @@{$handle->{solver}->{todo}}), "\n";
@


1.303
log
@very small clean-up of dependencies list handling.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.302 2007/06/01 21:50:46 espie Exp $
d327 36
d425 1
a434 3
			require OpenBSD::RequiredBy;
			my @@wantlist = OpenBSD::RequiredBy->new($oldname)->list;
			$o->{wantlist} = \@@wantlist;
d483 1
a483 18
	# and add dependencies corresponding to the replacement
	for my $o ($set->older) {
		require OpenBSD::Replace;
		my $oldname = $o->{pkgname};

		print "Adjusting dependencies for $pkgname/$oldname\n" 
		    if $state->{beverbose};
		my $d = OpenBSD::RequiredBy->new($pkgname);
		for my $dep (@@{$o->{wantlist}}) {
			if (defined $set->{skipupdatedeps}->{$dep}) {
				print "\tskipping $dep\n" if $state->{beverbose};
				next;
			}
			print "\t$dep\n" if $state->{beverbose};
			$d->add($dep);
			OpenBSD::Replace::adjust_dependency($dep, $oldname, $pkgname);
		}
	}
@


1.302
log
@don't store stuff in the plist, use the handle which is there for that.
so loop directly over $set->older for replacements.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.301 2007/06/01 21:37:56 espie Exp $
d783 2
a784 2
	my $d = OpenBSD::Requiring->new($plist->pkgname);
	return  grep {/^\.libs\-/} $d->list;
@


1.301
log
@compute real list.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.300 2007/06/01 14:58:29 espie Exp $
d95 6
a103 6
sub actual_replacements
{
	my $set = shift;
	return map {$_->{plist}} $set->older;
}
	
d111 2
a112 3
	my @@toreplace = $set->older;
	if (@@toreplace) {
		$header.=" (replacing ". join(', ', (map {$_->{pkgname}} @@toreplace)). ")";
d341 1
a341 1
	$state->set_pkgname($pkgname);
a347 1
	my @@toreplace = $set->actual_replacements;
d349 1
a349 1
	if (@@toreplace) {
d389 4
a392 3
		for my $op (@@toreplace) {
			$state->progress->set_header($op->pkgname." (deleting)");
			$state->set_pkgname($op->pkgname);
d394 1
a394 1
			if (OpenBSD::Search::PkgSpec->new("mozilla-thunderbird-<=1.0.2p0")->filter($op->pkgname)) {
d399 2
a400 2
			my @@wantlist = OpenBSD::RequiredBy->new($op->pkgname)->list;
			$op->{wantlist} = \@@wantlist;
d402 1
a402 1
			    OpenBSD::Delete::delete_plist($op, $state);
d406 1
a406 1
				    "Deinstallation of ".$op->pkgname." failed", 
d411 1
a411 1
				delete $state->{updatedepends}->{$op->pkgname};
d413 1
a413 1
			OpenBSD::PkgCfl::unregister($op, $state);
d418 1
a418 1
		$state->set_pkgname($pkgname);
d450 1
a450 1
	for my $op (@@toreplace) {
d452 1
a452 1
		my $opkgname = $op->pkgname;
d454 1
a454 1
		print "Adjusting dependencies for $pkgname/$opkgname\n" 
d457 1
a457 1
		for my $dep (@@{$op->{wantlist}}) {
d464 1
a464 1
			OpenBSD::Replace::adjust_dependency($dep, $opkgname, $pkgname);
d486 1
a486 1
			$state->set_pkgname($pkg);
@


1.300
log
@refactor ProgressMeter code to create objects, put these into state.
Create a common state class for delete and add, put the progressmeter
creation in there.

neat effect: we don't have a progressmeter, we use a stub class instead
and *never* pull the code in at all.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.299 2007/05/31 16:50:43 espie Exp $
d400 1
a400 1
			my @@wantlist = OpenBSD::RequiredBy->new($op)->list;
@


1.299
log
@we cannot install a package without a solver, remove redundant test.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.298 2007/05/31 16:48:18 espie Exp $
a31 1
use OpenBSD::ProgressMeter;
d43 1
a43 1
our @@ISA=(qw(OpenBSD::Error));
d115 1
a115 1
	if (!OpenBSD::ProgressMeter::set_header($header)) {
d373 1
a373 1
		OpenBSD::ProgressMeter::set_header("$pkgname (extracting)");
d385 1
a385 1
		OpenBSD::ProgressMeter::next();
d392 1
a392 1
			OpenBSD::ProgressMeter::set_header($op->pkgname." (deleting)");
d418 1
a418 1
		OpenBSD::ProgressMeter::set_header("$pkgname (installing)");
d433 1
a433 1
	OpenBSD::ProgressMeter::next();
a683 3
if (!$opt_x && !$state->{beverbose}) {
	OpenBSD::ProgressMeter::enable();
}
d685 3
a687 7
if ($< && !$forced{nonroot}) {
	if ($state->{not}) {
		Warn "$0 should be run as root\n";
	} else {
		Fatal "must be run as root";
	}
}
a688 1
lock_db($state->{not});
@


1.298
log
@simplify the handling of shared libs: there's no need to register each
package independently.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.297 2007/05/31 13:33:17 espie Exp $
d444 2
a446 4
	if (defined $handle->{solver}) {
		$handle->{solver}->register_dependencies;
	}
	add_installed($pkgname);
@


1.297
log
@move set validation earlier (in fact, it probably doesn't belong in
really_add).

move common delete_installed() code inside Delete.pm
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.296 2007/05/31 10:04:03 espie Exp $
a80 1
	OpenBSD::SharedLibs::add_libs_from_installed_package($pkg);
a533 4
	# grab libraries
	for my $dep ($handle->{solver}->dependencies) {
		OpenBSD::SharedLibs::add_libs_from_installed_package($dep);
	}
@


1.296
log
@fix the saving of partial installs in case destdir is used.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.295 2007/05/30 16:32:14 espie Exp $
d337 3
a360 3
	$set->validate_plists($state);


a412 1
			delete_installed($op->pkgname);
@


1.295
log
@simplify script handling a bit (they're going to disappear probably anyways).

Remove two passes visitors, we don't use them.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.294 2007/05/30 14:10:08 espie Exp $
d313 1
a313 1
	my ($set, $not) = @@_;
d315 1
a315 1
	return () if $not;
d319 1
a319 1
		push(@@l, OpenBSD::Add::record_partial_installation($h->{plist}, $h->{partial}));
d327 1
a327 1
	return failed_message($base_msg, $state->{interrupted}, save_partial_set($set, $state->{not}));
@


1.294
log
@fold even more stuff under the same control loop.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.293 2007/05/30 14:04:51 espie Exp $
a283 7
sub do_script
{
	my ($plist, $name, $state, $args) = @@_;
	return unless $plist->has($name);
	$plist->get($name)->run($state, $args);
}

d426 4
a429 7
		do_script($plist, REQUIRE, $state, "INSTALL");
		do_script($plist, INSTALL, $state, "PRE-INSTALL")
		    unless $state->{interrupted};
		OpenBSD::Add::perform_installation($handle, $state) 
		    unless $state->{interrupted};
		do_script($plist, INSTALL, $state, "POST-INSTALL") 
		    unless $state->{interrupted};
@


1.293
log
@simplify really_add to use real visitors for extraction and installation.
Just do one single try {} catchall {} per-method, as this is enough.

New methods: extract_and_progress, install_and_progress, that catch
interrupts (die) deal with fake, and handle the progress meter.
One single method: mark_progress, can be used for extraction, installation
and deletion.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.292 2007/05/30 12:52:06 espie Exp $
d434 6
a439 2
		do_script($plist, INSTALL, $state, "PRE-INSTALL");
		OpenBSD::Add::perform_installation($handle, $state);
a446 9

	if (!($state->{interrupted} || $errors)) {
		try { 
			do_script($plist, INSTALL, $state, "POST-INSTALL") 
		} catchall {
			Warn $_;
			$errors++;
		};
	}
@


1.292
log
@simplify the way partial installations get recorded: store elements
already installed in a hash, and do a shallow copy of the list when
necessary, using make_copy.

This removes a lot of action-at-a-distance in packing-list elements.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.291 2007/05/30 11:40:07 espie Exp $
d386 4
a389 9
		my $donesize = 0;
		$handle->{partial} = {};
		$state->{partial} = $handle->{partial};
		my $totsize = $handle->{totsize};
		$state->{archive} = $handle->{location};
		for my $item (@@{$plist->{items}}) {
			try { 
				$item->extract($state); 
			} catchall {
a391 4
			};
			if (defined $item->{size}) {
				$donesize += $item->{size};
				OpenBSD::ProgressMeter::show($donesize, $totsize);
d393 1
a393 2
			last if $state->{interrupted} || $errors;
		}
d432 1
a432 15
	if ($replacing) {
		try {
			do_script($plist, REQUIRE, $state, "INSTALL");
			do_script($plist, INSTALL, $state, "PRE-INSTALL");
		} catchall {
			Warn $_;
			$errors++;
		};

		if ($state->{interrupted} || $errors) {
			# here we should remove links from the temp package
			Fatal partial_install("Installation of $pkgname failed",
			    $set, $state);
		}
	} else {
d435 3
a437 14
	}

	my $totsize = $handle->{totsize};
	$state->{archive} = $handle->{location};
	my $donesize = 0;
	$state->{end_faked} = 0;
	if (!defined $handle->{partial}) {
		$handle->{partial} = {};
	}
	$state->{partial} = $handle->{partial};
	for my $item (@@{$plist->{groups}}, @@{$plist->{users}}, @@{$plist->{items}}) {
		try { 
			$item->install($state); }
		catchall {
a439 11
		};
		last if $errors;
		if (defined $item->{size}) {
                        $donesize += $item->{size};
                        OpenBSD::ProgressMeter::show($donesize, $totsize);
                }

		last if $state->{interrupted};
		# stop faked installation there...
		if ($state->{do_faked} && $state->{end_faked}) {
			last;
a440 7
	}

	try { 
		$handle->{location}->finish_and_close; }
	catchall {
		Warn $_;
		$errors++;
@


1.291
log
@slightly better control over partial installations (still preparing for
bigger sets)
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.290 2007/05/29 14:52:48 espie Exp $
d325 2
a326 2
		next unless defined $h->{plist}->{done};
		push(@@l, OpenBSD::Add::record_partial_installation($h->{plist}));
d387 2
a388 1
		$plist->{done} = [];
a397 1
			push(@@{$plist->{done}}, $item);
d465 4
a476 3
		if (!$replacing) {
			push(@@{$plist->{done}}, $item);
		}
d514 1
@


1.290
log
@move code a bit, in preparation for multiple handles in an UpdateSet.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.289 2007/05/29 14:39:03 espie Exp $
d305 1
a305 1
sub failed_install
d307 2
a308 4
	my ($handle, $not, $interrupted) = @@_;
	my $plist = $handle->{plist};
	my $pkgname = $handle->{pkgname};
	my $msg = "Installation of $pkgname failed";
d310 17
a326 1
		$msg ="Caught SIG$interrupted. $msg";
d328 7
a334 1
	OpenBSD::Add::borked_installation($plist, $not, $msg);
d406 2
a407 1
			failed_install($handle, $state->{not}, $state->{interrupted});
d425 3
a427 4
				OpenBSD::Add::borked_installation($plist,
				    $state->{not},
				    "Deinstallation of ", 
				    $op->pkgname, " failed");
d453 2
a454 1
			failed_install($handle, $state->{not}, $state->{interrupted});
d507 2
a508 1
		failed_install($handle, $state->{not}, $state->{interrupted});
@


1.289
log
@rely on packing-lists knowing where they live, much saner.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.288 2007/05/29 13:52:07 espie Exp $
d320 4
a324 2
	my $location = $handle->{location};
	my $destdir = $state->{destdir};
a325 1
	$plist->set_infodir($location->info);
a327 1
	$state->{archive} = $location;
a346 5
	my $totsize = $plist->{totsize};

	if (!defined $location) {
		Fatal "Archive in $pkgname broken";
	}
d348 1
a348 1
	$ENV{'PKG_PREFIX'} = $plist->localbase;
d368 2
d440 2
d468 1
a468 1
		$location->finish_and_close; }
@


1.288
log
@don't bypass add_object to create special files, otherwise infodir won't
get defined.

Simplify and clean-up register_installation: everything is in the packing-list
so don't pass other arguments. Do not copy arbitrary info_names objects, but
use a copy_info visitor which copies exactly what files are around.

Use the stored infodir to locate DISPLAY and INSTALL files.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.287 2007/05/29 13:15:23 espie Exp $
a195 1
		$rplist->{dir} = installed_info($toreplace);
d314 1
a314 2
	OpenBSD::Add::borked_installation($plist, 
	    $handle->{location}->info, $not, $msg);
a323 1
	my $dir = $location->info;
a327 2
	$plist->{dir} = $dir;
	$state->{dir} = $plist->{dir};
d407 1
a407 1
				OpenBSD::Add::borked_installation($plist, $dir, 
a421 1
		$state->{dir} = $plist->{dir};
d485 1
a485 1
	unlink($dir.CONTENTS);
@


1.287
log
@set_infodir during pkg_add.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.286 2007/05/28 13:55:34 espie Exp $
d497 1
a497 2
	my $dest = installed_info($pkgname);
	OpenBSD::Add::register_installation($dir, $dest, $plist);
@


1.286
log
@move `interrupted' stuff inside state: removes one local variable, allows
me to cut up big function into smaller ones.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.285 2007/05/28 12:44:41 espie Exp $
d327 1
@


1.285
log
@store skipupdatedeps in the set, not the plist
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.284 2007/05/28 11:29:09 espie Exp $
a358 1
	my $interrupted;
d360 1
a360 1
		$interrupted = shift;
d389 1
a389 1
			last if $interrupted || $errors;
d392 2
a393 2
		if ($interrupted || $errors) {
			failed_install($handle, $state->{not}, $interrupted);
d439 1
a439 1
		if ($interrupted || $errors) {
d441 1
a441 1
			failed_install($handle, $state->{not}, $interrupted);
d466 1
a466 1
		last if $interrupted;
d481 1
a481 1
	if (!($interrupted || $errors)) {
d491 2
a492 2
	if ($interrupted || $errors) {
		failed_install($handle, $state->{not}, $interrupted);
@


1.284
log
@split off handle creation (for added packages) into its own routine.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.283 2007/05/28 11:15:10 espie Exp $
d199 1
a199 1
	$plist->{skipupdatedeps} = \%conflicts;
d516 1
a516 1
			if (defined $plist->{skipupdatedeps}->{$dep}) {
@


1.283
log
@clean up packing-list validation, call the methods `prepare_for_addition'
and `prepare_for_deletion', that's clearer...
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.282 2007/05/27 22:34:24 espie Exp $
d203 1
a203 4

# This does prepare_to_add a package: finding it and reading its 
# package information
sub prepare_to_add
a205 2

	my $set = OpenBSD::UpdateSet->new;
a206 1
	$set->add_newer($handle);
d212 1
a212 1
		return $set;
d215 4
d225 1
a225 1
		return $set;
d234 1
a234 1
		return $set;
d249 1
a249 1
		return $set;
d259 1
a259 1
			return $set;
d262 12
a273 3
	if ($state->{verbose}) {
		print $state->deptree_header($pkg);
		print "parsing $pkgname\n";
d276 2
a277 2
		$location->close_with_client_error;
		$location->wipe_info;
@


1.282
log
@oops, save_old_libs is now set dependent, we no longer store old packages
in the same location.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.281 2007/05/27 22:18:14 espie Exp $
d242 3
a244 3
	    	!$state->{forced}->{installed} &&
	    	!$plist->has_new_sig($state) && 
	    	!$plist->uses_old_libs)) {
@


1.281
log
@move computation of header to a separate function.
slightly more precise comment
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.280 2007/05/27 22:04:17 espie Exp $
d367 1
a367 1
		OpenBSD::Replace::save_old_libraries($plist, $state);
@


1.280
log
@move packing-list validation to the UpdateSet level.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.279 2007/05/27 21:43:06 espie Exp $
d106 21
d327 2
a341 15
	my $header = $pkgname;

	$header = $state->deptree_header($pkgname).$header;
	if (@@toreplace) {
		$header.=" (replacing ". join(', ', (map {$_->pkgname} @@toreplace)). ")";
	}
	if (!OpenBSD::ProgressMeter::set_header($header)) {
	    print $state->{not} ? "Pretending to add " : "Adding ";
	    print $header;
	    if ($state->{do_faked}) {
		    print " under ", $state->{destdir};
	    }
	    print "\n";
	}

d367 1
a367 3
		if (@@toreplace) {
			OpenBSD::Replace::save_old_libraries($plist, $state);
		}
@


1.279
log
@comment out some of this code. Currently, we don't know how to recover
from collision with old libs (and the result from figure_out_old_libs says
so), so don't pretend we're doing anything significant with them...
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.278 2007/05/27 21:33:55 espie Exp $
d103 1
a103 7
	my @@toreplace = ();
	for my $h (@@{$set->{older}}) {
		if (is_installed($h->{pkgname})) {
			push(@@toreplace, $h->{plist});
		}
	}
	return @@toreplace;
d333 4
a336 7
	if (@@toreplace) {
		for my $old (@@toreplace) {
			OpenBSD::Delete::validate_plist($old, $state);
		}
	}
	my $totsize = OpenBSD::Add::validate_plist($plist, $state);
	OpenBSD::Vstat::synchronize();
@


1.278
log
@group packing-list validation for replaced packages with added one.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.277 2007/05/27 11:36:21 espie Exp $
d320 3
a322 3
	if (defined $plist->{old_libs}) {
		$replacing = 1;
	}
@


1.277
log
@rename $state->{replace} to $state->{allow_replacing}, which matches intent
better...
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.276 2007/05/27 11:31:35 espie Exp $
d338 5
@


1.276
log
@errors can now be a local variable
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.275 2007/05/27 11:21:55 espie Exp $
a118 1
	$plist->{replacing} = [];
d134 1
a134 1
	if (!$state->{replace}) {
d226 1
a226 1
	    (!$state->{replace} ||	
d731 1
a731 1
$state->{replace} = $opt_r || $opt_u;
@


1.275
log
@Simplify the mess that deals with alaready installed packages.
We can now have one central point that deals with it.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.274 2007/05/27 11:02:03 espie Exp $
a37 1
my $errors = 0;
d307 1
@


1.274
log
@store replaced packages inside the UpdateSet directly.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.273 2007/05/27 10:38:12 espie Exp $
a125 8
	if ((keys %conflicts) == 1 && (keys %conflicts)[0] eq $pkgname) {
		if (!$state->{forced}->{installed} &&
		    !$plist->has_new_sig($state) && !$plist->uses_old_libs) {
			print "Already installed: $pkgname\n";
			return 1;
		}
	}

a136 7
		if (@@conflicts == 1 && is_installed($pkgname) &&
		    !$plist->has_new_sig($state) && 
		    !$plist->uses_old_libs) {
			print "Not reinstalling $pkgname\n" if $state->{verbose};
			$state->mark_as_already_installed($pkgname);
			return;
		}
a153 7
	if (is_installed($pkgname) && !$state->{forced}->{installed}) {
		if (!$plist->has_new_sig($state) && !$plist->uses_old_libs) {
			    print "Not reinstalling $pkgname\n" if $state->{verbose};
			    $state->mark_as_already_installed($pkgname);
			    return;
			}
	}
d208 1
a208 1
    	my $plist = $handle->{plist} = $location->plist;
d212 2
d216 1
d219 3
d226 14
d244 3
d530 3
a550 12
	if (is_installed($handle->{pkgname}) && !$state->{forced}->{installed}) {
		if ($state->{replace}) {
			if (!$plist->has_new_sig($state) && !$plist->uses_old_libs) {
				$state->mark_as_already_installed($handle->{pkgname});
				$location->close_now;
				return ();
			}
		} else {
			$location->close_now;
			return ();
		}
	}
@


1.273
log
@depend more stuff off handle.
Introduce UpdateSet, finally, with a main handle.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.272 2007/05/27 09:59:41 espie Exp $
d98 15
d116 2
a117 1
	my ($handle, $state) = @@_;
d202 3
d206 1
a206 2
		push(@@{$plist->{replacing}}, $rplist);
		$plist->{skipupdatedeps} = \%conflicts;
d208 1
d254 1
a254 1
	if (!can_install($handle, $state)) {
d300 2
a301 1
	my ($handle, $state) = @@_;
d315 1
a315 7
	my @@toreplace = ();
	for my $pl2 (@@{$plist->{replacing}}) {
		if (is_installed($pl2->pkgname)) {
			push(@@toreplace, $pl2);
		}
	}
	
d608 1
a608 1
	really_add($handle, $state);
@


1.272
log
@finish converting most things in pkg_add to the `handle' form, so
we no longer stash anything inside locations.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.271 2007/05/27 09:48:05 espie Exp $
d103 1
a103 1
	my $pkgname = $plist->pkgname;
d200 1
d202 1
d208 1
a208 1
		return $handle;
d215 1
a215 1
		return $handle;
d220 1
a220 1
		return $handle;
d222 1
a222 1
	my $pkgname = $handle->{pkgname} = $location->{pkgname} = $plist->pkgname;
d228 1
a228 1
			return $handle;
d241 1
a241 1
	return $handle;
d270 1
a270 1
	my $pkgname = $plist->pkgname;
d286 1
a286 1
	my $pkgname = $plist->pkgname;
d513 2
a514 1
	my $handle = $cache->{$pkg};
d533 1
a533 1
	if (is_installed($plist->pkgname) && !$state->{forced}->{installed}) {
d536 1
a536 1
				$state->mark_as_already_installed($plist->pkgname);
@


1.271
log
@move the dependency solver up to the handle
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.270 2007/05/26 23:55:53 espie Exp $
d209 1
a209 1
    	my $plist = $handle->{plist} = $location->{plist} = $location->plist;
d236 1
a236 1
		delete $location->{plist};
d273 2
a274 1
	OpenBSD::Add::borked_installation($plist, $handle->info, $not, $msg);
d369 1
a369 1
			failed_install($location, $state->{not}, $interrupted);
d417 1
a417 1
			failed_install($location, $state->{not}, $interrupted);
d468 1
a468 1
		failed_install($location, $state->{not}, $interrupted);
d549 1
a549 1
		my $solver = OpenBSD::Dependencies::Solver->new($location->{plist});
@


1.270
log
@pass more handle through
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.269 2007/05/26 23:45:44 espie Exp $
d473 2
a474 2
	if (defined $location->{solver}) {
		$location->{solver}->register_dependencies;
d547 1
a547 1
	if (!defined $location->{solver}) {
d550 1
a550 1
		$location->{solver} = $solver;
d562 1
a562 1
	for my $dep ($location->{solver}->dependencies) {
d571 1
a571 1
	for my $dep ($location->{solver}->dependencies) {
d576 1
a576 1
		if (!$location->{solver}->lookup_library($state, $lib->{name})) {
d578 1
a578 1
			$location->{solver}->dump if $okay;
d582 1
a582 1
#	print "Didn't need to process: ", join(',', @@{$location->{solver}->{todo}}), "\n";
@


1.269
log
@simplify error logic a bit more, always let prepare_to_add return a
handle.

Also kill very old @@exec tests.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.268 2007/05/26 12:25:29 espie Exp $
d101 2
a102 1
	my ($plist, $state, $handle) = @@_;
d209 1
a209 1
    	my $plist = $location->{plist} = $location->plist;
d220 1
a220 1
	my $pkgname = $location->{pkgname} = $plist->pkgname;
d233 1
a233 1
	if (!can_install($plist, $state, $handle)) {
d276 1
a276 1
sub really_add($$)
d279 1
d282 1
a282 1
	my $dir = $handle->info;
d284 1
a284 1
	$state->{archive} = $handle;
d325 1
a325 1
	if (!defined $handle) {
d368 1
a368 1
			failed_install($handle, $state->{not}, $interrupted);
d416 1
a416 1
			failed_install($handle, $state->{not}, $interrupted);
d449 1
a449 1
		$handle->finish_and_close; }
d467 1
a467 1
		failed_install($handle, $state->{not}, $interrupted);
d473 2
a474 2
	if (defined $handle->{solver}) {
		$handle->{solver}->register_dependencies;
d522 1
a522 1
	if ($state->is_installed($location->{pkgname})) {
d527 1
a527 1
	my $plist = $location->{plist};
d590 1
a590 1
	really_add($location, $state);
d592 2
a593 2
	delete $location->{plist};
	$state->mark_installed($location->{pkgname});
@


1.268
log
@oops, fix: pass handle instead of location to can_install.

Ditch the modifications of global $errors.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.267 2007/05/26 12:22:38 espie Exp $
d197 1
a197 1
	my ($pkg, $state, $handle) = @@_;
d199 1
d205 1
a205 5
		return;
	}
	if ($location->{finished}) {
		$handle->set_error(OpenBSD::Handle::CANT_INSTALL);
		return;
d207 1
d212 1
a212 1
		return;
d217 1
a217 1
		return;
d225 1
a225 1
			return;
d232 1
a232 3
	if (can_install($plist, $state, $handle)) {
		return $location;
	} else {
a235 1
		$location->{finished} = 1;
a236 1
		return;
d238 1
a503 2
	my $handle = OpenBSD::Handle->new;

d505 1
a505 1
		$cache->{$pkg} = prepare_to_add($pkg, $state, $handle);
d508 4
a511 10
	my $location = $cache->{$pkg};
	if ($state->{forced}->{kitchensink}) {
		if ($handle->has_error(OpenBSD::Handle::BAD_PACKAGE)) {
			$state->set_pkgname($pkg);
			$state->fatal("Fatal error") unless defined $location;
		} else {
			return () unless defined $location;
		}
	} else {
		if ($handle->has_error) {
d513 1
a513 1
			$state->fatal("Fatal error") unless defined $location;
d515 1
a515 1
			return () unless defined $location;
d519 1
@


1.267
log
@base tests on $handle->has_error instead of $errors.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.266 2007/05/26 12:15:45 espie Exp $
a140 1
		$errors++;
a146 1
		$errors++;
a161 1
		$errors++;
a167 1
		$errors++;
a174 1
			$errors++;
a182 1
			$errors++;
a203 3
		if (!$state->{forced}->{kitchensink}) {
			$errors++;
		}
a213 1
		$errors++;
a218 1
		$errors++;
a226 1
			$errors++;
d234 1
a234 1
	if (can_install($plist, $state, $location)) {
a241 3
		if ($state->{forced}->{kitchensink}) {
			$errors = 0;
		}
@


1.266
log
@give a more descriptive name to function, we're past abreviations
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.265 2007/05/25 13:25:50 espie Exp $
d531 7
a537 3
	if ($errors > 0) {
		$state->set_pkgname($pkg);
		$state->fatal("Fatal error") unless defined $location;
d539 6
a544 1
		return () unless defined $location;
@


1.265
log
@Pass the handle to can_install, so that it can fill in errors (the package
location is actually not used by this routine).
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.264 2007/05/25 13:18:56 espie Exp $
d199 3
a201 2
# This does pre_add a package: finding it and reading its package information
sub pre_add
d527 1
a527 1
		$cache->{$pkg} = pre_add($pkg, $state, $handle);
@


1.264
log
@start cleaning up the mess that is error-handling when installing packages.
Mid-Term, we want to manipulate true `handles' that encapsulate package
locations.

For now, we create this handle externally, and just use it to record
errors, in duplicate...

Once handles are ready, they should be agregated into UpdateSets, to make
replacement of packages more explicit and flexible.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.263 2007/05/25 10:08:12 espie Exp $
d99 1
a99 1
sub can_install($$$)
d140 1
d147 1
d163 1
d170 1
d178 1
d187 1
@


1.263
log
@also rename this one for further wrapping
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.262 2007/05/25 09:50:31 espie Exp $
d194 1
a194 1
sub pre_add($$)
d196 1
a196 1
	my ($pkg, $state) = @@_;
d202 1
d209 1
d215 1
d221 1
d230 1
d246 1
d517 2
d520 1
a520 1
		$cache->{$pkg} = pre_add($pkg, $state);
@


1.262
log
@rename `handle' to `location' in preparation for wrapping it in a
proper `handle'.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.261 2007/05/23 10:33:45 espie Exp $
d515 1
a515 1
	my $handle = $cache->{$pkg};
d518 1
a518 1
		$state->fatal("Fatal error") unless defined $handle;
d520 1
a520 1
		return () unless defined $handle;
d523 2
a524 2
	if ($state->is_installed($handle->{pkgname})) {
		$handle->close_now;
d528 1
a528 1
	my $plist = $handle->{plist};
d534 1
a534 1
				$handle->close_now;
d538 1
a538 1
			$handle->close_now;
d548 2
a549 2
	if (!defined $handle->{solver}) {
		my $solver = OpenBSD::Dependencies::Solver->new($handle->{plist});
d551 1
a551 1
		$handle->{solver} = $solver;
d563 1
a563 1
	for my $dep ($handle->{solver}->dependencies) {
d566 1
a566 1
		$handle->close_now;
d572 1
a572 1
	for my $dep ($handle->{solver}->dependencies) {
d577 1
a577 1
		if (!$handle->{solver}->lookup_library($state, $lib->{name})) {
d579 1
a579 1
			$handle->{solver}->dump if $okay;
d583 1
a583 1
#	print "Didn't need to process: ", join(',', @@{$handle->{solver}->{todo}}), "\n";
d585 1
a585 1
		$handle->close_now;
d591 4
a594 4
	really_add($handle, $state);
	$handle->wipe_info;
	delete $handle->{plist};
	$state->mark_installed($handle->{pkgname});
@


1.261
log
@fiddle with SharedLibs name, put common code into a common place in
pkg_add.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.260 2007/05/22 10:47:40 espie Exp $
d197 3
a199 3
	
	my $handle = OpenBSD::PackageLocator->find($pkg, $state->{arch});
	if (!$handle) {
d207 1
a207 1
	if ($handle->{finished}) {
d210 1
a210 1
    	my $plist = $handle->{plist} = $handle->plist;
d221 1
a221 1
	my $pkgname = $handle->{pkgname} = $plist->pkgname;
d234 2
a235 2
	if (can_install($plist, $state, $handle)) {
		return $handle;
d237 4
a240 4
		$handle->close_with_client_error;
		$handle->wipe_info;
		delete $handle->{plist};
		$handle->{finished} = 1;
@


1.260
log
@cleanup shared state a bit earlier. Shouldn't change much, but may help
ensuring we don't reload fontdirs twice with weird fontdirs case.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.259 2007/05/22 10:11:58 espie Exp $
d79 7
d128 1
a128 1
		if (@@conflicts == 1 && is_installed($plist->pkgname) &&
d132 1
a132 2
			OpenBSD::SharedLibs::add_package_libs($plist->pkgname);
			$state->mark_installed($pkgname);
d152 1
a152 1
	if (is_installed($plist->pkgname) && !$state->{forced}->{installed}) {
d155 1
a155 2
			    OpenBSD::SharedLibs::add_package_libs($plist->pkgname);
			    $state->mark_installed($pkgname);
d474 1
a474 1
	OpenBSD::SharedLibs::add_plist_libs($plist);
d533 1
a533 2
				OpenBSD::SharedLibs::add_package_libs($plist->pkgname);
				$state->mark_installed($handle->{pkgname});
d573 1
a573 1
		OpenBSD::SharedLibs::add_package_libs($dep);
@


1.259
log
@introduce a SharedItemsRecorder (put it into Vstat, since that's a file
common to Add and Delete, for now).

Use it to have common code that records items to remove / items remaining.

Stash it into pkg_add/pkg_delete state, and abstract the cleaning up
operation into the SharedItemsRecorder (so that pkg_add and pkg_delete no
longer have to know about the internals of SharedItems at all).
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.258 2007/05/20 14:40:50 espie Exp $
d795 1
a798 2
# delayed directory/user/group removal
$state->{recorder}->cleanup($state);
@


1.258
log
@move deptree and installed into state object
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.257 2007/05/20 14:21:33 espie Exp $
d90 1
d669 1
d799 1
a799 6
if (defined $state->{dirs_to_rm} or defined $state->{users_to_rm} or
	defined $state->{groups_to_rm}) {
	require OpenBSD::SharedItems;

	OpenBSD::SharedItems::cleanup($state) unless $state->{not};
}
@


1.257
log
@create specific `state' objects for pkg_add and pkg_delete, so that I can
write shortcuts for common behavior, and start hiding some details.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.256 2007/05/20 14:04:39 espie Exp $
d47 31
d79 11
d125 1
a125 1
			$state->{installed}->{$pkgname} = 1;
d149 1
a149 1
			    $state->{installed}->{$pkgname} = 1;
d166 1
a166 1
		if (defined $state->{installed}->{$toreplace}) {
d194 1
a194 3
		if (defined $state->{deptree}->{$pkg}) {
			print $state->{deptree}->{$pkg}, ":";
		}
d225 1
a225 3
		if (defined $state->{deptree}->{$pkg}) {
		    print $state->{deptree}->{$pkg},":";
		}
d309 1
a309 3
	if (defined $state->{deptree}->{$pkgname}) {
	    $header = $state->{deptree}->{$pkgname}.":".$header;
	}
a499 16
# one-level dependencies tree, for nicer printouts
sub build_deptree
{
	my ($state, $pkg, @@deps) = @@_;

	my $tree = $state->{deptree};
	$pkg = OpenBSD::PackageName::url2pkgname($pkg);
	# flatten info
	if (defined $tree->{$pkg}) {
		$pkg = $tree->{$pkg};
	}
	for my $i (@@deps) {
		$tree->{$i} = $pkg unless defined $tree->{$i};
	}
}

d517 1
a517 1
	if (defined $state->{installed}->{$handle->{pkgname}}) {
d528 1
a528 1
				$state->{installed}->{$handle->{pkgname}} = 1;
d551 1
a551 1
			build_deptree($state, $pkg, @@deps);
d589 1
a589 1
	$state->{installed}->{$handle->{pkgname}} = 1;
a667 2
$state->{installed} = {};
$state->{deptree} = {};
d814 1
a814 1
	print "Added:\n", (map { "\t$_\n" } sort keys %{$state->{installed}}), "\n";
@


1.256
log
@placeholders for UpdateSet, once we have it.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.255 2007/05/20 11:06:44 espie Exp $
d44 2
d48 1
d646 1
a646 1
my $state = new OpenBSD::Error;
@


1.255
log
@compute list of dependencies to adjust just-in-time.
This lets the pkg_add regress pass, finally.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.254 2007/05/19 23:40:46 espie Exp $
d36 1
@


1.254
log
@move the code that handles dependencies registration into Dependencies
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.253 2007/05/18 09:45:18 espie Exp $
d338 3
a441 1
		require OpenBSD::RequiredBy;
@


1.253
log
@we don't need to walk the full dependency tree each time we don't find
a library. Instead, put the state of the closure computation in the solver
object, and only proceed until we find the library. We just need an extra
marker (known) to be aware of packages that may contain libraries, but have
not been used for extra dependencies yet.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.252 2007/05/17 15:40:06 espie Exp $
d430 1
a430 8
		require OpenBSD::RequiredBy;

		my $r = OpenBSD::Requiring->new($pkgname);

		for my $dep ($handle->{solver}->dependencies) {
			OpenBSD::RequiredBy->new($dep)->add($pkgname);
			$r->add($dep);
		}
@


1.252
log
@library lookup becomes a real method
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.251 2007/05/17 15:35:58 espie Exp $
a480 8
sub clue
{
	my $h = shift;
	Warn "Even by looking in the dependency tree:\n";
	Warn "\t", join(", ", keys %$h), "\n";
}


d553 1
a553 2
		my $extra = {};
		if (!$handle->{solver}->lookup_library($state, $lib->{name}, $extra)) {
d555 1
a555 1
			clue($extra) if $okay;
d559 1
@


1.251
log
@move the library lookup code into Solver, so that I can turn it into
methods as well...
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.250 2007/05/17 14:13:40 espie Exp $
a535 1
		$handle->{solved_dependencies} = $solver->{to_register};
d562 1
a562 2
		if (!OpenBSD::Dependencies::Solver::lookup_library($state, $lib->{name}, $plist,
		    $handle->{solved_dependencies}, $extra)) {
@


1.250
log
@use solver object in all direct instances of solved_dependencies.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.249 2007/05/17 14:08:49 espie Exp $
d563 1
a563 1
		if (!OpenBSD::Dependencies::lookup_library($state, $lib->{name}, $plist,
@


1.249
log
@access solver internals in a clean way through dependencies, uses it
internally.
store solver objects along with solved_dependencies.
Eventually, all solved_dependencies requests will use solver objects
instead.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.248 2007/05/17 13:36:21 espie Exp $
d429 1
a429 1
	if (defined $handle->{solved_dependencies}) {
d434 1
a434 1
		for my $dep (keys %{$handle->{solved_dependencies}}) {
d532 1
a532 1
	if (!defined $handle->{solved_dependencies}) {
d548 1
a548 1
	for my $dep (keys %{$handle->{solved_dependencies}}) {
d557 1
a557 1
	for my $dep (keys %{$handle->{solved_dependencies}}) {
@


1.248
log
@tweak the solver object a bit, now that I have a clearer idea of what
it's going to be used for.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.247 2007/05/14 18:19:25 espie Exp $
d535 1
@


1.247
log
@put the solver into its  own class.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.246 2007/05/14 17:52:08 espie Exp $
d533 3
a535 2
		my $solver = OpenBSD::Dependencies::Solver->new;
		my @@deps = $solver->solve($state, $handle, @@todo);
@


1.246
log
@move verbose printing into a separate method.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.245 2007/05/14 11:22:00 espie Exp $
d533 1
a533 1
		my $solver = OpenBSD::Dependencies->solver;
@


1.245
log
@redo search filters as real objects. Accordingly, rename match_list to
filter.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.244 2007/05/14 11:02:14 espie Exp $
d535 3
@


1.244
log
@put Search objects into their own file, finally
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.243 2007/05/14 10:53:31 espie Exp $
d334 1
a334 1
			if (OpenBSD::Search::PkgSpec->new("mozilla-thunderbird-<=1.0.2p0")->match_list($op->pkgname)) {
@


1.243
log
@put search objects into a search class.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.242 2007/05/14 10:43:45 espie Exp $
a28 1
use OpenBSD::PkgSpec;
d333 1
@


1.242
log
@name tweaks: match -> match_list, match_repo -> match
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.241 2007/05/14 09:49:27 espie Exp $
d334 1
a334 1
			if (OpenBSD::PkgSpec->new("mozilla-thunderbird-<=1.0.2p0")->match_list($op->pkgname)) {
d594 1
a594 1
		    my @@l = $h->match(OpenBSD::PackageName::Stem->new($pkgname));
@


1.241
log
@tidy
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.240 2007/05/13 13:32:36 espie Exp $
d334 1
a334 1
			if (OpenBSD::PkgSpec->new("mozilla-thunderbird-<=1.0.2p0")->match($op->pkgname)) {
@


1.240
log
@unify object lookup as locator->match($o) or $repo->match($o)
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.239 2007/05/13 10:43:33 espie Exp $
d825 1
a825 1
	return  grep {/^\.libs\-/} $d->list();
@


1.239
log
@turn the updater into an object
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.238 2007/05/12 14:48:45 espie Exp $
d594 1
a594 1
		    my @@l = $h->findstem($pkgname);
@


1.238
log
@use PkgSpec objects most of the time
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.237 2007/05/07 14:21:39 espie Exp $
d733 4
a736 1
	my @@cantupdate = OpenBSD::Update::find(\@@ARGV, \@@todo, $state);
d753 1
@


1.237
log
@lift up findstem to the PackageRepository
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.236 2007/05/07 14:12:43 espie Exp $
d334 1
a334 2
			if (OpenBSD::PkgSpec::match("mozilla-thunderbird-<=1.0.2p0",
			    $op->pkgname)) {
@


1.236
log
@remove dependency on available_stems(), make it go thru PackageLocator
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.235 2007/05/07 13:51:58 espie Exp $
d590 1
a590 1
			$h = OpenBSD::PackageName::avail2stems($state, $repo->available);
@


1.235
log
@make keep_most_recent explicit, do not try to pre-compute it at the stemlist
level.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.234 2007/05/07 12:19:04 espie Exp $
a584 2
	my $allstems;

d592 1
a592 4
			if (!defined $allstems) {
			    $allstems = OpenBSD::PackageName::available_stems($state);
			}
			$h = $allstems;
@


1.234
log
@refactor: create a solver object to handle state issues in a simpler way.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.233 2007/05/07 08:10:45 espie Exp $
d601 1
a601 1
		    if (@@l > 1) {
@


1.233
log
@zap unused parameters.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.232 2007/05/07 08:05:23 espie Exp $
d534 2
a535 1
		my @@deps = OpenBSD::Dependencies::solve($state, $handle, @@todo);
@


1.232
log
@finish removing old libdepends checks.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.231 2007/05/03 14:47:29 espie Exp $
d559 1
a559 1
		    $handle->{solved_dependencies}, 1, $extra)) {
@


1.231
log
@remove future code to handle modules, that is unused and possibly badly
designed as well.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.230 2007/05/02 15:17:36 espie Exp $
a555 11
	for my $dep (@@{$plist->{libdepend}}) {
		return () if defined $dep->{name} and $dep->{name} ne $plist->pkgname;
		for my $spec (split(/,/, $dep->{libspec})) {
		    if (!OpenBSD::Dependencies::lookup_library($state, $spec, $plist,
			$handle->{solved_dependencies}, 0)) {
			    Warn "Can't install $pkg: lib not found $spec\n";
			    clue($handle->{solved_dependencies}) if $okay;
			    $okay = 0;
		    }
		}
	}
@


1.230
log
@replace pkgbase with less confusing name localbase
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.229 2007/05/02 13:59:19 espie Exp $
a512 11
	if ($plist->{need_modules}) {
	    if (!defined $handle->{solved_dependencies}) {
		    my @@deps = OpenBSD::Dependencies::solve($state, $handle, @@todo);
		    if (@@deps > 0) {
			    build_deptree($state, $pkg, @@deps);
			    return (@@deps, $pkg);
		    }
	    } else {
		    $plist = $handle->{plist} = $handle->plist;
	    }
	}
@


1.229
log
@remove extraneous () in method call: $o->method() becomes $o->method
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.228 2007/05/01 18:22:20 espie Exp $
d167 2
a168 2
	if ($plist->pkgbase ne $state->{localbase}) {
		print "Localbase mismatch: package has: ", $plist->pkgbase, " , user wants: ", $state->{localbase}, "\n";
d289 1
a289 1
	$ENV{'PKG_PREFIX'} = $plist->pkgbase;
@


1.228
log
@move the old elements into PackingElements, since the code is now
much shorter.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.227 2007/04/21 09:57:22 espie Exp $
d49 1
a49 1
	my $pkgname = $plist->pkgname();
d58 1
a58 1
		    !$plist->has_new_sig($state) && !$plist->uses_old_libs()) {
d75 1
a75 1
		if (@@conflicts == 1 && is_installed($plist->pkgname()) &&
d77 1
a77 1
		    !$plist->uses_old_libs()) {
d79 1
a79 1
			OpenBSD::SharedLibs::add_package_libs($plist->pkgname());
d100 2
a101 2
	if (is_installed($plist->pkgname()) && !$state->{forced}->{installed}) {
		if (!$plist->has_new_sig($state) && !$plist->uses_old_libs()) {
d103 1
a103 1
			    OpenBSD::SharedLibs::add_package_libs($plist->pkgname());
d161 1
a161 1
    	my $plist = $handle->{plist} = $handle->plist();
d167 2
a168 2
	if ($plist->pkgbase() ne $state->{localbase}) {
		print "Localbase mismatch: package has: ", $plist->pkgbase(), " , user wants: ", $state->{localbase}, "\n";
d172 1
a172 1
	my $pkgname = $handle->{pkgname} = $plist->pkgname();
d190 2
a191 2
		$handle->close_with_client_error();
		$handle->wipe_info();
d213 1
a213 1
		next unless $item->IsFile();
d227 1
a227 1
	my $pkgname = $plist->pkgname();
d232 1
a232 1
	OpenBSD::Add::borked_installation($plist, $handle->info(), $not, $msg);
d240 2
a241 2
	my $dir = $handle->info();
	my $pkgname = $plist->pkgname();
d252 1
a252 1
		if (is_installed($pl2->pkgname())) {
d272 1
a272 1
		$header.=" (replacing ". join(', ', (map {$_->pkgname()}@@toreplace)). ")";
d289 1
a289 1
	$ENV{'PKG_PREFIX'} = $plist->pkgbase();
d332 2
a333 2
			OpenBSD::ProgressMeter::set_header($op->pkgname()." (deleting)");
			$state->set_pkgname($op->pkgname());
d335 1
a335 1
			    ($op->pkgname()))) {
d346 1
a346 1
				    $op->pkgname(), " failed");
d349 1
a349 1
			delete_installed($op->pkgname());
d351 1
a351 1
				delete $state->{updatedepends}->{$op->pkgname()};
d406 1
a406 1
		$handle->finish_and_close(); }
d427 1
a427 1
	$plist->to_cache();
d449 1
a449 1
		my $opkgname = $op->pkgname();
d508 1
a508 1
		$handle->close_now();
d521 1
a521 1
		    $plist = $handle->{plist} = $handle->plist();
d525 1
a525 1
	if (is_installed($plist->pkgname()) && !$state->{forced}->{installed}) {
d527 2
a528 2
			if (!$plist->has_new_sig($state) && !$plist->uses_old_libs()) {
				OpenBSD::SharedLibs::add_package_libs($plist->pkgname());
d530 1
a530 1
				$handle->close_now();
d534 1
a534 1
			$handle->close_now();
d557 1
a557 1
		$handle->close_now();
d568 1
a568 1
		return () if defined $dep->{name} and $dep->{name} ne $plist->pkgname();
d588 1
a588 1
		$handle->close_now();
d595 1
a595 1
	$handle->wipe_info();
d847 1
a847 1
	my $d = OpenBSD::Requiring->new($plist->pkgname());
d855 3
a857 3
		my $n = OpenBSD::PackingList->from_installation($plist->pkgname())->signature();
		my $o = $plist->signature();
		print "Comparing full signature for ", $plist->pkgname(), " \"$o\" vs. \"$n\": ", $n eq $o ? "equal\n" : "different\n" 
@


1.227
log
@if running a full update, proceed if we can't find some packages.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.226 2007/04/15 10:17:29 espie Exp $
a98 1
	require OpenBSD::PackingOld;
@


1.226
log
@update copyright years, standardize licence.
reword the introduction to the stuff originally from FreeBSD to clarify
slightly.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.225 2007/03/27 22:41:07 espie Exp $
d764 6
a769 2
		unless ($state->{forced}->{alwaysupdate} ||
			OpenBSD::Interactive::confirm("Proceed", $state->{interactive}, 0)) {
d771 1
@


1.225
log
@finally remove old warning, @@lib has been around (and used) since 3.7.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.224 2007/03/07 11:24:07 espie Exp $
d6 1
a6 1
# Copyright (c) 2003-2004 Marc Espie <espie@@openbsd.org>
@


1.224
log
@fix size checks for good. Since we want deletion to happen `right now'
but size accounting to happen later, just mark the size to delete `for
later', do not take them into account for avail(), and synchronize() at
the right time, e.g., after addition when updating, and right away for
straight deletion.

okay deraadt@@
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.223 2007/03/07 00:09:46 espie Exp $
a487 3
	Warn "Maybe it's in a dependent package, but not tagged with \@@lib ?\n";
	Warn "(check with pkg_info -K -L)\n";
	Warn "If you are still running 3.6 packages, update them.\n";
@


1.223
log
@revert size check tweak, the fix does break other stuff. this is harder
than I thought...
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.222 2007/03/06 23:35:01 espie Exp $
d284 1
@


1.222
log
@get vfs size snapshotted and restored so that pkg_add -u has a harder
time overflowing the disk.

let stem work at the end of urls.

test sturm@@ and bernd@@,

okay deraadt@@
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.221 2007/02/04 12:46:54 espie Exp $
a282 1
	my $x = OpenBSD::Vstat::remember_used();
a283 1
	OpenBSD::Vstat::restore_used($x);
@


1.221
log
@protect `normal' installs against archive burps.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.220 2006/11/17 15:34:15 espie Exp $
d283 1
d285 1
d611 1
a611 1
	my $h;
d615 10
a624 2
		    if (!defined $h) {
		    	$h = OpenBSD::PackageName::available_stems($state);
d632 3
@


1.220
log
@don't return undef, use plain return.
(return undef is only false in a scalar context)
found my perlcritic, one of the few issues I agree with...
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.219 2006/10/17 21:47:22 espie Exp $
d405 6
a410 1
	$handle->finish_and_close();
@


1.219
log
@add -F conflicts: force installation in the presence of registered conflicts,
provided nothing else happens (like, huh, the presence of actual conflicts
between files).

Allows nikolay@@ to work with redhat/base and fedora_core at the same time.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.218 2006/08/25 08:42:38 espie Exp $
d81 1
a81 1
			return undef;
d89 1
a89 1
		return undef;
d95 1
a95 1
		return undef;
d106 1
a106 1
			    return undef;
d112 1
a112 1
		return undef;
d118 1
a118 1
		return undef;
d125 1
a125 1
			return undef;
d133 1
a133 1
			return undef;
d157 1
a157 1
		return undef;
d160 1
a160 1
		return undef;
d166 1
a166 1
		return undef;
d171 1
a171 1
		return undef;
d179 1
a179 1
			return undef;
d198 1
a198 1
		return undef;
@


1.218
log
@add PackingOld when replacing, helps people with really old installs...
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.217 2006/03/04 11:31:18 espie Exp $
d82 4
@


1.217
log
@reorganize code a little bit: Update.pm becomes Replace.pm (since it matches
the -r option), and the find_update code moves to Update.pm, so that it doesn't
get parsed if -u is not used.

Also make the has_new_sig and uses_old_libs local methods of PackingList,
as it is their natural API.

Reorg a few more routines so that they can be found by pkg_add and by
Update.pm.

May need to split off more stuff to avoid parsing everything...
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.216 2006/02/10 11:42:51 espie Exp $
d95 1
@


1.216
log
@reset $state->{dir} to the correct value after deleting the replaced package.
Fixes a problem noticed by steven.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.215 2006/02/10 10:08:16 bernd Exp $
a43 21
sub uses_old_libs
{
	my $plist = shift;
	require OpenBSD::RequiredBy;

	my $d = OpenBSD::Requiring->new($plist->pkgname());
	return  grep {/^\.libs\-/} $d->list();
}

sub has_new_sig
{
	my ($plist, $state) = @@_;
	if (!defined $plist->{new_sig}) {
		my $n = OpenBSD::PackingList->from_installation($plist->pkgname())->signature();
		my $o = $plist->signature();
		print "Comparing full signature for ", $plist->pkgname(), " \"$o\" vs. \"$n\": ", $n eq $o ? "equal\n" : "different\n" 
		    if $state->{very_verbose};
		$plist->{new_sig} = $n ne $o;
	}
	return $plist->{new_sig};
}
d58 1
a58 1
		    !has_new_sig($plist, $state) && !uses_old_libs($plist)) {
d76 2
a77 2
		    !has_new_sig($plist, $state) && 
		    !uses_old_libs($plist)) {
d94 1
a94 1
	require OpenBSD::Update;
d97 1
a97 1
		if (!has_new_sig($plist, $state) && !uses_old_libs($plist)) {
d104 1
a104 1
	if (!OpenBSD::Update::is_safe($plist, $state)) {
d110 1
a110 1
	if (!OpenBSD::Update::figure_out_libs($plist, $state, @@libs)) {
d123 1
a123 1
		my $rplist = OpenBSD::Update::can_do($toreplace, $pkgname, 
d297 1
a297 1
		require OpenBSD::Update;
d302 1
a302 1
			OpenBSD::Update::save_old_libraries($plist, $state);
d438 1
a438 1
		require OpenBSD::Update;
d451 1
a451 1
			OpenBSD::Update::adjust_dependency($dep, $opkgname, $pkgname);
d520 1
a520 1
			if (!has_new_sig($plist, $state) && !uses_old_libs($plist)) {
a594 137
sub choose1
{
	my ($pkgname, $interactive, @@l) = @@_;
	if (@@l == 0) {
	    print "Can't resolve $pkgname\n";
	    $bad = 1;
	} elsif (@@l == 1) {
		return $l[0];
	} elsif (@@l != 0) {
		print "Ambiguous: $pkgname could be ", join(' ', @@l),"\n";
		if ($interactive) {
		    my $result = OpenBSD::Interactive::ask_list('Choose one package', 1, ("<None>", @@l));
		    if ($result eq '<None>') {
			$bad = 1;
		    } else {
			return $result;
		    }
		} else {
		    $bad = 1;
		}
	}
	return undef;
}

sub available_stems
{
	my $state = shift;
	my @@avail = OpenBSD::PackageLocator::available();
	if (@@avail == 0) {
		Warn "No packages available in the PKG_PATH\n";
	}
	unless ($state->{forced}->{allversions}) {
	    @@avail = OpenBSD::PackageName::keep_most_recent(@@avail);
	}
	return OpenBSD::PackageName::compile_stemlist(@@avail);
}

sub find_updates
{
	my ($old, $new, $state) = @@_;
	my @@list = ();

	OpenBSD::PackageInfo::solve_installed_names($old, \@@list, "(updating them all)", $state);
	unless (defined $state->{full_update} or defined $state->{forced}->{noclosure}) {
		require OpenBSD::RequiredBy;

		@@list = OpenBSD::Requiring->compute_closure(@@list);
	}
	my @@cantupdate = ();
	my $hash = available_stems($state);

	OpenBSD::ProgressMeter::set_header("Looking for updates");
	for my $pkgname (@@list) {
		next if $pkgname =~ m/^\.libs-/;
		my $stem = OpenBSD::PackageName::splitstem($pkgname);
		my @@l = $hash->findstem($stem);
		if (@@l == 0) {
			push(@@cantupdate, $pkgname);
			next;
		}
		my @@l2 = ();
		if (@@l == 1 && $state->{forced}->{pkgpath}) {
			OpenBSD::ProgressMeter::clear();
			print "Directly updating $pkgname -> ", $l[0], "\n";
			push(@@$new, $l[0]);
			next;
		}
		my $plist = OpenBSD::PackingList->from_installation($pkgname, \&OpenBSD::PackingList::UpdateInfoOnly);
		if (!defined $plist) {
			Fatal("Can't locate $pkgname");
		}
		my $found;
		for my $candidate (@@l) {
		    my $handle = OpenBSD::PackageLocator->find($candidate, $state->{arch});
		    if (!$handle) {
			    next;
		    }
		    $handle->close_now();
		    my $p2 = $handle->plist(\&OpenBSD::PackingList::UpdateInfoOnly);
		    if (!$p2) {
		    	next;
		    }
		    if ($p2->has('arch')) {
			unless ($p2->{arch}->check($state->{arch})) {
			    next;
			}
		    }
		    if ($plist->signature() eq $p2->signature()) {
		    	$found = $candidate;
		    }
		    if ($p2->{extrainfo}->{subdir} eq $plist->{extrainfo}->{subdir}) {
			push(@@l2, $candidate);
		    } elsif ($p2->has('pkgpath')) {
		    	for my $p (@@{$p2->{pkgpath}}) {
				if ($p->{name} eq $plist->{extrainfo}->{subdir}) {
					push(@@l2, $candidate);
					last;
				}
		    	}
		    }
		}

		if (defined $found && @@l2 == 1 && $found eq  $l2[0]) {
			if (!uses_old_libs($plist)) {
				my $msg = "No need to update $pkgname";
				OpenBSD::ProgressMeter::message($msg);
				print "$msg\n" if $state->{beverbose};
				next;
			}
		}
		OpenBSD::ProgressMeter::clear();
		print "Candidates for updating $pkgname -> ", join(' ', @@l2), "\n";
		# if all packages have the same version, but distinct p,
		# grab the most recent.
		if (@@l2 > 1) {
		    @@l2 = OpenBSD::PackageName::keep_most_recent(@@l2);
		}
			
		if (@@l2 == 1) {
			if (defined $found && $found eq  $l2[0] && !uses_old_libs($plist)) {
				my $msg = "No need to update $pkgname";
				OpenBSD::ProgressMeter::message($msg);
				print "$msg\n" if $state->{beverbose};
			} else {
				push(@@$new, $l2[0]);
			}
		} elsif (@@l2 == 0) {
			push(@@cantupdate, $pkgname);
		} else {
			my $result = choose1($pkgname, $state->{interactive}, sort @@l2);
			push(@@$new, $result) if defined $result;
		}
	}
	OpenBSD::ProgressMeter::next();
	return @@cantupdate;
}

d604 1
a604 1
		    	$h = available_stems($state);
d610 6
a615 2
		    my $result = choose1($pkgname, $state->{interactive}, sort @@l);
		    push(@@$new, $result) if defined $result;
d736 2
d742 1
a742 1
	my @@cantupdate = find_updates(\@@ARGV, \@@todo, $state);
d750 1
a750 1
	if ($bad) {
d815 24
@


1.215
log
@Use the ProgressMeter engine to display the update messages. This makes
'pkg_add -u' less chatty. (turn on verbose output to restore the old behaviour)

Advise the user to re-run 'pkg_add -u' in interactive mode if there are
ambiguities.

Discussed with steven@@ and espie@@.

Testing and some ideas by steven@@, thanks.

ok espie@@
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.214 2006/02/09 09:40:31 espie Exp $
d374 1
@


1.214
log
@use new interface (*close*)
optimization: store dir into state earlier, so that do_script and
other stuff can have access to it.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.213 2006/02/07 10:34:56 bernd Exp $
d666 1
d677 1
d719 3
a721 1
				print "No need to update $pkgname\n";
d725 1
d735 3
a737 1
				print "No need to update $pkgname\n";
d748 1
d901 8
a908 1
	print "Running the equivalent of pkg_add -r ", join(' ', @@todo), "\n";
@


1.213
log
@Don't push undef into the todo list. This avoids some perl warnings.

ok espie@@
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.212 2006/01/17 20:46:52 espie Exp $
d207 1
a207 1
		$handle->close();
a221 1
	$state->{dir} = $plist->{dir};
d261 1
d420 1
a420 1
	$handle->close();
d521 1
a521 1
		$handle->close();
d543 1
a543 1
				$handle->close();
d547 1
a547 1
			$handle->close();
d570 1
a570 1
		$handle->close();
d601 1
a601 1
		$handle->close();
d690 1
a690 1
		    $handle->close(0);
@


1.212
log
@special-case packages that use old-libs: always update them, even if the
signature didn't change.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.211 2005/11/03 11:50:32 espie Exp $
d737 2
a738 1
			push(@@$new, choose1($pkgname, $state->{interactive}, sort @@l2));
d759 2
a760 1
		    push(@@$new, choose1($pkgname, $state->{interactive}, sort @@l));
@


1.211
log
@exit with 1 if we can't install shit thanks to dependencies issues.
found out by sturm@@
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.210 2005/10/24 08:55:59 espie Exp $
d44 9
d79 1
a79 1
		    !has_new_sig($plist, $state)) {
d97 2
a98 1
		    !has_new_sig($plist, $state)) {
d118 1
a118 1
		if (!has_new_sig($plist, $state)) {
d540 1
a540 1
			if (!has_new_sig($plist, $state)) {
d716 4
a719 2
			print "No need to update $pkgname\n";
			next;
d729 1
a729 1
			if (defined $found && $found eq  $l2[0]) {
@


1.210
log
@filter out .libs-* later, so that compute_closures() packages do not
get involved.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.209 2005/10/24 07:16:35 espie Exp $
d39 1
d561 1
d592 4
a595 1
		return () unless $forced{libdepends};
a603 1
my $bad = 0;
d934 4
@


1.209
log
@do not try to find a match for .libs-* packages.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.208 2005/10/22 17:44:07 espie Exp $
d653 1
d864 1
a864 1
		@@ARGV = sort(installed_packages(1));
@


1.208
log
@add a hint to close that says how the fd got closed (real error, premature,
normal).

This will get used by parse_problems() to figure out what to report exactly,
e.g., short writes from prematurely closed fd are not real errors...
stuff that can't connect IPv6 and retries as v4 is not either, unless
there's a genuine `can't connect error'.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.207 2005/10/22 15:01:54 espie Exp $
d863 1
a863 1
		@@ARGV = sort(installed_packages());
@


1.207
log
@always display the list of packages we can't update.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.206 2005/10/10 11:06:04 espie Exp $
d675 1
a675 1
		    $handle->close();
@


1.206
log
@several paths lead to has_new_sig, cache the result.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.205 2005/10/10 11:02:19 espie Exp $
d868 1
d870 1
a870 1
			OpenBSD::Interactive::confirm("Cannot find updates for ".join(' ', @@cantupdate).". Proceed", $state->{interactive}, 0)) {
@


1.205
log
@We should do this, placeholder.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.204 2005/10/10 09:33:56 espie Exp $
d46 8
a53 5
	my $n = OpenBSD::PackingList->from_installation($plist->pkgname())->signature();
	my $o = $plist->signature();
	print "Comparing full signature for ", $plist->pkgname(), " \"$o\" vs. \"$n\": ", $n eq $o ? "equal\n" : "different\n" 
	    if $state->{very_verbose};
	return $n ne $o;
@


1.204
log
@Display an error message if no packages are available in the PKG_PATH.
Quote nlist command, if we invoke it accidentally in a directory with *.tgz
present.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.203 2005/09/19 10:19:45 espie Exp $
d373 1
@


1.203
log
@use $handle->plist()
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.202 2005/09/14 10:16:08 espie Exp $
d625 3
@


1.202
log
@typo, let @@pkgpath work.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.201 2005/09/13 20:57:14 espie Exp $
d164 1
a164 3
	my $dir = $handle->info();
    	my $plist = $handle->{plist} = 
	    OpenBSD::PackingList->fromfile($dir.CONTENTS);
a230 1
	my $dir = $handle->info();
d236 1
a236 1
	OpenBSD::Add::borked_installation($plist, $dir, $not, $msg);
d519 1
a519 3
		    my $dir = $handle->info();
		    $plist = $handle->{plist} = 
			OpenBSD::PackingList->fromfile($dir.CONTENTS);
d669 4
a672 3
		    my $dir = $handle->info();
		    my $p2 = OpenBSD::PackingList->fromfile($dir.CONTENTS,
			\&OpenBSD::PackingList::UpdateInfoOnly);
@


1.201
log
@use wipe_info() instead of hand-killing directories.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.200 2005/09/07 09:11:22 jmc Exp $
d689 1
a689 1
				if ($p2->{name} eq $plist->{extrainfo}->{subdir}) {
@


1.200
log
@sort options, and sync usage();
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.199 2005/09/05 11:41:03 espie Exp $
a36 1
use File::Path;
d196 1
a196 1
		rmtree($handle->info());
d594 1
a594 1
	rmtree($handle->info());
@


1.199
log
@Missing -F installed test.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.198 2005/09/04 22:53:51 espie Exp $
d759 2
a760 2
set_usage('pkg_add [-aciInqrvvx] [-A arch] [-B pkg-destdir] [-F keywords]',
'[-L localbase] [-P type] [-Q quick-destdir] pkgname [...]');
@


1.198
log
@zap duplicate code
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.197 2005/09/04 22:47:56 espie Exp $
d66 2
a67 1
		if (!has_new_sig($plist, $state)) {
@


1.197
log
@* New -i interactive option, that can ask obnoxious questions.
* move the signature code to a packing-list method, prepend the pkgname.
* depend on distant listings, cache these systematically.
* cut the PKG_PATH at :/ systematically, much simpler than parsing URLs.
People should get used to trailing /s.
* let pkg_add -u actually run the update.
* check for signature in more places, for instance, let pkg_add installed_stuff
be a void operation.
* grab enough stuff during updates to check signatures, so that pkg_add -u
can report updates that are not needed right away, instead of waiting
for the more confusing `trying to update'
* beginning of @@module support.
* @@pkgpath support, including updates.
* systematically expand stems when applicable.
* use visitors systematically in pkg_info.
* pkg_info -S reports signature.
* remove hardcoding of categories in PackingList, so that future modules
will be able to expand them.
* add @@updateset and @@incompatibility keywords.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.196 2005/08/29 00:42:58 espie Exp $
d66 1
a66 1
		if (!OpenBSD::Add::is_needed($plist, $state)) {
d530 1
a530 1
			if (!OpenBSD::Add::is_needed($plist, $state)) {
@


1.196
log
@correctly trim old p* versions of packages.

tests sturm@@, aanriot@@

okay deraadt@@
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.195 2005/08/22 12:18:06 espie Exp $
d34 1
d44 11
d65 4
a68 8
	if (defined $conflicts{$pkgname}) {
		if (!$state->{replace}) {
			if (!$state->{forced}->{installed}) {
				print "Can't install $pkgname because it's already installed\n";
				$state->{installed}->{$handle->{pkgname}} = 1;
				$errors++;
			}
			return undef;
d83 7
d104 2
a105 1
		if (!OpenBSD::Update::is_needed($plist, $state)) {
d112 1
a112 1
		print "Can't safely update to $pkgname\n";
d514 13
d530 1
a530 1
			if (!OpenBSD::Update::is_needed($plist, $state)) {
d600 36
d641 1
a641 15
	for my $pkgname (@@$old) {
		if (OpenBSD::PackageName::is_stem($pkgname)) {
			my @@l = OpenBSD::PackageName::findstem($pkgname,
			    installed_packages());
			if (@@l == 0) {
			    Fatal("Can't resolve $pkgname to an installed package name");
			} elsif (@@l == 1) {
				push(@@list, $l[0]);
			} else {
				Fatal("Ambiguous: $pkgname could be", join(',', @@l));
			}
		} else {
			push(@@list, $pkgname);
		}
	}
d648 1
a648 1
	my $hash = OpenBSD::PackageName::compile_stemlist(OpenBSD::PackageLocator::distant_available());
d663 1
a663 1
		my $plist = OpenBSD::PackingList->from_installation($pkgname, \&OpenBSD::PackingList::ExtraInfoOnly);
d667 1
d676 1
a676 1
			\&OpenBSD::PackingList::ExtraInfoOnly);
d682 3
d687 7
d697 5
a701 1
		print "Updating $pkgname -> ", join(' ', @@l2), "\n";
d709 7
a715 1
			push(@@$new, $l2[0]);
d717 1
a717 1
			push(@@cantupdate, $pkgname);
d723 22
d758 1
a758 1
set_usage('pkg_add [-acInqrvvx] [-A arch] [-B pkg-destdir] [-F keywords]',
d761 1
a761 1
our ($opt_a, $opt_v, $opt_n, $opt_I, $opt_L, $opt_B, $opt_A, $opt_P, $opt_Q, $opt_x, $opt_r, $opt_q, $opt_c, $opt_u);
d764 1
a764 1
	getopts('aqchuvnrxIL:f:F:B:A:P:Q:',
a788 1
$state->{replace} = $opt_r;
d827 1
a827 1
$state->{not} = $opt_n || $opt_u;
d835 1
d837 1
d855 3
a862 1
	my @@todo = ();
a863 1
	print "Update using pkg_add -r ", join(' ', @@todo), "\n";
d865 14
a878 1
		print "Cannot find updates for ",join(' ', @@cantupdate), "\n";
a879 1
	exit(0);
d882 2
a883 7
my @@todo = (@@ARGV);
if (defined $state->{forced}->{kitchensink}) {
	reorder(\@@todo);
	if (!$opt_r) {
		@@todo = grep {s/\.tgz$//; !is_installed($_);} @@todo;
	}
	print "Adding in order:\n", (map { "\t$_\n" } @@todo), "\n";
@


1.195
log
@Protect against more signals. Mark them as caught in a unified message.
During exit, just rethrow the signals, so that a wrapping process
can know what's going on.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.194 2005/08/22 11:37:23 espie Exp $
a637 1
		# XXX dirty as hell, clean-up after 3.8
d639 1
a639 25
		    my ($bestbase, $bestp, $best);
		    my ($base, $p);
		    for my $i (@@l2) {
			if ($i =~ m/p(\d+)$/) {
			    $base = $`;
			    $p = $1;
			} else {
			    $base = $i;
			    $p = -1;
			}
			if (!defined $bestbase) {
			    ($bestbase, $bestp, $best) = ($base, $p, $i);
			} else {
			    if ($base ne $bestbase) {
				undef $best;
				last;
			    }
			    if ($p > $bestp) {
			    	($bestp, $best) = ($p, $i);
			    }
			}
		    }
		    if (defined $best) {
		    	@@l2 = ($best);
		    }
@


1.194
log
@protect against $pkgname not being defined.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.193 2005/08/17 18:48:10 espie Exp $
d213 13
d281 2
a282 2
	local $SIG{'INT'} = sub {
		$interrupted = 1;
d284 5
d317 1
a317 3
			OpenBSD::Add::borked_installation($plist, $dir,
			    $state->{not},
			    "Installation of $pkgname failed");
d360 1
a360 3
			OpenBSD::Add::borked_installation($plist, $dir, 
			    $state->{not},
			    "Installation of $pkgname failed");
d406 1
a406 3
		OpenBSD::Add::borked_installation($plist, $dir, 
		    $state->{not},
		    "Installation of $pkgname failed");
d842 3
@


1.193
log
@better message when we can't resolve a stem, taken from pkg_delete.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.192 2005/08/17 18:24:52 espie Exp $
d163 2
a164 1
		if (OpenBSD::PackageName::url2pkgname($pkg) ne $pkgname) {
@


1.192
log
@clean-up, move the compute_closure code to RequiredBy, since it's
quite generic.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.191 2005/08/17 11:01:07 espie Exp $
d567 3
a569 1
			if (@@l == 1) {
@


1.191
log
@when looking for updates, select the best version: we know what to do
with p suffixes in a safe way.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.190 2005/08/17 10:45:13 espie Exp $
a557 22
sub compute_closure
{
	require OpenBSD::RequiredBy;

	my $old = shift;
	my @@todo;
	my %done;
	my %toupdate = map {($_, 1)} @@$old;
	push(@@todo, keys %toupdate);
	while (my $pkgname = pop @@todo) {
		next if $done{$pkgname};
		$done{$pkgname} = 1;
		for my $dep (OpenBSD::Requiring->new($pkgname)->list()) {
			next if defined $done{$dep};
			next if defined $toupdate{$dep};
			$toupdate{$dep} = 1;
			push(@@todo, $dep);
		}
	}
	return keys %toupdate;
}

d577 3
a579 1
		@@list = compute_closure(\@@list);
@


1.190
log
@if we can't read the packing-list, it's because it's a bad pkgname.
reported by niklas@@
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.189 2005/08/17 10:00:18 espie Exp $
d639 1
d641 31
@


1.189
log
@save architecture as well for ExtraInfo, so that pkg_add -u won't try
to add packages for the wrong architecture.

Noticed by Tim Kornau.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.188 2005/08/17 09:24:53 espie Exp $
d618 3
@


1.188
log
@restore $main::not that is needed by OpenBSD::RequiredBy,
put an # XXX comment so I won't be tempted to clean it again.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.187 2005/08/16 21:48:34 espie Exp $
d627 5
@


1.187
log
@big kludge that allows updating mozilla-thunderbird from 3.7 -> current.

okay pvalchev@@
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.186 2005/08/16 20:05:12 espie Exp $
a37 4
our %forced = ();

package main;

d40 2
d725 2
@


1.186
log
@make sure libs get registered if we take a shortcut and don't reinstall
the package, or if we call add_bogus_libs directly.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.185 2005/08/16 16:24:23 espie Exp $
d200 13
d308 4
@


1.185
log
@in case we're pretending to install, there's no borked package to create.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.184 2005/08/16 16:15:28 espie Exp $
d92 1
d474 1
@


1.184
log
@put a signature check way earlier, so that user doesn't get confused
seeing update messages for stuff that won't happen anyways.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.183 2005/08/16 13:52:15 espie Exp $
a203 1
	my $not = $state->{not};
d286 2
a287 1
			OpenBSD::Add::borked_installation($plist, $dir, 
d300 1
d328 1
d376 1
@


1.183
log
@In some cases, pkg_add -r will remove some extra packages while performing
replacement on dependencies.

When we finally reach the package that triggered the dependencies, the
package it's supposed to replace is no longer there, so do a quick
sanity check to only replace packages that have not already been replaced...
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.179 2005/08/14 09:06:53 espie Exp $
d90 6
@


1.182
log
@when you ask to update a package, you generally want to update its
dependencies as well...

so do the stem -> pkgname conversion early, and then compute the
closure of dependencies on the list of packages we asked for.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.181 2005/08/16 11:25:48 espie Exp $
d205 11
d217 1
a217 1
	if (@@{$plist->{replacing}}) {
d230 2
a231 2
	if (@@{$plist->{replacing}}) {
		$header.=" (replacing ". join(', ', (map {$_->pkgname()}@@{$plist->{replacing}})). ")";
d259 1
a259 1
		if (@@{$plist->{replacing}}) {
d285 1
a285 1
		for my $op (@@{$plist->{replacing}}) {
d390 1
a390 1
	for my $op (@@{$plist->{replacing}}) {
@


1.181
log
@use a hash for compiled stems, to avoid spurious duplicates.
adjust find_updatenames accordingly.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.180 2005/08/16 10:28:53 espie Exp $
d521 22
d546 1
a546 2
	my @@cantupdate = ();
	my $hash = OpenBSD::PackageName::compile_stemlist(OpenBSD::PackageLocator::distant_available());
a548 1
		my $stem = $pkgname;
d553 1
a553 1
				$pkgname = $l[0];
d555 1
a555 1
				Fatal("Ambiguous: $stem could be", join(',', @@l));
d558 1
a558 1
			$stem = OpenBSD::PackageName::splitstem($pkgname);
d560 9
d714 1
@


1.180
log
@add code that figures out the new package names after an update.
This is done very carefully, so that pkg_add -u only displays the
names to use, and so that it does not interfere with existing code.
-F pkgpath recommended for speed.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.179 2005/08/14 09:06:53 espie Exp $
d540 2
a541 2
		my $l = $hash->findstem($stem);
		if (!defined $l) {
d546 3
a548 3
		if (@@$l == 1 && $state->{forced}->{pkgpath}) {
			print "Directly updating $pkgname -> ", $l->[0], "\n";
			push(@@$new, $l->[0]);
d552 1
a552 1
		for my $candidate (@@$l) {
@


1.179
log
@zap extra line
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.178 2005/08/14 09:03:37 espie Exp $
a40 1
our $not;
d521 54
d591 1
a591 1
our ($opt_a, $opt_v, $opt_n, $opt_I, $opt_L, $opt_B, $opt_A, $opt_P, $opt_Q, $opt_x, $opt_r, $opt_q, $opt_c);
d594 1
a594 1
	getopts('aqchvnrxIL:f:F:B:A:P:Q:',
d658 1
a658 2
$state->{not} = $opt_n;
$not = $opt_n;
d666 1
a666 1
if (@@ARGV == 0) {
d681 14
a694 1
lock_db($opt_n);
@


1.178
log
@fix error recovery in replacing case.
- build the list of done items during extract only, since later all files
have a tempname.
- wrap pre-install in an exception handler, since there already is stuff to
save in a partial package...
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.177 2005/08/07 16:25:35 espie Exp $
a205 1
	$state->{replacing} = 0;
@


1.177
log
@split off the code that handles dependencies proper, so that we can (later)
reuse it in pkg_info or lib-depends-check.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.176 2005/07/24 11:50:03 espie Exp $
d207 1
d209 1
a209 1
		$state->{replacing} = 1;
d212 1
a212 1
		$state->{replacing} = 1;
d214 1
d245 1
a245 1
	if ($state->{replacing} == 1) {
d250 1
a250 1
		if (defined $plist->{replacing}) {
d301 8
a308 1
	do_script($plist, REQUIRE, $state, "INSTALL");
d310 8
a317 1
	do_script($plist, INSTALL, $state, "PRE-INSTALL");
a318 1
	$plist->{done} = [];
d329 3
a331 1
		push(@@{$plist->{done}}, $item);
@


1.176
log
@postpone decision whether to replace already installed packages in -r mode,
so that we get to execute is_needed and actually comparing full signatures.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.175 2005/06/29 22:54:31 espie Exp $
d23 1
a185 94
sub solve_dependencies
{
	my ($state, $handle, @@extra) = @@_;
	my $plist = $handle->{plist};
	my $verbose = $state->{verbose};
	my $to_register = $handle->{solved_dependencies} = {};
	my $to_install = {};
	for my $fullname (@@extra) {
		$to_install->{OpenBSD::PackageName::url2pkgname($fullname)} = 
		    $fullname;
	}

	# do simple old style pkgdep first
	my @@deps = ();
	for my $dep (@@{$plist->{pkgdep}}) {
		if (!is_installed($dep->{name})) {
			push(@@deps, $dep->{name});
		}
		$to_register->{$dep->{name}} = 1;
	}
	for my $dep (@@{$plist->{depend}}, @@{$plist->{newdepend}}, @@{$plist->{libdepend}}) {
	    next if defined $dep->{name} and $dep->{name} ne $plist->pkgname();

	    my @@candidates;
	    if ($state->{replace}) {
		# try against list of packages to install
		@@candidates = OpenBSD::PkgSpec::match($dep->{pattern}, keys %{$to_install});
		if (@@candidates >= 1) {
		    push(@@deps, $to_install->{$candidates[0]});
		    $to_register->{$candidates[0]} = 1;
		    next;
		}
	    }
	    @@candidates = OpenBSD::PkgSpec::match($dep->{pattern}, installed_packages());
	    if (@@candidates >= 1) {
		    $to_register->{$candidates[0]} = 1;
		    next;
	    }
	    if (!$state->{replace}) {
		# try against list of packages to install
		@@candidates = OpenBSD::PkgSpec::match($dep->{pattern}, keys %{$to_install});
		if (@@candidates >= 1) {
		    push(@@deps, $to_install->{$candidates[0]});
		    $to_register->{$candidates[0]} = 1;
		    next;
		}
	    }
	    # try with list of available packages
	    @@candidates = OpenBSD::PkgSpec::match($dep->{pattern}, OpenBSD::PackageLocator::available());
	    # one single choice
	    if (@@candidates == 1) {
		push(@@deps, $candidates[0]);
		$to_register->{$candidates[0]} = 1;
		next;
	    }
	    if (@@candidates > 1) {
		# grab default if available
		if (grep {$_ eq $dep->{def}} @@candidates) {
		    push(@@deps, $dep->{def});
		    $to_register->{$dep->{def}} = 1;
		    next;
		}
		push(@@deps, $candidates[0]);
		$to_register->{$candidates[0]} = 1;
	    }
	    # can't get a list of packages, assume default
	    # will be there.
	    push(@@deps, $dep->{def});
	    $to_register->{$dep->{def}} = 1;
	}

	if ($verbose && %$to_register) {
	    print "Dependencies for ", $plist->pkgname(), " resolve to: ", 
	    	join(', ', keys %$to_register);
	    print " (todo: ", join(',', @@deps), ")" if @@deps > 0;
	    print "\n";
	}
	return @@deps;
}

sub check_lib_spec
{
	my ($verbose, $base, $spec, $dependencies) = @@_;
	my @@r = OpenBSD::SharedLibs::lookup_libspec($base, $spec);
	for my $candidate (@@r) {
		if ($dependencies->{$candidate}) {
			print " found in $candidate\n" if $verbose;
			return 1;
		}
	}
	print " not found." if $verbose;
	return undef;
}

a399 90
sub find_old_lib
{
	my ($state, $base, $pattern, $lib, $dependencies) = @@_;

	$pattern = ".libs-".$pattern;
	for my $try (OpenBSD::PkgSpec::match($pattern, installed_packages())) {
		OpenBSD::SharedLibs::add_package_libs($try);
		if (check_lib_spec($state->{very_verbose},
		    $base, $lib, {$try => 1})) {
			Warn "Found library ", $lib, " in old package $try\n"
			    if $state->{verbose};
			$dependencies->{$try} = 1;
			return 1;
		}
	}
	return 0;
}

sub lookup_library
{
	my ($state, $lib, $plist, $dependencies, $harder, $done) = @@_;

	print "checking libspec $lib..." if $state->{very_verbose};
	if (check_lib_spec($state->{very_verbose},
	    $plist->pkgbase(), $lib, $dependencies)) {
	    return 1;
	}
	if ($harder && $lib !~ m|/|) {

		OpenBSD::SharedLibs::add_system_libs($state->{destdir});
		if (check_lib_spec($state->{very_verbose},
		    "/usr", $lib, {system => 1})) {
			return 1;
		}
		if (check_lib_spec($state->{very_verbose},
		    "/usr/X11R6", $lib, {system => 1})) {
			return 1;
		}
	}
	for my $dep (@@{$plist->{depends}}) {
		if (find_old_lib($state, $plist->pkgbase(), $dep->{pattern}, $lib, $dependencies)) {
			return 1;
		}
    	}
	if ($harder) {
		# lookup through the full tree...
		my @@todo = keys %$dependencies;
		while (my $dep = pop @@todo) {
			require OpenBSD::RequiredBy;

			next if $done->{$dep};
			$done->{$dep} = 1;
			for my $dep2 (OpenBSD::Requiring->new($dep)->list()) {
				push(@@todo, $dep2) unless $done->{$dep2};
			}
			next if $dependencies->{$dep};
			OpenBSD::SharedLibs::add_package_libs($dep);
			if (check_lib_spec($state->{very_verbose},
			    $plist->pkgbase(), $lib, {$dep => 1})) {
				Warn "Found library ", $lib, " in dependent package $dep\n" if $state->{verbose};
				$dependencies->{$dep} = 1;
				return 1;
			}
		}
	}
	if ($state->{forced}->{boguslibs}) {
		my $explored = {};
		# lookup through the full tree...
		my @@todo = keys %$dependencies;
		while (my $dep = pop @@todo) {
			require OpenBSD::RequiredBy;

			next if $explored->{$dep};
			$explored->{$dep} = 1;
			for my $dep2 (OpenBSD::Requiring->new($dep)->list()) {
				push(@@todo, $dep2) unless $done->{$dep2};
			}
			OpenBSD::SharedLibs::add_bogus_package_libs($dep);
			if (check_lib_spec($state->{very_verbose},
			    $plist->pkgbase(), $lib, {$dep => 1})) {
				Warn "Found unmarked library ", $lib, " in dependent package $dep\n" if $state->{verbose};
				$dependencies->{$dep} = 1;
				return 1;
			}
		}
	}
	print "\n" if $state->{very_verbose};
	return;
}

d454 1
a454 1
		my @@deps = solve_dependencies($state, $handle, @@todo);
d478 1
a478 1
		    if (!lookup_library($state, $spec, $plist,
d488 1
a488 1
		if (!lookup_library($state, $lib->{name}, $plist,
@


1.175
log
@stop if no pkgname.
from deraadt@@.

also lock_db later, since we can.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.174 2005/06/26 11:25:11 espie Exp $
d56 5
a60 4
		if ($state->{forced}->{installed}) {
			# deal with replacing later, not an error.
			if (!$state->{replace}) {
				return undef;
a61 4
		} else {
			print "Can't install $pkgname because it's already installed\n";
			$state->{installed}->{$handle->{pkgname}} = 1;
			$errors++;
d621 1
@


1.174
log
@handle fat packages based on architecture.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.173 2005/03/09 11:53:57 espie Exp $
d783 3
a785 1
lock_db($opt_n);
d798 1
@


1.173
log
@just clue() the first time a library is not found.
More clues are generally useless...
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.172 2005/03/09 11:46:07 espie Exp $
d132 1
a132 1
	my $handle = OpenBSD::PackageLocator->find($pkg);
@


1.172
log
@report all missing libraries (report is a bit verbose, but this will do).
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.171 2005/03/09 11:30:59 espie Exp $
d666 1
a666 1
			    clue($handle->{solved_dependencies});
d676 1
a676 1
			clue($extra);
@


1.171
log
@oops, since we don't register destdir along with libs, looking up with
destdir is doomed.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.170 2005/03/09 11:22:27 espie Exp $
d659 1
d667 1
a667 2
			    $handle->close();
			    return () unless $forced{libdepends};
d677 1
a677 2
			$handle->close();
			return () unless $forced{libdepends};
d679 4
@


1.170
log
@make sure lookup_libspec returns the same thing in -v -v mode.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.169 2005/02/07 15:35:23 espie Exp $
d504 1
a504 1
		    $state->{destdir}.$base, $lib, {$try => 1})) {
d520 1
a520 1
	    $state->{destdir}.$plist->pkgbase(), $lib, $dependencies)) {
d527 1
a527 1
		    $state->{destdir}."/usr", $lib, {system => 1})) {
d531 1
a531 1
		    $state->{destdir}."/usr/X11R6", $lib, {system => 1})) {
d554 1
a554 1
			    $state->{destdir}.$plist->pkgbase(), $lib, {$dep => 1})) {
d575 1
a575 1
			    $state->{destdir}.$plist->pkgbase(), $lib, {$dep => 1})) {
@


1.169
log
@make updatedepends slightly safer: note which packages may have bogus
dependencies, so that if you do one big pkg_add -r *, then you can check
which packages may have issues thanks to forced updates.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.168 2005/01/22 13:00:35 espie Exp $
d583 1
@


1.168
log
@do not clean-up shared items in pretend mode (for now, need extra logic
to pretend cleaning it up).
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.167 2005/01/14 02:25:12 espie Exp $
d384 3
d824 5
@


1.167
log
@`big lock' model: lock the whole db for reading/writing.
design checked with millert@@, relying on process termination for unlock
at his suggestion.

Perf optimization: don't try to reinstall installed packages in kitchensink
mode if !-r.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.166 2005/01/13 00:29:37 espie Exp $
d814 1
a814 1
	OpenBSD::SharedItems::cleanup($state);
@


1.166
log
@just mark it down when we can't install a package, instead of trying
later, so that we can erase some temp info.

Saves memory and time for -F kitchensink, mostly nop otherwise...
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.165 2005/01/03 01:02:45 espie Exp $
d776 1
d792 3
@


1.165
log
@rename -f -> -F
okay pvalchev@@, naddy@@, marco@@, deraadt@@

(keep -f around for the transition, will scrap it soon)
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.164 2004/12/28 14:50:38 espie Exp $
d63 1
d143 3
d177 3
@


1.164
log
@add a boguslibs forced option, that rescans packages for libraries
not marked with @@lib.

This allows pkg_add -current to deal with 3.6 packages fully.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.163 2004/12/28 13:54:13 espie Exp $
d690 1
a690 1
set_usage('pkg_add [-acInqrvvx] [-A arch] [-B pkg-destdir] [-f keys]',
d696 1
a696 1
	getopts('aqchvnrxIL:f:B:A:P:Q:',
d699 5
d756 1
@


1.163
log
@synchronize conflict lists when we add/remove anything.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.162 2004/12/27 23:56:48 espie Exp $
d546 21
@


1.162
log
@allow pkg_add -r to proceed even if there's more than one conflict.
Put an arbitrary threshold at 5 conflicts, so that a package that
conflicts with everything won't wipe everything out...

Take inter-dependencies into account while adjusting dependencies:
we can't adjust dependencies for stuff that is no longer there.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.161 2004/12/26 14:57:19 espie Exp $
d377 1
d445 1
a649 1
	OpenBSD::PkgCfl::register($plist, $state);
@


1.161
log
@be less verbose by default: no need to show the look-ups in dependent
and libs packages, since we do that all the time now and it works,
and since we have a good error message when it fails.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.160 2004/12/21 01:43:58 espie Exp $
d84 1
a84 1
	if (@@conflicts >= 2) {
d120 1
d457 4
@


1.160
log
@correct checks to allow for a package to replace several packages.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.159 2004/12/20 22:43:25 espie Exp $
d488 2
a489 1
			Warn "Found library ", $lib, " in old package $try\n";
d538 1
a538 1
				Warn "Found library ", $lib, " in dependent package $dep\n";
@


1.159
log
@allow a replacing package to replace several packages, in principle:
this is just a question of iterating over the replaced packages.

The fun part (can_install) still isn't done: wholesale replacements like
that mean the inter-dependencies between the replaced packages don't
count.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.158 2004/12/20 22:19:24 espie Exp $
d90 4
a93 3
	my $toreplace = $conflicts[0];
	if (defined $state->{installed}->{$toreplace}) {
		Warn "Cannot replace $toreplace with $pkgname: just got installed\n";
a96 1
	require OpenBSD::Update;
d104 3
a106 4
	my $rplist = OpenBSD::Update::can_do($conflicts[0], $pkgname, $state);
	if ($rplist) {
		if (!OpenBSD::Update::is_safe($plist, $state)) {
			print "Can't safely update $conflicts[0] to $pkgname\n";
d110 9
a118 1
		$rplist->{dir} = installed_info($conflicts[0]);
a119 5
		return 1;
	} else {
		print "Can't update $conflicts[0] into $pkgname\n";
		$errors++;
		return undef;
d121 1
@


1.158
log
@plug more handle leaks.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.156 2004/12/20 17:17:32 espie Exp $
d49 1
d112 1
a112 1
		$plist->{replacing} = $rplist;
d292 1
a292 1
	if (defined $plist->{replacing}) {
d304 2
a305 2
	if (defined $plist->{replacing}) {
		$header.=" (replacing ". $plist->{replacing}->pkgname(). ")";
d359 3
a361 3
		if (defined $plist->{replacing}) {
			OpenBSD::ProgressMeter::set_header($plist->{replacing}->pkgname()." (deleting)");
			$state->set_pkgname($plist->{replacing}->pkgname());
d364 1
a364 1
			    OpenBSD::Delete::delete_plist($plist->{replacing}, $state);
d369 1
a369 1
				    $plist->{replacing}->pkgname(), " failed");
d372 1
a372 1
			delete_installed($plist->{replacing}->pkgname());
d444 1
a444 1
	if (defined $plist->{replacing}) {
d447 1
d449 1
a449 1
		print "Adjusting dependencies for $pkgname\n" 
d452 1
a452 1
		for my $dep (@@{$plist->{replacing}->{wantlist}}) {
d455 1
a455 1
			OpenBSD::Update::adjust_dependency($dep, $plist->{replacing}->pkgname(), $pkgname);
@


1.157
log
@plug fd leak.
@
text
@d167 1
d621 1
d632 1
@


1.156
log
@remember to close what should be closed...
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.155 2004/12/20 12:56:19 espie Exp $
d605 1
@


1.155
log
@store pkgname in handle directly, so that we can delete the packing-list
itself when we're done: much lower memory footprint.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.154 2004/12/20 12:32:01 espie Exp $
d35 1
d569 1
d634 1
d741 1
a741 1
	print "Adding in order ", join(', ', @@todo), "\n";
d768 1
a768 1
	print "Added ", join(', ', sort keys %{$state->{installed}}), "\n";
@


1.154
log
@repair error message: set_pkgname so that we don't report for the last
package.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.153 2004/12/20 12:16:09 espie Exp $
d149 1
a149 1
	my $pkgname = $plist->pkgname();
d567 4
a583 3
	if (defined $state->{installed}->{$plist->pkgname()}) {
		return ();
	}
d632 2
a633 1
	$state->{installed}->{$plist->pkgname()} = 1;
@


1.153
log
@keep a hash of installed packages, so that we can refuse to replace a
package that just got installed.
Also allows us to give a full tally of what reorder did in kitchensink.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.152 2004/12/19 14:47:33 espie Exp $
d561 1
@


1.152
log
@simplify solve_dependencies: always compute to_install array (it is
reasonably cheap). Remove else conditions, use next: after all, it's
a simple pattern, try one solution after the other until one succeeds.
Pass state to access replace: in that case, first try the list of
packages to install/update so that we force them into proper order.

Add a mark to handles for finished packages: with -r, we can no longer rely
on installed packages to avoid doing the work twice.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.151 2004/12/19 14:09:53 espie Exp $
d88 6
d579 1
a579 1
	if (defined $handle->{finished}) {
d630 1
a630 1
	$handle->{finished} = 1;
d670 1
d735 1
d761 3
@


1.151
log
@move conflict code to PkgCfl.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.150 2004/12/18 14:40:27 espie Exp $
d170 1
a170 1
	my ($verbose, $handle, @@extra) = @@_;
d172 1
d174 5
a178 1
	my $to_install;
d190 12
a201 1
	    my @@candidates = OpenBSD::PkgSpec::match($dep->{pattern}, installed_packages());
d204 5
a208 9
	    } else {
	    	if (!defined $to_install) {
			$to_install = {};
			for my $fullname (@@extra) {
			    $to_install->{OpenBSD::PackageName::url2pkgname($fullname)} = $fullname;
			}
		}
	    	# try against list of packages to install
	    	my @@candidates = OpenBSD::PkgSpec::match($dep->{pattern}, keys %{$to_install});
d212 17
a228 23
		} else {
		    # try with list of packages
		    my @@candidates = OpenBSD::PkgSpec::match($dep->{pattern}, OpenBSD::PackageLocator::available());
		    # one single choice
		    if (@@candidates == 1) {
			push(@@deps, $candidates[0]);
			$to_register->{$candidates[0]} = 1;
		    } elsif (@@candidates > 1) {
			# grab default if available
		    	if (grep {$_ eq $dep->{def}} @@candidates) {
			    push(@@deps, $dep->{def});
			    $to_register->{$dep->{def}} = 1;
			# grab first one otherwise
			} else {
			    push(@@deps, $candidates[0]);
			    $to_register->{$candidates[0]} = 1;
			}
		    } else {
			# can't get a list of packages, assume default
			# will be there.
			push(@@deps, $dep->{def});
			$to_register->{$dep->{def}} = 1;
		    }
d230 2
d233 4
d573 3
d583 1
a583 1
		my @@deps = solve_dependencies($state->{verbose}, $handle, @@todo);
d624 1
@


1.150
log
@kitchensink mode will proceed if it can't find a dependent package...
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.149 2004/12/18 14:37:30 espie Exp $
a40 13
sub fill_conflict_lists
{
	my $state = shift;
	# first, find all possible potential conflicts
	for my $pkg (installed_packages()) {
		my $plist = OpenBSD::PackingList->from_installation($pkg, 
		    \&OpenBSD::PackingList::ConflictOnly);
		next unless defined $plist;
		$state->{conflict_list}->{$plist->pkgname()} = 
		    OpenBSD::PkgCfl->make_conflict_list($plist);
	}
}

a42 15
sub find_conflicts($$)
{
	my ($pkgname, $state) = @@_;
	my @@bad = ();
	if (is_installed $pkgname) {
		push(@@bad, $pkgname);
	}
	while (my ($name, $l) = each %{$state->{conflict_list}}) {
		next if $name eq $pkgname;
		if ($l->conflicts_with($pkgname)) {
			push(@@bad, $name);
		}
	}
	return @@bad;
}
d48 1
a48 5
	my $l = OpenBSD::PkgCfl->make_conflict_list($plist);
	$handle->{conflicts} = $l;

	my @@conflicts = find_conflicts($pkgname, $state);
	push(@@conflicts, $l->conflicts_with(installed_packages()));
d608 1
a608 1
	$state->{conflict_list}->{$plist->pkgname()} = $handle->{conflicts};
a687 1
$state->{conflict_list} = {};
a708 1
fill_conflict_lists($state);
@


1.149
log
@if we can't find a package, and it's there to solve a dependency,
say so.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.148 2004/12/18 13:34:36 espie Exp $
d157 3
a159 1
		$errors++;
@


1.148
log
@implement special `kitchensink' option for testers.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.147 2004/12/18 13:20:53 espie Exp $
d153 3
@


1.147
log
@basic code to handle legacy .libs-* packages: figure out what collisions
the new package actually has with old libs. If none is found, we can
proceed.

Prepare pkg_add to deal with it: switch into replacing mode as soon
as something fishy is going on.

Todo: code to actually delete replaced libraries.

Please note: if you don't play games such as going back to old packages
using replace, this code is enough.

If you update your whole system and remove old .libs-* package without
going back, this code isn't even needed...
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.146 2004/12/17 11:30:28 espie Exp $
d184 8
a191 2
	return undef unless can_install($plist, $state, $handle);
	return $handle;
d639 13
d739 3
@


1.146
log
@can postpone grabbing conflict keys.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.145 2004/12/16 11:38:27 espie Exp $
d98 18
a115 3
	@@conflicts = keys %conflicts;
	if (!$state->{replace} || @@conflicts >= 2) {
		print "Can't install $pkgname because of conflicts (",join(',', @@conflicts), ")\n";
d122 6
d291 1
d294 3
a296 2
	} else {
		$state->{replacing} = 0;
d328 1
a328 1
	if (defined $plist->{replacing}) {
d332 5
a336 1
		OpenBSD::Update::save_old_libraries($plist, $state);
d359 12
a370 11
		OpenBSD::ProgressMeter::set_header($plist->{replacing}->pkgname()." (deleting)");
		$state->set_pkgname($plist->{replacing}->pkgname());
		require OpenBSD::Delete;
		try {
		    OpenBSD::Delete::delete_plist($plist->{replacing}, $state);
		} catchall {
			Warn $_;
			OpenBSD::Add::borked_installation($plist, $dir, 
			    "Deinstallation of ", 
			    $plist->{replacing}->pkgname(), " failed");
		};
d372 3
a374 1
		delete_installed($plist->{replacing}->pkgname());
@


1.145
log
@if -f installed, don't treat reinstallation as errors.
if the package is installed, report it's there, don't give any conflict
message.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.144 2004/12/16 11:19:58 espie Exp $
a83 1
	@@conflicts = keys %conflicts;
d97 2
@


1.144
log
@save depend information into cache when package is installed.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.143 2004/12/16 11:07:33 espie Exp $
d86 12
@


1.143
log
@renamed borked_installation from borked.n to partial-<pkgname> ...
partial-<pkgname>.n if needed.

Make borked_installation take a message, to show installation/deinstallation
issues correctly.

Fix handling of ^C: this may lead some system calls to return early, thus
registering as errors: so always mark the last file as done, so that borked
installation will register it correctly.

Kill packing-list cache for anything but depends: we've got a global cache
of libraries now (use it in pkg_add).

Make almost everyone look at $main::not, so that we can call
register_installation
to_installation
RequirementList->add/delete
safely.

Simplify $not logic accordingly, do thing much more closely to what would
happen without -n.

This should allow pkg_add/pkg_delete -n to handle most nasty cases correctly
now, since all the relevant information is kept internally in a compact
format:
- register of shared libraries
- global register of conflicts
- cache of depends.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.142 2004/12/15 01:07:10 espie Exp $
d383 1
@


1.142
log
@move -n down into RequiredBy and PackingList (as $main::not, since we
don't want to load RequiredBy all the time).
Remove a few $state->{not} tests that are no longer needed.

pkg_add -n / pkg_delete -n should work much better when they need to
handle multiple dependencies.

(todo: kill plist caches, finish replacing with specialized caches like
libraries).
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.141 2004/12/13 21:28:08 espie Exp $
a305 1
			last if $errors;
d311 1
a311 1
			last if $interrupted;
d315 2
a316 5
			if ($not) {
				Fatal "Installation of $pkgname failed";
		    	} else {
				OpenBSD::Add::borked_installation($plist, $dir);
			}
d326 3
a328 6
			if ($not) {
				Fatal "Deinstallation of ", 
				    $plist->{replacing}->pkgname(), " failed";
		    	} else {
				OpenBSD::Add::borked_installation($plist, $dir);
			}
a349 1
			last;
d351 1
d379 2
a380 14
		if ($not) {
			Fatal "Installation of $pkgname failed";
		} else {
			OpenBSD::Add::borked_installation($plist, $dir);
		}
	}
	if ($not) {
		$plist->to_cache();
	} else {
		my $dest = installed_info($pkgname);
		OpenBSD::Add::register_installation($dir, $dest, $plist);
		if (!$state->{replace}) {
			$plist->forget();
		}
d382 3
@


1.141
log
@pull all the conflict checking code into one single function, makes
things much simpler...
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.140 2004/12/13 21:14:16 espie Exp $
d39 1
d400 3
a402 2
		if (defined $handle->{solved_dependencies}) {
			require OpenBSD::RequiredBy;
d404 1
a404 1
			my $r = OpenBSD::Requiring->new($pkgname);
d406 3
a408 4
			for my $dep (keys %{$handle->{solved_dependencies}}) {
				OpenBSD::RequiredBy->new($dep)->add($pkgname);
				$r->add($dep);
			}
d425 2
a426 2
			$d->add($dep) unless $state->{not};
			OpenBSD::Update::adjust_dependency($dep, $plist->{replacing}->pkgname(), $pkgname) unless $state->{not};
d670 1
@


1.140
log
@since we store dependencies we looked at, show them in the clue() message,
so that people can try to figure out why the library wasn't found.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.139 2004/12/13 18:29:51 espie Exp $
d71 1
a71 1
sub can_install($$)
d73 1
a73 1
	my ($plist, $state) = @@_;
d75 2
d78 3
a80 1
	my @@l = find_conflicts($pkgname, $state);
d82 5
a86 3
	return 1 if @@l == 0;
	if (!$state->{replace} || @@l >= 2) {
		print "Can't install $pkgname because of conflicts (",join(',', @@l), ")\n";
d93 1
a93 1
	my $rplist = OpenBSD::Update::can_do($l[0], $pkgname, $state);
d96 1
a96 1
			print "Can't safely update $l[0] to $pkgname\n";
d100 1
a100 1
		$rplist->{dir} = installed_info($l[0]);
d104 1
a104 1
		print "Can't update $l[0] into $pkgname\n";
d149 1
a149 14
	return undef unless can_install($plist, $state);
	my $avoid = '';
	if (defined $plist->{replacing}) {
		$avoid = $plist->{replacing}->pkgname();
	}
	# second handling of conflicts
	my $l = OpenBSD::PkgCfl->make_conflict_list($plist);
	$handle->{conflicts} = $l;
	if ($l->conflicts_with(grep {$_ ne $avoid} installed_packages())) {
		print "package $pkg has conflicts: ", 
		    join(' ', $l->conflicts_with(installed_packages())), "\n";
		$errors++;
		return undef unless $forced{conflicts};
	}
@


1.139
log
@avoid brutal exits from loop.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.138 2004/12/12 11:26:15 espie Exp $
d472 1
a472 1
	my ($state, $lib, $plist, $dependencies, $harder) = @@_;
a497 1
		my $done = {};
d522 3
d592 1
a592 1
			    clue();
d598 1
d600 1
a600 1
		    $handle->{solved_dependencies}, 1)) {
d602 1
a602 1
			clue();
@


1.138
log
@add somewhat more regular error catching code.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.137 2004/12/09 18:46:00 espie Exp $
a310 1
				last;
d312 1
@


1.137
log
@while upgrading, protect deletion in an eval: we've got an extract
package that should be registered as borked if something should go
wrong (which can happen if -f update, as I just witnessed with firefox).
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.136 2004/12/07 19:09:04 espie Exp $
d306 4
a309 3
			eval { $item->extract($state); };
			if ($@@) {
				Warn $@@;
d312 1
a312 1
			}
d332 1
a332 1
		eval {
d334 2
a335 3
		};
		if ($@@) {
			Warn $@@;
d342 1
a342 1
		}
d358 4
a361 3
		eval { $item->install($state); };
		if ($@@) {
			Warn $@@;
d364 1
a364 1
		}
d382 4
a385 3
		eval { do_script($plist, INSTALL, $state, "POST-INSTALL") };
		if ($@@) {
			Warn $@@;
d387 1
a387 1
		}
d540 1
a540 1
		Fatal "Fatal error" unless defined $handle;
d613 2
a614 1
eval { getopts('aqchvnrxIL:f:B:A:P:Q:',
d621 4
a624 6
	    	}}); };
if ($@@) {
	chomp($@@);
	$@@ =~ s/\s+at.*?$//;
	Usage($@@);
}
d626 1
d688 1
a688 1
		Fatal "$0 must be run as root";
d718 3
a720 2
if ($dielater) {
	print STDERR $dielater;
d722 1
a722 1
}
@


1.136
log
@wrap pkg_add usage.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.135 2004/12/07 12:19:34 espie Exp $
d331 13
a343 1
		OpenBSD::Delete::delete_plist($plist->{replacing}, $state);
@


1.135
log
@postpone check of conflicts until we have a packing-list.
this was an optimisation, but it doesn't make much sense:
not checking the packing-list first means we don't see some
errors in case of conflicts. And having the packing-list simplifies
the check-for-update operation.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.134 2004/12/06 21:55:01 espie Exp $
d594 2
a595 1
set_usage('pkg_add [-acInqrvvx] [-A arch] [-B pkg-destdir] [-f keys] [-L localbase] [-P type] [-Q quick-destdir] pkgname [...]');
@


1.134
log
@explicit clue() for people running 3.6 packages with current pkg_add.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.133 2004/12/06 12:35:36 espie Exp $
d73 2
a74 1
	my ($pkgname, $state) = @@_;
d87 10
a96 4
	my $plist = OpenBSD::Update::can_do($l[0], $pkgname, $state);
	if ($plist) {
		$plist->{dir} = installed_info($l[0]);
		return $plist;
a108 2
	my $pkgname1;
	my $toreplace;
a109 12
	if ($pkg ne '-') {
		if ($state->{verbose}) {
			if (defined $state->{deptree}->{$pkg}) {
			    print $state->{deptree}->{$pkg},":";
			}
			print "parsing $pkg\n";
		}
		$pkgname1 = OpenBSD::PackageName::url2pkgname($pkg);
		$toreplace = can_install($pkgname1, $state);
		return undef unless $toreplace;
	}

d130 2
a131 2
	if (defined $pkgname1) {
		if ($pkgname ne $pkgname1) {
d136 4
a139 6
	} else {
		if ($state->{verbose}) {
			if (defined $state->{deptree}->{$pkg}) {
			    print $state->{deptree}->{$pkg},":";
			}
			print "parsing $pkgname\n";
d141 1
a141 2
		$toreplace = can_install($pkgname, $state);
		return undef unless $toreplace;
d143 1
d145 2
a146 10
	if ($toreplace ne '1') {
		$plist->{replacing} = $toreplace;
		$avoid = $toreplace->pkgname();

		require OpenBSD::Update;

		if (!OpenBSD::Update::is_safe($plist, $state)) {
			print "Can't safely update $avoid to $pkgname\n";
			$errors++;
		}
@


1.133
log
@Usage
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.132 2004/12/02 00:04:38 espie Exp $
d524 7
d593 1
d602 1
@


1.132
log
@make sure we don't call Update::is_needed if we're not doing pkg_add -r.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.131 2004/11/27 16:38:26 espie Exp $
d602 2
d606 1
a606 1
getopts('aqcvnrxIL:f:B:A:P:Q:',
d608 1
d613 7
a619 1
	    	}});
d632 1
a632 1
	Fatal "-Q and -B are incompatible options";
d635 1
a635 1
	Fatal "-r and -Q are incompatible options";
d645 1
a645 1
	    Fatal "bad option: -P $opt_P";
d712 2
a713 1
	die $dielater;
@


1.131
log
@tweak very verbose output.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.130 2004/11/27 14:02:50 espie Exp $
d543 10
a552 3
	if (is_installed($plist->pkgname()) && !$state->{forced}->{installed} && !OpenBSD::Update::is_needed($plist, $state)) {
		$handle->close();
		return ();
@


1.130
log
@if the package is already installed, check whether updating it makes sense:
look at the context in which both packages were built. If dependencies differ,
then this is a sensible update.

While we're there, try harder to build a conflict list for .libs-* packages.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.129 2004/11/23 22:58:02 espie Exp $
a248 1
	print "checking libspec $spec..." if $verbose;
d256 1
a256 1
	print " not found\n" if $verbose;
d477 1
d499 6
a504 6
	return 0 unless $harder;
	# lookup through the full tree...
	my $done = {};
	my @@todo = keys %$dependencies;
	while (my $dep = pop @@todo) {
		require OpenBSD::RequiredBy;
d506 13
a518 12
		next if $done->{$dep};
		$done->{$dep} = 1;
		for my $dep2 (OpenBSD::Requiring->new($dep)->list()) {
			push(@@todo, $dep2) unless $done->{$dep2};
		}
		next if $dependencies->{$dep};
		OpenBSD::SharedLibs::add_package_libs($dep);
		if (check_lib_spec($state->{very_verbose},
		    $state->{destdir}.$plist->pkgbase(), $lib, {$dep => 1})) {
			Warn "Found library ", $lib, " in dependent package $dep\n";
			$dependencies->{$dep} = 1;
			return 1;
d521 1
@


1.129
log
@fix name of lib
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.128 2004/11/22 01:56:13 espie Exp $
d541 1
a541 1
	if (is_installed($plist->pkgname()) && !$state->{forced}->{installed}) {
@


1.128
log
@implement global repository for shared libraries.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.127 2004/11/21 15:44:55 espie Exp $
d576 1
a576 1
			    Warn "Can't install $pkg: lib not found spec\n";
@


1.127
log
@move the system libraries registration code to SharedLibs.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.126 2004/11/21 13:32:18 espie Exp $
d34 1
d248 7
a254 18
	my ($verbose, $base, $spec, $available) = @@_;
	my $dir;
	print "checking libspec $spec " if $verbose;
	if ($spec =~ m|(.*)/|) {
		$dir = "$base/$1";
		$spec = $';
	} else {
		$dir = "$base/lib";
	}
	if ($spec =~ m/^(.*)\.(\d+)\.(\d+)$/) {
		my ($libname, $major, $minor) = ($1, $2, $3);
		my $exists = $available->{"$dir/lib$libname.so.$major"};
		if ((defined $exists) && $exists->[0] >= $minor) {
			my ($m, $where) = @@$exists;
			print "found $dir/lib$libname.so.$major.$m in $where\n" if $verbose;
		} else {
			print "not found\n" if $verbose;
			return undef;
a255 3
	} else {
		print "bad spec\n" if $verbose;
		return undef;
d257 2
a258 1
	return 1;
d459 1
a459 1
	my ($state, $pattern, $lib, $global_avail, $dependencies) = @@_;
d463 1
a463 4
		my $plist = OpenBSD::PackingList->from_installation($try,
			\&OpenBSD::PackingList::LibraryOnly);
		my $available = {};
		$plist->visit('available_lib', $available, $try);
d465 1
a465 1
		    $state->{destdir}.$plist->pkgbase(), $lib, $available)) {
a466 1
			$plist->visit('available_lib', $global_avail, $try);
d476 1
a476 1
	my ($state, $lib, $available, $plist, $dependencies, $harder) = @@_;
d479 1
a479 1
	    $state->{destdir}.$plist->pkgbase(), $lib, $available)) {
a482 1
		require OpenBSD::SharedLibs;
d486 1
a486 1
		    $state->{destdir}."/usr", $lib, $OpenBSD::SharedLibs::registered_libs)) {
d490 1
a490 1
		    $state->{destdir}."/usr/X11R6", $lib, $OpenBSD::SharedLibs::registered_libs)) {
d495 1
a495 2
		if (find_old_lib($state, $dep->{pattern}, $lib, $available, 
		    $dependencies)) {
d512 1
a512 4
		my $plist = OpenBSD::PackingList->from_installation($dep,
			\&OpenBSD::PackingList::LibraryOnly);
		my $avail2 = {};
		$plist->visit('available_lib', $avail2, $dep);
d514 1
a514 1
		    $state->{destdir}.$plist->pkgbase(), $lib, $avail2)) {
a515 1
			$plist->visit('available_lib', $available, $dep);
a567 1
	my $available = {};
d569 1
a569 3
		my $plist = OpenBSD::PackingList->from_installation($dep, 
			\&OpenBSD::PackingList::LibraryOnly);
		$plist->visit('available_lib', $available, $dep);
d574 2
a575 2
		    if (!lookup_library($state, $spec, $available, 
			$plist, $handle->{solved_dependencies}, 0)) {
d582 2
a583 2
		if (!lookup_library($state, $lib->{name}, $available, 
		    $plist, $handle->{solved_dependencies}, 1)) {
@


1.126
log
@check_lib_specs -> check_lib_spec: check one spec at a time, and report on it.
Loop on libdepends now split lib specs by itself.
Better reports, slightly more efficient, clearer.

Use a local sub to factor out common code to deleting pkgspec and REQUIRING
file contents. Rephrase message to say `removing dependency ON'.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.125 2004/11/21 13:24:41 espie Exp $
a489 19
my $syst_avail;

sub add_system_libs
{
	my ($destdir, $avail) = @@_;
	for my $dirname ("/usr/lib", "/usr/X11R6/lib") {
		opendir(my $dir, $destdir.$dirname) or next;
		while (my $d = readdir($dir)) {
			next unless $d =~ m/^(.*\.so\.\d+)\.(\d+)$/;
			my ($stem, $minor) = ($1, $2);
			$stem = "$dirname/$stem";
			if (!defined $avail->{"$stem"} || $avail->{"$stem"}->[0] < $minor) {
				$avail->{"$stem"} = [$minor, 'system'];
			}
		}
		closedir($dir);
	}
}

d499 3
a501 4
		if (!defined $syst_avail) {
			$syst_avail = {};
			add_system_libs($state->{destdir}, $syst_avail);
		}
d503 1
a503 1
		    $state->{destdir}."/usr", $lib, $syst_avail)) {
d507 1
a507 1
		    $state->{destdir}."/usr/X11R6", $lib, $syst_avail)) {
a605 1
#	add_system_libs($state->{destdir}, $available);
@


1.125
log
@solved_dependencies becomes a hash, more efficient.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.124 2004/11/20 23:38:51 espie Exp $
d245 1
a245 1
sub check_lib_specs
d247 1
a247 1
	my ($verbose, $base, $specs, $available) = @@_;
d249 13
a261 5
	for my $spec (split(/,/, $specs)) {
		print "checking libspec $spec " if $verbose;
		if ($spec =~ m|(.*)/|) {
			$dir = "$base/$1";
			$spec = $';
d263 1
a263 14
			$dir = "$base/lib";
		}
		if ($spec =~ m/^(.*)\.(\d+)\.(\d+)$/) {
			my ($libname, $major, $minor) = ($1, $2, $3);
			my $exists = $available->{"$dir/lib$libname.so.$major"};
			if ((defined $exists) && $exists->[0] >= $minor) {
				my ($m, $where) = @@$exists;
				print "found $dir/lib$libname.so.$major.$m in $where\n" if $verbose;
			} else {
				print "not found\n" if $verbose;
				return undef;
			}
		} else {
			print "bad spec\n" if $verbose;
d266 3
d479 1
a479 1
		if (check_lib_specs($state->{very_verbose},
d496 1
a496 1
		opendir(my $dir, $destdir.$dirname);
d513 1
a513 1
	if (check_lib_specs($state->{very_verbose},
d522 1
a522 1
		if (check_lib_specs($state->{very_verbose},
d526 1
a526 1
		if (check_lib_specs($state->{very_verbose},
d554 1
a554 1
		if (check_lib_specs($state->{very_verbose},
d618 6
a623 4
		if (!lookup_library($state, $dep->{libspec}, $available, 
		    $plist, $handle->{solved_dependencies}, 0)) {
		    	Warn "Can't install $pkg: lib not found ", $dep->{libspec}, "\n";
			return () unless $forced{libdepends};
@


1.124
log
@opendir can use my variables.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.123 2004/11/18 21:48:02 espie Exp $
d181 1
a181 1
	my $to_register = $handle->{solved_dependencies} = [];
d190 1
a190 1
		push(@@$to_register, $dep->{name});
d196 1
a196 1
		    push(@@$to_register, $candidates[0]);
d208 1
a208 1
		    push(@@$to_register, $candidates[0]);
d215 1
a215 1
			push(@@$to_register, $candidates[0]);
d220 1
a220 1
			    push(@@$to_register, $dep->{def});
d224 1
a224 1
			    push(@@$to_register, $candidates[0]);
d230 1
a230 1
			push(@@$to_register, $dep->{def});
d236 1
a236 1
	if ($verbose && @@{$to_register} > 0) {
d238 1
a238 1
	    	join(',', @@$to_register);
d429 1
a429 1
			for my $dep (@@{$handle->{solved_dependencies}}) {
d485 1
a485 1
			push(@@$dependencies, $try);
d542 1
a542 2
	my %base_dependencies = map {($_, 1)} @@$dependencies;
	my @@todo = @@$dependencies;
d551 1
a551 1
		next if $base_dependencies{$dep};
d560 1
a560 1
			push(@@$dependencies, $dep);
d605 1
a605 1
	for my $dep (@@{$handle->{solved_dependencies}}) {
d613 1
a613 1
	for my $dep (@@{$handle->{solved_dependencies}}) {
@


1.123
log
@support depend (similar to libdepend and newdepend) and wantlib:
put lookup_library code in a separate routine, and add a `harder' mode
for wantlib, that will also look in system libraries, and in the full
tree of dependent packages.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.122 2004/11/14 19:25:45 espie Exp $
d497 3
a499 4
	for my $dir ("/usr/lib", "/usr/X11R6/lib") {
		local *DIR;
		opendir(DIR, $destdir.$dir);
		while (my $d = readdir(DIR)) {
d502 1
a502 1
			$stem = "$dir/$stem";
d507 1
a507 1
		closedir(DIR);
@


1.122
log
@stop storing @@pkdep into packing-lists, use separate REQUIRING file instead.

Cases where we need to tweak dependencies are well-delimited, and we simply
convert the old installed package to the new model in one step.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.121 2004/11/14 13:20:07 espie Exp $
d192 1
a192 1
	for my $dep (@@{$plist->{newdepend}}, @@{$plist->{libdepend}}) {
d260 3
a262 2
			if ((defined $exists) && $exists >= $minor) {
				print "found $dir/lib$libname.so.$major.$exists\n" if $verbose;
d473 1
a473 1
	my ($state, $dep, $global_avail, $dependencies) = @@_;
d475 1
a475 1
	my $pattern = ".libs-".$dep->{pattern};
d480 1
a480 1
		$plist->visit('available_lib', $available);
d482 3
a484 4
		    $state->{destdir}.$plist->pkgbase(), $dep->{libspec},
		    $available)) {
			Warn "Found libspec ", $dep->{libspec}, " in old package $try\n";
			$plist->visit('available_lib', $global_avail);
d492 77
d618 1
a618 1
		$plist->visit('available_lib', $available);
d622 12
a633 8
		if (!check_lib_specs($state->{very_verbose}, 
		    $state->{destdir}.$plist->pkgbase(), $dep->{libspec}, $available)) {
		    	# second chance
			if (!find_old_lib($state, $dep, $available, $handle->{solved_dependencies})) {
				Warn "Can't install $pkg: incorrect libspec: ",
				    $dep->{libspec}, "\n";
				return () unless $forced{libdepends};
			}
@


1.121
log
@allows for several -f options, since OpenBSD::Getopt makes this possible
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.120 2004/11/14 12:54:30 espie Exp $
d426 2
d430 1
a553 3
	}
	for my $dep (@@{$handle->{solved_dependencies}}) {
		OpenBSD::PackingElement::PkgDep->add($plist, $dep);
@


1.120
log
@cosmetic
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.119 2004/11/14 11:58:43 espie Exp $
d560 1
a560 1
our ($opt_a, $opt_v, $opt_n, $opt_I, $opt_f, $opt_L, $opt_B, $opt_A, $opt_P, $opt_Q, $opt_x, $opt_r, $opt_q, $opt_c);
d563 6
a568 4
	{'v' => sub {++$opt_v;} });
if ($opt_f) {
	%forced = map {($_, 1)} split(/,/, $opt_f);
}
@


1.119
log
@turn on progress meter by default, use -x to disable it.
document the new stuff, partial reorder of options.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.118 2004/11/13 15:00:48 espie Exp $
d306 1
a306 1
		$header.="(replacing ". $plist->{replacing}->pkgname(). ")";
@


1.118
log
@force update to replace existing packages.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.117 2004/11/13 13:55:02 espie Exp $
d620 1
a620 1
if ($opt_x && !$state->{beverbose}) {
@


1.117
log
@don't store things in cache if we know we're not going to use them again.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.116 2004/11/13 13:34:02 espie Exp $
d507 1
a507 1
	if (is_installed($plist->pkgname())) {
@


1.116
log
@pkg_add should have -c and -q since it may delete packages.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.115 2004/11/13 13:06:11 espie Exp $
d420 3
@


1.115
log
@look for libspecs in old packages that match the libdepend specification
as well.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.114 2004/11/13 12:49:58 espie Exp $
d557 1
a557 1
our ($opt_a, $opt_v, $opt_n, $opt_I, $opt_f, $opt_L, $opt_B, $opt_A, $opt_P, $opt_Q, $opt_x, $opt_r);
d559 1
a559 1
getopts('avnrxIL:f:B:A:P:Q:',
d610 2
@


1.114
log
@synchronize installed stuff, using the cache in -n mode so that -n
installations can proceed to the end...
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.113 2004/11/13 12:33:01 espie Exp $
d464 22
d541 6
a546 3
			Warn "Can't install $pkg: incorrect libspec: ",
			    $dep->{libspec}, "\n";
			return () unless $forced{libdepends};
@


1.113
log
@look for available registered libraries, not other stuff.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.112 2004/11/13 12:09:01 espie Exp $
d363 1
d415 3
a417 1
	if (!$not) {
@


1.112
log
@zap comment
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.111 2004/11/13 11:54:30 espie Exp $
d247 1
a247 1
	my ($verbose, $base, $specs) = @@_;
d259 4
a262 5
			my @@candidates = 
			    grep { /^lib\Q$libname\E\.so\.$major\.(\d+)$/ 
			    	&& $1 >= $minor } 
			    OpenBSD::Vstat::vreaddir($dir);
			if (@@candidates == 0) {
a264 2
			} else {
			    print "found ", $candidates[0], "\n" if $verbose;
d504 8
d515 1
a515 1
		    $state->{destdir}.$plist->pkgbase(), $dep->{libspec})) {
@


1.111
log
@fix logic error: while splitting libraries, copy cwd over, not move them...

use the same framework in pkg_add while extracting temp packages so that
we will be able to destroy them eventually.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.110 2004/11/13 10:47:21 espie Exp $
a507 1
		# can't check libspecs yet
@


1.110
log
@move borked_installation over to common routines, prepare it for
Update.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.109 2004/11/12 23:11:41 espie Exp $
d337 16
a352 3
		$state->{totsize} = $totsize;
		$state->{donesize} = 0;
		$plist->visit('extract_with_pm', $state);
d354 7
d401 1
a401 1
	if (!$interrupted) {
d410 4
a413 2
	if (!$not) {
		if ($interrupted || $errors) {
d416 2
@


1.109
log
@parse libspec better, With this, vreaddir can find libraries.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.108 2004/11/12 19:42:01 espie Exp $
a244 31
sub borked_installation
{
	my ($plist, $dir) = @@_;

	use OpenBSD::PackingElement;

	my $borked = borked_package();
	# fix packing list for pkg_delete
	$plist->{items} = $plist->{done};

	# last file may have not copied correctly
	my $last = $plist->{items}->[@@{$plist->{items}}-1];
	if ($last->IsFile()) {
	    require OpenBSD::md5;

	    my $old = $last->{md5};
	    $last->{md5} = OpenBSD::md5::fromfile($last->fullname());
	    if ($old ne $last->{md5}) {
		print "Adjusting md5 for ", $last->fullname(), " from ",
		    unpack('H*', $old), " to ", unpack('H*', $last->{md5}), "\n";
	    }
	}
	OpenBSD::PackingElement::Cwd->add($plist, '.');
	my $pkgname = $plist->pkgname();
	$plist->{name}->{name} = $borked;
	$plist->{pkgdep} = [];
	my $dest = installed_info($borked);
	OpenBSD::Add::register_installation($dir, $dest, $plist);
	Fatal "Installation of $pkgname failed, partial installation recorded as $borked";
}

d392 1
a392 1
			borked_installation($plist, $dir);
@


1.108
log
@don't store hexdigest internally.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.107 2004/11/12 00:04:34 espie Exp $
d282 2
a283 2
		if ($spec =~ m|.*/|) {
			$dir = "$base/$&";
@


1.107
log
@computed fullname.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.106 2004/11/11 12:45:15 espie Exp $
d264 1
a264 1
		    $old, " to ", $last->{md5}, "\n";
@


1.106
log
@symetry: updating a package means removing the old one and adding the new
one, tag unsafe operations accordingly...
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.105 2004/11/11 12:29:20 espie Exp $
d261 1
a261 1
	    $last->{md5} = OpenBSD::md5::fromfile($last->{fullname});
d263 1
a263 1
		print "Adjusting md5 for ", $last->{fullname}, " from ",
@


1.105
log
@store a ref to %forced in $state, for access anywhere.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.104 2004/11/11 12:17:25 espie Exp $
d85 1
a85 1
	my $plist = OpenBSD::Update::can_do($l[0], $pkgname, $state, \%forced);
d156 7
@


1.104
log
@File::Copy use moves as well.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.103 2004/11/11 12:13:57 espie Exp $
d541 2
@


1.103
log
@need to move collision_report over as well, and use PackageInfo routines.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.102 2004/11/11 11:36:26 espie Exp $
a33 1
use File::Copy;
@


1.102
log
@move some code from pkg_add to OpenBSD/Add.pm, for symetry with pkg_delete.

change prototype of validate_plist, ditch globals cdrom_only and ftp_only
(stash this into state).

Use Warn properly.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.101 2004/11/11 11:23:04 espie Exp $
d86 1
a86 1
	my $plist = OpenBSD::Update::can_do($l[0], $pkgname, $state);
a299 31
}

sub collision_report($)
{
	my $list = shift;
	my %todo = map {($_, 1)} @@$list;
	my $bypkg = {};
	

	for my $pkg (installed_packages()) {
		my $plist = OpenBSD::PackingList->from_installation($pkg, 
		    \&OpenBSD::PackingList::FilesOnly);
		for my $item (@@{$plist->{items}}) {
			next unless $item->IsFile();
			my $name = $item->fullname();
			if (defined $todo{$name}) {
				$bypkg->{$pkg} = [] unless defined $bypkg->{$pkg};
				push(@@{$bypkg->{$pkg}}, $name);
				delete $todo{$name};
			}
		}
	}
	print "Collision: the following files already exist\n";
	for my $pkg (sort keys %$bypkg) {
	    for my $item (sort @@{$bypkg->{$pkg}}) {
	    	print "\t$item ($pkg)\n";
	    }
	}
	for my $item (sort keys %todo) {
	    print "\t$item\n";
	}
@


1.101
log
@don't touch font directories if -n either...
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.100 2004/11/11 11:16:39 espie Exp $
a36 1
our ($ftp_only, $cdrom_only);
a238 10
sub register_installation
{
	my ($dir, $dest, $plist) = @@_;
	mkdir($dest);
	for my $i (info_names()) {
		copy($dir.$i, $dest);
	}
	$plist->to_installation();
}

d266 1
a266 1
	register_installation($dir, $dest, $plist);
a332 46
sub validate_plist($$)
{
	my ($plist, $destdir) = @@_;

	my $problems = 0;
	my $pkgname = $plist->pkgname();
	my $totsize = 0;

	my $extra = $plist->{extrainfo};
	if ($cdrom_only && ((!defined $extra) || $extra->{cdrom} ne 'yes')) {
	    Warn "Package $pkgname is not for cdrom.\n";
	    $problems++;
	}
	if ($ftp_only && ((!defined $extra) || $extra->{ftp} ne 'yes')) {
	    Warn "Package $pkgname is not for ftp.\n";
	    $problems++;
	}

	# check for collisions with existing stuff
	my $colliding = [];
	for my $item (@@{$plist->{items}}) {
		next unless $item->IsFile();
		my $fname = $destdir.$item->fullname();
		if (OpenBSD::Vstat::vexists($fname)) {
			push(@@$colliding, $fname);
			$problems++;
		}
		$totsize += $item->{size} if defined $item->{size};
		my $s = OpenBSD::Vstat::add($fname, $item->{size});
		next unless defined $s;
		if ($s->{ro}) {
			Warn "Error: ", $s->{mnt}, " is read-only ($fname)\n";
			$problems++;
		}
		if ($s->avail() < 0) {
			Warn "Error: ", $s->{mnt}, " is not large enough ($fname)\n";
			$problems++;
		}
	}
	if (@@$colliding > 0) {
		collision_report($colliding);
	}
	Fatal "fatal issues" if $problems;
	return $totsize;
}

a340 20
sub manpages_index
{
	my ($state) = @@_;
	return unless defined $state->{mandirs};
	my $destdir = $state->{destdir};
	require OpenBSD::Makewhatis;

	while (my ($k, $v) = each %{$state->{mandirs}}) {
		my @@l = map { $destdir.$_ } @@$v;
		if ($state->{not}) {
			print "Merging manpages in $destdir$k: ", join(@@l), "\n";
		} else {
			eval { OpenBSD::Makewhatis::merge($destdir.$k, \@@l); };
			if ($@@) {
				print STDERR "Error in makewhatis: $@@\n";
			}
		}
	}
}

d375 1
a375 1
	my $totsize = validate_plist($plist, $destdir);
d451 1
a451 1
		register_installation($dir, $dest, $plist);
a563 11
if ($opt_P) {
	if ($opt_P eq 'cdrom') {
		$cdrom_only = 1;
	}
	elsif ($opt_P eq 'ftp') { 
		$ftp_only = 1;
	}
	else {
	    Fatal "bad option: -P $opt_P";
	}
}
d579 11
d619 1
a619 1
		print "$0 should be run as root\n";
d637 1
a637 1
manpages_index($state);
@


1.100
log
@introduce shortcuts to read/write contents from_installation/to_installation

use these to simplify all those packing lists manipulations.

demote non-root detection to a warning in -n mode:
fix a couple of minor bugs, of stuff that was run in -n mode and should not.
Namely, manpages were indexed/unindexed (ouch) and tempfiles were creating
during updates.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.99 2004/11/11 10:47:26 espie Exp $
d713 1
a713 1
OpenBSD::PackingElement::Fontdir::finish_fontdirs();
@


1.99
log
@fix interaction of -n -v -r.
don't enable the progress meter if a very verbose mode is on.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.98 2004/11/09 11:02:42 espie Exp $
d46 1
a46 2
		my $dir = installed_info($pkg);
		my $plist = OpenBSD::PackingList->fromfile($dir.CONTENTS, 
d247 1
a247 1
	$plist->tofile($dest.CONTENTS);
d321 2
a322 1
		my $plist = OpenBSD::PackingList->fromfile(installed_info($pkg).CONTENTS, \&OpenBSD::PackingList::FilesOnly);
d407 7
a413 3
		eval { OpenBSD::Makewhatis::merge($destdir.$k, \@@l); };
		if ($@@) {
			print STDERR "Error in makewhatis: $@@\n";
a681 3
if ($< && !$forced{nonroot}) {
	Fatal "$0 must be run as root";
}
d692 8
@


1.98
log
@alternate between package names correctly when replacing a package.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.97 2004/11/09 10:17:51 espie Exp $
d542 2
d546 3
a548 2
			$d->add($dep);
			OpenBSD::Update::adjust_dependency($dep, $plist->{replacing}->pkgname(), $pkgname);
a647 4
if ($opt_x) {
	OpenBSD::ProgressMeter::enable();
}

d688 4
@


1.97
log
@save dir in plist, not state (unconfuse script operations when several
plists are present).

Encapsulate `extract' operation in `extract_with_pm' to allow progress meter
to do something sensible when replacing packages.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.96 2004/11/09 09:32:17 espie Exp $
d472 1
d477 1
@


1.96
log
@remove code we don't use.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.95 2004/11/07 12:19:20 espie Exp $
d90 1
d393 1
d424 1
a424 1
	$state->{dir} = $dir;
d464 1
d466 6
a471 2
		$plist->visit('extract', $state);
		
d474 2
@


1.95
log
@shared libraries, preliminary work, a simpler scheme:
compare replaced package with replacing package, mark all changed shared
libraries.
split_old_libs knows how to cobble a new plist off the old one with the
shared libraries.
print_depends_closure knows how to walk the RequiredBy objects to build
a complete list of packages that may depend upon those libraries.

Todo: actually split off the libraries, write a COMMENT/CONTENTS files too,
and register all those dependencies.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.94 2004/11/06 12:19:16 espie Exp $
a157 3
#		if (!OpenBSD::Update::verify_libs($plist, $state)) {
#			return undef;
#		}
@


1.94
log
@mark whole state for `replacing' so that only file entries get tempname
markers. Explain about tempname to PackingElement, so that we become
able to save temporary packing-lists (e.g, borking during replace will
now work).
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.93 2004/11/02 23:53:20 espie Exp $
d158 3
a160 3
		if (!OpenBSD::Update::verify_libs($plist, $state)) {
			return undef;
		}
d465 1
@


1.93
log
@logic error: match library version of *new* plist against existing packages.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.92 2004/11/01 19:48:58 espie Exp $
d427 5
@


1.92
log
@adjust dependencies
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.91 2004/11/01 19:21:58 espie Exp $
d158 3
@


1.91
log
@pkg_add may need to clean up shared items now that it can delete old stuff.
let very verbose mode show moving files around.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.90 2004/11/01 19:14:26 espie Exp $
d519 11
@


1.90
log
@allows Delete to remove a plist (assuming it's already been validated).
let pkg_add -r compute a replaced package and store its plist in the new
package plist, so that replacement has a chance to proceed.

Not finished yet. Missing:
- real lib depends checks;
- restoring package dependencies after replacement.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.89 2004/11/01 14:30:00 espie Exp $
d676 7
@


1.89
log
@handle the case of symlinks.
Let pkg_add -r do extraction first, and finish installation later.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.88 2004/11/01 11:27:50 espie Exp $
d88 3
a90 3
	my $toreplace = $l[0];
	if (OpenBSD::Update::can_do($toreplace, $pkgname, $state)) {
		print "Will be able to update $toreplace once we're done\n";
d92 3
a94 1
		print "Can't update $toreplace into $pkgname\n";
a95 2
	$errors++;
	return undef;
d104 1
a106 1
		my $more = "";
d114 2
a115 1
		return undef unless can_install($pkgname1, $state);
d151 7
a157 1
		return undef unless can_install($pkgname, $state);
d162 1
a162 1
	if ($l->conflicts_with(installed_packages())) {
d430 3
d454 1
a454 1
	if ($state->{replace}) {
d458 3
@


1.88
log
@reorg pkg_add slightly, put all options into state so that we don't need
to use local variables.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.87 2004/10/31 12:40:00 espie Exp $
d443 6
@


1.87
log
@fix logic error: we will be able to fully validate the new packing-list
in pkg_add -r mode, it's just a question of removing the old package
from the virtual filesystem early, so that we can still check for collisions.

Help getting OpenBSD::Delete self-contained while we're there...
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.86 2004/10/31 11:33:50 espie Exp $
d33 1
a38 331
# used by newuser/newgroup to deal with options.
sub add_entry
{
	my ($l, $f, $v) = @@_;
	return if !defined $v or $v eq '';
	if ($v =~ m/^\!/) {
		push(@@$l, $f, $');
	} else {
		push(@@$l, $f, $v);
	}
}

package OpenBSD::PackingElement;
use OpenBSD::Error;

my ($uidcache, $gidcache);

sub install
{
}

sub set_modes
{
	my ($self, $name) = @@_;

	if (defined $self->{owner} || defined $self->{group}) {
		require OpenBSD::IdCache;

		if (!defined $uidcache) {
			$uidcache = OpenBSD::UidCache->new();
			$gidcache = OpenBSD::GidCache->new();
		}
		my ($uid, $gid) = (stat $name)[4,5];
		if (defined $self->{owner}) {
			$uid = $uidcache->lookup($self->{owner}, $uid);
		}
		if (defined $self->{group}) {
			$gid = $gidcache->lookup($self->{group}, $gid);
		}
		chown $uid, $gid, $name;
	}
	if (defined $self->{mode}) {
		my $v = $self->{mode};
		if ($v =~ m/^\d+$/) {
			chmod oct($v), $name;
		} else {
			System('chmod', $self->{mode}, $name);
		}
	}
}

package OpenBSD::PackingElement::NewUser;
use OpenBSD::Error;

sub install
{
	my ($self, $state) = @@_;
	my $user = $self->{name};
	print "adding user $user\n" if $state->{verbose};
	return if $state->{not};
	my $ok = $self->check();
	if (defined $ok) {
		if ($ok == 0) {
			Fatal "user $user does not match\n";
		}
	} else {
		my $l=[];
		push(@@$l, "-v") if $state->{very_verbose};
		main::add_entry($l, '-u', $self->{uid});
		main::add_entry($l, '-g', $self->{group});
		main::add_entry($l, '-L', $self->{class});
		main::add_entry($l, '-c', $self->{comment});
		main::add_entry($l, '-d', $self->{home});
		main::add_entry($l, '-s', $self->{shell});
		VSystem($state->{very_verbose}, '/usr/sbin/useradd', @@$l, $user);
	}
}

package OpenBSD::PackingElement::NewGroup;
use OpenBSD::Error;

sub install
{
	my ($self, $state) = @@_;
	my $group = $self->{name};
	print "adding group $group\n" if $state->{verbose};
	return if $state->{not};
	my $ok = $self->check();
	if (defined $ok) {
		if ($ok == 0) {
			Fatal "group $group does not match\n";
		}
	} else {
		my $l=[];
		push(@@$l, "-v") if $state->{very_verbose};
		main::add_entry($l, '-g', $self->{gid});
		VSystem($state->{very_verbose}, '/usr/sbin/groupadd', @@$l, $group);
	}
}

package OpenBSD::PackingElement::Sysctl;
use OpenBSD::Error;

sub install
{
	my ($self, $state) = @@_;

	my $name = $self->{name};
	open(my $pipe, '-|', '/sbin/sysctl', $name);
	my $actual = <$pipe>;
	chomp $actual;
	$actual =~ s/^\Q$name\E\s*\=\s*//;
	if ($self->{mode} eq '=' && $actual eq $self->{value}) {
		return;
	}
	if ($self->{mode} eq '>=' && $actual >= $self->{value}) {
		return;
	}
	if ($state->{not}) {
		print "sysctl -w $name != ".
		    $self->{value}, "\n";
		return;
	}
	VSystem($state->{very_verbose}, '/sbin/sysctl', $name.'='.$self->{value});
}
			
package OpenBSD::PackingElement::FileBase;
use OpenBSD::Error;
use File::Basename;
use File::Path;

sub install
{
	my ($self, $state) = @@_;
	my $fullname = $self->fullname();

	my $file=$state->{archive}->next();
	if ($file->{name} ne $self->{name}) {
		Fatal "Error: archive does not match", $file->{name}, "!=",
		$self->{name}, "\n";
	}
	my $destdir = $state->{destdir};

	print "extracting $destdir$fullname\n" if $state->{very_verbose};
	return if $state->{not};
	$file->{name} = $fullname;
	$file->{cwd} = $self->{cwd};
	$file->{destdir} = $destdir;
	# faked installation are VERY weird
	if (defined $self->{symlink} && $state->{do_faked}) {
		$file->{linkname} = $destdir.$file->{linkname};
	}
	$file->create();
	$self->set_modes($destdir.$fullname);
}

package OpenBSD::PackingElement::EndFake;
sub install
{
	my ($self, $state) = @@_;

	$state->{end_faked} = 1;
}

package OpenBSD::PackingElement::Sample;
use OpenBSD::Error;
use File::Copy;

sub install
{
	my ($self, $state) = @@_;

	my $destdir = $state->{destdir};
	my $filename = $destdir.$self->fullname();
	my $orig = $self->{copyfrom};
	if (!defined $orig) {
		Fatal "\@@sample element does not reference a valid file\n";
	}
	my $origname = $destdir.$orig->fullname();
	if (-e $filename) {
		if ($state->{verbose}) {
		    print "The existing file $filename has NOT been changed\n";
		    if (defined $orig->{md5}) {
			require OpenBSD::md5;

			my $md5 = OpenBSD::md5::fromfile($filename);
			if ($md5 eq $orig->{md5}) {
			    print "(but it seems to match the sample file $origname)\n";
			} else {
			    print "It does NOT match the sample file $origname\n";
			    print "You may wish to update it manually\n";
			}
		    }
		}
	} else {
		if ($state->{not}) {
			print "The file $filename would be installed from $origname\n";
		} else {
			if (!copy($origname, $filename)) {
				Warn "File $filename could not be installed:\n\t$!\n";
			}
			$self->set_modes($filename);
			if ($state->{verbose}) {
			    print "installed $filename from $origname\n";
			}
		}
	}
}

package OpenBSD::PackingElement::Sampledir;

sub install
{
	&OpenBSD::PackingElement::Dir::install;
}

package OpenBSD::PackingElement::Mandir;

sub install
{
	my ($self, $state) = @@_;
	$self->SUPER::install($state);
	$state->print("You may wish to add ", $self->fullname(), " to /etc/man.conf\n");
}

package OpenBSD::PackingElement::Manpage;

sub install
{
	my ($self, $state) = @@_;
	$self->SUPER::install($state);
	$self->register_manpage($state) unless $state->{not};
}

package OpenBSD::PackingElement::InfoFile;
use File::Basename;
use OpenBSD::Error;

sub install
{
	my ($self, $state) = @@_;
	$self->SUPER::install($state);
	return if $state->{not};
	my $fullname = $state->{destdir}.$self->fullname();
	VSystem($state->{very_verbose}, 
	    "install-info", "--info-dir=".dirname($fullname), $fullname);
}

package OpenBSD::PackingElement::Shell;
sub install
{
	my ($self, $state) = @@_;
	$self->SUPER::install($state);
	return if $state->{not};
	my $fullname = $self->fullname();
	my $destdir = $state->{destdir};
	# go append to /etc/shells if needed
	open(my $shells, '<', $destdir.'/etc/shells') or return;
	local $_;
	while(<$shells>) {
		s/^\#.*//;
		return if $_ =~ m/^\Q$fullname\E\s*$/;
	}
	close($shells);
	open(my $shells2, '>>', $destdir.'/etc/shells') or return;
	print $shells2 $fullname, "\n";
	close $shells2;
	print "Shell $fullname appended to $destdir/etc/shells\n";
}

package OpenBSD::PackingElement::Dir;
sub install
{
	my ($self, $state) = @@_;
	my $fullname = $self->fullname();
	my $destdir = $state->{destdir};

	print "new directory ", $destdir, $fullname, "\n" if $state->{very_verbose};
	return if $state->{not};
	File::Path::mkpath($destdir.$fullname);
	$self->set_modes($destdir.$fullname);
}

package OpenBSD::PackingElement::Exec;
use OpenBSD::Error;

sub install
{
	my ($self, $state) = @@_;

	$self->run($state);
}

package OpenBSD::PackingElement::Lib;

sub install
{
	my ($self, $state) = @@_;
	$self->SUPER::install($state);
	return if $state->{do_faked};
	$self->mark_ldconfig_directory($state->{destdir});
}

package OpenBSD::PackingElement::Arch;

sub check
{
	my ($self, $forced_arch) = @@_;

	my ($machine_arch, $arch);
	for my $ok (@@{$self->{arches}}) {
		return 1 if $ok eq '*';
		if (defined $forced_arch) {
			if ($ok eq $forced_arch) {
				return 1;
			} else {
				next;
			}
		}
		if (!defined $machine_arch) {
			chomp($machine_arch = `/usr/bin/arch -s`);
		}
		return 1 if $ok eq $machine_arch;
		if (!defined $arch) {
			chomp($arch = `/usr/bin/uname -m`);
		}
		return 1 if $ok eq $arch;
	}
	return undef;
}

d57 1
a57 61
our ($opt_a, $opt_v, $opt_n, $opt_I, $opt_f, $opt_L, $opt_B, $opt_A, $opt_P, $opt_Q, $opt_x, $opt_r);
$opt_v = 0;
getopts('avnrxIL:f:B:A:P:Q:',
	{'v' => sub {++$opt_v;} });
if ($opt_f) {
	%forced = map {($_, 1)} split(/,/, $opt_f);
}
if ($opt_P) {
	if ($opt_P eq 'cdrom') {
		$cdrom_only = 1;
	}
	elsif ($opt_P eq 'ftp') { 
		$ftp_only = 1;
	}
	else {
	    Fatal "bad option: -P $opt_P";
	}
}
if ($opt_x) {
	OpenBSD::ProgressMeter::enable();
}

$opt_L = '/usr/local' unless defined $opt_L;

my $state = new OpenBSD::Error;
$state->{cache} = {};
$state->{deptree} = {};
$state->{do_faked} = 0;
$state->{replace} = $opt_r;
if (defined $opt_Q and defined $opt_B) {
	Fatal "-Q and -B are incompatible options";
}
if (defined $opt_Q) {
	$state->{destdir} = $opt_Q;
	$state->{do_faked} = 1;
} elsif (defined $opt_B) {
	$state->{destdir} = $opt_B;
} elsif (defined $ENV{'PKG_PREFIX'}) {
	$state->{destdir} = $ENV{'PKG_PREFIX'};
}
if (defined $state->{destdir}) {
	$state->{destdir}.='/';
	$ENV{'PKG_DESTDIR'} = $state->{destdir};
} else {
	$state->{destdir} = '';
}

if ($< && !$forced{nonroot}) {
	Fatal "$0 must be run as root";
}

$state->{conflict_list} = {};
$state->{not} = $opt_n;
$state->{dont_run_scripts} = $opt_I;
$state->{very_verbose} = $opt_v >= 2;
$state->{verbose} = $opt_v;
$state->{beverbose} = $opt_n || ($opt_v >= 2);

fill_conflict_lists($state);

sub find_conflicts
d59 1
a59 1
	my $pkgname = shift;
d77 1
a77 1
	my @@l = find_conflicts($pkgname);
d131 2
a132 2
	if ($plist->pkgbase() ne $opt_L) {
		print "Localbase mismatch: package has: ", $plist->pkgbase(), " , user wants: $opt_L\n";
d542 1
a542 1
		unless ($plist->{arch}->check($opt_A)) {
d580 64
@


1.86
log
@Simplify ldconfig handling: one single ensure_ldconfig routine that
reruns ldconfig -R (okay, we don't check that -m would be enough, so what ?)

First hooks for -r: check that replacement should work.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.84 2004/10/20 11:38:57 espie Exp $
d479 1
a479 1
	if (OpenBSD::Update::can_do($toreplace, $pkgname)) {
d726 1
a726 1
sub validate_plist($$$)
d728 1
a728 1
	my ($plist, $destdir, $replace) = @@_;
d749 1
a749 1
		if (OpenBSD::Vstat::vexists($fname) && !$replace) {
d821 1
a821 1
	my $totsize = validate_plist($plist, $destdir, $state->{replace});
@


1.85
log
@Erase old code
@
text
@a37 12
sub ensure_ldconfig
{
	my $state = shift;
	return if $state->{not};
	return if $state->{do_faked};
	return unless defined $OpenBSD::PackingElement::Lib::todo;
	VSystem($state->{very_verbose}, 
	    @@OpenBSD::PackingElement::Lib::ldconfig, "-m", 
	    keys %$OpenBSD::PackingElement::Lib::todo);
	undef $OpenBSD::PackingElement::Lib::todo;
}

d387 1
a387 1
our ($opt_a, $opt_v, $opt_n, $opt_I, $opt_f, $opt_L, $opt_B, $opt_A, $opt_P, $opt_Q, $opt_x);
d389 1
a389 1
getopts('avnxIL:f:B:A:P:Q:',
d415 1
d447 1
a447 1
sub can_install($$)
d449 2
a450 2
	my ($pkgname, $state) = @@_;

d452 1
a452 2
		print "package $pkgname is already installed\n";
		return undef unless $forced{installed};
a453 1

d455 1
d457 1
a457 3
			print "package $pkgname conflicts with installed package $name\n";
			$errors++;
			return undef unless $forced{conflicts};
d460 2
d463 23
a485 1
	return 1;
d726 1
a726 1
sub validate_plist($$)
d728 1
a728 1
	my ($plist, $destdir) = @@_;
d749 1
a749 1
		if (OpenBSD::Vstat::vexists($fname)) {
d821 1
a821 1
	my $totsize = validate_plist($plist, $destdir);
d982 1
a982 1
ensure_ldconfig($state);
@


1.84
log
@basic framework for delayed messages.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.83 2004/10/19 10:21:49 espie Exp $
a975 5
}
if (defined $state->{display}) {
	close $state->{display};
	my $pager = $ENV{'PAGER'} || "/usr/bin/more";
	System("$pager ".$state->{displayname});
@


1.83
log
@need to prepend destdir to pkgbase for libspecs checking.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.82 2004/10/18 12:03:19 espie Exp $
d272 1
a272 1
	print "You may wish to add ", $self->fullname(), " to /etc/man.conf\n";
d423 1
a423 1
my $state = {};
d796 1
a796 1
	$state->{pkgname} = $pkgname;
d982 1
@


1.82
log
@experimental progress meter.
not active unless you specify -x for pkg_add/pkg_delete.
(option is bound to change)
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.81 2004/10/18 11:12:21 espie Exp $
d946 1
a946 1
		    $plist->pkgbase(), $dep->{libspec})) {
@


1.81
log
@Don't show libspec checking unless very verbose.
Split addition into `parsing' and actual addition.
Don't show parsing info unless verbose, so that pkg_add only
displays the actual pkg addition...
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.80 2004/10/18 10:51:03 espie Exp $
d32 1
d399 1
a399 1
our ($opt_a, $opt_v, $opt_n, $opt_I, $opt_f, $opt_L, $opt_B, $opt_A, $opt_P, $opt_Q);
d401 1
a401 1
getopts('avnIL:f:B:A:P:Q:',
d417 3
d722 1
d743 1
d759 1
d798 2
d801 1
a801 1
	    print $state->{deptree}->{$pkgname},":";
d803 7
a809 4
	print $state->{not} ? "Pretending to add " : "Adding ";
	print $pkgname;
	if ($state->{do_faked}) {
		print " under ", $state->{destdir};
d811 1
a811 2
	print "\n";
	validate_plist($plist, $destdir) unless $state->{do_faked};
d829 1
d839 5
d852 1
@


1.80
log
@use OpenBSD::Getopt so that we can do -v -v.
Be much terser by default, start showing dependency information and
various things only with at least one -v.

Build a `flattened tree' of dependencies information in pkg_add, and
show why we install a given package (idea from deraadt@@).
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.79 2004/10/18 09:38:35 espie Exp $
a479 4
	my $operation = $state->{not} ? "Pretending to add" : "Adding";
	if (defined $state->{deptree}->{$pkg}) {
		$operation = $state->{deptree}->{$pkg}.":$operation";
	}
d483 5
a487 2
		if ($state->{do_faked}) {
			$more = " under ".$state->{destdir};
a488 2

		print "$operation $pkg$more\n";
d520 5
a524 3
		my $modifier = "";
		if ($state->{do_faked}) {
			$modifier = " under ".$state->{destdir};
a525 2
			
		print "$operation $pkgname$modifier\n";
d652 1
a652 1
	my $base = shift;
d654 2
a655 2
	for my $spec (split(/,/, shift)) {
		print "checking libspec $spec " if $opt_v;
d669 1
a669 1
				print "not found\n" if $opt_v;
d672 1
a672 1
			    print "found ", $candidates[0], "\n" if $opt_v;
d675 1
a675 1
			print "bad spec\n" if $opt_v;
d791 9
d927 2
a928 1
		if (!check_lib_specs($plist->pkgbase(), $dep->{libspec})) {
@


1.79
log
@fix report of final problems
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.78 2004/10/17 09:32:21 espie Exp $
d30 1
a30 1
use Getopt::Std;
d43 1
a43 1
	VSystem($state->{verbose}, 
d116 1
a116 1
		push(@@$l, "-v") if $state->{verbose};
d123 1
a123 1
		VSystem($state->{verbose}, '/usr/sbin/useradd', @@$l, $user);
d143 1
a143 1
		push(@@$l, "-v") if $state->{verbose};
d145 1
a145 1
		VSystem($state->{verbose}, '/usr/sbin/groupadd', @@$l, $group);
d172 1
a172 1
	VSystem($state->{verbose}, '/sbin/sysctl', $name.'='.$self->{value});
d192 1
a192 1
	print "extracting $destdir$fullname\n" if $state->{verbose};
d229 3
a231 2
		print "The existing file $filename has NOT been changed\n";
		if (defined $orig->{md5}) {
d236 1
a236 1
				print "\t(but it seems to match the sample file $origname)\n";
d238 2
a239 2
				print "\tIt does not match the sample file $origname\n";
				print "You may wish to update it manually\n";
d241 1
d251 3
a253 1
			print "The file $filename has been installed from $origname\n";
d293 1
a293 1
	VSystem($state->{verbose}, 
d326 1
a326 1
	print "new directory ", $destdir, $fullname, "\n" if $state->{verbose};
d399 3
a401 1
getopts('avnIL:f:B:A:P:Q:');
d421 1
d448 1
d450 1
a450 1
$state->{beverbose} = $opt_n || $opt_v;
d481 3
d546 1
a546 1
	my ($handle, @@extra) = @@_;
d603 1
a603 1
	if (@@{$to_register} > 0) {
a785 1
	my $verbose = $state->{verbose};
d859 15
d904 1
a904 1
		my @@deps = solve_dependencies($handle, @@todo);
d906 1
@


1.78
log
@behave according to documentation, e.g., delete groups/users only if -c.
fix typo.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.77 2004/10/16 11:01:29 espie Exp $
d917 1
a917 1
my $dielater = @@_;
d932 1
a932 1
	die $@@;
@


1.77
log
@Add support for @@endfake and pkg_add -Q, to be documented later...
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.76 2004/10/13 18:39:07 espie Exp $
d475 6
a480 1
		print "$operation $pkg\n";
d512 6
a517 1
		print "$operation $pkgname\n";
@


1.76
log
@@@sysctl
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.75 2004/10/12 09:35:15 espie Exp $
d41 1
d197 4
d205 8
d344 1
d394 2
a395 2
our ($opt_a, $opt_v, $opt_n, $opt_I, $opt_f, $opt_L, $opt_B, $opt_A, $opt_P);
getopts('avnIL:f:B:A:P:');
d415 8
a422 1
if (defined $opt_B) {
d774 1
a774 1
	validate_plist($plist, $destdir);
d792 1
d802 4
@


1.75
log
@move conflict handling into a separate function, cleaner...
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.74 2004/10/11 14:40:04 espie Exp $
d148 26
@


1.74
log
@common code for exec/unexec/extraunexec.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.73 2004/10/11 14:35:07 espie Exp $
d338 14
d397 1
a397 7
# first, find all possible potential conflicts
for my $pkg (installed_packages()) {
	my $dir = installed_info($pkg);
	my $plist = OpenBSD::PackingList->fromfile($dir.CONTENTS, \&OpenBSD::PackingList::ConflictOnly);
	next unless defined $plist;
	$state->{conflict_list}->{$plist->pkgname()} = OpenBSD::PkgCfl->make_conflict_list($plist);
}
d549 1
a549 1
		copy("$dir$i", "$dest");
@


1.73
log
@simplify ldconfig now that we run in an uniform way.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.72 2004/10/11 13:46:17 espie Exp $
d296 1
a296 3
	main::ensure_ldconfig($state);
	print "exec ", $self->{expanded}, "\n" if $state->{beverbose};
	System('/bin/sh', '-c', $self->{expanded}) unless $state->{not};
@


1.72
log
@aggregate all MESSAGES and display them at the end, with proper markers to
separate distinct packages.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.71 2004/10/11 13:29:05 espie Exp $
d39 2
a40 1
	my $verbose = shift;
d42 2
a43 1
	VSystem($verbose, @@OpenBSD::PackingElement::Lib::ldconfig, "-m", 
d296 1
a296 1
	main::ensure_ldconfig($state->{verbose}) unless $state->{not};
d853 1
a853 1
ensure_ldconfig($opt_v) unless $opt_n;
@


1.71
log
@move mandir handling to pkg_add/delete time, solely.
Adjust stuff so that pkg_add can run makewhatis just once.
pkg_delete cannot, since it has to have the manpages around still
to remove them...
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.70 2004/10/11 13:10:25 espie Exp $
d775 1
a775 2
		my $pager = $ENV{'PAGER'} || "/usr/bin/more";
		System("$pager $dir".DISPLAY);
d855 5
@


1.70
log
@common code for all script running.
Common option for not running scripts: -I for both pkg_add and pkg_delete.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.69 2004/10/11 12:50:09 espie Exp $
d229 9
d691 3
a693 2
	my ($plist, $destdir) = @@_;
	return unless defined $plist->{state}->{mandirs};
d696 1
a696 1
	while (my ($k, $v) = each %{$plist->{state}->{mandirs}}) {
a747 1
	manpages_index($plist, $destdir);
d851 1
@


1.69
log
@more similarities to pkg_delete
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.68 2004/10/11 12:39:04 espie Exp $
d370 1
d675 1
a675 1
	my ($plist, $dir, $name, $msg, $pkgname, $args, $opt_v, $opt_n) = @@_;
d677 1
a677 10
	ensure_ldconfig($opt_v) unless $opt_n;
	print "$msg script: $dir$name $pkgname $args\n" if $opt_v or $opt_n;
	return if $opt_n;
	chmod 0755, $dir.$name;
	return if System($dir.$name, $pkgname, $args) == 0;
	if ($forced{scripts}) {
		Warn "$msg borked\n";
	} else {	
		Fatal "$msg borked";
	}
d706 2
d722 1
a722 1
	do_script($plist, $dir, REQUIRE, "Require", $pkgname, "INSTALL", $verbose, $not);
d724 1
a724 1
	do_script($plist, $dir, INSTALL, "Install", $pkgname, "PRE-INSTALL", $verbose, $not) unless $opt_I;
d741 2
a742 2
	if (!$opt_I && !$interrupted) {
		eval { do_script($plist, $dir, INSTALL, "Install", $pkgname, "POST-INSTALL", $verbose, $not) };
@


1.68
log
@pass more stuff through state
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.67 2004/10/11 12:33:59 espie Exp $
d102 1
a102 1
	my ($self, $archive, $destdir, $verbose, $not) = @@_;
d104 2
a105 2
	print "adding user $user\n" if $verbose;
	return if $not;
d113 1
a113 1
		push(@@$l, "-v") if $verbose;
d120 1
a120 1
		VSystem($verbose, '/usr/sbin/useradd', @@$l, $user);
d129 1
a129 1
	my ($self, $archive, $destdir, $verbose, $not) = @@_;
d131 2
a132 2
	print "adding group $group\n" if $verbose;
	return if $not;
d140 1
a140 1
		push(@@$l, "-v") if $verbose;
d142 1
a142 1
		VSystem($verbose, '/usr/sbin/groupadd', @@$l, $group);
d153 1
a153 1
	my ($self, $archive, $destdir, $verbose, $not) = @@_;
d156 1
a156 1
	my $file=$archive->next();
d161 4
a164 2
	print "extracting ", $destdir, $fullname, "\n" if $verbose;
	return if $not;
d178 1
a178 1
	my ($self, $archive, $destdir, $verbose, $not) = @@_;
d180 1
d201 1
a201 1
		if ($not) {
d205 1
a205 1
				print STDERR "File $filename could not be installed:\n\t$!\n";
d224 2
a225 2
	my ($self, $archive, $destdir, $verbose, $not) = @@_;
	$self->SUPER::install($archive, $destdir, $verbose, $not);
d235 5
a239 5
	my ($self, $archive, $destdir, $verbose, $not) = @@_;
	$self->SUPER::install($archive, $destdir, $verbose, $not);
	return if $not;
	my $fullname = $destdir.$self->fullname();
	VSystem($verbose, 
d246 3
a248 3
	my ($self, $archive, $destdir, $verbose, $not) = @@_;
	$self->SUPER::install($archive, $destdir, $verbose, $not);
	return if $not;
d250 1
d268 1
a268 1
	my ($self, $archive, $destdir, $verbose, $not) = @@_;
d270 1
d272 2
a273 2
	print "new directory ", $destdir, $fullname, "\n" if $verbose;
	return if $not;
d283 1
a283 1
	my ($self, $archive, $destdir, $verbose, $not) = @@_;
d285 3
a287 3
	main::ensure_ldconfig($verbose) unless $not;
	print "exec ", $self->{expanded}, "\n" if $verbose or $not;
	System('/bin/sh', '-c', $self->{expanded}) unless $not;
d294 3
a296 3
	my ($self, $archive, $destdir, $verbose, $not) = @@_;
	$self->SUPER::install($archive, $destdir, $verbose, $not);
	$self->mark_ldconfig_directory($destdir);
d713 1
d734 1
a734 1
		eval { $item->install($handle, $destdir, $verbose, $not); };
@


1.67
log
@store opt_n and opt_v inside state.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.66 2004/10/11 12:25:18 espie Exp $
d701 4
a704 1
	my ($handle, $destdir) = @@_;
d722 1
a722 1
	do_script($plist, $dir, REQUIRE, "Require", $pkgname, "INSTALL", $opt_v, $opt_n);
d724 1
a724 1
	do_script($plist, $dir, INSTALL, "Install", $pkgname, "PRE-INSTALL", $opt_v, $opt_n) unless $opt_I;
d728 1
a728 1
		eval { $item->install($handle, $destdir, $opt_v, $opt_n); };
d742 1
a742 1
		eval { do_script($plist, $dir, INSTALL, "Install", $pkgname, "POST-INSTALL", $opt_v, $opt_n) };
d750 1
a750 1
	if (!$opt_n) {
d826 1
a826 1
	really_add($handle, $state->{destdir});
@


1.66
log
@store more stuff inside $state
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.65 2004/10/11 12:13:46 espie Exp $
d364 3
d398 1
a398 1
sub pre_add($$$)
d400 1
a400 1
	my ($pkg, $state, $not) = @@_;
d402 1
a402 1
	my $operation = $not ? "Pretending to add" : "Adding";
d775 1
a775 1
		$cache->{$pkg} = pre_add($pkg, $state, $opt_n);
d841 1
a841 1
if ($opt_n or $opt_v) {
@


1.65
log
@move to a structure more similar to pkg_delete.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.64 2004/10/11 11:38:35 espie Exp $
d345 2
a346 1
my $destdir;
d348 1
a348 1
	$destdir = $opt_B;
d350 1
a350 1
	$destdir = $ENV{'PKG_PREFIX'};
d352 3
a354 3
if (defined $destdir) {
	$destdir.='/';
	$ENV{'PKG_DESTDIR'} = $destdir;
d356 1
a356 1
	$destdir = '';
d363 1
a363 1
my $conflict_list = {};
d370 1
a370 1
	$conflict_list->{$plist->pkgname()} = OpenBSD::PkgCfl->make_conflict_list($plist);
d373 1
a373 1
sub can_install($)
d375 1
a375 1
	my $pkgname = shift;
d382 1
a382 1
	while (my ($name, $l) = each %$conflict_list) {
d395 1
a395 1
sub pre_add($$)
d397 1
a397 1
	my ($pkg, $not) = @@_;
d404 1
a404 1
		return undef unless can_install($pkgname1);
d435 1
a435 1
		return undef unless can_install($pkgname);
d772 1
a772 1
		$cache->{$pkg} = pre_add($pkg, $opt_n);
d820 2
a821 2
	really_add($handle, $destdir);
	$conflict_list->{$plist->pkgname()} = $handle->{conflicts};
a825 2
my $state = {};
$state->{cache} = {};
@


1.64
log
@rework error handling through an eval{} so that post really_add always
gets executed, which means we can postpone some stuff until then...
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.63 2004/10/11 09:44:06 espie Exp $
a763 2
my @@todo = (@@ARGV);
my $cache={};
d765 5
a769 2
MAINLOOP:
while (my $pkg = shift @@todo) {
d773 1
d776 1
a776 1
		last unless defined $handle;
d778 1
a778 1
		next unless defined $handle;
d785 1
a785 1
		next;
d790 1
a790 1
			next MAINLOOP unless $forced{arch};
d796 1
a796 2
			unshift(@@todo, @@deps, $pkg);
			next MAINLOOP;
d805 1
a805 1
		next MAINLOOP;
d809 1
a809 1
		next if defined $dep->{name} and $dep->{name} ne $plist->pkgname();
d811 1
a811 1
			print "Can't install $pkg: incorrect libspec: ",
d813 1
a813 1
			next MAINLOOP unless $forced{libdepends};
d819 1
a819 5
	eval { really_add($handle, $destdir) };
	if ($@@) {
		Warn $@@;
		last;
	}
d821 1
d824 12
d842 3
a844 1
exit(1) if $errors;
@


1.63
log
@split PackageName handling into PackageName stuff/PkgSpec matching.
Kill new method that isn't really used.

Name explicit splitstem() to get the stem of a packagename.

Adjust calls to the interface.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.62 2004/10/11 09:13:20 espie Exp $
d109 1
a109 1
			die "user $user does not match\n";
d136 1
a136 1
			die "group $group does not match\n";
d147 1
d158 1
a158 1
		die "Error: archive does not match", $file->{name}, "!=",
d171 1
d181 1
a181 1
		die "\@@sample element does not reference a valid file\n";
d339 1
a339 1
	    die "bad option: -P $opt_P";
d359 1
a359 1
	die "$0 must be run as root";
d555 1
a555 2
	print "Installation of $pkgname failed.\n";
	print "Partial installation recorded as $borked\n";
a589 11
sub borked_script($)
{
	my $msg = shift;

	if ($forced{scripts}) {
		print "$msg borked\n";
	} else {
		die "$msg borked";
	}
}

d629 1
a629 1
	    print "Package $pkgname is not for cdrom.\n";
d633 1
a633 1
	    print "Package $pkgname is not for ftp.\n";
d649 1
a649 1
			print "Error: ", $s->{mnt}, " is read-only ($fname)\n";
d653 1
a653 1
			print "Error: ", $s->{mnt}, " is not large enough ($fname)\n";
d660 17
a676 1
	exit(1) if $problems;
d705 1
a705 3
		print STDERR "Archive in $pkgname broken\n";
		$errors++;
		return;
d715 1
a715 9
	if ($plist->has(REQUIRE)) {
		ensure_ldconfig($opt_v) unless $opt_n;
		print "Require script: $dir",REQUIRE," $pkgname INSTALL\n" if $opt_v or $opt_n;
		unless ($opt_n) {
			chmod 0755, $dir.REQUIRE;
			System($dir.REQUIRE, $pkgname, "INSTALL") == 0 or
			    borked_script("require script");
		}
	}
d717 1
a717 11
	unless ($opt_I) {
		if ($plist->has(INSTALL)) {
			ensure_ldconfig($opt_v) unless $opt_n;
			print "Install script: $dir",INSTALL," $pkgname PRE-INSTALL\n" if $opt_v or $opt_n;
			unless ($opt_n) {
				chmod 0755, $dir.INSTALL;
				System($dir.INSTALL, $pkgname, "PRE-INSTALL") == 0 or
				    borked_script("install script");
			}
		}
	}
d723 1
a723 1
			print STDERR "$@@";
d734 5
a738 10
	unless ($opt_I) {
		if ($plist->has(INSTALL) && !$interrupted) {
			ensure_ldconfig($opt_v) unless $opt_n;
			print "Install script: $dir",INSTALL ," $pkgname POST-INSTALL\n" if $opt_v or $opt_n;
			unless ($opt_n) {
				if (System($dir.INSTALL, $pkgname, "POST-INSTALL") != 0) {
					print STDERR "install script for $pkgname borked\n";
					$errors++ unless $forced{scripts};
				}
			}
d743 8
a750 8
	if ($interrupted || $errors) {
		borked_installation($plist, $dir) unless $opt_n;
		exit 1;
	}
	my $dest = installed_info($pkgname);
	register_installation($dir, $dest, $plist) unless $opt_n;
	if (defined $handle->{solved_dependencies} && !$opt_n) {
		require OpenBSD::RequiredBy;
d752 3
a754 2
		for my $dep (@@{$handle->{solved_dependencies}}) {
			OpenBSD::RequiredBy->new($dep)->add($pkgname);
d756 1
a756 1
    	}
d818 5
a822 1
	really_add($handle, $destdir);
@


1.62
log
@reorg error handling slightly, cleaner and clearer.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.61 2004/09/24 09:06:50 espie Exp $
d28 1
d400 2
a401 2
		$pkgname1 = OpenBSD::PackageName->new($pkg);
		return undef unless can_install($pkgname1->{pkgname});
d423 1
a423 1
	my $pkgname = OpenBSD::PackageName->new($plist->pkgname());
d425 1
a425 1
		if ($pkgname->{pkgname} ne $pkgname1->{pkgname}) {
d431 2
a432 2
		print $operation, " ", $pkgname->{pkgname}, "\n";
		return undef unless can_install($pkgname->{pkgname});
d464 1
a464 1
	    my @@candidates = OpenBSD::PackageName::pkgspec_match($dep->{pattern}, installed_packages());
d475 1
a475 1
	    	my @@candidates = OpenBSD::PackageName::pkgspec_match($dep->{pattern}, keys %{$to_install});
d481 1
a481 1
		    my @@candidates = OpenBSD::PackageName::pkgspec_match($dep->{pattern}, OpenBSD::PackageLocator::available());
@


1.61
log
@ditch `config' in the @@sample messages, since this more or less covers
all files installed from templates.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.60 2004/09/21 22:17:49 espie Exp $
d599 1
a599 1
sub collision_report
d629 1
a629 1
sub manpages_index
a631 2
	return unless defined $plist->{state}->{mandirs};
	require OpenBSD::Makewhatis;
d633 1
a633 15
	while (my ($k, $v) = each %{$plist->{state}->{mandirs}}) {
		my @@l = map { $destdir.$_ } @@$v;
		eval { OpenBSD::Makewhatis::merge($destdir.$k, \@@l); };
		if ($@@) {
			print STDERR "Error in makewhatis: $@@\n";
		}
	}
}


sub really_add($$)
{
	my ($handle, $destdir) = @@_;
	my $plist = $handle->{plist};
	my $dir = $handle->info();
a634 1
	my $problems = 0;
d645 1
a645 1
	$ENV{'PKG_PREFIX'} = $plist->pkgbase();
d670 34
a730 7

	if (!defined $handle) {
		print STDERR "Archive in $pkgname broken\n";
		$errors++;
		return;
	}

@


1.60
log
@@@newuser/@@newgroup initial support:
- groups category and users category that get handled first, so that
those groups/users can be used for other files.
- : separated fields, for easy parsing. Mostly matching useradd groupadd.
- ! for mandatory values.
Missing pkg_delete -c support for now.

okay naddy@@, pvalchev@@, millert@@
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.59 2004/09/20 10:36:39 espie Exp $
d182 1
a182 1
		print "The existing configuration file $filename has NOT been changed\n";
d196 1
a196 1
			print "The configuration file $filename would be installed from $origname\n";
d199 1
a199 1
				print STDERR "Configuration file $filename could not be installed:\n\t$!\n";
d202 1
a202 1
			print "The configuration file $filename has been installed from $origname\n";
@


1.59
log
@error out for pkgcfl in pkg_create, but don't warn if it's found in
existing packages or installed packages. Too much noise for now.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.58 2004/09/20 09:10:21 espie Exp $
d45 12
d96 49
d723 1
a723 1
	for my $item (@@{$plist->{items}}) {
@


1.58
log
@deals with conflicts, must keep pkgcfl around a little while longer...
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.57 2004/09/20 07:31:42 espie Exp $
a23 1
use OpenBSD::PackingOld;
@


1.57
log
@use fullname() in sample, so that absolute names AND relative names work.
problem noticed by sturm@@
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.56 2004/09/18 13:28:19 espie Exp $
d24 1
@


1.56
log
@framework to be able to distinguish packages installed manually (and thus
wanted by the user) from packages installed automatically to satisfy a
dependency.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.55 2004/09/18 09:27:05 espie Exp $
d114 1
a114 1
	my $filename = $destdir.$self->{name};
@


1.55
log
@full support for @@shell: insert shells into /etc/shells if they're
not already there, and remove them on deinstall.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.54 2004/09/14 22:53:17 espie Exp $
d262 2
a263 2
our ($opt_v, $opt_n, $opt_I, $opt_f, $opt_L, $opt_B, $opt_A, $opt_P);
getopts('vnIL:f:B:A:P:');
@


1.54
log
@use System or Vsystem everywhere.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.53 2004/09/14 22:49:36 espie Exp $
d174 21
@


1.53
log
@better reporting of conflicts, suggested by naddy@@
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.52 2004/09/14 22:47:48 espie Exp $
a39 2
	print "running ldconfig -m ", join(' ', keys %$OpenBSD::PackingElement::Lib::todo), "\n"
	    if  $verbose;
d164 1
d172 2
a173 1
	system("install-info", "--info-dir=".dirname($fullname), $fullname);
d189 1
d197 1
a197 1
	system('/bin/sh', '-c', $self->{expanded}) unless $not;
d616 1
a616 1
			system($dir.REQUIRE, $pkgname, "INSTALL") == 0 or
d627 1
a627 1
				system($dir.INSTALL, $pkgname, "PRE-INSTALL") == 0 or
d660 1
a660 1
				if (system($dir.INSTALL, $pkgname, "POST-INSTALL") != 0) {
d685 1
a685 1
		system("$pager $dir".DISPLAY);
@


1.52
log
@report issues while installing configuration files.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.51 2004/09/14 22:46:12 espie Exp $
d354 2
a355 1
		print "package $pkg has conflicts\n";
@


1.51
log
@use chown/chmod system calls directly where possible.
some System instead of system.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.50 2004/08/12 19:18:03 brad Exp $
d139 3
a141 1
			copy($origname, $filename);
@


1.50
log
@add missing $

ok espie@@
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.49 2004/08/10 12:04:53 espie Exp $
d30 1
d42 1
a42 1
	system(@@OpenBSD::PackingElement::Lib::ldconfig, "-m", 
d48 3
d60 15
a74 6
	if (defined $self->{owner} && defined $self->{group}) {
		system('chown', $self->{owner}.':'.$self->{group}, $name);
	} elsif (defined $self->{owner}) {
		system('chown', $self->{owner}, $name);
	} elsif (defined $self->{group}) {
		system('chown', ':'.$self->{group}, $name);
d77 6
a82 1
		system('chmod', $self->{mode}, $name);
@


1.49
log
@typo
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.48 2004/08/10 11:53:27 espie Exp $
d113 1
a113 1
				print "\tIt does not match the sample file origname\n";
@


1.48
log
@cosmetic tweak: ensure all dirs always get exactly one / at the end.
cosmetic tweak: do not show a space after a keyword without args.
dir support reworked: keep clones() of dir objects, and call cleanup/reload
routines at end.

@@mandir/fontdir support:
both mandir and fontdir remove extra files on delete.
@@fontdir creates alias files, runs mkfontdir, and uses fc-cache.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.47 2004/08/07 17:27:26 espie Exp $
d140 1
a140 1
	$self->SUPER::install->($archive, $destdir, $verbose, $not);
@


1.47
log
@use chroot DESTDIR ldconfig in DESTDIR case.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.46 2004/08/06 14:33:02 espie Exp $
d135 9
d725 1
@


1.46
log
@protect makewhatis calls inside eval.
failing makewhatis should be a warning at best.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.45 2004/08/06 12:21:11 espie Exp $
d41 1
a41 1
	system($OpenBSD::PackingElement::Lib::ldconfig, "-m", 
@


1.45
log
@use OpenBSD::Makewhatis, avoid forking extra makewhatis.

Note: requires you to update makewhatis to work.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.44 2004/08/06 11:36:25 espie Exp $
d524 4
a527 1
		OpenBSD::Makewhatis::merge($destdir.$k, \@@l);
@


1.44
log
@fix one of the most bizarre bugs in a while...
found by henning@@.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.43 2004/08/06 10:23:45 espie Exp $
d520 2
d523 2
a524 2
		system("/usr/libexec/makewhatis", "-d", $destdir.$k,
		map { $destdir.$_ } @@$v);
@


1.43
log
@@@lib shared library marker.

- runs ldconfig to find out search library path.
- if library is in path, mark directory for updating cache.
- run ldconfig when needed, e.g., right before executing something that
might depend on the library.

Doesn't handle destdir case yet.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.42 2004/08/06 08:14:51 espie Exp $
d39 2
a40 1
	print "running ldconfig -m ", join(' ', keys %$OpenBSD::PackingElement::Lib::todo), "\n" if $verbose;
@


1.42
log
@avoid pulling in OpenBSD::md5 and File::Copy if we can.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.41 2004/08/06 08:06:01 espie Exp $
d35 10
d164 1
d169 9
d575 1
d586 1
d620 1
d709 2
@


1.41
log
@block-scoped require is way simpler than weird AUTOLOAD hack.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.40 2004/08/06 07:51:17 espie Exp $
a81 1
use OpenBSD::md5;
d96 2
d403 2
a404 1
	    use OpenBSD::md5;
@


1.40
log
@unified headers, switch to smaller copyright notice.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.39 2004/08/05 23:36:39 espie Exp $
a34 9
# XXX we don't want to load this package all the time
package OpenBSD::RequiredBy;
our $AUTOLOAD;
sub AUTOLOAD {
	eval { require OpenBSD::RequiredBy;
	};
	goto &$AUTOLOAD;
}

d614 2
@


1.39
log
@refactor classes in PackingElement to share more code.
- all files go through FileBase, all directories go through DirBase.
- dirclass() is used to switch classes based on final /, so that
@@sample, @@extra, and @@file  all take directories as well.
- set NoDuplicateNames() more thoroughly.
- make sure all no-default-conflict objects are correct.

compute_fullname() checks for absolute paths, allowed for @@sample and
@@extra.

lastfile only gets set for actual files.

special names like INSTALL are only checked for normal files.

add a CVSTag class for @@comment $OpenBSD$, so that these get sorted first.

Changes for make-plist rewrite:

clone() method that can create copies of all hash objects, to specialize
if needed.

add_object() method so that add() is now new() followed by add_object()
for most objects (useful for cloned objects).

Check that plist has a name in pkg_create, allowing PackingList to write
unnamed plists.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.38 2004/08/03 12:29:44 espie Exp $
d6 13
a18 22
# Copyright (c) 2003 Marc Espie.
# 
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
# 
# THIS SOFTWARE IS PROVIDED BY THE OPENBSD PROJECT AND CONTRIBUTORS
# ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
# A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OPENBSD
# PROJECT OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
@


1.38
log
@Support @@sample, tested by fries@@.
@@mandir and @@fontdir keywords recognition.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.37 2004/08/02 12:12:36 espie Exp $
d75 1
a75 1
package OpenBSD::PackingElement::File;
d132 7
@


1.37
log
@@@man type file for manpages.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.36 2004/08/02 12:08:25 espie Exp $
d96 36
@


1.36
log
@Reuse first component of @@newdepends, @@libdepends to contain
a PKG_PATH (easy backward compatibility: is there a slash ?)

That's missing info to enable pkg_add to launch package building
in the ports tree as an alternate source of binary packages.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.35 2004/07/20 18:58:41 espie Exp $
d468 11
d566 1
@


1.35
log
@support for gnu-info, with @@info keyword.
- modify pkg_create so that it will look for info-[0-9]+ and add them
to the packing-list.
- deal with installing the info file/de-installing it at pkg_add/pkg_delete
time.

tested by naddy@@
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.34 2004/07/14 10:44:03 espie Exp $
d302 1
a302 1
	    next if $dep->{name} ne $plist->pkgname();
d632 1
a632 1
		next if $dep->{name} ne $plist->pkgname();
@


1.34
log
@Rework @@dirrm: keep them all, and remove them at the end of pkg_delete.
Add @@dir, more powerful than @@dirrm, so that we can get rid of those
pesky @@exec mkdir -p.

okay naddy@@
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.33 2004/07/11 20:46:08 espie Exp $
d96 12
@


1.33
log
@hunt for the originating packages in case of collision, and sort
the colliding files by package.

okay naddy@@, and typo fix naddy/pval.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.32 2004/06/21 15:19:33 miod Exp $
d59 16
d82 1
d89 3
a91 2
	print "extracting ", $destdir, $self->fullname(), "\n" if $verbose;
	$file->{name} = $self->fullname();
d94 11
d106 2
a107 11
	$file->create();
	if (defined $self->{owner} && defined $self->{group}) {
		system('chown', $self->{owner}.':'.$self->{group}, $destdir.$self->fullname());
	} elsif (defined $self->{owner}) {
		system('chown', $self->{owner}, $destdir.$self->fullname());
	} elsif (defined $self->{group}) {
		system('chown', ':'.$self->{group}, $destdir.$self->fullname());
	}
	if (defined $self->{mode}) {
		system('chmod', $self->{mode}, $destdir.$self->fullname());
	}
@


1.32
log
@Implement pkg_add -I for real; ok espie@@
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.31 2004/04/28 06:53:17 espie Exp $
d406 30
d475 1
a475 2
		print "Collision: the following files already exists\n\t",
			join("\n\t", @@$colliding), "\n";
@


1.31
log
@Use the string version of system. Works with PAGER=less -s.
ho@@
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.30 2004/03/30 08:55:56 espie Exp $
d463 9
a471 6
	if ($plist->has(INSTALL)) {
		print "Install script: $dir",INSTALL," $pkgname PRE-INSTALL\n" if $opt_v or $opt_n;
		unless ($opt_n) {
			chmod 0755, $dir.INSTALL;
			system($dir.INSTALL, $pkgname, "PRE-INSTALL") == 0 or
			    borked_script("install script");
d495 9
a503 6
	if ($plist->has(INSTALL) && !$interrupted) {
		print "Install script: $dir",INSTALL ,"$pkgname POST-INSTALL\n" if $opt_v or $opt_n;
		unless ($opt_n) {
			if (system($dir.INSTALL, $pkgname, "POST-INSTALL") != 0) {
				print STDERR "install script for $pkgname borked\n";
				$errors++ unless $forced{scripts};
@


1.30
log
@wrap each install operation into eval {} so that a die there will leave
us a chance to register what's already happened.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.29 2004/03/18 16:49:50 tholo Exp $
d517 1
a517 1
		system($pager, $dir.DISPLAY);
@


1.29
log
@When using an install prefix with -B to install packages, and the packing
list uses @@owner, @@group and/or @@mode, setting these did not use the
install prefix.  ok deraadt@@
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.28 2004/03/07 19:29:08 espie Exp $
d481 6
a486 1
		$item->install($handle, $destdir, $opt_v, $opt_n);
@


1.28
log
@A few useful features:
- pkg_add -A arch, to make believe we are extracting on a given arch
(matches pkg_create).
- pkg_add -P cdrom/-P ftp, to enforce extracting only cdrom'able packages
or ftp'able packages. Helps a lot for checking cdrom lists.
- dependency look-up will look through local directory listings to solve
dependencies, so that non-default dependencies will work more seemlessly.
(doing the same thing for distant repository will happen after 3.5, but
this requires more apparatus: caching package lists, and killing/restoring
existing connections, plus more error handling).

okay pval
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.27 2004/02/20 19:13:51 espie Exp $
d79 1
a79 1
		system('chown', $self->{owner}.':'.$self->{group}, $self->fullname());
d81 1
a81 1
		system('chown', $self->{owner}, $self->fullname());
d83 1
a83 1
		system('chown', ':'.$self->{group}, $self->fullname());
d86 1
a86 1
		system('chmod', $self->{mode}, $self->fullname());
@


1.27
log
@PKG_DESTDIR / -B support in pkg_add.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.26 2004/01/28 22:12:01 espie Exp $
d42 1
d104 1
a104 1
	my $self = $_[0];
d109 7
d132 2
a133 2
our ($opt_v, $opt_n, $opt_I, $opt_f, $opt_L, $opt_B);
getopts('vnIL:f:B:');
d137 12
d287 22
a308 3
		    # okay, give up, use the default
		    push(@@deps, $dep->{def});
		    push(@@$to_register, $dep->{def});
d412 11
a424 1
	my $problems = 0;
d448 1
a448 1
	die if $problems;
d538 1
a538 1
		unless ($plist->{arch}->check()) {
@


1.26
log
@Add -L to record/enforce localbase.
Okay sturm@@
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.25 2004/01/27 17:47:45 sturm Exp $
d64 1
a64 1
	my ($self, $archive, $verbose, $not) = @@_;
d71 1
a71 1
	print "extracting ", $self->fullname(), "\n" if $verbose;
d74 1
d93 1
a93 1
	my ($self, $archive, $verbose, $not) = @@_;
d124 2
a125 2
our ($opt_v, $opt_n, $opt_I, $opt_f, $opt_L);
getopts('vnIL:f:');
d131 13
d367 1
a367 1
sub really_add($)
d369 1
a369 1
	my $handle = shift;
d376 1
d379 1
a379 1
		my $fname = $item->fullname();
d381 1
a381 1
			print "Collision: $fname already exists\n";
d395 4
d432 1
a432 1
		$item->install($handle, $opt_v, $opt_n);
d521 1
a521 1
	really_add($handle);
@


1.25
log
@Don't just detect errors in pre_add(), but exit. Gets rid of strange
error messages if a dependency cannot be installed.

found by naddy@@, ok espie@@
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.24 2004/01/27 14:50:52 espie Exp $
d123 2
a124 2
our ($opt_v, $opt_n, $opt_I, $opt_f);
getopts('vnIf:');
d128 1
d192 5
d359 1
a359 1
	$ENV{'PKG_PREFIX'} = '/usr/local';
d493 1
a493 1
		if (!check_lib_specs('/usr/local', $dep->{libspec})) {
@


1.24
log
@first series of -forced switches, looks okay to henning@@.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.23 2004/01/27 13:09:16 espie Exp $
d451 5
a455 1
	next unless defined $handle;
@


1.23
log
@-f framework, manpage fixes.
comments and okay jmc@@
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.22 2004/01/22 21:11:43 espie Exp $
d129 4
d149 1
a149 1
		return undef;
d156 1
a156 1
			return undef;
d208 1
a208 1
		return undef;
d336 11
d385 2
a386 1
			system($dir.REQUIRE, $pkgname, "INSTALL") == 0 or die "require script borked";
d393 2
a394 1
			system($dir.INSTALL, $pkgname, "PRE-INSTALL") == 0 or die "install script borked";
d418 1
a418 1
				$errors++;
d462 1
a462 1
			next MAINLOOP;
d486 1
a486 1
			next MAINLOOP;
@


1.22
log
@document/activate @@arch. Fix list handling.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.20 2003/12/26 16:34:05 espie Exp $
d41 2
d123 5
a127 2
our ($opt_v, $opt_n, $opt_I);
getopts('vnI');
@


1.21
log
@post-INSTALL script falling -> record installation as a borked package
instead of aborting outright with loads of files unregistered...
@
text
@d96 21
d436 6
@


1.20
log
@pkg_add reports size taken on each fs.
Reorg and clean Vstat a bit.
okay naddy@@
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.19 2003/12/21 18:41:23 espie Exp $
d373 4
a376 1
			system($dir.INSTALL, $pkgname, "POST-INSTALL") == 0 or die "install script borked";
d381 1
a381 1
	if ($interrupted) {
@


1.19
log
@Add virtual file system, so that pkg_add and pkg_delete can check for
read-only status, or size concerns, before even beginning to add/remove
files.

Allows pkg_add -n and pkg_delete -n to be more thorough as well.

Some testing by Todd Millert, comments by Greg Steuck and Sam Smith.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.18 2003/12/19 00:29:20 espie Exp $
d328 1
a328 1
		if ($s->{avail} < 0) {
d444 3
@


1.18
log
@Clean up PackageLocator so it looks somewhat more object-oriented.
Most importantly, put all the state information into the created object,
so that the actual archive can be closed, later reopened, and scanned
until the correct file is found.

This will be used to allow retrieving packages through ftp without keeping
loads of connections opened because of dependency resolving.

Approved by fries and naddy.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.17 2003/12/10 11:12:22 espie Exp $
d37 1
a287 4
			unless (opendir(DIRECTORY, $dir)) {
				print "base directory not found\n" if $opt_v;
				return undef;
			}
d291 1
a291 2
			    readdir(DIRECTORY);
			close(DIRECTORY);
d314 1
a314 1
	my $collisions = 0;
d317 14
a330 3
		if (-e $item->fullname()) {
			print "Collision: ",$item->fullname()," already exists\n";
			$collisions++;
d333 1
a333 1
	die if $collisions;
a429 1
		next if $opt_n;
@


1.17
log
@Replace Adding/Deleting with "Pretending to add/delete" in -n mode.
Pick up DISPLAY from staging area, so that it gets found even if -n.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.16 2003/12/09 19:10:35 espie Exp $
a346 1
	my $archive=$handle->{archive};
d348 1
a348 1
	if (!defined $archive) {
d357 1
a357 1
		$item->install($archive, $opt_v, $opt_n);
@


1.16
log
@Spell out which dependencies are getting solved so that pkg_add output
is less confusing.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.15 2003/12/09 19:08:44 espie Exp $
d134 1
a134 1
sub pre_add($)
d136 1
a136 1
	my $pkg = shift;
d138 1
d141 1
a141 1
		print "Adding $pkg\n";
d168 1
a168 1
		print "Adding ",$pkgname->{pkgname}, "\n";
d386 1
a386 1
		system($pager, $dest.DISPLAY);
d396 1
a396 1
		$cache->{$pkg} = pre_add($pkg);
@


1.15
log
@Fix logic for error handling, especially if -n is specified.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.14 2003/11/10 13:25:50 espie Exp $
d223 2
a224 1
	    print "Dependencies resolve to: ", join(',', @@$to_register);
@


1.14
log
@Fine-grained handling of errors, pkg already installed is not an error.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.13 2003/11/09 16:13:37 espie Exp $
a268 1
	exit 1;
d347 7
d371 2
a372 1
		borked_installation($plist, $dir);
d375 2
a376 2
	register_installation($dir, $dest, $plist);
	if (defined $handle->{solved_dependencies}) {
d421 2
@


1.13
log
@count errors while installing packages, and exit(1) if errors.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.12 2003/11/09 15:42:48 espie Exp $
d97 2
d124 1
d148 1
d156 1
d163 1
d175 1
a383 1
my $errors = 0;
d390 1
a390 4
	if (!defined $handle) {
		$errors++;
		next;
	}
@


1.12
log
@fix semantics to match old tools. This prefix is what was passed on
the command line, not the first cwd in the archive, sorry.

No way to override this currently.

To be safe,
- packages would need to be built with a specific base.
- packages would need to be installed with the same base.

Somewhat the same semantic difference as with LOCALBASE/PREFIX.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.11 2003/11/06 22:05:19 espie Exp $
d377 1
d384 4
a387 1
	next unless defined $handle;
d424 2
@


1.11
log
@handle +DISPLAY
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.10 2003/11/06 18:42:01 espie Exp $
d308 1
a308 1
	$ENV{'PKG_PREFIX'} = $plist->prefix();
d408 1
a408 1
		if (!check_lib_specs($plist->prefix(), $dep->{libspec})) {
@


1.10
log
@set env PKG_PREFIX for compatibility with old tools.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.9 2003/11/06 18:13:12 espie Exp $
d368 4
@


1.9
log
@verify libspec fully again (same code as old pkg add-on, mostly).
This ends the current batch of updates.
Much thanks to sturm@@ for testing and comments.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.4 2003/10/26 11:09:27 espie Exp $
d308 1
@


1.8
log
@Split off dependency solving into its own function.
pkg without dependencies is not a special case, it will simply
end up with an empty solved dependency list.

Try harder to resolve dependencies without resorting to default, use
other arguments on the command line first.

This makes it possible to have pkg_add * run for the CD even if the CD
doesn't contain only default packages as long as the packages satisfy the
dependencies.
@
text
@d265 36
d400 8
@


1.7
log
@do not try to run the post-install script on an aborted pkg_add.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.6 2003/11/06 18:04:10 espie Exp $
d129 1
d141 1
d174 49
d265 1
d282 1
d318 1
a337 1
	print "Trying to add $pkg\n";
d350 4
a353 4
	if (defined $handle->{solved_dependencies}) {
		for my $dep (@@{$handle->{solved_dependencies}}) {
			next if is_installed($dep);
			print "Can't install $pkg: can't resolve $dep\n";
d356 11
a366 44
		for my $dep (@@{$handle->{solved_dependencies}}) {
			OpenBSD::PackingElement::PkgDep->add($plist, $dep);
		}
	} elsif ((defined $plist->{pkgdep}) or (defined $plist->{libdepend}) or (defined $plist->{newdepend})) {
		# do simple old style pkgdep first
		my @@deps = ();
		my @@done_deps = ();
		if (defined $plist->{pkgdep}) {
			for my $dep (@@{$plist->{pkgdep}}) {
				if (is_installed($dep->{name})) {
					push(@@done_deps, $dep->{name});
				} else {
					push(@@deps, $dep->{name});
				}
			}
		} 
		if (defined $plist->{newdepend}) {
			for my $dep (@@{$plist->{newdepend}}) {
			    next if $dep->{name} ne $plist->pkgname();
			    my @@candidates = OpenBSD::PackageName::pkgspec_match($dep->{pattern}, installed_packages());
			    if (@@candidates >= 1) {
				    push(@@done_deps, $candidates[0]);
			    } else {
				    push(@@deps, $dep->{def});
			    }
		    	}
		}
		if (defined $plist->{libdepend}) {
			for my $dep (@@{$plist->{libdepend}}) {
			    next if $dep->{name} ne $plist->pkgname();
			    my @@candidates = OpenBSD::PackageName::pkgspec_match($dep->{pattern}, installed_packages());
			    if (@@candidates >= 1) {
				    push(@@done_deps, $candidates[0]);
			    } else {
				    push(@@deps, $dep->{def});
			    }
			}
		}
		print "Dependencies. Done: ", join(',', @@done_deps),
			" Todo: ", join(',', @@deps), "\n";
		unshift(@@todo, @@deps, $pkg);
		$handle->{solved_dependencies} = [];
		push(@@{$handle->{solved_dependencies}}, @@done_deps, @@deps);
		next;
@


1.6
log
@split out the registration process, and add a ^C handler, to that
half-installed packages register in a sensible way.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.5 2003/11/06 17:59:23 espie Exp $
d259 1
a259 1
	if ($plist->has(INSTALL)) {
@


1.5
log
@Handle pkg_add -
let pkg_add postpone conflict handling until it has the real name of
the package if necessary, and let PackageLocator deal correctly with a '-'
filename.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.4 2003/10/26 11:09:27 espie Exp $
d130 1
a130 1
sub pre_add
d172 43
a214 1
sub really_add
d230 5
d251 1
d254 2
a264 1
	my $dest = installed_info($pkgname);
d266 2
a267 3
	mkdir($dest);
	for my $i (info_names()) {
		copy("$dir$i", "$dest");
d269 2
a270 1
	$plist->tofile($dest.CONTENTS);
@


1.4
log
@cosmetic change, people read preadd as p_read_d, so make it explicit:
preadd -> pre_add
reallyadd -> really_add
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.3 2003/10/20 17:29:56 espie Exp $
d110 15
d126 2
d133 6
a138 10
	my $pkgname1 = OpenBSD::PackageName->new($pkg);
	if (is_installed $pkgname1->{pkgname}) {
		print "package $pkg is already installed\n";
		return undef;
	}
	while (my ($name, $l) = each %$conflict_list) {
		if ($l->conflicts_with($pkgname1->{pkgname})) {
			print "package $pkg conflicts with installed package $name\n";
			return undef;
		}
d153 8
a160 3
	if ($pkgname->{pkgname} ne $pkgname1->{pkgname}) {
		print "Package name is not consistent ???\n";
		return undef;
@


1.3
log
@Missing undef. conflicts is an error.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.2 2003/10/19 18:42:55 espie Exp $
d112 2
a113 2
# This does preadd a package: finding it and reading its package information
sub preadd
d154 1
a154 1
sub reallyadd
d219 1
a219 1
		$cache->{$pkg} = preadd($pkg);
d281 1
a281 1
	reallyadd($handle);
@


1.2
log
@plist's has/get methods for accessing elements: perl ->{} has quirks
that make it unusable for looking up constants correctly.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.1.1.1 2003/10/16 17:43:34 espie Exp $
d149 1
@


1.1
log
@Initial revision
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.1.1.1 2003/10/16 17:16:30 espie Exp $
d169 1
a169 1
	if ($plist->{OpenBSD::PackageInfo::REQUIRE}) {
d176 1
a176 1
	if ($plist->{OpenBSD::PackageInfo::INSTALL}) {
d190 1
a190 1
	if ($plist->{OpenBSD::PackageInfo::INSTALL}) {
@


1.1.1.1
log
@new import of my pkgtools, after a slight naming disagreement with the
Upper Management...
@
text
@@
