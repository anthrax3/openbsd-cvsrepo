head	1.157;
access;
symbols
	OPENBSD_6_1_BASE:1.157
	OPENBSD_6_0:1.157.0.6
	OPENBSD_6_0_BASE:1.157
	OPENBSD_5_9:1.157.0.2
	OPENBSD_5_9_BASE:1.157
	OPENBSD_5_8:1.155.0.6
	OPENBSD_5_8_BASE:1.155
	OPENBSD_5_7:1.155.0.2
	OPENBSD_5_7_BASE:1.155
	OPENBSD_5_6:1.152.0.6
	OPENBSD_5_6_BASE:1.152
	OPENBSD_5_5:1.152.0.4
	OPENBSD_5_5_BASE:1.152
	OPENBSD_5_4:1.151.0.12
	OPENBSD_5_4_BASE:1.151
	OPENBSD_5_3:1.151.0.10
	OPENBSD_5_3_BASE:1.151
	OPENBSD_5_2:1.151.0.8
	OPENBSD_5_2_BASE:1.151
	OPENBSD_5_1_BASE:1.151
	OPENBSD_5_1:1.151.0.6
	OPENBSD_5_0:1.151.0.4
	OPENBSD_5_0_BASE:1.151
	OPENBSD_4_9:1.151.0.2
	OPENBSD_4_9_BASE:1.151
	OPENBSD_4_8:1.133.0.2
	OPENBSD_4_8_BASE:1.133
	OPENBSD_4_7:1.123.0.2
	OPENBSD_4_7_BASE:1.123
	OPENBSD_4_6:1.65.0.4
	OPENBSD_4_6_BASE:1.65
	OPENBSD_4_5:1.64.0.4
	OPENBSD_4_5_BASE:1.64
	OPENBSD_4_4:1.64.0.2
	OPENBSD_4_4_BASE:1.64
	OPENBSD_4_3:1.59.0.4
	OPENBSD_4_3_BASE:1.59
	OPENBSD_4_2:1.59.0.2
	OPENBSD_4_2_BASE:1.59
	OPENBSD_4_1:1.6.0.2
	OPENBSD_4_1_BASE:1.6
	OPENBSD_4_0:1.4.0.4
	OPENBSD_4_0_BASE:1.4
	OPENBSD_3_9:1.4.0.2
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.2.0.2
	OPENBSD_3_8_BASE:1.2;
locks; strict;
comment	@# @;


1.157
date	2015.11.05.13.26.39;	author espie;	state Exp;
branches;
next	1.156;
commitid	mCiggYSeDw3JQTrw;

1.156
date	2015.08.14.10.12.02;	author espie;	state Exp;
branches;
next	1.155;
commitid	gWvHiU9yz03jnsd6;

1.155
date	2015.01.30.11.42.55;	author espie;	state Exp;
branches;
next	1.154;
commitid	cmEQoqBSBCDfR7gW;

1.154
date	2014.11.30.15.56.34;	author espie;	state Exp;
branches;
next	1.153;
commitid	3jwIEcaSx6HZgmLl;

1.153
date	2014.11.30.09.49.48;	author espie;	state Exp;
branches;
next	1.152;
commitid	w6OR877fYsRB71qA;

1.152
date	2014.02.01.11.37.58;	author espie;	state Exp;
branches;
next	1.151;

1.151
date	2010.12.24.09.04.14;	author espie;	state Exp;
branches;
next	1.150;

1.150
date	2010.12.21.17.43.07;	author espie;	state Exp;
branches;
next	1.149;

1.149
date	2010.12.21.11.25.19;	author espie;	state Exp;
branches;
next	1.148;

1.148
date	2010.12.20.16.30.03;	author espie;	state Exp;
branches;
next	1.147;

1.147
date	2010.12.20.11.55.48;	author espie;	state Exp;
branches;
next	1.146;

1.146
date	2010.12.20.09.43.51;	author espie;	state Exp;
branches;
next	1.145;

1.145
date	2010.12.20.09.41.44;	author espie;	state Exp;
branches;
next	1.144;

1.144
date	2010.12.20.09.38.40;	author espie;	state Exp;
branches;
next	1.143;

1.143
date	2010.12.20.09.30.40;	author espie;	state Exp;
branches;
next	1.142;

1.142
date	2010.12.20.09.23.23;	author espie;	state Exp;
branches;
next	1.141;

1.141
date	2010.12.20.09.10.51;	author espie;	state Exp;
branches;
next	1.140;

1.140
date	2010.12.20.09.08.42;	author espie;	state Exp;
branches;
next	1.139;

1.139
date	2010.12.20.08.58.03;	author espie;	state Exp;
branches;
next	1.138;

1.138
date	2010.12.13.12.13.54;	author espie;	state Exp;
branches;
next	1.137;

1.137
date	2010.11.27.11.58.12;	author espie;	state Exp;
branches;
next	1.136;

1.136
date	2010.10.28.16.31.07;	author espie;	state Exp;
branches;
next	1.135;

1.135
date	2010.10.27.14.35.56;	author espie;	state Exp;
branches;
next	1.134;

1.134
date	2010.08.13.11.12.43;	author espie;	state Exp;
branches;
next	1.133;

1.133
date	2010.08.07.10.26.58;	author espie;	state Exp;
branches;
next	1.132;

1.132
date	2010.06.30.10.51.04;	author espie;	state Exp;
branches;
next	1.131;

1.131
date	2010.06.30.10.41.42;	author espie;	state Exp;
branches;
next	1.130;

1.130
date	2010.06.30.10.37.25;	author espie;	state Exp;
branches;
next	1.129;

1.129
date	2010.06.09.07.26.01;	author espie;	state Exp;
branches;
next	1.128;

1.128
date	2010.06.05.07.35.21;	author landry;	state Exp;
branches;
next	1.127;

1.127
date	2010.06.04.13.19.39;	author espie;	state Exp;
branches;
next	1.126;

1.126
date	2010.05.10.09.17.55;	author espie;	state Exp;
branches;
next	1.125;

1.125
date	2010.04.10.11.04.21;	author espie;	state Exp;
branches;
next	1.124;

1.124
date	2010.04.10.10.48.57;	author espie;	state Exp;
branches;
next	1.123;

1.123
date	2010.03.06.13.38.42;	author espie;	state Exp;
branches;
next	1.122;

1.122
date	2010.01.24.15.13.15;	author espie;	state Exp;
branches;
next	1.121;

1.121
date	2010.01.24.15.00.26;	author espie;	state Exp;
branches;
next	1.120;

1.120
date	2010.01.05.11.30.19;	author espie;	state Exp;
branches;
next	1.119;

1.119
date	2010.01.04.00.14.31;	author espie;	state Exp;
branches;
next	1.118;

1.118
date	2010.01.01.13.00.05;	author espie;	state Exp;
branches;
next	1.117;

1.117
date	2010.01.01.12.58.30;	author espie;	state Exp;
branches;
next	1.116;

1.116
date	2009.12.31.14.46.37;	author espie;	state Exp;
branches;
next	1.115;

1.115
date	2009.12.31.14.43.54;	author espie;	state Exp;
branches;
next	1.114;

1.114
date	2009.12.31.11.52.25;	author espie;	state Exp;
branches;
next	1.113;

1.113
date	2009.12.30.17.40.45;	author espie;	state Exp;
branches;
next	1.112;

1.112
date	2009.12.30.17.37.36;	author espie;	state Exp;
branches;
next	1.111;

1.111
date	2009.12.30.09.36.16;	author espie;	state Exp;
branches;
next	1.110;

1.110
date	2009.12.29.18.16.14;	author espie;	state Exp;
branches;
next	1.109;

1.109
date	2009.12.29.15.21.02;	author espie;	state Exp;
branches;
next	1.108;

1.108
date	2009.12.29.14.36.53;	author espie;	state Exp;
branches;
next	1.107;

1.107
date	2009.12.29.14.21.47;	author espie;	state Exp;
branches;
next	1.106;

1.106
date	2009.12.29.14.11.46;	author espie;	state Exp;
branches;
next	1.105;

1.105
date	2009.12.29.14.03.31;	author espie;	state Exp;
branches;
next	1.104;

1.104
date	2009.12.29.13.51.50;	author espie;	state Exp;
branches;
next	1.103;

1.103
date	2009.12.28.21.30.09;	author espie;	state Exp;
branches;
next	1.102;

1.102
date	2009.12.28.10.42.02;	author espie;	state Exp;
branches;
next	1.101;

1.101
date	2009.12.27.22.26.28;	author espie;	state Exp;
branches;
next	1.100;

1.100
date	2009.12.26.21.14.57;	author espie;	state Exp;
branches;
next	1.99;

1.99
date	2009.12.20.22.38.45;	author espie;	state Exp;
branches;
next	1.98;

1.98
date	2009.12.13.17.54.15;	author espie;	state Exp;
branches;
next	1.97;

1.97
date	2009.12.11.21.04.01;	author espie;	state Exp;
branches;
next	1.96;

1.96
date	2009.12.07.13.41.02;	author espie;	state Exp;
branches;
next	1.95;

1.95
date	2009.12.05.11.45.35;	author espie;	state Exp;
branches;
next	1.94;

1.94
date	2009.12.04.15.42.24;	author espie;	state Exp;
branches;
next	1.93;

1.93
date	2009.12.04.10.45.20;	author espie;	state Exp;
branches;
next	1.92;

1.92
date	2009.12.03.18.49.59;	author espie;	state Exp;
branches;
next	1.91;

1.91
date	2009.12.03.18.43.46;	author espie;	state Exp;
branches;
next	1.90;

1.90
date	2009.12.02.11.36.27;	author espie;	state Exp;
branches;
next	1.89;

1.89
date	2009.11.29.13.19.29;	author espie;	state Exp;
branches;
next	1.88;

1.88
date	2009.11.29.11.49.01;	author espie;	state Exp;
branches;
next	1.87;

1.87
date	2009.11.29.11.22.25;	author espie;	state Exp;
branches;
next	1.86;

1.86
date	2009.11.29.07.06.17;	author espie;	state Exp;
branches;
next	1.85;

1.85
date	2009.11.28.10.25.34;	author espie;	state Exp;
branches;
next	1.84;

1.84
date	2009.11.11.12.32.03;	author espie;	state Exp;
branches;
next	1.83;

1.83
date	2009.11.11.12.21.20;	author espie;	state Exp;
branches;
next	1.82;

1.82
date	2009.11.11.12.04.19;	author espie;	state Exp;
branches;
next	1.81;

1.81
date	2009.11.10.11.36.56;	author espie;	state Exp;
branches;
next	1.80;

1.80
date	2009.11.10.10.58.32;	author espie;	state Exp;
branches;
next	1.79;

1.79
date	2009.11.08.11.18.41;	author espie;	state Exp;
branches;
next	1.78;

1.78
date	2009.10.19.14.20.55;	author espie;	state Exp;
branches;
next	1.77;

1.77
date	2009.10.15.22.41.50;	author espie;	state Exp;
branches;
next	1.76;

1.76
date	2009.10.15.22.32.13;	author espie;	state Exp;
branches;
next	1.75;

1.75
date	2009.10.15.22.21.25;	author espie;	state Exp;
branches;
next	1.74;

1.74
date	2009.10.15.20.51.28;	author espie;	state Exp;
branches;
next	1.73;

1.73
date	2009.10.15.18.40.32;	author espie;	state Exp;
branches;
next	1.72;

1.72
date	2009.10.15.10.45.47;	author espie;	state Exp;
branches;
next	1.71;

1.71
date	2009.10.12.11.57.36;	author espie;	state Exp;
branches;
next	1.70;

1.70
date	2009.10.12.11.35.20;	author espie;	state Exp;
branches;
next	1.69;

1.69
date	2009.10.12.10.57.27;	author espie;	state Exp;
branches;
next	1.68;

1.68
date	2009.10.11.16.46.37;	author espie;	state Exp;
branches;
next	1.67;

1.67
date	2009.10.11.12.35.53;	author espie;	state Exp;
branches;
next	1.66;

1.66
date	2009.10.11.11.26.40;	author espie;	state Exp;
branches;
next	1.65;

1.65
date	2009.04.19.14.58.32;	author espie;	state Exp;
branches;
next	1.64;

1.64
date	2008.06.21.14.01.10;	author espie;	state Exp;
branches;
next	1.63;

1.63
date	2008.06.11.12.43.13;	author espie;	state Exp;
branches;
next	1.62;

1.62
date	2008.06.11.12.21.03;	author espie;	state Exp;
branches;
next	1.61;

1.61
date	2008.06.10.10.52.52;	author espie;	state Exp;
branches;
next	1.60;

1.60
date	2008.03.08.12.07.45;	author espie;	state Exp;
branches;
next	1.59;

1.59
date	2007.06.26.14.40.25;	author espie;	state Exp;
branches;
next	1.58;

1.58
date	2007.06.19.10.47.28;	author espie;	state Exp;
branches;
next	1.57;

1.57
date	2007.06.19.10.25.35;	author espie;	state Exp;
branches;
next	1.56;

1.56
date	2007.06.18.18.45.09;	author espie;	state Exp;
branches;
next	1.55;

1.55
date	2007.06.18.18.34.00;	author espie;	state Exp;
branches;
next	1.54;

1.54
date	2007.06.18.18.06.28;	author espie;	state Exp;
branches;
next	1.53;

1.53
date	2007.06.09.10.39.16;	author espie;	state Exp;
branches;
next	1.52;

1.52
date	2007.06.05.23.19.00;	author espie;	state Exp;
branches;
next	1.51;

1.51
date	2007.06.04.16.58.40;	author espie;	state Exp;
branches;
next	1.50;

1.50
date	2007.06.02.12.45.24;	author espie;	state Exp;
branches;
next	1.49;

1.49
date	2007.06.02.12.37.37;	author espie;	state Exp;
branches;
next	1.48;

1.48
date	2007.06.02.12.21.14;	author espie;	state Exp;
branches;
next	1.47;

1.47
date	2007.06.02.11.30.06;	author espie;	state Exp;
branches;
next	1.46;

1.46
date	2007.06.02.11.24.22;	author espie;	state Exp;
branches;
next	1.45;

1.45
date	2007.06.02.11.18.46;	author espie;	state Exp;
branches;
next	1.44;

1.44
date	2007.06.01.22.35.46;	author espie;	state Exp;
branches;
next	1.43;

1.43
date	2007.05.31.22.33.45;	author espie;	state Exp;
branches;
next	1.42;

1.42
date	2007.05.31.16.48.18;	author espie;	state Exp;
branches;
next	1.41;

1.41
date	2007.05.29.23.12.26;	author espie;	state Exp;
branches;
next	1.40;

1.40
date	2007.05.27.11.36.21;	author espie;	state Exp;
branches;
next	1.39;

1.39
date	2007.05.23.10.33.45;	author espie;	state Exp;
branches;
next	1.38;

1.38
date	2007.05.19.23.40.46;	author espie;	state Exp;
branches;
next	1.37;

1.37
date	2007.05.18.12.18.33;	author espie;	state Exp;
branches;
next	1.36;

1.36
date	2007.05.18.09.45.18;	author espie;	state Exp;
branches;
next	1.35;

1.35
date	2007.05.17.15.40.06;	author espie;	state Exp;
branches;
next	1.34;

1.34
date	2007.05.17.15.35.58;	author espie;	state Exp;
branches;
next	1.33;

1.33
date	2007.05.17.14.08.49;	author espie;	state Exp;
branches;
next	1.32;

1.32
date	2007.05.17.13.58.44;	author espie;	state Exp;
branches;
next	1.31;

1.31
date	2007.05.17.13.36.21;	author espie;	state Exp;
branches;
next	1.30;

1.30
date	2007.05.14.18.19.25;	author espie;	state Exp;
branches;
next	1.29;

1.29
date	2007.05.14.17.52.08;	author espie;	state Exp;
branches;
next	1.28;

1.28
date	2007.05.14.17.48.32;	author espie;	state Exp;
branches;
next	1.27;

1.27
date	2007.05.14.11.22.00;	author espie;	state Exp;
branches;
next	1.26;

1.26
date	2007.05.14.11.02.14;	author espie;	state Exp;
branches;
next	1.25;

1.25
date	2007.05.14.10.53.31;	author espie;	state Exp;
branches;
next	1.24;

1.24
date	2007.05.14.10.43.45;	author espie;	state Exp;
branches;
next	1.23;

1.23
date	2007.05.14.09.49.27;	author espie;	state Exp;
branches;
next	1.22;

1.22
date	2007.05.13.13.32.36;	author espie;	state Exp;
branches;
next	1.21;

1.21
date	2007.05.12.15.19.00;	author espie;	state Exp;
branches;
next	1.20;

1.20
date	2007.05.12.14.38.30;	author espie;	state Exp;
branches;
next	1.19;

1.19
date	2007.05.07.13.27.28;	author espie;	state Exp;
branches;
next	1.18;

1.18
date	2007.05.07.13.12.11;	author espie;	state Exp;
branches;
next	1.17;

1.17
date	2007.05.07.12.19.04;	author espie;	state Exp;
branches;
next	1.16;

1.16
date	2007.05.07.08.18.02;	author espie;	state Exp;
branches;
next	1.15;

1.15
date	2007.05.07.08.14.51;	author espie;	state Exp;
branches;
next	1.14;

1.14
date	2007.05.07.08.10.45;	author espie;	state Exp;
branches;
next	1.13;

1.13
date	2007.05.07.08.06.47;	author espie;	state Exp;
branches;
next	1.12;

1.12
date	2007.05.02.15.17.36;	author espie;	state Exp;
branches;
next	1.11;

1.11
date	2007.05.02.15.05.29;	author espie;	state Exp;
branches;
next	1.10;

1.10
date	2007.05.02.13.36.07;	author espie;	state Exp;
branches;
next	1.9;

1.9
date	2007.05.02.12.23.59;	author espie;	state Exp;
branches;
next	1.8;

1.8
date	2007.05.01.19.41.37;	author espie;	state Exp;
branches;
next	1.7;

1.7
date	2007.04.15.10.17.29;	author espie;	state Exp;
branches;
next	1.6;

1.6
date	2007.02.04.12.18.39;	author espie;	state Exp;
branches;
next	1.5;

1.5
date	2006.11.17.15.34.15;	author espie;	state Exp;
branches;
next	1.4;

1.4
date	2005.10.10.11.24.34;	author espie;	state Exp;
branches;
next	1.3;

1.3
date	2005.09.04.22.47.56;	author espie;	state Exp;
branches;
next	1.2;

1.2
date	2005.08.10.11.36.28;	author espie;	state Exp;
branches;
next	1.1;

1.1
date	2005.08.07.16.25.35;	author espie;	state Exp;
branches;
next	;


desc
@@


1.157
log
@tweak dependencies handling, might fix some infrequent bugs including the
infamous cups bug.
- look for candidates in the whole new set first. Yep, that includes kept
packages (should make things slightly faster, I expect)
- correctly remove caching of list of installed packages outsides of old
packages from the current set each time we revisit the set (looking at the
old behavior this actually sounds very likely).
@
text
@# ex:ts=8 sw=4:
# $OpenBSD: Dependencies.pm,v 1.156 2015/08/14 10:12:02 espie Exp $
#
# Copyright (c) 2005-2010 Marc Espie <espie@@openbsd.org>
#
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF

use strict;
use warnings;

use OpenBSD::SharedLibs;

# generic dependencies lookup class: walk the dependency tree as far
# as necessary to resolve dependencies
package OpenBSD::lookup;

sub lookup
{
	my ($self, $solver, $dependencies, $state, $obj) = @@_;

	my $known = $self->{known};
	if (my $r = $self->find_in_already_done($solver, $state, $obj)) {
		$dependencies->{$r} = 1;
		return 1;
	}
	if ($self->find_in_extra_sources($solver, $state, $obj)) {
		return 1;
	}
	# lookup through the rest of the tree...
	my $done = $self->{done};
	while (my $dep = pop @@{$self->{todo}}) {
		require OpenBSD::RequiredBy;

		next if $done->{$dep};
		$done->{$dep} = 1;
		for my $dep2 (OpenBSD::Requiring->new($dep)->list) {
			push(@@{$self->{todo}}, $dep2) unless $done->{$dep2};
		}
		$known->{$dep} = 1;
		if ($self->find_in_new_source($solver, $state, $obj, $dep)) {
			$dependencies->{$dep} = 1;
			return 1;
		}
	}
	if (my $r = $self->find_elsewhere($solver, $state, $obj)) {
		$dependencies->{$r} = 1;
		return 1;
	}

	return 0;
}

sub new
{
	my ($class, $solver) = @@_;

	# prepare for closure
	my @@todo = $solver->dependencies;
	bless { todo => \@@todo, done => {}, known => {} }, $class;
}

sub dump
{
	my ($self, $state) = @@_;

	return unless %{$self->{done}};
	$state->say("Full dependency tree is #1",
	    join(' ', keys %{$self->{done}}));
}

package OpenBSD::lookup::library;
our @@ISA=qw(OpenBSD::lookup);

sub say_found
{
	my ($self, $state, $obj, $where) = @@_;

	$state->say("found libspec #1 in #2", $obj->to_string, $where)
	    if $state->verbose >= 3;
}

sub find_in_already_done
{
	my ($self, $solver, $state, $obj) = @@_;


	my $r = $solver->check_lib_spec($solver->{localbase}, $obj,
	    $self->{known});
	if ($r) {
		$self->say_found($state, $obj, $state->f("package #1", $r));
		return $r;
	} else {
		return undef;
	}
}

sub find_in_extra_sources
{
	my ($self, $solver, $state, $obj) = @@_;
	return undef if !$obj->is_valid || defined $obj->{dir};

	OpenBSD::SharedLibs::add_libs_from_system($state->{destdir}, $state);
	for my $dir (OpenBSD::SharedLibs::system_dirs()) {
		if ($solver->check_lib_spec($dir, $obj, {system => 1})) {
			$self->say_found($state, $obj, $state->f("#1/lib", $dir));
			return 'system';
		}
	}
	return undef;
}

sub find_in_new_source
{
	my ($self, $solver, $state, $obj, $dep) = @@_;

	if (defined $solver->{set}->{newer}->{$dep}) {
		OpenBSD::SharedLibs::add_libs_from_plist($solver->{set}->{newer}->{$dep}->plist, $state);
	} else {
		OpenBSD::SharedLibs::add_libs_from_installed_package($dep, $state);
	}
	if ($solver->check_lib_spec($solver->{localbase}, $obj, {$dep => 1})) {
		$self->say_found($state, $obj, $state->f("package #1", $dep));
		return $dep;
	}
	return undef;
}

sub find_elsewhere
{
	my ($self, $solver, $state, $obj) = @@_;

	for my $n ($solver->{set}->newer) {
		for my $dep (@@{$n->dependency_info->{depend}}) {
			my $r = $solver->find_old_lib($state,
			    $solver->{localbase}, $dep->{pattern}, $obj);
			if ($r) {
				$self->say_found($state, $obj,
				    $state->f("old package #1", $r));
				return $r;
			}
		}
	}
	return undef;
}

package OpenBSD::lookup::tag;
our @@ISA=qw(OpenBSD::lookup);
sub find_in_extra_sources
{
}

sub find_elsewhere
{
}

sub find_in_already_done
{
	my ($self, $solver, $state, $obj) = @@_;
	my $r = $self->{known_tags}->{$obj};
	if (defined $r) {
		$state->say("Found tag #1 in #2", $obj, $r)
		    if $state->verbose >= 3;
	}
	return $r;
}

sub find_in_plist
{
	my ($self, $plist, $dep) = @@_;
	if ($plist->has('define-tag')) {
		for my $t (@@{$plist->{'define-tag'}}) {
			$self->{known_tags}->{$t->name} = $dep;
		}
	}
}

sub find_in_new_source
{
	my ($self, $solver, $state, $obj, $dep) = @@_;
	my $plist = OpenBSD::PackingList->from_installation($dep,
	    \&OpenBSD::PackingList::DependOnly);
	if (!defined $plist) {
		$state->errsay("Can't read plist for #1", $dep);
	}
	$self->find_in_plist($plist, $dep);
	return $self->find_in_already_done($solver, $state, $obj);
}

package _cache;

sub new
{
	my ($class, $v) = @@_;
	bless \$v, $class;
}

sub pretty
{
	my $self = shift;
	return ref($self)."(".$$self.")";
}

package _cache::self;
our @@ISA=(qw(_cache));
sub do
{
	my ($v, $solver, $state, $dep, $package) = @@_;
	push(@@{$package->{before}}, $$v);
	return $$v;
}

package _cache::installed;
our @@ISA=(qw(_cache));
sub do
{
	my ($v, $solver, $state, $dep, $package) = @@_;
	return $$v;
}

package _cache::bad;
our @@ISA=(qw(_cache));
sub do
{
	my ($v, $solver, $state, $dep, $package) = @@_;
	return $$v;
}

package _cache::to_install;
our @@ISA=(qw(_cache));
sub do
{
	my ($v, $solver, $state, $dep, $package) = @@_;
	if ($state->tracker->{uptodate}{$$v}) {
		bless $v, "_cache::installed";
		$solver->set_global($dep, $v);
		return $$v;
	}
	if ($state->tracker->{cant_install}{$$v}) {
		bless $v, "_cache::bad";
		$solver->set_global($dep, $v);
		return $$v;
	}
	if ($state->tracker->{to_install}{$$v}) {
		my $set = $state->tracker->{to_install}{$$v};
		if ($set->real_set eq $solver->{set}) {
			bless $v, "_cache::self";
			return $v->do($solver, $state, $dep, $package);
		} else {
			$solver->add_dep($set);
			return $$v;
		}
	}
	return;
}

package _cache::to_update;
our @@ISA=(qw(_cache));
sub do
{
	my ($v, $solver, $state, $dep, $package) = @@_;
	my $alt = $solver->find_dep_in_self($state, $dep);
	if ($alt) {
		$solver->set_cache($dep, _cache::self->new($alt));
		push(@@{$package->{before}}, $alt);
		return $alt;
	}

	if ($state->tracker->{to_update}{$$v}) {
		$solver->add_dep($state->tracker->{to_update}{$$v});
		return $$v;
	}
	if ($state->tracker->{uptodate}{$$v}) {
		bless $v, "_cache::installed";
		$solver->set_global($dep, $v);
		return $$v;
	}
	if ($state->tracker->{cant_update}{$$v}) {
		bless $v, "_cache::bad";
		$solver->set_global($dep, $v);
		return $$v;
	}
	my @@candidates = $dep->spec->filter(keys %{$state->tracker->{installed}});
	if (@@candidates > 0) {
		$solver->set_global($dep, _cache::installed->new($candidates[0]));
		return $candidates[0];
	}
	return;
}

package OpenBSD::Cloner;
sub clone
{
	my ($self, $h, @@extra) = @@_;
	for my $extra (@@extra) {
		next unless defined $extra;
		while (my ($k, $e) = each %{$extra->{$h}}) {
			$self->{$h}{$k} //= $e;
		}
	}
}

package OpenBSD::Dependencies::SolverBase;
our @@ISA = qw(OpenBSD::Cloner);

my $global_cache = {};

sub cached
{
	my ($self, $dep) = @@_;
	return $global_cache->{$dep->{pattern}} ||
	    $self->{cache}{$dep->{pattern}};
}

sub set_cache
{
	my ($self, $dep, $value) = @@_;
	$self->{cache}{$dep->{pattern}} = $value;
}

sub set_global
{
	my ($self, $dep, $value) = @@_;
	$global_cache->{$dep->{pattern}} = $value;
}

sub global_cache
{
	my ($self, $pattern) = @@_;
	return $global_cache->{$pattern};
}

sub find_candidate
{
	my ($self, $dep, @@list) = @@_;
	my @@candidates = $dep->spec->filter(@@list);
	if (@@candidates >= 1) {
		return $candidates[0];
	} else {
		return undef;
	}
}

sub solve_dependency
{
	my ($self, $state, $dep, $package) = @@_;

	my $v;

	if (defined $self->cached($dep)) {
		if ($state->defines('stat_cache')) {
			if (defined $self->global_cache($dep->{pattern})) {
				$state->print("Global ");
			}
			$state->say("Cache hit on #1: #2", $dep->{pattern},
			    $self->cached($dep)->pretty);
		}
		$v = $self->cached($dep)->do($self, $state, $dep, $package);
		return $v if $v;
	}
	if ($state->defines('stat_cache')) {
		$state->say("No cache hit on #1", $dep->{pattern});
	}

	$self->really_solve_dependency($state, $dep, $package);
}

sub solve_depends
{
	my ($self, $state) = @@_;

	$self->{all_dependencies} = {};
	$self->{to_register} = {};
	$self->{deplist} = {};
	delete $self->{installed_list};

	for my $package ($self->{set}->newer, $self->{set}->kept) {
		$package->{before} = [];
		for my $dep (@@{$package->dependency_info->{depend}}) {
			my $v = $self->solve_dependency($state, $dep, $package);
			# XXX
			next if !defined $v;
			$self->{all_dependencies}{$v} = $dep;
			$self->{to_register}{$package}{$v} = $dep;
		}
	}

	return values %{$self->{deplist}};
}

sub solve_wantlibs
{
	my ($solver, $state) = @@_;
	my $okay = 1;

	my $lib_finder = OpenBSD::lookup::library->new($solver);
	for my $h ($solver->{set}->newer) {
		for my $lib (@@{$h->{plist}->{wantlib}}) {
			$solver->{localbase} = $h->{plist}->localbase;
			next if $lib_finder->lookup($solver,
			    $solver->{to_register}->{$h}, $state,
			    $lib->spec);
			if ($okay) {
				$solver->errsay_library($state, $h);
			}
			$okay = 0;
			OpenBSD::SharedLibs::report_problem($state,
			    $lib->spec);
		}
	}
	if (!$okay) {
		$solver->dump($state);
		$lib_finder->dump($state);
	}
	return $okay;
}

sub dump
{
	my ($self, $state) = @@_;
	if ($self->dependencies) {
	    $state->print("Direct dependencies for #1 resolve to #2",
	    	$self->{set}->print, join(' ',  $self->dependencies));
	    $state->print(" (todo: #1)",
	    	join(' ', (map {$_->print} values %{$self->{deplist}})))
	    	if %{$self->{deplist}};
	    $state->print("\n");
	}
}

sub dependencies
{
	my $self = shift;
	if (wantarray) {
		return keys %{$self->{all_dependencies}};
	} else {
		return scalar(%{$self->{all_dependencies}});
	}
}

sub check_lib_spec
{
	my ($self, $base, $spec, $dependencies) = @@_;
	my $r = OpenBSD::SharedLibs::lookup_libspec($base, $spec);
	for my $candidate (@@$r) {
		if ($dependencies->{$candidate->origin}) {
			return $candidate->origin;
		}
	}
	return;
}

sub find_dep_in_installed
{
	my ($self, $state, $dep) = @@_;

	return $self->find_candidate($dep, @@{$self->installed_list});
}

sub find_dep_in_self
{
	my ($self, $state, $dep) = @@_;

	return $self->find_candidate($dep, $self->{set}->newer_names,
	    $self->{set}->kept_names);
}

use OpenBSD::PackageInfo;
OpenBSD::Auto::cache(installed_list,
	sub {
		my $self = shift;
		my @@l = installed_packages();

		for my $o ($self->{set}->older_names) {
			@@l = grep {$_ ne $o} @@l;
		}
		return \@@l;
	}
);

sub add_dep
{
	my ($self, $d) = @@_;
	$self->{deplist}{$d} = $d;
}

package OpenBSD::Dependencies::Solver;
our @@ISA = qw(OpenBSD::Dependencies::SolverBase);

use OpenBSD::PackageInfo;

sub merge
{
	my ($solver, @@extra) = @@_;

	$solver->clone('cache', @@extra);
}

sub new
{
	my ($class, $set) = @@_;
	bless { set => $set, bad => [] }, $class;
}

sub check_for_loops
{
	my ($self, $state) = @@_;

	my $initial = $self->{set};

	my @@todo = ();
	my @@to_merge = ();
	push(@@todo, $initial);
	my $done = {};

	while (my $set = shift @@todo) {
		next unless defined $set->{solver};
		for my $l (values %{$set->solver->{deplist}}) {
			if ($l eq $initial) {
				push(@@to_merge, $set);
			}
			next if $done->{$l};
			next if $done->{$l->real_set};
			push(@@todo, $l);
			$done->{$l} = $set;
		}
	}
	if (@@to_merge > 0) {
		my $merged = {};
		my @@real = ();
		$state->say("Detected loop, merging sets #1", $state->ntogo);
		$state->say("| #1", $initial->print);
		for my $set (@@to_merge) {
			my $k = $set;
			while ($k ne $initial && !$merged->{$k}) {
				unless ($k->{finished}) {
					$state->say("| #1", $k->print);
					delete $k->solver->{deplist};
					delete $k->solver->{to_register};
					push(@@real, $k);
				}
				$merged->{$k} = 1;
				$k = $done->{$k};
			}
		}
		delete $initial->solver->{deplist};
		delete $initial->solver->{to_register};
		$initial->merge($state->tracker, @@real);
	}
}

sub find_dep_in_repositories
{
	my ($self, $state, $dep) = @@_;

	return unless $dep->spec->is_valid;

	my $candidates = $self->{set}->match_locations($dep->spec);
	if (!$state->defines('allversions')) {
		require OpenBSD::Search;
		$candidates = OpenBSD::Search::FilterLocation->
		    keep_most_recent->filter_locations($candidates);
	}
	# XXX not really efficient, but hey
	my %c = map {($_->name, $_)} @@$candidates;
	my @@pkgs = keys %c;
	if (@@pkgs == 1) {
		return $candidates->[0];
	} elsif (@@pkgs > 1) {
		# unless -ii, we return the def if available
		if ($state->is_interactive < 2) {
			if (defined(my $d = $c{$dep->{def}})) {
				return $d;
			}
		}
		# put default first if available
		@@pkgs = ((grep {$_ eq $dep->{def}} @@pkgs),
		    (sort (grep {$_ ne $dep->{def}} @@pkgs)));
		my $good = $state->ask_list(
		    'Ambiguous: choose dependency for '.$self->{set}->print.': ',
		    @@pkgs);
		return $c{$good};
	} else {
		return;
	}
}

sub find_dep_in_stuff_to_install
{
	my ($self, $state, $dep) = @@_;

	my $v = $self->find_candidate($dep,
	    keys %{$state->tracker->{uptodate}});
	if ($v) {
		$self->set_global($dep, _cache::installed->new($v));
		return $v;
	}
	# this is tricky, we don't always know what we're going to actually
	# install yet.
	my @@candidates = $dep->spec->filter(keys %{$state->tracker->{to_update}});
	if (@@candidates > 0) {
		for my $k (@@candidates) {
			my $set = $state->tracker->{to_update}{$k};
			$self->add_dep($set);
		}
		if (@@candidates == 1) {
			$self->set_cache($dep,
			    _cache::to_update->new($candidates[0]));
		}
		return $candidates[0];
	}

	$v = $self->find_candidate($dep, keys %{$state->tracker->{to_install}});
	if ($v) {
		$self->set_cache($dep, _cache::to_install->new($v));
		$self->add_dep($state->tracker->{to_install}->{$v});
	}
	return $v;
}

sub really_solve_dependency
{
	my ($self, $state, $dep, $package) = @@_;

	my $v;

	if ($state->{allow_replacing}) {

		$v = $self->find_dep_in_self($state, $dep);
		if ($v) {
			$self->set_cache($dep, _cache::self->new($v));
			push(@@{$package->{before}}, $v);
			return $v;
		}
		$v = $self->find_candidate($dep, $self->{set}->older_names);
		if ($v) {
			push(@@{$self->{bad}}, $dep->{pattern});
			return $v;
		}
		$v = $self->find_dep_in_stuff_to_install($state, $dep);
		return $v if $v;
	}

	$v = $self->find_dep_in_installed($state, $dep);
	if ($v) {
		if ($state->{newupdates}) {
			if ($state->tracker->is_known($v)) {
				return $v;
			}
			my $set = $state->updateset->add_older(OpenBSD::Handle->create_old($v, $state));
			$set->merge_paths($self->{set});
			$self->add_dep($set);
			$self->set_cache($dep, _cache::to_update->new($v));
			$state->tracker->todo($set);
		}
		return $v;
	}
	if (!$state->{allow_replacing}) {
		$v = $self->find_dep_in_stuff_to_install($state, $dep);
		return $v if $v;
	}

	$v = $self->find_dep_in_repositories($state, $dep);

	my $s;
	if ($v) {
		$s = $state->updateset_from_location($v);
		$v = $v->name;
	} else {
		# resort to default if nothing else
		$v = $dep->{def};
		$s = $state->updateset_with_new($v);
	}

	$s->merge_paths($self->{set});
	$state->tracker->todo($s);
	$self->add_dep($s);
	$self->set_cache($dep, _cache::to_install->new($v));
	return $v;
}

sub check_depends
{
	my $self = shift;

	for my $dep ($self->dependencies) {
		push(@@{$self->{bad}}, $dep)
		    unless is_installed($dep) or
		    	defined $self->{set}{newer}{$dep};
	}
	return $self->{bad};
}

sub register_dependencies
{
	my ($self, $state) = @@_;

	require OpenBSD::RequiredBy;
	for my $pkg ($self->{set}->newer) {
		my $pkgname = $pkg->pkgname;
		my @@l = keys %{$self->{to_register}{$pkg}};

		OpenBSD::Requiring->new($pkgname)->add(@@l);
		for my $dep (@@l) {
			OpenBSD::RequiredBy->new($dep)->add($pkgname);
		}
	}
}

sub repair_dependencies
{
	my ($self, $state) = @@_;
	for my $p ($self->{set}->newer) {
		my $pkgname = $p->pkgname;
		for my $pkg (installed_packages(1)) {
			my $plist = OpenBSD::PackingList->from_installation(
			    $pkg, \&OpenBSD::PackingList::DependOnly);
			$plist->repair_dependency($pkg, $pkgname);
		}
	}
}

sub find_old_lib
{
	my ($self, $state, $base, $pattern, $lib) = @@_;

	require OpenBSD::Search;

	my $r = $state->repo->installed->match_locations(OpenBSD::Search::PkgSpec->new(".libs-".$pattern));
	for my $try (map {$_->name} @@$r) {
		OpenBSD::SharedLibs::add_libs_from_installed_package($try, $state);
		if ($self->check_lib_spec($base, $lib, {$try => 1})) {
			return $try;
		}
	}
	return undef;
}

sub errsay_library
{
	my ($solver, $state, $h) = @@_;

	$state->errsay("Can't install #1 because of libraries", $h->pkgname);
}

sub solve_tags
{
	my ($solver, $state) = @@_;
	my $okay = 1;

	my $tag_finder = OpenBSD::lookup::tag->new($solver);
	for my $h ($solver->{set}->newer) {
		for my $tag (keys %{$h->{plist}->{tags}}) {
			next if $tag_finder->lookup($solver,
			    $solver->{to_register}->{$h}, $state, $tag);
			$state->errsay("Can't install #1: tag definition not found #2",
			    $h->pkgname, $tag);
			if ($okay) {
				$solver->dump($state);
				$tag_finder->dump($state);
				$okay = 0;
			}
	    	}
	}
	return $okay;
}

package OpenBSD::PackingElement;
sub repair_dependency
{
}

package OpenBSD::PackingElement::Dependency;
sub repair_dependency
{
	my ($self, $requiring, $required) = @@_;
	if ($self->spec->filter($required) == 1) {
		require OpenBSD::RequiredBy;
		OpenBSD::RequiredBy->new($required)->add($requiring);
		OpenBSD::Requiring->new($requiring)->add($required);
	}
}

1;
@


1.156
log
@remove partial to_register from sets when we merge, since we have to do the
work again.

Should solve the +REQUIRED_BY problem hopefully.
@
text
@d2 1
a2 1
# $OpenBSD: Dependencies.pm,v 1.155 2015/01/30 11:42:55 espie Exp $
d383 1
a383 1
	delete $self->{installed};
d391 2
a392 2
			$self->{all_dependencies}->{$v} = $dep;
			$self->{to_register}->{$package}->{$v} = $dep;
d472 2
a473 1
	return $self->find_candidate($dep, $self->{set}->newer_names);
d697 1
a697 1
		    	defined $self->{set}->{newer}->{$dep};
d709 1
a709 1
		my @@l = keys %{$self->{to_register}->{$pkg}};
@


1.155
log
@Fix the default interactive level to install the "default" dependencies.
Actually testing it caused me to write correct (and simpler) code...
@
text
@d2 1
a2 1
# $OpenBSD: Dependencies.pm,v 1.154 2014/11/30 15:56:34 espie Exp $
d546 1
d554 1
@


1.154
log
@interactive/progressmeter clean-up
@
text
@d2 1
a2 1
# $OpenBSD: Dependencies.pm,v 1.153 2014/11/30 09:49:48 espie Exp $
d575 6
@


1.153
log
@clear progress meter before asking questions
From Carlin Bingham
@
text
@d2 1
a2 1
# $OpenBSD: Dependencies.pm,v 1.152 2014/02/01 11:37:58 espie Exp $
a574 2
		require OpenBSD::Interactive;

a577 1
		$state->progress->clear;
d580 1
a580 1
		    $state->{interactive}, @@pkgs);
@


1.152
log
@let solve_depends work as soon as we have update_info
@
text
@d2 1
a2 1
# $OpenBSD: Dependencies.pm,v 1.151 2010/12/24 09:04:14 espie Exp $
d580 1
@


1.151
log
@handle failures from ports tree with more care.
this does avoid infinite loops in case of wrong plists.
necessary since print-plist-with-depends CAN fail...
@
text
@d2 1
a2 1
# $OpenBSD$
d142 1
a142 1
		for my $dep (@@{$n->{plist}->{depend}}) {
d387 1
a387 1
		for my $dep (@@{$package->{plist}->{depend}}) {
@


1.150
log
@fix, as noticed  by dcoppa@@
@
text
@d2 1
a2 1
# $OpenBSD: Dependencies.pm,v 1.149 2010/12/21 11:25:19 espie Exp $
d76 1
a76 1
	$state->say("Full dependency tree is #1", 
d170 1
a170 1
		$state->say("Found tag #1 in #2", $obj, $r) 
d593 1
a593 1
	my $v = $self->find_candidate($dep, 
@


1.149
log
@simplify a bit:
- make find_dep_in_installed more regular
- zap the {more} entry, add_dep is okay for that purpose
- don't special case installed_list, provide older_names instead
- make PseudoSets slightly less hackish
- don't read full packinglist, prelinkstuff is exactly what we need
@
text
@d2 1
a2 1
# $OpenBSD: Dependencies.pm,v 1.148 2010/12/20 16:30:03 espie Exp $
d496 2
@


1.148
log
@use a better strategy: ask the ports tree for the plist for packages with
the same pkgpath. Thus, PseudoSets need to have a real list, and
pkgcreate needs to loop to solve those depends.

reactivate the check
@
text
@d2 1
a2 1
# $OpenBSD: Dependencies.pm,v 1.147 2010/12/20 11:55:48 espie Exp $
d461 1
a461 1
sub find_in_installed
d463 1
a463 1
	my ($self, $dep) = @@_;
a474 9
package OpenBSD::Dependencies::Solver;
our @@ISA = qw(OpenBSD::Dependencies::SolverBase);

sub add_dep
{
	my ($self, $d) = @@_;
	$self->{deplist}{$d} = $d;
}

d488 8
d643 1
a643 1
	$v = $self->find_in_installed($dep);
@


1.147
log
@missed some
@
text
@d2 1
a2 1
# $OpenBSD: Dependencies.pm,v 1.146 2010/12/20 09:43:51 espie Exp $
a404 2
	$lib_finder->{known}{BUILD} = 1;
	$lib_finder->{done}{BUILD} = 1;
d468 7
a585 7
}

sub find_dep_in_self
{
	my ($self, $state, $dep) = @@_;

	return $self->find_candidate($dep, $self->{set}->newer_names);
@


1.146
log
@prepare for reuse in pkgcreate: allow not finding stuff and not failing
also mark as known a special package known as BUILD
@
text
@d2 1
a2 1
# $OpenBSD: Dependencies.pm,v 1.145 2010/12/20 09:41:44 espie Exp $
d406 1
@


1.145
log
@split solver class into a base that can be reused from pkgcreate.
@
text
@d2 1
a2 1
# $OpenBSD: Dependencies.pm,v 1.144 2010/12/20 09:38:40 espie Exp $
d389 2
d405 1
@


1.144
log
@more refactor: errsay_library
@
text
@d2 1
a2 1
# $OpenBSD: Dependencies.pm,v 1.143 2010/12/20 09:30:40 espie Exp $
d311 1
a311 1
package OpenBSD::Dependencies::Solver;
d465 3
@


1.143
log
@more refactor: method for global_cache, add find_in_installed, separate
cache handling from the rest for solve_dependency
@
text
@d2 1
a2 1
# $OpenBSD: Dependencies.pm,v 1.142 2010/12/20 09:23:23 espie Exp $
d410 1
a410 1
				$state->errsay("Can't install #1 because of libraries", $h->pkgname);
d476 1
a477 1
		my @@l = installed_packages();
d732 7
@


1.142
log
@move stuff around
@
text
@d2 1
a2 1
# $OpenBSD: Dependencies.pm,v 1.141 2010/12/20 09:10:51 espie Exp $
d335 6
d360 1
a360 1
			if (defined $global_cache->{$dep->{pattern}}) {
d373 1
a373 53
	if ($state->{allow_replacing}) {

		$v = $self->find_dep_in_self($state, $dep);
		if ($v) {
			$self->set_cache($dep, _cache::self->new($v));
			push(@@{$package->{before}}, $v);
			return $v;
		}
		$v = $self->find_candidate($dep, $self->{set}->older_names);
		if ($v) {
			push(@@{$self->{bad}}, $dep->{pattern});
			return $v;
		}
		$v = $self->find_dep_in_stuff_to_install($state, $dep);
		return $v if $v;
	}

	$v = $self->find_candidate($dep, @@{$self->installed_list});
	if ($v) {
		if ($state->{newupdates}) {
			if ($state->tracker->is_known($v)) {
				return $v;
			}
			my $set = $state->updateset->add_older(OpenBSD::Handle->create_old($v, $state));
			$set->merge_paths($self->{set});
			$self->add_dep($set);
			$self->set_cache($dep, _cache::to_update->new($v));
			$state->tracker->todo($set);
		}
		return $v;
	}
	if (!$state->{allow_replacing}) {
		$v = $self->find_dep_in_stuff_to_install($state, $dep);
		return $v if $v;
	}

	$v = $self->find_dep_in_repositories($state, $dep);

	my $s;
	if ($v) {
		$s = $state->updateset_from_location($v);
		$v = $v->name;
	} else {
		# resort to default if nothing else
		$v = $dep->{def};
		$s = $state->updateset_with_new($v);
	}

	$s->merge_paths($self->{set});
	$state->tracker->todo($s);
	$self->add_dep($s);
	$self->set_cache($dep, _cache::to_install->new($v));
	return $v;
d459 7
d613 61
@


1.141
log
@use Auto::cache
@
text
@d2 1
a2 1
# $OpenBSD: Dependencies.pm,v 1.140 2010/12/20 09:08:42 espie Exp $
d20 2
d312 102
a413 1
our @@ISA = (qw(OpenBSD::Cloner));
d415 77
a491 1
use OpenBSD::PackageInfo;
d493 11
a503 1
my $global_cache = {};
d511 14
a531 11
sub find_candidate
{
	    my ($self, $dep, @@list) = @@_;
	    my @@candidates = $dep->spec->filter(@@list);
	    if (@@candidates >= 1) {
		    return $candidates[0];
	    } else {
		    return undef;
	    }
}

a582 10
sub dependencies
{
	my $self = shift;
	if (wantarray) {
		return keys %{$self->{all_dependencies}};
	} else {
		return scalar(%{$self->{all_dependencies}});
	}
}

a654 128
sub cached
{
	my ($self, $dep) = @@_;
	return $global_cache->{$dep->{pattern}} ||
	    $self->{cache}{$dep->{pattern}};
}

sub set_cache
{
	my ($self, $dep, $value) = @@_;
	$self->{cache}{$dep->{pattern}} = $value;
}

sub set_global
{
	my ($self, $dep, $value) = @@_;
	$global_cache->{$dep->{pattern}} = $value;
}

OpenBSD::Auto::cache(installed_list,
	sub {
		my $self = shift;

		my @@l = installed_packages();
		for my $o ($self->{set}->older_names) {
			@@l = grep {$_ ne $o} @@l;
		}
		return \@@l;
	}
);

sub solve_dependency
{
	my ($self, $state, $dep, $package) = @@_;

	my $v;

	if (defined $self->cached($dep)) {
		if ($state->defines('stat_cache')) {
			if (defined $global_cache->{$dep->{pattern}}) {
				$state->print("Global ");
			}
			$state->say("Cache hit on #1: #2", $dep->{pattern},
			    $self->cached($dep)->pretty);
		}
		$v = $self->cached($dep)->do($self, $state, $dep, $package);
		return $v if $v;
	}
	if ($state->defines('stat_cache')) {
		$state->say("No cache hit on #1", $dep->{pattern});
	}

	if ($state->{allow_replacing}) {

		$v = $self->find_dep_in_self($state, $dep);
		if ($v) {
			$self->set_cache($dep, _cache::self->new($v));
			push(@@{$package->{before}}, $v);
			return $v;
		}
		$v = $self->find_candidate($dep, $self->{set}->older_names);
		if ($v) {
			push(@@{$self->{bad}}, $dep->{pattern});
			return $v;
		}
		$v = $self->find_dep_in_stuff_to_install($state, $dep);
		return $v if $v;
	}

	$v = $self->find_candidate($dep, @@{$self->installed_list});
	if ($v) {
		if ($state->{newupdates}) {
			if ($state->tracker->is_known($v)) {
				return $v;
			}
			my $set = $state->updateset->add_older(OpenBSD::Handle->create_old($v, $state));
			$set->merge_paths($self->{set});
			$self->add_dep($set);
			$self->set_cache($dep, _cache::to_update->new($v));
			$state->tracker->todo($set);
		}
		return $v;
	}
	if (!$state->{allow_replacing}) {
		$v = $self->find_dep_in_stuff_to_install($state, $dep);
		return $v if $v;
	}

	$v = $self->find_dep_in_repositories($state, $dep);

	my $s;
	if ($v) {
		$s = $state->updateset_from_location($v);
		$v = $v->name;
	} else {
		# resort to default if nothing else
		$v = $dep->{def};
		$s = $state->updateset_with_new($v);
	}

	$s->merge_paths($self->{set});
	$state->tracker->todo($s);
	$self->add_dep($s);
	$self->set_cache($dep, _cache::to_install->new($v));
	return $v;
}

sub solve_depends
{
	my ($self, $state) = @@_;

	$self->{all_dependencies} = {};
	$self->{to_register} = {};
	$self->{deplist} = {};
	delete $self->{installed};

	for my $package ($self->{set}->newer, $self->{set}->kept) {
		$package->{before} = [];
		for my $dep (@@{$package->{plist}->{depend}}) {
			my $v = $self->solve_dependency($state, $dep, $package);
			$self->{all_dependencies}->{$v} = $dep;
			$self->{to_register}->{$package}->{$v} = $dep;
		}
	}

	return values %{$self->{deplist}};
}

a666 13
sub dump
{
	my ($self, $state) = @@_;
	if ($self->dependencies) {
	    $state->print("Direct dependencies for #1 resolve to #2",
	    	$self->{set}->print, join(' ',  $self->dependencies));
	    $state->print(" (todo: #1)",
	    	join(' ', (map {$_->print} values %{$self->{deplist}})))
	    	if %{$self->{deplist}};
	    $state->print("\n");
	}
}

a695 14
use OpenBSD::SharedLibs;

sub check_lib_spec
{
	my ($self, $base, $spec, $dependencies) = @@_;
	my $r = OpenBSD::SharedLibs::lookup_libspec($base, $spec);
	for my $candidate (@@$r) {
		if ($dependencies->{$candidate->origin}) {
			return $candidate->origin;
		}
	}
	return;
}

a709 27
}

sub solve_wantlibs
{
	my ($solver, $state) = @@_;
	my $okay = 1;

	my $lib_finder = OpenBSD::lookup::library->new($solver);
	for my $h ($solver->{set}->newer) {
		for my $lib (@@{$h->{plist}->{wantlib}}) {
			$solver->{localbase} = $h->{plist}->localbase;
			next if $lib_finder->lookup($solver,
			    $solver->{to_register}->{$h}, $state,
			    $lib->spec);
			if ($okay) {
				$state->errsay("Can't install #1 because of libraries", $h->pkgname);
			}
			$okay = 0;
			OpenBSD::SharedLibs::report_problem($state,
			    $lib->spec);
		}
	}
	if (!$okay) {
		$solver->dump($state);
		$lib_finder->dump($state);
	}
	return $okay;
@


1.140
log
@turn find_candidate into a real method we can inherit, tweak parameters
@
text
@d2 1
a2 1
# $OpenBSD: Dependencies.pm,v 1.139 2010/12/20 08:58:03 espie Exp $
d492 3
a494 3
sub installed_list
{
	my $self = shift;
a495 1
	if (!defined $self->{installed}) {
d500 1
a500 1
		$self->{installed} = \@@l;
d502 1
a502 2
	return $self->{installed};
}
@


1.139
log
@pass state to SharedLibs for direct printing
(also cosmetic ws)
@
text
@d2 1
a2 1
# $OpenBSD: Dependencies.pm,v 1.138 2010/12/13 12:13:54 espie Exp $
d331 2
a332 2
	    my $spec = shift;
	    my @@candidates = $spec->filter(@@_);
d437 1
a437 1
	return find_candidate($dep->spec, $self->{set}->newer_names);
d444 2
a445 1
	my $v = find_candidate($dep->spec, keys %{$state->tracker->{uptodate}});
d465 1
a465 1
	$v = find_candidate($dep->spec, keys %{$state->tracker->{to_install}});
d535 1
a535 1
		$v = find_candidate($dep->spec, $self->{set}->older_names);
d544 1
a544 1
	$v = find_candidate($dep->spec, @@{$self->installed_list});
@


1.138
log
@pass state around and use state->print
inspired by landry@@
@
text
@d2 1
a2 1
# $OpenBSD: Dependencies.pm,v 1.137 2010/11/27 11:58:12 espie Exp $
d75 1
a75 1
		join(' ', keys %{$self->{done}}));
d109 1
a109 1
	OpenBSD::SharedLibs::add_libs_from_system($state->{destdir});
d124 1
a124 1
		OpenBSD::SharedLibs::add_libs_from_plist($solver->{set}->{newer}->{$dep}->plist);
d126 1
a126 1
		OpenBSD::SharedLibs::add_libs_from_installed_package($dep);
d128 2
a129 3
	if ($solver->check_lib_spec($solver->{localbase}, $obj,
	    {$dep => 1})) {
	    	$self->say_found($state, $obj, $state->f("package #1", $dep));
d168 2
a169 1
		$state->say("Found tag #1 in #2", $obj, $r) if $state->verbose >= 3;
d277 1
a277 1
	    	return $$v;
d306 1
a306 1
    	}
d678 1
a678 1
		OpenBSD::SharedLibs::add_libs_from_installed_package($try);
@


1.137
log
@avoid infinite loops correctly this time
@
text
@d2 1
a2 1
# $OpenBSD: Dependencies.pm,v 1.136 2010/10/28 16:31:07 espie Exp $
d71 1
a71 1
	my $self = shift;
d74 2
a75 2
	print "Full dependency tree is ", join(' ', keys %{$self->{done}}),
	    "\n";
d616 1
a616 1
	my $self = shift;
d618 4
a621 5
	    print "Direct dependencies for ", $self->{set}->print,
	    	" resolve to: ", join(' ',  $self->dependencies);
	    print " (todo: ",
	    	join(' ', (map {$_->print} values %{$self->{deplist}})),
		")"
d623 1
a623 1
	    print "\n";
d707 2
a708 2
		$solver->dump;
		$lib_finder->dump;
d726 2
a727 2
				$solver->dump;
				$tag_finder->dump;
@


1.136
log
@this can't be right, as it takes out check_for_loops entirely...
(fixes cyrus-sasl install/updates, but not deinstall yet)
@
text
@d2 1
a2 1
# $OpenBSD: Dependencies.pm,v 1.135 2010/10/27 14:35:56 espie Exp $
a358 1
#		next if $set->real_set eq $initial->real_set;
d364 1
@


1.135
log
@initial scaffolding for @@rcscript: for now, acts like normal files,
but allow absolute pathnames (treat that as an implicit @@cwd).
@
text
@d2 1
a2 1
# $OpenBSD$
d359 1
a359 1
		next if $set->real_set eq $initial->real_set;
@


1.134
log
@bad works better if you push consistent stuff in it, like always strings...
@
text
@d2 1
a2 1
# $OpenBSD: Dependencies.pm,v 1.133 2010/08/07 10:26:58 espie Exp $
@


1.133
log
@need to check that kept packages are still okay.
fixes:

sudo pkg_add -r ghostscript-8.63p13-no_x11.tgz
quirks-1.17: 1/1
ghostscript-8.63p13->ghostscript-8.63p13-no_x11 forward dependencies:
| Dependency of libspectre-0.2.6 on ghostscript-*-!no_x11 doesn't match
Merging libspectre-0.2.6->libspectre-0.2.6 (1/3)
[libspectre-0.2.6]ghostscript-8.63p13->ghostscript-8.63p13-no_x11: 3/3
Read shared items: ok
@
text
@d2 1
a2 1
# $OpenBSD: Dependencies.pm,v 1.132 2010/06/30 10:51:04 espie Exp $
d536 1
a536 1
			push(@@{$self->{bad}}, $dep);
a604 1
	my @@bad = (@@{$self->{bad}});
d607 1
a607 1
		push(@@bad, $dep)
d611 1
a611 1
	return @@bad;
@


1.132
log
@allow say and errsay to work without parameters, as it's ways common.
create verbose_system up in state, because it makes sense without verbose.
@
text
@d2 1
a2 1
# $OpenBSD$
d590 1
a590 1
	for my $package ($self->{set}->newer) {
@


1.131
log
@whitespace cleanup
@
text
@@


1.130
log
@extra parameter to UpdateSet: use the factory to create extra object.
don't create updatesets directly, go through AddDelete::State.
Get all Locator/Repo access through state.
@
text
@d2 1
a2 1
# $OpenBSD: Dependencies.pm,v 1.129 2010/06/09 07:26:01 espie Exp $
@


1.129
log
@ui changes: go thru a state object for most printouts
@
text
@d2 1
a2 1
# $OpenBSD: Dependencies.pm,v 1.128 2010/06/05 07:35:21 landry Exp $
d549 1
a549 1
			my $set = OpenBSD::UpdateSet->new->add_older(OpenBSD::Handle->create_old($v, $state));
d566 1
a566 1
		$s = OpenBSD::UpdateSet->from_location($v);
d571 1
a571 1
		$s = OpenBSD::UpdateSet->create_new($v);
a676 1
	require OpenBSD::PackageRepository::Installed;
d678 1
a678 2

	my $r = OpenBSD::PackageRepository::Installed->new->match_locations(OpenBSD::Search::PkgSpec->new(".libs-".$pattern));
@


1.128
log
@Move ask_list() method to $state object like it's done for confirm(), so
that it can be overriden. Change callers accordingly.
ok espie@@
@
text
@d2 1
a2 1
# $OpenBSD: Dependencies.pm,v 1.127 2010/06/04 13:19:39 espie Exp $
d83 1
a83 1
	my ($self, $state, $obj, $msg) = @@_;
d85 1
a85 1
	$state->say("found libspec ", $obj->to_string, " ", $msg)
d97 1
a97 1
		$self->say_found($state, $obj, "in package $r");
d112 1
a112 1
			$self->say_found($state, $obj, "in $dir/lib");
d130 1
a130 1
	    	$self->say_found($state, $obj, "in package $dep");
d146 1
a146 1
				    "in old package $r");
d169 1
a169 1
		$state->say("Found tag $obj in $r") if $state->verbose >= 3;
d190 1
a190 1
		$state->errsay("Can't read plist for $dep");
d372 2
a373 2
		$state->say("Detected loop, merging sets", $state->ntogo);
		$state->say("| ", $initial->print);
d378 1
a378 1
					$state->say("| ", $k->print);
d516 1
a516 1
			$state->say("Cache hit on $dep->{pattern}: ",
d523 1
a523 1
		$state->say("No cache hit on $dep->{pattern}");
d703 1
a703 2
				$state->errsay("Can't install ",
				    $h->pkgname, " because of libraries");
d727 2
a728 3
			$state->errsay("Can't install ",
			    $h->pkgname, ": tag definition not found ",
			    $tag);
@


1.127
log
@move code around, so that commands can be used as modules.
pkg becomes the start hub, which does nothing except require the
correct module.
Saner code wrt Add/Delete, and more sharing.
@
text
@d2 1
a2 1
# $OpenBSD: Dependencies.pm,v 1.126 2010/05/10 09:17:55 espie Exp $
d424 1
a424 1
		my $good =  OpenBSD::Interactive::ask_list(
@


1.126
log
@whitespace fixes
@
text
@d2 1
a2 1
# $OpenBSD$
d408 1
a408 1
	if (!$state->{defines}->{allversions}) {
d512 1
a512 1
		if ($state->{defines}->{stat_cache}) {
d522 1
a522 1
	if ($state->{defines}->{stat_cache}) {
@


1.125
log
@finding dep in old names like this actually means we are replacing with
stuff that won't match, so mark it for later.
@
text
@d56 1
a56 1
	
d74 1
a74 1
	print "Full dependency tree is ", join(' ', keys %{$self->{done}}), 
d94 1
a94 1
	my $r = $solver->check_lib_spec($solver->{localbase}, $obj, 
d128 1
a128 1
	if ($solver->check_lib_spec($solver->{localbase}, $obj, 
d132 1
a132 1
	} 
d142 1
a142 1
			my $r = $solver->find_old_lib($state, 
d458 1
a458 1
			$self->set_cache($dep, 
d516 1
a516 1
			$state->say("Cache hit on $dep->{pattern}: ", 
d527 1
a527 1
		
d608 2
a609 2
		push(@@bad, $dep) 
		    unless is_installed($dep) or 
d619 1
a619 1
	    print "Direct dependencies for ", $self->{set}->print, 
d621 3
a623 3
	    print " (todo: ", 
	    	join(' ', (map {$_->print} values %{$self->{deplist}})), 
		")" 
d699 2
a700 2
			next if $lib_finder->lookup($solver, 
			    $solver->{to_register}->{$h}, $state, 
d703 1
a703 1
				$state->errsay("Can't install ", 
d707 1
a707 1
			OpenBSD::SharedLibs::report_problem($state, 
d726 1
a726 1
			next if $tag_finder->lookup($solver, 
d728 2
a729 2
			$state->errsay("Can't install ", 
			    $h->pkgname, ": tag definition not found ", 
@


1.124
log
@avoid some loops.
@
text
@d343 1
a343 1
	bless { set => $set }, $class;
d536 1
d605 1
a605 1
	my @@bad = ();
@


1.123
log
@match_locations doesn't work on invalid specs, so don't go there
@
text
@d359 1
d532 4
@


1.122
log
@use libspecs, report problem will be terser for now.
@
text
@d404 2
@


1.121
log
@use libspecs through Dependencies.
@
text
@d655 4
a658 4
	my @@r = OpenBSD::SharedLibs::lookup_libspec($base, $spec);
	for my $candidate (@@r) {
		if ($dependencies->{$candidate}) {
			return $candidate;
@


1.120
log
@tweak output
@
text
@d81 8
d97 1
a97 2
		$state->say("found libspec $obj in package $r") 
		    if $state->verbose >= 3;
d107 1
a107 1
	return undef if $obj =~ m/\//;
d112 1
a112 2
			$state->say("found libspec $obj in $dir/lib")
			    if $state->verbose >= 3;
d130 1
a130 2
		$state->say("found libspec $obj in package $dep") 
		    if $state->verbose >= 3;
d145 2
a146 2
				$state->say("found libspec $obj in old package $r")
				    if $state->verbose;
d693 1
a693 1
			    $lib->{name});
d700 1
a700 1
			    $lib->{name});
@


1.119
log
@better
@
text
@d74 1
a74 1
	print "Full dependency tree is ", join(',', keys %{$self->{done}}), 
d607 1
a607 1
	    	" resolve to: ", join(', ',  $self->dependencies);
d609 1
a609 1
	    	join(',', (map {$_->print} values %{$self->{deplist}})), 
@


1.118
log
@(C) of affected files
@
text
@d192 1
d199 6
d508 2
a509 1
			$state->say("Cache hit on $dep->{pattern}: ", ref($self->cached($dep)));
@


1.117
log
@store repository paths in sets and propagate them.
This fixes pkg_add /some/path/package
which will now find dependencies in the same path again.
@
text
@d4 1
a4 1
# Copyright (c) 2005-2007 Marc Espie <espie@@openbsd.org>
@


1.116
log
@stupid, stupid, stupid
@
text
@a390 1
	require OpenBSD::PackageLocator;
d392 1
a392 1
	my $candidates = OpenBSD::PackageLocator->match_locations($dep->spec);
d529 1
d542 2
d545 6
a550 5
		my $s = OpenBSD::UpdateSet->from_location($v);
		$state->tracker->todo($s);
		$self->add_dep($s);
		$self->set_cache($dep, _cache::to_install->new($v->name));
		return $v->name;
d553 1
a553 3
	# resort to default if nothing else
	$v = $dep->{def};
	my $s = OpenBSD::UpdateSet->create_new($v);
@


1.115
log
@need to tweak from to_update to self, as this kind of thing happens all
the time.
@
text
@d566 1
a566 1
	$self->{installed} = [];
@


1.114
log
@more/better cache for bad cases, and trap self after merge.
@
text
@d256 7
@


1.113
log
@... and this should fix todd's case, that of not finding anything and
resorting to default...
@
text
@d230 6
a235 1
		set_global($dep, $v);
d239 8
a246 2
		$solver->add_dep($state->tracker->{to_install}{$$v});
		return $$v;
d262 1
a262 1
		set_global($dep, $v);
d266 2
a267 2
		bless $v, "_cache::installed";
		set_global($dep, $v);
d272 1
a272 1
		set_global($dep, _cache::installed->new($candidates[0]));
d425 1
a425 1
		set_global($dep, _cache::installed->new($v));
d454 1
a454 1
	return $global_cache->{$dep->{pattern}} or 
d466 1
a466 1
	my ($dep, $value) = @@_;
d524 1
a535 4
		if (defined $state->{tracker}{cant_install}{$v->name}) {
			set_global($dep, _cache::bad->new($v->name));
			return $v->name;
		}
a536 1

a537 1
		
a544 4
	if (defined $state->{tracker}{cant_install}{$v}) {
		set_global($dep, _cache::bad->new($v));
		return $v;
	}
d548 1
@


1.112
log
@also track stuff I couldn't install, and use it for negative cache lookups.
fix some looping if stuff can't install for whatever reason.
@
text
@d539 4
@


1.111
log
@pretty
@
text
@d215 8
d524 4
d533 2
a534 2
		$self->set_cache($dep, _cache::to_install->new($v->{name}));
		return $v->{name};
@


1.110
log
@a few more tweaks:
- allow for merged updates if we want them
- deplist becomes a hash, maybe useful for big sets
- simplify loop checking. We don't actually care whether we find any.
- be more aggressive in keeping cached stuff, create solver or conflict_cache
if need be.
@
text
@d476 1
a476 1
			$state->say("Cache hit on $dep->{pattern}:", ref($self->cached($dep)));
@


1.109
log
@the way Tracker works, installed packages are always marked uptodate as well,
so remove some unneeded checks from solver's perspective.
@
text
@d226 1
a226 2
		push(@@{$solver->{deplist}}, 
		    $state->tracker->{to_install}{$$v});
d238 1
a238 2
		push(@@{$solver->{deplist}},
			$state->tracker->{to_update}{$$v});
d278 6
d321 1
a321 1
		for my $l (@@{$set->solver->{deplist}}) {
d338 5
a342 2
				$state->say("| ", $k->print);
				push(@@real, $k);
d347 1
a348 1
		return 1;
a349 1
	return 0;
d415 1
a415 1
			push(@@{$self->{deplist}}, $set);
d427 1
a427 1
		push(@@{$self->{deplist}}, $state->tracker->{to_install}->{$v});
d504 1
a504 1
			push(@@{$self->{deplist}}, $set);
d520 1
a520 1
		push(@@{$self->{deplist}}, $s);
d529 1
a529 1
	push(@@{$self->{deplist}}, $s);
d539 1
a539 1
	$self->{deplist} = [];
d551 1
a551 1
	return @@{$self->{deplist}};
d574 1
a574 1
	    	join(',', (map {$_->print} @@{$self->{deplist}})), 
d576 1
a576 1
	    	if @@{$self->{deplist}} > 0;
a594 3
	delete $self->{toregister};
	delete $self->{all_dependencies};
	delete $self->{deplist};
@


1.108
log
@for now, show cache statistic if -F stat_cache (still in need of improvements)
@
text
@a219 5
	if ($state->tracker->{installed}{$$v}) {
		bless $v, "_cache::installed";
		set_global($dep, $v);
		return $$v;
	}
d398 1
a398 7
	my $v = find_candidate($dep->spec, keys %{$state->tracker->{installed}});
	if ($v) {
		set_global($dep, _cache::installed->new($v));
		return $v;
	}

	$v = find_candidate($dep->spec, keys %{$state->tracker->{uptodate}});
@


1.107
log
@rework dependency solving around cached items, so that redoing the same
lookup will be faster
@
text
@d477 6
a482 4
#		if (defined $global_cache->{$dep->{pattern}}) {
#			$state->say("Global cache hit on $dep->{pattern}");
#		}
#		$state->say("Cache hit on $dep->{pattern}:", ref($self->cached($dep)));
d486 3
a488 1
#	$state->say("No cache hit on $dep->{pattern}");
a581 1
	    print "!!" if $self->{not_ready};
@


1.106
log
@prepare to cache conflicts in sets: object to do so, code to merge conflicts
and solver, actual auto-gen of conflict cache and solver.
@
text
@d191 75
d283 2
d306 1
a306 2
	bless {set => $set, 
	    deplist => [], to_register => {}, all_dependencies => {} }, $class;
d322 1
a322 1
		for my $l (@@{$set->{solver}->{deplist}}) {
d403 11
d422 4
a425 1
		$self->{not_ready} = 1;
d429 1
a429 1
	my $v = find_candidate($dep->spec, keys %{$state->tracker->{to_install}});
d431 1
d437 33
d476 10
d490 1
d495 1
a495 3
		if ($v) {
			return $v;
		}
d498 1
a498 5
	my @@l = installed_packages();
	for my $o ($self->{set}->older_names) {
		@@l = grep {$_ ne $o} @@l;
	}
	$v = find_candidate($dep->spec, @@l);
a506 1
			$self->{not_ready} = 1;
d512 1
a512 3
		if ($v) {
			return $v;
		}
d522 1
d537 5
@


1.105
log
@improved check for loops:
- detect as many loops as we can
- don't merge sets twice
@
text
@d191 12
d204 1
d210 3
@


1.104
log
@prepare for smarter sets, with cache info
@
text
@d224 1
d231 3
d236 15
a250 8
			if ($l eq $initial) {
				my $k = $set;
				while ($k ne $initial) {
					$initial->merge($state->tracker, $k);
					$k = $done->{$k};
				}
				$state->say("Merging ", $initial->print, $state->ntogo);
				return 1;
a251 1
			$done->{$l} = $set;
d253 2
@


1.103
log
@kill old dependency adjuster
@
text
@d195 4
@


1.102
log
@nits
@
text
@a437 49
sub record_old_dependencies
{
	my ($self, $state) = @@_;
	for my $o ($self->{set}->older_to_do) {
		require OpenBSD::RequiredBy;
		my @@wantlist = OpenBSD::RequiredBy->new($o->pkgname)->list;
		$o->{wantlist} = \@@wantlist;
	}
}

sub adjust_old_dependency_on
{
	my ($self, $pkgname, $state) = @@_;

	my $set = $self->{set};
	
	for my $o ($set->older) {
		next unless defined $o->{wantlist};
		require OpenBSD::Replace;
		require OpenBSD::RequiredBy;

		my $oldname = $o->pkgname;

		$state->say("Adjusting dependencies for ",
		    "$oldname->$pkgname") if $state->verbose >= 3;
		my $d = OpenBSD::RequiredBy->new($pkgname);
		for my $dep (@@{$o->{wantlist}}) {
			if (defined $set->{older}->{$dep}) {
				$state->say("\tskipping $dep")
				    if $state->verbose >= 4;
				next;
			}
			$state->say("\t$dep") if $state->verbose >= 4;
			$d->add($dep);
			OpenBSD::Replace::adjust_dependency($dep, 
			    $oldname, $pkgname) if $oldname ne $pkgname;
		}
	}
}

sub adjust_old_dependencies
{
	my ($self, $state) = @@_;
	
	for my $pkg ($self->{set}->newer) {
		$self->adjust_old_dependency_on($pkg->pkgname, $state);
	}
}

@


1.101
log
@check for loops and merge sets, in case we end up with real funky depends.
also, reset package->{before} before solving depends, since we may solve
them several times.
@
text
@d117 1
a117 1
	if ($solver->{set}->{newer}->{$dep}) {
d398 2
a399 1
		    unless is_installed($dep) or $self->{set}->{newer}->{$dep};
@


1.100
log
@qualify (Direct Dependencies)
@
text
@d213 30
d380 1
@


1.99
log
@change verbosity handling: be silent by default, turn on the first level if -v.
Add more levels, specifically, lots of info regarding individual files only
visible if -vvvvv.
Make -n display the same stuff as normal (need -n -v to display more stuff).
Introduce -s, "size-only", turns on -n and does skip any extraction.
Sprinkle handlers for SIG_INFO, not really nice yet.

Note that -n is non functional for complex updates, because of caching
issues I have to fix.
@
text
@d376 1
a376 1
	    print "Dependencies for ", $self->{set}->print, 
@


1.98
log
@simplify set printing
@
text
@d90 1
a90 1
		    if $state->{verbose};
d106 1
a106 1
			    if $state->{verbose};
d125 1
a125 1
		    if $state->{verbose};
d141 1
a141 1
				    if $state->{verbose};
d164 1
a164 1
		$state->say("Found tag $obj in $r") if $state->{verbose};
d430 1
a430 1
		    "$oldname->$pkgname") if $state->{beverbose};
d435 1
a435 1
				    if $state->{beverbose};
d438 1
a438 1
			$state->say("\t$dep") if $state->{beverbose};
@


1.97
log
@record internal updateset dependencies for new packages, and respect them
while installing (need doing something similar for old packages)
@
text
@d246 1
a246 1
		    'Ambiguous: choose dependency for '.$self->{set}->short_print.': ',
d376 1
a376 1
	    print "Dependencies for ", $self->{set}->short_print, 
d379 1
a379 1
	    	join(',', (map {$_->short_print} @@{$self->{deplist}})), 
@


1.96
log
@simplify tracker a bit now we know what we're doing.
kill code that never got used
@
text
@d286 1
a286 1
	my ($self, $state, $dep) = @@_;
d294 1
d351 1
a351 1
			my $v = $self->solve_dependency($state, $dep);
@


1.95
log
@since we don't redisplay missing libraries message, tell why we can't install
in general terms...
@
text
@d314 1
a314 1
			$state->tracker->add_set($set);
d330 1
a330 1
		$state->tracker->add_set($s);
d339 1
a339 1
	$state->tracker->add_set($s);
@


1.94
log
@create new updatesets when needed
@
text
@d513 1
a513 1
				    $h->pkgname, ":");
@


1.93
log
@simpler unified lookup for libs inside set/installed packages.
@
text
@d308 9
@


1.92
log
@zap useless debug code
@
text
@d116 6
a121 1
	OpenBSD::SharedLibs::add_libs_from_installed_package($dep);
a495 3
	for my $h ($solver->{set}->newer) {
		OpenBSD::SharedLibs::add_libs_from_plist($h->plist);
	}
@


1.91
log
@register plists from newer elements, in case they're useful.
@
text
@d502 1
a502 1
				    $h->pkgname, ":", $lib->{name});
@


1.90
log
@fix some inter-dependencies case:
- when we merge updatesets, invalidate the solver (there isn't any, usually).
- look inside set for check_depends.
- do register_dependencies after committing all plists to cache.
@
text
@d492 3
d502 1
a502 1
				    $h->pkgname, ":");
@


1.89
log
@set things up for updates on the fly. In particular, we may have to look
into "to_update" stuff...
@
text
@d253 1
a253 3
	return find_candidate($dep->spec, 
	    map {$_->pkgname} $self->{set}->newer);

d351 2
a352 1
		push(@@bad, $dep) unless is_installed($dep);
@


1.88
log
@show old->new as everywhere else in sets.
micro-optimisation: if old pkgname is the same as new pkgname, we just
need to build the RequiredBy file, no need to adjust Requiring...
@
text
@d262 17
a278 1
	return find_candidate($dep->spec, keys %{$state->tracker->{to_install}});
a294 1
			push(@@{$self->{deplist}}, $state->tracker->{to_install}->{$v});
a309 1
			push(@@{$self->{deplist}}, $state->tracker->{to_install}->{$v});
d368 1
@


1.87
log
@clean up conflict handling and dependency adjustement: build list
of conflict globally, add it as old handles, and then use it everywhere.
@
text
@d401 1
a401 1
		    "$pkgname/$oldname") if $state->{beverbose};
d412 1
a412 1
			    $oldname, $pkgname);
@


1.86
log
@have SharedLibs use state to print error messages.
@
text
@d387 1
a387 1
sub adjust_old_dependencies
d389 8
a396 7
	my ($self, $state) = @@_;
	for my $pkg ($self->{set}->newer) {
		my $pkgname = $pkg->pkgname;
		for my $o ($self->{set}->older) {
			next unless defined $o->{wantlist};
			require OpenBSD::Replace;
			require OpenBSD::RequiredBy;
d398 1
a398 1
			my $oldname = $o->pkgname;
d400 6
a405 10
			$state->say("Adjusting dependencies for ",
			    "$pkgname/$oldname") if $state->{beverbose};
			my $d = OpenBSD::RequiredBy->new($pkgname);
			for my $dep (@@{$o->{wantlist}}) {
				if (defined $self->{set}->{skipupdatedeps}->{$dep}) {
					$state->say("\tskipping $dep") 
					    if $state->{beverbose};
					next;
				}
				$state->say("\t$dep") 
d407 1
a407 3
				$d->add($dep);
				OpenBSD::Replace::adjust_dependency($dep, 
				    $oldname, $pkgname);
d409 4
d414 9
@


1.85
log
@rework display of missing libs some more: first show the libraries, then
the dependency tree.
@
text
@d480 2
a481 2
			OpenBSD::SharedLibs::report_problem(
			    $state->{localbase}, $lib->{name});
@


1.84
log
@don't use Warn if we've got a $state, get through errprint/errsay.
Also: reset lastdisplay on clear, and don't clear twice.
@
text
@a474 3
			$state->errsay("Can't install ", 
			    $h->pkgname, ": lib not found ", 
			    $lib->{name});
d476 2
a477 3
				$solver->dump;
				$lib_finder->dump;
				$okay = 0;
d479 1
d483 4
@


1.83
log
@also get most STDERR messages through the same way
@
text
@d475 1
a475 1
			OpenBSD::Error::Warn "Can't install ", 
d477 1
a477 1
			    $lib->{name}, "\n";
d500 1
a500 1
			OpenBSD::Error::Warn "Can't install ", 
d502 1
a502 1
			    $tag, "\n";
@


1.82
log
@progressmeter puts STDOUT in autoflush if -t, so that it can display to it instead of piping a lot of stuff to STDERR.

Go through state->print for most messages, so they will NOT do weird things
with the progressmeter.
Use a ->say shortcut which does the same thing that perl 5.10 say does...
@
text
@d180 1
a180 1
		print STDERR "Can't read plist for $dep\n";
@


1.81
log
@bad espie: use strict/warnings consistently, and fix two nits and two
actual errors !
@
text
@d89 2
a90 1
		print "found libspec $obj in package $r\n" if $state->{verbose};
d105 2
a106 1
			print "found libspec $obj in $dir/lib\n" if $state->{verbose};
d119 2
a120 1
		print "found libspec $obj in package $dep\n" if $state->{verbose};
d135 2
a136 1
				print "found libspec $obj in old package $r\n" if $state->{verbose};
d159 1
a159 1
		print "Found tag $obj in $r\n" if $state->{verbose};
d399 2
a400 2
			print "Adjusting dependencies for $pkgname/$oldname\n" 
			    if $state->{beverbose};
d404 1
a404 1
					print "\tskipping $dep\n" 
d408 2
a409 1
				print "\t$dep\n" if $state->{beverbose};
@


1.80
log
@zap match
@
text
@a15 1
#
@


1.79
log
@tracker/updater methods for state that auto-create the object.
@
text
@d448 3
a450 1
	for my $try (OpenBSD::PackageRepository::Installed->new->match(OpenBSD::Search::PkgSpec->new(".libs-".$pattern))) {
@


1.78
log
@remove almost all references to set->handle, iterate over newer in most
cases (todo: rebuild dependency headers for the complex case...)
@
text
@d259 1
a259 1
	return find_candidate($dep->spec, keys %{$state->{tracker}->{to_install}});
d276 1
a276 1
			push(@@{$self->{deplist}}, $state->{tracker}->{to_install}->{$v});
d292 1
a292 1
			push(@@{$self->{deplist}}, $state->{tracker}->{to_install}->{$v});
d301 1
a301 1
		$state->{tracker}->add_set($s);
d310 1
a310 1
	$state->{tracker}->add_set($s);
@


1.77
log
@allow solve to find dependencies in current UpdateSet
@
text
@d348 1
a348 1
	    	join(',', (map {$_->handle->pkgname} @@{$self->{deplist}})), 
d388 1
a388 1
		my $pkgname = $self->{set}->handle->pkgname;
d418 1
a418 1
		my $pkgname = $self->{set}->handle->pkgname;
@


1.76
log
@sync updatesets with tracker when we create them...
@
text
@d246 9
d269 5
@


1.75
log
@separate the dependencies in several lists for registration, so that
newer can have several entries.
@
text
@d285 5
a289 2
		push(@@{$self->{deplist}}, 
		    OpenBSD::UpdateSet->from_location($v));
d295 3
a297 1
	push(@@{$self->{deplist}}, OpenBSD::UpdateSet->create_new($v));
@


1.74
log
@remove parameter we no longer use
@
text
@d27 1
a27 1
	my ($self, $solver, $state, $obj) = @@_;
a28 1
	my $dependencies = $solver->{to_register};
d201 2
a202 2
	bless {set => $set, plist => $set->handle->{plist}, 
	    deplist => [], to_register => {} }, $class;
d209 1
a209 1
		return keys %{$self->{to_register}};
d211 1
a211 1
		return scalar(%{$self->{to_register}});
a214 6
sub has_dep
{
	my ($self, $dep) = @@_;
	return $self->{to_register}->{$dep};
}

d303 2
a304 1
			$self->{to_register}->{$v} = $dep;
d341 8
a348 6
	my $pkgname = $self->{set}->handle->pkgname;
	my @@l = $self->dependencies;

	OpenBSD::Requiring->new($pkgname)->add(@@l);
	for my $dep (@@l) {
		OpenBSD::RequiredBy->new($dep)->add($pkgname);
d351 1
d368 22
a389 15
	my $pkgname = $self->{set}->handle->pkgname;
	for my $o ($self->{set}->older) {
		next unless defined $o->{wantlist};
		require OpenBSD::Replace;
		require OpenBSD::RequiredBy;

		my $oldname = $o->pkgname;

		print "Adjusting dependencies for $pkgname/$oldname\n" 
		    if $state->{beverbose};
		my $d = OpenBSD::RequiredBy->new($pkgname);
		for my $dep (@@{$o->{wantlist}}) {
			if (defined $self->{set}->{skipupdatedeps}->{$dep}) {
				print "\tskipping $dep\n" if $state->{beverbose};
				next;
a390 3
			print "\t$dep\n" if $state->{beverbose};
			$d->add($dep);
			OpenBSD::Replace::adjust_dependency($dep, $oldname, $pkgname);
d398 7
a404 5
	my $pkgname = $self->{set}->handle->pkgname;
	for my $pkg (installed_packages(1)) {
		my $plist = OpenBSD::PackingList->from_installation($pkg, 
		    \&OpenBSD::PackingList::DependOnly);
	    	$plist->repair_dependency($pkg, $pkgname);
d447 2
a448 1
			next if $lib_finder->lookup($solver, $state, 
d473 2
a474 1
			next if $tag_finder->lookup($solver, $state, $tag);
@


1.73
log
@the to_install/to_update stuff is now in the tracker object.
@
text
@d305 1
a305 1
	my ($self, $state, @@extra) = @@_;
@


1.72
log
@let handle compute pkgnames correctly, simplifies code a bit
@
text
@d203 1
a203 1
	    to_install => {}, to_update => {}, deplist => [], to_register => {} }, $class;
a221 16
sub add_todo
{
	my ($self, @@extra) = @@_;

	require OpenBSD::PackageName;

	for my $set (@@extra) {
		for my $n ($set->newer) {
			$self->{to_install}->{$n->pkgname} = $set;
		}
		for my $n ($set->older) {
			$self->{to_update}->{$n->pkgname} = $set;
		}
	}
}

d257 1
a257 1
	return find_candidate($dep->spec, keys %{$self->{to_install}});
d269 1
a269 1
			push(@@{$self->{deplist}}, $self->{to_install}->{$v});
d285 1
a285 1
			push(@@{$self->{deplist}}, $self->{to_install}->{$v});
a305 2

	$self->add_todo(@@extra);
@


1.71
log
@more handle -> newer.
it is going to get more complicated sooner....
@
text
@d230 1
a230 1
			$self->{to_install}->{OpenBSD::PackageName::url2pkgname($n->{pkgname})} = $set;
d233 1
a233 1
			$self->{to_update}->{OpenBSD::PackageName::url2pkgname($n->{pkgname})} = $set;
d353 1
a353 1
	    	join(',', (map {$_->handle->{pkgname}} @@{$self->{deplist}})), 
d365 1
a365 1
	my $pkgname = $self->{set}->handle->{pkgname};
d381 1
a381 1
		my @@wantlist = OpenBSD::RequiredBy->new($o->{pkgname})->list;
d389 1
a389 1
	my $pkgname = $self->{set}->handle->{pkgname};
d395 1
a395 1
		my $oldname = $o->{pkgname};
d415 1
a415 1
	my $pkgname = $self->{set}->handle->{pkgname};
d465 1
a465 1
			    $h->{pkgname}, ": lib not found ", 
d489 1
a489 1
			    $h->{pkgname}, ": tag definition not found ", 
@


1.70
log
@more simple uses of set->newer
@
text
@a221 6
sub pkgname
{
	my $self = shift;
	return $self->{plist}->pkgname;
}

d261 1
a261 1
		    'Ambiguous: choose dependency for '.$self->pkgname.': ',
d350 2
a351 2
	    print "Dependencies for ", $self->pkgname, " resolve to: ", 
	    	join(', ',  $self->dependencies);
d365 1
a365 1
	my $pkgname = $self->pkgname;
@


1.69
log
@looking through installed packages is cool, but remember to filter out
older stuff in the updateset...
@
text
@d129 8
a136 6
	for my $dep (@@{$solver->{plist}->{depend}}) {
		my $r = $solver->find_old_lib($state, 
		    $solver->{localbase}, $dep->{pattern}, $obj);
		if ($r) {
			print "found libspec $obj in old package $r\n" if $state->{verbose};
			return $r;
d138 1
a138 1
    	}
d331 5
a335 3
	for my $dep (@@{$self->{plist}->{depend}}) {
		my $v = $self->solve_dependency($state, $dep);
		$self->{to_register}->{$v} = $dep;
@


1.68
log
@need to save more stuff about updateset for complicated upgrade scenarios.
@
text
@d294 5
a298 1
	$v = find_candidate($dep->spec, installed_packages());
@


1.67
log
@fix arguments order
@
text
@d201 1
a201 1
	    to_install => {}, deplist => [], to_register => {} }, $class;
d233 6
a238 3
		my $fullname = $set->handle->{pkgname};
		$self->{to_install}->
		    {OpenBSD::PackageName::url2pkgname($fullname)} = $set;
@


1.66
log
@store localbase in solver, in preparation to multiple handles.
@
text
@d127 1
a127 1
	my ($self, $state, $solver, $obj) = @@_;
@


1.65
log
@synch with my new style search/location changes
It's likely there will be some fallout, but it's getting a bit too large
to keep around.
This does kill a few very old oddities as well.
@
text
@d88 1
a88 1
	my $r = $solver->check_lib_spec($solver->{plist}->localbase, $obj, 
d117 1
a117 1
	if ($solver->check_lib_spec($solver->{plist}->localbase, $obj, 
d131 1
a131 1
		    $solver->{plist}->localbase, $dep->{pattern}, $obj);
d456 1
@


1.64
log
@rework collisionreport to allow some limited repair capabilities:
assuming none of the files is registered, we can assume that the
package registration fails, and then we remove the files, and install
the package.

Then we also walk installed packages to restore dependencies that would
have been erased (this is fairly simple-minded and may fail in weird
cases).
@
text
@d165 1
a165 1
			$self->{known_tags}->{$t->{name}} = $dep;
d244 6
a249 1
	my @@candidates = OpenBSD::PackageLocator->match_locations($dep->spec);
d251 1
a251 1
	my %c = map {($_->{name}, $_)} @@candidates;
a252 3
	if (!$state->{defines}->{allversions}) {
		@@pkgs = OpenBSD::PackageName::keep_most_recent(@@pkgs);
	}
d254 1
a254 1
		return $c{$pkgs[0]};
d306 1
a306 1
		    OpenBSD::UpdateSet->from_location($v->openPackage));
@


1.63
log
@cut lookup tag code in smaller pieces
@
text
@d2 1
a2 1
# $OpenBSD: Dependencies.pm,v 1.62 2008/06/11 12:21:03 espie Exp $
d405 11
d491 16
@


1.62
log
@further step on the road to tags:
make definitions migrate to the top of the packing-list,
allow solver to find tag on the correct name (will look at full definition
later).
@
text
@d2 1
a2 1
# $OpenBSD: Dependencies.pm,v 1.61 2008/06/10 10:52:52 espie Exp $
d160 10
d178 1
a178 5
	if ($plist->has('define-tag')) {
		for my $t (@@{$plist->{'define-tag'}}) {
			$self->{known_tags}->{$t->{name}} = $dep;
		}
	}
@


1.61
log
@typo in -as yet- unused code.
@
text
@d2 1
a2 1
# $OpenBSD: Dependencies.pm,v 1.60 2008/03/08 12:07:45 espie Exp $
d164 1
a164 1
	    \&OpenBSD::PackingList::DependsOnly);
d170 1
a170 1
			$self->{known_tags}->{$t} = $dep;
@


1.60
log
@rename forced to defines
@
text
@d2 1
a2 1
# $OpenBSD$
d173 1
a173 1
	return $self->find_in_already_dony($solver, $state, $obj);
@


1.59
log
@the big gap one: create UpdateSet for all packages being installed, and
consider only UpdateSet internally. This involves moving stuff around a
bit to keep pkg_add -n working, adding creators from_location for UpdateSet,
and tweaking dependencies heavily.

More changes later, like sanitizing PackageLocation state engine, or
creating UpdateSet earlier for actual updates.
@
text
@d2 1
a2 1
# $OpenBSD: Dependencies.pm,v 1.58 2007/06/19 10:47:28 espie Exp $
d242 1
a242 1
	if (!$state->{forced}->{allversions}) {
@


1.58
log
@first draft of a tag solver, needs more flesh to be useful (especially:
transform the lib cache into a tags/lib cache)
@
text
@d2 1
a2 1
# $OpenBSD: Dependencies.pm,v 1.57 2007/06/19 10:25:35 espie Exp $
d21 2
a58 1
	$self->dependency_not_found($state, $obj);
a139 6
sub dependency_not_found
{
	my ($self, $state, $obj) = @@_;
	print "libspec $obj not found\n" if $state->{very_verbose};
}

d226 2
a227 1
	for my $fullname (@@extra) {
d229 1
a229 1
		    {OpenBSD::PackageName::url2pkgname($fullname)} = $fullname;
a232 7
sub add_new_dep
{
	my ($self, $pkgname, $satisfy) = @@_;
	push(@@{$self->{deplist}}, $pkgname) if !is_installed($pkgname);
	$self->{to_register}->{$pkgname} = $satisfy;
}

d238 4
a241 1
	my @@candidates = OpenBSD::PackageLocator->match($dep->spec);
d243 1
a243 1
		@@candidates = OpenBSD::PackageName::keep_most_recent(@@candidates);
d245 3
a247 3
	if (@@candidates == 1) {
		return $candidates[0];
	} elsif (@@candidates > 1) {
d251 3
a253 3
		@@candidates = ((grep {$_ eq $dep->{def}} @@candidates),
		    (sort (grep {$_ ne $dep->{def}} @@candidates)));
		return OpenBSD::Interactive::ask_list(
d255 2
a256 1
		    $state->{interactive}, @@candidates);
d278 2
a279 3
			push(@@{$self->{deplist}}, $v);
			$self->{to_register}->{$v} = $dep;
			return;
d283 3
a285 2
	if (!$v) {
		$v = find_candidate($dep->spec, installed_packages());
d287 1
a287 1
	if (!$v && !$state->{allow_replacing}) {
d289 4
d295 5
a299 2
	if (!$v) {
		$v = $self->find_dep_in_repositories($state, $dep);
d301 1
d303 3
a305 5
	if (!$v) {
		$v = $dep->{def};
	}

	$self->add_new_dep($v, $dep);
d315 2
a316 1
		$self->solve_dependency($state, $dep);
d339 3
a341 1
	    print " (todo: ", join(',', @@{$self->{deplist}}), ")" 
@


1.57
log
@sometimes, wanting to share code gives insight: disentangle the code
that walks dependencies entirely. It is far less related to the main
solver than I thought, it can be built when needed, and own its own
state. Much cleaner design.
@
text
@d2 1
a2 1
# $OpenBSD: Dependencies.pm,v 1.56 2007/06/18 18:45:09 espie Exp $
d145 36
d448 22
@


1.56
log
@... and zap old code
@
text
@d2 1
a2 1
# $OpenBSD: Dependencies.pm,v 1.55 2007/06/18 18:34:00 espie Exp $
d28 1
a28 1
	my $known = $solver->{known};
d37 2
a38 2
	my $done = $solver->{done};
	while (my $dep = pop @@{$solver->{todo}}) {
d44 1
a44 1
			push(@@{$solver->{todo}}, $dep2) unless $done->{$dep2};
d61 18
d88 1
a88 1
	    $solver->{known});
d280 1
a280 1
	    $self->solve_dependency($state, $dep);
a282 6
	# prepare for closure
	my @@todo = $self->dependencies;
	$self->{todo} = \@@todo;
	$self->{done} = {};
	$self->{known} = {};

a305 1
	    print "Full dependency tree is ", join(',', keys %{$self->{done}}), "\n"	if %{$self->{done}};
d396 1
d399 8
a406 7
			if (!OpenBSD::lookup::library->lookup($solver,
			    $state, $lib->{name})) {
				OpenBSD::Error::Warn "Can't install ", 
				    $h->{pkgname}, ": lib not found ", 
				    $lib->{name}, "\n";
				$solver->dump if $okay;
				OpenBSD::SharedLibs::report_problem($state->{localbase}, $lib->{name});
d409 2
@


1.55
log
@reorganize lookup_library so I can reuse the exact same algorithm to
look up different things (in particular, the incremental lookup through
dependencies).
@
text
@d2 1
a2 1
# $OpenBSD: Dependencies.pm,v 1.54 2007/06/18 18:06:28 espie Exp $
a378 54

sub lookup_library
{
	my ($self, $state, $lib) = @@_;

	my $plist = $self->{plist};
	my $dependencies = $self->{to_register};
	my $known = $self->{known};
	my $r = $self->check_lib_spec($plist->localbase, $lib, $known);
	if ($r) {
		print "found libspec $lib in package $r\n" if $state->{verbose};
		$dependencies->{$r} = 1;
		return 1;
	}
	if ($lib !~ m|/|) {

		OpenBSD::SharedLibs::add_libs_from_system($state->{destdir});
		for my $dir (OpenBSD::SharedLibs::system_dirs()) {
			if ($self->check_lib_spec($dir, $lib, {system => 1})) {
				print "found libspec $lib in $dir/lib\n" if $state->{very_verbose};
				return 1;
			}
		}
	}
	# lookup through the rest of the tree...
	my $done = $self->{done};
	while (my $dep = pop @@{$self->{todo}}) {
		require OpenBSD::RequiredBy;

		next if $done->{$dep};
		$done->{$dep} = 1;
		for my $dep2 (OpenBSD::Requiring->new($dep)->list) {
			push(@@{$self->{todo}}, $dep2) unless $done->{$dep2};
		}
		OpenBSD::SharedLibs::add_libs_from_installed_package($dep);
		$known->{$dep} = 1;
		if ($self->check_lib_spec($plist->localbase, $lib, {$dep => 1})) {
			print "found libspec $lib in package $dep\n" if $state->{verbose};
			$dependencies->{$dep} = 1;
			return 1;
		} 
	}
	for my $dep (@@{$plist->{depend}}) {
		$r = $self->find_old_lib($state, $plist->localbase, $dep->{pattern}, $lib, $dependencies);
		if ($r) {
			print "found libspec $lib in old package $r\n" if $state->{verbose};
			return 1;
		}
    	}
	
	print "libspec $lib not found\n" if $state->{very_verbose};
	return;
}

@


1.54
log
@more uniform: all deps routines should be methods, even if they don't
use the data.
@
text
@d2 1
a2 1
# $OpenBSD: Dependencies.pm,v 1.53 2007/06/09 10:39:16 espie Exp $
d21 106
d366 1
a366 1
	my ($self, $state, $base, $pattern, $lib, $dependencies) = @@_;
d374 1
a374 2
			$dependencies->{$try} = 1;
			return "$try($lib)";
d377 1
a377 1
	return;
d441 2
a442 1
			if (!$solver->lookup_library($state, $lib->{name})) {
@


1.53
log
@give Dependencies a chance at finding libraries in old packages.
@
text
@d2 1
a2 1
# $OpenBSD: Dependencies.pm,v 1.52 2007/06/05 23:19:00 espie Exp $
d248 1
a248 1
	my ($base, $spec, $dependencies) = @@_;
d260 1
a260 1
	my ($state, $base, $pattern, $lib, $dependencies) = @@_;
d267 1
a267 1
		if (check_lib_spec($base, $lib, {$try => 1})) {
d282 1
a282 1
	my $r = check_lib_spec($plist->localbase, $lib, $known);
d292 1
a292 1
			if (check_lib_spec($dir, $lib, {system => 1})) {
d310 1
a310 1
		if (check_lib_spec($plist->localbase, $lib, {$dep => 1})) {
d317 1
a317 1
		$r = find_old_lib($state, $plist->localbase, $dep->{pattern}, $lib, $dependencies);
@


1.52
log
@allow accessing all older values (make a semantic distinction), so that
adjust_dependencies gets access to all. This fixes some bogus replacements.
@
text
@d2 1
a2 1
# $OpenBSD: Dependencies.pm,v 1.51 2007/06/04 16:58:40 espie Exp $
d316 1
a316 1
	for my $dep (@@{$plist->{depends}}) {
@


1.51
log
@error code: if we can't find a given libspec, we look through all
known registered libs, and tell the user why this library doesn't match.

Example:
Can't install kdelibs-3.5.7: lib not found lib/qt3/qt-mt.31.0
qt-mt.31.0: found partial match in /usr/local/lib/qt3: major=32, minor=0 (bad major)
qt-mt.31.0: found partial match in /usr/local/lib: major=31, minor=0 (bad directory)

(after altering qt to have @@lib lib/qt3/libqt-mt.so.32.0)
@
text
@d2 1
a2 1
# $OpenBSD: Dependencies.pm,v 1.50 2007/06/02 12:45:24 espie Exp $
d211 1
a211 1
	for my $o ($self->{set}->older) {
d223 1
@


1.50
log
@remove elements of the solver that correspond to dependencies `in-transit'
since they're now recorded as true dependencies.

(helps me think about future improvements)
@
text
@d2 1
a2 1
# $OpenBSD: Dependencies.pm,v 1.49 2007/06/02 12:37:37 espie Exp $
d340 1
@


1.49
log
@move the check that dependencies are satisfied inside the solver object
@
text
@d2 1
a2 1
# $OpenBSD: Dependencies.pm,v 1.48 2007/06/02 12:21:14 espie Exp $
d204 2
@


1.48
log
@slight refactor, move wantlib dependencies handling inside the solver.
@
text
@d2 1
a2 1
# $OpenBSD: Dependencies.pm,v 1.47 2007/06/02 11:30:06 espie Exp $
d166 11
@


1.47
log
@reorder code
@
text
@d2 1
a2 1
# $OpenBSD: Dependencies.pm,v 1.46 2007/06/02 11:24:22 espie Exp $
d149 1
a149 1
sub solve
a229 2


d312 20
@


1.46
log
@move most of the code that deals with dependencies in the solver object
@
text
@d2 1
a2 1
# $OpenBSD: Dependencies.pm,v 1.45 2007/06/02 11:18:46 espie Exp $
d195 37
a314 37

sub record_old_dependencies
{
	my ($self, $state) = @@_;
	for my $o ($self->{set}->older) {
		require OpenBSD::RequiredBy;
		my @@wantlist = OpenBSD::RequiredBy->new($o->{pkgname})->list;
		$o->{wantlist} = \@@wantlist;
	}
}

sub adjust_old_dependencies
{
	my ($self, $state) = @@_;
	my $pkgname = $self->{set}->handle->{pkgname};
	for my $o ($self->{set}->older) {
		require OpenBSD::Replace;
		require OpenBSD::RequiredBy;

		my $oldname = $o->{pkgname};

		print "Adjusting dependencies for $pkgname/$oldname\n" 
		    if $state->{beverbose};
		my $d = OpenBSD::RequiredBy->new($pkgname);
		for my $dep (@@{$o->{wantlist}}) {
			if (defined $self->{set}->{skipupdatedeps}->{$dep}) {
				print "\tskipping $dep\n" if $state->{beverbose};
				next;
			}
			print "\t$dep\n" if $state->{beverbose};
			$d->add($dep);
			OpenBSD::Replace::adjust_dependency($dep, $oldname, $pkgname);
		}
	}
}


@


1.45
log
@move the solver object up to the set level.
@
text
@d2 1
a2 1
# $OpenBSD: Dependencies.pm,v 1.44 2007/06/01 22:35:46 espie Exp $
d183 1
a183 1
	my $self = shift;
d278 36
@


1.44
log
@very small clean-up of dependencies list handling.
@
text
@d2 1
a2 1
# $OpenBSD: Dependencies.pm,v 1.43 2007/05/31 22:33:45 espie Exp $
d38 3
a40 3
	my ($class, $plist) = @@_;
	bless {plist => $plist, to_install => {}, deplist => [], 
	    to_register => {} }, $class;
@


1.43
log
@look up for old libraries last, so that we do not get tied to old stuff
whenever possible.
@
text
@d2 1
a2 1
# $OpenBSD: Dependencies.pm,v 1.42 2007/05/31 16:48:18 espie Exp $
d187 1
d189 2
a190 3
	my $r = OpenBSD::Requiring->new($pkgname);

	for my $dep ($self->dependencies) {
a191 1
		$r->add($dep);
@


1.42
log
@simplify the handling of shared libs: there's no need to register each
package independently.
@
text
@d2 1
a2 1
# $OpenBSD: Dependencies.pm,v 1.41 2007/05/29 23:12:26 espie Exp $
a249 7
	for my $dep (@@{$plist->{depends}}) {
		$r = find_old_lib($state, $plist->localbase, $dep->{pattern}, $lib, $dependencies);
		if ($r) {
			print "found libspec $lib in old package $r\n" if $state->{verbose};
			return 1;
		}
    	}
d268 7
@


1.41
log
@In update mode, restore previous behavior: some updated packages may have
names that match installed packages, but still mark them to be installed,
so that they're returned as dependencies, and get updated first.

Write in TODO that the current situation is brittle, solved dependencies
should get adjusted in real time to be 100% sure this won't cause problems...
@
text
@d2 1
a2 1
# $OpenBSD: Dependencies.pm,v 1.40 2007/05/27 11:36:21 espie Exp $
a232 6

	my $r = check_lib_spec($plist->localbase, $lib, $dependencies);
	if ($r) {
	    print "found libspec $lib in $r\n" if $state->{very_verbose};
	    return 1;
	}
d234 1
a234 1
	$r = check_lib_spec($plist->localbase, $lib, $known);
d236 1
a236 2
		print "found libspec $lib in dependent package $r\n" if $state->{verbose};
		delete $known->{$r};
a266 1
		next if $dependencies->{$dep};
d268 1
d270 1
a270 1
			print "found libspec $lib in dependent package $dep\n" if $state->{verbose};
d273 1
a273 3
		} else {
			$known->{$dep} = 1;
		}
@


1.40
log
@rename $state->{replace} to $state->{allow_replacing}, which matches intent
better...
@
text
@d2 1
a2 1
# $OpenBSD: Dependencies.pm,v 1.39 2007/05/23 10:33:45 espie Exp $
d124 5
@


1.39
log
@fiddle with SharedLibs name, put common code into a common place in
pkg_add.
@
text
@d2 1
a2 1
# $OpenBSD: Dependencies.pm,v 1.38 2007/05/19 23:40:46 espie Exp $
d122 1
a122 1
	if ($state->{replace}) {
d129 1
a129 1
	if (!$v && !$state->{replace}) {
@


1.38
log
@move the code that handles dependencies registration into Dependencies
@
text
@d2 1
a2 1
# $OpenBSD: Dependencies.pm,v 1.37 2007/05/18 12:18:33 espie Exp $
d213 1
a213 1
		OpenBSD::SharedLibs::add_package_libs($try);
d244 1
a244 1
		OpenBSD::SharedLibs::add_system_libs($state->{destdir});
d270 1
a270 1
		OpenBSD::SharedLibs::add_package_libs($dep);
@


1.37
log
@cut dependency code in smaller chunks
@
text
@d2 1
a2 1
# $OpenBSD: Dependencies.pm,v 1.36 2007/05/18 09:45:18 espie Exp $
d173 15
@


1.36
log
@we don't need to walk the full dependency tree each time we don't find
a library. Instead, put the state of the closure computation in the solver
object, and only proceed until we find the library. We just need an extra
marker (known) to be aware of packages that may contain libraries, but have
not been used for extra dependencies yet.
@
text
@d2 1
a2 1
# $OpenBSD: Dependencies.pm,v 1.35 2007/05/17 15:40:06 espie Exp $
d39 2
a40 1
	bless {plist => $plist, to_install => {}, deplist => [], to_register => {} }, $class;
d80 27
a106 2
	push(@@{$self->{deplist}}, $pkgname);
	$self->add_installed_dep($pkgname, $satisfy);
d109 1
a109 1
sub add_installed_dep
d111 3
a113 2
	my ($self, $pkgname, $satisfy) = @@_;
	$self->{to_register}->{$pkgname} = $satisfy;
d120 2
a121 1
	my $spec = $dep->spec;
d123 1
a123 5
	    my $v = find_candidate($spec, keys %{$self->{to_install}});
	    if ($v) {
		$self->add_new_dep($v, $dep);
		return;
	    }
d126 2
a127 4
	my $v = find_candidate($spec, installed_packages());
	if ($v) {
		$self->add_installed_dep($v, $dep);
		return;
d129 2
a130 6
	if (!$state->{replace}) {
	    my $v = find_candidate($spec, keys %{$self->{to_install}});
	    if ($v) {
		$self->add_new_dep($v, $dep);
	    	return;
	    }
a131 1
	require OpenBSD::PackageLocator;
d133 2
a134 4
	# try with list of available packages
	my @@candidates = OpenBSD::PackageLocator->match($spec);
	if (!$state->{forced}->{allversions}) {
	    @@candidates = OpenBSD::PackageName::keep_most_recent(@@candidates);
d136 3
a138 4
	# one single choice
	if (@@candidates == 1) {
	    $self->add_new_dep($candidates[0], $dep);
	    return;
a139 2
	if (@@candidates > 1) {
	    require OpenBSD::Interactive;
d141 1
a141 12
	    # put default first if available
	    @@candidates = ((grep {$_ eq $dep->{def}} @@candidates),
			    (sort (grep {$_ ne $dep->{def}} @@candidates)));
	    my $choice = 
		OpenBSD::Interactive::ask_list('Ambiguous: choose dependency for '.$self->pkgname.': ',
		    $state->{interactive}, @@candidates);
	    $self->add_new_dep($choice, $dep);
	    return;
	}
	# can't get a list of packages, assume default
	# will be there.
	$self->add_new_dep($dep->{def}, $dep);
@


1.35
log
@library lookup becomes a real method
@
text
@d2 1
a2 1
# $OpenBSD: Dependencies.pm,v 1.34 2007/05/17 15:35:58 espie Exp $
d153 6
d171 1
d208 1
a208 1
	my ($self, $state, $lib, $done) = @@_;
d218 8
d243 3
a245 3
	# lookup through the full tree...
	my @@todo = keys %$dependencies;
	while (my $dep = pop @@todo) {
d251 1
a251 1
			push(@@todo, $dep2) unless $done->{$dep2};
d259 2
@


1.34
log
@move the library lookup code into Solver, so that I can turn it into
methods as well...
@
text
@d2 1
a2 1
# $OpenBSD: Dependencies.pm,v 1.33 2007/05/17 14:08:49 espie Exp $
d201 4
a204 1
	my ($state, $lib, $plist, $dependencies, $done) = @@_;
@


1.33
log
@access solver internals in a clean way through dependencies, uses it
internally.
store solver objects along with solved_dependencies.
Eventually, all solved_dependencies requests will use solver objects
instead.
@
text
@d2 1
a2 1
# $OpenBSD: Dependencies.pm,v 1.32 2007/05/17 13:58:44 espie Exp $
d52 6
a166 2

package OpenBSD::Dependencies;
@


1.32
log
@make the solved dependencies more explicit, match them back to the spec
they match.
@
text
@d2 1
a2 1
# $OpenBSD: Dependencies.pm,v 1.31 2007/05/17 13:36:21 espie Exp $
d42 10
d153 1
a153 1
	if (%{$self->{to_register}}) {
d155 1
a155 1
	    	join(', ', keys %{$self->{to_register}});
@


1.31
log
@tweak the solver object a bit, now that I have a clearer idea of what
it's going to be used for.
@
text
@d2 1
a2 1
# $OpenBSD: Dependencies.pm,v 1.30 2007/05/14 18:19:25 espie Exp $
d62 3
a64 3
	my ($self, $dep) = @@_;
	push(@@{$self->{deplist}}, $dep);
	$self->add_installed_dep($dep);
d69 2
a70 2
	my ($self, $dep) = @@_;
	$self->{to_register}->{$dep} = 1;
d81 1
a81 1
		$self->add_new_dep($v);
d88 1
a88 1
		$self->add_installed_dep($v);
d94 1
a94 1
		$self->add_new_dep($v);
d107 1
a107 1
	    $self->add_new_dep($candidates[0]);
d119 1
a119 1
	    $self->add_new_dep($choice);
d124 1
a124 1
	$self->add_new_dep($dep->{def});
@


1.30
log
@put the solver into its  own class.
@
text
@d2 1
a2 1
# $OpenBSD: Dependencies.pm,v 1.29 2007/05/14 17:52:08 espie Exp $
d38 8
a45 2
	my $class = shift;
	bless {to_install => {}, deplist => [], to_register => {} }, $class;
d117 1
a117 1
		OpenBSD::Interactive::ask_list('Ambiguous: choose dependency for '.$self->{pkgname}.': ',
d129 1
a129 2
	my ($self, $state, $handle, @@extra) = @@_;
	my $plist = $handle->{plist};
a131 1
	$self->{pkgname} = $plist->pkgname;
d133 1
a133 1
	for my $dep (@@{$plist->{depend}}) {
a136 1
	$handle->{solved_dependencies} = $self->{to_register};
d144 1
a144 1
	    print "Dependencies for ", $self->{pkgname}, " resolve to: ", 
@


1.29
log
@move verbose printing into a separate method.
@
text
@d2 1
a2 1
# $OpenBSD: Dependencies.pm,v 1.28 2007/05/14 17:48:32 espie Exp $
d21 1
a21 1
package OpenBSD::Dependencies;
a22 1
use OpenBSD::PackageName;
a23 3
use OpenBSD::SharedLibs;
use OpenBSD::Error;
use OpenBSD::Interactive;
d36 1
a36 1
sub solver
d45 3
d105 2
d148 4
@


1.28
log
@use the solver object to split the code into smaller chunks
@
text
@d2 1
a2 1
# $OpenBSD: Dependencies.pm,v 1.27 2007/05/14 11:22:00 espie Exp $
d132 8
a139 1
	if ($state->{verbose} && %{$self->{to_register}}) {
a145 2
	$handle->{solved_dependencies} = $self->{to_register};
	return @@{$self->{deplist}};
@


1.27
log
@redo search filters as real objects. Accordingly, rename match_list to
filter.
@
text
@d2 1
a2 1
# $OpenBSD: Dependencies.pm,v 1.26 2007/05/14 11:02:14 espie Exp $
d43 1
a43 1
	bless {}, $class;
d46 1
a46 1
sub solve
d48 1
a48 5
	my ($self, $state, $handle, @@extra) = @@_;
	my $plist = $handle->{plist};
	my $verbose = $state->{verbose};
	my $to_register = $handle->{solved_dependencies} = {};
	my $to_install = {};
d50 2
a51 2
		$to_install->{OpenBSD::PackageName::url2pkgname($fullname)} = 
		    $fullname;
d53 14
d68 3
a70 1
	my @@deps;
d72 6
a77 9
	for my $dep (@@{$plist->{depend}}) {
	    my $spec = $dep->spec;
	    if ($state->{replace}) {
	    	my $v = find_candidate($spec, keys %{$to_install});
		if ($v) {
		    push(@@deps, $to_install->{$v});
		    $to_register->{$v} = 1;
		    next;
		}
d79 1
d81 7
a87 1
	    my $v = find_candidate($spec, installed_packages());
d89 2
a90 2
		    $to_register->{$v} = 1;
		    next;
d92 35
a126 9
	    if (!$state->{replace}) {
	    	my $v = find_candidate($spec, keys %{$to_install});
		if ($v) {
		    push(@@deps, $to_install->{$v});
		    $to_register->{$v} = 1;
		    next;
		}
	    }
	    require OpenBSD::PackageLocator;
d128 2
a129 26
	    # try with list of available packages
	    my @@candidates = OpenBSD::PackageLocator->match($spec);
	    if (!$state->{forced}->{allversions}) {
		@@candidates = OpenBSD::PackageName::keep_most_recent(@@candidates);
	    }
	    # one single choice
	    if (@@candidates == 1) {
		push(@@deps, $candidates[0]);
		$to_register->{$candidates[0]} = 1;
		next;
	    }
	    if (@@candidates > 1) {
		# put default first if available
		@@candidates = ((grep {$_ eq $dep->{def}} @@candidates),
				(sort (grep {$_ ne $dep->{def}} @@candidates)));
		my $choice = 
		    OpenBSD::Interactive::ask_list('Ambiguous: choose dependency for '.$plist->pkgname().': ',
			$state->{interactive}, @@candidates);
		push(@@deps, $choice);
		$to_register->{$choice} = 1;
		next;
	    }
	    # can't get a list of packages, assume default
	    # will be there.
	    push(@@deps, $dep->{def});
	    $to_register->{$dep->{def}} = 1;
d132 5
a136 4
	if ($verbose && %$to_register) {
	    print "Dependencies for ", $plist->pkgname, " resolve to: ", 
	    	join(', ', keys %$to_register);
	    print " (todo: ", join(',', @@deps), ")" if @@deps > 0;
d139 2
a140 1
	return @@deps;
@


1.26
log
@put Search objects into their own file, finally
@
text
@d2 1
a2 1
# $OpenBSD: Dependencies.pm,v 1.25 2007/05/14 10:53:31 espie Exp $
d32 1
a32 1
	    my @@candidates = $spec->match_list(@@_);
@


1.25
log
@put search objects into a search class.
@
text
@d2 1
a2 1
# $OpenBSD: Dependencies.pm,v 1.24 2007/05/14 10:43:45 espie Exp $
d139 1
a139 1
	my $spec = OpenBSD::Search::PkgSpec->new(".libs-".$pattern);
d142 1
a142 1
	for my $try (OpenBSD::PackageRepository::Installed->new->match($spec)) {
@


1.24
log
@name tweaks: match -> match_list, match_repo -> match
@
text
@d2 1
a2 1
# $OpenBSD: Dependencies.pm,v 1.23 2007/05/14 09:49:27 espie Exp $
d139 1
a139 1
	my $spec = OpenBSD::PkgSpec->new(".libs-".$pattern);
@


1.23
log
@tidy
@
text
@d2 1
a2 1
# $OpenBSD: Dependencies.pm,v 1.22 2007/05/13 13:32:36 espie Exp $
d32 1
a32 1
	    my @@candidates = $spec->match(@@_);
d140 3
a142 1
	for my $try ($spec->match(installed_packages())) {
@


1.22
log
@unify object lookup as locator->match($o) or $repo->match($o)
@
text
@d2 1
a2 1
# $OpenBSD: Dependencies.pm,v 1.21 2007/05/12 15:19:00 espie Exp $
d183 1
a183 1
		for my $dep2 (OpenBSD::Requiring->new($dep)->list()) {
@


1.21
log
@lift PkgSpec creation up into PackingElement::Dependency.
@
text
@d2 1
a2 1
# $OpenBSD: Dependencies.pm,v 1.20 2007/05/12 14:38:30 espie Exp $
d87 1
a87 1
	    my @@candidates = OpenBSD::PackageLocator->match_spec($spec);
@


1.20
log
@use OO version of spec match
@
text
@d2 1
a2 1
# $OpenBSD: Dependencies.pm,v 1.19 2007/05/07 13:27:28 espie Exp $
a23 1
use OpenBSD::PkgSpec;
d61 1
a61 1
	    my $spec = OpenBSD::PkgSpec->new($dep->{pattern});
@


1.19
log
@we want to no longer expose PackageLocator::available(), lift interfaces
up there, starting with match_spec.
@
text
@d2 1
a2 1
# $OpenBSD: Dependencies.pm,v 1.18 2007/05/07 13:12:11 espie Exp $
d32 2
a33 2
	    my $dep = shift;
	    my @@candidates = OpenBSD::PkgSpec::match($dep->{pattern}, @@_);
d62 1
d64 1
a64 1
	    	my $v = find_candidate($dep, keys %{$to_install});
d72 1
a72 1
	    my $v = find_candidate($dep, installed_packages());
d78 1
a78 1
	    	my $v = find_candidate($dep, keys %{$to_install});
d88 1
a88 1
	    my @@candidates = OpenBSD::PackageLocator->match_spec($dep->{pattern});
d140 2
a141 2
	$pattern = ".libs-".$pattern;
	for my $try (OpenBSD::PkgSpec::match($pattern, installed_packages())) {
@


1.18
log
@restore lost behavior
@
text
@d2 1
a2 1
# $OpenBSD: Dependencies.pm,v 1.17 2007/05/07 12:19:04 espie Exp $
a29 9
my @@avail;
sub available
{
	if (!@@avail) {
	    @@avail = OpenBSD::PackageLocator::available();
	}
	return @@avail;
}

d84 2
d87 1
a87 1
	    my @@candidates = OpenBSD::PkgSpec::match($dep->{pattern}, available());
@


1.17
log
@refactor: create a solver object to handle state issues in a simpler way.
@
text
@d2 1
a2 1
# $OpenBSD: Dependencies.pm,v 1.16 2007/05/07 08:18:02 espie Exp $
a34 4
	    my $state = shift;
	    if (!$state->{forced}->{allversions}) {
		@@avail = OpenBSD::PackageName::keep_most_recent(@@avail);
	    }
d95 3
@


1.16
log
@use one single list for system directories.
@
text
@d2 1
a2 1
# $OpenBSD: Dependencies.pm,v 1.15 2007/05/07 08:14:51 espie Exp $
d54 6
d62 1
a62 1
	my ($state, $handle, @@extra) = @@_;
@


1.15
log
@remove -Fboguslibs, we haven't had unmarked libraries for years
@
text
@d2 1
a2 1
# $OpenBSD: Dependencies.pm,v 1.14 2007/05/07 08:10:45 espie Exp $
d164 1
a164 1
		for my $dir ("/usr", "/usr/X11R6") {
@


1.14
log
@zap unused parameters.
@
text
@d2 1
a2 1
# $OpenBSD: Dependencies.pm,v 1.13 2007/05/07 08:06:47 espie Exp $
a196 20
	if ($state->{forced}->{boguslibs}) {
		my $explored = {};
		# lookup through the full tree...
		my @@todo = keys %$dependencies;
		while (my $dep = pop @@todo) {
			require OpenBSD::RequiredBy;

			next if $explored->{$dep};
			$explored->{$dep} = 1;
			for my $dep2 (OpenBSD::Requiring->new($dep)->list()) {
				push(@@todo, $dep2) unless $done->{$dep2};
			}
			OpenBSD::SharedLibs::add_bogus_package_libs($dep);
			if (check_lib_spec($plist->localbase, $lib, {$dep => 1})) {
				print "found libspec $lib in dependent package $dep (unmarked library)\n" if $state->{verbose};
				$dependencies->{$dep} = 1;
				return 1;
			}
		}
	}
@


1.13
log
@share common code for system libs.
@
text
@d2 1
a2 1
# $OpenBSD: Dependencies.pm,v 1.12 2007/05/02 15:17:36 espie Exp $
d154 1
a154 1
	my ($state, $lib, $plist, $dependencies, $harder, $done) = @@_;
d161 1
a161 1
	if ($harder && $lib !~ m|/|) {
d178 16
a193 18
	if ($harder) {
		# lookup through the full tree...
		my @@todo = keys %$dependencies;
		while (my $dep = pop @@todo) {
			require OpenBSD::RequiredBy;

			next if $done->{$dep};
			$done->{$dep} = 1;
			for my $dep2 (OpenBSD::Requiring->new($dep)->list()) {
				push(@@todo, $dep2) unless $done->{$dep2};
			}
			next if $dependencies->{$dep};
			OpenBSD::SharedLibs::add_package_libs($dep);
			if (check_lib_spec($plist->localbase, $lib, {$dep => 1})) {
				print "found libspec $lib in dependent package $dep\n" if $state->{verbose};
				$dependencies->{$dep} = 1;
				return 1;
			}
d196 1
@


1.12
log
@replace pkgbase with less confusing name localbase
@
text
@d2 1
a2 1
# $OpenBSD: Dependencies.pm,v 1.11 2007/05/02 15:05:29 espie Exp $
d164 5
a168 7
		if (check_lib_spec("/usr", $lib, {system => 1})) {
			print "found libspec $lib in /usr\n" if $state->{very_verbose};
			return 1;
		}
		if (check_lib_spec("/usr/X11R6", $lib, {system => 1})) {
			print "found libspec $lib in /usr/X11R6\n" if $state->{very_verbose};
			return 1;
@


1.11
log
@$o->method() becomes $o->method
@
text
@d2 1
a2 1
# $OpenBSD: Dependencies.pm,v 1.10 2007/05/02 13:36:07 espie Exp $
d156 1
a156 1
	my $r = check_lib_spec($plist->pkgbase(), $lib, $dependencies);
d174 1
a174 1
		$r = find_old_lib($state, $plist->pkgbase, $dep->{pattern}, $lib, $dependencies);
d193 1
a193 1
			if (check_lib_spec($plist->pkgbase, $lib, {$dep => 1})) {
d213 1
a213 1
			if (check_lib_spec($plist->pkgbase(), $lib, {$dep => 1})) {
@


1.10
log
@move common code into a find_candidate function.
@
text
@d2 1
a2 1
# $OpenBSD: Dependencies.pm,v 1.9 2007/05/02 12:23:59 espie Exp $
d117 1
a117 1
	    print "Dependencies for ", $plist->pkgname(), " resolve to: ", 
d174 1
a174 1
		$r = find_old_lib($state, $plist->pkgbase(), $dep->{pattern}, $lib, $dependencies);
d193 1
a193 1
			if (check_lib_spec($plist->pkgbase(), $lib, {$dep => 1})) {
@


1.9
log
@refactor: remove temp @@avail, move it to an external code, slightly more
explicit code.
@
text
@d2 1
a2 1
# $OpenBSD: Dependencies.pm,v 1.8 2007/05/01 19:41:37 espie Exp $
d43 11
a68 1
	    my @@candidates;
d70 4
a73 5
		# try against list of packages to install
		@@candidates = OpenBSD::PkgSpec::match($dep->{pattern}, keys %{$to_install});
		if (@@candidates >= 1) {
		    push(@@deps, $to_install->{$candidates[0]});
		    $to_register->{$candidates[0]} = 1;
d77 4
a80 3
	    @@candidates = OpenBSD::PkgSpec::match($dep->{pattern}, installed_packages());
	    if (@@candidates >= 1) {
		    $to_register->{$candidates[0]} = 1;
d84 4
a87 5
		# try against list of packages to install
		@@candidates = OpenBSD::PkgSpec::match($dep->{pattern}, keys %{$to_install});
		if (@@candidates >= 1) {
		    push(@@deps, $to_install->{$candidates[0]});
		    $to_register->{$candidates[0]} = 1;
d92 1
a92 1
	    @@candidates = OpenBSD::PkgSpec::match($dep->{pattern}, available());
@


1.8
log
@kill code for handling old style dependencies.
@
text
@d2 1
a2 1
# $OpenBSD: Dependencies.pm,v 1.7 2007/04/15 10:17:29 espie Exp $
d30 13
a53 1
	my @@avail;
a81 6
	    if (!@@avail) {
	    	@@avail = OpenBSD::PackageLocator::available();
		if (!$state->{forced}->{allversions}) {
		    @@avail = OpenBSD::PackageName::keep_most_recent(@@avail);
		}
	    }
d83 1
a83 1
	    @@candidates = OpenBSD::PkgSpec::match($dep->{pattern}, @@avail);
@


1.7
log
@update copyright years, standardize licence.
reword the introduction to the stuff originally from FreeBSD to clarify
slightly.
@
text
@d2 1
a2 1
# $OpenBSD: Dependencies.pm,v 1.6 2007/02/04 12:18:39 espie Exp $
d43 1
a43 10
	# do simple old style pkgdep first
	my @@deps = ();
	for my $dep (@@{$plist->{pkgdep}}) {
		if (!is_installed($dep->{name})) {
			push(@@deps, $dep->{name});
		}
		$to_register->{$dep->{name}} = 1;
	}
	for my $dep (@@{$plist->{depend}}, @@{$plist->{newdepend}}, @@{$plist->{libdepend}}) {
	    next if defined $dep->{name} and $dep->{name} ne $plist->pkgname();
d45 1
@


1.6
log
@streamline messages for interactive mode, no need to repeat the same list
twice.
@
text
@d2 1
a2 1
# $OpenBSD: Dependencies.pm,v 1.5 2006/11/17 15:34:15 espie Exp $
d4 1
a4 1
# Copyright (c) 2005 Marc Espie <espie@@openbsd.org>
@


1.5
log
@don't return undef, use plain return.
(return undef is only false in a scalar context)
found my perlcritic, one of the few issues I agree with...
@
text
@d2 1
a2 1
# $OpenBSD: Dependencies.pm,v 1.4 2005/10/10 11:24:34 espie Exp $
d97 1
a97 1
		    OpenBSD::Interactive::ask_list('Choose dependency for '.$plist->pkgname().': ',
@


1.4
log
@less verbose listing of libraries
@
text
@d2 1
a2 1
# $OpenBSD: Dependencies.pm,v 1.3 2005/09/04 22:47:56 espie Exp $
d127 1
a127 1
	return undef;
d142 1
a142 1
	return undef;
@


1.3
log
@* New -i interactive option, that can ask obnoxious questions.
* move the signature code to a packing-list method, prepend the pkgname.
* depend on distant listings, cache these systematically.
* cut the PKG_PATH at :/ systematically, much simpler than parsing URLs.
People should get used to trailing /s.
* let pkg_add -u actually run the update.
* check for signature in more places, for instance, let pkg_add installed_stuff
be a void operation.
* grab enough stuff during updates to check signatures, so that pkg_add -u
can report updates that are not needed right away, instead of waiting
for the more confusing `trying to update'
* beginning of @@module support.
* @@pkgpath support, including updates.
* systematically expand stems when applicable.
* use visitors systematically in pkg_info.
* pkg_info -S reports signature.
* remove hardcoding of categories in PackingList, so that future modules
will be able to expand them.
* add @@updateset and @@incompatibility keywords.
@
text
@d2 1
a2 1
# $OpenBSD: Dependencies.pm,v 1.1 2005/08/07 16:25:35 espie Exp $
d120 1
a120 1
	my ($verbose, $base, $spec, $dependencies) = @@_;
d124 1
a124 2
			print " found in $candidate\n" if $verbose;
			return 1;
a126 1
	print " not found." if $verbose;
d137 1
a137 4
		if (check_lib_spec($state->{very_verbose},
		    $base, $lib, {$try => 1})) {
			Warn "Found library ", $lib, " in old package $try\n"
			    if $state->{verbose};
d139 1
a139 1
			return 1;
d142 1
a142 1
	return 0;
d149 3
a151 3
	print "checking libspec $lib..." if $state->{very_verbose};
	if (check_lib_spec($state->{very_verbose},
	    $plist->pkgbase(), $lib, $dependencies)) {
d157 2
a158 2
		if (check_lib_spec($state->{very_verbose},
		    "/usr", $lib, {system => 1})) {
d161 2
a162 2
		if (check_lib_spec($state->{very_verbose},
		    "/usr/X11R6", $lib, {system => 1})) {
d167 3
a169 1
		if (find_old_lib($state, $plist->pkgbase(), $dep->{pattern}, $lib, $dependencies)) {
d186 2
a187 3
			if (check_lib_spec($state->{very_verbose},
			    $plist->pkgbase(), $lib, {$dep => 1})) {
				Warn "Found library ", $lib, " in dependent package $dep\n" if $state->{verbose};
d206 2
a207 3
			if (check_lib_spec($state->{very_verbose},
			    $plist->pkgbase(), $lib, {$dep => 1})) {
				Warn "Found unmarked library ", $lib, " in dependent package $dep\n" if $state->{verbose};
d213 1
a213 1
	print "\n" if $state->{very_verbose};
@


1.2
log
@bug fix: if default is not available, do not push it for installation.
@
text
@d28 1
d41 1
d78 6
d85 1
a85 1
	    @@candidates = OpenBSD::PkgSpec::match($dep->{pattern}, OpenBSD::PackageLocator::available());
d93 8
a100 8
		# grab default if available
		if (grep {$_ eq $dep->{def}} @@candidates) {
		    push(@@deps, $dep->{def});
		    $to_register->{$dep->{def}} = 1;
		    next;
		}
		push(@@deps, $candidates[0]);
		$to_register->{$candidates[0]} = 1;
@


1.1
log
@split off the code that handles dependencies proper, so that we can (later)
reuse it in pkg_info or lib-depends-check.
@
text
@d2 1
a2 1
# $OpenBSD$
d93 1
@

