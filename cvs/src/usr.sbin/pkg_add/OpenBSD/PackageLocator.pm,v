head	1.110;
access;
symbols
	OPENBSD_6_2:1.110.0.4
	OPENBSD_6_2_BASE:1.110
	OPENBSD_6_1:1.108.0.4
	OPENBSD_6_1_BASE:1.108
	OPENBSD_6_0:1.105.0.6
	OPENBSD_6_0_BASE:1.105
	OPENBSD_5_9:1.105.0.2
	OPENBSD_5_9_BASE:1.105
	OPENBSD_5_8:1.103.0.8
	OPENBSD_5_8_BASE:1.103
	OPENBSD_5_7:1.103.0.2
	OPENBSD_5_7_BASE:1.103
	OPENBSD_5_6:1.103.0.4
	OPENBSD_5_6_BASE:1.103
	OPENBSD_5_5:1.102.0.6
	OPENBSD_5_5_BASE:1.102
	OPENBSD_5_4:1.102.0.2
	OPENBSD_5_4_BASE:1.102
	OPENBSD_5_3:1.100.0.4
	OPENBSD_5_3_BASE:1.100
	OPENBSD_5_2:1.100.0.2
	OPENBSD_5_2_BASE:1.100
	OPENBSD_5_1_BASE:1.99
	OPENBSD_5_1:1.99.0.2
	OPENBSD_5_0:1.98.0.4
	OPENBSD_5_0_BASE:1.98
	OPENBSD_4_9:1.98.0.2
	OPENBSD_4_9_BASE:1.98
	OPENBSD_4_8:1.96.0.2
	OPENBSD_4_8_BASE:1.96
	OPENBSD_4_7:1.87.0.2
	OPENBSD_4_7_BASE:1.87
	OPENBSD_4_6:1.76.0.6
	OPENBSD_4_6_BASE:1.76
	OPENBSD_4_5:1.76.0.2
	OPENBSD_4_5_BASE:1.76
	OPENBSD_4_4:1.75.0.2
	OPENBSD_4_4_BASE:1.75
	OPENBSD_4_3:1.73.0.4
	OPENBSD_4_3_BASE:1.73
	OPENBSD_4_2:1.73.0.2
	OPENBSD_4_2_BASE:1.73
	OPENBSD_4_1:1.54.0.2
	OPENBSD_4_1_BASE:1.54
	OPENBSD_4_0:1.53.0.2
	OPENBSD_4_0_BASE:1.53
	OPENBSD_3_9:1.50.0.2
	OPENBSD_3_9_BASE:1.50
	OPENBSD_3_8:1.20.0.2
	OPENBSD_3_8_BASE:1.20
	OPENBSD_3_7:1.11.0.4
	OPENBSD_3_7_BASE:1.11
	OPENBSD_3_6:1.11.0.2
	OPENBSD_3_6_BASE:1.11
	OPENBSD_3_5:1.9.0.2
	OPENBSD_3_5_BASE:1.9
	pkgtools:1.1.1.1
	espie:1.1.1;
locks; strict;
comment	@# @;


1.110
date	2017.05.29.12.28.54;	author espie;	state Exp;
branches;
next	1.109;
commitid	Cgf05tZggkOgfUsE;

1.109
date	2017.05.18.12.24.15;	author espie;	state Exp;
branches;
next	1.108;
commitid	Padq7bNQdWrGtjzv;

1.108
date	2017.03.09.14.33.32;	author espie;	state Exp;
branches;
next	1.107;
commitid	PwhbhajV0nubPxQ4;

1.107
date	2017.03.01.10.35.24;	author espie;	state Exp;
branches;
next	1.106;
commitid	WLXUAeW6LYQMCSi5;

1.106
date	2016.10.03.14.15.55;	author espie;	state Exp;
branches;
next	1.105;
commitid	4Eo9wuSrk4MGj9WT;

1.105
date	2016.01.30.11.29.29;	author espie;	state Exp;
branches;
next	1.104;
commitid	2wS0pE1OgZTaZHle;

1.104
date	2016.01.27.20.49.45;	author sthen;	state Exp;
branches;
next	1.103;
commitid	4BMp8OoFgOvY0Ive;

1.103
date	2014.03.18.18.53.29;	author espie;	state Exp;
branches;
next	1.102;

1.102
date	2013.05.29.21.58.25;	author espie;	state Exp;
branches;
next	1.101;

1.101
date	2013.05.29.09.35.16;	author espie;	state Exp;
branches;
next	1.100;

1.100
date	2012.07.13.07.50.13;	author espie;	state Exp;
branches;
next	1.99;

1.99
date	2011.08.26.08.46.10;	author espie;	state Exp;
branches;
next	1.98;

1.98
date	2010.12.24.09.04.14;	author espie;	state Exp;
branches;
next	1.97;

1.97
date	2010.10.27.14.35.56;	author espie;	state Exp;
branches;
next	1.96;

1.96
date	2010.08.07.21.19.04;	author espie;	state Exp;
branches;
next	1.95;

1.95
date	2010.07.02.12.42.49;	author espie;	state Exp;
branches;
next	1.94;

1.94
date	2010.07.02.11.41.30;	author espie;	state Exp;
branches;
next	1.93;

1.93
date	2010.07.02.11.17.46;	author espie;	state Exp;
branches;
next	1.92;

1.92
date	2010.06.30.10.51.04;	author espie;	state Exp;
branches;
next	1.91;

1.91
date	2010.06.30.10.41.42;	author espie;	state Exp;
branches;
next	1.90;

1.90
date	2010.06.30.10.37.25;	author espie;	state Exp;
branches;
next	1.89;

1.89
date	2010.06.25.10.15.13;	author espie;	state Exp;
branches;
next	1.88;

1.88
date	2010.05.10.09.17.55;	author espie;	state Exp;
branches;
next	1.87;

1.87
date	2010.01.10.11.32.41;	author espie;	state Exp;
branches;
next	1.86;

1.86
date	2010.01.09.15.10.17;	author espie;	state Exp;
branches;
next	1.85;

1.85
date	2010.01.09.14.55.53;	author espie;	state Exp;
branches;
next	1.84;

1.84
date	2010.01.09.14.49.53;	author espie;	state Exp;
branches;
next	1.83;

1.83
date	2010.01.09.13.44.57;	author espie;	state Exp;
branches;
next	1.82;

1.82
date	2010.01.09.12.01.57;	author espie;	state Exp;
branches;
next	1.81;

1.81
date	2010.01.09.11.26.58;	author espie;	state Exp;
branches;
next	1.80;

1.80
date	2010.01.09.10.59.48;	author espie;	state Exp;
branches;
next	1.79;

1.79
date	2010.01.09.10.45.32;	author espie;	state Exp;
branches;
next	1.78;

1.78
date	2010.01.09.09.45.40;	author espie;	state Exp;
branches;
next	1.77;

1.77
date	2010.01.09.09.37.45;	author espie;	state Exp;
branches;
next	1.76;

1.76
date	2008.10.20.10.25.16;	author espie;	state Exp;
branches;
next	1.75;

1.75
date	2008.06.18.12.24.58;	author espie;	state Exp;
branches;
next	1.74;

1.74
date	2008.06.18.12.04.41;	author espie;	state Exp;
branches;
next	1.73;

1.73
date	2007.06.04.14.57.33;	author espie;	state Exp;
branches;
next	1.72;

1.72
date	2007.06.04.14.40.39;	author espie;	state Exp;
branches;
next	1.71;

1.71
date	2007.05.19.09.45.33;	author espie;	state Exp;
branches;
next	1.70;

1.70
date	2007.05.19.09.18.55;	author espie;	state Exp;
branches;
next	1.69;

1.69
date	2007.05.14.12.52.53;	author espie;	state Exp;
branches;
next	1.68;

1.68
date	2007.05.13.17.00.02;	author espie;	state Exp;
branches;
next	1.67;

1.67
date	2007.05.13.13.37.00;	author espie;	state Exp;
branches;
next	1.66;

1.66
date	2007.05.13.13.12.21;	author espie;	state Exp;
branches;
next	1.65;

1.65
date	2007.05.13.12.34.32;	author espie;	state Exp;
branches;
next	1.64;

1.64
date	2007.05.13.10.16.06;	author espie;	state Exp;
branches;
next	1.63;

1.63
date	2007.05.12.15.00.30;	author espie;	state Exp;
branches;
next	1.62;

1.62
date	2007.05.12.14.52.26;	author espie;	state Exp;
branches;
next	1.61;

1.61
date	2007.05.12.14.16.38;	author espie;	state Exp;
branches;
next	1.60;

1.60
date	2007.05.08.08.42.02;	author espie;	state Exp;
branches;
next	1.59;

1.59
date	2007.05.07.14.12.43;	author espie;	state Exp;
branches;
next	1.58;

1.58
date	2007.05.07.13.27.28;	author espie;	state Exp;
branches;
next	1.57;

1.57
date	2007.05.02.15.05.30;	author espie;	state Exp;
branches;
next	1.56;

1.56
date	2007.04.29.11.09.29;	author espie;	state Exp;
branches;
next	1.55;

1.55
date	2007.04.15.10.17.29;	author espie;	state Exp;
branches;
next	1.54;

1.54
date	2007.03.06.23.35.01;	author espie;	state Exp;
branches;
next	1.53;

1.53
date	2006.03.08.12.10.47;	author espie;	state Exp;
branches;
next	1.52;

1.52
date	2006.03.04.13.13.05;	author espie;	state Exp;
branches;
next	1.51;

1.51
date	2006.03.04.11.28.03;	author espie;	state Exp;
branches;
next	1.50;

1.50
date	2006.02.21.19.20.54;	author espie;	state Exp;
branches;
next	1.49;

1.49
date	2006.02.09.09.38.41;	author espie;	state Exp;
branches;
next	1.48;

1.48
date	2005.11.03.13.28.07;	author espie;	state Exp;
branches;
next	1.47;

1.47
date	2005.11.02.22.26.51;	author espie;	state Exp;
branches;
next	1.46;

1.46
date	2005.10.25.23.38.51;	author espie;	state Exp;
branches;
next	1.45;

1.45
date	2005.10.22.17.44.07;	author espie;	state Exp;
branches;
next	1.44;

1.44
date	2005.10.22.15.00.47;	author espie;	state Exp;
branches;
next	1.43;

1.43
date	2005.10.22.13.11.55;	author espie;	state Exp;
branches;
next	1.42;

1.42
date	2005.10.10.09.33.56;	author espie;	state Exp;
branches;
next	1.41;

1.41
date	2005.09.24.08.43.59;	author espie;	state Exp;
branches;
next	1.40;

1.40
date	2005.09.19.10.15.01;	author espie;	state Exp;
branches;
next	1.39;

1.39
date	2005.09.19.09.49.51;	author espie;	state Exp;
branches;
next	1.38;

1.38
date	2005.09.17.12.45.49;	author espie;	state Exp;
branches;
next	1.37;

1.37
date	2005.09.17.12.10.32;	author espie;	state Exp;
branches;
next	1.36;

1.36
date	2005.09.17.09.30.16;	author espie;	state Exp;
branches;
next	1.35;

1.35
date	2005.09.16.23.17.39;	author espie;	state Exp;
branches;
next	1.34;

1.34
date	2005.09.16.20.03.50;	author espie;	state Exp;
branches;
next	1.33;

1.33
date	2005.09.16.10.00.59;	author espie;	state Exp;
branches;
next	1.32;

1.32
date	2005.09.14.09.50.40;	author espie;	state Exp;
branches;
next	1.31;

1.31
date	2005.09.13.21.20.01;	author espie;	state Exp;
branches;
next	1.30;

1.30
date	2005.09.13.21.08.14;	author espie;	state Exp;
branches;
next	1.29;

1.29
date	2005.09.13.20.44.08;	author espie;	state Exp;
branches;
next	1.28;

1.28
date	2005.09.13.20.03.29;	author espie;	state Exp;
branches;
next	1.27;

1.27
date	2005.09.13.19.40.30;	author espie;	state Exp;
branches;
next	1.26;

1.26
date	2005.09.13.10.44.06;	author espie;	state Exp;
branches;
next	1.25;

1.25
date	2005.09.13.10.25.33;	author espie;	state Exp;
branches;
next	1.24;

1.24
date	2005.09.13.10.00.48;	author espie;	state Exp;
branches;
next	1.23;

1.23
date	2005.09.13.09.30.55;	author espie;	state Exp;
branches;
next	1.22;

1.22
date	2005.09.13.09.21.01;	author espie;	state Exp;
branches;
next	1.21;

1.21
date	2005.09.04.22.47.56;	author espie;	state Exp;
branches;
next	1.20;

1.20
date	2005.08.22.11.30.30;	author espie;	state Exp;
branches;
next	1.19;

1.19
date	2005.08.19.00.10.56;	author espie;	state Exp;
branches;
next	1.18;

1.18
date	2005.08.16.11.09.28;	author espie;	state Exp;
branches;
next	1.17;

1.17
date	2005.08.16.10.24.23;	author espie;	state Exp;
branches;
next	1.16;

1.16
date	2005.08.16.09.44.07;	author espie;	state Exp;
branches;
next	1.15;

1.15
date	2005.08.16.09.35.15;	author espie;	state Exp;
branches;
next	1.14;

1.14
date	2005.06.26.16.41.08;	author espie;	state Exp;
branches;
next	1.13;

1.13
date	2005.06.26.12.44.29;	author espie;	state Exp;
branches;
next	1.12;

1.12
date	2005.06.26.11.25.11;	author espie;	state Exp;
branches;
next	1.11;

1.11
date	2004.08.06.08.06.01;	author espie;	state Exp;
branches;
next	1.10;

1.10
date	2004.08.06.07.51.17;	author espie;	state Exp;
branches;
next	1.9;

1.9
date	2004.03.11.18.54.06;	author espie;	state Exp;
branches;
next	1.8;

1.8
date	2004.03.07.19.29.08;	author espie;	state Exp;
branches;
next	1.7;

1.7
date	2004.01.28.22.30.50;	author espie;	state Exp;
branches;
next	1.6;

1.6
date	2003.12.19.00.29.20;	author espie;	state Exp;
branches;
next	1.5;

1.5
date	2003.11.06.17.59.23;	author espie;	state Exp;
branches;
next	1.4;

1.4
date	2003.10.31.18.42.51;	author espie;	state Exp;
branches;
next	1.3;

1.3
date	2003.10.23.23.18.55;	author espie;	state Exp;
branches;
next	1.2;

1.2
date	2003.10.19.18.41.56;	author espie;	state Exp;
branches;
next	1.1;

1.1
date	2003.10.16.17.43.34;	author espie;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2003.10.16.17.43.34;	author espie;	state Exp;
branches;
next	;


desc
@@


1.110
log
@Refactor locator code so it's a proper object.
allow  fw_update to short-circuit entirely, thus the specific
treatment of paths is actually less of a special case,
and the code that reaches into /etc/installurl is no longer used
at all in that case.

problem noticed by mlarkin@@
@
text
@# ex:ts=8 sw=4:
# $OpenBSD: PackageLocator.pm,v 1.109 2017/05/18 12:24:15 espie Exp $
#
# Copyright (c) 2003-2010 Marc Espie <espie@@openbsd.org>
#
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

use strict;
use warnings;

package OpenBSD::PackageLocator;

use OpenBSD::PackageRepositoryList;
use OpenBSD::PackageRepository;

my $default_path;

sub add_default
{
	my ($self, $state, $p) = @@_;
	my $w;

	if (defined $ENV{TRUSTED_PKG_PATH}) {
		my $v = $ENV{TRUSTED_PKG_PATH};
		$v =~ s/^\:+//o;
		$v =~ s/\:+$//o;
		while (my $o = OpenBSD::PackageRepository->parse(\$v, $state)) {
			$o->{trusted} = 1;
			$p->add($o);
		}
	} else {
		$w = "./:installpath";
	}
	if (defined $ENV{PKG_PATH}) {
		$w = $ENV{PKG_PATH};
	}
	if (defined $w) {
		$w =~ s/^\:+//o;
		$w =~ s/\:+$//o;
		while (my $o = OpenBSD::PackageRepository->parse(\$w, $state)) {
			$p->add($o);
		}
	}
}

sub build_default_path
{
	my ($self, $state) = @@_;
	$default_path = OpenBSD::PackageRepositoryList->new($state);

	$self->add_default($state, $default_path);
}

sub default_path
{
	my ($self, $state) = @@_;
	if (!defined $default_path) {
		$self->build_default_path($state);
	}
	return $default_path;
}

sub printable_default_path
{
	my ($self, $state) = @@_;

	return join(':', $self->default_path($state)->do_something('url'));
}

sub path_parse
{
	my ($self, $pkgname, $state, $path) = (@@_, './');
	if ($pkgname =~ m/^(.*[\/\:])(.*)/) {
		($pkgname, $path) = ($2, $1);
	}

	return (OpenBSD::PackageRepository->new($path, $state), $pkgname);
}

sub find
{
	my ($self, $url, $state) = @@_;

	my $package;
	if ($url =~ m/[\/\:]/o) {
		my ($repository, $pkgname) = $self->path_parse($url, $state);
		$package = $repository->find($pkgname);
		if (defined $package) {
			$self->default_path($state)->add($repository);
		}
	} else {
		$package = $self->default_path($state)->find($url);
	}
	return $package;
}

sub grabPlist
{
	my ($self, $url, $code, $state) = @@_;

	my $plist;
	if ($url =~ m/[\/\:]/o) {
		my ($repository, $pkgname) = $self->path_parse($url, $state);
		$plist = $repository->grabPlist($pkgname, $code);
		if (defined $plist) {
			$self->default_path($state)->add($repository);
		}
	} else {
		$plist = $self->default_path($state)->grabPlist($url, $code);
	}
	return $plist;
}

sub match_locations
{
	my ($self, @@search) = @@_;
	my $state = pop @@search;
	return $self->default_path($state)->match_locations(@@search);
}

1;
@


1.109
log
@introduce new url "installpath" to mean "the contents of installurl"
use it to simplify logic.

have ./ always be silent, wherever it may come from.

zap NOINSTALLPATH since it's more intuitive to just define PKG_PATH=
(nothing) now.
@
text
@d2 1
a2 1
# $OpenBSD: PackageLocator.pm,v 1.108 2017/03/09 14:33:32 espie Exp $
d28 1
a28 1
sub build_default_path
d30 1
a30 3
	my ($self, $state) = @@_;
	$default_path = OpenBSD::PackageRepositoryList->new($state);

d39 1
a39 1
			$default_path->add($o);
d51 1
a51 1
			$default_path->add($o);
d56 8
d66 1
d68 1
a68 1
		&build_default_path;
d71 7
@


1.108
log
@tweak installurl code to return a single string that gets parsed
so that we don't have to write the same thing twice later.
@
text
@d2 1
a2 1
# $OpenBSD: PackageLocator.pm,v 1.107 2017/03/01 10:35:24 espie Exp $
d33 1
a33 1
	my $path_set = 0;
d43 2
a44 1
		$path_set = 1;
d47 1
a47 7
		my $v = $ENV{PKG_PATH};
		$v =~ s/^\:+//o;
		$v =~ s/\:+$//o;
		while (my $o = OpenBSD::PackageRepository->parse(\$v, $state)) {
			$default_path->add($o);
		}
		$path_set = 1;
d49 4
a52 6
	return if $path_set;
	$default_path->add(OpenBSD::PackageRepository->new("./", $state)->can_be_empty);
	return if $state->defines('NOINSTALLPATH');

	if (defined(my $i = $state->installpath)) {
		while (my $o = OpenBSD::PackageRepository->parse(\$i, $state)) {
@


1.107
log
@scrape most of the config framework
okay aja@@, rpe@@
@
text
@d2 1
a2 1
# $OpenBSD: PackageLocator.pm,v 1.106 2016/10/03 14:15:55 espie Exp $
d58 4
a61 2
	for my $i (@@{$state->installpath}) {
		$default_path->add(OpenBSD::PackageRepository->new($i, $state));
@


1.106
log
@add TRUSTED_PKG_PATH after discussing with aja@@
use case is testing binary packages among developers, -Dunsigned means
everything is unsigned, which is bad for dependencies
@
text
@d2 1
a2 1
# $OpenBSD: PackageLocator.pm,v 1.105 2016/01/30 11:29:29 espie Exp $
d58 1
a58 2
	return unless defined $state->config->value('installpath');
	for my $i ($state->config->value("installpath")) {
@


1.105
log
@redo sthen's idea deeper in pkg_add, so that *every* url can be abbreviated
the same way (e.g., PKG_PATH=ftp.openbsd.org  will work)

okay sthen@@
@
text
@d2 1
a2 1
# $OpenBSD: PackageLocator.pm,v 1.104 2016/01/27 20:49:45 sthen Exp $
d33 12
d52 1
a52 1
		return;
d54 1
@


1.104
log
@Allow pkg.conf's installpath to be set to a bare hostname (no /), which
implies http://hostname/pub/OpenBSD/[snapshots-or-version]/packages/[arch].
This could be handled at a different location in the code to support PKG_PATH
but this approach is pretty simple and I have something else to make use of it.
ok espie@@ for now.
@
text
@d2 1
a2 1
# $OpenBSD: PackageLocator.pm,v 1.103 2014/03/18 18:53:29 espie Exp $
a46 1
	    	$i =~ s/(^[a-z0-9][a-z0-9.]+\.[a-z0-9.]+$)/http:\/\/$1\/%m/;
@


1.103
log
@remove $_ usage that warns under perl 5.18
@
text
@d2 1
a2 1
# $OpenBSD: PackageLocator.pm,v 1.102 2013/05/29 21:58:25 espie Exp $
d47 1
@


1.102
log
@I had misgivings about that one, I was right. Missed an obvious testcases,
and my crash bunnies ARE a bunch of unreliable nitwits.

thanks kili@@
@
text
@d2 1
a2 1
# $OpenBSD: PackageLocator.pm,v 1.101 2013/05/29 09:35:16 espie Exp $
d71 1
a71 1
	my ($self, $_, $state) = @@_;
d74 2
a75 2
	if (m/[\/\:]/o) {
		my ($repository, $pkgname) = $self->path_parse($_, $state);
d81 1
a81 1
		$package = $self->default_path($state)->find($_);
d88 1
a88 1
	my ($self, $_, $code, $state) = @@_;
d91 2
a92 2
	if (m/[\/\:]/o) {
		my ($repository, $pkgname) = $self->path_parse($_, $state);
d98 1
a98 1
		$plist = $self->default_path($state)->grabPlist($_, $code);
@


1.101
log
@allow installpath to use +=, requested by quite a few people,
but did require testing.
@
text
@d2 1
a2 1
# $OpenBSD: PackageLocator.pm,v 1.100 2012/07/13 07:50:13 espie Exp $
d45 1
@


1.100
log
@temporary option until I come up with a nicer way: if -DNOINSTALLPATH
don't even look in pkg.conf for the installpath.
@
text
@d2 1
a2 1
# $OpenBSD$
d45 1
a45 1
	if (my $i = $state->config->value("installpath")) {
@


1.99
log
@zap fatpackages. nobody actually uses them.
accordingly, locations do not need to track architecture.
@
text
@d2 1
a2 1
# $OpenBSD: PackageLocator.pm,v 1.98 2010/12/24 09:04:14 espie Exp $
d43 2
@


1.98
log
@handle failures from ports tree with more care.
this does avoid infinite loops in case of wrong plists.
necessary since print-plist-with-depends CAN fail...
@
text
@d2 1
a2 1
# $OpenBSD$
d68 1
a68 1
	my ($self, $_, $arch, $state) = @@_;
d73 1
a73 1
		$package = $repository->find($pkgname, $arch);
d78 1
a78 1
		$package = $self->default_path($state)->find($_, $arch);
d85 1
a85 1
	my ($self, $_, $arch, $code, $state) = @@_;
d90 1
a90 1
		$plist = $repository->grabPlist($pkgname, $arch, $code);
d95 1
a95 1
		$plist = $self->default_path($state)->grabPlist($_, $arch, $code);
@


1.97
log
@initial scaffolding for @@rcscript: for now, acts like normal files,
but allow absolute pathnames (treat that as an implicit @@cwd).
@
text
@@


1.96
log
@nasty inversion of parameters, so that state did not get propagated correctly.
ended up calling './'->errsay in ArcCheck, which of course doesn't work, so
a die() in the middle of a package install... compounded with file !existing,
so that adjust checksum would fail, and so not even a partial install...
@
text
@d2 1
a2 1
# $OpenBSD: PackageLocator.pm,v 1.95 2010/07/02 12:42:49 espie Exp $
@


1.95
log
@parse pkg.conf and use it for default_path if PKG_PATH is not defined.
@
text
@d2 1
a2 1
# $OpenBSD: PackageLocator.pm,v 1.94 2010/07/02 11:41:30 espie Exp $
d58 1
a58 1
	my ($self, $pkgname, $path, $state) = (@@_, './');
@


1.94
log
@fix params so that state is state and not PackageLocator...
@
text
@d2 1
a2 1
# $OpenBSD: PackageLocator.pm,v 1.93 2010/07/02 11:17:46 espie Exp $
d28 1
a28 1
sub default_path
d30 2
a31 3
	if (!defined $default_path) {
		my ($self, $state) = @@_;
		$default_path = OpenBSD::PackageRepositoryList->new($state);
d33 6
a38 9
		if (defined $ENV{PKG_PATH}) {
			my $v = $ENV{PKG_PATH};
			$v =~ s/^\:+//o;
			$v =~ s/\:+$//o;
			while (my $o = OpenBSD::PackageRepository->parse(\$v, $state)) {
				$default_path->add($o);
			}
		} else {
			$default_path->add(OpenBSD::PackageRepository->new("./", $state));
d40 7
d48 4
@


1.93
log
@pass (and save) state around in Repository-related stuff.
@
text
@d2 1
a2 1
# $OpenBSD: PackageLocator.pm,v 1.92 2010/06/30 10:51:04 espie Exp $
d31 1
a31 1
		my $state = shift;
@


1.92
log
@allow say and errsay to work without parameters, as it's ways common.
create verbose_system up in state, because it makes sense without verbose.
@
text
@d2 1
a2 1
# $OpenBSD$
d31 2
a32 1
		$default_path = OpenBSD::PackageRepositoryList->new;
d38 1
a38 1
			while (my $o = OpenBSD::PackageRepository->parse(\$v)) {
d42 1
a42 1
			$default_path->add(OpenBSD::PackageRepository->new("./"));
a48 8
my $singleton;

sub new
{
	my ($class, $state) = @@_;
	return $singleton //= bless { state => $state }, $class;
}

d51 1
a51 1
	my ($self, $pkgname, $path) = (@@_, './');
d56 1
a56 1
	return (OpenBSD::PackageRepository->new($path), $pkgname);
d61 1
a61 1
	my ($self, $_, $arch) = @@_;
d65 1
a65 1
		my ($repository, $pkgname) = $self->path_parse($_);
d68 1
a68 1
			$self->default_path->add($repository);
d71 1
a71 1
		$package = $self->default_path->find($_, $arch);
d78 1
a78 1
	my ($self, $_, $arch, $code) = @@_;
d82 1
a82 1
		my ($repository, $pkgname) = $self->path_parse($_);
d85 1
a85 1
			$self->default_path->add($repository);
d88 1
a88 1
		$plist = $self->default_path->grabPlist($_, $arch, $code);
d96 2
a97 1
	return $self->default_path->match_locations(@@search);
@


1.91
log
@whitespace cleanup
@
text
@@


1.90
log
@extra parameter to UpdateSet: use the factory to create extra object.
don't create updatesets directly, go through AddDelete::State.
Get all Locator/Repo access through state.
@
text
@@


1.89
log
@allow creation of a unique PackageLocator object, that stores state,
and thus can eventually be used to create repositories, print messages,
etc.
@
text
@d2 1
a2 1
# $OpenBSD: PackageLocator.pm,v 1.88 2010/05/10 09:17:55 espie Exp $
@


1.88
log
@whitespace fixes
@
text
@d2 1
a2 1
# $OpenBSD$
d48 8
d58 1
a58 1
	my ($class, $pkgname, $path) = (@@_, './');
d68 1
a68 1
	my ($class, $_, $arch) = @@_;
d72 1
a72 1
		my ($repository, $pkgname) = $class->path_parse($_);
d75 1
a75 1
			$class->default_path->add($repository);
d78 1
a78 1
		$package = $class->default_path->find($_, $arch);
d85 1
a85 1
	my ($class, $_, $arch, $code) = @@_;
d89 1
a89 1
		my ($repository, $pkgname) = $class->path_parse($_);
d92 1
a92 1
			$class->default_path->add($repository);
d95 1
a95 1
		$plist = $class->default_path->grabPlist($_, $arch, $code);
d102 2
a103 2
	my ($class, @@search) = @@_;
	return $class->default_path->match_locations(@@search);
@


1.87
log
@bump copyright
@
text
@@


1.86
log
@zap unused
@
text
@d4 1
a4 1
# Copyright (c) 2003-2007 Marc Espie <espie@@openbsd.org>
@


1.85
log
@streamline interface
@
text
@d55 1
a55 1
	return (OpenBSD::PackageRepository->new($path), $path, $pkgname);
d64 1
a64 1
		my ($repository, undef, $pkgname) = $class->path_parse($_);
d81 1
a81 1
		my ($repository, undef, $pkgname) = $class->path_parse($_);
@


1.84
log
@move signal catching up, so we can clean repos and temp files at once.
Fix main program try/catch: signal message should use standard form so
it gets caught.
@
text
@d26 1
a26 2
# this returns an archive handle from an uninstalled package name, currently
# There is a cache available.
d28 15
a42 2
my %packages;
my $pkgpath = OpenBSD::PackageRepositoryList->new;
a43 6
if (defined $ENV{PKG_PATH}) {
	my $v = $ENV{PKG_PATH};
	$v =~ s/^\:+//o;
	$v =~ s/\:+$//o;
	while (my $o = OpenBSD::PackageRepository->parse(\$v)) {
		$pkgpath->add($o);
d45 1
a45 2
} else {
	$pkgpath->add(OpenBSD::PackageRepository->new("./"));
a47 3
# rebuild PKG_PATH
#$ENV{PKG_PATH} = $pkgpath->print_without_src;

d50 1
a50 1
	my ($pkgname, $path) = (shift, './');
a61 3
	if (exists $packages{$_}) {
		return $packages{$_};
	}
d64 1
a64 1
		my ($repository, undef, $pkgname) = path_parse($_);
d67 1
a67 1
			$pkgpath->add($repository);
d70 1
a70 1
		$package = $pkgpath->find($_, $arch);
a71 1
	$packages{$_} = $package if defined($package);
d81 1
a81 1
		my ($repository, undef, $pkgname) = path_parse($_);
d84 1
a84 1
			$pkgpath->add($repository);
d87 1
a87 1
		$plist = $pkgpath->grabPlist($_, $arch, $code);
d95 1
a95 1
	return $pkgpath->match_locations(@@search);
d97 1
@


1.83
log
@kill cache, we don't really need it
@
text
@d26 4
d60 3
d73 1
a91 5
}

sub cleanup
{
	$pkgpath->cleanup;
@


1.82
log
@fixed version, somehow I forgot that I use parse to do weird things with
PKG_PATH...
@
text
@a25 4
# this returns an archive handle from an uninstalled package name, currently
# There is a cache available.

my %packages;
a55 3
	if (exists $packages{$_}) {
		return $packages{$_};
	}
a65 1
	$packages{$_} = $package if defined($package);
@


1.81
log
@temporary revert until I figure this out
@
text
@d48 3
a50 11
	use File::Basename;
	use OpenBSD::Paths;
	my $pkg_db = $ENV{"PKG_DBDIR"} || OpenBSD::Paths->pkgdb;

	my ($pkgname, $path) = fileparse(shift);
	my $repo;

	if ($path eq $pkg_db.'/') {
		$repo = OpenBSD::PackageRepository::Installed->new;
	} else {
		$repo = OpenBSD::PackageRepository->new($path);
d53 1
a53 1
	return ($repo, $path, $pkgname);
d64 1
a64 1
	if (m/\//o) {
d82 1
a82 1
	if (m/\//o) {
@


1.80
log
@move the code that recognizes /var/db/pkg as inst: into Repo::Local
@
text
@d48 11
a58 3
	my ($pkgname, $path) = (shift, './');
	if ($pkgname =~ m/^(.*[\/\:])(.*)/) {
		($pkgname, $path) = ($2, $1);
d61 1
a61 1
	return (OpenBSD::PackageRepository->new($path), $path, $pkgname);
d72 1
a72 1
	if (m/[\/\:]/o) {
d90 1
a90 1
	if (m/[\/\:]/o) {
@


1.79
log
@tweak path parsing to handle inst:pkgname and such as well...
@
text
@a47 3
	use OpenBSD::Paths;
	my $pkg_db = $ENV{"PKG_DBDIR"} || OpenBSD::Paths->pkgdb;

a51 7
	my $repo;

	if ($path eq $pkg_db.'/') {
		$repo = OpenBSD::PackageRepository::Installed->new;
	} else {
		$repo = OpenBSD::PackageRepository->new($path);
	}
d53 1
a53 1
	return ($repo, $path, $pkgname);
@


1.78
log
@move pipe handling into RepositoryList
@
text
@a47 1
	use File::Basename;
d51 4
a54 1
	my ($pkgname, $path) = fileparse(shift);
d74 1
a74 1
	if (m/\//o) {
d92 1
a92 1
	if (m/\//o) {
@


1.77
log
@repositories no longer need match
@
text
@a67 5
	if ($_ eq '-') {
		my $repository = OpenBSD::PackageRepository::Local::Pipe->_new('./');
		my $package = $repository->find(undef, $arch);
		return $package;
	}
a88 5
	if ($_ eq '-') {
		my $repository = OpenBSD::PackageRepository::Local::Pipe->_new('./');
		my $plist = $repository->grabPlist(undef, $arch, $code);
		return $plist;
	}
@


1.76
log
@Say goodbye to local $_
lexical scoping is so much neater (courtesy of perl 5.10)
@
text
@a116 6
sub match
{
	my ($class, @@search) = @@_;
	return $pkgpath->match(@@search);
}

@


1.75
log
@better standards for inst: paths.
@
text
@d43 3
d52 1
a52 1
	my ($pkgname, $path) = fileparse($_);
d66 1
a66 3
	my $class = shift;
	local $_ = shift;
	my $arch = shift;
d92 1
a92 4
	my $class = shift;
	local $_ = shift;
	my $arch = shift;
	my $code = shift;
@


1.74
log
@special-case parser so that /var/db/pkg becomes inst: during path_parse.
@
text
@d47 1
d52 2
a53 2
	if ($path eq OpenBSD::Paths::pkgdb().'/') {
		$repo = OpenBSD::PackageRepository::Installed->new($path);
@


1.73
log
@I am on drugs, I don't know where I found split can take strings as
arguments. Repair...
@
text
@d2 1
a2 1
# $OpenBSD: PackageLocator.pm,v 1.72 2007/06/04 14:40:39 espie Exp $
d36 2
a37 4
	my @@tentative = split /\/\:/o, $v;
	while (my $i = shift @@tentative) {
		$i =~ m|/$|o or $i.='/';
		$pkgpath->add(OpenBSD::PackageRepository->new($i));
d46 1
d49 9
a57 2
	my $repository = OpenBSD::PackageRepository->new($path);
	return ($repository, $path, $pkgname);
@


1.72
log
@some minor systematic changes.
- mark all regexps I can with /o if they can be compiled once.
- turn $o->method() into $o->method
- remove unneeded prototypes
- reduce split /re/ into split "string" where possible.
@
text
@d2 1
a2 1
# $OpenBSD: PackageLocator.pm,v 1.71 2007/05/19 09:45:33 espie Exp $
d36 1
a36 1
	my @@tentative = split '/:', $v;
@


1.71
log
@add match_locations/filter_locations methods to search stuff that returns
full pkg locations instead of package names.
@
text
@d2 1
a2 1
# $OpenBSD: PackageLocator.pm,v 1.70 2007/05/19 09:18:55 espie Exp $
d34 3
a36 3
	$v =~ s/^\:+//;
	$v =~ s/\:+$//;
	my @@tentative = split /\/\:/, $v;
d38 1
a38 1
		$i =~ m|/$| or $i.='/';
d69 1
a69 1
	if (m/\//) {
d95 1
a95 1
	if (m/\//) {
@


1.70
log
@don't pass srcpath around, since we don't use it.
@
text
@d2 1
a2 1
# $OpenBSD: PackageLocator.pm,v 1.69 2007/05/14 12:52:53 espie Exp $
d118 5
@


1.69
log
@kill "available" routine, which is no longer used.
@
text
@d2 1
a2 1
# $OpenBSD: PackageLocator.pm,v 1.68 2007/05/13 17:00:02 espie Exp $
a58 1
	my $srcpath = shift;
d62 1
a62 1
		my $package = $repository->find(undef, $arch, $srcpath);
d71 1
a71 1
		$package = $repository->find($pkgname, $arch, $srcpath);
d76 1
a76 1
		$package = $pkgpath->find($_, $arch, $srcpath);
@


1.68
log
@remove some specialness of the Filtering stuff.
@
text
@d2 1
a2 1
# $OpenBSD: PackageLocator.pm,v 1.67 2007/05/13 13:37:00 espie Exp $
a80 5
}

sub available
{
	return $pkgpath->available();
@


1.67
log
@kill unused stuff
@
text
@d2 1
a2 1
# $OpenBSD: PackageLocator.pm,v 1.66 2007/05/13 13:12:21 espie Exp $
d120 2
a121 2
	my ($class, $search, $filter) = @@_;
	return $pkgpath->match($search, $filter);
@


1.66
log
@also create PartialStem objects, and create a generic
PackageLocator->match($o), where $o can be a spec, a stem, a partialstem.
@
text
@d2 1
a2 1
# $OpenBSD: PackageLocator.pm,v 1.65 2007/05/13 12:34:32 espie Exp $
a117 18
sub match_spec
{
	my ($class, $spec, $filter) = @@_;
	return $pkgpath->match_spec($spec, $filter);
}

sub findstem
{
	my ($class, $stem, $filter) = @@_;
	return $pkgpath->findstem($stem, $filter);
}

sub find_partialstem
{
	my ($class, $partial, $filter) = @@_;
	return $pkgpath->find_partialstem($partial, $filter);
}

d121 1
a121 1
	return $pkgpath->match_repo($search, $filter);
@


1.65
log
@have PackageLocator defer to PackageRepositoryList, so that package
availability uses normal linker rules.
@
text
@d2 1
a2 1
# $OpenBSD: PackageLocator.pm,v 1.64 2007/05/13 10:16:06 espie Exp $
d134 6
@


1.64
log
@allow filtering while calling the Locator.
@
text
@d2 1
a2 1
# $OpenBSD: PackageLocator.pm,v 1.63 2007/05/12 15:00:30 espie Exp $
a117 2
my @@avail;

d121 1
a121 8
	if (!@@avail) {
	    @@avail = available();
	}
	if (defined $filter) {
		return &$filter($spec->match_ref(\@@avail));
	} else {
		return $spec->match_ref(\@@avail);
	}
a123 2
my $stemlist;

d127 1
a127 12
	if (!@@avail) {
		@@avail = available();
	}
	require OpenBSD::PackageName;
	if (!$stemlist) {
		$stemlist = OpenBSD::PackageName::avail2stems(@@avail);
	}
	if (defined $filter) {
		return &$filter($stemlist->findstem($stem));
	} else {
		return $stemlist->findstem($stem);
	}
d133 1
a133 12
	if (!@@avail) {
		@@avail = available();
	}
	require OpenBSD::PackageName;
	if (!$stemlist) {
		$stemlist = OpenBSD::PackageName::avail2stems(@@avail);
	}
	if (defined $filter) {
		return &$filter($stemlist->find_partialstem($partial));
	} else {
		return $stemlist->find_partialstem($partial);
	}
@


1.63
log
@kill old PkgSpec interface
@
text
@d2 1
a2 1
# $OpenBSD: PackageLocator.pm,v 1.62 2007/05/12 14:52:26 espie Exp $
d122 1
a122 1
	my ($class, $spec) = @@_;
d126 5
a130 1
	return $spec->match_ref(\@@avail);
d137 1
a137 1
	my ($class, $stem) = @@_;
d145 5
a149 1
	return $stemlist->findstem($stem);
d154 1
a154 1
	my ($class, $partial) = @@_;
d162 5
a166 1
	return $stemlist->find_partialstem($partial);
@


1.62
log
@use match_ref consistently
@
text
@d2 1
a2 1
# $OpenBSD: PackageLocator.pm,v 1.61 2007/05/12 14:16:38 espie Exp $
d126 1
a126 7
	if (ref $spec) {
		return $spec->match_ref(\@@avail);
	} else {
		require OpenBSD::PkgSpec;

		return OpenBSD::PkgSpec::match_ref($spec, \@@avail);
    	}
@


1.61
log
@also allow Spec objects in Repository matches.
@
text
@d2 1
a2 1
# $OpenBSD: PackageLocator.pm,v 1.60 2007/05/08 08:42:02 espie Exp $
d127 1
a127 1
		return $spec->match(@@avail);
d131 1
a131 1
		return OpenBSD::PkgSpec::match($spec, @@avail);
@


1.60
log
@spec match works better with a list
@
text
@d2 1
a2 1
# $OpenBSD: PackageLocator.pm,v 1.59 2007/05/07 14:12:43 espie Exp $
d126 4
a129 1
	require OpenBSD::PkgSpec;
d131 2
a132 1
	return OpenBSD::PkgSpec::match($spec, @@avail);
@


1.59
log
@remove dependency on available_stems(), make it go thru PackageLocator
@
text
@d2 1
a2 1
# $OpenBSD: PackageLocator.pm,v 1.58 2007/05/07 13:27:28 espie Exp $
d128 1
a128 1
	return OpenBSD::PkgSpec::match($spec);
@


1.58
log
@we want to no longer expose PackageLocator::available(), lift interfaces
up there, starting with match_spec.
@
text
@d2 1
a2 1
# $OpenBSD: PackageLocator.pm,v 1.57 2007/05/02 15:05:30 espie Exp $
d131 27
@


1.57
log
@$o->method() becomes $o->method
@
text
@d2 1
a2 1
# $OpenBSD: PackageLocator.pm,v 1.56 2007/04/29 11:09:29 espie Exp $
d118 2
d122 7
a128 2
	my $self = shift;
	return $pkgpath->match_spec(@@_);
d130 1
@


1.56
log
@replace $p->visit('method') calls with $p->method
now that it works.
@
text
@d2 1
a2 1
# $OpenBSD: PackageLocator.pm,v 1.55 2007/04/15 10:17:29 espie Exp $
d30 1
a30 1
my $pkgpath = OpenBSD::PackageRepositoryList->new();
d115 1
a115 1
	$pkgpath->cleanup();
@


1.55
log
@update copyright years, standardize licence.
reword the introduction to the stuff originally from FreeBSD to clarify
slightly.
@
text
@d2 1
a2 1
# $OpenBSD: PackageLocator.pm,v 1.54 2007/03/06 23:35:01 espie Exp $
d116 6
@


1.54
log
@get vfs size snapshotted and restored so that pkg_add -u has a harder
time overflowing the disk.

let stem work at the end of urls.

test sturm@@ and bernd@@,

okay deraadt@@
@
text
@d2 1
a2 1
# $OpenBSD: PackageLocator.pm,v 1.53 2006/03/08 12:10:47 espie Exp $
d4 1
a4 1
# Copyright (c) 2003-2004 Marc Espie <espie@@openbsd.org>
@


1.53
log
@propagate stuff to be able to explicitly clean-up repositories.
(we can't use a normal destructor, since this will be called for
each fork()ed subprocess).
@
text
@d2 1
a2 1
# $OpenBSD: PackageLocator.pm,v 1.52 2006/03/04 13:13:05 espie Exp $
d45 9
d71 1
a71 4
		use File::Basename;

		my ($pkgname, $path) = fileparse($_);
		my $repository = OpenBSD::PackageRepository->new($path);
d102 1
a102 4
		use File::Basename;

		my ($pkgname, $path) = fileparse($_);
		my $repository = OpenBSD::PackageRepository->new($path);
@


1.52
log
@cut down the Locator code into maintainable chunks.
@
text
@d2 1
a2 1
# $OpenBSD: PackageLocator.pm,v 1.51 2006/03/04 11:28:03 espie Exp $
d108 5
@


1.51
log
@zap more success messages. Keep pid of distant location pipe, just in case.
@
text
@d2 1
a2 1
# $OpenBSD: PackageLocator.pm,v 1.50 2006/02/21 19:20:54 espie Exp $
d21 1
a21 509
package OpenBSD::PackageRepository;

sub _new
{
	my ($class, $address) = @@_;
	bless { baseurl => $address }, $class;
}

sub new
{
	my ($class, $baseurl) = @@_;
	if ($baseurl =~ m/^ftp\:/i) {
		return OpenBSD::PackageRepository::FTP->_new($baseurl);
	} elsif ($baseurl =~ m/^http\:/i) {
		return OpenBSD::PackageRepository::HTTP->_new($baseurl);
	} elsif ($baseurl =~ m/^scp\:/i) {
		return OpenBSD::PackageRepository::SCP->_new($baseurl);
	} elsif ($baseurl =~ m/src\:/i) {
		return OpenBSD::PackageRepository::Source->_new($baseurl);
	} else {
		return OpenBSD::PackageRepository::Local->_new($baseurl);
	}
}

sub available
{
	my $self = shift;

	return @@{$self->list()};
}

sub wipe_info
{
	my ($self, $pkg) = @@_;

	require File::Path;

	my $dir = $pkg->{dir};
	if (defined $dir) {

	    File::Path::rmtree($dir);
	    delete $pkg->{dir};
	}
}

# by default, all objects may exist
sub may_exist
{
	return 1;
}

# by default, we don't track opened files for this key

sub opened
{
	undef;
}

# hint: 0 premature close, 1 real error. undef, normal !

sub close
{
	my ($self, $object, $hint) = @@_;
	close($object->{fh}) if defined $object->{fh};
	$self->parse_problems($object->{errors}, $hint) 
	    if defined $object->{errors};
	undef $object->{errors};
	$object->deref();
}

sub finish_and_close
{
	my ($self, $object) = @@_;
	$self->close($object);
}

sub close_now
{
	my ($self, $object) = @@_;
	$self->close($object, 0);
}

sub close_after_error
{
	my ($self, $object) = @@_;
	$self->close($object, 1);
}

sub close_with_client_error
{
	my ($self, $object) = @@_;
	$self->close($object, 1);
}

sub make_room
{
	my $self = shift;

	# kill old files if too many
	my $already = $self->opened();
	if (defined $already) {
		# gc old objects
		if (@@$already >= $self->maxcount()) {
			@@$already = grep { defined $_->{fh} } @@$already;
		}
		while (@@$already >= $self->maxcount()) {
			my $o = shift @@$already;
			$self->close_now($o);
		}
	}
	return $already;
}

# open method that tracks opened files per-host.
sub open
{
	my ($self, $object) = @@_;

	return undef unless $self->may_exist($object->{name});

	# kill old files if too many
	my $already = $self->make_room();
	my $fh = $self->open_pipe($object);
	if (!defined $fh) {
		return undef;
	}
	$object->{fh} = $fh;
	if (defined $already) {
		push @@$already, $object;
	}
	return $fh;
}

sub find
{
	my ($repository, $name, $arch, $srcpath) = @@_;
	$name.=".tgz" unless $name =~ m/\.tgz$/;
	my $self = OpenBSD::PackageLocation->new($repository, $name);

	return $self->openPackage($name, $arch);
}

sub grabPlist
{
	my ($repository, $name, $arch, $code) = @@_;
	$name.=".tgz" unless $name =~ m/\.tgz$/;
	my $self = OpenBSD::PackageLocation->new($repository, $name);

	return $self->grabPlist($name, $arch, $code);
}

sub parse_problems
{
	my ($self, $filename, $hint) = @@_;
	CORE::open(my $fh, '<', $filename) or return;

	my $baseurl = $self->{baseurl};
	local $_;
	my $notyet = 1;
	while(<$fh>) {
		next if m/^(?:200|220|221|226|229|230|227|250|331|500|150)[\s\-]/;
		next if m/^EPSV command not understood/;
		next if m/^Trying [\da-f\.\:]+\.\.\./;
		next if m/^Requesting \Q$baseurl\E/;
		next if m/^Remote system type is\s+/;
		next if m/^Connected to\s+/;
		next if m/^remote\:\s+/;
		next if m/^Using binary mode to transfer files/;
		next if m/^Retrieving\s+/;
		next if m/^Succesfully retrieved file/;
		next if m/^\d+\s+bytes\s+received\s+in/;
		next if m/^ftp: connect to address.*: No route to host/;

		if (defined $hint && $hint == 0) {
			next if m/^ftp: -: short write/;
			next if m/^421\s+/;
		}
		if ($notyet) {
			print STDERR "Error from $baseurl:\n" if $notyet;
			$notyet = 0;
		}
		if (m/^421\s+/ ||
		    m/^ftp: connect: Connection timed out/ ||
		    m/^ftp: Can't connect or login to host/) {
			$self->{lasterror} = 421;
		}
		if (m/^550\s+/) {
			$self->{lasterror} = 550;
		}
		print STDERR  $_;
	}
	CORE::close($fh);
	unlink $filename;
}

package OpenBSD::PackageRepository::Installed;
our @@ISA=qw(OpenBSD::PackageRepository);
use OpenBSD::PackageInfo;

sub new
{
	bless {}, shift;
}

sub find
{
	my ($repository, $name, $arch, $srcpath) = @@_;
	my $self;

	if (is_installed($name)) {
		$self = OpenBSD::PackageLocation->new($repository, $name);
		$self->{dir} = installed_info($name);
	}
	return $self;
}

sub grabPlist
{
	my ($repository, $name, $arch, $code) = @@_;
	require OpenBSD::PackingList;
	return  OpenBSD::PackingList->from_installation($name, $code);
}

sub available
{
	return installed_packages();
}

sub list
{
	my @@list = installed_packages();
	return \@@list;
}

sub wipe_info
{
}

sub may_exist
{
	my ($self, $name) = @@_;
	return is_installed($name);
}

package PackageRepository::Source;

sub find
{
	my ($repository, $name, $arch, $srcpath) = @@_;
	my $dir;
	my $make;
	if (defined $ENV{'MAKE'}) {
		$make = $ENV{'MAKE'};
	} else {
		$make = '/usr/bin/make';
	}
	if (defined $repository->{baseurl} && $repository->{baseurl} ne '') {
		$dir = $repository->{baseurl}
	} elsif (defined $ENV{PORTSDIR}) {
		$dir = $ENV{PORTSDIR};
	} else {
		$dir = '/usr/ports';
	}
	# figure out the repository name and the pkgname
	my $pkgfile = `cd $dir && SUBDIR=$srcpath ECHO_MSG=: $make show=PKGFILE`;
	chomp $pkgfile;
	if (! -f $pkgfile) {
		system "cd $dir && SUBDIR=$srcpath $make package BULK=Yes";
	}
	if (! -f $pkgfile) {
		return undef;
	}
	$pkgfile =~ m|(.*/)([^/]*)|;
	my ($base, $fname) = ($1, $2);

	my $repo = OpenBSD::PackageRepository::Local->_new($base);
	return $repo->find($fname);
}

package OpenBSD::PackageRepository::Local;
our @@ISA=qw(OpenBSD::PackageRepository);

sub open_pipe
{
	my ($self, $object) = @@_;
	my $pid = open(my $fh, "-|");
	if (!defined $pid) {
		die "Cannot fork: $!";
	}
	if ($pid) {
		return $fh;
	} else {
		open STDERR, ">/dev/null";
		exec {"/usr/bin/gzip"} 
		    "gzip", 
		    "-d", 
		    "-c", 
		    "-q", 
		    "-f", 
		    $self->{baseurl}.$object->{name}
		or die "Can't run gzip";
	}
}

sub may_exist
{
	my ($self, $name) = @@_;
	return -r $self->{baseurl}.$name;
}

sub list
{
	my $self = shift;
	my $l = [];
	my $dname = $self->{baseurl};
	opendir(my $dir, $dname) or return $l;
	while (my $e = readdir $dir) {
		next unless $e =~ m/\.tgz$/;
		next unless -f "$dname/$e";
		push(@@$l, $`);
	}
	close($dir);
	return $l;
}

package OpenBSD::PackageRepository::Local::Pipe;
our @@ISA=qw(OpenBSD::PackageRepository::Local);

sub may_exist
{
	return 1;
}

sub open_pipe
{
	my ($self, $object) = @@_;
	my $fullname = $self->{baseurl}.$object->{name};
	my $pid = open(my $fh, "-|");
	if (!defined $pid) {
		die "Cannot fork: $!";
	}
	if ($pid) {
		return $fh;
	} else {
		open STDERR, ">/dev/null";
		exec {"/usr/bin/gzip"} 
		    "gzip", 
		    "-d", 
		    "-c", 
		    "-q", 
		    "-f", 
		    "-"
		or die "can't run gzip";
	}
}

package OpenBSD::PackageRepository::Distant;
our @@ISA=qw(OpenBSD::PackageRepository);

my $buffsize = 2 * 1024 * 1024;

sub pkg_copy
{
	my ($in, $dir, $name) = @@_;

	require File::Temp;
	my $template = $name;
	$template =~ s/\.tgz$/.XXXXXXXX/;

	my ($copy, $filename) = File::Temp::tempfile($template,
	    DIR => $dir) or die "Can't write copy to cache";
	chmod 0644, $filename;
	my $handler = sub {
		my ($sig) = @@_;
		unlink $filename;
		$SIG{$sig} = 'DEFAULT';
		kill $sig, $$;
	};

	my $nonempty = 0;
	{

	local $SIG{'PIPE'} =  $handler;
	local $SIG{'INT'} =  $handler;
	local $SIG{'HUP'} =  $handler;
	local $SIG{'QUIT'} =  $handler;
	local $SIG{'KILL'} =  $handler;
	local $SIG{'TERM'} =  $handler;

	my ($buffer, $n);
	# copy stuff over
	do {
		$n = sysread($in, $buffer, $buffsize);
		if (!defined $n) {
			die "Error reading\n";
		}
		if ($n > 0) {
			$nonempty = 1;
		}
		syswrite $copy, $buffer;
		syswrite STDOUT, $buffer;
	} while ($n != 0);
	close($copy);
	}

	if ($nonempty) {
		rename $filename, "$dir/$name";
	} else {
		unlink $filename;
	}
}

sub open_pipe
{
	require OpenBSD::Temp;

	my ($self, $object) = @@_;
	$object->{errors} = OpenBSD::Temp::file();
	$object->{cache_dir} = $ENV{'PKG_CACHE'};
	my $pid = open(my $fh, "-|");
	if (!defined $pid) {
		die "Cannot fork: $!";
	}
	if ($pid) {
		$object->{pid} = $pid;
		return $fh;
	} else {
		open STDERR, '>', $object->{errors};

		my $pid2 = open(STDIN, "-|");

		if (!defined $pid2) {
			die "Cannot fork: $!";
		}
		if ($pid2) {
			exec {"/usr/bin/gzip"} 
			    "gzip", 
			    "-d", 
			    "-c", 
			    "-q", 
			    "-" 
			or die "can't run gzip";
		} else {
			if (defined $object->{cache_dir}) {
				my $pid3 = open(my $in, "-|");
				if (!defined $pid3) {
					die "Cannot fork: $!";
				}
				if ($pid3) {
					pkg_copy($in, $object->{cache_dir}, 
					    $object->{name});
					exit(0);
				} else {
					$self->grab_object($object);
				}
			} else {
				$self->grab_object($object);
			}
		}
	}
}

sub _list
{
	my ($self, $cmd) = @@_;
	my $l =[];
	local $_;
	open(my $fh, '-|', "$cmd") or return undef;
	while(<$fh>) {
		chomp;
		next if m/^d.*\s+\S/;
		next unless m/([^\s]+)\.tgz\s*$/;
		push(@@$l, $1);
	}
	close($fh);
	return $l;
}

sub finish_and_close
{
	my ($self, $object) = @@_;
	if (defined $object->{cache_dir}) {
		while (defined $object->intNext()) {
		}
	}
	$self->SUPER::finish_and_close($object);
}

package OpenBSD::PackageRepository::SCP;
our @@ISA=qw(OpenBSD::PackageRepository::Distant);


sub grab_object
{
	my ($self, $object) = @@_;

	exec {"/usr/bin/scp"} 
	    "scp", 
	    $self->{host}.":".$self->{path}.$object->{name}, 
	    "/dev/stdout"
	or die "can't run scp";
}

our %distant = ();

sub maxcount
{
	return 2;
}
d23 2
a24 497
sub opened
{
	my $self = $_[0];
	my $k = $self->{key};
	if (!defined $distant{$k}) {
		$distant{$k} = [];
	}
	return $distant{$k};
}

sub _new
{
	my ($class, $baseurl) = @@_;
	$baseurl =~ s/scp\:\/\///i;
	$baseurl =~ m/\//;
	bless {	host => $`, key => $`, path => "/$'" }, $class;
}

sub list
{
	my ($self) = @@_;
	if (!defined $self->{list}) {
		my $host = $self->{host};
		my $path = $self->{path};
		$self->{list} = $self->_list("ssh $host ls -l $path");
	}
	return $self->{list};
}

package OpenBSD::PackageRepository::HTTPorFTP;
our @@ISA=qw(OpenBSD::PackageRepository::Distant);

our %distant = ();


sub grab_object
{
	my ($self, $object) = @@_;
	my $ftp = defined $ENV{'FETCH_CMD'} ? $ENV{'FETCH_CMD'} : "/usr/bin/ftp";
	exec {$ftp} 
	    "ftp", 
	    "-o", 
	    "-", $self->{baseurl}.$object->{name}
	or die "can't run ftp";
}

sub maxcount
{
	return 1;
}

sub opened
{
	my $self = $_[0];
	my $k = $self->{key};
	if (!defined $distant{$k}) {
		$distant{$k} = [];
	}
	return $distant{$k};
}

sub _new
{
	my ($class, $baseurl) = @@_;
	my $distant_host;
	if ($baseurl =~ m/^(http|ftp)\:\/\/(.*?)\//i) {
	    $distant_host = $&;
	}
	bless { baseurl => $baseurl, key => $distant_host }, $class;
}


package OpenBSD::PackageRepository::HTTP;
our @@ISA=qw(OpenBSD::PackageRepository::HTTPorFTP);

sub list
{
	my ($self) = @@_;
	if (!defined $self->{list}) {
		my $error = OpenBSD::Temp::file();
		$self->make_room();
		my $fullname = $self->{baseurl};
		my $l = $self->{list} = [];
		local $_;
		open(my $fh, '-|', "ftp -o - $fullname 2>$error") or return undef;
		# XXX assumes a pkg HREF won't cross a line. Is this the case ?
		while(<$fh>) {
			chomp;
			for my $pkg (m/\<A\s+HREF=\"(.*?)\.tgz\"\>/gi) {
				next if $pkg =~ m|/|;
				push(@@$l, $pkg);
			}
		}
		close($fh);
		$self->parse_problems($error);
	}
	return $self->{list};
}

package OpenBSD::PackageRepository::FTP;
our @@ISA=qw(OpenBSD::PackageRepository::HTTPorFTP);


sub list
{
	my ($self) = @@_;
	if (!defined $self->{list}) {
		require OpenBSD::Temp;

		my $error = OpenBSD::Temp::file();
		$self->make_room();
		my $fullname = $self->{baseurl};
		$self->{list} = $self->_list("echo 'nlist *.tgz'|ftp -o - $fullname 2>$error");
		$self->parse_problems($error);
	}
	return $self->{list};
}

package OpenBSD::PackageLocation;

use OpenBSD::PackageInfo;
use OpenBSD::Temp;

sub new
{
	my ($class, $repository, $name) = @@_;
	my $self = { repository => $repository, name => $name};
	bless $self, $class;
}

sub openArchive
{
	my $self = shift;

	my $fh = $self->{repository}->open($self);
	if (!defined $fh) {
		$self->{repository}->parse_problems($self->{errors}) 
		    if defined $self->{errors};
		undef $self->{errors};
		return undef;
	}
	require OpenBSD::Ustar;

	my $archive = new OpenBSD::Ustar $fh;
	$self->{_archive} = $archive;
}

sub grabInfoFiles
{
	my $self = shift;
	my $dir = $self->{dir} = OpenBSD::Temp::dir();

	if (defined $self->{contents} && ! -f $dir.CONTENTS) {
		open my $fh, '>', $dir.CONTENTS or die "Permission denied";
		print $fh $self->{contents};
		close $fh;
	}

	while (my $e = $self->intNext()) {
		if ($e->isFile() && is_info_name($e->{name})) {
			$e->{name}=$dir.$e->{name};
			eval { $e->create(); };
			if ($@@) {
				unlink($e->{name});
				$@@ =~ s/\s+at.*//;
				print STDERR $@@;
				return 0;
			}
		} else {
			$self->unput();
			last;
		}
	}
	return 1;
}

sub scanPackage
{
	my $self = shift;
	while (my $e = $self->intNext()) {
		if ($e->isFile() && is_info_name($e->{name})) {
			if ($e->{name} eq CONTENTS && !defined $self->{dir}) {
				$self->{contents} = $e->contents();
				last;
			}
			if (!defined $self->{dir}) {
				$self->{dir} = OpenBSD::Temp::dir();
			}
			$e->{name}=$self->{dir}.$e->{name};
			eval { $e->create(); };
			if ($@@) {
				unlink($e->{name});
				$@@ =~ s/\s+at.*//;
				print STDERR $@@;
				return 0;
			}
		} else {
			$self->unput();
			last;
		}
	}
	return 1;
}

sub grabPlist
{
	my ($self, $pkgname, $arch, $code) = @@_;

	my $pkg = $self->openPackage($pkgname, $arch);
	if (defined $pkg) {
		my $plist = $self->plist($code);
		$pkg->wipe_info();
		$pkg->close_now();
		return $plist;
	} else {
		return undef;
	}
}

sub openPackage
{
	my ($self, $pkgname, $arch) = @@_;
	if (!$self->openArchive()) {
		return undef;
	}
	$self->scanPackage();

	if (defined $self->{contents}) {
		return $self;
	} 

	# maybe it's a fat package.
	while (my $e = $self->intNext()) {
		unless ($e->{name} =~ m/\/\+CONTENTS$/) {
			last;
		}
		my $prefix = $`;
		my $contents = $e->contents();
		require OpenBSD::PackingList;

		$pkgname =~ s/\.tgz$//;

		my $plist = OpenBSD::PackingList->fromfile(\$contents, 
		    \&OpenBSD::PackingList::FatOnly);
		next if defined $pkgname and $plist->pkgname() ne $pkgname;
		if ($plist->has('arch')) {
			if ($plist->{arch}->check($arch)) {
				$self->{filter} = $prefix;
				bless $self, "OpenBSD::FatPackageLocation";
				$self->{contents} = $contents;
				return $self;
			}
		}
	}
	# hopeless
	$self->close_with_client_error();
	$self->wipe_info();
	return undef;
}

sub wipe_info
{
	my $self = shift;
	$self->{repository}->wipe_info($self);
}

sub info
{
	my $self = shift;
	if (!defined $self->{dir}) {
		$self->grabInfoFiles();
	}
	return $self->{dir};
}

sub plist
{
	my ($self, $code) = @@_;

	require OpenBSD::PackingList;

	if (defined $self->{contents}) {
		my $value = $self->{contents};
		return OpenBSD::PackingList->fromfile(\$value, $code);
	} elsif (defined $self->{dir} && -f $self->{dir}.CONTENTS) {
		return OpenBSD::PackingList->fromfile($self->{dir}.CONTENTS, 
		    $code);
	}
	# hopeless
	$self->close_with_client_error();

	return undef;
}

sub close
{
	my ($self, $hint) = @@_;
	$self->{repository}->close($self, $hint);
}

sub finish_and_close
{
	my $self = shift;
	$self->{repository}->finish_and_close($self);
}

sub close_now
{
	my $self = shift;
	$self->{repository}->close_now($self);
}

sub close_after_error
{
	my $self = shift;
	$self->{repository}->close_after_error($self);
}

sub close_with_client_error
{
	my $self = shift;
	$self->{repository}->close_with_client_error($self);
}

sub deref
{
	my $self = shift;
	$self->{fh} = undef;
	$self->{_archive} = undef;
}

sub reopen
{
	my $self = shift;
	if (!$self->openArchive()) {
		return undef;
	}
	while (my $e = $self->{_archive}->next()) {
		if ($e->{name} eq $self->{_current}->{name}) {
			$self->{_current} = $e;
			return $self;
		}
	}
	return undef;
}

# proxy for archive operations
sub next
{
	my $self = shift;

	if (!defined $self->{dir}) {
		$self->grabInfoFiles();
	}
	return $self->intNext();
}

sub intNext
{
	my $self = shift;

	if (!defined $self->{fh}) {
		if (!$self->reopen()) {
			return undef;
		}
	}
	if (!$self->{_unput}) {
		$self->{_current} = $self->getNext();
	}
	$self->{_unput} = 0;
	return $self->{_current};
}

sub unput
{ 	
	my $self = shift;
	$self->{_unput} = 1;
}

sub getNext
{
	my $self = shift;

	return $self->{_archive}->next();
}

sub skip
{
	my $self = shift;
	return $self->{_archive}->skip();
}

package OpenBSD::FatPackageLocation;
our @@ISA=qw(OpenBSD::PackageLocation);

sub getNext
{
	my $self = shift;

	my $e = $self->SUPER::getNext();
	if ($e->{name} =~ m/^(.*?)\/(.*)$/) {
		my ($beg, $name) = ($1, $2);
		if (index($beg, $self->{filter}) == -1) {
			return $self->next();
		}
		$e->{name} = $name;
		if ($e->isHardLink()) {
			$e->{linkname} =~ s/^(.*?)\///;
		}
	}
	return $e;
}

package OpenBSD::PackageRepositoryList;

sub new
{
	my $class = shift;
	return bless {list => [], avail => undef }, $class;
}

sub add
{
	my $self = shift;
	push @@{$self->{list}}, @@_;
	if (@@_ > 0) {
		$self->{avail} = undef;
	}
}

sub find
{
	my ($self, $pkgname, $arch, $srcpath) = @@_;

	for my $repo (@@{$self->{list}}) {
		my $pkg;

		for (my $retry = 5; $retry < 60; $retry *= 2) {
			undef $repo->{lasterror};
			$pkg = $repo->find($pkgname, $arch, $srcpath);
			if (!defined $pkg && defined $repo->{lasterror} && 
			    $repo->{lasterror} == 421 && 
			    defined $self->{avail} &&
			    $self->{avail}->{$pkgname} eq $repo) { 
				print STDERR "Temporary error, sleeping $retry seconds\n";
				sleep($retry);
			} else {
				last;
			}
		}
		return $pkg if defined $pkg;
	}
	return undef;
}

sub grabPlist
{
	my ($self, $pkgname, $arch, $code) = @@_;

	for my $repo (@@{$self->{list}}) {
		my $plist;

		for (my $retry = 5; $retry < 60; $retry *= 2) {
			undef $repo->{lasterror};
			$plist = $repo->grabPlist($pkgname, $arch, $code);
			if (!defined $plist && defined $repo->{lasterror} && 
			    $repo->{lasterror} == 421 && 
			    defined $self->{avail} &&
			    $self->{avail}->{$pkgname} eq $repo) { 
				print STDERR "Temporary error, sleeping $retry seconds\n";
				sleep($retry);
			} else {
				last;
			}
		}
		return $plist if defined $plist;
	}
	return undef;
}

sub available
{
	my $self = shift;

	if (!defined $self->{avail}) {
		my $available_packages = {};
		foreach my $loc (reverse @@{$self->{list}}) {
		    foreach my $pkg (@@{$loc->list()}) {
		    	$available_packages->{$pkg} = $loc;
		    }
		}
		$self->{avail} = $available_packages;
	}
	return keys %{$self->{avail}};
}

package OpenBSD::PackageLocator;
@


1.50
log
@detect temporary connection errors, and retry with exponential timeout.
@
text
@d2 1
a2 1
# $OpenBSD: PackageLocator.pm,v 1.49 2006/02/09 09:38:41 espie Exp $
d190 1
d445 1
@


1.49
log
@Add some nice interfaces instead of the hint() argument to close().
This allows the cache to finish properly even in some weird cases like
fat packages (calling finish_and_close).
@
text
@d2 1
a2 1
# $OpenBSD: PackageLocator.pm,v 1.48 2005/11/03 13:28:07 espie Exp $
d201 8
d964 15
a978 1
		my $pkg = $repo->find($pkgname, $arch, $srcpath);
d989 15
a1003 1
		my $plist = $repo->grabPlist($pkgname, $arch, $code);
@


1.48
log
@kludge: avoid creating non-empty files.

I don't like the fix, but it works...
@
text
@d2 1
a2 1
# $OpenBSD: PackageLocator.pm,v 1.47 2005/11/02 22:26:51 espie Exp $
d91 24
d128 1
a128 1
			$self->close($o, 0);
d430 1
d454 1
a454 1
			if (defined $ENV{'PKG_CACHE'}) {
d460 1
a460 1
					pkg_copy($in, $ENV{'PKG_CACHE'}, 
d489 9
d733 1
a733 1
		$pkg->close(0);
d776 1
a776 1
	$self->close(1);
d810 1
a810 1
	$self->close(1);
d819 24
@


1.47
log
@In case we are pretending, make sure we skip to the next archive member.
Otherwise, we might miss a truncated archive that's missing its last file,
and PKG_CACHE won't work, since it hits a SIGPIPE too soon.

Nice testcase from sturm@@
@
text
@d2 1
a2 1
# $OpenBSD: PackageLocator.pm,v 1.46 2005/10/25 23:38:51 espie Exp $
d367 1
d384 3
d393 5
a397 1
	rename $filename, "$dir/$name";
@


1.46
log
@zap 229 (frantisek holop)
@
text
@d2 1
a2 1
# $OpenBSD: PackageLocator.pm,v 1.45 2005/10/22 17:44:07 espie Exp $
d839 6
@


1.45
log
@add a hint to close that says how the fd got closed (real error, premature,
normal).

This will get used by parse_problems() to figure out what to report exactly,
e.g., short writes from prematurely closed fd are not real errors...
stuff that can't connect IPv6 and retries as v4 is not either, unless
there's a genuine `can't connect error'.
@
text
@d2 1
a2 1
# $OpenBSD: PackageLocator.pm,v 1.44 2005/10/22 15:00:47 espie Exp $
d157 1
a157 1
		next if m/^(?:200|220|221|226|230|227|250|331|500|150)[\s\-]/;
@


1.44
log
@more non-errors from ftp.
@
text
@d2 1
a2 1
# $OpenBSD: PackageLocator.pm,v 1.43 2005/10/22 13:11:55 espie Exp $
d79 2
d83 1
a83 1
	my ($self, $object) = @@_;
d85 3
a87 1
	$self->parse_problems($object->{errors}) if defined $object->{errors};
d104 1
a104 1
			$self->close($o);
d150 3
a152 2
	my ($self, $filename) = @@_;
	CORE::open(my $fh, '<', $filename);
d155 1
d159 1
a159 1
		next if m/^Trying [\d\.\:]+\.\.\./;
d166 12
a177 2
		next if m/^\d+\s+bytes received in/;
		print STDERR "Error from $baseurl:\n", $_;
d617 1
d691 1
a691 1
		$pkg->close();
d734 1
a734 1
	$self->close();
d768 1
a768 1
	$self->close();
d775 2
a776 2
	my $self = shift;
	$self->{repository}->close($self);
@


1.43
log
@I haven't received any feedback at all about this patch, so everyone
gets to test it.
@
text
@d2 1
a2 1
# $OpenBSD: PackageLocator.pm,v 1.42 2005/10/10 09:33:56 espie Exp $
d151 1
a151 1
		next if m/^(?:200|220|230|227|250|331|500|150)[\s\-]/;
d160 1
@


1.42
log
@Display an error message if no packages are available in the PKG_PATH.
Quote nlist command, if we invoke it accidentally in a directory with *.tgz
present.
@
text
@d2 1
a2 1
# $OpenBSD: PackageLocator.pm,v 1.41 2005/09/24 08:43:59 espie Exp $
d83 1
d144 22
d377 2
d380 1
d388 1
a388 1
		open STDERR, ">/dev/null";
d541 1
d546 1
a546 1
		open(my $fh, '-|', "ftp -o - $fullname 2>/dev/null") or return undef;
d556 1
d564 1
d569 3
d574 2
a575 1
		$self->{list} = $self->_list("echo 'nlist *.tgz'|ftp -o - $fullname 2>/dev/null");
d598 2
@


1.41
log
@Allows FETCH_CMD to replace ftp.
Note that, for simplicity, FETCH_CMD must be a single command with
a full path. Use a script if you must.
@
text
@d2 1
a2 1
# $OpenBSD: PackageLocator.pm,v 1.40 2005/09/19 10:15:01 espie Exp $
d542 1
a542 1
		$self->{list} = $self->_list("echo nlist *.tgz|ftp -o - $fullname 2>/dev/null");
@


1.40
log
@fix PackageRepository::Installed().
let grabPlist finish closing what it opened.
@
text
@d2 1
a2 1
# $OpenBSD: PackageLocator.pm,v 1.39 2005/09/19 09:49:51 espie Exp $
d474 2
a475 1
	exec {"/usr/bin/ftp"} 
@


1.39
log
@make package opening more efficient (and maybe more intuitive) by
delaying reading the full info directory to a temporary directory.

When we open a package, we just scan for the CONTENTS. If it's the
first file, we stash it into memory and STOP there, delaying grabbing
the rest of the special files to the first call to info().

Make sure the next() proxy shows only real file, by grabbing info files
if necessary.

Introduce handle->plist() method that can retrieve the plist from either
the version stored in memory, or in a file in the temp directory.
@
text
@d2 1
a2 1
# $OpenBSD: PackageLocator.pm,v 1.38 2005/09/17 12:45:49 espie Exp $
d144 1
d147 5
d637 1
@


1.38
log
@allows grabbing the packing-list directly from a PackageLocation,
in order to make further code more symetric and efficient.
@
text
@d2 1
a2 1
# $OpenBSD: PackageLocator.pm,v 1.37 2005/09/17 12:10:32 espie Exp $
a56 1
	my $dir = $pkg->info();
d58 6
a63 2
	File::Path::rmtree($dir);
	delete $pkg->{dir};
d569 1
a569 4
	my $dir = $self->{dir};

	if (defined $self->{plist}) {
		require OpenBSD::PackingList;
d571 1
a571 3
		$self->{plist}->tofile($dir.CONTENTS);
		delete $self->{plist};
	} elsif (defined $self->{contents}) {
a574 1
		delete $self->{contents};
d577 1
a577 1
	while (my $e = $self->next()) {
d595 1
a595 1
sub grabPlist
d597 5
a601 11
	my ($self, $pkgname, $arch, $code) = @@_;
	if (!$self->openArchive()) {
		return undef;
	}

	while (my $e = $self->next()) {
		if ($e->{name} ne CONTENTS) {
			if ($e->{name} =~ m/\/\+CONTENTS$/) {
				$self->{prefix} = $';
				bless $self, "OpenBSD:FatPackageLocation";
			} else {
d604 10
a613 16
		}
		my $value = $e->contents();
		open my $fh,  '<', \$value or next;
		require OpenBSD::PackingList;
		$pkgname =~ s/\.tgz$//;
		my $plist = OpenBSD::PackingList->read($fh, $code);
		close $fh;
		next if defined $pkgname and $plist->pkgname() ne $pkgname;
		if ($plist->has('arch')) {
			if ($plist->{arch}->check($arch)) {
				if (!defined $code) {
					$self->{plist} = $plist;
				} else {
					$self->{contents} = $value;
				}
				return $plist;
d615 3
d620 6
a625 2
	# hopeless
	$self->close();
d627 8
a634 1
	return undef;
d643 1
a643 4
	my $dir = OpenBSD::Temp::dir();
	$self->{dir} = $dir;

	$self->grabInfoFiles();
d645 1
a645 1
	if (-f $dir.CONTENTS) {
d650 1
a650 1
	while (my $e = $self->next()) {
d655 1
a655 2
		$e->{name}=$dir.CONTENTS;
		eval { $e->create(); };
d657 1
d659 3
a661 1
		my $plist = OpenBSD::PackingList->fromfile($dir.CONTENTS, \&OpenBSD::PackingList::FatOnly);
d667 1
a667 1
				$self->grabInfoFiles();
d687 3
d699 11
a709 1
	return OpenBSD::PackingList->fromfile($self->info().CONTENTS, $code);
d742 10
@


1.37
log
@beginning to a source path repository infrastructure, very likely to change
a lot yet.
@
text
@d2 1
a2 1
# $OpenBSD: PackageLocator.pm,v 1.36 2005/09/17 09:30:16 espie Exp $
d690 9
@


1.36
log
@minor nit
@
text
@d2 1
a2 1
# $OpenBSD: PackageLocator.pm,v 1.35 2005/09/16 23:17:39 espie Exp $
d38 2
d124 1
a124 1
	my ($repository, $name, $arch) = @@_;
d145 1
a145 1
	my ($repository, $name, $arch) = @@_;
d183 35
d790 1
a790 1
	my ($self, $pkgname, $arch) = @@_;
d793 1
a793 1
		my $pkg = $repo->find($pkgname, $arch);
d852 1
d856 1
a856 1
		my $package = $repository->find(undef, $arch);
d868 1
a868 1
		$package = $repository->find($pkgname, $arch);
d873 1
a873 1
		$package = $pkgpath->find($_, $arch);
@


1.35
log
@more clean-up:
- kill multiple inheritance;
- replace pipename() with open_pipe, and use explicit exec.
- add intermediate PackageRepository::Distant class.

- if PKG_CACHE is set, use an intermediate wedge that stores the
retrieved package in that directory.

- handle signals correctly in that case.
@
text
@d2 1
a2 1
# $OpenBSD: PackageLocator.pm,v 1.34 2005/09/16 20:03:50 espie Exp $
d201 2
a202 2
		    $self->{baseurl}.$object->{name};
		exit(1);
@


1.34
log
@oops
@
text
@d2 1
a2 1
# $OpenBSD: PackageLocator.pm,v 1.33 2005/09/16 10:00:59 espie Exp $
d109 4
a112 3
	my $p = $self->pipename($object->{name});
	
	open(my $fh, '-|', $p) or return undef;
d181 2
a182 2
package OpenBSD::PackageRepository::SCP;
our @@ISA=qw(OpenBSD::PackageRepository OpenBSD::PackageRepository::FTPorSCP);
d184 1
a184 3
our %distant = ();

sub maxcount
d186 4
a189 9
	return 2;
}

sub opened
{
	my $self = $_[0];
	my $k = $self->{key};
	if (!defined $distant{$k}) {
		$distant{$k} = [];
d191 12
a202 26
	return $distant{$k};
}

sub _new
{
	my ($class, $baseurl) = @@_;
	$baseurl =~ s/scp\:\/\///i;
	$baseurl =~ m/\//;
	bless {	host => $`, key => $`, path => "/$'" }, $class;
}

sub pipename
{
	my ($self, $name) = @@_;
	my $host = $self->{host};
	my $path = $self->{path};
	return "scp $host:$path$name /dev/stdout 2> /dev/null|gzip -d -c -q - 2> /dev/null";
}

sub list
{
	my ($self) = @@_;
	if (!defined $self->{list}) {
		my $host = $self->{host};
		my $path = $self->{path};
		$self->{list} = $self->_list("ssh $host ls -l $path");
a203 11
	return $self->{list};
}

package OpenBSD::PackageRepository::Local;
our @@ISA=qw(OpenBSD::PackageRepository);

sub pipename
{
	my ($self, $name) = @@_;
	my $fullname = $self->{baseurl}.$name;
	return "gzip -d -c -q -f 2>/dev/null $fullname";
d235 1
a235 1
sub pipename
d237 19
a255 1
	return "gzip -d -c -q -f 2>/dev/null -";
d258 92
a349 1
package OpenBSD::PackageRepository::FTPorSCP;
d367 52
d420 1
d424 11
a459 6
sub pipename
{
	my ($self, $name) = @@_;
	my $fullname = $self->{baseurl}.$name;
	return "ftp -o - $fullname 2>/dev/null|gzip -d -c -q - 2>/dev/null";
}
d462 2
a463 1
our @@ISA=qw(OpenBSD::PackageRepository::HTTPorFTP OpenBSD::PackageRepository);
d487 1
a487 1
our @@ISA=qw(OpenBSD::PackageRepository::HTTPorFTP OpenBSD::PackageRepository OpenBSD::PackageRepository::FTPorSCP);
@


1.33
log
@move .tgz addition down to PackageRepositoryList.
re-add list, which returns a \@@, whereas available returns a @@.
@
text
@d2 1
a2 1
# $OpenBSD: PackageLocator.pm,v 1.32 2005/09/14 09:50:40 espie Exp $
d643 1
a643 1
		    foreach my $pkg (@@{$loc->available()}) {
@


1.32
log
@filter names out first, as it's slightly faster
@
text
@d2 1
a2 1
# $OpenBSD: PackageLocator.pm,v 1.31 2005/09/13 21:20:01 espie Exp $
d43 7
d122 1
d131 1
d164 6
d216 1
a216 1
sub available
d243 1
a243 1
sub available
d327 1
a327 1
sub available
d352 1
a352 1
sub available
a683 1
	$_.=".tgz" unless m/\.tgz$/;
a720 1
	$_.=".tgz" unless m/\.tgz$/;
@


1.31
log
@more Package/FatPackage common code: separate the proxy 'next' into two
parts: the one that gets (and renames) files from the archive (getNext)
that depends on Package/FatPackage, and the one that handles opening/
reopening/caching archives (true next);
@
text
@d2 1
a2 1
# $OpenBSD: PackageLocator.pm,v 1.30 2005/09/13 21:08:14 espie Exp $
d235 1
a236 1
		next unless $e =~ m/\.tgz$/;
@


1.30
log
@typo, fix fat packages reading.
@
text
@d2 1
a2 1
# $OpenBSD: PackageLocator.pm,v 1.29 2005/09/13 20:44:08 espie Exp $
d542 1
a542 2
		my $e = $self->{_archive}->next();
		$self->{_current} = $e;
d549 2
a550 1
{ my $self = shift;
d554 7
d564 1
a564 2
# proxy for archive operations
sub next
d568 5
a572 3
	if (!defined $self->{fh}) {
		if (!$self->reopen()) {
			return undef;
d574 3
a576 12
	}
	if (!$self->{_unput}) {
		my $e = $self->{_archive}->next();
		if ($e->{name} =~ m/^(.*?)\/(.*)$/) {
			my ($beg, $name) = ($1, $2);
			if (index($beg, $self->{filter}) == -1) {
				return $self->next();
			}
			$e->{name} = $name;
			if ($e->isHardLink()) {
				$e->{linkname} =~ s/^(.*?)\///;
			}
a577 1
		$self->{_current} = $e;
d579 1
a579 2
	$self->{_unput} = 0;
	return $self->{_current};
@


1.29
log
@grabPlist shall behave like find.
@
text
@d2 1
a2 1
# $OpenBSD: PackageLocator.pm,v 1.28 2005/09/13 20:03:29 espie Exp $
d480 1
a480 1
				$self->grabInfoFile();
@


1.28
log
@Repository::Installed class, to provide uniform access to installed
packages compared to other `repositories'.
@
text
@d2 1
a2 1
# $OpenBSD: PackageLocator.pm,v 1.27 2005/09/13 19:40:30 espie Exp $
d700 14
a713 1
	my ($self, $pkgname, $arch, $code) = @@_;
d715 10
a724 1
	return $pkgpath->grabPlist($pkgname, $arch, $code);
@


1.27
log
@yet more uniform names.
@
text
@d2 1
a2 1
# $OpenBSD: PackageLocator.pm,v 1.26 2005/09/13 10:44:06 espie Exp $
d126 37
@


1.26
log
@don't actively avoid the Composite Pattern.
PackageRepositoryList can handle very close to PackageRepository
@
text
@d2 1
a2 1
# $OpenBSD: PackageLocator.pm,v 1.24 2005/09/13 10:00:48 espie Exp $
d112 1
a112 1
sub openPackage
d164 1
a164 1
sub list
d191 1
a191 1
sub list
d275 1
a275 1
sub list
d300 1
a300 1
sub list
d450 1
a450 1
	$self->wipe();
d454 1
a454 1
sub wipe
d513 1
a513 2
{
	my $self = shift;
d565 1
a565 1
sub openPackage
d570 1
a570 1
		my $pkg = $repo->openPackage($pkgname, $arch);
d576 12
a587 1
sub list
d594 1
a594 1
		    foreach my $pkg (@@{$loc->list()}) {
d632 1
a632 1
		my $package = $repository->openPackage(undef, $arch);
d645 1
a645 1
		$package = $repository->openPackage($pkgname, $arch);
d650 1
a650 1
		$package = $pkgpath->openPackage($_, $arch);
d658 8
a665 1
	return $pkgpath->list();
@


1.25
log
@new class: PackageRepositoryList, of which pkgpath is one instance.
new method: wipe(), that removes the info directory, redirected to
the PackageRepository object which `knows' how to wipe stuff out.

(this allows us to eliminate special cases for installed/not installed
packages in the near future).
@
text
@d566 1
a566 1
sub find
d577 1
a577 1
sub available
d640 1
a640 1
		$package = $pkgpath->find($_, $arch);
d648 1
a648 1
	return $pkgpath->available();
@


1.24
log
@make grabPlist slightly smarter so that we can still open the package
afterwards.
@
text
@d2 1
a2 1
# $OpenBSD: PackageLocator.pm,v 1.23 2005/09/13 09:30:55 espie Exp $
d43 10
d450 3
d454 4
a457 4
	require File::Path;
	File::Path::rmtree($dir);
	delete $self->{dir};
	return undef;
d549 43
d599 1
a599 5
my @@pkgpath;
my $need_new_cache = 1;
my $available_packages = {};
my @@pkglist = ();

d602 4
a605 5
	my $pkgpath = $ENV{PKG_PATH};
	$pkgpath =~ s/^\:+//;
	$pkgpath =~ s/\:+$//;
	my @@tentative = split /\/\:/, $pkgpath;
	@@pkgpath = ();
d608 1
a608 1
		push @@pkgpath, OpenBSD::PackageRepository->new($i);
d611 1
a611 1
	@@pkgpath=(OpenBSD::PackageRepository->new("./"));
d637 1
a637 2
			push(@@pkgpath, $repository);
			$need_new_cache = 1;
d640 1
a640 4
		for my $p (@@pkgpath) {
			$package = $p->openPackage($_, $arch);
			last if defined $package;
		}
d648 1
a648 11
	if ($need_new_cache) {
		$available_packages = {};
		foreach my $loc (reverse @@pkgpath) {
		    foreach my $pkg (@@{$loc->list()}) {
		    	$available_packages->{$pkg} = $loc;
		    }
		}
		@@pkglist = keys %$available_packages;
		$need_new_cache = 0;
	}
	return @@pkglist;
@


1.23
log
@allows grabbing a packing-list directly, without needing to go through
a temporary file, by using perl's new-fangled
open my $fh, '<', \$scalar
@
text
@d2 1
a2 1
# $OpenBSD: PackageLocator.pm,v 1.22 2005/09/13 09:21:01 espie Exp $
d332 12
a368 1
	# maybe it's a fat package.
d370 7
a376 2
		unless ($e->{name} eq CONTENTS or $e->{name} =~ m/\/\+CONTENTS$/) {
			last;
a377 1
		my $prefix = $`;
d387 5
@


1.22
log
@some long-delayed clean-up of this code.
- rename PackageLocation to PackageRepository.
- new class `PackageLocation' which symbolizes an actually opened package.
- rename quite a few things and reorg stuff to make lots more sense.
- put fat packages into a derived FatPackageLocation class.
- fix a bug that made sure fat packages could not be opened on stdin.

ways cleaner and easier to extend...
@
text
@d2 1
a2 1
# $OpenBSD: PackageLocator.pm,v 1.21 2005/09/04 22:47:56 espie Exp $
d110 8
d348 32
@


1.21
log
@* New -i interactive option, that can ask obnoxious questions.
* move the signature code to a packing-list method, prepend the pkgname.
* depend on distant listings, cache these systematically.
* cut the PKG_PATH at :/ systematically, much simpler than parsing URLs.
People should get used to trailing /s.
* let pkg_add -u actually run the update.
* check for signature in more places, for instance, let pkg_add installed_stuff
be a void operation.
* grab enough stuff during updates to check signatures, so that pkg_add -u
can report updates that are not needed right away, instead of waiting
for the more confusing `trying to update'
* beginning of @@module support.
* @@pkgpath support, including updates.
* systematically expand stems when applicable.
* use visitors systematically in pkg_info.
* pkg_info -S reports signature.
* remove hardcoding of categories in PackingList, so that future modules
will be able to expand them.
* add @@updateset and @@incompatibility keywords.
@
text
@d2 1
a2 1
# $OpenBSD: PackageLocator.pm,v 1.20 2005/08/22 11:30:30 espie Exp $
d21 1
a21 1
package OpenBSD::PackageLocation;
d25 2
a26 2
	my ($class, $location) = @@_;
	bless { location => $location }, $class;
d31 7
a37 7
	my ($class, $location) = @@_;
	if ($location =~ m/^ftp\:/i) {
		return OpenBSD::PackageLocation::FTP->_new($location);
	} elsif ($location =~ m/^http\:/i) {
		return OpenBSD::PackageLocation::HTTP->_new($location);
	} elsif ($location =~ m/^scp\:/i) {
		return OpenBSD::PackageLocation::SCP->_new($location);
d39 1
a39 1
		return OpenBSD::PackageLocation::Local->_new($location);
d61 1
a61 1
	$object->_close();
d102 10
a111 2
package OpenBSD::PackageLocation::SCP;
our @@ISA=qw(OpenBSD::PackageLocation OpenBSD::PackageLocation::FTPorSCP);
d132 3
a134 3
	my ($class, $location) = @@_;
	$location =~ s/scp\:\/\///i;
	$location =~ m/\//;
d157 2
a158 2
package OpenBSD::PackageLocation::Local;
our @@ISA=qw(OpenBSD::PackageLocation);
d163 1
a163 1
	my $fullname = $self->{location}.$name;
d170 1
a170 1
	return -r $self->{location}.$name;
d177 1
a177 1
	my $dname = $self->{location};
d188 2
a189 2
package OpenBSD::PackageLocation::Local::Pipe;
our @@ISA=qw(OpenBSD::PackageLocation::Local);
d201 1
a201 1
package OpenBSD::PackageLocation::FTPorSCP;
d219 1
a219 1
package OpenBSD::PackageLocation::HTTPorFTP;
d240 1
a240 1
	my ($class, $location) = @@_;
d242 1
a242 1
	if ($location =~ m/^(http|ftp)\:\/\/(.*?)\//i) {
d245 1
a245 1
	bless { location => $location, key => $distant_host }, $class;
d251 1
a251 1
	my $fullname = $self->{location}.$name;
d255 2
a256 2
package OpenBSD::PackageLocation::HTTP;
our @@ISA=qw(OpenBSD::PackageLocation::HTTPorFTP OpenBSD::PackageLocation);
d262 1
a262 1
		my $fullname = $self->{location};
d279 2
a280 2
package OpenBSD::PackageLocation::FTP;
our @@ISA=qw(OpenBSD::PackageLocation::HTTPorFTP OpenBSD::PackageLocation OpenBSD::PackageLocation::FTPorSCP);
d287 1
a287 1
		my $fullname = $self->{location};
d293 1
a293 5

package OpenBSD::PackageLocator;

# this returns an archive handle from an uninstalled package name, currently
# There is a cache available.
d298 1
a298 22
my %packages;
my @@pkgpath;
my $need_new_cache = 1;
my $available_packages = {};
my @@pkglist = ();


if (defined $ENV{PKG_PATH}) {
	my $pkgpath = $ENV{PKG_PATH};
	$pkgpath =~ s/^\:+//;
	$pkgpath =~ s/\:+$//;
	my @@tentative = split /\/\:/, $pkgpath;
	@@pkgpath = ();
	while (my $i = shift @@tentative) {
		$i =~ m|/$| or $i.='/';
		push @@pkgpath, OpenBSD::PackageLocation->new($i);
	}
} else {
	@@pkgpath=(OpenBSD::PackageLocation->new("./"));
}

sub find
d300 3
a302 66
	my $class = shift;
	local $_ = shift;
	my $arch = shift;

	if ($_ eq '-') {
		my $location = OpenBSD::PackageLocation::Local::Pipe->_new('./');
		my $package = $class->openAbsolute($location, '', $arch);
		return $package;
	}
	$_.=".tgz" unless m/\.tgz$/;
	if (exists $packages{$_}) {
		return $packages{$_};
	}
	my $package;
	if (m/\//) {
		use File::Basename;

		my ($pkgname, $path) = fileparse($_);
		my $location = OpenBSD::PackageLocation->new($path);
		$package = $class->openAbsolute($location, $pkgname, $arch);
		if (defined $package) {
			push(@@pkgpath, $location);
			$need_new_cache = 1;
		}
	} else {
		for my $p (@@pkgpath) {
			$package = $class->openAbsolute($p, $_, $arch);
			last if defined $package;
		}
	}
	$packages{$_} = $package if defined($package);
	return $package;
}

sub available
{
	if ($need_new_cache) {
		$available_packages = {};
		foreach my $loc (reverse @@pkgpath) {
		    foreach my $pkg (@@{$loc->list()}) {
		    	$available_packages->{$pkg} = $loc;
		    }
		}
		@@pkglist = keys %$available_packages;
		$need_new_cache = 0;
	}
	return @@pkglist;
}

sub info
{
	my $self = shift;
	return $self->{dir};
}

sub close
{
	my $self = shift;
	$self->{location}->close($self);
}

sub _close
{
	my $self = shift;
	$self->{fh} = undef;
	$self->{_archive} = undef;
d305 1
a305 1
sub _open
d309 1
a309 1
	my $fh = $self->{location}->open($self);
d319 1
a319 1
sub openAbsolute
d321 2
a322 3
	my ($class, $location, $name, $arch) = @@_;
	my $self = { location => $location, name => $name};
	bless $self, $class;
a323 9

	if (!$self->_open()) {
		return undef;
	}
	my $dir = OpenBSD::Temp::dir();
	$self->{dir} = $dir;

	# check that Open worked
OKAY:
d332 1
d339 14
a353 1
#		$self->close();
d355 20
a374 19
	} else {
		# maybe it's a fat package.
		while (my $e = $self->next()) {
			unless ($e->{name} =~ m/\/\+CONTENTS$/) {
				last;
			}
			my $prefix = $`;
			$e->{name}=$dir.CONTENTS;
			eval { $e->create(); };
			require OpenBSD::PackingList;
			my $pkgname = $name;
			$pkgname =~ s/\.tgz$//;
			my $plist = OpenBSD::PackingList->fromfile($dir.CONTENTS, \&OpenBSD::PackingList::FatOnly);
			next if $pkgname ne '-' and $plist->pkgname() ne $pkgname;
			if ($plist->has('arch')) {
				if ($plist->{arch}->check($arch)) {
					$self->{filter} = $prefix;
					goto OKAY;
				}
d377 21
a397 1
		$self->close();
d399 5
a403 4
		require File::Path;
		File::Path::rmtree($dir);
		return undef;
	}
d409 1
a409 1
	if (!$self->_open()) {
a432 12
		if (defined $self->{filter}) {
			if ($e->{name} =~ m/^(.*?)\/(.*)$/) {
				my ($beg, $name) = ($1, $2);
				if (index($beg, $self->{filter}) == -1) {
					return $self->next();
				}
				$e->{name} = $name;
				if ($e->isHardLink()) {
					$e->{linkname} =~ s/^(.*?)\///;
				}
			}
		}
d443 109
@


1.20
log
@while scanning a potential package, process issues anyways:
if create() fails, we want to remove any stub file (and report the
problem), so that tools won't get confused in believing the packing-list
got created correctly.
@
text
@d2 1
a2 1
# $OpenBSD: PackageLocator.pm,v 1.19 2005/08/19 00:10:56 espie Exp $
a91 1

d102 6
a107 2
# by default, we don't know how to list packages there.
sub simplelist
d109 1
d112 9
a120 2
package OpenBSD::PackageLocation::SCP;
our @@ISA=qw(OpenBSD::PackageLocation OpenBSD::PackageLocation::FTPorSCP);
d127 1
a127 1
	bless {	host => $`, path => "/$'" }, $class;
d141 6
a146 3
	my $host = $self->{host};
	my $path = $self->{path};
	return $self->_list("ssh $host ls -l $path");
d168 1
a168 1
	my @@l = ();
d170 1
a170 1
	opendir(my $dir, $dname) or return undef;
d174 1
a174 1
		push(@@l, $`);
d177 1
a177 6
	return @@l;
}

sub simplelist
{
	return $_[0]->list();
d198 1
a198 1
	my @@l =();
d205 1
a205 1
		push(@@l, $1);
d208 1
a208 1
	return @@l;
d213 1
a213 1
my %distant = ();
d252 13
a264 11
	$self->make_room();
	my $fullname = $self->{location};
	my @@l =();
	local $_;
	open(my $fh, '-|', "ftp -o - $fullname 2>/dev/null") or return undef;
	# XXX assumes a pkg HREF won't cross a line. Is this the case ?
	while(<$fh>) {
		chomp;
		for my $pkg (m/\<A\s+HREF=\"(.*?)\.tgz\"\>/gi) {
			next if $pkg =~ m|/|;
			push(@@l, $pkg);
d266 1
d268 1
a268 2
	close($fh);
	return @@l;
d277 6
a282 3
	$self->make_room();
	my $fullname = $self->{location};
	return $self->_list("echo nlist|ftp -o - $fullname 2>/dev/null");
d296 4
d302 4
a305 1
	my @@tentative = split /\:/, $ENV{PKG_PATH};
a307 3
		if ($i =~ m/^(?:ftp|http|scp)$/i) {
			$i.= ":".(shift @@tentative);
		}
d339 1
d353 9
a361 12
	my @@l = ();
	foreach my $loc (@@pkgpath) {
		push(@@l, $loc->simplelist());
	}
	return @@l;
}

sub distant_available
{
	my @@l = ();
	foreach my $loc (@@pkgpath) {
		push(@@l, $loc->list());
d363 1
a363 1
	return @@l;
@


1.19
log
@remove tempdir right away if it turns out we're not dealing with a
package at all.
@
text
@d2 1
a2 1
# $OpenBSD: PackageLocator.pm,v 1.18 2005/08/16 11:09:28 espie Exp $
d401 6
a406 1
			eval { $e->create(); }
@


1.18
log
@don't mix nlist with ls
@
text
@d2 1
a2 1
# $OpenBSD: PackageLocator.pm,v 1.17 2005/08/16 10:24:23 espie Exp $
d432 3
@


1.17
log
@support code for pkg_add -u:
- distant_available(), using the distant listing functions.
- stem compiler, to match lots of stems
@
text
@d2 1
a2 1
# $OpenBSD: PackageLocator.pm,v 1.16 2005/08/16 09:44:07 espie Exp $
d268 1
a268 1
	return $self->_list("echo nlist *.tgz|ftp -o - $fullname 2>/dev/null");
@


1.16
log
@make the code that enforces the connection limit a separate function, so
that the distant listing code can use it too. Since the distant listing code
creates transient connections, it does not actually need to be tracked,
just to ensure that it has a slot !
@
text
@d2 1
a2 1
# $OpenBSD: PackageLocator.pm,v 1.15 2005/08/16 09:35:15 espie Exp $
d337 9
@


1.15
log
@fix a few minor details: _list() needs to be called as a method.
use nlist *.tgz instead of ls to gain speed. http does not need
any command, it just retrieves the directory index.

(code not used yet, but so blatantly incorrect)
@
text
@d2 1
a2 1
# $OpenBSD: PackageLocator.pm,v 1.14 2005/06/26 16:41:08 espie Exp $
d64 1
a64 3

# open method that tracks opened files per-host.
sub open
d66 1
a66 3
	my ($self, $object) = @@_;

	return undef unless $self->may_exist($object->{name});
d80 12
d243 1
d266 1
@


1.14
log
@Handle hard links correctly: the names need to be aliased correctly for
pkg_merging, and the names need to lose the prefix path when getting
extracted.
@
text
@d2 1
a2 1
# $OpenBSD: PackageLocator.pm,v 1.13 2005/06/26 12:44:29 espie Exp $
d124 1
a124 1
	return _list("ssh $host ls -l $path");
d238 1
a238 1
	open(my $fh, '-|', "echo ls|ftp -o - $fullname 2>/dev/null") or return undef;
d258 1
a258 1
	return _list("echo ls|ftp -o - $fullname 2>/dev/null");
@


1.13
log
@select fat package based on name too.
@
text
@d2 1
a2 1
# $OpenBSD: PackageLocator.pm,v 1.12 2005/06/26 11:25:11 espie Exp $
d451 3
@


1.12
log
@handle fat packages based on architecture.
@
text
@d2 1
a2 1
# $OpenBSD: PackageLocator.pm,v 1.11 2004/08/06 08:06:01 espie Exp $
d370 1
d401 2
d404 1
@


1.11
log
@block-scoped require is way simpler than weird AUTOLOAD hack.
@
text
@d2 1
a2 1
# $OpenBSD: PackageLocator.pm,v 1.10 2004/08/06 07:51:17 espie Exp $
d291 1
d295 1
a295 1
		my $package = $class->openAbsolute($location, '');
d308 1
a308 1
		$package = $class->openAbsolute($location, $pkgname);
d314 1
a314 1
			$package = $class->openAbsolute($p, $_);
d366 1
a366 1
	my ($class, $location, $name) = @@_;
d377 1
d391 17
d439 11
a449 1
		$self->{_current} = $self->{_archive}->next();
@


1.10
log
@unified headers, switch to smaller copyright notice.
@
text
@d2 1
a2 1
# $OpenBSD: PackageLocator.pm,v 1.9 2004/03/11 18:54:06 espie Exp $
a20 11
# XXX we don't want to load Ustar all the time
package OpenBSD::Ustar;

our $AUTOLOAD;

sub AUTOLOAD {
	eval { require OpenBSD::Ustar;
	};
	goto &$AUTOLOAD;
}

d357 2
a429 5
}

# allows the autoloader to work correctly
sub DESTROY
{
@


1.9
log
@repair pkg_add -, by making sure `-' is a special object.
@
text
@d1 2
a2 1
# $OpenBSD: PackageLocator.pm,v 1.8 2004/03/07 19:29:08 espie Exp $
d4 13
a16 22
# Copyright (c) 2003 Marc Espie.
# 
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
# 
# THIS SOFTWARE IS PROVIDED BY THE OPENBSD PROJECT AND CONTRIBUTORS
# ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
# A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OPENBSD
# PROJECT OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
@


1.8
log
@A few useful features:
- pkg_add -A arch, to make believe we are extracting on a given arch
(matches pkg_create).
- pkg_add -P cdrom/-P ftp, to enforce extracting only cdrom'able packages
or ftp'able packages. Helps a lot for checking cdrom lists.
- dependency look-up will look through local directory listings to solve
dependencies, so that non-default dependencies will work more seemlessly.
(doing the same thing for distant repository will happen after 3.5, but
this requires more apparatus: caching package lists, and killing/restoring
existing connections, plus more error handling).

okay pval
@
text
@d1 1
a1 1
# $OpenBSD: PackageLocator.pm,v 1.7 2004/01/28 22:30:50 espie Exp $
d182 13
d312 1
a312 1
		my $location = OpenBSD::PackageLocation->new('-');
@


1.7
log
@some code refactoring.
minor optimization: don't try to open pipe to local file that doesn't
exist anyways.

track connections per-host for ftp/http.
Don't allow more than maxcount() connections per-host (for now, one
connection).

tests by sturm@@, fries@@
@
text
@d1 1
a1 1
# $OpenBSD: PackageLocator.pm,v 1.6 2003/12/19 00:29:20 espie Exp $
d114 5
d166 2
a167 1
	opendir(my $dir, $self->{location}) or return undef;
d169 2
a170 2
		next unless -f "$dir/$e";
		next unless $e = ~ m/\.tgz$/;
d177 5
d325 9
@


1.6
log
@Clean up PackageLocator so it looks somewhat more object-oriented.
Most importantly, put all the state information into the created object,
so that the actual archive can be closed, later reopened, and scanned
until the correct file is found.

This will be used to allow retrieving packages through ftp without keeping
loads of connections opened because of dependency resolving.

Approved by fries and naddy.
@
text
@d1 1
a1 1
# $OpenBSD: PackageLocator.pm,v 1.5 2003/11/06 17:59:23 espie Exp $
d62 52
d125 1
a125 1
sub open
d130 1
a130 2
	open(my $fh, '-|', "scp $host:$path$name /dev/stdout 2> /dev/null|gzip -d -c -q - 2> /dev/null") or return undef;
	return $fh;
d144 1
a144 1
sub open
d148 7
a154 2
	open(my $fh, '-|', "gzip -d -c -q -f 2>/dev/null $fullname") or return undef;
	return $fh;
d190 29
a218 1
sub open
d222 1
a222 2
	open(my $fh, '-|', "ftp -o - $fullname 2>/dev/null|gzip -d -c -q - 2>/dev/null") or return undef;
	return $fh;
d325 6
a330 1
	close($self->{fh}) if defined $self->{fh};
d339 1
a339 2
	my $fh = $self->{location}->open($self->{name});
	$self->{fh} = $fh;
d363 1
a363 1
			$e->create();
a380 1
#	print "Reopening ", $self->{name}, "\n";
a384 1
#		print "Scanning ", $e->{name}, "\n";
@


1.5
log
@Handle pkg_add -
let pkg_add postpone conflict handling until it has the real name of
the package if necessary, and let PackageLocator deal correctly with a '-'
filename.
@
text
@d1 1
a1 1
# $OpenBSD: PackageLocator.pm,v 1.4 2003/10/31 18:42:51 espie Exp $
d206 1
a206 2
		my $package = openAbsolute($location, '');
		bless $package, $class;
d219 1
a219 1
		$package = openAbsolute($location, $pkgname);
d225 1
a225 1
			$package = openAbsolute($p, $_);
d229 2
a230 3
	return $package unless defined $package;
	$packages{$_} = $package;
	bless $package, $class;
d244 1
a244 1
	$self->{archive} = undef;
d247 1
a247 1
sub openAbsolute
d249 4
a252 2
	my ($location, $name) = @@_;
	my $fh = $location->open($name);
d257 12
d270 1
a271 1
	my $self = { name => $_, fh => $fh, archive => $archive, dir => $dir };
d273 1
a273 1
	while (my $e = $archive->next()) {
d278 1
a278 1
			$archive->unput();
d283 1
d286 10
a295 1
		CORE::close($fh);
d298 31
@


1.4
log
@put pkgpath back in correct order.
automatically append package location specified on the command
line to pkgpath (reported by numerous people).

okay sturm@@
@
text
@d1 1
a1 1
# $OpenBSD: PackageLocator.pm,v 1.3 2003/10/23 23:18:55 espie Exp $
d97 1
a97 1
	open(my $fh, '-|', "gzip -d -c -q 2>/dev/null $fullname") or return undef;
d203 7
@


1.3
log
@Allows close() on already closed locator.
Fix second problem seen by krw@@
@
text
@d1 1
a1 1
# $OpenBSD: PackageLocator.pm,v 1.2 2003/10/19 18:41:56 espie Exp $
d193 1
a193 1
		unshift @@pkgpath, OpenBSD::PackageLocation->new($i);
d209 8
a216 2
		my $location = OpenBSD::PackageLocation->new($_);
		$package = openAbsolute($location, '');
@


1.2
log
@pkgpath is .  by default.
@
text
@d1 1
a1 1
# $OpenBSD: PackageLocator.pm,v 1.1.1.1 2003/10/16 17:43:34 espie Exp $
d231 1
a231 1
	close($self->{fh});
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
# $OpenBSD: PackageLocator.pm,v 1.1.1.1 2003/10/16 17:16:30 espie Exp $
d195 2
@


1.1.1.1
log
@new import of my pkgtools, after a slight naming disagreement with the
Upper Management...
@
text
@@
