head	1.173;
access;
symbols
	OPENBSD_6_1:1.173.0.4
	OPENBSD_6_1_BASE:1.173
	OPENBSD_6_0:1.170.0.4
	OPENBSD_6_0_BASE:1.170
	OPENBSD_5_9:1.169.0.2
	OPENBSD_5_9_BASE:1.169
	OPENBSD_5_8:1.169.0.4
	OPENBSD_5_8_BASE:1.169
	OPENBSD_5_7:1.164.0.2
	OPENBSD_5_7_BASE:1.164
	OPENBSD_5_6:1.161.0.4
	OPENBSD_5_6_BASE:1.161
	OPENBSD_5_5:1.149.0.4
	OPENBSD_5_5_BASE:1.149
	OPENBSD_5_4:1.133.0.4
	OPENBSD_5_4_BASE:1.133
	OPENBSD_5_3:1.133.0.2
	OPENBSD_5_3_BASE:1.133
	OPENBSD_5_2:1.130.0.2
	OPENBSD_5_2_BASE:1.130
	OPENBSD_5_1_BASE:1.129
	OPENBSD_5_1:1.129.0.2
	OPENBSD_5_0:1.124.0.2
	OPENBSD_5_0_BASE:1.124
	OPENBSD_4_9:1.122.0.2
	OPENBSD_4_9_BASE:1.122
	OPENBSD_4_8:1.115.0.2
	OPENBSD_4_8_BASE:1.115
	OPENBSD_4_7:1.104.0.2
	OPENBSD_4_7_BASE:1.104
	OPENBSD_4_6:1.88.0.4
	OPENBSD_4_6_BASE:1.88
	OPENBSD_4_5:1.85.0.2
	OPENBSD_4_5_BASE:1.85
	OPENBSD_4_4:1.83.0.2
	OPENBSD_4_4_BASE:1.83
	OPENBSD_4_3:1.81.0.4
	OPENBSD_4_3_BASE:1.81
	OPENBSD_4_2:1.81.0.2
	OPENBSD_4_2_BASE:1.81
	OPENBSD_4_1:1.50.0.2
	OPENBSD_4_1_BASE:1.50
	OPENBSD_4_0:1.48.0.4
	OPENBSD_4_0_BASE:1.48
	OPENBSD_3_9:1.48.0.2
	OPENBSD_3_9_BASE:1.48
	OPENBSD_3_8:1.39.0.2
	OPENBSD_3_8_BASE:1.39
	OPENBSD_3_7:1.31.0.2
	OPENBSD_3_7_BASE:1.31;
locks; strict;
comment	@# @;


1.173
date	2017.03.03.14.06.32;	author espie;	state Exp;
branches;
next	1.172;
commitid	bNSFa2yCbJO7px2f;

1.172
date	2016.08.27.18.17.46;	author espie;	state Exp;
branches;
next	1.171;
commitid	gU2z7H9jfAvdu8Iz;

1.171
date	2016.08.12.11.17.37;	author espie;	state Exp;
branches;
next	1.170;
commitid	MGHi9LgU67P6WvQB;

1.170
date	2016.04.02.12.18.44;	author espie;	state Exp;
branches;
next	1.169;
commitid	YeDPCJ6ER1ZZVXJV;

1.169
date	2015.05.25.07.20.31;	author espie;	state Exp;
branches;
next	1.168;
commitid	OQgkIpW2ns8hlwEU;

1.168
date	2015.05.18.18.25.13;	author espie;	state Exp;
branches;
next	1.167;
commitid	7BGI5YuG7t0cBCSe;

1.167
date	2015.05.18.18.17.27;	author espie;	state Exp;
branches;
next	1.166;
commitid	xzIWGymmdr7C9W4l;

1.166
date	2015.05.18.10.41.19;	author espie;	state Exp;
branches;
next	1.165;
commitid	rrwCEb8hinrmFki2;

1.165
date	2015.03.29.09.42.58;	author espie;	state Exp;
branches;
next	1.164;
commitid	aGCcg6yat5ZgtSYY;

1.164
date	2014.11.30.15.53.26;	author espie;	state Exp;
branches;
next	1.163;
commitid	4TfcC66BF3LV8lu0;

1.163
date	2014.11.25.14.16.15;	author espie;	state Exp;
branches;
next	1.162;
commitid	UeC1WcUe5pQNhy3k;

1.162
date	2014.11.21.15.07.09;	author espie;	state Exp;
branches;
next	1.161;
commitid	9JKM8glnI39M4iKz;

1.161
date	2014.07.12.19.50.43;	author espie;	state Exp;
branches;
next	1.160;
commitid	QzYY7ILxCL3CoU1A;

1.160
date	2014.07.11.12.49.20;	author espie;	state Exp;
branches;
next	1.159;
commitid	m039fLFzsDbIVH1a;

1.159
date	2014.07.10.10.32.01;	author espie;	state Exp;
branches;
next	1.158;
commitid	67aPPsPHmCNALsP2;

1.158
date	2014.07.07.16.45.03;	author espie;	state Exp;
branches;
next	1.157;
commitid	dNXHBdhSxhza9UxR;

1.157
date	2014.07.01.09.22.40;	author espie;	state Exp;
branches;
next	1.156;
commitid	VUqmQ7tTf31CANZ7;

1.156
date	2014.06.25.10.52.21;	author espie;	state Exp;
branches;
next	1.155;
commitid	9MGnEZdgBZC3SHdG;

1.155
date	2014.06.17.13.35.06;	author espie;	state Exp;
branches;
next	1.154;
commitid	RN1bHBeyBmhKyZON;

1.154
date	2014.06.16.09.02.07;	author espie;	state Exp;
branches;
next	1.153;
commitid	6aQdppY1h2Ao9BwU;

1.153
date	2014.05.20.05.55.43;	author espie;	state Exp;
branches;
next	1.152;

1.152
date	2014.05.20.05.46.13;	author espie;	state Exp;
branches;
next	1.151;

1.151
date	2014.04.18.10.00.48;	author schwarze;	state Exp;
branches;
next	1.150;

1.150
date	2014.03.18.18.53.29;	author espie;	state Exp;
branches;
next	1.149;

1.149
date	2014.02.10.19.16.19;	author espie;	state Exp;
branches;
next	1.148;

1.148
date	2014.02.08.10.43.25;	author espie;	state Exp;
branches;
next	1.147;

1.147
date	2014.02.03.16.13.13;	author espie;	state Exp;
branches;
next	1.146;

1.146
date	2014.02.03.15.57.13;	author espie;	state Exp;
branches;
next	1.145;

1.145
date	2014.01.31.10.29.54;	author espie;	state Exp;
branches;
next	1.144;

1.144
date	2014.01.30.13.12.50;	author espie;	state Exp;
branches;
next	1.143;

1.143
date	2014.01.17.15.54.06;	author espie;	state Exp;
branches;
next	1.142;

1.142
date	2014.01.11.11.54.43;	author espie;	state Exp;
branches;
next	1.141;

1.141
date	2014.01.11.11.51.01;	author espie;	state Exp;
branches;
next	1.140;

1.140
date	2014.01.09.20.20.01;	author espie;	state Exp;
branches;
next	1.139;

1.139
date	2014.01.07.17.33.53;	author espie;	state Exp;
branches;
next	1.138;

1.138
date	2014.01.07.13.31.35;	author espie;	state Exp;
branches;
next	1.137;

1.137
date	2014.01.07.13.26.17;	author espie;	state Exp;
branches;
next	1.136;

1.136
date	2014.01.07.10.22.05;	author espie;	state Exp;
branches;
next	1.135;

1.135
date	2014.01.05.10.24.30;	author espie;	state Exp;
branches;
next	1.134;

1.134
date	2013.12.30.09.02.37;	author espie;	state Exp;
branches;
next	1.133;

1.133
date	2013.02.18.20.24.11;	author okan;	state Exp;
branches;
next	1.132;

1.132
date	2013.02.18.19.56.10;	author okan;	state Exp;
branches;
next	1.131;

1.131
date	2013.02.18.19.29.03;	author okan;	state Exp;
branches;
next	1.130;

1.130
date	2012.04.28.12.00.10;	author espie;	state Exp;
branches;
next	1.129;

1.129
date	2012.01.16.08.42.38;	author schwarze;	state Exp;
branches;
next	1.128;

1.128
date	2012.01.05.23.03.57;	author schwarze;	state Exp;
branches;
next	1.127;

1.127
date	2011.12.03.16.15.05;	author espie;	state Exp;
branches;
next	1.126;

1.126
date	2011.09.17.15.33.56;	author schwarze;	state Exp;
branches;
next	1.125;

1.125
date	2011.08.23.10.32.27;	author espie;	state Exp;
branches;
next	1.124;

1.124
date	2011.07.12.10.09.52;	author espie;	state Exp;
branches;
next	1.123;

1.123
date	2011.06.20.09.46.22;	author espie;	state Exp;
branches;
next	1.122;

1.122
date	2011.01.25.11.46.57;	author espie;	state Exp;
branches;
next	1.121;

1.121
date	2011.01.23.06.56.53;	author espie;	state Exp;
branches;
next	1.120;

1.120
date	2011.01.21.20.37.26;	author espie;	state Exp;
branches;
next	1.119;

1.119
date	2010.12.29.13.03.05;	author espie;	state Exp;
branches;
next	1.118;

1.118
date	2010.12.24.09.09.54;	author espie;	state Exp;
branches;
next	1.117;

1.117
date	2010.12.24.09.04.14;	author espie;	state Exp;
branches;
next	1.116;

1.116
date	2010.10.02.13.33.05;	author espie;	state Exp;
branches;
next	1.115;

1.115
date	2010.08.07.21.19.04;	author espie;	state Exp;
branches;
next	1.114;

1.114
date	2010.07.24.10.49.01;	author espie;	state Exp;
branches;
next	1.113;

1.113
date	2010.06.30.10.51.04;	author espie;	state Exp;
branches;
next	1.112;

1.112
date	2010.06.30.10.41.41;	author espie;	state Exp;
branches;
next	1.111;

1.111
date	2010.06.15.08.26.39;	author espie;	state Exp;
branches;
next	1.110;

1.110
date	2010.06.09.07.26.01;	author espie;	state Exp;
branches;
next	1.109;

1.109
date	2010.06.04.13.19.39;	author espie;	state Exp;
branches;
next	1.108;

1.108
date	2010.05.10.09.17.55;	author espie;	state Exp;
branches;
next	1.107;

1.107
date	2010.04.05.16.07.10;	author espie;	state Exp;
branches;
next	1.106;

1.106
date	2010.04.05.13.46.24;	author espie;	state Exp;
branches;
next	1.105;

1.105
date	2010.03.22.20.38.44;	author espie;	state Exp;
branches;
next	1.104;

1.104
date	2010.01.14.19.35.55;	author espie;	state Exp;
branches;
next	1.103;

1.103
date	2010.01.03.19.55.35;	author espie;	state Exp;
branches;
next	1.102;

1.102
date	2010.01.02.12.59.45;	author espie;	state Exp;
branches;
next	1.101;

1.101
date	2009.12.20.22.38.45;	author espie;	state Exp;
branches;
next	1.100;

1.100
date	2009.12.17.11.57.02;	author espie;	state Exp;
branches;
next	1.99;

1.99
date	2009.12.17.11.07.24;	author espie;	state Exp;
branches;
next	1.98;

1.98
date	2009.12.17.08.21.09;	author espie;	state Exp;
branches;
next	1.97;

1.97
date	2009.11.16.14.42.18;	author espie;	state Exp;
branches;
next	1.96;

1.96
date	2009.11.11.13.00.40;	author espie;	state Exp;
branches;
next	1.95;

1.95
date	2009.11.11.12.32.03;	author espie;	state Exp;
branches;
next	1.94;

1.94
date	2009.11.11.12.21.20;	author espie;	state Exp;
branches;
next	1.93;

1.93
date	2009.11.11.12.04.19;	author espie;	state Exp;
branches;
next	1.92;

1.92
date	2009.11.11.11.13.16;	author espie;	state Exp;
branches;
next	1.91;

1.91
date	2009.11.10.11.36.56;	author espie;	state Exp;
branches;
next	1.90;

1.90
date	2009.10.27.11.45.22;	author espie;	state Exp;
branches;
next	1.89;

1.89
date	2009.10.11.18.38.06;	author espie;	state Exp;
branches;
next	1.88;

1.88
date	2009.04.20.08.29.02;	author espie;	state Exp;
branches;
next	1.87;

1.87
date	2009.04.19.14.58.32;	author espie;	state Exp;
branches;
next	1.86;

1.86
date	2009.03.05.10.44.59;	author espie;	state Exp;
branches;
next	1.85;

1.85
date	2008.10.20.10.25.16;	author espie;	state Exp;
branches;
next	1.84;

1.84
date	2008.10.06.09.36.17;	author espie;	state Exp;
branches;
next	1.83;

1.83
date	2008.06.11.09.43.25;	author espie;	state Exp;
branches;
next	1.82;

1.82
date	2008.03.08.12.07.45;	author espie;	state Exp;
branches;
next	1.81;

1.81
date	2007.06.25.09.30.16;	author espie;	state Exp;
branches;
next	1.80;

1.80
date	2007.06.18.10.47.03;	author espie;	state Exp;
branches;
next	1.79;

1.79
date	2007.06.16.11.50.49;	author espie;	state Exp;
branches;
next	1.78;

1.78
date	2007.06.16.09.29.37;	author espie;	state Exp;
branches;
next	1.77;

1.77
date	2007.06.12.09.53.36;	author espie;	state Exp;
branches;
next	1.76;

1.76
date	2007.06.09.13.39.31;	author espie;	state Exp;
branches;
next	1.75;

1.75
date	2007.06.06.15.35.20;	author espie;	state Exp;
branches;
next	1.74;

1.74
date	2007.06.06.15.31.06;	author espie;	state Exp;
branches;
next	1.73;

1.73
date	2007.06.06.12.32.09;	author espie;	state Exp;
branches;
next	1.72;

1.72
date	2007.06.04.18.55.47;	author espie;	state Exp;
branches;
next	1.71;

1.71
date	2007.06.04.14.40.39;	author espie;	state Exp;
branches;
next	1.70;

1.70
date	2007.06.01.22.06.03;	author espie;	state Exp;
branches;
next	1.69;

1.69
date	2007.06.01.14.58.29;	author espie;	state Exp;
branches;
next	1.68;

1.68
date	2007.05.31.11.05.41;	author espie;	state Exp;
branches;
next	1.67;

1.67
date	2007.05.31.10.04.03;	author espie;	state Exp;
branches;
next	1.66;

1.66
date	2007.05.30.16.32.14;	author espie;	state Exp;
branches;
next	1.65;

1.65
date	2007.05.30.14.04.51;	author espie;	state Exp;
branches;
next	1.64;

1.64
date	2007.05.30.13.03.54;	author espie;	state Exp;
branches;
next	1.63;

1.63
date	2007.05.30.12.52.07;	author espie;	state Exp;
branches;
next	1.62;

1.62
date	2007.05.30.11.40.07;	author espie;	state Exp;
branches;
next	1.61;

1.61
date	2007.05.30.11.13.35;	author espie;	state Exp;
branches;
next	1.60;

1.60
date	2007.05.29.14.39.03;	author espie;	state Exp;
branches;
next	1.59;

1.59
date	2007.05.29.13.52.07;	author espie;	state Exp;
branches;
next	1.58;

1.58
date	2007.05.28.13.00.04;	author espie;	state Exp;
branches;
next	1.57;

1.57
date	2007.05.28.12.16.55;	author espie;	state Exp;
branches;
next	1.56;

1.56
date	2007.05.28.11.15.11;	author espie;	state Exp;
branches;
next	1.55;

1.55
date	2007.05.27.22.04.17;	author espie;	state Exp;
branches;
next	1.54;

1.54
date	2007.05.22.11.02.57;	author espie;	state Exp;
branches;
next	1.53;

1.53
date	2007.05.02.15.05.29;	author espie;	state Exp;
branches;
next	1.52;

1.52
date	2007.04.29.11.09.29;	author espie;	state Exp;
branches;
next	1.51;

1.51
date	2007.04.15.10.17.29;	author espie;	state Exp;
branches;
next	1.50;

1.50
date	2007.02.24.18.45.11;	author espie;	state Exp;
branches;
next	1.49;

1.49
date	2006.12.05.14.04.19;	author steven;	state Exp;
branches;
next	1.48;

1.48
date	2006.02.16.11.21.58;	author espie;	state Exp;
branches;
next	1.47;

1.47
date	2006.02.09.09.42.10;	author espie;	state Exp;
branches;
next	1.46;

1.46
date	2005.12.05.13.39.28;	author espie;	state Exp;
branches;
next	1.45;

1.45
date	2005.11.02.22.26.51;	author espie;	state Exp;
branches;
next	1.44;

1.44
date	2005.11.02.17.01.26;	author bernd;	state Exp;
branches;
next	1.43;

1.43
date	2005.10.19.10.41.19;	author espie;	state Exp;
branches;
next	1.42;

1.42
date	2005.09.24.12.52.19;	author espie;	state Exp;
branches;
next	1.41;

1.41
date	2005.09.04.22.53.51;	author espie;	state Exp;
branches;
next	1.40;

1.40
date	2005.09.04.22.47.56;	author espie;	state Exp;
branches;
next	1.39;

1.39
date	2005.08.22.11.25.59;	author espie;	state Exp;
branches;
next	1.38;

1.38
date	2005.08.16.16.24.24;	author espie;	state Exp;
branches;
next	1.37;

1.37
date	2005.08.13.16.46.35;	author espie;	state Exp;
branches;
next	1.36;

1.36
date	2005.08.13.15.47.57;	author espie;	state Exp;
branches;
next	1.35;

1.35
date	2005.08.07.14.18.05;	author espie;	state Exp;
branches;
next	1.34;

1.34
date	2005.08.05.09.52.08;	author espie;	state Exp;
branches;
next	1.33;

1.33
date	2005.06.21.19.12.31;	author espie;	state Exp;
branches;
next	1.32;

1.32
date	2005.06.12.11.14.28;	author espie;	state Exp;
branches;
next	1.31;

1.31
date	2005.02.07.00.52.35;	author espie;	state Exp;
branches;
next	1.30;

1.30
date	2005.01.13.00.27.39;	author espie;	state Exp;
branches;
next	1.29;

1.29
date	2004.12.20.12.16.51;	author espie;	state Exp;
branches;
next	1.28;

1.28
date	2004.12.18.13.58.43;	author espie;	state Exp;
branches;
next	1.27;

1.27
date	2004.12.18.13.48.23;	author espie;	state Exp;
branches;
next	1.26;

1.26
date	2004.12.17.11.26.21;	author espie;	state Exp;
branches;
next	1.25;

1.25
date	2004.12.16.11.07.33;	author espie;	state Exp;
branches;
next	1.24;

1.24
date	2004.12.12.11.26.16;	author espie;	state Exp;
branches;
next	1.23;

1.23
date	2004.12.02.00.37.54;	author espie;	state Exp;
branches;
next	1.22;

1.22
date	2004.11.22.01.56.13;	author espie;	state Exp;
branches;
next	1.21;

1.21
date	2004.11.18.21.48.02;	author espie;	state Exp;
branches;
next	1.20;

1.20
date	2004.11.14.19.50.44;	author espie;	state Exp;
branches;
next	1.19;

1.19
date	2004.11.13.12.33.01;	author espie;	state Exp;
branches;
next	1.18;

1.18
date	2004.11.13.12.02.57;	author espie;	state Exp;
branches;
next	1.17;

1.17
date	2004.11.13.11.39.40;	author espie;	state Exp;
branches;
next	1.16;

1.16
date	2004.11.13.10.47.21;	author espie;	state Exp;
branches;
next	1.15;

1.15
date	2004.11.12.21.52.01;	author espie;	state Exp;
branches;
next	1.14;

1.14
date	2004.11.11.12.29.58;	author espie;	state Exp;
branches;
next	1.13;

1.13
date	2004.11.11.12.17.25;	author espie;	state Exp;
branches;
next	1.12;

1.12
date	2004.11.11.12.13.57;	author espie;	state Exp;
branches;
next	1.11;

1.11
date	2004.11.11.11.36.26;	author espie;	state Exp;
branches;
next	1.10;

1.10
date	2004.11.11.11.16.39;	author espie;	state Exp;
branches;
next	1.9;

1.9
date	2004.11.06.19.48.24;	author espie;	state Exp;
branches;
next	1.8;

1.8
date	2004.11.06.12.22.33;	author espie;	state Exp;
branches;
next	1.7;

1.7
date	2004.11.06.12.20.02;	author espie;	state Exp;
branches;
next	1.6;

1.6
date	2004.11.06.12.19.17;	author espie;	state Exp;
branches;
next	1.5;

1.5
date	2004.11.01.19.21.58;	author espie;	state Exp;
branches;
next	1.4;

1.4
date	2004.11.01.15.45.02;	author espie;	state Exp;
branches;
next	1.3;

1.3
date	2004.11.01.14.30.00;	author espie;	state Exp;
branches;
next	1.2;

1.2
date	2004.11.01.11.48.03;	author espie;	state Exp;
branches;
next	1.1;

1.1
date	2004.11.01.11.27.50;	author espie;	state Exp;
branches;
next	;


desc
@@


1.173
log
@pass @@sysctl into old stuff
okay sthen@@
@
text
@# ex:ts=8 sw=4:
# $OpenBSD: Add.pm,v 1.172 2016/08/27 18:17:46 espie Exp $
#
# Copyright (c) 2003-2014 Marc Espie <espie@@openbsd.org>
#
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

use strict;
use warnings;

package OpenBSD::Add;
use OpenBSD::Error;
use OpenBSD::PackageInfo;
use OpenBSD::ArcCheck;
use OpenBSD::Paths;
use File::Copy;

sub manpages_index
{
	my ($state) = @@_;
	return unless defined $state->{addman};
	my $destdir = $state->{destdir};

	# fudge verbose for API differences
	while (my ($k, $v) = each %{$state->{addman}}) {
		my @@l = map { "$destdir$k/$_" } @@$v;
		if ($state->{not}) {
			$state->say("Merging manpages in #1: #2",
			    $destdir.$k, join(' ', @@l)) if $state->verbose;
		} else {
			$state->run_makewhatis(['-d', $destdir.$k], \@@l);
		}
	}
	delete $state->{addman};
}

sub register_installation
{
	my ($plist, $state) = @@_;
	if ($state->{not}) {
		$plist->to_cache;
	} else {
		my $dest = installed_info($plist->pkgname);
		mkdir($dest);
		$plist->copy_info($dest, $state);
		$plist->set_infodir($dest);
		$plist->to_installation;
	}
}

sub validate_plist
{
	my ($plist, $state, $set) = @@_;

	$plist->prepare_for_addition($state, $plist->pkgname, $set);
}

sub record_partial_installation
{
	my ($plist, $state, $h) = @@_;

	use OpenBSD::PackingElement;

	my $n = $plist->make_shallow_copy($h);
	my $borked = borked_package($plist->pkgname);
	$n->set_pkgname($borked);

	# last file may have not copied correctly
	my $last = $n->{state}->{lastfile};
	if (defined $last && defined($last->{d})) {

		my $old = $last->{d};
		my $lastname = $last->realname($state);
		if (-f $lastname) {
			$last->{d} = $last->compute_digest($lastname, $old);
			if (!$old->equals($last->{d})) {
				$state->say("Adjusting #1 for #2 from #3 to #4",
				    $old->keyword, $lastname, $old->stringize,
				    $last->{d}->stringize);
			}
		} else {
			delete $last->{d};
		}
	}
	register_installation($n, $state);
	return $borked;
}

sub perform_installation
{
	my ($handle, $state) = @@_;

	$state->{partial} = $handle->{partial};
	$state->progress->visit_with_size($handle->{plist}, 'install');
	if ($handle->{location}{early_close}) {
		$handle->{location}->close_now;
	} else {
		$handle->{location}->finish_and_close;
	}
}

sub perform_extraction
{
	my ($handle, $state) = @@_;

	$handle->{partial} = {};
	$state->{partial} = $handle->{partial};
	$state->{archive} = $handle->{location};
	$state->{check_digest} = $handle->{plist}{check_digest};
	my ($wanted, $tied) = ({}, {});
	$handle->{plist}->find_extractible($state, $wanted, $tied);
	my $p = $state->progress->new_sizer($handle->{plist}, $state);
	while (my $file = $state->{archive}->next) {
		if (keys %$wanted == 0) {
			for my $e (values %$tied) {
				$e->tie($state);
			}
			if (keys %$tied > 0) {
				$handle->{location}{early_close} = 1;
			}
			last;
		}
		my $e = $tied->{$file->name};
		if (defined $e) {
			delete $tied->{$file->name};
			$e->prepare_to_extract($state, $file);
			$e->tie($state);
			$state->{archive}->skip;
			$p->advance($e);
			# skip to next;
			next;
		}
		$e = $wanted->{$file->name};
		if (!defined $e) {
			$state->fatal("archive member not found #1",
			    $file->name);
		}
		delete $wanted->{$file->name};
		$e->prepare_to_extract($state, $file);
		$e->extract($state, $file);
		$p->advance($e);
	}
	if (keys %$wanted > 0) {
		$state->fatal("Truncated archive");
	}
	$p->saved;
}

my $user_tagged = {};

sub extract_pkgname
{
	my $pkgname = shift;
	$pkgname =~ s/^.*\///;
	$pkgname =~ s/\.tgz$//;
	return $pkgname;
}

sub tweak_package_status
{
	my ($pkgname, $state) = @@_;

	$pkgname = extract_pkgname($pkgname);
	return 0 unless is_installed($pkgname);
	return 0 unless $user_tagged->{$pkgname};
	return 1 if $state->{not};
	my $plist = OpenBSD::PackingList->from_installation($pkgname);
	if ($plist->has('manual-installation') && $state->{automatic} > 1) {
		delete $plist->{'manual-installation'};
		$plist->to_installation;
		return 1;
	} elsif (!$plist->has('manual-installation') && !$state->{automatic}) {
		OpenBSD::PackingElement::ManualInstallation->add($plist);
		$plist->to_installation;
		return 1;
	}
	return 0;
}

sub tweak_plist_status
{
	my ($plist, $state) = @@_;

	my $pkgname = $plist->pkgname;
	if ($state->defines('FW_UPDATE')) {
		$plist->has('firmware') or
			OpenBSD::PackingElement::Firmware->add($plist);
	}
	return 0 unless $user_tagged->{$pkgname};
	if (!$plist->has('manual-installation') && !$state->{automatic}) {
		OpenBSD::PackingElement::ManualInstallation->add($plist);
	}
}

sub tag_user_packages
{
	for my $set (@@_) {
		for my $n ($set->newer_names) {
			$user_tagged->{OpenBSD::PackageName::url2pkgname($n)} = 1;
		}
	}
}

# used by newuser/newgroup to deal with options.
package OpenBSD::PackingElement;
use OpenBSD::Error;

my ($uidcache, $gidcache);

sub prepare_for_addition
{
}

sub find_extractible
{
}

sub extract
{
	my ($self, $state) = @@_;
	$state->{partial}{$self} = 1;
	if ($state->{interrupted}) {
		die "Interrupted";
	}
}

sub install
{
	my ($self, $state) = @@_;
	# XXX "normal" items are already in partial, but NOT stuff
	# that's install-only, like symlinks and dirs...
	$state->{partial}{$self} = 1;
	if ($state->{interrupted}) {
		die "Interrupted";
	}
}

sub copy_info
{
}

sub set_modes
{
	my ($self, $state, $name) = @@_;

	if (defined $self->{owner} || defined $self->{group}) {
		require OpenBSD::IdCache;

		if (!defined $uidcache) {
			$uidcache = OpenBSD::UidCache->new;
			$gidcache = OpenBSD::GidCache->new;
		}
		my ($uid, $gid) = (-1, -1);
		if (defined $self->{owner}) {
			$uid = $uidcache->lookup($self->{owner}, $uid);
		}
		if (defined $self->{group}) {
			$gid = $gidcache->lookup($self->{group}, $gid);
		}
		chown $uid, $gid, $name;
	}
	if (defined $self->{mode}) {
		my $v = $self->{mode};
		if ($v =~ m/^\d+$/o) {
			chmod oct($v), $name;
		} else {
			$state->system(OpenBSD::Paths->chmod, 
			    $self->{mode}, $name);
		}
	}
	if (defined $self->{ts}) {
		utime $self->{ts}, $self->{ts}, $name;
	}
}

package OpenBSD::PackingElement::Meta;

# XXX stuff that's invisible to find_extractible should be considered extracted
# for the most part, otherwise we create broken partial packages
sub find_extractible
{
	my ($self, $state, $wanted, $tied) = @@_;
	$state->{partial}{$self} = 1;
}

package OpenBSD::PackingElement::ExtraInfo;
use OpenBSD::Error;

sub prepare_for_addition
{
	my ($self, $state, $pkgname) = @@_;

	if ($state->{cdrom_only} && $self->{cdrom} ne 'yes') {
	    $state->errsay("Package #1 is not for cdrom", $pkgname);
	    $state->{problems}++;
	}
	if ($state->{ftp_only} && $self->{ftp} ne 'yes') {
	    $state->errsay("Package #1 is not for ftp", $pkgname);
	    $state->{problems}++;
	}
}

package OpenBSD::PackingElement::NewAuth;
use OpenBSD::Error;

sub add_entry
{
	shift;	# get rid of self
	my $l = shift;
	while (@@_ >= 2) {
		my $f = shift;
		my $v = shift;
		next if !defined $v or $v eq '';
		if ($v =~ m/^\!(.*)$/o) {
			push(@@$l, $f, $1);
		} else {
			push(@@$l, $f, $v);
		}
	}
}

sub prepare_for_addition
{
	my ($self, $state, $pkgname) = @@_;
	my $ok = $self->check;
	if (defined $ok) {
		if ($ok == 0) {
			$state->errsay("#1 #2 does not match",
			    $self->type, $self->name);
			$state->{problems}++;
		}
	}
	$self->{okay} = $ok;
}

sub install
{
	my ($self, $state) = @@_;
	$self->SUPER::install($state);
	my $auth = $self->name;
	$state->say("adding #1 #2", $self->type, $auth) if $state->verbose >= 2;
	return if $state->{not};
	return if defined $self->{okay};
	my $l=[];
	push(@@$l, "-v") if $state->verbose >= 2;
	$self->build_args($l);
	$state->vsystem($self->command,, @@$l, '--', $auth);
}

package OpenBSD::PackingElement::NewUser;

sub command 	{ OpenBSD::Paths->useradd }

sub build_args
{
	my ($self, $l) = @@_;

	$self->add_entry($l,
	    '-u', $self->{uid},
	    '-g', $self->{group},
	    '-L', $self->{class},
	    '-c', $self->{comment},
	    '-d', $self->{home},
	    '-s', $self->{shell});
}

package OpenBSD::PackingElement::NewGroup;

sub command { OpenBSD::Paths->groupadd }

sub build_args
{
	my ($self, $l) = @@_;

	$self->add_entry($l, '-g', $self->{gid});
}

package OpenBSD::PackingElement::FileBase;
use OpenBSD::Error;
use File::Basename;
use File::Path;
use OpenBSD::Temp;

sub find_extractible
{
	my ($self, $state, $wanted, $tied) = @@_;
	if ($self->{tieto} || $self->{link} || $self->{symlink}) {
		$tied->{$self->name} = $self;
	} else {
		$wanted->{$self->name} = $self;
	}
}

sub prepare_for_addition
{
	my ($self, $state, $pkgname) = @@_;
	my $fname = $state->{destdir}.$self->fullname;
	# check for collisions with existing stuff
	if ($state->vstat->exists($fname)) {
		push(@@{$state->{colliding}}, $self);
		$self->{newly_found} = $pkgname;
		$state->{problems}++;
		return;
	}
	my $s = $state->vstat->add($fname, $self->{tieto} ? 0 : $self->{size},
	    $pkgname);
	return unless defined $s;
	if ($s->ro) {
		$s->report_ro($state, $fname);
	}
	if ($s->avail < 0) {
		$s->report_overflow($state, $fname);
	}
}

sub prepare_to_extract
{
	my ($self, $state, $file) = @@_;
	my $fullname = $self->fullname;
	my $destdir = $state->{destdir};

	$file->{cwd} = $self->cwd;
	if (!$file->validate_meta($self)) {
		$state->fatal("can't continue");
	}

	$file->set_name($fullname);
	$file->{destdir} = $destdir;
}

sub create_temp
{
	my ($self, $d, $state, $fullname) = @@_;
	if (!-e _) {
		$state->make_path($d, $fullname);
	}
	my ($fh, $tempname) = OpenBSD::Temp::permanent_file($d, "pkg");
	$self->{tempname} = $tempname;
	if (!defined $tempname) {
		if ($state->allow_nonroot($fullname)) {
			$state->errsay("Can't create temp file outside localbase for #1", $fullname);
			return undef;
		}
		$state->fatal("create temporary file in #1: #2", $d, $!);
	}
	return ($fh, $tempname);
}

sub tie
{
	my ($self, $state) = @@_;
	if (defined $self->{link} || defined $self->{symlink}) {
		return;
	}

	$self->SUPER::extract($state);

	# figure out a safe directory where to put the temp file
	my $d = dirname($state->{destdir}.$self->fullname);
	# we go back up until we find an existing directory.
	# hopefully this will be on the same file system.
	while (!-d $d && -e _) {
		$d = dirname($d);
	}
	if ($state->{not}) {
		$state->say("link #1 -> #2", 
		    $self->name, $d) if $state->verbose >= 3;
	} else {
		my ($fh, $tempname) = $self->create_temp($d, $state, 
		    $self->fullname);

		return if !defined $tempname;
		my $src = $self->{tieto}->realname($state);
		unlink($tempname);
		$state->say("link #1 -> #2", $src, $tempname)
		    if $state->verbose >= 3;
		link($src, $tempname) || $state->copy_file($src, $tempname);
	}
}

sub extract
{
	my ($self, $state, $file) = @@_;

	$self->SUPER::extract($state);

	# figure out a safe directory where to put the temp file
	my $d = dirname($file->{destdir}.$file->name);
	# we go back up until we find an existing directory.
	# hopefully this will be on the same file system.
	while (!-d $d && -e _) {
		$d = dirname($d);
	}
	if ($state->{not}) {
		$state->say("extract #1 -> #2", 
		    $self->name, $d) if $state->verbose >= 3;
		$state->{archive}->skip;
	} else {
		my ($fh, $tempname) = $self->create_temp($d, $state, 
		    $file->name);
		if (!defined $tempname) {
			$state->{archive}->skip;
			return;
		}

		# XXX don't apply destdir twice
		$file->{destdir} = '';
		$file->set_name($tempname);

		$state->say("extract #1 -> #2", $self->name, $tempname) 
		    if $state->verbose >= 3;


		if (!$file->isFile) {
			$state->fatal("can't extract #1, it's not a file", 
			    $self->stringize);
		}
		$file->create;
		$self->may_check_digest($file, $state);
	}
}

sub install
{
	my ($self, $state) = @@_;
	$self->SUPER::install($state);
	my $fullname = $self->fullname;
	my $destdir = $state->{destdir};
	if ($fullname =~ m,^$state->{localbase}/share/doc/pkg-readmes/,) {
		$state->{readmes}++;
	}

	if ($state->{not}) {
		$state->say("moving tempfile -> #1",
		    $destdir.$fullname) if $state->verbose >= 5;
		return;
	}
	$state->make_path(dirname($destdir.$fullname), $fullname);
	if (defined $self->{link}) {
		link($destdir.$self->{link}, $destdir.$fullname);
	} elsif (defined $self->{symlink}) {
		symlink($self->{symlink}, $destdir.$fullname);
	} else {
		if (!defined $self->{tempname}) {
			return if $state->allow_nonroot($fullname);
			$state->fatal("No tempname for #1", $fullname);
		}
		rename($self->{tempname}, $destdir.$fullname) or
		    $state->fatal("can't move #1 to #2: #3",
			$self->{tempname}, $fullname, $!);
		$state->say("moving #1 -> #2",
		    $self->{tempname}, $destdir.$fullname)
			if $state->verbose >= 5;
		delete $self->{tempname};
	}
	$self->set_modes($state, $destdir.$fullname);
}

package OpenBSD::PackingElement::RcScript;
sub install
{
	my ($self, $state) = @@_;
	$state->{add_rcscripts}{$self->fullname} = 1;
	$self->SUPER::install($state);
}

package OpenBSD::PackingElement::Sample;
use OpenBSD::Error;
use File::Copy;

sub prepare_for_addition
{
	my ($self, $state, $pkgname) = @@_;
	if (!defined $self->{copyfrom}) {
		$state->errsay("\@@sample element #1 does not reference a valid file",
		    $self->fullname);
		$state->{problems}++;
	}
	my $fname = $state->{destdir}.$self->fullname;
	# If file already exists, we won't change it
	if ($state->vstat->exists($fname)) {
		return;
	}
	my $size = $self->{copyfrom}->{size};
	my $s = $state->vstat->add($fname, $size, $pkgname);
	return unless defined $s;
	if ($s->ro) {
		$s->report_ro($state, $fname);
	}
	if ($s->avail < 0) {
		$s->report_overflow($state, $fname);
	}
}

sub find_extractible
{
}

sub extract
{
}

sub install
{
	my ($self, $state) = @@_;

	$self->SUPER::install($state);
	my $destdir = $state->{destdir};
	my $filename = $destdir.$self->fullname;
	my $orig = $self->{copyfrom};
	my $origname = $destdir.$orig->fullname;
	if (-e $filename) {
		if ($state->verbose) {
		    $state->say("The existing file #1 has NOT been changed",
		    	$filename);
		    if (defined $orig->{d}) {

			# XXX assume this would be the same type of file
			my $d = $self->compute_digest($filename, $orig->{d});
			if ($d->equals($orig->{d})) {
			    $state->say("(but it seems to match the sample file #1)", $origname);
			} else {
			    $state->say("It does NOT match the sample file #1",
				$origname);
			    $state->say("You may wish to update it manually");
			}
		    }
		}
	} else {
		if ($state->{not}) {
			$state->say("The file #1 would be installed from #2",
			    $filename, $origname) if $state->verbose >= 2;
		} else {
			if (!copy($origname, $filename)) {
				$state->errsay("File #1 could not be installed:\n\t#2", $filename, $!);
			}
			$self->set_modes($state, $filename);
			if ($state->verbose >= 2) {
			    $state->say("installed #1 from #2",
				$filename, $origname);
			}
		}
	}
}

package OpenBSD::PackingElement::Sampledir;
sub extract
{
}

sub install
{
	&OpenBSD::PackingElement::Dir::install;
}

package OpenBSD::PackingElement::Mandir;

sub install
{
	my ($self, $state) = @@_;
	$self->SUPER::install($state);
	if (!$state->{current_set}{known_mandirs}{$self->fullname}) {
		$state->log("You may wish to add #1 to /etc/man.conf", 
		    $self->fullname);
	}
}

package OpenBSD::PackingElement::Manpage;

sub install
{
	my ($self, $state) = @@_;
	$self->SUPER::install($state);
	$self->register_manpage($state, 'addman');
}

package OpenBSD::PackingElement::InfoFile;
use File::Basename;
use OpenBSD::Error;

sub install
{
	my ($self, $state) = @@_;
	$self->SUPER::install($state);
	return if $state->{not};
	my $fullname = $state->{destdir}.$self->fullname;
	$state->vsystem(OpenBSD::Paths->install_info,
	    "--info-dir=".dirname($fullname), '--', $fullname);
}

package OpenBSD::PackingElement::Shell;
sub install
{
	my ($self, $state) = @@_;
	$self->SUPER::install($state);
	return if $state->{not};
	my $fullname = $self->fullname;
	my $destdir = $state->{destdir};
	# go append to /etc/shells if needed
	open(my $shells, '<', $destdir.OpenBSD::Paths->shells) or return;
	while(<$shells>) {
		s/^\#.*//o;
		return if m/^\Q$fullname\E\s*$/;
	}
	close($shells);
	open(my $shells2, '>>', $destdir.OpenBSD::Paths->shells) or return;
	print $shells2 $fullname, "\n";
	close $shells2;
	$state->say("Shell #1 appended to #2", $fullname,
	    $destdir.OpenBSD::Paths->shells) if $state->verbose;
}

package OpenBSD::PackingElement::Dir;
sub extract
{
	my ($self, $state) = @@_;
	my $fullname = $self->fullname;
	my $destdir = $state->{destdir};

	return if -e $destdir.$fullname;
	$self->SUPER::extract($state);
	$state->say("new directory #1", $destdir.$fullname)
	    if $state->verbose >= 3;
	return if $state->{not};
	$state->make_path($destdir.$fullname, $fullname);
}

sub install
{
	my ($self, $state) = @@_;
	$self->SUPER::install($state);
	my $fullname = $self->fullname;
	my $destdir = $state->{destdir};

	$state->say("new directory #1", $destdir.$fullname) 
	    if $state->verbose >= 5;
	return if $state->{not};
	$state->make_path($destdir.$fullname, $fullname);
	$self->set_modes($state, $destdir.$fullname);
}

package OpenBSD::PackingElement::Exec;
use OpenBSD::Error;

sub install
{
	my ($self, $state) = @@_;

	$self->SUPER::install($state);
	if ($self->should_run($state)) {
		$self->run($state);
	}
}

sub should_run() { 1 }

package OpenBSD::PackingElement::ExecAdd;
sub should_run
{
	my ($self, $state) = @@_;
	return !$state->replacing;
}

package OpenBSD::PackingElement::ExecUpdate;
sub should_run
{
	my ($self, $state) = @@_;
	return $state->replacing;
}

package OpenBSD::PackingElement::Lib;

sub install
{
	my ($self, $state) = @@_;
	$self->SUPER::install($state);
	$self->mark_ldconfig_directory($state);
}

package OpenBSD::PackingElement::SpecialFile;
use OpenBSD::PackageInfo;
use OpenBSD::Error;

sub prepare_for_addition
{
	my ($self, $state, $pkgname) = @@_;

	my $fname = installed_info($pkgname).$self->name;
	my $cname = $self->fullname;
	my $size = $self->{size};
	if (!defined $size) {
		$size = (stat $cname)[7];
	}
	my $s = $state->vstat->add($fname, $self->{size}, $pkgname);
	return unless defined $s;
	if ($s->ro) {
		$s->report_ro($state, $fname);
	}
	if ($s->avail < 0) {
		$s->report_overflow($state, $fname);
	}
}

sub copy_info
{
	my ($self, $dest, $state) = @@_;
	require File::Copy;

	File::Copy::move($self->fullname, $dest) or
	    $state->errsay("Problem while moving #1 into #2: #3",
		$self->fullname, $dest, $!);
}

sub extract
{
	my ($self, $state) = @@_;
	$self->may_verify_digest($state);
}

sub find_extractible
{
	my ($self, $state) = @@_;
	$self->may_verify_digest($state);
}

package OpenBSD::PackingElement::FCONTENTS;
sub copy_info
{
}

package OpenBSD::PackingElement::AskUpdate;
sub prepare_for_addition
{
	my ($self, $state, $pkgname, $set) = @@_;
	my @@old = $set->older_names;
	if ($self->spec->match_ref(\@@old) > 0) {
		my $key = "update_".OpenBSD::PackageName::splitstem($pkgname);
		return if $state->defines($key);
		if ($state->is_interactive) {
			if ($state->confirm($pkgname.":".$self->{message}."\n".
			    "Do you want to update now", 0)) {
			    	return;
			}
		} else {
			$state->errsay("Can't update #1 now: #2",
			    $pkgname, $self->{message});
		}
		$state->{problems}++;
	}
}

package OpenBSD::PackingElement::FDISPLAY;
sub install
{
	my ($self, $state) = @@_;
	my $d = $self->{d};
	if (!$state->{current_set}{known_displays}{$self->{d}->key}) {
		$self->prepare($state);
	}
	$self->SUPER::install($state);
}

package OpenBSD::PackingElement::FUNDISPLAY;
sub find_extractible
{
	my ($self, $state, $wanted, $tied) = @@_;
	$state->{current_set}{known_displays}{$self->{d}->key} = 1;
	$self->SUPER::find_extractible($state, $wanted, $tied);
}

1;
@


1.172
log
@in case we run delete_first (not enough room), delay the unlink of
tied items so we can still skip extracting them.

better than the stopgap measure I committed a few weeks ago.
@
text
@d2 1
a2 1
# $OpenBSD: Add.pm,v 1.171 2016/08/12 11:17:37 espie Exp $
a385 26
}

package OpenBSD::PackingElement::Sysctl;
use OpenBSD::Error;

sub install
{
	my ($self, $state) = @@_;

	my $name = $self->name;
	$self->SUPER::install($state);
	open(my $pipe, '-|', OpenBSD::Paths->sysctl, '-n', '--', $name);
	my $actual = <$pipe>;
	chomp $actual;
	if ($self->{mode} eq '=' && $actual eq $self->{value}) {
		return;
	}
	if ($self->{mode} eq '>=' && $actual >= $self->{value}) {
		return;
	}
	if ($state->{not}) {
		$state->say("sysctl -w #1 =! #2",
		    $name, $self->{value}) if $state->verbose >= 2;
		return;
	}
	$state->vsystem(OpenBSD::Paths->sysctl, '--', $name.'='.$self->{value});
@


1.171
log
@band-aid for a nasty bug. tieto + space constraints don't interact well.
there are better fixes (such as computing tieto first, computing the size
better, and doing two passes deletes), but at least this one doesn't fuck
things up.
@
text
@d2 1
a2 1
# $OpenBSD: Add.pm,v 1.170 2016/04/02 12:18:44 espie Exp $
d423 1
a423 2
	if ($self->{tieto} && !$state->{delete_first} 
	    || $self->{link} || $self->{symlink}) {
@


1.170
log
@streamline the code that checks meta information before extracting files
- verify_modes should only verify modes
- put the whole checking code in one single routine in validate_meta, makes
the size checking code more obvious
- document what's going on
- prevent PkgCreate from creating impossible packages, only a few Ustar
objects are actually usable.
@
text
@d2 1
a2 1
# $OpenBSD: Add.pm,v 1.169 2015/05/25 07:20:31 espie Exp $
d423 2
a424 1
	if ($self->{tieto} || $self->{link} || $self->{symlink}) {
@


1.169
log
@allow pkg_add as nonroot to soft-fail when outside of local base.
@
text
@d2 1
a2 1
# $OpenBSD: Add.pm,v 1.168 2015/05/18 18:25:13 espie Exp $
d459 1
a459 21
	if (defined $self->{symlink} || $file->isSymLink) {
		unless (defined $self->{symlink} && $file->isSymLink) {
			$state->fatal("bogus symlink #1", $self->name);
		}
		if (!$file->check_linkname($self->{symlink})) {
			$state->fatal("archive symlink does not match #1 != #2",
			    $file->{linkname}, $self->{symlink});
		}
	} elsif (defined $self->{link} || $file->isHardLink) {
		unless (defined $self->{link} && $file->isHardLink) {
			$state->fatal("bogus hardlink #1", $self->name);
		}
		if (!$file->check_linkname($self->{link})) {
			$state->fatal("archive hardlink does not match #1 != #2",
			    $file->{linkname}, $self->{link});
		}
	} elsif (!$file->isFile) {
		$state->fatal("archive content for #1 should be file", 
		    $self->name);
	}
	if (!$file->verify_modes($self)) {
@


1.168
log
@identical common code -> refactor
@
text
@d2 1
a2 1
# $OpenBSD: Add.pm,v 1.167 2015/05/18 18:17:27 espie Exp $
d491 1
a491 1
		File::Path::mkpath($d);
d494 1
d496 5
a500 2
		$state->fatal("create temporary file in #1: #2",
		    $d, $!);
a501 1
	$self->{tempname} = $tempname;
d528 1
d557 4
d594 1
a594 1
	File::Path::mkpath(dirname($destdir.$fullname));
d600 4
d781 1
a781 1
	File::Path::mkpath($destdir.$fullname);
d794 1
a794 1
	File::Path::mkpath($destdir.$fullname);
@


1.167
log
@better error in case we can't create tempfiles
@
text
@d2 1
a2 1
# $OpenBSD: Add.pm,v 1.166 2015/05/18 10:41:19 espie Exp $
d487 15
d522 2
a523 9
		if (!-e _) {
			File::Path::mkpath($d);
		}
		my ($fh, $tempname) = OpenBSD::Temp::permanent_file($d, "pkg");
		if (!defined $tempname) {
			$state->fatal("create temporary file in #1: #2",
			    $d, $!);
		}
		$self->{tempname} = $tempname;
d551 2
a552 9
		if (!-e _) {
			File::Path::mkpath($d);
		}
		my ($fh, $tempname) = OpenBSD::Temp::permanent_file($d, "pkg");
		if (!defined $tempname) {
			$state->fatal("create temporary file in #1: #2",
			    $d, $!);
		}
		$self->{tempname} = $tempname;
@


1.166
log
@simplify progressmeter calls to visit_and: we retrieve the state from the
progressmeter object
@
text
@d2 1
a2 1
# $OpenBSD: Add.pm,v 1.165 2015/03/29 09:42:58 espie Exp $
d511 4
d547 4
@


1.165
log
@make sure specialfiles get checked. Actual bug, got lost when moving to
extractible/tied files.

Could have been mentioned earlier, the fix is obvious.
@
text
@d2 1
a2 1
# $OpenBSD: Add.pm,v 1.164 2014/11/30 15:53:26 espie Exp $
d104 1
a104 1
	$state->progress->visit_with_size($handle->{plist}, 'install', $state);
@


1.164
log
@missed some.
@
text
@d2 1
a2 1
# $OpenBSD: Add.pm,v 1.163 2014/11/25 14:16:15 espie Exp $
d850 6
@


1.163
log
@minor clean-up: the stuff not to display is tied to the set, so make the
current_set more explicit in the PkgAdd algorithm...
and clean it up when we clean the set.

Put the "tieing files" stuff into its own function so that the add code
looks a bit less like a spaghetti monster
@
text
@d2 1
a2 1
# $OpenBSD: Add.pm,v 1.162 2014/11/21 15:07:09 espie Exp $
d868 1
a868 1
		if ($state->{interactive}) {
@


1.162
log
@a long time ago, DISPLAY and UNDISPLAY required special treatment, as they
were displayed "on the fly". But prepare+log means the display happens later
in any case, so they can be done as part of regular plist.

Also, mark known manpage dirs for even more verbiage reduction...
@
text
@d2 1
a2 1
# $OpenBSD: Add.pm,v 1.161 2014/07/12 19:50:43 espie Exp $
d697 1
a697 1
	if (!$state->{knownmandirs}{$self->fullname}) {
d886 1
a886 1
	if (!$state->{known_displays}{$self->{d}->key}) {
d896 1
a896 1
	$state->{known_displays}{$self->{d}->key} = 1;
@


1.161
log
@finish killing old experiment, less confusing code
@
text
@d2 1
a2 1
# $OpenBSD: Add.pm,v 1.160 2014/07/11 12:49:20 espie Exp $
d697 4
a700 1
	$state->log("You may wish to add #1 to /etc/man.conf", $self->fullname);
d879 19
@


1.160
log
@with out-of-order extraction, match tempnames to item names
@
text
@d2 1
a2 1
# $OpenBSD: Add.pm,v 1.159 2014/07/10 10:32:01 espie Exp $
a484 4
	# faked installation are VERY weird
	if (defined $self->{symlink} && $state->{do_faked}) {
		$file->{linkname} = $destdir.$file->{linkname};
	}
a808 1
	return if $state->{do_faked};
@


1.159
log
@add a separate timestamp annotation to have this as metadata
@
text
@d2 1
a2 1
# $OpenBSD: Add.pm,v 1.158 2014/07/07 16:45:03 espie Exp $
d508 2
a509 2
		$state->say("extracting tempfile under #1", $d)
		    if $state->verbose >= 3;
d519 1
a519 1
		$state->say("linking #1 to #2", $src, $tempname)
d539 2
a540 2
		$state->say("extracting tempfile under #1", $d)
		    if $state->verbose >= 3;
d553 2
a554 1
		$state->say("extracting #1", $tempname) if $state->verbose >= 3;
@


1.158
log
@record how many bytes we saved for statistics purposes.
exit the loop thru the same end code every time for consistency.
@
text
@d2 1
a2 1
# $OpenBSD: Add.pm,v 1.157 2014/07/01 09:22:40 espie Exp $
d280 3
@


1.157
log
@turn out-of-order extraction back on.
- separate extraction into extract/tie methods, with slightly overlapping code
- early exit when we only have tied entries
- mark location as early_exit in that case, since we're gonna close the archive
early
@
text
@d2 1
a2 1
# $OpenBSD: Add.pm,v 1.156 2014/06/25 10:52:21 espie Exp $
d131 1
a131 1
			return;
d156 1
@


1.156
log
@revert for now. Some aspects of tied code are currently broken in a fun
way. surprised nobody noticed...
@
text
@d2 1
a2 1
# $OpenBSD: Add.pm,v 1.155 2014/06/17 13:35:06 espie Exp $
d105 5
a109 1
	$handle->{location}->finish_and_close;
d120 36
a155 1
	$state->progress->visit_with_size($handle->{plist}, 'extract', $state);
d223 4
d282 10
d416 10
d450 1
a450 1
	my ($self, $state) = @@_;
a453 4
	my $file=$state->{archive}->next;
	if (!defined $file) {
		$state->fatal("truncated archive");
	}
a454 4
	if (!$file->check_name($self)) {
		$state->fatal("archive does not match #1 != #2",
		    $file->name, $self->name);
	}
a484 1
	return $file;
d487 1
a487 1
sub extract
d490 3
d494 1
a494 1
	my $file = $self->prepare_to_extract($state);
d496 22
a517 3
	if (defined $self->{link} || defined $self->{symlink}) {
		$state->{archive}->skip;
		return;
d519 5
d549 1
a549 15
		if ($self->{tieto}) {
			my $src = $self->{tieto}->realname($state);
			unlink($tempname);
			$state->say("linking #1 to #2", $src, $tempname)
			    if $state->verbose >= 3;
			if (link($src, $tempname) ||
			    $state->copy_file($src, $tempname)) {
				# we still need to adjust properties
				$file->set_modes;
				$state->{archive}->skip;
				return;
			}
			# okay, it didn't work. recreate tempname.
			open $fh, ">", $tempname;
		}
a550 1
		$state->say("extracting #1", $tempname) if $state->verbose >= 3;
d627 4
@


1.155
log
@oops, committed debug version, to the tied hash was not used at all,
and of course there were 3 obvious errors...

fixed and retested. much better now
@
text
@d2 1
a2 1
# $OpenBSD: Add.pm,v 1.154 2014/06/16 09:02:07 espie Exp $
d116 1
a116 29
	my ($wanted, $tied) = ({}, {});
	$handle->{plist}->find_extractible($state, $wanted, $tied);
	my $p = $state->progress->new_sizer($handle->{plist}, $state);
	while (my $file = $state->{archive}->next) {
		my $e = $tied->{$file->name};
		if (defined $e) {
			delete $tied->{$file->name};
			$e->prepare_to_extract($state, $file);
			$state->{archive}->skip;
			$p->advance($e);
			# skip to next;
			next;
		}
		$e = $wanted->{$file->name};
		if (!defined $e) {
			$state->fatal("archive member not found #1",
			    $file->name);
		}
		delete $wanted->{$file->name};
		$e->prepare_to_extract($state, $file);
		$e->extract($state, $file);
		$p->advance($e);
		if (keys %$wanted == 0) {
			return;
		}
	}
	if (keys %$wanted > 0) {
		$state->fatal("Truncated archive");
	}
a183 4
sub find_extractible
{
}

a238 10
package OpenBSD::PackingElement::Meta;

# XXX stuff that's invisible to find_extractible should be considered extracted
# for the most part, otherwise we create broken partial packages
sub find_extractible
{
	my ($self, $state, $wanted, $tied) = @@_;
	$state->{partial}{$self} = 1;
}

a362 10
sub find_extractible
{
	my ($self, $state, $wanted, $tied) = @@_;
	if ($self->{tied} || $self->{link} || $self->{symlink}) {
		$tied->{$self->name} = $self;
	} else {
		$wanted->{$self->name} = $self;
	}
}

d387 1
a387 1
	my ($self, $state, $file) = @@_;
d391 4
d396 4
d430 1
d435 3
a437 1
	my ($self, $state, $file) = @@_;
a485 1

a560 4
}

sub find_extractible
{
@


1.154
log
@tweak extraction for out-of-order archives: do a first pass
where we register every actual file in the plist by its path relative
to cwd.  Note every meta info as extracted (for partial packages to make
sense), then do a newer extract loop, where each archive member must match
by path.

That way, we can close archives early as soon as we've extracted every
new file.  To be used shortly by pkg_create. Note that new packages *won't*
be extractible by the old tools.
@
text
@d2 1
a2 1
# $OpenBSD: Add.pm,v 1.153 2014/05/20 05:55:43 espie Exp $
d116 1
a116 1
	my ($wanted, $tied) = {};
d127 1
d131 1
a131 1
			$state->Fatal("archive member not found #1",
a407 2
	$wanted->{$self->name} = $self;
	return;
@


1.153
log
@yet more code that no longer makes any sense
@
text
@d2 1
a2 1
# $OpenBSD: Add.pm,v 1.152 2014/05/20 05:46:13 espie Exp $
d116 28
a143 1
	$state->progress->visit_with_size($handle->{plist}, 'extract', $state);
d211 4
d270 10
d404 12
d440 1
a440 1
	my ($self, $state) = @@_;
a443 4
	my $file=$state->{archive}->next;
	if (!defined $file) {
		$state->fatal("truncated archive");
	}
a444 4
	if (!$file->check_name($self)) {
		$state->fatal("archive does not match #1 != #2",
		    $file->name, $self->name);
	}
a474 1
	return $file;
d479 1
a479 3
	my ($self, $state) = @@_;

	my $file = $self->prepare_to_extract($state);
d528 1
d604 4
@


1.152
log
@makewhatis being now external, it no longer requires picky/test/check_dir.
It also can't handle too many manpages at once (shell limit) so hand-feed
it (problem spotted by landry@@).

Some tests by schwarze@@.
@
text
@d2 1
a2 1
# $OpenBSD: Add.pm,v 1.151 2014/04/18 10:00:48 schwarze Exp $
a34 2
	my $v = $state->{v};
	$state->{v} = $state->verbose >= 2;
a43 1
	$state->{v} = $v;
@


1.151
log
@Switch to the new makewhatis(8)/apropos(1)/whatis(1) combo.
"commit the switch now" espie@@  "go for it" deraadt@@

See the apropos(1) manual for a description of what's new.
On machines where you want the full functionality,
run "sudo makewhatis" and put "MAKEWHATISARGS=' '" into weekly.local(8).
Otherwise, when upgrading via source, run "sudo makewhatis -Q".
@
text
@d2 1
a2 1
# $OpenBSD: Add.pm,v 1.150 2014/03/18 18:53:29 espie Exp $
d43 1
a43 2
			$state->vsystem(OpenBSD::Paths->makewhatis,
			    '-d', $destdir.$k, '--', @@l);
@


1.150
log
@remove $_ usage that warns under perl 5.18
@
text
@d2 1
a2 1
# $OpenBSD: Add.pm,v 1.149 2014/02/10 19:16:19 espie Exp $
a32 1
	require OpenBSD::Makewhatis;
d43 2
a44 7
			eval {
				OpenBSD::Makewhatis::merge($destdir.$k, \@@l,
				    $state);
			};
			if ($@@) {
				$state->errsay("Error in makewhatis: #1", $_);
			};
@


1.149
log
@assume tweaking package status always work if $state->{not}.
Problem noticed by Mikolaj Kucharski
@
text
@d2 1
a2 1
# $OpenBSD: Add.pm,v 1.148 2014/02/08 10:43:25 espie Exp $
a671 1
	my $_;
d674 1
a674 1
		return if $_ =~ m/^\Q$fullname\E\s*$/;
@


1.148
log
@fudge verbose state so that makewhatis is only verbose if pkg_add/delete -vv
or more.
@
text
@d2 1
a2 1
# $OpenBSD: Add.pm,v 1.147 2014/02/03 16:13:13 espie Exp $
d146 1
@


1.147
log
@gc old stuff that never fixed the problem it intended to fix :(
@
text
@d2 1
a2 1
# $OpenBSD: Add.pm,v 1.146 2014/02/03 15:57:13 espie Exp $
d35 3
d42 1
a42 2
			    $destdir.$k, join(' ', @@l))
				if $state->verbose >= 2;
d44 1
a44 1
			try {
d47 2
a48 1
			} catchall {
d53 1
@


1.146
log
@store compact form of manpages.

fix a long standing stupid bug: can't store both deleted and added manpages in
the same hash, otherwise the first deletion is going to scrape already added
stuff. Ouchie.
@
text
@d2 1
a2 1
# $OpenBSD: Add.pm,v 1.145 2014/01/31 10:29:54 espie Exp $
a361 8
package OpenBSD::PackingElement::DirBase;
sub prepare_for_addition
{
	my ($self, $state, $pkgname) = @@_;
	return unless $self->{noshadow};
	$state->{noshadow}{$state->{destdir}.$self->fullname} = 1;
}

d455 1
a455 1
	while (!-d $d && -e _ || defined $state->{noshadow}{$d}) {
@


1.145
log
@minor fix: don't go to cache if genuine install
@
text
@d2 1
a2 1
# $OpenBSD: Add.pm,v 1.144 2014/01/30 13:12:50 espie Exp $
d31 1
a31 1
	return unless defined $state->{mandirs};
d35 2
a36 2
	while (my ($k, $v) = each %{$state->{mandirs}}) {
		my @@l = map { $destdir.$_ } @@$v;
d50 1
d367 1
a367 1
	$state->{noshadow}->{$state->{destdir}.$self->fullname} = 1;
d463 1
a463 1
	while (!-d $d && -e _ || defined $state->{noshadow}->{$d}) {
d648 1
a648 1
	$self->register_manpage($state);
@


1.144
log
@minor bug-fix, make sure partial is handled properly.
also use delete instead of undef so that they entry vanishes...
@
text
@d2 1
a2 1
# $OpenBSD: Add.pm,v 1.143 2014/01/17 15:54:06 espie Exp $
d55 9
a63 6
	return if $state->{not};
	my $dest = installed_info($plist->pkgname);
	mkdir($dest);
	$plist->copy_info($dest, $state);
	$plist->set_infodir($dest);
	$plist->to_installation;
@


1.143
log
@do check_digest per plist.
show UNSIGNED packages unconditionally.
@
text
@d2 1
a2 1
# $OpenBSD: Add.pm,v 1.142 2014/01/11 11:54:43 espie Exp $
d94 1
a94 1
			undef $last->{d};
d105 1
d188 1
a188 1
	$state->{partial}->{$self} = 1;
d197 3
a199 1
	$state->{partial}->{$self} = 1;
d531 1
a531 1
		undef $self->{tempname};
@


1.142
log
@simplify code: always extract, then install, so that initial installations
and updates are more similar.
@
text
@d2 1
a2 1
# $OpenBSD: Add.pm,v 1.141 2014/01/11 11:51:01 espie Exp $
d116 1
@


1.141
log
@a bit of spring cleanup in advance: scrape old stuff that's not really
used.
@
text
@d2 1
a2 1
# $OpenBSD: Add.pm,v 1.140 2014/01/09 20:20:01 espie Exp $
a104 3
	$state->{archive} = $handle->{location};
	$handle->{partial} //= {};
	$state->{partial} = $handle->{partial};
d109 10
d183 9
d195 1
a198 1
	$state->{partial}->{$self} = 1;
d366 1
a389 46
sub install
{
	my ($self, $state) = @@_;
	$self->SUPER::install($state);
	my $fullname = $self->fullname;
	my $destdir = $state->{destdir};
	if ($fullname =~ m,^$state->{localbase}/share/doc/pkg-readmes/,) {
		$state->{readmes}++;
	}

	if ($state->{extracted_first}) {
		if ($state->{not}) {
			$state->say("moving tempfile -> #1",
			    $destdir.$fullname) if $state->verbose >= 5;
			return;
		}
		File::Path::mkpath(dirname($destdir.$fullname));
		if (defined $self->{link}) {
			link($destdir.$self->{link}, $destdir.$fullname);
		} elsif (defined $self->{symlink}) {
			symlink($self->{symlink}, $destdir.$fullname);
		} else {
			rename($self->{tempname}, $destdir.$fullname) or
			    $state->fatal("can't move #1 to #2: #3",
			    	$self->{tempname}, $fullname, $!);
			$state->say("moving #1 -> #2",
			    $self->{tempname}, $destdir.$fullname)
			    	if $state->verbose >= 5;
			undef $self->{tempname};
		}
	} else {
		my $file = $self->prepare_to_extract($state);
		$state->say("extracting #1", $destdir.$fullname)
		    if $state->verbose >= 5;
		if ($state->{not}) {
			$state->{archive}->skip;
			return;
		} else {
			$file->create;
			$self->may_check_digest($file, $state);

		}
	}
	$self->set_modes($state, $destdir.$fullname);
}

d438 94
d568 4
d616 3
d681 14
d702 2
a703 1
	$state->say("new directory #1", $destdir.$fullname) if $state->verbose >= 5;
d782 1
a782 1
sub install
d785 1
a785 3
	if (!$state->{extracted_first}) {
		$self->may_verify_digest($state);
	}
@


1.140
log
@bump copyright to 2014
@
text
@d2 1
a2 1
# $OpenBSD: Add.pm,v 1.139 2014/01/07 17:33:53 espie Exp $
a105 1
	$state->{end_faked} = 0;
a472 9
}

package OpenBSD::PackingElement::EndFake;
sub install
{
	my ($self, $state) = @@_;

	$self->SUPER::install($state);
	$state->{end_faked} = 1;
@


1.139
log
@even if Ustar handles fifo and stuff gracefully, pkg contents should be more
limited...
@
text
@d2 1
a2 1
# $OpenBSD: Add.pm,v 1.138 2014/01/07 13:31:35 espie Exp $
d4 1
a4 1
# Copyright (c) 2003-2007 Marc Espie <espie@@openbsd.org>
@


1.138
log
@tedu some very old checks: we no longer have INSTALL/UNINSTALL scripts,
so we don't care whether /var/db/pkg is mounted noexec.
@
text
@d2 1
a2 1
# $OpenBSD: Add.pm,v 1.137 2014/01/07 13:26:17 espie Exp $
a405 1

d451 3
@


1.137
log
@let's verify all checksums.
I forgot about special files, since they've been extracted early,
but they can be checked nonetheless.

(prevents people from tampering with DESC and the like)
@
text
@d2 1
a2 1
# $OpenBSD: Add.pm,v 1.136 2014/01/07 10:22:05 espie Exp $
a682 6
	if ($self->exec_on_add) {
		my $s2 = $state->vstat->stat($cname);
		if (defined $s2 && $s2->noexec) {
			$s2->report_noexec($state, $cname);
		}
	}
a686 3
	}
	if ($s->noexec && $self->exec_on_delete) {
		$s->report_noexec($state, $fname);
@


1.136
log
@simplify set_modes, there's no need to stat(2) stuff, chown -1 takes care
of things.
@
text
@d2 1
a2 1
# $OpenBSD: Add.pm,v 1.135 2014/01/05 10:24:30 espie Exp $
d710 8
@


1.135
log
@have -DFW_UPDATE set @@option firmware on downloaded firmwares.
- normal pkg_add -u should ignore them
- pkg_delete will ask about deleting them

okay landry@@
@
text
@d2 1
a2 1
# $OpenBSD: Add.pm,v 1.134 2013/12/30 09:02:37 espie Exp $
d201 1
a201 6
		my ($uid, $gid);
		if (-l $name) {
			($uid, $gid) = (lstat $name)[4,5];
		} else {
			($uid, $gid) = (stat $name)[4,5];
		}
d215 2
a216 1
			$state->system(OpenBSD::Paths->chmod, $self->{mode}, $name);
@


1.134
log
@use replacing method (and not var)
@
text
@d2 1
a2 1
# $OpenBSD: Add.pm,v 1.133 2013/02/18 20:24:11 okan Exp $
d148 4
@


1.133
log
@re-apply:
use localbase for pkg-readmes

ok espie@@
@
text
@d2 1
a2 1
# $OpenBSD: Add.pm,v 1.132 2013/02/18 19:56:10 okan Exp $
d649 1
a649 1
	return !$state->{replacing};
d656 1
a656 1
	return $state->{replacing};
@


1.132
log
@revert previous; wrong time.
@
text
@d2 1
a2 1
# $OpenBSD: Add.pm,v 1.131 2013/02/18 19:29:03 okan Exp $
d380 1
a380 1
	if ($fullname =~ m,^/usr/local/share/doc/pkg-readmes/,) {
@


1.131
log
@use localbase for pkg-readmes

ok espie@@
@
text
@d2 1
a2 1
# $OpenBSD: Add.pm,v 1.130 2012/04/28 12:00:10 espie Exp $
d380 1
a380 1
	if ($fullname =~ m,^$state->{localbase}/share/doc/pkg-readmes/,) {
@


1.130
log
@zap blank spaces
@
text
@d2 1
a2 1
# $OpenBSD$
d380 1
a380 1
	if ($fullname =~ m,^/usr/local/share/doc/pkg-readmes/,) {
@


1.129
log
@Backout activation of the new apropos(1)/whatis(1)/makewhatis(8).
In its current state, it causes too much slowdown, in particular
during system builds, and there are other regressions.
That cannot be fixed quickly while it's enabled.

Problems pointed out by espie@@, backout requested by deraadt@@,
diff "looks good" to espie@@.
@
text
@d2 1
a2 1
# $OpenBSD: Add.pm,v 1.128 2012/01/05 23:03:57 schwarze Exp $
d363 1
a363 1
	my $s = $state->vstat->add($fname, $self->{tieto} ? 0 : $self->{size}, 
d708 1
a708 1
	    $state->errsay("Problem while moving #1 into #2: #3", 
@


1.128
log
@Enable the new apropos(1), whatis(1), and makewhatis(8).
Unlink the old apropos(1), whatis(1), and makewhatis(8) from the build.
Call the new tools from pkg_create(1) and pkg_add(1).
"Please enable it now."  deraadt@@
@
text
@d2 1
a2 1
# $OpenBSD: Add.pm,v 1.127 2011/12/03 16:15:05 espie Exp $
d33 1
d42 6
a47 2
			$state->vsystem(OpenBSD::Paths->makewhatis,
			    '-d', $destdir.$k, '--', @@l);
@


1.127
log
@In a collision, retrofit storage for 2nd pkgname.
(in large updatesets, it may not be obvious where the 2nd copy comes from,
as exemplified by ajacoutot@@).
@
text
@d2 1
a2 1
# $OpenBSD: Add.pm,v 1.126 2011/09/17 15:33:56 schwarze Exp $
a32 1
	require OpenBSD::Makewhatis;
d41 2
a42 6
			try {
				OpenBSD::Makewhatis::merge($destdir.$k, \@@l,
				    $state);
			} catchall {
				$state->errsay("Error in makewhatis: #1", $_);
			};
@


1.126
log
@make pkg_add -nvv work with respect to whatis.db updates;
ok espie@@
@
text
@d2 1
a2 1
# $OpenBSD: Add.pm,v 1.125 2011/08/23 10:32:27 espie Exp $
d359 1
@


1.125
log
@zap old INSTALL/DEINSTALL stuff, it's been deprecated for 3 years, and removed
from pkg_create for over a year.
@
text
@d2 1
a2 1
# $OpenBSD: Add.pm,v 1.124 2011/07/12 10:09:52 espie Exp $
d39 2
a40 1
				$destdir.$k, join(@@l)) if $state->verbose >= 2;
d575 1
a575 1
	$self->register_manpage($state) unless $state->{not};
@


1.124
log
@tweak: need -a -a to reverse @@option manual-install
@
text
@d2 1
a2 1
# $OpenBSD: Add.pm,v 1.123 2011/06/20 09:46:22 espie Exp $
a707 7
}

package OpenBSD::PackingElement::FINSTALL;
sub install
{
	my ($self, $state) = @@_;
	$self->run($state, 'PRE-INSTALL');
@


1.123
log
@in an UpdateSet, match new files with old files based on their sha256.
avoid extracting again identical files, leading to less file system churn.
put in a few failsafes (size check) for people with fubar'd file
systems (hey oga@@).

The more often you update, the more you gain. Over 6 months, about one
out of five files doesn't change.

apparently, improves things a lot on slow fs, as said landry@@ and sthen@@.
tested by quite a few people.
@
text
@d2 1
a2 1
# $OpenBSD: Add.pm,v 1.122 2011/01/25 11:46:57 espie Exp $
d130 1
a130 1
	if ($plist->has('manual-installation') && $state->{automatic}) {
@


1.122
log
@prepend pkgname to ask-update prompt, so that user knows for sure which
package is asking.
@
text
@d2 1
a2 1
# $OpenBSD: Add.pm,v 1.121 2011/01/23 06:56:53 espie Exp $
d361 2
a362 1
	my $s = $state->vstat->add($fname, $self->{size}, $pkgname);
@


1.121
log
@hide details of "finish" inside PackingElement proper.
do the font dirs, also display a message for new installed rcscripts, and
if some stuff has been added to the readmes directory.
@
text
@d2 1
a2 1
# $OpenBSD: Add.pm,v 1.120 2011/01/21 20:37:26 espie Exp $
d730 1
a730 1
			if ($state->confirm($self->{message}."\n".
@


1.120
log
@forgot to pass this. bug-report from "Michael W. Lucas" <mwlucas@@blackhelicopters.org>
@
text
@d2 1
a2 1
# $OpenBSD: Add.pm,v 1.119 2010/12/29 13:03:05 espie Exp $
d377 3
d461 8
@


1.119
log
@more stuff that uses print directly dies
@
text
@d2 1
a2 1
# $OpenBSD: Add.pm,v 1.118 2010/12/24 09:09:54 espie Exp $
d96 1
a96 1
	register_installation($n);
@


1.118
log
@move the handling of ldconfig to AddDelete::State
actually simplifies code a great deal. It's not as if trying to avoid
loading ten lines of code is a good idea.
@
text
@d2 1
a2 1
# $OpenBSD: Add.pm,v 1.117 2010/12/24 09:04:14 espie Exp $
d53 2
a54 2
	my $plist = shift;
	return if $main::not;
d57 1
a57 1
	$plist->copy_info($dest);
d690 1
a690 1
	my ($self, $dest) = @@_;
d694 2
a695 2
		print STDERR "Problem while moving ", $self->fullname,
			" into $dest: $!\n";
@


1.117
log
@handle failures from ports tree with more care.
this does avoid infinite loops in case of wrong plists.
necessary since print-plist-with-depends CAN fail...
@
text
@d2 1
a2 1
# $OpenBSD$
d652 1
a652 1
	$self->mark_ldconfig_directory($state->{destdir});
@


1.116
log
@whitespace
@
text
@@


1.115
log
@nasty inversion of parameters, so that state did not get propagated correctly.
ended up calling './'->errsay in ArcCheck, which of course doesn't work, so
a die() in the middle of a package install... compounded with file !existing,
so that adjust checksum would fail, and so not even a partial install...
@
text
@d2 1
a2 1
# $OpenBSD: Add.pm,v 1.114 2010/07/24 10:49:01 espie Exp $
d42 1
a42 1
				OpenBSD::Makewhatis::merge($destdir.$k, \@@l, 
@


1.114
log
@pass state to Makewhatis. With new hooks in there, that means display
will integrate with pkg_add output (no more disturbed error messages
from wrong subject lines)
@
text
@d2 1
a2 1
# $OpenBSD: Add.pm,v 1.113 2010/06/30 10:51:04 espie Exp $
d83 12
a94 8
	    my $old = $last->{d};
	    my $lastname = $last->realname($state);
	    $last->{d} = $last->compute_digest($lastname, $old);
	    if (!$old->equals($last->{d})) {
		$state->say("Adjusting #1 for #2 from #3 to #4",
		    $old->keyword, $lastname, $old->stringize,
		    $last->{d}->stringize);
	    }
@


1.113
log
@allow say and errsay to work without parameters, as it's ways common.
create verbose_system up in state, because it makes sense without verbose.
@
text
@d2 1
a2 1
# $OpenBSD$
d42 2
a43 1
				OpenBSD::Makewhatis::merge($destdir.$k, \@@l);
@


1.112
log
@whitespace cleanup
@
text
@@


1.111
log
@more printing changes.

move log operations into their own file, since they're used outside of
pkg_add/pkg_delete by pkg_check.

move all system stuff to State, so that printing can be localized/controlled.
Create primitives _print, _errprint, _fatal for overriding output, without
localization.

Accordingly, move a lot of code out of Error. We should also move Unlink and
Copy eventually.
@
text
@d2 1
a2 1
# $OpenBSD: Add.pm,v 1.110 2010/06/09 07:26:01 espie Exp $
d38 1
a38 1
			$state->say("Merging manpages in #1: #2", 
d86 1
a86 1
		$state->say("Adjusting #1 for #2 from #3 to #4", 
d257 1
a257 1
			$state->errsay("#1 #2 does not match", 
d326 1
a326 1
		$state->say("sysctl -w #1 =! #2", 
d375 1
a375 1
			$state->say("moving tempfile -> #1", 
d386 1
a386 1
			    $state->fatal("can't move #1 to #2: #3", 
d388 2
a389 2
			$state->say("moving #1 -> #2", 
			    $self->{tempname}, $destdir.$fullname) 
d396 1
a396 1
		$state->say("extracting #1", $destdir.$fullname) 
d422 1
a422 1
		$state->fatal("archive does not match #1 != #2", 
d430 1
a430 1
			$state->fatal("archive symlink does not match #1 != #2", 
d438 1
a438 1
			$state->fatal("archive hardlink does not match #1 != #2", 
d512 1
a512 1
			    $state->say("It does NOT match the sample file #1", 
d520 1
a520 1
			$state->say("The file #1 would be installed from #2", 
d528 1
a528 1
			    $state->say("installed #1 from #2", 
d593 1
a593 1
	$state->say("Shell #1 appended to #2", $fullname, 
d719 1
a719 1
			$state->errsay("Can't update #1 now: #2", 
@


1.110
log
@ui changes: go thru a state object for most printouts
@
text
@d2 1
a2 1
# $OpenBSD: Add.pm,v 1.109 2010/06/04 13:19:39 espie Exp $
d182 1
a182 1
	my ($self, $name) = @@_;
d210 1
a210 1
			System(OpenBSD::Paths->chmod, $self->{mode}, $name);
d407 1
a407 1
	$self->set_modes($destdir.$fullname);
d526 1
a526 1
			$self->set_modes($filename);
d608 1
a608 1
	$self->set_modes($destdir.$fullname);
@


1.109
log
@move code around, so that commands can be used as modules.
pkg becomes the start hub, which does nothing except require the
correct module.
Saner code wrt Add/Delete, and more sharing.
@
text
@d2 1
a2 1
# $OpenBSD: Add.pm,v 1.108 2010/05/10 09:17:55 espie Exp $
d38 2
a39 1
			$state->say("Merging manpages in $destdir$k: ", join(@@l)) if $state->verbose >= 2;
d44 1
a44 1
				$state->errsay("Error in makewhatis: $_");
d86 3
a88 3
		$state->say("Adjusting ", $old->keyword,
		    " for $lastname from ", $old->stringize,
		    " to ", $last->{d}->stringize);
d223 1
a223 1
	    $state->errsay("Package $pkgname is not for cdrom.");
d227 1
a227 1
	    $state->errsay("Package $pkgname is not for ftp.");
d257 2
a258 2
			$state->errsay($self->type, " ",  $self->name,
			    " does not match");
d270 1
a270 1
	$state->say("adding ", $self->type, " ", $auth) if $state->verbose >= 2;
d326 2
a327 1
		$state->say("sysctl -w $name != ".  $self->{value}) if $state->verbose >= 2;
d375 2
a376 1
			$state->say("moving tempfile -> $destdir$fullname") if $state->verbose >= 5;
d386 5
a390 2
			    Fatal "Can't move ", $self->{tempname}, " to $fullname: $!";
			$state->say("moving ", $self->{tempname}, " -> $destdir$fullname") if $state->verbose >= 5;
d396 2
a397 1
		$state->say("extracting $destdir$fullname") if $state->verbose >= 5;
d418 1
a418 1
		Fatal "Error: truncated archive\n";
d422 2
a423 2
		Fatal "Error: archive does not match ", $file->name, "!=",
		$self->name, "\n";
d427 1
a427 1
			Fatal "Error: bogus symlink ", $self->name, "\n";
d430 2
a431 2
			Fatal "Error: archive sl does not match ", $file->{linkname}, "!=",
			$self->{symlink}, "\n";
d435 1
a435 1
			Fatal "Error: bogus hardlink ", $self->name, "\n";
d438 2
a439 2
			Fatal "Error: archive hl does not match ", $file->{linkname}, "!=",
			$self->{link}, "!!!\n";
d443 1
a443 1
		Fatal "Can't continue\n";
d472 2
a473 2
		$state->errsay("\@@sample element ",$self->fullname,
		    " does not reference a valid file");
d503 2
a504 1
		    $state->say("The existing file $filename has NOT been changed");
d510 1
a510 1
			    $state->say("(but it seems to match the sample file $origname)");
d512 2
a513 1
			    $state->say("It does NOT match the sample file $origname");
d520 2
a521 1
			$state->say("The file $filename would be installed from $origname") if $state->verbose >= 2;
d524 1
a524 1
				$state->errsay("File $filename could not be installed:\n\t$!");
d528 2
a529 1
			    $state->say("installed $filename from $origname");
d548 1
a548 1
	$state->log("You may wish to add ", $self->fullname, " to /etc/man.conf\n");
d593 2
a594 2
	$state->say("Shell $fullname appended to $destdir",
	    OpenBSD::Paths->shells) if $state->verbose;
d605 1
a605 1
	$state->say("new directory ", $destdir, $fullname) if $state->verbose >= 5;
d719 2
a720 1
			$state->errsay("Can't update $pkgname now: $self->{message}");
@


1.108
log
@whitespace fixes
@
text
@d2 1
a2 1
# $OpenBSD$
d701 1
a701 1
		return if $state->{defines}->{$key};
@


1.107
log
@new keyword, @@ask-update, to be used *very* sparingly (so far, only useful
for pgsql updates)
@
text
@d40 2
a41 2
			try { 
				OpenBSD::Makewhatis::merge($destdir.$k, \@@l); 
d76 1
a76 1
	
d85 2
a86 2
		$state->say("Adjusting ", $old->keyword, 
		    " for $lastname from ", $old->stringize, 
d256 1
a256 1
			$state->errsay($self->type, " ",  $self->name, 
d286 1
a286 1
	$self->add_entry($l, 
d330 1
a330 1
			
d382 1
a382 1
			rename($self->{tempname}, $destdir.$fullname) or 
d465 1
a465 1
		$state->errsay("\@@sample element ",$self->fullname, 
d616 2
a617 2
sub should_run 
{ 
d623 2
a624 2
sub should_run 
{ 
@


1.106
log
@clean-up validate_plists a bit, so that it starts with a clean state.
new feature: if a normal updateset order does not fit, let the user decide
to do a "dangerous update", by deleting older packages first (if they fit).
tweak really_add to do so: move delete old packages out of the way, and add
a new state variable (extracted_first) to distinguish between both replace
modes.
@
text
@d62 1
a62 1
	my ($plist, $state) = @@_;
d64 1
a64 1
	$plist->prepare_for_addition($state, $plist->pkgname);
d692 20
@


1.105
log
@clean up the ProgressMeter code, create a specific class if a Term
is around.
start using stuff from termcap, specifically, cleareol, and move to hp.
use the full line when we can, cram 100% if we can.
(this should flicker much less on slow terminals).

clean-up the install-and-progress bits to be in progressmeter, this removes
some code.

have pkg_create follow the same pattern as the others, with a state.
This allows us to unify error messages a bit.
@
text
@d371 1
a371 1
	if ($state->{replacing}) {
@


1.104
log
@fix new vstat, and make it useful, for instance for -n.
@
text
@a97 1
	my $totsize = $handle->{totsize};
a98 1
	my $donesize = 0;
d100 1
a100 3
	if (!defined $handle->{partial}) {
		$handle->{partial} = {};
	}
d102 1
a102 2
	$state->progress->show(0, $totsize);
	$handle->{plist}->install_and_progress($state, \$donesize, $totsize);
d166 1
a166 1
sub install_and_progress
d168 1
a168 8
	my ($self, $state, $donesize, $totsize) = @@_;
	$state->{callback} = sub {
		my $done = shift;
		$state->progress->show($$donesize + $done, $totsize);
	};
	unless ($state->{do_faked} && $state->{end_faked}) {
		$self->install($state);
	}
a171 6
	$self->mark_progress($state->progress, $donesize, $totsize);
}

sub install
{
	my ($self, $state) = @@_;
d395 1
a395 1
			$file->create($state->{callback});
@


1.103
log
@not a fatal error, keep going
@
text
@d372 1
a372 1
	my $s = $state->vstat->add($fname, $self->{size}, \$pkgname);
d493 1
a493 1
	my $s = $state->vstat->add($fname, $size, \$pkgname);
d677 1
a677 1
	my $s = $state->vstat->add($fname, $self->{size}, \$pkgname);
@


1.102
log
@fully encapsulate dev objects from vstat so I can change the internals
completely.
@
text
@d483 3
a485 1
		Fatal "\@@sample element does not reference a valid file\n";
@


1.101
log
@change verbosity handling: be silent by default, turn on the first level if -v.
Add more levels, specifically, lots of info regarding individual files only
visible if -vvvvv.
Make -n display the same stuff as normal (need -n -v to display more stuff).
Introduce -s, "size-only", turns on -n and does skip any extraction.
Sprinkle handlers for SIG_INFO, not really nice yet.

Note that -n is non functional for complex updates, because of caching
issues I have to fix.
@
text
@d374 1
a374 1
	if ($s->{ro}) {
d493 1
a493 1
	if ($s->{ro}) {
d671 1
a671 1
		if (defined $s2 && $s2->{noexec}) {
d677 1
a677 1
	if ($s->{ro}) {
d680 1
a680 1
	if ($s->{noexec} && $self->exec_on_delete) {
@


1.100
log
@be slightly more paranoid about shell stuff we run.
@
text
@d2 1
a2 1
# $OpenBSD: Add.pm,v 1.99 2009/12/17 11:07:24 espie Exp $
d38 1
a38 1
			$state->say("Merging manpages in $destdir$k: ", join(@@l)) if $state->{verbose};
d287 1
a287 1
	$state->say("adding ", $self->type, " ", $auth) if $state->{verbose};
d291 1
a291 1
	push(@@$l, "-v") if $state->{very_verbose};
d343 1
a343 1
		$state->say("sysctl -w $name != ".  $self->{value});
d391 1
a391 1
			$state->say("moving tempfile -> $destdir$fullname") if $state->{very_verbose};
d402 1
a402 1
			$state->say("moving ", $self->{tempname}, " -> $destdir$fullname") if $state->{very_verbose};
d408 1
a408 1
		$state->say("extracting $destdir$fullname") if $state->{very_verbose};
d511 1
a511 1
		if ($state->{verbose}) {
d527 1
a527 1
			$state->say("The file $filename would be installed from $origname");
d533 1
a533 1
			if ($state->{verbose}) {
d599 1
a599 1
	    OpenBSD::Paths->shells);
d610 1
a610 1
	$state->say("new directory ", $destdir, $fullname) if $state->{very_verbose};
@


1.99
log
@add a callback to file creation, so that we get progress meter for huge
files in packages. Should affect emacs, chrome and the likes.
@
text
@d2 1
a2 1
# $OpenBSD: Add.pm,v 1.98 2009/12/17 08:21:09 espie Exp $
d293 1
a293 1
	$state->vsystem($self->command,, @@$l, $auth);
d333 1
a333 1
	open(my $pipe, '-|', OpenBSD::Paths->sysctl, '-n', $name);
d346 1
a346 1
	$state->vsystem(OpenBSD::Paths->sysctl, $name.'='.$self->{value});
d576 1
a576 1
	    "--info-dir=".dirname($fullname), $fullname);
@


1.98
log
@display progressmeter at 0% at start of install/deinstall.
(better synch for packages that start with a huge binary)
@
text
@d2 1
a2 1
# $OpenBSD$
d174 4
d413 1
a413 1
			$file->create;
@


1.97
log
@create a pseudo vstat object inside state, so that we can modify Vstat
interface very locally...

model hints objects like Locations, to uniformize further treatment.
@
text
@d106 1
@


1.96
log
@vsystem, system, unlink can mostly go through state, and do the ->clear part
as well.
@
text
@d362 1
a362 1
	if (OpenBSD::Vstat::vexists($fname)) {
d367 1
a367 1
	my $s = OpenBSD::Vstat::add($fname, $self->{size}, \$pkgname);
d482 1
a482 1
	if (OpenBSD::Vstat::vexists($fname)) {
d486 1
a486 1
	my $s = OpenBSD::Vstat::add($fname, $size, \$pkgname);
d665 1
a665 1
		my $s2 = OpenBSD::Vstat::filestat($cname);
d670 1
a670 1
	my $s = OpenBSD::Vstat::add($fname, $self->{size}, \$pkgname);
@


1.95
log
@don't use Warn if we've got a $state, get through errprint/errsay.
Also: reset lastdisplay on clear, and don't clear twice.
@
text
@d288 1
a288 1
	VSystem($state->{very_verbose}, $self->command,, @@$l, $auth);
d341 1
a341 3
	VSystem($state->{very_verbose}, 
	    OpenBSD::Paths->sysctl, 
	    $name.'='.$self->{value});
d570 1
a570 2
	VSystem($state->{very_verbose}, 
	    OpenBSD::Paths->install_info,
@


1.94
log
@also get most STDERR messages through the same way
@
text
@d235 1
a235 1
	    Warn "Package $pkgname is not for cdrom.\n";
d239 1
a239 1
	    Warn "Package $pkgname is not for ftp.\n";
d269 2
a270 2
			Warn $self->type, " ",  $self->name, 
			    " does not match\n";
d527 1
a527 1
				Warn "File $filename could not be installed:\n\t$!\n";
@


1.93
log
@progressmeter puts STDOUT in autoflush if -t, so that it can display to it instead of piping a lot of stuff to STDERR.

Go through state->print for most messages, so they will NOT do weird things
with the progressmeter.
Use a ->say shortcut which does the same thing that perl 5.10 say does...
@
text
@d43 1
a43 1
				print STDERR "Error in makewhatis: $_\n";
@


1.92
log
@remove forwarders, and provide a sensible API that says what's going on
(e.g., we're logging information for later).
@
text
@d38 1
a38 1
			print "Merging manpages in $destdir$k: ", join(@@l), "\n" if $state->{verbose};
d85 3
a87 2
		print "Adjusting ", $old->keyword, " for $lastname from ",
		    $old->stringize, " to ", $last->{d}->stringize, "\n";
d282 1
a282 1
	print "adding ", $self->type, " $auth\n" if $state->{verbose};
d338 1
a338 2
		print "sysctl -w $name != ".
		    $self->{value}, "\n";
d388 1
a388 1
			print "moving tempfile -> $destdir$fullname\n" if $state->{very_verbose};
d399 1
a399 1
			print "moving ", $self->{tempname}, " -> $destdir$fullname\n" if $state->{very_verbose};
d405 1
a405 1
		print "extracting $destdir$fullname\n" if $state->{very_verbose};
d509 1
a509 1
		    print "The existing file $filename has NOT been changed\n";
d515 1
a515 1
			    print "(but it seems to match the sample file $origname)\n";
d517 2
a518 2
			    print "It does NOT match the sample file $origname\n";
			    print "You may wish to update it manually\n";
d524 1
a524 1
			print "The file $filename would be installed from $origname\n";
d531 1
a531 1
			    print "installed $filename from $origname\n";
d596 2
a597 2
	print "Shell $fullname appended to $destdir",
	    OpenBSD::Paths->shells, "\n";
d608 1
a608 1
	print "new directory ", $destdir, $fullname, "\n" if $state->{very_verbose};
@


1.91
log
@bad espie: use strict/warnings consistently, and fix two nits and two
actual errors !
@
text
@d550 1
a550 1
	$state->print("You may wish to add ", $self->fullname, " to /etc/man.conf\n");
@


1.90
log
@finish zapping old "kitchensink" option, we have much better ways to test
big stuff now.
@
text
@d17 1
@


1.89
log
@repair tagging of user-specified packagenames, so that manual-install actually occurs some of the time...
@
text
@a372 3
	if ($state->{defines}->{kitchensink} && $state->{not}) {
		return;
	}
a491 3
	if ($state->{defines}->{kitchensink} && $state->{not}) {
		return;
	}
a678 3
	}
	if ($state->{defines}->{kitchensink} && $state->{not}) {
		return;
@


1.88
log
@restore tagged user packages to functionality (for now)
@
text
@d152 2
a153 2
		for my $handle ($set->newer) {
			$user_tagged->{$handle->{pkgname}} = 1;
@


1.87
log
@synch with my new style search/location changes
It's likely there will be some fallout, but it's getting a bit too large
to keep around.
This does kill a few very old oddities as well.
@
text
@d151 4
a154 2
	for my $pkgname (@@_) {
		$user_tagged->{extract_pkgname($pkgname)} = 1;
@


1.86
log
@call may_check_digest after extraction
@
text
@d265 1
a265 1
			Warn $self->type, " ",  $self->{name}, 
d277 1
a277 1
	my $auth = $self->{name};
d322 1
a322 1
	my $name = $self->{name};
d430 2
a431 2
		Fatal "Error: archive does not match ", $file->{name}, "!=",
		$self->{name}, "\n";
d435 1
a435 1
			Fatal "Error: bogus symlink ", $self->{name}, "\n";
d443 1
a443 1
			Fatal "Error: bogus hardlink ", $self->{name}, "\n";
d454 1
a454 1
	$file->{name} = $fullname;
d664 1
a664 1
	my $fname = installed_info($pkgname).$self->{name};
@


1.85
log
@Say goodbye to local $_
lexical scoping is so much neater (courtesy of perl 5.10)
@
text
@d411 2
@


1.84
log
@turn the checksums stored in packing elements into real objects, so that
pkg_add becomes mostly independent of the type of checksum stored.

separate md5 into an abstract OpenBSD::digest class and an md5 subclass
with specific methods to compute checksums and serialize results, and create
an sha class that does the same thing with sha256 (with a base64 serializer)
@
text
@d588 1
a588 1
	local $_;
@


1.83
log
@defer to the packing element for computing md5
@
text
@d2 1
a2 1
# $OpenBSD: Add.pm,v 1.82 2008/03/08 12:07:45 espie Exp $
d78 1
a78 1
	if (defined $last && defined($last->{md5})) {
d80 1
a80 1
	    my $old = $last->{md5};
d82 4
a85 4
	    $last->{md5} = $last->compute_md5($lastname);
	    if ($old ne $last->{md5}) {
		print "Adjusting md5 for $lastname from ",
		    unpack('H*', $old), " to ", unpack('H*', $last->{md5}), "\n";
d511 1
a511 1
		    if (defined $orig->{md5}) {
d514 2
a515 2
			my $md5 = $self->compute_md5($filename);
			if ($md5 eq $orig->{md5}) {
@


1.82
log
@rename forced to defines
@
text
@d2 1
a2 1
# $OpenBSD$
a78 1
	    require OpenBSD::md5;
d82 1
a82 1
	    $last->{md5} = OpenBSD::md5::fromfile($lastname);
a511 1
			require OpenBSD::md5;
d513 2
a514 1
			my $md5 = OpenBSD::md5::fromfile($filename);
@


1.81
log
@typo
@
text
@d2 1
a2 1
# $OpenBSD: Add.pm,v 1.80 2007/06/18 10:47:03 espie Exp $
d372 1
a372 1
	if ($state->{forced}->{kitchensink} && $state->{not}) {
d492 1
a492 1
	if ($state->{forced}->{kitchensink} && $state->{not}) {
d683 1
a683 1
	if ($state->{forced}->{kitchensink} && $state->{not}) {
@


1.80
log
@add tag no shadow, to allow us to specify that we do NOT want tempfiles
into some directories.

a few minor style tweaks, such as using a nice join(map()) to build some
strings.
@
text
@d2 1
a2 1
# $OpenBSD: Add.pm,v 1.79 2007/06/16 11:50:49 espie Exp $
d349 1
a349 1
	$state->{noshadow}->{$self->{destdir}.$self->fullname} = 1;
@


1.79
log
@Add variation on exec/unexec:
@@exec-always         @@unexec-always
@@exec-add            @@unexec-delete
@@exec-update         @@unexec-update

with the obvious semantics that *update are only run during updates,
and *add/delete are only run during `pure' additions/removals.

This should solve the problem of those packages that `lose' manual
configuration when you update them (e.g., all the mod_xxx apache stuff
and postfix).

caveat: you will need to go through one finaly broken update before the
new stuff kicks in.
@
text
@d2 1
a2 1
# $OpenBSD: Add.pm,v 1.78 2007/06/16 09:29:37 espie Exp $
d344 8
@


1.78
log
@use OpenBSD::Paths contents
@
text
@d2 1
a2 1
# $OpenBSD: Add.pm,v 1.77 2007/06/12 09:53:36 espie Exp $
d616 19
a634 1
	$self->run($state);
@


1.77
log
@tidy error messages: uses $! more consistently, do not append \n on die,
do append \n on warn.

Fix the two cases where the temp dir vanished too soon: not copying +DESC
should have been apparent. Not finding a +DISPLAY file is not a reason for
burping all over the place.
@
text
@d2 1
a2 1
# $OpenBSD: Add.pm,v 1.76 2007/06/09 13:39:31 espie Exp $
d24 1
d219 1
a219 1
			System('chmod', $self->{mode}, $name);
d290 1
a290 1
sub command 	{ '/usr/sbin/useradd' }
d307 1
a307 1
sub command { '/usr/sbin/groupadd' }
d325 1
a325 1
	open(my $pipe, '-|', '/sbin/sysctl', '-n', $name);
d339 3
a341 1
	VSystem($state->{very_verbose}, '/sbin/sysctl', $name.'='.$self->{value});
d567 2
a568 1
	    "install-info", "--info-dir=".dirname($fullname), $fullname);
d580 1
a580 1
	open(my $shells, '<', $destdir.'/etc/shells') or return;
d587 1
a587 1
	open(my $shells2, '>>', $destdir.'/etc/shells') or return;
d590 2
a591 1
	print "Shell $fullname appended to $destdir/etc/shells\n";
@


1.76
log
@tag user installed packages.
- record what's on the command line.
- adjust option depending on -a / !-a
- report `manual-install' status when replacing stuff.
@
text
@d2 1
a2 1
# $OpenBSD: Add.pm,v 1.75 2007/06/06 15:35:20 espie Exp $
d665 3
a667 1
	File::Copy::move($self->fullname, $dest);
@


1.75
log
@finish moving the size computations out of validate_plist.
@
text
@d2 1
a2 1
# $OpenBSD: Add.pm,v 1.74 2007/06/06 15:31:06 espie Exp $
d106 48
@


1.74
log
@separate the size computation from other operations in `prepare_for_addition'
`prepare_for_deletion' -> move that to Vstat, as it is common code.
Do the splitting of libraries through a deep copy and shallow copy, so that
we keep any State information related to libraries (like special group/owners).
@
text
@d2 1
a2 1
# $OpenBSD: Add.pm,v 1.73 2007/06/06 12:32:09 espie Exp $
a62 1
	return $plist->compute_size;
@


1.73
log
@tweak how copies happen: rename make_copy into make_shallow_copy,
make_deep_copy.

tweak keep_old_files so that we set the pkgname later, when it won't
cause any error to have duplicates in there.
@
text
@d2 1
a2 1
# $OpenBSD: Add.pm,v 1.72 2007/06/04 18:55:47 espie Exp $
a61 2
	$state->{totsize} = 0;

d63 1
a63 2
	$state->{totsize} = 1 if $state->{totsize} == 0;
	$plist->{totsize} = $state->{totsize};
a308 1
	$state->{totsize} += $self->{size} if defined $self->{size};
a428 1
	$state->{totsize} += $size if defined $size;
@


1.72
log
@a few missed $' / $`
@
text
@d2 1
a2 1
# $OpenBSD: Add.pm,v 1.71 2007/06/04 14:40:39 espie Exp $
d75 1
a75 1
	my $n = $plist->make_copy($h);
@


1.71
log
@some minor systematic changes.
- mark all regexps I can with /o if they can be compiled once.
- turn $o->method() into $o->method
- remove unneeded prototypes
- reduce split /re/ into split "string" where possible.
@
text
@d2 1
a2 1
# $OpenBSD: Add.pm,v 1.70 2007/06/01 22:06:03 espie Exp $
d207 2
a208 2
		if ($v =~ m/^\!/o) {
			push(@@$l, $f, $');
@


1.70
log
@apply the same checks on extraction that are done during pkg_create
(modes and owners without annotation WILL be refused).

Somewhat pedantic: skip archive entry during extraction of links/symlinks.
Doesn't change a thing, except in the very rare case where a package would
end with a link in the packing-list. Now we're able to detect a premature
end of the tarball.

(okay, it's an obscure bug, I haven't even met it for real. So what ?)
@
text
@d2 1
a2 1
# $OpenBSD: Add.pm,v 1.69 2007/06/01 14:58:29 espie Exp $
d171 1
a171 1
		if ($v =~ m/^\d+$/) {
d207 1
a207 1
		if ($v =~ m/^\!/) {
d537 1
a537 1
		s/^\#.*//;
@


1.69
log
@refactor ProgressMeter code to create objects, put these into state.
Create a common state class for delete and add, put the progressmeter
creation in there.

neat effect: we don't have a progressmeter, we use a stub class instead
and *never* pull the code in at all.
@
text
@d2 1
a2 1
# $OpenBSD: Add.pm,v 1.68 2007/05/31 11:05:41 espie Exp $
d394 3
@


1.68
log
@kill REQ script directly. I'm pretty sure it doesn't quite work anyways.
Deprecate INSTALL and DEINSTALL, write out warnings in pkg_create.

Clean up some more old cruft
@
text
@d2 1
a2 1
# $OpenBSD: Add.pm,v 1.67 2007/05/31 10:04:03 espie Exp $
d131 1
a131 1
	$self->mark_progress($donesize, $totsize);
@


1.67
log
@fix the saving of partial installs in case destdir is used.
@
text
@d2 1
a2 1
# $OpenBSD: Add.pm,v 1.66 2007/05/30 16:32:14 espie Exp $
a620 7
}

package OpenBSD::PackingElement::FREQUIRE;
sub install
{
	my ($self, $state) = @@_;
	$self->run($state, 'INSTALL');
@


1.66
log
@simplify script handling a bit (they're going to disappear probably anyways).

Remove two passes visitors, we don't use them.
@
text
@d2 1
a2 1
# $OpenBSD: Add.pm,v 1.65 2007/05/30 14:04:51 espie Exp $
d71 1
a71 1
	my ($plist, $h) = @@_;
d85 1
a85 6
	    my $lastname;
	    if (defined $last->{tempname}) {
	    	$lastname = $last->{tempname};
	    } else {
	    	$lastname = $last->fullname;
	    }
@


1.65
log
@simplify really_add to use real visitors for extraction and installation.
Just do one single try {} catchall {} per-method, as this is enough.

New methods: extract_and_progress, install_and_progress, that catch
interrupts (die) deal with fake, and handle the progress meter.
One single method: mark_progress, can be used for extraction, installation
and deletion.
@
text
@d2 1
a2 1
# $OpenBSD: Add.pm,v 1.64 2007/05/30 13:03:54 espie Exp $
d626 14
@


1.64
log
@avoid setting partial directly when we can, use inheritance instead.
@
text
@d2 1
a2 1
# $OpenBSD: Add.pm,v 1.63 2007/05/30 12:52:07 espie Exp $
d101 16
d125 12
@


1.63
log
@simplify the way partial installations get recorded: store elements
already installed in a hash, and do a shallow copy of the list when
necessary, using make_copy.

This removes a lot of action-at-a-distance in packing-list elements.
@
text
@d2 1
a2 1
# $OpenBSD: Add.pm,v 1.62 2007/05/30 11:40:07 espie Exp $
d209 1
a209 1
	$state->{partial}->{$self} = 1;
d256 1
a256 1
	$state->{partial}->{$self} = 1;
d306 1
a306 1
	$state->{partial}->{$self} = 1;
d387 1
a387 1
	$state->{partial}->{$self} = 1;
d425 1
a425 1
	$state->{partial}->{$self} = 1;
d525 1
a525 1
	$state->{partial}->{$self} = 1;
d542 1
a542 1
	$state->{partial}->{$self} = 1;
@


1.62
log
@slightly better control over partial installations (still preparing for
bigger sets)
@
text
@d2 1
a2 1
# $OpenBSD: Add.pm,v 1.61 2007/05/30 11:13:35 espie Exp $
d71 1
a71 1
	my $plist = shift;
d75 1
d77 2
a78 3
	# fix packing list for pkg_delete
	$plist->{items} = $plist->{done};

d80 2
a81 2
	my $last = $plist->{items}->[@@{$plist->{items}}-1];
	if ($last->IsFile && defined($last->{md5})) {
d97 1
a97 3
	OpenBSD::PackingElement::Cwd->add($plist, '.');
	$plist->{name}->{name} = $borked;
	register_installation($plist);
d113 2
d209 1
d256 1
d306 1
a317 1
			delete $self->{zap};
a319 1
			delete $self->{zap};
d387 1
d425 1
d525 1
d542 1
@


1.61
log
@separate the creation of the borked package and the Fatal.
@
text
@d2 1
a2 1
# $OpenBSD: Add.pm,v 1.60 2007/05/29 14:39:03 espie Exp $
a100 9
}

sub borked_installation
{
	my ($plist, $not, @@msg) = @@_;

	Fatal @@msg if $not;
	my $borked = record_partial_installation($plist);
	Fatal @@msg, ", partial installation recorded as $borked";
@


1.60
log
@rely on packing-lists knowing where they live, much saner.
@
text
@d2 1
a2 1
# $OpenBSD: Add.pm,v 1.59 2007/05/29 13:52:07 espie Exp $
d69 1
a69 1
sub borked_installation
d71 1
a71 1
	my ($plist, $not, @@msg) = @@_;
a72 1
	Fatal @@msg if $not;
a74 1

d81 1
a81 1
	if ($last->IsFile() && defined($last->{md5})) {
d100 9
@


1.59
log
@don't bypass add_object to create special files, otherwise infodir won't
get defined.

Simplify and clean-up register_installation: everything is in the packing-list
so don't pass other arguments. Do not copy arbitrary info_names objects, but
use a copy_info visitor which copies exactly what files are around.

Use the stored infodir to locate DISPLAY and INSTALL files.
@
text
@d2 1
a2 1
# $OpenBSD: Add.pm,v 1.58 2007/05/28 13:00:04 espie Exp $
a51 1
	my $dir = $plist->infodir;
d71 1
a71 1
	my ($plist, $dir, $not, @@msg) = @@_;
d562 1
a562 1
	my $cname = $state->{dir}.'/'.$self->{name};
@


1.58
log
@delay error reporting a bit more: try installing and deinstalling everything
and report more issues.
@
text
@d2 1
a2 1
# $OpenBSD: Add.pm,v 1.57 2007/05/28 12:16:55 espie Exp $
d49 1
a49 1
	my ($dir, $dest, $plist) = @@_;
d51 2
d54 2
a55 3
	for my $i (info_names()) {
		copy($dir.$i, $dest);
	}
a100 1
	my $pkgname = $plist->pkgname;
d102 1
a102 2
	my $dest = installed_info($borked);
	register_installation($dir, $dest, $plist);
d120 4
d588 13
@


1.57
log
@lift up more of the dev checking code into Vstat.
un-special case SpecialFiles on deletion. Now that CONTENTS is part of the
plist, it's checked as well on addition.
@
text
@d2 1
a2 1
# $OpenBSD: Add.pm,v 1.56 2007/05/28 11:15:11 espie Exp $
a61 1
	$state->{problems} = 0;
a62 1
	$state->{colliding} = [];
a64 10
	if (@@{$state->{colliding}} > 0) {
		require OpenBSD::CollisionReport;

		OpenBSD::CollisionReport::collision_report($state->{colliding}, $state);
	}
	if (defined $state->{overflow}) {
		OpenBSD::Vstat::tally();
	}
	Fatal "fatal issues in installing ", $plist->pkgname 
	    if $state->{problems};
@


1.56
log
@clean up packing-list validation, call the methods `prepare_for_addition'
and `prepare_for_deletion', that's clearer...
@
text
@d2 1
a2 1
# $OpenBSD: Add.pm,v 1.55 2007/05/27 22:04:17 espie Exp $
d303 1
a303 8
		if ($state->{very_verbose} or ++($s->{problems}) < 4) {
			Warn "Error: ", $s->{dev}, 
			    " is read-only ($fname)\n";
		} elsif ($s->{problems} == 4) {
			Warn "Error: ... more files can't be written to ",
				$s->{dev}, "\n";
		}
		$state->{problems}++;
d309 1
a309 9
		if ($state->{very_verbose} or ++($s->{problems}) < 4) {
			Warn "Error: ", $s->{dev}, 
			    " is not large enough ($fname)\n";
		} elsif ($s->{problems} == 4) {
			Warn "Error: ... more files do not fit on ",
				$s->{dev}, "\n";
		}
		$state->{overflow} = 1;
		$state->{problems}++;
d421 1
a421 8
		if ($state->{very_verbose} or ++($s->{problems}) < 4) {
			Warn "Error: ", $s->{dev}, 
			    " is read-only ($fname)\n";
		} elsif ($s->{problems} == 4) {
			Warn "Error: ... more files can't be written to ",
				$s->{dev}, "\n";
		}
		$state->{problems}++;
d427 1
a427 9
		if ($state->{very_verbose} or ++($s->{problems}) < 4) {
			Warn "Error: ", $s->{dev}, 
			    " is not large enough ($fname)\n";
		} elsif ($s->{problems} == 4) {
			Warn "Error: ... more files do not fit on ",
				$s->{dev}, "\n";
		}
		$state->{overflow} = 1;
		$state->{problems}++;
d580 1
a580 2
			Warn "Error: ", $s2->{dev}, " is noexec ($cname)\n";
			$state->{problems}++;
d586 1
a586 2
		Warn "Error: ", $s->{dev}, " is read-only ($fname)\n";
		$state->{problems}++;
d589 1
a589 2
		Warn "Error: ", $s->{dev}, " is noexec ($fname)\n";
		$state->{problems}++;
d595 1
a595 3
		Warn "Error: ", $s->{dev}, " is not large enough ($fname)\n";
		$state->{overflow} = 1;
		$state->{problems}++;
@


1.55
log
@move packing-list validation to the UpdateSet level.
@
text
@d2 1
a2 1
# $OpenBSD: Add.pm,v 1.54 2007/05/22 11:02:57 espie Exp $
d58 1
a58 1
sub validate_plist($$)
d62 3
a64 5
	my $destdir = $state->{destdir};
	my $problems = 0;
	my $pkgname = $plist->pkgname;
	my $totsize = 0;
	my $colliding = [];
d66 2
a67 2
	$plist->validate($state, \$problems, $colliding, \$totsize, $plist->pkgname);
	if (@@$colliding > 0) {
d70 1
a70 1
		OpenBSD::CollisionReport::collision_report($colliding, $state);
d75 4
a78 3
	Fatal "fatal issues in installing $pkgname" if $problems;
	$totsize = 1 if $totsize == 0;
	$plist->{totsize} = $totsize;
d125 1
a125 1
sub validate
d171 1
a171 1
sub validate
d173 1
a173 1
	my ($self, $state, $problems, $colliding, $totsize, $pkgname) = @@_;
d177 1
a177 1
	    $$problems++;
d181 1
a181 1
	    $$problems++;
d204 1
a204 1
sub validate
d206 2
a207 2
	my ($self, $state, $problems, $colliding, $totsize, $pkgname) = @@_;
	my $ok = $self->check();
d212 1
a212 1
			$$problems++;
d289 1
a289 1
sub validate
d291 1
a291 1
	my ($self, $state, $problems, $colliding, $totsize, $pkgname) = @@_;
d295 2
a296 2
		push(@@$colliding, $self);
		$$problems++;
d299 1
a299 1
	$$totsize += $self->{size} if defined $self->{size};
d310 1
a310 1
		$$problems++;
d324 1
a324 1
		$$problems++;
d420 1
a420 1
sub validate
d422 1
a422 1
	my ($self, $state, $problems, $colliding, $totsize, $pkgname) = @@_;
d426 1
a426 1
	my $fname = $state->{destdir}.$self->fullname();
d432 1
a432 1
	$$totsize += $size if defined $size;
d443 1
a443 1
		$$problems++;
d457 1
a457 1
		$$problems++;
d597 1
a597 1
sub validate
d599 1
a599 1
	my ($self, $state, $problems, $colliding, $totsize, $pkgname) = @@_;
d607 1
a607 1
	if ($self->exec_on_add()) {
d611 1
a611 1
			$$problems++;
d618 1
a618 1
		$$problems++;
d620 1
a620 1
	if ($s->{noexec} && $self->exec_on_delete()) {
d622 1
a622 1
		$$problems++;
d630 1
a630 1
		$$problems++;
@


1.54
log
@zap references to pkgdep. Packing-Lists no longer even record it, anyways.
@
text
@d2 1
a2 1
# $OpenBSD: Add.pm,v 1.53 2007/05/02 15:05:29 espie Exp $
d79 1
a79 1
	return $totsize;
@


1.53
log
@$o->method() becomes $o->method
@
text
@d2 1
a2 1
# $OpenBSD: Add.pm,v 1.52 2007/04/29 11:09:29 espie Exp $
a114 1
	$plist->{pkgdep} = [];
@


1.52
log
@replace $p->visit('method') calls with $p->method
now that it works.
@
text
@d2 1
a2 1
# $OpenBSD: Add.pm,v 1.51 2007/04/15 10:17:29 espie Exp $
d55 1
a55 1
	$plist->to_installation();
d64 1
a64 1
	my $pkgname = $plist->pkgname();
d68 1
a68 1
	$plist->validate($state, \$problems, $colliding, \$totsize, $plist->pkgname());
d90 1
a90 1
	my $borked = borked_package($plist->pkgname());
d104 1
a104 1
	    	$lastname = $last->fullname();
d113 1
a113 1
	my $pkgname = $plist->pkgname();
d143 2
a144 2
			$uidcache = OpenBSD::UidCache->new();
			$gidcache = OpenBSD::GidCache->new();
d212 1
a212 1
			Warn $self->type(), " ",  $self->{name}, 
d224 1
a224 1
	print "adding ", $self->type(), " $auth\n" if $state->{verbose};
d230 1
a230 1
	VSystem($state->{very_verbose}, $self->command(),, @@$l, $auth);
d294 1
a294 1
	my $fname = $state->{destdir}.$self->fullname();
d317 1
a317 1
	if ($s->avail() < 0) {
d333 1
a333 1
	my $fullname = $self->fullname();
d359 1
a359 1
			$state->{archive}->skip();
d362 1
a362 1
			$file->create();
d371 1
a371 1
	my $fullname = $self->fullname();
d374 1
a374 1
	my $file=$state->{archive}->next();
d378 1
a378 1
	$file->{cwd} = $self->cwd();
d383 2
a384 2
	if (defined $self->{symlink} || $file->isSymLink()) {
		unless (defined $self->{symlink} && $file->isSymLink()) {
d391 2
a392 2
	} elsif (defined $self->{link} || $file->isHardLink()) {
		unless (defined $self->{link} && $file->isHardLink()) {
d450 1
a450 1
	if ($s->avail() < 0) {
d468 1
a468 1
	my $filename = $destdir.$self->fullname();
d470 1
a470 1
	my $origname = $destdir.$orig->fullname();
d514 1
a514 1
	$state->print("You may wish to add ", $self->fullname(), " to /etc/man.conf\n");
d535 1
a535 1
	my $fullname = $state->{destdir}.$self->fullname();
d546 1
a546 1
	my $fullname = $self->fullname();
d566 1
a566 1
	my $fullname = $self->fullname();
d629 1
a629 1
	if ($s->avail() < 0) {
@


1.51
log
@update copyright years, standardize licence.
reword the introduction to the stuff originally from FreeBSD to clarify
slightly.
@
text
@d2 1
a2 1
# $OpenBSD: Add.pm,v 1.50 2007/02/24 18:45:11 espie Exp $
d68 1
a68 1
	$plist->visit('validate', $state, \$problems, $colliding, \$totsize, $plist->pkgname());
@


1.50
log
@UI improvement: in case the disk overflows, let tally give information
about the extra size needed. In validate, mark the overflow and call tally
later.

.e.g.,
Error: /dev/wd0f is not large enough (/usr/local/lib/libkparts.so.4.0.0)
Error: /dev/wd0f is not large enough (/usr/local/lib/libkrosscore.so.4.0.0)
Error: /dev/wd0f is not large enough (/usr/local/lib/libktexteditor.so.4.0.0)
Error: ... more files do not fit on /dev/wd0f
/dev/wd0h: 97 bytes
/dev/wd0f: 337090852 bytes (missing 78473 blocks)
@
text
@d2 1
a2 1
# $OpenBSD: Add.pm,v 1.49 2006/12/05 14:04:19 steven Exp $
d4 1
a4 1
# Copyright (c) 2003-2004 Marc Espie <espie@@openbsd.org>
@


1.49
log
@use lstat for symbolic links; fixes uninitialized uid/gid.

ok espie@@
@
text
@d2 1
a2 1
# $OpenBSD: Add.pm,v 1.48 2006/02/16 11:21:58 espie Exp $
d74 3
d325 1
d458 1
d631 1
@


1.48
log
@validate() can also take sample files into account.
@
text
@d2 1
a2 1
# $OpenBSD: Add.pm,v 1.47 2006/02/09 09:42:10 espie Exp $
d143 6
a148 1
		my ($uid, $gid) = (stat $name)[4,5];
@


1.47
log
@Turn validate_plist() into a real visitor that calls validate() for each
object in the packing-list.

Move some checks earlier, so that update of packages fails before
deleting the old package.

Add more checks, like verifying that install/deinstall scripts are indeed
located on exec'able partitions.
@
text
@d2 1
a2 1
# $OpenBSD: Add.pm,v 1.46 2005/12/05 13:39:28 espie Exp $
d415 1
a415 1
	my $self = shift;
d418 32
@


1.46
log
@make sure set_modes always get called for a `real' extraction.
Problem noticed by sturm@@
@
text
@d2 1
a2 1
# $OpenBSD: Add.pm,v 1.45 2005/11/02 22:26:51 espie Exp $
d66 1
d68 1
a68 68
	my $extra = $plist->{extrainfo};
	if ($state->{cdrom_only} && ((!defined $extra) || $extra->{cdrom} ne 'yes')) {
	    Warn "Package $pkgname is not for cdrom.\n";
	    $problems++;
	}
	if ($state->{ftp_only} && ((!defined $extra) || $extra->{ftp} ne 'yes')) {
	    Warn "Package $pkgname is not for ftp.\n";
	    $problems++;
	}

	# check for collisions with existing stuff
	my $colliding = [];
	for my $item (@@{$plist->{items}}) {
		next unless $item->IsFile();
		my $fname = $destdir.$item->fullname();
		if (OpenBSD::Vstat::vexists($fname)) {
			push(@@$colliding, $item);
			$problems++;
			next;
		}
		$totsize += $item->{size} if defined $item->{size};
		my $s = OpenBSD::Vstat::add($fname, $item->{size}, \$pkgname);
		next unless defined $s;
		if ($s->{ro}) {
			if ($state->{very_verbose} or ++($s->{problems}) < 4) {
				Warn "Error: ", $s->{dev}, 
				    " is read-only ($fname)\n";
			} elsif ($s->{problems} == 4) {
				Warn "Error: ... more files can't be written to ",
					$s->{dev}, "\n";
			}
			$problems++;
		}
		if ($state->{forced}->{kitchensink} && $state->{not}) {
			next;
		}
		if ($s->avail() < 0) {
			if ($state->{very_verbose} or ++($s->{problems}) < 4) {
				Warn "Error: ", $s->{dev}, 
				    " is not large enough ($fname)\n";
			} elsif ($s->{problems} == 4) {
				Warn "Error: ... more files do not fit on ",
					$s->{dev}, "\n";
			}
			$problems++;
		}
	}
	my $dest = installed_info($pkgname);
	my $dir = $plist->{dir};
	for my $i (info_names()) {
		if (-e "$dir/$i") {
			my $size = (stat _)[7];
			my $fname = "$dest/$i";
			my $s = OpenBSD::Vstat::add($fname, $size, \$pkgname);
			next unless defined $s;
			if ($s->{ro}) {
				Warn "Error: ", $s->{dev}, " is read-only ($fname)\n";
				$problems++;
			}
			if ($state->{forced}->{kitchensink} && $state->{not}) {
				next;
			}
			if ($s->avail() < 0) {
				Warn "Error: ", $s->{dev}, " is not large enough ($fname)\n";
				$problems++;
			}
		}
	}
d124 4
d162 20
d198 1
a198 4
package OpenBSD::PackingElement::NewUser;
use OpenBSD::Error;

sub install
d200 1
a200 4
	my ($self, $state) = @@_;
	my $user = $self->{name};
	print "adding user $user\n" if $state->{verbose};
	return if $state->{not};
d204 3
a206 1
			Fatal "user $user does not match\n";
a207 11
	} else {
		my $l=[];
		push(@@$l, "-v") if $state->{very_verbose};
		$self->add_entry($l, 
		    '-u', $self->{uid},
		    '-g', $self->{group},
		    '-L', $self->{class},
		    '-c', $self->{comment},
		    '-d', $self->{home},
		    '-s', $self->{shell});
		VSystem($state->{very_verbose}, '/usr/sbin/useradd', @@$l, $user);
d209 1
a211 3
package OpenBSD::PackingElement::NewGroup;
use OpenBSD::Error;

d215 2
a216 2
	my $group = $self->{name};
	print "adding group $group\n" if $state->{verbose};
d218 33
a250 11
	my $ok = $self->check();
	if (defined $ok) {
		if ($ok == 0) {
			Fatal "group $group does not match\n";
		}
	} else {
		my $l=[];
		push(@@$l, "-v") if $state->{very_verbose};
		$self->add_entry($l, '-g', $self->{gid});
		VSystem($state->{very_verbose}, '/usr/sbin/groupadd', @@$l, $group);
	}
d283 38
d413 8
a427 3
	if (!defined $orig) {
		Fatal "\@@sample element does not reference a valid file\n";
	}
d551 40
@


1.45
log
@In case we are pretending, make sure we skip to the next archive member.
Otherwise, we might miss a truncated archive that's missing its last file,
and PKG_CACHE won't work, since it hits a SIGPIPE too soon.

Nice testcase from sturm@@
@
text
@d2 1
a2 1
# $OpenBSD: Add.pm,v 1.44 2005/11/02 17:01:26 bernd Exp $
d350 1
a352 1
			$self->set_modes($destdir.$fullname);
d355 1
@


1.44
log
@Simplify OpenBSD::PackingElement::Sysctl::install().

okay espie@@
@
text
@d2 1
a2 1
# $OpenBSD: Add.pm,v 1.43 2005/10/19 10:41:19 espie Exp $
d348 6
a353 2
		return if $state->{not};
		$file->create();
a354 1
	$self->set_modes($destdir.$fullname);
@


1.43
log
@mark links being extracted with `zap', so that they do not get recorded
into partial plists until they've gone through an actual install.

Prevents partial replacements from destroying genuine links in packages
when they get uninstalled.
@
text
@d2 1
a2 1
# $OpenBSD: Add.pm,v 1.42 2005/09/24 12:52:19 espie Exp $
d298 1
a298 1
	open(my $pipe, '-|', '/sbin/sysctl', $name);
a300 1
	$actual =~ s/^\Q$name\E\s*\=\s*//;
@


1.42
log
@pass actual items to prepare_long and check_name so that we can also
verify that modes/groups/owners are correct (code to come)
@
text
@d2 1
a2 1
# $OpenBSD: Add.pm,v 1.41 2005/09/04 22:53:51 espie Exp $
d335 1
d338 1
@


1.41
log
@zap duplicate code
@
text
@d2 1
a2 1
# $OpenBSD: Add.pm,v 1.40 2005/09/04 22:47:56 espie Exp $
d364 1
a364 1
	if (!$file->check_name($self->{name})) {
@


1.40
log
@* New -i interactive option, that can ask obnoxious questions.
* move the signature code to a packing-list method, prepend the pkgname.
* depend on distant listings, cache these systematically.
* cut the PKG_PATH at :/ systematically, much simpler than parsing URLs.
People should get used to trailing /s.
* let pkg_add -u actually run the update.
* check for signature in more places, for instance, let pkg_add installed_stuff
be a void operation.
* grab enough stuff during updates to check signatures, so that pkg_add -u
can report updates that are not needed right away, instead of waiting
for the more confusing `trying to update'
* beginning of @@module support.
* @@pkgpath support, including updates.
* systematically expand stems when applicable.
* use visitors systematically in pkg_info.
* pkg_info -S reports signature.
* remove hardcoding of categories in PackingList, so that future modules
will be able to expand them.
* add @@updateset and @@incompatibility keywords.
@
text
@d2 1
a2 1
# $OpenBSD: Add.pm,v 1.39 2005/08/22 11:25:59 espie Exp $
a24 11

sub is_needed
{
	my ($plist, $state) = @@_;
	my $oplist = OpenBSD::PackingList->from_installation($plist->pkgname());
	my $n = $plist->signature();
	my $o = $oplist->signature();
	print "Comparing full signature for ", $plist->pkgname(), " \"$o\" vs. \"$n\": ", $n eq $o ? "equal\n" : "different\n" 
	    if $state->{very_verbose};
	return $n ne $o;
}
@


1.39
log
@maintain a counter of problems encountered per-filesystem.
Do not report more than 3 problems per filesystem unless -v -v.
@
text
@d2 1
a2 1
# $OpenBSD: Add.pm,v 1.38 2005/08/16 16:24:24 espie Exp $
d25 11
@


1.38
log
@in case we're pretending to install, there's no borked package to create.
@
text
@d2 1
a2 1
# $OpenBSD: Add.pm,v 1.37 2005/08/13 16:46:35 espie Exp $
d91 7
a97 1
			Warn "Error: ", $s->{dev}, " is read-only ($fname)\n";
d104 7
a110 1
			Warn "Error: ", $s->{dev}, " is not large enough ($fname)\n";
@


1.37
log
@symlinks and hardlinks do not have an md5
@
text
@d2 1
a2 1
# $OpenBSD: Add.pm,v 1.36 2005/08/13 15:47:57 espie Exp $
d135 1
a135 1
	my ($plist, $dir, @@msg) = @@_;
d137 1
d139 1
@


1.36
log
@don't set $file->{cwd} until *after* we're sure it's defined.

Allows pkg_add to properly report truncated archives, instead of weird
can't call method check_name() on an unblessed reference
messages.

problem reported by brad@@, somewhat difficult to reproduce.

as usual, the most obvious bugs take the longest time...
@
text
@d2 1
a2 1
# $OpenBSD: Add.pm,v 1.35 2005/08/07 14:18:05 espie Exp $
d145 1
a145 1
	if ($last->IsFile()) {
@


1.35
log
@wrapper around Ustar that replaces long names/links with LongName#/LongLink#.

The archive will unpack correctly with tar, except that those names won't
be preserved.

The wrapper checks names against the packing-list to restore the correct names
on the fly.

Put into a separate file, as it is an extension of Ustar proper, and we're
going to do more archive checking in the future.

Lots of tests by Bernd Ahlers. Comments by Tom Cosgrove.
@
text
@d2 1
a2 1
# $OpenBSD: Add.pm,v 1.33 2005/06/21 19:12:31 espie Exp $
a345 1
	$file->{cwd} = $self->cwd();
d349 1
@


1.34
log
@Make sure $totsize != 0, even if the package does not contain any actual
files, so that the progress meter will work.
@
text
@d23 1
d346 1
d350 1
a350 1
	if ($file->{name} ne $self->{name}) {
d358 1
a358 1
		if ($self->{symlink} ne $file->{linkname}) {
d366 2
a367 6
		my $linkname = $file->{linkname};
		if (defined $self->{cwd}) {
			$linkname = $self->cwd().'/'.$linkname;
		}
		if ($self->{link} ne $linkname) {
			Fatal "Error: archive hl does not match ", $linkname, "!=",
a372 1
	$file->{cwd} = $self->cwd();
@


1.33
log
@move Arch->check() up to Packingelement, so that it can be called anywhere,
not only while adding packages.

Add FatOnly filter, which will be used to get information from packing-lists
to select the correct packing-list from a fat package (e.g., @@arch and @@name).
@
text
@d2 1
a2 1
# $OpenBSD: Add.pm,v 1.32 2005/06/12 11:14:28 espie Exp $
d128 1
@


1.32
log
@test that archive->next() worked, and explicitly throw a `truncated archive'
message if it didn't work.

Replaces messages like:
Use of uninitialized value in string ne at /usr/libdata/perl5/OpenBSD/Add.pm lin
e 344.
Use of uninitialized value in join or string at /usr/libdata/perl5/OpenBSD/Error
.pm line 67.
Error: archive does not match   != share/autoconf-2.13/acheaders


with:
Error: truncated archive
@
text
@d2 1
a2 1
# $OpenBSD: Add.pm,v 1.31 2005/02/07 00:52:35 espie Exp $
a528 29

package OpenBSD::PackingElement::Arch;

sub check
{
	my ($self, $forced_arch) = @@_;

	my ($machine_arch, $arch);
	for my $ok (@@{$self->{arches}}) {
		return 1 if $ok eq '*';
		if (defined $forced_arch) {
			if ($ok eq $forced_arch) {
				return 1;
			} else {
				next;
			}
		}
		if (!defined $machine_arch) {
			chomp($machine_arch = `/usr/bin/arch -s`);
		}
		return 1 if $ok eq $machine_arch;
		if (!defined $arch) {
			chomp($arch = `/usr/bin/uname -m`);
		}
		return 1 if $ok eq $arch;
	}
	return undef;
}

@


1.31
log
@take size of metainfo into account when checking if the file system is
large enough before installing a package.
@
text
@d2 1
a2 1
# $OpenBSD: Add.pm,v 1.30 2005/01/13 00:27:39 espie Exp $
d344 3
@


1.30
log
@let collision reports give the name of the package they're trying to
install. When you add 2000 packages, this can be *real* confusing
otherwise.
@
text
@d2 1
a2 1
# $OpenBSD: Add.pm,v 1.29 2004/12/20 12:16:51 espie Exp $
d99 21
@


1.29
log
@don't display some details in -n mode unless very verbose.
@
text
@d2 1
a2 1
# $OpenBSD: Add.pm,v 1.28 2004/12/18 13:58:43 espie Exp $
d106 1
a106 1
	Fatal "fatal issues" if $problems;
@


1.28
log
@display something when files ought to get moved in -n.
@
text
@d2 1
a2 1
# $OpenBSD: Add.pm,v 1.27 2004/12/18 13:48:23 espie Exp $
d35 1
a35 1
			print "Merging manpages in $destdir$k: ", join(@@l), "\n";
d292 1
a292 1
			print "moving tempfile -> $destdir$fullname\n";
d309 1
a309 1
		print "extracting $destdir$fullname\n" if $state->{beverbose};
@


1.27
log
@ignore size issues in kitchensink pretend mode.

Be consistent: show added files and deleted files if pretending.
@
text
@d2 1
a2 1
# $OpenBSD: Add.pm,v 1.26 2004/12/17 11:26:21 espie Exp $
d291 4
a294 1
		return if $state->{not};
d303 1
a303 1
			print "moving ", $self->{tempname}, " -> $destdir$fullname\n" if $state->{beverbose};
@


1.26
log
@better collision reports.
- in validate_plist, don't re-add a file that exists.
- allows the virtual file system to put marks on existing files
- use a \$pkgname the first time a file is added (space constraints: don't
duplicate the pkgname).
- in CollisionReport, first check the vfs, so that we don't look
at installed packages when the collision only concerns newly added pkgs.

Makes pkg_add -n report collision reports correctly.
@
text
@d2 1
a2 1
# $OpenBSD: Add.pm,v 1.25 2004/12/16 11:07:33 espie Exp $
d93 3
d300 1
a300 1
			print "moving ", $self->{tempname}, " -> $destdir$fullname\n" if $state->{very_verbose};
d306 1
a306 1
		print "extracting $destdir$fullname\n" if $state->{very_verbose};
@


1.25
log
@renamed borked_installation from borked.n to partial-<pkgname> ...
partial-<pkgname>.n if needed.

Make borked_installation take a message, to show installation/deinstallation
issues correctly.

Fix handling of ^C: this may lead some system calls to return early, thus
registering as errors: so always mark the last file as done, so that borked
installation will register it correctly.

Kill packing-list cache for anything but depends: we've got a global cache
of libraries now (use it in pkg_add).

Make almost everyone look at $main::not, so that we can call
register_installation
to_installation
RequirementList->add/delete
safely.

Simplify $not logic accordingly, do thing much more closely to what would
happen without -n.

This should allow pkg_add/pkg_delete -n to handle most nasty cases correctly
now, since all the relevant information is kept internally in a compact
format:
- register of shared libraries
- global register of conflicts
- cache of depends.
@
text
@d2 1
a2 1
# $OpenBSD: Add.pm,v 1.24 2004/12/12 11:26:16 espie Exp $
d84 1
d87 1
a87 1
		my $s = OpenBSD::Vstat::add($fname, $item->{size});
@


1.24
log
@add somewhat more regular error catching code.
@
text
@d2 1
a2 1
# $OpenBSD: Add.pm,v 1.23 2004/12/02 00:37:54 espie Exp $
d49 1
d108 1
a108 1
	my ($plist, $dir) = @@_;
d112 1
a112 1
	my $borked = borked_package();
d140 1
a140 1
	Fatal "Installation of $pkgname failed, partial installation recorded as $borked";
@


1.23
log
@Vstat API changed slightly. Found out by fries@@
@
text
@d2 1
a2 1
# $OpenBSD: Add.pm,v 1.22 2004/11/22 01:56:13 espie Exp $
d37 5
a41 4
			eval { OpenBSD::Makewhatis::merge($destdir.$k, \@@l); };
			if ($@@) {
				print STDERR "Error in makewhatis: $@@\n";
			}
@


1.22
log
@implement global repository for shared libraries.
@
text
@d2 1
a2 1
# $OpenBSD: Add.pm,v 1.21 2004/11/18 21:48:02 espie Exp $
d87 1
a87 1
			Warn "Error: ", $s->{mnt}, " is read-only ($fname)\n";
d91 1
a91 1
			Warn "Error: ", $s->{mnt}, " is not large enough ($fname)\n";
@


1.21
log
@support depend (similar to libdepend and newdepend) and wantlib:
put lookup_library code in a separate routine, and add a `harder' mode
for wantlib, that will also look in system libraries, and in the full
tree of dependent packages.
@
text
@d2 1
a2 1
# $OpenBSD: Add.pm,v 1.20 2004/11/14 19:50:44 espie Exp $
a150 4
sub available_lib
{
}

a494 13
}

sub available_lib
{
	my ($self, $avail, $pkgname) = @@_;
	my $fullname = $self->fullname();

	if ($fullname =~ m/^(.*\.so\.\d+)\.(\d+)$/) {
		my ($stem, $minor) = ($1, $2);
		if (!defined $avail->{"$stem"} || $avail->{"$stem"}->[0] < $minor) {
			$avail->{"$stem"} = [$minor, $pkgname];
		}
	}
@


1.20
log
@pass full item to CollisionReport, so that it can compute md5 for files
not registered with any package, and tell you if the file differs or not.
@
text
@d2 1
a2 1
# $OpenBSD: Add.pm,v 1.19 2004/11/13 12:33:01 espie Exp $
d503 1
a503 1
	my ($self, $avail) = @@_;
d508 2
a509 2
		if (!defined $avail->{"$stem"} || $avail->{"$stem"} < $minor) {
			$avail->{"$stem"} = $minor;
d513 1
@


1.19
log
@look for available registered libraries, not other stuff.
@
text
@d2 1
a2 1
# $OpenBSD: Add.pm,v 1.18 2004/11/13 12:02:57 espie Exp $
d80 1
a80 1
			push(@@$colliding, $fname);
@


1.18
log
@use lastname as I should.
@
text
@d2 1
a2 1
# $OpenBSD: Add.pm,v 1.17 2004/11/13 11:39:40 espie Exp $
d151 4
d501 12
@


1.17
log
@cwd() function so that further changes to internal storage won't matter
that much.
@
text
@d2 1
a2 1
# $OpenBSD: Add.pm,v 1.16 2004/11/13 10:47:21 espie Exp $
d126 1
a126 1
	    $last->{md5} = OpenBSD::md5::fromfile($last->fullname());
d128 1
a128 1
		print "Adjusting md5 for ", $last->fullname(), " from ",
@


1.16
log
@move borked_installation over to common routines, prepare it for
Update.
@
text
@d2 1
a2 1
# $OpenBSD: Add.pm,v 1.15 2004/11/12 21:52:01 espie Exp $
d332 1
a332 1
			$linkname = $self->{cwd}.'/'.$linkname;
d341 1
a341 1
	$file->{cwd} = $self->{cwd};
@


1.15
log
@be saner wrt directory creation during pkg updates:
don't disturb existing objects if they're not directories,
create them better if they don't exist.
@
text
@d2 1
a2 1
# $OpenBSD: Add.pm,v 1.14 2004/11/11 12:29:58 espie Exp $
d102 37
@


1.14
log
@move collision reporter to a separate file, so that it doesn't get loaded
all the time.
@
text
@d2 1
a2 1
# $OpenBSD: Add.pm,v 1.13 2004/11/11 12:17:25 espie Exp $
a247 1

d249 1
d256 1
a256 1
			    Fatal "Can't move file to $fullname: $!";
@


1.13
log
@File::Copy use moves as well.
@
text
@d2 1
a2 1
# $OpenBSD: Add.pm,v 1.12 2004/11/11 12:13:57 espie Exp $
a54 31
sub collision_report($)
{
	my $list = shift;
	my %todo = map {($_, 1)} @@$list;
	my $bypkg = {};
	

	for my $pkg (installed_packages()) {
		my $plist = OpenBSD::PackingList->from_installation($pkg, 
		    \&OpenBSD::PackingList::FilesOnly);
		for my $item (@@{$plist->{items}}) {
			next unless $item->IsFile();
			my $name = $item->fullname();
			if (defined $todo{$name}) {
				$bypkg->{$pkg} = [] unless defined $bypkg->{$pkg};
				push(@@{$bypkg->{$pkg}}, $name);
				delete $todo{$name};
			}
		}
	}
	print "Collision: the following files already exist\n";
	for my $pkg (sort keys %$bypkg) {
	    for my $item (sort @@{$bypkg->{$pkg}}) {
	    	print "\t$item ($pkg)\n";
	    }
	}
	for my $item (sort keys %todo) {
	    print "\t$item\n";
	}
}

d96 3
a98 1
		collision_report($colliding);
@


1.12
log
@need to move collision_report over as well, and use PackageInfo routines.
@
text
@d2 1
a2 1
# $OpenBSD: Add.pm,v 1.11 2004/11/11 11:36:26 espie Exp $
d23 1
@


1.11
log
@move some code from pkg_add to OpenBSD/Add.pm, for symetry with pkg_delete.

change prototype of validate_plist, ditch globals cdrom_only and ftp_only
(stash this into state).

Use Warn properly.
@
text
@d2 1
a2 1
# $OpenBSD: Add.pm,v 1.10 2004/11/11 11:16:39 espie Exp $
d22 1
d54 31
d131 1
@


1.10
log
@introduce shortcuts to read/write contents from_installation/to_installation

use these to simplify all those packing lists manipulations.

demote non-root detection to a warning in -n mode:
fix a couple of minor bugs, of stuff that was run in -n mode and should not.
Namely, manpages were indexed/unindexed (ouch) and tempfiles were creating
during updates.
@
text
@d2 1
a2 1
# $OpenBSD: Add.pm,v 1.9 2004/11/06 19:48:24 espie Exp $
d21 1
d23 76
@


1.9
log
@oops. Thanks krw.
@
text
@d2 1
a2 1
# $OpenBSD: Add.pm,v 1.8 2004/11/06 12:22:33 espie Exp $
d167 1
@


1.8
log
@die if moving tempfiles doesn't work.
pkg_delete should remove tempnames, since files actually live there.
@
text
@d2 1
a2 1
# $OpenBSD: Add.pm,v 1.7 2004/11/06 12:20:02 espie Exp $
d165 1
a165 1
	if (defined $state->{replacing}) {
@


1.7
log
@zap tempname once we've moved the file.
@
text
@d2 1
a2 1
# $OpenBSD: Add.pm,v 1.6 2004/11/06 12:19:17 espie Exp $
d172 2
a173 1
			rename($self->{tempname}, $destdir.$fullname);
@


1.6
log
@mark whole state for `replacing' so that only file entries get tempname
markers. Explain about tempname to PackingElement, so that we become
able to save temporary packing-lists (e.g, borking during replace will
now work).
@
text
@d2 1
a2 1
# $OpenBSD: Add.pm,v 1.5 2004/11/01 19:21:58 espie Exp $
d174 1
@


1.5
log
@pkg_add may need to clean up shared items now that it can delete old stuff.
let very verbose mode show moving files around.
@
text
@d2 1
a2 1
# $OpenBSD: Add.pm,v 1.4 2004/11/01 15:45:02 espie Exp $
d165 1
a165 1
	if (defined $self->{tempname}) {
@


1.4
log
@move all the checking prior to extraction to a `prepare_to_extract' function.
check that linknames match while we're at it.
@
text
@d2 1
a2 1
# $OpenBSD: Add.pm,v 1.3 2004/11/01 14:30:00 espie Exp $
d173 1
@


1.3
log
@handle the case of symlinks.
Let pkg_add -r do extraction first, and finish installation later.
@
text
@d2 1
a2 1
# $OpenBSD: Add.pm,v 1.2 2004/11/01 11:48:03 espie Exp $
d166 1
d175 1
a175 5
		my $file=$state->{archive}->next();
		if ($file->{name} ne $self->{name}) {
			Fatal "Error: archive does not match", $file->{name}, "!=",
			$self->{name}, "\n";
		}
a178 7
		$file->{name} = $fullname;
		$file->{cwd} = $self->{cwd};
		$file->{destdir} = $destdir;
		# faked installation are VERY weird
		if (defined $self->{symlink} && $state->{do_faked}) {
			$file->{linkname} = $destdir.$file->{linkname};
		}
d182 43
@


1.2
log
@separate `extract' routine that can put an archive in temporary files
next to their final locations.

XXX: doesn't work with hard links, yet.
@
text
@d2 1
a2 1
# $OpenBSD: Add.pm,v 1.1 2004/11/01 11:27:50 espie Exp $
d166 7
a172 1
		rename($self->{tempname}, $destdir.$fullname);
@


1.1
log
@reorg pkg_add slightly, put all options into state so that we don't need
to use local variables.
@
text
@d2 1
a2 1
# $OpenBSD: pkg_add,v 1.87 2004/10/31 12:40:00 espie Exp $
a162 6

	my $file=$state->{archive}->next();
	if ($file->{name} ne $self->{name}) {
		Fatal "Error: archive does not match", $file->{name}, "!=",
		$self->{name}, "\n";
	}
d165 19
a183 8
	print "extracting $destdir$fullname\n" if $state->{very_verbose};
	return if $state->{not};
	$file->{name} = $fullname;
	$file->{cwd} = $self->{cwd};
	$file->{destdir} = $destdir;
	# faked installation are VERY weird
	if (defined $self->{symlink} && $state->{do_faked}) {
		$file->{linkname} = $destdir.$file->{linkname};
a184 1
	$file->create();
@

