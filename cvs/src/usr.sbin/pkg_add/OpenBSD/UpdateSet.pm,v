head	1.76;
access;
symbols
	OPENBSD_6_1:1.76.0.8
	OPENBSD_6_1_BASE:1.76
	OPENBSD_6_0:1.76.0.10
	OPENBSD_6_0_BASE:1.76
	OPENBSD_5_9:1.76.0.4
	OPENBSD_5_9_BASE:1.76
	OPENBSD_5_8:1.76.0.6
	OPENBSD_5_8_BASE:1.76
	OPENBSD_5_7:1.76.0.2
	OPENBSD_5_7_BASE:1.76
	OPENBSD_5_6:1.75.0.6
	OPENBSD_5_6_BASE:1.75
	OPENBSD_5_5:1.75.0.4
	OPENBSD_5_5_BASE:1.75
	OPENBSD_5_4:1.70.0.4
	OPENBSD_5_4_BASE:1.70
	OPENBSD_5_3:1.70.0.2
	OPENBSD_5_3_BASE:1.70
	OPENBSD_5_2:1.69.0.6
	OPENBSD_5_2_BASE:1.69
	OPENBSD_5_1_BASE:1.69
	OPENBSD_5_1:1.69.0.4
	OPENBSD_5_0:1.69.0.2
	OPENBSD_5_0_BASE:1.69
	OPENBSD_4_9:1.64.0.2
	OPENBSD_4_9_BASE:1.64
	OPENBSD_4_8:1.62.0.2
	OPENBSD_4_8_BASE:1.62
	OPENBSD_4_7:1.51.0.2
	OPENBSD_4_7_BASE:1.51
	OPENBSD_4_6:1.4.0.4
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.3.0.4
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.3.0.2
	OPENBSD_4_4_BASE:1.3
	OPENBSD_4_3:1.2.0.4
	OPENBSD_4_3_BASE:1.2
	OPENBSD_4_2:1.2.0.2
	OPENBSD_4_2_BASE:1.2;
locks; strict;
comment	@# @;


1.76
date	2014.11.25.14.16.15;	author espie;	state Exp;
branches;
next	1.75;
commitid	UeC1WcUe5pQNhy3k;

1.75
date	2014.02.04.18.06.01;	author espie;	state Exp;
branches;
next	1.74;

1.74
date	2014.02.02.15.22.36;	author espie;	state Exp;
branches;
next	1.73;

1.73
date	2014.02.01.18.54.01;	author espie;	state Exp;
branches;
next	1.72;

1.72
date	2014.01.31.11.54.24;	author espie;	state Exp;
branches;
next	1.71;

1.71
date	2014.01.30.12.38.51;	author espie;	state Exp;
branches;
next	1.70;

1.70
date	2012.09.06.09.07.50;	author espie;	state Exp;
branches;
next	1.69;

1.69
date	2011.07.17.13.18.07;	author espie;	state Exp;
branches;
next	1.68;

1.68
date	2011.07.13.12.57.27;	author espie;	state Exp;
branches;
next	1.67;

1.67
date	2011.07.13.12.32.15;	author espie;	state Exp;
branches;
next	1.66;

1.66
date	2011.07.12.10.30.29;	author espie;	state Exp;
branches;
next	1.65;

1.65
date	2011.06.20.09.46.23;	author espie;	state Exp;
branches;
next	1.64;

1.64
date	2010.12.24.09.04.14;	author espie;	state Exp;
branches;
next	1.63;

1.63
date	2010.10.27.14.35.56;	author espie;	state Exp;
branches;
next	1.62;

1.62
date	2010.08.01.10.03.24;	author espie;	state Exp;
branches;
next	1.61;

1.61
date	2010.07.11.07.27.25;	author espie;	state Exp;
branches;
next	1.60;

1.60
date	2010.06.30.10.51.04;	author espie;	state Exp;
branches;
next	1.59;

1.59
date	2010.06.30.10.41.42;	author espie;	state Exp;
branches;
next	1.58;

1.58
date	2010.06.30.10.37.26;	author espie;	state Exp;
branches;
next	1.57;

1.57
date	2010.06.25.10.34.03;	author espie;	state Exp;
branches;
next	1.56;

1.56
date	2010.06.04.13.19.39;	author espie;	state Exp;
branches;
next	1.55;

1.55
date	2010.05.10.09.17.55;	author espie;	state Exp;
branches;
next	1.54;

1.54
date	2010.04.05.16.07.10;	author espie;	state Exp;
branches;
next	1.53;

1.53
date	2010.04.05.13.46.24;	author espie;	state Exp;
branches;
next	1.52;

1.52
date	2010.03.22.20.38.44;	author espie;	state Exp;
branches;
next	1.51;

1.51
date	2010.01.04.00.10.52;	author espie;	state Exp;
branches;
next	1.50;

1.50
date	2010.01.02.16.51.51;	author espie;	state Exp;
branches;
next	1.49;

1.49
date	2010.01.01.13.00.05;	author espie;	state Exp;
branches;
next	1.48;

1.48
date	2010.01.01.12.57.08;	author espie;	state Exp;
branches;
next	1.47;

1.47
date	2010.01.01.12.47.14;	author espie;	state Exp;
branches;
next	1.46;

1.46
date	2010.01.01.12.46.09;	author espie;	state Exp;
branches;
next	1.45;

1.45
date	2009.12.29.18.16.14;	author espie;	state Exp;
branches;
next	1.44;

1.44
date	2009.12.29.13.51.50;	author espie;	state Exp;
branches;
next	1.43;

1.43
date	2009.12.28.10.42.02;	author espie;	state Exp;
branches;
next	1.42;

1.42
date	2009.12.27.22.24.48;	author espie;	state Exp;
branches;
next	1.41;

1.41
date	2009.12.27.12.39.53;	author espie;	state Exp;
branches;
next	1.40;

1.40
date	2009.12.19.14.21.14;	author espie;	state Exp;
branches;
next	1.39;

1.39
date	2009.12.14.18.11.26;	author espie;	state Exp;
branches;
next	1.38;

1.38
date	2009.12.13.17.58.55;	author espie;	state Exp;
branches;
next	1.37;

1.37
date	2009.12.13.17.54.15;	author espie;	state Exp;
branches;
next	1.36;

1.36
date	2009.12.12.17.08.07;	author espie;	state Exp;
branches;
next	1.35;

1.35
date	2009.12.07.15.09.08;	author espie;	state Exp;
branches;
next	1.34;

1.34
date	2009.12.07.13.41.02;	author espie;	state Exp;
branches;
next	1.33;

1.33
date	2009.12.05.10.08.58;	author espie;	state Exp;
branches;
next	1.32;

1.32
date	2009.12.02.11.36.27;	author espie;	state Exp;
branches;
next	1.31;

1.31
date	2009.11.30.16.15.13;	author espie;	state Exp;
branches;
next	1.30;

1.30
date	2009.11.29.07.54.18;	author espie;	state Exp;
branches;
next	1.29;

1.29
date	2009.11.28.16.46.20;	author espie;	state Exp;
branches;
next	1.28;

1.28
date	2009.11.24.10.50.18;	author espie;	state Exp;
branches;
next	1.27;

1.27
date	2009.11.24.10.28.31;	author espie;	state Exp;
branches;
next	1.26;

1.26
date	2009.11.22.09.18.55;	author espie;	state Exp;
branches;
next	1.25;

1.25
date	2009.11.16.14.42.18;	author espie;	state Exp;
branches;
next	1.24;

1.24
date	2009.11.16.12.20.32;	author espie;	state Exp;
branches;
next	1.23;

1.23
date	2009.11.11.13.00.40;	author espie;	state Exp;
branches;
next	1.22;

1.22
date	2009.11.11.12.47.13;	author espie;	state Exp;
branches;
next	1.21;

1.21
date	2009.11.11.12.32.03;	author espie;	state Exp;
branches;
next	1.20;

1.20
date	2009.11.11.12.21.20;	author espie;	state Exp;
branches;
next	1.19;

1.19
date	2009.11.11.12.04.19;	author espie;	state Exp;
branches;
next	1.18;

1.18
date	2009.11.11.11.17.11;	author espie;	state Exp;
branches;
next	1.17;

1.17
date	2009.11.11.11.13.16;	author espie;	state Exp;
branches;
next	1.16;

1.16
date	2009.11.11.11.01.55;	author espie;	state Exp;
branches;
next	1.15;

1.15
date	2009.11.10.11.36.56;	author espie;	state Exp;
branches;
next	1.14;

1.14
date	2009.11.10.10.35.56;	author espie;	state Exp;
branches;
next	1.13;

1.13
date	2009.11.10.10.28.12;	author espie;	state Exp;
branches;
next	1.12;

1.12
date	2009.11.08.10.46.11;	author espie;	state Exp;
branches;
next	1.11;

1.11
date	2009.11.04.16.50.02;	author espie;	state Exp;
branches;
next	1.10;

1.10
date	2009.10.19.14.07.26;	author espie;	state Exp;
branches;
next	1.9;

1.9
date	2009.10.15.10.45.47;	author espie;	state Exp;
branches;
next	1.8;

1.8
date	2009.10.14.22.59.34;	author espie;	state Exp;
branches;
next	1.7;

1.7
date	2009.10.14.10.38.06;	author espie;	state Exp;
branches;
next	1.6;

1.6
date	2009.10.11.10.53.39;	author espie;	state Exp;
branches;
next	1.5;

1.5
date	2009.10.10.09.27.30;	author espie;	state Exp;
branches;
next	1.4;

1.4
date	2009.04.19.14.58.32;	author espie;	state Exp;
branches;
next	1.3;

1.3
date	2008.03.08.12.07.45;	author espie;	state Exp;
branches;
next	1.2;

1.2
date	2007.06.30.11.38.38;	author espie;	state Exp;
branches;
next	1.1;

1.1
date	2007.06.25.12.21.08;	author espie;	state Exp;
branches;
next	;


desc
@@


1.76
log
@minor clean-up: the stuff not to display is tied to the set, so make the
current_set more explicit in the PkgAdd algorithm...
and clean it up when we clean the set.

Put the "tieing files" stuff into its own function so that the add code
looks a bit less like a spaghetti monster
@
text
@# ex:ts=8 sw=4:
# $OpenBSD: UpdateSet.pm,v 1.75 2014/02/04 18:06:01 espie Exp $
#
# Copyright (c) 2007-2010 Marc Espie <espie@@openbsd.org>
#
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.


# an UpdateSet is a list of packages to remove/install.
# it contains several things:
# -> a list of older packages to remove (installed locations)
# -> a list of newer packages to add (might be very simple locations)
# -> a list of "hints", as package names to install
# -> a list of packages that are kept throughout an update
# every add/remove operations manipulate UpdateSet.
#
# Since older packages are always installed, they're organized as a hash.
#
# XXX: an UpdateSet succeeds or fails "together".
# if several packages should be removed/added, then not being able
# to do stuff on ONE of them is enough to invalidate the whole set.
#
# Normal UpdateSets contain one newer package at most.
# Bigger UpdateSets can be created through the merge operation, which
# will be used only when necessary.
#
# kept packages are needed after merges, where some dependencies may
# not need updating, and to distinguish from old packages that will be
# removed.
#
# for instance, package installation will check UpdateSets for internal
# dependencies and for conflicts. For that to work, we need kept stuff
#
use strict;
use warnings;

# hints should behave like locations
package OpenBSD::hint;
sub new
{
	my ($class, $name) = @@_;
	bless {name => $name}, $class;
}

sub pkgname
{
	return shift->{name};
}

package OpenBSD::hint2;
our @@ISA = qw(OpenBSD::hint);

package OpenBSD::DeleteSet;
sub new
{
	my ($class, $state) = @@_;
	return bless {older => {}}, $class;
}

sub add_older
{
	my $self = shift;
	for my $h (@@_) {
		$self->{older}->{$h->pkgname} = $h;
	}
	return $self;
}

sub older
{
	my $self = shift;
	return values %{$self->{older}};
}

sub older_names
{
	my $self = shift;
	return keys %{$self->{older}};
}

sub all_handles
{
	&older;
}

sub mark_as_finished
{
	my $self = shift;
	$self->{finished} = 1;
}

sub cleanup
{
	my ($self, $error, $errorinfo) = @@_;
	for my $h ($self->all_handles) {
		$h->cleanup($error, $errorinfo);
	}
	if (defined $error) {
		$self->{error} //= $error;
		$self->{errorinfo} //= $errorinfo;
	}
	delete $self->{solver};
	delete $self->{known_mandirs};
	delete $self->{known_displays};
	$self->mark_as_finished;
}

sub has_error
{
	&OpenBSD::Handle::has_error;
}

sub print
{
	my $self = shift;
	return join('+', sort $self->older_names);
}

sub todo_names
{
	&older_names;
}

sub short_print
{
	my $self = shift;
	my $result = join('+', sort $self->todo_names);
	if (length $result > 30) {
		return substr($result, 0, 27)."...";
	} else {
		return $result;
	}
}

sub real_set
{
	my $set = shift;
	while (defined $set->{merged}) {
		$set = $set->{merged};
	}
	return $set;
}

sub merge_set
{
	my ($self, $set) = @@_;
	$self->add_older($set->older);
	$set->mark_as_finished;
	# XXX and mark it as merged, for eventual updates
	$set->{merged} = $self;
}

# Merge several deletesets together
sub merge
{
	my ($self, $tracker, @@sets) = @@_;

	# Apparently simple, just add the missing parts
	for my $set (@@sets) {
		next if $set eq $self;
		$self->merge_set($set);
		$tracker->handle_set($set);
	}
	# then regen tracker info for $self
	$tracker->todo($self);
	return $self;
}

package OpenBSD::UpdateSet;
our @@ISA = qw(OpenBSD::DeleteSet);

sub new
{
	my ($class, $state) = @@_;
	my $o = $class->SUPER::new($state);
	$o->{newer} = {};
	$o->{kept} = {};
	$o->{repo} = $state->repo;
	$o->{hints} = [];
	$o->{updates} = 0;
	return $o;
}

sub path
{
	my $set = shift;

	return $set->{path};
}

sub add_repositories
{
	my ($set, @@repos) = @@_;

	if (!defined $set->{path}) {
		$set->{path} = $set->{repo}->path;
	}
	$set->{path}->add(@@repos);
}

sub merge_paths
{
	my ($set, $other) = @@_;

	if (defined $other->path) {
		if (!defined $set->path) {
			$set->{path} = $other->path;
		} elsif ($set->{path} ne $other->path) {
			$set->add_path(@@{$other->{path}});
		}
	}
}

sub match_locations
{
	my ($set, @@spec) = @@_;
	my $r = [];
	if (defined $set->{path}) {
		$r = $set->{path}->match_locations(@@spec);
	}
	if (@@$r == 0) {
		$r = $set->{repo}->match_locations(@@spec);
	}
	return $r;
}

sub add_newer
{
	my $self = shift;
	for my $h (@@_) {
		$self->{newer}->{$h->pkgname} = $h;
		$self->{updates}++;
	}
	return $self;
}

sub add_kept
{
	my $self = shift;
	for my $h (@@_) {
		$self->{kept}->{$h->pkgname} = $h;
	}
	return $self;
}

sub move_kept
{
	my $self = shift;
	for my $h (@@_) {
		delete $self->{older}{$h->pkgname};
		delete $self->{newer}{$h->pkgname};
		$self->{kept}{$h->pkgname} = $h;
		$h->complete_dependency_info;
		$h->{update_found} = $h;
	}
	return $self;
}

sub add_hints
{
	my $self = shift;
	for my $h (@@_) {
		push(@@{$self->{hints}}, OpenBSD::hint->new($h));
	}
	return $self;
}

sub add_hints2
{
	my $self = shift;
	for my $h (@@_) {
		push(@@{$self->{hints}}, OpenBSD::hint2->new($h));
	}
	return $self;
}

sub newer
{
	my $self = shift;
	return values %{$self->{newer}};
}

sub kept
{
	my $self = shift;
	return values %{$self->{kept}};
}

sub hints
{
	my $self = shift;
	return @@{$self->{hints}};
}

sub newer_names
{
	my $self = shift;
	return keys %{$self->{newer}};
}

sub kept_names
{
	my $self = shift;
	return keys %{$self->{kept}};
}

sub all_handles
{
	my $self = shift;
	return ($self->older, $self->newer, $self->kept);
}

sub hint_names
{
	my $self = shift;
	return map {$_->pkgname} $self->hints;
}

sub older_to_do
{
	my $self = shift;
	# XXX in `combined' updates, some dependencies may remove extra
	# packages, so we do a double-take on the list of packages we
	# are actually replacing... for now, until we merge update sets.
	require OpenBSD::PackageInfo;
	my @@l = ();
	for my $h ($self->older) {
		if (OpenBSD::PackageInfo::is_installed($h->pkgname)) {
			push(@@l, $h);
		}
	}
	return @@l;
}

sub print
{
	my $self = shift;
	my $result = "";
	if ($self->kept > 0) {
		$result = "[".join('+', sort $self->kept_names)."]";
	}
	# XXX common case
	if ($self->newer == 1 && $self->older == 1) {
		my ($a, $b) = ($self->older_names, $self->newer_names);
		my $stema = OpenBSD::PackageName::splitstem($a);
		my ($stemb, @@rest) = OpenBSD::PackageName::splitname($b);
		if ($stema eq $stemb) {
			return $result .$a."->".join('-', @@rest);
		}
	}

	if ($self->older > 0) {
		$result .= $self->SUPER::print."->";
	}
	if ($self->newer > 0) {
		$result .= join('+', sort $self->newer_names);
	} elsif ($self->hints > 0) {
		$result .= join('+', sort $self->hint_names);
	}
	return $result;
}

sub todo_names
{
	my $self = shift;
	if ($self->newer > 0) {
		return $self->newer_names;
	} else {
		return $self->kept_names;
	}
}

sub validate_plists
{
	my ($self, $state) = @@_;
	$state->{problems} = 0;
	delete $state->{overflow};

	$state->{current_set} = $self;

	for my $o ($self->older_to_do) {
		require OpenBSD::Delete;
		OpenBSD::Delete::validate_plist($o->{plist}, $state);
	}
	$state->{colliding} = [];
	for my $n ($self->newer) {
		require OpenBSD::Add;
		OpenBSD::Add::validate_plist($n->{plist}, $state, $self);
	}
	if (@@{$state->{colliding}} > 0) {
		require OpenBSD::CollisionReport;

		OpenBSD::CollisionReport::collision_report($state->{colliding}, $state, $self);
	}
	if (defined $state->{overflow}) {
		$state->vstat->tally;
		# okay, let's retry the other way around if we haven't yet
		if (!defined $state->{delete_first}) {
			if ($state->defines('deletefirst') ||
			    $state->confirm("Delete older packages first", 0)) {
				$state->{delete_first} = 1;
				$state->vstat->drop_changes;
				return $self->validate_plists($state);
			}
		}
	}
	if ($state->{problems}) {
		$state->vstat->drop_changes;
		return 0;
	} else {
		$state->vstat->synchronize;
		return 1;
	}
}

sub cleanup_old_shared
{
	my ($set, $state) = @@_;
	my $h = $set->{old_shared};

	for my $d (sort {$b cmp $a} keys %$h) {
		OpenBSD::SharedItems::wipe_directory($state, $h, $d) ||
		    $state->fatal("Can't continue");
		delete $state->{recorder}{dirs}{$d};
	}
}

sub create_new
{
	my ($class, $pkgname) = @@_;
	my $set = $class->new;
	$set->add_newer(OpenBSD::Handle->create_new($pkgname));
	return $set;
}

sub from_location
{
	my ($class, $location) = @@_;
	my $set = $class->new;
	$set->add_newer(OpenBSD::Handle->from_location($location));
	return $set;
}

my @@extra = qw(solver conflict_cache);
sub mark_as_finished
{
	my $self = shift;
	for my $i (@@extra, 'sha') {
		delete $self->{$i};
	}
	$self->SUPER::mark_as_finished;
}

sub merge_if_exists
{
	my ($self, $k, @@extra) = @@_;

	my @@list = ();
	for my $s (@@extra) {
		if ($s ne $self && defined $s->{$k}) {
			push(@@list, $s->{$k});
		}
	}
	$self->$k->merge(@@list);
}

sub merge_set
{
	my ($self, $set) = @@_;
	$self->SUPER::merge_set($set);
	$self->add_newer($set->newer);
	$self->add_kept($set->kept);
	$self->merge_paths($set);
	$self->{updates} += $set->{updates};
	$set->{updates} = 0;
}

# Merge several updatesets together
sub merge
{
	my ($self, $tracker, @@sets) = @@_;

	for my $i (@@extra) {
		$self->merge_if_exists($i, @@sets);
	}
	return $self->SUPER::merge($tracker, @@sets);
}

1;
@


1.75
log
@prevent updates from starting with a lone ":"
Some UpdateSets will only contain kept packages, BUT require the update
of some dependencies.

just spew out the kept_names instead of newer_names in that case.
@
text
@d2 1
a2 1
# $OpenBSD: UpdateSet.pm,v 1.74 2014/02/02 15:22:36 espie Exp $
d113 2
@


1.74
log
@simplify how "kept" packages are handled. First, we never need their
full plist, just their update_info. Also, the routine for move_kept is
pretty much always the same, so fold it.

Finally, delay full plists in create_old.
@
text
@d2 1
a2 1
# $OpenBSD: UpdateSet.pm,v 1.73 2014/02/01 18:54:01 espie Exp $
d373 6
a378 1
	&newer_names;
@


1.73
log
@style
@
text
@d2 1
a2 1
# $OpenBSD: UpdateSet.pm,v 1.72 2014/01/31 11:54:24 espie Exp $
d261 2
@


1.72
log
@no longer a need for the solver, which is fortunate as this creates
a cycle (in perl -current at least).

found by careful usage of Devel::Leak::Object and going back in time to
2007...
@
text
@d2 1
a2 1
# $OpenBSD: UpdateSet.pm,v 1.71 2014/01/30 12:38:51 espie Exp $
d258 3
a260 3
		delete $self->{older}->{$h->pkgname};
		delete $self->{newer}->{$h->pkgname};
		$self->{kept}->{$h->pkgname} = $h;
@


1.71
log
@don't create empty entries
@
text
@d2 1
a2 1
# $OpenBSD: UpdateSet.pm,v 1.70 2012/09/06 09:07:50 espie Exp $
d112 1
@


1.70
log
@shorter display for trivial updatesets,
foo-0.0->foo-1.0
becomes
foo-0.0->1.0
@
text
@d2 1
a2 1
# $OpenBSD: UpdateSet.pm,v 1.69 2011/07/17 13:18:07 espie Exp $
d108 4
a111 2
	$self->{error} //= $error;
	$self->{errorinfo} //= $errorinfo;
@


1.69
log
@now that the API is working, reorg the code correctly: DeleteSet is the
base class, and UpdateSet adds stuff to it.

During cleanup, also clean-up kept packages, there's no reason not to.
@
text
@d2 1
a2 1
# $OpenBSD: UpdateSet.pm,v 1.68 2011/07/13 12:57:27 espie Exp $
d345 10
@


1.68
log
@let short_print work on DeleteSets
@
text
@d2 1
a2 1
# $OpenBSD: UpdateSet.pm,v 1.67 2011/07/13 12:32:15 espie Exp $
d63 111
d175 1
d180 7
a186 2
	return bless {newer => {}, older => {}, kept => {},
	    hints => [], updates => 0, repo => $state->repo}, $class;
a231 19
sub cleanup
{
	my ($self, $error, $errorinfo) = @@_;
	for my $h ($self->older, $self->newer) {
		$h->cleanup($error, $errorinfo);
	}
	$self->{error} //= $error;
	$self->{errorinfo} //= $errorinfo;
	delete $self->{solver};
	delete $self->{conflict_cache};
	delete $self->{sha};
	$self->{finished} = 1;
}

sub has_error
{
	&OpenBSD::Handle::has_error;
}

a241 9
sub add_older
{
	my $self = shift;
	for my $h (@@_) {
		$self->{older}->{$h->pkgname} = $h;
	}
	return $self;
}

a285 6
sub older
{
	my $self = shift;
	return values %{$self->{older}};
}

d298 1
a298 1
sub older_names
d301 1
a301 1
	return keys %{$self->{older}};
d304 1
a304 1
sub newer_names
d307 1
a307 1
	return keys %{$self->{newer}};
d310 1
a310 1
sub kept_names
d313 1
a313 1
	return keys %{$self->{kept}};
d346 1
a346 1
		$result .= $self->old_print."->";
a355 6
sub old_print
{
	my $self = shift;
	return join('+', sort $self->older_names);
}

d358 1
a358 12
	&OpenBSD::UpdateSet::newer_names;
}

sub short_print
{
	my $self = shift;
	my $result = join('+', sort $self->todo_names);
	if (length $result > 30) {
		return substr($result, 0, 27)."...";
	} else {
		return $result;
	}
d432 10
d455 11
d471 2
a472 29
	$self->merge_if_exists('solver', @@sets);
	$self->merge_if_exists('conflict_cache', @@sets);
	# Apparently simple, just add the missing parts
	for my $set (@@sets) {
		next if $set eq $self;
		$self->add_newer($set->newer);
		$self->add_older($set->older);
		$self->add_kept($set->kept);
		$self->merge_paths($set);
		# ... and mark it as already done
		$set->{finished} = 1;
		$tracker->handle_set($set);
		$self->{updates} += $set->{updates};
		$set->{updates} = 0;
		# XXX and mark it as merged, for eventual updates
		$set->{merged} = $self;
		delete $set->{solver};
		delete $set->{conflict_cache};
	}
	# then regen tracker info for $self
	$tracker->todo($self);
	return $self;
}

sub real_set
{
	my $set = shift;
	while (defined $set->{merged}) {
		$set = $set->{merged};
d474 1
a474 13
	return $set;
}

package OpenBSD::DeleteSet;
our @@ISA = qw(OpenBSD::UpdateSet);
sub print
{
	&OpenBSD::UpdateSet::old_print;
}

sub todo_names
{
	&OpenBSD::UpdateSet::older_names;
@


1.67
log
@create DeleteSet as a specialized version of UpdateSets that print
differently, specialize the states a wee little bit.
@
text
@d2 1
a2 1
# $OpenBSD: UpdateSet.pm,v 1.66 2011/07/12 10:30:29 espie Exp $
d279 5
d287 1
a287 1
	my $result = join('+', sort $self->newer_names);
d422 5
@


1.66
log
@new pkg_delete, very similar to pkg_add, support for -a
@
text
@d2 1
a2 1
# $OpenBSD: UpdateSet.pm,v 1.65 2011/06/20 09:46:23 espie Exp $
d263 1
a263 1
		$result .= $self->delete_print."->";
d273 1
a273 1
sub delete_print
d410 7
@


1.65
log
@in an UpdateSet, match new files with old files based on their sha256.
avoid extracting again identical files, leading to less file system churn.
put in a few failsafes (size check) for people with fubar'd file
systems (hey oga@@).

The more often you update, the more you gain. Over 6 months, about one
out of five files doesn't change.

apparently, improves things a lot on slow fs, as said landry@@ and sthen@@.
tested by quite a few people.
@
text
@d2 1
a2 1
# $OpenBSD: UpdateSet.pm,v 1.64 2010/12/24 09:04:14 espie Exp $
d263 1
a263 1
		$result .= join('+',sort $self->older_names)."->";
d271 6
@


1.64
log
@handle failures from ports tree with more care.
this does avoid infinite loops in case of wrong plists.
necessary since print-plist-with-depends CAN fail...
@
text
@d2 1
a2 1
# $OpenBSD$
d125 1
@


1.63
log
@initial scaffolding for @@rcscript: for now, acts like normal files,
but allow absolute pathnames (treat that as an implicit @@cwd).
@
text
@@


1.62
log
@fix the qt 4.5 -> 4.6 update issue.
since we usually deal with directories in a global way, replacing a
directory with something else didn't work.
the fix is to record removed directories in Vstat in a "lazy" way:
we only test these objects for existence if we add something else at
the same location. Since this happens rarely, we can afford to perform
the whole SharedItems dance twice...
@
text
@d2 1
a2 1
# $OpenBSD: UpdateSet.pm,v 1.61 2010/07/11 07:27:25 espie Exp $
@


1.61
log
@display updateset name alongside collisionreport (turns out it's not
always obvious)
@
text
@d2 1
a2 1
# $OpenBSD: UpdateSet.pm,v 1.60 2010/06/30 10:51:04 espie Exp $
d289 2
d323 12
@


1.60
log
@allow say and errsay to work without parameters, as it's ways common.
create verbose_system up in state, because it makes sense without verbose.
@
text
@d2 1
a2 1
# $OpenBSD$
d301 1
a301 1
		OpenBSD::CollisionReport::collision_report($state->{colliding}, $state);
@


1.59
log
@whitespace cleanup
@
text
@@


1.58
log
@extra parameter to UpdateSet: use the factory to create extra object.
don't create updatesets directly, go through AddDelete::State.
Get all Locator/Repo access through state.
@
text
@d2 1
a2 1
# $OpenBSD: UpdateSet.pm,v 1.57 2010/06/25 10:34:03 espie Exp $
d68 1
a68 1
	return bless {newer => {}, older => {}, kept => {}, 
@


1.57
log
@do options the other way so that we provide defaults that can be overridden
locally
@
text
@d2 1
a2 1
# $OpenBSD$
d67 3
a69 3
	my $class = shift;
	return bless {newer => {}, older => {}, kept => {}, hints => [], updates => 0},
	    $class;
d84 1
a84 3
		require OpenBSD::PackageRepositoryList;

		$set->{path} = OpenBSD::PackageRepositoryList->new;
d110 1
a110 2
		require OpenBSD::PackageLocator;
		$r = OpenBSD::PackageLocator->match_locations(@@spec);
@


1.56
log
@move code around, so that commands can be used as modules.
pkg becomes the start hub, which does nothing except require the
correct module.
Saner code wrt Add/Delete, and more sharing.
@
text
@d2 1
a2 1
# $OpenBSD: UpdateSet.pm,v 1.55 2010/05/10 09:17:55 espie Exp $
@


1.55
log
@whitespace fixes
@
text
@d2 1
a2 1
# $OpenBSD$
d310 1
a310 1
			if ($state->{defines}->{deletefirst} ||
@


1.54
log
@new keyword, @@ask-update, to be used *very* sparingly (so far, only useful
for pgsql updates)
@
text
@d68 1
a68 1
	return bless {newer => {}, older => {}, kept => {}, hints => [], updates => 0}, 
d75 1
a75 1
	
d244 2
a245 2
	# XXX in `combined' updates, some dependencies may remove extra 
	# packages, so we do a double-take on the list of packages we 
d310 1
a310 1
			if ($state->{defines}->{deletefirst} || 
@


1.53
log
@clean-up validate_plists a bit, so that it starts with a clean state.
new feature: if a normal updateset order does not fit, let the user decide
to do a "dangerous update", by deleting older packages first (if they fit).
tweak really_add to do so: move delete old packages out of the way, and add
a new state variable (extracted_first) to distinguish between both replace
modes.
@
text
@d299 1
a299 1
		OpenBSD::Add::validate_plist($n->{plist}, $state);
@


1.52
log
@clean up the ProgressMeter code, create a specific class if a Term
is around.
start using stuff from termcap, specifically, cleareol, and move to hp.
use the full line when we can, cram 100% if we can.
(this should flicker much less on slow terminals).

clean-up the install-and-progress bits to be in progressmeter, this removes
some code.

have pkg_create follow the same pattern as the others, with a state.
This allows us to unify error messages a bit.
@
text
@d290 1
d308 9
@


1.51
log
@There's no reason for -l to imply -z.

Also, fix a nasty bug: when finding installed packages in a set, don't
remove them silently, just tag them to be kept, and let tracker know about
it (fixes loop1 regress)
@
text
@a316 8
sub compute_size
{
	my ($self, $state) = @@_;
	for my $h ($self->older_to_do, $self->newer) {
		$h->{totsize} = $h->{plist}->compute_size;
	}
}

@


1.50
log
@keep going after collisions
@
text
@d169 1
@


1.49
log
@(C) of affected files
@
text
@d308 5
a312 2
		require OpenBSD::Error;
		OpenBSD::Error::Fatal "fatal issues in ", $self->short_print;
a313 1
	$state->vstat->synchronize;
@


1.48
log
@make the merge_paths operations visible
@
text
@d4 1
a4 1
# Copyright (c) 2007-2009 Marc Espie <espie@@openbsd.org>
@


1.47
log
@make updatesets aware of repository paths
@
text
@d91 13
d364 1
a364 7
		if (defined $set->path) {
			if (!defined $self->path) {
				$self->{path} = $set->path;
			} elsif ($set->{path} ne $self->path) {
				$self->add_path(@@{$set->{path}});
			}
		}
@


1.46
log
@propagate errorinfo thru set->cleanup (finally better messages than
can't install)
@
text
@d72 33
d351 7
@


1.45
log
@a few more tweaks:
- allow for merged updates if we want them
- deplist becomes a hash, maybe useful for big sets
- simplify loop checking. We don't actually care whether we find any.
- be more aggressive in keeping cached stuff, create solver or conflict_cache
if need be.
@
text
@d74 1
a74 1
	my ($self, $error) = @@_;
d76 1
a76 1
		$h->cleanup($error);
d79 1
@


1.44
log
@prepare for smarter sets, with cache info
@
text
@d108 9
d230 6
a235 1
	return join('+', sort $self->newer_names);
d295 5
a299 2
	if (defined $self->{$k}) {
		$self->{$k}->merge(map {$_->{$k}} @@extra);
d301 1
d313 1
d316 1
d324 2
a328 3
	if (defined $self->{solver}) {
		delete $self->{solver}->{deplist};
	}
@


1.43
log
@nits
@
text
@d80 1
d277 9
d290 3
d307 3
a309 1
	delete $self->{solver};
@


1.42
log
@solver is no longer needed at that point, so kill it. this shaves a bit of
memory.
@
text
@d137 1
a137 1
	my $self =shift;
d155 1
a155 1
	my $self =shift;
d167 1
a167 1
	my $self =shift;
d179 1
a179 1
	my $self =shift;
@


1.41
log
@sort
@
text
@d79 1
@


1.40
log
@create a $state->todo method to account for sets to install.
have tracker keep track of sets not done, and ask it directly for how many
there's still to do. Provide an offset into next for cases where we know
we already did a set but haven't accounted for it yet.
-> more accurate number of sets still to do.
@
text
@d203 1
a203 1
		$result = "[".join('+', $self->kept_names)."]";
d206 1
a206 1
		$result .= join('+',$self->older_names)."->";
d209 1
a209 1
		$result .= join('+', $self->newer_names);
d211 1
a211 1
		$result .= join('+', $self->hint_names);
d219 1
a219 1
	return join('+', $self->newer_names);
@


1.39
log
@since some packages in updatesets don't need updates, be explicit about it.
This is more complex and simpler at the same time...
@
text
@d285 1
@


1.38
log
@okay, so old libs are not 'kept', keep track of updates correctly instead
@
text
@d4 1
a4 1
# Copyright (c) 2007 Marc Espie <espie@@openbsd.org>
d20 1
a20 1
# it contains three things:
d24 1
d36 8
d68 1
a68 1
	return bless {newer => {}, older => {}, hints => [], updates => 0}, 
d106 10
d146 6
d170 6
d191 1
a191 2
		if (!defined $h->{keepit} && 
		    OpenBSD::PackageInfo::is_installed($h->pkgname)) {
d202 3
@


1.37
log
@simplify set printing
@
text
@d83 1
d252 2
@


1.36
log
@fix the fam->libgamin issue. Look for update candidates in self before
asking the repository. This solves this kind of conflicts.
also, register packages we keep, this makes for simpler scenarios
(todo: split updateset into further categories)
@
text
@d170 1
a170 14
	my @@l = ();
	if ($self->newer > 0) {
		push(@@l, "installing", $self->newer_names);
	}
	if ($self->older > 0) {
		push(@@l, "deinstalling", $self->older_names);
	}
	return join(' ', @@l);
}

sub short_print
{
	my $self = shift;
	my @@l = ();
d172 1
a172 1
		push(@@l, join('+',$self->older_names));
d175 1
a175 1
		push(@@l, join('+', $self->newer_names));
d177 1
a177 1
		push(@@l, join('+', $self->hint_names));
d179 1
a179 1
	return join('->', @@l);
d182 1
a182 1
sub shorter_print
@


1.35
log
@don't use $set->print, consistent messages.
@
text
@d159 2
a160 1
		if (OpenBSD::PackageInfo::is_installed($h->pkgname)) {
a265 1
		$self->{updates} += $set->{updates};
@


1.34
log
@simplify tracker a bit now we know what we're doing.
kill code that never got used
@
text
@d224 1
a224 1
		OpenBSD::Error::Fatal "fatal issues in ", $self->print;
@


1.33
log
@make quirks silent. Track # of updates found, instead of newer size, since
we may end up updating sets with newer == 0
@
text
@a260 2
		# BUT XXX tell the tracker we killed the set
		$tracker->remove_set($set);
d268 1
a268 1
	$tracker->add_set($self);
@


1.32
log
@fix some inter-dependencies case:
- when we merge updatesets, invalidate the solver (there isn't any, usually).
- look inside set for check_depends.
- do register_dependencies after committing all plists to cache.
@
text
@d59 2
a60 1
	return bless {newer => {}, older => {}, hints => []}, $class;
d267 1
@


1.31
log
@better errors: have $set->cleanup mark set as finished.
in case there is an issue, register set as not updateable with tracker.
@
text
@d269 1
@


1.30
log
@slightly simpler error handling
@
text
@d69 1
@


1.29
log
@prepare for "better" merge: we can't just wipe the old set, we have to point
it to the new set, as tracker stuff may still know about it.
@
text
@d62 1
a62 1
sub set_error
d65 2
a66 2
	for my $h ($self->older) {
		$h->set_error($error);
d68 6
@


1.28
log
@sets that were not solved should still display something...
@
text
@d55 1
d62 8
d257 2
d263 9
@


1.27
log
@more regular. Note that newer can be a hash as well (why not ?)
@
text
@d171 2
@


1.26
log
@change the timing a bit: create a list of updateset first, and process
them later.

To do that, normal additions go through hint2, and the findtruelocation
code moves to Update.pm

This will allow for more systematic handling of all names (including solving
more stuff on the fly, instead of upfront).
@
text
@d58 1
a58 1
	return bless {newer => [], older => {}, hints => []}, $class;
d63 4
a66 2
	my ($self, @@handles) = @@_;
	push(@@{$self->{newer}}, @@handles);
d70 1
a70 1
sub add_hints
d72 3
a74 3
	my ($self, @@hints) = @@_;
	for my $h (@@hints) {
		push(@@{$self->{hints}}, OpenBSD::hint->new($h));
d79 1
a79 1
sub add_hints2
d81 3
a83 3
	my ($self, @@hints) = @@_;
	for my $h (@@hints) {
		push(@@{$self->{hints}}, OpenBSD::hint2->new($h));
d88 1
a88 1
sub add_older
d92 1
a92 1
		$self->{older}->{$h->pkgname} = $h;
d100 1
a100 1
	return @@{$self->{newer}};
a113 5
sub hint_names
{
	my $self =shift;
	return map {$_->pkgname} $self->hints;
}
d124 7
a130 1
	return map {$_->pkgname} $self->newer;
d240 2
a241 6
		for my $p ($set->newer) {
			$self->add_newer($p);
		}
		for my $p ($set->older) {
			$self->add_older($p);
		}
@


1.25
log
@create a pseudo vstat object inside state, so that we can modify Vstat
interface very locally...

model hints objects like Locations, to uniformize further treatment.
@
text
@d51 3
d73 9
@


1.24
log
@start pulling all the code that's the same between pkg_add and pkg_delete
into a common AddDelete package... lots of identical options and handling,
actually...
@
text
@d38 13
d68 3
a70 1
	push(@@{$self->{hints}}, @@hints);
d100 5
d186 1
a186 1
		OpenBSD::Vstat::tally();
d192 1
a192 1
	OpenBSD::Vstat::synchronize();
@


1.23
log
@vsystem, system, unlink can mostly go through state, and do the ->clear part
as well.
@
text
@a18 193
# these things don't really live here, they're just stuff that's shared
# between pkg_add and pkg_delete, so to avoid yes another header...

use strict;
use warnings;

package OpenBSD::SharedItemsRecorder;
sub new
{
	my $class = shift;
	return bless {}, $class;
}

sub is_empty
{
	my $self = shift;
	return !(defined $self->{dirs} or defined $self->{users} or
		defined $self->{groups});
}

sub cleanup
{
	my ($self, $state) = @@_;
	return if $self->is_empty or $state->{not};

	require OpenBSD::SharedItems;
	OpenBSD::SharedItems::cleanup($self, $state);
}

package OpenBSD::Log;
use OpenBSD::Error;
our @@ISA = qw(OpenBSD::Error);

sub set_context
{
	&OpenBSD::Error::set_pkgname;
}

sub dump
{
	&OpenBSD::Error::delayed_output;
}


package OpenBSD::pkg_foo::State;
use OpenBSD::Error;

sub new
{
	my $class = shift;
	my $o = bless {}, $class;
	$o->init(@@_);
	return $o;
}

sub init
{
	my $self = shift;
	$self->{l} = OpenBSD::Log->new;
	$self->{progressmeter} = bless {}, "OpenBSD::StubProgress";
}

sub log
{
	my $self = shift;
	if (@@_ == 0) {
		return $self->{l};
	} else {
		$self->{l}->print(@@_);
	}
}

sub print
{
	my $self = shift;
	$self->progress->print(@@_);
}

sub say
{
	my $self = shift;
	$self->progress->print(@@_, "\n");
}

sub errprint
{
	my $self = shift;
	$self->progress->errprint(@@_);
}

sub errsay
{
	my $self = shift;
	$self->progress->errprint(@@_, "\n");
}

sub progress
{
	my $self = shift;
	return $self->{progressmeter};
}

sub vsystem
{
	my $self = shift;
	$self->progress->clear;
	OpenBSD::Error::VSystem($self->{very_verbose}, @@_);
}

sub system
{
	my $self = shift;
	$self->progress->clear;
	OpenBSD::Error::System(@@_);
}

sub unlink
{
	my $self = shift;
	$self->progress->clear;
	OpenBSD::Error::Unlink(@@_);
}

# we always have a progressmeter we can print to...
sub setup_progressmeter
{
	my ($self, $opt_x) = @@_;
	if (!$opt_x && !$self->{beverbose}) {
		require OpenBSD::ProgressMeter;
		$self->{progressmeter} = OpenBSD::ProgressMeter->new;
	}
}

sub check_root
{
	my $state = shift;
	if ($< && !$state->{defines}->{nonroot}) {
		if ($state->{not}) {
			$state->errsay("$0 should be run as root");
		} else {
			Fatal "$0 must be run as root";
		}
	}
}

sub choose_location
{
	my ($state, $name, $list) = @@_;
	if (@@$list == 0) {
		$state->say("Can't find $name");
		return undef;
	} elsif (@@$list == 1) {
		return $list->[0];
	}

	my %h = map {($_->name, $_)} @@$list;
	if ($state->{interactive}) {
		require OpenBSD::Interactive;

		$h{'<None>'} = undef;
		$state->progress->clear;
		my $result = OpenBSD::Interactive::ask_list("Ambiguous: choose package for $name", 1, sort keys %h);
		return $h{$result};
	} else {
		$state->say("Ambiguous: $name could be ", join(' ', keys %h));
		return undef;
	}
}

# stub class when no actual progressmeter that still prints out.
package OpenBSD::StubProgress;
sub clear {}

sub show {}

sub message {}

sub next {}

sub set_header {}

sub print
{
	shift;
	print @@_;
}

sub errprint
{
	shift;
	print STDERR @@_;
}

d35 3
a218 41
}

package OpenBSD::PackingList;
sub compute_size
{
	my $plist = shift;
	my $totsize = 0;
	$plist->visit('compute_size', \$totsize);
	$totsize = 1 if $totsize == 0;
	$plist->{totsize} = $totsize;
}

package OpenBSD::PackingElement;
sub mark_progress
{
}

sub compute_size
{
}

package OpenBSD::PackingElement::FileBase;
sub mark_progress
{
	my ($self, $progress, $donesize, $totsize) = @@_;
	return unless defined $self->{size};
	$$donesize += $self->{size};
	$progress->show($$donesize, $totsize);
}

sub compute_size
{
	my ($self, $totsize) = @@_;

	$$totsize += $self->{size} if defined $self->{size};
}

package OpenBSD::PackingElement::Sample;
sub compute_size
{
	&OpenBSD::PackingElement::FileBase::compute_size;
@


1.22
log
@remove redirector: if we want to run system AND log, just say so
@
text
@d121 21
@


1.21
log
@don't use Warn if we've got a $state, get through errprint/errsay.
Also: reset lastdisplay on clear, and don't clear twice.
@
text
@a114 6
sub system
{
	my $self = shift;
	$self->log->system(@@_);
}

@


1.20
log
@also get most STDERR messages through the same way
@
text
@d142 1
a142 1
			Warn "$0 should be run as root\n";
@


1.19
log
@progressmeter puts STDOUT in autoflush if -t, so that it can display to it instead of piping a lot of stuff to STDERR.

Go through state->print for most messages, so they will NOT do weird things
with the progressmeter.
Use a ->say shortcut which does the same thing that perl 5.10 say does...
@
text
@d103 12
d189 6
@


1.18
log
@make things so that $state->print always work, with or without progressmeter,
even before we set it up.
@
text
@d97 6
d141 1
a141 1
		$state->print("Can't find $name\n");
d156 1
a156 2
		$state->print("Ambiguous: $name could be ", 
		    join(' ', keys %h), "\n");
d176 1
a176 1
	print STDERR @@_;
@


1.17
log
@remove forwarders, and provide a sensible API that says what's going on
(e.g., we're logging information for later).
@
text
@d78 1
d91 6
a115 2
	} else {
		$self->{progressmeter} = bless {}, "OpenBSD::StubProgress";
d135 1
a135 1
		$state->progress->print("Can't find $name\n");
d150 1
a150 1
		$state->progress->print("Ambiguous: $name could be ", 
@


1.16
log
@bad idea to inherit from Error, compose object instead
@
text
@d48 15
d77 1
a77 1
	$self->{l} = OpenBSD::Error->new;
d83 5
a87 31
	return $self->{l};
}

sub set_pkgname
{
	my $self = shift;
	$self->log->set_pkgname(@@_);
}

sub print
{
	my $self = shift;
	$self->log->print(@@_);
}

sub warn
{
	my $self = shift;
	$self->log->warn(@@_);
}

sub fatal
{
	my $self = shift;
	$self->log->fatal(@@_);
}

sub delayed_output
{
	my $self = shift;
	$self->log->delayed_output(@@_);
@


1.15
log
@bad espie: use strict/warnings consistently, and fix two nits and two
actual errors !
@
text
@d50 56
a105 1
our @@ISA=(qw(OpenBSD::Error));
@


1.14
log
@zap handle method, we finally no longer use it.
@
text
@d22 3
@


1.13
log
@document what's going on...
@
text
@a282 12
# temporary shortcut
sub handle
{
	my $self = shift;
	if (defined $self->{newer}) {
		return $self->{newer}[0];
	} else {
		return undef;
	}
}

# temporary creator
@


1.12
log
@add the notion of "hints" to UpdateSet, in order to unify -z/-l handling:
create updatesets with nothing but a hint of what to install. Have
Update.pm do the dirty work.

More importantly, make Tracker aware of what's going on.
@
text
@d18 4
d55 1
d104 1
d122 16
@


1.11
log
@cleanup a bit printouts
@
text
@d2 1
a2 1
# $OpenBSD: UpdateSet.pm,v 1.10 2009/10/19 14:07:26 espie Exp $
d120 1
a120 1
	return bless {newer => [], older => {}}, $class;
d130 7
d156 6
@


1.10
log
@basic routines to handle the merging of updatesets: mark updatesets as
already done, separate remove/mark_installed in tracker, create a merge
method that allows the merging of updatesets.
@
text
@d2 1
a2 1
# $OpenBSD$
d197 1
a197 1
		push(@@l, join(' ',$self->older_names));
d200 1
a200 1
		push(@@l, join(' ', $self->newer_names));
d202 7
a208 1
	return join(' -> ', @@l);
@


1.9
log
@let handle compute pkgnames correctly, simplifies code a bit
@
text
@d270 22
@


1.8
log
@move OpenBSD::Handle into its own file. I guess I need to disentangle this
code before I go further....
@
text
@d134 1
a134 1
		$self->{older}->{$h->{pkgname}} = $h;
d160 1
a160 1
	return map {$_->{pkgname}} $self->newer;
d172 1
a172 1
		if (OpenBSD::PackageInfo::is_installed($h->{pkgname})) {
@


1.7
log
@add a "print" method to ProgressMeter and StubProgress to allow me to clean
up the current mess (e.g., print things out to stderr without needing to
explicitly clear the current line if needed).

create a choose_location method directly in state, that will replace all
instances of looking for a package eventually (hopefully).
@
text
@a115 78
# fairly non-descriptive name. Used to store various package information
# during installs and updates.
package OpenBSD::Handle;

use constant {
	BAD_PACKAGE => 1,
	CANT_INSTALL => 2,
	ALREADY_INSTALLED => 3,
	NOT_FOUND => 4
};

sub new
{
	my $class = shift;
	return bless {}, $class;
}

sub set_error
{
	my ($self, $error) = @@_;
	$self->{error} = $error;
}

sub has_error
{
	my ($self, $error) = @@_;
	if (!defined $self->{error}) {
		return undef;
	}
	if (defined $error) {
		return $self->{error} eq $error;
	}
	return $self->{error};
}

sub create_old
{

	my ($class, $pkgname, $state) = @@_;
	my $self= $class->new;
	$self->{pkgname} = $pkgname;

	require OpenBSD::PackageRepository::Installed;

	my $location = OpenBSD::PackageRepository::Installed->new->find($pkgname, $state->{arch});
	if (!defined $location) {
		$self->set_error(NOT_FOUND);
    	} else {
		$self->{location} = $location;
		my $plist = $location->plist;
		if (!defined $plist) {
			$self->set_error(BAD_PACKAGE);
		} else {
			$self->{plist} = $plist;
		}
	}
	return $self;
}

sub create_new
{
	my ($class, $pkg) = @@_;
	my $handle = $class->new;
	$handle->{pkgname} = $pkg;
	$handle->{tweaked} = 0;
	return $handle;
}

sub from_location
{
	my ($class, $location) = @@_;
	my $handle = $class->new;
	$handle->{pkgname} = $location->name;
	$handle->{location} = $location;
	$handle->{tweaked} = 0;
	return $handle;
}

@


1.6
log
@store installed packages in a hash, since we have simple keys for that.
provide newer_names/older_names methods, and a shorter print version of
an updateset (to display during update since it's no longer quite pkg_add -r)
@
text
@d74 25
d109 6
@


1.5
log
@have modifiers return self so we can chain them
@
text
@d167 1
a167 1
	return bless {newer => [], older => []}, $class;
d179 4
a182 2
	my ($self, @@handles) = @@_;
	push(@@{$self->{older}}, @@handles);
d195 13
a207 1
	return @@{$self->{older}};
d230 2
a231 2
	if (defined $self->{newer}) {
		push(@@l, "installing", map {$_->{pkgname}} $self->newer);
d233 2
a234 2
	if (defined $self->{older} && @@{$self->{older}} > 0) {
		push(@@l, "deinstalling", map {$_->{pkgname}} $self->older);
d237 13
@


1.4
log
@synch with my new style search/location changes
It's likely there will be some fallout, but it's getting a bit too large
to keep around.
This does kill a few very old oddities as well.
@
text
@d174 1
d181 1
@


1.3
log
@rename forced to defines
@
text
@d157 1
a157 1
	$handle->{pkgname} = $location->{name};
@


1.2
log
@move the UpdateSet stuff into its separate file, leaving Vstat much cleaner.
@
text
@d2 1
a2 1
# $OpenBSD: UpdateSet.pm,v 1.1 2007/06/25 12:21:08 espie Exp $
d65 1
a65 1
	if ($< && !$state->{forced}->{nonroot}) {
@


1.1
log
@placeholder to split off the code that handles UpdateSets, as it's
currently scattered all over the place.
@
text
@d2 1
a2 1
# $OpenBSD$
d17 311
@

