head	1.89;
access;
symbols
	OPENBSD_6_2:1.89.0.8
	OPENBSD_6_2_BASE:1.89
	OPENBSD_6_1:1.89.0.12
	OPENBSD_6_1_BASE:1.89
	OPENBSD_6_0:1.89.0.10
	OPENBSD_6_0_BASE:1.89
	OPENBSD_5_9:1.89.0.4
	OPENBSD_5_9_BASE:1.89
	OPENBSD_5_8:1.89.0.6
	OPENBSD_5_8_BASE:1.89
	OPENBSD_5_7:1.89.0.2
	OPENBSD_5_7_BASE:1.89
	OPENBSD_5_6:1.88.0.6
	OPENBSD_5_6_BASE:1.88
	OPENBSD_5_5:1.88.0.4
	OPENBSD_5_5_BASE:1.88
	OPENBSD_5_4:1.84.0.6
	OPENBSD_5_4_BASE:1.84
	OPENBSD_5_3:1.84.0.4
	OPENBSD_5_3_BASE:1.84
	OPENBSD_5_2:1.84.0.2
	OPENBSD_5_2_BASE:1.84
	OPENBSD_5_1_BASE:1.83
	OPENBSD_5_1:1.83.0.2
	OPENBSD_5_0:1.82.0.2
	OPENBSD_5_0_BASE:1.82
	OPENBSD_4_9:1.80.0.2
	OPENBSD_4_9_BASE:1.80
	OPENBSD_4_8:1.77.0.2
	OPENBSD_4_8_BASE:1.77
	OPENBSD_4_7:1.69.0.2
	OPENBSD_4_7_BASE:1.69
	OPENBSD_4_6:1.49.0.4
	OPENBSD_4_6_BASE:1.49
	OPENBSD_4_5:1.47.0.2
	OPENBSD_4_5_BASE:1.47
	OPENBSD_4_4:1.45.0.2
	OPENBSD_4_4_BASE:1.45
	OPENBSD_4_3:1.43.0.2
	OPENBSD_4_3_BASE:1.43
	OPENBSD_4_2:1.42.0.2
	OPENBSD_4_2_BASE:1.42
	OPENBSD_4_1:1.3.0.2
	OPENBSD_4_1_BASE:1.3
	OPENBSD_4_0:1.2.0.2
	OPENBSD_4_0_BASE:1.2;
locks; strict;
comment	@# @;


1.89
date	2014.11.29.10.42.51;	author espie;	state Exp;
branches;
next	1.88;
commitid	XiRgNGt76qJ9BWZO;

1.88
date	2014.02.11.08.58.34;	author sthen;	state Exp;
branches;
next	1.87;

1.87
date	2014.01.11.11.54.43;	author espie;	state Exp;
branches;
next	1.86;

1.86
date	2014.01.09.20.20.01;	author espie;	state Exp;
branches;
next	1.85;

1.85
date	2014.01.07.13.26.18;	author espie;	state Exp;
branches;
next	1.84;

1.84
date	2012.04.28.12.00.10;	author espie;	state Exp;
branches;
next	1.83;

1.83
date	2011.08.23.10.32.27;	author espie;	state Exp;
branches;
next	1.82;

1.82
date	2011.06.25.11.10.11;	author espie;	state Exp;
branches;
next	1.81;

1.81
date	2011.06.20.09.46.23;	author espie;	state Exp;
branches;
next	1.80;

1.80
date	2010.12.24.09.04.14;	author espie;	state Exp;
branches;
next	1.79;

1.79
date	2010.10.28.22.33.43;	author espie;	state Exp;
branches;
next	1.78;

1.78
date	2010.10.27.14.35.56;	author espie;	state Exp;
branches;
next	1.77;

1.77
date	2010.07.28.15.06.14;	author espie;	state Exp;
branches;
next	1.76;

1.76
date	2010.06.30.10.51.04;	author espie;	state Exp;
branches;
next	1.75;

1.75
date	2010.06.30.10.41.42;	author espie;	state Exp;
branches;
next	1.74;

1.74
date	2010.06.30.10.09.09;	author espie;	state Exp;
branches;
next	1.73;

1.73
date	2010.06.09.07.26.01;	author espie;	state Exp;
branches;
next	1.72;

1.72
date	2010.06.04.13.19.39;	author espie;	state Exp;
branches;
next	1.71;

1.71
date	2010.05.10.09.17.55;	author espie;	state Exp;
branches;
next	1.70;

1.70
date	2010.03.22.20.38.44;	author espie;	state Exp;
branches;
next	1.69;

1.69
date	2010.01.18.10.04.53;	author espie;	state Exp;
branches;
next	1.68;

1.68
date	2010.01.11.12.25.38;	author espie;	state Exp;
branches;
next	1.67;

1.67
date	2009.12.29.20.34.10;	author espie;	state Exp;
branches;
next	1.66;

1.66
date	2009.12.28.21.30.09;	author espie;	state Exp;
branches;
next	1.65;

1.65
date	2009.12.28.12.51.26;	author espie;	state Exp;
branches;
next	1.64;

1.64
date	2009.12.27.15.32.20;	author espie;	state Exp;
branches;
next	1.63;

1.63
date	2009.12.26.17.00.49;	author espie;	state Exp;
branches;
next	1.62;

1.62
date	2009.12.20.22.38.45;	author espie;	state Exp;
branches;
next	1.61;

1.61
date	2009.12.17.08.21.09;	author espie;	state Exp;
branches;
next	1.60;

1.60
date	2009.12.14.18.11.26;	author espie;	state Exp;
branches;
next	1.59;

1.59
date	2009.12.14.09.12.43;	author espie;	state Exp;
branches;
next	1.58;

1.58
date	2009.12.13.17.57.57;	author espie;	state Exp;
branches;
next	1.57;

1.57
date	2009.11.29.11.22.25;	author espie;	state Exp;
branches;
next	1.56;

1.56
date	2009.11.29.06.51.12;	author espie;	state Exp;
branches;
next	1.55;

1.55
date	2009.11.17.10.17.21;	author espie;	state Exp;
branches;
next	1.54;

1.54
date	2009.11.11.12.32.03;	author espie;	state Exp;
branches;
next	1.53;

1.53
date	2009.11.11.12.04.19;	author espie;	state Exp;
branches;
next	1.52;

1.52
date	2009.11.10.11.36.56;	author espie;	state Exp;
branches;
next	1.51;

1.51
date	2009.10.15.10.45.47;	author espie;	state Exp;
branches;
next	1.50;

1.50
date	2009.10.11.11.51.22;	author espie;	state Exp;
branches;
next	1.49;

1.49
date	2009.04.19.14.58.32;	author espie;	state Exp;
branches;
next	1.48;

1.48
date	2009.03.05.10.44.59;	author espie;	state Exp;
branches;
next	1.47;

1.47
date	2008.10.24.16.50.27;	author espie;	state Exp;
branches;
next	1.46;

1.46
date	2008.10.07.06.29.36;	author espie;	state Exp;
branches;
next	1.45;

1.45
date	2008.06.11.09.43.25;	author espie;	state Exp;
branches;
next	1.44;

1.44
date	2008.03.08.12.07.45;	author espie;	state Exp;
branches;
next	1.43;

1.43
date	2008.03.02.23.43.32;	author espie;	state Exp;
branches;
next	1.42;

1.42
date	2007.06.18.10.47.03;	author espie;	state Exp;
branches;
next	1.41;

1.41
date	2007.06.16.11.50.49;	author espie;	state Exp;
branches;
next	1.40;

1.40
date	2007.06.10.15.11.05;	author espie;	state Exp;
branches;
next	1.39;

1.39
date	2007.06.09.11.16.54;	author espie;	state Exp;
branches;
next	1.38;

1.38
date	2007.06.09.10.30.53;	author espie;	state Exp;
branches;
next	1.37;

1.37
date	2007.06.07.20.41.01;	author espie;	state Exp;
branches;
next	1.36;

1.36
date	2007.06.07.12.57.33;	author espie;	state Exp;
branches;
next	1.35;

1.35
date	2007.06.06.15.31.06;	author espie;	state Exp;
branches;
next	1.34;

1.34
date	2007.06.06.14.09.47;	author espie;	state Exp;
branches;
next	1.33;

1.33
date	2007.06.05.23.11.01;	author espie;	state Exp;
branches;
next	1.32;

1.32
date	2007.06.04.16.33.23;	author espie;	state Exp;
branches;
next	1.31;

1.31
date	2007.06.04.14.40.39;	author espie;	state Exp;
branches;
next	1.30;

1.30
date	2007.06.01.22.35.46;	author espie;	state Exp;
branches;
next	1.29;

1.29
date	2007.06.01.22.06.03;	author espie;	state Exp;
branches;
next	1.28;

1.28
date	2007.06.01.21.50.47;	author espie;	state Exp;
branches;
next	1.27;

1.27
date	2007.06.01.14.58.29;	author espie;	state Exp;
branches;
next	1.26;

1.26
date	2007.06.01.12.19.00;	author espie;	state Exp;
branches;
next	1.25;

1.25
date	2007.05.30.14.04.51;	author espie;	state Exp;
branches;
next	1.24;

1.24
date	2007.05.30.13.03.54;	author espie;	state Exp;
branches;
next	1.23;

1.23
date	2007.05.30.12.52.07;	author espie;	state Exp;
branches;
next	1.22;

1.22
date	2007.05.27.22.39.09;	author espie;	state Exp;
branches;
next	1.21;

1.21
date	2007.05.27.22.34.24;	author espie;	state Exp;
branches;
next	1.20;

1.20
date	2007.05.27.21.43.06;	author espie;	state Exp;
branches;
next	1.19;

1.19
date	2007.05.27.21.33.55;	author espie;	state Exp;
branches;
next	1.18;

1.18
date	2007.05.26.23.45.44;	author espie;	state Exp;
branches;
next	1.17;

1.17
date	2007.05.22.11.02.57;	author espie;	state Exp;
branches;
next	1.16;

1.16
date	2007.05.20.11.06.44;	author espie;	state Exp;
branches;
next	1.15;

1.15
date	2007.05.20.10.48.48;	author espie;	state Exp;
branches;
next	1.14;

1.14
date	2007.05.20.10.38.50;	author espie;	state Exp;
branches;
next	1.13;

1.13
date	2007.05.20.10.20.07;	author espie;	state Exp;
branches;
next	1.12;

1.12
date	2007.05.14.11.22.00;	author espie;	state Exp;
branches;
next	1.11;

1.11
date	2007.05.14.10.43.45;	author espie;	state Exp;
branches;
next	1.10;

1.10
date	2007.05.12.22.50.31;	author espie;	state Exp;
branches;
next	1.9;

1.9
date	2007.05.07.09.32.51;	author espie;	state Exp;
branches;
next	1.8;

1.8
date	2007.05.07.08.24.16;	author espie;	state Exp;
branches;
next	1.7;

1.7
date	2007.05.02.15.09.04;	author espie;	state Exp;
branches;
next	1.6;

1.6
date	2007.05.02.15.05.30;	author espie;	state Exp;
branches;
next	1.5;

1.5
date	2007.04.29.11.09.29;	author espie;	state Exp;
branches;
next	1.4;

1.4
date	2007.04.15.10.17.29;	author espie;	state Exp;
branches;
next	1.3;

1.3
date	2006.11.17.15.34.15;	author espie;	state Exp;
branches;
next	1.2;

1.2
date	2006.04.22.10.31.44;	author bernd;	state Exp;
branches;
next	1.1;

1.1
date	2006.03.04.11.31.18;	author espie;	state Exp;
branches;
next	;


desc
@@


1.89
log
@simplify the interactive code into its own little object with simpler
interface, so that most is it interactive tests vanish from the main
program.
@
text
@# ex:ts=8 sw=4:
# $OpenBSD: Replace.pm,v 1.88 2014/02/11 08:58:34 sthen Exp $
#
# Copyright (c) 2004-2014 Marc Espie <espie@@openbsd.org>
#
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF

use strict;
use warnings;

use OpenBSD::Delete;

package OpenBSD::PackingElement;
sub can_update
{
	my ($self, $installing, $state) = @@_;

	my $issue = $self->update_issue($installing);

	if (defined $issue) {
	    	push(@@{$state->{journal}}, $issue);
	}
}

sub update_issue { undef }

package OpenBSD::PackingElement::Exec;
sub update_issue
{
	my ($self, $installing) = @@_;
	return if !$installing;
	return '@@'.$self->keyword.' '.$self->{expanded};
}

package OpenBSD::PackingElement::ExecAdd;
sub update_issue { undef }

package OpenBSD::PackingElement::Unexec;
sub update_issue
{
	my ($self, $installing) = @@_;

	return if $installing;

	return '@@'.$self->keyword.' '.$self->{expanded};
}

package OpenBSD::PackingElement::UnexecDelete;
sub update_issue { undef }

package OpenBSD::Replace;

sub check_plist_exec
{
	my ($plist, $state, $new) = @@_;

	$state->{journal} = [];
	$plist->can_update($new, $state);
	return 1 if @@{$state->{journal}} == 0;

	$state->errsay(($new ? "New": "Old").
	    " package #1 will run the following commands", $plist->pkgname);
	for my $i (@@{$state->{journal}}) {
		if ($new) {
			$state->errsay("+ #1", $i);
		} else {
			$state->errsay("- #1", $i);
		}
	}
	return 0;
}

sub can_old_package_be_replaced
{
	my ($plist, $state) = @@_;
	return check_plist_exec($plist, $state, 0);
}

sub is_new_package_safe
{
	my ($plist, $state) = @@_;
	return check_plist_exec($plist, $state, 1);
}

sub is_set_safe
{
	my ($set, $state) = @@_;

	if (!$state->defines('paranoid') && !$state->verbose) {
		return 1;
	}

	my $ok = 1;

	for my $pkg ($set->older) {
		$ok = 0 unless can_old_package_be_replaced($pkg->plist, $state);
	}
	for my $pkg ($set->newer) {
		$ok = 0 unless is_new_package_safe($pkg->plist, $state);
	}
	return 1 if $ok;

	if (!$state->defines('paranoid')) {
		$state->errsay("Running update");
		return 1;
	} elsif ($state->is_interactive) {
		if ($state->confirm("proceed with update anyway", 0)) {
			return 1;
		} else {
			return 0;
		}
	} else {
		$state->errsay("Cannot install #1",
		    $set->print);
		return 0;
    	}
}


1;
@


1.88
log
@s/anyways/anyway/, ok espie@@
@
text
@d2 1
a2 1
# $OpenBSD: Replace.pm,v 1.87 2014/01/11 11:54:43 espie Exp $
d115 1
a115 2
	} elsif ($state->{interactive}) {

@


1.87
log
@simplify code: always extract, then install, so that initial installations
and updates are more similar.
@
text
@d2 1
a2 1
# $OpenBSD: Replace.pm,v 1.86 2014/01/09 20:20:01 espie Exp $
d117 1
a117 1
		if ($state->confirm("proceed with update anyways", 0)) {
@


1.86
log
@bump copyright to 2014
@
text
@d2 1
a2 1
# $OpenBSD: Replace.pm,v 1.85 2014/01/07 13:26:18 espie Exp $
a35 103
sub extract
{
	my ($self, $state) = @@_;
	$state->{partial}->{$self} = 1;
	if ($state->{interrupted}) {
		die "Interrupted";
	}
}

package OpenBSD::PackingElement::FileBase;
use OpenBSD::Temp;

sub extract
{
	my ($self, $state) = @@_;

	my $file = $self->prepare_to_extract($state);

	if (defined $self->{link} || defined $self->{symlink}) {
		$state->{archive}->skip;
		return;
	}

	$self->SUPER::extract($state);

	# figure out a safe directory where to put the temp file
	my $d = dirname($file->{destdir}.$file->name);
	# we go back up until we find an existing directory.
	# hopefully this will be on the same file system.
	while (!-d $d && -e _ || defined $state->{noshadow}->{$d}) {
		$d = dirname($d);
	}
	if ($state->{not}) {
		$state->say("extracting tempfile under #1", $d)
		    if $state->verbose >= 3;
		$state->{archive}->skip;
	} else {
		if (!-e _) {
			File::Path::mkpath($d);
		}
		my ($fh, $tempname) = OpenBSD::Temp::permanent_file($d, "pkg");
		$self->{tempname} = $tempname;

		# XXX don't apply destdir twice
		$file->{destdir} = '';
		$file->set_name($tempname);

		if ($self->{tieto}) {
			my $src = $self->{tieto}->realname($state);
			unlink($tempname);
			$state->say("linking #1 to #2", $src, $tempname)
			    if $state->verbose >= 3;
			if (link($src, $tempname) ||
			    $state->copy_file($src, $tempname)) {
				# we still need to adjust properties
				$file->set_modes;
				$state->{archive}->skip;
				return;
			}
			# okay, it didn't work. recreate tempname.
			open $fh, ">", $tempname;
		}

		$state->say("extracting #1", $tempname) if $state->verbose >= 3;

		$file->create;
		$self->may_check_digest($file, $state);
	}
}

package OpenBSD::PackingElement::Dir;
sub extract
{
	my ($self, $state) = @@_;
	my $fullname = $self->fullname;
	my $destdir = $state->{destdir};

	return if -e $destdir.$fullname;
	$self->SUPER::extract($state);
	$state->say("new directory #1", $destdir.$fullname)
	    if $state->verbose >= 3;
	return if $state->{not};
	File::Path::mkpath($destdir.$fullname);
}


package OpenBSD::PackingElement::Sample;
sub extract
{
}

package OpenBSD::PackingElement::Sampledir;
sub extract
{
}

package OpenBSD::PackingElement::SpecialFile;
sub extract
{
	my ($self, $state) = @@_;
	$self->may_verify_digest($state);
}

a60 10

sub perform_extraction
{
	my ($handle, $state) = @@_;

	$handle->{partial} = {};
	$state->{partial} = $handle->{partial};
	$state->{archive} = $handle->{location};
	$state->progress->visit_with_size($handle->{plist}, 'extract', $state);
}
@


1.85
log
@let's verify all checksums.
I forgot about special files, since they've been extracted early,
but they can be checked nonetheless.

(prevents people from tampering with DESC and the like)
@
text
@d2 1
a2 1
# $OpenBSD: Replace.pm,v 1.84 2012/04/28 12:00:10 espie Exp $
d4 1
a4 1
# Copyright (c) 2004-2010 Marc Espie <espie@@openbsd.org>
@


1.84
log
@zap blank spaces
@
text
@d2 1
a2 1
# $OpenBSD$
d130 7
@


1.83
log
@zap old INSTALL/DEINSTALL stuff, it's been deprecated for 3 years, and removed
from pkg_create for over a year.
@
text
@d2 1
a2 1
# $OpenBSD: Replace.pm,v 1.82 2011/06/25 11:10:11 espie Exp $
d86 1
a86 1
			$state->say("linking #1 to #2", $src, $tempname) 
@


1.82
log
@even with tied files, still arrange to apply set_modes.

issue noted by halex@@
@
text
@d2 1
a2 1
# $OpenBSD: Replace.pm,v 1.81 2011/06/20 09:46:23 espie Exp $
a129 23
}

package OpenBSD::PackingElement::ScriptFile;
sub update_issue
{
	my ($self, $installing) = @@_;
	return $self->name." script";
}

package OpenBSD::PackingElement::FINSTALL;
sub update_issue
{
	my ($self, $installing) = @@_;
	return if !$installing;
	return $self->SUPER::update_issue($installing);
}

package OpenBSD::PackingElement::FDEINSTALL;
sub update_issue
{
	my ($self, $installing) = @@_;
	return if $installing;
	return $self->SUPER::update_issue($installing);
@


1.81
log
@in an UpdateSet, match new files with old files based on their sha256.
avoid extracting again identical files, leading to less file system churn.
put in a few failsafes (size check) for people with fubar'd file
systems (hey oga@@).

The more often you update, the more you gain. Over 6 months, about one
out of five files doesn't change.

apparently, improves things a lot on slow fs, as said landry@@ and sthen@@.
tested by quite a few people.
@
text
@d2 1
a2 1
# $OpenBSD: Replace.pm,v 1.80 2010/12/24 09:04:14 espie Exp $
d78 5
d90 2
a100 3
		# XXX don't apply destdir twice
		$file->{destdir} = '';
		$file->set_name($tempname);
@


1.80
log
@handle failures from ports tree with more care.
this does avoid infinite loops in case of wrong plists.
necessary since print-plist-with-depends CAN fail...
@
text
@d2 1
a2 1
# $OpenBSD$
d77 14
a92 1
		$self->{tempname} = $tempname;
@


1.79
log
@:-P
@
text
@d2 1
a2 1
# $OpenBSD: Replace.pm,v 1.78 2010/10/27 14:35:56 espie Exp $
@


1.78
log
@initial scaffolding for @@rcscript: for now, acts like normal files,
but allow absolute pathnames (treat that as an implicit @@cwd).
@
text
@d2 1
a2 1
# $OpenBSD$
d210 1
a210 1
	if ($state->defines('update') && !$state->verbose) {
d224 2
a225 2
	if ($state->defines('update')) {
		$state->errsay("Forcing update");
d235 1
a235 1
		$state->errsay("Cannot install #1 (use -D update)",
@


1.77
log
@more explicit message
@
text
@d2 1
a2 1
# $OpenBSD: Replace.pm,v 1.76 2010/06/30 10:51:04 espie Exp $
@


1.76
log
@allow say and errsay to work without parameters, as it's ways common.
create verbose_system up in state, because it makes sense without verbose.
@
text
@d2 1
a2 1
# $OpenBSD$
d183 1
a183 1
	    " package #1 contains potentially unsafe operations", $plist->pkgname);
@


1.75
log
@whitespace cleanup
@
text
@@


1.74
log
@differentiate more between @@exec and @@unexec
@
text
@d2 1
a2 1
# $OpenBSD: Replace.pm,v 1.73 2010/06/09 07:26:01 espie Exp $
d182 1
a182 1
	$state->errsay(($new ? "New": "Old"). 
@


1.73
log
@ui changes: go thru a state object for most printouts
@
text
@d2 1
a2 1
# $OpenBSD: Replace.pm,v 1.72 2010/06/04 13:19:39 espie Exp $
d185 5
a189 1
		$state->errsay("| #1", $i);
@


1.72
log
@move code around, so that commands can be used as modules.
pkg becomes the start hub, which does nothing except require the
correct module.
Saner code wrt Add/Delete, and more sharing.
@
text
@d2 1
a2 1
# $OpenBSD: Replace.pm,v 1.71 2010/05/10 09:17:55 espie Exp $
d69 1
a69 1
		$state->say("extracting tempfile under $d")
d78 1
a78 1
		$state->say("extracting $tempname") if $state->verbose >= 3;
d98 1
a98 1
	$state->say("new directory ", $destdir, $fullname)
d182 2
a183 2
	$state->errsay($new ? "New": "Old", " package ", $plist->pkgname,
	    " contains potentially unsafe operations");
d185 1
a185 1
		$state->errsay("| ", $i);
d231 2
a232 2
		$state->errsay("Cannot install ", $set->print,
		    " (use -D update)");
@


1.71
log
@whitespace fixes
@
text
@d2 1
a2 1
# $OpenBSD$
d206 1
a206 1
	if ($state->{defines}->{update} && !$state->verbose) {
d220 1
a220 1
	if ($state->{defines}->{update}) {
@


1.70
log
@clean up the ProgressMeter code, create a specific class if a Term
is around.
start using stuff from termcap, specifically, cleareol, and move to hp.
use the full line when we can, cram 100% if we can.
(this should flicker much less on slow terminals).

clean-up the install-and-progress bits to be in progressmeter, this removes
some code.

have pkg_create follow the same pattern as the others, with a state.
This allows us to unify error messages a bit.
@
text
@d28 1
a28 1
	
d58 1
a58 1
	
d69 1
a69 1
		$state->say("extracting tempfile under $d") 
d98 1
a98 1
	$state->say("new directory ", $destdir, $fullname) 
d117 1
a117 1
{ 
d124 1
a124 1
{ 
d132 1
a132 1
{ 
d140 1
a140 1
{ 
d151 1
a151 1
{ 
d182 1
a182 1
	$state->errsay($new ? "New": "Old", " package ", $plist->pkgname, 
d231 1
a231 1
		$state->errsay("Cannot install ", $set->print, 
@


1.69
log
@don't bother checking for exec and displaying them if we're not verbose
and we have -D update on.
@
text
@a39 6
}

sub extract_and_progress
{
	my ($self, $state, $donesize, $totsize) = @@_;
	$self->extract($state);
a42 1
	$self->mark_progress($state->progress, $donesize, $totsize);
a169 1
	my $totsize = $handle->{totsize};
d171 1
a171 3
	my $donesize = 0;
	$state->{donesize} = 0;
	$handle->{plist}->extract_and_progress($state, \$donesize, $totsize);
@


1.68
log
@move the oldlibs code into its separate file, prior to fixing it.
allow replacement if it only touches partial or libs
@
text
@d216 4
@


1.67
log
@temporary fix for .libs update issue.
@
text
@d4 1
a4 1
# Copyright (c) 2004-2006 Marc Espie <espie@@openbsd.org>
a41 14
sub mark_lib
{
}

sub unmark_lib
{
}

sub separate_element
{
	my ($self, $libs, $c1, $c2) = @@_;
	$c2->{$self} = 1;
}

a51 23
package OpenBSD::PackingElement::Meta;

sub separate_element
{
	my ($self, $libs, $c1, $c2) = @@_;
	$c1->{$self} = 1;
	$c2->{$self} = 1;
}

package OpenBSD::PackingElement::DigitalSignature;
sub separate_element
{
	my ($self, $libs, $c1, $c2) = @@_;
	$c2->{$self} = 1;
}

package OpenBSD::PackingElement::State;

sub separate_element
{
	&OpenBSD::PackingElement::Meta::separate_element;
}

a168 52
package OpenBSD::PackingElement::Depend;
sub separate_element
{
	&OpenBSD::PackingElement::separate_element;
}

package OpenBSD::PackingElement::SpecialFile;
sub separate_element
{
	&OpenBSD::PackingElement::separate_element;
}

package OpenBSD::PackingElement::Dependency;
use OpenBSD::Error;

package OpenBSD::PackingElement::Lib;
sub mark_lib
{
	my ($self, $libs, $libpatterns) = @@_;
	my $libname = $self->fullname;
	my ($stem, $major, $minor, $dir) = $self->parse($libname);
	if (defined $stem) {
		$libpatterns->{$stem}->{$dir} = [$major, $minor, $libname];
	}
	$libs->{$libname} = 1;
}

sub separate_element
{
	my ($self, $libs, $c1, $c2) = @@_;
	if ($libs->{$self->fullname}) {
		$c1->{$self} = 1;
	} else {
		$c2->{$self} = 1;
	}
}

sub unmark_lib
{
	my ($self, $libs, $libpatterns) = @@_;
	my $libname = $self->fullname;
	my ($stem, $major, $minor, $dir) = $self->parse($libname);
	if (defined $stem) {
		my $p = $libpatterns->{$stem}->{$dir};
		if (defined $p && $p->[0] == $major && $p->[1] <= $minor) {
			my $n = $p->[2];
			delete $libs->{$n};
		}
	}
	delete $libs->{$libname};
}

a169 4
use OpenBSD::RequiredBy;
use OpenBSD::PackingList;
use OpenBSD::PackageInfo;
use OpenBSD::Error;
d238 1
a238 1
		    " (use -F update)");
a242 125

sub split_some_libs
{
	my ($plist, $libs) = @@_;
	my $c1 = {};
	my $c2 = {};
	$plist->separate_element($libs, $c1, $c2);
	my $p1 = $plist->make_deep_copy($c1);
	my $p2 = $plist->make_shallow_copy($c2);
	return ($p1, $p2);
}

# create a packing-list with only the libraries we want to keep around.
sub split_libs
{
	my ($plist, $to_split) = @@_;

	(my $splitted, $plist) = split_some_libs($plist, $to_split);

	require OpenBSD::PackageInfo;

	$splitted->set_pkgname(OpenBSD::PackageInfo::libs_package($plist->pkgname));

	if (defined $plist->{'no-default-conflict'}) {
		# we conflict with the package we just removed...
		OpenBSD::PackingElement::Conflict->add($splitted, $plist->pkgname);
	} else {
		require OpenBSD::PackageName;

		my $stem = OpenBSD::PackageName::splitstem($plist->pkgname);
		OpenBSD::PackingElement::Conflict->add($splitted, $stem."-*");
	}
	return ($plist, $splitted);
}

sub adjust_depends_closure
{
	my ($oldname, $plist, $state) = @@_;

	$state->say("Packages that depend on those shared libraries:") 
	    if $state->verbose >= 3;

	my $write = OpenBSD::RequiredBy->new($plist->pkgname);
	for my $pkg (OpenBSD::RequiredBy->compute_closure($oldname)) {
		$state->say("\t", $pkg) if $state->verbose >= 3;
		$write->add($pkg);
		my $r = OpenBSD::Requiring->new($pkg)->add($plist->pkgname);
		if ($oldname =~ m/^\.libs\d*\-/o) {
			$r->delete($oldname);
		}
	}
}

sub do_save_libs
{
	my ($o, $libs, $state) = @@_;

	my $oldname = $o->pkgname;

	($o->{plist}, my $stub_list) = split_libs($o->plist, $libs);
	my $stub_name = $stub_list->pkgname;
	my $dest = installed_info($stub_name);
	$state->say("Keeping them in $stub_name") 
	    if $state->verbose >= 2;


	if ($state->{not}) {
		require OpenBSD::SharedLibs;

		OpenBSD::SharedLibs::add_libs_from_plist($stub_list);
		$stub_list->to_cache;
		$o->plist->to_cache;
	} else {
		mkdir($dest);
		open my $descr, '>', $dest.DESC;
		print $descr "Stub libraries for $oldname\n";
		close $descr;
		my $f = OpenBSD::PackingElement::FDESC->add($stub_list, DESC);
		$f->{ignore} = 1;
		$f->add_digest($f->compute_digest($dest.DESC));
		$stub_list->to_installation;
		$o->plist->to_installation;
	}
	add_installed($stub_name);

	require OpenBSD::PkgCfl;
	OpenBSD::PkgCfl::register($stub_list, $state);

	adjust_depends_closure($oldname, $stub_list, $state);
}

sub save_libs_from_handle
{
	my ($o, $set, $state) = @@_;

	my $libs = {};
	my $p = {};

	$state->say("Looking for changes in shared libraries") 
	    if $state->verbose >= 2;
	$o->plist->mark_lib($libs, $p);
	for my $n ($set->newer) {
		$n->plist->unmark_lib($libs, $p);
	}
	for my $n ($set->kept) {
		$n->plist->unmark_lib($libs, $p);
	}

	if (%$libs) {
		$state->say("Libraries to keep: ", 
		    join(",", sort(keys %$libs))) if $state->verbose >= 2;
		do_save_libs($o, $libs, $state);
	} else {
		$state->say("No libraries to keep") if $state->verbose >= 2;
	}
}

sub save_old_libraries
{
	my ($set, $state) = @@_;

	for my $o ($set->older) {
		save_libs_from_handle($o, $set, $state);
	}
}
@


1.66
log
@kill old dependency adjuster
@
text
@d382 4
a385 1
		OpenBSD::Requiring->new($pkg)->add($plist->pkgname);
@


1.65
log
@move code around a bit, more functions. Especially do the exec check
ways later, when we're certain we're not going to change the set any longer,
so we don't need to go back.
@
text
@a458 10
			
sub adjust_dependency
{
	my ($dep, $from, $into) = @@_;

	my $l = OpenBSD::Requiring->new($dep);
	$l->delete($from);
	$l->add($into);
}

@


1.64
log
@don't ask/report the same exec issue twice
@
text
@a311 1
		next if defined $pkg->{exec_checked};
a312 1
		$pkg->{exec_checked} = 1;
a314 1
		next if defined $pkg->{exec_checked};
a315 1
		$pkg->{exec_checked} = 1;
@


1.63
log
@Better, more global way of dealing with forward dependencies, and to
ask just once per-set for exec/unexec.

Todo: forward-deps could be merged, but this might lead to dependency
loops, we have to detect them and act first

Todo: rewrite the other part of forward dependency handling (dep adjustment)
@
text
@d312 1
d314 1
d317 1
d319 1
@


1.62
log
@change verbosity handling: be silent by default, turn on the first level if -v.
Add more levels, specifically, lots of info regarding individual files only
visible if -vvvvv.
Make -n display the same stuff as normal (need -n -v to display more stuff).
Introduce -s, "size-only", turns on -n and does skip any extraction.
Sprinkle handlers for SIG_INFO, not really nice yet.

Note that -n is non functional for complex updates, because of caching
issues I have to fix.
@
text
@a29 1
		$state->{okay} = 0;
a33 4
sub validate_depend
{
}

a220 27
sub validate_depend
{
	my ($self, $state, $wanting, $toreplace, @@replacement) = @@_;

	# nothing to validate if old dependency doesn't concern us.
	return unless $self->spec->filter($toreplace);
	# nothing to do if new dependency just matches
	return if $self->spec->filter(@@replacement);

	if ($state->{defines}->{updatedepends}) {
	    $state->errsay("Forward dependency of $wanting on $toreplace doesn't match @@replacement, forcing it");
	    $state->{forcedupdates} = {} unless defined $state->{forcedupdates};
	    $state->{forcedupdates}->{$wanting} = 1;
	} elsif ($state->{interactive}) {

	    if ($state->confirm("Forward dependency of $wanting on $toreplace doesn't match @@replacement, proceed with update anyways", 0)) {
		$state->{forcedupdates} = {} unless defined $state->{forcedupdates};
		$state->{forcedupdates}->{$wanting} = 1;
	    } else {
		$state->{okay} = 0;
	    }
	} else {
	    $state->{okay} = 0;
	    $state->errsay("Can't update forward dependency of $wanting on $toreplace: @@replacement doesn't match (use -F updatedepends to force it)");
	}
}

d277 1
a277 1
sub can_old_package_be_replaced
d279 1
a279 1
	my ($old_plist, $set, $state) = @@_;
a280 1
	$state->{okay} = 1;
d282 7
a288 16
	$old_plist->can_update(0, $state);
	if ($state->{okay} == 0) {
		$state->errsay("Old package ", $old_plist->pkgname, 
		    " contains potentially unsafe operations");
		for my $i (@@{$state->{journal}}) {
			$state->errsay("\t", $i);
		}
		if ($state->{defines}->{update}) {
			$state->errsay("(forcing update)");
			$state->{okay} = 1;
		} elsif ($state->{interactive}) {

			if ($state->confirm("proceed with update anyways", 0)) {
			    $state->{okay} = 1;
			}
		}
d290 7
a296 21
	my @@wantlist = OpenBSD::RequiredBy->new($old_plist->pkgname)->list;
	my @@r = ();
	for my $wanting (@@wantlist) {
		push(@@r, $wanting) if !defined $set->{older}->{$wanting};
	}
	if (@@r) {
		$state->say("Verifying dependencies still match for ", 
		    join(', ', @@r)) if $state->verbose >= 2;
		for my $wanting (@@wantlist) {
			my $p2 = OpenBSD::PackingList->from_installation(
			    $wanting, \&OpenBSD::PackingList::DependOnly);
			if (!defined $p2) {
				$state->errsay("Error: $wanting missing from installation");
			} else {
				$p2->validate_depend($state, $wanting, 
				    $old_plist->pkgname, $set->newer_names, 
				    $set->kept_names);
			}
		}
	}
	return $state->{okay};
d302 26
a327 8
	$state->{okay} = 1;
	$state->{journal} = [];
	$plist->can_update(1, $state);
	if ($state->{okay} == 0) {
		$state->errsay("New package ", $plist->pkgname, 
		    " contains potentially unsafe operations");
		for my $i (@@{$state->{journal}}) {
			$state->errsay("\t", $i);
d329 5
a333 10
		if ($state->{defines}->{update}) {
			$state->errsay("(forcing update)");
			$state->{okay} = 1;
		} elsif ($state->{interactive}) {
			if ($state->confirm("proceed with update anyways", 0)) {
			    $state->{okay} = 1;
			}
		}
	}
	return $state->{okay};
d335 1
@


1.61
log
@display progressmeter at 0% at start of install/deinstall.
(better synch for packages that start with a huge binary)
@
text
@d119 1
a119 1
		    if $state->{very_verbose};
d127 1
a127 1
		$state->say("extracting $tempname") if $state->{very_verbose};
d148 1
a148 1
	    if $state->{very_verbose};
d339 1
a339 1
		    join(', ', @@r)) if $state->{verbose};
d418 1
a418 1
	    if $state->{beverbose};
d422 1
a422 1
		$state->say("\t", $pkg) if $state->{beverbose};
d438 1
a438 1
	    if $state->{verbose};
d474 1
a474 1
	    if $state->{beverbose};
d485 1
a485 1
		    join(",", sort(keys %$libs))) if $state->{verbose};
d488 1
a488 1
		$state->say("No libraries to keep") if $state->{verbose};
@


1.60
log
@since some packages in updatesets don't need updates, be explicit about it.
This is more complex and simpler at the same time...
@
text
@d439 2
d442 3
@


1.59
log
@temporary fix for kept packages until we move them away
@
text
@d347 2
a348 1
				    $old_plist->pkgname, $set->newer_names);
d474 1
a474 2
	for my $n ($set->older) {
		next unless $n->{keepit};
a491 1
		next if $o->{keepit};
@


1.58
log
@clean up code, no functional change
@
text
@d473 4
d492 1
@


1.57
log
@clean up conflict handling and dependency adjustement: build list
of conflict globally, add it as old handles, and then use it everywhere.
@
text
@d427 55
d488 1
a488 45

		my $oldname = $o->pkgname;
		my $libs = {};
		my $p = {};

		$state->say("Looking for changes in shared libraries") 
		    if $state->{beverbose};
		$o->{plist}->mark_lib($libs, $p);
		for my $n ($set->newer) {
			$n->{plist}->unmark_lib($libs, $p);
		}

		if (%$libs) {
			$state->say("Libraries to keep: ", 
			    join(",", sort(keys %$libs))) 
			    if $state->{verbose};
			($o->{plist}, my $stub_list) = split_libs($o->{plist}, $libs);
			my $stub_name = $stub_list->pkgname;
			my $dest = installed_info($stub_name);
			$state->say("Keeping them in $stub_name") 
			    if $state->{verbose};
			if ($state->{not}) {
				$stub_list->to_cache;
				$o->{plist}->to_cache;
			} else {
				mkdir($dest);
				open my $descr, '>', $dest.DESC;
				print $descr "Stub libraries for $oldname\n";
				close $descr;
				my $f = OpenBSD::PackingElement::FDESC->add($stub_list, DESC);
				$f->{ignore} = 1;
				$f->add_digest($f->compute_digest($dest.DESC));
				$stub_list->to_installation;
				$o->{plist}->to_installation;
			}
			add_installed($stub_name);

			require OpenBSD::PkgCfl;
			OpenBSD::PkgCfl::register($stub_list, $state);

			adjust_depends_closure($oldname, $stub_list, $state);
		} else {
			$state->say("No libraries to keep") 
			    if $state->{verbose};
		}
@


1.56
log
@handle more general conflicts:
- match old spec against any of the new packages in the set.
- manage conflicts globally if several newer packages are there.
- remove the limit of 5 conflicting packages, it's no longer really relevant.
@
text
@d311 1
a311 1
	my ($old_plist, $set, $state, $ignore) = @@_;
d335 1
a335 1
		push(@@r, $wanting) if !defined $ignore->{$wanting};
@


1.55
log
@revamp interactive stuff: simplify (just one always for everything, per
theo suggestion. Also go through the "state" object which simplifies code
a great deal)
@
text
@d228 1
a228 1
	my ($self, $state, $wanting, $toreplace, $replacement) = @@_;
d233 1
a233 1
	return if $self->spec->filter($replacement);
d236 1
a236 1
	    $state->errsay("Forward dependency of $wanting on $toreplace doesn't match $replacement, forcing it");
d241 1
a241 1
	    if ($state->confirm("Forward dependency of $wanting on $toreplace doesn't match $replacement, proceed with update anyways", 0)) {
d249 1
a249 1
	    $state->errsay("Can't update forward dependency of $wanting on $toreplace: $replacement doesn't match (use -F updatedepends to force it)");
d311 1
a311 1
	my ($old_plist, $new_pkgname, $state, $ignore) = @@_;
d347 1
a347 1
				    $old_plist->pkgname, $new_pkgname);
@


1.54
log
@don't use Warn if we've got a $state, get through errprint/errsay.
Also: reset lastdisplay on clear, and don't clear twice.
@
text
@a20 1
use OpenBSD::Interactive;
d241 1
a241 1
	    if (OpenBSD::Interactive::confirm("Forward dependency of $wanting on $toreplace doesn't match $replacement, proceed with update anyways", 1, 0, 'updatedepends')) {
a294 1
use OpenBSD::Interactive;
d327 1
a327 1
			if (OpenBSD::Interactive::confirm("proceed with update anyways", 1, 0, 'update')) {
d370 1
a370 1
			if (OpenBSD::Interactive::confirm("proceed with update anyways", 1, 0, 'update')) {
@


1.53
log
@progressmeter puts STDOUT in autoflush if -t, so that it can display to it instead of piping a lot of stuff to STDERR.

Go through state->print for most messages, so they will NOT do weird things
with the progressmeter.
Use a ->say shortcut which does the same thing that perl 5.10 say does...
@
text
@d237 1
a237 1
	    Warn "Forward dependency of $wanting on $toreplace doesn't match $replacement, forcing it\n";
d250 1
a250 1
	    Warn "Can't update forward dependency of $wanting on $toreplace: $replacement doesn't match (use -F updatedepends to force it)\n";
d319 2
a320 2
		Warn "Old package ", $old_plist->pkgname, 
		    " contains potentially unsafe operations\n";
d322 1
a322 1
			Warn "\t$i\n";
d325 1
a325 1
			Warn "(forcing update)\n";
d346 1
a346 1
				Warn "Error: $wanting missing from installation\n"
d363 2
a364 2
		Warn "New package ", $plist->pkgname, 
		    " contains potentially unsafe operations\n";
d366 1
a366 1
			Warn "\t$i\n";
d369 1
a369 1
			Warn "(forcing update)\n";
@


1.52
log
@bad espie: use strict/warnings consistently, and fix two nits and two
actual errors !
@
text
@d119 2
a120 1
		print "extracting tempfile under $d\n" if $state->{very_verbose};
d128 1
a128 1
		print "extracting $tempname\n" if $state->{very_verbose};
d148 2
a149 1
	print "new directory ", $destdir, $fullname, "\n" if $state->{very_verbose};
d340 2
a341 2
		print "Verifying dependencies still match for ", 
		    join(', ', @@r), "\n" if $state->{verbose};
d418 1
a418 1
	print "Packages that depend on those shared libraries:\n" 
d423 1
a423 1
		print "\t$pkg\n" if $state->{beverbose};
d440 1
a440 1
		print "Looking for changes in shared libraries\n" 
d448 2
a449 1
			print "Libraries to keep: ", join(",", sort(keys %$libs)), "\n" 
d454 2
a455 1
			print "Keeping them in $stub_name\n" if $state->{verbose};
d477 2
a478 1
			print "No libraries to keep\n" if $state->{verbose};
@


1.51
log
@let handle compute pkgnames correctly, simplifies code a bit
@
text
@a15 1
#
@


1.50
log
@don't copy digital sig over when it makes no sense...
@
text
@d435 1
a435 1
		my $oldname = $o->{pkgname};
@


1.49
log
@synch with my new style search/location changes
It's likely there will be some fallout, but it's getting a bit too large
to keep around.
This does kill a few very old oddities as well.
@
text
@d82 7
@


1.48
log
@call may_check_digest after extraction
@
text
@d106 1
a106 1
	my $d = dirname($file->{destdir}.$file->{name});
d126 1
a126 1
		$file->{name} = $tempname;
d161 1
a161 1
	return $self->{name}." script";
@


1.47
log
@tweak compute_digest so that it `defaults' if invoked without a 2nd argument.
switch the default digest to sha256.

It's been there for a few weeks, all package tools cope with both formats,
now is the time for the switch.
@
text
@d2 1
a2 1
# $OpenBSD: Replace.pm,v 1.46 2008/10/07 06:29:36 espie Exp $
d128 1
@


1.46
log
@oops, missed one compute_md5
noticed by djm@@
@
text
@d2 1
a2 1
# $OpenBSD$
d455 1
a455 1
				$f->add_digest($f->compute_digest($dest.DESC, 'OpenBSD::md5'));
@


1.45
log
@defer to the packing element for computing md5
@
text
@d2 1
a2 1
# $OpenBSD: Replace.pm,v 1.44 2008/03/08 12:07:45 espie Exp $
d455 1
a455 1
				$f->{md5} = $f->compute_md5($dest.DESC);
@


1.44
log
@rename forced to defines
@
text
@d2 1
a2 1
# $OpenBSD$
a448 2
				require OpenBSD::md5;

d455 1
a455 1
				$f->{md5} = OpenBSD::md5::fromfile($dest.DESC);
@


1.43
log
@fix pkg_add -r -B
problem noticed by winiger@@
@
text
@d227 1
a227 1
	if ($state->{forced}->{updatedepends}) {
d315 1
a315 1
		if ($state->{forced}->{update}) {
d359 1
a359 1
		if ($state->{forced}->{update}) {
@


1.42
log
@add tag no shadow, to allow us to specify that we do NOT want tempfiles
into some directories.

a few minor style tweaks, such as using a nice join(map()) to build some
strings.
@
text
@d2 1
a2 1
# $OpenBSD: Replace.pm,v 1.41 2007/06/16 11:50:49 espie Exp $
d122 4
a126 1
		$self->{tempname} = $tempname;
@


1.41
log
@Add variation on exec/unexec:
@@exec-always         @@unexec-always
@@exec-add            @@unexec-delete
@@exec-update         @@unexec-update

with the obvious semantics that *update are only run during updates,
and *add/delete are only run during `pure' additions/removals.

This should solve the problem of those packages that `lose' manual
configuration when you update them (e.g., all the mod_xxx apache stuff
and postfix).

caveat: you will need to go through one finaly broken update before the
new stuff kicks in.
@
text
@d2 1
a2 1
# $OpenBSD: Replace.pm,v 1.40 2007/06/10 15:11:05 espie Exp $
d109 1
a109 1
	while (!-d $d && -e _) {
@


1.40
log
@make the replacement check methods slightly clearer, avoid doing two
things at once, mostly.
@
text
@d2 1
a2 1
# $OpenBSD: Replace.pm,v 1.39 2007/06/09 11:16:54 espie Exp $
d27 1
a27 1
	my ($self, $install, $state) = @@_;
d29 1
a29 1
	my $issue = $self->update_issue($install);
d41 1
a41 1
sub update_issue($$) { undef }
d154 1
a154 1
sub update_issue($$) 
d156 2
a157 1
	return $_[0]->{name}." script";
d161 1
a161 1
sub update_issue($$) 
d163 3
a165 2
	return if !$_[1];
	return $_[0]->SUPER::update_issue($_[1]);
d169 1
a169 1
sub update_issue($$) 
d171 3
a173 2
	return if $_[1];
	return $_[0]->SUPER::update_issue($_[1]);
d177 1
a177 1
sub update_issue($$) 
d179 3
a181 2
	return if !$_[1];
	return '@@exec '.$_[0]->{expanded};
d184 3
d188 1
a188 1
sub update_issue($$) 
d190 3
a192 2
	return if $_[1];
	my $self = $_[0];
d194 1
a194 1
	return '@@unexec '.$self->{expanded};
d196 3
@


1.39
log
@rework `special' package names a bit.
- do a test to create partial-foo-1.0.1 instead of partial-partial-foo-1.0
when removing partial-foo fails.
- have .libs name generation, e.g., .libs-foo, then .libs1-foo, then .libs2-foo
instead of .libs-.libs-foo.... extend the pkgspec pattern slightly, so
that all these are more or less equivalent for dependencies and conflicts.

With this, we can do practically any scenario of shared libs updates and
downgrades.
@
text
@d2 1
a2 1
# $OpenBSD: Replace.pm,v 1.38 2007/06/09 10:30:53 espie Exp $
d288 1
a288 1
sub can_do
d290 1
a290 1
	my ($toreplace, $replacement, $state, $ignore) = @@_;
a292 4
	my $plist = OpenBSD::PackingList->from_installation($toreplace);
	if (!defined $plist) {
		Fatal "Couldn't find packing-list for $toreplace\n";
	}
d294 1
a294 1
	$plist->can_update(0, $state);
d296 2
a297 1
		Warn "Old package ", $plist->pkgname, " contains potentially unsafe operations\n";
d311 1
a311 1
	my @@wantlist = OpenBSD::RequiredBy->new($toreplace)->list;
d326 1
a326 1
				    $toreplace, $replacement);
d330 1
a330 2

	return $state->{okay} ? $plist : 0;
d333 1
a333 1
sub is_safe
@


1.38
log
@new code is much sturdier with respect to old libraries, we do not have
to consider .libs-* as `special case', saving old libraries should do
the right thing in all cases, more or less...
@
text
@d2 1
a2 1
# $OpenBSD: Replace.pm,v 1.37 2007/06/07 20:41:01 espie Exp $
d379 3
a381 1
	$splitted->set_pkgname(".libs-".$plist->pkgname);
@


1.37
log
@show messages about keeping libraries more often, starting on verbose.
@
text
@d2 1
a2 1
# $OpenBSD: Replace.pm,v 1.36 2007/06/07 12:57:33 espie Exp $
a468 65
}

sub figure_out_libs
{
	my ($plist, $state, @@libs) = @@_;

	my $has = {};
	my $result = [];

	for my $item (@@{$plist->{items}}) {
		next unless $item->IsFile;
		$has->{$item->fullname} = 1;
	}

	for my $oldlib (@@libs) {
		print "Checking for collisions with $oldlib... " 
		    if $state->{verbose};

#		require OpenBSD::RequiredBy;
#
#		if (OpenBSD::RequiredBy->new($oldlib)->list == 0) {
#			require OpenBSD::Delete;
#
#			OpenBSD::Delete::delete_package($oldlib, $state);
#			delete_installed($oldlib);
#			next;
#		}

		my $p = OpenBSD::PackingList->from_installation($oldlib);
		my $n = [];
		my $delete = [];
		my $empty = 1;
		my $doit = 0;
		for my $file (@@{$p->{items}}) {
			if ($file->IsFile) {
				if ($has->{$file->fullname}) {
					$doit = 1;
					push(@@$delete, $file);
					next;
				} else {
					$empty = 0;
				}
			}
			push(@@$n, $file);
		}
		$p->{items} = $n;
		if ($doit) {
			print "some found\n" if $state->{verbose};
			# XXX we don't use this code yet
			my $dummy = {items => $delete};
			push(@@$result, 
			    { plist => $p, 
			      todelete => $dummy,
			      empty => $empty});
			#require OpenBSD::Delete;
			#OpenBSD::Delete::validate_plist($p, $state);
		} else {
			print "none found\n" if $state->{verbose};
		}
	}
	if (@@$result) {
		#$plist->{old_libs} = $result;
		return 0;
	}
	return 1;
@


1.36
log
@make compute_size explicit. That way, we can do it once, at the right
moment.
@
text
@d2 1
a2 1
# $OpenBSD: Replace.pm,v 1.35 2007/06/06 15:31:06 espie Exp $
d428 1
a428 1
			    if $state->{beverbose};
d432 1
a432 1
			print "Keeping them in $stub_name\n" if $state->{beverbose};
d456 1
a456 1
			print "No libraries to keep\n" if $state->{beverbose};
@


1.35
log
@separate the size computation from other operations in `prepare_for_addition'
`prepare_for_deletion' -> move that to Vstat, as it is common code.
Do the splitting of libraries through a deep copy and shallow copy, so that
we keep any State information related to libraries (like special group/owners).
@
text
@d2 1
a2 1
# $OpenBSD: Replace.pm,v 1.34 2007/06/06 14:09:47 espie Exp $
a429 2
			$o->{totsize} = $o->{plist}->compute_size;

@


1.34
log
@tweak split_libs slightly for further changes: make it return the old
packing-list, and the new, instead of doing `in-place' edition of the
plist contents.
@
text
@d2 1
a2 1
# $OpenBSD: Replace.pm,v 1.33 2007/06/05 23:11:01 espie Exp $
d57 6
d73 16
d189 12
d243 10
d361 11
d377 1
a377 1
	my $items = [];
d379 1
a379 1
	my $splitted = OpenBSD::PackingList->new;
a380 6
	$splitted->set_pkgname(".libs-".$plist->pkgname);
	if (defined $plist->{conflict}) {
		for my $item (@@{$plist->{conflict}}) {
			$item->clone->add_object($splitted);
		}
	}
a389 13

	for my $item (@@{$plist->{items}}) {
		if ($item->isa("OpenBSD::PackingElement::Lib") &&
		    defined $to_split->{$item->fullname}) {
		    	$item->clone->add_object($splitted);
			next;
		}
		if ($item->isa("OpenBSD::PackingElement::Cwd")) {
			$item->clone->add_object($splitted);
		}
		push(@@$items, $item);
	}
	$plist->{items} = $items;
d430 2
@


1.33
log
@reuse the compute_closure code.
@
text
@d2 1
a2 1
# $OpenBSD: Replace.pm,v 1.32 2007/06/04 16:33:23 espie Exp $
d354 1
a354 1
	return $splitted;
a378 1
		my $old_plist = $o->{plist};
d385 1
a385 1
		$old_plist->mark_lib($libs, $p);
d393 1
a393 1
			my $stub_list = split_libs($old_plist, $libs);
d399 1
a399 1
				$old_plist->to_cache;
d411 1
a411 1
				$old_plist->to_installation;
@


1.32
log
@avoid parsing libraries by hand.
Store shared libraries in a `better' format, which will also us
to report issues more nicely.
@
text
@d2 1
a2 1
# $OpenBSD: Replace.pm,v 1.31 2007/06/04 14:40:39 espie Exp $
d357 1
a357 1
sub walk_depends_closure
d359 1
a359 5
	my ($start, $plist, $state) = @@_;
	my @@todo = ($start);
	my $done = {};
	my $depend = 0;
	my $name = $plist->pkgname;
d364 6
a369 20
	my $write = OpenBSD::RequiredBy->new($name);

	while (my $pkg = shift @@todo) {
		$done->{$pkg} = 1;
		for my $pkg2 (OpenBSD::RequiredBy->new($pkg)->list) {
			next if $done->{$pkg2};
			push(@@todo, $pkg2);
			print "\t$pkg2\n" if $state->{beverbose};
			$done->{$pkg2} = 1;
			$write->add($pkg2);
			OpenBSD::Requiring->new($pkg2)->add($name);
			$depend = 1;
		}
	}
#	if (!$depend && $state->{interactive}) {
#		if ($state->{forced}->{zapoldlibs} ||
#		    OpenBSD::Interactive::confirm("Nothing depends on $name.  Delete it", 1, 0)) {
#		    	OpenBSD::Delete::delete_plist($plist, $state);
#		}
#	}
a372 1

d419 1
a419 1
			walk_depends_closure($oldname, $stub_list, $state);
@


1.31
log
@some minor systematic changes.
- mark all regexps I can with /o if they can be compiled once.
- turn $o->method() into $o->method
- remove unneeded prototypes
- reduce split /re/ into split "string" where possible.
@
text
@d2 1
a2 1
# $OpenBSD: Replace.pm,v 1.30 2007/06/01 22:35:46 espie Exp $
d202 3
a204 2
	if ($libname =~ m/^(.*\.so\.)(\d+)\.(\d+)$/o) {
		$libpatterns->{$1} = [$2, $3, $libname];
d213 3
a215 3
	if ($libname =~ m/^(.*\.so\.)(\d+)\.(\d+)$/o) {
		my ($pat, $major, $minor) = ($1, $2, $3);
		my $p = $libpatterns->{$pat};
@


1.30
log
@very small clean-up of dependencies list handling.
@
text
@d2 1
a2 1
# $OpenBSD: Replace.pm,v 1.29 2007/06/01 22:06:03 espie Exp $
d202 1
a202 1
	if ($libname =~ m/^(.*\.so\.)(\d+)\.(\d+)$/) {
d212 1
a212 1
	if ($libname =~ m/^(.*\.so\.)(\d+)\.(\d+)$/) {
d328 1
a328 1
			$item->clone()->add_object($splitted);
@


1.29
log
@apply the same checks on extraction that are done during pkg_create
(modes and owners without annotation WILL be refused).

Somewhat pedantic: skip archive entry during extraction of links/symlinks.
Doesn't change a thing, except in the very rare case where a package would
end with a link in the packing-list. Now we're able to detect a premature
end of the tarball.

(okay, it's an obscure bug, I haven't even met it for real. So what ?)
@
text
@d2 1
a2 1
# $OpenBSD: Replace.pm,v 1.28 2007/06/01 21:50:47 espie Exp $
d377 1
a377 2
			my $l = OpenBSD::Requiring->new($pkg2);
			$l->add($name);
@


1.28
log
@don't store stuff in the plist, use the handle which is there for that.
so loop directly over $set->older for replacements.
@
text
@d2 1
a2 1
# $OpenBSD: Replace.pm,v 1.27 2007/06/01 14:58:29 espie Exp $
d77 1
d82 2
d85 2
@


1.27
log
@refactor ProgressMeter code to create objects, put these into state.
Create a common state class for delete and add, put the progressmeter
creation in there.

neat effect: we don't have a progressmeter, we use a stub class instead
and *never* pull the code in at all.
@
text
@d2 1
a2 1
# $OpenBSD: Replace.pm,v 1.26 2007/06/01 12:19:00 espie Exp $
d391 1
a391 1
	for my $old_plist ($set->actual_replacements) {
d393 2
a418 1
				my $oldname = $old_plist->pkgname;
d433 1
a433 1
			walk_depends_closure($old_plist->pkgname, $stub_list, $state);
@


1.26
log
@no need to require ProgressMeter twice.
@
text
@d2 1
a2 1
# $OpenBSD: Replace.pm,v 1.25 2007/05/30 14:04:51 espie Exp $
d64 1
a64 1
	$self->mark_progress($donesize, $totsize);
@


1.25
log
@simplify really_add to use real visitors for extraction and installation.
Just do one single try {} catchall {} per-method, as this is enough.

New methods: extract_and_progress, install_and_progress, that catch
interrupts (die) deal with fake, and handle the progress meter.
One single method: mark_progress, can be used for extraction, installation
and deletion.
@
text
@d2 1
a2 1
# $OpenBSD: Replace.pm,v 1.24 2007/05/30 13:03:54 espie Exp $
a58 2
	require OpenBSD::ProgressMeter;

@


1.24
log
@avoid setting partial directly when we can, use inheritance instead.
@
text
@d2 1
a2 1
# $OpenBSD: Replace.pm,v 1.23 2007/05/30 12:52:07 espie Exp $
d57 12
d226 13
@


1.23
log
@simplify the way partial installations get recorded: store elements
already installed in a hash, and do a shallow copy of the list when
necessary, using make_copy.

This removes a lot of action-at-a-distance in packing-list elements.
@
text
@d2 1
a2 1
# $OpenBSD: Replace.pm,v 1.22 2007/05/27 22:39:09 espie Exp $
d70 1
a70 1
	$state->{partial}->{$self} = 1;
d99 1
a99 1
	$state->{partial}->{$self} = 1;
@


1.22
log
@so save_old_libs becomes the first routine to handle full UpdateSets.
@
text
@d2 1
a2 1
# $OpenBSD: Replace.pm,v 1.21 2007/05/27 22:34:24 espie Exp $
d45 2
a66 1
		$self->{zap} = 1;
d70 1
d99 1
d105 1
d297 1
a297 1
	OpenBSD::PackingElement::Name->add($splitted, ".libs-".$plist->pkgname);
@


1.21
log
@oops, save_old_libs is now set dependent, we no longer store old packages
in the same location.
@
text
@d2 1
a2 1
# $OpenBSD: Replace.pm,v 1.20 2007/05/27 21:43:06 espie Exp $
a363 2
	my $new_plist = $set->handle->{plist};

d372 3
a374 1
		$new_plist->unmark_lib($libs, $p);
@


1.20
log
@comment out some of this code. Currently, we don't know how to recover
from collision with old libs (and the result from figure_out_old_libs says
so), so don't pretend we're doing anything significant with them...
@
text
@d2 1
a2 1
# $OpenBSD: Replace.pm,v 1.19 2007/05/27 21:33:55 espie Exp $
d362 1
a362 1
	my ($new_plist, $state) = @@_;
d364 3
a366 1
	for my $old_plist (@@{$new_plist->{replacing}}) {
@


1.19
log
@group packing-list validation for replaced packages with added one.
@
text
@d2 1
a2 1
# $OpenBSD: Replace.pm,v 1.18 2007/05/26 23:45:44 espie Exp $
d466 1
d472 2
a473 2
			require OpenBSD::Delete;
			OpenBSD::Delete::validate_plist($p, $state);
d479 1
a479 1
		$plist->{old_libs} = $result;
@


1.18
log
@simplify error logic a bit more, always let prepare_to_add return a
handle.

Also kill very old @@exec tests.
@
text
@d2 1
a2 1
# $OpenBSD: Replace.pm,v 1.17 2007/05/22 11:02:57 espie Exp $
a254 9
	}

	if ($state->{okay}) {
		try {
			OpenBSD::Delete::validate_plist($plist, $state);
		} catchall {
			Warn "$_";
			return 0;
		};
@


1.17
log
@zap references to pkgdep. Packing-Lists no longer even record it, anyways.
@
text
@d2 1
a2 1
# $OpenBSD: Replace.pm,v 1.16 2007/05/20 11:06:44 espie Exp $
d145 1
a145 7
	# those are deemed innocuous
	if ($self->{expanded} =~ m|^/sbin/ldconfig\s+\-R\b| or
	    $self->{expanded} =~ m|^install-info\s+\-\-delete\b|) {
		return;
	} else {
		return '@@unexec '.$self->{expanded};
	}
@


1.16
log
@compute list of dependencies to adjust just-in-time.
This lets the pkg_add regress pass, finally.
@
text
@d2 1
a2 1
# $OpenBSD: Replace.pm,v 1.15 2007/05/20 10:48:48 espie Exp $
a338 17
sub convert_to_requiring
{
	my $pkg = shift;

	my $plist = OpenBSD::PackingList->from_installation($pkg);
	if (!defined $plist) {
		Warn "Couldn't read plist for $pkg\n";
		return;
	}
	my $r = OpenBSD::Requiring->new($pkg);
	for my $item (@@{$plist->{pkgdep}}) {
		$r->add($item->{name});
	}
	delete $plist->{pkgdep};
	$plist->to_installation;
}

a360 3
			if (!$l->list) {
				convert_to_requiring($pkg2);
			}
a430 3
	if (!$l->list) {
		convert_to_requiring($dep);
	}
@


1.15
log
@libs_to_check ? actually, never use it...
@
text
@d2 1
a2 1
# $OpenBSD: Replace.pm,v 1.14 2007/05/20 10:38:50 espie Exp $
a271 2
	$plist->{wantlist} = \@@wantlist;
	
@


1.14
log
@remove extra forwarding method that is no longer needed
@
text
@d2 1
a2 1
# $OpenBSD: Replace.pm,v 1.13 2007/05/20 10:20:07 espie Exp $
a221 1
	$state->{libs_to_check} = [];
a272 1
	$plist->{libs_to_check} = $state->{libs_to_check};
@


1.13
log
@zap old depend code I missed
@
text
@d2 1
a2 1
# $OpenBSD: Replace.pm,v 1.12 2007/05/14 11:22:00 espie Exp $
d154 1
a154 1
package OpenBSD::PackingElement::Depend;
d157 1
a157 1
sub check_replacement_spec
a207 8
}

package OpenBSD::PackingElement::Dependency;
sub validate_depend
{
	my ($self, $state, $wanting, $toreplace, $replacement) = @@_;

	$self->check_replacement_spec($state, $wanting, $toreplace, $replacement);
@


1.12
log
@redo search filters as real objects. Accordingly, rename match_list to
filter.
@
text
@d2 1
a2 1
# $OpenBSD: Replace.pm,v 1.11 2007/05/14 10:43:45 espie Exp $
a183 11
package OpenBSD::PackingElement::LibDepend;
sub validate_depend
{
	my ($self, $state, $wanting, $toreplace, $replacement) = @@_;

	if (defined $self->{name}) {
		return unless $self->{name} eq $wanting;
	}
	$self->check_replacement_spec($state, $wanting, $toreplace, $replacement);
}

a207 11
}

package OpenBSD::PackingElement::NewDepend;
sub validate_depend
{
	my ($self, $state, $wanting, $toreplace, $replacement) = @@_;

	if (defined $self->{name}) {
		return unless $self->{name} eq $wanting;
	}
	$self->check_replacement_spec($state, $wanting, $toreplace, $replacement);
@


1.11
log
@name tweaks: match -> match_list, match_repo -> match
@
text
@d2 1
a2 1
# $OpenBSD: Replace.pm,v 1.10 2007/05/12 22:50:31 espie Exp $
d162 1
a162 1
	return unless $self->spec->match_list($toreplace);
d164 1
a164 1
	return if $self->spec->match_list($replacement);
@


1.10
log
@oops. forgot this one. Noticed by M.Pereboom.
@
text
@d2 1
a2 1
# $OpenBSD: Replace.pm,v 1.9 2007/05/07 09:32:51 espie Exp $
d162 1
a162 1
	return unless $self->spec->match($toreplace);
d164 1
a164 1
	return if $self->spec->match($replacement);
@


1.9
log
@make sure all temporary file handling goes through OpenBSD::Temp
@
text
@d2 1
a2 1
# $OpenBSD: Replace.pm,v 1.8 2007/05/07 08:24:16 espie Exp $
d162 1
a162 1
	return unless OpenBSD::PkgSpec::match($self->{pattern}, $toreplace);
d164 1
a164 1
	return if OpenBSD::PkgSpec::match($self->{pattern}, $replacement);
@


1.8
log
@kill old code to handle deprecated pkgcfl.
@
text
@d2 1
a2 1
# $OpenBSD: Replace.pm,v 1.7 2007/05/02 15:09:04 espie Exp $
d56 1
a56 1
use File::Temp qw/tempfile/;
d80 1
a80 2
		my ($fh, $tempname) = tempfile('pkg.XXXXXXXXXX', 
		    DIR => $d);
@


1.7
log
@remove extra "" that don't make sense.
@
text
@d2 1
a2 1
# $OpenBSD: Replace.pm,v 1.6 2007/05/02 15:05:30 espie Exp $
a345 5
			$item->clone()->add_object($splitted);
		}
	}
	if (defined $plist->{pkgcfl}) {
		for my $item (@@{$plist->{pkgcfl}}) {
@


1.6
log
@$o->method() becomes $o->method
@
text
@d2 1
a2 1
# $OpenBSD: Replace.pm,v 1.5 2007/04/29 11:09:29 espie Exp $
d202 1
a202 1
		$libpatterns->{"$1"} = [$2, $3, $libname];
d204 1
a204 1
	$libs->{"$libname"} = 1;
d213 1
a213 1
		my $p = $libpatterns->{"$pat"};
d216 1
a216 1
			delete $libs->{"$n"};
d219 1
a219 1
	delete $libs->{"$libname"};
@


1.5
log
@replace $p->visit('method') calls with $p->method
now that it works.
@
text
@d2 1
a2 1
# $OpenBSD: Replace.pm,v 1.4 2007/04/15 10:17:29 espie Exp $
d75 1
a75 1
		$state->{archive}->skip();
d86 1
a86 1
		$file->create();
d94 1
a94 1
	my $fullname = $self->fullname();
d200 1
a200 1
	my $libname = $self->fullname();
d210 1
a210 1
	my $libname = $self->fullname();
d261 1
a261 1
		Warn "Old package ", $plist->pkgname(), " contains potentially unsafe operations\n";
d275 1
a275 1
	my @@wantlist = OpenBSD::RequiredBy->new($toreplace)->list();
d317 1
a317 1
		Warn "New package ", $plist->pkgname(), 
d341 1
a341 1
	my $splitted = OpenBSD::PackingList->new();
d343 1
a343 1
	OpenBSD::PackingElement::Name->add($splitted, ".libs-".$plist->pkgname());
d356 1
a356 1
		OpenBSD::PackingElement::Conflict->add($splitted, $plist->pkgname());
d360 1
a360 1
		my $stem = OpenBSD::PackageName::splitstem($plist->pkgname());
d366 2
a367 2
		    defined $to_split->{$item->fullname()}) {
		    	$item->clone()->add_object($splitted);
d371 1
a371 1
			$item->clone()->add_object($splitted);
d393 1
a393 1
	$plist->to_installation();
d402 1
a402 1
	my $name = $plist->pkgname();
d411 1
a411 1
		for my $pkg2 (OpenBSD::RequiredBy->new($pkg)->list()) {
d418 1
a418 1
			if (!$l->list()) {
d453 1
a453 1
			my $stub_name = $stub_list->pkgname();
d457 2
a458 2
				$stub_list->to_cache();
				$old_plist->to_cache();
d463 1
a463 1
				my $oldname = $old_plist->pkgname();
d470 2
a471 2
				$stub_list->to_installation();
				$old_plist->to_installation();
d478 1
a478 1
			walk_depends_closure($old_plist->pkgname(), $stub_list, $state);
d491 1
a491 1
	if (!$l->list()) {
d506 2
a507 2
		next unless $item->IsFile();
		$has->{$item->fullname()} = 1;
d516 1
a516 1
#		if (OpenBSD::RequiredBy->new($oldlib)->list() == 0) {
d530 2
a531 2
			if ($file->IsFile()) {
				if ($has->{$file->fullname()}) {
@


1.4
log
@update copyright years, standardize licence.
reword the introduction to the stuff originally from FreeBSD to clarify
slightly.
@
text
@d2 1
a2 1
# $OpenBSD: Replace.pm,v 1.3 2006/11/17 15:34:15 espie Exp $
d259 1
a259 1
	$plist->visit('can_update', 0, $state);
d289 1
a289 1
				$p2->visit('validate_depend', $state, $wanting, 
d315 1
a315 1
	$plist->visit('can_update', 1, $state);
d446 2
a447 2
		$old_plist->visit('mark_lib', $libs, $p);
		$new_plist->visit('unmark_lib', $libs, $p);
@


1.3
log
@don't return undef, use plain return.
(return undef is only false in a scalar context)
found my perlcritic, one of the few issues I agree with...
@
text
@d2 1
a2 1
# $OpenBSD: Replace.pm,v 1.2 2006/04/22 10:31:44 bernd Exp $
d4 1
a4 1
# Copyright (c) 2004 Marc Espie <espie@@openbsd.org>
@


1.2
log
@Pass over the right object to OpenBSD::Delete::validate_plist().
This fixes an error while checking for collision with old libs.

okay espie@@
@
text
@d2 1
a2 1
# $OpenBSD: Replace.pm,v 1.1 2006/03/04 11:31:18 espie Exp $
d122 1
a122 1
	return undef if !$_[1];
d129 1
a129 1
	return undef if $_[1];
d136 1
a136 1
	return undef if !$_[1];
d143 1
a143 1
	return undef if $_[1];
d149 1
a149 1
		return undef;
@


1.1
log
@reorganize code a little bit: Update.pm becomes Replace.pm (since it matches
the -r option), and the find_update code moves to Update.pm, so that it doesn't
get parsed if -u is not used.

Also make the has_new_sig and uses_old_libs local methods of PackingList,
as it is their natural API.

Reorg a few more routines so that they can be found by pkg_add and by
Update.pm.

May need to split off more stuff to avoid parsing everything...
@
text
@d2 1
a2 1
# $OpenBSD: Update.pm,v 1.61 2006/02/21 19:20:17 espie Exp $
d550 1
a550 1
			OpenBSD::Delete::validate_plist($dummy, $state);
@

