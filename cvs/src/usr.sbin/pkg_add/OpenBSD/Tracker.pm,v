head	1.28;
access;
symbols
	OPENBSD_6_2_BASE:1.28
	OPENBSD_6_1:1.28.0.8
	OPENBSD_6_1_BASE:1.28
	OPENBSD_6_0:1.28.0.6
	OPENBSD_6_0_BASE:1.28
	OPENBSD_5_9:1.28.0.2
	OPENBSD_5_9_BASE:1.28
	OPENBSD_5_8:1.27.0.10
	OPENBSD_5_8_BASE:1.27
	OPENBSD_5_7:1.27.0.2
	OPENBSD_5_7_BASE:1.27
	OPENBSD_5_6:1.27.0.6
	OPENBSD_5_6_BASE:1.27
	OPENBSD_5_5:1.27.0.4
	OPENBSD_5_5_BASE:1.27
	OPENBSD_5_4:1.26.0.10
	OPENBSD_5_4_BASE:1.26
	OPENBSD_5_3:1.26.0.8
	OPENBSD_5_3_BASE:1.26
	OPENBSD_5_2:1.26.0.6
	OPENBSD_5_2_BASE:1.26
	OPENBSD_5_1_BASE:1.26
	OPENBSD_5_1:1.26.0.4
	OPENBSD_5_0:1.26.0.2
	OPENBSD_5_0_BASE:1.26
	OPENBSD_4_9:1.25.0.2
	OPENBSD_4_9_BASE:1.25
	OPENBSD_4_8:1.23.0.2
	OPENBSD_4_8_BASE:1.23
	OPENBSD_4_7:1.19.0.2
	OPENBSD_4_7_BASE:1.19;
locks; strict;
comment	@# @;


1.28
date	2015.08.13.16.34.11;	author espie;	state Exp;
branches;
next	1.27;
commitid	JpX27r02NoOabOr8;

1.27
date	2014.02.06.17.13.05;	author espie;	state Exp;
branches;
next	1.26;

1.26
date	2011.07.12.10.30.29;	author espie;	state Exp;
branches;
next	1.25;

1.25
date	2010.12.24.09.04.14;	author espie;	state Exp;
branches;
next	1.24;

1.24
date	2010.10.27.14.35.56;	author espie;	state Exp;
branches;
next	1.23;

1.23
date	2010.06.30.10.51.04;	author espie;	state Exp;
branches;
next	1.22;

1.22
date	2010.06.30.10.41.42;	author espie;	state Exp;
branches;
next	1.21;

1.21
date	2010.06.09.08.13.19;	author espie;	state Exp;
branches;
next	1.20;

1.20
date	2010.05.10.09.17.55;	author espie;	state Exp;
branches;
next	1.19;

1.19
date	2009.12.30.17.37.36;	author espie;	state Exp;
branches;
next	1.18;

1.18
date	2009.12.30.09.56.26;	author espie;	state Exp;
branches;
next	1.17;

1.17
date	2009.12.19.14.21.14;	author espie;	state Exp;
branches;
next	1.16;

1.16
date	2009.12.14.18.11.26;	author espie;	state Exp;
branches;
next	1.15;

1.15
date	2009.12.14.13.50.28;	author espie;	state Exp;
branches;
next	1.14;

1.14
date	2009.12.12.12.21.22;	author espie;	state Exp;
branches;
next	1.13;

1.13
date	2009.12.07.13.41.02;	author espie;	state Exp;
branches;
next	1.12;

1.12
date	2009.12.04.10.43.02;	author espie;	state Exp;
branches;
next	1.11;

1.11
date	2009.11.28.16.46.20;	author espie;	state Exp;
branches;
next	1.10;

1.10
date	2009.11.24.11.35.18;	author espie;	state Exp;
branches;
next	1.9;

1.9
date	2009.11.16.14.42.18;	author espie;	state Exp;
branches;
next	1.8;

1.8
date	2009.11.10.11.36.56;	author espie;	state Exp;
branches;
next	1.7;

1.7
date	2009.11.10.10.28.12;	author espie;	state Exp;
branches;
next	1.6;

1.6
date	2009.11.08.10.46.11;	author espie;	state Exp;
branches;
next	1.5;

1.5
date	2009.11.08.09.39.21;	author espie;	state Exp;
branches;
next	1.4;

1.4
date	2009.10.19.14.07.26;	author espie;	state Exp;
branches;
next	1.3;

1.3
date	2009.10.16.18.29.43;	author espie;	state Exp;
branches;
next	1.2;

1.2
date	2009.10.15.18.32.11;	author espie;	state Exp;
branches;
next	1.1;

1.1
date	2009.10.15.18.17.18;	author espie;	state Exp;
branches;
next	;


desc
@@


1.28
log
@scaffolding that will display more info for the elusive REQUIRED_BY error
@
text
@# ex:ts=8 sw=4:
# $OpenBSD: Tracker.pm,v 1.27 2014/02/06 17:13:05 espie Exp $
#
# Copyright (c) 2009 Marc Espie <espie@@openbsd.org>
#
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF

# In order to deal with dependencies, we have to know what's actually installed,
# and what can actually be updated.
# Specifically, to solve a dependency:
# - look at packages to_install
# - look at installed packages
#   - if it's marked to_update, then we must process the update first
#   - if it's marked as installed, or as cant_update, or uptodate, then
#   we can use the installed packages.
#   - otherwise, in update mode, put a request to update the package (e.g.,
#   create a new UpdateSet.

# the Tracker object does maintain that information globally so that
# Update/Dependencies can do its job.

use strict;
use warnings;

package OpenBSD::Tracker;
our $s;

sub new
{
	my $class = shift;
	return $s = bless {}, $class;
}

sub dump2
{
	my $set = shift;
	if (defined $set->{merged}) {
		return "merged from ".dump2($set->{merged});
	}
	return join("/",
	    join(",", $set->newer_names), 
	    join(",", $set->older_names), 
	    join(",", $set->kept_names),
	    join(",", $set->hint_names));
}

sub dump
{
	return unless defined $s;
	for my $l ('to_install', 'to_update') {
		next unless defined $s->{$l};
		print STDERR "$l:\n";
		while (my ($k, $e) = each %{$s->{$l}}) {
			print STDERR "\t$k => ", dump2($e), "\n";
		}
	}
	for my $l ('uptodate', 'can_install', 'cant_update') {
		next unless defined $s->{$l};
		print STDERR "$l: ", join(' ', keys %{$s->{$l}}), "\n";
	}
}

sub sets_todo
{
	my ($self, $offset) = @@_;
	return sprintf("%u/%u", (scalar keys %{$self->{done}})-$offset,
		scalar keys %{$self->{total}});
}

sub handle_set
{
	my ($self, $set) = @@_;
	$self->{total}{$set} = 1;
	if ($set->{finished}) {
		$self->{done}{$set} = 1;
	}
}

sub known
{
	my ($self, $set) = @@_;
	for my $n ($set->newer, $set->older, $set->hints) {
		$self->{known}{$n->pkgname} = 1;
	}
}

sub add_set
{
	my ($self, $set) = @@_;
	for my $n ($set->newer) {
		$self->{to_install}{$n->pkgname} = $set;
	}
	for my $n ($set->older, $set->hints) {
		$self->{to_update}{$n->pkgname} = $set;
	}
	for my $n ($set->kept) {
		delete $self->{to_update}{$n->pkgname};
		$self->{uptodate}{$n->pkgname} = 1;
	}
	$self->known($set);
	$self->handle_set($set);
	return $self;
}

sub todo
{
	my ($self, @@sets) = @@_;
	for my $set (@@sets) {
		$self->add_set($set);
	}
	return $self;
}

sub remove_set
{
	my ($self, $set) = @@_;
	for my $n ($set->newer) {
		delete $self->{to_install}{$n->pkgname};
		delete $self->{cant_install}{$n->pkgname};
	}
	for my $n ($set->kept, $set->older, $set->hints) {
		delete $self->{to_update}{$n->pkgname};
		delete $self->{cant_update}{$n->pkgname};
	}
	$self->handle_set($set);
}

sub uptodate
{
	my ($self, $set) = @@_;
	$set->{finished} = 1;
	$self->remove_set($set);
	for my $n ($set->older, $set->kept) {
		$self->{uptodate}{$n->pkgname} = 1;
	}
}

sub cant
{
	my ($self, $set) = @@_;
	$set->{finished} = 1;
	$self->remove_set($set);
	$self->known($set);
	for my $n ($set->older) {
		$self->{cant_update}{$n->pkgname} = 1;
	}
	for my $n ($set->newer) {
		$self->{cant_install}{$n->pkgname} = 1;
	}
	for my $n ($set->kept) {
		$self->{uptodate}{$n->pkgname} = 1;
	}
}

sub done
{
	my ($self, $set) = @@_;

	$set->{finished} = 1;
	$self->remove_set($set);
	$self->known($set);

	for my $n ($set->newer) {
		$self->{uptodate}{$n->pkgname} = 1;
		$self->{installed}{$n->pkgname} = 1;
	}
	for my $n ($set->kept) {
		$self->{uptodate}{$n->pkgname} = 1;
	}
}

sub is
{
	my ($self, $k, $pkg) = @@_;

	my $set = $self->{$k}{$pkg};
	if (ref $set) {
		return $set->real_set;
	} else {
		return $set;
	}
}

sub is_known
{
	my ($self, $pkg) = @@_;
	return $self->is('known', $pkg);
}

sub is_installed
{
	my ($self, $pkg) = @@_;
	return $self->is('installed', $pkg);
}

sub is_to_update
{
	my ($self, $pkg) = @@_;
	return $self->is('to_update', $pkg);
}

sub cant_list
{
	my $self = shift;
	return keys %{$self->{cant_update}};
}

1;
@


1.27
log
@style
@
text
@d2 1
a2 1
# $OpenBSD: Tracker.pm,v 1.26 2011/07/12 10:30:29 espie Exp $
d35 2
d40 30
a69 1
	return bless {}, $class;
@


1.26
log
@new pkg_delete, very similar to pkg_add, support for -a
@
text
@d2 1
a2 1
# $OpenBSD$
d51 1
a51 1
	$self->{total}->{$set} = 1;
d53 1
a53 1
		$self->{done}->{$set} = 1;
d61 1
a61 1
		$self->{known}->{$n->pkgname} = 1;
d69 1
a69 1
		$self->{to_install}->{$n->pkgname} = $set;
d72 1
a72 1
		$self->{to_update}->{$n->pkgname} = $set;
d75 2
a76 2
		delete $self->{to_update}->{$n->pkgname};
		$self->{uptodate}->{$n->pkgname} = 1;
d96 2
a97 2
		delete $self->{to_install}->{$n->pkgname};
		delete $self->{cant_install}->{$n->pkgname};
d100 2
a101 2
		delete $self->{to_update}->{$n->pkgname};
		delete $self->{cant_update}->{$n->pkgname};
d112 1
a112 1
		$self->{uptodate}->{$n->pkgname} = 1;
d123 1
a123 1
		$self->{cant_update}->{$n->pkgname} = 1;
d126 1
a126 1
		$self->{cant_install}->{$n->pkgname} = 1;
d129 1
a129 1
		$self->{uptodate}->{$n->pkgname} = 1;
d142 2
a143 2
		$self->{uptodate}->{$n->pkgname} = 1;
		$self->{installed}->{$n->pkgname} = 1;
d146 1
a146 1
		$self->{uptodate}->{$n->pkgname} = 1;
d154 1
a154 1
	my $set = $self->{$k}->{$pkg};
@


1.25
log
@handle failures from ports tree with more care.
this does avoid infinite loops in case of wrong plists.
necessary since print-plist-with-depends CAN fail...
@
text
@@


1.24
log
@initial scaffolding for @@rcscript: for now, acts like normal files,
but allow absolute pathnames (treat that as an implicit @@cwd).
@
text
@@


1.23
log
@allow say and errsay to work without parameters, as it's ways common.
create verbose_system up in state, because it makes sense without verbose.
@
text
@@


1.22
log
@whitespace cleanup
@
text
@@


1.21
log
@replace confusing (n to go) message with #done/#total annotations.
e.g.,
Checking packages|No change in apr-util-mt-1.2.10p4 (26/1530)
@
text
@d2 1
a2 1
# $OpenBSD: Tracker.pm,v 1.20 2010/05/10 09:17:55 espie Exp $
@


1.20
log
@whitespace fixes
@
text
@d2 1
a2 1
# $OpenBSD$
d43 4
a46 1
	my $self = shift;
a47 2
	return scalar keys %{$self->{todo}};
}
d51 1
d53 1
a53 3
		delete $self->{todo}->{$set};
	} else {
		$self->{todo}->{$set} = 1;
@


1.19
log
@also track stuff I couldn't install, and use it for negative cache lookups.
fix some looping if stuff can't install for whatever reason.
@
text
@d28 1
a28 1
# the Tracker object does maintain that information globally so that 
@


1.18
log
@ouch, now that we keep packages, take them into account on done.
@
text
@d97 1
d121 1
d124 6
@


1.17
log
@create a $state->todo method to account for sets to install.
have tracker keep track of sets not done, and ask it directly for how many
there's still to do. Provide an offset into next for cases where we know
we already did a set but haven't accounted for it yet.
-> more accurate number of sets still to do.
@
text
@d137 3
@


1.16
log
@since some packages in updatesets don't need updates, be explicit about it.
This is more complex and simpler at the same time...
@
text
@d41 16
d79 1
d102 1
d108 1
d118 1
d129 1
@


1.15
log
@when removing sets, remove cant markers as well
@
text
@d58 4
d81 1
a81 1
	for my $n ($set->older, $set->hints) {
d91 1
a91 1
	for my $n ($set->older) {
@


1.14
log
@remove *everything* from to_update, including hints
@
text
@d79 1
@


1.13
log
@simplify tracker a bit now we know what we're doing.
kill code that never got used
@
text
@d77 1
a77 1
	for my $n ($set->older) {
@


1.12
log
@internal API: is_known, for pkgnames that are known by the tracker,
so that we decide whether to create new updatesets.
(not efficient, but isolate from rest of code before Tracker refactor)
@
text
@d41 8
d58 1
d62 1
a62 1
sub add_sets
d82 1
a82 1
sub mark_uptodate
d85 1
a86 1
		delete $self->{to_update}->{$n->pkgname};
d91 1
a91 1
sub mark_cant_update
d94 1
a95 1
		delete $self->{to_update}->{$n->pkgname};
d100 1
a100 1
sub mark_installed
d105 1
d128 1
a128 6
	my $r;
	for my $k qw(installed uptodate cant_update to_update) {
		$r = $self->is($k, $pkg);
	    	return $r if defined $r;
	}
	return $r;
d143 1
a143 7
sub installed
{
	my $self = shift;
	return keys %{$self->{installed}};
}

sub cant_update
@


1.11
log
@prepare for "better" merge: we can't just wipe the old set, we have to point
it to the new set, as tracker stuff may still know about it.
@
text
@d115 11
@


1.10
log
@better
@
text
@d103 12
d118 7
a124 1
	return $self->{installed}->{$pkg};
@


1.9
log
@create a pseudo vstat object inside state, so that we can modify Vstat
interface very locally...

model hints objects like Locations, to uniformize further treatment.
@
text
@d94 3
d98 1
a100 1
	$self->remove_set($set);
@


1.8
log
@bad espie: use strict/warnings consistently, and fix two nits and two
actual errors !
@
text
@d47 1
a47 1
	for my $n ($set->older) {
a48 3
	}
	for my $n ($set->hints) {
		$self->{to_update}->{$n} = $set;
@


1.7
log
@document what's going on...
@
text
@a15 4
#

use strict;
use warnings;
d30 3
@


1.6
log
@add the notion of "hints" to UpdateSet, in order to unify -z/-l handling:
create updatesets with nothing but a hint of what to install. Have
Update.pm do the dirty work.

More importantly, make Tracker aware of what's going on.
@
text
@d21 13
a33 3
# the tracker class is used to track what's going on during a complicated
# install. Specifically: what packages are installed, what's left to do,
# etc
@


1.5
log
@put all the state of the current update into the tracker
@
text
@d41 3
@


1.4
log
@basic routines to handle the merging of updatesets: mark updatesets as
already done, separate remove/mark_installed in tracker, create a merge
method that allows the merging of updatesets.
@
text
@d64 18
d101 6
@


1.3
log
@ouch. delete is not undef. We need to make sure the entries vanish,
otherwise, find_dep_in_stuff_to_install will still find the key.
@
text
@d53 1
a53 1
sub mark_installed
a57 1
		$self->{installed}->{$n->pkgname} = 1;
d62 9
@


1.2
log
@move the installed check in Tracker, where they belong
@
text
@d2 1
a2 1
# $OpenBSD: Tracker.pm,v 1.1 2009/10/15 18:17:18 espie Exp $
d57 1
a57 1
		undef $self->{to_install}->{$n->pkgname};
d61 1
a61 1
		undef $self->{to_update}->{$n->pkgname};
@


1.1
log
@pkg_add will need to track installation progress globally, so that we don't
solve dependencies with stuff that we want to update later...
create that information, to be used...
@
text
@d2 1
a2 1
# $OpenBSD$
d63 12
@

