head	1.45;
access;
symbols
	OPENBSD_6_1_BASE:1.45
	OPENBSD_6_0:1.37.0.4
	OPENBSD_6_0_BASE:1.37
	OPENBSD_5_9:1.34.0.2
	OPENBSD_5_9_BASE:1.34
	OPENBSD_5_8:1.34.0.4
	OPENBSD_5_8_BASE:1.34
	OPENBSD_5_7:1.33.0.2
	OPENBSD_5_7_BASE:1.33
	OPENBSD_5_6:1.32.0.4
	OPENBSD_5_6_BASE:1.32
	OPENBSD_5_5:1.25.0.4
	OPENBSD_5_5_BASE:1.25
	OPENBSD_5_4:1.23.0.6
	OPENBSD_5_4_BASE:1.23
	OPENBSD_5_3:1.23.0.4
	OPENBSD_5_3_BASE:1.23
	OPENBSD_5_2:1.23.0.2
	OPENBSD_5_2_BASE:1.23
	OPENBSD_5_1_BASE:1.21
	OPENBSD_5_1:1.21.0.2
	OPENBSD_5_0:1.20.0.4
	OPENBSD_5_0_BASE:1.20
	OPENBSD_4_9:1.20.0.2
	OPENBSD_4_9_BASE:1.20
	OPENBSD_4_8:1.16.0.2
	OPENBSD_4_8_BASE:1.16;
locks; strict;
comment	@# @;


1.45
date	2017.03.09.14.33.32;	author espie;	state Exp;
branches;
next	1.44;
commitid	PwhbhajV0nubPxQ4;

1.44
date	2017.03.01.10.35.24;	author espie;	state Exp;
branches;
next	1.43;
commitid	WLXUAeW6LYQMCSi5;

1.43
date	2017.02.27.21.53.11;	author rpe;	state Exp;
branches;
next	1.42;
commitid	7XQfqtkSXX43wr6R;

1.42
date	2017.02.06.15.13.23;	author espie;	state Exp;
branches;
next	1.41;
commitid	euMih8NZU8IZREri;

1.41
date	2017.02.05.14.00.42;	author rpe;	state Exp;
branches;
next	1.40;
commitid	0sRAhI8ETPEIQ5nF;

1.40
date	2016.10.03.13.58.09;	author espie;	state Exp;
branches;
next	1.39;
commitid	cVDhKpeP8PSoCWif;

1.39
date	2016.09.27.21.31.20;	author naddy;	state Exp;
branches;
next	1.38;
commitid	V5PNFIkfVXShTRqF;

1.38
date	2016.09.14.14.14.22;	author espie;	state Exp;
branches;
next	1.37;
commitid	6lOgjJkAiRMRHn41;

1.37
date	2016.06.24.11.42.30;	author espie;	state Exp;
branches;
next	1.36;
commitid	Pp1JudXEajWFIq4j;

1.36
date	2016.06.23.16.11.23;	author espie;	state Exp;
branches;
next	1.35;
commitid	QxkzX6iWFbwTHuvu;

1.35
date	2016.06.23.12.44.10;	author espie;	state Exp;
branches;
next	1.34;
commitid	2SFl6rtYP7cfzydR;

1.34
date	2015.04.06.11.07.24;	author espie;	state Exp;
branches;
next	1.33;
commitid	5mxPWdqhJG0A6CvY;

1.33
date	2014.11.30.15.56.15;	author espie;	state Exp;
branches;
next	1.32;
commitid	VEUnKivfaZ0TBfIM;

1.32
date	2014.07.27.22.19.18;	author espie;	state Exp;
branches;
next	1.31;
commitid	itMXrJJijCBXYdte;

1.31
date	2014.07.08.16.52.47;	author espie;	state Exp;
branches;
next	1.30;
commitid	2tCYYRzHpvC8kprV;

1.30
date	2014.06.10.15.50.01;	author espie;	state Exp;
branches;
next	1.29;
commitid	KVUqOxIAG26j8JdL;

1.29
date	2014.05.30.15.04.54;	author espie;	state Exp;
branches;
next	1.28;

1.28
date	2014.05.20.05.43.55;	author espie;	state Exp;
branches;
next	1.27;

1.27
date	2014.03.18.18.53.29;	author espie;	state Exp;
branches;
next	1.26;

1.26
date	2014.03.18.16.42.24;	author espie;	state Exp;
branches;
next	1.25;

1.25
date	2014.01.09.20.20.01;	author espie;	state Exp;
branches;
next	1.24;

1.24
date	2014.01.07.01.35.56;	author espie;	state Exp;
branches;
next	1.23;

1.23
date	2012.05.01.10.18.13;	author espie;	state Exp;
branches;
next	1.22;

1.22
date	2012.04.10.16.57.12;	author espie;	state Exp;
branches;
next	1.21;

1.21
date	2011.08.26.08.46.10;	author espie;	state Exp;
branches;
next	1.20;

1.20
date	2010.12.24.09.04.14;	author espie;	state Exp;
branches;
next	1.19;

1.19
date	2010.12.18.10.39.01;	author espie;	state Exp;
branches;
next	1.18;

1.18
date	2010.10.24.17.04.47;	author espie;	state Exp;
branches;
next	1.17;

1.17
date	2010.10.02.13.33.05;	author espie;	state Exp;
branches;
next	1.16;

1.16
date	2010.07.26.23.27.28;	author espie;	state Exp;
branches;
next	1.15;

1.15
date	2010.07.12.09.31.52;	author espie;	state Exp;
branches;
next	1.14;

1.14
date	2010.07.09.12.42.43;	author espie;	state Exp;
branches;
next	1.13;

1.13
date	2010.07.04.19.27.26;	author espie;	state Exp;
branches;
next	1.12;

1.12
date	2010.07.02.12.42.49;	author espie;	state Exp;
branches;
next	1.11;

1.11
date	2010.07.02.11.17.46;	author espie;	state Exp;
branches;
next	1.10;

1.10
date	2010.06.30.11.32.20;	author espie;	state Exp;
branches;
next	1.9;

1.9
date	2010.06.30.10.51.04;	author espie;	state Exp;
branches;
next	1.8;

1.8
date	2010.06.30.10.41.42;	author espie;	state Exp;
branches;
next	1.7;

1.7
date	2010.06.30.10.11.23;	author espie;	state Exp;
branches;
next	1.6;

1.6
date	2010.06.25.10.34.03;	author espie;	state Exp;
branches;
next	1.5;

1.5
date	2010.06.25.10.19.00;	author espie;	state Exp;
branches;
next	1.4;

1.4
date	2010.06.15.08.29.22;	author espie;	state Exp;
branches;
next	1.3;

1.3
date	2010.06.15.08.26.39;	author espie;	state Exp;
branches;
next	1.2;

1.2
date	2010.06.09.11.57.21;	author espie;	state Exp;
branches;
next	1.1;

1.1
date	2010.06.09.07.26.01;	author espie;	state Exp;
branches;
next	;


desc
@@


1.45
log
@tweak installurl code to return a single string that gets parsed
so that we don't have to write the same thing twice later.
@
text
@# ex:ts=8 sw=4:
# $OpenBSD: State.pm,v 1.44 2017/03/01 10:35:24 espie Exp $
#
# Copyright (c) 2007-2014 Marc Espie <espie@@openbsd.org>
#
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
#

use strict;
use warnings;

package OpenBSD::PackageRepositoryFactory;
sub new
{
	my ($class, $state) = @@_;
	bless {state => $state}, $class;
}

sub installed
{
	my ($self, $all) = @@_;
	require OpenBSD::PackageRepository::Installed;

	return OpenBSD::PackageRepository::Installed->new($all, $self->{state});
}

sub path_parse
{
	my ($self, $pkgname) = @@_;
	require OpenBSD::PackageLocator;

	return OpenBSD::PackageLocator->path_parse($pkgname, $self->{state});
}

sub find
{
	my ($self, $pkg) = @@_;
	require OpenBSD::PackageLocator;

	return OpenBSD::PackageLocator->find($pkg, $self->{state});
}

sub reinitialize
{
}

sub match_locations
{
	my $self = shift;
	require OpenBSD::PackageLocator;

	return OpenBSD::PackageLocator->match_locations(@@_, $self->{state});
}

sub grabPlist
{
	my ($self, $url, $code) = @@_;
	require OpenBSD::PackageLocator;

	return OpenBSD::PackageLocator->grabPlist($url, $code, $self->{state});
}

sub path
{
	my $self = shift;
	require OpenBSD::PackageRepositoryList;

	return OpenBSD::PackageRepositoryList->new($self->{state});
}

# common routines to everything state.
# in particular, provides "singleton-like" access to UI.
package OpenBSD::State;
use Carp;
use OpenBSD::Subst;
use OpenBSD::Error;
require Exporter;
our @@ISA = qw(Exporter);
our @@EXPORT = ();

sub new
{
	my $class = shift;
	my $cmd = shift;
	my $o = bless {cmd => $cmd}, $class;
	$o->init(@@_);
	return $o;
}

sub init
{
	my $self = shift;
	$self->{subst} = OpenBSD::Subst->new;
	$self->{repo} = OpenBSD::PackageRepositoryFactory->new($self);
	$self->{export_level} = 1;
}

sub repo
{
	my $self = shift;
	return $self->{repo};
}

sub sync_display
{
}

OpenBSD::Auto::cache(installpath,
	sub {
		my $self = shift;
		require OpenBSD::Paths;
		open(my $fh, '<', OpenBSD::Paths->installurl) or return undef;
		while (<$fh>) {
			chomp;
			next if m/^\s*\#/;
			next if m/^\s*$/;
			return "$_/%c/packages/%a/";
		}
	});

sub usage_is
{
	my ($self, @@usage) = @@_;
	$self->{usage} = \@@usage;
}

sub verbose
{
	my $self = shift;
	return $self->{v};
}

sub opt
{
	my ($self, $k) = @@_;
	return $self->{opt}{$k};
}

sub usage
{
	my $self = shift;
	my $code = 0;
	if (@@_) {
		print STDERR "$self->{cmd}: ", $self->f(@@_), "\n";
		$code = 1;
	}
	print STDERR "Usage: $self->{cmd} ", shift(@@{$self->{usage}}), "\n";
	for my $l (@@{$self->{usage}}) {
		print STDERR "       $l\n";
	}
	exit($code);
}

sub f
{
	my $self = shift;
	if (@@_ == 0) {
		return undef;
	}
	my ($fmt, @@l) = @@_;
	# make it so that #0 is #
	unshift(@@l, '#');
	$fmt =~ s,\#(\d+),($l[$1] // "<Undefined #$1>"),ge;
	return $fmt;
}

sub _fatal
{
	my $self = shift;
	# implementation note: to print "fatal errors" elsewhere,
	# the way is to eval { croak @@_}; and decide what to do with $@@.
	delete $SIG{__DIE__};
	$self->sync_display;
	croak "Fatal error: ", @@_, "\n";
}

sub fatal
{
	my $self = shift;
	$self->_fatal($self->f(@@_));
}

sub _fhprint
{
	my $self = shift;
	my $fh = shift;
	$self->sync_display;
	print $fh @@_;
}
sub _print
{
	my $self = shift;
	$self->_fhprint(\*STDOUT, @@_);
}

sub _errprint
{
	my $self = shift;
	$self->_fhprint(\*STDERR, @@_);
}

sub fhprint
{
	my $self = shift;
	my $fh = shift;
	$self->_fhprint($fh, $self->f(@@_));
}

sub fhsay
{
	my $self = shift;
	my $fh = shift;
	if (@@_ == 0) {
		$self->_fhprint($fh, "\n");
	} else {
		$self->_fhprint($fh, $self->f(@@_), "\n");
	}
}

sub print
{
	my $self = shift;
	$self->fhprint(\*STDOUT, @@_);
}

sub say
{
	my $self = shift;
	$self->fhsay(\*STDOUT, @@_);
}

sub errprint
{
	my $self = shift;
	$self->fhprint(\*STDERR, @@_);
}

sub errsay
{
	my $self = shift;
	$self->fhsay(\*STDERR, @@_);
}

sub do_options
{
	my ($state, $sub) = @@_;
	# this could be nicer...

	try {
		&$sub;
	} catchall {
		$state->usage("#1", $_);
	};
}

sub handle_options
{
	my ($state, $opt_string, @@usage) = @@_;
	require OpenBSD::Getopt;

	$state->{opt}{v} = 0 unless $opt_string =~ m/v/;
	$state->{opt}{h} = sub { $state->usage; } unless $opt_string =~ m/h/;
	$state->{opt}{D} = sub {
		$state->{subst}->parse_option(shift);
	} unless $opt_string =~ m/D/;
	$state->usage_is(@@usage);
	$state->do_options(sub {
		OpenBSD::Getopt::getopts($opt_string.'hvD:', $state->{opt});
	});
	$state->{v} = $state->opt('v');

	if ($state->defines('unsigned')) {
		$state->{signature_style} //= 'unsigned';
	} elsif ($state->defines('oldsign')) {
		$state->fatal('old style signature no longer supported');
	} else {
		$state->{signature_style} //= 'new';
	}

	return if $state->{no_exports};
	# XXX
	no strict "refs";
	no strict "vars";
	for my $k (keys %{$state->{opt}}) {
		${"opt_$k"} = $state->opt($k);
		push(@@EXPORT, "\$opt_$k");
	}
	local $Exporter::ExportLevel = $state->{export_level};
	import OpenBSD::State;
}

sub defines
{
	my ($self, $k) = @@_;
	return $self->{subst}->value($k);
}

sub width
{
	my $self = shift;
	if (!defined $self->{width}) {
		$self->find_window_size;
	}
	return $self->{width};
}

sub height
{
	my $self = shift;
	if (!defined $self->{height}) {
		$self->find_window_size;
	}
	return $self->{height};
}
		
sub find_window_size
{
	my $self = shift;
	require Term::ReadKey;
	my @@l = Term::ReadKey::GetTermSizeGWINSZ(\*STDOUT);
	if (@@l != 4) {
		$self->{width} = 80;
		$self->{height} = 24;
	} else {
		$self->{width} = $l[0];
		$self->{height} = $l[1];
		$SIG{'WINCH'} = sub {
			$self->find_window_size;
		};
	}
	$SIG{'CONT'} = sub {
		$self->find_window_size(1);
	}
}

OpenBSD::Auto::cache(signer_list,
	sub {
		my $self = shift;
		if ($self->defines('SIGNER')) {
			return [split /,/, $self->{subst}->value('SIGNER')];
		} else {
			if ($self->defines('FW_UPDATE')) {
				return [qr{^.*fw$}];
			} else {
				return [qr{^.*pkg$}];
			}
		}
	});

my @@signal_name = ();
sub fillup_names
{
	{
	# XXX force autoload
	package verylocal;

	require POSIX;
	POSIX->import(qw(signal_h));
	}

	for my $sym (keys %POSIX::) {
		next unless $sym =~ /^SIG([A-Z].*)/;
		$signal_name[eval "&POSIX::$sym()"] = $1;
	}
	# extra BSD signals
	$signal_name[5] = 'TRAP';
	$signal_name[7] = 'IOT';
	$signal_name[10] = 'BUS';
	$signal_name[12] = 'SYS';
	$signal_name[16] = 'URG';
	$signal_name[23] = 'IO';
	$signal_name[24] = 'XCPU';
	$signal_name[25] = 'XFSZ';
	$signal_name[26] = 'VTALRM';
	$signal_name[27] = 'PROF';
	$signal_name[28] = 'WINCH';
	$signal_name[29] = 'INFO';
}

sub find_signal
{
	my $number =  shift;

	if (@@signal_name == 0) {
		fillup_names();
	}

	return $signal_name[$number] || $number;
}

sub child_error
{
	my $self = shift;
	my $error = $?;

	my $extra = "";

	if ($error & 128) {
		$extra = $self->f(" (core dumped)");
	}
	if ($error & 127) {
		return $self->f("killed by signal #1#2",
		    find_signal($error & 127), $extra);
	} else {
		return $self->f("exit(#1)#2", ($error >> 8), $extra);
	}
}

sub _system
{
	my $self = shift;
	$self->sync_display;
	my $r = fork;
	my ($todo, $todo2);
	if (ref $_[0] eq 'CODE') {
		$todo = shift;
	} else {
		$todo = sub {};
	}
	if (ref $_[0] eq 'CODE') {
		$todo2 = shift;
	} else {
		$todo2 = sub {};
	}
	if (!defined $r) {
		return 1;
	} elsif ($r == 0) {
		&$todo;
		exec {$_[0]} @@_ or return 1;
	} else {
		&$todo2;
		waitpid($r, 0);
		return $?;
	}
}

sub system
{
	my $self = shift;
	my $r = $self->_system(@@_);
	if ($r != 0) {
		if (ref $_[0] eq 'CODE') {
			shift;
		}
		if (ref $_[0] eq 'CODE') {
			shift;
		}
		$self->say("system(#1) failed: #2",
		    join(", ", @@_), $self->child_error);
	}
	return $r;
}

sub verbose_system
{
	my $self = shift;
	my @@p = @@_;
	if (ref $p[0]) {
		shift @@p;
	}
	if (ref $p[0]) {
		shift @@p;
	}

	$self->print("Running #1", join(' ', @@p));
	my $r = $self->_system(@@_);
	if ($r != 0) {
		$self->say("... failed: #1", $self->child_error);
	} else {
		$self->say;
	}
}

sub copy_file
{
	my $self = shift;
	require File::Copy;

	my $r = File::Copy::copy(@@_);
	if (!$r) {
		$self->say("copy(#1) failed: #2", join(',', @@_), $!);
	}
	return $r;
}

sub unlink
{
	my $self = shift;
	my $verbose = shift;
	my $r = unlink @@_;
	if ($r != @@_) {
		$self->say("rm #1 failed: removed only #2 targets, #3",
		    join(' ', @@_), $r, $!);
	} elsif ($verbose) {
		$self->say("rm #1", join(' ', @@_));
	}
	return $r;
}

sub copy
{
	my $self = shift;
	require File::Copy;

	my $r = File::Copy::copy(@@_);
	if (!$r) {
		$self->say("copy(#1) failed: #2", join(',', @@_), $!);
	}
	return $r;
}

1;
@


1.44
log
@scrape most of the config framework
okay aja@@, rpe@@
@
text
@d2 1
a2 1
# $OpenBSD: State.pm,v 1.43 2017/02/27 21:53:11 rpe Exp $
d122 1
a122 1
		open(my $fh, '<', OpenBSD::Paths->installurl) or return [];
d127 1
a127 1
			return ["$_/%c/packages/%a/"];
@


1.43
log
@Remove support for pkg.conf in light of the consolidation towards
a single configuration file for the OpenBSD repository location.

The pkg_* tools now use installurl(5) to find the package repository.

NOTE:
/etc/installurl only contains a single URL pointing to a mirror.
Use the PKG_PATH environment variable to specify more than one
package repository.

prodded by and OK deraadt@@ aja@@
@
text
@d2 1
a2 1
# $OpenBSD: State.pm,v 1.42 2017/02/06 15:13:23 espie Exp $
a21 88
package OpenBSD::Configuration;
sub new
{
	my ($class, $state) = @@_;
	my $self = bless {}, $class;
	require OpenBSD::Paths;
	$self->add_installurl(OpenBSD::Paths->installurl, $state);
	return $self;
}

sub add_installurl
{
	my ($self, $filename, $state) = @@_;
	open(my $fh, '<', $filename) or return;
	while (<$fh>) {
		chomp;
		next if m/^\s*\#/;
		next if m/^\s*$/;
		$self->{installpath} = ["$_/%c/packages/%a/"];
		return;
	}
}

sub read_file
{
	my ($self, $filename, $state) = @@_;
	open(my $fh, '<', $filename) or return;
	while (<$fh>) {
		chomp;
		next if m/^\s*\#/;
		next if m/^\s*$/;
		my ($cmd, $k, $v, $add);
		my $h = $self;
		if (($cmd, $k, $add, $v) = m/^\s*(.*?)\.(.*?)\s*(\+?)\=\s*(.*?)\s*$/) {
			next unless $cmd eq $state->{cmd};
			my $h = $self->{cmd} = {};
		} elsif (($k, $add, $v) = m/^\s*(.*?)\s*(\+?)\=\s*(.*?)\s*$/) {
		} else {
			# bad line: should we say so ?
			$state->errsay("Bad line in #1: #2 (#3)",
			    $filename, $_, $.);
			next;
		}
		# remove caps
		$k =~ tr/A-Z/a-z/;
		if ($add eq '') {
			$h->{$k} = [$v];
		} else {
			push(@@{$h->{$k}}, $v);
		}
	}
}

sub ref
{
	my ($self, $k) = @@_;
	if (defined $self->{cmd}{$k}) {
		return $self->{cmd}{$k};
	} else {
		return $self->{$k};
	}
}

sub value
{
	my ($self, $k) = @@_;
	my $r = $self->ref($k);
	if (!defined $r) {
		return $r;
	}
	if (wantarray) {
		return @@$r;
	} else {
		return $r->[0];
	}
}

sub istrue
{
	my ($self, $k) = @@_;
	my $v = $self->value($k);
	if (defined $v && $v =~ /^yes$/i) {
		return 1;
	} else {
		return 0;
	}
}

d118 1
a118 1
OpenBSD::Auto::cache(config,
d120 9
a128 1
		return OpenBSD::Configuration->new(shift);
@


1.42
log
@basic installurl support, get installpath from it (appending the requisite
magic for packages location...).   Fairly straightforward

if pkg.conf defines installpath=, it takes precedence
(manual trumps automatic)

to be fully documented once the dust settles.

okay aja@@
@
text
@d2 1
a2 1
# $OpenBSD: State.pm,v 1.41 2017/02/05 14:00:42 rpe Exp $
a28 1
	$self->read_file(OpenBSD::Paths->pkgconf, $state);
@


1.41
log
@Use a non-greedy regular expression for the installpath url.
This ensures, that a trailing whitespace does not break pkg_add.

OK espie@@
@
text
@d2 1
a2 1
# $OpenBSD: State.pm,v 1.40 2016/10/03 13:58:09 espie Exp $
d28 1
d31 13
@


1.40
log
@gc the old checking code in pkg_add
@
text
@d2 1
a2 1
# $OpenBSD: State.pm,v 1.39 2016/09/27 21:31:20 naddy Exp $
d42 1
a42 1
		if (($cmd, $k, $add, $v) = m/^\s*(.*?)\.(.*?)\s*(\+?)\=\s*(.*)\s*$/) {
d45 1
a45 1
		} elsif (($k, $add, $v) = m/^\s*(.*?)\s*(\+?)\=\s*(.*)\s*$/) {
@


1.39
log
@switch to using the new package signature scheme (signify2) by default
ok sthen@@
@
text
@d2 1
a2 1
# $OpenBSD: State.pm,v 1.38 2016/09/14 14:14:22 espie Exp $
d349 1
a349 3
	if ($state->defines('newsign')) {
		$state->{signature_style} //= 'new';
	} elsif ($state->defines('unsigned')) {
d352 1
a352 1
		$state->{signature_style} //= 'old';
@


1.38
log
@move the check up in state
@
text
@d2 1
a2 1
# $OpenBSD: State.pm,v 1.37 2016/06/24 11:42:30 espie Exp $
a348 1
	# XXX switch not flipped
d356 1
a356 1
		$state->{signature_style} //= 'old';
@


1.37
log
@simplify the logic. no need for a separate hook when we can just specialize
find_window_size.
fix a bug: integrate SIG{CONT} for re-checking window size.

the way it's currently written, first call to compute_playfield will
call itself once. But it makes for less code.
@
text
@d2 1
a2 1
# $OpenBSD: State.pm,v 1.36 2016/06/23 16:11:23 espie Exp $
d348 12
@


1.36
log
@there's no reason for window size computation to be linked to the
ProgressMeter, so make it available from state.
- computation is lazy, so no runtime difference;
- don't bother setting a SIG{WINCH} on non-tty;
- progressmeter already has access to state;
- do an empty window_size_changed in base state, override it for
addcreatedelete to inform the progressmeter.

to be reused in dpb...
@
text
@d2 1
a2 1
# $OpenBSD: State.pm,v 1.35 2016/06/23 12:44:10 espie Exp $
a396 1
			$self->window_size_changed;
d399 3
a401 4
}

sub window_size_changed
{
@


1.35
log
@add fh variation of printing code. Systematically use it with STDOUT/STDERR
for classical functions.
@
text
@d2 1
a2 1
# $OpenBSD: State.pm,v 1.34 2015/04/06 11:07:24 espie Exp $
d364 40
@


1.34
log
@move signer_list up so pkg_info can use it
@
text
@d2 1
a2 1
# $OpenBSD: State.pm,v 1.33 2014/11/30 15:56:15 espie Exp $
d260 7
d270 1
a270 2
	$self->sync_display;
	print @@_;
d276 1
a276 2
	$self->sync_display;
	print STDERR @@_;
d279 1
a279 1
sub print
d282 2
a283 1
	$self->_print($self->f(@@_));
d286 1
a286 1
sub say
d289 1
d291 1
a291 1
		$self->_print("\n");
d293 1
a293 1
		$self->_print($self->f(@@_), "\n");
d297 12
d312 1
a312 1
	$self->_errprint($self->f(@@_));
d318 1
a318 5
	if (@@_ == 0) {
		$self->_errprint("\n");
	} else {
		$self->_errprint($self->f(@@_), "\n");
	}
@


1.33
log
@much cleaner way to handle progress meter wipes: have state methods that
do print something call sync_display (which does nothing by default), and
override THAT one for the progressmeter case to go clear.
Should sync by default now.
@
text
@d2 1
a2 1
# $OpenBSD: State.pm,v 1.32 2014/07/27 22:19:18 espie Exp $
d350 14
@


1.32
log
@make sure makewhatis shows error messages without unsightly CODE() refs
@
text
@d2 1
a2 1
# $OpenBSD: State.pm,v 1.31 2014/07/08 16:52:47 espie Exp $
d189 4
d250 1
d263 1
d270 1
d413 1
@


1.31
log
@in case we say("Some parameter #1 blabla there") but we
forget the parameter, display a decent error message instead
of the usual warning...
@
text
@d2 1
a2 1
# $OpenBSD: State.pm,v 1.30 2014/06/10 15:50:01 espie Exp $
d435 6
@


1.30
log
@get verbose_system in line with _system, do not display \&code snippets...
@
text
@d2 1
a2 1
# $OpenBSD: State.pm,v 1.29 2014/05/30 15:04:54 espie Exp $
d236 1
a236 1
	$fmt =~ s/\#(\d+)/$l[$1]/ge;
@


1.29
log
@oops, auto-read config only *after* we have a way to print out errors.
Also zap bad lines completely.

issue reported by aja@@
@
text
@d2 1
a2 1
# $OpenBSD: State.pm,v 1.28 2014/05/20 05:43:55 espie Exp $
d444 7
d452 1
a452 1
	$self->print("Running #1", join(' ', @@_));
@


1.28
log
@fix bogus extension: $code and $code2 belong in _system, so that
both system and verbose_system will work properly.
@
text
@d2 1
a2 1
# $OpenBSD: State.pm,v 1.27 2014/03/18 18:53:29 espie Exp $
d50 1
@


1.27
log
@remove $_ usage that warns under perl 5.18
@
text
@d2 1
a2 1
# $OpenBSD: State.pm,v 1.26 2014/03/18 16:42:24 espie Exp $
d404 1
a404 1
	my ($self, $todo, $todo2, @@r) = @@_;
d406 11
d421 1
a421 1
		exec {$r[0]} @@r or return 1;
d432 1
a432 12
	my ($todo, $todo2);
	if (ref $_[0] eq 'CODE') {
		$todo = shift;
	} else {
		$todo = sub {};
	}
	if (ref $_[0] eq 'CODE') {
		$todo2 = shift;
	} else {
		$todo2 = sub {};
	}
	my $r = $self->_system($todo, $todo2, @@_);
a442 6
	my $todo;
	if (ref $_[0] eq 'CODE') {
		$todo = shift;
	} else {
		$todo = sub {};
	}
d445 1
a445 1
	my $r = $self->_system($todo, @@_);
@


1.26
log
@... and commit this as well (linked to new signify.pm): allows specific
block of code to run on both father&child sides, thus making our system
more useful around pipes...

Also zap two "my $_" on while(<>) to prepare for new perl.
@
text
@d2 1
a2 1
# $OpenBSD: State.pm,v 1.25 2014/01/09 20:20:01 espie Exp $
d232 1
a232 1
	my ($_, @@l) = @@_;
d235 2
a236 2
	s/\#(\d+)/$l[$1]/ge;
	return $_;
@


1.25
log
@bump copyright to 2014
@
text
@d2 1
a2 1
# $OpenBSD: State.pm,v 1.24 2014/01/07 01:35:56 espie Exp $
a35 1
	my $_;
d404 1
a404 1
	my ($self, $todo) = (shift, shift);
d410 1
a410 1
		exec {$_[0]} @@_ or return 1;
d412 1
d421 1
a421 1
	my $todo;
d427 6
a432 1
	my $r = $self->_system($todo, @@_);
@


1.24
log
@... and let sign_list(\@@ARGV... work too)
@
text
@d2 1
a2 1
# $OpenBSD: State.pm,v 1.23 2012/05/01 10:18:13 espie Exp $
d4 1
a4 1
# Copyright (c) 2007-2010 Marc Espie <espie@@openbsd.org>
@


1.23
log
@properly pass extra parameters from State->new to init.
@
text
@d2 1
a2 1
# $OpenBSD: State.pm,v 1.22 2012/04/10 16:57:12 espie Exp $
d126 4
@


1.22
log
@prevent dpb trace handler from getting in the way of normal usage error reports.
@
text
@d2 1
a2 1
# $OpenBSD$
d164 2
a165 1
	my ($class, $cmd) = @@_;
@


1.21
log
@zap fatpackages. nobody actually uses them.
accordingly, locations do not need to track architecture.
@
text
@d2 1
a2 1
# $OpenBSD: State.pm,v 1.20 2010/12/24 09:04:14 espie Exp $
d240 1
@


1.20
log
@handle failures from ports tree with more care.
this does avoid infinite loops in case of wrong plists.
necessary since print-plist-with-depends CAN fail...
@
text
@d2 1
a2 1
# $OpenBSD$
d122 1
a122 1
	my ($self, $pkg, $arch) = @@_;
d125 1
a125 1
	return OpenBSD::PackageLocator->find($pkg, $arch, $self->{state});
d138 1
a138 1
	my ($self, $url, $arch, $code) = @@_;
d141 1
a141 1
	return OpenBSD::PackageLocator->grabPlist($url, $arch, $code, $self->{state});
@


1.19
log
@bump ->defines up to main state class.
@
text
@d2 1
a2 1
# $OpenBSD: State.pm,v 1.18 2010/10/24 17:04:47 espie Exp $
@


1.18
log
@redo ->system in a smarter way (fork+exec) so that we can sneak in a code
reference to be run before the command.
@
text
@d2 1
a2 1
# $OpenBSD: State.pm,v 1.17 2010/10/02 13:33:05 espie Exp $
d330 6
@


1.17
log
@whitespace
@
text
@d2 1
a2 1
# $OpenBSD$
d391 15
d409 7
a415 1
	my $r = CORE::system(@@_);
d426 6
d434 1
a434 1
	my $r = CORE::system(@@_);
@


1.16
log
@typo in message
@
text
@d2 1
a2 1
# $OpenBSD: State.pm,v 1.15 2010/07/12 09:31:52 espie Exp $
d49 1
a49 1
			$state->errsay("Bad line in #1: #2 (#3)", 
@


1.15
log
@need to copy f() parameters, otherwise strange bugs with sub expressions
may occur (bug in locality in @@_ ?)

Add missing bagage to State.pm to be able to interact directly with
Makewhatis, later.
@
text
@d2 1
a2 1
# $OpenBSD: State.pm,v 1.14 2010/07/09 12:42:43 espie Exp $
d90 1
a90 1
	if (defined $v && $v =~ /^(?:1|yes|y|on|true|t)$/) {
d434 1
a434 1
		    join(' ', @@_), $r, $1);
@


1.14
log
@fix pkg_mklocatedb
@
text
@d2 1
a2 1
# $OpenBSD: State.pm,v 1.13 2010/07/04 19:27:26 espie Exp $
d228 1
a228 1
	my $_ = shift;
d230 2
a231 2
	unshift(@@_, '#');
	s/\#(\d+)/$_[$1]/ge;
@


1.13
log
@best if I don't forget half of the commit...
@
text
@d2 1
a2 1
# $OpenBSD: State.pm,v 1.12 2010/07/02 12:42:49 espie Exp $
d175 1
d328 1
a328 1
	local $Exporter::ExportLevel = 1;
@


1.12
log
@parse pkg.conf and use it for default_path if PKG_PATH is not defined.
@
text
@d2 1
a2 1
# $OpenBSD: State.pm,v 1.11 2010/07/02 11:17:46 espie Exp $
d83 11
@


1.11
log
@pass (and save) state around in Repository-related stuff.
@
text
@d2 1
a2 1
# $OpenBSD: State.pm,v 1.10 2010/06/30 11:32:20 espie Exp $
d22 64
d171 5
@


1.10
log
@handle GrabPlist as well
@
text
@d2 1
a2 1
# $OpenBSD: State.pm,v 1.9 2010/06/30 10:51:04 espie Exp $
d34 1
a34 1
	return OpenBSD::PackageRepository::Installed->new($all);
d42 1
a42 1
	return OpenBSD::PackageLocator->path_parse($pkgname);
d50 1
a50 1
	return OpenBSD::PackageLocator->find($pkg, $arch);
d58 1
a58 1
	return OpenBSD::PackageLocator->match_locations(@@_);
d63 1
a63 1
	my $self = shift;
d66 1
a66 1
	return OpenBSD::PackageLocator->grabPlist(@@_);
d74 1
a74 1
	return OpenBSD::PackageRepositoryList->new;
@


1.9
log
@allow say and errsay to work without parameters, as it's ways common.
create verbose_system up in state, because it makes sense without verbose.
@
text
@d2 1
a2 1
# $OpenBSD$
d59 8
@


1.8
log
@whitespace cleanup
@
text
@d181 5
a185 1
	$self->_print($self->f(@@_), "\n");
d197 5
a201 1
	$self->_errprint($self->f(@@_), "\n");
d311 13
@


1.7
log
@create RepositoryFactory object that can be used as a single access point
for all PackageRepository-related operations (so that tweaking parameters
and initialization happens in one single location)
@
text
@d2 1
a2 1
# $OpenBSD: State.pm,v 1.6 2010/06/25 10:34:03 espie Exp $
d287 1
a287 1
		return $self->f("killed by signal #1#2", 
d299 1
a299 1
		$self->say("system(#1) failed: #2", 
@


1.6
log
@do options the other way so that we provide defaults that can be overridden
locally
@
text
@d2 1
a2 1
# $OpenBSD: State.pm,v 1.5 2010/06/25 10:19:00 espie Exp $
d22 47
d74 1
d91 7
a198 1
	require OpenBSD::Error;
d200 6
a205 3
	eval { &$sub; };
	OpenBSD::Error::dienow($@@, 
	    bless sub { $state->usage("#1", $_)}, "OpenBSD::Error::catchall");
@


1.5
log
@move common options (-D/-v) handling code upto State.
rework handle_options to be code in state proper, so that I can remove
a class that's actually useless.
reuse the export code from getopt so that legacy code still get opt_x
working.
@
text
@d2 1
a2 1
# $OpenBSD: State.pm,v 1.4 2010/06/15 08:29:22 espie Exp $
d156 2
a157 2
	$state->{opt}{v} = 0;
	$state->{opt}{h} = sub { $state->usage; };
d160 1
a160 1
	};
d163 1
a163 1
		OpenBSD::Getopt::getopts('hvD:'.$opt_string, $state->{opt});
@


1.4
log
@typo
@
text
@d2 1
a2 1
# $OpenBSD: State.pm,v 1.3 2010/06/15 08:26:39 espie Exp $
d26 4
d41 2
d51 12
d149 27
@


1.3
log
@more printing changes.

move log operations into their own file, since they're used outside of
pkg_add/pkg_delete by pkg_check.

move all system stuff to State, so that printing can be localized/controlled.
Create primitives _print, _errprint, _fatal for overriding output, without
localization.

Accordingly, move a lot of code out of Error. We should also move Unlink and
Copy eventually.
@
text
@d2 1
a2 1
# $OpenBSD: State.pm,v 1.2 2010/06/09 11:57:21 espie Exp $
d108 1
a108 1
	$self-_print($self->f(@@_), "\n");
@


1.2
log
@common pattern reuse
@
text
@d2 1
a2 1
# $OpenBSD$
d73 1
a73 1
sub fatal
d78 19
a96 1
	croak "Fatal error: ", $self->f(@@_), "\n";
d102 1
a102 1
	print $self->f(@@_);
d108 1
a108 1
	print $self->f(@@_), "\n";
d114 1
a114 1
	print STDERR $self->f(@@_);
d120 1
a120 1
	print STDERR $self->f(@@_), "\n";
d131 108
@


1.1
log
@ui changes: go thru a state object for most printouts
@
text
@d105 10
@

