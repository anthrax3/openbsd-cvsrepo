head	1.247;
access;
symbols
	OPENBSD_6_2_BASE:1.247
	OPENBSD_6_1:1.245.0.4
	OPENBSD_6_1_BASE:1.245
	OPENBSD_6_0:1.244.0.4
	OPENBSD_6_0_BASE:1.244
	OPENBSD_5_9:1.243.0.2
	OPENBSD_5_9_BASE:1.243
	OPENBSD_5_8:1.242.0.4
	OPENBSD_5_8_BASE:1.242
	OPENBSD_5_7:1.239.0.2
	OPENBSD_5_7_BASE:1.239
	OPENBSD_5_6:1.235.0.4
	OPENBSD_5_6_BASE:1.235
	OPENBSD_5_5:1.233.0.4
	OPENBSD_5_5_BASE:1.233
	OPENBSD_5_4:1.212.0.2
	OPENBSD_5_4_BASE:1.212
	OPENBSD_5_3:1.211.0.2
	OPENBSD_5_3_BASE:1.211
	OPENBSD_5_2:1.207.0.2
	OPENBSD_5_2_BASE:1.207
	OPENBSD_5_1_BASE:1.201
	OPENBSD_5_1:1.201.0.2
	OPENBSD_5_0:1.199.0.2
	OPENBSD_5_0_BASE:1.199
	OPENBSD_4_9:1.194.0.2
	OPENBSD_4_9_BASE:1.194
	OPENBSD_4_8:1.183.0.2
	OPENBSD_4_8_BASE:1.183
	OPENBSD_4_7:1.173.0.2
	OPENBSD_4_7_BASE:1.173
	OPENBSD_4_6:1.156.0.4
	OPENBSD_4_6_BASE:1.156
	OPENBSD_4_5:1.152.0.2
	OPENBSD_4_5_BASE:1.152
	OPENBSD_4_4:1.148.0.2
	OPENBSD_4_4_BASE:1.148
	OPENBSD_4_3:1.143.0.4
	OPENBSD_4_3_BASE:1.143
	OPENBSD_4_2:1.143.0.2
	OPENBSD_4_2_BASE:1.143
	OPENBSD_4_1:1.86.0.2
	OPENBSD_4_1_BASE:1.86
	OPENBSD_4_0:1.83.0.2
	OPENBSD_4_0_BASE:1.83
	OPENBSD_3_9:1.80.0.2
	OPENBSD_3_9_BASE:1.80
	OPENBSD_3_8:1.77.0.2
	OPENBSD_3_8_BASE:1.77
	OPENBSD_3_7:1.75.0.2
	OPENBSD_3_7_BASE:1.75
	OPENBSD_3_6:1.22.0.2
	OPENBSD_3_6_BASE:1.22
	OPENBSD_3_5:1.7.0.2
	OPENBSD_3_5_BASE:1.7
	pkgtools:1.1.1.1
	espie:1.1.1;
locks; strict;
comment	@# @;


1.247
date	2017.09.16.11.36.25;	author espie;	state Exp;
branches;
next	1.246;
commitid	ulE0zXUtvlHkfCk2;

1.246
date	2017.05.15.15.14.11;	author schwarze;	state Exp;
branches;
next	1.245;
commitid	bZZDkESX9RlIhEzK;

1.245
date	2017.03.03.14.06.32;	author espie;	state Exp;
branches;
next	1.244;
commitid	bNSFa2yCbJO7px2f;

1.244
date	2016.06.25.18.02.59;	author espie;	state Exp;
branches;
next	1.243;
commitid	o0xYSWZBh7faPr35;

1.243
date	2016.02.03.18.30.15;	author robert;	state Exp;
branches;
next	1.242;
commitid	1CSdxNzAHLPF2L4Q;

1.242
date	2015.04.20.13.10.54;	author espie;	state Exp;
branches;
next	1.241;
commitid	Y1KlSLdVHP6wl7bT;

1.241
date	2015.04.16.13.29.16;	author espie;	state Exp;
branches;
next	1.240;
commitid	glpsNd6nX6NAzNf5;

1.240
date	2015.04.16.09.32.23;	author espie;	state Exp;
branches;
next	1.239;
commitid	Nsp1TyPshg4itCKw;

1.239
date	2015.02.25.16.37.15;	author sthen;	state Exp;
branches;
next	1.238;
commitid	yWnkrVEm0fE58Oxp;

1.238
date	2014.12.23.08.46.31;	author espie;	state Exp;
branches;
next	1.237;
commitid	9RA6Fzd3hxtPT6qv;

1.237
date	2014.10.13.12.44.16;	author espie;	state Exp;
branches;
next	1.236;
commitid	O74FclwE2iqZYO3l;

1.236
date	2014.09.09.09.40.23;	author espie;	state Exp;
branches;
next	1.235;
commitid	3LnGk6tZmORiAACe;

1.235
date	2014.07.10.10.32.01;	author espie;	state Exp;
branches;
next	1.234;
commitid	67aPPsPHmCNALsP2;

1.234
date	2014.03.18.18.53.29;	author espie;	state Exp;
branches;
next	1.233;

1.233
date	2014.02.10.19.12.20;	author espie;	state Exp;
branches;
next	1.232;

1.232
date	2014.02.09.19.22.19;	author espie;	state Exp;
branches;
next	1.231;

1.231
date	2014.02.03.16.18.05;	author espie;	state Exp;
branches;
next	1.230;

1.230
date	2014.02.03.16.13.13;	author espie;	state Exp;
branches;
next	1.229;

1.229
date	2014.02.03.15.57.13;	author espie;	state Exp;
branches;
next	1.228;

1.228
date	2014.01.31.15.48.44;	author espie;	state Exp;
branches;
next	1.227;

1.227
date	2014.01.11.11.51.01;	author espie;	state Exp;
branches;
next	1.226;

1.226
date	2014.01.09.20.20.01;	author espie;	state Exp;
branches;
next	1.225;

1.225
date	2014.01.07.18.35.23;	author espie;	state Exp;
branches;
next	1.224;

1.224
date	2014.01.07.13.52.43;	author espie;	state Exp;
branches;
next	1.223;

1.223
date	2014.01.07.13.37.23;	author espie;	state Exp;
branches;
next	1.222;

1.222
date	2014.01.07.13.31.36;	author espie;	state Exp;
branches;
next	1.221;

1.221
date	2014.01.07.13.26.18;	author espie;	state Exp;
branches;
next	1.220;

1.220
date	2014.01.04.14.14.55;	author espie;	state Exp;
branches;
next	1.219;

1.219
date	2014.01.04.01.42.46;	author espie;	state Exp;
branches;
next	1.218;

1.218
date	2014.01.04.00.14.08;	author espie;	state Exp;
branches;
next	1.217;

1.217
date	2014.01.03.13.12.35;	author espie;	state Exp;
branches;
next	1.216;

1.216
date	2014.01.02.20.13.43;	author espie;	state Exp;
branches;
next	1.215;

1.215
date	2013.12.31.11.21.10;	author espie;	state Exp;
branches;
next	1.214;

1.214
date	2013.12.30.09.14.49;	author espie;	state Exp;
branches;
next	1.213;

1.213
date	2013.10.15.20.23.51;	author schwarze;	state Exp;
branches;
next	1.212;

1.212
date	2013.05.13.18.30.51;	author espie;	state Exp;
branches;
next	1.211;

1.211
date	2013.02.18.20.24.11;	author okan;	state Exp;
branches;
next	1.210;

1.210
date	2013.02.18.19.56.10;	author okan;	state Exp;
branches;
next	1.209;

1.209
date	2013.02.18.19.29.03;	author okan;	state Exp;
branches;
next	1.208;

1.208
date	2012.10.13.10.28.22;	author jeremy;	state Exp;
branches;
next	1.207;

1.207
date	2012.07.12.08.57.02;	author espie;	state Exp;
branches;
next	1.206;

1.206
date	2012.06.08.15.01.00;	author espie;	state Exp;
branches;
next	1.205;

1.205
date	2012.05.15.08.14.29;	author espie;	state Exp;
branches;
next	1.204;

1.204
date	2012.05.07.17.21.23;	author espie;	state Exp;
branches;
next	1.203;

1.203
date	2012.05.05.10.20.58;	author espie;	state Exp;
branches;
next	1.202;

1.202
date	2012.04.28.12.00.10;	author espie;	state Exp;
branches;
next	1.201;

1.201
date	2011.11.16.16.38.34;	author schwarze;	state Exp;
branches;
next	1.200;

1.200
date	2011.08.23.10.32.27;	author espie;	state Exp;
branches;
next	1.199;

1.199
date	2011.06.24.22.43.58;	author espie;	state Exp;
branches;
next	1.198;

1.198
date	2011.06.22.13.04.39;	author espie;	state Exp;
branches;
next	1.197;

1.197
date	2011.05.30.10.07.19;	author espie;	state Exp;
branches;
next	1.196;

1.196
date	2011.05.30.09.59.38;	author espie;	state Exp;
branches;
next	1.195;

1.195
date	2011.03.19.16.56.05;	author schwarze;	state Exp;
branches;
next	1.194;

1.194
date	2011.01.31.12.21.31;	author ajacoutot;	state Exp;
branches;
next	1.193;

1.193
date	2011.01.23.06.56.53;	author espie;	state Exp;
branches;
next	1.192;

1.192
date	2011.01.14.14.32.18;	author espie;	state Exp;
branches;
next	1.191;

1.191
date	2011.01.02.15.25.45;	author espie;	state Exp;
branches;
next	1.190;

1.190
date	2010.12.24.09.09.54;	author espie;	state Exp;
branches;
next	1.189;

1.189
date	2010.12.24.09.04.14;	author espie;	state Exp;
branches;
next	1.188;

1.188
date	2010.12.18.10.33.21;	author espie;	state Exp;
branches;
next	1.187;

1.187
date	2010.10.27.14.35.56;	author espie;	state Exp;
branches;
next	1.186;

1.186
date	2010.10.24.17.06.05;	author espie;	state Exp;
branches;
next	1.185;

1.185
date	2010.10.19.11.37.59;	author sthen;	state Exp;
branches;
next	1.184;

1.184
date	2010.10.19.07.29.41;	author espie;	state Exp;
branches;
next	1.183;

1.183
date	2010.08.03.14.07.27;	author espie;	state Exp;
branches;
next	1.182;

1.182
date	2010.06.30.10.51.04;	author espie;	state Exp;
branches;
next	1.181;

1.181
date	2010.06.30.10.41.42;	author espie;	state Exp;
branches;
next	1.180;

1.180
date	2010.06.15.08.26.39;	author espie;	state Exp;
branches;
next	1.179;

1.179
date	2010.06.09.07.26.01;	author espie;	state Exp;
branches;
next	1.178;

1.178
date	2010.06.04.17.29.53;	author espie;	state Exp;
branches;
next	1.177;

1.177
date	2010.06.04.13.19.39;	author espie;	state Exp;
branches;
next	1.176;

1.176
date	2010.05.10.09.17.55;	author espie;	state Exp;
branches;
next	1.175;

1.175
date	2010.04.05.16.07.10;	author espie;	state Exp;
branches;
next	1.174;

1.174
date	2010.04.05.14.08.56;	author espie;	state Exp;
branches;
next	1.173;

1.173
date	2010.01.19.14.26.24;	author espie;	state Exp;
branches;
next	1.172;

1.172
date	2010.01.10.11.31.08;	author espie;	state Exp;
branches;
next	1.171;

1.171
date	2010.01.09.17.44.21;	author espie;	state Exp;
branches;
next	1.170;

1.170
date	2010.01.05.17.53.23;	author espie;	state Exp;
branches;
next	1.169;

1.169
date	2010.01.05.11.31.07;	author espie;	state Exp;
branches;
next	1.168;

1.168
date	2010.01.01.13.36.07;	author espie;	state Exp;
branches;
next	1.167;

1.167
date	2009.12.30.09.39.08;	author espie;	state Exp;
branches;
next	1.166;

1.166
date	2009.12.30.09.37.55;	author espie;	state Exp;
branches;
next	1.165;

1.165
date	2009.12.20.22.38.45;	author espie;	state Exp;
branches;
next	1.164;

1.164
date	2009.12.17.11.57.02;	author espie;	state Exp;
branches;
next	1.163;

1.163
date	2009.11.11.13.00.40;	author espie;	state Exp;
branches;
next	1.162;

1.162
date	2009.11.11.12.47.13;	author espie;	state Exp;
branches;
next	1.161;

1.161
date	2009.11.11.12.32.03;	author espie;	state Exp;
branches;
next	1.160;

1.160
date	2009.11.11.12.04.19;	author espie;	state Exp;
branches;
next	1.159;

1.159
date	2009.11.11.11.13.16;	author espie;	state Exp;
branches;
next	1.158;

1.158
date	2009.11.10.11.36.56;	author espie;	state Exp;
branches;
next	1.157;

1.157
date	2009.11.03.11.03.19;	author espie;	state Exp;
branches;
next	1.156;

1.156
date	2009.04.19.14.58.32;	author espie;	state Exp;
branches;
next	1.155;

1.155
date	2009.04.14.17.53.58;	author espie;	state Exp;
branches;
next	1.154;

1.154
date	2009.03.05.10.43.00;	author espie;	state Exp;
branches;
next	1.153;

1.153
date	2009.03.03.11.01.26;	author espie;	state Exp;
branches;
next	1.152;

1.152
date	2008.10.28.09.51.58;	author espie;	state Exp;
branches;
next	1.151;

1.151
date	2008.10.24.16.50.27;	author espie;	state Exp;
branches;
next	1.150;

1.150
date	2008.10.20.10.25.16;	author espie;	state Exp;
branches;
next	1.149;

1.149
date	2008.10.06.09.36.17;	author espie;	state Exp;
branches;
next	1.148;

1.148
date	2008.06.11.12.21.03;	author espie;	state Exp;
branches;
next	1.147;

1.147
date	2008.06.11.09.42.13;	author espie;	state Exp;
branches;
next	1.146;

1.146
date	2008.06.06.14.49.21;	author espie;	state Exp;
branches;
next	1.145;

1.145
date	2008.05.31.11.53.46;	author espie;	state Exp;
branches;
next	1.144;

1.144
date	2008.03.08.12.07.45;	author espie;	state Exp;
branches;
next	1.143;

1.143
date	2007.07.14.21.50.05;	author ajacoutot;	state Exp;
branches;
next	1.142;

1.142
date	2007.06.18.10.47.03;	author espie;	state Exp;
branches;
next	1.141;

1.141
date	2007.06.17.12.09.36;	author espie;	state Exp;
branches;
next	1.140;

1.140
date	2007.06.17.10.44.01;	author espie;	state Exp;
branches;
next	1.139;

1.139
date	2007.06.17.09.50.02;	author espie;	state Exp;
branches;
next	1.138;

1.138
date	2007.06.16.12.16.42;	author espie;	state Exp;
branches;
next	1.137;

1.137
date	2007.06.16.11.50.49;	author espie;	state Exp;
branches;
next	1.136;

1.136
date	2007.06.16.09.29.37;	author espie;	state Exp;
branches;
next	1.135;

1.135
date	2007.06.14.09.11.49;	author espie;	state Exp;
branches;
next	1.134;

1.134
date	2007.06.12.09.53.36;	author espie;	state Exp;
branches;
next	1.133;

1.133
date	2007.06.06.12.32.09;	author espie;	state Exp;
branches;
next	1.132;

1.132
date	2007.06.04.18.52.02;	author espie;	state Exp;
branches;
next	1.131;

1.131
date	2007.06.04.16.13.30;	author espie;	state Exp;
branches;
next	1.130;

1.130
date	2007.06.04.15.57.09;	author espie;	state Exp;
branches;
next	1.129;

1.129
date	2007.06.04.14.57.33;	author espie;	state Exp;
branches;
next	1.128;

1.128
date	2007.06.04.14.42.19;	author espie;	state Exp;
branches;
next	1.127;

1.127
date	2007.06.04.14.40.39;	author espie;	state Exp;
branches;
next	1.126;

1.126
date	2007.06.02.12.44.37;	author espie;	state Exp;
branches;
next	1.125;

1.125
date	2007.06.01.20.39.41;	author espie;	state Exp;
branches;
next	1.124;

1.124
date	2007.05.31.13.20.27;	author espie;	state Exp;
branches;
next	1.123;

1.123
date	2007.05.31.13.11.21;	author espie;	state Exp;
branches;
next	1.122;

1.122
date	2007.05.31.11.05.41;	author espie;	state Exp;
branches;
next	1.121;

1.121
date	2007.05.31.10.00.22;	author espie;	state Exp;
branches;
next	1.120;

1.120
date	2007.05.30.12.52.07;	author espie;	state Exp;
branches;
next	1.119;

1.119
date	2007.05.30.12.29.19;	author espie;	state Exp;
branches;
next	1.118;

1.118
date	2007.05.29.13.52.07;	author espie;	state Exp;
branches;
next	1.117;

1.117
date	2007.05.29.13.00.17;	author espie;	state Exp;
branches;
next	1.116;

1.116
date	2007.05.29.12.36.53;	author espie;	state Exp;
branches;
next	1.115;

1.115
date	2007.05.29.10.56.22;	author espie;	state Exp;
branches;
next	1.114;

1.114
date	2007.05.24.10.06.35;	author espie;	state Exp;
branches;
next	1.113;

1.113
date	2007.05.22.09.39.24;	author espie;	state Exp;
branches;
next	1.112;

1.112
date	2007.05.20.17.04.25;	author espie;	state Exp;
branches;
next	1.111;

1.111
date	2007.05.18.13.22.06;	author espie;	state Exp;
branches;
next	1.110;

1.110
date	2007.05.17.15.46.27;	author espie;	state Exp;
branches;
next	1.109;

1.109
date	2007.05.14.11.02.15;	author espie;	state Exp;
branches;
next	1.108;

1.108
date	2007.05.14.10.53.31;	author espie;	state Exp;
branches;
next	1.107;

1.107
date	2007.05.14.10.43.45;	author espie;	state Exp;
branches;
next	1.106;

1.106
date	2007.05.13.10.08.11;	author espie;	state Exp;
branches;
next	1.105;

1.105
date	2007.05.12.15.19.00;	author espie;	state Exp;
branches;
next	1.104;

1.104
date	2007.05.12.14.48.45;	author espie;	state Exp;
branches;
next	1.103;

1.103
date	2007.05.07.09.09.07;	author espie;	state Exp;
branches;
next	1.102;

1.102
date	2007.05.07.09.03.44;	author espie;	state Exp;
branches;
next	1.101;

1.101
date	2007.05.02.15.27.49;	author espie;	state Exp;
branches;
next	1.100;

1.100
date	2007.05.02.15.13.04;	author espie;	state Exp;
branches;
next	1.99;

1.99
date	2007.05.02.15.05.30;	author espie;	state Exp;
branches;
next	1.98;

1.98
date	2007.05.02.10.30.56;	author espie;	state Exp;
branches;
next	1.97;

1.97
date	2007.05.01.20.01.55;	author espie;	state Exp;
branches;
next	1.96;

1.96
date	2007.05.01.19.48.30;	author espie;	state Exp;
branches;
next	1.95;

1.95
date	2007.05.01.18.46.02;	author espie;	state Exp;
branches;
next	1.94;

1.94
date	2007.05.01.18.22.20;	author espie;	state Exp;
branches;
next	1.93;

1.93
date	2007.05.01.18.09.44;	author espie;	state Exp;
branches;
next	1.92;

1.92
date	2007.05.01.18.07.00;	author espie;	state Exp;
branches;
next	1.91;

1.91
date	2007.05.01.17.54.46;	author espie;	state Exp;
branches;
next	1.90;

1.90
date	2007.04.30.08.43.19;	author espie;	state Exp;
branches;
next	1.89;

1.89
date	2007.04.29.11.28.59;	author espie;	state Exp;
branches;
next	1.88;

1.88
date	2007.04.15.10.17.29;	author espie;	state Exp;
branches;
next	1.87;

1.87
date	2007.04.15.10.01.13;	author espie;	state Exp;
branches;
next	1.86;

1.86
date	2006.12.16.12.28.15;	author espie;	state Exp;
branches;
next	1.85;

1.85
date	2006.12.02.10.48.03;	author espie;	state Exp;
branches;
next	1.84;

1.84
date	2006.11.17.15.34.15;	author espie;	state Exp;
branches;
next	1.83;

1.83
date	2006.03.19.12.01.13;	author espie;	state Exp;
branches;
next	1.82;

1.82
date	2006.03.17.20.44.01;	author espie;	state Exp;
branches;
next	1.81;

1.81
date	2006.03.05.13.08.05;	author espie;	state Exp;
branches;
next	1.80;

1.80
date	2006.02.07.11.16.57;	author espie;	state Exp;
branches;
next	1.79;

1.79
date	2005.10.19.10.41.19;	author espie;	state Exp;
branches;
next	1.78;

1.78
date	2005.09.04.22.47.56;	author espie;	state Exp;
branches;
next	1.77;

1.77
date	2005.08.14.12.01.08;	author espie;	state Exp;
branches;
next	1.76;

1.76
date	2005.06.21.19.12.31;	author espie;	state Exp;
branches;
next	1.75;

1.75
date	2004.12.16.11.07.33;	author espie;	state Exp;
branches;
next	1.74;

1.74
date	2004.12.09.18.58.25;	author espie;	state Exp;
branches;
next	1.73;

1.73
date	2004.11.21.15.36.17;	author espie;	state Exp;
branches;
next	1.72;

1.72
date	2004.11.18.21.46.07;	author espie;	state Exp;
branches;
next	1.71;

1.71
date	2004.11.13.12.01.30;	author espie;	state Exp;
branches;
next	1.70;

1.70
date	2004.11.13.11.48.46;	author espie;	state Exp;
branches;
next	1.69;

1.69
date	2004.11.13.11.39.40;	author espie;	state Exp;
branches;
next	1.68;

1.68
date	2004.11.12.23.26.41;	author espie;	state Exp;
branches;
next	1.67;

1.67
date	2004.11.12.23.00.46;	author espie;	state Exp;
branches;
next	1.66;

1.66
date	2004.11.12.22.48.31;	author espie;	state Exp;
branches;
next	1.65;

1.65
date	2004.11.12.22.39.40;	author espie;	state Exp;
branches;
next	1.64;

1.64
date	2004.11.12.19.42.01;	author espie;	state Exp;
branches;
next	1.63;

1.63
date	2004.11.11.11.23.04;	author espie;	state Exp;
branches;
next	1.62;

1.62
date	2004.11.07.11.48.42;	author espie;	state Exp;
branches;
next	1.61;

1.61
date	2004.11.06.12.19.17;	author espie;	state Exp;
branches;
next	1.60;

1.60
date	2004.10.31.11.33.51;	author espie;	state Exp;
branches;
next	1.59;

1.59
date	2004.10.23.09.43.16;	author espie;	state Exp;
branches;
next	1.58;

1.58
date	2004.10.20.11.38.57;	author espie;	state Exp;
branches;
next	1.57;

1.57
date	2004.10.18.10.51.03;	author espie;	state Exp;
branches;
next	1.56;

1.56
date	2004.10.16.11.01.29;	author espie;	state Exp;
branches;
next	1.55;

1.55
date	2004.10.13.18.39.07;	author espie;	state Exp;
branches;
next	1.54;

1.54
date	2004.10.12.21.05.20;	author espie;	state Exp;
branches;
next	1.53;

1.53
date	2004.10.11.14.40.04;	author espie;	state Exp;
branches;
next	1.52;

1.52
date	2004.10.11.14.35.08;	author espie;	state Exp;
branches;
next	1.51;

1.51
date	2004.10.11.13.46.17;	author espie;	state Exp;
branches;
next	1.50;

1.50
date	2004.10.11.13.29.05;	author espie;	state Exp;
branches;
next	1.49;

1.49
date	2004.10.11.13.10.25;	author espie;	state Exp;
branches;
next	1.48;

1.48
date	2004.10.11.10.30.34;	author espie;	state Exp;
branches;
next	1.47;

1.47
date	2004.10.05.20.37.03;	author espie;	state Exp;
branches;
next	1.46;

1.46
date	2004.10.05.20.35.09;	author espie;	state Exp;
branches;
next	1.45;

1.45
date	2004.10.05.20.22.10;	author espie;	state Exp;
branches;
next	1.44;

1.44
date	2004.10.05.20.20.59;	author espie;	state Exp;
branches;
next	1.43;

1.43
date	2004.10.05.20.04.56;	author espie;	state Exp;
branches;
next	1.42;

1.42
date	2004.10.05.19.44.15;	author espie;	state Exp;
branches;
next	1.41;

1.41
date	2004.10.05.19.35.49;	author espie;	state Exp;
branches;
next	1.40;

1.40
date	2004.10.05.18.47.15;	author espie;	state Exp;
branches;
next	1.39;

1.39
date	2004.10.05.10.21.42;	author espie;	state Exp;
branches;
next	1.38;

1.38
date	2004.10.05.10.20.40;	author espie;	state Exp;
branches;
next	1.37;

1.37
date	2004.10.05.10.12.22;	author espie;	state Exp;
branches;
next	1.36;

1.36
date	2004.10.05.10.09.34;	author espie;	state Exp;
branches;
next	1.35;

1.35
date	2004.10.05.10.06.14;	author espie;	state Exp;
branches;
next	1.34;

1.34
date	2004.10.05.10.01.17;	author espie;	state Exp;
branches;
next	1.33;

1.33
date	2004.10.04.12.30.54;	author espie;	state Exp;
branches;
next	1.32;

1.32
date	2004.10.04.12.23.58;	author espie;	state Exp;
branches;
next	1.31;

1.31
date	2004.10.04.12.16.31;	author espie;	state Exp;
branches;
next	1.30;

1.30
date	2004.10.04.12.09.07;	author espie;	state Exp;
branches;
next	1.29;

1.29
date	2004.09.21.22.17.49;	author espie;	state Exp;
branches;
next	1.28;

1.28
date	2004.09.20.10.36.39;	author espie;	state Exp;
branches;
next	1.27;

1.27
date	2004.09.20.08.53.53;	author espie;	state Exp;
branches;
next	1.26;

1.26
date	2004.09.18.13.28.19;	author espie;	state Exp;
branches;
next	1.25;

1.25
date	2004.09.18.08.14.40;	author espie;	state Exp;
branches;
next	1.24;

1.24
date	2004.09.15.17.10.09;	author espie;	state Exp;
branches;
next	1.23;

1.23
date	2004.09.14.23.04.10;	author espie;	state Exp;
branches;
next	1.22;

1.22
date	2004.08.11.09.57.50;	author espie;	state Exp;
branches;
next	1.21;

1.21
date	2004.08.10.11.53.27;	author espie;	state Exp;
branches;
next	1.20;

1.20
date	2004.08.07.17.27.26;	author espie;	state Exp;
branches;
next	1.19;

1.19
date	2004.08.06.10.23.45;	author espie;	state Exp;
branches;
next	1.18;

1.18
date	2004.08.06.07.51.17;	author espie;	state Exp;
branches;
next	1.17;

1.17
date	2004.08.05.23.36.40;	author espie;	state Exp;
branches;
next	1.16;

1.16
date	2004.08.03.12.29.45;	author espie;	state Exp;
branches;
next	1.15;

1.15
date	2004.08.02.12.12.36;	author espie;	state Exp;
branches;
next	1.14;

1.14
date	2004.08.02.12.08.25;	author espie;	state Exp;
branches;
next	1.13;

1.13
date	2004.07.22.22.23.26;	author espie;	state Exp;
branches;
next	1.12;

1.12
date	2004.07.20.18.58.41;	author espie;	state Exp;
branches;
next	1.11;

1.11
date	2004.07.14.10.44.03;	author espie;	state Exp;
branches;
next	1.10;

1.10
date	2004.07.13.00.35.39;	author espie;	state Exp;
branches;
next	1.9;

1.9
date	2004.06.21.16.33.45;	author espie;	state Exp;
branches;
next	1.8;

1.8
date	2004.03.30.08.53.35;	author espie;	state Exp;
branches;
next	1.7;

1.7
date	2004.01.28.22.12.01;	author espie;	state Exp;
branches;
next	1.6;

1.6
date	2004.01.22.21.11.43;	author espie;	state Exp;
branches;
next	1.5;

1.5
date	2003.12.26.16.44.31;	author espie;	state Exp;
branches;
next	1.4;

1.4
date	2003.11.16.11.49.15;	author espie;	state Exp;
branches;
next	1.3;

1.3
date	2003.11.06.17.46.35;	author espie;	state Exp;
branches;
next	1.2;

1.2
date	2003.10.31.17.43.20;	author espie;	state Exp;
branches;
next	1.1;

1.1
date	2003.10.16.17.43.34;	author espie;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2003.10.16.17.43.34;	author espie;	state Exp;
branches;
next	;


desc
@@


1.247
log
@recognize @@version, to be used for a system-wide version marker
@
text
@# ex:ts=8 sw=4:
# $OpenBSD: PackingElement.pm,v 1.246 2017/05/15 15:14:11 schwarze Exp $
#
# Copyright (c) 2003-2014 Marc Espie <espie@@openbsd.org>
#
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

use strict;
use warnings;

use OpenBSD::PackageInfo;
use OpenBSD::Paths;

# perl ipc
require 5.008_000;

# This is the basic class, which is mostly abstract, except for
# create and register_with_factory.
# It does provide base methods for stuff under it, though.
package OpenBSD::PackingElement;
our %keyword;

sub create
{
	my ($class, $line, $plist) = @@_;
	if ($line =~ m/^\@@(\S+)\s*(.*)$/o) {
		if (defined $keyword{$1}) {
			$keyword{$1}->add($plist, $2);
		} else {
			die "Unknown element: $line";
		}
	} else {
		chomp $line;
		OpenBSD::PackingElement::File->add($plist, $line);
	}
}

sub register_with_factory
{
	my ($class, $k, $o) = @@_;
	if (!defined $k) {
		$k = $class->keyword;
	}
	if (!defined $o) {
		$o = $class;
	}
	$keyword{$k} = $o;
}

sub category() { 'items' }

sub new
{
	my ($class, $args) = @@_;
	bless { name => $args }, $class;
}

sub remove
{
	my ($self, $plist) = @@_;
	$self->{deleted} = 1;
}

sub clone
{
	my $object = shift;
	# shallow copy
	my %h = %$object;
	bless \%h, ref($object);
}


sub register_manpage
{
}

sub destate
{
}

sub add_object
{
	my ($self, $plist) = @@_;
	$self->destate($plist->{state});
	$plist->add2list($self);
	return $self;
}

sub add
{
	my ($class, $plist, @@args) = @@_;

	my $self = $class->new(@@args);
	return $self->add_object($plist);
}

sub needs_keyword() { 1 }

sub write
{
	my ($self, $fh) = @@_;
	my $s = $self->stringize;
	if ($self->needs_keyword) {
		$s = " $s" unless $s eq '';
		print $fh "\@@", $self->keyword, "$s\n";
	} else {
		print $fh "$s\n";
	}
}

sub write_no_sig
{
	my ($self, $fh) = @@_;
	$self->write($fh);
}

sub write_without_variation
{
	my ($self, $fh) = @@_;
	$self->write_no_sig($fh);
}

# needed for comment checking
sub fullstring
{
	my ($self, $fh) = @@_;
	my $s = $self->stringize;
	if ($self->needs_keyword) {
		$s = " $s" unless $s eq '';
		return "\@@".$self->keyword.$s;
	} else {
		return $s;
	}
}

sub name
{
	my $self = shift;
	return $self->{name};
}

sub set_name
{
	my ($self, $v) = @@_;
	$self->{name} = $v;
}
sub stringize
{
	my $self = shift;
	return $self->name;
}

sub IsFile() { 0 }

sub is_a_library() { 0 }
sub NoDuplicateNames() { 0 }


sub copy_shallow_if
{
	my ($self, $copy, $h) = @@_;
	$self->add_object($copy) if defined $h->{$self};
}

sub copy_deep_if
{
	my ($self, $copy, $h) = @@_;
	$self->clone->add_object($copy) if defined $h->{$self};
}

sub finish
{
	my ($class, $state) = @@_;
	OpenBSD::PackingElement::Fontdir->finish($state);
	OpenBSD::PackingElement::RcScript->report($state);
	if ($state->{readmes}) {
		$state->say("Look in #1/share/doc/pkg-readmes for extra documentation.", $state->{localbase});
	}
}

# Basic class hierarchy

# various stuff that's only linked to objects before/after them
# this class doesn't have real objects: no valid new nor clone...
package OpenBSD::PackingElement::Annotation;
our @@ISA=qw(OpenBSD::PackingElement);
sub new { die "Can't create annotation objects" }

# concrete objects
package OpenBSD::PackingElement::Object;
our @@ISA=qw(OpenBSD::PackingElement);

sub cwd
{
	return ${$_[0]->{cwd}};
}

sub absolute_okay() { 0 }
sub compute_fullname
{
	my ($self, $state) = @@_;

	$self->{cwd} = $state->{cwd};
	$self->set_name(File::Spec->canonpath($self->name));
	if ($self->name =~ m|^/|) {
		unless ($self->absolute_okay) {
			die "Absolute name forbidden: ", $self->name;
		}
	}
}

sub make_full
{
	my ($self, $path) = @@_;
	if ($path !~ m|^/|o && $self->cwd ne '.') {
		$path = $self->cwd."/".$path;
		$path =~ s,^//,/,;
	}
	return $path;
}

sub fullname
{
	my $self = shift;
	return $self->make_full($self->name);
}

sub compute_modes
{
	my ($self, $state) = @@_;
	if (defined $state->{mode}) {
		$self->{mode} = $state->{mode};
	}
	if (defined $state->{owner}) {
		$self->{owner} = $state->{owner};
		if (defined $state->{uid}) {
			$self->{uid} = $state->{uid};
		}
	}
	if (defined $state->{group}) {
		$self->{group} = $state->{group};
		if (defined $state->{gid}) {
			$self->{gid} = $state->{gid};
		}
	}
}

# concrete objects with file-like behavior
package OpenBSD::PackingElement::FileObject;
our @@ISA=qw(OpenBSD::PackingElement::Object);

sub NoDuplicateNames() { 1 }

sub dirclass() { undef }

sub new
{
	my ($class, $args) = @@_;
	if ($args =~ m/^(.*?)\/+$/o and defined $class->dirclass) {
		bless { name => $1 }, $class->dirclass;
	} else {
		bless { name => $args }, $class;
	}
}

sub destate
{
	my ($self, $state) = @@_;
	$state->{lastfileobject} = $self;
	$self->compute_fullname($state);
}

sub set_tempname
{
	my ($self, $tempname) = @@_;
	$self->{tempname} = $tempname;
}

sub realname
{
	my ($self, $state) = @@_;

	my $name = $self->fullname;
	if (defined $self->{tempname}) {
		$name = $self->{tempname};
	}
	return $state->{destdir}.$name;
}

sub compute_digest
{
	my ($self, $filename, $class) = @@_;
	require OpenBSD::md5;
	$class = 'OpenBSD::sha' if !defined $class;
	return $class->new($filename);
}

sub write
{
	my ($self, $fh) = @@_;

	$self->SUPER::write($fh);
	if (defined $self->{tags}) {
		for my $tag (sort keys %{$self->{tags}}) {
			print $fh "\@@tag ", $tag, "\n";
		}
	}
}

# exec/unexec and friends
package OpenBSD::PackingElement::Action;
our @@ISA=qw(OpenBSD::PackingElement::Object);

# persistent state for following objects
package OpenBSD::PackingElement::State;
our @@ISA=qw(OpenBSD::PackingElement::Object);

# meta information, stored elsewhere
package OpenBSD::PackingElement::Meta;
our @@ISA=qw(OpenBSD::PackingElement);

package OpenBSD::PackingElement::Unique;
our @@ISA=qw(OpenBSD::PackingElement::Meta);

sub add_object
{
	my ($self, $plist) = @@_;

	$self->destate($plist->{state});
	$plist->addunique($self);
	return $self;
}

sub remove
{
	my ($self, $plist) = @@_;
	delete $plist->{$self->category};
}

sub category
{
	return ref(shift);
}

# all dependency information
package OpenBSD::PackingElement::Depend;
our @@ISA=qw(OpenBSD::PackingElement::Meta);

# Abstract class for all file-like elements
package OpenBSD::PackingElement::FileBase;
our @@ISA=qw(OpenBSD::PackingElement::FileObject);

use File::Basename;

sub write
{
	my ($self, $fh) = @@_;
	print $fh "\@@comment no checksum\n" if defined $self->{nochecksum};
	$self->SUPER::write($fh);
	if (defined $self->{d}) {
		$self->{d}->write($fh);
	}
	if (defined $self->{size}) {
		print $fh "\@@size ", $self->{size}, "\n";
	}
	if (defined $self->{ts}) {
		print $fh "\@@ts ", $self->{ts}, "\n";
	}
	if (defined $self->{symlink}) {
		print $fh "\@@symlink ", $self->{symlink}, "\n";
	}
	if (defined $self->{link}) {
		print $fh "\@@link ", $self->{link}, "\n";
	}
	if (defined $self->{tempname}) {
		print $fh "\@@temp ", $self->{tempname}, "\n";
	}
}

sub destate
{
	my ($self, $state) = @@_;
	$self->SUPER::destate($state);
	$state->{lastfile} = $self;
	$state->{lastchecksummable} = $self;
	$self->compute_modes($state);
	if (defined $state->{nochecksum}) {
		$self->{nochecksum} = 1;
		undef $state->{nochecksum};
	}
}

sub add_digest
{
	my ($self, $d) = @@_;
	$self->{d} = $d;
}
sub add_size
{
	my ($self, $sz) = @@_;
	$self->{size} = $sz;
}

sub add_timestamp
{
	my ($self, $ts) = @@_;
	$self->{ts} = $ts;
}

# XXX symlink/hardlinks are properties of File,
# because we want to use inheritance for other stuff.

sub make_symlink
{
	my ($self, $linkname) = @@_;
	$self->{symlink} = $linkname;
}

sub make_hardlink
{
	my ($self, $linkname) = @@_;
	$self->{link} = $linkname;
}

sub may_check_digest
{
	my ($self, $file, $state) = @@_;
	if ($state->{check_digest}) {
		$self->check_digest($file, $state);
	}
}

sub check_digest
{
	my ($self, $file, $state) = @@_;
	return if $self->{link} or $self->{symlink};
	if (!defined $self->{d}) {
		$state->log->fatal($state->f("#1 does not have a signature",
		    $self->fullname));
	}
	my $d = $self->compute_digest($file->{destdir}.$file->name);
	if (!$d->equals($self->{d})) {
		$state->log->fatal($state->f("checksum for #1 does not match",
		    $self->fullname));
	}
	if ($state->verbose >= 3) {
		$state->say("Checksum match for #1", $self->fullname);
	}
}

sub IsFile() { 1 }

package OpenBSD::PackingElement::File;
our @@ISA=qw(OpenBSD::PackingElement::FileBase);

use OpenBSD::PackageInfo qw(is_info_name);
sub keyword() { "file" }
__PACKAGE__->register_with_factory;

sub dirclass() { "OpenBSD::PackingElement::Dir" }

sub needs_keyword
{
	my $self = shift;
	return $self->stringize =~ m/\^@@/;
}

sub add_object
{
	my ($self, $plist) = @@_;

	$self->destate($plist->{state});
	my $j = is_info_name($self->fullname);
	if ($j) {
		bless $self, "OpenBSD::PackingElement::$j";
		$self->add_object($plist);
	} else {
		$plist->add2list($self);
	}
	return $self;
}

package OpenBSD::PackingElement::Sample;
our @@ISA=qw(OpenBSD::PackingElement::FileObject);

sub keyword() { "sample" }
sub absolute_okay() { 1 }
__PACKAGE__->register_with_factory;

sub destate
{
	my ($self, $state) = @@_;
	if ($state->{lastfile}->isa("OpenBSD::PackingElement::SpecialFile")) {
		die "Can't \@@sample a specialfile: ". 
		    $state->{lastfile}->stringize. "\n";
	}
	$self->{copyfrom} = $state->{lastfile};
	$self->compute_fullname($state);
	$self->compute_modes($state);
}

sub dirclass() { "OpenBSD::PackingElement::Sampledir" }

package OpenBSD::PackingElement::Ghost;
our @@ISA = qw(OpenBSD::PackingElement::FileObject);

sub keyword() { "ghost" }
sub absolute_okay() { 1 }
__PACKAGE__->register_with_factory;

sub destate
{
	my ($self, $state) = @@_;
	$self->compute_fullname($state);
	$self->compute_modes($state);
}

package OpenBSD::PackingElement::Sampledir;
our @@ISA=qw(OpenBSD::PackingElement::DirBase OpenBSD::PackingElement::Sample);

sub absolute_okay() { 1 }

sub destate
{
	my ($self, $state) = @@_;
	$self->compute_fullname($state);
	$self->compute_modes($state);
}

package OpenBSD::PackingElement::RcScript;
use File::Basename;
our @@ISA = qw(OpenBSD::PackingElement::FileBase);

sub keyword() { "rcscript" }
sub absolute_okay() { 1 }
__PACKAGE__->register_with_factory;

sub destate
{
	my ($self, $state) = @@_;
	$self->compute_fullname($state);
	if ($self->name =~ m/^\//) {
		$state->set_cwd(dirname($self->name));
	}
	$state->{lastfile} = $self;
	$state->{lastchecksummable} = $self;
	$self->compute_modes($state);
}

sub report
{
	my ($class, $state) = @@_;

	my @@l;
	for my $script (sort keys %{$state->{add_rcscripts}}) {
		next if $state->{delete_rcscripts}{$script};
		push(@@l, $script);
	}
	if (@@l > 0) {
		$state->say("The following new rcscripts were installed: #1",
		    join(' ', @@l));
		$state->say("See rcctl(8) for details.");
	}
}

package OpenBSD::PackingElement::InfoFile;
our @@ISA=qw(OpenBSD::PackingElement::FileBase);

sub keyword() { "info" }
__PACKAGE__->register_with_factory;
sub dirclass() { "OpenBSD::PackingElement::Infodir" }

package OpenBSD::PackingElement::Shell;
our @@ISA=qw(OpenBSD::PackingElement::FileBase);

sub keyword() { "shell" }
__PACKAGE__->register_with_factory;

package OpenBSD::PackingElement::Manpage;
use File::Basename;
our @@ISA=qw(OpenBSD::PackingElement::FileBase);

sub keyword() { "man" }
__PACKAGE__->register_with_factory;

sub register_manpage
{
	my ($self, $state, $key) = @@_;
	# XXX don't bother register stuff from partial packages
	return if defined $self->{tempname};
	my $fname = $self->fullname;
	if ($fname =~ m,^(.*/man(?:/\w+)?)/((?:man|cat)[1-9n]\w*/.*),) {
		push(@@{$state->{$key}{$1}}, $2);
    	}
}

sub is_source
{
	my $self = shift;
	return $self->name =~ m/man\/man[^\/]+\/[^\/]+\.[\dln][^\/]?$/o;
}

sub source_to_dest
{
	my $self = shift;
	my $v = $self->name;
	$v =~ s/(man\/)man([^\/]+\/[^\/]+)\.[\dln][^\/]?$/$1cat$2.0/;
	return $v;
}

# assumes the source is nroff, launches nroff
sub format
{
	my ($self, $state, $dest, $destfh) = @@_;

	my $base = $state->{base};
	my $fname = $base.$self->fullname;
	if (-z $fname) {
		$state->error("empty source manpage: #1", $fname);
		return;
	}
	open(my $fh, '<', $fname) or die "Can't read $fname";
	my $line = <$fh>;
	close $fh;
	my @@extra = ();
	# extra preprocessors as described in man.
	if ($line =~ m/^\'\\\"\s+(.*)$/o) {
		for my $letter (split '', $1) {
			if ($letter =~ m/[ept]/o) {
				push(@@extra, "-$letter");
			} elsif ($letter eq 'r') {
				push(@@extra, "-R");
			}
		}
	}
	my $d = dirname($dest);
	unless (-d $d) {
		mkdir($d);
	}
	if (my ($dir, $file) = $fname =~ m/^(.*)\/([^\/]+\/[^\/]+)$/) {
		$state->system(sub {
		    open STDOUT, '>&', $destfh or
			die "Can't write to $dest";
		    close $destfh;
		    chdir($dir) or die "Can't chdir to $dir";
		    },
		    OpenBSD::Paths->groff,
		    qw(-mandoc -mtty-char -E -Ww -Tascii -P -c),
		    @@extra, '--', $file);
	} else {
		die "Can't parse source name $fname";
	}
	return 1;
}

package OpenBSD::PackingElement::Mandoc;
our @@ISA=qw(OpenBSD::PackingElement::Manpage);

sub keyword() { "mandoc" }
__PACKAGE__->register_with_factory;

package OpenBSD::PackingElement::Lib;
our @@ISA=qw(OpenBSD::PackingElement::FileBase);

our $todo = 0;

sub keyword() { "lib" }
__PACKAGE__->register_with_factory;

sub mark_ldconfig_directory
{
	my ($self, $state) = @@_;
	$state->ldconfig->mark_directory($self->fullname);
}

sub parse
{
	my ($self, $filename) = @@_;
	if ($filename =~ m/^(.*?)\/?lib([^\/]+)\.so\.(\d+)\.(\d+)$/o) {
		return ($2, $3, $4, $1);
	} else {
		return undef;
	}
}

sub is_a_library() { 1 }

package OpenBSD::PackingElement::PkgConfig;
our @@ISA=qw(OpenBSD::PackingElement::FileBase);

sub keyword() { "pkgconfig" }
__PACKAGE__->register_with_factory;

package OpenBSD::PackingElement::LibtoolLib;
our @@ISA=qw(OpenBSD::PackingElement::FileBase);

sub keyword() { "ltlib" }
__PACKAGE__->register_with_factory;

package OpenBSD::PackingElement::Binary;
our @@ISA=qw(OpenBSD::PackingElement::FileBase);

sub keyword() { "bin" }
__PACKAGE__->register_with_factory;

# Comment is very special
package OpenBSD::PackingElement::Comment;
our @@ISA=qw(OpenBSD::PackingElement::Meta);

sub keyword() { "comment" }
__PACKAGE__->register_with_factory;

sub destate
{
	my ($self, $state) = @@_;
	$self->{cwd} = $state->{cwd};
}

sub add
{
	my ($class, $plist, $args) = @@_;

	if ($args =~ m/^\$OpenBSD.*\$\s*$/o) {
		return OpenBSD::PackingElement::CVSTag->add($plist, $args);
	} elsif ($args =~ m/^(?:subdir|pkgpath)\=(.*?)\s+cdrom\=(.*?)\s+ftp\=(.*?)\s*$/o) {
		return OpenBSD::PackingElement::ExtraInfo->add($plist, $1, $2, $3);
	} elsif ($args eq 'no checksum') {
		$plist->{state}->{nochecksum} = 1;
		return;
	} else {
		return $class->SUPER::add($plist, $args);
	}
}

package OpenBSD::PackingElement::CVSTag;
our @@ISA=qw(OpenBSD::PackingElement::Meta);

sub keyword() { 'comment' }

sub category() { 'cvstags'}

# don't incorporate this into compared signatures
sub write_without_variation
{
}

package OpenBSD::PackingElement::sha;
our @@ISA=qw(OpenBSD::PackingElement::Annotation);

__PACKAGE__->register_with_factory('sha');

sub add
{
	my ($class, $plist, $args) = @@_;

	require OpenBSD::md5;

	$plist->{state}->{lastchecksummable}->add_digest(OpenBSD::sha->fromstring($args));
	return;
}

package OpenBSD::PackingElement::tag;
our @@ISA=qw(OpenBSD::PackingElement::Annotation);

__PACKAGE__->register_with_factory('tag');

sub add
{
	my ($class, $plist, $args) = @@_;

	if ($args eq 'no checksum') {
		$plist->{state}{lastfile}{nochecksum} = 1;
	} else {
		my $object = $plist->{state}{lastfileobject};
		$object->{tags}{$args} = 1;
		push(@@{$plist->{tags}{$args}}, $object);
	}
	return undef;
}

package OpenBSD::PackingElement::DefineTag;
our @@ISA=qw(OpenBSD::PackingElement::Meta);

sub category() { 'define-tag' }
sub keyword() { 'define-tag' }
__PACKAGE__->register_with_factory;

sub new
{
	my ($class, $args) = @@_;
	my ($tag, $condition, @@command) = split(/\s+/, $args);
	bless {
		name => $tag,
		when => $condition,
		command => join(' ', @@command)
	}, $class;
}

sub stringize
{
	my $self = shift;
	return join(' ', map { $self->{$_}}
		(qw(name when command)));
}

package OpenBSD::PackingElement::symlink;
our @@ISA=qw(OpenBSD::PackingElement::Annotation);

__PACKAGE__->register_with_factory('symlink');

sub add
{
	my ($class, $plist, $args) = @@_;

	$plist->{state}->{lastfile}->make_symlink($args);
	return;
}

package OpenBSD::PackingElement::hardlink;
our @@ISA=qw(OpenBSD::PackingElement::Annotation);

__PACKAGE__->register_with_factory('link');

sub add
{
	my ($class, $plist, $args) = @@_;

	$plist->{state}->{lastfile}->make_hardlink($args);
	return;
}

package OpenBSD::PackingElement::temp;
our @@ISA=qw(OpenBSD::PackingElement::Annotation);

__PACKAGE__->register_with_factory('temp');

sub add
{
	my ($class, $plist, $args) = @@_;
	$plist->{state}->{lastfile}->set_tempname($args);
	return;
}

package OpenBSD::PackingElement::size;
our @@ISA=qw(OpenBSD::PackingElement::Annotation);

__PACKAGE__->register_with_factory('size');

sub add
{
	my ($class, $plist, $args) = @@_;

	$plist->{state}->{lastfile}->add_size($args);
	return;
}

package OpenBSD::PackingElement::ts;
our @@ISA=qw(OpenBSD::PackingElement::Annotation);

__PACKAGE__->register_with_factory('ts');

sub add
{
	my ($class, $plist, $args) = @@_;

	$plist->{state}->{lastfile}->add_timestamp($args);
	return;
}

package OpenBSD::PackingElement::Option;
our @@ISA=qw(OpenBSD::PackingElement::Meta);

sub keyword() { 'option' }
__PACKAGE__->register_with_factory;

sub new
{
	my ($class, $args) = @@_;
	if ($args eq 'no-default-conflict') {
		return OpenBSD::PackingElement::NoDefaultConflict->new;
	} elsif ($args eq 'manual-installation') {
		return OpenBSD::PackingElement::ManualInstallation->new;
	} elsif ($args eq 'firmware') {
		return OpenBSD::PackingElement::Firmware->new;
	} elsif ($args eq 'always-update') {
		return OpenBSD::PackingElement::AlwaysUpdate->new;
	} elsif ($args eq 'is-branch') {
		return OpenBSD::PackingElement::IsBranch->new;
	} else {
		die "Unknown option: $args";
	}
}

package OpenBSD::PackingElement::UniqueOption;
our @@ISA=qw(OpenBSD::PackingElement::Unique OpenBSD::PackingElement::Option);

sub stringize
{
	my $self = shift;
	return $self->category;
}

sub new
{
	my ($class, @@args) = @@_;
	bless {}, $class;
}

package OpenBSD::PackingElement::NoDefaultConflict;
our @@ISA=qw(OpenBSD::PackingElement::UniqueOption);

sub category() { 'no-default-conflict' }

package OpenBSD::PackingElement::ManualInstallation;
our @@ISA=qw(OpenBSD::PackingElement::UniqueOption);

sub category() { 'manual-installation' }

# XXX don't incorporate this in signatures.
sub write_no_sig()
{
}

package OpenBSD::PackingElement::Firmware;
our @@ISA=qw(OpenBSD::PackingElement::ManualInstallation);
sub category() { 'firmware' }

package OpenBSD::PackingElement::AlwaysUpdate;
our @@ISA=qw(OpenBSD::PackingElement::UniqueOption);

sub category()
{
	'always-update';
}

package OpenBSD::PackingElement::IsBranch;
our @@ISA=qw(OpenBSD::PackingElement::UniqueOption);

sub category()
{
	'is-branch';
}
# The special elements that don't end in the right place
package OpenBSD::PackingElement::ExtraInfo;
our @@ISA=qw(OpenBSD::PackingElement::Unique OpenBSD::PackingElement::Comment);

sub category() { 'extrainfo' }

sub new
{
	my ($class, $subdir, $cdrom, $ftp) = @@_;

	$cdrom =~ s/^\"(.*)\"$/$1/;
	$cdrom =~ s/^\'(.*)\'$/$1/;
	$ftp =~ s/^\"(.*)\"$/$1/;
	$ftp =~ s/^\'(.*)\'$/$1/;
	bless { subdir => $subdir,
		path => OpenBSD::PkgPath->new($subdir),
	    cdrom => $cdrom,
	    ftp => $ftp}, $class;
}

sub subdir
{
	return shift->{subdir};
}

sub may_quote
{
	my $s = shift;
	if ($s =~ m/\s/) {
		return '"'.$s.'"';
	} else {
		return $s;
	}
}

sub stringize
{
	my $self = shift;
	return join(' ',
	    "pkgpath=".$self->{subdir},
	    "cdrom=".may_quote($self->{cdrom}),
	    "ftp=".may_quote($self->{ftp}));
}

package OpenBSD::PackingElement::Name;
use File::Spec;
our @@ISA=qw(OpenBSD::PackingElement::Unique);

sub keyword() { "name" }
__PACKAGE__->register_with_factory;
sub category() { "name" }

package OpenBSD::PackingElement::LocalBase;
our @@ISA=qw(OpenBSD::PackingElement::Unique);

sub keyword() { "localbase" }
__PACKAGE__->register_with_factory;
sub category() { "localbase" }

package OpenBSD::PackingElement::Url;
our @@ISA=qw(OpenBSD::PackingElement::Unique);

sub keyword() { "url" }
__PACKAGE__->register_with_factory;
sub category() { "url" }

# XXX don't incorporate this in signatures.
sub write_no_sig()
{
}

package OpenBSD::PackingElement::Version;
our @@ISA=qw(OpenBSD::PackingElement::Unique);

sub keyword() { "version" }
__PACKAGE__->register_with_factory;
sub category() { "version" }

package OpenBSD::PackingElement::Conflict;
our @@ISA=qw(OpenBSD::PackingElement::Meta);

sub keyword() { "conflict" }
__PACKAGE__->register_with_factory;
sub category() { "conflict" }

sub spec
{
	my $self =shift;

	require OpenBSD::Search;
	return OpenBSD::Search::PkgSpec->new($self->name);
}

package OpenBSD::PackingElement::Dependency;
our @@ISA=qw(OpenBSD::PackingElement::Depend);
use OpenBSD::Error;

sub keyword() { "depend" }
__PACKAGE__->register_with_factory;
sub category() { "depend" }

sub new
{
	my ($class, $args) = @@_;
	my ($pkgpath, $pattern, $def) = split /\:/o, $args;
	bless { name => $def, pkgpath => $pkgpath, pattern => $pattern,
	    def => $def }, $class;
}

sub stringize
{
	my $self = shift;
	return join(':', map { $self->{$_}}
	    (qw(pkgpath pattern def)));
}

OpenBSD::Auto::cache(spec,
    sub {
	require OpenBSD::Search;

	my $self = shift;
	return OpenBSD::Search::PkgSpec->new($self->{pattern})
	    ->add_pkgpath_hint($self->{pkgpath});
    });

package OpenBSD::PackingElement::Wantlib;
our @@ISA=qw(OpenBSD::PackingElement::Depend);

sub category() { "wantlib" }
sub keyword() { "wantlib" }
__PACKAGE__->register_with_factory;

OpenBSD::Auto::cache(spec,
    sub {
    	my $self = shift;

    	require OpenBSD::LibSpec;
	return OpenBSD::LibSpec->from_string($self->name);
    });
package OpenBSD::PackingElement::PkgPath;
our @@ISA=qw(OpenBSD::PackingElement::Meta);

sub keyword() { "pkgpath" }
__PACKAGE__->register_with_factory;
sub category() { "pkgpath" }

sub new
{
	my ($class, $fullpkgpath) = @@_;
	bless {name => $fullpkgpath,
	    path => OpenBSD::PkgPath::WithOpts->new($fullpkgpath)}, $class;
}

sub subdir
{
	return shift->{name};
}

package OpenBSD::PackingElement::AskUpdate;
our @@ISA=qw(OpenBSD::PackingElement::Meta);

sub new
{
	my ($class, $args) = @@_;
	my ($pattern, $message) = split /\s+/o, $args, 2;
	bless { pattern => $pattern, message => $message}, $class;
}

sub stringize
{
	my $self = shift;
	return join(' ', map { $self->{$_}}
	    (qw(pattern message)));
}

sub keyword() { "ask-update" }
__PACKAGE__->register_with_factory;
sub category() { "ask-update" }

OpenBSD::Auto::cache(spec,
    sub {
	require OpenBSD::PkgSpec;

	my $self = shift;
	return OpenBSD::PkgSpec->new($self->{pattern})
    });

package OpenBSD::PackingElement::NewAuth;
our @@ISA=qw(OpenBSD::PackingElement::Action);

package OpenBSD::PackingElement::NewUser;
our @@ISA=qw(OpenBSD::PackingElement::NewAuth);

sub type() { "user" }
sub category() { "users" }
sub keyword() { "newuser" }
__PACKAGE__->register_with_factory;

sub new
{
	my ($class, $args) = @@_;
	my ($name, $uid, $group, $loginclass, $comment, $home, $shell) =
	    split /\:/o, $args;
	bless { name => $name, uid => $uid, group => $group,
	    class => $loginclass,
	    comment => $comment, home => $home, shell => $shell }, $class;
}

sub destate
{
	my ($self, $state) = @@_;
	my $uid = $self->{uid};
	$uid =~ s/^\!//;
	$state->{owners}{$self->{name}} = $uid;
}

sub check
{
	my $self = shift;
	my ($name, $passwd, $uid, $gid, $quota, $class, $gcos, $dir, $shell,
	    $expire) = getpwnam($self->name);
	return unless defined $name;
	if ($self->{uid} =~ m/^\!(.*)$/o) {
		return 0 unless $uid == $1;
	}
	if ($self->{group} =~ m/^\!(.*)$/o) {
		my $g = $1;
		unless ($g =~ m/^\d+$/o) {
			$g = getgrnam($g);
			return 0 unless defined $g;
		}
		return 0 unless $gid eq $g;
	}
	if ($self->{class} =~ m/^\!(.*)$/o) {
		return 0 unless $class eq $1;
	}
	if ($self->{comment} =~ m/^\!(.*)$/o) {
		return 0 unless $gcos eq $1;
	}
	if ($self->{home} =~ m/^\!(.*)$/o) {
		return 0 unless $dir eq $1;
	}
	if ($self->{shell} =~ m/^\!(.*)$/o) {
		return 0 unless $shell eq $1;
	}
	return 1;
}

sub stringize
{
	my $self = shift;
	return join(':', map { $self->{$_}}
	    (qw(name uid group class comment home shell)));
}

package OpenBSD::PackingElement::NewGroup;
our @@ISA=qw(OpenBSD::PackingElement::NewAuth);


sub type() { "group" }
sub category() { "groups" }
sub keyword() { "newgroup" }
__PACKAGE__->register_with_factory;

sub new
{
	my ($class, $args) = @@_;
	my ($name, $gid) = split /\:/o, $args;
	bless { name => $name, gid => $gid }, $class;
}

sub destate
{
	my ($self, $state) = @@_;
	my $gid = $self->{gid};
	$gid =~ s/^\!//;
	$state->{groups}{$self->{name}} = $gid;
}

sub check
{
	my $self = shift;
	my ($name, $passwd, $gid, $members) = getgrnam($self->name);
	return unless defined $name;
	if ($self->{gid} =~ m/^\!(.*)$/o) {
		return 0 unless $gid == $1;
	}
	return 1;
}

sub stringize($)
{
	my $self = $_[0];
	return join(':', map { $self->{$_}}
	    (qw(name gid)));
}

package OpenBSD::PackingElement::Cwd;
use File::Spec;
our @@ISA=qw(OpenBSD::PackingElement::State);


sub keyword() { 'cwd' }
__PACKAGE__->register_with_factory;

sub destate
{
	my ($self, $state) = @@_;
	$state->set_cwd($self->name);
}

package OpenBSD::PackingElement::Owner;
our @@ISA=qw(OpenBSD::PackingElement::State);

sub keyword() { 'owner' }
__PACKAGE__->register_with_factory;

sub destate
{
	my ($self, $state) = @@_;

	delete $state->{uid};
	if ($self->name eq '') {
		undef $state->{owner};
	} else {
		$state->{owner} = $self->name;
		if (defined $state->{owners}{$self->name}) {
			$state->{uid} = $state->{owners}{$self->name};
		}
	}
}

package OpenBSD::PackingElement::Group;
our @@ISA=qw(OpenBSD::PackingElement::State);

sub keyword() { 'group' }
__PACKAGE__->register_with_factory;

sub destate
{
	my ($self, $state) = @@_;

	delete $state->{gid};
	if ($self->name eq '') {
		undef $state->{group};
	} else {
		$state->{group} = $self->name;
		if (defined $state->{groups}{$self->name}) {
			$state->{gid} = $state->{groups}{$self->name};
		}
	}
}

package OpenBSD::PackingElement::Mode;
our @@ISA=qw(OpenBSD::PackingElement::State);

sub keyword() { 'mode' }
__PACKAGE__->register_with_factory;

sub destate
{
	my ($self, $state) = @@_;

	if ($self->name eq '') {
		undef $state->{mode};
	} else {
		$state->{mode} = $self->name;
	}
}

package OpenBSD::PackingElement::ExeclikeAction;
use File::Basename;
use OpenBSD::Error;
our @@ISA=qw(OpenBSD::PackingElement::Action);

sub expand
{
	my ($self, $state) = @@_;
	my $e = $self->name;
	if ($e =~ m/\%F/o) {
		die "Bad expand" unless defined $state->{lastfile};
		$e =~ s/\%F/$state->{lastfile}->{name}/g;
	}
	if ($e =~ m/\%D/o) {
		die "Bad expand" unless defined $state->{cwd};
		$e =~ s/\%D/$state->cwd/ge;
	}
	if ($e =~ m/\%B/o) {
		die "Bad expand" unless defined $state->{lastfile};
		$e =~ s/\%B/dirname($state->{lastfile}->fullname)/ge;
	}
	if ($e =~ m/\%f/o) {
		die "Bad expand" unless defined $state->{lastfile};
		$e =~ s/\%f/basename($state->{lastfile}->fullname)/ge;
	}
	return $e;
}

sub destate
{
	my ($self, $state) = @@_;
	$self->{expanded} = $self->expand($state);
}

sub run
{
	my ($self, $state) = @@_;

	$state->ldconfig->ensure;
	$state->say("#1 #2", $self->keyword, $self->{expanded})
	    if $state->verbose >= 2;
	$state->log->system(OpenBSD::Paths->sh, '-c', $self->{expanded})
	    unless $state->{not};
}

package OpenBSD::PackingElement::Exec;
our @@ISA=qw(OpenBSD::PackingElement::ExeclikeAction);

sub keyword() { "exec" }
__PACKAGE__->register_with_factory;

package OpenBSD::PackingElement::ExecAlways;
our @@ISA=qw(OpenBSD::PackingElement::Exec);

sub keyword() { "exec-always" }
__PACKAGE__->register_with_factory;

package OpenBSD::PackingElement::ExecAdd;
our @@ISA=qw(OpenBSD::PackingElement::Exec);

sub keyword() { "exec-add" }
__PACKAGE__->register_with_factory;

package OpenBSD::PackingElement::ExecUpdate;
our @@ISA=qw(OpenBSD::PackingElement::Exec);

sub keyword() { "exec-update" }
__PACKAGE__->register_with_factory;

package OpenBSD::PackingElement::Unexec;
our @@ISA=qw(OpenBSD::PackingElement::ExeclikeAction);

sub keyword() { "unexec" }
__PACKAGE__->register_with_factory;

package OpenBSD::PackingElement::UnexecAlways;
our @@ISA=qw(OpenBSD::PackingElement::Unexec);

sub keyword() { "unexec-always" }
__PACKAGE__->register_with_factory;

package OpenBSD::PackingElement::UnexecUpdate;
our @@ISA=qw(OpenBSD::PackingElement::Unexec);

sub keyword() { "unexec-update" }
__PACKAGE__->register_with_factory;

package OpenBSD::PackingElement::UnexecDelete;
our @@ISA=qw(OpenBSD::PackingElement::Unexec);

sub keyword() { "unexec-delete" }
__PACKAGE__->register_with_factory;

package OpenBSD::PackingElement::ExtraUnexec;
our @@ISA=qw(OpenBSD::PackingElement::ExeclikeAction);

sub keyword() { "extraunexec" }
__PACKAGE__->register_with_factory;

package OpenBSD::PackingElement::DirlikeObject;
our @@ISA=qw(OpenBSD::PackingElement::FileObject);

package OpenBSD::PackingElement::DirBase;
our @@ISA=qw(OpenBSD::PackingElement::DirlikeObject);

sub destate
{
	my ($self, $state) = @@_;
	$state->{lastdir} = $self;
	$self->SUPER::destate($state);
}


sub stringize
{
	my $self = shift;
	return $self->name."/";
}

sub write
{
	my ($self, $fh) = @@_;
	$self->SUPER::write($fh);
}

package OpenBSD::PackingElement::Dir;
our @@ISA=qw(OpenBSD::PackingElement::DirBase);

sub keyword() { "dir" }
__PACKAGE__->register_with_factory;

sub destate
{
	my ($self, $state) = @@_;
	$self->SUPER::destate($state);
	$self->compute_modes($state);
}

sub needs_keyword
{
	my $self = shift;
	return $self->stringize =~ m/\^@@/o;
}

package OpenBSD::PackingElement::Infodir;
our @@ISA=qw(OpenBSD::PackingElement::Dir);
sub keyword() { "info" }
sub needs_keyword() { 1 }

package OpenBSD::PackingElement::Fontdir;
our @@ISA=qw(OpenBSD::PackingElement::Dir);
sub keyword() { "fontdir" }
__PACKAGE__->register_with_factory;
sub needs_keyword() { 1 }
sub dirclass() { "OpenBSD::PackingElement::Fontdir" }

sub install
{
	my ($self, $state) = @@_;
	$self->SUPER::install($state);
	$state->log("You may wish to update your font path for #1", $self->fullname);
	$state->{recorder}{fonts_todo}{$state->{destdir}.$self->fullname} = 1;
}

sub reload
{
	my ($self, $state) = @@_;
	$state->{recorder}{fonts_todo}{$state->{destdir}.$self->fullname} = 1;
}

sub update_fontalias
{
	my $dirname = shift;
	my @@aliases;

	if (-d "$dirname") {
		for my $alias (glob "$dirname/fonts.alias-*") {
			open my $f ,'<', $alias or next;
			push(@@aliases, <$f>);
			close $f;
		}
		open my $f, '>', "$dirname/fonts.alias";
		print $f @@aliases;
		close $f;
	}
}

sub restore_fontdir
{
	my ($dirname, $state) = @@_;
	if (-f "$dirname/fonts.dir.dist") {

		unlink("$dirname/fonts.dir");
		$state->copy_file("$dirname/fonts.dir.dist",
		    "$dirname/fonts.dir");
	}
}

sub run_if_exists
{
	my ($state, $cmd, @@l) = @@_;

	if (-x $cmd) {
		$state->vsystem($cmd, @@l);
	} else {
		$state->errsay("#1 not found", $cmd);
	}
}

sub finish
{
	my ($class, $state) = @@_;
	my @@l = keys %{$state->{recorder}->{fonts_todo}};

	if (@@l != 0) {
		require OpenBSD::Error;

		return if $state->{not};
		map { update_fontalias($_) } @@l;
		if (-d "@@l") {
			run_if_exists($state, OpenBSD::Paths->mkfontscale, '--', @@l);
			run_if_exists($state, OpenBSD::Paths->mkfontdir, '--', @@l);
			map { restore_fontdir($_, $state) } @@l;
		}

		run_if_exists($state, OpenBSD::Paths->fc_cache, '--', @@l);
	}
}


package OpenBSD::PackingElement::Mandir;
our @@ISA=qw(OpenBSD::PackingElement::Dir);

sub keyword() { "mandir" }
__PACKAGE__->register_with_factory;
sub needs_keyword() { 1 }
sub dirclass() { "OpenBSD::PackingElement::Mandir" }

package OpenBSD::PackingElement::Extra;
our @@ISA=qw(OpenBSD::PackingElement::FileObject);

sub keyword() { 'extra' }
sub absolute_okay() { 1 }
__PACKAGE__->register_with_factory;

sub destate
{
	my ($self, $state) = @@_;
	$self->compute_fullname($state);
}

sub dirclass() { "OpenBSD::PackingElement::Extradir" }

package OpenBSD::PackingElement::Extradir;
our @@ISA=qw(OpenBSD::PackingElement::DirBase OpenBSD::PackingElement::Extra);
sub absolute_okay() { 1 }

sub destate
{
	&OpenBSD::PackingElement::Extra::destate;
}

package OpenBSD::PackingElement::SpecialFile;
our @@ISA=qw(OpenBSD::PackingElement::Unique);

sub add_digest
{
	&OpenBSD::PackingElement::FileBase::add_digest;
}

sub add_size
{
	&OpenBSD::PackingElement::FileBase::add_size;
}

sub add_timestamp
{
	# just don't
}

sub compute_digest
{
	&OpenBSD::PackingElement::FileObject::compute_digest;
}

sub write
{
	&OpenBSD::PackingElement::FileBase::write;
}

sub needs_keyword { 0 }

sub add_object
{
	my ($self, $plist) = @@_;
	$self->{infodir} = $plist->{infodir};
	$self->SUPER::add_object($plist);
}

sub infodir
{
	my $self = shift;
	return ${$self->{infodir}};
}

sub stringize
{
	my $self = shift;
	return $self->category;
}

sub fullname
{
	my $self = shift;
	my $d = $self->infodir;
	if (defined $d) {
		return $d.$self->name;
	} else {
		return undef;
	}
}

sub category
{
	my $self = shift;

	return $self->name;
}

sub new
{
	&OpenBSD::PackingElement::UniqueOption::new;
}

sub may_verify_digest
{
	my ($self, $state) = @@_;
	if (!$state->{check_digest}) {
		return;
	}
	if (!defined $self->{d}) {
		$state->log->fatal($state->f("#1 does not have a signature",
		    $self->fullname));
	}
	my $d = $self->compute_digest($self->fullname);
	if (!$d->equals($self->{d})) {
		$state->log->fatal($state->f("checksum for #1 does not match",
		    $self->fullname));
	}
	if ($state->verbose >= 3) {
		$state->say("Checksum match for #1", $self->fullname);
	}
}

package OpenBSD::PackingElement::FCONTENTS;
our @@ISA=qw(OpenBSD::PackingElement::SpecialFile);
sub name() { OpenBSD::PackageInfo::CONTENTS }
# XXX we don't write `self'
sub write
{}

sub copy_shallow_if
{
}

sub copy_deep_if
{
}

# CONTENTS doesn't have a checksum
sub may_verify_digest
{
}

package OpenBSD::PackingElement::FDESC;
our @@ISA=qw(OpenBSD::PackingElement::SpecialFile);
sub name() { OpenBSD::PackageInfo::DESC }

package OpenBSD::PackingElement::DisplayFile;
our @@ISA=qw(OpenBSD::PackingElement::SpecialFile);
use OpenBSD::Error;

sub prepare
{
	my ($self, $state) = @@_;
	my $fname = $self->fullname;
	if (open(my $src, '<', $fname)) {
		while (<$src>) {
			chomp;
			next if m/^\+\-+\s*$/o;
			s/^[+-] //o;
			$state->log("#1", $_);
		}
	} else {
		$state->errsay("Can't open #1: #2", $fname, $!);
    	}
}

package OpenBSD::PackingElement::FDISPLAY;
our @@ISA=qw(OpenBSD::PackingElement::DisplayFile);
sub name() { OpenBSD::PackageInfo::DISPLAY }

package OpenBSD::PackingElement::FUNDISPLAY;
our @@ISA=qw(OpenBSD::PackingElement::DisplayFile);
sub name() { OpenBSD::PackageInfo::UNDISPLAY }

package OpenBSD::PackingElement::Arch;
our @@ISA=qw(OpenBSD::PackingElement::Unique);

sub category() { 'arch' }
sub keyword() { 'arch' }
__PACKAGE__->register_with_factory;

sub new
{
	my ($class, $args) = @@_;
	my @@arches= split(/\,/o, $args);
	bless { arches => \@@arches }, $class;
}

sub stringize($)
{
	my $self = $_[0];
	return join(',', @@{$self->{arches}});
}

sub check
{
	my ($self, $forced_arch) = @@_;

	for my $ok (@@{$self->{arches}}) {
		return 1 if $ok eq '*';
		if (defined $forced_arch) {
			if ($ok eq $forced_arch) {
				return 1;
			} else {
				next;
			}
		}
		return 1 if $ok eq OpenBSD::Paths->machine_architecture;
		return 1 if $ok eq OpenBSD::Paths->architecture;
	}
	return;
}

package OpenBSD::PackingElement::Signer;
our @@ISA=qw(OpenBSD::PackingElement::Unique);
sub keyword() { 'signer' }
__PACKAGE__->register_with_factory;
sub category() { "signer" }
sub new
{
	my ($class, $args) = @@_;
	unless ($args =~ m/^[\w\d\.\-\+\@@]+$/) {
		die "Invalid characters in signer $args\n";
	}
	$class->SUPER::new($args);
}

# don't incorporate this into compared signatures
sub write_without_variation
{
}

# XXX digital-signatures have to be unique, since they are a part
# of the unsigned packing-list, with only the b64sig part removed
# (likewise for signer)
package OpenBSD::PackingElement::DigitalSignature;
our @@ISA=qw(OpenBSD::PackingElement::Unique);

sub keyword() { 'digital-signature' }
__PACKAGE__->register_with_factory;
sub category() { "digital-signature" }

# parse to and from a subset of iso8601
#
# allows us to represent timestamps in a human readable format without
# any ambiguity
sub time_to_iso8601
{
	my $time = shift;
	my ($sec, $min, $hour, $day, $month, $year, @@rest) = gmtime($time);
	return sprintf("%04d-%02d-%02dT%02d:%02d:%02dZ",
	    $year+1900, $month+1, $day, $hour, $min, $sec);
}

sub iso8601
{
	my $self = shift;
	return time_to_iso8601($self->{timestamp});
}

sub iso8601_to_time
{
	if ($_[0] =~ m/^(\d{4})\-(\d{2})\-(\d{2})T(\d{2})\:(\d{2})\:(\d{2})Z$/) {
		my ($year, $month, $day, $hour, $min, $sec) =
			($1 - 1900, $2-1, $3, $4, $5, $6);
		require POSIX;
		my $oldtz = $ENV{TZ};
		$ENV{TZ} = 'UTC';
		my $t = POSIX::mktime($sec, $min, $hour, $day, $month, $year);
		if (defined $oldtz) {
			$ENV{TZ} = $oldtz;
		} else {
			delete $ENV{TZ};
		}
		return $t;
	} else {
		die "Incorrect ISO8601 timestamp: $_[0]";
	}
}

sub new
{
	my ($class, $args) = @@_;
	my ($key, $tsbase, $tsmin, $tssec, $signature) = split(/\:/, $args);
	my $timestamp = iso8601_to_time("$tsbase:$tsmin:$tssec");
	bless { key => $key, timestamp => $timestamp, b64sig => $signature },
		$class;
}

sub blank
{
	my ($class, $type) = @@_;
	bless { key => $type, timestamp => time, b64sig => '' }, $class;
}

sub stringize
{
	my $self = shift;
	return join(':', $self->{key}, time_to_iso8601($self->{timestamp}),
	    $self->{b64sig});
}

sub write_no_sig
{
	my ($self, $fh) = @@_;
	print $fh "\@@", $self->keyword, " ", $self->{key}, ":",
	    time_to_iso8601($self->{timestamp}), "\n";
}

# don't incorporate this into compared signatures
sub write_without_variation
{
}

package OpenBSD::PackingElement::Old;
our @@ISA=qw(OpenBSD::PackingElement);

my $warned;

sub new
{
	my ($class, $k, $args) = @@_;
	bless { keyword => $k, name => $args }, $class;
}

sub add
{
	my ($o, $plist, $args) = @@_;
	my $keyword = $$o;
	if (!$warned->{$keyword}) {
		print STDERR "Warning: obsolete construct: \@@$keyword $args\n";
		$warned->{$keyword} = 1;
	}
	my $o2 = OpenBSD::PackingElement::Old->new($keyword, $args);
	$o2->add_object($plist);
	$plist->{deprecated} = 1;
	return undef;
}

sub keyword
{
	my $self = shift;
	return $self->{keyword};
}

sub register_old_keyword
{
	my ($class, $k) = @@_;
	$class->register_with_factory($k, bless \$k, $class);
}

for my $k (qw(src display mtree ignore_inst dirrm pkgcfl pkgdep newdepend
    libdepend endfake ignore vendor incompatibility md5 sysctl)) {
	__PACKAGE__->register_old_keyword($k);
}

# Real pkgpath objects, with matching properties
package OpenBSD::PkgPath;
sub new
{
	my ($class, $fullpkgpath) = @@_;
	my ($dir, @@mandatory) = split(/\,/, $fullpkgpath);
	return bless {dir => $dir,
		mandatory => {map {($_, 1)} @@mandatory},
	}, $class;
}

sub fullpkgpath
{
	my ($self) = @@_;
	if(%{$self->{mandatory}}) {
		my $m = join(",", keys %{$self->{mandatory}});
		return "$self->{dir},$m";
	} else {
		return $self->{dir};
	}
}

# a pkgpath has a dir, and some flavors/multi parts. To match, we must
# remove them all. So, keep a full hash of everything we have (has), and
# when stuff $to_rm matches, remove them from $from.
# We match when we're left with nothing.
sub trim
{
	my ($self, $has, $from, $to_rm) = @@_;
	for my $f (keys %$to_rm) {
		if ($has->{$f}) {
			delete $from->{$f};
		} else {
			return 0;
		}
	}
	return 1;
}

# basic match: after mandatory, nothing left
sub match2
{
	my ($self, $has, $h) = @@_;
	if (keys %$h) {
		return 0;
	} else {
		return 1;
	}
}

# zap mandatory, check that what's left is okay.
sub match
{
	my ($self, $other) = @@_;
	# make a copy of options
	my %h = %{$other->{mandatory}};
	if (!$self->trim($other->{mandatory}, \%h, $self->{mandatory})) {
		return 0;
	}
	if ($self->match2($other->{mandatory}, \%h)) {
		return 1;
	} else {
		return 0;
	}
}

package OpenBSD::PkgPath::WithOpts;
our @@ISA = qw(OpenBSD::PkgPath);

sub new
{
	my ($class, $fullpkgpath) = @@_;
	my @@opts = ();
	while ($fullpkgpath =~ s/\[\,(.*?)\]//) {
		push(@@opts, {map {($_, 1)} split(/\,/, $1) });
	};
	my $o = $class->SUPER::new($fullpkgpath);
	if (@@opts == 0) {
		bless $o, "OpenBSD::PkgPath";
	} else {
		$o->{opts} = \@@opts;
	}
	return $o;
}

# match with options: systematically trim any optional part that  fully
# matches, until we're left with nothing, or some options keep happening.
sub match2
{
	my ($self, $has, $h) = @@_;
	if (!keys %$h) {
		return 1;
	}
	for my $opts (@@{$self->{opts}}) {
		my %h2 = %$h;
		if ($self->trim($has, \%h2, $opts)) {
			$h = \%h2;
			if (!keys %$h) {
				return 1;
			}
		}
	}
	return 0;
}

1;
@


1.246
log
@Properly register manual pages in non-English language directories.
Before this, pkg_add(1) neglected running makewhatis(8) in directories
like /usr/local/man/ru/.
OK espie@@
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.245 2017/03/03 14:06:32 espie Exp $
d1023 7
@


1.245
log
@pass @@sysctl into old stuff
okay sthen@@
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.244 2016/06/25 18:02:59 espie Exp $
d602 1
a602 1
	if ($fname =~ m,^(.*/man)/((?:man|cat).*),) {
@


1.244
log
@recognize @@option is-branch
so that it trickles to snapshots and then can be used in ports
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.243 2016/02/03 18:30:15 robert Exp $
a1315 23
package OpenBSD::PackingElement::Sysctl;
our @@ISA=qw(OpenBSD::PackingElement::Action);

sub keyword() { 'sysctl' }
__PACKAGE__->register_with_factory;

sub new

{
	my ($class, $args) = @@_;
	if ($args =~ m/^\s*(.*)\s*(\=|\>=)\s*(.*)\s*$/o) {
		bless { name => $1, mode => $2, value => $3}, $class;
	} else {
		die "Bad syntax for \@@sysctl";
	}
}

sub stringize
{
	my $self = shift;
	return $self->{name}.$self->{mode}.$self->{value};
}

d1900 1
a1900 1
    libdepend endfake ignore vendor incompatibility md5)) {
@


1.243
log
@update the font cache by running fc-cache after removing packages
with @@fontdir markers

ok espie@@
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.242 2015/04/20 13:10:54 espie Exp $
d897 2
d946 7
@


1.242
log
@totally forgot about the !uid notation in newuser when adding the early
cache for pkg_create. Reminded by sthen@@
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.241 2015/04/16 13:29:16 espie Exp $
a1485 2
our %fonts_todo = ();

d1490 2
a1491 1
	$fonts_todo{$state->{destdir}.$self->fullname} = 1;
d1497 1
a1497 1
	$fonts_todo{$state->{destdir}.$self->fullname} = 1;
d1505 8
a1512 3
	for my $alias (glob "$dirname/fonts.alias-*") {
		open my $f ,'<', $alias or next;
		push(@@aliases, <$f>);
a1514 3
	open my $f, '>', "$dirname/fonts.alias";
	print $f @@aliases;
	close $f;
d1542 2
a1543 1
	my @@l = keys %fonts_todo;
a1546 3
		map { update_fontalias($_) } @@l unless $state->{not};
		$state->say("You may wish to update your font path for #1",
		    join(' ', @@l));
d1548 6
a1553 4
		run_if_exists($state, OpenBSD::Paths->mkfontscale, '--', @@l);
		run_if_exists($state, OpenBSD::Paths->mkfontdir, '--', @@l);

		map { restore_fontdir($_, $state) } @@l;
@


1.241
log
@reorg code, the arch/osversion code should live in a single place,
short and sweet
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.240 2015/04/16 09:32:23 espie Exp $
d1148 3
a1150 1
	$state->{owners}{$self->{name}} = $self->{uid};
d1211 3
a1213 1
	$state->{groups}{$self->{name}} = $self->{gid};
@


1.240
log
@commit expanded tags for %c, %v, %a
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.239 2015/02/25 16:37:15 sthen Exp $
a1750 11
my ($machine_arch, $arch);

sub arch
{
		if (!defined $arch) {
			my $cmd = OpenBSD::Paths->uname." -m";
			chomp($arch = `$cmd`);
		}
		return $arch;
}

d1764 2
a1765 6
		if (!defined $machine_arch) {
			my $cmd = OpenBSD::Paths->arch." -s";
			chomp($machine_arch = `$cmd`);
		}
		return 1 if $ok eq $machine_arch;
		return 1 if $ok eq arch();
@


1.239
log
@Point people at rcctl(8) rather than rc.d(8) in the text displayed when
a package has installed an rcscript - it's a good UI, and people needing
further details can follow the "see also". ok espie@@ brynet@@
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.238 2014/12/23 08:46:31 espie Exp $
d1753 9
d1780 1
a1780 5
		if (!defined $arch) {
			my $cmd = OpenBSD::Paths->uname." -m";
			chomp($arch = `$cmd`);
		}
		return 1 if $ok eq $arch;
@


1.238
log
@tweak meta-info checking a bit.
- remove IsLink tests, there's no reason to treat them specially.
- files are forced to root, no need to allow for bin anymore.

- force libraries to be not executable, if there's no explicit @@mode
annotation
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.237 2014/10/13 12:44:16 espie Exp $
d572 1
a572 1
		$state->say("See rc.d(8) for details.");
@


1.237
log
@scaffolding for future new features, committed early, so that pkg_sign
will grok it when it happens
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.236 2014/09/09 09:40:23 espie Exp $
d165 1
d695 2
@


1.236
log
@register @@newuser/@@newgroup so that we try creating tarballs with the correct
users (which doesn't really matter all that much, as the owner/group in
the plist are what matters)

Otherwise, if we're not root, dismiss user id and groups, replace
with root/bin (significant fix from previous version: this interprets $(
correctly).  Should help with FAKE_AS_ROOT=No
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.235 2014/07/10 10:32:01 espie Exp $
d512 14
@


1.235
log
@add a separate timestamp annotation to have this as metadata
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.234 2014/03/18 18:53:29 espie Exp $
d245 3
d251 3
d1128 6
d1189 6
d1237 1
d1242 3
d1258 1
d1263 3
@


1.234
log
@remove $_ usage that warns under perl 5.18
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.233 2014/02/10 19:12:20 espie Exp $
d369 3
d407 6
d844 13
d1557 5
d1776 6
@


1.233
log
@cvstags are a bit fickle, there's no need to always-update if they change.
from Mikolaj Kucharski
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.232 2014/02/09 19:22:19 espie Exp $
d1269 2
a1270 2
	my $_ = $self->name;
	if (m/\%F/o) {
d1272 1
a1272 1
		s/\%F/$state->{lastfile}->{name}/g;
d1274 1
a1274 1
	if (m/\%D/o) {
d1276 1
a1276 1
		s/\%D/$state->cwd/ge;
d1278 1
a1278 1
	if (m/\%B/o) {
d1280 1
a1280 1
		s/\%B/dirname($state->{lastfile}->fullname)/ge;
d1282 1
a1282 1
	if (m/\%f/o) {
d1284 1
a1284 1
		s/\%f/basename($state->{lastfile}->fullname)/ge;
d1286 1
a1286 1
	return $_;
@


1.232
log
@forgot about that small issue. Don't take crypto sigs into account for
"always-update" comparisons (among other things, the crypto sig contains
a timestamp which will always change).

Put things in line with other "package changed" comparison.

Reminded by Mikolaj Kucharski
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.231 2014/02/03 16:18:05 espie Exp $
d719 5
@


1.231
log
@don't remove this test, indicate why it can trigger
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.230 2014/02/03 16:13:13 espie Exp $
d127 6
d1719 5
d1793 5
@


1.230
log
@gc old stuff that never fixed the problem it intended to fix :(
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.229 2014/02/03 15:57:13 espie Exp $
d563 1
@


1.229
log
@store compact form of manpages.

fix a long standing stupid bug: can't store both deleted and added manpages in
the same hash, otherwise the first deletion is going to scrape already added
stuff. Ouchie.
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.228 2014/01/31 15:48:44 espie Exp $
a738 2
	} elsif ($args eq 'no shadow') {
		$plist->{state}{lastdir}{noshadow} = 1;
a1371 3
	if (defined $self->{noshadow}) {
		print $fh "\@@tag no shadow\n";
	}
@


1.228
log
@@@md5 annotations died at the end of 2008, so it's reasonable to scrape the
code now.
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.227 2014/01/11 11:51:01 espie Exp $
d562 1
a562 1
	my ($self, $state) = @@_;
d565 2
a566 3
	if ($fname =~ m,^(.*/man)/(?:man|cat).*?/,) {
		my $d = $1;
		push(@@{$state->{mandirs}->{$d}}, $fname);
d738 1
a738 1
		$plist->{state}->{lastfile}->{nochecksum} = 1;
d740 1
a740 1
		$plist->{state}->{lastdir}->{noshadow} = 1;
d742 3
a744 3
		my $object = $plist->{state}->{lastfileobject};
		$object->{tags}->{$args} = 1;
		push(@@{$plist->{tags}->{$args}}, $object);
@


1.227
log
@a bit of spring cleanup in advance: scrape old stuff that's not really
used.
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.226 2014/01/09 20:20:01 espie Exp $
a713 15
package OpenBSD::PackingElement::md5;
our @@ISA=qw(OpenBSD::PackingElement::Annotation);

__PACKAGE__->register_with_factory('md5');

sub add
{
	my ($class, $plist, $args) = @@_;

	require OpenBSD::md5;

	$plist->{state}->{lastchecksummable}->add_digest(OpenBSD::md5->fromstring($args));
	return;
}

d1827 1
a1827 1
    libdepend endfake ignore vendor incompatibility)) {
@


1.226
log
@bump copyright to 2014
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.225 2014/01/07 18:35:23 espie Exp $
a855 2
	} elsif ($args eq 'system-package') {
		return OpenBSD::PackingElement::SystemPackage->new;
a857 2
	} elsif ($args eq 'explicit-update') {
		return OpenBSD::PackingElement::ExplicitUpdate->new;
a896 5
package OpenBSD::PackingElement::SystemPackage;
our @@ISA=qw(OpenBSD::PackingElement::UniqueOption);

sub category() { 'system-package' }

a904 7
package OpenBSD::PackingElement::ExplicitUpdate;
our @@ISA=qw(OpenBSD::PackingElement::UniqueOption);

sub category()
{
	'explicit-update';
}
a1029 20
sub destate
{
	my ($self, $state) = @@_;
	$state->{lastchecksummable} = $self;
}

sub write
{
	my ($self, $fh) = @@_;
	$self->SUPER::write($fh);
	if (defined $self->{d}) {
		$self->{d}->write($fh);
	}
}

sub add_digest
{
	&OpenBSD::PackingElement::FileBase::add_digest;
}

a1055 7
package OpenBSD::PackingElement::Incompatibility;
our @@ISA=qw(OpenBSD::PackingElement::Meta);

sub keyword() { "incompatibility" }
__PACKAGE__->register_with_factory;
sub category() { "incompatibility" }

a1084 7
package OpenBSD::PackingElement::UpdateSet;
our @@ISA=qw(OpenBSD::PackingElement::Meta);

sub keyword() { "updateset" }
__PACKAGE__->register_with_factory;
sub category() { "updateset" }

a1192 15
package OpenBSD::PackingElement::EndFake;
our @@ISA=qw(OpenBSD::PackingElement::State);


sub keyword() { 'endfake' }
__PACKAGE__->register_with_factory;

sub new
{
	my ($class, @@args) = @@_;
	bless {}, $class;
}

sub stringize() { '' }

a1641 4
package OpenBSD::PackingElement::FMETA;
our @@ISA=qw(OpenBSD::PackingElement::SpecialFile);
sub name() { OpenBSD::PackageInfo::META }

a1723 1

d1842 1
a1842 1
    libdepend ignore vendor)) {
@


1.225
log
@severely restrict what characters can be in a signer, to make
certain it's not possible to go ../  from /etc/signify
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.224 2014/01/07 13:52:43 espie Exp $
d4 1
a4 1
# Copyright (c) 2003-2010 Marc Espie <espie@@openbsd.org>
@


1.224
log
@scrape support for old +COMMENT file.
8 years of backward compatibility is long enough... :)
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.223 2014/01/07 13:37:23 espie Exp $
d1793 9
@


1.223
log
@recognize special file +META
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.222 2014/01/07 13:31:36 espie Exp $
a1700 10
}
package OpenBSD::PackingElement::FCOMMENT;
our @@ISA=qw(OpenBSD::PackingElement::SpecialFile);
sub name() { OpenBSD::PackageInfo::COMMENT }

sub new
{
	my ($self, @@r) = @@_;
	print STDERR "Warning: obsolete special file: +COMMENT\n";
	$self->SUPER::new(@@r);
@


1.222
log
@tedu some very old checks: we no longer have INSTALL/UNINSTALL scripts,
so we don't care whether /var/db/pkg is mounted noexec.
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.221 2014/01/07 13:26:18 espie Exp $
d1716 4
@


1.221
log
@let's verify all checksums.
I forgot about special files, since they've been extracted early,
but they can be checked nonetheless.

(prevents people from tampering with DESC and the like)
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.220 2014/01/04 14:14:55 espie Exp $
a1597 3

sub exec_on_add { 0 }
sub exec_on_delete { 0 }
@


1.220
log
@recognize @@option firmware
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.219 2014/01/04 01:42:46 espie Exp $
d1666 20
d1701 4
@


1.219
log
@mark @@vendor as old keyword so that transitory packages can be handled
thru pkg_delete -q
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.218 2014/01/04 00:14:08 espie Exp $
d854 2
d896 4
@


1.218
log
@vendor->signer
shorten pubkey -> pub (naddy@@)
\\ -> \e (jmc@@)
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.217 2014/01/03 13:12:35 espie Exp $
d1882 1
a1882 1
    libdepend ignore)) {
@


1.217
log
@explain why digital-sig must be unique
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.216 2014/01/02 20:13:43 espie Exp $
d1767 1
a1767 1
package OpenBSD::PackingElement::Vendor;
d1769 1
a1769 1
sub keyword() { 'vendor' }
d1771 1
a1771 1
sub category() { "vendor" }
d1775 1
a1775 1
# (likewise for vendor)
@


1.216
log
@simplify handling of special files some more, that stuff has fixed names
anyways
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.215 2013/12/31 11:21:10 espie Exp $
d1773 3
d1778 1
@


1.215
log
@signify support
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.214 2013/12/30 09:14:49 espie Exp $
a1636 7
sub add
{
	my ($class, $plist, @@args) = @@_;

	$class->SUPER::add($plist, $class->category);
}

d1642 1
a1642 1
		return $d.$self->category;
d1648 12
d1662 1
a1662 1
sub category() { OpenBSD::PackageInfo::CONTENTS }
d1677 8
a1684 1
sub category() { OpenBSD::PackageInfo::COMMENT }
d1688 1
a1688 1
sub category() { OpenBSD::PackageInfo::DESC }
d1712 1
a1712 1
sub category() { OpenBSD::PackageInfo::DISPLAY }
d1716 1
a1716 1
sub category() { OpenBSD::PackageInfo::UNDISPLAY }
@


1.214
log
@@@vendor annotation
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.213 2013/10/15 20:23:51 schwarze Exp $
d1808 1
a1808 1
sub new_x509
d1810 2
a1811 2
	my ($class) = @@_;
	bless { key => 'x509', timestamp => time, b64sig => '' }, $class;
a1812 1

@


1.213
log
@If the fake target of a port installed an empty (0-byte) file as a
manual page, pkg_create(1) asked groff to process the empty file,
which failed, and then decided to install the empty file as a source
manual page, which later caused mandoc(1) called from man(1) to
complain to the end-user.  Instead, detect the emptiness in time,
skip the formatting attempt, skip the file, process the packing
list to its end, then abort pkg_create(1) unsuccessfully such that
the porter sees the problem and can fix whatever the root cause is.

Problem reported by naddy@@ as seen in p5-Carp-Datum during a bulk build,
solution is joint work with espie@@, again tested in a bulk by naddy@@;
"please commit" espie@@.
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.212 2013/05/13 18:30:51 espie Exp $
d1754 6
@


1.212
log
@specialfiles ARE file while destated, so they set lastfile, which is
useful for size and digest. BUT samples should never alias specialfiles,
so error out right away.
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.211 2013/02/18 20:24:11 okan Exp $
d592 4
d627 1
@


1.211
log
@re-apply:
use localbase for pkg-readmes

ok espie@@
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.210 2013/02/18 19:56:10 okan Exp $
d477 1
d481 4
@


1.210
log
@revert previous; wrong time.
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.209 2013/02/18 19:29:03 okan Exp $
d180 1
a180 1
		$state->say("Look in /usr/local/share/doc/pkg-readmes for extra documentation.");
@


1.209
log
@use localbase for pkg-readmes

ok espie@@
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.208 2012/10/13 10:28:22 jeremy Exp $
d180 1
a180 1
		$state->say("Look in #1/share/doc/pkg-readmes for extra documentation.", $state->{localbase});
@


1.208
log
@In update verbose mode, when skipping an update candidate due to an
unmatching pkgpath, if no valid update candidates are found, print that
we are skipping the update candidate and all pkgpaths for both the
currently installed package and the skipped update candidate.

This is designed to help diagnosing issues when ports move locations
in the tree, but the necessary @@pkgpath entries are not correctly added
to the PLIST.

Much help and OK espie@@
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.207 2012/07/12 08:57:02 espie Exp $
d180 1
a180 1
		$state->say("Look in /usr/local/share/doc/pkg-readmes for extra documentation.");
@


1.207
log
@minor fix
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.206 2012/06/08 15:01:00 espie Exp $
d1864 11
@


1.206
log
@silent rename of @@comment subdir= to @@comment pkgpath=
this makes more sense
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.205 2012/05/15 08:14:29 espie Exp $
d752 1
@


1.205
log
@allow elements to remove themselves from PackingList, adjust visit
accordingly.

Make sure obsolete stuff ->add returns undef, unconfuses PkgCreate.
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.204 2012/05/07 17:21:23 espie Exp $
d687 1
a687 1
	} elsif ($args =~ m/^subdir\=(.*?)\s+cdrom\=(.*?)\s+ftp\=(.*?)\s*$/o) {
d943 1
a943 1
	    "subdir=".$self->{subdir},
@


1.204
log
@new method to convert other file names to fullname.
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.203 2012/05/05 10:20:58 espie Exp $
d68 6
d331 6
d1834 1
@


1.203
log
@un-specialcase shallow/deep copy: create a normal new plist.
(so don't copy FCONTENTS since it's automatically created)
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.202 2012/04/28 12:00:10 espie Exp $
d209 10
d221 2
a222 7
	my $self = $_[0];
	my $fullname = $self->name;
	if ($fullname !~ m|^/|o && $self->cwd ne '.') {
		$fullname = $self->cwd."/".$fullname;
		$fullname =~ s,^//,/,;
	}
	return $fullname;
@


1.202
log
@zap blank spaces
@
text
@d2 1
a2 1
# $OpenBSD$
d1633 8
@


1.201
log
@During pkg_create(1), do not print any warnings or non-fatal errors
from groff(1); of course, fatal errors cannot be ignored.
If you want to polish manuals, use mandoc(1) -Tlint instead.
ok espie@@, and millert@@ does not object
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.200 2011/08/23 10:32:27 espie Exp $
d902 2
a903 2
		path => OpenBSD::PkgPath->new($subdir), 
	    cdrom => $cdrom, 
d1049 1
a1049 1
	bless {name => $fullpkgpath, 
@


1.200
log
@zap old INSTALL/DEINSTALL stuff, it's been deprecated for 3 years, and removed
from pkg_create for over a year.
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.199 2011/06/24 22:43:58 espie Exp $
d596 2
a597 2
		    qw(-Tascii -mandoc -Wall -mtty-char -P -c), @@extra, '--',
		    $file);
@


1.199
log
@fix @@extra dir/
found out by sthen
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.198 2011/06/22 13:04:39 espie Exp $
a1633 29
package OpenBSD::PackingElement::ScriptFile;
our @@ISA=qw(OpenBSD::PackingElement::SpecialFile);
use OpenBSD::Error;

sub exec_on_add { 1 }
sub exec_on_delete { 1 }

sub run
{
	my ($self, $state, @@args) = @@_;

	my $pkgname = $state->{pkgname};
	my $name = $self->fullname;

	return if $state->{dont_run_scripts};

	$state->ldconfig->ensure;
	$state->say("#1 script: #2 #3 #4", $self->beautify, $name, $pkgname,
	    join(' ', @@args)) if $state->verbose >= 2;
	return if $state->{not};
	chmod 0755, $name;
	return if $state->log->system($name, $pkgname, @@args) == 0;
	if ($state->defines('scripts')) {
		$state->log->say($self->beautify." script failed");
	} else {
		$state->log->fatal($self->beautify." script failed");
	}
}

a1641 17
package OpenBSD::PackingElement::FINSTALL;
our @@ISA=qw(OpenBSD::PackingElement::ScriptFile);
sub exec_on_delete { 0 }
sub category() { OpenBSD::PackageInfo::INSTALL }
sub beautify() { "Install" }

package OpenBSD::PackingElement::FDEINSTALL;
our @@ISA=qw(OpenBSD::PackingElement::ScriptFile);
sub exec_on_add { 0 }
sub category() { OpenBSD::PackageInfo::DEINSTALL }
sub beautify() { "Deinstall" }

package OpenBSD::PackingElement::FREQUIRE;
our @@ISA=qw(OpenBSD::PackingElement::ScriptFile);
sub category() { OpenBSD::PackageInfo::REQUIRE }
sub beautify() { "Require" }

a1668 4

package OpenBSD::PackingElement::FMTREE_DIRS;
our @@ISA=qw(OpenBSD::PackingElement::SpecialFile);
sub category() { OpenBSD::PackageInfo::MTREE_DIRS }
@


1.198
log
@absolute_okay is more a property of the class than an extra parameter to
pass to compute_fullname. To be used in update-plist
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.197 2011/05/30 10:07:19 espie Exp $
d1555 1
@


1.197
log
@a few more comments, since for once this is complicated.
add subdir method to extrainfo and pkgpath to get to pkgpath string.
to be used in register-plist to allow for normalization of pkgpaths.
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.196 2011/05/30 09:59:38 espie Exp $
d195 1
d198 1
a198 1
	my ($self, $state, $absolute_okay) = @@_;
d203 1
a203 1
		unless ($absolute_okay) {
d458 1
d464 1
a464 1
	$self->compute_fullname($state, 1);
d473 2
d478 1
a478 1
	$self->compute_fullname($state, 1);
d487 1
d493 1
a493 1
	$self->compute_fullname($state, 1);
d1542 1
d1548 1
a1548 1
	$self->compute_fullname($state, 1);
@


1.196
log
@turn @@pkgpath into real objects, to simplify some updates by not having to
figure out what matches precisely.

approved by dcoppa@@. okay sthen@@, landry@@
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.195 2011/03/19 16:56:05 schwarze Exp $
d902 5
d1048 5
d1871 1
d1882 4
d1899 1
d1910 1
d1945 2
@


1.195
log
@Pass the new -c option to grotty when building manuals, to avoid ANSI
escape sequences and continue using traditional backspace escaping.
Using feedback from millert@@ and espie@@.
Tested by landry@@ in bulk builds.
ok naddy@@ landry@@

When installing this patch, make sure to upgrade your textproc/groff
package to groff-1.21 before trying to build ports, because the old
groff-1.15 grotty will error out when being fed the -c option.
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.194 2011/01/31 12:21:31 ajacoutot Exp $
d896 4
a899 1
	bless { subdir => $subdir, cdrom => $cdrom, ftp => $ftp}, $class;
d915 4
a918 2
	return "subdir=".$self->{subdir}." cdrom=".may_quote($self->{cdrom}).
	    " ftp=".may_quote($self->{ftp});
d1036 7
d1859 85
@


1.194
log
@Add a full stop at the end of the sentences from finish and report.

ok espie@@
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.193 2011/01/23 06:56:53 espie Exp $
d591 1
a591 1
		    '-Tascii', '-mandoc', '-Wall', '-mtty-char', @@extra, '--',
@


1.193
log
@hide details of "finish" inside PackingElement proper.
do the font dirs, also display a message for new installed rcscripts, and
if some stuff has been added to the readmes directory.
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.192 2011/01/14 14:32:18 espie Exp $
d174 1
a174 1
		$state->say("Look in /usr/local/share/doc/pkg-readmes for extra documentation");
d509 1
a509 1
		$state->say("See rc.d(8) for details");
@


1.192
log
@Quick fix for cwd = /
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.191 2011/01/02 15:25:45 espie Exp $
d168 10
d497 16
d1482 1
a1482 1
sub finish_fontdirs
d1484 1
a1484 1
	my $state = shift;
@


1.191
log
@create formatted manpages as temporary files we remove after the fact.
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.190 2010/12/24 09:09:54 espie Exp $
d204 1
@


1.190
log
@move the handling of ldconfig to AddDelete::State
actually simplifies code a great deal. It's not as if trying to avoid
loading ten lines of code is a good idea.
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.189 2010/12/24 09:04:14 espie Exp $
d534 1
a534 1
	my ($self, $state, $dest) = @@_;
a537 1
	$dest = "$base$dest";
d558 1
a558 1
		    open STDOUT, '>', "$dest" or
d560 1
@


1.189
log
@handle failures from ports tree with more care.
this does avoid infinite loops in case of wrong plists.
necessary since print-plist-with-depends CAN fail...
@
text
@d2 1
a2 1
# $OpenBSD$
d587 2
a588 14
	require OpenBSD::SharedLibs;

	my ($self, $destdir) = @@_;
	OpenBSD::SharedLibs::mark_ldconfig_directory($self->fullname,
	    $destdir);
}

sub ensure_ldconfig
{
	if ($todo) {
		require OpenBSD::SharedLibs;

		&OpenBSD::SharedLibs::ensure_ldconfig;
	}
d1282 1
a1282 1
	OpenBSD::PackingElement::Lib::ensure_ldconfig($state);
d1594 1
a1594 1
	OpenBSD::PackingElement::Lib::ensure_ldconfig($state);
@


1.188
log
@zap old Error usage, state incorporates error printing.
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.187 2010/10/27 14:35:56 espie Exp $
d559 1
a559 1
		    open STDOUT, '>', "$dest" or 
d562 1
a562 1
		    }, 
d564 1
a564 1
		    '-Tascii', '-mandoc', '-Wall', '-mtty-char', @@extra, '--', 
d1451 1
a1451 1
		$state->copy_file("$dirname/fonts.dir.dist", 
@


1.187
log
@initial scaffolding for @@rcscript: for now, acts like normal files,
but allow absolute pathnames (treat that as an implicit @@cwd).
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.186 2010/10/24 17:06:05 espie Exp $
d1447 1
a1447 1
	my $dirname = shift;
a1448 1
		require OpenBSD::Error;
d1451 2
a1452 1
		OpenBSD::Error::Copy("$dirname/fonts.dir.dist", "$dirname/fonts.dir");
a1459 2
	require OpenBSD::Error;

d1481 1
a1481 1
		map { restore_fontdir($_) } @@l;
@


1.186
log
@use newer system for more efficient redirection, and chdir the way man(1)
does, so groff is happier with .so.
(agreed by ingo)
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.185 2010/10/19 11:37:59 sthen Exp $
d464 19
@


1.185
log
@fix a split() which was causing problems with the mbox.5 manpage
in Mutt, as noticed by Andreas Kahari. ok espie@@ "we'll fix the fix
if it breaks".
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.184 2010/10/19 07:29:41 espie Exp $
d515 5
a519 2
	my ($self, $base, $out) = @@_;
	my $fname = $base."/".$self->fullname;
d534 16
a549 9
	open my $oldout, '>&STDOUT';
	my $dir = dirname("$base/$out");
	unless (-d $dir) {
		mkdir($dir);
	}
	open STDOUT, '>', "$base/$out" or die "Can't write to $base/$out";
	system(OpenBSD::Paths->groff,
	    '-Tascii', '-mandoc', '-Wall', '-mtty-char', @@extra, '--', $fname);
	open STDOUT, '>&', $oldout;
@


1.184
log
@before running groff, create dir when needed.
fixes tcl and the few ports with non-standard man locations that can't
rely on mtree fake.

as noticed by brad@@
@
text
@d2 1
a2 1
# $OpenBSD$
d523 1
a523 1
		for my $letter (split $1) {
@


1.183
log
@use proper log idiom (blanket okay from theo for pkg_add careful changes for
the time being)
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.182 2010/06/30 10:51:04 espie Exp $
d481 1
d532 4
@


1.182
log
@allow say and errsay to work without parameters, as it's ways common.
create verbose_system up in state, because it makes sense without verbose.
@
text
@d2 1
a2 1
# $OpenBSD$
d1625 1
a1625 1
			$state->log($_);
@


1.181
log
@whitespace cleanup
@
text
@@


1.180
log
@more printing changes.

move log operations into their own file, since they're used outside of
pkg_add/pkg_delete by pkg_check.

move all system stuff to State, so that printing can be localized/controlled.
Create primitives _print, _errprint, _fatal for overriding output, without
localization.

Accordingly, move a lot of code out of Error. We should also move Unlink and
Copy eventually.
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.179 2010/06/09 07:26:01 espie Exp $
d397 1
a397 1
		$state->log->fatal($state->f("#1 does not have a signature", 
@


1.179
log
@ui changes: go thru a state object for most printouts
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.178 2010/06/04 17:29:53 espie Exp $
d1581 1
a1581 1
		$state->log->warn($self->beautify, " script failed\n");
@


1.178
log
@add ->spec to Conflict and use the same check as for depend during pkg_create.
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.177 2010/06/04 13:19:39 espie Exp $
d397 2
a398 2
		$state->log->fatal($self->fullname,
		    " does not have a signature");
d402 2
a403 2
		$state->log->fatal("checksum for ", $self->fullname,
		    " does not match");
d406 1
a406 1
		$state->say("Checksum match for ", $self->fullname);
d1261 1
a1261 1
	$state->say($self->keyword, " ", $self->{expanded})
d1431 1
a1431 1
		$state->errsay("$cmd not found");
d1443 1
a1443 1
		$state->say("You may wish to update your font path for ",
d1575 1
a1575 1
	$state->say($self->beautify, " script: $name $pkgname ",
d1622 1
d1628 1
a1628 1
		$state->errsay("Can't open $fname: $!");
@


1.177
log
@move code around, so that commands can be used as modules.
pkg becomes the start hub, which does nothing except require the
correct module.
Saner code wrt Add/Delete, and more sharing.
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.176 2010/05/10 09:17:55 espie Exp $
d900 8
@


1.176
log
@whitespace fixes
@
text
@d2 1
a2 1
# $OpenBSD$
d1572 1
a1572 1
	if ($state->{defines}->{scripts}) {
@


1.175
log
@new keyword, @@ask-update, to be used *very* sparingly (so far, only useful
for pgsql updates)
@
text
@d48 1
a48 1
sub register_with_factory 
d56 1
a56 1
	} 
d75 1
a75 1
	
d102 1
a102 1
	
d397 1
a397 1
		$state->log->fatal($self->fullname, 
d402 1
a402 1
		$state->log->fatal("checksum for ", $self->fullname, 
d556 1
a556 1
	OpenBSD::SharedLibs::mark_ldconfig_directory($self->fullname, 
d641 1
a641 1
	
d656 1
a656 1
	
d694 3
a696 3
	bless { 
		name => $tag, 
		when => $condition, 
d704 1
a704 1
	return join(' ', map { $self->{$_}} 
d786 2
a787 2
sub stringize 
{ 
d789 1
a789 1
	return $self->category; 
d913 1
a913 1
	bless { name => $def, pkgpath => $pkgpath, pattern => $pattern, 
d920 1
a920 1
	return join(':', map { $self->{$_}} 
d994 1
a994 1
	return join(' ', map { $self->{$_}} 
d1031 1
a1031 1
	my ($name, $uid, $group, $loginclass, $comment, $home, $shell) = 
d1033 2
a1034 2
	bless { name => $name, uid => $uid, group => $group, 
	    class => $loginclass, 
d1041 1
a1041 1
	my ($name, $passwd, $uid, $gid, $quota, $class, $gcos, $dir, $shell, 
d1073 1
a1073 1
	return join(':', map { $self->{$_}} 
d1107 1
a1107 1
	return join(':', map { $self->{$_}} 
d1253 1
a1253 1
	$state->say($self->keyword, " ", $self->{expanded}) 
d1255 1
a1255 1
	$state->log->system(OpenBSD::Paths->sh, '-c', $self->{expanded}) 
d1325 1
a1325 1
	
d1435 1
a1435 1
		$state->say("You may wish to update your font path for ", 
d1567 1
a1567 1
	$state->say($self->beautify, " script: $name $pkgname ", 
d1617 1
a1617 1
		} 
d1698 1
a1698 1
	return sprintf("%04d-%02d-%02dT%02d:%02d:%02dZ", 
d1736 1
a1736 1
 
d1741 1
a1741 1
	return join(':', $self->{key}, time_to_iso8601($self->{timestamp}), 
d1748 1
a1748 1
	print $fh "\@@", $self->keyword, " ", $self->{key}, ":", 
d1788 1
a1788 1
for my $k (qw(src display mtree ignore_inst dirrm pkgcfl pkgdep newdepend 
@


1.174
log
@add an extra "mandoc" category that behaves exactly like man for now (to
be used for distinguishing between pages that require groff and those that
don't)
@
text
@d981 29
@


1.173
log
@move generic code to handle libspec in a new file, to clean up stuff
@
text
@d537 6
@


1.172
log
@pull the signature comparison code into its own file.
add comparison functions to Packagenames that return undef when it matters.
@
text
@d954 7
@


1.171
log
@build signature objects that we will be able to compare
@
text
@a154 1
sub signature {}
a917 6
sub signature
{
	my ($self, $hash) = @@_;
	$hash->{$self->{pkgpath}} = OpenBSD::PackageName->from_string($self->{def});
}

a951 10
}

sub signature
{
	my ($self, $hash) = @@_;
	require OpenBSD::SharedLibs;

	if (my ($stem, $major, $minor) = OpenBSD::SharedLibs::parse_spec($self->name)) {
	    $hash->{$stem} = OpenBSD::LibrarySpec->new($stem, $major, $minor);
	}
@


1.170
log
@repair
@
text
@a317 6
sub signature
{
	my ($self, $hash) = @@_;
	$hash->{$self->name} = 1;
}

d919 6
d959 10
@


1.169
log
@use Auto::cache
@
text
@d904 1
@


1.168
log
@new option 'explicit-update', for firmwares (don't consider these in bulk
updates, only when user asks for them explicitly)
@
text
@d924 4
a927 2
sub spec
{
d929 3
a931 7
	if (!defined $self->{spec}) {
		require OpenBSD::Search;
		$self->{spec} = OpenBSD::Search::PkgSpec->new($self->{pattern});
		$self->{spec}->add_pkgpath_hint($self->{pkgpath});
	}
	return $self->{spec};
}
@


1.167
log
@infrastructure for url elements
@
text
@d4 1
a4 1
# Copyright (c) 2003-2007 Marc Espie <espie@@openbsd.org>
d777 2
d827 7
@


1.166
log
@actually cache architecture, as intended
@
text
@d874 12
@


1.165
log
@change verbosity handling: be silent by default, turn on the first level if -v.
Add more levels, specifically, lots of info regarding individual files only
visible if -vvvvv.
Make -n display the same stuff as normal (need -n -v to display more stuff).
Introduce -s, "size-only", turns on -n and does skip any extraction.
Sprinkle handlers for SIG_INFO, not really nice yet.

Note that -n is non functional for complex updates, because of caching
issues I have to fix.
@
text
@d1600 2
a1605 1
	my ($machine_arch, $arch);
@


1.164
log
@be slightly more paranoid about shell stuff we run.
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.163 2009/11/11 13:00:40 espie Exp $
d412 1
a412 1
	if ($state->{very_verbose}) {
d1199 1
a1199 1
	    if $state->{beverbose};
a1505 1
	my $not = $state->{not};
d1513 2
a1514 2
	    join(' ', @@args)) if $state->{beverbose};
	return if $not;
@


1.163
log
@vsystem, system, unlink can mostly go through state, and do the ->clear part
as well.
@
text
@d2 1
a2 1
# $OpenBSD$
d540 1
a540 1
	    '-Tascii', '-mandoc', '-Wall', '-mtty-char', @@extra, $fname);
d1383 2
a1384 2
		run_if_exists($state, OpenBSD::Paths->mkfontscale, @@l);
		run_if_exists($state, OpenBSD::Paths->mkfontdir, @@l);
d1388 1
a1388 1
		run_if_exists($state, OpenBSD::Paths->fc_cache, @@l);
@


1.162
log
@remove redirector: if we want to run system AND log, just say so
@
text
@d1366 1
a1366 1
		OpenBSD::Error::VSystem($state->{very_verbose}, $cmd, @@l);
@


1.161
log
@don't use Warn if we've got a $state, get through errprint/errsay.
Also: reset lastdisplay on clear, and don't clear twice.
@
text
@d1200 1
a1200 1
	$state->system(OpenBSD::Paths->sh, '-c', $self->{expanded}) 
d1517 1
a1517 1
	return if $state->system($name, $pkgname, @@args) == 0;
@


1.160
log
@progressmeter puts STDOUT in autoflush if -t, so that it can display to it instead of piping a lot of stuff to STDERR.

Go through state->print for most messages, so they will NOT do weird things
with the progressmeter.
Use a ->say shortcut which does the same thing that perl 5.10 say does...
@
text
@d1368 1
a1368 1
		OpenBSD::Error::Warn("$cmd not found\n");
d1565 1
a1565 1
		Warn "Can't open $fname: $!\n";
@


1.159
log
@remove forwarders, and provide a sensible API that says what's going on
(e.g., we're logging information for later).
@
text
@d413 1
a413 1
		print "Checksum match for ", $self->fullname, "\n";
d1198 2
a1199 1
	print $self->keyword, " ", $self->{expanded}, "\n" if $state->{beverbose};
d1380 2
a1381 1
		print "You may wish to update your font path for ", join(' ', @@l), "\n";
d1513 2
a1514 1
	print $self->beautify, " script: $name $pkgname ", join(' ', @@args), "\n" if $state->{beverbose};
@


1.158
log
@bad espie: use strict/warnings consistently, and fix two nits and two
actual errors !
@
text
@d404 2
a405 1
		$state->fatal($self->fullname, " does not have a signature");
d409 1
a409 1
		$state->fatal("checksum for ", $self->fullname, 
d1516 1
a1516 1
		$state->warn($self->beautify, " script failed\n");
d1518 1
a1518 1
		$state->fatal($self->beautify." script failed");
d1559 1
a1559 1
			$state->print($_);
@


1.157
log
@add @@option always-update.
a package tagged as 'always-update' will have its full packing-list, complete
with checksums, as signatures, so it will always get updated, even when the
version number doesn't change, as long as it's not the same package.
@
text
@d20 1
@


1.156
log
@synch with my new style search/location changes
It's likely there will be some fallout, but it's getting a bit too large
to keep around.
This does kill a few very old oddities as well.
@
text
@d773 2
d814 8
@


1.155
log
@initial implementation of package signatures, based on x509 certificates and
smime detached signatures.
@
text
@d133 11
d147 1
a147 1
	return $self->{name};
d190 2
a191 2
	$self->{name} = File::Spec->canonpath($self->{name});
	if ($self->{name} =~ m|^/|) {
d193 1
a193 1
			die "Absolute name forbidden: ", $self->{name};
d201 1
a201 1
	my $fullname = $self->{name};
d320 1
a320 1
	$hash->{$self->{name}} = 1;
d405 1
a405 1
	my $d = $self->compute_digest($file->{destdir}.$file->{name});
d505 1
a505 1
	return $self->{name} =~ m/man\/man[^\/]+\/[^\/]+\.[\dln][^\/]?$/o;
d511 1
a511 1
	my $v = $self->{name};
d975 1
a975 1
	    $expire) = getpwnam($self->{name});
d1029 1
a1029 1
	my ($name, $passwd, $gid, $members) = getgrnam($self->{name});
d1055 1
a1055 1
	$state->set_cwd($self->{name});
d1083 1
a1083 1
	if ($self->{name} eq '') {
d1086 1
a1086 1
		$state->{owner} = $self->{name};
d1100 1
a1100 1
	if ($self->{name} eq '') {
d1103 1
a1103 1
		$state->{group} = $self->{name};
d1117 1
a1117 1
	if ($self->{name} eq '') {
d1120 1
a1120 1
		$state->{mode} = $self->{name};
d1155 1
a1155 1
	my $_ = $self->{name};
d1262 1
a1262 1
	return $self->{name}."/";
@


1.154
log
@more stuff to check digests during extraction, if wanted.
Fix read/write of digitalsignature stuff.
don't integrate manual-installs, since it's highly variable.
create correct category for digitalsignature, so it gets written out.
@
text
@d390 1
d1650 6
@


1.153
log
@stupid bug. If I don't name the class the same way, I don't override
behavior correctly. Be consistent, use the same naming scheme.
problem noticed by Brad Smith.
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.152 2008/10/28 09:51:58 espie Exp $
d379 24
d791 5
d1606 1
d1661 1
a1661 1
	    $self->{timestamp}, "\n";
@


1.152
log
@"destate" comments, let them know in which cwd they stand.
This is actually useful for update-plist...
@
text
@d2 1
a2 1
# $OpenBSD$
d1162 1
a1162 1
package OpenBSD::PackingElement::ExecInstall;
@


1.151
log
@tweak compute_digest so that it `defaults' if invoked without a 2nd argument.
switch the default digest to sha256.

It's been there for a few weeks, all package tools cope with both formats,
now is the time for the switch.
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.150 2008/10/20 10:25:16 espie Exp $
d566 6
@


1.150
log
@Say goodbye to local $_
lexical scoping is so much neater (courtesy of perl 5.10)
@
text
@d2 1
a2 1
# $OpenBSD$
d257 1
@


1.149
log
@turn the checksums stored in packing elements into real objects, so that
pkg_add becomes mostly independent of the type of checksum stored.

separate md5 into an abstract OpenBSD::digest class and an md5 subclass
with specific methods to compute checksums and serialize results, and create
an sha class that does the same thing with sha256 (with a base64 serializer)
@
text
@d1107 1
a1107 1
	local $_ = $self->{name};
@


1.148
log
@further step on the road to tags:
make definitions migrate to the top of the packing-list,
allow solver to find tag on the correct name (will look at full definition
later).
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.147 2008/06/11 09:42:13 espie Exp $
d253 1
a253 1
sub compute_md5
d255 1
a255 1
	my ($self, $filename) = @@_;
d257 1
a257 1
	return OpenBSD::md5::fromfile($filename);
d322 2
a323 2
	if (defined $self->{md5}) {
		print $fh "\@@md5 ", unpack('H*', $self->{md5}), "\n";
d352 1
a352 1
sub add_md5
d354 2
a355 2
	my ($self, $md5) = @@_;
	$self->{md5} = $md5;
a356 1

d597 17
d615 1
a615 1
	$plist->{state}->{lastchecksummable}->add_md5(pack('H*', $args));
d871 2
a872 2
	if (defined $self->{md5}) {
		print $fh "\@@md5 ", unpack('H*', $self->{md5}), "\n";
d876 1
a876 1
sub add_md5
d878 1
a878 1
	&OpenBSD::PackingElement::FileBase::add_md5;
d1367 1
a1367 1
sub add_md5
d1369 1
a1369 1
	&OpenBSD::PackingElement::FileBase::add_md5;
d1377 1
a1377 1
sub compute_md5
d1379 1
a1379 1
	&OpenBSD::PackingElement::FileObject::compute_md5;
@


1.147
log
@let elements be responsible for computing their own md5 (allows special
behavior for @@bin object).
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.146 2008/06/06 14:49:21 espie Exp $
d260 12
d626 1
d629 18
@


1.146
log
@@@wantlib elements become checksummable
@
text
@d2 1
a2 1
# $OpenBSD$
d253 7
d1322 1
a1322 2
	my ($self, $md5) = @@_;
	$self->{md5} = $md5;
d1327 1
a1327 2
	my ($self, $sz) = @@_;
	$self->{size} = $sz;
d1330 4
a1333 1
sub needs_keyword { 0 }
d1339 2
@


1.145
log
@add a marker for true binary files to be used by prelinking
@
text
@d325 1
d580 1
a580 1
	$plist->{state}->{lastfile}->add_md5(pack('H*', $args));
d806 20
@


1.144
log
@rename forced to defines
@
text
@d534 6
@


1.143
log
@- there's no point in running mkfontdir only for @@fontdir ; so let's run
mkfontscale too (and remove fonts.scale on package removal)

discussed with matthieu@@ and espie@@ weeks ago
"seems fine" pyr@@, ok espie@@
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.142 2007/06/18 10:47:03 espie Exp $
d1371 1
a1371 1
	if ($state->{forced}->{scripts}) {
@


1.142
log
@add tag no shadow, to allow us to specify that we do NOT want tempfiles
into some directories.

a few minor style tweaks, such as using a nice join(map()) to build some
strings.
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.141 2007/06/17 12:09:36 espie Exp $
d1240 1
@


1.141
log
@fix format for timestamps. Use a non-ambiguous subset of ISO8601.
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.140 2007/06/17 10:44:01 espie Exp $
d135 2
a136 1
	return $_[0]->{name};
a360 1

d588 2
d731 1
a731 1
sub stringize($)
d733 1
a733 1
	my $self = $_[0];
d775 1
a775 1
sub stringize($)
d777 3
a779 2
	my $self = $_[0];
	return $self->{pkgpath}.':'.$self->{pattern}.':'.$self->{def};
d874 1
a874 1
sub stringize($)
d876 3
a878 4
	my $self = $_[0];
	return $self->{name}.':'.$self->{uid}.':'.$self->{group}.':'.
	    $self->{class}.':'.$self->{comment}.':'.$self->{home}.':'.
	    $self->{shell};
d911 2
a912 1
	return $self->{name}.':'.$self->{gid};
d1014 1
a1014 1
	my $self = $_[0];
d1025 2
a1026 2
	my $state = $_[2];
	local $_ = $_[1];
d1049 1
a1049 1
	$self->{expanded} = $self->expand($self->{name}, $state);
d1122 9
a1130 1
sub stringize($)
d1132 1
a1132 1
	my $self = $_[0];
d1134 9
@


1.140
log
@more scaffolding we don't really use yet.
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.139 2007/06/17 09:50:02 espie Exp $
d1466 32
d1501 2
a1502 1
	my ($key, $timestamp, $signature) = split(/\:/, $args);
d1507 1
d1511 2
a1512 1
	return join(':', $self->{key}, $self->{timestamp}, $self->{b64sig});
@


1.139
log
@add a bit of scaffolding for signatures
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.138 2007/06/16 12:16:42 espie Exp $
d589 3
a591 1
		die "Unknown tag $args";
d594 6
@


1.138
log
@introduce new stuff: @@tag, to be used to tag files and other objects.
Only one tag for now: no checksum.
Will supersede @@comment no checksum eventually.
Benefit: errors out in case of a typo.
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.137 2007/06/16 11:50:49 espie Exp $
d114 6
d1453 26
d1516 1
a1516 1
    libdepend digitalsignature ignore)) {
@


1.137
log
@Add variation on exec/unexec:
@@exec-always         @@unexec-always
@@exec-add            @@unexec-delete
@@exec-update         @@unexec-update

with the obvious semantics that *update are only run during updates,
and *add/delete are only run during `pure' additions/removals.

This should solve the problem of those packages that `lose' manual
configuration when you update them (e.g., all the mod_xxx apache stuff
and postfix).

caveat: you will need to go through one finaly broken update before the
new stuff kicks in.
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.136 2007/06/16 09:29:37 espie Exp $
d569 16
@


1.136
log
@use OpenBSD::Paths contents
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.135 2007/06/14 09:11:49 espie Exp $
d1035 18
d1057 18
@


1.135
log
@minor changes: move @@ignore to deprecated stuff (it's been out for a few
months now), register lastfileobject for future changes, make a common
class for uniqueoptions.
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.134 2007/06/12 09:53:36 espie Exp $
d21 1
d475 2
a476 2
	system('groff', '-Tascii', '-mandoc', '-Wall', '-mtty-char', 
	    @@extra, $fname);
d1025 2
a1026 1
	$state->system('/bin/sh', '-c', $self->{expanded}) unless $state->{not};
d1154 1
a1154 1
		run_if_exists($state, "/usr/X11R6/bin/mkfontdir", @@l);
d1158 1
a1158 1
		run_if_exists($state, "/usr/X11R6/bin/fc-cache", @@l);
d1382 2
a1383 1
			chomp($machine_arch = `/usr/bin/arch -s`);
d1387 2
a1388 1
			chomp($arch = `/usr/bin/uname -m`);
@


1.134
log
@tidy error messages: uses $! more consistently, do not append \n on die,
do append \n on warn.

Fix the two cases where the temp dir vanished too soon: not copying +DESC
should have been apparent. Not finding a +DISPLAY file is not a reason for
burping all over the place.
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.133 2007/06/06 12:32:09 espie Exp $
d224 1
a526 9
package OpenBSD::PackingElement::Ignore;
our @@ISA=qw(OpenBSD::PackingElement::Annotation);

__PACKAGE__->register_with_factory('ignore');

sub add
{
}

d634 2
d641 1
a641 1
package OpenBSD::PackingElement::NoDefaultConflict;
d644 4
a647 5
sub category() { 'no-default-conflict' }

sub stringize() 
{
	return 'no-default-conflict';
d656 5
d662 1
a662 1
our @@ISA=qw(OpenBSD::PackingElement::Unique OpenBSD::PackingElement::Option);
d666 2
a667 4
sub stringize() 
{
	return 'manual-installation';
}
d669 1
a669 5
sub new
{
	my ($class, @@args) = @@_;
	bless {}, $class;
}
d1428 1
a1428 1
    libdepend digitalsignature)) {
@


1.133
log
@tweak how copies happen: rename make_copy into make_shallow_copy,
make_deep_copy.

tweak keep_old_files so that we set the pkgname later, when it won't
cause any error to have duplicates in there.
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.132 2007/06/04 18:52:02 espie Exp $
d1330 9
a1338 6
	open(my $src, '<', $fname) or Warn "Can't open $fname: $!";
	while (<$src>) {
		next if m/^\+\-+\s*$/o;
		s/^[+-] //o;
		$state->print($_);
	}
@


1.132
log
@more efficient regexps: anchor stuff at both ends, be more specific in
what matches. Get rid of $`, $', $&, which encur a performance penalty.
(not yet done on PackageName and PkgSpec).
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.131 2007/06/04 16:13:30 espie Exp $
d137 1
a137 1
sub copy_if
d141 6
@


1.131
log
@stricter regexp for libraries.
Put the directory *last* as it can be empty, which breaks havoc with tests.
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.130 2007/06/04 15:57:09 espie Exp $
d208 2
a209 2
	if ($args =~ m|/+$|o and defined $class->dirclass) {
		bless { name => $` }, $class->dirclass;
d816 2
a817 2
	if ($self->{uid} =~ m/^\!/o) {
		return 0 unless $uid == $';
d819 3
a821 3
	if ($self->{group} =~ m/^\!/o) {
		my $g = $';
		unless ($g =~ m/^\d+/o) {
d827 2
a828 2
	if ($self->{class} =~ m/^\!/o) {
		return 0 unless $class eq $';
d830 2
a831 2
	if ($self->{comment} =~ m/^\!/o) {
		return 0 unless $gcos eq $';
d833 2
a834 2
	if ($self->{home} =~ m/^\!/o) {
		return 0 unless $dir eq $';
d836 2
a837 2
	if ($self->{shell} =~ m/^\!/o) {
		return 0 unless $shell eq $';
d871 2
a872 2
	if ($self->{gid} =~ m/^\!/o) {
		return 0 unless $gid == $';
@


1.130
log
@add a lib parsing routine to PackingElement::Lib so I don't have to
do the same thing again and again...
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.129 2007/06/04 14:57:33 espie Exp $
d501 2
a502 2
	if ($filename =~ m/^(.*)\/?lib(.*?)\.so\.(\d+)\.(\d+)$/o) {
		return ($1, $2, $3, $4);
@


1.129
log
@I am on drugs, I don't know where I found split can take strings as
arguments. Repair...
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.128 2007/06/04 14:42:19 espie Exp $
d495 10
@


1.128
log
@zap dead code: we no longer use DirRm.
stop recognizing @@comment MD5: as special.
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.127 2007/06/04 14:40:39 espie Exp $
d729 1
a729 1
	my ($pkgpath, $pattern, $def) = split ':', $args;
d794 1
a794 1
	    split ':', $args;
d852 1
a852 1
	my ($name, $gid) = split ':', $args;
d1344 1
a1344 1
	my @@arches= split(',', $args);
@


1.127
log
@some minor systematic changes.
- mark all regexps I can with /o if they can be compiled once.
- turn $o->method() into $o->method
- remove unneeded prototypes
- reduce split /re/ into split "string" where possible.
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.126 2007/06/02 12:44:37 espie Exp $
a531 3
	} elsif ($args =~ m/^MD5:\s*/o) {
		$plist->{state}->{lastfile}->add_md5(pack('H*', $'));
		return;
@


1.126
log
@show the font commands being run in very verbose state. After all, we show
ldconfig -R
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.125 2007/06/01 20:39:41 espie Exp $
d177 1
a177 1
	if ($fullname !~ m|^/| && $self->cwd ne '.') {
d208 1
a208 1
	if ($args =~ m|/+$| and defined $class->dirclass) {
d435 1
a435 1
	return $self->{name} =~ m/man\/man[^\/]+\/[^\/]+\.[\dln][^\/]?$/;
d456 1
a456 1
	if ($line =~ m/^\'\\\"\s+(.*)$/) {
d458 1
a458 1
			if ($letter =~ m/[ept]/) {
d530 1
a530 1
	if ($args =~ m/^\$OpenBSD.*\$\s*$/) {
d532 1
a532 1
	} elsif ($args =~ m/^MD5:\s*/) {
d535 1
a535 1
	} elsif ($args =~ m/^subdir\=(.*?)\s+cdrom\=(.*?)\s+ftp\=(.*?)\s*$/) {
d732 1
a732 1
	my ($pkgpath, $pattern, $def) = split /\:/, $args;
d797 1
a797 1
	    split /\:/, $args;
d809 1
a809 1
	if ($self->{uid} =~ m/^\!/) {
d812 1
a812 1
	if ($self->{group} =~ m/^\!/) {
d814 1
a814 1
		unless ($g =~ m/^\d+/) {
d820 1
a820 1
	if ($self->{class} =~ m/^\!/) {
d823 1
a823 1
	if ($self->{comment} =~ m/^\!/) {
d826 1
a826 1
	if ($self->{home} =~ m/^\!/) {
d829 1
a829 1
	if ($self->{shell} =~ m/^\!/) {
d855 1
a855 1
	my ($name, $gid) = split /\:/, $args;
d864 1
a864 1
	if ($self->{gid} =~ m/^\!/) {
d966 1
a966 1
	if ($args =~ m/^\s*(.*)\s*(\=|\>=)\s*(.*)\s*$/) {
d988 1
a988 1
	if (m/\%F/) {
d992 1
a992 1
	if (m/\%D/) {
d994 1
a994 1
		s/\%D/$state->cwd()/ge;
d996 1
a996 1
	if (m/\%B/) {
d998 1
a998 1
		s/\%B/dirname($state->{lastfile}->fullname())/ge;
d1000 1
a1000 1
	if (m/\%f/) {
d1002 1
a1002 1
		s/\%f/basename($state->{lastfile}->fullname())/ge;
d1068 1
a1068 1
	return $self->stringize =~ m/\^@@/;
d1319 2
a1320 2
		next if m/^\+\-+\s*$/;
		s/^[+-] //;
d1347 1
a1347 1
	my @@arches= split(/\,/, $args);
d1354 1
a1354 1
	return join(',',@@{$self->{arches}});
@


1.125
log
@micro-optimizations
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.124 2007/05/31 13:20:27 espie Exp $
d1126 1
a1126 1
	my ($cmd, @@l) = @@_;
d1131 1
a1131 1
		OpenBSD::Error::System($cmd, @@l);
d1147 1
a1147 1
		run_if_exists("/usr/X11R6/bin/mkfontdir", @@l);
d1151 1
a1151 1
		run_if_exists("/usr/X11R6/bin/fc-cache", @@l);
@


1.124
log
@don't bother registering files that have tempnames. The real files don't/no
longer exist. The stuff has been removed already anyways, this just makes
spurious warnings while deleting partial packages.

Also use auto-vivification, like we do everywhere else.
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.123 2007/05/31 13:11:21 espie Exp $
d34 1
a34 1
	if ($line =~ m/^\@@(\S+)\s*(.*)/) {
d41 1
@


1.123
log
@oops, move realname up so that ::Sample sees it too.

remove last traces of MODULEs.
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.122 2007/05/31 11:05:41 espie Exp $
d423 1
a426 3
		$state->{mandirs} = {} unless defined $state->{mandirs};
		$state->{mandirs}->{$d} = [] 
		    unless defined $state->{mandirs}->{$d};
@


1.122
log
@kill REQ script directly. I'm pretty sure it doesn't quite work anyways.
Deprecate INSTALL and DEINSTALL, write out warnings in pkg_create.

Clean up some more old cruft
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.121 2007/05/31 10:00:22 espie Exp $
d220 17
a342 17
sub set_tempname
{
	my ($self, $tempname) = @@_;
	$self->{tempname} = $tempname;
}

sub realname
{
	my ($self, $state) = @@_;

	my $name = $self->fullname;
	if (defined $self->{tempname}) {
		$name = $self->{tempname};
	}
	return $state->{destdir}.$name;
}

a782 38
package OpenBSD::PackingElement::Module;
our @@ISA=qw(OpenBSD::PackingElement::Meta);

use OpenBSD::PackageInfo;

sub keyword() { "module" }
__PACKAGE__->register_with_factory;
sub category() { "module" }

my $installed_modules = {};

sub add
{
	my ($class, $plist, $args) = @@_;

	require OpenBSD::Search;
	require OpenBSD::PackageRepository::Installed;

	my @@candidates = OpenBSD::PackageRepository::Installed->new
	    ->match(OpenBSD::Search::PkgSpec->new($args));
	if (@@candidates == 1) {
		if (!defined $installed_modules->{$candidates[0]}) {
			# pull in the module right here and now;
			my $f = installed_info($candidates[0]).MODULE;
			eval "require \"$f\";";
			if ($@@) {
				die "Error in reading module $f: $@@";
			}
		}
	} elsif (@@candidates == 0) {
		$plist->{need_modules} = 1;
	} else {
		die "Ambiguous module: ", $args;
	}
		
	$class->SUPER::add($plist, $args);
}

a1254 4

package OpenBSD::PackingElement::FMODULE;
our @@ISA=qw(OpenBSD::PackingElement::SpecialFile);
sub category() { OpenBSD::PackageInfo::MODULE }
@


1.121
log
@a few cosmetic changes, move realname over to PackingElement to be
able to use it in other cases.
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.120 2007/05/30 12:52:07 espie Exp $
a1350 4

package OpenBSD::PackingElement::FREQUIRED_BY;
our @@ISA=qw(OpenBSD::PackingElement::SpecialFile);
sub category() { OpenBSD::PackageInfo::REQUIRED_BY }
@


1.120
log
@simplify the way partial installations get recorded: store elements
already installed in a hash, and do a shallow copy of the list when
necessary, using make_copy.

This removes a lot of action-at-a-distance in packing-list elements.
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.119 2007/05/30 12:29:19 espie Exp $
d330 11
@


1.119
log
@new functionality: copy elements of packing-lists to a new plist if they
are registered in a hash. This will be used to create borked packages in
a much simpler way.

Also, set_pkgname, so that I don't have to remember whether this
packing-list already has a name. Useful when copying stuff over.
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.118 2007/05/29 13:52:07 espie Exp $
a267 1
	return if defined $self->{zap};
@


1.118
log
@don't bypass add_object to create special files, otherwise infodir won't
get defined.

Simplify and clean-up register_installation: everything is in the packing-list
so don't pass other arguments. Do not copy arbitrary info_names objects, but
use a copy_info visitor which copies exactly what files are around.

Use the stored infodir to locate DISPLAY and INSTALL files.
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.117 2007/05/29 13:00:17 espie Exp $
d135 6
@


1.117
log
@a few more details so that infodirs become useful.
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.116 2007/05/29 12:36:53 espie Exp $
d353 1
a353 1
		$plist->addunique($self);
a1292 1
	my $dir = $state->{dir};
d1295 1
a1295 1
	my $name = $self->{name};
d1300 1
a1300 1
	print $self->beautify, " script: $dir$name $pkgname ", join(' ', @@args), "\n" if $state->{beverbose};
d1302 2
a1303 2
	chmod 0755, $dir.$name;
	return if $state->system($dir.$name, $pkgname, @@args) == 0;
d1347 1
a1347 1
	my $fname = $state->{dir}.$self->{name};
@


1.116
log
@clean-up SpecialFile a bit: make sure the name passed during creation is
totally irrelevant.

Add a new property to packing-lists: infodir, and use it to compute fullnames
for special files.

Once this is properly synchronized, we can tie infodir to packing-lists, and
remove it from the state...
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.115 2007/05/29 10:56:22 espie Exp $
d1263 6
a1268 1
	return $self->infodir.'/'.$self->category;
@


1.115
log
@downgrade `can't find +DISPLAY' to a warning until I figure things out.
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.114 2007/05/24 10:06:35 espie Exp $
d1232 32
@


1.114
log
@catch up and rethrow Packing-List read issues with the filename when
available.
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.113 2007/05/22 09:39:24 espie Exp $
d1312 1
a1312 1
	open(my $src, '<', $fname) or Fatal "Can't open $fname: $!";
@


1.113
log
@mark `digitalsignature' as a known keyword, which helps me.
Use autovivification on stuff to remove.
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.112 2007/05/20 17:04:25 espie Exp $
d38 1
a38 2
			print STDERR "Unknown element: $line\n";
			exit 1 ;
@


1.112
log
@make the package tools more aware of manpages: handle names correctly,
and figure out how to process manpages.
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.111 2007/05/18 13:22:06 espie Exp $
d1416 1
a1416 1
    libdepend)) {
@


1.111
log
@Add pkgpath hints to pkgspec. Make PackageRepository/Source functional:
if a pkgpath is hinted at, then we build that package, and we delegate
to the corresponding File: repository.

Some XXX: we need to unlock the database temporarily, as the build
*requires* shared access to stuff that is going on (and possibly write
access for installing subpackages, so this cannot work 100% yet).

Still, this allows the transparent build of one single package, at least.
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.110 2007/05/17 15:46:27 espie Exp $
d416 40
@


1.110
log
@make sure that mkfontdir and friends get their arguments
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.109 2007/05/14 11:02:15 espie Exp $
d695 1
@


1.109
log
@put Search objects into their own file, finally
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.108 2007/05/14 10:53:31 espie Exp $
d1130 1
a1130 1
		run_if_exists("/usr/X11R6/bin/mkfontdir");
d1134 1
a1134 1
		run_if_exists("/usr/X11R6/bin/fc-cache");
@


1.108
log
@put search objects into a search class.
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.107 2007/05/14 10:43:45 espie Exp $
d693 1
a693 1
		require OpenBSD::PkgSpec;
d742 1
a742 1
	require OpenBSD::PkgSpec;
@


1.107
log
@name tweaks: match -> match_list, match_repo -> match
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.106 2007/05/13 10:08:11 espie Exp $
d694 1
a694 1
		$self->{spec} = OpenBSD::PkgSpec->new($self->{pattern});
d746 1
a746 1
	    ->match(OpenBSD::PkgSpec->new($args));
@


1.106
log
@normalize quoting in extra info.
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.105 2007/05/12 15:19:00 espie Exp $
d743 1
d745 2
a746 1
	my @@candidates = OpenBSD::PkgSpec->new($args)->match(installed_packages());
@


1.105
log
@lift PkgSpec creation up into PackingElement::Dependency.
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.104 2007/05/12 14:48:45 espie Exp $
d621 5
d629 10
d642 2
a643 2
	return "subdir=".$self->{subdir}." cdrom=".$self->{cdrom}.
	    " ftp=".$self->{ftp};
@


1.104
log
@use PkgSpec objects most of the time
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.103 2007/05/07 09:09:07 espie Exp $
d672 10
@


1.103
log
@split common code into run_if_exists
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.102 2007/05/07 09:03:44 espie Exp $
d719 1
a719 1
	my @@candidates = OpenBSD::PkgSpec::match($args, installed_packages());
@


1.102
log
@remove non sensical eval {}
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.101 2007/05/02 15:27:49 espie Exp $
d1080 13
d1103 2
a1104 5
		if (-x "/usr/X11R6/bin/mkfontdir") {
			OpenBSD::Error::System("/usr/X11R6/bin/mkfontdir", @@l);
		} else {
			OpenBSD::Error::Warn("/usr/X11R6/bin/mkfontdir not found\n");
		}
d1106 2
a1107 5
		if (-x "/usr/X11R6/bin/fc-cache") {
			OpenBSD::Error::System("/usr/X11R6/bin/fc-cache", @@l);
		} else {
			OpenBSD::Error::Warn("/usr/X11R6/bin/fc-cache not found\n");
		}
@


1.101
log
@replace general @@args -> $args unless strictly needed.
remove ($) prototypes which are more confusing than anything else.
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.100 2007/05/02 15:13:04 espie Exp $
d1091 1
a1091 1
			eval { OpenBSD::Error::System("/usr/X11R6/bin/mkfontdir", @@l); };
d1097 1
a1097 1
			eval { OpenBSD::Error::System("/usr/X11R6/bin/fc-cache", @@l); };
@


1.100
log
@replace abstract Factory name with a more sensible create name.
Call it OO, so that we can specialize it if we ever need it.
Be more explicit about parameters.
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.99 2007/05/02 15:05:30 espie Exp $
d126 1
a126 1
sub stringize($)
d167 1
a167 1
sub fullname($)
d474 1
a474 1
	my ($class, $plist, @@args) = @@_;
d476 3
a478 3
	if ($args[0] =~ m/^\$OpenBSD(.*)\$\s*$/) {
		return OpenBSD::PackingElement::CVSTag->add($plist, @@args);
	} elsif ($args[0] =~ m/^MD5:\s*/) {
d481 1
a481 1
	} elsif ($args[0] =~ m/^subdir\=(.*?)\s+cdrom\=(.*?)\s+ftp\=(.*?)\s*$/) {
d483 1
a483 1
	} elsif ($args[0] eq 'no checksum') {
d487 1
a487 1
		return $class->SUPER::add($plist, @@args);
d505 1
a505 1
	my ($class, $plist, @@args) = @@_;
d507 1
a507 1
	$plist->{state}->{lastfile}->add_md5(pack('H*', $args[0]));
d518 1
a518 1
	my ($class, $plist, @@args) = @@_;
d520 1
a520 1
	$plist->{state}->{lastfile}->make_symlink(@@args);
d531 1
a531 1
	my ($class, $plist, @@args) = @@_;
d533 1
a533 1
	$plist->{state}->{lastfile}->make_hardlink(@@args);
d544 2
a545 2
	my ($class, $plist, @@args) = @@_;
	$plist->{state}->{lastfile}->set_tempname(@@args);
d556 1
a556 1
	my ($class, $plist, @@args) = @@_;
d558 1
a558 1
	$plist->{state}->{lastfile}->add_size($args[0]);
d570 2
a571 2
	my ($class, @@args) = @@_;
	if ($args[0] eq 'no-default-conflict') {
d573 1
a573 1
	} elsif ($args[0] eq 'manual-installation') {
d576 1
a576 1
		die "Unknown option: $args[0]";
d715 1
a715 1
	my ($class, $plist, @@args) = @@_;
d719 1
a719 1
	my @@candidates = OpenBSD::PkgSpec::match($args[0], installed_packages());
d732 1
a732 1
		die "Ambiguous module: ", $args[0];
d735 1
a735 1
	$class->SUPER::add($plist, @@args);
d1317 1
a1317 1
	my ($o, $plist, @@args) = @@_;
d1320 1
a1320 1
		print STDERR "Warning: obsolete construct: \@@$keyword @@args\n";
d1323 1
a1323 1
	my $o2 = OpenBSD::PackingElement::Old->new($keyword, @@args);
@


1.99
log
@$o->method() becomes $o->method
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.98 2007/05/02 10:30:56 espie Exp $
d26 1
a26 1
# and Factory and register_with_factory.
d31 1
a31 1
sub Factory
d33 2
a34 2
	local $_ = shift;
	if (m/^\@@(\S+)\s*/) {
d36 1
a36 1
			$keyword{$1}->add(@@_, $');
d38 2
a39 2
			print STDERR "Unknown element: $_\n";
			exit(1);
d42 1
a42 1
		OpenBSD::PackingElement::File->add(@@_, $_);
@


1.98
log
@add code to keep obsolete constructs around. This allows pkg_info to
print them sensibly.
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.97 2007/05/01 20:01:55 espie Exp $
d104 2
a105 2
	my $s = $self->stringize();
	if ($self->needs_keyword()) {
d107 1
a107 1
		print $fh "\@@", $self->keyword(), "$s\n";
d117 2
a118 2
	my $s = $self->stringize();
	if ($self->needs_keyword()) {
d120 1
a120 1
		return "\@@".$self->keyword().$s;
d171 2
a172 2
	if ($fullname !~ m|^/| && $self->cwd() ne '.') {
		$fullname = $self->cwd()."/".$fullname;
d202 2
a203 2
	if ($args =~ m|/+$| and defined $class->dirclass()) {
		bless { name => $` }, $class->dirclass();
d343 1
a343 1
	return $self->stringize() =~ m/\^@@/;
d351 1
a351 1
	my $j = is_info_name($self->fullname());
d408 1
a408 1
	my $fname = $self->fullname();
d431 1
a431 1
	OpenBSD::SharedLibs::mark_ldconfig_directory($self->fullname(), 
d572 1
a572 1
		return OpenBSD::PackingElement::NoDefaultConflict->new();
d574 1
a574 1
		return OpenBSD::PackingElement::ManualInstallation->new();
d974 1
a974 1
	print $self->keyword(), " ", $self->{expanded}, "\n" if $state->{beverbose};
d1024 1
a1024 1
	return $self->stringize() =~ m/\^@@/;
d1045 1
a1045 1
	$fonts_todo{$state->{destdir}.$self->fullname()} = 1;
d1051 1
a1051 1
	$fonts_todo{$state->{destdir}.$self->fullname()} = 1;
d1190 1
a1190 1
	print $self->beautify(), " script: $dir$name $pkgname ", join(' ', @@args), "\n" if $state->{beverbose};
d1195 1
a1195 1
		$state->warn($self->beautify(), " script failed\n");
d1197 1
a1197 1
		$state->fatal($self->beautify()." script failed");
@


1.97
log
@simplify signature computation slightly
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.96 2007/05/01 19:48:30 espie Exp $
d1309 6
d1323 2
d1326 6
@


1.96
log
@unique objects probably use their class name as category.
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.95 2007/05/01 18:46:02 espie Exp $
d251 1
a251 1
	$hash->{$self->{def}} = 1;
d664 2
a665 1
	bless { pkgpath => $pkgpath, pattern => $pattern, def => $def }, $class;
a679 6

sub signature
{
	my ($self, $hash) = @@_;
	$hash->{$self->{name}} = 1;
}
@


1.95
log
@kill old constructs that have been deprecated since 2004.
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.94 2007/05/01 18:22:20 espie Exp $
d237 5
@


1.94
log
@move the old elements into PackingElements, since the code is now
much shorter.
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.93 2007/05/01 18:09:44 espie Exp $
a647 46
package OpenBSD::PackingElement::PkgConflict;
our @@ISA=qw(OpenBSD::PackingElement::Conflict);

sub keyword() { "pkgcfl" }
__PACKAGE__->register_with_factory;
sub category() { "pkgcfl" }

package OpenBSD::PackingElement::PkgDep;
our @@ISA=qw(OpenBSD::PackingElement::Depend);

sub signature
{
}

sub keyword() { "pkgdep" }
__PACKAGE__->register_with_factory;
sub category() { "pkgdep" }

package OpenBSD::PackingElement::NewDepend;
our @@ISA=qw(OpenBSD::PackingElement::Depend);

sub keyword() { "newdepend" }
__PACKAGE__->register_with_factory;
sub category() { "newdepend" }

sub new
{
	my ($class, $args) = @@_;
	my ($name, $pattern, $def) = split /\:/, $args;
	my $self = bless { pattern => $pattern, def => $def }, $class;
	# very old packages still work
	if ($name =~ m|/|) {
		$self->{pkgpath} = $name;
	} else {
		$self->{name} = $name;
	}
	return $self;
}

sub stringize($)
{
	my $self = $_[0];
	return (defined $self->{name} ? $self->{name} : $self->{pkgpath}).
	    ':'.$self->{pattern}.':'.$self->{def};
}

a680 29
package OpenBSD::PackingElement::LibDepend;
our @@ISA=qw(OpenBSD::PackingElement::Depend);

sub category() { "libdepend" }
sub keyword() { "libdepend" }
__PACKAGE__->register_with_factory;

sub new
{
	my ($class, $args) = @@_;
	my ($name, $libspec, $pattern, $def)  = split /\:/, $args;
	my $self = bless { libspec => $libspec, pattern => $pattern, 
	    def => $def }, $class;
	# very old packages still work
	if ($name =~ m|/|) {
		$self->{pkgpath} = $name;
	} else {
		$self->{name} = $name;
	}
	return $self;
}

sub stringize($)
{
	my $self = $_[0];
	return (defined $self->{name} ? $self->{name} : $self->{pkgpath}).
	    ':'.$self->{libspec}.':'.$self->{pattern}.':'.$self->{def};
}

a998 6
package OpenBSD::PackingElement::DirRm;
our @@ISA=qw(OpenBSD::PackingElement::DirlikeObject);

sub keyword() { "dirrm" }
__PACKAGE__->register_with_factory;

d1326 2
a1327 1
for my $k (qw(src display mtree ignore_inst)) {
@


1.93
log
@allows us to register anything, and not just a class, with the factory.
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.92 2007/05/01 18:07:00 espie Exp $
d1383 26
@


1.92
log
@define keyword() first, and allow register_with_factory() to reuse it
by default.
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.91 2007/05/01 17:54:46 espie Exp $
d48 1
a48 1
	my ($class, $k) = @@_;
d52 4
a55 1
	$keyword{$k} = $class;
@


1.91
log
@rename setKeyword to register_with_factory
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.90 2007/04/30 08:43:19 espie Exp $
d49 3
a326 1
__PACKAGE__->register_with_factory('file');
d328 1
a355 1
__PACKAGE__->register_with_factory('sample');
d357 1
a380 1
__PACKAGE__->register_with_factory('info');
d382 1
a387 1
__PACKAGE__->register_with_factory('shell');
d389 1
a393 1
__PACKAGE__->register_with_factory('man');
d395 1
a414 1
__PACKAGE__->register_with_factory('lib');
d416 1
a438 1
__PACKAGE__->register_with_factory('pkgconfig');
d440 1
a444 1
__PACKAGE__->register_with_factory('ltlib');
d446 1
d450 1
a460 1
__PACKAGE__->register_with_factory('comment');
d462 1
a556 1
__PACKAGE__->register_with_factory('option');
d558 1
a626 1
__PACKAGE__->register_with_factory('name');
d628 1
a633 1
__PACKAGE__->register_with_factory('localbase');
d635 1
a640 1
__PACKAGE__->register_with_factory('conflict');
d642 1
a647 1
__PACKAGE__->register_with_factory('pkgcfl');
d649 1
a658 1
__PACKAGE__->register_with_factory('pkgdep');
d660 1
d666 2
a667 1
__PACKAGE__->register_with_factory('newdepend');
a668 1
sub keyword() { "newdepend" }
d694 2
a695 1
__PACKAGE__->register_with_factory('depend');
a696 1
sub keyword() { "depend" }
a713 1
__PACKAGE__->register_with_factory('wantlib');
d716 1
a726 1
__PACKAGE__->register_with_factory('libdepend');
d729 1
a755 1
__PACKAGE__->register_with_factory('pkgpath');
d757 1
a762 1
__PACKAGE__->register_with_factory('incompatibility');
d764 1
a769 1
__PACKAGE__->register_with_factory('updateset');
d771 1
a778 1
__PACKAGE__->register_with_factory('module');
d780 1
a814 1
__PACKAGE__->register_with_factory("newuser");
d819 1
a873 1
__PACKAGE__->register_with_factory("newgroup");
d878 1
a907 1
__PACKAGE__->register_with_factory('cwd');
d910 1
a920 1
__PACKAGE__->register_with_factory('endfake');
d923 1
a935 1
__PACKAGE__->register_with_factory('owner');
d937 1
a952 1
__PACKAGE__->register_with_factory('group');
d954 1
a969 1
__PACKAGE__->register_with_factory('mode');
d971 1
a986 1
__PACKAGE__->register_with_factory('sysctl');
d988 1
a1052 2
__PACKAGE__->register_with_factory('exec');

d1054 1
a1058 1
__PACKAGE__->register_with_factory('unexec');
d1060 1
a1064 1
__PACKAGE__->register_with_factory('extraunexec');
d1066 1
a1073 1
__PACKAGE__->register_with_factory('dirrm');
d1075 1
a1088 1
__PACKAGE__->register_with_factory('dir');
d1090 1
a1111 1
__PACKAGE__->register_with_factory('fontdir');
d1113 1
a1185 1
__PACKAGE__->register_with_factory('mandir');
d1187 1
a1193 1
__PACKAGE__->register_with_factory('extra');
d1195 1
a1338 1
__PACKAGE__->register_with_factory('arch');
d1341 1
@


1.90
log
@add most things concerning @@ignore, since we now have ways nicer to do
things.

We still recognize @@ignore in packing-lists for now, but we don't handle
it. Not that register-plist has smart enough comparison functions that
it doesn't care about @@ignore at all...
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.89 2007/04/29 11:28:59 espie Exp $
d26 1
a26 1
# setKeyword and Factory.
d46 1
a46 1
sub setKeyword 
d324 1
a324 1
__PACKAGE__->setKeyword('file');
d353 1
a353 1
__PACKAGE__->setKeyword('sample');
d378 1
a378 1
__PACKAGE__->setKeyword('info');
d385 1
a385 1
__PACKAGE__->setKeyword('shell');
d391 1
a391 1
__PACKAGE__->setKeyword('man');
d412 1
a412 1
__PACKAGE__->setKeyword('lib');
d436 1
a436 1
__PACKAGE__->setKeyword('pkgconfig');
d442 1
a442 1
__PACKAGE__->setKeyword('ltlib');
d447 1
a447 1
__PACKAGE__->setKeyword('ignore');
d457 1
a457 1
__PACKAGE__->setKeyword('comment');
d489 1
a489 1
__PACKAGE__->setKeyword('md5');
d502 1
a502 1
__PACKAGE__->setKeyword('symlink');
d515 1
a515 1
__PACKAGE__->setKeyword('link');
d528 1
a528 1
__PACKAGE__->setKeyword('temp');
d540 1
a540 1
__PACKAGE__->setKeyword('size');
d553 1
a553 1
__PACKAGE__->setKeyword('option');
d623 1
a623 1
__PACKAGE__->setKeyword('name');
d630 1
a630 1
__PACKAGE__->setKeyword('localbase');
d637 1
a637 1
__PACKAGE__->setKeyword('conflict');
d644 1
a644 1
__PACKAGE__->setKeyword('pkgcfl');
d655 1
a655 1
__PACKAGE__->setKeyword('pkgdep');
d662 1
a662 1
__PACKAGE__->setKeyword('newdepend');
d690 1
a690 1
__PACKAGE__->setKeyword('depend');
d710 1
a710 1
__PACKAGE__->setKeyword('wantlib');
d723 1
a723 1
__PACKAGE__->setKeyword('libdepend');
d752 1
a752 1
__PACKAGE__->setKeyword('pkgpath');
d759 1
a759 1
__PACKAGE__->setKeyword('incompatibility');
d766 1
a766 1
__PACKAGE__->setKeyword('updateset');
d775 1
a775 1
__PACKAGE__->setKeyword('module');
d811 1
a811 1
__PACKAGE__->setKeyword("newuser");
d870 1
a870 1
__PACKAGE__->setKeyword("newgroup");
d904 1
a904 1
__PACKAGE__->setKeyword('cwd');
d917 1
a917 1
__PACKAGE__->setKeyword('endfake');
d932 1
a932 1
__PACKAGE__->setKeyword('owner');
d949 1
a949 1
__PACKAGE__->setKeyword('group');
d966 1
a966 1
__PACKAGE__->setKeyword('mode');
d983 1
a983 1
__PACKAGE__->setKeyword('sysctl');
d1049 1
a1049 1
__PACKAGE__->setKeyword('exec');
d1056 1
a1056 1
__PACKAGE__->setKeyword('unexec');
d1062 1
a1062 1
__PACKAGE__->setKeyword('extraunexec');
d1071 1
a1071 1
__PACKAGE__->setKeyword('dirrm');
d1086 1
a1086 1
__PACKAGE__->setKeyword('dir');
d1109 1
a1109 1
__PACKAGE__->setKeyword('fontdir');
d1183 1
a1183 1
__PACKAGE__->setKeyword('mandir');
d1191 1
a1191 1
__PACKAGE__->setKeyword('extra');
d1336 1
a1336 1
__PACKAGE__->setKeyword('arch');
@


1.89
log
@make packing-lists more regular by including the CONTENTS. Avoid
`recursion' by not writing it out. also remove PackingList::write,
since it's a simple visitor.
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.88 2007/04/15 10:17:29 espie Exp $
a252 1
	print $fh "\@@ignore\n" if defined $self->{ignore};
a281 4
	if (defined $state->{ignore}) {
		$self->{ignore} = 1;
		undef $state->{ignore};
	}
a450 3
	my ($class, $plist, @@args) = @@_;
	$plist->{state}->{ignore} = 1;
	return;
@


1.88
log
@update copyright years, standardize licence.
reword the introduction to the stuff originally from FreeBSD to clarify
slightly.
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.87 2007/04/15 10:01:13 espie Exp $
d1246 3
@


1.87
log
@do not rely on side-effects in there.
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.86 2006/12/16 12:28:15 espie Exp $
d4 1
a4 1
# Copyright (c) 2003-2004 Marc Espie <espie@@openbsd.org>
@


1.86
log
@ltlib marker for libtool convenience library.

Long-term, we want to be able to build stuff without installing dependencies
`for real', and pkgconfig and libtool files keep getting in the way, so
pkg_* will have to take control, sooner or later...
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.85 2006/12/02 10:48:03 espie Exp $
d503 1
a503 1
	$plist->{state}->{lastfile}->add_md5(pack('H*', $'));
@


1.85
log
@allows us to mark *.pc files as PkgConfig.
This will be useful for some `normalization' work (remove ports directory,
and replace /usr/local with DEPBASE or some such, so that building without
installation works).
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.84 2006/11/17 15:34:15 espie Exp $
d443 6
@


1.84
log
@don't return undef, use plain return.
(return undef is only false in a scalar context)
found my perlcritic, one of the few issues I agree with...
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.83 2006/03/19 12:01:13 espie Exp $
d437 6
@


1.83
log
@Partial revert of previous changes, nasty regexps not greedy the way they should. Broke md5.
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.82 2006/03/17 20:44:01 espie Exp $
d446 1
a446 1
	return undef;
d464 1
a464 1
		return undef;
d469 1
a469 1
		return undef;
d492 1
a492 1
	return undef;
d505 1
a505 1
	return undef;
d518 1
a518 1
	return undef;
d530 1
a530 1
	return undef;
d543 1
a543 1
	return undef;
d828 1
a828 1
	return undef unless defined $name;
d883 1
a883 1
	return undef unless defined $name;
d1369 1
a1369 1
	return undef;
@


1.82
log
@un-special case old constructs: make them inherit from the same class,
and remove any special code from Factory.

As it's simpler remove local variables.
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.81 2006/03/05 13:08:05 espie Exp $
d34 1
a34 1
	if (m/^\@@(\S+)\s*(.*)$/) {
d36 1
a36 1
			$keyword{$1}->add(@@_, $2);
@


1.81
log
@avoid running mkfontdir/fc-cache if they don't exist.
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.80 2006/02/07 11:16:57 espie Exp $
a29 1
our %oldkeyword;
d34 3
a36 9
	if (m/^\@@(\S+)\s*/) {
		my $cmd = $1;
		my $args = $';

		if (defined $keyword{$cmd}) {
			$keyword{$cmd}->add(@@_, $args);
		} elsif (defined $oldkeyword{$cmd}) {
			$oldkeyword{$cmd}->add(@@_, $args);
			print STDERR "Warning: obsolete construct: \@@$cmd $args\n";
d38 1
a38 1
			print STDERR "Unknown element: \@@$cmd $args\n";
a49 5
}

sub setOldKeyword {
	my ($class, $k) = @@_;
	$oldkeyword{$k} = $class;
@


1.80
log
@minor independent tweaks:
- make Newuser and Newgroup subclasses of Newauth, so that code can be shared.
- add property type() for these, that expands to user/group
- add property to SpecialFile() that says whether this is executed on
add/delete, so that we can check for noexec fs and error out early on these.
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.79 2005/10/19 10:41:19 espie Exp $
d1173 5
a1177 1
		eval { OpenBSD::Error::System("/usr/X11R6/bin/mkfontdir", @@l); };
d1179 5
a1183 1
		eval { OpenBSD::Error::System("/usr/X11R6/bin/fc-cache", @@l); };
@


1.79
log
@mark links being extracted with `zap', so that they do not get recorded
into partial plists until they've gone through an actual install.

Prevents partial replacements from destroying genuine links in packages
when they get uninstalled.
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.78 2005/09/04 22:47:56 espie Exp $
d814 3
d818 1
a818 1
our @@ISA=qw(OpenBSD::PackingElement::Action);
d821 1
d876 1
a876 1
our @@ISA=qw(OpenBSD::PackingElement::Action);
d880 1
d1213 3
d1247 3
d1283 1
d1289 1
@


1.78
log
@* New -i interactive option, that can ask obnoxious questions.
* move the signature code to a packing-list method, prepend the pkgname.
* depend on distant listings, cache these systematically.
* cut the PKG_PATH at :/ systematically, much simpler than parsing URLs.
People should get used to trailing /s.
* let pkg_add -u actually run the update.
* check for signature in more places, for instance, let pkg_add installed_stuff
be a void operation.
* grab enough stuff during updates to check signatures, so that pkg_add -u
can report updates that are not needed right away, instead of waiting
for the more confusing `trying to update'
* beginning of @@module support.
* @@pkgpath support, including updates.
* systematically expand stems when applicable.
* use visitors systematically in pkg_info.
* pkg_info -S reports signature.
* remove hardcoding of categories in PackingList, so that future modules
will be able to expand them.
* add @@updateset and @@incompatibility keywords.
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.77 2005/08/14 12:01:08 espie Exp $
d264 1
@


1.77
log
@no reason not to record special files sizes along with md5.
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.76 2005/06/21 19:12:31 espie Exp $
d141 2
d249 6
d658 4
d721 5
d756 57
d1229 4
@


1.76
log
@move Arch->check() up to Packingelement, so that it can be called anywhere,
not only while adding packages.

Add FatOnly filter, which will be used to get information from packing-lists
to select the correct packing-list from a fat package (e.g., @@arch and @@name).
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.75 2004/12/16 11:07:33 espie Exp $
d1137 6
@


1.75
log
@renamed borked_installation from borked.n to partial-<pkgname> ...
partial-<pkgname>.n if needed.

Make borked_installation take a message, to show installation/deinstallation
issues correctly.

Fix handling of ^C: this may lead some system calls to return early, thus
registering as errors: so always mark the last file as done, so that borked
installation will register it correctly.

Kill packing-list cache for anything but depends: we've got a global cache
of libraries now (use it in pkg_add).

Make almost everyone look at $main::not, so that we can call
register_installation
to_installation
RequirementList->add/delete
safely.

Simplify $not logic accordingly, do thing much more closely to what would
happen without -n.

This should allow pkg_add/pkg_delete -n to handle most nasty cases correctly
now, since all the relevant information is kept internally in a compact
format:
- register of shared libraries
- global register of conflicts
- cache of depends.
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.74 2004/12/09 18:58:25 espie Exp $
d1250 26
@


1.74
log
@make -f scripts work again, and document it properly in both pkg_add and
pkg_delete since it now works for both.
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.73 2004/11/21 15:36:17 espie Exp $
d437 1
a437 1
		&OpenBSD::SharedLibs::ensure_ldconfig();
@


1.73
log
@pull the code that handles shared libraries (ldconfig for now) aside.
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.72 2004/11/18 21:46:07 espie Exp $
d1170 5
a1174 1
	Fatal $self->beautify()." script borked";
@


1.72
log
@add @@wantlib and @@depend keyword
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.71 2004/11/13 12:01:30 espie Exp $
d417 2
a418 2
use File::Basename;
use OpenBSD::Error;
a422 27
my $todo = 0;
my $path;
our @@ldconfig = ('/sbin/ldconfig');

sub init_path($)
{
	my $destdir = shift;
	$path={};
	if ($destdir ne '') {
		unshift @@ldconfig, 'chroot', $destdir;
	}
	open my $fh, "-|", @@ldconfig, "-r";
	if (defined $fh) {
		local $_;
		while (<$fh>) {
			if (m/^\s*search directories:\s*(.*?)\s*$/) {
				for my $d (split(':', $1)) {
					$path->{$d} = 1;
				}
			}
		}
		close($fh);
	} else {
		print STDERR "Can't find ldconfig\n";
	}
}

d425 2
d428 2
a429 7
	if (!defined $path) {
		init_path($destdir);
	}
	my $d = dirname($self->fullname());
	if ($path->{$d}) {
		$todo = 1;
	}
a433 1
	my $state = shift;
d435 3
a437 3
		VSystem($state->{very_verbose}, 
		    @@ldconfig, "-R") unless $state->{not};
		$todo = 0;
@


1.71
log
@correctly read back tempnames.
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.70 2004/11/13 11:48:46 espie Exp $
d712 28
@


1.70
log
@likewise, packing-lists state will store refs to cwd, so make this
a true object with cwd()/set_cwd() functions.
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.69 2004/11/13 11:39:40 espie Exp $
d322 1
a322 1
	$self->{temp} = $tempname;
@


1.69
log
@cwd() function so that further changes to internal storage won't matter
that much.
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.68 2004/11/12 23:26:41 espie Exp $
d842 1
a842 2
	my $name = File::Spec->canonpath($self->{name});
	$state->{cwd} = \$name;
d949 1
a949 1
		s/\%D/${$state->{cwd}}/g;
@


1.68
log
@store a ref to cwd instead of cwd itself, allowing it to be shared.
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.67 2004/11/12 23:00:46 espie Exp $
d153 5
d175 2
a176 2
	if ($fullname !~ m|^/| && ${$self->{cwd}} ne '.') {
		$fullname = ${$self->{cwd}}."/".$fullname;
@


1.67
log
@avoid even more calls to canonpath.
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.66 2004/11/12 22:48:31 espie Exp $
d170 2
a171 2
	if ($fullname !~ m|^/| && $self->{cwd} ne '.') {
		$fullname = $self->{cwd}."/".$fullname;
d837 2
a838 1
	$state->{cwd} = File::Spec->canonpath($self->{name});
d945 1
a945 1
		s/\%D/$state->{cwd}/g;
@


1.66
log
@stop storing fullname, recompute it dynamically instead.
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.65 2004/11/12 22:39:40 espie Exp $
d158 1
d170 1
a170 1
	unless ($fullname =~ m|^/|) {
a172 1
	$fullname = File::Spec->canonpath($fullname);
d837 1
a837 1
	$state->{cwd} = $self->{name};
@


1.65
log
@do catfile manually, e.g., avoid several calls to canonpath.
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.64 2004/11/12 19:42:01 espie Exp $
d158 1
a158 2
	my $fullname = $self->{name};
	if ($fullname =~ m|^/|) {
d160 1
a160 1
			die "Absolute name forbidden: $fullname";
a161 2
	} else {
		$fullname = $self->{cwd}."/".$fullname;
a162 3
	$fullname = File::Spec->canonpath($fullname);
	$self->{fullname} = $fullname;
	return $fullname;
d167 7
a173 1
	return $_[0]->{fullname};
@


1.64
log
@don't store hexdigest internally.
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.63 2004/11/11 11:23:04 espie Exp $
d164 1
a164 1
		$fullname = File::Spec->catfile($state->{cwd}, $fullname);
@


1.63
log
@don't touch font directories if -n either...
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.62 2004/11/07 11:48:42 espie Exp $
d255 1
a255 1
		print $fh "\@@md5 ", $self->{md5}, "\n";
d492 1
a492 1
		$plist->{state}->{lastfile}->add_md5($');
d520 1
a520 1
	$plist->{state}->{lastfile}->add_md5($');
@


1.62
log
@don't try to be smart and not store the full tempname: we don't use this
except in rare cases, so it doesn't matter if the tempname is long,
and it doesn't justify missing extra code to restore it when reading the
packing-list...
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.61 2004/11/06 12:19:17 espie Exp $
d1083 1
d1088 1
a1088 1
		map { update_fontalias($_) } @@l;
d1090 1
@


1.61
log
@mark whole state for `replacing' so that only file entries get tempname
markers. Explain about tempname to PackingElement, so that we become
able to save temporary packing-lists (e.g, borking during replace will
now work).
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.60 2004/10/31 11:33:51 espie Exp $
d267 1
a267 1
		print $fh "\@@temp ", basename($self->{tempname}), "\n";
@


1.60
log
@Simplify ldconfig handling: one single ensure_ldconfig routine that
reruns ldconfig -R (okay, we don't check that -m would be enough, so what ?)

First hooks for -r: check that replacement should work.
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.59 2004/10/23 09:43:16 espie Exp $
d246 1
a246 1
use File::Spec;
d266 3
d314 6
d547 12
@


1.59
log
@system() method that stores command normal output so that we can show
it at end of pkg install/deinstall...
use for @@exec/INSTALL stuff.
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.58 2004/10/20 11:38:57 espie Exp $
d404 1
d409 1
a409 1
our $todo;
d413 1
a413 1
sub add_ldconfig_dirs()
d415 18
a432 4
	my $sub = shift;
	return unless defined $todo;
	for my $d (keys %$todo) {
		&$sub($d);
a433 1
	$todo={};
d440 1
a440 18
		$path={};
		if ($destdir ne '') {
			unshift @@ldconfig, 'chroot', $destdir;
		}
		open my $fh, "-|", @@ldconfig, "-r";
		if (defined $fh) {
			local $_;
			while (<$fh>) {
				if (m/^\s*search directories:\s*(.*?)\s*$/) {
					for my $d (split(':', $1)) {
						$path->{$d} = 1;
					}
				}
			}
			close($fh);
		} else {
			print STDERR "Can't find ldconfig\n";
		}
d444 11
a454 2
		$todo = {} unless defined $todo;
		$todo->{$d} = 1;
d946 1
a946 1
	main::ensure_ldconfig($state);
d1140 1
a1140 1
	main::ensure_ldconfig($state);
@


1.58
log
@basic framework for delayed messages.
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.57 2004/10/18 10:51:03 espie Exp $
d942 1
a942 1
	System('/bin/sh', '-c', $self->{expanded}) unless $state->{not};
d1138 1
a1138 1
	return if System($dir.$name, $pkgname, @@args) == 0;
@


1.57
log
@use OpenBSD::Getopt so that we can do -v -v.
Be much terser by default, start showing dependency information and
various things only with at least one -v.

Build a `flattened tree' of dependencies information in pkg_add, and
show why we install a given package (idea from deraadt@@).
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.56 2004/10/16 11:01:29 espie Exp $
a1175 6
	unless (defined $state->{display}) {
		require OpenBSD::Temp;
		require File::Temp;

		($state->{display}, $state->{displayname}) = File::Temp::tempfile("display.XXXXXXXXX", DIR => $OpenBSD::Temp::tempbase);
	}
a1177 3
	my $dest = $state->{display};
	local $_;
	print $dest "+-------------- ", $state->{pkgname}, "\n";
d1181 1
a1181 1
		print $dest "| $_";
a1182 1
	print $dest "+-------------- ", $state->{pkgname}, "\n";
@


1.56
log
@Add support for @@endfake and pkg_add -Q, to be documented later...
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.55 2004/10/13 18:39:07 espie Exp $
a1127 1
	my $verbose = $state->{verbose};
@


1.55
log
@@@sysctl
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.54 2004/10/12 21:05:20 espie Exp $
d812 15
@


1.54
log
@nicer display
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.53 2004/10/11 14:40:04 espie Exp $
d862 23
@


1.53
log
@common code for exec/unexec/extraunexec.
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.52 2004/10/11 14:35:08 espie Exp $
d1152 2
a1153 2
		s/^\+ //;
		print $dest $_;
@


1.52
log
@simplify ldconfig now that we run in an uniform way.
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.51 2004/10/11 13:46:17 espie Exp $
d866 1
d896 9
@


1.51
log
@aggregate all MESSAGES and display them at the end, with proper markers to
separate distinct packages.
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.50 2004/10/11 13:29:05 espie Exp $
d1087 1
a1087 1
	main::ensure_ldconfig($verbose) unless $not;
@


1.50
log
@move mandir handling to pkg_add/delete time, solely.
Adjust stuff so that pkg_add can run makewhatis just once.
pkg_delete cannot, since it has to have the manpages around still
to remove them...
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.49 2004/10/11 13:10:25 espie Exp $
d1122 26
d1149 1
a1149 1
our @@ISA=qw(OpenBSD::PackingElement::SpecialFile);
d1153 1
a1153 1
our @@ISA=qw(OpenBSD::PackingElement::SpecialFile);
@


1.49
log
@common code for all script running.
Common option for not running scripts: -I for both pkg_add and pkg_delete.
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.48 2004/10/11 10:30:34 espie Exp $
d81 4
d388 1
a388 1
sub destate
a390 1
	$self->SUPER::destate($state);
d398 1
a398 1
	}
@


1.48
log
@add support for undisplay file, to be able to show information at pkg
removal without having to run a DEINSTALL script...
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.47 2004/10/05 20:37:03 espie Exp $
d966 3
a968 3
	my ($self, $archive, $destdir, $verbose, $not) = @@_;
	$self->SUPER::install($archive, $destdir, $verbose, $not);
	$fonts_todo{$destdir.$self->fullname()} = 1;
d1068 24
d1101 1
a1101 1
our @@ISA=qw(OpenBSD::PackingElement::SpecialFile);
d1103 1
d1106 1
a1106 1
our @@ISA=qw(OpenBSD::PackingElement::SpecialFile);
d1108 1
d1111 1
a1111 1
our @@ISA=qw(OpenBSD::PackingElement::SpecialFile);
d1113 1
@


1.47
log
@move expand down to ::ExeclikeAction
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.46 2004/10/05 20:35:09 espie Exp $
d1095 4
@


1.46
log
@unbreak expand
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.45 2004/10/05 20:22:10 espie Exp $
a146 1
use File::Basename;
a185 22
sub expand
{
	my $state = $_[2];
	local $_ = $_[1];
	if (m/\%F/) {
		die "Bad expand" unless defined $state->{lastfile};
		s/\%F/$state->{lastfile}->{name}/g;
	}
	if (m/\%D/) {
		die "Bad expand" unless defined $state->{cwd};
		s/\%D/$state->{cwd}/g;
	}
	if (m/\%B/) {
		die "Bad expand" unless defined $state->{lastfile};
		s/\%B/dirname($state->{lastfile}->fullname())/ge;
	}
	if (m/\%f/) {
		die "Bad expand" unless defined $state->{lastfile};
		s/\%f/basename($state->{lastfile}->fullname())/ge;
	}
	return $_;
}
d862 1
d864 23
@


1.45
log
@explicitly call the right destate for Extradir
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.44 2004/10/05 20:20:59 espie Exp $
a28 1
use File::Basename;
d147 1
@


1.44
log
@more inheritance, reorder stuff slightly
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.43 2004/10/05 20:04:56 espie Exp $
d1041 5
@


1.43
log
@intermediate ::DirlikeObject class, so that all dir objects inherit from
it, including ::DirRm.
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.42 2004/10/05 19:44:15 espie Exp $
d587 1
a587 1
our @@ISA=qw(OpenBSD::PackingElement::Unique);
a589 1
sub keyword() { 'option' }
d603 1
a603 1
our @@ISA=qw(OpenBSD::PackingElement::Unique);
a605 1
sub keyword() { 'option' }
d620 1
a620 1
our @@ISA=qw(OpenBSD::PackingElement::Unique);
a621 1
sub keyword() { 'comment' }
d637 10
a646 2
package OpenBSD::PackingElement::PkgDep;
our @@ISA=qw(OpenBSD::PackingElement::Depend);
d648 3
a650 3
__PACKAGE__->setKeyword('pkgdep');
sub keyword() { "pkgdep" }
sub category() { "pkgdep" }
d666 7
d701 29
a817 44

package OpenBSD::PackingElement::LibDepend;
our @@ISA=qw(OpenBSD::PackingElement::Depend);

__PACKAGE__->setKeyword('libdepend');
sub category() { "libdepend" }
sub keyword() { "libdepend" }

sub new
{
	my ($class, $args) = @@_;
	my ($name, $libspec, $pattern, $def)  = split /\:/, $args;
	my $self = bless { libspec => $libspec, pattern => $pattern, 
	    def => $def }, $class;
	# very old packages still work
	if ($name =~ m|/|) {
		$self->{pkgpath} = $name;
	} else {
		$self->{name} = $name;
	}
	return $self;
}

sub stringize($)
{
	my $self = $_[0];
	return (defined $self->{name} ? $self->{name} : $self->{pkgpath}).
	    ':'.$self->{libspec}.':'.$self->{pattern}.':'.$self->{def};
}

package OpenBSD::PackingElement::Name;
use File::Spec;
our @@ISA=qw(OpenBSD::PackingElement::Unique);

__PACKAGE__->setKeyword('name');
sub keyword() { "name" }
sub category() { "name" }

package OpenBSD::PackingElement::LocalBase;
our @@ISA=qw(OpenBSD::PackingElement::Unique);

__PACKAGE__->setKeyword('localbase');
sub keyword() { "localbase" }
sub category() { "localbase" }
@


1.42
log
@unbreak pure comments, handle @@option at new level.
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.41 2004/10/05 19:35:49 espie Exp $
d915 3
d919 1
a919 1
our @@ISA=qw(OpenBSD::PackingElement::FileObject);
d925 1
a925 1
our @@ISA=qw(OpenBSD::PackingElement::FileObject);
@


1.41
log
@Let DirBase inherit from FileObject
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.40 2004/10/05 18:47:15 espie Exp $
d505 1
a505 1
		return $class->SUPER::add(@@args);
d574 1
a574 1
sub add
d576 1
a576 1
	my ($class, $plist, @@args) = @@_;
d578 1
a578 2
		shift;
		return OpenBSD::PackingElement::NoDefaultConflict->add($plist);
d580 1
a580 2
		shift;
		return OpenBSD::PackingElement::ManualInstallation->add($plist);
@


1.40
log
@mark stuff as annotations. don't create ignore objects, since they are
proper annotations.

ditch multiple inheritance for CVSTag, like ExtraInfo, since these
being comments is more an historic artefact than anything else.
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.39 2004/10/05 10:21:42 espie Exp $
d924 2
d933 1
a933 1
our @@ISA=qw(OpenBSD::PackingElement::DirBase OpenBSD::PackingElement::FileObject);
@


1.39
log
@derive ::PkgCfl from ::Conflict
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.38 2004/10/05 10:20:40 espie Exp $
d264 1
d266 1
d473 1
a473 1
our @@ISA=qw(OpenBSD::PackingElement);
d476 1
a476 1
sub add_object
d478 1
a478 1
	my ($plist, $self) = @@_;
d485 1
a485 1
our @@ISA=qw(OpenBSD::PackingElement);
d495 1
a495 1
		OpenBSD::PackingElement::CVSTag->add($plist, @@args);
d500 1
a500 1
		OpenBSD::PackingElement::ExtraInfo->add($plist, $1, $2, $3);
d505 1
a505 2
		my $self = $class->new(@@args);
		return $self->add_object($plist);
d509 7
d517 1
a517 1
our @@ISA=qw(OpenBSD::PackingElement);
a528 5
package OpenBSD::PackingElement::CVSTag;
our @@ISA=qw(OpenBSD::PackingElement::Meta OpenBSD::PackingElement::Comment);

sub category() { 'cvstags'}

d530 1
a530 1
our @@ISA=qw(OpenBSD::PackingElement);
d538 1
a538 1
	$plist->{state}->{lastfile}->make_symlink($');
d543 1
a543 1
our @@ISA=qw(OpenBSD::PackingElement);
d551 1
a551 1
	$plist->{state}->{lastfile}->make_hardlink($');
d556 1
a556 1
our @@ISA=qw(OpenBSD::PackingElement);
d569 1
a569 1
our @@ISA=qw(OpenBSD::PackingElement);
a627 1

@


1.38
log
@basic destate for ::FileObject, derive ::Exec, ::Unexec, ::Extraunexec
from ::ExeclikeAction
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.37 2004/10/05 10:12:22 espie Exp $
a646 7
package OpenBSD::PackingElement::PkgConflict;
our @@ISA=qw(OpenBSD::PackingElement::Meta);

__PACKAGE__->setKeyword('pkgcfl');
sub keyword() { "pkgcfl" }
sub category() { "pkgcfl" }

d654 6
@


1.37
log
@unique objects only need to override add_object.
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.36 2004/10/05 10:09:34 espie Exp $
d227 6
d288 1
a288 1
	$self->compute_fullname($state);
d888 1
a888 1
package OpenBSD::PackingElement::Exec;
a890 4
__PACKAGE__->setKeyword('exec');

sub keyword() { "exec" }

d897 7
d905 1
a905 1
our @@ISA=qw(OpenBSD::PackingElement::Action);
a909 6
sub destate
{
	my ($self, $state) = @@_;
	$self->{expanded} = $self->expand($self->{name}, $state);
}

d911 1
a911 1
our @@ISA=qw(OpenBSD::PackingElement::Action);
a915 6
sub destate
{
	my ($self, $state) = @@_;
	$self->{expanded} = $self->expand($self->{name}, $state);
}

a921 6
sub destate
{
	my ($self, $state) = @@_;
	$self->compute_fullname($state);
}

d938 1
a938 1
	$self->compute_fullname($state);
@


1.36
log
@fullname and mode stuff only concerns ::Object
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.35 2004/10/05 10:06:14 espie Exp $
d242 1
a242 1
sub add 
d244 1
a244 1
	my ($class, $plist, @@args) = @@_;
a245 1
	my $self = $class->new(@@args);
@


1.35
log
@Only ::FileObject need to do the dirclass test, other objects don't
become dirs/
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.34 2004/10/05 10:01:17 espie Exp $
d134 16
d168 5
a208 21
sub IsFile() { 0 }

sub NoDuplicateNames() { 0 }

sub fullname($)
{
	return $_[0]->{fullname};
}

# Basic class hierarchy

# various stuff that's only linked to objects before/after them
# this class doesn't have real objects: no valid new nor clone...
package OpenBSD::PackingElement::Annotation;
our @@ISA=qw(OpenBSD::PackingElement);
sub new { die "Can't create annotation objects" }

# concrete objects
package OpenBSD::PackingElement::Object;
our @@ISA=qw(OpenBSD::PackingElement);

@


1.34
log
@NoDuplicateNames = 1 is a ::FileObject property
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.33 2004/10/04 12:30:54 espie Exp $
d70 1
a70 5
	if ($args =~ m|/+$| and defined $class->dirclass()) {
		bless { name => $` }, $class->dirclass();
	} else {
		bless { name => $args }, $class;
	}
a81 2
sub dirclass() { undef }

d214 12
@


1.33
log
@link FileObject, State, Action.
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.32 2004/10/04 12:23:58 espie Exp $
d219 2
a318 1
sub NoDuplicateNames() { 1 }
a352 1
sub NoDuplicateNames() { 1 }
a925 2
sub NoDuplicateNames() { 1 }

a931 2

sub NoDuplicateNames() { 1 }
@


1.32
log
@link `Meta/Unique' class hierarchy. Ditch some common code.
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.31 2004/10/04 12:16:31 espie Exp $
d250 1
a250 1
our @@ISA=qw(OpenBSD::PackingElement);
d350 1
a350 1
our @@ISA=qw(OpenBSD::PackingElement);
d511 1
a511 1
our @@ISA=qw(OpenBSD::PackingElement OpenBSD::PackingElement::Comment);
d680 1
a680 1
our @@ISA=qw(OpenBSD::PackingElement);
d737 2
a738 1
our @@ISA=qw(OpenBSD::PackingElement);
d814 1
a814 1
our @@ISA=qw(OpenBSD::PackingElement);
d827 1
a827 1
our @@ISA=qw(OpenBSD::PackingElement);
d844 1
a844 1
our @@ISA=qw(OpenBSD::PackingElement);
d861 1
a861 1
our @@ISA=qw(OpenBSD::PackingElement);
d878 1
a878 1
our @@ISA=qw(OpenBSD::PackingElement);
d891 1
a891 1
our @@ISA=qw(OpenBSD::PackingElement);
d903 1
a903 1
our @@ISA=qw(OpenBSD::PackingElement);
d915 1
a915 1
our @@ISA=qw(OpenBSD::PackingElement);
d938 1
a938 1
our @@ISA=qw(OpenBSD::PackingElement::DirBase OpenBSD::PackingElement);
d1026 1
d1033 1
a1033 1
our @@ISA=qw(OpenBSD::PackingElement);
@


1.31
log
@basic class hierarchy to cut up packing-list items into better groups.
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.30 2004/10/04 12:09:07 espie Exp $
d215 1
d231 13
d321 1
d351 1
d367 1
d377 1
d384 1
d390 1
d473 1
d499 1
d512 1
d517 1
d530 1
d543 1
d556 1
d576 1
d593 1
d610 1
a610 1
our @@ISA=qw(OpenBSD::PackingElement);
a621 8
sub add
{
	my ($class, $plist, @@args) = @@_;
	my $self = $class->new(@@args);
	$plist->addunique($self);
	return $self;
}

d630 1
a630 1
our @@ISA=qw(OpenBSD::PackingElement);
d637 1
a637 1
our @@ISA=qw(OpenBSD::PackingElement);
d644 1
a644 1
our @@ISA=qw(OpenBSD::PackingElement);
d652 1
a652 2

our @@ISA=qw(OpenBSD::PackingElement);
d768 1
a768 2

our @@ISA=qw(OpenBSD::PackingElement);
a795 13
package OpenBSD::PackingElement::Unique;
our @@ISA=qw(OpenBSD::PackingElement);

sub add 
{
	my ($class, $plist, @@args) = @@_;

	my $self = $class->new(@@args);
	$self->destate($plist->{state});
	$plist->addunique($self);
	return $self;
}

d798 1
a798 1
our @@ISA=qw(OpenBSD::PackingElement::Unique OpenBSD::PackingElement);
d805 1
a805 1
our @@ISA=qw(OpenBSD::PackingElement::Unique OpenBSD::PackingElement);
d1101 1
@


1.30
log
@fix bogus indentation
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.29 2004/09/21 22:17:49 espie Exp $
d203 31
a234 1

@


1.29
log
@@@newuser/@@newgroup initial support:
- groups category and users category that get handled first, so that
those groups/users can be used for other files.
- : separated fields, for easy parsing. Mostly matching useradd groupadd.
- ! for mandatory values.
Missing pkg_delete -c support for now.

okay naddy@@, pvalchev@@, millert@@
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.28 2004/09/20 10:36:39 espie Exp $
d46 2
a47 2
		    print STDERR "Unknown element: \@@$cmd $args\n";
		    exit(1);
d50 1
a50 1
			OpenBSD::PackingElement::File->add(@@_, $_);
d73 1
a73 1
	    bless { name => $args }, $class;
@


1.28
log
@error out for pkgcfl in pkg_create, but don't warn if it's found in
existing packages or installed packages. Too much noise for now.
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.27 2004/09/20 08:53:53 espie Exp $
d627 88
@


1.27
log
@old pkgcfl is dead.
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.26 2004/09/18 13:28:19 espie Exp $
d584 7
@


1.26
log
@framework to be able to distinguish packages installed manually (and thus
wanted by the user) from packages installed automatically to satisfy a
dependency.
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.25 2004/09/18 08:14:40 espie Exp $
a583 7

package OpenBSD::PackingElement::PkgConflict;
our @@ISA=qw(OpenBSD::PackingElement);

__PACKAGE__->setKeyword('pkgcfl');
sub keyword() { "pkgcfl" }
sub category() { "pkgcfl" }
@


1.25
log
@new-style conflicts that respect pkgspec.
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.24 2004/09/15 17:10:09 espie Exp $
d509 3
d525 16
@


1.24
log
@shell keyword...
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.23 2004/09/14 23:04:10 espie Exp $
d572 7
@


1.23
log
@add support for info directories.
more prototypes.
use Error module for system calls.
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.22 2004/08/11 09:57:50 espie Exp $
d333 5
@


1.22
log
@allow for a fonts.dir.dist, for cases where mkfontdir doesn't know what to do.
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.21 2004/08/10 11:53:27 espie Exp $
d332 1
a332 1

d800 5
d809 1
a809 1
sub needs_keyword { 1 }
d846 1
a846 1
		require File::Copy;
d849 1
a849 1
		File::Copy::copy("$dirname/fonts.dir.dist", "$dirname/fonts.dir");
d857 2
d861 1
a861 1
		eval { system("/usr/X11R6/bin/mkfontdir", @@l); };
d863 1
a863 1
		eval { system("/usr/X11R6/bin/fc-cache", @@l); };
d872 1
a872 1
sub needs_keyword { 1 }
@


1.21
log
@cosmetic tweak: ensure all dirs always get exactly one / at the end.
cosmetic tweak: do not show a space after a keyword without args.
dir support reworked: keep clones() of dir objects, and call cleanup/reload
routines at end.

@@mandir/fontdir support:
both mandir and fontdir remove extra files on delete.
@@fontdir creates alias files, runs mkfontdir, and uses fc-cache.
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.20 2004/08/07 17:27:26 espie Exp $
d837 11
d855 1
@


1.20
log
@use chroot DESTDIR ldconfig in DESTDIR case.
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.19 2004/08/06 10:23:45 espie Exp $
d70 1
a70 1
	if ($args =~ m|/$| and defined $class->dirclass()) {
d113 1
d115 2
a116 1
		print $fh "\@@", $self->keyword(), " ", $self->stringize(), "\n";
d118 1
a118 1
		print $fh $self->stringize(), "\n";
d126 1
d128 2
a129 1
		return "\@@".$self->keyword()." ".$self->stringize();
d131 1
a131 1
		return $self->stringize();
d775 2
a776 1
	return $_[0]->{name}."/";
d805 43
d854 1
@


1.19
log
@@@lib shared library marker.

- runs ldconfig to find out search library path.
- if library is in path, mark directory for updating cache.
- run ldconfig when needed, e.g., right before executing something that
might depend on the library.

Doesn't handle destdir case yet.
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.18 2004/08/06 07:51:17 espie Exp $
d358 1
a358 1
our $ldconfig = '/sbin/ldconfig';
d375 4
a378 1
		open my $fh, "-|", $ldconfig, "-r";
@


1.18
log
@unified headers, switch to smaller copyright notice.
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.17 2004/08/05 23:36:40 espie Exp $
d22 3
d346 48
@


1.17
log
@refactor classes in PackingElement to share more code.
- all files go through FileBase, all directories go through DirBase.
- dirclass() is used to switch classes based on final /, so that
@@sample, @@extra, and @@file  all take directories as well.
- set NoDuplicateNames() more thoroughly.
- make sure all no-default-conflict objects are correct.

compute_fullname() checks for absolute paths, allowed for @@sample and
@@extra.

lastfile only gets set for actual files.

special names like INSTALL are only checked for normal files.

add a CVSTag class for @@comment $OpenBSD$, so that these get sorted first.

Changes for make-plist rewrite:

clone() method that can create copies of all hash objects, to specialize
if needed.

add_object() method so that add() is now new() followed by add_object()
for most objects (useful for cloned objects).

Check that plist has a name in pkg_create, allowing PackingList to write
unnamed plists.
@
text
@d1 2
a2 1
# $OpenBSD: PackingElement.pm,v 1.16 2004/08/03 12:29:45 espie Exp $
d4 17
a20 22
# Copyright (c) 2003 Marc Espie.
# 
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
# 
# THIS SOFTWARE IS PROVIDED BY THE OPENBSD PROJECT AND CONTRIBUTORS
# ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
# A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OPENBSD
# PROJECT OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
a24 4

use strict;
use warnings;
use OpenBSD::PackageInfo;
@


1.16
log
@Support @@sample, tested by fries@@.
@@mandir and @@fontdir keywords recognition.
@
text
@d1 1
a1 1
# $OpenBSD: PackingElement.pm,v 1.15 2004/08/02 12:12:36 espie Exp $
a54 3
		if ($_ =~ m|/$|) {
			OpenBSD::PackingElement::Dir->add(@@_, $`);
		} else {
a55 1
		}
d59 2
a60 1
sub setKeyword {
d75 5
a79 1
	bless { name => $args }, $class;
d82 11
d97 8
d110 1
a110 3
	$self->destate($plist->{state});
	$plist->add2list($self);
	return $self;
d113 1
a113 3
sub keyword() { return; }

sub needs_keyword() { 1; }
d130 1
a130 1
		return "\@@".$self->keyword()." ".$self->stringize()."\n";
d132 1
a132 1
		return $self->stringize()."\n";
d143 1
a143 1
	my ($self, $state) = @@_;
d146 10
a155 3
	my $fullname = $self->{fullname} = 
	    File::Spec->canonpath(File::Spec->catfile($state->{cwd}, $self->{name}));
	$state->{lastfile} = $self;
d204 3
a206 1
package OpenBSD::PackingElement::File;
a208 9
use OpenBSD::PackageInfo qw(is_info_name);
__PACKAGE__->setKeyword('file');

sub needs_keyword
{
	my $self = shift;
	return $self->stringize() =~ m/\^@@/;
}

d233 1
a244 16
sub add
{
	my ($class, $plist, @@args) = @@_;

	my $self = $class->new(@@args);
	$self->destate($plist->{state});
	my $j = is_info_name($self->fullname());
	if ($j) {
		bless $self, "OpenBSD::PackingElement::$j";
		$plist->addunique($self);
	} else {
		$plist->add2list($self);
	}
	return $self;
}

d276 29
d307 1
d314 12
d330 1
a330 1
our @@ISA=qw(OpenBSD::PackingElement::File);
a333 1
sub needs_keyword { 1 }
d336 1
a336 1
our @@ISA=qw(OpenBSD::PackingElement::File);
a338 1
sub needs_keyword { 1 }
d358 1
a358 1
sub add
d360 1
a360 1
	my ($class, $plist, @@args) = @@_;
d375 3
a377 1
	if ($args[0] =~ m/^MD5:\s*/) {
d387 1
a387 3
		$self->destate($plist->{state});
		$plist->add2list($self);
		return $self;
d403 4
d453 1
a453 1
		return OpenBSD::PackingElement::NoDefaultConflict->add(@@_);
d464 11
a707 4
package OpenBSD::PackingElement::Dirs;

sub NoDuplicateNames() { 1 }

d709 1
a709 1
our @@ISA=qw(OpenBSD::PackingElement::Dirs OpenBSD::PackingElement);
d720 10
d731 1
a731 1
our @@ISA=qw(OpenBSD::PackingElement::Dirs OpenBSD::PackingElement);
d734 1
a748 5
sub stringize($)
{
	return $_[0]->{name}."/";
}

d770 1
a770 1
	$self->compute_fullname($state);
d773 5
d791 1
a791 1
	&OpenBSD::PackingElement::File::write;
@


1.15
log
@@@man type file for manpages.
@
text
@d1 1
a1 1
# $OpenBSD: PackingElement.pm,v 1.14 2004/08/02 12:08:25 espie Exp $
d275 11
d690 12
@


1.14
log
@Reuse first component of @@newdepends, @@libdepends to contain
a PKG_PATH (easy backward compatibility: is there a slash ?)

That's missing info to enable pkg_add to launch package building
in the ports tree as an alternate source of binary packages.
@
text
@d1 1
a1 1
# $OpenBSD: PackingElement.pm,v 1.13 2004/07/22 22:23:26 espie Exp $
d281 20
@


1.13
log
@use
directory/
instead of
@@dir directory
okay naddy@@
@
text
@d1 1
a1 1
# $OpenBSD: PackingElement.pm,v 1.12 2004/07/20 18:58:41 espie Exp $
d444 8
a451 1
	bless { name => $name, pattern => $pattern, def => $def }, $class;
d457 2
a458 1
	return $self->{name}.':'.$self->{pattern}.':'.$self->{def};
d473 1
a473 1
	bless { name => $name, libspec => $libspec, pattern => $pattern, 
d475 7
d487 2
a488 2
	return $self->{name}.':'.$self->{libspec}.':'.$self->{pattern}.
	    ':'.$self->{def};
@


1.12
log
@support for gnu-info, with @@info keyword.
- modify pkg_create so that it will look for info-[0-9]+ and add them
to the packing-list.
- deal with installing the info file/de-installing it at pkg_add/pkg_delete
time.

tested by naddy@@
@
text
@d1 1
a1 1
# $OpenBSD: PackingElement.pm,v 1.11 2004/07/14 10:44:03 espie Exp $
d55 5
a59 1
		OpenBSD::PackingElement::File->add(@@_, $_);
d97 2
d102 16
a117 1
	print $fh "\@@", $self->keyword(), " ", $self->stringize(), "\n";
d198 1
a198 5
	if ($self->needs_keyword()) {
		$self->SUPER::write($fh);
	} else {
		print $fh $self->stringize(), "\n";
	}
a625 1
sub keyword() { "dir" }
d632 11
@


1.11
log
@Rework @@dirrm: keep them all, and remove them at the end of pkg_delete.
Add @@dir, more powerful than @@dirrm, so that we can get rid of those
pesky @@exec mkdir -p.

okay naddy@@
@
text
@d1 1
a1 1
# $OpenBSD: PackingElement.pm,v 1.10 2004/07/13 00:35:39 espie Exp $
d153 2
d166 6
d177 1
a177 1
	if ($self->stringize() =~ m/^\@@/) {
d256 9
d591 2
d638 2
@


1.10
log
@at pkg_create time, mark hard links with @@link, and symlinks with @@symlink,
instead of computing size and md5.
okay naddy@@, sturm@@
@
text
@d1 1
a1 1
# $OpenBSD: PackingElement.pm,v 1.9 2004/06/21 16:33:45 espie Exp $
d115 14
d192 1
a192 9
	if (defined $state->{mode}) {
		$self->{mode} = $state->{mode};
	}
	if (defined $state->{owner}) {
		$self->{owner} = $state->{owner};
	}
	if (defined $state->{group}) {
		$self->{group} = $state->{group};
	}
d572 2
d575 1
a575 1
our @@ISA=qw(OpenBSD::PackingElement);
d584 13
@


1.9
log
@support for old stuff in pkg_info/pkg_delete, e.g., @@src
prompted by miod@@, okay miod@@ millert@@.
@
text
@d1 1
a1 1
# $OpenBSD: PackingElement.pm,v 1.8 2004/03/30 08:53:35 espie Exp $
d166 6
d225 15
d288 24
@


1.8
log
@do not allow non-sensible stuff in packing-lists.
@
text
@d1 1
a1 1
# $OpenBSD: PackingElement.pm,v 1.7 2004/01/28 22:12:01 espie Exp $
d36 1
d47 3
d62 5
@


1.7
log
@Add -L to record/enforce localbase.
Okay sturm@@
@
text
@d1 1
a1 1
# $OpenBSD: PackingElement.pm,v 1.6 2004/01/22 21:11:43 espie Exp $
d47 2
a48 1
		    OpenBSD::PackingElement::Other->add(@@_, "\@@$cmd $args");
a210 3

package OpenBSD::PackingElement::Other;
our @@ISA=qw(OpenBSD::PackingElement);
@


1.6
log
@document/activate @@arch. Fix list handling.
@
text
@d1 1
a1 1
# $OpenBSD: PackingElement.pm,v 1.5 2003/12/26 16:44:31 espie Exp $
d405 7
a423 3
	if (!defined $state->{prefix}) {
		$state->{prefix} = $state->{cwd};
	}
@


1.5
log
@Allow storing of `arch' annotations inside packages.
Factor common method code in write, keep variations in stringize.
@
text
@d1 1
a1 1
# $OpenBSD: PackingElement.pm,v 1.4 2003/11/16 11:49:15 espie Exp $
d594 1
a594 1
	bless { arches => @@arches }, $class;
d600 1
a600 1
	return join(',',$self->{arches});
@


1.4
log
@Record no checksum in generated packing-list.
Thx to sturm@@ for finding out something was wrong.
@
text
@d1 1
a1 1
# $OpenBSD: PackingElement.pm,v 1.3 2003/11/06 17:46:35 espie Exp $
d86 6
a91 1
	print $fh "\@@", $self->keyword()," ", $self->{name}, "\n";
d145 1
a145 1
	if ($self->{name} =~ m/^\@@/) {
d148 1
a148 1
		print $fh $self->{name}, "\n";
d300 1
d318 1
a318 1
sub write
d320 3
a322 4
	my ($self, $fh) = @@_;
	print  $fh "\@@comment subdir=", $self->{subdir}, 
	    " cdrom=", $self->{cdrom}, 
	    " ftp=", $self->{ftp}, "\n";
d346 1
d355 1
a355 1
sub write
d357 2
a358 3
	my ($self, $fh) = @@_;
	print $fh "\@@newdepend ", $self->{name}, ':', 
	    $self->{pattern}, ':', $self->{def}, "\n";
d367 1
d377 1
a377 1
sub write
d379 3
a381 4
	my ($self, $fh) = @@_;
	print $fh "\@@libdepend ", $self->{name}, ':', 
	    $self->{libspec}, ':',
	    $self->{pattern}, ':', $self->{def}, "\n";
d583 19
@


1.3
log
@Implement discovery of a `packing-list' prefix, e.g., the first @@cwd
present in the packing-list (necessary for libdepends checking).
@
text
@d1 1
a1 1
# $OpenBSD: PackingElement.pm,v 1.2 2003/10/31 17:43:20 espie Exp $
d139 1
@


1.2
log
@upward compatible change: let md5 register as @@md5 (still grok @@comment MD5
though), and add @@size to denote file sizes in created package.

okay naddy@@
@
text
@d1 1
a1 1
# $OpenBSD: PackingElement.pm,v 1.1.1.1 2003/10/16 17:43:34 espie Exp $
d411 3
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
# $OpenBSD: PackingElement.pm,v 1.1.1.1 2003/10/16 17:16:30 espie Exp $
d145 4
a148 1
		print $fh "\@@comment MD5:", $self->{md5}, "\n";
d197 6
d243 24
@


1.1.1.1
log
@new import of my pkgtools, after a slight naming disagreement with the
Upper Management...
@
text
@@
