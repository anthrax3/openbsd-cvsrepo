head	1.38;
access;
symbols
	OPENBSD_6_0:1.35.0.6
	OPENBSD_6_0_BASE:1.35
	OPENBSD_5_9:1.35.0.2
	OPENBSD_5_9_BASE:1.35
	OPENBSD_5_8:1.34.0.6
	OPENBSD_5_8_BASE:1.34
	OPENBSD_5_7:1.34.0.2
	OPENBSD_5_7_BASE:1.34
	OPENBSD_5_6:1.33.0.4
	OPENBSD_5_6_BASE:1.33
	OPENBSD_5_5:1.32.0.4
	OPENBSD_5_5_BASE:1.32
	OPENBSD_5_4:1.30.0.4
	OPENBSD_5_4_BASE:1.30
	OPENBSD_5_3:1.30.0.2
	OPENBSD_5_3_BASE:1.30
	OPENBSD_5_2:1.29.0.4
	OPENBSD_5_2_BASE:1.29
	OPENBSD_5_1_BASE:1.29
	OPENBSD_5_1:1.29.0.2
	OPENBSD_5_0:1.20.0.2
	OPENBSD_5_0_BASE:1.20
	OPENBSD_4_9:1.11.0.2
	OPENBSD_4_9_BASE:1.11
	OPENBSD_4_8:1.8.0.2
	OPENBSD_4_8_BASE:1.8;
locks; strict;
comment	@# @;


1.38
date	2017.03.13.11.36.23;	author espie;	state Exp;
branches;
next	1.37;
commitid	0Cccwq7xYZZsBTzT;

1.37
date	2017.02.27.14.03.52;	author espie;	state Exp;
branches;
next	1.36;
commitid	c3kgqPdp6tlunPOd;

1.36
date	2017.01.25.14.12.33;	author espie;	state Exp;
branches;
next	1.35;
commitid	HZaoIcNEcg8tNVfP;

1.35
date	2015.10.07.17.52.38;	author jmc;	state Exp;
branches;
next	1.34;
commitid	wtnyUwU0yuhbcppY;

1.34
date	2014.11.29.10.42.51;	author espie;	state Exp;
branches;
next	1.33;
commitid	XiRgNGt76qJ9BWZO;

1.33
date	2014.07.12.19.50.43;	author espie;	state Exp;
branches;
next	1.32;
commitid	QzYY7ILxCL3CoU1A;

1.32
date	2014.02.11.08.58.34;	author sthen;	state Exp;
branches;
next	1.31;

1.31
date	2014.02.08.16.21.54;	author espie;	state Exp;
branches;
next	1.30;

1.30
date	2013.01.07.10.50.41;	author espie;	state Exp;
branches;
next	1.29;

1.29
date	2011.12.02.16.39.10;	author espie;	state Exp;
branches;
next	1.28;

1.28
date	2011.12.02.16.01.17;	author jmc;	state Exp;
branches;
next	1.27;

1.27
date	2011.12.02.12.00.32;	author espie;	state Exp;
branches;
next	1.26;

1.26
date	2011.11.25.23.58.40;	author espie;	state Exp;
branches;
next	1.25;

1.25
date	2011.11.25.09.25.59;	author espie;	state Exp;
branches;
next	1.24;

1.24
date	2011.08.26.08.46.10;	author espie;	state Exp;
branches;
next	1.23;

1.23
date	2011.08.23.10.32.27;	author espie;	state Exp;
branches;
next	1.22;

1.22
date	2011.08.18.07.55.26;	author espie;	state Exp;
branches;
next	1.21;

1.21
date	2011.08.17.10.48.27;	author espie;	state Exp;
branches;
next	1.20;

1.20
date	2011.07.19.05.58.33;	author espie;	state Exp;
branches;
next	1.19;

1.19
date	2011.07.18.19.19.08;	author espie;	state Exp;
branches;
next	1.18;

1.18
date	2011.07.17.13.16.15;	author espie;	state Exp;
branches;
next	1.17;

1.17
date	2011.07.14.11.31.20;	author espie;	state Exp;
branches;
next	1.16;

1.16
date	2011.07.13.13.01.13;	author espie;	state Exp;
branches;
next	1.15;

1.15
date	2011.07.13.12.32.15;	author espie;	state Exp;
branches;
next	1.14;

1.14
date	2011.07.12.10.56.03;	author espie;	state Exp;
branches;
next	1.13;

1.13
date	2011.07.12.10.51.28;	author espie;	state Exp;
branches;
next	1.12;

1.12
date	2011.07.12.10.30.29;	author espie;	state Exp;
branches;
next	1.11;

1.11
date	2010.12.24.09.04.14;	author espie;	state Exp;
branches;
next	1.10;

1.10
date	2010.12.13.12.14.38;	author espie;	state Exp;
branches;
next	1.9;

1.9
date	2010.10.27.14.35.56;	author espie;	state Exp;
branches;
next	1.8;

1.8
date	2010.06.30.10.51.04;	author espie;	state Exp;
branches;
next	1.7;

1.7
date	2010.06.30.10.41.42;	author espie;	state Exp;
branches;
next	1.6;

1.6
date	2010.06.25.11.12.14;	author espie;	state Exp;
branches;
next	1.5;

1.5
date	2010.06.15.08.21.05;	author espie;	state Exp;
branches;
next	1.4;

1.4
date	2010.06.11.09.53.06;	author espie;	state Exp;
branches;
next	1.3;

1.3
date	2010.06.09.08.13.19;	author espie;	state Exp;
branches;
next	1.2;

1.2
date	2010.06.09.07.26.01;	author espie;	state Exp;
branches;
next	1.1;

1.1
date	2010.06.04.13.19.39;	author espie;	state Exp;
branches;
next	;


desc
@@


1.38
log
@fix usage order, as reminded by jmc@@
@
text
@#!/usr/bin/perl
# ex:ts=8 sw=4:
# $OpenBSD: PkgDelete.pm,v 1.37 2017/02/27 14:03:52 espie Exp $
#
# Copyright (c) 2003-2010 Marc Espie <espie@@openbsd.org>
#
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

use strict;
use warnings;

use OpenBSD::AddDelete;


package OpenBSD::PkgDelete::Tracker;

sub new
{
	my $class = shift;
	bless {}, $class;
}

sub sets_todo
{
	my ($self, $offset) = @@_;
	return sprintf("%u/%u", (scalar keys %{$self->{done}})-$offset,
		scalar keys %{$self->{total}});
}

sub handle_set
{
	my ($self, $set) = @@_;
	$self->{total}{$set} = 1;
	if ($set->{finished}) {
		$self->{done}{$set} = 1;
	}
}

sub todo
{
	my ($self, @@list) = @@_;
	for my $set (@@list) {
		for my $pkgname ($set->older_names) {
			$self->{todo}{$pkgname} = $set;
		}
		$self->handle_set($set);
	}
}


sub done
{
	my ($self, $set) = @@_;
	$set->{finished} = 1;
	for my $pkgname ($set->older_names) {
		delete $self->{todo}{$pkgname};
	}
	$self->handle_set($set);
}

sub cant
{
	&done;
}
sub find
{
	my ($self, $pkgname) = @@_;
	return $self->{todo}{$pkgname};
}



package OpenBSD::PkgDelete::State;
our @@ISA = qw(OpenBSD::AddDelete::State);

sub new
{
	my $class = shift;
	my $self = $class->SUPER::new(@@_);
	$self->{tracker} = OpenBSD::PkgDelete::Tracker->new;
	return $self;
}

sub tracker
{
	my $self = shift;
	return $self->{tracker};
}

sub handle_options
{
	my $state = shift;
	$state->SUPER::handle_options('X',
	    '[-acimnqsVvXx] [-B pkg-destdir] [-D name[=value]] [pkg-name ...]');

	my $base = $state->opt('B') // $ENV{'PKG_DESTDIR'} // '';
	if ($base ne '') {
		$base.='/' unless $base =~ m/\/$/o;
	}
	$ENV{'PKG_DESTDIR'} = $base;

	$state->{destdir} = $base;
	if ($base eq '') {
	    $state->{destdirname} = '';
	} else {
	    $state->{destdirname} = '${PKG_DESTDIR}';
	}
	$state->{exclude} = $state->opt('X');
}

sub stem2location
{
	my ($self, $locator, $name, $state) = @@_;
	require OpenBSD::Search;
	my $l = $locator->match_locations(OpenBSD::Search::Stem->new($name));
	if (@@$l > 1 && !$state->defines('allversions')) {
		$l = OpenBSD::Search::FilterLocation->keep_most_recent->filter_locations($l);
	}
	return $state->choose_location($name, $l);
}

sub deleteset
{
	my $self = shift;
	require OpenBSD::UpdateSet;

	return OpenBSD::DeleteSet->new($self);
}

sub deleteset_from_location
{
	my ($self, $location) = @@_;
	return $self->deleteset->add_older(OpenBSD::Handle->from_location($location));
}

package OpenBSD::DeleteSet;
sub setup_header
{
	my ($set, $state, $handle) = @@_;
	my $header = $state->deptree_header($set);
	if (defined $handle) {
		$header .= $handle->pkgname;
	} else {
		$header .= $set->print;
	}
	if (!$state->progress->set_header($header)) {
		return unless $state->verbose;
		$header = "Deleting $header";
		if (defined $state->{lastheader} &&
		    $header eq $state->{lastheader}) {
			return;
		}
		$state->{lastheader} = $header;
		$state->print("#1", $header);
		$state->print("(pretending) ") if $state->{not};
		$state->print("\n");
	}
}

package OpenBSD::PkgDelete;
our @@ISA = qw(OpenBSD::AddDelete);

use OpenBSD::PackingList;
use OpenBSD::RequiredBy;
use OpenBSD::Delete;
use OpenBSD::PackageInfo;
use OpenBSD::UpdateSet;
use OpenBSD::Handle;


sub add_location
{
	my ($self, $state, $l) = @@_;
	push(@@{$state->{setlist}},
	    $state->deleteset_from_location($l));
}

sub create_locations
{
	my ($state, @@l) = @@_;
	my $inst = $state->repo->installed;
	my $result = [];
	for my $name (@@l) {
		my $l = $inst->find($name, $state->{arch});
		if (!defined $l) {
			$state->errsay("Can't find #1 in installed packages",
			    $name);
			$state->{bad}++;
		} else {
			push(@@$result, $state->deleteset_from_location($l));
		}
	}
	return $result;
}

sub process_parameters
{
	my ($self, $state) = @@_;

	my $inst = $state->repo->installed;

	if (@@ARGV == 0) {
		if (!($state->{automatic} || $state->{exclude})) {
			$state->fatal("No packages to delete");
		}
	} else {
		for my $pkgname (@@ARGV) {
			my $l;

			if (OpenBSD::PackageName::is_stem($pkgname)) {
				$l = $state->stem2location($inst, $pkgname,
				    $state);
			} else {
				$l = $inst->find($pkgname);
			}
			if (!defined $l) {
				unless ($state->{exclude}) {
					$state->say("Problem finding #1", 
					    $pkgname);
					$state->{bad}++;
				}
			} else {
				$self->add_location($state, $l);
			}
		}
	}
}

sub finish_display
{
}

sub really_remove
{
	my ($set, $state) = @@_;
	if ($state->{not}) {
		$state->status->what("Pretending to delete");
	} else {
		$state->status->what("Deleting");
	}
	$set->setup_header($state);
	for my $pkgname ($set->older_names) {
		$set->setup_header($state, $set->{older}{$pkgname});
		$state->log->set_context('-'.$pkgname);
		OpenBSD::Delete::delete_package($pkgname, $state);
	}
	$state->progress->next($state->ntogo);
	$state->syslog("Removed #1", $set->print);
}

sub delete_dependencies
{
	my $state = shift;

	if ($state->defines("dependencies")) {
		return 1;
	}
	return $state->confirm("Delete them as well", 0);
}

sub fix_bad_dependencies
{
	my $state = shift;

	if ($state->defines("baddepend")) {
		return 1;
	}
	return $state->confirm("Delete anyway", 0);
}

sub process_set
{
	my ($self, $set, $state) = @@_;

	my $todo = {};
	my $bad = {};
    	for my $pkgname ($set->older_names) {
		unless (is_installed($pkgname)) {
			$state->errsay("#1 was not installed", $pkgname);
			$set->{finished} = 1;
			$set->cleanup(OpenBSD::Handle::NOT_FOUND);
			$state->{bad}++;
			return ();
		}
		my $r = OpenBSD::RequiredBy->new($pkgname);
		for my $pkg ($r->list) {
			next if $set->{older}->{$pkg};
			my $f = $state->tracker->find($pkg);
			if (defined $f) {
				$todo->{$pkg} = $f;
			} else {
				$bad->{$pkg} = 1;
			}
		}
	}
	if (keys %$bad > 0) {
		my $bad2 = {};
		for my $pkg (keys %$bad) {
			if (!is_installed($pkg)) {
				$bad2->{$pkg} = 1;
			}
		}
		if (keys %$bad2 > 0) {
			$state->errsay("#1 depends on non-existant #2",
			    $set->print, join(' ', sort keys %$bad2));
			if (fix_bad_dependencies($state)) {
				for my $pkg (keys %$bad2) {
					delete $bad->{$pkg};
				}
			}
		}
	}
	if (keys %$bad > 0) {
		if (!$state->{do_automatic} || $state->verbose) {
			$state->errsay("can't delete #1 without deleting #2",
			    $set->print, join(' ', sort keys %$bad));
		}
		if (!$state->{do_automatic}) {
			if (delete_dependencies($state)) {
			    	my $l = create_locations($state, keys %$bad);
				$state->tracker->todo(@@$l);
				return (@@$l, $set);
			}
			$state->{bad}++;
	    	}
		$set->cleanup(OpenBSD::Handle::CANT_DELETE);
		$state->tracker->cant($set);
		return ();
	}
	# XXX this si where we should detect loops
	if (keys %$todo > 0) {
		if ($set->{once}) {
			for my $set2 (values %$todo) {
				# XXX merge all ?
				$set->add_older($set2->older);
				$set2->{merged} = $set;
				$set2->{finished} = 1;
			}
			delete $set->{once};
			return ($set);
		}
		$set->{once} = 1;
		$state->build_deptree($set, values %$todo);
		return (values %$todo, $set);
	}
	if ($state->{do_automatic}) {
		for my $pkg  ($set->older) {
			$pkg->complete_old;
			if (!defined $pkg->plist) {
				$state->say("Corrupt set #1, run pkg_check",
				    $set->print);
				$set->cleanup(OpenBSD::Handle::CANT_DELETE);
				$state->tracker->cant($set);
				return ();
			}
			if ($pkg->plist->has('manual-installation')) {
				$state->say("Won't delete manually installed #1",
				    $set->print) if $state->verbose;
				$set->cleanup(OpenBSD::Handle::CANT_DELETE);
				$state->tracker->cant($set);
				return ();
			}
		}
	}
	really_remove($set, $state);
	$set->cleanup;
	$state->tracker->done($set);
	return ();
}

sub main
{
	my ($self, $state) = @@_;

	if ($state->{exclude}) {
		my $names = {};
		for my $l (@@{$state->{setlist}}) {
			for my $n ($l->older_names) {
				$names->{$n} = 1;
			}
		}
		$state->{setlist} = [];
		my $inst = $state->repo->installed;
		for my $l (@@{$inst->locations_list}) {
			$self->add_location($state, $l) if !$names->{$l->name};
		}
	}
	if ($state->{automatic}) {
		if (!defined $state->{setlist}) {
			my $inst = $state->repo->installed;
			for my $l (@@{$inst->locations_list}) {
				$self->add_location($state, $l);
			}
		}
		$state->{do_automatic} = 1;
		$self->process_setlist($state);
	} else {
		$self->process_setlist($state);
	}
}

sub new_state
{
	my ($self, $cmd) = @@_;
	return OpenBSD::PkgDelete::State->new($cmd);
}

1;
@


1.37
log
@framework for some performance stats as a -V... option (like how much
of a package you actually downloaded, or how many packages you touch)
okay aja@@
@
text
@d3 1
a3 1
# $OpenBSD: PkgDelete.pm,v 1.36 2017/01/25 14:12:33 espie Exp $
d104 1
a104 1
	    '[-acimnqsvVXx] [-B pkg-destdir] [-D name[=value]] [pkg-name ...]');
@


1.36
log
@if the fs got badly damaged, display a decent error message instead of
erroring out when we can't read a plist.
@
text
@d3 1
a3 1
# $OpenBSD: PkgDelete.pm,v 1.35 2015/10/07 17:52:38 jmc Exp $
d104 1
a104 1
	    '[-acimnqsvXx] [-B pkg-destdir] [-D name[=value]] [pkg-name ...]');
@


1.35
log
@"..." implies optional, so no need for []; from michael reed
@
text
@d3 1
a3 1
# $OpenBSD: PkgDelete.pm,v 1.34 2014/11/29 10:42:51 espie Exp $
d359 7
@


1.34
log
@simplify the interactive code into its own little object with simpler
interface, so that most is it interactive tests vanish from the main
program.
@
text
@d3 1
a3 1
# $OpenBSD: PkgDelete.pm,v 1.33 2014/07/12 19:50:43 espie Exp $
d104 1
a104 1
	    '[-acimnqsvXx] [-B pkg-destdir] [-D name[=value]] pkg-name [...]');
@


1.33
log
@finish killing old experiment, less confusing code
@
text
@d3 1
a3 1
# $OpenBSD: PkgDelete.pm,v 1.32 2014/02/11 08:58:34 sthen Exp $
d268 1
a268 4
	if ($state->{interactive}) {
		return $state->confirm("Delete them as well", 0);
	}
	return 0;
d278 1
a278 4
	if ($state->{interactive}) {
		return $state->confirm("Delete anyway", 0);
	}
	return 0;
@


1.32
log
@s/anyways/anyway/, ok espie@@
@
text
@d3 1
a3 1
# $OpenBSD: PkgDelete.pm,v 1.31 2014/02/08 16:21:54 espie Exp $
a165 3
		if ($state->{do_faked}) {
			$state->print(" under #1", $state->{destdir});
		}
@


1.31
log
@be less verbose for pkg_delete -X
@
text
@d3 1
a3 1
# $OpenBSD: PkgDelete.pm,v 1.30 2013/01/07 10:50:41 espie Exp $
d285 1
a285 1
		return $state->confirm("Delete anyways", 0);
@


1.30
log
@only protest midly if we're in exclude mode, so that you can exclude stuff
that does not exist, and that you will still see typos.
@
text
@d3 1
a3 1
# $OpenBSD$
a229 1
				$state->say("Problem finding #1", $pkgname);
d231 2
@


1.29
log
@small logic error
@
text
@d3 1
a3 1
# $OpenBSD: PkgDelete.pm,v 1.28 2011/12/02 16:01:17 jmc Exp $
d24 1
d231 3
a233 1
				$state->{bad}++;
@


1.28
log
@-X before -x;
@
text
@d3 1
a3 1
# $OpenBSD: PkgDelete.pm,v 1.27 2011/12/02 12:00:32 espie Exp $
d215 1
a215 1
		if (!$state->{automatic} || $state->{exclude}) {
@


1.27
log
@-X exclude option: negates the packages we give (remove them instead of
adding them).
@
text
@d3 1
a3 1
# $OpenBSD: PkgDelete.pm,v 1.26 2011/11/25 23:58:40 espie Exp $
d103 1
a103 1
	    '[-acinqsvxX] [-B pkg-destdir] [-D name[=value]] pkg-name [...]');
@


1.26
log
@darn, setlist might actually be undefined entirely...
noticed by nigel
@
text
@d3 1
a3 1
# $OpenBSD: PkgDelete.pm,v 1.25 2011/11/25 09:25:59 espie Exp $
d102 2
a103 2
	$state->SUPER::handle_options('',
	    '[-acinqsvx] [-B pkg-destdir] [-D name[=value]] pkg-name [...]');
d117 1
d215 1
a215 1
		if (!$state->{automatic}) {
d383 13
@


1.25
log
@fix -a <list> semantics:
instead of first doing, -a, then deleting the list, it's ways more useful
to pick !manual installs in the list and remove them.
@
text
@d3 1
a3 1
# $OpenBSD: PkgDelete.pm,v 1.24 2011/08/26 08:46:10 espie Exp $
d383 1
a383 1
		if (@@{$state->{setlist}} == 0) {
@


1.24
log
@zap fatpackages. nobody actually uses them.
accordingly, locations do not need to track architecture.
@
text
@d3 1
a3 1
# $OpenBSD: PkgDelete.pm,v 1.23 2011/08/23 10:32:27 espie Exp $
a381 1
	$self->process_setlist($state);
d383 5
a387 4
		my $inst = $state->repo->installed;
		delete $state->{setlist};
		for my $l (@@{$inst->locations_list}) {
			$self->add_location($state, $l);
d390 2
@


1.23
log
@zap old INSTALL/DEINSTALL stuff, it's been deprecated for 3 years, and removed
from pkg_create for over a year.
@
text
@d3 1
a3 1
# $OpenBSD: PkgDelete.pm,v 1.22 2011/08/18 07:55:26 espie Exp $
d225 1
a225 1
				$l = $inst->find($pkgname, $state->{arch});
@


1.22
log
@spacing
@
text
@d3 1
a3 1
# $OpenBSD$
d103 1
a103 1
	    '[-acIinqsvx] [-B pkg-destdir] [-D name[=value]] pkg-name [...]');
@


1.21
log
@pkg_add and pkg_delete will now syslog activity by default.
@
text
@d3 1
a3 1
# $OpenBSD: PkgDelete.pm,v 1.20 2011/07/19 05:58:33 espie Exp $
d170 1
a170 1
	
d222 1
a222 1
				$l = $state->stem2location($inst, $pkgname, 
@


1.20
log
@fix -Ddependencies, from Nathanael Rensen
@
text
@d3 1
a3 1
# $OpenBSD: PkgDelete.pm,v 1.19 2011/07/18 19:19:08 espie Exp $
d256 1
@


1.19
log
@allow pkg_delete -a pkgname to do something useful:
- first delete the list of packages
- then if -a was specified, try deleting everything else (but only !manual)
@
text
@d3 1
a3 1
# $OpenBSD: PkgDelete.pm,v 1.18 2011/07/17 13:16:15 espie Exp $
d334 1
a334 1
				$state->tracker->todo($l);
@


1.18
log
@unify the main loop some more: add and delete do more or less the
same processing.

start making process_set similar as well
@
text
@d3 1
a3 1
# $OpenBSD: PkgDelete.pm,v 1.17 2011/07/14 11:31:20 espie Exp $
d213 3
a215 3
	if (@@ARGV == 0 && $state->{automatic}) {
		for my $l (@@{$inst->locations_list}) {
			$self->add_location($state, $l);
d222 2
a223 1
				$l = $state->stem2location($inst, $pkgname, $state);
d327 1
a327 1
		if (!$state->{automatic} || $state->verbose) {
d331 1
a331 1
		if (!$state->{automatic}) {
d359 1
a359 1
	if ($state->{automatic}) {
d382 9
@


1.17
log
@move deptree_header into AddDelete, use it in pkg_delete.
Now, pkg_delete will display things a lot like pkg_add, spelling out
what reverse dependencies trigger the deletion of a given package at that
point in the list.

by popular demand.
@
text
@d3 1
a3 1
# $OpenBSD: PkgDelete.pm,v 1.16 2011/07/13 13:01:13 espie Exp $
d50 2
a51 2
	my ($self, $list) = @@_;
	for my $set (@@$list) {
d70 4
a253 2
	$set->cleanup;
	$state->tracker->done($set);
d283 1
a283 1
sub remove_set
d285 1
a285 1
	my ($set, $state) = @@_;
a288 4
	$set = $set->real_set;
	if ($set->{finished}) {
		return ();
	}
d339 1
a339 1
		$state->tracker->done($set);
d365 1
a365 1
				$state->tracker->done($set);
d371 2
d380 1
a380 9
	my %done;
	my $removed;

	$state->tracker->todo($state->{setlist});
	# and finally, handle the removal
	while (my $set = shift @@{$state->{setlist}}) {
		$state->status->what->set($set);
		unshift(@@{$state->{setlist}}, remove_set($set, $state));
	}
@


1.16
log
@share code
@
text
@d3 1
a3 1
# $OpenBSD$
d140 27
d244 1
a244 6
	if (!$state->progress->set_header($set->print)) {
		$state->say($state->{not} ?
		    "Pretending to delete #1" :
		    "Deleting #1",
		    $set->print) if $state->verbose;
	}
d246 1
d357 1
@


1.15
log
@create DeleteSet as a specialized version of UpdateSets that print
differently, specialize the states a wee little bit.
@
text
@d3 1
a3 1
# $OpenBSD: PkgDelete.pm,v 1.14 2011/07/12 10:56:03 espie Exp $
d76 1
a76 1
	
a114 6
sub todo
{
	my ($state, $offset) = @@_;
	return $state->tracker->sets_todo($offset);
}

d154 1
a154 1
	push(@@{$state->{setlist}}, 
d166 1
a166 1
			$state->errsay("Can't find #1 in installed packages", 
@


1.14
log
@be ways more verbose with -a
@
text
@d3 1
a3 1
# $OpenBSD: PkgDelete.pm,v 1.13 2011/07/12 10:51:28 espie Exp $
d132 14
d161 1
a161 1
	    $state->updateset->add_older(OpenBSD::Handle->from_location($l)));
d176 1
a176 1
			push(@@$result, $state->updateset->add_older(OpenBSD::Handle->from_location($l)));
d223 1
a223 1
	if (!$state->progress->set_header($set->delete_print)) {
d227 1
a227 1
		    $set->delete_print) if $state->verbose;
d302 1
a302 1
			    $set->delete_print, join(' ', sort keys %$bad2));
d313 1
a313 1
			    $set->delete_print, join(' ', sort keys %$bad));
d347 1
a347 1
				    $set->delete_print) if $state->verbose;
@


1.13
log
@put back options -Dbaddepend -Ddependencies
uninstalled and verbosedeps are now always on.
ambiguous will die ?
@
text
@d3 1
a3 1
# $OpenBSD: PkgDelete.pm,v 1.12 2011/07/12 10:30:29 espie Exp $
d297 1
a297 1
		if (!$state->{automatic}) {
d300 2
d332 2
@


1.12
log
@new pkg_delete, very similar to pkg_add, support for -a
@
text
@d3 1
a3 1
# $OpenBSD$
d224 26
d280 17
d299 2
a300 4
			    join(' ', $set->older_names), 
			    join(' ', sort keys %$bad));
			if ($state->{interactive} && 
			    $state->confirm("Delete them as well", 0)) {
@


1.11
log
@handle failures from ports tree with more care.
this does avoid infinite loops in case of wrong plists.
necessary since print-plist-with-depends CAN fail...
@
text
@d24 54
d81 14
d99 1
a99 1
	    '[-cIinqsvx] [-B pkg-destdir] [-D name[=value]] pkg-name [...]');
d118 12
a129 1
	return sprintf("%u/%u", $state->{done} - $offset, $state->{total});
d140 2
d143 24
d172 1
a172 2
	my @@realnames;
	my @@toremove;
d174 7
a180 2
	OpenBSD::PackageInfo::solve_installed_names(\@@ARGV, \@@realnames,
	    "(removing them all)", $state);
d182 11
a192 36
	@@toremove = OpenBSD::RequiredBy->compute_closure(@@realnames);

	if (@@toremove > @@realnames) {
		my $details = $state->verbose >= 2 ||
		    $state->defines('verbosedeps');
		my $show = sub {
			my ($p, $d) = @@_;
			$state->say("Can't remove #1".
			    " without also removing:\n#2",
			    join(' ', @@$p), join(' ', @@$d));
		};
		if ($state->{interactive} || !$details) {
			my %deps = map {($_, 1)} @@toremove;
			for my $p (@@realnames) {
				delete $deps{$p};
			}
			&$show([@@realnames], [keys %deps]);
			if (@@realnames > 1 && (keys %deps) > 1 &&
			    $state->confirm("Do you want details", 1)) {
				$details = 1;
			}
		}
		if ($details) {
			for my $pkg (@@realnames) {
				my @@deps = OpenBSD::RequiredBy->compute_closure($pkg);
				next unless @@deps > 1;
				@@deps = grep {$_ ne $pkg} @@deps;
				&$show([$pkg], [@@deps]);
			}
		}
		my $them = @@toremove > 1 ? 'them' : 'it';
		if ($state->defines('dependencies') or
		    $state->confirm("Do you want to remove $them as well", 0)) {
			$state->say("(removing #1 as well)", $them);
		} else {
			$state->{bad}++;
a194 1
	$state->{toremove} = \@@toremove;
d201 98
d306 1
d308 4
a311 48
	do {
		$removed = 0;
		if ($state->{not}) {
			$state->status->what("Pretending to delete");
		} else {
			$state->status->what("Deleting");
		}
		$state->{total} = scalar @@{$state->{toremove}};
		DELETE: for my $pkgname (@@{$state->{toremove}}) {
			if ($done{$pkgname}) {
				next;
			}
			unless (is_installed($pkgname)) {
				$state->errsay("#1 was not installed", $pkgname);
				$done{$pkgname} = 1;
				$removed++;
				next;
			}
			my $r = OpenBSD::RequiredBy->new($pkgname);
			if ($r->list > 0) {
				if ($state->defines('baddepend')) {
					for my $p ($r->list) {
						if ($done{$p}) {
							$r->delete($p);
						} else {
							next DELETE;
						}
					}
				} else {
					next;
				}
			}
			my $info = sub {
			};

			$state->status->object($pkgname);
			if (!$state->progress->set_header($pkgname)) {
				$state->say($state->{not} ?
				    "Pretending to delete #1" :
				    "Deleting #1",
				    $pkgname) if $state->verbose;
			}
			$state->log->set_context('-'.$pkgname);
			OpenBSD::Delete::delete_package($pkgname, $state);
			$done{$pkgname} = 1;
			$removed++;
		}
	} while ($removed);
@


1.10
log
@remove locals, so that it can be called again and again
(again, needed by landry@@)
@
text
@d3 1
a3 1
# $OpenBSD: PkgDelete.pm,v 1.9 2010/10/27 14:35:56 espie Exp $
@


1.9
log
@initial scaffolding for @@rcscript: for now, acts like normal files,
but allow absolute pathnames (treat that as an implicit @@cwd).
@
text
@d3 1
a3 1
# $OpenBSD$
a62 7
my %done;
my $removed;

# Resolve pkg names
my @@realnames;
my @@todo;

d66 4
d73 1
a73 1
	@@todo = OpenBSD::RequiredBy->compute_closure(@@realnames);
d75 1
a75 1
	if (@@todo > @@realnames) {
d85 1
a85 1
			my %deps = map {($_, 1)} @@todo;
d103 1
a103 1
		my $them = @@todo > 1 ? 'them' : 'it';
d111 1
d122 3
d133 2
a134 2
		$state->{total} = scalar @@todo;
		DELETE: for my $pkgname (@@todo) {
@


1.8
log
@allow say and errsay to work without parameters, as it's ways common.
create verbose_system up in state, because it makes sense without verbose.
@
text
@@


1.7
log
@whitespace cleanup
@
text
@@


1.6
log
@clean-up options handling some more
@
text
@d3 1
a3 1
# $OpenBSD: PkgDelete.pm,v 1.5 2010/06/15 08:21:05 espie Exp $
d30 1
a30 1
	$state->SUPER::handle_options('', 
d79 1
a79 1
		my $details = $state->verbose >= 2 || 
d83 1
a83 1
			$state->say("Can't remove #1". 
@


1.5
log
@fix count of deinstalling packages.
@
text
@d3 1
a3 1
# $OpenBSD: PkgDelete.pm,v 1.4 2010/06/11 09:53:06 espie Exp $
d27 20
a117 21
}

sub handle_options
{
	my ($self, $cmd) = @@_;
	my $state = $self->SUPER::handle_options('', {}, $cmd,
	    '[-cIinqsvx] [-B pkg-destdir] [-D name[=value]] pkg-name [...]');

	my $base = $state->opt('B') // $ENV{'PKG_DESTDIR'} // '';
	if ($base ne '') {
		$base.='/' unless $base =~ m/\/$/o;
	}
	$ENV{'PKG_DESTDIR'} = $base;

	$state->{destdir} = $base;
	if ($base eq '') {
	    $state->{destdirname} = '';
	} else {
	    $state->{destdirname} = '${PKG_DESTDIR}';
	}
	return $state;
@


1.4
log
@fix format, as noticed by marco@@
@
text
@d3 1
a3 1
# $OpenBSD: PkgDelete.pm,v 1.3 2010/06/09 08:13:19 espie Exp $
a135 1
				$state->{total}--;
a140 1
				$state->{total}--;
@


1.3
log
@replace confusing (n to go) message with #done/#total annotations.
e.g.,
Checking packages|No change in apr-util-mt-1.2.10p4 (26/1530)
@
text
@d3 1
a3 1
# $OpenBSD: PkgDelete.pm,v 1.2 2010/06/09 07:26:01 espie Exp $
d63 1
a63 1
			$state->say("Can't remove #1", 
@


1.2
log
@ui changes: go thru a state object for most printouts
@
text
@d3 1
a3 1
# $OpenBSD: PkgDelete.pm,v 1.1 2010/06/04 13:19:39 espie Exp $
d29 2
a30 2
	my $state = shift;
	return $state->{todo};
d133 1
d135 4
a138 2
			$state->{todo} = scalar @@todo - scalar keys %done;
			next if $done{$pkgname};
d142 1
@


1.1
log
@move code around, so that commands can be used as modules.
pkg becomes the start hub, which does nothing except require the
correct module.
Saner code wrt Add/Delete, and more sharing.
@
text
@d3 1
a3 1
# $OpenBSD: pkg_delete,v 1.134 2010/05/10 09:17:55 espie Exp $
d63 3
a65 3
			$state->say("Can't remove ", join(' ', @@$p),
			    " without also removing:\n",
			    join(' ', @@$d));
d89 1
a89 1
			$state->say("(removing $them as well)");
d102 3
a104 3
	my $self = shift;
	my $state = $self->SUPER::handle_options('', {},
	    'pkg_delete [-cIinqsvx] [-B pkg-destdir] [-D name[=value]] pkg-name [...]');
d137 1
a137 1
				$state->errsay("$pkgname was not installed");
d162 2
a163 2
				    "Pretending to delete " :
				    "Deleting ",
d176 2
a177 1
	return OpenBSD::PkgDelete::State->new;
@

