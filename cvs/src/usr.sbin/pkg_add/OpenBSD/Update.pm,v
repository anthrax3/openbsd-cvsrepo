head	1.162;
access;
symbols
	OPENBSD_6_2:1.162.0.8
	OPENBSD_6_2_BASE:1.162
	OPENBSD_6_1:1.162.0.12
	OPENBSD_6_1_BASE:1.162
	OPENBSD_6_0:1.162.0.10
	OPENBSD_6_0_BASE:1.162
	OPENBSD_5_9:1.162.0.4
	OPENBSD_5_9_BASE:1.162
	OPENBSD_5_8:1.162.0.6
	OPENBSD_5_8_BASE:1.162
	OPENBSD_5_7:1.162.0.2
	OPENBSD_5_7_BASE:1.162
	OPENBSD_5_6:1.161.0.6
	OPENBSD_5_6_BASE:1.161
	OPENBSD_5_5:1.161.0.4
	OPENBSD_5_5_BASE:1.161
	OPENBSD_5_4:1.153.0.4
	OPENBSD_5_4_BASE:1.153
	OPENBSD_5_3:1.153.0.2
	OPENBSD_5_3_BASE:1.153
	OPENBSD_5_2:1.152.0.2
	OPENBSD_5_2_BASE:1.152
	OPENBSD_5_1_BASE:1.151
	OPENBSD_5_1:1.151.0.2
	OPENBSD_5_0:1.149.0.2
	OPENBSD_5_0_BASE:1.149
	OPENBSD_4_9:1.147.0.2
	OPENBSD_4_9_BASE:1.147
	OPENBSD_4_8:1.145.0.2
	OPENBSD_4_8_BASE:1.145
	OPENBSD_4_7:1.134.0.2
	OPENBSD_4_7_BASE:1.134
	OPENBSD_4_6:1.84.0.4
	OPENBSD_4_6_BASE:1.84
	OPENBSD_4_5:1.82.0.4
	OPENBSD_4_5_BASE:1.82
	OPENBSD_4_4:1.82.0.2
	OPENBSD_4_4_BASE:1.82
	OPENBSD_4_3:1.81.0.2
	OPENBSD_4_3_BASE:1.81
	OPENBSD_4_2:1.80.0.2
	OPENBSD_4_2_BASE:1.80
	OPENBSD_4_1:1.64.0.4
	OPENBSD_4_1_BASE:1.64
	OPENBSD_4_0:1.64.0.2
	OPENBSD_4_0_BASE:1.64
	OPENBSD_3_9:1.61.0.2
	OPENBSD_3_9_BASE:1.61
	OPENBSD_3_8:1.55.0.2
	OPENBSD_3_8_BASE:1.55
	OPENBSD_3_7:1.51.0.2
	OPENBSD_3_7_BASE:1.51;
locks; strict;
comment	@# @;


1.162
date	2015.01.04.14.20.04;	author espie;	state Exp;
branches;
next	1.161;
commitid	xJlx1plAz31SlC6u;

1.161
date	2014.02.02.15.22.36;	author espie;	state Exp;
branches;
next	1.160;

1.160
date	2014.02.01.10.55.37;	author espie;	state Exp;
branches;
next	1.159;

1.159
date	2014.01.24.11.41.23;	author espie;	state Exp;
branches;
next	1.158;

1.158
date	2014.01.11.11.51.01;	author espie;	state Exp;
branches;
next	1.157;

1.157
date	2014.01.09.20.20.01;	author espie;	state Exp;
branches;
next	1.156;

1.156
date	2014.01.05.10.24.30;	author espie;	state Exp;
branches;
next	1.155;

1.155
date	2013.12.25.15.59.51;	author espie;	state Exp;
branches;
next	1.154;

1.154
date	2013.12.25.14.20.48;	author espie;	state Exp;
branches;
next	1.153;

1.153
date	2012.10.13.10.28.22;	author jeremy;	state Exp;
branches;
next	1.152;

1.152
date	2012.04.28.11.55.16;	author espie;	state Exp;
branches;
next	1.151;

1.151
date	2012.02.06.17.02.48;	author espie;	state Exp;
branches;
next	1.150;

1.150
date	2011.08.26.08.46.10;	author espie;	state Exp;
branches;
next	1.149;

1.149
date	2011.07.19.20.04.23;	author espie;	state Exp;
branches;
next	1.148;

1.148
date	2011.06.19.01.28.43;	author espie;	state Exp;
branches;
next	1.147;

1.147
date	2010.12.24.09.04.14;	author espie;	state Exp;
branches;
next	1.146;

1.146
date	2010.10.02.13.33.05;	author espie;	state Exp;
branches;
next	1.145;

1.145
date	2010.08.03.14.08.49;	author espie;	state Exp;
branches;
next	1.144;

1.144
date	2010.07.31.11.17.22;	author espie;	state Exp;
branches;
next	1.143;

1.143
date	2010.07.26.23.28.06;	author espie;	state Exp;
branches;
next	1.142;

1.142
date	2010.07.06.12.12.37;	author espie;	state Exp;
branches;
next	1.141;

1.141
date	2010.06.30.10.51.04;	author espie;	state Exp;
branches;
next	1.140;

1.140
date	2010.06.30.10.41.42;	author espie;	state Exp;
branches;
next	1.139;

1.139
date	2010.06.30.10.36.07;	author espie;	state Exp;
branches;
next	1.138;

1.138
date	2010.06.09.08.13.19;	author espie;	state Exp;
branches;
next	1.137;

1.137
date	2010.06.09.07.26.01;	author espie;	state Exp;
branches;
next	1.136;

1.136
date	2010.06.04.13.19.39;	author espie;	state Exp;
branches;
next	1.135;

1.135
date	2010.05.10.09.17.55;	author espie;	state Exp;
branches;
next	1.134;

1.134
date	2010.01.26.15.03.39;	author espie;	state Exp;
branches;
next	1.133;

1.133
date	2010.01.10.16.03.49;	author espie;	state Exp;
branches;
next	1.132;

1.132
date	2010.01.09.15.10.17;	author espie;	state Exp;
branches;
next	1.131;

1.131
date	2010.01.09.14.55.53;	author espie;	state Exp;
branches;
next	1.130;

1.130
date	2010.01.09.12.01.57;	author espie;	state Exp;
branches;
next	1.129;

1.129
date	2010.01.09.11.26.58;	author espie;	state Exp;
branches;
next	1.128;

1.128
date	2010.01.09.10.45.32;	author espie;	state Exp;
branches;
next	1.127;

1.127
date	2010.01.02.12.52.18;	author espie;	state Exp;
branches;
next	1.126;

1.126
date	2010.01.01.17.37.08;	author espie;	state Exp;
branches;
next	1.125;

1.125
date	2010.01.01.13.41.49;	author espie;	state Exp;
branches;
next	1.124;

1.124
date	2010.01.01.13.00.05;	author espie;	state Exp;
branches;
next	1.123;

1.123
date	2010.01.01.12.58.30;	author espie;	state Exp;
branches;
next	1.122;

1.122
date	2009.12.28.19.28.59;	author espie;	state Exp;
branches;
next	1.121;

1.121
date	2009.12.26.16.58.55;	author espie;	state Exp;
branches;
next	1.120;

1.120
date	2009.12.24.14.06.43;	author espie;	state Exp;
branches;
next	1.119;

1.119
date	2009.12.20.22.38.45;	author espie;	state Exp;
branches;
next	1.118;

1.118
date	2009.12.14.18.11.26;	author espie;	state Exp;
branches;
next	1.117;

1.117
date	2009.12.14.11.19.04;	author espie;	state Exp;
branches;
next	1.116;

1.116
date	2009.12.14.09.35.56;	author espie;	state Exp;
branches;
next	1.115;

1.115
date	2009.12.13.17.58.55;	author espie;	state Exp;
branches;
next	1.114;

1.114
date	2009.12.12.17.08.07;	author espie;	state Exp;
branches;
next	1.113;

1.113
date	2009.12.07.13.41.02;	author espie;	state Exp;
branches;
next	1.112;

1.112
date	2009.12.05.14.41.03;	author espie;	state Exp;
branches;
next	1.111;

1.111
date	2009.12.05.10.54.11;	author espie;	state Exp;
branches;
next	1.110;

1.110
date	2009.12.05.10.43.49;	author espie;	state Exp;
branches;
next	1.109;

1.109
date	2009.12.05.10.08.58;	author espie;	state Exp;
branches;
next	1.108;

1.108
date	2009.12.04.10.48.14;	author espie;	state Exp;
branches;
next	1.107;

1.107
date	2009.11.30.18.45.14;	author espie;	state Exp;
branches;
next	1.106;

1.106
date	2009.11.29.12.12.15;	author espie;	state Exp;
branches;
next	1.105;

1.105
date	2009.11.24.11.41.56;	author espie;	state Exp;
branches;
next	1.104;

1.104
date	2009.11.24.11.36.06;	author espie;	state Exp;
branches;
next	1.103;

1.103
date	2009.11.24.10.22.26;	author espie;	state Exp;
branches;
next	1.102;

1.102
date	2009.11.22.11.26.43;	author espie;	state Exp;
branches;
next	1.101;

1.101
date	2009.11.22.09.38.10;	author espie;	state Exp;
branches;
next	1.100;

1.100
date	2009.11.22.09.18.55;	author espie;	state Exp;
branches;
next	1.99;

1.99
date	2009.11.17.10.17.21;	author espie;	state Exp;
branches;
next	1.98;

1.98
date	2009.11.16.17.30.43;	author espie;	state Exp;
branches;
next	1.97;

1.97
date	2009.11.16.16.32.55;	author espie;	state Exp;
branches;
next	1.96;

1.96
date	2009.11.16.15.13.00;	author espie;	state Exp;
branches;
next	1.95;

1.95
date	2009.11.16.15.01.30;	author espie;	state Exp;
branches;
next	1.94;

1.94
date	2009.11.16.14.47.05;	author espie;	state Exp;
branches;
next	1.93;

1.93
date	2009.11.11.12.04.19;	author espie;	state Exp;
branches;
next	1.92;

1.92
date	2009.11.11.11.18.24;	author espie;	state Exp;
branches;
next	1.91;

1.91
date	2009.11.10.11.36.56;	author espie;	state Exp;
branches;
next	1.90;

1.90
date	2009.11.09.17.50.24;	author espie;	state Exp;
branches;
next	1.89;

1.89
date	2009.11.08.10.46.11;	author espie;	state Exp;
branches;
next	1.88;

1.88
date	2009.10.15.10.48.27;	author espie;	state Exp;
branches;
next	1.87;

1.87
date	2009.10.14.13.46.25;	author espie;	state Exp;
branches;
next	1.86;

1.86
date	2009.10.14.11.08.16;	author espie;	state Exp;
branches;
next	1.85;

1.85
date	2009.10.13.21.21.07;	author espie;	state Exp;
branches;
next	1.84;

1.84
date	2009.06.06.11.48.04;	author espie;	state Exp;
branches;
next	1.83;

1.83
date	2009.04.19.14.58.32;	author espie;	state Exp;
branches;
next	1.82;

1.82
date	2008.03.08.12.07.45;	author espie;	state Exp;
branches;
next	1.81;

1.81
date	2007.09.20.09.01.34;	author espie;	state Exp;
branches;
next	1.80;

1.80
date	2007.06.09.11.16.54;	author espie;	state Exp;
branches;
next	1.79;

1.79
date	2007.06.04.14.40.39;	author espie;	state Exp;
branches;
next	1.78;

1.78
date	2007.06.01.14.58.29;	author espie;	state Exp;
branches;
next	1.77;

1.77
date	2007.05.14.11.22.00;	author espie;	state Exp;
branches;
next	1.76;

1.76
date	2007.05.14.10.53.31;	author espie;	state Exp;
branches;
next	1.75;

1.75
date	2007.05.14.09.29.07;	author espie;	state Exp;
branches;
next	1.74;

1.74
date	2007.05.13.16.58.13;	author espie;	state Exp;
branches;
next	1.73;

1.73
date	2007.05.13.13.32.36;	author espie;	state Exp;
branches;
next	1.72;

1.72
date	2007.05.13.12.19.28;	author espie;	state Exp;
branches;
next	1.71;

1.71
date	2007.05.13.11.14.25;	author espie;	state Exp;
branches;
next	1.70;

1.70
date	2007.05.13.10.43.33;	author espie;	state Exp;
branches;
next	1.69;

1.69
date	2007.05.07.14.12.43;	author espie;	state Exp;
branches;
next	1.68;

1.68
date	2007.05.07.13.51.58;	author espie;	state Exp;
branches;
next	1.67;

1.67
date	2007.05.02.15.05.30;	author espie;	state Exp;
branches;
next	1.66;

1.66
date	2007.04.21.10.02.15;	author espie;	state Exp;
branches;
next	1.65;

1.65
date	2007.04.15.10.17.29;	author espie;	state Exp;
branches;
next	1.64;

1.64
date	2006.04.08.23.24.06;	author bernd;	state Exp;
branches;
next	1.63;

1.63
date	2006.03.07.11.10.49;	author espie;	state Exp;
branches;
next	1.62;

1.62
date	2006.03.04.11.31.18;	author espie;	state Exp;
branches;
next	1.61;

1.61
date	2006.02.21.19.20.17;	author espie;	state Exp;
branches;
next	1.60;

1.60
date	2006.01.24.20.14.13;	author espie;	state Exp;
branches;
next	1.59;

1.59
date	2005.11.05.10.59.21;	author espie;	state Exp;
branches;
next	1.58;

1.58
date	2005.10.19.10.41.19;	author espie;	state Exp;
branches;
next	1.57;

1.57
date	2005.09.09.09.11.38;	author espie;	state Exp;
branches;
next	1.56;

1.56
date	2005.09.04.22.47.56;	author espie;	state Exp;
branches;
next	1.55;

1.55
date	2005.08.16.21.34.10;	author espie;	state Exp;
branches;
next	1.54;

1.54
date	2005.08.16.18.37.06;	author espie;	state Exp;
branches;
next	1.53;

1.53
date	2005.08.10.12.10.26;	author espie;	state Exp;
branches;
next	1.52;

1.52
date	2005.07.26.09.16.48;	author espie;	state Exp;
branches;
next	1.51;

1.51
date	2005.02.07.15.35.23;	author espie;	state Exp;
branches;
next	1.50;

1.50
date	2004.12.28.14.00.21;	author espie;	state Exp;
branches;
next	1.49;

1.49
date	2004.12.28.13.56.08;	author espie;	state Exp;
branches;
next	1.48;

1.48
date	2004.12.27.22.40.42;	author espie;	state Exp;
branches;
next	1.47;

1.47
date	2004.12.21.01.43.58;	author espie;	state Exp;
branches;
next	1.46;

1.46
date	2004.12.20.22.43.25;	author espie;	state Exp;
branches;
next	1.45;

1.45
date	2004.12.20.12.16.51;	author espie;	state Exp;
branches;
next	1.44;

1.44
date	2004.12.19.20.25.17;	author espie;	state Exp;
branches;
next	1.43;

1.43
date	2004.12.19.20.03.09;	author espie;	state Exp;
branches;
next	1.42;

1.42
date	2004.12.18.13.39.17;	author espie;	state Exp;
branches;
next	1.41;

1.41
date	2004.12.18.13.20.54;	author espie;	state Exp;
branches;
next	1.40;

1.40
date	2004.12.15.01.07.10;	author espie;	state Exp;
branches;
next	1.39;

1.39
date	2004.12.12.11.26.16;	author espie;	state Exp;
branches;
next	1.38;

1.38
date	2004.12.02.00.19.26;	author espie;	state Exp;
branches;
next	1.37;

1.37
date	2004.12.02.00.15.15;	author espie;	state Exp;
branches;
next	1.36;

1.36
date	2004.11.27.16.38.26;	author espie;	state Exp;
branches;
next	1.35;

1.35
date	2004.11.27.14.02.50;	author espie;	state Exp;
branches;
next	1.34;

1.34
date	2004.11.18.21.56.03;	author espie;	state Exp;
branches;
next	1.33;

1.33
date	2004.11.18.21.48.02;	author espie;	state Exp;
branches;
next	1.32;

1.32
date	2004.11.14.19.25.45;	author espie;	state Exp;
branches;
next	1.31;

1.31
date	2004.11.14.11.40.08;	author espie;	state Exp;
branches;
next	1.30;

1.30
date	2004.11.13.12.53.01;	author espie;	state Exp;
branches;
next	1.29;

1.29
date	2004.11.13.12.49.58;	author espie;	state Exp;
branches;
next	1.28;

1.28
date	2004.11.13.11.54.30;	author espie;	state Exp;
branches;
next	1.27;

1.27
date	2004.11.12.21.52.01;	author espie;	state Exp;
branches;
next	1.26;

1.26
date	2004.11.11.22.40.38;	author espie;	state Exp;
branches;
next	1.25;

1.25
date	2004.11.11.20.59.05;	author espie;	state Exp;
branches;
next	1.24;

1.24
date	2004.11.11.13.54.48;	author espie;	state Exp;
branches;
next	1.23;

1.23
date	2004.11.11.12.45.15;	author espie;	state Exp;
branches;
next	1.22;

1.22
date	2004.11.11.12.15.28;	author espie;	state Exp;
branches;
next	1.21;

1.21
date	2004.11.11.11.16.40;	author espie;	state Exp;
branches;
next	1.20;

1.20
date	2004.11.11.10.47.26;	author espie;	state Exp;
branches;
next	1.19;

1.19
date	2004.11.11.10.23.53;	author espie;	state Exp;
branches;
next	1.18;

1.18
date	2004.11.09.22.55.56;	author espie;	state Exp;
branches;
next	1.17;

1.17
date	2004.11.09.22.44.30;	author espie;	state Exp;
branches;
next	1.16;

1.16
date	2004.11.09.10.17.52;	author espie;	state Exp;
branches;
next	1.15;

1.15
date	2004.11.09.09.58.56;	author espie;	state Exp;
branches;
next	1.14;

1.14
date	2004.11.09.09.32.17;	author espie;	state Exp;
branches;
next	1.13;

1.13
date	2004.11.07.13.29.29;	author espie;	state Exp;
branches;
next	1.12;

1.12
date	2004.11.07.13.19.48;	author espie;	state Exp;
branches;
next	1.11;

1.11
date	2004.11.07.12.19.20;	author espie;	state Exp;
branches;
next	1.10;

1.10
date	2004.11.06.12.19.17;	author espie;	state Exp;
branches;
next	1.9;

1.9
date	2004.11.02.23.53.21;	author espie;	state Exp;
branches;
next	1.8;

1.8
date	2004.11.02.18.50.36;	author espie;	state Exp;
branches;
next	1.7;

1.7
date	2004.11.01.19.48.58;	author espie;	state Exp;
branches;
next	1.6;

1.6
date	2004.11.01.19.14.26;	author espie;	state Exp;
branches;
next	1.5;

1.5
date	2004.11.01.15.45.02;	author espie;	state Exp;
branches;
next	1.4;

1.4
date	2004.11.01.14.30.00;	author espie;	state Exp;
branches;
next	1.3;

1.3
date	2004.11.01.11.48.03;	author espie;	state Exp;
branches;
next	1.2;

1.2
date	2004.10.31.12.40.01;	author espie;	state Exp;
branches;
next	1.1;

1.1
date	2004.10.23.11.09.23;	author espie;	state Exp;
branches;
next	;


desc
@@


1.162
log
@tweak the ntogo messages slightly so that they work better in all situations
@
text
@# ex:ts=8 sw=4:
# $OpenBSD: Update.pm,v 1.161 2014/02/02 15:22:36 espie Exp $
#
# Copyright (c) 2004-2014 Marc Espie <espie@@openbsd.org>
#
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF

use strict;
use warnings;

package OpenBSD::Handle;
sub update
{
	my ($self, $updater, $set, $state) = @@_;

	return $updater->process_handle($set, $self, $state);
}

package OpenBSD::hint;
sub update
{
	my ($self, $updater, $set, $state) = @@_;

	return $updater->process_hint($set, $self, $state);
}

package OpenBSD::hint2;
sub update
{
	my ($self, $updater, $set, $state) = @@_;

	return $updater->process_hint2($set, $self, $state);
}

package OpenBSD::Update;
use OpenBSD::PackageInfo;
use OpenBSD::PackageName;
use OpenBSD::Error;
use OpenBSD::UpdateSet;

sub new
{
	my $class = shift;
	return bless {}, $class;
}

sub add_handle
{
	my ($self, $set, $old, $n) = @@_;
	$old->{update_found} = $n;
	$set->add_newer($n);
}

sub add_location
{
	my ($self, $set, $handle, $location) = @@_;

	$self->add_handle($set, $handle,
	    OpenBSD::Handle->from_location($location));
}

sub progress_message
{
	my ($self, $state, @@r) = @@_;
	my $msg = $state->f(@@r);
	$msg .= $state->ntogo_string;
	$state->progress->message($msg);
	$state->say($msg) if $state->verbose >= 2;
}

sub process_handle
{
	my ($self, $set, $h, $state) = @@_;
	my $pkgname = $h->pkgname;

	if ($pkgname =~ m/^\.libs\d*\-/o) {
		return 0;
	}

	if (!$set->{quirks}) {
		my $base = 0;
		$state->run_quirks(
		    sub {
			my $quirks = shift;
			$base = $quirks->is_base_system($h, $state);
		    });
		if ($base) {
			$h->{update_found} = OpenBSD::Handle->system;
			$set->{updates}++;
			return 1;
		}
	}

	my $plist = OpenBSD::PackingList->from_installation($pkgname,
	    \&OpenBSD::PackingList::UpdateInfoOnly);
	if (!defined $plist) {
		$state->fatal("can't locate #1", $pkgname);
	}

	if ($plist->has('firmware') && !$state->defines('FW_UPDATE')) {
		$set->move_kept($h);
		return 0;
	}

#	if (defined $plist->{url}) {
#		my $repo;
#		($repo, undef) = $state->repo->path_parse($plist->{url}->name);
#		$set->add_repositories($repo);
#	}
	my @@search = ();

	my $sname = $pkgname;
	while ($sname =~ s/^partial\-//o) {
	}
	push(@@search, OpenBSD::Search::Stem->split($sname));

	if (!$set->{quirks}) {
		$state->run_quirks(
		    sub {
			my $quirks = shift;
			$quirks->tweak_search(\@@search, $h, $state);
		    });
	}
	my $oldfound = 0;
	my @@skipped_locs = ();

	# XXX this is nasty: maybe we added an old set to update
	# because of conflicts, in which case the pkgpath +
	# conflict should be enough  to "match".
	for my $n ($set->newer) {
		if (($state->{hard_replace} ||
		    $n->location->update_info->match_pkgpath($plist)) &&
			$n->conflict_list->conflicts_with($sname)) {
				$self->add_handle($set, $h, $n);
				return 1;
		}
	}
	if (!$state->defines('downgrade')) {
		push(@@search, OpenBSD::Search::FilterLocation->more_recent_than($sname, \$oldfound));
	}
	push(@@search, OpenBSD::Search::FilterLocation->new(
	    sub {
		my $l = shift;
		if (@@$l == 0) {
			return $l;
		}
		my @@l2 = ();
		for my $loc (@@$l) {
		    if (!$loc) {
			    next;
		    }
		    my $p2 = $loc->update_info;
		    if (!$p2) {
			next;
		    }
		    if ($p2->has('arch')) {
			unless ($p2->{arch}->check($state->{arch})) {
			    $loc->forget;
			    next;
			}
		    }
		    if (!$plist->match_pkgpath($p2)) {
			push(@@skipped_locs, $loc);
			next
		    }
		    my $r = $plist->signature->compare($p2->signature);
		    if (defined $r && $r > 0 && !$state->defines('downgrade')) {
		    	$oldfound = 1;
			$loc->forget;
			next;
		    }
		    push(@@l2, $loc);
		}
		return \@@l2;
	    }));

	if (!$state->defines('allversions')) {
		push(@@search, OpenBSD::Search::FilterLocation->keep_most_recent);
	}

	my $l = $set->match_locations(@@search);

	for my $loc (@@skipped_locs) {
		if (@@$l == 0 && $state->verbose) {
			$self->say_skipped_packages($state, $plist,
				$loc->update_info);
		}
		$loc->forget;
	}

	if (@@$l == 0) {
		if ($oldfound) {
			$set->move_kept($h);
			$self->progress_message($state,
			    "No need to update #1", $pkgname);

			return 0;
		}
		return undef;
	}
	$state->say("Update candidates: #1 -> #2#3", $pkgname,
	    join(' ', map {$_->name} @@$l), $state->ntogo_string) 
		if $state->verbose;

	my $r = $state->choose_location($pkgname, $l);
	if (defined $r) {
		$self->add_location($set, $h, $r);
		return 1;
	} else {
		$state->{issues} = 1;
		return undef;
	}
}

sub say_skipped_packages
{
	my ($self, $state, $o, $n) = @@_;

	my $o_name = $o->pkgname;
	my @@o_ps = map { @@{$o->pkgpath->{$_}} } keys %{$o->pkgpath};
	my $o_pp = join(" ", map {$_->fullpkgpath} @@o_ps);

	my $n_name = $n->pkgname;
	my @@n_ps = map { @@{$n->pkgpath->{$_}} } keys %{$n->pkgpath};
	my $n_pp= join(" ", map {$_->fullpkgpath} @@n_ps);

	my $t  = "Skipping #1 (update candidate for #2)";
	   $t .= "\n\t#2 pkgpaths: #4\n\t#1 pkgpaths: #3";

	$state->say($t, $n_name, $o_name, $n_pp, $o_pp);
}

sub find_nearest
{
	my ($base, $locs) = @@_;

	my $pkgname = OpenBSD::PackageName->from_string($base);
	return undef if !defined $pkgname->{version};
	my @@sorted = sort {$a->pkgname->{version}->compare($b->pkgname->{version}) } @@$locs;
	if ($sorted[0]->pkgname->{version}->compare($pkgname->{version}) > 0) {
		return $sorted[0];
	}
	if ($sorted[-1]->pkgname->{version}->compare($pkgname->{version}) < 0) {
		return $sorted[-1];
	}
	return undef;
}

sub process_hint
{
	my ($self, $set, $hint, $state) = @@_;

	my $l;
	my $hint_name = $hint->pkgname;
	my $k = OpenBSD::Search::FilterLocation->keep_most_recent;
	# first try to find us exactly

	$self->progress_message($state, "Looking for #1", $hint_name);
	$l = $set->match_locations(OpenBSD::Search::Exact->new($hint_name), $k);
	if (@@$l == 0) {
		my $t = $hint_name;
		$t =~ s/\-\d([^-]*)\-?/--/;
		my @@search = (OpenBSD::Search::Stem->new($t));
		$state->run_quirks(
		    sub {
			my $quirks = shift;
			$quirks->tweak_search(\@@search, $hint, $state);
		    });
		$l = $set->match_locations(@@search, $k);
	}
	if (@@$l > 1) {
		my $r = find_nearest($hint_name, $l);
		if (defined $r) {
			$self->add_location($set, $hint, $r);
			return 1;
		}
	}
	my $r = $state->choose_location($hint_name, $l);
	if (defined $r) {
		$self->add_location($set, $hint, $r);
		OpenBSD::Add::tag_user_packages($set);
		return 1;
	} else {
		return 0;
	}
}

my $cache = {};

sub process_hint2
{
	my ($self, $set, $hint, $state) = @@_;
	my $pkgname = $hint->pkgname;
	if (OpenBSD::PackageName::is_stem($pkgname)) {
		if ($pkgname =~ m/[\/\:]/o) {
			my $repo;
			($repo, $pkgname) = $state->repo->path_parse($pkgname);
			$set->add_repositories($repo);
		};
		my $l = $state->updater->stem2location($set, $pkgname, $state,
		    $set->{quirks});
		if (defined $l) {
			$self->add_location($set, $hint, $l);
		} else {
			return undef;
		}
	} else {
		if (!defined $cache->{$pkgname}) {
			$self->add_handle($set, $hint, OpenBSD::Handle->create_new($pkgname));
			$cache->{$pkgname} = 1;
		}
	}
	OpenBSD::Add::tag_user_packages($set);
	return 1;
}

sub process_set
{
	my ($self, $set, $state) = @@_;
	my @@problems = ();
	for my $h ($set->older, $set->hints) {
		next if $h->{update_found};
		if (!defined $h->update($self, $set, $state)) {
			push(@@problems, $h->pkgname);
		}
	}
	if (@@problems > 0) {
		$state->tracker->cant($set) if !$set->{quirks};
		if ($set->{updates} != 0) {
			$state->say("Can't update #1: no update found for #2",
			    $set->print, join(',', @@problems));
		}
		return 0;
	} elsif ($set->{updates} == 0) {
		$state->tracker->uptodate($set);
		return 0;
	}
	$state->tracker->add_set($set);
	return 1;
}

sub stem2location
{
	my ($self, $locator, $name, $state, $is_quirks) = @@_;
	my $l = $locator->match_locations(OpenBSD::Search::Stem->new($name));
	if (@@$l > 1 && !$state->defines('allversions')) {
		$l = OpenBSD::Search::FilterLocation->keep_most_recent->filter_locations($l);
	}
	return $state->choose_location($name, $l, $is_quirks);
}

1;
@


1.161
log
@simplify how "kept" packages are handled. First, we never need their
full plist, just their update_info. Also, the routine for move_kept is
pretty much always the same, so fold it.

Finally, delay full plists in create_old.
@
text
@d2 1
a2 1
# $OpenBSD: Update.pm,v 1.160 2014/02/01 10:55:37 espie Exp $
d75 1
a75 3
	if ($state->{wantntogo}) {
		$msg .= " (".$state->ntogo.")";
	}
d210 3
a212 2
	$state->say("Update candidates: #1 -> #2 (#3)", $pkgname,
	    join(' ', map {$_->name} @@$l), $state->ntogo) if $state->verbose;
@


1.160
log
@no need to test for plist, we get the conflict_list since we have update_info
@
text
@d2 1
a2 1
# $OpenBSD: Update.pm,v 1.159 2014/01/24 11:41:23 espie Exp $
a111 1
		$h->{update_found} = $h;
a203 1
			$h->{update_found} = $h;
a204 1

@


1.159
log
@subject -z hints (fuzzy update) to quirks' tweak_search.
Reminded by sthen@@
This solves the 5.4 -> 5.5 delete/reinstall gap for changed pkgnames.
@
text
@d2 1
a2 1
# $OpenBSD: Update.pm,v 1.158 2014/01/11 11:51:01 espie Exp $
d145 1
a145 2
			defined $n->plist &&
			$n->plist->conflict_list->conflicts_with($sname)) {
@


1.158
log
@a bit of spring cleanup in advance: scrape old stuff that's not really
used.
@
text
@d2 1
a2 1
# $OpenBSD: Update.pm,v 1.157 2014/01/09 20:20:01 espie Exp $
d277 7
a283 1
		$l = $set->match_locations(OpenBSD::Search::Stem->new($t), $k);
@


1.157
log
@bump copyright to 2014
@
text
@d2 1
a2 1
# $OpenBSD: Update.pm,v 1.156 2014/01/05 10:24:30 espie Exp $
d111 1
a111 2
	if ($plist->has('explicit-update') && $state->{allupdates} ||
	    $plist->has('firmware') && !$state->defines('FW_UPDATE')) {
a177 5
		    }
		    if ($p2->has('explicit-update') && $state->{allupdates}) {
			$oldfound = 1;
			$loc->forget;
			next;
@


1.156
log
@have -DFW_UPDATE set @@option firmware on downloaded firmwares.
- normal pkg_add -u should ignore them
- pkg_delete will ask about deleting them

okay landry@@
@
text
@d2 1
a2 1
# $OpenBSD: Update.pm,v 1.155 2013/12/25 15:59:51 espie Exp $
d4 1
a4 1
# Copyright (c) 2004-2010 Marc Espie <espie@@openbsd.org>
@


1.155
log
@fix autoloading of quirks: don't try to run quirks while processing the
quirks set, as we may accidentally load the old one.
also, in case we can't load quirks, report if quirks should be there,
e.g., compilation error, without regard to verbose status
@
text
@d2 1
a2 1
# $OpenBSD: Update.pm,v 1.154 2013/12/25 14:20:48 espie Exp $
d111 2
a112 1
	if ($plist->has('explicit-update') && $state->{allupdates}) {
@


1.154
log
@a bit more scaffolding for running quirks. In particular, once quirks
have been loaded, complain loudly if something doesn't work.
(and complain when quirks don't load in !verbose mode)
@
text
@d2 1
a2 1
# $OpenBSD: Update.pm,v 1.153 2012/10/13 10:28:22 jeremy Exp $
d91 12
a102 10
	my $base = 0;
	$state->run_quirks(
	    sub {
	    	my $quirks = shift;
		$base = $quirks->is_base_system($h, $state);
	    });
	if ($base) {
		$h->{update_found} = OpenBSD::Handle->system;
		$set->{updates}++;
		return 1;
d129 7
a135 5
	$state->run_quirks(
	    sub {
	    	my $quirks = shift;
		$quirks->tweak_search(\@@search, $h, $state);
	    });
@


1.153
log
@In update verbose mode, when skipping an update candidate due to an
unmatching pkgpath, if no valid update candidates are found, print that
we are skipping the update candidate and all pkgpaths for both the
currently installed package and the skipped update candidate.

This is designed to help diagnosing issues when ports move locations
in the tree, but the necessary @@pkgpath entries are not correctly added
to the PLIST.

Much help and OK espie@@
@
text
@d2 1
a2 1
# $OpenBSD: Update.pm,v 1.152 2012/04/28 11:55:16 espie Exp $
d92 5
a96 3
	eval {
		$base = $state->quirks->is_base_system($h, $state);
	};
d127 5
a131 3
	eval {
		$state->quirks->tweak_search(\@@search, $h, $state);
	};
@


1.152
log
@cleaner code: only wrap the call to quirks itself inside an eval.
anything else that could fail shouldn't be inside the eval.
create an object instead of saying "hey we're cool, let's let other
stuff break horribly".
@
text
@d2 1
a2 1
# $OpenBSD$
d129 1
d168 1
a168 1
		    	$loc->forget;
d192 9
d224 18
@


1.151
log
@don't abort if that info is not yet available...
@
text
@d2 1
a2 1
# $OpenBSD: Update.pm,v 1.150 2011/08/26 08:46:10 espie Exp $
d91 1
a91 1

d93 1
a93 4
		if ($state->quirks->is_base_system($h, $state)) {
			$h->{update_found} = 1;
			$set->{updates}++;
		}
d95 5
a99 1
	return 1 if $h->{update_found};
@


1.150
log
@zap fatpackages. nobody actually uses them.
accordingly, locations do not need to track architecture.
@
text
@d2 1
a2 1
# $OpenBSD: Update.pm,v 1.149 2011/07/19 20:04:23 espie Exp $
d135 1
@


1.149
log
@tag fuzzy stuff for manual-installs too
@
text
@d2 1
a2 1
# $OpenBSD: Update.pm,v 1.148 2011/06/19 01:28:43 espie Exp $
a150 1
		    $loc->set_arch($state->{arch});
@


1.148
log
@another missing message
@
text
@d2 1
a2 1
# $OpenBSD: Update.pm,v 1.147 2010/12/24 09:04:14 espie Exp $
d257 1
@


1.147
log
@handle failures from ports tree with more care.
this does avoid infinite loops in case of wrong plists.
necessary since print-plist-with-depends CAN fail...
@
text
@d2 1
a2 1
# $OpenBSD$
d305 1
a305 1
			$state->say("Can't update #1: no update found for ",
@


1.146
log
@whitespace
@
text
@@


1.145
log
@bug-fix: during updates, only set oldfound after we found a matching pkgpath.
that way, we detect pkgpath problems as "can't update" instead of silently
ignoring them (gconf2 issue).
@
text
@d2 1
a2 1
# $OpenBSD: Update.pm,v 1.144 2010/07/31 11:17:22 espie Exp $
d195 1
a195 1
			$self->progress_message($state, 
@


1.144
log
@keep location open while we grab updateinfo.
deal with error fallout and need to forget unneeded stuff
(halves number of connections, roughly)
@
text
@d2 1
a2 1
# $OpenBSD: Update.pm,v 1.143 2010/07/26 23:28:06 espie Exp $
d165 4
d171 1
d180 1
a180 5
		    if ($plist->match_pkgpath($p2)) {
			push(@@l2, $loc);
			next
		    }
		    $loc->forget;
@


1.143
log
@better progress_message
@
text
@d2 1
a2 1
# $OpenBSD: Update.pm,v 1.142 2010/07/06 12:12:37 espie Exp $
d161 1
d172 1
d179 1
@


1.142
log
@fuss over wantntogo, especially when it's false (make sure we still get :ok
at end of lines instead of '' replacing 30/50)
@
text
@d2 1
a2 1
# $OpenBSD: Update.pm,v 1.141 2010/06/30 10:51:04 espie Exp $
d73 2
a74 1
	my ($self, $state, $msg) = @@_;
d191 2
a192 2
			$self->progress_message($state,
			    "No need to update $pkgname");
d236 1
a236 1
	$state->progress->message("Looking for $hint_name");
@


1.141
log
@allow say and errsay to work without parameters, as it's ways common.
create verbose_system up in state, because it makes sense without verbose.
@
text
@d2 1
a2 1
# $OpenBSD$
d74 3
a76 1
	$msg .= " (".$state->ntogo.")";
@


1.140
log
@whitespace cleanup
@
text
@@


1.139
log
@access locator through new API
@
text
@d2 1
a2 1
# $OpenBSD: Update.pm,v 1.138 2010/06/09 08:13:19 espie Exp $
@


1.138
log
@replace confusing (n to go) message with #done/#total annotations.
e.g.,
Checking packages|No change in apr-util-mt-1.2.10p4 (26/1530)
@
text
@d2 1
a2 1
# $OpenBSD: Update.pm,v 1.137 2010/06/09 07:26:01 espie Exp $
a109 1
#		require OpenBSD::PackageLocator;
d111 1
a111 1
#		($repo, undef) = OpenBSD::PackageLocator->path_parse($plist->{url}->name);
a263 1
			require OpenBSD::PackageLocator;
d265 1
a265 1
			($repo, $pkgname) = OpenBSD::PackageLocator->path_parse($pkgname);
@


1.137
log
@ui changes: go thru a state object for most printouts
@
text
@d2 1
a2 1
# $OpenBSD: Update.pm,v 1.136 2010/06/04 13:19:39 espie Exp $
d74 1
a74 1
	$msg .= $state->ntogo;
d196 1
a196 1
	$state->say("Update candidates: #1 -> #2", $pkgname,
@


1.136
log
@move code around, so that commands can be used as modules.
pkg becomes the start hub, which does nothing except require the
correct module.
Saner code wrt Add/Delete, and more sharing.
@
text
@d2 1
a2 1
# $OpenBSD: Update.pm,v 1.135 2010/05/10 09:17:55 espie Exp $
d100 1
a100 1
		Fatal("Can't locate $pkgname");
d196 1
a196 1
	$state->say("Update candidates: $pkgname -> ",
d300 2
a301 3
			$state->say("Can't update ", $set->print,
			    ": no update found for ",
			    join(',', @@problems));
@


1.135
log
@whitespace fixes
@
text
@d2 1
a2 1
# $OpenBSD$
d138 1
a138 1
	if (!$state->{defines}->{downgrade}) {
d167 1
a167 1
		    if (defined $r && $r > 0 && !$state->{defines}{downgrade}) {
d179 1
a179 1
	if (!$state->{defines}->{allversions}) {
d317 1
a317 1
	if (@@$l > 1 && !$state->{defines}->{allversions}) {
@


1.134
log
@downgrade, not downgrades
@
text
@d67 1
a67 1
	$self->add_handle($set, $handle, 
d97 1
a97 1
	my $plist = OpenBSD::PackingList->from_installation($pkgname, 
d127 2
a128 2
	# XXX this is nasty: maybe we added an old set to update 
	# because of conflicts, in which case the pkgpath + 
d131 1
a131 1
		if (($state->{hard_replace} || 
d189 1
a189 1
			$self->progress_message($state, 
d191 1
a191 1
			
d196 1
a196 1
	$state->say("Update candidates: $pkgname -> ", 
d198 1
a198 1
		
d270 1
a270 1
		my $l = $state->updater->stem2location($set, $pkgname, $state, 
d300 2
a301 2
			$state->say("Can't update ", $set->print, 
			    ": no update found for ", 
d308 1
a308 1
	} 
d322 1
a322 1
 
@


1.133
log
@use full signatures to avoid downgrades.
remove double check in update that properly belongs in pkg_add
replace has_new_sig by has_different_sig, with better diagnostic messages.
@
text
@d167 1
a167 1
		    if (defined $r && $r > 0 && !$state->{defines}{downgrades}) {
@


1.132
log
@zap unused
@
text
@a124 1
	my $found;
d166 3
a168 3
		    if ($plist->signature->compare($p2->signature) eq 0) {
			$found = $loc;
			push(@@l2, $loc);
a195 13
	if (@@$l == 1) {
		if (defined $found && $found eq $l->[0] &&
		    !$plist->uses_old_libs && !$state->{defines}->{installed}) {
			$h->{update_found} = $h;
			$set->move_kept($h);

			$self->progress_message($state, 
			    "No need to update $pkgname");

			return 0;
		}
	}

@


1.131
log
@streamline interface
@
text
@d112 1
a112 1
#		($repo, undef, undef) = OpenBSD::PackageLocator->path_parse($plist->{url}->name);
d281 1
a281 1
			($repo, undef, $pkgname) = OpenBSD::PackageLocator->path_parse($pkgname);
@


1.130
log
@fixed version, somehow I forgot that I use parse to do weird things with
PKG_PATH...
@
text
@d112 1
a112 1
#		($repo, undef, undef) = OpenBSD::PackageLocator::path_parse($plist->{url}->name);
d281 1
a281 1
			($repo, undef, $pkgname) = OpenBSD::PackageLocator::path_parse($pkgname);
@


1.129
log
@temporary revert until I figure this out
@
text
@d278 1
a278 1
		if ($pkgname =~ m/\//o) {
@


1.128
log
@tweak path parsing to handle inst:pkgname and such as well...
@
text
@d278 1
a278 1
		if ($pkgname =~ m/[\/\:]/o) {
@


1.127
log
@first step in comparing full signatures: make them full objects, with
proper sign/compare interfaces.
@
text
@d278 1
a278 1
		if ($pkgname =~ m/\//o) {
@


1.126
log
@for -z/-l, if several candidates are found, try to order them, and use the
nearest to the hint if they all have larger/smaller versions.
@
text
@d149 3
a151 3
		for my $handle (@@$l) {
		    $handle->set_arch($state->{arch});
		    if (!$handle) {
d154 1
a154 1
		    my $p2 = $handle->update_info;
d167 3
a169 3
		    if ($plist->signature eq $p2->signature) {
			$found = $handle;
			push(@@l2, $handle);
d173 2
a174 1
			push(@@l2, $handle);
@


1.125
log
@explicit-update support
(also url support, but commented out for now)
@
text
@d222 16
d253 7
@


1.124
log
@(C) of affected files
@
text
@d103 12
d162 4
@


1.123
log
@store repository paths in sets and propagate them.
This fixes pkg_add /some/path/package
which will now find dependencies in the same path again.
@
text
@d4 1
a4 1
# Copyright (c) 2004-2006 Marc Espie <espie@@openbsd.org>
@


1.122
log
@an actual difference between -r and -u. If we replace, don't look as hard
for conflict matching.
@
text
@a45 1
use OpenBSD::PackageLocator;
d167 1
a167 1
	my $l = OpenBSD::PackageLocator->match_locations(@@search);
d216 1
a216 1
	$l = OpenBSD::PackageLocator->match_locations(OpenBSD::Search::Exact->new($hint_name), $k);
d220 1
a220 1
		$l = OpenBSD::PackageLocator->match_locations(OpenBSD::Search::Stem->new($t), $k);
a237 1
		my ($h, $path, $repo);
d239 6
a244 7
			($repo, $path, $pkgname) = OpenBSD::PackageLocator::path_parse($pkgname);
			$h = $repo;
		} else {
			$h = 'OpenBSD::PackageLocator';
			$path = "";
		}
		my $l = $state->updater->stem2location($h, $pkgname, $state, 
d289 2
a290 2
	my ($self, $repo, $name, $state, $is_quirks) = @@_;
	my $l = $repo->match_locations(OpenBSD::Search::Stem->new($name));
@


1.121
log
@zap message for .libs, be smart about partial-*, it's easy to install/update
actually
@
text
@d121 2
a122 1
		if ($n->location->update_info->match_pkgpath($plist) &&
@


1.120
log
@avoid infinite loop, noticed by Rivo Nurges.
@
text
@a79 1
my $first = 1;
a85 10
		if ($first) {
			$state->say("Not updating .libs*, remember to clean them");
			$first = 0;
		}
		return 0;
	}
	if ($pkgname =~ m/^partial\-/o) {
		$state->say("Not updating $pkgname, remember to clean it");
		$h->{update_found} = $h;
		$set->move_kept($h);
d105 5
a109 1
	push(@@search, OpenBSD::Search::Stem->split($pkgname));
d122 1
a122 1
			$n->plist->conflict_list->conflicts_with($pkgname)) {
d128 1
a128 1
		push(@@search, OpenBSD::Search::FilterLocation->more_recent_than($pkgname, \$oldfound));
@


1.119
log
@change verbosity handling: be silent by default, turn on the first level if -v.
Add more levels, specifically, lots of info regarding individual files only
visible if -vvvvv.
Make -n display the same stuff as normal (need -n -v to display more stuff).
Introduce -s, "size-only", turns on -n and does skip any extraction.
Sprinkle handlers for SIG_INFO, not really nice yet.

Note that -n is non functional for complex updates, because of caching
issues I have to fix.
@
text
@d95 1
@


1.118
log
@since some packages in updatesets don't need updates, be explicit about it.
This is more complex and simpler at the same time...
@
text
@d77 1
a77 1
	$state->say($msg) if $state->{beverbose};
d200 1
a200 1
	    join(' ', map {$_->name} @@$l), $state->ntogo);
@


1.117
log
@combined updates show the packages that can't be updated
@
text
@d95 1
a95 1
		$h->{keepit} = 1;
d177 1
a177 1
			$h->{keepit} = 1;
d190 1
a190 1
			$h->{keepit} = 1;
@


1.116
log
@fuss about install msgs: new method state->ntogo, use it to annotate more
messages with global progress information.

Also, when not finding a suitable update, report it if set is not a simple
update. Helps in figuring out cases like gstreamer...
@
text
@d272 1
a272 1
	my $problem;
d276 1
a276 1
			$problem = 1;
d279 1
a279 1
	if ($problem) {
d282 3
a284 1
			$state->say("Can't update ", $set->print);
@


1.115
log
@okay, so old libs are not 'kept', keep track of updates correctly instead
@
text
@d72 8
d178 4
a181 6
			my $msg = "No need to update $pkgname";
			if (defined $state->{todo} && $state->{todo} > 0) {
				$msg .= " ($state->{todo} to go)";
			}
			$state->progress->message($msg);
			$state->say($msg) if $state->{beverbose};
d191 4
a194 6
			my $msg = "No need to update $pkgname";
			if (defined $state->{todo} && $state->{todo} > 0) {
				$msg .= " ($state->{todo} to go)";
			}
			$state->progress->message($msg);
			$state->say($msg) if $state->{beverbose};
d199 2
a200 2
	$state->say("Candidates for updating $pkgname -> ", 
	    join(' ', map {$_->name} @@$l));
d281 3
@


1.114
log
@fix the fam->libgamin issue. Look for update candidates in self before
asking the repository. This solves this kind of conflicts.
also, register packages we keep, this makes for simpler scenarios
(todo: split updateset into further categories)
@
text
@a82 1
		$h->{keepit} = 1;
d95 1
d278 1
a278 1
	} elsif ($set->older_to_do == 0 && $set->newer == 0) {
@


1.113
log
@simplify tracker a bit now we know what we're doing.
kill code that never got used
@
text
@d83 1
d88 1
d115 10
a166 9
		# XXX this is nasty: maybe we added an old set to update 
		# because of conflicts, in which case the pkgpath + 
		# conflict should be enough  to "match".
		for my $n ($set->newer) {
			if ($n->location->update_info->match_pkgpath($plist)) {
				$self->add_handle($set, $h, $n);
				return 1;
			}
		}
d169 1
d184 1
d271 1
a271 3
		my $r = $h->update($self, $set, $state);

		if (!defined $r) {
a272 2
		} else {
			$set->{updates} += $r;
d278 1
a278 1
	} elsif ($set->{updates} == 0 && $set->newer == 0) {
@


1.112
log
@use eval {} everywhere around quirks.
also, remove quirks from the list of packages to update, since it deserves
special treatment...
@
text
@d275 1
a275 1
		$state->tracker->mark_cant_update($set) if !$set->{quirks};
d278 1
a278 1
		$state->tracker->mark_uptodate($set);
@


1.111
log
@better quirks interface: pass the search object that was built, so we can
adjust it (eventually, pass the whole list ?)
@
text
@d91 1
a91 1
	if ($state->quirks) {
a93 1
			return 1;
d95 2
a96 1
	}
d107 1
a107 1
	if ($state->quirks) {
d109 1
a109 1
	}
@


1.110
log
@oops
@
text
@d2 1
a2 1
# $OpenBSD: Update.pm,v 1.109 2009/12/05 10:08:58 espie Exp $
d105 2
a106 1
	my $s;
d108 1
a108 4
		$s = $state->quirks->search_object($h, $state);
	}
	if (!$s) {
		$s = OpenBSD::Search::Stem->split($pkgname);
a109 2
	push(@@search, $s);

@


1.109
log
@make quirks silent. Track # of updates found, instead of newer size, since
we may end up updating sets with newer == 0
@
text
@d2 1
a2 1
# $OpenBSD$
d281 1
a281 1
	} elsif ($set->{updates} == 0) {
@


1.108
log
@set-up for quirks, just don't do it yet.
@
text
@d90 1
d92 1
a92 1
		if ($state->quirks->is_base_system($h)) {
d97 1
d107 1
a107 1
		$s = $state->quirks->search_object($h);
d247 2
a248 1
		my $l = $state->updater->stem2location($h, $pkgname, $state);
d270 3
a272 1
		if (!defined $h->update($self, $set, $state)) {
d274 2
d279 1
a279 1
		$state->tracker->mark_cant_update($set);
d281 1
a281 1
	} elsif ($set->newer == 0) {
d291 1
a291 1
	my ($self, $repo, $name, $state) = @@_;
d296 1
a296 1
	return $state->choose_location($name, $l);
@


1.107
log
@tweak the rules a bit: the search filter for "more recent than" ought to
notice it sees older stuff. Even if they get filtered later on, this would
turn into a "no need to update".

(in actual use, I probably will need to open those packages and look at
the pkgpaths to make sure they are not valid candidates, and to compare
full signatures... oh well)
@
text
@d90 6
d102 9
a111 2
	my @@search = ();
	push(@@search, OpenBSD::Search::Stem->split($pkgname));
@


1.106
log
@in the worst case, we find a new handle with the right pkgpath,
independently of the name...
@
text
@d100 1
d103 1
a103 1
		push(@@search, OpenBSD::Search::FilterLocation->more_recent_than($pkgname));
d152 10
@


1.105
log
@todo all over
@
text
@d89 8
a99 1
	my $plist;
a110 4
		$plist = OpenBSD::PackingList->from_installation($pkgname, \&OpenBSD::PackingList::UpdateInfoOnly);
		if (!defined $plist) {
			Fatal("Can't locate $pkgname");
		}
d143 9
@


1.104
log
@zap pkgpath totally, set up to display (to go) as well.
@
text
@d147 1
a147 1
			if ($state->{todo} > 0) {
@


1.103
log
@better name. Mark "no need to update" as updated, since we know what's
going on...
@
text
@a102 3
		if (@@$l == 1 && $state->{defines}->{pkgpath}) {
			return $l;
		}
d147 3
@


1.102
log
@typo
@
text
@d60 1
a60 1
	$old->{update} = $n;
a145 5
		if ($state->{defines}->{pkgpath}) {
			$state->say("Directly updating $pkgname -> ", $l->[0]->name);
			$self->add_location($set, $h, $l->[0]);
			return 1;
		}
d148 5
a152 4
				my $msg = "No need to update $pkgname";
				$state->progress->message($msg);
				$state->say($msg) if $state->{beverbose};
				return 0;
d230 1
a230 1
		next if $h->{update};
@


1.101
log
@less verbose display: only shows .libs* once, but still show all partial-*
@
text
@d215 1
a215 1
			$self->add_ulocation($set, $hint, $l);
@


1.100
log
@change the timing a bit: create a list of updateset first, and process
them later.

To do that, normal additions go through hint2, and the findtruelocation
code moves to Update.pm

This will allow for more systematic handling of all names (including solving
more stuff on the fly, instead of upfront).
@
text
@d72 1
d78 8
a85 1
	if ($pkgname =~ m/^(?:\.libs\d*|partial)\-/o) {
@


1.99
log
@revamp interactive stuff: simplify (just one always for everything, per
theo suggestion. Also go through the "state" object which simplifies code
a great deal)
@
text
@d20 24
d57 8
a64 1
sub add_updateset
d68 2
a69 3
	my $n = OpenBSD::Handle->from_location($location);
	$handle->{done} = $n;
	$set->add_newer($n);
a75 4
	if (defined $h->{update}) {
		$state->say("Update to $pkgname already found");
		return 0;
	}
d140 1
a140 1
			$self->add_updateset($set, $h, $l->[0]);
d157 1
a157 1
		$self->add_updateset($set, $h, $r);
d183 1
a183 1
		$self->add_updateset($set, $hint, $r);
d190 31
d225 3
a227 5
	my $need_update;
	for my $h ($set->older) {
		next if $h->{done};
		my $r = $self->process_handle($set, $h, $state);
		if (!defined $r) {
a229 13
		if ($r) {
			$need_update = 1;
		}
	}
	for my $h ($set->hints) {
		next if $h->{done};
		my $r = $self->process_hint($set, $h, $state);
		if (!defined $r) {
			$problem = 1;
		}
		if ($r) {
			$need_update = 1;
		}
d234 1
a234 1
	} elsif (!$need_update) {
d238 1
d242 10
@


1.98
log
@typo
@
text
@a20 1
use OpenBSD::Interactive;
@


1.97
log
@oops
@
text
@d191 1
a191 1
		$state->tracker->mark_cantupdate($set);
@


1.96
log
@typo
@
text
@d149 1
a149 1
	$state->progress->message("Looking for $hint");
@


1.95
log
@unify hints and normal updates some more
@
text
@d194 1
a194 1
		$state->tracker->mark_uptoupdate($set);
@


1.94
log
@unify hint and location processing some more.
@
text
@d165 35
@


1.93
log
@progressmeter puts STDOUT in autoflush if -t, so that it can display to it instead of piping a lot of stuff to STDERR.

Go through state->print for most messages, so they will NOT do weird things
with the progressmeter.
Use a ->say shortcut which does the same thing that perl 5.10 say does...
@
text
@d39 1
d145 1
d150 1
a150 1
	$l = OpenBSD::PackageLocator->match_locations(OpenBSD::Search::Exact->new($hint), $k);
d152 1
a152 1
		my $t = $hint;
d156 1
a156 1
	my $r = $state->choose_location($hint, $l);
d158 1
a158 1
		$self->add_updateset($set, undef, $r);
@


1.92
log
@state->progress->print => $state->print
@
text
@d47 1
a47 2
		$state->progress->clear;
		print "Update to $pkgname already found\n";
d52 1
a52 2
		$state->progress->clear;
		print "Not updating $pkgname, remember to clean it\n";
d113 1
a113 2
			$state->progress->clear;
			print "Directly updating $pkgname -> ", $l->[0]->name, "\n";
d121 1
a121 1
				print "$msg\n" if $state->{beverbose};
d126 2
a127 1
	$state->print("Candidates for updating $pkgname -> ", join(' ', map {$_->name} @@$l), "\n");
@


1.91
log
@bad espie: use strict/warnings consistently, and fix two nits and two
actual errors !
@
text
@d129 1
a129 1
	$state->progress->print("Candidates for updating $pkgname -> ", join(' ', map {$_->name} @@$l), "\n");
@


1.90
log
@okay, so updates become "true" updates: unless you say -F downgrade
then packages with an older version will be filtered out.
@
text
@d16 1
a16 1
#
@


1.89
log
@add the notion of "hints" to UpdateSet, in order to unify -z/-l handling:
create updatesets with nothing but a hint of what to install. Have
Update.pm do the dirty work.

More importantly, make Tracker aware of what's going on.
@
text
@d62 3
@


1.88
log
@missed one
@
text
@d138 24
@


1.87
log
@add a few comments, finish killing kitchensink.
@
text
@d45 1
a45 1
	my $pkgname = $h->{pkgname};
@


1.86
log
@use choose_location
@
text
@d37 1
a37 1
 
d51 1
a51 1
 
d117 1
a117 1
		if (defined $found && $found eq $l->[0] && 
@


1.85
log
@deal with UpdateSets earlier: build an updateset, and ask Update to complete
it.

Tweak the control for updates to move to main program. Eventually, we will
run updates on the fly (there's still some merging code and debugging to go)
@
text
@a105 1

d126 1
a126 3
	$state->progress->clear;
	my %cnd = map {($_->name, $_)} @@$l;
	print "Candidates for updating $pkgname -> ", join(' ', keys %cnd), "\n";
d128 3
a130 2
	if (@@$l == 1) {
		$self->add_updateset($set, $h, $l->[0]);
a131 12
	}
	my $result = OpenBSD::Interactive::choose1($pkgname, 
	    $state->{interactive}, sort keys %cnd);
	if (defined $result) {
		if (defined $found && $found eq $result && 
		    !$plist->uses_old_libs) {
			print "No need to update $pkgname\n";
			return 0;
		} else {
			$self->add_updateset($set, $h, $cnd{$result});
			return 1;
		}
@


1.84
log
@fix direct pkgpath case
@
text
@d26 1
d31 1
a31 1
	return bless {cant => [], updates => []}, $class;
d34 1
a34 1
sub cant
d36 4
a39 2
	my $self = shift;
	return $self->{cant};
d42 1
a42 1
sub updates
d44 8
a51 19
	my $self = shift;
	return $self->{updates};
}

sub add2cant
{
	my ($self, @@args) = @@_;
	push(@@{$self->{cant}}, @@args);
}

sub add2updates
{
	my ($self, @@args) = @@_;
	push(@@{$self->{updates}}, @@args);
}

sub process_package
{
	my ($self, $pkgname, $state) = @@_;
d55 1
a55 1
		return;
d109 1
a109 2
		$self->add2cant($pkgname);
		return;
d115 2
a116 2
			$self->add2updates($l->[0]);
			return;
d118 1
a118 1
		if (defined $found && $found eq  $l->[0] && 
d123 1
a123 1
				return;
d132 2
a133 2
		$self->add2updates($l->[0]);
		return;
d141 1
d143 2
a144 1
			$self->add2updates($cnd{$result});
d148 1
a149 19
}

sub process
{
	my ($self, $old, $state) = @@_;
	my @@list = ();

	OpenBSD::PackageInfo::solve_installed_names($old, \@@list, "(updating them all)", $state);
	unless (defined $state->{full_update} or defined $state->{defines}->{noclosure}) {
		require OpenBSD::RequiredBy;

		@@list = OpenBSD::Requiring->compute_closure(@@list);
	}

	$state->progress->set_header("Looking for updates");
	for my $pkgname (@@list) {
		$self->process_package($pkgname, $state);
	}
	$state->progress->next;
@


1.83
log
@synch with my new style search/location changes
It's likely there will be some fallout, but it's getting a bit too large
to keep around.
This does kill a few very old oddities as well.
@
text
@d124 1
a124 1
			$self->add2updates($l->[0]->name);
@


1.82
log
@rename forced to defines
@
text
@a66 4
	if (!$state->{defines}->{allversions}) {
		push(@@search, OpenBSD::Search::Filter->keep_most_recent);
	}

d70 1
a70 1
	push(@@search, OpenBSD::Search::Filter->new(
d72 3
a74 3
		my @@l = @@_;
		if (@@l == 0) {
			return @@l;
d76 2
a77 2
		if (@@l == 1 && $state->{defines}->{pkgpath}) {
			return @@l;
d84 2
a85 2
		for my $candidate (@@l) {
		    my $handle = OpenBSD::PackageLocator->find($candidate, $state->{arch});
d89 1
a89 2
		    $handle->close_now;
		    my $p2 = $handle->plist(\&OpenBSD::PackingList::UpdateInfoOnly);
d99 2
a100 2
			$found = $candidate;
			push(@@l2, $candidate);
d103 2
a104 9
		    if ($p2->{extrainfo}->{subdir} eq $plist->{extrainfo}->{subdir}) {
			push(@@l2, $candidate);
		    } elsif ($p2->has('pkgpath')) {
			for my $p (@@{$p2->{pkgpath}}) {
				if ($p->{name} eq $plist->{extrainfo}->{subdir}) {
					push(@@l2, $candidate);
					last;
				}
			}
d107 1
a107 1
		return @@l2;
d110 4
d115 2
a116 2
	my @@l = OpenBSD::PackageLocator->match(@@search);
	if (@@l == 0) {
d120 1
a120 1
	if (@@l == 1) {
d123 2
a124 2
			print "Directly updating $pkgname -> ", $l[0], "\n";
			$self->add2updates($l[0]);
d127 1
a127 1
		if (defined $found && $found eq  $l[0] && 
d137 2
a138 1
	print "Candidates for updating $pkgname -> ", join(' ', @@l), "\n";
d140 2
a141 2
	if (@@l == 1) {
		$self->add2updates($l[0]);
d145 1
a145 1
	    $state->{interactive}, sort @@l);
d151 1
a151 1
			$self->add2updates($result);
@


1.81
log
@obey -F installed
noticed by kurt@@, tested by him too.
@
text
@d2 1
a2 1
# $OpenBSD: Update.pm,v 1.80 2007/06/09 11:16:54 espie Exp $
d67 1
a67 1
	if (!$state->{forced}->{allversions}) {
d80 1
a80 1
		if (@@l == 1 && $state->{forced}->{pkgpath}) {
d129 1
a129 1
		if ($state->{forced}->{pkgpath}) {
d136 1
a136 1
		    !$plist->uses_old_libs && !$state->{forced}->{installed}) {
d171 1
a171 1
	unless (defined $state->{full_update} or defined $state->{forced}->{noclosure}) {
@


1.80
log
@rework `special' package names a bit.
- do a test to create partial-foo-1.0.1 instead of partial-partial-foo-1.0
when removing partial-foo fails.
- have .libs name generation, e.g., .libs-foo, then .libs1-foo, then .libs2-foo
instead of .libs-.libs-foo.... extend the pkgspec pattern slightly, so
that all these are more or less equivalent for dependencies and conflicts.

With this, we can do practically any scenario of shared libs updates and
downgrades.
@
text
@d2 1
a2 1
# $OpenBSD: Update.pm,v 1.79 2007/06/04 14:40:39 espie Exp $
d136 1
a136 1
		    !$plist->uses_old_libs) {
@


1.79
log
@some minor systematic changes.
- mark all regexps I can with /o if they can be compiled once.
- turn $o->method() into $o->method
- remove unneeded prototypes
- reduce split /re/ into split "string" where possible.
@
text
@d2 1
a2 1
# $OpenBSD: Update.pm,v 1.78 2007/06/01 14:58:29 espie Exp $
d60 1
a60 1
	if ($pkgname =~ m/^(?:\.libs|partial)\-/o) {
@


1.78
log
@refactor ProgressMeter code to create objects, put these into state.
Create a common state class for delete and add, put the progressmeter
creation in there.

neat effect: we don't have a progressmeter, we use a stub class instead
and *never* pull the code in at all.
@
text
@d2 1
a2 1
# $OpenBSD: Update.pm,v 1.77 2007/05/14 11:22:00 espie Exp $
d60 1
a60 1
	if ($pkgname =~ m/^(?:\.libs|partial)\-/) {
d103 1
a103 1
		    if ($plist->signature() eq $p2->signature()) {
@


1.77
log
@redo search filters as real objects. Accordingly, rename match_list to
filter.
@
text
@d2 1
a2 1
# $OpenBSD: Update.pm,v 1.76 2007/05/14 10:53:31 espie Exp $
a20 1
use OpenBSD::ProgressMeter;
d61 1
a61 1
		OpenBSD::ProgressMeter::clear();
d130 1
a130 1
			OpenBSD::ProgressMeter::clear();
d138 1
a138 1
				OpenBSD::ProgressMeter::message($msg);
d144 1
a144 1
	OpenBSD::ProgressMeter::clear();
d177 1
a177 1
	OpenBSD::ProgressMeter::set_header("Looking for updates");
d181 1
a181 1
	OpenBSD::ProgressMeter::next();
@


1.76
log
@put search objects into a search class.
@
text
@d2 1
a2 1
# $OpenBSD: Update.pm,v 1.75 2007/05/14 09:29:07 espie Exp $
d66 5
a70 1
	my $stem = OpenBSD::Search::Stem->split($pkgname);
d75 2
a76 1
	my $filter = sub {
a80 3
		if (@@l > 1 && !$state->{forced}->{allversions}) {
		    @@l = OpenBSD::PackageName::keep_most_recent(@@l);
		}
d121 1
a121 1
	};
d124 1
a124 1
	my @@l = OpenBSD::PackageLocator->match($stem, $filter);
@


1.75
log
@simplify updater slightly
@
text
@d2 1
a2 1
# $OpenBSD: Update.pm,v 1.74 2007/05/13 16:58:13 espie Exp $
d66 1
a66 1
	my $stem = OpenBSD::PackageName::Stem->split($pkgname);
@


1.74
log
@next -> return
@
text
@d2 1
a2 1
# $OpenBSD: Update.pm,v 1.73 2007/05/13 13:32:36 espie Exp $
d127 5
a131 12
	if (@@l == 1 && $state->{forced}->{pkgpath}) {
		OpenBSD::ProgressMeter::clear();
		print "Directly updating $pkgname -> ", $l[0], "\n";
		$self->add2updates($l[0]);
		return;
	}

	if (defined $found && @@l == 1 && $found eq  $l[0]) {
		if (!$plist->uses_old_libs) {
			my $msg = "No need to update $pkgname";
			OpenBSD::ProgressMeter::message($msg);
			print "$msg\n" if $state->{beverbose};
d134 7
d142 1
a144 5
	# if all packages have the same version, but distinct p,
	# grab the most recent.
	if (@@l > 1) {
	    @@l = OpenBSD::PackageName::keep_most_recent(@@l);
	}
d147 9
a155 4
		if (defined $found && $found eq  $l[0] && !$plist->uses_old_libs) {
			my $msg = "No need to update $pkgname";
			OpenBSD::ProgressMeter::message($msg);
			print "$msg\n" if $state->{beverbose};
d157 1
a157 1
			$self->add2updates($l[0]);
a158 2
	} elsif (@@l == 0) {
		$self->add2cant($pkgname);
d160 1
a160 10
		my $result = OpenBSD::Interactive::choose1($pkgname, $state->{interactive}, sort @@l);
		if (defined $result) {
			if (defined $found && $found eq  $result && !$plist->uses_old_libs) {
				print "No need to update $pkgname\n";
			} else {
				$self->add2updates($result);
			}
		} else {
			$state->{issues} = 1;
		}
@


1.73
log
@unify object lookup as locator->match($o) or $repo->match($o)
@
text
@d2 1
a2 1
# $OpenBSD: Update.pm,v 1.72 2007/05/13 12:19:28 espie Exp $
d64 1
a64 1
		next;
@


1.72
log
@reorg the update code some more, so that it goes through a filtering
of candidates.
@
text
@d2 1
a2 1
# $OpenBSD: Update.pm,v 1.71 2007/05/13 11:14:25 espie Exp $
d66 1
a66 1
	my $stem = OpenBSD::PackageName::splitstem($pkgname);
d122 1
a122 1
	my @@l = OpenBSD::PackageLocator->findstem($stem, $filter);
@


1.71
log
@move most of the code into one process_package method
@
text
@d2 1
a2 1
# $OpenBSD: Update.pm,v 1.70 2007/05/13 10:43:33 espie Exp $
d67 56
a122 1
	my @@l = OpenBSD::PackageLocator->findstem($stem);
a126 4
	my @@l2 = ();
	if (@@l > 1 && !$state->{forced}->{allversions}) {
	    @@l = OpenBSD::PackageName::keep_most_recent(@@l);
	}
a132 34
	my $plist = OpenBSD::PackingList->from_installation($pkgname, \&OpenBSD::PackingList::UpdateInfoOnly);
	if (!defined $plist) {
		Fatal("Can't locate $pkgname");
	}
	my $found;
	for my $candidate (@@l) {
	    my $handle = OpenBSD::PackageLocator->find($candidate, $state->{arch});
	    if (!$handle) {
		    next;
	    }
	    $handle->close_now;
	    my $p2 = $handle->plist(\&OpenBSD::PackingList::UpdateInfoOnly);
	    if (!$p2) {
		next;
	    }
	    if ($p2->has('arch')) {
		unless ($p2->{arch}->check($state->{arch})) {
		    next;
		}
	    }
	    if ($plist->signature() eq $p2->signature()) {
		$found = $candidate;
	    }
	    if ($p2->{extrainfo}->{subdir} eq $plist->{extrainfo}->{subdir}) {
		push(@@l2, $candidate);
	    } elsif ($p2->has('pkgpath')) {
		for my $p (@@{$p2->{pkgpath}}) {
			if ($p->{name} eq $plist->{extrainfo}->{subdir}) {
				push(@@l2, $candidate);
				last;
			}
		}
	    }
	}
d134 1
a134 1
	if (defined $found && @@l2 == 1 && $found eq  $l2[0]) {
d143 1
a143 1
	print "Candidates for updating $pkgname -> ", join(' ', @@l2), "\n";
d146 2
a147 2
	if (@@l2 > 1) {
	    @@l2 = OpenBSD::PackageName::keep_most_recent(@@l2);
d150 2
a151 2
	if (@@l2 == 1) {
		if (defined $found && $found eq  $l2[0] && !$plist->uses_old_libs) {
d156 1
a156 1
			$self->add2updates($l2[0]);
d158 1
a158 1
	} elsif (@@l2 == 0) {
d161 1
a161 1
		my $result = OpenBSD::Interactive::choose1($pkgname, $state->{interactive}, sort @@l2);
@


1.70
log
@turn the updater into an object
@
text
@d2 1
a2 1
# $OpenBSD: Update.pm,v 1.69 2007/05/07 14:12:43 espie Exp $
d58 99
d171 1
a171 94
		if ($pkgname =~ m/^(?:\.libs|partial)\-/) {
			OpenBSD::ProgressMeter::clear();
			print "Not updating $pkgname, remember to clean it\n";
			next;
		}
		my $stem = OpenBSD::PackageName::splitstem($pkgname);
		my @@l = OpenBSD::PackageLocator->findstem($stem);
		if (@@l == 0) {
			$self->add2cant($pkgname);
			next;
		}
		my @@l2 = ();
		if (@@l > 1 && !$state->{forced}->{allversions}) {
		    @@l = OpenBSD::PackageName::keep_most_recent(@@l);
		}
		if (@@l == 1 && $state->{forced}->{pkgpath}) {
			OpenBSD::ProgressMeter::clear();
			print "Directly updating $pkgname -> ", $l[0], "\n";
			$self->add2updates($l[0]);
			next;
		}
		my $plist = OpenBSD::PackingList->from_installation($pkgname, \&OpenBSD::PackingList::UpdateInfoOnly);
		if (!defined $plist) {
			Fatal("Can't locate $pkgname");
		}
		my $found;
		for my $candidate (@@l) {
		    my $handle = OpenBSD::PackageLocator->find($candidate, $state->{arch});
		    if (!$handle) {
			    next;
		    }
		    $handle->close_now;
		    my $p2 = $handle->plist(\&OpenBSD::PackingList::UpdateInfoOnly);
		    if (!$p2) {
		    	next;
		    }
		    if ($p2->has('arch')) {
			unless ($p2->{arch}->check($state->{arch})) {
			    next;
			}
		    }
		    if ($plist->signature() eq $p2->signature()) {
		    	$found = $candidate;
		    }
		    if ($p2->{extrainfo}->{subdir} eq $plist->{extrainfo}->{subdir}) {
			push(@@l2, $candidate);
		    } elsif ($p2->has('pkgpath')) {
		    	for my $p (@@{$p2->{pkgpath}}) {
				if ($p->{name} eq $plist->{extrainfo}->{subdir}) {
					push(@@l2, $candidate);
					last;
				}
		    	}
		    }
		}

		if (defined $found && @@l2 == 1 && $found eq  $l2[0]) {
			if (!$plist->uses_old_libs) {
				my $msg = "No need to update $pkgname";
				OpenBSD::ProgressMeter::message($msg);
				print "$msg\n" if $state->{beverbose};
				next;
			}
		}
		OpenBSD::ProgressMeter::clear();
		print "Candidates for updating $pkgname -> ", join(' ', @@l2), "\n";
		# if all packages have the same version, but distinct p,
		# grab the most recent.
		if (@@l2 > 1) {
		    @@l2 = OpenBSD::PackageName::keep_most_recent(@@l2);
		}
			
		if (@@l2 == 1) {
			if (defined $found && $found eq  $l2[0] && !$plist->uses_old_libs) {
				my $msg = "No need to update $pkgname";
				OpenBSD::ProgressMeter::message($msg);
				print "$msg\n" if $state->{beverbose};
			} else {
				$self->add2updates($l2[0]);
			}
		} elsif (@@l2 == 0) {
			$self->add2cant($pkgname);
		} else {
			my $result = OpenBSD::Interactive::choose1($pkgname, $state->{interactive}, sort @@l2);
			if (defined $result) {
				if (defined $found && $found eq  $result && !$plist->uses_old_libs) {
					print "No need to update $pkgname\n";
				} else {
					$self->add2updates($result);
				}
			} else {
				$state->{issues} = 1;
			}
		}
@


1.69
log
@remove dependency on available_stems(), make it go thru PackageLocator
@
text
@d2 1
a2 1
# $OpenBSD: Update.pm,v 1.68 2007/05/07 13:51:58 espie Exp $
d28 29
d58 1
a58 1
sub find
d60 1
a60 1
	my ($old, $new, $state) = @@_;
a68 1
	my @@cantupdate = ();
d80 1
a80 1
			push(@@cantupdate, $pkgname);
d90 1
a90 1
			push(@@$new, $l[0]);
d103 1
a103 1
		    $handle->close_now();
d150 1
a150 1
				push(@@$new, $l2[0]);
d153 1
a153 1
			push(@@cantupdate, $pkgname);
d160 1
a160 1
					push(@@$new, $result);
a167 1
	return @@cantupdate;
@


1.68
log
@make keep_most_recent explicit, do not try to pre-compute it at the stemlist
level.
@
text
@d2 1
a2 1
# $OpenBSD: Update.pm,v 1.67 2007/05/02 15:05:30 espie Exp $
a40 1
	my $hash = OpenBSD::PackageName::available_stems($state);
d50 1
a50 1
		my @@l = $hash->findstem($stem);
@


1.67
log
@$o->method() becomes $o->method
@
text
@d2 1
a2 1
# $OpenBSD: Update.pm,v 1.66 2007/04/21 10:02:15 espie Exp $
d57 3
@


1.66
log
@avoid both .libs-* and partial-*. Be a bit forceful about them, as they're
going to cause problems if they're not cleaned from time to time.
@
text
@d2 1
a2 1
# $OpenBSD: Update.pm,v 1.65 2007/04/15 10:17:29 espie Exp $
d99 1
a99 1
			if (!$plist->uses_old_libs()) {
d115 1
a115 1
			if (defined $found && $found eq  $l2[0] && !$plist->uses_old_libs()) {
d127 1
a127 1
				if (defined $found && $found eq  $result && !$plist->uses_old_libs()) {
@


1.65
log
@update copyright years, standardize licence.
reword the introduction to the stuff originally from FreeBSD to clarify
slightly.
@
text
@d2 1
a2 1
# $OpenBSD: Update.pm,v 1.64 2006/04/08 23:24:06 bernd Exp $
d45 5
a49 1
		next if $pkgname =~ m/^\.libs-/;
@


1.64
log
@Add missing 'use OpenBSD::Error'.

spotted by marco@@

'go ahead' espie@@
@
text
@d2 1
a2 1
# $OpenBSD: Update.pm,v 1.63 2006/03/07 11:10:49 espie Exp $
d4 1
a4 1
# Copyright (c) 2004 Marc Espie <espie@@openbsd.org>
@


1.63
log
@special case: repository holds several packages (say, old versions), and
you choose the most recent one, which also happens to be the currently
installed version -> then explicitly say no update is needed and proceed.
@
text
@d2 1
a2 1
# $OpenBSD: Update.pm,v 1.62 2006/03/04 11:31:18 espie Exp $
d26 1
@


1.62
log
@reorganize code a little bit: Update.pm becomes Replace.pm (since it matches
the -r option), and the find_update code moves to Update.pm, so that it doesn't
get parsed if -u is not used.

Also make the has_new_sig and uses_old_libs local methods of PackingList,
as it is their natural API.

Reorg a few more routines so that they can be found by pkg_add and by
Update.pm.

May need to split off more stuff to avoid parsing everything...
@
text
@d2 1
a2 1
# $OpenBSD: Update.pm,v 1.61 2006/02/21 19:20:17 espie Exp $
d122 5
a126 1
				push(@@$new, $result);
@


1.61
log
@ask question corresponding to -F updatedepends too (commonalize code).
Use key 'update', 'updatedepend' to avoid answering the same question
again and again.
@
text
@d2 1
a2 1
# $OpenBSD: Update.pm,v 1.60 2006/01/24 20:14:13 espie Exp $
a16 1

d20 2
a21 1
use OpenBSD::Delete;
d23 3
a26 83
package OpenBSD::PackingElement;
sub can_update
{
	my ($self, $install, $state) = @@_;

	my $issue = $self->update_issue($install);
	
	if (defined $issue) {
		$state->{okay} = 0;
	    	push(@@{$state->{journal}}, $issue);
	}
}

sub validate_depend
{
}

sub update_issue($$) { undef }

sub extract
{
}

sub mark_lib
{
}

sub unmark_lib
{
}

package OpenBSD::PackingElement::FileBase;
use File::Temp qw/tempfile/;

sub extract
{
	my ($self, $state) = @@_;

	my $file = $self->prepare_to_extract($state);

	if (defined $self->{link} || defined $self->{symlink}) {
		$self->{zap} = 1;
		return;
	}
	
	my $d = dirname($file->{destdir}.$file->{name});
	while (!-d $d && -e _) {
		$d = dirname($d);
	}
	if ($state->{not}) {
		print "extracting tempfile under $d\n" if $state->{very_verbose};
		$state->{archive}->skip();
	} else {
		if (!-e _) {
			File::Path::mkpath($d);
		}
		my ($fh, $tempname) = tempfile('pkg.XXXXXXXXXX', 
		    DIR => $d);

		print "extracting $tempname\n" if $state->{very_verbose};
		$file->{name} = $tempname;
		$self->{tempname} = $tempname;
		$file->create();
	}
}

package OpenBSD::PackingElement::Dir;
sub extract
{
	my ($self, $state) = @@_;
	my $fullname = $self->fullname();
	my $destdir = $state->{destdir};

	return if -e $destdir.$fullname;
	print "new directory ", $destdir, $fullname, "\n" if $state->{very_verbose};
	return if $state->{not};
	File::Path::mkpath($destdir.$fullname);
}

package OpenBSD::PackingElement::Sample;
sub extract
{
}
d28 1
a28 2
package OpenBSD::PackingElement::Sampledir;
sub extract
d30 2
a31 14
}

package OpenBSD::PackingElement::ScriptFile;
sub update_issue($$) 
{ 
	return $_[0]->{name}." script";
}

package OpenBSD::PackingElement::FINSTALL;
sub update_issue($$) 
{ 
	return undef if !$_[1];
	return $_[0]->SUPER::update_issue($_[1]);
}
d33 3
a35 6
package OpenBSD::PackingElement::FDEINSTALL;
sub update_issue($$) 
{ 
	return undef if $_[1];
	return $_[0]->SUPER::update_issue($_[1]);
}
d37 1
a37 19
package OpenBSD::PackingElement::Exec;
sub update_issue($$) 
{ 
	return undef if !$_[1];
	return '@@exec '.$_[0]->{expanded};
}

package OpenBSD::PackingElement::Unexec;
sub update_issue($$) 
{ 
	return undef if $_[1];
	my $self = $_[0];

	# those are deemed innocuous
	if ($self->{expanded} =~ m|^/sbin/ldconfig\s+\-R\b| or
	    $self->{expanded} =~ m|^install-info\s+\-\-delete\b|) {
		return undef;
	} else {
		return '@@unexec '.$self->{expanded};
d39 2
a40 1
}
d42 8
a49 197
package OpenBSD::PackingElement::Depend;
use OpenBSD::Error;

sub check_replacement_spec
{
	my ($self, $state, $wanting, $toreplace, $replacement) = @@_;

	# nothing to validate if old dependency doesn't concern us.
	return unless OpenBSD::PkgSpec::match($self->{pattern}, $toreplace);
	# nothing to do if new dependency just matches
	return if OpenBSD::PkgSpec::match($self->{pattern}, $replacement);

	if ($state->{forced}->{updatedepends}) {
	    Warn "Forward dependency of $wanting on $toreplace doesn't match $replacement, forcing it\n";
	    $state->{forcedupdates} = {} unless defined $state->{forcedupdates};
	    $state->{forcedupdates}->{$wanting} = 1;
	} elsif ($state->{interactive}) {

	    if (OpenBSD::Interactive::confirm("Forward dependency of $wanting on $toreplace doesn't match $replacement, proceed with update anyways", 1, 0, 'updatedepends')) {
		$state->{forcedupdates} = {} unless defined $state->{forcedupdates};
		$state->{forcedupdates}->{$wanting} = 1;
	    } else {
		$state->{okay} = 0;
	    }
	} else {
	    $state->{okay} = 0;
	    Warn "Can't update forward dependency of $wanting on $toreplace: $replacement doesn't match (use -F updatedepends to force it)\n";
	}
}

package OpenBSD::PackingElement::LibDepend;
sub validate_depend
{
	my ($self, $state, $wanting, $toreplace, $replacement) = @@_;

	if (defined $self->{name}) {
		return unless $self->{name} eq $wanting;
	}
	$self->check_replacement_spec($state, $wanting, $toreplace, $replacement);
}

package OpenBSD::PackingElement::Lib;
sub mark_lib
{
	my ($self, $libs, $libpatterns) = @@_;
	my $libname = $self->fullname();
	if ($libname =~ m/^(.*\.so\.)(\d+)\.(\d+)$/) {
		$libpatterns->{"$1"} = [$2, $3, $libname];
	}
	$libs->{"$libname"} = 1;
}

sub unmark_lib
{
	my ($self, $libs, $libpatterns) = @@_;
	my $libname = $self->fullname();
	if ($libname =~ m/^(.*\.so\.)(\d+)\.(\d+)$/) {
		my ($pat, $major, $minor) = ($1, $2, $3);
		my $p = $libpatterns->{"$pat"};
		if (defined $p && $p->[0] == $major && $p->[1] <= $minor) {
			my $n = $p->[2];
			delete $libs->{"$n"};
		}
	}
	delete $libs->{"$libname"};
}

package OpenBSD::PackingElement::NewDepend;
sub validate_depend
{
	my ($self, $state, $wanting, $toreplace, $replacement) = @@_;

	if (defined $self->{name}) {
		return unless $self->{name} eq $wanting;
	}
	$self->check_replacement_spec($state, $wanting, $toreplace, $replacement);
}

package OpenBSD::PackingElement::Dependency;
sub validate_depend
{
	my ($self, $state, $wanting, $toreplace, $replacement) = @@_;

	$self->check_replacement_spec($state, $wanting, $toreplace, $replacement);
}

package OpenBSD::Update;
use OpenBSD::RequiredBy;
use OpenBSD::PackingList;
use OpenBSD::PackageInfo;
use OpenBSD::Error;
use OpenBSD::Interactive;

sub can_do
{
	my ($toreplace, $replacement, $state, $ignore) = @@_;

	$state->{okay} = 1;
	$state->{libs_to_check} = [];
	my $plist = OpenBSD::PackingList->from_installation($toreplace);
	if (!defined $plist) {
		Fatal "Couldn't find packing-list for $toreplace\n";
	}
	$state->{journal} = [];
	$plist->visit('can_update', 0, $state);
	if ($state->{okay} == 0) {
		Warn "Old package ", $plist->pkgname(), " contains potentially unsafe operations\n";
		for my $i (@@{$state->{journal}}) {
			Warn "\t$i\n";
		}
		if ($state->{forced}->{update}) {
			Warn "(forcing update)\n";
			$state->{okay} = 1;
		} elsif ($state->{interactive}) {

			if (OpenBSD::Interactive::confirm("proceed with update anyways", 1, 0, 'update')) {
			    $state->{okay} = 1;
			}
		}
	}
	my @@wantlist = OpenBSD::RequiredBy->new($toreplace)->list();
	my @@r = ();
	for my $wanting (@@wantlist) {
		push(@@r, $wanting) if !defined $ignore->{$wanting};
	}
	if (@@r) {
		print "Verifying dependencies still match for ", 
		    join(', ', @@r), "\n" if $state->{verbose};
		for my $wanting (@@wantlist) {
			my $p2 = OpenBSD::PackingList->from_installation(
			    $wanting, \&OpenBSD::PackingList::DependOnly);
			if (!defined $p2) {
				Warn "Error: $wanting missing from installation\n"
			} else {
				$p2->visit('validate_depend', $state, $wanting, 
				    $toreplace, $replacement);
			}
		}
	}

	if ($state->{okay}) {
		try {
			OpenBSD::Delete::validate_plist($plist, $state);
		} catchall {
			Warn "$_";
			return 0;
		};
	}

	$plist->{wantlist} = \@@wantlist;
	$plist->{libs_to_check} = $state->{libs_to_check};
	
	return $state->{okay} ? $plist : 0;
}

sub is_safe
{
	my ($plist, $state) = @@_;
	$state->{okay} = 1;
	$state->{journal} = [];
	$plist->visit('can_update', 1, $state);
	if ($state->{okay} == 0) {
		Warn "New package ", $plist->pkgname(), 
		    " contains potentially unsafe operations\n";
		for my $i (@@{$state->{journal}}) {
			Warn "\t$i\n";
		}
		if ($state->{forced}->{update}) {
			Warn "(forcing update)\n";
			$state->{okay} = 1;
		} elsif ($state->{interactive}) {
			if (OpenBSD::Interactive::confirm("proceed with update anyways", 1, 0, 'update')) {
			    $state->{okay} = 1;
			}
		}
	}
	return $state->{okay};
}

# create a packing-list with only the libraries we want to keep around.
sub split_libs
{
	my ($plist, $to_split) = @@_;

	my $items = [];

	my $splitted = OpenBSD::PackingList->new();

	OpenBSD::PackingElement::Name->add($splitted, ".libs-".$plist->pkgname());
	if (defined $plist->{conflict}) {
		for my $item (@@{$plist->{conflict}}) {
			$item->clone()->add_object($splitted);
		}
	}
	if (defined $plist->{pkgcfl}) {
		for my $item (@@{$plist->{pkgcfl}}) {
			$item->clone()->add_object($splitted);
d51 5
a55 15
	}
	if (defined $plist->{'no-default-conflict'}) {
		# we conflict with the package we just removed...
		OpenBSD::PackingElement::Conflict->add($splitted, $plist->pkgname());
	} else {
		require OpenBSD::PackageName;

		my $stem = OpenBSD::PackageName::splitstem($plist->pkgname());
		OpenBSD::PackingElement::Conflict->add($splitted, $stem."-*");
	}

	for my $item (@@{$plist->{items}}) {
		if ($item->isa("OpenBSD::PackingElement::Lib") &&
		    defined $to_split->{$item->fullname()}) {
		    	$item->clone()->add_object($splitted);
d58 33
a90 2
		if ($item->isa("OpenBSD::PackingElement::Cwd")) {
			$item->clone()->add_object($splitted);
a91 35
		push(@@$items, $item);
	}
	$plist->{items} = $items;
	return $splitted;
}

sub convert_to_requiring
{
	my $pkg = shift;

	my $plist = OpenBSD::PackingList->from_installation($pkg);
	if (!defined $plist) {
		Warn "Couldn't read plist for $pkg\n";
		return;
	}
	my $r = OpenBSD::Requiring->new($pkg);
	for my $item (@@{$plist->{pkgdep}}) {
		$r->add($item->{name});
	}
	delete $plist->{pkgdep};
	$plist->to_installation();
}

sub walk_depends_closure
{
	my ($start, $plist, $state) = @@_;
	my @@todo = ($start);
	my $done = {};
	my $depend = 0;
	my $name = $plist->pkgname();

	print "Packages that depend on those shared libraries:\n" 
	    if $state->{beverbose};

	my $write = OpenBSD::RequiredBy->new($name);
d93 14
a106 14
	while (my $pkg = shift @@todo) {
		$done->{$pkg} = 1;
		for my $pkg2 (OpenBSD::RequiredBy->new($pkg)->list()) {
			next if $done->{$pkg2};
			push(@@todo, $pkg2);
			print "\t$pkg2\n" if $state->{beverbose};
			$done->{$pkg2} = 1;
			$write->add($pkg2);
			my $l = OpenBSD::Requiring->new($pkg2);
			if (!$l->list()) {
				convert_to_requiring($pkg2);
			}
			$l->add($name);
			$depend = 1;
d108 6
a113 35
	}
#	if (!$depend && $state->{interactive}) {
#		if ($state->{forced}->{zapoldlibs} ||
#		    OpenBSD::Interactive::confirm("Nothing depends on $name.  Delete it", 1, 0)) {
#		    	OpenBSD::Delete::delete_plist($plist, $state);
#		}
#	}
}



sub save_old_libraries
{
	my ($new_plist, $state) = @@_;

	for my $old_plist (@@{$new_plist->{replacing}}) {

		my $libs = {};
		my $p = {};

		print "Looking for changes in shared libraries\n" 
		    if $state->{beverbose};
		$old_plist->visit('mark_lib', $libs, $p);
		$new_plist->visit('unmark_lib', $libs, $p);

		if (%$libs) {
			print "Libraries to keep: ", join(",", sort(keys %$libs)), "\n" 
			    if $state->{beverbose};
			my $stub_list = split_libs($old_plist, $libs);
			my $stub_name = $stub_list->pkgname();
			my $dest = installed_info($stub_name);
			print "Keeping them in $stub_name\n" if $state->{beverbose};
			if ($state->{not}) {
				$stub_list->to_cache();
				$old_plist->to_cache();
d115 1
a115 12
				require OpenBSD::md5;

				mkdir($dest);
				my $oldname = $old_plist->pkgname();
				open my $descr, '>', $dest.DESC;
				print $descr "Stub libraries for $oldname\n";
				close $descr;
				my $f = OpenBSD::PackingElement::FDESC->add($stub_list, DESC);
				$f->{ignore} = 1;
				$f->{md5} = OpenBSD::md5::fromfile($dest.DESC);
				$stub_list->to_installation();
				$old_plist->to_installation();
d117 2
a118 6
			add_installed($stub_name);

			require OpenBSD::PkgCfl;
			OpenBSD::PkgCfl::register($stub_list, $state);

			walk_depends_closure($old_plist->pkgname(), $stub_list, $state);
d120 5
a124 58
			print "No libraries to keep\n" if $state->{beverbose};
		}
	}
}

			
sub adjust_dependency
{
	my ($dep, $from, $into) = @@_;

	my $l = OpenBSD::Requiring->new($dep);
	if (!$l->list()) {
		convert_to_requiring($dep);
	}
	$l->delete($from);
	$l->add($into);
}

sub figure_out_libs
{
	my ($plist, $state, @@libs) = @@_;

	my $has = {};
	my $result = [];

	for my $item (@@{$plist->{items}}) {
		next unless $item->IsFile();
		$has->{$item->fullname()} = 1;
	}

	for my $oldlib (@@libs) {
		print "Checking for collisions with $oldlib... " 
		    if $state->{verbose};

#		require OpenBSD::RequiredBy;
#
#		if (OpenBSD::RequiredBy->new($oldlib)->list() == 0) {
#			require OpenBSD::Delete;
#
#			OpenBSD::Delete::delete_package($oldlib, $state);
#			delete_installed($oldlib);
#			next;
#		}

		my $p = OpenBSD::PackingList->from_installation($oldlib);
		my $n = [];
		my $delete = [];
		my $empty = 1;
		my $doit = 0;
		for my $file (@@{$p->{items}}) {
			if ($file->IsFile()) {
				if ($has->{$file->fullname()}) {
					$doit = 1;
					push(@@$delete, $file);
					next;
				} else {
					$empty = 0;
				}
a125 14
			push(@@$n, $file);
		}
		$p->{items} = $n;
		if ($doit) {
			print "some found\n" if $state->{verbose};
			my $dummy = {items => $delete};
			push(@@$result, 
			    { plist => $p, 
			      todelete => $dummy,
			      empty => $empty});
			require OpenBSD::Delete;
			OpenBSD::Delete::validate_plist($dummy, $state);
		} else {
			print "none found\n" if $state->{verbose};
d128 2
a129 5
	if (@@$result) {
		$plist->{old_libs} = $result;
		return 0;
	}
	return 1;
@


1.60
log
@protect against weird situations where dependencies don't match
(admittedly, we should recompute them, but that's already better than
nothing).
@
text
@d2 1
a2 1
# $OpenBSD: Update.pm,v 1.59 2005/11/05 10:59:21 espie Exp $
d155 30
a185 1
use OpenBSD::Error;
d193 1
a193 11
	return unless OpenBSD::PkgSpec::match($self->{pattern}, $toreplace);
	if (!OpenBSD::PkgSpec::match($self->{pattern}, $replacement)) {
		if ($state->{forced}->{updatedepends}) {
		    Warn "Forward dependency of $wanting on $toreplace doesn't match $replacement, forcing it\n";
		    $state->{forcedupdates} = {} unless defined $state->{forcedupdates};
		    $state->{forcedupdates}->{$wanting} = 1;
		} else {
		    $state->{okay} = 0;
		    Warn "Can't update forward dependency of $wanting on $toreplace: $replacement doesn't match (use -F updatedepends to force it)\n";
		}
	}
a222 1
use OpenBSD::Error;
d230 1
a230 9
	return unless OpenBSD::PkgSpec::match($self->{pattern}, $toreplace);
	if (!OpenBSD::PkgSpec::match($self->{pattern}, $replacement)) {
		if ($state->{forced}->{updatedepends}) {
		    Warn "Forward dependency of $wanting on $toreplace doesn't match $replacement, forcing it\n";
		} else {
		    $state->{okay} = 0;
		    Warn "Can't update forward dependency of $wanting on $toreplace: $replacement doesn't match (use -F updatedepends to force it)\n";
		}
	}
a233 2
use OpenBSD::Error;

d238 1
a238 9
	return unless OpenBSD::PkgSpec::match($self->{pattern}, $toreplace);
	if (!OpenBSD::PkgSpec::match($self->{pattern}, $replacement)) {
		if ($state->{forced}->{updatedepends}) {
		    Warn "Forward dependency of $wanting on $toreplace doesn't match $replacement, forcing it\n";
		} else {
		    $state->{okay} = 0;
		    Warn "Can't update forward dependency of $wanting on $toreplace: $replacement doesn't match (use -F updatedepends to force it)\n";
		}
	}
d246 1
a268 1
			require OpenBSD::Interactive;
d270 1
a270 1
			if (OpenBSD::Interactive::confirm("proceed with update anyways", 1, 0)) {
d322 1
a322 1
		if ($state->{forced}->{update} || OpenBSD::Interactive::confirm("Proceed with update anyways", $state->{interactive}, 0)) {
d325 4
@


1.59
log
@same fix as Add.pm: make sure we parse the whole package.
@
text
@d2 1
a2 1
# $OpenBSD: Update.pm,v 1.58 2005/10/19 10:41:19 espie Exp $
d286 6
a291 2
			$p2->visit('validate_depend', $state, $wanting, 
			    $toreplace, $replacement);
@


1.58
log
@mark links being extracted with `zap', so that they do not get recorded
into partial plists until they've gone through an actual install.

Prevents partial replacements from destroying genuine links in packages
when they get uninstalled.
@
text
@d2 1
a2 1
# $OpenBSD: Update.pm,v 1.57 2005/09/09 09:11:38 espie Exp $
d75 1
@


1.57
log
@zap dup. From Bernd Ahlers
@
text
@d2 1
a2 1
# $OpenBSD: Update.pm,v 1.56 2005/09/04 22:47:56 espie Exp $
d65 1
@


1.56
log
@* New -i interactive option, that can ask obnoxious questions.
* move the signature code to a packing-list method, prepend the pkgname.
* depend on distant listings, cache these systematically.
* cut the PKG_PATH at :/ systematically, much simpler than parsing URLs.
People should get used to trailing /s.
* let pkg_add -u actually run the update.
* check for signature in more places, for instance, let pkg_add installed_stuff
be a void operation.
* grab enough stuff during updates to check signatures, so that pkg_add -u
can report updates that are not needed right away, instead of waiting
for the more confusing `trying to update'
* beginning of @@module support.
* @@pkgpath support, including updates.
* systematically expand stems when applicable.
* use visitors systematically in pkg_info.
* pkg_info -S reports signature.
* remove hardcoding of categories in PackingList, so that future modules
will be able to expand them.
* add @@updateset and @@incompatibility keywords.
@
text
@d2 1
a2 1
# $OpenBSD: Update.pm,v 1.55 2005/08/16 21:34:10 espie Exp $
a454 1
				print $descr "Stub libraries for $oldname\n";
@


1.55
log
@unsafe operations -> potentially unsafe operations
@
text
@d2 1
a2 1
# $OpenBSD: Update.pm,v 1.54 2005/08/16 18:37:06 espie Exp $
d22 1
a54 4
sub build_context
{
}

d170 1
a170 1
		    Warn "Can't update forward dependency of $wanting on $toreplace: $replacement doesn't match\n";
a200 19
package OpenBSD::PackingElement::Wantlib;
sub build_context
{
	my ($self, $hash) = @@_;
	$hash->{$self->{name}} = 1;
}

package OpenBSD::PackingElement::Depend;
sub build_context
{
	my ($self, $hash) = @@_;
	$hash->{$self->{def}} = 1;
}

package OpenBSD::PackingElement::PkgDep;
sub build_context
{
}

d216 1
a216 1
		    Warn "Can't update forward dependency of $wanting on $toreplace: $replacement doesn't match\n";
d234 1
a234 1
		    Warn "Can't update forward dependency of $wanting on $toreplace: $replacement doesn't match\n";
d265 6
d316 1
a316 1
		if ($state->{forced}->{update}) {
d388 1
a388 1
	my ($start, $name, $state) = @@_;
d391 2
d412 1
d415 6
d469 1
a469 1
			walk_depends_closure($old_plist->pkgname(), $stub_name, $state);
a486 15
}

sub is_needed
{
	my ($plist, $state) = @@_;
	my $new_context = {};
	$plist->visit('build_context', $new_context);
	my $oplist = OpenBSD::PackingList->from_installation($plist->pkgname());
	my $old_context = {};
	$oplist->visit('build_context', $old_context);
	my $n = join(',', sort keys %$new_context);
	my $o = join(',', sort keys %$old_context);
	print "Comparing full signature for ", $plist->pkgname(), " \"$o\" vs. \"$n\": ", $n eq $o ? "equal\n" : "different\n" 
	    if $state->{very_verbose};
	return $n ne $o;
@


1.54
log
@avoid computing signature twice!
slightly more verbose message.
@
text
@d2 1
a2 1
# $OpenBSD: Update.pm,v 1.53 2005/08/10 12:10:26 espie Exp $
d280 1
a280 1
		Warn "Old package ", $plist->pkgname(), " contains unsafe operations\n";
d328 1
a328 1
		    " contains unsafe operations\n";
@


1.53
log
@record unsafe operations in a journal, so that we can give a much
more specific message than `package XXX contains unsafe operations'.
@
text
@d2 1
a2 1
# $OpenBSD: Update.pm,v 1.52 2005/07/26 09:16:48 espie Exp $
d506 1
a506 1
	print "Comparing full signature \"$o\" vs. \"$n\"\n" 
d508 1
a508 2
	return join(',', sort keys %$new_context) ne 
	    join(',', sort keys %$old_context);
@


1.52
log
@switch .libs stubs package over to new COMMENT format.
Fix packing-list to be complete (it was missing the DESC special file)
@
text
@d2 1
a2 1
# $OpenBSD: Update.pm,v 1.51 2005/02/07 15:35:23 espie Exp $
d28 3
a30 1
	if (!$self->updatable($install)) {
d32 1
d40 1
a40 1
sub updatable($$) { 1 }
d115 4
a118 1
sub updatable($$) { 0 }
d121 5
a125 1
sub updatable($$) { !$_[1] }
d128 5
a132 1
sub updatable($$) { $_[1] }
d135 5
a139 1
sub updatable($$) { !$_[1] }
d142 1
a142 1
sub updatable($$) 
d144 1
a144 1
	return 1 if $_[1];
d150 1
a150 1
		return 1;
d152 1
a152 1
		return 0;
d277 1
d281 3
d324 1
d329 3
@


1.51
log
@make updatedepends slightly safer: note which packages may have bogus
dependencies, so that if you do one big pkg_add -r *, then you can check
which packages may have issues thanks to forced updates.
@
text
@d2 1
a2 1
# $OpenBSD: Update.pm,v 1.50 2004/12/28 14:00:21 espie Exp $
d431 2
d435 7
a441 4
				open my $comment, '>', $dest.COMMENT;
				print $comment "Stub libraries for $oldname";
				close $comment;
				link($dest.COMMENT, $dest.DESC);
@


1.50
log
@clearer error/warning
@
text
@d2 1
a2 1
# $OpenBSD: Update.pm,v 1.49 2004/12/28 13:56:08 espie Exp $
d151 2
@


1.49
log
@improve message quality: don't say we can't update stuff when we are going
to force it.
Group the verification of forward dependencies, so that it is less verbose.

Also, register .libs conflict, even if it's not that useful.
@
text
@d2 1
a2 1
# $OpenBSD: Update.pm,v 1.48 2004/12/27 22:40:42 espie Exp $
d150 1
a150 1
		    Warn "Forward dependency of $wanting on $toreplace doesn't match, forcing it\n";
d153 1
a153 1
		    Warn "Can't update forward dependency of $wanting on $toreplace\n";
d215 1
a215 1
		    Warn "Forward dependency of $wanting on $toreplace doesn't match, forcing it\n";
d218 1
a218 1
		    Warn "Can't update forward dependency of $wanting on $toreplace\n";
d233 1
a233 1
		    Warn "Forward dependency of $wanting on $toreplace doesn't match, forcing it\n";
d236 1
a236 1
		    Warn "Can't update forward dependency of $wanting on $toreplace\n";
@


1.48
log
@if we can't read this packing-list, this is not really an issue.
@
text
@d2 1
a2 1
# $OpenBSD: Update.pm,v 1.47 2004/12/21 01:43:58 espie Exp $
d149 6
a154 2
		$state->{okay} = 0;
		Warn "Can't update forward dependency of $wanting on $toreplace\n";
d214 6
a219 2
		$state->{okay} = 0;
		Warn "Can't update forward dependency of $wanting on $toreplace\n";
d232 6
a237 2
		$state->{okay} = 0;
		Warn "Can't update forward dependency of $wanting on $toreplace\n";
d260 4
a263 3
	}
	if ($state->{forced}->{update}) {
		$state->{okay} = 1;
d266 1
d268 1
a268 5
		next if defined $ignore->{$wanting};
		print "Verifying dependencies still match for $wanting\n" if $state->{verbose};
		my $p2 = OpenBSD::PackingList->from_installation($wanting,
		    \&OpenBSD::PackingList::DependOnly);
		$p2->visit('validate_depend', $state, $wanting, $toreplace, $replacement);
d270 9
a278 3

	if ($state->{forced}->{updatedepends}) {
		$state->{okay} = 1;
d304 4
d309 1
a309 1
	return $state->{okay} || $state->{forced}->{update};
d439 3
@


1.47
log
@correct checks to allow for a package to replace several packages.
@
text
@d2 1
a2 1
# $OpenBSD: Update.pm,v 1.46 2004/12/20 22:43:25 espie Exp $
d342 4
@


1.46
log
@allow a replacing package to replace several packages, in principle:
this is just a question of iterating over the replaced packages.

The fun part (can_install) still isn't done: wholesale replacements like
that mean the inter-dependencies between the replaced packages don't
count.
@
text
@d2 1
a2 1
# $OpenBSD: Update.pm,v 1.45 2004/12/20 12:16:51 espie Exp $
d237 1
a237 1
	my ($toreplace, $replacement, $state) = @@_;
d254 1
@


1.45
log
@don't display some details in -n mode unless very verbose.
@
text
@d2 1
a2 1
# $OpenBSD: Update.pm,v 1.44 2004/12/19 20:25:17 espie Exp $
d383 1
a383 3
	my $old_plist = $new_plist->{replacing};
	my $libs = {};
	my $p = {};
d385 2
a386 4
	print "Looking for changes in shared libraries\n" 
	    if $state->{beverbose};
	$old_plist->visit('mark_lib', $libs, $p);
	$new_plist->visit('unmark_lib', $libs, $p);
d388 1
a388 2
	if (%$libs) {
		print "Libraries to keep: ", join(",", sort(keys %$libs)), "\n" 
d390 26
a415 7
		my $stub_list = split_libs($old_plist, $libs);
		my $stub_name = $stub_list->pkgname();
		my $dest = installed_info($stub_name);
		print "Keeping them in $stub_name\n" if $state->{beverbose};
		if ($state->{not}) {
			$stub_list->to_cache();
			$old_plist->to_cache();
d417 1
a417 8
			mkdir($dest);
			my $oldname = $old_plist->pkgname();
			open my $comment, '>', $dest.COMMENT;
			print $comment "Stub libraries for $oldname";
			close $comment;
			link($dest.COMMENT, $dest.DESC);
			$stub_list->to_installation();
			$old_plist->to_installation();
a418 5
		add_installed($stub_name);

		walk_depends_closure($old_plist->pkgname(), $stub_name, $state);
	} else {
		print "No libraries to keep\n" if $state->{beverbose};
@


1.44
log
@sanity check: in -n mode, we end up replacing stuff that doesn't exist ?
@
text
@d2 1
a2 1
# $OpenBSD: Update.pm,v 1.43 2004/12/19 20:03:09 espie Exp $
d73 1
a73 1
		print "extracting tempfile under $d\n";
@


1.43
log
@don't create path if -n.
@
text
@d2 1
a2 1
# $OpenBSD: Update.pm,v 1.42 2004/12/18 13:39:17 espie Exp $
d242 3
@


1.42
log
@oops, don't compute fullname unless we know we can.
@
text
@d2 1
a2 1
# $OpenBSD: Update.pm,v 1.41 2004/12/18 13:20:54 espie Exp $
a71 3
	if (!-e _) {
		File::Path::mkpath($d);
	}
d75 3
@


1.41
log
@basic code to handle legacy .libs-* packages: figure out what collisions
the new package actually has with old libs. If none is found, we can
proceed.

Prepare pkg_add to deal with it: switch into replacing mode as soon
as something fishy is going on.

Todo: code to actually delete replaced libraries.

Please note: if you don't play games such as going back to old packages
using replace, this code is enough.

If you update your whole system and remove old .libs-* package without
going back, this code isn't even needed...
@
text
@d2 1
a2 1
# $OpenBSD: Update.pm,v 1.40 2004/12/15 01:07:10 espie Exp $
d454 1
@


1.40
log
@move -n down into RequiredBy and PackingList (as $main::not, since we
don't want to load RequiredBy all the time).
Remove a few $state->{not} tests that are no longer needed.

pkg_add -n / pkg_delete -n should work much better when they need to
handle multiple dependencies.

(todo: kill plist caches, finish replacing with specialized caches like
libraries).
@
text
@d2 1
a2 1
# $OpenBSD: Update.pm,v 1.39 2004/12/12 11:26:16 espie Exp $
d445 64
@


1.39
log
@add somewhat more regular error catching code.
@
text
@d2 1
a2 1
# $OpenBSD: Update.pm,v 1.38 2004/12/02 00:19:26 espie Exp $
a363 1
			next if $state->{not};
@


1.38
log
@don't try to validate_plist if not needed at all.
@
text
@d2 1
a2 1
# $OpenBSD: Update.pm,v 1.37 2004/12/02 00:15:15 espie Exp $
d262 1
a262 1
		eval {
d264 3
a267 4
		if ($@@) {
			Warn "$@@";
			return 0;
		}
@


1.37
log
@cosmetic: shows old and new package name, plus signatures.
@
text
@d2 1
a2 1
# $OpenBSD: Update.pm,v 1.36 2004/11/27 16:38:26 espie Exp $
d260 9
a268 6
	eval {
		OpenBSD::Delete::validate_plist($plist, $state);
	};
	if ($@@) {
		Warn "$@@";
		return 0;
@


1.36
log
@tweak very verbose output.
@
text
@d2 1
a2 1
# $OpenBSD: Update.pm,v 1.35 2004/11/27 14:02:50 espie Exp $
d244 1
a244 1
		Warn "Old package contains unsafe operations\n";
d280 2
a281 1
		Warn "New package contains unsafe operations\n";
d439 2
a440 1
	print "Comparing full signature $o vs. $n\n" if $state->{very_verbose};
@


1.35
log
@if the package is already installed, check whether updating it makes sense:
look at the context in which both packages were built. If dependencies differ,
then this is a sensible update.

While we're there, try harder to build a conflict list for .libs-* packages.
@
text
@d2 1
a2 1
# $OpenBSD: Update.pm,v 1.34 2004/11/18 21:56:03 espie Exp $
a386 2
	print "Libraries to keep: ", join(",", sort(keys %$libs)), "\n" 
	    if $state->{beverbose};
d388 2
d410 2
@


1.34
log
@unsafe operations is better than impossible to update, especially since it
can go on anyways.
@
text
@d2 1
a2 1
# $OpenBSD: Update.pm,v 1.33 2004/11/18 21:48:02 espie Exp $
d51 4
d180 19
d293 1
d295 19
a313 2
	# we conflict with the package we just removed...
	OpenBSD::PackingElement::Conflict->add($splitted, $plist->pkgname());
d424 15
@


1.33
log
@support depend (similar to libdepend and newdepend) and wantlib:
put lookup_library code in a separate routine, and add a `harder' mode
for wantlib, that will also look in system libraries, and in the full
tree of dependent packages.
@
text
@d2 1
a2 1
# $OpenBSD: Update.pm,v 1.32 2004/11/14 19:25:45 espie Exp $
d221 1
a221 1
		Warn "Old package contains impossible to update elements\n";
@


1.32
log
@stop storing @@pkdep into packing-lists, use separate REQUIRING file instead.

Cases where we need to tweak dependencies are well-delimited, and we simply
convert the old installed package to the new model in one step.
@
text
@d2 1
a2 1
# $OpenBSD: Update.pm,v 1.31 2004/11/14 11:40:08 espie Exp $
d185 14
@


1.31
log
@let RequiredBy generate lists directly, use hashes to trim down duplicates directly. Optimize for !wantarray, by telling whether the list is empty or not.

prepare for a second similar list (REQUIRING) that will replace pkgdep, since
pkg_add -r spends a hell of a lot of its time reading/writing long
packing-lists...

Use the simplified interface.

Remove quite a few tests that the RequiredBy list is non-empty that do
nothing but obfuscate the code: just deal with the damn list already.
@
text
@d2 1
a2 1
# $OpenBSD: Update.pm,v 1.30 2004/11/13 12:53:01 espie Exp $
d275 13
a304 4
			$write->add($pkg2) unless $state->{not};
			my $plist = OpenBSD::PackingList->from_installation($pkg2);
			OpenBSD::PackingElement::PkgDep->add($plist, $name);
			$plist->to_installation() unless $state->{not};
d306 7
d363 3
a365 5
	my $plist = OpenBSD::PackingList->from_installation($dep);
	my $items = [];
	for my $item (@@{$plist->{pkgdep}}) {
		next if $item->{'name'} eq $from;
		push(@@$items, $item);
d367 2
a368 3
	$plist->{pkgdep} = $items;
	OpenBSD::PackingElement::PkgDep->add($plist, $into);
	$plist->to_installation();
@


1.30
log
@typo
@
text
@d2 1
a2 1
# $OpenBSD: Update.pm,v 1.29 2004/11/13 12:49:58 espie Exp $
a201 2
	my $wantlist = [];
	my $r = OpenBSD::RequiredBy->new($toreplace);
d212 6
a217 11
	if (-f $$r) {
		$wantlist = $r->list();
		my $done_wanted = {};
		for my $wanting (@@$wantlist) {
			next if defined $done_wanted->{$wanting};
			$done_wanted->{$wanting} = 1;
			print "Verifying dependencies still match for $wanting\n" if $state->{verbose};
			my $p2 = OpenBSD::PackingList->from_installation($wanting,
			    \&OpenBSD::PackingList::DependOnly);
			$p2->visit('validate_depend', $state, $wanting, $toreplace, $replacement);
		}
d231 1
a231 1
	$plist->{wantlist} = $wantlist;
d288 9
a296 13
		my $r = OpenBSD::RequiredBy->new($pkg);
		if (-f $$r) {
			my $list = $r->list();
			for my $pkg2 (@@$list) {
				next if $done->{$pkg2};
				push(@@todo, $pkg2);
				print "\t$pkg2\n" if $state->{beverbose};
				$write->add($pkg2) unless $state->{not};
				my $plist = OpenBSD::PackingList->from_installation($pkg2);
				OpenBSD::PackingElement::PkgDep->add($plist, $name);
				$plist->to_installation() unless $state->{not};
				$done->{$pkg2} = 1;
			}
@


1.29
log
@synchronize installed stuff, using the cache in -n mode so that -n
installations can proceed to the end...
@
text
@d2 1
a2 1
# $OpenBSD: Update.pm,v 1.28 2004/11/13 11:54:30 espie Exp $
d347 1
a347 1
		add_installed($stubname);
@


1.28
log
@fix logic error: while splitting libraries, copy cwd over, not move them...

use the same framework in pkg_add while extracting temp packages so that
we will be able to destroy them eventually.
@
text
@d2 1
a2 1
# $OpenBSD: Update.pm,v 1.27 2004/11/12 21:52:01 espie Exp $
d334 4
a337 1
		unless ($state->{not}) {
d347 1
@


1.27
log
@be saner wrt directory creation during pkg updates:
don't disturb existing objects if they're not directories,
create them better if they don't exist.
@
text
@d2 1
a2 1
# $OpenBSD: Update.pm,v 1.26 2004/11/11 22:40:38 espie Exp $
a50 13
sub extract_with_pm
{
	require OpenBSD::ProgressMeter;

	my ($self, $state) = @@_;

	$self->extract($state);
	if (defined $self->{size}) {
		$state->{donesize} += $self->{size};
		OpenBSD::ProgressMeter::show($state->{donesize}, $state->{totsize});
	}
}

d271 4
a274 4
		} elsif ($item->isa("OpenBSD::PackingElement::Cwd")) {
			OpenBSD::PackingElement::Cwd->add($splitted, $item->{name});
		} else {
			push(@@$items, $item);
d276 1
@


1.26
log
@forget packing-lists after deleting the package (avoid out-of-memory error
when deleting large sets of packages).
@
text
@d2 1
a2 1
# $OpenBSD: Update.pm,v 1.25 2004/11/11 20:59:05 espie Exp $
d77 7
d85 1
a85 1
		print "extracting tempfile under ", dirname($file->{destdir}.$file->{name}), "\n";
d88 1
a88 1
		    DIR => dirname($file->{destdir}.$file->{name}));
d104 1
@


1.25
log
@oops
@
text
@d2 1
a2 1
# $OpenBSD: Update.pm,v 1.24 2004/11/11 13:54:48 espie Exp $
d80 2
a81 1
		my ($fh, $tempname) = tempfile(DIR => dirname($file->{destdir}.$file->{name}));
@


1.24
log
@oops, updatable is an object method, so $self is first parameter.

Mark @@unexec /sbin/ldconfig -R  and @@unexec install-info --delete
as innocuous.
@
text
@d2 1
a2 1
# $OpenBSD: Update.pm,v 1.23 2004/11/11 12:45:15 espie Exp $
d274 1
a274 1
		    	OpenBSD::PackingElement::Lib->add($splitted, $item->clone());
@


1.23
log
@symetry: updating a package means removing the old one and adding the new
one, tag unsafe operations accordingly...
@
text
@d2 1
a2 1
# $OpenBSD: Update.pm,v 1.22 2004/11/11 12:15:28 espie Exp $
d37 1
a37 1
sub updatable($) { 1 }
d112 1
a112 1
sub updatable($) { 0 }
d115 1
a115 1
sub updatable($) { !$_[0] }
d118 1
a118 1
sub updatable($) { $_[0] }
d121 1
a121 1
sub updatable($) { !$_[0] }
d124 13
a136 1
sub updatable($) { $_[0] }
@


1.22
log
@restrict update operation less: we're not bothered by @@exec or INSTALL,
only DEINSTALL or @@unexec (we should need to run symetric checks on
the package we're going to install, though...)

allows forced replacement: script running, and breaking forward dependencies.

Communicate more about what may break.
@
text
@d2 1
a2 1
# $OpenBSD: Update.pm,v 1.21 2004/11/11 11:16:40 espie Exp $
d26 1
a26 1
	my ($self, $state) = @@_;
d28 1
a28 1
	if (!$self->updatable()) {
d37 1
a37 1
sub updatable() { 1 }
d112 1
a112 1
sub updatable() { 0 }
d115 7
a121 1
sub updatable() { 1 }
d124 1
a124 1
sub updatable() { 0 }
d192 1
a192 1
	my ($toreplace, $replacement, $state, $forced) = @@_;
d199 1
a199 1
	$plist->visit('can_update', $state);
d203 1
a203 1
	if ($forced->{update}) {
d219 1
a219 1
	if ($forced->{updatedepends}) {
d223 1
a223 1
		OpenBSD::Delete::validate_plist($plist, $state->{destdir});
d226 1
d234 11
@


1.21
log
@introduce shortcuts to read/write contents from_installation/to_installation

use these to simplify all those packing lists manipulations.

demote non-root detection to a warning in -n mode:
fix a couple of minor bugs, of stuff that was run in -n mode and should not.
Namely, manpages were indexed/unindexed (ouch) and tempfiles were creating
during updates.
@
text
@d2 1
a2 1
# $OpenBSD: Update.pm,v 1.20 2004/11/11 10:47:26 espie Exp $
d114 4
a117 1
package OpenBSD::PackingElement::ExeclikeAction;
d121 1
d132 1
a132 1
		return;
d163 1
d174 1
d182 1
d186 1
a186 1
	my ($toreplace, $replacement, $state) = @@_;
d195 4
a198 1
		print "Old package contains impossible to update elements\n";
d213 3
@


1.20
log
@fix interaction of -n -v -r.
don't enable the progress meter if a very verbose mode is on.
@
text
@d2 1
a2 1
# $OpenBSD: Update.pm,v 1.19 2004/11/11 10:23:53 espie Exp $
d76 11
a86 7
	my ($fh, $tempname) = tempfile(DIR => dirname($file->{destdir}.$file->{name}));

	print "extracting $tempname\n" if $state->{very_verbose};
	$file->{name} = $tempname;
	$self->{tempname} = $tempname;
	return if $state->{not};
	$file->create();
d185 1
a185 1
	my $plist = OpenBSD::PackingList->fromfile(installed_info($toreplace).CONTENTS);
d197 1
a197 1
			my $p2 = OpenBSD::PackingList->fromfile(installed_info($wanting).CONTENTS,
d263 1
a263 2
				my $contents = installed_info($pkg2).CONTENTS;
				my $plist = OpenBSD::PackingList->fromfile($contents);
d265 1
a265 1
				$plist->tofile($contents) unless $state->{not};
d301 2
a302 2
			$stub_list->tofile($dest.CONTENTS);
			$old_plist->tofile(installed_info($oldname).CONTENTS);
d314 1
a314 2
	my $contents = installed_info($dep).CONTENTS;
	my $plist = OpenBSD::PackingList->fromfile($contents);
d322 1
a322 1
	$plist->tofile($contents);
@


1.19
log
@hide lib packages
@
text
@d2 1
a2 1
# $OpenBSD: Update.pm,v 1.18 2004/11/09 22:55:56 espie Exp $
d80 2
a82 1
	$self->{tempname} = $tempname;
d183 3
d192 1
a192 1
			print "Verifying dependencies still match for $wanting\n";
d240 1
a240 1
	my ($start, $name) = @@_;
d244 3
d257 2
a258 1
				$write->add($pkg2);
d262 1
a262 1
				$plist->tofile($contents);
d279 2
d284 2
d290 11
a300 8
		mkdir($dest);
		my $oldname = $old_plist->pkgname();
		open my $comment, '>', $dest.COMMENT;
		print $comment "Stub libraries for $oldname";
		close $comment;
		link($dest.COMMENT, $dest.DESC);
		$stub_list->tofile($dest.CONTENTS);
		$old_plist->tofile(installed_info($oldname).CONTENTS);
d302 1
a302 1
		walk_depends_closure($old_plist->pkgname(), $stub_name);
@


1.18
log
@oops again.
@
text
@d2 1
a2 1
# $OpenBSD: Update.pm,v 1.17 2004/11/09 22:44:30 espie Exp $
d216 1
a216 1
	OpenBSD::PackingElement::Name->add($splitted, "_libs-".$plist->pkgname());
@


1.17
log
@oops, dropped one line I shouldn't have.
@
text
@d2 1
a2 1
# $OpenBSD: Update.pm,v 1.16 2004/11/09 10:17:52 espie Exp $
d132 1
a132 1
	if (my $libname =~ m/^(.*\.so\.)(\d+)\.(\d+)$/) {
d142 1
a142 1
	if (my $libname =~ m/^(.*\.so\.)(\d+)\.(\d+)$/) {
@


1.16
log
@save dir in plist, not state (unconfuse script operations when several
plists are present).

Encapsulate `extract' operation in `extract_with_pm' to allow progress meter
to do something sensible when replacing packages.
@
text
@d2 1
a2 1
# $OpenBSD: Update.pm,v 1.15 2004/11/09 09:58:56 espie Exp $
d127 1
@


1.15
log
@don't keep libraries whose version numbers are not needed.
@
text
@d2 1
a2 1
# $OpenBSD: Update.pm,v 1.14 2004/11/09 09:32:17 espie Exp $
d49 13
@


1.14
log
@remove code we don't use.
@
text
@d2 1
a2 1
# $OpenBSD: Update.pm,v 1.13 2004/11/07 13:29:29 espie Exp $
d116 1
a116 1
	my ($self, $libs) = @@_;
d118 3
d126 1
a126 1
	my ($self, $libs) = @@_;
d128 8
d255 1
d257 2
a258 2
	$old_plist->visit('mark_lib', $libs);
	$new_plist->visit('unmark_lib', $libs);
@


1.13
log
@clone() library entry so that md5 and modes/owners get copied along.
@
text
@d2 1
a2 1
# $OpenBSD: Update.pm,v 1.12 2004/11/07 13:19:48 espie Exp $
a36 4
sub register_libs
{
}

a111 12
	push(@@{$state->{libs_to_check}}, split(/,/, $self->{libspec}));
}
package OpenBSD::PackingElement::Lib;
sub register_libs
{
	my ($self, $state) = @@_;

	my $localbase = $state->{localbase};
	my $libname = $self->fullname();
	if ($libname =~ m/^\Q$localbase\E\/(.*)\.so\.(\d+)\.(\d+)$/) {
		$state->{libs}->{$1} = [$2, $3];
	}
a265 30
sub verify_libs
{
	my ($plist, $state) = @@_;
	$state->{libs} = {};
	$plist->visit('register_libs', $state);
	for my $spec (@@{$state->{libs_to_check}}) {
		my $dir;
		if ($spec =~ m|.*/|) {
			$dir = "$&";
			$spec = $';
		} else {
			$dir = "lib";
		}
		if ($spec =~ m/^(.*)\.(\d+)\.(\d+)$/) {
			my ($libname, $major, $minor) = ($1, $2, $3);
			my $v = $state->{libs}->{"$dir/lib$libname"};
			if (!defined $v) {
				print "No such lib $libname\n";
				return 0;
			}
			unless ($v->[0] == $major && $v->[1] >= $minor) {
				print "Bad library version for $libname\n";
				return 0;
			}
		}
	}
	return 1;
}


@


1.12
log
@split off libraries, so that we can erase the old packages.

todo: allow people to reverse the process, since _libs-* will conflict
with reinstalling a package.
@
text
@d2 1
a2 1
# $OpenBSD: Update.pm,v 1.11 2004/11/07 12:19:20 espie Exp $
d214 1
a214 1
		    	OpenBSD::PackingElement::Lib->add($splitted, $item->{name});
@


1.11
log
@shared libraries, preliminary work, a simpler scheme:
compare replaced package with replacing package, mark all changed shared
libraries.
split_old_libs knows how to cobble a new plist off the old one with the
shared libraries.
print_depends_closure knows how to walk the RequiredBy objects to build
a complete list of packages that may depend upon those libraries.

Todo: actually split off the libraries, write a COMMENT/CONTENTS files too,
and register all those dependencies.
@
text
@d2 1
a2 1
# $OpenBSD: Update.pm,v 1.10 2004/11/06 12:19:17 espie Exp $
d225 1
a225 1
sub print_depends_closure
d227 2
a228 1
	my @@todo = @@_;
d231 2
d241 5
a245 1
				print $pkg2, "\n";
d266 12
a277 3
		print_depends_closure($old_plist->pkgname());
		$stub_list->write(\*STDOUT);
		exit(1);
@


1.10
log
@mark whole state for `replacing' so that only file entries get tempname
markers. Explain about tempname to PackingElement, so that we become
able to save temporary packing-lists (e.g, borking during replace will
now work).
@
text
@d2 1
a2 1
# $OpenBSD: Update.pm,v 1.9 2004/11/02 23:53:21 espie Exp $
d47 8
d130 14
d199 67
@


1.9
log
@logic error: match library version of *new* plist against existing packages.
@
text
@d2 1
a2 1
# $OpenBSD: Update.pm,v 1.8 2004/11/02 18:50:36 espie Exp $
a56 1
		$self->{tempname} = 1;
@


1.8
log
@refuse to update if library numbers do not match.
@
text
@d2 1
a2 1
# $OpenBSD: Update.pm,v 1.7 2004/11/01 19:48:58 espie Exp $
d36 5
d109 1
a109 21
	for my $spec (split(/,/, $self->{libspec})) {
		my $dir;
		if ($spec =~ m|.*/|) {
			$dir = "$&";
			$spec = $';
		} else {
			$dir = "lib";
		}
		if ($spec =~ m/^(.*)\.(\d+)\.(\d+)$/) {
			my ($libname, $major, $minor) = ($1, $2, $3);
			my $v = $state->{libs}->{"$dir/lib$libname"};
			if (!defined $v) {
				print "No such lib $libname\n";
				$state->{okay} = 0;
			}
			unless ($v->[0] == $major && $v->[1] >= $minor) {
				print "Bad library version for $libname\n";
				$state->{okay} = 0;
			}
		}
	}
a110 1

d112 1
a112 1
sub can_update
d149 1
a149 1
	$state->{libs} = {};
d173 1
d177 30
@


1.7
log
@adjust dependencies
@
text
@d2 1
a2 1
# $OpenBSD: Update.pm,v 1.6 2004/11/01 19:14:26 espie Exp $
d26 1
a26 1
	my ($self, $okay) = @@_;
d28 3
a30 1
	$$okay = $self->updatable();
d94 1
a94 1
	my ($self, $okay, $wanting, $toreplace, $replacement) = @@_;
d101 35
a135 1
		$$okay = 0;
d142 1
a142 1
	my ($self, $okay, $wanting, $toreplace, $replacement) = @@_;
d149 1
a149 1
		$$okay = 0;
d164 4
a167 1
	my $okay = 1;
d177 1
a177 1
			$p2->visit('validate_depend', \$okay, $wanting, $toreplace, $replacement);
a180 2
	my $plist = OpenBSD::PackingList->fromfile(installed_info($toreplace).CONTENTS);
	$plist->visit('can_update', \$okay);
d190 1
a190 1
	return $okay ? $plist : $okay;
@


1.6
log
@allows Delete to remove a plist (assuming it's already been validated).
let pkg_add -r compute a replaced package and store its plist in the new
package plist, so that replacement has a chance to proceed.

Not finished yet. Missing:
- real lib depends checks;
- restoring package dependencies after replacement.
@
text
@d2 1
a2 1
# $OpenBSD: Update.pm,v 1.5 2004/11/01 15:45:02 espie Exp $
d126 1
d130 1
a130 1
		my $wantlist = $r->list();
d150 2
d154 16
@


1.5
log
@move all the checking prior to extraction to a `prepare_to_extract' function.
check that linknames match while we're at it.
@
text
@d2 1
a2 1
# $OpenBSD: Update.pm,v 1.4 2004/11/01 14:30:00 espie Exp $
d55 1
a55 1
	print "extracting $tempname\n";
d147 1
a147 1
		$okay = 0;
d150 1
a150 1
	return $okay;
@


1.4
log
@handle the case of symlinks.
Let pkg_add -r do extraction first, and finish installation later.
@
text
@d2 1
a2 1
# $OpenBSD: Update.pm,v 1.3 2004/11/01 11:48:03 espie Exp $
a45 1
	my $fullname = $self->fullname();
d47 1
a47 6
	my $file=$state->{archive}->next();
	if ($file->{name} ne $self->{name}) {
		Fatal "Error: archive does not match", $file->{name}, "!=",
		$self->{name}, "\n";
	}
	my $destdir = $state->{destdir};
d53 1
a53 1
	my ($fh, $tempname) = tempfile(DIR => dirname($destdir.$fullname));
a56 2
	$file->{cwd} = $self->{cwd};
	$file->{destdir} = $destdir;
@


1.3
log
@separate `extract' routine that can put an archive in temporary files
next to their final locations.

XXX: doesn't work with hard links, yet.
@
text
@d2 1
a2 1
# $OpenBSD: Update.pm,v 1.2 2004/10/31 12:40:01 espie Exp $
d55 4
a64 4
	# faked installation are VERY weird
	if (defined $self->{symlink} && $state->{do_faked}) {
		$file->{linkname} = $destdir.$file->{linkname};
	}
@


1.2
log
@fix logic error: we will be able to fully validate the new packing-list
in pkg_add -r mode, it's just a question of removing the old package
from the virtual filesystem early, so that we can still check for collisions.

Help getting OpenBSD::Delete self-contained while we're there...
@
text
@d2 1
a2 1
# $OpenBSD: Update.pm,v 1.1 2004/10/23 11:09:23 espie Exp $
d35 55
@


1.1
log
@beginning of update module: basic check that stuff we are replacing
is still okay.
@
text
@d2 1
a2 1
# $OpenBSD$
d21 2
d77 1
a77 1
	my ($toreplace, $replacement) = @@_;
d96 6
@

