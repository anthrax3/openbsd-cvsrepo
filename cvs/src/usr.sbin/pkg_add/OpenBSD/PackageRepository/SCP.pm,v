head	1.29;
access;
symbols
	OPENBSD_6_1_BASE:1.29
	OPENBSD_6_0:1.29.0.10
	OPENBSD_6_0_BASE:1.29
	OPENBSD_5_9:1.29.0.4
	OPENBSD_5_9_BASE:1.29
	OPENBSD_5_8:1.29.0.6
	OPENBSD_5_8_BASE:1.29
	OPENBSD_5_7:1.29.0.2
	OPENBSD_5_7_BASE:1.29
	OPENBSD_5_6:1.28.0.4
	OPENBSD_5_6_BASE:1.28
	OPENBSD_5_5:1.27.0.14
	OPENBSD_5_5_BASE:1.27
	OPENBSD_5_4:1.27.0.10
	OPENBSD_5_4_BASE:1.27
	OPENBSD_5_3:1.27.0.8
	OPENBSD_5_3_BASE:1.27
	OPENBSD_5_2:1.27.0.6
	OPENBSD_5_2_BASE:1.27
	OPENBSD_5_1_BASE:1.27
	OPENBSD_5_1:1.27.0.4
	OPENBSD_5_0:1.27.0.2
	OPENBSD_5_0_BASE:1.27
	OPENBSD_4_9:1.24.0.4
	OPENBSD_4_9_BASE:1.24
	OPENBSD_4_8:1.24.0.2
	OPENBSD_4_8_BASE:1.24
	OPENBSD_4_7:1.20.0.2
	OPENBSD_4_7_BASE:1.20
	OPENBSD_4_6:1.19.0.4
	OPENBSD_4_6_BASE:1.19
	OPENBSD_4_5:1.17.0.4
	OPENBSD_4_5_BASE:1.17
	OPENBSD_4_4:1.17.0.2
	OPENBSD_4_4_BASE:1.17
	OPENBSD_4_3:1.16.0.4
	OPENBSD_4_3_BASE:1.16
	OPENBSD_4_2:1.16.0.2
	OPENBSD_4_2_BASE:1.16
	OPENBSD_4_1:1.9.0.4
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.9.0.2
	OPENBSD_4_0_BASE:1.9;
locks; strict;
comment	@# @;


1.29
date	2014.08.27.18.40.03;	author kspillner;	state Exp;
branches;
next	1.28;
commitid	634hl9204nK0ovPn;

1.28
date	2014.03.18.18.53.29;	author espie;	state Exp;
branches;
next	1.27;

1.27
date	2011.07.19.17.30.05;	author espie;	state Exp;
branches;
next	1.26;

1.26
date	2011.03.23.15.29.31;	author espie;	state Exp;
branches;
next	1.25;

1.25
date	2011.03.23.14.05.35;	author espie;	state Exp;
branches;
next	1.24;

1.24
date	2010.07.02.11.50.50;	author espie;	state Exp;
branches;
next	1.23;

1.23
date	2010.06.30.10.51.04;	author espie;	state Exp;
branches;
next	1.22;

1.22
date	2010.06.30.10.41.42;	author espie;	state Exp;
branches;
next	1.21;

1.21
date	2010.05.10.09.17.55;	author espie;	state Exp;
branches;
next	1.20;

1.20
date	2010.01.05.11.31.07;	author espie;	state Exp;
branches;
next	1.19;

1.19
date	2009.06.06.10.13.29;	author espie;	state Exp;
branches;
next	1.18;

1.18
date	2009.06.03.10.17.50;	author espie;	state Exp;
branches;
next	1.17;

1.17
date	2008.06.27.10.57.27;	author espie;	state Exp;
branches;
next	1.16;

1.16
date	2007.06.16.09.29.37;	author espie;	state Exp;
branches;
next	1.15;

1.15
date	2007.06.04.18.52.02;	author espie;	state Exp;
branches;
next	1.14;

1.14
date	2007.06.04.14.40.39;	author espie;	state Exp;
branches;
next	1.13;

1.13
date	2007.05.19.09.44.28;	author espie;	state Exp;
branches;
next	1.12;

1.12
date	2007.05.17.18.59.38;	author espie;	state Exp;
branches;
next	1.11;

1.11
date	2007.05.17.18.17.20;	author espie;	state Exp;
branches;
next	1.10;

1.10
date	2007.04.15.10.17.29;	author espie;	state Exp;
branches;
next	1.9;

1.9
date	2006.05.26.17.12.09;	author steven;	state Exp;
branches;
next	1.8;

1.8
date	2006.03.13.16.08.12;	author espie;	state Exp;
branches;
next	1.7;

1.7
date	2006.03.08.12.10.48;	author espie;	state Exp;
branches;
next	1.6;

1.6
date	2006.03.08.11.22.02;	author espie;	state Exp;
branches;
next	1.5;

1.5
date	2006.03.07.14.18.51;	author espie;	state Exp;
branches;
next	1.4;

1.4
date	2006.03.07.14.00.48;	author espie;	state Exp;
branches;
next	1.3;

1.3
date	2006.03.07.13.25.05;	author espie;	state Exp;
branches;
next	1.2;

1.2
date	2006.03.07.11.03.17;	author espie;	state Exp;
branches;
next	1.1;

1.1
date	2006.03.06.10.40.32;	author espie;	state Exp;
branches;
next	;


desc
@@


1.29
log
@Rename Persistant to Persistent.

sure espie@@
@
text
@# ex:ts=8 sw=4:
# $OpenBSD: SCP.pm,v 1.28 2014/03/18 18:53:29 espie Exp $
#
# Copyright (c) 2003-2006 Marc Espie <espie@@openbsd.org>
#
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

use strict;
use warnings;

use OpenBSD::PackageRepository::Persistent;

package OpenBSD::PackageRepository::SCP;
our @@ISA=qw(OpenBSD::PackageRepository::Persistent);

use IPC::Open2;
use IO::Handle;
use OpenBSD::Paths;

sub urlscheme
{
	return 'scp';
}

# Any SCP repository uses one single connection, reliant on a perl at end.
# The connection starts by xfering and firing up the `distant' script.
sub initiate
{
	my $self = shift;

	my ($rdfh, $wrfh);

	$self->{controller} = open2($rdfh, $wrfh, OpenBSD::Paths->ssh,
	    $self->{host}, 'perl', '-x');
	$self->{cmdfh} = $wrfh;
	$self->{getfh} = $rdfh;
	$wrfh->autoflush(1);
	while(<DATA>) {
		# compress script a bit
		next if m/^\#/o && !m/^\#!/o;
		s/^\s*//o;
		next if m/^$/o;
		print $wrfh $_;
	}
	seek(DATA, 0, 0);
}

1;
__DATA__
# Distant connection script.
#! /usr/bin/perl

my $pid;
my $token = 0;
$|= 1;

sub batch(&)
{
	my $code = shift;
	if (defined $pid) {
		waitpid($pid, 0);
		undef $pid;
	}
	$token++;
	$pid = fork();
	if (!defined $pid) {
		print "ERROR: fork failed: $!\n";
	}
	if ($pid == 0) {
		&$code();
		exit(0);
	}
}

sub abort_batch()
{
	if (defined $pid) {
		kill 1, $pid;
		waitpid($pid, 0);
		undef $pid;
	}
	print "\nABORTED $token\n";
}

my $dirs = {};

sub expand_tilde
{
	my $arg = shift;

	return $dirs->{$arg} //= (getpwnam($arg))[7]."/";
}

while (<STDIN>) {
	chomp;
	if (m/^LIST\s+(.*)$/o) {
		my $dname = $1;
		$dname =~ s/^\/\~(.*?)\//expand_tilde($1)/e;
		batch(sub {
			my $d;
			if (opendir($d, $dname)) {
				print "SUCCESS: directory $dname\n";
			} else {
				print "ERROR: bad directory $dname $!\n";
			}
			while (my $e = readdir($d)) {
				next if $e eq '.' or $e eq '..';
				next unless $e =~ m/(.+)\.tgz$/;
				next unless -f "$dname/$e";
				print "$1\n";
			}
			print "\n";
			closedir($d);
		});
	} elsif (m/^GET\s+(.*)$/o) {
		my $fname = $1;
		$fname =~ s/^\/\~(.*?)\//expand_tilde($1)/e;
		batch(sub {
			if (open(my $fh, '<', $fname)) {
				my $size = (stat $fh)[7];
				print "TRANSFER: $size\n";
				my $buffer = '';
				while (read($fh, $buffer, 1024 * 1024) > 0) {
					print $buffer;
				}
				close($fh);
			} else {
				print "ERROR: bad file $fname $!\n";
			}
		});
	} elsif (m/^BYE$/o) {
		exit(0);
	} elsif (m/^ABORT$/o) {
		abort_batch();
	} else {
		print "ERROR: Unknown command\n";
	}
}
__END__
@


1.28
log
@remove $_ usage that warns under perl 5.18
@
text
@d2 1
a2 1
# $OpenBSD: SCP.pm,v 1.27 2011/07/19 17:30:05 espie Exp $
d21 1
a21 1
use OpenBSD::PackageRepository::Persistant;
d24 1
a24 1
our @@ISA=qw(OpenBSD::PackageRepository::Persistant);
@


1.27
log
@use common code for ssh/http 1.1
@
text
@d2 1
a2 1
# $OpenBSD: SCP.pm,v 1.26 2011/03/23 15:29:31 espie Exp $
a47 2
	my $_;

a103 1
my $_;
@


1.26
log
@cache user name for ~user
@
text
@d2 1
a2 1
# $OpenBSD: SCP.pm,v 1.25 2011/03/23 14:05:35 espie Exp $
d21 2
d24 1
a24 1
our @@ISA=qw(OpenBSD::PackageRepository::Distant);
a34 2
our %distant = ();

a57 111
}


sub may_exist
{
	my ($self, $name) = @@_;
	my $l = $self->list;
	return grep {$_ eq $name } @@$l;
}

sub grab_object
{
	my ($self, $object) = @@_;

	my $cmdfh = $self->{cmdfh};
	my $getfh = $self->{getfh};

	print $cmdfh "ABORT\n";
	my $_;
	while (<$getfh>) {
		last if m/^ABORTED/o;
	}
	print $cmdfh "GET ", $self->{path}.$object->{name}.".tgz", "\n";
	close($cmdfh);
	$_ = <$getfh>;
	chomp;
	if (m/^ERROR:/o) {
		$self->{state}->fatal("transfer error: #1", $_);
	}
	if (m/^TRANSFER:\s+(\d+)/o) {
		my $buffsize = 10 * 1024;
		my $buffer;
		my $size = $1;
		my $remaining = $size;
		my $n;

		do {
			$n = read($getfh, $buffer,
				$remaining < $buffsize ? $remaining :$buffsize);
			if (!defined $n) {
				$self->{state}->fatal("Error reading: #1", $!);
			}
			$remaining -= $n;
			if ($n > 0) {
				syswrite STDOUT, $buffer;
			}
		} while ($n != 0 && $remaining != 0);
		exit(0);
	}
}

sub maxcount
{
	return 1;
}

sub opened
{
	my $self = $_[0];
	my $k = $self->{host};
	if (!defined $distant{$k}) {
		$distant{$k} = [];
	}
	return $distant{$k};
}

sub list
{
	my ($self) = @@_;
	if (!defined $self->{list}) {
		if (!defined $self->{controller}) {
			$self->initiate;
		}
		my $cmdfh = $self->{cmdfh};
		my $getfh = $self->{getfh};
		my $path = $self->{path};
		my $l = [];
		print $cmdfh "LIST $path\n";
		my $_;
		$_ = <$getfh>;
		if (!defined $_) {
			$self->{state}->fatal("Could not initiate SSH session");
		}
		chomp;
		if (m/^ERROR:/o) {
			$self->{state}->fatal("#1", $_);
		}
		if (!m/^SUCCESS:/o) {
			$self->{state}->fatal("Synchronization error");
		}
		while (<$getfh>) {
			chomp;
			last if $_ eq '';
			push(@@$l, $_);
		}
		$self->{list} = $l;
	}
	return $self->{list};
}

sub cleanup
{
	my $self = shift;
	if (defined $self->{controller}) {
		my $cmdfh = $self->{cmdfh};
		my $getfh = $self->{getfh};
		print $cmdfh "ABORT\nBYE\nBYE\n";
		CORE::close($cmdfh);
		CORE::close($getfh);
		waitpid($self->{controller}, 0);
	}
@


1.25
log
@allow scp://hostname/~user/subdir to work
@
text
@d2 1
a2 1
# $OpenBSD: SCP.pm,v 1.24 2010/07/02 11:50:50 espie Exp $
d208 2
d213 2
a214 1
	return (getpwnam($arg))[7]."/";
d217 1
a217 1
local $_;
@


1.24
log
@use state to print error messages
@
text
@d2 1
a2 1
# $OpenBSD: SCP.pm,v 1.23 2010/06/30 10:51:04 espie Exp $
d208 5
d219 1
d238 1
@


1.23
log
@allow say and errsay to work without parameters, as it's ways common.
create verbose_system up in state, because it makes sense without verbose.
@
text
@d2 1
a2 1
# $OpenBSD$
d85 1
a85 1
		die "transfer error: $_";
d98 1
a98 1
				die "Error reading\n";
d139 1
a139 1
			die "Could not initiate SSH session\n";
d143 1
a143 1
			die $_;
d146 1
a146 1
			die "Synchronization error\n";
@


1.22
log
@whitespace cleanup
@
text
@@


1.21
log
@whitespace fixes
@
text
@@


1.20
log
@use Auto::cache
@
text
@d43 1
a43 1
	$self->{controller} = open2($rdfh, $wrfh, OpenBSD::Paths->ssh, 
d59 2
a60 2
	
	
d95 1
a95 1
			$n = read($getfh, $buffer, 
@


1.19
log
@my $_, except for the server code, which could still run on older perl
@
text
@@


1.18
log
@rewind DATA, so that the next scp: url will have code to connect to...
@
text
@d48 1
a48 1
	local $_;
d76 1
a76 1
	local $_;
d136 1
a136 1
		local $_;
@


1.17
log
@synch with rest of work
@
text
@d57 1
@


1.16
log
@use OpenBSD::Paths contents
@
text
@d2 1
a2 1
# $OpenBSD: SCP.pm,v 1.15 2007/06/04 18:52:02 espie Exp $
a107 11
sub _new
{
	my ($class, $baseurl) = @@_;
	if ($baseurl =~ m/^\/\/(.*?)(\/.*)$/o) {
		bless {	host => $1, baseurl => $baseurl, 
		    key => $1, path => $2 }, $class;
	} else {
		die "Invalid scp url: scp:$baseurl\n";
	}
}

d116 1
a116 1
	my $k = $self->{key};
@


1.15
log
@more efficient regexps: anchor stuff at both ends, be more specific in
what matches. Get rid of $`, $', $&, which encur a performance penalty.
(not yet done on PackageName and PkgSpec).
@
text
@d2 1
a2 1
# $OpenBSD: SCP.pm,v 1.14 2007/06/04 14:40:39 espie Exp $
d26 1
d43 2
a44 1
	$self->{controller} = open2($rdfh, $wrfh, 'ssh', $self->{host}, 'perl', '-x');
@


1.14
log
@some minor systematic changes.
- mark all regexps I can with /o if they can be compiled once.
- turn $o->method() into $o->method
- remove unneeded prototypes
- reduce split /re/ into split "string" where possible.
@
text
@d2 1
a2 1
# $OpenBSD: SCP.pm,v 1.13 2007/05/19 09:44:28 espie Exp $
d220 2
a221 2
	if (m/^LIST\s+/o) {
		my $dname = $';
d238 2
a239 2
	} elsif (m/^GET\s+/o) {
		my $fname = $';
@


1.13
log
@fix scp url parsing and printing
@
text
@d2 1
a2 1
# $OpenBSD: SCP.pm,v 1.12 2007/05/17 18:59:38 espie Exp $
d50 3
a52 3
		next if m/^\#/ && !m/^\#!/;
		s/^\s*//;
		next if m/^$/;
d61 1
a61 1
	my $l = $self->list();
d75 1
a75 1
		last if m/^ABORTED/;
d81 1
a81 1
	if (m/^ERROR:/) {
d84 1
a84 1
	if (m/^TRANSFER:\s+(\d+)/) {
d109 1
a109 1
	if ($baseurl =~ m/^\/\/(.*?)(\/.*)$/) {
d137 1
a137 1
			$self->initiate();
d150 1
a150 1
		if (m/^ERROR:/) {
d153 1
a153 1
		if (!m/^SUCCESS:/) {
d220 1
a220 1
	if (m/^LIST\s+/) {
d238 1
a238 1
	} elsif (m/^GET\s+/) {
d253 1
a253 1
	} elsif (m/^BYE$/) {
d255 1
a255 1
	} elsif (m/^ABORT$/) {
@


1.12
log
@do not pass the urlscheme to the constructors, since they each have
a known urlscheme.

Recognize inst: and file: as specific schemes that refer to given
repositories, for future extension.
@
text
@d2 1
a2 1
# $OpenBSD: SCP.pm,v 1.11 2007/05/17 18:17:20 espie Exp $
d109 6
a114 3
	$baseurl =~ s/^\/\///i;
	$baseurl =~ m/\//;
	bless {	host => $`, baseurl => $baseurl, key => $`, path => "/$'" }, $class;
@


1.11
log
@name each urlscheme
@
text
@d2 1
a2 1
# $OpenBSD: SCP.pm,v 1.10 2007/04/15 10:17:29 espie Exp $
d109 1
a109 1
	$baseurl =~ s/scp\:\/\///i;
@


1.10
log
@update copyright years, standardize licence.
reword the introduction to the stuff originally from FreeBSD to clarify
slightly.
@
text
@d2 1
a2 1
# $OpenBSD: SCP.pm,v 1.9 2006/05/26 17:12:09 steven Exp $
d26 5
@


1.9
log
@make pkg_add exit gracefully if it cannot read from a file handle, which
happens when the ssh connection could not be established.

ok espie@@
@
text
@d2 1
a2 1
# $OpenBSD: SCP.pm,v 1.8 2006/03/13 16:08:12 espie Exp $
d4 1
a4 1
# Copyright (c) 2003-2004 Marc Espie <espie@@openbsd.org>
@


1.8
log
@clean-up some name handling:
- package locations always contain a pkgname (except if we don't have it)
- complete it on the repository side to grab the right file.
- no need to pass pkgname/arch on $location->grabPlist(), since it's
already in the location.
@
text
@d2 1
a2 1
# $OpenBSD: SCP.pm,v 1.7 2006/03/08 12:10:48 espie Exp $
d138 3
@


1.7
log
@propagate stuff to be able to explicitly clean-up repositories.
(we can't use a normal destructor, since this will be called for
each fork()ed subprocess).
@
text
@d2 1
a2 1
# $OpenBSD: SCP.pm,v 1.6 2006/03/08 11:22:02 espie Exp $
a56 1
	$name =~ s/\.tgz$//;
d72 1
a72 1
	print $cmdfh "GET ", $self->{path}.$object->{name}, "\n";
@


1.6
log
@fix race condition in SCP for real.

We can't control a grand-child death through gzip, so stop spawning
grand-children: create two children connected by hand through a pipe,
and when we close gzip, explicitly wait for the second child to die
as well.

This avoids race conditions between sigpipe and sigusr1.

(and as usual, the resulting code is easier to follow once you get
through the pipe/fork).

Thanks theo for the comment. ;-)
@
text
@d2 1
a2 1
# $OpenBSD: SCP.pm,v 1.5 2006/03/07 14:18:51 espie Exp $
a155 1
# XXX not used yet
a159 1
		print STDERR "Closing repository\n";
d161 1
d164 1
a165 1
		print STDERR "Repository closed\n";
@


1.5
log
@properly zap temporary file.
@
text
@d2 1
a2 1
# $OpenBSD: SCP.pm,v 1.4 2006/03/07 14:00:48 espie Exp $
a66 4
	$SIG{'USR1'} = sub {
		kill USR1 => $object->{parent};
		exit(1);
	};
a101 16
sub pkg_copy
{
	my ($self, $in, $object) = @@_;

	$SIG{'USR1'} = sub {
		close($in);
		if (defined $object->{tempname}) {
			unlink $object->{tempname};
		}
		kill USR1 => $object->{parent};
		exit(1);
	};

	$self->SUPER::pkg_copy($in, $object);
}

a153 26
}

sub finish_and_close
{
	my ($self, $object) = @@_;
	$self->SUPER::close($object);
}

sub close
{
	my ($self, $object, $hint) = @@_;
	# XXX we have to make sure the grand-child is dead.
	if (defined $object->{pid2}) {
		my $received = 0;
		local $SIG{'USR1'} = sub { $received = 1; };
		kill USR1 => $object->{pid2};
		while (!$received) {
			sleep 0.01;
		}
	}
	close($object->{fh}) if defined $object->{fh};
	
	$self->parse_problems($object->{errors}, $hint) 
	    if defined $object->{errors};
	undef $object->{errors};
	$object->deref();
@


1.4
log
@rendez-vous with subchild through signal USR1.
@
text
@d2 1
a2 1
# $OpenBSD: SCP.pm,v 1.3 2006/03/07 13:25:05 espie Exp $
d112 3
d188 1
a188 1
		local $SIG{'USR1'} = sub { print STDERR "Received USR1\n"; $received = 1; };
@


1.3
log
@only the grand child can have issues
@
text
@d2 1
a2 1
# $OpenBSD: SCP.pm,v 1.2 2006/03/07 11:03:17 espie Exp $
d67 5
a78 1

d106 13
a181 1
	close($object->{fh}) if defined $object->{fh};
d184 5
a188 4
		my $sleep = 0.05;
		while (kill 0 => $object->{pid2}) {
			sleep($sleep);
			$sleep *= 2;
d191 1
@


1.2
log
@let scp repositories work. Avoid run-away processes by just having one single
ssh connection for each repository.
@
text
@d2 1
a2 1
# $OpenBSD: SCP.pm,v 1.1 2006/03/06 10:40:32 espie Exp $
d166 6
a171 8
	# XXX we have to make sure the children are dead.
	for my $child (qw(pid pid2)) {
		if (defined $object->{$child}) {
			my $sleep = 0.05;
			while (kill 0 => $object->{$child}) {
				sleep($sleep);
				$sleep *= 2;
			}
@


1.1
log
@take some infrequently used code completely out of the way.
@
text
@d2 1
a2 1
# $OpenBSD: PackageRepository.pm,v 1.1 2006/03/04 13:13:05 espie Exp $
d24 36
d65 35
a99 5
	exec {"/usr/bin/scp"} 
	    "scp", 
	    $self->{host}.":".$self->{path}.$object->{name}, 
	    "/dev/stdout"
	or die "can't run scp";
d102 7
a108 1
our %distant = ();
d112 1
a112 1
	return 2;
a124 8
sub _new
{
	my ($class, $baseurl) = @@_;
	$baseurl =~ s/scp\:\/\///i;
	$baseurl =~ m/\//;
	bless {	host => $`, key => $`, path => "/$'" }, $class;
}

d129 5
a133 1
		my $host = $self->{host};
d135 17
a151 1
		$self->{list} = $self->_list("ssh $host ls -l $path");
d156 41
d198 82
@

