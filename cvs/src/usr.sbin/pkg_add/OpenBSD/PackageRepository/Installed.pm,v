head	1.38;
access;
symbols
	OPENBSD_6_2:1.38.0.6
	OPENBSD_6_2_BASE:1.38
	OPENBSD_6_1:1.38.0.4
	OPENBSD_6_1_BASE:1.38
	OPENBSD_6_0:1.34.0.4
	OPENBSD_6_0_BASE:1.34
	OPENBSD_5_9:1.33.0.2
	OPENBSD_5_9_BASE:1.33
	OPENBSD_5_8:1.33.0.4
	OPENBSD_5_8_BASE:1.33
	OPENBSD_5_7:1.29.0.2
	OPENBSD_5_7_BASE:1.29
	OPENBSD_5_6:1.29.0.4
	OPENBSD_5_6_BASE:1.29
	OPENBSD_5_5:1.28.0.4
	OPENBSD_5_5_BASE:1.28
	OPENBSD_5_4:1.26.0.14
	OPENBSD_5_4_BASE:1.26
	OPENBSD_5_3:1.26.0.12
	OPENBSD_5_3_BASE:1.26
	OPENBSD_5_2:1.26.0.10
	OPENBSD_5_2_BASE:1.26
	OPENBSD_5_1_BASE:1.26
	OPENBSD_5_1:1.26.0.8
	OPENBSD_5_0:1.26.0.6
	OPENBSD_5_0_BASE:1.26
	OPENBSD_4_9:1.26.0.4
	OPENBSD_4_9_BASE:1.26
	OPENBSD_4_8:1.26.0.2
	OPENBSD_4_8_BASE:1.26
	OPENBSD_4_7:1.21.0.2
	OPENBSD_4_7_BASE:1.21
	OPENBSD_4_6:1.14.0.4
	OPENBSD_4_6_BASE:1.14
	OPENBSD_4_5:1.12.0.8
	OPENBSD_4_5_BASE:1.12
	OPENBSD_4_4:1.12.0.6
	OPENBSD_4_4_BASE:1.12
	OPENBSD_4_3:1.12.0.4
	OPENBSD_4_3_BASE:1.12
	OPENBSD_4_2:1.12.0.2
	OPENBSD_4_2_BASE:1.12;
locks; strict;
comment	@# @;


1.38
date	2017.03.11.11.25.01;	author espie;	state Exp;
branches;
next	1.37;
commitid	k6Bnb18Aa8kAcKqT;

1.37
date	2016.09.15.12.53.08;	author espie;	state Exp;
branches;
next	1.36;
commitid	T32lHWrXXaHrnk35;

1.36
date	2016.09.14.13.42.19;	author espie;	state Exp;
branches;
next	1.35;
commitid	zj6Hy6ytm5K6ku2B;

1.35
date	2016.09.05.10.36.21;	author espie;	state Exp;
branches;
next	1.34;
commitid	O5HZ8gs7tNjk4bN3;

1.34
date	2016.06.14.20.49.03;	author espie;	state Exp;
branches;
next	1.33;
commitid	sx31TH89ATrwgXsN;

1.33
date	2015.06.25.13.33.25;	author sthen;	state Exp;
branches;
next	1.32;
commitid	hjphmFL7sGjqZ51j;

1.32
date	2015.04.16.14.08.19;	author espie;	state Exp;
branches;
next	1.31;
commitid	vDgWLGGpGcr65K7t;

1.31
date	2015.04.16.13.29.16;	author espie;	state Exp;
branches;
next	1.30;
commitid	glpsNd6nX6NAzNf5;

1.30
date	2015.04.16.09.32.23;	author espie;	state Exp;
branches;
next	1.29;
commitid	Nsp1TyPshg4itCKw;

1.29
date	2014.06.15.23.49.51;	author afresh1;	state Exp;
branches;
next	1.28;
commitid	YRvhirTYs3Wbreq2;

1.28
date	2014.01.09.20.20.01;	author espie;	state Exp;
branches;
next	1.27;

1.27
date	2014.01.07.01.29.17;	author espie;	state Exp;
branches;
next	1.26;

1.26
date	2010.07.02.11.17.46;	author espie;	state Exp;
branches;
next	1.25;

1.25
date	2010.06.30.10.51.04;	author espie;	state Exp;
branches;
next	1.24;

1.24
date	2010.06.30.10.41.42;	author espie;	state Exp;
branches;
next	1.23;

1.23
date	2010.06.30.10.37.26;	author espie;	state Exp;
branches;
next	1.22;

1.22
date	2010.05.10.09.17.55;	author espie;	state Exp;
branches;
next	1.21;

1.21
date	2010.03.06.11.55.31;	author espie;	state Exp;
branches;
next	1.20;

1.20
date	2010.01.10.11.32.41;	author espie;	state Exp;
branches;
next	1.19;

1.19
date	2010.01.09.12.01.57;	author espie;	state Exp;
branches;
next	1.18;

1.18
date	2010.01.09.11.26.58;	author espie;	state Exp;
branches;
next	1.17;

1.17
date	2010.01.09.10.44.42;	author espie;	state Exp;
branches;
next	1.16;

1.16
date	2010.01.05.11.31.07;	author espie;	state Exp;
branches;
next	1.15;

1.15
date	2009.11.10.14.37.20;	author espie;	state Exp;
branches;
next	1.14;

1.14
date	2009.04.19.15.18.23;	author espie;	state Exp;
branches;
next	1.13;

1.13
date	2009.04.19.14.58.32;	author espie;	state Exp;
branches;
next	1.12;

1.12
date	2007.06.10.17.13.48;	author espie;	state Exp;
branches;
next	1.11;

1.11
date	2007.05.30.11.04.31;	author espie;	state Exp;
branches;
next	1.10;

1.10
date	2007.05.19.09.45.33;	author espie;	state Exp;
branches;
next	1.9;

1.9
date	2007.05.19.09.18.55;	author espie;	state Exp;
branches;
next	1.8;

1.8
date	2007.05.18.12.28.26;	author espie;	state Exp;
branches;
next	1.7;

1.7
date	2007.05.17.18.52.58;	author espie;	state Exp;
branches;
next	1.6;

1.6
date	2007.05.17.18.17.20;	author espie;	state Exp;
branches;
next	1.5;

1.5
date	2007.05.14.11.22.00;	author espie;	state Exp;
branches;
next	1.4;

1.4
date	2007.05.14.10.43.45;	author espie;	state Exp;
branches;
next	1.3;

1.3
date	2007.05.14.10.24.58;	author espie;	state Exp;
branches;
next	1.2;

1.2
date	2007.05.14.10.19.01;	author espie;	state Exp;
branches;
next	1.1;

1.1
date	2007.05.14.10.12.24;	author espie;	state Exp;
branches;
next	;


desc
@@


1.38
log
@tweak %m to expand to %c, and make %c more magical:
on a -stable system, %c/packages will expand to
two directories in support of packages-stable,
with the -stable directory being "silent".

Also add a -Dsnap option that forces %c to be snapshots
so that the last weeks of testing of release are less
painful.

okay aja@@
@
text
@# ex:ts=8 sw=4:
# $OpenBSD: Installed.pm,v 1.37 2016/09/15 12:53:08 espie Exp $
#
# Copyright (c) 2007-2014 Marc Espie <espie@@openbsd.org>
#
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

use strict;
use warnings;

# XXX: we want to be able to load PackageRepository::Installed stand-alone,
# so we put the only common method into PackageRepositoryBase.
#
# later, when we load the base PackageRepository, we tweak the inheritance
# of PackageRepository::Installed to have full access...

package OpenBSD::PackageRepositoryBase;

my ($version, $current);

sub is_local_file
{
	return 0;
}

sub expand_locations
{
	my ($class, $string, $state) = @@_;
	require OpenBSD::Paths;
	if ($string eq '%a') {
		return OpenBSD::Paths->machine_architecture;
	} elsif ($string eq '%v') {
		return OpenBSD::Paths->os_version;
	} elsif ($string eq '%m') {
		return join('/',
		    'pub/OpenBSD', 
		    '%c',
		    'packages', 
		    OpenBSD::Paths->machine_architecture);
	}
}

sub parse_url
{
	my ($class, $r, $state) = @@_;

	my $path;

	if ($$r =~ m/^(.*?)\:(.*)/) {
		$path = $1;
		$$r = $2;
	} else {
		$path = $$r;
		$$r = '';
	}

	$path =~ s/\%[vam]\b/$class->expand_locations($&, $state)/ge;
	# make %c magical: if we're on a release, we expand into
	# stable, and leave the release dir for the full object with
	# host to push back
	my $release;
	if ($path =~ m/\%c\b/) {
		my $d = $state->defines('snap') ?
		    'snapshots' : OpenBSD::Paths->os_directory;
		if ($d ne 'snapshots' && $path =~ m,\%c/packages/,) {
			$release = $path;
			$release =~ s,\%c\b,$d,;
			$path =~ s,\%c/packages/,$d/packages-stable/,;
		} else {
			$path =~ s,\%c\b,$d,;
	    	}
	}
	$path .= '/' unless $path =~ m/\/$/;
	bless { path => $path, release => $release, state => $state }, $class;
}

sub parse_fullurl
{
	my ($class, $r, $state) = @@_;

	$class->strip_urlscheme($r) or return undef;
	return $class->parse_url($r, $state);
}

sub strip_urlscheme
{
	my ($class, $r) = @@_;
	if ($$r =~ m/^(.*?)\:(.*)$/) {
		my $scheme = lc($1);
		if ($scheme eq $class->urlscheme) {
			$$r = $2;
			return 1;
	    	}
	}
	return 0;
}

sub match_locations
{
	my ($self, $search, @@filters) = @@_;
	my $l = $search->match_locations($self);
	while (my $filter = (shift @@filters)) {
		last if @@$l == 0; # don't bother filtering empty list
		$l = $filter->filter_locations($l);
	}
	return $l;
}

sub url
{
	my ($self, $name) = @@_;
	return $self->urlscheme.':'.$self->relative_url($name);
}

sub finish_and_close
{
	my ($self, $object) = @@_;
	$self->close($object);
}

sub close_now
{
	my ($self, $object) = @@_;
	$self->close($object, 0);
}

sub close_after_error
{
	my ($self, $object) = @@_;
	$self->close($object, 1);
}

sub close_with_client_error
{
	my ($self, $object) = @@_;
	$self->close($object, 1);
}

sub canonicalize
{
	my ($self, $name) = @@_;

	if (defined $name) {
		$name =~ s/\.tgz$//o;
	}
	return $name;
}

sub new_location
{
	my ($self, @@args) = @@_;

	return $self->locationClassName->new($self, @@args);
}

sub locationClassName
{ "OpenBSD::PackageLocation" }

sub locations_list
{
	my $self = shift;
	if (!defined $self->{locations}) {
		my $l = [];
		require OpenBSD::PackageLocation;

		for my $name (@@{$self->list}) {
			push @@$l, $self->new_location($name);
		}
		$self->{locations} = $l;
	}
	return $self->{locations};
}

sub reinitialize
{
}

package OpenBSD::PackageRepository::Installed;

our @@ISA = (qw(OpenBSD::PackageRepositoryBase));

sub urlscheme
{
	return 'inst';
}

use OpenBSD::PackageInfo (qw(is_installed installed_info
    installed_packages installed_stems installed_name));

sub new
{
	my ($class, $all, $state) = @@_;
	return bless { all => $all, state => $state }, $class;
}

sub relative_url
{
	my ($self, $name) = @@_;
	$name or '';
}

sub close
{
}

sub make_error_file
{
}

sub canonicalize
{
	my ($self, $name) = @@_;
	return installed_name($name);
}

sub find
{
	my ($repository, $name, $arch) = @@_;
	my $self;

	if (is_installed($name)) {
		require OpenBSD::PackageLocation;

		$self = $repository->new_location($name);
		$self->{dir} = installed_info($name);
	}
	return $self;
}

sub locationClassName
{ "OpenBSD::PackageLocation::Installed" }

sub grabPlist
{
	my ($repository, $name, $arch, $code) = @@_;
	require OpenBSD::PackingList;
	return  OpenBSD::PackingList->from_installation($name, $code);
}

sub available
{
	my $self = shift;
	return installed_packages($self->{all});
}

sub list
{
	my $self = shift;
	my @@list = installed_packages($self->{all});
	return \@@list;
}

sub stemlist
{
	return installed_stems();
}

sub wipe_info
{
}

sub may_exist
{
	my ($self, $name) = @@_;
	return is_installed($name);
}

1;
@


1.37
log
@move the error saving code slightly around
still not perfect
@
text
@d2 1
a2 1
# $OpenBSD: Installed.pm,v 1.36 2016/09/14 13:42:19 espie Exp $
a43 2
	} elsif ($string eq '%c') {
		return OpenBSD::Paths->os_directory;
d47 1
a47 1
		    OpenBSD::Paths->os_directory,
d67 16
a82 1
	$path =~ s/\%[vacm]\b/$class->expand_locations($&, $state)/ge;
d84 1
a84 1
	bless { path => $path, state => $state }, $class;
@


1.36
log
@add an is_local-file method for later signature
@
text
@d2 1
a2 1
# $OpenBSD: Installed.pm,v 1.35 2016/09/05 10:36:21 espie Exp $
a94 4
sub make_error_file
{
}

d200 4
@


1.35
log
@forgot to provide an empty method
@
text
@d2 1
a2 1
# $OpenBSD: Installed.pm,v 1.34 2016/06/14 20:49:03 espie Exp $
d30 5
@


1.34
log
@restrict %m and friends to "separate words" so they won't collide with
branch specifiers. Unlikely, but better safe than sorry.
@
text
@d2 1
a2 1
# $OpenBSD: Installed.pm,v 1.33 2015/06/25 13:33:25 sthen Exp $
d88 4
@


1.33
log
@use machine_architecture (arch -s) when assembling PKG_PATHs using %m or %a,
fixes these variables with arch like powerpc where this differs from "uname -m".

reported by/ok aja@@
@
text
@d2 1
a2 1
# $OpenBSD: Installed.pm,v 1.32 2015/04/16 14:08:19 espie Exp $
d64 1
a64 1
	$path =~ s/\%[vacm]/$class->expand_locations($&, $state)/ge;
@


1.32
log
@add %m as a shorthand, will expand to
pub/OpenBSD/5.7/packages/amd64
for lazy typers.

okay aja@@
@
text
@d2 1
a2 1
# $OpenBSD: Installed.pm,v 1.31 2015/04/16 13:29:16 espie Exp $
d36 1
a36 1
		return OpenBSD::Paths->architecture;
d46 1
a46 1
		    OpenBSD::Paths->architecture);
@


1.31
log
@reorg code, the arch/osversion code should live in a single place,
short and sweet
@
text
@d2 1
a2 1
# $OpenBSD: Installed.pm,v 1.30 2015/04/16 09:32:23 espie Exp $
d41 6
d64 1
a64 1
	$path =~ s/\%[vac]/$class->expand_locations($&, $state)/ge;
@


1.30
log
@commit expanded tags for %c, %v, %a
@
text
@d2 1
a2 1
# $OpenBSD: Installed.pm,v 1.29 2014/06/15 23:49:51 afresh1 Exp $
d34 1
d36 5
a40 25
		require OpenBSD::PackingElement;
		return OpenBSD::PackingElement::Arch::arch();
	} else {
		if (!defined $version) {
			require OpenBSD::Paths;
			open my $cmd, '-|', 
			    OpenBSD::Paths->sysctl, '-n', 'kern.version';
			my $line = <$cmd>;
			close($cmd);
			if ($line =~ m/^OpenBSD (\d\.\d)(\S*)\s/) {
				$version = $1;
				if ($2 eq '-current') {
					$current = 'snapshots';
				} else {
					$current = $version;
				}
			} else {
				$state->fatal("Can't figure out version");
			}
		}
		if ($string eq '%c') {
			return $current;
		} else {
			return $version;
		}
@


1.29
log
@Correct precedence for returned value.

style suggested and ok espie@@
@
text
@d2 1
a2 1
# $OpenBSD: Installed.pm,v 1.28 2014/01/09 20:20:01 espie Exp $
d29 34
d77 1
@


1.28
log
@bump copyright to 2014
@
text
@d2 1
a2 1
# $OpenBSD: Installed.pm,v 1.27 2014/01/07 01:29:17 espie Exp $
d169 1
a169 1
	return $name or '';
@


1.27
log
@new method: reinitialize, for repositories with a sequential connection
that need a new connection if they're ever called from separate processes
simultaneously
@
text
@d2 1
a2 1
# $OpenBSD: Installed.pm,v 1.26 2010/07/02 11:17:46 espie Exp $
d4 1
a4 1
# Copyright (c) 2007-2010 Marc Espie <espie@@openbsd.org>
@


1.26
log
@pass (and save) state around in Repository-related stuff.
@
text
@d2 1
a2 1
# $OpenBSD: Installed.pm,v 1.25 2010/06/30 10:51:04 espie Exp $
d142 4
@


1.25
log
@allow say and errsay to work without parameters, as it's ways common.
create verbose_system up in state, because it makes sense without verbose.
@
text
@d2 1
a2 1
# $OpenBSD$
d31 1
a31 1
	my ($class, $r) = @@_;
d44 1
a44 1
	bless { path => $path }, $class;
d49 1
a49 1
	my ($class, $_) = @@_;
d51 2
a52 2
	$class->strip_urlscheme($_) or return undef;
	return $class->parse_url($_);
a155 3
my $singleton = bless {}, __PACKAGE__;
my $s2 = bless {all => 1}, __PACKAGE__;

d158 2
a159 1
	return $_[1] ? $s2 : $singleton;
@


1.24
log
@whitespace cleanup
@
text
@@


1.23
log
@extra parameter to UpdateSet: use the factory to create extra object.
don't create updatesets directly, go through AddDelete::State.
Get all Locator/Repo access through state.
@
text
@@


1.22
log
@whitespace fixes
@
text
@@


1.21
log
@fix very stupid typo
@
text
@d42 1
a42 1
		
d153 1
a153 1
use OpenBSD::PackageInfo (qw(is_installed installed_info 
@


1.20
log
@bump copyright
@
text
@d37 1
a37 1
		$$r = 2;
@


1.19
log
@fixed version, somehow I forgot that I use parse to do weird things with
PKG_PATH...
@
text
@d4 1
a4 1
# Copyright (c) 2007 Marc Espie <espie@@openbsd.org>
@


1.18
log
@temporary revert until I figure this out
@
text
@d29 39
@


1.17
log
@move some url parsing into Installed, provide for pipe:
@
text
@a28 28
sub parse_url
{
	my ($class, $path) = @@_;
	$path .= '/' unless $path =~ m/\/$/;
	bless { path => $path }, $class;
}

sub parse_fullurl
{
	my ($class, $_) = @@_;

	$class->strip_urlscheme(\$_) or return undef;
	return $class->parse_url($_);
}

sub strip_urlscheme
{
	my ($class, $r) = @@_;
	if ($$r =~ m/^(.*?)\:(.*)$/) {
		my $scheme = lc($1);
		if ($scheme eq $class->urlscheme) {
			$$r = $2;
			return 1;
	    	}
	}
	return 0;
}

@


1.16
log
@use Auto::cache
@
text
@d29 28
@


1.15
log
@kill more unused code
@
text
@@


1.14
log
@remove class FatPackageLocation. Instead make PackageLocation a hierarchy
so that I can handle installed packages without playing ping-pong with
the PackageRepository hierarchy (mostly)
@
text
@a28 11
sub match
{
	my ($self, $search, @@filters) = @@_;
	my @@l = $search->match($self);
	while (my $filter = (shift @@filters)) {
		last if @@l == 0; # don't bother filtering empty list
		@@l = $filter->filter(@@l);
	}
	return @@l;
}

@


1.13
log
@synch with my new style search/location changes
It's likely there will be some fallout, but it's getting a bit too large
to keep around.
This does kill a few very old oddities as well.
@
text
@d91 10
d109 1
a109 1
			push @@$l, OpenBSD::PackageLocation->new($self, $name);
a115 11
sub grab_info
{
	my ($repository, $location) = @@_;
	$location->grabInfoFiles;
}

sub get_plist
{
	my ($repository, $location, $code) = @@_;
	$location->_plist($code);
}
d160 1
a160 1
		$self = OpenBSD::PackageLocation->new($repository, $name);
d166 2
a167 12
sub grab_info
{
	my ($repository, $location) = @@_;
	$location->{dir} = installed_info($location->name);
}

sub get_plist
{
	my ($repository, $location, $code) = @@_;
	require OpenBSD::PackingList;
	return OpenBSD::PackingList->from_installation($location->name, $code);
}
@


1.12
log
@give repository/locations slightly more control over package names.
@
text
@d2 1
a2 1
# $OpenBSD: Installed.pm,v 1.11 2007/05/30 11:04:31 espie Exp $
d43 1
a43 1
	my @@l = $search->match_locations($self);
d45 2
a46 2
		last if @@l == 0; # don't bother filtering empty list
		@@l = $filter->filter_locations(@@l);
d48 1
a48 1
	return @@l;
d91 26
d152 1
d165 13
@


1.11
log
@move close methods so that error paths can proceed on Repository::Installed.
@
text
@d2 1
a2 1
# $OpenBSD: Installed.pm,v 1.10 2007/05/19 09:45:33 espie Exp $
d81 10
d121 5
d134 1
a134 1
		$self = OpenBSD::PackageLocation->new($repository, installed_name($name));
@


1.10
log
@add match_locations/filter_locations methods to search stuff that returns
full pkg locations instead of package names.
@
text
@d2 1
a2 1
# $OpenBSD: Installed.pm,v 1.9 2007/05/19 09:18:55 espie Exp $
d57 24
d105 4
@


1.9
log
@don't pass srcpath around, since we don't use it.
@
text
@d2 1
a2 1
# $OpenBSD: Installed.pm,v 1.8 2007/05/18 12:28:26 espie Exp $
d36 11
@


1.8
log
@normalize installed names
@
text
@d2 1
a2 1
# $OpenBSD: Installed.pm,v 1.7 2007/05/17 18:52:58 espie Exp $
d74 1
a74 1
	my ($repository, $name, $arch, $srcpath) = @@_;
@


1.7
log
@new methods: repositories can create url. Rename PackageLocation->stringize
to url, since that's what it does. Use the new methods to shorten code.
@
text
@d2 1
a2 1
# $OpenBSD: Installed.pm,v 1.6 2007/05/17 18:17:20 espie Exp $
d56 1
a56 1
    installed_packages installed_stems));
d80 1
a80 1
		$self = OpenBSD::PackageLocation->new($repository, $name);
@


1.6
log
@name each urlscheme
@
text
@d2 1
a2 1
# $OpenBSD: Installed.pm,v 1.5 2007/05/14 11:22:00 espie Exp $
d40 6
d50 1
a50 1
sub urlschem
d64 6
@


1.5
log
@redo search filters as real objects. Accordingly, rename match_list to
filter.
@
text
@d2 1
a2 1
# $OpenBSD: Installed.pm,v 1.4 2007/05/14 10:43:45 espie Exp $
d43 5
@


1.4
log
@name tweaks: match -> match_list, match_repo -> match
@
text
@d2 1
a2 1
# $OpenBSD: Installed.pm,v 1.3 2007/05/14 10:24:58 espie Exp $
d31 5
a35 5
	my ($self, $search, $filter) = @@_;
	if (defined $filter) {
		return &$filter($search->match($self));
	} else {
		return $search->match($self);
d37 1
@


1.3
log
@two repos: new(1) gives all packages. new() zaps .libs and friends.
@
text
@d2 1
a2 1
# $OpenBSD: Installed.pm,v 1.2 2007/05/14 10:19:01 espie Exp $
d33 1
a33 1
		return &$filter($search->match_repo($self));
d35 1
a35 1
		return $search->match_repo($self);
@


1.2
log
@load PackageLocation just in time. Control what we import from
PackageInfo.
@
text
@d2 1
a2 1
# $OpenBSD: Installed.pm,v 1.1 2007/05/14 10:12:24 espie Exp $
d47 1
d51 1
a51 1
	return $singleton;
d77 2
a78 1
	return installed_packages();
d83 2
a84 1
	my @@list = installed_packages();
@


1.1
log
@move code around to allow OO access to installed packages always.
@
text
@d2 1
a2 1
# $OpenBSD: PackageRepository.pm,v 1.30 2007/05/14 10:00:08 espie Exp $
d43 2
a44 1
use OpenBSD::PackageInfo;
d59 2
@

