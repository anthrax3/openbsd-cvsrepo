head	1.143;
access;
symbols
	OPENBSD_6_2_BASE:1.143
	OPENBSD_6_1:1.142.0.4
	OPENBSD_6_1_BASE:1.142
	OPENBSD_6_0:1.137.0.4
	OPENBSD_6_0_BASE:1.137
	OPENBSD_5_9:1.135.0.4
	OPENBSD_5_9_BASE:1.135
	OPENBSD_5_8:1.135.0.6
	OPENBSD_5_8_BASE:1.135
	OPENBSD_5_7:1.135.0.2
	OPENBSD_5_7_BASE:1.135
	OPENBSD_5_6:1.133.0.4
	OPENBSD_5_6_BASE:1.133
	OPENBSD_5_5:1.132.0.4
	OPENBSD_5_5_BASE:1.132
	OPENBSD_5_4:1.121.0.4
	OPENBSD_5_4_BASE:1.121
	OPENBSD_5_3:1.121.0.2
	OPENBSD_5_3_BASE:1.121
	OPENBSD_5_2:1.120.0.2
	OPENBSD_5_2_BASE:1.120
	OPENBSD_5_1_BASE:1.117
	OPENBSD_5_1:1.117.0.2
	OPENBSD_5_0:1.114.0.2
	OPENBSD_5_0_BASE:1.114
	OPENBSD_4_9:1.111.0.2
	OPENBSD_4_9_BASE:1.111
	OPENBSD_4_8:1.109.0.2
	OPENBSD_4_8_BASE:1.109
	OPENBSD_4_7:1.101.0.2
	OPENBSD_4_7_BASE:1.101
	OPENBSD_4_6:1.90.0.4
	OPENBSD_4_6_BASE:1.90
	OPENBSD_4_5:1.85.0.2
	OPENBSD_4_5_BASE:1.85
	OPENBSD_4_4:1.83.0.2
	OPENBSD_4_4_BASE:1.83
	OPENBSD_4_3:1.81.0.2
	OPENBSD_4_3_BASE:1.81
	OPENBSD_4_2:1.80.0.2
	OPENBSD_4_2_BASE:1.80
	OPENBSD_4_1:1.52.0.2
	OPENBSD_4_1_BASE:1.52
	OPENBSD_4_0:1.50.0.4
	OPENBSD_4_0_BASE:1.50
	OPENBSD_3_9:1.50.0.2
	OPENBSD_3_9_BASE:1.50
	OPENBSD_3_8:1.47.0.2
	OPENBSD_3_8_BASE:1.47
	OPENBSD_3_7:1.44.0.2
	OPENBSD_3_7_BASE:1.44
	OPENBSD_3_6:1.21.0.2
	OPENBSD_3_6_BASE:1.21
	OPENBSD_3_5:1.6.0.2
	OPENBSD_3_5_BASE:1.6
	pkgtools:1.1.1.1
	espie:1.1.1;
locks; strict;
comment	@# @;


1.143
date	2017.09.16.11.36.25;	author espie;	state Exp;
branches;
next	1.142;
commitid	ulE0zXUtvlHkfCk2;

1.142
date	2016.10.04.14.24.45;	author espie;	state Exp;
branches;
next	1.141;
commitid	yvjaENhqw9SEhrSb;

1.141
date	2016.09.27.21.31.20;	author naddy;	state Exp;
branches;
next	1.140;
commitid	V5PNFIkfVXShTRqF;

1.140
date	2016.09.08.09.51.15;	author espie;	state Exp;
branches;
next	1.139;
commitid	QWEcc8Lx3uBKjkRa;

1.139
date	2016.09.04.12.08.49;	author espie;	state Exp;
branches;
next	1.138;
commitid	FzUsHEbzjmXlu7Kf;

1.138
date	2016.07.27.13.02.03;	author espie;	state Exp;
branches;
next	1.137;
commitid	NENxgL49ZmgGbJOw;

1.137
date	2016.06.25.18.02.59;	author espie;	state Exp;
branches;
next	1.136;
commitid	o0xYSWZBh7faPr35;

1.136
date	2016.06.14.15.41.31;	author espie;	state Exp;
branches;
next	1.135;
commitid	XOkjG8dyAbBzo5Y6;

1.135
date	2014.10.13.12.44.16;	author espie;	state Exp;
branches;
next	1.134;
commitid	O74FclwE2iqZYO3l;

1.134
date	2014.09.09.09.40.23;	author espie;	state Exp;
branches;
next	1.133;
commitid	3LnGk6tZmORiAACe;

1.133
date	2014.03.18.18.53.29;	author espie;	state Exp;
branches;
next	1.132;

1.132
date	2014.02.08.15.07.12;	author espie;	state Exp;
branches;
next	1.131;

1.131
date	2014.02.04.18.11.36;	author espie;	state Exp;
branches;
next	1.130;

1.130
date	2014.02.01.11.03.50;	author espie;	state Exp;
branches;
next	1.129;

1.129
date	2014.01.11.11.51.01;	author espie;	state Exp;
branches;
next	1.128;

1.128
date	2014.01.09.20.20.01;	author espie;	state Exp;
branches;
next	1.127;

1.127
date	2014.01.07.01.38.58;	author espie;	state Exp;
branches;
next	1.126;

1.126
date	2014.01.04.14.14.55;	author espie;	state Exp;
branches;
next	1.125;

1.125
date	2014.01.04.00.14.08;	author espie;	state Exp;
branches;
next	1.124;

1.124
date	2013.12.31.11.21.10;	author espie;	state Exp;
branches;
next	1.123;

1.123
date	2013.12.30.09.14.49;	author espie;	state Exp;
branches;
next	1.122;

1.122
date	2013.12.25.14.38.15;	author espie;	state Exp;
branches;
next	1.121;

1.121
date	2012.12.28.15.09.09;	author espie;	state Exp;
branches;
next	1.120;

1.120
date	2012.06.08.15.01.00;	author espie;	state Exp;
branches;
next	1.119;

1.119
date	2012.05.15.08.14.29;	author espie;	state Exp;
branches;
next	1.118;

1.118
date	2012.05.05.10.20.58;	author espie;	state Exp;
branches;
next	1.117;

1.117
date	2011.08.27.08.57.39;	author espie;	state Exp;
branches;
next	1.116;

1.116
date	2011.08.26.08.47.45;	author espie;	state Exp;
branches;
next	1.115;

1.115
date	2011.08.26.08.46.10;	author espie;	state Exp;
branches;
next	1.114;

1.114
date	2011.06.16.14.48.36;	author espie;	state Exp;
branches;
next	1.113;

1.113
date	2011.06.01.11.20.04;	author espie;	state Exp;
branches;
next	1.112;

1.112
date	2011.05.30.09.59.38;	author espie;	state Exp;
branches;
next	1.111;

1.111
date	2010.12.24.09.04.14;	author espie;	state Exp;
branches;
next	1.110;

1.110
date	2010.10.27.14.35.56;	author espie;	state Exp;
branches;
next	1.109;

1.109
date	2010.07.31.11.30.50;	author espie;	state Exp;
branches;
next	1.108;

1.108
date	2010.06.30.10.51.04;	author espie;	state Exp;
branches;
next	1.107;

1.107
date	2010.06.30.10.41.42;	author espie;	state Exp;
branches;
next	1.106;

1.106
date	2010.06.05.16.22.08;	author espie;	state Exp;
branches;
next	1.105;

1.105
date	2010.05.10.09.17.55;	author espie;	state Exp;
branches;
next	1.104;

1.104
date	2010.04.19.10.22.59;	author espie;	state Exp;
branches;
next	1.103;

1.103
date	2010.04.05.16.07.10;	author espie;	state Exp;
branches;
next	1.102;

1.102
date	2010.03.22.20.38.44;	author espie;	state Exp;
branches;
next	1.101;

1.101
date	2010.01.10.11.31.08;	author espie;	state Exp;
branches;
next	1.100;

1.100
date	2010.01.09.17.44.21;	author espie;	state Exp;
branches;
next	1.99;

1.99
date	2010.01.02.12.52.18;	author espie;	state Exp;
branches;
next	1.98;

1.98
date	2010.01.01.16.09.35;	author espie;	state Exp;
branches;
next	1.97;

1.97
date	2010.01.01.13.36.07;	author espie;	state Exp;
branches;
next	1.96;

1.96
date	2009.12.30.09.39.08;	author espie;	state Exp;
branches;
next	1.95;

1.95
date	2009.12.26.16.58.11;	author espie;	state Exp;
branches;
next	1.94;

1.94
date	2009.12.12.17.18.48;	author espie;	state Exp;
branches;
next	1.93;

1.93
date	2009.12.12.07.44.03;	author espie;	state Exp;
branches;
next	1.92;

1.92
date	2009.11.15.08.46.36;	author espie;	state Exp;
branches;
next	1.91;

1.91
date	2009.11.03.11.03.19;	author espie;	state Exp;
branches;
next	1.90;

1.90
date	2009.07.03.17.02.02;	author naddy;	state Exp;
branches;
next	1.89;

1.89
date	2009.06.25.07.41.04;	author espie;	state Exp;
branches;
next	1.88;

1.88
date	2009.04.19.14.58.32;	author espie;	state Exp;
branches;
next	1.87;

1.87
date	2009.04.14.17.53.58;	author espie;	state Exp;
branches;
next	1.86;

1.86
date	2009.03.05.10.43.00;	author espie;	state Exp;
branches;
next	1.85;

1.85
date	2008.10.20.10.25.16;	author espie;	state Exp;
branches;
next	1.84;

1.84
date	2008.10.06.09.36.17;	author espie;	state Exp;
branches;
next	1.83;

1.83
date	2008.06.06.15.02.57;	author espie;	state Exp;
branches;
next	1.82;

1.82
date	2008.06.01.10.09.39;	author espie;	state Exp;
branches;
next	1.81;

1.81
date	2007.12.08.15.54.45;	author espie;	state Exp;
branches;
next	1.80;

1.80
date	2007.06.20.13.44.39;	author espie;	state Exp;
branches;
next	1.79;

1.79
date	2007.06.19.10.47.28;	author espie;	state Exp;
branches;
next	1.78;

1.78
date	2007.06.12.09.53.36;	author espie;	state Exp;
branches;
next	1.77;

1.77
date	2007.06.06.12.32.09;	author espie;	state Exp;
branches;
next	1.76;

1.76
date	2007.06.04.14.40.39;	author espie;	state Exp;
branches;
next	1.75;

1.75
date	2007.06.01.20.39.41;	author espie;	state Exp;
branches;
next	1.74;

1.74
date	2007.05.31.13.33.17;	author espie;	state Exp;
branches;
next	1.73;

1.73
date	2007.05.31.13.11.21;	author espie;	state Exp;
branches;
next	1.72;

1.72
date	2007.05.30.16.32.14;	author espie;	state Exp;
branches;
next	1.71;

1.71
date	2007.05.30.12.29.19;	author espie;	state Exp;
branches;
next	1.70;

1.70
date	2007.05.30.11.13.35;	author espie;	state Exp;
branches;
next	1.69;

1.69
date	2007.05.29.13.17.48;	author espie;	state Exp;
branches;
next	1.68;

1.68
date	2007.05.29.13.00.17;	author espie;	state Exp;
branches;
next	1.67;

1.67
date	2007.05.29.12.36.53;	author espie;	state Exp;
branches;
next	1.66;

1.66
date	2007.05.28.11.35.54;	author espie;	state Exp;
branches;
next	1.65;

1.65
date	2007.05.24.11.06.29;	author espie;	state Exp;
branches;
next	1.64;

1.64
date	2007.05.24.10.06.35;	author espie;	state Exp;
branches;
next	1.63;

1.63
date	2007.05.03.14.47.29;	author espie;	state Exp;
branches;
next	1.62;

1.62
date	2007.05.02.15.17.36;	author espie;	state Exp;
branches;
next	1.61;

1.61
date	2007.05.02.15.13.05;	author espie;	state Exp;
branches;
next	1.60;

1.60
date	2007.05.02.15.05.30;	author espie;	state Exp;
branches;
next	1.59;

1.59
date	2007.05.01.20.13.44;	author espie;	state Exp;
branches;
next	1.58;

1.58
date	2007.05.01.19.54.55;	author espie;	state Exp;
branches;
next	1.57;

1.57
date	2007.04.29.11.28.59;	author espie;	state Exp;
branches;
next	1.56;

1.56
date	2007.04.29.10.52.15;	author espie;	state Exp;
branches;
next	1.55;

1.55
date	2007.04.15.10.17.29;	author espie;	state Exp;
branches;
next	1.54;

1.54
date	2007.04.15.10.00.50;	author espie;	state Exp;
branches;
next	1.53;

1.53
date	2007.04.08.12.35.40;	author espie;	state Exp;
branches;
next	1.52;

1.52
date	2007.02.08.11.07.37;	author bernd;	state Exp;
branches;
next	1.51;

1.51
date	2006.11.17.15.34.15;	author espie;	state Exp;
branches;
next	1.50;

1.50
date	2005.09.19.09.51.01;	author espie;	state Exp;
branches;
next	1.49;

1.49
date	2005.09.07.10.39.25;	author espie;	state Exp;
branches;
next	1.48;

1.48
date	2005.09.04.22.47.56;	author espie;	state Exp;
branches;
next	1.47;

1.47
date	2005.08.17.10.00.19;	author espie;	state Exp;
branches;
next	1.46;

1.46
date	2005.06.26.11.23.35;	author espie;	state Exp;
branches;
next	1.45;

1.45
date	2005.06.21.19.12.31;	author espie;	state Exp;
branches;
next	1.44;

1.44
date	2004.12.16.11.19.59;	author espie;	state Exp;
branches;
next	1.43;

1.43
date	2004.12.16.11.07.33;	author espie;	state Exp;
branches;
next	1.42;

1.42
date	2004.12.15.01.07.10;	author espie;	state Exp;
branches;
next	1.41;

1.41
date	2004.11.18.21.46.07;	author espie;	state Exp;
branches;
next	1.40;

1.40
date	2004.11.15.15.06.22;	author espie;	state Exp;
branches;
next	1.39;

1.39
date	2004.11.13.13.55.03;	author espie;	state Exp;
branches;
next	1.38;

1.38
date	2004.11.13.12.49.58;	author espie;	state Exp;
branches;
next	1.37;

1.37
date	2004.11.13.11.48.46;	author espie;	state Exp;
branches;
next	1.36;

1.36
date	2004.11.13.11.39.40;	author espie;	state Exp;
branches;
next	1.35;

1.35
date	2004.11.12.23.26.41;	author espie;	state Exp;
branches;
next	1.34;

1.34
date	2004.11.11.15.32.28;	author espie;	state Exp;
branches;
next	1.33;

1.33
date	2004.11.11.11.16.40;	author espie;	state Exp;
branches;
next	1.32;

1.32
date	2004.11.10.09.55.43;	author espie;	state Exp;
branches;
next	1.31;

1.31
date	2004.11.09.10.30.26;	author espie;	state Exp;
branches;
next	1.30;

1.30
date	2004.10.26.17.25.36;	author espie;	state Exp;
branches;
next	1.29;

1.29
date	2004.10.23.11.09.22;	author espie;	state Exp;
branches;
next	1.28;

1.28
date	2004.10.11.14.25.28;	author espie;	state Exp;
branches;
next	1.27;

1.27
date	2004.10.11.14.11.42;	author espie;	state Exp;
branches;
next	1.26;

1.26
date	2004.09.24.08.49.27;	author espie;	state Exp;
branches;
next	1.25;

1.25
date	2004.09.21.22.17.49;	author espie;	state Exp;
branches;
next	1.24;

1.24
date	2004.09.18.08.14.40;	author espie;	state Exp;
branches;
next	1.23;

1.23
date	2004.09.16.07.46.00;	author espie;	state Exp;
branches;
next	1.22;

1.22
date	2004.09.14.22.28.23;	author espie;	state Exp;
branches;
next	1.21;

1.21
date	2004.08.06.10.23.45;	author espie;	state Exp;
branches;
next	1.20;

1.20
date	2004.08.06.08.06.01;	author espie;	state Exp;
branches;
next	1.19;

1.19
date	2004.08.06.07.51.17;	author espie;	state Exp;
branches;
next	1.18;

1.18
date	2004.08.05.23.39.19;	author espie;	state Exp;
branches;
next	1.17;

1.17
date	2004.08.05.23.36.40;	author espie;	state Exp;
branches;
next	1.16;

1.16
date	2004.08.03.12.33.48;	author espie;	state Exp;
branches;
next	1.15;

1.15
date	2004.08.03.12.29.45;	author espie;	state Exp;
branches;
next	1.14;

1.14
date	2004.08.02.12.12.36;	author espie;	state Exp;
branches;
next	1.13;

1.13
date	2004.07.22.23.53.53;	author espie;	state Exp;
branches;
next	1.12;

1.12
date	2004.07.20.18.58.41;	author espie;	state Exp;
branches;
next	1.11;

1.11
date	2004.07.14.10.44.03;	author espie;	state Exp;
branches;
next	1.10;

1.10
date	2004.07.13.00.35.39;	author espie;	state Exp;
branches;
next	1.9;

1.9
date	2004.07.05.09.22.40;	author espie;	state Exp;
branches;
next	1.8;

1.8
date	2004.05.19.13.05.16;	author espie;	state Exp;
branches;
next	1.7;

1.7
date	2004.04.28.06.50.21;	author espie;	state Exp;
branches;
next	1.6;

1.6
date	2004.02.23.21.47.48;	author espie;	state Exp;
branches;
next	1.5;

1.5
date	2004.01.28.22.12.01;	author espie;	state Exp;
branches;
next	1.4;

1.4
date	2003.12.26.16.44.31;	author espie;	state Exp;
branches;
next	1.3;

1.3
date	2003.11.06.17.46.35;	author espie;	state Exp;
branches;
next	1.2;

1.2
date	2003.10.19.18.42.55;	author espie;	state Exp;
branches;
next	1.1;

1.1
date	2003.10.16.17.43.34;	author espie;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2003.10.16.17.43.34;	author espie;	state Exp;
branches;
next	;


desc
@@


1.143
log
@recognize @@version, to be used for a system-wide version marker
@
text
@# ex:ts=8 sw=4:
# $OpenBSD: PackingList.pm,v 1.142 2016/10/04 14:24:45 espie Exp $
#
# Copyright (c) 2003-2014 Marc Espie <espie@@openbsd.org>
#
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

use strict;
use warnings;

package OpenBSD::PackingList::State;
my $dot = '.';

sub new
{
	my $class = shift;
	bless { default_owner=>'root',
	     default_group=>'bin',
	     default_mode=> 0444,
	     owners => {},
	     groups => {},
	     cwd=>\$dot}, $class;
}

sub cwd
{
	return ${$_[0]->{cwd}};
}

sub set_cwd
{
	my ($self, $p) = @@_;

	require File::Spec;

	$p = File::Spec->canonpath($p);
	$self->{cwd} = \$p;
}

package OpenBSD::PackingList::hashpath;
sub match
{
	my ($h, $plist) = @@_;
	my $f = $plist->fullpkgpath2;
	if (!defined $f) {
		return 0;
	}
	for my $i (@@{$h->{$f->{dir}}}) {
		if ($i->match($f)) {
			return 1;
		}
	}
	return 0;
}

sub partial_match
{
	my ($h, $subdir) = @@_;
	for my $dir (keys %$h) {
		return 1 if $dir =~ m/\b\Q$subdir\E\b/;
	}
	return 0;
}

package OpenBSD::Composite;

# convert call to $self->sub(@@args) into $self->visit(sub, @@args)
sub AUTOLOAD
{
	our $AUTOLOAD;
	my $fullsub = $AUTOLOAD;
	(my $sub = $fullsub) =~ s/.*:://o;
	return if $sub eq 'DESTROY'; # special case
	my $self = $_[0];
	# verify it makes sense
	if ($self->element_class->can($sub)) {
		no strict "refs";
		# create the sub to avoid regenerating further calls
		*$fullsub = sub {
			my $self = shift;
			$self->visit($sub, @@_);
		};
		# and jump to it
		goto &$fullsub;
	} else {
		die "Can't call $sub on ".ref($self);
	}
}

package OpenBSD::PackingList;
our @@ISA = qw(OpenBSD::Composite);

use OpenBSD::PackingElement;
use OpenBSD::PackageInfo;

sub element_class { "OpenBSD::PackingElement" }

sub new
{
	my $class = shift;
	my $plist = bless {state => OpenBSD::PackingList::State->new,
		infodir => \(my $d)}, $class;
	OpenBSD::PackingElement::File->add($plist, CONTENTS);
	return $plist;
}

sub set_infodir
{
	my ($self, $dir) = @@_;
	$dir .= '/' unless $dir =~ m/\/$/o;
	${$self->{infodir}} = $dir;
}

sub make_shallow_copy
{
	my ($plist, $h) = @@_;

	my $copy = ref($plist)->new;
	$copy->set_infodir($plist->infodir);
	$plist->copy_shallow_if($copy, $h);
	return $copy;
}

sub make_deep_copy
{
	my ($plist, $h) = @@_;

	my $copy = ref($plist)->new;
	$copy->set_infodir($plist->infodir);
	$plist->copy_deep_if($copy, $h);
	return $copy;
}

sub infodir
{
	my $self = shift;
	return ${$self->{infodir}};
}

sub zap_wrong_annotations
{
	my $self = shift;
	my $pkgname = $self->pkgname;
	if (defined $pkgname && $pkgname =~ m/^(?:\.libs\d*|partial)\-/) {
		delete $self->{'manual-installation'};
		delete $self->{'firmware'};
		delete $self->{'digital-signature'};
	}
}

sub conflict_list
{
	require OpenBSD::PkgCfl;

	my $self = shift;
	return OpenBSD::PkgCfl->make_conflict_list($self);
}

my $subclass;

sub read
{
	my ($a, $u, $code) = @@_;
	my $plist;
	$code = \&defaultCode if !defined $code;
	if (ref $a) {
		$plist = $a;
	} else {
		$plist = new $a;
	}
	if (defined $subclass->{$code}) {
		bless $plist, "OpenBSD::PackingList::".$subclass->{$code};
	}
	&$code($u,
		sub {
			my $line = shift;
			return if $line =~ m/^\s*$/o;
			OpenBSD::PackingElement->create($line, $plist);
		});
	$plist->zap_wrong_annotations;
	return $plist;
}

sub defaultCode
{
	my ($fh, $cont) = @@_;
	while (<$fh>) {
		&$cont($_);
	}
}

sub SharedItemsOnly
{
	my ($fh, $cont) = @@_;
	while (<$fh>) {
		next unless m/^\@@(?:cwd|dir|fontdir|ghost|mandir|newuser|newgroup|name)\b/o || m/^\@@(?:sample|extra)\b.*\/$/o || m/^[^\@@].*\/$/o;
		&$cont($_);
	}
}

sub DirrmOnly
{
	&OpenBSD::PackingList::SharedItemsOnly;
}

sub LibraryOnly
{
	my ($fh, $cont) = @@_;
	while (<$fh>) {
		next unless m/^\@@(?:cwd|lib|name|comment\s+subdir\=)\b/o;
		&$cont($_);
	}
}

sub FilesOnly
{
	my ($fh, $cont) = @@_;
	while (<$fh>) {
	    	next unless m/^\@@(?:cwd|name|info|man|file|lib|shell|sample|bin|rcscript)\b/o || !m/^\@@/o;
		&$cont($_);
	}
}

sub PrelinkStuffOnly
{
	my ($fh, $cont) = @@_;
	while (<$fh>) {
		next unless m/^\@@(?:cwd|bin|lib|name|depend|wantlib|comment\s+ubdir\=)\b/o;
		&$cont($_);
	}
}

sub DependOnly
{
	my ($fh, $cont) = @@_;
	while (<$fh>) {
		if (m/^\@@(?:depend|wantlib|define-tag)\b/o) {
			&$cont($_);
		# XXX optimization
		} elsif (m/^\@@(?:newgroup|newuser|cwd)\b/o) {
			last;
		}
	}
}

sub ExtraInfoOnly
{
	my ($fh, $cont) = @@_;
	while (<$fh>) {
		if (m/^\@@(?:name|pkgpath|comment\s+(?:subdir|pkgpath)\=|option)\b/o) {
			&$cont($_);
		# XXX optimization
		} elsif (m/^\@@(?:depend|wantlib|newgroup|newuser|cwd)\b/o) {
			last;
		}
	}
}

sub UpdateInfoOnly
{
	my ($fh, $cont) = @@_;
	while (<$fh>) {
		# if alwaysupdate, all info is sig
		if (m/^\@@option\s+always-update\b/o) {
		    &$cont($_);
		    while (<$fh>) {
			    &$cont($_);
		    }
		    return;
		}
		if (m/^\@@(?:name|depend|wantlib|conflict|option|pkgpath|url|version|arch|comment\s+(?:subdir|pkgpath)\=)\b/o) {
			&$cont($_);
		# XXX optimization
		} elsif (m/^\@@(?:newgroup|newuser|cwd)\b/o) {
			last;
		}
	}
}

sub ConflictOnly
{
	my ($fh, $cont) = @@_;
	while (<$fh>) {
		if (m/^\@@(?:name|conflict|option)\b/o) {
			&$cont($_);
		# XXX optimization
		} elsif (m/^\@@(?:depend|wantlib|newgroup|newuser|cwd)\b/o) {
			last;
		}
	}
}

sub fromfile
{
	my ($a, $fname, $code) = @@_;
	open(my $fh, '<', $fname) or return;
	my $plist;
	eval {
		$plist = $a->read($fh, $code);
	};
	if ($@@) {
		chomp $@@;
		$@@ =~ s/\.$/,/o;
		die "$@@ in $fname, ";
	}
	close($fh);
	return $plist;
}

sub tofile
{
	my ($self, $fname) = @@_;
	open(my $fh, '>', $fname) or return;
	$self->zap_wrong_annotations;
	$self->write($fh);
	close($fh) or return;
	return 1;
}

sub save
{
	my $self = shift;
	$self->tofile($self->infodir.CONTENTS);
}

sub add2list
{
	my ($plist, $object) = @@_;
	my $category = $object->category;
	push @@{$plist->{$category}}, $object;
}

sub addunique
{
	my ($plist, $object) = @@_;
	my $category = $object->category;
	if (defined $plist->{$category}) {
		die "Duplicate $category in plist ".($plist->pkgname // "?");
	}
	$plist->{$category} = $object;
}

sub has
{
	my ($plist, $name) = @@_;
	return defined $plist->{$name};
}

sub get
{
	my ($plist, $name) = @@_;
	return $plist->{$name};
}

sub set_pkgname
{
	my ($self, $name) = @@_;
	if (defined $self->{name}) {
		$self->{name}->set_name($name);
	} else {
		OpenBSD::PackingElement::Name->add($self, $name);
	}
}

sub pkgname
{
	my $self = shift;
	if (defined $self->{name}) {
		return $self->{name}->name;
	} else {
		return undef;
	}
}

sub localbase
{
	my $self = shift;

	if (defined $self->{localbase}) {
		return $self->{localbase}->name;
	} else {
		return '/usr/local';
	}
}

sub is_signed
{
	my $self = shift;
	return defined $self->{'digital-signature'};
}

sub fullpkgpath
{
	my $self = shift;
	if (defined $self->{extrainfo} && $self->{extrainfo}{subdir} ne '') {
		return $self->{extrainfo}{subdir};
	} else {
		return undef;
	}
}

sub fullpkgpath2
{
	my $self = shift;
	if (defined $self->{extrainfo} && $self->{extrainfo}{subdir} ne '') {
		return $self->{extrainfo}{path};
	} else {
		return undef;
	}
}

sub pkgpath
{
	my $self = shift;
	if (!defined $self->{_hashpath}) {
		my $h = $self->{_hashpath} =
		    bless {}, "OpenBSD::PackingList::hashpath";
		my $f = $self->fullpkgpath2;
		if (defined $f) {
			push(@@{$h->{$f->{dir}}}, $f);
		}
		if (defined $self->{pkgpath}) {
			for my $i (@@{$self->{pkgpath}}) {
				push(@@{$h->{$i->{path}{dir}}}, $i->{path});
			}
		}
	}
	return $self->{_hashpath};
}

sub match_pkgpath
{
	my ($self, $plist2) = @@_;
	return $self->pkgpath->match($plist2) ||
	    $plist2->pkgpath->match($self);
}

our @@unique_categories =
    (qw(name url version signer digital-signature no-default-conflict manual-installation firmware always-update is-branch extrainfo localbase arch));

our @@list_categories =
    (qw(conflict pkgpath ask-update depend
    	wantlib define-tag groups users items));

our @@cache_categories =
    (qw(depend wantlib));

sub visit
{
	my ($self, $method, @@l) = @@_;

	if (defined $self->{cvstags}) {
		for my $item (@@{$self->{cvstags}}) {
			$item->$method(@@l) unless $item->{deleted};
		}
	}

	# XXX unique and info files really get deleted, so there's no need
	# to remove them later.
	for my $unique_item (@@unique_categories) {
		$self->{$unique_item}->$method(@@l) 
		    if defined $self->{$unique_item};
	}

	for my $special (OpenBSD::PackageInfo::info_names()) {
		$self->{$special}->$method(@@l) if defined $self->{$special};
	}

	for my $listname (@@list_categories) {
		if (defined $self->{$listname}) {
			for my $item (@@{$self->{$listname}}) {
				$item->$method(@@l) if !$item->{deleted};
			}
		}
	}
}

my $plist_cache = {};

sub from_installation
{
	my ($o, $pkgname, $code) = @@_;

	require OpenBSD::PackageInfo;

	$code //= \&defaultCode;

	if ($code == \&DependOnly && defined $plist_cache->{$pkgname}) {
	    return $plist_cache->{$pkgname};
	}
	my $filename = OpenBSD::PackageInfo::installed_contents($pkgname);
	my $plist = $o->fromfile($filename, $code);
	if (defined $plist && $code == \&DependOnly) {
		$plist_cache->{$pkgname} = $plist;
	}
	if (defined $plist) {
		$plist->set_infodir(OpenBSD::PackageInfo::installed_info($pkgname));
	}
	if (!defined $plist) {
		print STDERR "Warning: couldn't read packing-list from installed package $pkgname\n";
		unless (-e $filename) {
			print STDERR "File $filename does not exist\n";
		}
	}
	return $plist;
}

sub to_cache
{
	my ($self) = @@_;
	return if defined $plist_cache->{$self->pkgname};
	my $plist = OpenBSD::PackingList::Depend->new;
	for my $c (@@cache_categories) {
		if (defined $self->{$c}) {
			$plist->{$c} = $self->{$c};
		}
	}
	$plist_cache->{$self->pkgname} = $plist;
}

sub to_installation
{
	my ($self) = @@_;

	require OpenBSD::PackageInfo;

	return if $main::not;

	$self->tofile(OpenBSD::PackageInfo::installed_contents($self->pkgname));
}

sub forget
{
}

sub signature
{
	my $self = shift;

	require OpenBSD::Signature;
	return OpenBSD::Signature->from_plist($self);
}

$subclass =  {
	\&defaultCode => 'Full',
	\&SharedItemsOnly => 'SharedItems',
	\&DirrmOnly => 'SharedItems',
	\&LibraryOnly => 'Libraries',
	\&FilesOnly => 'Files',
	\&PrelinkStuffOnly => 'Prelink',
	\&DependOnly => 'Depend',
	\&ExtraInfoOnly => 'ExtraInfo',
	\&UpdateInfoOnly => 'UpdateInfo',
	\&ConflictOnly => 'Conflict' };

package OpenBSD::PackingList::OldLibs;
our @@ISA = qw(OpenBSD::PackingList);
package OpenBSD::PackingList::Full;
our @@ISA = qw(OpenBSD::PackingList::OldLibs);
package OpenBSD::PackingList::SharedItems;
our @@ISA = qw(OpenBSD::PackingList);
package OpenBSD::PackingList::Libraries;
our @@ISA = qw(OpenBSD::PackingList);
package OpenBSD::PackingList::Files;
our @@ISA = qw(OpenBSD::PackingList);
package OpenBSD::PackingList::Prelink;
our @@ISA = qw(OpenBSD::PackingList);
package OpenBSD::PackingList::Depend;
our @@ISA = qw(OpenBSD::PackingList);
package OpenBSD::PackingList::ExtraInfo;
our @@ISA = qw(OpenBSD::PackingList);
package OpenBSD::PackingList::UpdateInfo;
our @@ISA = qw(OpenBSD::PackingList);
package OpenBSD::PackingList::Conflict;
our @@ISA = qw(OpenBSD::PackingList);

1;
@


1.142
log
@check_signature is gone
@
text
@d2 1
a2 1
# $OpenBSD: PackingList.pm,v 1.141 2016/09/27 21:31:20 naddy Exp $
d281 1
a281 1
		if (m/^\@@(?:name|depend|wantlib|conflict|option|pkgpath|url|arch|comment\s+(?:subdir|pkgpath)\=)\b/o) {
d449 1
a449 1
    (qw(name url signer digital-signature no-default-conflict manual-installation firmware always-update is-branch extrainfo localbase arch));
@


1.141
log
@switch to using the new package signature scheme (signify2) by default
ok sthen@@
@
text
@d2 1
a2 1
# $OpenBSD: PackingList.pm,v 1.140 2016/09/08 09:51:15 espie Exp $
a539 18
}

sub check_signature
{
	my ($plist, $state) = @@_;
	my $sig = $plist->get('digital-signature');
	if ($sig->{key} eq 'x509') {
		require OpenBSD::x509;
		return OpenBSD::x509::check_signature($plist, $state);
	} elsif ($sig->{key} eq 'signify' && $state->defines('oldsign')) {
		require OpenBSD::signify;
		return OpenBSD::signify::check_signature($plist, $state);
	} elsif ($sig->{key} eq 'signify2') {
		return 1;
	} else {
		$state->log("Error: unknown signature style $sig->{key}");
		return 0;
	}
@


1.140
log
@new sign only when new sign
@
text
@d2 1
a2 1
# $OpenBSD: PackingList.pm,v 1.139 2016/09/04 12:08:49 espie Exp $
d549 1
a549 1
	} elsif ($sig->{key} eq 'signify') {
d552 1
a552 1
	} elsif ($sig->{key} eq 'signify2' && $state->defines('newsign')) {
@


1.139
log
@basic scaffolding to ask signify to check stuff
still missing some proper error reporting
@
text
@d2 1
a2 1
# $OpenBSD: PackingList.pm,v 1.138 2016/07/27 13:02:03 espie Exp $
d552 1
a552 1
	} elsif ($sig->{key} eq 'signify2') {
@


1.138
log
@checking for firmware works better if I pass thru all options
@
text
@d2 1
a2 1
# $OpenBSD: PackingList.pm,v 1.137 2016/06/25 18:02:59 espie Exp $
d552 2
@


1.137
log
@recognize @@option is-branch
so that it trickles to snapshots and then can be used in ports
@
text
@d2 1
a2 1
# $OpenBSD: PackingList.pm,v 1.136 2016/06/14 15:41:31 espie Exp $
d260 1
a260 1
		if (m/^\@@(?:name|pkgpath|comment\s+(?:subdir|pkgpath)\=|option\s+is-branch)\b/o) {
@


1.136
log
@new syntax: pkgname%branch   to select a branch wherever it makes sense.
see pkg_add(1) for details.

Search framework makes that surprisingly simple.
@
text
@d2 1
a2 1
# $OpenBSD: PackingList.pm,v 1.135 2014/10/13 12:44:16 espie Exp $
d260 1
a260 1
		if (m/^\@@(?:name|pkgpath|comment\s+(?:subdir|pkgpath)\=)\b/o) {
d449 1
a449 1
    (qw(name url signer digital-signature no-default-conflict manual-installation firmware always-update extrainfo localbase arch));
@


1.135
log
@scaffolding for future new features, committed early, so that pkg_sign
will grok it when it happens
@
text
@d2 1
a2 1
# $OpenBSD: PackingList.pm,v 1.134 2014/09/09 09:40:23 espie Exp $
d62 9
@


1.134
log
@register @@newuser/@@newgroup so that we try creating tarballs with the correct
users (which doesn't really matter all that much, as the owner/group in
the plist are what matters)

Otherwise, if we're not root, dismiss user id and groups, replace
with root/bin (significant fix from previous version: this interprets $(
correctly).  Should help with FAKE_AS_ROOT=No
@
text
@d2 1
a2 1
# $OpenBSD: PackingList.pm,v 1.133 2014/03/18 18:53:29 espie Exp $
d197 1
a197 1
		next unless m/^\@@(?:cwd|dir|fontdir|mandir|newuser|newgroup|name)\b/o || m/^\@@(?:sample|extra)\b.*\/$/o || m/^[^\@@].*\/$/o;
@


1.133
log
@remove $_ usage that warns under perl 5.18
@
text
@d2 1
a2 1
# $OpenBSD: PackingList.pm,v 1.132 2014/02/08 15:07:12 espie Exp $
d30 2
@


1.132
log
@style
@
text
@d2 1
a2 1
# $OpenBSD: PackingList.pm,v 1.131 2014/02/04 18:11:36 espie Exp $
a185 1
	my $_;
a193 1
	my $_;
a207 1
	my $_;
a216 1
	my $_;
a225 1
	my $_;
a234 1
	my $_;
a247 1
	my $_;
a260 1
	my $_;
a281 1
	my $_;
@


1.131
log
@no functional change (for now). Make things more debuggable by subclassing
PackingList into types that describe what info they've been limited to.

Long term (post 5.5) some operations will be restricted, such as e.g.,
only committing lists to installation if they're "full", or only checking
signatures for same.
@
text
@d2 1
a2 1
# $OpenBSD: PackingList.pm,v 1.130 2014/02/01 11:03:50 espie Exp $
d403 2
a404 2
	if (defined $self->{extrainfo} && $self->{extrainfo}->{subdir} ne '') {
		return $self->{extrainfo}->{subdir};
d413 2
a414 2
	if (defined $self->{extrainfo} && $self->{extrainfo}->{subdir} ne '') {
		return $self->{extrainfo}->{path};
d432 1
a432 1
				push(@@{$h->{$i->{path}->{dir}}}, $i->{path});
@


1.130
log
@don't bother caching, it's no longer useful
@
text
@d2 1
a2 1
# $OpenBSD: PackingList.pm,v 1.129 2014/01/11 11:51:01 espie Exp $
d66 1
d117 1
a117 1
	my $copy = OpenBSD::PackingList->new;
d127 1
a127 1
	my $copy = OpenBSD::PackingList->new;
d158 2
d170 3
d520 1
a520 1
	my $plist = new OpenBSD::PackingList;
a559 2
# convert call to $self->sub(@@args) into $self->visit(sub, @@args)

d567 33
@


1.129
log
@a bit of spring cleanup in advance: scrape old stuff that's not really
used.
@
text
@d2 1
a2 1
# $OpenBSD: PackingList.pm,v 1.128 2014/01/09 20:20:01 espie Exp $
d154 1
a154 3

	$self->{conflict_list} //= OpenBSD::PkgCfl->make_conflict_list($self);
	return $self->{conflict_list};
@


1.128
log
@bump copyright to 2014
@
text
@d2 1
a2 1
# $OpenBSD: PackingList.pm,v 1.127 2014/01/07 01:38:58 espie Exp $
d443 1
a443 1
    (qw(name url signer digital-signature no-default-conflict manual-installation firmware always-update explicit-update extrainfo localbase arch));
d446 1
a446 1
    (qw(conflict pkgpath incompatibility ask-update updateset depend
@


1.127
log
@more stuff than cannot end in .libs nor partial- packages
@
text
@d2 1
a2 1
# $OpenBSD: PackingList.pm,v 1.126 2014/01/04 14:14:55 espie Exp $
d4 1
a4 1
# Copyright (c) 2003-2010 Marc Espie <espie@@openbsd.org>
@


1.126
log
@recognize @@option firmware
@
text
@d2 1
a2 1
# $OpenBSD: PackingList.pm,v 1.125 2014/01/04 00:14:08 espie Exp $
d144 2
@


1.125
log
@vendor->signer
shorten pubkey -> pub (naddy@@)
\\ -> \e (jmc@@)
@
text
@d2 1
a2 1
# $OpenBSD: PackingList.pm,v 1.124 2013/12/31 11:21:10 espie Exp $
d441 1
a441 1
    (qw(name url signer digital-signature no-default-conflict manual-installation always-update explicit-update extrainfo localbase arch));
@


1.124
log
@signify support
@
text
@d2 1
a2 1
# $OpenBSD: PackingList.pm,v 1.123 2013/12/30 09:14:49 espie Exp $
d441 1
a441 1
    (qw(name url vendor digital-signature no-default-conflict manual-installation always-update explicit-update extrainfo localbase arch));
@


1.123
log
@@@vendor annotation
@
text
@d2 1
a2 1
# $OpenBSD: PackingList.pm,v 1.122 2013/12/25 14:38:15 espie Exp $
d541 3
@


1.122
log
@move the choice of signature type for checking into one single place
@
text
@d2 1
a2 1
# $OpenBSD: PackingList.pm,v 1.121 2012/12/28 15:09:09 espie Exp $
d441 1
a441 1
    (qw(name url digital-signature no-default-conflict manual-installation always-update explicit-update extrainfo localbase arch));
@


1.121
log
@base on landry's remarks, stuff like .libs* and partial* shouldn't ever
have manual annotation markers.

(the read part is there for legacy, as some stuff is already written
back that way. Eventually, no .libs* will have @@option manual-install
left).
@
text
@d2 1
a2 1
# $OpenBSD: PackingList.pm,v 1.120 2012/06/08 15:01:00 espie Exp $
d534 12
@


1.120
log
@silent rename of @@comment subdir= to @@comment pkgpath=
this makes more sense
@
text
@d2 1
a2 1
# $OpenBSD: PackingList.pm,v 1.119 2012/05/15 08:14:29 espie Exp $
d138 9
d173 1
d316 1
@


1.119
log
@allow elements to remove themselves from PackingList, adjust visit
accordingly.

Make sure obsolete stuff ->add returns undef, unconfuses PkgCreate.
@
text
@d2 1
a2 1
# $OpenBSD: PackingList.pm,v 1.118 2012/05/05 10:20:58 espie Exp $
d240 1
a240 1
		if (m/^\@@(?:name|pkgpath|comment\s+subdir\=)\b/o) {
d262 1
a262 1
		if (m/^\@@(?:name|depend|wantlib|conflict|option|pkgpath|url|arch|comment\s+subdir\=)\b/o) {
@


1.118
log
@un-specialcase shallow/deep copy: create a normal new plist.
(so don't copy FCONTENTS since it's automatically created)
@
text
@d2 1
a2 1
# $OpenBSD: PackingList.pm,v 1.117 2011/08/27 08:57:39 espie Exp $
d445 1
a445 1
			$item->$method(@@l);
d449 2
d452 2
a453 1
		$self->{$unique_item}->$method(@@l) if defined $self->{$unique_item};
d463 1
a463 1
				$item->$method(@@l);
@


1.117
log
@the order of packinglists has been fixed for years by now, so it's no
longer necessary to look for @@arch for "new" packing-lists. Optimize a
bit more for @@pkgpath since @@wantlib/@@depend mean it's over.
@
text
@d2 1
a2 1
# $OpenBSD$
d116 2
a117 2
	my $copy = bless {state => OpenBSD::PackingList::State->new,
		infodir => \(my $d = ${$plist->{infodir}})}, ref($plist);
d126 2
a127 2
	my $copy = bless {state => OpenBSD::PackingList::State->new,
		infodir => \(my $d = ${$plist->{infodir}})}, ref($plist);
@


1.116
log
@Shared Stuff never got used
@
text
@d2 1
a2 1
# $OpenBSD: PackingList.pm,v 1.115 2011/08/26 08:46:10 espie Exp $
d196 1
a196 2
		next unless m/^\@@(?:cwd|lib|name)\b/o ||
			m/^\@@comment\s+subdir\=/o;
d216 1
a216 2
		next unless m/^\@@(?:cwd|bin|lib|name|depend|wantlib)\b/o ||
			m/^\@@comment\s+subdir\=/o;
d226 2
d229 2
a230 9
		if (m/^\@@arch\b/o) {
			while (<$fh>) {
			    if (m/^\@@(?:depend|wantlib|define-tag)\b/o) {
				    &$cont($_);
			    } elsif (m/^\@@(?:newgroup|newuser|cwd)\b/o) {
				    last;
			    }
			}
			return;
a231 2
		next unless m/^\@@(?:depend|wantlib|define-tag)\b/o;
		&$cont($_);
d240 2
d243 2
a244 9
		if (m/^\@@arch\b/o) {
			while (<$fh>) {
			    if (m/^\@@(?:pkgpath)\b/o) {
				    &$cont($_);
			    } elsif (m/^\@@(?:newgroup|newuser|cwd)\b/o) {
				    last;
			    }
			}
			return;
a245 2
		next unless m/^\@@(?:name\b|comment\s+subdir\=)/o;
		&$cont($_);
a253 11
		# XXX optimization
		if (m/^\@@arch\b/o) {
			while (<$fh>) {
			    if (m/^\@@(?:depend|wantlib|conflict|option|pkgpath|url)\b/o) {
				    &$cont($_);
			    } elsif (m/^\@@(?:newgroup|newuser|cwd)\b/o) {
				    last;
			    }
			}
			return;
		}
d262 6
a267 2
		next unless m/^\@@(?:name\b|depend\b|wantlib\b|conflict|\b|option\b|pkgpath\b|comment\s+subdir\=|arch\b|url\b)/o;
		&$cont($_);
d276 2
d279 2
a280 9
		if (m/^\@@arch\b/o) {
			while (<$fh>) {
			    if (m/^\@@(?:conflict|option|name)\b/o) {
				    &$cont($_);
			    } elsif (m/^\@@(?:depend|wantlib|newgroup|newuser|cwd)\b/o) {
				    last;
			    }
			}
			return;
a281 2
	    	next unless m/^\@@(?:conflict|option|name)\b/o;
		&$cont($_);
@


1.115
log
@zap fatpackages. nobody actually uses them.
accordingly, locations do not need to track architecture.
@
text
@d2 1
a2 1
# $OpenBSD: PackingList.pm,v 1.114 2011/06/16 14:48:36 espie Exp $
a310 21
		&$cont($_);
	}
}

sub SharedStuffOnly
{
	my ($fh, $cont) = @@_;
	my $_;
MAINLOOP:
	while (<$fh>) {
		if (m/^\@@shared\b/o) {
			&$cont($_);
			while(<$fh>) {
				redo MAINLOOP unless m/^\@@(?:sha|md5|size|symlink|link)\b/o;
				    m/^\@@size\b/o || m/^\@@symlink\b/o ||
				    m/^\@@link\b/o;
				&$cont($_);
			}
		} else {
			next unless m/^\@@(?:cwd|name)\b/o;
		}
@


1.114
log
@remove redundant values
@
text
@d2 1
a2 1
# $OpenBSD: PackingList.pm,v 1.113 2011/06/01 11:20:04 espie Exp $
a289 15
		&$cont($_);
	}
}

sub FatOnly
{
	my ($fh, $cont) = @@_;
	my $_;
	while (<$fh>) {
		# XXX optimization
		if (m/^\@@arch\b/o) {
			&$cont($_);
			return;
		}
		next unless m/^\@@(?:name\b)/o;
@


1.113
log
@repaire pkg_info -P in the simplest possible way, pending revisit.
(problem noticed by Nigel Taylor)
@
text
@d2 1
a2 1
# $OpenBSD: PackingList.pm,v 1.112 2011/05/30 09:59:38 espie Exp $
d56 1
a56 1
	for my $i (values @@{$h->{$f->{dir}}}) {
@


1.112
log
@turn @@pkgpath into real objects, to simplify some updates by not having to
figure out what matches precisely.

approved by dcoppa@@. okay sthen@@, landry@@
@
text
@d2 1
a2 1
# $OpenBSD: PackingList.pm,v 1.111 2010/12/24 09:04:14 espie Exp $
d52 1
a52 1
	my $f = $plist->fullpkgpath;
d453 10
d468 1
d475 1
a475 1
		my $f = $self->fullpkgpath;
@


1.111
log
@handle failures from ports tree with more care.
this does avoid infinite loops in case of wrong plists.
necessary since print-plist-with-depends CAN fail...
@
text
@d2 1
a2 1
# $OpenBSD$
d52 10
a61 3
	return
	    defined $plist->fullpkgpath &&
	    $h->{$plist->fullpkgpath};
d453 1
a453 1
		return $self->{extrainfo}->{subdir};
d464 3
a466 2
		if (defined $self->fullpkgpath) {
			$h->{$self->fullpkgpath} = 1;
d470 1
a470 1
				$h->{$i->name} = 1;
@


1.110
log
@initial scaffolding for @@rcscript: for now, acts like normal files,
but allow absolute pathnames (treat that as an implicit @@cwd).
@
text
@@


1.109
log
@very old thinko, not really a problem, obviously, but groups and users are
categories, the corresponding keywords are newgroup and newuser.
@
text
@d2 1
a2 1
# $OpenBSD: PackingList.pm,v 1.108 2010/06/30 10:51:04 espie Exp $
d200 1
a200 1
	    	next unless m/^\@@(?:cwd|name|info|man|file|lib|shell|sample|bin)\b/o || !m/^\@@/o;
@


1.108
log
@allow say and errsay to work without parameters, as it's ways common.
create verbose_system up in state, because it makes sense without verbose.
@
text
@d2 1
a2 1
# $OpenBSD$
d226 1
a226 1
			    } elsif (m/^\@@(?:groups|users|cwd)\b/o) {
d247 1
a247 1
			    } elsif (m/^\@@(?:groups|users|cwd)\b/o) {
d268 1
a268 1
			    } elsif (m/^\@@(?:groups|users|cwd)\b/o) {
d312 1
a312 1
			    } elsif (m/^\@@(?:depend|wantlib|groups|users|cwd)\b/o) {
@


1.107
log
@whitespace cleanup
@
text
@@


1.106
log
@modern syntax
@
text
@d2 1
a2 1
# $OpenBSD: PackingList.pm,v 1.105 2010/05/10 09:17:55 espie Exp $
@


1.105
log
@whitespace fixes
@
text
@d2 1
a2 1
# $OpenBSD$
d521 1
a521 1
	$code = \&defaultCode if !defined $code;
@


1.104
log
@move Composite pattern (auto-visitor) into its own subclass
@
text
@d27 2
a28 2
	bless { default_owner=>'root', 
	     default_group=>'bin', 
d53 1
a53 1
	    defined $plist->fullpkgpath && 
d136 1
a136 1
	
d333 1
a333 1
				    m/^\@@size\b/o || m/^\@@symlink\b/o || 
d455 1
a455 1
		my $h = $self->{_hashpath} = 
d472 1
a472 1
	return $self->pkgpath->match($plist2) || 
d480 1
a480 1
    (qw(conflict pkgpath incompatibility ask-update updateset depend 
d485 1
a485 1
	
d530 1
a530 1
	} 
@


1.103
log
@new keyword, @@ask-update, to be used *very* sparingly (so far, only useful
for pgsql updates)
@
text
@d57 24
d82 1
d87 2
a572 21

sub AUTOLOAD 
{
	our $AUTOLOAD;
	my $fullsub = $AUTOLOAD;
	(my $sub = $fullsub) =~ s/.*:://o;
	return if $sub eq 'DESTROY'; # special case
	# verify it makes sense
	if (OpenBSD::PackingElement->can($sub)) {
		no strict "refs";
		# create the sub to avoid regenerating further calls
		*$fullsub = sub {
			my $self = shift;
			$self->visit($sub, @@_);
		};
		# and jump to it
		goto &$fullsub;
	} else {
		die "Can't call $sub on ", __PACKAGE__;
	}
}
@


1.102
log
@clean up the ProgressMeter code, create a specific class if a Term
is around.
start using stuff from termcap, specifically, cleareol, and move to hp.
use the full line when we can, cram 100% if we can.
(this should flicker much less on slow terminals).

clean-up the install-and-progress bits to be in progressmeter, this removes
some code.

have pkg_create follow the same pattern as the others, with a state.
This allows us to unify error messages a bit.
@
text
@d453 1
a453 1
    (qw(conflict pkgpath incompatibility updateset depend 
@


1.101
log
@pull the signature comparison code into its own file.
add comparison functions to Packagenames that return undef when it matters.
@
text
@d361 1
a361 1
		die "Duplicate $category in plist";
@


1.100
log
@build signature objects that we will be able to compare
@
text
@a570 20
	if ($self->has('always-update')) {
		my $s;
		open my $fh, '>', \$s;
		$self->write_no_sig($fh);
		close $fh;
		return OpenBSD::PackingList::FullSignature->new($self->pkgname,
		    $s);
	} else {
		my $k = {};
		$self->visit('signature', $k);
		return OpenBSD::PackingList::Signature->new($self->pkgname, $k);
	}
}

package OpenBSD::PackingList::Signature;
sub new
{
	my ($class, $pkgname, $extra) = @@_;
	bless { name => $pkgname, extra => $extra }, $class;
}
d572 2
a573 4
sub string
{
	my $self = shift;
	return join(',', $self->{name}, sort map {$_->to_string} values %{$self->{extra}});
a575 27
sub compare
{
	my ($a, $b) = @@_;
	return $a->string cmp $b->string;
}

package OpenBSD::PackingList::FullSignature;
our @@ISA=qw(OpenBSD::PackingList::Signature);

sub string
{
	my $self = shift;
	return $self->{extra};
}

package OpenBSD::LibrarySpec;
sub new
{
	my ($class, $stem, $major, $minor) = @@_;
	bless {stem => $stem, major => $major, minor => $minor}, $class;
}

sub to_string
{
	my $self = shift;
	return join('.', $self->{stem}, $self->{major}, $self->{minor});
}
@


1.99
log
@first step in comparing full signatures: make them full objects, with
proper sign/compare interfaces.
@
text
@d581 1
a581 3
		my $o = [$self->pkgname, sort keys %$k];
		return OpenBSD::PackingList::Signature->new($self->pkgname,
		    [sort keys %$k]);
d595 1
a595 1
	return join(',', $self->{name}, @@{$self->{extra}});
d613 12
@


1.98
log
@new method fullpkgpath that accesses the default fullpkgpath.
make use of it, relax pkg_create to allow any of
FULLPKGPATH, PERMIT_PACKAGE_FTP, PERMIT_PACKAGE_CDROM
(store the others as empty).
remove warning in pkg_mklocatedb for newer perl.
@
text
@a540 16
sub signature
{
	my $self = shift;
	if ($self->has('always-update')) {
		my $s;
		open my $fh, '>', \$s;
		$self->write_no_sig($fh);
		close $fh;
		return $s;
	} else {
		my $k = {};
		$self->visit('signature', $k);
		return join(',', $self->pkgname, sort keys %$k);
	}
}

d566 47
@


1.97
log
@new option 'explicit-update', for firmwares (don't consider these in bulk
updates, only when user asks for them explicitly)
@
text
@d53 2
a54 2
	    defined $plist->{extrainfo} && 
	    $h->{$plist->{extrainfo}->{subdir}};
d415 9
d430 2
a431 2
		if (defined $self->{extrainfo}) {
			$h->{$self->{extrainfo}->{subdir}} = 1;
@


1.96
log
@infrastructure for url elements
@
text
@d4 1
a4 1
# Copyright (c) 2003-2007 Marc Espie <espie@@openbsd.org>
d441 1
a441 1
    (qw(name url digital-signature no-default-conflict manual-installation always-update extrainfo localbase arch));
@


1.95
log
@protect against partial-* packing-lists
@
text
@d239 1
a239 1
			    if (m/^\@@(?:depend|wantlib|conflict|option|pkgpath)\b/o) {
d255 1
a255 1
		next unless m/^\@@(?:name\b|depend\b|wantlib\b|conflict|\b|option\b|pkgpath\b|comment\s+subdir\=|arch\b)/o;
d441 1
a441 1
    (qw(name digital-signature no-default-conflict manual-installation always-update extrainfo localbase arch));
@


1.94
log
@update will ask about conflicts, so we need that in updateinfo...
@
text
@d52 3
a54 1
	return $h->{$plist->{extrainfo}->{subdir}};
@


1.93
log
@tie conflict lists to packing lists and use them
@
text
@d237 1
a237 1
			    if (m/^\@@(?:depend|wantlib|pkgpath)\b/o) {
d253 1
a253 1
		next unless m/^\@@(?:name\b|depend\b|wantlib\b|pkgpath\b|comment\s+subdir\=|arch\b)/o;
@


1.92
log
@missing return (nothing else to see)
@
text
@d102 10
@


1.91
log
@add @@option always-update.
a package tagged as 'always-update' will have its full packing-list, complete
with checksums, as signatures, so it will always get updated, even when the
version number doesn't change, as long as it's not the same package.
@
text
@d241 1
@


1.90
log
@allow pkg_mklocatedb -p to work again; from espie@@
@
text
@d2 1
a2 1
# $OpenBSD: PackingList.pm,v 1.89 2009/06/25 07:41:04 espie Exp $
d235 7
d428 1
a428 1
    (qw(name digital-signature no-default-conflict manual-installation extrainfo localbase arch));
d522 11
a532 3
	my $k = {};
	$self->visit('signature', $k);
	return join(',', $self->pkgname, sort keys %$k);
@


1.89
log
@pkgpath are only used for updates, so matching should only be pkgpath vs
default info, and not maximal matching, otherwise too many things will
match.

problem noticed by marco@@

With input from sthen@@ and tests from kili@@
@
text
@d2 1
a2 1
# $OpenBSD$
d371 5
a375 1
	return $self->{name}->name;
@


1.88
log
@synch with my new style search/location changes
It's likely there will be some fallout, but it's getting a bit too large
to keep around.
This does kill a few very old oddities as well.
@
text
@d51 2
a52 7
	my ($a, $b) = @@_;
	for my $i (keys %$a) {
		if ($b->{$i}) {
			return 1;
		} 
	}
	return 0;
d412 2
a413 1
	return $self->pkgpath->match($plist2->pkgpath);
@


1.87
log
@initial implementation of package signatures, based on x509 certificates and
smime detached signatures.
@
text
@d48 12
d367 1
a367 1
		$self->{name}->{name} = $name;
d376 1
a376 1
	return $self->{name}->{name};
d384 1
a384 1
		return $self->{localbase}->{name};
d394 24
@


1.86
log
@more stuff to check digests during extraction, if wanted.
Fix read/write of digitalsignature stuff.
don't integrate manual-installs, since it's highly variable.
create correct category for digitalsignature, so it gets written out.
@
text
@d380 2
a381 1
	return 0;
@


1.85
log
@Say goodbye to local $_
lexical scoping is so much neater (courtesy of perl 5.10)
@
text
@d384 1
a384 1
    (qw(name no-default-conflict manual-installation extrainfo localbase arch));
@


1.84
log
@turn the checksums stored in packing elements into real objects, so that
pkg_add becomes mostly independent of the type of checksum stored.

separate md5 into an abstract OpenBSD::digest class and an md5 subclass
with specific methods to compute checksums and serialize results, and create
an sha class that does the same thing with sha256 (with a base64 serializer)
@
text
@d117 1
a117 1
	local $_;
d126 1
a126 1
	local $_;
d141 1
a141 1
	local $_;
d152 1
a152 1
	local $_;
d162 1
a162 1
	local $_;
d173 1
a173 1
	local $_;
d194 1
a194 1
	local $_;
d215 1
a215 1
	local $_;
d236 1
a236 1
	local $_;
d251 1
a251 1
	local $_;
d272 1
a272 1
	local $_;
@


1.83
log
@oops, @@bin files are files too
@
text
@d278 1
a278 1
				redo MAINLOOP unless m/^\@@(?:md5|size|symlink|link)\b/o;
@


1.82
log
@provision for reading only prelink related stuff from a package (maybe
a bit more, we'll trim it as fitting).
@
text
@d154 1
a154 1
	    	next unless m/^\@@(?:cwd|name|info|man|file|lib|shell|sample)\b/o || !m/^\@@/o;
@


1.81
log
@let pkg_info -E see @@sample objects. No sense in hiding them.
@
text
@d2 1
a2 1
# $OpenBSD: PackingList.pm,v 1.80 2007/06/20 13:44:39 espie Exp $
d155 11
@


1.80
log
@sprinkle code to deal gracefully with absent packing-lists.
makes it easier for people to recover after a disk crash that
leaves /var/db/pkg half-empty.
@
text
@d2 1
a2 1
# $OpenBSD: PackingList.pm,v 1.79 2007/06/19 10:47:28 espie Exp $
d154 1
a154 1
	    	next unless m/^\@@(?:cwd|name|info|man|file|lib|shell)\b/o || !m/^\@@/o;
@


1.79
log
@first draft of a tag solver, needs more flesh to be useful (especially:
transform the lib cache into a tags/lib cache)
@
text
@d2 1
a2 1
# $OpenBSD: PackingList.pm,v 1.78 2007/06/12 09:53:36 espie Exp $
d422 2
a423 3
	my $plist =
	    $o->fromfile(OpenBSD::PackageInfo::installed_contents($pkgname), 
		$code);
d429 6
@


1.78
log
@tidy error messages: uses $! more consistently, do not append \n on die,
do append \n on warn.

Fix the two cases where the temp dir vanished too soon: not copying +DESC
should have been apparent. Not finding a +DISPLAY file is not a reason for
burping all over the place.
@
text
@d2 1
a2 1
# $OpenBSD: PackingList.pm,v 1.77 2007/06/06 12:32:09 espie Exp $
d167 1
a167 1
			    if (m/^\@@(?:depend|wantlib)\b/o) {
d175 1
a175 1
		next unless m/^\@@(?:depend|wantlib)\b/o;
d377 1
a377 1
    	wantlib groups users items));
@


1.77
log
@tweak how copies happen: rename make_copy into make_shallow_copy,
make_deep_copy.

tweak keep_old_files so that we set the pkgname later, when it won't
cause any error to have duplicates in there.
@
text
@d2 1
a2 1
# $OpenBSD: PackingList.pm,v 1.76 2007/06/04 14:40:39 espie Exp $
d323 1
a323 1
		die "Duplicate $category in plist\n";
@


1.76
log
@some minor systematic changes.
- mark all regexps I can with /o if they can be compiled once.
- turn $o->method() into $o->method
- remove unneeded prototypes
- reduce split /re/ into split "string" where possible.
@
text
@d2 1
a2 1
# $OpenBSD: PackingList.pm,v 1.75 2007/06/01 20:39:41 espie Exp $
d69 1
a69 1
sub make_copy
d75 1
a75 1
	$plist->copy_if($copy, $h);
d79 9
@


1.75
log
@micro-optimizations
@
text
@d2 1
a2 1
# $OpenBSD: PackingList.pm,v 1.74 2007/05/31 13:33:17 espie Exp $
d65 1
a65 1
	$dir .= '/' unless $dir =~ m/\/$/;
d255 1
a255 1
		if (m/^\@@shared\b/) {
d258 3
a260 3
				redo MAINLOOP unless m/^\@@(?:md5|size|symlink|link)\b/;
				    m/^\@@size\b/ || m/^\@@symlink\b/ || 
				    m/^\@@link\b/;
d264 1
a264 1
			next unless m/^\@@(?:cwd|name)\b/;
d280 1
a280 1
		$@@ =~ s/\.$/,/;
d468 1
a468 1
	(my $sub = $fullsub) =~ s/.*:://;
@


1.74
log
@move set validation earlier (in fact, it probably doesn't belong in
really_add).

move common delete_installed() code inside Delete.pm
@
text
@d2 1
a2 1
# $OpenBSD: PackingList.pm,v 1.73 2007/05/31 13:11:21 espie Exp $
d98 3
a100 4
			local $_ = shift;
			return if m/^\s*$/;
			chomp;
			OpenBSD::PackingElement->create($_, $plist);
@


1.73
log
@oops, move realname up so that ::Sample sees it too.

remove last traces of MODULEs.
@
text
@d2 1
a2 1
# $OpenBSD: PackingList.pm,v 1.72 2007/05/30 16:32:14 espie Exp $
d429 1
a429 1
	return if defined $plist_cache->{$self->pkgname()};
@


1.72
log
@simplify script handling a bit (they're going to disappear probably anyways).

Remove two passes visitors, we don't use them.
@
text
@d2 1
a2 1
# $OpenBSD: PackingList.pm,v 1.71 2007/05/30 12:29:19 espie Exp $
d369 1
a369 1
    	wantlib module groups users items));
@


1.71
log
@new functionality: copy elements of packing-lists to a new plist if they
are registered in a hash. This will be used to create borked packages in
a much simpler way.

Also, set_pkgname, so that I don't have to remember whether this
packing-list already has a name. Useful when copying stuff over.
@
text
@d2 1
a2 1
# $OpenBSD: PackingList.pm,v 1.70 2007/05/30 11:13:35 espie Exp $
a363 15
{
    package OpenBSD::PackingList::Visitor;
    sub new
    {
	    my $class = shift;
	    bless {list=>[], pass=>1}, $class;
    }

    sub revisit
    {
	    my ($self, $item) = @@_;
	    push(@@{$self->{list}}, $item);
    }
}

a377 4
	my $visitor = new OpenBSD::PackingList::Visitor;

	push(@@l, $visitor);

a397 4
	}
	$visitor->{pass} = 2;
	while (my $item = shift @@{$visitor->{list}}) {
		$item->$method(@@l);
@


1.70
log
@separate the creation of the borked package and the Fatal.
@
text
@d2 1
a2 1
# $OpenBSD: PackingList.pm,v 1.69 2007/05/29 13:17:48 espie Exp $
d69 11
d330 10
@


1.69
log
@set_infodir only if plist got defined.
@
text
@d2 1
a2 1
# $OpenBSD: PackingList.pm,v 1.68 2007/05/29 13:00:17 espie Exp $
d72 1
a72 1
	return ${$self->{infodir}}
@


1.68
log
@a few more details so that infodirs become useful.
@
text
@d2 1
a2 1
# $OpenBSD: PackingList.pm,v 1.67 2007/05/29 12:36:53 espie Exp $
d422 3
a424 1
	$plist->set_infodir(OpenBSD::PackageInfo::installed_info($pkgname));
@


1.67
log
@clean-up SpecialFile a bit: make sure the name passed during creation is
totally irrelevant.

Add a new property to packing-lists: infodir, and use it to compute fullnames
for special files.

Once this is properly synchronized, we can tie infodir to packing-lists, and
remove it from the state...
@
text
@d2 1
a2 1
# $OpenBSD: PackingList.pm,v 1.66 2007/05/28 11:35:54 espie Exp $
d64 2
a65 1
	my ($self, $dir) = shift;
d69 6
d284 6
@


1.66
log
@always create packing-lists with a `contents' entry.
@
text
@d2 1
a2 1
# $OpenBSD: PackingList.pm,v 1.65 2007/05/24 11:06:29 espie Exp $
d56 2
a57 1
	my $plist = bless {state => OpenBSD::PackingList::State->new }, $class;
d62 6
d409 1
d423 1
a423 1
	$plist_cache->{$self->pkgname()} = $plist;
@


1.65
log
@place holder for signature checking
@
text
@d2 1
a2 1
# $OpenBSD: PackingList.pm,v 1.64 2007/05/24 10:06:35 espie Exp $
d56 3
a58 3
	bless {state => 
		OpenBSD::PackingList::State->new
	}, $class;
@


1.64
log
@catch up and rethrow Packing-List read issues with the filename when
available.
@
text
@d2 1
a2 1
# $OpenBSD: PackingList.pm,v 1.63 2007/05/03 14:47:29 espie Exp $
d318 4
@


1.63
log
@remove future code to handle modules, that is unused and possibly badly
designed as well.
@
text
@d2 1
a2 1
# $OpenBSD: PackingList.pm,v 1.62 2007/05/02 15:17:36 espie Exp $
d250 9
a258 1
	my $plist = $a->read($fh, $code);
@


1.62
log
@replace pkgbase with less confusing name localbase
@
text
@d2 1
a2 1
# $OpenBSD: PackingList.pm,v 1.61 2007/05/02 15:13:05 espie Exp $
d63 1
a63 1
	my ($a, $fh, $code) = @@_;
d71 1
a71 1
	&$code($fh,
a76 4
			if ($plist->{need_modules}) {
				close($fh);
				open($fh, '<', '/dev/null');
			}
@


1.61
log
@replace abstract Factory name with a more sensible create name.
Call it OO, so that we can specialize it if we ever need it.
Be more explicit about parameters.
@
text
@d2 1
a2 1
# $OpenBSD: PackingList.pm,v 1.60 2007/05/02 15:05:30 espie Exp $
d297 1
a297 1
sub pkgname($)
d303 1
a303 1
sub pkgbase($)
@


1.60
log
@$o->method() becomes $o->method
@
text
@d2 1
a2 1
# $OpenBSD: PackingList.pm,v 1.59 2007/05/01 20:13:44 espie Exp $
d76 1
a76 1
			OpenBSD::PackingElement::Factory($_, $plist);
@


1.59
log
@repair -L option, should work much better if we copy @@localbase over...
@
text
@d2 1
a2 1
# $OpenBSD: PackingList.pm,v 1.58 2007/05/01 19:54:55 espie Exp $
d57 1
a57 1
		OpenBSD::PackingList::State->new()
d271 1
a271 1
	my $category = $object->category();
d278 1
a278 1
	my $category = $object->category();
d418 1
a418 1
	$self->tofile(OpenBSD::PackageInfo::installed_contents($self->pkgname()));
d427 1
a427 1
	return join(',', $self->pkgname(), sort keys %$k);
@


1.58
log
@remove more traces of old dependencies
@
text
@d2 1
a2 1
# $OpenBSD: PackingList.pm,v 1.57 2007/04/29 11:28:59 espie Exp $
d331 1
a331 1
    (qw(name no-default-conflict manual-installation extrainfo arch));
@


1.57
log
@make packing-lists more regular by including the CONTENTS. Avoid
`recursion' by not writing it out. also remove PackingList::write,
since it's a simple visitor.
@
text
@d2 1
a2 1
# $OpenBSD: PackingList.pm,v 1.56 2007/04/29 10:52:15 espie Exp $
d99 1
a99 1
		next unless m/^\@@(?:cwd|dirrm|dir|fontdir|mandir|newuser|newgroup|name)\b/o || m/^\@@(?:sample|extra)\b.*\/$/o || m/^[^\@@].*\/$/o;
d138 1
a138 1
			    if (m/^\@@(?:depend|wantlib|pkgdep|newdepend|libdepend)\b/o) {
d146 1
a146 1
		next unless m/^\@@(?:depend|wantlib|pkgdep|newdepend|libdepend)\b/o;
d180 1
a180 1
			    if (m/^\@@(?:depend|wantlib|pkgdep|newdepend|libdepend|pkgpath)\b/o) {
d188 1
a188 1
		next unless m/^\@@(?:name\b|depend\b|wantlib\b|pkgdep\b|newdepend\b|libdepend\b|pkgpath\b|comment\s+subdir\=|arch\b)/o;
d216 1
a216 1
			    if (m/^\@@(?:pkgcfl|conflict|option|name)\b/o) {
d218 1
a218 1
			    } elsif (m/^\@@(?:depend|wantlib|pkgdep|newdepend|libdepend|groups|users|cwd)\b/o) {
d224 1
a224 1
	    	next unless m/^\@@(?:pkgcfl|conflict|option|name)\b/o;
d244 1
a244 1
			next unless m/^\@@(?:cwd|dirrm|name)\b/;
d334 2
a335 2
    (qw(pkgcfl conflict pkgpath incompatibility updateset depend 
    	wantlib pkgdep newdepend libdepend module groups users items));
d338 1
a338 1
    (qw(depend wantlib pkgdep newdepend libdepend));
@


1.56
log
@use an AUTOLOAD to auto-create PackingList visitors when needed.
Document visitors, at least partially.
@
text
@d2 1
a2 1
# $OpenBSD: PackingList.pm,v 1.55 2007/04/15 10:17:29 espie Exp $
a248 9

sub write
{
	my ($self, $fh) = @@_;

	$self->visit('write', $fh);

}

@


1.55
log
@update copyright years, standardize licence.
reword the introduction to the stuff originally from FreeBSD to clarify
slightly.
@
text
@d2 1
a2 1
# $OpenBSD: PackingList.pm,v 1.54 2007/04/15 10:00:50 espie Exp $
d441 23
@


1.54
log
@use autovivification
@
text
@d2 1
a2 1
# $OpenBSD: PackingList.pm,v 1.53 2007/04/08 12:35:40 espie Exp $
d4 1
a4 1
# Copyright (c) 2003-2004 Marc Espie <espie@@openbsd.org>
@


1.53
log
@remove warning (exiting thru next)
@
text
@d2 1
a2 1
# $OpenBSD: PackingList.pm,v 1.52 2007/02/08 11:07:37 bernd Exp $
a280 1
	$plist->{$category} = [] unless defined $plist->{$category};
@


1.52
log
@Fix a typo. 'Yes, of course.' espie@@
@
text
@d2 1
a2 1
# $OpenBSD: PackingList.pm,v 1.51 2006/11/17 15:34:15 espie Exp $
d74 1
a74 1
			next if m/^\s*$/;
@


1.51
log
@don't return undef, use plain return.
(return undef is only false in a scalar context)
found my perlcritic, one of the few issues I agree with...
@
text
@d2 1
a2 1
# $OpenBSD: PackingList.pm,v 1.50 2005/09/19 09:51:01 espie Exp $
d381 1
a381 1
		$item->method(@@l);
@


1.50
log
@Let ExtraInfoOnly grab pkgpath as well.
@
text
@d2 1
a2 1
# $OpenBSD: PackingList.pm,v 1.49 2005/09/07 10:39:25 espie Exp $
d262 1
a262 1
	open(my $fh, '<', $fname) or return undef;
d271 1
a271 1
	open(my $fh, '>', $fname) or return undef;
d273 1
a273 1
	close($fh) or return undef;
@


1.49
log
@copy new annotations over.
@
text
@d2 1
a2 1
# $OpenBSD: PackingList.pm,v 1.48 2005/09/04 22:47:56 espie Exp $
d158 7
a164 1
			&$cont($_);
@


1.48
log
@* New -i interactive option, that can ask obnoxious questions.
* move the signature code to a packing-list method, prepend the pkgname.
* depend on distant listings, cache these systematically.
* cut the PKG_PATH at :/ systematically, much simpler than parsing URLs.
People should get used to trailing /s.
* let pkg_add -u actually run the update.
* check for signature in more places, for instance, let pkg_add installed_stuff
be a void operation.
* grab enough stuff during updates to check signatures, so that pkg_add -u
can report updates that are not needed right away, instead of waiting
for the more confusing `trying to update'
* beginning of @@module support.
* @@pkgpath support, including updates.
* systematically expand stems when applicable.
* use visitors systematically in pkg_info.
* pkg_info -S reports signature.
* remove hardcoding of categories in PackingList, so that future modules
will be able to expand them.
* add @@updateset and @@incompatibility keywords.
@
text
@d2 1
a2 1
# $OpenBSD: PackingList.pm,v 1.47 2005/08/17 10:00:19 espie Exp $
d338 2
a339 2
    (qw(pkgcfl conflict depend wantlib pkgdep newdepend 
    	libdepend module groups users items));
@


1.47
log
@save architecture as well for ExtraInfo, so that pkg_add -u won't try
to add packages for the wrong architecture.

Noticed by Tim Kornau.
@
text
@d2 1
a2 1
# $OpenBSD: PackingList.pm,v 1.46 2005/06/26 11:23:35 espie Exp $
d77 4
d166 21
d334 10
d358 1
a358 1
	for my $unique_item (qw(name no-default-conflict manual-installation extrainfo arch)) {
d366 1
a366 1
	for my $listname (qw(modules pkgcfl conflict depend wantlib pkgdep newdepend libdepend groups users items)) {
d406 1
a406 1
	for my $c (qw(depend wantlib pkgdep newdepend libdepend)) {
d425 8
@


1.46
log
@faster fat package finder
@
text
@d2 1
a2 1
# $OpenBSD: PackingList.pm,v 1.45 2005/06/21 19:12:31 espie Exp $
d154 1
@


1.45
log
@move Arch->check() up to Packingelement, so that it can be called anywhere,
not only while adding packages.

Add FatOnly filter, which will be used to get information from packing-lists
to select the correct packing-list from a fat package (e.g., @@arch and @@name).
@
text
@d2 1
a2 1
# $OpenBSD: PackingList.pm,v 1.44 2004/12/16 11:19:59 espie Exp $
d166 6
a171 1
		next unless m/^\@@(?:name\b|arch\b)/o;
@


1.44
log
@save depend information into cache when package is installed.
@
text
@d2 1
a2 1
# $OpenBSD: PackingList.pm,v 1.43 2004/12/16 11:07:33 espie Exp $
d157 10
@


1.43
log
@renamed borked_installation from borked.n to partial-<pkgname> ...
partial-<pkgname>.n if needed.

Make borked_installation take a message, to show installation/deinstallation
issues correctly.

Fix handling of ^C: this may lead some system calls to return early, thus
registering as errors: so always mark the last file as done, so that borked
installation will register it correctly.

Kill packing-list cache for anything but depends: we've got a global cache
of libraries now (use it in pkg_add).

Make almost everyone look at $main::not, so that we can call
register_installation
to_installation
RequirementList->add/delete
safely.

Simplify $not logic accordingly, do thing much more closely to what would
happen without -n.

This should allow pkg_add/pkg_delete -n to handle most nasty cases correctly
now, since all the relevant information is kept internally in a compact
format:
- register of shared libraries
- global register of conflicts
- cache of depends.
@
text
@d2 1
a2 1
# $OpenBSD: PackingList.pm,v 1.42 2004/12/15 01:07:10 espie Exp $
d352 9
@


1.42
log
@move -n down into RequiredBy and PackingList (as $main::not, since we
don't want to load RequiredBy all the time).
Remove a few $state->{not} tests that are no longer needed.

pkg_add -n / pkg_delete -n should work much better when they need to
handle multiple dependencies.

(todo: kill plist caches, finish replacing with specialized caches like
libraries).
@
text
@d2 1
a2 1
# $OpenBSD: PackingList.pm,v 1.41 2004/11/18 21:46:07 espie Exp $
a69 1
		$plist->{code} = $code;
a335 3
	if (defined $plist_cache->{\&defaultCode}->{$pkgname}) {
		return $plist_cache->{\&defaultCode}->{$pkgname};
	}
d338 8
a345 10
	if (!defined $plist_cache->{$code}->{$pkgname}) {
	    my $plist =
	    	$o->fromfile(OpenBSD::PackageInfo::installed_contents($pkgname), 
		    $code);
	    if (defined $plist) {
		$plist_cache->{$code}->{$pkgname} = $plist;
		return $plist;
	    } else {
	    	return undef;
	    }
d347 1
a347 1
	return $plist_cache->{$code}->{$pkgname};
a351 3
	my ($self) = @@_;

	$plist_cache->{\&defaultCode}->{$self->pkgname()} = $self;
a359 1
	$self->to_cache();
a367 5
	my ($self) = @@_;

	if (defined $plist_cache->{$self->{code}}) {
		delete $plist_cache->{$self->{code}}->{$self->pkgname()};
	}
@


1.41
log
@add @@wantlib and @@depend keyword
@
text
@d2 1
a2 1
# $OpenBSD: PackingList.pm,v 1.40 2004/11/15 15:06:22 espie Exp $
d369 3
a372 1
	$self->to_cache();
@


1.40
log
@compile patterns once, should be a slight speed up.
@
text
@d2 1
a2 1
# $OpenBSD: PackingList.pm,v 1.39 2004/11/13 13:55:03 espie Exp $
d135 1
a135 1
			    if (m/^\@@(?:pkgdep|newdepend|libdepend)\b/o) {
d143 1
a143 1
		next unless m/^\@@(?:pkgdep|newdepend|libdepend)\b/o;
d172 1
a172 1
			    } elsif (m/^\@@(?:pkgdep|newdepend|libdepend|groups|users|cwd)\b/o) {
d316 1
a316 1
	for my $listname (qw(modules pkgcfl conflict pkgdep newdepend libdepend groups users items)) {
@


1.39
log
@don't store things in cache if we know we're not going to use them again.
@
text
@d2 1
a2 1
# $OpenBSD: PackingList.pm,v 1.38 2004/11/13 12:49:58 espie Exp $
d96 1
a96 1
		next unless m/^\@@(?:cwd|dirrm|dir|fontdir|mandir|newuser|newgroup|name)\b/ || m/^\@@(?:sample|extra)\b.*\/$/ || m/^[^\@@].*\/$/;
d111 2
a112 2
		next unless m/^\@@(?:cwd|lib|name)\b/ ||
			m/^\@@comment\s+subdir\=/;
d122 1
a122 1
	    	next unless m/^\@@(?:cwd|name|info|man|file|lib|shell)\b/ || !m/^\@@/;
d133 1
a133 1
		if (m/^\@@arch\b/) {
d135 1
a135 1
			    if (m/^\@@(?:pkgdep|newdepend|libdepend)\b/) {
d137 1
a137 1
			    } elsif (m/^\@@(?:groups|users|cwd)\b/) {
d143 1
a143 1
		next unless m/^\@@(?:pkgdep|newdepend|libdepend)\b/;
d154 1
a154 1
		if (m/^\@@arch\b/) {
d157 1
a157 1
		next unless m/^\@@(?:name\b|comment\s+subdir\=)/;
d168 1
a168 1
		if (m/^\@@arch\b/) {
d170 1
a170 1
			    if (m/^\@@(?:pkgcfl|conflict|option|name)\b/) {
d172 1
a172 1
			    } elsif (m/^\@@(?:pkgdep|newdepend|libdepend|groups|users|cwd)\b/) {
d178 1
a178 1
	    	next unless m/^\@@(?:pkgcfl|conflict|option|name)\b/;
@


1.38
log
@synchronize installed stuff, using the cache in -n mode so that -n
installations can proceed to the end...
@
text
@d2 1
a2 1
# $OpenBSD: PackingList.pm,v 1.37 2004/11/13 11:48:46 espie Exp $
d65 1
d70 1
a71 1
	$code = \&defaultCode if !defined $code;
a346 1
	    	$plist->{code} = $code;
d378 3
a380 1
	delete $plist_cache->{$self->{code}}->{$self->pkgname()};
@


1.37
log
@likewise, packing-lists state will store refs to cwd, so make this
a true object with cwd()/set_cwd() functions.
@
text
@d2 1
a2 1
# $OpenBSD: PackingList.pm,v 1.36 2004/11/13 11:39:40 espie Exp $
d356 7
d369 2
a370 4
	my $pkgname = $self->pkgname();

	$self->tofile(OpenBSD::PackageInfo::installed_contents($pkgname));
	$plist_cache->{\&defaultCode}->{$pkgname} = $self;
@


1.36
log
@cwd() function so that further changes to internal storage won't matter
that much.
@
text
@d2 1
a2 1
# $OpenBSD: PackingList.pm,v 1.35 2004/11/12 23:26:41 espie Exp $
d20 28
a52 1
my $dot = '.';
d57 2
a58 4
	    {default_owner=>'root', 
	     default_group=>'bin', 
	     default_mode=> 0444,
	     cwd=>\$dot} }, $class;
@


1.35
log
@store a ref to cwd instead of cwd itself, allowing it to be shared.
@
text
@d2 1
a2 1
# $OpenBSD: PackingList.pm,v 1.34 2004/11/11 15:32:28 espie Exp $
d25 1
a28 1
	my $o = '.';
d33 1
a33 1
	     cwd=>\$o} }, $class;
@


1.34
log
@cache packing-lists, so that we don't read them again and again.

big win as soon as pkg_add -r updates two or three packages with lots
of dependencies.
@
text
@d2 1
a2 1
# $OpenBSD: PackingList.pm,v 1.33 2004/11/11 11:16:40 espie Exp $
d28 1
d33 1
a33 1
	     cwd=>'.'} }, $class;
@


1.33
log
@introduce shortcuts to read/write contents from_installation/to_installation

use these to simplify all those packing lists manipulations.

demote non-root detection to a warning in -n mode:
fix a couple of minor bugs, of stuff that was run in -n mode and should not.
Namely, manpages were indexed/unindexed (ouch) and tempfiles were creating
during updates.
@
text
@d2 1
a2 1
# $OpenBSD: PackingList.pm,v 1.32 2004/11/10 09:55:43 espie Exp $
d302 2
d306 1
a306 1
	my ($o, $name, @@args) = @@_;
d310 18
a327 2
	return $o->fromfile(OpenBSD::PackageInfo::installed_contents($name), 
	    @@args);
d336 12
a347 1
	$self->tofile(OpenBSD::PackageInfo::installed_contents($self->pkgname()));
@


1.32
log
@use ExtraInfo, finally: allows pkg_info to report packages according to
PKGPATH, e.g., pkg_info -e x11/kde/base3 will tell you which version
(if any) of kdebase is installed.

Necessary for achieving updates.
@
text
@d2 1
a2 1
# $OpenBSD: PackingList.pm,v 1.31 2004/11/09 10:30:26 espie Exp $
d300 19
@


1.31
log
@avoid scanning the whole packing-list when looking for info that are
at the top anyways: recent packages have arch markers, and are in `normal
order'. First cwd we meet, we're out.
(speeds up the scanning of conflicts by 4 or 5).
@
text
@d2 1
a2 1
# $OpenBSD: PackingList.pm,v 1.30 2004/10/26 17:25:36 espie Exp $
d117 14
@


1.30
log
@more accurate name: DirRmOnly -> SharedItemsOnly
use a visitor instead of hardcoding items/users/groups.
@
text
@d2 1
a2 1
# $OpenBSD: PackingList.pm,v 1.29 2004/10/23 11:09:22 espie Exp $
d105 11
d126 11
@


1.29
log
@beginning of update module: basic check that stuff we are replacing
is still okay.
@
text
@d2 1
a2 1
# $OpenBSD: PackingList.pm,v 1.28 2004/10/11 14:25:28 espie Exp $
d64 1
a64 1
sub DirrmOnly
d72 5
@


1.28
log
@remove special `visiting order' when writing packing-lists.
Add implicit '.' cwd at beginning of packing-list.
so that special files get registered at front of packing-list before
any cwd occurs (and they get in the same order as stuff gets written
through tar).
@
text
@d2 1
a2 1
# $OpenBSD: PackingList.pm,v 1.27 2004/10/11 14:11:42 espie Exp $
d91 10
@


1.27
log
@better visitor, that allows for revisits later.
@
text
@d2 1
a2 1
# $OpenBSD: PackingList.pm,v 1.26 2004/09/24 08:49:27 espie Exp $
d31 2
a32 1
	     default_mode=> 0444} }, $class;
d130 2
a131 18
	if (defined $self->{cvstags}) {
		for my $item (@@{$self->{cvstags}}) {
			$item->write($fh);
		}
	}
	for my $unique_item (qw(name no-default-conflict manual-installation extrainfo arch)) {
		$self->{$unique_item}->write($fh) if defined $self->{$unique_item};
	}
	for my $listname (qw(modules pkgcfl conflict pkgdep newdepend libdepend groups users items)) {
		if (defined $self->{$listname}) {
			for my $item (@@{$self->{$listname}}) {
				$item->write($fh);
			}
		}
	}
	for my $special (OpenBSD::PackageInfo::info_names()) {
		$self->{$special}->write($fh) if defined $self->{$special};
	}
@


1.26
log
@2nd half of @@newuser/@@newgroup: treat them as shared items, and remove
them along with directories, if extra.
@
text
@d2 1
a2 1
# $OpenBSD: PackingList.pm,v 1.25 2004/09/21 22:17:49 espie Exp $
a148 28
sub visit
{
	my ($self, $method, @@l) = @@_;

	if (defined $self->{cvstags}) {
		for my $item (@@{$self->{cvstags}}) {
			$item->$method(@@l);
		}
	}

	for my $special (OpenBSD::PackageInfo::info_names()) {
		$self->{$special}->$method(@@l, 0) if defined $self->{$special};
	}

	for my $unique_item (qw(name no-default-conflict manual-installation extrainfo arch)) {
		$self->{$unique_item}->$method(@@l) if defined $self->{$unique_item};
	}
	for my $listname (qw(modules pkgcfl conflict pkgdep newdepend libdepend groups users items)) {
		if (defined $self->{$listname}) {
			for my $item (@@{$self->{$listname}}) {
				$item->$method(@@l);
			}
		}
	}
	for my $special (OpenBSD::PackageInfo::info_names()) {
		$self->{$special}->$method(@@l, 1) if defined $self->{$special};
	}
}
d212 51
@


1.25
log
@@@newuser/@@newgroup initial support:
- groups category and users category that get handled first, so that
those groups/users can be used for other files.
- : separated fields, for easy parsing. Mostly matching useradd groupadd.
- ! for mandatory values.
Missing pkg_delete -c support for now.

okay naddy@@, pvalchev@@, millert@@
@
text
@d2 1
a2 1
# $OpenBSD: PackingList.pm,v 1.24 2004/09/18 08:14:40 espie Exp $
d68 1
a68 1
		next unless m/^\@@(?:cwd|dirrm|dir|fontdir|mandir|name)\b/ || m/^\@@(?:sample|extra)\b.*\/$/ || m/^[^\@@].*\/$/;
@


1.24
log
@new-style conflicts that respect pkgspec.
@
text
@d2 1
a2 1
# $OpenBSD: PackingList.pm,v 1.23 2004/09/16 07:46:00 espie Exp $
d137 1
a137 1
	for my $listname (qw(modules pkgcfl conflict pkgdep newdepend libdepend items)) {
d166 1
a166 1
	for my $listname (qw(modules pkgcfl conflict pkgdep newdepend libdepend items)) {
@


1.23
log
@Add LibraryOnly routine to check on @@lib files.
Forgot to add shell to the list of files...
@
text
@d2 1
a2 1
# $OpenBSD: PackingList.pm,v 1.22 2004/09/14 22:28:23 espie Exp $
d99 1
a99 1
	    	next unless m/^\@@(?:pkgcfl|option|name)\b/;
d137 1
a137 1
	for my $listname (qw(modules pkgcfl pkgdep newdepend libdepend items)) {
d166 1
a166 1
	for my $listname (qw(modules pkgcfl pkgdep newdepend libdepend items)) {
@


1.22
log
@new categories, modules and manual-installation, not active yet.
new visit method, to do anything on a packing-list.
@
text
@d2 1
a2 1
# $OpenBSD: PackingList.pm,v 1.21 2004/08/06 10:23:45 espie Exp $
d73 11
d89 1
a89 1
	    	next unless m/^\@@(?:cwd|name|info|man|file|lib)\b/ || !m/^\@@/;
@


1.21
log
@@@lib shared library marker.

- runs ldconfig to find out search library path.
- if library is in path, mark directory for updating cache.
- run ldconfig when needed, e.g., right before executing something that
might depend on the library.

Doesn't handle destdir case yet.
@
text
@d2 1
a2 1
# $OpenBSD: PackingList.pm,v 1.20 2004/08/06 08:06:01 espie Exp $
d123 1
a123 1
	for my $unique_item (qw(name no-default-conflict extrainfo arch)) {
d126 1
a126 1
	for my $listname (qw(pkgcfl pkgdep newdepend libdepend items)) {
d135 29
@


1.20
log
@block-scoped require is way simpler than weird AUTOLOAD hack.
@
text
@d2 1
a2 1
# $OpenBSD: PackingList.pm,v 1.19 2004/08/06 07:51:17 espie Exp $
d78 1
a78 1
	    	next unless m/^\@@(?:cwd|name|info|man|file)\b/ || !m/^\@@/;
@


1.19
log
@unified headers, switch to smaller copyright notice.
@
text
@d2 1
a2 1
# $OpenBSD: PackingList.pm,v 1.18 2004/08/05 23:39:19 espie Exp $
a200 5
}

# allows the autoloader to work correctly
sub DESTROY
{
@


1.18
log
@kill 3 lines of unused code
@
text
@d1 2
a2 1
# $OpenBSD: PackingList.pm,v 1.17 2004/08/05 23:36:40 espie Exp $
d4 13
a16 22
# Copyright (c) 2003 Marc Espie.
# 
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
# 
# THIS SOFTWARE IS PROVIDED BY THE OPENBSD PROJECT AND CONTRIBUTORS
# ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
# A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OPENBSD
# PROJECT OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
@


1.17
log
@refactor classes in PackingElement to share more code.
- all files go through FileBase, all directories go through DirBase.
- dirclass() is used to switch classes based on final /, so that
@@sample, @@extra, and @@file  all take directories as well.
- set NoDuplicateNames() more thoroughly.
- make sure all no-default-conflict objects are correct.

compute_fullname() checks for absolute paths, allowed for @@sample and
@@extra.

lastfile only gets set for actual files.

special names like INSTALL are only checked for normal files.

add a CVSTag class for @@comment $OpenBSD$, so that these get sorted first.

Changes for make-plist rewrite:

clone() method that can create copies of all hash objects, to specialize
if needed.

add_object() method so that add() is now new() followed by add_object()
for most objects (useful for cloned objects).

Check that plist has a name in pkg_create, allowing PackingList to write
unnamed plists.
@
text
@d1 1
a1 1
# $OpenBSD: PackingList.pm,v 1.16 2004/08/03 12:33:48 espie Exp $
d124 1
a124 6
	my ($self, $fh, $w) = @@_;

	$w = sub {
		my ($o, $fh) = @@_;
		$o->write($fh);
	    } unless defined $w;
@


1.16
log
@forgot mandir. reorder slightly.
@
text
@d1 1
a1 1
# $OpenBSD: PackingList.pm,v 1.15 2004/08/03 12:29:45 espie Exp $
d76 1
a76 1
		next unless m/^\@@(?:cwd|dirrm|dir|fontdir|mandir|name)\b/ || m/^[^\@@].*\/$/;
d124 11
a134 8
	my ($self, $fh) = @@_;
	if (!defined $self->{name}) {
		print STDERR "Can't write unnamed packing list\n";
		exit 1;
	}
	$self->{name}->write($fh);
	if (defined $self->{'no-default-conflict'}) {
		$self->{'no-default-conflict'}->write($fh);
d136 1
a136 1
	for my $unique_item (qw(extrainfo arch)) {
@


1.15
log
@Support @@sample, tested by fries@@.
@@mandir and @@fontdir keywords recognition.
@
text
@d1 1
a1 1
# $OpenBSD: PackingList.pm,v 1.14 2004/08/02 12:12:36 espie Exp $
d76 1
a76 1
		next unless m/^\@@cwd\b/ || m/^\@@dirrm\b/ || m/^\@@dir\b/ || m/^\@@fontdir\b/ || m/^\@@name\b/ || m/^[^\@@].*\/$/;
d86 1
a86 1
	    	next unless m/^\@@cwd\b/ || m/^\@@name\b/ || m/^\@@info\b/ || m/^\@@man\b/ || !m/^\@@/;
d96 1
a96 1
	    	next unless m/^\@@pkgcfl\b/ || m/^\@@option\b/ || m/^\@@name\b/;
d110 1
a110 1
				redo MAINLOOP unless m/^\@@md5\b/ || 
d116 1
a116 1
			next unless m/^\@@cwd\b/ || m/^\@@dirrm\b/ || m/^\@@name\b/;
@


1.14
log
@@@man type file for manpages.
@
text
@d1 1
a1 1
# $OpenBSD: PackingList.pm,v 1.13 2004/07/22 23:53:53 espie Exp $
d76 1
a76 1
		next unless m/^\@@cwd\b/ || m/^\@@dirrm\b/ || m/^\@@dir\b/ || m/^\@@name\b/ || m/^[^\@@].*\/$/;
@


1.13
log
@fast-scanner should now about dir/ too.
@
text
@d1 1
a1 1
# $OpenBSD: PackingList.pm,v 1.12 2004/07/20 18:58:41 espie Exp $
d86 1
a86 1
	    	next unless m/^\@@cwd\b/ || m/^\@@name\b/ || m/^\@@info\b/ || !m/^\@@/;
@


1.12
log
@support for gnu-info, with @@info keyword.
- modify pkg_create so that it will look for info-[0-9]+ and add them
to the packing-list.
- deal with installing the info file/de-installing it at pkg_add/pkg_delete
time.

tested by naddy@@
@
text
@d1 1
a1 1
# $OpenBSD: PackingList.pm,v 1.11 2004/07/14 10:44:03 espie Exp $
d76 1
a76 1
		next unless m/^\@@cwd\b/ || m/^\@@dirrm\b/ || m/^\@@dir\b/ || m/^\@@name\b/;
@


1.11
log
@Rework @@dirrm: keep them all, and remove them at the end of pkg_delete.
Add @@dir, more powerful than @@dirrm, so that we can get rid of those
pesky @@exec mkdir -p.

okay naddy@@
@
text
@d1 1
a1 1
# $OpenBSD: PackingList.pm,v 1.10 2004/07/13 00:35:39 espie Exp $
d86 1
a86 1
	    	next unless m/^\@@cwd\b/ || m/^\@@name\b/ || !m/^\@@/;
@


1.10
log
@at pkg_create time, mark hard links with @@link, and symlinks with @@symlink,
instead of computing size and md5.
okay naddy@@, sturm@@
@
text
@d1 1
a1 1
# $OpenBSD: PackingList.pm,v 1.9 2004/07/05 09:22:40 espie Exp $
d76 1
a76 1
		next unless m/^\@@cwd\b/ || m/^\@@dirrm\b/ || m/^\@@name\b/;
@


1.9
log
@less esoteric error message for missing @@name, on a question from
Brad Webb.
@
text
@d1 1
a1 1
# $OpenBSD: PackingList.pm,v 1.8 2004/05/19 13:05:16 espie Exp $
d110 3
a112 1
				redo MAINLOOP unless m/^\@@md5\b/ || m/^\@@size\b/;
@


1.8
log
@Add word boundary markers, so that the fast scanners get exactly what they
are supposed to.
@
text
@d1 1
a1 1
# $OpenBSD: PackingList.pm,v 1.7 2004/04/28 06:50:21 espie Exp $
d123 4
@


1.7
log
@slightly more intricate selectors code.
Approved by at least sturm@@ and fries@@
@
text
@d1 1
a1 1
# $OpenBSD: PackingList.pm,v 1.6 2004/02/23 21:47:48 espie Exp $
d76 1
a76 1
		next unless m/^\@@cwd/ || m/^\@@dirrm/ || m/^\@@name/;
d86 1
a86 1
	    	next unless m/^\@@cwd/ || m/^\@@name/ || !m/^\@@/;
d96 1
a96 1
	    	next unless m/^\@@pkgcfl/ || m/^\@@option/ || m/^\@@name/;
d107 1
a107 1
		if (m/^\@@shared/) {
d110 1
a110 1
				redo MAINLOOP unless m/^\@@md5/ || m/^\@@size/;
d114 1
a114 1
			next unless m/^\@@cwd/ || m/^\@@dirrm/ || m/^\@@name/;
@


1.6
log
@document that this even more off-limits than the rest of the
(so far and intentionally) undocumented interface.
@
text
@d1 1
a1 1
# $OpenBSD: PackingList.pm,v 1.5 2004/01/28 22:12:01 espie Exp $
d51 15
d67 1
a67 4
		next if m/^\s*$/;
		next if defined $code and !&$code;
		chomp;
		OpenBSD::PackingElement::Factory($_, $plist);
a68 1
	return $plist;
d71 9
a79 2
# XXX Please don't define other selectors yourself, as this is a hack
# XXX that is bound to change in the future.
d81 1
a81 1
sub OpenBSD::PackingList::DirrmOnly
d83 6
a88 1
	m/^\@@cwd/ || m/^\@@dirrm/ || m/^\@@name/;
d91 1
a91 1
sub OpenBSD::PackingList::FilesOnly
d93 6
a98 1
	m/^\@@cwd/ || m/^\@@name/ || !m/^\@@/;
d101 1
a101 1
sub OpenBSD::PackingList::ConflictOnly
d103 15
a117 1
	m/^\@@pkgcfl/ || m/^\@@option/ || m/^\@@name/;
@


1.5
log
@Add -L to record/enforce localbase.
Okay sturm@@
@
text
@d1 1
a1 1
# $OpenBSD: PackingList.pm,v 1.4 2003/12/26 16:44:31 espie Exp $
d59 3
@


1.4
log
@Allow storing of `arch' annotations inside packages.
Factor common method code in write, keep variations in stringize.
@
text
@d1 1
a1 1
# $OpenBSD: PackingList.pm,v 1.3 2003/11/06 17:46:35 espie Exp $
d151 1
a151 1
sub prefix($)
d154 6
a159 1
	return $self->{state}->{prefix};
@


1.3
log
@Implement discovery of a `packing-list' prefix, e.g., the first @@cwd
present in the packing-list (necessary for libdepends checking).
@
text
@d1 1
a1 1
# $OpenBSD: PackingList.pm,v 1.2 2003/10/19 18:42:55 espie Exp $
d82 3
a84 1
	$self->{extrainfo}->write($fh);
@


1.2
log
@plist's has/get methods for accessing elements: perl ->{} has quirks
that make it unusable for looking up constants correctly.
@
text
@d1 1
a1 1
# $OpenBSD: PackingList.pm,v 1.1.1.1 2003/10/16 17:43:34 espie Exp $
d147 6
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
# $OpenBSD: PackingList.pm,v 1.1.1.1 2003/10/16 17:16:30 espie Exp $
d129 12
@


1.1.1.1
log
@new import of my pkgtools, after a slight naming disagreement with the
Upper Management...
@
text
@@
