head	1.32;
access;
symbols
	OPENBSD_6_2_BASE:1.32
	OPENBSD_6_1:1.31.0.22
	OPENBSD_6_1_BASE:1.31
	OPENBSD_6_0:1.31.0.20
	OPENBSD_6_0_BASE:1.31
	OPENBSD_5_9:1.31.0.14
	OPENBSD_5_9_BASE:1.31
	OPENBSD_5_8:1.31.0.16
	OPENBSD_5_8_BASE:1.31
	OPENBSD_5_7:1.31.0.8
	OPENBSD_5_7_BASE:1.31
	OPENBSD_5_6:1.31.0.12
	OPENBSD_5_6_BASE:1.31
	OPENBSD_5_5:1.31.0.10
	OPENBSD_5_5_BASE:1.31
	OPENBSD_5_4:1.31.0.6
	OPENBSD_5_4_BASE:1.31
	OPENBSD_5_3:1.31.0.4
	OPENBSD_5_3_BASE:1.31
	OPENBSD_5_2:1.31.0.2
	OPENBSD_5_2_BASE:1.31
	OPENBSD_5_1_BASE:1.30
	OPENBSD_5_1:1.30.0.6
	OPENBSD_5_0:1.30.0.4
	OPENBSD_5_0_BASE:1.30
	OPENBSD_4_9:1.30.0.2
	OPENBSD_4_9_BASE:1.30
	OPENBSD_4_8:1.28.0.2
	OPENBSD_4_8_BASE:1.28
	OPENBSD_4_7:1.23.0.2
	OPENBSD_4_7_BASE:1.23
	OPENBSD_4_6:1.16.0.6
	OPENBSD_4_6_BASE:1.16
	OPENBSD_4_5:1.16.0.2
	OPENBSD_4_5_BASE:1.16
	OPENBSD_4_4:1.13.0.2
	OPENBSD_4_4_BASE:1.13
	OPENBSD_4_3:1.11.0.4
	OPENBSD_4_3_BASE:1.11
	OPENBSD_4_2:1.11.0.2
	OPENBSD_4_2_BASE:1.11
	OPENBSD_4_1:1.10.0.10
	OPENBSD_4_1_BASE:1.10
	OPENBSD_4_0:1.10.0.8
	OPENBSD_4_0_BASE:1.10
	OPENBSD_3_9:1.10.0.6
	OPENBSD_3_9_BASE:1.10
	OPENBSD_3_8:1.10.0.4
	OPENBSD_3_8_BASE:1.10
	OPENBSD_3_7:1.10.0.2
	OPENBSD_3_7_BASE:1.10;
locks; strict;
comment	@# @;


1.32
date	2017.04.18.15.12.00;	author espie;	state Exp;
branches;
next	1.31;
commitid	MlZY2C6WfFQv9ptF;

1.31
date	2012.04.28.15.22.49;	author espie;	state Exp;
branches;
next	1.30;

1.30
date	2010.12.24.09.04.14;	author espie;	state Exp;
branches;
next	1.29;

1.29
date	2010.10.27.14.35.56;	author espie;	state Exp;
branches;
next	1.28;

1.28
date	2010.06.30.10.51.04;	author espie;	state Exp;
branches;
next	1.27;

1.27
date	2010.06.30.10.41.42;	author espie;	state Exp;
branches;
next	1.26;

1.26
date	2010.06.15.08.26.39;	author espie;	state Exp;
branches;
next	1.25;

1.25
date	2010.05.10.09.17.55;	author espie;	state Exp;
branches;
next	1.24;

1.24
date	2010.04.24.09.27.15;	author espie;	state Exp;
branches;
next	1.23;

1.23
date	2010.01.19.14.58.53;	author espie;	state Exp;
branches;
next	1.22;

1.22
date	2010.01.17.11.56.46;	author espie;	state Exp;
branches;
next	1.21;

1.21
date	2010.01.09.14.49.53;	author espie;	state Exp;
branches;
next	1.20;

1.20
date	2010.01.05.11.16.08;	author espie;	state Exp;
branches;
next	1.19;

1.19
date	2009.11.15.09.53.52;	author espie;	state Exp;
branches;
next	1.18;

1.18
date	2009.11.11.11.13.16;	author espie;	state Exp;
branches;
next	1.17;

1.17
date	2009.11.10.11.36.56;	author espie;	state Exp;
branches;
next	1.16;

1.16
date	2008.10.21.21.06.19;	author espie;	state Exp;
branches;
next	1.15;

1.15
date	2008.10.20.10.25.16;	author espie;	state Exp;
branches;
next	1.14;

1.14
date	2008.09.29.17.46.59;	author simon;	state Exp;
branches;
next	1.13;

1.13
date	2008.06.21.13.23.09;	author espie;	state Exp;
branches;
next	1.12;

1.12
date	2008.03.10.13.11.57;	author espie;	state Exp;
branches;
next	1.11;

1.11
date	2007.06.04.14.40.39;	author espie;	state Exp;
branches;
next	1.10;

1.10
date	2004.12.12.22.44.51;	author espie;	state Exp;
branches;
next	1.9;

1.9
date	2004.12.12.11.26.16;	author espie;	state Exp;
branches;
next	1.8;

1.8
date	2004.12.06.12.35.36;	author espie;	state Exp;
branches;
next	1.7;

1.7
date	2004.11.27.12.07.58;	author espie;	state Exp;
branches;
next	1.6;

1.6
date	2004.11.15.02.44.50;	author espie;	state Exp;
branches;
next	1.5;

1.5
date	2004.10.23.09.43.16;	author espie;	state Exp;
branches;
next	1.4;

1.4
date	2004.10.23.09.27.48;	author espie;	state Exp;
branches;
next	1.3;

1.3
date	2004.10.20.11.38.57;	author espie;	state Exp;
branches;
next	1.2;

1.2
date	2004.10.04.12.12.30;	author espie;	state Exp;
branches;
next	1.1;

1.1
date	2004.09.14.22.43.09;	author espie;	state Exp;
branches;
next	;


desc
@@


1.32
log
@recent perl have signal names we don't have, protect against that.
also, allow child_error to take a parameter so that this can be used to decode
an arbitrary wait() result.
@
text
@# ex:ts=8 sw=4:
# $OpenBSD: Error.pm,v 1.31 2012/04/28 15:22:49 espie Exp $
#
# Copyright (c) 2004-2010 Marc Espie <espie@@openbsd.org>
#
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF

use strict;
use warnings;

package OpenBSD::Auto;
sub cache(*&)
{
	my ($sym, $code) = @@_;
	my $callpkg = caller;
	my $actual = sub {
		my $self = shift;
		return $self->{$sym} //= &$code($self);
	};
	no strict 'refs';
	*{$callpkg."::$sym"} = $actual;
}

package OpenBSD::Handler;

my $list = [];

sub register
{
	my ($class, $code) = @@_;
	push(@@$list, $code);
}

my $handler = sub {
	my $sig = shift;
	for my $c (@@$list) {
		&$c($sig);
	}
	$SIG{$sig} = 'DEFAULT';
	kill $sig, $$;
};

sub reset
{
	$SIG{'INT'} = $handler;
	$SIG{'QUIT'} = $handler;
	$SIG{'HUP'} = $handler;
	$SIG{'KILL'} = $handler;
	$SIG{'TERM'} = $handler;
}

__PACKAGE__->reset;

package OpenBSD::Error;
require Exporter;
our @@ISA=qw(Exporter);
our @@EXPORT=qw(Copy Unlink try throw catch catchall rethrow);

our ($FileName, $Line, $FullMessage);

my @@signal_name = ();

use Carp;

sub fillup_names
{
	{
	# XXX force autoload
	package verylocal;

	require POSIX;
	POSIX->import(qw(signal_h));
	}

	for my $sym (keys %POSIX::) {
		next unless $sym =~ /^SIG([A-Z].*)/;
		my $i = eval "&POSIX::$sym()";
		next unless defined $i;
		$signal_name[$i] = $1;
	}
	# extra BSD signals
	$signal_name[5] = 'TRAP';
	$signal_name[7] = 'IOT';
	$signal_name[10] = 'BUS';
	$signal_name[12] = 'SYS';
	$signal_name[16] = 'URG';
	$signal_name[23] = 'IO';
	$signal_name[24] = 'XCPU';
	$signal_name[25] = 'XFSZ';
	$signal_name[26] = 'VTALRM';
	$signal_name[27] = 'PROF';
	$signal_name[28] = 'WINCH';
	$signal_name[29] = 'INFO';
}

sub find_signal
{
	my $number =  shift;

	if (@@signal_name == 0) {
		fillup_names();
	}

	return $signal_name[$number] || $number;
}

sub child_error
{
	my $error = shift // $?;

	my $extra = "";

	if ($error & 128) {
		$extra = " (core dumped)";
	}
	if ($error & 127) {
		return "killed by signal ". find_signal($error & 127).$extra;
	} else {
		return "exit(". ($error >> 8) . ")$extra";
	}
}

sub Copy
{
	require File::Copy;

	my $r = File::Copy::copy(@@_);
	if (!$r) {
		print "copy(", join(',', @@_),") failed: $!\n";
	}
	return $r;
}

sub Unlink
{
	my $verbose = shift;
	my $r = unlink @@_;
	if ($r != @@_) {
		print "rm @@_ failed: removed only $r targets, $!\n";
	} elsif ($verbose) {
		print "rm @@_\n";
	}
	return $r;
}

sub dienow
{
	my ($error, $handler) = @@_;
	if ($error) {
		if ($error =~ m/^(.*?)(?:\s+at\s+(.*)\s+line\s+(\d+)\.?)?$/o) {
			local $_ = $1;
			$FileName = $2;
			$Line = $3;
			$FullMessage = $error;

			$handler->exec($error, '', $1, $2, $3);
		} else {
			die "Fatal error: can't parse $error";
		}
	}
}

sub try(&@@)
{
	my ($try, $catch) = @@_;
	eval { &$try };
	dienow($@@, $catch);
}

sub throw
{
	croak @@_;

}

sub rethrow
{
	my $e = shift;
	die $e if $e;
}

sub catch(&)
{
		bless $_[0], "OpenBSD::Error::catch";
}

sub catchall(&)
{
	bless $_[0], "OpenBSD::Error::catchall";
}

sub rmtree
{
	my $class = shift;
	require File::Path;
	require Cwd;

	# XXX make sure we live somewhere
	Cwd::getcwd() || chdir('/');

	File::Path::rmtree(@@_);
}

package OpenBSD::Error::catch;
sub exec
{
	my ($self, $full, $e) = @@_;
	if ($e) {
		&$self;
	} else {
		die $full;
	}
}

package OpenBSD::Error::catchall;
sub exec
{
	my ($self, $full, $e) = @@_;
	&$self;
}

1;
@


1.31
log
@File::Path::rmtree is very stupid and spews out warning messages if there's
no cwd.

Well, if there's no cwd, we don't care about getting back there, so wrap
rmtree to just move to / before calling the real rmtree.
@
text
@d2 1
a2 1
# $OpenBSD$
d86 3
a88 1
		$signal_name[eval "&POSIX::$sym()"] = $1;
d118 1
a118 1
	my $error = $?;
@


1.30
log
@handle failures from ports tree with more care.
this does avoid infinite loops in case of wrong plists.
necessary since print-plist-with-depends CAN fail...
@
text
@d199 12
@


1.29
log
@initial scaffolding for @@rcscript: for now, acts like normal files,
but allow absolute pathnames (treat that as an implicit @@cwd).
@
text
@@


1.28
log
@allow say and errsay to work without parameters, as it's ways common.
create verbose_system up in state, because it makes sense without verbose.
@
text
@@


1.27
log
@whitespace cleanup
@
text
@@


1.26
log
@more printing changes.

move log operations into their own file, since they're used outside of
pkg_add/pkg_delete by pkg_check.

move all system stuff to State, so that printing can be localized/controlled.
Create primitives _print, _errprint, _fatal for overriding output, without
localization.

Accordingly, move a lot of code out of Error. We should also move Unlink and
Copy eventually.
@
text
@d2 1
a2 1
# $OpenBSD: Error.pm,v 1.25 2010/05/10 09:17:55 espie Exp $
@


1.25
log
@whitespace fixes
@
text
@d2 1
a2 1
# $OpenBSD$
d66 1
a66 2
our @@EXPORT=qw(System VSystem Copy Unlink Fatal Warn Usage set_usage
    try throw catch catchall rethrow);
a129 26
sub System
{
	my $r = system(@@_);
	if ($r != 0) {
		print "system(", join(", ", @@_), ") failed: ", child_error(),
		    "\n";
	}
	return $r;
}

sub VSystem
{
	my $verbose = shift;
	if (!$verbose) {
		&System;
	} else {
		print "Running ", join(' ', @@_);
		my $r = system(@@_);
		if ($r != 0) {
			print "... failed: ", child_error(), "\n";
		} else {
			print "\n";
		}
	}
}

a150 96
}

sub Fatal
{
	croak @@_;
}

sub Warn
{
	print STDERR @@_;
}

sub new
{
	my $class = shift;
	bless {messages=>{}, dirs_okay=>{}}, $class;
}

sub set_pkgname
{
	my ($self, $pkgname) = @@_;
	$self->{pkgname} = $pkgname;
	$self->{output} = $self->{messages}->{$pkgname} //= [];
}

sub warn
{
	&OpenBSD::Error::print;
}

sub fatal
{
	my $self = shift;
	if (defined $self->{pkgname}) {
		unshift @@_, $self->{pkgname}, ':';
	}
	croak @@_;
}

sub print
{
	my $self = shift;
	push(@@{$self->{output}}, join('', @@_));
}

sub delayed_output
{
	my $self = shift;
	for my $pkg (sort keys %{$self->{messages}}) {
		my $msgs = $self->{messages}->{$pkg};
		if (@@$msgs > 0) {
			print "--- $pkg -------------------\n";
			print @@$msgs;
		}
	}
	$self->{messages} = {};
}

sub system
{
	my $self = shift;
	if (open(my $grab, "-|", @@_)) {
		my $_;
		while (<$grab>) {
			$self->print($_);
		}
		if (!close $grab) {
		    $self->print("system(", join(", ", @@_), ") failed: $! ",
		    	child_error(), "\n");
		}
		return $?;
	} else {
		    $self->print("system(", join(", ", @@_),
		    	") was not run: $!", child_error(), "\n");
	}
}

my @@usage_line;

sub set_usage
{
	@@usage_line = @@_;
}

sub Usage
{
	my $code = 0;
	if (@@_) {
		print STDERR "$0: ", @@_, "\n";
		$code = 1;
	}
	print STDERR "Usage: ", shift(@@usage_line), "\n";
	for my $l (@@usage_line) {
		print STDERR "       $l\n";
	}
	exit($code);
@


1.24
log
@simplify using //=
@
text
@d52 1
a52 1
sub reset 
d66 1
a66 1
our @@EXPORT=qw(System VSystem Copy Unlink Fatal Warn Usage set_usage 
d123 1
a123 1
	} 
d135 1
a135 1
		print "system(", join(", ", @@_), ") failed: ", child_error(), 
d213 1
a213 1
	} 
d245 1
a245 1
		    $self->print("system(", join(", ", @@_), ") failed: $! ", 
d250 1
a250 1
		    $self->print("system(", join(", ", @@_), 
d293 1
a293 1
sub try(&@@) 
d300 1
a300 1
sub throw 
@


1.23
log
@simplify caching: return $cached->{$_} //= new_value;
remove stats
cache LibSpec as well (1000 c.53.0 !)
@
text
@d200 1
a200 4
	if (!defined $self->{messages}->{$pkgname}) {
		$self->{messages}->{$pkgname} = [];
	}
	$self->{output} = $self->{messages}->{$pkgname};
@


1.22
log
@use Carp directly, it it very inexpensive actually, since it's been rewritten
to be just a very small stub that loads Carp::Heavy on demand.
Also, stop wrapping messages in "Expected", doesn't give us anything.
Finally, make RequiredBy calls be carp, so that we actually know where they
fail...
@
text
@d27 1
a27 4
		if (!defined $self->{$sym}) {
			$self->{$sym} = &$code($self);
		}
		return $self->{$sym};
@


1.21
log
@move signal catching up, so we can clean repos and temp files at once.
Fix main program try/catch: signal message should use standard form so
it gets caught.
@
text
@d76 1
a76 1
sub Carp::croak;
d185 1
a185 2
	require Carp;
	Carp::croak "Expected: @@_";
a216 1
	require Carp;
d218 3
a220 4
		Carp::croak("Expected: ", $self->{pkgname}, ':', @@_);
	} else {
		Carp::croak("Expected: ", @@_);
	}
d286 4
a289 4
		if ($error =~ m/^(Expected\:\s+)?(.*?)(?:\s+at\s+(.*)\s+line\s+(\d+)\.?)?$/o) {
			local $_ = $2;
			$FileName = $3;
			$Line = $4;
d292 1
a292 1
			$handler->exec($error, $1, $2, $3, $4);
d308 1
a308 2
	require Carp;
	Carp::croak "Expected: @@_";
@


1.20
log
@common pattern, put it there since everything uses Error.
@
text
@d36 30
d289 1
a289 1
		if ($error =~ m/^(Expected:\s+)?(.*?)(?:\s+at\s+(.*)\s+line\s+(\d+)\.?)?$/o) {
@


1.19
log
@make these independent from Getopt, require Exporter
@
text
@d4 1
a4 1
# Copyright (c) 2004 Marc Espie <espie@@openbsd.org>
d19 16
@


1.18
log
@remove forwarders, and provide a sensible API that says what's going on
(e.g., we're logging information for later).
@
text
@d21 1
@


1.17
log
@bad espie: use strict/warnings consistently, and fix two nits and two
actual errors !
@
text
@d195 1
d200 1
a200 1
	my $state = shift;
d204 1
a204 1
			$state->print($_);
d207 1
a207 1
		    $state->print("system(", join(", ", @@_), ") failed: $! ", 
d212 1
a212 1
		    $state->print("system(", join(", ", @@_), 
@


1.16
log
@ouch, this one requires local for now
(as found out by Chris Cappuccio)
@
text
@a15 1
#
@


1.15
log
@Say goodbye to local $_
lexical scoping is so much neater (courtesy of perl 5.10)
@
text
@d243 1
a243 1
			my $_ = $2;
@


1.14
log
@add prototype for Carp::croak to prevent error under perl 5.10

feedback by espie@@, prodded by millert@@
@
text
@d2 1
a2 1
# $OpenBSD: Error.pm,v 1.13 2008/06/21 13:23:09 espie Exp $
d202 1
a202 1
		local $_;
d243 1
a243 1
			local $_ = $2;
@


1.13
log
@introduce unlink operation with nice properties
@
text
@d2 1
a2 1
# $OpenBSD$
d29 2
@


1.12
log
@print better error message if child dies... with extra dark magic to grab
signal names from POSIX.
@
text
@d23 1
a23 1
our @@EXPORT=qw(System VSystem Copy Fatal Warn Usage set_usage 
d119 12
@


1.11
log
@some minor systematic changes.
- mark all regexps I can with /o if they can be compiled once.
- turn $o->method() into $o->method
- remove unneeded prototypes
- reduce split /re/ into split "string" where possible.
@
text
@d2 1
a2 1
# $OpenBSD: Error.pm,v 1.10 2004/12/12 22:44:51 espie Exp $
d28 58
d90 2
a91 1
		print "system(", join(", ", @@_), ") failed: $?\n";
d105 1
a105 1
			print "... failed: $?\n";
d193 2
a194 1
		    $state->print("system(", join(", ", @@_), ") failed: $! $?\n");
d198 2
a199 1
		    $state->print("system(", join(", ", @@_), ") was not run: $! $?\n");
@


1.10
log
@cvs expands $OpenBSD...$, so move the variable defs up so that they don't
need a full name.
@
text
@d2 1
a2 1
# $OpenBSD: Error.pm,v 1.8 2004/12/06 12:35:36 espie Exp $
d167 1
a167 1
		if ($error =~ m/^(Expected:\s+)?(.*?)(?:\s+at\s+(.*)\s+line\s+(\d+)\.?)?$/) {
@


1.9
log
@add somewhat more regular error catching code.
@
text
@d26 2
d169 3
a171 3
			$OpenBSD::Error::FileName = $3;
			$OpenBSD::Error::Line = $4;
			$OpenBSD::Error::FullMessage = $error;
a208 2

our ($FileName, $Line, $FullMessage);
@


1.8
log
@Usage
@
text
@d2 1
a2 1
# $OpenBSD: Error.pm,v 1.7 2004/11/27 12:07:58 espie Exp $
d23 2
a24 1
our @@EXPORT=qw(System VSystem Copy Fatal Warn Usage set_usage);
d65 1
a65 1
	Carp::croak @@_;
d98 5
a102 1
	Carp::croak ($self->{pkgname}, ':', @@_);
d151 1
a151 1
		print STDERR "Error: ", @@_, "\n";
d159 67
@


1.7
log
@record sample/extra directories if !extra, so that SharedItems won't warn
if those directories are not empty...
@
text
@d2 1
a2 1
# $OpenBSD: Error.pm,v 1.6 2004/11/15 02:44:50 espie Exp $
d23 1
a23 1
our @@EXPORT=qw(System VSystem Copy Fatal Warn);
d134 22
@


1.6
log
@use Carp
@
text
@d2 1
a2 1
# $OpenBSD: Error.pm,v 1.5 2004/10/23 09:43:16 espie Exp $
d75 1
a75 1
	bless {messages=>{}}, $class;
@


1.5
log
@system() method that stores command normal output so that we can show
it at end of pkg install/deinstall...
use for @@exec/INSTALL stuff.
@
text
@d2 1
a2 1
# $OpenBSD: Error.pm,v 1.4 2004/10/23 09:27:48 espie Exp $
d63 2
a64 1
	die @@_;
d96 2
a97 1
	die ($self->{pkgname}, ':', @@_);
@


1.4
log
@store pkgname in shared items, so that delayed printing can be used
(and use it).

Optimisation: don't clone() directories
@
text
@d2 1
a2 1
# $OpenBSD: Error.pm,v 1.3 2004/10/20 11:38:57 espie Exp $
d116 16
@


1.3
log
@basic framework for delayed messages.
@
text
@d2 1
a2 1
# $OpenBSD: Error.pm,v 1.2 2004/10/04 12:12:30 espie Exp $
d110 1
a110 1
			print "$pkg -------------------\n";
@


1.2
log
@Add Fatal/Warn routines: for now, they do nothing more than die/print STDERR,
but they can get better.
@
text
@d2 1
a2 1
# $OpenBSD: Error.pm,v 1.1 2004/09/14 22:43:09 espie Exp $
d69 45
@


1.1
log
@basic error wrapper for system and such.
@
text
@d2 1
a2 1
# $OpenBSD$
d23 1
a23 1
our @@EXPORT=qw(System VSystem Copy);
d59 10
@

