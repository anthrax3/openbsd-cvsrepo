head	1.47;
access;
symbols
	OPENBSD_6_2:1.47.0.2
	OPENBSD_6_2_BASE:1.47
	OPENBSD_6_1:1.44.0.4
	OPENBSD_6_1_BASE:1.44
	OPENBSD_6_0:1.40.0.4
	OPENBSD_6_0_BASE:1.40
	OPENBSD_5_9:1.36.0.2
	OPENBSD_5_9_BASE:1.36
	OPENBSD_5_8:1.35.0.4
	OPENBSD_5_8_BASE:1.35
	OPENBSD_5_7:1.33.0.2
	OPENBSD_5_7_BASE:1.33
	OPENBSD_5_6:1.33.0.4
	OPENBSD_5_6_BASE:1.33
	OPENBSD_5_5:1.30.0.4
	OPENBSD_5_5_BASE:1.30
	OPENBSD_5_4:1.27.0.4
	OPENBSD_5_4_BASE:1.27
	OPENBSD_5_3:1.27.0.2
	OPENBSD_5_3_BASE:1.27
	OPENBSD_5_2:1.25.0.4
	OPENBSD_5_2_BASE:1.25
	OPENBSD_5_1_BASE:1.25
	OPENBSD_5_1:1.25.0.2
	OPENBSD_5_0:1.21.0.4
	OPENBSD_5_0_BASE:1.21
	OPENBSD_4_9:1.21.0.2
	OPENBSD_4_9_BASE:1.21
	OPENBSD_4_8:1.14.0.2
	OPENBSD_4_8_BASE:1.14;
locks; strict;
comment	@# @;


1.47
date	2017.08.29.14.21.18;	author espie;	state Exp;
branches;
next	1.46;
commitid	PwFezUS6evVmTZnX;

1.46
date	2017.08.04.23.35.40;	author abieber;	state Exp;
branches;
next	1.45;
commitid	HGHpBigX2qC1TDAx;

1.45
date	2017.08.03.13.08.58;	author abieber;	state Exp;
branches;
next	1.44;
commitid	xhQfHuSvUhoMvHyW;

1.44
date	2017.01.25.14.10.46;	author espie;	state Exp;
branches;
next	1.43;
commitid	hdjtOqmq5xAI0FZF;

1.43
date	2016.10.04.10.10.19;	author espie;	state Exp;
branches;
next	1.42;
commitid	dtG19gVXVcVmDtwG;

1.42
date	2016.10.03.10.38.30;	author espie;	state Exp;
branches;
next	1.41;
commitid	FbpYyfNs7DAAI0CB;

1.41
date	2016.07.27.12.58.21;	author espie;	state Exp;
branches;
next	1.40;
commitid	bXaYV61BErAtpI1K;

1.40
date	2016.06.28.17.35.34;	author espie;	state Exp;
branches;
next	1.39;
commitid	Awc8EgCqZe5NIOtq;

1.39
date	2016.06.28.15.38.36;	author espie;	state Exp;
branches;
next	1.38;
commitid	UBYEvJt8oXHTeTWd;

1.38
date	2016.06.22.12.18.21;	author espie;	state Exp;
branches;
next	1.37;
commitid	ZG9DrdvTd9x9wf5Y;

1.37
date	2016.05.13.00.22.50;	author espie;	state Exp;
branches;
next	1.36;
commitid	99u0ruWTuU30u4oJ;

1.36
date	2015.10.07.17.52.38;	author jmc;	state Exp;
branches;
next	1.35;
commitid	wtnyUwU0yuhbcppY;

1.35
date	2015.04.06.12.19.35;	author espie;	state Exp;
branches;
next	1.34;
commitid	c4trMcymjHQjtZ1V;

1.34
date	2015.04.06.11.14.58;	author espie;	state Exp;
branches;
next	1.33;
commitid	xhSPS3BqX89repUR;

1.33
date	2014.07.18.16.57.41;	author espie;	state Exp;
branches;
next	1.32;
commitid	ehPpKyf327BLIPRY;

1.32
date	2014.07.08.16.45.44;	author zhuk;	state Exp;
branches;
next	1.31;
commitid	McfOkqnJyEeH9gb2;

1.31
date	2014.03.18.18.53.29;	author espie;	state Exp;
branches;
next	1.30;

1.30
date	2014.01.09.20.20.01;	author espie;	state Exp;
branches;
next	1.29;

1.29
date	2014.01.09.13.40.05;	author espie;	state Exp;
branches;
next	1.28;

1.28
date	2014.01.07.13.52.43;	author espie;	state Exp;
branches;
next	1.27;

1.27
date	2013.01.18.21.19.36;	author espie;	state Exp;
branches;
next	1.26;

1.26
date	2013.01.18.13.22.54;	author espie;	state Exp;
branches;
next	1.25;

1.25
date	2011.11.24.19.47.11;	author espie;	state Exp;
branches;
next	1.24;

1.24
date	2011.11.21.14.38.43;	author espie;	state Exp;
branches;
next	1.23;

1.23
date	2011.11.20.10.52.14;	author espie;	state Exp;
branches;
next	1.22;

1.22
date	2011.08.18.07.55.26;	author espie;	state Exp;
branches;
next	1.21;

1.21
date	2011.01.10.13.04.38;	author espie;	state Exp;
branches;
next	1.20;

1.20
date	2011.01.03.19.33.46;	author espie;	state Exp;
branches;
next	1.19;

1.19
date	2010.12.29.13.03.05;	author espie;	state Exp;
branches;
next	1.18;

1.18
date	2010.12.24.09.04.14;	author espie;	state Exp;
branches;
next	1.17;

1.17
date	2010.12.18.10.17.31;	author espie;	state Exp;
branches;
next	1.16;

1.16
date	2010.12.05.09.41.55;	author espie;	state Exp;
branches;
next	1.15;

1.15
date	2010.10.27.14.35.56;	author espie;	state Exp;
branches;
next	1.14;

1.14
date	2010.07.26.07.28.29;	author espie;	state Exp;
branches;
next	1.13;

1.13
date	2010.07.03.11.36.17;	author espie;	state Exp;
branches;
next	1.12;

1.12
date	2010.06.30.10.51.04;	author espie;	state Exp;
branches;
next	1.11;

1.11
date	2010.06.30.10.41.42;	author espie;	state Exp;
branches;
next	1.10;

1.10
date	2010.06.30.10.35.24;	author espie;	state Exp;
branches;
next	1.9;

1.9
date	2010.06.25.14.32.18;	author espie;	state Exp;
branches;
next	1.8;

1.8
date	2010.06.25.14.14.09;	author espie;	state Exp;
branches;
next	1.7;

1.7
date	2010.06.25.14.02.07;	author espie;	state Exp;
branches;
next	1.6;

1.6
date	2010.06.25.13.03.59;	author espie;	state Exp;
branches;
next	1.5;

1.5
date	2010.06.25.10.22.56;	author espie;	state Exp;
branches;
next	1.4;

1.4
date	2010.06.09.11.57.21;	author espie;	state Exp;
branches;
next	1.3;

1.3
date	2010.06.09.10.25.17;	author espie;	state Exp;
branches;
next	1.2;

1.2
date	2010.06.09.07.26.01;	author espie;	state Exp;
branches;
next	1.1;

1.1
date	2010.06.04.13.19.39;	author espie;	state Exp;
branches;
next	;


desc
@@


1.47
log
@avoid double search. Fix abieber's commit vaguely. (todo: speed-ups)
@
text
@#! /usr/bin/perl
# ex:ts=8 sw=4:
# $OpenBSD: PkgInfo.pm,v 1.46 2017/08/04 23:35:40 abieber Exp $
#
# Copyright (c) 2003-2014 Marc Espie <espie@@openbsd.org>
#
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

use strict;
use warnings;

use OpenBSD::State;

package OpenBSD::PackingElement;
sub dump_file
{
}

sub hunt_file
{
}

sub sum_up
{
	my ($self, $rsize) = @@_;
	if (defined $self->{size}) {
		$$rsize += $self->{size};
	}
}

package OpenBSD::PackingElement::FileBase;
sub dump_file
{
	my ($item, $opt_K) = @@_;
	if ($opt_K) {
		print '@@', $item->keyword, " ";
	}
	print $item->fullname, "\n";
}

package OpenBSD::PackingElement::FileObject;
sub hunt_file
{
	my ($item, $h, $pkgname, $l) = @@_;
	my $fname = $item->fullname;
	if (defined $h->{$fname}) {
		push(@@{$h->{$fname}}, $pkgname);
		push(@@$l, $pkgname);
	}
}

package OpenBSD::PkgInfo::State;
our @@ISA = qw(OpenBSD::State);

use OpenBSD::PackageInfo;

sub lock
{
	my $state = shift;
	return if $state->{locked};
	return if $state->{subst}->value('nolock');
	lock_db(1, $state->opt('q') ? undef : $state);
	$state->{locked} = 1;
}

sub banner
{
	my ($state, @@args) = @@_;
	return if $state->opt('q');
	$state->print("#1", $state->opt('l')) if $state->opt('l');
	$state->say(@@args);
}

sub header
{
	my ($state, $handle) = @@_;
	return if $state->{terse} || $state->opt('q');
	my $url = $handle->url;
	return if $state->{header_done}{$url};
	$state->{header_done}{$url} = 1;
	$state->banner("Information for #1\n", $url);
}

sub footer
{
	my ($state, $handle) = @@_;
	return if $state->opt('q') || $state->{terse};
	return unless $state->{header_done}{$handle->url};
	if ($state->opt('l')) {
		$state->say("#1", $state->opt('l'));
	} else {
		$state->say;
	}
}

sub printfile
{
	my ($state, $filename) = @@_;

	open my $fh, '<', $filename or return;
	while(<$fh>) {
		chomp;
		$state->say("#1", $_);
	}
	close $fh;
	$state->say;
}

sub printfile_sorted
{
	my ($state, $filename) = @@_;

	open my $fh, '<', $filename or return;
	my @@lines = (<$fh>);
	close $fh;
	foreach my $line (sort @@lines) {
		chomp $line;
		$state->say("#1", $line);
	}
	$state->say;
}

sub print_description
{
	my ($state, $dir) = @@_;

	open my $fh, '<', $dir.DESC or return;
	$_ = <$fh>; # zap COMMENT
	while(<$fh>) {
		chomp;
		$state->say("#1", $_);
	}
	close $fh;
	$state->say;
}

sub hasanyopt
{
	my ($self, $string) = @@_;
	for my $i (split //, $string) {
		if ($self->opt($i)) {
			return 1;
		}
	}
	return 0;
}

sub setopts
{
	my ($self, $string) = @@_;
	for my $i (split //, $string) {
		$self->{opt}{$i} = 1;
	}
}

sub log
{
	my $self = shift;
	if (@@_ == 0) {
		return $self;
	} else {
		$self->say(@@_);
	}
}

package OpenBSD::PkgInfo;
use OpenBSD::PackageInfo;
use OpenBSD::PackageName;
use OpenBSD::Getopt;
use OpenBSD::Error;


my $total_size = 0;
my $pkgs = 0;

sub find_pkg_in
{
	my ($self, $state, $repo, $pkgname, $code) = @@_;

	if (OpenBSD::PackageName::is_stem($pkgname)) {
		require OpenBSD::Search;
		my $l = $repo->match_locations(OpenBSD::Search::Stem->new($pkgname));
		if (@@$l != 0) {
			for my $pkg (sort {$a->name cmp $b->name} @@$l) {
				&$code($pkg->name, $pkg);
				$pkg->close_now;
				$pkg->wipe_info;
			}
			return 1;
		}
	}
	# okay, so we're actually a spec in disguise
	if ($pkgname =~ m/[\*\<\>\=]/) {
		require OpenBSD::Search;
		my $s = OpenBSD::Search::PkgSpec->new($pkgname);
		if (!$s->is_valid) {
			$state->errsay("Invalid spec: #1", $pkgname);
			return 0;
		}
		my $r = $repo->match_locations($s);
		if (@@$r == 0) {
			return 0;
		} else {
			for my $pkg (@@$r) {
				&$code($pkg->name, $pkg);
				$pkg->close_now;
				$pkg->wipe_info;
			}
			return 1;
		}
	} else {
		my $pkg = $repo->find($pkgname);
		if (defined $pkg) {
			&$code($pkgname, $pkg);
			$pkg->close_now;
			$pkg->wipe_info;
			return 1;
		}
		return 0;
	}
}

sub find_pkg
{
	my ($self, $state, $pkgname, $code) = @@_;

	if ($self->find_pkg_in($state, $state->repo->installed, $pkgname,
	    $code)) {
		return 1;
	}
	my $repo;

	if ($pkgname =~ m/[\/\:]/o) {
		($repo, $pkgname) = $state->repo->path_parse($pkgname);
	} else {
		$repo = $state->repo;
	}

	return $self->find_pkg_in($state, $repo, $pkgname, $code);
}

sub get_line
{
	open my $fh, '<', shift or return "";
	my $c = <$fh>;
	chomp($c);
	close $fh;
	return $c;
}

sub get_comment
{
	my $d = shift;
	return get_line($d.DESC);
}

sub find_by_spec
{
	my ($pat, $state) = @@_;

	require OpenBSD::Search;

	my $s = OpenBSD::Search::PkgSpec->new($pat);
	if (!$s->is_valid) {
		$state->errsay("Invalid spec: #1", $pat);
		return ();
	} else {
		my $r = $state->repo->installed->match_locations($s);

		return sort {$a->name cmp $b->name} @@$r;
	}
}

sub filter_files
{
	my ($self, $state, $search, @@args) = @@_;
	require OpenBSD::PackingList;

	my @@k = ();
	for my $file (keys %$search) {
		my $k = $file;
		if ($file =~ m|^.*/(.*?)$|) {
			$k = $1;
		}
		push(@@k, quotemeta($k));
	}
	my $re = join('|', @@k);

	my @@result = ();
	for my $arg (@@args) {
		$self->find_pkg($state, $arg,
		    sub {
		    	my ($pkgname, $handle) = @@_;

			if (-f $handle->info.CONTENTS) {
				my $maybe = 0;
				open(my $fh, '<', $handle->info.CONTENTS);
				while (<$fh>) {
					if (m/$re/) {
						$maybe = 1;
						last;
					}
				}
				close($fh);
				return if !$maybe;
			}
			my $plist = $handle->plist(\&OpenBSD::PackingList::FilesOnly);

			$plist->hunt_file($search, $pkgname, \@@result);
		    });
	}
	return @@result;
}

sub manual_filter
{
	my ($self, $state, @@args) = @@_;
	require OpenBSD::PackingList;

	my @@result = ();
	for my $arg (@@args) {
		$self->find_pkg($state, $arg,
		    sub {
		    	my ($pkgname, $handle) = @@_;

			my $plist = $handle->plist(\&OpenBSD::PackingList::ConflictOnly);

			push(@@result, $pkgname) if $plist->has('manual-installation');
		    });
	}
	return @@result;
}

my $path_info;

sub add_to_path_info
{
	my ($path, $pkgname) = @@_;

	push(@@{$path_info->{$path}}, $pkgname);
}

sub find_by_path
{
	my $pat = shift;

	if (!defined $path_info) {
		require OpenBSD::PackingList;

		$path_info = {};
		for my $pkg (installed_packages(1)) {
			my $plist =
				OpenBSD::PackingList->from_installation($pkg,
				    \&OpenBSD::PackingList::ExtraInfoOnly);
			next if !defined $plist;
			if (defined $plist->fullpkgpath) {
				add_to_path_info($plist->fullpkgpath,
				    $plist->pkgname);
			}
			if ($plist->has('pkgpath')) {
				for my $p (@@{$plist->{pkgpath}}) {
					add_to_path_info($p->name,
					    $plist->pkgname);
				}
			}
		}
	}
	if (defined $path_info->{$pat}) {
		return @@{$path_info->{$pat}};
	} else {
		return ();
	}
}

sub print_info
{
	my ($self, $state, $pkg, $handle) = @@_;
	unless (defined $handle) {
		$state->errsay("Error printing info for #1: no info ?", $pkg);
		return;
	}
	my $plist;
	if ($state->opt('z')) {
		$plist = $handle->plist(\&OpenBSD::PackingList::ExtraInfoOnly);
		# firmware don't belong
		if ($plist->has('firmware')) {
			return;
		}
		my $name = OpenBSD::PackageName->new_from_string($plist->pkgname);
		my $stem = $name->{stem};
		my $compose = $stem."--".join('-', sort keys %{$name->{flavors}});
		if ($plist->has('is-branch')) {
			if ($plist->fullpkgpath =~ m/\/([^\/]+?)(,.*)?$/) {
				$compose .= "%$1";
			}
		}
		$state->say("#1", $compose);
	} elsif ($state->opt('I')) {
		if ($state->opt('q')) {
			$state->say("#1", $pkg);
		} else {
			my $l = 20 - length($pkg);
			$l = 1 if $l <= 0;
			$state->say("#1#2#3", $pkg, " "x$l,
			    get_comment($handle->info));
		}
	} else {
		if ($state->opt('c')) {
			$state->header($handle);
			$state->banner("Comment:");
			$state->say("#1\n", get_comment($handle->info));
		}
		if ($state->opt('R') && -f $handle->info.REQUIRED_BY) {
			$state->header($handle);
			$state->banner("Required by:");
			$state->printfile_sorted($handle->info.REQUIRED_BY);
		}
		if ($state->opt('d')) {
			$state->header($handle);
			$state->banner("Description:");
			$state->print_description($handle->info);
		}
		if ($state->opt('M') && -f $handle->info.DISPLAY) {
			$state->header($handle);
			$state->banner("Install notice:");
			$state->printfile($handle->info.DISPLAY);
		}
		if ($state->opt('U') && -f $handle->info.UNDISPLAY) {
			$state->header($handle);
			$state->banner("Deinstall notice:");
			$state->printfile($handle->info.UNDISPLAY);
		}
		my $needplist = $state->hasanyopt('fsSC');
		if ($needplist || $state->opt('L')) {
			require OpenBSD::PackingList;

			if ($needplist) {
				$plist //= $handle->plist;
			} else {
				$plist //= $handle->plist(\&OpenBSD::PackingList::FilesOnly);
			}
			$state->fatal("bad packing-list for #1", $handle->url)
			    unless defined $plist;
		}
		if ($state->opt('L')) {
			$state->header($handle);
			$state->banner("Files:");
			$plist->dump_file($state->opt('K'));
			$state->say;
		}
		if ($state->opt('C')) {
			$state->header($handle);
			if ($plist->is_signed) {
				my $sig = $plist->get('digital-signature');
				if ($sig->{key} eq 'x509') {
					require OpenBSD::x509;
					$state->banner("Certificate info:");
					OpenBSD::x509::print_certificate_info($plist);
				} elsif ($sig->{key} eq 'signify' ||
				    $sig->{key} eq 'signify2') {
					$state->say("reportedly signed by #1",
					    $plist->get('signer')->name);
				}
			} else {
				$state->banner("No digital signature");
			}
		}
		if ($state->opt('s')) {
			$state->header($handle);
			my $size = 0;
			$plist->sum_up(\$size);
			$state->say(
			    ($state->opt('q') ? "#1": "Size: #1"), $size);
			$total_size += $size;
			$pkgs++;
		}
		if ($state->opt('S')) {
			$state->header($handle);
			$state->say(
			    ($state->opt('q') ? "#1": "Signature: #1"),
			    $plist->signature->string);
		}
		if ($state->opt('P')) {
			require OpenBSD::PackingList;

			my $plist = $handle->plist(
			    \&OpenBSD::PackingList::ExtraInfoOnly);
			$state->header($handle);
			$state->banner("Pkgpath:");
			if (defined $plist->fullpkgpath) {
				$state->say("#1", $plist->fullpkgpath);
			} else {
				$state->errsay("#1 has no FULLPKGPATH", $plist->pkgname);
				$state->say;
			}
		}

		if ($state->opt('f')) {
			$state->header($handle);
			$state->banner("Packing-list:");
			$plist->write(\*STDOUT);
			$state->say;
		}
		$state->footer($handle);
	}
}

sub parse_and_run
{
	my ($self, $cmd) = @@_;
	my $exit_code = 0;
	my @@sought_files;
	my $error_e = 0;
	my $state = OpenBSD::PkgInfo::State->new($cmd);
	my @@extra;
	$state->{opt} =
	    {
	    	'e' =>
		    sub {
			    my $pat = shift;
			    my @@list;
			    if ($pat =~ m/\//o) {
				    $state->lock;
				    @@list = find_by_path($pat);
				    push(@@ARGV, @@list);
			    } else {
				    @@list = find_by_spec($pat, $state);
				    push(@@extra, @@list);
			    }
			    if (@@list == 0) {
				    $exit_code = 1;
				    $error_e = 1;
			    }
			    $state->{terse} = 1;
		    },
	     'E' =>
		    sub {
			    require File::Spec;

			    push(@@sought_files, File::Spec->rel2abs(shift));

		    }
	    };
	$state->{no_exports} = 1;
	$state->handle_options('cCdfF:hIKLmPQ:qr:RsSUe:E:Ml:aAtz',
	    '[-AaCcdfIKLMmPqRSstUvz] [-D nolock][-E filename] [-e pkg-name] ',
	    '[-l str] [-Q query] [-r pkgspec] [pkg-name ...]');

	if ($state->opt('r')) {

		require OpenBSD::PkgSpec;

		my $pattern = $state->opt('r');
		my $s = OpenBSD::PkgSpec->new($pattern);
		if (!$s->is_valid) {
			$state->errsay("Invalid pkgspec: #1", $pattern);
			return 1;
		}
		my @@l = $s->match_ref(\@@ARGV);
		unless ($state->opt('q')) {
			$state->say("Pkgspec #1 matched #2", $pattern,
			    join(' ', @@l));
		}
		if (@@l == 0) {
			$exit_code += 2;
		}
		if (@@extra == 0) {
			return $exit_code;
		} else {
			@@ARGV = ();
		}
	}

	$state->lock;

	my $nonames = @@ARGV == 0 && @@extra == 0;

	unless ($state->hasanyopt('cMUdfILRsSP') || $state->{terse}) {
		if ($nonames) {
			$state->setopts('Ia');
		} else {
			$state->setopts('cdMR');
		}
	}

	if ($state->opt('Q')) {
		require OpenBSD::Search;

		print "PKG_PATH=$ENV{PKG_PATH}\n" if $state->verbose;
		my $partial = OpenBSD::Search::PartialStem->new($state->opt('Q'));
		my $r = $state->repo->match_locations($partial);

		for my $pkg (sort {$a->name cmp $b->name} @@$r) {
			my $p = $pkg->name;
			if ($state->hasanyopt('cdfMqs')) {
				$self->print_info($state, $p, $pkg);
			} else {
				$state->say(
			    	    is_installed($p) ? "#1 (installed)" : "#1", $p);
			}
		}

		return 0;
	}

	if ($state->verbose) {
		$state->setopts('cdfMURsS');
	}

	if ($state->opt('K') && !$state->opt('L')) {
		$state->usage("-K only makes sense with -L");
	}

	my $all = $state->opt('a') || $state->opt('A');

	if ($nonames && !$all) {
		$state->usage("Missing package name(s)") unless $state->{terse} || $state->opt('q');
	}

	if (!$nonames && $state->hasanyopt('aAtm')) {
		$state->usage("Can't specify package name(s) with [-aAtm]");
	}


	if ($nonames && !$error_e) {
		@@ARGV = sort(installed_packages($state->opt('A') ? 0 : 1));
		if ($state->opt('t')) {
			require OpenBSD::RequiredBy;
			@@ARGV = grep { OpenBSD::RequiredBy->new($_)->list == 0 } @@ARGV;
		}
	}

	if (@@sought_files) {
		my %hash = map { ($_, []) }  @@sought_files;
		@@ARGV = $self->filter_files($state, \%hash, @@ARGV);
		for my $f (@@sought_files) {
			my $l = $hash{$f};
			if (@@$l) {
				$state->say("#1: #2", $f, join(',', @@$l))
				    unless $state->opt('q');
			} else {
				$exit_code = 1;
			}
		}
	}

	if ($state->opt('m')) {
		@@ARGV = $self->manual_filter($state, @@ARGV);
	}

	for my $pkg (@@ARGV) {
		if ($state->{terse}) {
			$state->banner('#1', $pkg);
		}
		if (!$self->find_pkg($state, $pkg,
		    sub {
			$self->print_info($state, @@_);
		})) {
			$exit_code = 1;
		}
	}
	for my $extra (@@extra) {
		if ($state->{terse}) {
			$state->banner('#1', $extra->url);
		}
		$self->print_info($state, $extra->url, $extra);
	}

	if ($pkgs > 1) {
		$state->say("Total size: #1", $total_size);
	}
	return $exit_code;
}

1;
@


1.46
log
@Only call find_pkg when we are using other options with -Q.

This resolves the speed issues Michael Reed <michael@@michaelreed.io>
reported that were introduced by my changes in 1.45.

OK landry@@
@
text
@d3 1
a3 1
# $OpenBSD: PkgInfo.pm,v 1.45 2017/08/03 13:08:58 abieber Exp $
d603 2
a604 1
		for my $p (sort map {$_->name} @@$r) {
d606 1
a606 4
				$self->find_pkg($state, $p,
			    	    sub {
					$self->print_info($state, @@_);
			    	    });
@


1.45
log
@Make -Q work play nice with other flags. This makes things like:
"pkg_info -Q quake -d" function as expected.

OK landry@@
@
text
@d3 1
a3 1
# $OpenBSD: PkgInfo.pm,v 1.44 2017/01/25 14:10:46 espie Exp $
d409 2
a410 3
		if ($state->opt('Q')) {
			$state->say(
			    is_installed($pkg) ? "#1 (installed)" : "#1", $pkg);
d412 4
a415 8
			if ($state->opt('q')) {
				$state->say("#1", $pkg);
			} else {
				my $l = 20 - length($pkg);
				$l = 1 if $l <= 0;
				$state->say("#1#2#3", $pkg, " "x$l,
				    get_comment($handle->info));
		    	}
d604 9
a612 4
			$self->find_pkg($state, $p,
			    sub {
				$self->print_info($state, @@_);
			    });
@


1.44
log
@In some cases, pkg_info -e spec would display the spec instead of the
actual pkg name as intended.

(forgot who reported that one, sorry)
@
text
@d3 1
a3 1
# $OpenBSD: PkgInfo.pm,v 1.43 2016/10/04 10:10:19 espie Exp $
d409 3
a411 2
		if ($state->opt('q')) {
			$state->say("#1", $pkg);
d413 8
a420 4
			my $l = 20 - length($pkg);
			$l = 1 if $l <= 0;
			$state->say("#1#2#3", $pkg, " "x$l,
			    get_comment($handle->info));
d476 1
a476 1
					$state->say("reportedly signed by #1", 
d609 4
a612 2
			$state->say(
			    is_installed($p) ? "#1 (installed)" : "#1", $p);
@


1.43
log
@remove may_check_data logic, since signatures are now handled externally
@
text
@d3 1
a3 1
# $OpenBSD: PkgInfo.pm,v 1.42 2016/10/03 10:38:30 espie Exp $
d215 1
a215 1
				&$code($pkgname, $pkg);
@


1.42
log
@report signify2 as well
@
text
@d3 1
a3 1
# $OpenBSD: PkgInfo.pm,v 1.41 2016/07/27 12:58:21 espie Exp $
a384 25
sub may_check_data
{
	my ($self, $handle, $pkgname, $state, $r) = @@_;
	# don't check installed packages
	return if  $handle->trusted || $handle->{checked};
	require OpenBSD::PackingList;
	$$r //= $handle->plist;
	if ($$r->is_signed) {
		if ($state->defines('nosig')) {
			$state->errsay("NOT CHECKING DIGITAL SIGNATURE FOR #1",
			    $pkgname);
		} else {
			if (!$$r->check_signature($state)) {
				$state->fatal("Couldn't check signature for #1", $pkgname);
			}
		}
	}
	for my $name (OpenBSD::PackageInfo::info_names()) {
		if ($$r->has($name)) {
			$$r->get($name)->may_verify_digest($state);
		}
	}
	$handle->{checked} = 1;
}

a411 1
			$self->may_check_data($handle, $pkg, $state, \$plist);
a418 1
			$self->may_check_data($handle, $pkg, $state, \$plist);
a428 1
			$self->may_check_data($handle, $pkg, $state, \$plist);
a433 1
			$self->may_check_data($handle, $pkg, $state, \$plist);
a438 1
			$self->may_check_data($handle, $pkg, $state, \$plist);
a446 1
			$self->may_check_data($handle, $pkg, $state, \$plist);
@


1.41
log
@don't include firmwares in the fuzzy auto-reinstall list
@
text
@d3 1
a3 1
# $OpenBSD: PkgInfo.pm,v 1.40 2016/06/28 17:35:34 espie Exp $
d500 2
a501 1
				} elsif ($sig->{key} eq 'signify') {
@


1.40
log
@oops, $pkg can be more than a pkgname. We have the right information
in the plist, so use it instead.
@
text
@d3 1
a3 1
# $OpenBSD: PkgInfo.pm,v 1.39 2016/06/28 15:38:36 espie Exp $
d420 4
@


1.39
log
@option -z that uses is-branch info to produce "complete"
stem--[flavor][%branch] listing.
feedback and suggestions semarie@@
@
text
@d3 1
a3 1
# $OpenBSD: PkgInfo.pm,v 1.38 2016/06/22 12:18:21 espie Exp $
d420 1
a420 1
		my $name = OpenBSD::PackageName->new_from_string($pkg);
@


1.38
log
@have a consistent exit code when looking for stuff
@
text
@d3 1
a3 1
# $OpenBSD: PkgInfo.pm,v 1.37 2016/05/13 00:22:50 espie Exp $
d418 12
a429 1
	if ($state->opt('I')) {
d581 2
a582 2
	$state->handle_options('cCdfF:hIKLmPQ:qr:RsSUe:E:Ml:aAt',
	    '[-AaCcdfIKLMmPqRSstUv] [-D nolock][-E filename] [-e pkg-name] ',
@


1.37
log
@add a stub log for signify, problem noticed by tedu
@
text
@d3 1
a3 1
# $OpenBSD: PkgInfo.pm,v 1.36 2015/10/07 17:52:38 jmc Exp $
d239 1
a239 1
		return;
d249 1
a249 1
	$self->find_pkg_in($state, $repo, $pkgname, $code);
d675 1
a675 1
		$self->find_pkg($state, $pkg,
d678 3
a680 1
		});
@


1.36
log
@"..." implies optional, so no need for []; from michael reed
@
text
@d3 1
a3 1
# $OpenBSD: PkgInfo.pm,v 1.35 2015/04/06 12:19:35 espie Exp $
d166 10
d398 1
a398 1
				$state->fatal("#1 is corrupted", $pkgname);
@


1.35
log
@don't check this twice.
@
text
@d3 1
a3 1
# $OpenBSD: PkgInfo.pm,v 1.34 2015/04/06 11:14:58 espie Exp $
d562 1
a562 1
	    '[-l str] [-Q query] [-r pkgspec] [pkg-name] [...]');
@


1.34
log
@make pkg_info run slightly slower on distant packages, but do check that
the info is signed and checked.

after remarks from tedu@@...
@
text
@d3 1
a3 1
# $OpenBSD: PkgInfo.pm,v 1.33 2014/07/18 16:57:41 espie Exp $
d379 1
a379 1
	return if  $handle->trusted;
d397 1
@


1.33
log
@fix sorted output
@
text
@d3 1
a3 1
# $OpenBSD: PkgInfo.pm,v 1.32 2014/07/08 16:45:44 zhuk Exp $
d375 24
d406 1
d411 1
d419 1
d430 1
d436 1
d442 1
a446 1
		my $plist;
d451 1
d453 1
a453 1
				$plist = $handle->plist;
d455 1
a455 1
				$plist = $handle->plist(\&OpenBSD::PackingList::FilesOnly);
@


1.32
log
@Prettify the list of "required by" package names by sorting it.

okay espie@@
@
text
@d3 1
a3 1
# $OpenBSD: PkgInfo.pm,v 1.31 2014/03/18 18:53:29 espie Exp $
d127 2
a128 2
		chomp;
		$state->say("#1", $_);
@


1.31
log
@remove $_ usage that warns under perl 5.18
@
text
@d3 1
a3 1
# $OpenBSD: PkgInfo.pm,v 1.30 2014/01/09 20:20:01 espie Exp $
d119 14
d400 1
a400 1
			$state->printfile($handle->info.REQUIRED_BY);
@


1.30
log
@bump copyright to 2014
@
text
@d3 1
a3 1
# $OpenBSD: PkgInfo.pm,v 1.29 2014/01/09 13:40:05 espie Exp $
a108 1
	my $_;
a121 1
	my $_;
@


1.29
log
@-C was useless with signify, report @@signer identity instead (prepend
"reportedly" to make tedu happy :) )
@
text
@d3 1
a3 1
# $OpenBSD: PkgInfo.pm,v 1.28 2014/01/07 13:52:43 espie Exp $
d5 1
a5 1
# Copyright (c) 2003-2010 Marc Espie <espie@@openbsd.org>
@


1.28
log
@scrape support for old +COMMENT file.
8 years of backward compatibility is long enough... :)
@
text
@d3 1
a3 1
# $OpenBSD: PkgInfo.pm,v 1.27 2013/01/18 21:19:36 espie Exp $
d427 9
a435 4

				require OpenBSD::x509;
				$state->banner("Certificate info:");
				OpenBSD::x509::print_certificate_info($plist);
@


1.27
log
@much faster -E: try a sneak peek at the 'raw' contents file.
if it doesn't contain the last part of the filename, then we don't even
need to parse the plist...

idea prompted by a chance remark from Vadim.
@
text
@d3 1
a3 1
# $OpenBSD: PkgInfo.pm,v 1.26 2013/01/18 13:22:54 espie Exp $
d126 1
a126 1
	$_ = <$fh> unless -f $dir.COMMENT;
d242 1
a242 1
	return get_line(-f $d.COMMENT? $d.COMMENT : $d.DESC);
@


1.26
log
@move lock down: we don't really need to lock to match the directory
@
text
@d3 1
a3 1
# $OpenBSD$
d267 10
d283 12
@


1.25
log
@allow code to proceed if -e + -r.
@
text
@d3 1
a3 1
# $OpenBSD: PkgInfo.pm,v 1.24 2011/11/21 14:38:43 espie Exp $
a466 1
			    $state->lock;
d468 1
@


1.24
log
@exit code of 1 for -e errors, 2 for -r errors... combine as 3.
-> allows to run one pkg_info and disambiguate both kinds of errors.
@
text
@d3 1
a3 1
# $OpenBSD: PkgInfo.pm,v 1.23 2011/11/20 10:52:14 espie Exp $
d509 4
a512 1
		if (@@l != 0) {
d515 1
a515 1
			return $exit_code + 2;
a516 1

@


1.23
log
@for the -r option, if we already set an error code (like in -e), reuse that.
allows pkg_info -e 'gettext->=0.20' -r 'gettext->=0.10.38' gettext-0.18.1p0
in one go.
@
text
@d3 1
a3 1
# $OpenBSD: PkgInfo.pm,v 1.22 2011/08/18 07:55:26 espie Exp $
d512 1
a512 1
			return 1;
@


1.22
log
@spacing
@
text
@d3 1
a3 1
# $OpenBSD$
d510 1
a510 1
			return 0;
@


1.21
log
@have "non quiet" mode for pkg_info -r show something...
postpone locking: we don't need any locks for pkg_info -r.
@
text
@d3 1
a3 1
# $OpenBSD: PkgInfo.pm,v 1.20 2011/01/03 19:33:46 espie Exp $
d506 1
a506 1
			$state->say("Pkgspec #1 matched #2", $pattern, 
d514 1
a514 1
		
@


1.20
log
@make it possible to check for a pkgspec by name, without looking at installed
stuff.
@
text
@d3 1
a3 1
# $OpenBSD: PkgInfo.pm,v 1.19 2010/12/29 13:03:05 espie Exp $
a493 2
	$state->lock;

d498 2
a499 1
		my $s = OpenBSD::PkgSpec->new($state->opt('r'));
d501 1
a501 1
			$state->errsay("Invalid spec: #1", $state->opt('r'));
d504 6
a509 1
		if ($s->match_ref(\@@ARGV) != 0) {
d516 3
@


1.19
log
@more stuff that uses print directly dies
@
text
@d3 1
a3 1
# $OpenBSD: PkgInfo.pm,v 1.18 2010/12/24 09:04:14 espie Exp $
d490 1
a490 1
	$state->handle_options('cCdfF:hIKLmPQ:qRsSUe:E:Ml:aAt',
d492 1
a492 1
	    '[-l str] [-Q query] [pkg-name] [...]');
d496 16
@


1.18
log
@handle failures from ports tree with more care.
this does avoid infinite loops in case of wrong plists.
necessary since print-plist-with-depends CAN fail...
@
text
@d3 1
a3 1
# $OpenBSD$
d72 1
a72 1
	lock_db(1, $state->opt('q'));
@


1.17
log
@go thru state for printing (prodded by landry@@)
@
text
@d3 1
a3 1
# $OpenBSD: PkgInfo.pm,v 1.16 2010/12/05 09:41:55 espie Exp $
@


1.16
log
@tweak the framework so that individual modules don't exist and return
the exit code upstream instead.
this simplifies the task of people who want to reuse it, as noted by
landry@@
@
text
@d3 1
a3 1
# $OpenBSD: PkgInfo.pm,v 1.15 2010/10/27 14:35:56 espie Exp $
d185 1
a185 1
			print STDERR "Invalid spec: $pkgname\n";
@


1.15
log
@initial scaffolding for @@rcscript: for now, acts like normal files,
but allow absolute pathnames (treat that as an implicit @@cwd).
@
text
@d3 1
a3 1
# $OpenBSD$
d518 1
a518 1
		exit 0;
d585 1
a585 1
	exit($exit_code);
@


1.14
log
@typo (canacar@@)
@
text
@d3 1
a3 1
# $OpenBSD: PkgInfo.pm,v 1.13 2010/07/03 11:36:17 espie Exp $
@


1.13
log
@string comparison (noticed by landry)
@
text
@d3 1
a3 1
# $OpenBSD: PkgInfo.pm,v 1.12 2010/06/30 10:51:04 espie Exp $
d522 1
a522 1
		$state->setops('cdfMURsS');
@


1.12
log
@allow say and errsay to work without parameters, as it's ways common.
create verbose_system up in state, because it makes sense without verbose.
@
text
@d3 1
a3 1
# $OpenBSD$
d258 1
a258 1
		return sort {$a->name <=> $b->name} @@$r;
@


1.11
log
@whitespace cleanup
@
text
@d102 1
a102 1
		$state->say("");
d117 1
a117 1
	$state->say('');
d132 1
a132 1
	$state->say('');
d400 1
a400 1
			$state->say('');
d439 1
a439 1
				$state->say("");
d447 1
a447 1
			$state->say('');
@


1.10
log
@pass state along to find_by_spec, clean up error messages.
Simplify PkgLocator/PkgRepo access with new API
@
text
@@


1.9
log
@minor cleanups
@
text
@d3 1
a3 1
# $OpenBSD: PkgInfo.pm,v 1.8 2010/06/25 14:14:09 espie Exp $
a213 1
	require OpenBSD::PackageRepository::Installed;
d215 1
a215 1
	if ($self->find_pkg_in($state, OpenBSD::PackageRepository::Installed->new, $pkgname,
a218 2
	require OpenBSD::PackageLocator;

d222 1
a222 2
		($repo, $pkgname) =
		    OpenBSD::PackageLocator->new($state)->path_parse($pkgname);
d224 1
a224 1
		$repo = 'OpenBSD::PackageLocator';
d247 1
a247 1
	my $pat = shift;
a249 1
	require OpenBSD::PackageRepository::Installed;
d253 1
a253 1
		print STDERR "Invalid spec: $pat\n";
d256 1
a256 1
		my $r = OpenBSD::PackageRepository::Installed->new->match_locations($s);
d472 1
a472 1
				    @@list = find_by_spec($pat);
a506 1
		require OpenBSD::PackageLocator;
d511 1
a511 1
		my $r = OpenBSD::PackageLocator->new($state)->match_locations($partial);
@


1.8
log
@fix bad opt('l') printing.
don't create names list to recreate handles list
@
text
@d3 1
a3 1
# $OpenBSD: PkgInfo.pm,v 1.7 2010/06/25 14:02:07 espie Exp $
d226 1
a226 1
		    OpenBSD::PackageLocator->path_parse($pkgname);
d517 1
a517 3
		my $locator = OpenBSD::PackageLocator->new($state);

		my $r = $locator->match_locations($partial);
@


1.7
log
@remove last local vars.
@
text
@d3 1
a3 1
# $OpenBSD$
d263 1
a263 1
		return sort (map {$_->name} @@$r);
a310 2
	$path_info->{$path} = [] unless
	    defined $path_info->{$path};
d465 1
d475 1
d478 1
a483 1
			    push(@@ARGV, @@list);
d501 2
d504 1
a504 1
		if (@@ARGV == 0) {
d539 1
a539 1
	if (@@ARGV == 0 && !$all) {
d543 1
a543 1
	if (@@ARGV > 0 && $state->hasanyopt('aAtm')) {
d548 1
a548 1
	if (@@ARGV == 0 && !$error_e) {
d575 2
a576 2
		if ($state->{terse} && !$state->opt('q')) {
			$state->say("#1#2", $state->opt('l'), $pkg);
d583 7
@


1.6
log
@simplify message printing a bit
@
text
@d3 1
a3 1
# $OpenBSD: PkgInfo.pm,v 1.5 2010/06/25 10:22:56 espie Exp $
d106 48
a233 25
sub printfile
{
	my $filename = shift;
	my $_;

	open my $fh, '<', $filename or return;
	while(<$fh>) {
		print;
	}
	close $fh;
}

sub print_description
{
	my $dir = shift;
	my $_;

	open my $fh, '<', $dir.DESC or return;
	$_ = <$fh> unless -f $dir.COMMENT;
	while(<$fh>) {
		print;
	}
	close $fh;
}

a347 8
our ($opt_c, $opt_C, $opt_d, $opt_f, $opt_I, $opt_K,
    $opt_L, $opt_Q, $opt_q, $opt_R, $opt_s, $opt_v, $opt_h,
    $opt_l, $opt_a, $opt_m, $opt_M, $opt_U, $opt_A, $opt_S, $opt_P, $opt_t);
my $exit_code = 0;
my $error_e = 0;
my @@sought_files;
my $state;

d355 9
a363 6
	if ($opt_I) {
		my $l = 20 - length($pkg);
		$l = 1 if $l <= 0;
		print $pkg;
		print " "x$l, get_comment($handle->info) unless $opt_q;
		print "\n";
d365 1
a365 1
		if ($opt_c) {
d368 1
a368 2
			print get_comment($handle->info), "\n";
			print "\n";
d370 1
a370 1
		if ($opt_R && -f $handle->info.REQUIRED_BY) {
d373 1
a373 2
			printfile($handle->info.REQUIRED_BY);
			print "\n";
d375 1
a375 1
		if ($opt_d) {
d378 1
a378 2
			print_description($handle->info);
			print "\n";
d380 1
a380 1
		if ($opt_M && -f $handle->info.DISPLAY) {
d383 1
a383 2
			printfile($handle->info.DISPLAY);
			print "\n";
d385 1
a385 1
		if ($opt_U && -f $handle->info.UNDISPLAY) {
d388 1
a388 2
			printfile($handle->info.UNDISPLAY);
			print "\n";
d391 2
a392 1
		if ($opt_f || $opt_L || $opt_s || $opt_S || $opt_C) {
d395 1
a395 1
			if ($opt_f || $opt_s || $opt_S || $opt_C) {
d403 1
a403 1
		if ($opt_L) {
d406 2
a407 2
			$plist->dump_file($opt_K);
			print "\n";
d409 1
a409 1
		if ($opt_C) {
d420 1
a420 1
		if ($opt_s) {
d429 1
a429 1
		if ($opt_S) {
d432 1
a432 1
			    ($state->opt('q') ? "#1": "Signature: #1"), 
d435 1
a435 1
		if ($opt_P) {
d441 1
a441 1
			print "Pkgpath:\n" unless $opt_q;
d443 1
a443 1
				print $plist->fullpkgpath;
d445 2
a446 2
				print STDERR $plist->pkgname,
				    " has no FULLPKGPATH\n";
a447 1
			print "\n";
d450 1
a450 1
		if ($opt_f) {
d454 1
a454 1
			print "\n";
d463 4
a466 1
	$state = OpenBSD::PkgInfo::State->new($cmd);
d494 1
d501 1
a501 3
	unless ($opt_c || $opt_M || $opt_U || $opt_d || $opt_f || $opt_I ||
		$opt_L || $opt_R || $opt_s ||
		$opt_S || $opt_P || $state->{terse}) {
d503 1
a503 1
			$opt_I = $opt_a = 1;
d505 1
a505 1
			$opt_c = $opt_d = $opt_M = $opt_R = 1;
d509 1
a509 1
	if ($opt_Q) {
d514 1
a514 1
		my $partial = OpenBSD::Search::PartialStem->new($opt_Q);
d528 1
a528 2
		$opt_c = $opt_d = $opt_f = $opt_M =
		    $opt_U = $opt_R = $opt_s = $opt_S = 1;
d531 1
a531 5
	if (!defined $opt_l) {
		$opt_l = "";
	}

	if ($opt_K && !$opt_L) {
d535 1
a535 3
	if (@@ARGV == 0 && !$opt_a && !$opt_A) {
		$state->usage("Missing package name(s)") unless $state->{terse} || $opt_q;
	}
d537 2
a538 2
	if (@@ARGV > 0 && ($opt_a || $opt_A)) {
		$state->usage("Can't specify package name(s) with -a");
d541 2
a542 2
	if (@@ARGV > 0 && $opt_t) {
		$state->usage("Can't specify package name(s) with -t");
a544 3
	if (@@ARGV > 0 && $opt_m) {
		$state->usage("Can't specify package name(s) with -m");
	}
d547 2
a548 2
		@@ARGV = sort(installed_packages(defined $opt_A ? 0 : 1));
		if ($opt_t) {
d568 1
a568 1
	if ($opt_m) {
d573 1
a573 1
		if ($state->{terse} && !$opt_q) {
d576 1
a576 1
		$self->find_pkg($state, $pkg, 
@


1.5
log
@use new state (so no need to parse some options).
this requires exporter for now.
@
text
@d3 1
a3 1
# $OpenBSD$
d76 30
d118 1
a118 1
	my ($repo, $pkgname, $code) = @@_;
d165 1
a165 1
	my ($pkgname, $code) = @@_;
d168 1
a168 1
	if (find_pkg_in(OpenBSD::PackageRepository::Installed->new, $pkgname,
d183 1
a183 1
	find_pkg_in($repo, $pkgname, $code);
d246 1
a248 1
	my $search = shift;
d250 2
a251 2
	for my $arg (@@_) {
		find_pkg($arg,
d265 1
d269 2
a270 2
	for my $arg (@@_) {
		find_pkg($arg,
a327 1
my $terse = 0;
a332 10
sub just_in_time_header
{
	my ($pkg, $handle, $rdone) = @@_;
	return if $$rdone == 1;
	if (!$terse && !$opt_q) {
		print $opt_l, "Information for ", $handle->url, "\n\n";
	}
	$$rdone = 1;
}

d335 1
a335 1
	my ($pkg, $handle) = @@_;
d337 2
a338 1
		print STDERR "Error printing info for $pkg: no info ?\n";
a346 1
		my $done = 0;
d348 2
a349 2
			just_in_time_header($pkg, $handle ,\$done);
			print $opt_l, "Comment:\n" unless $opt_q;
d354 2
a355 2
			just_in_time_header($pkg, $handle ,\$done);
			print $opt_l, "Required by:\n" unless $opt_q;
d360 2
a361 2
			just_in_time_header($pkg, $handle ,\$done);
			print $opt_l, "Description:\n" unless $opt_q;
d366 2
a367 2
			just_in_time_header($pkg, $handle ,\$done);
			print $opt_l, "Install notice:\n" unless $opt_q;
d372 2
a373 2
			just_in_time_header($pkg, $handle ,\$done);
			print $opt_l, "Deinstall notice:\n" unless $opt_q;
d386 1
a386 1
			$state->fatal("bad packing-list for", $handle->url)
d390 2
a391 2
			just_in_time_header($pkg, $handle ,\$done);
			print $opt_l, "Files:\n" unless $opt_q;
d396 1
a396 1
			just_in_time_header($pkg, $handle ,\$done);
d400 1
a400 1
				print $opt_l, "Certificate info:\n" unless $opt_q;
d403 1
a403 1
				print $opt_l, "No digital signature\n" unless $opt_q;
d407 1
a407 1
			just_in_time_header($pkg, $handle ,\$done);
d410 2
a411 2
			print "Size: " unless $opt_q;
			print "$size\n";
d416 4
a419 3
			just_in_time_header($pkg, $handle ,\$done);
			print "Signature: " unless $opt_q;
			print $plist->signature->string, "\n";
d426 1
a426 1
			just_in_time_header($pkg, $handle ,\$done);
d438 2
a439 2
			just_in_time_header($pkg, $handle ,\$done);
			print $opt_l, "Packing-list:\n" unless $opt_q;
d443 1
a443 2
		return unless $done;
		print $opt_l, "\n" unless $opt_q || $terse;
d468 1
a468 1
			    $terse = 1;
d486 1
a486 1
		$opt_S || $opt_P || $terse) {
d500 1
d502 1
a502 1
		my $r = OpenBSD::PackageLocator->match_locations($partial);
d526 1
a526 1
		$state->usage("Missing package name(s)") unless $terse || $opt_q;
d551 1
a551 1
		@@ARGV = filter_files(\%hash, @@ARGV);
d555 2
a556 1
				print "$f: ", join(',', @@$l), "\n" unless $opt_q;
d564 1
a564 1
		@@ARGV = manual_filter(@@ARGV);
d568 2
a569 2
		if ($terse && !$opt_q) {
			print $opt_l, $pkg, "\n";
d571 4
a574 1
		find_pkg($pkg, \&print_info);
d577 1
a577 1
		print "Total size: $total_size\n";
d581 1
@


1.4
log
@common pattern reuse
@
text
@d3 1
a3 1
# $OpenBSD: PkgInfo.pm,v 1.3 2010/06/09 10:25:17 espie Exp $
d22 2
d62 14
a80 1
use OpenBSD::State;
d430 23
a452 34
	$state = OpenBSD::State->new($cmd);
	$state->usage_is('[-AaCcdfIKLMmPqRSstUv] [-E filename] [-e pkg-name] [-l str] [-Q query] [pkg-name] [...]');

	my %defines;
	my $locked;
	$state->do_options(sub {
		getopts('cCdfF:hIKLmPQ:qRsSUve:E:Ml:aAt',
		    {'e' =>
			    sub {
				    my $pat = shift;
				    my @@list;
				    lock_db(1, $opt_q) unless $defines{nolock};
				    $locked = 1;
				    if ($pat =~ m/\//o) {
					    @@list = find_by_path($pat);
				    } else {
					    @@list = find_by_spec($pat);
				    }
				    if (@@list == 0) {
					    $exit_code = 1;
					    $error_e = 1;
				    }
				    push(@@ARGV, @@list);
				    $terse = 1;
			    },
		     'F' => sub {
				    for my $o (split /\,/o, shift) {
					    $defines{$o} = 1;
				    }
			    },
		     'h' => sub {	$state->usage; },
		     'E' =>
			    sub {
				    require File::Spec;
d454 1
a454 1
				    push(@@sought_files, File::Spec->rel2abs(shift));
d456 5
a460 3
			    }
		})
	    });
d462 1
a462 1
	lock_db(1, $opt_q) unless $locked or $defines{nolock};
d478 1
a478 1
		print "PKG_PATH=$ENV{PKG_PATH}\n" if $opt_v;
d484 2
a485 1
			print $p, is_installed($p) ? " (installed)" : "" , "\n";
d491 1
a491 1
	if ($opt_v) {
@


1.3
log
@uniform spelling: packing-list
@
text
@d3 1
a3 1
# $OpenBSD: PkgInfo.pm,v 1.2 2010/06/09 07:26:01 espie Exp $
d420 1
a420 1
	try {
d453 2
a454 4
		});
	} catchall {
		$state->usage("#1", $_);
	};
@


1.2
log
@ui changes: go thru a state object for most printouts
@
text
@d3 1
a3 1
# $OpenBSD: PkgInfo.pm,v 1.1 2010/06/04 13:19:39 espie Exp $
d351 1
a351 1
			$state->fatal("bad packing list for", $handle->url)
d403 1
a403 1
			print $opt_l, "Packing list:\n" unless $opt_q;
@


1.1
log
@move code around, so that commands can be used as modules.
pkg becomes the start hub, which does nothing except require the
correct module.
Saner code wrt Add/Delete, and more sharing.
@
text
@d3 1
a3 1
# $OpenBSD: pkg_info,v 1.94 2010/05/10 09:17:55 espie Exp $
d65 1
d286 1
d351 1
a351 1
			Fatal "Bad packing list for", $handle->url
d414 3
a416 1
	set_usage('pkg_info [-AaCcdfIKLMmPqRSstUv] [-E filename] [-e pkg-name] [-l str] [-Q query] [pkg-name] [...]');
d445 1
a445 1
		     'h' => sub {	Usage(); },
d455 1
a455 1
		Usage($_);
d496 1
a496 1
		Usage "-K only makes sense with -L";
d500 1
a500 1
		Usage "Missing package name(s)" unless $terse || $opt_q;
d504 1
a504 1
		Usage "Can't specify package name(s) with -a";
d508 1
a508 1
		Usage "Can't specify package name(s) with -t";
d512 1
a512 1
		Usage "Can't specify package name(s) with -m";
@

