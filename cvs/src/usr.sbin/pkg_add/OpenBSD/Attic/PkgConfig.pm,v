head	1.20;
access;
symbols
	OPENBSD_5_1_BASE:1.19
	OPENBSD_5_1:1.19.0.4
	OPENBSD_5_0:1.19.0.2
	OPENBSD_5_0_BASE:1.19
	OPENBSD_4_9:1.18.0.2
	OPENBSD_4_9_BASE:1.18
	OPENBSD_4_8:1.16.0.2
	OPENBSD_4_8_BASE:1.16
	OPENBSD_4_7:1.13.0.2
	OPENBSD_4_7_BASE:1.13
	OPENBSD_4_6:1.12.0.6
	OPENBSD_4_6_BASE:1.12
	OPENBSD_4_5:1.12.0.2
	OPENBSD_4_5_BASE:1.12
	OPENBSD_4_4:1.11.0.4
	OPENBSD_4_4_BASE:1.11
	OPENBSD_4_3:1.11.0.2
	OPENBSD_4_3_BASE:1.11
	OPENBSD_4_2:1.10.0.2
	OPENBSD_4_2_BASE:1.10
	OPENBSD_4_1:1.9.0.2
	OPENBSD_4_1_BASE:1.9;
locks; strict;
comment	@# @;


1.20
date	2012.06.11.10.16.46;	author espie;	state dead;
branches;
next	1.19;

1.19
date	2011.06.21.07.18.35;	author jasper;	state Exp;
branches;
next	1.18;

1.18
date	2010.12.24.09.04.14;	author espie;	state Exp;
branches;
next	1.17;

1.17
date	2010.10.27.14.35.56;	author espie;	state Exp;
branches;
next	1.16;

1.16
date	2010.06.30.10.51.04;	author espie;	state Exp;
branches;
next	1.15;

1.15
date	2010.06.30.10.41.42;	author espie;	state Exp;
branches;
next	1.14;

1.14
date	2010.05.10.09.17.55;	author espie;	state Exp;
branches;
next	1.13;

1.13
date	2009.11.10.11.36.56;	author espie;	state Exp;
branches;
next	1.12;

1.12
date	2008.10.20.10.25.16;	author espie;	state Exp;
branches;
next	1.11;

1.11
date	2007.11.17.18.31.31;	author steven;	state Exp;
branches;
next	1.10;

1.10
date	2007.06.04.14.57.33;	author espie;	state Exp;
branches;
next	1.9;

1.9
date	2006.12.04.11.29.02;	author espie;	state Exp;
branches;
next	1.8;

1.8
date	2006.12.01.16.36.37;	author espie;	state Exp;
branches;
next	1.7;

1.7
date	2006.12.01.16.17.03;	author espie;	state Exp;
branches;
next	1.6;

1.6
date	2006.11.30.13.18.22;	author espie;	state Exp;
branches;
next	1.5;

1.5
date	2006.11.30.01.04.35;	author espie;	state Exp;
branches;
next	1.4;

1.4
date	2006.11.30.00.07.50;	author espie;	state Exp;
branches;
next	1.3;

1.3
date	2006.11.29.17.10.06;	author espie;	state Exp;
branches;
next	1.2;

1.2
date	2006.11.29.16.54.11;	author espie;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.29.11.10.16;	author espie;	state Exp;
branches;
next	;


desc
@@


1.20
log
@move PkgConfig.pm where it belongs
as requested by matthieu@@, ok jasper@@, miod@@, matthieu@@
@
text
@# ex:ts=8 sw=4:
# $OpenBSD: PkgConfig.pm,v 1.19 2011/06/21 07:18:35 jasper Exp $
#
# Copyright (c) 2006 Marc Espie <espie@@openbsd.org>
#
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF

use strict;
use warnings;

# this is a 'special' package, interface to the *.pc file format of pkg-config.
package OpenBSD::PkgConfig;

# specific properties may have specific needs.

my $parse = {
	Requires => sub {
	    [split qr{
	    	(?<![<=>]) 	# not preceded by <=>
		[,\s]+ 		#    delimiter
		(?![<=>])	# not followed by <=>
		}x, shift ] }
};


my $write = {
	Libs => sub { " ".__PACKAGE__->compress(shift) }
};

$parse->{'Requires.private'} = $parse->{Requires};
$write->{'Libs.private'} = $write->{Libs};

sub new
{
	my $class = shift;

	return bless {
		variables => {},
		vlist => [],
		properties => {},
		proplist => []
	}, $class;
}

sub add_variable
{
	my ($self, $name, $value) = @@_;
	if (defined $self->{variables}->{$name}) {
		die "Duplicate variable $name";
	}
	push(@@{$self->{vlist}}, $name);
	$self->{variables}->{$name} = $value;
}

sub add_property
{
	my ($self, $name, $value) = @@_;
	if (defined $self->{properties}->{$name}) {
		die "Duplicate property $name";
	}
	push(@@{$self->{proplist}}, $name);
	my $v;
	if (defined $value) {
		if (defined $parse->{$name}) {
			$v = $parse->{$name}($value);
		} else {
			$v = [split /(?<!\\)\s+/o, $value];
		}
	} else {
		$v = [];
	}
	$self->{properties}->{$name} = $v;
}

sub read_fh
{
	my ($class, $fh, $name) = @@_;
	my $cfg = $class->new;
	my $_;

	$name = '' if !defined $name;
	while (<$fh>) {
		chomp;
		# continuation lines
		while (m/(?<!\\)\\$/) {
			s/\\$//;
			$_.=<$fh>;
			chomp;
		}
		next if m/^\s*$/;
		next if m/^\#/;
		# zap comments
		s/(?<!\\)\#.*//;
		if (m/^([\w.]*)\s*\=\s*(.*)$/) {
			$cfg->add_variable($1, $2);
		} elsif (m/^([\w.]*)\:\s+(.*)$/) {
			$cfg->add_property($1, $2);
		} elsif (m/^([\w.]*)\:\s*$/) {
			$cfg->add_property($1);
		} else {
			die "Incorrect cfg file $name";
		}
	}
	if (defined $cfg->{properties}->{Libs}) {
		$cfg->{properties}->{Libs} =
		    $cfg->compress_list($cfg->{properties}->{Libs});
	}
	return $cfg;
}

sub read_file
{
	my ($class, $filename) = @@_;

	open my $fh, '<:crlf', $filename or die "Can't open $filename: $!";
	return $class->read_fh($fh, $filename);
}

sub write_fh
{
	my ($self, $fh) = @@_;

	foreach my $variable (@@{$self->{vlist}}) {
		print $fh "$variable=", $self->{variables}->{$variable}, "\n";
	}
	print $fh "\n\n";
	foreach my $property (@@{$self->{proplist}}) {
		my $p = $self->{properties}->{$property};
		print $fh "$property:";
		if (defined $write->{$property}) {
			print $fh $write->{$property}($p);
		} else {
			print $fh (map { " $_" } @@$p);
		}
	    	print $fh "\n";
	}
}

sub write_file
{
	my ($cfg, $filename) = @@_;
	open my $fh, '>', $filename or die "Can't open $filename: $!";
	$cfg->write_fh($fh);
}

sub compress_list
{
	my ($class, $l, $keep) = @@_;
	my $h = {};
	my $r = [];
	foreach my $i (@@$l) {
		next if defined $h->{$i};
		next if defined $keep && !&$keep($i);
		push(@@$r, $i);
		$h->{$i} = 1;
	}
	return $r;
}

sub compress
{
	my ($class, $l, $keep) = @@_;
	return join(' ', @@{$class->compress_list($l, $keep)});
}

sub rcompress
{
	my ($class, $l, $keep) = @@_;
	my @@l2 = reverse @@$l;
	return join(' ', reverse @@{$class->compress_list(\@@l2, $keep)});
}

sub expanded
{
	my ($self, $v, $extra) = @@_;

	$extra = {} if !defined $extra;
	my $get_value =
		sub {
			my $var = shift;
			if (defined $extra->{$var}) {
				return $extra->{$var};
			} elsif (defined $self->{variables}->{$var}) {
				return $self->{variables}->{$var};
			} else {
				return '';
			}
	};

	while ($v =~ s/\$\{(.*?)\}/&$get_value($1)/ge) {
	}
	return $v;
}

sub get_property
{
	my ($self, $k, $extra) = @@_;

	my $l = $self->{properties}->{$k};
	if (!defined $l) {
		return undef;
	}
	my $r = [];
	for my $v (@@$l) {
		push(@@$r, $self->expanded($v, $extra));
	}
	return $r;
}

sub get_variable
{
	my ($self, $k, $extra) = @@_;

	my $v = $self->{variables}->{$k};
	if (defined $v) {
		return $self->expanded($v, $extra);
	} else {
		return undef;
	}
}

# to be used to make sure a config does not depend on absolute path names,
# e.g., $cfg->add_bases(X11R6 => '/usr/X11R6');

sub add_bases
{
	my ($self, $extra) = @@_;

	while (my ($k, $v) = each %$extra) {
		for my $name (keys %{$self->{variables}}) {
			$self->{variables}->{$name} =~ s/\Q$v\E\b/\$\{\Q$k\E\}/g;
		}
		for my $name (keys %{$self->{properties}}) {
			for my $e (@@{$self->{properties}->{$name}}) {
				$e =~ s/\Q$v\E\b/\$\{\Q$k\E\}/g;
			}
		}
		$self->{variables}->{$k} = $v;
		unshift(@@{$self->{vlist}}, $k);
	}
}

1;
@


1.19
log
@- adjust add_property() to allow more liberal whitespace usage.

from simon@@, tested in a bulk by landry@@
ok espie@@
@
text
@d2 1
a2 1
# $OpenBSD: PkgConfig.pm,v 1.18 2010/12/24 09:04:14 espie Exp $
@


1.18
log
@handle failures from ports tree with more care.
this does avoid infinite loops in case of wrong plists.
necessary since print-plist-with-depends CAN fail...
@
text
@d2 1
a2 1
# $OpenBSD$
d76 1
a76 1
			$v = [split /\s+/o, $value] ;
@


1.17
log
@initial scaffolding for @@rcscript: for now, acts like normal files,
but allow absolute pathnames (treat that as an implicit @@cwd).
@
text
@@


1.16
log
@allow say and errsay to work without parameters, as it's ways common.
create verbose_system up in state, because it makes sense without verbose.
@
text
@@


1.15
log
@whitespace cleanup
@
text
@@


1.14
log
@whitespace fixes
@
text
@@


1.13
log
@bad espie: use strict/warnings consistently, and fix two nits and two
actual errors !
@
text
@d26 1
a26 1
	Requires => sub { 
d46 3
a48 3
	return bless { 
		variables => {},  
		vlist => [], 
d114 1
a114 1
		$cfg->{properties}->{Libs} = 
d142 1
a142 1
			print $fh (map { " $_" } @@$p); 
d187 1
a187 1
	my $get_value = 
@


1.12
log
@Say goodbye to local $_
lexical scoping is so much neater (courtesy of perl 5.10)
@
text
@d16 1
a16 1
#
@


1.11
log
@allow whitespace before = sign when reading variables from a .pc file.

"go ahead" espie@@, "makes sense" ckuethe@@
@
text
@d2 1
a2 1
# $OpenBSD: PkgConfig.pm,v 1.10 2007/06/04 14:57:33 espie Exp $
d88 1
a88 1
	local $_;
@


1.10
log
@I am on drugs, I don't know where I found split can take strings as
arguments. Repair...
@
text
@d2 1
a2 1
# $OpenBSD: PkgConfig.pm,v 1.9 2006/12/04 11:29:02 espie Exp $
d103 1
a103 1
		if (m/^([\w.]*)\=\s*(.*)$/) {
@


1.9
log
@add rcompress method
@
text
@d2 1
a2 1
# $OpenBSD: PkgConfig.pm,v 1.8 2006/12/01 16:36:37 espie Exp $
d76 1
a76 1
			$v = [split /\s+/, $value] ;
@


1.8
log
@handles continuation lines and comments.
@
text
@d2 1
a2 1
# $OpenBSD: PkgConfig.pm,v 1.7 2006/12/01 16:17:03 espie Exp $
d173 7
@


1.7
log
@Fixes parsing of variables/delimiters, so that we classify like pkgconfig.
Augment the Requires parser to deal correctly with comparisons.
@
text
@d2 1
a2 1
# $OpenBSD: PkgConfig.pm,v 1.6 2006/11/30 13:18:22 espie Exp $
d93 6
d101 2
@


1.6
log
@apply some normalization to some properties while reading or writing,
for instance, parse Requirements correctly, and simplify Libs before
writing.
We normalize Libs before writing because it's more efficient.
@
text
@d2 1
a2 1
# $OpenBSD: PkgConfig.pm,v 1.5 2006/11/30 01:04:35 espie Exp $
d26 6
a31 1
	Requires => sub { [split /[,\s]\s*/, shift ] }
d34 1
d39 3
d95 1
a95 1
		if (m/^(.*?)\=\s*(.*)$/) {
d97 1
a97 1
		} elsif (m/^(.*?)\:\s+(.*)$/) {
d99 1
a99 1
		} elsif (m/^(.*?)\:\s*$/) {
@


1.5
log
@some *.pc files have variable= value, with a space.
@
text
@d2 1
a2 1
# $OpenBSD: PkgConfig.pm,v 1.4 2006/11/30 00:07:50 espie Exp $
d23 10
d62 1
d64 5
a68 1
		$self->{properties}->{$name} = [split /\s+/, $value] ;
d70 1
a70 1
		$self->{properties}->{$name} = [];
d72 1
d96 4
d120 8
a127 3
		print $fh "$property:", 
			(map { " $_" } @@{$self->{properties}->{$property}}), 
			"\n";
@


1.4
log
@adjust (C), noticed by matthieu.

Note that this lives here because pkg_create is going to use it to
normalize *.pc files at some point...
@
text
@d2 1
a2 1
# $OpenBSD: PkgConfig.pm,v 1.3 2006/11/29 17:10:06 espie Exp $
d70 1
a70 1
		if (m/^(.*?)\=(.*)$/) {
@


1.3
log
@add compress_list, allows for empty lines consisting of spaces...
@
text
@d2 1
a2 1
# $OpenBSD: PkgConfig.pm,v 1.2 2006/11/29 16:54:11 espie Exp $
d4 1
a4 1
# Copyright (c) 2004 Marc Espie <espie@@openbsd.org>
@


1.2
log
@let compress filter out stuff, add method add_bases, make sure write_fh
writes to fh.
@
text
@d2 1
a2 1
# $OpenBSD: PkgConfig.pm,v 1.1 2006/11/29 11:10:16 espie Exp $
d68 1
a68 1
		next if m/^$/;
d113 1
a113 1
sub compress
d117 1
a117 1
	my @@r = ();
d121 1
a121 1
		push(@@r, $i);
d124 7
a130 1
	return join(' ', @@r);
@


1.1
log
@handle pkg-config files.
@
text
@d2 1
a2 1
# $OpenBSD$
d96 1
a96 1
		print "$variable=", $self->{variables}->{$variable}, "\n";
d98 1
a98 1
	print "\n\n";
d100 1
a100 1
		print "$property:", 
d115 1
a115 1
	my ($class, $l) = @@_;
d120 1
d173 21
@

