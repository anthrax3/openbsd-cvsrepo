head	1.14;
access;
symbols
	OPENBSD_6_0:1.13.0.12
	OPENBSD_6_0_BASE:1.13
	OPENBSD_5_9:1.13.0.6
	OPENBSD_5_9_BASE:1.13
	OPENBSD_5_8:1.13.0.8
	OPENBSD_5_8_BASE:1.13
	OPENBSD_5_7:1.13.0.2
	OPENBSD_5_7_BASE:1.13
	OPENBSD_5_6:1.13.0.4
	OPENBSD_5_6_BASE:1.13
	OPENBSD_5_5:1.11.0.4
	OPENBSD_5_5_BASE:1.11;
locks; strict;
comment	@# @;


1.14
date	2016.10.04.14.27.25;	author espie;	state dead;
branches;
next	1.13;
commitid	xPfTqDS8lBGpjpcG;

1.13
date	2014.03.18.16.40.46;	author espie;	state Exp;
branches;
next	1.12;

1.12
date	2014.03.05.22.42.36;	author espie;	state Exp;
branches;
next	1.11;

1.11
date	2014.01.17.10.59.18;	author espie;	state Exp;
branches;
next	1.10;

1.10
date	2014.01.14.10.05.58;	author espie;	state Exp;
branches;
next	1.9;

1.9
date	2014.01.13.01.41.34;	author tedu;	state Exp;
branches;
next	1.8;

1.8
date	2014.01.10.14.34.02;	author espie;	state Exp;
branches;
next	1.7;

1.7
date	2014.01.09.20.20.01;	author espie;	state Exp;
branches;
next	1.6;

1.6
date	2014.01.09.10.36.52;	author espie;	state Exp;
branches;
next	1.5;

1.5
date	2014.01.08.06.40.56;	author espie;	state Exp;
branches;
next	1.4;

1.4
date	2014.01.04.00.14.08;	author espie;	state Exp;
branches;
next	1.3;

1.3
date	2014.01.03.17.10.57;	author espie;	state Exp;
branches;
next	1.2;

1.2
date	2014.01.02.13.45.14;	author espie;	state Exp;
branches;
next	1.1;

1.1
date	2013.12.31.11.21.10;	author espie;	state Exp;
branches;
next	;


desc
@@


1.14
log
@no longer needed
@
text
@# ex:ts=8 sw=4:
# $OpenBSD: signify.pm,v 1.13 2014/03/18 16:40:46 espie Exp $
#
# Copyright (c) 2013-2014 Marc Espie <espie@@openbsd.org>
#
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

use strict;
use warnings;

package OpenBSD::signify;

use OpenBSD::PackageInfo;
use OpenBSD::Paths;
use File::Temp qw/mkstemp/;

my $header = "untrusted comment: signify -- signature\n";
my $cmd = OpenBSD::Paths->signify;
my $suffix = ".sig";

sub do_check
{
	my ($plist, $state, $sig, $pubkey) = @@_;
	my ($rdmsg, $wrmsg);
	pipe($rdmsg, $wrmsg) or $state->fatal("Bad pipe: #1", $!);
	return $state->system(
	    sub {
		    close($wrmsg);
		    open(STDIN, '<&', $rdmsg);
		    close($rdmsg);
	    },
	    sub {
	    	close($rdmsg);
		print $wrmsg $header, $sig, "\n";
		$plist->write_no_sig($wrmsg);
		close($wrmsg);
	    },
	    $cmd, '-V', '-q', '-p', $pubkey, '-e', '-x', '-', 
	    '-m', '/dev/null');
}

sub compute_signature
{
	my ($plist, $state, $key, $pub) = @@_;

	my ($rdmsg, $wrmsg);
	my ($rdsig, $wrsig);
	pipe($rdmsg, $wrmsg) or $state->fatal("Bad pipe: #1", $!);
	pipe($rdsig, $wrsig) or $state->fatal("Bad pipe: #1", $!);
	my $sig;
	$state->system(
	    sub {
		close($wrmsg);
		open(STDIN, '<&', $rdmsg);
		close($rdmsg);
		close($rdsig);
		open(STDOUT, '>&', $wrsig);
		close($wrsig);
	    },
	    sub {
	    	close($rdmsg);
		close($wrsig);
		$plist->write_no_sig($wrmsg);
		close($wrmsg);
		my $header = <$rdsig>;
		$sig = <$rdsig>;
		chomp $sig;
		close($rdsig);
	    },
	    $cmd, '-S', '-q', '-s', $key, '-m', '-', '-x', '-') == 0 or 
	    $state->fatal("problem generating signature");
	if (defined $pub) {
		do_check($plist, $state, $sig, $pub) == 0 or
		    $state->fatal("public key and private key don't match");
	}
	return $sig;
}


sub check_signature
{
	my ($plist, $state) = @@_;
	
	if (!$plist->has('signer')) {
		$state->errsay("Invalid signed plist: no \@@signer");
		return 0;
	}
	my $signer = $plist->get('signer')->name;
	my $pubkey = OpenBSD::Paths->signifykey($signer);
	if (!-f $pubkey) {
		$state->errsay("Can't find key #1 for signer #1", $pubkey, 
		    $signer);
		return 0;
	}

	my $sig = $plist->get('digital-signature');
	my $rc = do_check($plist, $state, $sig->{b64sig}, $pubkey);
	if ($rc != 0) {
	    	$state->log("Bad signature");
		return 0;
	}
	if (!grep 
	    {ref($_) eq 'Regexp' ? $signer =~ $_ : $_ eq $signer} 
	    @@{$state->signer_list}) {
		$state->errsay("Package signed by untrusted party #1", $signer);
		return 0;
	}
	return 1;
}

1;
@


1.13
log
@now that signify can read/write messages to pipes, use that to avoid
creating temporary files.

for checking, use the "embedded sig" format to avoid writing to two
distinct pipes from the same process (tedu@@ reluctantly agrees)
@
text
@d2 1
a2 1
# $OpenBSD: signify.pm,v 1.12 2014/03/05 22:42:36 espie Exp $
@


1.12
log
@shush. signify is quiet now, but we want it to stay that way
@
text
@d2 1
a2 1
# $OpenBSD: signify.pm,v 1.11 2014/01/17 10:59:18 espie Exp $
d31 21
d56 25
a80 7
	my $contents = $plist->infodir.CONTENTS;
	my $sigfile = $contents.$suffix;

	open my $fh, ">", $contents;
	$plist->write_no_sig($fh);
	close $fh;
	$state->system($cmd, '-S', '-q', '-s', $key, '-m', $contents) == 0 or 
d83 1
a83 2
		$state->system($cmd, '-V', '-q', '-p', $pub, '-m', 
		    $contents) == 0 or 
a85 7
	open(my $sighandle, '<', $sigfile)
		or $state->fatal("problem reading signature");
	my $header = <$sighandle>;
	my $sig = <$sighandle>;
	close($sighandle);
	unlink($sigfile);
	chomp $sig;
d89 1
d107 1
a107 10
	my ($fh, $fname) = mkstemp("/tmp/pkgcontent.XXXXXXXXX");
	$plist->write_no_sig($fh);
	open(my $fh2, ">", $fname.$suffix);
	print $fh2 $header, $sig->{b64sig}, "\n";
	close $fh;
	close $fh2;
	my $rc = $state->system($cmd, '-V', '-q', '-p', $pubkey, '-m', $fname);
	unlink $fname;
	unlink $fname.$suffix;

@


1.11
log
@as requested by theo, invoke signify in the EXAMPLE order.
@
text
@d2 1
a2 1
# $OpenBSD: signify.pm,v 1.10 2014/01/14 10:05:58 espie Exp $
d41 1
a41 1
	$state->system($cmd, '-S', '-s', $key, '-m', $contents) == 0 or 
d44 2
a45 1
		$state->system($cmd, '-V', '-p', $pub, '-m', $contents) == 0 or 
d81 1
a81 1
	my $rc = $state->system($cmd, '-V', '-p', $pubkey, '-m', $fname);
@


1.10
log
@reorder signature checks, we can do much more upfront.
clean up temp files always.
use a regexp for allowed keys, put default key up in front still.
@
text
@d2 1
a2 1
# $OpenBSD: signify.pm,v 1.9 2014/01/13 01:41:34 tedu Exp $
d33 1
a33 1
	my ($plist, $state, $key) = @@_;
d41 6
a46 2
	$state->system($cmd, '-s', $key, '-S', '-m', $contents)
	    == 0 or die "probleme generating signature";
d48 1
a48 1
		or die "problem reading signature";
d80 1
a80 1
	my $rc = $state->system($cmd, '-p', $pubkey, '-V', '-m', $fname);
@


1.9
log
@new signify options. from and ok espie
@
text
@d2 1
a2 1
# $OpenBSD: signify.pm,v 1.8 2014/01/10 14:34:02 espie Exp $
d56 13
d76 6
a81 3
	
	if (!$plist->has('signer')) {
		$state->errsay("Invalid signed plist: no \@@signer");
d84 3
a86 10
	my $pubkey;
	my $signer = $plist->get('signer')->name;
	if (grep {$_ eq $signer} @@{$state->signer_list}) {
		$pubkey = OpenBSD::Paths->signifykey($signer);
		if (!-f $pubkey) {
			$state->errsay("Can't find key #1 for signer #1", 
			    $pubkey, $signer);
			return 0;
		}
	} else {
a89 6
	if ($state->system($cmd, '-p', $pubkey, '-V', '-m', $fname) != 0) {
	    	$state->log("Bad signature");
		return 0;
	}
	unlink $fname;
	unlink $fname.$suffix;
@


1.8
log
@signify silent by default, don't bother working around stdout.
@
text
@d2 1
a2 1
# $OpenBSD: signify.pm,v 1.7 2014/01/09 20:20:01 espie Exp $
d41 1
a41 1
	$state->system($cmd, '-s', $key, '-S', '--', $contents)
d81 1
a81 1
	if ($state->system($cmd, '-p', $pubkey, '-V', '--', $fname) != 0) {
@


1.7
log
@bump copyright to 2014
@
text
@d2 1
a2 1
# $OpenBSD: signify.pm,v 1.6 2014/01/09 10:36:52 espie Exp $
d81 1
a81 3
	if ($state->system(sub {
	    open STDOUT, ">", "/dev/null";},
	    $cmd, '-p', $pubkey, '-V', '--', $fname) != 0) {
@


1.6
log
@tweak signing yet again. Have pkg_create automatically add signing
identities every time, and make matching identities mandatory.
e.g., pkg_create and pkg_add must have matching -DSIGNER.
by default, signer is derived from uname -r and role (pkg_add/fw_update),
e.g., 54pkg, 54fw...
@
text
@d2 1
a2 1
# $OpenBSD: signify.pm,v 1.5 2014/01/08 06:40:56 espie Exp $
d4 1
a4 1
# Copyright (c) 2013 Marc Espie <espie@@openbsd.org>
@


1.5
log
@synch with signify(1) paranoia
@
text
@d2 1
a2 1
# $OpenBSD: signify.pm,v 1.4 2014/01/04 00:14:08 espie Exp $
a62 1
	my $pubkey;
d64 3
a66 4
	if ($state->defines('FW_UPDATE')) {
		$pubkey = OpenBSD::Paths->signifyfwkey;
	} else {
		$pubkey = OpenBSD::Paths->signifykey;
d68 4
a71 3
	if ($plist->has('signer')) {
		my $signer = $plist->get('signer')->name;
		$pubkey = "/etc/signify/$signer.pub";
d73 2
a74 1
			$state->say("Unknown signer #1", $signer);
d77 3
@


1.4
log
@vendor->signer
shorten pubkey -> pub (naddy@@)
\\ -> \e (jmc@@)
@
text
@d2 1
a2 1
# $OpenBSD: signify.pm,v 1.3 2014/01/03 17:10:57 espie Exp $
d27 1
a27 1
my $header = "signify -- signature\n";
@


1.3
log
@synch with signify usage
@
text
@d2 1
a2 1
# $OpenBSD: signify.pm,v 1.2 2014/01/02 13:45:14 espie Exp $
d70 3
a72 3
	if ($plist->has('vendor')) {
		my $vendor = $plist->get('vendor')->name;
		$pubkey = "/etc/signify/$vendor.pubkey";
d74 1
a74 1
			$state->say("Unknown vendor #1", $vendor);
@


1.2
log
@adapt to signify changes
allow a separate key for firmwares
@
text
@d2 1
a2 1
# $OpenBSD: signify.pm,v 1.1 2013/12/31 11:21:10 espie Exp $
d41 1
a41 1
	$state->system($cmd, '-i', $contents, '-s', $key, '-S')
d78 1
a78 1
	if ($state->system(sub { open STDERR, ">", "/dev/null";
d80 1
a80 1
	    $cmd, '-i', $fname, '-p', $pubkey, '-V') != 0) {
@


1.1
log
@signify support
@
text
@d2 1
a2 1
# $OpenBSD$
a28 1
my $defaultpubkey = OpenBSD::Paths->signifykey;
d41 1
a41 1
	$state->system($cmd, '-I', $contents, '-S', $key, '-V', 'sign')
d63 7
a69 1
	my $pubkey = $defaultpubkey;
d80 1
a80 1
	    $cmd, '-I', $fname, '-P', $pubkey, '-V', 'verify') != 0) {
@

