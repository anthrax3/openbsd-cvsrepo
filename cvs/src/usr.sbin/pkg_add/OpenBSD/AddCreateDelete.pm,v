head	1.39;
access;
symbols
	OPENBSD_6_2:1.39.0.2
	OPENBSD_6_2_BASE:1.39
	OPENBSD_6_1:1.39.0.6
	OPENBSD_6_1_BASE:1.39
	OPENBSD_6_0:1.39.0.4
	OPENBSD_6_0_BASE:1.39
	OPENBSD_5_9:1.34.0.2
	OPENBSD_5_9_BASE:1.34
	OPENBSD_5_8:1.34.0.4
	OPENBSD_5_8_BASE:1.34
	OPENBSD_5_7:1.33.0.2
	OPENBSD_5_7_BASE:1.33
	OPENBSD_5_6:1.25.0.4
	OPENBSD_5_6_BASE:1.25
	OPENBSD_5_5:1.22.0.4
	OPENBSD_5_5_BASE:1.22
	OPENBSD_5_4:1.16.0.6
	OPENBSD_5_4_BASE:1.16
	OPENBSD_5_3:1.16.0.4
	OPENBSD_5_3_BASE:1.16
	OPENBSD_5_2:1.16.0.2
	OPENBSD_5_2_BASE:1.16
	OPENBSD_5_1_BASE:1.15
	OPENBSD_5_1:1.15.0.4
	OPENBSD_5_0:1.15.0.2
	OPENBSD_5_0_BASE:1.15
	OPENBSD_4_9:1.13.0.2
	OPENBSD_4_9_BASE:1.13
	OPENBSD_4_8:1.11.0.2
	OPENBSD_4_8_BASE:1.11;
locks; strict;
comment	@# @;


1.39
date	2016.06.24.11.42.30;	author espie;	state Exp;
branches;
next	1.38;
commitid	Pp1JudXEajWFIq4j;

1.38
date	2016.06.23.16.11.23;	author espie;	state Exp;
branches;
next	1.37;
commitid	QxkzX6iWFbwTHuvu;

1.37
date	2016.06.15.15.40.13;	author espie;	state Exp;
branches;
next	1.36;
commitid	FvFggVo6v6h0AgLZ;

1.36
date	2016.06.06.15.19.45;	author espie;	state Exp;
branches;
next	1.35;
commitid	5ZvORJhUrqy17eFI;

1.35
date	2016.06.06.13.58.55;	author espie;	state Exp;
branches;
next	1.34;
commitid	pHyhF6U3vfmY5FqA;

1.34
date	2015.04.06.11.07.24;	author espie;	state Exp;
branches;
next	1.33;
commitid	5mxPWdqhJG0A6CvY;

1.33
date	2015.02.09.11.01.08;	author espie;	state Exp;
branches;
next	1.32;
commitid	Z6l6oTpMQ1XDG1H9;

1.32
date	2015.02.09.09.47.10;	author espie;	state Exp;
branches;
next	1.31;
commitid	xqLBFD7mhjAxdWa0;

1.31
date	2015.02.05.10.47.48;	author espie;	state Exp;
branches;
next	1.30;
commitid	chlihveKiAUpX9Tf;

1.30
date	2015.01.30.11.42.55;	author espie;	state Exp;
branches;
next	1.29;
commitid	cmEQoqBSBCDfR7gW;

1.29
date	2015.01.04.14.20.04;	author espie;	state Exp;
branches;
next	1.28;
commitid	xJlx1plAz31SlC6u;

1.28
date	2015.01.04.14.10.20;	author espie;	state Exp;
branches;
next	1.27;
commitid	xYfsnhxsU1KFmOcD;

1.27
date	2014.11.30.15.56.15;	author espie;	state Exp;
branches;
next	1.26;
commitid	VEUnKivfaZ0TBfIM;

1.26
date	2014.11.29.10.42.51;	author espie;	state Exp;
branches;
next	1.25;
commitid	XiRgNGt76qJ9BWZO;

1.25
date	2014.06.03.13.13.53;	author espie;	state Exp;
branches;
next	1.24;
commitid	wM95YBNwH1MmV3qV;

1.24
date	2014.05.20.05.55.43;	author espie;	state Exp;
branches;
next	1.23;

1.23
date	2014.05.20.05.46.13;	author espie;	state Exp;
branches;
next	1.22;

1.22
date	2014.01.17.10.55.01;	author espie;	state Exp;
branches;
next	1.21;

1.21
date	2014.01.14.10.05.58;	author espie;	state Exp;
branches;
next	1.20;

1.20
date	2014.01.12.11.18.57;	author espie;	state Exp;
branches;
next	1.19;

1.19
date	2014.01.09.20.20.01;	author espie;	state Exp;
branches;
next	1.18;

1.18
date	2014.01.09.10.36.52;	author espie;	state Exp;
branches;
next	1.17;

1.17
date	2013.12.23.16.50.29;	author espie;	state Exp;
branches;
next	1.16;

1.16
date	2012.05.01.10.18.13;	author espie;	state Exp;
branches;
next	1.15;

1.15
date	2011.03.19.10.30.02;	author espie;	state Exp;
branches;
next	1.14;

1.14
date	2011.03.07.09.26.47;	author espie;	state Exp;
branches;
next	1.13;

1.13
date	2010.12.24.09.04.14;	author espie;	state Exp;
branches;
next	1.12;

1.12
date	2010.10.25.21.02.44;	author espie;	state Exp;
branches;
next	1.11;

1.11
date	2010.07.09.12.42.43;	author espie;	state Exp;
branches;
next	1.10;

1.10
date	2010.06.30.10.51.04;	author espie;	state Exp;
branches;
next	1.9;

1.9
date	2010.06.30.10.41.41;	author espie;	state Exp;
branches;
next	1.8;

1.8
date	2010.06.25.10.34.03;	author espie;	state Exp;
branches;
next	1.7;

1.7
date	2010.06.25.10.19.00;	author espie;	state Exp;
branches;
next	1.6;

1.6
date	2010.06.15.08.35.11;	author espie;	state Exp;
branches;
next	1.5;

1.5
date	2010.06.15.08.30.37;	author espie;	state Exp;
branches;
next	1.4;

1.4
date	2010.06.09.11.57.21;	author espie;	state Exp;
branches;
next	1.3;

1.3
date	2010.06.09.07.26.01;	author espie;	state Exp;
branches;
next	1.2;

1.2
date	2010.06.05.09.15.55;	author espie;	state Exp;
branches;
next	1.1;

1.1
date	2010.06.04.13.19.39;	author espie;	state Exp;
branches;
next	;


desc
@@


1.39
log
@simplify the logic. no need for a separate hook when we can just specialize
find_window_size.
fix a bug: integrate SIG{CONT} for re-checking window size.

the way it's currently written, first call to compute_playfield will
call itself once. But it makes for less code.
@
text
@# ex:ts=8 sw=4:
# $OpenBSD: AddCreateDelete.pm,v 1.38 2016/06/23 16:11:23 espie Exp $
#
# Copyright (c) 2007-2014 Marc Espie <espie@@openbsd.org>
#
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
#

use strict;
use warnings;

# common framework, let's place most everything in there

package OpenBSD::AddCreateDelete::State;
our @@ISA = qw(OpenBSD::State);

use OpenBSD::State;
use OpenBSD::ProgressMeter;

sub init
{
	my $self = shift;

	$self->{progressmeter} = OpenBSD::ProgressMeter->new;
	$self->{bad} = 0;
	$self->SUPER::init(@@_);
	$self->{export_level}++;
}

sub progress
{
	my $self = shift;
	return $self->{progressmeter};
}

sub not
{
	my $self = shift;
	return $self->{not};
}

sub sync_display
{
	my $self = shift;
	$self->progress->clear;
}

sub add_interactive_options
{
	my $self = shift;
	$self->{has_interactive_options} = 1;
	return $self;
}

sub handle_options
{
	my ($state, $opt_string, @@usage) = @@_;

	my $i;

	if ($state->{has_interactive_options}) {
		$opt_string .= 'iI';
		$state->{opt}{i} = sub {
			$i++;
		};
	};

	$state->SUPER::handle_options($opt_string.'L:mnx', @@usage);

	$state->progress->setup($state->opt('x'), $state->opt('m'), $state);
	$state->{not} = $state->opt('n');
	if ($state->{has_interactive_options}) {
		if ($state->opt('I')) {
			$i = 0;
		} elsif (!defined $i) {
			$i = -t STDIN;
		}
	}
	if ($i) {
		require OpenBSD::Interactive;
		$state->{interactive} = OpenBSD::Interactive->new($state, $i);
	}
	$state->{interactive} //= OpenBSD::InteractiveStub->new($state);
}


sub is_interactive
{
	return shift->{interactive}->is_interactive;
}

sub find_window_size
{
	my ($state, $cont) = @@_;
	$state->SUPER::find_window_size;
	$state->{progressmeter}->compute_playfield($cont);
}

sub confirm
{
	my $self = shift;
	return $self->{interactive}->confirm(@@_);
}

sub ask_list
{
	my $self = shift;
	return $self->{interactive}->ask_list(@@_);
}

sub vsystem
{
	my $self = shift;
	if ($self->verbose < 2) {
		$self->system(@@_);
	} else {
		$self->verbose_system(@@_);
	}
}

sub system
{
	my $self = shift;
	$self->SUPER::system(@@_);
}

sub run_makewhatis
{
	my ($state, $opts, $l) = @@_;
	my $braindead = sub { chdir('/'); };
	while (@@$l > 1000) {
		my @@b = splice(@@$l, 0, 1000);
		$state->vsystem($braindead,
		    OpenBSD::Paths->makewhatis, @@$opts, '--', @@b);
	}
	$state->vsystem($braindead,
	    OpenBSD::Paths->makewhatis, @@$opts, '--', @@$l);
}

sub ntogo
{
	my ($self, $offset) = @@_;

	return $self->{wantntogo} ?
	    $self->progress->ntogo($self, $offset) :
	    $self->f("ok");
}

sub ntogo_string
{
	my ($self, $offset) = @@_;

	return $self->{wantntogo} ?
	    $self->f(" (#1)", $self->ntodo($offset // 0)) :
	    $self->f("");
}

package OpenBSD::AddCreateDelete;
use OpenBSD::Error;

sub handle_options
{
	my ($self, $opt_string, $state, @@usage) = @@_;
	$state->handle_options($opt_string, $self, @@usage);
}

package OpenBSD::InteractiveStub;
sub new
{
	my $class = shift;
	bless {}, $class;
}

sub ask_list
{
	my ($self, $prompt, @@values) = @@_;
	return $values[0];
}

sub confirm
{
	my ($self, $prompt, $yesno) = @@_;
	return $yesno;
}

sub is_interactive
{
	return 0;
}
1;
@


1.38
log
@there's no reason for window size computation to be linked to the
ProgressMeter, so make it available from state.
- computation is lazy, so no runtime difference;
- don't bother setting a SIG{WINCH} on non-tty;
- progressmeter already has access to state;
- do an empty window_size_changed in base state, override it for
addcreatedelete to inform the progressmeter.

to be reused in dpb...
@
text
@d2 1
a2 1
# $OpenBSD: AddCreateDelete.pm,v 1.37 2016/06/15 15:40:13 espie Exp $
d102 1
a102 1
sub window_size_changed
d104 3
a106 1
	shift->{progressmeter}->compute_playfield;
@


1.37
log
@dedup interactive options handling code yet again.
dynamic code mixin
@
text
@d2 1
a2 1
# $OpenBSD: AddCreateDelete.pm,v 1.36 2016/06/06 15:19:45 espie Exp $
d100 5
@


1.36
log
@band-aid for pkg_check, some options need to be mixin.
@
text
@d2 1
a2 1
# $OpenBSD: AddCreateDelete.pm,v 1.35 2016/06/06 13:58:55 espie Exp $
d58 7
d69 9
d82 12
a93 1
	$state->{interactive} = OpenBSD::InteractiveStub->new($state);
@


1.35
log
@fix somewhat broken inheritance: the actual -i/-I interactive dance is
only relevant for pkg_add/pkg_delete.

Every tool needs an interactive object, but setting that to InteractiveStub
"just in case" after doing the interactive dance is fine for
pkg_create/pkg_sign

problem noticed by jsg@@ in pkg_sign(1).
@
text
@d2 1
a2 1
# $OpenBSD: AddCreateDelete.pm,v 1.34 2015/04/06 11:07:24 espie Exp $
d66 1
a66 1
	$state->{interactive} //= OpenBSD::InteractiveStub->new($state);
@


1.34
log
@move signer_list up so pkg_info can use it
@
text
@d2 1
a2 1
# $OpenBSD: AddCreateDelete.pm,v 1.33 2015/02/09 11:01:08 espie Exp $
d62 1
a62 5
	my $i;
	$state->{opt}{i} //= sub {
		$i++;
	};
	$state->SUPER::handle_options($opt_string.'IiL:mnx', @@usage);
d66 1
a66 11
	if ($state->opt('I')) {
		$i = 0;
	} elsif (!defined $i) {
		$i = -t STDIN;
	}
	if ($i) {
		require OpenBSD::Interactive;
		$state->{interactive} = OpenBSD::Interactive->new($state, $i);
	} else {
		$state->{interactive} = OpenBSD::InteractiveStub->new($state);
	}
@


1.33
log
@oops, this little bit is unneeded and actually breaks some other stuff
@
text
@d2 1
a2 1
# $OpenBSD: AddCreateDelete.pm,v 1.32 2015/02/09 09:47:10 espie Exp $
a146 14

OpenBSD::Auto::cache(signer_list,
	sub {
		my $self = shift;
		if ($self->defines('SIGNER')) {
			return [split /,/, $self->{subst}->value('SIGNER')];
		} else {
			if ($self->defines('FW_UPDATE')) {
				return [qr{^.*fw$}];
			} else {
				return [qr{^.*pkg$}];
			}
		}
	});
@


1.32
log
@full fix for check-lib-depends... previous patch did only half the work
@
text
@d2 1
a2 1
# $OpenBSD: AddCreateDelete.pm,v 1.31 2015/02/05 10:47:48 espie Exp $
d62 1
a62 1
	my $i = 0;
@


1.31
log
@compat for check-lib-depends
@
text
@d2 1
a2 1
# $OpenBSD: AddCreateDelete.pm,v 1.30 2015/01/30 11:42:55 espie Exp $
d62 2
a63 2
	my $i;
	$state->{opt}{i} = sub {
a80 1
	$state->{opt}{i} = $i;
@


1.30
log
@Fix the default interactive level to install the "default" dependencies.
Actually testing it caused me to write correct (and simpler) code...
@
text
@d2 1
a2 1
# $OpenBSD: AddCreateDelete.pm,v 1.29 2015/01/04 14:20:04 espie Exp $
d81 1
@


1.29
log
@tweak the ntogo messages slightly so that they work better in all situations
@
text
@d2 1
a2 1
# $OpenBSD: AddCreateDelete.pm,v 1.28 2015/01/04 14:10:20 espie Exp $
d62 4
d70 1
a70 7
	if ($state->opt('i') && $state->opt('I')) {
		$state->usage("-i and -I are reverse options, make up your mind");
	}
	my $i;
	if ($state->opt('i')) {
		$i = 1;
	} elsif ($state->opt('I')) {
d72 1
a72 1
	} else {
d77 1
a77 1
		$state->{interactive} = OpenBSD::Interactive->new($state);
@


1.28
log
@too many todo. Use unambiguous names, since they're not the same operation
at all
@
text
@d2 1
a2 1
# $OpenBSD: AddCreateDelete.pm,v 1.27 2014/11/30 15:56:15 espie Exp $
d145 3
a147 1
	return $self->ntodo($offset // 0);
@


1.27
log
@much cleaner way to handle progress meter wipes: have state methods that
do print something call sync_display (which does nothing by default), and
override THAT one for the progressmeter case to go clear.
Should sync by default now.
@
text
@d2 1
a2 1
# $OpenBSD: AddCreateDelete.pm,v 1.26 2014/11/29 10:42:51 espie Exp $
d145 1
a145 1
	return $self->todo($offset // 0);
@


1.26
log
@simplify the interactive code into its own little object with simpler
interface, so that most is it interactive tests vanish from the main
program.
@
text
@d2 1
a2 1
# $OpenBSD: AddCreateDelete.pm,v 1.25 2014/06/03 13:13:53 espie Exp $
d52 1
a52 1
sub _print
d55 1
a55 7
	$self->progress->print(@@_);
}

sub _errprint
{
	my $self = shift;
	$self->progress->errprint(@@_);
a115 1
	$self->progress->clear;
@


1.25
log
@as miod found out, mandocdb is slightly intrusive and wants to know where
you live (e.g., it expects to be able to get back to the directory it
started from, even when this one wasn't readable in the first place).

Do an extra chdir('/') to try to sidestep the issue.
@
text
@d2 1
a2 1
# $OpenBSD: AddCreateDelete.pm,v 1.24 2014/05/20 05:55:43 espie Exp $
d68 1
a68 1
	$state->SUPER::handle_options($opt_string.'L:mnx', @@usage);
d72 35
d178 23
@


1.24
log
@yet more code that no longer makes any sense
@
text
@d2 1
a2 1
# $OpenBSD: AddCreateDelete.pm,v 1.23 2014/05/20 05:46:13 espie Exp $
d94 1
d97 2
a98 1
		$state->vsystem(OpenBSD::Paths->makewhatis, @@$opts, '--', @@b);
d100 3
a102 1
	$state->vsystem(OpenBSD::Paths->makewhatis, @@$opts, '--', @@$l);
a103 1
}
@


1.23
log
@makewhatis being now external, it no longer requires picky/test/check_dir.
It also can't handle too many manpages at once (shell limit) so hand-feed
it (problem spotted by landry@@).

Some tests by schwarze@@.
@
text
@d2 1
a2 1
# $OpenBSD: AddCreateDelete.pm,v 1.22 2014/01/17 10:55:01 espie Exp $
a76 1
	my $verbose = $self;
@


1.22
log
@default signer less picky, just select by function, e.g., *pkg or *fw.
@
text
@d2 1
a2 1
# $OpenBSD: AddCreateDelete.pm,v 1.21 2014/01/14 10:05:58 espie Exp $
d74 1
a74 2
# those are required for makewhatis integration
sub picky
d76 7
a82 1
	return shift->{picky};
d85 1
a85 1
sub testmode
d87 3
a89 1
	return shift->{testmode};
d92 1
a92 1
sub check_dir
d94 4
a97 3
	my ($self, $dir) = @@_;
	unless (-d $dir) {
		$self->fatal("#1: #2 is not a directory", $0, $dir);
d99 2
a101 1

@


1.21
log
@reorder signature checks, we can do much more upfront.
clean up temp files always.
use a regexp for allowed keys, put default key up in front still.
@
text
@d2 1
a2 1
# $OpenBSD: AddCreateDelete.pm,v 1.20 2014/01/12 11:18:57 espie Exp $
a114 6
			require OpenBSD::Paths;

			my $cmd = OpenBSD::Paths->uname." -r";
			my $value = `$cmd`;
			$value =~ s/\.//;
			chomp $value;
d116 1
a116 1
				return [$value."fw", qr{^\d+fw$}];
d118 1
a118 1
				return [$value."pkg", qr{^\d+pkg$}];
@


1.20
log
@allow prev release keys for now, transition 5.4 -> 5.5 kindof requires
it.
@
text
@d2 1
a2 1
# $OpenBSD: AddCreateDelete.pm,v 1.19 2014/01/09 20:20:01 espie Exp $
a120 1
			my $previous = $value - 1;
d122 1
a122 1
				return [$value."fw", $previous."fw"];
d124 1
a124 1
				return [$value."pkg", $previous."pkg"];
@


1.19
log
@bump copyright to 2014
@
text
@d2 1
a2 1
# $OpenBSD: AddCreateDelete.pm,v 1.18 2014/01/09 10:36:52 espie Exp $
d121 1
d123 1
a123 1
				return [$value."fw"];
d125 1
a125 1
				return [$value."pkg"];
@


1.18
log
@tweak signing yet again. Have pkg_create automatically add signing
identities every time, and make matching identities mandatory.
e.g., pkg_create and pkg_add must have matching -DSIGNER.
by default, signer is derived from uname -r and role (pkg_add/fw_update),
e.g., 54pkg, 54fw...
@
text
@d2 1
a2 1
# $OpenBSD: AddCreateDelete.pm,v 1.17 2013/12/23 16:50:29 espie Exp $
d4 1
a4 1
# Copyright (c) 2007-2010 Marc Espie <espie@@openbsd.org>
@


1.17
log
@move ntogo code, so it can be used while copying packages in pkg_create.
add the few lines necessary for that to work.
@
text
@d2 1
a2 1
# $OpenBSD: AddCreateDelete.pm,v 1.16 2012/05/01 10:18:13 espie Exp $
d108 20
@


1.16
log
@properly pass extra parameters from State->new to init.
@
text
@d2 1
a2 1
# $OpenBSD$
d91 16
@


1.15
log
@put back -L in handle_options, so that it works in pkg_add/pkg_delete/pkg_create

prompted by jmc@@, noticed by Gregory Edigarov
@
text
@d2 1
a2 1
# $OpenBSD: AddCreateDelete.pm,v 1.14 2011/03/07 09:26:47 espie Exp $
d36 1
a36 1
	$self->SUPER::init;
@


1.14
log
@run makewhatis during pkg_create in verbose mode.
tweak temp manpage generation a bit, so that it has correct names in its
own directory, because makewhatis will be really pissed off otherwise.
@
text
@d2 1
a2 1
# $OpenBSD: AddCreateDelete.pm,v 1.13 2010/12/24 09:04:14 espie Exp $
d68 1
a68 1
	$state->SUPER::handle_options($opt_string.'mnx', @@usage);
@


1.13
log
@handle failures from ports tree with more care.
this does avoid infinite loops in case of wrong plists.
necessary since print-plist-with-depends CAN fail...
@
text
@d2 1
a2 1
# $OpenBSD$
d72 19
@


1.12
log
@don't use the fullwidth of the term by default, makes typing easier.
pass state thru so that we can check in /etc/pkg.conf and use it if we want.
@
text
@@


1.11
log
@fix pkg_mklocatedb
@
text
@d2 1
a2 1
# $OpenBSD: AddCreateDelete.pm,v 1.10 2010/06/30 10:51:04 espie Exp $
d70 1
a70 1
	$state->progress->setup($state->opt('x'), $state->opt('m'));
@


1.10
log
@allow say and errsay to work without parameters, as it's ways common.
create verbose_system up in state, because it makes sense without verbose.
@
text
@d2 1
a2 1
# $OpenBSD$
d37 1
@


1.9
log
@whitespace cleanup
@
text
@@


1.8
log
@do options the other way so that we provide defaults that can be overridden
locally
@
text
@d2 1
a2 1
# $OpenBSD: AddCreateDelete.pm,v 1.7 2010/06/25 10:19:00 espie Exp $
@


1.7
log
@move common options (-D/-v) handling code upto State.
rework handle_options to be code in state proper, so that I can remove
a class that's actually useless.
reuse the export code from getopt so that legacy code still get opt_x
working.
@
text
@d2 1
a2 1
# $OpenBSD: AddCreateDelete.pm,v 1.6 2010/06/15 08:35:11 espie Exp $
d67 1
a67 1
	$state->SUPER::handle_options('mnx'.$opt_string, @@usage);
@


1.6
log
@typo2
@
text
@d2 1
a2 1
# $OpenBSD: AddCreateDelete.pm,v 1.5 2010/06/15 08:30:37 espie Exp $
a26 1
use OpenBSD::Subst;
a33 1
	$self->{subst} = OpenBSD::Subst->new;
a44 6
sub verbose
{
	my $self = shift;
	return $self->{v};
}

a50 6
sub opt
{
	my ($self, $k) = @@_;
	return $self->{opt}{$k};
}

d63 10
a73 1
use OpenBSD::Getopt;
d79 1
a79 14


	$state->{opt}{v} = 0;
	$state->{opt}{h} = sub { $state->usage; };
	$state->{opt}{D} = sub {
		$state->{subst}->parse_option(shift);
	};
	$state->usage_is(@@usage);
	$state->do_options(sub {
		getopts('hmnvxD:'.$opt_string, $state->{opt});
	});
	$state->progress->setup($state->opt('x'), $state->opt('m'));
	$state->{v} = $state->opt('v');
	$state->{not} = $state->opt('n');
@


1.5
log
@with more primitive primitives, we don't need to override so much...
@
text
@d2 1
a2 1
# $OpenBSD: AddCreateDelete.pm,v 1.4 2010/06/09 11:57:21 espie Exp $
d74 1
a74 1
	$self->progress->_errprint(@@_);
@


1.4
log
@common pattern reuse
@
text
@d2 1
a2 1
# $OpenBSD$
d65 1
a65 1
sub print
d68 1
a68 1
	$self->progress->print($self->f(@@_));
d71 1
a71 1
sub say
d74 1
a74 13
	$self->progress->print($self->f(@@_), "\n");
}

sub errprint
{
	my $self = shift;
	$self->progress->errprint($self->f(@@_));
}

sub errsay
{
	my $self = shift;
	$self->progress->errprint($self->f(@@_), "\n");
@


1.3
log
@ui changes: go thru a state object for most printouts
@
text
@d2 1
a2 1
# $OpenBSD: AddCreateDelete.pm,v 1.2 2010/06/05 09:15:55 espie Exp $
d104 1
a104 1
	try {
d106 1
a106 3
	} catchall {
		$state->usage("#1", $_);
	};
@


1.2
log
@move use to common part
@
text
@d2 1
a2 1
# $OpenBSD: AddCreateDelete.pm,v 1.1 2010/06/04 13:19:39 espie Exp $
d25 2
d28 1
a30 8
sub new
{
	my $class = shift;
	my $o = bless {}, $class;
	$o->init(@@_);
	return $o;
}

d38 1
d68 1
a68 1
	$self->progress->print(@@_);
d74 1
a74 1
	$self->progress->print(@@_, "\n");
d80 1
a80 1
	$self->progress->errprint(@@_);
d86 1
a86 1
	$self->progress->errprint(@@_, "\n");
d99 1
a99 1
	$state->{opt}{h} = sub { Usage(); };
d103 1
a103 1
	set_usage(@@usage);
d107 1
a107 1
		Usage($_);
@


1.1
log
@move code around, so that commands can be used as modules.
pkg becomes the start hub, which does nothing except require the
correct module.
Saner code wrt Add/Delete, and more sharing.
@
text
@d2 1
a2 1
# $OpenBSD: AddDelete.pm,v 1.20 2010/05/10 09:17:55 espie Exp $
d25 2
@

