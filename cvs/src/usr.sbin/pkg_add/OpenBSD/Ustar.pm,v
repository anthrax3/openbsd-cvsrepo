head	1.88;
access;
symbols
	OPENBSD_6_2:1.88.0.4
	OPENBSD_6_2_BASE:1.88
	OPENBSD_6_1:1.87.0.6
	OPENBSD_6_1_BASE:1.87
	OPENBSD_6_0:1.87.0.4
	OPENBSD_6_0_BASE:1.87
	OPENBSD_5_9:1.86.0.4
	OPENBSD_5_9_BASE:1.86
	OPENBSD_5_8:1.86.0.6
	OPENBSD_5_8_BASE:1.86
	OPENBSD_5_7:1.86.0.2
	OPENBSD_5_7_BASE:1.86
	OPENBSD_5_6:1.80.0.4
	OPENBSD_5_6_BASE:1.80
	OPENBSD_5_5:1.77.0.4
	OPENBSD_5_5_BASE:1.77
	OPENBSD_5_4:1.72.0.6
	OPENBSD_5_4_BASE:1.72
	OPENBSD_5_3:1.72.0.4
	OPENBSD_5_3_BASE:1.72
	OPENBSD_5_2:1.72.0.2
	OPENBSD_5_2_BASE:1.72
	OPENBSD_5_1_BASE:1.71
	OPENBSD_5_1:1.71.0.4
	OPENBSD_5_0:1.71.0.2
	OPENBSD_5_0_BASE:1.71
	OPENBSD_4_9:1.70.0.2
	OPENBSD_4_9_BASE:1.70
	OPENBSD_4_8:1.62.0.2
	OPENBSD_4_8_BASE:1.62
	OPENBSD_4_7:1.54.0.2
	OPENBSD_4_7_BASE:1.54
	OPENBSD_4_6:1.51.0.4
	OPENBSD_4_6_BASE:1.51
	OPENBSD_4_5:1.50.0.8
	OPENBSD_4_5_BASE:1.50
	OPENBSD_4_4:1.50.0.6
	OPENBSD_4_4_BASE:1.50
	OPENBSD_4_3:1.50.0.4
	OPENBSD_4_3_BASE:1.50
	OPENBSD_4_2:1.50.0.2
	OPENBSD_4_2_BASE:1.50
	OPENBSD_4_1:1.44.0.2
	OPENBSD_4_1_BASE:1.44
	OPENBSD_4_0:1.42.0.2
	OPENBSD_4_0_BASE:1.42
	OPENBSD_3_9:1.40.0.2
	OPENBSD_3_9_BASE:1.40
	OPENBSD_3_8:1.35.0.2
	OPENBSD_3_8_BASE:1.35
	OPENBSD_3_7:1.15.0.2
	OPENBSD_3_7_BASE:1.15
	OPENBSD_3_6:1.9.0.2
	OPENBSD_3_6_BASE:1.9
	OPENBSD_3_5:1.7.0.2
	OPENBSD_3_5_BASE:1.7
	pkgtools:1.1.1.1
	espie:1.1.1;
locks; strict;
comment	@# @;


1.88
date	2017.07.23.10.34.44;	author espie;	state Exp;
branches;
next	1.87;
commitid	dQ9nfsTBHWBhI8jq;

1.87
date	2016.04.02.11.07.50;	author espie;	state Exp;
branches;
next	1.86;
commitid	6RMXQjEbkVWrftL4;

1.86
date	2015.01.04.14.10.20;	author espie;	state Exp;
branches;
next	1.85;
commitid	xYfsnhxsU1KFmOcD;

1.85
date	2014.11.20.11.39.29;	author espie;	state Exp;
branches;
next	1.84;
commitid	95cel0oO7vtIujDy;

1.84
date	2014.09.01.11.29.15;	author espie;	state Exp;
branches;
next	1.83;
commitid	HEW5hJiBH3ZICwFH;

1.83
date	2014.08.10.10.04.39;	author espie;	state Exp;
branches;
next	1.82;
commitid	WmPwEcdhYQ4cu18I;

1.82
date	2014.08.10.10.03.46;	author espie;	state Exp;
branches;
next	1.81;
commitid	9v9ExMO6Ai06DWrY;

1.81
date	2014.08.10.10.01.03;	author espie;	state Exp;
branches;
next	1.80;
commitid	TVTGkMkybHLfxISy;

1.80
date	2014.07.23.14.35.17;	author espie;	state Exp;
branches;
next	1.79;
commitid	mE7qJMD6lDUJNqBh;

1.79
date	2014.07.07.16.43.55;	author espie;	state Exp;
branches;
next	1.78;
commitid	e9IeHCLb7Kc19weh;

1.78
date	2014.04.21.11.42.31;	author espie;	state Exp;
branches;
next	1.77;

1.77
date	2014.01.17.15.39.53;	author espie;	state Exp;
branches;
next	1.76;

1.76
date	2014.01.13.18.42.34;	author espie;	state Exp;
branches;
next	1.75;

1.75
date	2014.01.09.20.20.01;	author espie;	state Exp;
branches;
next	1.74;

1.74
date	2014.01.07.00.48.24;	author espie;	state Exp;
branches;
next	1.73;

1.73
date	2014.01.05.23.11.24;	author espie;	state Exp;
branches;
next	1.72;

1.72
date	2012.04.28.12.00.10;	author espie;	state Exp;
branches;
next	1.71;

1.71
date	2011.03.20.08.17.24;	author espie;	state Exp;
branches;
next	1.70;

1.70
date	2011.01.03.19.02.01;	author espie;	state Exp;
branches;
next	1.69;

1.69
date	2011.01.03.14.22.48;	author jasper;	state Exp;
branches;
next	1.68;

1.68
date	2011.01.03.00.12.06;	author espie;	state Exp;
branches;
next	1.67;

1.67
date	2011.01.02.14.39.18;	author espie;	state Exp;
branches;
next	1.66;

1.66
date	2010.12.24.09.04.14;	author espie;	state Exp;
branches;
next	1.65;

1.65
date	2010.10.02.13.36.56;	author espie;	state Exp;
branches;
next	1.64;

1.64
date	2010.09.14.10.02.37;	author espie;	state Exp;
branches;
next	1.63;

1.63
date	2010.08.23.05.36.20;	author kili;	state Exp;
branches;
next	1.62;

1.62
date	2010.07.28.15.05.33;	author espie;	state Exp;
branches;
next	1.61;

1.61
date	2010.07.28.12.19.54;	author espie;	state Exp;
branches;
next	1.60;

1.60
date	2010.07.04.19.34.47;	author espie;	state Exp;
branches;
next	1.59;

1.59
date	2010.06.30.10.51.04;	author espie;	state Exp;
branches;
next	1.58;

1.58
date	2010.06.30.10.41.42;	author espie;	state Exp;
branches;
next	1.57;

1.57
date	2010.06.30.10.10.17;	author espie;	state Exp;
branches;
next	1.56;

1.56
date	2010.05.10.09.17.55;	author espie;	state Exp;
branches;
next	1.55;

1.55
date	2010.03.22.20.38.44;	author espie;	state Exp;
branches;
next	1.54;

1.54
date	2009.12.17.11.57.02;	author espie;	state Exp;
branches;
next	1.53;

1.53
date	2009.12.17.11.07.24;	author espie;	state Exp;
branches;
next	1.52;

1.52
date	2009.11.10.11.36.56;	author espie;	state Exp;
branches;
next	1.51;

1.51
date	2009.04.19.14.58.32;	author espie;	state Exp;
branches;
next	1.50;

1.50
date	2007.06.16.09.29.37;	author espie;	state Exp;
branches;
next	1.49;

1.49
date	2007.06.12.09.53.36;	author espie;	state Exp;
branches;
next	1.48;

1.48
date	2007.06.04.14.40.39;	author espie;	state Exp;
branches;
next	1.47;

1.47
date	2007.05.02.15.05.30;	author espie;	state Exp;
branches;
next	1.46;

1.46
date	2007.04.15.10.17.29;	author espie;	state Exp;
branches;
next	1.45;

1.45
date	2007.04.14.12.38.12;	author espie;	state Exp;
branches;
next	1.44;

1.44
date	2007.02.22.21.40.39;	author espie;	state Exp;
branches;
next	1.43;

1.43
date	2006.11.17.15.34.15;	author espie;	state Exp;
branches;
next	1.42;

1.42
date	2006.08.05.08.21.55;	author espie;	state Exp;
branches;
next	1.41;

1.41
date	2006.03.21.18.41.34;	author espie;	state Exp;
branches;
next	1.40;

1.40
date	2005.10.26.09.47.48;	author espie;	state Exp;
branches;
next	1.39;

1.39
date	2005.10.26.09.35.32;	author espie;	state Exp;
branches;
next	1.38;

1.38
date	2005.09.24.12.07.38;	author espie;	state Exp;
branches;
next	1.37;

1.37
date	2005.09.20.20.06.48;	author espie;	state Exp;
branches;
next	1.36;

1.36
date	2005.09.13.09.30.55;	author espie;	state Exp;
branches;
next	1.35;

1.35
date	2005.08.10.14.02.22;	author espie;	state Exp;
branches;
next	1.34;

1.34
date	2005.08.05.10.36.53;	author espie;	state Exp;
branches;
next	1.33;

1.33
date	2005.08.05.10.03.10;	author espie;	state Exp;
branches;
next	1.32;

1.32
date	2005.08.05.10.01.38;	author espie;	state Exp;
branches;
next	1.31;

1.31
date	2005.07.25.11.26.01;	author espie;	state Exp;
branches;
next	1.30;

1.30
date	2005.07.20.15.35.33;	author espie;	state Exp;
branches;
next	1.29;

1.29
date	2005.06.26.15.39.19;	author espie;	state Exp;
branches;
next	1.28;

1.28
date	2005.06.21.17.52.49;	author espie;	state Exp;
branches;
next	1.27;

1.27
date	2005.06.20.13.27.37;	author espie;	state Exp;
branches;
next	1.26;

1.26
date	2005.06.18.13.17.11;	author espie;	state Exp;
branches;
next	1.25;

1.25
date	2005.06.18.12.52.29;	author espie;	state Exp;
branches;
next	1.24;

1.24
date	2005.06.18.11.42.49;	author espie;	state Exp;
branches;
next	1.23;

1.23
date	2005.06.13.18.38.59;	author espie;	state Exp;
branches;
next	1.22;

1.22
date	2005.06.13.18.11.44;	author espie;	state Exp;
branches;
next	1.21;

1.21
date	2005.06.13.14.24.06;	author espie;	state Exp;
branches;
next	1.20;

1.20
date	2005.06.13.13.11.11;	author espie;	state Exp;
branches;
next	1.19;

1.19
date	2005.06.13.12.51.18;	author espie;	state Exp;
branches;
next	1.18;

1.18
date	2005.06.13.12.46.47;	author espie;	state Exp;
branches;
next	1.17;

1.17
date	2005.06.13.12.22.37;	author espie;	state Exp;
branches;
next	1.16;

1.16
date	2005.06.13.12.12.34;	author espie;	state Exp;
branches;
next	1.15;

1.15
date	2004.12.26.15.18.51;	author espie;	state Exp;
branches;
next	1.14;

1.14
date	2004.12.13.18.50.23;	author espie;	state Exp;
branches;
next	1.13;

1.13
date	2004.12.11.14.05.13;	author espie;	state Exp;
branches;
next	1.12;

1.12
date	2004.11.01.15.44.11;	author espie;	state Exp;
branches;
next	1.11;

1.11
date	2004.11.01.15.21.48;	author espie;	state Exp;
branches;
next	1.10;

1.10
date	2004.09.14.22.40.01;	author espie;	state Exp;
branches;
next	1.9;

1.9
date	2004.08.06.08.06.01;	author espie;	state Exp;
branches;
next	1.8;

1.8
date	2004.08.06.07.51.17;	author espie;	state Exp;
branches;
next	1.7;

1.7
date	2004.02.15.15.33.59;	author espie;	state Exp;
branches;
next	1.6;

1.6
date	2004.01.29.13.06.39;	author espie;	state Exp;
branches;
next	1.5;

1.5
date	2004.01.27.23.25.31;	author espie;	state Exp;
branches;
next	1.4;

1.4
date	2003.12.19.00.29.20;	author espie;	state Exp;
branches;
next	1.3;

1.3
date	2003.12.10.17.45.11;	author espie;	state Exp;
branches;
next	1.2;

1.2
date	2003.10.31.09.30.10;	author espie;	state Exp;
branches;
next	1.1;

1.1
date	2003.10.16.17.43.34;	author espie;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2003.10.16.17.43.34;	author espie;	state Exp;
branches;
next	;


desc
@@


1.88
log
@recent perls have more fun rules related to _ and -
@
text
@# ex:ts=8 sw=4:
# $OpenBSD: Ustar.pm,v 1.87 2016/04/02 11:07:50 espie Exp $
#
# Copyright (c) 2002-2014 Marc Espie <espie@@openbsd.org>
#
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

# Handle utar archives

use strict;
use warnings;

package OpenBSD::Ustar;

use constant {
	FILE => "\0",
	FILE1 => '0',
	HARDLINK => '1',
	SOFTLINK => '2',
	CHARDEVICE => '3',
	BLOCKDEVICE => '4',
	DIR => '5',
	FIFO => '6',
	CONTFILE => '7',
	USTAR_HEADER => 'a100a8a8a8a12a12a8aa100a6a2a32a32a8a8a155a12',
	MAXFILENAME => 100,
	MAXLINKNAME => 100,
	MAXPREFIX => 155,
	MAXUSERNAME => 32,
	MAXGROUPNAME => 32,
	XHDR => 'x',
	# XXX those are NOT supported, just recognized
	GHDR => 'g',
	LONGLINK => 'K',
	LONGNAME => 'L',
};

use File::Basename ();
use OpenBSD::IdCache;
use OpenBSD::Paths;

our $uidcache = new OpenBSD::UidCache;
our $gidcache = new OpenBSD::GidCache;
our $unamecache = new OpenBSD::UnameCache;
our $gnamecache = new OpenBSD::GnameCache;

# This is a multiple of st_blksize everywhere....
my $buffsize = 2 * 1024 * 1024;

sub new
{
	my ($class, $fh, $state, $destdir) = @@_;

	$destdir = '' unless defined $destdir;

	return bless {
	    fh => $fh,
	    swallow => 0,
	    state => $state,
	    key => {},
	    destdir => $destdir} , $class;
}

sub set_description
{
	my ($self, $d) = @@_;
	$self->{description} = $d;
}

sub set_callback
{
	my ($self, $code) = @@_;
	$self->{callback} = $code;
}

sub fatal
{
	my ($self, $msg, @@args) = @@_;
	$self->{state}->fatal("Ustar [#1][#2]: #3",
	    $self->{description} // '?', $self->{lastname} // '?',
	    $self->{state}->f($msg, @@args));
}

sub new_object
{
	my ($self, $h, $class) = @@_;
	$h->{archive} = $self;
	$h->{destdir} = $self->{destdir};
	bless $h, $class;
	return $h;
}

sub skip
{
	my $self = shift;
	my $temp;

	while ($self->{swallow} > 0) {
		my $toread = $self->{swallow};
		if ($toread >$buffsize) {
			$toread = $buffsize;
		}
		my $actual = read($self->{fh}, $temp, $toread);
		if (!defined $actual) {
			$self->fatal("Error while skipping archive: #1", $!);
		}
		if ($actual == 0) {
			$self->fatal("Premature end of archive in header: #1", $!);
		}
		$self->{swallow} -= $actual;
	}
}

my $types = {
	DIR , 'OpenBSD::Ustar::Dir',
	HARDLINK , 'OpenBSD::Ustar::HardLink',
	SOFTLINK , 'OpenBSD::Ustar::SoftLink',
	FILE , 'OpenBSD::Ustar::File',
	FILE1 , 'OpenBSD::Ustar::File',
	FIFO , 'OpenBSD::Ustar::Fifo',
	CHARDEVICE , 'OpenBSD::Ustar::CharDevice',
	BLOCKDEVICE , 'OpenBSD::Ustar::BlockDevice',
};

my $unsupported = {
	XHDR => 'Extended header',
	GHDR => 'GNU header',
	LONGLINK => 'Long symlink',
	LONGNAME => 'Long file',
};
	
sub read_records
{
	my ($self, $size) = @@_;
	my $toread = $self->{swallow};
	my $result = '';
	while ($toread > 0) {
		my $buffer;
		my $maxread = $buffsize;
		$maxread = $toread if $maxread > $toread;
		my $actual = read($self->{fh}, $buffer, $maxread);
		if (!defined $actual) {
			$self->fatal("Error reading from archive: #1", $!);
		}
		if ($actual == 0) {
			$self->fatal("Premature end of archive");
		}
		$self->{swallow} -= $actual;
		$toread -= $actual;
		$result .= $buffer;
	}
	return substr($result, 0, $size);
}

sub parse_records
{
	my ($self, $result, $h) = @@_;
	open(my $fh, '<', \$h);
	while (<$fh>) {
		chomp;
		if (m/^(\d+)\s+(\w+?)\=(.*)$/) {
			my ($k, $v) = ($2, $3);
			if ($k eq 'path') {
				$result->{name} = $v;
			} elsif ($k eq 'linkpath') {
				$result->{linkname} = $v;
			}
		}
	}
}

sub next
{
	my $self = shift;
	# get rid of the current object
	$self->skip;
	my $header;
	my $n = read($self->{fh}, $header, 512);
	return if (defined $n) and $n == 0;
	$self->fatal("Error while reading header")
	    unless defined $n and $n == 512;
	if ($header eq "\0"x512) {
		return $self->next;
	}
	# decode header
	my ($name, $mode, $uid, $gid, $size, $mtime, $chksum, $type,
	    $linkname, $magic, $version, $uname, $gname, $major, $minor,
	    $prefix, $pad) = unpack(USTAR_HEADER, $header);
	if ($magic ne "ustar\0" || $version ne '00') {
		$self->fatal("Not an ustar archive header");
	}
	# verify checksum
	my $value = $header;
	substr($value, 148, 8) = " "x8;
	my $ck2 = unpack("%C*", $value);
	if ($ck2 != oct($chksum)) {
		$self->fatal("Bad archive checksum");
	}
	$name =~ s/\0*$//o;
	$mode = oct($mode) & 0xfff;
	$uname =~ s/\0*$//o;
	$gname =~ s/\0*$//o;
	$linkname =~ s/\0*$//o;
	$major = oct($major);
	$minor = oct($minor);
	$uid = oct($uid);
	$gid = oct($gid);
	$uid = $uidcache->lookup($uname, $uid);
	$gid = $gidcache->lookup($gname, $gid);
	{
		no warnings; # XXX perl warns if oct converts >= 2^32 values
		$mtime = oct($mtime);
	}
	unless ($prefix =~ m/^\0/o) {
		$prefix =~ s/\0*$//o;
		$name = "$prefix/$name";
	}

	$self->{lastname} = $name;
	$size = oct($size);
	my $result= {
	    name => $name,
	    mode => $mode,
	    atime => $mtime,
	    mtime => $mtime,
	    linkname=> $linkname,
	    uname => $uname,
	    uid => $uid,
	    gname => $gname,
	    gid => $gid,
	    size => $size,
	    major => $major,
	    minor => $minor,
	};
	# adjust swallow
	$self->{swallow} = $size;
	if ($size % 512) {
		$self->{swallow} += 512 - $size % 512;
	}
	if ($type eq XHDR) {
		my $h = $self->read_records($size);
		$result = $self->next;
		$self->parse_records($result, $h);
		return $result;
	}
	if (defined $types->{$type}) {
		$self->new_object($result, $types->{$type});
	} else {
		$self->fatal("Unsupported type #1 (#2)", $type,
		    $unsupported->{$type} // "unknown");
	}
	if (!$result->isFile && $result->{size} != 0) {
		$self->fatal("Bad archive: non null size for #1 (#2)",
		    $types->{$type}, $result->{name});
	}

	$self->{cachename} = $name;
	return $result;
}

sub split_name
{
	my $name = shift;
	my $prefix = '';

	my $l = length $name;
	if ($l > MAXFILENAME && $l <= MAXFILENAME+MAXPREFIX+1) {
		while (length($name) > MAXFILENAME &&
		    $name =~ m/^(.*?\/)(.*)$/o) {
			$prefix .= $1;
			$name = $2;
		}
		$prefix =~ s|/$||;
	}
	return ($prefix, $name);
}

sub extended_record
{
	my ($k, $v) = @@_;
	my $string = " $k=$v\n";
	my $len = length($string);
	if ($len < 995) {
		return sprintf("%3d", $len+3).$string;
	} elsif ($len < 9995) {
		return sprintf("%04d", $len+4).$string;
	} else {
		return sprintf("%05d", $len+5).$string;
	}
}

sub pack_header
{
	my ($archive, $type, $size, $entry, $prefix, $name, $linkname, 
		$uname, $gname, $major, $minor) = @@_;

	my $header;
	my $cksum = ' 'x8;
	for (1 .. 2) {
		$header = pack(USTAR_HEADER,
		    $name,
		    sprintf("%07o", $entry->{mode}),
		    sprintf("%07o", $entry->{uid} // 0),
		    sprintf("%07o", $entry->{gid} // 0),
		    sprintf("%011o", $size),
		    sprintf("%011o", $entry->{mtime} // 0),
		    $cksum,
		    $type,
		    $linkname,
		    'ustar', '00',
		    $uname,
		    $gname,
		    sprintf("%07o", $major),
		    sprintf("%07o", $minor),
		    $prefix, "\0");
		$cksum = sprintf("%07o", unpack("%C*", $header));
	}
	return $header;
}

my $whatever = "usualSuspect000";

sub mkheader
{
	my ($archive, $entry, $type) = @@_;
	my ($prefix, $name) = split_name($entry->name);
	my ($extendedname, $extendedlink);
	my $linkname = $entry->{linkname};
	my $size = $entry->{size};
	my ($major, $minor);
	if ($entry->isDevice) {
		$major = $entry->{major};
		$minor = $entry->{minor};
	} else {
		$major = 0;
		$minor = 0;
	}
	my ($uname, $gname);
	if (defined $entry->{uname}) {
		$uname = $entry->{uname};
	} else {
		$uname = $entry->{uid};
	}
	if (defined $entry->{gname}) {
		$gname = $entry->{gname};
	} else {
		$gname = $entry->{gid};
	}

	if (defined $entry->{cwd}) {
		my $cwd = $entry->{cwd};
		$cwd.='/' unless $cwd =~ m/\/$/o;
		$linkname =~ s/^\Q$cwd\E//;
	}
	if (!defined $linkname) {
		$linkname = '';
	}
	if (length $prefix > MAXPREFIX) {
		$prefix = substr($prefix, 0, MAXPREFIX);
		$extendedname = 1;
	}
	if (length $name > MAXFILENAME) {
		$name = substr($name, 0, MAXPREFIX);
		$extendedname = 1;
	}
	if (length $linkname > MAXLINKNAME) {
		$linkname = substr($linkname, 0, MAXLINKNAME);
		$extendedlink = 1;
	}
	if (length $uname > MAXUSERNAME) {
		$archive->fatal("Username too long #1", $uname);
	}
	if (length $gname > MAXGROUPNAME) {
		$archive->fatal("Groupname too long #1", $gname);
	}
	my $header = $archive->pack_header($type, $size, $entry, 
	    $prefix, $name, $linkname, $uname, $gname, $major, $minor);
	my $x;
	if ($extendedname) {
		$x .= extended_record("path", $entry->name);
	}
	if ($extendedlink) {
		$x .= extended_record("linkpath",$entry->{linkname});
	}
	if ($x) {
		my $extended = $archive->pack_header(XHDR, length($x), $entry,
		    '', $whatever, '', $uname, $gname, $major, $minor);
		$whatever++;
		if ((length $x) % 512) {
			$x .= "\0" x (512 - ((length $x) % 512));
		}
		return $extended.$x.$header;
	}
	return $header;
}

sub prepare
{
	my ($self, $filename, $destdir) = @@_;

	$destdir //= $self->{destdir};
	my $realname = "$destdir/$filename";

	my ($dev, $ino, $mode, $uid, $gid, $rdev, $size, $mtime) =
	    (lstat $realname)[0,1,2, 4,5,6,7, 9];

	my $entry = {
		key => "$dev/$ino",
		name => $filename,
		realname => $realname,
		mode => $mode,
		uid => $uid,
		gid => $gid,
		size => $size,
		mtime => $mtime,
		uname => $unamecache->lookup($uid),
		gname => $gnamecache->lookup($gid),
		major => $rdev/256,
		minor => $rdev%256,
	};
	my $k = $entry->{key};
	my $class = "OpenBSD::Ustar::File"; # default
	if (defined $self->{key}{$k}) {
		$entry->{linkname} = $self->{key}{$k};
		$class = "OpenBSD::Ustar::HardLink";
	} elsif (-l $realname) {
		$entry->{linkname} = readlink($realname);
		$class = "OpenBSD::Ustar::SoftLink";
	} elsif (-p _) {
		$class = "OpenBSD::Ustar::Fifo";
	} elsif (-c _) {
		$class = "OpenBSD::Ustar::CharDevice";
	} elsif (-b _) {
		$class ="OpenBSD::Ustar::BlockDevice";
	} elsif (-d _) {
		$class = "OpenBSD::Ustar::Dir";
	}
	$self->new_object($entry, $class);
	if (!$entry->isFile) {
		$entry->{size} = 0;
	}
	return $entry;
}

sub pad
{
	my $self = shift;
	my $fh = $self->{fh};
	print $fh "\0"x1024 or $self->fatal("Error writing to archive: #1", $!);
}

sub close
{
	my $self = shift;
	if (defined $self->{padout}) {
	    $self->pad;
	}
	close($self->{fh});
}

sub destdir
{
	my $self = shift;
	if (@@_ > 0) {
		$self->{destdir} = shift;
	} else {
		return $self->{destdir};
	}
}

sub fh
{
	return $_[0]->{fh};
}

package OpenBSD::Ustar::Object;

sub recheck_owner
{
	my $entry = shift;
	# XXX weird format to prevent cvs from expanding OpenBSD id
	$entry->{uid} //= $OpenBSD::Ustar::uidcache
	    ->lookup($entry->{uname});
	$entry->{gid} //= $OpenBSD::Ustar::gidcache
	    ->lookup($entry->{gname});
}

sub fatal
{
	my ($self, @@args) = @@_;
	$self->{archive}->fatal(@@args);
}

sub system
{
	my ($self, @@args) = @@_;
	$self->{archive}{state}->system(@@args);
}

sub errsay
{
	my ($self, @@args) = @@_;
	$self->{archive}{state}->errsay(@@args);
}
sub left_todo
{
	my ($self, $toread) = @@_;
	return if $toread == 0;
	return unless defined $self->{archive}{callback};
	&{$self->{archive}{callback}}($self->{size} - $toread);
}

sub name
{
	my $self = shift;
	return $self->{name};
}

sub set_name
{
	my ($self, $v) = @@_;
	$self->{name} = $v;
}

sub set_modes
{
	my $self = shift;
	chown $self->{uid}, $self->{gid}, $self->{destdir}.$self->name;
	chmod $self->{mode}, $self->{destdir}.$self->name;
	if (defined $self->{mtime} || defined $self->{atime}) {
		utime $self->{atime} // time, $self->{mtime} // time,
		    $self->{destdir}.$self->name;
	}
}

sub ensure_dir
{
	my ($self, $dir) = @@_;
	return if -d $dir;
	$self->ensure_dir(File::Basename::dirname($dir));
	if (mkdir($dir)) {
		return;
	}
	$self->fatal("Error making directory #1: #2", $dir, $!);
}

sub make_basedir
{
	my $self = shift;
	my $dir = $self->{destdir}.File::Basename::dirname($self->name);
	$self->ensure_dir($dir);
}

sub write
{
	my $self = shift;
	my $arc = $self->{archive};
	my $out = $arc->{fh};

	$arc->{padout} = 1;
	my $header = $arc->mkheader($self, $self->type);
	print $out $header or $self->fatal("Error writing to archive: #1", $!);
	$self->write_contents($arc);
	my $k = $self->{key};
	if (!defined $arc->{key}{$k}) {
		$arc->{key}{$k} = $self->name;
	}
}

sub alias
{
	my ($self, $arc, $alias) = @@_;

	my $k = $self->{archive}.":".$self->{archive}{cachename};
	if (!defined $arc->{key}{$k}) {
		$arc->{key}{$k} = $alias;
	}
}

sub write_contents
{
	# only files have anything to write
}

sub resolve_links
{
	# only hard links must cheat
}

sub copy_contents
{
	# only files need copying
}

sub copy
{
	my ($self, $wrarc) = @@_;
	my $out = $wrarc->{fh};
	$self->resolve_links($wrarc);
	$wrarc->{padout} = 1;
	my $header = $wrarc->mkheader($self, $self->type);
	print $out $header or $self->fatal("Error writing to archive: #1", $!);

	$self->copy_contents($wrarc);
}

sub isDir() { 0 }
sub isFile() { 0 }
sub isDevice() { 0 }
sub isFifo() { 0 }
sub isLink() { 0 }
sub isSymLink() { 0 }
sub isHardLink() { 0 }

package OpenBSD::Ustar::Dir;
our @@ISA=qw(OpenBSD::Ustar::Object);

sub create
{
	my $self = shift;
	$self->ensure_dir($self->{destdir}.$self->name);
	$self->set_modes;
}

sub isDir() { 1 }

sub type() { OpenBSD::Ustar::DIR }

package OpenBSD::Ustar::HardLink;
our @@ISA=qw(OpenBSD::Ustar::Object);

sub create
{
	my $self = shift;
	$self->make_basedir;
	my $linkname = $self->{linkname};
	if (defined $self->{cwd}) {
		$linkname=$self->{cwd}.'/'.$linkname;
	}
	link $self->{destdir}.$linkname, $self->{destdir}.$self->name or
	    $self->fatal("Can't link #1#2 to #1#3: #4",
	    	$self->{destdir}, $linkname, $self->name, $!);
}

sub resolve_links
{
	my ($self, $arc) = @@_;

	my $k = $self->{archive}.":".$self->{linkname};
	if (defined $arc->{key}{$k}) {
		$self->{linkname} = $arc->{key}{$k};
	} else {
		print join("\n", keys(%{$arc->{key}})), "\n";
		$self->fatal("Can't copy link over: original for #1 NOT available", $k);
	}
}

sub isLink() { 1 }
sub isHardLink() { 1 }

sub type() { OpenBSD::Ustar::HARDLINK }

package OpenBSD::Ustar::SoftLink;
our @@ISA=qw(OpenBSD::Ustar::Object);

sub create
{
	my $self = shift;
	$self->make_basedir;
	symlink $self->{linkname}, $self->{destdir}.$self->name or
	    $self->fatal("Can't symlink #1 to #2#3: #4",
	    	$self->{linkname}, $self->{destdir}, $self->name, $!);
	require POSIX;
	POSIX::lchown($self->{uid}, $self->{gid}, $self->{destdir}.$self->name);
}

sub isLink() { 1 }
sub isSymLink() { 1 }

sub type() { OpenBSD::Ustar::SOFTLINK }

package OpenBSD::Ustar::Fifo;
our @@ISA=qw(OpenBSD::Ustar::Object);

sub create
{
	my $self = shift;
	$self->make_basedir;
	require POSIX;
	POSIX::mkfifo($self->{destdir}.$self->name, $self->{mode}) or
	    $self->fatal("Can't create fifo #1#2: #3", $self->{destdir},
	    	$self->name, $!);
	$self->set_modes;
}

sub isFifo() { 1 }
sub type() { OpenBSD::Ustar::FIFO }

package OpenBSD::UStar::Device;
our @@ISA=qw(OpenBSD::Ustar::Object);

sub create
{
	my $self = shift;
	$self->make_basedir;
	$self->system(OpenBSD::Paths->mknod,
	    '-m', $self->{mode}, '--', $self->{destdir}.$self->name,
	    $self->devicetype, $self->{major}, $self->{minor});
	$self->set_modes;
}

sub isDevice() { 1 }

package OpenBSD::Ustar::BlockDevice;
our @@ISA=qw(OpenBSD::Ustar::Device);

sub type() { OpenBSD::Ustar::BLOCKDEVICE }
sub devicetype() { 'b' }

package OpenBSD::Ustar::CharDevice;
our @@ISA=qw(OpenBSD::Ustar::Device);

sub type() { OpenBSD::Ustar::BLOCKDEVICE }
sub devicetype() { 'c' }

package OpenBSD::CompactWriter;

use constant {
	FH => 0,
	BS => 1,
	ZEROES => 2,
	UNFINISHED => 3,
};

sub new
{
	my ($class, $fname) = @@_;
	open (my $out, '>', $fname) or return;
	my $bs = (stat $out)[11];
	my $zeroes;
	if (defined $bs) {
		$zeroes = "\x00"x$bs;
	}
	bless [ $out, $bs, $zeroes, 0 ], $class;
}

sub write
{
	my ($self, $buffer) = @@_;
	my ($fh, $bs, $zeroes, $e) = @@$self;
START:
	if (defined $bs) {
		for (my $i = 0; $i + $bs <= length($buffer); $i+= $bs) {
			if (substr($buffer, $i, $bs) eq $zeroes) {
				my $r = syswrite($fh, $buffer, $i);
				unless (defined $r && $r == $i) {
					return 0;
				}
				$i+=$bs;
				my $seek_forward = $bs;
				while (substr($buffer, $i, $bs) eq $zeroes) {
					$i += $bs;
					$seek_forward += $bs;
				}
				defined(sysseek($fh, $seek_forward, 1))
				    or return 0;
				$buffer = substr($buffer, $i);
				if (length $buffer == 0) {
					$self->[UNFINISHED] = 1;
					return 1;
				}
				goto START;
			}
		}
	}
	$self->[UNFINISHED] = 0;
	my $r = syswrite($fh, $buffer);
	if (defined $r && $r == length $buffer) {
		return 1;
	} else {
		return 0;
	}
}

sub close
{
	my ($self) = @@_;
	if ($self->[UNFINISHED]) {
		defined(sysseek($self->[FH], -1, 1)) or return 0;
		defined(syswrite($self->[FH], "\0")) or return 0;
	}
	return 1;
}

package OpenBSD::Ustar::File;
our @@ISA=qw(OpenBSD::Ustar::Object);

sub create
{
	my $self = shift;
	$self->make_basedir;
	my $buffer;
	my $out = OpenBSD::CompactWriter->new($self->{destdir}.$self->name);
	if (!defined $out) {
		$self->fatal("Can't write to #1#2: #3", $self->{destdir},
		    $self->name, $!);
	}
	my $toread = $self->{size};
	if ($self->{partial}) {
		$toread -= length($self->{partial});
		unless ($out->write($self->{partial})) {
			$self->fatal("Error writing to #1#2: #3",
			    $self->{destdir}, $self->name, $!);
		}
	}
	while ($toread > 0) {
		my $maxread = $buffsize;
		$maxread = $toread if $maxread > $toread;
		my $actual = read($self->{archive}{fh}, $buffer, $maxread);
		if (!defined $actual) {
			$self->fatal("Error reading from archive: #1", $!);
		}
		if ($actual == 0) {
			$self->fatal("Premature end of archive");
		}
		$self->{archive}{swallow} -= $actual;
		unless ($out->write($buffer)) {
			$self->fatal("Error writing to #1#2: #3",
			    $self->{destdir}, $self->name, $!);
		}

		$toread -= $actual;
		$self->left_todo($toread);
	}
	$out->close or $self->fatal("Error closing #1#2: #3",
	    $self->{destdir}, $self->name, $!);
	$self->set_modes;
}

sub contents
{
	my ($self, $lookfor) = @@_;
	my $toread = $self->{size};
	my $buffer;
	my $offset = 0;
	if ($self->{partial}) {
		$buffer = $self->{partial};
		$offset = length($self->{partial});
		$toread -= $offset;
	}

	while ($toread != 0) {
		my $sz = $toread;
		if (defined $lookfor) {
			last if (defined $buffer) and &$lookfor($buffer);
			$sz = 1024 if $sz > 1024;
		}
		my $actual = read($self->{archive}{fh}, $buffer, $sz, $offset);
		if (!defined $actual) {
			$self->fatal("Error reading from archive: #1", $!);
		}
		if ($actual != $sz) {
			$self->fatal("Error: short read from archive");
		}
		$self->{archive}{swallow} -= $actual;
		$toread -= $actual;
		$offset += $actual;
	}

	$self->{partial} = $buffer;
	return $buffer;
}

sub write_contents
{
	my ($self, $arc) = @@_;
	my $filename = $self->{realname};
	my $size = $self->{size};
	my $out = $arc->{fh};
	open my $fh, "<", $filename or $self->fatal("Can't read file #1: #2",
	    $filename, $!);

	my $buffer;
	my $toread = $size;
	while ($toread > 0) {
		my $maxread = $buffsize;
		$maxread = $toread if $maxread > $toread;
		my $actual = read($fh, $buffer, $maxread);
		if (!defined $actual) {
			$self->fatal("Error reading from file: #1", $!);
		}
		if ($actual == 0) {
			$self->fatal("Premature end of file");
		}
		unless (print $out $buffer) {
			$self->fatal("Error writing to archive: #1", $!);
		}

		$toread -= $actual;
		$self->left_todo($toread);
	}
	if ($size % 512) {
		print $out "\0" x (512 - $size % 512) or
		    $self->fatal("Error writing to archive: #1", $!);
	}
}

sub copy_contents
{
	my ($self, $arc) = @@_;
	my $out = $arc->{fh};
	my $buffer;
	my $size = $self->{size};
	my $toread = $size;
	while ($toread > 0) {
		my $maxread = $buffsize;
		$maxread = $toread if $maxread > $toread;
		my $actual = read($self->{archive}{fh}, $buffer, $maxread);
		if (!defined $actual) {
			$self->fatal("Error reading from archive: #1", $!);
		}
		if ($actual == 0) {
			$self->fatal("Premature end of archive");
		}
		$self->{archive}{swallow} -= $actual;
		unless (print $out $buffer) {
			$self->fatal("Error writing to archive #1", $!);
		}

		$toread -= $actual;
	}
	if ($size % 512) {
		print $out "\0" x (512 - $size % 512) or
		    $self->fatal("Error writing to archive: #1", $!);
	}
	$self->alias($arc, $self->name);
}

sub isFile() { 1 }

sub type() { OpenBSD::Ustar::FILE1 }

1;
@


1.87
log
@sprinkle spaces to make more obvious which fields we use
@
text
@d2 1
a2 1
# $OpenBSD: Ustar.pm,v 1.86 2015/01/04 14:10:20 espie Exp $
d331 1
a331 1
my $whatever = "usual_suspect000";
@


1.86
log
@too many todo. Use unambiguous names, since they're not the same operation
at all
@
text
@d2 1
a2 1
# $OpenBSD: Ustar.pm,v 1.85 2014/11/20 11:39:29 espie Exp $
d415 1
a415 1
	    (lstat $realname)[0,1,2,4,5,6, 7,9];
@


1.85
log
@theo's right. use random_name for truely random stuff.
rename variable and index accordingly.
@
text
@d2 1
a2 1
# $OpenBSD: Ustar.pm,v 1.84 2014/09/01 11:29:15 espie Exp $
d515 1
a515 1
sub todo
d843 1
a843 1
		$self->todo($toread);
d910 1
a910 1
		$self->todo($toread);
@


1.84
log
@@@newuser and @@newgroup won't necessarily be on the machine during pkg_create,
so fake uid/gid 0 if they're not. (removes some warning message)
@
text
@d2 1
a2 1
# $OpenBSD: Ustar.pm,v 1.83 2014/08/10 10:04:39 espie Exp $
d331 1
a331 1
my $random_name = "A_random_name000";
d397 2
a398 2
		    '', $random_name, '', $uname, $gname, $major, $minor);
		$random_name++;
@


1.83
log
@comment what's going on
@
text
@d2 1
a2 1
# $OpenBSD: Ustar.pm,v 1.82 2014/08/10 10:03:46 espie Exp $
d313 2
a314 2
		    sprintf("%07o", $entry->{uid}),
		    sprintf("%07o", $entry->{gid}),
@


1.82
log
@Ouch... fuck cvs
@
text
@d2 1
a2 1
# $OpenBSD: Ustar.pm,v 1.81 2014/08/10 10:01:03 espie Exp $
d491 1
@


1.81
log
@if pkg_create is run as non-root, restory correct group/owner to root/bin.

also, remove write permissions without explicit modes. Allows fake installs
to keep directories/files writable while producing correct package.
@
text
@d2 1
a2 1
# $OpenBSD: Ustar.pm,v 1.80 2014/07/23 14:35:17 espie Exp $
d316 1
a316 1
		    sprintf("%011o", $entry->{mtime}),
d491 4
a494 2
	$entry->{uid} //= $OpenBSD::Ustar::uidcache->lookup($entry->{uname});
	$entry->{gid} //= $OpenBSD::Ustar::gidcache->lookup($entry->{gname});
@


1.80
log
@move misleading comment
@
text
@d2 1
a2 1
# $OpenBSD: Ustar.pm,v 1.79 2014/07/07 16:43:55 espie Exp $
d52 4
a55 4
my $uidcache = new OpenBSD::UidCache;
my $gidcache = new OpenBSD::GidCache;
my $unamecache = new OpenBSD::UnameCache;
my $gnamecache = new OpenBSD::GnameCache;
d487 7
@


1.79
log
@restore progressmeter for big files.
somehow, one extra level of indirection to archive, make it all go away
by adding a new method set_callback
@
text
@d2 1
a2 1
# $OpenBSD: Ustar.pm,v 1.78 2014/04/21 11:42:31 espie Exp $
d41 1
a42 1
	XHDR => 'x',
@


1.78
log
@add support for reading/writing long paths and linkpaths as extended
headers
@
text
@d2 1
a2 1
# $OpenBSD: Ustar.pm,v 1.77 2014/01/17 15:39:53 espie Exp $
d78 6
@


1.77
log
@"recognize" extended header thingies (we don't handle them, we just
spew more useful error messages)
@
text
@d2 1
a2 1
# $OpenBSD: Ustar.pm,v 1.76 2014/01/13 18:42:34 espie Exp $
d136 40
d239 11
a260 5
	# adjust swallow
	$self->{swallow} = $size;
	if ($size % 512) {
		$self->{swallow} += 512 - $size % 512;
	}
d282 45
d331 1
d363 2
a364 1
		$archive->fatal("Prefix too long #1", $prefix);
d367 2
a368 1
		$archive->fatal("Name too long #1", $name);
d371 2
a372 1
		$archive->fatal("Linkname too long #1", $linkname);
d380 17
a396 20
	my $header;
	my $cksum = ' 'x8;
	for (1 .. 2) {
		$header = pack(USTAR_HEADER,
		    $name,
		    sprintf("%07o", $entry->{mode}),
		    sprintf("%07o", $entry->{uid}),
		    sprintf("%07o", $entry->{gid}),
		    sprintf("%011o", $size),
		    sprintf("%011o", $entry->{mtime}),
		    $cksum,
		    $type,
		    $linkname,
		    'ustar', '00',
		    $uname,
		    $gname,
		    sprintf("%07o", $major),
		    sprintf("%07o", $minor),
		    $prefix, "\0");
		$cksum = sprintf("%07o", unpack("%C*", $header));
@


1.76
log
@have Ustar extract owners for symlinks, which isn't really important for
pkg_add, since it skips links and restores owners from the plist anyways.
@
text
@d2 1
a2 1
# $OpenBSD: Ustar.pm,v 1.75 2014/01/09 20:20:01 espie Exp $
d40 6
a45 1
	MAXGROUPNAME => 32
d129 7
d202 2
a203 1
		$self->fatal("Unsupported type #1", $type);
@


1.75
log
@bump copyright to 2014
@
text
@d2 1
a2 1
# $OpenBSD: Ustar.pm,v 1.74 2014/01/07 00:48:24 espie Exp $
d562 2
@


1.74
log
@a few mechanical style changes
@
text
@d2 1
a2 1
# $OpenBSD: Ustar.pm,v 1.73 2014/01/05 23:11:24 espie Exp $
d4 1
a4 1
# Copyright (c) 2002-2007 Marc Espie <espie@@openbsd.org>
@


1.73
log
@don't whine about octal numbers > 2^32. They're not portable, but
they work on all OpenBSD platforms.

Shuts up warning noticed by naddy@@
@
text
@d2 1
a2 1
# $OpenBSD: Ustar.pm,v 1.72 2012/04/28 12:00:10 espie Exp $
d130 1
a130 1
	my $n = read $self->{fh}, $header, 512;
d163 2
a164 2
	no warnings;
	$mtime = oct($mtime);
d322 2
a323 2
	if (defined $self->{key}->{$k}) {
		$entry->{linkname} = $self->{key}->{$k};
d392 1
a392 1
	$self->{archive}->{state}->errsay(@@args);
d454 2
a455 2
	if (!defined $arc->{key}->{$k}) {
		$arc->{key}->{$k} = $self->name;
d463 3
a465 3
	my $k = $self->{archive}.":".$self->{archive}->{cachename};
	if (!defined $arc->{key}->{$k}) {
		$arc->{key}->{$k} = $alias;
d539 2
a540 2
	if (defined $arc->{key}->{$k}) {
		$self->{linkname} = $arc->{key}->{$k};
d706 1
a706 1
		my $actual = read($self->{archive}->{fh}, $buffer, $maxread);
d713 1
a713 1
		$self->{archive}->{swallow} -= $actual;
d745 1
a745 1
		my $actual = read($self->{archive}->{fh}, $buffer, $sz, $offset);
d752 1
a752 1
		$self->{archive}->{swallow} -= $actual;
d805 1
a805 1
		my $actual = read($self->{archive}->{fh}, $buffer, $maxread);
d812 1
a812 1
		$self->{archive}->{swallow} -= $actual;
@


1.72
log
@zap blank spaces
@
text
@d2 1
a2 1
# $OpenBSD$
d162 2
d165 1
@


1.71
log
@allow Ustar to be more precise in its error messages: record position
in archive, and caller can set description of file handle
@
text
@d2 1
a2 1
# $OpenBSD: Ustar.pm,v 1.70 2011/01/03 19:02:01 espie Exp $
d78 2
a79 2
	$self->{state}->fatal("Ustar [#1][#2]: #3", 
	    $self->{description} // '?', $self->{lastname} // '?', 
d190 1
a190 1
		$self->fatal("Bad archive: non null size for #1 (#2)", 
@


1.70
log
@redo the object creation in a more straightforward way.
@
text
@d2 1
a2 1
# $OpenBSD: Ustar.pm,v 1.69 2011/01/03 14:22:48 jasper Exp $
d69 6
d78 3
a80 1
	$self->{state}->fatal("Ustar: $msg", @@args);
d168 1
@


1.69
log
@unbreak hardlinks, like MLINKS, too.

ok espie@@
@
text
@d2 1
a2 1
# $OpenBSD: Ustar.pm,v 1.68 2011/01/03 00:12:06 espie Exp $
d77 1
a77 1
	my ($self, $h) = @@_;
d80 1
d161 1
a161 1
	my $result= $self->new_object({
d174 1
a174 1
	});
d176 1
a176 1
		$types->{$type}->new($result);
d180 5
a216 3
	if (!$entry->isFile) {
		$size = 0;
	}
d294 1
a294 1
	my $entry = $self->new_object({
d307 1
a307 1
	});
a311 1
		$entry->{size} = 0;
a314 1
		$entry->{size} = 0;
d325 5
a329 1
	$class->new($entry);
a364 12
sub new
{
	my ($class, $object) = @@_;

	bless $object, $class;
	if ($object->{size} != 0) {
		$object->fatal("Bad archive: non null size for #1 (#2)", 
		    $class, $object->{name});
	}
	return $object;
}

a671 6
sub new
{
	my ($class, $object) = @@_;

	bless $object, $class;
}
@


1.68
log
@broke symlinks, noticed by jasper@@
@
text
@d2 1
a2 1
# $OpenBSD: Ustar.pm,v 1.67 2011/01/02 14:39:18 espie Exp $
d309 1
@


1.67
log
@tidy things: use ->new more often.
use mkdir directly to be able to report errors in a sane way (as the
File::Path interface is prone to change).
allow prepare to specify its own destdir (for temp files).
use state->system to report more errors.
be consistent in destdir error printing.
@
text
@d2 1
a2 1
# $OpenBSD: Ustar.pm,v 1.66 2010/12/24 09:04:14 espie Exp $
d312 1
d365 2
a366 1
		$object->fatal("Bad archive: non null size for #1", $class);
@


1.66
log
@handle failures from ports tree with more care.
this does avoid infinite loops in case of wrong plists.
necessary since print-plist-with-depends CAN fail...
@
text
@d2 1
a2 1
# $OpenBSD$
a42 1
use File::Path ();
d130 2
a131 2
	$linkname, $magic, $version, $uname, $gname, $major, $minor,
	$prefix, $pad) = unpack(USTAR_HEADER, $header);
d283 1
a283 1
	my ($self, $filename) = @@_;
d285 2
a286 1
	my $realname = "$self->{destdir}/$filename";
d306 1
d309 1
a309 1
		bless $entry, "OpenBSD::Ustar::HardLink";
d312 1
a312 1
		bless $entry, "OpenBSD::Ustar::SoftLink";
d314 1
a314 1
		bless $entry, "OpenBSD::Ustar::Fifo";
d316 1
a316 1
		bless $entry, "OpenBSD::Ustar::CharDevice";
d318 1
a318 1
		bless $entry, "OpenBSD::Ustar::BlockDevice";
d320 1
a320 3
		bless $entry, "OpenBSD::Ustar::Dir";
	} else {
		bless $entry, "OpenBSD::Ustar::File";
d322 1
a322 1
	return $entry;
d357 1
d375 6
d417 11
d432 1
a432 1
	File::Path::mkpath($dir) unless -d $dir;
d502 1
a502 1
	File::Path::mkpath($self->{destdir}.$self->name);
d516 1
a516 1
	$self->make_basedir($self->name);
d550 1
a550 1
	$self->make_basedir($self->name);
d567 1
a567 1
	$self->make_basedir($self->name);
d570 2
a571 1
	    $self->fatal("Can't create fifo #1: #2", $self->name, $!);
d584 2
a585 2
	$self->make_basedir($self->name);
	system(OpenBSD::Paths->mknod,
d686 1
a686 1
	$self->make_basedir($self->name);
@


1.65
log
@somewhat complicated optimization: avoid reading the whole plist file
when we're only looking for update-info. Means Ustar must deal with
"partial" files. Occasionnally a huge win, such as skipping 95% of the kdebase
or texlive plist when they don't need updating.

I've been running with this for a few weeks now...
@
text
@d2 1
a2 1
# $OpenBSD: Ustar.pm,v 1.64 2010/09/14 10:02:37 espie Exp $
d406 1
a406 1
		utime $self->{atime} // time, $self->{mtime} // time, 
@


1.64
log
@set separate fields for atime/mtime in file entry, use them while creating.
allows user to undef them, and thus not to set utimes.
Use that to not set utimes for pkginfo.
fixes kili@@'s bug in a nicer way wrt Ustar interface...
@
text
@d2 1
a2 1
# $OpenBSD: Ustar.pm,v 1.63 2010/08/23 05:36:20 kili Exp $
d62 3
a64 3
	return bless { 
	    fh => $fh, 
	    swallow => 0, 
d66 1
a66 1
	    key => {}, 
d406 1
a406 1
		utime $self->{atime} // time, $self->{mtime} // time,
d672 1
a672 1
		$self->fatal("Can't write to #1#2: #3", $self->{destdir}, 
d676 7
d709 1
a709 1
	my $self = shift;
d712 6
d719 16
a734 3
	my $actual = read($self->{archive}->{fh}, $buffer, $toread);
	if (!defined $actual) {
		$self->fatal("Error reading from archive: #1", $!);
d736 2
a737 4
	if ($actual != $toread) {
		$self->fatal("Error: short read from archive");
	}
	$self->{archive}->{swallow} -= $actual;
@


1.63
log
@When extracting the pkg tar file, don't preserve the atime, just set it
to the current time. Works around a rare race condition that can happen
if daily(8) zaps old files from /var/tmp while pkg_add(8) is installing
or updating a package and doesn't yet have moved nor even read some of
the files in /var/tmp/pkginfo.* (typically +DESCR).

Espie wasn't totally happy with this at first, and will eventually work
on something better, so I'm omitting documentations bits for now.

ok espie@@
@
text
@d2 1
a2 1
# $OpenBSD: Ustar.pm,v 1.62 2010/07/28 15:05:33 espie Exp $
d164 2
a165 1
	    mtime=> $mtime,
d405 4
a408 1
	utime time, $self->{mtime}, $self->{destdir}.$self->name;
@


1.62
log
@let fatal work, fix typo
@
text
@d2 1
a2 1
# $OpenBSD: Ustar.pm,v 1.61 2010/07/28 12:19:54 espie Exp $
d404 1
a404 1
	utime $self->{mtime}, $self->{mtime}, $self->{destdir}.$self->name;
@


1.61
log
@pass state to Ustar objects, use it to display those pesky error and
fatal messages.

zap $opt_x from pkg_mklocated, do things like other commands do.
@
text
@d2 1
a2 1
# $OpenBSD: Ustar.pm,v 1.60 2010/07/04 19:34:47 espie Exp $
d72 1
a72 1
	my ($self, $msg, @@args) = $_;
d363 1
a363 2
		$object->fatal("Bad archive: non null size for #1", 
		    $class );
@


1.60
log
@reindent, turn function mkheader into method.
@
text
@d2 1
a2 1
# $OpenBSD: Ustar.pm,v 1.59 2010/06/30 10:51:04 espie Exp $
d58 1
a58 1
	my ($class, $fh, $destdir) = @@_;
d65 1
d70 5
d96 1
a96 1
			die "Error while skipping archive: $!";
d99 1
a99 1
			die "Premature end of archive in header: $!";
d124 1
a124 1
	die "Error while reading header"
d134 1
a134 1
		die "Not an ustar archive header";
d141 1
a141 1
		die "Bad archive checksum";
d177 1
a177 1
		die "Unsupported type $type";
d243 1
a243 1
		die "Prefix too long $prefix";
d246 1
a246 1
		die "Name too long $name";
d249 1
a249 1
		die "Linkname too long $linkname";
d252 1
a252 1
		die "Username too long $uname";
d255 1
a255 1
		die "Groupname too long $gname";
d327 3
a329 2
	my $fh = $_[0]->{fh};
	print $fh "\0"x1024 or die "Error writing to archive: $!";
d361 1
d363 2
a364 1
		die "Bad archive: non null size for arbitrary entry";
d366 7
a372 1
	bless $object, $class;
d375 5
d423 1
a423 1
	print $out $header or die "Error writing to archive: $!";
d463 1
a463 1
	print $out $header or die "Error writing to archive: $!";
d502 2
a503 2
	    die "Can't link $self->{destdir}$linkname to $self->{destdir}",
	    	$self->name, ": $!";
d515 1
a515 1
		die "Can't copy link over: original for $k NOT available";
d532 2
a533 2
	    die "Can't symlink $self->{linkname} to $self->{destdir}",
	    	$self->name, ": $!";
d550 1
a550 1
	    die "Can't create fifo ", $self->name,": $!";
d669 2
a670 1
		die "Can't write to $self->{destdir}", $self->name, ": $!";
d678 1
a678 1
			die "Error reading from archive: $!";
d681 1
a681 1
			die "Premature end of archive";
d685 2
a686 2
			die "Error writing to $self->{destdir}", $self->name,
			    ": $!";
d692 2
a693 2
	$out->close or die "Error closing $self->{destdir}", $self->name,
	    ": $!";
d705 1
a705 1
		die "Error reading from archive: $!";
d708 1
a708 1
		die "Error: short read from archive";
d720 2
a721 1
	open my $fh, "<", $filename or die "Can't read file $filename: $!";
d730 1
a730 1
			die "Error reading from file: $!";
d733 1
a733 1
			die "Premature end of file";
d736 1
a736 1
			die "Error writing to archive: $!";
d744 1
a744 1
		    die "Error writing to archive: $!";
d760 1
a760 1
			die "Error reading from archive: $!";
d763 1
a763 1
			die "Premature end of archive";
d767 1
a767 1
			die "Error writing to archive $!";
d774 1
a774 1
		    die "Error writing to archive: $!";
@


1.59
log
@allow say and errsay to work without parameters, as it's ways common.
create verbose_system up in state, because it makes sense without verbose.
@
text
@d2 1
a2 1
# $OpenBSD$
d58 1
a58 1
    my ($class, $fh, $destdir) = @@_;
d60 1
a60 1
    $destdir = '' unless defined $destdir;
d62 5
a66 1
    return bless { fh => $fh, swallow => 0, key => {}, destdir => $destdir} , $class;
d80 2
a81 2
    my $self = shift;
    my $temp;
d83 13
a95 11
    while ($self->{swallow} > 0) {
    	my $toread = $self->{swallow};
	if ($toread >$buffsize) {
		$toread = $buffsize;
	}
    	my $actual = read($self->{fh}, $temp, $toread);
	if (!defined $actual) {
		die "Error while skipping archive: $!";
	}
	if ($actual == 0) {
		die "Premature end of archive in header: $!";
a96 2
	$self->{swallow} -= $actual;
    }
d100 8
a107 8
    DIR , 'OpenBSD::Ustar::Dir',
    HARDLINK , 'OpenBSD::Ustar::HardLink',
    SOFTLINK , 'OpenBSD::Ustar::SoftLink',
    FILE , 'OpenBSD::Ustar::File',
    FILE1 , 'OpenBSD::Ustar::File',
    FIFO , 'OpenBSD::Ustar::Fifo',
    CHARDEVICE , 'OpenBSD::Ustar::CharDevice',
    BLOCKDEVICE , 'OpenBSD::Ustar::BlockDevice',
d112 68
a179 68
    my $self = shift;
    # get rid of the current object
    $self->skip;
    my $header;
    my $n = read $self->{fh}, $header, 512;
    return if (defined $n) and $n == 0;
    die "Error while reading header"
	unless defined $n and $n == 512;
    if ($header eq "\0"x512) {
	return $self->next;
    }
    # decode header
    my ($name, $mode, $uid, $gid, $size, $mtime, $chksum, $type,
    $linkname, $magic, $version, $uname, $gname, $major, $minor,
    $prefix, $pad) = unpack(USTAR_HEADER, $header);
    if ($magic ne "ustar\0" || $version ne '00') {
	die "Not an ustar archive header";
    }
    # verify checksum
    my $value = $header;
    substr($value, 148, 8) = " "x8;
    my $ck2 = unpack("%C*", $value);
    if ($ck2 != oct($chksum)) {
	die "Bad archive checksum";
    }
    $name =~ s/\0*$//o;
    $mode = oct($mode) & 0xfff;
    $uname =~ s/\0*$//o;
    $gname =~ s/\0*$//o;
    $linkname =~ s/\0*$//o;
    $major = oct($major);
    $minor = oct($minor);
    $uid = oct($uid);
    $gid = oct($gid);
    $uid = $uidcache->lookup($uname, $uid);
    $gid = $gidcache->lookup($gname, $gid);
    $mtime = oct($mtime);
    unless ($prefix =~ m/^\0/o) {
	$prefix =~ s/\0*$//o;
	$name = "$prefix/$name";
    }

    $size = oct($size);
    my $result= $self->new_object({
	name => $name,
	mode => $mode,
	mtime=> $mtime,
	linkname=> $linkname,
	uname => $uname,
	uid => $uid,
	gname => $gname,
	gid => $gid,
	size => $size,
	major => $major,
	minor => $minor,
    });
    if (defined $types->{$type}) {
    	$types->{$type}->new($result);
    } else {
    	die "Unsupported type $type";
    }
    # adjust swallow
    $self->{swallow} = $size;
    if ($size % 512) {
	$self->{swallow} += 512 - $size % 512;
    }
    $self->{cachename} = $name;
    return $result;
d201 1
a201 1
	my ($entry, $type) = @@_;
d402 1
a402 1
	my $header = OpenBSD::Ustar::mkheader($self, $self->type);
d442 1
a442 1
	my $header = OpenBSD::Ustar::mkheader($self, $self->type);
@


1.58
log
@whitespace cleanup
@
text
@@


1.57
log
@slightly better error handling
@
text
@d2 1
a2 1
# $OpenBSD: Ustar.pm,v 1.56 2010/05/10 09:17:55 espie Exp $
@


1.56
log
@whitespace fixes
@
text
@d2 1
a2 1
# $OpenBSD$
d572 1
a572 4
	open (my $out, '>', $fname);
	if (!defined $out) {
		return;
	}
@


1.55
log
@clean up the ProgressMeter code, create a specific class if a Term
is around.
start using stuff from termcap, specifically, cleareol, and move to hp.
use the full line when we can, cram 100% if we can.
(this should flicker much less on slow terminals).

clean-up the install-and-progress bits to be in progressmeter, this removes
some code.

have pkg_create follow the same pattern as the others, with a state.
This allows us to unify error messages a bit.
@
text
@d149 1
a149 1
    
d185 1
a185 1
		while (length($name) > MAXFILENAME && 
d250 1
a250 1
		$header = pack(USTAR_HEADER, 
d277 1
a277 1
	my ($dev, $ino, $mode, $uid, $gid, $rdev, $size, $mtime) = 
d281 1
a281 1
		key => "$dev/$ino", 
d451 1
a451 1
	
d507 1
a507 1
	symlink $self->{linkname}, $self->{destdir}.$self->name or 
d540 2
a541 2
	system(OpenBSD::Paths->mknod, 
	    '-m', $self->{mode}, '--', $self->{destdir}.$self->name, 
d602 1
a602 1
				defined(sysseek($fh, $seek_forward, 1)) 
d666 1
a666 1
			
d670 1
a670 1
	$out->close or die "Error closing $self->{destdir}", $self->name, 
d715 1
a715 1
			
d720 1
a720 1
		print $out "\0" x (512 - $size % 512) or 
d746 1
a746 1
			
d750 1
a750 1
		print $out "\0" x (512 - $size % 512) or 
@


1.54
log
@be slightly more paranoid about shell stuff we run.
@
text
@d2 1
a2 1
# $OpenBSD: Ustar.pm,v 1.53 2009/12/17 11:07:24 espie Exp $
d66 8
d151 1
a151 1
    my $result= {
d163 1
a163 3
	archive => $self,
	destdir => $self->{destdir}
    };
d275 1
a275 2
	my $destdir = $self->{destdir};
	my $realname = "$destdir/$filename";
d280 1
a280 1
	my $entry = {
d293 1
a293 3
		archive => $self,
		destdir => $self->{destdir}
	};
d356 8
d643 1
a643 1
	my ($self, $callback) = @@_;
d668 1
a668 3
		if ($toread > 0 && defined $callback) {
			&$callback($self->{size} - $toread);
		}
d717 1
@


1.53
log
@add a callback to file creation, so that we get progress meter for huge
files in packages. Should affect emacs, chrome and the likes.
@
text
@d2 1
a2 1
# $OpenBSD: Ustar.pm,v 1.52 2009/11/10 11:36:56 espie Exp $
d530 1
a530 1
	    '-m', $self->{mode}, $self->{destdir}.$self->name, 
@


1.52
log
@bad espie: use strict/warnings consistently, and fix two nits and two
actual errors !
@
text
@d2 1
a2 1
# $OpenBSD$
d632 1
a632 1
	my $self = shift;
d657 3
@


1.51
log
@synch with my new style search/location changes
It's likely there will be some fallout, but it's getting a bit too large
to keep around.
This does kill a few very old oddities as well.
@
text
@d22 1
@


1.50
log
@use OpenBSD::Paths contents
@
text
@d2 1
a2 1
# $OpenBSD: Ustar.pm,v 1.49 2007/06/12 09:53:36 espie Exp $
d191 1
a191 1
	my ($prefix, $name) = split_name($entry->{name});
d352 12
d367 3
a369 3
	chown $self->{uid}, $self->{gid}, $self->{destdir}.$self->{name};
	chmod $self->{mode}, $self->{destdir}.$self->{name};
	utime $self->{mtime}, $self->{mtime}, $self->{destdir}.$self->{name};
d375 1
a375 1
	my $dir = $self->{destdir}.File::Basename::dirname($self->{name});
d391 1
a391 1
		$arc->{key}->{$k} = $self->{name};
d446 1
a446 1
	File::Path::mkpath($self->{destdir}.$self->{name});
d460 1
a460 1
	$self->make_basedir($self->{name});
d465 3
a467 2
	link $self->{destdir}.$linkname, $self->{destdir}.$self->{name} or
	    die "Can't link $self->{destdir}$linkname to $self->{destdir}$self->{name}: $!";
d494 4
a497 3
	$self->make_basedir($self->{name});
	symlink $self->{linkname}, $self->{destdir}.$self->{name} or 
	    die "Can't symlink $self->{linkname} to $self->{destdir}$self->{name}: $!";
d511 1
a511 1
	$self->make_basedir($self->{name});
d513 2
a514 2
	POSIX::mkfifo($self->{destdir}.$self->{name}, $self->{mode}) or
	    die "Can't create fifo $self->{name}: $!";
d527 1
a527 1
	$self->make_basedir($self->{name});
d529 1
a529 1
	    '-m', $self->{mode}, $self->{destdir}.$self->{name}, 
d632 1
a632 1
	$self->make_basedir($self->{name});
d634 1
a634 1
	my $out = OpenBSD::CompactWriter->new($self->{destdir}.$self->{name});
d636 1
a636 1
		die "Can't write to $self->{destdir}$self->{name}: $!";
d651 2
a652 1
			die "Error writing to $self->{destdir}$self->{name}: $!";
d657 2
a658 1
	$out->close or die "Error closing $self->{destdir}$self->{name}: $!";
d739 1
a739 1
	$self->alias($arc, $self->{name});
@


1.49
log
@tidy error messages: uses $! more consistently, do not append \n on die,
do append \n on warn.

Fix the two cases where the temp dir vanished too soon: not copying +DESC
should have been apparent. Not finding a +DISPLAY file is not a reason for
burping all over the place.
@
text
@d2 1
a2 1
# $OpenBSD: Ustar.pm,v 1.48 2007/06/04 14:40:39 espie Exp $
d45 1
d514 3
a516 1
	system('/sbin/mknod', 'mknod', '-m', $self->{mode}, $self->{destdir}.$self->{name}, $self->devicetype, $self->{major}, $self->{minor});
@


1.48
log
@some minor systematic changes.
- mark all regexps I can with /o if they can be compiled once.
- turn $o->method() into $o->method
- remove unneeded prototypes
- reduce split /re/ into split "string" where possible.
@
text
@d2 1
a2 1
# $OpenBSD: Ustar.pm,v 1.47 2007/05/02 15:05:30 espie Exp $
d76 1
a76 1
		die "Error while skipping archive: $!\n";
d79 1
a79 1
		die "Premature end of archive in header: $!\n";
d225 1
a225 1
		die "Prefix too long $prefix\n";
d228 1
a228 1
		die "Name too long $name\n";
d231 1
a231 1
		die "Linkname too long $linkname\n";
d234 1
a234 1
		die "Username too long $uname\n";
d237 1
a237 1
		die "Groupname too long $gname\n";
d346 1
a346 1
		die "Bad archive: non null size for arbitrary entry\n";
d465 1
a465 1
		die "Can't copy link over: original for $k NOT available\n";
@


1.47
log
@$o->method() becomes $o->method
@
text
@d2 1
a2 1
# $OpenBSD: Ustar.pm,v 1.46 2007/04/15 10:17:29 espie Exp $
d107 1
a107 1
	return $self->next();
d123 1
a123 1
    $name =~ s/\0*$//;
d125 3
a127 3
    $uname =~ s/\0*$//;
    $gname =~ s/\0*$//;
    $linkname =~ s/\0*$//;
d135 2
a136 2
    unless ($prefix =~ m/^\0/) {
	$prefix =~ s/\0*$//;
d178 1
a178 1
		    $name =~ m/^(.*?\/)(.*)$/) {
d218 1
a218 1
		$cwd.='/' unless $cwd =~ m/\/$/;
d373 1
a373 1
	my $header = OpenBSD::Ustar::mkheader($self, $self->type());
d413 1
a413 1
	my $header = OpenBSD::Ustar::mkheader($self, $self->type());
@


1.46
log
@update copyright years, standardize licence.
reword the introduction to the stuff originally from FreeBSD to clarify
slightly.
@
text
@d2 1
a2 1
# $OpenBSD: Ustar.pm,v 1.45 2007/04/14 12:38:12 espie Exp $
d100 1
a100 1
    $self->skip();
d193 1
a193 1
	if (!$entry->isFile()) {
d197 1
a197 1
	if ($entry->isDevice()) {
d320 1
a320 1
	    $self->pad();
d434 1
a434 1
	$self->set_modes();
d500 1
a500 1
	$self->set_modes();
d513 2
a514 2
	system('/sbin/mknod', 'mknod', '-m', $self->{mode}, $self->{destdir}.$self->{name}, $self->devicetype(), $self->{major}, $self->{minor});
	$self->set_modes();
d639 2
a640 2
	$out->close() or die "Error closing $self->{destdir}$self->{name}: $!";
	$self->set_modes();
@


1.45
log
@no need to go SUPER:: for set_modes.
also call it for devices (even though it's unlikely to be very useful)
@
text
@d2 1
a2 1
# $OpenBSD: Ustar.pm,v 1.44 2007/02/22 21:40:39 espie Exp $
d4 1
a4 1
# Copyright (c) 2002-2004 Marc Espie <espie@@openbsd.org>
@


1.44
log
@avoid undefined. closes pr5386.
@
text
@d2 1
a2 1
# $OpenBSD: Ustar.pm,v 1.43 2006/11/17 15:34:15 espie Exp $
d434 1
a434 1
	$self->SUPER::set_modes();
d500 1
a500 1
	$self->SUPER::set_modes();
d514 1
d640 1
a640 1
	$self->SUPER::set_modes();
@


1.43
log
@don't return undef, use plain return.
(return undef is only false in a scalar context)
found my perlcritic, one of the few issues I agree with...
@
text
@d2 1
a2 1
# $OpenBSD: Ustar.pm,v 1.42 2006/08/05 08:21:55 espie Exp $
d103 1
a103 1
    return if $n == 0;
@


1.42
log
@actually perform error-checking on every read/write.
@
text
@d2 1
a2 1
# $OpenBSD: Ustar.pm,v 1.41 2006/03/21 18:41:34 espie Exp $
d103 1
a103 1
    return undef if $n == 0;
d544 1
a544 1
		return undef;
@


1.41
log
@fix endless loop in case of error in archive header.
@
text
@d2 1
a2 1
# $OpenBSD: Ustar.pm,v 1.40 2005/10/26 09:47:48 espie Exp $
d313 1
a313 1
	print $fh "\0"x1024;
d374 1
a374 1
	print $out $header;
d414 1
a414 1
	print $out $header;
d562 4
a565 1
				defined(syswrite($fh, $buffer, $i)) or return 0;
d584 6
a589 2
	defined(syswrite($fh, $buffer)) or return 0;
	return 1;
d624 2
a625 1
		if (!defined read($self->{archive}->{fh}, $buffer, $maxread)) {
d628 4
a631 1
		$self->{archive}->{swallow} -= $maxread;
d636 1
a636 1
		$toread -= $maxread;
d648 2
a649 1
	if (!defined read($self->{archive}->{fh}, $buffer, $toread)) {
d652 4
a655 1
	$self->{archive}->{swallow} -= $toread;
d672 2
a673 1
		if (!defined read($fh, $buffer, $maxread)) {
d676 3
d683 1
a683 1
		$toread -= $maxread;
d686 2
a687 1
		print $out "\0" x (512 - $size % 512);
d701 2
a702 1
		if (!defined read($self->{archive}->{fh}, $buffer, $maxread)) {
d705 4
a708 1
		$self->{archive}->{swallow} -= $maxread;
d713 1
a713 1
		$toread -= $maxread;
d716 2
a717 1
		print $out "\0" x (512 - $size % 512);
@


1.40
log
@add checks in skip for walking off the file.
use cleaner code for reading headers.
@
text
@d2 1
a2 1
# $OpenBSD: Ustar.pm,v 1.39 2005/10/26 09:35:32 espie Exp $
d77 3
@


1.39
log
@minor clean-up, unhardcode test for type, use a table instead.
@
text
@d2 1
a2 1
# $OpenBSD: Ustar.pm,v 1.38 2005/09/24 12:07:38 espie Exp $
d67 1
a67 1
    return if $self->{swallow} == 0;
d69 10
a78 4
    my $temp;
    while ($self->{swallow} > $buffsize) {
    	read($self->{fh}, $temp, $buffsize);
	$self->{swallow} -= $buffsize;
a79 2
    read($self->{fh},  $temp, $self->{swallow});
    $self->{swallow} = 0;
d154 1
a154 1
    	bless $result, $types->{$type};
a157 5
    if (!$result->isFile()) {
    	if ($size != 0) {
		die "Bad archive: non null size for non file entry\n";
	}
    }
d338 10
d594 6
@


1.38
log
@move uname/gname existence check into ArcCheck: Ustar archives deal with
this differently. Namely, use specific variables that default to the
numeric value if the uid/gid don't exist in mkheader.
Since the entry fields are not filled, ArcCheck gets all it needs for
the package check.
@
text
@d2 1
a2 1
# $OpenBSD: Ustar.pm,v 1.37 2005/09/20 20:06:48 espie Exp $
d78 11
d148 3
a150 15
	};
    if ($type eq DIR) {
    	bless $result, 'OpenBSD::Ustar::Dir';
    } elsif ($type eq HARDLINK) {
	bless $result, 'OpenBSD::Ustar::HardLink';
    } elsif ($type eq SOFTLINK) {
    	bless $result, 'OpenBSD::Ustar::SoftLink';
    } elsif ($type eq FILE || $type eq FILE1) {
    	bless $result, 'OpenBSD::Ustar::File';
    } elsif ($type eq FIFO) {
    	bless $result, 'OpenBSD::Ustar::Fifo';
    } elsif ($type eq CHARDEVICE) {
    	bless $result, 'OpenBSD::Ustar::CharDevice';
    } elsif ($type eq BLOCKDEVICE) {
    	bless $result, 'OpenBSD::Ustar::BlockDevice';
d152 1
a152 1
    	die "Unsupported type";
@


1.37
log
@refuse building archive if we don't have user names for the uids.
@
text
@d2 1
a2 1
# $OpenBSD: Ustar.pm,v 1.36 2005/09/13 09:30:55 espie Exp $
d203 12
d232 2
a233 8
	if (!defined $entry->{uname}) {
		die "No user name for ", $entry->{name}, " (uid ", $entry->{uid}, ")\n";
	}
	if (length $entry->{uname} > MAXUSERNAME) {
		die "Username too long ", $entry->{uname}, "\n";
	}
	if (!defined $entry->{gname}) {
		die "No group name for ", $entry->{name}, " (gid ", $entry->{gid}. "\n";
d235 2
a236 2
	if (length $entry->{gname} > MAXGROUPNAME) {
		die "Groupname too long ", $entry->{gname}, "\n";
d252 2
a253 2
		    $entry->{uname},
		    $entry->{gname},
@


1.36
log
@allows grabbing a packing-list directly, without needing to go through
a temporary file, by using perl's new-fangled
open my $fh, '<', \$scalar
@
text
@d2 1
a2 1
# $OpenBSD: Ustar.pm,v 1.35 2005/08/10 14:02:22 espie Exp $
d220 3
d225 3
@


1.35
log
@typo
@
text
@d2 1
a2 1
# $OpenBSD: Ustar.pm,v 1.34 2005/08/05 10:36:53 espie Exp $
d600 13
@


1.34
log
@expose the algorithm used for splitting names, so that ArcCheck will be
able to use it.
@
text
@d2 1
a2 1
# $OpenBSD: Ustar.pm,v 1.31 2005/07/25 11:26:01 espie Exp $
d148 1
a148 1
    } elsif ($type eq 'CHARDEVICE') {
d150 1
a150 1
    } elsif ($type eq 'BLOCKDEVICE') {
@


1.33
log
@activate sanity check: only files have !0 size.
@
text
@d2 1
a2 1
# $OpenBSD: Ustar.pm,v 1.32 2005/08/05 10:01:38 espie Exp $
d169 1
a169 1
sub mkheader
d171 7
a177 10
	my ($entry, $type) = @@_;
	my ($name, $prefix);
	$name = $entry->{name};
	if (length($name) <= MAXFILENAME) {
		$prefix = '';
	} elsif (length($name) > MAXFILENAME+MAXPREFIX+1) {
		die "Can't fit such a name $name\n";
	} else {
		$prefix = '';
		while (length($name) > MAXFILENAME && $name =~ m/^(.*?\/)(.*)$/) {
d183 7
@


1.32
log
@fix splitting bug
@
text
@d2 1
a2 1
# $OpenBSD: Ustar.pm,v 1.31 2005/07/25 11:26:01 espie Exp $
d155 5
a159 5
#    if (!$result->isFile()) {
#    	if ($size != 0) {
#		die "Bad archive: non null size for non file entry\n";
#	}
#    }
@


1.31
log
@common code for all device handling.
@
text
@d2 1
a2 1
# $OpenBSD: Ustar.pm,v 1.30 2005/07/20 15:35:33 espie Exp $
d180 2
a181 2
		while (length($name) > MAXFILENAME && $name =~ m/^(.*\/)(.*)$/) {
			$prefix =$1;
@


1.30
log
@support for fifo and character/block devices.
@
text
@d2 1
a2 1
# $OpenBSD: Ustar.pm,v 1.29 2005/06/26 15:39:19 espie Exp $
d479 1
a479 1
package OpenBSD::Ustar::BlockDevice;
d486 1
a486 1
	system('/sbin/mknod', 'mknod', '-m', $self->{mode}, $self->{destdir}.$self->{name}, 'b', $self->{major}, $self->{minor});
d490 4
d495 1
d498 1
a498 8
our @@ISA=qw(OpenBSD::Ustar::Object);

sub create
{
	my $self = shift;
	$self->make_basedir($self->{name});
	system('/sbin/mknod', 'mknod', '-m', $self->{mode}, $self->{destdir}.$self->{name}, 'b', $self->{major}, $self->{minor});
}
a499 1
sub isDevice() { 1 }
d501 1
@


1.29
log
@expose the name aliasing operation, since it can be useful.
@
text
@d2 1
a2 1
# $OpenBSD: Ustar.pm,v 1.28 2005/06/21 17:52:49 espie Exp $
d110 2
d133 2
d146 6
d191 8
d238 2
a239 1
		    "\0", "\0",
d253 2
a254 2
	my ($dev, $ino, $mode, $uid, $gid, $size, $mtime) = 
	    (lstat $realname)[0,1,2,4,5,7,9];
d267 2
d279 6
d394 2
d437 1
d462 42
@


1.28
log
@when writing store the file `real name' on the filesystem, which
allows renaming it on-the-fly just for archive creation purposes.
@
text
@d2 1
a2 1
# $OpenBSD: Ustar.pm,v 1.27 2005/06/20 13:27:37 espie Exp $
d328 10
d408 1
a408 1
		die "Can't copy link over: original NOT available\n";
d578 1
a578 4
	my $k = $self->{archive}.":".$self->{archive}->{cachename};
	if (!defined $arc->{key}->{$k}) {
		$arc->{key}->{$k} = $self->{name};
	}
@


1.27
log
@flesh out the destdir() working. Provide a convenience close() method.
@
text
@d2 1
a2 1
# $OpenBSD: Ustar.pm,v 1.26 2005/06/18 13:17:11 espie Exp $
d232 1
d235 1
a235 1
	    (lstat "$destdir/$filename")[0,1,2,4,5,7,9];
d240 1
d255 2
a256 2
	} elsif (-l "$destdir/$filename") {
		$entry->{linkname} = readlink("$destdir/$filename");
d521 1
a521 1
	my $filename = $self->{destdir}."/".$self->{name};
@


1.26
log
@maintain correspondence between original archive file names and rewritten
names. Allows transparent rename & copy of hard links.
@
text
@d2 1
a2 1
# $OpenBSD: Ustar.pm,v 1.25 2005/06/18 12:52:29 espie Exp $
d270 24
d316 1
d346 1
@


1.25
log
@more sanity checks, don't truncate names silently.
@
text
@d2 1
a2 1
# $OpenBSD: Ustar.pm,v 1.24 2005/06/18 11:42:49 espie Exp $
d155 1
d306 5
d320 1
d362 12
d539 4
@


1.24
log
@fix prefix/name cut (found out by aanriot)
@
text
@d2 1
a2 1
# $OpenBSD: Ustar.pm,v 1.23 2005/06/13 18:38:59 espie Exp $
d35 5
d163 1
a163 1
	if (length($name) < 100) {
d165 1
a165 1
	} elsif (length($name) > 255) {
a167 1
		my @@c = split('/', $name);
d169 3
a171 2
		while (length($prefix.$c[0].'/') <= 155 and @@c > 1) {
			$prefix.=(shift @@c).'/';
a172 1
		$name = join('/', @@c);
a173 3
		if (length $prefix > 155 or length $name > 100) {
			die "Can't fit such a name $prefix/$name\n";
		}
d187 15
@


1.23
log
@add copy method, and document it.
Note that it doesn't do any magic with hard links so far.
@
text
@d2 1
a2 1
# $OpenBSD: Ustar.pm,v 1.22 2005/06/13 18:11:44 espie Exp $
a161 3
	} elsif ($name =~ m|^(.*)/(.{,100})$|) {
		$prefix = $1;
		$name = $2;
d163 10
a172 1
		die "Can't fit such a name $name\n";
@


1.22
log
@if this is not a `real' file, override the size entry with a zero.
@
text
@d2 1
a2 1
# $OpenBSD: Ustar.pm,v 1.21 2005/06/13 14:24:06 espie Exp $
a128 5
    # adjust swallow
    $self->{swallow} = $size;
    if ($size % 512) {
	$self->{swallow} += 512 - $size % 512;
    }
d140 10
d283 15
d458 1
a458 1
	my $toread = $self->{size};
d467 25
@


1.21
log
@fix archive header writing.
add pad() method to finish archives.
With this, writing Ustar archives work.
@
text
@d2 1
a2 1
# $OpenBSD: Ustar.pm,v 1.20 2005/06/13 13:11:11 espie Exp $
d164 4
d184 1
a184 1
		    sprintf("%011o", $entry->{size}),
@


1.20
log
@almost working...
@
text
@d2 1
a2 1
# $OpenBSD: Ustar.pm,v 1.19 2005/06/13 12:51:18 espie Exp $
d34 1
a34 1
	USTAR_HEADER => 'a100a8a8a8a12a12a8aa100a6a2a32a32a8a8a155',
d89 1
a89 1
    $prefix) = unpack(USTAR_HEADER, $header);
d177 5
a181 5
		    sprintf("%o", $entry->{mode}),
		    sprintf("%o", $entry->{uid}),
		    sprintf("%o", $entry->{gid}),
		    sprintf("%o", $entry->{size}),
		    sprintf("%o", $entry->{mtime}),
d188 3
a190 3
		    '0', '0',
		    $prefix);
		$cksum = unpack("%C*", $header);
d225 1
a225 1
		bless $entry, "OpenBSD::UStar::Dir";
d232 6
d258 1
d261 1
a261 1
	syswrite($arc->{fh}, $header, 512);
a440 1
		$self->{archive}->{swallow} -= $maxread;
d454 1
a454 1
sub type() { OpenBSD::Ustar::FILE }
@


1.19
log
@$entry->{cwd} support while writing, for symetry.
@
text
@d2 1
a2 1
# $OpenBSD: Ustar.pm,v 1.18 2005/06/13 12:46:47 espie Exp $
d169 3
d220 2
a221 2
		bless "OpenBSD::Ustar::HardLink", $entry;
	} elsif (-l $_) {
d223 1
a223 1
		bless "OpenBSD::Ustar::SoftLink", $entry;
d225 1
a225 1
		bless "OpenBSD::UStar::Dir", $entry;
d227 1
a227 1
		bless "OpenBSD::Ustar::File", $entry;
d285 1
a285 1
sub type() { DIR }
d305 1
a305 1
sub type() { HARDLINK }
d321 1
a321 1
sub type() { SOFTLINK }
d448 1
a448 1
sub type() { FILE }
@


1.18
log
@we can determine if an entry will be stored as a HardLink at prepare() time,
so do it...
@
text
@d2 1
a2 1
# $OpenBSD: Ustar.pm,v 1.17 2005/06/13 12:22:37 espie Exp $
d163 6
d181 1
a181 1
		    $entry->{linkname},
@


1.17
log
@interface more symetric to reading.
@
text
@d2 1
a2 1
# $OpenBSD: Ustar.pm,v 1.16 2005/06/13 12:12:34 espie Exp $
d208 5
a212 2

	if (-l $_) {
d244 2
a245 1
	$self->write_header($arc);
a257 7
sub write_header
{
	my ($self, $arc) = @@_;
	my $header = OpenBSD::Ustar::mkheader($self, $self->type());
	syswrite($arc->{fh}, $header, 512);
}

a406 11
}

sub write_header
{
	my ($self, $arc) = @@_;
	my $k = $self->{key};
	if (defined $arc->{key}->{$k}) {
		$self->{linkname} = $arc->{key}->{$k};
		bless "OpenBSD::Ustar::HardLink", $self;
	}
	$self->SUPER::write_header($arc);
@


1.16
log
@UStar writer, all the flesh, thoroughly untested yet, reading unaffected...
@
text
@d2 1
a2 1
# $OpenBSD: Ustar.pm,v 1.15 2004/12/26 15:18:51 espie Exp $
d188 1
a188 1
	my ($arc, $filename) = @@_;
d190 1
a190 1
	my $destdir = $arc->{destdir};
d204 3
a206 1
		gname => $gnamecache->lookup($gid)
d238 2
a239 1
	my ($self, $arc) = @@_;
d426 1
a426 1
	my $filename = $arc->{destdir}."/".$self->{name};
@


1.15
log
@put the compress 0 codes into a specific object. Handles the case where
file ends with a block of zero, as sleuthed by sturm@@.
The object means the code is cleaned up with all the state in one
place.

Also, better use of constant.

And beginnings of an Ustar writer code...
@
text
@d2 1
a2 1
# $OpenBSD: Ustar.pm,v 1.14 2004/12/13 18:50:23 espie Exp $
d43 2
d55 1
a55 1
    return bless { fh => $fh, swallow => 0, destdir => $destdir} , $class;
d152 1
d186 31
d234 24
d276 2
d296 2
d312 2
d409 39
d449 2
@


1.14
log
@fix test for syswrite errors: zero returns are legitimate.
@
text
@d2 1
a2 1
# $OpenBSD: Ustar.pm,v 1.13 2004/12/11 14:05:13 espie Exp $
d24 13
a36 10
use constant FILE => "\0";
use constant FILE1 => '0';
use constant HARDLINK => '1';
use constant SOFTLINK => '2';
use constant CHARDEVICE => '3';
use constant BLOCKDEVICE => '4';
use constant DIR => '5';
use constant FIFO => '6';
use constant CONTFILE => '7';
use constant USTAR_HEADER => 'a100a8a8a8a12a12a8aa100a6a2a32a32a8a8a155';
d146 38
d250 8
a257 2
package OpenBSD::Ustar::File;
our @@ISA=qw(OpenBSD::Ustar::Object);
d259 10
a268 8
my $bs;
my $zeroes;
sub print_compact
{
	my ($fh, $buffer) = @@_;
	my $newbs = (stat $fh)[11];
	if (!defined $bs or $newbs != $bs) {
		$bs = $newbs;
d271 7
d292 4
d300 1
d305 13
d322 2
a323 1
	open (my $out, '>', $self->{destdir}.$self->{name});
a326 1
	my $buffer;
d335 1
a335 1
		unless (print_compact($out, $buffer)) {
@


1.13
log
@implement zeroes blocks detection
@
text
@d2 1
a2 1
# $OpenBSD: Ustar.pm,v 1.12 2004/11/01 15:44:11 espie Exp $
d226 1
a226 1
				syswrite($fh, $buffer, $i) or return 0;
d233 2
a234 1
				sysseek($fh, $seek_forward, 1) or return 0;
d240 2
a241 1
	syswrite($fh, $buffer) or return 0;
@


1.12
log
@linknames have extra 0 we want to get rid of.
@
text
@d2 1
a2 1
# $OpenBSD: Ustar.pm,v 1.11 2004/11/01 15:21:48 espie Exp $
d40 2
d212 30
d259 1
a259 1
		unless (print $out $buffer) {
@


1.11
log
@typo
@
text
@d2 1
a2 1
# $OpenBSD: Ustar.pm,v 1.10 2004/09/14 22:40:01 espie Exp $
d97 1
@


1.10
log
@use IdCache.
@
text
@d2 1
a2 1
# $OpenBSD: Ustar.pm,v 1.9 2004/08/06 08:06:01 espie Exp $
d204 1
a204 1
sub isHardLink() { 1 }
@


1.9
log
@block-scoped require is way simpler than weird AUTOLOAD hack.
@
text
@d2 1
a2 1
# $OpenBSD: Ustar.pm,v 1.8 2004/08/06 07:51:17 espie Exp $
d33 1
d36 1
d38 2
a39 2
my $uidcache = {};
my $gidcache = {};
d44 1
a44 4
    my ($class, $fh) = @@_;

    return bless { fh => $fh, swallow => 0} , $class;
}
d46 1
d48 1
a48 10
sub name2uid
{
	my $name = shift;
	return $uidcache->{$name} if defined $uidcache->{$name};
	my @@entry = getpwnam($name);
	if (@@entry == 0) {
		return $uidcache->{$name} = shift;
	} else {
		return $uidcache->{$name} = $entry[2];
	}
a50 11
sub name2gid
{
	my $name = shift;
	return $gidcache->{$name} if defined $gidcache->{$name};
	my @@entry = getgrnam($name);
	if (@@entry == 0) {
		return $gidcache->{$name} = shift;
	} else {
		return $gidcache->{$name} = $entry[2];
	}
}
d82 1
a82 1
    $prefix) = unpack('a100a8a8a8a12a12a8aa100a6a2a32a32a8a8a155', $header);
d99 2
a100 2
    $uid = name2uid($uname, $uid);
    $gid = name2gid($gname, $gid);
d119 1
a119 1
	destdir => ''
@


1.8
log
@unified headers, switch to smaller copyright notice.
@
text
@d2 1
a2 1
# $OpenBSD: Ustar.pm,v 1.7 2004/02/15 15:33:59 espie Exp $
a22 4
# helps autoloader
sub DESTROY
{
}
@


1.7
log
@remove extra .   I left when putting $self->{destdir} inside...
@
text
@d1 2
a2 1
# $OpenBSD: Ustar.pm,v 1.6 2004/01/29 13:06:39 espie Exp $
d4 13
a16 22
# Copyright (c) 2002 Marc Espie.
# 
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
# 
# THIS SOFTWARE IS PROVIDED BY THE OPENBSD PROJECT AND CONTRIBUTORS
# ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
# A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OPENBSD
# PROJECT OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
a18 3

# Prototype of new pkg* implementation, tar module.
# Interface is likely to change A LOT in the near future...
@


1.6
log
@destdir support
okay pvalchev.
@
text
@d1 1
a1 1
# $OpenBSD: Ustar.pm,v 1.5 2004/01/27 23:25:31 espie Exp $
d221 1
a221 1
	    die "Can't link $self->{destdir}.$linkname to $self->{destdir}.$self->{name}: $!";
d235 1
a235 1
	    die "Can't symlink $self->{linkname} to $self->{destdir}.$self->{name}: $!";
d250 1
a250 1
		die "Can't write to $self->{destdir}.$self->{name}: $!";
d262 1
a262 1
			die "Error writing to $self->{destdir}.$self->{name}: $!";
d267 1
a267 1
	$out->close() or die "Error closing $self->{destdir}.$self->{name}: $!";
@


1.5
log
@avoid File::IO, one less module to load.
catch more error conditions and die in a systematic way.
okay sturm@@
@
text
@d1 1
a1 1
# $OpenBSD: Ustar.pm,v 1.4 2003/12/19 00:29:20 espie Exp $
d153 2
a154 1
	archive => $self
d179 3
a181 3
	chown $self->{uid}, $self->{gid}, $self->{name};
	chmod $self->{mode}, $self->{name};
	utime $self->{mtime}, $self->{mtime}, $self->{name};
d187 1
a187 1
	my $dir = File::Basename::dirname($self->{name});
d203 1
a203 1
	File::Path::mkpath($self->{name});
d220 2
a221 2
	link $linkname, $self->{name} or
	    die "Can't link $linkname to $self->{name}: $!";
d234 2
a235 2
	symlink $self->{linkname}, $self->{name} or 
	    die "Can't symlink $self->{linkname} to $self->{name}: $!";
d248 1
a248 1
	open (my $out, '>', $self->{name});
d250 1
a250 1
		die "Can't write to $self->{name}: $!";
d262 1
a262 1
			die "Error writing to $self->{name}: $!";
d267 1
a267 1
	$out->close() or die "Error closing $self->{name}: $!";
@


1.4
log
@Clean up PackageLocator so it looks somewhat more object-oriented.
Most importantly, put all the state information into the created object,
so that the actual archive can be closed, later reopened, and scanned
until the correct file is found.

This will be used to allow retrieving packages through ftp without keeping
loads of connections opened because of dependency resolving.

Approved by fries and naddy.
@
text
@d1 1
a1 1
# $OpenBSD: Ustar.pm,v 1.3 2003/12/10 17:45:11 espie Exp $
d215 1
d217 1
a217 3
		link $self->{cwd}."/".$self->{linkname}, $self->{name};
	} else {
		link $self->{linkname}, $self->{name};
d219 2
d233 2
a234 1
	symlink $self->{linkname}, $self->{name};
a242 2
use IO::File;

d247 1
a247 1
	my $out = new IO::File $self->{name}, "w";
d249 1
a249 2
		print "Can't write to ", $self->{name}, "\n";
		return;
d256 3
a258 1
		read($self->{archive}->{fh}, $buffer, $maxread);
d260 4
a263 1
		print $out $buffer;
d266 1
a266 1
	$out->close();
@


1.3
log
@stamp files and directories.
okay sturm@@
@
text
@d1 1
a1 1
# $OpenBSD: Ustar.pm,v 1.2 2003/10/31 09:30:10 espie Exp $
d59 1
a59 1
    return bless { fh => $fh, swallow => 0, unput => 0} , $class;
a100 6
sub unput
{
    my $self = shift;
    $self->{unput} = 1;
}

a103 4
    if ($self->{unput}) {
    	$self->{unput} = 0;
	return $self->{current};
    }
a170 1
    $self->{current} = $result;
@


1.2
log
@Fix typo (ouch) and logic order (chown before chmod)
Still a very good idea to mark setXid and special owners
in packing-lists (as make update-plist does anyways...)
@
text
@d1 1
a1 1
# $OpenBSD: Ustar.pm,v 1.1.1.1 2003/10/16 17:43:34 espie Exp $
d191 1
a262 1
	$self->SUPER::set_modes();
d274 1
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
# $OpenBSD: Ustar.pm,v 1.1.1.1 2003/10/16 17:16:30 espie Exp $
d145 1
a145 1
    $gid = name2gid($uname, $gid);
d189 1
a190 1
	chown $self->{uid}, $self->{gid}, $self->{name};
@


1.1.1.1
log
@new import of my pkgtools, after a slight naming disagreement with the
Upper Management...
@
text
@@
