head	1.77;
access;
symbols
	OPENBSD_6_1:1.77.0.2
	OPENBSD_6_1_BASE:1.77
	OPENBSD_6_0:1.74.0.4
	OPENBSD_6_0_BASE:1.74
	OPENBSD_5_9:1.72.0.2
	OPENBSD_5_9_BASE:1.72
	OPENBSD_5_8:1.72.0.4
	OPENBSD_5_8_BASE:1.72
	OPENBSD_5_7:1.71.0.2
	OPENBSD_5_7_BASE:1.71
	OPENBSD_5_6:1.66.0.4
	OPENBSD_5_6_BASE:1.66
	OPENBSD_5_5:1.60.0.4
	OPENBSD_5_5_BASE:1.60
	OPENBSD_5_4:1.54.0.6
	OPENBSD_5_4_BASE:1.54
	OPENBSD_5_3:1.54.0.4
	OPENBSD_5_3_BASE:1.54
	OPENBSD_5_2:1.54.0.2
	OPENBSD_5_2_BASE:1.54
	OPENBSD_5_1_BASE:1.53
	OPENBSD_5_1:1.53.0.2
	OPENBSD_5_0:1.51.0.2
	OPENBSD_5_0_BASE:1.51
	OPENBSD_4_9:1.45.0.2
	OPENBSD_4_9_BASE:1.45
	OPENBSD_4_8:1.37.0.2
	OPENBSD_4_8_BASE:1.37
	OPENBSD_4_7:1.18.0.2
	OPENBSD_4_7_BASE:1.18;
locks; strict;
comment	@# @;


1.77
date	2017.03.25.18.58.59;	author espie;	state Exp;
branches;
next	1.76;
commitid	tze2rAjBliJxVa9a;

1.76
date	2017.03.01.10.35.24;	author espie;	state Exp;
branches;
next	1.75;
commitid	WLXUAeW6LYQMCSi5;

1.75
date	2017.02.27.14.03.52;	author espie;	state Exp;
branches;
next	1.74;
commitid	c3kgqPdp6tlunPOd;

1.74
date	2016.06.15.15.40.13;	author espie;	state Exp;
branches;
next	1.73;
commitid	FvFggVo6v6h0AgLZ;

1.73
date	2016.06.06.13.58.55;	author espie;	state Exp;
branches;
next	1.72;
commitid	pHyhF6U3vfmY5FqA;

1.72
date	2015.05.25.07.20.31;	author espie;	state Exp;
branches;
next	1.71;
commitid	OQgkIpW2ns8hlwEU;

1.71
date	2015.01.04.14.20.04;	author espie;	state Exp;
branches;
next	1.70;
commitid	xJlx1plAz31SlC6u;

1.70
date	2015.01.04.14.10.20;	author espie;	state Exp;
branches;
next	1.69;
commitid	xYfsnhxsU1KFmOcD;

1.69
date	2014.12.03.22.41.11;	author espie;	state Exp;
branches;
next	1.68;
commitid	fzCFEdbJgcxfuVJA;

1.68
date	2014.11.30.15.46.45;	author espie;	state Exp;
branches;
next	1.67;
commitid	ZVZAhcUUjIc6oAS2;

1.67
date	2014.11.29.10.42.51;	author espie;	state Exp;
branches;
next	1.66;
commitid	XiRgNGt76qJ9BWZO;

1.66
date	2014.07.11.12.50.15;	author espie;	state Exp;
branches;
next	1.65;
commitid	7Rj2ymoDgIfa0BBq;

1.65
date	2014.07.07.16.55.16;	author espie;	state Exp;
branches;
next	1.64;
commitid	kzM5Gxg7nI20tyyw;

1.64
date	2014.07.07.16.45.52;	author espie;	state Exp;
branches;
next	1.63;
commitid	YoDYjT4iTng8OZSP;

1.63
date	2014.05.30.15.04.54;	author espie;	state Exp;
branches;
next	1.62;

1.62
date	2014.05.20.05.46.13;	author espie;	state Exp;
branches;
next	1.61;

1.61
date	2014.03.18.18.53.29;	author espie;	state Exp;
branches;
next	1.60;

1.60
date	2014.01.30.13.23.51;	author espie;	state Exp;
branches;
next	1.59;

1.59
date	2013.12.30.09.01.30;	author espie;	state Exp;
branches;
next	1.58;

1.58
date	2013.12.25.15.59.51;	author espie;	state Exp;
branches;
next	1.57;

1.57
date	2013.12.25.14.20.48;	author espie;	state Exp;
branches;
next	1.56;

1.56
date	2013.12.23.16.50.29;	author espie;	state Exp;
branches;
next	1.55;

1.55
date	2013.12.08.12.14.41;	author espie;	state Exp;
branches;
next	1.54;

1.54
date	2012.07.06.12.02.50;	author espie;	state Exp;
branches;
next	1.53;

1.53
date	2011.10.09.16.43.50;	author espie;	state Exp;
branches;
next	1.52;

1.52
date	2011.08.17.10.48.27;	author espie;	state Exp;
branches;
next	1.51;

1.51
date	2011.07.17.13.16.15;	author espie;	state Exp;
branches;
next	1.50;

1.50
date	2011.07.14.11.31.20;	author espie;	state Exp;
branches;
next	1.49;

1.49
date	2011.07.13.13.01.13;	author espie;	state Exp;
branches;
next	1.48;

1.48
date	2011.07.13.12.32.15;	author espie;	state Exp;
branches;
next	1.47;

1.47
date	2011.07.12.10.06.57;	author espie;	state Exp;
branches;
next	1.46;

1.46
date	2011.03.07.09.26.47;	author espie;	state Exp;
branches;
next	1.45;

1.45
date	2011.01.23.06.56.53;	author espie;	state Exp;
branches;
next	1.44;

1.44
date	2010.12.29.13.03.05;	author espie;	state Exp;
branches;
next	1.43;

1.43
date	2010.12.24.09.09.54;	author espie;	state Exp;
branches;
next	1.42;

1.42
date	2010.12.24.09.04.14;	author espie;	state Exp;
branches;
next	1.41;

1.41
date	2010.12.18.10.39.01;	author espie;	state Exp;
branches;
next	1.40;

1.40
date	2010.12.05.09.41.55;	author espie;	state Exp;
branches;
next	1.39;

1.39
date	2010.10.27.14.35.56;	author espie;	state Exp;
branches;
next	1.38;

1.38
date	2010.08.13.11.12.04;	author espie;	state Exp;
branches;
next	1.37;

1.37
date	2010.07.12.09.31.52;	author espie;	state Exp;
branches;
next	1.36;

1.36
date	2010.07.09.12.42.43;	author espie;	state Exp;
branches;
next	1.35;

1.35
date	2010.07.06.12.12.37;	author espie;	state Exp;
branches;
next	1.34;

1.34
date	2010.07.04.18.21.03;	author espie;	state Exp;
branches;
next	1.33;

1.33
date	2010.07.01.19.15.59;	author espie;	state Exp;
branches;
next	1.32;

1.32
date	2010.06.30.10.51.04;	author espie;	state Exp;
branches;
next	1.31;

1.31
date	2010.06.30.10.41.41;	author espie;	state Exp;
branches;
next	1.30;

1.30
date	2010.06.30.10.27.17;	author espie;	state Exp;
branches;
next	1.29;

1.29
date	2010.06.25.11.12.14;	author espie;	state Exp;
branches;
next	1.28;

1.28
date	2010.06.25.10.54.28;	author espie;	state Exp;
branches;
next	1.27;

1.27
date	2010.06.18.10.55.58;	author espie;	state Exp;
branches;
next	1.26;

1.26
date	2010.06.15.08.26.39;	author espie;	state Exp;
branches;
next	1.25;

1.25
date	2010.06.09.08.13.19;	author espie;	state Exp;
branches;
next	1.24;

1.24
date	2010.06.09.07.26.01;	author espie;	state Exp;
branches;
next	1.23;

1.23
date	2010.06.05.09.15.55;	author espie;	state Exp;
branches;
next	1.22;

1.22
date	2010.06.05.07.35.21;	author landry;	state Exp;
branches;
next	1.21;

1.21
date	2010.06.04.13.19.39;	author espie;	state Exp;
branches;
next	1.20;

1.20
date	2010.05.10.09.17.55;	author espie;	state Exp;
branches;
next	1.19;

1.19
date	2010.03.22.20.38.44;	author espie;	state Exp;
branches;
next	1.18;

1.18
date	2010.01.11.12.29.13;	author espie;	state Exp;
branches;
next	1.17;

1.17
date	2010.01.10.21.27.59;	author espie;	state Exp;
branches;
next	1.16;

1.16
date	2010.01.09.14.49.53;	author espie;	state Exp;
branches;
next	1.15;

1.15
date	2010.01.03.09.34.22;	author espie;	state Exp;
branches;
next	1.14;

1.14
date	2010.01.02.14.13.02;	author espie;	state Exp;
branches;
next	1.13;

1.13
date	2009.12.28.14.46.48;	author espie;	state Exp;
branches;
next	1.12;

1.12
date	2009.12.22.18.26.47;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2009.12.21.13.24.57;	author espie;	state Exp;
branches;
next	1.10;

1.10
date	2009.12.21.10.38.58;	author espie;	state Exp;
branches;
next	1.9;

1.9
date	2009.12.20.22.38.45;	author espie;	state Exp;
branches;
next	1.8;

1.8
date	2009.12.19.14.21.14;	author espie;	state Exp;
branches;
next	1.7;

1.7
date	2009.12.17.11.11.51;	author espie;	state Exp;
branches;
next	1.6;

1.6
date	2009.12.14.09.35.56;	author espie;	state Exp;
branches;
next	1.5;

1.5
date	2009.12.05.10.08.58;	author espie;	state Exp;
branches;
next	1.4;

1.4
date	2009.11.17.10.17.21;	author espie;	state Exp;
branches;
next	1.3;

1.3
date	2009.11.16.14.42.18;	author espie;	state Exp;
branches;
next	1.2;

1.2
date	2009.11.16.12.53.27;	author espie;	state Exp;
branches;
next	1.1;

1.1
date	2009.11.16.12.20.32;	author espie;	state Exp;
branches;
next	;


desc
@@


1.77
log
@tweak checksums on delete to not happen by default, with an interface
as discussed with sthen@@

manpage bits to follow soonish
@
text
@# ex:ts=8 sw=4:
# $OpenBSD: AddDelete.pm,v 1.76 2017/03/01 10:35:24 espie Exp $
#
# Copyright (c) 2007-2010 Marc Espie <espie@@openbsd.org>
#
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
#

use strict;
use warnings;

# common framework, let's place most everything in there
package main;
our $not;

package OpenBSD::AddDelete;
use OpenBSD::Error;
use OpenBSD::Paths;
use OpenBSD::PackageInfo;
use OpenBSD::AddCreateDelete;

sub do_the_main_work
{
	my ($self, $state) = @@_;

	if ($state->{bad}) {
		return;
	}

	my $handler = sub { $state->fatal("Caught SIG#1", shift); };
	local $SIG{'INT'} = $handler;
	local $SIG{'QUIT'} = $handler;
	local $SIG{'HUP'} = $handler;
	local $SIG{'KILL'} = $handler;
	local $SIG{'TERM'} = $handler;

	if ($state->defines('debug')) {
		$self->main($state);
	} else {
		eval { $self->main($state); };
	}
	my $dielater = $@@;
	return $dielater;
}

sub framework
{
	my ($self, $state) = @@_;

	my $do = sub {
		lock_db($state->{not}, $state) unless $state->defines('nolock');
		$state->check_root;
		$self->process_parameters($state);
		my $dielater = $self->do_the_main_work($state);
		# cleanup various things
		$state->{recorder}->cleanup($state);
		$state->ldconfig->ensure;
		OpenBSD::PackingElement->finish($state);
		$state->progress->clear;
		$state->log->dump;
		$self->finish_display($state);
		if ($state->verbose >= 2 || $state->{size_only} ||
		    $state->defines('tally')) {
			$state->vstat->tally;
		}
		$state->say("Extracted #1 from #2", 
		    $state->{stats}{donesize},
		    $state->{stats}{totsize}) 
			if defined $state->{stats} and $state->verbose;
		# show any error, and show why we died...
		rethrow $dielater;
	};
	if ($state->defines('debug')) {
		&$do;
	} else {
		try {
			&$do;
		} catch {
			$state->errsay("#1: #2", $0, $_);
			OpenBSD::Handler->reset;
			if ($_ =~ m/^Caught SIG(\w+)/o) {
				kill $1, $$;
			}
			$state->{bad}++;
		};
	}

}

sub parse_and_run
{
	my ($self, $cmd) = @@_;

	my $state = $self->new_state($cmd);
	$state->handle_options;
	local $SIG{'INFO'} = sub { $state->status->print($state); };

	$self->framework($state);
	return $state->{bad} != 0;
}

# nothing to do
sub tweak_list
{
}

sub process_setlist
{
	my ($self, $state) = @@_;
	$state->tracker->todo(@@{$state->{setlist}});
	# this is the actual very small loop that processes all sets
	while (my $set = shift @@{$state->{setlist}}) {
		$state->status->what->set($set);
		$set = $set->real_set;
		next if $set->{finished};
		$state->progress->set_header('Checking packages');
		unshift(@@{$state->{setlist}}, $self->process_set($set, $state));
		$self->tweak_list($state);
	}
}

package OpenBSD::SharedItemsRecorder;
sub new
{
	my $class = shift;
	return bless {}, $class;
}

sub is_empty
{
	my $self = shift;
	return !(defined $self->{dirs} or defined $self->{users} or
		defined $self->{groups});
}

sub cleanup
{
	my ($self, $state) = @@_;
	return if $self->is_empty or $state->{not};

	require OpenBSD::SharedItems;
	OpenBSD::SharedItems::cleanup($self, $state);
}

package OpenBSD::AddDelete::State;
use OpenBSD::Vstat;
use OpenBSD::Log;
our @@ISA = qw(OpenBSD::AddCreateDelete::State);

sub handle_options
{
	my ($state, $opt_string, @@usage) = @@_;

	$state->{extra_stats} = 0;
	$state->{opt}{V} = sub {
		$state->{extra_stats}++;
	};
	$state->{no_exports} = 1;
	$state->add_interactive_options;
	$state->SUPER::handle_options($opt_string.'aciInqsVB:', @@usage);

	if ($state->opt('s')) {
		$state->{not} = 1;
	}
	# XXX RequiredBy
	$main::not = $state->{not};
	$state->{localbase} = $state->opt('L') // OpenBSD::Paths->localbase;
	$ENV{PATH} = join(':',
	    '/bin',
	    '/sbin',
	    '/usr/bin',
	    '/usr/sbin',
	    '/usr/X11R6/bin',
	    "$state->{localbase}/bin",
	    "$state->{localbase}/sbin");

	$state->{size_only} = $state->opt('s');
	$state->{quick} = $state->opt('q');
	$state->{extra} = $state->opt('c');
	$state->{automatic} = $state->opt('a') // 0;
	$ENV{'PKG_DELETE_EXTRA'} = $state->{extra} ? "Yes" : "No";
	if ($state->{not}) {
		$state->{loglevel} = 0;
	}
	$state->{loglevel} //= 1;
	if ($state->{loglevel}) {
		require Sys::Syslog;
		Sys::Syslog::openlog($state->{cmd}, "nofatal");
	}
	$state->{wantntogo} = $state->{extra_stats};
	if (defined $ENV{PKG_CHECKSUM}) {
		$state->{subst}->add('checksum', 1);
	}
}

sub init
{
	my $self = shift;
	$self->{l} = OpenBSD::Log->new($self);
	$self->{vstat} = OpenBSD::Vstat->new($self);
	$self->{status} = OpenBSD::Status->new;
	$self->{recorder} = OpenBSD::SharedItemsRecorder->new;
	$self->{v} = 0;
	$self->SUPER::init(@@_);
	$self->{export_level}++;
}

sub syslog
{
	my $self = shift;
	return unless $self->{loglevel};
	Sys::Syslog::syslog('info', $self->f(@@_));
}

sub ntodo
{
	my ($state, $offset) = @@_;
	return $state->tracker->sets_todo($offset);
}

# one-level dependencies tree, for nicer printouts
sub build_deptree
{
	my ($state, $set, @@deps) = @@_;

	if (defined $state->{deptree}->{$set}) {
		$set = $state->{deptree}->{$set};
	}
	for my $dep (@@deps) {
		$state->{deptree}->{$dep} = $set unless
		    defined $state->{deptree}->{$dep};
	}
}

sub deptree_header
{
	my ($state, $pkg) = @@_;
	if (defined $state->{deptree}->{$pkg}) {
		my $s = $state->{deptree}->{$pkg}->real_set;
		if ($s eq $pkg) {
			delete $state->{deptree}->{$pkg};
		} else {
			return $s->short_print.':';
		}
	}
	return '';
}

sub vstat
{
	my $self = shift;
	return $self->{vstat};
}

sub log
{
	my $self = shift;
	if (@@_ == 0) {
		return $self->{l};
	} else {
		$self->{l}->say(@@_);
	}
}

sub run_quirks
{
	my ($state, $sub) = @@_;

	if (!exists $state->{quirks}) {
		eval {
			require OpenBSD::Quirks;
			# interface version number.
			$state->{quirks} = OpenBSD::Quirks->new(1);
		};
		if ($@@) {
			my $show = $state->verbose >= 2;
			if (!$show) {
				my $l = $state->repo->installed->match_locations(OpenBSD::Search::Stem->new('quirks'));
				$show = @@$l > 0;
			}
			$state->errsay("Can't load quirk: #1", $@@) if $show;
			# XXX cache that this didn't work
			$state->{quirks} = undef;
		}
	}

	if (defined $state->{quirks}) {
		eval {
			&$sub($state->{quirks});
		};
		if ($@@) {
			$state->errsay("Bad quirk: #1", $@@);
		}
	}
}

sub check_root
{
	my $state = shift;
	if ($< && !$state->defines('nonroot')) {
		if ($state->{not}) {
			$state->errsay("#1 should be run as root",
			    $state->{cmd}) if $state->verbose;
		} else {
			$state->fatal("#1 must be run as root", $state->{cmd});
		}
	}
}

sub choose_location
{
	my ($state, $name, $list, $is_quirks) = @@_;
	if (@@$list == 0) {
		if (!$is_quirks) {
			$state->errsay("Can't find #1", $name);
			$state->run_quirks(
			    sub {
				my $quirks = shift;
				$quirks->filter_obsolete([$name], $state);
			    });
		}
		return undef;
	} elsif (@@$list == 1) {
		return $list->[0];
	}

	my %h = map {($_->name, $_)} @@$list;
	if ($state->is_interactive) {
		$h{'<None>'} = undef;
		$state->progress->clear;
		my $result = $state->ask_list("Ambiguous: choose package for $name", sort keys %h);
		return $h{$result};
	} else {
		$state->errsay("Ambiguous: #1 could be #2",
		    $name, join(' ', keys %h));
		return undef;
	}
}

sub status
{
	my $self = shift;

	return $self->{status};
}

sub replacing
{
	my $self = shift;
	return $self->{replacing};
}

OpenBSD::Auto::cache(ldconfig,
    sub {
    	my $self = shift;
	return OpenBSD::LdConfig->new($self);
    });

# if we're not running as root, allow some stuff when not under /usr/local
sub allow_nonroot
{
	my ($state, $path) = @@_;
	return $state->defines('nonroot') &&
	    $path !~ m,^\Q$state->{localbase}/\E,;
}

sub make_path
{
	my ($state, $path, $fullname) = @@_;
	require File::Path;
	if ($state->allow_nonroot($fullname)) {
		eval {
			File::Path::mkpath($path);
		};
	} else {
		File::Path::mkpath($path);
	}
}

# this is responsible for running ldconfig when needed
package OpenBSD::LdConfig;

sub new
{
	my ($class, $state) = @@_;
	bless { state => $state, todo => 0 }, $class;
}

# called once to figure out which directories are actually used
sub init
{
	my $self = shift;
	my $state = $self->{state};
	my $destdir = $state->{destdir};

	$self->{ldconfig} = [OpenBSD::Paths->ldconfig];

	$self->{path} = {};
	if ($destdir ne '') {
		unshift @@{$self->{ldconfig}}, OpenBSD::Paths->chroot, '--',
		    $destdir;
	}
	open my $fh, "-|", @@{$self->{ldconfig}}, "-r";
	if (defined $fh) {
		while (<$fh>) {
			if (m/^\s*search directories:\s*(.*?)\s*$/o) {
				for my $d (split(/\:/o, $1)) {
					$self->{path}{$d} = 1;
				}
				last;
			}
		}
		close($fh);
	} else {
		$state->errsay("Can't find ldconfig");
	}
}

# called from libs to figure out whether ldconfig should be rerun
sub mark_directory
{
	my ($self, $name) = @@_;
	if (!defined $self->{path}) {
		$self->init;
	}
	require File::Basename;
	my $d = File::Basename::dirname($name);
	if ($self->{path}{$d}) {
		$self->{todo} = 1;
	}
}

# call before running any command (or at end) to run ldconfig just in time
sub ensure
{
	my $self = shift;
	if ($self->{todo}) {
		my $state = $self->{state};
		$state->vsystem(@@{$self->{ldconfig}}, "-R")
		    unless $state->{not};
		$self->{todo} = 0;
	}
}

# the object that gets displayed during status updates
package OpenBSD::Status;

sub print
{
	my ($self, $state) = @@_;

	my $what = $self->{what};
	$what //= "Processing";
	my $object;
	if (defined $self->{object}) {
		$object = $self->{object};
	} elsif (defined $self->{set}) {
		$object = $self->{set}->print;
	} else {
		$object = "Parameters";
	}

	$state->say($what." #1#2", $object, $state->ntogo_string);
	if ($state->defines('carp')) {
		require Carp;
		Carp::cluck("currently here");
	}
}

sub set
{
	my ($self, $set) = @@_;
	delete $self->{object};
	$self->{set} = $set;
	return $self;
}

sub object
{
	my ($self, $object) = @@_;
	delete $self->{set};
	$self->{object} = $object;
	return $self;
}

sub what
{
	my ($self, $what) = @@_;
	$self->{what} = $what;
	return $self;
}

sub new
{
	my $class = shift;

	bless {}, $class;
}

1;
@


1.76
log
@scrape most of the config framework
okay aja@@, rpe@@
@
text
@d2 1
a2 1
# $OpenBSD: AddDelete.pm,v 1.75 2017/02/27 14:03:52 espie Exp $
d201 3
@


1.75
log
@framework for some performance stats as a -V... option (like how much
of a package you actually downloaded, or how many packages you touch)
okay aja@@
@
text
@d2 1
a2 1
# $OpenBSD: AddDelete.pm,v 1.74 2016/06/15 15:40:13 espie Exp $
d188 1
a188 1
	$state->{quick} = $state->opt('q') || $state->config->istrue("nochecksum");
d195 1
a195 1
	$state->{loglevel} //= $state->config->value("loglevel") // 1;
d200 1
a200 2
	$state->{wantntogo} = $state->{extra_stats} || 
	    $state->config->istrue("ntogo");
@


1.74
log
@dedup interactive options handling code yet again.
dynamic code mixin
@
text
@d2 1
a2 1
# $OpenBSD: AddDelete.pm,v 1.73 2016/06/06 13:58:55 espie Exp $
d164 3
a166 5
	# backward compatibility
	$state->{opt}{F} = sub {
		for my $o (split /\,/o, shift) {
			$state->{subst}->add($o, 1);
		}
d170 1
a170 1
	$state->SUPER::handle_options($opt_string.'aciInqsB:F:', @@usage);
d200 2
a212 1
	$self->{wantntogo} = $self->config->istrue("ntogo");
@


1.73
log
@fix somewhat broken inheritance: the actual -i/-I interactive dance is
only relevant for pkg_add/pkg_delete.

Every tool needs an interactive object, but setting that to InteractiveStub
"just in case" after doing the interactive dance is fine for
pkg_create/pkg_sign

problem noticed by jsg@@ in pkg_sign(1).
@
text
@d2 1
a2 1
# $OpenBSD: AddDelete.pm,v 1.72 2015/05/25 07:20:31 espie Exp $
a169 4
	my $i;
	$state->{opt}{i} //= sub {
		$i++;
	};
d171 1
a175 9
	}
	if ($state->opt('I')) {
		$i = 0;
	} elsif (!defined $i) {
		$i = -t STDIN;
	}
	if ($i) {
		require OpenBSD::Interactive;
		$state->{interactive} = OpenBSD::Interactive->new($state, $i);
@


1.72
log
@allow pkg_add as nonroot to soft-fail when outside of local base.
@
text
@d2 1
a2 1
# $OpenBSD: AddDelete.pm,v 1.71 2015/01/04 14:20:04 espie Exp $
d170 4
d179 9
@


1.71
log
@tweak the ntogo messages slightly so that they work better in all situations
@
text
@d2 1
a2 1
# $OpenBSD: AddDelete.pm,v 1.70 2015/01/04 14:10:20 espie Exp $
d366 21
@


1.70
log
@too many todo. Use unambiguous names, since they're not the same operation
at all
@
text
@d2 1
a2 1
# $OpenBSD: AddDelete.pm,v 1.69 2014/12/03 22:41:11 espie Exp $
d450 1
a450 1
	$state->say($what." #1 (#2)", $object, $state->ntogo_string);
@


1.69
log
@zap extra parameter that my first read missed, because that one is constant.
Strangeness noticed by aja@@
@
text
@d2 1
a2 1
# $OpenBSD: AddDelete.pm,v 1.68 2014/11/30 15:46:45 espie Exp $
d223 1
a223 1
sub todo
@


1.68
log
@forgot to take that out...
@
text
@d2 1
a2 1
# $OpenBSD: AddDelete.pm,v 1.67 2014/11/29 10:42:51 espie Exp $
d339 1
a339 1
		my $result = $state->ask_list("Ambiguous: choose package for $name", 1, sort keys %h);
@


1.67
log
@simplify the interactive code into its own little object with simpler
interface, so that most is it interactive tests vanish from the main
program.
@
text
@d2 1
a2 1
# $OpenBSD: AddDelete.pm,v 1.66 2014/07/11 12:50:15 espie Exp $
a177 10
	if ($state->opt('i') && $state->opt('I')) {
		$state->usage("-i and -I are reverse options, make up your mind");
	}
	if ($state->opt('i')) {
		$state->{interactive} = 1;
	} elsif ($state->opt('I')) {
		$state->{interactive} = 0;
	} else {
		$state->{interactive} = -t STDIN;
	}
@


1.66
log
@display the extraction tally only if verbose
@
text
@d2 1
a2 1
# $OpenBSD: AddDelete.pm,v 1.65 2014/07/07 16:55:16 espie Exp $
d346 1
a346 3
	if ($state->{interactive}) {
		require OpenBSD::Interactive;

a355 17
}

sub confirm
{
	my ($state, $prompt, $default) = @@_;

	return 0 if !$state->{interactive};
	require OpenBSD::Interactive;
	return OpenBSD::Interactive::confirm($prompt, $default);
}

sub ask_list
{
	my ($state, $prompt, $interactive, @@values) = @@_;

	require OpenBSD::Interactive;
	return OpenBSD::Interactive::ask_list($prompt, $interactive, @@values);
@


1.65
log
@don't throw strange warnings during pkg_delete...
@
text
@d2 1
a2 1
# $OpenBSD: AddDelete.pm,v 1.64 2014/07/07 16:45:52 espie Exp $
d78 2
a79 1
		    $state->{stats}{totsize}) if defined $state->{stats};
@


1.64
log
@display saved size for now, to be disabled once I'm satisfied this is very
good :)
@
text
@d2 1
a2 1
# $OpenBSD: AddDelete.pm,v 1.63 2014/05/30 15:04:54 espie Exp $
d78 1
a78 1
		    $state->{stats}{totsize});
@


1.63
log
@oops, auto-read config only *after* we have a way to print out errors.
Also zap bad lines completely.

issue reported by aja@@
@
text
@d2 1
a2 1
# $OpenBSD: AddDelete.pm,v 1.62 2014/05/20 05:46:13 espie Exp $
d76 3
@


1.62
log
@makewhatis being now external, it no longer requires picky/test/check_dir.
It also can't handle too many manpages at once (shell limit) so hand-feed
it (problem spotted by landry@@).

Some tests by schwarze@@.
@
text
@d2 1
a2 1
# $OpenBSD: AddDelete.pm,v 1.61 2014/03/18 18:53:29 espie Exp $
d217 1
a218 1
	$self->SUPER::init(@@_);
@


1.61
log
@remove $_ usage that warns under perl 5.18
@
text
@d2 1
a2 1
# $OpenBSD: AddDelete.pm,v 1.60 2014/01/30 13:23:51 espie Exp $
a308 18
}

sub vsystem
{
	my $self = shift;
	my $verbose = $self;
	if ($self->verbose < 2) {
		$self->system(@@_);
	} else {
		$self->verbose_system(@@_);
	}
}

sub system
{
	my $self = shift;
	$self->progress->clear;
	$self->SUPER::system(@@_);
@


1.60
log
@avoid storing dead keys.
quirks is exceptional, since it needs to be cached negatively.
@
text
@d2 1
a2 1
# $OpenBSD: AddDelete.pm,v 1.59 2013/12/30 09:01:30 espie Exp $
a434 1
		my $_;
@


1.59
log
@explicitly fix the PATH to something sensible
move "replacing" to a method, so that it can be more specific later.
@
text
@d2 1
a2 1
# $OpenBSD: AddDelete.pm,v 1.58 2013/12/25 15:59:51 espie Exp $
d296 1
a296 1
			# cache that this didn't work
@


1.58
log
@fix autoloading of quirks: don't try to run quirks while processing the
quirks set, as we may accidentally load the old one.
also, in case we can't load quirks, report if quirks should be there,
e.g., compilation error, without regard to verbose status
@
text
@d2 1
a2 1
# $OpenBSD: AddDelete.pm,v 1.57 2013/12/25 14:20:48 espie Exp $
d185 9
d396 6
@


1.57
log
@a bit more scaffolding for running quirks. In particular, once quirks
have been loaded, complain loudly if something doesn't work.
(and complain when quirks don't load in !verbose mode)
@
text
@d2 1
a2 1
# $OpenBSD: AddDelete.pm,v 1.56 2013/12/23 16:50:29 espie Exp $
d281 6
a286 2
			$state->errsay("Can't load quirk: #1", $@@)
			    if $state->verbose >= 2;
@


1.56
log
@move ntogo code, so it can be used while copying packages in pkg_create.
add the few lines necessary for that to work.
@
text
@d2 1
a2 1
# $OpenBSD: AddDelete.pm,v 1.55 2013/12/08 12:14:41 espie Exp $
d270 28
d335 5
a339 4
			eval {
				my $r = [$name];
				$state->quirks->filter_obsolete($r, $state);
			}
@


1.55
log
@also cover initial installations (which means we do try to install
quirks even for initial installations)
@
text
@d2 1
a2 1
# $OpenBSD: AddDelete.pm,v 1.54 2012/07/06 12:02:50 espie Exp $
a219 9
sub ntogo
{
	my ($self, $offset) = @@_;

	return $self->{wantntogo} ?
	    $self->progress->ntogo($self, $offset) :
	    $self->f("ok");
}

a223 7
}

sub ntogo_string
{
	my ($self, $offset) = @@_;

	return $self->todo($offset // 0);
@


1.54
log
@have -i be automatically on for ttys.
use -i/-I to force interactive/non interactive mode
(-I for not running scripts has been dead for years)
@
text
@d2 1
a2 1
# $OpenBSD$
d321 7
a327 1
		$state->errsay("Can't find #1", $name) unless $is_quirks;
@


1.53
log
@don't be too hasty, we can choose to syslog (OR NOT) *after* we parse the
command line options.

Problem noticed by Markus Lude.
@
text
@d2 1
a2 1
# $OpenBSD: AddDelete.pm,v 1.52 2011/08/17 10:48:27 espie Exp $
d174 10
a183 1
	$state->{interactive} = $state->opt('i');
a187 1
	$state->{dont_run_scripts} = $state->opt('I');
@


1.52
log
@pkg_add and pkg_delete will now syslog activity by default.
@
text
@d2 1
a2 1
# $OpenBSD: AddDelete.pm,v 1.51 2011/07/17 13:16:15 espie Exp $
d182 8
a200 8
	if ($self->{not}) {
		$self->{loglevel} = 0;
	}
	$self->{loglevel} //= $self->config->value("loglevel") // 1;
	if ($self->{loglevel}) {
		require Sys::Syslog;
		Sys::Syslog::openlog($self->{cmd}, "nofatal");
	}
@


1.51
log
@unify the main loop some more: add and delete do more or less the
same processing.

start making process_set similar as well
@
text
@d2 1
a2 1
# $OpenBSD: AddDelete.pm,v 1.50 2011/07/14 11:31:20 espie Exp $
d193 8
d203 7
@


1.50
log
@move deptree_header into AddDelete, use it in pkg_delete.
Now, pkg_delete will display things a lot like pkg_add, spelling out
what reverse dependencies trigger the deletion of a given package at that
point in the list.

by popular demand.
@
text
@d2 1
a2 1
# $OpenBSD: AddDelete.pm,v 1.49 2011/07/13 13:01:13 espie Exp $
d106 20
@


1.49
log
@share code
@
text
@d2 1
a2 1
# $OpenBSD: AddDelete.pm,v 1.48 2011/07/13 12:32:15 espie Exp $
d197 28
@


1.48
log
@create DeleteSet as a specialized version of UpdateSets that print
differently, specialize the states a wee little bit.
@
text
@d2 1
a2 1
# $OpenBSD: AddDelete.pm,v 1.47 2011/07/12 10:06:57 espie Exp $
d184 6
@


1.47
log
@move option -a up into common add/delete code, in preparation for pkg_delete
change.
@
text
@d2 1
a2 1
# $OpenBSD: AddDelete.pm,v 1.46 2011/03/07 09:26:47 espie Exp $
a286 24
}

sub updateset
{
	my $self = shift;
	require OpenBSD::UpdateSet;

	return OpenBSD::UpdateSet->new($self);
}

sub updateset_with_new
{
	my ($self, $pkgname) = @@_;

	return $self->updateset->add_newer(
	    OpenBSD::Handle->create_new($pkgname));
}

sub updateset_from_location
{
	my ($self, $location) = @@_;

	return $self->updateset->add_newer(
	    OpenBSD::Handle->from_location($location));
@


1.46
log
@run makewhatis during pkg_create in verbose mode.
tweak temp manpage generation a bit, so that it has correct names in its
own directory, because makewhatis will be really pissed off otherwise.
@
text
@d2 1
a2 1
# $OpenBSD: AddDelete.pm,v 1.45 2011/01/23 06:56:53 espie Exp $
d147 1
a147 1
	$state->SUPER::handle_options($opt_string.'ciInqsB:F:', @@usage);
d160 1
@


1.45
log
@hide details of "finish" inside PackingElement proper.
do the font dirs, also display a message for new installed rcscripts, and
if some stuff has been added to the readmes directory.
@
text
@d2 1
a2 1
# $OpenBSD: AddDelete.pm,v 1.44 2010/12/29 13:03:05 espie Exp $
a309 19
}

# those are required for makewhatis integration
sub picky
{
	return shift->{picky};
}

sub testmode
{
	return shift->{testmode};
}

sub check_dir
{
	my ($self, $dir) = @@_;
	unless (-d $dir) {
	    $self->fatal("#1: #2 is not a directory", $0, $dir);
	}
@


1.44
log
@more stuff that uses print directly dies
@
text
@d2 1
a2 1
# $OpenBSD: AddDelete.pm,v 1.43 2010/12/24 09:09:54 espie Exp $
d68 1
a68 1
		OpenBSD::PackingElement::Fontdir::finish_fontdirs($state);
@


1.43
log
@move the handling of ldconfig to AddDelete::State
actually simplifies code a great deal. It's not as if trying to avoid
loading ten lines of code is a good idea.
@
text
@d2 1
a2 1
# $OpenBSD: AddDelete.pm,v 1.42 2010/12/24 09:04:14 espie Exp $
d61 1
a61 1
		lock_db($state->{not}) unless $state->defines('nolock');
d85 1
a85 1
			print STDERR "$0: $_\n";
@


1.42
log
@handle failures from ports tree with more care.
this does avoid infinite loops in case of wrong plists.
necessary since print-plist-with-depends CAN fail...
@
text
@d2 1
a2 1
# $OpenBSD$
d67 1
a67 1
		OpenBSD::PackingElement::Lib::ensure_ldconfig($state);
d328 72
@


1.41
log
@bump ->defines up to main state class.
@
text
@d2 1
a2 1
# $OpenBSD: AddDelete.pm,v 1.40 2010/12/05 09:41:55 espie Exp $
@


1.40
log
@tweak the framework so that individual modules don't exist and return
the exit code upstream instead.
this simplifies the task of people who want to reuse it, as noted by
landry@@
@
text
@d2 1
a2 1
# $OpenBSD: AddDelete.pm,v 1.39 2010/10/27 14:35:56 espie Exp $
a285 6
}

sub defines
{
	my ($self, $k) = @@_;
	return $self->{subst}->value($k);
@


1.39
log
@initial scaffolding for @@rcscript: for now, acts like normal files,
but allow absolute pathnames (treat that as an implicit @@cwd).
@
text
@d2 1
a2 1
# $OpenBSD$
d37 1
a37 1
		exit(1);
d90 1
a90 1
			exit(1);
a93 3
	if ($state->{bad}) {
		exit(1);
	}
d105 1
@


1.38
log
@whitespace
@
text
@@


1.37
log
@need to copy f() parameters, otherwise strange bugs with sub expressions
may occur (bug in locality in @@_ ?)

Add missing bagage to State.pm to be able to interact directly with
Makewhatis, later.
@
text
@d2 1
a2 1
# $OpenBSD: AddDelete.pm,v 1.36 2010/07/09 12:42:43 espie Exp $
d182 2
a183 2
	return $self->{wantntogo} ? 
	    $self->progress->ntogo($self, $offset) : 
@


1.36
log
@fix pkg_mklocatedb
@
text
@d2 1
a2 1
# $OpenBSD: AddDelete.pm,v 1.35 2010/07/06 12:12:37 espie Exp $
d318 19
@


1.35
log
@fuss over wantntogo, especially when it's false (make sure we still get :ok
at end of lines instead of '' replacing 30/50)
@
text
@d2 1
a2 1
# $OpenBSD: AddDelete.pm,v 1.34 2010/07/04 18:21:03 espie Exp $
d175 1
@


1.34
log
@two config options
@
text
@d2 1
a2 1
# $OpenBSD: AddDelete.pm,v 1.33 2010/07/01 19:15:59 espie Exp $
d181 3
a183 1
	return $self->{wantntogo} ? $self->progress->ntogo($self, $offset) : "";
@


1.33
log
@remove the try/catch in debug mode, so that we get the errors directly...
@
text
@d2 1
a2 1
# $OpenBSD: AddDelete.pm,v 1.32 2010/06/30 10:51:04 espie Exp $
d159 1
a159 1
	$state->{quick} = $state->opt('q');
d173 1
d181 1
a181 1
	return $self->progress->ntogo($self, $offset);
@


1.32
log
@allow say and errsay to work without parameters, as it's ways common.
create verbose_system up in state, because it makes sense without verbose.
@
text
@d2 1
a2 1
# $OpenBSD$
d59 2
a60 1
	try {
a77 7
	} catch {
		print STDERR "$0: $_\n";
		OpenBSD::Handler->reset;
		if ($_ =~ m/^Caught SIG(\w+)/o) {
			kill $1, $$;
		}
		exit(1);
d79 14
@


1.31
log
@whitespace cleanup
@
text
@d205 1
a205 7
		$self->print("Running #1", join(' ', @@_));
		my $r = CORE::system(@@_);
		if ($r != 0) {
			$self->say("... failed: #1", $self->child_error);
		} else {
			$self->say("");
		}
@


1.30
log
@UpdateSet will need access to state->repo, so it's better to have all
updateset creations operations go through state as well.
@
text
@d2 1
a2 1
# $OpenBSD: AddDelete.pm,v 1.29 2010/06/25 11:12:14 espie Exp $
@


1.29
log
@clean-up options handling some more
@
text
@d2 1
a2 1
# $OpenBSD$
d288 24
@


1.28
log
@move handle_options in state, as should be.
fix a buglet in vsystem
@
text
@d2 1
a2 1
# $OpenBSD: AddDelete.pm,v 1.27 2010/06/18 10:55:58 espie Exp $
a31 10
sub handle_options
{
	my ($self, $opt_string, $hash, $cmd, @@usage) = @@_;

	my $state = $self->new_state($cmd);
	$state->{opt} = $hash;
	$state->handle_options($opt_string, @@usage);
	return $state;
}

d95 2
a96 1
	my $state = $self->handle_options($cmd);
d140 1
@


1.27
log
@whitespace
@
text
@d2 1
a2 1
# $OpenBSD$
a31 2
our @@ISA = qw(OpenBSD::AddCreateDelete);

d38 1
a38 20
	$hash->{F} = sub {
		for my $o (split /\,/o, shift) {
			$state->{subst}->add($o, 1);
		}
	};
	$self->SUPER::handle_options($opt_string.'ciInqsB:F:',
	    $state, @@usage);

	if ($state->opt('s')) {
		$state->{not} = 1;
	}
	# XXX RequiredBy
	$main::not = $state->{not};
	$state->{interactive} = $state->opt('i');
	$state->{localbase} = $state->opt('L') // OpenBSD::Paths->localbase;
	$state->{size_only} = $state->opt('s');
	$state->{quick} = $state->opt('q');
	$state->{extra} = $state->opt('c');
	$state->{dont_run_scripts} = $state->opt('I');
	$ENV{'PKG_DELETE_EXTRA'} = $state->{extra} ? "Yes" : "No";
d139 26
d218 1
a218 1
			$self->say;
@


1.26
log
@more printing changes.

move log operations into their own file, since they're used outside of
pkg_add/pkg_delete by pkg_check.

move all system stuff to State, so that printing can be localized/controlled.
Create primitives _print, _errprint, _fatal for overriding output, without
localization.

Accordingly, move a lot of code out of Error. We should also move Unlink and
Copy eventually.
@
text
@d2 1
a2 1
# $OpenBSD: AddDelete.pm,v 1.25 2010/06/09 08:13:19 espie Exp $
d230 1
a230 1
			$state->errsay("#1 should be run as root", 
d257 1
a257 1
		$state->errsay("Ambiguous: #1 could be #2", 
@


1.25
log
@replace confusing (n to go) message with #done/#total annotations.
e.g.,
Checking packages|No change in apr-util-mt-1.2.10p4 (26/1530)
@
text
@d2 1
a2 1
# $OpenBSD: AddDelete.pm,v 1.24 2010/06/09 07:26:01 espie Exp $
a154 15
package OpenBSD::Log;
use OpenBSD::Error;
our @@ISA = qw(OpenBSD::Error);

sub set_context
{
	&OpenBSD::Error::set_pkgname;
}

sub dump
{
	&OpenBSD::Error::delayed_output;
}


a155 1
use OpenBSD::Error;
d157 1
d163 1
a163 1
	$self->{l} = OpenBSD::Log->new;
d197 1
a197 1
		$self->{l}->print($self->f(@@_), "\n");
d204 12
a215 2
	$self->progress->clear;
	OpenBSD::Error::VSystem($self->verbose >= 2, @@_);
d222 1
a222 8
	OpenBSD::Error::System(@@_);
}

sub unlink
{
	my $self = shift;
	$self->progress->clear;
	OpenBSD::Error::Unlink(@@_);
@


1.24
log
@ui changes: go thru a state object for most printouts
@
text
@d2 1
a2 1
# $OpenBSD: AddDelete.pm,v 1.23 2010/06/05 09:15:55 espie Exp $
d197 1
a197 9
	my $todo = $self->{todo} // 0;
	$offset //= 0;
	$todo += $offset;

	if ($todo > 0) {
		return " ($todo to go)";
	} else {
		return "";
	}
d323 1
a323 1
	$state->say($what." ".$object.$state->ntogo_string);
@


1.23
log
@move use to common part
@
text
@d2 1
a2 1
# $OpenBSD: AddDelete.pm,v 1.22 2010/06/05 07:35:21 landry Exp $
d36 1
a36 1
	my ($self, $opt_string, $hash, @@usage) = @@_;
d38 1
a38 1
	my $state = $self->new_state;
d71 1
a71 1
	my $handler = sub { my $sig = shift; Fatal "Caught SIG$sig"; };
d124 1
a124 1
	my $self = shift;
d126 1
a126 1
	my $state = $self->handle_options;
d220 1
a220 1
		$self->{l}->print(@@_);
d250 2
a251 1
			$state->errsay("$0 should be run as root") if $state->verbose;
d253 1
a253 1
			Fatal "$0 must be run as root";
d262 1
a262 1
		$state->errsay("Can't find $name") unless $is_quirks;
d277 2
a278 1
		$state->errsay("Ambiguous: $name could be ", join(' ', keys %h));
@


1.22
log
@Move ask_list() method to $state object like it's done for confirm(), so
that it can be overriden. Change callers accordingly.
ok espie@@
@
text
@d2 1
a2 1
# $OpenBSD: AddDelete.pm,v 1.21 2010/06/04 13:19:39 espie Exp $
a28 1
use OpenBSD::ProgressMeter;
a29 1
use OpenBSD::Subst;
@


1.21
log
@move code around, so that commands can be used as modules.
pkg becomes the start hub, which does nothing except require the
correct module.
Saner code wrt Add/Delete, and more sharing.
@
text
@d2 1
a2 1
# $OpenBSD: AddDelete.pm,v 1.20 2010/05/10 09:17:55 espie Exp $
d275 1
a275 1
		my $result = OpenBSD::Interactive::ask_list("Ambiguous: choose package for $name", 1, sort keys %h);
d290 8
@


1.20
log
@whitespace fixes
@
text
@d2 1
a2 1
# $OpenBSD$
a26 1
use OpenBSD::Getopt;
d30 3
d34 1
a34 6
our $bad = 0;
our %defines = ();
our $state;

our ($opt_n, $opt_x, $opt_v, $opt_B, $opt_L, $opt_i, $opt_q, $opt_c, $opt_I, $opt_s);
$opt_v = 0;
d38 1
a38 1
	my ($opt_string, $hash, @@usage) = @@_;
d40 2
a41 3
	set_usage(@@usage);
	$state = OpenBSD::State->new;
	$hash->{h} = sub { Usage(); };
d44 1
a44 9
			$defines{$o} = 1;
		}
	};
	$hash->{D} = sub {
		my $_ = shift;
		if (m/^(.*?)=(.*)/) {
			$defines{$1} = $2;
		} else {
			$defines{$_} = 1;
d47 2
a48 5
	try {
		getopts('hciInqvsxB:D:F:L:'.$opt_string, $hash);
	} catchall {
		Usage($_);
	};
d50 2
a51 4
	$opt_L = OpenBSD::Paths->localbase unless defined $opt_L;

	if ($opt_s) {
		$opt_n = 1;
a52 1
	$state->{not} = $opt_n;
d54 9
a62 9
	$main::not = $opt_n;
	$state->{defines} = \%defines;
	$state->{interactive} = $opt_i;
	$state->{v} = $opt_v;
	$state->{localbase} = $opt_L;
	$state->{size_only} = $opt_s;
	$state->{quick} = $opt_q;
	$state->{extra} = $opt_c;
	$state->{dont_run_scripts} = $opt_I;
d67 1
a67 1
	my $code = shift;
d69 1
a69 1
	if ($bad) {
d80 2
a81 2
	if ($state->{defines}->{debug}) {
		&$code;
d83 1
a83 1
		eval { &$code; };
d91 1
a91 1
	my $code = shift;
d93 1
a93 2
		lock_db($opt_n) unless $state->{defines}->{nolock};
		$state->progress->setup($opt_x);
d95 2
a96 2
		process_parameters();
		my $dielater = do_the_main_work($code);
d103 3
a105 3
		finish_display();
		if ($state->verbose >= 2 || $opt_s ||
		    $state->{defines}->{tally}) {
d119 1
a119 1
	if ($bad) {
d124 9
d172 1
a172 1
package OpenBSD::UI;
d175 1
a175 8

sub new
{
	my $class = shift;
	my $o = bless {}, $class;
	$o->init(@@_);
	return $o;
}
a181 1
	$self->{progressmeter} = OpenBSD::ProgressMeter->new;
d185 1
d192 1
a192 1
	return $self->progress->ntogo($self->todo, $offset);
d197 1
a197 1
	my ($self, $todo, $offset) = @@_;
d199 1
a199 1
	$todo //= 0;
a209 5
sub verbose
{
	return shift->{v};
}

d212 2
a213 1
	return shift->{vstat};
a225 30
sub print
{
	my $self = shift;
	$self->progress->print(@@_);
}

sub say
{
	my $self = shift;
	$self->progress->print(@@_, "\n");
}

sub errprint
{
	my $self = shift;
	$self->progress->errprint(@@_);
}

sub errsay
{
	my $self = shift;
	$self->progress->errprint(@@_, "\n");
}

sub progress
{
	my $self = shift;
	return $self->{progressmeter};
}

d250 1
a250 1
	if ($< && !$state->{defines}->{nonroot}) {
d299 6
d323 2
a324 2
	$state->say($what." ".$object.$state->ntogo_string($state->todo));
	if ($state->{defines}->{carp}) {
@


1.19
log
@clean up the ProgressMeter code, create a specific class if a Term
is around.
start using stuff from termcap, specifically, cleareol, and move to hp.
use the full line when we can, cram 100% if we can.
(this should flicker much less on slow terminals).

clean-up the install-and-progress bits to be in progressmeter, this removes
some code.

have pkg_create follow the same pattern as the others, with a state.
This allows us to unify error messages a bit.
@
text
@d46 2
a47 2
	$hash->{F} = sub { 
		for my $o (split /\,/o, shift) { 
d100 1
a100 1
	} else { 
d123 1
a123 1
		if ($state->verbose >= 2 || $opt_s || 
@


1.18
log
@works much better if I actually add the option...
@
text
@d4 13
a16 1
# Copyright (c) 2007-2009 Marc Espie <espie@@openbsd.org>
d30 1
d112 1
a112 1
		$state->setup_progressmeter($opt_x);
d199 1
a199 1
	$self->{progressmeter} = bless {}, "OpenBSD::StubProgress";
a297 10
# we always have a progressmeter we can print to...
sub setup_progressmeter
{
	my ($self, $opt_x) = @@_;
	if (!$opt_x) {
		require OpenBSD::ProgressMeter;
		$self->{progressmeter} = OpenBSD::ProgressMeter->new;
	}
}

a402 70
}

# stub class when no actual progressmeter that still prints out.
package OpenBSD::StubProgress;
sub clear {}

sub show {}

sub message {}

sub next {}

sub set_header {}

sub print
{
	shift;
	print @@_;
}

sub ntogo
{
	return "";
}

sub errprint
{
	shift;
	print STDERR @@_;
}

package OpenBSD::PackingList;
sub compute_size
{
	my $plist = shift;
	my $totsize = 0;
	$plist->visit('compute_size', \$totsize);
	$totsize = 1 if $totsize == 0;
	$plist->{totsize} = $totsize;
}

package OpenBSD::PackingElement;
sub mark_progress
{
}

sub compute_size
{
}

package OpenBSD::PackingElement::FileBase;
sub mark_progress
{
	my ($self, $progress, $donesize, $totsize) = @@_;
	return unless defined $self->{size};
	$$donesize += $self->{size};
	$progress->show($$donesize, $totsize);
}

sub compute_size
{
	my ($self, $totsize) = @@_;

	$$totsize += $self->{size} if defined $self->{size};
}

package OpenBSD::PackingElement::Sample;
sub compute_size
{
	&OpenBSD::PackingElement::FileBase::compute_size;
@


1.17
log
@unify options a bit: use -Dname=value for defines uniformously (e.g., deprecate
-F keyword heavily).
@
text
@d47 1
a47 1
		getopts('hciInqvsxB:f:F:L:'.$opt_string, $hash);
@


1.16
log
@move signal catching up, so we can clean repos and temp files at once.
Fix main program try/catch: signal message should use standard form so
it gets caught.
@
text
@d33 1
a33 1
	$hash->{f} = $hash->{F} = sub { 
d36 8
@


1.15
log
@-F tally
@
text
@d70 1
a70 1
	my $handler = sub { my $sig = shift; die "Caught SIG$sig"; };
d110 1
@


1.14
log
@replace vstat with modern code, almost ready for stacking vfs...
@
text
@d102 2
a103 1
		if ($state->verbose >= 2 || $opt_s) {
@


1.13
log
@add -F carp as an extra debugging device: ^T handler will show a stack
backtrace
@
text
@a49 1
	$state->vstat->{not} = $opt_n;
a143 44
package OpenBSD::MyStat;
use OpenBSD::Vstat;
sub new
{
	my $class = shift;
	bless {}, $class
}

sub add
{
	shift;
	&OpenBSD::Vstat::add;
}

sub remove
{
	shift;
	&OpenBSD::Vstat::remove;
}

sub exists
{
	shift;
	&OpenBSD::Vstat::vexists;
}

sub stat
{
	shift;
	&OpenBSD::Vstat::filestat;
}

sub tally
{
	shift;
	&OpenBSD::Vstat::tally;
}

sub synchronize
{
	my $self = shift;
	OpenBSD::Vstat::synchronize($self->{not});
}

d161 1
d175 1
a175 1
	$self->{vstat} = OpenBSD::MyStat->new;
@


1.12
log
@progressmeter always, unless -x is given
ok espie
@
text
@d2 1
a2 1
# $OpenBSD: AddDelete.pm,v 1.11 2009/12/21 13:24:57 espie Exp $
d400 4
@


1.11
log
@if we're not in a "pretend" mode, synchronization operations on vstat occur
after the files have been committed to the file system, so we can forget about
them...

I don't know where I lost that change, restores pkg_add memory usage to very
small values...
@
text
@d2 1
a2 1
# $OpenBSD$
d323 1
a323 1
	if (!$opt_x && $self->verbose) {
@


1.10
log
@much simpler SIG{INFO} handling: create a status object in state and
update it when needed. Install a SIG{INFO} handler at start that will do
what's needed.
@
text
@d50 1
d185 2
a186 2
	shift;
	&OpenBSD::Vstat::synchronize;
@


1.9
log
@change verbosity handling: be silent by default, turn on the first level if -v.
Add more levels, specifically, lots of info regarding individual files only
visible if -vvvvv.
Make -n display the same stuff as normal (need -n -v to display more stuff).
Introduce -s, "size-only", turns on -n and does skip any extraction.
Sprinkle handlers for SIG_INFO, not really nice yet.

Note that -n is non functional for complex updates, because of caching
issues I have to fix.
@
text
@a45 1
	$state->{recorder} = OpenBSD::SharedItemsRecorder->new;
d220 2
d232 15
d371 58
@


1.8
log
@create a $state->todo method to account for sets to install.
have tracker keep track of sets not done, and ask it directly for how many
there's still to do. Provide an offset into next for cases where we know
we already did a set but haven't accounted for it yet.
-> more accurate number of sets still to do.
@
text
@d23 1
a23 1
our ($opt_n, $opt_x, $opt_v, $opt_B, $opt_L, $opt_i, $opt_q, $opt_c, $opt_I);
d39 1
a39 1
		getopts('hciInqvxB:f:F:L:'.$opt_string, $hash);
d47 3
a53 2
	$state->{very_verbose} = $opt_v >= 2;
	$state->{verbose} = $opt_v;
d55 1
a55 1
	$state->{beverbose} = $opt_n || ($opt_v >= 2);
d57 1
a99 3
		if ($state->{beverbose}) {
			$state->vstat->tally;
		}
d103 3
d221 1
d231 5
d285 1
a285 1
	OpenBSD::Error::VSystem($self->{very_verbose}, @@_);
d306 1
a306 1
	if (!$opt_x && !$self->{beverbose}) {
d317 1
a317 1
			$state->errsay("$0 should be run as root");
d328 1
a328 1
		$state->say("Can't find $name") unless $is_quirks;
d343 1
a343 1
		$state->say("Ambiguous: $name could be ", join(' ', keys %h));
@


1.7
log
@move the ntogo actual code in the progressmeter, so that -x shuts it off.
@
text
@d2 1
a2 1
# $OpenBSD: AddDelete.pm,v 1.6 2009/12/14 09:35:56 espie Exp $
d223 1
a223 1
	my $self = shift;
d225 1
a225 1
	return $self->progress->ntogo($self->{todo});
@


1.6
log
@fuss about install msgs: new method state->ntogo, use it to annotate more
messages with global progress information.

Also, when not finding a suitable update, report it if set is not a simple
update. Helps in figuring out cases like gstreamer...
@
text
@d2 1
a2 1
# $OpenBSD$
d225 1
a225 5
	if (defined $self->{todo} && $self->{todo} > 0) {
		return " ($self->{todo} to go)";
	} else {
		return "";
	}
d365 5
@


1.5
log
@make quirks silent. Track # of updates found, instead of newer size, since
we may end up updating sets with newer == 0
@
text
@d221 11
@


1.4
log
@revamp interactive stuff: simplify (just one always for everything, per
theo suggestion. Also go through the "state" object which simplifies code
a great deal)
@
text
@d2 1
a2 1
# $OpenBSD: AddDelete.pm,v 1.3 2009/11/16 14:42:18 espie Exp $
d311 1
a311 1
	my ($state, $name, $list) = @@_;
d313 1
a313 1
		$state->say("Can't find $name");
@


1.3
log
@create a pseudo vstat object inside state, so that we can modify Vstat
interface very locally...

model hints objects like Locations, to uniformize further treatment.
@
text
@d2 1
a2 1
# $OpenBSD: AddDelete.pm,v 1.2 2009/11/16 12:53:27 espie Exp $
d331 9
@


1.2
log
@pull more common code in a "framework" routine.
@
text
@d2 1
a2 1
# $OpenBSD: AddDelete.pm,v 1.1 2009/11/16 12:20:32 espie Exp $
a25 4
sub setup_state
{
}

d99 1
a99 1
			OpenBSD::Vstat::tally();
d143 44
d217 1
d219 5
@


1.1
log
@start pulling all the code that's the same between pkg_add and pkg_delete
into a common AddDelete package... lots of identical options and handling,
actually...
@
text
@d2 1
a2 1
# $OpenBSD$
a27 3
	lock_db($opt_n) unless $state->{defines}->{nolock};
	$state->setup_progressmeter($opt_x);
	$state->check_root;
d32 4
a35 1
	my ($opt_string, $hash) = @@_;
d86 34
a119 6
	# cleanup various things
	$state->{recorder}->cleanup($state);
	OpenBSD::PackingElement::Lib::ensure_ldconfig($state);
	OpenBSD::PackingElement::Fontdir::finish_fontdirs($state);
	if ($state->{beverbose}) {
		OpenBSD::Vstat::tally();
a120 3
	$state->progress->clear;
	$state->log->dump;
	return $dielater;
d122 1
@

