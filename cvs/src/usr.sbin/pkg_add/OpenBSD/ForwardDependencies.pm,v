head	1.13;
access;
symbols
	OPENBSD_6_0:1.13.0.20
	OPENBSD_6_0_BASE:1.13
	OPENBSD_5_9:1.13.0.14
	OPENBSD_5_9_BASE:1.13
	OPENBSD_5_8:1.13.0.16
	OPENBSD_5_8_BASE:1.13
	OPENBSD_5_7:1.13.0.8
	OPENBSD_5_7_BASE:1.13
	OPENBSD_5_6:1.13.0.12
	OPENBSD_5_6_BASE:1.13
	OPENBSD_5_5:1.13.0.10
	OPENBSD_5_5_BASE:1.13
	OPENBSD_5_4:1.13.0.6
	OPENBSD_5_4_BASE:1.13
	OPENBSD_5_3:1.13.0.4
	OPENBSD_5_3_BASE:1.13
	OPENBSD_5_2:1.13.0.2
	OPENBSD_5_2_BASE:1.13
	OPENBSD_5_1_BASE:1.11
	OPENBSD_5_1:1.11.0.6
	OPENBSD_5_0:1.11.0.4
	OPENBSD_5_0_BASE:1.11
	OPENBSD_4_9:1.11.0.2
	OPENBSD_4_9_BASE:1.11
	OPENBSD_4_8:1.9.0.2
	OPENBSD_4_8_BASE:1.9
	OPENBSD_4_7:1.5.0.2
	OPENBSD_4_7_BASE:1.5;
locks; strict;
comment	@# @;


1.13
date	2012.04.28.15.24.52;	author espie;	state Exp;
branches;
next	1.12;

1.12
date	2012.04.28.11.55.53;	author espie;	state Exp;
branches;
next	1.11;

1.11
date	2010.12.24.09.04.14;	author espie;	state Exp;
branches;
next	1.10;

1.10
date	2010.10.27.14.35.56;	author espie;	state Exp;
branches;
next	1.9;

1.9
date	2010.06.30.10.51.04;	author espie;	state Exp;
branches;
next	1.8;

1.8
date	2010.06.30.10.41.42;	author espie;	state Exp;
branches;
next	1.7;

1.7
date	2010.06.09.07.26.01;	author espie;	state Exp;
branches;
next	1.6;

1.6
date	2010.05.10.09.17.55;	author espie;	state Exp;
branches;
next	1.5;

1.5
date	2009.12.31.12.36.57;	author espie;	state Exp;
branches;
next	1.4;

1.4
date	2009.12.29.18.16.14;	author espie;	state Exp;
branches;
next	1.3;

1.3
date	2009.12.28.21.28.35;	author espie;	state Exp;
branches;
next	1.2;

1.2
date	2009.12.28.19.27.58;	author espie;	state Exp;
branches;
next	1.1;

1.1
date	2009.12.26.17.00.49;	author espie;	state Exp;
branches;
next	;


desc
@@


1.13
log
@explain why the base pseudo-handle is a dirty hack and why it's less
confusing than the clean approach
@
text
@# ex:ts=8 sw=4:
# $OpenBSD: ForwardDependencies.pm,v 1.12 2012/04/28 11:55:53 espie Exp $
#
# Copyright (c) 2009 Marc Espie <espie@@openbsd.org>
#
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF

# handling of forward dependency adjustments

use strict;
use warnings;

package OpenBSD::ForwardDependencies;

require OpenBSD::RequiredBy;

sub find
{
	my ($class, $set) = @@_;
	my $forward = {};
	for my $old ($set->older) {
		for my $f (OpenBSD::RequiredBy->new($old->pkgname)->list) {
			next if defined $set->{older}->{$f};
			next if defined $set->{kept}->{$f};
			$forward->{$f} = 1;
		}
	}
	bless { forward => $forward, set => $set}, $class;
}

sub adjust
{
	my ($self, $state) = @@_;
	my $set = $self->{set};

	for my $f (keys %{$self->{forward}}) {
		my $deps_f = OpenBSD::Requiring->new($f);
		for my $check ($deps_f->list) {
			my $h = $set->{older}->{$check};
			next unless defined $h;
			if (!defined $h->{update_found}) {
				$state->errsay("XXX #1", $check);
				$deps_f->delete($check);
			} else {
				# XXX proper OO wouldn't have ->is_real
				# but it would use double dispatch to record
				# every dependency.
				# ETOOMUCHSCAFFOLDING, quick&dirty hack
				# is much shorter and fairly localized.
				my $r = $h->{update_found};
				my $p = $r->pkgname;
				$state->say("Adjusting #1 to #2 in #3",
				    $check, $p, $f)
					if $state->verbose >= 3;
				if ($check ne $p) {
					if ($r->is_real) {
						$deps_f->delete($check)->add($p);
					} else {
						$deps_f->delete($check);
					}
				}
				if ($r->is_real) {
					OpenBSD::RequiredBy->new($p)->add($f);
				}
			}
		}
	}
}

sub check
{
	my ($self, $state) = @@_;
	my $forward = $self->{forward};
	my $set = $self->{set};

	my @@r = keys %$forward;

	my $result = {};

	return $result if @@r == 0;
	$state->say("Verifying dependencies still match for #1",
	    join(', ', @@r)) if $state->verbose >= 2;

	my @@new = ($set->newer_names, $set->kept_names);
	my @@old = $set->older_names;

	for my $f (@@r) {
		my $p2 = OpenBSD::PackingList->from_installation(
		    $f, \&OpenBSD::PackingList::DependOnly);
		if (!defined $p2) {
			$state->errsay("Error: #1 missing from installation", $f);
		} else {
			$p2->check_forward_dependency($f, \@@old, \@@new, $result);
		}
	}
	if (%$result) {
		$state->say("#1 forward dependencies:", $set->print);
		while (my ($pkg, $l) = each %$result) {
			my $deps = join(',', map {$_->{pattern}} @@$l);
			if (@@$l == 1) {
				$state->say("| Dependency of #1 on #2 doesn't match",
				    $pkg, $deps);
			} else {
				$state->say("| Dependencies of #1 on #2 don't match",
				    $pkg, $deps);
			}
		}
	}
	return $result;
}

package OpenBSD::PackingElement;
sub check_forward_dependency
{
}

package OpenBSD::PackingElement::Dependency;
sub check_forward_dependency
{
	my ($self, $f, $old, $new, $r) = @@_;

	# nothing to validate if old dependency doesn't concern us.
	return unless $self->spec->filter(@@$old);
	# nothing to do if new dependency just matches
	return if $self->spec->filter(@@$new);

	push(@@{$r->{$f}}, $self);
}

1;
@


1.12
log
@work-around the fact that BaseSystem updates have specific dependency
handling
@
text
@d2 1
a2 1
# $OpenBSD$
d54 5
@


1.11
log
@handle failures from ports tree with more care.
this does avoid infinite loops in case of wrong plists.
necessary since print-plist-with-depends CAN fail...
@
text
@d54 2
a55 1
				my $r = $h->{update_found}->pkgname;
d57 1
a57 1
				    $check, $r, $f)
d59 9
a67 2
				if ($check ne $r) {
					$deps_f->delete($check)->add($r);
a68 1
				OpenBSD::RequiredBy->new($r)->add($f);
@


1.10
log
@initial scaffolding for @@rcscript: for now, acts like normal files,
but allow absolute pathnames (treat that as an implicit @@cwd).
@
text
@@


1.9
log
@allow say and errsay to work without parameters, as it's ways common.
create verbose_system up in state, because it makes sense without verbose.
@
text
@@


1.8
log
@whitespace cleanup
@
text
@@


1.7
log
@ui changes: go thru a state object for most printouts
@
text
@d2 1
a2 1
# $OpenBSD: ForwardDependencies.pm,v 1.6 2010/05/10 09:17:55 espie Exp $
d55 1
a55 1
				$state->say("Adjusting #1 to #2 in #3", 
@


1.6
log
@whitespace fixes
@
text
@d2 1
a2 1
# $OpenBSD$
d51 1
a51 1
				$state->errsay("XXX $check");
d55 3
a57 2
				$state->say("Adjusting $check to $r in $f")
				    if $state->verbose >= 3;
d78 1
a78 1
	$state->say("Verifying dependencies still match for ",
d88 1
a88 1
			$state->errsay("Error: $f missing from installation");
d94 1
a94 1
		$state->say($set->print, " forward dependencies:");
d98 2
a99 1
				$state->say("| Dependency of $pkg on $deps doesn't match");
d101 2
a102 1
				$state->say("| Dependencies of $pkg on $deps don't match");
@


1.5
log
@XXX until I fix it for real
@
text
@d77 1
a77 1
	$state->say("Verifying dependencies still match for ", 
@


1.4
log
@a few more tweaks:
- allow for merged updates if we want them
- deplist becomes a hash, maybe useful for big sets
- simplify loop checking. We don't actually care whether we find any.
- be more aggressive in keeping cached stuff, create solver or conflict_cache
if need be.
@
text
@d48 7
a54 2
			if (defined $set->{older}->{$check}) {
				my $r = $set->{older}->{$check}->{update_found}->pkgname;
@


1.3
log
@new method for adjusting forward dependencies, much simpler.
@
text
@d2 1
a2 1
# $OpenBSD: ForwardDependencies.pm,v 1.2 2009/12/28 19:27:58 espie Exp $
d69 3
a71 1
	return if @@r == 0;
a76 1
	my $result = {};
d87 1
a87 1
	if (keys %$result > 0) {
@


1.2
log
@prepare to handle forward dependencies in a simpler way
@
text
@d2 1
a2 1
# $OpenBSD: ForwardDependencies.pm,v 1.1 2009/12/26 17:00:49 espie Exp $
d50 6
a55 1
				$state->say("Should adjust $check to $r in $f");
@


1.1
log
@Better, more global way of dealing with forward dependencies, and to
ask just once per-set for exec/unexec.

Todo: forward-deps could be merged, but this might lead to dependency
loops, we have to detect them and act first

Todo: rewrite the other part of forward dependency handling (dep adjustment)
@
text
@d2 1
a2 1
# $OpenBSD$
d37 17
a53 1
	bless $forward, $class;
d58 3
a60 1
	my ($forward, $set, $state) = @@_;
@

