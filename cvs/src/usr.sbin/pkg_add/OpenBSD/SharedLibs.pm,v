head	1.59;
access;
symbols
	OPENBSD_6_2:1.59.0.2
	OPENBSD_6_2_BASE:1.59
	OPENBSD_6_1:1.58.0.4
	OPENBSD_6_1_BASE:1.58
	OPENBSD_6_0:1.57.0.26
	OPENBSD_6_0_BASE:1.57
	OPENBSD_5_9:1.57.0.20
	OPENBSD_5_9_BASE:1.57
	OPENBSD_5_8:1.57.0.22
	OPENBSD_5_8_BASE:1.57
	OPENBSD_5_7:1.57.0.14
	OPENBSD_5_7_BASE:1.57
	OPENBSD_5_6:1.57.0.18
	OPENBSD_5_6_BASE:1.57
	OPENBSD_5_5:1.57.0.16
	OPENBSD_5_5_BASE:1.57
	OPENBSD_5_4:1.57.0.12
	OPENBSD_5_4_BASE:1.57
	OPENBSD_5_3:1.57.0.10
	OPENBSD_5_3_BASE:1.57
	OPENBSD_5_2:1.57.0.8
	OPENBSD_5_2_BASE:1.57
	OPENBSD_5_1_BASE:1.57
	OPENBSD_5_1:1.57.0.6
	OPENBSD_5_0:1.57.0.4
	OPENBSD_5_0_BASE:1.57
	OPENBSD_4_9:1.57.0.2
	OPENBSD_4_9_BASE:1.57
	OPENBSD_4_8:1.51.0.2
	OPENBSD_4_8_BASE:1.51
	OPENBSD_4_7:1.47.0.2
	OPENBSD_4_7_BASE:1.47
	OPENBSD_4_6:1.32.0.6
	OPENBSD_4_6_BASE:1.32
	OPENBSD_4_5:1.32.0.2
	OPENBSD_4_5_BASE:1.32
	OPENBSD_4_4:1.31.0.4
	OPENBSD_4_4_BASE:1.31
	OPENBSD_4_3:1.31.0.2
	OPENBSD_4_3_BASE:1.31
	OPENBSD_4_2:1.29.0.2
	OPENBSD_4_2_BASE:1.29
	OPENBSD_4_1:1.8.0.8
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.8.0.6
	OPENBSD_4_0_BASE:1.8
	OPENBSD_3_9:1.8.0.4
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.8.0.2
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.6.0.2
	OPENBSD_3_7_BASE:1.6;
locks; strict;
comment	@# @;


1.59
date	2017.09.16.12.04.13;	author espie;	state Exp;
branches;
next	1.58;
commitid	iXoLx916G6f6tokh;

1.58
date	2017.02.10.02.10.22;	author espie;	state Exp;
branches;
next	1.57;
commitid	gSIiwP71qSX8prsz;

1.57
date	2010.12.24.10.31.59;	author espie;	state Exp;
branches;
next	1.56;

1.56
date	2010.12.24.09.09.54;	author espie;	state Exp;
branches;
next	1.55;

1.55
date	2010.12.24.09.04.14;	author espie;	state Exp;
branches;
next	1.54;

1.54
date	2010.12.20.09.03.51;	author espie;	state Exp;
branches;
next	1.53;

1.53
date	2010.12.20.08.58.03;	author espie;	state Exp;
branches;
next	1.52;

1.52
date	2010.10.27.14.35.56;	author espie;	state Exp;
branches;
next	1.51;

1.51
date	2010.06.30.10.51.04;	author espie;	state Exp;
branches;
next	1.50;

1.50
date	2010.06.30.10.41.42;	author espie;	state Exp;
branches;
next	1.49;

1.49
date	2010.06.09.07.26.01;	author espie;	state Exp;
branches;
next	1.48;

1.48
date	2010.05.10.09.17.55;	author espie;	state Exp;
branches;
next	1.47;

1.47
date	2010.01.24.15.31.38;	author espie;	state Exp;
branches;
next	1.46;

1.46
date	2010.01.24.15.13.15;	author espie;	state Exp;
branches;
next	1.45;

1.45
date	2010.01.24.15.00.26;	author espie;	state Exp;
branches;
next	1.44;

1.44
date	2009.12.31.14.14.08;	author espie;	state Exp;
branches;
next	1.43;

1.43
date	2009.12.31.13.25.03;	author espie;	state Exp;
branches;
next	1.42;

1.42
date	2009.12.31.13.12.27;	author espie;	state Exp;
branches;
next	1.41;

1.41
date	2009.12.17.11.57.02;	author espie;	state Exp;
branches;
next	1.40;

1.40
date	2009.11.29.10.32.58;	author espie;	state Exp;
branches;
next	1.39;

1.39
date	2009.11.29.07.06.17;	author espie;	state Exp;
branches;
next	1.38;

1.38
date	2009.11.28.10.25.34;	author espie;	state Exp;
branches;
next	1.37;

1.37
date	2009.11.28.08.21.05;	author espie;	state Exp;
branches;
next	1.36;

1.36
date	2009.11.17.10.48.14;	author espie;	state Exp;
branches;
next	1.35;

1.35
date	2009.11.17.10.38.27;	author espie;	state Exp;
branches;
next	1.34;

1.34
date	2009.11.11.13.00.40;	author espie;	state Exp;
branches;
next	1.33;

1.33
date	2009.11.10.11.36.56;	author espie;	state Exp;
branches;
next	1.32;

1.32
date	2008.10.20.10.25.16;	author espie;	state Exp;
branches;
next	1.31;

1.31
date	2007.10.06.12.13.41;	author steven;	state Exp;
branches;
next	1.30;

1.30
date	2007.09.28.14.42.12;	author espie;	state Exp;
branches;
next	1.29;

1.29
date	2007.06.20.13.44.40;	author espie;	state Exp;
branches;
next	1.28;

1.28
date	2007.06.16.09.29.37;	author espie;	state Exp;
branches;
next	1.27;

1.27
date	2007.06.06.10.56.21;	author espie;	state Exp;
branches;
next	1.26;

1.26
date	2007.06.04.23.28.01;	author espie;	state Exp;
branches;
next	1.25;

1.25
date	2007.06.04.22.32.59;	author espie;	state Exp;
branches;
next	1.24;

1.24
date	2007.06.04.21.51.35;	author espie;	state Exp;
branches;
next	1.23;

1.23
date	2007.06.04.20.34.07;	author espie;	state Exp;
branches;
next	1.22;

1.22
date	2007.06.04.18.52.02;	author espie;	state Exp;
branches;
next	1.21;

1.21
date	2007.06.04.17.00.45;	author espie;	state Exp;
branches;
next	1.20;

1.20
date	2007.06.04.16.58.40;	author espie;	state Exp;
branches;
next	1.19;

1.19
date	2007.06.04.16.33.23;	author espie;	state Exp;
branches;
next	1.18;

1.18
date	2007.06.04.14.57.33;	author espie;	state Exp;
branches;
next	1.17;

1.17
date	2007.06.04.14.40.39;	author espie;	state Exp;
branches;
next	1.16;

1.16
date	2007.05.23.10.33.45;	author espie;	state Exp;
branches;
next	1.15;

1.15
date	2007.05.23.09.27.27;	author espie;	state Exp;
branches;
next	1.14;

1.14
date	2007.05.14.23.16.41;	author espie;	state Exp;
branches;
next	1.13;

1.13
date	2007.05.07.08.18.02;	author espie;	state Exp;
branches;
next	1.12;

1.12
date	2007.05.07.08.14.51;	author espie;	state Exp;
branches;
next	1.11;

1.11
date	2007.05.02.15.05.30;	author espie;	state Exp;
branches;
next	1.10;

1.10
date	2007.04.29.11.09.29;	author espie;	state Exp;
branches;
next	1.9;

1.9
date	2007.04.15.10.17.29;	author espie;	state Exp;
branches;
next	1.8;

1.8
date	2005.08.16.20.05.12;	author espie;	state Exp;
branches;
next	1.7;

1.7
date	2005.08.12.16.57.15;	author espie;	state Exp;
branches;
next	1.6;

1.6
date	2004.12.28.14.50.38;	author espie;	state Exp;
branches;
next	1.5;

1.5
date	2004.12.21.11.43.46;	author espie;	state Exp;
branches;
next	1.4;

1.4
date	2004.11.23.11.12.56;	author espie;	state Exp;
branches;
next	1.3;

1.3
date	2004.11.22.01.56.13;	author espie;	state Exp;
branches;
next	1.2;

1.2
date	2004.11.21.15.44.56;	author espie;	state Exp;
branches;
next	1.1;

1.1
date	2004.11.21.15.36.17;	author espie;	state Exp;
branches;
next	;


desc
@@


1.59
log
@we already have a comparison function for libobjects, so move it up to
the best class, and sort bad libraries in dependency solving accordingly
@
text
@# ex:ts=8 sw=4:
# $OpenBSD: SharedLibs.pm,v 1.58 2017/02/10 02:10:22 espie Exp $
#
# Copyright (c) 2003-2010 Marc Espie <espie@@openbsd.org>
#
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

use strict;
use warnings;

use OpenBSD::Paths;
use OpenBSD::LibSpec;

package OpenBSD::PackingElement;

sub mark_available_lib
{
}

package OpenBSD::PackingElement::Lib;

sub mark_available_lib
{
	my ($self, $pkgname, $state) = @@_;
	OpenBSD::SharedLibs::register_libname($self->fullname,
	    $pkgname, $state);
}

package OpenBSD::SharedLibs;
use File::Basename;
use OpenBSD::Error;

our $repo = OpenBSD::LibRepo->new;

sub register_library
{
	my ($lib, $pkgname) = @@_;
	$repo->register($lib, $pkgname);
}

sub register_libname
{
	my ($name, $pkgname, $state) = @@_;
	my $lib = OpenBSD::Library->from_string($name);
	if ($lib->is_valid) {
		register_library($lib, $pkgname);
	} else {
		$state->errsay("Bogus library in #1: #2", $pkgname, $name)
		    unless $pkgname eq 'system';
	}

}

sub find_best
{
	my ($class, $stem) = @@_;
	return $repo->find_best($stem);
}

my $done_plist = {};

sub system_dirs
{
	return OpenBSD::Paths->library_dirs;
}

sub add_libs_from_system
{
	my ($destdir, $state) = @@_;
	return if $done_plist->{'system'};
	$done_plist->{'system'} = 1;
	for my $dirname (system_dirs()) {
		opendir(my $dir, $destdir.$dirname."/lib") or next;
		while (my $d = readdir($dir)) {
			next unless $d =~ m/\.so/;
			register_libname("$dirname/lib/$d", 'system', $state);
		}
		closedir($dir);
	}
}

sub add_libs_from_installed_package
{
	my ($pkgname, $state) = @@_;
	return if $done_plist->{$pkgname};
	$done_plist->{$pkgname} = 1;
	my $plist = OpenBSD::PackingList->from_installation($pkgname,
	    \&OpenBSD::PackingList::LibraryOnly);
	return if !defined $plist;

	$plist->mark_available_lib($pkgname, $state);
}

sub add_libs_from_plist
{
	my ($plist, $state) = @@_;
	my $pkgname = $plist->pkgname;
	return if $done_plist->{$pkgname};
	$done_plist->{$pkgname} = 1;
	$plist->mark_available_lib($pkgname, $state);
}

sub lookup_libspec
{
	my ($base, $spec) = @@_;
	return $spec->lookup($repo, $base);
}

my $printed = {};

sub report_problem
{
	my ($state, $spec) = @@_;
	my $name = $spec->to_string;
	my $base = $state->{localbase};
	my $approx = $spec->lookup_stem($repo);

	my $r = "";
	if (!$spec->is_valid) {
		$r = "| bad library specification\n";
	} elsif (!defined $approx) {
 		$r = "| not found anywhere\n";
	} else {
		for my $bad (sort {$a->compare($b)} @@$approx) {
			my $ouch = $spec->no_match($bad, $base);
			$ouch //= "not reachable";
			$r .= "| ".$bad->to_string." (".$bad->origin."): ".
			    $ouch."\n";
		}
	}
	if (!defined $printed->{$name} || $printed->{$name} ne $r) {
		$printed->{$name} = $r;
		$state->errsay("|library #1 not found", $name);
		$state->print("#1", $r);
	}
}

1;
@


1.58
log
@add glue to be able to ask "give me the highest number shared library with
that stem".  needed later for new fancy stuff in check-lib-depends
okay sthen@@
@
text
@d2 1
a2 1
# $OpenBSD: SharedLibs.pm,v 1.57 2010/12/24 10:31:59 espie Exp $
d134 1
a134 1
		for my $bad (@@$approx) {
@


1.57
log
@pass state around.
@
text
@d2 1
a2 1
# $OpenBSD: SharedLibs.pm,v 1.56 2010/12/24 09:09:54 espie Exp $
d62 6
@


1.56
log
@move the handling of ldconfig to AddDelete::State
actually simplifies code a great deal. It's not as if trying to avoid
loading ten lines of code is a good idea.
@
text
@d2 1
a2 1
# $OpenBSD: SharedLibs.pm,v 1.55 2010/12/24 09:04:14 espie Exp $
d80 1
a80 1
			register_libname("$dirname/lib/$d", 'system');
@


1.55
log
@handle failures from ports tree with more care.
this does avoid infinite loops in case of wrong plists.
necessary since print-plist-with-depends CAN fail...
@
text
@d2 1
a2 1
# $OpenBSD$
a41 47

my $path;
my @@ldconfig = (OpenBSD::Paths->ldconfig);


sub init_path($)
{
	my $destdir = shift;
	$path={};
	if ($destdir ne '') {
		unshift @@ldconfig, OpenBSD::Paths->chroot, '--', $destdir;
	}
	open my $fh, "-|", @@ldconfig, "-r";
	if (defined $fh) {
		my $_;
		while (<$fh>) {
			if (m/^\s*search directories:\s*(.*?)\s*$/o) {
				for my $d (split(/\:/o, $1)) {
					$path->{$d} = 1;
				}
				last;
			}
		}
		close($fh);
	} else {
		print STDERR "Can't find ldconfig\n";
	}
}

sub mark_ldconfig_directory
{
	my ($name, $destdir) = @@_;
	if (!defined $path) {
		init_path($destdir);
	}
	my $d = dirname($name);
	if ($path->{$d}) {
		$OpenBSD::PackingElement::Lib::todo = 1;
	}
}

sub ensure_ldconfig
{
	my $state = shift;
	$state->vsystem(@@ldconfig, "-R") unless $state->{not};
	$OpenBSD::PackingElement::Lib::todo = 0;
}
@


1.54
log
@extra indirection: allow registration of library objects (refactor for later)
@
text
@d2 1
a2 1
# $OpenBSD: SharedLibs.pm,v 1.53 2010/12/20 08:58:03 espie Exp $
d35 1
a35 1
	OpenBSD::SharedLibs::register_libname($self->fullname, 
@


1.53
log
@pass state to SharedLibs for direct printing
(also cosmetic ws)
@
text
@d2 1
a2 1
# $OpenBSD: SharedLibs.pm,v 1.52 2010/10/27 14:35:56 espie Exp $
d35 2
a36 1
	OpenBSD::SharedLibs::register_lib($self->fullname, $pkgname, $state);
d92 7
a98 1
sub register_lib
d103 1
a103 1
		$repo->register($lib, $pkgname);
d127 1
a127 1
			register_lib("$dirname/lib/$d", 'system');
@


1.52
log
@initial scaffolding for @@rcscript: for now, acts like normal files,
but allow absolute pathnames (treat that as an implicit @@cwd).
@
text
@d2 1
a2 1
# $OpenBSD$
d34 2
a35 2
	my ($self, $pkgname) = @@_;
	OpenBSD::SharedLibs::register_lib($self->fullname, $pkgname);
d93 1
a93 1
	my ($name, $pkgname) = @@_;
d98 1
a98 1
		print STDERR "Bogus library in $pkgname: $name\n"
d113 1
a113 1
	my ($destdir) = @@_;
d128 1
a128 1
	my $pkgname = shift;
d135 1
a135 1
	$plist->mark_available_lib($pkgname);
d140 1
a140 1
	my $plist = shift;
d144 1
a144 1
	$plist->mark_available_lib($pkgname);
@


1.51
log
@allow say and errsay to work without parameters, as it's ways common.
create verbose_system up in state, because it makes sense without verbose.
@
text
@@


1.50
log
@whitespace cleanup
@
text
@@


1.49
log
@ui changes: go thru a state object for most printouts
@
text
@d2 1
a2 1
# $OpenBSD: SharedLibs.pm,v 1.48 2010/05/10 09:17:55 espie Exp $
@


1.48
log
@whitespace fixes
@
text
@d2 1
a2 1
# $OpenBSD$
d177 2
a178 2
		$state->errsay("|library $name not found");
		$state->print($r);
@


1.47
log
@extra indirection: no match gives a reason why, so we can rebuild
report_problems to actually say what's wrong...
@
text
@d131 1
a131 1
	my $plist = OpenBSD::PackingList->from_installation($pkgname, 
@


1.46
log
@use libspecs, report problem will be terser for now.
@
text
@d168 6
a173 1
		$r .= join(',', sort map {$_->to_string} @@$approx)."\n";
@


1.45
log
@use libspecs through Dependencies.
@
text
@d22 2
d89 1
a89 1
our $registered_libs = {};
d94 3
a96 5
	my ($stem, $major, $minor, $dir) = 
	    OpenBSD::PackingElement::Lib->parse($name);
	if (defined $stem) {
		push(@@{$registered_libs->{$stem}->{$dir}->{$major}},
		    [$minor, $pkgname]);
a146 20
sub normalize_dir_and_spec
{
	my ($base, $libspec) = @@_;
	if ($libspec =~ m/^(.*)\/([^\/]+)$/o) {
		return ("$base/$1", $2);
	} else {
		return ("$base/lib", $libspec);
	}
}

sub parse_spec
{
	my $spec = shift;
	if ($spec =~ m/^(.*)\.(\d+)\.(\d+)$/o) {
		return ($1, $2, $3);
	} else {
		return undef;
	}
}

d149 2
a150 35
	my ($dir, $spec) = normalize_dir_and_spec($_[0], $_[1]->to_string);
	my @@r = ();
	my ($libname, $major, $minor) = parse_spec($spec);
	if (defined $libname) {
		my $exists = $registered_libs->{$libname}->{$dir}->{$major};
		if (defined $exists) {
			for my $e (@@$exists) {
				if ($e->[0] >= $minor) {
					push(@@r, $e->[1]);
				}
			}
		}
	}
	return @@r;
}

sub entry_string
{
	my ($stem, $M, $m) = @@_;
	return "lib$stem.so.$M.$m";
}

sub why_is_this_bad
{
	my ($base, $name, $d1, $d2, $M1, $M2, $m1, $m2, $pkgname) = @@_;
	if ($d1 ne $d2 && !($pkgname eq 'system' && $d1 eq "$base/lib")) {
		return "bad directory";
	}
	if ($M1 != $M2) {
		return "bad major";
	}
	if ($m1 > $m2) {
		return "minor not large enough";
	}
	return "$pkgname not reachable";
d157 2
a158 1
	my ($state, $p) = @@_;
d160 1
a160 2
	my ($dir, $name) = normalize_dir_and_spec($base, $p->to_string);
	my ($stem, $major, $minor) = parse_spec($name);
d163 1
a163 1
	if (!defined $stem) {
d165 2
a166 2
	} elsif (!defined $registered_libs->{$stem}) {
		$r = "| not found anywhere\n";
d168 1
a168 17
		while (my ($d, $v) = each %{$registered_libs->{$stem}}) {
			my @@l = ();
			while (my ($M, $w) = each %$v) {
				for my $e (@@$w) {
					push(@@l, 
					    entry_string($stem, $M, $e->[0]).
					    " (".
					    why_is_this_bad($base, $name, $dir, 
						$d, $major, $M, $minor, 
						$e->[0], $e->[1]).
					    ")");
				}
			}
			if (@@l > 0) {
				$r .= "| in $d: ". join(", ", sort @@l). "\n";
			}
		}
@


1.44
log
@oops, actually report issues
@
text
@d4 1
a4 1
# Copyright (c) 2003-2005 Marc Espie <espie@@openbsd.org>
d169 1
a169 1
	my ($dir, $spec) = normalize_dir_and_spec(@@_);
d212 1
a212 1
	my ($dir, $name) = normalize_dir_and_spec($base, $p);
@


1.43
log
@always create a problem entry for libraries we don't find
@
text
@d218 1
a218 1
	} elsif (!defined $registered_libs->{stem}) {
@


1.42
log
@complain if we see weird @@libs (so, not in system).
optimization: for system libs, only parse stuff with .so in the name
@
text
@a214 3
	return unless defined $stem;
	return unless defined $registered_libs->{$stem};

d216 20
a235 8
	while (my ($d, $v) = each %{$registered_libs->{$stem}}) {
		my @@l = ();
		while (my ($M, $w) = each %$v) {
			for my $e (@@$w) {
				push(@@l, entry_string($stem, $M, $e->[0]).
				    " (".why_is_this_bad($base, $name, $dir, 
				    $d, $major, $M, $minor, $e->[0], $e->[1]).
				    ")");
a236 3
		}
		if (@@l > 0) {
			$r .= "| in $d: ". join(", ", sort @@l). "\n";
@


1.41
log
@be slightly more paranoid about shell stuff we run.
@
text
@d2 1
a2 1
# $OpenBSD: SharedLibs.pm,v 1.40 2009/11/29 10:32:58 espie Exp $
d97 3
d101 1
d119 1
@


1.40
log
@show missing libraries as "|detail" for the can't install message.
@
text
@d2 1
a2 1
# $OpenBSD$
d49 1
a49 1
		unshift @@ldconfig, OpenBSD::Paths->chroot, $destdir;
@


1.39
log
@have SharedLibs use state to print error messages.
@
text
@d225 1
a225 1
			$r .= " in $d: ". join(", ", sort @@l). "\n";
d230 1
a230 1
		$state->errsay("library $name not found");
@


1.38
log
@rework display of missing libs some more: first show the libraries, then
the dependency tree.
@
text
@d205 3
a207 2
	my $base = $_[0];
	my ($dir, $name) = normalize_dir_and_spec(@@_);
d230 2
a231 2
		print "library $name not found\n";
		print $r;
@


1.37
log
@remove redundant message
@
text
@d229 1
@


1.36
log
@trim more, we already display a quick message for the missing lib elsewhere.
@
text
@a228 1
		print "library $name not found\n";
@


1.35
log
@shorter message when we don't find library, and stash it away to avoid
repeating ourselves uselessly.
@
text
@a211 1
	print "library $name not found\n";
d229 1
@


1.34
log
@vsystem, system, unlink can mostly go through state, and do the ->clear part
as well.
@
text
@d182 2
a183 2
	my ($d, $M, $m) = @@_;
	return "partial match in $d: major=$M, minor=$m";
d201 2
d212 2
d215 1
d218 4
a221 7
				print "$name: ", 
				    entry_string($d, $M, $e->[0]),
				    " (", 
				    why_is_this_bad($base, $name, $dir, 
				    	$d, $major, $M, $minor, 
					$e->[0], $e->[1]),
				    ")\n";
d224 7
@


1.33
log
@bad espie: use strict/warnings consistently, and fix two nits and two
actual errors !
@
text
@d83 1
a83 2
	VSystem($state->{very_verbose}, 
	    @@ldconfig, "-R") unless $state->{not};
@


1.32
log
@Say goodbye to local $_
lexical scoping is so much neater (courtesy of perl 5.10)
@
text
@d20 1
@


1.31
log
@finish loop as soon as the ldconfig search directories have been found.

ok espie@@
@
text
@d2 1
a2 1
# $OpenBSD: SharedLibs.pm,v 1.30 2007/09/28 14:42:12 espie Exp $
d52 1
a52 1
		local $_;
@


1.30
log
@nit
from qgiovanni@@gmail.com
@
text
@d2 1
a2 1
# $OpenBSD$
d58 1
@


1.29
log
@sprinkle code to deal gracefully with absent packing-lists.
makes it easier for people to recover after a disk crash that
leaves /var/db/pkg half-empty.
@
text
@d2 1
a2 1
# $OpenBSD: SharedLibs.pm,v 1.28 2007/06/16 09:29:37 espie Exp $
d127 1
a127 1
	next if !defined $plist;
@


1.28
log
@use OpenBSD::Paths contents
@
text
@d2 1
a2 1
# $OpenBSD: SharedLibs.pm,v 1.27 2007/06/06 10:56:21 espie Exp $
d127 1
a127 4
	if (!defined $plist) {
		Warn "Can't read plist for $pkgname\n";
		return;
	}
@


1.27
log
@augment reporting of bad problems so that it works with system libs.
reverse bogus minor check as well
@
text
@d2 1
a2 1
# $OpenBSD: SharedLibs.pm,v 1.26 2007/06/04 23:28:01 espie Exp $
d20 1
d40 1
a40 1
my @@ldconfig = ('/sbin/ldconfig');
d48 1
a48 1
		unshift @@ldconfig, 'chroot', $destdir;
d103 1
a103 1
	return ("/usr", "/usr/X11R6");
@


1.26
log
@zap extra param
@
text
@d2 1
a2 1
# $OpenBSD: SharedLibs.pm,v 1.25 2007/06/04 22:32:59 espie Exp $
d189 2
a190 2
	my ($name, $d1, $d2, $M1, $M2, $m1, $m2, $pkgname) = @@_;
	if ($d1 ne $d2) {
d196 2
a197 2
	if ($m1 < $m2) {
		return "too small minor";
d204 1
d217 3
a219 2
				    why_is_this_bad($name, $dir, $d, $major, 
				    	$M, $minor, $e->[0], $e->[1]),
@


1.25
log
@minor tweak, use one single print. Build character strings instead.
@
text
@d2 1
a2 1
# $OpenBSD: SharedLibs.pm,v 1.24 2007/06/04 21:51:35 espie Exp $
d183 1
a183 1
	my ($name, $d, $M, $m) = @@_;
@


1.24
log
@slight refactor to remove duplicate code.
@
text
@d2 1
a2 1
# $OpenBSD: SharedLibs.pm,v 1.23 2007/06/04 20:34:07 espie Exp $
d181 1
a181 1
sub write_entry
d184 1
a184 1
	print "$name: partial match in $d: major=$M, minor=$m ";
d191 1
a191 2
		print "(bad directory)\n";
		return;
d194 1
a194 2
		print "(bad major)\n";
		return;
d197 1
a197 2
		print "(too small minor)\n";
		return;
d199 1
a199 1
	print "($pkgname not reachable)\n";
d213 6
a218 2
				write_entry($name, $d, $M, $e->[0]);
				why_is_this_bad($name, $dir, $d, $major, $M, $minor, $e->[0], $e->[1]);
@


1.23
log
@shorten message a bit, give it a chance to fit on one line.
@
text
@d2 1
a2 1
# $OpenBSD: SharedLibs.pm,v 1.22 2007/06/04 18:52:02 espie Exp $
d143 1
a143 1
sub _lookup_libspec
d145 7
a151 2
	my ($dir, $spec) = @@_;
	my @@r = ();
d153 3
d157 12
a168 1
		my ($libname, $major, $minor) = ($1, $2, $3);
a180 11
sub lookup_libspec
{
	my ($base, $libspec) = @@_;
		
	if ($libspec =~ m/^(.*)\/([^\/]+)$/o) {
		return _lookup_libspec("$base/$1", $2);
	} else {
		return _lookup_libspec("$base/lib", $libspec);
	}
}

d205 1
a205 1
sub _report_problem
d207 11
a217 10
	my ($dir, $name) = @@_;
	if ($name =~ m/^(.*)\.(\d+)\.(\d+)$/o) {
		my ($stem, $major, $minor) = ($1, $2, $3, $4);
		return unless defined $registered_libs->{$stem};
		while (my ($d, $v) = each %{$registered_libs->{$stem}}) {
			while (my ($M, $w) = each %$v) {
				for my $e (@@$w) {
					write_entry($name, $d, $M, $e->[0]);
					why_is_this_bad($name, $dir, $d, $major, $M, $minor, $e->[0], $e->[1]);
				}
a222 10
sub report_problem
{
	my ($base, $libspec) = @@_;
		
	if ($libspec =~ m/^(.*)\/([^\/]+)$/o) {
		return _report_problem("$base/$1", $2);
	} else {
		return _report_problem("$base/lib", $libspec);
	}
}
@


1.22
log
@more efficient regexps: anchor stuff at both ends, be more specific in
what matches. Get rid of $`, $', $&, which encur a performance penalty.
(not yet done on PackageName and PkgSpec).
@
text
@d2 1
a2 1
# $OpenBSD: SharedLibs.pm,v 1.21 2007/06/04 17:00:45 espie Exp $
d176 1
a176 1
	print "$name: found partial match in $d: major=$M, minor=$m ";
@


1.21
log
@zap extra parameter that nothing uses.
@
text
@d2 1
a2 1
# $OpenBSD: SharedLibs.pm,v 1.20 2007/06/04 16:58:40 espie Exp $
d166 2
a167 2
	if ($libspec =~ m|(.*)/|o) {
		return _lookup_libspec("$base/$1", $');
d218 2
a219 2
	if ($libspec =~ m|(.*)/|o) {
		return _report_problem("$base/$1", $');
@


1.20
log
@error code: if we can't find a given libspec, we look through all
known registered libs, and tell the user why this library doesn't match.

Example:
Can't install kdelibs-3.5.7: lib not found lib/qt3/qt-mt.31.0
qt-mt.31.0: found partial match in /usr/local/lib/qt3: major=32, minor=0 (bad major)
qt-mt.31.0: found partial match in /usr/local/lib: major=31, minor=0 (bad directory)

(after altering qt to have @@lib lib/qt3/libqt-mt.so.32.0)
@
text
@d2 1
a2 1
# $OpenBSD: SharedLibs.pm,v 1.19 2007/06/04 16:33:23 espie Exp $
d164 1
a164 1
	my ($base, $libspec, $wantpath) = @@_;
@


1.19
log
@avoid parsing libraries by hand.
Store shared libraries in a `better' format, which will also us
to report issues more nicely.
@
text
@d2 1
a2 1
# $OpenBSD: SharedLibs.pm,v 1.18 2007/06/04 14:57:33 espie Exp $
d173 51
@


1.18
log
@I am on drugs, I don't know where I found split can take strings as
arguments. Repair...
@
text
@d2 1
a2 1
# $OpenBSD: SharedLibs.pm,v 1.17 2007/06/04 14:40:39 espie Exp $
d90 5
a94 3
	if ($name =~ m/^(.*\/lib.*?\.so\.\d+)\.(\d+)$/o) {
		my ($stem, $minor) = ($1, $2);
		push(@@{$registered_libs->{$stem}}, [$minor, $pkgname]);
d150 1
a150 1
		my $exists = $registered_libs->{"$dir/lib$libname.so.$major"};
@


1.17
log
@some minor systematic changes.
- mark all regexps I can with /o if they can be compiled once.
- turn $o->method() into $o->method
- remove unneeded prototypes
- reduce split /re/ into split "string" where possible.
@
text
@d2 1
a2 1
# $OpenBSD: SharedLibs.pm,v 1.16 2007/05/23 10:33:45 espie Exp $
d54 1
a54 1
				for my $d (split(':', $1)) {
@


1.16
log
@fiddle with SharedLibs name, put common code into a common place in
pkg_add.
@
text
@d2 1
a2 1
# $OpenBSD: SharedLibs.pm,v 1.15 2007/05/23 09:27:27 espie Exp $
d53 1
a53 1
			if (m/^\s*search directories:\s*(.*?)\s*$/) {
d90 1
a90 1
	if ($name =~ m/^(.*\/lib.*?\.so\.\d+)\.(\d+)$/) {
d146 1
a146 1
	if ($spec =~ m/^(.*)\.(\d+)\.(\d+)$/) {
d164 1
a164 1
	if ($libspec =~ m|(.*)/|) {
@


1.15
log
@use autovivify
@
text
@d2 1
a2 1
# $OpenBSD: SharedLibs.pm,v 1.14 2007/05/14 23:16:41 espie Exp $
d103 1
a103 1
sub add_system_libs
d117 1
a117 1
sub add_package_libs
d119 1
a119 1
	my ($pkgname, $wantpath) = @@_;
a127 5
	if (defined $wantpath) {
		if (defined $plist->{extrainfo}) {
			$pkgname = $plist->{extrainfo}->{subdir};
		}
	}
d132 1
a132 1
sub add_plist_libs
d134 1
a134 1
	my ($plist) = @@_;
@


1.14
log
@remove unneeded quotes
@
text
@d2 1
a2 1
# $OpenBSD: SharedLibs.pm,v 1.13 2007/05/07 08:18:02 espie Exp $
a91 2
		$registered_libs->{$stem} = [] 
		    unless defined $registered_libs->{$stem};
@


1.13
log
@use one single list for system directories.
@
text
@d2 1
a2 1
# $OpenBSD: SharedLibs.pm,v 1.12 2007/05/07 08:14:51 espie Exp $
d92 3
a94 3
		$registered_libs->{"$stem"} = [] 
		    unless defined $registered_libs->{"$stem"};
		push(@@{$registered_libs->{"$stem"}}, [$minor, $pkgname]);
@


1.12
log
@remove -Fboguslibs, we haven't had unmarked libraries for years
@
text
@d2 1
a2 1
# $OpenBSD: SharedLibs.pm,v 1.11 2007/05/02 15:05:30 espie Exp $
d100 5
d110 2
a111 2
	for my $dirname ("/usr/lib", "/usr/X11R6/lib") {
		opendir(my $dir, $destdir.$dirname) or next;
d113 1
a113 1
			register_lib("$dirname/$d", 'system');
@


1.11
log
@$o->method() becomes $o->method
@
text
@d2 1
a2 1
# $OpenBSD: SharedLibs.pm,v 1.10 2007/04/29 11:09:29 espie Exp $
a25 14
sub mark_bogus_lib
{
}

package OpenBSD::PackingElement::FileBase;

sub mark_bogus_lib
{
	my ($self, $pkgname) = @@_;
	my $fname = $self->fullname;
	return unless $fname =~ m/\/lib[^\/]+\.so\.\d+\.\d+$/;
	OpenBSD::SharedLibs::register_lib($fname, $pkgname);
}

a33 4
sub mark_bogus_lib
{
}

a131 16
}

sub add_bogus_package_libs
{
	my $pkgname = $_[0];
	if (!defined $done_plist->{$pkgname}) {
		add_package_libs($pkgname);
	}
	return if $done_plist->{$pkgname} == 2;
	$done_plist->{$pkgname} = 2;
	my $plist = OpenBSD::PackingList->from_installation($pkgname);
	if (!defined $plist) {
		Warn "Can't read plist for $pkgname\n";
		return;
	}
	$plist->mark_bogus_lib($pkgname);
@


1.10
log
@replace $p->visit('method') calls with $p->method
now that it works.
@
text
@d2 1
a2 1
# $OpenBSD: SharedLibs.pm,v 1.9 2007/04/15 10:17:29 espie Exp $
d35 1
a35 1
	my $fname = $self->fullname();
d45 1
a45 1
	OpenBSD::SharedLibs::register_lib($self->fullname(), $pkgname);
d171 1
a171 1
	my $pkgname = $plist->pkgname();
@


1.9
log
@update copyright years, standardize licence.
reword the introduction to the stuff originally from FreeBSD to clarify
slightly.
@
text
@d2 1
a2 1
# $OpenBSD: SharedLibs.pm,v 1.8 2005/08/16 20:05:12 espie Exp $
d149 1
a149 1
	$plist->visit('mark_available_lib', $pkgname);
d165 1
a165 1
	$plist->visit('mark_bogus_lib', $pkgname);
d174 1
a174 1
	$plist->visit('mark_available_lib', $pkgname);
@


1.8
log
@make sure libs get registered if we take a shortcut and don't reinstall
the package, or if we call add_bogus_libs directly.
@
text
@d2 1
a2 1
# $OpenBSD: SharedLibs.pm,v 1.7 2005/08/12 16:57:15 espie Exp $
d4 1
a4 1
# Copyright (c) 2003-2004 Marc Espie <espie@@openbsd.org>
@


1.7
log
@avoid warning message
@
text
@d2 1
a2 1
# $OpenBSD: SharedLibs.pm,v 1.6 2004/12/28 14:50:38 espie Exp $
d155 4
a158 1
	return if defined $done_plist->{$pkgname} && $done_plist->{$pkgname} == 2;
@


1.6
log
@add a boguslibs forced option, that rescans packages for libraries
not marked with @@lib.

This allows pkg_add -current to deal with 3.6 packages fully.
@
text
@d2 1
a2 1
# $OpenBSD: SharedLibs.pm,v 1.5 2004/12/21 11:43:46 espie Exp $
d155 1
a155 1
	return if $done_plist->{$pkgname} == 2;
@


1.5
log
@if we can't get this packing-list, this is not dramatic
@
text
@d2 1
a2 1
# $OpenBSD: SharedLibs.pm,v 1.4 2004/11/23 11:12:56 espie Exp $
d26 14
d48 4
d150 13
@


1.4
log
@allow for registration of libraries from an existing plist.
make sure lookup_libspec result is defined.
allow for registering pkgpath instead of pkgname.
@
text
@d2 1
a2 1
# $OpenBSD: SharedLibs.pm,v 1.3 2004/11/22 01:56:13 espie Exp $
d121 4
@


1.3
log
@implement global repository for shared libraries.
@
text
@d2 1
a2 1
# $OpenBSD: SharedLibs.pm,v 1.2 2004/11/21 15:44:56 espie Exp $
d116 1
a116 1
	my ($pkgname) = @@_;
d121 15
d142 1
a142 1
	my @@r;
d160 2
a161 1
	my ($base, $libspec) = @@_;
@


1.2
log
@move the system libraries registration code to SharedLibs.
@
text
@d2 1
a2 1
# $OpenBSD: SharedLibs.pm,v 1.1 2004/11/21 15:36:17 espie Exp $
d20 14
d89 6
a94 3
	my ($stem, $minor, $pkg) = @@_;
	if (!defined $registered_libs->{"$stem"} || $registered_libs->{"$stem"}->[0] < $minor) {
		$registered_libs->{"$stem"} = [$minor, $pkg];
d98 1
a98 1
my $done_system = 0;
d103 2
a104 2
	return if $done_system;
	$done_system = 1;
d108 1
a108 4
			next unless $d =~ m/^(.*\.so\.\d+)\.(\d+)$/;
			my ($stem, $minor) = ($1, $2);
			$stem = "$dirname/$stem";
			register_lib($stem, $minor, 'system');
d113 40
@


1.1
log
@pull the code that handles shared libraries (ldconfig for now) aside.
@
text
@d2 1
a2 1
# $OpenBSD: PackingElement.pm,v 1.72 2004/11/18 21:46:07 espie Exp $
d27 1
d71 28
@

