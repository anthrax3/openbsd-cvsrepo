head	1.49;
access;
symbols
	OPENBSD_6_1_BASE:1.49
	OPENBSD_6_0:1.49.0.4
	OPENBSD_6_0_BASE:1.49
	OPENBSD_5_9:1.47.0.2
	OPENBSD_5_9_BASE:1.47
	OPENBSD_5_8:1.47.0.4
	OPENBSD_5_8_BASE:1.47
	OPENBSD_5_7:1.45.0.2
	OPENBSD_5_7_BASE:1.45
	OPENBSD_5_6:1.43.0.4
	OPENBSD_5_6_BASE:1.43
	OPENBSD_5_5:1.40.0.4
	OPENBSD_5_5_BASE:1.40
	OPENBSD_5_4:1.38.0.12
	OPENBSD_5_4_BASE:1.38
	OPENBSD_5_3:1.38.0.10
	OPENBSD_5_3_BASE:1.38
	OPENBSD_5_2:1.38.0.8
	OPENBSD_5_2_BASE:1.38
	OPENBSD_5_1_BASE:1.38
	OPENBSD_5_1:1.38.0.6
	OPENBSD_5_0:1.38.0.4
	OPENBSD_5_0_BASE:1.38
	OPENBSD_4_9:1.38.0.2
	OPENBSD_4_9_BASE:1.38
	OPENBSD_4_8:1.36.0.2
	OPENBSD_4_8_BASE:1.36
	OPENBSD_4_7:1.29.0.2
	OPENBSD_4_7_BASE:1.29
	OPENBSD_4_6:1.11.0.12
	OPENBSD_4_6_BASE:1.11
	OPENBSD_4_5:1.11.0.8
	OPENBSD_4_5_BASE:1.11
	OPENBSD_4_4:1.11.0.6
	OPENBSD_4_4_BASE:1.11
	OPENBSD_4_3:1.11.0.4
	OPENBSD_4_3_BASE:1.11
	OPENBSD_4_2:1.11.0.2
	OPENBSD_4_2_BASE:1.11
	OPENBSD_4_1:1.9.0.2
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.8.0.4
	OPENBSD_4_0_BASE:1.8
	OPENBSD_3_9:1.8.0.2
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.5.0.4
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.2
	OPENBSD_3_7_BASE:1.5;
locks; strict;
comment	@# @;


1.49
date	2016.06.23.16.11.23;	author espie;	state Exp;
branches;
next	1.48;
commitid	QxkzX6iWFbwTHuvu;

1.48
date	2016.06.15.15.31.09;	author espie;	state Exp;
branches;
next	1.47;
commitid	Tw2l7s39vzJqETyy;

1.47
date	2015.05.18.10.41.20;	author espie;	state Exp;
branches;
next	1.46;
commitid	rrwCEb8hinrmFki2;

1.46
date	2015.05.18.10.25.10;	author espie;	state Exp;
branches;
next	1.45;
commitid	DMp3xx7BP1az3zhE;

1.45
date	2014.12.22.14.24.56;	author espie;	state Exp;
branches;
next	1.44;
commitid	quUhL2VXB9OEK2rK;

1.44
date	2014.11.30.15.56.15;	author espie;	state Exp;
branches;
next	1.43;
commitid	VEUnKivfaZ0TBfIM;

1.43
date	2014.07.07.16.45.03;	author espie;	state Exp;
branches;
next	1.42;
commitid	dNXHBdhSxhza9UxR;

1.42
date	2014.07.01.09.21.14;	author espie;	state Exp;
branches;
next	1.41;
commitid	pahs4DvL3j6GdczB;

1.41
date	2014.06.16.08.58.59;	author espie;	state Exp;
branches;
next	1.40;
commitid	h0JS5hNT4uwgPF1H;

1.40
date	2013.12.23.15.04.37;	author espie;	state Exp;
branches;
next	1.39;

1.39
date	2013.12.23.13.29.41;	author espie;	state Exp;
branches;
next	1.38;

1.38
date	2010.12.24.09.04.14;	author espie;	state Exp;
branches;
next	1.37;

1.37
date	2010.10.25.21.02.44;	author espie;	state Exp;
branches;
next	1.36;

1.36
date	2010.06.30.10.51.04;	author espie;	state Exp;
branches;
next	1.35;

1.35
date	2010.06.30.10.41.42;	author espie;	state Exp;
branches;
next	1.34;

1.34
date	2010.06.18.09.01.38;	author espie;	state Exp;
branches;
next	1.33;

1.33
date	2010.06.05.12.01.08;	author espie;	state Exp;
branches;
next	1.32;

1.32
date	2010.06.04.13.19.39;	author espie;	state Exp;
branches;
next	1.31;

1.31
date	2010.05.10.09.17.55;	author espie;	state Exp;
branches;
next	1.30;

1.30
date	2010.03.22.20.38.44;	author espie;	state Exp;
branches;
next	1.29;

1.29
date	2010.03.07.15.53.18;	author espie;	state Exp;
branches;
next	1.28;

1.28
date	2010.03.06.11.42.58;	author espie;	state Exp;
branches;
next	1.27;

1.27
date	2009.12.21.10.38.58;	author espie;	state Exp;
branches;
next	1.26;

1.26
date	2009.12.19.14.21.14;	author espie;	state Exp;
branches;
next	1.25;

1.25
date	2009.12.17.11.11.51;	author espie;	state Exp;
branches;
next	1.24;

1.24
date	2009.12.14.09.35.56;	author espie;	state Exp;
branches;
next	1.23;

1.23
date	2009.12.05.10.12.19;	author espie;	state Exp;
branches;
next	1.22;

1.22
date	2009.11.24.10.29.25;	author espie;	state Exp;
branches;
next	1.21;

1.21
date	2009.11.22.16.51.14;	author espie;	state Exp;
branches;
next	1.20;

1.20
date	2009.11.22.14.08.21;	author espie;	state Exp;
branches;
next	1.19;

1.19
date	2009.11.22.13.32.50;	author espie;	state Exp;
branches;
next	1.18;

1.18
date	2009.11.16.23.02.57;	author espie;	state Exp;
branches;
next	1.17;

1.17
date	2009.11.15.08.59.32;	author espie;	state Exp;
branches;
next	1.16;

1.16
date	2009.11.11.12.32.03;	author espie;	state Exp;
branches;
next	1.15;

1.15
date	2009.11.11.12.21.20;	author espie;	state Exp;
branches;
next	1.14;

1.14
date	2009.11.11.12.04.19;	author espie;	state Exp;
branches;
next	1.13;

1.13
date	2009.11.10.11.36.56;	author espie;	state Exp;
branches;
next	1.12;

1.12
date	2009.10.14.10.38.06;	author espie;	state Exp;
branches;
next	1.11;

1.11
date	2007.06.01.14.58.29;	author espie;	state Exp;
branches;
next	1.10;

1.10
date	2007.04.15.10.17.29;	author espie;	state Exp;
branches;
next	1.9;

1.9
date	2007.02.22.21.36.46;	author espie;	state Exp;
branches;
next	1.8;

1.8
date	2006.02.10.09.52.28;	author bernd;	state Exp;
branches;
next	1.7;

1.7
date	2005.10.23.10.03.23;	author espie;	state Exp;
branches;
next	1.6;

1.6
date	2005.09.04.22.47.56;	author espie;	state Exp;
branches;
next	1.5;

1.5
date	2004.12.29.14.10.27;	author espie;	state Exp;
branches;
next	1.4;

1.4
date	2004.12.29.01.11.13;	author espie;	state Exp;
branches;
next	1.3;

1.3
date	2004.11.14.11.58.43;	author espie;	state Exp;
branches;
next	1.2;

1.2
date	2004.10.18.13.29.14;	author espie;	state Exp;
branches;
next	1.1;

1.1
date	2004.10.18.12.03.19;	author espie;	state Exp;
branches;
next	;


desc
@@


1.49
log
@there's no reason for window size computation to be linked to the
ProgressMeter, so make it available from state.
- computation is lazy, so no runtime difference;
- don't bother setting a SIG{WINCH} on non-tty;
- progressmeter already has access to state;
- do an empty window_size_changed in base state, override it for
addcreatedelete to inform the progressmeter.

to be reused in dpb...
@
text
@# ex:ts=8 sw=4:
# $OpenBSD: ProgressMeter.pm,v 1.48 2016/06/15 15:31:09 espie Exp $
#
# Copyright (c) 2010 Marc Espie <espie@@openbsd.org>
#
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

use strict;
use warnings;

package OpenBSD::PackingElement;
sub compute_size
{
	my ($self, $totsize) = @@_;

	$$totsize += $self->{size} if defined $self->{size};
}

package OpenBSD::ProgressMeter;
sub new
{
	bless {}, "OpenBSD::ProgressMeter::Stub";
}

sub compute_size
{
	my ($self, $plist) = @@_;
	my $totsize = 0;
	$plist->compute_size(\$totsize);
	$totsize = 1 if $totsize == 0;
	return $totsize;
}

sub setup
{
	my ($self, $opt_x, $opt_m, $state) = @@_;
	$self->{state} = $state;
	if ($opt_m || (!$opt_x && -t STDOUT)) {
		require OpenBSD::ProgressMeter::Term;
		bless $self, "OpenBSD::ProgressMeter::Term";
		$self->init;
	}
}

sub disable {}

sub new_sizer
{
	my ($progress, $plist) = @@_;
	return $progress->sizer_class->new($progress, $plist);
}

sub sizer_class
{
	"PureSizer"
}

sub for_list
{
	my ($self, $msg, $l, $code) = @@_;
	if (defined $msg) {
		$self->set_header($msg);
	}
	my $total = scalar @@$l;
	my $i = 0;
	for my $e (@@$l) {
		$self->show(++$i, $total);
		&$code($e);
	}
	$self->next;
}

sub compute_playfield
{
}

# stub class when no actual progressmeter that still prints out.
package OpenBSD::ProgressMeter::Stub;
our @@ISA = qw(OpenBSD::ProgressMeter);

sub forked {}

sub clear {}


sub show {}

sub working {}
sub message {}

sub next {}

sub set_header {}

sub ntogo
{
	return "";
}

sub visit_with_size
{
	my ($progress, $plist, $method, @@r) = @@_;
	$plist->$method($progress->{state}, @@r);
}

sub visit_with_count
{
	&OpenBSD::ProgressMeter::Stub::visit_with_size;
}

package PureSizer;

sub new
{
	my ($class, $progress, $plist) = @@_;
	$plist->{totsize} //= $progress->compute_size($plist);
	bless {
	    progress => $progress, 
	    totsize => $plist->{totsize},
	    donesize => 0,
	    }, $class;
}

sub advance
{
	my ($self, $e) = @@_;
	if (defined $e->{size}) {
		$self->{donesize} += $e->{size};
	}
}

sub saved
{
	my $self = shift;
	$self->{progress}{state}{stats}{totsize} += $self->{totsize};
	$self->{progress}{state}{stats}{donesize} += $self->{donesize};
}

1;
@


1.48
log
@ProgressMeter keeps state. Unfortunately, term is shared between processes.
Adds supplementary code that was first tested in proot, but may be needed
to split pkg_add into processes in the future.
@
text
@d2 1
a2 1
# $OpenBSD: ProgressMeter.pm,v 1.47 2015/05/18 10:41:20 espie Exp $
d81 4
@


1.47
log
@simplify progressmeter calls to visit_and: we retrieve the state from the
progressmeter object
@
text
@d2 1
a2 1
# $OpenBSD: ProgressMeter.pm,v 1.46 2015/05/18 10:25:10 espie Exp $
d86 2
@


1.46
log
@since the progressmeter is always tied to a state, store the state always,
and not just in the Term case.

allows passing less parameters around.
@
text
@d2 1
a2 1
# $OpenBSD: ProgressMeter.pm,v 1.45 2014/12/22 14:24:56 espie Exp $
d107 1
a107 1
	$plist->$method(@@r);
@


1.45
log
@when we run into real errors, the progress meter is distracting, so have
a method ->disable that does something nice to the display, and stops
the progress meter right before we display our first real error.
@
text
@d2 1
a2 1
# $OpenBSD: ProgressMeter.pm,v 1.44 2014/11/30 15:56:15 espie Exp $
d47 1
a50 1
		$self->{state} = $state;
d59 2
a60 2
	my ($progress, $plist, $state) = @@_;
	return $progress->sizer_class->new($progress, $plist, $state);
d119 1
a119 1
	my ($class, $progress, $plist, $state) = @@_;
a124 1
	    state => $state
d139 2
a140 2
	$self->{state}{stats}{totsize} += $self->{totsize};
	$self->{state}{stats}{donesize} += $self->{donesize};
@


1.44
log
@much cleaner way to handle progress meter wipes: have state methods that
do print something call sync_display (which does nothing by default), and
override THAT one for the progressmeter case to go clear.
Should sync by default now.
@
text
@d2 1
a2 1
# $OpenBSD: ProgressMeter.pm,v 1.43 2014/07/07 16:45:03 espie Exp $
d55 2
d88 1
@


1.43
log
@record how many bytes we saved for statistics purposes.
exit the loop thru the same end code every time for consistency.
@
text
@d2 1
a2 1
# $OpenBSD: ProgressMeter.pm,v 1.42 2014/07/01 09:21:14 espie Exp $
a52 12
}

sub print
{
	shift->clear;
	print @@_;
}

sub errprint
{
	shift->clear;
	print STDERR @@_;
@


1.42
log
@tweak the ProgressMeter code to always record sizes, even in the stub case
@
text
@d2 1
a2 1
# $OpenBSD: ProgressMeter.pm,v 1.41 2014/06/16 08:58:59 espie Exp $
d144 7
@


1.41
log
@tweak the size_and support to be able to do stuff out of order
@
text
@d2 1
a2 1
# $OpenBSD: ProgressMeter.pm,v 1.40 2013/12/23 15:04:37 espie Exp $
d21 8
d35 9
d69 2
a70 1
	return shift;
d73 1
a73 1
sub advance
d75 1
d122 22
@


1.40
log
@real fix: turns out visit_with_* are transparent, e.g., pass all their
parameters to the end consumer.  Make sure the !Term version obeys that too.
@
text
@d2 1
a2 1
# $OpenBSD: ProgressMeter.pm,v 1.39 2013/12/23 13:29:41 espie Exp $
d48 9
@


1.39
log
@interface bug: visit_with_size has a state parameter.
I've been lucky that I've not invoked it with more parameters so far...
@
text
@d2 1
a2 1
# $OpenBSD: ProgressMeter.pm,v 1.38 2010/12/24 09:04:14 espie Exp $
d87 1
a87 1
	my ($progress, $plist, $method, $state, @@r) = @@_;
@


1.38
log
@handle failures from ports tree with more care.
this does avoid infinite loops in case of wrong plists.
necessary since print-plist-with-depends CAN fail...
@
text
@d2 1
a2 1
# $OpenBSD$
d87 1
a87 1
	my ($progress, $plist, $method, @@r) = @@_;
@


1.37
log
@don't use the fullwidth of the term by default, makes typing easier.
pass state thru so that we can check in /etc/pkg.conf and use it if we want.
@
text
@@


1.36
log
@allow say and errsay to work without parameters, as it's ways common.
create verbose_system up in state, because it makes sense without verbose.
@
text
@d29 1
a29 1
	my ($self, $opt_x, $opt_m) = @@_;
d33 1
@


1.35
log
@whitespace cleanup
@
text
@@


1.34
log
@buglet: Log object needs a printer to run f().
introduce for_list() iterator in ProgressMeter and use it
@
text
@d2 1
a2 1
# $OpenBSD: ProgressMeter.pm,v 1.33 2010/06/05 12:01:08 espie Exp $
@


1.33
log
@interface tweaks:
- allow mtree to create more diverse data structures.
- new "working" method, for when progressmeter should show that something is
going on, but doesn't actually have an actual % to show, so show cartwheels.
e.g., progress->working(1024);
(actual counter will be /= argument, so that it does move a bit slower).
@
text
@d2 1
a2 1
# $OpenBSD: ProgressMeter.pm,v 1.32 2010/06/04 13:19:39 espie Exp $
d47 15
@


1.32
log
@move code around, so that commands can be used as modules.
pkg becomes the start hub, which does nothing except require the
correct module.
Saner code wrt Add/Delete, and more sharing.
@
text
@d2 1
a2 1
# $OpenBSD: ProgressMeter.pm,v 1.31 2010/05/10 09:17:55 espie Exp $
d57 1
@


1.31
log
@whitespace fixes
@
text
@d2 1
a2 1
# $OpenBSD$
d29 2
a30 2
	my ($self, $opt_x) = @@_;
	if (!$opt_x && -t STDOUT) {
@


1.30
log
@clean up the ProgressMeter code, create a specific class if a Term
is around.
start using stuff from termcap, specifically, cleareol, and move to hp.
use the full line when we can, cram 100% if we can.
(this should flicker much less on slow terminals).

clean-up the install-and-progress bits to be in progressmeter, this removes
some code.

have pkg_create follow the same pattern as the others, with a state.
This allows us to unify error messages a bit.
@
text
@@


1.29
log
@erase to the end of "previous line". Avoid dangling % after displaying 100%.
from sthen@@.
@
text
@d4 1
a4 1
# Copyright (c) 2004-2007 Marc Espie <espie@@openbsd.org>
d16 1
a21 13

my $header;
my $lastdisplay = '';
my $isatty;
my $continued = 0;

# unless we know better
my $width;
my $playfield;

my $wsz_format = 'SSSS';
our %sizeof;

d24 1
a24 8
	my $class = shift;
	$isatty = -t STDOUT;
	if ($isatty) {
		my $oldfh = select(STDOUT);
		$| = 1;
		select($oldfh);
	}
	return bless {}, $class;
d27 1
a27 1
sub find_window_size
d29 5
a33 11
	return if defined $width;
	# try to get exact window width
	my $r;
	$r = pack($wsz_format, 0, 0, 0, 0);
	$sizeof{'struct winsize'} = 8;
	require 'sys/ttycom.ph';
	$width = 80;
	if (ioctl(STDOUT, &TIOCGWINSZ, $r)) {
		my ($rows, $cols, $xpix, $ypix) = 
		    unpack($wsz_format, $r);
		$width = $cols;
d37 1
a37 1
sub compute_playfield
d39 2
a40 6
	return unless $isatty;
	# compute playfield
	$playfield = $width - length($header) - 8;
	if ($playfield < 5) {
		$playfield = 0;
	}
d43 1
a43 1
sub set_header
d45 2
a46 15
	my $self = shift;
	$header = shift;
	if ($isatty) {
		find_window_size();
		compute_playfield();
		$SIG{'WINCH'} = sub {
			$width = undef;
			find_window_size();
			compute_playfield();
		};
		$SIG{'CONT'} = sub {
			$continued = 1;
		};
	}
	return $isatty;
d49 3
a51 3
sub _show
{
	my ($self, $d) = @@_;
d53 1
a53 9
	return if $d eq $lastdisplay && !$continued;
	$lastdisplay=$d;
	$continued = 0;
	print $d;
	if ($width > length($d)) {
		print ' 'x($width - length($d) - 1);
	}
	print "\r";
}
d55 1
a55 14
sub message
{
	my $self = shift;
	return unless $isatty;
	my $message = shift;
	if ($playfield > length($message)) {
		$message .= ' 'x($playfield - length($message));
	}
	if ($playfield) {
		$self->_show("$header|".substr($message, 0, $playfield));
	} else {
		$self->_show($header);
	}
}
d57 1
a57 14
sub show
{
	my $self = shift;
	return unless $isatty;
	my ($current, $total) = @@_;

	if ($playfield) {
		my $stars = int (($current * $playfield) / $total + 0.5);
		my $percent = int (($current * 100)/$total + 0.5);
		$self->_show("$header|".'*'x$stars.' 'x($playfield-$stars)."| ".$percent."\%");
	} else {
	    $self->_show( $header);
	}
}
d59 1
a59 8
sub clear
{
	my $self = shift;
	return unless $isatty;
	return unless length($lastdisplay) > 0;
	print ' 'x length($lastdisplay), "\r";
	$lastdisplay = '';
}
d61 1
a61 5
sub print
{
	shift->clear;
	print @@_;
}
d63 1
a63 1
sub errprint
d65 1
a65 2
	shift->clear;
	print STDERR @@_;
d68 1
a68 1
sub next
d70 2
a71 6
	my ($self, $todo) = @@_;
	return unless $isatty;
	$self->clear;

	$todo //= '';
	print "$header: ok$todo\n";
d74 1
a74 1
sub ntogo
d76 1
a76 1
	&OpenBSD::UI::ntogo_string;
@


1.28
log
@don't go up to column 80, until we ask Term::Cap properly for what's going
on.
@
text
@d98 5
a102 1
	print $d, "\r";
@


1.27
log
@much simpler SIG{INFO} handling: create a status object in state and
update it when needed. Install a SIG{INFO} handler at start that will do
what's needed.
@
text
@d66 1
a66 1
	$playfield = $width - length($header) - 7;
@


1.26
log
@create a $state->todo method to account for sets to install.
have tracker keep track of sets not done, and ask it directly for how many
there's still to do. Provide an offset into next for cases where we know
we already did a set but haven't accounted for it yet.
-> more accurate number of sets still to do.
@
text
@d164 1
a164 11
	my ($self, $todo, $offset) = @@_;

	$todo //= 0;
	$offset //= 0;
	$todo += $offset;

	if ($todo > 0) {
		return " ($todo to go)";
	} else {
		return "";
	}
@


1.25
log
@move the ntogo actual code in the progressmeter, so that -x shuts it off.
@
text
@d2 1
a2 1
# $OpenBSD: ProgressMeter.pm,v 1.24 2009/12/14 09:35:56 espie Exp $
d164 5
a168 1
	my ($self, $todo) = @@_;
d170 1
a170 1
	if (defined $todo && $todo > 0) {
@


1.24
log
@fuss about install msgs: new method state->ntogo, use it to annotate more
messages with global progress information.

Also, when not finding a suitable update, report it if set is not a simple
update. Helps in figuring out cases like gstreamer...
@
text
@d2 1
a2 1
# $OpenBSD$
d160 11
@


1.23
log
@cosmetic
@
text
@d158 2
a159 3
	$todo //= 0;
	print "$header: ok", $todo > 0 ? " ($todo to go)" : "", "\n";

@


1.22
log
@ok even shorter than done
@
text
@d159 1
a159 1
	print "$header: ok", $todo ? " ($todo to go)" : "", "\n";
@


1.21
log
@complete -> done (shorter)
@
text
@d159 1
a159 1
	print "$header: done ", $todo ? "($todo to go)" : "", "\n";
@


1.20
log
@tweak completion messages: do the next only during the next iteration, so
that at end, we can show a full completion message for the whole set.
pass the number of packages still to-do through, so that the last complete
also says (n to go) during installs...
@
text
@d159 1
a159 1
	print "$header: complete ", $todo ? "($todo to go)" : "", "\n";
@


1.19
log
@extra parameter to give out more info
@
text
@d157 3
a159 1
	print "$header: complete ", defined $todo ? "($todo to go)\n" : "\n";
@


1.18
log
@fuller meter, that goes to the end of the line - 1
@
text
@d154 1
a154 1
	my $self = shift;
d157 2
a158 1
	print "$header: complete\n";
@


1.17
log
@common code, handle SIG{CONT} in both cases.
@
text
@d66 1
a66 1
	$playfield = $width - length($header) - 10;
@


1.16
log
@don't use Warn if we've got a $state, get through errprint/errsay.
Also: reset lastdisplay on clear, and don't clear twice.
@
text
@d91 10
a105 1
	my $d;
d110 1
a110 1
		$d = "$header|".substr($message, 0, $playfield);
d112 1
a112 1
		$d = $header;
a113 4
	return if $d eq $lastdisplay && !$continued;
	$lastdisplay=$d;
	$continued = 0;
	print $d, "\r";
a120 1
	my $d;
d123 3
a125 3
	    my $stars = int (($current * $playfield) / $total + 0.5);
	    my $percent = int (($current * 100)/$total + 0.5);
	    $d = "$header|".'*'x$stars.' 'x($playfield-$stars)."| ".$percent."\%";
d127 1
a127 1
	    $d = $header;
a128 3
	return if $d eq $lastdisplay;
        $lastdisplay=$d;
        print $d, "\r";
@


1.15
log
@also get most STDERR messages through the same way
@
text
@d134 1
d136 1
@


1.14
log
@progressmeter puts STDOUT in autoflush if -t, so that it can display to it instead of piping a lot of stuff to STDERR.

Go through state->print for most messages, so they will NOT do weird things
with the progressmeter.
Use a ->say shortcut which does the same thing that perl 5.10 say does...
@
text
@d143 6
@


1.13
log
@bad espie: use strict/warnings consistently, and fix two nits and two
actual errors !
@
text
@d37 6
a42 1
	$isatty = -t STDERR;
d55 1
a55 1
	if (ioctl(STDERR, &TIOCGWINSZ, $r)) {
d108 1
a108 1
	print STDERR $d, "\r";
d127 1
a127 1
        print STDERR $d, "\r";
d134 1
a134 1
	print STDERR ' 'x length($lastdisplay), "\r";
d140 1
a140 1
	print STDERR @@_;
d148 1
a148 1
	print STDERR"$header: complete\n";
@


1.12
log
@add a "print" method to ProgressMeter and StubProgress to allow me to clean
up the current mess (e.g., print things out to stderr without needing to
explicitly clear the current line if needed).

create a choose_location method directly in state, that will replace all
instances of looking for a package eventually (hopefully).
@
text
@a15 1
#
@


1.11
log
@refactor ProgressMeter code to create objects, put these into state.
Create a common state class for delete and add, put the progressmeter
creation in there.

neat effect: we don't have a progressmeter, we use a stub class instead
and *never* pull the code in at all.
@
text
@d2 1
a2 1
# $OpenBSD: ProgressMeter.pm,v 1.10 2007/04/15 10:17:29 espie Exp $
d131 6
@


1.10
log
@update copyright years, standardize licence.
reword the introduction to the stuff originally from FreeBSD to clarify
slightly.
@
text
@d2 1
a2 1
# $OpenBSD: ProgressMeter.pm,v 1.9 2007/02/22 21:36:46 espie Exp $
a25 1
my $enabled = 0;
d35 7
a67 5
sub enable
{
	$enabled = 1;
}

d70 1
a71 6
	if (!$enabled) {
		$isatty = 0;
	}
	if (!defined $isatty) {
		$isatty = -t STDERR;
	}
d89 1
d109 1
d128 1
d135 1
d137 1
a137 1
	clear;
@


1.9
log
@avoid comparing undef to 0: perl's ioctl returns `true' 0s, so that this
idiom works.
@
text
@d2 1
a2 1
# $OpenBSD: ProgressMeter.pm,v 1.8 2006/02/10 09:52:28 bernd Exp $
d4 1
a4 1
# Copyright (c) 2004 Marc Espie <espie@@openbsd.org>
@


1.8
log
@If the length of the message in OpenBSD::ProgressMeter::message() is shorter
than the length of the playfield, fill up the difference with whitespace.

Prevents leftover characters from previous message()s.

ok espie@@
@
text
@d2 1
a2 1
# $OpenBSD: ProgressMeter.pm,v 1.7 2005/10/23 10:03:23 espie Exp $
d45 1
a45 1
	if (ioctl(STDERR, &TIOCGWINSZ, $r) == 0) {
@


1.7
log
@if resumed from ^Z, display meter without waiting for changes.
idea from deraadt@@
@
text
@d2 1
a2 1
# $OpenBSD: ProgressMeter.pm,v 1.6 2005/09/04 22:47:56 espie Exp $
d96 3
@


1.6
log
@* New -i interactive option, that can ask obnoxious questions.
* move the signature code to a packing-list method, prepend the pkgname.
* depend on distant listings, cache these systematically.
* cut the PKG_PATH at :/ systematically, much simpler than parsing URLs.
People should get used to trailing /s.
* let pkg_add -u actually run the update.
* check for signature in more places, for instance, let pkg_add installed_stuff
be a void operation.
* grab enough stuff during updates to check signatures, so that pkg_add -u
can report updates that are not needed right away, instead of waiting
for the more confusing `trying to update'
* beginning of @@module support.
* @@pkgpath support, including updates.
* systematically expand stems when applicable.
* use visitors systematically in pkg_info.
* pkg_info -S reports signature.
* remove hardcoding of categories in PackingList, so that future modules
will be able to expand them.
* add @@updateset and @@incompatibility keywords.
@
text
@d2 1
a2 1
# $OpenBSD: ProgressMeter.pm,v 1.5 2004/12/29 14:10:27 espie Exp $
d27 1
d84 3
d101 1
a101 1
	return if $d eq $lastdisplay;
d103 1
@


1.5
log
@show `reading plist' while deleting packages, since we can do this easily,
and this gives a hint about what is going on for big packages (like tetex).
@
text
@d2 1
a2 1
# $OpenBSD: ProgressMeter.pm,v 1.4 2004/12/29 01:11:13 espie Exp $
d71 3
a73 4
	} else {
		if (!defined $isatty) {
			$isatty = -t STDERR;
		}
@


1.4
log
@round number of stars immediately, avoids off-by-1 display error.
fixes an elusive problem reported ages ago by sturm@@...
@
text
@d2 1
a2 1
# $OpenBSD: ProgressMeter.pm,v 1.3 2004/11/14 11:58:43 espie Exp $
d88 15
d105 1
a106 1
	return unless $isatty;
@


1.3
log
@turn on progress meter by default, use -x to disable it.
document the new stuff, partial reorder of options.
@
text
@d2 1
a2 1
# $OpenBSD: ProgressMeter.pm,v 1.2 2004/10/18 13:29:14 espie Exp $
d95 1
a95 1
	    my $stars = ($current * $playfield) / $total;
@


1.2
log
@take window size into account.
window sizes changes are delayed, nothing to do about it,
since perl keeps the signal around until it is safe to activate it...
@
text
@d2 1
a2 1
# $OpenBSD: ProgressMeter.pm,v 1.1 2004/10/18 12:03:19 espie Exp $
a74 1
		find_window_size();
@


1.1
log
@experimental progress meter.
not active unless you specify -x for pkg_add/pkg_delete.
(option is bound to change)
@
text
@d2 1
a2 1
# $OpenBSD: Error.pm,v 1.2 2004/10/04 12:12:30 espie Exp $
d29 1
a29 1
my $width = 80;
d32 29
d75 1
d78 7
a84 5
		# compute playfield
		$playfield = $width - length($header) - 10;
		if ($playfield > 40) {
			$playfield = 40;
		}
d93 1
d95 7
a101 3
        my $stars = ($current * $playfield) / $total;
	my $percent = int (($current * 100)/$total + 0.5);
        my $d = "$header|".'*'x$stars.' 'x($playfield-$stars)."| ".$percent."\%";
@

