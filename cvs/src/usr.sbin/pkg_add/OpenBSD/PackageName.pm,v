head	1.52;
access;
symbols
	OPENBSD_6_1:1.52.0.14
	OPENBSD_6_1_BASE:1.52
	OPENBSD_6_0:1.52.0.12
	OPENBSD_6_0_BASE:1.52
	OPENBSD_5_9:1.52.0.6
	OPENBSD_5_9_BASE:1.52
	OPENBSD_5_8:1.52.0.8
	OPENBSD_5_8_BASE:1.52
	OPENBSD_5_7:1.52.0.2
	OPENBSD_5_7_BASE:1.52
	OPENBSD_5_6:1.52.0.4
	OPENBSD_5_6_BASE:1.52
	OPENBSD_5_5:1.51.0.12
	OPENBSD_5_5_BASE:1.51
	OPENBSD_5_4:1.51.0.8
	OPENBSD_5_4_BASE:1.51
	OPENBSD_5_3:1.51.0.6
	OPENBSD_5_3_BASE:1.51
	OPENBSD_5_2:1.51.0.4
	OPENBSD_5_2_BASE:1.51
	OPENBSD_5_1_BASE:1.51
	OPENBSD_5_1:1.51.0.2
	OPENBSD_5_0:1.50.0.4
	OPENBSD_5_0_BASE:1.50
	OPENBSD_4_9:1.50.0.2
	OPENBSD_4_9_BASE:1.50
	OPENBSD_4_8:1.48.0.2
	OPENBSD_4_8_BASE:1.48
	OPENBSD_4_7:1.43.0.2
	OPENBSD_4_7_BASE:1.43
	OPENBSD_4_6:1.35.0.4
	OPENBSD_4_6_BASE:1.35
	OPENBSD_4_5:1.32.0.2
	OPENBSD_4_5_BASE:1.32
	OPENBSD_4_4:1.31.0.6
	OPENBSD_4_4_BASE:1.31
	OPENBSD_4_3:1.31.0.4
	OPENBSD_4_3_BASE:1.31
	OPENBSD_4_2:1.31.0.2
	OPENBSD_4_2_BASE:1.31
	OPENBSD_4_1:1.14.0.2
	OPENBSD_4_1_BASE:1.14
	OPENBSD_4_0:1.12.0.2
	OPENBSD_4_0_BASE:1.12
	OPENBSD_3_9:1.9.0.4
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.9.0.2
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.6.0.2
	OPENBSD_3_7_BASE:1.6
	OPENBSD_3_6:1.5.0.2
	OPENBSD_3_6_BASE:1.5
	OPENBSD_3_5:1.4.0.2
	OPENBSD_3_5_BASE:1.4
	pkgtools:1.1.1.1
	espie:1.1.1;
locks; strict;
comment	@# @;


1.52
date	2014.03.18.18.53.29;	author espie;	state Exp;
branches;
next	1.51;

1.51
date	2011.08.31.10.11.58;	author espie;	state Exp;
branches;
next	1.50;

1.50
date	2010.12.24.09.04.14;	author espie;	state Exp;
branches;
next	1.49;

1.49
date	2010.10.27.14.35.56;	author espie;	state Exp;
branches;
next	1.48;

1.48
date	2010.07.02.12.41.43;	author espie;	state Exp;
branches;
next	1.47;

1.47
date	2010.06.30.10.51.04;	author espie;	state Exp;
branches;
next	1.46;

1.46
date	2010.06.30.10.41.42;	author espie;	state Exp;
branches;
next	1.45;

1.45
date	2010.06.18.14.04.20;	author espie;	state Exp;
branches;
next	1.44;

1.44
date	2010.05.10.09.17.55;	author espie;	state Exp;
branches;
next	1.43;

1.43
date	2010.01.27.15.57.16;	author espie;	state Exp;
branches;
next	1.42;

1.42
date	2010.01.24.14.12.24;	author espie;	state Exp;
branches;
next	1.41;

1.41
date	2010.01.19.14.58.53;	author espie;	state Exp;
branches;
next	1.40;

1.40
date	2010.01.10.11.31.08;	author espie;	state Exp;
branches;
next	1.39;

1.39
date	2010.01.09.17.42.25;	author espie;	state Exp;
branches;
next	1.38;

1.38
date	2009.12.30.19.04.06;	author espie;	state Exp;
branches;
next	1.37;

1.37
date	2009.12.30.16.43.08;	author espie;	state Exp;
branches;
next	1.36;

1.36
date	2009.11.10.11.36.56;	author espie;	state Exp;
branches;
next	1.35;

1.35
date	2009.06.10.14.40.03;	author espie;	state Exp;
branches;
next	1.34;

1.34
date	2009.04.19.14.58.32;	author espie;	state Exp;
branches;
next	1.33;

1.33
date	2009.03.07.12.04.13;	author espie;	state Exp;
branches;
next	1.32;

1.32
date	2008.10.20.10.25.16;	author espie;	state Exp;
branches;
next	1.31;

1.31
date	2007.08.23.09.09.16;	author espie;	state Exp;
branches;
next	1.30;

1.30
date	2007.06.04.20.48.23;	author espie;	state Exp;
branches;
next	1.29;

1.29
date	2007.06.04.14.57.33;	author espie;	state Exp;
branches;
next	1.28;

1.28
date	2007.06.04.14.40.39;	author espie;	state Exp;
branches;
next	1.27;

1.27
date	2007.05.17.12.07.46;	author espie;	state Exp;
branches;
next	1.26;

1.26
date	2007.05.14.11.02.14;	author espie;	state Exp;
branches;
next	1.25;

1.25
date	2007.05.14.10.53.31;	author espie;	state Exp;
branches;
next	1.24;

1.24
date	2007.05.14.10.43.45;	author espie;	state Exp;
branches;
next	1.23;

1.23
date	2007.05.14.10.00.08;	author espie;	state Exp;
branches;
next	1.22;

1.22
date	2007.05.13.13.39.43;	author espie;	state Exp;
branches;
next	1.21;

1.21
date	2007.05.13.13.32.36;	author espie;	state Exp;
branches;
next	1.20;

1.20
date	2007.05.13.13.12.21;	author espie;	state Exp;
branches;
next	1.19;

1.19
date	2007.05.13.12.55.54;	author espie;	state Exp;
branches;
next	1.18;

1.18
date	2007.05.07.14.29.06;	author espie;	state Exp;
branches;
next	1.17;

1.17
date	2007.05.07.14.06.38;	author espie;	state Exp;
branches;
next	1.16;

1.16
date	2007.05.07.13.51.58;	author espie;	state Exp;
branches;
next	1.15;

1.15
date	2007.04.15.10.17.29;	author espie;	state Exp;
branches;
next	1.14;

1.14
date	2007.03.06.23.35.01;	author espie;	state Exp;
branches;
next	1.13;

1.13
date	2006.10.17.22.08.31;	author espie;	state Exp;
branches;
next	1.12;

1.12
date	2006.08.11.11.01.12;	author bernd;	state Exp;
branches;
next	1.11;

1.11
date	2006.03.13.14.06.58;	author espie;	state Exp;
branches;
next	1.10;

1.10
date	2006.03.04.11.31.18;	author espie;	state Exp;
branches;
next	1.9;

1.9
date	2005.08.29.00.42.58;	author espie;	state Exp;
branches;
next	1.8;

1.8
date	2005.08.16.11.25.48;	author espie;	state Exp;
branches;
next	1.7;

1.7
date	2005.08.16.10.24.23;	author espie;	state Exp;
branches;
next	1.6;

1.6
date	2004.10.11.09.44.06;	author espie;	state Exp;
branches;
next	1.5;

1.5
date	2004.08.06.07.51.17;	author espie;	state Exp;
branches;
next	1.4;

1.4
date	2004.02.20.19.11.28;	author espie;	state Exp;
branches;
next	1.3;

1.3
date	2003.11.06.17.47.25;	author espie;	state Exp;
branches;
next	1.2;

1.2
date	2003.10.19.18.41.32;	author espie;	state Exp;
branches;
next	1.1;

1.1
date	2003.10.16.17.43.34;	author espie;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2003.10.16.17.43.34;	author espie;	state Exp;
branches;
next	;


desc
@@


1.52
log
@remove $_ usage that warns under perl 5.18
@
text
@# ex:ts=8 sw=4:
# $OpenBSD: PackageName.pm,v 1.51 2011/08/31 10:11:58 espie Exp $
#
# Copyright (c) 2003-2010 Marc Espie <espie@@openbsd.org>
#
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

use strict;
use warnings;

package OpenBSD::PackageName;

sub url2pkgname($)
{
	my $name = $_[0];
	$name =~ s|.*/||;
	$name =~ s|\.tgz$||;

	return $name;
}

# see packages-specs(7)
sub splitname
{
	my $n = shift;
	if ($n =~ /^(.*?)\-(\d.*)$/o) {
		my $stem = $1;
		my $rest = $2;
		my @@all = split /\-/o, $rest;
		return ($stem, @@all);
	} else {
		return ($n);
	}
}

my $cached = {};

sub from_string
{
	my ($class, $s) = @@_;
	return $cached->{$s} //= $class->new_from_string($s);
}

sub new_from_string
{
	my ($class, $n) = @@_;
	if ($n =~ /^(.*?)\-(\d.*)$/o) {
		my $stem = $1;
		my $rest = $2;
		my @@all = split /\-/o, $rest;
		my $version = OpenBSD::PackageName::version->from_string(shift @@all);
		return bless {
			stem => $stem,
			version => $version,
			flavors => { map {($_, 1)} @@all },
		}, "OpenBSD::PackageName::Name";
	} else {
		return bless {
			stem => $n,
		}, "OpenBSD::PackageName::Stem";
	}
}

sub splitstem
{
	my $s = shift;
	if ($s =~ /^(.*?)\-\d/o) {
		return $1;
	} else {
		return $s;
	}
}

sub is_stem
{
	my $s = shift;
	if ($s =~ m/\-\d/o || $s eq '-') {
		return 0;
	} else {
		return 1;
	}
}

sub compile_stemlist
{
	my $hash = {};
	for my $n (@@_) {
		my $stem = splitstem($n);
		$hash->{$stem} = {} unless defined $hash->{$stem};
		$hash->{$stem}->{$n} = 1;
	}
	bless $hash, "OpenBSD::PackageLocator::_compiled_stemlist";
}

sub avail2stems
{
	my @@avail = @@_;
	return OpenBSD::PackageName::compile_stemlist(@@avail);
}

package OpenBSD::PackageLocator::_compiled_stemlist;

sub find
{
	my ($self, $stem) = @@_;
	return keys %{$self->{$stem}};
}

sub add
{
	my ($self, $pkgname) = @@_;
	my $stem = OpenBSD::PackageName::splitstem($pkgname);
	$self->{$stem}->{$pkgname} = 1;
}

sub delete
{
	my ($self, $pkgname) = @@_;
	my $stem = OpenBSD::PackageName::splitstem($pkgname);
	delete $self->{$stem}->{$pkgname};
	if(keys %{$self->{$stem}} == 0) {
		delete $self->{$stem};
	}
}

sub find_partial
{
	my ($self, $partial) = @@_;
	my @@result = ();
	while (my ($stem, $pkgs) = each %$self) {
		next unless $stem =~ /\Q$partial\E/i;
		push(@@result, keys %$pkgs);
	}
	return @@result;
}

package OpenBSD::PackageName::dewey;

my $cache = {};

sub from_string
{
	my ($class, $string) = @@_;
	my $o = bless { deweys => [ split(/\./o, $string) ],
		suffix => '', suffix_value => 0}, $class;
	if ($o->{deweys}->[-1] =~ m/^(\d+)(rc|beta|pre|pl)(\d*)$/) {
		$o->{deweys}->[-1] = $1;
		$o->{suffix} = $2;
		$o->{suffix_value} = $3;
	}
	return $o;
}

sub make
{
	my ($class, $string) = @@_;
	return $cache->{$string} //= $class->from_string($string);
}

sub to_string
{
	my $self = shift;
	my $r = join('.', @@{$self->{deweys}});
	if ($self->{suffix}) {
		$r .= $self->{suffix} . $self->{suffix_value};
	}
	return $r;
}

sub suffix_compare
{
	my ($a, $b) = @@_;
	if ($a->{suffix} eq $b->{suffix}) {
		return $a->{suffix_value} <=> $b->{suffix_value};
	}
	if ($a->{suffix} eq 'pl') {
		return 1;
	}
	if ($b->{suffix} eq 'pl') {
		return -1;
	}

	if ($a->{suffix} gt $b->{suffix}) {
		return -suffix_compare($b, $a);
	}
	# order is '', beta, pre, rc
	# we know that a < b,
	if ($a->{suffix} eq '') {
		return 1;
	}
	if ($a->{suffix} eq 'beta') {
		return -1;
	}
	# refuse to compare pre vs. rc
	return 0;
}

sub compare
{
	my ($a, $b) = @@_;
	# Try a diff in dewey numbers first
	for (my $i = 0; ; $i++) {
		if (!defined $a->{deweys}->[$i]) {
			if (!defined $b->{deweys}->[$i]) {
				last;
			} else {
				return -1;
			}
		}
		if (!defined $b->{deweys}->[$i]) {
			return 1;
		}
		my $r = dewey_compare($a->{deweys}->[$i],
			$b->{deweys}->[$i]);
		return $r if $r != 0;
	}
	return suffix_compare($a, $b);
}

sub dewey_compare
{
	my ($a, $b) = @@_;
	# numerical comparison
	if ($a =~ m/^\d+$/o and $b =~ m/^\d+$/o) {
		return $a <=> $b;
	}
	# added lowercase letter
	if ("$a.$b" =~ m/^(\d+)([a-z]?)\.(\d+)([a-z]?)$/o) {
		my ($an, $al, $bn, $bl) = ($1, $2, $3, $4);
		if ($an != $bn) {
			return $an <=> $bn;
		} else {
			return $al cmp $bl;
		}
	}
	return $a cmp $b;
}

package OpenBSD::PackageName::version;

sub p
{
	my $self = shift;

	return defined $self->{p} ? $self->{p} : -1;
}

sub v
{
	my $self = shift;

	return defined $self->{v} ? $self->{v} : -1;
}

sub from_string
{
	my ($class, $string) = @@_;
	my $o = bless {}, $class;
	if ($string =~ m/^(.*)v(\d+)$/o) {
		$o->{v} = $2;
		$string = $1;
	}
	if ($string =~ m/^(.*)p(\d+)$/o) {
		$o->{p} = $2;
		$string = $1;
	}
	$o->{dewey} = OpenBSD::PackageName::dewey->make($string);

	return $o;
}

sub to_string
{
	my $o = shift;
	my $string = $o->{dewey}->to_string;
	if (defined $o->{p}) {
		$string .= 'p'.$o->{p};
	}
	if (defined $o->{v}) {
		$string .= 'v'.$o->{v};
	}
	return $string;
}

sub pnum_compare
{
	my ($a, $b) = @@_;
	return $a->p <=> $b->p;
}

sub compare
{
	my ($a, $b) = @@_;
	# Simple case: epoch number
	if ($a->v != $b->v) {
		return $a->v <=> $b->v;
	}
	# Simple case: only p number differs
	if ($a->{dewey} eq $b->{dewey}) {
		return $a->pnum_compare($b);
	}

	return $a->{dewey}->compare($b->{dewey});
}

sub has_issues
{
	my $self = shift;
	if ($self->{dewey}{deweys}[-1] =~ m/v\d+$/ && defined $self->{p}) {
		return ("correct order is pNvM");
	} else {
		return ();
	}
}

package OpenBSD::PackageName::Stem;
sub to_string
{
	my $o = shift;
	return $o->{stem};
}

sub to_pattern
{
	my $o = shift;
	return $o->{stem}.'-*';
}

sub has_issues
{
	my $self = shift;
	return ("is a stem");
}

package OpenBSD::PackageName::Name;
sub flavor_string
{
	my $o = shift;
	return join('-', sort keys %{$o->{flavors}});
}

sub to_string
{
	my $o = shift;
	return join('-', $o->{stem}, $o->{version}->to_string,
	    sort keys %{$o->{flavors}});
}

sub to_pattern
{
	my $o = shift;
	return join('-', $o->{stem}, '*', $o->flavor_string);
}

sub compare
{
	my ($a, $b) = @@_;
	if ($a->{stem} ne $b->{stem} || $a->flavor_string ne $b->flavor_string) {
		return undef;
	}
	return $a->{version}->compare($b->{version});
}

sub has_issues
{
	my $self = shift;
	return ((map {"flavor $_ can't start with digit"}
	    	grep { /^\d/ } keys %{$self->{flavors}}),
		$self->{version}->has_issues);
}

1;
@


1.51
log
@versionspec stuff belongs in PkgSpec, not PackageName
@
text
@d2 1
a2 1
# $OpenBSD$
d35 2
a36 2
	my $_ = shift;
	if (/^(.*?)\-(\d.*)$/o) {
d42 1
a42 1
		return ($_);
d50 2
a51 2
	my ($class, $_) = @@_;
	return $cached->{$_} //= $class->new_from_string($_);
d56 2
a57 2
	my ($class, $_) = @@_;
	if (/^(.*?)\-(\d.*)$/o) {
d69 1
a69 1
			stem => $_,
d76 2
a77 2
	my $_ = shift;
	if (/^(.*?)\-\d/o) {
d80 1
a80 1
		return $_;
d86 2
a87 2
	my $_ = shift;
	if (m/\-\d/o || $_ eq '-') {
@


1.50
log
@handle failures from ports tree with more care.
this does avoid infinite loops in case of wrong plists.
necessary since print-plist-with-depends CAN fail...
@
text
@a325 81
package OpenBSD::PackageName::versionspec;
our @@ISA = qw(OpenBSD::PackageName::version);

my $ops = {
	'<' => 'lt',
	'<=' => 'le',
	'>' => 'gt',
	'>=' => 'ge',
	'=' => 'eq'
};

sub from_string
{
	my ($class, $s) = @@_;
	my ($op, $version) = ('=', $s);
	if ($s =~ m/^(\>\=|\>|\<\=|\<|\=)(.*)$/) {
		($op, $version) = ($1, $2);
	}
	bless $class->SUPER::from_string($version),
		"OpenBSD::PackageName::version::$ops->{$op}";
}

sub pnum_compare
{
	my ($spec, $b) = @@_;
	if (!defined $spec->{p}) {
		return 0;
	} else {
		return $spec->SUPER::pnum_compare($b);
	}
}

sub is_exact
{
	return 0;
}
package OpenBSD::PackageName::version::lt;
our @@ISA = qw(OpenBSD::PackageName::versionspec);
sub match
{
	my ($self, $b) = @@_;
	-$self->compare($b) >= 0 ? 0 : 1;
}

package OpenBSD::PackageName::version::le;
our @@ISA = qw(OpenBSD::PackageName::versionspec);
sub match
{
	my ($self, $b) = @@_;
	-$self->compare($b) <= 0 ? 1 : 0;
}

package OpenBSD::PackageName::version::gt;
our @@ISA = qw(OpenBSD::PackageName::versionspec);
sub match
{
	my ($self, $b) = @@_;
	-$self->compare($b) > 0 ? 1 : 0;
}

package OpenBSD::PackageName::version::ge;
our @@ISA = qw(OpenBSD::PackageName::versionspec);
sub match
{
	my ($self, $b) = @@_;
	-$self->compare($b) >= 0 ? 1 : 0;
}

package OpenBSD::PackageName::version::eq;
our @@ISA = qw(OpenBSD::PackageName::versionspec);
sub match
{
	my ($self, $b) = @@_;
	-$self->compare($b) == 0 ? 1 : 0;
}

sub is_exact
{
	return 1;
}

@


1.49
log
@initial scaffolding for @@rcscript: for now, acts like normal files,
but allow absolute pathnames (treat that as an implicit @@cwd).
@
text
@@


1.48
log
@move the empty url message up to PackageRepository, so that we can print
it cleanly.
allow some urls to be empty without warning (e.g., "./" should generally
be allowed to be empty).
@
text
@d2 1
a2 1
# $OpenBSD: PackageName.pm,v 1.47 2010/06/30 10:51:04 espie Exp $
@


1.47
log
@allow say and errsay to work without parameters, as it's ways common.
create verbose_system up in state, because it makes sense without verbose.
@
text
@d2 1
a2 1
# $OpenBSD$
a107 3
	if (@@avail == 0) {
		print STDERR "No packages available in the PKG_PATH\n";
	}
@


1.46
log
@whitespace cleanup
@
text
@@


1.45
log
@oops
@
text
@d2 1
a2 1
# $OpenBSD: PackageName.pm,v 1.44 2010/05/10 09:17:55 espie Exp $
@


1.44
log
@whitespace fixes
@
text
@d2 1
a2 1
# $OpenBSD$
d109 1
a109 3
		require OpenBSD::Error;

		OpenBSD::Error::Warn("No packages available in the PKG_PATH\n");
@


1.43
log
@actually order things:
beta < (rc|pre) < release < pl

(fixes speex updates)
@
text
@d151 1
a151 1
	
d202 1
a202 1
	# we know that a < b, 
d316 1
a316 1
	} 
d335 2
a336 2
	'<' => 'lt', 
	'<=' => 'le', 
d339 1
a339 1
	'=' => 'eq' 
d349 1
a349 1
	bless $class->SUPER::from_string($version), 
d441 1
a441 1
	return join('-', $o->{stem}, $o->{version}->to_string, 
d463 2
a464 2
	return ((map {"flavor $_ can't start with digit"} 
	    	grep { /^\d/ } keys %{$self->{flavors}}), 
@


1.42
log
@add code to check packagename for problems
@
text
@d159 6
a164 6
	my $o = bless { deweys => [ split(/\./o, $string) ]}, $class;
	for my $suffix (qw(rc beta pre pl)) {
		if ($o->{deweys}->[-1] =~ m/^(\d+)$suffix(\d*)$/) {
			$o->{deweys}->[-1] = $1;
			$o->{$suffix} = $2;
		}
d179 2
a180 4
	for my $suffix (qw(pl pre beta rc)) {
		if (defined $self->{$suffix}) {
			$r .= $suffix . $self->{$suffix};
		}
d185 28
d232 1
a232 16
	# finally try all the usual suspects
	# release candidates and beta and pre releases.
	for my $suffix (qw(rc beta pre pl)) {
		my $result = $suffix eq 'pl' ? 1 : -1;
		if (defined $a->{$suffix} && defined $b->{$suffix}) {
			return $a->{$suffix} <=> $b->{$suffix};
		}
		if (defined $a->{$suffix} && !defined $b->{$suffix}) {
			return $result;
		}
		if (!defined $a->{$suffix} && defined $b->{$suffix}) {
			return -$result;
		}
	}
	# give up: we don't know how to make a difference
	return 0;
@


1.41
log
@simplify caching: return $cached->{$_} //= new_value;
remove stats
cache LibSpec as well (1000 c.53.0 !)
@
text
@d4 1
a4 1
# Copyright (c) 2003-2007 Marc Espie <espie@@openbsd.org>
d310 10
d414 6
d447 8
@


1.40
log
@pull the signature comparison code into its own file.
add comparison functions to Packagenames that return undef when it matters.
@
text
@a46 20
my $calls = 0;
my $nohits = 0;
my $dewey_calls = 0;
my $dewey_hits = 0;
my $tocalls = 0;
my $strings = 0;

sub stats
{
	require Devel::Size;

	print STDERR "Size=", Devel::Size::total_size($cached), "\n";
	print STDERR "Total calls: ", $calls, "\n";
	print STDERR "Cache hits: ", $calls - $nohits, "\n";
	print STDERR "Dewey calls: ", $dewey_calls, "\n";
	print STDERR "Dewey hits: ", $dewey_hits, "\n";
	print STDERR "to_string calls: ", $tocalls, "\n";
	print STDERR "string compares: ", $strings, "\n";
#	print STDERR join(',', sort keys %$cached), "\n";
}
d51 1
a51 7
	$calls++;
	if (!defined $cached->{$_}) {
		$nohits++;
		return $cached->{$_} = $class->new_from_string($_);
	} else {
		return $cached->{$_};
	}
d172 1
a172 7
	$dewey_calls++;
	if (!defined $cache->{$string}) {
		return $cache->{$string} = $class->from_string($string);
	} else {
		$dewey_hits++;
		return $cache->{$string};
	}
a278 1
	$tocalls++;
a303 1
		$strings++;
@


1.39
log
@fix to_string
@
text
@d458 9
@


1.38
log
@more changes and optimizations: create unique dewey objects, so I can
compare them directly and avoid storing the string.
on typical use through a large update, 2/3 cache hits.

also, remove switch on <,> by writing subclasses. Actually makes things
clearer.
@
text
@d210 1
a210 1
	my $r = join('.', [$self->{deweys}]);
d449 1
a449 1
	    $o->flavor_string);
@


1.37
log
@fix pkgspec handling, actually do filter by regexp.
shave some memory off packagenames by not storing non-existent p/v.
cache all packagename construction (happens two times out of 3).
@
text
@d49 2
d61 2
d65 1
a65 1
	print STDERR join(',', sort keys %$cached), "\n";
a72 1
		$cached->{$_} = $class->new_from_string($_);
d74 3
a77 1
	return $cached->{$_};
d178 3
a180 1
package OpenBSD::PackageName::version;
d182 1
a182 1
sub make_dewey
d184 2
a185 2
	my $o = shift;
	$o->{deweys} = [ split(/\./o, $o->{string}) ];
d192 1
d195 1
a195 15
sub p
{
	my $self = shift;

	return defined $self->{p} ? $self->{p} : -1;
}

sub v
{
	my $self = shift;

	return defined $self->{v} ? $self->{v} : -1;
}

sub from_string
d198 6
a203 4
	my $o = bless {}, $class;
	if ($string =~ m/^(.*)v(\d+)$/o) {
		$o->{v} = $2;
		$string = $1;
a204 8
	if ($string =~ m/^(.*)p(\d+)$/o) {
		$o->{p} = $2;
		$string = $1;
	}
	$o->{string} = $string;

	$o->make_dewey;
	return $o;
d209 6
a214 5
	my $o = shift;
	$tocalls++;
	my $string = $o->{string};
	if (defined $o->{p}) {
		$string .= 'p'.$o->{p};
d216 1
a216 10
	if (defined $o->{v}) {
		$string .= 'v'.$o->{v};
	}
	return $string;
}

sub pnum_compare
{
	my ($a, $b) = @@_;
	return $a->p <=> $b->p;
a221 9
	# Simple case: epoch number
	if ($a->v != $b->v) {
		return $a->v <=> $b->v;
	}
	# Simple case: only p number differs
	if ($a->{string} eq $b->{string}) {
		$strings++;
		return $a->pnum_compare($b);
	} 
d275 69
d347 8
d362 2
a363 3
	my $self = $class->SUPER::from_string($version);
	$self->{op} = $op;
	return $self;
d376 14
d393 26
a418 2
	
	my $op = $self->{op};
d420 2
a421 6
	my $compare = - $self->compare($b);
	return 0 if $op eq '<' && $compare >= 0;
	return 0 if $op eq '<=' && $compare > 0;
	return 0 if $op eq '>' && $compare <= 0;
	return 0 if $op eq '>=' && $compare < 0;
	return 0 if $op eq '=' && $compare != 0;
@


1.36
log
@bad espie: use strict/warnings consistently, and fix two nits and two
actual errors !
@
text
@d46 18
d67 11
a82 1
		my %flavors = map {($_,1)}  @@all;
d86 1
a86 1
			flavors => \%flavors,
d187 14
d204 1
a204 2
	my $vnum = -1;
	my $pnum = -1;
d206 1
a206 1
		$vnum = $2;
d210 1
a210 1
		$pnum = $2;
d213 1
a213 5
	my $o = bless {
		pnum => $pnum,
		vnum => $vnum,
		string => $string,
	}, $class;
d222 1
d224 2
a225 2
	if ($o->{pnum} > -1) {
		$string .= 'p'.$o->{pnum};
d227 2
a228 2
	if ($o->{vnum} > -1) {
		$string .= 'v'.$o->{vnum};
d236 1
a236 1
	return $a->{pnum} <=> $b->{pnum}
d243 2
a244 2
	if ($a->{vnum} != $b->{vnum}) {
		return $a->{vnum} <=> $b->{vnum};
d248 1
d322 1
a322 1
	if ($spec->{pnum} == -1) {
@


1.35
log
@fix dewey comparison for suffixes (no early return)
@
text
@d20 1
@


1.34
log
@synch with my new style search/location changes
It's likely there will be some fallout, but it's getting a bit too large
to keep around.
This does kill a few very old oddities as well.
@
text
@d215 1
a215 1
				return 0;
@


1.33
log
@introduce versionspecs as a derivative object from version.

Allows an operator such as <=.
also overrides the compare operator for the pnum part, because specifically,
in pkgspecs, if the pnum is not specified, it stands for "any pnum will do"...

yes, that's hairy...
@
text
@a85 40
sub splitp
{
	my $_ = shift;

	if (/^(.*\-\d[^-]*)p(\d+)(.*)$/o) {
		return ($1.$3, $2);
	} else {
		return ($_,-1);
	}
}

sub rebuildp
{
	my ($pkg, $p) = @@_;
	if ($p == -1) {
		return $pkg;
	}
	if ($pkg =~ m/^(.*?)(\-\d[^-v]*)(.*)$/o) {
		return "$1$2p$p$3";
	} else {
		return $pkg."p".$p;
	}
}

sub keep_most_recent
{
	my $h = {};
	for my $pkgname (@@_) {
		my ($p, $v) = splitp($pkgname);
		if (!defined $h->{$p} || $h->{$p} < $v) {
			$h->{$p} = $v;
		}
	}
	my @@list = ();
	while (my ($p, $v) = each %$h) {
		push(@@list, rebuildp($p, $v));
	}
	return @@list;
}

d318 6
d327 2
a328 1
	return join('-', $o->{stem}, $o->{version}->to_string, sort keys %{$o->{flavors}});
d334 1
a334 1
	return join('-', $o->{stem}, '*', sort keys %{$o->{flavors}});
@


1.32
log
@Say goodbye to local $_
lexical scoping is so much neater (courtesy of perl 5.10)
@
text
@d234 6
d249 1
a249 1
		return $a->{pnum} <=> $b->{pnum}
d302 40
@


1.31
log
@fix v* order in keep_most_recent.
@
text
@d2 1
a2 1
# $OpenBSD: PackageName.pm,v 1.30 2007/06/04 20:48:23 espie Exp $
d34 1
a34 1
	local $_ = shift;
d47 1
a47 2
	my $class = shift;
	local $_ = shift;
d68 1
a68 1
	local $_ = shift;
d78 1
a78 1
	local $_ = shift;
d88 1
a88 1
	local $_ = shift;
@


1.30
log
@convert the remaining regexps, so that $`, $', $& are completely dead.
Should shave a few % off time and space.
@
text
@d2 1
a2 1
# $OpenBSD: PackageName.pm,v 1.29 2007/06/04 14:57:33 espie Exp $
d104 1
a104 1
	if ($pkg =~ m/^(.*?)(\-\d[^-]*)(.*)$/o) {
@


1.29
log
@I am on drugs, I don't know where I found split can take strings as
arguments. Repair...
@
text
@d2 1
a2 1
# $OpenBSD: PackageName.pm,v 1.28 2007/06/04 14:40:39 espie Exp $
d35 3
a37 3
	if (/\-(?=\d)/o) {
		my $stem = $`;
		my $rest = $';
d49 3
a51 3
	if (/\-(?=\d)/o) {
		my $stem = $`;
		my $rest = $';
d70 2
a71 2
	if (/\-(?=\d)/o) {
		return $`;
d91 2
a92 2
	if (/^(.*\-\d[^-]*)p(\d+)/o) {
		return ($1.$', $2);
d104 2
a105 2
	if ($pkg =~ m/\-\d[^-]*/o) {
		return "$`$&p$p$'";
d204 7
a210 7
	if ($string =~ m/v(\d+)$/o) {
		$vnum = $1;
		$string = $`;
	}
	if ($string =~ m/p(\d+)$/o) {
		$pnum = $1;
		$string = $`;
@


1.28
log
@some minor systematic changes.
- mark all regexps I can with /o if they can be compiled once.
- turn $o->method() into $o->method
- remove unneeded prototypes
- reduce split /re/ into split "string" where possible.
@
text
@d2 1
a2 1
# $OpenBSD: PackageName.pm,v 1.27 2007/05/17 12:07:46 espie Exp $
d38 1
a38 1
		my @@all = split '-', $rest;
d52 1
a52 1
		my @@all = split '-', $rest;
d190 1
a190 1
	$o->{deweys} = [ split('.', $o->{string}) ];
@


1.27
log
@handle normalization of flavors in PackageName objects.
@
text
@d2 1
a2 1
# $OpenBSD: PackageName.pm,v 1.26 2007/05/14 11:02:14 espie Exp $
d35 1
a35 1
	if (/\-(?=\d)/) {
d38 1
a38 1
		my @@all = split /\-/, $rest;
d49 1
a49 1
	if (/\-(?=\d)/) {
d52 1
a52 1
		my @@all = split /\-/, $rest;
d70 1
a70 1
	if (/\-(?=\d)/) {
d80 1
a80 1
	if (m/\-\d/ || $_ eq '-') {
d91 1
a91 1
	if (/^(.*\-\d[^-]*)p(\d+)/) {
d104 1
a104 1
	if ($pkg =~ m/\-\d[^-]*/) {
d190 1
a190 1
	$o->{deweys} = [ split(/\./, $o->{string}) ];
d204 1
a204 1
	if ($string =~ m/v(\d+)$/) {
d208 1
a208 1
	if ($string =~ m/p(\d+)$/) {
d284 1
a284 1
	if ($a =~ m/^\d+$/ and $b =~ m/^\d+$/) {
d288 1
a288 1
	if ("$a.$b" =~ m/^(\d+)([a-z]?)\.(\d+)([a-z]?)$/) {
@


1.26
log
@put Search objects into their own file, finally
@
text
@d2 1
a2 1
# $OpenBSD: PackageName.pm,v 1.25 2007/05/14 10:53:31 espie Exp $
d54 1
d58 1
a58 1
			flavors => \@@all
d316 1
a316 1
	return join('-', $o->{stem}, $o->{version}->to_string, @@{$o->{flavors}});
d322 1
a322 1
	return join('-', $o->{stem}, '*', @@{$o->{flavors}});
@


1.25
log
@put search objects into a search class.
@
text
@d2 1
a2 1
# $OpenBSD: PackageName.pm,v 1.24 2007/05/14 10:43:45 espie Exp $
a321 29
}

package OpenBSD::Search::Stem;
sub new
{
	my ($class, $stem) = @@_;

	return bless {stem => $stem}, $class;
}

sub split
{
	my ($class, $pkgname) = @@_;
	return $class->new(OpenBSD::PackageName::splitstem($pkgname));
}

sub match
{
	my ($self, $o) = @@_;
	return $o->stemlist->find($self->{stem});
}

package OpenBSD::Search::PartialStem;
our @@ISA=(qw(OpenBSD::Search::Stem));

sub match
{
	my ($self, $o) = @@_;
	return $o->stemlist->find_partial($self->{stem});
@


1.24
log
@name tweaks: match -> match_list, match_repo -> match
@
text
@d2 1
a2 1
# $OpenBSD: PackageName.pm,v 1.23 2007/05/14 10:00:08 espie Exp $
d311 14
d344 2
a345 8
package OpenBSD::PackageName::PartialStem;
our @@ISA=(qw(OpenBSD::PackageName::Stem));

sub to_pattern
{
	my $o = shift;
	return '*.'.$o->{stem}.'*-*';
}
a350 13
}

package OpenBSD::PackageName::Name;
sub to_string
{
	my $o = shift;
	return join('-', $o->{stem}, $o->{version}->to_string, @@{$o->{flavors}});
}

sub to_pattern
{
	my $o = shift;
	return join('-', $o->{stem}, '*', @@{$o->{flavors}});
@


1.23
log
@maintain stemlist for installed packages dynamically
@
text
@d2 1
a2 1
# $OpenBSD: PackageName.pm,v 1.22 2007/05/13 13:39:43 espie Exp $
d324 1
a324 1
sub match_repo
d339 1
a339 1
sub match_repo
@


1.22
log
@kill more stuff
@
text
@d2 1
a2 1
# $OpenBSD: PackageName.pm,v 1.21 2007/05/13 13:32:36 espie Exp $
d154 17
@


1.21
log
@unify object lookup as locator->match($o) or $repo->match($o)
@
text
@d2 1
a2 1
# $OpenBSD: PackageName.pm,v 1.20 2007/05/13 13:12:21 espie Exp $
a125 13
sub findstem
{
	my ($k, @@list) = @@_;
	my @@r = ();
	for my $n (@@list) {
		my $stem = splitstem($n);
		if ($k eq $stem) {
			push(@@r, $n);
		}
	}
	return @@r;
}

d150 1
a150 1
sub findstem
d156 1
a156 1
sub find_partialstem
d310 1
a310 1
	return $o->stemlist->findstem($self->{stem});
d325 1
a325 1
	return $o->stemlist->find_partialstem($self->{stem});
@


1.20
log
@also create PartialStem objects, and create a generic
PackageLocator->match($o), where $o can be a spec, a stem, a partialstem.
@
text
@d2 1
a2 1
# $OpenBSD: PackageName.pm,v 1.19 2007/05/13 12:55:54 espie Exp $
d323 1
a323 1
	return $o->stemlist->findstem($o->{stem});
d327 1
a327 1
our @@ISA=(qw(OpenBSD::PackageName::PartialStem));
d338 1
a338 1
	return $o->stemlist->find_partialstem($o->{stem});
@


1.19
log
@move towards unifying stem searches and pkgspec searches.
@
text
@d2 1
a2 1
# $OpenBSD: PackageName.pm,v 1.18 2007/05/07 14:29:06 espie Exp $
d318 21
@


1.18
log
@zap old code
@
text
@d2 1
a2 1
# $OpenBSD: PackageName.pm,v 1.17 2007/05/07 14:06:38 espie Exp $
d305 13
@


1.17
log
@do not expose stemlist internals, create find_partialstem function.
@
text
@d2 1
a2 1
# $OpenBSD: PackageName.pm,v 1.16 2007/05/07 13:51:58 espie Exp $
a158 5
}

sub available_stems
{
	return avail2stems(OpenBSD::PackageLocator::available());
@


1.16
log
@make keep_most_recent explicit, do not try to pre-compute it at the stemlist
level.
@
text
@d2 1
a2 1
# $OpenBSD: PackageName.pm,v 1.15 2007/04/15 10:17:29 espie Exp $
d172 11
@


1.15
log
@update copyright years, standardize licence.
reword the introduction to the stuff originally from FreeBSD to clarify
slightly.
@
text
@d2 1
a2 1
# $OpenBSD: PackageName.pm,v 1.14 2007/03/06 23:35:01 espie Exp $
a151 1
	my $state = shift;
a157 3
	unless ($state->{forced}->{allversions}) {
	    @@avail = OpenBSD::PackageName::keep_most_recent(@@avail);
	}
d163 1
a163 2
	my $state = shift;
	return avail2stems($state, OpenBSD::PackageLocator::available());
@


1.14
log
@get vfs size snapshotted and restored so that pkg_add -u has a harder
time overflowing the disk.

let stem work at the end of urls.

test sturm@@ and bernd@@,

okay deraadt@@
@
text
@d2 1
a2 1
# $OpenBSD: PackageName.pm,v 1.13 2006/10/17 22:08:31 espie Exp $
d4 1
a4 1
# Copyright (c) 2003-2004 Marc Espie <espie@@openbsd.org>
@


1.13
log
@add proper version handling, not really used yet.
@
text
@d2 1
a2 1
# $OpenBSD: PackageName.pm,v 1.12 2006/08/11 11:01:12 bernd Exp $
d150 1
a150 1
sub available_stems
d153 1
a153 1
	my @@avail = OpenBSD::PackageLocator::available();
d163 6
@


1.12
log
@typo in comment
@
text
@d2 1
a2 1
# $OpenBSD: PackageName.pm,v 1.11 2006/03/13 14:06:58 espie Exp $
d45 21
d68 6
a73 1
	return (splitname $_[0])[0];
d173 140
@


1.11
log
@repair pkg_add -
@
text
@d2 1
a2 1
# $OpenBSD: PackageName.pm,v 1.10 2006/03/04 11:31:18 espie Exp $
d31 1
a31 1
# see package-specs(7)
@


1.10
log
@reorganize code a little bit: Update.pm becomes Replace.pm (since it matches
the -r option), and the find_update code moves to Update.pm, so that it doesn't
get parsed if -u is not used.

Also make the has_new_sig and uses_old_libs local methods of PackingList,
as it is their natural API.

Reorg a few more routines so that they can be found by pkg_add and by
Update.pm.

May need to split off more stuff to avoid parsing everything...
@
text
@d2 1
a2 1
# $OpenBSD: PackageName.pm,v 1.9 2005/08/29 00:42:58 espie Exp $
d53 1
a53 1
	if (m/\-\d/) {
@


1.9
log
@correctly trim old p* versions of packages.

tests sturm@@, aanriot@@

okay deraadt@@
@
text
@d2 1
a2 1
# $OpenBSD: PackageName.pm,v 1.8 2005/08/16 11:25:48 espie Exp $
d122 15
@


1.8
log
@use a hash for compiled stems, to avoid spurious duplicates.
adjust find_updatenames accordingly.
@
text
@d2 1
a2 1
# $OpenBSD: PackageName.pm,v 1.7 2005/08/16 10:24:23 espie Exp $
d58 40
@


1.7
log
@support code for pkg_add -u:
- distant_available(), using the distant listing functions.
- stem compiler, to match lots of stems
@
text
@d2 1
a2 1
# $OpenBSD: PackageName.pm,v 1.6 2004/10/11 09:44:06 espie Exp $
d78 2
a79 2
		$hash->{$stem} = [] unless defined $hash->{$stem};
		push(@@{$hash->{$stem}}, $n);
d89 1
a89 1
	return $self->{$stem};
@


1.6
log
@split PackageName handling into PackageName stuff/PkgSpec matching.
Kill new method that isn't really used.

Name explicit splitstem() to get the stem of a packagename.

Adjust calls to the interface.
@
text
@d2 1
a2 1
# $OpenBSD: PackageName.pm,v 1.5 2004/08/06 07:51:17 espie Exp $
d73 19
@


1.5
log
@unified headers, switch to smaller copyright notice.
@
text
@d2 1
a2 1
# $OpenBSD: PackageName.pm,v 1.4 2004/02/20 19:11:28 espie Exp $
a30 16
sub new
{
	my ($class, $name) = @@_;
	my $self = { name => $name };
# remove irrelevant filesystem info
	my $pkgname = url2pkgname($name);
	$self->{pkgname} = $pkgname;
# cut pkgname into pieces
	my @@list = splitname($pkgname);
	$self->{stem} = $list[0];
	$self->{version} = $list[1];
	$self->{flavors} = [];
	push @@{$self->{flavors}}, @@list[2,];
	bless $self, $class;
}

d45 5
d65 1
a65 1
		my $stem = (splitname $n)[0];
a70 194
}

# all the shit that does handle package specifications
sub compare_pseudo_numbers
{
	my ($n, $m) = @@_;

	my ($n1, $m1);

	if ($n =~ m/^\d+/) {
		$n1 = $&;
		$n = $';
	}
	if ($m =~ m/^\d+/) {
		$m1 = $&;
		$m = $';
	}

	if ($n1 == $m1) {
		return $n cmp $m;
	} else {
		return $n1 <=> $m1;
	}
}


sub dewey_compare
{
	my ($a, $b) = @@_;
	my ($pa, $pb);

	unless ($b =~ m/p\d+$/) { 		# does the Dewey hold a p<number> ?
		$a =~ s/p\d+$//; 	# No -> strip it from version.
	}

	return 0 if $a =~ /^$b$/; 	# bare equality

	if ($a =~ s/p(\d+)$//) {	# extract patchlevels
		$pa = $1;
	}
	if ($b =~ s/p(\d+)$//) {
		$pb = $1;
	}

	my @@a = split(/\./, $a);
	push @@a, $pa if defined $pa;	# ... and restore them
	my @@b = split(/\\\./, $b);
	push @@b, $pb if defined $pb;
	while (@@a > 0 && @@b > 0) {
		my $va = shift @@a;
		my $vb = shift @@b;
		next if $va eq $vb;
		return compare_pseudo_numbers($va, $vb);
	}
	if (@@a > 0) {
		return 1;
	} else {
		return -1;
	}
}

sub check_version
{
	my ($v, $spec) = @@_;
	local $_;

	# any version spec
	return 1 if $spec eq '.*';

	my @@specs = split(/,/, $spec);
	for (grep /^\d/, @@specs) { 		# exact number: check match
		return 1 if $v =~ /^$_$/;
		return 1 if $v =~ /^${_}p\d+$/; # allows for recent patches
	}

	# Last chance: dewey specs ?
	my @@deweys = grep !/^\d/, @@specs;		
	for (@@deweys) {
		if (m/^\<\=|\>\=|\<|\>/) {
			my ($op, $dewey) = ($&, $');
			my $compare = dewey_compare($v, $dewey);
			return 0 if $op eq '<' && $compare >= 0;
			return 0 if $op eq '<=' && $compare > 0;
			return 0 if $op eq '>' && $compare <= 0;
			return 0 if $op eq '>=' && $compare < 0;
		} else {
			return 0;	# unknown spec type
		}
	}
	return @@deweys == 0 ? 0 : 1;
}

sub check_1flavor
{
	my ($f, $spec) = @@_;
	local $_;

	for (split /-/, $spec) {
		# must not be here
		if (m/^\!/) {
			return 0 if $f->{$'};
		# must be here
		} else {
			return 0 unless $f->{$_};
		}
	}
	return 1;
}

sub check_flavor
{
	my ($f, $spec) = @@_;
	local $_;
	# no flavor constraints
	return 1 if $spec eq '';

	$spec =~ s/^-//;
	# retrieve all flavors
	my %f = map +($_, 1), split /\-/, $f;

	# check each flavor constraint
	for (split /,/, $spec) {
		if (check_1flavor(\%f, $_)) {
			return 1;
		}
	}
	return 0;
}

sub subpattern_match
{
	my ($p, $list) = @@_;
	local $_;

	my ($stemspec, $vspec, $flavorspec);


	# then, guess at where the version number is if any,
	
	# this finds patterns like -<=2.3,>=3.4.p1-
	# the only constraint is that the actual number 
	# - must start with a digit, 
	# - not contain - or ,
	if ($p =~ m/\-((?:\>|\>\=|\<|\<\=)?\d[^-]*)/) {
		($stemspec, $vspec, $flavorspec) = ($`, $1, $');
	# `any version' matcher
	} elsif ($p =~ m/\-\*/) {
		($stemspec, $vspec, $flavorspec) = ($`, '*', $');
	# okay, so no version marker. Assume no flavor spec.
	} else {
		($stemspec, $vspec, $flavorspec) = ($p, '', '');
	}

	$stemspec =~ s/\./\\\./g;
	$stemspec =~ s/\+/\\\+/g;
	$stemspec =~ s/\*/\.\*/g;
	$stemspec =~ s/\?/\./g;
	$vspec =~ s/\./\\\./g;
	$vspec =~ s/\+/\\\+/g;
	$vspec =~ s/\*/\.\*/g;
	$vspec =~ s/\?/\./g;

	$p = $stemspec;
	$p.="-.*" if $vspec ne '';

	# First trim down the list
	my @@l = grep {/^$p$/} @@$list;

	my @@result = ();
	# Now, have to extract the version number, and the flavor...
	for (@@l) {
		my ($stem, $v, $flavor);
		if (m/\-(\d[^-]*)/) {
			($stem, $v, $flavor) = ($`, $1, $');
			if ($stem =~ m/^$stemspec$/ &&
			    check_version($v, $vspec) &&
			    check_flavor($flavor, $flavorspec)) {
			    	push(@@result, $_);
			}
	    	}
	}
		
	return @@result;
}

sub pkgspec_match
{
	my ($pattern, @@list) = @@_;
	my @@l = ();

	for my $subpattern (split /\|/, $pattern) {
		push(@@l, subpattern_match($subpattern, \@@list));
	}
	return @@l;
@


1.4
log
@move wildcard rewriting down. Allows flavors in package-specs to
properly contain a dot and other fun characters.

Reported by Jason Ish. Survives a full ports build.
@
text
@d1 2
a2 1
# $OpenBSD: PackageName.pm,v 1.3 2003/11/06 17:47:25 espie Exp $
d4 13
a16 22
# Copyright (c) 2003 Marc Espie.
# 
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
# 
# THIS SOFTWARE IS PROVIDED BY THE OPENBSD PROJECT AND CONTRIBUTORS
# ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
# A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OPENBSD
# PROJECT OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
@


1.3
log
@url2pkgname as an explicit function
@
text
@d1 1
a1 1
# $OpenBSD: PackageName.pm,v 1.2 2003/10/19 18:41:32 espie Exp $
a225 5
	# first, handle special characters (shell -> perl)
	$p =~ s/\./\\\./g;
	$p =~ s/\+/\\\+/g;
	$p =~ s/\*/\.\*/g;
	$p =~ s/\?/\./g;
d236 2
a237 2
	} elsif ($p =~ m/\-(\.\*)/) {
		($stemspec, $vspec, $flavorspec) = ($`, $1, $');
d243 11
a253 1
	$p = "$stemspec-\.\*" if $vspec ne '';
@


1.2
log
@Add is_stem/find_stem
@
text
@d1 1
a1 1
# $OpenBSD: PackageName.pm,v 1.1.1.1 2003/10/16 17:43:34 espie Exp $
d30 9
d44 2
a45 3
	$name =~ s|.*/||;
	$name =~ s|\.tgz||;
	$self->{pkgname} = $name;
d47 1
a47 1
	my @@list = splitname($name);
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
# $OpenBSD: PackageName.pm,v 1.1.1.1 2003/10/16 17:16:30 espie Exp $
d59 23
@


1.1.1.1
log
@new import of my pkgtools, after a slight naming disagreement with the
Upper Management...
@
text
@@
