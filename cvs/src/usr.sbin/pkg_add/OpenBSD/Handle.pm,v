head	1.42;
access;
symbols
	OPENBSD_6_1:1.42.0.2
	OPENBSD_6_1_BASE:1.42
	OPENBSD_6_0:1.39.0.14
	OPENBSD_6_0_BASE:1.39
	OPENBSD_5_9:1.39.0.8
	OPENBSD_5_9_BASE:1.39
	OPENBSD_5_8:1.39.0.10
	OPENBSD_5_8_BASE:1.39
	OPENBSD_5_7:1.39.0.2
	OPENBSD_5_7_BASE:1.39
	OPENBSD_5_6:1.39.0.6
	OPENBSD_5_6_BASE:1.39
	OPENBSD_5_5:1.39.0.4
	OPENBSD_5_5_BASE:1.39
	OPENBSD_5_4:1.30.0.6
	OPENBSD_5_4_BASE:1.30
	OPENBSD_5_3:1.30.0.4
	OPENBSD_5_3_BASE:1.30
	OPENBSD_5_2:1.30.0.2
	OPENBSD_5_2_BASE:1.30
	OPENBSD_5_1_BASE:1.29
	OPENBSD_5_1:1.29.0.2
	OPENBSD_5_0:1.28.0.2
	OPENBSD_5_0_BASE:1.28
	OPENBSD_4_9:1.27.0.2
	OPENBSD_4_9_BASE:1.27
	OPENBSD_4_8:1.25.0.2
	OPENBSD_4_8_BASE:1.25
	OPENBSD_4_7:1.17.0.2
	OPENBSD_4_7_BASE:1.17;
locks; strict;
comment	@# @;


1.42
date	2017.03.07.16.21.28;	author espie;	state Exp;
branches;
next	1.41;
commitid	J3ao0H3I5Bp276ES;

1.41
date	2017.03.07.14.35.40;	author espie;	state Exp;
branches;
next	1.40;
commitid	Nu0K2kdk0tu6TXHG;

1.40
date	2017.03.07.14.20.01;	author espie;	state Exp;
branches;
next	1.39;
commitid	ro3Wdya2TUayzhKE;

1.39
date	2014.02.08.16.11.02;	author espie;	state Exp;
branches;
next	1.38;

1.38
date	2014.02.06.16.55.01;	author espie;	state Exp;
branches;
next	1.37;

1.37
date	2014.02.04.00.14.27;	author espie;	state Exp;
branches;
next	1.36;

1.36
date	2014.02.03.13.47.20;	author espie;	state Exp;
branches;
next	1.35;

1.35
date	2014.02.03.13.28.43;	author espie;	state Exp;
branches;
next	1.34;

1.34
date	2014.02.02.15.22.36;	author espie;	state Exp;
branches;
next	1.33;

1.33
date	2014.02.01.10.54.11;	author espie;	state Exp;
branches;
next	1.32;

1.32
date	2014.01.30.13.18.34;	author espie;	state Exp;
branches;
next	1.31;

1.31
date	2013.12.08.12.14.41;	author espie;	state Exp;
branches;
next	1.30;

1.30
date	2012.04.28.11.53.53;	author espie;	state Exp;
branches;
next	1.29;

1.29
date	2011.08.26.08.46.09;	author espie;	state Exp;
branches;
next	1.28;

1.28
date	2011.07.12.10.30.29;	author espie;	state Exp;
branches;
next	1.27;

1.27
date	2010.12.24.09.04.14;	author espie;	state Exp;
branches;
next	1.26;

1.26
date	2010.10.27.14.35.56;	author espie;	state Exp;
branches;
next	1.25;

1.25
date	2010.08.12.20.36.13;	author espie;	state Exp;
branches;
next	1.24;

1.24
date	2010.07.31.11.17.22;	author espie;	state Exp;
branches;
next	1.23;

1.23
date	2010.06.30.10.51.04;	author espie;	state Exp;
branches;
next	1.22;

1.22
date	2010.06.30.10.41.42;	author espie;	state Exp;
branches;
next	1.21;

1.21
date	2010.06.30.10.33.09;	author espie;	state Exp;
branches;
next	1.20;

1.20
date	2010.06.09.07.26.01;	author espie;	state Exp;
branches;
next	1.19;

1.19
date	2010.05.10.09.17.55;	author espie;	state Exp;
branches;
next	1.18;

1.18
date	2010.03.20.09.55.05;	author espie;	state Exp;
branches;
next	1.17;

1.17
date	2009.12.31.13.48.52;	author espie;	state Exp;
branches;
next	1.16;

1.16
date	2009.12.31.12.38.19;	author espie;	state Exp;
branches;
next	1.15;

1.15
date	2009.12.30.10.02.52;	author espie;	state Exp;
branches;
next	1.14;

1.14
date	2009.12.29.13.58.18;	author espie;	state Exp;
branches;
next	1.13;

1.13
date	2009.12.20.22.38.45;	author espie;	state Exp;
branches;
next	1.12;

1.12
date	2009.11.28.12.50.25;	author espie;	state Exp;
branches;
next	1.11;

1.11
date	2009.11.11.12.04.19;	author espie;	state Exp;
branches;
next	1.10;

1.10
date	2009.11.10.11.36.56;	author espie;	state Exp;
branches;
next	1.9;

1.9
date	2009.11.08.12.16.23;	author espie;	state Exp;
branches;
next	1.8;

1.8
date	2009.11.08.11.31.37;	author espie;	state Exp;
branches;
next	1.7;

1.7
date	2009.11.08.11.18.41;	author espie;	state Exp;
branches;
next	1.6;

1.6
date	2009.10.19.14.00.10;	author espie;	state Exp;
branches;
next	1.5;

1.5
date	2009.10.19.09.29.53;	author espie;	state Exp;
branches;
next	1.4;

1.4
date	2009.10.15.23.22.55;	author espie;	state Exp;
branches;
next	1.3;

1.3
date	2009.10.15.11.18.48;	author espie;	state Exp;
branches;
next	1.2;

1.2
date	2009.10.15.10.45.47;	author espie;	state Exp;
branches;
next	1.1;

1.1
date	2009.10.14.22.59.34;	author espie;	state Exp;
branches;
next	;


desc
@@


1.42
log
@okay "can't find" means error reported as well
@
text
@# ex:ts=8 sw=4:
# $OpenBSD: Handle.pm,v 1.41 2017/03/07 14:35:40 espie Exp $
#
# Copyright (c) 2007-2009 Marc Espie <espie@@openbsd.org>
#
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

# fairly non-descriptive name. Used to store various package information
# during installs and updates.

use strict;
use warnings;

package OpenBSD::Handle;

use OpenBSD::PackageInfo;
use OpenBSD::Error;

use constant {
	BAD_PACKAGE => 1,
	CANT_INSTALL => 2,
	ALREADY_INSTALLED => 3,
	NOT_FOUND => 4,
	CANT_DELETE => 5,
};

sub is_real { return 1; }

sub cleanup
{
	my ($self, $error, $errorinfo) = @@_;
	if (defined $error) {
		$self->{error} //= $error;
		$self->{errorinfo} //= $errorinfo;
	}
	if (defined $self->location) {
		if (defined $self->{error} && $self->{error} == BAD_PACKAGE) {
			$self->location->close_with_client_error;
		} else {
			$self->location->close_now;
		}
		$self->location->wipe_info;
	}
	delete $self->{plist};
	delete $self->{db};
	delete $self->{conflict_list};
}

sub new
{
	my $class = shift;
	return bless {}, $class;
}

sub system
{
	my $class = shift;
	return OpenBSD::Handle::BaseSystem->new;
}

sub pkgname
{
	my $self = shift;
	if (!defined $self->{pkgname}) {
		if (defined $self->{plist}) {
			$self->{pkgname} = $self->{plist}->pkgname;
		} elsif (defined $self->{location}) {
			$self->{pkgname} = $self->{location}->name;
		} elsif (defined $self->{name}) {
			require OpenBSD::PackageName;

			$self->{pkgname} =
			    OpenBSD::PackageName::url2pkgname($self->{name});
		}
	}

	return $self->{pkgname};
}

sub location
{
	return shift->{location};
}

sub plist
{
	return shift->{plist};
}

sub dependency_info
{
	my $self = shift;
	if (defined $self->{plist}) {
		return $self->{plist};
	} elsif (defined $self->{location} && 
	    defined $self->{location}{update_info}) {
		return $self->{location}{update_info};
	} else {
		return undef;
	}
}

OpenBSD::Auto::cache(conflict_list,
    sub {
    	require OpenBSD::PkgCfl;
	return OpenBSD::PkgCfl->make_conflict_list(shift->dependency_info);
    });

sub set_error
{
	my ($self, $error) = @@_;
	$self->{error} = $error;
}

sub has_error
{
	my ($self, $error) = @@_;
	if (!defined $self->{error}) {
		return undef;
	}
	if (defined $error) {
		return $self->{error} eq $error;
	}
	return $self->{error};
}

sub has_reported_error
{
	my $self = shift;
	return $self->{error_reported};
}

sub error_message
{
	my $self = shift;
	my $error = $self->{error};
	if ($error == BAD_PACKAGE) {
		return "bad package";
	} elsif ($error == CANT_INSTALL) {
		if ($self->{errorinfo}) {
			return "$self->{errorinfo}";
		} else {
			return "can't install";
		}
	} elsif ($error == NOT_FOUND) {
		return "not found";
	} elsif ($error == ALREADY_INSTALLED) {
		return "already installed";
	} else {
		return "no error";
	}
}

sub complete_old
{
	my $self = shift;
	my $location = $self->{location};

	if (!defined $location) {
		$self->set_error(NOT_FOUND);
    	} else {
		my $plist = $location->plist;
		if (!defined $plist) {
			$self->set_error(BAD_PACKAGE);
		} else {
			$self->{plist} = $plist;
			delete $location->{contents};
			delete $location->{update_info};
		}
	}
}

sub complete_dependency_info
{
	my $self = shift;
	my $location = $self->{location};

	if (!defined $location) {
		$self->set_error(NOT_FOUND);
	} else {
		if (!defined $self->{plist}) {
			# trigger build
			$location->update_info;
		}
	}
}

sub create_old
{

	my ($class, $pkgname, $state) = @@_;
	my $self= $class->new;
	$self->{name} = $pkgname;

	my $location = $state->repo->installed->find($pkgname);
	if (defined $location) {
		$self->{location} = $location;
	}
	$self->complete_dependency_info;

	return $self;
}

sub create_new
{
	my ($class, $pkg) = @@_;
	my $handle = $class->new;
	$handle->{name} = $pkg;
	$handle->{tweaked} = 0;
	return $handle;
}

sub from_location
{
	my ($class, $location) = @@_;
	my $handle = $class->new;
	$handle->{location} = $location;
	$handle->{tweaked} = 0;
	return $handle;
}

sub get_plist
{
	my ($handle, $state) = @@_;

	my $location = $handle->{location};
	my $pkg = $handle->pkgname;

	if ($state->verbose >= 2) {
		$state->say("#1parsing #2", $state->deptree_header($pkg), $pkg);
	}
	my $plist = $location->plist;
	unless (defined $plist) {
		$state->say("Can't find CONTENTS from #1", $location->url)
		    unless $location->{error_reported};
		$location->close_with_client_error;
		$location->wipe_info;
		$handle->set_error(BAD_PACKAGE);
		$handle->{error_reported} = 1;
		return;
	}
	delete $location->{update_info};
	unless ($plist->has('url')) {
		OpenBSD::PackingElement::Url->add($plist, $location->url);
	}
	if ($plist->localbase ne $state->{localbase}) {
		$state->say("Localbase mismatch: package has: #1, user wants: #2",
		    $plist->localbase, $state->{localbase});
		$location->close_with_client_error;
		$location->wipe_info;
		$handle->set_error(BAD_PACKAGE);
		return;
	}
	my $pkgname = $handle->{pkgname} = $plist->pkgname;

	if ($pkg ne '-') {
		if (!defined $pkgname or $pkg ne $pkgname) {
			$state->say("Package name is not consistent ???");
			$location->close_with_client_error;
			$location->wipe_info;
			$handle->set_error(BAD_PACKAGE);
			return;
		}
	}
	$handle->{plist} = $plist;
}

sub get_location
{
	my ($handle, $state) = @@_;

	my $name = $handle->{name};

	my $location = $state->repo->find($name);
	if (!$location) {
		$state->print("#1", $state->deptree_header($name));
		$handle->set_error(NOT_FOUND);
		$handle->{tweaked} =
		    OpenBSD::Add::tweak_package_status($handle->pkgname,
			$state);
		if (!$handle->{tweaked}) {
			$state->say("Can't find #1", $name);
			$handle->{error_reported} = 1;
			eval {
				my $r = [$name];
				$state->quirks->filter_obsolete($r, $state);
			}
		}
		return;
	}
	$handle->{location} = $location;
	$handle->{pkgname} = $location->name;
}

sub complete
{
	my ($handle, $state) = @@_;

	return if $handle->has_error;

	if (!defined $handle->{location}) {
		$handle->get_location($state);
	}
	return if $handle->has_error;
	if (!defined $handle->{plist}) {
		$handle->get_plist($state);
	}
}

package OpenBSD::Handle::BaseSystem;
our @@ISA = qw(OpenBSD::Handle);
sub pkgname { return "BaseSystem"; }

sub is_real { return 0; }

1;
@


1.41
log
@if we reported "Can't find CONTENTS", we know it's a bad package,
so no need to say it again
@
text
@d2 1
a2 1
# $OpenBSD: Handle.pm,v 1.40 2017/03/07 14:20:01 espie Exp $
d293 1
@


1.40
log
@get rid of redundant "Can't find CONTENTS" if the location already twitted
@
text
@d2 1
a2 1
# $OpenBSD: Handle.pm,v 1.39 2014/02/08 16:11:02 espie Exp $
d137 6
d249 1
@


1.39
log
@scrape update_info when we have full plists.
@
text
@d2 1
a2 1
# $OpenBSD: Handle.pm,v 1.38 2014/02/06 16:55:01 espie Exp $
d238 2
a239 1
		$state->say("Can't find CONTENTS from #1", $location->url);
@


1.38
log
@don't store full directory objects if they're not "special", just knowing
there's a directory that should stay around is enough.
shaves on the number of shared directories for shared items quite a lot.
@
text
@d2 1
a2 1
# $OpenBSD: Handle.pm,v 1.37 2014/02/04 00:14:27 espie Exp $
d172 1
d244 1
@


1.37
log
@check for errors before dependencies, anyways.
split the part for arch, since it requires full plists.
avoid creating dummy locations for handles in errors.
@
text
@d2 1
a2 1
# $OpenBSD: Handle.pm,v 1.36 2014/02/03 13:47:20 espie Exp $
d55 1
@


1.36
log
@remove extra cache copy in memory...
to be revisited, the setting of info dir so late is slightly broken and
will reopen packages more times than needed.
@
text
@d2 1
a2 1
# $OpenBSD: Handle.pm,v 1.35 2014/02/03 13:28:43 espie Exp $
d104 2
a105 1
	} elsif (defined $self->{location}{update_info}) {
@


1.35
log
@zap duplicate test, spotted by Arto Jonsson
@
text
@d2 1
a2 1
# $OpenBSD: Handle.pm,v 1.34 2014/02/02 15:22:36 espie Exp $
d169 1
@


1.34
log
@simplify how "kept" packages are handled. First, we never need their
full plist, just their update_info. Also, the routine for move_kept is
pretty much always the same, so fold it.

Finally, delay full plists in create_old.
@
text
@d2 1
a2 1
# $OpenBSD: Handle.pm,v 1.33 2014/02/01 10:54:11 espie Exp $
a177 3
	if (!defined $location) {
		$self->set_error(NOT_FOUND);
    	}
@


1.33
log
@handles are more adequate places to stash conflict lists, since they can
be computed directly from update_info (without the full plist)
@
text
@d2 1
a2 1
# $OpenBSD: Handle.pm,v 1.32 2014/01/30 13:18:34 espie Exp $
d173 18
d202 1
a202 1
	$self->complete_old;
@


1.32
log
@don't save empty errors
@
text
@d2 1
a2 1
# $OpenBSD: Handle.pm,v 1.31 2013/12/08 12:14:41 espie Exp $
d27 1
d55 1
d98 18
@


1.31
log
@also cover initial installations (which means we do try to install
quirks even for initial installations)
@
text
@d2 1
a2 1
# $OpenBSD: Handle.pm,v 1.30 2012/04/28 11:53:53 espie Exp $
d41 4
a44 2
	$self->{error} //= $error;
	$self->{errorinfo} //= $errorinfo;
@


1.30
log
@add a "fake" handle class for base system updates and ForwardDependencies
@
text
@d2 1
a2 1
# $OpenBSD$
d243 4
@


1.29
log
@zap fatpackages. nobody actually uses them.
accordingly, locations do not need to track architecture.
@
text
@d2 1
a2 1
# $OpenBSD: Handle.pm,v 1.28 2011/07/12 10:30:29 espie Exp $
d36 2
d60 6
d264 6
@


1.28
log
@new pkg_delete, very similar to pkg_add, support for -a
@
text
@d2 1
a2 1
# $OpenBSD: Handle.pm,v 1.27 2010/12/24 09:04:14 espie Exp $
d150 1
a150 1
	my $location = $state->repo->installed->find($pkgname, $state->{arch});
d226 1
a226 1
	my $location = $state->repo->find($name, $state->{arch});
@


1.27
log
@handle failures from ports tree with more care.
this does avoid infinite loops in case of wrong plists.
necessary since print-plist-with-depends CAN fail...
@
text
@d2 1
a2 1
# $OpenBSD$
d32 2
a33 1
	NOT_FOUND => 4
@


1.26
log
@initial scaffolding for @@rcscript: for now, acts like normal files,
but allow absolute pathnames (treat that as an implicit @@cwd).
@
text
@@


1.25
log
@if we ask for cleanup, always close the location. If it's not open, it's
harmless. This prevents processes from piling up on !network addition of
already existing packages...
(fixes THAT bug)
@
text
@d2 1
a2 1
# $OpenBSD: Handle.pm,v 1.24 2010/07/31 11:17:22 espie Exp $
@


1.24
log
@keep location open while we grab updateinfo.
deal with error fallout and need to forget unneeded stuff
(halves number of connections, roughly)
@
text
@d2 1
a2 1
# $OpenBSD: Handle.pm,v 1.23 2010/06/30 10:51:04 espie Exp $
d41 4
a44 6
		if (defined $self->{error}) {
			if ($self->{error} == BAD_PACKAGE) {
				$self->location->close_with_client_error;
			} else {
				$self->location->close_now;
			}
@


1.23
log
@allow say and errsay to work without parameters, as it's ways common.
create verbose_system up in state, because it makes sense without verbose.
@
text
@d2 1
a2 1
# $OpenBSD$
d41 6
a46 6
		if (defined $self->{error} &&
		    $self->{error} == ALREADY_INSTALLED) {
			$self->location->close_now;
		} elsif (defined $self->{error} &&
		    $self->{error} == CANT_INSTALL) {
			$self->location->close_with_client_error;
d188 1
a188 1
	my $plist = $location->grabPlist;
@


1.22
log
@whitespace cleanup
@
text
@@


1.21
log
@simple use of new state->repo API
@
text
@d2 1
a2 1
# $OpenBSD: Handle.pm,v 1.20 2010/06/09 07:26:01 espie Exp $
d200 1
a200 1
		$state->say("Localbase mismatch: package has: #1, user wants: #2", 
@


1.20
log
@ui changes: go thru a state object for most printouts
@
text
@d2 1
a2 1
# $OpenBSD: Handle.pm,v 1.19 2010/05/10 09:17:55 espie Exp $
d151 1
a151 3
	require OpenBSD::PackageRepository::Installed;

	my $location = OpenBSD::PackageRepository::Installed->new->find($pkgname, $state->{arch});
d227 1
a227 1
	my $location = OpenBSD::PackageLocator->find($name, $state->{arch});
@


1.19
log
@whitespace fixes
@
text
@d2 1
a2 1
# $OpenBSD$
d188 1
a188 1
		$state->say($state->deptree_header($pkg), "parsing $pkg");
d192 1
a192 1
		$state->say("Can't find CONTENTS from ", $location->url);
d202 2
a203 1
		$state->say("Localbase mismatch: package has: ", $plist->localbase, " , user wants: ", $state->{localbase});
d231 1
a231 1
		$state->print($state->deptree_header($name));
d237 1
a237 1
			$state->say("Can't find $name");
@


1.18
log
@if a package already contains an url marker (say, local stuff recreated),
don't override it. so that it can actually be installed.
@
text
@d70 1
a70 1
			$self->{pkgname} = 
d232 2
a233 2
		$handle->{tweaked} = 
		    OpenBSD::Add::tweak_package_status($handle->pkgname, 
@


1.17
log
@fix for error message logging.
@
text
@d198 3
a200 1
	OpenBSD::PackingElement::Url->add($plist, $location->url);
@


1.16
log
@add meat to the "can't install" stupid handle message
@
text
@d114 1
a114 1
			return "can't install: $self->{errorinfo}";
@


1.15
log
@store url where we retrieved the package.
@
text
@d37 1
a37 1
	my ($self, $error) = @@_;
d39 1
d113 5
a117 1
		return "can't install";
@


1.14
log
@move check for already installed UP, which allows me to deal with UpdateSet
and tracker globally to avoid loops.
@
text
@d193 1
@


1.13
log
@change verbosity handling: be silent by default, turn on the first level if -v.
Add more levels, specifically, lots of info regarding individual files only
visible if -vvvvv.
Make -n display the same stuff as normal (need -n -v to display more stuff).
Introduce -s, "size-only", turns on -n and does skip any extraction.
Sprinkle handlers for SIG_INFO, not really nice yet.

Note that -n is non functional for complex updates, because of caching
issues I have to fix.
@
text
@a201 15
	if (is_installed($pkgname) && 
	    (!$state->{allow_replacing} ||	
	      !$state->{defines}->{installed} &&
	      !$plist->has_new_sig($state) && 
	      !$plist->uses_old_libs)) {
		$handle->{tweaked} = 
		    OpenBSD::Add::tweak_package_status($pkgname, $state);
		$state->say("Not reinstalling $pkgname")
		    if $state->verbose >= 2 and !$handle->{tweaked};
		$state->tracker->{installed}->{$pkgname} = 1;
		$location->close_now;
		$location->wipe_info;
		$handle->set_error(ALREADY_INSTALLED);
		return;
	}
@


1.12
log
@when resolving conflicts, don't recreate handles for packages being replaced
if we already know they're being replaced.
This requires completing them with a plist.
(some cleanup of api to do later)
@
text
@d182 1
a182 1
	if ($state->{verbose}) {
d210 1
a210 1
		    if $state->{verbose} and !$handle->{tweaked};
@


1.11
log
@progressmeter puts STDOUT in autoflush if -t, so that it can display to it instead of piping a lot of stuff to STDERR.

Go through state->print for most messages, so they will NOT do weird things
with the progressmeter.
Use a ->say shortcut which does the same thing that perl 5.10 say does...
@
text
@d122 17
d149 1
a149 3
	if (!defined $location) {
		$self->set_error(NOT_FOUND);
    	} else {
a150 6
		my $plist = $location->plist;
		if (!defined $plist) {
			$self->set_error(BAD_PACKAGE);
		} else {
			$self->{plist} = $plist;
		}
d152 1
@


1.10
log
@bad espie: use strict/warnings consistently, and fix two nits and two
actual errors !
@
text
@d173 1
a173 2
		print $state->deptree_header($pkg);
		print "parsing $pkg\n";
d177 1
a177 1
		print "Can't find CONTENTS from ", $location->url, "\n";
d184 1
a184 1
		print "Localbase mismatch: package has: ", $plist->localbase, " , user wants: ", $state->{localbase}, "\n";
d199 2
a200 2
		print "Not reinstalling $pkgname\n" if $state->{verbose} and
		    !$handle->{tweaked};
d209 1
a209 1
			print "Package name is not consistent ???\n";
d227 1
a227 1
		print $state->deptree_header($name);
d233 1
a233 1
			print "Can't find $name\n";
@


1.9
log
@let Handle display what went wrong.
Move stuff from being a fatal error to an error that displays at end, together
with an error code.
@
text
@a17 1

d20 4
d40 2
a41 1
		if ($self->{error} == ALREADY_INSTALLED) {
d43 2
a44 1
		} elsif ($self->{error} == CANT_INSTALL) {
@


1.8
log
@bug-fix: if we can't find the package, it makes no sense to look in a
non-existent location...
@
text
@d100 17
@


1.7
log
@tracker/updater methods for state that auto-create the object.
@
text
@d229 1
@


1.6
log
@cleanup method that does more or less what's needed
@
text
@d180 1
a180 1
		$state->{tracker}->{installed}->{$pkgname} = 1;
@


1.5
log
@syntactic sugar: methods to access plist and location from handle.
@
text
@d32 15
@


1.4
log
@missed one, tell tracker this is already installed
@
text
@d2 1
a2 1
# $OpenBSD: Handle.pm,v 1.3 2009/10/15 11:18:48 espie Exp $
d55 10
@


1.3
log
@reorg code
@
text
@d2 1
a2 1
# $OpenBSD: Handle.pm,v 1.2 2009/10/15 10:45:47 espie Exp $
d155 1
a155 1
		$state->mark_installed($pkgname);
@


1.2
log
@let handle compute pkgnames correctly, simplifies code a bit
@
text
@d2 1
a2 1
# $OpenBSD: Handle.pm,v 1.1 2009/10/14 22:59:34 espie Exp $
d173 22
a200 1

d202 1
a202 17
		my $name = $handle->{name};

		my $location = OpenBSD::PackageLocator->find($name, 
		    $state->{arch});
		if (!$location) {
			print $state->deptree_header($name);
			$handle->set_error(NOT_FOUND);
			$handle->{tweaked} = 
			    OpenBSD::Add::tweak_package_status($handle->pkgname, 
				$state);
			if (!$handle->{tweaked}) {
				print "Can't find $name\n";
			}
			return;
		}
		$handle->{location} = $location;
		$handle->{pkgname} = $location->name;
@


1.1
log
@move OpenBSD::Handle into its own file. I guess I need to disentangle this
code before I go further....
@
text
@d2 1
a2 1
# $OpenBSD$
d38 19
d80 1
a80 1
	$self->{pkgname} = $pkgname;
d96 1
d104 1
a104 1
	$handle->{pkgname} = $pkg;
a112 1
	$handle->{pkgname} = $location->name;
d123 1
a123 1
	my $pkg = $handle->{pkgname};
d162 1
a162 2
		if (!defined $pkgname or 
		    OpenBSD::PackageName::url2pkgname($pkg) ne $pkgname) {
a178 1
	my $pkgname = $handle->{pkgname};
d181 3
a183 1
		my $location = OpenBSD::PackageLocator->find($pkgname, 
d186 1
a186 1
			print $state->deptree_header($pkgname);
d189 1
a189 1
			    OpenBSD::Add::tweak_package_status($pkgname, 
d192 1
a192 1
				print "Can't find $pkgname\n";
d197 1
d203 1
@

