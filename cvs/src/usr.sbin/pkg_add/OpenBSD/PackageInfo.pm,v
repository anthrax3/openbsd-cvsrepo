head	1.60;
access;
symbols
	OPENBSD_6_2:1.60.0.12
	OPENBSD_6_2_BASE:1.60
	OPENBSD_6_1:1.60.0.16
	OPENBSD_6_1_BASE:1.60
	OPENBSD_6_0:1.60.0.14
	OPENBSD_6_0_BASE:1.60
	OPENBSD_5_9:1.60.0.8
	OPENBSD_5_9_BASE:1.60
	OPENBSD_5_8:1.60.0.10
	OPENBSD_5_8_BASE:1.60
	OPENBSD_5_7:1.60.0.2
	OPENBSD_5_7_BASE:1.60
	OPENBSD_5_6:1.60.0.6
	OPENBSD_5_6_BASE:1.60
	OPENBSD_5_5:1.60.0.4
	OPENBSD_5_5_BASE:1.60
	OPENBSD_5_4:1.56.0.8
	OPENBSD_5_4_BASE:1.56
	OPENBSD_5_3:1.56.0.6
	OPENBSD_5_3_BASE:1.56
	OPENBSD_5_2:1.56.0.4
	OPENBSD_5_2_BASE:1.56
	OPENBSD_5_1_BASE:1.56
	OPENBSD_5_1:1.56.0.2
	OPENBSD_5_0:1.54.0.2
	OPENBSD_5_0_BASE:1.54
	OPENBSD_4_9:1.53.0.2
	OPENBSD_4_9_BASE:1.53
	OPENBSD_4_8:1.50.0.2
	OPENBSD_4_8_BASE:1.50
	OPENBSD_4_7:1.44.0.2
	OPENBSD_4_7_BASE:1.44
	OPENBSD_4_6:1.39.0.4
	OPENBSD_4_6_BASE:1.39
	OPENBSD_4_5:1.38.0.4
	OPENBSD_4_5_BASE:1.38
	OPENBSD_4_4:1.38.0.2
	OPENBSD_4_4_BASE:1.38
	OPENBSD_4_3:1.36.0.2
	OPENBSD_4_3_BASE:1.36
	OPENBSD_4_2:1.35.0.2
	OPENBSD_4_2_BASE:1.35
	OPENBSD_4_1:1.20.0.2
	OPENBSD_4_1_BASE:1.20
	OPENBSD_4_0:1.18.0.4
	OPENBSD_4_0_BASE:1.18
	OPENBSD_3_9:1.18.0.2
	OPENBSD_3_9_BASE:1.18
	OPENBSD_3_8:1.17.0.4
	OPENBSD_3_8_BASE:1.17
	OPENBSD_3_7:1.17.0.2
	OPENBSD_3_7_BASE:1.17
	OPENBSD_3_6:1.7.0.2
	OPENBSD_3_6_BASE:1.7
	OPENBSD_3_5:1.6.0.2
	OPENBSD_3_5_BASE:1.6
	pkgtools:1.1.1.1
	espie:1.1.1;
locks; strict;
comment	@# @;


1.60
date	2014.01.11.11.51.01;	author espie;	state Exp;
branches;
next	1.59;

1.59
date	2014.01.09.20.20.01;	author espie;	state Exp;
branches;
next	1.58;

1.58
date	2014.01.07.13.52.43;	author espie;	state Exp;
branches;
next	1.57;

1.57
date	2014.01.07.13.37.23;	author espie;	state Exp;
branches;
next	1.56;

1.56
date	2011.08.23.10.32.27;	author espie;	state Exp;
branches;
next	1.55;

1.55
date	2011.08.18.07.53.59;	author espie;	state Exp;
branches;
next	1.54;

1.54
date	2011.07.12.10.30.29;	author espie;	state Exp;
branches;
next	1.53;

1.53
date	2010.12.29.13.03.05;	author espie;	state Exp;
branches;
next	1.52;

1.52
date	2010.12.24.09.04.14;	author espie;	state Exp;
branches;
next	1.51;

1.51
date	2010.10.27.14.35.56;	author espie;	state Exp;
branches;
next	1.50;

1.50
date	2010.06.30.10.51.04;	author espie;	state Exp;
branches;
next	1.49;

1.49
date	2010.06.30.10.41.42;	author espie;	state Exp;
branches;
next	1.48;

1.48
date	2010.06.30.10.33.09;	author espie;	state Exp;
branches;
next	1.47;

1.47
date	2010.06.09.07.26.01;	author espie;	state Exp;
branches;
next	1.46;

1.46
date	2010.06.04.13.19.39;	author espie;	state Exp;
branches;
next	1.45;

1.45
date	2010.05.10.09.17.55;	author espie;	state Exp;
branches;
next	1.44;

1.44
date	2009.11.15.09.53.52;	author espie;	state Exp;
branches;
next	1.43;

1.43
date	2009.11.11.12.04.19;	author espie;	state Exp;
branches;
next	1.42;

1.42
date	2009.11.11.11.18.24;	author espie;	state Exp;
branches;
next	1.41;

1.41
date	2009.11.10.11.36.56;	author espie;	state Exp;
branches;
next	1.40;

1.40
date	2009.11.10.11.10.52;	author espie;	state Exp;
branches;
next	1.39;

1.39
date	2009.06.04.18.59.28;	author wcmaier;	state Exp;
branches;
next	1.38;

1.38
date	2008.06.15.08.23.50;	author espie;	state Exp;
branches;
next	1.37;

1.37
date	2008.03.08.12.07.45;	author espie;	state Exp;
branches;
next	1.36;

1.36
date	2008.01.12.14.02.32;	author espie;	state Exp;
branches;
next	1.35;

1.35
date	2007.06.16.09.29.37;	author espie;	state Exp;
branches;
next	1.34;

1.34
date	2007.06.09.11.16.54;	author espie;	state Exp;
branches;
next	1.33;

1.33
date	2007.06.04.14.40.39;	author espie;	state Exp;
branches;
next	1.32;

1.32
date	2007.06.01.14.58.29;	author espie;	state Exp;
branches;
next	1.31;

1.31
date	2007.05.31.13.11.21;	author espie;	state Exp;
branches;
next	1.30;

1.30
date	2007.05.30.16.32.14;	author espie;	state Exp;
branches;
next	1.29;

1.29
date	2007.05.18.12.40.35;	author espie;	state Exp;
branches;
next	1.28;

1.28
date	2007.05.15.08.00.59;	author espie;	state Exp;
branches;
next	1.27;

1.27
date	2007.05.14.10.53.31;	author espie;	state Exp;
branches;
next	1.26;

1.26
date	2007.05.14.10.00.08;	author espie;	state Exp;
branches;
next	1.25;

1.25
date	2007.05.14.09.49.27;	author espie;	state Exp;
branches;
next	1.24;

1.24
date	2007.05.13.13.32.36;	author espie;	state Exp;
branches;
next	1.23;

1.23
date	2007.05.07.14.33.30;	author espie;	state Exp;
branches;
next	1.22;

1.22
date	2007.04.15.10.17.29;	author espie;	state Exp;
branches;
next	1.21;

1.21
date	2007.03.18.10.57.12;	author espie;	state Exp;
branches;
next	1.20;

1.20
date	2007.02.22.21.31.41;	author espie;	state Exp;
branches;
next	1.19;

1.19
date	2007.02.17.10.39.35;	author sturm;	state Exp;
branches;
next	1.18;

1.18
date	2005.09.04.22.47.56;	author espie;	state Exp;
branches;
next	1.17;

1.17
date	2005.01.16.11.16.23;	author espie;	state Exp;
branches;
next	1.16;

1.16
date	2005.01.14.02.25.12;	author espie;	state Exp;
branches;
next	1.15;

1.15
date	2004.12.27.22.16.13;	author espie;	state Exp;
branches;
next	1.14;

1.14
date	2004.12.16.11.07.33;	author espie;	state Exp;
branches;
next	1.13;

1.13
date	2004.11.14.19.10.41;	author espie;	state Exp;
branches;
next	1.12;

1.12
date	2004.11.14.11.40.08;	author espie;	state Exp;
branches;
next	1.11;

1.11
date	2004.11.11.11.54.09;	author espie;	state Exp;
branches;
next	1.10;

1.10
date	2004.11.11.11.16.39;	author espie;	state Exp;
branches;
next	1.9;

1.9
date	2004.10.11.10.30.34;	author espie;	state Exp;
branches;
next	1.8;

1.8
date	2004.10.11.10.07.37;	author espie;	state Exp;
branches;
next	1.7;

1.7
date	2004.08.06.07.51.17;	author espie;	state Exp;
branches;
next	1.6;

1.6
date	2004.02.21.19.15.40;	author espie;	state Exp;
branches;
next	1.5;

1.5
date	2004.01.27.00.14.42;	author espie;	state Exp;
branches;
next	1.4;

1.4
date	2003.12.09.19.22.36;	author espie;	state Exp;
branches;
next	1.3;

1.3
date	2003.11.06.18.16.25;	author espie;	state Exp;
branches;
next	1.2;

1.2
date	2003.11.06.17.49.31;	author espie;	state Exp;
branches;
next	1.1;

1.1
date	2003.10.16.17.43.34;	author espie;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2003.10.16.17.43.34;	author espie;	state Exp;
branches;
next	;


desc
@@


1.60
log
@a bit of spring cleanup in advance: scrape old stuff that's not really
used.
@
text
@# ex:ts=8 sw=4:
# $OpenBSD: PackageInfo.pm,v 1.59 2014/01/09 20:20:01 espie Exp $
#
# Copyright (c) 2003-2014 Marc Espie <espie@@openbsd.org>
#
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

use strict;
use warnings;

package OpenBSD::PackageInfo;
require Exporter;
our @@ISA=qw(Exporter);
our @@EXPORT=qw(installed_packages installed_info installed_name info_names is_info_name installed_stems
    lock_db unlock_db
    add_installed delete_installed is_installed borked_package 
    CONTENTS DESC REQUIRED_BY REQUIRING DISPLAY UNDISPLAY);

use OpenBSD::PackageName;
use OpenBSD::Paths;
use constant {
	CONTENTS => '+CONTENTS',
	DESC => '+DESC',
	REQUIRED_BY => '+REQUIRED_BY',
	REQUIRING => '+REQUIRING',
	DISPLAY => '+DISPLAY',
	UNDISPLAY => '+UNDISPLAY'};

use Fcntl qw/:flock/;
my $pkg_db = $ENV{"PKG_DBDIR"} || OpenBSD::Paths->pkgdb;

my ($list, $stemlist);

our @@info = (CONTENTS, DESC, REQUIRED_BY, REQUIRING, DISPLAY, UNDISPLAY);

our %info = ();
for my $i (@@info) {
	my $j = $i;
	$j =~ s/\+/F/o;
	$info{$i} = $j;
}

sub _init_list
{
	$list = {};
	$stemlist = OpenBSD::PackageName::compile_stemlist();

	opendir(my $dir, $pkg_db) or die "Bad pkg_db: $!";
	while (my $e = readdir($dir)) {
		next if $e eq '.' or $e eq '..';
		add_installed($e);
	}
	close($dir);
}

sub add_installed
{
	if (!defined $list) {
		_init_list();
	}
	for my $p (@@_) {
		$list->{$p} = 1;
		$stemlist->add($p);
	}
}

sub delete_installed
{
	if (!defined $list) {
		_init_list();
	}
	for my $p (@@_) {
		delete $list->{$p};
		$stemlist->delete($p);

	}
}

sub installed_stems
{
	if (!defined $list) {
		_init_list();
	}
	return $stemlist;
}

sub installed_packages
{
	if (!defined $list) {
		_init_list();
	}
	if ($_[0]) {
		return grep { !/^\./o } keys %$list;
	} else {
		return keys %$list;
	}
}

sub installed_info
{
	my $name =  shift;

	# XXX remove the o if we allow pkg_db to change dynamically
	if ($name =~ m|^\Q$pkg_db\E/?|o) {
		return "$name/";
	} else {
		return "$pkg_db/$name/";
	}
}

sub installed_contents
{
	my $name = shift;
	return installed_info($name).CONTENTS;
}

sub borked_package
{
	my $pkgname = shift;
	$pkgname = "partial-$pkgname" unless $pkgname =~ m/^partial\-/;
	unless (-e "$pkg_db/$pkgname") {
		return $pkgname;
	}
	my $i = 1;

	while (-e "$pkg_db/$pkgname.$i") {
		$i++;
	}
	return "$pkgname.$i";
}

sub libs_package
{
	my $pkgname = shift;
	$pkgname =~ s/^\.libs\d*\-//;
	unless (-e "$pkg_db/.libs-$pkgname") {
		return ".libs-$pkgname";
	}
	my $i = 1;

	while (-e "$pkg_db/.libs$i-$pkgname") {
		$i++;
	}
	return ".libs$i-$pkgname";
}

sub is_installed
{
	my $name = installed_name(shift);
	if (!defined $list) {
		installed_packages();
	}
	return defined $list->{$name};
}

sub installed_name
{
	require File::Spec;
	my $name = File::Spec->canonpath(shift);
	$name =~ s|/$||o;
	# XXX remove the o if we allow pkg_db to change dynamically
	$name =~ s|^\Q$pkg_db\E/?||o;
	$name =~ s|/\+CONTENTS$||o;
	return $name;
}

sub info_names()
{
	return @@info;
}

sub is_info_name
{
	my $name = shift;
	return $info{$name};
}

my $dlock;

sub lock_db($;$)
{
	my ($shared, $state) = @@_;
	my $mode = $shared ? LOCK_SH : LOCK_EX;
	open($dlock, '<', $pkg_db) or return;
	if (flock($dlock, $mode | LOCK_NB)) {
		return;
	}
	$state->errprint("Package database already locked... awaiting release... ")
		if defined $state;
	while (!flock($dlock, $mode)) {
	}
	$state->errsay("done!") if defined $state;
	return;
}

sub unlock_db()
{
	if (defined $dlock) {
		flock($dlock, LOCK_UN);
		close($dlock);
	}
}

1;
@


1.59
log
@bump copyright to 2014
@
text
@d2 1
a2 1
# $OpenBSD: PackageInfo.pm,v 1.58 2014/01/07 13:52:43 espie Exp $
d27 1
a27 2
    CONTENTS DESC META
    REQUIRED_BY REQUIRING DISPLAY UNDISPLAY);
a33 1
	META => '+META',
d44 1
a44 1
our @@info = (CONTENTS, DESC, META, REQUIRED_BY, REQUIRING, DISPLAY, UNDISPLAY);
@


1.58
log
@scrape support for old +COMMENT file.
8 years of backward compatibility is long enough... :)
@
text
@d2 1
a2 1
# $OpenBSD: PackageInfo.pm,v 1.57 2014/01/07 13:37:23 espie Exp $
d4 1
a4 1
# Copyright (c) 2003-2007 Marc Espie <espie@@openbsd.org>
@


1.57
log
@recognize special file +META
@
text
@d2 1
a2 1
# $OpenBSD: PackageInfo.pm,v 1.56 2011/08/23 10:32:27 espie Exp $
d27 1
a27 1
    CONTENTS COMMENT DESC META
a33 1
	COMMENT => '+COMMENT',
d46 1
a46 1
our @@info = (CONTENTS, COMMENT, DESC, META, REQUIRED_BY, REQUIRING, DISPLAY, UNDISPLAY);
@


1.56
log
@zap old INSTALL/DEINSTALL stuff, it's been deprecated for 3 years, and removed
from pkg_create for over a year.
@
text
@d2 1
a2 1
# $OpenBSD: PackageInfo.pm,v 1.55 2011/08/18 07:53:59 espie Exp $
d26 2
a27 1
    add_installed delete_installed is_installed borked_package CONTENTS COMMENT DESC
d36 1
d47 1
a47 1
our @@info = (CONTENTS, COMMENT, DESC, REQUIRED_BY, REQUIRING, DISPLAY, UNDISPLAY);
@


1.55
log
@tweak
@
text
@d2 1
a2 1
# $OpenBSD: PackageInfo.pm,v 1.54 2011/07/12 10:30:29 espie Exp $
d26 2
a27 2
    add_installed delete_installed is_installed borked_package CONTENTS COMMENT DESC INSTALL DEINSTALL REQUIRE
    REQUIRED_BY REQUIRING DISPLAY UNDISPLAY MTREE_DIRS);
a34 3
	INSTALL => '+INSTALL',
	DEINSTALL => '+DEINSTALL',
	REQUIRE => '+REQUIRE',
d38 1
a38 2
	UNDISPLAY => '+UNDISPLAY',
	MTREE_DIRS => '+MTREE_DIRS' };
d45 1
a45 1
our @@info = (CONTENTS, COMMENT, DESC, REQUIRE, INSTALL, DEINSTALL, REQUIRED_BY, REQUIRING, DISPLAY, UNDISPLAY, MTREE_DIRS);
@


1.54
log
@new pkg_delete, very similar to pkg_add, support for -a
@
text
@d2 1
a2 1
# $OpenBSD: PackageInfo.pm,v 1.53 2010/12/29 13:03:05 espie Exp $
d128 2
a129 1
	return installed_info(shift).CONTENTS;
@


1.53
log
@more stuff that uses print directly dies
@
text
@d2 1
a2 1
# $OpenBSD: PackageInfo.pm,v 1.52 2010/12/24 09:04:14 espie Exp $
a215 64
}


sub solve_installed_names
{
	my ($old, $new, $msg, $state) = @@_;

	my $bad = 0;
	my $seen = {};

	for my $pkgname (@@$old) {
	    $pkgname =~ s/\.tgz$//o;
	    if (is_installed($pkgname)) {
	    	if (!$seen->{$pkgname}) {
		    $seen->{$pkgname} = 1;
		    push(@@$new, installed_name($pkgname));
		}
	    } else {
		if (OpenBSD::PackageName::is_stem($pkgname)) {
		    require OpenBSD::Search;

		    my $r = $state->repo->installed->match_locations(OpenBSD::Search::Stem->new($pkgname));
		    if (@@$r == 0) {
			print "Can't resolve $pkgname to an installed package name\n";
			$bad = 1;
		    } elsif (@@$r == 1) {
			if (!$seen->{$r->[0]}) {
			    $seen->{$r->[0]} = 1;
			    push(@@$new, $r->[0]->name);
			}
		    } else {
		    	# try to see if we already solved the ambiguity
			my $found = 0;
			for my $p (@@$r) {
			    if ($seen->{$p}) {
				$found = 1;
				last;
			    }
			}
			next if $found;

			if ($state->defines('ambiguous')) {
			    my @@l = map {$_->name} @@$r;
			    $state->say("Ambiguous: #1 could be #2",
				$pkgname, join(' ', @@l));
			    $state->say($msg);
			    push(@@$new, @@l);
			    for my $p (@@$r) {
			    	$seen->{$p} = 1;
			    }
			} else {
			    my $result = $state->choose_location($pkgname, $r);
			    if (defined $result) {
			    	push(@@$new, $result->name);
				$seen->{$result} = 1;
			    } else {
				$bad = 1;
			    }
			}
		    }
		}
	    }
    	}
	return $bad;
@


1.52
log
@handle failures from ports tree with more care.
this does avoid infinite loops in case of wrong plists.
necessary since print-plist-with-depends CAN fail...
@
text
@d2 1
a2 1
# $OpenBSD$
d196 1
a196 1
	my ($shared, $quiet) = @@_;
d202 2
a203 2
	print STDERR "Package database already locked... awaiting release... "
		unless $quiet;
d206 1
a206 1
	print STDERR "done!\n" unless $quiet;
@


1.51
log
@initial scaffolding for @@rcscript: for now, acts like normal files,
but allow absolute pathnames (treat that as an implicit @@cwd).
@
text
@@


1.50
log
@allow say and errsay to work without parameters, as it's ways common.
create verbose_system up in state, because it makes sense without verbose.
@
text
@@


1.49
log
@whitespace cleanup
@
text
@@


1.48
log
@simple use of new state->repo API
@
text
@d2 1
a2 1
# $OpenBSD: PackageInfo.pm,v 1.47 2010/06/09 07:26:01 espie Exp $
@


1.47
log
@ui changes: go thru a state object for most printouts
@
text
@d2 1
a2 1
# $OpenBSD: PackageInfo.pm,v 1.46 2010/06/04 13:19:39 espie Exp $
a234 1
		    require OpenBSD::PackageRepository::Installed;
d237 1
a237 1
		    my $r = OpenBSD::PackageRepository::Installed->new->match_locations(OpenBSD::Search::Stem->new($pkgname));
@


1.46
log
@move code around, so that commands can be used as modules.
pkg becomes the start hub, which does nothing except require the
correct module.
Saner code wrt Add/Delete, and more sharing.
@
text
@d2 1
a2 1
# $OpenBSD: PackageInfo.pm,v 1.45 2010/05/10 09:17:55 espie Exp $
d260 2
a261 2
			    $state->say("Ambiguous: $pkgname could be ",
				join(' ', @@l));
@


1.45
log
@whitespace fixes
@
text
@d2 1
a2 1
# $OpenBSD$
d258 1
a258 1
			if ($state->{defines}->{ambiguous}) {
@


1.44
log
@make these independent from Getopt, require Exporter
@
text
@d260 1
a260 1
			    $state->say("Ambiguous: $pkgname could be ", 
@


1.43
log
@progressmeter puts STDOUT in autoflush if -t, so that it can display to it instead of piping a lot of stuff to STDERR.

Go through state->print for most messages, so they will NOT do weird things
with the progressmeter.
Use a ->say shortcut which does the same thing that perl 5.10 say does...
@
text
@d22 1
@


1.42
log
@state->progress->print => $state->print
@
text
@d259 3
a261 2
			    $state->print("Ambiguous: $pkgname could be ", join(' ', @@l),"\n");
			    print "$msg\n";
@


1.41
log
@bad espie: use strict/warnings consistently, and fix two nits and two
actual errors !
@
text
@d259 1
a259 1
			    $state->progress->print("Ambiguous: $pkgname could be ", join(' ', @@l),"\n");
@


1.40
log
@switch to match_locations, and so we can use choose_location, yippee!
@
text
@d20 1
@


1.39
log
@Canonicalise package names when comparing them against the package database.

This unconfuses pkg_* when passed paths that, while valid, don't exactly
match /var/db/pkg. For example, the following now works (note the double
slash):

	$ pkg_info /var//db/pkg/somepackage

Hasty tab-completers the world over shall rejoice. Tweaks and ok espie@@.
@
text
@d2 1
a2 1
# $OpenBSD: PackageInfo.pm,v 1.38 2008/06/15 08:23:50 espie Exp $
d236 2
a237 2
		    my @@l = OpenBSD::PackageRepository::Installed->new->match(OpenBSD::Search::Stem->new($pkgname));
		    if (@@l == 0) {
d240 4
a243 4
		    } elsif (@@l == 1) {
			if (!$seen->{$l[0]}) {
			    $seen->{$l[0]} = 1;
			    push(@@$new, $l[0]);
d245 1
a245 1
		    } elsif (@@l != 0) {
d248 1
a248 1
			for my $p (@@l) {
a255 1
			print "Ambiguous: $pkgname could be ", join(' ', @@l),"\n";
d257 2
d261 1
a261 1
			    for my $p (@@l) {
d265 3
a267 4
			    if ($state->{interactive}) {
			    	require OpenBSD::Interactive;
				my $result = OpenBSD::Interactive::ask_list('Choose one package', 1, ("<None>", sort @@l));
				push(@@$new, $result) if $result ne '<None>';
@


1.38
log
@make sure installed_stem is defined when needed, prevents some weird
errors.
@
text
@d2 1
a2 1
# $OpenBSD$
d170 2
a171 1
	my $name = shift;
@


1.37
log
@rename forced to defines
@
text
@d94 3
@


1.36
log
@better ui for locking messages.
Instead of just saying we await the release, we say when it's done.
(practically, a lot of package operation take `some time', it's good
for the user to know whether the command is still waiting for an held lock,
or actually doing some work)
@
text
@d2 1
a2 1
# $OpenBSD: PackageInfo.pm,v 1.35 2007/06/16 09:29:37 espie Exp $
d253 1
a253 1
			if ($state->{forced}->{ambiguous}) {
@


1.35
log
@use OpenBSD::Paths contents
@
text
@d2 1
a2 1
# $OpenBSD: PackageInfo.pm,v 1.34 2007/06/09 11:16:54 espie Exp $
d196 1
a196 1
	print STDERR "Package database already locked... awaiting release\n"
d200 1
@


1.34
log
@rework `special' package names a bit.
- do a test to create partial-foo-1.0.1 instead of partial-partial-foo-1.0
when removing partial-foo fails.
- have .libs name generation, e.g., .libs-foo, then .libs1-foo, then .libs2-foo
instead of .libs-.libs-foo.... extend the pkgspec pattern slightly, so
that all these are more or less equivalent for dependencies and conflicts.

With this, we can do practically any scenario of shared libs updates and
downgrades.
@
text
@d2 1
a2 1
# $OpenBSD: PackageInfo.pm,v 1.33 2007/06/04 14:40:39 espie Exp $
d28 1
d43 1
a43 1
my $pkg_db = $ENV{"PKG_DBDIR"} || '/var/db/pkg';
@


1.33
log
@some minor systematic changes.
- mark all regexps I can with /o if they can be compiled once.
- turn $o->method() into $o->method
- remove unneeded prototypes
- reduce split /re/ into split "string" where possible.
@
text
@d2 1
a2 1
# $OpenBSD: PackageInfo.pm,v 1.32 2007/06/01 14:58:29 espie Exp $
d127 4
a130 3
	my $pkgname = $_[0];
	unless (-e "$pkg_db/partial-$pkgname") {
		return "partial-$pkgname";
d134 1
a134 1
	while (-e "$pkg_db/partial-$pkgname.$i") {
d137 16
a152 1
	return "partial-$pkgname.$i";
@


1.32
log
@refactor ProgressMeter code to create objects, put these into state.
Create a common state class for delete and add, put the progressmeter
creation in there.

neat effect: we don't have a progressmeter, we use a stub class instead
and *never* pull the code in at all.
@
text
@d2 1
a2 1
# $OpenBSD: PackageInfo.pm,v 1.31 2007/05/31 13:11:21 espie Exp $
d51 1
a51 1
	$j =~ s/\+/F/;
d96 1
a96 1
sub installed_packages(;$)
d102 1
a102 1
		return grep { !/^\./ } keys %$list;
d108 1
a108 1
sub installed_info($)
d112 2
a113 1
	if ($name =~ m|^\Q$pkg_db\E/?|) {
d120 1
a120 1
sub installed_contents($)
d125 1
a125 1
sub borked_package($)
d139 1
a139 1
sub is_installed($)
d148 1
a148 1
sub installed_name($)
d151 4
a154 3
	$name =~ s|/$||;
	$name =~ s|^\Q$pkg_db\E/?||;
	$name =~ s|/\+CONTENTS$||;
d163 1
a163 1
sub is_info_name($)
d203 1
a203 1
	    $pkgname =~ s/\.tgz$//;
@


1.31
log
@oops, move realname up so that ::Sample sees it too.

remove last traces of MODULEs.
@
text
@d2 1
a2 1
# $OpenBSD: PackageInfo.pm,v 1.30 2007/05/30 16:32:14 espie Exp $
d241 1
a241 2
			    	require OpenBSD::ProgressMeter;

@


1.30
log
@simplify script handling a bit (they're going to disappear probably anyways).

Remove two passes visitors, we don't use them.
@
text
@d2 1
a2 1
# $OpenBSD: PackageInfo.pm,v 1.29 2007/05/18 12:40:35 espie Exp $
d24 1
a24 1
    add_installed delete_installed is_installed borked_package CONTENTS COMMENT DESC INSTALL DEINSTALL REQUIRE MODULE
a30 1
	MODULE => '+MODULE.pm' ,
d46 1
a46 2
# XXX note that REQUIRE occurs before INSTALL/DESINSTALL.
our @@info = (CONTENTS, COMMENT, DESC, REQUIRE, INSTALL, DEINSTALL, REQUIRED_BY, REQUIRING, DISPLAY, UNDISPLAY, MTREE_DIRS, MODULE);
a52 1
	$info{'+MODULE.pm'} = 'FMODULE';
@


1.29
log
@also strip +CONTENTS
@
text
@d2 1
a2 1
# $OpenBSD: PackageInfo.pm,v 1.28 2007/05/15 08:00:59 espie Exp $
d47 1
@


1.28
log
@fix dependencies
@
text
@d2 1
a2 1
# $OpenBSD: PackageInfo.pm,v 1.27 2007/05/14 10:53:31 espie Exp $
d154 1
@


1.27
log
@put search objects into a search class.
@
text
@d2 1
a2 1
# $OpenBSD: PackageInfo.pm,v 1.26 2007/05/14 10:00:08 espie Exp $
d210 2
a211 1
		    require OpenBSD::PackageRepository;
@


1.26
log
@maintain stemlist for installed packages dynamically
@
text
@d2 1
a2 1
# $OpenBSD: PackageInfo.pm,v 1.25 2007/05/14 09:49:27 espie Exp $
d212 1
a212 1
		    my @@l = OpenBSD::PackageRepository::Installed->new->match(OpenBSD::PackageName::Stem->new($pkgname));
@


1.25
log
@tidy
@
text
@d2 1
a2 1
# $OpenBSD: PackageInfo.pm,v 1.24 2007/05/13 13:32:36 espie Exp $
d22 1
a22 1
our @@EXPORT=qw(installed_packages installed_info installed_name info_names is_info_name 
d45 1
a45 1
my $list;
d60 1
d65 1
a65 1
		$list->{$e} = 1;
d77 1
d88 1
d91 5
@


1.24
log
@unify object lookup as locator->match($o) or $repo->match($o)
@
text
@d2 1
a2 1
# $OpenBSD: PackageInfo.pm,v 1.23 2007/05/07 14:33:30 espie Exp $
d45 1
a45 1
our $list;
@


1.23
log
@avoid calling compile_stemlist directly
@
text
@d2 1
a2 1
# $OpenBSD: PackageInfo.pm,v 1.22 2007/04/15 10:17:29 espie Exp $
d204 1
a204 1
		    my @@l = OpenBSD::PackageRepository::Installed->new->findstem($pkgname);
@


1.22
log
@update copyright years, standardize licence.
reword the introduction to the stuff originally from FreeBSD to clarify
slightly.
@
text
@d2 1
a2 1
# $OpenBSD: PackageInfo.pm,v 1.21 2007/03/18 10:57:12 espie Exp $
a189 1
	my $installed;
d202 3
a204 4
		    if (!defined $installed) {
		    	$installed = OpenBSD::PackageName::compile_stemlist(installed_packages());
		    }
		    my @@l = $installed->findstem($pkgname);
@


1.21
log
@remove some unnecessary sanity checks. /var/db/pkg is supposed to contain
only packages, so it's not really necessary to check for file existence
and rights. Besides, actual use of package stuff will try reading +CONTENTS
in a guarded way, so it will error out sanely...

Trims out hundreds of stat() under /var/db/pkg, which are largely responsible
for the slow start time of pkg_* tools.
@
text
@d2 1
a2 1
# $OpenBSD: PackageInfo.pm,v 1.20 2007/02/22 21:31:41 espie Exp $
d4 1
a4 1
# Copyright (c) 2003-2004 Marc Espie <espie@@openbsd.org>
@


1.20
log
@Problem noticed by Henrik Hellerstedt <henrik@@kohina.net>

Fix a really fun bug in pkg_delete: solve_installed_names has to
normalize the list of names so that comparing its size vs. its
transitive closure is meaningful. Use the classical hash + list to
preserve the order. While we're there, use the hash to avoid asking
the same questions again and again.

After some back&forth with bernd. okay bernd@@
@
text
@d2 1
a2 1
# $OpenBSD: PackageInfo.pm,v 1.19 2007/02/17 10:39:35 sturm Exp $
a59 1
	my @@bad=();
d64 1
a64 10
		next unless -d "$pkg_db/$e";
		if (! -r _) {
			push(@@bad, $e);
			next;
		}
		if (-f "$pkg_db/$e/+CONTENTS") {
			$list->{$e} = 1;
		} else {
			print "Warning: $e is not really a package\n";
		}
a66 3
	if (@@bad > 0) {
		print "Warning: can't access information for ", join(", ", @@bad), "\n";
	}
@


1.19
log
@ask_list() is in OpenBSD::Interactive, not OpenBSD::ProgressMeter
@
text
@d2 1
a2 1
# $OpenBSD: PackageInfo.pm,v 1.18 2005/09/04 22:47:56 espie Exp $
d205 1
d210 4
a213 1
		push(@@$new, installed_name($pkgname));
d224 4
a227 1
			push(@@$new, $l[0]);
d229 10
d243 3
d252 1
@


1.18
log
@* New -i interactive option, that can ask obnoxious questions.
* move the signature code to a packing-list method, prepend the pkgname.
* depend on distant listings, cache these systematically.
* cut the PKG_PATH at :/ systematically, much simpler than parsing URLs.
People should get used to trailing /s.
* let pkg_add -u actually run the update.
* check for signature in more places, for instance, let pkg_add installed_stuff
be a void operation.
* grab enough stuff during updates to check signatures, so that pkg_add -u
can report updates that are not needed right away, instead of waiting
for the more confusing `trying to update'
* beginning of @@module support.
* @@pkgpath support, including updates.
* systematically expand stems when applicable.
* use visitors systematically in pkg_info.
* pkg_info -S reports signature.
* remove hardcoding of categories in PackingList, so that future modules
will be able to expand them.
* add @@updateset and @@incompatibility keywords.
@
text
@d2 1
a2 1
# $OpenBSD: PackageInfo.pm,v 1.17 2005/01/16 11:16:23 espie Exp $
d230 1
a230 1
				my $result = OpenBSD::ProgressMeter::ask_list('Choose one package', 1, ("<None>", sort @@l));
@


1.17
log
@allow locking of database in quiet mode, where we don't display any
message.
Display the lock message on stderr anyways, so that we don't disturb
normal displays.
postpone locking after we know about -q in pkg_info's case.
Display command line if pkg_create fails, so that we can see what arguments
it found in bsd.port.mk.
@
text
@d2 1
a2 1
# $OpenBSD: PackageInfo.pm,v 1.16 2005/01/14 02:25:12 espie Exp $
d24 1
a24 1
    add_installed delete_installed is_installed borked_package CONTENTS COMMENT DESC INSTALL DEINSTALL REQUIRE 
d31 1
d47 1
a47 1
our @@info = (CONTENTS, COMMENT, DESC, REQUIRE, INSTALL, DEINSTALL, REQUIRED_BY, REQUIRING, DISPLAY, UNDISPLAY, MTREE_DIRS);
d54 1
d196 45
@


1.16
log
@`big lock' model: lock the whole db for reading/writing.
design checked with millert@@, relying on process termination for unlock
at his suggestion.

Perf optimization: don't try to reinstall installed packages in kitchensink
mode if !-r.
@
text
@d2 1
a2 1
# $OpenBSD: PackageInfo.pm,v 1.15 2004/12/27 22:16:13 espie Exp $
d173 1
a173 1
sub lock_db($)
d175 1
a175 1
	my $shared = shift;
d181 2
a182 1
	print "Package database already locked... awaiting release\n";
@


1.15
log
@use delete, not undef, to update installed_packages correctly...
while we're there, clean-up code slightly.
@
text
@d2 1
a2 1
# $OpenBSD: PackageInfo.pm,v 1.14 2004/12/16 11:07:33 espie Exp $
d23 1
d41 1
d169 24
@


1.14
log
@renamed borked_installation from borked.n to partial-<pkgname> ...
partial-<pkgname>.n if needed.

Make borked_installation take a message, to show installation/deinstallation
issues correctly.

Fix handling of ^C: this may lead some system calls to return early, thus
registering as errors: so always mark the last file as done, so that borked
installation will register it correctly.

Kill packing-list cache for anything but depends: we've got a global cache
of libraries now (use it in pkg_add).

Make almost everyone look at $main::not, so that we can call
register_installation
to_installation
RequirementList->add/delete
safely.

Simplify $not logic accordingly, do thing much more closely to what would
happen without -n.

This should allow pkg_add/pkg_delete -n to handle most nasty cases correctly
now, since all the relevant information is kept internally in a compact
format:
- register of shared libraries
- global register of conflicts
- cache of depends.
@
text
@d2 1
a2 1
# $OpenBSD: PackageInfo.pm,v 1.13 2004/11/14 19:10:41 espie Exp $
d53 25
d81 1
a81 1
		installed_packages();
d91 1
a91 1
		installed_packages();
d94 1
a94 1
		undef $list->{$p};
d102 1
a102 21
		$list = {};
		my @@bad=();

		opendir(my $dir, $pkg_db) or die "Bad pkg_db: $!";
		while (my $e = readdir($dir)) {
			next if $e eq '.' or $e eq '..';
			next unless -d "$pkg_db/$e";
			if (! -r _) {
				push(@@bad, $e);
				next;
			}
			if (-f "$pkg_db/$e/+CONTENTS") {
				$list->{$e} = 1;
			} else {
				print "Warning: $e is not really a package\n";
			}
		}
		close($dir);
		if (@@bad > 0) {
			print "Warning: can't access information for ", join(", ", @@bad), "\n";
		}
@


1.13
log
@make sure REQUIRING file is an integral part of what we do.
@
text
@d2 1
a2 1
# $OpenBSD: PackageInfo.pm,v 1.12 2004/11/14 11:40:08 espie Exp $
d122 1
a122 1
sub borked_package()
d124 4
d130 1
a130 1
	while (-e "$pkg_db/borked.$i") {
d133 1
a133 1
	return "borked.$i";
@


1.12
log
@let RequiredBy generate lists directly, use hashes to trim down duplicates directly. Optimize for !wantarray, by telling whether the list is empty or not.

prepare for a second similar list (REQUIRING) that will replace pkgdep, since
pkg_add -r spends a hell of a lot of its time reading/writing long
packing-lists...

Use the simplified interface.

Remove quite a few tests that the RequiredBy list is non-empty that do
nothing but obfuscate the code: just deal with the damn list already.
@
text
@d2 1
a2 1
# $OpenBSD: PackageInfo.pm,v 1.11 2004/11/11 11:54:09 espie Exp $
d24 1
a24 1
    REQUIRED_BY DISPLAY UNDISPLAY MTREE_DIRS);
d35 1
a35 1
	REQUIRING => '+REQUIRING' ,
d44 1
a44 1
our @@info = (CONTENTS, COMMENT, DESC, REQUIRE, INSTALL, DEINSTALL, REQUIRED_BY, DISPLAY, UNDISPLAY, MTREE_DIRS);
@


1.11
log
@package names starting with .  are hidden from pkg_info by default.
-A shows them.
@
text
@d2 1
a2 1
# $OpenBSD: PackageInfo.pm,v 1.10 2004/11/11 11:16:39 espie Exp $
d35 1
@


1.10
log
@introduce shortcuts to read/write contents from_installation/to_installation

use these to simplify all those packing lists manipulations.

demote non-root detection to a warning in -n mode:
fix a couple of minor bugs, of stuff that was run in -n mode and should not.
Namely, manpages were indexed/unindexed (ouch) and tempfiles were creating
during updates.
@
text
@d2 1
a2 1
# $OpenBSD: PackageInfo.pm,v 1.9 2004/10/11 10:30:34 espie Exp $
d73 1
a73 1
sub installed_packages()
d98 5
a102 1
	return keys %$list;
@


1.9
log
@add support for undisplay file, to be able to show information at pkg
removal without having to run a DEINSTALL script...
@
text
@d2 1
a2 1
# $OpenBSD: PackageInfo.pm,v 1.8 2004/10/11 10:07:37 espie Exp $
d110 5
@


1.8
log
@kill old MTREE option that was never implemented in the new tools anyways.
kill -C and -P options which are definitely no longer used as well.
Reorder special files so that REQUIRE is at front (and it's executed first
anyways).
@
text
@d2 1
a2 1
# $OpenBSD: PackageInfo.pm,v 1.7 2004/08/06 07:51:17 espie Exp $
d24 1
a24 1
    REQUIRED_BY DISPLAY MTREE_DIRS);
d36 1
d43 1
a43 1
our @@info = (CONTENTS, COMMENT, DESC, REQUIRE, INSTALL, DEINSTALL, REQUIRED_BY, DISPLAY, MTREE_DIRS);
@


1.7
log
@unified headers, switch to smaller copyright notice.
@
text
@d2 1
a2 1
# $OpenBSD: PackageInfo.pm,v 1.6 2004/02/21 19:15:40 espie Exp $
d42 1
a42 1
our @@info = (CONTENTS, COMMENT, DESC, INSTALL, DEINSTALL, REQUIRE, REQUIRED_BY, DISPLAY, MTREE_DIRS);
@


1.6
log
@distinguish between unreadable directories and non packages.
problem found by John L. Scarfone, who runs a paranoid root.
@
text
@d1 2
a2 1
# $OpenBSD: PackageInfo.pm,v 1.5 2004/01/27 00:14:42 espie Exp $
d4 13
a16 22
# Copyright (c) 2003 Marc Espie.
# 
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
# 
# THIS SOFTWARE IS PROVIDED BY THE OPENBSD PROJECT AND CONTRIBUTORS
# ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
# A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OPENBSD
# PROJECT OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
@


1.5
log
@die $!
@
text
@d1 1
a1 1
# $OpenBSD: PackageInfo.pm,v 1.4 2003/12/09 19:22:36 espie Exp $
d84 1
d90 4
d97 1
a97 1
				print "Warning: $e is not really a package";
d101 3
@


1.4
log
@better management of list of installed packages. Allow pkg_add/delete -n
to proceed correctly in case of dependencies.
@
text
@d1 1
a1 1
# $OpenBSD: PackageInfo.pm,v 1.3 2003/11/06 18:16:25 espie Exp $
d85 1
a85 1
		opendir(my $dir, $pkg_db) or die "Bad pkg_db";
@


1.3
log
@... pkg_add obviously much happier with borked_package...
@
text
@d1 1
a1 1
# $OpenBSD: PackageInfo.pm,v 1.1.1.1 2003/10/16 17:43:34 espie Exp $
d31 1
a31 1
    add_installed is_installed borked_package CONTENTS COMMENT DESC INSTALL DEINSTALL REQUIRE 
d48 1
a48 2
our @@list;
my $read_list;
d61 1
a61 1
	if (!$read_list) {
d64 14
a77 1
	push(@@list, @@_);
d82 2
a83 3
	if (!$read_list) {
		@@list = ();
		$read_list = 1;
d90 1
a90 1
				add_installed($e);
d97 1
a97 1
	return @@list;
d123 5
a127 5
	my $name = shift;
	my $dir = installed_info($name);
	return unless -d $dir;
	return unless -f $dir.CONTENTS;
	return $dir;
@


1.2
log
@Allow the use of full paths to refer to installed packages, so that
pkg_delete /var/db/pkg/zsh-*/  works.
@
text
@d31 1
a31 1
    add_installed is_installed CONTENTS COMMENT DESC INSTALL DEINSTALL REQUIRE 
d98 10
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
# $OpenBSD: PackageInfo.pm,v 1.1.1.1 2003/10/16 17:16:30 espie Exp $
d30 1
a30 1
our @@EXPORT=qw(installed_packages installed_info info_names is_info_name 
d92 6
a97 1
	return "$pkg_db/$name/";
d107 8
@


1.1.1.1
log
@new import of my pkgtools, after a slight naming disagreement with the
Upper Management...
@
text
@@
