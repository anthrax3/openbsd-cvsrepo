head	1.39;
access;
symbols
	OPENBSD_6_1:1.39.0.2
	OPENBSD_6_1_BASE:1.39
	OPENBSD_6_0:1.38.0.4
	OPENBSD_6_0_BASE:1.38
	OPENBSD_5_9:1.32.0.2
	OPENBSD_5_9_BASE:1.32
	OPENBSD_5_8:1.32.0.4
	OPENBSD_5_8_BASE:1.32
	OPENBSD_5_7:1.30.0.2
	OPENBSD_5_7_BASE:1.30
	OPENBSD_5_6:1.28.0.4
	OPENBSD_5_6_BASE:1.28
	OPENBSD_5_5:1.22.0.4
	OPENBSD_5_5_BASE:1.22
	OPENBSD_5_4:1.17.0.12
	OPENBSD_5_4_BASE:1.17
	OPENBSD_5_3:1.17.0.10
	OPENBSD_5_3_BASE:1.17
	OPENBSD_5_2:1.17.0.8
	OPENBSD_5_2_BASE:1.17
	OPENBSD_5_1_BASE:1.17
	OPENBSD_5_1:1.17.0.6
	OPENBSD_5_0:1.17.0.4
	OPENBSD_5_0_BASE:1.17
	OPENBSD_4_9:1.17.0.2
	OPENBSD_4_9_BASE:1.17
	OPENBSD_4_8:1.14.0.2
	OPENBSD_4_8_BASE:1.14;
locks; strict;
comment	@# @;


1.39
date	2017.03.01.10.35.24;	author espie;	state Exp;
branches;
next	1.38;
commitid	WLXUAeW6LYQMCSi5;

1.38
date	2016.06.24.11.42.30;	author espie;	state Exp;
branches;
next	1.37;
commitid	Pp1JudXEajWFIq4j;

1.37
date	2016.06.23.16.11.23;	author espie;	state Exp;
branches;
next	1.36;
commitid	QxkzX6iWFbwTHuvu;

1.36
date	2016.06.15.15.31.09;	author espie;	state Exp;
branches;
next	1.35;
commitid	Tw2l7s39vzJqETyy;

1.35
date	2016.05.15.10.29.01;	author espie;	state Exp;
branches;
next	1.34;
commitid	81AVIgaMoSDC9wmC;

1.34
date	2016.05.10.14.46.04;	author espie;	state Exp;
branches;
next	1.33;
commitid	1kYOnZORhbBz0O8x;

1.33
date	2016.05.09.13.23.34;	author espie;	state Exp;
branches;
next	1.32;
commitid	eAvlxzbS5gjhMHYN;

1.32
date	2015.05.18.10.41.20;	author espie;	state Exp;
branches;
next	1.31;
commitid	rrwCEb8hinrmFki2;

1.31
date	2015.05.18.10.25.10;	author espie;	state Exp;
branches;
next	1.30;
commitid	DMp3xx7BP1az3zhE;

1.30
date	2015.01.04.14.20.04;	author espie;	state Exp;
branches;
next	1.29;
commitid	xJlx1plAz31SlC6u;

1.29
date	2014.12.22.14.24.56;	author espie;	state Exp;
branches;
next	1.28;
commitid	quUhL2VXB9OEK2rK;

1.28
date	2014.07.08.17.02.56;	author espie;	state Exp;
branches;
next	1.27;
commitid	4xDpj7wbvCslEONd;

1.27
date	2014.07.08.07.59.05;	author espie;	state Exp;
branches;
next	1.26;
commitid	tUn1ElHUvv0eMzYB;

1.26
date	2014.07.07.16.43.55;	author espie;	state Exp;
branches;
next	1.25;
commitid	e9IeHCLb7Kc19weh;

1.25
date	2014.07.01.09.21.14;	author espie;	state Exp;
branches;
next	1.24;
commitid	pahs4DvL3j6GdczB;

1.24
date	2014.06.16.08.58.59;	author espie;	state Exp;
branches;
next	1.23;
commitid	h0JS5hNT4uwgPF1H;

1.23
date	2014.03.18.18.53.29;	author espie;	state Exp;
branches;
next	1.22;

1.22
date	2014.02.07.11.20.58;	author espie;	state Exp;
branches;
next	1.21;

1.21
date	2014.02.03.19.56.53;	author espie;	state Exp;
branches;
next	1.20;

1.20
date	2014.01.30.13.23.51;	author espie;	state Exp;
branches;
next	1.19;

1.19
date	2013.12.23.15.04.37;	author espie;	state Exp;
branches;
next	1.18;

1.18
date	2013.12.23.14.03.58;	author espie;	state Exp;
branches;
next	1.17;

1.17
date	2011.01.09.13.32.18;	author espie;	state Exp;
branches;
next	1.16;

1.16
date	2010.10.25.21.02.44;	author espie;	state Exp;
branches;
next	1.15;

1.15
date	2010.10.25.11.04.47;	author espie;	state Exp;
branches;
next	1.14;

1.14
date	2010.08.03.17.31.52;	author espie;	state Exp;
branches;
next	1.13;

1.13
date	2010.08.01.10.26.27;	author espie;	state Exp;
branches;
next	1.12;

1.12
date	2010.06.30.10.51.04;	author espie;	state Exp;
branches;
next	1.11;

1.11
date	2010.06.30.10.41.42;	author espie;	state Exp;
branches;
next	1.10;

1.10
date	2010.06.14.08.17.37;	author espie;	state Exp;
branches;
next	1.9;

1.9
date	2010.06.11.23.51.16;	author espie;	state Exp;
branches;
next	1.8;

1.8
date	2010.06.09.08.13.19;	author espie;	state Exp;
branches;
next	1.7;

1.7
date	2010.06.06.07.27.03;	author espie;	state Exp;
branches;
next	1.6;

1.6
date	2010.06.05.12.27.13;	author espie;	state Exp;
branches;
next	1.5;

1.5
date	2010.06.05.12.01.08;	author espie;	state Exp;
branches;
next	1.4;

1.4
date	2010.06.04.13.19.39;	author espie;	state Exp;
branches;
next	1.3;

1.3
date	2010.05.10.09.17.55;	author espie;	state Exp;
branches;
next	1.2;

1.2
date	2010.03.23.08.11.04;	author espie;	state Exp;
branches;
next	1.1;

1.1
date	2010.03.22.20.38.44;	author espie;	state Exp;
branches;
next	;


desc
@@


1.39
log
@scrape most of the config framework
okay aja@@, rpe@@
@
text
@# ex:ts=8 sw=4:
# $OpenBSD: Term.pm,v 1.38 2016/06/24 11:42:30 espie Exp $
#
# Copyright (c) 2004-2007 Marc Espie <espie@@openbsd.org>
#
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF

use strict;
use warnings;

package OpenBSD::PackingElement;
sub size_and
{
	my ($self, $p, $method, @@r) = @@_;
	$p->advance($self);
	$self->$method(@@r);
}

sub compute_count
{
	my ($self, $count) = @@_;

	$$count ++;
}

sub count_and
{
	my ($self, $progress, $done, $total, $method, @@r) = @@_;
	$$done ++;
	$progress->show($$done, $total);
	$self->$method(@@r);
}

package OpenBSD::ProgressMeter::Real;
our @@ISA = qw(OpenBSD::ProgressMeter);

sub ntogo
{
	my ($self, $state, $offset) = @@_;
	return $state->ntodo($offset // 0);
}

sub compute_count
{
	my ($progres, $plist) = @@_;
	my $total = 0;
	$plist->compute_count(\$total);
	$total = 1 if $total == 0;
	return $total;
}

sub visit_with_size
{
	my ($progress, $plist, $method, @@r) = @@_;
	my $p = $progress->new_sizer($plist);
	$plist->size_and($p, $method, $progress->{state}, @@r);
}

sub sizer_class
{
	"ProgressSizer"
}

sub visit_with_count
{
	my ($progress, $plist, $method, @@r) = @@_;
	$plist->{total} //= $progress->compute_count($plist);
	my $count = 0;
	$progress->show($count, $plist->{total});
	$plist->count_and($progress, \$count, $plist->{total},
	    $method, $progress->{state}, @@r);
}

package OpenBSD::ProgressMeter::Term;
our @@ISA = qw(OpenBSD::ProgressMeter::Real);
use POSIX;
use Term::Cap;
use Term::ReadKey;

sub width
{
	my $self = shift;
	return $self->{state}->width;
}

sub forked
{
	my $self = shift;
	$self->{lastdisplay} = ' 'x($self->width-1);
}

sub init
{
	my $self = shift;
	my $oldfh = select(STDOUT);
	$| = 1;
	select($oldfh);
	$self->{lastdisplay} = '';
	$self->{continued} = 0;
	$self->{work} = 0;
	$self->{header} = '';
	return unless defined $ENV{TERM} || defined $ENV{TERMCAP};
	my $termios = POSIX::Termios->new;
	$termios->getattr(0);
	my $terminal = Term::Cap->Tgetent({ OSPEED =>
	    $termios->getospeed});
	$self->{glitch} = $terminal->{_xn};
	$self->{cleareol} = $terminal->Tputs("ce", 1);
	$self->{hpa} = $terminal->Tputs("ch", 1);
	if (!defined $self->{hpa}) {
		# XXX this works with screen and tmux
		$self->{cuf} = $terminal->Tputs("RI", 1);
		if (defined $self->{cuf}) {
			$self->{hpa} = "\r".$self->{cuf};
		}
	}
}

sub compute_playfield
{
	my ($self, $cont) = @@_;
	$self->{playfield} = $self->width - length($self->{header}) - 7;
	if ($self->{playfield} < 5) {
		$self->{playfield} = 0;
	}
	if ($cont) {
		$self->{continued} = 1;
	}
}

sub set_header
{
	my ($self, $header) = @@_;
	$self->{header} = $header;
	$self->compute_playfield;
	return 1;
}

sub hmove
{
	my ($self, $v) = @@_;
	my $seq = $self->{hpa};
	$seq =~ s/\%i// and $v++;
	$seq =~ s/\%n// and $v ^= 0140;
	$seq =~ s/\%B// and $v = 16 * ($v/10) + $v%10;
	$seq =~ s/\%D// and $v = $v - 2*($v%16);
	$seq =~ s/\%\./sprintf('%c', $v)/e;
	$seq =~ s/\%d/sprintf('%d', $v)/e;
	$seq =~ s/\%2/sprintf('%2d', $v)/e;
	$seq =~ s/\%3/sprintf('%3d', $v)/e;
	$seq =~ s/\%\+(.)/sprintf('%c', $v+ord($1))/e;
	$seq =~ s/\%\%/\%/g;
	return $seq;
}

sub _show
{
	my ($self, $extra, $stars) = @@_;
	my $d = $self->{header};
	my $prefix = length($d);
	if (defined $extra) {
		$d.="|$extra";
		$prefix++;
	}
	if ($self->width > length($d)) {
		if ($self->{cleareol}) {
			$d .= $self->{cleareol};
		} else {
			$d .= ' 'x($self->width - length($d) - 1);
		}
	}

	if ($self->{continued}) {
		print "\r$d";
		$self->{continued} = 0;
		$self->{lastdisplay} = $d;
		return;
	}

	return if $d eq $self->{lastdisplay};


	if (defined $self->{hpa}) {
		if (defined $stars && defined $self->{stars}) {
			$prefix += $self->{stars};
		}
	}
	if (defined $self->{hpa} && substr($self->{lastdisplay}, 0, $prefix) eq
	    substr($d, 0, $prefix)) {
		print $self->hmove($prefix), substr($d, $prefix);
	} else {
		print "\r$d";
	}
	$self->{lastdisplay} = $d;
}

sub message
{
	my ($self, $message) = @@_;
	if ($self->{cleareol}) {
		$message .= $self->{cleareol};
	} elsif ($self->{playfield} > length($message)) {
		$message .= ' 'x($self->{playfield} - length($message));
	}
	if ($self->{playfield}) {
		$self->_show(substr($message, 0, $self->{playfield}));
	} else {
		$self->_show;
	}
}

sub show
{
	my ($self, $current, $total) = @@_;

	if ($self->{playfield}) {
		my $stars = int (($current * $self->{playfield}) / $total + 0.5);
		my $percent = int (($current * 100)/$total + 0.5);
		if ($percent < 100) {
			$self->_show('*'x$stars.' 'x($self->{playfield}-$stars)."| ".$percent."\%", $stars);
		} else {
			$self->_show('*'x$self->{playfield}."|100\%", $stars);
		}
		$self->{stars} = $stars;
	} else {
	    	$self->_show;
	}
}

sub working
{
	my ($self, $slowdown) = @@_;
	$self->{work}++;
	return if $self->{work} < $slowdown;
	$self->message(substr("/-\\|", ($self->{work}/$slowdown) % 4, 1));
}

sub clear
{
	my $self = shift;
	return unless length($self->{lastdisplay}) > 0;
	if ($self->{cleareol}) {
		print "\r", $self->{cleareol};
	} else {
		print "\r", ' 'x length($self->{lastdisplay}), "\r";
	}
	$self->{lastdisplay} = '';
	delete $self->{stars};
}

sub disable
{
	my $self = shift;
	print "\n" if length($self->{lastdisplay}) > 0;

	bless $self, "OpenBSD::ProgressMeter::Stub";
}

sub next
{
	my ($self, $todo) = @@_;
	$self->clear;

	$todo //= 'ok';
	print "\r$self->{header}: $todo\n";
}

package ProgressSizer;
our @@ISA = qw(PureSizer);

sub new
{
	my ($class, $progress, $plist) = @@_;
	my $p = $class->SUPER::new($progress, $plist);
	$progress->show(0, $p->{totsize});
	if (defined $progress->{state}{archive}) {
		$progress->{state}{archive}->set_callback(
		    sub {
			my $done = shift;
			$progress->show($p->{donesize} + $done, $p->{totsize});
		});
	}
	return $p;
}

sub advance
{
	my ($self, $e) = @@_;
	if (defined $e->{size}) {
		$self->{donesize} += $e->{size};
		$self->{progress}->show($self->{donesize}, $self->{totsize});
	}
}

1;
@


1.38
log
@simplify the logic. no need for a separate hook when we can just specialize
find_window_size.
fix a bug: integrate SIG{CONT} for re-checking window size.

the way it's currently written, first call to compute_playfield will
call itself once. But it makes for less code.
@
text
@d2 1
a2 1
# $OpenBSD: Term.pm,v 1.37 2016/06/23 16:11:23 espie Exp $
a131 4
	# we can print to 80 columns
	if ($self->{glitch} && $self->{state}->config->istrue("fullwidth")) {
		$self->{playfield} += 1;
	}
@


1.37
log
@there's no reason for window size computation to be linked to the
ProgressMeter, so make it available from state.
- computation is lazy, so no runtime difference;
- don't bother setting a SIG{WINCH} on non-tty;
- progressmeter already has access to state;
- do an empty window_size_changed in base state, override it for
addcreatedelete to inform the progressmeter.

to be reused in dpb...
@
text
@d2 1
a2 1
# $OpenBSD: Term.pm,v 1.36 2016/06/15 15:31:09 espie Exp $
d130 1
a130 1
	my $self = shift;
d139 3
a148 3
	$SIG{'CONT'} = sub {
		$self->{continued} = 1;
	};
@


1.36
log
@ProgressMeter keeps state. Unfortunately, term is shared between processes.
Adds supplementary code that was first tested in proot, but may be needed
to split pkg_add into processes in the future.
@
text
@d2 1
a2 1
# $OpenBSD: Term.pm,v 1.35 2016/05/15 10:29:01 espie Exp $
d89 6
d98 1
a98 1
	$self->{lastdisplay} = ' 'x($self->{width}-1);
a106 1
	$self->find_window_size;
a127 12
sub find_window_size
{
	my $self = shift;

	my @@l = Term::ReadKey::GetTermSizeGWINSZ(\*STDOUT);
	if (@@l != 4) {
		$self->{width} = 80;
	} else {
		$self->{width} = $l[0];
	}
}

d131 1
a131 1
	$self->{playfield} = $self->{width} - length($self->{header}) - 7;
a145 4
	$SIG{'WINCH'} = sub {
		$self->find_window_size;
		$self->compute_playfield;
	};
d178 1
a178 1
	if ($self->{width} > length($d)) {
d182 1
a182 1
			$d .= ' 'x($self->{width} - length($d) - 1);
@


1.35
log
@set glitch correctly
@
text
@d2 1
a2 1
# $OpenBSD: Term.pm,v 1.34 2016/05/10 14:46:04 espie Exp $
d88 6
@


1.34
log
@go deeper in Term::ReadKey, we don't need smart guesses.
okay afresh@@/millert@@
@
text
@d2 1
a2 1
# $OpenBSD: Term.pm,v 1.33 2016/05/09 13:23:34 espie Exp $
d105 1
a105 1
	$self->{glitch} = $terminal->Tputs("xn", 1);
@


1.33
log
@stop depending on *.ph
use Term::ReadKey
a bit of funky stuff while old ports Term::ReadKey is around
@
text
@d2 1
a2 1
# $OpenBSD: Term.pm,v 1.32 2015/05/18 10:41:20 espie Exp $
d121 1
a121 5
	# shut up warnings for Term::ReadKey 2.33
	local $SIG{__WARN__} = sub {};
	my @@l;
	# XXX don't die! in case people still have Term::ReadKey 2.30 as a port
	eval { @@l = GetTerminalSize(\*STDOUT); } ;
@


1.32
log
@simplify progressmeter calls to visit_and: we retrieve the state from the
progressmeter object
@
text
@d2 1
a2 1
# $OpenBSD: Term.pm,v 1.31 2015/05/18 10:25:10 espie Exp $
d87 1
a116 3
my $wsz_format = 'SSSS';
our %sizeof;

d120 8
a127 9
	# try to get exact window width
	my $r;
	$r = pack($wsz_format, 0, 0, 0, 0);
	$sizeof{'struct winsize'} = 8;
	require 'sys/ttycom.ph';
	if (ioctl(STDOUT, &TIOCGWINSZ, $r)) {
		my ($rows, $cols, $xpix, $ypix) =
		    unpack($wsz_format, $r);
		$self->{width} = $cols;
d129 1
a129 1
		$self->{width} = 80;
@


1.31
log
@since the progressmeter is always tied to a state, store the state always,
and not just in the Term case.

allows passing less parameters around.
@
text
@d2 1
a2 1
# $OpenBSD: Term.pm,v 1.30 2015/01/04 14:20:04 espie Exp $
d63 1
a63 1
	my ($progress, $plist, $method, $state, @@r) = @@_;
d80 1
a80 1
	    $method, @@r);
@


1.30
log
@tweak the ntogo messages slightly so that they work better in all situations
@
text
@d2 1
a2 1
# $OpenBSD: Term.pm,v 1.29 2014/12/22 14:24:56 espie Exp $
d64 2
a65 2
	my $p = $progress->new_sizer($plist, $state);
	$plist->size_and($p, $method, $state, @@r);
d298 2
a299 2
	my ($class, $progress, $plist, $state) = @@_;
	my $p = $class->SUPER::new($progress, $plist, $state);
d301 2
a302 2
	if (defined $state->{archive}) {
		$state->{archive}->set_callback(
@


1.29
log
@when we run into real errors, the progress meter is distracting, so have
a method ->disable that does something nice to the display, and stops
the progress meter right before we display our first real error.
@
text
@d2 1
a2 1
# $OpenBSD: Term.pm,v 1.28 2014/07/08 17:02:56 espie Exp $
d49 1
a49 1
	return $state->ntogo_string($offset);
@


1.28
log
@don't really bother cleaning up the callback, it will go away soon enough
@
text
@d2 1
a2 1
# $OpenBSD: Term.pm,v 1.27 2014/07/08 07:59:05 espie Exp $
d274 8
@


1.27
log
@cleaner callback handling
- store it inside location, so that belayed archives open can get it
- wipe it out when the sizer goes away... to be done slightly better
probably ?
@
text
@d2 1
a2 1
# $OpenBSD: Term.pm,v 1.26 2014/07/07 16:43:55 espie Exp $
a308 9
	}
}

sub saved
{
	my $self = shift;
	$self->SUPER::saved;
	if (defined $self->{state}{archive}) {
		$self->{state}{archive}->set_callback;
@


1.26
log
@restore progressmeter for big files.
somehow, one extra level of indirection to archive, make it all go away
by adding a new method set_callback
@
text
@d2 1
a2 1
# $OpenBSD: Term.pm,v 1.25 2014/07/01 09:21:14 espie Exp $
d309 9
@


1.25
log
@tweak the ProgressMeter code to always record sizes, even in the stub case
@
text
@d2 1
a2 1
# $OpenBSD: Term.pm,v 1.24 2014/06/16 08:58:59 espie Exp $
d294 5
a298 4
		$state->{archive}{callback} = sub {
		    my $done = shift;
		    $progress->show($p->{donesize} + $done, $p->{totsize});
		};
@


1.24
log
@tweak the size_and support to be able to do stuff out of order
@
text
@d2 1
a2 1
# $OpenBSD: Term.pm,v 1.23 2014/03/18 18:53:29 espie Exp $
a27 7
sub compute_size
{
	my ($self, $totsize) = @@_;

	$$totsize += $self->{size} if defined $self->{size};
}

a51 9
sub compute_size
{
	my $plist = shift;
	my $totsize = 0;
	$plist->compute_size(\$totsize);
	$totsize = 1 if $totsize == 0;
	return $totsize;
}

d54 1
a54 1
	my $plist = shift;
d68 1
a68 1
sub new_sizer
d70 1
a70 16
	my ($progress, $plist, $state) = @@_;
	$plist->{totsize} //= compute_size($plist);
	my $p = bless {
	    progress => $progress, 
	    totsize => $plist->{totsize},
	    donesize => 0,
	    state => $state
	    }, "_SizeCounter";
	$progress->show(0, $p->{totsize});
	if (defined $state->{archive}) {
		$state->{archive}{callback} = sub {
		    my $done = shift;
		    $progress->show($p->{donesize} + $done, $p->{totsize});
		};
	}
	return $p;
d76 1
a76 1
	$plist->{total} //= compute_count($plist);
d285 3
a287 1
package _SizeCounter;
d290 10
@


1.23
log
@remove $_ usage that warns under perl 5.18
@
text
@d2 1
a2 1
# $OpenBSD: Term.pm,v 1.22 2014/02/07 11:20:58 espie Exp $
d23 2
a24 5
	my ($self, $progress, $donesize, $totsize, $method, @@r) = @@_;
	if (defined $self->{size}) {
		$$donesize += $self->{size};
		$progress->show($$donesize, $totsize);
	}
d80 7
d88 7
a94 3
	my $donesize = 0;
	my $totsize = $plist->{totsize};
	$progress->show($donesize, $totsize);
d98 1
a98 1
		    $progress->show($donesize + $done, $totsize);
d101 1
a101 2
	$plist->size_and($progress, \$donesize, $totsize,
	    $method, $state, @@r);
d314 14
@


1.22
log
@don't store full terminal, we just need a few control sequences
@
text
@d2 1
a2 1
# $OpenBSD: Term.pm,v 1.21 2014/02/03 19:56:53 espie Exp $
d191 12
a202 12
	my $_ = $self->{hpa};
	s/\%i// and $v++;
	s/\%n// and $v ^= 0140;
	s/\%B// and $v = 16 * ($v/10) + $v%10;
	s/\%D// and $v = $v - 2*($v%16);
	s/\%\./sprintf('%c', $v)/e;
	s/\%d/sprintf('%d', $v)/e;
	s/\%2/sprintf('%2d', $v)/e;
	s/\%3/sprintf('%3d', $v)/e;
	s/\%\+(.)/sprintf('%c', $v+ord($1))/e;
	s/\%\%/\%/g;
	return $_;
@


1.21
log
@perl is actually VERY BAD at scraping captured variables until the end.
Avoid creating a gratuitous back reference to that packing-list.
Prevents us from keeping shas around... :(
@
text
@d2 1
a2 1
# $OpenBSD: Term.pm,v 1.20 2014/01/30 13:23:51 espie Exp $
d93 1
a93 1
	$plist->size_and($progress, \$donesize, $plist->{totsize},
d126 1
a126 1
	$self->{terminal} = Term::Cap->Tgetent({ OSPEED =>
d128 3
a130 3
	$self->{glitch} = $self->{terminal}->Tputs("xn", 1);
	$self->{cleareol} = $self->{terminal}->Tputs("ce", 1);
	$self->{hpa} = $self->{terminal}->Tputs("ch", 1);
d133 1
a133 1
		$self->{cuf} = $self->{terminal}->Tputs("RI", 1);
@


1.20
log
@avoid storing dead keys.
quirks is exceptional, since it needs to be cached negatively.
@
text
@d2 1
a2 1
# $OpenBSD: Term.pm,v 1.19 2013/12/23 15:04:37 espie Exp $
d85 2
a86 1
	$progress->show($donesize, $plist->{totsize});
d90 1
a90 1
		    $progress->show($donesize + $done, $plist->{totsize});
@


1.19
log
@real fix: turns out visit_with_* are transparent, e.g., pass all their
parameters to the end consumer.  Make sure the !Term version obeys that too.
@
text
@d2 1
a2 1
# $OpenBSD: Term.pm,v 1.18 2013/12/23 14:03:58 espie Exp $
d296 1
a296 1
	undef $self->{stars};
@


1.18
log
@and I fucked up that one too...
@
text
@d2 1
a2 1
# $OpenBSD: Term.pm,v 1.17 2011/01/09 13:32:18 espie Exp $
d23 1
a23 1
	my ($self, $progress, $donesize, $totsize, $method, $state, @@r) = @@_;
d98 1
a98 1
	my ($progress, $plist, $method, $state, @@r) = @@_;
d103 1
a103 1
	    $method, $state, @@r);
@


1.17
log
@NYTProf now warns against $& in regexps, remove that one which doesn't
serve any purpose...
@
text
@d2 1
a2 1
# $OpenBSD: Term.pm,v 1.16 2010/10/25 21:02:44 espie Exp $
d23 1
a23 1
	my ($self, $progress, $donesize, $totsize, $method, @@r) = @@_;
@


1.16
log
@don't use the fullwidth of the term by default, makes typing easier.
pass state thru so that we can check in /etc/pkg.conf and use it if we want.
@
text
@d2 1
a2 1
# $OpenBSD: Term.pm,v 1.15 2010/10/25 11:04:47 espie Exp $
d196 1
a196 1
	s/\%d/sprintf($&, $v)/e;
@


1.15
log
@separate "Term" part from "Real progressmeter" handling, so that one can
use the common part independently.
@
text
@d2 1
a2 1
# $OpenBSD: Term.pm,v 1.14 2010/08/03 17:31:52 espie Exp $
d164 1
a164 1
	if ($self->{glitch}) {
@


1.14
log
@missed one if (continued) test, so simplify logic: test continue beforehand.
fixes display after ^Z/fg.

(problem pointed out by Theo)
@
text
@d2 1
a2 1
# $OpenBSD: Term.pm,v 1.13 2010/08/01 10:26:27 espie Exp $
d53 53
d107 1
a107 1
our @@ISA = qw(OpenBSD::ProgressMeter);
a307 49
sub ntogo
{
	my ($self, $state, $offset) = @@_;
	return $state->ntogo_string($offset);
}

sub compute_size
{
	my $plist = shift;
	my $totsize = 0;
	$plist->compute_size(\$totsize);
	$totsize = 1 if $totsize == 0;
	return $totsize;
}

sub compute_count
{
	my $plist = shift;
	my $total = 0;
	$plist->compute_count(\$total);
	$total = 1 if $total == 0;
	return $total;
}

sub visit_with_size
{
	my ($progress, $plist, $method, $state, @@r) = @@_;
	$plist->{totsize} //= compute_size($plist);
	my $donesize = 0;
	$progress->show($donesize, $plist->{totsize});
	if (defined $state->{archive}) {
		$state->{archive}{callback} = sub {
		    my $done = shift;
		    $progress->show($donesize + $done, $plist->{totsize});
		};
	}
	$plist->size_and($progress, \$donesize, $plist->{totsize},
	    $method, $state, @@r);
}

sub visit_with_count
{
	my ($progress, $plist, $method, $state, @@r) = @@_;
	$plist->{total} //= compute_count($plist);
	my $count = 0;
	$progress->show($count, $plist->{total});
	$plist->count_and($progress, \$count, $plist->{total},
	    $method, $state, @@r);
}
@


1.13
log
@adjust position of test so that it does something !
avoid a lot of extra stupid printing.
@
text
@d2 1
a2 1
# $OpenBSD: Term.pm,v 1.12 2010/06/30 10:51:04 espie Exp $
d168 8
a175 1
	return if $d eq $self->{lastdisplay} && !$self->{continued};
d177 2
a178 1
	if (!$self->{continued} && defined $self->{hpa}) {
a189 1
	$self->{continued} = 0;
@


1.12
log
@allow say and errsay to work without parameters, as it's ways common.
create verbose_system up in state, because it makes sense without verbose.
@
text
@d2 1
a2 1
# $OpenBSD$
a159 1
	return if $d eq $self->{lastdisplay} && !$self->{continued};
d167 3
@


1.11
log
@whitespace cleanup
@
text
@@


1.10
log
@screen does not have hpa, but we can make do with \r cuf.
fixes flickering under tmux...
@
text
@d2 1
a2 1
# $OpenBSD: Term.pm,v 1.9 2010/06/11 23:51:16 espie Exp $
d173 1
a173 1
	if (defined $self->{hpa} && substr($self->{lastdisplay}, 0, $prefix) eq 
@


1.9
log
@start with an empty header
@
text
@d2 1
a2 1
# $OpenBSD: Term.pm,v 1.8 2010/06/09 08:13:19 espie Exp $
d77 7
@


1.8
log
@replace confusing (n to go) message with #done/#total annotations.
e.g.,
Checking packages|No change in apr-util-mt-1.2.10p4 (26/1530)
@
text
@d2 1
a2 1
# $OpenBSD: Term.pm,v 1.7 2010/06/06 07:27:03 espie Exp $
d68 1
d216 1
@


1.7
log
@oops, make sure we have wpa before using it.
@
text
@d2 1
a2 1
# $OpenBSD: Term.pm,v 1.6 2010/06/05 12:27:13 espie Exp $
d233 2
a234 2
	$todo //= '';
	print "\r$self->{header}: ok$todo\n";
@


1.6
log
@be more specific as to what we keep. Less flicker in working
@
text
@d2 1
a2 1
# $OpenBSD: Term.pm,v 1.5 2010/06/05 12:01:08 espie Exp $
d165 1
a165 1
	if (substr($self->{lastdisplay}, 0, $prefix) eq 
@


1.5
log
@interface tweaks:
- allow mtree to create more diverse data structures.
- new "working" method, for when progressmeter should show that something is
going on, but doesn't actually have an actual % to show, so show cartwheels.
e.g., progress->working(1024);
(actual counter will be /= argument, so that it does move a bit slower).
@
text
@d2 1
a2 1
# $OpenBSD: Term.pm,v 1.4 2010/06/04 13:19:39 espie Exp $
d147 1
d150 1
a159 1
	my $prefix;
d162 1
a162 3
			$prefix = length($self->{header})+1+$self->{stars};
		} else {
			$prefix = length($self->{header});
d165 1
a165 1
	if (defined $prefix && substr($self->{lastdisplay}, 0, $prefix) eq
d212 1
@


1.4
log
@move code around, so that commands can be used as modules.
pkg becomes the start hub, which does nothing except require the
correct module.
Saner code wrt Add/Delete, and more sharing.
@
text
@d2 1
a2 1
# $OpenBSD: Term.pm,v 1.3 2010/05/10 09:17:55 espie Exp $
d67 1
d209 6
@


1.3
log
@whitespace fixes
@
text
@d2 1
a2 1
# $OpenBSD$
d232 2
a233 1
	&OpenBSD::UI::ntogo_string;
@


1.2
log
@fix callback. This one isn't called that often actually.
noticed by ckuethe
@
text
@d2 1
a2 1
# $OpenBSD: Term.pm,v 1.1 2010/03/22 20:38:44 espie Exp $
d70 1
a70 1
	$self->{terminal} = Term::Cap->Tgetent({ OSPEED => 
d89 1
a89 1
		my ($rows, $cols, $xpix, $ypix) = 
d159 1
a159 1
		if (defined $stars && defined $self->{stars}) { 
d265 1
a265 1
	$plist->size_and($progress, \$donesize, $plist->{totsize}, 
d275 1
a275 1
	$plist->count_and($progress, \$count, $plist->{total}, 
@


1.1
log
@clean up the ProgressMeter code, create a specific class if a Term
is around.
start using stuff from termcap, specifically, cleareol, and move to hp.
use the full line when we can, cram 100% if we can.
(this should flicker much less on slow terminals).

clean-up the install-and-progress bits to be in progressmeter, this removes
some code.

have pkg_create follow the same pattern as the others, with a state.
This allows us to unify error messages a bit.
@
text
@d2 1
a2 1
# $OpenBSD$
d262 1
a262 1
		    $progress->show($$donesize + $done, $plist->{totsize});
@

