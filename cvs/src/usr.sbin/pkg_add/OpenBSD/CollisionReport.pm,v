head	1.46;
access;
symbols
	OPENBSD_6_1_BASE:1.46
	OPENBSD_6_0:1.46.0.10
	OPENBSD_6_0_BASE:1.46
	OPENBSD_5_9:1.46.0.4
	OPENBSD_5_9_BASE:1.46
	OPENBSD_5_8:1.46.0.6
	OPENBSD_5_8_BASE:1.46
	OPENBSD_5_7:1.46.0.2
	OPENBSD_5_7_BASE:1.46
	OPENBSD_5_6:1.44.0.12
	OPENBSD_5_6_BASE:1.44
	OPENBSD_5_5:1.44.0.10
	OPENBSD_5_5_BASE:1.44
	OPENBSD_5_4:1.44.0.6
	OPENBSD_5_4_BASE:1.44
	OPENBSD_5_3:1.44.0.4
	OPENBSD_5_3_BASE:1.44
	OPENBSD_5_2:1.44.0.2
	OPENBSD_5_2_BASE:1.44
	OPENBSD_5_1_BASE:1.43
	OPENBSD_5_1:1.43.0.2
	OPENBSD_5_0:1.41.0.4
	OPENBSD_5_0_BASE:1.41
	OPENBSD_4_9:1.41.0.2
	OPENBSD_4_9_BASE:1.41
	OPENBSD_4_8:1.38.0.2
	OPENBSD_4_8_BASE:1.38
	OPENBSD_4_7:1.32.0.2
	OPENBSD_4_7_BASE:1.32
	OPENBSD_4_6:1.19.0.6
	OPENBSD_4_6_BASE:1.19
	OPENBSD_4_5:1.19.0.2
	OPENBSD_4_5_BASE:1.19
	OPENBSD_4_4:1.18.0.2
	OPENBSD_4_4_BASE:1.18
	OPENBSD_4_3:1.15.0.4
	OPENBSD_4_3_BASE:1.15
	OPENBSD_4_2:1.15.0.2
	OPENBSD_4_2_BASE:1.15
	OPENBSD_4_1:1.9.0.4
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.9.0.2
	OPENBSD_4_0_BASE:1.9
	OPENBSD_3_9:1.8.0.2
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.7.0.4
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.2
	OPENBSD_3_7_BASE:1.7;
locks; strict;
comment	@# @;


1.46
date	2014.12.02.06.52.46;	author espie;	state Exp;
branches;
next	1.45;
commitid	erhPuMImVuxQ4K2F;

1.45
date	2014.11.29.10.42.51;	author espie;	state Exp;
branches;
next	1.44;
commitid	XiRgNGt76qJ9BWZO;

1.44
date	2012.04.28.12.00.10;	author espie;	state Exp;
branches;
next	1.43;

1.43
date	2011.12.03.16.45.50;	author espie;	state Exp;
branches;
next	1.42;

1.42
date	2011.12.03.16.15.05;	author espie;	state Exp;
branches;
next	1.41;

1.41
date	2011.01.02.14.26.17;	author espie;	state Exp;
branches;
next	1.40;

1.40
date	2010.12.24.09.04.14;	author espie;	state Exp;
branches;
next	1.39;

1.39
date	2010.10.27.14.35.56;	author espie;	state Exp;
branches;
next	1.38;

1.38
date	2010.07.11.07.27.25;	author espie;	state Exp;
branches;
next	1.37;

1.37
date	2010.06.30.10.51.04;	author espie;	state Exp;
branches;
next	1.36;

1.36
date	2010.06.30.10.41.42;	author espie;	state Exp;
branches;
next	1.35;

1.35
date	2010.06.09.07.26.01;	author espie;	state Exp;
branches;
next	1.34;

1.34
date	2010.06.04.13.19.39;	author espie;	state Exp;
branches;
next	1.33;

1.33
date	2010.05.10.09.17.55;	author espie;	state Exp;
branches;
next	1.32;

1.32
date	2010.01.17.11.56.46;	author espie;	state Exp;
branches;
next	1.31;

1.31
date	2010.01.14.19.35.55;	author espie;	state Exp;
branches;
next	1.30;

1.30
date	2010.01.08.16.42.56;	author espie;	state Exp;
branches;
next	1.29;

1.29
date	2009.12.20.22.38.45;	author espie;	state Exp;
branches;
next	1.28;

1.28
date	2009.11.17.10.17.21;	author espie;	state Exp;
branches;
next	1.27;

1.27
date	2009.11.16.14.42.18;	author espie;	state Exp;
branches;
next	1.26;

1.26
date	2009.11.15.09.01.55;	author espie;	state Exp;
branches;
next	1.25;

1.25
date	2009.11.14.21.04.02;	author espie;	state Exp;
branches;
next	1.24;

1.24
date	2009.11.14.10.56.19;	author espie;	state Exp;
branches;
next	1.23;

1.23
date	2009.11.14.08.11.05;	author espie;	state Exp;
branches;
next	1.22;

1.22
date	2009.11.11.13.00.40;	author espie;	state Exp;
branches;
next	1.21;

1.21
date	2009.11.11.12.04.19;	author espie;	state Exp;
branches;
next	1.20;

1.20
date	2009.11.10.11.36.56;	author espie;	state Exp;
branches;
next	1.19;

1.19
date	2008.10.06.09.36.17;	author espie;	state Exp;
branches;
next	1.18;

1.18
date	2008.06.21.14.01.10;	author espie;	state Exp;
branches;
next	1.17;

1.17
date	2008.06.21.12.41.55;	author espie;	state Exp;
branches;
next	1.16;

1.16
date	2008.03.08.12.07.45;	author espie;	state Exp;
branches;
next	1.15;

1.15
date	2007.06.20.13.44.39;	author espie;	state Exp;
branches;
next	1.14;

1.14
date	2007.06.09.11.16.54;	author espie;	state Exp;
branches;
next	1.13;

1.13
date	2007.06.04.14.40.39;	author espie;	state Exp;
branches;
next	1.12;

1.12
date	2007.05.30.12.27.19;	author espie;	state Exp;
branches;
next	1.11;

1.11
date	2007.05.02.15.05.29;	author espie;	state Exp;
branches;
next	1.10;

1.10
date	2007.04.15.10.17.29;	author espie;	state Exp;
branches;
next	1.9;

1.9
date	2006.05.04.08.36.07;	author espie;	state Exp;
branches;
next	1.8;

1.8
date	2006.02.06.21.55.58;	author espie;	state Exp;
branches;
next	1.7;

1.7
date	2004.12.17.11.26.22;	author espie;	state Exp;
branches;
next	1.6;

1.6
date	2004.12.16.11.18.44;	author espie;	state Exp;
branches;
next	1.5;

1.5
date	2004.12.16.11.07.33;	author espie;	state Exp;
branches;
next	1.4;

1.4
date	2004.11.15.17.05.50;	author espie;	state Exp;
branches;
next	1.3;

1.3
date	2004.11.14.19.50.44;	author espie;	state Exp;
branches;
next	1.2;

1.2
date	2004.11.13.23.13.39;	author espie;	state Exp;
branches;
next	1.1;

1.1
date	2004.11.11.12.29.58;	author espie;	state Exp;
branches;
next	;


desc
@@


1.46
log
@zap extra parenthesis after recent rewrite
from Mark Patruck
@
text
@# ex:ts=8 sw=4:
# $OpenBSD: CollisionReport.pm,v 1.45 2014/11/29 10:42:51 espie Exp $
#
# Copyright (c) 2003-2006 Marc Espie <espie@@openbsd.org>
#
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

use strict;
use warnings;

package OpenBSD::PackingElement;
sub handle_collisions
{
}

package OpenBSD::PackingElement::FileBase;
sub handle_collisions
{
	my ($self, $todo, $pkg, $bypkg) = @@_;
	my $name = $self->fullname;
	if (defined $todo->{$name}) {
		push(@@{$bypkg->{$pkg}}, $name);
		delete $todo->{$name};
	}
}

package OpenBSD::CollisionReport;
use OpenBSD::PackingList;
use OpenBSD::PackageInfo;

sub find_collisions
{
	my ($todo, $state) = @@_;
	my $verbose = $state->verbose >= 3;
	my $bypkg = {};
	for my $name (keys %$todo) {
		my $pkg = $state->vstat->value($state->{destdir}.$name);
		if (defined $pkg) {
			push(@@{$bypkg->{$pkg}}, $name);
			delete $todo->{$name};
		}
	}


	if (!%$todo) {
		return $bypkg;
	}
	for my $pkg (installed_packages()) {
		$state->say("Looking for collisions in #1", $pkg) if $verbose;
		my $plist = OpenBSD::PackingList->from_installation($pkg,
		    \&OpenBSD::PackingList::FilesOnly);
		next if !defined $plist;
		$plist->handle_collisions($todo, $pkg, $bypkg);
	}
	return $bypkg;
}

sub collision_report
{
	my ($list, $state, $set) = @@_;

	my $destdir = $state->{destdir};

	if ($state->defines('removecollisions')) {
		require OpenBSD::Error;
		for my $f (@@$list) {
			$state->unlink(1, $destdir.$f->fullname);
		}
		return;
	}
	my %todo = map {($_->fullname, $_->{d})} @@$list;
	my %extra = map {($_->fullname, $_->{newly_found})} @@$list;
	my $clueless_bat;
	my $clueless_bat2;
	my $found = 0;

	$state->errsay("Collision in #1: the following files already exist",
	    $set->print);
	if (!$state->defines('dontfindcollisions')) {
		my $bypkg = find_collisions(\%todo, $state);
		for my $pkg (sort keys %$bypkg) {
		    for my $item (sort @@{$bypkg->{$pkg}}) {
		    	$found++;
			$state->errsay("\t#1 (#2 and #3)", $item, $pkg,
			    $extra{$item});
		    }
		    if ($pkg =~ m/^(?:partial\-|borked\.\d+$)/o) {
			$clueless_bat = $pkg;
		    }
		    if ($pkg =~ m/^\.libs\d*-*$/o) {
			$clueless_bat2 = $pkg;
		    }
		}
	}
	if (%todo) {

		for my $item (sort keys %todo) {
			my $old = $todo{$item};
		    $state->errprint("\t#1 from #2", $item, $extra{$item});
		    if (defined $old && -f $destdir.$item) {
			    my $d = $old->new($destdir.$item);

			    if ($d->equals($old)) {
				    $state->errsay(" (same checksum)");
			    } else {
				    $state->errsay(" (different checksum)");
			    }
		    } else {
			    $state->errsay;
		    }
	    	}
	}
	if (defined $clueless_bat) {
		$state->errprint("The package name #1 suggests that a former installation\n".
		    "of a similar package got interrupted.  It is likely that\n".
		    "\tpkg_delete #1\n".
		    "will solve the problem\n", $clueless_bat);
	}
	if (defined $clueless_bat2) {
		$state->errprint("The package name #1 suggests remaining libraries\n".
		    "from a former package update.  It is likely that\n".
		    "\tpkg_delete #1\n".
		    "will solve the problem\n", $clueless_bat2);
	}
	my $dorepair = 0;
	if ($found == 0) {
		$dorepair = $state->defines('repair') ||
		    $state->confirm("It seems to be a missing package registration\nRepair", 0);
	}
	if ($dorepair == 1) {
		for my $f (@@$list) {

			if ($state->unlink($state->verbose >= 2,
			    $destdir.$f->fullname)) {
				$state->{problems}--;
			} else {
				return;
			}
		}
		$state->{repairdependencies} = 1;
	}
}

1;
@


1.45
log
@simplify the interactive code into its own little object with simpler
interface, so that most is it interactive tests vanish from the main
program.
@
text
@d2 1
a2 1
# $OpenBSD: CollisionReport.pm,v 1.44 2012/04/28 12:00:10 espie Exp $
d138 1
a138 1
		    $state->confirm("It seems to be a missing package registration\nRepair", 0));
@


1.44
log
@zap blank spaces
@
text
@d2 1
a2 1
# $OpenBSD$
d137 2
a138 7
		if ($state->defines('repair')) {
			$dorepair = 1;
		} elsif ($state->{interactive}) {
			if ($state->confirm("It seems to be a missing package registration\nRepair", 0)) {
				$dorepair = 1;
			}
		}
@


1.43
log
@simplify/generalize
@
text
@d2 1
a2 1
# $OpenBSD: CollisionReport.pm,v 1.42 2011/12/03 16:15:05 espie Exp $
d94 1
a94 1
			$state->errsay("\t#1 (#2 and #3)", $item, $pkg, 
@


1.42
log
@In a collision, retrofit storage for 2nd pkgname.
(in large updatesets, it may not be obvious where the 2nd copy comes from,
as exemplified by ajacoutot@@).
@
text
@d2 1
a2 1
# $OpenBSD: CollisionReport.pm,v 1.41 2011/01/02 14:26:17 espie Exp $
d94 2
a95 6
			if ($extra{$item}) {
				$state->errsay("\t#1 (#2 and #3)", $item, 
				    $pkg, $extra{$item});
			} else {
				$state->errsay("\t#1 (#2)", $item, $pkg);
			}
d109 1
a109 1
		    $state->errprint("\t#1", $item);
@


1.41
log
@kill very old idiom, I don't actually want to go thru items directly.
@
text
@d2 1
a2 1
# $OpenBSD: CollisionReport.pm,v 1.40 2010/12/24 09:04:14 espie Exp $
d82 1
d94 6
a99 1
			$state->errsay("\t#1 (#2)", $item, $pkg);
@


1.40
log
@handle failures from ports tree with more care.
this does avoid infinite loops in case of wrong plists.
necessary since print-plist-with-depends CAN fail...
@
text
@d2 1
a2 1
# $OpenBSD$
d21 16
d63 1
a63 8
		for my $item (@@{$plist->{items}}) {
			next unless $item->IsFile;
			my $name = $item->fullname;
			if (defined $todo->{$name}) {
				push(@@{$bypkg->{$pkg}}, $name);
				delete $todo->{$name};
			}
		}
@


1.39
log
@initial scaffolding for @@rcscript: for now, acts like normal files,
but allow absolute pathnames (treat that as an implicit @@cwd).
@
text
@@


1.38
log
@display updateset name alongside collisionreport (turns out it's not
always obvious)
@
text
@d2 1
a2 1
# $OpenBSD: CollisionReport.pm,v 1.37 2010/06/30 10:51:04 espie Exp $
@


1.37
log
@allow say and errsay to work without parameters, as it's ways common.
create verbose_system up in state, because it makes sense without verbose.
@
text
@d2 1
a2 1
# $OpenBSD$
d59 1
a59 1
sub collision_report($$)
d61 1
a61 1
	my ($list, $state) = @@_;
d77 2
a78 1
	$state->errsay("Collision: the following files already exist");
@


1.36
log
@whitespace cleanup
@
text
@d107 1
a107 1
			    $state->errsay("");
@


1.35
log
@ui changes: go thru a state object for most printouts
@
text
@d2 1
a2 1
# $OpenBSD: CollisionReport.pm,v 1.34 2010/06/04 13:19:39 espie Exp $
@


1.34
log
@move code around, so that commands can be used as modules.
pkg becomes the start hub, which does nothing except require the
correct module.
Saner code wrt Add/Delete, and more sharing.
@
text
@d2 1
a2 1
# $OpenBSD: CollisionReport.pm,v 1.33 2010/05/10 09:17:55 espie Exp $
d43 1
a43 1
		$state->say("Looking for collisions in $pkg") if $verbose;
d83 1
a83 1
			$state->errsay("\t$item ($pkg)");
d97 1
a97 1
		    $state->errprint("\t$item");
d112 4
a115 4
		$state->errprint("The package name $clueless_bat suggests that a former installation\n",
		    "of a similar package got interrupted.  It is likely that\n",
		    "\tpkg_delete $clueless_bat\n",
		    "will solve the problem\n");
d118 4
a121 4
		$state->errprint("The package name $clueless_bat2 suggests remaining libraries\n",
		    "from a former package update.  It is likely that\n",
		    "\tpkg_delete $clueless_bat2\n".
		    "will solve the problem\n");
@


1.33
log
@whitespace fixes
@
text
@d2 1
a2 1
# $OpenBSD$
d65 1
a65 1
	if ($state->{defines}->{removecollisions}) {
d78 1
a78 1
	if (!$state->{defines}->{dontfindcollisions}) {
d125 1
a125 1
		if ($state->{defines}->{repair}) {
@


1.32
log
@use Carp directly, it it very inexpensive actually, since it's been rewritten
to be just a very small stub that loads Carp::Heavy on demand.
Also, stop wrapping messages in "Expected", doesn't give us anything.
Finally, make RequiredBy calls be carp, so that we actually know where they
fail...
@
text
@d44 1
a44 1
		my $plist = OpenBSD::PackingList->from_installation($pkg, 
d76 1
a76 1
	
d136 1
a136 1
			if ($state->unlink($state->verbose >= 2, 
@


1.31
log
@fix new vstat, and make it useful, for instance for -n.
@
text
@d102 1
a102 1
				    $state->errsay("(same checksum)");
d104 1
a104 1
				    $state->errsay("(different checksum)");
@


1.30
log
@stat objects with more than value (store symlinks eventually)
@
text
@d31 2
a32 3
		my $p = $state->vstat->exists($name);
		if (defined $p && $p->value) {
			my $pkg = $p->value;
d96 3
a98 2
		    if (defined $todo{$item}) {
			    my $old = $todo{$item};
d100 1
d102 1
a102 1
				$state->errsay("\t$item (same checksum)");
d104 1
a104 1
				$state->errsay("\t$item (different checksum)");
d107 1
a107 1
			    $state->errsay("\t$item");
@


1.29
log
@change verbosity handling: be silent by default, turn on the first level if -v.
Add more levels, specifically, lots of info regarding individual files only
visible if -vvvvv.
Make -n display the same stuff as normal (need -n -v to display more stuff).
Introduce -s, "size-only", turns on -n and does skip any extraction.
Sprinkle handlers for SIG_INFO, not really nice yet.

Note that -n is non functional for complex updates, because of caching
issues I have to fix.
@
text
@d32 2
a33 2
		if (ref $p) {
			my $pkg = $$p;
@


1.28
log
@revamp interactive stuff: simplify (just one always for everything, per
theo suggestion. Also go through the "state" object which simplifies code
a great deal)
@
text
@d28 1
a28 1
	my $verbose = $state->{verbose};
d135 1
a135 1
			if ($state->unlink($state->{verbose}, 
@


1.27
log
@create a pseudo vstat object inside state, so that we can modify Vstat
interface very locally...

model hints objects like Locations, to uniformize further treatment.
@
text
@d127 1
a127 3
			require OpenBSD::Interactive;
			if (OpenBSD::Interactive::confirm(
	    "It seems to be a missing package registration\nRepair", 1, 0)) {
@


1.26
log
@start categorizing stuff as error messages that should be error messages
@
text
@a23 1
use OpenBSD::Vstat;
d31 1
a31 1
		my $p = OpenBSD::Vstat::vexists $name;
@


1.25
log
@ouch, collision handling must take destdir into account
@
text
@d79 1
a79 1
	$state->say("Collision: the following files already exist");
d85 1
a85 1
			$state->say("\t$item ($pkg)");
d102 1
a102 1
				$state->say("\t$item (same checksum)");
d104 1
a104 1
				$state->say("\t$item (different checksum)");
d107 1
a107 1
			    $state->say("\t$item");
d112 1
a112 1
		$state->print("The package name $clueless_bat suggests that a former installation\n",
d118 1
a118 1
		$state->print("The package name $clueless_bat2 suggests remaining libraries\n",
@


1.24
log
@remove stupid extraneous return...
@
text
@d65 2
d70 1
a70 1
			$state->unlink(1, $f->fullname);
a95 1
		my $destdir = $state->{destdir};
d139 1
a139 1
			    $f->fullname)) {
@


1.23
log
@fix. noticed by sthen@@
@
text
@d2 1
a2 1
# $OpenBSD: CollisionReport.pm,v 1.22 2009/11/11 13:00:40 espie Exp $
a54 1
				return $bypkg;
@


1.22
log
@vsystem, system, unlink can mostly go through state, and do the ->clear part
as well.
@
text
@d2 1
a2 1
# $OpenBSD$
d28 2
a29 1
	my ($todo, $verbose) = @@_;
d80 1
a80 1
		my $bypkg = find_collisions(\%todo, $state->{verbose});
@


1.21
log
@progressmeter puts STDOUT in autoflush if -t, so that it can display to it instead of piping a lot of stuff to STDERR.

Go through state->print for most messages, so they will NOT do weird things
with the progressmeter.
Use a ->say shortcut which does the same thing that perl 5.10 say does...
@
text
@d68 1
a68 1
			OpenBSD::Error::Unlink(1, $f->fullname);
a134 1
		require OpenBSD::Error;
d137 1
a137 1
			if (OpenBSD::Error::Unlink($state->{verbose}, 
@


1.20
log
@bad espie: use strict/warnings consistently, and fix two nits and two
actual errors !
@
text
@d44 1
a44 1
		print "Looking for collisions in $pkg\n" if $verbose;
d77 1
a77 1
	print "Collision: the following files already exist\n";
d83 1
a83 1
			print "\t$item ($pkg)\n";
d101 1
a101 1
				print "\t$item (same checksum)\n";
d103 1
a103 1
				print "\t$item (different checksum)\n";
d106 1
a106 1
			    print "\t$item\n";
d111 4
a114 4
		print "The package name $clueless_bat suggests that a former installation\n";
		print "of a similar package got interrupted.  It is likely that\n";
		print "\tpkg_delete $clueless_bat\n";
		print "will solve the problem\n";
d117 4
a120 4
		print "The package name $clueless_bat2 suggests remaining libraries\n";
		print "from a former package update.  It is likely that\n";
		print "\tpkg_delete $clueless_bat2\n";
		print "will solve the problem\n";
@


1.19
log
@turn the checksums stored in packing elements into real objects, so that
pkg_add becomes mostly independent of the type of checksum stored.

separate md5 into an abstract OpenBSD::digest class and an md5 subclass
with specific methods to compute checksums and serialize results, and create
an sha class that does the same thing with sha256 (with a base64 serializer)
@
text
@d17 1
@


1.18
log
@rework collisionreport to allow some limited repair capabilities:
assuming none of the files is registered, we can assume that the
package registration fails, and then we remove the files, and install
the package.

Then we also walk installed packages to restore dependencies that would
have been erased (this is fairly simple-minded and may fail in weird
cases).
@
text
@d71 1
a71 1
	my %todo = map {($_->fullname, $_->{md5})} @@$list;
a92 1
		require OpenBSD::md5;
d97 4
a100 3
			    my $md5 = OpenBSD::md5::fromfile($destdir.$item);
			    if ($md5 eq $todo{$item}) {
				print "\t$item (same md5)\n";
d102 1
a102 1
				print "\t$item (different md5)\n";
@


1.17
log
@use autovivification
@
text
@d25 34
d65 1
d67 1
a67 2
			print "rm ", $f->fullname, "\n";
			unlink($f->fullname);
a71 1
	my $bypkg = {};
d74 1
d77 13
a89 26
	for my $name (keys %todo) {
		my $p = OpenBSD::Vstat::vexists $name;
		if (ref $p) {
			my $pkg = $$p;
			push(@@{$bypkg->{$pkg}}, $name);
			delete $todo{$name};
		}
	}

	if (%todo) {
		BIGLOOP: {
		for my $pkg (installed_packages()) {
			print "Looking for collisions in $pkg\n" if $state->{verbose};
			my $plist = OpenBSD::PackingList->from_installation($pkg, 
			    \&OpenBSD::PackingList::FilesOnly);
			next if !defined $plist;
			for my $item (@@{$plist->{items}}) {
				next unless $item->IsFile;
				my $name = $item->fullname;
				if (defined $todo{$name}) {
					push(@@{$bypkg->{$pkg}}, $name);
					delete $todo{$name};
					last BIGLOOP if !%todo;
				}
			}
		}
a91 11
	for my $pkg (sort keys %$bypkg) {
	    for my $item (sort @@{$bypkg->{$pkg}}) {
	    	print "\t$item ($pkg)\n";
	    }
	    if ($pkg =~ m/^(?:partial\-|borked\.\d+$)/o) {
	    	$clueless_bat = $pkg;
	    }
	    if ($pkg =~ m/^\.libs\d*-*$/o) {
	    	$clueless_bat2 = $pkg;
	    }
	}
d120 25
@


1.16
log
@rename forced to defines
@
text
@d39 2
a40 2
	my $clueless_bat = 0;
	my $clueless_bat2 = 0;
a46 1
			$bypkg->{$pkg} = [] unless defined $bypkg->{$pkg};
a62 1
					$bypkg->{$pkg} = [] unless defined $bypkg->{$pkg};
d99 1
a99 1
	if ($clueless_bat) {
d105 1
a105 1
	if ($clueless_bat2) {
@


1.15
log
@sprinkle code to deal gracefully with absent packing-lists.
makes it easier for people to recover after a disk crash that
leaves /var/db/pkg half-empty.
@
text
@d2 1
a2 1
# $OpenBSD: CollisionReport.pm,v 1.14 2007/06/09 11:16:54 espie Exp $
d30 1
a30 1
	if ($state->{forced}->{removecollisions}) {
@


1.14
log
@rework `special' package names a bit.
- do a test to create partial-foo-1.0.1 instead of partial-partial-foo-1.0
when removing partial-foo fails.
- have .libs name generation, e.g., .libs-foo, then .libs1-foo, then .libs2-foo
instead of .libs-.libs-foo.... extend the pkgspec pattern slightly, so
that all these are more or less equivalent for dependencies and conflicts.

With this, we can do practically any scenario of shared libs updates and
downgrades.
@
text
@d2 1
a2 1
# $OpenBSD: CollisionReport.pm,v 1.13 2007/06/04 14:40:39 espie Exp $
d59 1
@


1.13
log
@some minor systematic changes.
- mark all regexps I can with /o if they can be compiled once.
- turn $o->method() into $o->method
- remove unneeded prototypes
- reduce split /re/ into split "string" where possible.
@
text
@d2 1
a2 1
# $OpenBSD: CollisionReport.pm,v 1.12 2007/05/30 12:27:19 espie Exp $
d79 1
a79 1
	    if ($pkg =~ m/^\.libs-*$/o) {
@


1.12
log
@allow for removing colliding files... very dangerous.
@
text
@d2 1
a2 1
# $OpenBSD: CollisionReport.pm,v 1.11 2007/05/02 15:05:29 espie Exp $
d76 1
a76 1
	    if ($pkg =~ m/^(?:partial\-|borked\.\d+$)/) {
d79 1
a79 1
	    if ($pkg =~ m/^\.libs-*$/) {
@


1.11
log
@$o->method() becomes $o->method
@
text
@d2 1
a2 1
# $OpenBSD: CollisionReport.pm,v 1.10 2007/04/15 10:17:29 espie Exp $
d29 8
@


1.10
log
@update copyright years, standardize licence.
reword the introduction to the stuff originally from FreeBSD to clarify
slightly.
@
text
@d2 1
a2 1
# $OpenBSD: CollisionReport.pm,v 1.9 2006/05/04 08:36:07 espie Exp $
d29 1
a29 1
	my %todo = map {($_->fullname(), $_->{md5})} @@$list;
d52 2
a53 2
				next unless $item->IsFile();
				my $name = $item->fullname();
@


1.9
log
@more clues for people who update their system.
@
text
@d2 1
a2 1
# $OpenBSD: CollisionReport.pm,v 1.8 2006/02/06 21:55:58 espie Exp $
d4 1
a4 1
# Copyright (c) 2003-2004 Marc Espie <espie@@openbsd.org>
@


1.8
log
@tell user about collision much earlier, so that they do not wonder what
is taking so long...
@
text
@d2 1
a2 1
# $OpenBSD: CollisionReport.pm,v 1.7 2004/12/17 11:26:22 espie Exp $
d32 1
d71 3
d96 6
@


1.7
log
@better collision reports.
- in validate_plist, don't re-add a file that exists.
- allows the virtual file system to put marks on existing files
- use a \$pkgname the first time a file is added (space constraints: don't
duplicate the pkgname).
- in CollisionReport, first check the vfs, so that we don't look
at installed packages when the collision only concerns newly added pkgs.

Makes pkg_add -n report collision reports correctly.
@
text
@d2 1
a2 1
# $OpenBSD: CollisionReport.pm,v 1.6 2004/12/16 11:18:44 espie Exp $
d33 1
a62 1
	print "Collision: the following files already exist\n";
@


1.6
log
@both borked.* and partial-* are recognized.
give the right pkg_delete command
@
text
@d2 1
a2 1
# $OpenBSD: CollisionReport.pm,v 1.5 2004/12/16 11:07:33 espie Exp $
d23 1
d33 9
d43 15
a57 13
	BIGLOOP: {
	for my $pkg (installed_packages()) {
		print "Looking for collisions in $pkg\n" if $state->{verbose};
		my $plist = OpenBSD::PackingList->from_installation($pkg, 
		    \&OpenBSD::PackingList::FilesOnly);
		for my $item (@@{$plist->{items}}) {
			next unless $item->IsFile();
			my $name = $item->fullname();
			if (defined $todo{$name}) {
				$bypkg->{$pkg} = [] unless defined $bypkg->{$pkg};
				push(@@{$bypkg->{$pkg}}, $name);
				delete $todo{$name};
				last BIGLOOP if !%todo;
d60 1
a60 1
	}
@


1.5
log
@renamed borked_installation from borked.n to partial-<pkgname> ...
partial-<pkgname>.n if needed.

Make borked_installation take a message, to show installation/deinstallation
issues correctly.

Fix handling of ^C: this may lead some system calls to return early, thus
registering as errors: so always mark the last file as done, so that borked
installation will register it correctly.

Kill packing-list cache for anything but depends: we've got a global cache
of libraries now (use it in pkg_add).

Make almost everyone look at $main::not, so that we can call
register_installation
to_installation
RequirementList->add/delete
safely.

Simplify $not logic accordingly, do thing much more closely to what would
happen without -n.

This should allow pkg_add/pkg_delete -n to handle most nasty cases correctly
now, since all the relevant information is kept internally in a compact
format:
- register of shared libraries
- global register of conflicts
- cache of depends.
@
text
@d2 1
a2 1
# $OpenBSD: CollisionReport.pm,v 1.4 2004/11/15 17:05:50 espie Exp $
d55 1
a55 1
	    if ($pkg =~ m/^partial\-/) {
d79 1
a79 1
		print "\tpkg_delete borked.*\n";
@


1.4
log
@hit the clueless...
@
text
@d2 1
a2 1
# $OpenBSD: CollisionReport.pm,v 1.3 2004/11/14 19:50:44 espie Exp $
d55 1
a55 1
	    if ($pkg =~ m/^borked\.\d+$/) {
@


1.3
log
@pass full item to CollisionReport, so that it can compute md5 for files
not registered with any package, and tell you if the file differs or not.
@
text
@d2 1
a2 1
# $OpenBSD: CollisionReport.pm,v 1.2 2004/11/13 23:13:39 espie Exp $
d30 1
d55 3
d64 7
a70 3
		    my $md5 = OpenBSD::md5::fromfile($destdir.$item);
		    if ($md5 eq $todo{$item}) {
			print "\t$item (same md5)\n";
d72 1
a72 1
			print "\t$item (different md5)\n";
d75 6
@


1.2
log
@fix loop label. reported by naddy@@
@
text
@d2 1
a2 1
# $OpenBSD: CollisionReport.pm,v 1.1 2004/11/11 12:29:58 espie Exp $
d28 1
a28 1
	my %todo = map {($_, 1)} @@$list;
d55 12
a66 2
	for my $item (sort keys %todo) {
	    print "\t$item\n";
@


1.1
log
@move collision reporter to a separate file, so that it doesn't get loaded
all the time.
@
text
@d2 1
a2 1
# $OpenBSD: Add.pm,v 1.13 2004/11/11 12:17:25 espie Exp $
d44 1
a44 1
				last LOOP if !%todo;
@

