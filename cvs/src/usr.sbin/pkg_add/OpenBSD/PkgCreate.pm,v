head	1.124;
access;
symbols
	OPENBSD_6_1:1.123.0.4
	OPENBSD_6_1_BASE:1.123
	OPENBSD_6_0:1.121.0.4
	OPENBSD_6_0_BASE:1.121
	OPENBSD_5_9:1.118.0.2
	OPENBSD_5_9_BASE:1.118
	OPENBSD_5_8:1.116.0.4
	OPENBSD_5_8_BASE:1.116
	OPENBSD_5_7:1.114.0.2
	OPENBSD_5_7_BASE:1.114
	OPENBSD_5_6:1.108.0.4
	OPENBSD_5_6_BASE:1.108
	OPENBSD_5_5:1.101.0.4
	OPENBSD_5_5_BASE:1.101
	OPENBSD_5_4:1.69.0.4
	OPENBSD_5_4_BASE:1.69
	OPENBSD_5_3:1.69.0.2
	OPENBSD_5_3_BASE:1.69
	OPENBSD_5_2:1.68.0.2
	OPENBSD_5_2_BASE:1.68
	OPENBSD_5_1_BASE:1.56
	OPENBSD_5_1:1.56.0.2
	OPENBSD_5_0:1.47.0.2
	OPENBSD_5_0_BASE:1.47
	OPENBSD_4_9:1.41.0.2
	OPENBSD_4_9_BASE:1.41
	OPENBSD_4_8:1.22.0.2
	OPENBSD_4_8_BASE:1.22;
locks; strict;
comment	@# @;


1.124
date	2017.09.18.13.01.10;	author espie;	state Exp;
branches;
next	1.123;
commitid	Gwhmmmjv06YtHVag;

1.123
date	2016.10.03.13.17.30;	author espie;	state Exp;
branches;
next	1.122;
commitid	UAcDnHKM3hWLAfsT;

1.122
date	2016.09.06.10.41.51;	author espie;	state Exp;
branches;
next	1.121;
commitid	s2PPIDjn9UAqg50C;

1.121
date	2016.06.21.10.40.37;	author espie;	state Exp;
branches;
next	1.120;
commitid	XcGgxmDDgO3seW9q;

1.120
date	2016.04.25.10.12.58;	author espie;	state Exp;
branches;
next	1.119;
commitid	YqCfgScl8lnWHOaz;

1.119
date	2016.04.02.12.18.44;	author espie;	state Exp;
branches;
next	1.118;
commitid	YeDPCJ6ER1ZZVXJV;

1.118
date	2015.11.06.08.53.12;	author espie;	state Exp;
branches;
next	1.117;
commitid	DHNtx5859YTC6Qel;

1.117
date	2015.08.13.08.13.44;	author espie;	state Exp;
branches;
next	1.116;
commitid	V2etPV7HAZ44rUGp;

1.116
date	2015.05.18.10.41.20;	author espie;	state Exp;
branches;
next	1.115;
commitid	rrwCEb8hinrmFki2;

1.115
date	2015.05.18.10.37.12;	author espie;	state Exp;
branches;
next	1.114;
commitid	uerp2dHq9c7mdzvA;

1.114
date	2014.12.22.14.24.56;	author espie;	state Exp;
branches;
next	1.113;
commitid	quUhL2VXB9OEK2rK;

1.113
date	2014.09.21.07.53.19;	author espie;	state Exp;
branches;
next	1.112;
commitid	XDadRWExw0EfJTlD;

1.112
date	2014.09.20.07.41.14;	author espie;	state Exp;
branches;
next	1.111;
commitid	sT70Hpi2V5VfTGq3;

1.111
date	2014.09.19.16.05.13;	author espie;	state Exp;
branches;
next	1.110;
commitid	vEDQVv3gGY05Jpgn;

1.110
date	2014.09.16.10.01.51;	author espie;	state Exp;
branches;
next	1.109;
commitid	ENOctzVlgQtBhz9a;

1.109
date	2014.09.16.08.50.26;	author espie;	state Exp;
branches;
next	1.108;
commitid	0WhwQzRBaIVpvr14;

1.108
date	2014.07.10.10.33.10;	author espie;	state Exp;
branches;
next	1.107;
commitid	svNzqY3LXHgXkQsD;

1.107
date	2014.07.01.09.52.27;	author espie;	state Exp;
branches;
next	1.106;
commitid	Z50XSr8JdmfFT2hv;

1.106
date	2014.05.20.05.46.13;	author espie;	state Exp;
branches;
next	1.105;

1.105
date	2014.04.18.10.00.48;	author schwarze;	state Exp;
branches;
next	1.104;

1.104
date	2014.03.18.20.56.30;	author espie;	state Exp;
branches;
next	1.103;

1.103
date	2014.03.18.18.53.29;	author espie;	state Exp;
branches;
next	1.102;

1.102
date	2014.03.05.22.32.32;	author espie;	state Exp;
branches;
next	1.101;

1.101
date	2014.02.02.15.35.52;	author espie;	state Exp;
branches;
next	1.100;

1.100
date	2014.01.23.22.57.06;	author espie;	state Exp;
branches;
next	1.99;

1.99
date	2014.01.23.12.32.40;	author espie;	state Exp;
branches;
next	1.98;

1.98
date	2014.01.23.11.52.34;	author espie;	state Exp;
branches;
next	1.97;

1.97
date	2014.01.20.21.10.55;	author naddy;	state Exp;
branches;
next	1.96;

1.96
date	2014.01.18.01.10.36;	author espie;	state Exp;
branches;
next	1.95;

1.95
date	2014.01.18.01.09.30;	author espie;	state Exp;
branches;
next	1.94;

1.94
date	2014.01.17.10.54.14;	author espie;	state Exp;
branches;
next	1.93;

1.93
date	2014.01.13.10.07.32;	author espie;	state Exp;
branches;
next	1.92;

1.92
date	2014.01.09.20.20.01;	author espie;	state Exp;
branches;
next	1.91;

1.91
date	2014.01.09.17.51.56;	author espie;	state Exp;
branches;
next	1.90;

1.90
date	2014.01.09.13.30.46;	author espie;	state Exp;
branches;
next	1.89;

1.89
date	2014.01.09.13.21.03;	author espie;	state Exp;
branches;
next	1.88;

1.88
date	2014.01.09.10.43.13;	author espie;	state Exp;
branches;
next	1.87;

1.87
date	2014.01.09.10.36.52;	author espie;	state Exp;
branches;
next	1.86;

1.86
date	2014.01.07.11.51.15;	author espie;	state Exp;
branches;
next	1.85;

1.85
date	2014.01.07.10.38.12;	author espie;	state Exp;
branches;
next	1.84;

1.84
date	2014.01.07.01.30.28;	author espie;	state Exp;
branches;
next	1.83;

1.83
date	2014.01.04.14.13.39;	author espie;	state Exp;
branches;
next	1.82;

1.82
date	2014.01.04.00.14.08;	author espie;	state Exp;
branches;
next	1.81;

1.81
date	2014.01.03.13.26.24;	author espie;	state Exp;
branches;
next	1.80;

1.80
date	2014.01.02.20.13.43;	author espie;	state Exp;
branches;
next	1.79;

1.79
date	2014.01.02.18.19.46;	author espie;	state Exp;
branches;
next	1.78;

1.78
date	2014.01.02.16.27.10;	author espie;	state Exp;
branches;
next	1.77;

1.77
date	2014.01.02.16.05.42;	author espie;	state Exp;
branches;
next	1.76;

1.76
date	2013.12.31.11.21.10;	author espie;	state Exp;
branches;
next	1.75;

1.75
date	2013.12.30.09.14.49;	author espie;	state Exp;
branches;
next	1.74;

1.74
date	2013.12.29.13.40.54;	author espie;	state Exp;
branches;
next	1.73;

1.73
date	2013.12.25.14.38.56;	author espie;	state Exp;
branches;
next	1.72;

1.72
date	2013.12.23.16.50.29;	author espie;	state Exp;
branches;
next	1.71;

1.71
date	2013.12.23.16.34.51;	author espie;	state Exp;
branches;
next	1.70;

1.70
date	2013.10.15.20.23.51;	author schwarze;	state Exp;
branches;
next	1.69;

1.69
date	2012.12.31.09.42.05;	author espie;	state Exp;
branches;
next	1.68;

1.68
date	2012.06.08.15.02.10;	author espie;	state Exp;
branches;
next	1.67;

1.67
date	2012.05.24.17.49.51;	author espie;	state Exp;
branches;
next	1.66;

1.66
date	2012.05.15.08.59.12;	author espie;	state Exp;
branches;
next	1.65;

1.65
date	2012.05.15.08.15.45;	author espie;	state Exp;
branches;
next	1.64;

1.64
date	2012.05.07.15.56.18;	author espie;	state Exp;
branches;
next	1.63;

1.63
date	2012.05.01.14.24.16;	author espie;	state Exp;
branches;
next	1.62;

1.62
date	2012.04.30.18.04.14;	author espie;	state Exp;
branches;
next	1.61;

1.61
date	2012.04.30.11.22.12;	author espie;	state Exp;
branches;
next	1.60;

1.60
date	2012.04.30.11.12.16;	author espie;	state Exp;
branches;
next	1.59;

1.59
date	2012.04.30.10.43.51;	author espie;	state Exp;
branches;
next	1.58;

1.58
date	2012.04.30.10.32.12;	author espie;	state Exp;
branches;
next	1.57;

1.57
date	2012.02.13.17.32.14;	author espie;	state Exp;
branches;
next	1.56;

1.56
date	2012.01.21.19.14.05;	author espie;	state Exp;
branches;
next	1.55;

1.55
date	2012.01.16.08.42.38;	author schwarze;	state Exp;
branches;
next	1.54;

1.54
date	2012.01.05.23.03.57;	author schwarze;	state Exp;
branches;
next	1.53;

1.53
date	2011.11.16.11.41.38;	author espie;	state Exp;
branches;
next	1.52;

1.52
date	2011.11.14.12.49.06;	author espie;	state Exp;
branches;
next	1.51;

1.51
date	2011.11.14.10.31.20;	author espie;	state Exp;
branches;
next	1.50;

1.50
date	2011.10.21.18.19.34;	author espie;	state Exp;
branches;
next	1.49;

1.49
date	2011.09.25.08.26.28;	author espie;	state Exp;
branches;
next	1.48;

1.48
date	2011.09.17.09.49.55;	author espie;	state Exp;
branches;
next	1.47;

1.47
date	2011.06.24.14.36.16;	author espie;	state Exp;
branches;
next	1.46;

1.46
date	2011.06.20.09.41.46;	author espie;	state Exp;
branches;
next	1.45;

1.45
date	2011.06.15.10.12.13;	author espie;	state Exp;
branches;
next	1.44;

1.44
date	2011.04.25.00.16.58;	author espie;	state Exp;
branches;
next	1.43;

1.43
date	2011.03.19.12.06.11;	author espie;	state Exp;
branches;
next	1.42;

1.42
date	2011.03.07.09.26.47;	author espie;	state Exp;
branches;
next	1.41;

1.41
date	2011.01.09.13.06.10;	author espie;	state Exp;
branches;
next	1.40;

1.40
date	2011.01.04.14.23.05;	author espie;	state Exp;
branches;
next	1.39;

1.39
date	2011.01.04.13.48.24;	author espie;	state Exp;
branches;
next	1.38;

1.38
date	2011.01.02.15.25.45;	author espie;	state Exp;
branches;
next	1.37;

1.37
date	2010.12.24.09.04.14;	author espie;	state Exp;
branches;
next	1.36;

1.36
date	2010.12.22.14.50.45;	author espie;	state Exp;
branches;
next	1.35;

1.35
date	2010.12.22.06.49.24;	author espie;	state Exp;
branches;
next	1.34;

1.34
date	2010.12.21.11.25.19;	author espie;	state Exp;
branches;
next	1.33;

1.33
date	2010.12.20.16.30.04;	author espie;	state Exp;
branches;
next	1.32;

1.32
date	2010.12.20.11.48.42;	author espie;	state Exp;
branches;
next	1.31;

1.31
date	2010.12.20.11.32.30;	author espie;	state Exp;
branches;
next	1.30;

1.30
date	2010.12.20.08.59.59;	author espie;	state Exp;
branches;
next	1.29;

1.29
date	2010.12.05.09.41.55;	author espie;	state Exp;
branches;
next	1.28;

1.28
date	2010.11.27.11.54.25;	author espie;	state Exp;
branches;
next	1.27;

1.27
date	2010.10.27.14.35.56;	author espie;	state Exp;
branches;
next	1.26;

1.26
date	2010.10.25.21.33.15;	author espie;	state Exp;
branches;
next	1.25;

1.25
date	2010.10.25.18.00.10;	author espie;	state Exp;
branches;
next	1.24;

1.24
date	2010.10.24.17.06.05;	author espie;	state Exp;
branches;
next	1.23;

1.23
date	2010.10.02.13.33.05;	author espie;	state Exp;
branches;
next	1.22;

1.22
date	2010.07.28.12.19.54;	author espie;	state Exp;
branches;
next	1.21;

1.21
date	2010.07.09.12.42.43;	author espie;	state Exp;
branches;
next	1.20;

1.20
date	2010.07.03.01.52.09;	author espie;	state Exp;
branches;
next	1.19;

1.19
date	2010.06.30.10.51.04;	author espie;	state Exp;
branches;
next	1.18;

1.18
date	2010.06.30.10.41.42;	author espie;	state Exp;
branches;
next	1.17;

1.17
date	2010.06.30.10.31.52;	author espie;	state Exp;
branches;
next	1.16;

1.16
date	2010.06.25.10.21.41;	author espie;	state Exp;
branches;
next	1.15;

1.15
date	2010.06.20.08.32.26;	author espie;	state Exp;
branches;
next	1.14;

1.14
date	2010.06.14.22.08.24;	author espie;	state Exp;
branches;
next	1.13;

1.13
date	2010.06.11.23.44.37;	author espie;	state Exp;
branches;
next	1.12;

1.12
date	2010.06.09.10.47.05;	author espie;	state Exp;
branches;
next	1.11;

1.11
date	2010.06.09.10.41.19;	author espie;	state Exp;
branches;
next	1.10;

1.10
date	2010.06.09.10.22.54;	author espie;	state Exp;
branches;
next	1.9;

1.9
date	2010.06.09.07.26.01;	author espie;	state Exp;
branches;
next	1.8;

1.8
date	2010.06.08.07.49.00;	author espie;	state Exp;
branches;
next	1.7;

1.7
date	2010.06.08.07.25.38;	author espie;	state Exp;
branches;
next	1.6;

1.6
date	2010.06.07.13.51.19;	author espie;	state Exp;
branches;
next	1.5;

1.5
date	2010.06.06.11.00.40;	author espie;	state Exp;
branches;
next	1.4;

1.4
date	2010.06.05.12.27.40;	author espie;	state Exp;
branches;
next	1.3;

1.3
date	2010.06.05.09.15.55;	author espie;	state Exp;
branches;
next	1.2;

1.2
date	2010.06.04.17.29.53;	author espie;	state Exp;
branches;
next	1.1;

1.1
date	2010.06.04.13.19.39;	author espie;	state Exp;
branches;
next	;


desc
@@


1.124
log
@-V option for pkg_create and incorporate version into signatures.
@
text
@#! /usr/bin/perl
# ex:ts=8 sw=4:
# $OpenBSD: PkgCreate.pm,v 1.123 2016/10/03 13:17:30 espie Exp $
#
# Copyright (c) 2003-2014 Marc Espie <espie@@openbsd.org>
#
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

use strict;
use warnings;

use OpenBSD::AddCreateDelete;
use OpenBSD::Dependencies;
use OpenBSD::SharedLibs;
use OpenBSD::Signer;

package OpenBSD::PkgCreate::State;
our @@ISA = qw(OpenBSD::CreateSign::State);

sub init
{
	my $self = shift;

	$self->{stash} = {};
	$self->SUPER::init(@@_);
	$self->{simple_status} = 0;
}

sub stash
{
	my ($self, $key) = @@_;
	return $self->{stash}{$key};
}

sub error
{
	my $self = shift;
	my $msg = shift;
	$self->{bad}++;
	$self->progress->disable;
	$self->errsay("Error: $msg", @@_);
}

sub set_status
{
	my ($self, $status) = @@_;
	if ($self->{simple_status}) {
		print "\n$status";
	} else {
		if ($self->progress->set_header($status)) {
			$self->progress->message('');
		} else {
			$| = 1;
			print "$status...";
			$self->{simple_status} = 1;
		}
	}
}

sub end_status
{
	my $self = shift;

	if ($self->{simple_status}) {
		print "\n";
	} else {
		$self->progress->clear;
	}
}

sub handle_options
{
	my $state = shift;

	$state->{system_version} = 0;
	$state->{opt} = {
	    'f' =>
		    sub {
			    push(@@{$state->{contents}}, shift);
		    },
	    'p' => 
		    sub {
			    $state->{prefix} = shift;
		    },
	    'P' => sub {
			    my $d = shift;
			    $state->{dependencies}{$d} = 1;
		    },
	    'V' => sub {
			    my $d = shift;
			    if ($d !~ m/^\d+$/) {
			    	$state->usage("-V number");
			    }
			    $state->{system_version} += $d;
		    },
	    'W' => sub {
			    my $w = shift;
			    $state->{wantlib}{$w} = 1;
		    },
	};
	$state->{no_exports} = 1;
	$state->SUPER::handle_options('p:f:d:M:U:A:B:P:V:W:qQ',
	    '[-nQqvx] [-A arches] [-B pkg-destdir] [-D name[=value]]',
	    '[-L localbase] [-M displayfile] [-P pkg-dependency]',
	    '[-U undisplayfile] [-V n] [-W wantedlib]',
	    '[-d desc -D COMMENT=value -f packinglist -p prefix]',
	    'pkg-name');

	my $base = '/';
	if (defined $state->opt('B')) {
		$base = $state->opt('B');
	} 

	$state->{base} = $base;
}

package OpenBSD::PkgCreate;

use OpenBSD::PackingList;
use OpenBSD::PackageInfo;
use OpenBSD::Getopt;
use OpenBSD::Temp;
use OpenBSD::Error;
use OpenBSD::Ustar;
use OpenBSD::ArcCheck;
use OpenBSD::Paths;
use File::Basename;

# Extra stuff needed to archive files
package OpenBSD::PackingElement;
sub create_package
{
	my ($self, $state) = @@_;

	$self->archive($state);
	if ($state->verbose) {
		$self->comment_create_package($state);
	}
}

sub pretend_to_archive
{
	my ($self, $state) = @@_;
	$self->comment_create_package($state);
}

sub record_digest {}
sub archive {}
sub really_archived { 0 }
sub comment_create_package {}
sub grab_manpages {}

sub print_file {}

sub avert_duplicates_and_other_checks
{
	my ($self, $state) = @@_;
	return unless $self->NoDuplicateNames;
	my $n = $self->fullname;
	if (defined $state->stash($n)) {
		$state->error("duplicate item in packing-list #1", $n);
	}
	$state->{stash}{$n} = 1;
}

sub makesum_plist
{
	my ($self, $state, $plist) = @@_;
	$self->add_object($plist);
}

sub verify_checksum
{
}

sub register_forbidden
{
	my ($self, $state) = @@_;
	if ($self->is_forbidden) {
		push(@@{$state->{forbidden}}, $self);
	}
}

sub is_forbidden() { 0 }
sub resolve_link
{
	my ($filename, $base, $level) = @@_;
	$level //= 0;
	if (-l $filename) {
		my $l = readlink($filename);
		if ($level++ > 14) {
			return undef;
		}
		if ($l =~ m|^/|) {
			return $base.resolve_link($l, $base, $level);
		} else {
			return resolve_link(File::Spec->catfile(File::Basename::dirname($filename),$l), $base, $level);
		}
	} else {
		return $filename;
	}
}

sub compute_checksum
{
	my ($self, $result, $state, $base) = @@_;
	my $name = $self->fullname;
	my $fname = $name;
	if (defined $base) {
		$fname = $base.$fname;
	}
	for my $field (qw(symlink link size ts)) {  # md5
		if (defined $result->{$field}) {
			$state->error("User tried to define @@#1 for #2",
			    $field, $fname);
		}
	}
	if (defined $self->{wtempname}) {
		$fname = $self->{wtempname};
	}
	if (-l $fname) {
		if (!defined $base) {
			$state->error("special file #1 can't be a symlink",
			    $self->stringize);
		}
		my $value = readlink $fname;
		my $chk = resolve_link($fname, $base);
		$fname =~ s|^//|/|; # cosmetic
		if (!defined $chk) {
			$state->error("bogus symlink: #1 (too deep)", $fname);
		} elsif (!-e $chk) {
			push(@@{$state->{bad_symlinks}{$chk}}, $fname);
		}
		$result->make_symlink($value);
	} elsif (-f _) {
		my ($dev, $ino, $size, $mtime) = (stat _)[0,1,7, 9];
		# XXX when rebuilding packages, tied updates can produce
		# spurious hardlinks. We also refer to the installed plist 
		# we're rebuilding to know if we must checksum.
		if (defined $state->stash("$dev/$ino") && !defined $self->{d}) {
			$result->make_hardlink($state->stash("$dev/$ino"));
		} else {
			$state->{stash}{"$dev/$ino"} = $name;
			$result->add_digest($self->compute_digest($fname))
			    unless $state->{bad};
			$result->add_size($size);
			$result->add_timestamp($mtime);
		}
	} elsif (-d _) {
		$state->error("#1 should be a file and not a directory", $fname);
	} else {
		$state->error("#1 does not exist", $fname);
	}
}

sub makesum_plist_with_base
{
	my ($self, $plist, $state, $base) = @@_;
	$self->compute_checksum($self, $state, $base);
	$self->add_object($plist);
}

sub verify_checksum_with_base
{
	my ($self, $state, $base) = @@_;
	my $check = ref($self)->new($self->name);
	$self->compute_checksum($check, $state, $base);

	for my $field (qw(symlink link size)) {  # md5
		if ((defined $check->{$field} && defined $self->{$field} &&
		    $check->{$field} ne $self->{$field}) ||
		    (defined $check->{$field} xor defined $self->{$field})) {
		    	$state->error("#1 inconsistency for #2",
			    $field, $self->fullname);
		}
	}
	if ((defined $check->{d} && defined $self->{d} &&
	    !$check->{d}->equals($self->{d})) ||
	    (defined $check->{d} xor defined $self->{d})) {
	    	$state->error("checksum inconsistency for #1",
		    $self->fullname);
	}
}


sub prepare_for_archival
{
	my ($self, $state) = @@_;

	my $o = $state->{archive}->prepare_long($self);
	if (!$o->verify_modes($self)) {
		$state->error("modes don't match for #1", $self->fullname);
	}
	if (!$o->is_allowed) {
		$state->error("can't package #1", $self->fullname);
	}
	return $o;
}

sub discover_directories
{
}

sub check_version
{
}

package OpenBSD::PackingElement::StreamMarker;
our @@ISA = qw(OpenBSD::PackingElement::Meta);
sub new
{
	my $class = shift;
	bless {}, $class;
}

sub comment_create_package
{
	my ($self, $state) = @@_;
	$self->SUPER::comment_create_package($state);
	$state->say("Gzip: next chunk");
}

sub archive
{
	my ($self, $state) = @@_;
	$state->new_gstream;
}

package OpenBSD::PackingElement::Meta;
sub record_digest
{
	my ($self, $original, $entries, $new, $tail) = @@_;
	push(@@$new, $self);
}

package OpenBSD::PackingElement::RcScript;
sub set_destdir
{
	my ($self, $state) = @@_;
	if ($self->name =~ m/^\//) {
		$state->{archive}->destdir($state->{base});
	} else {
		$self->SUPER::set_destdir($state);
	}
}

package OpenBSD::PackingElement::SpecialFile;
sub archive
{
	&OpenBSD::PackingElement::FileBase::archive;
}

sub pretend_to_archive
{
	&OpenBSD::PackingElement::FileBase::pretend_to_archive;
}

sub set_destdir
{
}

sub may_add
{
	my ($class, $subst, $plist, $opt) = @@_;
	if (defined $opt) {
		my $o = $class->add($plist);
		$subst->copy($opt, $o->fullname) if defined $o->fullname;
	}
}

sub comment_create_package
{
	my ($self, $state) = @@_;
	$state->say("Adding #1", $self->name);
}

sub makesum_plist
{
	my ($self, $state, $plist) = @@_;
	$self->makesum_plist_with_base($plist, $state, undef);
}

sub verify_checksum
{
	my ($self, $state) = @@_;
	$self->verify_checksum_with_base($state, undef);
}

sub prepare_for_archival
{
	my ($self, $state) = @@_;

	my $o = $state->{archive}->prepare_long($self);
	$o->{uname} = 'root';
	$o->{gname} = 'wheel';
	$o->{uid} = 0;
	$o->{gid} = 0;
	$o->{mode} &= 0555; # zap all write and suid modes
	return $o;
}

sub forbidden() { 1 }

# override for CONTENTS: we cannot checksum this.
package OpenBSD::PackingElement::FCONTENTS;
sub makesum_plist
{
}

sub verify_checksum
{
}

sub archive
{
	my ($self, $state) = @@_;
	$self->SUPER::archive($state);
	$state->new_gstream;
}

sub comment_create_package
{
	my ($self, $state) = @@_;
	$self->SUPER::comment_create_package($state);
	$state->say("GZIP: END OF SIGNATURE CHUNK");
}

package OpenBSD::PackingElement::Cwd;
sub archive
{
	my ($self, $state) = @@_;
}

sub pretend_to_archive
{
	my ($self, $state) = @@_;
	$self->comment_create_package($state);
}

sub comment_create_package
{
	my ($self, $state) = @@_;
	$state->say("Cwd: #1", $self->name);
}

package OpenBSD::PackingElement::FileBase;

sub record_digest
{
	my ($self, $original, $entries, $new, $tail) = @@_;
	if (defined $self->{d}) {
		my $k = $self->{d}->stringize;
		push(@@{$entries->{$k}}, $self);
		push(@@$original, $k);
	} else {
		push(@@$tail, $self);
	}
}

sub set_destdir
{
	my ($self, $state) = @@_;

	$state->{archive}->destdir($state->{base}."/".$self->cwd);
}

sub archive
{
	my ($self, $state) = @@_;

	$self->set_destdir($state);
	my $o = $self->prepare_for_archival($state);

	$o->write unless $state->{bad};
}

sub really_archived { 1 }
sub pretend_to_archive
{
	my ($self, $state) = @@_;

	$self->set_destdir($state);
	$self->prepare_for_archival($state);
	$self->comment_create_package($state);
}

sub comment_create_package
{
	my ($self, $state) = @@_;
	$state->say("Adding #1", $self->name);
}

sub print_file
{
	my ($item) = @@_;
	print '@@', $item->keyword, " ", $item->fullname, "\n";
}

sub makesum_plist
{
	my ($self, $state, $plist) = @@_;
	$self->makesum_plist_with_base($plist, $state, $state->{base});
}

sub verify_checksum
{
	my ($self, $state) = @@_;
	$self->verify_checksum_with_base($state, $state->{base});
}

package OpenBSD::PackingElement::Dir;
sub discover_directories
{
	my ($self, $state) = @@_;
	$state->{known_dirs}->{$self->fullname} = 1;
}

package OpenBSD::PackingElement::InfoFile;
sub makesum_plist
{
	my ($self, $state, $plist) = @@_;
	$self->SUPER::makesum_plist($state, $plist);
	my $fname = $self->fullname;
	for (my $i = 1; ; $i++) {
		if (-e "$state->{base}/$fname-$i") {
			my $e = OpenBSD::PackingElement::File->add($plist, $self->name."-".$i);
			$e->compute_checksum($e, $state, $state->{base});
		} else {
			last;
		}
	}
}

package OpenBSD::PackingElement::Manpage;
use File::Basename;

sub grab_manpages
{
	my ($self, $state) = @@_;
	my $filename;
	if ($self->{wtempname}) {
		$filename = $self->{wtempname};
	} else {
		$filename = $state->{base}.$self->fullname;
	}
	push(@@{$state->{manpages}}, $filename);
}

sub makesum_plist
{
	my ($self, $state, $plist) = @@_;
	if ($state->{subst}->empty("USE_GROFF") || !$self->is_source) {
		return $self->SUPER::makesum_plist($state, $plist);
	}
	my $dest = $self->source_to_dest;
	my $fullname = $self->cwd."/".$dest;
	my $d = dirname($fullname);
	$state->{mandir} //= OpenBSD::Temp::permanent_dir(
	    $ENV{TMPDIR} // '/tmp', "manpage");
	my $tempname = $state->{mandir}."/".$fullname;
	require File::Path;
	File::Path::make_path($state->{mandir}."/".$d);
	open my $fh, ">", $tempname or $state->error("can't create #1: #2",
	    $tempname, $!);
	chmod 0444, $fh;
	if (-d $state->{base}.$d) {
		undef $d;
	}
	$self->format($state, $tempname, $fh) or return;
	if (-z $tempname) {
		$state->errsay("groff produced empty result for #1", $dest);
		$state->errsay("\tkeeping source manpage");
		return $self->SUPER::makesum_plist($state, $plist);
	}
	if (defined $d && !$state->{known_dirs}->{$d}) {
		$state->{known_dirs}->{$d} = 1;
		OpenBSD::PackingElement::Dir->add($plist, dirname($dest));
	}
	my $e = OpenBSD::PackingElement::Manpage->add($plist, $dest);
	$e->{wtempname} = $tempname;
	$e->compute_checksum($e, $state, $state->{base});
}

package OpenBSD::PackingElement::Depend;
sub avert_duplicates_and_other_checks
{
	my ($self, $state) = @@_;
	if (!$self->spec->is_valid) {
		$state->error("invalid \@@#1 #2 in packing-list",
		    $self->keyword, $self->stringize);
	}
	$self->SUPER::avert_duplicates_and_other_checks($state);
}

sub forbidden() { 1 }

package OpenBSD::PackingElement::Conflict;
sub avert_duplicates_and_other_checks
{
	$_[1]->{has_conflict}++;
	&OpenBSD::PackingElement::Depend::avert_duplicates_and_other_checks;
}

package OpenBSD::PackingElement::AskUpdate;
sub avert_duplicates_and_other_checks
{
	&OpenBSD::PackingElement::Depend::avert_duplicates_and_other_checks;
}

package OpenBSD::PackingElement::Dependency;
sub avert_duplicates_and_other_checks
{
	my ($self, $state) = @@_;

	$self->SUPER::avert_duplicates_and_other_checks($state);

	my @@issues = OpenBSD::PackageName->from_string($self->{def})->has_issues;
	if (@@issues > 0) {
		$state->error("\@@#1 #2\n  #3, #4",
		    $self->keyword, $self->stringize,
		    $self->{def}, join(' ', @@issues));
	} elsif ($self->spec->is_valid) {
		my @@m = $self->spec->filter($self->{def});
		if (@@m == 0) {
			$state->error("\@@#1 #2\n  pattern #3 doesn't match default #4\n",
			    $self->keyword, $self->stringize,
			    $self->{pattern}, $self->{def});
		}
	}
}

package OpenBSD::PackingElement::Name;
sub avert_duplicates_and_other_checks
{
	my ($self, $state) = @@_;

	my @@issues = OpenBSD::PackageName->from_string($self->name)->has_issues;
	if (@@issues > 0) {
		$state->error("bad package name #1: ", $self->name,
		    join(' ', @@issues));
	}
	$self->SUPER::avert_duplicates_and_other_checks($state);
}

sub forbidden() { 1 }

package OpenBSD::PackingElement::NoDefaultConflict;
sub avert_duplicates_and_other_checks
{
	my ($self, $state) = @@_;
	$state->{has_no_default_conflict}++;
}


package OpenBSD::PackingElement::Lib;
sub check_version
{
	my ($self, $state, $unsubst) = @@_;
	my @@l  = $self->parse($self->name);
	if (defined $l[0]) {
		if (!$unsubst =~ m/\$\{LIB$l[0]_VERSION\}/) {
			$state->error("Incorrectly versioned shared library: #1", $unsubst);
		}
	} else {
		$state->error("Invalid shared library #1", $unsubst);
	}
	$state->{has_libraries} = 1;
}

package OpenBSD::PackingElement::DigitalSignature;
sub is_forbidden() { 1 }

package OpenBSD::PackingElement::Signer;
sub is_forbidden() { 1 }

package OpenBSD::PackingElement::ExtraInfo;
sub is_forbidden() { 1 }

package OpenBSD::PackingElement::ManualInstallation;
sub is_forbidden() { 1 }

package OpenBSD::PackingElement::Firmware;
sub is_forbidden() { 1 }

package OpenBSD::PackingElement::Url;
sub is_forbidden() { 1 }

package OpenBSD::PackingElement::Arch;
sub is_forbidden() { 1 }

package OpenBSD::PackingElement::LocalBase;
sub is_forbidden() { 1 }

package OpenBSD::PackingElement::Fragment;
our @@ISA=qw(OpenBSD::PackingElement);

sub needs_keyword() { 0 }

sub stringize
{
	return '%%'.shift->{name}.'%%';
}

package OpenBSD::PackingElement::NoFragment;
our @@ISA=qw(OpenBSD::PackingElement::Fragment);
sub stringize
{
	return '!%%'.shift->{name}.'%%';
}

# put together file and filename, in order to handle fragments simply
package MyFile;
sub new
{
	my ($class, $filename) = @@_;

	open(my $fh, '<', $filename) or die "Missing file $filename";

	bless { fh => $fh, name => $filename }, (ref($class) || $class);
}

sub readline
{
	my $self = shift;
	return readline $self->{fh};
}

sub name
{
	my $self = shift;
	return $self->{name};
}

sub close
{
	my $self = shift;
	close($self->{fh});
}

sub deduce_name
{
	my ($self, $frag, $not) = @@_;

	my $o = $self->name;
	my $noto = $o;
	my $nofrag = "no-$frag";

	$o =~ s/PFRAG\./PFRAG.$frag-/o or
	    $o =~ s/PLIST/PFRAG.$frag/o;

	$noto =~ s/PFRAG\./PFRAG.no-$frag-/o or
	    $noto =~ s/PLIST/PFRAG.no-$frag/o;
	unless (-e $o or -e $noto) {
		die "Missing fragments for $frag: $o and $noto don't exist";
	}
	if ($not) {
		return $noto if -e $noto;
    	} else {
		return $o if -e $o;
	}
	return;
}

# special solver class for PkgCreate
package OpenBSD::Dependencies::CreateSolver;
our @@ISA = qw(OpenBSD::Dependencies::SolverBase);

# we need to "hack" a special set
sub new
{
	my ($class, $plist) = @@_;
	bless { set => OpenBSD::PseudoSet->new($plist), bad => [] }, $class;
}

sub solve_all_depends
{
	my ($solver, $state) = @@_;

	while (1) {
		my @@todo = $solver->solve_depends($state);
		if (@@todo == 0) {
			return;
		}
		if ($solver->solve_wantlibs($state, 0)) {
			return;
		}
		$solver->{set}->add_new(@@todo);
	}
}

sub solve_wantlibs
{
	my ($solver, $state, $final) = @@_;

	my $okay = 1;
	my $lib_finder = OpenBSD::lookup::library->new($solver);
	my $h = $solver->{set}->{new}[0];
	for my $lib (@@{$h->{plist}->{wantlib}}) {
		$solver->{localbase} = $h->{plist}->localbase;
		next if $lib_finder->lookup($solver,
		    $solver->{to_register}->{$h}, $state,
		    $lib->spec);
		$okay = 0;
		OpenBSD::SharedLibs::report_problem($state,
		    $lib->spec) if $final;
	}
	if (!$okay && $final) {
		$solver->dump($state);
		$lib_finder->dump($state);
	}
	return $okay;
}

sub really_solve_dependency
{
	my ($self, $state, $dep, $package) = @@_;

	$state->progress->message($dep->{pkgpath});

	# look in installed packages
	my $v = $self->find_dep_in_installed($state, $dep);
	if (!defined $v) {
		$v = $self->find_dep_in_self($state, $dep);
	}

	# and in portstree otherwise
	if (!defined $v) {
		$v = $self->solve_from_ports($state, $dep, $package);
	}
	return $v;
}

sub diskcachename
{
	my ($self, $dep) = @@_;

	if ($ENV{_DEPENDS_CACHE}) {
		my $diskcache = $dep->{pkgpath};
		$diskcache =~ s/\//--/g;
		return $ENV{_DEPENDS_CACHE}."/pkgcreate-".$diskcache;
	} else {
		return undef;
	}
}

sub to_cache
{
	my ($self, $plist, $final) = @@_;
	# try to cache atomically. 
	# no error if it doesn't work
	require OpenBSD::MkTemp;
	my ($fh, $tmp) = OpenBSD::MkTemp::mkstemp(
	    "$ENV{_DEPENDS_CACHE}/my.XXXXXXXXXXX") or return;
	chmod 0644, $fh;
	$plist->write($fh);
	close($fh);
	rename($tmp, $final);
	unlink($tmp);
}

sub ask_tree
{
	my ($self, $state, $dep, $portsdir, @@action) = @@_;

	my $make = OpenBSD::Paths->make;
	my $pid = open(my $fh, "-|");
	if (!defined $pid) {
		$state->fatal("cannot fork: $!");
	}
	if ($pid == 0) {
		chdir $portsdir or exit 2;
		open STDERR, '>', '/dev/null';
		$ENV{FULLPATH} = 'Yes';
		delete $ENV{FLAVOR};
		delete $ENV{SUBPACKAGE};
		$ENV{SUBDIR} = $dep->{pkgpath};
		$ENV{ECHO_MSG} = ':';
		exec $make ('make', @@action);
	}
	my $plist = OpenBSD::PackingList->read($fh,
	    \&OpenBSD::PackingList::PrelinkStuffOnly);
	close($fh);
	return $plist;
}

sub really_solve_from_ports
{
	my ($self, $state, $dep, $portsdir) = @@_;

	my $diskcache = $self->diskcachename($dep);
	my $plist;

	if (defined $diskcache && -f $diskcache) {
		$plist = OpenBSD::PackingList->fromfile($diskcache);
	} else {
		$plist = $self->ask_tree($state, $dep, $portsdir,
		    'print-plist-libs-with-depends',
		    'wantlib_args=no-wantlib-args');
		if ($? != 0 || !defined $plist->pkgname) {
			return undef;
		}
		if (defined $diskcache) {
			$self->to_cache($plist, $diskcache);
		}
	}
	OpenBSD::SharedLibs::add_libs_from_plist($plist, $state);
	$self->add_dep($plist);
	return $plist->pkgname;
}

my $cache = {};

sub solve_from_ports
{
	my ($self, $state, $dep, $package) = @@_;

	my $portsdir = $state->defines('PORTSDIR');
	return undef unless defined $portsdir;
	my $pkgname;
	if (defined $cache->{$dep->{pkgpath}}) {
		$pkgname = $cache->{$dep->{pkgpath}};
	} else {
		$pkgname = $self->really_solve_from_ports($state, $dep, 
		    $portsdir);
		$cache->{$dep->{pkgpath}} = $pkgname;
	}
	if (!defined $pkgname) {
		$state->error("Can't obtain dependency #1 from ports tree",
		    $dep->{pattern});
		return undef;
	}
	if ($dep->spec->filter($pkgname) == 0) {
		$state->error("Dependency #1 doesn't match FULLPKGNAME: #2",
		    $dep->{pattern}, $pkgname);
		return undef;
	}

	return $pkgname;
}

# we don't want old libs
sub find_old_lib
{
	return undef;
}

package OpenBSD::PseudoHandle;
sub new
{
	my ($class, $plist) = @@_;
	bless { plist => $plist}, $class;
}

sub pkgname
{
	my $self = shift;

	return $self->{plist}->pkgname;
}

sub dependency_info
{
	my $self = shift;
	return $self->{plist};
}

package OpenBSD::PseudoSet;
sub new
{
	my ($class, @@elements) = @@_;

	my $o = bless {}, $class;
	$o->add_new(@@elements);
}

sub add_new
{
	my ($self, @@elements) = @@_;
	for my $i (@@elements) {
		push(@@{$self->{new}}, OpenBSD::PseudoHandle->new($i));
	}
	return $self;
}

sub newer
{
	return @@{shift->{new}};
}


sub newer_names
{
	return map {$_->pkgname} @@{shift->{new}};
}

sub older
{
	return ();
}

sub older_names
{
	return ();
}

sub kept
{
	return ();
}

sub kept_names
{
	return ();
}

sub print
{
	my $self = shift;
	return $self->{new}[0]->pkgname;
}

package OpenBSD::PkgCreate;
our @@ISA = qw(OpenBSD::AddCreateDelete);

sub handle_fragment
{
	my ($self, $state, $old, $not, $frag, undef, $cont, $msg) = @@_;
	my $def = $frag;
	if ($state->{subst}->has_fragment($def, $frag, $msg)) {
		return undef if defined $not;
	} else {
		return undef unless defined $not;
	}
	my $newname = $old->deduce_name($frag, $not);
	if (defined $newname) {
		$state->set_status("switching to $newname")
		    if !defined $state->opt('q');
		return $old->new($newname);
	}
	return undef;
}

sub FileClass
{
	return "MyFile";
}

sub read_fragments
{
	my ($self, $state, $plist, $filename) = @@_;

	my $stack = [];
	my $subst = $state->{subst};
	push(@@$stack, $self->FileClass->new($filename));
	my $fast = $subst->value("LIBS_ONLY");

	return $plist->read($stack,
	    sub {
		my ($stack, $cont) = @@_;
		while(my $file = pop @@$stack) {
			while (my $l = $file->readline) {
				$state->progress->working(2048) unless $state->opt('q');
				if ($l =~m/^(\@@comment\s+\$(?:Open)BSD\$)$/o) {
					$l = '@@comment $'.'OpenBSD: '.basename($file->name).',v$';
				}
				if ($l =~ m/^(\!)?\%\%(.*)\%\%$/) {
					if (my $f2 = $self->handle_fragment($state, $file, $1, $2, $l, $cont, $filename)) {
						push(@@$stack, $file);
						$file = $f2;
					}
					next;
				}
				my $s = $subst->do($l);
				if ($fast) {
					next unless $s =~ m/^\@@(?:cwd|lib|depend|wantlib)\b/o || $s =~ m/lib.*\.a$/o;
				}
	# XXX some things, like @@comment no checksum, don't produce an object
				my $o = &$cont($s);
				if (defined $o) {
					$o->check_version($state, $s);
					$self->annotate($o, $l, $file);
				}
			}
		}
	    });
}

sub annotate
{
}

sub add_description
{
	my ($state, $plist, $name, $opt_d) = @@_;
	my $o = OpenBSD::PackingElement::FDESC->add($plist, $name);
	my $subst = $state->{subst};
	my $comment = $subst->value('COMMENT');
	if (defined $comment) {
		if (length $comment > 60) {
			$state->fatal("comment is too long\n#1\n#2\n",
			    $comment, ' 'x60 . "^" x (length($comment)-60));
		}
	} else {
		$state->usage("Comment required");
	}
	if (!defined $opt_d) {
		$state->usage("Description required");
	}
	return if $state->opt('q');

	open(my $fh, '>', $o->fullname) or die "Can't write to DESC: $!";
	if (defined $comment) {
		print $fh $subst->do($comment), "\n";
	}
	if ($opt_d =~ /^\-(.*)$/o) {
		print $fh $1, "\n";
	} else {
		$subst->copy_fh($opt_d, $fh);
	}
	if (defined $comment) {
		if ($subst->empty('MAINTAINER')) {
			$state->errsay("no MAINTAINER");
		} else {
			print $fh "\n", 
			    $subst->do('Maintainer: ${MAINTAINER}'), "\n";
		}
		if (!$subst->empty('HOMEPAGE')) {
			print $fh "\n", $subst->do('WWW: ${HOMEPAGE}'), "\n";
		}
	}
	close($fh);
}

sub add_extra_info
{
	my ($self, $plist, $state) = @@_;

	my $subst = $state->{subst};
	my $fullpkgpath = $subst->value('FULLPKGPATH');
	my $cdrom = $subst->value('PERMIT_PACKAGE_CDROM') ||
	    $subst->value('CDROM');;
	my $ftp = $subst->value('PERMIT_PACKAGE_FTP') ||
	    $subst->value('FTP');
	if (defined $fullpkgpath || defined $cdrom || defined $ftp) {
		$fullpkgpath //= '';
		$cdrom //= 'no';
		$ftp //= 'no';
		$cdrom = 'yes' if $cdrom =~ m/^yes$/io;
		$ftp = 'yes' if $ftp =~ m/^yes$/io;

		OpenBSD::PackingElement::ExtraInfo->add($plist,
		    $fullpkgpath, $cdrom, $ftp);
	} else {
		$state->errsay("Package without FULLPKGPATH");
	}
}

sub add_elements
{
	my ($self, $plist, $state) = @@_;

	my $subst = $state->{subst};
	add_description($state, $plist, DESC, $state->opt('d'));
	OpenBSD::PackingElement::FDISPLAY->may_add($subst, $plist,
	    $state->opt('M'));
	OpenBSD::PackingElement::FUNDISPLAY->may_add($subst, $plist,
	    $state->opt('U'));
	for my $d (sort keys %{$state->{dependencies}}) {
		OpenBSD::PackingElement::Dependency->add($plist, $d);
	}

	for my $w (sort keys %{$state->{wantlib}}) {
		OpenBSD::PackingElement::Wantlib->add($plist, $w);
	}

	if (defined $state->opt('A')) {
		OpenBSD::PackingElement::Arch->add($plist, $state->opt('A'));
	}

	if (defined $state->opt('L')) {
		OpenBSD::PackingElement::LocalBase->add($plist, $state->opt('L'));
	}
	$self->add_extra_info($plist, $state);
	if ($state->{system_version}) {
		OpenBSD::PackingElement::Version->add($plist, 
		    $state->{system_version});
    	}
}

sub cant_read_fragment
{
	my ($self, $state, $frag) = @@_;
	$state->fatal("can't read packing-list #1", $frag);
}

sub read_all_fragments
{
	my ($self, $state, $plist) = @@_;

	if (defined $state->{prefix}) {
		OpenBSD::PackingElement::Cwd->add($plist, $state->{prefix});
	} else {
		$state->usage("Prefix required");
	}
	for my $contentsfile (@@{$state->{contents}}) {
		$self->read_fragments($state, $plist, $contentsfile) or
		    $self->cant_read_fragment($state, $contentsfile);
	}

	$plist->register_forbidden($state);
	if (defined $state->{forbidden}) {
		for my $e (@@{$state->{forbidden}}) {
			$state->errsay("Error: #1 can't be set explicitly", "\@@".$e->keyword." ".$e->stringize);
		}
		$state->fatal("Can't continue");
	}
}

sub create_plist
{
	my ($self, $state, $pkgname) = @@_;

	my $plist = OpenBSD::PackingList->new;

	if ($pkgname =~ m|([^/]+)$|o) {
		$pkgname = $1;
		$pkgname =~ s/\.tgz$//o;
	}
	$state->say("Creating package #1", $pkgname)
	    if !(defined $state->opt('q')) && $state->opt('v');
	if (!$state->opt('q')) {
		$plist->set_infodir(OpenBSD::Temp->dir);
	}

	unless (defined $state->opt('q') && defined $state->opt('n')) {
		$state->set_status("reading plist");
	}
	$self->read_all_fragments($state, $plist);
	$plist->set_pkgname($pkgname);

	$self->add_elements($plist, $state);
	return $plist;
}

sub make_plist_with_sum
{
	my ($self, $state, $plist) = @@_;
	my $p2 = OpenBSD::PackingList->new;
	$state->progress->visit_with_count($plist, 'makesum_plist', $p2);
	$p2->set_infodir($plist->infodir);
	return $p2;
}

sub read_existing_plist
{
	my ($self, $state, $contents) = @@_;

	my $plist = OpenBSD::PackingList->new;
	if (-d $contents && -f $contents.'/'.CONTENTS) {
		$plist->set_infodir($contents);
		$contents .= '/'.CONTENTS;
	} else {
		$plist->set_infodir(dirname($contents));
	}
	$plist->fromfile($contents) or
	    $state->fatal("can't read packing-list #1", $contents);
	return $plist;
}

sub create_package
{
	my ($self, $state, $plist, $ordered, $wname) = @@_;

	$state->say("Creating gzip'd tar ball in '#1'", $wname)
	    if $state->opt('v');
	my $h = sub {
		unlink $wname;
		my $caught = shift;
		$SIG{$caught} = 'DEFAULT';
		kill $caught, $$;
	};

	local $SIG{'INT'} = $h;
	local $SIG{'QUIT'} = $h;
	local $SIG{'HUP'} = $h;
	local $SIG{'KILL'} = $h;
	local $SIG{'TERM'} = $h;
	$state->{archive} = $state->create_archive($wname, $plist->infodir);
	$state->set_status("archiving");
	my $p = $state->progress->new_sizer($plist, $state);
	for my $e (@@$ordered) {
		$e->create_package($state);
		$p->advance($e);
	}
	$state->end_status;
	$state->{archive}->close;
	if ($state->{bad}) {
		unlink($wname);
		exit(1);
	}
}

sub show_bad_symlinks
{
	my ($self, $state) = @@_;
	for my $dest (sort keys %{$state->{bad_symlinks}}) {
		$state->errsay("Warning: symlink(s) point to non-existent #1",
		    $dest);
		for my $link (@@{$state->{bad_symlinks}{$dest}}) {
			$state->errsay("\t#1", $link);
		}
	}
}

sub check_dependencies
{
	my ($self, $plist, $state) = @@_;

	my $solver = OpenBSD::Dependencies::CreateSolver->new($plist);

	# look for libraries in the "real" tree
	$state->{destdir} = '/';

	$solver->solve_all_depends($state);
	if (!$solver->solve_wantlibs($state, 1)) {
		$state->{bad}++;
	}
}

sub finish_manpages
{
	my ($self, $state, $plist) = @@_;
	$plist->grab_manpages($state);
	if (defined $state->{manpages}) {
		$state->run_makewhatis(['-t'], $state->{manpages});
	}

	if (defined $state->{mandir}) {
		require File::Path;
		File::Path::remove_tree($state->{mandir});
	}
}

sub save_history
{
	my ($self, $plist, $dir) = @@_;

	# grab the old stuff:
	# - order
	# - and presence
	my (%known, %found);
	my $fname;
	if (defined $dir) {
		unless (-d $dir) {
			require File::Path;

			File::Path::make_path($dir);
		}

		my $name = $plist->fullpkgpath;
		$name =~ s,/,.,g;
		my $fname = "$dir/$name";
		my $n = 0;

		if (open(my $f, '<', $fname)) {
			while (<$f>) {
				chomp;
				$known{$_} //= $n++;
			}
			close($f);
		}
	}
	my @@new;
	my $entries = {};
	my $list = [];
	my $tail = [];
	$plist->record_digest(\@@new, $entries, $list, $tail);

	my $f;
	if (defined $fname) {
		open($f, ">", "$fname.new");
	}
	
	# split list
	# - first, unknown stuff
	for my $h (@@new) {
		if ($known{$h}) {
			$found{$h} = $known{$h};
		} else {
			print $f "$h\n" if defined $f;
			push(@@$list, (shift @@{$entries->{$h}}));
		}
	}
	# - then known stuff, preserve the order
	for my $h (sort  {$found{$a} <=> $found{$b}} keys %found) {
		print $f "$h\n" if defined $f;
		push(@@$list, @@{$entries->{$h}});
	}
	if (defined $f) {
		close($f);
		rename("$fname.new", $fname);
	}
	# create a new list with check points.
	my $l = [@@$tail];
	my $i = 0;
	my $end_marker = OpenBSD::PackingElement::StreamMarker->new;
	while (@@$list > 0) {
		my $e = pop @@$list;
		if ($e->really_archived && $i++ % 16 == 0) {
			unshift @@$l, $end_marker;
		}
		unshift @@$l, $e;
	}
	# remove extraneous marker if @@$tail is empty.
	if ($l->[-1] eq $end_marker) {
		pop @@$l;
	}
	return $l;
}

sub parse_and_run
{
	my ($self, $cmd) = @@_;

	my $regen_package = 0;
	my $sign_only = 0;

	my $state = OpenBSD::PkgCreate::State->new($cmd);
	$state->handle_options;

	if (@@ARGV == 0) {
		$regen_package = 1;
	} elsif (@@ARGV != 1) {
		if (defined $state->{contents} || 
		    !defined $state->{signature_params}) {
			$state->usage("Exactly one single package name is required: #1", join(' ', @@ARGV));
		}
	}

	try {
	if (defined $state->opt('Q')) {
		$state->{opt}{q} = 1;
	}

	if (!defined $state->{contents}) {
		$state->usage("Packing-list required");
	}

	my $plist;
	if ($regen_package) {
		if (!defined $state->{contents} || @@{$state->{contents}} > 1) {
			$state->usage("Exactly one single packing-list is required");
		}
		$plist = $self->read_existing_plist($state, 
		    $state->{contents}[0]);
	} else {
		$plist = $self->create_plist($state, $ARGV[0]);
	}


	$plist->discover_directories($state);
	my $ordered;
	unless (defined $state->opt('q') && defined $state->opt('n')) {
		$state->set_status("checking dependencies");
		$self->check_dependencies($plist, $state);
		$state->set_status("checksumming");
		if ($regen_package) {
			$state->progress->visit_with_count($plist, 'verify_checksum');
		} else {
			$plist = $self->make_plist_with_sum($state, $plist);
		}
		$ordered = $self->save_history($plist, 
		    $state->defines('HISTORY_DIR'));
		$self->show_bad_symlinks($state);
		$state->end_status;
	}

	if (!defined $plist->pkgname) {
		$state->fatal("can't write unnamed packing-list");
	}

	if (defined $state->opt('q')) {
		if (defined $state->opt('Q')) {
			$plist->print_file;
		} else {
			$plist->write(\*STDOUT);
		}
		return 0 if defined $state->opt('n');
	}

	if ($plist->{deprecated}) {
		$state->fatal("found obsolete constructs");
	}

	$plist->avert_duplicates_and_other_checks($state);
	if ($state->{has_no_default_conflict} && !$state->{has_conflict}) {
		$state->errsay("Warning: \@@option no-default-conflict without \@@conflict");
	}
	$state->{stash} = {};

	if ($state->{bad} && !$state->defines('REGRESSION_TESTING')) {
		$state->fatal("can't continue");
	}
	$state->{bad} = 0;

	my $wname;
	if ($regen_package) {
		$wname = $plist->pkgname.".tgz";
	} else {
		$plist->save or $state->fatal("can't write packing-list");
		$wname = $ARGV[0];
	}

	if ($state->opt('n')) {
		$state->{archive} = OpenBSD::Ustar->new(undef, $state,
		    $plist->infodir);
		$plist->pretend_to_archive($state);
	} else {
		$self->create_package($state, $plist, $ordered, $wname);
	}
	$self->finish_manpages($state, $plist);
	}catch {
		print STDERR "$0: $_\n";
		return 1;
	};
	return 0;
}

1;
@


1.123
log
@kill creating old signatures.
@
text
@d3 1
a3 1
# $OpenBSD: PkgCreate.pm,v 1.122 2016/09/06 10:41:51 espie Exp $
d85 1
d99 7
d112 1
a112 1
	$state->SUPER::handle_options('p:f:d:M:U:A:B:P:W:qQ',
d115 1
a115 1
	    '[-U undisplayfile] [-W wantedlib]',
a124 1

d1194 4
@


1.122
log
@remove code that allows pkg_create to sign
@
text
@d3 1
a3 1
# $OpenBSD: PkgCreate.pm,v 1.121 2016/06/21 10:40:37 espie Exp $
a1503 5

	if (defined $state->{signer}) {
		$state->add_signature($plist);
		$plist->save if $regen_package;
	}
@


1.121
log
@pass file name thru to Subst for better error messages.
reported by Adam Wolk
@
text
@d3 1
a3 1
# $OpenBSD: PkgCreate.pm,v 1.120 2016/04/25 10:12:58 espie Exp $
d107 1
a107 1
	    '[-s signing-parameter] [-U undisplayfile] [-W wantedlib]',
@


1.120
log
@kill remnants of non shared arches
@
text
@d3 1
a3 1
# $OpenBSD: PkgCreate.pm,v 1.119 2016/04/02 12:18:44 espie Exp $
d1030 1
a1030 1
	my ($self, $state, $old, $not, $frag, undef, $cont) = @@_;
d1032 1
a1032 1
	if ($state->{subst}->has_fragment($def, $frag)) {
d1070 1
a1070 1
					if (my $f2 = $self->handle_fragment($state, $file, $1, $2, $l, $cont)) {
d1238 1
a1239 1
	$plist->set_pkgname($pkgname);
@


1.119
log
@streamline the code that checks meta information before extracting files
- verify_modes should only verify modes
- put the whole checking code in one single routine in validate_meta, makes
the size checking code more obvious
- document what's going on
- prevent PkgCreate from creating impossible packages, only a few Ustar
objects are actually usable.
@
text
@d3 1
a3 1
# $OpenBSD: PkgCreate.pm,v 1.118 2015/11/06 08:53:12 espie Exp $
a310 4
sub find_every_library
{
}

a513 8
sub find_every_library
{
	my ($self, $h) = @@_;
	if ($self->fullname =~ m,/lib([^/]+)\.a$,) {
		$h->{$1}{static} = 1;
	}
}

a672 7
sub find_every_library
{
	my ($self, $h) = @@_;
	my @@l = $self->parse($self->fullname);
	push(@@{$h->{$l[0]}{dynamic}}, $self);
}

a1031 4
	if ($frag eq 'SHARED') {
		$def = 'SHARED_LIBS';
		$frag = 'shared';
	}
a1342 22
# This converts shared libraries into non-shared libraries if necessary
sub tweak_libraries
{
	my ($self, $state, $plist) = @@_;
	return unless $state->{has_libraries};
	return if $state->{subst}->has_fragment('SHARED_LIBS', 'shared');
	my $h = {};
	$plist->find_every_library($h);
	# now we have each library recorded by "stem"
	while (my ($k, $v) = each %$h) {
		# need a static one: convert the first dynamic library to static
		if (!defined $v->{static}) {
			my $lib = pop @@{$v->{dynamic}};
			$lib->{name} = "lib/lib$k.a";
			bless $lib, "OpenBSD::PackingElement::File";
		}
		for my $lib (@@{$v->{dynamic}}) {
			$lib->remove($plist);
		}
	}
}

a1460 1
	$self->tweak_libraries($state, $plist);
@


1.118
log
@the Solver uses kept_names, so we need these there too
found by aja@@
@
text
@d3 1
a3 1
# $OpenBSD: PkgCreate.pm,v 1.117 2015/08/13 08:13:44 espie Exp $
d296 3
@


1.117
log
@let pkg_create recreate all packages correctly, again.
@
text
@d3 1
a3 1
# $OpenBSD: PkgCreate.pm,v 1.116 2015/05/18 10:41:20 espie Exp $
d1026 5
@


1.116
log
@simplify progressmeter calls to visit_and: we retrieve the state from the
progressmeter object
@
text
@d3 1
a3 1
# $OpenBSD: PkgCreate.pm,v 1.115 2015/05/18 10:37:12 espie Exp $
d240 4
a243 1
		if (defined $state->stash("$dev/$ino")) {
@


1.115
log
@have visit_with_count and visit_with_size use the same parameter conventions.
In particular, pass state before the other method parameters.
@
text
@d3 1
a3 1
# $OpenBSD: PkgCreate.pm,v 1.114 2014/12/22 14:24:56 espie Exp $
d1260 1
a1260 1
	$state->progress->visit_with_count($plist, 'makesum_plist', $state, $p2);
d1502 1
a1502 1
			$state->progress->visit_with_count($plist, 'verify_checksum', $state);
@


1.114
log
@when we run into real errors, the progress meter is distracting, so have
a method ->disable that does something nice to the display, and stops
the progress meter right before we display our first real error.
@
text
@d3 1
a3 1
# $OpenBSD: PkgCreate.pm,v 1.113 2014/09/21 07:53:19 espie Exp $
d171 1
a171 1
	my ($self, $plist, $state) = @@_;
d380 1
a380 1
	my ($self, $plist, $state) = @@_;
d502 1
a502 1
	my ($self, $plist, $state) = @@_;
d530 2
a531 2
	my ($self, $plist, $state) = @@_;
	$self->SUPER::makesum_plist($plist, $state);
d560 1
a560 1
	my ($self, $plist, $state) = @@_;
d562 1
a562 1
		return $self->SUPER::makesum_plist($plist, $state);
d582 1
a582 1
		return $self->SUPER::makesum_plist($plist, $state);
d1260 1
a1260 1
	$state->progress->visit_with_count($plist, 'makesum_plist', $p2, $state);
@


1.113
log
@final bulk shows chunking to happen in all the right places, and signing
works correctly as well. So activate this.

This basically makes package snapshots rsync-friendly with a low-tech
approach. Instead of having a patched gzip, we borrow from other archive
formats, and cut the archive every few files. Since the files are already
sorted in order of date of modification, packages that don't change tend
to end with identical gzip archives.

Note that this will still work when/if we transition to bzip2/xz packages...
@
text
@d3 1
a3 1
# $OpenBSD: PkgCreate.pm,v 1.112 2014/09/20 07:41:14 espie Exp $
d50 1
@


1.112
log
@need meta stuff that tells me those are "real files" to not create extra
chunks at the beginning of the package...
Also, be very verbose about everything.
@
text
@d3 1
a3 1
# $OpenBSD: PkgCreate.pm,v 1.111 2014/09/19 16:05:13 espie Exp $
d1441 3
a1443 3
#		if ($e->really_archived && $i++ % 16 == 0) {
#			unshift @@$l, $end_marker;
#		}
@


1.111
log
@.py files no longer need to be special, as the timestamps are stored in
the plist itself, so there's no longer any worry of the timestamp not
getting updated and python throwing a fit.
@
text
@d3 1
a3 1
# $OpenBSD: PkgCreate.pm,v 1.110 2014/09/16 10:01:51 espie Exp $
d151 1
d319 1
d421 7
d477 1
d1440 2
a1441 1
#		if ($i++ % 16 == 0) {
a1443 1
		my $e = pop @@$list;
d1445 4
@


1.110
log
@fix display of comments to use "say" properly.
Prepare scaffolding to be able to chunk archives
@
text
@d3 1
a3 1
# $OpenBSD: PkgCreate.pm,v 1.109 2014/09/16 08:50:26 espie Exp $
d1409 1
a1409 1
		if ($known{$h} && $entries->{$h}[0]->{name} !~ /\.py$/) {
@


1.109
log
@store explicit timestamps in generated plists.
this prevents updates from fucking up mtime of new file, thus the
"python exception" no longer prevents python files from being reordered.

Note that this requires newish scaffolding in pkg_add proper. That
scaffolding was committed prior to 5.6, in preparation for this change.
@
text
@d3 1
a3 1
# $OpenBSD: PkgCreate.pm,v 1.108 2014/07/10 10:33:10 espie Exp $
d139 1
a139 1
		$self->comment_create_package;
d146 1
a146 1
	$self->comment_create_package;
d307 20
d371 2
a372 2
	my ($self) = @@_;
	print "Adding ", $self->name, "\n";
d428 1
a428 1
	$self->comment_create_package;
d433 2
a434 2
	my ($self) = @@_;
	print "Cwd: ", $self->name, "\n";
d474 1
a474 1
	$self->comment_create_package;
d479 2
a480 2
	my ($self) = @@_;
	print "Adding ", $self->name, "\n";
d1425 12
a1436 2
	push(@@$list, @@$tail);
	return $list;
@


1.108
log
@prevent users from adding timestamp themselves
@
text
@d3 1
a3 1
# $OpenBSD: PkgCreate.pm,v 1.107 2014/07/01 09:52:27 espie Exp $
d237 1
a237 1
		my ($dev, $ino, $size) = (stat _)[0,1,7];
d245 1
@


1.107
log
@activate "out-of-order" archives based on history
things to watch out for:
- correct handling of multiple files with the same sha
- cwd handling. This is already destated, so we can call set_destdir on
each entry's cwd, instead of relying on @@cwd being in the "right" location
as that's no longer the case...
@
text
@d3 1
a3 1
# $OpenBSD: PkgCreate.pm,v 1.106 2014/05/20 05:46:13 espie Exp $
d213 1
a213 1
	for my $field (qw(symlink link size)) {  # md5
@


1.106
log
@makewhatis being now external, it no longer requires picky/test/check_dir.
It also can't handle too many manpages at once (shell limit) so hand-feed
it (problem spotted by landry@@).

Some tests by schwarze@@.
@
text
@d3 1
a3 1
# $OpenBSD: PkgCreate.pm,v 1.105 2014/04/18 10:00:48 schwarze Exp $
d306 7
d314 1
a314 1
sub archive
d319 2
a321 1
	$self->SUPER::archive($state);
d335 4
a401 1
	$state->{archive}->destdir($state->{base}."/".$self->name);
a406 1
	$state->{archive}->destdir($state->{base}."/".$self->name);
d420 1
a420 1
	my ($self, $list) = @@_;
d422 5
a426 1
		push(@@$list, $self->{d}->stringize);
d429 8
d441 1
d451 1
d1251 1
a1251 1
	my ($self, $state, $plist, $wname) = @@_;
d1269 5
a1273 1
	$state->progress->visit_with_size($plist, 'create_package', $state);
a1348 10
	unless (-d $dir) {
		require File::Path;

		File::Path::make_path($dir);
	}

	my $name = $plist->fullpkgpath;
	$name =~ s,/,.,g;
	my $fname = "$dir/$name";

a1351 1
	my @@old;
d1353 19
a1371 5
	if (open(my $f, '<', $fname)) {
		while (<$f>) {
			chomp;
			push(@@old, $_);
			$known{$_} = 1;
a1372 1
		close($f);
d1375 9
a1383 2
	$plist->record_digest(\@@new);
	open(my $f, ">", "$fname.new") or return;
d1387 3
a1389 3
	for my $i (@@new) {
		if ($known{$i}) {
			$found{$i} = 1;
d1391 2
a1392 1
			print $f "$i\n";
d1396 7
a1402 4
	for my $i (@@old) {
		if ($found{$i}) {
			print $f "$i\n";
		}
d1404 2
a1405 2
	close($f);
	rename("$fname.new", $fname);
d1450 1
d1460 2
a1461 4
		if ($state->defines('HISTORY_DIR')) {
			$self->save_history($plist, 
			    $state->defines('HISTORY_DIR'));
		}
d1512 1
a1512 1
		$self->create_package($state, $plist, $wname);
@


1.105
log
@Switch to the new makewhatis(8)/apropos(1)/whatis(1) combo.
"commit the switch now" espie@@  "go for it" deraadt@@

See the apropos(1) manual for a description of what's new.
On machines where you want the full functionality,
run "sudo makewhatis" and put "MAKEWHATISARGS=' '" into weekly.local(8).
Otherwise, when upgrading via source, run "sudo makewhatis -Q".
@
text
@d3 1
a3 1
# $OpenBSD: PkgCreate.pm,v 1.104 2014/03/18 20:56:30 espie Exp $
d1286 1
a1286 2
		$state->system(OpenBSD::Paths->makewhatis, '-t', '--',
		    @@{$state->{manpages}});
@


1.104
log
@don't use $_ as "throw-away" variable, proper idiom is "undef"
(and if you're wondering about the unused extra parameter, this is
designed to allow a new makewhatis that shares more code with pkg_create)
@
text
@d3 1
a3 1
# $OpenBSD: PkgCreate.pm,v 1.103 2014/03/18 18:53:29 espie Exp $
d1286 2
a1287 11
		$state->{v} ++;

		require OpenBSD::Makewhatis;

		try {
			OpenBSD::Makewhatis::scan_manpages($state->{manpages},
			    $state);
		} catchall {
			$state->errsay("Error in makewhatis: #1", $_);
		};
		$state->{v} --;
@


1.103
log
@remove $_ usage that warns under perl 5.18
@
text
@d3 1
a3 1
# $OpenBSD: PkgCreate.pm,v 1.102 2014/03/05 22:32:32 espie Exp $
d982 1
a982 1
	my ($self, $state, $old, $not, $frag, $_, $cont) = @@_;
@


1.102
log
@refactor solve_from_ports a bit.

do the write to cache thru a temp file, so the end result is atomic,
to be used to enable a global depends cache for parallel building in
the near future.
@
text
@d3 1
a3 1
# $OpenBSD: PkgCreate.pm,v 1.101 2014/02/02 15:35:52 espie Exp $
d1020 1
a1020 1
			while (my $_ = $file->readline) {
d1022 2
a1023 2
				if (m/^(\@@comment\s+\$(?:Open)BSD\$)$/o) {
					$_ = '@@comment $'.'OpenBSD: '.basename($file->name).',v$';
d1025 2
a1026 2
				if (m/^(\!)?\%\%(.*)\%\%$/) {
					if (my $f2 = $self->handle_fragment($state, $file, $1, $2, $_, $cont)) {
d1032 1
a1032 1
				my $s = $subst->do($_);
d1040 1
a1040 1
					$self->annotate($o, $_, $file);
@


1.101
log
@pseudo handle needs dependency_info too, forgot that one.
@
text
@d3 1
a3 1
# $OpenBSD: PkgCreate.pm,v 1.100 2014/01/23 22:57:06 espie Exp $
d793 1
a793 2
my $cache = {};
sub solve_from_ports
d795 1
a795 1
	my ($self, $state, $dep, $package) = @@_;
d797 4
a800 5
	my $portsdir = $state->defines('PORTSDIR');
	return undef unless defined $portsdir;
	my $pkgname;
	if (defined $cache->{$dep->{pkgpath}}) {
		$pkgname = $cache->{$dep->{pkgpath}};
a801 28
		my ($plist, $diskcache);
		if ($ENV{_DEPENDS_CACHE}) {
			$diskcache = $dep->{pkgpath};
			$diskcache =~ s/\//--/g;
			$diskcache = $ENV{_DEPENDS_CACHE}."/pkgcreate-".
			    $diskcache;
		}
		if (defined $diskcache && -f $diskcache) {
			$plist = OpenBSD::PackingList->fromfile($diskcache);
		} else {
			$plist = $self->ask_tree($state, $dep, $portsdir,
			    'print-plist-libs-with-depends',
			    'wantlib_args=no-wantlib-args');
			if ($? != 0 || !defined $plist->pkgname) {
				$state->error("Can't obtain dependency #1 from ports tree",
				    $dep->{pattern});
				return undef;
			}
			$plist->tofile($diskcache) if defined $diskcache;
		}
		OpenBSD::SharedLibs::add_libs_from_plist($plist, $state);
		$self->add_dep($plist);
		$pkgname = $plist->pkgname;
		$cache->{$dep->{pkgpath}} = $pkgname;
	}
	if ($dep->spec->filter($pkgname) == 0) {
		$state->error("Dependency #1 doesn't match FULLPKGNAME: #2",
		    $dep->{pattern}, $pkgname);
d804 1
d806 13
a818 1
	return $pkgname;
d844 55
@


1.100
log
@tweak the way we create and sign packages significantly:

all modern compression formats support multi-stream archives.
Store the packing-list as a separate stream, and note where the
first stream ends when reading back the packing list.

When pkg_sign sees a split-stream archive, it does not need to unpack/repack
the whole archive: it can just sign the packing-list, close the stream, and
copy the next stream(s) from the source archive verbatim.

This is perfectly transparent to pkg_add, but abuses IO::Uncompress::Gunzip
internals slightly (to be solved with cpan).

also adds explicit option -C for generating a SHA256 list of all packages.

and okay naddy@@
@
text
@d3 1
a3 1
# $OpenBSD: PkgCreate.pm,v 1.99 2014/01/23 12:32:40 espie Exp $
d881 6
@


1.99
log
@clean-up synopsis
@
text
@d3 1
a3 1
# $OpenBSD: PkgCreate.pm,v 1.98 2014/01/23 11:52:34 espie Exp $
d377 7
@


1.98
log
@zap the sign-only part (moved to PkgSign.pm).
reuse the signer part (move to Signer.pm)
@
text
@d3 1
a3 1
# $OpenBSD: PkgCreate.pm,v 1.97 2014/01/20 21:10:55 naddy Exp $
d106 1
a106 1
	    '[-U undisplayfile] [-W wantedlib]',
d108 1
a108 1
	    'pkg-name...');
@


1.97
log
@for the SHA256 file, output checksums in base64; ok espie@@
@
text
@d3 1
a3 1
# $OpenBSD: PkgCreate.pm,v 1.96 2014/01/18 01:10:36 espie Exp $
d25 1
a25 84

package Signer;

my $h = {
	x509 => 'Signer::X509',
	signify => 'Signer::SIGNIFY',
};

sub factory
{
	my ($class, $state) = @@_;

	my @@p = @@{$state->{signature_params}};

	if (defined $h->{$p[0]}) {
		return $h->{$p[0]}->new($state, @@p);
	} else {
		$state->usage("Unknown signature scheme $p[0]");
	}
}

package Signer::X509;
sub new
{
	my ($class, $state, @@p) = @@_;

	if (@@p != 3 || !-f $p[1] || !-f $p[2]) {
		$state->usage("$p[0] signature wants -s cert -s privkey");
	}
	bless {cert => $p[1], privkey => $p[2]}, $class;
}

sub new_sig
{
	require OpenBSD::x509;
	return OpenBSD::PackingElement::DigitalSignature->blank('x509');
}

sub compute_signature
{
	my ($self, $state, $plist) = @@_;
	return OpenBSD::x509::compute_signature($plist, $self->{cert}, 
	    $self->{privkey});
}

package Signer::SIGNIFY;
sub new
{
	my ($class, $state, @@p) = @@_;
	if (@@p != 2 || !-f $p[1]) {
		$state->usage("$p[0] signature wants -s privkey");
	}
	my $o = bless {privkey => $p[1]}, $class;
	my $signer = $o->{privkey};
	$signer =~ s/\.sec$//;
	my $pubkey = "$signer.pub";
	$signer =~ s,.*/,,;
	$o->{signer} = $signer;
	if (!-f $pubkey) {
		$pubkey =~ s,.*/,/etc/signify/,;
		if (!-f $pubkey) {
			$state->errsay("warning: public key not found");
			return $o;
		}
	}
	$o->{pubkey} = $pubkey;
	return $o;
}

sub new_sig
{
	require OpenBSD::signify;
	return OpenBSD::PackingElement::DigitalSignature->blank('signify');
}

sub compute_signature
{
	my ($self, $state, $plist) = @@_;

	OpenBSD::PackingElement::Signer->add($plist, $self->{signer});

	return OpenBSD::signify::compute_signature($plist, $state, 
	    $self->{privkey}, $self->{pubkey});
}
d28 1
a28 1
our @@ISA = qw(OpenBSD::AddCreateDelete::State);
a68 6
sub todo
{
	my ($self, $offset) = @@_;
	return sprintf("%u/%u", $self->{done}-$offset, $self->{total});
}

a88 11
	    'o' =>
		    sub {
			    $state->{output_dir} = shift;
			    if (!-d $state->{output_dir}) {
				    $state->usage("no such dir");
			    }
		    },
	    'S' =>
		    sub {
			    $state->{source} = shift;
		    },
a100 3
	    's' => sub {
			    push(@@{$state->{signature_params}}, shift);
		    },
d103 1
a103 1
	$state->SUPER::handle_options('p:f:d:j:M:U:s:A:B:P:W:qQo:S:',
a105 1
	    '[-s [x509 -s cert|signify] -s priv] [-o dir] [-S source]',
a293 4
sub copy_over
{
}

a366 8
sub copy_over
{
	my ($self, $state, $wrarc, $rdarc) = @@_;
	$wrarc->destdir($rdarc->info);
	my $e = $wrarc->prepare($self->{name});
	$e->write;
}

a448 7
sub copy_over
{
	my ($self, $state, $wrarc, $rdarc) = @@_;
	my $e = $rdarc->next;
	$e->copy($wrarc);
}

a1041 138
sub add_signature
{
	my ($self, $plist, $state) = @@_;

	if ($plist->has('digital-signature') || $plist->has('signer')) {
		if ($state->defines('resign')) {
			if ($state->defines('nosig')) {
				$state->errsay("NOT CHECKING DIGITAL SIGNATURE FOR #1",
				    $plist->pkgname);
			} else {
				if (!$plist->check_signature($state)) {
					$state->fatal("#1 is corrupted",
					    $plist->pkgname);
				}
			}
			$state->errsay("Resigning #1", $plist->pkgname);
			delete $plist->{'digital-signature'};
			delete $plist->{signer};
		}
	}

	my $sig = $state->{signer}->new_sig;
	$sig->add_object($plist);
	$sig->{b64sig} = $state->{signer}->compute_signature($state, $plist);
}

sub create_archive
{
	my ($self, $state, $filename, $dir) = @@_;
	require IO::Compress::Gzip;
	my $fh = IO::Compress::Gzip->new($filename);
	return OpenBSD::Ustar->new($fh, $state, $dir);
}

sub sign_existing_package
{
	my ($self, $state, $pkg) = @@_;
	my $output = $state->{output_dir} // ".";
	my $dir = $pkg->info;
	my $plist = OpenBSD::PackingList->fromfile($dir.CONTENTS);
	$plist->set_infodir($dir);
	$self->add_signature($plist, $state);
	$plist->save;
	my $tmp = OpenBSD::Temp::permanent_file($output, "pkg");
	my $wrarc = $self->create_archive($state, $tmp, ".");
	$plist->copy_over($state, $wrarc, $pkg);
	$wrarc->close;
	$pkg->wipe_info;
	chmod((0666 & ~umask), $tmp);
	rename($tmp, $output.'/'.$plist->pkgname.".tgz") or
	    $state->fatal("Can't create final signed package: #1", $!);
	$state->system(sub {
	    chdir($output);
	    open(STDOUT, '>>', 'SHA256');
	    },
	    OpenBSD::Paths->sha256, '-b', $plist->pkgname.".tgz");
}

sub sign_list
{
	my ($self, $l, $repo, $maxjobs, $state) = @@_;
	$state->{total} = scalar @@$l;
	$maxjobs //= 1;
	my $code = sub {
		my $pkg = $repo->find(shift);
		$self->sign_existing_package($state, $pkg);
	    };
	my $display = $state->verbose ?
	    sub {
		$state->progress->set_header("Signed ".shift);
		$state->{done}++;
		$state->progress->next($state->ntogo);
	    } :
	    sub {
	    };
	if ($maxjobs > 1) {
		my $jobs = {};
		my $n = 0;
		my $reap_job = sub {
			my $pid = wait;
			if (!defined $jobs->{$pid}) {
				$state->fatal("Wait returned #1: unknown process", $pid);
			}
			if ($? != 0) {
				$state->fatal("Signature of #1 failed\n", 
				    $jobs->{$pid});
			}
			$n--;
			&$display($jobs->{$pid});
			delete $state->{signer}{pubkey};
			delete $jobs->{$pid};
		};
			
		while (@@$l > 0) {
			my $name = shift @@$l;
			my $pid = fork();
			if ($pid == 0) {
				$repo->reinitialize;
				&$code($name);
				exit(0);
			} else {
				$jobs->{$pid} = $name;
				$n++;
			}
			if ($n >= $maxjobs) {
				&$reap_job;
			}
		}
		while ($n != 0) {
			&$reap_job;
		}
	} else {
		for my $name (@@$l) {
			&$code($name);
			&$display($name);
			delete $state->{signer}{pubkey};
		}
	}
	$state->system(sub {
	    chdir($state->{output_dir}) if $state->{output_dir};
	    open(STDOUT, '>', 'SHA256.new');
	    }, 'sort', 'SHA256');
	rename($state->{output_dir}.'/SHA256.new', 
	    $state->{output_dir}.'/SHA256');
}

sub sign_existing_repository
{
	my ($self, $state, $source) = @@_;
	require OpenBSD::PackageRepository;
	my $repo = OpenBSD::PackageRepository->new($source, $state);
	my @@list = sort @@{$repo->list};
	if (@@list == 0) {
		$state->errsay('Source repository "#1" is empty', $source);
    	}
	$self->sign_list(\@@list, $repo, $state->opt('j'), $state);
}

d1192 1
a1192 2
	$state->{archive} = $self->create_archive($state, $wname,
	    $plist->infodir);
d1336 1
a1336 1
	if (@@ARGV == 0 && !defined $state->{source}) {
a1345 3
	if (defined $state->{signature_params}) {
		$state->{signer} = Signer->factory($state);
	}
d1351 1
a1351 5
		if (defined $state->{signer}) {
			$sign_only = 1;
		} else {
			$state->usage("Packing-list required");
		}
a1360 12
	} elsif ($sign_only) {
		if ($state->not) {
			$state->fatal("can't pretend to sign existing packages");
		}
		$state->{wantntogo} = $state->config->istrue("ntogo");
		if (defined $state->{source}) {
			$self->sign_existing_repository($state, 
			    $state->{source});
		}
		$self->sign_list(\@@ARGV, $state->repo, $state->opt('j'), 
		    $state);
		return 0;
d1414 1
a1414 1
		$self->add_signature($plist, $state);
@


1.96
log
@involuntary sneak preview, revert
@
text
@d3 1
a3 1
# $OpenBSD: PkgCreate.pm,v 1.95 2014/01/18 01:09:30 espie Exp $
d1220 1
a1220 1
	    OpenBSD::Paths->sha256, $plist->pkgname.".tgz");
@


1.95
log
@...and sort SHA256 properly
@
text
@d3 1
a3 1
# $OpenBSD: PkgCreate.pm,v 1.94 2014/01/17 10:54:14 espie Exp $
d1195 1
a1195 8
	require Compress::Raw::Zlib;
	my $level = $state->{subst}->value('COMPRESSION_LEVEL');
	if (defined $state->{signer}) {
		$level //= 6;
	} else {
		$level //= 1;
	}
	my $fh = IO::Compress::Gzip->new($filename, -Level => $level);
@


1.94
log
@tweak the interface to generating signatures yet again.
- assume key names match, deduce signer from sec key.
e.g., -s signify -s 55pkg.sec
will set signer to 55pkg and look for a pubkey named 55pkg.pub,
either besides 55pkg.sec or in /etc/signify.
- verify there's no mismatch, if possible, by verifying the first package
signed.

- also build a SHA256 on the fly while signing.
@
text
@d3 1
a3 1
# $OpenBSD: PkgCreate.pm,v 1.93 2014/01/13 10:07:32 espie Exp $
d1195 8
a1202 1
	my $fh = IO::Compress::Gzip->new($filename);
d1292 1
d1294 2
@


1.93
log
@say something if we sign an empty repository
tweak mode on tmp signed file
@
text
@d3 1
a3 1
# $OpenBSD: PkgCreate.pm,v 1.92 2014/01/09 20:20:01 espie Exp $
d77 15
a91 2

	bless {privkey => $p[1]}, $class;
d104 1
a104 2
	my $list = $state->signer_list;
	OpenBSD::PackingElement::Signer->add($plist, $list->[0]);
d107 1
a107 1
	    $self->{privkey});
a1212 1
	unlink($plist->pkgname.".tgz") if $state->{output};
d1216 5
d1254 1
d1280 1
d1283 3
@


1.92
log
@bump copyright to 2014
@
text
@d3 1
a3 1
# $OpenBSD: PkgCreate.pm,v 1.91 2014/01/09 17:51:56 espie Exp $
d1202 1
d1273 3
@


1.91
log
@if we're re-signing, check old sig first. shouldn't sign stuff we don't
trust.
@
text
@d3 1
a3 1
# $OpenBSD: PkgCreate.pm,v 1.90 2014/01/09 13:30:46 espie Exp $
d5 1
a5 1
# Copyright (c) 2003-2010 Marc Espie <espie@@openbsd.org>
@


1.90
log
@@@signer makes sense only for signify, so move it there.
@
text
@d3 1
a3 1
# $OpenBSD: PkgCreate.pm,v 1.89 2014/01/09 13:21:03 espie Exp $
d1159 9
@


1.89
log
@simplify a bit: pass the first SIGNER for @@signer.
@
text
@d3 1
a3 1
# $OpenBSD: PkgCreate.pm,v 1.88 2014/01/09 10:43:13 espie Exp $
d90 4
a1163 3

	my $list = $state->signer_list;
	OpenBSD::PackingElement::Signer->add($plist, $list->[0]);
@


1.88
log
@switch to internal gzip/gunzip.
reduces the number of external processes and the complexity of the code.

tested on a few select arches by tobiasu, naddy. If it breaks somewhere,
tough. This one is simple to revert.
@
text
@d3 1
a3 1
# $OpenBSD: PkgCreate.pm,v 1.87 2014/01/09 10:36:52 espie Exp $
a1161 3
	if (@@$list != 1) {
		$state->fatal("Ambiguous: single SIGNER identity required");
	}
@


1.87
log
@tweak signing yet again. Have pkg_create automatically add signing
identities every time, and make matching identities mandatory.
e.g., pkg_create and pkg_add must have matching -DSIGNER.
by default, signer is derived from uname -r and role (pkg_add/fw_update),
e.g., 54pkg, 54fw...
@
text
@d3 1
a3 1
# $OpenBSD: PkgCreate.pm,v 1.86 2014/01/07 11:51:15 espie Exp $
d1175 3
a1177 2
	open(my $fh, "|-", OpenBSD::Paths->gzip, "-f", "-o", $filename);
	return  OpenBSD::Ustar->new($fh, $state, $dir);
a1178 1

@


1.86
log
@integrate signer logic and fix resign with -DSIGNER
@
text
@d3 1
a3 1
# $OpenBSD: PkgCreate.pm,v 1.85 2014/01/07 10:38:12 espie Exp $
d1161 3
a1163 3
	my $signer = $state->{subst}->value('SIGNER');
	if (defined $signer) {
		OpenBSD::PackingElement::Signer->add($plist, $signer);
d1165 1
@


1.85
log
@if HISTORY_DIR is defined, create a new "permanent" file during build.
this file records the sha256 of all elements in the archive, and keeps
track of changes (quite simply: sha256 that were already present end
up at the end of the file).

Start recording these *now*, so that we have enough info to shuffle
packages later.
@
text
@d3 1
a3 1
# $OpenBSD: PkgCreate.pm,v 1.84 2014/01/07 01:30:28 espie Exp $
d1153 1
a1153 1
	if ($plist->has('digital-signature')) {
d1157 1
d1161 5
a1177 9
sub setup_signer
{
	my ($self, $plist, $state) = @@_;
	my $signer = $state->{subst}->value('SIGNER');
	if (!defined $signer) {
		return;
	}
	OpenBSD::PackingElement::Signer->add($plist, $signer);
}
a1186 1
	$self->setup_signer($plist, $state);
a1271 1
	$self->setup_signer($plist, $state);
@


1.84
log
@allow processing of package lists in parallel.
Turns out re-gzipping a signed package is really expensive, so turn
it into several jobs with a -j option.
@
text
@d3 1
a3 1
# $OpenBSD: PkgCreate.pm,v 1.83 2014/01/04 14:13:39 espie Exp $
d237 1
d501 7
d1507 50
d1626 4
@


1.83
log
@more forbidden elements
@
text
@d3 1
a3 1
# $OpenBSD: PkgCreate.pm,v 1.82 2014/01/04 00:14:08 espie Exp $
d190 1
a190 1
	$state->SUPER::handle_options('p:f:d:M:U:s:A:B:P:W:qQo:S:',
a1176 1
	$state->set_status("Signing ".$pkg->name);
d1186 1
a1186 2
	$state->progress->visit_with_size($plist, 'copy_over', $state, 
	    $wrarc, $pkg);
a1191 2
	$state->{done}++;
	$state->progress->next($state->ntogo);
d1194 1
a1194 1
sub sign_existing_pkgname
d1196 56
a1251 6
	my ($self, $state, $pkgname) = @@_;

	my $true_package = $state->repo->find($pkgname);
	$state->fatal("No such package #1", $pkgname) unless $true_package;

	$self->sign_existing_package($state, $true_package);
d1260 1
a1260 6
	$state->{total} = scalar @@list;
	$state->{done} = 0;
	for my $name (@@list) {
		my $pkg = $repo->find($name);
		$self->sign_existing_package($state, $pkg);
	}
d1550 2
a1551 5
		$state->{total} = scalar @@ARGV;
		$state->{done} = 0;
		for my $pkgname (@@ARGV) {
			$self->sign_existing_pkgname($state, $pkgname);
		}
@


1.82
log
@vendor->signer
shorten pubkey -> pub (naddy@@)
\\ -> \e (jmc@@)
@
text
@d3 1
a3 1
# $OpenBSD: PkgCreate.pm,v 1.81 2014/01/03 13:26:24 espie Exp $
d725 3
d732 3
@


1.81
log
@make sure elements are not set manually, namely forbid
@@depend (use -P)
@@wantlib (use -W)
@@name (duh)
@@arch
@@localbase
@@option manual-installation
@@comment pkgpath=...
(some of this is actually redundant, but will give more explicit error
messages)
@
text
@d3 1
a3 1
# $OpenBSD: PkgCreate.pm,v 1.80 2014/01/02 20:13:43 espie Exp $
d1158 1
a1158 1
sub setup_vendor
d1161 2
a1162 2
	my $vendor = $state->{subst}->value('VENDOR');
	if (!defined $vendor) {
d1165 1
a1165 1
	OpenBSD::PackingElement::Vendor->add($plist, $vendor);
d1177 1
a1177 1
	$self->setup_vendor($plist, $state);
d1221 1
a1221 1
	$self->setup_vendor($plist, $state);
@


1.80
log
@simplify handling of special files some more, that stuff has fixed names
anyways
@
text
@d3 1
a3 1
# $OpenBSD: PkgCreate.pm,v 1.79 2014/01/02 18:19:46 espie Exp $
d466 2
d640 2
d690 2
d725 6
d732 6
@


1.79
log
@make the special file creation more explicit, so that the order actually
doesn't matter
@
text
@d3 1
a3 1
# $OpenBSD: PkgCreate.pm,v 1.78 2014/01/02 16:27:10 espie Exp $
d420 1
a420 1
	my ($class, $subst, $plist, $name, $opt) = @@_;
d422 1
a422 1
		my $o = $class->add($plist, $name);
d1229 1
a1229 1
	OpenBSD::PackingElement::FDISPLAY->may_add($subst, $plist, DISPLAY,
d1231 1
a1231 1
	OpenBSD::PackingElement::FUNDISPLAY->may_add($subst, $plist, UNDISPLAY,
@


1.78
log
@be more explicit  in why we don't write DESC
return early instead of adding an extra level of test.
@
text
@d3 1
a3 1
# $OpenBSD: PkgCreate.pm,v 1.77 2014/01/02 16:05:42 espie Exp $
d418 9
a1074 9
sub add_special_file
{
	my ($subst, $plist, $name, $opt) = @@_;
	if (defined $opt) {
	    my $o = OpenBSD::PackingElement::File->add($plist, $name);
	    $subst->copy($opt, $o->fullname) if defined $o->fullname;
	}
}

d1229 4
a1232 2
	add_special_file($subst, $plist, DISPLAY, $state->opt('M'));
	add_special_file($subst, $plist, UNDISPLAY, $state->opt('U'));
d1270 8
d1299 2
a1302 8
	$self->read_all_fragments($state, $plist);
	$plist->register_forbidden($state);
	if (defined $state->{forbidden}) {
		for my $e (@@{$state->{forbidden}}) {
			$state->errsay("Error: #1 can't be set explicitly", "\@@".$e->keyword." ".$e->stringize);
		}
		$state->fatal("Can't continue");
	}
@


1.77
log
@zap PKG_PREFIX (undocumented and unused, now)
okay landry@@
@
text
@d3 1
a3 1
# $OpenBSD: PkgCreate.pm,v 1.76 2013/12/31 11:21:10 espie Exp $
d1092 7
a1098 6
	if (defined $o->fullname) {
	    open(my $fh, '>', $o->fullname) or die "Can't write to DESC: $!";
	    if (defined $comment) {
	    	print $fh $subst->do($comment), "\n";
	    }
	    if ($opt_d =~ /^\-(.*)$/o) {
d1100 1
a1100 1
	    } else {
d1102 2
a1103 2
	    }
	    if (defined $comment) {
d1107 2
a1108 1
			print $fh "\n", $subst->do('Maintainer: ${MAINTAINER}'), "\n";
a1112 2
	    }
	    close($fh);
d1114 1
@


1.76
log
@signify support
@
text
@d3 1
a3 1
# $OpenBSD: PkgCreate.pm,v 1.75 2013/12/30 09:14:49 espie Exp $
d201 1
a201 3
	} elsif (defined $ENV{'PKG_PREFIX'}) {
		$base = $ENV{'PKG_PREFIX'};
	}
@


1.75
log
@@@vendor annotation
@
text
@d3 1
a3 1
# $OpenBSD: PkgCreate.pm,v 1.74 2013/12/29 13:40:54 espie Exp $
d26 20
d52 1
a52 1
		$state->usage("x509 signature wants -s cert -s privkey");
d60 1
a60 1
	return OpenBSD::PackingElement::DigitalSignature->new_x509;
d70 24
d193 1
a193 1
	    '[-s [x509|sos] -s cert -s priv] [-o dir] [-S source]',
d266 9
a468 1

d709 6
a731 1

a1121 1

a1280 1
	$plist->set_pkgname($pkgname);
a1286 1
	$self->add_elements($plist, $state);
d1290 2
d1293 7
d1452 1
a1452 6
		my @@p = @@{$state->{signature_params}};
		if ($p[0] eq 'x509') {
			$state->{signer} = Signer::X509->new($state, @@p);
		} else  {
			$state->usage("Unknown signature scheme $p[0]");
		}
@


1.74
log
@fix sign-while-creating mode
@
text
@d3 1
a3 1
# $OpenBSD: PkgCreate.pm,v 1.73 2013/12/25 14:38:56 espie Exp $
d1085 10
d1104 1
d1148 1
@


1.73
log
@sign package thru a signer object, instead of hardcoding signature parameters
@
text
@d3 1
a3 1
# $OpenBSD: PkgCreate.pm,v 1.72 2013/12/23 16:50:29 espie Exp $
d1467 1
a1467 1
		$self->add_signature($plist);
@


1.72
log
@move ntogo code, so it can be used while copying packages in pkg_create.
add the few lines necessary for that to work.
@
text
@d3 1
a3 1
# $OpenBSD: PkgCreate.pm,v 1.71 2013/12/23 16:34:51 espie Exp $
d26 24
d121 3
d149 1
a149 1
	    '[-s x509 -s cert -s priv] [-o dir] [-S source]',
d1063 1
a1063 1
	my ($self, $plist, $cert, $privkey) = @@_;
a1064 1
	require OpenBSD::x509;
d1066 8
a1073 1
	my $sig = OpenBSD::PackingElement::DigitalSignature->new_x509;
d1075 1
a1075 2
	$sig->{b64sig} = OpenBSD::x509::compute_signature($plist,
	    $cert, $privkey);
d1087 1
a1087 1
	my ($self, $state, $pkg, $cert, $privkey) = @@_;
d1093 1
a1093 1
	$self->add_signature($plist, $cert, $privkey);
d1110 1
a1110 1
	my ($self, $state, $pkgname, $cert, $privkey) = @@_;
d1115 1
a1115 1
	$self->sign_existing_package($state, $true_package, $cert, $privkey);
d1120 1
a1120 1
	my ($self, $state, $source, $cert, $privkey) = @@_;
d1123 1
a1123 1
	my @@list = @@{$repo->list};
d1128 1
a1128 1
		$self->sign_existing_package($state, $pkg, $cert, $privkey);
a1359 1
	my ($cert, $privkey);
d1378 4
a1381 2
		if (@@p != 3 || $p[0] ne 'x509' || !-f $p[1] || !-f $p[2]) {
			$state->usage("Signature only works as -s x509 -s cert -s privkey");
a1382 2
		$cert = $p[1];
		$privkey = $p[2];
d1389 1
a1389 1
		if (defined $cert) {
d1410 1
a1410 1
			    $state->{source}, $cert, $privkey);
d1415 1
a1415 2
			$self->sign_existing_pkgname($state, 
			    $pkgname, $cert, $privkey);
d1466 2
a1467 2
	if (defined $cert) {
		$self->add_signature($plist, $cert, $privkey);
@


1.71
log
@get rid of "copy_long", we don't really need to recheck names while copying
a package contents.

Allow -o/-S for output/signature dirs for batch operations.
Fix copying of packages while signing, add progressmeter.
@
text
@d3 1
a3 1
# $OpenBSD: PkgCreate.pm,v 1.70 2013/10/15 20:23:51 schwarze Exp $
d68 6
d1072 2
a1073 1
    	$state->end_status;
d1091 4
a1094 1
	for my $name (@@{$repo->list}) {
d1376 1
d1381 2
@


1.70
log
@If the fake target of a port installed an empty (0-byte) file as a
manual page, pkg_create(1) asked groff to process the empty file,
which failed, and then decided to install the empty file as a source
manual page, which later caused mandoc(1) called from man(1) to
complain to the end-user.  Instead, detect the emptiness in time,
skip the formatting attempt, skip the file, process the packing
list to its end, then abort pkg_create(1) unsuccessfully such that
the porter sees the problem and can fix whatever the root cause is.

Problem reported by naddy@@ as seen in p5-Carp-Datum during a bulk build,
solution is joint work with espie@@, again tested in a bulk by naddy@@;
"please commit" espie@@.
@
text
@d3 1
a3 1
# $OpenBSD: PkgCreate.pm,v 1.69 2012/12/31 09:42:05 espie Exp $
d88 8
d113 1
a113 1
	$state->SUPER::handle_options('p:f:d:M:U:s:A:B:P:W:qQ',
d116 4
a119 2
	    '[-s x509 -s cert -s priv] [-U undisplayfile] [-W wantedlib]',
	    '-d desc -D COMMENT=value -f packinglist -p prefix pkg-name');
d367 1
a367 1
	my ($self, $wrarc, $rdarc) = @@_;
d449 1
a449 1
	my ($self, $wrarc, $rdarc) = @@_;
d451 1
a451 4
	if (!$e->check_name($self)) {
		die "Names don't match: ", $e->{name}, " ", $self->{name};
	}
	$e->copy_long($wrarc);
d1049 4
a1052 6
	my ($self, $state, $pkgname, $cert, $privkey) = @@_;


	my $true_package = $state->repo->find($pkgname);
	$state->fatal("No such package #1", $pkgname) unless $true_package;
	my $dir = $true_package->info;
d1057 1
a1057 1
	my $tmp = OpenBSD::Temp::permanent_file(".", "pkg");
d1059 2
a1060 1
	$plist->copy_over($wrarc, $true_package);
d1062 3
a1064 3
	$true_package->wipe_info;
	unlink($plist->pkgname.".tgz");
	rename($tmp, $plist->pkgname.".tgz") or
d1066 22
d1325 1
a1325 1
	if (@@ARGV == 0) {
a1342 1

d1366 4
d1371 2
a1372 1
			$self->sign_existing($state, $pkgname, $cert, $privkey);
@


1.69
log
@simple optimization: if we're already erroring out, there's totally no
need to compute those pesky checksums.
@
text
@d3 1
a3 1
# $OpenBSD: PkgCreate.pm,v 1.68 2012/06/08 15:02:10 espie Exp $
d513 1
a513 1
	$self->format($state, $tempname, $fh);
@


1.68
log
@activate new pkg_create magic.
Note that, in most cases, PFRAG.shared are probably no longer needed...
@
text
@d3 1
a3 1
# $OpenBSD: PkgCreate.pm,v 1.67 2012/05/24 17:49:51 espie Exp $
d235 2
a236 1
			$result->add_digest($self->compute_digest($fname));
@


1.67
log
@put possible fragments in there.
fix buglet in parsing libraries
@
text
@d3 1
a3 1
# $OpenBSD: PkgCreate.pm,v 1.66 2012/05/15 08:59:12 espie Exp $
d1348 1
a1348 1
#	$self->tweak_libraries($state, $plist);
@


1.66
log
@supplementary magic code, not active yet
@
text
@d3 1
a3 1
# $OpenBSD: PkgCreate.pm,v 1.65 2012/05/15 08:15:45 espie Exp $
d598 2
a599 1
	if (my @@l = $self->parse($self->name)) {
d615 18
@


1.65
log
@less hackish test for LIB*VERSION: after building the element,
redo a check based on the non-subst version, so we can:
- actually parse the library name
- check we depend upon the right variable
@
text
@d3 1
a3 1
# $OpenBSD: PkgCreate.pm,v 1.64 2012/05/07 15:56:18 espie Exp $
d298 4
d446 8
d594 1
a594 1
package OpenBSD::PackingElement::Library;
d605 8
d1244 22
d1329 1
@


1.64
log
@well pkg_create itself doesn't care, but a custom ->annotate will get
very confused
@
text
@d3 1
a3 1
# $OpenBSD: PkgCreate.pm,v 1.63 2012/05/01 14:24:16 espie Exp $
d294 4
d582 13
a904 4
				if (m/^\@@lib\s+(.*)$/o &&
				    OpenBSD::PackingElement::Lib->parse($1)) {
				    	$state->error("shared library without SHARED_LIBS: #1", $_);
				}
d919 1
@


1.63
log
@make fragment handling yet more customizable
@
text
@d3 1
a3 1
# $OpenBSD: PkgCreate.pm,v 1.62 2012/04/30 18:04:14 espie Exp $
d903 5
a907 1
				$self->annotate(&$cont($s), $_, $file);
@


1.62
log
@allow a subclass to override that specific error
@
text
@d3 1
a3 1
# $OpenBSD: PkgCreate.pm,v 1.61 2012/04/30 11:22:12 espie Exp $
d586 1
a586 1
	bless { fh => $fh, name => $filename }, $class;
d607 24
a842 23
sub deduce_name
{
	my ($state, $o, $frag, $not) = @@_;

	my $noto = $o;
	my $nofrag = "no-$frag";

	$o =~ s/PFRAG\./PFRAG.$frag-/o or
	    $o =~ s/PLIST/PFRAG.$frag/o;

	$noto =~ s/PFRAG\./PFRAG.no-$frag-/o or
	    $noto =~ s/PLIST/PFRAG.no-$frag/o;
	unless (-e $o or -e $noto) {
		die "Missing fragments for $frag: $o and $noto don't exist";
	}
	if ($not) {
		return $noto if -e $noto;
    	} else {
		return $o if -e $o;
	}
	return;
}

d845 1
a845 1
	my ($state, $stack, $file, $not, $frag) = @@_;
a850 1
	my $newname = deduce_name($state, $file->name, $frag, $not);
d852 1
a852 1
		return $file if defined $not;
d854 1
a854 1
		return $file unless defined $not;
d856 1
d860 1
a860 2
		push(@@$stack, $file);
		$file = MyFile->new($newname);
d862 6
a867 1
	return $file;
d876 1
a876 1
	push(@@$stack, MyFile->new($filename));
d892 4
a895 7
				if (my ($not, $frag) = m/^(\!)?\%\%(.*)\%\%$/) {
					$file = handle_fragment($state, $stack,
					    $file, $not, $frag);
				} else {
					my $s = $subst->do($_);
					if ($fast) {
						next unless $s =~ m/^\@@(?:cwd|lib|depend|wantlib)\b/o || $s =~ m/lib.*\.a$/o;
d897 5
a901 1
					$self->annotate(&$cont($s), $_, $file);
d903 1
@


1.61
log
@make the reading of packing-lists amenable to further annotations, such as
those that will be required for update-plist
@
text
@d3 1
a3 1
# $OpenBSD: PkgCreate.pm,v 1.60 2012/04/30 11:12:16 espie Exp $
d1047 6
d1064 1
a1064 1
		    $state->fatal("can't read packing-list #1", $contentsfile);
@


1.60
log
@move code around a bit more
@
text
@d3 1
a3 1
# $OpenBSD: PkgCreate.pm,v 1.59 2012/04/30 10:43:51 espie Exp $
d867 1
a867 1
	my ($state, $plist, $filename) = @@_;
d891 1
a891 1
					$_ = $subst->do($_);
d893 1
a893 1
						next unless m/^\@@(?:cwd|lib|depend|wantlib)\b/o || m/lib.*\.a$/o;
d895 1
a895 1
					&$cont($_);
d902 4
d1057 1
a1057 1
		read_fragments($state, $plist, $contentsfile) or
@


1.59
log
@more refactor
@
text
@d3 1
a3 1
# $OpenBSD: PkgCreate.pm,v 1.58 2012/04/30 10:32:12 espie Exp $
d88 4
d102 1
a102 1
		    }
a1024 5
	if (defined $state->opt('p')) {
		OpenBSD::PackingElement::Cwd->add($plist, $state->opt('p'));
	} else {
		$state->usage("Prefix required");
	}
d1043 15
a1061 2
	my $frags = $state->{contents};

d1079 1
a1079 4
	for my $contentsfile (@@$frags) {
		read_fragments($state, $plist, $contentsfile) or
		    $state->fatal("can't read packing-list #1", $contentsfile);
	}
@


1.58
log
@just a bit of refactoring, make sure option handling is done in state,
as should be, so we can reuse it without needing to duplicate all of
pkg_create code.
@
text
@d3 1
a3 1
# $OpenBSD: PkgCreate.pm,v 1.57 2012/02/13 17:32:14 espie Exp $
d106 10
a1240 9

	my $base = '/';
	if (defined $state->opt('B')) {
		$base = $state->opt('B');
	} elsif (defined $ENV{'PKG_PREFIX'}) {
		$base = $ENV{'PKG_PREFIX'};
	}

	$state->{base} = $base;
@


1.57
log
@warn when @@option no-default-conflict and not explicit @@conflict.
(very seldom correct, mostly used for autoconf/automake)
@
text
@d3 1
a3 1
# $OpenBSD$
d79 29
d1005 1
a1005 1
	my ($self, $plist, $state, $dep, $want) = @@_;
d1016 1
a1016 1
	for my $d (sort keys %$dep) {
d1020 1
a1020 1
	for my $w (sort keys %$want) {
d1036 3
a1038 1
	my ($self, $state, $pkgname, $frags, $dep, $want) = @@_;
d1053 1
a1053 1
	$self->add_elements($plist, $state, $dep, $want);
a1176 2
	my (@@contents, %dependencies, %wantlib, @@signature_params);

d1179 1
a1179 24

	$state->{opt} = {
	    'f' =>
		    sub {
			    push(@@contents, shift);
		    },
	    'P' => sub {
			    my $d = shift;
			    $dependencies{$d} = 1;
		    },
	    'W' => sub {
			    my $w = shift;
			    $wantlib{$w} = 1;
		    },
	    's' => sub {
			    push(@@signature_params, shift);
		    }
	};
	$state->{no_exports} = 1;
	$state->handle_options('p:f:d:M:U:s:A:B:P:W:qQ',
	    '[-nQqvx] [-A arches] [-B pkg-destdir] [-D name[=value]]',
	    '[-L localbase] [-M displayfile] [-P pkg-dependency]',
	    '[-s x509 -s cert -s priv] [-U undisplayfile] [-W wantedlib]',
	    '-d desc -D COMMENT=value -f packinglist -p prefix pkg-name');
d1184 2
a1185 1
		if (@@contents || @@signature_params == 0) {
d1191 3
a1193 3
	if (@@signature_params > 0) {
		if (@@signature_params != 3 || $signature_params[0] ne 'x509' ||
		    !-f $signature_params[1] || !-f $signature_params[2]) {
d1196 2
a1197 2
		$cert = $signature_params[1];
		$privkey = $signature_params[2];
d1204 2
a1205 2
	if (!@@contents) {
		if (@@signature_params > 0) {
d1214 1
a1214 1
		if (@@contents != 1) {
d1217 2
a1218 1
		$plist = $self->read_existing_plist($state, $contents[0]);
d1228 1
a1228 2
		$plist = $self->create_plist($state, $ARGV[0], \@@contents,
		    \%dependencies, \%wantlib);
@


1.56
log
@sanitize stuff a bit more...
@
text
@d3 1
a3 1
# $OpenBSD: PkgCreate.pm,v 1.55 2012/01/16 08:42:38 schwarze Exp $
d447 1
a447 1
	open my $fh, ">", $tempname or $state->error("can't create #1: #2", 
d482 1
d527 8
d655 1
a655 1
			    'print-plist-libs-with-depends', 
d1125 1
a1125 1
			OpenBSD::Makewhatis::scan_manpages($state->{manpages}, 
d1266 3
@


1.55
log
@Backout activation of the new apropos(1)/whatis(1)/makewhatis(8).
In its current state, it causes too much slowdown, in particular
during system builds, and there are other regressions.
That cannot be fixed quickly while it's enabled.

Problems pointed out by espie@@, backout requested by deraadt@@,
diff "looks good" to espie@@.
@
text
@d3 1
a3 1
# $OpenBSD: PkgCreate.pm,v 1.54 2012/01/05 23:03:57 schwarze Exp $
d682 2
@


1.54
log
@Enable the new apropos(1), whatis(1), and makewhatis(8).
Unlink the old apropos(1), whatis(1), and makewhatis(8) from the build.
Call the new tools from pkg_create(1) and pkg_add(1).
"Please enable it now."  deraadt@@
@
text
@d3 1
a3 1
# $OpenBSD: PkgCreate.pm,v 1.53 2011/11/16 11:41:38 espie Exp $
d1109 11
a1119 2
		$state->system(OpenBSD::Paths->makewhatis, '-t', '--',
		    @@{$state->{manpages}});
@


1.53
log
@if the portstree gives us a cache directory, use it.
in lots of multi-packages scenarios that all depend on the main package,
this speeds things *a lot*.
case in point: in php 5.2,  make package goes down from 1mn40 to 53s.
@
text
@d3 1
a3 1
# $OpenBSD: PkgCreate.pm,v 1.52 2011/11/14 12:49:06 espie Exp $
d1109 2
a1110 11
		$state->{v} ++;

		require OpenBSD::Makewhatis;

		try {
			OpenBSD::Makewhatis::scan_manpages($state->{manpages}, 
			    $state);
		} catchall {
			$state->errsay("Error in makewhatis: #1", $_);
		};
		$state->{v} --;
@


1.52
log
@much better solver: don't try to solve every library, but just the ones
we have in the package we're trying to create.

So, solve one level, and keep solving until we have what we need or we
run out of level. Any package without @@wantlib and lots of runtime depends
will build MUCH faster. Other packages MAY build faster.
@
text
@d3 1
a3 1
# $OpenBSD: PkgCreate.pm,v 1.51 2011/11/14 10:31:20 espie Exp $
d635 19
a653 6
		my $plist = $self->ask_tree($state, $dep, $portsdir,
		    'print-plist-libs-with-depends', 'wantlib_args=no-wantlib-args');
		if ($? != 0 || !defined $plist->pkgname) {
			$state->error("Can't obtain dependency #1 from ports tree",
			    $dep->{pattern});
			return undef;
@


1.51
log
@use print-plist-libs-with-depends (and make sure it does not skip depends)
@
text
@d3 1
a3 1
# $OpenBSD: PkgCreate.pm,v 1.50 2011/10/21 18:19:34 espie Exp $
a569 1

d575 3
d582 23
a678 7
sub errsay_library
{
	my ($solver, $state, $h) = @@_;

	$state->errsay("Can't create #1 because of libraries", $h->pkgname);
}

d1081 1
a1081 1
	$solver->solve_all_depends($state);
d1084 3
a1086 1
	if (!$solver->solve_wantlibs($state)) {
@


1.50
log
@small optimization: tell pkg_create to skip !libs if LIBS_ONLY (to be
used in make print-plist-libs)
@
text
@d3 1
a3 1
# $OpenBSD: PkgCreate.pm,v 1.49 2011/09/25 08:26:28 espie Exp $
d611 1
a611 1
		    'print-plist-with-depends', 'wantlib_args=no-wantlib-args');
d808 1
a808 1
						next unless m/^\@@(?:cwd|lib)\b/o || m/lib.*\.a$/o;
@


1.49
log
@remove hack, ask for SUBDIRs with FULLPATH set
@
text
@d3 1
a3 1
# $OpenBSD: PkgCreate.pm,v 1.48 2011/09/17 09:49:55 espie Exp $
d787 1
d806 5
a810 1
					&$cont($subst->do($_));
d814 1
a814 2
	    }
	);
@


1.48
log
@work-around for default vs. no flavor
@
text
@d3 1
a3 1
# $OpenBSD: PkgCreate.pm,v 1.47 2011/06/24 14:36:16 espie Exp $
d643 2
a644 5
		my ($dir, @@parts) = split(/\,/, $dep->{pkgpath});
		if (@@parts == 0 || @@parts == 1 && $parts[0] =~ m/^\-/) {
			unshift(@@parts, '');
		}
		$ENV{SUBDIR} = join(',', $dir, @@parts);
@


1.47
log
@speed up dependency checking:
- if the ports tree is -current, do not compute
@@wantlib during dependencies.

- add an extra cache. The solver caches "exact" depends, we can also cache
pkgpaths when we go to the ports tree.

- make the checking computation progress message less painful by adding the
pkgpath currently investigated...
@
text
@d3 1
a3 1
# $OpenBSD: PkgCreate.pm,v 1.46 2011/06/20 09:41:46 espie Exp $
d643 5
a647 1
		$ENV{SUBDIR} = $dep->{pkgpath};
@


1.46
log
@zap extra try that's no longer needed: print-plist-with-depends should
always succeed since it only depends on the ports tree itself.
@
text
@d3 1
a3 1
# $OpenBSD: PkgCreate.pm,v 1.44 2011/04/25 00:16:58 espie Exp $
d584 2
d599 1
d606 15
a620 6
	my $plist = $self->ask_tree($state, $dep, $portsdir,
	    'print-plist-with-depends');
	if ($? != 0 || !defined $plist->pkgname) {
		$state->error("Can't obtain dependency #1 from ports tree",
		    $dep->{pattern});
		return undef;
d622 1
a622 1
	if ($dep->spec->filter($plist->pkgname) == 0) {
d624 1
a624 1
		    $dep->{pattern}, $plist->pkgname);
d628 1
a628 3
	OpenBSD::SharedLibs::add_libs_from_plist($plist, $state);
	$self->add_dep($plist);
	return $plist->pkgname;
d633 1
a633 1
	my ($self, $state, $dep, $portsdir, $action) = @@_;
d645 1
a645 1
		exec $make ('make', $action);
@


1.45
log
@change yet again how we handle transparent formatting of manpages.
simplify: actually create a tmp directory hierarchy that exactly mimics
what fake contains.  This avoids trouble with makewhatis checks.
Don't even try to remember what files are there, just wipe it all with
rmtree.
@
text
@d3 1
a3 1
# $OpenBSD$
d447 1
a447 1
	open my $fh, ">", $tempname or $state->error("can't create #1: #2",
a605 4
		$plist = $self->ask_tree($state, $dep, $portsdir,
		    'print-plist');
	}
	if ($? != 0 || !defined $plist->pkgname) {
d1066 1
a1066 1
			OpenBSD::Makewhatis::scan_manpages($state->{manpages},
@


1.44
log
@don't erase 1st manpage in case two manpages have the first name.
as noticed on texlive, among a host of other issues...
@
text
@d3 1
a3 1
# $OpenBSD: PkgCreate.pm,v 1.43 2011/03/19 12:06:11 espie Exp $
a250 4
sub remove_temp
{
}

d440 2
a441 1
	my $d = dirname($self->cwd."/".$dest);
d444 4
a447 9
	my $tempname = $state->{mandir}."/".basename($dest);
	if (-f $tempname) {
		my $i = 0;
		do {
			$tempname = $state->{mandir}."/".$i.basename($dest);
			$i++;
		} while (-f $tempname);
	}
	open my $fh, ">", $tempname or $state->error("can't create #1: #2", 
a467 10
sub remove_temp
{
	my $self = shift;

	if (defined $self->{wtempname}) {
		unlink($self->{wtempname});
		$self->{wtempname} = undef;
	}
}

d1070 1
a1070 1
			OpenBSD::Makewhatis::scan_manpages($state->{manpages}, 
a1077 1
	$plist->remove_temp;
d1079 2
a1080 1
		rmdir($state->{mandir});
@


1.43
log
@I can remove duplicate flag since that's handled upwards.
@
text
@d3 1
a3 1
# $OpenBSD: PkgCreate.pm,v 1.42 2011/03/07 09:26:47 espie Exp $
d448 7
@


1.42
log
@run makewhatis during pkg_create in verbose mode.
tweak temp manpage generation a bit, so that it has correct names in its
own directory, because makewhatis will be really pissed off otherwise.
@
text
@d3 1
a3 1
# $OpenBSD: PkgCreate.pm,v 1.41 2011/01/09 13:06:10 espie Exp $
d1125 1
a1125 1
	$state->handle_options('p:f:d:M:U:s:A:L:B:P:W:qQ',
@


1.41
log
@add yet another check: obviously in a @@depend line, if the def part doesn't
match the pattern, the package has something wrong.

prevents some bogus tk LIB_DEPENDS from even packaging.
@
text
@d3 1
a3 1
# $OpenBSD: PkgCreate.pm,v 1.40 2011/01/04 14:23:05 espie Exp $
d111 1
d425 12
d445 5
a449 2
	my ($fh, $tempname) = OpenBSD::Temp::permanent_file(
	    $ENV{TMPDIR} // '/tmp', "manpage.".basename($dest));
d1071 23
d1249 1
a1249 1
	$plist->remove_temp;
@


1.40
log
@go all the way, put temp pages in /tmp
@
text
@d3 1
a3 1
# $OpenBSD: PkgCreate.pm,v 1.39 2011/01/04 13:48:24 espie Exp $
d491 2
d495 1
a495 1
		$state->error("invalid \@@#1 #2 in packing-list\n#3, #4",
d498 7
a505 2

	$self->SUPER::avert_duplicates_and_other_checks($state);
@


1.39
log
@create tempfile directly under fake, no need to go down.
@
text
@d3 1
a3 1
# $OpenBSD: PkgCreate.pm,v 1.38 2011/01/02 15:25:45 espie Exp $
d432 2
a433 2
	my ($fh, $tempname) = OpenBSD::Temp::permanent_file($state->{base}, 
	    "manpage.".basename($dest));
@


1.38
log
@create formatted manpages as temporary files we remove after the fact.
@
text
@d3 1
a3 1
# $OpenBSD$
d432 1
a432 1
	my ($fh, $tempname) = OpenBSD::Temp::permanent_file($state->{base}.$d, 
@


1.37
log
@handle failures from ports tree with more care.
this does avoid infinite loops in case of wrong plists.
necessary since print-plist-with-depends CAN fail...
@
text
@d168 3
d250 4
a430 1
	my $out = $state->{base}.$self->cwd."/".$dest;
d432 3
d438 2
a439 2
	$self->format($state, $self->cwd."/".$dest);
	if (-z $out) {
d449 1
d453 10
d591 1
a591 1
	my $plist = $self->ask_tree($state, $dep, $portsdir, 
d594 1
a594 1
		$plist = $self->ask_tree($state, $dep, $portsdir, 
d1203 1
@


1.36
log
@simplify some more: if it's not installed, ask the ports tree, who knows,
we will catch more mismatches between spec and actual packagenames ?

set status during dependency check

don't check when simply printing the plist, this 'fixes' a bit of
port-lib-depends-check

don't fatal(), error() allows for more stuff to show up
@
text
@d3 1
a3 1
# $OpenBSD: PkgCreate.pm,v 1.35 2010/12/22 06:49:24 espie Exp $
d164 1
a164 1
			$state->error("User tried to define @@#1 for #2", 
d557 1
a557 1
	
d569 13
a581 7
	my $portsdir = $state->defines('PORTSDIR') 
	    // $ENV{'PORTSDIR'} 
	    // OpenBSD::Paths->portsdir;
	my $make = OpenBSD::Paths->make;
	open(my $fh, "cd $portsdir && SUBDIR=$dep->{pkgpath} ECHO_MSG=: $make print-plist-with-depends|") or return undef;
	my $plist = OpenBSD::PackingList->read($fh, 
	    \&OpenBSD::PackingList::PrelinkStuffOnly);
d583 1
a583 1
		$state->error("Dependency #1 doesn't match FULLPKGNAME: #2", 
d585 1
d593 22
d618 1
a618 1
	
d664 1
a664 1
	
@


1.35
log
@once we read the list, make sure it matches the dependency.
Otherwise, this WILL turn into an infinite loop indeed !
@
text
@d3 1
a3 1
# $OpenBSD: PkgCreate.pm,v 1.34 2010/12/21 11:25:19 espie Exp $
d558 1
a558 1
	# and in built tree if other packages have the same BASE_PKGPATH
d560 1
a560 7
		my $f = $state->{subst}->value('FULLPKGPATH');
		$f =~ s/,.*//;
		my $f2 = $dep->{pkgpath};
		$f2 =~ s/,.*//;
		if ($f eq $f2) {
			return $self->solve_from_ports($state, $dep, $package);
		}
d577 1
a577 1
		$state->fatal("Dependency #1 doesn't match FULLPKGNAME: #2", 
a1095 1
	$self->check_dependencies($plist, $state);
d1097 2
@


1.34
log
@simplify a bit:
- make find_dep_in_installed more regular
- zap the {more} entry, add_dep is okay for that purpose
- don't special case installed_list, provide older_names instead
- make PseudoSets slightly less hackish
- don't read full packinglist, prelinkstuff is exactly what we need
@
text
@d3 1
a3 1
# $OpenBSD: PkgCreate.pm,v 1.33 2010/12/20 16:30:04 espie Exp $
d582 5
@


1.33
log
@use a better strategy: ask the ports tree for the plist for packages with
the same pkgpath. Thus, PseudoSets need to have a real list, and
pkgcreate needs to loop to solve those depends.

reactivate the check
@
text
@d3 1
a3 1
# $OpenBSD: PkgCreate.pm,v 1.32 2010/12/20 11:48:42 espie Exp $
d540 2
a541 8
		$solver->{more} = [];
		$solver->solve_depends($state);
		if (@@{$solver->{more}}) {
			for my $i (@@{$solver->{more}}) {
				push(@@{$solver->{set}{new}}, 
				    OpenBSD::PseudoHandle->new($i));
			}
		} else {
d544 1
d553 1
a553 1
	my $v = $self->find_in_installed($dep);
d580 2
a581 1
	my $plist = OpenBSD::PackingList->read($fh);
d583 1
a583 1
	push(@@{$self->{more}}, $plist);
a586 10
# the full installed list is okay
OpenBSD::Auto::cache(installed_list,
	sub {
		require OpenBSD::PackageInfo;

		my @@l = OpenBSD::PackageInfo::installed_packages();
		return \@@l;
	}
);

d617 5
a621 1
	my ($class, $plist) = @@_;
d623 7
a629 2
	my $h = OpenBSD::PseudoHandle->new($plist);
	bless {new => [$h]}, $class;
d644 5
@


1.32
log
@disable temporarily
@
text
@d3 1
a3 1
# $OpenBSD: PkgCreate.pm,v 1.31 2010/12/20 11:32:30 espie Exp $
d534 19
d559 3
d564 1
a564 1
	if (!defined $v && !defined $self->{all_dependencies}{BUILD}) {
d570 1
a570 1
			return $self->add_built_libraries($state);	
d576 1
a576 1
sub add_built_libraries
d578 11
a588 11
	my ($self, $state) = @@_;
	require File::Find;
	File::Find::find(sub {
		return unless -f $_;
		my $libname = $File::Find::name;
		$libname =~ s,^\Q$state->{base}\E,,;
		my $lib = OpenBSD::Library->from_string($libname);
		return unless $lib->is_valid;
		OpenBSD::SharedLibs::register_library($lib, "BUILD");
		}, $state->{base});
	return "BUILD";
d634 1
a634 1
	bless {h => $h}, $class;
d639 1
a639 1
	return (shift->{h});
d642 6
d661 1
a661 1
	return $self->{h}->pkgname;
d992 1
a992 1
	$solver->solve_depends($state);
d1097 1
a1097 1
#	$self->check_dependencies($plist, $state);
@


1.31
log
@new check in pkg_create: walk the dependency tree for @@wantlib, thus
preventing packages that won't install (much easier to fix that when
you still have the fake tree around !)

specifically, look into depend that are installed, and possibly in the
fake tree: if the package does build, it requires the libraries to be
around anyways, so pure RUN_DEPENDS are not an issue (and avoid old libraries,
if we find wantlib only in .lib, something really fishy is going on).

Reuse the Dependencies class, so we're sure to have the exact same way
to find libraries.

Also fix exit codes from pkg_create...
@
text
@d3 1
a3 1
# $OpenBSD: PkgCreate.pm,v 1.30 2010/12/20 08:59:59 espie Exp $
d1069 1
a1069 1
	$self->check_dependencies($plist, $state);
@


1.30
log
@use state->defines
@
text
@d3 1
a3 1
# $OpenBSD: PkgCreate.pm,v 1.29 2010/12/05 09:41:55 espie Exp $
d23 2
d523 113
d959 14
d1069 1
d1082 1
a1082 2
		$state->error("can't write unnamed packing-list");
		return 1;
d1095 1
a1095 2
		$state->error("found obsolete constructs");
		return 1;
d1102 1
a1102 1
		return 1;
@


1.29
log
@tweak the framework so that individual modules don't exist and return
the exit code upstream instead.
this simplifies the task of people who want to reuse it, as noted by
landry@@
@
text
@d3 1
a3 1
# $OpenBSD: PkgCreate.pm,v 1.28 2010/11/27 11:54:25 espie Exp $
d973 1
a973 1
	if ($state->{bad} && $state->{subst}->empty('REGRESSION_TESTING')) {
@


1.28
log
@minor fix for ports which install manpages in other directories: keep
track of all known directories, so when we generate a manpage in a new
catN directory, we add the entry and it gets deleted properly.
-> requires a bump to affected packages.
@
text
@d3 1
a3 1
# $OpenBSD: PkgCreate.pm,v 1.27 2010/10/27 14:35:56 espie Exp $
d923 1
a923 1
		exit(0);
d953 1
a953 1
		exit 1;
d962 1
a962 1
		exit 0 if defined $state->opt('n');
d967 1
a967 1
		exit 1;
d974 1
a974 1
		exit 1;
d1000 1
a1000 1
		exit(1);
d1002 1
@


1.27
log
@initial scaffolding for @@rcscript: for now, acts like normal files,
but allow absolute pathnames (treat that as an implicit @@cwd).
@
text
@d3 1
a3 1
# $OpenBSD: PkgCreate.pm,v 1.26 2010/10/25 21:33:15 espie Exp $
d240 5
d389 7
d413 2
d423 4
d433 4
d939 1
@


1.26
log
@@@symlink/@@size/@@link are generated automatically, make pkg_create(1) error
out if we create them manually, instead of erroring later during pkg_add.
@
text
@d3 1
a3 1
# $OpenBSD: PkgCreate.pm,v 1.25 2010/10/25 18:00:10 espie Exp $
d240 10
@


1.25
log
@just bail out of producing empty files.
*this will become an error eventually, please fix those*
@
text
@d3 1
a3 1
# $OpenBSD: PkgCreate.pm,v 1.24 2010/10/24 17:06:05 espie Exp $
d160 6
a165 1

@


1.24
log
@use newer system for more efficient redirection, and chdir the way man(1)
does, so groff is happier with .so.
(agreed by ingo)
@
text
@d3 1
a3 1
# $OpenBSD: PkgCreate.pm,v 1.23 2010/10/02 13:33:05 espie Exp $
d395 5
@


1.23
log
@whitespace
@
text
@d3 1
a3 1
# $OpenBSD$
d393 2
a394 1
	$self->format($state->{base}, $self->cwd."/".$dest);
@


1.22
log
@pass state to Ustar objects, use it to display those pesky error and
fatal messages.

zap $opt_x from pkg_mklocated, do things like other commands do.
@
text
@d3 1
a3 1
# $OpenBSD: PkgCreate.pm,v 1.21 2010/07/09 12:42:43 espie Exp $
d777 1
a777 1
	$state->{archive} = $self->create_archive($state, $wname, 
d948 1
a948 1
		$state->{archive} = OpenBSD::Ustar->new(undef, $state, 
@


1.21
log
@fix pkg_mklocatedb
@
text
@d3 1
a3 1
# $OpenBSD$
d624 1
a624 1
	my ($self, $filename, $dir) = @@_;
d626 1
a626 1
	return  OpenBSD::Ustar->new($fh, $dir);
d642 1
a642 1
	my $wrarc = $self->create_archive($tmp, ".");
d777 2
a778 1
	$state->{archive} = $self->create_archive($wname, $plist->infodir);
d948 2
a949 1
		$state->{archive} = OpenBSD::Ustar->new(undef, $plist->infodir);
@


1.20
log
@we can't checksum directories either, so give a better error message
@
text
@d3 1
a3 1
# $OpenBSD: PkgCreate.pm,v 1.19 2010/06/30 10:51:04 espie Exp $
@


1.19
log
@allow say and errsay to work without parameters, as it's ways common.
create verbose_system up in state, because it makes sense without verbose.
@
text
@d3 1
a3 1
# $OpenBSD$
d184 2
@


1.18
log
@whitespace cleanup
@
text
@@


1.17
log
@pass state along when signing packages, uses repo and fatal directly
@
text
@d3 1
a3 1
# $OpenBSD: PkgCreate.pm,v 1.16 2010/06/25 10:21:41 espie Exp $
d138 1
a138 1
		my $l = readlink($filename); 
d517 1
a517 1
		$state->set_status("switching to $newname") 
d611 1
a611 1
		
d790 1
a790 1
		$state->errsay("Warning: symlink(s) point to non-existent #1", 
d879 1
a879 1
		$plist = $self->create_plist($state, $ARGV[0], \@@contents, 
d949 1
a949 1
	} 
@


1.16
log
@use locator object.
rework options into state
@
text
@d3 1
a3 1
# $OpenBSD: PkgCreate.pm,v 1.15 2010/06/20 08:32:26 espie Exp $
d629 1
a629 1
	my ($self, $repo, $pkgname, $cert, $privkey) = @@_;
d632 2
a633 2
	my $true_package = $repo->find($pkgname);
	die "No such package $pkgname" unless $true_package;
d646 1
a646 1
	    die "Can't create final signed package $!\n";
a873 3
		require OpenBSD::PackageLocator;

		my $repo = OpenBSD::PackageLocator->new($state);
d875 1
a875 1
			$self->sign_existing($repo, $pkgname, $cert, $privkey);
@


1.15
log
@display bad symlinks by destination
@
text
@d3 1
a3 1
# $OpenBSD: PkgCreate.pm,v 1.14 2010/06/14 22:08:24 espie Exp $
d629 1
a629 1
	my ($self, $pkgname, $cert, $privkey) = @@_;
a630 1
	require OpenBSD::PackageLocator;
d632 1
a632 1
	my $true_package = OpenBSD::PackageLocator->find($pkgname);
d827 2
a828 1
	$self->handle_options('p:f:d:M:U:s:A:L:B:P:W:qQ', $state,
d874 3
d878 1
a878 1
			$self->sign_existing($pkgname, $cert, $privkey);
@


1.14
log
@zap empty message...
@
text
@d3 1
a3 1
# $OpenBSD: PkgCreate.pm,v 1.13 2010/06/11 23:44:37 espie Exp $
d172 1
a172 2
			$state->errsay("Warning: symlink #1 points to non-existent #2", 
			    $fname, $chk);
d787 12
d900 1
@


1.13
log
@don't call working() in -q mode.
@
text
@d3 1
a3 1
# $OpenBSD: PkgCreate.pm,v 1.12 2010/06/09 10:47:05 espie Exp $
d57 1
a57 1
			$self->progress->message;
d671 1
a671 1
		$state->warn("Package without FULLPKGPATH\n");
@


1.12
log
@no need to fatal(), we can error() and keep going.
@
text
@d3 1
a3 1
# $OpenBSD: PkgCreate.pm,v 1.11 2010/06/09 10:41:19 espie Exp $
d539 1
a539 1
				$state->progress->working(2048);
@


1.11
log
@warns if packages contain symlinks that point to non-existent places.
actually error out if a symlink points to itself.
this breaks evolution, until someone fixes the bogus symlinks.
@
text
@d3 1
a3 1
# $OpenBSD: PkgCreate.pm,v 1.10 2010/06/09 10:22:54 espie Exp $
d170 1
a170 1
			$state->fatal("bogus symlink: #1 (too deep)", $fname);
@


1.10
log
@make error messages more consistent. Add an extra sanity check which
shouldn't trigger for special files
@
text
@d3 1
a3 1
# $OpenBSD: PkgCreate.pm,v 1.9 2010/06/09 07:26:01 espie Exp $
d133 19
d167 8
@


1.9
log
@ui changes: go thru a state object for most printouts
@
text
@d3 1
a3 1
# $OpenBSD: PkgCreate.pm,v 1.8 2010/06/08 07:49:00 espie Exp $
d45 1
d47 1
a47 1
	$self->errsay(@@_);
d118 1
a118 1
		$state->error("Error in packing-list: duplicate item #1", $n);
d143 4
d159 1
a159 1
		$state->error("Error in package: #1 does not exist", $fname);
d180 1
a180 1
		    	$state->error("Error: #1 inconsistency for #2",
d187 1
a187 1
	    	$state->error("Error: checksum inconsistency for #1",
d199 1
a199 1
		$state->error("Modes don't match");
d375 1
a375 1
		$state->error("Error in packing-list: invalid \@@#1 #2",
d400 1
a400 1
		$state->error("Error in packing-list: invalid \@@#1 #2\n#3, #4",
d415 1
a415 1
		$state->error("Bad packagename #1: ", $self->name,
d518 1
a518 1
				    	$state->error("Shared library without SHARED_LIBS: $_");
d702 1
a702 1
		    $state->fatal("can't read packing list #1", $contentsfile);
d728 1
a728 1
	    $state->fatal("can't read packing list #1", $contents);
d822 1
a822 1
			$state->usage("Packing list required");
d829 1
a829 1
			$state->usage("Exactly one single packing list is required");
d866 1
a866 1
		$state->error("Can't write unnamed packing list");
d880 1
a880 1
		$state->error("Error: found obsolete constructs");
d901 1
a901 1
		$plist->save or $state->fatal("can't write packing list");
@


1.8
log
@tweak tweak so it works
@
text
@d3 1
a3 1
# $OpenBSD: PkgCreate.pm,v 1.7 2010/06/08 07:25:38 espie Exp $
d117 1
a117 1
		$state->error("Error in packing-list: duplicate item $n");
d154 1
a154 1
		$state->error("Error in package: $fname does not exist");
d175 2
a176 2
		    	$state->error("Error: $field inconsistency for ",
			    $self->fullname);
d182 1
a182 1
	    	$state->error("Error: checksum inconsistency for ",
d370 2
a371 2
		$state->error("Error in packing-list: invalid \@@",
		    $self->keyword, " ", $self->stringize);
d395 3
a397 3
		$state->error("Error in packing-list: invalid \@@",
		    $self->keyword, " ", $self->stringize, "\n",
		    "$self->{def}: , ", join(' ', @@issues));
d410 1
a410 1
		$state->error("Bad packagename ", $self->name, ":",
d538 1
a538 1
	my ($subst, $plist, $name, $opt_d) = @@_;
d540 1
d544 2
a545 4
			print STDERR "Error: comment is too long\n";
			print STDERR $comment, "\n";
			print STDERR ' 'x60, "^"x (length($comment)-60), "\n";
			exit 1;
d548 1
a548 1
		Usage "Comment required";
d551 1
a551 1
		Usage "Description required";
d565 1
a565 1
			Warn "no MAINTAINER\n";
d621 1
a621 1
	my ($self, $plist, $subst) = @@_;
d623 1
d639 1
a639 1
		Warn "Package without FULLPKGPATH\n";
d648 1
a648 1
	add_description($subst, $plist, DESC, $state->opt('d'));
d654 1
a654 1
		Usage "Prefix required";
d671 1
a671 1
	$self->add_extra_info($plist, $subst);
d685 1
a685 1
	print "Creating package $pkgname\n" 
d697 1
a697 1
		    Fatal "Can't read packing list $contentsfile";
d713 1
a713 1
	my ($self, $contents) = @@_;
d723 1
a723 1
	    Fatal "Can't read packing list $contents";
d731 2
a732 1
	print "Creating gzip'd tar ball in '$wname'\n" if $state->opt('v');
d758 1
a758 1
	my $self = shift;
d766 1
a766 1
	my $state = OpenBSD::PkgCreate::State->new;
d786 1
a786 1
	    'pkg_create [-nQqvx] [-A arches] [-B pkg-destdir] [-D name[=value]]',
d795 1
a795 2
			Usage "Exactly one single package name is required: ",
			    join(' ', @@ARGV);
d803 1
a803 1
			Usage "Signature only works as -s x509 -s cert -s privkey";
d817 1
a817 1
			Usage "Packing list required";
d824 1
a824 1
			Usage "Exactly one single packing list is required";
d826 1
a826 1
		$plist = $self->read_existing_plist($contents[0]);
d829 1
a829 1
			Fatal "Can't pretend to sign existing packages";
d896 1
a896 1
		$plist->save or Fatal "Can't write packing list";
@


1.7
log
@tweak fragment handling a bit more. In particular, protest when we can't
get a fragment, regardless of whether or not we're going to use it.
@
text
@d3 1
a3 1
# $OpenBSD: PkgCreate.pm,v 1.6 2010/06/07 13:51:19 espie Exp $
d481 1
a481 1
		return if defined $not;
d483 1
a483 1
		return unless defined $not;
@


1.6
log
@display "switching to" with ->set_status
@
text
@d3 1
a3 1
# $OpenBSD: PkgCreate.pm,v 1.5 2010/06/06 11:00:40 espie Exp $
a463 2
		$state->set_status("switching to $noto")
		    if !defined $state->opt('q');
a465 2
		$state->set_status("switching to $o")
		    if !defined $state->opt('q');
d471 23
a504 1
		local $_;
d506 1
a506 2
			GETLINE:
			while ($_ = $file->readline) {
a507 18
				if (my ($not, $frag) = m/^(\!)?\%\%(.*)\%\%$/) {
					my $def = $frag;
					if ($frag eq 'SHARED') {
						$def = 'SHARED_LIBS';
						$frag = 'shared';
					}
					if ($subst->has_fragment($def, $frag)) {
						next GETLINE if defined $not;
					} else {
						next GETLINE unless defined $not;
					}
					my $newname = deduce_name($state, $file->name, $frag, $not);
					if (defined $newname) {
						push(@@$stack, $file);
						$file = MyFile->new($newname);
					}
					next GETLINE;
				}
d515 6
a520 1
				&$cont($subst->do($_));
@


1.5
log
@clean-up into smaller functions
@
text
@d3 1
a3 1
# $OpenBSD$
d464 2
a465 1
		print "Switching to $noto\n" if !defined $state->opt('q');
d468 2
a469 1
		print "Switching to $o\n" if !defined $state->opt('q');
@


1.4
log
@add working cartwheel
@
text
@d3 1
a3 1
# $OpenBSD: PkgCreate.pm,v 1.3 2010/06/05 09:15:55 espie Exp $
d33 1
d49 27
d572 64
a635 1
my (@@contents, %dependencies, %wantlib, @@signature_params);
d637 111
a747 3
my $regen_package = 0;
my $sign_only = 0;
my ($cert, $privkey);
d753 6
a759 1
	my $plist = new OpenBSD::PackingList;
a783 2
	my $subst = $state->{subst};

a793 1

d815 1
a815 1
	my $cont = 0;
d820 1
a820 8
		if (-d $contents[0] && -f $contents[0].'/'.CONTENTS) {
			$plist->set_infodir($contents[0]);
			$contents[0] .= '/'.CONTENTS;
		} else {
			$plist->set_infodir(dirname($contents[0]));
		}
		$plist->fromfile($contents[0]) or
		    Fatal "Can't read packing list $contents[0]";
d826 1
a826 23
			require OpenBSD::PackageLocator;
			require OpenBSD::x509;

			my $true_package = OpenBSD::PackageLocator->find($pkgname);
			die "No such package $pkgname" unless $true_package;
			my $dir = $true_package->info;
			my $plist = OpenBSD::PackingList->fromfile($dir.CONTENTS);
			$plist->set_infodir($dir);
			my $sig = OpenBSD::PackingElement::DigitalSignature->new_x509;
			$sig->add_object($plist);
			$sig->{b64sig} = OpenBSD::x509::compute_signature($plist,
			    $cert, $privkey);
			$plist->save;
			my $tmp = OpenBSD::Temp::permanent_file(".", "pkg");
			open( my $outfh, "|-", OpenBSD::Paths->gzip, "-o", $tmp);

			my $wrarc = OpenBSD::Ustar->new($outfh, ".");
			$plist->copy_over($wrarc, $true_package);
			$wrarc->close;
			$true_package->wipe_info;
			unlink($plist->pkgname.".tgz");
			rename($tmp, $plist->pkgname.".tgz") or
			    die "Can't create final signed package $!";
d830 2
a831 62
		print "Creating package $ARGV[0]\n" if !(defined $state->opt('q')) && $state->opt('v');
		if (!$state->opt('q')) {
			$plist->set_infodir(OpenBSD::Temp->dir);
		}
		add_description($subst, $plist, DESC, $state->opt('d'));
		add_special_file($subst, $plist, DISPLAY, $state->opt('M'));
		add_special_file($subst, $plist, UNDISPLAY, $state->opt('U'));
		if (defined $state->opt('p')) {
			OpenBSD::PackingElement::Cwd->add($plist, $state->opt('p'));
		} else {
			Usage "Prefix required";
		}
		for my $d (sort keys %dependencies) {
			OpenBSD::PackingElement::Dependency->add($plist, $d);
		}

		for my $w (sort keys %wantlib) {
			OpenBSD::PackingElement::Wantlib->add($plist, $w);
		}

		if (defined $state->opt('A')) {
			OpenBSD::PackingElement::Arch->add($plist, $state->opt('A'));
		}

		if (defined $state->opt('L')) {
			OpenBSD::PackingElement::LocalBase->add($plist, $state->opt('L'));
		}
		if ($ARGV[0] =~ m|([^/]+)$|o) {
			my $pkgname = $1;
			$pkgname =~ s/\.tgz$//o;
			$plist->set_pkgname($pkgname);
		}
		my $fullpkgpath = $subst->value('FULLPKGPATH');
		my $cdrom = $subst->value('PERMIT_PACKAGE_CDROM') ||
		    $subst->value('CDROM');;
		my $ftp = $subst->value('PERMIT_PACKAGE_FTP') ||
		    $subst->value('FTP');
		if (defined $fullpkgpath || defined $cdrom || defined $ftp) {
			$fullpkgpath //= '';
			$cdrom //= 'no';
			$ftp //= 'no';
			$cdrom = 'yes' if $cdrom =~ m/^yes$/io;
			$ftp = 'yes' if $ftp =~ m/^yes$/io;

			OpenBSD::PackingElement::ExtraInfo->add($plist,
			    $fullpkgpath, $cdrom, $ftp);
		} else {
			Warn "Package without FULLPKGPATH\n";
		}
		unless (defined $state->opt('q') && defined $state->opt('n')) {
			if ($state->progress->set_header("reading plist")) {
				$state->progress->message;
			} else {
				$| = 1;
				print "Reading plist...";
				$cont = 1;
			}
		}
		for my $contentsfile (@@contents) {
			read_fragments($state, $plist, $contentsfile) or
			    Fatal "Can't read packing list $contentsfile";
		}
d845 1
a845 5
		if ($cont) {
			print "\nChecksumming...";
		} else {
			$state->progress->set_header("checksumming");
		}
d849 1
a849 7
			my $p2 = OpenBSD::PackingList->new;
			$state->progress->visit_with_count($plist, 'makesum_plist', $p2, $state);
			$p2->set_infodir($plist->infodir);
			$plist = $p2;
		}
		if ($cont) {
			print "\n";
d851 1
d854 1
a854 1
	if (!defined $plist->{name}) {
d876 1
a876 1
	if ($state->{bad} && $subst->empty('REGRESSION_TESTING')) {
d882 1
a882 4
		my $sig = OpenBSD::PackingElement::DigitalSignature->new_x509;
		$sig->add_object($plist);
		require OpenBSD::x509;
		$sig->{b64sig} = OpenBSD::x509::compute_signature($plist, $cert, $privkey);
d898 3
a900 33
		print "Creating gzip'd tar ball in '$wname'\n" if $state->opt('v');
		my $h = sub {
			unlink $wname;
			my $caught = shift;
			$SIG{$caught} = 'DEFAULT';
			kill $caught, $$;
		};

		local $SIG{'INT'} = $h;
		local $SIG{'QUIT'} = $h;
		local $SIG{'HUP'} = $h;
		local $SIG{'KILL'} = $h;
		local $SIG{'TERM'} = $h;
		open(my $fh, "|-", OpenBSD::Paths->gzip, "-f", "-o", $wname);
		$state->{archive} = OpenBSD::Ustar->new($fh, $plist->infodir);

		if ($cont) {
			print "Archiving...";
		} else {
			$state->progress->set_header("archiving");
		}
		$state->progress->visit_with_size($plist, 'create_package', $state);
		if ($cont) {
			print "\n";
		}
		$state->progress->clear;
		$state->{archive}->close;
		if ($state->{bad}) {
			unlink($wname);
			exit(1);
		}
	}
	} catch {
@


1.3
log
@move use to common part
@
text
@d3 1
a3 1
# $OpenBSD: PkgCreate.pm,v 1.2 2010/06/04 17:29:53 espie Exp $
d460 1
@


1.2
log
@add ->spec to Conflict and use the same check as for depend during pkg_create.
@
text
@d3 1
a3 1
# $OpenBSD: PkgCreate.pm,v 1.1 2010/06/04 13:19:39 espie Exp $
a57 2
use OpenBSD::Subst;
use OpenBSD::ProgressMeter;
@


1.1
log
@move code around, so that commands can be used as modules.
pkg becomes the start hub, which does nothing except require the
correct module.
Saner code wrt Add/Delete, and more sharing.
@
text
@d3 1
a3 1
# $OpenBSD: pkg_create,v 1.139 2010/05/10 09:17:55 espie Exp $
d348 6
@

