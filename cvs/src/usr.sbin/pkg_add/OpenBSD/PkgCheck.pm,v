head	1.64;
access;
symbols
	OPENBSD_6_1_BASE:1.64
	OPENBSD_6_0:1.59.0.4
	OPENBSD_6_0_BASE:1.59
	OPENBSD_5_9:1.57.0.2
	OPENBSD_5_9_BASE:1.57
	OPENBSD_5_8:1.56.0.4
	OPENBSD_5_8_BASE:1.56
	OPENBSD_5_7:1.55.0.2
	OPENBSD_5_7_BASE:1.55
	OPENBSD_5_6:1.54.0.4
	OPENBSD_5_6_BASE:1.54
	OPENBSD_5_5:1.46.0.4
	OPENBSD_5_5_BASE:1.46
	OPENBSD_5_4:1.40.0.2
	OPENBSD_5_4_BASE:1.40
	OPENBSD_5_3:1.39.0.2
	OPENBSD_5_3_BASE:1.39
	OPENBSD_5_2:1.37.0.2
	OPENBSD_5_2_BASE:1.37
	OPENBSD_5_1_BASE:1.33
	OPENBSD_5_1:1.33.0.2
	OPENBSD_5_0:1.30.0.2
	OPENBSD_5_0_BASE:1.30
	OPENBSD_4_9:1.28.0.2
	OPENBSD_4_9_BASE:1.28
	OPENBSD_4_8:1.23.0.2
	OPENBSD_4_8_BASE:1.23;
locks; strict;
comment	@# @;


1.64
date	2017.03.14.23.30.36;	author espie;	state Exp;
branches;
next	1.63;
commitid	bBBtgv49NJxHSmhV;

1.63
date	2017.03.11.12.28.30;	author espie;	state Exp;
branches;
next	1.62;
commitid	SDEiTZlIUV5zjGgj;

1.62
date	2016.08.26.18.19.21;	author espie;	state Exp;
branches;
next	1.61;
commitid	Qu74OUmDpyRnMR7D;

1.61
date	2016.08.25.16.27.16;	author jmc;	state Exp;
branches;
next	1.60;
commitid	STJKeSvNbPEWOQfK;

1.60
date	2016.08.25.14.58.43;	author espie;	state Exp;
branches;
next	1.59;
commitid	dqHkwVYHptSAcYQ8;

1.59
date	2016.06.15.15.40.13;	author espie;	state Exp;
branches;
next	1.58;
commitid	FvFggVo6v6h0AgLZ;

1.58
date	2016.06.06.15.19.45;	author espie;	state Exp;
branches;
next	1.57;
commitid	5ZvORJhUrqy17eFI;

1.57
date	2015.10.21.10.11.13;	author espie;	state Exp;
branches;
next	1.56;
commitid	EFTLl5vwWubelz9a;

1.56
date	2015.05.24.07.53.14;	author espie;	state Exp;
branches;
next	1.55;
commitid	cf634iBpC3T6NJom;

1.55
date	2014.11.29.10.42.51;	author espie;	state Exp;
branches;
next	1.54;
commitid	XiRgNGt76qJ9BWZO;

1.54
date	2014.07.27.22.18.36;	author espie;	state Exp;
branches;
next	1.53;
commitid	Z009Q6qBcRTJgEA6;

1.53
date	2014.07.14.08.47.49;	author espie;	state Exp;
branches;
next	1.52;
commitid	ja6CSic7SEsRa8BZ;

1.52
date	2014.07.13.17.17.21;	author espie;	state Exp;
branches;
next	1.51;
commitid	xRA70cbi6tAP2HJU;

1.51
date	2014.07.12.19.39.09;	author espie;	state Exp;
branches;
next	1.50;
commitid	kxwCtgUpQ6XSw7AU;

1.50
date	2014.07.11.13.37.02;	author espie;	state Exp;
branches;
next	1.49;
commitid	Vw9VKfYRPmFbsncc;

1.49
date	2014.04.15.11.02.38;	author espie;	state Exp;
branches;
next	1.48;

1.48
date	2014.04.14.21.55.37;	author espie;	state Exp;
branches;
next	1.47;

1.47
date	2014.03.18.18.53.29;	author espie;	state Exp;
branches;
next	1.46;

1.46
date	2014.02.10.19.40.47;	author espie;	state Exp;
branches;
next	1.45;

1.45
date	2014.01.10.16.09.08;	author espie;	state Exp;
branches;
next	1.44;

1.44
date	2014.01.09.20.20.01;	author espie;	state Exp;
branches;
next	1.43;

1.43
date	2014.01.02.16.05.42;	author espie;	state Exp;
branches;
next	1.42;

1.42
date	2013.12.25.14.38.15;	author espie;	state Exp;
branches;
next	1.41;

1.41
date	2013.09.11.15.36.18;	author espie;	state Exp;
branches;
next	1.40;

1.40
date	2013.05.26.16.02.20;	author espie;	state Exp;
branches;
next	1.39;

1.39
date	2012.11.06.15.43.04;	author jmc;	state Exp;
branches;
next	1.38;

1.38
date	2012.11.06.08.01.35;	author espie;	state Exp;
branches;
next	1.37;

1.37
date	2012.04.16.13.27.25;	author espie;	state Exp;
branches;
next	1.36;

1.36
date	2012.04.16.10.55.31;	author espie;	state Exp;
branches;
next	1.35;

1.35
date	2012.04.16.10.32.05;	author espie;	state Exp;
branches;
next	1.34;

1.34
date	2012.04.16.10.29.53;	author espie;	state Exp;
branches;
next	1.33;

1.33
date	2012.01.07.16.28.16;	author espie;	state Exp;
branches;
next	1.32;

1.32
date	2011.11.26.17.35.09;	author espie;	state Exp;
branches;
next	1.31;

1.31
date	2011.11.26.17.27.57;	author espie;	state Exp;
branches;
next	1.30;

1.30
date	2011.07.17.09.56.12;	author espie;	state Exp;
branches;
next	1.29;

1.29
date	2011.06.27.12.13.56;	author espie;	state Exp;
branches;
next	1.28;

1.28
date	2010.12.29.13.03.05;	author espie;	state Exp;
branches;
next	1.27;

1.27
date	2010.12.24.10.31.59;	author espie;	state Exp;
branches;
next	1.26;

1.26
date	2010.12.24.09.04.14;	author espie;	state Exp;
branches;
next	1.25;

1.25
date	2010.12.05.09.41.55;	author espie;	state Exp;
branches;
next	1.24;

1.24
date	2010.10.02.13.33.43;	author espie;	state Exp;
branches;
next	1.23;

1.23
date	2010.07.12.15.54.48;	author espie;	state Exp;
branches;
next	1.22;

1.22
date	2010.07.08.10.16.13;	author sthen;	state Exp;
branches;
next	1.21;

1.21
date	2010.06.30.10.51.04;	author espie;	state Exp;
branches;
next	1.20;

1.20
date	2010.06.30.10.41.42;	author espie;	state Exp;
branches;
next	1.19;

1.19
date	2010.06.25.10.58.08;	author espie;	state Exp;
branches;
next	1.18;

1.18
date	2010.06.18.09.01.38;	author espie;	state Exp;
branches;
next	1.17;

1.17
date	2010.06.15.08.53.55;	author espie;	state Exp;
branches;
next	1.16;

1.16
date	2010.06.15.08.45.15;	author espie;	state Exp;
branches;
next	1.15;

1.15
date	2010.06.15.08.26.39;	author espie;	state Exp;
branches;
next	1.14;

1.14
date	2010.06.14.08.16.14;	author espie;	state Exp;
branches;
next	1.13;

1.13
date	2010.06.10.07.21.07;	author espie;	state Exp;
branches;
next	1.12;

1.12
date	2010.06.09.11.21.15;	author espie;	state Exp;
branches;
next	1.11;

1.11
date	2010.06.09.09.53.03;	author espie;	state Exp;
branches;
next	1.10;

1.10
date	2010.06.09.07.26.01;	author espie;	state Exp;
branches;
next	1.9;

1.9
date	2010.06.07.13.41.22;	author espie;	state Exp;
branches;
next	1.8;

1.8
date	2010.06.07.10.39.09;	author espie;	state Exp;
branches;
next	1.7;

1.7
date	2010.06.07.10.02.27;	author espie;	state Exp;
branches;
next	1.6;

1.6
date	2010.06.07.09.54.28;	author espie;	state Exp;
branches;
next	1.5;

1.5
date	2010.06.07.09.18.11;	author espie;	state Exp;
branches;
next	1.4;

1.4
date	2010.06.07.09.10.37;	author espie;	state Exp;
branches;
next	1.3;

1.3
date	2010.06.06.09.08.44;	author espie;	state Exp;
branches;
next	1.2;

1.2
date	2010.06.05.18.08.31;	author espie;	state Exp;
branches;
next	1.1;

1.1
date	2010.06.05.17.15.32;	author espie;	state Exp;
branches;
next	;


desc
@@


1.64
log
@a few more characters that are safe to print
pass thru the $@@ "dieing" report from reading a plist.
@
text
@#! /usr/bin/perl

# ex:ts=8 sw=4:
# $OpenBSD: PkgCheck.pm,v 1.63 2017/03/11 12:28:30 espie Exp $
#
# Copyright (c) 2003-2014 Marc Espie <espie@@openbsd.org>
#
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

use strict;
use warnings;

use OpenBSD::AddCreateDelete;
use OpenBSD::SharedLibs;

package Installer::State;
our @@ISA = qw(OpenBSD::PkgAdd::State);
sub new
{
	my ($class, $cmd) = @@_;
	my $state = $class->SUPER::new($cmd);
	$state->{localbase} = OpenBSD::Paths->localbase;
	return $state;
}

package Installer;
our @@ISA = qw(OpenBSD::PkgAdd);

sub new
{
	my ($class, $mystate) = @@_;
	my $state = Installer::State->new("pkg_check");
	$state->{v} = $mystate->{v};
	$state->{subst} = $mystate->{subst};
	$state->{interactive} = $mystate->{interactive};
	$state->{destdir} = $mystate->{destdir};
	$state->progress->setup($state->opt('x'), $state->opt('m'), $state);
	bless { state => $state}, $class;
}

sub install
{
	my ($self, $pkg) = @@_;
	my $state = $self->{state};
	push(@@{$state->{setlist}}, 
	    $state->updateset->add_hints2($pkg));
	$self->framework($state);
	return $state->{bad} != 0;
}

package OpenBSD::PackingElement;
sub thorough_check
{
	my ($self, $state) = @@_;
	$self->basic_check($state);
}

sub basic_check
{
}

sub find_dependencies
{
}

package OpenBSD::PackingElement::FileBase;
use File::Basename;

sub basic_check
{
	my ($self, $state) = @@_;

	my $name = $state->destdir($self->fullname);
	$state->{known}{dirname($name)}{basename($name)} = 1;
	if ($self->{symlink}) {
		if (!-l $name) {
			if (!-e $name) {
				$state->log("#1 should be a symlink but does not exist", $name);
			} else {
				$state->log("#1 is not a symlink", $name);
			}
		} else {
			if (readlink($name) ne $self->{symlink}) {
				$state->log("#1 should point to #2 but points to #3 instead",
				    $name, $self->{symlink}, readlink($name));
			}
		}
		return;
	}
	if (!-e $name) {
		if (-l $name) {
			$state->log("#1 points to non-existent #2",
			    $name, readlink($name));
		} else {
			$state->log("#1 should exist", $name);
		}
	}
	if (!-f _) {
		$state->log("#1 is not a file", $name);
	}
	if ($self->{link}) {
		my ($a, $b) = (stat _)[0, 1];
		if (!-f $state->destdir($self->{link})) {
			$state->log("#1 should link to non-existent #2",
			    $name, $self->{link});
		} else {
			my ($c, $d) = (stat _)[0, 1];
			if (defined $a && defined $c) {
				if ($a != $c || $b != $d) {
					$state->log("#1 doesn't link to #2",
					    $name, $self->{link});
				}
			}
		}
	}
}

sub thorough_check
{
	my ($self, $state) = @@_;
	my $name = $state->destdir($self->fullname);
	$self->basic_check($state);
	return if $self->{link} or $self->{symlink} or $self->{nochecksum};
	if (!-r $name) {
		$state->log("can't read #1", $name);
		return;
	}
	if (!defined $self->{d}) {
		$state->log("no checksum for #1", $name);
		return;
	}
	my $d = $self->compute_digest($name, $self->{d});
	if (!$d->equals($self->{d})) {
		$state->log("checksum for #1 does not match", $name);
	}
}

package OpenBSD::PackingElement::SpecialFile;
sub basic_check
{
	&OpenBSD::PackingElement::FileBase::basic_check;
}

sub thorough_check
{
	&OpenBSD::PackingElement::FileBase::basic_check;
}

package OpenBSD::PackingElement::DirlikeObject;
sub basic_check
{
	my ($self, $state) = @@_;
	my $name = $state->destdir($self->fullname);
	$state->{known}{$name} //= {};
	if (!-e $name) {
		$state->log("#1 should exist", $name);
	}
	if (!-d _) {
		$state->log("#1 is not a directory", $name);
	}
}

package OpenBSD::PackingElement::Sample;
use File::Basename;
sub basic_check
{
	my ($self, $state) = @@_;
	my $name = $state->destdir($self->fullname);
	$state->{known}{dirname($name)}{basename($name)} = 1;
}

package OpenBSD::PackingElement::Sampledir;
sub basic_check
{
	my ($self, $state) = @@_;
	my $name = $state->destdir($self->fullname);
	$state->{known}{$name} //= {};
}

package OpenBSD::PackingElement::Mandir;
sub basic_check
{
	my ($self, $state) = @@_;
	$self->SUPER::basic_check($state);
	my $name = $state->destdir($self->fullname);
	for my $file (OpenBSD::Paths::man_cruft()) {
		$state->{known}{$name}{$file} = 1;
	}
}

package OpenBSD::PackingElement::Fontdir;
sub basic_check
{
	my ($self, $state) = @@_;
	$self->SUPER::basic_check($state);
	my $name = $state->destdir($self->fullname);
	for my $i (qw(fonts.alias fonts.scale fonts.dir)) {
		$state->{known}{$name}{$i} = 1;
	}
}

package OpenBSD::PackingElement::Infodir;
sub basic_check
{
	my ($self, $state) = @@_;
	$self->SUPER::basic_check($state);
	my $name = $state->destdir($self->fullname);
	$state->{known}{$name}{'dir'} = 1;
}

package OpenBSD::PackingElement::Dependency;
sub find_dependencies
{
	my ($self, $state, $l, $checker) = @@_;
	# several ways to failure
	if (!$self->spec->is_valid) {
		$state->log("invalid \@@", $self->keyword, " ",
		    $self->stringize);
		return;
	}
	my @@deps = $self->spec->filter(@@$l);
	if (@@deps == 0) {
		$state->log("dependency #1 does not match any installed package",
		    $self->stringize);
		return;
	}
	my $okay = 0;
	for my $i (@@deps) {
		if ($checker->find($i)) {
			$okay = 1;
		}
	}
	if (!$okay) {
		$checker->not_found($deps[0]);
	}
}

package OpenBSD::PackingElement::Wantlib;
sub find_dependencies
{
	my ($self, $state, $l, $checker) = @@_;
	my $r = OpenBSD::SharedLibs::lookup_libspec($state->{localbase},
	    $self->spec);
	if (defined $r && @@$r != 0) {
		my $okay = 0;
		for my $lib (@@$r) {
			my $i = $lib->origin;
			if ($i eq 'system') {
				$okay = 1;
				$state->{needed_libs}{$lib->to_string} = 1;
				next;
			}
			if ($checker->find($i)) {
				$okay = 1;
			}
		}
		if (!$okay) {
			$checker->not_found($r->[0]->origin);
		}
	} else {
		$state->log("#1 not found", $self->stringize);
	}
}

package OpenBSD::PkgCheck::State;
our @@ISA = qw(OpenBSD::AddCreateDelete::State);

use File::Spec;
use OpenBSD::Log;
use File::Basename;

sub init
{
	my $self = shift;
	$self->{l} = OpenBSD::Log->new($self);
	$self->SUPER::init;
}

sub log
{
	my $self = shift;
	if (@@_ == 0) {
		return $self->{l};
	} else {
		$self->{l}->say(@@_);
	}
}

sub safe
{
	my ($self, $string) = @@_;
	$string =~ s/[^\w\d\s\+\-\.\>\<\=\/\;\:\,\(\)\[\]\'\$\@@\"]/?/g;
	return $string;
}

sub handle_options
{
	my $self = shift;
	$self->{no_exports} = 1;

	$self->add_interactive_options;
	$self->SUPER::handle_options('fFB:q',
		'[-FfIimnqvx] [-B pkg-destdir] [-D value]');
	$self->{force} = $self->opt('f');
	$self->{quick} = $self->opt('q') // 0;
	$self->{filesystem} = $self->opt('F');
	if (defined $self->opt('B')) {
		$self->{destdir} = $self->opt('B');
	} 
	if (defined $self->{destdir}) {
		$self->{destdir} .= '/';
	} else {
		$self->{destdir} = '';
	}
}

sub build_tag
{
}

sub destdir
{
	my ($self, $path) = @@_;
	return File::Spec->canonpath($self->{destdir}.$path);
}

sub process_entry
{
	my ($self, $entry) = @@_;
	my $name = $self->destdir($entry);
	$self->{known}{dirname($name)}{basename($name)} = 1;
}

package OpenBSD::DependencyCheck;

sub new
{
	my ($class, $state, $name, $req) = @@_;
	my $o = bless {
		not_yet => {},
		possible => {},
		others => {},
		name => $name,
		req => $req
	    }, $class;
	for my $pkg ($req->list) {
		$o->{not_yet}{$pkg} = 1;
		if ($state->{exists}{$pkg}) {
			$o->{possible}{$pkg} = 1;
		} else {
			$state->errsay("#1: bogus #2",
			    $name, $o->string($state->safe($pkg)));
		}
	}
	return $o;
}

sub find
{
	my ($self, $name) = @@_;
	if ($self->{possible}{$name}) {
		delete $self->{not_yet}{$name};
		return 1;
	} else {
		return 0;
	}
}

sub not_found
{
	my ($self, $name) = @@_;
	$self->{others}{$name} = 1;
}

sub ask_delete_deps
{
	my ($self, $state, $l) = @@_;
	if ($state->{force}) {
		$self->{req}->delete(@@$l);
	} elsif ($state->confirm("Remove missing ".
		    $state->safe($self->string(@@$l)))) {
			$self->{req}->delete(@@$l);
	}
}

sub ask_add_deps
{
	my ($self, $state, $l) = @@_;
	if ($state->{force}) {
		$self->{req}->add(@@$l);
	} elsif ($state->confirm("Add missing ".
		    $self->string(@@$l))) {
			$self->{req}->add(@@$l);
	}
}

sub adjust
{
	my ($self, $state) = @@_;
	if (keys %{$self->{not_yet}} > 0) {
		my @@todo = sort keys %{$self->{not_yet}};
		unless ($state->{subst}->value("weed_libs")) {
			@@todo = grep {!/^\.libs/} @@todo;
		}
		if (@@todo != 0) {
			$state->errsay("#1 has too many #2",
			    $self->{name}, $state->safe($self->string(@@todo)));
			$self->ask_delete_deps($state, \@@todo);
		}
	}
	if (keys %{$self->{others}} > 0) {
		my @@todo = sort keys %{$self->{others}};
		$state->errsay("#1 is missing #2",
		    $self->{name}, $self->string(@@todo));
		    if ($self->{name} =~ m/^partial/) {
			    $state->errsay("not a problem, since this is a partial- package");
		    } else {
			    $self->ask_add_deps($state, \@@todo);
		    }
	}
}

package OpenBSD::DirectDependencyCheck;
our @@ISA = qw(OpenBSD::DependencyCheck);
use OpenBSD::RequiredBy;
sub string
{
	my $self = shift;
	return "dependencies: ". join(' ', @@_);
}

sub new
{
	my ($class, $state, $name) = @@_;
	return $class->SUPER::new($state, $name,
	    OpenBSD::Requiring->new($name));
}

package OpenBSD::ReverseDependencyCheck;
our @@ISA = qw(OpenBSD::DependencyCheck);
use OpenBSD::RequiredBy;
sub string
{
	my $self = shift;
	return "reverse dependencies: ". join(' ', @@_);
}

sub new
{
	my ($class, $state, $name) = @@_;
	return $class->SUPER::new($state, $name,
	    OpenBSD::RequiredBy->new($name));
}

package OpenBSD::Pkglocate;
sub new
{
	my ($class, $state) = @@_;
	bless {state => $state, result => {unknown => []}, 
	    params => []}, $class;
}

sub add_param
{
	my ($self, @@p) = @@_;
	push(@@{$self->{params}}, @@p);
	while (@@{$self->{params}} > 200) {
		$self->run_command;
	}
}

sub run_command
{
	my $self = shift;

	if (@@{$self->{params}} == 0) {
		return;
	}
	my %h = map {($_, 1)} @@{$self->{params}};
	open(my $cmd, '-|', 'pkg_locate', map {"*:$_"} @@{$self->{params}});
	while (<$cmd>) {
		chomp;
		my ($pkgname, $pkgpath, $path) = split(':', $_, 3);

		# pkglocate will return false positives, so trim them
		if ($h{$path}) {
			push(@@{$self->{result}{"$pkgname:$pkgpath"} }, $path);
			delete $h{$path};
		}
	}
	close($cmd);
	for my $k (keys %h) {
		push(@@{$self->{result}{unknown}}, $k);
	}

	$self->{params} = [];
}

sub result
{
	my $self = shift;
	while (@@{$self->{params}} > 0) {
		$self->run_command;
	}
	my $state = $self->{state};
	my $r = $self->{result};
	my $u = $r->{unknown};
	delete $r->{unknown};

	$state->say("Not found:");
	for my $e (sort @@$u) {
		$state->say("\t#1", $e);
	}

	for my $k (sort keys %{$r}) {
		$state->say("In #1:", $k);
		for my $e (sort @@{$r->{$k}}) {
			$state->say("\t#1", $e);
		}
	}
}

package OpenBSD::PkgCheck;
our @@ISA = qw(OpenBSD::AddCreateDelete);

use OpenBSD::PackageInfo;
use OpenBSD::PackingList;
use File::Find;
use OpenBSD::Paths;
use OpenBSD::Mtree;

sub fill_base_system
{
	my ($self, $state) = @@_;
	open(my $cmd, '-|', 'locate', 
	    '-d', OpenBSD::Paths->srclocatedb,
	    '-d', OpenBSD::Paths->xlocatedb, ':');
	while (<$cmd>) {
		chomp;
		my ($set, $path) = split(':', $_, 2);
		$state->{basesystem}{$path} = 1;
	}
	close($cmd);
}

sub remove
{
	my ($self, $state, $name) = @@_;
	$state->{removed}{$name} = 1;
	my $dir = installed_info($name);
	for my $i (@@OpenBSD::PackageInfo::info) {
		if (-e $dir.$i) {
			if ($state->verbose) {
				$state->say("unlink(#1)", $dir.$i);
			}
			unless ($state->{not}) {
				unlink($dir.$i) or
				    $state->errsay("#1: Couldn't delete #2: #3",
				    	$name, $dir.$i, $!);
			}
		}
	}
	if (-f $dir) {
		if ($state->verbose) {
			$state->say("unlink(#1)", $dir);
		}
		unless ($state->{not}) {
			unlink($dir) or
			    $state->errsay("#1: Couldn't delete #2: #3",
				$name, $dir, $!);
		}
	} elsif (-d $dir) {
		if ($state->verbose) {
			$state->say("rmdir(#1)", $dir);
		}
		unless ($state->{not}) {
			rmdir($dir) or
			    $state->errsay("#1: Couldn't delete #2: #3",
			    	$name, $dir, $!);
		}
	}
}

sub may_remove
{
	my ($self, $state, $name) = @@_;
	if ($state->{force}) {
		$self->remove($state, $name);
	} elsif ($state->confirm("Remove wrong package $name")) {
			$self->remove($state, $name);
	}
	$state->{bogus}{$name} = 1;
}

sub for_all_packages
{
	my ($self, $state, $l, $msg, $code) = @@_;

	$state->progress->for_list($msg, $l,
	    sub {
		return if $state->{removed}{$_[0]};
		if ($state->{bogus}{$_[0]}) {
			$state->errsay("skipping #1", $_[0]);
			return;
		}
		&$code;
	    });
}

sub sanity_check
{
	my ($self, $state, $l) = @@_;
	$self->for_all_packages($state, $l, "Packing-list sanity", sub {
		my $name = shift;
		my $info = installed_info($name);
		if (-f $info) {
			$state->errsay("#1: #2 should be a directory",
			    $state->safe($name), $state->safe($info));
			if ($info =~ m/\.core$/) {
				$state->errsay("looks like a core dump, ".
					"removing");
				$self->remove($state, $name);
			} else {
				$self->may_remove($state, $name);
			}
			return;
		}
		my $contents = $info.OpenBSD::PackageInfo::CONTENTS;
		unless (-f $contents) {
			$state->errsay("#1: missing #2",
			    $state->safe($name), $state->safe($contents));
			$self->may_remove($state, $name);
			return;
		}
		my $plist;
		eval {
			$plist = OpenBSD::PackingList->fromfile($contents);
		};
		if ($@@ || !defined $plist) {
			$state->errsay("#1: bad packing-list", $state->safe($name));
			if ($@@) {
				$state->errsay("#1", $state->safe($@@));
			}
			$self->may_remove($state, $name);
			return;
		}
		if (!defined $plist->pkgname) {
			$state->errsay("#1: no pkgname in plist",
			    $state->safe($name));
			$self->may_remove($state, $name);
			return;
		}
		if ($plist->pkgname ne $name) {
			$state->errsay("#1: pkgname does not match",
			    $state->safe($name));
			$self->may_remove($state, $name);
		}
		$plist->mark_available_lib($plist->pkgname, $state);
		$state->{exists}{$plist->pkgname} = 1;
	});
}

sub dependencies_check
{
	my ($self, $state, $l) = @@_;
	OpenBSD::SharedLibs::add_libs_from_system($state->{destdir}, $state);
	$self->for_all_packages($state, $l, "Direct dependencies", sub {
		my $name = shift;
		$state->log->set_context($name);
		my $plist = OpenBSD::PackingList->from_installation($name,
		    \&OpenBSD::PackingList::DependOnly);
		my $checker = OpenBSD::DirectDependencyCheck->new($state,
		    $name);
		$state->{localbase} = $plist->localbase;
		$plist->find_dependencies($state, $l, $checker);
		$checker->adjust($state);
		for my $dep ($checker->{req}->list) {
			push(@@{$state->{reverse}{$dep}}, $name);
		}
	});
}

sub reverse_dependencies_check
{
	my ($self, $state, $l) = @@_;
	$self->for_all_packages($state, $l, "Reverse dependencies", sub {
		my $name = shift;
		my $checker = OpenBSD::ReverseDependencyCheck->new($state,
		    $name);
		for my $i (@@{$state->{reverse}{$name}}) {
			$checker->find($i) or $checker->not_found($i);
		}
		$checker->adjust($state);
	});
}

sub package_files_check
{
	my ($self, $state, $l) = @@_;
	$self->for_all_packages($state, $l, "Files from packages", sub {
		my $name = shift;
		my $plist = OpenBSD::PackingList->from_installation($name);
		$state->log->set_context($name);
		if ($state->{quick}) {
			$plist->basic_check($state);
		} else {
			$plist->thorough_check($state);
		}
		$plist->mark_available_lib($plist->pkgname, $state);
	});
}

sub install_pkglocate
{
	my ($self, $state) = @@_;

	my $spec = 'pkglocatedb->=1.1';

	my @@l = installed_stems()->find('pkglocatedb');
	require OpenBSD::PkgSpec;
	if (OpenBSD::PkgSpec->new($spec)->match_ref(\@@l)) {
		return 1;
	}
	unless ($state->confirm("Unknown file system entries.\n".
	    "Do you want to install $spec to look them up")) {
	    	return 0;
	}

	require OpenBSD::PkgAdd;

	$state->{installer} //= Installer->new($state);
	if ($state->{installer}->install('pkglocatedb--')) {
		return 1;
	} else {
		$state->errsay("Couldn't install #1", $spec);
		return 0;
	}
}

# non fancy display of unknown objects
sub display_unknown
{
	my ($self, $state) = @@_;
	if (defined $state->{unknown}{file}) {
		$state->say("Unknown files:");
		for my $e (sort @@{$state->{unknown}{file}}) {
			$state->say("\t#1", $e);
		}
	}
	if (defined $state->{unknown}{dir}) {
		$state->say("Unknown directories:");
		for my $e (sort {$b cmp $a } @@{$state->{unknown}{dir}}) {
			$state->say("\t#1", $e);
		}
	}
}

sub display_tmps
{
	my ($self, $state) = @@_;
	$state->say("Unregistered temporary files:");
	for my $e (sort @@{$state->{tmps}}) {
		$state->say("\t#1", $e);
	}
	if ($state->{force}) {
		unlink(@@{$state->{tmps}});
	} elsif ($state->confirm("Remove")) {
			unlink(@@{$state->{tmps}});
	}
}

sub display_unregs
{
	my ($self, $state) = @@_;
	$state->say("System libs NOT in locate dbs:");
	for my $e (sort @@{$state->{unreg_libs}}) {
		$state->say("\t#1", $e);
	}
}

sub locate_unknown
{
	my ($self, $state) = @@_;
	my $locator = OpenBSD::Pkglocate->new($state);
	if (defined $state->{unknown}{file}) {
		$state->progress->for_list("Locating unknown files", 
		    $state->{unknown}{file},
			sub {
				$locator->add_param($_[0]);
			});
	}
	if (defined $state->{unknown}{dir}) {
		$state->progress->for_list("Locating unknown directories", 
		    $state->{unknown}{dir},
			sub {
				$locator->add_param($_[0]);
			});
	}
	$locator->result($state);
}

sub fill_localbase
{
	my ($self, $state, $base) = @@_;
	for my $file (OpenBSD::Paths::man_cruft()) {
		$state->{known}{$base."/man"}{$file} = 1;
	}
	$state->{known}{$base."/info"}{'dir'} = 1;
	$state->{known}{$base."/lib/X11"}{'app-defaults'} = 1;
	$state->{known}{$base."/libdata"} = {};
	$state->{known}{$base."/libdata/perl5"} = {};
}

sub fill_root
{
	my ($self, $state, $root) = @@_;
	OpenBSD::Mtree::parse($state->{known}, $root, 
	    '/etc/mtree/4.4BSD.dist', 1);
	OpenBSD::Mtree::parse($state->{known}, $root,
	    '/etc/mtree/BSD.x11.dist', 1);
}

sub filesystem_check
{
	my ($self, $state) = @@_;
	$state->{known} //= {};
	$self->fill_localbase($state, 
	    $state->destdir(OpenBSD::Paths->localbase));
	my $root = $state->{destdir} || '/';
	$self->fill_root($state, $root);
	$self->fill_base_system($state);

	$state->progress->set_header("Checking file system");
	find(sub {
		$state->progress->working(1024);
		if (-d $_) {
			for my $i ('/dev', '/home', OpenBSD::Paths->pkgdb, '/var/log', '/var/backups', '/var/cron', '/var/run', '/tmp', '/var/tmp') {
				if ($File::Find::name eq $state->destdir($i)) {
					$File::Find::prune = 1;
				}
			}
		}
		if (defined $state->{basesystem}{$File::Find::name}) {
			delete $state->{basesystem}{$File::Find::name};
			return;
		}
		if (defined $state->{needed_libs}{$File::Find::name}) {
			push(@@{$state->{unreg_libs}}, $File::Find::name);
			return;
		}
		if (-d $_) {
			if ($_ eq "lost+found") {
				$state->say("fsck(8) info found: #1",
				    $File::Find::name);
				$File::Find::prune = 1;
				return;
			}
			# some directories we've got to ignore
			if (! -r -x _) {
				$File::Find::prune = 1;
				$state->errsay("can't enter #1", 
				    $File::Find::name);
			}
			return if defined $state->{known}{$File::Find::name};
			if (-l $_) {
				return if $state->{known}{$File::Find::dir}{$_};
			}
			push(@@{$state->{unknown}{dir}}, $File::Find::name);
			$File::Find::prune = 1;
		} else {
			return if $state->{known}{$File::Find::dir}{$_};
			if (m/^pkg\..{10}$/) {
				push(@@{$state->{tmps}}, $File::Find::name);
			} else {
				push(@@{$state->{unknown}{file}}, 
				    $File::Find::name);
			}
		}
	}, $root);
	if (defined $state->{tmps}) {
		$self->display_tmps($state);
	}
	if (defined $state->{unreg_libs}) {
		$self->display_unregs($state);
	}
	if (defined $state->{unknown}) {
		if ($self->install_pkglocate($state)) {
			$self->locate_unknown($state);
		} else {
			$self->display_unknown($state);
		}
	}
}

sub run
{
	my ($self, $state) = @@_;

	my @@list = installed_packages();
	$self->sanity_check($state, \@@list);
	$self->dependencies_check($state, \@@list);
	$state->log->dump;
	$self->reverse_dependencies_check($state, \@@list);
	$state->log->dump;
	if ($state->{quick} < 2) {
		$self->package_files_check($state, \@@list);
		$state->log->dump;
	}
	if ($state->{filesystem}) {
		$self->filesystem_check($state);
		$state->progress->next;
	}
}

sub parse_and_run
{
	my ($self, $cmd) = @@_;

	my $state = OpenBSD::PkgCheck::State->new($cmd);
	$state->handle_options;
	if (@@ARGV != 0) {
		$state->usage;
	}
	lock_db(0, $state) unless $state->{subst}->value('nolock');
	$self->run($state);
	return 0;
}

1;
@


1.63
log
@compute_digest already clones object's class, no need to ref here.
@
text
@d4 1
a4 1
# $OpenBSD: PkgCheck.pm,v 1.62 2016/08/26 18:19:21 espie Exp $
d302 1
a302 1
	$string =~ s/[^\w\d\s\+\-\.\>\<\=\/\;\:\,\(\)\[\]]/?/g;
d651 3
@


1.62
log
@grrr warning
@
text
@d4 1
a4 1
# $OpenBSD: PkgCheck.pm,v 1.61 2016/08/25 16:27:16 jmc Exp $
d142 1
a142 1
	my $d = $self->compute_digest($name, ref($self->{d}));
@


1.61
log
@-F before -f (as -I before -i currently is...);
@
text
@d4 1
a4 1
# $OpenBSD: PkgCheck.pm,v 1.60 2016/08/25 14:58:43 espie Exp $
d315 1
a315 1
	$self->{quick} = $self->opt('q');
@


1.60
log
@make the full filesystem check optional, by popular demand.
doubling -q removes the plist thorough check.
@
text
@d4 1
a4 1
# $OpenBSD: PkgCheck.pm,v 1.59 2016/06/15 15:40:13 espie Exp $
d313 1
a313 1
		'[-fFIimnqvx] [-B pkg-destdir] [-D value]');
@


1.59
log
@dedup interactive options handling code yet again.
dynamic code mixin
@
text
@d4 1
a4 1
# $OpenBSD: PkgCheck.pm,v 1.58 2016/06/06 15:19:45 espie Exp $
d312 2
a313 2
	$self->SUPER::handle_options('fB:q',
		'[-fIimnqvx] [-B pkg-destdir] [-D value]');
d316 1
d912 8
a919 4
	$self->package_files_check($state, \@@list);
	$state->log->dump;
	$self->filesystem_check($state);
	$state->progress->next;
@


1.58
log
@band-aid for pkg_check, some options need to be mixin.
@
text
@d4 1
a4 1
# $OpenBSD: PkgCheck.pm,v 1.57 2015/10/21 10:11:13 espie Exp $
a308 4
	my $i;
	$self->{opt}{i} //= sub {
		$i++;
	};
d311 2
a312 1
	$self->SUPER::handle_options('iIfB:q',
a313 9
	if ($self->opt('I')) {
		$i = 0;
	} elsif (!defined $i) {
		$i = -t STDIN;
	}
	if ($i) {
		require OpenBSD::Interactive;
		$self->{interactive} = OpenBSD::Interactive->new($self, $i);
	}
@


1.57
log
@make sure ProgressMeter gets set up. Fixes some weirdness in package installs,
as it now must contain a proper linkback to its own state.
@
text
@d4 1
a4 1
# $OpenBSD: PkgCheck.pm,v 1.56 2015/05/24 07:53:14 espie Exp $
d309 4
d315 1
a315 1
	$self->SUPER::handle_options('fB:q',
d317 9
@


1.56
log
@pass subst to the installer state, so that -Dunsigned would work
@
text
@d4 1
a4 1
# $OpenBSD: PkgCheck.pm,v 1.55 2014/11/29 10:42:51 espie Exp $
d47 1
@


1.55
log
@simplify the interactive code into its own little object with simpler
interface, so that most is it interactive tests vanish from the main
program.
@
text
@d4 1
a4 1
# $OpenBSD: PkgCheck.pm,v 1.54 2014/07/27 22:18:36 espie Exp $
d44 1
@


1.54
log
@- log libraries in a proper way
- mark wanted libraries, then run the db check.
Gives you a way to figure out when locate db are behind wrt pkgs
@
text
@d4 1
a4 1
# $OpenBSD: PkgCheck.pm,v 1.53 2014/07/14 08:47:49 espie Exp $
d309 1
a309 1
	$self->SUPER::handle_options('fB:Iiq',
a310 7
	if ($self->opt('i')) {
		$self->{interactive} = 1;
	} elsif ($self->opt('I')) {
		$self->{interactive} = 0;
	} else {
		$self->{interactive} = -t STDIN;
	}
d386 1
a386 3
	} elsif ($state->{interactive}) {
		require OpenBSD::Interactive;
		if (OpenBSD::Interactive::confirm("Remove missing ".
a388 1
		}
d397 1
a397 3
	} elsif ($state->{interactive}) {
		require OpenBSD::Interactive;
		if (OpenBSD::Interactive::confirm("Add missing ".
a399 1
		}
d595 1
a595 3
	} elsif ($state->{interactive}) {
		require OpenBSD::Interactive;
		if (OpenBSD::Interactive::confirm("Remove wrong package $name")) {
a596 1
		}
d727 1
a727 3
	require OpenBSD::Interactive;
	unless (OpenBSD::Interactive::confirm(
	    "Unknown file system entries.\n".
d770 1
a770 3
	} elsif ($state->{interactive}) {
		require OpenBSD::Interactive;
		if (OpenBSD::Interactive::confirm("Remove")) {
a771 1
		}
@


1.53
log
@unhardcode db paths.
put pruning of paths back early: these happen to be in the source db for
the most part, so if we auto-detect source first, we lose.
@
text
@d4 1
a4 1
# $OpenBSD: PkgCheck.pm,v 1.52 2014/07/13 17:17:21 espie Exp $
d258 1
d688 1
d796 9
d871 4
d906 3
@


1.52
log
@bundling base + packages was slow, as it needed to find lots of files.
different approach: mark the base system in one go, then hand pick the
files from the pkglocatedb.

quite a few unaccounted files yet, this will get better
@
text
@d4 1
a4 1
# $OpenBSD: PkgCheck.pm,v 1.51 2014/07/12 19:39:09 espie Exp $
d554 2
a555 2
	    '-d', '/usr/lib/locate/src.db', 
	    '-d', '/usr/X11R6/lib/locate/xorg.db', ':');
a725 2
		$state->{known}{$plist->infodir}{OpenBSD::PackageInfo::REQUIRED_BY} = 1;
		$state->{known}{$plist->infodir}{OpenBSD::PackageInfo::REQUIRING} = 1;
d836 1
a836 1
sub localbase_check
d849 7
a867 5
			for my $i ('/dev', '/home', OpenBSD::Paths->pkgdb, '/var/log', '/var/backups', '/var/cron', '/var/run', '/tmp', '/var/tmp') {
				if ($File::Find::name eq $state->destdir($i)) {
					$File::Find::prune = 1;
				}
			}
d913 1
a913 1
	$self->localbase_check($state);
@


1.51
log
@so, pkg_check can now troll thru the whole file system. Either use
a full pkglocatedb, or the system locate dbs...
@
text
@d4 1
a4 1
# $OpenBSD: PkgCheck.pm,v 1.50 2014/07/11 13:37:02 espie Exp $
d473 1
a473 1
package OpenBSD::Locate;
d485 1
a485 1
	while (@@{$self->{params}} > 50) {
d498 1
a498 1
	open(my $cmd, '-|', $self->command, map {"*:$_"} @@{$self->{params}});
d501 1
a501 2
		my @@r = split(':', $_);
		my ($pkgname, $pkgpath, $path, $k);
a502 9
		$pkgname = shift @@r;
		if (@@r > 1) {
			$pkgpath = shift @@r;
			$k = join(':', $pkgname, $pkgpath);
		} else {
			$pkgpath = '';
			$k = $pkgname;
		}
		$path = join(':', @@r);
d505 1
a505 1
			push(@@{$self->{result}{$k} }, $path) if $pkgpath ne '';
a506 6
		} elsif ($pkgpath ne '') {
			$path = join(':', $pkgpath, $path);
			$k = $pkgname;
			if ($h{$path}) {
				delete $h{$path};
		    	}
a540 15
package OpenBSD::Pkglocate;
our @@ISA = qw(OpenBSD::Locate);
sub command
{
	return ('pkg_locate');
}

package OpenBSD::Baselocate;
our @@ISA = qw(OpenBSD::Locate);
sub command
{
	return ('locate', '-d', '/usr/lib/locate/src.db', '-d', 
	    '/usr/X11R6/lib/locate/xorg.db');
}

d550 14
d726 2
d736 1
a736 1
	my $spec = 'pkglocatedb->=1.0';
d798 2
a799 2
	my ($self, $state, $class) = @@_;
	my $locator = $class->new($state);
d814 1
a814 1
	$locator->result;
d846 1
d851 4
a892 1
		my $locator;
d894 1
a894 1
			$locator = 'OpenBSD::Pkglocate';
d896 1
a896 1
			$locator = 'OpenBSD::Baselocate';
a897 1
		$self->locate_unknown($state, $locator);
@


1.50
log
@use the merged 4.4BSD.dist mtree if BSD.local is gone
@
text
@d4 1
a4 1
# $OpenBSD: PkgCheck.pm,v 1.49 2014/04/15 11:02:38 espie Exp $
d308 2
a309 2
	$self->SUPER::handle_options('fB:Iiqs:X:',
		'[-fIimnqvx] [-s src] [-X x11] [-B pkg-destdir] [-D value]');
a326 10
	if (defined $self->opt('s')) {
		require OpenBSD::SetList;
		OpenBSD::SetList::Source->walk($self, $self->opt('s'));
		$self->{wholefs} = 1;
	}
	if (defined $self->opt('X')) {
		require OpenBSD::SetList;
		OpenBSD::SetList::Xenocara->walk($self, $self->opt('X'));
		$self->{wholefs} = 1;
	}
d473 1
a473 1
package OpenBSD::Pkglocate;
d477 2
a478 1
	bless {state => $state, result => {}, params => []}, $class;
d498 1
a498 1
	open(my $cmd, '-|', 'pkg_locate', map {"*:$_"} @@{$self->{params}});
d501 12
a512 1
		my ($pkgname, $pkgpath, $path) = split(':', $_);
d515 1
a515 1
			push(@@{$self->{result}{"$pkgname:$pkgpath"} }, $path);
d517 6
d557 15
d751 1
a751 1
	my $spec = 'pkglocatedb->=0.4';
d813 2
a814 2
	my ($self, $state) = @@_;
	my $locator = OpenBSD::Pkglocate->new($state);
a841 8
	my $l = "/etc/mtree/BSD.local.dist";
	if (-f $l) {
		# XXX
		OpenBSD::Mtree::parse($state->{known}, $base, $l, 1);
	} else {
		OpenBSD::Mtree::parse($state->{known}, $state->destdir('/'),
		    "/etc/mtree/4.4BSD.dist", 1);
	}
d857 4
a860 6
	my $root = $state->destdir(OpenBSD::Paths->localbase);
	$self->fill_localbase($state, $root);
	if ($state->{wholefs}) {
		$root = $state->{destdir} || '/';
		$self->fill_root($state, $root);
	}
d872 4
a875 6
			if ($state->{wholefs}) {
				# some directories we've got to ignore
				for my $i ('/dev', '/home', OpenBSD::Paths->pkgdb, '/var/log', '/var/backups', '/var/cron', '/var/run', '/tmp', '/var/tmp') {
					if ($File::Find::name eq $state->destdir($i)) {
						$File::Find::prune = 1;
					}
d903 1
d905 1
a905 1
			$self->locate_unknown($state);
d907 1
a907 1
			$self->display_unknown($state);
d909 1
@


1.49
log
@catch directories we don't have the right to enter instead of letting Find
do it (shorter/better message)
@
text
@d4 1
a4 1
# $OpenBSD: PkgCheck.pm,v 1.48 2014/04/14 21:55:37 espie Exp $
d819 8
a826 3
	# XXX
	OpenBSD::Mtree::parse($state->{known}, $base,
	    "/etc/mtree/BSD.local.dist", 1);
@


1.48
log
@tweak the file system walker to be able to walk from /, assuming -s src
and -X xenocara to get at the distrib/sets.

Somewhat experimental for now, good enough at figuring out files to scrape
after a major update
@
text
@d4 1
a4 1
# $OpenBSD: PkgCheck.pm,v 1.47 2014/03/18 18:53:29 espie Exp $
d861 5
@


1.47
log
@remove $_ usage that warns under perl 5.18
@
text
@d4 1
a4 1
# $OpenBSD: PkgCheck.pm,v 1.46 2014/02/10 19:40:47 espie Exp $
d81 1
a81 1
	my $name = $state->{destdir}.$self->fullname;
d111 1
a111 1
		if (!-f $state->{destdir}.$self->{link}) {
d129 1
a129 1
	my $name = $state->{destdir}.$self->fullname;
d161 1
a161 1
	my $name = $state->{destdir}.$self->fullname;
d176 1
a176 1
	my $name = $state->{destdir}.$self->fullname;
d184 1
a184 1
	my $name = $state->{destdir}.$self->fullname;
d193 1
a193 1
	my $name = $state->{destdir}.$self->fullname;
d204 1
a204 1
	my $name = $state->{destdir}.$self->fullname;
d215 1
a215 1
	my $name = $state->{destdir}.$self->fullname;
d275 1
d277 1
d308 2
a309 2
	$self->SUPER::handle_options('fB:Iiq',
		'[-fIimnqvx] [-B pkg-destdir] [-D value]');
d327 27
d809 1
a809 1
sub localbase_check
d811 1
a811 3
	my ($self, $state) = @@_;
	$state->{known} //= {};
	my $base = $state->{destdir}.OpenBSD::Paths->localbase;
d822 22
d848 1
a848 2
			if ($File::Find::name eq
			    OpenBSD::Paths->localbase."/lost+found") {
d854 8
d867 1
d877 1
a877 1
	}, OpenBSD::Paths->localbase);
@


1.46
log
@pattern for "our" temporary files is not random... get it out of the
normal "unknown files" routine and allow to remove them beforehand.
@
text
@d4 1
a4 1
# $OpenBSD: PkgCheck.pm,v 1.45 2014/01/10 16:09:08 espie Exp $
d296 3
a298 3
	my ($self, $_) = @@_;
	s/[^\w\d\s\+\-\.\>\<\=\/\;\:\,\(\)\[\]]/?/g;
	return $_;
@


1.45
log
@likewise. this is useless
@
text
@d4 1
a4 1
# $OpenBSD: PkgCheck.pm,v 1.44 2014/01/09 20:20:01 espie Exp $
d742 17
d813 6
a818 1
			push(@@{$state->{unknown}{file}}, $File::Find::name);
d821 3
@


1.44
log
@bump copyright to 2014
@
text
@d4 1
a4 1
# $OpenBSD: PkgCheck.pm,v 1.43 2014/01/02 16:05:42 espie Exp $
a685 5
		if ($plist->is_signed && !$state->defines('nosig')) {
			if (!$plist->check_signature($state)) {
				$state->fatal("#1 is corrupted", $name);
			}
		}
@


1.43
log
@zap PKG_PREFIX (undocumented and unused, now)
okay landry@@
@
text
@d4 1
a4 1
# $OpenBSD: PkgCheck.pm,v 1.42 2013/12/25 14:38:15 espie Exp $
d6 1
a6 1
# Copyright (c) 2003-2010 Marc Espie <espie@@openbsd.org>
@


1.42
log
@move the choice of signature type for checking into one single place
@
text
@d4 1
a4 1
# $OpenBSD: PkgCheck.pm,v 1.41 2013/09/11 15:36:18 espie Exp $
d319 1
a319 3
	} elsif (defined $ENV{'PKG_PREFIX'}) {
		$self->{destdir} = $ENV{'PKG_PREFIX'};
	}
a321 1
		$ENV{'PKG_DESTDIR'} = $self->{destdir};
a323 1
		delete $ENV{'PKG_DESTDIR'};
@


1.41
log
@pkglocatedb should be installable even if nothing is there...
@
text
@d4 1
a4 1
# $OpenBSD: PkgCheck.pm,v 1.40 2013/05/26 16:02:20 espie Exp $
d691 1
a691 3
			require OpenBSD::x509;

			if (!OpenBSD::x509::check_signature($plist, $state)) {
@


1.40
log
@add B: to the list of options actually handled.
@
text
@d4 1
a4 1
# $OpenBSD: PkgCheck.pm,v 1.39 2012/11/06 15:43:04 jmc Exp $
d713 1
@


1.39
log
@sort options; ok espie
@
text
@d4 1
a4 1
# $OpenBSD: PkgCheck.pm,v 1.38 2012/11/06 08:01:35 espie Exp $
d306 1
a306 1
	$self->SUPER::handle_options('fIiq',
@


1.38
log
@do interactivity like for the others.
force pkglocatedb-- when auto-installing (reported by aja)
@
text
@d4 1
a4 1
# $OpenBSD: PkgCheck.pm,v 1.37 2012/04/16 13:27:25 espie Exp $
d306 2
a307 2
	$self->SUPER::handle_options('fiIq',
		'[-fiImnqvx] [-B pkg-destdir] [-D value]');
@


1.37
log
@supplementary code for Samples
@
text
@d4 1
a4 1
# $OpenBSD: PkgCheck.pm,v 1.36 2012/04/16 10:55:31 espie Exp $
d306 9
a314 3
	$self->SUPER::handle_options('fiq',
		'[-fimnqvx] [-B pkg-destdir] [-D value]');
	$self->{interactive} = $self->opt('i');
d710 4
a713 1
	if (installed_stems()->find('pkglocatedb')) {
d719 1
a719 1
	    "Do you want to install pkglocatedb to look them up ?")) {
d726 1
a726 1
	if ($state->{installer}->install('pkglocatedb')) {
d729 1
a729 1
		$state->errsay("Couldn't install pkglocatedb");
@


1.36
log
@use explicit pattern to avoid huge results from pkg_locate we will
then have to trim.
@
text
@d4 1
a4 1
# $OpenBSD: PkgCheck.pm,v 1.35 2012/04/16 10:32:05 espie Exp $
d169 17
@


1.35
log
@display truely unknown stuff first
@
text
@d4 1
a4 1
# $OpenBSD: PkgCheck.pm,v 1.34 2012/04/16 10:29:53 espie Exp $
d459 1
a459 1
	open(my $cmd, '-|', 'pkg_locate', @@{$self->{params}});
@


1.34
log
@new glue: figure out how to install pkglocatedb on our own (if not
already there), and use it to locate unknown objects in the file system.
@
text
@d4 1
a4 1
# $OpenBSD$
d487 6
a497 4
	}
	$state->say("Not found:");
	for my $e (sort @@$u) {
		$state->say("\t#1", $e);
@


1.33
log
@sloppy Ingo, whatis.db + whatis.index

fix PkgCheck to use the proper API.
@
text
@d4 1
a4 1
# $OpenBSD: PkgCheck.pm,v 1.32 2011/11/26 17:35:09 espie Exp $
d26 33
d435 64
d681 64
d760 1
a760 1
	$state->progress->set_header("Other files");
d775 1
a775 1
			$state->say("Unknown directory #1", $File::Find::name);
d778 1
a778 1
			$state->say("Unknown file #1", $File::Find::name);
d781 7
@


1.32
log
@a second missing $state...
@
text
@d4 1
a4 1
# $OpenBSD: PkgCheck.pm,v 1.31 2011/11/26 17:27:57 espie Exp $
d144 3
a146 1
	$state->{known}{$name}{'whatis.db'} = 1;
d589 3
a591 1
	$state->{known}{$base."/man"}{'whatis.db'} = 1;
@


1.31
log
@fix reporting of weird libs in partial-*, as seen by fries@@,
who always manages to run into strange corners headlong ;)
@
text
@d4 1
a4 1
# $OpenBSD: PkgCheck.pm,v 1.30 2011/07/17 09:56:12 espie Exp $
d578 1
a578 1
		$plist->mark_available_lib($plist->pkgname);
@


1.30
log
@protect against really weird packing-lists
@
text
@d4 1
a4 1
# $OpenBSD: PkgCheck.pm,v 1.29 2011/06/27 12:13:56 espie Exp $
d521 1
a521 1
		$plist->mark_available_lib($plist->pkgname);
@


1.29
log
@compute checksum in plist's existing checksum class, so that very old
md5 can be checked.
would credit whoever reported this (oga?) except I don't remember.
@
text
@d4 1
a4 1
# $OpenBSD: PkgCheck.pm,v 1.28 2010/12/29 13:03:05 espie Exp $
d507 6
@


1.28
log
@more stuff that uses print directly dies
@
text
@d4 1
a4 1
# $OpenBSD: PkgCheck.pm,v 1.27 2010/12/24 10:31:59 espie Exp $
d103 5
a107 1
	my $d = $self->compute_digest($name);
@


1.27
log
@pass state around.
@
text
@d4 1
a4 1
# $OpenBSD: PkgCheck.pm,v 1.26 2010/12/24 09:04:14 espie Exp $
d633 1
a633 1
	lock_db(0) unless $state->{subst}->value('nolock');
@


1.26
log
@handle failures from ports tree with more care.
this does avoid infinite loops in case of wrong plists.
necessary since print-plist-with-depends CAN fail...
@
text
@d4 1
a4 1
# $OpenBSD$
d519 1
a519 1
	OpenBSD::SharedLibs::add_libs_from_system($state->{destdir});
@


1.25
log
@tweak the framework so that individual modules don't exist and return
the exit code upstream instead.
this simplifies the task of people who want to reuse it, as noted by
landry@@
@
text
@d4 1
a4 1
# $OpenBSD: PkgCheck.pm,v 1.24 2010/10/02 13:33:43 espie Exp $
@


1.24
log
@don't try to read bogus stuff, we already errored out on it
@
text
@d4 1
a4 1
# $OpenBSD$
d635 1
@


1.23
log
@missed one next -> return, as noticed by marco@@
@
text
@d4 1
a4 1
# $OpenBSD: PkgCheck.pm,v 1.22 2010/07/08 10:16:13 sthen Exp $
d454 1
d464 4
@


1.22
log
@use more natural English in messages; ok espie@@
@
text
@d4 1
a4 1
# $OpenBSD: PkgCheck.pm,v 1.21 2010/06/30 10:51:04 espie Exp $
d462 1
a462 1
		next if $state->{removed}{$_[0]};
@


1.21
log
@allow say and errsay to work without parameters, as it's ways common.
create verbose_system up in state, because it makes sense without verbose.
@
text
@d4 1
a4 1
# $OpenBSD$
d347 1
a347 1
			$state->errsay("#1 is having too many #2",
d370 1
a370 5
	if (@@_ == 1) {
		return "dependency: ".$_[0];
	} else {
		return "dependencies: ". join(' ', @@_);
	}
d386 1
a386 5
	if (@@_ == 1) {
		return "reverse dependency: @@_";
	} else {
		return "reverse dependencies: ". join(' ', @@_);
	}
@


1.20
log
@whitespace cleanup
@
text
@@


1.19
log
@new style
@
text
@d4 1
a4 1
# $OpenBSD: PkgCheck.pm,v 1.18 2010/06/18 09:01:38 espie Exp $
d59 1
a59 1
				$state->log("#1 should point to #2 but points to #3 instead", 
d67 1
a67 1
			$state->log("#1 points to non-existent #2", 
d79 1
a79 1
			$state->log("#1 should link to non-existent #2", 
d169 1
a169 1
		$state->log("invalid \@@", $self->keyword, " ", 
d194 1
a194 1
	my $r = OpenBSD::SharedLibs::lookup_libspec($state->{localbase}, 
d275 3
a277 3
		not_yet => {}, 
		possible => {}, 
		others => {}, 
d286 1
a286 1
			$state->errsay("#1: bogus #2", 
d367 2
a368 2
sub string 
{ 
d380 1
a380 1
	return $class->SUPER::new($state, $name, 
d387 2
a388 2
sub string 
{ 
d400 1
a400 1
	return $class->SUPER::new($state, $name, 
d436 1
a436 1
			    $state->errsay("#1: Couldn't delete #2: #3", 
d468 1
a468 1
	$state->progress->for_list($msg, $l, 
d482 1
a482 1
			$state->errsay("#1: #2 should be a directory", 
d495 1
a495 1
			$state->errsay("#1: missing #2", 
d510 1
a510 1
			$state->errsay("#1: pkgname does not match", 
d527 1
a527 1
		my $checker = OpenBSD::DirectDependencyCheck->new($state, 
d543 1
a543 1
		my $checker = OpenBSD::ReverseDependencyCheck->new($state, 
d592 1
a592 1
			if ($File::Find::name eq 
d594 1
a594 1
				$state->say("fsck(8) info found: #1", 
@


1.18
log
@buglet: Log object needs a printer to run f().
introduce for_list() iterator in ProgressMeter and use it
@
text
@d4 1
a4 1
# $OpenBSD: PkgCheck.pm,v 1.17 2010/06/15 08:53:55 espie Exp $
d245 24
d632 1
a632 2
	$self->handle_options('fiq', $state,
		'[-fimnqvx] [-B pkg-destdir] [-D value]');
a634 15
	}
	$state->{interactive} = $state->opt('i');
	$state->{force} = $state->opt('f');
	$state->{quick} = $state->opt('q');
	if (defined $state->opt('B')) {
		$state->{destdir} = $state->opt('B');
	} elsif (defined $ENV{'PKG_PREFIX'}) {
		$state->{destdir} = $ENV{'PKG_PREFIX'};
	}
	if (defined $state->{destdir}) {
		$state->{destdir} .= '/';
		$ENV{'PKG_DESTDIR'} = $state->{destdir};
	} else {
		$state->{destdir} = '';
		delete $ENV{'PKG_DESTDIR'};
@


1.17
log
@handle lost+found
@
text
@d4 1
a4 1
# $OpenBSD: PkgCheck.pm,v 1.16 2010/06/15 08:45:15 espie Exp $
d224 1
a224 1
	$self->{l} = OpenBSD::Log->new;
d444 5
a448 8
	my $total = scalar @@$l;
	$state->progress->set_header($msg);
	my $i = 0;
	for my $name (@@$l) {
		$state->progress->show(++$i, $total);
		next if $state->{removed}{$name};
		&$code($name);
	}
@


1.16
log
@it's okay for partial- packages to be a bit weird...
@
text
@d4 1
a4 1
# $OpenBSD: PkgCheck.pm,v 1.15 2010/06/15 08:26:39 espie Exp $
d571 7
@


1.15
log
@more printing changes.

move log operations into their own file, since they're used outside of
pkg_add/pkg_delete by pkg_check.

move all system stuff to State, so that printing can be localized/controlled.
Create primitives _print, _errprint, _fatal for overriding output, without
localization.

Accordingly, move a lot of code out of Error. We should also move Unlink and
Copy eventually.
@
text
@d4 1
a4 1
# $OpenBSD: PkgCheck.pm,v 1.14 2010/06/14 08:16:14 espie Exp $
d332 5
a336 1
		$self->ask_add_deps($state, \@@todo);
@


1.14
log
@log must use ->f
@
text
@d4 1
a4 1
# $OpenBSD: PkgCheck.pm,v 1.13 2010/06/10 07:21:07 espie Exp $
a215 14
package OpenBSD::Log;
use OpenBSD::Error;
our @@ISA = qw(OpenBSD::Error);

sub set_context
{
	&OpenBSD::Error::set_pkgname;
}

sub dump
{
	&OpenBSD::Error::delayed_output;
}

d219 2
d234 1
a234 1
		$self->{l}->print($self->f(@@_), "\n");
@


1.13
log
@next -> return after code change (noticed by Antti Harri)
@
text
@d4 1
a4 1
# $OpenBSD: PkgCheck.pm,v 1.12 2010/06/09 11:21:15 espie Exp $
d246 1
a246 1
		$self->{l}->print(@@_);
@


1.12
log
@wrap most stuff read from files in safe(), so that if the fs is in a bad shape,
we don't put junk on the terminal.
@
text
@d4 1
a4 1
# $OpenBSD: PkgCheck.pm,v 1.11 2010/06/09 09:53:03 espie Exp $
d478 1
a478 1
			next;
d485 1
a485 1
			next;
d494 1
a494 1
			next;
@


1.11
log
@check digital signatures, document that
@
text
@d4 1
a4 1
# $OpenBSD: PkgCheck.pm,v 1.10 2010/06/09 07:26:01 espie Exp $
d250 7
d274 2
a275 1
			$state->errsay("#1: bogus #2", $name, $o->string($pkg));
d306 1
a306 1
		    $self->string(@@$l))) {
d336 1
a336 1
			    $self->{name}, $self->string(@@todo));
d355 1
a355 1
		return "dependency: @@_";
d469 2
a470 1
			$state->errsay("#1: #2 should be a directory", $name, $info);
d482 2
a483 1
			$state->errsay("#1: missing #2", $name, $contents);
d492 1
a492 1
			$state->errsay("#1: bad plist", $name);
d497 2
a498 1
			$state->errsay("#1: pkgname does not match", $name);
@


1.10
log
@ui changes: go thru a state object for most printouts
@
text
@d4 1
a4 1
# $OpenBSD: PkgCheck.pm,v 1.9 2010/06/07 13:41:22 espie Exp $
d535 7
@


1.9
log
@be a bit more specific about documenting this program
@
text
@d4 1
a4 1
# $OpenBSD: PkgCheck.pm,v 1.8 2010/06/07 10:39:09 espie Exp $
d53 1
a53 1
				$state->log("$name should be a symlink but does not exist");
d55 1
a55 1
				$state->log("$name is not a symlink\n");
d59 2
a60 1
				$state->log("$name should point to $self->{symlink} but points to ", readlink($name), " instead\n");
d67 2
a68 1
			$state->log("$name points to non-existent ".readlink($name)."\n");
d70 1
a70 1
			$state->log("$name should exist\n");
d74 1
a74 1
		$state->log("$name is not a file\n");
d79 2
a80 1
			$state->log("$name should link to non-existent $self->{link}");
d85 2
a86 1
					$state->log("$name doesn't link to $self->{link}\n");
d100 1
a100 1
		$state->log("can't read $name\n");
d105 1
a105 1
		$state->log("checksum for $name does not match", "\n");
d127 1
a127 1
		$state->log("$name should exist\n");
d130 1
a130 1
		$state->log("$name is not a directory\n");
d175 2
a176 1
		$state->log("dependency ", $self->stringize, " does not match any installed package");
d196 1
a196 1
	if (defined $r) {
d212 1
a212 1
		$state->log($self->stringize, " not found\n");
d267 1
a267 1
			$state->errsay("$name: bogus ", $o->string($pkg));
d323 8
a330 3
		$state->errsay($self->{name}, " is having too many ",
		    $self->string(@@todo));
		$self->ask_delete_deps($state, \@@todo);
d334 2
a335 2
		$state->errsay($self->{name}, " is missing ",
		    $self->string(@@todo));
d397 1
a397 1
				$state->say("unlink($dir.$i)");
d401 2
a402 1
				    $state->errsay("$name: Couldn't delete $dir.$i: $!");
d408 1
a408 1
			$state->say("unlink($dir)");
d412 2
a413 1
			    $state->errsay("$name: Couldn't delete $dir: $!");
d417 1
a417 1
			$state->say("rmdir($dir)");
d421 2
a422 1
			    $state->errsay("$name: Couldn't delete $dir: $!");
d461 1
a461 1
			$state->errsay("$name: $info should be a directory");
d463 1
a463 1
				$state->errsay("looks like a core dump, ",
d473 1
a473 1
			$state->errsay("$name: missing $contents");
d482 1
a482 1
			$state->errsay("$name: bad plist");
d487 1
a487 1
			$state->errsay("$name: pkgname does not match");
d565 1
a565 1
			$state->say("Unknown directory $File::Find::name");
d568 1
a568 1
			$state->say("Unknown file $File::Find::name");
d577 1
a577 1
	my @@list = installed_packages(1);
d591 1
a591 1
	my $self = shift;
d593 1
a593 1
	my $state = OpenBSD::PkgCheck::State->new;
d595 1
a595 1
		'pkg_check [-fimnqvx] [-B pkg-destdir] [-D value]');
d597 1
a597 1
		Usage();
@


1.8
log
@factor common code for dependency adjustment
@
text
@d4 1
a4 1
# $OpenBSD: PkgCheck.pm,v 1.7 2010/06/07 10:02:27 espie Exp $
d486 1
a486 1
	$self->for_all_packages($state, $l, "Dependencies", sub {
@


1.7
log
@check reverse dependencies as well
@
text
@d4 1
a4 1
# $OpenBSD: PkgCheck.pm,v 1.6 2010/06/07 09:54:28 espie Exp $
d162 1
a162 1
	my ($self, $state, $l, $not_yet, $possible, $others) = @@_;
d176 1
a176 2
		if ($possible->{$i}) {
			delete $not_yet->{$i};
d181 1
a181 1
		$others->{$deps[0]} = 1;
d188 1
a188 1
	my ($self, $state, $l, $not_yet, $possible, $others) = @@_;
d199 1
a199 2
			if ($possible->{$i}) {
				delete $not_yet->{$i};
d204 1
a204 1
			$others->{$r->[0]->origin} = 1;
d245 125
a377 1
use OpenBSD::RequiredBy;
d421 1
a421 1
		if (OpenBSD::Interactive::confirm("Remove wrong package $name ?")) {
a426 26
sub ask_delete_deps
{
	my ($self, $state, $name, $l, $req) = @@_;
	if ($state->{force}) {
		$req->delete(@@$l);
	} elsif ($state->{interactive}) {
		require OpenBSD::Interactive;
		if (OpenBSD::Interactive::confirm("Remove missing deps ?")) {
			$req->delete(@@$l);
		}
	}
}

sub ask_add_deps
{
	my ($self, $state, $name, $l, $req) = @@_;
	if ($state->{force}) {
		$req->add(@@$l);
	} elsif ($state->{interactive}) {
		require OpenBSD::Interactive;
		if (OpenBSD::Interactive::confirm("Add missing deps ?")) {
			$req->add(@@$l);
		}
	}
}

d490 2
a491 13
		my $req = OpenBSD::Requiring->new($name);
		my @@known = $req->list;
		my %not_yet = (); 
		my %possible = ();
		my %other = ();
		for my $pkg (@@known) {
			$not_yet{$pkg} = 1;
			if ($state->{exists}{$pkg}) {
				$possible{$pkg} = 1;
			} else {
				$state->errsay("$name: bogus dependency $pkg");
			}
		}
d493 3
a495 14
		$plist->find_dependencies($state, $l, \%not_yet, \%possible,
		    \%other);
		if (keys %not_yet > 0) {
			my @@todo = sort keys %not_yet;
			$state->errsay("$name is having too many dependencies: ", join(' ', @@todo));
			$self->ask_delete_deps($state, $name, \@@todo, $req);
		}
		if (keys %other > 0) {
			my @@todo = sort keys %other;
			$state->errsay("$name is missing dependencies: ", 
			    join(' ', @@todo));
			$self->ask_add_deps($state, $name, \@@todo, $req);
		}
		for my $dep ($req->list) {
d506 2
a507 13
		my $req = OpenBSD::RequiredBy->new($name);
		my @@known = $req->list;
		my %not_yet = (); 
		my %possible = ();
		my %other = ();
		for my $pkg (@@known) {
			$not_yet{$pkg} = 1;
			if ($state->{exists}{$pkg}) {
				$possible{$pkg} = 1;
			} else {
				$state->errsay("$name: bogus reverse dependency $pkg");
			}
		}
d509 1
a509 16
			if ($possible{$i}) {
				delete $not_yet{$i};
			} else {
				$other{$i} = 1;
			}
		}
		if (keys %not_yet > 0) {
			my @@todo = sort keys %not_yet;
			$state->errsay("$name is having too many dependencies: ", join(' ', @@todo));
			$self->ask_delete_deps($state, $name, \@@todo, $req);
		}
		if (keys %other > 0) {
			my @@todo = sort keys %other;
			$state->errsay("$name is missing dependencies: ", 
			    join(' ', @@todo));
			$self->ask_add_deps($state, $name, \@@todo, $req);
d511 1
@


1.6
log
@check symlinks upfront, so we don't warn if they don't exist, assuming
they point to the correct location.
@
text
@d4 1
a4 1
# $OpenBSD: PkgCheck.pm,v 1.5 2010/06/07 09:18:11 espie Exp $
a389 1
	my $i = 0;
d421 42
d518 2
@


1.5
log
@fix interactive
@
text
@d4 1
a4 1
# $OpenBSD: PkgCheck.pm,v 1.4 2010/06/07 09:10:37 espie Exp $
a49 3
	if (!-e $name) {
		$state->log("$name should exist\n");
	}
d52 5
a56 1
			$state->log("$name is not a symlink\n");
d64 7
d331 14
d348 2
a349 3
	$state->progress->set_header("Packing-list sanity");
	my $i = 0;
	for my $name (@@$l) {
a350 1
		$state->progress->show(++$i, scalar @@$l);
d382 2
a383 1
	}
a388 1
	$state->progress->set_header("Dependencies");
d391 2
a392 2
	for my $name (@@$l) {
		$state->progress->show(++$i, scalar @@$l);
d397 2
a398 2
		my %not_yet =map {($_, 1)} @@known;
		my %possible = map {($_, 1)} @@known;
d400 8
d422 1
a422 1
	}
d428 2
a429 5
	$state->progress->set_header("Files from packages");
	my $i = 0;
	for my $name (@@$l) {
		next if $state->{removed}{$name};
		$state->progress->show(++$i, scalar @@$l);
d438 1
a438 1
	}
@


1.4
log
@add shared libraries while sanity check, so that we can check wantlib.
With this +REQUIRING should be "complete" (not that this does not check
that the packages are reachable through closure, just that +REQUIRING is
sane).
@
text
@d4 1
a4 1
# $OpenBSD: PkgCheck.pm,v 1.3 2010/06/06 09:08:44 espie Exp $
d291 1
a291 1
		if (OpenBSD::Interactive("Remove wrong package $name ?")) {
d304 1
a304 1
		if (OpenBSD::Interactive("Remove missing deps ?")) {
d317 1
a317 1
		if (OpenBSD::Interactive("Add missing deps ?")) {
@


1.3
log
@more checks: verify links.
better at handling fs stuff.
@
text
@d4 1
a4 1
# $OpenBSD: PkgCheck.pm,v 1.2 2010/06/05 18:08:31 espie Exp $
d24 1
d178 27
d361 1
d369 1
d380 1
d412 1
d451 2
a452 2
#	$self->dependencies_check($state, \@@list);
#	$state->log->dump;
@


1.2
log
@empty plist is bad too.
@
text
@d4 1
a4 1
# $OpenBSD: PkgCheck.pm,v 1.1 2010/06/05 17:15:32 espie Exp $
d55 4
d65 13
d388 6
d395 1
a395 2
	OpenBSD::Mtree::parse($state->{known}, 
	    $state->{destdir}.OpenBSD::Paths->localbase,
d402 4
d408 1
a409 1
		$state->say("Unknown object $File::Find::name");
d424 1
@


1.1
log
@move files after a discussion with Theo.
@
text
@d4 1
a4 1
# $OpenBSD: PkgFsck.pm,v 1.3 2010/06/05 16:21:35 espie Exp $
d307 1
a307 1
		if ($@@) {
@

