head	1.96;
access;
symbols
	OPENBSD_6_1_BASE:1.96
	OPENBSD_6_0:1.88.0.6
	OPENBSD_6_0_BASE:1.88
	OPENBSD_5_9:1.88.0.2
	OPENBSD_5_9_BASE:1.88
	OPENBSD_5_8:1.87.0.4
	OPENBSD_5_8_BASE:1.87
	OPENBSD_5_7:1.83.0.2
	OPENBSD_5_7_BASE:1.83
	OPENBSD_5_6:1.74.0.4
	OPENBSD_5_6_BASE:1.74
	OPENBSD_5_5:1.63.0.4
	OPENBSD_5_5_BASE:1.63
	OPENBSD_5_4:1.35.0.4
	OPENBSD_5_4_BASE:1.35
	OPENBSD_5_3:1.35.0.2
	OPENBSD_5_3_BASE:1.35
	OPENBSD_5_2:1.34.0.2
	OPENBSD_5_2_BASE:1.34
	OPENBSD_5_1_BASE:1.33
	OPENBSD_5_1:1.33.0.2
	OPENBSD_5_0:1.30.0.2
	OPENBSD_5_0_BASE:1.30
	OPENBSD_4_9:1.21.0.2
	OPENBSD_4_9_BASE:1.21
	OPENBSD_4_8:1.13.0.2
	OPENBSD_4_8_BASE:1.13;
locks; strict;
comment	@# @;


1.96
date	2017.03.25.18.58.59;	author espie;	state Exp;
branches;
next	1.95;
commitid	tze2rAjBliJxVa9a;

1.95
date	2017.03.16.15.57.47;	author espie;	state Exp;
branches;
next	1.94;
commitid	etWQmvL975raqrlF;

1.94
date	2017.03.13.11.36.23;	author espie;	state Exp;
branches;
next	1.93;
commitid	0Cccwq7xYZZsBTzT;

1.93
date	2017.03.07.14.35.40;	author espie;	state Exp;
branches;
next	1.92;
commitid	Nu0K2kdk0tu6TXHG;

1.92
date	2017.02.27.14.03.52;	author espie;	state Exp;
branches;
next	1.91;
commitid	c3kgqPdp6tlunPOd;

1.91
date	2016.10.03.13.58.09;	author espie;	state Exp;
branches;
next	1.90;
commitid	cVDhKpeP8PSoCWif;

1.90
date	2016.09.14.14.14.22;	author espie;	state Exp;
branches;
next	1.89;
commitid	6lOgjJkAiRMRHn41;

1.89
date	2016.08.27.18.17.46;	author espie;	state Exp;
branches;
next	1.88;
commitid	gU2z7H9jfAvdu8Iz;

1.88
date	2015.10.07.17.52.38;	author jmc;	state Exp;
branches;
next	1.87;
commitid	wtnyUwU0yuhbcppY;

1.87
date	2015.06.30.19.20.08;	author espie;	state Exp;
branches;
next	1.86;
commitid	aPeT5NUWEVnA5f0A;

1.86
date	2015.05.15.21.18.53;	author jasper;	state Exp;
branches;
next	1.85;
commitid	za8CvTLe2DspeSX7;

1.85
date	2015.03.26.22.07.58;	author kili;	state Exp;
branches;
next	1.84;
commitid	gY5FR3xtOyYgUeGI;

1.84
date	2015.03.09.11.09.00;	author espie;	state Exp;
branches;
next	1.83;
commitid	yTZcEklEHLOWCkrw;

1.83
date	2015.01.27.09.35.35;	author espie;	state Exp;
branches;
next	1.82;
commitid	ynWnXPc9QG2DjpCW;

1.82
date	2015.01.19.09.42.06;	author espie;	state Exp;
branches;
next	1.81;
commitid	9hHhQWYHGzokwfk5;

1.81
date	2015.01.12.18.27.33;	author espie;	state Exp;
branches;
next	1.80;
commitid	10N8k5yTtjAUyMku;

1.80
date	2014.12.24.12.50.22;	author espie;	state Exp;
branches;
next	1.79;
commitid	4ivz1ZpxsUV65s63;

1.79
date	2014.11.30.15.53.54;	author espie;	state Exp;
branches;
next	1.78;
commitid	Sv5KdPRZyxo00ddG;

1.78
date	2014.11.29.10.42.51;	author espie;	state Exp;
branches;
next	1.77;
commitid	XiRgNGt76qJ9BWZO;

1.77
date	2014.11.25.14.16.15;	author espie;	state Exp;
branches;
next	1.76;
commitid	UeC1WcUe5pQNhy3k;

1.76
date	2014.11.21.15.07.09;	author espie;	state Exp;
branches;
next	1.75;
commitid	9JKM8glnI39M4iKz;

1.75
date	2014.11.20.15.08.21;	author espie;	state Exp;
branches;
next	1.74;
commitid	34b5MSuPnxcJiMqh;

1.74
date	2014.07.30.12.44.26;	author espie;	state Exp;
branches;
next	1.73;
commitid	BK3TnPtJ3LzmW3eB;

1.73
date	2014.07.19.08.48.44;	author espie;	state Exp;
branches;
next	1.72;
commitid	ltOYeLqdghhBEd8h;

1.72
date	2014.07.12.22.08.23;	author espie;	state Exp;
branches;
next	1.71;
commitid	hE1ZdJtA7rXM6Tse;

1.71
date	2014.07.12.19.58.20;	author espie;	state Exp;
branches;
next	1.70;
commitid	NTPdsi7tlwkJkvwE;

1.70
date	2014.07.12.19.54.15;	author espie;	state Exp;
branches;
next	1.69;
commitid	Wwp0YIqxUs28l1jt;

1.69
date	2014.07.12.19.50.43;	author espie;	state Exp;
branches;
next	1.68;
commitid	QzYY7ILxCL3CoU1A;

1.68
date	2014.07.10.21.12.33;	author espie;	state Exp;
branches;
next	1.67;
commitid	rlsVXHJUSb5lwjzw;

1.67
date	2014.06.16.08.56.48;	author espie;	state Exp;
branches;
next	1.66;
commitid	oblvcM95ID2BPJm4;

1.66
date	2014.06.12.09.50.05;	author espie;	state Exp;
branches;
next	1.65;
commitid	Qgzgah0euceupZRp;

1.65
date	2014.05.05.16.29.32;	author espie;	state Exp;
branches;
next	1.64;

1.64
date	2014.03.18.18.53.29;	author espie;	state Exp;
branches;
next	1.63;

1.63
date	2014.02.13.19.35.00;	author espie;	state Exp;
branches;
next	1.62;

1.62
date	2014.02.13.16.58.08;	author espie;	state Exp;
branches;
next	1.61;

1.61
date	2014.02.11.08.58.34;	author sthen;	state Exp;
branches;
next	1.60;

1.60
date	2014.02.08.12.18.14;	author espie;	state Exp;
branches;
next	1.59;

1.59
date	2014.02.04.23.39.16;	author espie;	state Exp;
branches;
next	1.58;

1.58
date	2014.02.04.00.14.27;	author espie;	state Exp;
branches;
next	1.57;

1.57
date	2014.02.03.13.47.20;	author espie;	state Exp;
branches;
next	1.56;

1.56
date	2014.02.03.11.35.44;	author espie;	state Exp;
branches;
next	1.55;

1.55
date	2014.02.02.15.22.36;	author espie;	state Exp;
branches;
next	1.54;

1.54
date	2014.02.02.11.19.31;	author espie;	state Exp;
branches;
next	1.53;

1.53
date	2014.02.02.09.11.27;	author espie;	state Exp;
branches;
next	1.52;

1.52
date	2014.02.01.18.50.58;	author espie;	state Exp;
branches;
next	1.51;

1.51
date	2014.02.01.11.18.27;	author espie;	state Exp;
branches;
next	1.50;

1.50
date	2014.02.01.11.00.57;	author espie;	state Exp;
branches;
next	1.49;

1.49
date	2014.01.31.10.29.54;	author espie;	state Exp;
branches;
next	1.48;

1.48
date	2014.01.30.13.12.50;	author espie;	state Exp;
branches;
next	1.47;

1.47
date	2014.01.23.15.46.39;	author espie;	state Exp;
branches;
next	1.46;

1.46
date	2014.01.17.15.54.06;	author espie;	state Exp;
branches;
next	1.45;

1.45
date	2014.01.11.11.54.43;	author espie;	state Exp;
branches;
next	1.44;

1.44
date	2014.01.09.20.20.01;	author espie;	state Exp;
branches;
next	1.43;

1.43
date	2014.01.04.14.13.05;	author espie;	state Exp;
branches;
next	1.42;

1.42
date	2014.01.02.16.05.42;	author espie;	state Exp;
branches;
next	1.41;

1.41
date	2013.12.31.11.24.55;	author espie;	state Exp;
branches;
next	1.40;

1.40
date	2013.12.25.14.38.15;	author espie;	state Exp;
branches;
next	1.39;

1.39
date	2013.12.25.14.20.48;	author espie;	state Exp;
branches;
next	1.38;

1.38
date	2013.12.23.15.40.24;	author espie;	state Exp;
branches;
next	1.37;

1.37
date	2013.12.08.12.14.41;	author espie;	state Exp;
branches;
next	1.36;

1.36
date	2013.12.08.12.04.13;	author espie;	state Exp;
branches;
next	1.35;

1.35
date	2012.11.06.08.02.45;	author espie;	state Exp;
branches;
next	1.34;

1.34
date	2012.04.28.12.00.10;	author espie;	state Exp;
branches;
next	1.33;

1.33
date	2011.08.26.08.46.10;	author espie;	state Exp;
branches;
next	1.32;

1.32
date	2011.08.23.10.32.27;	author espie;	state Exp;
branches;
next	1.31;

1.31
date	2011.08.17.10.48.27;	author espie;	state Exp;
branches;
next	1.30;

1.30
date	2011.07.23.15.04.27;	author espie;	state Exp;
branches;
next	1.29;

1.29
date	2011.07.17.13.16.15;	author espie;	state Exp;
branches;
next	1.28;

1.28
date	2011.07.14.11.31.20;	author espie;	state Exp;
branches;
next	1.27;

1.27
date	2011.07.13.13.01.13;	author espie;	state Exp;
branches;
next	1.26;

1.26
date	2011.07.13.12.32.15;	author espie;	state Exp;
branches;
next	1.25;

1.25
date	2011.07.13.11.58.41;	author espie;	state Exp;
branches;
next	1.24;

1.24
date	2011.07.12.10.06.57;	author espie;	state Exp;
branches;
next	1.23;

1.23
date	2011.06.27.12.17.38;	author espie;	state Exp;
branches;
next	1.22;

1.22
date	2011.06.20.09.46.23;	author espie;	state Exp;
branches;
next	1.21;

1.21
date	2011.01.03.19.01.04;	author espie;	state Exp;
branches;
next	1.20;

1.20
date	2010.12.29.13.03.05;	author espie;	state Exp;
branches;
next	1.19;

1.19
date	2010.12.24.10.31.59;	author espie;	state Exp;
branches;
next	1.18;

1.18
date	2010.12.24.09.04.14;	author espie;	state Exp;
branches;
next	1.17;

1.17
date	2010.12.13.12.13.54;	author espie;	state Exp;
branches;
next	1.16;

1.16
date	2010.10.02.13.36.56;	author espie;	state Exp;
branches;
next	1.15;

1.15
date	2010.08.13.11.13.25;	author espie;	state Exp;
branches;
next	1.14;

1.14
date	2010.08.13.11.12.43;	author espie;	state Exp;
branches;
next	1.13;

1.13
date	2010.08.07.09.37.44;	author espie;	state Exp;
branches;
next	1.12;

1.12
date	2010.08.01.10.04.24;	author espie;	state Exp;
branches;
next	1.11;

1.11
date	2010.08.01.10.03.24;	author espie;	state Exp;
branches;
next	1.10;

1.10
date	2010.07.30.10.06.44;	author espie;	state Exp;
branches;
next	1.9;

1.9
date	2010.06.30.10.51.04;	author espie;	state Exp;
branches;
next	1.8;

1.8
date	2010.06.30.10.41.42;	author espie;	state Exp;
branches;
next	1.7;

1.7
date	2010.06.30.10.37.26;	author espie;	state Exp;
branches;
next	1.6;

1.6
date	2010.06.30.10.08.00;	author espie;	state Exp;
branches;
next	1.5;

1.5
date	2010.06.25.11.12.14;	author espie;	state Exp;
branches;
next	1.4;

1.4
date	2010.06.15.08.20.44;	author espie;	state Exp;
branches;
next	1.3;

1.3
date	2010.06.09.08.13.19;	author espie;	state Exp;
branches;
next	1.2;

1.2
date	2010.06.09.07.26.01;	author espie;	state Exp;
branches;
next	1.1;

1.1
date	2010.06.04.13.19.39;	author espie;	state Exp;
branches;
next	;


desc
@@


1.96
log
@tweak checksums on delete to not happen by default, with an interface
as discussed with sthen@@

manpage bits to follow soonish
@
text
@#! /usr/bin/perl

# ex:ts=8 sw=4:
# $OpenBSD: PkgAdd.pm,v 1.95 2017/03/16 15:57:47 espie Exp $
#
# Copyright (c) 2003-2014 Marc Espie <espie@@openbsd.org>
#
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

use strict;
use warnings;

use OpenBSD::AddDelete;

package OpenBSD::PackingList;

sub uses_old_libs
{
	my $plist = shift;
	require OpenBSD::RequiredBy;

	return  grep {/^\.libs\d*\-/o}
	    OpenBSD::Requiring->new($plist->pkgname)->list;
}

sub has_different_sig
{
	my ($plist, $state) = @@_;
	if (!defined $plist->{different_sig}) {
		my $n = OpenBSD::PackingList->from_installation($plist->pkgname)->signature;
		my $o = $plist->signature;
		my $r = $n->compare($o, $state->defines("SHORTENED"));
		$state->print("Comparing full signature for #1 \"#2\" vs. \"#3\":",
		    $plist->pkgname, $o->string, $n->string)
			if $state->verbose >= 3;
		if (defined $r) {
			if ($r == 0) {
				$plist->{different_sig} = 0;
				$state->say("equal") if $state->verbose >= 3;
			} elsif ($r > 0) {
				$plist->{different_sig} = 1;
				$state->say("greater") if $state->verbose >= 3;
			} else {
				$plist->{different_sig} = 1;
				$state->say("less") if $state->verbose >= 3;
			}
		} else {
			$plist->{different_sig} = 1;
			$state->say("non comparable") if $state->verbose >= 3;
		}
	}
	return $plist->{different_sig};
}

package OpenBSD::PackingElement;
sub hash_files
{
}
sub tie_files
{
}

package OpenBSD::PackingElement::FileBase;
sub hash_files
{
	my ($self, $sha, $state) = @@_;
	return if $self->{link} or $self->{symlink} or $self->{nochecksum};
	if (defined $self->{d}) {
		$sha->{$self->{d}->key} = $self;
	}
}

sub tie_files
{
	my ($self, $sha, $state) = @@_;
	return if $self->{link} or $self->{symlink} or $self->{nochecksum};
	# XXX python doesn't like this, overreliance on timestamps
	return if $self->{name} =~ m/\.py$/ && !defined $self->{ts};
	if (defined $sha->{$self->{d}->key}) {
		my $tied = $sha->{$self->{d}->key};
		# don't tie if there's a problem with the file
		my $realname = $tied->realname($state);
		return unless -f $realname;
		# and do a sanity check that this file wasn't altered
		return unless (stat _)[7] == $self->{size};
		if ($state->defines('checksum')) {
			my $d = $self->compute_digest($realname, $self->{d});
			# XXX we don't have to display anything here
			# because delete will take care of that
			return unless $d->equals($self->{d});
		}
		$self->{tieto} = $tied;
		$tied->{tied} = 1;
		$state->say("Tieing #1 to #2", $self->stringize,
		    $tied->stringize) if $state->verbose >= 3;
	}
}

package OpenBSD::PkgAdd::State;
our @@ISA = qw(OpenBSD::AddDelete::State);

sub handle_options
{
	my $state = shift;
	$state->SUPER::handle_options('ruUzl:A:P:',
	    '[-acinqrsUuVvxz] [-A arch] [-B pkg-destdir] [-D name[=value]]',
	    '[-L localbase] [-l file] [-P type] pkg-name ...');

	$state->{arch} = $state->opt('A');

	if ($state->opt('P')) {
		if ($state->opt('P') eq 'cdrom') {
			$state->{cdrom_only} = 1;
		}
		elsif ($state->opt('P') eq 'ftp') {
			$state->{ftp_only} = 1;
		}
		else {
		    $state->usage("bad option: -P #1", $state->opt('P'));
		}
	}
	if (defined $state->opt('B')) {
		$state->{destdir} = $state->opt('B');
	}
	if (defined $state->{destdir}) {
		$state->{destdir}.='/';
	} else {
		$state->{destdir} = '';
	}


	$state->{hard_replace} = $state->opt('r');
	$state->{newupdates} = $state->opt('u') || $state->opt('U');
	$state->{allow_replacing} = $state->{hard_replace} ||
	    $state->{newupdates};
	$state->{pkglist} = $state->opt('l');
	$state->{update} = $state->opt('u');
	$state->{fuzzy} = $state->opt('z');

	if (@@ARGV == 0 && !$state->{update} && !$state->{pkglist}) {
		$state->usage("Missing pkgname");
	}
}

sub set_name_from_handle
{
	my ($state, $h, $extra) = @@_;
	$extra //= '';
	$state->log->set_context($extra.$h->pkgname);
}

sub updateset
{
	my $self = shift;
	require OpenBSD::UpdateSet;

	return OpenBSD::UpdateSet->new($self);
}

sub updateset_with_new
{
	my ($self, $pkgname) = @@_;

	return $self->updateset->add_newer(
	    OpenBSD::Handle->create_new($pkgname));
}

sub updateset_from_location
{
	my ($self, $location) = @@_;

	return $self->updateset->add_newer(
	    OpenBSD::Handle->from_location($location));
}

sub display_timestamp
{
	my ($state, $pkgname, $timestamp) = @@_;
	$state->say("#1 signed on #2", $pkgname, $timestamp);
}

OpenBSD::Auto::cache(updater,
    sub {
	require OpenBSD::Update;
	return OpenBSD::Update->new;
    });

OpenBSD::Auto::cache(tracker,
    sub {
	require OpenBSD::Tracker;
	return OpenBSD::Tracker->new;
    });

package OpenBSD::ConflictCache;
our @@ISA = (qw(OpenBSD::Cloner));
sub new
{
	my $class = shift;
	bless {done => {}, c => {}}, $class;
}

sub add
{
	my ($self, $handle, $state) = @@_;
	return if $self->{done}{$handle};
	$self->{done}{$handle} = 1;
	for my $conflict (OpenBSD::PkgCfl::find_all($handle, $state)) {
		$self->{c}{$conflict} = 1;
	}
}

sub list
{
	my $self = shift;
	return keys %{$self->{c}};
}

sub merge
{
	my ($self, @@extra) = @@_;
	$self->clone('c', @@extra);
	$self->clone('done', @@extra);
}

package OpenBSD::UpdateSet;
use OpenBSD::PackageInfo;
use OpenBSD::Error;
use OpenBSD::Handle;

OpenBSD::Auto::cache(solver,
    sub {
	return OpenBSD::Dependencies::Solver->new(shift);
    });

OpenBSD::Auto::cache(conflict_cache,
    sub {
	return OpenBSD::ConflictCache->new;
    });

sub setup_header
{
	my ($set, $state, $handle, $info) = @@_;

	my $header = $state->deptree_header($set);
	if (defined $handle) {
		$header .= $handle->pkgname;
	} else {
		$header .= $set->print;
	}
	if (defined $info) {
		$header.=" ($info)";
	}

	if (!$state->progress->set_header($header)) {
		return unless $state->verbose;
		if (!defined $info) {
			$header = "Adding $header";
		}
		if (defined $state->{lastheader} &&
		    $header eq $state->{lastheader}) {
			return;
		}
		$state->{lastheader} = $header;
		$state->print("#1", $header);
		$state->print("(pretending) ") if $state->{not};
		$state->print("\n");
	}
}

my $checked = {};

sub check_security
{
	my ($set, $state, $plist, $h) = @@_;
	return if $checked->{$plist->fullpkgpath};
	$checked->{$plist->fullpkgpath} = 1;
	return if $set->{quirks};
	my ($error, $bad);
	$state->run_quirks(
		sub {
			my $quirks = shift;
			return unless $quirks->can("check_security");
			$bad = $quirks->check_security($plist->fullpkgpath);
			if (defined $bad) {
				require OpenBSD::PkgSpec;
				my $spec = OpenBSD::PkgSpec->new($bad);
				my $r = $spec->match_locations([$h->{location}]);
				if (@@$r != 0) {
					$error++;
				}
			}
		});
	if ($error) {
		$state->errsay("Package #1 found, matching insecure #2", 
		    $h->pkgname, $bad);
	}
}

sub display_timestamp
{
	my ($pkgname, $plist, $state) = @@_;

	return unless $plist->is_signed;
	$state->display_timestamp($pkgname,
	    $plist->get('digital-signature')->iso8601);
}

sub find_kept_handle
{
	my ($set, $n,  $state) = @@_;
	unless (defined $n->{location} && defined $n->{location}{update_info}) {
		$n->complete($state);
	}
	my $plist = $n->dependency_info;
	return if !defined $plist;
	my $pkgname = $plist->pkgname;
	if ($set->{quirks}) {
		display_timestamp($pkgname, $plist, $state);
	}
	# condition for no update
	unless (is_installed($pkgname) &&
	    (!$state->{allow_replacing} ||
	      !$state->defines('installed') &&
	      !$plist->has_different_sig($state) &&
	      !$plist->uses_old_libs)) {
	      	$set->check_security($state, $plist, $n);
	      	return;
	}
	my $o = $set->{older}{$pkgname};
	if (!defined $o) {
		$o = OpenBSD::Handle->create_old($pkgname, $state);
		if (!defined $o->pkgname) {
			$state->{bad}++;
			$set->cleanup(OpenBSD::Handle::CANT_INSTALL, 
			    "Bogus package already installed");
		    	return;
		}
	}
	$set->check_security($state, $plist, $o);
	$set->move_kept($o);
	$o->{tweaked} =
	    OpenBSD::Add::tweak_package_status($pkgname, $state);
	$state->updater->progress_message($state, "No change in $pkgname");
	delete $set->{newer}{$pkgname};
	$n->cleanup;
}

sub figure_out_kept
{
	my ($set, $state) = @@_;

	for my $n ($set->newer) {
		$set->find_kept_handle($n, $state);
	}
}

sub complete
{
	my ($set, $state) = @@_;

	for my $n ($set->newer) {
		$n->complete($state);
		my $plist = $n->plist;
		return 1 if !defined $plist;
		return 1 if $n->has_error;
	}
	# XXX kept must have complete plists to be able to track 
	# libs for OldLibs
	for my $o ($set->older, $set->kept) {
		$o->complete_old($state);
	}

	my $check = $set->install_issues($state);
	return 0 if !defined $check;

	if ($check) {
		$state->{bad}++;
		$set->cleanup(OpenBSD::Handle::CANT_INSTALL, $check);
		$state->tracker->cant($set);
	}
	return 1;
}

sub find_conflicts
{
	my ($set, $state) = @@_;

	my $c = $set->conflict_cache;

	for my $handle ($set->newer) {
		$c->add($handle, $state);
	}
	return $c->list;
}

sub mark_as_manual_install
{
	my $set = shift;

	for my $handle ($set->newer) {
		my $plist = $handle->plist;
		$plist->has('manual-installation') or
		    OpenBSD::PackingElement::ManualInstallation->add($plist);
	}
}

sub updates
{
	my ($n, $plist) = @@_;
	if (!$n->location->update_info->match_pkgpath($plist)) {
		return 0;
	}
	if (!$n->conflict_list->conflicts_with($plist->pkgname)) {
		return 0;
	}
	my $r = OpenBSD::PackageName->from_string($n->pkgname)->compare(
	    OpenBSD::PackageName->from_string($plist->pkgname));
	if (defined $r && $r < 0) {
		return 0;
	}
	return 1;
}

sub is_an_update_from
{
	my ($set, @@conflicts) = @@_;
LOOP:	for my $c (@@conflicts) {
		next if $c =~ m/^\.libs\d*\-/;
		next if $c =~ m/^partial\-/;
		my $plist = OpenBSD::PackingList->from_installation($c, \&OpenBSD::PackingList::UpdateInfoOnly);
		return 0 unless defined $plist;
		for my $n ($set->newer) {
			if (updates($n, $plist)) {
				next LOOP;
			}
		}
	    	return 0;
	}
	return 1;
}

sub install_issues
{
	my ($set, $state) = @@_;

	my @@conflicts = $set->find_conflicts($state);

	if (@@conflicts == 0) {
		if ($state->defines('update_only')) {
			return "only update, no install";
		} else {
			return 0;
		}
	}

	if (!$state->{allow_replacing}) {
		if (grep { !/^\.libs\d*\-/ && !/^partial\-/ } @@conflicts) {
			if (!$set->is_an_update_from(@@conflicts)) {
				$state->errsay("Can't install #1 because of conflicts (#2)",
				    $set->print, join(',', @@conflicts));
				return "conflicts";
			}
		}
	}

	my $later = 0;
	for my $toreplace (@@conflicts) {
		if ($state->tracker->is_installed($toreplace)) {
			$state->errsay("Cannot replace #1 in #2: just got installed",
			    $toreplace, $set->print);
			return "replacing just installed";
		}

		next if defined $set->{older}{$toreplace};
		next if defined $set->{kept}{$toreplace};

		$later = 1;
		my $s = $state->tracker->is_to_update($toreplace);
		if (defined $s && $s ne $set) {
			$set->merge($state->tracker, $s);
		} else {
			$set->add_older(OpenBSD::Handle->create_old($toreplace,
			    $state));
		}
	}

	return if $later;


	my $manual_install = 0;

	for my $old ($set->older) {
		my $name = $old->pkgname;

		if ($old->has_error(OpenBSD::Handle::NOT_FOUND)) {
			$state->fatal("can't find #1 in installation", $name);
		}
		if ($old->has_error(OpenBSD::Handle::BAD_PACKAGE)) {
			$state->fatal("couldn't find packing-list for #1", 
			    $name);
		}

		if ($old->plist->has('manual-installation')) {
			$manual_install = 1;
		}
	}

	$set->mark_as_manual_install if $manual_install;

	return 0;
}

sub try_merging
{
	my ($set, $m, $state) = @@_;

	my $s = $state->tracker->is_to_update($m);
	if (!defined $s) {
		$s = $state->updateset->add_older(
		    OpenBSD::Handle->create_old($m, $state));
	}
	if ($state->updater->process_set($s, $state)) {
		$state->say("Merging #1 (#2)", $s->print, $state->ntogo);
		$set->merge($state->tracker, $s);
		return 1;
	} else {
		$state->errsay("NOT MERGING: can't find update for #1 (#2)",
		    $s->print, $state->ntogo);
		return 0;
	}
}

sub check_forward_dependencies
{
	my ($set, $state) = @@_;

	require OpenBSD::ForwardDependencies;
	$set->{forward} = OpenBSD::ForwardDependencies->find($set);
	my $bad = $set->{forward}->check($state);

	if (%$bad) {
		my $no_merge = 1;
		if (!$state->defines('dontmerge')) {
			my $okay = 1;
			for my $m (keys %$bad) {
				if ($set->try_merging($m, $state)) {
					$no_merge = 0;
				} else {
					$okay = 0;
				}
			}
			return 0 if $okay == 1;
		}
		if ($state->defines('updatedepends')) {
			$state->errsay("Forcing update");
			return $no_merge;
		} elsif ($state->confirm("Proceed with update anyway", 0)) {
				return $no_merge;
		} else {
				return undef;
		}
	}
	return 1;
}

sub recheck_conflicts
{
	my ($set, $state) = @@_;

	# no conflicts between newer sets nor kept sets
	for my $h ($set->newer, $set->kept) {
		for my $h2 ($set->newer, $set->kept) {
			next if $h2 == $h;
			if ($h->conflict_list->conflicts_with($h2->pkgname)) {
				$state->errsay("#1: internal conflict between #2 and #3",
				    $set->print, $h->pkgname, $h2->pkgname);
				return 0;
			}
		}
	}

	return 1;
}

package OpenBSD::PkgAdd;
our @@ISA = qw(OpenBSD::AddDelete);

use OpenBSD::Dependencies;
use OpenBSD::PackingList;
use OpenBSD::PackageInfo;
use OpenBSD::PackageName;
use OpenBSD::PkgCfl;
use OpenBSD::Add;
use OpenBSD::SharedLibs;
use OpenBSD::UpdateSet;
use OpenBSD::Error;

sub failed_message
{
	my ($base_msg, $received, @@l) = @@_;
	my $msg = $base_msg;
	if ($received) {
		$msg = "Caught SIG$received. $msg";
	}
	if (@@l > 0) {
		$msg.= ", partial installation recorded as ".join(',', @@l);
	}
	return $msg;
}

sub save_partial_set
{
	my ($set, $state) = @@_;

	return () if $state->{not};
	my @@l = ();
	for my $h ($set->newer) {
		next unless defined $h->{partial};
		push(@@l, OpenBSD::Add::record_partial_installation($h->plist, $state, $h->{partial}));
	}
	return @@l;
}

sub partial_install
{
	my ($base_msg, $set, $state) = @@_;
	return failed_message($base_msg, $state->{received}, save_partial_set($set, $state));
}

sub build_before
{
	my %known = map {($_->pkgname, 1)} @@_;
	require OpenBSD::RequiredBy;
	for my $c (@@_) {
		for my $d (OpenBSD::RequiredBy->new($c->pkgname)->list) {
			push(@@{$c->{before}}, $d) if $known{$d};
		}
	}
}

sub okay
{
	my ($h, $c) = @@_;

	for my $d (@@{$c->{before}}) {
		return 0 if !$h->{$d};
	}
	return 1;
}

sub iterate
{
	my $sub = pop @@_;
	my $done = {};
	my $something_done;

	do {
		$something_done = 0;

		for my $c (@@_) {
			next if $done->{$c->pkgname};
			if (okay($done, $c)) {
				&$sub($c);
				$done->{$c->pkgname} = 1;
				$something_done = 1;
			}
		}
	} while ($something_done);
	# if we can't do stuff in order, do it anyway
	for my $c (@@_) {
		next if $done->{$c->pkgname};
		&$sub($c);
	}
}

sub delete_old_packages
{
	my ($set, $state) = @@_;

	build_before($set->older_to_do);
	iterate($set->older_to_do, sub {
		return if $state->{size_only};
		my $o = shift;
		$set->setup_header($state, $o, "deleting");
		my $oldname = $o->pkgname;
		$state->set_name_from_handle($o, '-');
		require OpenBSD::Delete;
		try {
			OpenBSD::Delete::delete_plist($o->plist, $state);
		} catchall {
			$state->errsay($_);
			$state->fatal(partial_install(
			    "Deinstallation of $oldname failed",
			    $set, $state));
		};

		if (defined $state->{updatedepends}) {
			delete $state->{updatedepends}->{$oldname};
		}
		OpenBSD::PkgCfl::unregister($o, $state);
	});
	$set->cleanup_old_shared($state);
	# Here there should be code to handle old libs
}

sub delayed_delete
{
	my $state = shift;
	for my $realname (@@{$state->{delayed}}) {
		if (!unlink $realname) {
			$state->errsay("Problem deleting #1: #2", $realname, 
			    $!);
			$state->log("deleting #1 failed: #2", $realname, $!);
		}
	}
	delete $state->{delayed};
}

sub really_add
{
	my ($set, $state) = @@_;

	my $errors = 0;

	if ($state->{not}) {
		$state->status->what("Pretending to add");
	} else {
		$state->status->what("Adding");
	}
	$set->setup_header($state);

	# XXX in `combined' updates, some dependencies may remove extra
	# packages, so we do a double-take on the list of packages we
	# are actually replacing.
	my $replacing = 0;
	if ($set->older_to_do) {
		$replacing = 1;
	}
	$state->{replacing} = $replacing;

	my $handler = sub {
		$state->{received} = shift;
		$state->errsay("Interrupted");
		if ($state->{hardkill}) {
			delete $state->{hardkill};
			return;
		}
		$state->{interrupted}++;
	};
	local $SIG{'INT'} = $handler;
	local $SIG{'QUIT'} = $handler;
	local $SIG{'HUP'} = $handler;
	local $SIG{'KILL'} = $handler;
	local $SIG{'TERM'} = $handler;

	$state->{hardkill} = $state->{delete_first};

	if ($replacing) {
		require OpenBSD::OldLibs;
		OpenBSD::OldLibs->save($set, $state);
	}

	if ($state->{delete_first}) {
		delete_old_packages($set, $state);
	}

	for my $handle ($set->newer) {
		next if $state->{size_only};
		$set->setup_header($state, $handle, "extracting");

		try {
			OpenBSD::Add::perform_extraction($handle,
			    $state);
		} catchall {
			unless ($state->{interrupted}) {
				$state->errsay($_);
				$errors++;
			}
		};
		if ($state->{interrupted} || $errors) {
			$state->fatal(partial_install("Installation of ".
			    $handle->pkgname." failed", $set, $state));
		}
	}
	if ($state->{delete_first}) {
		delayed_delete($state);
	} else {
		$state->{hardkill} = 1;
		delete_old_packages($set, $state);
	}

	iterate($set->newer, sub {
		return if $state->{size_only};
		my $handle = shift;
		my $pkgname = $handle->pkgname;
		my $plist = $handle->plist;

		$set->setup_header($state, $handle, "installing");
		$state->set_name_from_handle($handle, '+');

		try {
			OpenBSD::Add::perform_installation($handle, $state);
		} catchall {
			unless ($state->{interrupted}) {
				$state->errsay($_);
				$errors++;
			}
		};

		unlink($plist->infodir.CONTENTS);
		if ($state->{interrupted} || $errors) {
			$state->fatal(partial_install("Installation of $pkgname failed",
			    $set, $state));
		}
	});
	$set->setup_header($state);
	$state->progress->next($state->ntogo(-1));
	for my $handle ($set->newer) {
		my $pkgname = $handle->pkgname;
		my $plist = $handle->plist;
		OpenBSD::SharedLibs::add_libs_from_plist($plist, $state);
		OpenBSD::Add::tweak_plist_status($plist, $state);
		OpenBSD::Add::register_installation($plist, $state);
		add_installed($pkgname);
		delete $handle->{partial};
		OpenBSD::PkgCfl::register($handle, $state);
	}
	delete $state->{partial};
	$set->{solver}->register_dependencies($state);
	if ($replacing) {
		$set->{forward}->adjust($state);
	}
	if ($state->{repairdependencies}) {
		$set->{solver}->repair_dependencies($state);
	}
	delete $state->{delete_first};
	$state->syslog("Added #1", $set->print);
	if ($state->{received}) {
		die "interrupted";
	}
}

sub newer_has_errors
{
	my ($set, $state) = @@_;

	for my $handle ($set->newer) {
		if ($handle->has_error(OpenBSD::Handle::ALREADY_INSTALLED)) {
			$set->cleanup(OpenBSD::Handle::ALREADY_INSTALLED);
			return 1;
		}
		if ($handle->has_error) {
			$state->set_name_from_handle($handle);
			$state->log("Can't install #1: #2",
			    $handle->pkgname, $handle->error_message)
			    unless $handle->has_reported_error;
			$state->{bad}++;
			$set->cleanup($handle->has_error);
			$state->tracker->cant($set);
			return 1;
		}
	}
	return 0;
}

sub newer_is_bad_arch
{
	my ($set, $state) = @@_;

	for my $handle ($set->newer) {
		if ($handle->plist->has('arch')) {
			unless ($handle->plist->{arch}->check($state->{arch})) {
				$state->set_name_from_handle($handle);
				$state->log("#1 is not for the right architecture",
				    $handle->pkgname);
				if (!$state->defines('arch')) {
					$state->{bad}++;
					$set->cleanup(OpenBSD::Handle::CANT_INSTALL);
					$state->tracker->cant($set);
					return 1;
				}
			}
		}
	}
	return 0;
}

sub may_tie_files
{
	my ($set, $state) = @@_;
	if ($set->newer > 0 && $set->older_to_do > 0 && !$state->defines('donttie')) {
		my $sha = {};

		for my $o ($set->older_to_do) {
			$o->{plist}->hash_files($sha, $state);
		}
		for my $n ($set->newer) {
			$n->{plist}->tie_files($sha, $state);
		}
	}
}

sub process_set
{
	my ($self, $set, $state) = @@_;

	$state->{current_set} = $set;

	if (!$state->updater->process_set($set, $state)) {
		return ();
	}

	for my $handle ($set->newer) {
		if ($state->tracker->is_installed($handle->pkgname)) {
			$set->move_kept($handle);
			$handle->{tweaked} = OpenBSD::Add::tweak_package_status($handle->pkgname, $state);
		}
	}

	$set->figure_out_kept($state);

	if (newer_has_errors($set, $state)) {
		return ();
	}
	if ($set->newer == 0 && $set->older_to_do == 0) {
		$state->tracker->uptodate($set);
		return ();
	}

	my @@deps = $set->solver->solve_depends($state);
	if ($state->verbose >= 2) {
		$set->solver->dump($state);
	}
	if (@@deps > 0) {
		$state->build_deptree($set, @@deps);
		$set->solver->check_for_loops($state);
		return (@@deps, $set);
	}

	if (!$set->complete($state)) {
		return $set;
	}

	if (newer_has_errors($set, $state)) {
		return ();
	}

	for my $h ($set->newer) {
		$set->check_security($state, $h->plist, $h);
	}

	if (newer_is_bad_arch($set, $state)) {
		return ();
	}

	if ($set->older_to_do) {
		my $r = $set->check_forward_dependencies($state);
		if (!defined $r) {
			$state->{bad}++;
			$set->cleanup(OpenBSD::Handle::CANT_INSTALL);
			$state->tracker->cant($set);
			return ();
		}
		if ($r == 0) {
			return $set;
		}
	}

	# verify dependencies have been installed
	my $baddeps = $set->solver->check_depends;

	if (@@$baddeps) {
		$state->errsay("Can't install #1: can't resolve #2",
		    $set->print, join(',', @@$baddeps));
		$state->{bad}++;
		$set->cleanup(OpenBSD::Handle::CANT_INSTALL,"bad dependencies");
		$state->tracker->cant($set);
		return ();
	}

	if (!$set->solver->solve_wantlibs($state)) {
		$state->{bad}++;
		$set->cleanup(OpenBSD::Handle::CANT_INSTALL, "libs not found");
		$state->tracker->cant($set);
		return ();
	}
#	if (!$set->solver->solve_tags($state)) {
#		if (!$state->defines('libdepends')) {
#			$state->{bad}++;
#			return ();
#		}
#	}
	if (!$set->recheck_conflicts($state)) {
		$state->{bad}++;
		$set->cleanup(OpenBSD::Handle::CANT_INSTALL, "fatal conflicts");
		$state->tracker->cant($set);
		return ();
	}
	if ($set->older_to_do) {
		require OpenBSD::Replace;
		if (!OpenBSD::Replace::is_set_safe($set, $state)) {
			$state->{bad}++;
			$set->cleanup(OpenBSD::Handle::CANT_INSTALL, "exec detected");
			$state->tracker->cant($set);
			return ();
		}
	}
	may_tie_files($set, $state);
	if ($set->newer > 0 || $set->older_to_do > 0) {
		for my $h ($set->newer) {
			$h->plist->set_infodir($h->location->info);
			delete $h->location->{contents};
		}

		if (!$set->validate_plists($state)) {
			$state->{bad}++;
			$set->cleanup(OpenBSD::Handle::CANT_INSTALL,
			    "file issues");
			$state->tracker->cant($set);
			return ();
		}

		really_add($set, $state);
	}
	$set->cleanup;
	$state->tracker->done($set);
	return ();
}

sub inform_user_of_problems
{
	my $state = shift;
	my @@cantupdate = $state->tracker->cant_list;
	if (@@cantupdate > 0) {
		$state->run_quirks(
		    sub {
		    	my $quirks = shift;
			$quirks->filter_obsolete(\@@cantupdate, $state);
		    });

		$state->say("Couldn't find updates for #1", 
		    join(' ', sort @@cantupdate)) if @@cantupdate > 0;
	}
	if (defined $state->{issues}) {
		$state->say("There were some ambiguities. ".
		    "Please run in interactive mode again.");
	}
}

# if we already have quirks, we update it. If not, we try to install it.
sub quirk_set
{
	my $state = shift;
	require OpenBSD::Search;

	my $set = $state->updateset;
	$set->{quirks} = 1;
	my $l = $state->repo->installed->match_locations(OpenBSD::Search::Stem->new('quirks'));
	if (@@$l > 0) {
		$set->add_older(map {OpenBSD::Handle->from_location($_)} @@$l);
	} else {
		$set->add_hints2('quirks');
	}
	return $set;
}

sub do_quirks
{
	my ($self, $state) = @@_;
	my $set = quirk_set($state);
	$self->process_set($set, $state);
}


sub process_parameters
{
	my ($self, $state) = @@_;
	my $add_hints = $state->{fuzzy} ? "add_hints" : "add_hints2";

	# match against a list
	if ($state->{pkglist}) {
		open my $f, '<', $state->{pkglist} or
		    $state->fatal("bad list #1: #2", $state->{pkglist}, $!);
		while (<$f>) {
			chomp;
			s/\s.*//;
			s/\.tgz$//;
			push(@@{$state->{setlist}},
			    $state->updateset->$add_hints($_));
		}
	}

	# update existing stuff
	if ($state->{update}) {

		if (@@ARGV == 0) {
			@@ARGV = sort(installed_packages());
			$state->{allupdates} = 1;
		}
		my $inst = $state->repo->installed;
		for my $pkgname (@@ARGV) {
			my $l;

			next if $pkgname =~ m/^quirks\-\d/;
			if (OpenBSD::PackageName::is_stem($pkgname)) {
				$l = $state->updater->stem2location($inst, $pkgname, $state);
			} else {
				$l = $inst->find($pkgname);
			}
			if (!defined $l) {
				$state->say("Problem finding #1", $pkgname);
			} else {
				push(@@{$state->{setlist}},
				    $state->updateset->add_older(OpenBSD::Handle->from_location($l)));
			}
		}
	} else {

	# actual names
		for my $pkgname (@@ARGV) {
			next if $pkgname =~ m/^quirks\-\d/;
			push(@@{$state->{setlist}},
			    $state->updateset->$add_hints($pkgname));
		}
	}
}

sub finish_display
{
	my ($self, $state) = @@_;
	OpenBSD::Add::manpages_index($state);

	# and display delayed thingies.
	if (defined $state->{updatedepends} && %{$state->{updatedepends}}) {
		$state->say("Forced updates, bogus dependencies for ",
		    join(' ', sort(keys %{$state->{updatedepends}})),
		    " may remain");
	}
	inform_user_of_problems($state);
}

sub tweak_list
{
	my ($self, $state) = @@_;

	$state->run_quirks(
	    sub {
	    	my $quirks = shift;
		$quirks->tweak_list($state->{setlist}, $state);
	    });
}

sub main
{
	my ($self, $state) = @@_;

	$state->progress->set_header('');
	$self->do_quirks($state);

	$self->process_setlist($state);
}


sub new_state
{
	my ($self, $cmd) = @@_;
	return OpenBSD::PkgAdd::State->new($cmd);
}

1;
@


1.95
log
@tied files should be treated like deleted files wrt checksums.
@
text
@d4 1
a4 1
# $OpenBSD: PkgAdd.pm,v 1.93 2017/03/07 14:35:40 espie Exp $
d96 1
a96 1
		if (!$state->{quick}) {
@


1.94
log
@fix usage order, as reminded by jmc@@
@
text
@d92 2
a93 1
		return unless -f $tied->realname($state);
d96 6
@


1.93
log
@if we reported "Can't find CONTENTS", we know it's a bad package,
so no need to say it again
@
text
@d4 1
a4 1
# $OpenBSD: PkgAdd.pm,v 1.92 2017/02/27 14:03:52 espie Exp $
d109 1
a109 1
	    '[-acinqrsUuvVxz] [-A arch] [-B pkg-destdir] [-D name[=value]]',
@


1.92
log
@framework for some performance stats as a -V... option (like how much
of a package you actually downloaded, or how many packages you touch)
okay aja@@
@
text
@d4 1
a4 1
# $OpenBSD: PkgAdd.pm,v 1.91 2016/10/03 13:58:09 espie Exp $
d858 2
a859 1
			    $handle->pkgname, $handle->error_message);
@


1.91
log
@gc the old checking code in pkg_add
@
text
@d4 1
a4 1
# $OpenBSD: PkgAdd.pm,v 1.90 2016/09/14 14:14:22 espie Exp $
d109 1
a109 1
	    '[-acinqrsUuvxz] [-A arch] [-B pkg-destdir] [-D name[=value]]',
@


1.90
log
@move the check up in state
@
text
@d4 1
a4 1
# $OpenBSD: PkgAdd.pm,v 1.89 2016/08/27 18:17:46 espie Exp $
a306 8
	if ($state->defines('nosig')) {
		$state->errsay("NOT CHECKING DIGITAL SIGNATURE FOR #1",
		    $pkgname);
		return;
	}
	if (!$plist->check_signature($state)) {
		$state->fatal("#1 is corrupted", $pkgname);
	}
a678 37
sub check_digital_signature
{
	my ($set, $state) = @@_;
	for my $handle ($set->newer) {
		$state->set_name_from_handle($handle, '+');
		my $plist = $handle->plist;
		my $pkgname = $plist->pkgname;
		if ($plist->is_signed) {
			if ($state->defines('nosig')) {
				$state->errsay("NOT CHECKING DIGITAL SIGNATURE FOR #1",
				    $pkgname);
			} else {
				if (!$plist->check_signature($state)) {
					$state->fatal("#1 is corrupted",
					    $pkgname);
				}
				$plist->{check_digest} = 1;
				$state->{packages_with_sig}++;
			}
		} else {
			$state->{packages_without_sig}{$pkgname} = 1;
			return if $state->{signature_style} eq 'unsigned';
			my $okay = 0;
			my $url;
			if (defined $handle->location) {
				$url = $handle->location->url;
			} else {
				$url = $pkgname;
			}
			$okay = $state->confirm("UNSIGNED PACKAGE $url: install anyway", 0);
			if (!$okay) {
				$state->fatal("Unsigned package #1", $url);
			}
		}
	}
}

a727 2
	check_digital_signature($set, $state);

a1135 11
	my $warn = 1;
	if ($state->{signature_style} eq 'unsigned') {
		$warn = 0;
	}
	if ($state->{packages_with_sig}) {
		$warn = 1;
	}
	if ($warn && $state->{packages_without_sig}) {
		$state->say("UNSIGNED PACKAGES: #1",
		    join(', ', keys %{$state->{packages_without_sig}}));
	}
@


1.89
log
@in case we run delete_first (not enough room), delay the unlink of
tied items so we can still skip extracting them.

better than the stopgap measure I committed a few weeks ago.
@
text
@d4 1
a4 1
# $OpenBSD: PkgAdd.pm,v 1.88 2015/10/07 17:52:38 jmc Exp $
d708 1
a708 1
			return if $state->defines('unsigned');
d1184 1
a1184 1
	if ($state->defines("unsigned")) {
@


1.88
log
@"..." implies optional, so no need for []; from michael reed
@
text
@d4 1
a4 1
# $OpenBSD: PkgAdd.pm,v 1.87 2015/06/30 19:20:08 espie Exp $
d754 13
d835 3
a837 1
	if (!$state->{delete_first}) {
@


1.87
log
@cosmetic comma is not really necessary, better to have a raw list of packages. Pointed out by theo.
@
text
@d4 1
a4 1
# $OpenBSD: PkgAdd.pm,v 1.86 2015/05/15 21:18:53 jasper Exp $
d110 1
a110 1
	    '[-L localbase] [-l file] [-P type] pkg-name [...]');
@


1.86
log
@add missing placeholder so that the "UNSIGNED PACKAGES: " line actually
contains the list of packages.

ok espie@@
@
text
@d4 1
a4 1
# $OpenBSD: PkgAdd.pm,v 1.85 2015/03/26 22:07:58 kili Exp $
d1076 1
a1076 1
		    join(', ', sort @@cantupdate)) if @@cantupdate > 0;
@


1.85
log
@Backout -DSHORTENED semantics by default for now, because it caused
too much problems with the recent changes to net/libnet (in combination
with security/dsniff); the PKGSPEC changes. Some more suspicious
pudate problems mentioned by landry@@.

ok sthen@@
@
text
@d4 1
a4 1
# $OpenBSD: PkgAdd.pm,v 1.84 2015/03/09 11:09:00 espie Exp $
d1176 1
a1176 1
		$state->say("UNSIGNED PACKAGES: ",
@


1.84
log
@make -DSHORTENED the default: don't update unless there is an actual
change in dependencies: shared library versions, and explicit version
requirements in dependencies.
as discussed with aja@@ before the lock.
@
text
@d4 1
a4 1
# $OpenBSD: PkgAdd.pm,v 1.83 2015/01/27 09:35:35 espie Exp $
d42 1
a42 1
		my $r = $n->compare($o);
@


1.83
log
@fix messages of FwUpdate
@
text
@d4 1
a4 1
# $OpenBSD: PkgAdd.pm,v 1.82 2015/01/19 09:42:06 espie Exp $
d42 1
a42 1
		my $r = $n->compare($o, $state->defines("SHORTENED"));
@


1.82
log
@add a specialized version of version compares that should not update
everything all the time, at the bequest of aja.

(basically, we updated everything when runtime dependencies  changed, even
though we actually only care for wantlib, and hard dependencies, but those
trigger bumps all over the tree)

Experimental for now, turn on with -DSHORTENED. Likely to become the new
default if nothing bad comes out of it.
@
text
@d4 1
a4 1
# $OpenBSD: PkgAdd.pm,v 1.81 2015/01/12 18:27:33 espie Exp $
d179 6
d315 1
a315 1
	$state->say("#1 signed on #2", $pkgname, 
@


1.81
log
@oops, don't load quirks prematurely. noticed by many, myself included
@
text
@d4 1
a4 1
# $OpenBSD: PkgAdd.pm,v 1.80 2014/12/24 12:50:22 espie Exp $
d42 1
a42 1
		my $r = $n->compare($o);
@


1.80
log
@recheck list for non emptyness *after* filtering obsolete packages.
@
text
@d4 1
a4 1
# $OpenBSD: PkgAdd.pm,v 1.79 2014/11/30 15:53:54 espie Exp $
d274 1
@


1.79
log
@get rid of some of the unadorned printfs
@
text
@d4 1
a4 1
# $OpenBSD: PkgAdd.pm,v 1.78 2014/11/29 10:42:51 espie Exp $
d1069 1
a1069 1
		    join(', ', sort @@cantupdate));
@


1.78
log
@simplify the interactive code into its own little object with simpler
interface, so that most is it interactive tests vanish from the main
program.
@
text
@d4 1
a4 1
# $OpenBSD: PkgAdd.pm,v 1.77 2014/11/25 14:16:15 espie Exp $
d1169 2
a1170 2
		print "UNSIGNED PACKAGES: ",
		    join(', ', keys %{$state->{packages_without_sig}}), "\n";
d1173 1
a1173 1
		print "Forced updates, bogus dependencies for ",
d1175 1
a1175 1
		    " may remain\n";
@


1.77
log
@minor clean-up: the stuff not to display is tied to the set, so make the
current_set more explicit in the PkgAdd algorithm...
and clean it up when we clean the set.

Put the "tieing files" stuff into its own function so that the add code
looks a bit less like a spaghetti monster
@
text
@d4 1
a4 1
# $OpenBSD: PkgAdd.pm,v 1.76 2014/11/21 15:07:09 espie Exp $
d561 1
a561 2
		} elsif ($state->{interactive}) {
			if ($state->confirm("Proceed with update anyway", 0)) {
d563 1
a563 1
			} else {
a564 3
			}
		} else {
			return undef;
d709 1
a709 5
			if ($state->{interactive}) {
				$state->errprint('UNSIGNED PACKAGE #1: ', 
				    $url);
				$okay = $state->confirm("install anyway", 0);
			}
@


1.76
log
@a long time ago, DISPLAY and UNDISPLAY required special treatment, as they
were displayed "on the fly". But prepare+log means the display happens later
in any case, so they can be done as part of regular plist.

Also, mark known manpage dirs for even more verbiage reduction...
@
text
@d4 1
a4 1
# $OpenBSD: PkgAdd.pm,v 1.75 2014/11/20 15:08:21 espie Exp $
a776 3
#	if (defined $plist->{old_libs}) {
#		$replacing = 1;
#	}
d923 15
d942 2
d1043 1
a1043 10
	if ($set->newer > 0 && $set->older_to_do > 0 && !$state->defines('donttie')) {
		my $sha = {};

		for my $o ($set->older_to_do) {
			$o->{plist}->hash_files($sha, $state);
		}
		for my $n ($set->newer) {
			$n->{plist}->tie_files($sha, $state);
		}
	}
@


1.75
log
@big trim-down of MESSAGE/UNMESSAGE: just match checksums between new packages
and old packages. Rationale being you don't need to display UNMESSAGE if the
new package has the exact same one. And likewise, you don't need to display
MESSAGE if the old package had the exact same one.
@
text
@d4 1
a4 1
# $OpenBSD: PkgAdd.pm,v 1.74 2014/07/30 12:44:26 espie Exp $
a738 4
			if ($o->plist->has(DISPLAY)) {
				my $d = $o->plist->get(DISPLAY)->{d};
				$state->{known_displays}{$$d} = 1;
			}
a814 4
			if ($handle->plist->has(UNDISPLAY)) {
				my $d = $handle->plist->get(UNDISPLAY)->{d};
				$state->{known_displays}{$$d} = 1;
			}
a865 6
		if ($plist->has(DISPLAY)) {
			my $d = $plist->get(DISPLAY)->{d};
			if (!$state->{known_displays}{$$d}) {
				$plist->get(DISPLAY)->prepare($state);
			}
		}
@


1.74
log
@prepare for post 5.6 packages, recognize special case where timestamp exist.
(specifically, this is a nop for 5.6, but it will allow changes to packages
without needing anything in pkg_add)
@
text
@d4 1
a4 1
# $OpenBSD: PkgAdd.pm,v 1.73 2014/07/19 08:48:44 espie Exp $
d739 4
d819 4
d875 4
a878 1
			$plist->get(DISPLAY)->prepare($state);
@


1.73
log
@actually use the cve match_location correctly.
problem noticed by aja@@
@
text
@d4 1
a4 1
# $OpenBSD: PkgAdd.pm,v 1.72 2014/07/12 22:08:23 espie Exp $
d88 1
a88 1
	return if $self->{name} =~ m/\.py$/;
@


1.72
log
@don't check_security on newer *after* making sure the set doesn't have
errors. Note that the errors are already signaling enough (conflicts, bad
package etc)... And not having any errors mean we actually have proper plists.

problem noticed by zhuk@@
@
text
@d4 1
a4 1
# $OpenBSD: PkgAdd.pm,v 1.71 2014/07/12 19:58:20 espie Exp $
d283 2
a284 1
				if ($spec->match_locations([$h->{location}])) {
@


1.71
log
@oh well, remove -Q entirely... I'm probably the only one who ever used that.
@
text
@d4 1
a4 1
# $OpenBSD: PkgAdd.pm,v 1.70 2014/07/12 19:54:15 espie Exp $
d967 4
a972 4
	}

	if (newer_has_errors($set, $state)) {
		return ();
@


1.70
log
@security check in quirks
@
text
@d4 1
a4 1
# $OpenBSD: PkgAdd.pm,v 1.68 2014/07/10 21:12:33 espie Exp $
d108 1
a108 1
	$state->SUPER::handle_options('ruUzl:A:P:Q:',
@


1.69
log
@finish killing old experiment, less confusing code
@
text
@d267 27
d329 1
d342 1
d965 4
@


1.68
log
@make quirks slightly more special, grab the whole packing-list always,
and display the timestamp from the signature if we were signed.
@
text
@d4 1
a4 1
# $OpenBSD: PkgAdd.pm,v 1.67 2014/06/16 08:56:48 espie Exp $
d110 1
a110 1
	    '[-L localbase] [-l file] [-P type] [-Q quick-destdir] pkg-name [...]');
a111 1
	$state->{do_faked} = 0;
a113 6
	if (defined $state->opt('Q') and defined $state->opt('B')) {
		$state->usage("-Q and -B are incompatible options");
	}
	if (defined $state->opt('Q') and defined $state->opt('r')) {
		$state->usage("-r and -Q are incompatible options");
	}
d125 1
a125 4
	if (defined $state->opt('Q')) {
		$state->{destdir} = $state->opt('Q');
		$state->{do_faked} = 1;
	} elsif (defined $state->opt('B')) {
a262 3
		if ($state->{do_faked}) {
			$state->print(" under #1", $state->{destdir});
		}
@


1.67
log
@fix bug introduced by work-around: sets with nothing to do must be marked
uptodate as well. Restores ntogo to working order
@
text
@d4 1
a4 1
# $OpenBSD: PkgAdd.pm,v 1.66 2014/06/12 09:50:05 espie Exp $
d280 17
d306 3
@


1.66
log
@display full url if we can for UNSIGNED PACKAGES.
unconfuse mikeb@@ :)
@
text
@d4 1
a4 1
# $OpenBSD: PkgAdd.pm,v 1.65 2014/05/05 16:29:32 espie Exp $
d913 1
@


1.65
log
@work-around the same location being reinstalled thru a different path
later... no need to do anything on sets consisting purely of "kept" handles

This is not fully satisfying, I expect I need to tie some "done already" to
locations as we do with sets, so that we can wipe update_info properly and
be done once and for all...

Issue found by stsp@@ while trying to use FETCH_PACKAGES, which is still not
100% in good shape with this.
@
text
@d4 1
a4 1
# $OpenBSD: PkgAdd.pm,v 1.64 2014/03/18 18:53:29 espie Exp $
d670 6
d678 1
a678 1
				    $pkgname);
d682 1
a682 1
				$state->fatal("Unsigned package #1", $pkgname);
@


1.64
log
@remove $_ usage that warns under perl 5.18
@
text
@d4 1
a4 1
# $OpenBSD: PkgAdd.pm,v 1.63 2014/02/13 19:35:00 espie Exp $
d904 3
@


1.63
log
@this one is non obvious enough it deserves a comment
@
text
@d4 1
a4 1
# $OpenBSD: PkgAdd.pm,v 1.62 2014/02/13 16:58:08 espie Exp $
a1065 1
		my $_;
@


1.62
log
@still need the plists for kept handles... because of OldLibs.

Problem noticed by henning@@
@
text
@d4 1
a4 1
# $OpenBSD: PkgAdd.pm,v 1.61 2014/02/11 08:58:34 sthen Exp $
d334 2
@


1.61
log
@s/anyways/anyway/, ok espie@@
@
text
@d4 1
a4 1
# $OpenBSD: PkgAdd.pm,v 1.60 2014/02/08 12:18:14 espie Exp $
d334 1
a334 1
	for my $o ($set->older) {
@


1.60
log
@don't allow unsigned packages by default.

as kettenis@@ says "test it now", always possible to revert if we don't
want it for the release.
@
text
@d4 1
a4 1
# $OpenBSD: PkgAdd.pm,v 1.59 2014/02/04 23:39:16 espie Exp $
d523 1
a523 1
			if ($state->confirm("Proceed with update anyways", 0)) {
d638 1
a638 1
	# if we can't do stuff in order, do it anyways
d671 1
a671 1
				$okay = $state->confirm("install anyways", 0);
@


1.59
log
@sort list of stuff we can't update for user display (otherwise, it's a list
of keys, so it isn't in any particularly interesting order)
@
text
@d4 1
a4 1
# $OpenBSD: PkgAdd.pm,v 1.58 2014/02/04 00:14:27 espie Exp $
d651 1
d655 1
a655 1
				    $plist->pkgname);
d659 1
a659 1
					    $plist->pkgname);
d665 11
a675 1
			$state->{packages_without_sig}{$plist->pkgname} = 1;
@


1.58
log
@check for errors before dependencies, anyways.
split the part for arch, since it requires full plists.
avoid creating dummy locations for handles in errors.
@
text
@d4 1
a4 1
# $OpenBSD: PkgAdd.pm,v 1.57 2014/02/03 13:47:20 espie Exp $
d464 2
a465 1
			$state->fatal("couldn't find packing-list for #1", $name);
d1010 2
a1011 1
		$state->say("Couldn't find updates for #1", join(', ', @@cantupdate));
@


1.57
log
@remove extra cache copy in memory...
to be revisited, the setting of info dir so late is slightly broken and
will reopen packages more times than needed.
@
text
@d4 1
a4 1
# $OpenBSD: PkgAdd.pm,v 1.56 2014/02/03 11:35:44 espie Exp $
d846 3
d850 5
d889 4
d908 4
@


1.56
log
@don't keep tied information around !
@
text
@d4 1
a4 1
# $OpenBSD: PkgAdd.pm,v 1.55 2014/02/02 15:22:36 espie Exp $
d964 1
@


1.55
log
@simplify how "kept" packages are handled. First, we never need their
full plist, just their update_info. Also, the routine for move_kept is
pretty much always the same, so fold it.

Finally, delay full plists in create_old.
@
text
@d4 1
a4 1
# $OpenBSD: PkgAdd.pm,v 1.54 2014/02/02 11:19:31 espie Exp $
d952 1
a952 1
		$set->{sha} = {};
d955 1
a955 1
			$o->{plist}->hash_files($set->{sha}, $state);
d958 1
a958 1
			$n->{plist}->tie_files($set->{sha}, $state);
@


1.54
log
@now that things are clean enough, we just need to figure out kept packages
before we solve depends. Avoids keeping full packing-lists all along the
dependency chain...
@
text
@d4 1
a4 1
# $OpenBSD: PkgAdd.pm,v 1.53 2014/02/02 09:11:27 espie Exp $
a305 3
		$set->add_older($o);
	} else {
		$o->complete_old;
a306 1
	$o->{update_found} = $o;
a320 3
	}
	for my $n ($set->kept) {
		$n->complete_old;
@


1.53
log
@make sure kept handles are complete... not really optimized so far, but will
fix issues seen by nigel@@
@
text
@d4 1
a4 1
# $OpenBSD: PkgAdd.pm,v 1.52 2014/02/01 18:50:58 espie Exp $
a334 2
	$set->figure_out_kept($state);

d886 1
a886 7
	if (!$set->complete($state)) {
		return $set;
	}

	if (newer_has_errors($set, $state)) {
		return ();
	}
d896 8
@


1.52
log
@sort out the code to figuring out kept packages.
Fix a (formerly) silent bug: kept packages *must* be completed somewhere.
(older solve_depends would create dummy plists, new one errors out on them!)
@
text
@d4 1
a4 1
# $OpenBSD: PkgAdd.pm,v 1.51 2014/02/01 11:18:27 espie Exp $
d325 3
@


1.51
log
@handling of critical section was wrong. Interrupting an update once we're
"committed" is a bad idea. Make it possible by ^C^C still, but try to
get out only when the db is in a safe state.
@
text
@d4 1
a4 1
# $OpenBSD: PkgAdd.pm,v 1.50 2014/02/01 11:00:57 espie Exp $
d280 48
d332 2
a334 23
		if (defined $n->{location} && defined $n->{location}{update_info}) {
			my $plist = $n->{location}{update_info};
			my $pkgname = $plist->pkgname;
			if (is_installed($pkgname) &&
			    (!$state->{allow_replacing} ||
			      !$state->defines('installed') &&
			      !$plist->has_different_sig($state) &&
			      !$plist->uses_old_libs)) {
				my $o = $set->{older}->{$pkgname};
				if (!defined $o) {
					$o = OpenBSD::Handle->create_old($pkgname, $state);
					$set->add_older($o);
				}
				$o->{update_found} = $o;
				$set->move_kept($o);
				$o->{tweaked} =
				    OpenBSD::Add::tweak_package_status($pkgname, $state);
				$state->updater->progress_message($state, "No change in $pkgname");
				delete $set->{newer}->{$pkgname};
				$n->cleanup;
				next;
			}
		}
a335 1
		my $pkgname = $n->pkgname;
a337 23
		if (is_installed($pkgname) &&
		    (!$state->{allow_replacing} ||
		      !$state->defines('installed') &&
		      !$plist->has_different_sig($state) &&
		      !$plist->uses_old_libs)) {
		      	my $o = $set->{older}->{$pkgname};
			if (!defined $o) {
				$o = OpenBSD::Handle->create_old($pkgname, $state);
				if (!defined $o->pkgname) {
					$state->{bad}++;
					$set->cleanup(OpenBSD::Handle::CANT_INSTALL, "Bogus package already installed");
					return 1;
				}
				$set->add_older($o);
			}
			$o->{update_found} = $o;
			$set->move_kept($o);
			$o->{tweaked} =
			    OpenBSD::Add::tweak_package_status($pkgname, $state);
			$state->updater->progress_message($state, "No change in $pkgname");
			delete $set->{newer}->{$pkgname};
			$n->cleanup;
		}
@


1.50
log
@use conflict_list directly from handle.
(only user left of plist->conflict_list is PkgCfl::register thru
OldLibs stub_list)
@
text
@d4 1
a4 1
# $OpenBSD: PkgAdd.pm,v 1.49 2014/01/31 10:29:54 espie Exp $
d571 1
a571 1
	my ($base_msg, $interrupted, @@l) = @@_;
d573 2
a574 2
	if ($interrupted) {
		$msg = "Caught SIG$interrupted. $msg";
d598 1
a598 1
	return failed_message($base_msg, $state->{interrupted}, save_partial_set($set, $state));
d729 7
a735 1
		$state->{interrupted} = shift;
d743 2
d773 1
d826 3
@


1.49
log
@minor fix: don't go to cache if genuine install
@
text
@d4 1
a4 1
# $OpenBSD: PkgAdd.pm,v 1.48 2014/01/30 13:12:50 espie Exp $
d214 1
a214 1
	for my $conflict (OpenBSD::PkgCfl::find_all($handle->plist, $state)) {
d381 1
a381 1
	if (!$n->plist->conflict_list->conflicts_with($plist->pkgname)) {
d442 2
a443 2
		next if defined $set->{older}->{$toreplace};
		next if defined $set->{kept}->{$toreplace};
d545 1
a545 1
			if ($h->plist->conflict_list->conflicts_with($h2->pkgname)) {
d695 1
a695 1
		OpenBSD::PkgCfl::unregister($o->plist, $state);
d802 1
a802 1
		OpenBSD::PkgCfl::register($plist, $state);
@


1.48
log
@minor bug-fix, make sure partial is handled properly.
also use delete instead of undef so that they entry vanishes...
@
text
@d4 1
a4 1
# $OpenBSD: PkgAdd.pm,v 1.47 2014/01/23 15:46:39 espie Exp $
a798 1
		$plist->to_cache;
@


1.47
log
@more sophisticated warning: builds with empty SIGNING_PARAMETERS
run with -Dunsigned, so they shouldn't show UNSIGNED PACKAGES while
handling dependencies.

*but* if we install a mix of signed and unsigned packages, ALWAYS show the
line.
@
text
@d4 1
a4 1
# $OpenBSD: PkgAdd.pm,v 1.46 2014/01/17 15:54:06 espie Exp $
d808 1
@


1.46
log
@do check_digest per plist.
show UNSIGNED packages unconditionally.
@
text
@d4 1
a4 1
# $OpenBSD: PkgAdd.pm,v 1.45 2014/01/11 11:54:43 espie Exp $
d1074 8
a1081 1
	if ($state->{packages_without_sig}) {
@


1.45
log
@simplify code: always extract, then install, so that initial installations
and updates are more similar.
@
text
@d4 1
a4 1
# $OpenBSD: PkgAdd.pm,v 1.44 2014/01/09 20:20:01 espie Exp $
a649 1
	$state->{check_digest} //= 0;
d662 1
a662 1
				$state->{check_digest} = 1;
a1072 1

d1074 3
a1076 8
	if ($state->{packages_with_sig}) {
		$state->print("Packages with signatures: #1",
		    $state->{packages_with_sig});
		if ($state->{packages_without_sig}) {
			print ". UNSIGNED PACKAGES: ",
			    join(', ', keys %{$state->{packages_without_sig}});
		}
		print "\n";
@


1.44
log
@bump copyright to 2014
@
text
@d4 1
a4 1
# $OpenBSD: PkgAdd.pm,v 1.43 2014/01/04 14:13:05 espie Exp $
d743 15
a757 18
	if ($replacing && !$state->{delete_first}) {
		$state->{extracted_first} = 1;
		for my $handle ($set->newer) {
			next if $state->{size_only};
			$set->setup_header($state, $handle, "extracting");

			try {
				OpenBSD::Replace::perform_extraction($handle,
				    $state);
			} catchall {
				unless ($state->{interrupted}) {
					$state->errsay($_);
					$errors++;
				}
			};
			if ($state->{interrupted} || $errors) {
				$state->fatal(partial_install("Installation of ".
				    $handle->pkgname." failed", $set, $state));
d759 4
a763 2
	} else {
		$state->{extracted_first} = 0;
d765 1
a765 2

	if ($replacing) {
a771 1

d774 2
a775 2
		$set->setup_header($state, $handle,
		    $replacing ? "installing" : undef);
@


1.43
log
@oops, it's global to the set, no need to do it several times
@
text
@d4 1
a4 1
# $OpenBSD: PkgAdd.pm,v 1.42 2014/01/02 16:05:42 espie Exp $
d6 1
a6 1
# Copyright (c) 2003-2010 Marc Espie <espie@@openbsd.org>
@


1.42
log
@zap PKG_PREFIX (undocumented and unused, now)
okay landry@@
@
text
@d4 1
a4 1
# $OpenBSD: PkgAdd.pm,v 1.41 2013/12/31 11:24:55 espie Exp $
d812 1
a812 3
	for my $handle ($set->newer) {
		$set->{solver}->register_dependencies($state);
	}
@


1.41
log
@... and rename this too
@
text
@d4 1
a4 1
# $OpenBSD: PkgAdd.pm,v 1.40 2013/12/25 14:38:15 espie Exp $
a136 2
	} elsif (defined $ENV{'PKG_PREFIX'}) {
		$state->{destdir} = $ENV{'PKG_PREFIX'};
a139 1
		$ENV{'PKG_DESTDIR'} = $state->{destdir};
a141 1
		delete $ENV{'PKG_DESTDIR'};
a727 2

	$ENV{'PKG_PREFIX'} = $state->{localbase};
@


1.40
log
@move the choice of signature type for checking into one single place
@
text
@d4 1
a4 1
# $OpenBSD: PkgAdd.pm,v 1.39 2013/12/25 14:20:48 espie Exp $
d651 1
a651 1
sub check_x509_signature
d712 1
a712 1
	check_x509_signature($set, $state);
@


1.39
log
@a bit more scaffolding for running quirks. In particular, once quirks
have been loaded, complain loudly if something doesn't work.
(and complain when quirks don't load in !verbose mode)
@
text
@d4 1
a4 1
# $OpenBSD: PkgAdd.pm,v 1.38 2013/12/23 15:40:24 espie Exp $
d663 1
a663 4
				require OpenBSD::x509;

				if (!OpenBSD::x509::check_signature($plist,
				    $state)) {
d665 1
a665 1
					    $set->print);
@


1.38
log
@simpler logic: if one package is signed, check all digests
@
text
@d4 1
a4 1
# $OpenBSD: PkgAdd.pm,v 1.37 2013/12/08 12:14:41 espie Exp $
a204 7
sub quirks
{
	my $state = shift;

	return $state->{quirks};
}

d990 5
a994 3
		eval {
			$state->quirks->filter_obsolete(\@@cantupdate, $state);
		};
d1024 2
a1025 7

	$self->process_set(quirk_set($state), $state);
	eval {
		require OpenBSD::Quirks;
		# interface version number.
		$state->{quirks} = OpenBSD::Quirks->new(1);
	};
d1111 5
a1115 3
	eval {
		$state->quirks->tweak_list($state->{setlist}, $state);
	}
@


1.37
log
@also cover initial installations (which means we do try to install
quirks even for initial installations)
@
text
@d4 1
a4 1
# $OpenBSD: PkgAdd.pm,v 1.36 2013/12/08 12:04:13 espie Exp $
d661 1
a668 1
				$state->{check_digest} = 0;
a681 1
			$state->{check_digest} = 0;
@


1.36
log
@make use of the new "quirks" interface
@
text
@d4 1
a4 1
# $OpenBSD: PkgAdd.pm,v 1.35 2012/11/06 08:02:45 espie Exp $
d1132 1
a1132 3
	if ($state->{allow_replacing}) {
		$self->do_quirks($state);
	}
@


1.35
log
@work-around python compile issue: don't tie python files for now, so
that timestamps don't trigger recompile.
@
text
@d4 1
a4 1
# $OpenBSD: PkgAdd.pm,v 1.34 2012/04/28 12:00:10 espie Exp $
d998 4
@


1.34
log
@zap blank spaces
@
text
@d4 1
a4 1
# $OpenBSD$
d87 2
@


1.33
log
@zap fatpackages. nobody actually uses them.
accordingly, locations do not need to track architecture.
@
text
@d4 1
a4 1
# $OpenBSD: PkgAdd.pm,v 1.32 2011/08/23 10:32:27 espie Exp $
d95 1
a95 1
		$state->say("Tieing #1 to #2", $self->stringize, 
@


1.32
log
@zap old INSTALL/DEINSTALL stuff, it's been deprecated for 3 years, and removed
from pkg_create for over a year.
@
text
@d4 1
a4 1
# $OpenBSD: PkgAdd.pm,v 1.31 2011/08/17 10:48:27 espie Exp $
d1068 1
a1068 1
				$l = $inst->find($pkgname, $state->{arch});
@


1.31
log
@pkg_add and pkg_delete will now syslog activity by default.
@
text
@d4 1
a4 1
# $OpenBSD: PkgAdd.pm,v 1.30 2011/07/23 15:04:27 espie Exp $
d107 1
a107 1
	    '[-acIinqrsUuvxz] [-A arch] [-B pkg-destdir] [-D name[=value]]',
a797 3
			if (!$state->{interrupted} && $plist->has(INSTALL)) {
				$plist->get(INSTALL)->run($state, 'POST-INSTALL');
			}
@


1.30
log
@avoid weird warnings in case we run into a strange package.
@
text
@d4 1
a4 1
# $OpenBSD: PkgAdd.pm,v 1.29 2011/07/17 13:16:15 espie Exp $
d840 1
@


1.29
log
@unify the main loop some more: add and delete do more or less the
same processing.

start making process_set similar as well
@
text
@d4 1
a4 1
# $OpenBSD: PkgAdd.pm,v 1.28 2011/07/14 11:31:20 espie Exp $
d329 5
@


1.28
log
@move deptree_header into AddDelete, use it in pkg_delete.
Now, pkg_delete will display things a lot like pkg_add, spelling out
what reverse dependencies trigger the deletion of a given package at that
point in the list.

by popular demand.
@
text
@d4 1
a4 1
# $OpenBSD: PkgAdd.pm,v 1.27 2011/07/13 13:01:13 espie Exp $
d873 1
a873 1
sub install_set
d875 1
a875 9
	my ($set, $state) = @@_;

	$set = $set->real_set;

	$state->progress->set_header('Checking packages');

	if ($set->{finished}) {
		return ();
	}
d1020 1
a1020 1
	my $state = shift;
d1022 1
a1022 1
	install_set(quirk_set($state), $state);
d1109 9
d1124 1
a1124 1
		do_quirks($state);
d1127 1
a1127 10
	$state->tracker->todo(@@{$state->{setlist}});
	# This is the actual very small loop that adds all packages
	while (my $set = shift @@{$state->{setlist}}) {

		$state->status->what->set($set);
		unshift(@@{$state->{setlist}}, install_set($set, $state));
		eval {
			$state->quirks->tweak_list($state->{setlist}, $state);
		};
	}
@


1.27
log
@share code
@
text
@d4 1
a4 1
# $OpenBSD: PkgAdd.pm,v 1.26 2011/07/13 12:32:15 espie Exp $
a157 28
}

# one-level dependencies tree, for nicer printouts
sub build_deptree
{
	my ($state, $set, @@deps) = @@_;

	if (defined $state->{deptree}->{$set}) {
		$set = $state->{deptree}->{$set};
	}
	for my $dep (@@deps) {
		$state->{deptree}->{$dep} = $set unless
		    defined $state->{deptree}->{$dep};
	}
}

sub deptree_header
{
	my ($state, $pkg) = @@_;
	if (defined $state->{deptree}->{$pkg}) {
		my $s = $state->{deptree}->{$pkg}->real_set;
		if ($s eq $pkg) {
			delete $state->{deptree}->{$pkg};
		} else {
			return $s->short_print.':';
		}
	}
	return '';
@


1.26
log
@create DeleteSet as a specialized version of UpdateSets that print
differently, specialize the states a wee little bit.
@
text
@d4 1
a4 1
# $OpenBSD: PkgAdd.pm,v 1.25 2011/07/13 11:58:41 espie Exp $
a171 6
}

sub todo
{
	my ($state, $offset) = @@_;
	return $state->tracker->sets_todo($offset);
@


1.25
log
@fix a nasty bug: hints are evaluated lazily, so if a package is mentioned
on the command line, it's possible it won't be marked as user_tagged
early enough.
So, when we encounter it, the package is already installed, it will be moved
to kept in the set... and we need to tag it anyways
@
text
@d4 1
a4 1
# $OpenBSD: PkgAdd.pm,v 1.24 2011/07/12 10:06:57 espie Exp $
d199 24
@


1.24
log
@move option -a up into common add/delete code, in preparation for pkg_delete
change.
@
text
@d4 1
a4 1
# $OpenBSD: PkgAdd.pm,v 1.23 2011/06/27 12:17:38 espie Exp $
d902 1
@


1.23
log
@make things slightly more readable
@
text
@d4 1
a4 1
# $OpenBSD: PkgAdd.pm,v 1.22 2011/06/20 09:46:23 espie Exp $
d106 1
a106 1
	$state->SUPER::handle_options('aruUzl:A:P:Q:',
a146 1
	$state->{automatic} = $state->opt('a');
@


1.22
log
@in an UpdateSet, match new files with old files based on their sha256.
avoid extracting again identical files, leading to less file system churn.
put in a few failsafes (size check) for people with fubar'd file
systems (hey oga@@).

The more often you update, the more you gain. Over 6 months, about one
out of five files doesn't change.

apparently, improves things a lot on slow fs, as said landry@@ and sthen@@.
tested by quite a few people.
@
text
@d4 1
a4 1
# $OpenBSD: PkgAdd.pm,v 1.21 2011/01/03 19:01:04 espie Exp $
d79 1
a79 1
		$sha->{${$self->{d}}} = $self;
d87 2
a88 2
	if (defined $sha->{${$self->{d}}}) {
		my $tied = $sha->{${$self->{d}}};
@


1.21
log
@those all need newlines
@
text
@d4 1
a4 1
# $OpenBSD: PkgAdd.pm,v 1.20 2010/12/29 13:03:05 espie Exp $
d65 35
d974 10
@


1.20
log
@more stuff that uses print directly dies
@
text
@d4 1
a4 1
# $OpenBSD: PkgAdd.pm,v 1.19 2010/12/24 10:31:59 espie Exp $
d671 1
a671 1
			$state->errprint($_);
d740 1
a740 1
					$state->errprint($_);
d774 1
a774 1
				$state->errprint($_);
@


1.19
log
@pass state around.
@
text
@d4 1
a4 1
# $OpenBSD: PkgAdd.pm,v 1.18 2010/12/24 09:04:14 espie Exp $
d793 1
a793 1
		OpenBSD::Add::register_installation($plist);
@


1.18
log
@handle failures from ports tree with more care.
this does avoid infinite loops in case of wrong plists.
necessary since print-plist-with-depends CAN fail...
@
text
@d4 1
a4 1
# $OpenBSD$
d790 1
a790 1
		OpenBSD::SharedLibs::add_libs_from_plist($plist);
@


1.17
log
@pass state around and use state->print
inspired by landry@@
@
text
@d4 1
a4 1
# $OpenBSD: PkgAdd.pm,v 1.16 2010/10/02 13:36:56 espie Exp $
@


1.16
log
@somewhat complicated optimization: avoid reading the whole plist file
when we're only looking for update-info. Means Ustar must deal with
"partial" files. Occasionnally a huge win, such as skipping 95% of the kdebase
or texlive plist when they don't need updating.

I've been running with this for a few weeks now...
@
text
@d4 1
a4 1
# $OpenBSD$
d881 1
a881 1
		$set->solver->dump;
@


1.15
log
@if we pass pkgnames with .tgz to -l, just deal with it silently.
@
text
@d4 1
a4 1
# $OpenBSD: PkgAdd.pm,v 1.14 2010/08/13 11:12:43 espie Exp $
d270 23
@


1.14
log
@bad works better if you push consistent stuff in it, like always strings...
@
text
@d4 1
a4 1
# $OpenBSD: PkgAdd.pm,v 1.13 2010/08/07 09:37:44 espie Exp $
d994 1
@


1.13
log
@dep is an object, needs to become a string for error messages
@
text
@d4 1
a4 1
# $OpenBSD: PkgAdd.pm,v 1.12 2010/08/01 10:04:24 espie Exp $
d880 1
a880 1
	my @@baddeps = $set->solver->check_depends;
d882 1
a882 1
	if (@@baddeps) {
d884 1
a884 1
		    $set->print, join(',', map {$_->{pattern}} @@baddeps));
@


1.12
log
@typo
@
text
@d4 1
a4 1
# $OpenBSD: PkgAdd.pm,v 1.11 2010/08/01 10:03:24 espie Exp $
d884 1
a884 1
		    $set->print, join(',', @@baddeps));
@


1.11
log
@fix the qt 4.5 -> 4.6 update issue.
since we usually deal with directories in a global way, replacing a
directory with something else didn't work.
the fix is to record removed directories in Vstat in a "lazy" way:
we only test these objects for existence if we add something else at
the same location. Since this happens rarely, we can afford to perform
the whole SharedItems dance twice...
@
text
@d4 1
a4 1
# $OpenBSD: PkgAdd.pm,v 1.10 2010/07/30 10:06:44 espie Exp $
d382 1
a382 1
		if (grep { !/^.libs\d*\-/ && !/^partial\-/ } @@conflicts) {
@


1.10
log
@fix header during update
@
text
@d4 1
a4 1
# $OpenBSD: PkgAdd.pm,v 1.9 2010/06/30 10:51:04 espie Exp $
d659 1
@


1.9
log
@allow say and errsay to work without parameters, as it's ways common.
create verbose_system up in state, because it makes sense without verbose.
@
text
@d4 1
a4 1
# $OpenBSD$
d831 2
d1061 1
a1061 1
	$state->progress->set_header("Checking packages");
@


1.8
log
@whitespace cleanup
@
text
@@


1.7
log
@extra parameter to UpdateSet: use the factory to create extra object.
don't create updatesets directly, go through AddDelete::State.
Get all Locator/Repo access through state.
@
text
@@


1.6
log
@kill extra spaces
@
text
@d4 1
a4 1
# $OpenBSD: PkgAdd.pm,v 1.5 2010/06/25 11:12:14 espie Exp $
d443 1
a443 1
		$s = OpenBSD::UpdateSet->new->add_older(
a518 1
use OpenBSD::PackageLocator;
d951 1
a951 1
	require OpenBSD::PackageRepository::Installed;
d954 1
a954 1
	my $set = OpenBSD::UpdateSet->new;
d956 1
a956 1
	my $l = OpenBSD::PackageRepository::Installed->new->match_locations(OpenBSD::Search::Stem->new('quirks'));
d969 1
a969 1
	install_set(quirk_set(), $state);
d992 1
a992 1
			    OpenBSD::UpdateSet->new->$add_hints($_));
a997 1
		require OpenBSD::PackageRepository::Installed;
d1003 1
a1003 1
		my $inst = OpenBSD::PackageRepository::Installed->new;
d1017 1
a1017 1
				    OpenBSD::UpdateSet->new->add_older(OpenBSD::Handle->from_location($l)));
d1026 1
a1026 1
			    OpenBSD::UpdateSet->new->$add_hints($pkgname));
@


1.5
log
@clean-up options handling some more
@
text
@d4 1
a4 1
# $OpenBSD: PkgAdd.pm,v 1.4 2010/06/15 08:20:44 espie Exp $
d71 1
a71 1
	$state->SUPER::handle_options('aruUzl:A:P:Q:', 
d115 1
a115 1
	$state->{allow_replacing} = $state->{hard_replace} || 
d451 1
a451 1
		$state->errsay("NOT MERGING: can't find update for #1 (#2)", 
d503 1
a503 1
				$state->errsay("#1: internal conflict between #2 and #3", 
d621 1
a621 1
					$state->fatal("#1 is corrupted", 
d801 1
a801 1
			$state->log("Can't install #1: #2", 
d881 1
a881 1
		$state->errsay("Can't install #1: can't resolve #2", 
d986 1
a986 1
		open my $f, '<', $state->{pkglist} or 
d992 1
a992 1
			push(@@{$state->{setlist}}, 
d1018 1
a1018 1
				push(@@{$state->{setlist}}, 
@


1.4
log
@push @@todo2 global into state. name other  options with sensible names.
@
text
@d4 1
a4 1
# $OpenBSD: PkgAdd.pm,v 1.3 2010/06/09 08:13:19 espie Exp $
d68 58
a1054 59
}

sub handle_options
{
	my ($self, $cmd) = @@_;
	my $state = $self->SUPER::handle_options('aruUzl:A:P:Q:', {}, $cmd,
	    '[-acIinqrsUuvxz] [-A arch] [-B pkg-destdir] [-D name[=value]]',
	    '[-L localbase] [-l file] [-P type] [-Q quick-destdir] pkg-name [...]');

	$state->{do_faked} = 0;
	$state->{arch} = $state->opt('A');

	if (defined $state->opt('Q') and defined $state->opt('B')) {
		$state->usage("-Q and -B are incompatible options");
	}
	if (defined $state->opt('Q') and defined $state->opt('r')) {
		$state->usage("-r and -Q are incompatible options");
	}
	if ($state->opt('P')) {
		if ($state->opt('P') eq 'cdrom') {
			$state->{cdrom_only} = 1;
		}
		elsif ($state->opt('P') eq 'ftp') {
			$state->{ftp_only} = 1;
		}
		else {
		    $state->usage("bad option: -P #1", $state->opt('P'));
		}
	}
	if (defined $state->opt('Q')) {
		$state->{destdir} = $state->opt('Q');
		$state->{do_faked} = 1;
	} elsif (defined $state->opt('B')) {
		$state->{destdir} = $state->opt('B');
	} elsif (defined $ENV{'PKG_PREFIX'}) {
		$state->{destdir} = $ENV{'PKG_PREFIX'};
	}
	if (defined $state->{destdir}) {
		$state->{destdir}.='/';
		$ENV{'PKG_DESTDIR'} = $state->{destdir};
	} else {
		$state->{destdir} = '';
		delete $ENV{'PKG_DESTDIR'};
	}


	$state->{automatic} = $state->opt('a');
	$state->{hard_replace} = $state->opt('r');
	$state->{newupdates} = $state->opt('u') || $state->opt('U');
	$state->{allow_replacing} = $state->{hard_replace} || 
	    $state->{newupdates};
	$state->{pkglist} = $state->opt('l');
	$state->{update} = $state->opt('u');
	$state->{fuzzy} = $state->opt('z');

	if (@@ARGV == 0 && !$state->{update} && !$state->{pkglist}) {
		$state->usage("Missing pkgname");
	}
	return $state;
@


1.3
log
@replace confusing (n to go) message with #done/#total annotations.
e.g.,
Checking packages|No change in apr-util-mt-1.2.10p4 (26/1530)
@
text
@d4 1
a4 1
# $OpenBSD: PkgAdd.pm,v 1.2 2010/06/09 07:26:01 espie Exp $
a919 5
# Here we create the list of packages to install
# actually, an updateset list (@@todo2), and we hope to do this lazily
# later for the most part...
my @@todo2 = ();

d924 1
a924 1
	my $add_hints = $state->opt('z') ? "add_hints" : "add_hints2";
d926 4
a929 4
	# match fuzzily against a list
	if ($state->opt('l')) {
		open my $f, '<', $state->opt('l') or 
		    die "$!: bad list ".$state->opt('l');
d934 2
a935 1
			push(@@todo2, OpenBSD::UpdateSet->new->$add_hints($_));
d940 1
a940 1
	if ($state->opt('u')) {
d960 2
a961 1
				push(@@todo2, OpenBSD::UpdateSet->new->add_older(OpenBSD::Handle->from_location($l)));
d969 1
a969 1
			push(@@todo2,
d1048 3
d1052 1
a1052 1
	if (@@ARGV == 0 && !$state->opt('u') && !$state->opt('l')) {
d1061 2
a1063 1
		$state->progress->set_header("Checking packages");
d1067 1
a1067 1
	$state->tracker->todo(@@todo2);
d1069 1
a1069 2
	while (my $set = shift @@todo2) {
		$state->progress->set_header("Checking packages");
d1072 1
a1072 1
		unshift(@@todo2, install_set($set, $state));
d1074 1
a1074 1
			$state->quirks->tweak_list(\@@todo2, $state);
@


1.2
log
@ui changes: go thru a state object for most printouts
@
text
@d4 1
a4 1
# $OpenBSD: PkgAdd.pm,v 1.1 2010/06/04 13:19:39 espie Exp $
d84 2
a85 2
	my $state = shift;
	return $state->tracker->sets_todo;
d389 1
a389 1
		$state->say("Merging #1#2", $s->print, $state->ntogo);
d393 1
a393 1
		$state->errsay("NOT MERGING: can't find update for #1#2", 
@


1.1
log
@move code around, so that commands can be used as modules.
pkg becomes the start hub, which does nothing except require the
correct module.
Saner code wrt Add/Delete, and more sharing.
@
text
@d4 1
a4 1
# $OpenBSD: pkg_add,v 1.478 2010/05/10 09:17:54 espie Exp $
d43 2
a44 3
		$state->print("Comparing full signature for ",
		    $plist->pkgname, " \"", $o->string, "\" vs. \"",
		    $n->string,"\": ")
d198 2
a199 2
		print $header;
		print "(pretending) " if $state->{not};
d201 1
a201 1
			print " under ", $state->{destdir};
d203 1
a203 1
		print "\n";
d326 2
a327 3
				$state->errsay("Can't install ", $set->print,
				    " because of conflicts (",
				    join(',', @@conflicts), ")");
d336 2
a337 2
			$state->errsay("Cannot replace $toreplace in ",
			    $set->print, ": just got installed");
d363 1
a363 1
			Fatal "Can't find $name as an installed package\n";
d366 1
a366 1
			Fatal "Couldn't find packing-list for $name\n";
d389 1
a389 1
		$state->say("Merging ", $s->print, $state->ntogo);
d393 2
a394 1
		$state->errsay("NOT MERGING: can't find update for ", $s->print, $state->ntogo);
d445 2
a446 1
				$state->errsay($set->print, ": internal conflict between ", $h->pkgname, " and ", $h2->pkgname);
d555 1
a555 1
				$state->errsay("NOT CHECKING DIGITAL SIGNATURE FOR ",
d563 2
a564 1
					Fatal "fatal issues in ", $set->print;
d592 1
a592 1
			Fatal partial_install(
d594 1
a594 1
			    $set, $state);
d664 2
a665 2
				Fatal partial_install("Installation of ".
				    $handle->pkgname." failed", $set, $state);
d700 2
a701 2
			Fatal partial_install("Installation of $pkgname failed",
			    $set, $state);
d743 2
a744 2
			$state->log("Can't install ", $handle->pkgname, ": ",
				$handle->error_message, "\n");
d754 2
a755 1
				$state->log($handle->pkgname, " is not for the right architecture");
d823 2
a824 2
		$state->errsay("Can't install ", $set->print,
		    ": can't resolve ", join(',', @@baddeps));
d883 1
a883 1
		$state->print("Couldn't find updates for ", join(', ', @@cantupdate), "\n");
d886 1
a886 1
		$state->say("There were some ambiguities. ",
d962 1
a962 1
				$state->say("Problem finding $pkgname");
d986 1
a986 1
		$state->print("Packages with signatures: ",
d1004 3
a1006 3
	my $self = shift;
	my $state = $self->SUPER::handle_options('aruUzl:A:P:Q:', {},
	    'pkg_add [-acIinqrsUuvxz] [-A arch] [-B pkg-destdir] [-D name[=value]]',
d1013 1
a1013 1
		Usage "-Q and -B are incompatible options";
d1016 1
a1016 1
		Usage "-r and -Q are incompatible options";
d1026 1
a1026 1
		    Usage "bad option: -P ".$state->opt('P');
d1053 1
a1053 1
		Usage "Missing pkgname";
d1082 2
a1083 1
	return OpenBSD::PkgAdd::State->new;
@

