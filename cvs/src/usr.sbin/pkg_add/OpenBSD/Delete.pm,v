head	1.149;
access;
symbols
	OPENBSD_6_1:1.148.0.4
	OPENBSD_6_1_BASE:1.148
	OPENBSD_6_0:1.145.0.6
	OPENBSD_6_0_BASE:1.145
	OPENBSD_5_9:1.145.0.2
	OPENBSD_5_9_BASE:1.145
	OPENBSD_5_8:1.144.0.4
	OPENBSD_5_8_BASE:1.144
	OPENBSD_5_7:1.142.0.2
	OPENBSD_5_7_BASE:1.142
	OPENBSD_5_6:1.137.0.4
	OPENBSD_5_6_BASE:1.137
	OPENBSD_5_5:1.133.0.4
	OPENBSD_5_5_BASE:1.133
	OPENBSD_5_4:1.119.0.8
	OPENBSD_5_4_BASE:1.119
	OPENBSD_5_3:1.119.0.6
	OPENBSD_5_3_BASE:1.119
	OPENBSD_5_2:1.119.0.4
	OPENBSD_5_2_BASE:1.119
	OPENBSD_5_1_BASE:1.119
	OPENBSD_5_1:1.119.0.2
	OPENBSD_5_0:1.115.0.2
	OPENBSD_5_0_BASE:1.115
	OPENBSD_4_9:1.113.0.2
	OPENBSD_4_9_BASE:1.113
	OPENBSD_4_8:1.108.0.2
	OPENBSD_4_8_BASE:1.108
	OPENBSD_4_7:1.96.0.2
	OPENBSD_4_7_BASE:1.96
	OPENBSD_4_6:1.81.0.4
	OPENBSD_4_6_BASE:1.81
	OPENBSD_4_5:1.78.0.2
	OPENBSD_4_5_BASE:1.78
	OPENBSD_4_4:1.76.0.2
	OPENBSD_4_4_BASE:1.76
	OPENBSD_4_3:1.72.0.2
	OPENBSD_4_3_BASE:1.72
	OPENBSD_4_2:1.71.0.2
	OPENBSD_4_2_BASE:1.71
	OPENBSD_4_1:1.34.0.2
	OPENBSD_4_1_BASE:1.34
	OPENBSD_4_0:1.32.0.4
	OPENBSD_4_0_BASE:1.32
	OPENBSD_3_9:1.32.0.2
	OPENBSD_3_9_BASE:1.32
	OPENBSD_3_8:1.27.0.2
	OPENBSD_3_8_BASE:1.27
	OPENBSD_3_7:1.21.0.2
	OPENBSD_3_7_BASE:1.21;
locks; strict;
comment	@# @;


1.149
date	2017.04.05.11.57.58;	author sthen;	state Exp;
branches;
next	1.148;
commitid	o1fI0gva7rWbBC0U;

1.148
date	2017.03.25.18.58.59;	author espie;	state Exp;
branches;
next	1.147;
commitid	tze2rAjBliJxVa9a;

1.147
date	2017.03.09.15.36.14;	author espie;	state Exp;
branches;
next	1.146;
commitid	JTug2YyGr0NgN1kx;

1.146
date	2016.08.27.18.17.46;	author espie;	state Exp;
branches;
next	1.145;
commitid	gU2z7H9jfAvdu8Iz;

1.145
date	2016.02.03.18.30.15;	author robert;	state Exp;
branches;
next	1.144;
commitid	1CSdxNzAHLPF2L4Q;

1.144
date	2015.07.28.13.22.07;	author espie;	state Exp;
branches;
next	1.143;
commitid	ooJcqCwqqMVADfcu;

1.143
date	2015.05.18.10.41.19;	author espie;	state Exp;
branches;
next	1.142;
commitid	rrwCEb8hinrmFki2;

1.142
date	2014.11.30.15.53.26;	author espie;	state Exp;
branches;
next	1.141;
commitid	4TfcC66BF3LV8lu0;

1.141
date	2014.11.27.14.15.48;	author espie;	state Exp;
branches;
next	1.140;
commitid	NPORR02wekcKpHJI;

1.140
date	2014.11.25.14.16.15;	author espie;	state Exp;
branches;
next	1.139;
commitid	UeC1WcUe5pQNhy3k;

1.139
date	2014.11.21.15.07.09;	author espie;	state Exp;
branches;
next	1.138;
commitid	9JKM8glnI39M4iKz;

1.138
date	2014.11.20.15.08.21;	author espie;	state Exp;
branches;
next	1.137;
commitid	34b5MSuPnxcJiMqh;

1.137
date	2014.05.20.05.55.43;	author espie;	state Exp;
branches;
next	1.136;

1.136
date	2014.05.20.05.46.13;	author espie;	state Exp;
branches;
next	1.135;

1.135
date	2014.04.18.10.00.48;	author schwarze;	state Exp;
branches;
next	1.134;

1.134
date	2014.03.18.18.53.29;	author espie;	state Exp;
branches;
next	1.133;

1.133
date	2014.02.08.10.43.25;	author espie;	state Exp;
branches;
next	1.132;

1.132
date	2014.02.06.16.55.01;	author espie;	state Exp;
branches;
next	1.131;

1.131
date	2014.02.03.16.13.13;	author espie;	state Exp;
branches;
next	1.130;

1.130
date	2014.02.03.15.57.13;	author espie;	state Exp;
branches;
next	1.129;

1.129
date	2014.01.30.13.23.51;	author espie;	state Exp;
branches;
next	1.128;

1.128
date	2014.01.30.12.38.20;	author espie;	state Exp;
branches;
next	1.127;

1.127
date	2014.01.10.16.05.31;	author espie;	state Exp;
branches;
next	1.126;

1.126
date	2014.01.09.20.20.01;	author espie;	state Exp;
branches;
next	1.125;

1.125
date	2014.01.07.13.31.36;	author espie;	state Exp;
branches;
next	1.124;

1.124
date	2014.01.05.10.24.30;	author espie;	state Exp;
branches;
next	1.123;

1.123
date	2014.01.02.16.05.42;	author espie;	state Exp;
branches;
next	1.122;

1.122
date	2013.12.30.09.02.37;	author espie;	state Exp;
branches;
next	1.121;

1.121
date	2013.12.25.14.38.15;	author espie;	state Exp;
branches;
next	1.120;

1.120
date	2013.09.24.21.00.57;	author espie;	state Exp;
branches;
next	1.119;

1.119
date	2012.01.16.08.42.38;	author schwarze;	state Exp;
branches;
next	1.118;

1.118
date	2012.01.05.23.03.57;	author schwarze;	state Exp;
branches;
next	1.117;

1.117
date	2011.09.17.15.33.56;	author schwarze;	state Exp;
branches;
next	1.116;

1.116
date	2011.08.23.10.32.27;	author espie;	state Exp;
branches;
next	1.115;

1.115
date	2011.07.12.10.30.29;	author espie;	state Exp;
branches;
next	1.114;

1.114
date	2011.06.20.09.46.23;	author espie;	state Exp;
branches;
next	1.113;

1.113
date	2011.01.23.06.56.53;	author espie;	state Exp;
branches;
next	1.112;

1.112
date	2010.12.24.09.09.54;	author espie;	state Exp;
branches;
next	1.111;

1.111
date	2010.12.24.09.04.14;	author espie;	state Exp;
branches;
next	1.110;

1.110
date	2010.12.13.12.13.54;	author espie;	state Exp;
branches;
next	1.109;

1.109
date	2010.10.27.14.35.56;	author espie;	state Exp;
branches;
next	1.108;

1.108
date	2010.08.01.10.03.24;	author espie;	state Exp;
branches;
next	1.107;

1.107
date	2010.07.25.05.20.34;	author espie;	state Exp;
branches;
next	1.106;

1.106
date	2010.07.24.10.49.01;	author espie;	state Exp;
branches;
next	1.105;

1.105
date	2010.06.30.10.51.04;	author espie;	state Exp;
branches;
next	1.104;

1.104
date	2010.06.30.10.41.42;	author espie;	state Exp;
branches;
next	1.103;

1.103
date	2010.06.09.08.13.19;	author espie;	state Exp;
branches;
next	1.102;

1.102
date	2010.06.09.07.26.01;	author espie;	state Exp;
branches;
next	1.101;

1.101
date	2010.06.04.13.19.39;	author espie;	state Exp;
branches;
next	1.100;

1.100
date	2010.05.10.09.17.55;	author espie;	state Exp;
branches;
next	1.99;

1.99
date	2010.05.10.09.05.27;	author espie;	state Exp;
branches;
next	1.98;

1.98
date	2010.04.05.13.46.24;	author espie;	state Exp;
branches;
next	1.97;

1.97
date	2010.03.22.20.38.44;	author espie;	state Exp;
branches;
next	1.96;

1.96
date	2010.01.02.12.59.45;	author espie;	state Exp;
branches;
next	1.95;

1.95
date	2009.12.28.21.28.00;	author espie;	state Exp;
branches;
next	1.94;

1.94
date	2009.12.20.22.38.45;	author espie;	state Exp;
branches;
next	1.93;

1.93
date	2009.12.17.11.57.02;	author espie;	state Exp;
branches;
next	1.92;

1.92
date	2009.12.17.08.21.09;	author espie;	state Exp;
branches;
next	1.91;

1.91
date	2009.12.14.09.35.56;	author espie;	state Exp;
branches;
next	1.90;

1.90
date	2009.12.05.09.26.42;	author espie;	state Exp;
branches;
next	1.89;

1.89
date	2009.11.28.09.36.32;	author espie;	state Exp;
branches;
next	1.88;

1.88
date	2009.11.16.14.42.18;	author espie;	state Exp;
branches;
next	1.87;

1.87
date	2009.11.11.13.00.40;	author espie;	state Exp;
branches;
next	1.86;

1.86
date	2009.11.11.12.21.20;	author espie;	state Exp;
branches;
next	1.85;

1.85
date	2009.11.11.12.04.19;	author espie;	state Exp;
branches;
next	1.84;

1.84
date	2009.11.11.11.13.16;	author espie;	state Exp;
branches;
next	1.83;

1.83
date	2009.11.10.11.36.56;	author espie;	state Exp;
branches;
next	1.82;

1.82
date	2009.10.11.11.01.44;	author espie;	state Exp;
branches;
next	1.81;

1.81
date	2009.04.19.14.58.32;	author espie;	state Exp;
branches;
next	1.80;

1.80
date	2009.04.18.08.30.02;	author espie;	state Exp;
branches;
next	1.79;

1.79
date	2009.04.14.17.53.58;	author espie;	state Exp;
branches;
next	1.78;

1.78
date	2008.10.20.10.25.16;	author espie;	state Exp;
branches;
next	1.77;

1.77
date	2008.10.06.09.36.17;	author espie;	state Exp;
branches;
next	1.76;

1.76
date	2008.06.11.09.43.25;	author espie;	state Exp;
branches;
next	1.75;

1.75
date	2008.03.11.08.46.14;	author espie;	state Exp;
branches;
next	1.74;

1.74
date	2008.03.08.11.48.01;	author espie;	state Exp;
branches;
next	1.73;

1.73
date	2008.03.08.11.41.42;	author espie;	state Exp;
branches;
next	1.72;

1.72
date	2008.03.03.16.48.32;	author espie;	state Exp;
branches;
next	1.71;

1.71
date	2007.06.30.11.35.21;	author espie;	state Exp;
branches;
next	1.70;

1.70
date	2007.06.25.09.30.16;	author espie;	state Exp;
branches;
next	1.69;

1.69
date	2007.06.18.10.47.03;	author espie;	state Exp;
branches;
next	1.68;

1.68
date	2007.06.16.11.50.49;	author espie;	state Exp;
branches;
next	1.67;

1.67
date	2007.06.16.09.29.37;	author espie;	state Exp;
branches;
next	1.66;

1.66
date	2007.06.14.09.29.32;	author espie;	state Exp;
branches;
next	1.65;

1.65
date	2007.06.06.15.35.20;	author espie;	state Exp;
branches;
next	1.64;

1.64
date	2007.06.06.15.31.06;	author espie;	state Exp;
branches;
next	1.63;

1.63
date	2007.06.06.12.32.09;	author espie;	state Exp;
branches;
next	1.62;

1.62
date	2007.06.04.14.42.19;	author espie;	state Exp;
branches;
next	1.61;

1.61
date	2007.06.04.14.40.39;	author espie;	state Exp;
branches;
next	1.60;

1.60
date	2007.06.04.10.58.23;	author espie;	state Exp;
branches;
next	1.59;

1.59
date	2007.06.02.10.32.31;	author espie;	state Exp;
branches;
next	1.58;

1.58
date	2007.06.01.14.58.29;	author espie;	state Exp;
branches;
next	1.57;

1.57
date	2007.05.31.13.33.17;	author espie;	state Exp;
branches;
next	1.56;

1.56
date	2007.05.31.11.05.41;	author espie;	state Exp;
branches;
next	1.55;

1.55
date	2007.05.31.10.00.22;	author espie;	state Exp;
branches;
next	1.54;

1.54
date	2007.05.30.16.32.14;	author espie;	state Exp;
branches;
next	1.53;

1.53
date	2007.05.30.14.04.51;	author espie;	state Exp;
branches;
next	1.52;

1.52
date	2007.05.30.12.30.15;	author espie;	state Exp;
branches;
next	1.51;

1.51
date	2007.05.30.11.13.04;	author espie;	state Exp;
branches;
next	1.50;

1.50
date	2007.05.29.14.39.03;	author espie;	state Exp;
branches;
next	1.49;

1.49
date	2007.05.28.13.00.05;	author espie;	state Exp;
branches;
next	1.48;

1.48
date	2007.05.28.12.16.55;	author espie;	state Exp;
branches;
next	1.47;

1.47
date	2007.05.28.11.15.11;	author espie;	state Exp;
branches;
next	1.46;

1.46
date	2007.05.22.11.02.57;	author espie;	state Exp;
branches;
next	1.45;

1.45
date	2007.05.22.10.11.59;	author espie;	state Exp;
branches;
next	1.44;

1.44
date	2007.05.22.09.39.23;	author espie;	state Exp;
branches;
next	1.43;

1.43
date	2007.05.15.09.32.18;	author espie;	state Exp;
branches;
next	1.42;

1.42
date	2007.05.14.09.49.27;	author espie;	state Exp;
branches;
next	1.41;

1.41
date	2007.05.07.09.32.51;	author espie;	state Exp;
branches;
next	1.40;

1.40
date	2007.05.07.08.34.09;	author espie;	state Exp;
branches;
next	1.39;

1.39
date	2007.05.07.08.24.16;	author espie;	state Exp;
branches;
next	1.38;

1.38
date	2007.05.02.15.17.36;	author espie;	state Exp;
branches;
next	1.37;

1.37
date	2007.05.02.15.05.29;	author espie;	state Exp;
branches;
next	1.36;

1.36
date	2007.04.29.11.09.29;	author espie;	state Exp;
branches;
next	1.35;

1.35
date	2007.04.15.10.17.29;	author espie;	state Exp;
branches;
next	1.34;

1.34
date	2007.03.07.11.24.07;	author espie;	state Exp;
branches;
next	1.33;

1.33
date	2006.10.18.16.40.40;	author sturm;	state Exp;
branches;
next	1.32;

1.32
date	2005.10.27.07.02.02;	author bernd;	state Exp;
branches;
next	1.31;

1.31
date	2005.10.24.10.19.16;	author espie;	state Exp;
branches;
next	1.30;

1.30
date	2005.10.24.10.10.26;	author espie;	state Exp;
branches;
next	1.29;

1.29
date	2005.10.24.09.50.51;	author espie;	state Exp;
branches;
next	1.28;

1.28
date	2005.10.22.13.11.07;	author espie;	state Exp;
branches;
next	1.27;

1.27
date	2005.08.22.11.34.52;	author espie;	state Exp;
branches;
next	1.26;

1.26
date	2005.08.17.09.19.09;	author espie;	state Exp;
branches;
next	1.25;

1.25
date	2005.08.16.17.27.40;	author espie;	state Exp;
branches;
next	1.24;

1.24
date	2005.08.09.20.55.26;	author espie;	state Exp;
branches;
next	1.23;

1.23
date	2005.08.05.09.52.08;	author espie;	state Exp;
branches;
next	1.22;

1.22
date	2005.07.24.10.41.14;	author espie;	state Exp;
branches;
next	1.21;

1.21
date	2005.02.09.11.07.13;	author espie;	state Exp;
branches;
next	1.20;

1.20
date	2004.12.29.14.10.27;	author espie;	state Exp;
branches;
next	1.19;

1.19
date	2004.12.21.18.12.05;	author espie;	state Exp;
branches;
next	1.18;

1.18
date	2004.12.20.12.16.51;	author espie;	state Exp;
branches;
next	1.17;

1.17
date	2004.12.16.11.07.33;	author espie;	state Exp;
branches;
next	1.16;

1.16
date	2004.12.15.01.07.10;	author espie;	state Exp;
branches;
next	1.15;

1.15
date	2004.12.12.11.26.16;	author espie;	state Exp;
branches;
next	1.14;

1.14
date	2004.12.02.00.37.55;	author espie;	state Exp;
branches;
next	1.13;

1.13
date	2004.11.27.12.07.58;	author espie;	state Exp;
branches;
next	1.12;

1.12
date	2004.11.27.11.36.16;	author espie;	state Exp;
branches;
next	1.11;

1.11
date	2004.11.21.13.32.18;	author espie;	state Exp;
branches;
next	1.10;

1.10
date	2004.11.14.19.25.45;	author espie;	state Exp;
branches;
next	1.9;

1.9
date	2004.11.11.22.40.38;	author espie;	state Exp;
branches;
next	1.8;

1.8
date	2004.11.11.11.51.53;	author espie;	state Exp;
branches;
next	1.7;

1.7
date	2004.11.11.11.16.39;	author espie;	state Exp;
branches;
next	1.6;

1.6
date	2004.11.09.11.11.01;	author espie;	state Exp;
branches;
next	1.5;

1.5
date	2004.11.09.10.49.25;	author espie;	state Exp;
branches;
next	1.4;

1.4
date	2004.11.06.12.22.33;	author espie;	state Exp;
branches;
next	1.3;

1.3
date	2004.11.01.19.14.26;	author espie;	state Exp;
branches;
next	1.2;

1.2
date	2004.10.31.12.40.01;	author espie;	state Exp;
branches;
next	1.1;

1.1
date	2004.10.31.10.26.17;	author espie;	state Exp;
branches;
next	;


desc
@@


1.149
log
@For a non-interactive attempt to pkg_delete a firmware package, print a
message advising use of "fw_update -d" rather than saying "ok" and doing
nothing. (pkg_delete intentionally makes it hard to uninstall firmware
to prevent surprises when cleaning a machine).

aja and I were surprised by the "ok" leaving the fw package installed.
suggestion from espie to mention fw_update -d in the message.
@
text
@# ex:ts=8 sw=4:
# $OpenBSD: Delete.pm,v 1.148 2017/03/25 18:58:59 espie Exp $
#
# Copyright (c) 2003-2014 Marc Espie <espie@@openbsd.org>
#
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

use strict;
use warnings;

package OpenBSD::Delete;
use OpenBSD::Error;
use OpenBSD::PackageInfo;
use OpenBSD::RequiredBy;
use OpenBSD::Paths;
use File::Basename;

sub keep_old_files
{
	my ($state, $plist) = @@_;
	my $p = OpenBSD::PackingList->new;
	my $borked = borked_package($plist->pkgname);
	$p->set_infodir(installed_info($borked));
	mkdir($p->infodir);

	$plist->copy_old_stuff($p, $state);
	$p->set_pkgname($borked);
	$p->to_installation;
	return $borked;
}

sub manpages_unindex
{
	my ($state) = @@_;
	return unless defined $state->{rmman};
	my $destdir = $state->{destdir};

	while (my ($k, $v) = each %{$state->{rmman}}) {
		my @@l = map { "$destdir$k/$_" } @@$v;
		if ($state->{not}) {
			$state->say("Removing manpages in #1: #2",
			    $destdir.$k, join(' ', @@l)) if $state->verbose;
		} else {
			$state->run_makewhatis(['-u', $destdir.$k], \@@l);
		}
	}
	delete $state->{rmman};
}

sub validate_plist
{
	my ($plist, $state) = @@_;

	$plist->prepare_for_deletion($state, $plist->pkgname);
}

sub remove_packing_info
{
	my ($plist, $state) = @@_;

	my $dir = $plist->infodir;

	for my $fname (info_names()) {
		unlink($dir.$fname);
	}
	OpenBSD::RequiredBy->forget($dir);
	OpenBSD::Requiring->forget($dir);
	rmdir($dir) or
	    $state->fatal("can't finish removing directory #1: #2", $dir, $!);
}

sub delete_package
{
	my ($pkgname, $state) = @@_;
	$state->progress->message($state->f("reading list for #1", $pkgname));
	my $plist = OpenBSD::PackingList->from_installation($pkgname) or
	    $state->fatal("bad package #1", $pkgname);
	if (!defined $plist->pkgname) {
		$state->fatal("package #1 is missing a \@@name in plist",
		    $pkgname);
	}
	if ($plist->pkgname ne $pkgname) {
		$state->fatal("Package real name #1 does not match #2",
			$plist->pkgname, $pkgname);
	}
	if ($plist->has('firmware')) {
		if ($state->is_interactive) {
			if (!$state->confirm("\nDelete firmware $pkgname", 0)) {
				$state->errsay("NOT deleting #1", $pkgname);
				return;
			}
		} else {
			$state->errsay("NOT deleting #1: use fwupdate -d", $pkgname);
			return;
		}
	}

	$state->{problems} = 0;
	validate_plist($plist, $state);
	$state->fatal("can't recover from deinstalling #1", $pkgname)
	    if $state->{problems};
	$state->vstat->synchronize;

	delete_plist($plist, $state);
}

sub unregister_dependencies
{
	my ($plist, $state) = @@_;

	my $pkgname = $plist->pkgname;
	my $l = OpenBSD::Requiring->new($pkgname);

	for my $name ($l->list) {
		$state->say("remove dependency on #1", $name)
		    if $state->verbose >= 3;
		local $@@;
		try {
			OpenBSD::RequiredBy->new($name)->delete($pkgname);
		} catchall {
			$state->errsay($_);
		};
	}
	$l->erase;
}

sub delete_plist
{
	my ($plist, $state) = @@_;

	my $pkgname = $plist->pkgname;
	$state->{pkgname} = $pkgname;
	if (!$state->{size_only}) {
		$plist->register_manpage($state, 'rmman');
		manpages_unindex($state);
		$state->progress->visit_with_size($plist, 'delete');
	}

	unregister_dependencies($plist, $state);
	return if $state->{not};
	if ($state->{baddelete}) {
	    my $borked = keep_old_files($state, $plist);
	    $state->log("Files kept as #1 package", $borked);
	    delete $state->{baddelete};
	}


	remove_packing_info($plist, $state);
	delete_installed($pkgname);
}

package OpenBSD::PackingElement;

sub rename_file_to_temp
{
	my ($self, $state) = @@_;
	require OpenBSD::Temp;

	my $n = $self->realname($state);

	my ($fh, $j) = OpenBSD::Temp::permanent_file(undef, $n);
	close $fh;
	if (rename($n, $j)) {
		$state->say("Renaming old file #1 to #2", $n, $j);
		if ($self->name !~ m/^\//o && $self->cwd ne '.') {
			my $c = $self->cwd;
			$j =~ s|^\Q$c\E/||;
		}
		$self->set_name($j);
	} else {
		$state->errsay("Bad rename #1 to #2: #3", $n, $j, $!);
	}
}

sub prepare_for_deletion
{
}

sub delete
{
}

sub record_shared
{
}

sub copy_old_stuff
{
}

package OpenBSD::PackingElement::Cwd;

sub copy_old_stuff
{
	my ($self, $plist, $state) = @@_;
	$self->add_object($plist);
}

package OpenBSD::PackingElement::FileObject;
use File::Basename;

sub mark_directory
{
	my ($self, $state, $dir) = @@_;

	$state->{dirs_okay}{$dir} = 1;
	my $d2 = dirname($dir);
	if ($d2 ne $dir) {
		$self->mark_directory($state, $d2);
	}
}

sub mark_dir
{
	my ($self, $state) = @@_;

	$self->mark_directory($state, dirname($self->fullname));
}

sub do_not_delete
{
	my ($self, $state) = @@_;

	my $realname = $self->realname($state);
	$state->{baddelete} = 1;
	$self->{stillaround} = 1;

	delete $self->{symlink};
	delete $self->{link};
	my $algo = $self->{d};
	delete $self->{d};

	if (-l $realname) {
		$self->{symlink} = readlink $realname;
	} elsif (-f _) {
		$self->{d} = $self->compute_digest($realname, $algo);
	} elsif (-d _) {
		# what should we do ?
	}
}


package OpenBSD::PackingElement::DirlikeObject;
sub mark_dir
{
	my ($self, $state) = @@_;
	$self->mark_directory($state, $self->fullname);
}

package OpenBSD::PackingElement::RcScript;
# XXX we should check stuff more thoroughly

sub delete
{
	my ($self, $state) = @@_;
	$state->{delete_rcscripts}{$self->fullname} = 1;
	$self->SUPER::delete($state);
}

package OpenBSD::PackingElement::NewUser;
sub delete
{
	my ($self, $state) = @@_;

	if ($state->verbose >= 2) {
		$state->say("rmuser: #1", $self->name);
	}

	$self->record_shared($state->{recorder}, $state->{pkgname});
}

sub record_shared
{
	my ($self, $recorder, $pkgname) = @@_;
	$recorder->{users}{$self->name} = $pkgname;
}

package OpenBSD::PackingElement::NewGroup;
sub delete
{
	my ($self, $state) = @@_;

	if ($state->verbose >= 2) {
		$state->say("rmgroup: #1", $self->name);
	}

	$self->record_shared($state->{recorder}, $state->{pkgname});
}

sub record_shared
{
	my ($self, $recorder, $pkgname) = @@_;
	$recorder->{groups}{$self->name} = $pkgname;
}

package OpenBSD::PackingElement::DirBase;
sub prepare_for_deletion
{
	my ($self, $state, $pkgname) = @@_;
	my $fname = $state->{destdir}.$self->fullname;
	$state->vstat->remove_directory($fname, $self);
}

sub delete
{
	my ($self, $state) = @@_;

	if ($state->verbose >= 5) {
		$state->say("rmdir: #1", $self->fullname);
	}

	$self->record_shared($state->{recorder}, $state->{pkgname});
}

sub record_shared
{
	my ($self, $recorder, $pkgname) = @@_;
	# enough for the entry to exist, we only record interesting
	# entries more thoroughly
	$recorder->{dirs}{$self->fullname} //= [];
}

package OpenBSD::PackingElement::Mandir;
sub record_shared
{
	my ($self, $recorder, $pkgname) = @@_;
	$self->{pkgname} = $pkgname;
	push(@@{$recorder->{dirs}{$self->fullname}} , $self);
}

package OpenBSD::PackingElement::Fontdir;
sub record_shared
{
	my ($self, $recorder, $pkgname) = @@_;
	$self->{pkgname} = $pkgname;
	push(@@{$recorder->{dirs}{$self->fullname}} , $self);
	$recorder->{fonts_todo}{$self->fullname} = 1;
}

package OpenBSD::PackingElement::Infodir;
sub record_shared
{
	&OpenBSD::PackingElement::Mandir::record_shared;
}

package OpenBSD::PackingElement::Unexec;
sub delete
{
	my ($self, $state) = @@_;
	if ($self->should_run($state)) {
		$self->run($state);
	}
}

sub should_run() { 1 }

package OpenBSD::PackingElement::UnexecDelete;
sub should_run
{
	my ($self, $state) = @@_;
	return !$state->replacing;
}

package OpenBSD::PackingElement::UnexecUpdate;
sub should_run
{
	my ($self, $state) = @@_;
	return $state->replacing;
}

package OpenBSD::PackingElement::FileBase;
use OpenBSD::Error;

sub prepare_for_deletion
{
	my ($self, $state, $pkgname) = @@_;

	my $fname = $state->{destdir}.$self->fullname;
	my $s;
	my $size = $self->{tied} ? 0 : $self->{size};
	if ($state->{delete_first}) {
		$s = $state->vstat->remove_first($fname, $size);
	} else {
		$s = $state->vstat->remove($fname, $size);
	}
	return unless defined $s;
	if ($s->ro) {
		$s->report_ro($state, $fname);
	}
}

sub is_intact
{
	my ($self, $state, $realname) = @@_;
	return 1 if defined($self->{link}) or $self->{nochecksum};
	if (!defined $self->{d}) {
		if ($self->fullname eq $realname) {
			$state->say("NOT deleting #1 (no checksum)", $realname);
		} else {
			$state->say("Not deleting #1 (no checksum for #2",
			    $realname, $self->fullname);
		}
		$state->log("Couldn't delete #1 (no checksum)", $realname);
		return 0;
	}
	return 1 unless $state->defines('checksum');
	my $d = $self->compute_digest($realname, $self->{d});
	return 1 if $d->equals($self->{d});
	if ($self->fullname eq $realname) {
		$state->say("NOT deleting #1 (bad checksum)", $realname);
	} else {
		$state->say("Not deleting #1 (bad checksum for #2)",
		    $realname, $self->fullname);
	}
	$state->log("Couldn't delete #1 (bad checksum)", $realname);
	return 0;
}

sub delete
{
	my ($self, $state) = @@_;
	my $realname = $self->realname($state);

	if (defined $self->{symlink}) {
		if (-l $realname) {
			my $contents = readlink $realname;
			if ($contents ne $self->{symlink}) {
				$state->say("Symlink does not match: #1 (#2 vs. #3)",
				    $realname, $contents, $self->{symlink});
				$self->do_not_delete($state);
				return;
			}
		} else  {
			$state->say("Bogus symlink: #1", $realname);
			$self->do_not_delete($state);
			return;
		}
	} else {
		if (-l $realname) {
				$state->say("Unexpected symlink: #1", $realname);
				$self->do_not_delete($state);
		} else {
			if (!-f $realname) {
				$state->say("File #1 does not exist", $realname);
				return;
			}
			if (!$self->is_intact($state, $realname)) {
				$self->do_not_delete($state);
				return;
			}
		}
	}
	if ($state->verbose >= 5) {
		$state->say("deleting: #1", $realname);
	}
	return if $state->{not};
	if ($state->{delete_first} && $self->{tied}) {
		push(@@{$state->{delayed}}, $realname);
	} else {
		if (!unlink $realname) {
			$state->errsay("Problem deleting #1: #2", $realname, 
			    $!);
			$state->log("deleting #1 failed: #2", $realname, $!);
		}
	}
}

sub copy_old_stuff
{
	my ($self, $plist, $state) = @@_;

	if (defined $self->{stillaround}) {
		delete $self->{stillaround};
		if ($state->replacing) {
			$self->rename_file_to_temp($state);
		}
		$self->add_object($plist);
	}
}

package OpenBSD::PackingElement::SpecialFile;
use OpenBSD::PackageInfo;

sub prepare_for_deletion
{
	my ($self, $state, $pkgname) = @@_;

	my $fname = $self->fullname;
	my $size = $self->{size};
	if (!defined $size) {
		$size = (stat $fname)[7];
	}
	my $s = $state->vstat->remove($fname, $self->{size});
	return unless defined $s;
	if ($s->ro) {
		$s->report_ro($state, $fname);
	}
}

sub copy_old_stuff
{
}

package OpenBSD::PackingElement::Meta;
sub copy_old_stuff
{
	my ($self, $plist, $state) = @@_;
	$self->add_object($plist);
}

package OpenBSD::PackingElement::DigitalSignature;
sub copy_old_stuff
{
}

package OpenBSD::PackingElement::FDESC;
sub copy_old_stuff
{
	my ($self, $plist, $state) = @@_;
	require File::Copy;

	File::Copy::copy($self->fullname, $plist->infodir);
	$self->add_object($plist);
}

package OpenBSD::PackingElement::Sample;
use OpenBSD::Error;
use File::Basename;

sub delete
{
	my ($self, $state) = @@_;
	my $realname = $self->realname($state);

	my $orig = $self->{copyfrom};
	if (!defined $orig) {
		$state->fatal("\@@sample element does not reference a valid file");
	}
	my $action = $state->replacing ? "check" : "remove";
	my $origname = $orig->realname($state);
	if (! -e $realname) {
		$state->log("File #1 does not exist", $realname);
		return;
	}
	if (! -f $realname) {
		$state->log("File #1 is not a file", $realname);
		return;
	}

	if (!defined $orig->{d}) {
		$state->log("Couldn't delete #1 (no checksum)", $realname);
		return;
	}

	if ($state->{quick} && $state->{quick} >= 2) {
		unless ($state->{extra}) {
			$self->mark_dir($state);
			$state->log("You should also #1 #2", $action, $realname );
			return;
		}
	} else {
		my $d = $self->compute_digest($realname, $orig->{d});
		if ($d->equals($orig->{d})) {
			$state->say("File #1 identical to sample", $realname) if $state->verbose >= 2;
		} else {
			unless ($state->{extra}) {
				$self->mark_dir($state);
				$state->log("You should also #1 #2 (which was modified)", $action, $realname);
				return;
			}
		}
	}
	$state->say("deleting #1", $realname) if $state->verbose >= 2;
	return if $state->{not};
	if (!unlink $realname) {
		$state->errsay("Problem deleting #1: #2", $realname, $!);
		$state->log("deleting #1 failed: #2", $realname, $!);
	}
}


package OpenBSD::PackingElement::InfoFile;
use File::Basename;
use OpenBSD::Error;
sub delete
{
	my ($self, $state) = @@_;
	unless ($state->{not}) {
	    my $fullname = $state->{destdir}.$self->fullname;
	    $state->vsystem(OpenBSD::Paths->install_info,
		"--delete", "--info-dir=".dirname($fullname), '--', $fullname);
	}
	$self->SUPER::delete($state);
}

package OpenBSD::PackingElement::Shell;
sub delete
{
	my ($self, $state) = @@_;
	unless ($state->{not}) {
		my $destdir = $state->{destdir};
		my $fullname = $self->fullname;
		my @@l=();
		if (open(my $shells, '<', $destdir.OpenBSD::Paths->shells)) {
			while(<$shells>) {
				push(@@l, $_);
				s/^\#.*//o;
				if ($_ =~ m/^\Q$fullname\E\s*$/) {
					pop(@@l);
				}
			}
			close($shells);
			open(my $shells2, '>', $destdir.OpenBSD::Paths->shells);
			print $shells2 @@l;
			close $shells2;
			$state->say("Shell #1 removed from #2",
			    $fullname, $destdir.OpenBSD::Paths->shells)
			    	if $state->verbose;
		}
	}
	$self->SUPER::delete($state);
}

package OpenBSD::PackingElement::Extra;
use File::Basename;

sub delete
{
	my ($self, $state) = @@_;
	my $realname = $self->realname($state);
	if ($state->verbose >= 2 && $state->{extra}) {
		$state->say("deleting extra file: #1", $realname);
	}
	return if $state->{not};
	return unless -e $realname or -l $realname;
	if ($state->replacing) {
		$state->log("Remember to update #1", $realname);
		$self->mark_dir($state);
	} elsif ($state->{extra}) {
		unlink($realname) or
		    $state->say("problem deleting extra file #1: #2", $realname, $!);
	} else {
		$state->log("You should also remove #1", $realname);
		$self->mark_dir($state);
	}
}


package OpenBSD::PackingElement::Extradir;
sub delete
{
	my ($self, $state) = @@_;
	return unless $state->{extra};
	my $realname = $self->realname($state);
	return if $state->replacing;
	if ($state->{extra}) {
		$self->SUPER::delete($state);
	} else {
		$state->log("You should also remove the directory #1", $realname);
		$self->mark_dir($state);
	}
}

package OpenBSD::PackingElement::ExtraUnexec;

sub delete
{
	my ($self, $state) = @@_;
	if ($state->{extra}) {
		$self->run($state);
	} else {
		$state->log("You should also run #1", $self->{expanded});
	}
}

package OpenBSD::PackingElement::Lib;
sub delete
{
	my ($self, $state) = @@_;
	$self->SUPER::delete($state);
	$self->mark_ldconfig_directory($state);
}

package OpenBSD::PackingElement::Depend;
sub copy_old_stuff
{
	my ($self, $plist, $state) = @@_;

	OpenBSD::PackingElement::Comment->add($plist, "\@@".$self->keyword." ".$self->stringize);
}

package OpenBSD::PackingElement::FDISPLAY;
sub delete
{
	my ($self, $state) = @@_;
	$state->{current_set}{known_displays}{$self->{d}->key} = 1;
	$self->SUPER::delete($state);
}

package OpenBSD::PackingElement::FUNDISPLAY;
sub delete
{
	my ($self, $state) = @@_;
	my $d = $self->{d};
	if (!$state->{current_set}{known_displays}{$self->{d}->key}) {
		$self->prepare($state);
	}
	$self->SUPER::delete($state);
}

package OpenBSD::PackingElement::Mandir;
sub delete
{
	my ($self, $state) = @@_;
	$state->{current_set}{known_mandirs}{$self->fullname} = 1;
	$self->SUPER::delete($state);
}

1;
@


1.148
log
@tweak checksums on delete to not happen by default, with an interface
as discussed with sthen@@

manpage bits to follow soonish
@
text
@d2 1
a2 1
# $OpenBSD: Delete.pm,v 1.147 2017/03/09 15:36:14 espie Exp $
d103 1
@


1.147
log
@take the checksum part out of line.

Fix the "no checksum" part: pass thru do_not_delete, and do it even if
quick is set.

Simplify the error messages in case realname and fullname are identical
(which is the most common case)
@
text
@d2 1
a2 1
# $OpenBSD: Delete.pm,v 1.146 2016/08/27 18:17:46 espie Exp $
d415 1
a415 1
	return 1 if $self->{quick};
@


1.146
log
@in case we run delete_first (not enough room), delay the unlink of
tied items so we can still skip extracting them.

better than the stopgap measure I committed a few weeks ago.
@
text
@d2 1
a2 1
# $OpenBSD: Delete.pm,v 1.145 2016/02/03 18:30:15 robert Exp $
d401 27
d452 1
a452 1
			if (! -f $realname) {
d456 3
a458 18
			unless (defined($self->{link}) or $self->{nochecksum} or $state->{quick}) {
				if (!defined $self->{d}) {
					$state->say("Problem: #1 does not have a checksum\n".
					    "NOT deleting: #2",
					    $self->fullname, $realname);
					$state->log("Couldn't delete #1 (no checksum)", $realname);
					return;
				}
				my $d = $self->compute_digest($realname,
				    $self->{d});
				if (!$d->equals($self->{d})) {
					$state->say("Problem: checksum doesn't match for #1\n".
					    "NOT deleting: #2",
					    $self->fullname, $realname);
					$state->log("Couldn't delete #1 (bad checksum)", $realname);
					$self->do_not_delete($state);
					return;
				}
@


1.145
log
@update the font cache by running fc-cache after removing packages
with @@fontdir markers

ok espie@@
@
text
@d2 1
a2 1
# $OpenBSD: Delete.pm,v 1.144 2015/07/28 13:22:07 espie Exp $
d454 8
a461 3
	if (!unlink $realname) {
		$state->errsay("Problem deleting #1: #2", $realname, $!);
		$state->log("deleting #1 failed: #2", $realname, $!);
@


1.144
log
@make -B with bad checksums cope. Reported by millert@@
@
text
@d2 1
a2 1
# $OpenBSD: Delete.pm,v 1.143 2015/05/18 10:41:19 espie Exp $
d343 4
a346 1
	&OpenBSD::PackingElement::Mandir::record_shared;
d348 1
@


1.143
log
@simplify progressmeter calls to visit_and: we retrieve the state from the
progressmeter object
@
text
@d2 1
a2 1
# $OpenBSD: Delete.pm,v 1.142 2014/11/30 15:53:26 espie Exp $
d168 1
a168 1
	my $n = $self->fullname;
@


1.142
log
@missed some.
@
text
@d2 1
a2 1
# $OpenBSD: Delete.pm,v 1.141 2014/11/27 14:15:48 espie Exp $
d145 1
a145 1
		$state->progress->visit_with_size($plist, 'delete', $state);
@


1.141
log
@default for interactive should match non-interactive.
Pointed out by krw@@
@
text
@d2 1
a2 1
# $OpenBSD: Delete.pm,v 1.140 2014/11/25 14:16:15 espie Exp $
d97 1
a97 1
		if ($state->{interactive}) {
@


1.140
log
@minor clean-up: the stuff not to display is tied to the set, so make the
current_set more explicit in the PkgAdd algorithm...
and clean it up when we clean the set.

Put the "tieing files" stuff into its own function so that the add code
looks a bit less like a spaghetti monster
@
text
@d2 1
a2 1
# $OpenBSD: Delete.pm,v 1.139 2014/11/21 15:07:09 espie Exp $
d102 2
@


1.139
log
@a long time ago, DISPLAY and UNDISPLAY required special treatment, as they
were displayed "on the fly". But prepare+log means the display happens later
in any case, so they can be done as part of regular plist.

Also, mark known manpage dirs for even more verbiage reduction...
@
text
@d2 1
a2 1
# $OpenBSD: Delete.pm,v 1.138 2014/11/20 15:08:21 espie Exp $
d682 1
a682 1
	$state->{known_displays}{$self->{d}->key} = 1;
d691 1
a691 1
	if (!$state->{known_displays}{$self->{d}->key}) {
d701 1
a701 1
	$state->{knownmandirs}{$self->fullname} = 1;
@


1.138
log
@big trim-down of MESSAGE/UNMESSAGE: just match checksums between new packages
and old packages. Rationale being you don't need to display UNMESSAGE if the
new package has the exact same one. And likewise, you don't need to display
MESSAGE if the old package had the exact same one.
@
text
@d2 1
a2 1
# $OpenBSD: Delete.pm,v 1.137 2014/05/20 05:55:43 espie Exp $
a143 6
		if ($plist->has(UNDISPLAY)) {
			my $d = $plist->get(UNDISPLAY)->{d};
			if (!$state->{known_displays}{$$d}) {
				$plist->get(UNDISPLAY)->prepare($state);
			}
		}
d337 1
d676 27
@


1.137
log
@yet more code that no longer makes any sense
@
text
@d2 1
a2 1
# $OpenBSD: Delete.pm,v 1.136 2014/05/20 05:46:13 espie Exp $
d145 4
a148 1
			$plist->get(UNDISPLAY)->prepare($state);
@


1.136
log
@makewhatis being now external, it no longer requires picky/test/check_dir.
It also can't handle too many manpages at once (shell limit) so hand-feed
it (problem spotted by landry@@).

Some tests by schwarze@@.
@
text
@d2 1
a2 1
# $OpenBSD: Delete.pm,v 1.135 2014/04/18 10:00:48 schwarze Exp $
a47 3
	# fudge verbose for API differences
	my $v = $state->{v};
	$state->{v} = $state->verbose >= 2;
a56 1
	$state->{v} = $v;
@


1.135
log
@Switch to the new makewhatis(8)/apropos(1)/whatis(1) combo.
"commit the switch now" espie@@  "go for it" deraadt@@

See the apropos(1) manual for a description of what's new.
On machines where you want the full functionality,
run "sudo makewhatis" and put "MAKEWHATISARGS=' '" into weekly.local(8).
Otherwise, when upgrading via source, run "sudo makewhatis -Q".
@
text
@d2 1
a2 1
# $OpenBSD: Delete.pm,v 1.134 2014/03/18 18:53:29 espie Exp $
d57 1
a57 2
			$state->vsystem(OpenBSD::Paths->makewhatis,
			    '-u', $destdir.$k, '--', @@l);
@


1.134
log
@remove $_ usage that warns under perl 5.18
@
text
@d2 1
a2 1
# $OpenBSD: Delete.pm,v 1.133 2014/02/08 10:43:25 espie Exp $
a46 1
	require OpenBSD::Makewhatis;
d57 2
a58 7
			eval {
				OpenBSD::Makewhatis::remove($destdir.$k, \@@l,
				    $state);
			};
			if ($@@) {
				$state->errsay("Error in makewhatis: #1", $_);
			};
@


1.133
log
@fudge verbose state so that makewhatis is only verbose if pkg_add/delete -vv
or more.
@
text
@d2 1
a2 1
# $OpenBSD: Delete.pm,v 1.132 2014/02/06 16:55:01 espie Exp $
a603 1
			my $_;
@


1.132
log
@don't store full directory objects if they're not "special", just knowing
there's a directory that should stay around is enough.
shaves on the number of shared directories for shared items quite a lot.
@
text
@d2 1
a2 1
# $OpenBSD: Delete.pm,v 1.131 2014/02/03 16:13:13 espie Exp $
d49 3
d56 1
a56 2
			    $destdir.$k, join(' ', @@l))
				 if $state->verbose >= 2;
d58 4
a61 2
			eval { OpenBSD::Makewhatis::remove($destdir.$k, \@@l,
			    $state); };
d63 2
a64 2
				$state->errsay("Error in makewhatis: #1", $@@);
			}
d67 1
@


1.131
log
@gc old stuff that never fixed the problem it intended to fix :(
@
text
@d2 1
a2 1
# $OpenBSD: Delete.pm,v 1.130 2014/02/03 15:57:13 espie Exp $
d31 1
a31 1
	my $p = new OpenBSD::PackingList;
d222 1
a222 1
	$state->{dirs_okay}->{$dir} = 1;
d291 1
a291 1
	$recorder->{users}->{$self->name} = $pkgname;
d309 1
a309 1
	$recorder->{groups}->{$self->name} = $pkgname;
d334 9
d344 11
a354 1
	push(@@{$recorder->{dirs}->{$self->fullname}} , $self);
@


1.130
log
@store compact form of manpages.

fix a long standing stupid bug: can't store both deleted and added manpages in
the same hash, otherwise the first deletion is going to scrape already added
stuff. Ouchie.
@
text
@d2 1
a2 1
# $OpenBSD: Delete.pm,v 1.129 2014/01/30 13:23:51 espie Exp $
a317 2
	return unless $self->{noshadow};
	$state->{noshadow}{$fname} = 1;
@


1.129
log
@avoid storing dead keys.
quirks is exceptional, since it needs to be cached negatively.
@
text
@d2 1
a2 1
# $OpenBSD: Delete.pm,v 1.128 2014/01/30 12:38:20 espie Exp $
d45 1
a45 1
	return unless defined $state->{mandirs};
d49 2
a50 2
	while (my ($k, $v) = each %{$state->{mandirs}}) {
		my @@l = map { $destdir.$_ } @@$v;
d63 1
a63 1
	delete $state->{mandirs};
d147 1
a147 1
		$plist->register_manpage($state);
@


1.128
log
@finish killing old annotation
@
text
@d2 1
a2 1
# $OpenBSD: Delete.pm,v 1.127 2014/01/10 16:05:31 espie Exp $
d63 1
a63 1
	undef $state->{mandirs};
@


1.127
log
@by popular demand, remove excessive paranoia
@
text
@d2 1
a2 1
# $OpenBSD: Delete.pm,v 1.126 2014/01/09 20:20:01 espie Exp $
a69 5
	if ($plist->has('system-package')) {
		$state->{problems}++;
		$state->errsay("Error: can't delete system packages");
		return;
	}
@


1.126
log
@bump copyright to 2014
@
text
@d2 1
a2 1
# $OpenBSD: Delete.pm,v 1.125 2014/01/07 13:31:36 espie Exp $
a105 7
	}
	if ($plist->is_signed) {
		if (!$state->{quick}) {
			if (!$plist->check_signature($state)) {
				$state->fatal("package #1 was corrupted: signature check failed", $pkgname);
			}
		}
@


1.125
log
@tedu some very old checks: we no longer have INSTALL/UNINSTALL scripts,
so we don't care whether /var/db/pkg is mounted noexec.
@
text
@d2 1
a2 1
# $OpenBSD: Delete.pm,v 1.124 2014/01/05 10:24:30 espie Exp $
d4 1
a4 1
# Copyright (c) 2003-2007 Marc Espie <espie@@openbsd.org>
@


1.124
log
@have -DFW_UPDATE set @@option firmware on downloaded firmwares.
- normal pkg_add -u should ignore them
- pkg_delete will ask about deleting them

okay landry@@
@
text
@d2 1
a2 1
# $OpenBSD: Delete.pm,v 1.123 2014/01/02 16:05:42 espie Exp $
a485 3
	}
	if ($s->noexec && $self->exec_on_delete) {
		$s->report_noexec($state, $fname);
@


1.123
log
@zap PKG_PREFIX (undocumented and unused, now)
okay landry@@
@
text
@d2 1
a2 1
# $OpenBSD: Delete.pm,v 1.122 2013/12/30 09:02:37 espie Exp $
d111 8
@


1.122
log
@use replacing method (and not var)
@
text
@d2 1
a2 1
# $OpenBSD: Delete.pm,v 1.121 2013/12/25 14:38:15 espie Exp $
a149 1
	$ENV{'PKG_PREFIX'} = $plist->localbase;
@


1.121
log
@move the choice of signature type for checking into one single place
@
text
@d2 1
a2 1
# $OpenBSD: Delete.pm,v 1.120 2013/09/24 21:00:57 espie Exp $
d360 1
a360 1
	return !$state->{replacing};
d367 1
a367 1
	return $state->{replacing};
d456 1
a456 1
		if ($state->{replacing}) {
d524 1
a524 1
	my $action = $state->{replacing} ? "check" : "remove";
d622 1
a622 1
	if ($state->{replacing}) {
d641 1
a641 1
	return if $state->{replacing};
@


1.120
log
@missing number
@
text
@d2 1
a2 1
# $OpenBSD: Delete.pm,v 1.119 2012/01/16 08:42:38 schwarze Exp $
d109 1
a109 2
			require OpenBSD::x509;
			if (!OpenBSD::x509::check_signature($plist, $state)) {
@


1.119
log
@Backout activation of the new apropos(1)/whatis(1)/makewhatis(8).
In its current state, it causes too much slowdown, in particular
during system builds, and there are other regressions.
That cannot be fixed quickly while it's enabled.

Problems pointed out by espie@@, backout requested by deraadt@@,
diff "looks good" to espie@@.
@
text
@d2 1
a2 1
# $OpenBSD: Delete.pm,v 1.118 2012/01/05 23:03:57 schwarze Exp $
d193 1
a193 1
		$state->errsay("Bad rename #1 to #2: #", $n, $j, $!);
@


1.118
log
@Enable the new apropos(1), whatis(1), and makewhatis(8).
Unlink the old apropos(1), whatis(1), and makewhatis(8) from the build.
Call the new tools from pkg_create(1) and pkg_add(1).
"Please enable it now."  deraadt@@
@
text
@d2 1
a2 1
# $OpenBSD: Delete.pm,v 1.117 2011/09/17 15:33:56 schwarze Exp $
d47 1
d56 5
a60 2
			$state->vsystem(OpenBSD::Paths->makewhatis,
				'-u', $destdir.$k, '--', @@l);
@


1.117
log
@make pkg_add -nvv work with respect to whatis.db updates;
ok espie@@
@
text
@d2 1
a2 1
# $OpenBSD: Delete.pm,v 1.116 2011/08/23 10:32:27 espie Exp $
a46 1
	require OpenBSD::Makewhatis;
d55 2
a56 5
			eval { OpenBSD::Makewhatis::remove($destdir.$k, \@@l,
			    $state); };
			if ($@@) {
				$state->errsay("Error in makewhatis: #1", $@@);
			}
@


1.116
log
@zap old INSTALL/DEINSTALL stuff, it's been deprecated for 3 years, and removed
from pkg_create for over a year.
@
text
@d2 1
a2 1
# $OpenBSD: Delete.pm,v 1.115 2011/07/12 10:30:29 espie Exp $
d53 2
a54 1
			    $destdir.$k, join(@@l)) if $state->verbose >= 2;
@


1.115
log
@new pkg_delete, very similar to pkg_add, support for -a
@
text
@d2 1
a2 1
# $OpenBSD$
a667 8
}

package OpenBSD::PackingElement::FDEINSTALL;
sub delete
{
	my ($self, $state) = @@_;

	$self->run($state, "DEINSTALL");
@


1.114
log
@in an UpdateSet, match new files with old files based on their sha256.
avoid extracting again identical files, leading to less file system churn.
put in a few failsafes (size check) for people with fubar'd file
systems (hey oga@@).

The more often you update, the more you gain. Over 6 months, about one
out of five files doesn't change.

apparently, improves things a lot on slow fs, as said landry@@ and sthen@@.
tested by quite a few people.
@
text
@d2 1
a2 1
# $OpenBSD: Delete.pm,v 1.113 2011/01/23 06:56:53 espie Exp $
a121 2
	$state->{done}++;
	$state->progress->next($state->ntogo);
@


1.113
log
@hide details of "finish" inside PackingElement proper.
do the font dirs, also display a message for new installed rcscripts, and
if some stuff has been added to the readmes directory.
@
text
@d2 1
a2 1
# $OpenBSD: Delete.pm,v 1.112 2010/12/24 09:09:54 espie Exp $
d381 1
d383 1
a383 1
		$s = $state->vstat->remove_first($fname, $self->{size});
d385 1
a385 1
		$s = $state->vstat->remove($fname, $self->{size});
@


1.112
log
@move the handling of ldconfig to AddDelete::State
actually simplifies code a great deal. It's not as if trying to avoid
loading ten lines of code is a good idea.
@
text
@d2 1
a2 1
# $OpenBSD: Delete.pm,v 1.111 2010/12/24 09:04:14 espie Exp $
d271 10
@


1.111
log
@handle failures from ports tree with more care.
this does avoid infinite loops in case of wrong plists.
necessary since print-plist-with-depends CAN fail...
@
text
@d2 1
a2 1
# $OpenBSD$
d658 1
a658 1
	$self->mark_ldconfig_directory($state->{destdir});
@


1.110
log
@pass state around and use state->print
inspired by landry@@
@
text
@d2 1
a2 1
# $OpenBSD: Delete.pm,v 1.109 2010/10/27 14:35:56 espie Exp $
@


1.109
log
@initial scaffolding for @@rcscript: for now, acts like normal files,
but allow absolute pathnames (treat that as an implicit @@cwd).
@
text
@d2 1
a2 1
# $OpenBSD$
d95 1
a95 1
	$state->progress->message("reading plist");
d179 1
a179 1
	my $self = shift;
d187 1
a187 1
		print "Renaming old file $n to $j\n";
d194 1
a194 1
		print "Bad rename $n to $j: $!\n";
d448 1
a448 1
			$self->rename_file_to_temp;
@


1.108
log
@fix the qt 4.5 -> 4.6 update issue.
since we usually deal with directories in a global way, replacing a
directory with something else didn't work.
the fix is to record removed directories in Vstat in a "lazy" way:
we only test these objects for existence if we add something else at
the same location. Since this happens rarely, we can afford to perform
the whole SharedItems dance twice...
@
text
@d2 1
a2 1
# $OpenBSD: Delete.pm,v 1.107 2010/07/25 05:20:34 espie Exp $
@


1.107
log
@oops
@
text
@d2 1
a2 1
# $OpenBSD: Delete.pm,v 1.106 2010/07/24 10:49:01 espie Exp $
d314 1
a314 1
#	$state->vstat->remove_directory($fname);
d316 1
a316 1
	$state->{noshadow}->{$state->{destdir}.$self->fullname} = 1;
@


1.106
log
@pass state to Makewhatis. With new hooks in there, that means display
will integrate with pkg_add output (no more disturbed error messages
from wrong subject lines)
@
text
@d2 1
a2 1
# $OpenBSD: Delete.pm,v 1.105 2010/06/30 10:51:04 espie Exp $
d314 1
a314 1
	$state->vstat->remove_directory($fname);
@


1.105
log
@allow say and errsay to work without parameters, as it's ways common.
create verbose_system up in state, because it makes sense without verbose.
@
text
@d2 1
a2 1
# $OpenBSD$
d55 2
a56 1
			eval { OpenBSD::Makewhatis::remove($destdir.$k, \@@l); };
d313 2
@


1.104
log
@whitespace cleanup
@
text
@@


1.103
log
@replace confusing (n to go) message with #done/#total annotations.
e.g.,
Checking packages|No change in apr-util-mt-1.2.10p4 (26/1530)
@
text
@d2 1
a2 1
# $OpenBSD: Delete.pm,v 1.102 2010/06/09 07:26:01 espie Exp $
d52 1
a52 1
			$state->say("Removing manpages in #1: #2", 
d87 1
a87 1
	rmdir($dir) or 
d98 1
a98 1
		$state->fatal("package #1 is missing a \@@name in plist", 
d102 2
a103 2
		$state->fatal("Package real name #1 does not match #2", 
			$plist->pkgname, $pkgname); 
d388 1
a388 1
				$state->say("Symlink does not match: #1 (#2 vs. #3)", 
d590 2
a591 2
			$state->say("Shell #1 removed from #2", 
			    $fullname, $destdir.OpenBSD::Paths->shells) 
@


1.102
log
@ui changes: go thru a state object for most printouts
@
text
@d2 1
a2 1
# $OpenBSD: Delete.pm,v 1.101 2010/06/04 13:19:39 espie Exp $
d121 1
a121 1
	$state->{todo}--;
@


1.101
log
@move code around, so that commands can be used as modules.
pkg becomes the start hub, which does nothing except require the
correct module.
Saner code wrt Add/Delete, and more sharing.
@
text
@d2 1
a2 1
# $OpenBSD$
d52 2
a53 1
			$state->say("Removing manpages in $destdir$k: ", join(@@l)) if $state->verbose >= 2;
d57 1
a57 1
				$state->errsay("Error in makewhatis: $@@");
d78 1
a78 1
	my $plist = shift;
d87 2
a88 1
	rmdir($dir) or Fatal "Can't finish removing directory $dir: $!";
d96 1
a96 1
	    Fatal "Bad package";
d98 2
a99 1
		Fatal "Package $pkgname has no name";
d102 2
a103 1
		Fatal "Package $pkgname real name does not match";
d109 1
a109 1
				Fatal "Package $pkgname is corrupted";
d116 1
a116 1
	Fatal "fatal issues in deinstalling $pkgname"
d133 1
a133 1
		$state->say("remove dependency on $name")
d165 1
a165 1
	    $state->log("Files kept as $borked package\n");
d170 1
a170 1
	remove_packing_info($plist);
d278 1
a278 1
		$state->say("rmuser: ", $self->name);
d296 1
a296 1
		$state->say("rmgroup: ", $self->name);
d321 1
a321 1
		$state->say("rmdir: ", $self->fullname);
d388 2
a389 1
				$state->say("Symlink does not match: $realname ($contents vs. ", $self->{symlink},")");
d394 1
a394 1
			$state->say("Bogus symlink: $realname");
d400 1
a400 1
				$state->say("Unexpected symlink: $realname");
d404 1
a404 1
				$state->say("File $realname does not exist");
d409 4
a412 5
					$state->say("Problem: ",
					    $self->fullname,
					    " does not have a checksum\n",
					    "NOT deleting: $realname");
					$state->log("Couldn't delete $realname (no checksum)\n");
d418 4
a421 4
					$state->say("Problem: checksum doesn't match for ",
					    $self->fullname, "\n",
					    "NOT deleting: $realname");
					$state->log("Couldn't delete $realname (bad checksum)\n");
d429 1
a429 1
		$state->say("deleting: $realname");
d433 2
a434 2
		$state->say("Problem deleting $realname");
		$state->log("deleting $realname failed: $!\n");
d510 1
a510 1
		Fatal "\@@sample element does not reference a valid file\n";
d515 1
a515 1
		$state->log("File $realname does not exist\n");
d519 1
a519 1
		$state->log("File $realname is not a file\n");
d524 1
a524 1
		$state->log("Couldn't delete $realname (no checksum)\n");
d531 1
a531 1
			$state->log("You should also $action $realname\n");
d537 1
a537 1
			$state->say("File $realname identical to sample") if $state->verbose >= 2;
d541 1
a541 1
				$state->log("You should also $action $realname (which was modified)\n");
d546 1
a546 1
	$state->say("deleting $realname") if $state->verbose >= 2;
d549 2
a550 2
		$state->say("Problem deleting $realname");
		$state->log("deleting $realname failed: $!\n");
d590 3
a592 2
			$state->say("Shell $fullname removed from $destdir",
			    OpenBSD::Paths->shells) if $state->verbose;
d606 1
a606 1
		$state->say("deleting extra file: $realname");
d611 1
a611 1
		$state->log("Remember to update $realname\n");
d615 1
a615 1
		    $state->say("problem deleting extra file $realname");
d617 1
a617 1
		$state->log("You should also remove $realname\n");
d633 1
a633 1
		$state->log("You should also remove the directory $realname\n");
d646 1
a646 1
		$state->log("You should also run ", $self->{expanded}, "\n");
@


1.100
log
@whitespace fixes
@
text
@@


1.99
log
@typo
@
text
@d2 1
a2 1
# $OpenBSD: Delete.pm,v 1.98 2010/04/05 13:46:24 espie Exp $
d129 1
a129 1
		$state->say("remove dependency on $name") 
d132 1
a132 1
		try { 
d140 1
a140 1
		
d156 1
a156 1
 
d164 1
a164 1
			
d342 2
a343 2
sub should_run 
{ 
d349 2
a350 2
sub should_run 
{ 
d404 1
a404 1
					$state->say("Problem: ", 
d411 1
a411 1
				my $d = $self->compute_digest($realname, 
d549 1
a549 1
		
d559 1
a559 1
	    $state->vsystem(OpenBSD::Paths->install_info, 
d609 1
a609 1
		unlink($realname) or 
@


1.98
log
@clean-up validate_plists a bit, so that it starts with a clean state.
new feature: if a normal updateset order does not fit, let the user decide
to do a "dangerous update", by deleting older packages first (if they fit).
tweak really_add to do so: move delete old packages out of the way, and add
a new state variable (extracted_first) to distinguish between both replace
modes.
@
text
@d2 1
a2 1
# $OpenBSD$
d450 1
a450 1
sub prepare_for_deletetion
@


1.97
log
@clean up the ProgressMeter code, create a specific class if a Term
is around.
start using stuff from termcap, specifically, cleareol, and move to hp.
use the full line when we can, cram 100% if we can.
(this should flicker much less on slow terminals).

clean-up the install-and-progress bits to be in progressmeter, this removes
some code.

have pkg_create follow the same pattern as the others, with a state.
This allows us to unify error messages a bit.
@
text
@d363 6
a368 1
	my $s = $state->vstat->remove($fname, $self->{size});
@


1.96
log
@fully encapsulate dev objects from vstat so I can change the internals
completely.
@
text
@a111 1
	$plist->compute_size;
a144 2
	my $totsize = $plist->{totsize};
	my $donesize = 0;
d151 1
a151 2
		$state->progress->show(0, $totsize);
		$plist->delete_and_progress($state, \$donesize, $totsize);
a198 7
}

sub delete_and_progress
{
	my ($self, $state, $donesize, $totsize) = @@_;
	$self->delete($state);
	$self->mark_progress($state->progress, $donesize, $totsize);
@


1.95
log
@erase Requiring entirely while deleting, to avoid further issues.

if size_only, don't even pretend to delete the list (ways faster, no checksum
checks)
@
text
@d376 1
a376 1
	if ($s->{ro}) {
d467 1
a467 1
	if ($s->{ro}) {
d470 1
a470 1
	if ($s->{noexec} && $self->exec_on_delete) {
@


1.94
log
@change verbosity handling: be silent by default, turn on the first level if -v.
Add more levels, specifically, lots of info regarding individual files only
visible if -vvvvv.
Make -n display the same stuff as normal (need -n -v to display more stuff).
Introduce -s, "size-only", turns on -n and does skip any extraction.
Sprinkle handlers for SIG_INFO, not really nice yet.

Note that -n is non functional for complex updates, because of caching
issues I have to fix.
@
text
@d127 1
d129 1
a129 1
	for my $name (OpenBSD::Requiring->new($pkgname)->list) {
d139 1
d151 8
a158 6
	$plist->register_manpage($state);
	manpages_unindex($state);
	$state->progress->show(0, $totsize);
	$plist->delete_and_progress($state, \$donesize, $totsize);
	if ($plist->has(UNDISPLAY)) {
		$plist->get(UNDISPLAY)->prepare($state);
a160 1

@


1.93
log
@be slightly more paranoid about shell stuff we run.
@
text
@d2 1
a2 1
# $OpenBSD: Delete.pm,v 1.92 2009/12/17 08:21:09 espie Exp $
d52 1
a52 1
			$state->say("Removing manpages in $destdir$k: ", join(@@l)) if $state->{verbose};
d130 1
a130 1
		    if $state->{very_verbose} or $state->{not};
d281 1
a281 1
	if ($state->{beverbose}) {
d299 1
a299 1
	if ($state->{beverbose}) {
d324 1
a324 1
	if ($state->{very_verbose}) {
d427 1
a427 1
	if ($state->{very_verbose}) {
d536 1
a536 1
			$state->say("File $realname identical to sample") if $state->{not} or $state->{verbose};
d545 1
a546 1
	$state->say("deleting $realname") if $state->{verbose};
d590 1
a590 1
			    OpenBSD::Paths->shells);
d603 1
a603 1
	if ($state->{beverbose} && $state->{extra}) {
@


1.92
log
@display progressmeter at 0% at start of install/deinstall.
(better synch for packages that start with a huge binary)
@
text
@d2 1
a2 1
# $OpenBSD$
d563 1
a563 1
		"--delete", "--info-dir=".dirname($fullname), $fullname);
@


1.91
log
@fuss about install msgs: new method state->ntogo, use it to annotate more
messages with global progress information.

Also, when not finding a suitable update, report it if set is not a simple
update. Helps in figuring out cases like gstreamer...
@
text
@d151 1
@


1.90
log
@fix off-by-one, noticed by frantisek holop
@
text
@d118 2
a119 1
	$state->progress->next($state->{todo}-1);
@


1.89
log
@add (n to go) to pkg_delete as well.
@
text
@d118 1
a118 1
	$state->progress->next($state->{todo});
@


1.88
log
@create a pseudo vstat object inside state, so that we can modify Vstat
interface very locally...

model hints objects like Locations, to uniformize further treatment.
@
text
@d118 1
a118 1
	$state->progress->next;
@


1.87
log
@vsystem, system, unlink can mostly go through state, and do the ->clear part
as well.
@
text
@a22 1
use OpenBSD::Vstat;
d115 1
a115 1
	OpenBSD::Vstat::synchronize();
a362 1
use OpenBSD::Vstat;
d369 1
a369 1
	my $s = OpenBSD::Vstat::remove($fname, $self->{size});
d460 1
a460 1
	my $s = OpenBSD::Vstat::remove($fname, $self->{size});
@


1.86
log
@also get most STDERR messages through the same way
@
text
@d562 1
a562 2
	    VSystem($state->{very_verbose}, 
		OpenBSD::Paths->install_info, 
@


1.85
log
@progressmeter puts STDOUT in autoflush if -t, so that it can display to it instead of piping a lot of stuff to STDERR.

Go through state->print for most messages, so they will NOT do weird things
with the progressmeter.
Use a ->say shortcut which does the same thing that perl 5.10 say does...
@
text
@d57 1
a57 1
				print STDERR "Error in makewhatis: $@@\n";
d70 1
a70 1
		print STDERR "Error: can't delete system packages\n";
d135 1
a135 1
			print STDERR "$_\n";
@


1.84
log
@remove forwarders, and provide a sensible API that says what's going on
(e.g., we're logging information for later).
@
text
@d53 1
a53 1
			print "Removing manpages in $destdir$k: ", join(@@l), "\n" if $state->{verbose};
d129 1
a129 1
		print "remove dependency on $name\n" 
d281 1
a281 1
		print "rmuser: ", $self->name, "\n";
d299 1
a299 1
		print "rmgroup: ", $self->name, "\n";
d324 1
a324 1
		print "rmdir: ", $self->fullname, "\n";
d387 1
a387 1
				print "Symlink does not match: $realname ($contents vs. ", $self->{symlink},")\n";
d392 1
a392 1
			print "Bogus symlink: $realname\n";
d398 1
a398 1
				print "Unexpected symlink: $realname\n";
d402 1
a402 1
				print "File $realname does not exist\n";
d407 4
a410 3
					print "Problem: ", $self->fullname,
					    " does not have a checksum\n";
					print "NOT deleting: $realname\n";
d417 3
a419 3
					print "Problem: checksum doesn't match for ",
						$self->fullname, "\n";
					print "NOT deleting: $realname\n";
d428 1
a428 1
		print "deleting: $realname\n";
d432 1
a432 1
		print "Problem deleting $realname\n";
d536 1
a536 1
			print "File $realname identical to sample\n" if $state->{not} or $state->{verbose};
d546 1
a546 1
	print "deleting $realname\n" if $state->{verbose};
d548 1
a548 1
		print "Problem deleting $realname\n";
d590 2
a591 2
			print "Shell $fullname removed from $destdir",
			    OpenBSD::Paths->shells, "\n";
d605 1
a605 1
		print "deleting extra file: $realname\n";
d614 1
a614 1
		    print "problem deleting extra file $realname\n";
@


1.83
log
@bad espie: use strict/warnings consistently, and fix two nits and two
actual errors !
@
text
@d161 1
a161 1
	    $state->print("Files kept as $borked package\n");
d410 1
a410 1
					$state->print("Couldn't delete $realname (no checksum)\n");
d419 1
a419 1
					$state->print("Couldn't delete $realname (bad checksum)\n");
d432 1
a432 1
		$state->print("deleting $realname failed: $!\n");
d513 1
a513 1
		$state->print("File $realname does not exist\n");
d517 1
a517 1
		$state->print("File $realname is not a file\n");
d522 1
a522 1
		$state->print("Couldn't delete $realname (no checksum)\n");
d529 1
a529 1
			$state->print("You should also $action $realname\n");
d539 1
a539 1
				$state->print("You should also $action $realname (which was modified)\n");
d548 1
a548 1
		$state->print("deleting $realname failed: $!\n");
d609 1
a609 1
		$state->print("Remember to update $realname\n");
d615 1
a615 1
		$state->print("You should also remove $realname\n");
d631 1
a631 1
		$state->print("You should also remove the directory $realname\n");
d644 1
a644 1
		$state->print("You should also run ", $self->{expanded}, "\n");
@


1.82
log
@overlay extract/delete/install messages, for shorter reports in normal mode
@
text
@d20 1
@


1.81
log
@synch with my new style search/location changes
It's likely there will be some fallout, but it's getting a bit too large
to keep around.
This does kill a few very old oddities as well.
@
text
@d118 1
a150 1
	$state->progress->next;
@


1.80
log
@don't copy DigitalSig to partial packages, it makes no sense
@
text
@d182 1
a182 1
		if ($self->{name} !~ m/^\//o && $self->cwd ne '.') {
d186 1
a186 1
		$self->{name} = $j;
d280 1
a280 1
		print "rmuser: $self->{name}\n";
d289 1
a289 1
	$recorder->{users}->{$self->{name}} = $pkgname;
d298 1
a298 1
		print "rmgroup: $self->{name}\n";
d307 1
a307 1
	$recorder->{groups}->{$self->{name}} = $pkgname;
@


1.79
log
@initial implementation of package signatures, based on x509 certificates and
smime detached signatures.
@
text
@d481 5
@


1.78
log
@Say goodbye to local $_
lexical scoping is so much neater (courtesy of perl 5.10)
@
text
@d101 8
@


1.77
log
@turn the checksums stored in packing elements into real objects, so that
pkg_add becomes mostly independent of the type of checksum stored.

separate md5 into an abstract OpenBSD::digest class and an md5 subclass
with specific methods to compute checksums and serialize results, and create
an sha class that does the same thing with sha256 (with a base64 serializer)
@
text
@d563 1
a563 1
			local $_;
@


1.76
log
@defer to the packing element for computing md5
@
text
@d2 1
a2 1
# $OpenBSD: Delete.pm,v 1.75 2008/03/11 08:46:14 espie Exp $
d246 2
a247 1
	delete $self->{md5};
d252 1
a252 1
		$self->{md5} = $self->compute_md5($realname);
d397 1
a397 1
				if (!defined $self->{md5}) {
d404 3
a406 2
				my $md5 = $self->compute_md5($realname);
				if ($md5 ne $self->{md5}) {
d507 1
a507 1
	if (!defined $orig->{md5}) {
d519 2
a520 2
		my $md5 = $self->compute_md5($realname);
		if ($md5 eq $orig->{md5}) {
@


1.75
log
@oops
@
text
@d2 1
a2 1
# $OpenBSD$
d251 1
a251 1
		$self->{md5} = OpenBSD::md5::fromfile($realname);
a352 1
use OpenBSD::md5;
d403 1
a403 1
				my $md5 = OpenBSD::md5::fromfile($realname);
a481 1
use OpenBSD::md5;
d517 1
a517 1
		my $md5 = OpenBSD::md5::fromfile($realname);
@


1.74
log
@better -q: mention once, and it speeds up (assumes normal files haven't
changed), but still checks config files. Use twice, and wipe your config
out as well.
@
text
@d512 1
a512 1
	if ($state->{quick} >= 2) {
@


1.73
log
@tweak messages mentioning checksums so that they mention checksums, not
specifics like md5, since that's likely to change.
@
text
@d512 1
a512 1
	if ($state->{quick}) {
@


1.72
log
@fix utterly confusing message for updates.
okay bernd@@/deraadt@@
@
text
@d399 1
a399 1
					    " does not have an md5 checksum\n";
d401 1
a401 1
					$state->print("Couldn't delete $realname (no md5)\n");
d406 1
a406 1
					print "Problem: md5 doesn't match for ",
d409 1
a409 1
					$state->print("Couldn't delete $realname (bad md5)\n");
d508 1
a508 1
		$state->print("Couldn't delete $realname (no md5)\n");
@


1.71
log
@fix saving of old partial packages... problem noticed by Paul Irofti
@
text
@d2 1
a2 1
# $OpenBSD: Delete.pm,v 1.70 2007/06/25 09:30:16 espie Exp $
d496 1
d515 1
a515 1
			$state->print("You should also remove $realname\n");
d525 1
a525 1
				$state->print("You should also remove $realname (which was modified)\n");
@


1.70
log
@typo
@
text
@d2 1
a2 1
# $OpenBSD: Delete.pm,v 1.69 2007/06/18 10:47:03 espie Exp $
a27 21
sub rename_file_to_temp
{
	my $i = shift;
	require OpenBSD::Temp;

	my $n = $i->fullname;

	my ($fh, $j) = OpenBSD::Temp::permanent_file(undef, $n);
	close $fh;
	if (rename($n, $j)) {
		print "Renaming old file $n to $j\n";
		if ($i->{name} !~ m/^\//o && $i->cwd ne '.') {
			my $c = $i->cwd;
			$j =~ s|^\Q$c\E/||;
		}
		$i->{name} = $j;
	} else {
		print "Bad rename $n to $j: $!\n";
	}
}

d163 21
d433 1
a433 1
			rename_file_to_temp($self);
@


1.69
log
@add tag no shadow, to allow us to specify that we do NOT want tempfiles
into some directories.

a few minor style tweaks, such as using a nice join(map()) to build some
strings.
@
text
@d2 1
a2 1
# $OpenBSD: Delete.pm,v 1.68 2007/06/16 11:50:49 espie Exp $
d306 1
a306 1
	$state->{noshadow}->{$self->{destdir}.$self->fullname} = 1;
@


1.68
log
@Add variation on exec/unexec:
@@exec-always         @@unexec-always
@@exec-add            @@unexec-delete
@@exec-update         @@unexec-update

with the obvious semantics that *update are only run during updates,
and *add/delete are only run during `pure' additions/removals.

This should solve the problem of those packages that `lose' manual
configuration when you update them (e.g., all the mod_xxx apache stuff
and postfix).

caveat: you will need to go through one finaly broken update before the
new stuff kicks in.
@
text
@d2 1
a2 1
# $OpenBSD: Delete.pm,v 1.67 2007/06/16 09:29:37 espie Exp $
d302 7
@


1.67
log
@use OpenBSD::Paths contents
@
text
@d2 1
a2 1
# $OpenBSD: Delete.pm,v 1.66 2007/06/14 09:29:32 espie Exp $
d324 19
a342 1
	$self->run($state);
@


1.66
log
@I don't know what we will do with system packages yet, but prevent
them from getting deleted.
@
text
@d2 1
a2 1
# $OpenBSD: Delete.pm,v 1.65 2007/06/06 15:35:20 espie Exp $
d25 1
d522 2
a523 1
	    "install-info", "--delete", "--info-dir=".dirname($fullname), $fullname);
d536 1
a536 1
		if (open(my $shells, '<', $destdir.'/etc/shells')) {
d546 1
a546 1
			open(my $shells2, '>', $destdir.'/etc/shells');
d549 2
a550 1
			print "Shell $fullname removed from $destdir/etc/shells\n";
@


1.65
log
@finish moving the size computations out of validate_plist.
@
text
@d2 1
a2 1
# $OpenBSD: Delete.pm,v 1.64 2007/06/06 15:31:06 espie Exp $
d87 5
@


1.64
log
@separate the size computation from other operations in `prepare_for_addition'
`prepare_for_deletion' -> move that to Vstat, as it is common code.
Do the splitting of libraries through a deep copy and shallow copy, so that
we keep any State information related to libraries (like special group/owners).
@
text
@d2 1
a2 1
# $OpenBSD: Delete.pm,v 1.63 2007/06/06 12:32:09 espie Exp $
a87 1
	return $plist->compute_size;
d119 1
@


1.63
log
@tweak how copies happen: rename make_copy into make_shallow_copy,
make_deep_copy.

tweak keep_old_files so that we set the pkgname later, when it won't
cause any error to have duplicates in there.
@
text
@d2 1
a2 1
# $OpenBSD: Delete.pm,v 1.62 2007/06/04 14:42:19 espie Exp $
a86 1
	$state->{totsize} = 0;
d88 1
a88 2
	$state->{totsize} = 1 if $state->{totsize} == 0;
	$plist->{totsize} = $state->{totsize};
a330 1
	$state->{totsize} += $self->{size} if defined $self->{size};
@


1.62
log
@zap dead code: we no longer use DirRm.
stop recognizing @@comment MD5: as special.
@
text
@d2 1
a2 1
# $OpenBSD: Delete.pm,v 1.61 2007/06/04 14:40:39 espie Exp $
a52 1
	$p->set_pkgname($borked);
d57 1
a432 5
sub copy_old_stuff
{
}

package OpenBSD::PackingElement::Name;
@


1.61
log
@some minor systematic changes.
- mark all regexps I can with /o if they can be compiled once.
- turn $o->method() into $o->method
- remove unneeded prototypes
- reduce split /re/ into split "string" where possible.
@
text
@d2 1
a2 1
# $OpenBSD: Delete.pm,v 1.60 2007/06/04 10:58:23 espie Exp $
a313 6
}

package OpenBSD::PackingElement::DirRm;
sub delete
{
	&OpenBSD::PackingElement::DirBase::delete;
@


1.60
log
@fix keep_old_files
@
text
@d2 1
a2 1
# $OpenBSD: Delete.pm,v 1.59 2007/06/02 10:32:31 espie Exp $
d38 1
a38 1
		if ($i->{name} !~ m|^/| && $i->cwd ne '.') {
d376 1
a376 1
					print "Problem: ", $self->fullname(),
d547 1
a547 1
				s/^\#.*//;
@


1.59
log
@move dependency registration into its own function.
@
text
@d2 1
a2 1
# $OpenBSD: Delete.pm,v 1.58 2007/06/01 14:58:29 espie Exp $
d439 5
@


1.58
log
@refactor ProgressMeter code to create objects, put these into state.
Create a common state class for delete and add, put the progressmeter
creation in there.

neat effect: we don't have a progressmeter, we use a stub class instead
and *never* pull the code in at all.
@
text
@d2 1
a2 1
# $OpenBSD: Delete.pm,v 1.57 2007/05/31 13:33:17 espie Exp $
d129 18
d165 1
a165 11
	for my $name (OpenBSD::Requiring->new($pkgname)->list) {
		print "remove dependency on $name\n" 
		    if $state->{very_verbose} or $state->{not};
		local $@@;
		try { 
			OpenBSD::RequiredBy->new($name)->delete($pkgname);
		} catchall {
			print STDERR "$_\n";
		};
	}
		
@


1.57
log
@move set validation earlier (in fact, it probably doesn't belong in
really_add).

move common delete_installed() code inside Delete.pm
@
text
@d2 1
a2 1
# $OpenBSD: Delete.pm,v 1.56 2007/05/31 11:05:41 espie Exp $
d110 1
a110 1
	OpenBSD::ProgressMeter::message("reading plist");
d141 1
a141 1
	OpenBSD::ProgressMeter::next();
d184 1
a184 1
	$self->mark_progress($donesize, $totsize);
@


1.56
log
@kill REQ script directly. I'm pretty sure it doesn't quite work anyways.
Deprecate INSTALL and DEINSTALL, write out warnings in pkg_create.

Clean up some more old cruft
@
text
@d2 1
a2 1
# $OpenBSD: Delete.pm,v 1.55 2007/05/31 10:00:22 espie Exp $
d167 1
@


1.55
log
@a few cosmetic changes, move realname over to PackingElement to be
able to use it in other cases.
@
text
@d2 1
a2 1
# $OpenBSD: Delete.pm,v 1.54 2007/05/30 16:32:14 espie Exp $
a605 8
}

package OpenBSD::PackingElement::FREQUIRE;
sub delete
{
	my ($self, $state) = @@_;

	$self->run($state, "DEINSTALL");
@


1.54
log
@simplify script handling a bit (they're going to disappear probably anyways).

Remove two passes visitors, we don't use them.
@
text
@d2 1
a2 1
# $OpenBSD: Delete.pm,v 1.53 2007/05/30 14:04:51 espie Exp $
d32 1
a32 1
	my $n = $i->fullname();
d38 2
a39 2
		if ($i->{name} !~ m|^/| && $i->cwd() ne '.') {
			my $c = $i->cwd();
d220 1
a220 12
	$self->mark_directory($state, dirname($self->fullname()));
}

sub realname
{
	my ($self, $state) = @@_;

	my $name = $self->fullname;
	if (defined $self->{tempname}) {
		$name = $self->{tempname};
	}
	return $state->{destdir}.$name;
d294 1
a294 1
		print "dirrm: ", $self->fullname, "\n";
d415 1
a415 1
	my $fname = installed_info($pkgname).$self->{name};
d514 1
a514 1
	    my $fullname = $state->{destdir}.$self->fullname();
@


1.53
log
@simplify really_add to use real visitors for extraction and installation.
Just do one single try {} catchall {} per-method, as this is enough.

New methods: extract_and_progress, install_and_progress, that catch
interrupts (die) deal with fake, and handle the progress meter.
One single method: mark_progress, can be used for extraction, installation
and deletion.
@
text
@d2 1
a2 1
# $OpenBSD: Delete.pm,v 1.52 2007/05/30 12:30:15 espie Exp $
d134 1
a137 6
	if ($plist->has(REQUIRE)) {
		$plist->get(REQUIRE)->delete($state);
	}
	if ($plist->has(DEINSTALL)) {
		$plist->get(DEINSTALL)->delete($state);
	} 
d140 1
a140 6
	my $donesize = 0;
	for my $item (@@{$plist->{groups}}, @@{$plist->{users}}, @@{$plist->{items}}) {
		$item->delete($state);
		$item->mark_progress(\$donesize, $totsize);
	}

d145 1
d177 7
@


1.52
log
@don't bother not copying the pkgname, we're going to overwrite it anyways.
@
text
@d2 1
a2 1
# $OpenBSD: Delete.pm,v 1.51 2007/05/30 11:13:04 espie Exp $
d148 1
a148 4
		if (defined $item->{size}) {
                        $donesize += $item->{size};
                        OpenBSD::ProgressMeter::show($donesize, $totsize);
                }
@


1.51
log
@redo keep_old_files as a visitor. Copy more stuff over.
@
text
@d2 1
a2 1
# $OpenBSD: Delete.pm,v 1.50 2007/05/29 14:39:03 espie Exp $
d53 1
a53 1
	OpenBSD::PackingElement::Name->add($p, $borked);
a454 5
}

package OpenBSD::PackingElement::Name;
sub copy_old_stuff
{
@


1.50
log
@rely on packing-lists knowing where they live, much saner.
@
text
@d2 1
a2 1
# $OpenBSD: Delete.pm,v 1.49 2007/05/28 13:00:05 espie Exp $
a51 19
	for my $i (qw(cvstags no-default-conflict conflict) ) {
		if (defined $plist->{$i}) {
			$p->{$i} = $plist->{$i};
		}
	}
	for my $i (@@{$plist->{items}}) {
		if ($i->isa("OpenBSD::PackingElement::Cwd")) {
			push(@@{$p->{items}}, $i);
			next;
		}
		next unless $i->IsFile;
		if (defined $i->{stillaround}) {
			delete $i->{stillaround};
			if ($state->{replacing}) {
				rename_file_to_temp($i);
			}
			push(@@{$p->{items}}, $i);
		}
	}
d54 1
a54 2
	$p->{name}->{name} = $borked;
	$p->set_info(installed_info($borked));
a55 1
	require File::Copy;
d57 1
a57 2
	File::Copy::copy($plist->infodir.COMMENT, $p->infodir);
	File::Copy::copy($plist->infodir.DESC, $p->infodir);
d195 12
d411 13
d446 26
d643 8
@


1.49
log
@delay error reporting a bit more: try installing and deinstalling everything
and report more issues.
@
text
@d2 1
a2 1
# $OpenBSD: Delete.pm,v 1.48 2007/05/28 12:16:55 espie Exp $
d50 1
a50 1
	my ($state, $plist, $dir) = @@_;
d74 2
a75 2
	my $dest = installed_info($borked);
	mkdir($dest);
d78 2
a79 2
	File::Copy::copy($dir.COMMENT, $dest);
	File::Copy::copy($dir.DESC, $dest);
d117 3
a119 1
	my $dir = shift;
a157 2
	my $dir = installed_info($pkgname);
	$state->{dir} = $dir;
d194 1
a194 1
	    my $borked = keep_old_files($state, $plist, $dir);
d200 1
a200 1
	remove_packing_info($dir);
@


1.48
log
@lift up more of the dev checking code into Vstat.
un-special case SpecialFiles on deletion. Now that CONTENTS is part of the
plist, it's checked as well on addition.
@
text
@d2 1
a2 1
# $OpenBSD: Delete.pm,v 1.47 2007/05/28 11:15:11 espie Exp $
a108 1
	$state->{problems} = 0;
a110 2
	Fatal "fatal issues in deinstalling ", $plist->pkgname 
	    if $state->{problems};
d140 1
d142 2
@


1.47
log
@clean up packing-list validation, call the methods `prepare_for_addition'
and `prepare_for_deletion', that's clearer...
@
text
@d2 1
a2 1
# $OpenBSD: Delete.pm,v 1.46 2007/05/22 11:02:57 espie Exp $
d111 1
a111 14
	$plist->prepare_for_deletion($state);
	my $dir = installed_info($plist->pkgname);
	for my $i (info_names()) {
		my $fname = $dir.$i;
		if (-e $fname) {
			my $size = (stat _)[7];
			my $s = OpenBSD::Vstat::remove($fname, $size);
			next unless defined $s;
			if ($s->{ro}) {
				Warn "Error: ", $s->{dev}, " is read-only ($fname)\n";
				$state->{problems}++;
			}
		}
	}
d353 1
a353 1
	my ($self, $state) = @@_;
d360 1
a360 8
		if ($state->{very_verbose} or ++($s->{problems}) < 4) {
			Warn "Error: ", $s->{dev}, 
			    " is read-only ($fname)\n";
		} elsif ($s->{problems} == 4) {
			Warn "Error: ... more files can't be removed from ",
				$s->{dev}, "\n";
		}
		$state->{problems}++;
d418 22
@


1.46
log
@zap references to pkgdep. Packing-Lists no longer even record it, anyways.
@
text
@d2 1
a2 1
# $OpenBSD: Delete.pm,v 1.45 2007/05/22 10:11:59 espie Exp $
d105 1
a105 1
sub validate_plist($$)
a108 1
	my $destdir = $state->{destdir};
d125 2
a126 1
	Fatal "fatal issues" if $state->{problems};
@


1.45
log
@introduce a SharedItemsRecorder (put it into Vstat, since that's a file
common to Add and Delete, for now).

Use it to have common code that records items to remove / items remaining.

Stash it into pkg_add/pkg_delete state, and abstract the cleaning up
operation into the SharedItemsRecorder (so that pkg_add and pkg_delete no
longer have to know about the internals of SharedItems at all).
@
text
@d2 1
a2 1
# $OpenBSD: Delete.pm,v 1.44 2007/05/22 09:39:23 espie Exp $
d194 1
a194 7
	# guard against duplicate pkgdep
	my $removed = {};

	my $zap_dependency = sub {
		my $name = shift;

		return if defined $removed->{$name};
a202 8
		$removed->{$name} = 1;
	};

	for my $item (@@{$plist->{pkgdep}}) {
		&$zap_dependency($item->{name});
	}
	for my $name (OpenBSD::Requiring->new($pkgname)->list) {
		&$zap_dependency($name);
@


1.44
log
@mark `digitalsignature' as a known keyword, which helps me.
Use autovivification on stuff to remove.
@
text
@d2 1
a2 1
# $OpenBSD: Delete.pm,v 1.43 2007/05/15 09:32:18 espie Exp $
d240 4
a309 2
	my $name = $self->{name};

d311 1
a311 1
		print "rmuser: $name\n";
d314 7
a320 1
	$state->{users_to_rm}->{$name} = $state->{pkgname};
a327 2
	my $name = $self->{name};

d329 1
a329 1
		print "rmgroup: $name\n";
d332 7
a338 1
	$state->{groups_to_rm}->{$name} = $state->{pkgname};
a345 2
	my $name = $self->fullname;

d347 1
a347 1
		print "dirrm: $name\n";
d350 8
a357 2
	$self->{pkgname} = $state->{pkgname};
	push(@@{$state->{dirs_to_rm}->{$name}}, $self);
@


1.43
log
@do not copy pkgname, since we're going to erase it, and packing-lists
now detect duplicate stuff.
@
text
@d2 1
a2 1
# $OpenBSD: Delete.pm,v 1.42 2007/05/14 09:49:27 espie Exp $
d312 1
a312 4
	$state->{users_to_rm} = {} unless defined $state->{users_to_rm};

	my $h = $state->{users_to_rm};
	$h->{$name} = $state->{pkgname};
d326 1
a326 4
	$state->{groups_to_rm} = {} unless defined $state->{groups_to_rm};

	my $h = $state->{groups_to_rm};
	$h->{$name} = $state->{pkgname};
a339 4
	$state->{dirs_to_rm} = {} unless defined $state->{dirs_to_rm};

	my $h = $state->{dirs_to_rm};
	$h->{$name} = [] unless defined $h->{$name};
d341 1
a341 1
	push(@@{$h->{$name}}, $self);
@


1.42
log
@tidy
@
text
@d2 1
a2 1
# $OpenBSD: Delete.pm,v 1.41 2007/05/07 09:32:51 espie Exp $
d52 1
a52 1
	for my $i (qw(cvstags name no-default-conflict conflict) ) {
@


1.41
log
@make sure all temporary file handling goes through OpenBSD::Temp
@
text
@d2 1
a2 1
# $OpenBSD: Delete.pm,v 1.40 2007/05/07 08:34:09 espie Exp $
d215 1
a215 1
	for my $name (OpenBSD::Requiring->new($pkgname)->list()) {
@


1.40
log
@name code from keep_old_files, don't set pkgname directly.
@
text
@d2 1
a2 1
# $OpenBSD: Delete.pm,v 1.39 2007/05/07 08:24:16 espie Exp $
d30 1
a30 1
	require File::Temp;
d34 1
a34 1
	my ($fh, $j) = File::Temp::mkstemp("$n.XXXXXXXX");
@


1.39
log
@kill old code to handle deprecated pkgcfl.
@
text
@d2 1
a2 1
# $OpenBSD: Delete.pm,v 1.38 2007/05/02 15:17:36 espie Exp $
d27 21
d66 1
a66 16
				require File::Temp;

				my $n = $i->fullname();

				my ($fh, $j) = File::Temp::mkstemp("$n.XXXXXXXX");
				close $fh;
				if (rename($n, $j)) {
					print "Renaming old file $n to $j\n";
					if ($i->{name} !~ m|^/| && $i->cwd() ne '.') {
						my $c = $i->cwd();
						$j =~ s|^\Q$c\E/||;
					}
					$i->{name} = $j;
				} else {
					print "Bad rename $n to $j: $!\n";
				}
d71 2
a72 1
	my $borked = borked_package($plist->pkgname());
@


1.38
log
@replace pkgbase with less confusing name localbase
@
text
@d2 1
a2 1
# $OpenBSD: Delete.pm,v 1.37 2007/05/02 15:05:29 espie Exp $
d31 1
a31 1
	for my $i (qw(cvstags name no-default-conflict pkgcfl conflict) ) {
@


1.37
log
@$o->method() becomes $o->method
@
text
@d2 1
a2 1
# $OpenBSD: Delete.pm,v 1.36 2007/04/29 11:09:29 espie Exp $
d164 1
a164 1
	$ENV{'PKG_PREFIX'} = $plist->pkgbase;
@


1.36
log
@replace $p->visit('method') calls with $p->method
now that it works.
@
text
@d2 1
a2 1
# $OpenBSD: Delete.pm,v 1.35 2007/04/15 10:17:29 espie Exp $
d41 1
a41 1
		next unless $i->IsFile();
d73 1
a73 1
	$p->to_installation();
d106 1
a106 1
	my $dir = installed_info($plist->pkgname());
d142 1
a142 1
	if (!defined $plist->pkgname()) {
d145 1
a145 1
	if ($plist->pkgname() ne $pkgname) {
d160 1
a160 1
	my $pkgname = $plist->pkgname();
d164 1
a164 1
	$ENV{'PKG_PREFIX'} = $plist->pkgbase();
d258 1
a258 1
	my $name = $self->fullname();
d291 1
a291 1
	$self->mark_directory($state, $self->fullname());
d333 1
a333 1
	my $name = $self->fullname();
d369 1
a369 1
	my $fname = $state->{destdir}.$self->fullname();
d423 1
a423 1
						$self->fullname(), "\n";
d518 1
a518 1
		my $fullname = $self->fullname();
@


1.35
log
@update copyright years, standardize licence.
reword the introduction to the stuff originally from FreeBSD to clarify
slightly.
@
text
@d2 1
a2 1
# $OpenBSD: Delete.pm,v 1.34 2007/03/07 11:24:07 espie Exp $
d105 1
a105 1
	$plist->visit('prepare_for_deletion', $state);
d171 1
a171 1
	$plist->visit('register_manpage', $state);
@


1.34
log
@fix size checks for good. Since we want deletion to happen `right now'
but size accounting to happen later, just mark the size to delete `for
later', do not take them into account for avail(), and synchronize() at
the right time, e.g., after addition when updating, and right away for
straight deletion.

okay deraadt@@
@
text
@d2 1
a2 1
# $OpenBSD: Delete.pm,v 1.33 2006/10/18 16:40:40 sturm Exp $
d4 1
a4 1
# Copyright (c) 2003-2004 Marc Espie <espie@@openbsd.org>
@


1.33
log
@symlinks marked @@extra need special care for deletion

ok bernd, espie
@
text
@d2 1
a2 1
# $OpenBSD: Delete.pm,v 1.32 2005/10/27 07:02:02 bernd Exp $
d150 1
@


1.32
log
@Fix a perl warning during package deletion.
Noticed by Jonathan Weiss <jw at innerewut.de>, thanks.

ok espie@@
@
text
@d2 1
a2 1
# $OpenBSD: Delete.pm,v 1.31 2005/10/24 10:19:16 espie Exp $
d549 1
a549 1
	return unless -e $realname;
@


1.31
log
@more robust deletion: rebuild item from file system instead of using
computed state information, for storage in partial package.
@
text
@d2 1
a2 1
# $OpenBSD: Delete.pm,v 1.30 2005/10/24 10:10:26 espie Exp $
d371 1
a371 1
	next unless defined $s;
@


1.30
log
@use a visitor('prepare_for_deletion') to validate plist for removal,
so that we can put more checks earlier...
@
text
@d2 1
a2 1
# $OpenBSD: Delete.pm,v 1.29 2005/10/24 09:50:51 espie Exp $
d264 22
d394 1
a394 3
				$self->{stillaround} = 1;
				$self->{symlink} = $contents;
				$state->{baddelete} = 1;
d399 1
a399 6
			if (-f $realname) {
				delete $self->{symlink};
				$self->{md5} = OpenBSD::md5::fromfile($realname);
				$self->{stillaround} = 1;
			}
			$state->{baddelete} = 1;
d405 1
a405 2
				$self->{stillaround} = 1;
				$state->{baddelete} = 1;
d425 1
a425 3
					$self->{stillaround} = 1;
					$self->{md5} = $md5;
					$state->{baddelete} = 1;
@


1.29
log
@factor out a bit of code, and be more aware of symlinks.
@
text
@d2 1
a2 1
# $OpenBSD: Delete.pm,v 1.28 2005/10/22 13:11:07 espie Exp $
d103 3
a105 19
	my $problems = 0;
	my $totsize = 0;
	for my $item (@@{$plist->{items}}) {
		next unless $item->IsFile();
		my $fname = $destdir.$item->fullname();
		$totsize += $item->{size} if defined $item->{size};
		my $s = OpenBSD::Vstat::remove($fname, $item->{size});
		next unless defined $s;
		if ($s->{ro}) {
			if ($state->{very_verbose} or ++($s->{problems}) < 4) {
				Warn "Error: ", $s->{dev}, 
				    " is read-only ($fname)\n";
			} elsif ($s->{problems} == 4) {
				Warn "Error: ... more files can't be removed from ",
					$s->{dev}, "\n";
			}
			$problems++;
		}
	}
d115 1
a115 1
				$problems++;
d119 3
a121 3
	Fatal "fatal issues" if $problems;
	$totsize = 1 if $totsize == 0;
	$plist->{totsize} = $totsize;
d224 4
d339 23
@


1.28
log
@be more explicit about what's going on.
@
text
@d2 1
a2 1
# $OpenBSD: Delete.pm,v 1.27 2005/08/22 11:34:52 espie Exp $
d247 1
a247 1
sub mark_dir
d254 1
a254 1
		$self->mark_dir($state, $d2);
d258 25
d354 21
a374 8
	my $name = $self->fullname();
	if (defined $self->{tempname}) {
		$name = $self->{tempname};
	}
	my $realname = $state->{destdir}.$name;
	if (-l $realname) {
		if ($state->{very_verbose}) {
			print "deleting symlink: $realname\n";
d377 2
a378 16
		if (! -f $realname) {
			print "File $realname does not exist\n";
			return;
		}
		unless (defined($self->{link}) or $self->{nochecksum} or $state->{quick}) {
			if (!defined $self->{md5}) {
				print "Problem: $name does not have an md5 checksum\n";
				print "NOT deleting: $realname\n";
				$state->print("Couldn't delete $realname (no md5)\n");
				return;
			}
			my $md5 = OpenBSD::md5::fromfile($realname);
			if ($md5 ne $self->{md5}) {
				print "Problem: md5 doesn't match for $name\n";
				print "NOT deleting: $realname\n";
				$state->print("Couldn't delete $realname (bad md5)\n");
a379 1
				$self->{md5} = $md5;
d381 3
d386 20
d407 3
a409 3
		if ($state->{very_verbose}) {
			print "deleting: $realname\n";
		}
d426 1
a426 2
	my $name = $self->fullname();
	my $realname = $state->{destdir}.$name;
d432 1
a432 1
	my $origname = $state->{destdir}.$orig->fullname();
d449 1
a449 1
			$self->mark_dir($state, dirname($name));
d459 1
a459 1
				$self->mark_dir($state, dirname($name));
d521 1
a521 2
	my $name = $self->fullname();
	my $realname = $state->{destdir}.$name;
d529 1
a529 1
		$self->mark_dir($state, dirname($name));
d535 1
a535 1
		$self->mark_dir($state, dirname($name));
d545 1
a545 1
	my $realname = $state->{destdir}.$self->fullname();
d551 1
a551 1
		$self->mark_dir($state, $self->fullname());
@


1.27
log
@likewise, report only the first three files
@
text
@d2 1
a2 1
# $OpenBSD: Delete.pm,v 1.26 2005/08/17 09:19:09 espie Exp $
d52 1
a52 1
					print "Renaming $n to $j\n";
@


1.26
log
@rename erase to more appropriate forget
@
text
@d2 1
a2 1
# $OpenBSD: Delete.pm,v 1.25 2005/08/16 17:27:40 espie Exp $
d112 7
a118 1
			Warn "Error: ", $s->{dev}, " is read-only ($fname)\n";
@


1.25
log
@check special names too.
Fixes a nasty bug: you could have /var/db/pkg mounted read-only,
and still delete a package and keep the packing information around.

Also makes pkg_add -r estimation of size more accurate, even though
it usually doesn't matter, except for packages with huge packing-lists.
@
text
@d2 1
a2 1
# $OpenBSD: Delete.pm,v 1.24 2005/08/09 20:55:26 espie Exp $
d141 2
a142 2
	OpenBSD::RequiredBy->erase($dir);
	OpenBSD::Requiring->erase($dir);
@


1.24
log
@if we are replacing a package, the messages for @@extra stuff should be
slightly different.

Noticed by rohee@@
@
text
@d2 1
a2 1
# $OpenBSD: Delete.pm,v 1.23 2005/08/05 09:52:08 espie Exp $
d114 13
@


1.23
log
@Make sure $totsize != 0, even if the package does not contain any actual
files, so that the progress meter will work.
@
text
@d2 1
a2 1
# $OpenBSD: Delete.pm,v 1.22 2005/07/24 10:41:14 espie Exp $
d464 4
a467 1
	if ($state->{extra}) {
d483 1
@


1.22
log
@deal with a special case, where we are replacing files with changed md5:
in which case, we need to rename the files for the partial package, so
the renaming phase won't fuck up.
@
text
@d2 1
a2 1
# $OpenBSD: Delete.pm,v 1.21 2005/02/09 11:07:13 espie Exp $
d117 1
@


1.21
log
@in case some md5 don't match, keep the offending files around as a
borked package (with fixed md5). Makes it easier to locate those files
and erase them later if needed... this also  makes collisions explicit if
user forgets and tries to install a new package later.
@
text
@d2 1
a2 1
# $OpenBSD: Delete.pm,v 1.20 2004/12/29 14:10:27 espie Exp $
d25 1
d29 1
a29 1
	my ($plist, $dir) = @@_;
d44 18
d209 1
a209 1
	    my $borked = keep_old_files($plist, $dir);
@


1.20
log
@show `reading plist' while deleting packages, since we can do this easily,
and this gives a hint about what is going on for big packages (like tetex).
@
text
@d2 1
a2 1
# $OpenBSD: Delete.pm,v 1.19 2004/12/21 18:12:05 espie Exp $
d26 32
d188 9
a196 1
	remove_packing_info($dir) unless $state->{not};
d316 3
@


1.19
log
@fix nasty cache-out-of-sync bug.
Now, update with the same package name works again.
@
text
@d2 1
a2 1
# $OpenBSD: Delete.pm,v 1.18 2004/12/20 12:16:51 espie Exp $
d84 1
d314 1
@


1.18
log
@don't display some details in -n mode unless very verbose.
@
text
@d2 1
a2 1
# $OpenBSD: Delete.pm,v 1.17 2004/12/16 11:07:33 espie Exp $
d24 1
d76 2
@


1.17
log
@renamed borked_installation from borked.n to partial-<pkgname> ...
partial-<pkgname>.n if needed.

Make borked_installation take a message, to show installation/deinstallation
issues correctly.

Fix handling of ^C: this may lead some system calls to return early, thus
registering as errors: so always mark the last file as done, so that borked
installation will register it correctly.

Kill packing-list cache for anything but depends: we've got a global cache
of libraries now (use it in pkg_add).

Make almost everyone look at $main::not, so that we can call
register_installation
to_installation
RequirementList->add/delete
safely.

Simplify $not logic accordingly, do thing much more closely to what would
happen without -n.

This should allow pkg_add/pkg_delete -n to handle most nasty cases correctly
now, since all the relevant information is kept internally in a compact
format:
- register of shared libraries
- global register of conflicts
- cache of depends.
@
text
@d2 1
a2 1
# $OpenBSD: Delete.pm,v 1.16 2004/12/15 01:07:10 espie Exp $
d35 1
a35 1
			print "Removing manpages in $destdir$k: ", join(@@l), "\n";
d216 1
a216 1
	if ($state->{beverbose}) {
d252 1
a252 1
		if ($state->{beverbose}) {
d275 1
a275 1
		if ($state->{beverbose}) {
@


1.16
log
@move -n down into RequiredBy and PackingList (as $main::not, since we
don't want to load RequiredBy all the time).
Remove a few $state->{not} tests that are no longer needed.

pkg_add -n / pkg_delete -n should work much better when they need to
handle multiple dependencies.

(todo: kill plist caches, finish replacing with specialized caches like
libraries).
@
text
@d2 1
a2 1
# $OpenBSD: Delete.pm,v 1.15 2004/12/12 11:26:16 espie Exp $
a152 1
	$plist->forget();
@


1.15
log
@add somewhat more regular error catching code.
@
text
@d2 1
a2 1
# $OpenBSD: Delete.pm,v 1.14 2004/12/02 00:37:55 espie Exp $
d138 1
a138 1
			OpenBSD::RequiredBy->new($name)->delete($pkgname) unless $state->{not}; 
@


1.14
log
@Vstat API changed slightly. Found out by fries@@
@
text
@d2 1
a2 1
# $OpenBSD: Delete.pm,v 1.13 2004/11/27 12:07:58 espie Exp $
d137 5
a141 4
		eval { OpenBSD::RequiredBy->new($name)->delete($pkgname) unless $state->{not}; };
		if ($@@) {
			print STDERR "$@@\n";
		}
@


1.13
log
@record sample/extra directories if !extra, so that SharedItems won't warn
if those directories are not empty...
@
text
@d2 1
a2 1
# $OpenBSD: Delete.pm,v 1.12 2004/11/27 11:36:16 espie Exp $
d60 1
a60 1
			Warn "Error: ", $s->{mnt}, " is read-only ($fname)\n";
@


1.12
log
@be verbose if !extra, tell user what they should do manually.
@
text
@d2 1
a2 1
# $OpenBSD: Delete.pm,v 1.11 2004/11/21 13:32:18 espie Exp $
d161 14
d289 2
d317 1
d327 1
d384 2
d401 1
d405 1
d416 1
@


1.11
log
@check_lib_specs -> check_lib_spec: check one spec at a time, and report on it.
Loop on libdepends now split lib specs by itself.
Better reports, slightly more efficient, clearer.

Use a local sub to factor out common code to deleting pkgspec and REQUIRING
file contents. Rephrase message to say `removing dependency ON'.
@
text
@d2 1
a2 1
# $OpenBSD: Delete.pm,v 1.10 2004/11/14 19:25:45 espie Exp $
d192 1
a192 1
	$h->{$name} = 1;
d287 1
a287 1
		print "File $realname does not exist\n";
d291 1
a291 1
		print "File $realname is not a file\n";
a294 2
		print "Problem: file $name does not have an md5 checksum\n";
		print "NOT deleting: $realname\n";
d301 1
a301 1
			print "NOT deleting file $realname\n";
a308 1
			print "File $realname NOT identical to sample\n";
d310 1
a310 1
				print "NOT deleting $realname\n";
a368 1
	return unless $state->{extra};
d371 1
a371 1
	if ($state->{beverbose}) {
d376 6
a381 2
	unlink($realname) or 
	    print "problem deleting extra file $realname\n";
d389 6
a394 2
	return unless -e $state->{destdir}.$self->fullname();
	$self->SUPER::delete($state);
d402 5
a406 3
	return unless $state->{extra};

	$self->run($state);
@


1.10
log
@stop storing @@pkdep into packing-lists, use separate REQUIRING file instead.

Cases where we need to tweak dependencies are well-delimited, and we simply
convert the old installed package to the new model in one step.
@
text
@d2 1
a2 1
# $OpenBSD: Delete.pm,v 1.9 2004/11/11 22:40:38 espie Exp $
d129 6
a134 4
	for my $item (@@{$plist->{pkgdep}}) {
		my $name = $item->{name};
		next if defined $removed->{$name};
		print "remove dependency in $name\n" 
d142 4
d148 1
a148 9
		next if defined $removed->{$name};
		print "remove dependency in $name\n" 
		    if $state->{very_verbose} or $state->{not};
		local $@@;
		eval { OpenBSD::RequiredBy->new($name)->delete($pkgname) unless $state->{not}; };
		if ($@@) {
			print STDERR "$@@\n";
		}
		$removed->{$name} = 1;
@


1.9
log
@forget packing-lists after deleting the package (avoid out-of-memory error
when deleting large sets of packages).
@
text
@d2 1
a2 1
# $OpenBSD: Delete.pm,v 1.8 2004/11/11 11:51:53 espie Exp $
d141 12
@


1.8
log
@synch validate_plist
@
text
@d2 1
a2 1
# $OpenBSD: Delete.pm,v 1.7 2004/11/11 11:16:39 espie Exp $
d142 1
@


1.7
log
@introduce shortcuts to read/write contents from_installation/to_installation

use these to simplify all those packing lists manipulations.

demote non-root detection to a warning in -n mode:
fix a couple of minor bugs, of stuff that was run in -n mode and should not.
Namely, manpages were indexed/unindexed (ouch) and tempfiles were creating
during updates.
@
text
@d2 1
a2 1
# $OpenBSD: Delete.pm,v 1.6 2004/11/09 11:11:01 espie Exp $
d48 1
a48 1
	my ($plist, $destdir) = @@_;
d50 1
d90 1
a90 1
	validate_plist($plist, $state->{destdir});
@


1.6
log
@kill old Logger interface, use $state->print() to report problems at
end exclusively now.
@
text
@d2 1
a2 1
# $OpenBSD: Delete.pm,v 1.5 2004/11/09 10:49:25 espie Exp $
d34 7
a40 3
		eval { OpenBSD::Makewhatis::remove($destdir.$k, \@@l); };
		if ($@@) {
			print STDERR "Error in makewhatis: $@@\n";
d80 1
a80 2
	my $dir = installed_info($pkgname);
	my $plist = OpenBSD::PackingList->fromfile($dir.CONTENTS) or 
@


1.5
log
@kill dup code
@
text
@d2 1
a2 1
# $OpenBSD: Delete.pm,v 1.4 2004/11/06 12:22:33 espie Exp $
a140 1
use OpenBSD::Logger;
a145 10
sub log_pkgname
{
	my ($self, $state) = @@_;
	if (defined $state->{pkgname_tolog}) {
		OpenBSD::Logger::log
		    "# package ", $state->{pkgname_tolog}, "\n";
	$state->{pkgname_tolog} = undef;
	}
}

d235 1
a235 2
				$self->log_pkgname($state);
				OpenBSD::Logger::log "rm $state->{destdirname}$name\n";
d242 1
a242 2
				$self->log_pkgname($state);
				OpenBSD::Logger::log "rm $state->{destdirname}$name #MD5\n";
d253 1
a253 2
		$self->log_pkgname($state);
		OpenBSD::Logger::log "rm $state->{destdirname}$name\n";
d282 1
a282 2
		$self->log_pkgname($state);
		OpenBSD::Logger::log "rm $state->{destdirname}$name\n";
d307 1
a307 2
		$self->log_pkgname($state);
		OpenBSD::Logger::log "rm $state->{destdirname}$name\n";
@


1.4
log
@die if moving tempfiles doesn't work.
pkg_delete should remove tempnames, since files actually live there.
@
text
@d2 1
a2 1
# $OpenBSD: Delete.pm,v 1.3 2004/11/01 19:14:26 espie Exp $
a23 10

sub ensure_ldconfig
{
	my $state = shift;
	return if $state->{not};
	return unless defined $OpenBSD::PackingElement::Lib::todo;
	VSystem($state->{very_verbose}, 
	    @@OpenBSD::PackingElement::Lib::ldconfig, "-R");
	undef $OpenBSD::PackingElement::Lib::todo;
}
@


1.3
log
@allows Delete to remove a plist (assuming it's already been validated).
let pkg_add -r compute a replaced package and store its plist in the new
package plist, so that replacement has a chance to proceed.

Not finished yet. Missing:
- real lib depends checks;
- restoring package dependencies after replacement.
@
text
@d2 1
a2 1
# $OpenBSD: Delete.pm,v 1.2 2004/10/31 12:40:01 espie Exp $
d239 3
@


1.2
log
@fix logic error: we will be able to fully validate the new packing-list
in pkg_add -r mode, it's just a question of removing the old package
from the virtual filesystem early, so that we can still check for collisions.

Help getting OpenBSD::Delete self-contained while we're there...
@
text
@d2 1
a2 1
# $OpenBSD: Delete.pm,v 1.1 2004/10/31 10:26:17 espie Exp $
d70 1
a70 1
	return $totsize;
a85 1
	$state->{pkgname} = $pkgname;
a86 1
	$state->{dir} = $dir;
d96 1
a96 1
	my $totsize = validate_plist($plist, $state->{destdir});
d98 12
@


1.1
log
@Move most of the code of pkg_delete into a separate module so that it will
be usable by pkg_add -r.
@
text
@d2 1
a2 1
# $OpenBSD$
d141 2
@

