head	1.45;
access;
symbols
	OPENBSD_6_2:1.45.0.10
	OPENBSD_6_2_BASE:1.45
	OPENBSD_6_1:1.45.0.14
	OPENBSD_6_1_BASE:1.45
	OPENBSD_6_0:1.45.0.12
	OPENBSD_6_0_BASE:1.45
	OPENBSD_5_9:1.45.0.6
	OPENBSD_5_9_BASE:1.45
	OPENBSD_5_8:1.45.0.8
	OPENBSD_5_8_BASE:1.45
	OPENBSD_5_7:1.45.0.2
	OPENBSD_5_7_BASE:1.45
	OPENBSD_5_6:1.45.0.4
	OPENBSD_5_6_BASE:1.45
	OPENBSD_5_5:1.44.0.4
	OPENBSD_5_5_BASE:1.44
	OPENBSD_5_4:1.39.0.8
	OPENBSD_5_4_BASE:1.39
	OPENBSD_5_3:1.39.0.6
	OPENBSD_5_3_BASE:1.39
	OPENBSD_5_2:1.39.0.4
	OPENBSD_5_2_BASE:1.39
	OPENBSD_5_1_BASE:1.39
	OPENBSD_5_1:1.39.0.2
	OPENBSD_5_0:1.37.0.2
	OPENBSD_5_0_BASE:1.37
	OPENBSD_4_9:1.34.0.2
	OPENBSD_4_9_BASE:1.34
	OPENBSD_4_8:1.31.0.2
	OPENBSD_4_8_BASE:1.31
	OPENBSD_4_7:1.27.0.2
	OPENBSD_4_7_BASE:1.27
	OPENBSD_4_6:1.20.0.4
	OPENBSD_4_6_BASE:1.20
	OPENBSD_4_5:1.18.0.2
	OPENBSD_4_5_BASE:1.18
	OPENBSD_4_4:1.16.0.6
	OPENBSD_4_4_BASE:1.16
	OPENBSD_4_3:1.16.0.4
	OPENBSD_4_3_BASE:1.16
	OPENBSD_4_2:1.16.0.2
	OPENBSD_4_2_BASE:1.16
	OPENBSD_4_1:1.2.0.8
	OPENBSD_4_1_BASE:1.2
	OPENBSD_4_0:1.2.0.6
	OPENBSD_4_0_BASE:1.2
	OPENBSD_3_9:1.2.0.4
	OPENBSD_3_9_BASE:1.2
	OPENBSD_3_8:1.2.0.2
	OPENBSD_3_8_BASE:1.2
	OPENBSD_3_7:1.1.0.2
	OPENBSD_3_7_BASE:1.1;
locks; strict;
comment	@# @;


1.45
date	2014.03.07.09.45.53;	author espie;	state Exp;
branches;
next	1.44;

1.44
date	2014.02.04.07.59.40;	author espie;	state Exp;
branches;
next	1.43;

1.43
date	2014.02.03.12.03.01;	author espie;	state Exp;
branches;
next	1.42;

1.42
date	2014.01.31.10.49.53;	author espie;	state Exp;
branches;
next	1.41;

1.41
date	2014.01.31.10.30.48;	author espie;	state Exp;
branches;
next	1.40;

1.40
date	2014.01.30.13.17.42;	author espie;	state Exp;
branches;
next	1.39;

1.39
date	2011.08.31.22.50.21;	author espie;	state Exp;
branches;
next	1.38;

1.38
date	2011.08.31.10.11.58;	author espie;	state Exp;
branches;
next	1.37;

1.37
date	2011.07.12.10.22.29;	author espie;	state Exp;
branches;
next	1.36;

1.36
date	2011.07.02.12.12.58;	author espie;	state Exp;
branches;
next	1.35;

1.35
date	2011.06.30.12.54.44;	author espie;	state Exp;
branches;
next	1.34;

1.34
date	2010.12.24.09.04.14;	author espie;	state Exp;
branches;
next	1.33;

1.33
date	2010.11.04.07.43.53;	author espie;	state Exp;
branches;
next	1.32;

1.32
date	2010.10.27.14.35.56;	author espie;	state Exp;
branches;
next	1.31;

1.31
date	2010.06.30.10.51.04;	author espie;	state Exp;
branches;
next	1.30;

1.30
date	2010.06.30.10.41.42;	author espie;	state Exp;
branches;
next	1.29;

1.29
date	2010.06.11.09.56.44;	author espie;	state Exp;
branches;
next	1.28;

1.28
date	2010.05.10.09.17.55;	author espie;	state Exp;
branches;
next	1.27;

1.27
date	2010.01.07.13.11.21;	author espie;	state Exp;
branches;
next	1.26;

1.26
date	2010.01.05.12.20.47;	author espie;	state Exp;
branches;
next	1.25;

1.25
date	2009.12.30.19.04.06;	author espie;	state Exp;
branches;
next	1.24;

1.24
date	2009.12.30.16.43.08;	author espie;	state Exp;
branches;
next	1.23;

1.23
date	2009.12.30.09.43.34;	author espie;	state Exp;
branches;
next	1.22;

1.22
date	2009.11.10.14.32.31;	author espie;	state Exp;
branches;
next	1.21;

1.21
date	2009.10.11.18.04.41;	author espie;	state Exp;
branches;
next	1.20;

1.20
date	2009.04.19.14.58.32;	author espie;	state Exp;
branches;
next	1.19;

1.19
date	2009.03.07.12.07.37;	author espie;	state Exp;
branches;
next	1.18;

1.18
date	2008.10.20.10.25.16;	author espie;	state Exp;
branches;
next	1.17;

1.17
date	2008.10.04.09.39.00;	author espie;	state Exp;
branches;
next	1.16;

1.16
date	2007.06.09.11.16.54;	author espie;	state Exp;
branches;
next	1.15;

1.15
date	2007.06.04.20.48.23;	author espie;	state Exp;
branches;
next	1.14;

1.14
date	2007.06.04.14.57.33;	author espie;	state Exp;
branches;
next	1.13;

1.13
date	2007.06.04.14.40.39;	author espie;	state Exp;
branches;
next	1.12;

1.12
date	2007.05.14.11.02.15;	author espie;	state Exp;
branches;
next	1.11;

1.11
date	2007.05.14.10.53.31;	author espie;	state Exp;
branches;
next	1.10;

1.10
date	2007.05.14.10.43.45;	author espie;	state Exp;
branches;
next	1.9;

1.9
date	2007.05.13.12.55.54;	author espie;	state Exp;
branches;
next	1.8;

1.8
date	2007.05.12.22.55.29;	author espie;	state Exp;
branches;
next	1.7;

1.7
date	2007.05.12.15.00.30;	author espie;	state Exp;
branches;
next	1.6;

1.6
date	2007.05.12.14.36.56;	author espie;	state Exp;
branches;
next	1.5;

1.5
date	2007.05.12.14.07.17;	author espie;	state Exp;
branches;
next	1.4;

1.4
date	2007.05.12.13.36.54;	author espie;	state Exp;
branches;
next	1.3;

1.3
date	2007.04.15.10.17.29;	author espie;	state Exp;
branches;
next	1.2;

1.2
date	2005.08.14.23.23.34;	author espie;	state Exp;
branches;
next	1.1;

1.1
date	2004.10.11.09.44.06;	author espie;	state Exp;
branches;
next	;


desc
@@


1.45
log
@rename $_ for better style... lots more to be done
@
text
@# ex:ts=8 sw=4:
# $OpenBSD: PkgSpec.pm,v 1.44 2014/02/04 07:59:40 espie Exp $
#
# Copyright (c) 2003-2007 Marc Espie <espie@@openbsd.org>
#
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

use strict;
use warnings;

package OpenBSD::PkgSpec::flavorspec;
sub new
{
	my ($class, $spec) = @@_;

	bless \$spec, $class;
}

sub check_1flavor
{
	my ($f, $spec) = @@_;

	for my $flavor (split /\-/o, $spec) {
		# must not be here
		if ($flavor =~ m/^\!(.*)$/o) {
			return 0 if $f->{$1};
		# must be here
		} else {
			return 0 unless $f->{$flavor};
		}
	}
	return 1;
}

sub match
{
	my ($self, $h) = @@_;

	# check each flavor constraint
	for my $c (split /\,/o, $$self) {
		if (check_1flavor($h->{flavors}, $c)) {
			return 1;
		}
	}
	return 0;
}

package OpenBSD::PkgSpec::exactflavor;
our @@ISA = qw(OpenBSD::PkgSpec::flavorspec);
sub new
{
	my ($class, $value) = @@_;
	bless {map{($_, 1)} split(/\-/, $value)}, $class;
}

sub flavor_string
{
	my $self = shift;
	return join('-', sort keys %$self);
}

sub match
{
	my ($self, $h) = @@_;
	if ($self->flavor_string eq $h->flavor_string) {
		return 1;
	} else {
		return 0;
	}
}

package OpenBSD::PkgSpec::versionspec;
our @@ISA = qw(OpenBSD::PackageName::version);
my $ops = {
	'<' => 'lt',
	'<=' => 'le',
	'>' => 'gt',
	'>=' => 'ge',
	'=' => 'eq'
};

sub new
{
	my ($class, $s) = @@_;
	my ($op, $version) = ('=', $s);
	if ($s =~ m/^(\>\=|\>|\<\=|\<|\=)(.*)$/) {
		($op, $version) = ($1, $2);
	}
	return "OpenBSD::PkgSpec::version::$ops->{$op}"->from_string($version);
}

sub pnum_compare
{
	my ($self, $b) = @@_;
	if (!defined $self->{p}) {
		return 0;
	} else {
		return $self->SUPER::pnum_compare($b);
	}
}

sub is_exact
{
	return 0;
}

package OpenBSD::PkgSpec::version::lt;
our @@ISA = qw(OpenBSD::PkgSpec::versionspec);
sub match
{
	my ($self, $b) = @@_;
	-$self->compare($b->{version}) < 0 ? 1 : 0;
}

package OpenBSD::PkgSpec::version::le;
our @@ISA = qw(OpenBSD::PkgSpec::versionspec);
sub match
{
	my ($self, $b) = @@_;
	-$self->compare($b->{version}) <= 0 ? 1 : 0;
}

package OpenBSD::PkgSpec::version::gt;
our @@ISA = qw(OpenBSD::PkgSpec::versionspec);
sub match
{
	my ($self, $b) = @@_;
	-$self->compare($b->{version}) > 0 ? 1 : 0;
}

package OpenBSD::PkgSpec::version::ge;
our @@ISA = qw(OpenBSD::PkgSpec::versionspec);
sub match
{
	my ($self, $b) = @@_;
	-$self->compare($b->{version}) >= 0 ? 1 : 0;
}

package OpenBSD::PkgSpec::version::eq;
our @@ISA = qw(OpenBSD::PkgSpec::versionspec);
sub match
{
	my ($self, $b) = @@_;
	-$self->compare($b->{version}) == 0 ? 1 : 0;
}

sub is_exact
{
	return 1;
}

package OpenBSD::PkgSpec::badspec;
sub new
{
	my $class = shift;
	bless {}, $class;
}

sub match_ref
{
	return ();
}

sub match_libs_ref
{
	return ();
}

sub match_locations
{
	return [];
}

sub is_valid
{
	return 0;
}

package OpenBSD::PkgSpec::SubPattern;
use OpenBSD::PackageName;

sub parse
{
	my ($class, $p) = @@_;

	my $r = {};

	# let's try really hard to find the stem and the flavors
	unless ($p =~ m/^(.*?)\-((?:(?:\>|\>\=|\<\=|\<|\=)?\d|\*)[^-]*)(.*)$/) {
		return undef;
	}
	($r->{stemspec}, $r->{vspec}, $r->{flavorspec}) = ($1, $2, $3);
	$r->{flavorspec} =~ s/^\-//;

	$r->{stemspec} =~ s/\./\\\./go;
	$r->{stemspec} =~ s/\+/\\\+/go;
	$r->{stemspec} =~ s/\*/\.\*/go;
	$r->{stemspec} =~ s/\?/\./go;
	$r->{stemspec} =~ s/^(\\\.libs)\-/$1\\d*\-/go;
	return $r;
}

sub add_version_constraints
{
	my ($class, $constraints, $vspec) = @@_;

	# turn the vspec into a list of constraints.
	if ($vspec eq '*') {
		# non constraint
	} else {
		for my $c (split /\,/, $vspec) {
			push(@@$constraints,
			    OpenBSD::PkgSpec::versionspec->new($c));
		}
	}
}

sub add_flavor_constraints
{
	my ($class, $constraints, $flavorspec) = @@_;
	# and likewise for flavors
	if ($flavorspec eq '') {
		# non constraint
	} else {
		push(@@$constraints,
		    OpenBSD::PkgSpec::flavorspec->new($flavorspec));
	}
}

sub new
{
	my ($class, $p, $with_partial) = @@_;

	my $r = $class->parse($p);
	if (defined $r) {
		my $stemspec = $r->{stemspec};
		my $constraints = [];
		$class->add_version_constraints($constraints, $r->{vspec});
		$class->add_flavor_constraints($constraints, $r->{flavorspec});

		my $o = bless {
			libstem => qr{^\.libs\d*\-$stemspec\-\d.*$},
		    }, $class;

		if ($with_partial) {
			$o->{fuzzystem} = qr{^(?:partial\-)*$stemspec\-\d.*$};
		} else {
			$o->{fuzzystem} = qr{^$stemspec\-\d.*$};
		}
		if (@@$constraints != 0) {
			$o->{constraints} = $constraints;
		}
		if (defined $r->{e}) {
			$o->{e} = 1;
		}
	   	return $o;
	} else {
		return OpenBSD::PkgSpec::badspec->new;
	}
}

sub match_ref
{
	my ($o, $list) = @@_;
	my @@result = ();
	# Now, have to extract the version number, and the flavor...
LOOP1:
	for my $s (grep(/$o->{fuzzystem}/, @@$list)) {
		my $name = OpenBSD::PackageName->from_string($s);
		if (defined $o->{constraints}) {
			for my $c (@@{$o->{constraints}}) {
				next LOOP1 unless $c->match($name);
			}
		}
		if (wantarray) {
			push(@@result, $s);
		} else {
			return 1;
		}
	}

	return @@result;
}

sub match_libs_ref
{
	my ($o, $list) = @@_;
	return grep(/$o->{libstem}/, @@$list);
}


sub match_locations
{
	my ($o, $list) = @@_;
	my $result = [];
	# Now, have to extract the version number, and the flavor...
LOOP2:
	for my $s (grep { $_->name =~ m/$o->{fuzzystem}/} @@$list) {
		my $name = $s->pkgname;
		if (defined $o->{constraints}) {
			for my $c (@@{$o->{constraints}}) {
				next LOOP2 unless $c->match($name);
			}
		}
		push(@@$result, $s);
	}

	return $result;
}

sub is_valid
{
	return 1;
}

package OpenBSD::PkgSpec;
sub subpattern_class
{ "OpenBSD::PkgSpec::SubPattern" }
sub new
{
	my ($class, $pattern, $with_partial) = @@_;
	my @@l = map { $class->subpattern_class->new($_, $with_partial) }
		(split /\|/o, $pattern);
	if (@@l == 1) {
		return $l[0];
	} else {
		return bless \@@l, $class;
	}
}

sub match_ref
{
	my ($self, $r) = @@_;
	if (wantarray) {
		my @@l = ();
		for my $subpattern (@@$self) {
			push(@@l, $subpattern->match_ref($r));
		}
		return @@l;
	} else {
		for my $subpattern (@@$self) {
			if ($subpattern->match_ref($r)) {
				return 1;
			}
		}
		return 0;
	}
}

sub match_libs_ref
{
	my ($self, $r) = @@_;
	if (wantarray) {
		my @@l = ();
		for my $subpattern (@@$self) {
			push(@@l, $subpattern->match_libs_ref($r));
		}
		return @@l;
	} else {
		for my $subpattern (@@$self) {
			if ($subpattern->match_libs_ref($r)) {
				return 1;
			}
		}
		return 0;
	}
}

sub match_locations
{
	my ($self, $r) = @@_;
	my $l = [];
	for my $subpattern (@@$self) {
		push(@@$l, @@{$subpattern->match_locations($r)});
	}
	return $l;
}

sub is_valid
{
	my $self = shift;
	for my $subpattern (@@$self) {
		return 0 unless $subpattern->is_valid;
	}
	return 1;
}

package OpenBSD::PkgSpec::SubPattern::Exact;
our @@ISA = qw(OpenBSD::PkgSpec::SubPattern);

sub add_version_constraints
{
	my ($class, $constraints, $vspec) = @@_;
	return if $vspec eq '*'; # XXX
	my $v = OpenBSD::PkgSpec::versionspec->new($vspec);
	die "not a good exact spec" if !$v->is_exact;
	delete $v->{p};
	push(@@$constraints, $v);
}

sub add_flavor_constraints
{
	my ($class, $constraints, $flavorspec) = @@_;
	push(@@$constraints, OpenBSD::PkgSpec::exactflavor->new($flavorspec));
}

package OpenBSD::PkgSpec::Exact;
our @@ISA = qw(OpenBSD::PkgSpec);

sub subpattern_class
{ "OpenBSD::PkgSpec::SubPattern::Exact" }

1;
@


1.44
log
@kill very old compatibility code (2009/04... those exceptions are fully dead)
@
text
@d2 1
a2 1
# $OpenBSD: PkgSpec.pm,v 1.43 2014/02/03 12:03:01 espie Exp $
d33 1
a33 1
	for my $_ (split /\-/o, $spec) {
d35 1
a35 1
		if (m/^\!(.*)$/o) {
d39 1
a39 1
			return 0 unless $f->{$_};
d50 2
a51 2
	for my $_ (split /\,/o, $$self) {
		if (check_1flavor($h->{flavors}, $_)) {
@


1.43
log
@don't really need exactstem, the initial grep is good enough
@
text
@d2 1
a2 1
# $OpenBSD: PkgSpec.pm,v 1.42 2014/01/31 10:49:53 espie Exp $
a191 51
my $exception = {
	"db-3.*" => "db->=3,<4",
	"db-4.*" => "db->=4,<5",
	"db-java-4.*" => "db-java->=4,<5",
	"emacs-21.*" => "emacs->=21,<22",
	"emacs-21.4*" => "emacs->=21.4,<21.5",
	"emacs-22.2*" => "emacs->=22.2,<22.3",
	"enlightenment-0.16*" => "enlightenment->=0.16,<0.17",
	"gimp-2.*" => "gimp->=2,<3",
	"gnupg->=1.4.*" => "gnupg->=1.4",
	"gstreamer-0.10.*" => "gstreamer->=0.10,<0.11",
	"gtksourceview-2.*" => "gtksourceview->=2,<3",
	"hydra-5.4*" => "hydra->=5.4,<5.5",
	"jdk->=1.5.0.*" => "jdk->=1.5.0",
	"jdk->=1.6.0.*" => "jdk->=1.6.0",
	"jre->=1.5.0.*" => "jre->=1.5.0",
	"libggi->=0.9*" => "libggi->=0.9",
	"libnet-1.0*" => "libnet->=1.0,<1.1",
	"libnet-1.0.*" => "libnet->=1.0,<1.1",
	"libnet-1.1*" => "libnet->=1.1,<1.2",
	"libsigc++-1.*" => "libsigc++->=1,<2",
	"libsigc++-2.*" => "libsigc++->=2,<3",
	"mysql-client-5.0.*" => "mysql-client->=5.0,<5.1",
	"ocaml-3.09.3*" => "ocaml->=3.09.3,<3.09.4",
	"openldap-client-2.*" => "openldap-client->=2,<3",
	"pgp-5.*" => "pgp->=5,<6",
	"postgresql-client-8.3.*" => "postgresql-client->=8.3,<8.4",
	"python-2.4*" => "python->=2.4,<2.5",
	"python-2.4.*" => "python->=2.4,<2.5",
	"python-2.5*" => "python->=2.5,<2.6",
	"python-2.5.*" => "python->=2.5,<2.6",
	"python-2.6.*" => "python->=2.6,<2.7",
	"python-bsddb-2.5*" => "python-bsddb->=2.5,<2.6",
	"python-tkinter-2.4*" => "python-tkinter->=2.4,<2.5",
	"python-tkinter-2.5*" => "python-tkinter->=2.5,<2.6",
	"rrdtool-1.2.*" => "rrdtool->=1.2,<1.3",
	"swt-3.2.2*" => "swt->=3.2.2,<3.2.3",
	"swt-browser-3.2.2*" => "swt-browser->=3.2.2,<3.2.3",
	"tcl-8.4.*" => "tcl->=8.4,<8.5",
	"tcl-8.5.*" => "tcl->=8.5,<8.6",
	"tk-8.4*" => "tk->=8.4,<8.5",
	"tk-8.4.*" => "tk->=8.4,<8.5",
	"tk-8.5*" => "tk->=8.5,<8.6",
	"tomcat-4.*" => "tomcat->=4,<5",
	"tomcat-5.*" => "tomcat->=5,<6",
	"tomcat-6.*" => "tomcat->=6,<7",
	"tomcat-admin-4.*" => "tomcat-admin->=4,<5",
	"tomcat-admin-5.*" => "tomcat-admin->=5,<6",
	"xmms-1.2.11*" => "xmms->=1.2.11,<1.2.12"
};

a197 5
	if (defined $exception->{$p}) {
		$p = $exception->{$p};
		$r->{e} = 1;
	}

d323 1
a323 1
	return !defined shift->{e};
@


1.42
log
@avoid creating backrefs
@
text
@d2 1
a2 1
# $OpenBSD: PkgSpec.pm,v 1.41 2014/01/31 10:30:48 espie Exp $
a311 1
			$o->{exactstem} = qr{^(?:partial\-)*$stemspec$};
a313 1
			$o->{exactstem} = qr{^$stemspec$};
a335 1
		next unless $name->{stem} =~ m/^$o->{exactstem}$/;
a365 1
		next unless $name->{stem} =~ m/^$o->{exactstem}$/;
@


1.41
log
@handle conflict with partial in a less hackish ways, by passing an
extra "with_partial" parameter to specs.
This also removes quite a lot extraneous objects.
@
text
@d2 1
a2 1
# $OpenBSD: PkgSpec.pm,v 1.40 2014/01/30 13:17:42 espie Exp $
d312 2
a313 2
			$o->{exactstem} = qr{^(partial\-)*$stemspec$};
			$o->{fuzzystem} = qr{^(partial\-)*$stemspec\-\d.*$};
@


1.40
log
@most PkgSpec are default conflicts, so not storing empty constraints...
@
text
@d2 1
a2 1
# $OpenBSD: PkgSpec.pm,v 1.39 2011/08/31 22:50:21 espie Exp $
d298 1
a298 1
	my ($class, $p) = @@_;
a307 2
			exactstem => qr{^$stemspec$},
			fuzzystem => qr{^$stemspec\-\d.*$},
d310 8
d391 2
a392 2
	my ($class, $pattern) = @@_;
	my @@l = map { $class->subpattern_class->new($_) }
@


1.39
log
@propagate change of internals

fixes:
Not a SCALAR reference at /usr/libdata/perl5/OpenBSD/PkgSpec.pm line 454
@
text
@d2 1
a2 1
# $OpenBSD: PkgSpec.pm,v 1.38 2011/08/31 10:11:58 espie Exp $
a310 1
			constraints => $constraints,
d312 3
d333 4
a336 2
		for my $c (@@{$o->{constraints}}) {
			next LOOP1 unless $c->match($name);
d364 4
a367 2
		for my $c (@@{$o->{constraints}}) {
			next LOOP2 unless $c->match($name);
@


1.38
log
@versionspec stuff belongs in PkgSpec, not PackageName
@
text
@d2 1
a2 1
# $OpenBSD$
d454 2
a455 2
	die "not a good exact spec" if !$$v->is_exact;
	delete $$v->{p};
@


1.37
log
@refactor
@
text
@d2 1
a2 1
# $OpenBSD: PkgSpec.pm,v 1.36 2011/07/02 12:12:58 espie Exp $
d83 9
d95 52
a146 2
	my $spec = OpenBSD::PackageName::versionspec->from_string($s);
	bless \$spec, $class;
d149 2
d153 3
a155 1
	my ($self, $name) = @@_;
d157 3
a159 1
	return $$self->match($name->{version});
@


1.36
log
@allows .libs* packages to match correctly in the presence of @@conflict markers
@
text
@d2 1
a2 1
# $OpenBSD: PkgSpec.pm,v 1.35 2011/06/30 12:54:44 espie Exp $
a25 2
	$spec =~ s/^-//o;

a62 1
	$value =~ s/^\-//;
d194 1
@


1.35
log
@make exact flavor specs smarter.

problem reported by Jacek Masiulaniec
@
text
@d2 1
a2 1
# $OpenBSD: PkgSpec.pm,v 1.34 2010/12/24 09:04:14 espie Exp $
d112 5
d247 1
d281 7
d338 19
@


1.34
log
@handle failures from ports tree with more care.
this does avoid infinite loops in case of wrong plists.
necessary since print-plist-with-depends CAN fail...
@
text
@d2 1
a2 1
# $OpenBSD$
d62 13
d78 1
a78 1
	if ($$self eq $h->flavor_string) {
@


1.33
log
@badspec match_locations must return a ref, fixes pkg_add -nz bzr
(sorry, I don't remember your name, I misplaced that email)
@
text
@d2 1
a2 1
# $OpenBSD: PkgSpec.pm,v 1.32 2010/10/27 14:35:56 espie Exp $
@


1.32
log
@initial scaffolding for @@rcscript: for now, acts like normal files,
but allow absolute pathnames (treat that as an implicit @@cwd).
@
text
@d2 1
a2 1
# $OpenBSD$
d101 1
a101 1
	return ();
@


1.31
log
@allow say and errsay to work without parameters, as it's ways common.
create verbose_system up in state, because it makes sense without verbose.
@
text
@@


1.30
log
@whitespace cleanup
@
text
@@


1.29
log
@add wantarray optimization, just reply 1 as soon as we can when we actually
don't try to build the list.
@
text
@d2 1
a2 1
# $OpenBSD: PkgSpec.pm,v 1.28 2010/05/10 09:17:55 espie Exp $
@


1.28
log
@whitespace fixes
@
text
@d2 1
a2 1
# $OpenBSD$
d252 5
a256 1
		push(@@result, $s);
d303 13
a315 3
	my @@l = ();
	for my $subpattern (@@$self) {
		push(@@l, $subpattern->match_ref($r));
a316 1
	return @@l;
@


1.27
log
@make sure is_valid works for alternatives
@
text
@d197 1
a197 1
			push(@@$constraints, 
d210 1
a210 1
		push(@@$constraints, 
d226 4
a229 4
		my $o = bless { 
			exactstem => qr{^$stemspec$}, 
			fuzzystem => qr{^$stemspec\-\d.*$}, 
			constraints => $constraints, 
d254 1
a254 1
		
d272 1
a272 1
		
d287 1
a287 1
	my @@l = map { $class->subpattern_class->new($_) } 
@


1.26
log
@better spec handling: instead of dying, create badspec objects that never
match anything. Add method is_valid (and propagators) to know whether a
spec is valid (to be used in pkg_create in a systematic way).
@
text
@d318 1
a318 1
	my $self = @@_;
@


1.25
log
@more changes and optimizations: create unique dewey objects, so I can
compare them directly and avoid storing the string.
on typical use through a large update, 2/3 cache hits.

also, remove switch on <,> by writing subclasses. Actually makes things
clearer.
@
text
@d87 21
d167 2
d171 1
d176 1
a176 1
		die "Invalid spec $p";
d178 1
a178 1
	my ($stemspec, $vspec, $flavorspec) = ($1, $2, $3);
d180 6
a185 6
	$stemspec =~ s/\./\\\./go;
	$stemspec =~ s/\+/\\\+/go;
	$stemspec =~ s/\*/\.\*/go;
	$stemspec =~ s/\?/\./go;
	$stemspec =~ s/^(\\\.libs)\-/$1\\d*\-/go;
	return ($stemspec, $vspec, $flavorspec);
d219 19
a237 10
	my ($stemspec, $vspec, $flavorspec) = $class->parse($p);
	my $constraints = [];
	$class->add_version_constraints($constraints, $vspec);
	$class->add_flavor_constraints($constraints, $flavorspec);

	bless { 
	    exactstem => qr{^$stemspec$}, 
	    fuzzystem => qr{^$stemspec\-\d.*$}, 
	    constraints => $constraints, 
	}, $class;
d276 5
d314 9
@


1.24
log
@fix pkgspec handling, actually do filter by regexp.
shave some memory off packagenames by not storing non-existent p/v.
cache all packagename construction (happens two times out of 3).
@
text
@d286 1
a286 1
	die "not a good exact spec" if $$v->{op} ne '=';
@


1.23
log
@a few small optimizations:
- be more specific in what we trim.
- iterate over list directly, don't build it.
- don't create pattern objects for the most common case (one subpattern)
@
text
@d213 1
a213 1
	for my $s (grep($o->{fuzzystem}, @@$list)) {
d287 1
a287 1
	$$v->{pnum} = -1;
@


1.22
log
@remove dead code: as far as possible, we use only
match_locations/filter_locations since we deal with location.

external API only uses spec->filter(), so we keep that one.
We still need the generic match/filter adapters for Stem searches.
@
text
@d202 1
a202 1
	    fuzzystem => qr{^$stemspec-.*$}, 
a209 1
	my @@l = grep($o->{fuzzystem}, @@$list);
d213 1
a213 1
	for my $s (@@l) {
a227 1
	my @@l = grep { $_->name =~ m/$o->{fuzzystem}/} @@$list;
d231 1
a231 1
	for my $s (@@l) {
d251 5
a255 1
	bless \@@l, $class;
@


1.21
log
@maybe I'll change the code later (two XXX), but allows flavor after stem,
so that e.g.
pkg_add star--
pkg_add star--static
are now not ambiguous.
@
text
@a28 1

@


1.20
log
@synch with my new style search/location changes
It's likely there will be some fallout, but it's getting a bit too large
to keep around.
This does kill a few very old oddities as well.
@
text
@d283 1
@


1.19
log
@tweak code to use same comparison operations as PackageNames.
so the "special code" to handle weird suffixes and epoch names (v*) finally
comes into operation.
regress tests still pass, I still expect some breakage...
@
text
@a19 2
package OpenBSD::PkgSpec;
use OpenBSD::PackageName;
d21 2
a22 1
sub check_version
d24 5
a28 1
	my ($v, $constraint_list) = @@_;
a29 4
	for my $c (@@$constraint_list) {
		return 0 if $c->match($v) == 0;
	}
	return 1;
d48 1
a48 1
sub check_flavor
d50 1
a50 5
	my ($h, $spec) = @@_;
	# no flavor constraints
	return 1 if $spec eq '';

	$spec =~ s/^-//o;
d53 2
a54 2
	for my $_ (split /\,/o, $spec) {
		if (check_1flavor($h, $_)) {
d61 83
a143 1
sub subpattern_match
d145 5
a149 1
	my ($p, $list) = @@_;
a154 1

d162 2
d165 3
a167 2
	# First trim down the list
	my @@l = grep {/^$stemspec-.*$/} @@$list;
a169 1
	my @@constraints = ();
d174 2
a175 2
			push(@@constraints, 
			    OpenBSD::PackageName::versionspec->from_string($c));
d178 29
d208 4
d214 1
d217 5
a221 5
		if ($name->{stem} =~ m/^$stemspec$/ &&
			check_flavor($name->{flavors}, $flavorspec) &&
			check_version($name->{version}, \@@constraints)) {
			    	push(@@result, $s);
			}
d226 74
@


1.18
log
@Say goodbye to local $_
lexical scoping is so much neater (courtesy of perl 5.10)
@
text
@a22 59
# all the shit that does handle package specifications
sub compare_pseudo_numbers
{
	my ($n, $m) = @@_;

	my ($n1, $m1);

	if ($n =~ m/^(\d+)(.*)$/o) {
		$n1 = $1;
		$n = $2;
	}
	if ($m =~ m/^(\d+)(.*)$/o) {
		$m1 = $1;
		$m = $2;
	}

	if ($n1 == $m1) {
		return $n cmp $m;
	} else {
		return $n1 <=> $m1;
	}
}


sub dewey_compare
{
	my ($a, $b) = @@_;
	my ($pa, $pb);

	unless ($b =~ m/p\d+$/o) { 		# does the Dewey hold a p<number> ?
		$a =~ s/p\d+$//o; 	# No -> strip it from version.
	}

	return 0 if $a =~ /^$b$/; 	# bare equality

	if ($a =~ s/p(\d+)$//o) {	# extract patchlevels
		$pa = $1;
	}
	if ($b =~ s/p(\d+)$//o) {
		$pb = $1;
	}

	my @@a = split(/\./o, $a);
	push @@a, $pa if defined $pa;	# ... and restore them
	my @@b = split(/\\\./o, $b);
	push @@b, $pb if defined $pb;
	while (@@a > 0 && @@b > 0) {
		my $va = shift @@a;
		my $vb = shift @@b;
		next if $va eq $vb;
		return compare_pseudo_numbers($va, $vb);
	}
	if (@@a > 0) {
		return 1;
	} else {
		return -1;
	}
}

d25 1
a25 4
	my ($v, $spec) = @@_;

	# any version spec
	return 1 if $spec eq '.*';
d27 2
a28 4
	my @@specs = split(/\,/o, $spec);
	for my $_ (grep /^\d/o, @@specs) { 	# exact number: check match
		return 1 if $v =~ /^$_$/;
		return 1 if $v =~ /^${_}p\d+$/; # allows for recent patches
d30 1
a30 16

	# Last chance: dewey specs ?
	my @@deweys = grep !/^\d/o, @@specs;		
	for (@@deweys) {
		if (m/^(\<\=|\>\=|\<|\>)(.*)$/o) {
			my ($op, $dewey) = ($1, $2);
			my $compare = dewey_compare($v, $dewey);
			return 0 if $op eq '<' && $compare >= 0;
			return 0 if $op eq '<=' && $compare > 0;
			return 0 if $op eq '>' && $compare <= 0;
			return 0 if $op eq '>=' && $compare < 0;
		} else {
			return 0;	# unknown spec type
		}
	}
	return @@deweys == 0 ? 0 : 1;
d51 1
a51 1
	my ($f, $spec) = @@_;
a55 2
	# retrieve all flavors
	my %f = map +($_, 1), split /\-/o, $f;
d59 1
a59 1
		if (check_1flavor(\%f, $_)) {
d71 1
a71 1
	unless ($p =~ m/^(.*?)\-((?:(?:\>|\>\=|\<|\<\=|\=)?\d|\*)[^-]*)(.*)$/) {
d86 10
a95 4
	$vspec =~ s/\./\\\./go;
	$vspec =~ s/\+/\\\+/go;
	$vspec =~ s/\*/\.\*/go;
	$vspec =~ s/\?/\./go;
d99 6
a104 8
	for my $_ (@@l) {
		my ($stem, $v, $flavor);
		if (m/^(.*?)\-(\d[^-]*)(.*)$/o) {
			($stem, $v, $flavor) = ($1, $2, $3);
			if ($stem =~ m/^$stemspec$/ &&
			    check_version($v, $vspec) &&
			    check_flavor($flavor, $flavorspec)) {
			    	push(@@result, $_);
a105 5
	    	} else {
			if ($vspec eq '') {
				push(@@result, $_);
			}
		}
@


1.17
log
@tighter specs (tested for ages locally)
@
text
@a84 1
	local $_;
d90 1
a90 1
	for (grep /^\d/o, @@specs) { 		# exact number: check match
a114 1
	local $_;
d116 1
a116 1
	for (split /\-/o, $spec) {
a130 1
	local $_;
d139 1
a139 1
	for (split /\,/o, $spec) {
a149 1
	local $_;
d174 1
a174 1
	for (@@l) {
@


1.16
log
@rework `special' package names a bit.
- do a test to create partial-foo-1.0.1 instead of partial-partial-foo-1.0
when removing partial-foo fails.
- have .libs name generation, e.g., .libs-foo, then .libs1-foo, then .libs2-foo
instead of .libs-.libs-foo.... extend the pkgspec pattern slightly, so
that all these are more or less equivalent for dependencies and conflicts.

With this, we can do practically any scenario of shared libs updates and
downgrades.
@
text
@d2 1
a2 1
# $OpenBSD: PkgSpec.pm,v 1.15 2007/06/04 20:48:23 espie Exp $
d21 1
d155 4
a158 1
	my ($stemspec, $vspec, $flavorspec);
d160 1
a160 16

	# then, guess at where the version number is if any,
	
	# this finds patterns like -<=2.3,>=3.4.p1-
	# the only constraint is that the actual number 
	# - must start with a digit, 
	# - not contain - or ,
	if ($p =~ m/^(.*?)\-((?:\>|\>\=|\<|\<\=)?\d[^-]*)(.*)$/o) {
		($stemspec, $vspec, $flavorspec) = ($1, $2, $3);
	# `any version' matcher
	} elsif ($p =~ m/^(.*?)\-\*(.*)$/o) {
		($stemspec, $vspec, $flavorspec) = ($1, '*', $2);
	# okay, so no version marker. Assume no flavor spec.
	} else {
		($stemspec, $vspec, $flavorspec) = ($p, '', '');
	}
d167 4
a174 6

	$p = $stemspec;
	$p.="-.*" if $vspec ne '';

	# First trim down the list
	my @@l = grep {/^$p$/} @@$list;
@


1.15
log
@convert the remaining regexps, so that $`, $', $& are completely dead.
Should shave a few % off time and space.
@
text
@d2 1
a2 1
# $OpenBSD: PkgSpec.pm,v 1.14 2007/06/04 14:57:33 espie Exp $
d177 1
@


1.14
log
@I am on drugs, I don't know where I found split can take strings as
arguments. Repair...
@
text
@d2 1
a2 1
# $OpenBSD: PkgSpec.pm,v 1.13 2007/06/04 14:40:39 espie Exp $
d29 7
a35 7
	if ($n =~ m/^\d+/o) {
		$n1 = $&;
		$n = $';
	}
	if ($m =~ m/^\d+/o) {
		$m1 = $&;
		$m = $';
d98 2
a99 2
		if (m/^\<\=|\>\=|\<|\>/o) {
			my ($op, $dewey) = ($&, $');
d119 2
a120 2
		if (m/^\!/o) {
			return 0 if $f->{$'};
d163 2
a164 2
	if ($p =~ m/\-((?:\>|\>\=|\<|\<\=)?\d[^-]*)/o) {
		($stemspec, $vspec, $flavorspec) = ($`, $1, $');
d166 2
a167 2
	} elsif ($p =~ m/\-\*/o) {
		($stemspec, $vspec, $flavorspec) = ($`, '*', $');
d192 2
a193 2
		if (m/\-(\d[^-]*)/o) {
			($stem, $v, $flavor) = ($`, $1, $');
@


1.13
log
@some minor systematic changes.
- mark all regexps I can with /o if they can be compiled once.
- turn $o->method() into $o->method
- remove unneeded prototypes
- reduce split /re/ into split "string" where possible.
@
text
@d2 1
a2 1
# $OpenBSD: PkgSpec.pm,v 1.12 2007/05/14 11:02:15 espie Exp $
d64 1
a64 1
	my @@a = split('.', $a);
d66 1
a66 1
	my @@b = split("\\.", $b);
d89 1
a89 1
	my @@specs = split(',', $spec);
d117 1
a117 1
	for (split '-', $spec) {
d138 1
a138 1
	my %f = map +($_, 1), split '-', $f;
d141 1
a141 1
	for (split ',', $spec) {
@


1.12
log
@put Search objects into their own file, finally
@
text
@d2 1
a2 1
# $OpenBSD: PkgSpec.pm,v 1.11 2007/05/14 10:53:31 espie Exp $
d29 1
a29 1
	if ($n =~ m/^\d+/) {
d33 1
a33 1
	if ($m =~ m/^\d+/) {
d51 2
a52 2
	unless ($b =~ m/p\d+$/) { 		# does the Dewey hold a p<number> ?
		$a =~ s/p\d+$//; 	# No -> strip it from version.
d57 1
a57 1
	if ($a =~ s/p(\d+)$//) {	# extract patchlevels
d60 1
a60 1
	if ($b =~ s/p(\d+)$//) {
d64 1
a64 1
	my @@a = split(/\./, $a);
d66 1
a66 1
	my @@b = split(/\\\./, $b);
d89 2
a90 2
	my @@specs = split(/,/, $spec);
	for (grep /^\d/, @@specs) { 		# exact number: check match
d96 1
a96 1
	my @@deweys = grep !/^\d/, @@specs;		
d98 1
a98 1
		if (m/^\<\=|\>\=|\<|\>/) {
d117 1
a117 1
	for (split /-/, $spec) {
d119 1
a119 1
		if (m/^\!/) {
d136 1
a136 1
	$spec =~ s/^-//;
d138 1
a138 1
	my %f = map +($_, 1), split /\-/, $f;
d141 1
a141 1
	for (split /,/, $spec) {
d163 1
a163 1
	if ($p =~ m/\-((?:\>|\>\=|\<|\<\=)?\d[^-]*)/) {
d166 1
a166 1
	} elsif ($p =~ m/\-\*/) {
d173 8
a180 8
	$stemspec =~ s/\./\\\./g;
	$stemspec =~ s/\+/\\\+/g;
	$stemspec =~ s/\*/\.\*/g;
	$stemspec =~ s/\?/\./g;
	$vspec =~ s/\./\\\./g;
	$vspec =~ s/\+/\\\+/g;
	$vspec =~ s/\*/\.\*/g;
	$vspec =~ s/\?/\./g;
d192 1
a192 1
		if (m/\-(\d[^-]*)/) {
@


1.11
log
@put search objects into a search class.
@
text
@d2 1
a2 1
# $OpenBSD: PkgSpec.pm,v 1.10 2007/05/14 10:43:45 espie Exp $
d4 1
a4 1
# Copyright (c) 2003-2005 Marc Espie <espie@@openbsd.org>
a206 32
}

package OpenBSD::Search::PkgSpec;

sub match_ref
{
	my ($self, $r) = @@_;
	my @@l = ();

	for my $subpattern (@@{$self->{patterns}}) {
		push(@@l, OpenBSD::PkgSpec::subpattern_match($subpattern, $r));
	}
	return @@l;
}

sub match
{
	my ($self, $o) = @@_;
	return $self->match_ref($o->list);
}

sub match_list
{
	my ($self, @@list) = @@_;
	return $self->match_ref(\@@list);
}

sub new
{
	my ($class, $pattern) = @@_;
	my @@l = split /\|/, $pattern;
	bless { patterns => \@@l }, $class;
@


1.10
log
@name tweaks: match -> match_list, match_repo -> match
@
text
@d2 1
a2 1
# $OpenBSD: PkgSpec.pm,v 1.9 2007/05/13 12:55:54 espie Exp $
d209 2
d217 1
a217 1
		push(@@l, subpattern_match($subpattern, $r));
@


1.9
log
@move towards unifying stem searches and pkgspec searches.
@
text
@d2 1
a2 1
# $OpenBSD: PkgSpec.pm,v 1.8 2007/05/12 22:55:29 espie Exp $
d220 1
a220 1
sub match_repo
d226 1
a226 1
sub match
@


1.8
log
@remove obsolete comment.
@
text
@d2 1
a2 1
# $OpenBSD: PkgSpec.pm,v 1.7 2007/05/12 15:00:30 espie Exp $
d218 6
@


1.7
log
@kill old PkgSpec interface
@
text
@d2 1
a2 1
# $OpenBSD: PkgSpec.pm,v 1.6 2007/05/12 14:36:56 espie Exp $
a20 4

# one useful function: 
#   OpenBSD::PkgSpec::match($pattern, @@list) -> @@sublist
# note that @@sublist may contain duplicates
@


1.6
log
@oops, make the object variant functional
@
text
@d2 1
a2 1
# $OpenBSD: PkgSpec.pm,v 1.5 2007/05/12 14:07:17 espie Exp $
d218 1
a218 1
	for my $subpattern (ref($self) ? @@{$self->{patterns}} : split /\|/, $self) {
d227 1
a227 1
	return match_ref($self, \@@list);
@


1.5
log
@somewhat sneaky: allow PkgSpecs to be objects, so that we can perform
optimizations on them. For now, we just do the subpattern split once.
@
text
@d2 1
a2 1
# $OpenBSD: PkgSpec.pm,v 1.4 2007/05/12 13:36:54 espie Exp $
d218 1
a218 1
	for my $subpattern (ref($self) ? $self->{patterns} : split /\|/, $self) {
@


1.4
log
@pass refs around instead of extending them.
@
text
@d2 1
a2 1
# $OpenBSD: PkgSpec.pm,v 1.3 2007/04/15 10:17:29 espie Exp $
d215 1
a215 1
	my ($pattern, $r) = @@_;
d218 1
a218 1
	for my $subpattern (split /\|/, $pattern) {
d226 9
a234 2
	my ($pattern, @@list) = @@_;
	return match_ref($pattern, \@@list);
@


1.3
log
@update copyright years, standardize licence.
reword the introduction to the stuff originally from FreeBSD to clarify
slightly.
@
text
@d2 1
a2 1
# $OpenBSD: PkgSpec.pm,v 1.2 2005/08/14 23:23:34 espie Exp $
d213 1
a213 1
sub match
d215 1
a215 1
	my ($pattern, @@list) = @@_;
d219 1
a219 1
		push(@@l, subpattern_match($subpattern, \@@list));
d222 6
@


1.2
log
@if there's no identifiable version in the spec, and in the package name,
then it matches when it is equal.
@
text
@d2 1
a2 1
# $OpenBSD: PkgSpec.pm,v 1.1 2004/10/11 09:44:06 espie Exp $
d4 1
a4 1
# Copyright (c) 2003-2004 Marc Espie <espie@@openbsd.org>
@


1.1
log
@split PackageName handling into PackageName stuff/PkgSpec matching.
Kill new method that isn't really used.

Name explicit splitstem() to get the stem of a packagename.

Adjust calls to the interface.
@
text
@d2 1
a2 1
# $OpenBSD$
d203 5
a207 1
	    	}
@

