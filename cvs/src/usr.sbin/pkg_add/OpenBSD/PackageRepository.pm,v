head	1.145;
access;
symbols
	OPENBSD_6_1:1.142.0.4
	OPENBSD_6_1_BASE:1.142
	OPENBSD_6_0:1.124.0.4
	OPENBSD_6_0_BASE:1.124
	OPENBSD_5_9:1.118.0.2
	OPENBSD_5_9_BASE:1.118
	OPENBSD_5_8:1.114.0.4
	OPENBSD_5_8_BASE:1.114
	OPENBSD_5_7:1.113.0.2
	OPENBSD_5_7_BASE:1.113
	OPENBSD_5_6:1.111.0.4
	OPENBSD_5_6_BASE:1.111
	OPENBSD_5_5:1.108.0.4
	OPENBSD_5_5_BASE:1.108
	OPENBSD_5_4:1.95.0.6
	OPENBSD_5_4_BASE:1.95
	OPENBSD_5_3:1.95.0.4
	OPENBSD_5_3_BASE:1.95
	OPENBSD_5_2:1.95.0.2
	OPENBSD_5_2_BASE:1.95
	OPENBSD_5_1_BASE:1.94
	OPENBSD_5_1:1.94.0.2
	OPENBSD_5_0:1.93.0.4
	OPENBSD_5_0_BASE:1.93
	OPENBSD_4_9:1.93.0.2
	OPENBSD_4_9_BASE:1.93
	OPENBSD_4_8:1.88.0.2
	OPENBSD_4_8_BASE:1.88
	OPENBSD_4_7:1.78.0.2
	OPENBSD_4_7_BASE:1.78
	OPENBSD_4_6:1.66.0.4
	OPENBSD_4_6_BASE:1.66
	OPENBSD_4_5:1.62.0.2
	OPENBSD_4_5_BASE:1.62
	OPENBSD_4_4:1.58.0.2
	OPENBSD_4_4_BASE:1.58
	OPENBSD_4_3:1.51.0.2
	OPENBSD_4_3_BASE:1.51
	OPENBSD_4_2:1.48.0.2
	OPENBSD_4_2_BASE:1.48
	OPENBSD_4_1:1.14.0.2
	OPENBSD_4_1_BASE:1.14
	OPENBSD_4_0:1.13.0.2
	OPENBSD_4_0_BASE:1.13;
locks; strict;
comment	@# @;


1.145
date	2017.06.20.18.05.44;	author espie;	state Exp;
branches;
next	1.144;
commitid	a4ithGTNpKWfLO0V;

1.144
date	2017.05.29.12.54.05;	author espie;	state Exp;
branches;
next	1.143;
commitid	0iHHIkpVNLLsaOvN;

1.143
date	2017.05.18.12.24.15;	author espie;	state Exp;
branches;
next	1.142;
commitid	Padq7bNQdWrGtjzv;

1.142
date	2017.03.11.11.25.01;	author espie;	state Exp;
branches;
next	1.141;
commitid	k6Bnb18Aa8kAcKqT;

1.141
date	2017.03.07.14.19.32;	author espie;	state Exp;
branches;
next	1.140;
commitid	a4hGW2HN8vlZMze4;

1.140
date	2017.02.06.16.12.16;	author espie;	state Exp;
branches;
next	1.139;
commitid	JqF1KgZVSvceFItn;

1.139
date	2017.01.25.14.07.36;	author espie;	state Exp;
branches;
next	1.138;
commitid	AQcUW0BLkW1pJ25b;

1.138
date	2016.10.05.13.50.20;	author espie;	state Exp;
branches;
next	1.137;
commitid	ogJcfbHVqVRVeyPJ;

1.137
date	2016.10.04.14.46.13;	author espie;	state Exp;
branches;
next	1.136;
commitid	u2LtcBQy8k697vi6;

1.136
date	2016.10.03.14.15.55;	author espie;	state Exp;
branches;
next	1.135;
commitid	4Eo9wuSrk4MGj9WT;

1.135
date	2016.09.15.12.53.08;	author espie;	state Exp;
branches;
next	1.134;
commitid	T32lHWrXXaHrnk35;

1.134
date	2016.09.14.14.14.22;	author espie;	state Exp;
branches;
next	1.133;
commitid	6lOgjJkAiRMRHn41;

1.133
date	2016.09.14.13.42.19;	author espie;	state Exp;
branches;
next	1.132;
commitid	zj6Hy6ytm5K6ku2B;

1.132
date	2016.09.14.12.48.58;	author espie;	state Exp;
branches;
next	1.131;
commitid	hmW3vzD57ooMjMU0;

1.131
date	2016.09.14.12.35.40;	author espie;	state Exp;
branches;
next	1.130;
commitid	quF9U4bdOhTqIU0R;

1.130
date	2016.09.14.12.30.52;	author espie;	state Exp;
branches;
next	1.129;
commitid	W5GSBYuYV4xzBHFq;

1.129
date	2016.09.06.12.41.23;	author espie;	state Exp;
branches;
next	1.128;
commitid	axDlvdkCxdxrDoYO;

1.128
date	2016.09.04.14.01.31;	author espie;	state Exp;
branches;
next	1.127;
commitid	7B8DXNhwaXaj31Ou;

1.127
date	2016.09.04.12.51.44;	author espie;	state Exp;
branches;
next	1.126;
commitid	Z4KMEefKKKK9UPtq;

1.126
date	2016.09.04.12.08.49;	author espie;	state Exp;
branches;
next	1.125;
commitid	FzUsHEbzjmXlu7Kf;

1.125
date	2016.07.27.12.57.10;	author espie;	state Exp;
branches;
next	1.124;
commitid	51E5ozcGSOEKhpf0;

1.124
date	2016.06.27.08.38.15;	author espie;	state Exp;
branches;
next	1.123;
commitid	AoxR5Z3DJlQckd9O;

1.123
date	2016.04.25.10.53.13;	author espie;	state Exp;
branches;
next	1.122;
commitid	1qr63krW5zMHrlYC;

1.122
date	2016.04.25.10.45.54;	author espie;	state Exp;
branches;
next	1.121;
commitid	9ysaFNehJVbiNaFe;

1.121
date	2016.04.16.11.00.42;	author espie;	state Exp;
branches;
next	1.120;
commitid	sW36QFXXEVccHqyW;

1.120
date	2016.03.26.22.04.08;	author sthen;	state Exp;
branches;
next	1.119;
commitid	IEhN2q8sCV3u7Z0q;

1.119
date	2016.03.18.11.33.40;	author espie;	state Exp;
branches;
next	1.118;
commitid	5G7gEFkREDg3hSdv;

1.118
date	2016.02.23.17.45.43;	author espie;	state Exp;
branches;
next	1.117;
commitid	pQeyYoNjHtKO2qcP;

1.117
date	2016.02.09.10.02.27;	author espie;	state Exp;
branches;
next	1.116;
commitid	rkKUVOV7KklGK3ou;

1.116
date	2016.02.09.09.59.39;	author espie;	state Exp;
branches;
next	1.115;
commitid	aWgWss9MQpcXSv7u;

1.115
date	2016.01.30.11.29.29;	author espie;	state Exp;
branches;
next	1.114;
commitid	2wS0pE1OgZTaZHle;

1.114
date	2015.07.12.14.52.17;	author espie;	state Exp;
branches;
next	1.113;
commitid	RQEziz3d2FEU5pJq;

1.113
date	2015.03.04.13.55.32;	author espie;	state Exp;
branches;
next	1.112;
commitid	23nA8DerE0x6I5Dv;

1.112
date	2015.02.03.10.26.29;	author espie;	state Exp;
branches;
next	1.111;
commitid	hXQolFOeWQ48akSA;

1.111
date	2014.07.13.17.24.06;	author espie;	state Exp;
branches;
next	1.110;
commitid	JoDiaCRt4wN8ZyJj;

1.110
date	2014.03.18.18.53.29;	author espie;	state Exp;
branches;
next	1.109;

1.109
date	2014.03.07.09.44.11;	author espie;	state Exp;
branches;
next	1.108;

1.108
date	2014.02.08.11.07.33;	author espie;	state Exp;
branches;
next	1.107;

1.107
date	2014.02.07.14.06.43;	author espie;	state Exp;
branches;
next	1.106;

1.106
date	2014.02.06.22.58.26;	author espie;	state Exp;
branches;
next	1.105;

1.105
date	2014.02.02.23.09.56;	author espie;	state Exp;
branches;
next	1.104;

1.104
date	2014.01.30.13.18.10;	author espie;	state Exp;
branches;
next	1.103;

1.103
date	2014.01.17.13.41.47;	author espie;	state Exp;
branches;
next	1.102;

1.102
date	2014.01.13.18.44.41;	author espie;	state Exp;
branches;
next	1.101;

1.101
date	2014.01.12.20.23.29;	author phessler;	state Exp;
branches;
next	1.100;

1.100
date	2014.01.09.20.20.01;	author espie;	state Exp;
branches;
next	1.99;

1.99
date	2014.01.09.17.41.41;	author espie;	state Exp;
branches;
next	1.98;

1.98
date	2014.01.09.10.43.13;	author espie;	state Exp;
branches;
next	1.97;

1.97
date	2013.12.23.16.55.00;	author jca;	state Exp;
branches;
next	1.96;

1.96
date	2013.12.08.12.53.23;	author jca;	state Exp;
branches;
next	1.95;

1.95
date	2012.04.28.15.22.49;	author espie;	state Exp;
branches;
next	1.94;

1.94
date	2011.08.26.08.46.10;	author espie;	state Exp;
branches;
next	1.93;

1.93
date	2010.12.24.09.04.14;	author espie;	state Exp;
branches;
next	1.92;

1.92
date	2010.12.18.10.37.53;	author espie;	state Exp;
branches;
next	1.91;

1.91
date	2010.11.22.10.26.04;	author espie;	state Exp;
branches;
next	1.90;

1.90
date	2010.10.27.14.35.56;	author espie;	state Exp;
branches;
next	1.89;

1.89
date	2010.08.13.11.12.04;	author espie;	state Exp;
branches;
next	1.88;

1.88
date	2010.07.27.09.09.43;	author espie;	state Exp;
branches;
next	1.87;

1.87
date	2010.07.26.10.59.32;	author espie;	state Exp;
branches;
next	1.86;

1.86
date	2010.07.02.12.41.43;	author espie;	state Exp;
branches;
next	1.85;

1.85
date	2010.07.02.11.44.14;	author espie;	state Exp;
branches;
next	1.84;

1.84
date	2010.07.02.11.17.46;	author espie;	state Exp;
branches;
next	1.83;

1.83
date	2010.06.30.10.51.04;	author espie;	state Exp;
branches;
next	1.82;

1.82
date	2010.06.30.10.41.42;	author espie;	state Exp;
branches;
next	1.81;

1.81
date	2010.06.30.10.05.54;	author espie;	state Exp;
branches;
next	1.80;

1.80
date	2010.06.04.17.51.15;	author espie;	state Exp;
branches;
next	1.79;

1.79
date	2010.05.10.09.17.55;	author espie;	state Exp;
branches;
next	1.78;

1.78
date	2010.01.10.11.32.41;	author espie;	state Exp;
branches;
next	1.77;

1.77
date	2010.01.09.14.49.53;	author espie;	state Exp;
branches;
next	1.76;

1.76
date	2010.01.09.13.42.03;	author espie;	state Exp;
branches;
next	1.75;

1.75
date	2010.01.09.12.01.57;	author espie;	state Exp;
branches;
next	1.74;

1.74
date	2010.01.09.11.26.58;	author espie;	state Exp;
branches;
next	1.73;

1.73
date	2010.01.09.10.59.48;	author espie;	state Exp;
branches;
next	1.72;

1.72
date	2010.01.09.10.44.41;	author espie;	state Exp;
branches;
next	1.71;

1.71
date	2010.01.09.10.17.09;	author espie;	state Exp;
branches;
next	1.70;

1.70
date	2010.01.09.09.58.49;	author espie;	state Exp;
branches;
next	1.69;

1.69
date	2010.01.09.09.45.40;	author espie;	state Exp;
branches;
next	1.68;

1.68
date	2009.10.13.11.49.25;	author espie;	state Exp;
branches;
next	1.67;

1.67
date	2009.08.24.21.24.06;	author sthen;	state Exp;
branches;
next	1.66;

1.66
date	2009.05.11.19.51.27;	author sthen;	state Exp;
branches;
next	1.65;

1.65
date	2009.04.24.23.22.20;	author espie;	state Exp;
branches;
next	1.64;

1.64
date	2009.04.19.15.18.23;	author espie;	state Exp;
branches;
next	1.63;

1.63
date	2009.04.19.14.58.32;	author espie;	state Exp;
branches;
next	1.62;

1.62
date	2009.02.02.20.41.47;	author espie;	state Exp;
branches;
next	1.61;

1.61
date	2008.12.11.15.43.19;	author espie;	state Exp;
branches;
next	1.60;

1.60
date	2008.10.25.22.28.42;	author bernd;	state Exp;
branches;
next	1.59;

1.59
date	2008.10.20.10.25.16;	author espie;	state Exp;
branches;
next	1.58;

1.58
date	2008.07.04.10.47.13;	author espie;	state Exp;
branches;
next	1.57;

1.57
date	2008.07.03.18.45.51;	author sturm;	state Exp;
branches;
next	1.56;

1.56
date	2008.06.25.12.42.59;	author espie;	state Exp;
branches;
next	1.55;

1.55
date	2008.06.18.12.12.14;	author espie;	state Exp;
branches;
next	1.54;

1.54
date	2008.06.13.15.19.06;	author espie;	state Exp;
branches;
next	1.53;

1.53
date	2008.05.26.17.38.54;	author espie;	state Exp;
branches;
next	1.52;

1.52
date	2008.05.16.18.31.47;	author espie;	state Exp;
branches;
next	1.51;

1.51
date	2008.03.04.19.18.37;	author ckuethe;	state Exp;
branches;
next	1.50;

1.50
date	2008.02.06.20.22.19;	author bernd;	state Exp;
branches;
next	1.49;

1.49
date	2007.08.23.09.09.49;	author espie;	state Exp;
branches;
next	1.48;

1.48
date	2007.06.23.17.55.12;	author espie;	state Exp;
branches;
next	1.47;

1.47
date	2007.06.16.09.37.31;	author espie;	state Exp;
branches;
next	1.46;

1.46
date	2007.06.16.09.29.37;	author espie;	state Exp;
branches;
next	1.45;

1.45
date	2007.06.12.09.53.36;	author espie;	state Exp;
branches;
next	1.44;

1.44
date	2007.06.10.14.25.18;	author espie;	state Exp;
branches;
next	1.43;

1.43
date	2007.06.06.14.06.18;	author espie;	state Exp;
branches;
next	1.42;

1.42
date	2007.06.04.18.55.47;	author espie;	state Exp;
branches;
next	1.41;

1.41
date	2007.06.04.18.52.02;	author espie;	state Exp;
branches;
next	1.40;

1.40
date	2007.06.04.14.40.39;	author espie;	state Exp;
branches;
next	1.39;

1.39
date	2007.05.30.11.04.31;	author espie;	state Exp;
branches;
next	1.38;

1.38
date	2007.05.19.09.18.55;	author espie;	state Exp;
branches;
next	1.37;

1.37
date	2007.05.18.13.22.06;	author espie;	state Exp;
branches;
next	1.36;

1.36
date	2007.05.17.18.59.38;	author espie;	state Exp;
branches;
next	1.35;

1.35
date	2007.05.17.18.52.58;	author espie;	state Exp;
branches;
next	1.34;

1.34
date	2007.05.17.18.17.20;	author espie;	state Exp;
branches;
next	1.33;

1.33
date	2007.05.14.12.49.27;	author espie;	state Exp;
branches;
next	1.32;

1.32
date	2007.05.14.12.18.49;	author espie;	state Exp;
branches;
next	1.31;

1.31
date	2007.05.14.10.12.24;	author espie;	state Exp;
branches;
next	1.30;

1.30
date	2007.05.14.10.00.08;	author espie;	state Exp;
branches;
next	1.29;

1.29
date	2007.05.13.17.00.02;	author espie;	state Exp;
branches;
next	1.28;

1.28
date	2007.05.13.13.37.00;	author espie;	state Exp;
branches;
next	1.27;

1.27
date	2007.05.13.13.32.36;	author espie;	state Exp;
branches;
next	1.26;

1.26
date	2007.05.13.12.58.54;	author espie;	state Exp;
branches;
next	1.25;

1.25
date	2007.05.13.09.31.24;	author espie;	state Exp;
branches;
next	1.24;

1.24
date	2007.05.12.15.00.30;	author espie;	state Exp;
branches;
next	1.23;

1.23
date	2007.05.12.14.52.26;	author espie;	state Exp;
branches;
next	1.22;

1.22
date	2007.05.12.14.16.38;	author espie;	state Exp;
branches;
next	1.21;

1.21
date	2007.05.12.13.36.54;	author espie;	state Exp;
branches;
next	1.20;

1.20
date	2007.05.08.08.44.17;	author espie;	state Exp;
branches;
next	1.19;

1.19
date	2007.05.07.14.29.24;	author espie;	state Exp;
branches;
next	1.18;

1.18
date	2007.05.07.14.21.39;	author espie;	state Exp;
branches;
next	1.17;

1.17
date	2007.05.07.09.32.51;	author espie;	state Exp;
branches;
next	1.16;

1.16
date	2007.05.02.15.05.30;	author espie;	state Exp;
branches;
next	1.15;

1.15
date	2007.04.15.10.17.29;	author espie;	state Exp;
branches;
next	1.14;

1.14
date	2006.11.17.15.34.15;	author espie;	state Exp;
branches;
next	1.13;

1.13
date	2006.09.16.15.04.23;	author espie;	state Exp;
branches;
next	1.12;

1.12
date	2006.03.13.16.08.12;	author espie;	state Exp;
branches;
next	1.11;

1.11
date	2006.03.08.12.10.47;	author espie;	state Exp;
branches;
next	1.10;

1.10
date	2006.03.08.11.22.02;	author espie;	state Exp;
branches;
next	1.9;

1.9
date	2006.03.07.17.25.47;	author espie;	state Exp;
branches;
next	1.8;

1.8
date	2006.03.07.15.00.15;	author bernd;	state Exp;
branches;
next	1.7;

1.7
date	2006.03.07.14.18.51;	author espie;	state Exp;
branches;
next	1.6;

1.6
date	2006.03.07.14.00.21;	author espie;	state Exp;
branches;
next	1.5;

1.5
date	2006.03.07.10.59.27;	author espie;	state Exp;
branches;
next	1.4;

1.4
date	2006.03.06.12.00.28;	author espie;	state Exp;
branches;
next	1.3;

1.3
date	2006.03.06.11.22.13;	author espie;	state Exp;
branches;
next	1.2;

1.2
date	2006.03.06.10.40.31;	author espie;	state Exp;
branches;
next	1.1;

1.1
date	2006.03.04.13.13.05;	author espie;	state Exp;
branches;
next	;


desc
@@


1.145
log
@trim more error messages
- if we can't retrieve the package, of course signify will say it's truncated
so that's redundant.
- if you give a full package name, can_be_empty should make directories
vanish.

(landry just discovered 6.1/packages-stable by accident, make it vanish
again so he can't find it back... :D )
@
text
@# ex:ts=8 sw=4:
# $OpenBSD: PackageRepository.pm,v 1.144 2017/05/29 12:54:05 espie Exp $
#
# Copyright (c) 2003-2010 Marc Espie <espie@@openbsd.org>
#
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

use strict;
use warnings;

# XXX load extra class, grab match from Base class, and tweak inheritance
# to get all methods.

use OpenBSD::PackageRepository::Installed;
$OpenBSD::PackageRepository::Installed::ISA = qw(OpenBSD::PackageRepository);

package OpenBSD::PackageRepository;
our @@ISA=(qw(OpenBSD::PackageRepositoryBase));

use OpenBSD::PackageLocation;
use OpenBSD::Paths;
use OpenBSD::Error;
use OpenBSD::Temp;

sub make_error_file
{
	my ($self, $object) = @@_;
	$object->{errors} = OpenBSD::Temp->file;
	if (!defined $object->{errors}) {
		$self->{state}->fatal("#1 not writable",
		    $OpenBSD::Temp::tempbase);
	}
}

sub baseurl
{
	my $self = shift;

	return $self->{path};
}

sub new
{
	my ($class, $baseurl, $state) = @@_;
	my $o = $class->parse(\$baseurl, $state);
	if ($baseurl ne '') {
		return undef;
	}
	return $o;
}

sub can_be_empty
{
	my $self = shift;
	$self->{empty_okay} = 1;
	return $self;
}

my $cache = {};

sub unique
{
	my ($class, $o) = @@_;
	return $o unless defined $o;
	if (defined $cache->{$o->url}) {
		return $cache->{$o->url};
	}
	$cache->{$o->url} = $o;
	return $o;
}

my $cleanup = sub {
	for my $repo (values %$cache) {
		$repo->cleanup;
	}
};
END {
	&$cleanup;
}

OpenBSD::Handler->register($cleanup);

sub parse_fullurl
{
	my ($class, $r, $state) = @@_;

	$class->strip_urlscheme($r) or return undef;
	return $class->unique($class->parse_url($r, $state));
}

sub dont_cleanup
{
}

sub ftp() { 'OpenBSD::PackageRepository::FTP' }
sub http() { 'OpenBSD::PackageRepository::HTTP' }
sub https() { 'OpenBSD::PackageRepository::HTTPS' }
sub scp() { 'OpenBSD::PackageRepository::SCP' }
sub file() { 'OpenBSD::PackageRepository::Local' }
sub installed() { 'OpenBSD::PackageRepository::Installed' }

sub parse
{
	my ($class, $r, $state) = @@_;

	{
	no warnings qw(uninitialized);	# in case installpath is empty
	$$r =~ s/^installpath(\:|$)/$state->installpath.$1/e;
	}

	my $u = $$r;
	return undef if $u eq '';

		

	if ($u =~ m/^ftp\:/io) {
		return $class->ftp->parse_fullurl($r, $state);
	} elsif ($u =~ m/^http\:/io) {
#		require OpenBSD::PackageRepository::HTTP;

		return $class->http->parse_fullurl($r, $state);
	} elsif ($u =~ m/^https\:/io) {
		return $class->https->parse_fullurl($r, $state);
	} elsif ($u =~ m/^scp\:/io) {
		return undef if $state->defines("NO_SCP");

		require OpenBSD::PackageRepository::SCP;

		return $class->scp->parse_fullurl($r, $state);
	} elsif ($u =~ m/^file\:/io) {
		return $class->file->parse_fullurl($r, $state);
	} elsif ($u =~ m/^inst\:$/io) {
		return $class->installed->parse_fullurl($r, $state);
	} else {
		if ($$r =~ m/^([a-z0-9][a-z0-9.]+\.[a-z0-9.]+)(\:|$)/ 
		    && !-d $1) {
			$$r =~ s//http:\/\/$1\/%m$2/;
			return $class->http->parse_fullurl($r, $state);
		}
		return $class->file->parse_fullurl($r, $state);
	}
}

sub available
{
	my $self = shift;

	return @@{$self->list};
}

sub stemlist
{
	my $self = shift;
	if (!defined $self->{stemlist}) {
		require OpenBSD::PackageName;
		my @@l = $self->available;
		if (@@l == 0 && !$self->{empty_okay}) {
			$self->{state}->errsay("#1: #2", $self->url,
				$self->{no_such_dir} ? "no such dir" : "empty");
		}
		$self->{stemlist} = OpenBSD::PackageName::avail2stems(@@l);
	}
	return $self->{stemlist};
}

sub wipe_info
{
	my ($self, $pkg) = @@_;

	require File::Path;

	my $dir = $pkg->{dir};
	if (defined $dir) {
		OpenBSD::Error->rmtree($dir);
		OpenBSD::Temp->reclaim($dir);
		delete $pkg->{dir};
	}
}

# by default, all objects may exist
sub may_exist
{
	return 1;
}

# by default, we don't track opened files for this key

sub opened
{
	undef;
}

# hint: 0 premature close, 1 real error. undef, normal !

sub close
{
	my ($self, $object, $hint) = @@_;
	close($object->{fh}) if defined $object->{fh};
	if (defined $object->{pid2}) {
		local $SIG{ALRM} = sub {
			kill HUP => $object->{pid2};
		};
		alarm(30);
		waitpid($object->{pid2}, 0);
		alarm(0);
	}
	$self->parse_problems($object->{errors}, $hint, $object)
	    if defined $object->{errors};
	undef $object->{errors};
	$object->deref;
}

sub make_room
{
	my $self = shift;

	# kill old files if too many
	my $already = $self->opened;
	if (defined $already) {
		# gc old objects
		if (@@$already >= $self->maxcount) {
			@@$already = grep { defined $_->{fh} } @@$already;
		}
		while (@@$already >= $self->maxcount) {
			my $o = shift @@$already;
			$self->close_now($o);
		}
	}
	return $already;
}

# open method that tracks opened files per-host.
sub open
{
	my ($self, $object) = @@_;

	return unless $self->may_exist($object->{name});

	# kill old files if too many
	my $already = $self->make_room;
	local $SIG{'PIPE'} = 'DEFAULT';
	my $fh = $self->open_pipe($object);
	if (!defined $fh) {
		return;
	}
	$object->{fh} = $fh;
	if (defined $already) {
		push @@$already, $object;
	}
	return $fh;
}

sub find
{
	my ($repository, $name) = @@_;
	my $self = $repository->new_location($name);

	if ($self->contents) {
		return $self;
	}
}

sub grabPlist
{
	my ($repository, $name, $code) = @@_;
	my $self = $repository->new_location($name);

	return $self->grabPlist($code);
}

sub parse_problems
{
	my ($self, $filename, $hint, $object) = @@_;
	CORE::open(my $fh, '<', $filename) or return;

	my $baseurl = $self->url;
	my $url = $baseurl;
	if (defined $object) {
		$url = $object->url;
	}
	my $notyet = 1;
	my $broken = 0;
	my $signify_error = 0;
	$self->{last_error} = 0;
	while(<$fh>) {
		next if m/^(?:200|220|221|226|229|230|227|250|331|500|150)[\s\-]/o;
		next if m/^EPSV command not understood/o;
		next if m/^Trying [\da-f\.\:]+\.\.\./o;
		next if m/^Requesting \Q$baseurl\E/;
		next if m/^Remote system type is\s+/o;
		next if m/^Connected to\s+/o;
		next if m/^remote\:\s+/o;
		next if m/^Using binary mode to transfer files/o;
		next if m/^Retrieving\s+/o;
		next if m/^Success?fully retrieved file/o;
		next if m/^\d+\s+bytes\s+received\s+in/o;
		next if m/^ftp: connect to address.*: No route to host/o;
		if (m/^ftp: Writing -: Broken pipe/o) {
			$broken = 1;
			next;
		}
		# http error
		if (m/^ftp: Error retrieving file: 404/o) {
			if (!defined $object) {
				$self->{no_such_dir} = 1;
				next;
			} else {
				$self->{lasterror} = 404;
			}
			# ignore errors for stable packages
			next if $self->can_be_empty;
		}

		if (defined $hint && $hint == 0) {
			next if m/^ftp: -: short write/o;
			next if m/^ftp: local: -: Broken pipe/o;
			next if m/^421\s+/o;
		}
		# not retrieving the file => always the same message
		# so it's superfluous
		next if m/^signify:/ && $self->{lasterror};
		if ($notyet) {
			$self->{state}->errprint("#1: ", $url);
			if (defined $object) {
				$object->{error_reported} = 1;
			}
			$notyet = 0;
		}
		if (m/^signify:/) {
			$signify_error = 1;
			s/.*unsigned .*archive.*/unsigned package (signify(1) doesn't see old-style signatures)/;
		}
		if (m/^421\s+/o ||
		    m/^ftp: connect: Connection timed out/o ||
		    m/^ftp: Can't connect or login to host/o) {
			$self->{lasterror} = 421;
		}
		if (m/^550\s+/o) {
			$self->{lasterror} = 550;
		}
		$self->{state}->errprint("#1", $_);
	}
	if ($broken) {
		unless ($signify_error || defined $hint && $hint == 0) { 
			$self->{state}->errprint('#1', "ftp: Broken pipe");
		}
	}
	CORE::close($fh);
	OpenBSD::Temp->reclaim($filename);
	unlink $filename;
}

sub cleanup
{
	# nothing to do
}

sub relative_url
{
	my ($self, $name) = @@_;
	if (defined $name) {
		return $self->baseurl.$name.".tgz";
	} else {
		return $self->baseurl;
	}
}

sub add_to_list
{
	my ($self, $list, $filename) = @@_;
	if ($filename =~ m/^(.*\-\d.*)\.tgz$/o) {
		push(@@$list, $1);
	}
}

sub did_it_fork
{
	my ($self, $pid) = @@_;
	if (!defined $pid) {
		$self->{state}->fatal("Cannot fork: #1", $!);
	}
	if ($pid == 0) {
		delete $SIG{'WINCH'};
		delete $SIG{'CONT'};
		delete $SIG{'INFO'};
	}
}

sub uncompress
{
	my $self = shift;
	my $object = shift;
	require IO::Uncompress::Gunzip;
	my $fh = IO::Uncompress::Gunzip->new(@@_, MultiStream => 1);
	my $result = "";
	if ($object->{is_signed}) {
		my $h = $fh->getHeaderInfo;
		if ($h) {
			for my $line (split /\n/, $h->{Comment}) {
				if ($line =~ m/^key=.*\/(.*)\.sec$/) {
					$result .= "\@@signer $1\n";
				} elsif ($line =~ m/^date=(.*)$/) {
					$result .= "\@@digital-signature signify2:$1:external\n";
				}
			}
		} else {
			$fh->close;
			return undef;
		}
	}
	$object->{extra_content} = $result;
	return $fh;
}

sub signify_pipe
{
	my $self = shift;
	my $object = shift;
	CORE::open STDERR, ">>", $object->{errors};
	exec {OpenBSD::Paths->signify}
	    ("signify",
	    "-zV",
	    @@_)
	or $self->{state}->fatal("Can't run #1: #2",
	    OpenBSD::Paths->signify, $!);
}

sub check_signed
{
	my ($self, $object) = @@_;
	if ($object->{repository}{trusted}) {
		return 0;
	}
	if ($self->{state}{signature_style} eq 'new') {
		$object->{is_signed} = 1;
		return 1;
	} else {
		return 0;
	}
}

package OpenBSD::PackageRepository::Local;
our @@ISA=qw(OpenBSD::PackageRepository);
use OpenBSD::Error;

sub is_local_file
{
	return 1;
}

sub urlscheme
{
	return 'file';
}

my $pkg_db;

sub pkg_db
{
	if (!defined $pkg_db) {
		use OpenBSD::Paths;
		$pkg_db = $ENV{"PKG_DBDIR"} || OpenBSD::Paths->pkgdb;
	}
	return $pkg_db;
}

sub parse_fullurl
{
	my ($class, $r, $state) = @@_;

	my $ok = $class->strip_urlscheme($r);
	my $o = $class->parse_url($r, $state);
	if (!$ok && $o->{path} eq $class->pkg_db."/") {
		return $class->installed->new(0, $state);
	} else {
		if ($o->{path} eq './') {
			$o->can_be_empty;
		}
		return $class->unique($o);
	}
}

# wrapper around copy, that sometimes does not copy
sub may_copy
{
	my ($self, $object, $destdir) = @@_;
	my $src = $self->relative_url($object->{name});
	require File::Spec;
	my (undef, undef, $base) = File::Spec->splitpath($src);
	my $dest = File::Spec->catfile($destdir, $base);
	if (File::Spec->canonpath($dest) eq File::Spec->canonpath($src)) {
	    	return;
	}
	if (-f $dest) {
		my ($ddev, $dino) = (stat $dest)[0,1];
		my ($sdev, $sino) = (stat $src)[0, 1];
		if ($ddev == $sdev and $sino == $dino) {
			return;
		}
	}
	$self->{state}->copy_file($src, $destdir);
}

sub open_pipe
{
	my ($self, $object) = @@_;
	if (defined $ENV{'PKG_CACHE'}) {
		$self->may_copy($object, $ENV{'PKG_CACHE'});
	}
	my $name = $self->relative_url($object->{name});
	if ($self->check_signed($object)) {
		$self->make_error_file($object);
		my $pid = open(my $fh, "-|");
		$self->did_it_fork($pid);
		if ($pid) {
			$object->{pid} = $pid;
			return $self->uncompress($object, $fh);
		} else {
			$self->signify_pipe($object, "-x", $name);
		}
	} else {
		return $self->uncompress($object, $name);
	}
}

sub may_exist
{
	my ($self, $name) = @@_;
	return -r $self->relative_url($name);
}

my $local = [];

sub opened
{
	return $local;
}

sub maxcount
{
	return 3;
}

sub list
{
	my $self = shift;
	my $l = [];
	my $dname = $self->baseurl;
	opendir(my $dir, $dname) or return $l;
	while (my $e = readdir $dir) {
		next unless -f "$dname/$e";
		$self->add_to_list($l, $e);
	}
	close($dir);
	return $l;
}

package OpenBSD::PackageRepository::Distant;
our @@ISA=qw(OpenBSD::PackageRepository);

sub baseurl
{
	my $self = shift;

	return "//$self->{host}$self->{path}";
}

sub parse_url
{
	my ($class, $r, $state) = @@_;
	# same heuristics as ftp(1):
	# find host part, rest is parsed as a local url
	if (my ($host, $path) = $$r =~ m/^\/\/(.*?)(\/.*)$/) {

		$$r = $path;
		my $o = $class->SUPER::parse_url($r, $state);
		$o->{host} = $host;
		if (defined $o->{release}) {
			$o->can_be_empty;
			$$r = $class->urlscheme."://$o->{host}$o->{release}:$$r";
		}
		return $o;
	} else {
		return undef;
	}
}

my $buffsize = 2 * 1024 * 1024;

sub pkg_copy
{
	my ($self, $in, $object) = @@_;

	my $name = $object->{name};
	my $dir = $object->{cache_dir};

	my ($copy, $filename) = OpenBSD::Temp::permanent_file($dir, $name) or die "Can't write copy to cache";
	chmod((0666 & ~umask), $filename);
	$object->{tempname} = $filename;
	my $handler = sub {
		my ($sig) = @@_;
		unlink $filename;
		close($in);
		$SIG{$sig} = 'DEFAULT';
		kill $sig, $$;
	};

	my $nonempty = 0;
	my $error = 0;
	{

	local $SIG{'PIPE'} =  $handler;
	local $SIG{'INT'} =  $handler;
	local $SIG{'HUP'} =  $handler;
	local $SIG{'QUIT'} =  $handler;
	local $SIG{'KILL'} =  $handler;
	local $SIG{'TERM'} =  $handler;

	my ($buffer, $n);
	# copy stuff over
	do {
		$n = sysread($in, $buffer, $buffsize);
		if (!defined $n) {
			$self->{state}->fatal("Error reading: #1", $!);
		}
		if ($n > 0) {
			$nonempty = 1;
		}
		if (!$error) {
			my $r = syswrite $copy, $buffer;
			if (!defined $r || $r < $n) {
				$error = 1;
			}
		}
		syswrite STDOUT, $buffer;
	} while ($n != 0);
	close($copy);
	}

	if ($nonempty && !$error) {
		rename $filename, "$dir/$name.tgz";
	} else {
		unlink $filename;
	}
	close($in);
}

sub open_pipe
{
	my ($self, $object) = @@_;
	$self->make_error_file($object);
	my $d = $ENV{'PKG_CACHE'};
	if (defined $d) {
		$object->{cache_dir} = $d;
		if (! -d -w $d) {
			$self->{state}->fatal("bad PKG_CACHE directory #1", $d);
		}
		$object->{cache_dir} = $d;
	}
	$object->{parent} = $$;

	my ($rdfh, $wrfh);

	pipe($rdfh, $wrfh);
	my $pid2 = fork();
	$self->did_it_fork($pid2);
	if ($pid2) {
		$object->{pid2} = $pid2;
		close($wrfh);
	} else {
		open STDERR, '>>', $object->{errors};
		open(STDOUT, '>&', $wrfh);
		close($rdfh);
		close($wrfh);
		if (defined $d) {
			my $pid3 = open(my $in, "-|");
			$self->did_it_fork($pid3);
			if ($pid3) {
				$self->dont_cleanup;
				$self->pkg_copy($in, $object);
			} else {
				$self->grab_object($object);
			}
		} else {
			$self->grab_object($object);
		}
		exit(0);
	}

	if ($self->check_signed($object)) {
		my $pid = open(my $fh, "-|");
		$self->did_it_fork($pid);
		if ($pid) {
			$object->{pid} = $pid;
			close($rdfh);
		} else {
			open(STDIN, '<&', $rdfh) or
			    $self->{state}->fatal("Bad dup: #1", $!);
			close($rdfh);
			$self->signify_pipe($object);
		}

		return $self->uncompress($object, $fh);
	} else {
		return $self->uncompress($object, $rdfh);
	}
}

sub finish_and_close
{
	my ($self, $object) = @@_;
	if (defined $object->{cache_dir}) {
		while (defined $object->next) {
		}
	}
	$self->SUPER::finish_and_close($object);
}

package OpenBSD::PackageRepository::HTTPorFTP;
our @@ISA=qw(OpenBSD::PackageRepository::Distant);

our %distant = ();

sub drop_privileges_and_setup_env
{
	my $self = shift;
	my $user = '_pkgfetch';
	if ($< == 0) {
		# we can't cache anything, we happen after the fork, 
		# right before exec
		if (my (undef, undef, $uid, $gid) = getpwnam($user)) {
			$( = $gid;
			$) = "$gid $gid";
			$< = $uid;
			$> = $uid;
		} else {
			$self->{state}->fatal("Couldn't change identity: can't find #1 user", $user);
		}
	} else {
		($user) = getpwuid($<);
	}
	# create sanitized env for ftp
	my %newenv = (
		HOME => '/var/empty',
		USER => $user,
		LOGNAME => $user,
		SHELL => '/bin/sh',
		LC_ALL => 'C', # especially, laundry error messages
		PATH => '/bin:/usr/bin'
	    );

	# copy selected stuff;
	for my $k (qw(
	    TERM
	    FTPMODE 
	    FTPSERVER
	    FTPSERVERPORT
	    ftp_proxy 
	    http_proxy 
	    http_cookies
	    ALL_PROXY
	    FTP_PROXY
	    HTTPS_PROXY
	    HTTP_PROXY
	    NO_PROXY)) {
	    	if (exists $ENV{$k}) {
			$newenv{$k} = $ENV{$k};
		}
	}
	# don't forget to swap!
	%ENV = %newenv;
}


sub grab_object
{
	my ($self, $object) = @@_;
	my ($ftp, @@extra) = split(/\s+/, OpenBSD::Paths->ftp);
	$self->drop_privileges_and_setup_env;
	exec {$ftp}
	    $ftp,
	    @@extra,
	    "-o",
	    "-", $self->url($object->{name})
	or $self->{state}->fatal("Can't run #1: #2", OpenBSD::Paths->ftp, $!);
}

sub open_read_ftp
{
	my ($self, $cmd, $errors) = @@_;
	my $child_pid = open(my $fh, '-|');
	if ($child_pid) {
		$self->{pipe_pid} = $child_pid;
		return $fh;
	} else {
		open STDERR, '>>', $errors if defined $errors;

		$self->drop_privileges_and_setup_env;
		exec($cmd) 
		or $self->{state}->fatal("Can't run #1: #2", $cmd, $!);
	}
}

sub close_read_ftp
{
	my ($self, $fh) = @@_;
	close($fh);
	waitpid $self->{pipe_pid}, 0;
}

sub maxcount
{
	return 1;
}

sub opened
{
	my $self = $_[0];
	my $k = $self->{host};
	if (!defined $distant{$k}) {
		$distant{$k} = [];
	}
	return $distant{$k};
}

sub should_have
{
	my ($self, $pkgname) = @@_;
	if (defined $self->{lasterror} && $self->{lasterror} == 421) {
		return (defined $self->{list}) &&
			grep { $_ eq $pkgname } @@{$self->{list}};
	} else {
		return 0;
	}
}

sub try_until_success
{
	my ($self, $pkgname, $code) = @@_;

	for (my $retry = 5; $retry <= 160; $retry *= 2) {
		undef $self->{lasterror};
		my $o = &$code;
		if (defined $o) {
			return $o;
		}
		if (defined $self->{lasterror} && 
		    ($self->{lasterror} == 550 || $self->{lasterror} == 404)) {
			last;
		}
		if ($self->should_have($pkgname)) {
			$self->errsay("Temporary error, sleeping #1 seconds",
				$retry);
			sleep($retry);
		}
	}
	return undef;
}

sub find
{
	my ($self, $pkgname, @@extra) = @@_;

	return $self->try_until_success($pkgname,
	    sub {
	    	return $self->SUPER::find($pkgname, @@extra); });

}

sub grabPlist
{
	my ($self, $pkgname, @@extra) = @@_;

	return $self->try_until_success($pkgname,
	    sub {
	    	return $self->SUPER::grabPlist($pkgname, @@extra); });
}

sub list
{
	my ($self) = @@_;
	if (!defined $self->{list}) {
		$self->make_room;
		my $error = OpenBSD::Temp->file;
		if (!defined $error) {
			$self->{state}->fatal("#1 not writable",
			    $OpenBSD::Temp::tempbase);
		}
		$self->{list} = $self->obtain_list($error);
		$self->parse_problems($error);
	}
	return $self->{list};
}

sub get_http_list
{
	my ($self, $error) = @@_;

	my $fullname = $self->url;
	my $l = [];
	my $fh = $self->open_read_ftp(OpenBSD::Paths->ftp." -o - $fullname", 
	    $error) or return;
	while(<$fh>) {
		chomp;
		for my $pkg (m/\<A\s+HREF=\"(.*?\.tgz)\"\>/gio) {
			$pkg = $1 if $pkg =~ m|^.*/(.*)$|;
			# decode uri-encoding; from URI::Escape
			$pkg =~ s/%([0-9A-Fa-f]{2})/chr(hex($1))/eg;
			$self->add_to_list($l, $pkg);
		}
	}
	$self->close_read_ftp($fh);
	return $l;
}

package OpenBSD::PackageRepository::HTTP;
our @@ISA=qw(OpenBSD::PackageRepository::HTTPorFTP);

sub urlscheme
{
	return 'http';
}

sub obtain_list
{
	my ($self, $error) = @@_;
	return $self->get_http_list($error);
}

package OpenBSD::PackageRepository::HTTPS;
our @@ISA=qw(OpenBSD::PackageRepository::HTTP);

sub urlscheme
{
	return 'https';
}

package OpenBSD::PackageRepository::FTP;
our @@ISA=qw(OpenBSD::PackageRepository::HTTPorFTP);

sub urlscheme
{
	return 'ftp';
}

sub _list
{
	my ($self, $cmd, $error) = @@_;
	my $l =[];
	my $fh = $self->open_read_ftp($cmd, $error) or return;
	while(<$fh>) {
		chomp;
		next if m/^\d\d\d\s+\S/;
		if (m/No such file or directory|Failed to change directory/i) {
			$self->{no_such_dir} = 1;
		}
		next unless m/^(?:\.\/)?(\S+\.tgz)\s*$/;
		$self->add_to_list($l, $1);
	}
	$self->close_read_ftp($fh);
	return $l;
}

sub get_ftp_list
{
	my ($self, $error) = @@_;

	my $fullname = $self->url;
	return $self->_list("echo 'nlist'| ".OpenBSD::Paths->ftp
	    ." $fullname", $error);
}

sub obtain_list
{
	my ($self, $error) = @@_;
	if (defined $ENV{'ftp_proxy'} && $ENV{'ftp_proxy'} ne '') {
		return $self->get_http_list($error);
	} else {
		return $self->get_ftp_list($error);
	}
}

1;
@


1.144
log
@do not whine if installpath is undef.
@
text
@d2 1
a2 1
# $OpenBSD: PackageRepository.pm,v 1.143 2017/05/18 12:24:15 espie Exp $
d294 1
d320 2
d329 3
@


1.143
log
@introduce new url "installpath" to mean "the contents of installurl"
use it to simplify logic.

have ./ always be silent, wherever it may come from.

zap NOINSTALLPATH since it's more intuitive to just define PKG_PATH=
(nothing) now.
@
text
@d2 1
a2 1
# $OpenBSD: PackageRepository.pm,v 1.142 2017/03/11 11:25:01 espie Exp $
d116 2
d119 1
@


1.142
log
@tweak %m to expand to %c, and make %c more magical:
on a -stable system, %c/packages will expand to
two directories in support of packages-stable,
with the -stable directory being "silent".

Also add a -Dsnap option that forces %c to be snapshots
so that the last weeks of testing of release are less
painful.

okay aja@@
@
text
@d2 1
a2 1
# $OpenBSD: PackageRepository.pm,v 1.141 2017/03/07 14:19:32 espie Exp $
d115 3
d121 2
d477 3
@


1.141
log
@more error streamlining:
- if we don't have an object for fetch, then we're grabbing a list for http
"not found" means it's not a proper package directory.
- report once for "empty" repositories, and we know the difference between
an empty dir and a non existing directory

- if we have an object, save we already reported an error to avoiding
cascading error reports
@
text
@d2 1
a2 1
# $OpenBSD: PackageRepository.pm,v 1.140 2017/02/06 16:12:16 espie Exp $
d571 4
@


1.140
log
@amend the "unsigned package" message, commenting that signify(1) doesn't
see old-style signatures. Clue for people trying pkg_add -current against
6.0 or earlier.
@
text
@d2 1
a2 1
# $OpenBSD: PackageRepository.pm,v 1.139 2017/01/25 14:07:36 espie Exp $
d160 2
a161 1
			$self->{state}->errsay("#1 is empty", $self->url);
d303 9
d319 4
a322 1
			$self->{state}->errsay("Error from #1", $url);
a333 4
		# http error
		if (m/^ftp: Error retrieving file: 404/o) {
		    	$self->{lasterror} = 404;
		}
a879 6
		if ($self->{no_such_dir}) {
			$self->{state}->errsay(
			    "#1: Directory does not exist on #2",
			    $self->{path}, $self->{host});
		    	$self->{lasterror} = 404;
		}
@


1.139
log
@some run environnement do not properly reset signals (e.g., python) and
as a result pkg_add + signify fails with weird error messages, as it relies
on default SIGPIPE behavior.

Finally fix the problem, sanitize our running environment before forking.

Problem reported by various people.
@
text
@d2 1
a2 1
# $OpenBSD: PackageRepository.pm,v 1.138 2016/10/05 13:50:20 espie Exp $
a307 4
		if (m/^signify:/) {
			$signify_error = 1;
			s/.*unsigned .*archive.*/unsigned package/;
		}
d311 4
@


1.138
log
@getting errors is trivial, just don't forget to close the handle and not
return anything in case signature did fail.
@
text
@d2 1
a2 1
# $OpenBSD: PackageRepository.pm,v 1.137 2016/10/04 14:46:13 espie Exp $
d242 1
@


1.137
log
@slightly smarter parsing of error log
@
text
@d2 1
a2 1
# $OpenBSD: PackageRepository.pm,v 1.136 2016/10/03 14:15:55 espie Exp $
d392 3
@


1.136
log
@add TRUSTED_PKG_PATH after discussing with aja@@
use case is testing binary packages among developers, -Dunsigned means
everything is unsigned, which is bad for dependencies
@
text
@d2 1
a2 1
# $OpenBSD: PackageRepository.pm,v 1.135 2016/09/15 12:53:08 espie Exp $
d282 2
d297 4
a304 1
			next if m/^ftp: Writing -: Broken pipe/o;
d307 4
a310 1
		s/.*unsigned .*archive.*/unsigned package/;
d328 5
@


1.135
log
@move the error saving code slightly around
still not perfect
@
text
@d2 1
a2 1
# $OpenBSD: PackageRepository.pm,v 1.134 2016/09/14 14:14:22 espie Exp $
d401 3
@


1.134
log
@move the check up in state
@
text
@d2 1
a2 1
# $OpenBSD: PackageRepository.pm,v 1.133 2016/09/14 13:42:19 espie Exp $
d33 11
a174 1
		require OpenBSD::Temp;
d302 1
a302 1
		s/.*unsigned archive.*/unsigned package/;
a553 1
	require OpenBSD::Temp;
a607 10
sub make_error_file
{
	my ($self, $object) = @@_;
	$object->{errors} = OpenBSD::Temp->file;
	if (!defined $object->{errors}) {
		$self->{state}->fatal("#1 not writable",
		    $OpenBSD::Temp::tempbase);
	}
}

a609 2
	require OpenBSD::Temp;

@


1.133
log
@add an is_local-file method for later signature
@
text
@d2 1
a2 1
# $OpenBSD: PackageRepository.pm,v 1.132 2016/09/14 12:48:58 espie Exp $
d391 1
a391 2
	# XXX switch not flipped
	if ($self->{state}->defines('newsign')) {
a395 8
	}

	if ($self->{state}->defines('unsigned') ||
	    $self->{state}->defines('oldsign')) {
		return 0;
	} else {
		$object->{is_signed} = 1;
		return 1;
@


1.132
log
@gc pipe: support, makes less and less sense as time goes by
@
text
@d2 1
a2 1
# $OpenBSD: PackageRepository.pm,v 1.131 2016/09/14 12:35:40 espie Exp $
d411 5
@


1.131
log
@tidy running those commands
@
text
@d2 1
a2 1
# $OpenBSD: PackageRepository.pm,v 1.130 2016/09/14 12:30:52 espie Exp $
a99 1
sub pipe() { 'OpenBSD::PackageRepository::Local::Pipe' }
a124 2
	} elsif ($u =~ m/^pipe\:$/io) {
		return $class->pipe->parse_fullurl($r, $state);
a513 42
}

package OpenBSD::PackageRepository::Local::Pipe;
our @@ISA=qw(OpenBSD::PackageRepository::Local);

sub urlscheme
{
	return 'pipe';
}

sub relative_url
{
	return '';
}

sub may_exist
{
	return 1;
}

sub new
{
	my ($class, $state) = @@_;
	return bless { state => $state}, $class;
}

sub open_pipe
{
	my ($self, $object) = @@_;
	if ($self->check_signed($object)) {
		$self->make_error_file($object);
		my $pid = open(my $fh, "-|");
		$self->did_it_fork($pid);
		if ($pid) {
			$object->{pid} = $pid;
			return $self->uncompress_signed($object, $fh);
		} else {
			$self->signify_pipe($object);
		}
    	} else {
		return $self->uncompress($object, \*STDIN);
	}
@


1.130
log
@gc last remnants of source:
@
text
@d2 1
a2 1
# $OpenBSD: PackageRepository.pm,v 1.129 2016/09/06 12:41:23 espie Exp $
d386 3
a388 2
	    @@_);
    	exit(1);
d797 1
a797 1
	or $self->{state}->fatal("Can't run ".OpenBSD::Paths->ftp.": #1", $!);
d812 1
a812 1
		or $self->{state}->fatal("Can't run $cmd: #1", $!);
@


1.129
log
@heck, have new signatures be -Dnewsign until we flip the switch
@
text
@d2 1
a2 1
# $OpenBSD: PackageRepository.pm,v 1.128 2016/09/04 14:01:31 espie Exp $
a97 1
sub source() { 'OpenBSD::PackageRepository::Source' }
@


1.128
log
@put signify errors alongside ftp
@
text
@d2 1
a2 1
# $OpenBSD: PackageRepository.pm,v 1.127 2016/09/04 12:51:44 espie Exp $
d394 8
a401 2
	# XXX not yet
	return 0;
@


1.127
log
@signature tracking bases: stored signed status inside object, so that
we don't erroneously get "signature" comments from unsigned packages.
force the gzip object to get its header.
So if it can't something wrong happened.
for now, we just know shit happened...
@
text
@d2 1
a2 1
# $OpenBSD: PackageRepository.pm,v 1.126 2016/09/04 12:08:49 espie Exp $
d268 48
d362 12
a373 3
	if (!$fh->getHeaderInfo) {
		print STDERR "Bad signed package ", 
		    $self->url($object->{name}), "\n";
d375 1
d382 2
a383 1
	CORE::open STDERR, ">", "/dev/null";
d396 2
a397 1
	if ($self->{state}->defines('unsigned')) {
d467 1
d474 1
a474 1
			$self->signify_pipe( "-x", $name);
d541 1
d548 1
a548 1
			$self->signify_pipe;
d642 1
a642 1
sub open_pipe
a643 2
	require OpenBSD::Temp;

d650 8
d677 1
a677 1
		open STDERR, '>', $object->{errors};
d706 1
a706 1
			$self->signify_pipe;
d802 1
a802 1
		open STDERR, '>', $errors if defined $errors;
a882 53
}

sub parse_problems
{
	my ($self, $filename, $hint, $object) = @@_;
	CORE::open(my $fh, '<', $filename) or return;

	my $baseurl = $self->url;
	my $url = $baseurl;
	if (defined $object) {
		$url = $object->url;
	}
	my $notyet = 1;
	while(<$fh>) {
		next if m/^(?:200|220|221|226|229|230|227|250|331|500|150)[\s\-]/o;
		next if m/^EPSV command not understood/o;
		next if m/^Trying [\da-f\.\:]+\.\.\./o;
		next if m/^Requesting \Q$baseurl\E/;
		next if m/^Remote system type is\s+/o;
		next if m/^Connected to\s+/o;
		next if m/^remote\:\s+/o;
		next if m/^Using binary mode to transfer files/o;
		next if m/^Retrieving\s+/o;
		next if m/^Success?fully retrieved file/o;
		next if m/^\d+\s+bytes\s+received\s+in/o;
		next if m/^ftp: connect to address.*: No route to host/o;

		if (defined $hint && $hint == 0) {
			next if m/^ftp: -: short write/o;
			next if m/^ftp: local: -: Broken pipe/o;
			next if m/^ftp: Writing -: Broken pipe/o;
			next if m/^421\s+/o;
		}
		if ($notyet) {
			$self->{state}->errsay("Error from #1", $url);
			$notyet = 0;
		}
		if (m/^421\s+/o ||
		    m/^ftp: connect: Connection timed out/o ||
		    m/^ftp: Can't connect or login to host/o) {
			$self->{lasterror} = 421;
		}
		# http error
		if (m/^ftp: Error retrieving file: 404/o) {
		    	$self->{lasterror} = 404;
		}
		if (m/^550\s+/o) {
			$self->{lasterror} = 550;
		}
		$self->{state}->errprint("#1", $_);
	}
	CORE::close($fh);
	$self->SUPER::parse_problems($filename, $hint, $object);
@


1.126
log
@basic scaffolding to ask signify to check stuff
still missing some proper error reporting
@
text
@d2 1
a2 1
# $OpenBSD: PackageRepository.pm,v 1.125 2016/07/27 12:57:10 espie Exp $
d311 1
d313 6
a318 1
	return IO::Uncompress::Gunzip->new(@@_, MultiStream => 1);
d321 1
a321 1
sub checksigpipe
d332 1
a332 1
sub checksigned
d334 1
a334 1
	my $self = shift;
d337 6
a342 1
#	return !$self->{state}->defines('unsigned');
d405 2
a406 1
	if ($self->checksigned) {
d411 1
a411 1
			return $self->uncompress($fh);
d413 1
a413 2
			$self->checksigpipe( "-x", 
				$self->relative_url($object->{name}));
d416 1
a416 1
		return $self->uncompress($self->relative_url($object->{name}));
d479 1
a479 1
	if ($self->checksigned) {
d484 1
a484 1
			return $fh;
d486 1
a486 1
			$self->checksigpipe;
d489 1
a489 1
		return $self->uncompress(\*STDIN);
d628 1
a628 1
	if ($self->checksigned) {
d638 1
a638 1
			$self->checksigpipe;
d641 1
a641 1
		return $self->uncompress($fh);
d643 1
a643 1
		return $self->uncompress($rdfh);
@


1.125
log
@hunting around for some sporadic error message. Removing the hash entry
entirely is slightly better.

noticed by sthen@@
@
text
@d2 1
a2 1
# $OpenBSD: PackageRepository.pm,v 1.124 2016/06/27 08:38:15 espie Exp $
d311 21
a331 2
	require IO::Uncompress::AnyUncompress;
	return IO::Uncompress::AnyUncompress->new(@@_, MultiStream => 1);
d394 13
a406 1
	return $self->uncompress($self->relative_url($object->{name}));
d468 12
a479 1
	return $self->uncompress(\*STDIN);
d589 4
a592 1
	my $pid2 = open(my $rdfh, "-|");
d596 1
d599 3
d616 18
a633 1
	return $self->uncompress($rdfh);
@


1.124
log
@surprised nobody noticed before me
let scp:// work with PKG_CACHE
basically, we do an extra fork, so we end up cleaning up the connection twice
that's okay for the handles, but not for the commands, since we do a spurious
ABORT BYE BYE on cleanup.
@
text
@d2 1
a2 1
# $OpenBSD: PackageRepository.pm,v 1.123 2016/04/25 10:53:13 espie Exp $
d302 3
a304 3
		undef $SIG{'WINCH'};
		undef $SIG{'CONT'};
		undef $SIG{'INFO'};
@


1.123
log
@prepare for possible pledging. We can't really drop privs if we're not
running as root, so don't even try.   Also, have the environment reflect
reality in that case.
@
text
@d2 1
a2 1
# $OpenBSD: PackageRepository.pm,v 1.122 2016/04/25 10:45:54 espie Exp $
d90 4
d557 1
@


1.122
log
@now that sysmerge happens before us, no need to fallback on _pfetch
revert previous commit
@
text
@d2 1
a2 1
# $OpenBSD: PackageRepository.pm,v 1.120 2016/03/26 22:04:08 sthen Exp $
d584 11
a594 7
	# we can't cache anything, we happen after the fork, 
	# right before exec
	if (my (undef, undef, $uid, $gid) = getpwnam($user)) {
		$( = $gid;
		$) = "$gid $gid";
		$< = $uid;
		$> = $uid;
d596 1
a596 1
		$self->{state}->fatal("Couldn't change identity: can't find #1 user", $user);
a597 1

@


1.121
log
@fallback to _pfetch after _pkgfetch until sysmerge is run automatically
@
text
@d580 1
a580 1
sub try_drop
d582 4
a585 1
	my ($self, $user) = @@_;
d592 1
a592 1
		return 0;
d594 1
a624 11
	return 1;
}
	
sub drop_privileges_and_setup_env
{
	my $self = shift;
	my $u1 = '_pkgfetch';
	my $u2 = '_pfetch';
	$self->try_drop($u1) or $self->try_drop($u2) or
	    $self->{state}->fatal(
	    	"Couldn't change identity: missing #1 and #2 users", $u1, $u2);
@


1.120
log
@fix error message, based on a suggestion from doug@@, ok espie
@
text
@d2 1
a2 1
# $OpenBSD: PackageRepository.pm,v 1.119 2016/03/18 11:33:40 espie Exp $
d580 1
a580 1
sub drop_privileges_and_setup_env
d582 1
a582 4
	my $self = shift;
	my $user = '_pkgfetch';
	# we can't cache anything, we happen after the fork, 
	# right before exec
d589 1
a589 1
		$self->{state}->fatal("Couldn't change identity: can't find #1 user", $user);
a590 1

d621 11
@


1.119
log
@use properly separated _pkgfetch user.

abort if you can't find it. if you somehow managed NOT to update your
users thru sysmerge or the normal build process, you deserve this.
@
text
@d2 1
a2 1
# $OpenBSD: PackageRepository.pm,v 1.118 2016/02/23 17:45:43 espie Exp $
d582 1
a582 1
	my $state = shift;
d592 1
a592 1
		$state->fatal("Couldn't change identity: can't find #1", $user);
@


1.118
log
@sanitize environment thru a whitelist. Only pass what's relevant for ftp and
ftp clones.

Give "decent" values to your normal environment variables, so that commands
won't be surprised.

This fixes the spurious warnings from ftp:// url reported by Jiri B.

Much feedback from deraadt@@, zhuk@@, sthen@@
@
text
@d2 1
a2 1
# $OpenBSD: PackageRepository.pm,v 1.117 2016/02/09 10:02:27 espie Exp $
d582 5
a586 2
	# we can't cache anything, we happen after the fork, right before exec
	if (my (undef, undef, $uid, $gid) = getpwnam("_pfetch")) {
d591 3
a593 2
	} 
	# don't error out yet if we can't change.
d598 2
a599 2
		USER => '_pfetch',
		LOGNAME => '_pfetch',
@


1.117
log
@tweak names
set LC_ALL everywhere since it's now easy
@
text
@d2 1
a2 1
# $OpenBSD: PackageRepository.pm,v 1.115 2016/01/30 11:29:29 espie Exp $
a588 1
	$ENV{LC_ALL} = 'C';
d590 31
@


1.116
log
@drop privs prior to running ftp
okay sthen@@
@
text
@d580 1
a580 1
sub drop_privileges
d589 1
d598 1
a598 2
	$ENV{LC_ALL} = 'C';
	$self->drop_privileges;
d607 1
a607 1
sub open_read_pipe
d617 3
a619 3
		$self->drop_privileges;
		exec($cmd) or
		$self->{state}->fatal("Can't run $cmd: #1", $!);
d623 1
a623 1
sub close_pipe
d779 1
a779 1
	my $fh = $self->open_read_pipe(OpenBSD::Paths->ftp." -o - $fullname", 
d790 1
a790 1
	$self->close_pipe($fh);
d828 1
a828 1
	my $fh = $self->open_read_pipe($cmd, $error) or return;
d838 1
a838 1
	$self->close_pipe($fh);
@


1.115
log
@redo sthen's idea deeper in pkg_add, so that *every* url can be abbreviated
the same way (e.g., PKG_PATH=ftp.openbsd.org  will work)

okay sthen@@
@
text
@d2 1
a2 1
# $OpenBSD: PackageRepository.pm,v 1.114 2015/07/12 14:52:17 espie Exp $
d580 12
d598 1
d607 23
d779 2
a780 2
	open(my $fh, '-|', OpenBSD::Paths->ftp." -o - $fullname 2>$error")
	    or return;
d790 1
a790 1
	close($fh);
d826 1
a826 1
	my ($self, $cmd) = @@_;
d828 1
a828 1
	open(my $fh, '-|', "$cmd") or return;
d838 1
a838 1
	close($fh);
d848 1
a848 1
	    ." $fullname 2>$error");
@


1.114
log
@improve the error message for incorrect PKG_CACHE.
(yes, this should error out always)
@
text
@d2 1
a2 1
# $OpenBSD: PackageRepository.pm,v 1.113 2015/03/04 13:55:32 espie Exp $
d126 5
@


1.113
log
@better error reports if PKG_TMPDIR is not writable, okay millert@@
@
text
@d2 1
a2 1
# $OpenBSD: PackageRepository.pm,v 1.112 2015/02/03 10:26:29 espie Exp $
d528 8
a535 1
	$object->{cache_dir} = $ENV{'PKG_CACHE'};
d544 1
a544 1
		if (defined $object->{cache_dir}) {
@


1.112
log
@zap scp urls from quirks update for fw_update
@
text
@d2 1
a2 1
# $OpenBSD: PackageRepository.pm,v 1.111 2014/07/13 17:24:06 espie Exp $
d524 4
d709 4
@


1.111
log
@bye bye src url. Never amounted to much, we went another road a while ago
@
text
@d2 1
a2 1
# $OpenBSD: PackageRepository.pm,v 1.110 2014/03/18 18:53:29 espie Exp $
d114 2
@


1.110
log
@remove $_ usage that warns under perl 5.18
@
text
@d2 1
a2 1
# $OpenBSD: PackageRepository.pm,v 1.109 2014/03/07 09:44:11 espie Exp $
a116 4
	} elsif ($u =~ m/^src\:/io) {
		require OpenBSD::PackageRepository::Source;

		return $class->source->parse_fullurl($r, $state);
@


1.109
log
@the IO::Uncompress framework can auto-detect compression type, turn
that on to make sure things are okay all the time.
@
text
@d2 1
a2 1
# $OpenBSD: PackageRepository.pm,v 1.108 2014/02/08 11:07:33 espie Exp $
d102 2
a103 2
	my $_ = $$r;
	return undef if $_ eq '';
d105 1
a105 1
	if (m/^ftp\:/io) {
d107 1
a107 1
	} elsif (m/^http\:/io) {
d111 1
a111 1
	} elsif (m/^https\:/io) {
d113 1
a113 1
	} elsif (m/^scp\:/io) {
d117 1
a117 1
	} elsif (m/^src\:/io) {
d121 1
a121 1
	} elsif (m/^file\:/io) {
d123 1
a123 1
	} elsif (m/^inst\:$/io) {
d125 1
a125 1
	} elsif (m/^pipe\:$/io) {
a657 1
	my $_;
a724 1
	my $_;
a773 1
	my $_;
@


1.108
log
@also limit the number of currently opened packages locally: each uncompress
gobbles memory.

(this was probably already an issue with external gunzip, but not THAT
visible because of separate processes).
@
text
@d2 1
a2 1
# $OpenBSD: PackageRepository.pm,v 1.107 2014/02/07 14:06:43 espie Exp $
d304 2
a305 2
	require IO::Uncompress::Gunzip;
	return IO::Uncompress::Gunzip->new(@@_, MultiStream => 1);
@


1.107
log
@reclaim: we don't need to keep tracking temporary files/directories we
removed.
@
text
@d2 1
a2 1
# $OpenBSD: PackageRepository.pm,v 1.106 2014/02/06 22:58:26 espie Exp $
d375 12
@


1.106
log
@http 404 is definitive, so treat it like 550 ftp.
@
text
@d2 1
a2 1
# $OpenBSD: PackageRepository.pm,v 1.105 2014/02/02 23:09:56 espie Exp $
d161 1
d163 1
d261 1
@


1.105
log
@gc really old code
@
text
@d2 1
a2 1
# $OpenBSD: PackageRepository.pm,v 1.104 2014/01/30 13:18:10 espie Exp $
d601 2
a602 1
		if (defined $self->{lasterror} && $self->{lasterror} == 550) {
d673 4
@


1.104
log
@indent fix
@
text
@d2 1
a2 1
# $OpenBSD: PackageRepository.pm,v 1.103 2014/01/17 13:41:47 espie Exp $
d540 1
a540 1
		while (defined $object->_next) {
@


1.103
log
@use internal gunzip, now that the fh leak is closed.
@
text
@d2 1
a2 1
# $OpenBSD: PackageRepository.pm,v 1.102 2014/01/13 18:44:41 espie Exp $
d161 2
a162 3

	    OpenBSD::Error->rmtree($dir);
	    delete $pkg->{dir};
@


1.102
log
@fix another chmod on permanent tempfile to respect umask.
@
text
@d2 1
a2 1
# $OpenBSD: PackageRepository.pm,v 1.101 2014/01/12 20:23:29 phessler Exp $
d299 1
a299 1
sub exec_gunzip
d302 2
a303 8
	$ENV{LC_ALL} = 'C';
	exec {OpenBSD::Paths->gzip}
	    ("gzip",
	    "-d",
	    "-c",
	    "-q",
	    @@_)
	or $self->{state}->fatal("Can't run gzip: #1", $!);
d366 1
a366 8
	my $pid = open(my $fh, "-|");
	$self->did_it_fork($pid);
	if ($pid) {
		return $fh;
	} else {
		open STDERR, ">/dev/null";
		$self->exec_gunzip("-f", $self->relative_url($object->{name}));
	}
d416 1
a416 8
	my $pid = open(my $fh, "-|");
	$self->did_it_fork($pid);
	if ($pid) {
		return $fh;
	} else {
		open STDERR, ">/dev/null";
		$self->exec_gunzip("-f", "-");
	}
d515 1
a515 16
	my ($rdfh, $wrfh);
	pipe($rdfh, $wrfh);

	my $pid = open(my $fh, "-|");
	$self->did_it_fork($pid);
	if ($pid) {
		$object->{pid} = $pid;
	} else {
		open(STDIN, '<&', $rdfh) or
		    $self->{state}->fatal("Bad dup: #1", $!);
		close($rdfh);
		close($wrfh);
		$self->exec_gunzip("-f", "-");
	}
	my $pid2 = fork();

a520 5
		open(STDOUT, '>&', $wrfh) or
		    $self->{state}->fatal("Bad dup: #1", $!);
		close($rdfh);
		close($wrfh);
		close($fh);
d534 1
a534 3
	close($rdfh);
	close($wrfh);
	return $fh;
@


1.101
log
@revert back to 1.97

There is a memory leak when using internal GZip, so switch back to the
external gzip for now.

OK espie@@
@
text
@d2 1
a2 1
# $OpenBSD: PackageRepository.pm,v 1.97 2013/12/23 16:55:00 jca Exp $
d476 1
a476 1
	chmod 0644, $filename;
@


1.100
log
@bump copyright to 2014
@
text
@d2 1
a2 1
# $OpenBSD: PackageRepository.pm,v 1.99 2014/01/09 17:41:41 espie Exp $
d4 1
a4 1
# Copyright (c) 2003-2014 Marc Espie <espie@@openbsd.org>
d299 1
a299 1
sub uncompress
d302 8
a309 2
	require IO::Uncompress::Gunzip;
	return IO::Uncompress::Gunzip->new(@@_, MultiStream => 1);
d372 8
a379 1
	return $self->uncompress($self->relative_url($object->{name}));
d429 8
a436 1
	return $self->uncompress(\*STDIN);
d535 16
a550 1
	my $pid2 = open(my $rdfh, "-|");
d556 5
d574 3
a576 1
	return $self->uncompress($rdfh);
@


1.99
log
@with the intermediate gunzip gone, this is a simple pipe. No need for
separate handles to tweak.
@
text
@d2 1
a2 1
# $OpenBSD: PackageRepository.pm,v 1.98 2014/01/09 10:43:13 espie Exp $
d4 1
a4 1
# Copyright (c) 2003-2010 Marc Espie <espie@@openbsd.org>
@


1.98
log
@switch to internal gzip/gunzip.
reduces the number of external processes and the complexity of the code.

tested on a few select arches by tobiasu, naddy. If it breaks somewhere,
tough. This one is simple to revert.
@
text
@d2 1
a2 1
# $OpenBSD: PackageRepository.pm,v 1.97 2013/12/23 16:55:00 jca Exp $
d515 1
a515 5
	my ($rdfh, $wrfh);
	pipe($rdfh, $wrfh);

	my $pid2 = fork();

a520 4
		open(STDOUT, '>&', $wrfh) or
		    $self->{state}->fatal("Bad dup: #1", $!);
		close($rdfh);
		close($wrfh);
a533 1
	close($wrfh);
@


1.97
log
@Cope with the change in ftp(1) warning messages since last commit.
Issue reported by Maxime Villard, ok espie@@.
@
text
@d2 1
a2 1
# $OpenBSD: PackageRepository.pm,v 1.96 2013/12/08 12:53:23 jca Exp $
d299 1
a299 1
sub exec_gunzip
d302 2
a303 8
	$ENV{LC_ALL} = 'C';
	exec {OpenBSD::Paths->gzip}
	    ("gzip",
	    "-d",
	    "-c",
	    "-q",
	    @@_)
	or $self->{state}->fatal("Can't run gzip: #1", $!);
d366 1
a366 8
	my $pid = open(my $fh, "-|");
	$self->did_it_fork($pid);
	if ($pid) {
		return $fh;
	} else {
		open STDERR, ">/dev/null";
		$self->exec_gunzip("-f", $self->relative_url($object->{name}));
	}
d416 1
a416 8
	my $pid = open(my $fh, "-|");
	$self->did_it_fork($pid);
	if ($pid) {
		return $fh;
	} else {
		open STDERR, ">/dev/null";
		$self->exec_gunzip("-f", "-");
	}
a517 11
	my $pid = open(my $fh, "-|");
	$self->did_it_fork($pid);
	if ($pid) {
		$object->{pid} = $pid;
	} else {
		open(STDIN, '<&', $rdfh) or
		    $self->{state}->fatal("Bad dup: #1", $!);
		close($rdfh);
		close($wrfh);
		$self->exec_gunzip("-f", "-");
	}
a528 1
		close($fh);
a541 1
	close($rdfh);
d543 1
a543 1
	return $fh;
@


1.96
log
@Force LC_ALL to 'C' before exec'ing ftp or gzip -d.  pkg_add expects
english error messages.  This fixes glitches reported by Landry.
Suggestions from zhuk@@ and espie@@, ok espie@@.
@
text
@d2 1
a2 1
# $OpenBSD: PackageRepository.pm,v 1.95 2012/04/28 15:22:49 espie Exp $
d703 1
@


1.95
log
@File::Path::rmtree is very stupid and spews out warning messages if there's
no cwd.

Well, if there's no cwd, we don't care about getting back there, so wrap
rmtree to just move to / before calling the real rmtree.
@
text
@d2 1
a2 1
# $OpenBSD$
d302 1
d599 1
@


1.94
log
@zap fatpackages. nobody actually uses them.
accordingly, locations do not need to track architecture.
@
text
@d2 1
a2 1
# $OpenBSD: PackageRepository.pm,v 1.93 2010/12/24 09:04:14 espie Exp $
d32 1
d108 2
d162 1
a162 1
	    File::Path::rmtree($dir);
@


1.93
log
@handle failures from ports tree with more care.
this does avoid infinite loops in case of wrong plists.
necessary since print-plist-with-depends CAN fail...
@
text
@d2 1
a2 1
# $OpenBSD$
d238 2
a239 2
	my ($repository, $name, $arch) = @@_;
	my $self = $repository->new_location($name, $arch);
d248 2
a249 2
	my ($repository, $name, $arch, $code) = @@_;
	my $self = $repository->new_location($name, $arch);
@


1.92
log
@use copy_file from state
always remove our special sighandlers on fork, this should prevent
all the "smart" progress stuff to fail when perl children are active.
@
text
@d2 1
a2 1
# $OpenBSD: PackageRepository.pm,v 1.91 2010/11/22 10:26:04 espie Exp $
@


1.91
log
@allow weird practices such as ftp_proxy='' instead of unset altogether
because, apparently, that's what they do in the 3rd world.
@
text
@d2 1
a2 1
# $OpenBSD: PackageRepository.pm,v 1.90 2010/10/27 14:35:56 espie Exp $
d289 5
d359 1
a359 1
	Copy($src, $destdir);
a550 2
		undef $SIG{'WINCH'};
		undef $SIG{'CONT'};
@


1.90
log
@initial scaffolding for @@rcscript: for now, acts like normal files,
but allow absolute pathnames (treat that as an implicit @@cwd).
@
text
@d2 1
a2 1
# $OpenBSD$
d817 1
a817 1
	if (defined $ENV{'ftp_proxy'}) {
@


1.89
log
@whitespace
@
text
@@


1.88
log
@print these better
@
text
@d2 1
a2 1
# $OpenBSD: PackageRepository.pm,v 1.87 2010/07/26 10:59:32 espie Exp $
d534 1
a534 1
		open(STDIN, '<&', $rdfh) or 
d549 1
a549 1
		open(STDOUT, '>&', $wrfh) or 
@


1.87
log
@even if you write signal handlers to not do anything stupid when you're
not on a terminal, they STILL interrupt long system calls and cause sysread
to fail, so disable them when they're not needed.

problem found by mlarkin@@

this is just a band-aid, I guess I really need to "reset" non-needed signals
globally whenever I fork... sigh.
@
text
@d2 1
a2 1
# $OpenBSD: PackageRepository.pm,v 1.86 2010/07/02 12:41:43 espie Exp $
d699 1
a699 1
			print STDERR "Error from $url:\n" if $notyet;
d710 1
a710 1
		print STDERR  $_;
@


1.86
log
@move the empty url message up to PackageRepository, so that we can print
it cleanly.
allow some urls to be empty without warning (e.g., "./" should generally
be allowed to be empty).
@
text
@d2 1
a2 1
# $OpenBSD: PackageRepository.pm,v 1.85 2010/07/02 11:44:14 espie Exp $
d546 2
@


1.85
log
@use state to print out all error messages
@
text
@d2 1
a2 1
# $OpenBSD: PackageRepository.pm,v 1.84 2010/07/02 11:17:46 espie Exp $
d50 7
d141 5
a145 2

		$self->{stemlist} = OpenBSD::PackageName::avail2stems($self->available);
@


1.84
log
@pass (and save) state around in Repository-related stuff.
@
text
@d2 1
a2 1
# $OpenBSD: PackageRepository.pm,v 1.83 2010/06/30 10:51:04 espie Exp $
d273 20
d354 1
a354 3
	if (!defined $pid) {
		die "Cannot fork: $!";
	}
d359 1
a359 8
		exec {OpenBSD::Paths->gzip}
		    "gzip",
		    "-d",
		    "-c",
		    "-q",
		    "-f",
		    $self->relative_url($object->{name})
		or die "Can't run gzip";
d411 1
a411 3
	if (!defined $pid) {
		die "Cannot fork: $!";
	}
d416 1
a416 8
		exec {OpenBSD::Paths->gzip}
		    "gzip",
		    "-d",
		    "-c",
		    "-q",
		    "-f",
		    "-"
		or die "can't run gzip";
d483 1
a483 1
			die "Error reading: $!";
d520 1
a520 3
	if (!defined $pid) {
		die "Cannot fork: $!";
	}
d524 2
a525 1
		open(STDIN, '<&', $rdfh) or die "Bad dup";
d528 1
a528 7
		exec {OpenBSD::Paths->gzip}
		    "gzip",
		    "-d",
		    "-c",
		    "-q",
		    "-"
		or die "can't run gzip";
d532 1
a532 3
	if (!defined $pid2) {
		die "Cannot fork: $!";
	}
d537 2
a538 1
		open(STDOUT, '>&', $wrfh) or die "Bad dup";
d544 1
a544 3
			if (!defined $pid3) {
				die "Cannot fork: $!";
			}
d585 1
a585 1
	or die "can't run ".OpenBSD::Paths->ftp;
d628 2
a629 1
			print STDERR "Temporary error, sleeping $retry seconds\n";
d713 3
a715 3
			print STDERR $self->{path},
			    ": Directory does not exist on ", $self->{host},
			    "\n";
@


1.83
log
@allow say and errsay to work without parameters, as it's ways common.
create verbose_system up in state, because it makes sense without verbose.
@
text
@d2 1
a2 1
# $OpenBSD$
d42 2
a43 2
	my ($class, $baseurl) = @@_;
	my $o = $class->parse(\$baseurl);
d76 1
a76 1
	my ($class, $r) = @@_;
d79 1
a79 1
	return $class->unique($class->parse_url($r));
d82 9
d93 1
a93 1
	my ($class, $r) = @@_;
d98 1
a98 1
		return OpenBSD::PackageRepository::FTP->parse_fullurl($r);
d100 1
a100 1
		return OpenBSD::PackageRepository::HTTP->parse_fullurl($r);
d102 1
a102 1
		return OpenBSD::PackageRepository::HTTPS->parse_fullurl($r);
d106 1
a106 1
		return OpenBSD::PackageRepository::SCP->parse_fullurl($r);
d110 1
a110 1
		return OpenBSD::PackageRepository::Source->parse_fullurl($r);
d112 1
a112 1
		return OpenBSD::PackageRepository::Local->parse_fullurl($r);
d114 1
a114 1
		return OpenBSD::PackageRepository::Installed->parse_fullurl($r);
d116 1
a116 1
		return OpenBSD::PackageRepository::Local::Pipe->parse_fullurl($r);
d118 1
a118 1
		return OpenBSD::PackageRepository::Local->parse_fullurl($r);
d295 1
a295 1
	my ($class, $r) = @@_;
d298 3
a300 3
	my $o = $class->parse_url($r);
	if (!$ok && $o->{path} eq $class->pkg_db()."/") {
		return OpenBSD::PackageRepository::Installed->new;
a389 2
my $s = bless {}, __PACKAGE__;

d392 2
a393 1
	return $s;
d430 1
a430 1
	my ($class, $r) = @@_;
d436 1
a436 1
		my $o = $class->SUPER::parse_url($r);
@


1.82
log
@whitespace cleanup
@
text
@@


1.81
log
@style
@
text
@@


1.80
log
@centralize checking of packagenames. Avoid grabbing pkgnames that won't
have a version number. This gets rid of:
Can't call method "v" on an undefined value at /usr/libdata/perl5/OpenBSD/PackageName.pm line 310.
@
text
@d2 1
a2 1
# $OpenBSD: PackageRepository.pm,v 1.79 2010/05/10 09:17:55 espie Exp $
d25 1
a25 1
$OpenBSD::PackageRepository::Installed::ISA=(qw(OpenBSD::PackageRepository));
@


1.79
log
@whitespace fixes
@
text
@d2 1
a2 1
# $OpenBSD$
d256 8
a355 1
		next unless $e =~ m/^(.*)\.tgz$/o;
d357 1
a357 1
		push(@@$l, $1);
d732 1
a732 1
		for my $pkg (m/\<A\s+HREF=\"(.*?)\.tgz\"\>/gio) {
d736 1
a736 1
			push(@@$l, $pkg);
d785 2
a786 2
		next unless m/^(?:\.\/)?(\S+)\.tgz\s*$/;
		push(@@$l, $1);
@


1.78
log
@bump copyright
@
text
@d172 1
a172 1
	$self->parse_problems($object->{errors}, $hint, $object) 
d324 6
a329 6
		exec {OpenBSD::Paths->gzip} 
		    "gzip", 
		    "-d", 
		    "-c", 
		    "-q", 
		    "-f", 
d392 6
a397 6
		exec {OpenBSD::Paths->gzip} 
		    "gzip", 
		    "-d", 
		    "-c", 
		    "-q", 
		    "-f", 
d419 1
a419 1
		
d512 6
a517 6
		exec {OpenBSD::Paths->gzip} 
		    "gzip", 
		    "-d", 
		    "-c", 
		    "-q", 
		    "-" 
d573 1
a573 1
	exec {$ftp} 
d576 1
a576 1
	    "-o", 
d632 2
a633 2
	return $self->try_until_success($pkgname, 
	    sub { 
d642 2
a643 2
	return $self->try_until_success($pkgname, 
	    sub { 
d705 2
a706 2
			print STDERR $self->{path}, 
			    ": Directory does not exist on ", $self->{host}, 
@


1.77
log
@move signal catching up, so we can clean repos and temp files at once.
Fix main program try/catch: signal message should use standard form so
it gets caught.
@
text
@d4 1
a4 1
# Copyright (c) 2003-2007 Marc Espie <espie@@openbsd.org>
@


1.76
log
@create unique object for each repo
@
text
@d63 11
@


1.75
log
@fixed version, somehow I forgot that I use parse to do weird things with
PKG_PATH...
@
text
@d50 12
a61 5
# we have to pass a reference because we want to:
# - strip the scheme
# - report whether we stripped it
# (relevant for file: url, where we strip, but don't care if we did
# vs other schemes, where not having the ftp: marker is a problem)
d68 1
a68 1
	return $class->parse_url($r);
d274 1
a274 1
		return $o;
d363 2
d367 1
a367 2
	my $class = shift;
	bless {}, $class;
@


1.74
log
@temporary revert until I figure this out
@
text
@a32 7
sub _new
{
	my ($class, $path, $host) = @@_;
	$path .= '/' unless $path =~ m/\/$/;
	bless { host => $host, path => $path }, $class;
}

d44 2
a45 28
	return $o;
}

sub strip_urlscheme
{
	my ($class, $r) = @@_;
	if ($$r =~ m/^(.*?)\:(.*)$/) {
		my $scheme = lc($1);
		if ($scheme eq $class->urlscheme) {
			$$r = $2;
			return 1;
	    	}
	}
	return 0;
}

sub parse_local_url
{
	my ($class, $r, @@args) = @@_;

	my $o;

	if ($$r =~ m/^(.*?)\:(.*)/) {
		$o = $class->_new($1, @@args);
		$$r = $2;
	} else {
		$o = $class->_new($$r, @@args);
		$$r = '';
d50 5
a54 4
sub parse_url
{
	&parse_local_url;
}
d66 2
a67 2
	my ($class, $ref) = @@_;
	my $_ = $$ref;
d71 1
a71 1
		return OpenBSD::PackageRepository::FTP->parse_fullurl($ref);
d73 1
a73 1
		return OpenBSD::PackageRepository::HTTP->parse_fullurl($ref);
d75 1
a75 1
		return OpenBSD::PackageRepository::HTTPS->parse_fullurl($ref);
d79 1
a79 1
		return OpenBSD::PackageRepository::SCP->parse_fullurl($ref);
d83 1
a83 1
		return OpenBSD::PackageRepository::Source->parse_fullurl($ref);
d85 1
a85 1
		return OpenBSD::PackageRepository::Local->parse_fullurl($ref);
d87 3
a89 1
		return OpenBSD::PackageRepository::Installed->parse_fullurl($ref);
d91 1
a91 1
		return OpenBSD::PackageRepository::Local->parse_fullurl($ref);
d247 11
d262 7
a268 2
	$class->strip_urlscheme($r);
	return $class->parse_local_url($r);
a395 5
	&parse_distant_url;
}

sub parse_distant_url
{
d399 6
a404 4
	if ($$r =~ m/^\/\/(.*?)(\/.*)$/) {
		my $host = $1;
		$$r = $2;
		return $class->parse_local_url($r, $host);
@


1.73
log
@move the code that recognizes /var/db/pkg as inst: into Repo::Local
@
text
@d33 7
d50 30
a79 1
	my $o = $class->parse($baseurl);
d83 4
a86 5
# we have to pass a reference because we want to:
# - strip the scheme
# - report whether we stripped it
# (relevant for file: url, where we strip, but don't care if we did
# vs other schemes, where not having the ftp: marker is a problem)
d90 1
a90 1
	my ($class, $_) = @@_;
d92 2
a93 2
	$class->strip_urlscheme(\$_) or return undef;
	return $class->parse_url($_);
d98 2
a99 1
	my ($class, $_) = @@_;
d103 1
a103 1
		return OpenBSD::PackageRepository::FTP->parse_fullurl($_);
d105 1
a105 1
		return OpenBSD::PackageRepository::HTTP->parse_fullurl($_);
d107 1
a107 1
		return OpenBSD::PackageRepository::HTTPS->parse_fullurl($_);
d111 1
a111 1
		return OpenBSD::PackageRepository::SCP->parse_fullurl($_);
d115 1
a115 1
		return OpenBSD::PackageRepository::Source->parse_fullurl($_);
d117 1
a117 1
		return OpenBSD::PackageRepository::Local->parse_fullurl($_);
d119 1
a119 3
		return OpenBSD::PackageRepository::Installed->parse_fullurl($_);
	} elsif (m/^pipe\:$/io) {
		return OpenBSD::PackageRepository::Local::Pipe->parse_fullurl($_);
d121 1
a121 1
		return OpenBSD::PackageRepository::Local->parse_fullurl($_);
a276 11
my $pkg_db;

sub pkg_db
{
	if (!defined $pkg_db) {
		use OpenBSD::Paths;
		$pkg_db = $ENV{"PKG_DBDIR"} || OpenBSD::Paths->pkgdb;
	}
	return $pkg_db;
}

d279 1
a279 1
	my ($class, $_) = @@_;
d281 2
a282 7
	my $r = $class->strip_urlscheme(\$_);
	my $o = $class->parse_url($_);
	if (!$r && $o->{path} eq $class->pkg_db()."/") {
		return OpenBSD::PackageRepository::Installed->new;
	} else {
		return $o;
	}
d410 6
a415 1
	my ($class, $_) = @@_;
d418 4
a421 5
	if (my ($host, $path) = m/^\/\/(.*?)(\/.*)$/) {
		
		my $o = $class->SUPER::parse_url($path);
		$o->{host} = $host;
		return $o;
@


1.72
log
@move some url parsing into Installed, provide for pipe:
@
text
@d243 11
d258 7
a264 2
	$class->strip_urlscheme(\$_);
	return $class->parse_url($_);
@


1.71
log
@kill more useless code
@
text
@a32 7
sub parse_url
{
	my ($class, $path) = @@_;
	$path .= '/' unless $path =~ m/\/$/;
	bless { path => $path }, $class;
}

a52 13
sub strip_urlscheme
{
	my ($class, $r) = @@_;
	if ($$r =~ m/^(.*?)\:(.*)$/) {
		my $scheme = lc($1);
		if ($scheme eq $class->urlscheme) {
			$$r = $2;
			return 1;
	    	}
	}
	return 0;
}

d84 2
@


1.70
log
@simplify slightly
@
text
@d33 1
a33 1
sub _new
d35 1
a35 1
	my ($class, $path, $host) = @@_;
d37 1
a37 1
	bless { host => $host, path => $path }, $class;
a72 21
sub parse_local_url
{
	my ($class, $r, @@args) = @@_;

	my $o;

	if ($$r =~ m/^(.*?)\:(.*)/) {
		$o = $class->_new($1, @@args);
		$$r = $2;
	} else {
		$o = $class->_new($$r, @@args);
		$$r = '';
	}
	return $o;
}

sub parse_url
{
	&parse_local_url;
}

d78 1
a78 1
	return $class->parse_url(\$_);
d266 1
a266 1
	return $class->parse_local_url(\$_);
d394 1
a394 6
	&parse_distant_url;
}

sub parse_distant_url
{
	my ($class, $r) = @@_;
d397 5
a401 4
	if ($$r =~ m/^\/\/(.*?)(\/.*)$/) {
		my $host = $1;
		$$r = $2;
		return $class->parse_local_url($r, $host);
@


1.69
log
@move pipe handling into RepositoryList
@
text
@d50 1
a50 1
	my $o = $class->parse(\$baseurl);
d54 6
d96 1
a96 1
	my ($class, $r) = @@_;
d98 2
a99 2
	$class->strip_urlscheme($r) or return undef;
	return $class->parse_url($r);
d104 1
a104 2
	my ($class, $ref) = @@_;
	my $_ = $$ref;
d108 1
a108 1
		return OpenBSD::PackageRepository::FTP->parse_fullurl($ref);
d110 1
a110 1
		return OpenBSD::PackageRepository::HTTP->parse_fullurl($ref);
d112 1
a112 1
		return OpenBSD::PackageRepository::HTTPS->parse_fullurl($ref);
d116 1
a116 1
		return OpenBSD::PackageRepository::SCP->parse_fullurl($ref);
d120 1
a120 1
		return OpenBSD::PackageRepository::Source->parse_fullurl($ref);
d122 1
a122 1
		return OpenBSD::PackageRepository::Local->parse_fullurl($ref);
d124 1
a124 1
		return OpenBSD::PackageRepository::Installed->parse_fullurl($ref);
d126 1
a126 1
		return OpenBSD::PackageRepository::Local->parse_fullurl($ref);
d284 1
a284 1
	my ($class, $r) = @@_;
d286 2
a287 2
	$class->strip_urlscheme($r);
	return $class->parse_local_url($r);
@


1.68
log
@you have to hate those stupid tools:
if you echo nlist |ftp some_url
the site *won't* give you an error code, it will just spew out a stupid line
like:
Failed to change directory.
Can't change directory to pub/OpenBSD/zoinx: No such file or directory

and that on stdout !!!

Detect this in list grabbing, and display a decent error message for the
user.

Avoids some duh moments where you won't find shit because you
mistyped the url...
@
text
@d370 6
@


1.67
log
@URI-decode the filenames in the listing used for HTTP pkg_add updates.
Fixes a problem with pkg_add -u where package names are encoded in the
listing (e.g. those containing + like gtk+2-2.16.5 on standards-compliant
servers).

Problem noted and fix tested by ajacoutot@@ against a server running
lighttpd. No regressions against Apache. ok espie@@
@
text
@d2 1
a2 1
# $OpenBSD: PackageRepository.pm,v 1.66 2009/05/11 19:51:27 sthen Exp $
d696 6
d767 3
@


1.66
log
@remove an extraneous slash from the requested URL; some strict proxies
(and maybe http servers) have a problem with it.  ok espie@@
@
text
@d2 1
a2 1
# $OpenBSD: PackageRepository.pm,v 1.65 2009/04/24 23:22:20 espie Exp $
d713 2
@


1.65
log
@oops
@
text
@d2 1
a2 1
# $OpenBSD$
d399 1
a399 1
	return "//$self->{host}/$self->{path}";
@


1.64
log
@remove class FatPackageLocation. Instead make PackageLocation a hierarchy
so that I can handle installed packages without playing ping-pong with
the PackageRepository hierarchy (mostly)
@
text
@d549 1
a549 1
		while (defined $object->intNext) {
@


1.63
log
@synch with my new style search/location changes
It's likely there will be some fallout, but it's getting a bit too large
to keep around.
This does kill a few very old oddities as well.
@
text
@d232 1
a232 1
	my $self = OpenBSD::PackageLocation->new($repository, $name, $arch);
d242 1
a242 1
	my $self = OpenBSD::PackageLocation->new($repository, $name, $arch);
@


1.62
log
@deals with shaddy repositories from backwards countries that implement
nlist incorrectly.

as diagnosed by kili@@
@
text
@d2 1
a2 1
# $OpenBSD: PackageRepository.pm,v 1.61 2008/12/11 15:43:19 espie Exp $
d234 3
a236 1
	return $self->openPackage;
d487 1
a487 1
	$object->{errors} = OpenBSD::Temp::file();
a564 3
	if (defined $ENV{'FTP_KEEPALIVE'}) {
		push(@@extra, "-k", $ENV{'FTP_KEEPALIVE'});
	}
d693 1
a693 1
		my $error = OpenBSD::Temp::file();
@


1.61
log
@copying local files may cause some issues, as noticed by sturm@@
Try really hard to avoid copying a file on itself: by first checking the
stat() results, and if they are not available (since some people use fucked-up
stuff like AFS), rely on the file names as a last resort.

This should avoid stuff getting copied from PKG_CACHE to PKG_CACHE and
erasing itself in a few cases...
@
text
@d2 1
a2 1
# $OpenBSD$
d760 1
a760 1
		next unless m/(\S+)\.tgz\s*$/;
@


1.60
log
@Copy packages to the cache if a local PKG_PATH is used and PKG_CACHE is
defined. This unbreaks FETCH_PACKAGES with a local package repository.

help & discussion: espie@@ and sturm@@
@
text
@d2 1
a2 1
# $OpenBSD: PackageRepository.pm,v 1.59 2008/10/20 10:25:16 espie Exp $
d283 21
d308 1
a308 1
		Copy($self->relative_url($object->{name}), $ENV{'PKG_CACHE'});
@


1.59
log
@Say goodbye to local $_
lexical scoping is so much neater (courtesy of perl 5.10)
@
text
@d2 1
a2 1
# $OpenBSD$
d268 1
d286 3
@


1.58
log
@clean up parser a bit, separating local/distant parts in a more reusable way,
and simplify file: parsing scheme (trying it with file:, then without is
a bit stupid once we have the pieces to put it back together directly).
Drop the restriction on urls from the man page, no need to finish stuff with /.
@
text
@d99 1
a99 1
	local $_ = $$ref;
d625 1
a625 1
	local $_;
d682 1
a682 1
	local $_;
d730 1
a730 1
	local $_;
@


1.57
log
@deal with hrefs containing '/' instead of just the package file name
this permits fetching packages from thttpd
ok espie
@
text
@d2 1
a2 1
# $OpenBSD: PackageRepository.pm,v 1.56 2008/06/25 12:42:59 espie Exp $
d44 1
a44 5
	if (defined $self->{host}) {
		return "//$self->{host}/$self->{path}";
	} else {
		return $self->{path};
	}
d54 1
a54 1
sub _parse
d59 3
a61 2
		if ($scheme ne $class->urlscheme) {
			return undef;
d63 12
d76 3
a78 20
		my $o;
		# use similar heuristics as ftp
		if ($$r =~ m/^\/\/(.*?)(\/.*)$/) {
			my $host = $1;
			$$r = $2;
			if ($$r =~ m/^(.*?)\:(.*)$/) {
				$o = $class->_new($1, $host);
				$$r = $2;
			} else {
				$o = $class->_new($$r, $host);
				$$r = '';
			}
		} elsif ($$r =~ m/^(.*?)\:(.*)/) { 	# no /, split on :
			$o = $class->_new($1);
			$$r = $2;
		} else {
			$o = $class->_new($$r);
			$$r = '';
		}
	    	return $o;
d80 14
a93 1
	return undef;
d103 1
a103 1
		return OpenBSD::PackageRepository::FTP->_parse($ref);
d105 1
a105 1
		return OpenBSD::PackageRepository::HTTP->_parse($ref);
d107 1
a107 1
		return OpenBSD::PackageRepository::HTTPS->_parse($ref);
d111 1
a111 1
		return OpenBSD::PackageRepository::SCP->_parse($ref);
d115 1
a115 1
		return OpenBSD::PackageRepository::Source->_parse($ref);
d117 1
a117 1
		return OpenBSD::PackageRepository::Local->_parse($ref);
d119 1
a119 1
		return OpenBSD::PackageRepository::Installed->_parse($ref);
d121 1
a121 1
		return OpenBSD::PackageRepository::Local->_parse($ref);
d274 1
a274 1
sub _parse
d277 3
a279 4
	my $o = $class->SUPER::_parse($r);
	return $o if defined $o;
	$$r = "file:$$r";
	return $class->SUPER::_parse($r);
d367 26
@


1.56
log
@much better url parser.
@
text
@d2 1
a2 1
# $OpenBSD$
a654 1
	# XXX assumes a pkg HREF won't cross a line. Is this the case ?
d658 1
a658 1
			next if $pkg =~ m|/|;
@


1.55
log
@forgot: changed PackageLocator so that the new parse method is responsible
for breaking up the next part.
@
text
@d35 14
a48 2
	my ($class, $address) = @@_;
	bless { baseurl => $address }, $class;
d54 3
a56 8
	if ($baseurl =~ m/^ftp\:(.*)$/io) {
		return OpenBSD::PackageRepository::FTP->_new($1);
	} elsif ($baseurl =~ m/^http\:(.*)$/io) {
		return OpenBSD::PackageRepository::HTTP->_new($1);
	} elsif ($baseurl =~ m/^https\:(.*)$/io) {
		return OpenBSD::PackageRepository::HTTPS->_new($1);
	} elsif ($baseurl =~ m/^scp\:(.*)$/io) {
		require OpenBSD::PackageRepository::SCP;
d58 29
a86 11
		return OpenBSD::PackageRepository::SCP->_new($1);
	} elsif ($baseurl =~ m/^src\:(.*)$/io) {
		require OpenBSD::PackageRepository::Source;

		return OpenBSD::PackageRepository::Source->_new($1);
	} elsif ($baseurl =~ m/^file\:(.*)$/io) {
		return OpenBSD::PackageRepository::Local->_new($1);
	} elsif ($baseurl =~ m/^inst\:(.*)$/io) {
		return OpenBSD::PackageRepository::Installed->_new($1);
	} else {
		return OpenBSD::PackageRepository::Local->_new($baseurl);
d88 1
d91 1
a91 1
sub todo
d94 2
a95 2
	my $s = $$ref;
	return undef if $s eq '';
d97 7
a103 7
	if ($$ref =~ m/^ftp\:(.*)$/io) {
		return OpenBSD::PackageRepository::FTP->_parse($1, $ref);
	} elsif ($$ref =~ m/^http\:(.*)$/io) {
		return OpenBSD::PackageRepository::HTTP->_parse($1, $ref);
	} elsif ($$ref =~ m/^https\:(.*)$/io) {
		return OpenBSD::PackageRepository::HTTPS->_parse($1, $ref);
	} elsif ($$ref =~ m/^scp\:(.*)$/io) {
d106 2
a107 2
		return OpenBSD::PackageRepository::SCP->_parse($1, $ref);
	} elsif ($$ref =~ m/^src\:(.*)$/io) {
d110 5
a114 18
		return OpenBSD::PackageRepository::Source->_parse($1, $ref);
	} elsif ($$ref =~ m/^file\:(.*)$/io) {
		return OpenBSD::PackageRepository::Local->_parse($1, $ref);
	} elsif ($$ref =~ m/^inst\:(.*)$/io) {
		return OpenBSD::PackageRepository::Installed->_parse($1, $ref);
	} else {
		return OpenBSD::PackageRepository::Local->_parse($$ref, $ref);
	}
}

sub parse
{
	my ($class, $ref) = @@_;
	my $s = $$ref;
	return undef if !defined $s;
	if ($s =~ m/(.*?)\/\:(.*)/) {
		$$ref = $2;
		return $class->new($1);
d116 1
a116 2
		undef $$ref;
		return $class->new($s);
d255 1
a255 1
		return $self->{baseurl}.$name.".tgz";
d257 1
a257 1
		return $self->{baseurl};
d269 9
d310 1
a310 1
	my $dname = $self->{baseurl};
d527 1
a527 1
	my $k = $self->{key};
a531 10
}

sub _new
{
	my ($class, $baseurl) = @@_;
	my $distant_host;
	if ($baseurl =~ m/^(\/\/.*?\/)/io) {
	    $distant_host = $1;
	}
	bless { baseurl => $baseurl, key => $distant_host }, $class;
@


1.54
log
@550 is fatal, don't bother retrying.
Problem found by Martynas Venckus, fix by me.
@
text
@d2 1
a2 1
# $OpenBSD: PackageRepository.pm,v 1.53 2008/05/26 17:38:54 espie Exp $
d62 43
@


1.53
log
@remove nlist bandwidth optimization, since ftp servers actually don't cope
with *.tgz very well...

Fix regexp for stripping out ftp responses (as noticed by bernd)
@
text
@d2 1
a2 1
# $OpenBSD$
d500 3
@


1.52
log
@tweak ftp call, remove extraneous -o option.
okay sthen@@
@
text
@d648 2
a649 2
		next if m/^d.*\s+\S/;
		next unless m/([^\s]+)\.tgz\s*$/;
d661 1
a661 1
	return $self->_list("echo 'nlist *.tgz'| ".OpenBSD::Paths->ftp
@


1.51
log
@Since the back-off goes 5,10,20,40 seconds, allow the retry timeout to
increase to 80 and then 160sec before failing. Helps when doing big
updates with "pkg_add -ui"
ok espie, deraadt
@
text
@d2 1
a2 1
# $OpenBSD: PackageRepository.pm,v 1.50 2008/02/06 20:22:19 bernd Exp $
d662 1
a662 1
	    ." -o - $fullname 2>$error");
@


1.50
log
@Fix FETCH_CMD and don't hardcode ftp(1) but use OpenBSD::Paths->ftp().

ok espie@@
@
text
@d2 1
a2 1
# $OpenBSD: PackageRepository.pm,v 1.49 2007/08/23 09:09:49 espie Exp $
d495 1
a495 1
	for (my $retry = 5; $retry < 60; $retry *= 2) {
@


1.49
log
@write out the object url in the error message if that's an object error and
not a basic listing repository issue.
@
text
@d2 1
a2 1
# $OpenBSD: PackageRepository.pm,v 1.48 2007/06/23 17:55:12 espie Exp $
d443 1
a443 2
	my $ftp = $ENV{'FETCH_CMD'} || OpenBSD::Paths->ftp;
	my @@extra = ();
d447 2
a448 2
	exec {OpenBSD::Paths->ftp} 
	    "ftp", 
d452 1
a452 1
	or die "can't run ftp";
d596 2
a597 1
	open(my $fh, '-|', "ftp -o - $fullname 2>$error") or return;
d661 2
a662 1
	return $self->_list("echo 'nlist *.tgz'|ftp -o - $fullname 2>$error");
@


1.48
log
@setup a local sigalarm to send a HUP to the ftp process if it takes longer
than 30 seconds to stop... 30 seconds chosen as a `nice' average value.

Note that this is a `work-around' for some specificities of ftp(1), which
usually doesn't react to SIGINT, but reacts instantly to SIGHUP...
@
text
@d2 1
a2 1
# $OpenBSD: PackageRepository.pm,v 1.47 2007/06/16 09:37:31 espie Exp $
d124 1
a124 1
	$self->parse_problems($object->{errors}, $hint) 
d187 1
a187 1
	my ($self, $filename, $hint) = @@_;
d531 1
a531 1
	my ($self, $filename, $hint) = @@_;
d535 4
d561 1
a561 1
			print STDERR "Error from $baseurl:\n" if $notyet;
d575 1
a575 1
	$self->SUPER::parse_problems($filename, $hint);
@


1.47
log
@FTP_KEEPALIVE as a crude interface to ftp -k. To be thought out later.
this is just an experiment.
@
text
@d2 1
a2 1
# $OpenBSD: PackageRepository.pm,v 1.46 2007/06/16 09:29:37 espie Exp $
d116 8
a123 1
	waitpid($object->{pid2}, 0) if defined $object->{pid2};
@


1.46
log
@use OpenBSD::Paths contents
@
text
@d2 1
a2 1
# $OpenBSD: PackageRepository.pm,v 1.45 2007/06/12 09:53:36 espie Exp $
d436 5
d443 1
@


1.45
log
@tidy error messages: uses $! more consistently, do not append \n on die,
do append \n on warn.

Fix the two cases where the temp dir vanished too soon: not copying +DESC
should have been apparent. Not finding a +DISPLAY file is not a reason for
burping all over the place.
@
text
@d2 1
a2 1
# $OpenBSD: PackageRepository.pm,v 1.44 2007/06/10 14:25:18 espie Exp $
d31 1
d218 1
a218 1
		exec {"/usr/bin/gzip"} 
d279 1
a279 1
		exec {"/usr/bin/gzip"} 
d376 1
a376 1
		exec {"/usr/bin/gzip"} 
d436 1
a436 2
	my $ftp = defined $ENV{'FETCH_CMD'} ? $ENV{'FETCH_CMD'} : "/usr/bin/ftp";
	exec {$ftp} 
@


1.44
log
@refactor the code a bit, so that lists through ftp and htpp share more
code.

Finally handle ftp_proxy (close PR 5308).
@
text
@d2 1
a2 1
# $OpenBSD: PackageRepository.pm,v 1.43 2007/06/06 14:06:18 espie Exp $
d329 1
a329 1
			die "Error reading\n";
@


1.43
log
@recognize and handle https.
@
text
@d2 1
a2 1
# $OpenBSD: PackageRepository.pm,v 1.42 2007/06/04 18:55:47 espie Exp $
a415 16
sub _list
{
	my ($self, $cmd) = @@_;
	my $l =[];
	local $_;
	open(my $fh, '-|', "$cmd") or return;
	while(<$fh>) {
		chomp;
		next if m/^d.*\s+\S/;
		next unless m/([^\s]+)\.tgz\s*$/;
		push(@@$l, $1);
	}
	close($fh);
	return $l;
}

d540 1
d561 31
d601 1
a601 1
sub list
d603 2
a604 20
	my ($self) = @@_;
	if (!defined $self->{list}) {
		my $error = OpenBSD::Temp::file();
		$self->make_room;
		my $fullname = $self->url;
		my $l = $self->{list} = [];
		local $_;
		open(my $fh, '-|', "ftp -o - $fullname 2>$error") or return;
		# XXX assumes a pkg HREF won't cross a line. Is this the case ?
		while(<$fh>) {
			chomp;
			for my $pkg (m/\<A\s+HREF=\"(.*?)\.tgz\"\>/gio) {
				next if $pkg =~ m|/|;
				push(@@$l, $pkg);
			}
		}
		close($fh);
		$self->parse_problems($error);
	}
	return $self->{list};
d623 17
a639 1
sub list
d641 5
a645 3
	my ($self) = @@_;
	if (!defined $self->{list}) {
		require OpenBSD::Temp;
d647 7
a653 5
		my $error = OpenBSD::Temp::file();
		$self->make_room;
		my $fullname = $self->url;
		$self->{list} = $self->_list("echo 'nlist *.tgz'|ftp -o - $fullname 2>$error");
		$self->parse_problems($error);
a654 1
	return $self->{list};
@


1.42
log
@a few missed $' / $`
@
text
@d2 1
a2 1
# $OpenBSD: PackageRepository.pm,v 1.41 2007/06/04 18:52:02 espie Exp $
d45 2
d607 8
@


1.41
log
@more efficient regexps: anchor stuff at both ends, be more specific in
what matches. Get rid of $`, $', $&, which encur a performance penalty.
(not yet done on PackageName and PkgSpec).
@
text
@d2 1
a2 1
# $OpenBSD: PackageRepository.pm,v 1.40 2007/06/04 14:40:39 espie Exp $
d239 1
a239 1
		next unless $e =~ m/\.tgz$/o;
d241 1
a241 1
		push(@@$l, $`);
@


1.40
log
@some minor systematic changes.
- mark all regexps I can with /o if they can be compiled once.
- turn $o->method() into $o->method
- remove unneeded prototypes
- reduce split /re/ into split "string" where possible.
@
text
@d2 1
a2 1
# $OpenBSD: PackageRepository.pm,v 1.39 2007/05/30 11:04:31 espie Exp $
d41 5
a45 5
	if ($baseurl =~ m/^ftp\:/io) {
		return OpenBSD::PackageRepository::FTP->_new($');
	} elsif ($baseurl =~ m/^http\:/io) {
		return OpenBSD::PackageRepository::HTTP->_new($');
	} elsif ($baseurl =~ m/^scp\:/io) {
d48 2
a49 2
		return OpenBSD::PackageRepository::SCP->_new($');
	} elsif ($baseurl =~ m/^src\:/io) {
d52 5
a56 5
		return OpenBSD::PackageRepository::Source->_new($');
	} elsif ($baseurl =~ m/^file\:/io) {
		return OpenBSD::PackageRepository::Local->_new($');
	} elsif ($baseurl =~ m/^inst\:/io) {
		return OpenBSD::PackageRepository::Installed->_new($');
d476 2
a477 2
	if ($baseurl =~ m/^\/\/(.*?)\//io) {
	    $distant_host = $&;
@


1.39
log
@move close methods so that error paths can proceed on Repository::Installed.
@
text
@d2 1
a2 1
# $OpenBSD: PackageRepository.pm,v 1.38 2007/05/19 09:18:55 espie Exp $
d41 1
a41 1
	if ($baseurl =~ m/^ftp\:/i) {
d43 1
a43 1
	} elsif ($baseurl =~ m/^http\:/i) {
d45 1
a45 1
	} elsif ($baseurl =~ m/^scp\:/i) {
d49 1
a49 1
	} elsif ($baseurl =~ m/^src\:/i) {
d53 1
a53 1
	} elsif ($baseurl =~ m/^file\:/i) {
d55 1
a55 1
	} elsif ($baseurl =~ m/^inst\:/i) {
d117 1
a117 1
	$object->deref();
d239 1
a239 1
		next unless $e =~ m/\.tgz$/;
d476 1
a476 1
	if ($baseurl =~ m/^\/\/(.*?)\//i) {
d539 3
a541 3
		next if m/^(?:200|220|221|226|229|230|227|250|331|500|150)[\s\-]/;
		next if m/^EPSV command not understood/;
		next if m/^Trying [\da-f\.\:]+\.\.\./;
d543 8
a550 8
		next if m/^Remote system type is\s+/;
		next if m/^Connected to\s+/;
		next if m/^remote\:\s+/;
		next if m/^Using binary mode to transfer files/;
		next if m/^Retrieving\s+/;
		next if m/^Success?fully retrieved file/;
		next if m/^\d+\s+bytes\s+received\s+in/;
		next if m/^ftp: connect to address.*: No route to host/;
d553 2
a554 2
			next if m/^ftp: -: short write/;
			next if m/^421\s+/;
d560 3
a562 3
		if (m/^421\s+/ ||
		    m/^ftp: connect: Connection timed out/ ||
		    m/^ftp: Can't connect or login to host/) {
d565 1
a565 1
		if (m/^550\s+/) {
d596 1
a596 1
			for my $pkg (m/\<A\s+HREF=\"(.*?)\.tgz\"\>/gi) {
@


1.38
log
@don't pass srcpath around, since we don't use it.
@
text
@d2 1
a2 1
# $OpenBSD: PackageRepository.pm,v 1.37 2007/05/18 13:22:06 espie Exp $
a117 24
}

sub finish_and_close
{
	my ($self, $object) = @@_;
	$self->close($object);
}

sub close_now
{
	my ($self, $object) = @@_;
	$self->close($object, 0);
}

sub close_after_error
{
	my ($self, $object) = @@_;
	$self->close($object, 1);
}

sub close_with_client_error
{
	my ($self, $object) = @@_;
	$self->close($object, 1);
@


1.37
log
@Add pkgpath hints to pkgspec. Make PackageRepository/Source functional:
if a pkgpath is hinted at, then we build that package, and we delegate
to the corresponding File: repository.

Some XXX: we need to unlock the database temporarily, as the build
*requires* shared access to stuff that is going on (and possibly write
access for installing subpackages, so this cannot work 100% yet).

Still, this allows the transparent build of one single package, at least.
@
text
@d2 1
a2 1
# $OpenBSD: PackageRepository.pm,v 1.36 2007/05/17 18:59:38 espie Exp $
d185 1
a185 1
	my ($repository, $name, $arch, $srcpath) = @@_;
@


1.36
log
@do not pass the urlscheme to the constructors, since they each have
a known urlscheme.

Recognize inst: and file: as specific schemes that refer to given
repositories, for future extension.
@
text
@d2 1
a2 1
# $OpenBSD: PackageRepository.pm,v 1.35 2007/05/17 18:52:58 espie Exp $
d52 1
a52 1
		return OpenBSD::PackageRepository::Source->_new($baseurl);
@


1.35
log
@new methods: repositories can create url. Rename PackageLocation->stringize
to url, since that's what it does. Use the new methods to shorten code.
@
text
@d2 1
a2 1
# $OpenBSD: PackageRepository.pm,v 1.34 2007/05/17 18:17:20 espie Exp $
d42 1
a42 1
		return OpenBSD::PackageRepository::FTP->_new($baseurl);
d44 1
a44 1
		return OpenBSD::PackageRepository::HTTP->_new($baseurl);
d48 2
a49 2
		return OpenBSD::PackageRepository::SCP->_new($baseurl);
	} elsif ($baseurl =~ m/src\:/i) {
d53 4
a480 7
sub url
{
	my ($self, $name) = @@_;

	return $self->relative_url($name);
}

d500 1
a500 1
	if ($baseurl =~ m/^(http|ftp)\:\/\/(.*?)\//i) {
d559 1
a559 1
	my $baseurl = $self->{baseurl};
@


1.34
log
@name each urlscheme
@
text
@d2 1
a2 1
# $OpenBSD: PackageRepository.pm,v 1.33 2007/05/14 12:49:27 espie Exp $
d206 10
d241 1
a241 1
		    $self->{baseurl}.$object->{name}.".tgz"
d249 1
a249 1
	return -r $self->{baseurl}.$name.".tgz";
d275 5
d473 1
a473 1
	    "-", $self->{baseurl}.$object->{name}.".tgz"
d477 7
d616 1
a616 1
		my $fullname = $self->{baseurl};
d650 1
a650 1
		my $fullname = $self->{baseurl};
@


1.33
log
@move the retry code down at the http/ftp repository level, where it belongs.
@
text
@d2 1
a2 1
# $OpenBSD: PackageRepository.pm,v 1.32 2007/05/14 12:18:49 espie Exp $
d209 5
d260 5
d583 5
d615 4
@


1.32
log
@move parsing of http problems where it belongs.
@
text
@d2 1
a2 1
# $OpenBSD: PackageRepository.pm,v 1.31 2007/05/14 10:12:24 espie Exp $
d475 48
@


1.31
log
@move code around to allow OO access to installed packages always.
@
text
@d2 1
a2 1
# $OpenBSD: PackageRepository.pm,v 1.30 2007/05/14 10:00:08 espie Exp $
a197 38
	CORE::open(my $fh, '<', $filename) or return;

	my $baseurl = $self->{baseurl};
	local $_;
	my $notyet = 1;
	while(<$fh>) {
		next if m/^(?:200|220|221|226|229|230|227|250|331|500|150)[\s\-]/;
		next if m/^EPSV command not understood/;
		next if m/^Trying [\da-f\.\:]+\.\.\./;
		next if m/^Requesting \Q$baseurl\E/;
		next if m/^Remote system type is\s+/;
		next if m/^Connected to\s+/;
		next if m/^remote\:\s+/;
		next if m/^Using binary mode to transfer files/;
		next if m/^Retrieving\s+/;
		next if m/^Success?fully retrieved file/;
		next if m/^\d+\s+bytes\s+received\s+in/;
		next if m/^ftp: connect to address.*: No route to host/;

		if (defined $hint && $hint == 0) {
			next if m/^ftp: -: short write/;
			next if m/^421\s+/;
		}
		if ($notyet) {
			print STDERR "Error from $baseurl:\n" if $notyet;
			$notyet = 0;
		}
		if (m/^421\s+/ ||
		    m/^ftp: connect: Connection timed out/ ||
		    m/^ftp: Can't connect or login to host/) {
			$self->{lasterror} = 421;
		}
		if (m/^550\s+/) {
			$self->{lasterror} = 550;
		}
		print STDERR  $_;
	}
	CORE::close($fh);
d475 44
@


1.30
log
@maintain stemlist for installed packages dynamically
@
text
@d2 1
a2 1
# $OpenBSD: PackageRepository.pm,v 1.29 2007/05/13 17:00:02 espie Exp $
d4 1
a4 1
# Copyright (c) 2003-2006 Marc Espie <espie@@openbsd.org>
d21 6
d28 2
a75 10
sub match
{
	my ($self, $search, $filter) = @@_;
	if (defined $filter) {
		return &$filter($search->match_repo($self));
	} else {
		return $search->match_repo($self);
	}
}

a241 56
}

package OpenBSD::PackageRepository::Installed;
our @@ISA=qw(OpenBSD::PackageRepository);
use OpenBSD::PackageInfo;

my $singleton = bless {}, __PACKAGE__;

sub new
{
	return $singleton;
}

sub find
{
	my ($repository, $name, $arch, $srcpath) = @@_;
	my $self;

	if (is_installed($name)) {
		$self = OpenBSD::PackageLocation->new($repository, $name);
		$self->{dir} = installed_info($name);
	}
	return $self;
}

sub grabPlist
{
	my ($repository, $name, $arch, $code) = @@_;
	require OpenBSD::PackingList;
	return  OpenBSD::PackingList->from_installation($name, $code);
}

sub available
{
	return installed_packages();
}

sub list
{
	my @@list = installed_packages();
	return \@@list;
}

sub stemlist
{
	return installed_stems();
}

sub wipe_info
{
}

sub may_exist
{
	my ($self, $name) = @@_;
	return is_installed($name);
@


1.29
log
@remove some specialness of the Filtering stuff.
@
text
@d2 1
a2 1
# $OpenBSD: PackageRepository.pm,v 1.28 2007/05/13 13:37:00 espie Exp $
d285 5
@


1.28
log
@kill unused stuff
@
text
@d2 1
a2 1
# $OpenBSD: PackageRepository.pm,v 1.27 2007/05/13 13:32:36 espie Exp $
d70 6
a75 2
	my ($self, $search) = @@_;
	return $search->match_repo($self);
@


1.27
log
@unify object lookup as locator->match($o) or $repo->match($o)
@
text
@d2 1
a2 1
# $OpenBSD: PackageRepository.pm,v 1.26 2007/05/13 12:58:54 espie Exp $
a65 18
}

sub findstem
{
	my ($self, $stem) = @@_;
	return $self->stemlist->findstem($stem);
}

sub find_partialstem
{
	my ($self, $partial) = @@_;
	return $self->stemlist->find_partialstem($partial);
}

sub match_spec
{
	my ($self, $spec) = @@_;
	return $spec->match_repo($self);
@


1.26
log
@make caching of stemlists implicit
@
text
@d2 1
a2 1
# $OpenBSD: PackageRepository.pm,v 1.25 2007/05/13 09:31:24 espie Exp $
d84 6
@


1.25
log
@provide match_spec, findstem, find_partialstem at the repository list level,
with ld -L like semantics: we stop at the first repository which has the
corresponding packages..
@
text
@d2 1
a2 1
# $OpenBSD: PackageRepository.pm,v 1.24 2007/05/12 15:00:30 espie Exp $
d57 1
a57 1
sub findstem
d59 1
a59 1
	my ($self, $stem) = @@_;
d65 7
a71 1
	return $self->{stemlist}->findstem($stem);
d77 1
a77 6
	if (!defined $self->{stemlist}) {
		require OpenBSD::PackageName;

		$self->{stemlist} = OpenBSD::PackageName::avail2stems($self->available);
	}
	return $self->{stemlist}->find_partialstem($partial);
d83 1
a83 1
	return $spec->match_ref($self->list);
@


1.24
log
@kill old PkgSpec interface
@
text
@d2 1
a2 1
# $OpenBSD: PackageRepository.pm,v 1.23 2007/05/12 14:52:26 espie Exp $
d66 11
@


1.23
log
@use match_ref consistently
@
text
@d2 1
a2 1
# $OpenBSD: PackageRepository.pm,v 1.22 2007/05/12 14:16:38 espie Exp $
d71 1
a71 6
	if (ref $spec) {
		return $spec->match_ref($self->list);
	} else {
		require OpenBSD::PkgSpec;
		return OpenBSD::PkgSpec::match_ref($spec, $self->list);
	}
@


1.22
log
@also allow Spec objects in Repository matches.
@
text
@d2 1
a2 1
# $OpenBSD: PackageRepository.pm,v 1.21 2007/05/12 13:36:54 espie Exp $
d72 1
a72 1
		return $spec->match($self->list);
@


1.21
log
@pass refs around instead of extending them.
@
text
@d2 1
a2 1
# $OpenBSD: PackageRepository.pm,v 1.20 2007/05/08 08:44:17 espie Exp $
d71 6
a76 2
	require OpenBSD::PkgSpec;
	return OpenBSD::PkgSpec::match_ref($spec, $self->list);
@


1.20
log
@allow match_spec on repository
@
text
@d2 1
a2 1
# $OpenBSD: PackageRepository.pm,v 1.19 2007/05/07 14:29:24 espie Exp $
d72 1
a72 1
	return OpenBSD::PkgSpec::match($spec, @@{$self->list});
@


1.19
log
@cheap singleton for installed packages
@
text
@d2 1
a2 1
# $OpenBSD: PackageRepository.pm,v 1.18 2007/05/07 14:21:39 espie Exp $
d66 7
@


1.18
log
@lift up findstem to the PackageRepository
@
text
@d2 1
a2 1
# $OpenBSD: PackageRepository.pm,v 1.17 2007/05/07 09:32:51 espie Exp $
d240 2
d244 1
a244 1
	bless {}, shift;
@


1.17
log
@make sure all temporary file handling goes through OpenBSD::Temp
@
text
@d2 1
a2 1
# $OpenBSD: PackageRepository.pm,v 1.16 2007/05/02 15:05:30 espie Exp $
d55 11
@


1.16
log
@$o->method() becomes $o->method
@
text
@d2 1
a2 1
# $OpenBSD: PackageRepository.pm,v 1.15 2007/04/15 10:17:29 espie Exp $
d359 1
a359 1
	require File::Temp;
a361 1
	my $template = "$name.XXXXXXXXX";
d363 1
a363 2
	my ($copy, $filename) = File::Temp::tempfile($template,
	    DIR => $dir) or die "Can't write copy to cache";
@


1.15
log
@update copyright years, standardize licence.
reword the introduction to the stuff originally from FreeBSD to clarify
slightly.
@
text
@d2 1
a2 1
# $OpenBSD: PackageRepository.pm,v 1.14 2006/11/17 15:34:15 espie Exp $
d54 1
a54 1
	return @@{$self->list()};
d126 1
a126 1
	my $already = $self->opened();
d129 1
a129 1
		if (@@$already >= $self->maxcount()) {
d132 1
a132 1
		while (@@$already >= $self->maxcount()) {
d148 1
a148 1
	my $already = $self->make_room();
d165 1
a165 1
	return $self->openPackage();
d499 1
a499 1
		while (defined $object->intNext()) {
d556 1
a556 1
		$self->make_room();
d586 1
a586 1
		$self->make_room();
@


1.14
log
@don't return undef, use plain return.
(return undef is only false in a scalar context)
found my perlcritic, one of the few issues I agree with...
@
text
@d2 1
a2 1
# $OpenBSD: PackageRepository.pm,v 1.13 2006/09/16 15:04:23 espie Exp $
d4 1
a4 1
# Copyright (c) 2003-2004 Marc Espie <espie@@openbsd.org>
@


1.13
log
@fix error message parsing, okay deraadt@@
@
text
@d2 1
a2 1
# $OpenBSD: PackageRepository.pm,v 1.12 2006/03/13 16:08:12 espie Exp $
d145 1
a145 1
	return undef unless $self->may_exist($object->{name});
d151 1
a151 1
		return undef;
d484 1
a484 1
	open(my $fh, '-|', "$cmd") or return undef;
d560 1
a560 1
		open(my $fh, '-|', "ftp -o - $fullname 2>$error") or return undef;
@


1.12
log
@clean-up some name handling:
- package locations always contain a pkgname (except if we don't have it)
- complete it on the repository side to grab the right file.
- no need to pass pkgname/arch on $location->grabPlist(), since it's
already in the location.
@
text
@d2 1
a2 1
# $OpenBSD: PackageRepository.pm,v 1.11 2006/03/08 12:10:47 espie Exp $
d194 1
a194 1
		next if m/^Succesfully retrieved file/;
@


1.11
log
@propagate stuff to be able to explicitly clean-up repositories.
(we can't use a normal destructor, since this will be called for
each fork()ed subprocess).
@
text
@d2 1
a2 1
# $OpenBSD: PackageRepository.pm,v 1.10 2006/03/08 11:22:02 espie Exp $
d163 1
a163 2
	$name.=".tgz" unless $name =~ m/\.tgz$/;
	my $self = OpenBSD::PackageLocation->new($repository, $name);
d165 1
a165 1
	return $self->openPackage($name, $arch);
d171 1
a171 2
	$name.=".tgz" unless $name =~ m/\.tgz$/;
	my $self = OpenBSD::PackageLocation->new($repository, $name);
d173 1
a173 1
	return $self->grabPlist($name, $arch, $code);
d294 1
a294 1
		    $self->{baseurl}.$object->{name}
d302 1
a302 1
	return -r $self->{baseurl}.$name;
a330 1
	my $fullname = $self->{baseurl}.$object->{name};
d362 1
a362 2
	my $template = $name;
	$template =~ s/\.tgz$/.XXXXXXXX/;
d409 1
a409 1
		rename $filename, "$dir/$name";
d518 1
a518 1
	    "-", $self->{baseurl}.$object->{name}
@


1.10
log
@fix race condition in SCP for real.

We can't control a grand-child death through gzip, so stop spawning
grand-children: create two children connected by hand through a pipe,
and when we close gzip, explicitly wait for the second child to die
as well.

This avoids race conditions between sigpipe and sigusr1.

(and as usual, the resulting code is easier to follow once you get
through the pipe/fork).

Thanks theo for the comment. ;-)
@
text
@d2 1
a2 1
# $OpenBSD: PackageRepository.pm,v 1.9 2006/03/07 17:25:47 espie Exp $
d220 5
@


1.9
log
@do not write partial files out if the PKG_CACHE filesystem overflows.
@
text
@d2 1
a2 1
# $OpenBSD: PackageRepository.pm,v 1.8 2006/03/07 15:00:15 bernd Exp $
d90 1
d370 1
d412 1
d423 4
d433 19
a451 2
		$object->{pid2} = <$fh>;
		return $fh;
d454 11
a464 27

		my $pid2 = open(STDIN, "-|");

		if (!defined $pid2) {
			die "Cannot fork: $!";
		}
		if ($pid2) {
			print $pid2, "\n";
			exec {"/usr/bin/gzip"} 
			    "gzip", 
			    "-d", 
			    "-c", 
			    "-q", 
			    "-" 
			or die "can't run gzip";
		} else {
			if (defined $object->{cache_dir}) {
				my $pid3 = open(my $in, "-|");
				if (!defined $pid3) {
					die "Cannot fork: $!";
				}
				if ($pid3) {
					$self->pkg_copy($in, $object);
					exit(0);
				} else {
					$self->grab_object($object);
				}
d468 2
d471 1
d473 3
@


1.8
log
@Fix pkg_copy().
@
text
@d2 1
a2 1
# $OpenBSD: PackageRepository.pm,v 1.7 2006/03/07 14:18:51 espie Exp $
d374 1
d394 6
a399 1
		syswrite $copy, $buffer;
d405 1
a405 1
	if ($nonempty) {
@


1.7
log
@properly zap temporary file.
@
text
@d2 1
a2 1
# $OpenBSD: PackageRepository.pm,v 1.6 2006/03/07 14:00:21 espie Exp $
d365 1
a365 1
	$object->{tempname] = $filename;
@


1.6
log
@make pkg_copy be overidable by subclass.
@
text
@d2 1
a2 1
# $OpenBSD: PackageRepository.pm,v 1.5 2006/03/07 10:59:27 espie Exp $
d365 1
@


1.5
log
@pass the grandchild pid through the pipe, in order to be able to monitor it.
@
text
@d2 1
a2 1
# $OpenBSD: PackageRepository.pm,v 1.4 2006/03/06 12:00:28 espie Exp $
d354 1
a354 1
	my ($in, $dir, $name) = @@_;
d357 2
d412 1
d445 1
a445 2
					pkg_copy($in, $object->{cache_dir}, 
					    $object->{name});
@


1.4
log
@actually zap the code
@
text
@d2 1
a2 1
# $OpenBSD: PackageRepository.pm,v 1.3 2006/03/06 11:22:13 espie Exp $
d416 1
d427 1
@


1.3
log
@typo
@
text
@d2 1
a2 1
# $OpenBSD: PackageRepository.pm,v 1.2 2006/03/06 10:40:31 espie Exp $
a267 35
}

package PackageRepository::Source;

sub find
{
	my ($repository, $name, $arch, $srcpath) = @@_;
	my $dir;
	my $make;
	if (defined $ENV{'MAKE'}) {
		$make = $ENV{'MAKE'};
	} else {
		$make = '/usr/bin/make';
	}
	if (defined $repository->{baseurl} && $repository->{baseurl} ne '') {
		$dir = $repository->{baseurl}
	} elsif (defined $ENV{PORTSDIR}) {
		$dir = $ENV{PORTSDIR};
	} else {
		$dir = '/usr/ports';
	}
	# figure out the repository name and the pkgname
	my $pkgfile = `cd $dir && SUBDIR=$srcpath ECHO_MSG=: $make show=PKGFILE`;
	chomp $pkgfile;
	if (! -f $pkgfile) {
		system "cd $dir && SUBDIR=$srcpath $make package BULK=Yes";
	}
	if (! -f $pkgfile) {
		return undef;
	}
	$pkgfile =~ m|(.*/)([^/]*)|;
	my ($base, $fname) = ($1, $2);

	my $repo = OpenBSD::PackageRepository::Local->_new($base);
	return $repo->find($fname);
@


1.2
log
@take some infrequently used code completely out of the way.
@
text
@d2 1
a2 1
# $OpenBSD: PackageRepository.pm,v 1.1 2006/03/04 13:13:05 espie Exp $
d38 1
a38 1
		require OpenBSD::PackageRepositorySCP;
@


1.1
log
@cut down the Locator code into maintainable chunks.
@
text
@d2 1
a2 1
# $OpenBSD$
d38 2
d42 2
a511 51
}

package OpenBSD::PackageRepository::SCP;
our @@ISA=qw(OpenBSD::PackageRepository::Distant);


sub grab_object
{
	my ($self, $object) = @@_;

	exec {"/usr/bin/scp"} 
	    "scp", 
	    $self->{host}.":".$self->{path}.$object->{name}, 
	    "/dev/stdout"
	or die "can't run scp";
}

our %distant = ();

sub maxcount
{
	return 2;
}

sub opened
{
	my $self = $_[0];
	my $k = $self->{key};
	if (!defined $distant{$k}) {
		$distant{$k} = [];
	}
	return $distant{$k};
}

sub _new
{
	my ($class, $baseurl) = @@_;
	$baseurl =~ s/scp\:\/\///i;
	$baseurl =~ m/\//;
	bless {	host => $`, key => $`, path => "/$'" }, $class;
}

sub list
{
	my ($self) = @@_;
	if (!defined $self->{list}) {
		my $host = $self->{host};
		my $path = $self->{path};
		$self->{list} = $self->_list("ssh $host ls -l $path");
	}
	return $self->{list};
@

