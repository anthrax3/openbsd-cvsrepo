head	1.31;
access;
symbols
	OPENBSD_6_1:1.30.0.10
	OPENBSD_6_1_BASE:1.30
	OPENBSD_6_0:1.30.0.8
	OPENBSD_6_0_BASE:1.30
	OPENBSD_5_9:1.30.0.2
	OPENBSD_5_9_BASE:1.30
	OPENBSD_5_8:1.30.0.4
	OPENBSD_5_8_BASE:1.30
	OPENBSD_5_7:1.29.0.2
	OPENBSD_5_7_BASE:1.29
	OPENBSD_5_6:1.28.0.18
	OPENBSD_5_6_BASE:1.28
	OPENBSD_5_5:1.28.0.16
	OPENBSD_5_5_BASE:1.28
	OPENBSD_5_4:1.28.0.12
	OPENBSD_5_4_BASE:1.28
	OPENBSD_5_3:1.28.0.10
	OPENBSD_5_3_BASE:1.28
	OPENBSD_5_2:1.28.0.8
	OPENBSD_5_2_BASE:1.28
	OPENBSD_5_1_BASE:1.28
	OPENBSD_5_1:1.28.0.6
	OPENBSD_5_0:1.28.0.4
	OPENBSD_5_0_BASE:1.28
	OPENBSD_4_9:1.28.0.2
	OPENBSD_4_9_BASE:1.28
	OPENBSD_4_8:1.26.0.2
	OPENBSD_4_8_BASE:1.26
	OPENBSD_4_7:1.21.0.2
	OPENBSD_4_7_BASE:1.21
	OPENBSD_4_6:1.17.0.4
	OPENBSD_4_6_BASE:1.17
	OPENBSD_4_5:1.16.0.8
	OPENBSD_4_5_BASE:1.16
	OPENBSD_4_4:1.16.0.6
	OPENBSD_4_4_BASE:1.16
	OPENBSD_4_3:1.16.0.4
	OPENBSD_4_3_BASE:1.16
	OPENBSD_4_2:1.16.0.2
	OPENBSD_4_2_BASE:1.16
	OPENBSD_4_1:1.3.0.2
	OPENBSD_4_1_BASE:1.3
	OPENBSD_4_0:1.2.0.2
	OPENBSD_4_0_BASE:1.2;
locks; strict;
comment	@# @;


1.31
date	2017.05.29.12.28.54;	author espie;	state Exp;
branches;
next	1.30;
commitid	Cgf05tZggkOgfUsE;

1.30
date	2015.07.09.12.57.55;	author espie;	state Exp;
branches;
next	1.29;
commitid	S4ZL4GlS2rrkQYde;

1.29
date	2015.02.03.10.26.29;	author espie;	state Exp;
branches;
next	1.28;
commitid	hXQolFOeWQ48akSA;

1.28
date	2010.12.24.09.04.14;	author espie;	state Exp;
branches;
next	1.27;

1.27
date	2010.10.27.14.35.56;	author espie;	state Exp;
branches;
next	1.26;

1.26
date	2010.07.02.11.17.46;	author espie;	state Exp;
branches;
next	1.25;

1.25
date	2010.06.30.10.51.04;	author espie;	state Exp;
branches;
next	1.24;

1.24
date	2010.06.30.10.41.42;	author espie;	state Exp;
branches;
next	1.23;

1.23
date	2010.06.25.10.13.37;	author espie;	state Exp;
branches;
next	1.22;

1.22
date	2010.05.10.09.17.55;	author espie;	state Exp;
branches;
next	1.21;

1.21
date	2010.01.09.14.49.53;	author espie;	state Exp;
branches;
next	1.20;

1.20
date	2010.01.09.13.43.14;	author espie;	state Exp;
branches;
next	1.19;

1.19
date	2010.01.09.09.45.40;	author espie;	state Exp;
branches;
next	1.18;

1.18
date	2010.01.09.09.37.45;	author espie;	state Exp;
branches;
next	1.17;

1.17
date	2009.04.19.14.58.32;	author espie;	state Exp;
branches;
next	1.16;

1.16
date	2007.05.19.09.50.31;	author espie;	state Exp;
branches;
next	1.15;

1.15
date	2007.05.19.09.18.55;	author espie;	state Exp;
branches;
next	1.14;

1.14
date	2007.05.14.12.52.53;	author espie;	state Exp;
branches;
next	1.13;

1.13
date	2007.05.14.12.49.27;	author espie;	state Exp;
branches;
next	1.12;

1.12
date	2007.05.14.09.49.27;	author espie;	state Exp;
branches;
next	1.11;

1.11
date	2007.05.13.17.00.02;	author espie;	state Exp;
branches;
next	1.10;

1.10
date	2007.05.13.13.37.00;	author espie;	state Exp;
branches;
next	1.9;

1.9
date	2007.05.13.13.32.36;	author espie;	state Exp;
branches;
next	1.8;

1.8
date	2007.05.13.13.12.21;	author espie;	state Exp;
branches;
next	1.7;

1.7
date	2007.05.13.10.10.35;	author espie;	state Exp;
branches;
next	1.6;

1.6
date	2007.05.13.09.31.24;	author espie;	state Exp;
branches;
next	1.5;

1.5
date	2007.05.02.15.05.30;	author espie;	state Exp;
branches;
next	1.4;

1.4
date	2007.04.15.10.17.29;	author espie;	state Exp;
branches;
next	1.3;

1.3
date	2006.11.17.15.34.15;	author espie;	state Exp;
branches;
next	1.2;

1.2
date	2006.03.08.12.10.47;	author espie;	state Exp;
branches;
next	1.1;

1.1
date	2006.03.04.13.13.05;	author espie;	state Exp;
branches;
next	;


desc
@@


1.31
log
@Refactor locator code so it's a proper object.
allow  fw_update to short-circuit entirely, thus the specific
treatment of paths is actually less of a special case,
and the code that reaches into /etc/installurl is no longer used
at all in that case.

problem noticed by mlarkin@@
@
text
@# ex:ts=8 sw=4:
# $OpenBSD: PackageRepositoryList.pm,v 1.30 2015/07/09 12:57:55 espie Exp $
#
# Copyright (c) 2003-2006 Marc Espie <espie@@openbsd.org>
#
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

use strict;
use warnings;

package OpenBSD::PackageRepositoryList;

sub new
{
	my ($class, $state) = @@_;
	return bless {l => [], k => {}, state => $state}, $class;
}

sub filter_new
{
	my $self = shift;
	my @@l = ();
	for my $r (@@_) {
		next if !defined $r;
		next if $self->{k}{$r};
		$self->{k}{$r} = 1;
		push @@l, $r;
	}
	return @@l;
}

sub add
{
	my $self = shift;
	push @@{$self->{l}}, $self->filter_new(@@_);
}

sub prepend
{
	my $self = shift;
	unshift @@{$self->{l}}, $self->filter_new(@@_);
}

sub do_something
{
	my ($self, $do, $pkgname, @@args) = @@_;
	if (defined $pkgname && $pkgname eq '-') {
		return OpenBSD::PackageRepository->pipe->new($self->{state})->$do($pkgname, @@args);
	}
	for my $repo (@@{$self->{l}}) {
		my $r = $repo->$do($pkgname, @@args);
		return $r if defined $r;
	}
	return undef;
}

sub find
{
	my ($self, @@args) = @@_;

	return $self->do_something('find', @@args);
}

sub grabPlist
{
	my ($self, @@args) = @@_;
	return $self->do_something('grabPlist', @@args);
}

sub match_locations
{
	my ($self, @@search) = @@_;
	for my $repo (@@{$self->{l}}) {
		my $l = $repo->match_locations(@@search);
		if (@@$l > 0) {
			return $l;
		}
	}
	return [];
}

1;
@


1.30
log
@gc old code, from Jean-Philippe Ouellet
@
text
@d2 1
a2 1
# $OpenBSD: PackageRepositoryList.pm,v 1.29 2015/02/03 10:26:29 espie Exp $
d57 1
a57 1
	if ($pkgname eq '-') {
@


1.29
log
@zap scp urls from quirks update for fw_update
@
text
@d2 1
a2 1
# $OpenBSD: PackageRepositoryList.pm,v 1.28 2010/12/24 09:04:14 espie Exp $
a89 11
}

sub print_without_src
{
	my $self = shift;
	my @@l = ();
	for my $repo (@@$self) {
		next if $repo->isa("OpenBSD::PackageRepository::Source");
		push(@@l, $repo->url);
	}
	return join(':', @@l);
@


1.28
log
@handle failures from ports tree with more care.
this does avoid infinite loops in case of wrong plists.
necessary since print-plist-with-depends CAN fail...
@
text
@d2 1
a2 1
# $OpenBSD$
d34 1
@


1.27
log
@initial scaffolding for @@rcscript: for now, acts like normal files,
but allow absolute pathnames (treat that as an implicit @@cwd).
@
text
@@


1.26
log
@pass (and save) state around in Repository-related stuff.
@
text
@d2 1
a2 1
# $OpenBSD: PackageRepositoryList.pm,v 1.25 2010/06/30 10:51:04 espie Exp $
@


1.25
log
@allow say and errsay to work without parameters, as it's ways common.
create verbose_system up in state, because it makes sense without verbose.
@
text
@d2 1
a2 1
# $OpenBSD$
d25 2
a26 2
	my $class = shift;
	return bless {l => [], k => {}}, $class;
d57 1
a57 1
		return OpenBSD::PackageRepository::Local::Pipe->new->$do($pkgname, @@args);
@


1.24
log
@whitespace cleanup
@
text
@@


1.23
log
@fix "deduplicate" code.
allow prepend as well as add
@
text
@d2 1
a2 1
# $OpenBSD: PackageRepositoryList.pm,v 1.22 2010/05/10 09:17:55 espie Exp $
@


1.22
log
@whitespace fixes
@
text
@d2 1
a2 1
# $OpenBSD$
d26 1
a26 1
	return bless {l => [], c => {}, k => {}}, $class;
d29 1
a29 1
sub add
d32 1
d35 2
a36 1
		push @@{$self->{l}}, $r;
d38 13
@


1.21
log
@move signal catching up, so we can clean repos and temp files at once.
Fix main program try/catch: signal message should use standard form so
it gets caught.
@
text
@@


1.20
log
@slightly more complex repolist, to allow for:
- caching locations
- avoid readding known paths (done thx to unique repo objects)
@
text
@a75 8
sub cleanup
{
	my $self = shift;
	for my $repo (@@$self) {
		$repo->cleanup;
	}
}

@


1.19
log
@move pipe handling into RepositoryList
@
text
@d26 1
a26 1
	return bless [], $class;
d32 4
a35 1
	push @@$self, @@_;
d38 1
a38 1
sub find
d40 1
a40 2
	my ($self, $pkgname, $arch) = @@_;

d42 1
a42 1
		return OpenBSD::PackageRepository::Local::Pipe->new->find($pkgname, $arch);
d44 3
a46 3
	for my $repo (@@$self) {
		my $pkg = $repo->find($pkgname, $arch);
		return $pkg if defined $pkg;
d48 1
a48 1
	return;
d51 1
a51 1
sub grabPlist
d53 1
a53 1
	my ($self, $pkgname, $arch, $code) = @@_;
d55 2
a56 3
	if ($pkgname eq '-') {
		return OpenBSD::PackageRepository::Local::Pipe->new->grabPlist($pkgname, $arch, $code);
	}
d58 4
a61 5
	for my $repo (@@$self) {
		my $plist = $repo->grabPlist($pkgname, $arch, $code);
		return $plist if defined $plist;
	}
	return;
d67 1
a67 1
	for my $repo (@@$self) {
@


1.18
log
@repositories no longer need match
@
text
@d39 3
d52 4
@


1.17
log
@synch with my new style search/location changes
It's likely there will be some fallout, but it's getting a bit too large
to keep around.
This does kill a few very old oddities as well.
@
text
@a56 12
sub match
{
	my ($self, @@search) = @@_;
	for my $repo (@@$self) {
		my @@l = $repo->match(@@search);
		if (@@l > 0) {
			return @@l;
		}
	}
	return ();
}

@


1.16
log
@and I forgot this one
@
text
@d2 1
a2 1
# $OpenBSD: PackageRepositoryList.pm,v 1.15 2007/05/19 09:18:55 espie Exp $
d26 1
a26 1
	return bless {list => [] }, $class;
d32 1
a32 1
	push @@{$self->{list}}, @@_;
d39 1
a39 1
	for my $repo (@@{$self->{list}}) {
d50 1
a50 1
	for my $repo (@@{$self->{list}}) {
d60 1
a60 1
	for my $repo (@@{$self->{list}}) {
d72 4
a75 4
	for my $repo (@@{$self->{list}}) {
		my @@l = $repo->match_locations(@@search);
		if (@@l > 0) {
			return @@l;
d78 1
a78 1
	return ();
d84 1
a84 1
	for my $repo (@@{$self->{list}}) {
d87 11
@


1.15
log
@don't pass srcpath around, since we don't use it.
@
text
@d2 1
a2 1
# $OpenBSD: PackageRepositoryList.pm,v 1.14 2007/05/14 12:52:53 espie Exp $
d62 12
@


1.14
log
@kill "available" routine, which is no longer used.
@
text
@d2 1
a2 1
# $OpenBSD: PackageRepositoryList.pm,v 1.13 2007/05/14 12:49:27 espie Exp $
d37 1
a37 1
	my ($self, $pkgname, $arch, $srcpath) = @@_;
d40 1
a40 1
		my $pkg = $repo->find($pkgname, $arch, $srcpath);
@


1.13
log
@move the retry code down at the http/ftp repository level, where it belongs.
@
text
@d2 1
a2 1
# $OpenBSD: PackageRepositoryList.pm,v 1.12 2007/05/14 09:49:27 espie Exp $
d26 1
a26 1
	return bless {list => [], avail => undef }, $class;
a32 3
	if (@@_ > 0) {
		$self->{avail} = undef;
	}
a54 16
}

sub available
{
	my $self = shift;

	if (!defined $self->{avail}) {
		my $available_packages = {};
		foreach my $loc (reverse @@{$self->{list}}) {
		    foreach my $pkg (@@{$loc->list}) {
		    	$available_packages->{$pkg} = $loc;
		    }
		}
		$self->{avail} = $available_packages;
	}
	return keys %{$self->{avail}};
@


1.12
log
@tidy
@
text
@d2 1
a2 1
# $OpenBSD: PackageRepositoryList.pm,v 1.11 2007/05/13 17:00:02 espie Exp $
d43 1
a43 15
		my $pkg;

		for (my $retry = 5; $retry < 60; $retry *= 2) {
			undef $repo->{lasterror};
			$pkg = $repo->find($pkgname, $arch, $srcpath);
			if (!defined $pkg && defined $repo->{lasterror} && 
			    $repo->{lasterror} == 421 && 
			    defined $self->{avail} &&
			    $self->{avail}->{$pkgname} eq $repo) { 
				print STDERR "Temporary error, sleeping $retry seconds\n";
				sleep($retry);
			} else {
				last;
			}
		}
d54 1
a54 15
		my $plist;

		for (my $retry = 5; $retry < 60; $retry *= 2) {
			undef $repo->{lasterror};
			$plist = $repo->grabPlist($pkgname, $arch, $code);
			if (!defined $plist && defined $repo->{lasterror} && 
			    $repo->{lasterror} == 421 && 
			    defined $self->{avail} &&
			    $self->{avail}->{$pkgname} eq $repo) { 
				print STDERR "Temporary error, sleeping $retry seconds\n";
				sleep($retry);
			} else {
				last;
			}
		}
@


1.11
log
@remove some specialness of the Filtering stuff.
@
text
@d2 1
a2 1
# $OpenBSD: PackageRepositoryList.pm,v 1.10 2007/05/13 13:37:00 espie Exp $
d95 1
a95 1
		    foreach my $pkg (@@{$loc->list()}) {
@


1.10
log
@kill unused stuff
@
text
@d2 1
a2 1
# $OpenBSD: PackageRepositoryList.pm,v 1.9 2007/05/13 13:32:36 espie Exp $
d106 1
a106 1
	my ($self, $search, $filter) = @@_;
d108 1
a108 4
		my @@l = $repo->match($search);
		if (defined $filter) {
			@@l = &$filter(@@l);
		}
@


1.9
log
@unify object lookup as locator->match($o) or $repo->match($o)
@
text
@d2 1
a2 1
# $OpenBSD: PackageRepositoryList.pm,v 1.8 2007/05/13 13:12:21 espie Exp $
d104 1
a104 1
sub _first_of
d106 1
a106 1
	my ($self, $method, $filter, @@args) = @@_;
d108 1
a108 1
		my @@l = $repo->$method(@@args);
a116 24
}

sub find_partialstem
{
	my ($self, $partial, $filter) = @@_;
	return $self->_first_of('find_partialstem', $filter, $partial);
}

sub findstem
{
	my ($self, $stem, $filter) = @@_;
	return $self->_first_of('findstem', $filter, $stem);
}

sub match_spec
{
	my ($self, $spec, $filter) = @@_;
	return $self->_first_of('match_spec', $filter, $spec);
}

sub match
{
	my ($self, $spec, $filter) = @@_;
	return $self->_first_of('match', $filter, $spec);
@


1.8
log
@also create PartialStem objects, and create a generic
PackageLocator->match($o), where $o can be a spec, a stem, a partialstem.
@
text
@d2 1
a2 1
# $OpenBSD: PackageRepositoryList.pm,v 1.7 2007/05/13 10:10:35 espie Exp $
d137 1
a137 1
sub match_repo
d140 1
a140 1
	return $self->_first_of('match_repo', $filter, $spec);
@


1.7
log
@tweak _first_of so it can take an extra $filter routine, so that we
get the first set of results that are non empty after filtering
properly.
@
text
@d2 1
a2 1
# $OpenBSD: PackageRepositoryList.pm,v 1.6 2007/05/13 09:31:24 espie Exp $
d135 6
@


1.6
log
@provide match_spec, findstem, find_partialstem at the repository list level,
with ld -L like semantics: we stop at the first repository which has the
corresponding packages..
@
text
@d2 1
a2 1
# $OpenBSD: PackageRepositoryList.pm,v 1.5 2007/05/02 15:05:30 espie Exp $
d106 1
a106 1
	my ($self, $method, @@args) = @@_;
d109 3
d121 2
a122 2
	my ($self, $partial) = @@_;
	return $self->_first_of('find_partialstem', $partial);
d127 2
a128 2
	my ($self, $stem) = @@_;
	return $self->_first_of('findstem', $stem);
d133 2
a134 2
	my ($self, $spec) = @@_;
	return $self->_first_of('match_spec', $spec);
@


1.5
log
@$o->method() becomes $o->method
@
text
@d2 1
a2 1
# $OpenBSD: PackageRepositoryList.pm,v 1.4 2007/04/15 10:17:29 espie Exp $
d102 30
@


1.4
log
@update copyright years, standardize licence.
reword the introduction to the stuff originally from FreeBSD to clarify
slightly.
@
text
@d2 1
a2 1
# $OpenBSD: PackageRepositoryList.pm,v 1.3 2006/11/17 15:34:15 espie Exp $
d108 1
a108 1
		$repo->cleanup();
@


1.3
log
@don't return undef, use plain return.
(return undef is only false in a scalar context)
found my perlcritic, one of the few issues I agree with...
@
text
@d2 1
a2 1
# $OpenBSD: PackageRepositoryList.pm,v 1.2 2006/03/08 12:10:47 espie Exp $
d4 1
a4 1
# Copyright (c) 2003-2004 Marc Espie <espie@@openbsd.org>
@


1.2
log
@propagate stuff to be able to explicitly clean-up repositories.
(we can't use a normal destructor, since this will be called for
each fork()ed subprocess).
@
text
@d2 1
a2 1
# $OpenBSD: PackageRepositoryList.pm,v 1.1 2006/03/04 13:13:05 espie Exp $
d60 1
a60 1
	return undef;
d85 1
a85 1
	return undef;
@


1.1
log
@cut down the Locator code into maintainable chunks.
@
text
@d2 1
a2 1
# $OpenBSD: PackageLocator.pm,v 1.51 2006/03/04 11:28:03 espie Exp $
d102 8
@

