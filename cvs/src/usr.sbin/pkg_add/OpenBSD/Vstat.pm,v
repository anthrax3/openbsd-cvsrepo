head	1.68;
access;
symbols
	OPENBSD_6_1:1.68.0.14
	OPENBSD_6_1_BASE:1.68
	OPENBSD_6_0:1.68.0.12
	OPENBSD_6_0_BASE:1.68
	OPENBSD_5_9:1.68.0.6
	OPENBSD_5_9_BASE:1.68
	OPENBSD_5_8:1.68.0.8
	OPENBSD_5_8_BASE:1.68
	OPENBSD_5_7:1.68.0.2
	OPENBSD_5_7_BASE:1.68
	OPENBSD_5_6:1.68.0.4
	OPENBSD_5_6_BASE:1.68
	OPENBSD_5_5:1.67.0.6
	OPENBSD_5_5_BASE:1.67
	OPENBSD_5_4:1.67.0.2
	OPENBSD_5_4_BASE:1.67
	OPENBSD_5_3:1.65.0.8
	OPENBSD_5_3_BASE:1.65
	OPENBSD_5_2:1.65.0.6
	OPENBSD_5_2_BASE:1.65
	OPENBSD_5_1_BASE:1.65
	OPENBSD_5_1:1.65.0.4
	OPENBSD_5_0:1.65.0.2
	OPENBSD_5_0_BASE:1.65
	OPENBSD_4_9:1.64.0.2
	OPENBSD_4_9_BASE:1.64
	OPENBSD_4_8:1.62.0.2
	OPENBSD_4_8_BASE:1.62
	OPENBSD_4_7:1.56.0.2
	OPENBSD_4_7_BASE:1.56
	OPENBSD_4_6:1.43.0.12
	OPENBSD_4_6_BASE:1.43
	OPENBSD_4_5:1.43.0.8
	OPENBSD_4_5_BASE:1.43
	OPENBSD_4_4:1.43.0.6
	OPENBSD_4_4_BASE:1.43
	OPENBSD_4_3:1.43.0.4
	OPENBSD_4_3_BASE:1.43
	OPENBSD_4_2:1.43.0.2
	OPENBSD_4_2_BASE:1.43
	OPENBSD_4_1:1.18.0.2
	OPENBSD_4_1_BASE:1.18
	OPENBSD_4_0:1.14.0.4
	OPENBSD_4_0_BASE:1.14
	OPENBSD_3_9:1.14.0.2
	OPENBSD_3_9_BASE:1.14
	OPENBSD_3_8:1.12.0.2
	OPENBSD_3_8_BASE:1.12
	OPENBSD_3_7:1.10.0.2
	OPENBSD_3_7_BASE:1.10
	OPENBSD_3_6:1.7.0.2
	OPENBSD_3_6_BASE:1.7
	OPENBSD_3_5:1.4.0.2
	OPENBSD_3_5_BASE:1.4;
locks; strict;
comment	@# @;


1.68
date	2014.03.18.18.53.29;	author espie;	state Exp;
branches;
next	1.67;

1.67
date	2013.07.08.08.49.57;	author jasper;	state Exp;
branches;
next	1.66;

1.66
date	2013.04.16.09.33.20;	author espie;	state Exp;
branches;
next	1.65;

1.65
date	2011.06.16.10.58.12;	author espie;	state Exp;
branches;
next	1.64;

1.64
date	2010.12.24.09.04.14;	author espie;	state Exp;
branches;
next	1.63;

1.63
date	2010.10.02.13.33.05;	author espie;	state Exp;
branches;
next	1.62;

1.62
date	2010.08.01.10.03.24;	author espie;	state Exp;
branches;
next	1.61;

1.61
date	2010.06.30.10.51.04;	author espie;	state Exp;
branches;
next	1.60;

1.60
date	2010.06.30.10.41.42;	author espie;	state Exp;
branches;
next	1.59;

1.59
date	2010.06.09.07.26.01;	author espie;	state Exp;
branches;
next	1.58;

1.58
date	2010.05.10.09.17.55;	author espie;	state Exp;
branches;
next	1.57;

1.57
date	2010.04.05.13.46.24;	author espie;	state Exp;
branches;
next	1.56;

1.56
date	2010.01.14.19.35.55;	author espie;	state Exp;
branches;
next	1.55;

1.55
date	2010.01.08.16.42.56;	author espie;	state Exp;
branches;
next	1.54;

1.54
date	2010.01.05.11.00.57;	author espie;	state Exp;
branches;
next	1.53;

1.53
date	2010.01.03.09.30.40;	author espie;	state Exp;
branches;
next	1.52;

1.52
date	2010.01.03.00.59.31;	author espie;	state Exp;
branches;
next	1.51;

1.51
date	2010.01.02.14.53.04;	author espie;	state Exp;
branches;
next	1.50;

1.50
date	2010.01.02.14.45.40;	author espie;	state Exp;
branches;
next	1.49;

1.49
date	2010.01.02.14.33.57;	author espie;	state Exp;
branches;
next	1.48;

1.48
date	2010.01.02.14.13.02;	author espie;	state Exp;
branches;
next	1.47;

1.47
date	2010.01.02.12.59.45;	author espie;	state Exp;
branches;
next	1.46;

1.46
date	2009.12.21.13.24.57;	author espie;	state Exp;
branches;
next	1.45;

1.45
date	2009.12.20.22.38.45;	author espie;	state Exp;
branches;
next	1.44;

1.44
date	2009.11.11.12.21.20;	author espie;	state Exp;
branches;
next	1.43;

1.43
date	2007.06.30.11.38.38;	author espie;	state Exp;
branches;
next	1.42;

1.42
date	2007.06.26.14.40.25;	author espie;	state Exp;
branches;
next	1.41;

1.41
date	2007.06.16.09.29.37;	author espie;	state Exp;
branches;
next	1.40;

1.40
date	2007.06.11.09.12.27;	author espie;	state Exp;
branches;
next	1.39;

1.39
date	2007.06.10.16.05.49;	author espie;	state Exp;
branches;
next	1.38;

1.38
date	2007.06.07.12.57.33;	author espie;	state Exp;
branches;
next	1.37;

1.37
date	2007.06.06.15.36.32;	author espie;	state Exp;
branches;
next	1.36;

1.36
date	2007.06.06.15.35.20;	author espie;	state Exp;
branches;
next	1.35;

1.35
date	2007.06.06.15.31.06;	author espie;	state Exp;
branches;
next	1.34;

1.34
date	2007.06.05.23.19.00;	author espie;	state Exp;
branches;
next	1.33;

1.33
date	2007.06.04.14.57.33;	author espie;	state Exp;
branches;
next	1.32;

1.32
date	2007.06.04.14.40.39;	author espie;	state Exp;
branches;
next	1.31;

1.31
date	2007.06.01.14.58.29;	author espie;	state Exp;
branches;
next	1.30;

1.30
date	2007.05.30.14.04.51;	author espie;	state Exp;
branches;
next	1.29;

1.29
date	2007.05.29.10.40.20;	author espie;	state Exp;
branches;
next	1.28;

1.28
date	2007.05.28.13.00.05;	author espie;	state Exp;
branches;
next	1.27;

1.27
date	2007.05.28.12.16.55;	author espie;	state Exp;
branches;
next	1.26;

1.26
date	2007.05.27.22.18.14;	author espie;	state Exp;
branches;
next	1.25;

1.25
date	2007.05.27.22.04.17;	author espie;	state Exp;
branches;
next	1.24;

1.24
date	2007.05.27.11.21.55;	author espie;	state Exp;
branches;
next	1.23;

1.23
date	2007.05.27.10.38.12;	author espie;	state Exp;
branches;
next	1.22;

1.22
date	2007.05.26.12.22.38;	author espie;	state Exp;
branches;
next	1.21;

1.21
date	2007.05.25.13.18.57;	author espie;	state Exp;
branches;
next	1.20;

1.20
date	2007.05.22.10.11.59;	author espie;	state Exp;
branches;
next	1.19;

1.19
date	2007.04.15.10.17.29;	author espie;	state Exp;
branches;
next	1.18;

1.18
date	2007.03.07.11.24.07;	author espie;	state Exp;
branches;
next	1.17;

1.17
date	2007.03.07.00.09.46;	author espie;	state Exp;
branches;
next	1.16;

1.16
date	2007.03.06.23.35.01;	author espie;	state Exp;
branches;
next	1.15;

1.15
date	2007.02.24.18.45.11;	author espie;	state Exp;
branches;
next	1.14;

1.14
date	2006.02.07.10.56.55;	author espie;	state Exp;
branches;
next	1.13;

1.13
date	2005.11.29.09.31.07;	author bernd;	state Exp;
branches;
next	1.12;

1.12
date	2005.08.22.11.25.59;	author espie;	state Exp;
branches;
next	1.11;

1.11
date	2005.08.22.11.11.39;	author espie;	state Exp;
branches;
next	1.10;

1.10
date	2004.12.29.11.28.59;	author espie;	state Exp;
branches;
next	1.9;

1.9
date	2004.12.17.11.26.22;	author espie;	state Exp;
branches;
next	1.8;

1.8
date	2004.11.11.15.35.10;	author espie;	state Exp;
branches;
next	1.7;

1.7
date	2004.08.06.07.51.17;	author espie;	state Exp;
branches;
next	1.6;

1.6
date	2004.07.07.22.00.06;	author espie;	state Exp;
branches;
next	1.5;

1.5
date	2004.04.28.06.47.12;	author espie;	state Exp;
branches;
next	1.4;

1.4
date	2004.03.10.08.21.40;	author espie;	state Exp;
branches;
next	1.3;

1.3
date	2003.12.26.16.34.05;	author espie;	state Exp;
branches;
next	1.2;

1.2
date	2003.12.24.02.31.28;	author espie;	state Exp;
branches;
next	1.1;

1.1
date	2003.12.21.18.41.23;	author espie;	state Exp;
branches;
next	;


desc
@@


1.68
log
@remove $_ usage that warns under perl 5.18
@
text
@# ex:ts=8 sw=4:
# $OpenBSD: Vstat.pm,v 1.67 2013/07/08 08:49:57 jasper Exp $
#
# Copyright (c) 2003-2007 Marc Espie <espie@@openbsd.org>
#
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

# Provides stat and statfs-like functions for package handling.

# allows user to add/remove files.

# uses mount and df directly for now.

use strict;
use warnings;

{
package OpenBSD::Vstat::Object;
my $cache = {};
my $x = undef;
my $dummy = bless \$x, __PACKAGE__;

sub new
{
	my ($class, $value) = @@_;
	if (!defined $value) {
		return $dummy;
	}
	if (!defined $cache->{$value}) {
		$cache->{$value} = bless \$value, $class;
	}
	return $cache->{$value};
}

sub exists
{
	return 1;
}

sub value
{
	my $self = shift;
	return $$self;
}

sub none
{
	return OpenBSD::Vstat::Object::None->new;
}

}

{
package OpenBSD::Vstat::Object::None;
our @@ISA = qw(OpenBSD::Vstat::Object);

my $x = undef;
my $none = bless \$x, __PACKAGE__;

sub exists
{
	return 0;
}

sub new
{
	return $none;
}
}

{
package OpenBSD::Vstat::Object::Directory;
our @@ISA = qw(OpenBSD::Vstat::Object);

sub new
{
	my ($class, $fname, $set, $o) = @@_;
	bless { name => $fname, set => $set, o => $o }, $class;
}

# XXX directories don't do anything until you test for their presence.
# which only happens if you want to replace a directory with a file.
sub exists
{
	my $self = shift;
	require OpenBSD::SharedItems;

	return OpenBSD::SharedItems::check_shared($self->{set}, $self->{o});
}

}

package OpenBSD::Vstat;
use File::Basename;
use OpenBSD::Paths;

sub stat
{
	my ($self, $fname) = @@_;
	my $dev = (stat $fname)[0];

	if (!defined $dev && $fname ne '/') {
		return $self->stat(dirname($fname));
	}
	return OpenBSD::Mounts->find($dev, $fname, $self->{state});
}

sub account_for
{
	my ($self, $name, $size) = @@_;
	my $e = $self->stat($name);
	$e->{used} += $size;
	return $e;
}

sub account_later
{
	my ($self, $name, $size) = @@_;
	my $e = $self->stat($name);
	$e->{delayed} += $size;
	return $e;
}

sub new
{
	my ($class, $state) = @@_;

	bless {v => [{}], state => $state}, $class;
}

sub exists
{
	my ($self, $name) = @@_;
	for my $v (@@{$self->{v}}) {
		if (defined $v->{$name}) {
			return $v->{$name}->exists;
		}
	}
	return -e $name;
}

sub value
{
	my ($self, $name) = @@_;
	for my $v (@@{$self->{v}}) {
		if (defined $v->{$name}) {
			return $v->{$name}->value;
		}
	}
	return undef;
}

sub synchronize
{
	my $self = shift;

	OpenBSD::Mounts->synchronize;
	if ($self->{state}->{not}) {
		# this is the actual stacking case: in pretend mode,
		# I have to put a second vfs on top
		if (@@{$self->{v}} == 2) {
			my $top = shift @@{$self->{v}};
			while (my ($k, $v) = each %$top) {
				$self->{v}[0]{$k} = $v;
			}
		}
		unshift(@@{$self->{v}}, {});
	} else {
		$self->{v} = [{}];
	}
}

sub drop_changes
{
	my $self = shift;

	OpenBSD::Mounts->drop_changes;
	# drop the top layer
	$self->{v}[0] = {};
}

sub add
{
	my ($self, $name, $size, $value) = @@_;
	$self->{v}[0]->{$name} = OpenBSD::Vstat::Object->new($value);
	return defined($size) ? $self->account_for($name, $size) : undef;
}

sub remove
{
	my ($self, $name, $size) = @@_;
	$self->{v}[0]->{$name} = OpenBSD::Vstat::Object->none;
	return defined($size) ? $self->account_later($name, -$size) : undef;
}

sub remove_first
{
	my ($self, $name, $size) = @@_;
	$self->{v}[0]->{$name} = OpenBSD::Vstat::Object->none;
	return defined($size) ? $self->account_for($name, -$size) : undef;
}

# since directories may become files during updates, we may have to remove
# them early, so we need to record them: store exactly as much info as needed
# for SharedItems.
sub remove_directory
{
	my ($self, $name, $o) = @@_;
	$self->{v}[0]->{$name} = OpenBSD::Vstat::Object::Directory->new($name,
	    $self->{state}->{current_set}, $o);
}


sub tally
{
	my $self = shift;

	OpenBSD::Mounts->tally($self->{state});
}

package OpenBSD::Mounts;

my $devinfo;
my $devinfo2;
my $giveup;

sub giveup
{
	if (!defined $giveup) {
		$giveup = OpenBSD::MountPoint::Fail->new;
	}
	return $giveup;
}

sub new
{
	my ($class, $dev, $opts) = @@_;

	if (!defined $devinfo->{$dev}) {
		$devinfo->{$dev} = OpenBSD::MountPoint->new($dev, $opts);
	}
	return $devinfo->{$dev};
}

sub run
{
	my $state = shift;
	my $code = pop;
	open(my $cmd, "-|", @@_) or
		$state->errsay("Can't run #1", join(' ', @@_))
		and return;
	while (<$cmd>) {
		&$code($_);
	}
	if (!close($cmd)) {
		if ($!) {
			$state->errsay("Error running #1: #2", $!, join(' ', @@_));
		} else {
			$state->errsay("Exit status #1 from #2", $?, join(' ', @@_));
		}
	}
}

sub ask_mount
{
	my ($class, $state) = @@_;

	delete $ENV{'BLOCKSIZE'};
	run($state, OpenBSD::Paths->mount, sub {
		my $l = shift;
		chomp $l;
		if ($l =~ m/^(.*?)\s+on\s+\/.*?\s+type\s+.*?(?:\s+\((.*?)\))?$/o) {
			my ($dev, $opts) = ($1, $2);
			$class->new($dev, $opts);
		} else {
			$state->errsay("Can't parse mount line: #1", $l);
		}
	});
}

sub ask_df
{
	my ($class, $fname, $state) = @@_;

	my $info = $class->giveup;
	my $blocksize = 512;

	$class->ask_mount($state) if !defined $devinfo;
	run($state, OpenBSD::Paths->df, "--", $fname, sub {
		my $l = shift;
		chomp $l;
		if ($l =~ m/^Filesystem\s+(\d+)\-blocks/o) {
			$blocksize = $1;
		} elsif ($l =~ m/^(.*?)\s+\d+\s+\d+\s+(\-?\d+)\s+\d+\%\s+\/.*?$/o) {
			my ($dev, $avail) = ($1, $2);
			$info = $devinfo->{$dev};
			if (!defined $info) {
				$info = $class->new($dev);
			}
			$info->{avail} = $avail;
			$info->{blocksize} = $blocksize;
		}
	});

	return $info;
}

sub find
{
	my ($class, $dev, $fname, $state) = @@_;
	if (!defined $dev) {
		return $class->giveup;
	}
	if (!defined $devinfo2->{$dev}) {
		$devinfo2->{$dev} = $class->ask_df($fname, $state);
	}
	return $devinfo2->{$dev};
}

sub synchronize
{
	for my $v (values %$devinfo2) {
		$v->synchronize;
	}
}

sub drop_changes
{
	for my $v (values %$devinfo2) {
		$v->drop_changes;
	}
}

sub tally
{
	my ($self, $state) = @@_;

	for my $v ((sort {$a->name cmp $b->name } values %$devinfo2), $self->giveup) {
		$v->tally($state);
	}
}

package OpenBSD::MountPoint;

sub parse_opts
{
	my ($self, $opts) = @@_;
	for my $o (split /\,\s*/o, $opts) {
		if ($o eq 'read-only') {
			$self->{ro} = 1;
		} elsif ($o eq 'nodev') {
			$self->{nodev} = 1;
		} elsif ($o eq 'nosuid') {
			$self->{nosuid} = 1;
		} elsif ($o eq 'noexec') {
			$self->{noexec} = 1;
		}
	}
}

sub ro
{
	return shift->{ro};
}

sub nodev
{
	return shift->{nodev};
}

sub nosuid
{
	return shift->{nosuid};
}

sub noexec
{
	return shift->{noexec};
}

sub new
{
	my ($class, $dev, $opts) = @@_;
	my $n = bless { commited_use => 0, used => 0, delayed => 0,
	    hw => 0, dev => $dev }, $class;
	if (defined $opts) {
		$n->parse_opts($opts);
	}
	return $n;
}


sub avail
{
	my ($self, $used) = @@_;
	return $self->{avail} - $self->{used}/$self->{blocksize};
}

sub name
{
	my $self = shift;
	return $self->{dev};
}

sub report_ro
{
	my ($s, $state, $fname) = @@_;

	if ($state->verbose >= 3 or ++($s->{problems}) < 4) {
		$state->errsay("Error: #1 is read-only (#2)",
		    $s->name, $fname);
	} elsif ($s->{problems} == 4) {
		$state->errsay("Error: ... more files on #1", $s->name);
	}
	$state->{problems}++;
}

sub report_overflow
{
	my ($s, $state, $fname) = @@_;

	if ($state->verbose >= 3 or ++($s->{problems}) < 4) {
		$state->errsay("Error: #1 is not large enough (#2)",
		    $s->name, $fname);
	} elsif ($s->{problems} == 4) {
		$state->errsay("Error: ... more files do not fit on #1",
		    $s->name);
	}
	$state->{problems}++;
	$state->{overflow} = 1;
}

sub report_noexec
{
	my ($s, $state, $fname) = @@_;
	$state->errsay("Error: #1 is noexec (#2)", $s->name, $fname);
	$state->{problems}++;
}

sub synchronize
{
	my $v = shift;

	if ($v->{used} > $v->{hw}) {
		$v->{hw} = $v->{used};
	}
	$v->{used} += $v->{delayed};
	$v->{delayed} = 0;
	$v->{commited_use} = $v->{used};
}

sub drop_changes
{
	my $v = shift;

	$v->{used} = $v->{commited_use};
	$v->{delayed} = 0;
}

sub tally
{
	my ($data, $state) = @@_;

	return  if $data->{used} == 0;
	$state->print("#1: #2 bytes", $data->name, $data->{used});
	my $avail = $data->avail;
	if ($avail < 0) {
		$state->print(" (missing #1 blocks)", int(-$avail+1));
	} elsif ($data->{hw} >0 && $data->{hw} > $data->{used}) {
		$state->print(" (highwater #1 bytes)", $data->{hw});
	}
	$state->print("\n");
}

package OpenBSD::MountPoint::Fail;
our @@ISA=qw(OpenBSD::MountPoint);

sub avail
{
	return 1;
}

sub new
{
	my $class = shift;
	my $n = $class->SUPER::new('???');
	$n->{avail} = 0;
	return $n;
}

1;
@


1.67
log
@Swap the program name and it's exit code so the output makes sense again.

ok espie@@
@
text
@d2 1
a2 1
# $OpenBSD: Vstat.pm,v 1.66 2013/04/16 09:33:20 espie Exp $
a261 1
	my $_;
d280 3
a282 3
		my $_ = shift;
		chomp;
		if (m/^(.*?)\s+on\s+\/.*?\s+type\s+.*?(?:\s+\((.*?)\))?$/o) {
d286 1
a286 1
			$state->errsay("Can't parse mount line: #1", $_);
d300 3
a302 3
		my $_ = shift;
		chomp;
		if (m/^Filesystem\s+(\d+)\-blocks/o) {
d304 1
a304 1
		} elsif (m/^(.*?)\s+\d+\s+\d+\s+(\-?\d+)\s+\d+\%\s+\/.*?$/o) {
@


1.66
log
@pass state correctly so we can do error messages.
@
text
@d2 1
a2 1
# $OpenBSD: Vstat.pm,v 1.65 2011/06/16 10:58:12 espie Exp $
d268 1
a268 1
			$state->errsay("Error running #1: #2", join(' ', @@_), $!);
d270 1
a270 1
			$state->errsay("Exit status #1 from #2", join(' ', @@_), $?);
@


1.65
log
@repair broken tally display
@
text
@d2 1
a2 1
# $OpenBSD: Vstat.pm,v 1.64 2010/12/24 09:04:14 espie Exp $
d277 1
a277 1
	my ($class, $state) = shift;
@


1.64
log
@handle failures from ports tree with more care.
this does avoid infinite loops in case of wrong plists.
necessary since print-plist-with-depends CAN fail...
@
text
@d2 1
a2 1
# $OpenBSD$
d476 1
a476 1
	$state->print($data->name, ": ", $data->{used}, " bytes");
@


1.63
log
@whitespace
@
text
@@


1.62
log
@fix the qt 4.5 -> 4.6 update issue.
since we usually deal with directories in a global way, replacing a
directory with something else didn't work.
the fix is to record removed directories in Vstat in a "lazy" way:
we only test these objects for existence if we add something else at
the same location. Since this happens rarely, we can afford to perform
the whole SharedItems dance twice...
@
text
@d2 1
a2 1
# $OpenBSD: Vstat.pm,v 1.61 2010/06/30 10:51:04 espie Exp $
d219 1
a219 1
	$self->{v}[0]->{$name} = OpenBSD::Vstat::Object::Directory->new($name, 
@


1.61
log
@allow say and errsay to work without parameters, as it's ways common.
create verbose_system up in state, because it makes sense without verbose.
@
text
@d2 1
a2 1
# $OpenBSD$
d62 1
d81 22
d212 11
@


1.60
log
@whitespace cleanup
@
text
@@


1.59
log
@ui changes: go thru a state object for most printouts
@
text
@d2 1
a2 1
# $OpenBSD: Vstat.pm,v 1.58 2010/05/10 09:17:55 espie Exp $
@


1.58
log
@whitespace fixes
@
text
@d2 1
a2 1
# $OpenBSD$
d226 1
a226 1
		$state->errsay("Can't run ",join(' ', @@_))
d234 1
a234 1
			$state->errsay("Error running ", join(' ', @@_),": $!");
d236 1
a236 1
			$state->errsay("Exit status $? from ", join(' ', @@_));
d253 1
a253 1
			$state->errsay("Can't parse mount line: $_");
d387 2
a388 2
		$state->errsay("Error: ", $s->name,
		    " is read-only ($fname)");
d390 1
a390 1
		$state->errsay("Error: ... more files on ", $s->name);
d400 2
a401 2
		$state->errsay("Error: ", $s->name,
		    " is not large enough ($fname)");
d403 1
a403 1
		$state->errsay("Error: ... more files do not fit on ",
d413 1
a413 1
	$state->errsay("Error: ", $s->name, " is noexec ($fname)");
d445 1
a445 1
		$state->print(" (missing ", int(-$avail+1), " blocks)");
d447 1
a447 1
		$state->print(" (highwater ", $data->{hw}, " bytes)");
d449 1
a449 1
	$state->say;
@


1.57
log
@clean-up validate_plists a bit, so that it starts with a clean state.
new feature: if a normal updateset order does not fit, let the user decide
to do a "dangerous update", by deleting older packages first (if they fit).
tweak really_add to do so: move delete old packages out of the way, and add
a new state variable (extracted_first) to distinguish between both replace
modes.
@
text
@d361 1
a361 1
	my $n = bless { commited_use => 0, used => 0, delayed => 0, 
d387 1
a387 1
		$state->errsay("Error: ", $s->name, 
d403 1
a403 1
		$state->errsay("Error: ... more files do not fit on ", 
d443 1
a443 1
	my $avail = $data->avail; 
@


1.56
log
@fix new vstat, and make it useful, for instance for -n.
@
text
@d183 7
@


1.55
log
@stat objects with more than value (store symlinks eventually)
@
text
@d35 1
a35 1
	my ($class, $value) = shift;
d40 1
a40 1
		$cache->{value} = bless \$value, $class;
d42 1
a42 1
	return $cache->{value};
d129 11
a172 1

@


1.54
log
@auto-create giveup, so it's defined if we call tally without doing anything.
@
text
@d27 53
d123 1
a123 1
			return $v->{$name};
d161 2
a162 5
	if (defined $value) {
		$self->{v}[0]->{$name} = $value;
	} else {
		$self->{v}[0]->{$name} = 1;
	}
d169 1
a169 1
	$self->{v}[0]->{$name} = 0;
@


1.53
log
@separate code into two classes, cleaner.
@
text
@d136 8
a177 1
	$giveup = OpenBSD::MountPoint::Fail->new;
d195 1
a195 1
	my $info = $giveup;
d222 1
a222 1
		return $giveup;
d248 1
a248 1
	for my $v ((sort {$a->name cmp $b->name } values %$devinfo2), $giveup) {
@


1.52
log
@much better (avoid calling df all the time, oops)
@
text
@d39 1
a39 1
	return OpenBSD::MountPoint->find($dev, $fname, $self->{state});
d80 1
a80 1
	OpenBSD::MountPoint->synchronize;
d100 1
a100 1
	OpenBSD::MountPoint->drop_changes;
d127 1
a127 1
	OpenBSD::MountPoint->tally($self->{state});
d130 1
a130 1
package OpenBSD::MountPoint;
a135 47
sub parse_opts
{
	my ($self, $opts) = @@_;
	for my $o (split /\,\s*/o, $opts) {
		if ($o eq 'read-only') {
			$self->{ro} = 1;
		} elsif ($o eq 'nodev') {
			$self->{nodev} = 1;
		} elsif ($o eq 'nosuid') {
			$self->{nosuid} = 1;
		} elsif ($o eq 'noexec') {
			$self->{noexec} = 1;
		}
	}
}

sub ro
{
	return shift->{ro};
}

sub nodev
{
	return shift->{nodev};
}

sub nosuid
{
	return shift->{nosuid};
}

sub noexec
{
	return shift->{noexec};
}

sub create
{
	my ($class, $dev, $opts) = @@_;
	my $n = bless { commited_use => 0, used => 0, delayed => 0, 
	    hw => 0, dev => $dev }, $class;
	if (defined $opts) {
		$n->parse_opts($opts);
	}
	return $n;
}

d141 1
a141 1
		$devinfo->{$dev} = $class->create($dev, $opts);
d168 1
a168 1
	my $state = shift;
d177 1
a177 1
			OpenBSD::MountPoint->new($dev, $opts);
d186 1
a186 1
	my ($fname, $state) = @@_;
d191 1
a191 1
	ask_mount($state) if !defined $devinfo;
d201 1
a201 1
				$info = OpenBSD::MountPoint->new($dev);
d218 1
a218 1
		$devinfo2->{$dev} = ask_df($fname, $state);
d223 73
d345 4
a348 7
	for my $v (values %$devinfo2) {
		if ($v->{used} > $v->{hw}) {
			$v->{hw} = $v->{used};
		}
		$v->{used} += $v->{delayed};
		$v->{delayed} = 0;
		$v->{commited_use} = $v->{used};
d350 3
d357 4
a360 4
	for my $v (values %$devinfo2) {
		$v->{used} = $v->{commited_use};
		$v->{delayed} = 0;
	}
d365 9
a373 11
	my ($self, $state) = @@_;
	for my $data (values %$devinfo2) {
		next if $data->{used} == 0;
		$state->print($data->name, ": ", $data->{used}, " bytes");
		my $avail = $data->avail; 
		if ($avail < 0) {
			$state->print(" (missing ", int(-$avail+1), " blocks)");
		} elsif ($data->{hw} > $data->{used}) {
			$state->print(" (highwater ", $data->{hw}, " bytes)");
		}
		$state->say;
d375 1
d389 1
a389 1
	my $n = $class->SUPER::create('???');
@


1.51
log
@stacked vfs entries. I should be able to recover from overflows and
collisions now.
@
text
@d39 1
a39 5
	my $mp = OpenBSD::MountPoint->find($dev, $fname, $self->{state});
	if (!defined $self->{p}{$mp}) {
		$self->{p}{$mp} = OpenBSD::MountPoint::Proxy->new($mp);
	}
	return $self->{p}{$mp};
d62 1
a62 1
	bless {v => [{}], p => {}, state => $state}, $class;
d80 1
a80 5
	for my $v (values %{$self->{p}}) {
		$v->{used} += $v->{delayed};
		$v->{delayed} = 0;
		$v->{real}->{used} = $v->{used};
	}
d100 1
a100 4
	for my $v (values %{$self->{p}}) {
		$v->{used} = $v->{real}->{used};
		$v->{delayed} = 0;
	}
d127 1
a127 10
	for my $data (values %{$self->{p}}) {
		if ($data->{used} != 0) {
			print $data->name, ": ", $data->{used}, " bytes";
			my $avail = $data->avail; 
			if ($avail < 0) {
				print " (missing ", int(-$avail+1), " blocks)";
			}
			print "\n";
		}
	}
d133 1
d175 2
a176 3
	my $n = bless 
	    { dev => $dev, used => 0 },
	    $class;
d238 1
a260 1
	ask_mount($state) if !defined $devinfo;
d264 2
a265 3
	my $info = $devinfo->{$dev};
	if (!defined $info->{avail}) {
		$info = ask_df($fname, $state);
d267 1
a267 1
	return $info;
d270 1
a270 1
sub compute_avail
d273 1
a273 47
	return $self->{avail} - $used/$self->{blocksize};
}

sub avail
{
	my $self = shift;

	return $self->compute_avail($self->{used});
}

package OpenBSD::MountPoint::Fail;
our @@ISA=qw(OpenBSD::MountPoint);

sub new
{
	my $class = shift;
	bless { avail => 0, used => 0, dev => '???' }, $class;
}

sub compute_avail
{
	return 1;
}

package OpenBSD::MountPoint::Proxy;

sub new
{
	my ($class, $mp) = @@_;
	bless {real => $mp, used => $mp->{used}, delayed => 0,
	    problems => 0}, $class;
}

sub ro
{
	return shift->{real}->ro;
}

sub noexec
{
	return shift->{real}->noexec;
}

sub avail
{
	my $self = shift;
	return $self->{real}->compute_avail($self->{used});
d279 1
a279 1
	return $self->{real}->{dev};
d315 52
@


1.50
log
@things are simpler: I don't need to stack used size stuff.
@
text
@d82 2
a83 1
	my ($self) = @@_;
d89 25
a113 2
	return if $self->{state}->{not};
	$self->{v} = [{}];
@


1.49
log
@next step: create proxy objects for devices that count the size used.
@
text
@d40 2
a41 2
	if (!defined $self->{p}[0]{$mp}) {
		$self->{p}[0]{$mp} = OpenBSD::MountPoint::Proxy->new(0, $mp);
d43 1
a43 1
	return $self->{p}[0]{$mp};
d66 1
a66 1
	bless {v => [{}], p => [{}], state => $state}, $class;
d83 1
a83 1
	for my $v (values %{$self->{p}[0]}) {
d86 1
d114 1
a114 1
	for my $data (values %{$self->{p}[0]}) {
d171 1
a171 1
	    { dev => $dev, problems => 0 },
a279 35
sub report_ro
{
	my ($s, $state, $fname) = @@_;

	if ($state->verbose >= 3 or ++($s->{problems}) < 4) {
		$state->errsay("Error: ", $s->{dev}, 
		    " is read-only ($fname)");
	} elsif ($s->{problems} == 4) {
		$state->errsay("Error: ... more files on ", $s->{dev});
	}
	$state->{problems}++;
}

sub report_overflow
{
	my ($s, $state, $fname) = @@_;

	if ($state->verbose >= 3 or ++($s->{problems}) < 4) {
		$state->errsay("Error: ", $s->{dev}, 
		    " is not large enough ($fname)");
	} elsif ($s->{problems} == 4) {
		$state->errsay("Error: ... more files do not fit on ", 
		    $s->{dev});
	}
	$state->{problems}++;
	$state->{overflow} = 1;
}

sub report_noexec
{
	my ($s, $state, $fname) = @@_;
	$state->errsay("Error: ", $s->{dev}, " is noexec ($fname)");
	$state->{problems}++;
}

d286 1
a286 1
	bless { avail => 0, dev => '???' }, $class;
d298 3
a300 2
	my ($class, $used, $mp) = @@_;
	bless {real => $mp, used => $used, delayed => 0}, $class;
d323 35
@


1.48
log
@replace vstat with modern code, almost ready for stacking vfs...
@
text
@d39 5
a43 1
	return OpenBSD::MountPoint->find($dev, $fname, $self->{state});
d66 1
a66 1
	bless {v => [{}], state => $state}, $class;
d83 4
a86 1
	OpenBSD::MountPoint->synchronize;
d111 12
a122 1
	OpenBSD::MountPoint->tally;
d170 1
a170 1
	    { dev => $dev, used => 0, delayed => 0, problems => 0 },
d266 1
a266 1
sub synchronize
d268 2
a269 18
	while (my ($k, $v) = each %$devinfo) {
		$v->{used} += $v->{delayed};
		$v->{delayed} = 0;
	}
}

sub tally
{
	while (my ($device, $data) = each %$devinfo) {
		if ($data->{used} != 0) {
			print $device, ": ", $data->{used}, " bytes";
			my $avail = $data->avail; 
			if ($avail < 0) {
				print " (missing ", int(-$avail+1), " blocks)";
			}
			print "\n";
		}
	}
d276 1
a276 1
	return $self->{avail} - $self->{used}/$self->{blocksize};
d320 24
a343 1
	bless { avail => 0, used => 0, dev => '???' }, $class;
d348 8
a355 1
	return 1;
@


1.47
log
@fully encapsulate dev objects from vstat so I can change the internals
completely.
@
text
@d31 79
a109 3
my $devinfo = {};
my $devinfo2 = {};
our $virtual = {};
d112 1
a112 1
sub create_device($)
d114 42
a155 6
	my $dev = shift;
	my $n = $devinfo->{$dev};
	if (!defined $n) {
		$n = { dev => $dev, used => 0, delayed => 0, problems => 0 };
		bless $n, "OpenBSD::Vstat::MountPoint";
		$devinfo->{$dev} = $n;
d160 11
a170 1
sub init_devices()
d172 23
d196 2
a197 2
	open(my $cmd1, "-|", OpenBSD::Paths->mount) or print STDERR "Can't run mount\n";
	while (<$cmd1>) {
d201 1
a201 14
			my $i = create_device($dev);
			next unless defined $i;
			next unless defined $opts;
			for my $o (split /\,\s*/o, $opts) {
				if ($o eq 'read-only') {
					$i->{ro} = 1;
				} elsif ($o eq 'nodev') {
					$i->{nodev} = 1;
				} elsif ($o eq 'nosuid') {
					$i->{nosuid} = 1;
				} elsif ($o eq 'noexec') {
					$i->{noexec} = 1;
				}
			}
d203 1
a203 1
			print STDERR "Can't parse mount line: $_\n";
d205 1
a205 4
	}
	close($cmd1) or print STDERR "Error running mount: $!\n";
	$giveup = { used => 0, dev => '???' };
	bless $giveup, "OpenBSD::Vstat::Failsafe";
d208 1
a208 1
sub ask_df($)
d210 2
a211 1
	my $fname = shift;
d213 1
d215 2
a216 4
	open(my $cmd2, "-|", OpenBSD::Paths->df, $fname)
	    or print STDERR "Can't run df\n";
	my $blocksize = 512;
	while (<$cmd2>) {
d224 1
a224 1
				$info = create_device($dev);
d229 1
a229 1
	}
a230 1
	close($cmd2) or print STDERR "Error running df: $!\n";
d234 1
a234 5
init_devices();

sub filestat($);

sub filestat($)
d236 2
a237 6
	my $fname = shift;
	my $dev = (stat $fname)[0];

	if (!defined $dev && $fname ne '/') {
		return filestat(dirname($fname));
	}
a239 6
	} else {
		if (!defined $devinfo2->{$dev}) {
			return $devinfo2->{$dev} = ask_df($fname);
		} else {
			return $devinfo2->{$dev};
		}
d241 3
a243 9
}

sub vexists($)
{
	my $name = shift;
	if (defined $virtual->{$name}) {
		return $virtual->{$name};
	} else {
		return -e $name;
d245 1
a245 16
}

sub account_for($$)
{
	my ($name, $size) = @@_;
	my $e = filestat($name);
	$e->{used} += $size;
	return $e;
}

sub account_later($$)
{
	my ($name, $size) = @@_;
	my $e = filestat($name);
	$e->{delayed} += $size;
	return $e;
a249 1
	my $not = shift;
a253 2
	# Grab back all memory if we can !
	$virtual = {} unless $not;
d256 1
a256 19
sub add($$;$)
{
	my ($name, $size, $value) = @@_;
	if (defined $value) {
		$virtual->{$name} = $value;
	} else {
		$virtual->{$name} = 1;
	}
	return defined($size) ? account_for($name, $size) : undef;
}

sub remove($$)
{
	my ($name, $size) = @@_;
	$virtual->{$name} = 0;
	return defined($size) ? account_later($name, -$size) : undef;
}

sub tally()
a269 1
package OpenBSD::Vstat::MountPoint;
a276 24
sub ro
{
	my $self = shift;
	return $self->{ro};
}

sub noexec
{
	my $self = shift;
	return $self->{noexec};
}

sub nosuid
{
	my $self = shift;
	return $self->{nosuid};
}

sub nodev
{
	my $self = shift;
	return $self->{nodev};
}

d312 8
a319 2
package OpenBSD::Vstat::Failsafe;
our @@ISA=(qw(OpenBSD::Vstat::MountPoint));
@


1.46
log
@if we're not in a "pretend" mode, synchronization operations on vstat occur
after the files have been committed to the file system, so we can forget about
them...

I don't know where I lost that change, restores pkg_add memory usage to very
small values...
@
text
@d206 24
@


1.45
log
@change verbosity handling: be silent by default, turn on the first level if -v.
Add more levels, specifically, lots of info regarding individual files only
visible if -vvvvv.
Make -n display the same stuff as normal (need -n -v to display more stuff).
Introduce -s, "size-only", turns on -n and does skip any extraction.
Sprinkle handlers for SIG_INFO, not really nice yet.

Note that -n is non functional for complex updates, because of caching
issues I have to fix.
@
text
@d33 1
a33 1
my $virtual = {};
d157 1
d162 2
@


1.44
log
@also get most STDERR messages through the same way
@
text
@d207 1
a207 1
	if ($state->{very_verbose} or ++($s->{problems}) < 4) {
d220 1
a220 1
	if ($state->{very_verbose} or ++($s->{problems}) < 4) {
@


1.43
log
@move the UpdateSet stuff into its separate file, leaving Vstat much cleaner.
@
text
@d2 1
a2 1
# $OpenBSD: Vstat.pm,v 1.42 2007/06/26 14:40:25 espie Exp $
d208 2
a209 2
		print STDERR "Error: ", $s->{dev}, 
		    " is read-only ($fname)\n";
d211 1
a211 1
		print STDERR "Error: ... more files on ", $s->{dev}, "\n";
d221 2
a222 2
		print STDERR "Error: ", $s->{dev}, 
		    " is not large enough ($fname)\n";
d224 2
a225 2
		print STDERR "Error: ... more files do not fit on ", 
		    $s->{dev}, "\n";
d234 1
a234 1
	print STDERR "Error: ", $s->{dev}, " is noexec ($fname)\n";
@


1.42
log
@the big gap one: create UpdateSet for all packages being installed, and
consider only UpdateSet internally. This involves moving stuff around a
bit to keep pkg_add -n working, adding creators from_location for UpdateSet,
and tweaking dependencies heavily.

More changes later, like sanitizing PackageLocation state engine, or
creating UpdateSet earlier for actual updates.
@
text
@d2 1
a2 1
# $OpenBSD: Vstat.pm,v 1.41 2007/06/16 09:29:37 espie Exp $
a243 313
}

# Here we stuff things common to pkg_add and pkg_delete which do not warrant
# their own file yet.
package OpenBSD::SharedItemsRecorder;
sub new
{
	my $class = shift;
	return bless {}, $class;
}

sub is_empty
{
	my $self = shift;
	return !(defined $self->{dirs} or defined $self->{users} or
		defined $self->{groups});
}

sub cleanup
{
	my ($self, $state) = @@_;
	return if $self->is_empty or $state->{not};

	require OpenBSD::SharedItems;
	OpenBSD::SharedItems::cleanup($self, $state);
}

package OpenBSD::pkg_foo::State;
use OpenBSD::Error;
our @@ISA=(qw(OpenBSD::Error));

sub progress
{
	my $self = shift;
	return $self->{progressmeter};
}

sub setup_progressmeter
{
	my ($self, $opt_x) = @@_;
	if (!$opt_x && !$self->{beverbose}) {
		require OpenBSD::ProgressMeter;
		$self->{progressmeter} = OpenBSD::ProgressMeter->new;
	} else {
		$self->{progressmeter} = bless {}, "OpenBSD::StubProgress";
	}
}

sub check_root
{
	my $state = shift;
	if ($< && !$state->{forced}->{nonroot}) {
		if ($state->{not}) {
			Warn "$0 should be run as root\n";
		} else {
			Fatal "$0 must be run as root";
		}
	}
}

package OpenBSD::StubProgress;
sub clear {}

sub show {}

sub message {}

sub next {}

sub set_header {}

# fairly non-descriptive name. Used to store various package information
# during installs and updates.
package OpenBSD::Handle;

use constant {
	BAD_PACKAGE => 1,
	CANT_INSTALL => 2,
	ALREADY_INSTALLED => 3,
	NOT_FOUND => 4
};

sub new
{
	my $class = shift;
	return bless {}, $class;
}

sub set_error
{
	my ($self, $error) = @@_;
	$self->{error} = $error;
}

sub has_error
{
	my ($self, $error) = @@_;
	if (!defined $self->{error}) {
		return undef;
	}
	if (defined $error) {
		return $self->{error} eq $error;
	}
	return $self->{error};
}

sub create_old
{

	my ($class, $pkgname, $state) = @@_;
	my $self= $class->new;
	$self->{pkgname} = $pkgname;

	require OpenBSD::PackageRepository::Installed;

	my $location = OpenBSD::PackageRepository::Installed->new->find($pkgname, $state->{arch});
	if (!defined $location) {
		$self->set_error(NOT_FOUND);
    	} else {
		$self->{location} = $location;
		my $plist = $location->plist;
		if (!defined $plist) {
			$self->set_error(BAD_PACKAGE);
		} else {
			$self->{plist} = $plist;
		}
	}
	return $self;
}

sub create_new
{
	my ($class, $pkg) = @@_;
	my $handle = $class->new;
	$handle->{pkgname} = $pkg;
	$handle->{tweaked} = 0;
	return $handle;
}

sub from_location
{
	my ($class, $location) = @@_;
	my $handle = $class->new;
	$handle->{pkgname} = $location->{name};
	$handle->{location} = $location;
	$handle->{tweaked} = 0;
	return $handle;
}

package OpenBSD::UpdateSet;
sub new
{
	my $class = shift;
	return bless {newer => [], older => []}, $class;
}

sub add_newer
{
	my ($self, @@handles) = @@_;
	push(@@{$self->{newer}}, @@handles);
}

sub add_older
{
	my ($self, @@handles) = @@_;
	push(@@{$self->{older}}, @@handles);
}

sub newer
{
	my $self =shift;
	return @@{$self->{newer}};
}

sub older
{
	my $self = shift;
	return @@{$self->{older}};
}

sub older_to_do
{
	my $self = shift;
	# XXX in `combined' updates, some dependencies may remove extra 
	# packages, so we do a double-take on the list of packages we 
	# are actually replacing... for now, until we merge update sets.
	require OpenBSD::PackageInfo;
	my @@l = ();
	for my $h ($self->older) {
		if (OpenBSD::PackageInfo::is_installed($h->{pkgname})) {
			push(@@l, $h);
		}
	}
	return @@l;
}

sub print
{
	my $self = shift;
	my @@l = ();
	if (defined $self->{newer}) {
		push(@@l, "installing", map {$_->{pkgname}} $self->newer);
	}
	if (defined $self->{older} && @@{$self->{older}} > 0) {
		push(@@l, "deinstalling", map {$_->{pkgname}} $self->older);
	}
	return join(' ', @@l);
}

sub validate_plists
{
	my ($self, $state) = @@_;
	$state->{problems} = 0;

	for my $o ($self->older_to_do) {
		require OpenBSD::Delete;
		OpenBSD::Delete::validate_plist($o->{plist}, $state);
	}
	$state->{colliding} = [];
	for my $n ($self->newer) {
		require OpenBSD::Add;
		OpenBSD::Add::validate_plist($n->{plist}, $state);
	}
	if (@@{$state->{colliding}} > 0) {
		require OpenBSD::CollisionReport;

		OpenBSD::CollisionReport::collision_report($state->{colliding}, $state);
	}
	if (defined $state->{overflow}) {
		OpenBSD::Vstat::tally();
	}
	if ($state->{problems}) {
		require OpenBSD::Error;
		OpenBSD::Error::Fatal "fatal issues in ", $self->print;
	}
	OpenBSD::Vstat::synchronize();
}

sub compute_size
{
	my ($self, $state) = @@_;
	for my $h ($self->older_to_do, $self->newer) {
		$h->{totsize} = $h->{plist}->compute_size;
	}
}

# temporary shortcut
sub handle
{
	my $self = shift;
	if (defined $self->{newer}) {
		return $self->{newer}[0];
	} else {
		return undef;
	}
}

# temporary creator
sub create_new
{
	my ($class, $pkgname) = @@_;
	my $set = $class->new;
	$set->add_newer(OpenBSD::Handle->create_new($pkgname));
	return $set;
}

sub from_location
{
	my ($class, $location) = @@_;
	my $set = $class->new;
	$set->add_newer(OpenBSD::Handle->from_location($location));
	return $set;
}

package OpenBSD::PackingList;
sub compute_size
{
	my $plist = shift;
	my $totsize = 0;
	$plist->visit('compute_size', \$totsize);
	$totsize = 1 if $totsize == 0;
	$plist->{totsize} = $totsize;
}

package OpenBSD::PackingElement;
sub mark_progress
{
}

sub compute_size
{
}

package OpenBSD::PackingElement::FileBase;
sub mark_progress
{
	my ($self, $progress, $donesize, $totsize) = @@_;
	return unless defined $self->{size};
	$$donesize += $self->{size};
	$progress->show($$donesize, $totsize);
}

sub compute_size
{
	my ($self, $totsize) = @@_;

	$$totsize += $self->{size} if defined $self->{size};
}

package OpenBSD::PackingElement::Sample;
sub compute_size
{
	&OpenBSD::PackingElement::FileBase::compute_size;
@


1.41
log
@use OpenBSD::Paths contents
@
text
@d2 1
a2 1
# $OpenBSD: Vstat.pm,v 1.40 2007/06/11 09:12:27 espie Exp $
d383 10
d507 8
@


1.40
log
@keep on extracting stuff
@
text
@d2 1
a2 1
# $OpenBSD: Vstat.pm,v 1.39 2007/06/10 16:05:49 espie Exp $
d29 1
d51 1
a51 1
	open(my $cmd1, "/sbin/mount|") or print STDERR "Can't run mount\n";
d84 1
a84 1
	open(my $cmd2, "-|", "/bin/df", $fname)
@


1.39
log
@extract constructor to create old handles.
@
text
@d2 1
a2 1
# $OpenBSD: Vstat.pm,v 1.38 2007/06/07 12:57:33 espie Exp $
d372 10
d488 9
@


1.38
log
@make compute_size explicit. That way, we can do it once, at the right
moment.
@
text
@d2 1
a2 1
# $OpenBSD: Vstat.pm,v 1.37 2007/06/06 15:36:32 espie Exp $
d349 23
@


1.37
log
@do it only for older sets.
@
text
@d2 1
a2 1
# $OpenBSD: Vstat.pm,v 1.36 2007/06/06 15:35:20 espie Exp $
d436 5
@


1.36
log
@finish moving the size computations out of validate_plist.
@
text
@d2 1
a2 1
# $OpenBSD: Vstat.pm,v 1.35 2007/06/06 15:31:06 espie Exp $
d436 1
a436 1
	for my $h ($self->older, $self->newer) {
@


1.35
log
@separate the size computation from other operations in `prepare_for_addition'
`prepare_for_deletion' -> move that to Vstat, as it is common code.
Do the splitting of libraries through a deep copy and shallow copy, so that
we keep any State information related to libraries (like special group/owners).
@
text
@d2 1
a2 1
# $OpenBSD: Vstat.pm,v 1.34 2007/06/05 23:19:00 espie Exp $
d416 1
a416 2
		$o->{totsize} =
		    OpenBSD::Delete::validate_plist($o->{plist}, $state);
d421 1
a421 2
		$n->{totsize} =
		    OpenBSD::Add::validate_plist($n->{plist}, $state);
d436 3
@


1.34
log
@allow accessing all older values (make a semantic distinction), so that
adjust_dependencies gets access to all. This fixes some bogus replacements.
@
text
@d2 1
a2 1
# $OpenBSD: Vstat.pm,v 1.33 2007/06/04 14:57:33 espie Exp $
d414 1
a414 1
	for my $o ($self->older) {
d451 10
d466 4
d477 13
@


1.33
log
@I am on drugs, I don't know where I found split can take strings as
arguments. Repair...
@
text
@d2 1
a2 1
# $OpenBSD: Vstat.pm,v 1.32 2007/06/04 14:40:39 espie Exp $
d353 1
a353 1
	return bless {}, $class;
d377 6
d388 1
a388 1
	for my $h (@@{$self->{older}}) {
@


1.32
log
@some minor systematic changes.
- mark all regexps I can with /o if they can be compiled once.
- turn $o->method() into $o->method
- remove unneeded prototypes
- reduce split /re/ into split "string" where possible.
@
text
@d2 1
a2 1
# $OpenBSD: Vstat.pm,v 1.31 2007/06/01 14:58:29 espie Exp $
d58 1
a58 1
			for my $o (split /,\s*/, $opts) {
@


1.31
log
@refactor ProgressMeter code to create objects, put these into state.
Create a common state class for delete and add, put the progressmeter
creation in there.

neat effect: we don't have a progressmeter, we use a stub class instead
and *never* pull the code in at all.
@
text
@d2 1
a2 1
# $OpenBSD: Vstat.pm,v 1.30 2007/05/30 14:04:51 espie Exp $
d53 1
a53 1
		if (m/^(.*?)\s+on\s+\/.*?\s+type\s+.*?(?:\s+\((.*?)\))?$/) {
d88 1
a88 1
		if (m/^Filesystem\s+(\d+)\-blocks/) {
d90 1
a90 1
		} elsif (m/^(.*?)\s+\d+\s+\d+\s+(\-?\d+)\s+\d+\%\s+\/.*?$/) {
d185 1
a185 1
			my $avail = $data->avail(); 
@


1.30
log
@simplify really_add to use real visitors for extraction and installation.
Just do one single try {} catchall {} per-method, as this is enough.

New methods: extract_and_progress, install_and_progress, that catch
interrupts (die) deal with fake, and handle the progress meter.
One single method: mark_progress, can be used for extraction, installation
and deletion.
@
text
@d2 1
a2 1
# $OpenBSD: Vstat.pm,v 1.29 2007/05/29 10:40:20 espie Exp $
d270 44
d453 1
a453 1
	my ($self, $donesize, $totsize) = @@_;
a454 1
	require OpenBSD::ProgressMeter;
d456 1
a456 1
	OpenBSD::ProgressMeter::show($$donesize, $totsize);
@


1.29
log
@don't use 0 as an error number.
@
text
@d2 1
a2 1
# $OpenBSD: Vstat.pm,v 1.28 2007/05/28 13:00:05 espie Exp $
d399 15
@


1.28
log
@delay error reporting a bit more: try installing and deinstalling everything
and report more issues.
@
text
@d2 1
a2 1
# $OpenBSD: Vstat.pm,v 1.27 2007/05/28 12:16:55 espie Exp $
a274 1
	NOT_FOUND => 0,
d277 2
a278 1
	ALREADY_INSTALLED => 3
@


1.27
log
@lift up more of the dev checking code into Vstat.
un-special case SpecialFiles on deletion. Now that CONTENTS is part of the
plist, it's checked as well on addition.
@
text
@d2 1
a2 1
# $OpenBSD: Vstat.pm,v 1.26 2007/05/27 22:18:14 espie Exp $
d346 13
d362 2
d366 2
a367 1
		OpenBSD::Delete::validate_plist($o->{plist}, $state);
d369 1
d372 14
a385 1
		OpenBSD::Add::validate_plist($n->{plist}, $state);
@


1.26
log
@move computation of header to a separate function.
slightly more precise comment
@
text
@d2 1
a2 1
# $OpenBSD: Vstat.pm,v 1.25 2007/05/27 22:04:17 espie Exp $
d74 1
a74 1
	$giveup = { used => 0 };
d197 1
a197 1
	my $self = $_[0];
d202 35
d238 2
@


1.25
log
@move packing-list validation to the UpdateSet level.
@
text
@d2 1
a2 1
# $OpenBSD: Vstat.pm,v 1.24 2007/05/27 11:21:55 espie Exp $
d296 3
@


1.24
log
@Simplify the mess that deals with alaready installed packages.
We can now have one central point that deals with it.
@
text
@d2 1
a2 1
# $OpenBSD: Vstat.pm,v 1.23 2007/05/27 10:38:12 espie Exp $
d285 33
@


1.23
log
@depend more stuff off handle.
Introduce UpdateSet, finally, with a main handle.
@
text
@d2 1
a2 1
# $OpenBSD: Vstat.pm,v 1.22 2007/05/26 12:22:38 espie Exp $
d240 2
a241 1
	CANT_INSTALL => 2
@


1.22
log
@base tests on $handle->has_error instead of $errors.
@
text
@d2 1
a2 1
# $OpenBSD: Vstat.pm,v 1.21 2007/05/25 13:18:57 espie Exp $
d284 11
@


1.21
log
@start cleaning up the mess that is error-handling when installing packages.
Mid-Term, we want to manipulate true `handles' that encapsulate package
locations.

For now, we create this handle externally, and just use it to record
errors, in duplicate...

Once handles are ready, they should be agregated into UpdateSets, to make
replacement of packages more explicit and flexible.
@
text
@d2 1
a2 1
# $OpenBSD: Vstat.pm,v 1.20 2007/05/22 10:11:59 espie Exp $
d259 1
a259 1
		return 0;
d264 1
a264 1
	return 1;
@


1.20
log
@introduce a SharedItemsRecorder (put it into Vstat, since that's a file
common to Add and Delete, for now).

Use it to have common code that records items to remove / items remaining.

Stash it into pkg_add/pkg_delete state, and abstract the cleaning up
operation into the SharedItemsRecorder (so that pkg_add and pkg_delete no
longer have to know about the internals of SharedItems at all).
@
text
@d2 1
a2 1
# $OpenBSD: Vstat.pm,v 1.19 2007/04/15 10:17:29 espie Exp $
d231 53
@


1.19
log
@update copyright years, standardize licence.
reword the introduction to the stuff originally from FreeBSD to clarify
slightly.
@
text
@d2 1
a2 1
# $OpenBSD: Vstat.pm,v 1.18 2007/03/07 11:24:07 espie Exp $
d206 25
@


1.18
log
@fix size checks for good. Since we want deletion to happen `right now'
but size accounting to happen later, just mark the size to delete `for
later', do not take them into account for avail(), and synchronize() at
the right time, e.g., after addition when updating, and right away for
straight deletion.

okay deraadt@@
@
text
@d2 1
a2 1
# $OpenBSD: Vstat.pm,v 1.17 2007/03/07 00:09:46 espie Exp $
d4 1
a4 1
# Copyright (c) 2003-2004 Marc Espie <espie@@openbsd.org>
@


1.17
log
@revert size check tweak, the fix does break other stuff. this is harder
than I thought...
@
text
@d2 1
a2 1
# $OpenBSD: Vstat.pm,v 1.16 2007/03/06 23:35:01 espie Exp $
d40 1
a40 1
		$n = { dev => $dev, used => 0, problems => 0 };
d146 16
d177 1
a177 1
	return defined($size) ? account_for($name, -$size) : undef;
@


1.16
log
@get vfs size snapshotted and restored so that pkg_add -u has a harder
time overflowing the disk.

let stem work at the end of urls.

test sturm@@ and bernd@@,

okay deraadt@@
@
text
@d2 1
a2 1
# $OpenBSD: Vstat.pm,v 1.15 2007/02/24 18:45:11 espie Exp $
a44 18
}

sub remember_used
{
	my $h = {};
	while (my ($k, $v) = each %$devinfo) {
		$h->{$k} = $v->{used};
		$v->{used} = 0;
	}
	return $h;
}

sub restore_used
{
	my $h = shift;
	while (my ($k, $v) = each %$h) {
		$devinfo->{$k}->{used} += $v;
	}
@


1.15
log
@UI improvement: in case the disk overflows, let tally give information
about the extra size needed. In validate, mark the overflow and call tally
later.

.e.g.,
Error: /dev/wd0f is not large enough (/usr/local/lib/libkparts.so.4.0.0)
Error: /dev/wd0f is not large enough (/usr/local/lib/libkrosscore.so.4.0.0)
Error: /dev/wd0f is not large enough (/usr/local/lib/libktexteditor.so.4.0.0)
Error: ... more files do not fit on /dev/wd0f
/dev/wd0h: 97 bytes
/dev/wd0f: 337090852 bytes (missing 78473 blocks)
@
text
@d2 1
a2 1
# $OpenBSD: Vstat.pm,v 1.14 2006/02/07 10:56:55 espie Exp $
d45 18
@


1.14
log
@look at noexec as well
@
text
@d2 1
a2 1
# $OpenBSD: Vstat.pm,v 1.13 2005/11/29 09:31:07 bernd Exp $
d168 6
a173 1
			print $device, ": ", $data->{used}, " bytes\n";
@


1.13
log
@- Zap duplicate semicolon. From Alexander Hall via PR #4913. Thanks!
- Some indentation fixes while I'm here.

okay espie@@
@
text
@d2 1
a2 1
# $OpenBSD: Vstat.pm,v 1.12 2005/08/22 11:25:59 espie Exp $
d65 2
@


1.12
log
@maintain a counter of problems encountered per-filesystem.
Do not report more than 3 problems per filesystem unless -v -v.
@
text
@d2 1
a2 1
# $OpenBSD: Vstat.pm,v 1.11 2005/08/22 11:11:39 espie Exp $
d49 20
a68 17
    delete $ENV{'BLOCKSIZE'};
    open(my $cmd1, "/sbin/mount|") or print STDERR "Can't run mount\n";
    while (<$cmd1>) {
	    chomp;
	    if (m/^(.*?)\s+on\s+\/.*?\s+type\s+.*?(?:\s+\((.*?)\))?$/) {
		my ($dev, $opts) = ($1, $2);
		my $i = create_device($dev);
		next unless defined $i;
		next unless defined $opts;
		for my $o (split /,\s*/, $opts) {
		    if ($o eq 'read-only') {
			$i->{ro} = 1;
		    } elsif ($o eq 'nodev') {
			$i->{nodev} = 1;
		    } elsif ($o eq 'nosuid') {
			$i->{nosuid} = 1;
		    }
d70 4
a73 7
	    } else {
		print STDERR "Can't parse mount line: $_\n";
	    }
    }
    close($cmd1) or print STDERR "Error running mount: $!\n";
    $giveup = { used => 0 };
    bless $giveup, "OpenBSD::Vstat::Failsafe";
d79 1
a79 1
	my $info = $giveup;;
d81 2
a82 1
	open(my $cmd2, "-|", "/bin/df", $fname) or print STDERR "Can't run df\n";
@


1.11
log
@parse mount entry correctly even if space left is negative
@
text
@d2 1
a2 1
# $OpenBSD: Vstat.pm,v 1.10 2004/12/29 11:28:59 espie Exp $
d40 1
a40 1
		$n = { dev => $dev, used => 0 };
@


1.10
log
@remove vreaddir support, since library lookup no longer needs it.
important memory gain, since virtual and virtual_dir account for the
lion's share of pkg_add's memory consumption.
@
text
@d2 1
a2 1
# $OpenBSD: Vstat.pm,v 1.9 2004/12/17 11:26:22 espie Exp $
d87 1
a87 1
		} elsif (m/^(.*?)\s+\d+\s+\d+\s+(\d+)\s+\d+\%\s+\/.*?$/) {
@


1.9
log
@better collision reports.
- in validate_plist, don't re-add a file that exists.
- allows the virtual file system to put marks on existing files
- use a \$pkgname the first time a file is added (space constraints: don't
duplicate the pkgname).
- in CollisionReport, first check the vfs, so that we don't look
at installed packages when the collision only concerns newly added pkgs.

Makes pkg_add -n report collision reports correctly.
@
text
@d2 1
a2 1
# $OpenBSD: Vstat.pm,v 1.8 2004/11/11 15:35:10 espie Exp $
a28 1
use Symbol;
a32 1
my $virtual_dir = {};
d128 2
a129 2
	if (defined $virtual->{"$name"}) {
		return $virtual->{"$name"};
a134 21
sub vreaddir($)
{
	my $dirname = shift;
	my %l;
	my $d = gensym;
	opendir($d, $dirname);
	%l = map { $_ => 1 } readdir($d);
	closedir($d);
	if (defined $virtual_dir->{"$dirname"}) {
		for my $e (@@{$virtual_dir->{"$dirname"}}) {
			my $n = basename($e);
			if (vexists $e) {
				$l{"$n"} = 1;
			} else {
				undef $l{"$n"};
			}
		}
	}
	return keys(%l);
}

a150 3
	my $d = dirname($name);
	$virtual_dir->{$d} = [] unless defined $virtual_dir->{$d};
	push(@@{$virtual_dir->{$d}}, $name);
a157 3
	my $d = dirname($name);
	$virtual_dir->{$d} = [] unless defined $virtual_dir->{$d};
	push(@@{$virtual_dir->{$d}}, $name);
@


1.8
log
@new accounting method that works with chroot installations.
@
text
@d2 1
a2 1
# $OpenBSD: Vstat.pm,v 1.7 2004/08/06 07:51:17 espie Exp $
d166 1
a166 1
sub add($$)
d168 6
a173 2
	my ($name, $size) = @@_;
	$virtual->{$name} = 1;
@


1.7
log
@unified headers, switch to smaller copyright notice.
@
text
@d2 1
a2 1
# $OpenBSD: Vstat.pm,v 1.6 2004/07/07 22:00:06 espie Exp $
d31 2
a32 1
my $dirinfo = {};
d35 1
a35 2
my $mnts = [];
my $blocksize = 512;
d37 1
a37 1
sub create_mntpoint($)
d39 2
a40 5
	my $mntpoint = shift;
	my $dev = (stat $mntpoint)[0];
	# check that stat worked
	return undef unless defined $dev;
	my $n = $dirinfo->{"$dev"};
d42 1
a42 1
		$n = { mnt => $mntpoint, dev => $dev, used => 0 };
d44 1
a44 3
		$dirinfo->{"$dev"} = $n;
		$dirinfo->{"$mntpoint"} = $n;
		push(@@$mnts, $n);
d49 1
a49 1
sub init_dirinfo()
a51 14
    open(my $cmd2, "/bin/df|") or print STDERR "Can't run df\n";
    while (<$cmd2>) {
	    chomp;
	    if (m/^Filesystem\s+(\d+)\-blocks/) {
		    $blocksize = $1;
	    } elsif (m/^.*?\s+\d+\s+\d+\s+(\d+)\s+\d+\%\s+(\/.*?)$/) {
	    	my ($mntpoint, $avail) = ($2, $1);
		my $i = create_mntpoint($mntpoint);
		next unless defined $i;
		$i->{avail} = $avail;
	    }
    }

    close($cmd2) or print STDERR "Error running df: $!\n";
d55 3
a57 3
	    if (m/^.*?\s+on\s+(\/.*?)\s+type\s+.*?(?:\s+\((.*?)\))?$/) {
		my ($mntpoint, $opts) = ($1, $2);
		my $i = create_mntpoint($mntpoint);
d74 2
d78 1
a78 5
init_dirinfo();

sub _dirstat($);

sub _dirstat($)
d80 2
a81 2
	my $dname = shift;
	my $dev = (stat $dname)[0];
d83 14
a96 11
	if (!defined $dev) {
		if (!defined $dirinfo->{"$dname"}) {
			return $dirinfo->{"$dname"} = _dirstat(dirname($dname));
		} else {
			return $dirinfo->{"$dname"};
		}
	} else {
		if (!defined $dirinfo->{"$dev"}) {
			return $dirinfo->{"$dev"} = _dirstat(dirname($dname));
		} else {
			return $dirinfo->{"$dev"};
d99 3
d104 4
d113 3
d117 1
a117 5
		if (!defined $dirinfo->{"$fname"}) {
			return _dirstat(dirname($fname));
		} else {
			return $dirinfo->{"$fname"};
		}
d119 2
a120 2
		if (!defined $dirinfo->{"$dev"}) {
			return _dirstat(dirname($fname));
d122 1
a122 1
			return $dirinfo->{"$dev"};
d188 3
a190 3
	for my $mntpoint (@@$mnts) {
		if ($mntpoint->{used} != 0) {
			print $mntpoint->{mnt}, ": ", $mntpoint->{used}, " bytes\n";
d200 7
a206 1
	return $self->{avail} - $self->{used}/$blocksize;
@


1.6
log
@guard against stat not working, which happened to me...
okay naddy@@, sturm@@
@
text
@d1 2
a2 1
# $OpenBSD: Vstat.pm,v 1.5 2004/04/28 06:47:12 espie Exp $
d4 13
a16 22
# Copyright (c) 2003 Marc Espie.
# 
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
# 
# THIS SOFTWARE IS PROVIDED BY THE OPENBSD PROJECT AND CONTRIBUTORS
# ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
# A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OPENBSD
# PROJECT OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
@


1.5
log
@Blech, SFS yields weird mount/df shit.
Non absolute mount points ? give me a break.

Fix for ugly nonsense. Problem reported by David Mazieres.
@
text
@d1 1
a1 1
# $OpenBSD: Vstat.pm,v 1.4 2004/03/10 08:21:40 espie Exp $
d49 2
d73 1
d85 1
@


1.4
log
@Help it cope with symlinks. Mostly from rd@@thrush.com.
okay pvalchev@@
@
text
@d1 1
a1 1
# $OpenBSD: Vstat.pm,v 1.3 2003/12/26 16:34:05 espie Exp $
d68 1
a68 1
	    } elsif (m/^.*?\s+\d+\s+\d+\s+(\d+)\s+\d+\%\s+(.*?)$/) {
d79 1
a79 1
	    if (m/^.*?\s+on\s+(.*?)\s+type\s+.*?(?:\s+\((.*?)\))?$/) {
@


1.3
log
@pkg_add reports size taken on each fs.
Reorg and clean Vstat a bit.
okay naddy@@
@
text
@d1 1
a1 1
# $OpenBSD: Vstat.pm,v 1.2 2003/12/24 02:31:28 espie Exp $
d48 2
a49 1
	my $n = $dirinfo->{"$mntpoint"};
d51 1
a51 1
		$n = { mnt => $mntpoint, used => 0 };
d53 1
d106 8
a113 3
	
	if (!defined $dirinfo->{"$dname"}) {
		return $dirinfo->{"$dname"} = _dirstat(dirname($dname));
d115 5
a119 1
		return $dirinfo->{"$dname"};
d126 8
a133 2
	if (!defined $dirinfo->{"$fname"}) {
		return _dirstat(dirname($fname));
d135 5
a139 1
		return $dirinfo->{"$fname"};
@


1.2
log
@Handle mount entries without options.
Found and tested by our ubiquitous afs user, Bob Beck.
@
text
@d1 1
a1 1
# $OpenBSD: Vstat.pm,v 1.1 2003/12/21 18:41:23 espie Exp $
d42 15
d60 14
d79 1
a79 3
		$dirinfo->{"$mntpoint"} = { mnt => $mntpoint } 
		    unless defined $dirinfo->{"$mntpoint"};
		my $i = $dirinfo->{"$mntpoint"};
d94 1
a94 19
    close($cmd1);

    delete $ENV{'BLOCKSIZE'};
    open(my $cmd2, "/bin/df|") or print STDERR "Can't run df\n";
    my $bs;
    while (<$cmd2>) {
	    chomp;
	    if (m/^Filesystem\s+(\d+)\-blocks/) {
		    $bs = $1;
	    } elsif (m/^.*?\s+\d+\s+\d+\s+(\d+)\s+\d+\%\s+(.*?)$/) {
	    	my ($mntpoint, $avail) = ($2, $1);
		$dirinfo->{"$mntpoint"} = { mnt => $mntpoint } 
		    unless defined $dirinfo->{"$mntpoint"};
		my $i = $dirinfo->{"$mntpoint"};
		$i->{blocksize} = $bs;
		$i->{avail} = $avail;
	    }
    }
    close($cmd2);
d153 8
d168 1
a168 8
	if (defined $size) {
	    my $e = filestat($name);
	    if (defined $e->{avail} && defined $e->{blocksize}) {
		$e->{avail} -= $size / $e->{blocksize};
		return $e;
	    }
	}
	return undef;
d178 9
a186 6
	if (defined $size) {
	    my $e = filestat($name);
	    $e->{avail} += $size / $e->{blocksize};
	    return $e;
	} else {
		return undef;
d188 8
@


1.1
log
@Add virtual file system, so that pkg_add and pkg_delete can check for
read-only status, or size concerns, before even beginning to add/remove
files.

Allows pkg_add -n and pkg_delete -n to be more thorough as well.

Some testing by Todd Millert, comments by Greg Steuck and Sam Smith.
@
text
@d1 1
a1 1
# $OpenBSD$
d48 1
a48 1
	    if (m/^.*?\s+on\s+(.*?)\s+type\s+.*?\s+\((.*?)\)$/) {
d53 1
@

