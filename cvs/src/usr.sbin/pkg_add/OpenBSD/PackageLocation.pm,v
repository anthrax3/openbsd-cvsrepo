head	1.51;
access;
symbols
	OPENBSD_6_0:1.45.0.8
	OPENBSD_6_0_BASE:1.45
	OPENBSD_5_9:1.45.0.2
	OPENBSD_5_9_BASE:1.45
	OPENBSD_5_8:1.45.0.4
	OPENBSD_5_8_BASE:1.45
	OPENBSD_5_7:1.44.0.2
	OPENBSD_5_7_BASE:1.44
	OPENBSD_5_6:1.44.0.4
	OPENBSD_5_6_BASE:1.44
	OPENBSD_5_5:1.39.0.4
	OPENBSD_5_5_BASE:1.39
	OPENBSD_5_4:1.30.0.8
	OPENBSD_5_4_BASE:1.30
	OPENBSD_5_3:1.30.0.6
	OPENBSD_5_3_BASE:1.30
	OPENBSD_5_2:1.30.0.4
	OPENBSD_5_2_BASE:1.30
	OPENBSD_5_1_BASE:1.30
	OPENBSD_5_1:1.30.0.2
	OPENBSD_5_0:1.29.0.2
	OPENBSD_5_0_BASE:1.29
	OPENBSD_4_9:1.28.0.2
	OPENBSD_4_9_BASE:1.28
	OPENBSD_4_8:1.24.0.2
	OPENBSD_4_8_BASE:1.24
	OPENBSD_4_7:1.18.0.2
	OPENBSD_4_7_BASE:1.18
	OPENBSD_4_6:1.17.0.4
	OPENBSD_4_6_BASE:1.17
	OPENBSD_4_5:1.15.0.8
	OPENBSD_4_5_BASE:1.15
	OPENBSD_4_4:1.15.0.6
	OPENBSD_4_4_BASE:1.15
	OPENBSD_4_3:1.15.0.4
	OPENBSD_4_3_BASE:1.15
	OPENBSD_4_2:1.15.0.2
	OPENBSD_4_2_BASE:1.15
	OPENBSD_4_1:1.5.0.2
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.4.0.2
	OPENBSD_4_0_BASE:1.4;
locks; strict;
comment	@# @;


1.51
date	2017.03.07.14.15.09;	author espie;	state Exp;
branches;
next	1.50;
commitid	cWYpAgo62e3056V5;

1.50
date	2016.10.04.10.10.19;	author espie;	state Exp;
branches;
next	1.49;
commitid	dtG19gVXVcVmDtwG;

1.49
date	2016.10.03.13.24.44;	author espie;	state Exp;
branches;
next	1.48;
commitid	4CNRYPN7ieuKCUjw;

1.48
date	2016.09.04.14.01.31;	author espie;	state Exp;
branches;
next	1.47;
commitid	7B8DXNhwaXaj31Ou;

1.47
date	2016.09.04.12.51.44;	author espie;	state Exp;
branches;
next	1.46;
commitid	Z4KMEefKKKK9UPtq;

1.46
date	2016.09.04.12.08.49;	author espie;	state Exp;
branches;
next	1.45;
commitid	FzUsHEbzjmXlu7Kf;

1.45
date	2015.04.06.11.13.41;	author espie;	state Exp;
branches;
next	1.44;
commitid	xcku1qegRujb7ch7;

1.44
date	2014.07.10.21.12.33;	author espie;	state Exp;
branches;
next	1.43;
commitid	rlsVXHJUSb5lwjzw;

1.43
date	2014.07.08.17.02.56;	author espie;	state Exp;
branches;
next	1.42;
commitid	4xDpj7wbvCslEONd;

1.42
date	2014.07.08.07.59.05;	author espie;	state Exp;
branches;
next	1.41;
commitid	tUn1ElHUvv0eMzYB;

1.41
date	2014.07.07.19.10.25;	author espie;	state Exp;
branches;
next	1.40;
commitid	71Q8UiiCnz9TOT6M;

1.40
date	2014.07.07.16.43.55;	author espie;	state Exp;
branches;
next	1.39;
commitid	e9IeHCLb7Kc19weh;

1.39
date	2014.02.09.14.23.36;	author espie;	state Exp;
branches;
next	1.38;

1.38
date	2014.02.09.12.18.26;	author espie;	state Exp;
branches;
next	1.37;

1.37
date	2014.02.09.11.13.59;	author espie;	state Exp;
branches;
next	1.36;

1.36
date	2014.02.02.23.09.56;	author espie;	state Exp;
branches;
next	1.35;

1.35
date	2014.01.30.18.54.34;	author espie;	state Exp;
branches;
next	1.34;

1.34
date	2014.01.30.13.16.58;	author espie;	state Exp;
branches;
next	1.33;

1.33
date	2014.01.23.22.57.06;	author espie;	state Exp;
branches;
next	1.32;

1.32
date	2014.01.18.01.02.25;	author espie;	state Exp;
branches;
next	1.31;

1.31
date	2014.01.17.13.15.43;	author espie;	state Exp;
branches;
next	1.30;

1.30
date	2011.08.26.08.46.09;	author espie;	state Exp;
branches;
next	1.29;

1.29
date	2011.03.20.08.17.49;	author espie;	state Exp;
branches;
next	1.28;

1.28
date	2010.12.29.13.03.05;	author espie;	state Exp;
branches;
next	1.27;

1.27
date	2010.12.24.09.04.14;	author espie;	state Exp;
branches;
next	1.26;

1.26
date	2010.10.02.13.36.56;	author espie;	state Exp;
branches;
next	1.25;

1.25
date	2010.09.14.10.02.37;	author espie;	state Exp;
branches;
next	1.24;

1.24
date	2010.07.31.11.17.22;	author espie;	state Exp;
branches;
next	1.23;

1.23
date	2010.07.28.12.19.54;	author espie;	state Exp;
branches;
next	1.22;

1.22
date	2010.06.30.10.51.04;	author espie;	state Exp;
branches;
next	1.21;

1.21
date	2010.06.30.10.41.42;	author espie;	state Exp;
branches;
next	1.20;

1.20
date	2010.06.25.10.34.03;	author espie;	state Exp;
branches;
next	1.19;

1.19
date	2010.05.10.09.17.55;	author espie;	state Exp;
branches;
next	1.18;

1.18
date	2010.01.12.10.14.37;	author espie;	state Exp;
branches;
next	1.17;

1.17
date	2009.04.19.15.18.23;	author espie;	state Exp;
branches;
next	1.16;

1.16
date	2009.04.19.14.58.32;	author espie;	state Exp;
branches;
next	1.15;

1.15
date	2007.06.10.17.13.48;	author espie;	state Exp;
branches;
next	1.14;

1.14
date	2007.06.10.15.24.36;	author espie;	state Exp;
branches;
next	1.13;

1.13
date	2007.06.04.18.55.47;	author espie;	state Exp;
branches;
next	1.12;

1.12
date	2007.06.04.14.40.39;	author espie;	state Exp;
branches;
next	1.11;

1.11
date	2007.05.17.18.52.58;	author espie;	state Exp;
branches;
next	1.10;

1.10
date	2007.05.16.07.18.55;	author espie;	state Exp;
branches;
next	1.9;

1.9
date	2007.05.15.19.47.44;	author espie;	state Exp;
branches;
next	1.8;

1.8
date	2007.05.14.17.11.05;	author espie;	state Exp;
branches;
next	1.7;

1.7
date	2007.05.02.15.05.30;	author espie;	state Exp;
branches;
next	1.6;

1.6
date	2007.04.15.10.17.29;	author espie;	state Exp;
branches;
next	1.5;

1.5
date	2006.11.17.15.34.15;	author espie;	state Exp;
branches;
next	1.4;

1.4
date	2006.03.13.16.08.12;	author espie;	state Exp;
branches;
next	1.3;

1.3
date	2006.03.07.10.59.27;	author espie;	state Exp;
branches;
next	1.2;

1.2
date	2006.03.06.12.06.37;	author espie;	state Exp;
branches;
next	1.1;

1.1
date	2006.03.04.13.13.05;	author espie;	state Exp;
branches;
next	;


desc
@@


1.51
log
@error message bugfix: forgot to pass object around, so
parse_problems would report unspecific repository issues instead of trouble
with a given package.
@
text
@# ex:ts=8 sw=4:
# $OpenBSD: PackageLocation.pm,v 1.50 2016/10/04 10:10:19 espie Exp $
#
# Copyright (c) 2003-2007 Marc Espie <espie@@openbsd.org>
#
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

use strict;
use warnings;

package OpenBSD::PackageLocation;

use OpenBSD::PackageInfo;
use OpenBSD::Temp;
use OpenBSD::Error;

sub new
{
	my ($class, $repository, $name) = @@_;

	my $self = { repository => $repository, name => $repository->canonicalize($name) };
	bless $self, $class;
	return $self;

}

sub url
{
	my $self = shift;

	return $self->{repository}->url($self->name);
}

sub name
{
	my $self = shift;
	return $self->{name};
}

OpenBSD::Auto::cache(pkgname,
    sub {
	my $self = shift;
	return OpenBSD::PackageName->from_string($self->name);
    });

OpenBSD::Auto::cache(update_info,
    sub {
	my $self = shift;
	if ($self->name =~ /^quirks\-/) {
		return $self->plist;
	}
	return $self->plist(\&OpenBSD::PackingList::UpdateInfoOnly,
	    sub {
		return 0 if $_[0] =~ m/^\@@option\s+always-update\b/m;
		return 1 if $_[0] =~ m/^\@@(?:newgroup|newuser|cwd)\b/m;
		return 0;
	    });
    });


# make sure self is opened and move to the right location if need be.
sub _opened
{
	my $self = shift;

	if (defined $self->{fh}) {
		return $self;
	}
	my $fh = $self->{repository}->open($self);
	if (!defined $fh) {
		$self->{repository}->parse_problems($self->{errors}, undef, 
		    $self) if defined $self->{errors};
		undef $self->{errors};
		return;
	}
	require OpenBSD::Ustar;
	my $archive = OpenBSD::Ustar->new($fh, $self->{repository}{state});
	$archive->set_description($self->{repository}->url($self->{name}));
	$self->{_archive} = $archive;
	$self->_set_callback;

	if (defined $self->{_current_name}) {
		while (my $e = $self->{_archive}->next) {
			if ($e->{name} eq $self->{_current_name}) {
				$self->{_current} = $e;
				return $self;
			}
		}
	}
	return $self;
}

sub _set_callback
{
	my $self = shift;
	if (defined $self->{callback} && defined $self->{_archive}) {
		$self->{_archive}->set_callback($self->{callback});
	}
}

sub find_contents
{
	my ($self, $extra) = @@_;

	while (my $e = $self->next) {
		if ($e->isFile && is_info_name($e->{name})) {
			if ($e->{name} eq CONTENTS ) {
				my $v = 
				    $self->{extra_content}.$e->contents($extra);
				return $v;
			}
		} else {
			$self->unput;
			last;
		}
	}
}

sub contents
{
	my ($self, $extra) = @@_;
	if (!defined $self->{contents}) {
		if (!$self->_opened) {
			return;
		}
		if (defined $extra) {
			my $contents = $self->find_contents($extra);
			if ($contents) {
				$self->unput;
			}
			return $contents;
		}
		$self->{contents} = $self->find_contents;
	}

	return $self->{contents};
}

sub grab_info
{
	my $self = shift;
	my $dir = $self->{dir} = OpenBSD::Temp->dir;

	my $c = $self->contents;
	if (!defined $c) {
		return 0;
	}

	if (! -f $dir.CONTENTS) {
		open my $fh, '>', $dir.CONTENTS or die "Permission denied";
		print $fh $self->contents;
		close $fh;
	}

	while (my $e = $self->next) {
		if ($e->isFile && is_info_name($e->{name})) {
			$e->{name} = $dir.$e->{name};
			undef $e->{mtime};
			undef $e->{atime};
			eval { $e->create; };
			if ($@@) {
				unlink($e->{name});
				$@@ =~ s/\s+at.*//o;
				$self->{repository}{state}->errprint('#1', $@@);
				return 0;
			}
		} else {
			$self->unput;
			last;
		}
	}
	return 1;
}

sub grabPlist
{
	my ($self, $code) = @@_;

	my $plist = $self->plist($code);
	if (defined $plist) {
		$self->wipe_info;
		$self->close_now;
		return $plist;
	} else {
		return;
	}
}

sub forget
{
	my $self = shift;
	$self->wipe_info;
	$self->close_now;
}

sub wipe_info
{
	my $self = shift;
	$self->{repository}->wipe_info($self);
	$self->{repository}->close_now($self);
	delete $self->{contents};
	$self->deref;
	delete $self->{_current_name};
	delete $self->{update_info};
	delete $self->{_unput};
}

sub info
{
	my $self = shift;

	if (!defined $self->{dir}) {
		$self->grab_info;
	}
	return $self->{dir};
}

sub plist
{
	my ($self, $code, $extra) = @@_;
	require OpenBSD::PackingList;

	if (defined $self->{dir} && -f $self->{dir}.CONTENTS) {
		my $plist =
		    OpenBSD::PackingList->fromfile($self->{dir}.CONTENTS,
		    $code);
		$plist->set_infodir($self->{dir});
		return $plist;
	}
	if (my $value = $self->contents($extra)) {
		return OpenBSD::PackingList->fromfile(\$value, $code);
	}
	# hopeless
	$self->close_with_client_error;

	return;
}

sub close
{
	my ($self, $hint) = @@_;
	$self->{repository}->close($self, $hint);
}

sub finish_and_close
{
	my $self = shift;
	$self->{repository}->finish_and_close($self);
}

sub close_now
{
	my $self = shift;
	$self->{repository}->close_now($self);
}

sub close_after_error
{
	my $self = shift;
	$self->{repository}->close_after_error($self);
}

sub close_with_client_error
{
	my $self = shift;
	$self->{repository}->close_with_client_error($self);
}

sub deref
{
	my $self = shift;
	delete $self->{fh};
	delete $self->{pid2};
	delete $self->{_archive};
	delete $self->{_current};
}

# proxy for archive operations
sub next
{
	my $self = shift;

	if (!$self->_opened) {
		return;
	}
	if (!$self->{_unput}) {
		$self->{_current} = $self->getNext;
		if (defined $self->{_current}) {
			$self->{_current_name} = $self->{_current}{name};
		} else {
			delete $self->{_current_name};
		}
	} else {
		$self->{_unput} = 0;
	}
	return $self->{_current};
}

sub unput
{
	my $self = shift;
	$self->{_unput} = 1;
}

sub getNext
{
	my $self = shift;

	return $self->{_archive}->next;
}

sub skip
{
	my $self = shift;
	return $self->{_archive}->skip;
}

sub set_callback
{
	my ($self, $code) = @@_;
	$self->{callback} = $code;
	$self->_set_callback;
}

package OpenBSD::PackageLocation::Installed;
our @@ISA = qw(OpenBSD::PackageLocation);


sub info
{
	my $self = shift;
	require OpenBSD::PackageInfo;
	$self->{dir} = OpenBSD::PackageInfo::installed_info($self->name);
}

sub plist
{
	my ($self, $code) = @@_;
	require OpenBSD::PackingList;
	return OpenBSD::PackingList->from_installation($self->name, $code);
}

1;
@


1.50
log
@remove may_check_data logic, since signatures are now handled externally
@
text
@d2 1
a2 1
# $OpenBSD: PackageLocation.pm,v 1.49 2016/10/03 13:24:44 espie Exp $
d81 2
a82 2
		$self->{repository}->parse_problems($self->{errors})
		    if defined $self->{errors};
@


1.49
log
@No need to record gzip position after CONTENTS since we don't need partial
copy for newer signatures
@
text
@d2 1
a2 1
# $OpenBSD: PackageLocation.pm,v 1.48 2016/09/04 14:01:31 espie Exp $
a49 5
sub trusted
{
	return 0;
}

a351 6

sub trusted
{
	return 1;
}

@


1.48
log
@put signify errors alongside ftp
@
text
@d2 1
a2 1
# $OpenBSD: PackageLocation.pm,v 1.47 2016/09/04 12:51:44 espie Exp $
a115 13
sub store_end_of_stream
{

	my $self = shift;
	my $sym = $self->{fh};
	# don't bother for streams that don't end right after CONTENTS
	return if !*$sym->{NewStream};
	$self->{length} = *$sym->{CompSize}->get64bit +
	    *$sym->{Info}{HeaderLength} +
	    *$sym->{Info}{TrailerLength};
}


a124 1
				$self->store_end_of_stream;
@


1.47
log
@signature tracking bases: stored signed status inside object, so that
we don't erroneously get "signature" comments from unsigned packages.
force the gzip object to get its header.
So if it can't something wrong happened.
for now, we just know shit happened...
@
text
@d2 1
a2 1
# $OpenBSD: PackageLocation.pm,v 1.46 2016/09/04 12:08:49 espie Exp $
a127 15
sub signing_info
{
	my $self = shift;
	my $result = "";
	if ($self->{is_signed}) {
		for my $line (split /\n/, $self->{fh}->getHeaderInfo->{Comment}) {
			if ($line =~ m/^key=.*\/(.*)\.sec$/) {
				$result .= "\@@signer $1\n";
			} elsif ($line =~ m/^date=(.*)$/) {
				$result .= "\@@digital-signature signify2:$1:external\n";
			}
		}
	}
	return $result;
}
d137 1
a137 1
				    $self->signing_info.$e->contents($extra);
@


1.46
log
@basic scaffolding to ask signify to check stuff
still missing some proper error reporting
@
text
@d2 1
a2 1
# $OpenBSD: PackageLocation.pm,v 1.45 2015/04/06 11:13:41 espie Exp $
a130 1
	my $comment;
d132 2
a133 5
	eval {
		$comment = $self->{fh}->getHeaderInfo->{Comment};
	};
	if (defined $comment) {
		for my $line (split /\n/, $comment) {
d151 2
a152 3
				# XXX not yet
				#my $v = $self->signing_info.$e->contents($extra);
				my $v = $e->contents($extra);
@


1.45
log
@mark installed locations as "trusted" so that pkg_info does not check sigs
on them.
@
text
@d2 1
a2 1
# $OpenBSD: PackageLocation.pm,v 1.44 2014/07/10 21:12:33 espie Exp $
d128 20
d155 2
@


1.44
log
@make quirks slightly more special, grab the whole packing-list always,
and display the timestamp from the signature if we were signed.
@
text
@d2 1
a2 1
# $OpenBSD: PackageLocation.pm,v 1.43 2014/07/08 17:02:56 espie Exp $
d50 5
d369 6
@


1.43
log
@don't really bother cleaning up the callback, it will go away soon enough
@
text
@d2 1
a2 1
# $OpenBSD: PackageLocation.pm,v 1.42 2014/07/08 07:59:05 espie Exp $
d59 3
@


1.42
log
@cleaner callback handling
- store it inside location, so that belayed archives open can get it
- wipe it out when the sizer goes away... to be done slightly better
probably ?
@
text
@d2 1
a2 1
# $OpenBSD: PackageLocation.pm,v 1.41 2014/07/07 19:10:25 espie Exp $
d103 1
a103 1
	if (defined $self->{_archive}) {
@


1.41
log
@sometimes, the callback happens when the archive isn't opened...
fix it quickly, to be fixed better later.
@
text
@d2 1
a2 1
# $OpenBSD: PackageLocation.pm,v 1.40 2014/07/07 16:43:55 espie Exp $
d87 1
d100 8
d340 2
a341 3
	if (defined $self->{_archive}) {
		$self->{_archive}->set_callback($code);
	}
@


1.40
log
@restore progressmeter for big files.
somehow, one extra level of indirection to archive, make it all go away
by adding a new method set_callback
@
text
@d2 1
a2 1
# $OpenBSD: PackageLocation.pm,v 1.39 2014/02/09 14:23:36 espie Exp $
d331 3
a333 1
	$self->{_archive}->set_callback($code);
@


1.39
log
@wipe stuff during wipe_info, deref should keep unput correct.
@
text
@d2 1
a2 1
# $OpenBSD: PackageLocation.pm,v 1.38 2014/02/09 12:18:26 espie Exp $
d326 6
@


1.38
log
@grr... this should be kept across derefs
@
text
@d2 1
a2 1
# $OpenBSD: PackageLocation.pm,v 1.37 2014/02/09 11:13:59 espie Exp $
d215 1
a285 1
	delete $self->{_unput};
@


1.37
log
@do a better job in wipe_info: close files and reap children.
also wipe every state variable... fixes reget update_info in fringe
cases (this should fix nigel@@'s problems...)
@
text
@d2 1
a2 1
# $OpenBSD: PackageLocation.pm,v 1.36 2014/02/02 23:09:56 espie Exp $
d213 1
a284 1
	delete $self->{_current_name};
@


1.36
log
@gc really old code
@
text
@d2 1
a2 1
# $OpenBSD: PackageLocation.pm,v 1.35 2014/01/30 18:54:34 espie Exp $
d210 1
a212 1
	delete $self->{_current_name};
a280 1
	delete $self->{pid};
d284 2
@


1.35
log
@wipe locations a bit more thoroughly
@
text
@d2 1
a2 1
# $OpenBSD: PackageLocation.pm,v 1.34 2014/01/30 13:16:58 espie Exp $
d115 1
a115 1
	while (my $e = $self->_next) {
d165 1
a165 1
	while (my $e = $self->_next) {
a288 10
{
	my $self = shift;

	if (!defined $self->{dir}) {
		$self->grabInfoFiles;
	}
	return $self->_next;
}

sub _next
@


1.34
log
@not really a need to store state in the location, when we can ask
our repository for it.
@
text
@d2 1
a2 1
# $OpenBSD: PackageLocation.pm,v 1.33 2014/01/23 22:57:06 espie Exp $
d210 4
d280 5
a284 5
	$self->{fh} = undef;
	$self->{pid} = undef;
	$self->{pid2} = undef;
	$self->{_archive} = undef;
	$self->{_current} = undef;
@


1.33
log
@tweak the way we create and sign packages significantly:

all modern compression formats support multi-stream archives.
Store the packing-list as a separate stream, and note where the
first stream ends when reading back the packing list.

When pkg_sign sees a split-stream archive, it does not need to unpack/repack
the whole archive: it can just sign the packing-list, close the stream, and
copy the next stream(s) from the source archive verbatim.

This is perfectly transparent to pkg_add, but abuses IO::Uncompress::Gunzip
internals slightly (to be solved with cpan).

also adds explicit option -C for generating a SHA256 list of all packages.

and okay naddy@@
@
text
@d2 1
a2 1
# $OpenBSD: PackageLocation.pm,v 1.32 2014/01/18 01:02:25 espie Exp $
d31 1
a31 1
	my $self = { repository => $repository, name => $repository->canonicalize($name), state => $repository->{state} };
d84 1
a84 1
	my $archive = OpenBSD::Ustar->new($fh, $self->{state});
d174 1
a174 1
				$self->{state}->errprint('#1', $@@);
@


1.32
log
@caching a bit more tricky... problem noticed by naddy@@
@
text
@d2 1
a2 1
# $OpenBSD: PackageLocation.pm,v 1.31 2014/01/17 13:15:43 espie Exp $
d99 12
d118 3
a120 1
				return $e->contents($extra);
@


1.31
log
@oops, keeping _current around means I still have a live fh  after deref.
So remove it too. Accordingly, the code that resyncs archives on reopen
needs us tracking the name itself.
@
text
@d2 1
a2 1
# $OpenBSD: PackageLocation.pm,v 1.30 2011/08/26 08:46:09 espie Exp $
d289 5
a293 1
		$self->{_current_name} = $self->{_current}{name};
@


1.30
log
@zap fatpackages. nobody actually uses them.
accordingly, locations do not need to track architecture.
@
text
@d2 1
a2 1
# $OpenBSD: PackageLocation.pm,v 1.29 2011/03/20 08:17:49 espie Exp $
d88 1
a88 1
	if (defined $self->{_current}) {
d90 1
a90 1
			if ($e->{name} eq $self->{_current}->{name}) {
d266 1
d289 1
@


1.29
log
@pass url name to Ustar, for error messages
@
text
@d2 1
a2 1
# $OpenBSD: PackageLocation.pm,v 1.28 2010/12/29 13:03:05 espie Exp $
d29 1
a29 1
	my ($class, $repository, $name, $arch) = @@_;
a31 3
	if (defined $arch) {
		$self->{arch} = $arch;
	}
a36 7
sub set_arch
{
	my ($self, $arch) = @@_;

	$self->{arch} = $arch;
}

a114 26
sub find_fat_contents
{
	my $self = shift;

	while (my $e = $self->_next) {
		unless ($e->{name} =~ m/^(.*)\/\+CONTENTS$/o) {
			last;
		}
		my $prefix = $1;
		my $contents = $e->contents;
		require OpenBSD::PackingList;

		my $plist = OpenBSD::PackingList->fromfile(\$contents,
		    \&OpenBSD::PackingList::FatOnly);
		if (defined $self->name) {
			next if $plist->pkgname ne $self->name;
		}
		if ($plist->has('arch')) {
			if ($plist->{arch}->check($self->{arch})) {
				$self->{filter} = $prefix;
				return $contents;
			}
		}
	}
}

a125 1
				return $contents;
d127 1
a127 1
			return $self->find_fat_contents;
d129 1
a129 2
		$self->{contents} = $self->find_contents ||
		    $self->find_fat_contents;
d304 1
a304 14
	my $e = $self->{_archive}->next;
	if (defined $self->{filter}) {
		if ($e->{name} =~ m/^(.*?)\/(.*)$/o) {
			my ($beg, $name) = ($1, $2);
			if (index($beg, $self->{filter}) == -1) {
				return $self->getNext;
			}
			$e->{name} = $name;
			if ($e->isHardLink) {
				$e->{linkname} =~ s/^(.*?)\///o;
			}
		}
	}
	return $e;
@


1.28
log
@more stuff that uses print directly dies
@
text
@d2 1
a2 1
# $OpenBSD: PackageLocation.pm,v 1.27 2010/12/24 09:04:14 espie Exp $
d95 1
@


1.27
log
@handle failures from ports tree with more care.
this does avoid infinite loops in case of wrong plists.
necessary since print-plist-with-depends CAN fail...
@
text
@d2 1
a2 1
# $OpenBSD$
d197 1
a197 1
				print STDERR $@@;
@


1.26
log
@somewhat complicated optimization: avoid reading the whole plist file
when we're only looking for update-info. Means Ustar must deal with
"partial" files. Occasionnally a huge win, such as skipping 95% of the kdebase
or texlive plist when they don't need updating.

I've been running with this for a few weeks now...
@
text
@d2 1
a2 1
# $OpenBSD: PackageLocation.pm,v 1.25 2010/09/14 10:02:37 espie Exp $
@


1.25
log
@set separate fields for atime/mtime in file entry, use them while creating.
allows user to undef them, and thus not to set utimes.
Use that to not set utimes for pkginfo.
fixes kili@@'s bug in a nicer way wrt Ustar interface...
@
text
@d2 1
a2 1
# $OpenBSD: PackageLocation.pm,v 1.24 2010/07/31 11:17:22 espie Exp $
d69 6
a74 1
	return $self->plist(\&OpenBSD::PackingList::UpdateInfoOnly);
d110 1
a110 1
	my $self = shift;
d115 1
a115 1
				return $e->contents;
d152 1
a152 1
	my $self = shift;
d157 8
d247 1
a247 1
	my ($self, $code) = @@_;
d257 1
a257 1
	if (my $value = $self->contents) {
@


1.24
log
@keep location open while we grab updateinfo.
deal with error fallout and need to forget unneeded stuff
(halves number of connections, roughly)
@
text
@d2 1
a2 1
# $OpenBSD: PackageLocation.pm,v 1.23 2010/07/28 12:19:54 espie Exp $
d178 2
@


1.23
log
@pass state to Ustar objects, use it to display those pesky error and
fatal messages.

zap $opt_x from pkg_mklocated, do things like other commands do.
@
text
@d2 1
a2 1
# $OpenBSD: PackageLocation.pm,v 1.22 2010/06/30 10:51:04 espie Exp $
d69 1
a69 1
	return $self->grabPlist(\&OpenBSD::PackingList::UpdateInfoOnly);
d205 7
@


1.22
log
@allow say and errsay to work without parameters, as it's ways common.
create verbose_system up in state, because it makes sense without verbose.
@
text
@d2 1
a2 1
# $OpenBSD$
d31 1
a31 1
	my $self = { repository => $repository, name => $repository->canonicalize($name)};
d89 1
a89 1
	my $archive = new OpenBSD::Ustar $fh;
@


1.21
log
@whitespace cleanup
@
text
@@


1.20
log
@do options the other way so that we provide defaults that can be overridden
locally
@
text
@@


1.19
log
@whitespace fixes
@
text
@@


1.18
log
@more auto-cache goodness
@
text
@d83 1
a83 1
		$self->{repository}->parse_problems($self->{errors}) 
d131 1
a131 1
		my $plist = OpenBSD::PackingList->fromfile(\$contents, 
d152 1
a152 1
		$self->{contents} = $self->find_contents || 
d229 2
a230 2
		my $plist = 
		    OpenBSD::PackingList->fromfile($self->{dir}.CONTENTS, 
d310 1
a310 1
{ 	
@


1.17
log
@remove class FatPackageLocation. Instead make PackageLocation a hierarchy
so that I can handle installed packages without playing ping-pong with
the PackageRepository hierarchy (mostly)
@
text
@d25 1
d60 2
a61 2
sub pkgname
{
d63 2
a64 7
	if (!defined $self->{pkgname}) {
		require OpenBSD::PackageName;

		$self->{pkgname} = OpenBSD::PackageName->from_string($self->name);
	}
	return $self->{pkgname};
}
d66 2
a67 2
sub update_info
{
d69 2
a70 5
	if (!defined $self->{update_info}) {
		$self->{update_info} = $self->grabPlist(\&OpenBSD::PackingList::UpdateInfoOnly);
	}
	return $self->{update_info};
}
@


1.16
log
@synch with my new style search/location changes
It's likely there will be some fallout, but it's getting a bit too large
to keep around.
This does kill a few very old oddities as well.
@
text
@a145 1
				bless $self, "OpenBSD::FatPackageLocation";
d166 1
a166 1
sub grabInfoFiles
d225 1
a225 1
		$self->{repository}->grab_info($self);
a232 7
	$self->{repository}->get_plist($self, $code);
}

sub _plist
{
	my ($self, $code) = @@_;

d326 14
a339 1
	return $self->{_archive}->next;
d348 3
a350 2
package OpenBSD::FatPackageLocation;
our @@ISA=qw(OpenBSD::PackageLocation);
d352 1
a352 1
sub getNext
d355 3
d359 5
a363 12
	my $e = $self->SUPER::getNext;
	if ($e->{name} =~ m/^(.*?)\/(.*)$/o) {
		my ($beg, $name) = ($1, $2);
		if (index($beg, $self->{filter}) == -1) {
			return $self->next;
		}
		$e->{name} = $name;
		if ($e->isHardLink) {
			$e->{linkname} =~ s/^(.*?)\///o;
		}
	}
	return $e;
@


1.15
log
@give repository/locations slightly more control over package names.
@
text
@d2 1
a2 1
# $OpenBSD: PackageLocation.pm,v 1.14 2007/06/10 15:24:36 espie Exp $
d30 4
a33 1
	my $self = { repository => $repository, name => $repository->canonicalize($name), arch => $arch};
a34 1
#	print STDERR "Built location ", $self->url, "\n";
d59 23
a81 1
sub openArchive
d85 3
a95 1

d98 10
d110 1
a110 1
sub grabInfoFiles
a112 1
	my $dir = $self->{dir} = OpenBSD::Temp::dir();
d114 1
a114 7
	if (defined $self->{contents} && ! -f $dir.CONTENTS) {
		open my $fh, '>', $dir.CONTENTS or die "Permission denied";
		print $fh $self->{contents};
		close $fh;
	}

	while (my $e = $self->intNext) {
d116 2
a117 7
			$e->{name}=$dir.$e->{name};
			eval { $e->create; };
			if ($@@) {
				unlink($e->{name});
				$@@ =~ s/\s+at.*//o;
				print STDERR $@@;
				return 0;
a123 1
	return 1;
d126 42
a167 1
sub scanPackage
d170 14
a183 1
	while (my $e = $self->intNext) {
d185 1
a185 8
			if ($e->{name} eq CONTENTS && !defined $self->{dir}) {
				$self->{contents} = $e->contents;
				last;
			}
			if (!defined $self->{dir}) {
				$self->{dir} = OpenBSD::Temp::dir();
			}
			$e->{name}=$self->{dir}.$e->{name};
d205 4
a208 5
	my $pkg = $self->openPackage;
	if (defined $pkg) {
		my $plist = $self->plist($code);
		$pkg->wipe_info;
		$pkg->close_now;
a214 42
sub openPackage
{
	my $self = shift;
	my $arch = $self->{arch};
	if (!$self->openArchive) {
		return;
	}
	$self->scanPackage;

	if (defined $self->{contents}) {
		return $self;
	} 

	# maybe it's a fat package.
	while (my $e = $self->intNext) {
		unless ($e->{name} =~ m/^(.*)\/\+CONTENTS$/o) {
			last;
		}
		my $prefix = $1;
		my $contents = $e->contents;
		require OpenBSD::PackingList;

		my $plist = OpenBSD::PackingList->fromfile(\$contents, 
		    \&OpenBSD::PackingList::FatOnly);
		if (defined $self->{name}) {
			next if $plist->pkgname ne $self->{name};
		}
		if ($plist->has('arch')) {
			if ($plist->{arch}->check($arch)) {
				$self->{filter} = $prefix;
				bless $self, "OpenBSD::FatPackageLocation";
				$self->{contents} = $contents;
				return $self;
			}
		}
	}
	# hopeless
	$self->close_with_client_error;
	$self->wipe_info;
	return;
}

d224 1
d226 1
a226 1
		$self->grabInfoFiles;
d234 6
d243 1
a243 4
	if (defined $self->{contents}) {
		my $value = $self->{contents};
		return OpenBSD::PackingList->fromfile(\$value, $code);
	} elsif (defined $self->{dir} && -f $self->{dir}.CONTENTS) {
d250 3
a297 15
sub reopen
{
	my $self = shift;
	if (!$self->openArchive) {
		return;
	}
	while (my $e = $self->{_archive}->next) {
		if ($e->{name} eq $self->{_current}->{name}) {
			$self->{_current} = $e;
			return $self;
		}
	}
	return;
}

d306 1
a306 1
	return $self->intNext;
d309 1
a309 1
sub intNext
d313 2
a314 4
	if (!defined $self->{fh}) {
		if (!$self->reopen) {
			return;
		}
d318 2
a320 1
	$self->{_unput} = 0;
@


1.14
log
@set_infodir when we can in PackageLocation.
Create a full handle for replaced packages as well.
@
text
@d2 1
a2 1
# $OpenBSD: PackageLocation.pm,v 1.13 2007/06/04 18:55:47 espie Exp $
d30 1
a30 4
	if (defined $name) {
		$name =~ s/\.tgz$//o;
	}
	my $self = { repository => $repository, name => $name, arch => $arch};
d48 7
a54 1
	return $self->{repository}->url($self->{name});
@


1.13
log
@a few missed $' / $`
@
text
@d2 1
a2 1
# $OpenBSD: PackageLocation.pm,v 1.12 2007/06/04 14:40:39 espie Exp $
d210 2
a211 1
		return OpenBSD::PackingList->fromfile($self->{dir}.CONTENTS, 
d213 2
@


1.12
log
@some minor systematic changes.
- mark all regexps I can with /o if they can be compiled once.
- turn $o->method() into $o->method
- remove unneeded prototypes
- reduce split /re/ into split "string" where possible.
@
text
@d2 1
a2 1
# $OpenBSD: PackageLocation.pm,v 1.11 2007/05/17 18:52:58 espie Exp $
d158 1
a158 1
		unless ($e->{name} =~ m/\/\+CONTENTS$/o) {
d161 1
a161 1
		my $prefix = $`;
@


1.11
log
@new methods: repositories can create url. Rename PackageLocation->stringize
to url, since that's what it does. Use the new methods to shorten code.
@
text
@d2 1
a2 1
# $OpenBSD: PackageLocation.pm,v 1.10 2007/05/16 07:18:55 espie Exp $
d31 1
a31 1
		$name =~ s/\.tgz$//;
d85 1
a85 1
			eval { $e->create(); };
d88 1
a88 1
				$@@ =~ s/\s+at.*//;
d93 1
a93 1
			$self->unput();
d106 1
a106 1
				$self->{contents} = $e->contents();
d116 1
a116 1
				$@@ =~ s/\s+at.*//;
d158 1
a158 1
		unless ($e->{name} =~ m/\/\+CONTENTS$/) {
d327 1
a327 1
	if ($e->{name} =~ m/^(.*?)\/(.*)$/) {
d334 1
a334 1
			$e->{linkname} =~ s/^(.*?)\///;
@


1.10
log
@oops, committed debug code, sorry.
@
text
@d2 1
a2 1
# $OpenBSD: PackageLocation.pm,v 1.9 2007/05/15 19:47:44 espie Exp $
d35 1
a35 1
#	print STDERR "Built location ", $self->stringize, "\n";
d47 1
a47 1
sub stringize
d51 1
a51 1
	return $self->{repository}->stringize($self->{name});
@


1.9
log
@allows for incomplete locations (without arch) and for repositories to
print PackageLocations (to be cleaned up later).
@
text
@d2 1
a2 1
# $OpenBSD: PackageLocation.pm,v 1.8 2007/05/14 17:11:05 espie Exp $
d35 1
a35 1
	print STDERR "Built location ", $self->stringize, "\n";
@


1.8
log
@cosmetic tweak
@
text
@d2 1
a2 1
# $OpenBSD: PackageLocation.pm,v 1.7 2007/05/02 15:05:30 espie Exp $
d35 17
@


1.7
log
@$o->method() becomes $o->method
@
text
@d2 1
a2 1
# $OpenBSD: PackageLocation.pm,v 1.6 2007/04/15 10:17:29 espie Exp $
d4 1
a4 1
# Copyright (c) 2003-2006 Marc Espie <espie@@openbsd.org>
d65 2
a66 2
	while (my $e = $self->intNext()) {
		if ($e->isFile() && is_info_name($e->{name})) {
d87 1
a87 1
		if ($e->isFile() && is_info_name($e->{name})) {
@


1.6
log
@update copyright years, standardize licence.
reword the introduction to the stuff originally from FreeBSD to clarify
slightly.
@
text
@d2 1
a2 1
# $OpenBSD: PackageLocation.pm,v 1.5 2006/11/17 15:34:15 espie Exp $
d86 1
a86 1
	while (my $e = $self->intNext()) {
d96 1
a96 1
			eval { $e->create(); };
d104 1
a104 1
			$self->unput();
d115 1
a115 1
	my $pkg = $self->openPackage();
d118 2
a119 2
		$pkg->wipe_info();
		$pkg->close_now();
d130 1
a130 1
	if (!$self->openArchive()) {
d133 1
a133 1
	$self->scanPackage();
d140 1
a140 1
	while (my $e = $self->intNext()) {
d145 1
a145 1
		my $contents = $e->contents();
d151 1
a151 1
			next if $plist->pkgname() ne $self->{name};
d163 2
a164 2
	$self->close_with_client_error();
	$self->wipe_info();
d178 1
a178 1
		$self->grabInfoFiles();
d197 1
a197 1
	$self->close_with_client_error();
d244 1
a244 1
	if (!$self->openArchive()) {
d247 1
a247 1
	while (my $e = $self->{_archive}->next()) {
d262 1
a262 1
		$self->grabInfoFiles();
d264 1
a264 1
	return $self->intNext();
d272 1
a272 1
		if (!$self->reopen()) {
d277 1
a277 1
		$self->{_current} = $self->getNext();
d293 1
a293 1
	return $self->{_archive}->next();
d299 1
a299 1
	return $self->{_archive}->skip();
d309 1
a309 1
	my $e = $self->SUPER::getNext();
d313 1
a313 1
			return $self->next();
d316 1
a316 1
		if ($e->isHardLink()) {
@


1.5
log
@don't return undef, use plain return.
(return undef is only false in a scalar context)
found my perlcritic, one of the few issues I agree with...
@
text
@d2 1
a2 1
# $OpenBSD: PackageLocation.pm,v 1.4 2006/03/13 16:08:12 espie Exp $
d4 1
a4 1
# Copyright (c) 2003-2004 Marc Espie <espie@@openbsd.org>
@


1.4
log
@clean-up some name handling:
- package locations always contain a pkgname (except if we don't have it)
- complete it on the repository side to grab the right file.
- no need to pass pkgname/arch on $location->grabPlist(), since it's
already in the location.
@
text
@d2 1
a2 1
# $OpenBSD: PackageLocation.pm,v 1.3 2006/03/07 10:59:27 espie Exp $
d46 1
a46 1
		return undef;
d122 1
a122 1
		return undef;
d131 1
a131 1
		return undef;
d165 1
a165 1
	return undef;
d199 1
a199 1
	return undef;
d245 1
a245 1
		return undef;
d253 1
a253 1
	return undef;
d273 1
a273 1
			return undef;
@


1.3
log
@pass the grandchild pid through the pipe, in order to be able to monitor it.
@
text
@d2 1
a2 1
# $OpenBSD: PackageLocation.pm,v 1.2 2006/03/06 12:06:37 espie Exp $
d28 6
a33 2
	my ($class, $repository, $name) = @@_;
	my $self = { repository => $repository, name => $name};
d113 1
a113 1
	my ($self, $pkgname, $arch, $code) = @@_;
d115 1
a115 1
	my $pkg = $self->openPackage($pkgname, $arch);
d128 2
a129 1
	my ($self, $pkgname, $arch) = @@_;
a147 2
		$pkgname =~ s/\.tgz$//;

d150 3
a152 1
		next if defined $pkgname and $plist->pkgname() ne $pkgname;
@


1.2
log
@zap object pid when done with it.
@
text
@d2 1
a2 1
# $OpenBSD: PackageLocation.pm,v 1.1 2006/03/04 13:13:05 espie Exp $
d232 1
@


1.1
log
@cut down the Locator code into maintainable chunks.
@
text
@d2 1
a2 1
# $OpenBSD: PackageLocator.pm,v 1.51 2006/03/04 11:28:03 espie Exp $
d231 1
@

