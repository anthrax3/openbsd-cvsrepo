head	1.19;
access;
symbols
	OPENBSD_4_0:1.18.0.8
	OPENBSD_4_0_BASE:1.18
	OPENBSD_3_9:1.18.0.6
	OPENBSD_3_9_BASE:1.18
	OPENBSD_3_8:1.18.0.4
	OPENBSD_3_8_BASE:1.18
	OPENBSD_3_7:1.18.0.2
	OPENBSD_3_7_BASE:1.18
	OPENBSD_3_6:1.17.0.6
	OPENBSD_3_6_BASE:1.17
	OPENBSD_3_5:1.17.0.4
	OPENBSD_3_5_BASE:1.17
	OPENBSD_3_4:1.17.0.2
	OPENBSD_3_4_BASE:1.17
	OPENBSD_3_3:1.15.0.2
	OPENBSD_3_3_BASE:1.15
	OPENBSD_3_2:1.14.0.2
	OPENBSD_3_2_BASE:1.14
	OPENBSD_3_1:1.11.0.2
	OPENBSD_3_1_BASE:1.11
	OPENBSD_3_0:1.9.0.2
	OPENBSD_3_0_BASE:1.9
	OPENBSD_2_9_BASE:1.7
	OPENBSD_2_9:1.7.0.2
	OPENBSD_2_8:1.6.0.4
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.6.0.2
	OPENBSD_2_7_BASE:1.6
	OPENBSD_2_6:1.5.0.2
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.4.0.4
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.4.0.2
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.3.0.4
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.2
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.19
date	2006.09.20.14.58.32;	author pedro;	state dead;
branches;
next	1.18;

1.18
date	2005.02.17.13.50.41;	author aaron;	state Exp;
branches;
next	1.17;

1.17
date	2003.06.26.22.11.01;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2003.06.02.23.36.52;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2003.03.14.14.53.45;	author jmc;	state Exp;
branches;
next	1.14;

1.14
date	2002.06.10.00.40.53;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2002.06.09.02.38.11;	author itojun;	state Exp;
branches;
next	1.12;

1.12
date	2002.05.29.09.47.20;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2002.03.14.16.44.24;	author mpech;	state Exp;
branches;
next	1.10;

1.10
date	2002.02.16.21.28.01;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2001.08.12.12.03.03;	author heko;	state Exp;
branches;
next	1.8;

1.8
date	2001.07.02.16.51.46;	author jasoni;	state Exp;
branches;
next	1.7;

1.7
date	2000.12.09.14.51.03;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	99.12.05.06.32.47;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	99.06.16.10.23.17;	author espie;	state Exp;
branches;
next	1.4;

1.4
date	98.07.13.02.11.45;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	97.07.27.02.33.35;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	97.06.29.07.15.29;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.47.25;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.47.25;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.19
log
@Remove bad144, okay deraadt@@ miod@@
@
text
@/*	$OpenBSD: bad144.c,v 1.18 2005/02/17 13:50:41 aaron Exp $	*/
/*
 * Copyright (c) 1980, 1986, 1988, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#ifndef lint
static char copyright[] =
"@@(#) Copyright (c) 1980, 1986, 1988, 1993\n\
	The Regents of the University of California.  All rights reserved.\n";
#endif /* not lint */

#ifndef lint
/*static char sccsid[] = "from: @@(#)bad144.c	8.1 (Berkeley) 6/6/93";*/
static char *rcsid = "$Id: bad144.c,v 1.18 2005/02/17 13:50:41 aaron Exp $";
#endif /* not lint */

/*
 * bad144
 *
 * This program prints and/or initializes a bad block record for a pack,
 * in the format used by the DEC standard 144.
 * It can also add bad sector(s) to the record, moving the sector
 * replacements as necessary.
 *
 * It is preferable to write the bad information with a standard formatter,
 * but this program will do.
 * 
 * RP06 sectors are marked as bad by inverting the format bit in the
 * header; on other drives the valid-sector bit is cleared.
 */
#include <sys/param.h>
#include <sys/dkbad.h>
#include <sys/ioctl.h>
#include <sys/file.h>
#include <sys/disklabel.h>
#include <ufs/ffs/fs.h>

#include <unistd.h>
#include <stdlib.h>
#include <stdio.h>
#include <paths.h>
#include <string.h>
#include <err.h>

#define RETRIES	10		/* number of retries on reading old sectors */

int	add, copy, verbose, nflag;
int	dups;
int	badfile = -1;		/* copy of badsector table to use, -1 if any */
#define MAXSECSIZE	1024
struct	dkbad curbad, oldbad;
#define	DKBAD_MAGIC	0x4321

char	label[BBSIZE];
daddr_t	size;
struct	disklabel *dp;
char	name[BUFSIZ];

void	Perror(const char *);
daddr_t	badsn(const struct bt_bad *);
int	blkcopy(int, daddr_t, daddr_t);
void	blkzero(int, daddr_t);
int	checkold(void);
int	compare(const void *, const void *);
daddr_t	getold(int, struct dkbad *);
void	shift(int, int, int);
void	usage(void);

int
main(int argc, char *argv[])
{
	struct bt_bad *bt;
	daddr_t	sn, bn[NBT_BAD];
	int i, f, nbad, new, bad, errs, ch;

	while ((ch = getopt(argc, argv, "acnv01234")) != -1) {
		switch(ch) {
		case 'a':
			add = 1;
			break;
		case 'c':
			copy = 1;
			break;
		case 'n':
			nflag = 1;
			/* FALLTHROUGH */
		case 'v':
			verbose = 1;
			break;
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
			badfile = ch - '0';
			break;
		}
	}
	argc -= optind;
	argv += optind;

	if (argc < 1)
		usage();

	if (argv[0][0] != '/')
		(void)snprintf(name, sizeof(name), "%sr%s%c", _PATH_DEV,
		    argv[0], 'a' + RAW_PART);
	else
		strlcpy(name, argv[0], sizeof(name));
	f = open(name, argc == 1? O_RDONLY : O_RDWR);
	if (f < 0)
		err(4, "can't open %s", name);

	/* obtain label and adjust to fit */
	dp = (struct disklabel *)&label;
	if (ioctl(f, DIOCGDINFO, dp) < 0)
		err(4, "DIOCGDINFO");

	if (dp->d_magic != DISKMAGIC || dp->d_magic2 != DISKMAGIC
		/* dkcksum(lp) != 0 */ ) {
		errx(1, "bad pack magic number (pack is unlabeled)");
	}
	if (dp->d_secsize > MAXSECSIZE || dp->d_secsize <= 0) {
		errx(7, "Disk sector size too large/small (%d)",
			dp->d_secsize);
	}
	if (dp->d_type == DTYPE_SCSI) {
		errx(1, "SCSI disks don't need bad144!");
	}
#ifdef __i386__
	/* are we inside a DOS partition? */
	if (dp->d_partitions[0].p_offset) {
		/* yes, rules change. assume bad tables at end of partition C,
		   which maps all of DOS partition we are within -wfj */
		size = dp->d_partitions[2].p_offset + dp->d_partitions[2].p_size;
	} else
#endif
	size = dp->d_nsectors * dp->d_ntracks * dp->d_ncylinders; 

	argc--;
	argv++;
	if (argc == 0) {
		sn = getold(f, &oldbad);
		printf("bad block information at sector %d in %s:\n",
		    sn, name);
		printf("cartridge serial number: %d(10)\n", oldbad.bt_csn);
		switch (oldbad.bt_flag) {

		case (u_short)-1:
			printf("alignment cartridge\n");
			break;

		case DKBAD_MAGIC:
			break;

		default:
			printf("bt_flag=%x(16)?\n", oldbad.bt_flag);
			break;
		}
		bt = oldbad.bt_bad;
		for (i = 0; i < NBT_BAD; i++) {
			bad = (bt->bt_cyl<<16) + bt->bt_trksec;
			if (bad < 0)
				break;
			printf("sn=%d, cn=%d, tn=%d, sn=%d\n", badsn(bt),
			    bt->bt_cyl, bt->bt_trksec>>8, bt->bt_trksec&0xff);
			bt++;
		}
		(void) checkold();
		exit(0);
	}
	if (add) {
		/*
		 * Read in the old badsector table.
		 * Verify that it makes sense, and the bad sectors
		 * are in order.  Copy the old table to the new one.
		 */
		(void) getold(f, &oldbad);
		i = checkold();
		if (verbose)
			printf("Had %d bad sectors, adding %d\n", i, argc);
		if (i + argc > NBT_BAD) {
			errx(1, "not enough room for %d more sectors, "
			    "limited to %d by information format",
			    argc, NBT_BAD);
		}
		curbad = oldbad;
	} else {
		curbad.bt_csn = strtol(*argv++, NULL, 10);
		argc--;
		curbad.bt_mbz = 0;
		curbad.bt_flag = DKBAD_MAGIC;
		if (argc > NBT_BAD) {
			errx(1, "too many bad sectors specified, "
			   "limited to %d by information format",
			    NBT_BAD);
		}
		i = 0;
	}
	errs = 0;
	new = argc;
	while (argc > 0) {
		daddr_t sn = atoi(*argv++);
		argc--;
		if (sn < 0 || sn >= size) {
			printf("%d: out of range [0,%d) for disk %s\n",
			    sn, size, dp->d_typename);
			errs++;
			continue;
		}
		bn[i] = sn;
		curbad.bt_bad[i].bt_cyl = sn / (dp->d_nsectors*dp->d_ntracks);
		sn %= (dp->d_nsectors*dp->d_ntracks);
		curbad.bt_bad[i].bt_trksec =
		    ((sn/dp->d_nsectors) << 8) + (sn%dp->d_nsectors);
		i++;
	}
	if (errs)
		exit(1);
	nbad = i;
	while (i < NBT_BAD) {
		curbad.bt_bad[i].bt_trksec = -1;
		curbad.bt_bad[i].bt_cyl = -1;
		i++;
	}
	if (add) {
		/*
		 * Sort the new bad sectors into the list.
		 * Then shuffle the replacement sectors so that
		 * the previous bad sectors get the same replacement data.
		 */
		qsort((char *)curbad.bt_bad, nbad, sizeof (struct bt_bad),
		    compare);
		if (dups) {
			errx(3, "bad sectors have been duplicated; "
			    "can't add existing sectors");
		}
		shift(f, nbad, nbad-new);
	}
	if (badfile == -1)
		i = 0;
	else
		i = badfile * 2;
	for (; i < 10 && i < dp->d_nsectors; i += 2) {
		if (lseek(f, dp->d_secsize * (size - dp->d_nsectors + i),
		    SEEK_SET) < 0)
			err(4, "lseek");
		if (verbose)
			printf("write badsect file at %d\n",
				size - dp->d_nsectors + i);
		if (nflag == 0 && write(f, (caddr_t)&curbad, sizeof(curbad)) !=
		    sizeof(curbad)) {
			warn("write bad sector file %d", i/2);
		}
		if (badfile != -1)
			break;
	}
#ifdef DIOCSBAD
	if (nflag == 0 && ioctl(f, DIOCSBAD, (caddr_t)&curbad) < 0) {
		warn("can't sync bad-sector file");
		warnx("reboot for changes to take effect");
	}
#endif
	if ((dp->d_flags & D_BADSECT) == 0 && nflag == 0) {
		dp->d_flags |= D_BADSECT;
		if (ioctl(f, DIOCWDINFO, dp) < 0) {
			err(1, "can't write label to enable bad sector handling");
		}
	}
	exit(0);
}

daddr_t
getold(int f, struct dkbad *bad)
{
	int i;
	daddr_t sn;

	if (badfile == -1)
		i = 0;
	else
		i = badfile * 2;
	for (; i < 10 && i < dp->d_nsectors; i += 2) {
		sn = size - dp->d_nsectors + i;
		if (lseek(f, sn * dp->d_secsize, SEEK_SET) < 0)
			err(4, "lseek");
		if (read(f, (char *) bad, dp->d_secsize) == dp->d_secsize) {
			if (i > 0)
				printf("Using bad-sector file %d\n", i/2);
			return(sn);
		}
		warn("read bad sector file at sn %d", sn);
		if (badfile != -1)
			break;
	}
	errx(1, "can't read bad block info from %s", name);
	/*NOTREACHED*/
}

int
checkold(void)
{
	int i;
	struct bt_bad *bt;
	daddr_t sn, lsn = 0;
	int errors = 0, warned = 0;

	if (oldbad.bt_flag != DKBAD_MAGIC) {
		warnx("bad flag in bad-sector table %s", name);
		errors++;
	}
	if (oldbad.bt_mbz != 0) {
		warnx("%s: bad magic number", name);
		errors++;
	}
	bt = oldbad.bt_bad;
	for (i = 0; i < NBT_BAD; i++, bt++) {
		if (bt->bt_cyl == 0xffff && bt->bt_trksec == 0xffff)
			break;
		if ((bt->bt_cyl >= dp->d_ncylinders) ||
		    ((bt->bt_trksec >> 8) >= dp->d_ntracks) ||
		    ((bt->bt_trksec & 0xff) >= dp->d_nsectors)) {
			warnx("cyl/trk/sect out of range in existing entry: "
			    "sn=%d, cn=%d, tn=%d, sn=%d",
				badsn(bt), bt->bt_cyl, bt->bt_trksec>>8,
				bt->bt_trksec & 0xff);
			errors++;
		}
		sn = (bt->bt_cyl * dp->d_ntracks +
		    (bt->bt_trksec >> 8)) *
		    dp->d_nsectors + (bt->bt_trksec & 0xff);
		if (i > 0 && sn < lsn && !warned) {
		    warnx("bad sector file is out of order");
		    errors++;
		    warned++;
		}
		if (i > 0 && sn == lsn) {
		    warnx("bad sector file contains duplicates (sn %d)",
			sn);
		    errors++;
		}
		lsn = sn;
	}
	if (errors)
		exit(1);
	return (i);
}

/*
 * Move the bad sector replacements
 * to make room for the new bad sectors.
 * new is the new number of bad sectors, old is the previous count.
 */
void
shift(int f, int new, int old)
{
	daddr_t repl;

	/*
	 * First replacement is last sector of second-to-last track.
	 */
	repl = size - dp->d_nsectors - 1;
	new--; old--;
	while (new >= 0 && new != old) {
		if (old < 0 ||
		    compare(&curbad.bt_bad[new], &oldbad.bt_bad[old]) > 0) {
			/*
			 * Insert new replacement here-- copy original
			 * sector if requested and possible,
			 * otherwise write a zero block.
			 */
			if (!copy ||
			    !blkcopy(f, badsn(&curbad.bt_bad[new]), repl - new))
				blkzero(f, repl - new);
		} else {
			if (blkcopy(f, repl - old, repl - new) == 0)
			    fprintf(stderr,
				"Can't copy replacement sector %d to %d\n",
				repl-old, repl-new);
			old--;
		}
		new--;
	}
}

char *buf;

/*
 *  Copy disk sector s1 to s2.
 */
int
blkcopy(int f, daddr_t s1, daddr_t s2)
{
	int tries, n;

	if (buf == NULL) {
		buf = malloc((unsigned)dp->d_secsize);
		if (buf == NULL) {
			err(20, NULL);
		}
	}
	for (tries = 0; tries < RETRIES; tries++) {
		if (lseek(f, dp->d_secsize * s1, SEEK_SET) < 0)
			err(4, "lseek");
		if ((n = read(f, buf, dp->d_secsize)) == dp->d_secsize)
			break;
	}
	if (n != dp->d_secsize) {
		warnx("can't read sector %d", s1);
		return(0);
	}
	if (lseek(f, dp->d_secsize * s2, SEEK_SET) < 0)
		err(4, "lseek");
	if (verbose)
		printf("copying %d to %d\n", s1, s2);
	if (nflag == 0 && write(f, buf, dp->d_secsize) != dp->d_secsize) {
		warn("can't write replacement sector %d", s2);
		return(0);
	}
	return(1);
}

char *zbuf;

void
blkzero(int f, daddr_t sn)
{

	if (zbuf == NULL) {
		zbuf = malloc((unsigned)dp->d_secsize);
		if (zbuf == NULL) {
			err(20, NULL);
		}
	}
	if (lseek(f, dp->d_secsize * sn, SEEK_SET) < 0)
		err(4, "lseek");
	if (verbose)
		printf("zeroing %d\n", sn);
	if (nflag == 0 && write(f, zbuf, dp->d_secsize) != dp->d_secsize) {
		warn("can't write replacement sector %d", sn);
	}
}

int
compare(const void *v1, const void *v2)
{
	const struct bt_bad *b1 = v1, *b2 = v2;

	if (b1->bt_cyl > b2->bt_cyl)
		return(1);
	if (b1->bt_cyl < b2->bt_cyl)
		return(-1);
	if (b1->bt_trksec == b2->bt_trksec)
		dups++;
	return (b1->bt_trksec - b2->bt_trksec);
}

daddr_t
badsn(const struct bt_bad *bt)
{
	return ((bt->bt_cyl*dp->d_ntracks + (bt->bt_trksec>>8)) * dp->d_nsectors
		+ (bt->bt_trksec&0xff));
}

#ifdef vax

struct rp06hdr {
	short	h_cyl;
	short	h_trksec;
	short	h_key1;
	short	h_key2;
	char	h_data[512];
#define	RP06_FMT	010000		/* 1 == 16 bit, 0 == 18 bit */
};

/*
 * Most massbus and unibus drives
 * have headers of this form
 */
struct hpuphdr {
	u_short	hpup_cyl;
	u_char	hpup_sect;
	u_char	hpup_track;
	char	hpup_data[512];
#define	HPUP_OKSECT	0xc000		/* this normally means sector is good */
#define	HPUP_16BIT	0x1000		/* 1 == 16 bit format */
};
int rp06format(), hpupformat();

struct	formats {
	char	*f_name;		/* disk name */
	int	f_bufsize;		/* size of sector + header */
	int	f_bic;			/* value to bic in hpup_cyl */
	int	(*f_routine)();		/* routine for special handling */
} formats[] = {
	{ "rp06",	sizeof (struct rp06hdr), RP06_FMT,	rp06format },
	{ "eagle",	sizeof (struct hpuphdr), HPUP_OKSECT,	hpupformat },
	{ "capricorn",	sizeof (struct hpuphdr), HPUP_OKSECT,	hpupformat },
	{ "rm03",	sizeof (struct hpuphdr), HPUP_OKSECT,	hpupformat },
	{ "rm05",	sizeof (struct hpuphdr), HPUP_OKSECT,	hpupformat },
	{ "9300",	sizeof (struct hpuphdr), HPUP_OKSECT,	hpupformat },
	{ "9766",	sizeof (struct hpuphdr), HPUP_OKSECT,	hpupformat },
	{ 0, 0, 0, 0 }
};

/*ARGSUSED*/
hpupformat(struct formats *fp, struct disklabel *dp, daddr_t blk,
    char *buf, int count)
{
	struct hpuphdr *hdr = (struct hpuphdr *)buf;
	int sect;

	if (count < sizeof(struct hpuphdr)) {
		hdr->hpup_cyl = (HPUP_OKSECT | HPUP_16BIT) |
			(blk / (dp->d_nsectors * dp->d_ntracks));
		sect = blk % (dp->d_nsectors * dp->d_ntracks);
		hdr->hpup_track = (u_char)(sect / dp->d_nsectors);
		hdr->hpup_sect = (u_char)(sect % dp->d_nsectors);
	}
	return (0);
}

/*ARGSUSED*/
rp06format(struct formats *fp, struct disklabel *dp, daddr_t blk,
    char *buf, int count)
{

	if (count < sizeof(struct rp06hdr)) {
		fprintf(stderr, "Can't read header on blk %d, can't reformat\n",
			blk);
		return (-1);
	}
	return (0);
}

format(int fd, daddr_t blk)
{
	struct formats *fp;
	static char *buf;
	static char bufsize;
	struct format_op fop;
	int n;

	for (fp = formats; fp->f_name; fp++)
		if (strcmp(dp->d_typename, fp->f_name) == 0)
			break;
	if (fp->f_name == 0) {
		fprintf(stderr, "bad144: don't know how to format %s disks\n",
			dp->d_typename);
		exit(2);
	}
	if (buf && bufsize < fp->f_bufsize) {
		free(buf);
		buf = NULL;
	}
	if (buf == NULL)
		buf = malloc((unsigned)fp->f_bufsize);
	if (buf == NULL) {
		fprintf(stderr, "bad144: can't allocate sector buffer\n");
		exit(3);
	}
	bufsize = fp->f_bufsize;
	/*
	 * Here we do the actual formatting.  All we really
	 * do is rewrite the sector header and flag the bad sector
	 * according to the format table description.  If a special
	 * purpose format routine is specified, we allow it to
	 * process the sector as well.
	 */
	if (verbose)
		printf("format blk %d\n", blk);
	bzero((char *)&fop, sizeof(fop));
	fop.df_buf = buf;
	fop.df_count = fp->f_bufsize;
	fop.df_startblk = blk;
	bzero(buf, fp->f_bufsize);
	if (ioctl(fd, DIOCRFORMAT, &fop) < 0)
		perror("bad144: read format");
	if (fp->f_routine &&
	    (*fp->f_routine)(fp, dp, blk, buf, fop.df_count) != 0)
		return;
	if (fp->f_bic) {
		struct hpuphdr *xp = (struct hpuphdr *)buf;

		xp->hpup_cyl &= ~fp->f_bic;
	}
	if (nflag)
		return;
	bzero((char *)&fop, sizeof(fop));
	fop.df_buf = buf;
	fop.df_count = fp->f_bufsize;
	fop.df_startblk = blk;
	if (ioctl(fd, DIOCWFORMAT, &fop) < 0)
		Perror("write format");
	if (fop.df_count != fp->f_bufsize) {
		char msg[80];
		(void)snprintf(msg, sizeof msg,
		    "bad144: write format %d", blk);
		perror(msg);
	}
}
#endif

void
usage(void)
{
	fprintf(stderr,
		  "usage: bad144 [-c] [-n] [-v] disk [snum [bn ...]]\n");
	fprintf(stderr,
	      "to read or overwrite bad-sector table, e.g.: bad144 hp0\n");
	fprintf(stderr,
		  "or bad144 -a [-c] [-n] [-v] disk [bn ...]\n");
	fprintf(stderr, "where options are:\n");
	fprintf(stderr, "\t-a  add new bad sectors to the table\n");
	fprintf(stderr, "\t-c  copy original sector to replacement\n");
	fprintf(stderr, "\t-n  make no permanent changes\n");
	fprintf(stderr, "\t-v  be verbose\n");
	exit(1);
}
@


1.18
log
@Fix scoping error on DIOCSBAD ioctl failure condition.

miod@@, otto@@, henning@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: bad144.c,v 1.17 2003/06/26 22:11:01 deraadt Exp $	*/
d39 1
a39 1
static char *rcsid = "$Id: bad144.c,v 1.17 2003/06/26 22:11:01 deraadt Exp $";
@


1.17
log
@ansi
@
text
@d1 1
a1 1
/*	$OpenBSD: bad144.c,v 1.16 2003/06/02 23:36:52 millert Exp $	*/
d39 1
a39 1
static char *rcsid = "$Id: bad144.c,v 1.16 2003/06/02 23:36:52 millert Exp $";
d284 1
a284 1
	if (nflag == 0 && ioctl(f, DIOCSBAD, (caddr_t)&curbad) < 0)
d287 1
@


1.16
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: bad144.c,v 1.15 2003/03/14 14:53:45 jmc Exp $	*/
d39 1
a39 1
static char *rcsid = "$Id: bad144.c,v 1.15 2003/03/14 14:53:45 jmc Exp $";
d95 1
a95 3
main(argc, argv)
	int argc;
	char *argv[];
d298 1
a298 3
getold(f, bad)
	int f;
	struct dkbad *bad;
d325 1
a325 1
checkold()
d379 1
a379 2
shift(f, new, old)
	int f, new, old;
d416 1
a416 3
blkcopy(f, s1, s2)
	int f;
	daddr_t s1, s2;
d450 1
a450 3
blkzero(f, sn)
	int f;
	daddr_t sn;
d469 1
a469 2
compare(v1, v2)
	const void *v1, *v2;
d483 1
a483 2
badsn(bt)
	const struct bt_bad *bt;
d531 2
a532 6
hpupformat(fp, dp, blk, buf, count)
	struct formats *fp;
	struct disklabel *dp;
	daddr_t blk;
	char *buf;
	int count;
d548 2
a549 6
rp06format(fp, dp, blk, buf, count)
	struct formats *fp;
	struct disklabel *dp;
	daddr_t blk;
	char *buf;
	int count;
d560 1
a560 3
format(fd, blk)
	int fd;
	daddr_t blk;
d629 1
a629 1
usage()
@


1.15
log
@document the -n flag (dry-run)
remove info about non-existent -f flag
update usage()

fixes PR 2541;

checked by tedu - thanks. i owe you a favor :)
ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bad144.c,v 1.14 2002/06/10 00:40:53 miod Exp $	*/
d14 1
a14 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d39 1
a39 1
static char *rcsid = "$Id: bad144.c,v 1.14 2002/06/10 00:40:53 miod Exp $";
@


1.14
log
@Switch to modern (post 4.xBSD) world, with changes lying in my tree for a
lot of time:
- use getopt()
- use err() and warn()
- NBT_BAD instead of 126
- remove the vax-only parts since this is only build on i386. They can
come back later whenever necessary.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d43 1
a43 1
static char *rcsid = "$Id: bad144.c,v 1.13 2002/06/09 02:38:11 itojun Exp $";
d657 1
a657 1
		  "usage: bad144 disk [ snum [ bn ... ] ]\n");
d661 1
a661 1
		  "or bad144 -a [ -c ] disk  bn ...\n");
d665 2
@


1.13
log
@strlcpy fix, PR 2727
@
text
@d1 1
d43 1
a43 1
static char *rcsid = "$Id: bad144.c,v 1.12 2002/05/29 09:47:20 deraadt Exp $";
d72 1
d76 1
a76 1
int	fflag, add, copy, verbose, nflag;
d96 1
d104 2
a105 2
	daddr_t	sn, bn[126];
	int i, f, nbad, new, bad, errs;
d107 22
a128 47
	argc--, argv++;
	while (argc > 0 && **argv == '-') {
		(*argv)++;
		while (**argv) {
			switch (**argv) {
#if __vax__
			    case 'f':
				fflag++;
				break;
#endif
			    case 'a':
				add++;
				break;
			    case 'c':
				copy++;
				break;
			    case 'v':
				verbose++;
				break;
			    case 'n':
				nflag++;
				verbose++;
				break;
			    default:
				if (**argv >= '0' && **argv <= '4') {
					badfile = **argv - '0';
					break;
				}
				goto usage;
			}
			(*argv)++;
		}
		argc--, argv++;
	}
	if (argc < 1) {
usage:
		fprintf(stderr,
		  "usage: bad144 [ -f ] disk [ snum [ bn ... ] ]\n");
		fprintf(stderr,
	      "to read or overwrite bad-sector table, e.g.: bad144 hp0\n");
		fprintf(stderr,
		  "or bad144 -a [ -f ] [ -c ] disk  bn ...\n");
		fprintf(stderr, "where options are:\n");
		fprintf(stderr, "\t-a  add new bad sectors to the table\n");
		fprintf(stderr, "\t-f  reformat listed sectors as bad\n");
		fprintf(stderr, "\t-c  copy original sector to replacement\n");
		exit(1);
d130 6
d143 2
a144 11
		Perror(name);
#ifdef was
	if (read(f, label, sizeof(label)) < 0) 
		Perror("read");
	for (dp = (struct disklabel *)(label + LABELOFFSET);
	    dp < (struct disklabel *)
		(label + sizeof(label) - sizeof(struct disklabel));
	    dp = (struct disklabel *)((char *)dp + 64))
		if (dp->d_magic == DISKMAGIC && dp->d_magic2 == DISKMAGIC)
			break;
#else
d148 2
a149 2
		Perror("ioctl DIOCGDINFO");
#endif
d152 1
a152 2
		fprintf(stderr, "Bad pack magic number (pack is unlabeled)\n");
		exit(1);
d155 1
a155 1
		fprintf(stderr, "Disk sector size too large/small (%d)\n",
a156 1
		exit(7);
a157 1
#ifdef __i386__
d159 1
a159 2
		fprintf(stderr, "SCSI disks don't use bad144!\n");
		exit(1);
d161 1
d170 1
d192 1
a192 1
		for (i = 0; i < 126; i++) {
d213 4
a216 5
		if (i + argc > 126) {
			printf("bad144: not enough room for %d more sectors\n",
				argc);
			printf("limited to 126 by information format\n");
			exit(1);
d220 1
a220 1
		curbad.bt_csn = atoi(*argv++);
d224 4
a227 4
		if (argc > 126) {
			printf("bad144: too many bad sectors specified\n");
			printf("limited to 126 by information format\n");
			exit(1);
d252 1
a252 1
	while (i < 126) {
d266 2
a267 3
			fprintf(stderr,
"bad144: bad sectors have been duplicated; can't add existing sectors\n");
			exit(3);
d278 1
a278 1
			Perror("lseek");
d284 1
a284 5
			char msg[80];
			(void)snprintf(msg, sizeof msg,
			    "bad144: write bad sector file %d",
			    i/2);
			perror(msg);
a288 5
#ifdef vax
	if (nflag == 0 && fflag)
		for (i = nbad - new; i < nbad; i++)
			format(f, bn[i]);
#endif
d291 2
a292 2
		fprintf(stderr,
	"Can't sync bad-sector file; reboot for changes to take effect\n");
d297 1
a297 3
			perror("label");
			fprintf(stderr, "Can't write label to enable bad sector handling\n");
			exit(1);
d305 2
a306 1
struct dkbad *bad;
a309 1
	char msg[80];
d318 1
a318 1
			Perror("lseek");
d324 1
a324 3
		(void)snprintf(msg, sizeof msg,
		    "bad144: read bad sector file at sn %d", sn);
		perror(msg);
d328 1
a328 2
	fprintf(stderr, "bad144: %s: can't read bad block info\n", name);
	exit(1);
d341 1
a341 2
		fprintf(stderr, "bad144: %s: bad flag in bad-sector table\n",
			name);
d345 1
a345 1
		fprintf(stderr, "bad144: %s: bad magic number\n", name);
d349 1
a349 1
	for (i = 0; i < 126; i++, bt++) {
d355 2
a356 3
			fprintf(stderr,
		     "bad144: cyl/trk/sect out of range in existing entry: ");
			fprintf(stderr, "sn=%d, cn=%d, tn=%d, sn=%d\n",
d365 1
a365 2
		    fprintf(stderr,
			"bad144: bad sector file is out of order\n");
d370 1
a370 2
		    fprintf(stderr,
			"bad144: bad sector file contains duplicates (sn %d)\n",
d388 1
d426 2
a427 1
daddr_t s1, s2;
d431 1
a431 1
	if (buf == (char *)NULL) {
d433 2
a434 3
		if (buf == (char *)NULL) {
			fprintf(stderr, "Out of memory\n");
			exit(20);
d439 1
a439 1
			Perror("lseek");
d444 1
a444 3
		fprintf(stderr, "bad144: can't read sector, %d: ", s1);
		if (n < 0)
			perror((char *)0);
d448 1
a448 1
		Perror("lseek");
d452 1
a452 3
		fprintf(stderr,
		    "bad144: can't write replacement sector, %d: ", s2);
		perror((char *)0);
d462 2
a463 1
daddr_t sn;
d466 1
a466 1
	if (zbuf == (char *)NULL) {
d468 2
a469 3
		if (zbuf == (char *)NULL) {
			fprintf(stderr, "Out of memory\n");
			exit(20);
d473 1
a473 1
		Perror("lseek");
d477 1
a477 3
		fprintf(stderr,
		    "bad144: can't write replacement sector, %d: ", sn);
		perror((char *)0);
d654 1
a654 2
Perror(op)
	const char *op;
d656 10
a665 3
	fprintf(stderr, "bad144: ");
	perror(op);
	exit(4);
@


1.12
log
@more snprintf
@
text
@d42 1
a42 1
static char *rcsid = "$Id: bad144.c,v 1.11 2002/03/14 16:44:24 mpech Exp $";
d156 1
a156 1
		strlcpy(name, argv[0], MAXPATHLEN);
@


1.11
log
@kill more registers.

millert@@ ok
@
text
@d42 1
a42 1
static char *rcsid = "$Id: bad144.c,v 1.10 2002/02/16 21:28:01 millert Exp $";
d314 2
a315 1
			(void)sprintf(msg, "bad144: write bad sector file %d",
d364 2
a365 1
		(void)sprintf(msg, "bad144: read bad sector file at sn %d", sn);
d698 2
a699 1
		(void)sprintf(msg, "bad144: write format %d", blk);
@


1.10
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d42 1
a42 1
static char *rcsid = "$Id: bad144.c,v 1.9 2001/08/12 12:03:03 heko Exp $";
d100 1
a100 1
	register struct bt_bad *bt;
d346 1
a346 1
	register int i;
d376 2
a377 2
	register int i;
	register struct bt_bad *bt;
d472 1
a472 1
	register int tries, n;
d637 1
a637 1
	register struct formats *fp;
@


1.9
log
@#(endif|else) foo is incorrect, make it #endif /* foo */
deraadt@@ ok
@
text
@d42 1
a42 1
static char *rcsid = "$Id: bad144.c,v 1.8 2001/07/02 16:51:46 jasoni Exp $";
d86 8
a93 8
void	Perror __P((const char *));
daddr_t	badsn __P((const struct bt_bad *));
int	blkcopy __P((int, daddr_t, daddr_t));
void	blkzero __P((int, daddr_t));
int	checkold __P((void));
int	compare __P((const void *, const void *));
daddr_t	getold __P((int, struct dkbad *));
void	shift __P((int, int, int));
@


1.8
log
@-Wall cleanup; ok millert@@
@
text
@d38 1
a38 1
#endif not lint
d42 2
a43 2
static char *rcsid = "$Id: bad144.c,v 1.7 2000/12/09 14:51:03 deraadt Exp $";
#endif not lint
@


1.7
log
@avoid buf oflow; belu@@kriton.org
@
text
@d42 1
a42 1
static char *rcsid = "$Id: bad144.c,v 1.6 1999/12/05 06:32:47 deraadt Exp $";
d70 1
d472 1
a472 1
	register tries, n;
@


1.6
log
@oflow
@
text
@d42 1
a42 1
static char *rcsid = "$Id: bad144.c,v 1.5 1999/06/16 10:23:17 espie Exp $";
d152 2
a153 2
		(void)sprintf(name, "%sr%s%c", _PATH_DEV, argv[0],
		    'a' + RAW_PART);
@


1.5
log
@i386
@
text
@d42 1
a42 1
static char *rcsid = "$Id: bad144.c,v 1.4 1998/07/13 02:11:45 millert Exp $";
d155 1
a155 1
		strcpy(name, argv[0]);
@


1.4
log
@ftpd: sleep for an indeterminate amount for non-existant logins
      to simulate a crypt, like login does.
Use SEEK_* not L_* and kill some 0L's used in lseek while we're there.
@
text
@d42 1
a42 1
static char *rcsid = "$Id: bad144.c,v 1.3 1997/07/27 02:33:35 deraadt Exp $";
d108 1
a108 1
#if vax
d184 1
a184 1
#ifdef i386
@


1.3
log
@use RAW_PART
@
text
@d42 1
a42 1
static char *rcsid = "$Id: bad144.c,v 1.2 1997/06/29 07:15:29 deraadt Exp $";
d305 1
a305 1
		    L_SET) < 0)
d355 1
a355 1
		if (lseek(f, sn * dp->d_secsize, L_SET) < 0)
d481 1
a481 1
		if (lseek(f, dp->d_secsize * s1, L_SET) < 0)
d492 1
a492 1
	if (lseek(f, dp->d_secsize * s2, L_SET) < 0)
d519 1
a519 1
	if (lseek(f, dp->d_secsize * sn, L_SET) < 0)
@


1.2
log
@Wall, in part from mikel
@
text
@d42 1
a42 1
static char *rcsid = "$Id: bad144.c,v 1.1.1.1 1995/10/18 08:47:25 deraadt Exp $";
a71 5
#ifdef i386 /* XXX */
#define	RAWPART	"d"		/* disk partition containing badsector tables */
#else
#define	RAWPART	"c"		/* disk partition containing badsector tables */
#endif
d152 2
a153 1
		(void)sprintf(name, "%sr%s%s", _PATH_DEV, argv[0], RAWPART);
@


1.1
log
@Initial revision
@
text
@d42 1
a42 1
static char *rcsid = "$Id: bad144.c,v 1.8 1995/06/10 21:01:08 mycroft Exp $";
d66 2
a78 1
int	compare();
d86 1
a86 1
daddr_t	size, getold(), badsn();
a88 2
char	*malloc();
off_t	lseek();
d90 10
d230 1
a230 1
		(void) checkold(&oldbad);
d240 1
a240 1
		i = checkold(&oldbad);
d376 1
d381 1
a381 1
	daddr_t sn, lsn;
d434 1
d471 1
d511 1
d534 3
a536 2
compare(b1, b2)
register struct bt_bad *b1, *b2;
d538 2
d551 1
a551 1
register struct bt_bad *bt;
d705 1
d707 1
a707 1
	char *op;
d709 2
a710 2

	fprintf(stderr, "bad144: "); perror(op);
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
