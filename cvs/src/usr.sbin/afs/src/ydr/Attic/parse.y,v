head	1.6;
access;
symbols
	OPENBSD_5_2:1.5.0.38
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.36
	OPENBSD_5_0:1.5.0.34
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.32
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.30
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.26
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.5.0.28
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.5.0.24
	OPENBSD_4_5_BASE:1.5
	OPENBSD_4_4:1.5.0.22
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3:1.5.0.20
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.5.0.18
	OPENBSD_4_2_BASE:1.5
	OPENBSD_4_1:1.5.0.16
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.5.0.14
	OPENBSD_4_0_BASE:1.5
	OPENBSD_3_9:1.5.0.12
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.5.0.10
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.8
	OPENBSD_3_7_BASE:1.5
	OPENBSD_3_6:1.5.0.6
	OPENBSD_3_6_BASE:1.5
	OPENBSD_3_5:1.5.0.4
	OPENBSD_3_5_BASE:1.5
	OPENBSD_3_4:1.5.0.2
	OPENBSD_3_4_BASE:1.5
	arla-20030805:1.1.1.3
	OPENBSD_3_3:1.4.0.4
	OPENBSD_3_3_BASE:1.4
	OPENBSD_3_2:1.4.0.2
	OPENBSD_3_2_BASE:1.4
	arla-0-35-7:1.1.1.2
	OPENBSD_3_1:1.3.0.8
	OPENBSD_3_1_BASE:1.3
	OPENBSD_3_0:1.3.0.6
	OPENBSD_3_0_BASE:1.3
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_9:1.3.0.4
	OPENBSD_2_8:1.3.0.2
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.2.0.4
	OPENBSD_2_7_BASE:1.2
	OPENBSD_2_6:1.2.0.2
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.1.1.1.0.4
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.2
	OPENBSD_2_4_BASE:1.1.1.1
	arla-0_9:1.1.1.1
	arla:1.1.1;
locks; strict;
comment	@ * @;


1.6
date	2012.08.23.06.21.56;	author deraadt;	state dead;
branches;
next	1.5;

1.5
date	2003.08.05.09.16.16;	author hin;	state Exp;
branches;
next	1.4;

1.4
date	2002.06.07.04.45.57;	author hin;	state Exp;
branches;
next	1.3;

1.3
date	2000.09.11.14.41.41;	author art;	state Exp;
branches;
next	1.2;

1.2
date	99.04.30.01.59.19;	author art;	state Exp;
branches;
next	1.1;

1.1
date	98.09.14.21.53.27;	author art;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.09.14.21.53.27;	author art;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.06.07.04.14.38;	author hin;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2003.08.05.08.21.08;	author hin;	state Exp;
branches;
next	;


desc
@@


1.6
log
@the afs src tree can go away
@
text
@/*
 * Copyright (c) 1995, 1996, 1997, 1998, 1999 Kungliga Tekniska Högskolan
 * (Royal Institute of Technology, Stockholm, Sweden).
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

%{
#ifdef HAVE_CONFIG_H
#include <config.h>
RCSID("$arla: parse.y,v 1.28 2003/01/20 07:12:58 lha Exp $");
#endif

#include <stdio.h>
#include <list.h>
#include <bool.h>
#include <roken.h>
#include "sym.h"
#include "types.h"
#include "output.h"
#include "lex.h"

void yyerror (char *);
static int varcnt = 0;

%}

%union {
     int constant;
     Symbol *sym;
     List *list;
     char *name;
     Type *type;
     StructEntry *sentry;
     Argument *arg;
     Bool bool;
     unsigned flags;
}

%token T_ENUM T_STRUCT T_CONST T_UNSIGNED T_ULONG T_INT T_CHAR T_STRING
%token T_LONG T_TYPEDEF T_OPAQUE T_IN T_OUT T_INOUT T_SPLIT T_MULTI
%token T_SHORT T_USHORT T_UCHAR T_ASIS T_PROC
%token T_LONGLONG T_ULONGLONG
%token <name> T_IDENTIFIER T_VERBATIM T_PACKAGE T_PREFIX T_ERROR_FUNCTION
%token <constant> T_CONSTANT
%token <sym> T_IDCONST T_IDTYPE

%type <constant> constant opt_constant opt_proc
%type <constant> param_type
%type <sym> enumentry type_decl proc_decl
%type <list> enumentries enumbody structbody memberdecls params attrs
%type <type> type
%type <sentry> memberdecl memberdecl2
%type <arg> param
%type <flags> flags
%type <name> attr

%start specification

%%

specification:	
		| specification declaration
		| specification directive
		| error ';'
		;

declaration:	type_decl { 
                 if (!sym_find_attr($1, "__nogenerate__")) {
     		     generate_header ($1, headerfile.stream);
		     generate_sizeof ($1, headerfile.stream);
		     generate_function ($1, ydrfile.stream, TRUE);
		     generate_function_prototype ($1, headerfile.stream, TRUE);
		     generate_function ($1, ydrfile.stream, FALSE);
		     generate_function_prototype ($1, headerfile.stream, FALSE);
		     generate_printfunction ($1, ydrfile.stream);
		     generate_printfunction_prototype ($1, headerfile.stream);
		     generate_freefunction ($1, ydrfile.stream);
		     generate_freefunction_prototype ($1, headerfile.stream);
		 }
		}
		| proc_decl { 
		     generate_client_stub ($1, clientfile.stream,
					   clienthdrfile.stream);
		     generate_server_stub ($1, serverfile.stream,
					   serverhdrfile.stream,
					   headerfile.stream);
		}
		;

type_decl	: T_ENUM T_IDENTIFIER enumbody ';'
		{ $$ = define_enum ($2, $3); varcnt = 0; }
		| T_STRUCT T_IDENTIFIER { define_struct($2); } structbody attrs ';'
		{ $$ = set_struct_body ($2, $4);
		  set_sym_attrs($$, $5); }
		| T_STRUCT type structbody attrs';'
		{ if($2->symbol && $2->symbol->type != YDR_TSTRUCT)
		    error_message (1, "%s is not a struct\n",
				   $2->symbol->name);
		  $$ = set_struct_body_sym ($2->symbol, $3);
		  set_sym_attrs($2->symbol, $4);
		}
		| T_TYPEDEF memberdecl ';'
		{ $$ = define_typedef ($2); }
		| T_CONST T_IDENTIFIER '=' constant ';'
		{ $$ = define_const ($2, $4);  }
		;

flags:		{ $$ = TSIMPLE; }
		| T_SPLIT { $$ = TSPLIT; }
		| T_MULTI { $$ = TSPLIT | TSIMPLE | TMULTI; }
		;

opt_proc:	{ $$ = 0; }/* empty */
		| T_PROC { $$ = 0; }
		;

proc_decl:	opt_proc T_IDENTIFIER '(' params ')' flags '=' constant ';'
		{ $$ = (Symbol *)emalloc(sizeof(Symbol));
	          $$->type = YDR_TPROC;
	          $$->name = $2;
		  $$->u.proc.package = package;
		  $$->u.proc.arguments = $4;
		  $$->u.proc.id = $8;
		  $$->u.proc.flags = $6; 
	          }
		;

params:		{ $$ = listnew(); }
		| param { $$ = listnew(); listaddhead ($$, $1); }
		| params ',' param
		{ listaddtail ($1, $3); $$ = $1; }
		;

param:		param_type memberdecl
		{ $$ = (Argument *)emalloc(sizeof(Argument));
		  $$->argtype = $1;
		  $$->name = $2->name;
		  $$->type = $2->type;
		  free($2); }
		;

param_type:	T_IN    { $$ = TIN; }
		| T_OUT { $$ = TOUT; }
		| T_INOUT { $$ = TINOUT; }
		| { $$ = TIN; }
		;

directive:	T_PACKAGE T_IDENTIFIER
		{ package = estrdup($2); 
		  listaddtail (packagelist, package);
		}
		| T_PREFIX T_IDENTIFIER
		{ prefix = $2; }
		| T_VERBATIM
		{ fprintf (headerfile.stream, "%s\n", $1); }
		| T_ERROR_FUNCTION T_IDENTIFIER
		{ error_function = $2; }
		;

enumbody:	'{' enumentries '}' { $$ = $2; }
		;

enumentries:	{ $$ = listnew ();  }
		| enumentry
		{ $$ = listnew(); listaddhead ($$, $1); }
		| enumentries ',' enumentry
		{ listaddtail ($1, $3); $$ = $1;}
		;

enumentry:	T_IDENTIFIER '=' constant
 		{ $$ = createenumentry ($1, $3); varcnt = $3 + 1; }
  		| T_IDENTIFIER
  		{ $$ = createenumentry ($1, varcnt++); }
  		;

memberdecl:	T_ASIS memberdecl2
		{ $$ = $2; $$->type->flags |= TASIS; }  
		| memberdecl2
		{ $$ = $1; }
		;  

memberdecl2:	type T_IDENTIFIER
		{ $$ = createstructentry ($2, $1); }
		| T_STRING T_IDENTIFIER '<' opt_constant '>'
		{ Type *t  = create_type (YDR_TSTRING, NULL, $4, NULL, NULL,0);
		  $$ = createstructentry ($2, t);
		}
		| T_STRING T_IDENTIFIER
		{ Type *t  = create_type (YDR_TSTRING, NULL, 0, NULL, NULL, 0);
		  $$ = createstructentry ($2, t);
		}
		| type T_IDENTIFIER '[' opt_constant ']' 
		{ Type *t  = create_type (YDR_TARRAY, NULL, $4, $1, NULL, 0);
		  $$ = createstructentry ($2, t); }
		| type T_IDENTIFIER '<' opt_constant '>'
		{ Type *t  = create_type (YDR_TVARRAY, NULL, $4, $1, NULL, 0);
		  $$ = createstructentry ($2, t); }
		| type T_IDENTIFIER '<' type '>'
		{ Type *t  = create_type (YDR_TVARRAY, NULL, 0, $1, $4, 0);
		  $$ = createstructentry ($2, t); }
		;

type:		long_or_int
                { $$ = create_type (YDR_TLONG, NULL, 0, NULL, NULL, 0); }
		| T_UNSIGNED
                { $$ = create_type (YDR_TULONG, NULL, 0, NULL, NULL, 0); }
		| T_ULONG
                { $$ = create_type (YDR_TULONG, NULL, 0, NULL, NULL, 0); }
		| T_UNSIGNED T_LONG
                { $$ = create_type (YDR_TULONG, NULL, 0, NULL, NULL, 0); }
		| T_LONGLONG
                { $$ = create_type (YDR_TLONGLONG, NULL, 0, NULL, NULL, 0); }
		| T_ULONGLONG
                { $$ = create_type (YDR_TULONGLONG, NULL, 0, NULL, NULL, 0); }
		| T_CHAR
                { $$ = create_type (YDR_TCHAR, NULL, 0, NULL, NULL, 0); }
		| T_UCHAR
                { $$ = create_type (YDR_TUCHAR, NULL, 0, NULL, NULL, 0); }
		| T_UNSIGNED T_CHAR
                { $$ = create_type (YDR_TUCHAR, NULL, 0, NULL, NULL, 0); }
		| T_SHORT
                { $$ = create_type (YDR_TSHORT, NULL, 0, NULL, NULL, 0); }
		| T_USHORT
                { $$ = create_type (YDR_TUSHORT, NULL, 0, NULL, NULL, 0); }
		| T_UNSIGNED T_SHORT
                { $$ = create_type (YDR_TUSHORT, NULL, 0, NULL, NULL, 0); }
		| T_STRING
                { $$ = create_type (YDR_TSTRING, NULL, 0, NULL, NULL, 0); }
		| T_OPAQUE
                { $$ = create_type (YDR_TOPAQUE, NULL, 0, NULL, NULL, 0); }
		| type '*'
                { $$ = create_type (YDR_TPOINTER, NULL, 0, $1, NULL, 0); }
		| T_IDTYPE
                { $$ = create_type (YDR_TUSERDEF, $1, 0, NULL, NULL, 0);
		  if ($$->symbol->type != YDR_TSTRUCT 
		      && $$->symbol->type != YDR_TENUM
		      && $$->symbol->type != YDR_TTYPEDEF)
		       error_message (1, "%s used as a type\n",
				      $$->symbol->name);
	        }
		| T_STRUCT type
		{
		    $$ = $2;
		    if ($$->symbol && $$->symbol->type != YDR_TSTRUCT)
			error_message (1, "%s is not a struct\n",
				       $$->symbol->name);
		}
		| T_STRUCT T_IDENTIFIER
                {   $$ = create_type (YDR_TUSERDEF, define_struct($2), 0, NULL,
				      NULL, 0); 
                }
		;

long_or_int:	T_LONG
		| T_INT
		;

memberdecls:	{ $$ = listnew(); }
		| memberdecls memberdecl ';'
		{ listaddtail ($1, $2); $$ = $1; }
		;

structbody:	'{' memberdecls '}' { $$ = $2; }
		;

opt_constant:	  { $$ = 0; }
		| constant { $$ = $1; }
		;

constant:	T_CONSTANT { $$ = $1; }
		| T_IDCONST
		{ Symbol *s = $1;
		  if (s->type != YDR_TCONST) {
		       error_message (1, "%s not a constant\n", s->name);
		  } else
		       $$ = s->u.val;
	        }
		;
		  
attrs:		{ $$ = listnew(); }
		| attr { $$ = listnew(); listaddhead ($$, $1); }
		| attrs attr
		{ listaddtail ($1, $2); $$ = $1; }
		;

attr:		T_IDENTIFIER '(' '(' T_IDENTIFIER ')' ')'
		{ $$ = $4; 
		  if (strcmp($1, "__attribute__") != 0)
		     error_message(1, "%s isn't __attribute__"); }
		;
%%

void
yyerror (char *s)
{
     error_message (1, "%s\n", s);
}
@


1.5
log
@Merge
@
text
@@


1.4
log
@merge
@
text
@d37 1
a37 1
RCSID("$KTH: parse.y,v 1.24 2000/10/02 22:36:59 lha Exp $");
d69 1
d77 1
a77 1
%type <list> enumentries enumbody structbody memberdecls params
d82 1
d95 1
d104 3
a113 1
		     generate_tcpdump_stub ($1, td_file.stream);
d119 5
a123 4
		| T_STRUCT T_IDENTIFIER { define_struct($2); } structbody ';'
		{ $$ = set_struct_body ($2, $4); }
		| T_STRUCT type structbody ';'
		{ if($2->symbol && $2->symbol->type != TSTRUCT)
d127 1
d146 1
a146 1
	          $$->type = TPROC;
d212 1
a212 1
		{ Type *t  = create_type (TSTRING, NULL, $4, NULL, NULL, 0);
d216 1
a216 1
		{ Type *t  = create_type (TSTRING, NULL, 0, NULL, NULL, 0);
d220 1
a220 1
		{ Type *t  = create_type (TARRAY, NULL, $4, $1, NULL, 0);
d223 1
a223 1
		{ Type *t  = create_type (TVARRAY, NULL, $4, $1, NULL, 0);
d226 1
a226 1
		{ Type *t  = create_type (TVARRAY, NULL, 0, $1, $4, 0);
d231 1
a231 1
                { $$ = create_type (TLONG, NULL, 0, NULL, NULL, 0); }
d233 1
a233 1
                { $$ = create_type (TULONG, NULL, 0, NULL, NULL, 0); }
d235 1
a235 1
                { $$ = create_type (TULONG, NULL, 0, NULL, NULL, 0); }
d237 5
a241 1
                { $$ = create_type (TULONG, NULL, 0, NULL, NULL, 0); }
d243 1
a243 1
                { $$ = create_type (TCHAR, NULL, 0, NULL, NULL, 0); }
d245 1
a245 1
                { $$ = create_type (TUCHAR, NULL, 0, NULL, NULL, 0); }
d247 1
a247 1
                { $$ = create_type (TUCHAR, NULL, 0, NULL, NULL, 0); }
d249 1
a249 1
                { $$ = create_type (TSHORT, NULL, 0, NULL, NULL, 0); }
d251 1
a251 1
                { $$ = create_type (TUSHORT, NULL, 0, NULL, NULL, 0); }
d253 1
a253 1
                { $$ = create_type (TUSHORT, NULL, 0, NULL, NULL, 0); }
d255 1
a255 1
                { $$ = create_type (TSTRING, NULL, 0, NULL, NULL, 0); }
d257 1
a257 1
                { $$ = create_type (TOPAQUE, NULL, 0, NULL, NULL, 0); }
d259 1
a259 1
                { $$ = create_type (TPOINTER, NULL, 0, $1, NULL, 0); }
d261 4
a264 4
                { $$ = create_type (TUSERDEF, $1, 0, NULL, NULL, 0);
		  if ($$->symbol->type != TSTRUCT 
		      && $$->symbol->type != TENUM
		      && $$->symbol->type != TTYPEDEF)
d271 1
a271 1
		    if ($$->symbol && $$->symbol->type != TSTRUCT)
d276 1
a276 1
                {   $$ = create_type (TUSERDEF, define_struct($2), 0, NULL,
d300 1
a300 1
		  if (s->type != TCONST) {
d304 2
a305 1
	     }
d307 11
@


1.3
log
@New Arla userland from Arla between 0.34.2 and current in arla cvs.
Too many new features and fixes to mention here.
@
text
@d17 1
a17 6
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by the Kungliga Tekniska
 *      Högskolan and its contributors.
 * 
 * 4. Neither the name of the Institute nor the names of its contributors
d37 1
a37 1
RCSID("$Id: parse.y,v 1.23 2000/01/18 23:37:23 lha Exp $");
@


1.2
log
@upgrade Arla to fresher code. Too many new features and bugfixes.
@
text
@d42 1
a42 1
RCSID("$Id: parse.y,v 1.19 1999/03/19 06:07:11 lha Exp $");
d55 1
d118 1
a118 1
		{ $$ = define_enum ($2, $3); }
d146 1
d174 3
a176 1
		{ package = $2; }
d188 1
a188 1
enumentries:	{ $$ = listnew (); }
d196 4
a199 2
		{ $$ = createenumentry ($1, $3); }
		;
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
 * Copyright (c) 1995, 1996, 1997, 1998 Kungliga Tekniska Högskolan
d42 1
a42 1
RCSID("$Id: parse.y,v 1.8 1998/09/06 23:33:39 assar Exp $");
d48 1
a48 1
#include <mem.h>
d72 2
a73 2
%token T_SHORT T_USHORT T_UCHAR T_ASIS
%token <name> T_IDENTIFIER T_VERBATIM T_PACKAGE
d77 1
a77 1
%type <constant> constant opt_constant
d97 8
a104 6
     		     generate_header ($1, headerfile);
		     generate_sizeof ($1, headerfile);
		     generate_function ($1, ydrfile, TRUE);
		     generate_function_prototype ($1, headerfile, TRUE);
		     generate_function ($1, ydrfile, FALSE);
		     generate_function_prototype ($1, headerfile, FALSE);
d107 6
a112 2
		     generate_client_stub ($1, clientfile, clienthdrfile);
		     generate_server_stub ($1, serverfile, serverhdrfile);
d120 6
d134 5
a138 1
		| T_MULTI { $$ = TSPLIT | TSIMPLE; }
d141 1
a141 1
proc_decl:	T_IDENTIFIER '(' params ')' flags '=' constant ';'
d144 4
a147 4
	          $$->name = $1;
		  $$->u.proc.arguments = $3;
		  $$->u.proc.id = $7;
		  $$->u.proc.flags = $5; 
d168 1
d173 2
d176 3
a178 1
		{ fprintf (headerfile, "%s\n", $1); }
d203 3
a205 3
		| T_STRUCT type T_IDENTIFIER
		{
		    $$ = createstructentry ($3, $2);
d207 2
a208 5
		| T_STRING T_IDENTIFIER '<' opt_constant '>'
		{ Type *t  = (Type *)emalloc (sizeof(Type));
		  t->type  = TSTRING;
		  t->size  = $4;
		  t->flags = 0;
d212 1
a212 5
		{ Type *t    = (Type *)emalloc(sizeof(Type));
		  t->type    = TARRAY;
		  t->size    = $4;
		  t->subtype = $1;
		  t->flags   = 0;
d215 1
a215 6
		{ Type *t      = (Type *)emalloc(sizeof(Type));
		  t->type      = TVARRAY;
		  t->size      = $4;
		  t->subtype   = $1;
		  t->indextype = NULL;
		  t->flags     = 0;
d218 1
a218 6
		{ Type *t      = (Type *)emalloc(sizeof(Type));
		  t->type      = TVARRAY;
		  t->size      = 0;
		  t->subtype   = $1;
		  t->indextype = $4;
		  t->flags     = 0;
d223 1
a223 3
		{ $$ = (Type *)emalloc(sizeof(Type)); 
		  $$->type  = TLONG;
		  $$->flags = 0; }
d225 1
a225 3
		{ $$ = (Type *)emalloc(sizeof(Type)); 
		  $$->type  = TULONG;
		  $$->flags = 0; }
d227 1
a227 3
		{ $$ = (Type *)emalloc(sizeof(Type)); 
		  $$->type  = TULONG;
		  $$->flags = 0; }
d229 1
a229 3
		{ $$ = (Type *)emalloc(sizeof(Type)); 
		  $$->type  = TULONG;
		  $$->flags = 0; }
d231 1
a231 3
		{ $$ = (Type *)emalloc(sizeof(Type)); 
		  $$->type  = TCHAR;
		  $$->flags = 0; }
d233 1
a233 3
		{ $$ = (Type *)emalloc(sizeof(Type)); 
		  $$->type  = TUCHAR;
		  $$->flags = 0; }
d235 1
a235 3
		{ $$ = (Type *)emalloc(sizeof(Type)); 
		  $$->type  = TUCHAR;
		  $$->flags = 0; }
d237 1
a237 3
		{ $$ = (Type *)emalloc(sizeof(Type)); 
		  $$->type  = TSHORT;
		  $$->flags = 0; }
d239 1
a239 3
		{ $$ = (Type *)emalloc(sizeof(Type)); 
		  $$->type  = TUSHORT;
		  $$->flags = 0; }
d241 1
a241 3
		{ $$ = (Type *)emalloc(sizeof(Type)); 
		  $$->type  = TUSHORT;
		  $$->flags = 0; }
d243 1
a243 3
		{ $$ = (Type *)emalloc(sizeof(Type)); 
		  $$->type  = TSTRING;
		  $$->flags = 0; }
d245 1
a245 3
		{ $$ = (Type *)emalloc(sizeof(Type)); 
		  $$->type  = TOPAQUE;
		  $$->flags = 0; }
d247 1
a247 4
		{ $$ = (Type *)emalloc(sizeof(Type)); 
		  $$->type = TPOINTER; 
		  $$->subtype = $1;
		  $$->flags = 0; }
d249 1
a249 4
		{ $$ = (Type *)emalloc(sizeof(Type)); 
		  $$->type   = TUSERDEF;
		  $$->symbol = $1; 
		  $$->flags  = 0;
d253 2
a254 1
		       error_message ("%s used as a type\n", $$->symbol->name);
d256 11
d289 1
a289 1
		       error_message ("%s not a constant\n", s->name);
d299 1
a299 1
     error_message ("%s\n", s);
@


1.1.1.1
log
@Initial version of Arla, a free implementation of an AFS cache-manager.
(second try, hopefully into the correct repository this time)
@
text
@@


1.1.1.2
log
@Import of arla-0.35.7
@
text
@d2 1
a2 1
 * Copyright (c) 1995, 1996, 1997, 1998, 1999 Kungliga Tekniska Högskolan
d17 6
a22 1
 * 3. Neither the name of the Institute nor the names of its contributors
d42 1
a42 1
RCSID("$KTH: parse.y,v 1.24 2000/10/02 22:36:59 lha Exp $");
d48 1
a48 1
#include <roken.h>
a54 1
static int varcnt = 0;
d72 2
a73 2
%token T_SHORT T_USHORT T_UCHAR T_ASIS T_PROC
%token <name> T_IDENTIFIER T_VERBATIM T_PACKAGE T_PREFIX T_ERROR_FUNCTION
d77 1
a77 1
%type <constant> constant opt_constant opt_proc
d97 6
a102 8
     		     generate_header ($1, headerfile.stream);
		     generate_sizeof ($1, headerfile.stream);
		     generate_function ($1, ydrfile.stream, TRUE);
		     generate_function_prototype ($1, headerfile.stream, TRUE);
		     generate_function ($1, ydrfile.stream, FALSE);
		     generate_function_prototype ($1, headerfile.stream, FALSE);
		     generate_printfunction ($1, ydrfile.stream);
		     generate_printfunction_prototype ($1, headerfile.stream);
d105 2
a106 6
		     generate_client_stub ($1, clientfile.stream,
					   clienthdrfile.stream);
		     generate_server_stub ($1, serverfile.stream,
					   serverhdrfile.stream,
					   headerfile.stream);
		     generate_tcpdump_stub ($1, td_file.stream);
d111 1
a111 1
		{ $$ = define_enum ($2, $3); varcnt = 0; }
a113 6
		| T_STRUCT type structbody ';'
		{ if($2->symbol && $2->symbol->type != TSTRUCT)
		    error_message (1, "%s is not a struct\n",
				   $2->symbol->name);
		  $$ = set_struct_body_sym ($2->symbol, $3);
		}
d122 1
a122 5
		| T_MULTI { $$ = TSPLIT | TSIMPLE | TMULTI; }
		;

opt_proc:	{ $$ = 0; }/* empty */
		| T_PROC { $$ = 0; }
d125 1
a125 1
proc_decl:	opt_proc T_IDENTIFIER '(' params ')' flags '=' constant ';'
d128 4
a131 5
	          $$->name = $2;
		  $$->u.proc.package = package;
		  $$->u.proc.arguments = $4;
		  $$->u.proc.id = $8;
		  $$->u.proc.flags = $6; 
a151 1
		| { $$ = TIN; }
d155 1
a155 5
		{ package = estrdup($2); 
		  listaddtail (packagelist, package);
		}
		| T_PREFIX T_IDENTIFIER
		{ prefix = $2; }
d157 1
a157 3
		{ fprintf (headerfile.stream, "%s\n", $1); }
		| T_ERROR_FUNCTION T_IDENTIFIER
		{ error_function = $2; }
d163 1
a163 1
enumentries:	{ $$ = listnew ();  }
d171 2
a172 4
 		{ $$ = createenumentry ($1, $3); varcnt = $3 + 1; }
  		| T_IDENTIFIER
  		{ $$ = createenumentry ($1, varcnt++); }
  		;
d182 4
d187 4
a190 5
		{ Type *t  = create_type (TSTRING, NULL, $4, NULL, NULL, 0);
		  $$ = createstructentry ($2, t);
		}
		| T_STRING T_IDENTIFIER
		{ Type *t  = create_type (TSTRING, NULL, 0, NULL, NULL, 0);
d194 5
a198 1
		{ Type *t  = create_type (TARRAY, NULL, $4, $1, NULL, 0);
d201 6
a206 1
		{ Type *t  = create_type (TVARRAY, NULL, $4, $1, NULL, 0);
d209 6
a214 1
		{ Type *t  = create_type (TVARRAY, NULL, 0, $1, $4, 0);
d219 3
a221 1
                { $$ = create_type (TLONG, NULL, 0, NULL, NULL, 0); }
d223 3
a225 1
                { $$ = create_type (TULONG, NULL, 0, NULL, NULL, 0); }
d227 3
a229 1
                { $$ = create_type (TULONG, NULL, 0, NULL, NULL, 0); }
d231 3
a233 1
                { $$ = create_type (TULONG, NULL, 0, NULL, NULL, 0); }
d235 3
a237 1
                { $$ = create_type (TCHAR, NULL, 0, NULL, NULL, 0); }
d239 3
a241 1
                { $$ = create_type (TUCHAR, NULL, 0, NULL, NULL, 0); }
d243 3
a245 1
                { $$ = create_type (TUCHAR, NULL, 0, NULL, NULL, 0); }
d247 3
a249 1
                { $$ = create_type (TSHORT, NULL, 0, NULL, NULL, 0); }
d251 3
a253 1
                { $$ = create_type (TUSHORT, NULL, 0, NULL, NULL, 0); }
d255 3
a257 1
                { $$ = create_type (TUSHORT, NULL, 0, NULL, NULL, 0); }
d259 3
a261 1
                { $$ = create_type (TSTRING, NULL, 0, NULL, NULL, 0); }
d263 3
a265 1
                { $$ = create_type (TOPAQUE, NULL, 0, NULL, NULL, 0); }
d267 4
a270 1
                { $$ = create_type (TPOINTER, NULL, 0, $1, NULL, 0); }
d272 4
a275 1
                { $$ = create_type (TUSERDEF, $1, 0, NULL, NULL, 0);
d279 1
a279 2
		       error_message (1, "%s used as a type\n",
				      $$->symbol->name);
a280 11
		| T_STRUCT type
		{
		    $$ = $2;
		    if ($$->symbol && $$->symbol->type != TSTRUCT)
			error_message (1, "%s is not a struct\n",
				       $$->symbol->name);
		}
		| T_STRUCT T_IDENTIFIER
                {   $$ = create_type (TUSERDEF, define_struct($2), 0, NULL,
				      NULL, 0); 
                }
d303 1
a303 1
		       error_message (1, "%s not a constant\n", s->name);
d313 1
a313 1
     error_message (1, "%s\n", s);
@


1.1.1.3
log
@Import of arla -current as of Aug 5 2003

ok todd@@ deraadt@@
@
text
@d37 1
a37 1
RCSID("$arla: parse.y,v 1.28 2003/01/20 07:12:58 lha Exp $");
a68 1
%token T_LONGLONG T_ULONGLONG
d76 1
a76 1
%type <list> enumentries enumbody structbody memberdecls params attrs
a80 1
%type <name> attr
a92 1
                 if (!sym_find_attr($1, "__nogenerate__")) {
a100 3
		     generate_freefunction ($1, ydrfile.stream);
		     generate_freefunction_prototype ($1, headerfile.stream);
		 }
d108 1
d114 4
a117 5
		| T_STRUCT T_IDENTIFIER { define_struct($2); } structbody attrs ';'
		{ $$ = set_struct_body ($2, $4);
		  set_sym_attrs($$, $5); }
		| T_STRUCT type structbody attrs';'
		{ if($2->symbol && $2->symbol->type != YDR_TSTRUCT)
a120 1
		  set_sym_attrs($2->symbol, $4);
d139 1
a139 1
	          $$->type = YDR_TPROC;
d205 1
a205 1
		{ Type *t  = create_type (YDR_TSTRING, NULL, $4, NULL, NULL,0);
d209 1
a209 1
		{ Type *t  = create_type (YDR_TSTRING, NULL, 0, NULL, NULL, 0);
d213 1
a213 1
		{ Type *t  = create_type (YDR_TARRAY, NULL, $4, $1, NULL, 0);
d216 1
a216 1
		{ Type *t  = create_type (YDR_TVARRAY, NULL, $4, $1, NULL, 0);
d219 1
a219 1
		{ Type *t  = create_type (YDR_TVARRAY, NULL, 0, $1, $4, 0);
d224 1
a224 1
                { $$ = create_type (YDR_TLONG, NULL, 0, NULL, NULL, 0); }
d226 1
a226 1
                { $$ = create_type (YDR_TULONG, NULL, 0, NULL, NULL, 0); }
d228 1
a228 1
                { $$ = create_type (YDR_TULONG, NULL, 0, NULL, NULL, 0); }
d230 1
a230 5
                { $$ = create_type (YDR_TULONG, NULL, 0, NULL, NULL, 0); }
		| T_LONGLONG
                { $$ = create_type (YDR_TLONGLONG, NULL, 0, NULL, NULL, 0); }
		| T_ULONGLONG
                { $$ = create_type (YDR_TULONGLONG, NULL, 0, NULL, NULL, 0); }
d232 1
a232 1
                { $$ = create_type (YDR_TCHAR, NULL, 0, NULL, NULL, 0); }
d234 1
a234 1
                { $$ = create_type (YDR_TUCHAR, NULL, 0, NULL, NULL, 0); }
d236 1
a236 1
                { $$ = create_type (YDR_TUCHAR, NULL, 0, NULL, NULL, 0); }
d238 1
a238 1
                { $$ = create_type (YDR_TSHORT, NULL, 0, NULL, NULL, 0); }
d240 1
a240 1
                { $$ = create_type (YDR_TUSHORT, NULL, 0, NULL, NULL, 0); }
d242 1
a242 1
                { $$ = create_type (YDR_TUSHORT, NULL, 0, NULL, NULL, 0); }
d244 1
a244 1
                { $$ = create_type (YDR_TSTRING, NULL, 0, NULL, NULL, 0); }
d246 1
a246 1
                { $$ = create_type (YDR_TOPAQUE, NULL, 0, NULL, NULL, 0); }
d248 1
a248 1
                { $$ = create_type (YDR_TPOINTER, NULL, 0, $1, NULL, 0); }
d250 4
a253 4
                { $$ = create_type (YDR_TUSERDEF, $1, 0, NULL, NULL, 0);
		  if ($$->symbol->type != YDR_TSTRUCT 
		      && $$->symbol->type != YDR_TENUM
		      && $$->symbol->type != YDR_TTYPEDEF)
d260 1
a260 1
		    if ($$->symbol && $$->symbol->type != YDR_TSTRUCT)
d265 1
a265 1
                {   $$ = create_type (YDR_TUSERDEF, define_struct($2), 0, NULL,
d289 1
a289 1
		  if (s->type != YDR_TCONST) {
d293 1
a293 2
	        }
		;
a294 11
attrs:		{ $$ = listnew(); }
		| attr { $$ = listnew(); listaddhead ($$, $1); }
		| attrs attr
		{ listaddtail ($1, $2); $$ = $1; }
		;

attr:		T_IDENTIFIER '(' '(' T_IDENTIFIER ')' ')'
		{ $$ = $4; 
		  if (strcmp($1, "__attribute__") != 0)
		     error_message(1, "%s isn't __attribute__"); }
		;
@


