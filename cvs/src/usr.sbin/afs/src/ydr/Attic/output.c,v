head	1.12;
access;
symbols
	OPENBSD_5_2:1.11.0.36
	OPENBSD_5_2_BASE:1.11
	OPENBSD_5_1_BASE:1.11
	OPENBSD_5_1:1.11.0.34
	OPENBSD_5_0:1.11.0.32
	OPENBSD_5_0_BASE:1.11
	OPENBSD_4_9:1.11.0.30
	OPENBSD_4_9_BASE:1.11
	OPENBSD_4_8:1.11.0.28
	OPENBSD_4_8_BASE:1.11
	OPENBSD_4_7:1.11.0.24
	OPENBSD_4_7_BASE:1.11
	OPENBSD_4_6:1.11.0.26
	OPENBSD_4_6_BASE:1.11
	OPENBSD_4_5:1.11.0.22
	OPENBSD_4_5_BASE:1.11
	OPENBSD_4_4:1.11.0.20
	OPENBSD_4_4_BASE:1.11
	OPENBSD_4_3:1.11.0.18
	OPENBSD_4_3_BASE:1.11
	OPENBSD_4_2:1.11.0.16
	OPENBSD_4_2_BASE:1.11
	OPENBSD_4_1:1.11.0.14
	OPENBSD_4_1_BASE:1.11
	OPENBSD_4_0:1.11.0.12
	OPENBSD_4_0_BASE:1.11
	OPENBSD_3_9:1.11.0.10
	OPENBSD_3_9_BASE:1.11
	OPENBSD_3_8:1.11.0.8
	OPENBSD_3_8_BASE:1.11
	OPENBSD_3_7:1.11.0.6
	OPENBSD_3_7_BASE:1.11
	OPENBSD_3_6:1.11.0.4
	OPENBSD_3_6_BASE:1.11
	OPENBSD_3_5:1.11.0.2
	OPENBSD_3_5_BASE:1.11
	OPENBSD_3_4:1.10.0.2
	OPENBSD_3_4_BASE:1.10
	arla-20030805:1.1.1.3
	OPENBSD_3_3:1.4.0.4
	OPENBSD_3_3_BASE:1.4
	OPENBSD_3_2:1.4.0.2
	OPENBSD_3_2_BASE:1.4
	arla-0-35-7:1.1.1.2
	OPENBSD_3_1:1.3.0.8
	OPENBSD_3_1_BASE:1.3
	OPENBSD_3_0:1.3.0.6
	OPENBSD_3_0_BASE:1.3
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_9:1.3.0.4
	OPENBSD_2_8:1.3.0.2
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.2.0.4
	OPENBSD_2_7_BASE:1.2
	OPENBSD_2_6:1.2.0.2
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.1.1.1.0.4
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.2
	OPENBSD_2_4_BASE:1.1.1.1
	arla-0_9:1.1.1.1
	arla:1.1.1;
locks; strict;
comment	@ * @;


1.12
date	2012.08.23.06.21.56;	author deraadt;	state dead;
branches;
next	1.11;

1.11
date	2003.12.16.20.13.56;	author beck;	state Exp;
branches;
next	1.10;

1.10
date	2003.08.05.11.05.13;	author hin;	state Exp;
branches;
next	1.9;

1.9
date	2003.08.05.09.16.16;	author hin;	state Exp;
branches;
next	1.8;

1.8
date	2003.07.02.00.41.15;	author avsm;	state Exp;
branches;
next	1.7;

1.7
date	2003.05.08.19.57.49;	author vincent;	state Exp;
branches;
next	1.6;

1.6
date	2003.04.20.14.59.29;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2003.04.06.19.09.05;	author pvalchev;	state Exp;
branches;
next	1.4;

1.4
date	2002.06.07.04.45.57;	author hin;	state Exp;
branches;
next	1.3;

1.3
date	2000.09.11.14.41.41;	author art;	state Exp;
branches;
next	1.2;

1.2
date	99.04.30.01.59.19;	author art;	state Exp;
branches;
next	1.1;

1.1
date	98.09.14.21.53.26;	author art;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.09.14.21.53.26;	author art;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.06.07.04.14.38;	author hin;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2003.08.05.08.21.08;	author hin;	state Exp;
branches;
next	;


desc
@@


1.12
log
@the afs src tree can go away
@
text
@/*
 * Copyright (c) 1995 - 2002 Kungliga Tekniska Högskolan
 * (Royal Institute of Technology, Stockholm, Sweden).
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#ifdef HAVE_CONFIG_H
#include <config.h>
RCSID("$arla: output.c,v 1.91 2003/04/16 09:07:03 lha Exp $");
#endif

#include <stdio.h>
#include <assert.h>
#include <string.h>
#include <list.h>
#include <ctype.h>
#include <err.h>
#include <roken.h>
#include "sym.h"
#include "output.h"
#include "types.h"
#include "lex.h"

/*
 * The name of the current package that we're generating stubs for
 */

char *package = "";

/*
 * This is the list of packages so we know how to generate
 * all Execute_package().
 */

List *packagelist = NULL;

/*
 * Add this in front of the real functions implementing the server
 * functions called.
 */

char *prefix = "";

/*
 * File handles for the generated files themselves.
 */

ydr_file headerfile,
    clientfile,
    serverfile,
    clienthdrfile,
    serverhdrfile,
    ydrfile;

static long tmpcnt = 0;

/*
 * Function to convert error codes with.
 * (the default, the empty string, conveniently means no conversion.)
 */

char *error_function = "";

typedef enum { ENCODE_RX, DECODE_RX, ENCODE_MEM, DECODE_MEM } EncodeType;

typedef enum { CLIENT, SERVER } Side;

typedef enum { FDECL, VDECL } DeclType;

static void print_type (char *name, Type *type, enum argtype argtype, 
			DeclType decl, FILE *f);
static Bool print_entry (List *list, Listitem *item, void *i);
static void generate_hdr_struct (Symbol *s, FILE *f);
static void generate_hdr_enum (Symbol *s, FILE *f);
static void generate_hdr_const (Symbol *s, FILE *f);
static void generate_hdr_typedef (Symbol *s, FILE *f);
static int sizeof_type (Type *type);
static int sizeof_symbol (Symbol *);
static void encode_type (char *name, Type *type, FILE *f, 
			 EncodeType encodetype, Side side);
static void display_type (char *where, char *name, Type *type, FILE *f);
static Bool encode_entry (List *list, Listitem *item, void *arg);
static void encode_struct (Symbol *s, char *name, FILE *f, 
			   EncodeType encodetype, Side side);
static void encode_enum (Symbol *s, char *name, FILE *f,
			 EncodeType encodetype, Side side);
static void encode_typedef (Symbol *s, char *name, FILE *f, 
			    EncodeType encodetype, Side side);
static void encode_symbol (Symbol *s, char *name, FILE *f, 
			   EncodeType encodetype, Side side);
static void print_symbol (char *where, Symbol *s, char *name, FILE *f);
static void free_symbol (char *where, Symbol *s, char *name, FILE *f);
static void free_type (char *where, char *name, Type *type, FILE *f);

static void
print_type (char *name, Type *type, enum argtype argtype, 
	    DeclType decl, FILE *f)
{
     switch (type->type) {
	  case YDR_TCHAR :
	       fprintf (f, "char %s", name);
	       break;
	  case YDR_TUCHAR :
	       fprintf (f, "unsigned char %s", name);
	       break;
	  case YDR_TSHORT :
	       fprintf (f, "int16_t %s", name);
	       break;
	  case YDR_TUSHORT :
	       fprintf (f, "uint16_t %s", name);
	       break;
	  case YDR_TLONG :
	       fprintf (f, "int32_t %s", name);
	       break;
	  case YDR_TULONG :
	       fprintf (f, "uint32_t %s", name);
	       break;
	  case YDR_TLONGLONG:
	       fprintf (f, "int64_t %s", name);
	       break;
	  case YDR_TULONGLONG:
	       fprintf (f, "uint64_t %s", name);
	       break;
	  case YDR_TSTRING :
	       if (type->size && decl == VDECL)
		   fprintf (f, "char %s[%d]", name, type->size);
	       else if (argtype != TIN && type->size == 0)
		   fprintf (f, "char **%s", name);
	       else
		   fprintf (f, "char *%s", name);
	       break;
	  case YDR_TPOINTER :
	  {
	       char *tmp;
	       size_t len = strlen(name) + 2;

	       tmp = (char *)emalloc (len);
	       *tmp = '*';
	       strlcpy (tmp+1, name, len - 1);
	       print_type (tmp, type->subtype, argtype, decl, f);
	       free (tmp);
	       break;
	  }
	  case YDR_TUSERDEF : 
	       if(type->symbol->type == YDR_TSTRUCT)
		    fprintf (f, "struct %s %s", type->symbol->name, name);
	       else
		    fprintf (f, "%s %s", type->symbol->name, name);
	       break;
	  case YDR_TVARRAY :
	  {
	       char *s;
	       size_t len = strlen (name) + 6;

	       s = (char *)emalloc (len);
	       *s = '*';
	       strlcpy (s + 1, name, len - 1);
	       strlcat (s, "_len", len);

	       fprintf (f, "struct {\n");
	       if (type->indextype)
		    print_type ("len", type->indextype, argtype, decl, f);
	       else
		    fprintf (f, "unsigned %s", "len");
	       fprintf (f, ";\n");
	       strlcpy(s + strlen(s) - 3, "val", len - strlen(s) + 3);
	       print_type ("*val", type->subtype, argtype, decl, f);
	       fprintf (f, ";\n} %s", name);
	       free(s);
	       break;
	  }
	  case YDR_TARRAY :
	       print_type (name, type->subtype, argtype, decl, f);
	       fprintf (f, "[ %d ]", type->size);
	       break;
	  case YDR_TOPAQUE :
	       fprintf (f, "char %s", name);
	       break;
	  default :
	       exit(-1);
     }
}

static Bool
print_entry (List *list, Listitem *item, void *i)
{
     StructEntry *s = (StructEntry *)listdata (item);
     FILE *f = (FILE *)i;

     fprintf (f, "     ");
     print_type (s->name, s->type, TIN, VDECL, f);
     fprintf (f, ";\n");
     return FALSE;
}

/*
 * Return the size of this type in bytes.
 * In the case of a variable-sized type, return -1 (unknown) or
 * the negative maxsize.
 */

static Bool
sizeof_struct_iter (List *list, Listitem *item, void *arg)
{
     int *tot = (int *)arg;
     StructEntry *s = (StructEntry *)listdata (item);
     int sz;

     sz = sizeof_type (s->type);
     if (sz == -1) {
	  *tot = -1;
	  return TRUE;
     } else if (sz < 0 || *tot < 0) {
	  *tot = -1 * (abs(*tot) + abs(sz));
	  return FALSE;
     } else {
	  *tot = *tot + sz;
	  return FALSE;
     }
}

static int
sizeof_struct (Symbol *s)
{
     int tot = 0;

     if (s->u.list)
	 listiter (s->u.list, sizeof_struct_iter, &tot);
     return tot;
}

static int
sizeof_type (Type *t)
{
     switch (t->type) {
     case YDR_TCHAR :
     case YDR_TUCHAR :
     case YDR_TSHORT :
     case YDR_TUSHORT :
     case YDR_TLONG :
     case YDR_TULONG :
	  return 4;
     case YDR_TLONGLONG :
     case YDR_TULONGLONG :
	  return 8;
     case YDR_TSTRING :
	 if (t->size == 0)
	     return -1;
	 else
	     return t->size;
     case YDR_TOPAQUE :
	  return 1;
     case YDR_TUSERDEF :
	  return sizeof_symbol (t->symbol);
     case YDR_TARRAY :
     {
	  int sz = sizeof_type (t->subtype);

	  if (sz == -1)
	       return -1;
	  return t->size * sz;
     }
     case YDR_TVARRAY :
     {
	 int sz;
	 if (t->size == 0)
	     return -1;
	 sz = sizeof_type(t->subtype);
	 if (sz == -1)
	     return -1;
	 return -1 * (t->size * abs(sz) + 4); /* 4 is size of the var part */
     }
     case YDR_TPOINTER :
	  return -1;
     default :
	  abort ();
     }
}

static int
sizeof_symbol (Symbol *s)
{
     switch (s->type) {
	  case YDR_TUNDEFINED :
	       fprintf (stderr, "What is %s doing in sizeof_type?", s->name);
	       return 0;
	  case YDR_TSTRUCT :
	       return sizeof_struct (s);
	  case YDR_TENUM :
	       return 4;
	  case YDR_TCONST :
	       return 0;
	  case YDR_TENUMVAL :
	       return 0;
	  case YDR_TTYPEDEF :
	       return sizeof_type (s->u.type);
	  default :
	       abort ();
     }
}

/*
 * Generate header contents
 */

static void
generate_hdr_struct (Symbol *s, FILE *f)
{
     fprintf (f, "struct %s {\n", s->name);
     if (s->u.list)
	 listiter (s->u.list, print_entry, f);
     fprintf (f, "};\ntypedef struct %s %s;\n", s->name, s->name);
}

static void
generate_hdr_enum (Symbol *s, FILE *f)
{
     Listitem *item;
     Symbol *e;

     fprintf (f, "enum %s {\n", s->name);
     if (s->u.list) {
	 for (item = listhead (s->u.list); 
	      item && listnext (s->u.list, item); 
	      item = listnext (s->u.list, item))
	 {
	     e = (Symbol *)listdata (item);
	     
	     fprintf (f, "     %s = %d,\n", e->name, e->u.val);	     
	 }
	 e = (Symbol *)listdata (item);
	 fprintf (f, "     %s = %d\n};\n", e->name, e->u.val);
     }
     fprintf (f, "typedef enum %s %s;\n",
	      s->name, s->name);
}

static void
generate_hdr_const (Symbol *s, FILE *f)
{
     fprintf (f, "#define %s %d\n", s->name, s->u.val);
}

static void
generate_hdr_typedef (Symbol *s, FILE *f)
{
     fprintf (f, "typedef ");
     print_type (s->name, s->u.type, TIN, VDECL, f);
     fprintf (f, ";\n");
}

void
generate_sizeof (Symbol *s, FILE *f)
{
     int sz;

     if (s->type == YDR_TCONST)
	 return;

     sz = sizeof_symbol (s);
     if (sz == -1) {
	 ; /* the size is unknown */
     } else {
	  char *name, *ms = "";
	  if (sz < 0)
	      ms = "MAX_";

	  name = estrdup (s->name);
	  fprintf (f, "#define %s_%sSIZE %d\n", strupr (name), ms, abs(sz));
	  free (name);
     }
}

void
generate_header (Symbol *s, FILE *f)
{
     switch (s->type) {
	  case YDR_TUNDEFINED :
	       fprintf (f, "What is %s doing in generate_header?", s->name);
	       break;
	  case YDR_TSTRUCT :
	       generate_hdr_struct (s, f);
	       break;
	  case YDR_TENUM :
	       generate_hdr_enum (s, f);
	       break;
	  case YDR_TCONST :
	       generate_hdr_const (s, f);
	       break;
	  case YDR_TENUMVAL :
	       break;
	  case YDR_TTYPEDEF :
	       generate_hdr_typedef (s, f);
	  default :
	       break;
     }
     putc ('\n', f);
}

/*
 * Generate functions for encoding and decoding.
 */

static char *
encode_function (Type *type, EncodeType encodetype)
{
     if (type->flags & TASIS)
	  return "";
     else if (encodetype == ENCODE_RX || encodetype == ENCODE_MEM) {
	 switch (type->type) {
	 case YDR_TLONGLONG:
	 case YDR_TULONGLONG:
	     return "htole64";
	 default:
	     return "htonl";
	     break;
	 }
     } else if (encodetype == DECODE_RX || encodetype == DECODE_MEM) {
	 switch (type->type) {
	 case YDR_TLONGLONG:
	 case YDR_TULONGLONG:
	     return "letoh64";
	 default:
	     return "ntohl";
	     break;
	 }
     } else
	  exit(-1);
}

/*
 * encode/decode long/longlong
 */

static void
encode_int_type (char *name, char *tname, Type *type, 
		 FILE *f, EncodeType encodetype)
{
     switch (encodetype) {
	  case ENCODE_RX :
	       fprintf (f, "{ u%s u;\n"
			"u = %s (%s);\n"
			"if(rx_Write(call, &u, sizeof(u)) != sizeof(u))\n"
			"goto fail;\n"
			"}\n",
			tname,
			encode_function (type, encodetype),
			name);
	       break;
	  case DECODE_RX :
	       fprintf (f, "{ u%s u;\n"
			"if(rx_Read(call, &u, sizeof(u)) != sizeof(u))\n"
			"goto fail;\n"
			"%s = %s (u);\n"
			"}\n", tname, name,
			encode_function (type, encodetype));
	       break;
	  case ENCODE_MEM :
	       fprintf (f, "{ %s tmp = %s(%s); "
			"if (*total_len < sizeof(tmp)) goto fail;\n"
			"memcpy (ptr, (char*)&tmp, sizeof(tmp)); "
			"ptr += sizeof(tmp); "
			"*total_len -= sizeof(tmp);}\n",
			tname,
			encode_function (type, encodetype),
			name);
	       break;
	  case DECODE_MEM :
	       fprintf (f, "{ %s tmp; "
			"if (*total_len < sizeof(tmp)) goto fail;"
			"memcpy ((char*)&tmp, ptr, sizeof(tmp)); "
			"%s = %s(tmp); "
			"ptr += sizeof(tmp); "
			"*total_len -= sizeof(tmp);}\n", 
			tname,
			name,
			encode_function (type, encodetype));
	       break;
	  default :
	       abort ();
     }
}

static void
encode_long (char *name, Type *type, FILE *f, EncodeType encodetype)
{
    encode_int_type(name, "int32_t", type, f, encodetype);
}

static void
encode_longlong (char *name, Type *type, FILE *f, EncodeType encodetype)
{
    encode_int_type(name, "int64_t", type, f, encodetype);
}

/*
 * print long
 */ 

static void
print_long (char *where, char *name, Type *type, FILE *f)
{
    fprintf (f, "printf(\" %s = %%d\", %s%s);", name, where, name);
}

/*
 * print longlong
 */ 

static void
print_longlong (char *where, char *name, Type *type, FILE *f)
{
    fprintf (f, "printf(\" %s = %%d\", (int32_t)%s%s);", name, where, name);
}

/*
 *
 */

static void
gen_check_overflow(Type *indextype, Type *subtype, char *num, FILE *f)
{
     /* Check if we will overflow */
     fprintf(f, "{\n");
     print_type ("overI", indextype, TIN, VDECL, f);
     fprintf(f, ";\n");
     fprintf(f, "overI = ((");
     print_type ("", indextype, TIN, VDECL, f);
     fprintf(f, ")~((");
     print_type ("", indextype, TIN, VDECL, f);
     fprintf(f, ")0) >> 1) / sizeof(");
     print_type ("", subtype, TIN, VDECL, f);
     fprintf(f, ");\n");
     fprintf(f, "if (overI < %s) goto fail;\n", num);
     fprintf(f, "}\n");
}

/*
 *
 */

static void __attribute__ ((unused))
encode_char (char *name, Type *type, FILE *f, EncodeType encodetype)
{
     switch (encodetype) {
	  case ENCODE_RX :
	       fprintf (f,
			"if(rx_Write(call, &%s, sizeof(%s)) != sizeof(%s))\n"
			"goto fail;\n",
			name, name, name);
	       break;
	  case DECODE_RX :
	       fprintf (f,
			"if(rx_Read(call, &%s, sizeof(%s)) != sizeof(%s))\n"
			"goto fail;\n",
			name, name, name);
	       break;
	  case ENCODE_MEM :
	       fprintf (f, "{ if (*total_len < sizeof(char)) goto fail;\n"
			"*((char *)ptr) = %s; "
			"ptr += sizeof(char); *total_len -= sizeof(char);}\n",
			name);
	       break;
	  case DECODE_MEM :
	       fprintf (f, "{ if (*total_len < sizeof(char)) goto fail;\n"
			"%s = *((char *)ptr); "
			"ptr += sizeof(char); *total_len -= sizeof(char);}\n",
			name);
	       break;
	  default :
	       abort ();
     }
}

static void __attribute__ ((unused))
encode_short (char *name, Type *type, FILE *f, EncodeType encodetype)
{
     switch (encodetype) {
	  case ENCODE_RX :
	       fprintf (f, "{ int16_t u;\n"
			"u = %s (%s);\n"
			"if(rx_Write(call, &u, sizeof(u)) != sizeof(u))\n"
			"goto fail;\n"
			"}\n", 
			encode_function (type, encodetype),
			name);
	       break;
	  case DECODE_RX :
	       fprintf (f, "{ int16_t u;\n"
			"if(rx_Read(call, &u, sizeof(u)) != sizeof(u))\n"
	                "goto fail;\n"
			"%s = %s (u);\n"
			"}\n", name,
			encode_function (type, encodetype));
	       break;
	  case ENCODE_MEM :
	  fprintf (f, "{ in16_t tmp = %s(%s); "
	  	      "if (*total_len < sizeof(int16_t)) goto fail;\n"
	              "memcpy (ptr, (char*)&tmp, sizeof(int16_t)); "
	              "ptr += sizeof(int16_t); "
	              "*total_len -= sizeof(int16_t);}\n", 
	                encode_function (type, encodetype),
			name);
	       break;
	  case DECODE_MEM :
	       fprintf (f, "{ int16_t tmp; "
			"if (*total_len < sizeof(int16_t)) goto fail;\n"
			"memcpy ((char *)&tmp, ptr, sizeof(int16_t)); "
			"%s = %s(tmp); "
			"ptr += sizeof(int16_t); "
			"*total_len -= sizeof(int16_t); }\n", 
			name,
			encode_function (type, encodetype));
	       break;
	  default :
	       abort ();
     }
}

/*
 * encode/decode TSTRING
 */

static void
encode_string (char *name, Type *type, FILE *f, EncodeType encodetype,
	       Side side)
{
     Type lentype = {YDR_TULONG};
     char *nname;

     asprintf (&nname, "(%s%s)",
	       ((type->size == 0) && side == CLIENT 
		&& (encodetype == ENCODE_RX || encodetype == ENCODE_MEM))
	       ? "*" : "", name);

     switch (encodetype) {
	  case ENCODE_RX :
	       fprintf (f, "{ unsigned len;\n"
			"char zero[4] = {0, 0, 0, 0};\n"
			"unsigned padlen;\n"
			"len = strlen(%s);\n"
			"padlen = (4 - (len %% 4)) %% 4;\n",
			name);
	       encode_type ("len", &lentype, f, encodetype, side);
	       fprintf (f,
			"if(rx_Write(call, %s, len) != len)\n"
			"goto fail;\n"
			"if(rx_Write(call, zero, padlen) != padlen)\n"
			"goto fail;\n"
			"}\n", name);
	       break;
	  case DECODE_RX :
	       fprintf (f, "{ unsigned len;\n"
			"unsigned padlen;\n"
			"char zero[4] = {0, 0, 0, 0};\n");
	       encode_type ("len", &lentype, f, encodetype, side);
	       if (type->size != 0) {
		   fprintf (f,
			    "if (len >= %u) {\n"
			    "rx_SetCallError(call, ENOMEM);\n"
			    "goto fail;\n"
			    "}\n",
			    type->size);
	       } else {
		   fprintf(f, "if (len == (uint32_t) -1) {\n"
			   "rx_SetCallError(call, ENOMEM);\n"
			   "goto fail;\n"
			   "}\n");
		   fprintf(f, "%s = malloc(len + 1);\n"
			   "if (%s == NULL) {\n"
			   "rx_SetCallError(call, ENOMEM);\n"
			   "goto fail;\n"
			   "}\n", 
			   nname, nname);
	       }

	       fprintf (f, 
			"if(rx_Read(call, %s, len) != len)\n"
			"goto fail;\n"
			"%s[len] = '\\0';\n"
			"padlen = (4 - (len %% 4)) %% 4;\n"
			"if(rx_Read(call, zero, padlen) != padlen)\n"
			"goto fail;\n"
			"}\n", nname, nname);
	       break;
	  case ENCODE_MEM :
	       fprintf (f,
			"{\nunsigned len = strlen(%s);\n"
			"if (*total_len < len) goto fail;\n"
			"*total_len -= len;\n",
			name);
	       encode_type ("len", &lentype, f, encodetype, side);
	       fprintf (f, "strncpy (ptr, %s, len);\n", name);
	       fprintf (f, "ptr += len + (4 - (len %% 4)) %% 4;\n"
			"*total_len -= len + (4 - (len %% 4)) %% 4;\n}\n");
	       break;
	  case DECODE_MEM :
	       fprintf (f,
		   "{\nunsigned len;\n");
	       encode_type ("len", &lentype, f, encodetype, side);
	       fprintf (f,
			"if (*total_len < len) goto fail;\n"
			"*total_len -= len;\n");
	       if (type->size != 0) {
		   fprintf (f,
			    "if(len >= %u)\n"
			    "goto fail;\n",
			    type->size);
	       } else {
		   fprintf(f, "if (len == (uint32_t) -1) {\n"
			   "goto fail;\n"
			   "}\n");
		   fprintf(f, "%s = malloc(len + 1);\n"
			   "if (%s == NULL) {\n"
			   "goto fail;\n"
			   "}\n", 
			   nname, nname);
	       }
	       fprintf (f,
			"memcpy (%s, ptr, len);\n"
			"%s[len] = '\\0';\n"
			"ptr += len + (4 - (len %% 4)) %% 4;\n"
			"*total_len -= len + (4 - (len %% 4)) %% 4;\n}\n",
			nname, nname);
	       break;
	  default :
	       abort ();
     }
     free (nname);
}	       

/*
 * print TSTRING
 */

static void
print_string (char *where, char *name, Type *type, FILE *f)
{
    fprintf (f, "/* printing TSTRING %s%s */\n", where, name);
    fprintf (f, "printf(\" %s = %%s\", %s%s);", name, where, name);
}

#if 0
/*
 * free TSTRING
 */

static void
free_string (char *where, char *name, Type *type, FILE *f)
{
    fprintf (f, "free(%s%s);\n", where, name);
}
#endif

/*
 * encode/decode TARRAY 
 */

static void
encode_array (char *name, Type *type, FILE *f, EncodeType encodetype,
	      Side side)
{
     if (type->subtype->type == YDR_TOPAQUE) {
	  if (type->size % 4 != 0)
	       error_message (1, "Opaque array should be"
			      "multiple of 4");
	  switch (encodetype) {
	       case ENCODE_RX :
		    fprintf (f,
			     "if(rx_Write (call, %s, %d) != %d)\n"
			     "goto fail;",
			     name, type->size, type->size);
		    break;
	       case DECODE_RX :
		    fprintf (f,
			     "if(rx_Read (call, %s, %d) != %d)\n"
			     "goto fail;",
			     name, type->size, type->size);
		    break;
	       case ENCODE_MEM :
		    fprintf (f, "if (*total_len < %u) goto fail;\n"
			     "memcpy (ptr, %s, %u);\n", type->size, name,
			     type->size);
		    fprintf (f, "ptr += %u; *total_len -= %u;\n", 
			     type->size, type->size);
		    break;
	       case DECODE_MEM :
		    fprintf (f, "if (*total_len < %u) goto fail;"
			     "memcpy (%s, ptr, %u);\n", type->size, name,
			     type->size);
		    fprintf (f, "ptr += %u; *total_len -= %u;\n", 
			     type->size, type->size);
		    break;
	       default :
		    abort ();
	  }
     } else {
	  char tmp[256];

	  fprintf (f, "{\nint i%lu;\nfor(i%lu = 0; i%lu < %u;"
		   "++i%lu){\n", tmpcnt, tmpcnt, tmpcnt, type->size,tmpcnt);
	  snprintf(tmp, sizeof(tmp)-1, "%s[i%lu]", name, tmpcnt);
	  tmpcnt++;
	  if (type->flags)
	      type->subtype->flags |= type->flags;
	  encode_type (tmp , type->subtype, f, encodetype, side);
	  tmpcnt--;
	  fprintf (f, "}\n}\n");
     }
}

/*
 * print ARRAY
 */

static void
print_array (char *where, char *name, Type *type, FILE *f)
{
    fprintf (f, "{\nunsigned int i%lu;\n", tmpcnt);

    fprintf (f, "/* printing ARRAY %s%s */\n", where, name);

    if (type->subtype->type == YDR_TOPAQUE) {
	if (type->size % 4 != 0)
	    error_message (1, "print_array: Opaque array should be"
			   "multiple of 4");
	
	fprintf (f, "char *ptr = %s%s;\n", where, name);
	fprintf (f, "printf(\"0x\");");
	fprintf (f, "for (i%lu = 0; i%lu < %d; ++i%lu)\n"
		 "printf(\"%%x\", ptr[i%lu]);",
		 tmpcnt, tmpcnt,
		 type->size, tmpcnt, tmpcnt);

     } else {
	char *ptr;
	fprintf (f, "for (i%lu = 0; i%lu < %d; ++i%lu) {\n", 
		 tmpcnt, tmpcnt, type->size, tmpcnt);
	asprintf(&ptr, "%s%s[i%ld]", where, name, tmpcnt);
	tmpcnt++;
	display_type (ptr, "", type->subtype, f);
	tmpcnt--;
	free(ptr);
	fprintf (f, "\nif (i%lu != %d - 1) printf(\",\");\n", 
		 tmpcnt, type->size);
	
	fprintf (f, "}\n");
     }
    fprintf (f, "}\n");
}

/*
 * free TARRAY
 */

static void
free_array (char *where, char *name, Type *type, FILE *f)
{
    if (type->subtype->type == YDR_TOPAQUE) {
	; /* nothing */
    } else {
	char tmp[256];

	fprintf (f, "{\nint i%lu;\nfor(i%lu = 0; i%lu < %u;"
		 "++i%lu){\n", tmpcnt, tmpcnt, tmpcnt, type->size,tmpcnt);
	snprintf(tmp, sizeof(tmp)-1, "%s[i%lu]", name, tmpcnt);
	tmpcnt++;
	if (type->flags)
	    type->subtype->flags |= type->flags;
	free_type (tmp, "", type->subtype, f);
	tmpcnt--;
	fprintf (f, "}\n}\n");
    }
}

/*
 * encode/decode TVARRAY
 */

static void
encode_varray (char *name, Type *type, FILE *f, EncodeType encodetype,
	       Side side)
{
     char tmp[256];
     Type lentype = {YDR_TULONG};
     Type *indextype;
	       
     strlcpy (tmp, name, sizeof tmp);
     strlcat (tmp, ".len", sizeof tmp);

     indextype = type->indextype ? type->indextype : &lentype;

     encode_type (tmp, indextype, f, encodetype, side);
     if (encodetype == DECODE_MEM || encodetype == DECODE_RX) {
	 if (type->size != 0)
	     fprintf (f, "if (%s > %d) goto fail;\n", tmp, type->size);
	 if (encodetype == DECODE_MEM) {
	     fprintf (f, "if ((%s * sizeof(", tmp);
	     print_type ("", type->subtype, TIN, VDECL, f);
	     fprintf (f, ")) > *total_len) goto fail;\n");
	 }
     }
     gen_check_overflow(indextype, type->subtype, tmp, f);
     if (encodetype == DECODE_MEM || encodetype == DECODE_RX) {
	 fprintf (f, "%s.val = (", name);
	 print_type ("*", type->subtype, TIN, VDECL, f);
	 fprintf (f, ")malloc(sizeof(");
	 print_type ("", type->subtype, TIN, VDECL, f);
	 fprintf (f, ") * %s);\n", tmp);
	 fprintf (f, "if (%s.val == NULL) goto fail;\n", name);
     }
     if (type->subtype->type == YDR_TOPAQUE) {
	  switch (encodetype) {
	       case ENCODE_RX :
		    fprintf (f, "{\n"
			     "char zero[4] = {0, 0, 0, 0};\n"
			     "unsigned padlen = (4 - (%s %% 4)) %% 4;\n"
			     "if(rx_Write (call, %s.val, %s) != %s)\n"
			     "goto fail;\n"
			     "if(rx_Write (call, zero, padlen) != padlen)\n"
			     "goto fail;\n"
			     "}\n",
			     tmp, name, tmp, tmp);
		    break;
	       case DECODE_RX :
		    fprintf (f, "{\n"
			     "char zero[4] = {0, 0, 0, 0};\n"
			     "unsigned padlen = (4 - (%s %% 4)) %% 4;\n"
			     "if(rx_Read (call, %s.val, %s) != %s)\n"
			     "goto fail;\n"
			     "if(rx_Read (call, zero, padlen) != padlen)\n"
			     "goto fail;\n"
			     "}\n",
			     tmp, name, tmp, tmp);
		    break;
	       case ENCODE_MEM :
		    fprintf (f, "{\n"
			     "char zero[4] = {0, 0, 0, 0};\n"
			     "size_t sz = %s + (4 - (%s %% 4)) %% 4;\n"
			     "if (*total_len < sz) goto fail;\n"
			     "memcpy (ptr, %s.val, %s);\n"
			     "memcpy (ptr + %s, zero, (4 - (%s %% 4)) %% 4);\n"
			     "ptr += sz; *total_len -= sz;\n"
			     "}\n",
			     tmp, tmp, name, tmp, tmp, tmp);
		    break;
	       case DECODE_MEM :
		    fprintf (f, 
			     "{\n"
			     "memcpy (%s.val, ptr, %s);\n"
			     "ptr += %s + (4 - (%s %% 4)) %% 4;\n"
			     "}\n",
			     name, tmp, tmp, tmp);
		    break;
	       default :
		    abort ();
	  }
     } else {
	  fprintf (f, "{\nint i%lu;\nfor(i%lu = 0; i%lu < %s;"
		   "++i%lu){\n", tmpcnt, tmpcnt, tmpcnt, tmp, tmpcnt);
	  snprintf(tmp, sizeof(tmp)-1, "%s.val[i%lu]", name, tmpcnt);
	  tmpcnt++;
	  if (type->flags)
	      type->subtype->flags |= type->flags;
	  encode_type (tmp , type->subtype, f, encodetype, side);
	  tmpcnt--;
	  fprintf (f, "}\n}\n");
     }
}

/*
 * print TVARRAY
 */

static void
print_varray (char *where, char *name, Type *type, FILE *f)
{
    fprintf (f, "{\nunsigned int i%lu;\n", tmpcnt);

    fprintf (f, "/* printing YDR_TVARRAY %s%s */\n", where, name);

    if (type->subtype->type == YDR_TOPAQUE) {
	fprintf (f, "char *ptr = %s%s.val;\n", where, name);
	fprintf (f, "printf(\"0x\");");
	fprintf (f, "for (i%lu = 0; i%lu < %s%s.len; ++i%lu)\n"
		 "printf(\"%%x\", ptr[i%lu]);",
		 tmpcnt, tmpcnt,
		 where, name, tmpcnt, tmpcnt);
    } else {
	char *ptr;
	fprintf (f, "for (i%lu = 0; i%lu < %s%s.len; ++i%lu) {\n", 
		 tmpcnt, tmpcnt, where, name, tmpcnt);
	asprintf(&ptr, "%s%s.val[i%ld]", where, name, tmpcnt);
	tmpcnt++;
	display_type (ptr, "", type->subtype, f);
	tmpcnt--;
	free(ptr);
	fprintf (f, "\nif (i%lu != %s%s.len - 1) printf(\",\");\n", 
		 tmpcnt, where, name);
	
	fprintf (f, "}\n");
    }
    fprintf (f, "}\n");
}

/*
 * free TVARRAY
 */

static void
free_varray (char *where, char *name, Type *type, FILE *f)
{
    if (type->subtype->type != YDR_TOPAQUE) {
	char *ptr;
	fprintf (f, "{\n"
		 "unsigned int i%lu;\n", tmpcnt);
	fprintf (f, "for (i%lu = 0; i%lu < %s%s.len; ++i%lu) {\n", 
		 tmpcnt, tmpcnt, where, name, tmpcnt);
	asprintf(&ptr, "%s%s.val[i%ld]", where, name, tmpcnt);
	tmpcnt++;
	free_type (ptr, "", type->subtype, f);
	tmpcnt--;
	free(ptr);
	fprintf (f, "}\n");
	fprintf (f, "}\n");
    }
    fprintf (f, "free((%s%s).val);\n", where, name);
}

/*
 * encode/decode pointer
 */

static void
encode_pointer (char *name, Type *type, FILE *f, EncodeType encodetype,
		Side side)
{
     Type booltype = {YDR_TULONG};
     char tmp[256];

     snprintf (tmp, sizeof(tmp), "*(%s)", name);

     switch(encodetype) {
     case ENCODE_RX:
	  abort ();
     case ENCODE_MEM:
	  fprintf(f, "{ unsigned bool;\n"
		  "bool = %s != NULL;\n", name);
	  encode_type ("bool", &booltype, f, encodetype, side);
	  fprintf (f, "if(%s) {\n", name);
	  encode_type (tmp, type->subtype, f, encodetype, side);
	  fprintf (f, "}\n"
		   "}\n");
	  break;
     case DECODE_RX:
	  exit(-1);
     case DECODE_MEM:
	  fprintf(f, "{ unsigned bool;\n");
	  encode_type ("bool", &booltype, f, encodetype, side);
	  fprintf (f, "if(bool) {\n");
	  fprintf (f, "%s = malloc(sizeof(%s));\n"
		   "if (%s == NULL) return ENOMEM;\n", 
		   name, tmp, name);
	  encode_type (tmp, type->subtype, f, encodetype, side);
	  fprintf (f, "} else {\n"
		   "%s = NULL;\n"
		   "}\n"
		   "}\n", name);
	  break;
     default:
	  abort ();
     }
}

/*
 * free pointer
 */

static void
free_pointer (char *where, char *name, Type *type, FILE *f)
{
    char *tmp;

    asprintf (&tmp, "*(%s%s)", where, name);
    fprintf (f, "if(%s%s)", where, name);
    free_type(tmp, "", type->subtype, f);
    free(tmp);
}

/*
 * encode type
 */

static void
encode_type (char *name, Type *type, FILE *f, EncodeType encodetype,
	     Side side)
{
     switch (type->type) {
	  case YDR_TCHAR :
	  case YDR_TUCHAR :
	  case YDR_TSHORT :
	  case YDR_TUSHORT :
	  case YDR_TLONG :
	  case YDR_TULONG :
	       encode_long (name, type, f, encodetype);
	       break;
	  case YDR_TLONGLONG :
	  case YDR_TULONGLONG :
	       encode_longlong (name, type, f, encodetype);
	       break;
	  case YDR_TSTRING :
	       encode_string (name, type, f, encodetype, side);
	       break;
	  case YDR_TOPAQUE :
	       error_message (1,
			      "Type opaque only allowed as part of an array");
	       break;
	  case YDR_TUSERDEF :
	       encode_symbol (type->symbol, name, f, encodetype, side);
	       break;
	  case YDR_TARRAY :
	       encode_array (name, type, f, encodetype, side);
	       break;
	  case YDR_TVARRAY :
	       encode_varray (name, type, f, encodetype, side);
	       break;
	  case YDR_TPOINTER :
	       encode_pointer (name, type, f, encodetype, side);
	       break;
	  default :
	       exit(-1);
	  }
}

/*
 * print type
 */

static void
display_type (char *where, char *name, Type *type, FILE *f)
{
    assert (where);

    switch (type->type) {
    case YDR_TCHAR :
    case YDR_TUCHAR :
    case YDR_TSHORT :
    case YDR_TUSHORT :
    case YDR_TLONG :
    case YDR_TULONG :
	print_long (where, name, type, f);
	break;
    case YDR_TLONGLONG :
    case YDR_TULONGLONG :
	print_longlong (where, name, type, f);
	break;
    case YDR_TSTRING :
	print_string (where, name, type, f);
	break;
    case YDR_TOPAQUE :
	fprintf (f, "printf(\"printing TOPAQUE\\n\");");
	break;
    case YDR_TUSERDEF :
	print_symbol (where, type->symbol, name, f);
	break;
    case YDR_TARRAY :
	print_array (where, name, type, f);
	break;
    case YDR_TVARRAY :
	print_varray (where, name, type, f);
	break;
    case YDR_TPOINTER :
	fprintf (f, "printf(\"printing TPOINTER\\n\");");
	break;
    default :
	exit(-1);
    }
}

/*
 * free type
 */

static void
free_type (char *where, char *name, Type *type, FILE *f)
{
    switch (type->type) {
    case YDR_TCHAR :
    case YDR_TUCHAR :
    case YDR_TSHORT :
    case YDR_TUSHORT :
    case YDR_TLONG :
    case YDR_TULONG :
    case YDR_TLONGLONG :
    case YDR_TULONGLONG :
	break;
    case YDR_TSTRING :
#if 0
	free_string (where, name, type, f);
#endif
	break;
    case YDR_TOPAQUE :
	break;
    case YDR_TUSERDEF :
	free_symbol (where, type->symbol, name, f);
	break;
    case YDR_TARRAY :
	free_array (where, name, type, f);
	break;
    case YDR_TVARRAY :
	free_varray (where, name, type, f);
	break;
    case YDR_TPOINTER :
	free_pointer (where, name, type, f);
	break;
    default :
	exit(-1);
    }
}

struct context {
     char *name;
     FILE *f;
     Symbol *symbol;
     EncodeType encodetype;
     Side side;
};

/*
 * helpfunction for encode_struct
 */

static Bool
encode_entry (List *list, Listitem *item, void *arg)
{
     StructEntry *s = (StructEntry *)listdata (item);
     char tmp[256];
     struct context *context = (struct context *)arg;

     strlcpy (tmp, context->name, sizeof tmp);
     strlcat (tmp, ".", sizeof tmp);
     strlcat (tmp, s->name, sizeof tmp);

     if (s->type->type == YDR_TPOINTER
	 && s->type->subtype->type == YDR_TUSERDEF
	 && s->type->subtype->symbol->type == YDR_TSTRUCT
	 && strcmp(s->type->subtype->symbol->name,
		   context->symbol->name) == 0) {
	 fprintf (context->f,
		  "ptr = ydr_encode_%s(%s, ptr);\n",
		  context->symbol->name,
		  tmp);
     } else {
	 encode_type (tmp, s->type, context->f, context->encodetype,
		      context->side);
     }

     return FALSE;
}

/*
 * encode/decode TSTRUCT
 */

static void
encode_struct (Symbol *s, char *name, FILE *f, EncodeType encodetype,
	       Side side)
{
     struct context context;

     context.name       = name;
     context.symbol     = s;
     context.f          = f;
     context.encodetype = encodetype;
     context.side       = side;

     if (s->u.list)
	 listiter (s->u.list, encode_entry, (void *)&context);
}

/*
 * help function for print_struct
 */

struct printcontext {
    char *where;
    char *name;
    FILE *f;
    Symbol *symbol;
};

static Bool
print_structentry (List *list, Listitem *item, void *arg)
{
     StructEntry *s = (StructEntry *)listdata (item);
     struct printcontext *context = (struct printcontext *)arg;

     char *tmp;
     char *tmp2;

     asprintf(&tmp, ".%s", s->name);
     asprintf(&tmp2, "%s%s", context->where, context->name);

     if (s->type->type == YDR_TPOINTER
	 && s->type->subtype->type == YDR_TUSERDEF
	 && s->type->subtype->symbol->type == YDR_TSTRUCT
	 && strcmp(s->type->subtype->symbol->name,
		   context->symbol->name) == 0) {
	 fprintf (context->f,
		  "ydr_print_%s%s(%s%s, ptr);\n",
		  package,
		  context->symbol->name,
		  tmp2,
		  tmp);
     } else {
	 display_type (tmp2, tmp, s->type, context->f);
     }

     free(tmp);
     free(tmp2);

     fprintf (context->f, "\n");

     return FALSE;
}

/*
 * print TSTRUCT
 */

static void
print_struct (char *where, Symbol *s, char *name, FILE *f)
{
    struct printcontext context;
    
    context.name       = name;
    context.symbol     = s;
    context.f          = f;
    context.where      = where ;

    fprintf (f, "/* printing TSTRUCT %s%s */\n", where, name);
    
    if (s->u.list)
	listiter (s->u.list, print_structentry, (void *)&context);
}

/*
 * help function for free_struct
 */

struct freecontext {
    char *where;
    char *name;
    FILE *f;
    Symbol *symbol;
};

static Bool
free_structentry (List *list, Listitem *item, void *arg)
{
     StructEntry *s = (StructEntry *)listdata (item);
     struct freecontext *context = (struct freecontext *)arg;

     char *tmp;
     char *tmp2;

     asprintf(&tmp, ".%s", s->name);
     asprintf(&tmp2, "%s%s", context->where, context->name);

     if (s->type->type == YDR_TPOINTER
	 && s->type->subtype->type == YDR_TUSERDEF
	 && s->type->subtype->symbol->type == YDR_TSTRUCT
	 && strcmp(s->type->subtype->symbol->name,
		   context->symbol->name) == 0) {
	 fprintf (context->f,
		  "ydr_free_%s%s(%s%s, ptr);\n",
		  package,
		  context->symbol->name,
		  tmp2,
		  tmp);
     } else {
	 free_type (tmp2, tmp, s->type, context->f);
     }

     free(tmp);
     free(tmp2);

     return FALSE;
}

/*
 * free TSTRUCT
 */

static void
free_struct (char *where, Symbol *s, char *name, FILE *f)
{
    struct freecontext context;
    
    context.name       = name;
    context.symbol     = s;
    context.f          = f;
    context.where      = where;

    if (s->u.list)
	listiter (s->u.list, free_structentry, (void *)&context);
}

/*
 * encode/decode TENUM
 */

static void
encode_enum (Symbol *s, char *name, FILE *f, EncodeType encodetype,
	     Side side)
{
     Type type = {YDR_TLONG};

     encode_type (name, &type, f, encodetype, side);
}

/*
 * print TENUM
 */

static Bool
gen_printenum (List *list, Listitem *item, void *arg)
{
    Symbol *s = (Symbol *)listdata (item);
    FILE *f = (FILE *)arg;
    
    fprintf (f, "case %d:\n"
	     "printf(\"%s\");\n"
	     "break;\n", 
	     (int) s->u.val, s->name);

     return FALSE;
}

static void
print_enum (char *where, Symbol *s, char *name, FILE *f)
{
    fprintf (f, "/* print ENUM %s */\n", where);

    fprintf (f, "printf(\"%s = \");", name);
    fprintf (f, "switch(%s) {\n", where);
    if (s->u.list)
	listiter (s->u.list, gen_printenum, f);
    fprintf (f, 
	     "default:\n"
	     "printf(\" unknown enum %%d\", %s);\n"
	     "}\n",
	     where);
}

/*
 * encode/decode TTYPEDEF
 */

static void
encode_typedef (Symbol *s, char *name, FILE *f, EncodeType encodetype,
		Side side)
{
     encode_type (name, s->u.type, f, encodetype, side);
}

/*
 * print TTYPEDEF
 */

static void
print_typedef (char *where, Symbol *s, char *name, FILE *f)
{
    display_type (where, name, s->u.type, f);
}

/*
 * free TTYPEDEF
 */

static void
free_typedef (char *where, Symbol *s, char *name, FILE *f)
{
    free_type (where, name, s->u.type, f);
}

/*
 * Encode symbol/TUSERDEF
 */

static void
encode_symbol (Symbol *s, char *name, FILE *f, EncodeType encodetype,
	       Side side)
{
     switch (s->type) {
	  case YDR_TSTRUCT :
	       encode_struct (s, name, f, encodetype, side);
	       break;
	  case YDR_TENUM :
	       encode_enum (s, name, f, encodetype, side);
	       break;
	  case YDR_TTYPEDEF :
	       encode_typedef (s, name, f, encodetype, side);
	       break;
	  default :
	       exit(-1);
	  }
}

/*
 * print symbol/TUSERDEF
 */

static void
print_symbol (char *where, Symbol *s, char *name, FILE *f)
{
     switch (s->type) {
	  case YDR_TSTRUCT :
	       print_struct (where, s, name, f);
	       break;
	  case YDR_TENUM :
	       print_enum (where, s, name, f);
	       break;
	  case YDR_TTYPEDEF :
	       print_typedef (where, s, name, f);
	       break;
	  default :
	       exit(-1);
	  }
}

/*
 * Generate a free function for symbol
 */

static void
free_symbol (char *where, Symbol *s, char *name, FILE *f)
{
     switch (s->type) {
	  case YDR_TSTRUCT :
	       free_struct (where, s, name, f);
	       break;
	  case YDR_TENUM :
	       break;
	  case YDR_TTYPEDEF :
	       free_typedef (where, s, name, f);
	       break;
	  default :
	       exit(-1);
	  }
}

/*
 * Generate the definition of an encode/decode function.
 */

static void
generate_function_definition (Symbol *s, FILE *f, Bool encodep)
{
     if (s->type == YDR_TSTRUCT
	 || s->type == YDR_TENUM
	 || s->type == YDR_TTYPEDEF)
     {
	  fprintf (f, 
		   "%schar *ydr_%scode_%s(%s%s *o, %schar *ptr, size_t *total_len)",
		   encodep ? "" : "const ",
		   encodep ? "en" : "de",
		   s->name,
		   encodep ? "const " : "",
		   s->name,
		   encodep ? "" : "const ");
     } else if (s->type == YDR_TCONST
		|| s->type == YDR_TENUMVAL 
		|| s->type == YDR_TTYPEDEF)
	  ;
     else
	  error_message (1, "What is %s (type %d) doing here?\n",
			 s->name, s->type);
}

/*
 * Generate the definition of a print function.
 */

static void
generate_printfunction_definition (Symbol *s, FILE *f)
{
     if (s->type == YDR_TSTRUCT
	 || s->type == YDR_TENUM
	 || s->type == YDR_TTYPEDEF) 
     {
	  fprintf (f, 
		   "void ydr_print_%s(%s *o)",
		   s->name, s->name);
     } else if (s->type == YDR_TCONST
		|| s->type == YDR_TENUMVAL 
		|| s->type == YDR_TTYPEDEF)
	  ;
     else
	  error_message (1, "What is %s (type %d) doing here?\n",
			 s->name, s->type);
}

/*
 * Generate a defintion for a function to free `s', writing it to `f'
 */

static void
generate_freefunction_definition (Symbol *s, FILE *f)
{
     if (s->type == YDR_TSTRUCT
	 || s->type == YDR_TENUM
	 || s->type == YDR_TTYPEDEF) 
     {
	  fprintf (f, 
		   "void ydr_free_%s(%s *o)",
		   s->name, s->name);
     } else if (s->type == YDR_TCONST
		|| s->type == YDR_TENUMVAL 
		|| s->type == YDR_TTYPEDEF)
	  ;
     else
	  error_message (1, "What is %s (type %d) doing here?\n",
			 s->name, s->type);
}

/*
 * Generate an encode/decode function
 */

void
generate_function (Symbol *s, FILE *f, Bool encodep)
{
     if (s->type == YDR_TSTRUCT
	 || s->type == YDR_TENUM
	 || s->type == YDR_TTYPEDEF)
     {
	  generate_function_definition (s, f, encodep);
	  fprintf (f, "\n{\n");
	  if (!encodep)
	      fprintf (f, "memset(o, 0, sizeof(*o));\n");
	  encode_symbol (s, "(*o)", f,
			 encodep ? ENCODE_MEM : DECODE_MEM, CLIENT);
	  fprintf (f, "return ptr;\n"
		   "fail:\n");
	  if (!encodep)
	      free_symbol ("", s, "(*o)", f);
	  fprintf (f, "errno = EINVAL;\n"
		   "return NULL;}\n");
     } else if (s->type == YDR_TCONST
		|| s->type == YDR_TENUMVAL 
		|| s->type == YDR_TTYPEDEF)
	  ;
     else
	  error_message (1, "What is %s (type %d) doing here?\n",
			 s->name, s->type);
}

/*
 * Generate a print function
 */

void
generate_printfunction (Symbol *s, FILE *f)
{
     if (s->type == YDR_TSTRUCT
	 || s->type == YDR_TENUM
	 || s->type == YDR_TTYPEDEF) {
	  generate_printfunction_definition (s, f);
	  fprintf (f, "\n{\n");
	  print_symbol ("(*o)",  s, "", f);
	  fprintf (f, "return;\n}\n");
     } else if (s->type == YDR_TCONST
		|| s->type == YDR_TENUMVAL 
		|| s->type == YDR_TTYPEDEF)
	  ;
     else
	  error_message (1, "What is %s (type %d) doing here?\n",
			 s->name, s->type);
}

/*
 * Generate a free function for the type `s' and print it on `f'.
 */

void
generate_freefunction (Symbol *s, FILE *f)
{
     if (s->type == YDR_TSTRUCT
	 || s->type == YDR_TENUM
	 || s->type == YDR_TTYPEDEF) {
	  generate_freefunction_definition (s, f);
	  fprintf (f, "\n{\n");
	  free_symbol("(*o)", s, "", f);
	  fprintf (f, "return;\n}\n");
     } else if (s->type == YDR_TCONST
		|| s->type == YDR_TENUMVAL 
		|| s->type == YDR_TTYPEDEF)
	  ;
     else
	  error_message (1, "What is %s (type %d) doing here?\n",
			 s->name, s->type);
}

/*
 * Generate an prototype for an encode/decode function
 */

void
generate_function_prototype (Symbol *s, FILE *f, Bool encodep)
{
     if (s->type == YDR_TSTRUCT
	 || s->type == YDR_TENUM
	 || s->type == YDR_TTYPEDEF) 
     {
	  generate_function_definition (s, f, encodep);
	  fprintf (f, ";\n");
     } else if (s->type == YDR_TCONST
		|| s->type == YDR_TENUMVAL 
		|| s->type == YDR_TTYPEDEF)
	  ;
     else
	  error_message (1, "What is %s (type %d) doing here?\n",
			 s->name, s->type);
}

/*
 * Generate an prototype for a print function
 */

void
generate_printfunction_prototype (Symbol *s, FILE *f)
{
     if (s->type == YDR_TSTRUCT
	 || s->type == YDR_TENUM
	 || s->type == YDR_TTYPEDEF) {
	  generate_printfunction_definition (s, f);
	  fprintf (f, ";\n");
     } else if (s->type == YDR_TCONST
		|| s->type == YDR_TENUMVAL 
		|| s->type == YDR_TTYPEDEF)
	  ;
     else
	  error_message (1, "What is %s (type %d) doing here?\n",
			 s->name, s->type);
}

/*
 * Generate a prototype for a free function for the `s' type
 * and output it to `f'
 */

void
generate_freefunction_prototype(Symbol *s, FILE *f)
{
     if (s->type == YDR_TSTRUCT
	 || s->type == YDR_TENUM
	 || s->type == YDR_TTYPEDEF) {
	  generate_freefunction_definition (s, f);
	  fprintf (f, ";\n");
     } else if (s->type == YDR_TCONST
		|| s->type == YDR_TENUMVAL 
		|| s->type == YDR_TTYPEDEF)
	  ;
     else
	  error_message (1, "What is %s (type %d) doing here?\n",
			 s->name, s->type);
}

static Bool
gen1 (List *list, Listitem *item, void *arg)
{
     Argument *a = (Argument *)listdata (item);
     FILE *f = (FILE *)arg;

     if ((a->argtype == TOUT || a->argtype == TINOUT)
	 && a->type->type != YDR_TPOINTER
	 && a->type->type != YDR_TSTRING)
	 error_message (1, "Argument %s is OUT and not pointer or string.\n",
			a->name);
     fprintf (f, ", ");
     if (a->argtype == TIN)
	 fprintf (f, "const ");
     print_type (a->name, a->type, a->argtype, FDECL, f);
     fprintf (f, "\n");
     return FALSE;
}

static Bool
genin (List *list, Listitem *item, void *arg)
{
     Argument *a = (Argument *)listdata (item);
     FILE *f = (FILE *)arg;

     if (a->argtype == TIN || a->argtype == TINOUT) {
	  fprintf (f, ", %s ", a->argtype == TIN ? "const" : "");
	  print_type (a->name, a->type, a->argtype, FDECL, f);
	  fprintf (f, "\n");
     }
     return FALSE;
}

static Bool
genout (List *list, Listitem *item, void *arg)
{
     Argument *a = (Argument *)listdata (item);

     if (a->argtype == TOUT || a->argtype == TINOUT)
	  return gen1 (list, item, arg);
     else
	  return FALSE;
}

static Bool
gendeclare (List *list, Listitem *item, void *arg)
{
     Argument *a = (Argument *)listdata (item);
     FILE *f = (FILE *)arg;

     if (a->type->type == YDR_TPOINTER)
	  print_type (a->name, a->type->subtype, TIN, VDECL, f);
     else
	  print_type (a->name, a->type, TIN, VDECL, f);
     fprintf (f, ";\n");
     return FALSE;
}

static Bool
genzero (List *list, Listitem *item, void *arg)
{
     Argument *a = (Argument *)listdata (item);
     FILE *f = (FILE *)arg;

     fprintf (f, "memset(&%s, 0, sizeof(%s));\n",
	      a->name, a->name);
     return FALSE;
}

static Bool
genfree_isarrayp(Type *type)
{
    if (type->type == YDR_TVARRAY)
	return TRUE;
    if (type->type == YDR_TPOINTER)
	return genfree_isarrayp(type->subtype);
    if (type->type == YDR_TUSERDEF &&
	type->symbol &&
	type->symbol->type == YDR_TTYPEDEF)
	return genfree_isarrayp(type->symbol->u.type);
    
    return FALSE;
}


static Bool
genfree (List *list, Listitem *item, void *arg)
{
     Argument *a = (Argument *)listdata (item);
     FILE *f = (FILE *)arg;

     if (genfree_isarrayp(a->type))
	 fprintf(f, "free(%s.val);\n", a->name);
     else if (a->argtype != TIN
	      && a->type->type == YDR_TSTRING && a->type->size == 0)
	 fprintf (f, "free(%s);\n", a->name);
     return FALSE;
}

static Bool
genencodein (List *list, Listitem *item, void *arg)
{
    Argument *a = (Argument *)listdata (item);
    FILE *f = (FILE *)arg;
    
    if (a->argtype == TIN || a->argtype == TINOUT) {
	if (a->type->type == YDR_TPOINTER) {
	    size_t len = strlen (a->name) + 4;
	    char *tmp = (char *)emalloc (len);
	    
	    snprintf (tmp, len, "(*%s)", a->name);
	    
	    encode_type (tmp, a->type->subtype, f, ENCODE_RX, CLIENT);
	    free (tmp);
	} else
	    encode_type (a->name, a->type, f, ENCODE_RX, CLIENT);
    }
    return FALSE;
}

static Bool
gendecodeout (List *list, Listitem *item, void *arg)
{
     Argument *a = (Argument *)listdata (item);
     FILE *f = (FILE *)arg;

     if (a->argtype == TOUT || a->argtype == TINOUT) {
	 if (a->type->type == YDR_TPOINTER) {
	     size_t len = strlen(a->name) + 4;
	     char *tmp = (char *)emalloc (len);
	       
	     snprintf (tmp, len, "(*%s)", a->name);

	     encode_type (tmp, a->type->subtype, f, DECODE_RX, CLIENT);
	     free (tmp);
	 } else if(a->type->type == YDR_TSTRING) {
	     encode_type (a->name, a->type, f, DECODE_RX, CLIENT);
	 }
     }
     return FALSE;
}

static Bool
gendecodein (List *list, Listitem *item, void *arg)
{
     Argument *a = (Argument *)listdata (item);
     FILE *f = (FILE *)arg;

     if (a->argtype != TIN && a->argtype != TINOUT)
	  return TRUE;
     else {
	  if (a->type->type == YDR_TPOINTER) {
#if 0
	       size_t len = strlen(a->name) + 4;
	       char *tmp = (char *)emalloc (len);
	       
	       snprintf (tmp, len, "(*%s)", a->name);

	       encode_type (tmp, a->type->subtype, f, DECODE_RX, SERVER);
	       free (tmp);
#endif
	       encode_type (a->name, a->type->subtype, f, DECODE_RX, SERVER);
	  } else
	       encode_type (a->name, a->type, f, DECODE_RX, SERVER);
	  return FALSE;
     }
}

static Bool
genencodeout (List *list, Listitem *item, void *arg)
{
     Argument *a = (Argument *)listdata (item);
     FILE *f = (FILE *)arg;

     if (a->argtype == TOUT || a->argtype == TINOUT) {
	  if (a->type->type == YDR_TPOINTER)
	       encode_type (a->name, a->type->subtype, f, ENCODE_RX, SERVER);
	  else
	       encode_type (a->name, a->type, f, ENCODE_RX, SERVER);
     }
     return FALSE;
}

static Bool
findargtypeiter (List *list, Listitem *item, void *arg)
{
     Argument *a = (Argument *)listdata (item);
     int *type = (int *)arg;

     if (a->argtype == *type) {
	 (*type)++;
	 return TRUE;
     }
     return FALSE;
}

static Bool
findargtype(List *list, int type)
{
    int savedtype = type;
    listiter(list, findargtypeiter, &type);
    if (type != savedtype)
	return TRUE;
    return FALSE;
}

static Bool
genargs (List *list, Listitem *item, void *arg)
{
     Argument *a = (Argument *)listdata (item);
     FILE *f = (FILE *)arg;

     if (a->type->type == YDR_TPOINTER
	 || (a->argtype != TIN
	     && a->type->type == YDR_TSTRING && a->type->size == 0))
	  putc ('&', f);
     fputs (a->name, f);
     if (listnext (list, item))
	  fprintf (f, ", ");
     return FALSE;
}

/*
 * Generate the stub functions for this RPC call
 */

static void
generate_simple_stub (Symbol *s, FILE *f, FILE *headerf)
{
     Type type = {YDR_TLONG};
     char *op;

     fprintf (headerf, "int %s%s(\nstruct rx_connection *connection\n",
	      package, s->name);
     listiter (s->u.proc.arguments, gen1, headerf);
     fprintf (headerf, ");\n\n");

     fprintf (f, "int %s%s(\nstruct rx_connection *connection\n",
	      package, s->name);
     listiter (s->u.proc.arguments, gen1, f);
     fprintf (f, ")\n{\n"
	      "struct rx_call *call;\n"
	      "int ret = 0;\n"
	      "call = rx_NewCall (connection);\n");

     asprintf (&op, "%u", s->u.proc.id);
     
     encode_type (op, &type, f, ENCODE_RX, CLIENT);
     free (op);
     listiter (s->u.proc.arguments, genencodein, f);
     listiter (s->u.proc.arguments, gendecodeout, f);
     fprintf (f,
	      "return %s(rx_EndCall (call,0));\n"
	      "fail:\n"
	      "ret = %s(rx_GetCallError(call));\n"
	      "rx_EndCall (call, 0);\n"
	      "return ret;\n"
	      "}\n",
	      error_function,
	      error_function);
}

static void
generate_split_stub (Symbol *s, FILE *f, FILE *headerf)
{
     Type type = {YDR_TLONG};
     char *op;

     fprintf (headerf, "int Start%s%s(\nstruct rx_call *call\n",
	      package, s->name);
     listiter (s->u.proc.arguments, genin, headerf);
     fprintf (headerf, ");\n\n");

     fprintf (f, "int Start%s%s(\nstruct rx_call *call\n",
	      package, s->name);
     listiter (s->u.proc.arguments, genin, f);
     fprintf (f, ")\n{\n");


     asprintf (&op, "%u", s->u.proc.id);
     encode_type (op, &type, f, ENCODE_RX, CLIENT);
     free (op);
     listiter (s->u.proc.arguments, genencodein, f);
     fprintf (f, "return 0;\n");
     /* XXX only in arg */
     if (findargtype(s->u.proc.arguments, TIN) || 
	 findargtype(s->u.proc.arguments, TINOUT))
	 fprintf (f, "fail:\n"
                 "return %s(rx_GetCallError(call));\n",
		  error_function);

     fprintf (f, "}\n\n");

     fprintf (headerf, "int End%s%s(\nstruct rx_call *call\n", 
	      package, s->name);
     listiter (s->u.proc.arguments, genout, headerf);
     fprintf (headerf, ");\n\n");

     fprintf (f, "int End%s%s(\nstruct rx_call *call\n", 
	      package, s->name);
     listiter (s->u.proc.arguments, genout, f);
     fprintf (f, ")\n{\n");

     listiter (s->u.proc.arguments, gendecodeout, f);
     fprintf (f, "return 0;\n");
     /* XXX only out arg */
     if (findargtype(s->u.proc.arguments, TOUT) || 
	 findargtype(s->u.proc.arguments, TINOUT))
	 fprintf (f, "fail:\n"
                 "return %s(rx_GetCallError(call));\n",
		  error_function);

     fprintf (f, "}\n\n");
}

struct gen_args {
    FILE *f;
    int firstp;
    int arg_type;
};

static Bool
genmacro (List *list, Listitem *item, void *arg)
{
     Argument *a = (Argument *)listdata (item);
     struct gen_args *args = (struct gen_args *)arg;

     if (a->argtype == args->arg_type || a->argtype == TINOUT) {
	 fprintf (args->f, "%s%s",
		  args->firstp ? "" : ", ", a->name);
	 args->firstp = 0;
     }

     return FALSE;
}

static void
generate_multi (Symbol *s, FILE *f)
{
    struct gen_args gen_args;

    fprintf (f, "\n#include <rx/rx_multi.h>");
    fprintf (f, "\n#define multi_%s%s(", package, s->name);
    gen_args.f        = f;
    gen_args.firstp   = 1;
    gen_args.arg_type = TIN;
    listiter (s->u.proc.arguments, genmacro, &gen_args);
    fprintf (f, ") multi_Body(");
    fprintf (f, "Start%s%s(multi_call", package, s->name);
    gen_args.f        = f;
    gen_args.firstp   = 0;
    gen_args.arg_type = TIN;
    listiter (s->u.proc.arguments, genmacro, &gen_args);
    fprintf (f, "), End%s%s(multi_call", package, s->name);
    gen_args.f        = f;
    gen_args.firstp   = 0;
    gen_args.arg_type = TOUT;
    listiter (s->u.proc.arguments, genmacro, f);
    fprintf (f, "))\n");
}

void
generate_client_stub (Symbol *s, FILE *f, FILE *headerf)
{
    if (s->u.proc.flags & TSPLIT)
	  generate_split_stub (s, f, headerf);
    if (s->u.proc.flags & TSIMPLE)
	  generate_simple_stub (s, f, headerf);
}

/*
 * A list of all the functions that are to be recognized by the
 * server, later used in generate_server_switch.
 */

static List *func_list;

static void
generate_standard_c_prologue (FILE *f,
			      const char *filename,
			      const char *basename)
{
     fprintf (f, "/* Generated from %s.xg */\n", basename);
     fprintf (f, "#include \"%s.h\"\n\n", basename);
     fprintf (f, "#include <stdio.h>\n");
     fprintf (f, "#include <stdlib.h>\n");
     fprintf (f, "#include <string.h>\n");
     fprintf (f, "#include <netinet/in.h>\n");
     fprintf (f, "#include <errno.h>\n");
     fprintf (f, "#ifdef RCSID\n"
	      "RCSID(\"%s generated from %s.xg with $arla: output.c,v 1.91 2003/04/16 09:07:03 lha Exp $\");\n"
	      "#endif\n\n", filename, basename);
}

/*
 * Convert filename into a cpp symbol
 */

static char *
cppfilesymbolname(const char *fn)
{
     char *symname, *tmp;

     symname = estrdup(fn);
     estrdup (symname);
     for (tmp = symname; *tmp; tmp++) {
	 if (tmp == symname && isdigit((unsigned char)*tmp))
	     *tmp = '_';
	 if (!isalpha((unsigned char)*tmp))
	     *tmp = '_';
     }
     return symname;
}

/*
 * open all files
 */

void
init_generate (const char *filename)
{
     char *tmp;
     char *fileupr;

     func_list = listnew ();

     asprintf (&tmp, "%s.h", filename);
     if (tmp == NULL)
	 err (1, "malloc");
     ydr_fopen (tmp, "w", &headerfile);
     free (tmp);

     fileupr = cppfilesymbolname(filename);
     fprintf (headerfile.stream, "/* Generated from %s.xg */\n", filename);
     fprintf (headerfile.stream, "#ifndef _%s_\n"
	      "#define _%s_\n\n", fileupr, fileupr);
     fprintf (headerfile.stream, "#include <atypes.h>\n\n");
     free (fileupr);
     
     asprintf (&tmp, "%s.ydr.c", filename);
     if (tmp == NULL)
	 err (1, "malloc");
     ydr_fopen (tmp, "w", &ydrfile);
     generate_standard_c_prologue (ydrfile.stream, tmp, filename);
     free (tmp);

     asprintf (&tmp, "%s.cs.c", filename);
     if (tmp == NULL)
	 err (1, "malloc");
     ydr_fopen (tmp, "w", &clientfile);
     generate_standard_c_prologue (clientfile.stream, tmp, filename);
     fprintf (clientfile.stream, "#include \"%s.cs.h\"\n\n", filename);
     free (tmp);

     asprintf (&tmp, "%s.ss.c", filename);
     if (tmp == NULL)
	 err (1, "malloc");
     ydr_fopen (tmp, "w", &serverfile);
     generate_standard_c_prologue (serverfile.stream, tmp, filename);
     fprintf (serverfile.stream, "#include \"%s.ss.h\"\n\n", filename);
     free (tmp);

     asprintf (&tmp, "%s.cs.h", filename);
     if (tmp == NULL)
	 err (1, "malloc");
     ydr_fopen (tmp, "w", &clienthdrfile);
     free (tmp);
     fprintf (clienthdrfile.stream, "/* Generated from %s.xg */\n", filename);
     fprintf (clienthdrfile.stream, "#include <rx/rx.h>\n");
     fprintf (clienthdrfile.stream, "#include \"%s.h\"\n\n", filename);

     asprintf (&tmp, "%s.ss.h", filename);
     if (tmp == NULL)
	 err (1, "malloc");
     ydr_fopen (tmp, "w", &serverhdrfile);
     free (tmp);
     fprintf (serverhdrfile.stream, "/* Generated from %s.xg */\n", filename);
     fprintf (serverhdrfile.stream, "#include <rx/rx.h>\n");
     fprintf (serverhdrfile.stream, "#include \"%s.h\"\n\n", filename);

     packagelist = listnew();
     if (packagelist == NULL)
	 err (1, "init_generate: listnew: packagelist");
}

void
close_generator (const char *filename)
{
     char *fileupr;
	  
     fileupr = cppfilesymbolname(filename);
     fprintf (headerfile.stream, "\n#endif /* %s */\n", fileupr);
     free(fileupr);
     ydr_fclose (&headerfile);
     ydr_fclose (&clientfile);
     ydr_fclose (&serverfile);
     ydr_fclose (&clienthdrfile);
     ydr_fclose (&serverhdrfile);
     ydr_fclose (&ydrfile);
}

/*
 * Generate the server-side stub function for the function in s and
 * write it to the file f.
 */

void
generate_server_stub (Symbol *s, FILE *f, FILE *headerf, FILE *h_file)
{
     fprintf (headerf, "int S%s%s%s(\nstruct rx_call *call\n",
	      prefix, package, s->name);
     listiter (s->u.proc.arguments, gen1, headerf);
     fprintf (headerf, ");\n\n");

     fprintf (f, "static int ydr_ps_%s%s(\nstruct rx_call *call)\n",
	      package, s->name);
     fprintf (f, "{\n"
	      "int32_t _result;\n");
     listiter (s->u.proc.arguments, gendeclare, f);
     listiter (s->u.proc.arguments, genzero, f);
     fprintf (f, "\n");
     listiter (s->u.proc.arguments, gendecodein, f);
     fprintf (f, "_result = S%s%s%s(", prefix, package, s->name);
     if (/* s->u.proc.splitp */ 1) {
	  fprintf (f, "call");
	  if (!listemptyp (s->u.proc.arguments))
	       fprintf (f, ", ");
     }
     listiter (s->u.proc.arguments, genargs, f);
     fprintf (f, ");\n");
     fprintf (f, "if (_result) goto funcfail;\n");
     listiter (s->u.proc.arguments, genencodeout, f);
     listiter (s->u.proc.arguments, genfree, f);
     fprintf (f, "return _result;\n");
     if (!listemptyp(s->u.proc.arguments)) {
	 fprintf(f, "fail:\n");
	 listiter (s->u.proc.arguments, genfree, f);
	 fprintf(f, "return rx_GetCallError(call);\n");

     }
     fprintf(f, "funcfail:\n"
	     "return _result;\n"
	     "}\n\n");

     listaddtail (func_list, s);
     if (s->u.proc.flags & TMULTI)
	 generate_multi (s, h_file);
}

struct gencase_context {
    FILE *f;
    char *package;
};

static Bool
gencase (List *list, Listitem *item, void *arg)
{
     Symbol *s = (Symbol *)listdata (item);
     struct gencase_context *c = (struct gencase_context *)arg;
     FILE *f = c->f;

     if (c->package == s->u.proc.package) {
	 fprintf (f, "case %u: {\n"
		  "_result = ydr_ps_%s%s(call);\n"
		  "break;\n"
		  "}\n",
		  s->u.proc.id, s->u.proc.package, s->name);
     }
     return FALSE;
}

/*
 *
 */

void
generate_server_switch (FILE *c_file,
			FILE *h_file)
{
     Type optype = {YDR_TULONG};
     Listitem *li;
     struct gencase_context c;

     c.f = c_file;
     
     li = listhead (packagelist);
     while (li) {
	 c.package = (char *)listdata (li);

	 fprintf (h_file,
		  "int32_t %sExecuteRequest(struct rx_call *call);\n",
		  c.package);
	 
	 fprintf (c_file,
		  "int32_t %sExecuteRequest(struct rx_call *call)\n"
		  "{\n"
		  "unsigned opcode;\n"
		  "int32_t _result;\n",
		  c.package);
	 
	 encode_type ("opcode", &optype, c_file, DECODE_RX, SERVER);
	 fprintf (c_file, "switch(opcode) {\n");
	 
	 listiter (func_list, gencase, &c);
	 
	 fprintf (c_file, "default:\n"
 		  "_result = RXGEN_OPCODE;\n"
		  "}\n"
		  "return _result;\n"
		  "fail:\n"
		  "return rx_GetCallError(call);\n"
		  "}\n\n");

	 li = listnext (packagelist, li);
     }
}

/*
 *
 */

void
ydr_fopen (const char *name, const char *mode, ydr_file *f)
{
     int streamfd;

     asprintf (&f->curname, "%sXXXXXXXXXX", name);
     if (f->curname == NULL)
	 err (1, "malloc");

     streamfd = mkstemp(f->curname);
     if (streamfd < 0)
	 err (1, "mkstemp %s failed", f->curname);
     f->stream = fdopen (streamfd, mode);
     if (f->stream == NULL)
	 err (1, "open %s mode %s", f->curname, mode);
     f->newname = estrdup(name);
}

void
ydr_fclose (ydr_file *f)
{
     if (fclose (f->stream))
	 err (1, "close %s", f->curname);
     if (rename(f->curname, f->newname))
	 err (1, "rename %s, %s", f->curname, f->newname);
     free(f->curname);
     free(f->newname);
}
@


1.11
log
@afs cleanup, realloc strings, abort, etc.
testing by beck, hin, jose, fries. ok deraadt@@
@
text
@@


1.10
log
@TPOINTER -> YDR_TPOINTER
Somehow, cvs seems to have to have missed this change, probably a merge error.
@
text
@d207 1
a207 1
	       abort();
d455 1
a455 1
	  abort();
d1083 1
a1083 1
	  abort();
d1158 1
a1158 1
	       abort();
d1203 1
a1203 1
	abort();
d1244 1
a1244 1
	abort();
d1533 1
a1533 1
	       abort();
d1555 1
a1555 1
	       abort();
d1576 1
a1576 1
	       abort();
@


1.9
log
@Merge
@
text
@d1903 1
a1903 1
	if (a->type->type == TPOINTER) {
d1924 1
a1924 1
	 if (a->type->type == TPOINTER) {
@


1.8
log
@bump mktemp randomness from 6 to 10 X's
@
text
@d2 1
a2 1
 * Copyright (c) 1995 - 2000 Kungliga Tekniska Högskolan
d36 1
a36 1
RCSID("$KTH: output.c,v 1.73.2.1 2001/03/04 04:48:48 lha Exp $");
d43 1
a79 1
    td_file,
d82 1
a82 1
long tmpcnt = 0;
d119 2
d127 1
a127 1
	  case TCHAR :
d130 1
a130 1
	  case TUCHAR :
d133 1
a133 1
	  case TSHORT :
d136 2
a137 2
	  case TUSHORT :
	       fprintf (f, "u_int16_t %s", name);
d139 1
a139 1
	  case TLONG :
d142 2
a143 2
	  case TULONG :
	       fprintf (f, "u_int32_t %s", name);
d145 7
a151 1
	  case TSTRING :
d159 1
a159 1
	  case TPOINTER :
d171 2
a172 2
	  case TUSERDEF : 
	       if(type->symbol->type == TSTRUCT)
d177 1
a177 1
	  case TVARRAY :
d199 1
a199 1
	  case TARRAY :
d203 1
a203 1
	  case TOPAQUE :
d225 2
a226 1
 * In the case of a variable-sized type, return -1.
d240 3
d244 1
a244 1
	  *tot += sz;
d254 2
a255 1
     listiter (s->u.list, sizeof_struct_iter, &tot);
d263 6
a268 8
     case TCHAR :
     case TUCHAR :
/*	  return 1;*/
     case TSHORT :
     case TUSHORT :
/*	  return 2;*/
     case TLONG :
     case TULONG :
d270 4
a273 1
     case TSTRING :
d278 1
a278 1
     case TOPAQUE :
d280 1
a280 1
     case TUSERDEF :
d282 1
a282 1
     case TARRAY :
d288 11
a298 2
	  else
	       return t->size * sz;
d300 1
a300 3
     case TVARRAY :
	  return -1;
     case TPOINTER :
d311 1
a311 1
	  case TUNDEFINED :
d314 1
a314 1
	  case TSTRUCT :
d316 1
a316 1
	  case TENUM :
d318 1
a318 1
	  case TCONST :
d320 1
a320 1
	  case TENUMVAL :
d322 1
a322 1
	  case TTYPEDEF :
d349 14
a362 10
     for (item = listhead (s->u.list); 
	  item && listnext (s->u.list, item); 
	  item = listnext (s->u.list, item)) {
	  e = (Symbol *)listdata (item);

	  fprintf (f, "     %s = %d,\n", e->name, e->u.val);
     }
     e = (Symbol *)listdata (item);
     fprintf (f, "     %s = %d\n};\ntypedef enum %s %s;\n",
	      e->name, e->u.val, s->name, s->name);
d384 1
a384 1
     if (s->type == TCONST)
d388 6
a393 2
     if (sz != -1) {
	  char *name;
d396 1
a396 1
	  fprintf (f, "#define %s_SIZE %d\n", strupr (name), sz);
d405 1
a405 1
	  case TUNDEFINED :
d408 1
a408 1
	  case TSTRUCT :
d411 1
a411 1
	  case TENUM :
d414 1
a414 1
	  case TCONST :
d417 1
a417 1
	  case TENUMVAL :
d419 1
a419 1
	  case TTYPEDEF :
a430 2
/* XXX - still assumes that a word is 32 bits */

d436 19
a454 21
     else if (encodetype == ENCODE_RX || encodetype == ENCODE_MEM)
	 return "htonl";
#if 0
	  if (type->type == TSHORT || type->type == TUSHORT)
	       return "htons";
	  else if (type->type == TLONG || type->type == TULONG)
	       return "htonl";
	  else
	       abort();
#endif
     else if (encodetype == DECODE_RX || encodetype == DECODE_MEM)
	 return "ntohl";
#if 0
	  if (type->type == TSHORT || type->type == TUSHORT)
	       return "ntohs";
	  else if (type->type == TLONG || type->type == TULONG)
	       return "ntohl";
	  else
	       abort();
#endif
     else
d459 1
a459 1
 * encode/decode long
d463 2
a464 1
encode_long (char *name, Type *type, FILE *f, EncodeType encodetype)
d468 1
a468 1
	       fprintf (f, "{ u_int32_t u;\n"
d473 1
d478 1
a478 1
	       fprintf (f, "{ u_int32_t u;\n"
d482 1
a482 1
			"}\n", name,
d486 6
a491 5
	       fprintf (f, "{ int32_t tmp = %s(%s); "
			"if (*total_len < sizeof(int32_t)) goto fail;\n"
			"bcopy ((char*)&tmp, ptr, sizeof(int32_t)); "
			"ptr += sizeof(int32_t); "
			"*total_len -= sizeof(int32_t);}\n",
d496 3
a498 3
	       fprintf (f, "{ int32_t tmp; "
			"if (*total_len < sizeof(int32_t)) goto fail;"
			"bcopy (ptr, (char *)&tmp, sizeof(int32_t)); "
d500 3
a502 2
			"ptr += sizeof(int32_t); "
			"*total_len -= sizeof(int32_t);}\n", 
d511 12
d534 32
d626 1
a626 1
	              "bcopy ((char*)&tmp, ptr, sizeof(int16_t)); "
d635 1
a635 1
			"bcopy (ptr, (char *)&tmp, sizeof(int16_t)); "
d655 1
a655 1
     Type lentype = {TULONG};
d687 1
a687 1
			    "rx_Error(call) = ENOMEM;\n"
d692 10
a701 1
		   fprintf(f, "%s = malloc(len + 1);\n", nname);
d721 2
a722 2
	       fprintf (f, "ptr += len + (4 - (len %% 4) %% 4);\n"
			"*total_len -= len + (4 - (len %% 4) %% 4);\n}\n");
d737 8
a744 1
		   fprintf (f, "%s = malloc(len + 1);\n", nname);
d750 1
a750 1
			"*total_len -= len + (4 - (len %% 4) %% 4);\n}\n",
d770 12
d790 1
a790 1
     if (type->subtype->type == TOPAQUE) {
d840 1
a840 1
 * encode/decode TARRAY 
d850 1
a850 1
    if (type->subtype->type == TOPAQUE) {
d880 24
d912 2
a913 1
     Type lentype = {TULONG};
d918 13
a930 2
     encode_type (tmp, type->indextype ? type->indextype : &lentype,
		  f, encodetype, side);
d937 1
d939 1
a939 1
     if (type->subtype->type == TOPAQUE) {
a963 1
		   /* XXX bounce checking */
d966 2
d970 1
a970 1
			     "ptr += %s + (4 - (%s %% 4)) %% 4;\n"
d972 1
a972 1
			     name, tmp, tmp, tmp, tmp, tmp);
d975 2
a976 2
		   /* XXX bounce checking */
		    fprintf (f, "{\n"
d1007 1
a1007 1
    fprintf (f, "/* printing TVARRAY %s%s */\n", where, name);
d1009 1
a1009 1
    if (type->subtype->type == TOPAQUE) {
d1034 24
d1065 1
a1065 1
     Type booltype = {TULONG};
d1103 15
d1126 7
a1132 4
	  case TCHAR :
	  case TUCHAR :
#if 0
	       encode_char (name, type, f, encodetype);
d1134 3
a1136 5
#endif
	  case TSHORT :
	  case TUSHORT :
#if 0
	       encode_short (name, type, f, encodetype);
d1138 1
a1138 6
#endif
	  case TLONG :
	  case TULONG :
	       encode_long (name, type, f, encodetype);
	       break;
	  case TSTRING :
d1141 1
a1141 1
	  case TOPAQUE :
d1145 1
a1145 1
	  case TUSERDEF :
d1148 1
a1148 1
	  case TARRAY :
d1151 1
a1151 1
	  case TVARRAY :
d1154 1
a1154 1
	  case TPOINTER :
d1172 7
a1178 4
    case TCHAR :
    case TUCHAR :
#if 0
	print_char (name, type, f, encodetype);
d1180 3
a1182 5
#endif
    case TSHORT :
    case TUSHORT :
#if 0
	print_short (name, type, f, encodetype);
d1184 1
a1184 6
#endif
    case TLONG :
    case TULONG :
	print_long (where, name, type, f);
	break;
    case TSTRING :
d1187 1
a1187 1
    case TOPAQUE :
d1190 1
a1190 1
    case TUSERDEF :
d1193 1
a1193 1
    case TARRAY :
d1196 1
a1196 1
    case TVARRAY :
d1199 1
a1199 1
    case TPOINTER :
d1207 41
d1271 3
a1273 3
     if (s->type->type == TPOINTER
	 && s->type->subtype->type == TUSERDEF
	 && s->type->subtype->symbol->type == TSTRUCT
d1304 2
a1305 1
     listiter (s->u.list, encode_entry, (void *)&context);
d1331 3
a1333 3
     if (s->type->type == TPOINTER
	 && s->type->subtype->type == TUSERDEF
	 && s->type->subtype->symbol->type == TSTRUCT
d1370 64
a1433 1
    listiter (s->u.list, print_structentry, (void *)&context);
d1444 1
a1444 1
     Type type = {TLONG};
d1474 2
a1475 1
    listiter (s->u.list, gen_printenum, f);
d1505 10
d1523 1
a1523 1
	  case TSTRUCT :
d1526 1
a1526 1
	  case TENUM :
d1529 1
a1529 1
	  case TTYPEDEF :
d1545 1
a1545 1
	  case TSTRUCT :
d1548 1
a1548 1
	  case TENUM :
d1551 1
a1551 1
	  case TTYPEDEF :
d1560 21
d1587 4
a1590 1
     if (s->type == TSTRUCT || s->type == TENUM || s->type == TTYPEDEF) {
d1592 2
a1593 1
		   "char *ydr_%scode_%s(%s *o, char *ptr, size_t *total_len)",
d1595 7
a1601 3
		   s->name, s->name);
     } else if (s->type == TCONST || s->type == TENUMVAL 
	      || s->type == TTYPEDEF)
d1615 4
a1618 1
     if (s->type == TSTRUCT || s->type == TENUM || s->type == TTYPEDEF) {
d1622 26
a1647 2
     } else if (s->type == TCONST || s->type == TENUMVAL 
	      || s->type == TTYPEDEF)
d1661 4
a1664 1
     if (s->type == TSTRUCT || s->type == TENUM || s->type == TTYPEDEF) {
d1667 2
d1672 4
a1675 2
		   "fail:\n"
		   "errno = EFAULT;\n"
d1677 3
a1679 2
     } else if (s->type == TCONST || s->type == TENUMVAL 
	      || s->type == TTYPEDEF)
d1693 3
a1695 1
     if (s->type == TSTRUCT || s->type == TENUM || s->type == TTYPEDEF) {
d1700 26
a1725 2
     } else if (s->type == TCONST || s->type == TENUMVAL 
	      || s->type == TTYPEDEF)
d1739 4
a1742 1
     if (s->type == TSTRUCT || s->type == TENUM || s->type == TTYPEDEF) {
d1745 3
a1747 2
     } else if (s->type == TCONST || s->type == TENUMVAL 
	      || s->type == TTYPEDEF)
d1761 3
a1763 1
     if (s->type == TSTRUCT || s->type == TENUM || s->type == TTYPEDEF) {
d1766 25
a1790 2
     } else if (s->type == TCONST || s->type == TENUMVAL 
	      || s->type == TTYPEDEF)
d1804 2
a1805 2
	 && a->type->type != TPOINTER
	 && a->type->type != TSTRING)
d1847 1
a1847 1
     if (a->type->type == TPOINTER)
d1856 11
d1869 1
a1869 1
    if (type->type == TVARRAY)
d1871 1
a1871 1
    if (type->type == TPOINTER)
d1873 1
a1873 1
    if (type->type == TUSERDEF &&
d1875 1
a1875 1
	type->symbol->type == TTYPEDEF)
d1891 1
a1891 1
	      && a->type->type == TSTRING && a->type->size == 0)
d1932 1
a1932 1
	 } else if(a->type->type == TSTRING) {
d1948 1
a1948 1
	  if (a->type->type == TPOINTER) {
d1972 1
a1972 1
	  if (a->type->type == TPOINTER)
d2009 1
a2009 1
     if (a->type->type == TPOINTER
d2011 1
a2011 1
	     && a->type->type == TSTRING && a->type->size == 0))
d2026 1
a2026 1
     Type type = {TLONG};
d2051 1
a2051 1
	      "ret = %s(rx_Error(call));\n"
d2062 1
a2062 1
     Type type = {TLONG};
d2085 1
a2085 1
                 "return %s(rx_Error(call));\n",
d2106 1
a2106 1
                 "return %s(rx_Error(call));\n",
a2185 3
     fprintf (f, "#ifndef HAVE_BCOPY\n"
	      "#define bcopy(a,b,c) memcpy((b),(a),(c))\n"
	      "#endif /* !HAVE_BCOPY */\n\n");
d2187 1
a2187 1
	      "RCSID(\"%s generated from %s.xg with $KTH: output.c,v 1.73.2.1 2001/03/04 04:48:48 lha Exp $\");\n"
d2192 20
d2219 1
a2219 1
     char *fileuppr;
d2229 1
a2229 2
     fileuppr = estrdup (filename);
     strupr (fileuppr);
d2232 1
a2232 1
	      "#define _%s_\n\n", fileuppr, fileuppr);
d2234 1
a2234 1
     free (fileuppr);
a2276 6
     asprintf (&tmp, "%s.td.c", filename);
     if (tmp == NULL)
	 err (1, "malloc");
     ydr_fopen (tmp, "w", &td_file);
     free (tmp);

d2285 1
a2285 1
     char *fileupr = estrdup (filename);
d2287 1
a2287 1
     strupr (fileupr);
d2289 1
a2295 1
     ydr_fclose (&td_file);
d2306 1
a2306 3
     fprintf (headerf, "int _%s%s(\nstruct rx_call *call);\n",
	      package, s->name);
     fprintf (headerf, "int %s%s%s(\nstruct rx_call *call\n",
d2311 1
a2311 1
     fprintf (f, "int _%s%s(\nstruct rx_call *call)\n",
d2316 1
d2319 1
a2319 1
     fprintf (f, "_result = %s%s%s(", prefix, package, s->name);
d2334 1
a2334 1
	 fprintf(f, "return rx_Error(call);\n");
d2360 1
a2360 1
		  "_result = _%s%s(call);\n"
d2376 1
a2376 1
     Type optype = {TULONG};
a2403 1
		  "fprintf (stderr, \"Ignoring %%d\\n\", opcode);\n"
d2407 1
a2407 1
		  "return rx_Error(call);\n"
a2413 42
static Bool
gentcpdump_decode (List *list, Listitem *item, void *arg)
{
     Argument *a = (Argument *)listdata (item);
     FILE *f = (FILE *)arg;

     if (a->type->type == TPOINTER)
	 encode_type (a->name, a->type->subtype, f, ENCODE_MEM, CLIENT);
     else
	 encode_type (a->name, a->type, f, ENCODE_MEM, CLIENT);

     fprintf (f, "++found;\n");
     return FALSE;
}

/*
 *
 */

static Bool
gentcpdump_print (List *list, Listitem *item, void *arg)
{
     Argument *a = (Argument *)listdata (item);
     FILE *f = (FILE *)arg;

     fprintf (f, "if (found > 0)\n\n"
	      "{ --found;\n");

     if (a->type->type == TPOINTER)
	 display_type ("", a->name, a->type->subtype, f);
     else
	 display_type ("", a->name, a->type, f);

     if (listnextp(item))
	 fprintf (f, "printf(\",\");\n");
     
     fprintf (f, "} else\n"
	      "goto failandquit;\n");
     
     return FALSE;
}

a2416 88

void
generate_tcpdump_stub (Symbol *s, FILE *f)
{
     fprintf (f, "void %s%s_print(char *ptr, size_t *total_len)\n"
	      "{\n"
	      "int found = 0;\n",
	      package, s->name);
     listiter (s->u.proc.arguments, gendeclare, f);
     fprintf (f, "\n");

     listiter (s->u.proc.arguments, gentcpdump_decode, f);
     if (!listemptyp(s->u.proc.arguments))
	 fprintf(f, "fail:\n");
     fprintf (f, "printf(\"{\");");
     listiter (s->u.proc.arguments, gentcpdump_print, f);
     fprintf (f, "printf(\"}\\n\");");

     fprintf (f, "\nreturn ptr;\n");
     if (!listemptyp(s->u.proc.arguments))
	 fprintf(f, "failandquit:\n"
		 "printf(\"Error decoding paket\");\n"
		 "return NULL;");
     fprintf(f, "}\n\n");
}


static Bool
gentcpdump_case (List *list, Listitem *item, void *arg)
{
     Symbol *s = (Symbol *)listdata (item);
     FILE *f = (FILE *)arg;

     fprintf (f, "case %u:\n"
	      "printf(\"%s%s(\");\n"
	      "ret = %s%s_print(ptr, &total_len);\n"
	      "break;\n",
	      s->u.proc.id,
	      package,
	      s->name,
	      package,
	      s->name);

     return FALSE;
}

/*
 * generate tcpdump patches
 */


void
generate_tcpdump_patches(FILE *td_file, const char *filename)
{
    Type optype = {TULONG};

    fprintf(td_file, "/* generated by $KTH: output.c,v 1.73.2.1 2001/03/04 04:48:48 lha Exp $ */\n\n");

    fprintf (td_file, 
	     "#include <stdio.h>\n"
	     "#include <stdlib.h>\n"
	     "#include \"%s.h\"\n",
	     filename);

    fprintf (td_file, "%stcpdump_print(const unsigned char *ptr,"
	     "unsigned int len,"
	     "unsigned char *bp2)\n"
	     "{\n"
	     "u_int32_t opcode;\n"
	     "size_t *total_len = len;\n"
	     "char *ret;\n",
	     package);
    
    encode_type ("opcode", &optype, td_file, DECODE_MEM, CLIENT);

    fprintf (td_file, "switch(opcode) {\n");

    listiter (func_list, gentcpdump_case, td_file);
    
    fprintf (td_file, "default:\n"
	     "printf (\"Unknown opcode %%s->%%d\\n\", "
	     "package, opcode);\n"
	     "}\n"
	     "fail:\n"
	     "printf(\"Error decoding packet\\n\");\n"
	     "}\n\n");

}
@


1.7
log
@strcpy->strlcpy

ok deraadt
@
text
@d2129 1
a2129 1
     asprintf (&f->curname, "%sXXXXXX", name);
@


1.6
log
@more afs string cleaning; pvalchev ok
@
text
@d185 1
a185 1
	       strcpy(s + strlen(s) - 3, "val");
@


1.5
log
@strcpy/strcat/sprintf cleanups; ok krw deraadt
@
text
@d154 1
d156 1
a156 1
	       tmp = (char *)emalloc (strlen(name) + 2);
d158 1
a158 1
	       strcpy (tmp+1, name);
d172 1
d174 1
a174 1
	       s = (char *)emalloc (strlen (name) + 6);
d176 2
a177 2
	       strcpy (s + 1, name);
	       strcat (s, "_len");
d789 2
a790 2
     strcpy (tmp, name);
     strcat (tmp, ".len");
d1056 3
a1058 3
     strcpy (tmp, context->name);
     strcat (tmp, ".");
     strcat (tmp, s->name);
d1488 2
a1489 1
	    char *tmp = (char *)emalloc (strlen (a->name) + 4);
d1491 1
a1491 1
	    sprintf (tmp, "(*%s)", a->name);
@


1.4
log
@merge
@
text
@d903 1
a903 1
     sprintf (tmp, "*(%s)", name);
d1506 2
a1507 1
	     char *tmp = (char *)emalloc (strlen (a->name) + 4);
d1509 1
a1509 1
	     sprintf (tmp, "(*%s)", a->name);
d1531 2
a1532 1
	       char *tmp = (char *)emalloc (strlen (a->name) + 4);
d1534 1
a1534 1
	       sprintf (tmp, "(*%s)", a->name);
@


1.3
log
@New Arla userland from Arla between 0.34.2 and current in arla cvs.
Too many new features and fixes to mention here.
@
text
@d17 1
a17 6
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by the Kungliga Tekniska
 *      Högskolan and its contributors.
 * 
 * 4. Neither the name of the Institute nor the names of its contributors
d36 1
a36 1
RCSID("$Id: output.c,v 1.68 2000/08/20 00:23:30 assar Exp $");
d74 1
a74 1
fileblob headerfile,
d95 4
a98 1
static void print_type (char *name, Type *type, enum argtype argtype, FILE *f);
d121 2
a122 1
print_type (char *name, Type *type, enum argtype argtype, FILE *f)
d144 1
a144 1
	       if (type->size)
d146 1
a146 1
	       else if (argtype != TIN)
d158 1
a158 1
	       print_type (tmp, type->subtype, argtype, f);
d179 1
a179 1
		    print_type ("len", type->indextype, argtype, f);
d184 1
a184 1
	       print_type ("*val", type->subtype, argtype, f);
d190 1
a190 1
	       print_type (name, type->subtype, argtype, f);
d208 1
a208 1
     print_type (s->name, s->type, TIN, f);
d348 1
a348 1
     print_type (s->name, s->u.type, TIN, f);
d584 3
a586 1
	       (type->size == 0) && side == CLIENT ? "*" : "", name);
d794 1
a794 1
	 print_type ("*", type->subtype, TIN, f);
d796 1
a796 1
	 print_type ("", type->subtype, TIN, f);
d1404 1
a1404 1
     print_type (a->name, a->type, a->argtype, f);
d1417 1
a1417 1
	  print_type (a->name, a->type, a->argtype, f);
d1441 1
a1441 1
	  print_type (a->name, a->type->subtype, TIN, f);
d1443 1
a1443 1
	  print_type (a->name, a->type, TIN, f);
d1481 15
a1495 17
     Argument *a = (Argument *)listdata (item);
     FILE *f = (FILE *)arg;

     if (a->argtype != TIN && a->argtype != TINOUT)
	  return TRUE;
     else {
	  if (a->type->type == TPOINTER) {
	       char *tmp = (char *)emalloc (strlen (a->name) + 4);
	       
	       sprintf (tmp, "(*%s)", a->name);

	       encode_type (tmp, a->type->subtype, f, ENCODE_RX, CLIENT);
	       free (tmp);
	  } else
	       encode_type (a->name, a->type, f, ENCODE_RX, CLIENT);
	  return FALSE;
     }
d1769 1
a1769 1
	      "RCSID(\"%s generated from %s.xg with $Id: output.c,v 1.68 2000/08/20 00:23:30 assar Exp $\");\n"
d1788 1
a1788 1
     eefopen (tmp, "w", &headerfile);
d1802 1
a1802 1
     eefopen (tmp, "w", &ydrfile);
d1809 1
a1809 1
     eefopen (tmp, "w", &clientfile);
d1817 1
a1817 1
     eefopen (tmp, "w", &serverfile);
d1825 1
a1825 1
     eefopen (tmp, "w", &clienthdrfile);
d1834 1
a1834 1
     eefopen (tmp, "w", &serverhdrfile);
d1843 1
a1843 1
     eefopen (tmp, "w", &td_file);
d1858 7
a1864 7
     eefclose (&headerfile);
     eefclose (&clientfile);
     eefclose (&serverfile);
     eefclose (&clienthdrfile);
     eefclose (&serverhdrfile);
     eefclose (&ydrfile);
     eefclose (&td_file);
d1885 1
a1885 1
	      "int _result;\n");
d1964 1
a1964 1
		  "int _result;\n",
d2086 1
a2086 1
    fprintf(td_file, "/* generated by $Id: output.c,v 1.68 2000/08/20 00:23:30 assar Exp $ */\n\n");
d2117 29
@


1.2
log
@upgrade Arla to fresher code. Too many new features and bugfixes.
@
text
@a0 1
/*	$OpenBSD$	*/
d2 1
a2 1
 * Copyright (c) 1995, 1996, 1997, 1998, 1999 Kungliga Tekniska Högskolan
d41 1
a41 1
RCSID("$KTH: output.c,v 1.56 1999/03/05 05:13:56 assar Exp $");
a47 2
#include <eefile.h>
#include <strutil.h>
d62 7
d90 2
a91 1
 * Function to convert error codes with (if non-NULL)
d94 1
a94 1
char *error_function = NULL;
d98 3
a100 1
static void print_type (char *name, Type *type, FILE *f);
d109 1
a109 2
			 EncodeType encodetype);
static void print_type (char *name, Type *type, FILE *f);
d113 3
a115 2
			   EncodeType encodetype);
static void encode_enum (Symbol *s, char *name, FILE *f, EncodeType encodetype);
d117 1
a117 1
			    EncodeType encodetype);
d119 1
a119 1
			   EncodeType encodetype);
d123 1
a123 1
print_type (char *name, Type *type, FILE *f)
d147 2
d159 1
a159 1
	       print_type (tmp, type->subtype, f);
d180 1
a180 1
		    print_type ("len", type->indextype, f);
d185 1
a185 1
	       print_type ("*val", type->subtype, f);
d191 1
a191 1
	       print_type (name, type->subtype, f);
d209 1
a209 1
     print_type (s->name, s->type, f);
d315 2
a316 1
     listiter (s->u.list, print_entry, f);
d349 1
a349 1
     print_type (s->name, s->u.type, f);
d578 2
a579 1
encode_string (char *name, Type *type, FILE *f, EncodeType encodetype)
d582 4
d595 1
a595 1
	       encode_type ("len", &lentype, f, encodetype);
d607 1
a607 1
	       encode_type ("len", &lentype, f, encodetype);
d610 4
a613 2
			    "if (len >= %u)\n"
			    "abort();\n",
d616 1
a616 1
		   fprintf(f, "%s = malloc(len + 1);\n", name);
d626 1
a626 1
			"}\n", name, name);
d634 1
a634 1
	       encode_type ("len", &lentype, f, encodetype);
d642 1
a642 1
	       encode_type ("len", &lentype, f, encodetype);
d649 1
a649 1
			    "abort();\n",
d652 1
a652 1
		   fprintf (f, "%s = malloc(len + 1);\n", name);
d659 1
a659 1
			name, name);
d664 1
d683 2
a684 1
encode_array (char *name, Type *type, FILE *f, EncodeType encodetype)
d727 3
a729 1
	  encode_type (tmp , type->subtype, f, encodetype);
d780 2
a781 1
encode_varray (char *name, Type *type, FILE *f, EncodeType encodetype)
d790 1
a790 1
		  f, encodetype);
d793 1
a793 1
	 print_type ("*", type->subtype, f);
d795 1
a795 1
	 print_type ("", type->subtype, f);
d848 3
a850 1
	  encode_type (tmp , type->subtype, f, encodetype);
d896 2
a897 1
encode_pointer (char *name, Type *type, FILE *f, EncodeType encodetype)
d910 1
a910 1
	  encode_type ("bool", &booltype, f, encodetype);
d912 1
a912 1
	  encode_type (tmp, type->subtype, f, encodetype);
d920 1
a920 1
	  encode_type ("bool", &booltype, f, encodetype);
d925 1
a925 1
	  encode_type (tmp, type->subtype, f, encodetype);
d941 2
a942 1
encode_type (char *name, Type *type, FILE *f, EncodeType encodetype)
d962 1
a962 1
	       encode_string (name, type, f, encodetype);
d969 1
a969 1
	       encode_symbol (type->symbol, name, f, encodetype);
d972 1
a972 1
	       encode_array (name, type, f, encodetype);
d975 1
a975 1
	       encode_varray (name, type, f, encodetype);
d978 1
a978 1
	       encode_pointer (name, type, f, encodetype);
d1039 1
d1067 2
a1068 1
	 encode_type (tmp, s->type, context->f, context->encodetype);
d1079 2
a1080 1
encode_struct (Symbol *s, char *name, FILE *f, EncodeType encodetype)
d1088 1
d1163 2
a1164 1
encode_enum (Symbol *s, char *name, FILE *f, EncodeType encodetype)
a1166 4
     char tmp[256];

     strcpy (tmp, "(int)");
     strcat (tmp, name);
d1168 1
a1168 1
     encode_type (tmp, &type, f, encodetype);
d1209 2
a1210 1
encode_typedef (Symbol *s, char *name, FILE *f, EncodeType encodetype)
d1212 1
a1212 1
     encode_type (name, s->u.type, f, encodetype);
d1230 2
a1231 1
encode_symbol (Symbol *s, char *name, FILE *f, EncodeType encodetype)
d1235 1
a1235 1
	       encode_struct (s, name, f, encodetype);
d1238 1
a1238 1
	       encode_enum (s, name, f, encodetype);
d1241 1
a1241 1
	       encode_typedef (s, name, f, encodetype);
d1319 2
a1320 1
	  encode_symbol (s, "(*o)", f, encodep ? ENCODE_MEM : DECODE_MEM);
d1403 1
a1403 1
     print_type (a->name, a->type, f);
d1415 2
a1416 2
	  fprintf (f, ", ");
	  print_type (a->name, a->type, f);
d1440 1
a1440 1
	  print_type (a->name, a->type->subtype, f);
d1442 1
a1442 1
	  print_type (a->name, a->type, f);
d1471 3
a1473 1

d1491 1
a1491 1
	       encode_type (tmp, a->type->subtype, f, ENCODE_RX);
d1494 1
a1494 1
	       encode_type (a->name, a->type, f, ENCODE_RX);
d1511 1
a1511 1
	     encode_type (tmp, a->type->subtype, f, DECODE_RX);
d1514 1
a1514 1
	     encode_type (a->name, a->type, f, DECODE_RX);
d1535 1
a1535 1
	       encode_type (tmp, a->type->subtype, f, DECODE_RX);
d1538 1
a1538 1
	       encode_type (a->name, a->type->subtype, f, DECODE_RX);
d1540 1
a1540 1
	       encode_type (a->name, a->type, f, DECODE_RX);
d1553 1
a1553 1
	       encode_type (a->name, a->type->subtype, f, ENCODE_RX);
d1555 1
a1555 1
	       encode_type (a->name, a->type, f, ENCODE_RX);
d1589 3
a1591 1
     if (a->type->type == TPOINTER)
d1624 1
a1624 1
     encode_type (op, &type, f, ENCODE_RX);
d1629 1
a1629 1
	      "return rx_EndCall (call,0);\n"
d1635 2
a1636 1
	      error_function ? error_function : "");
d1657 1
a1657 1
     encode_type (op, &type, f, ENCODE_RX);
d1666 1
a1666 1
		  error_function ? error_function : "");
d1687 1
a1687 1
		  error_function ? error_function : "");
d1770 1
a1770 1
	      "RCSID(\"%s generated from %s.xg with $KTH: output.c,v 1.56 1999/03/05 05:13:56 assar Exp $\");\n"
d1846 4
d1917 5
d1926 2
a1927 1
     FILE *f = (FILE *)arg;
d1929 7
a1935 5
     fprintf (f, "case %u: {\n"
	      "_result = _%s%s(call);\n"
	      "break;\n"
	      "}\n",
	      s->u.proc.id, package, s->name);
d1948 4
d1953 28
a1980 3
     fprintf (h_file,
	      "int %sExecuteRequest(struct rx_call *call);\n",
	      package);
d1982 2
a1983 18
     fprintf (c_file, "int %sExecuteRequest(struct rx_call *call)\n"
	      "{\n"
	      "unsigned opcode;\n"
	      "int _result;\n",
	      package);

     encode_type ("opcode", &optype, c_file, DECODE_RX);
     fprintf (c_file, "switch(opcode) {\n");

     listiter (func_list, gencase, c_file);

     fprintf (c_file, "default:\n"
	      "fprintf (stderr, \"Ignoring %%d\\n\", opcode);\n"
	      "}\n"
	      "return _result;\n"
	      "fail:\n"
	      "return rx_Error(call);\n"
	      "}\n\n");
d1993 1
a1993 1
	 encode_type (a->name, a->type->subtype, f, ENCODE_MEM);
d1995 1
a1995 1
	 encode_type (a->name, a->type, f, ENCODE_MEM);
d2087 1
a2087 1
    fprintf(td_file, "/* generated by $KTH: output.c,v 1.56 1999/03/05 05:13:56 assar Exp $ */\n\n");
d2104 1
a2104 1
    encode_type ("opcode", &optype, td_file, DECODE_MEM);
a2118 2


@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
 * Copyright (c) 1995, 1996, 1997, 1998 Kungliga Tekniska Högskolan
d42 1
a42 1
RCSID("$KTH: output.c,v 1.31 1998/09/06 23:33:39 assar Exp $");
d46 2
d49 1
a49 2
#include <efile.h>
#include <string.h>
d51 1
a51 1
#include <mem.h>
d65 7
d75 7
a81 6
FILE *headerfile,
    *clientfile,
    *serverfile,
    *clienthdrfile,
    *serverhdrfile,
    *ydrfile;
d83 7
a89 1
long tmpcnt = 0 ;
a92 1

d103 2
d113 1
d138 4
a141 1
	       fprintf (f, "char %s[%d]", name, type->size);
d255 1
a255 1
	  return -1;
d355 1
a355 1
	  name = strdup (s->name);
d366 1
a366 1
	       fprintf (f, "What is %s doing in generate_heaer?", s->name);
d422 4
d449 1
a449 1
			"if (*total_len < sizeof(int32_t)) { errno = EFAULT; return NULL ; } "
d458 1
a458 1
			"if (*total_len < sizeof(int32_t)) { errno = EFAULT; return NULL ; } "
d471 4
a474 1
#ifdef not_yet
d476 10
d502 1
a502 1
	       fprintf (f, "{ if (*total_len < sizeof(char)) { errno = EFAULT; return NULL ; } "
d508 1
a508 1
	       fprintf (f, "{ if (*total_len < sizeof(char)) { errno = EFAULT; return NULL ; } "
d518 1
a518 1
static void
d534 1
a534 1
			"goto fail;\n"
d540 6
a545 6
	       fprintf (f, "{ in16_t tmp = %s(%s); "
			"if (*total_len < sizeof(int16_t)) { errno = EFAULT; return NULL ; } "
			"bcopy ((char*)&tmp, ptr, sizeof(int16_t)); "
			"ptr += sizeof(int16_t); "
			"*total_len -= sizeof(int16_t);}\n", 
			encode_function (type, encodetype),
d550 1
a550 1
			"if (*total_len < sizeof(int16_t)) { errno = EFAULT; return NULL ; } " 
d562 4
a565 1
#endif
d593 1
a593 1
	       if (type->size != 0)
d598 4
d614 1
a614 1
			"if (*total_len < len) { errno = EFAULT; return NULL ; } "
d619 2
a620 1
	       fprintf (f, "ptr += len + (4 - (len %% 4) %% 4);\n}\n");
d627 11
a637 2
			"if (*total_len < len) { errno = EFAULT; return NULL ; }\n"
			"*total_len -= len;\n"
d640 2
a641 1
			"ptr += len + (4 - (len %% 4)) %% 4;\n}\n",
d649 15
d669 1
a669 1
	       error_message ("Opaque array should be"
d685 1
a685 1
		    fprintf (f, "if (*total_len < %u) { errno = EFAULT; return NULL ; }\n"
d692 1
a692 1
		    fprintf (f, "if (*total_len < %u) { errno = EFAULT; return NULL ; }\n"
d714 44
d832 39
d911 4
d939 2
a940 1
	       error_message ("Type opaque only allowed as part of an array");
d959 49
d1015 4
d1046 4
d1063 69
d1144 37
d1187 14
d1220 22
d1257 20
a1276 1
	  error_message ("What is %s (type %d) doing here?\n",
d1291 4
a1294 1
	  fprintf (f, "return ptr;\n}\n");
d1299 21
a1319 1
	  error_message ("What is %s (type %d) doing here?\n",
d1337 19
a1355 1
	  error_message ("What is %s (type %d) doing here?\n",
d1368 1
a1368 1
	 error_message ("Argument %s is OUT and not pointer or string.\n",
d1597 1
a1597 1
	      "ret = rx_Error(call);\n"
d1600 2
a1601 1
	      "}\n");
d1630 3
a1632 1
		  "return rx_Error(call);\n");
d1651 3
a1653 1
		  "return rx_Error(call);\n");
d1657 46
d1719 20
d1744 1
a1744 1
init_generate (char *filename)
d1751 7
a1757 4
     tmp = (char *)emalloc (strlen (filename) + 17);
     sprintf (tmp, "%s.h", filename);
     headerfile = efopen (tmp, "w");
     fileuppr = strdup (filename);
d1759 2
a1760 2
     fprintf (headerfile, "/* Generated from %s.xg */\n", filename);
     fprintf (headerfile, "#ifndef _%s_\n"
d1762 1
d1765 6
a1770 12
     sprintf (tmp, "%s.ydr.c", filename);
     ydrfile = efopen (tmp, "w");
     fprintf (ydrfile, "/* Generated from %s.xg */\n", filename);
     fprintf (ydrfile, "#include <%s.h>\n\n", filename);
     fprintf (ydrfile, "#include <stdio.h>\n");
     fprintf (ydrfile, "#include <stdlib.h>\n");
     fprintf (ydrfile, "#include <sys/types.h>\n");
     fprintf (ydrfile, "#include <netinet/in.h>\n");
     fprintf (ydrfile, "#include <roken.h>\n");
     fprintf (ydrfile, "#ifndef HAVE_BCOPY\n"
	      "#define bcopy(a,b,c) memcpy((b),(a),(c))\n"
	      "#endif /* !HAVE_BCOPY */\n\n");
d1772 7
a1778 13
     sprintf (tmp, "%s.cs.c", filename);
     clientfile = efopen (tmp, "w");
     fprintf (clientfile, "/* Generated from %s.xg */\n", filename);
     fprintf (clientfile, "#include \"%s.h\"\n\n", filename);
     fprintf (clientfile, "#include \"%s.cs.h\"\n\n", filename);
     fprintf (clientfile, "#include <stdio.h>\n");
     fprintf (clientfile, "#include <stdlib.h>\n");
     fprintf (clientfile, "#include <sys/types.h>\n");
     fprintf (clientfile, "#include <netinet/in.h>\n");
     fprintf (clientfile, "#include <roken.h>\n");
     fprintf (clientfile, "#ifndef HAVE_BCOPY\n"
	      "#define bcopy(a,b,c) memcpy((b),(a),(c))\n"
	      "#endif /* !HAVE_BCOPY */\n\n");
d1780 7
a1786 22
     sprintf (tmp, "%s.ss.c", filename);
     serverfile = efopen (tmp, "w");
     fprintf (serverfile, "/* Generated from %s.xg */\n", filename);
     fprintf (serverfile, "#include \"%s.h\"\n\n", filename);
     fprintf (serverfile, "#include \"%s.ss.h\"\n\n", filename);
     fprintf (serverfile, "#include <stdio.h>\n");
     fprintf (serverfile, "#include <stdlib.h>\n");
     fprintf (serverfile, "#include <sys/types.h>\n");
     fprintf (serverfile, "#include <netinet/in.h>\n");
     fprintf (serverfile, "#include <roken.h>\n");
     fprintf (serverfile, "#ifndef HAVE_BCOPY\n"
	      "#define bcopy(a,b,c) memcpy((b),(a),(c))\n"
	      "#endif /* !HAVE_BCOPY */\n\n");

     sprintf (tmp, "%s.cs.h", filename);
     clienthdrfile = efopen (tmp, "w");
     fprintf (clienthdrfile, "/* Generated from %s.xg */\n", filename);

     sprintf (tmp, "%s.ss.h", filename);
     serverhdrfile = efopen (tmp, "w");
     fprintf (serverhdrfile, "/* Generated from %s.xg */\n", filename);
     fprintf (serverhdrfile, "#include <rx/rx.h>\n");
d1788 22
d1814 1
a1814 1
close_generator (char *filename)
d1816 1
a1816 1
     char *fileupr = strdup (filename);
d1819 8
a1826 7
     fprintf (headerfile, "\n#endif /* %s */\n", fileupr);
     efclose (headerfile);
     efclose (clientfile);
     efclose (serverfile);
     efclose (clienthdrfile);
     efclose (serverhdrfile);
     efclose (ydrfile);
d1835 1
a1835 1
generate_server_stub (Symbol *s, FILE *f, FILE *headerf)
d1839 2
a1840 2
     fprintf (headerf, "int %s%s(\nstruct rx_call *call\n",
	      package, s->name);
d1851 1
a1851 1
     fprintf (f, "_result = %s%s(", package, s->name);
d1859 1
d1863 9
a1871 4
     if (!listemptyp(s->u.proc.arguments))
	 fprintf(f, "fail:\n"
		 "return rx_Error(call);\n");
     fprintf(f, "}\n\n");
d1874 2
d1925 136
@


1.1.1.1
log
@Initial version of Arla, a free implementation of an AFS cache-manager.
(second try, hopefully into the correct repository this time)
@
text
@@


1.1.1.2
log
@Import of arla-0.35.7
@
text
@d1 1
d3 1
a3 1
 * Copyright (c) 1995 - 2000 Kungliga Tekniska Högskolan
d18 6
a23 1
 * 3. Neither the name of the Institute nor the names of its contributors
d42 1
a42 1
RCSID("$KTH: output.c,v 1.73.2.1 2001/03/04 04:48:48 lha Exp $");
d46 2
a47 1
#include <assert.h>
d49 2
a50 2
#include <list.h>
#include <err.h>
a63 14
 * This is the list of packages so we know how to generate
 * all Execute_package().
 */

List *packagelist = NULL;

/*
 * Add this in front of the real functions implementing the server
 * functions called.
 */

char *prefix = "";

/*
d67 6
a72 9
ydr_file headerfile,
    clientfile,
    serverfile,
    clienthdrfile,
    serverhdrfile,
    td_file,
    ydrfile;

long tmpcnt = 0;
d74 1
a74 6
/*
 * Function to convert error codes with.
 * (the default, the empty string, conveniently means no conversion.)
 */

char *error_function = "";
a77 1
typedef enum { CLIENT, SERVER } Side;
d79 1
a79 4
typedef enum { FDECL, VDECL } DeclType;

static void print_type (char *name, Type *type, enum argtype argtype, 
			DeclType decl, FILE *f);
d88 1
a88 2
			 EncodeType encodetype, Side side);
static void display_type (char *where, char *name, Type *type, FILE *f);
d91 2
a92 3
			   EncodeType encodetype, Side side);
static void encode_enum (Symbol *s, char *name, FILE *f,
			 EncodeType encodetype, Side side);
d94 1
a94 1
			    EncodeType encodetype, Side side);
d96 1
a96 2
			   EncodeType encodetype, Side side);
static void print_symbol (char *where, Symbol *s, char *name, FILE *f);
d99 1
a99 2
print_type (char *name, Type *type, enum argtype argtype, 
	    DeclType decl, FILE *f)
d121 1
a121 6
	       if (type->size && decl == VDECL)
		   fprintf (f, "char %s[%d]", name, type->size);
	       else if (argtype != TIN && type->size == 0)
		   fprintf (f, "char **%s", name);
	       else
		   fprintf (f, "char *%s", name);
d130 1
a130 1
	       print_type (tmp, type->subtype, argtype, decl, f);
d151 1
a151 1
		    print_type ("len", type->indextype, argtype, decl, f);
d156 1
a156 1
	       print_type ("*val", type->subtype, argtype, decl, f);
d162 1
a162 1
	       print_type (name, type->subtype, argtype, decl, f);
d180 1
a180 1
     print_type (s->name, s->type, TIN, VDECL, f);
d235 1
a235 1
	  return 1;
d286 1
a286 2
     if (s->u.list)
	 listiter (s->u.list, print_entry, f);
d319 1
a319 1
     print_type (s->name, s->u.type, TIN, VDECL, f);
d335 1
a335 1
	  name = estrdup (s->name);
d346 1
a346 1
	       fprintf (f, "What is %s doing in generate_header?", s->name);
a401 4
/*
 * encode/decode long
 */

d425 1
a425 1
			"if (*total_len < sizeof(int32_t)) goto fail;\n"
d434 1
a434 1
			"if (*total_len < sizeof(int32_t)) goto fail;"
d447 1
a447 4
/*
 * print long
 */ 

a448 10
print_long (char *where, char *name, Type *type, FILE *f)
{
    fprintf (f, "printf(\" %s = %%d\", %s%s);", name, where, name);
}

/*
 *
 */

static void __attribute__ ((unused))
d465 1
a465 1
	       fprintf (f, "{ if (*total_len < sizeof(char)) goto fail;\n"
d471 1
a471 1
	       fprintf (f, "{ if (*total_len < sizeof(char)) goto fail;\n"
d481 1
a481 1
static void __attribute__ ((unused))
d497 1
a497 1
	                "goto fail;\n"
d503 6
a508 6
	  fprintf (f, "{ in16_t tmp = %s(%s); "
	  	      "if (*total_len < sizeof(int16_t)) goto fail;\n"
	              "bcopy ((char*)&tmp, ptr, sizeof(int16_t)); "
	              "ptr += sizeof(int16_t); "
	              "*total_len -= sizeof(int16_t);}\n", 
	                encode_function (type, encodetype),
d513 1
a513 1
			"if (*total_len < sizeof(int16_t)) goto fail;\n"
d525 1
a525 4

/*
 * encode/decode TSTRING
 */
d528 1
a528 2
encode_string (char *name, Type *type, FILE *f, EncodeType encodetype,
	       Side side)
a530 6
     char *nname;

     asprintf (&nname, "(%s%s)",
	       ((type->size == 0) && side == CLIENT 
		&& (encodetype == ENCODE_RX || encodetype == ENCODE_MEM))
	       ? "*" : "", name);
d540 1
a540 1
	       encode_type ("len", &lentype, f, encodetype, side);
d552 2
a553 2
	       encode_type ("len", &lentype, f, encodetype, side);
	       if (type->size != 0) {
d555 2
a556 4
			    "if (len >= %u) {\n"
			    "rx_Error(call) = ENOMEM;\n"
			    "goto fail;\n"
			    "}\n",
a557 4
	       } else {
		   fprintf(f, "%s = malloc(len + 1);\n", nname);
	       }

d565 1
a565 1
			"}\n", nname, nname);
d570 1
a570 1
			"if (*total_len < len) goto fail;\n"
d573 1
a573 1
	       encode_type ("len", &lentype, f, encodetype, side);
d575 1
a575 2
	       fprintf (f, "ptr += len + (4 - (len %% 4) %% 4);\n"
			"*total_len -= len + (4 - (len %% 4) %% 4);\n}\n");
d580 1
a580 12
	       encode_type ("len", &lentype, f, encodetype, side);
	       fprintf (f,
			"if (*total_len < len) goto fail;\n"
			"*total_len -= len;\n");
	       if (type->size != 0) {
		   fprintf (f,
			    "if(len >= %u)\n"
			    "goto fail;\n",
			    type->size);
	       } else {
		   fprintf (f, "%s = malloc(len + 1);\n", nname);
	       }
d582 2
d586 2
a587 3
			"ptr += len + (4 - (len %% 4)) %% 4;\n"
			"*total_len -= len + (4 - (len %% 4) %% 4);\n}\n",
			nname, nname);
a591 1
     free (nname);
a593 15
/*
 * print TSTRING
 */

static void
print_string (char *where, char *name, Type *type, FILE *f)
{
    fprintf (f, "/* printing TSTRING %s%s */\n", where, name);
    fprintf (f, "printf(\" %s = %%s\", %s%s);", name, where, name);
}

/*
 * encode/decode TARRAY 
 */

d595 1
a595 2
encode_array (char *name, Type *type, FILE *f, EncodeType encodetype,
	      Side side)
d599 1
a599 1
	       error_message (1, "Opaque array should be"
d615 1
a615 1
		    fprintf (f, "if (*total_len < %u) goto fail;\n"
d622 1
a622 1
		    fprintf (f, "if (*total_len < %u) goto fail;"
d638 1
a638 3
	  if (type->flags)
	      type->subtype->flags |= type->flags;
	  encode_type (tmp , type->subtype, f, encodetype, side);
a643 44
/*
 * encode/decode TARRAY 
 */

static void
print_array (char *where, char *name, Type *type, FILE *f)
{
    fprintf (f, "{\nunsigned int i%lu;\n", tmpcnt);

    fprintf (f, "/* printing ARRAY %s%s */\n", where, name);

    if (type->subtype->type == TOPAQUE) {
	if (type->size % 4 != 0)
	    error_message (1, "print_array: Opaque array should be"
			   "multiple of 4");
	
	fprintf (f, "char *ptr = %s%s;\n", where, name);
	fprintf (f, "printf(\"0x\");");
	fprintf (f, "for (i%lu = 0; i%lu < %d; ++i%lu)\n"
		 "printf(\"%%x\", ptr[i%lu]);",
		 tmpcnt, tmpcnt,
		 type->size, tmpcnt, tmpcnt);

     } else {
	char *ptr;
	fprintf (f, "for (i%lu = 0; i%lu < %d; ++i%lu) {\n", 
		 tmpcnt, tmpcnt, type->size, tmpcnt);
	asprintf(&ptr, "%s%s[i%ld]", where, name, tmpcnt);
	tmpcnt++;
	display_type (ptr, "", type->subtype, f);
	tmpcnt--;
	free(ptr);
	fprintf (f, "\nif (i%lu != %d - 1) printf(\",\");\n", 
		 tmpcnt, type->size);
	
	fprintf (f, "}\n");
     }
    fprintf (f, "}\n");
}

/*
 * encode/decode TVARRAY
 */

d645 1
a645 2
encode_varray (char *name, Type *type, FILE *f, EncodeType encodetype,
	       Side side)
d654 1
a654 1
		  f, encodetype, side);
d657 1
a657 1
	 print_type ("*", type->subtype, TIN, VDECL, f);
d659 1
a659 1
	 print_type ("", type->subtype, TIN, VDECL, f);
d712 1
a712 3
	  if (type->flags)
	      type->subtype->flags |= type->flags;
	  encode_type (tmp , type->subtype, f, encodetype, side);
a717 39
/*
 * print TVARRAY
 */

static void
print_varray (char *where, char *name, Type *type, FILE *f)
{
    fprintf (f, "{\nunsigned int i%lu;\n", tmpcnt);

    fprintf (f, "/* printing TVARRAY %s%s */\n", where, name);

    if (type->subtype->type == TOPAQUE) {
	fprintf (f, "char *ptr = %s%s.val;\n", where, name);
	fprintf (f, "printf(\"0x\");");
	fprintf (f, "for (i%lu = 0; i%lu < %s%s.len; ++i%lu)\n"
		 "printf(\"%%x\", ptr[i%lu]);",
		 tmpcnt, tmpcnt,
		 where, name, tmpcnt, tmpcnt);
    } else {
	char *ptr;
	fprintf (f, "for (i%lu = 0; i%lu < %s%s.len; ++i%lu) {\n", 
		 tmpcnt, tmpcnt, where, name, tmpcnt);
	asprintf(&ptr, "%s%s.val[i%ld]", where, name, tmpcnt);
	tmpcnt++;
	display_type (ptr, "", type->subtype, f);
	tmpcnt--;
	free(ptr);
	fprintf (f, "\nif (i%lu != %s%s.len - 1) printf(\",\");\n", 
		 tmpcnt, where, name);
	
	fprintf (f, "}\n");
    }
    fprintf (f, "}\n");
}

/*
 * encode/decode pointer
 */

d719 1
a719 2
encode_pointer (char *name, Type *type, FILE *f, EncodeType encodetype,
		Side side)
d732 1
a732 1
	  encode_type ("bool", &booltype, f, encodetype, side);
d734 1
a734 1
	  encode_type (tmp, type->subtype, f, encodetype, side);
d742 1
a742 1
	  encode_type ("bool", &booltype, f, encodetype, side);
d747 1
a747 1
	  encode_type (tmp, type->subtype, f, encodetype, side);
a757 4
/*
 * encode type
 */

d759 1
a759 2
encode_type (char *name, Type *type, FILE *f, EncodeType encodetype,
	     Side side)
d779 1
a779 1
	       encode_string (name, type, f, encodetype, side);
d782 1
a782 2
	       error_message (1,
			      "Type opaque only allowed as part of an array");
d785 1
a785 1
	       encode_symbol (type->symbol, name, f, encodetype, side);
d788 1
a788 1
	       encode_array (name, type, f, encodetype, side);
d791 1
a791 1
	       encode_varray (name, type, f, encodetype, side);
d794 1
a794 1
	       encode_pointer (name, type, f, encodetype, side);
a800 49
/*
 * print type
 */

static void
display_type (char *where, char *name, Type *type, FILE *f)
{
    assert (where);

    switch (type->type) {
    case TCHAR :
    case TUCHAR :
#if 0
	print_char (name, type, f, encodetype);
	break;
#endif
    case TSHORT :
    case TUSHORT :
#if 0
	print_short (name, type, f, encodetype);
	break;
#endif
    case TLONG :
    case TULONG :
	print_long (where, name, type, f);
	break;
    case TSTRING :
	print_string (where, name, type, f);
	break;
    case TOPAQUE :
	fprintf (f, "printf(\"printing TOPAQUE\\n\");");
	break;
    case TUSERDEF :
	print_symbol (where, type->symbol, name, f);
	break;
    case TARRAY :
	print_array (where, name, type, f);
	break;
    case TVARRAY :
	print_varray (where, name, type, f);
	break;
    case TPOINTER :
	fprintf (f, "printf(\"printing TPOINTER\\n\");");
	break;
    default :
	abort();
    }
}

a805 1
     Side side;
a807 4
/*
 * helpfunction for encode_struct
 */

d829 1
a829 2
	 encode_type (tmp, s->type, context->f, context->encodetype,
		      context->side);
a834 4
/*
 * encode/decode TSTRUCT
 */

d836 1
a836 2
encode_struct (Symbol *s, char *name, FILE *f, EncodeType encodetype,
	       Side side)
a843 1
     context.side       = side;
a847 69
/*
 * help function for print_struct
 */

struct printcontext {
    char *where;
    char *name;
    FILE *f;
    Symbol *symbol;
};

static Bool
print_structentry (List *list, Listitem *item, void *arg)
{
     StructEntry *s = (StructEntry *)listdata (item);
     struct printcontext *context = (struct printcontext *)arg;

     char *tmp;
     char *tmp2;

     asprintf(&tmp, ".%s", s->name);
     asprintf(&tmp2, "%s%s", context->where, context->name);

     if (s->type->type == TPOINTER
	 && s->type->subtype->type == TUSERDEF
	 && s->type->subtype->symbol->type == TSTRUCT
	 && strcmp(s->type->subtype->symbol->name,
		   context->symbol->name) == 0) {
	 fprintf (context->f,
		  "ydr_print_%s%s(%s%s, ptr);\n",
		  package,
		  context->symbol->name,
		  tmp2,
		  tmp);
     } else {
	 display_type (tmp2, tmp, s->type, context->f);
     }

     free(tmp);
     free(tmp2);

     fprintf (context->f, "\n");

     return FALSE;
}

/*
 * print TSTRUCT
 */

static void
print_struct (char *where, Symbol *s, char *name, FILE *f)
{
    struct printcontext context;
    
    context.name       = name;
    context.symbol     = s;
    context.f          = f;
    context.where      = where ;

    fprintf (f, "/* printing TSTRUCT %s%s */\n", where, name);
    
    listiter (s->u.list, print_structentry, (void *)&context);
}

/*
 * encode/decode TENUM
 */

d849 1
a849 2
encode_enum (Symbol *s, char *name, FILE *f, EncodeType encodetype,
	     Side side)
d852 1
d854 2
a855 2
     encode_type (name, &type, f, encodetype, side);
}
d857 1
a857 31
/*
 * print TENUM
 */

static Bool
gen_printenum (List *list, Listitem *item, void *arg)
{
    Symbol *s = (Symbol *)listdata (item);
    FILE *f = (FILE *)arg;
    
    fprintf (f, "case %d:\n"
	     "printf(\"%s\");\n"
	     "break;\n", 
	     (int) s->u.val, s->name);

     return FALSE;
}

static void
print_enum (char *where, Symbol *s, char *name, FILE *f)
{
    fprintf (f, "/* print ENUM %s */\n", where);

    fprintf (f, "printf(\"%s = \");", name);
    fprintf (f, "switch(%s) {\n", where);
    listiter (s->u.list, gen_printenum, f);
    fprintf (f, 
	     "default:\n"
	     "printf(\" unknown enum %%d\", %s);\n"
	     "}\n",
	     where);
a859 4
/*
 * encode/decode TTYPEDEF
 */

d861 1
a861 2
encode_typedef (Symbol *s, char *name, FILE *f, EncodeType encodetype,
		Side side)
d863 1
a863 1
     encode_type (name, s->u.type, f, encodetype, side);
a865 4
/*
 * print TTYPEDEF
 */

d867 1
a867 12
print_typedef (char *where, Symbol *s, char *name, FILE *f)
{
    display_type (where, name, s->u.type, f);
}

/*
 * Encode symbol/TUSERDEF
 */

static void
encode_symbol (Symbol *s, char *name, FILE *f, EncodeType encodetype,
	       Side side)
d871 1
a871 1
	       encode_struct (s, name, f, encodetype, side);
d874 1
a874 1
	       encode_enum (s, name, f, encodetype, side);
d877 1
a877 23
	       encode_typedef (s, name, f, encodetype, side);
	       break;
	  default :
	       abort();
	  }
}

/*
 * print symbol/TUSERDEF
 */

static void
print_symbol (char *where, Symbol *s, char *name, FILE *f)
{
     switch (s->type) {
	  case TSTRUCT :
	       print_struct (where, s, name, f);
	       break;
	  case TENUM :
	       print_enum (where, s, name, f);
	       break;
	  case TTYPEDEF :
	       print_typedef (where, s, name, f);
d900 1
a900 20
	  error_message (1, "What is %s (type %d) doing here?\n",
			 s->name, s->type);
}

/*
 * Generate the definition of a print function.
 */

static void
generate_printfunction_definition (Symbol *s, FILE *f)
{
     if (s->type == TSTRUCT || s->type == TENUM || s->type == TTYPEDEF) {
	  fprintf (f, 
		   "void ydr_print_%s(%s *o)",
		   s->name, s->name);
     } else if (s->type == TCONST || s->type == TENUMVAL 
	      || s->type == TTYPEDEF)
	  ;
     else
	  error_message (1, "What is %s (type %d) doing here?\n",
d914 2
a915 26
	  encode_symbol (s, "(*o)", f,
			 encodep ? ENCODE_MEM : DECODE_MEM, CLIENT);
	  fprintf (f, "return ptr;\n"
		   "fail:\n"
		   "errno = EFAULT;\n"
		   "return NULL;}\n");
     } else if (s->type == TCONST || s->type == TENUMVAL 
	      || s->type == TTYPEDEF)
	  ;
     else
	  error_message (1, "What is %s (type %d) doing here?\n",
			 s->name, s->type);
}

/*
 * Generate a print function
 */

void
generate_printfunction (Symbol *s, FILE *f)
{
     if (s->type == TSTRUCT || s->type == TENUM || s->type == TTYPEDEF) {
	  generate_printfunction_definition (s, f);
	  fprintf (f, "\n{\n");
	  print_symbol ("(*o)",  s, "", f);
	  fprintf (f, "return;\n}\n");
d920 1
a920 1
	  error_message (1, "What is %s (type %d) doing here?\n",
d938 1
a938 19
	  error_message (1, "What is %s (type %d) doing here?\n",
			 s->name, s->type);
}

/*
 * Generate an prototype for a print function
 */

void
generate_printfunction_prototype (Symbol *s, FILE *f)
{
     if (s->type == TSTRUCT || s->type == TENUM || s->type == TTYPEDEF) {
	  generate_printfunction_definition (s, f);
	  fprintf (f, ";\n");
     } else if (s->type == TCONST || s->type == TENUMVAL 
	      || s->type == TTYPEDEF)
	  ;
     else
	  error_message (1, "What is %s (type %d) doing here?\n",
d951 1
a951 1
	 error_message (1, "Argument %s is OUT and not pointer or string.\n",
d956 1
a956 1
     print_type (a->name, a->type, a->argtype, FDECL, f);
d968 2
a969 2
	  fprintf (f, ", %s ", a->argtype == TIN ? "const" : "");
	  print_type (a->name, a->type, a->argtype, FDECL, f);
d993 1
a993 1
	  print_type (a->name, a->type->subtype, TIN, VDECL, f);
d995 1
a995 1
	  print_type (a->name, a->type, TIN, VDECL, f);
d1024 1
a1024 3
     else if (a->argtype != TIN
	      && a->type->type == TSTRING && a->type->size == 0)
	 fprintf (f, "free(%s);\n", a->name);
d1031 17
a1047 15
    Argument *a = (Argument *)listdata (item);
    FILE *f = (FILE *)arg;
    
    if (a->argtype == TIN || a->argtype == TINOUT) {
	if (a->type->type == TPOINTER) {
	    char *tmp = (char *)emalloc (strlen (a->name) + 4);
	    
	    sprintf (tmp, "(*%s)", a->name);
	    
	    encode_type (tmp, a->type->subtype, f, ENCODE_RX, CLIENT);
	    free (tmp);
	} else
	    encode_type (a->name, a->type, f, ENCODE_RX, CLIENT);
    }
    return FALSE;
d1062 1
a1062 1
	     encode_type (tmp, a->type->subtype, f, DECODE_RX, CLIENT);
d1065 1
a1065 1
	     encode_type (a->name, a->type, f, DECODE_RX, CLIENT);
d1086 1
a1086 1
	       encode_type (tmp, a->type->subtype, f, DECODE_RX, SERVER);
d1089 1
a1089 1
	       encode_type (a->name, a->type->subtype, f, DECODE_RX, SERVER);
d1091 1
a1091 1
	       encode_type (a->name, a->type, f, DECODE_RX, SERVER);
d1104 1
a1104 1
	       encode_type (a->name, a->type->subtype, f, ENCODE_RX, SERVER);
d1106 1
a1106 1
	       encode_type (a->name, a->type, f, ENCODE_RX, SERVER);
d1140 1
a1140 3
     if (a->type->type == TPOINTER
	 || (a->argtype != TIN
	     && a->type->type == TSTRING && a->type->size == 0))
d1173 1
a1173 1
     encode_type (op, &type, f, ENCODE_RX, CLIENT);
d1178 1
a1178 1
	      "return %s(rx_EndCall (call,0));\n"
d1180 1
a1180 1
	      "ret = %s(rx_Error(call));\n"
d1183 1
a1183 3
	      "}\n",
	      error_function,
	      error_function);
d1204 1
a1204 1
     encode_type (op, &type, f, ENCODE_RX, CLIENT);
d1212 1
a1212 3
                 "return %s(rx_Error(call));\n",
		  error_function);

d1231 1
a1231 3
                 "return %s(rx_Error(call));\n",
		  error_function);

a1234 46
struct gen_args {
    FILE *f;
    int firstp;
    int arg_type;
};

static Bool
genmacro (List *list, Listitem *item, void *arg)
{
     Argument *a = (Argument *)listdata (item);
     struct gen_args *args = (struct gen_args *)arg;

     if (a->argtype == args->arg_type || a->argtype == TINOUT) {
	 fprintf (args->f, "%s%s",
		  args->firstp ? "" : ", ", a->name);
	 args->firstp = 0;
     }

     return FALSE;
}

static void
generate_multi (Symbol *s, FILE *f)
{
    struct gen_args gen_args;

    fprintf (f, "\n#include <rx/rx_multi.h>");
    fprintf (f, "\n#define multi_%s%s(", package, s->name);
    gen_args.f        = f;
    gen_args.firstp   = 1;
    gen_args.arg_type = TIN;
    listiter (s->u.proc.arguments, genmacro, &gen_args);
    fprintf (f, ") multi_Body(");
    fprintf (f, "Start%s%s(multi_call", package, s->name);
    gen_args.f        = f;
    gen_args.firstp   = 0;
    gen_args.arg_type = TIN;
    listiter (s->u.proc.arguments, genmacro, &gen_args);
    fprintf (f, "), End%s%s(multi_call", package, s->name);
    gen_args.f        = f;
    gen_args.firstp   = 0;
    gen_args.arg_type = TOUT;
    listiter (s->u.proc.arguments, genmacro, f);
    fprintf (f, "))\n");
}

a1250 20
static void
generate_standard_c_prologue (FILE *f,
			      const char *filename,
			      const char *basename)
{
     fprintf (f, "/* Generated from %s.xg */\n", basename);
     fprintf (f, "#include \"%s.h\"\n\n", basename);
     fprintf (f, "#include <stdio.h>\n");
     fprintf (f, "#include <stdlib.h>\n");
     fprintf (f, "#include <string.h>\n");
     fprintf (f, "#include <netinet/in.h>\n");
     fprintf (f, "#include <errno.h>\n");
     fprintf (f, "#ifndef HAVE_BCOPY\n"
	      "#define bcopy(a,b,c) memcpy((b),(a),(c))\n"
	      "#endif /* !HAVE_BCOPY */\n\n");
     fprintf (f, "#ifdef RCSID\n"
	      "RCSID(\"%s generated from %s.xg with $KTH: output.c,v 1.73.2.1 2001/03/04 04:48:48 lha Exp $\");\n"
	      "#endif\n\n", filename, basename);
}

d1256 1
a1256 1
init_generate (const char *filename)
d1263 4
a1266 7
     asprintf (&tmp, "%s.h", filename);
     if (tmp == NULL)
	 err (1, "malloc");
     ydr_fopen (tmp, "w", &headerfile);
     free (tmp);

     fileuppr = estrdup (filename);
d1268 2
a1269 2
     fprintf (headerfile.stream, "/* Generated from %s.xg */\n", filename);
     fprintf (headerfile.stream, "#ifndef _%s_\n"
a1270 1
     fprintf (headerfile.stream, "#include <atypes.h>\n\n");
d1273 26
a1298 6
     asprintf (&tmp, "%s.ydr.c", filename);
     if (tmp == NULL)
	 err (1, "malloc");
     ydr_fopen (tmp, "w", &ydrfile);
     generate_standard_c_prologue (ydrfile.stream, tmp, filename);
     free (tmp);
d1300 13
a1312 7
     asprintf (&tmp, "%s.cs.c", filename);
     if (tmp == NULL)
	 err (1, "malloc");
     ydr_fopen (tmp, "w", &clientfile);
     generate_standard_c_prologue (clientfile.stream, tmp, filename);
     fprintf (clientfile.stream, "#include \"%s.cs.h\"\n\n", filename);
     free (tmp);
d1314 8
a1321 7
     asprintf (&tmp, "%s.ss.c", filename);
     if (tmp == NULL)
	 err (1, "malloc");
     ydr_fopen (tmp, "w", &serverfile);
     generate_standard_c_prologue (serverfile.stream, tmp, filename);
     fprintf (serverfile.stream, "#include \"%s.ss.h\"\n\n", filename);
     free (tmp);
a1322 4
     asprintf (&tmp, "%s.cs.h", filename);
     if (tmp == NULL)
	 err (1, "malloc");
     ydr_fopen (tmp, "w", &clienthdrfile);
a1323 22
     fprintf (clienthdrfile.stream, "/* Generated from %s.xg */\n", filename);
     fprintf (clienthdrfile.stream, "#include <rx/rx.h>\n");
     fprintf (clienthdrfile.stream, "#include \"%s.h\"\n\n", filename);

     asprintf (&tmp, "%s.ss.h", filename);
     if (tmp == NULL)
	 err (1, "malloc");
     ydr_fopen (tmp, "w", &serverhdrfile);
     free (tmp);
     fprintf (serverhdrfile.stream, "/* Generated from %s.xg */\n", filename);
     fprintf (serverhdrfile.stream, "#include <rx/rx.h>\n");
     fprintf (serverhdrfile.stream, "#include \"%s.h\"\n\n", filename);

     asprintf (&tmp, "%s.td.c", filename);
     if (tmp == NULL)
	 err (1, "malloc");
     ydr_fopen (tmp, "w", &td_file);
     free (tmp);

     packagelist = listnew();
     if (packagelist == NULL)
	 err (1, "init_generate: listnew: packagelist");
d1327 1
a1327 1
close_generator (const char *filename)
d1329 1
a1329 1
     char *fileupr = estrdup (filename);
d1332 7
a1338 8
     fprintf (headerfile.stream, "\n#endif /* %s */\n", fileupr);
     ydr_fclose (&headerfile);
     ydr_fclose (&clientfile);
     ydr_fclose (&serverfile);
     ydr_fclose (&clienthdrfile);
     ydr_fclose (&serverhdrfile);
     ydr_fclose (&ydrfile);
     ydr_fclose (&td_file);
d1347 1
a1347 1
generate_server_stub (Symbol *s, FILE *f, FILE *headerf, FILE *h_file)
d1351 2
a1352 2
     fprintf (headerf, "int %s%s%s(\nstruct rx_call *call\n",
	      prefix, package, s->name);
d1359 1
a1359 1
	      "int32_t _result;\n");
d1363 1
a1363 1
     fprintf (f, "_result = %s%s%s(", prefix, package, s->name);
a1370 1
     fprintf (f, "if (_result) goto funcfail;\n");
d1374 4
a1377 9
     if (!listemptyp(s->u.proc.arguments)) {
	 fprintf(f, "fail:\n");
	 listiter (s->u.proc.arguments, genfree, f);
	 fprintf(f, "return rx_Error(call);\n");

     }
     fprintf(f, "funcfail:\n"
	     "return _result;\n"
	     "}\n\n");
a1379 2
     if (s->u.proc.flags & TMULTI)
	 generate_multi (s, h_file);
a1381 5
struct gencase_context {
    FILE *f;
    char *package;
};

d1386 1
a1386 2
     struct gencase_context *c = (struct gencase_context *)arg;
     FILE *f = c->f;
d1388 5
a1392 7
     if (c->package == s->u.proc.package) {
	 fprintf (f, "case %u: {\n"
		  "_result = _%s%s(call);\n"
		  "break;\n"
		  "}\n",
		  s->u.proc.id, s->u.proc.package, s->name);
     }
a1404 76
     Listitem *li;
     struct gencase_context c;

     c.f = c_file;
     
     li = listhead (packagelist);
     while (li) {
	 c.package = (char *)listdata (li);

	 fprintf (h_file,
		  "int32_t %sExecuteRequest(struct rx_call *call);\n",
		  c.package);
	 
	 fprintf (c_file,
		  "int32_t %sExecuteRequest(struct rx_call *call)\n"
		  "{\n"
		  "unsigned opcode;\n"
		  "int32_t _result;\n",
		  c.package);
	 
	 encode_type ("opcode", &optype, c_file, DECODE_RX, SERVER);
	 fprintf (c_file, "switch(opcode) {\n");
	 
	 listiter (func_list, gencase, &c);
	 
	 fprintf (c_file, "default:\n"
 		  "_result = RXGEN_OPCODE;\n"
		  "fprintf (stderr, \"Ignoring %%d\\n\", opcode);\n"
		  "}\n"
		  "return _result;\n"
		  "fail:\n"
		  "return rx_Error(call);\n"
		  "}\n\n");

	 li = listnext (packagelist, li);
     }
}

static Bool
gentcpdump_decode (List *list, Listitem *item, void *arg)
{
     Argument *a = (Argument *)listdata (item);
     FILE *f = (FILE *)arg;

     if (a->type->type == TPOINTER)
	 encode_type (a->name, a->type->subtype, f, ENCODE_MEM, CLIENT);
     else
	 encode_type (a->name, a->type, f, ENCODE_MEM, CLIENT);

     fprintf (f, "++found;\n");
     return FALSE;
}

/*
 *
 */

static Bool
gentcpdump_print (List *list, Listitem *item, void *arg)
{
     Argument *a = (Argument *)listdata (item);
     FILE *f = (FILE *)arg;

     fprintf (f, "if (found > 0)\n\n"
	      "{ --found;\n");

     if (a->type->type == TPOINTER)
	 display_type ("", a->name, a->type->subtype, f);
     else
	 display_type ("", a->name, a->type, f);

     if (listnextp(item))
	 fprintf (f, "printf(\",\");\n");
     
     fprintf (f, "} else\n"
	      "goto failandquit;\n");
d1406 3
a1408 2
     return FALSE;
}
d1410 1
a1410 8
/*
 *
 */

void
generate_tcpdump_stub (Symbol *s, FILE *f)
{
     fprintf (f, "void %s%s_print(char *ptr, size_t *total_len)\n"
d1412 16
a1427 110
	      "int found = 0;\n",
	      package, s->name);
     listiter (s->u.proc.arguments, gendeclare, f);
     fprintf (f, "\n");

     listiter (s->u.proc.arguments, gentcpdump_decode, f);
     if (!listemptyp(s->u.proc.arguments))
	 fprintf(f, "fail:\n");
     fprintf (f, "printf(\"{\");");
     listiter (s->u.proc.arguments, gentcpdump_print, f);
     fprintf (f, "printf(\"}\\n\");");

     fprintf (f, "\nreturn ptr;\n");
     if (!listemptyp(s->u.proc.arguments))
	 fprintf(f, "failandquit:\n"
		 "printf(\"Error decoding paket\");\n"
		 "return NULL;");
     fprintf(f, "}\n\n");
}


static Bool
gentcpdump_case (List *list, Listitem *item, void *arg)
{
     Symbol *s = (Symbol *)listdata (item);
     FILE *f = (FILE *)arg;

     fprintf (f, "case %u:\n"
	      "printf(\"%s%s(\");\n"
	      "ret = %s%s_print(ptr, &total_len);\n"
	      "break;\n",
	      s->u.proc.id,
	      package,
	      s->name,
	      package,
	      s->name);

     return FALSE;
}

/*
 * generate tcpdump patches
 */


void
generate_tcpdump_patches(FILE *td_file, const char *filename)
{
    Type optype = {TULONG};

    fprintf(td_file, "/* generated by $KTH: output.c,v 1.73.2.1 2001/03/04 04:48:48 lha Exp $ */\n\n");

    fprintf (td_file, 
	     "#include <stdio.h>\n"
	     "#include <stdlib.h>\n"
	     "#include \"%s.h\"\n",
	     filename);

    fprintf (td_file, "%stcpdump_print(const unsigned char *ptr,"
	     "unsigned int len,"
	     "unsigned char *bp2)\n"
	     "{\n"
	     "u_int32_t opcode;\n"
	     "size_t *total_len = len;\n"
	     "char *ret;\n",
	     package);
    
    encode_type ("opcode", &optype, td_file, DECODE_MEM, CLIENT);

    fprintf (td_file, "switch(opcode) {\n");

    listiter (func_list, gentcpdump_case, td_file);
    
    fprintf (td_file, "default:\n"
	     "printf (\"Unknown opcode %%s->%%d\\n\", "
	     "package, opcode);\n"
	     "}\n"
	     "fail:\n"
	     "printf(\"Error decoding packet\\n\");\n"
	     "}\n\n");

}

void
ydr_fopen (const char *name, const char *mode, ydr_file *f)
{
     int streamfd;

     asprintf (&f->curname, "%sXXXXXX", name);
     if (f->curname == NULL)
	 err (1, "malloc");

     streamfd = mkstemp(f->curname);
     if (streamfd < 0)
	 err (1, "mkstemp %s failed", f->curname);
     f->stream = fdopen (streamfd, mode);
     if (f->stream == NULL)
	 err (1, "open %s mode %s", f->curname, mode);
     f->newname = estrdup(name);
}

void
ydr_fclose (ydr_file *f)
{
     if (fclose (f->stream))
	 err (1, "close %s", f->curname);
     if (rename(f->curname, f->newname))
	 err (1, "rename %s, %s", f->curname, f->newname);
     free(f->curname);
     free(f->newname);
@


1.1.1.3
log
@Import of arla -current as of Aug 5 2003

ok todd@@ deraadt@@
@
text
@d2 1
a2 1
 * Copyright (c) 1995 - 2002 Kungliga Tekniska Högskolan
d36 1
a36 1
RCSID("$arla: output.c,v 1.91 2003/04/16 09:07:03 lha Exp $");
a42 1
#include <ctype.h>
d79 1
d82 1
a82 1
static long tmpcnt = 0;
a118 2
static void free_symbol (char *where, Symbol *s, char *name, FILE *f);
static void free_type (char *where, char *name, Type *type, FILE *f);
d125 1
a125 1
	  case YDR_TCHAR :
d128 1
a128 1
	  case YDR_TUCHAR :
d131 1
a131 1
	  case YDR_TSHORT :
d134 2
a135 2
	  case YDR_TUSHORT :
	       fprintf (f, "uint16_t %s", name);
d137 1
a137 1
	  case YDR_TLONG :
d140 2
a141 2
	  case YDR_TULONG :
	       fprintf (f, "uint32_t %s", name);
d143 1
a143 7
	  case YDR_TLONGLONG:
	       fprintf (f, "int64_t %s", name);
	       break;
	  case YDR_TULONGLONG:
	       fprintf (f, "uint64_t %s", name);
	       break;
	  case YDR_TSTRING :
d151 1
a151 1
	  case YDR_TPOINTER :
d162 2
a163 2
	  case YDR_TUSERDEF : 
	       if(type->symbol->type == YDR_TSTRUCT)
d168 1
a168 1
	  case YDR_TVARRAY :
d189 1
a189 1
	  case YDR_TARRAY :
d193 1
a193 1
	  case YDR_TOPAQUE :
d215 1
a215 2
 * In the case of a variable-sized type, return -1 (unknown) or
 * the negative maxsize.
a228 3
     } else if (sz < 0 || *tot < 0) {
	  *tot = -1 * (abs(*tot) + abs(sz));
	  return FALSE;
d230 1
a230 1
	  *tot = *tot + sz;
d240 1
a240 2
     if (s->u.list)
	 listiter (s->u.list, sizeof_struct_iter, &tot);
d248 8
a255 6
     case YDR_TCHAR :
     case YDR_TUCHAR :
     case YDR_TSHORT :
     case YDR_TUSHORT :
     case YDR_TLONG :
     case YDR_TULONG :
d257 1
a257 4
     case YDR_TLONGLONG :
     case YDR_TULONGLONG :
	  return 8;
     case YDR_TSTRING :
d262 1
a262 1
     case YDR_TOPAQUE :
d264 1
a264 1
     case YDR_TUSERDEF :
d266 1
a266 1
     case YDR_TARRAY :
d272 2
a273 1
	  return t->size * sz;
d275 3
a277 11
     case YDR_TVARRAY :
     {
	 int sz;
	 if (t->size == 0)
	     return -1;
	 sz = sizeof_type(t->subtype);
	 if (sz == -1)
	     return -1;
	 return -1 * (t->size * abs(sz) + 4); /* 4 is size of the var part */
     }
     case YDR_TPOINTER :
d288 1
a288 1
	  case YDR_TUNDEFINED :
d291 1
a291 1
	  case YDR_TSTRUCT :
d293 1
a293 1
	  case YDR_TENUM :
d295 1
a295 1
	  case YDR_TCONST :
d297 1
a297 1
	  case YDR_TENUMVAL :
d299 1
a299 1
	  case YDR_TTYPEDEF :
d326 10
a335 14
     if (s->u.list) {
	 for (item = listhead (s->u.list); 
	      item && listnext (s->u.list, item); 
	      item = listnext (s->u.list, item))
	 {
	     e = (Symbol *)listdata (item);
	     
	     fprintf (f, "     %s = %d,\n", e->name, e->u.val);	     
	 }
	 e = (Symbol *)listdata (item);
	 fprintf (f, "     %s = %d\n};\n", e->name, e->u.val);
     }
     fprintf (f, "typedef enum %s %s;\n",
	      s->name, s->name);
d357 1
a357 1
     if (s->type == YDR_TCONST)
d361 2
a362 6
     if (sz == -1) {
	 ; /* the size is unknown */
     } else {
	  char *name, *ms = "";
	  if (sz < 0)
	      ms = "MAX_";
d365 1
a365 1
	  fprintf (f, "#define %s_%sSIZE %d\n", strupr (name), ms, abs(sz));
d374 1
a374 1
	  case YDR_TUNDEFINED :
d377 1
a377 1
	  case YDR_TSTRUCT :
d380 1
a380 1
	  case YDR_TENUM :
d383 1
a383 1
	  case YDR_TCONST :
d386 1
a386 1
	  case YDR_TENUMVAL :
d388 1
a388 1
	  case YDR_TTYPEDEF :
d400 2
d407 21
a427 19
     else if (encodetype == ENCODE_RX || encodetype == ENCODE_MEM) {
	 switch (type->type) {
	 case YDR_TLONGLONG:
	 case YDR_TULONGLONG:
	     return "htole64";
	 default:
	     return "htonl";
	     break;
	 }
     } else if (encodetype == DECODE_RX || encodetype == DECODE_MEM) {
	 switch (type->type) {
	 case YDR_TLONGLONG:
	 case YDR_TULONGLONG:
	     return "letoh64";
	 default:
	     return "ntohl";
	     break;
	 }
     } else
d432 1
a432 1
 * encode/decode long/longlong
d436 1
a436 2
encode_int_type (char *name, char *tname, Type *type, 
		 FILE *f, EncodeType encodetype)
d440 1
a440 1
	       fprintf (f, "{ u%s u;\n"
a444 1
			tname,
d449 1
a449 1
	       fprintf (f, "{ u%s u;\n"
d453 1
a453 1
			"}\n", tname, name,
d457 5
a461 6
	       fprintf (f, "{ %s tmp = %s(%s); "
			"if (*total_len < sizeof(tmp)) goto fail;\n"
			"memcpy (ptr, (char*)&tmp, sizeof(tmp)); "
			"ptr += sizeof(tmp); "
			"*total_len -= sizeof(tmp);}\n",
			tname,
d466 3
a468 3
	       fprintf (f, "{ %s tmp; "
			"if (*total_len < sizeof(tmp)) goto fail;"
			"memcpy ((char*)&tmp, ptr, sizeof(tmp)); "
d470 2
a471 3
			"ptr += sizeof(tmp); "
			"*total_len -= sizeof(tmp);}\n", 
			tname,
a479 12
static void
encode_long (char *name, Type *type, FILE *f, EncodeType encodetype)
{
    encode_int_type(name, "int32_t", type, f, encodetype);
}

static void
encode_longlong (char *name, Type *type, FILE *f, EncodeType encodetype)
{
    encode_int_type(name, "int64_t", type, f, encodetype);
}

a490 32
 * print longlong
 */ 

static void
print_longlong (char *where, char *name, Type *type, FILE *f)
{
    fprintf (f, "printf(\" %s = %%d\", (int32_t)%s%s);", name, where, name);
}

/*
 *
 */

static void
gen_check_overflow(Type *indextype, Type *subtype, char *num, FILE *f)
{
     /* Check if we will overflow */
     fprintf(f, "{\n");
     print_type ("overI", indextype, TIN, VDECL, f);
     fprintf(f, ";\n");
     fprintf(f, "overI = ((");
     print_type ("", indextype, TIN, VDECL, f);
     fprintf(f, ")~((");
     print_type ("", indextype, TIN, VDECL, f);
     fprintf(f, ")0) >> 1) / sizeof(");
     print_type ("", subtype, TIN, VDECL, f);
     fprintf(f, ");\n");
     fprintf(f, "if (overI < %s) goto fail;\n", num);
     fprintf(f, "}\n");
}

/*
d551 1
a551 1
	              "memcpy (ptr, (char*)&tmp, sizeof(int16_t)); "
d560 1
a560 1
			"memcpy ((char *)&tmp, ptr, sizeof(int16_t)); "
d580 1
a580 1
     Type lentype = {YDR_TULONG};
d612 1
a612 1
			    "rx_SetCallError(call, ENOMEM);\n"
d617 1
a617 10
		   fprintf(f, "if (len == (uint32_t) -1) {\n"
			   "rx_SetCallError(call, ENOMEM);\n"
			   "goto fail;\n"
			   "}\n");
		   fprintf(f, "%s = malloc(len + 1);\n"
			   "if (%s == NULL) {\n"
			   "rx_SetCallError(call, ENOMEM);\n"
			   "goto fail;\n"
			   "}\n", 
			   nname, nname);
d637 2
a638 2
	       fprintf (f, "ptr += len + (4 - (len %% 4)) %% 4;\n"
			"*total_len -= len + (4 - (len %% 4)) %% 4;\n}\n");
d653 1
a653 8
		   fprintf(f, "if (len == (uint32_t) -1) {\n"
			   "goto fail;\n"
			   "}\n");
		   fprintf(f, "%s = malloc(len + 1);\n"
			   "if (%s == NULL) {\n"
			   "goto fail;\n"
			   "}\n", 
			   nname, nname);
d659 1
a659 1
			"*total_len -= len + (4 - (len %% 4)) %% 4;\n}\n",
a678 12
#if 0
/*
 * free TSTRING
 */

static void
free_string (char *where, char *name, Type *type, FILE *f)
{
    fprintf (f, "free(%s%s);\n", where, name);
}
#endif

d687 1
a687 1
     if (type->subtype->type == YDR_TOPAQUE) {
d737 1
a737 1
 * print ARRAY
d747 1
a747 1
    if (type->subtype->type == YDR_TOPAQUE) {
a776 24
 * free TARRAY
 */

static void
free_array (char *where, char *name, Type *type, FILE *f)
{
    if (type->subtype->type == YDR_TOPAQUE) {
	; /* nothing */
    } else {
	char tmp[256];

	fprintf (f, "{\nint i%lu;\nfor(i%lu = 0; i%lu < %u;"
		 "++i%lu){\n", tmpcnt, tmpcnt, tmpcnt, type->size,tmpcnt);
	snprintf(tmp, sizeof(tmp)-1, "%s[i%lu]", name, tmpcnt);
	tmpcnt++;
	if (type->flags)
	    type->subtype->flags |= type->flags;
	free_type (tmp, "", type->subtype, f);
	tmpcnt--;
	fprintf (f, "}\n}\n");
    }
}

/*
d785 1
a785 2
     Type lentype = {YDR_TULONG};
     Type *indextype;
d790 2
a791 13
     indextype = type->indextype ? type->indextype : &lentype;

     encode_type (tmp, indextype, f, encodetype, side);
     if (encodetype == DECODE_MEM || encodetype == DECODE_RX) {
	 if (type->size != 0)
	     fprintf (f, "if (%s > %d) goto fail;\n", tmp, type->size);
	 if (encodetype == DECODE_MEM) {
	     fprintf (f, "if ((%s * sizeof(", tmp);
	     print_type ("", type->subtype, TIN, VDECL, f);
	     fprintf (f, ")) > *total_len) goto fail;\n");
	 }
     }
     gen_check_overflow(indextype, type->subtype, tmp, f);
a797 1
	 fprintf (f, "if (%s.val == NULL) goto fail;\n", name);
d799 1
a799 1
     if (type->subtype->type == YDR_TOPAQUE) {
d824 1
a826 2
			     "size_t sz = %s + (4 - (%s %% 4)) %% 4;\n"
			     "if (*total_len < sz) goto fail;\n"
d829 1
a829 1
			     "ptr += sz; *total_len -= sz;\n"
d831 1
a831 1
			     tmp, tmp, name, tmp, tmp, tmp);
d834 2
a835 2
		    fprintf (f, 
			     "{\n"
d866 1
a866 1
    fprintf (f, "/* printing YDR_TVARRAY %s%s */\n", where, name);
d868 1
a868 1
    if (type->subtype->type == YDR_TOPAQUE) {
a892 24
 * free TVARRAY
 */

static void
free_varray (char *where, char *name, Type *type, FILE *f)
{
    if (type->subtype->type != YDR_TOPAQUE) {
	char *ptr;
	fprintf (f, "{\n"
		 "unsigned int i%lu;\n", tmpcnt);
	fprintf (f, "for (i%lu = 0; i%lu < %s%s.len; ++i%lu) {\n", 
		 tmpcnt, tmpcnt, where, name, tmpcnt);
	asprintf(&ptr, "%s%s.val[i%ld]", where, name, tmpcnt);
	tmpcnt++;
	free_type (ptr, "", type->subtype, f);
	tmpcnt--;
	free(ptr);
	fprintf (f, "}\n");
	fprintf (f, "}\n");
    }
    fprintf (f, "free((%s%s).val);\n", where, name);
}

/*
d900 1
a900 1
     Type booltype = {YDR_TULONG};
a937 15
 * free pointer
 */

static void
free_pointer (char *where, char *name, Type *type, FILE *f)
{
    char *tmp;

    asprintf (&tmp, "*(%s%s)", where, name);
    fprintf (f, "if(%s%s)", where, name);
    free_type(tmp, "", type->subtype, f);
    free(tmp);
}

/*
d946 14
a959 6
	  case YDR_TCHAR :
	  case YDR_TUCHAR :
	  case YDR_TSHORT :
	  case YDR_TUSHORT :
	  case YDR_TLONG :
	  case YDR_TULONG :
d962 1
a962 5
	  case YDR_TLONGLONG :
	  case YDR_TULONGLONG :
	       encode_longlong (name, type, f, encodetype);
	       break;
	  case YDR_TSTRING :
d965 1
a965 1
	  case YDR_TOPAQUE :
d969 1
a969 1
	  case YDR_TUSERDEF :
d972 1
a972 1
	  case YDR_TARRAY :
d975 1
a975 1
	  case YDR_TVARRAY :
d978 1
a978 1
	  case YDR_TPOINTER :
d996 14
a1009 6
    case YDR_TCHAR :
    case YDR_TUCHAR :
    case YDR_TSHORT :
    case YDR_TUSHORT :
    case YDR_TLONG :
    case YDR_TULONG :
d1012 1
a1012 5
    case YDR_TLONGLONG :
    case YDR_TULONGLONG :
	print_longlong (where, name, type, f);
	break;
    case YDR_TSTRING :
d1015 1
a1015 1
    case YDR_TOPAQUE :
d1018 1
a1018 1
    case YDR_TUSERDEF :
d1021 1
a1021 1
    case YDR_TARRAY :
d1024 1
a1024 1
    case YDR_TVARRAY :
d1027 1
a1027 1
    case YDR_TPOINTER :
a1034 41
/*
 * free type
 */

static void
free_type (char *where, char *name, Type *type, FILE *f)
{
    switch (type->type) {
    case YDR_TCHAR :
    case YDR_TUCHAR :
    case YDR_TSHORT :
    case YDR_TUSHORT :
    case YDR_TLONG :
    case YDR_TULONG :
    case YDR_TLONGLONG :
    case YDR_TULONGLONG :
	break;
    case YDR_TSTRING :
#if 0
	free_string (where, name, type, f);
#endif
	break;
    case YDR_TOPAQUE :
	break;
    case YDR_TUSERDEF :
	free_symbol (where, type->symbol, name, f);
	break;
    case YDR_TARRAY :
	free_array (where, name, type, f);
	break;
    case YDR_TVARRAY :
	free_varray (where, name, type, f);
	break;
    case YDR_TPOINTER :
	free_pointer (where, name, type, f);
	break;
    default :
	abort();
    }
}

d1058 3
a1060 3
     if (s->type->type == YDR_TPOINTER
	 && s->type->subtype->type == YDR_TUSERDEF
	 && s->type->subtype->symbol->type == YDR_TSTRUCT
d1091 1
a1091 2
     if (s->u.list)
	 listiter (s->u.list, encode_entry, (void *)&context);
d1117 3
a1119 3
     if (s->type->type == YDR_TPOINTER
	 && s->type->subtype->type == YDR_TUSERDEF
	 && s->type->subtype->symbol->type == YDR_TSTRUCT
d1156 1
a1156 64
    if (s->u.list)
	listiter (s->u.list, print_structentry, (void *)&context);
}

/*
 * help function for free_struct
 */

struct freecontext {
    char *where;
    char *name;
    FILE *f;
    Symbol *symbol;
};

static Bool
free_structentry (List *list, Listitem *item, void *arg)
{
     StructEntry *s = (StructEntry *)listdata (item);
     struct freecontext *context = (struct freecontext *)arg;

     char *tmp;
     char *tmp2;

     asprintf(&tmp, ".%s", s->name);
     asprintf(&tmp2, "%s%s", context->where, context->name);

     if (s->type->type == YDR_TPOINTER
	 && s->type->subtype->type == YDR_TUSERDEF
	 && s->type->subtype->symbol->type == YDR_TSTRUCT
	 && strcmp(s->type->subtype->symbol->name,
		   context->symbol->name) == 0) {
	 fprintf (context->f,
		  "ydr_free_%s%s(%s%s, ptr);\n",
		  package,
		  context->symbol->name,
		  tmp2,
		  tmp);
     } else {
	 free_type (tmp2, tmp, s->type, context->f);
     }

     free(tmp);
     free(tmp2);

     return FALSE;
}

/*
 * free TSTRUCT
 */

static void
free_struct (char *where, Symbol *s, char *name, FILE *f)
{
    struct freecontext context;
    
    context.name       = name;
    context.symbol     = s;
    context.f          = f;
    context.where      = where;

    if (s->u.list)
	listiter (s->u.list, free_structentry, (void *)&context);
d1167 1
a1167 1
     Type type = {YDR_TLONG};
d1197 1
a1197 2
    if (s->u.list)
	listiter (s->u.list, gen_printenum, f);
a1226 10
 * free TTYPEDEF
 */

static void
free_typedef (char *where, Symbol *s, char *name, FILE *f)
{
    free_type (where, name, s->u.type, f);
}

/*
d1235 1
a1235 1
	  case YDR_TSTRUCT :
d1238 1
a1238 1
	  case YDR_TENUM :
d1241 1
a1241 1
	  case YDR_TTYPEDEF :
d1257 1
a1257 1
	  case YDR_TSTRUCT :
d1260 1
a1260 1
	  case YDR_TENUM :
d1263 1
a1263 1
	  case YDR_TTYPEDEF :
a1271 21
 * Generate a free function for symbol
 */

static void
free_symbol (char *where, Symbol *s, char *name, FILE *f)
{
     switch (s->type) {
	  case YDR_TSTRUCT :
	       free_struct (where, s, name, f);
	       break;
	  case YDR_TENUM :
	       break;
	  case YDR_TTYPEDEF :
	       free_typedef (where, s, name, f);
	       break;
	  default :
	       abort();
	  }
}

/*
d1278 1
a1278 4
     if (s->type == YDR_TSTRUCT
	 || s->type == YDR_TENUM
	 || s->type == YDR_TTYPEDEF)
     {
d1280 1
a1280 2
		   "%schar *ydr_%scode_%s(%s%s *o, %schar *ptr, size_t *total_len)",
		   encodep ? "" : "const ",
d1282 3
a1284 7
		   s->name,
		   encodep ? "const " : "",
		   s->name,
		   encodep ? "" : "const ");
     } else if (s->type == YDR_TCONST
		|| s->type == YDR_TENUMVAL 
		|| s->type == YDR_TTYPEDEF)
d1298 1
a1298 4
     if (s->type == YDR_TSTRUCT
	 || s->type == YDR_TENUM
	 || s->type == YDR_TTYPEDEF) 
     {
d1302 2
a1303 26
     } else if (s->type == YDR_TCONST
		|| s->type == YDR_TENUMVAL 
		|| s->type == YDR_TTYPEDEF)
	  ;
     else
	  error_message (1, "What is %s (type %d) doing here?\n",
			 s->name, s->type);
}

/*
 * Generate a defintion for a function to free `s', writing it to `f'
 */

static void
generate_freefunction_definition (Symbol *s, FILE *f)
{
     if (s->type == YDR_TSTRUCT
	 || s->type == YDR_TENUM
	 || s->type == YDR_TTYPEDEF) 
     {
	  fprintf (f, 
		   "void ydr_free_%s(%s *o)",
		   s->name, s->name);
     } else if (s->type == YDR_TCONST
		|| s->type == YDR_TENUMVAL 
		|| s->type == YDR_TTYPEDEF)
d1317 1
a1317 4
     if (s->type == YDR_TSTRUCT
	 || s->type == YDR_TENUM
	 || s->type == YDR_TTYPEDEF)
     {
a1319 2
	  if (!encodep)
	      fprintf (f, "memset(o, 0, sizeof(*o));\n");
d1323 2
a1324 4
		   "fail:\n");
	  if (!encodep)
	      free_symbol ("", s, "(*o)", f);
	  fprintf (f, "errno = EINVAL;\n"
d1326 2
a1327 3
     } else if (s->type == YDR_TCONST
		|| s->type == YDR_TENUMVAL 
		|| s->type == YDR_TTYPEDEF)
d1341 1
a1341 3
     if (s->type == YDR_TSTRUCT
	 || s->type == YDR_TENUM
	 || s->type == YDR_TTYPEDEF) {
d1346 2
a1347 26
     } else if (s->type == YDR_TCONST
		|| s->type == YDR_TENUMVAL 
		|| s->type == YDR_TTYPEDEF)
	  ;
     else
	  error_message (1, "What is %s (type %d) doing here?\n",
			 s->name, s->type);
}

/*
 * Generate a free function for the type `s' and print it on `f'.
 */

void
generate_freefunction (Symbol *s, FILE *f)
{
     if (s->type == YDR_TSTRUCT
	 || s->type == YDR_TENUM
	 || s->type == YDR_TTYPEDEF) {
	  generate_freefunction_definition (s, f);
	  fprintf (f, "\n{\n");
	  free_symbol("(*o)", s, "", f);
	  fprintf (f, "return;\n}\n");
     } else if (s->type == YDR_TCONST
		|| s->type == YDR_TENUMVAL 
		|| s->type == YDR_TTYPEDEF)
d1361 1
a1361 4
     if (s->type == YDR_TSTRUCT
	 || s->type == YDR_TENUM
	 || s->type == YDR_TTYPEDEF) 
     {
d1364 2
a1365 3
     } else if (s->type == YDR_TCONST
		|| s->type == YDR_TENUMVAL 
		|| s->type == YDR_TTYPEDEF)
d1379 1
a1379 3
     if (s->type == YDR_TSTRUCT
	 || s->type == YDR_TENUM
	 || s->type == YDR_TTYPEDEF) {
d1382 2
a1383 25
     } else if (s->type == YDR_TCONST
		|| s->type == YDR_TENUMVAL 
		|| s->type == YDR_TTYPEDEF)
	  ;
     else
	  error_message (1, "What is %s (type %d) doing here?\n",
			 s->name, s->type);
}

/*
 * Generate a prototype for a free function for the `s' type
 * and output it to `f'
 */

void
generate_freefunction_prototype(Symbol *s, FILE *f)
{
     if (s->type == YDR_TSTRUCT
	 || s->type == YDR_TENUM
	 || s->type == YDR_TTYPEDEF) {
	  generate_freefunction_definition (s, f);
	  fprintf (f, ";\n");
     } else if (s->type == YDR_TCONST
		|| s->type == YDR_TENUMVAL 
		|| s->type == YDR_TTYPEDEF)
d1397 2
a1398 2
	 && a->type->type != YDR_TPOINTER
	 && a->type->type != YDR_TSTRING)
d1440 1
a1440 1
     if (a->type->type == YDR_TPOINTER)
a1448 11
genzero (List *list, Listitem *item, void *arg)
{
     Argument *a = (Argument *)listdata (item);
     FILE *f = (FILE *)arg;

     fprintf (f, "memset(&%s, 0, sizeof(%s));\n",
	      a->name, a->name);
     return FALSE;
}

static Bool
d1451 1
a1451 1
    if (type->type == YDR_TVARRAY)
d1453 1
a1453 1
    if (type->type == YDR_TPOINTER)
d1455 1
a1455 1
    if (type->type == YDR_TUSERDEF &&
d1457 1
a1457 1
	type->symbol->type == YDR_TTYPEDEF)
d1473 1
a1473 1
	      && a->type->type == YDR_TSTRING && a->type->size == 0)
d1485 1
a1485 1
	if (a->type->type == YDR_TPOINTER) {
d1505 1
a1505 1
	 if (a->type->type == YDR_TPOINTER) {
d1512 1
a1512 1
	 } else if(a->type->type == YDR_TSTRING) {
d1528 1
a1528 1
	  if (a->type->type == YDR_TPOINTER) {
d1551 1
a1551 1
	  if (a->type->type == YDR_TPOINTER)
d1588 1
a1588 1
     if (a->type->type == YDR_TPOINTER
d1590 1
a1590 1
	     && a->type->type == YDR_TSTRING && a->type->size == 0))
d1605 1
a1605 1
     Type type = {YDR_TLONG};
d1630 1
a1630 1
	      "ret = %s(rx_GetCallError(call));\n"
d1641 1
a1641 1
     Type type = {YDR_TLONG};
d1664 1
a1664 1
                 "return %s(rx_GetCallError(call));\n",
d1685 1
a1685 1
                 "return %s(rx_GetCallError(call));\n",
d1765 3
d1769 1
a1769 1
	      "RCSID(\"%s generated from %s.xg with $arla: output.c,v 1.91 2003/04/16 09:07:03 lha Exp $\");\n"
a1773 20
 * Convert filename into a cpp symbol
 */

static char *
cppfilesymbolname(const char *fn)
{
     char *symname, *tmp;

     symname = estrdup(fn);
     estrdup (symname);
     for (tmp = symname; *tmp; tmp++) {
	 if (tmp == symname && isdigit((unsigned char)*tmp))
	     *tmp = '_';
	 if (!isalpha((unsigned char)*tmp))
	     *tmp = '_';
     }
     return symname;
}

/*
d1781 1
a1781 1
     char *fileupr;
d1791 2
a1792 1
     fileupr = cppfilesymbolname(filename);
d1795 1
a1795 1
	      "#define _%s_\n\n", fileupr, fileupr);
d1797 1
a1797 1
     free (fileupr);
d1840 6
d1854 1
a1854 1
     char *fileupr;
d1856 1
a1856 1
     fileupr = cppfilesymbolname(filename);
a1857 1
     free(fileupr);
d1864 1
d1875 3
a1877 1
     fprintf (headerf, "int S%s%s%s(\nstruct rx_call *call\n",
d1882 1
a1882 1
     fprintf (f, "static int ydr_ps_%s%s(\nstruct rx_call *call)\n",
a1886 1
     listiter (s->u.proc.arguments, genzero, f);
d1889 1
a1889 1
     fprintf (f, "_result = S%s%s%s(", prefix, package, s->name);
d1904 1
a1904 1
	 fprintf(f, "return rx_GetCallError(call);\n");
d1930 1
a1930 1
		  "_result = ydr_ps_%s%s(call);\n"
d1946 1
a1946 1
     Type optype = {YDR_TULONG};
d1974 1
d1978 1
a1978 1
		  "return rx_GetCallError(call);\n"
d1985 42
d2030 88
@


