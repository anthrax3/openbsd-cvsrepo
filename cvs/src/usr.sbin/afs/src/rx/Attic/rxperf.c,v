head	1.6;
access;
symbols
	OPENBSD_5_2:1.5.0.36
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.34
	OPENBSD_5_0:1.5.0.32
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.30
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.28
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.24
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.5.0.26
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.5.0.22
	OPENBSD_4_5_BASE:1.5
	OPENBSD_4_4:1.5.0.20
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3:1.5.0.18
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.5.0.16
	OPENBSD_4_2_BASE:1.5
	OPENBSD_4_1:1.5.0.14
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.5.0.12
	OPENBSD_4_0_BASE:1.5
	OPENBSD_3_9:1.5.0.10
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.5.0.8
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.6
	OPENBSD_3_7_BASE:1.5
	OPENBSD_3_6:1.5.0.4
	OPENBSD_3_6_BASE:1.5
	OPENBSD_3_5:1.5.0.2
	OPENBSD_3_5_BASE:1.5
	OPENBSD_3_4:1.4.0.2
	OPENBSD_3_4_BASE:1.4
	arla-20030805:1.1.1.2
	OPENBSD_3_3:1.2.0.4
	OPENBSD_3_3_BASE:1.2
	OPENBSD_3_2:1.2.0.2
	OPENBSD_3_2_BASE:1.2
	arla-0-35-7:1.1.1.1
	arla:1.1.1
	OPENBSD_3_1:1.1.0.8
	OPENBSD_3_1_BASE:1.1
	OPENBSD_3_0:1.1.0.6
	OPENBSD_3_0_BASE:1.1
	OPENBSD_2_9_BASE:1.1
	OPENBSD_2_9:1.1.0.4
	OPENBSD_2_8:1.1.0.2
	OPENBSD_2_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.6
date	2012.08.23.06.21.55;	author deraadt;	state dead;
branches;
next	1.5;

1.5
date	2003.12.16.20.13.56;	author beck;	state Exp;
branches;
next	1.4;

1.4
date	2003.08.05.09.11.12;	author hin;	state Exp;
branches;
next	1.3;

1.3
date	2003.04.06.19.09.04;	author pvalchev;	state Exp;
branches;
next	1.2;

1.2
date	2002.06.07.04.43.30;	author hin;	state Exp;
branches;
next	1.1;

1.1
date	2000.09.11.14.41.23;	author art;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.06.07.04.14.35;	author hin;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.08.05.08.21.07;	author hin;	state Exp;
branches;
next	;


desc
@@


1.6
log
@the afs src tree can go away
@
text
@/*
 * Copyright (c) 2000 - 2002 Kungliga Tekniska Högskolan
 * (Royal Institute of Technology, Stockholm, Sweden).
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

/* 
 * We are using getopt since we want it to be possible to link to
 * transarc libs.
 */

#define HAVE_GETRUSAGE 1

#ifdef RCSID
RCSID("$arla: rxperf.c,v 1.23 2003/04/08 00:19:47 lha Exp $");
#endif

#include <stdarg.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/socket.h>
#include <sys/file.h>
#include <sys/stat.h>
#if HAVE_GETRUSAGE
#include <sys/resource.h>
#endif
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>
#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <string.h>
#include <assert.h>
#include <unistd.h>
#include <signal.h>
#ifdef HAVE_ERRX
#include <err.h> /* not stricly right, but if we have a errx() there
		  * is hopefully a err.h */
#endif
#include "rx.h"
#include "rx_globs.h"
#include "rx_null.h"

#if defined(u_int32)
#define uint32_t u_int32
#elif defined(hget32)
#define uint32_t afs_uint32
#endif

static const char *__progname;

#ifndef HAVE_WARNX
static void
warnx(const char *fmt, ...)
{
    va_list args;

    va_start(args, fmt);
    fprintf(stderr, "%s: ", __progname);
    vfprintf (stderr, fmt, args);
    fprintf(stderr, "\n");
    va_end(args);
}
#endif /* !HAVE_WARNX */
     
#ifndef HAVE_ERRX
static void
errx(int eval, const char *fmt, ...)
{
    va_list args;

    va_start(args, fmt);
    fprintf(stderr, "%s: ", __progname);
    vfprintf (stderr, fmt, args);
    fprintf(stderr, "\n");
    va_end(args);

    exit(eval);
}
#endif /* !HAVE_ERRX */

#ifndef HAVE_WARN
static void
warn(const char *fmt, ...)
{
    va_list args;
    char *errstr;

    va_start(args, fmt);
    fprintf(stderr, "%s: ", __progname);
    vfprintf (stderr, fmt, args);

    errstr = strerror(errno);
    
    fprintf(stderr, ": %s\n", errstr ? errstr : "unknown error");
    va_end(args);
}
#endif /* !HAVE_WARN */
     
#ifndef HAVE_ERR
static void
err(int eval, const char *fmt, ...)
{
    va_list args;
    char *errstr;

    va_start(args, fmt);
    fprintf(stderr, "%s: ", __progname);
    vfprintf (stderr, fmt, args);

    errstr = strerror(errno);
    
    fprintf(stderr, ": %s\n", errstr ? errstr : "unknown error");
    va_end(args);

    exit(eval);
}
#endif /* !HAVE_ERR */

#define DEFAULT_PORT 7009	/* To match tcpdump */
#define DEFAULT_HOST "127.0.0.1"
#define DEFAULT_BYTES 1000000
#define RXPERF_BUFSIZE 10000

enum { RX_PERF_VERSION = 3 };
enum { RX_SERVER_ID = 147 };
enum { RX_PERF_UNKNOWN = -1, RX_PERF_SEND = 0, RX_PERF_RECV = 1, 
       RX_PERF_RPC=3, RX_PERF_FILE=4 };

enum { RXPERF_MAGIC_COOKIE = 0x4711 };

/*
 *
 */

#if DEBUG
#define DBFPRINT(x) do { printf x ; } while(0)
#else
#define DBFPRINT(x)
#endif

static void
sigusr1 (int foo)
{
    exit (2); /* XXX profiler */
}

static void
sigint (int foo)
{
    rx_Finalize();
    exit (2); /* XXX profiler */
}

/*
 *
 */

static struct timeval timer_start;
static struct timeval timer_stop;
static int timer_check = 0;

static void
start_timer (void)
{
    timer_check++;
    gettimeofday (&timer_start, NULL);
}

/*
 *
 */

static void
end_and_print_timer (char *str)
{
    long long start_l, stop_l;

    timer_check--; 
    assert (timer_check == 0);
    gettimeofday(&timer_stop, NULL);
    start_l = timer_start.tv_sec * 1000000 + timer_start.tv_usec;
    stop_l = timer_stop.tv_sec * 1000000 + timer_stop.tv_usec;
    printf("%s:\t%8llu msec\n", str, (stop_l-start_l)/1000);
}

/*
 *
 */

static u_long
str2addr (const char *s)
{
    struct in_addr server;
    struct hostent *h;

#ifndef INADDR_NONE
#define INADDR_NONE 0xffffffff
#endif
    if (inet_addr(s) != INADDR_NONE)
        return inet_addr(s);
    h = gethostbyname (s);
    if (h != NULL) {
	memcpy (&server, h->h_addr_list[0], sizeof(server));
	return server.s_addr;
    }
    return 0;
}


/*
 *
 */

static void
get_sec(int serverp, struct rx_securityClass** sec, int *secureindex)
{
    if (serverp) {
	*sec = rxnull_NewServerSecurityObject();
	*secureindex = 1;
    } else {
	*sec = rxnull_NewClientSecurityObject();
	*secureindex = 0;
    }
}

/*
 * process the "RPC" and return the results
 */

char somebuf[RXPERF_BUFSIZE];

int32_t rxwrite_size = sizeof(somebuf);
int32_t rxread_size = sizeof(somebuf);

static int
readbytes(struct rx_call *call, int32_t bytes)
{
    int32_t size;

    while (bytes > 0) {
	size = rxread_size;
	if (size > bytes)
	    size = bytes;
	if (rx_Read (call, somebuf, size) != size)
	    return 1;
	bytes -= size;
    }
    return 0;
}

static int
sendbytes(struct rx_call *call, int32_t bytes)
{
    int32_t size;

    while (bytes > 0) {
	size = rxwrite_size;
	if (size > bytes)
	    size = bytes;
	if (rx_Write (call, somebuf, size) != size)
	    return 1;
	bytes -= size;
    }
    return 0;
}


static int32_t
rxperf_ExecuteRequest(struct rx_call *call)
{
    int32_t version;
    int32_t command;
    uint32_t bytes;
    uint32_t recvb;
    uint32_t sendb;
    uint32_t data;
    uint32_t num;
    uint32_t *readwrite;
    int i;
    int readp=TRUE;

    DBFPRINT(("got a request\n"));

    if (rx_Read (call, &version, 4) != 4) {
	warn ("rx_Read failed to read version");
	return -1;
    }

    if (htonl(RX_PERF_VERSION) != version) {
	warnx ("client has wrong version");
	return -1;
    }
	
    if (rx_Read (call, &command, 4) != 4) {
	warnx ("rx_Read failed to read command");
	return -1;
    }
    command = ntohl(command);

    if (rx_Read (call, &data, 4) != 4) {
	warnx ("rx_Read failed to read size");
	return -1;
    }
    rxread_size = ntohl(data);
    if (rxread_size > sizeof(somebuf)) {
	warnx("rxread_size too large %d", rxread_size);
	return -1;
    }

    if (rx_Read (call, &data, 4) != 4) {
	warnx ("rx_Read failed to write size");
	return -1;
    }
    rxwrite_size = ntohl(data);
    if (rxwrite_size > sizeof(somebuf)) {
	warnx("rxwrite_size too large %d", rxwrite_size);
	return -1;
    }

    switch (command) {
    case RX_PERF_SEND:
	DBFPRINT(("got a send request\n"));

	if (rx_Read (call, &bytes, 4) != 4) {
	    warnx ("rx_Read failed to read bytes");
	    return -1;
	}
	bytes = ntohl(bytes);

	DBFPRINT(("reading(%d) ", bytes));
	readbytes(call, bytes);

	data = htonl(RXPERF_MAGIC_COOKIE);
	if (rx_Write (call, &data, 4) != 4) {
	    warnx ("rx_Write failed when sending back result");
	    return -1;
	}
	DBFPRINT(("done\n"));

	break;
    case RX_PERF_RPC:
	DBFPRINT(("got a rpc request, reading commands\n"));
	
	if (rx_Read (call, &recvb, 4) != 4) {
	    warnx ("rx_Read failed to read recvbytes");
	    return -1;
	}
	recvb = ntohl(recvb);
	if (rx_Read (call, &sendb, 4) != 4) {
	    warnx ("rx_Read failed to read recvbytes");
	    return -1;
	}
	sendb = ntohl(sendb);

	DBFPRINT(("read(%d) ", recvb));
	if (readbytes(call, recvb)) {
	    warnx("readbytes failed");
	    return -1;
	}
	DBFPRINT(("send(%d) ", sendb));
	if (sendbytes(call, sendb)) {
	    warnx("sendbytes failed");
	    return -1;
	}
	
	DBFPRINT(("done\n"));

	data = htonl(RXPERF_MAGIC_COOKIE);
	if (rx_Write (call, &data, 4) != 4) {
	    warnx ( "rx_Write failed when sending back magic cookie");
	    return -1;
	}

	break;
    case RX_PERF_FILE:
	if (rx_Read (call, &data, 4) != 4)
	    errx (1, "failed to read num from client");
	num = ntohl(data);

	readwrite = malloc(num*sizeof(uint32_t));
	if(readwrite == NULL)
	    err(1, "malloc");

	if (rx_Read (call, readwrite, num*sizeof(uint32_t)) !=
	    num*sizeof(uint32_t))
	    errx (1, "failed to read recvlist from client");

	    for(i=0; i < num; i++) {
		if(readwrite[i] == 0) {
		    DBFPRINT(("readp %d", readwrite[i] ));
		    readp = !readp;
		}

		bytes = ntohl(readwrite[i])*sizeof(uint32_t);

		if(readp) {
		    DBFPRINT(("read\n"));
		    readbytes(call, bytes);
		} else {
		    sendbytes(call, bytes);
		    DBFPRINT(("send\n"));
		}
	    }

	break;
    case RX_PERF_RECV:
	DBFPRINT(("got a recv request\n"));

	if (rx_Read (call, &bytes, 4) != 4) {
	    warnx ("rx_Read failed to read bytes");
	    return -1;
	}
	bytes = ntohl(bytes);

	DBFPRINT(("sending(%d) ", bytes));
	sendbytes(call, bytes);

	data = htonl(RXPERF_MAGIC_COOKIE);
	if (rx_Write (call, &data, 4) != 4) {
	    warnx ("rx_Write failed when sending back result");
	    return -1;
	}
	DBFPRINT(("done\n"));

	break;
    default:
	warnx ("client sent a unsupported command");
	return -1;
    }
    DBFPRINT(("done with command\n"));

    return 0;
}

/*
 *
 */

static void
do_server (int port)
{
    struct rx_service *service;
    struct rx_securityClass *secureobj;
    int secureindex;
    int ret;

    ret = rx_Init (port);
    if (ret)
	errx (1, "rx_Init failed");

    get_sec(1, &secureobj, &secureindex);
    
    service = rx_NewService (0,
			     RX_SERVER_ID,
			     "rxperf", 
			     &secureobj, 
			     secureindex, 
			     rxperf_ExecuteRequest);
    if (service == NULL) 
	errx(1, "Cant create server");

    rx_StartServer(1) ;
    /* NOTREACHED */
    errx(1, "rx_Startserver return, should not happen");
}

/*
 *
 */

static void
readfile(const char *filename, uint32_t **readwrite, uint32_t *size)
{
    FILE *f;
    uint32_t len=16;
    uint32_t num=0;
    uint32_t data;
    char *ptr;
    char buf[RXPERF_BUFSIZE];

    *readwrite = malloc(sizeof(uint32_t)*len);

    if(*readwrite == NULL)
	err(1, "malloc");

    f=fopen(filename, "r");
    if(f==NULL)
	err(1, "fopen");

    while(fgets(buf, sizeof(buf), f) != NULL) {

	buf[strcspn(buf, "\n")] = '\0';

	if(num >= len) {
	    len=len*2;
	    *readwrite = realloc(*readwrite, len*sizeof(uint32_t));
	    if(*readwrite == NULL)
		err(1, "realloc");
	}

	if(*buf != '\0') {
	    data = htonl(strtol (buf, &ptr, 0));
	    if (ptr && ptr == buf)
		errx (1, "can't resolve number of bytes to transfer");
	} else {
	    data = 0;
	}
	
	(*readwrite)[num] =data;
	num++;
    }

    *size = num;

    
    if(fclose(f) == -1)
	err(1, "fclose");
}


/*
 *
 */

static void
do_client (const char *server, int port, char *filename,
	   int32_t command, int32_t times, 
	   int32_t bytes, int32_t rpc_sendbytes, int32_t rpc_recvbytes)
{
    struct rx_connection *conn;
    struct rx_call *call;
    uint32_t addr = str2addr(server);
    struct rx_securityClass *secureobj;
    int secureindex;
    int32_t data;
    int32_t num;
    int ret;
    int i;
    int readp = FALSE;
    char stamp[1024];
    uint32_t size;

    uint32_t *readwrite;

    ret = rx_Init (0);
    if (ret)
	errx (1, "rx_Init failed");

    get_sec(0, &secureobj, &secureindex);

    conn = rx_NewConnection(addr, 
			    port, 
			    RX_SERVER_ID,
			    secureobj,
			    secureindex);
    if (conn == NULL)
	errx (1, "failed to contact server");

    if (command == RX_PERF_RPC)
	    snprintf (stamp, sizeof(stamp), 
		      "send\t%d times\t%d writes\t%d reads", 
		      times, rpc_sendbytes, rpc_recvbytes);
    else
	    snprintf (stamp, sizeof(stamp),
		      "send\t%d times", times);

    start_timer();

    for(i=0; i < times ; i++) {

	DBFPRINT(("starting command "));

	call = rx_NewCall (conn);
	if (call == NULL)
	    errx (1, "rx_NewCall failed");
	
	data = htonl(RX_PERF_VERSION);
	if (rx_Write (call, &data, 4) != 4)
	    errx (1, "rx_Write failed to send version");
	
	data = htonl(command);
	if (rx_Write (call, &data, 4) != 4)
	    errx (1, "rx_Write failed to send command");

	data = htonl(rxread_size);
	if (rx_Write (call, &data, 4) != 4)
	    errx (1, "rx_Write failed to send read size");
	data = htonl(rxwrite_size);
	if (rx_Write (call, &data, 4) != 4)
	    errx (1, "rx_Write failed to send write read");


	switch (command) {
	case RX_PERF_RECV:
	    DBFPRINT(("command "));

	    data = htonl (bytes);
	    if (rx_Write (call, &data, 4) != 4)
		errx (1, "rx_Write failed to send size");	    
	    
	    DBFPRINT(("sending(%d) ", bytes));
	    if (readbytes(call, bytes))
		errx(1, "sendbytes");

	    if (rx_Read (call, &data, 4) != 4)
		errx (1, "failed to read result from server");
	    
	    if (data != htonl(RXPERF_MAGIC_COOKIE))
		warn("server send wrong magic cookie in responce");

	    DBFPRINT(("done\n"));

	    break;
	case RX_PERF_SEND:
	    DBFPRINT(("command "));

	    data = htonl (bytes);
	    if (rx_Write (call, &data, 4) != 4)
		errx (1, "rx_Write failed to send size");	    
	    
	    DBFPRINT(("sending(%d) ", bytes));
	    if (sendbytes(call, bytes))
		errx(1, "sendbytes");

	    if (rx_Read (call, &data, 4) != 4)
		errx (1, "failed to read result from server");
	    
	    if (data != htonl(RXPERF_MAGIC_COOKIE))
		warn("server send wrong magic cookie in responce");

	    DBFPRINT(("done\n"));

	    break;
	case RX_PERF_RPC:
	    DBFPRINT(("commands "));

	    data = htonl(rpc_sendbytes);
	    if (rx_Write(call, &data, 4) != 4)
		errx (1, "rx_Write failed to send command");
	    
	    data = htonl(rpc_recvbytes);
	    if (rx_Write (call, &data, 4) != 4)
		errx (1, "rx_Write failed to send command");
	    
	    DBFPRINT(("send(%d) ", rpc_sendbytes));
	    sendbytes(call, rpc_sendbytes);
	    
	    DBFPRINT(("recv(%d) ", rpc_recvbytes));
	    readbytes(call, rpc_recvbytes);
	    
	    if (rx_Read (call, &bytes, 4) != 4)
		errx (1, "failed to read result from server");
	    
	    if (bytes != htonl(RXPERF_MAGIC_COOKIE))
		warn("server send wrong magic cookie in responce");

	    DBFPRINT(("done\n"));

	    break;
	case RX_PERF_FILE:
	    readfile(filename, &readwrite, &num);

	    data = htonl(num);
	    if (rx_Write(call, &data, sizeof(data)) != 4)
		errx (1, "rx_Write failed to send size");

	    if (rx_Write(call, readwrite, num*sizeof(uint32_t)) 
		!= num*sizeof(uint32_t))
		errx (1, "rx_Write failed to send list");

	    for(i=0; i < num; i++) {
		if(readwrite[i] == 0)
		    readp = !readp;

		size = ntohl(readwrite[i])*sizeof(uint32_t);

		if(readp) {
		    readbytes(call, size);
		    DBFPRINT(("read\n"));
		} else {
		    sendbytes(call, size);
		    DBFPRINT(("send\n"));
		}
	    }
	    break;
	default:
	    errx(-1, "do_client: unknown command %x", command); 
	}

	rx_EndCall (call, 0);
    }

    end_and_print_timer (stamp);
    DBFPRINT(("done for good\n"));

    rx_Finalize();
}

static void
usage()
{
#define COMMON ""

    fprintf(stderr, "usage: %s client -c send -b <bytes>\n",
	    __progname);
    fprintf(stderr, "usage: %s client -c recv -b <bytes>\n",
	    __progname);
    fprintf(stderr, "usage: %s client -c rpc  -S <rpc_sendbytes> -R <rpc_recvbytes>\n",
	    __progname);
    fprintf(stderr, "usage: %s client -c file -f filename\n", 
	    __progname);
    fprintf (stderr, "%s: usage:	common option to the client "
	     "-w <rx_write size> -r <rx_read size> -T times -p port -s server\n",
	     __progname);
    fprintf(stderr, "usage: %s server -p port\n", __progname);
#undef COMMMON
    exit(1);
}

/*
 * do argument processing and call networking functions
 */

static int
rxperf_server (int argc, char **argv)
{
    int port	   = DEFAULT_PORT;
    char *ptr;
    int ch;

    while ((ch = getopt(argc, argv, "r:d:p:w:")) != -1) {
	switch (ch) {
	case 'd':
#ifdef RXDEBUG
	    rx_debugFile = fopen(optarg, "w");
	    if (rx_debugFile == NULL)
		err(1, "fopen %s", optarg);
#else
	    errx(1, "compiled without RXDEBUG");
#endif
	    break;
	case 'r':
	    rxread_size = strtol(optarg, &ptr, 0);
	    if (ptr != 0 && ptr[0] != '\0')
		errx (1, "can't resolve readsize");
	    if (rxread_size > sizeof(somebuf))
	      errx(1, "%d > sizeof(somebuf) (%d)",
		   rxread_size, sizeof(somebuf));
	    break;
	case 'p':
	    port = strtol(optarg, &ptr, 0);
	    if (ptr != 0 && ptr[0] != '\0')
		errx (1, "can't resolve portname");
	    break;
	case 'w':
	    rxwrite_size = strtol(optarg, &ptr, 0);
	    if (ptr != 0 && ptr[0] != '\0')
		errx (1, "can't resolve writesize");
	    if (rxwrite_size > sizeof(somebuf))
		errx(1, "%d > sizeof(somebuf) (%d)",
		     rxwrite_size, sizeof(somebuf));
	    break;
	default:
	    usage();
	}
    }

    if (optind != argc)
	usage();
    
    do_server (htons(port));

    return 0;
}

/*
 * do argument processing and call networking functions
 */

static int
rxperf_client (int argc, char **argv)
{
    char *host	   = DEFAULT_HOST;
    int bytes	   = DEFAULT_BYTES;
    int port	   = DEFAULT_PORT;
    char *filename = NULL;
    int32_t cmd;
    int rpc_sendbytes = 3;
    int rpc_recvbytes = 30;
    int print_stats = 0;
    int times = 100;
    char *ptr;
    int ch;

    cmd = RX_PERF_UNKNOWN;
    
    while ((ch  = getopt(argc, argv, "GT:S:R:b:c:d:p:r:s:w:f:")) != -1) {
	switch (ch) {
	case 'G':
	    print_stats = 1;
#ifndef HAVE_GETRUSAGE
	    printf("could not find getrusage, can't print stats\n");
#endif
	    break;
	case 'b':
	    bytes = strtol (optarg, &ptr, 0);
	    if (ptr && *ptr != '\0')
		errx (1, "can't resolve number of bytes to transfer");
	    break;
	case 'c':
	    if (strcasecmp(optarg, "send") == 0)
	      cmd = RX_PERF_SEND;
	    else if (strcasecmp(optarg, "recv") == 0)
		cmd = RX_PERF_RECV;
	    else if (strcasecmp(optarg, "rpc") == 0)
		cmd = RX_PERF_RPC;
	    else if (strcasecmp(optarg, "file") == 0)
		cmd = RX_PERF_FILE;
	    else
		errx(1, "unknown command %s", optarg);
	    break;
	case 'd':
#ifdef RXDEBUG
	    rx_debugFile = fopen(optarg, "w");
	    if (rx_debugFile == NULL)
		err(1, "fopen %s", optarg);
#else
	    errx(1, "compiled without RXDEBUG");
#endif
	    break;
	case 'p':
	    port = strtol(optarg, &ptr, 0);
	    if (ptr != 0 && ptr[0] != '\0')
		errx (1, "can't resolve portname");
	    break;
	case 'r':
	    rxread_size = strtol(optarg, &ptr, 0);
	    if (ptr != 0 && ptr[0] != '\0')
		errx (1, "can't resolve readsize");
	    if (rxread_size > sizeof(somebuf))
		errx(1, "%d > sizeof(somebuf) (%d)",
		     rxread_size, sizeof(somebuf));
	    break;
	case 's':
	    host = strdup(optarg);
	    if (host == NULL)
		err(1, "strdup");
	    break;
	case 'w':
	    rxwrite_size = strtol(optarg, &ptr, 0);
	    if (ptr != 0 && ptr[0] != '\0')
		errx (1, "can't resolve writesize");
	    if (rxwrite_size > sizeof(somebuf))
		errx(1, "%d > sizeof(somebuf) (%d)",
		     rxwrite_size, sizeof(somebuf));
	    break;
	case 'T':
	    times = strtol (optarg, &ptr, 0);
	    if (ptr && *ptr != '\0')
		errx (1, "can't resolve number times to run the test");
	    break;
	case 'S':
	    rpc_sendbytes = strtol (optarg, &ptr, 0);
	    if (ptr && *ptr != '\0')
		errx (1, "can't resolve number of bytes to transfer");
	    break;
	case 'R':
	    rpc_recvbytes = strtol (optarg, &ptr, 0);
	    if (ptr && *ptr != '\0')
		errx (1, "can't resolve number of bytes to transfer");
	    break;
	case 'f':
	    filename = optarg;
	    break;
	default:
	    usage();
	}
    }

    if (optind != argc)
	usage();
    
    if (cmd == RX_PERF_UNKNOWN)
	errx(1, "no command given to the client");
    
    do_client(host, htons(port), filename, cmd, times, bytes, 
	      rpc_sendbytes, rpc_recvbytes);
    
#if HAVE_GETRUSAGE
    if (print_stats) {
	struct rusage rusage;
	if(getrusage (RUSAGE_SELF, &rusage) < 0)
	    printf("no stats\n");
	else
	    printf ("Status:\n"
		    "- utime = (%ld, %ld)\n"
		    "- stime = (%ld, %ld)\n"
		    "- maxrss = %ld\n"
		    "- ixrss = %ld\n"
		    "- idrss = %ld\n"
		    "- isrss = %ld\n"
		    "- minflt = %ld\n"
		    "- majflt = %ld\n"
		    "- nswap = %ld\n"
		    "- inblock = %ld\n"
		    "- oublock = %ld\n"
		    "- msgsnd = %ld\n"
		    "- msgrcv = %ld\n"
		    "- nsignals = %ld\n"
		    "- nvcsw = %ld\n"
		    "- nivcws = %ld\n",
		    rusage.ru_utime.tv_sec,
		    rusage.ru_utime.tv_usec,
		    rusage.ru_stime.tv_sec,
		    rusage.ru_stime.tv_usec,
		    rusage.ru_maxrss,
		    rusage.ru_ixrss,
		    rusage.ru_idrss,
		    rusage.ru_isrss,
		    rusage.ru_minflt,
		    rusage.ru_majflt,
		    rusage.ru_nswap,
		    rusage.ru_inblock,
		    rusage.ru_oublock,
		    rusage.ru_msgsnd,
		    rusage.ru_msgrcv,
		    rusage.ru_nsignals,
		    rusage.ru_nvcsw,
		    rusage.ru_nivcsw);
    }
#endif /* HAVE_GETRUSAGE */
    return 0;
}
    
/*
 * setup world and call cmd
 */

int
main(int argc, char **argv)
{
    PROCESS pid;

    __progname = strrchr(argv[0], '/');
    if (__progname)
	__progname++;
    else
	__progname = argv[0];

    signal (SIGUSR1, sigusr1);
    signal (SIGINT, sigint);

    LWP_InitializeProcessSupport (LWP_NORMAL_PRIORITY, &pid);
    
    memset (somebuf, 0, sizeof(somebuf));

    if (argc >= 2 && strcmp(argv[1], "server") == 0)
	rxperf_server(argc - 1, argv + 1);
    else if (argc >= 2 && strcmp(argv[1], "client") == 0)
	rxperf_client(argc - 1, argv + 1);
    else
	usage();
    return 0;
}

@


1.5
log
@afs cleanup, realloc strings, abort, etc.
testing by beck, hin, jose, fries. ok deraadt@@
@
text
@@


1.4
log
@Merge
@
text
@d496 2
a497 1
    abort();
d720 1
a720 1
	    abort();
@


1.3
log
@strcpy/strcat/sprintf cleanups; ok krw deraadt
@
text
@d2 1
a2 1
 * Copyright (c) 2000 Kungliga Tekniska Högskolan
d43 2
d46 1
a46 1
RCSID("$KTH: rxperf.c,v 1.3 2000/10/03 00:41:39 lha Exp $");
d49 1
d55 3
d64 1
a64 1
#include <strings.h>
d73 1
d77 1
a77 1
#define u_int32_t u_int32
d79 1
a79 1
#define u_int32_t afs_uint32
d84 14
d100 1
a100 1
errx(int eval, const char *fmt)
d102 9
a110 2
  fprintf(stderr, "%s: %s", __progname, fmt);
  exit(eval);
d114 1
a114 1
#ifndef HAVE_WARNX
d116 1
a116 1
warnx(const char *fmt)
d118 11
a128 1
  fprintf(stderr, "%s: %s", __progname, fmt);
d130 1
a130 1
#endif /* !HAVE_WARNX */
d132 1
a132 1
#ifndef HAVE_WARN
d134 1
a134 1
warn(const char *fmt)
d136 13
a148 1
  fprintf(stderr, "%s: %s", __progname, fmt);
d150 2
a151 2
#endif /* HAVE_WARN */
     
d155 1
a155 1
#define RXPERF_BUFSIZE 1400
d157 1
a157 1
enum { RX_PERF_VERSION = 0 };
d159 2
a160 1
enum { RX_PERF_SEND = 0, RX_PERF_RECV = 1 };
d162 1
d168 6
d180 7
d263 38
d306 10
a315 3
    u_int32_t bytes;
    char buf[RXPERF_BUFSIZE];
    int size;
d333 7
a339 2
    if (rx_Read (call, &bytes, 4) != 4) {
	warnx ("rx_Read failed to read bytes");
a341 1
    bytes = ntohl(bytes);
d343 9
a351 1
    memset (buf, 0, sizeof(buf));
d355 42
a396 7
	while (bytes > 0) {
	    size = sizeof(buf);
	    if (size > bytes)
		size = bytes;
	    if (rx_Read (call, buf, size) != size)
		errx (1, "rx_Read failed to read data");
	    bytes -= size;
d398 7
a404 4
	{
	    int32_t data = htonl(4711); /* XXX */
	    if (rx_Write (call, &data, 4) != 4)
		errx (1, "rx_Write failed when sending back result");
d406 32
d440 19
d463 2
d504 57
a560 1
do_client (const char *server, int port, int32_t bytes)
d564 1
a564 1
    u_int32_t addr = str2addr(server);
a566 1
    char buf[RXPERF_BUFSIZE];
d568 1
a568 1
    int size;
d570 2
d573 1
d575 1
a575 2
    for (size = 0; size < RXPERF_BUFSIZE; size++)
      buf[size] = rand() >> 3;
d591 7
a597 11
    call = rx_NewCall (conn);
    if (call == NULL)
	errx (1, "rx_NewCall failed");

    data = htonl(RX_PERF_VERSION);
    if (rx_Write (call, &data, 4) != 4)
	errx (1, "rx_Write failed to send version");

    data = htonl(RX_PERF_SEND);
    if (rx_Write (call, &data, 4) != 4)
	errx (1, "rx_Write failed to send command");
a598 1
    snprintf (stamp, sizeof(stamp), "send       %d bytes", bytes);
a599 4
    
    data = htonl (bytes);
    if (rx_Write (call, &data, 4) != 4)
	errx (1, "rx_Write failed to send size");
d601 122
a722 7
    while (bytes > 0) {
	size = sizeof (buf);
	if (size > bytes)
	    size = bytes;
	if (rx_Write (call, buf, size) != size)
	    errx (1, "failed when bytes where still left to send");
	bytes -= size;
d724 1
a724 2
    if (rx_Read (call, &bytes, 4) != 4)
	errx (1, "failed to read result from server");
d726 2
a727 1
    rx_EndCall (call, 0);
d734 16
a749 4
  fprintf(stderr, "usage: %s (client) -b bytes -p port -s server\n",
	  __progname);
  fprintf(stderr, "usage: %s server -p port\n", __progname);
  exit(1);
d763 38
a800 8
    while ((ch = getopt(argc, argv, "p:")) != -1)
      switch (ch) {
      case 'p':
	port = strtol(optarg, &ptr, 0);
	if (ptr != 0 && ptr[0] != '\0')
	    errx (1, "can't resolve portname");
	break;
      default:
a801 3
      }
    if (optind != argc)
      usage();
d818 6
d827 86
a912 16
    while ((ch  = getopt(argc, argv, "b:p:s:")) != -1)
      switch (ch) {
      case 'b':
	bytes = strtol (optarg, &ptr, 0);
	if (ptr && *ptr != '\0')
	  errx (1, "can't resolve number of bytes to transfer");
	break;
      case 'p':
	port = strtol(optarg, &ptr, 0);
	if (ptr != 0 && ptr[0] != '\0')
	    errx (1, "can't resolve portname");
	break;
      case 's':
	host = optarg;
	break;
      default:
a913 3
      }
    if (optind != argc)
      usage();
d915 49
a963 2
    do_client (host, htons(port), bytes);

d966 1
a966 1

d977 4
a980 2
    if (__progname == 0)
      __progname = argv[0];
d983 1
d986 2
d990 1
a990 1
      rxperf_server(argc - 1, argv + 1);
d992 1
a992 1
      rxperf_client(argc - 1, argv + 1);
d994 1
a994 1
      rxperf_client(argc, argv);
@


1.2
log
@merge
@
text
@d333 1
a333 1
    sprintf (stamp, "send       %d bytes", bytes);
@


1.1
log
@New Arla userland from Arla between 0.34.2 and current in arla cvs.
Too many new features and fixes to mention here.
@
text
@d17 1
a17 6
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by the Kungliga Tekniska
 *      Högskolan and its contributors.
 * 
 * 4. Neither the name of the Institute nor the names of its contributors
d38 8
a45 1
RCSID("$Id: rxperf.c,v 1.1 2000/07/15 23:05:43 lha Exp $");
d61 13
a73 1
#include <cmd.h>
d75 1
a75 2
#include <roken.h>
#include <err.h>
d77 8
a84 2
#include "rx.h"
#include "rx_null.h"
d86 17
a102 1
#define DEFAULT_PORT 4711
d164 5
a168 2
    if (inet_aton (s, &server) == 1)
	return server.s_addr;
d249 1
a249 1
	warnx ("client sent a unsupported command: %d", command);
d302 1
a302 1
    char *stamp;
d304 2
a305 1
    memset (buf, 0, sizeof(buf));
d319 1
a319 1
	errx (1, "failed to contact %s", server);
d333 1
a333 1
    asprintf (&stamp, "send       %d bytes", bytes);
d345 1
a345 1
	    errx (1, "failed when %d bytes was left to send", bytes);
d352 10
d369 1
a369 1
rxperf_server (struct cmd_syndesc *as, void *arock)
a371 1
    char *portname;
d373 1
d375 5
a379 4
    if (as->parms[0].items) {
	portname = as->parms[1].items->data;
	port = strtol (portname, &ptr, 0);
	if (ptr && ptr != '\0')
d381 6
a386 1
    }
d398 1
a398 1
rxperf_client (struct cmd_syndesc *as, void *arock)
a402 2
    char *numbytes = NULL;
    char *portname;
d404 1
d406 10
a415 7
    if (as->parms[0].items)
	host = as->parms[0].items->data;

    if (as->parms[1].items) {
	portname = as->parms[1].items->data;
	port = strtol (portname, &ptr, 0);
	if (ptr && ptr != '\0')
d417 9
a425 1
    }
a426 7
    if (as->parms[2].items) {
	numbytes = as->parms[2].items->data;
	bytes = strtol (numbytes, &ptr, 0);
	if (ptr && *ptr != '\0')
	    errx (1, "can't resolve number of bytes to transfer");
    }

a438 1
    struct cmd_syndesc *ts;
d441 3
a443 1
    set_progname (argv[0]);
a446 8
    ts = cmd_CreateSyntax("server", rxperf_server, NULL, "server");
    cmd_AddParm(ts, "-port", CMD_SINGLE, CMD_OPTIONAL, "udp port");

    ts = cmd_CreateSyntax("client", rxperf_client, NULL, "client");
    cmd_AddParm(ts, "-server", CMD_SINGLE, CMD_OPTIONAL, "server machine");
    cmd_AddParm(ts, "-port", CMD_SINGLE, CMD_OPTIONAL, "udp port");
    cmd_AddParm(ts, "-bytes", CMD_SINGLE, CMD_OPTIONAL, "number of bytes to transfer");

d449 6
a454 1
    cmd_Dispatch(argc, argv);
d457 1
@


1.1.1.1
log
@Import of arla-0.35.7
@
text
@d17 6
a22 1
 * 3. Neither the name of the Institute nor the names of its contributors
d43 1
a43 8
/* 
 * We are using getopt since we want it to be possible to link to
 * transarc libs.
 */

#ifdef RCSID
RCSID("$KTH: rxperf.c,v 1.3 2000/10/03 00:41:39 lha Exp $");
#endif
d59 5
a63 5
#include <signal.h>
#ifdef HAVE_ERRX
#include <err.h> /* not stricly right, but if we have a errx() there
		  * is hopefully a err.h */
#endif
d67 1
a67 34
#if defined(u_int32)
#define u_int32_t u_int32
#elif defined(hget32)
#define u_int32_t afs_uint32
#endif

static const char *__progname;

#ifndef HAVE_ERRX
static void
errx(int eval, const char *fmt)
{
  fprintf(stderr, "%s: %s", __progname, fmt);
  exit(eval);
}
#endif /* !HAVE_ERRX */

#ifndef HAVE_WARNX
static void
warnx(const char *fmt)
{
  fprintf(stderr, "%s: %s", __progname, fmt);
}
#endif /* !HAVE_WARNX */
     
#ifndef HAVE_WARN
static void
warn(const char *fmt)
{
  fprintf(stderr, "%s: %s", __progname, fmt);
}
#endif /* HAVE_WARN */
     
#define DEFAULT_PORT 7009	/* To match tcpdump */
d129 2
a130 5
#ifndef INADDR_NONE
#define INADDR_NONE 0xffffffff
#endif
    if (inet_addr(s) != INADDR_NONE)
        return inet_addr(s);
d211 1
a211 1
	warnx ("client sent a unsupported command");
d264 1
a264 1
    char stamp[1024];
d266 1
a266 2
    for (size = 0; size < RXPERF_BUFSIZE; size++)
      buf[size] = rand() >> 3;
d280 1
a280 1
	errx (1, "failed to contact server");
d294 1
a294 1
    sprintf (stamp, "send       %d bytes", bytes);
d306 1
a306 1
	    errx (1, "failed when bytes where still left to send");
a312 10
    rx_Finalize();
}

static void
usage()
{
  fprintf(stderr, "usage: %s (client) -b bytes -p port -s server\n",
	  __progname);
  fprintf(stderr, "usage: %s server -p port\n", __progname);
  exit(1);
d320 1
a320 1
rxperf_server (int argc, char **argv)
d323 1
a324 1
    int ch;
d326 4
a329 5
    while ((ch = getopt(argc, argv, "p:")) != -1)
      switch (ch) {
      case 'p':
	port = strtol(optarg, &ptr, 0);
	if (ptr != 0 && ptr[0] != '\0')
d331 1
a331 6
	break;
      default:
	usage();
      }
    if (optind != argc)
      usage();
d343 1
a343 1
rxperf_client (int argc, char **argv)
d348 2
a350 1
    int ch;
d352 7
a358 10
    while ((ch  = getopt(argc, argv, "b:p:s:")) != -1)
      switch (ch) {
      case 'b':
	bytes = strtol (optarg, &ptr, 0);
	if (ptr && *ptr != '\0')
	  errx (1, "can't resolve number of bytes to transfer");
	break;
      case 'p':
	port = strtol(optarg, &ptr, 0);
	if (ptr != 0 && ptr[0] != '\0')
d360 1
a360 9
	break;
      case 's':
	host = optarg;
	break;
      default:
	usage();
      }
    if (optind != argc)
      usage();
d362 7
d381 1
d384 1
a384 3
    __progname = strrchr(argv[0], '/');
    if (__progname == 0)
      __progname = argv[0];
d388 8
d398 1
a398 6
    if (argc >= 2 && strcmp(argv[1], "server") == 0)
      rxperf_server(argc - 1, argv + 1);
    else if (argc >= 2 && strcmp(argv[1], "client") == 0)
      rxperf_client(argc - 1, argv + 1);
    else
      rxperf_client(argc, argv);
a400 1

@


1.1.1.2
log
@Import of arla -current as of Aug 5 2003

ok todd@@ deraadt@@
@
text
@d2 1
a2 1
 * Copyright (c) 2000 - 2002 Kungliga Tekniska Högskolan
a42 2
#define HAVE_GETRUSAGE 1

d44 1
a44 1
RCSID("$arla: rxperf.c,v 1.23 2003/04/08 00:19:47 lha Exp $");
a46 1
#include <stdarg.h>
a51 3
#if HAVE_GETRUSAGE
#include <sys/resource.h>
#endif
d58 1
a58 1
#include <string.h>
a66 1
#include "rx_globs.h"
d70 1
a70 1
#define uint32_t u_int32
d72 1
a72 1
#define uint32_t afs_uint32
a76 14
#ifndef HAVE_WARNX
static void
warnx(const char *fmt, ...)
{
    va_list args;

    va_start(args, fmt);
    fprintf(stderr, "%s: ", __progname);
    vfprintf (stderr, fmt, args);
    fprintf(stderr, "\n");
    va_end(args);
}
#endif /* !HAVE_WARNX */
     
d79 1
a79 1
errx(int eval, const char *fmt, ...)
d81 2
a82 9
    va_list args;

    va_start(args, fmt);
    fprintf(stderr, "%s: ", __progname);
    vfprintf (stderr, fmt, args);
    fprintf(stderr, "\n");
    va_end(args);

    exit(eval);
d86 1
a86 1
#ifndef HAVE_WARN
d88 1
a88 1
warn(const char *fmt, ...)
d90 1
a90 11
    va_list args;
    char *errstr;

    va_start(args, fmt);
    fprintf(stderr, "%s: ", __progname);
    vfprintf (stderr, fmt, args);

    errstr = strerror(errno);
    
    fprintf(stderr, ": %s\n", errstr ? errstr : "unknown error");
    va_end(args);
d92 1
a92 1
#endif /* !HAVE_WARN */
d94 1
a94 1
#ifndef HAVE_ERR
d96 1
a96 1
err(int eval, const char *fmt, ...)
d98 1
a98 13
    va_list args;
    char *errstr;

    va_start(args, fmt);
    fprintf(stderr, "%s: ", __progname);
    vfprintf (stderr, fmt, args);

    errstr = strerror(errno);
    
    fprintf(stderr, ": %s\n", errstr ? errstr : "unknown error");
    va_end(args);

    exit(eval);
d100 2
a101 2
#endif /* !HAVE_ERR */

d105 1
a105 1
#define RXPERF_BUFSIZE 10000
d107 1
a107 1
enum { RX_PERF_VERSION = 3 };
d109 1
a109 2
enum { RX_PERF_UNKNOWN = -1, RX_PERF_SEND = 0, RX_PERF_RECV = 1, 
       RX_PERF_RPC=3, RX_PERF_FILE=4 };
a110 1
enum { RXPERF_MAGIC_COOKIE = 0x4711 };
a115 6
#if DEBUG
#define DBFPRINT(x) do { printf x ; } while(0)
#else
#define DBFPRINT(x)
#endif

a121 7
static void
sigint (int foo)
{
    rx_Finalize();
    exit (2); /* XXX profiler */
}

a197 38
char somebuf[RXPERF_BUFSIZE];

int32_t rxwrite_size = sizeof(somebuf);
int32_t rxread_size = sizeof(somebuf);

static int
readbytes(struct rx_call *call, int32_t bytes)
{
    int32_t size;

    while (bytes > 0) {
	size = rxread_size;
	if (size > bytes)
	    size = bytes;
	if (rx_Read (call, somebuf, size) != size)
	    return 1;
	bytes -= size;
    }
    return 0;
}

static int
sendbytes(struct rx_call *call, int32_t bytes)
{
    int32_t size;

    while (bytes > 0) {
	size = rxwrite_size;
	if (size > bytes)
	    size = bytes;
	if (rx_Write (call, somebuf, size) != size)
	    return 1;
	bytes -= size;
    }
    return 0;
}


d203 3
a205 10
    uint32_t bytes;
    uint32_t recvb;
    uint32_t sendb;
    uint32_t data;
    uint32_t num;
    uint32_t *readwrite;
    int i;
    int readp=TRUE;

    DBFPRINT(("got a request\n"));
d223 2
a224 7
    if (rx_Read (call, &data, 4) != 4) {
	warnx ("rx_Read failed to read size");
	return -1;
    }
    rxread_size = ntohl(data);
    if (rxread_size > sizeof(somebuf)) {
	warnx("rxread_size too large %d", rxread_size);
d227 1
d229 1
a229 9
    if (rx_Read (call, &data, 4) != 4) {
	warnx ("rx_Read failed to write size");
	return -1;
    }
    rxwrite_size = ntohl(data);
    if (rxwrite_size > sizeof(somebuf)) {
	warnx("rxwrite_size too large %d", rxwrite_size);
	return -1;
    }
d233 7
a239 5
	DBFPRINT(("got a send request\n"));

	if (rx_Read (call, &bytes, 4) != 4) {
	    warnx ("rx_Read failed to read bytes");
	    return -1;
d241 4
a244 36
	bytes = ntohl(bytes);

	DBFPRINT(("reading(%d) ", bytes));
	readbytes(call, bytes);

	data = htonl(RXPERF_MAGIC_COOKIE);
	if (rx_Write (call, &data, 4) != 4) {
	    warnx ("rx_Write failed when sending back result");
	    return -1;
	}
	DBFPRINT(("done\n"));

	break;
    case RX_PERF_RPC:
	DBFPRINT(("got a rpc request, reading commands\n"));
	
	if (rx_Read (call, &recvb, 4) != 4) {
	    warnx ("rx_Read failed to read recvbytes");
	    return -1;
	}
	recvb = ntohl(recvb);
	if (rx_Read (call, &sendb, 4) != 4) {
	    warnx ("rx_Read failed to read recvbytes");
	    return -1;
	}
	sendb = ntohl(sendb);

	DBFPRINT(("read(%d) ", recvb));
	if (readbytes(call, recvb)) {
	    warnx("readbytes failed");
	    return -1;
	}
	DBFPRINT(("send(%d) ", sendb));
	if (sendbytes(call, sendb)) {
	    warnx("sendbytes failed");
	    return -1;
a245 40
	
	DBFPRINT(("done\n"));

	data = htonl(RXPERF_MAGIC_COOKIE);
	if (rx_Write (call, &data, 4) != 4) {
	    warnx ( "rx_Write failed when sending back magic cookie");
	    return -1;
	}

	break;
    case RX_PERF_FILE:
	if (rx_Read (call, &data, 4) != 4)
	    errx (1, "failed to read num from client");
	num = ntohl(data);

	readwrite = malloc(num*sizeof(uint32_t));
	if(readwrite == NULL)
	    err(1, "malloc");

	if (rx_Read (call, readwrite, num*sizeof(uint32_t)) !=
	    num*sizeof(uint32_t))
	    errx (1, "failed to read recvlist from client");

	    for(i=0; i < num; i++) {
		if(readwrite[i] == 0) {
		    DBFPRINT(("readp %d", readwrite[i] ));
		    readp = !readp;
		}

		bytes = ntohl(readwrite[i])*sizeof(uint32_t);

		if(readp) {
		    DBFPRINT(("read\n"));
		    readbytes(call, bytes);
		} else {
		    sendbytes(call, bytes);
		    DBFPRINT(("send\n"));
		}
	    }

a247 19
	DBFPRINT(("got a recv request\n"));

	if (rx_Read (call, &bytes, 4) != 4) {
	    warnx ("rx_Read failed to read bytes");
	    return -1;
	}
	bytes = ntohl(bytes);

	DBFPRINT(("sending(%d) ", bytes));
	sendbytes(call, bytes);

	data = htonl(RXPERF_MAGIC_COOKIE);
	if (rx_Write (call, &data, 4) != 4) {
	    warnx ("rx_Write failed when sending back result");
	    return -1;
	}
	DBFPRINT(("done\n"));

	break;
a251 2
    DBFPRINT(("done with command\n"));

d291 1
a291 57
readfile(const char *filename, uint32_t **readwrite, uint32_t *size)
{
    FILE *f;
    uint32_t len=16;
    uint32_t num=0;
    uint32_t data;
    char *ptr;
    char buf[RXPERF_BUFSIZE];

    *readwrite = malloc(sizeof(uint32_t)*len);

    if(*readwrite == NULL)
	err(1, "malloc");

    f=fopen(filename, "r");
    if(f==NULL)
	err(1, "fopen");

    while(fgets(buf, sizeof(buf), f) != NULL) {

	buf[strcspn(buf, "\n")] = '\0';

	if(num >= len) {
	    len=len*2;
	    *readwrite = realloc(*readwrite, len*sizeof(uint32_t));
	    if(*readwrite == NULL)
		err(1, "realloc");
	}

	if(*buf != '\0') {
	    data = htonl(strtol (buf, &ptr, 0));
	    if (ptr && ptr == buf)
		errx (1, "can't resolve number of bytes to transfer");
	} else {
	    data = 0;
	}
	
	(*readwrite)[num] =data;
	num++;
    }

    *size = num;

    
    if(fclose(f) == -1)
	err(1, "fclose");
}


/*
 *
 */

static void
do_client (const char *server, int port, char *filename,
	   int32_t command, int32_t times, 
	   int32_t bytes, int32_t rpc_sendbytes, int32_t rpc_recvbytes)
d295 1
a295 1
    uint32_t addr = str2addr(server);
d298 1
d300 1
a300 1
    int32_t num;
a301 2
    int i;
    int readp = FALSE;
a302 1
    uint32_t size;
d304 2
a305 1
    uint32_t *readwrite;
d321 11
a331 7
    if (command == RX_PERF_RPC)
	    snprintf (stamp, sizeof(stamp), 
		      "send\t%d times\t%d writes\t%d reads", 
		      times, rpc_sendbytes, rpc_recvbytes);
    else
	    snprintf (stamp, sizeof(stamp),
		      "send\t%d times", times);
d333 1
d335 4
d340 7
a346 122
    for(i=0; i < times ; i++) {

	DBFPRINT(("starting command "));

	call = rx_NewCall (conn);
	if (call == NULL)
	    errx (1, "rx_NewCall failed");
	
	data = htonl(RX_PERF_VERSION);
	if (rx_Write (call, &data, 4) != 4)
	    errx (1, "rx_Write failed to send version");
	
	data = htonl(command);
	if (rx_Write (call, &data, 4) != 4)
	    errx (1, "rx_Write failed to send command");

	data = htonl(rxread_size);
	if (rx_Write (call, &data, 4) != 4)
	    errx (1, "rx_Write failed to send read size");
	data = htonl(rxwrite_size);
	if (rx_Write (call, &data, 4) != 4)
	    errx (1, "rx_Write failed to send write read");


	switch (command) {
	case RX_PERF_RECV:
	    DBFPRINT(("command "));

	    data = htonl (bytes);
	    if (rx_Write (call, &data, 4) != 4)
		errx (1, "rx_Write failed to send size");	    
	    
	    DBFPRINT(("sending(%d) ", bytes));
	    if (readbytes(call, bytes))
		errx(1, "sendbytes");

	    if (rx_Read (call, &data, 4) != 4)
		errx (1, "failed to read result from server");
	    
	    if (data != htonl(RXPERF_MAGIC_COOKIE))
		warn("server send wrong magic cookie in responce");

	    DBFPRINT(("done\n"));

	    break;
	case RX_PERF_SEND:
	    DBFPRINT(("command "));

	    data = htonl (bytes);
	    if (rx_Write (call, &data, 4) != 4)
		errx (1, "rx_Write failed to send size");	    
	    
	    DBFPRINT(("sending(%d) ", bytes));
	    if (sendbytes(call, bytes))
		errx(1, "sendbytes");

	    if (rx_Read (call, &data, 4) != 4)
		errx (1, "failed to read result from server");
	    
	    if (data != htonl(RXPERF_MAGIC_COOKIE))
		warn("server send wrong magic cookie in responce");

	    DBFPRINT(("done\n"));

	    break;
	case RX_PERF_RPC:
	    DBFPRINT(("commands "));

	    data = htonl(rpc_sendbytes);
	    if (rx_Write(call, &data, 4) != 4)
		errx (1, "rx_Write failed to send command");
	    
	    data = htonl(rpc_recvbytes);
	    if (rx_Write (call, &data, 4) != 4)
		errx (1, "rx_Write failed to send command");
	    
	    DBFPRINT(("send(%d) ", rpc_sendbytes));
	    sendbytes(call, rpc_sendbytes);
	    
	    DBFPRINT(("recv(%d) ", rpc_recvbytes));
	    readbytes(call, rpc_recvbytes);
	    
	    if (rx_Read (call, &bytes, 4) != 4)
		errx (1, "failed to read result from server");
	    
	    if (bytes != htonl(RXPERF_MAGIC_COOKIE))
		warn("server send wrong magic cookie in responce");

	    DBFPRINT(("done\n"));

	    break;
	case RX_PERF_FILE:
	    readfile(filename, &readwrite, &num);

	    data = htonl(num);
	    if (rx_Write(call, &data, sizeof(data)) != 4)
		errx (1, "rx_Write failed to send size");

	    if (rx_Write(call, readwrite, num*sizeof(uint32_t)) 
		!= num*sizeof(uint32_t))
		errx (1, "rx_Write failed to send list");

	    for(i=0; i < num; i++) {
		if(readwrite[i] == 0)
		    readp = !readp;

		size = ntohl(readwrite[i])*sizeof(uint32_t);

		if(readp) {
		    readbytes(call, size);
		    DBFPRINT(("read\n"));
		} else {
		    sendbytes(call, size);
		    DBFPRINT(("send\n"));
		}
	    }
	    break;
	default:
	    abort();
	}

	rx_EndCall (call, 0);
d348 2
a349 1

d351 1
a351 2
    DBFPRINT(("done for good\n"));

d358 4
a361 16
#define COMMON ""

    fprintf(stderr, "usage: %s client -c send -b <bytes>\n",
	    __progname);
    fprintf(stderr, "usage: %s client -c recv -b <bytes>\n",
	    __progname);
    fprintf(stderr, "usage: %s client -c rpc  -S <rpc_sendbytes> -R <rpc_recvbytes>\n",
	    __progname);
    fprintf(stderr, "usage: %s client -c file -f filename\n", 
	    __progname);
    fprintf (stderr, "%s: usage:	common option to the client "
	     "-w <rx_write size> -r <rx_read size> -T times -p port -s server\n",
	     __progname);
    fprintf(stderr, "usage: %s server -p port\n", __progname);
#undef COMMMON
    exit(1);
d375 10
a384 37
    while ((ch = getopt(argc, argv, "r:d:p:w:")) != -1) {
	switch (ch) {
	case 'd':
#ifdef RXDEBUG
	    rx_debugFile = fopen(optarg, "w");
	    if (rx_debugFile == NULL)
		err(1, "fopen %s", optarg);
#else
	    errx(1, "compiled without RXDEBUG");
#endif
	    break;
	case 'r':
	    rxread_size = strtol(optarg, &ptr, 0);
	    if (ptr != 0 && ptr[0] != '\0')
		errx (1, "can't resolve readsize");
	    if (rxread_size > sizeof(somebuf))
	      errx(1, "%d > sizeof(somebuf) (%d)",
		   rxread_size, sizeof(somebuf));
	    break;
	case 'p':
	    port = strtol(optarg, &ptr, 0);
	    if (ptr != 0 && ptr[0] != '\0')
		errx (1, "can't resolve portname");
	    break;
	case 'w':
	    rxwrite_size = strtol(optarg, &ptr, 0);
	    if (ptr != 0 && ptr[0] != '\0')
		errx (1, "can't resolve writesize");
	    if (rxwrite_size > sizeof(somebuf))
		errx(1, "%d > sizeof(somebuf) (%d)",
		     rxwrite_size, sizeof(somebuf));
	    break;
	default:
	    usage();
	}
    }

d386 1
a386 1
	usage();
a402 6
    char *filename = NULL;
    int32_t cmd;
    int rpc_sendbytes = 3;
    int rpc_recvbytes = 30;
    int print_stats = 0;
    int times = 100;
d406 20
a425 1
    cmd = RX_PERF_UNKNOWN;
d427 1
a427 82
    while ((ch  = getopt(argc, argv, "GT:S:R:b:c:d:p:r:s:w:f:")) != -1) {
	switch (ch) {
	case 'G':
	    print_stats = 1;
#ifndef HAVE_GETRUSAGE
	    printf("could not find getrusage, can't print stats\n");
#endif
	    break;
	case 'b':
	    bytes = strtol (optarg, &ptr, 0);
	    if (ptr && *ptr != '\0')
		errx (1, "can't resolve number of bytes to transfer");
	    break;
	case 'c':
	    if (strcasecmp(optarg, "send") == 0)
	      cmd = RX_PERF_SEND;
	    else if (strcasecmp(optarg, "recv") == 0)
		cmd = RX_PERF_RECV;
	    else if (strcasecmp(optarg, "rpc") == 0)
		cmd = RX_PERF_RPC;
	    else if (strcasecmp(optarg, "file") == 0)
		cmd = RX_PERF_FILE;
	    else
		errx(1, "unknown command %s", optarg);
	    break;
	case 'd':
#ifdef RXDEBUG
	    rx_debugFile = fopen(optarg, "w");
	    if (rx_debugFile == NULL)
		err(1, "fopen %s", optarg);
#else
	    errx(1, "compiled without RXDEBUG");
#endif
	    break;
	case 'p':
	    port = strtol(optarg, &ptr, 0);
	    if (ptr != 0 && ptr[0] != '\0')
		errx (1, "can't resolve portname");
	    break;
	case 'r':
	    rxread_size = strtol(optarg, &ptr, 0);
	    if (ptr != 0 && ptr[0] != '\0')
		errx (1, "can't resolve readsize");
	    if (rxread_size > sizeof(somebuf))
		errx(1, "%d > sizeof(somebuf) (%d)",
		     rxread_size, sizeof(somebuf));
	    break;
	case 's':
	    host = strdup(optarg);
	    if (host == NULL)
		err(1, "strdup");
	    break;
	case 'w':
	    rxwrite_size = strtol(optarg, &ptr, 0);
	    if (ptr != 0 && ptr[0] != '\0')
		errx (1, "can't resolve writesize");
	    if (rxwrite_size > sizeof(somebuf))
		errx(1, "%d > sizeof(somebuf) (%d)",
		     rxwrite_size, sizeof(somebuf));
	    break;
	case 'T':
	    times = strtol (optarg, &ptr, 0);
	    if (ptr && *ptr != '\0')
		errx (1, "can't resolve number times to run the test");
	    break;
	case 'S':
	    rpc_sendbytes = strtol (optarg, &ptr, 0);
	    if (ptr && *ptr != '\0')
		errx (1, "can't resolve number of bytes to transfer");
	    break;
	case 'R':
	    rpc_recvbytes = strtol (optarg, &ptr, 0);
	    if (ptr && *ptr != '\0')
		errx (1, "can't resolve number of bytes to transfer");
	    break;
	case 'f':
	    filename = optarg;
	    break;
	default:
	    usage();
	}
    }
a428 52
    if (optind != argc)
	usage();
    
    if (cmd == RX_PERF_UNKNOWN)
	errx(1, "no command given to the client");
    
    do_client(host, htons(port), filename, cmd, times, bytes, 
	      rpc_sendbytes, rpc_recvbytes);
    
#if HAVE_GETRUSAGE
    if (print_stats) {
	struct rusage rusage;
	if(getrusage (RUSAGE_SELF, &rusage) < 0)
	    printf("no stats\n");
	else
	    printf ("Status:\n"
		    "- utime = (%ld, %ld)\n"
		    "- stime = (%ld, %ld)\n"
		    "- maxrss = %ld\n"
		    "- ixrss = %ld\n"
		    "- idrss = %ld\n"
		    "- isrss = %ld\n"
		    "- minflt = %ld\n"
		    "- majflt = %ld\n"
		    "- nswap = %ld\n"
		    "- inblock = %ld\n"
		    "- oublock = %ld\n"
		    "- msgsnd = %ld\n"
		    "- msgrcv = %ld\n"
		    "- nsignals = %ld\n"
		    "- nvcsw = %ld\n"
		    "- nivcws = %ld\n",
		    rusage.ru_utime.tv_sec,
		    rusage.ru_utime.tv_usec,
		    rusage.ru_stime.tv_sec,
		    rusage.ru_stime.tv_usec,
		    rusage.ru_maxrss,
		    rusage.ru_ixrss,
		    rusage.ru_idrss,
		    rusage.ru_isrss,
		    rusage.ru_minflt,
		    rusage.ru_majflt,
		    rusage.ru_nswap,
		    rusage.ru_inblock,
		    rusage.ru_oublock,
		    rusage.ru_msgsnd,
		    rusage.ru_msgrcv,
		    rusage.ru_nsignals,
		    rusage.ru_nvcsw,
		    rusage.ru_nivcsw);
    }
#endif /* HAVE_GETRUSAGE */
d431 1
a431 1
    
d442 2
a443 4
    if (__progname)
	__progname++;
    else
	__progname = argv[0];
a445 1
    signal (SIGINT, sigint);
a447 2
    
    memset (somebuf, 0, sizeof(somebuf));
d450 1
a450 1
	rxperf_server(argc - 1, argv + 1);
d452 1
a452 1
	rxperf_client(argc - 1, argv + 1);
d454 1
a454 1
	usage();
@


