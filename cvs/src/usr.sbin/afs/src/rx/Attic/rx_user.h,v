head	1.6;
access;
symbols
	OPENBSD_5_2:1.5.0.10
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.8
	OPENBSD_5_0:1.5.0.6
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.4
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.2
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.4.0.26
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.4.0.28
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.4.0.24
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.4.0.22
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.4.0.20
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.4.0.18
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.4.0.16
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.4.0.14
	OPENBSD_4_0_BASE:1.4
	OPENBSD_3_9:1.4.0.12
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.10
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.8
	OPENBSD_3_7_BASE:1.4
	OPENBSD_3_6:1.4.0.6
	OPENBSD_3_6_BASE:1.4
	OPENBSD_3_5:1.4.0.4
	OPENBSD_3_5_BASE:1.4
	OPENBSD_3_4:1.4.0.2
	OPENBSD_3_4_BASE:1.4
	arla-20030805:1.1.1.3
	OPENBSD_3_3:1.3.0.4
	OPENBSD_3_3_BASE:1.3
	OPENBSD_3_2:1.3.0.2
	OPENBSD_3_2_BASE:1.3
	arla-0-35-7:1.1.1.2
	OPENBSD_3_1:1.2.0.8
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.6
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_9:1.2.0.4
	OPENBSD_2_8:1.2.0.2
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.1.1.1.0.8
	OPENBSD_2_7_BASE:1.1.1.1
	OPENBSD_2_6:1.1.1.1.0.6
	OPENBSD_2_6_BASE:1.1.1.1
	OPENBSD_2_5:1.1.1.1.0.4
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.2
	OPENBSD_2_4_BASE:1.1.1.1
	arla-0_9:1.1.1.1
	arla:1.1.1;
locks; strict;
comment	@ * @;


1.6
date	2012.08.23.06.21.54;	author deraadt;	state dead;
branches;
next	1.5;

1.5
date	2010.05.01.20.51.06;	author jsg;	state Exp;
branches;
next	1.4;

1.4
date	2003.08.05.09.11.12;	author hin;	state Exp;
branches;
next	1.3;

1.3
date	2002.06.07.04.43.30;	author hin;	state Exp;
branches;
next	1.2;

1.2
date	2000.09.11.14.41.23;	author art;	state Exp;
branches;
next	1.1;

1.1
date	98.09.14.21.53.17;	author art;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.09.14.21.53.17;	author art;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.06.07.04.14.35;	author hin;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2003.08.05.08.21.07;	author hin;	state Exp;
branches;
next	;


desc
@@


1.6
log
@the afs src tree can go away
@
text
@/* $arla: rx_user.h,v 1.9 2003/04/08 22:13:44 lha Exp $ */

/*
****************************************************************************
*        Copyright IBM Corporation 1988, 1989 - All Rights Reserved        *
*                                                                          *
* Permission to use, copy, modify, and distribute this software and its    *
* documentation for any purpose and without fee is hereby granted,         *
* provided that the above copyright notice appear in all copies and        *
* that both that copyright notice and this permission notice appear in     *
* supporting documentation, and that the name of IBM not be used in        *
* advertising or publicity pertaining to distribution of the software      *
* without specific, written prior permission.                              *
*                                                                          *
* IBM DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL *
* IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL IBM *
* BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY      *
* DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER  *
* IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING   *
* OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.    *
****************************************************************************
*/

#ifndef RX_USER_INCLUDE
#define RX_USER_INCLUDE

/* 
 * rx_user.h:
 * definitions specific to the user-level implementation of Rx 
 */

#include <stdio.h>
#include <lwp.h>

#ifdef RXDEBUG
extern FILE *rx_debugFile;
#endif

/* These routines are no-ops in the user level implementation */
#define SPLVAR
#define NETPRI
#define USERPRI
#if defined(AFS_SGIMP_ENV)
#define AFS_GLOCK()
#define AFS_GUNLOCK()
#define ISAFS_GLOCK()
#endif

void rxi_StartListener(void);
void rxi_StartServerProcs(int);
void rxi_ReScheduleEvents(void);

void rxi_PacketsUnWait(void);

/*
 *Some "operating-system independent" stuff, for the user mode implementation
 */
typedef short osi_socket;

osi_socket rxi_GetUDPSocket(uint16_t, uint16_t *);

#define	OSI_NULLSOCKET	((osi_socket) -1)

#define	rx_Sleep(x)		    osi_Sleep(x)
#define	rx_Wakeup(x)		    osi_Wakeup(x)
#define	osi_rxSleep(x)		    osi_Sleep(x)
#define	osi_rxWakeup(x)		    osi_Wakeup(x)
#define	osi_Sleep(x)		    LWP_WaitProcess(x)
#define	osi_Wakeup(x)		    LWP_NoYieldSignal(x)
/* 
 * osi_WakeupAndYieldIfPossible doesn't actually have to yield, but
 * its better if it does
 */
#define	osi_WakeupAndYieldIfPossible(x)	    LWP_SignalProcess(x)
#define	osi_YieldIfPossible()	    LWP_DispatchProcess();

#ifndef osi_Alloc
#define	osi_Alloc(size)		    (malloc(size))
#endif

#ifndef osi_Free
#define	osi_Free(ptr, size)	    free(ptr)
#endif

#define	osi_GetTime(timevalptr)	    gettimeofday(timevalptr, 0)

/*
 * Just in case it's possible to distinguish between relatively
 * long-lived stuff and stuff which will be freed very soon, but which
 * needs quick allocation (e.g. dynamically allocated xdr things)
 */

#define	osi_QuickFree(ptr, size)    osi_Free(ptr, size)
#define	osi_QuickAlloc(size)	    osi_Alloc(size)


void	osi_Panic(const char *fmt, ...);
void	osi_vMsg(const char *fmt, ...);

#define	osi_Msg(x)			do { osi_vMsg x ; } while(0)

#endif				       /* RX_USER_INCLUDE */
@


1.5
log
@remove an uneeded extern which upsets gcc4, matches changes made
in the upstream arla code.

ok miod@@
@
text
@@


1.4
log
@Merge
@
text
@a48 2
extern PROCESS rx_listenerPid;	       /* LWP process id of socket listener
				        * process */
@


1.3
log
@merge
@
text
@d1 1
a1 1
/* $KTH: rx_user.h,v 1.5 1998/03/28 16:35:47 lha Exp $ */
a23 3
#ifdef	VALIDATE
error - foo error - foo error - foo
#endif				       /* VALIDATE */
d27 4
a30 1
/* rx_user.h:  definitions specific to the user-level implementation of Rx */
a36 1

d62 1
a62 1
osi_socket rxi_GetUDPSocket(u_short);
d72 4
a75 1
/* osi_WakeupAndYieldIfPossible doesn't actually have to yield, but its better if it does */
a78 2
#ifndef	AFS_AIX32_ENV

d80 1
a80 1
#define	osi_Alloc(size)		    ((char *) malloc(size))
d84 1
a84 1
#define	osi_Free(ptr, size)	    free((char *)(ptr))
d87 1
a87 1
#endif
d89 5
a93 5
#ifdef USE_MMAPTIME
#define	osi_GetTime(timevalptr)	    mmaptime_gettimeofday(timevalptr, 0)
#else
#define	osi_GetTime(timevalptr)	    gettimeofday(timevalptr, 0)
#endif
a94 1
/* Just in case it's possible to distinguish between relatively long-lived stuff and stuff which will be freed very soon, but which needs quick allocation (e.g. dynamically allocated xdr things) */
a97 1
void osi_Panic(const char *fmt, ...);
d99 2
a100 1
int fprintf(FILE *, const char *, ...);
d102 1
a102 1
#define	osi_Msg			    fprintf)(stderr,
@


1.2
log
@New Arla userland from Arla between 0.34.2 and current in arla cvs.
Too many new features and fixes to mention here.
@
text
@d1 1
a1 1
/* $Id: rx_user.h,v 1.5 1998/03/28 16:35:47 lha Exp $ */
@


1.1
log
@Initial revision
@
text
@d1 1
a1 2
/*	$OpenBSD$	*/
/* $KTH: rx_user.h,v 1.5 1998/03/28 16:35:47 lha Exp $ */
@


1.1.1.1
log
@Initial version of Arla, a free implementation of an AFS cache-manager.
(second try, hopefully into the correct repository this time)
@
text
@@


1.1.1.2
log
@Import of arla-0.35.7
@
text
@d1 1
@


1.1.1.3
log
@Import of arla -current as of Aug 5 2003

ok todd@@ deraadt@@
@
text
@d1 1
a1 1
/* $arla: rx_user.h,v 1.9 2003/04/08 22:13:44 lha Exp $ */
d24 3
d30 1
a30 4
/* 
 * rx_user.h:
 * definitions specific to the user-level implementation of Rx 
 */
d37 1
d63 1
a63 1
osi_socket rxi_GetUDPSocket(uint16_t, uint16_t *);
d73 1
a73 4
/* 
 * osi_WakeupAndYieldIfPossible doesn't actually have to yield, but
 * its better if it does
 */
d77 2
d80 1
a80 1
#define	osi_Alloc(size)		    (malloc(size))
d84 3
a86 1
#define	osi_Free(ptr, size)	    free(ptr)
d89 3
d93 1
d95 1
a95 6
/*
 * Just in case it's possible to distinguish between relatively
 * long-lived stuff and stuff which will be freed very soon, but which
 * needs quick allocation (e.g. dynamically allocated xdr things)
 */

d99 1
d101 1
a101 2
void	osi_Panic(const char *fmt, ...);
void	osi_vMsg(const char *fmt, ...);
d103 1
a103 1
#define	osi_Msg(x)			do { osi_vMsg x ; } while(0)
@


