head	1.4;
access;
symbols
	OPENBSD_5_2:1.3.0.38
	OPENBSD_5_2_BASE:1.3
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.36
	OPENBSD_5_0:1.3.0.34
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.32
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.3.0.30
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.3.0.26
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.28
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.3.0.24
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.3.0.22
	OPENBSD_4_4_BASE:1.3
	OPENBSD_4_3:1.3.0.20
	OPENBSD_4_3_BASE:1.3
	OPENBSD_4_2:1.3.0.18
	OPENBSD_4_2_BASE:1.3
	OPENBSD_4_1:1.3.0.16
	OPENBSD_4_1_BASE:1.3
	OPENBSD_4_0:1.3.0.14
	OPENBSD_4_0_BASE:1.3
	OPENBSD_3_9:1.3.0.12
	OPENBSD_3_9_BASE:1.3
	OPENBSD_3_8:1.3.0.10
	OPENBSD_3_8_BASE:1.3
	OPENBSD_3_7:1.3.0.8
	OPENBSD_3_7_BASE:1.3
	OPENBSD_3_6:1.3.0.6
	OPENBSD_3_6_BASE:1.3
	OPENBSD_3_5:1.3.0.4
	OPENBSD_3_5_BASE:1.3
	OPENBSD_3_4:1.3.0.2
	OPENBSD_3_4_BASE:1.3
	arla-20030805:1.1.1.3
	OPENBSD_3_3:1.2.0.12
	OPENBSD_3_3_BASE:1.2
	OPENBSD_3_2:1.2.0.10
	OPENBSD_3_2_BASE:1.2
	arla-0-35-7:1.1.1.2
	OPENBSD_3_1:1.2.0.8
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.6
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_9:1.2.0.4
	OPENBSD_2_8:1.2.0.2
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.1.1.1.0.8
	OPENBSD_2_7_BASE:1.1.1.1
	OPENBSD_2_6:1.1.1.1.0.6
	OPENBSD_2_6_BASE:1.1.1.1
	OPENBSD_2_5:1.1.1.1.0.4
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.2
	OPENBSD_2_4_BASE:1.1.1.1
	arla-0_9:1.1.1.1
	arla:1.1.1;
locks; strict;
comment	@ * @;


1.4
date	2012.08.23.06.21.53;	author deraadt;	state dead;
branches;
next	1.3;

1.3
date	2003.08.05.09.11.12;	author hin;	state Exp;
branches;
next	1.2;

1.2
date	2000.09.11.14.41.21;	author art;	state Exp;
branches;
next	1.1;

1.1
date	98.09.14.21.53.15;	author art;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.09.14.21.53.15;	author art;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.06.07.04.14.34;	author hin;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2003.08.05.08.21.06;	author hin;	state Exp;
branches;
next	;


desc
@@


1.4
log
@the afs src tree can go away
@
text
@/*
****************************************************************************
*        Copyright IBM Corporation 1988, 1989 - All Rights Reserved        *
*                                                                          *
* Permission to use, copy, modify, and distribute this software and its    *
* documentation for any purpose and without fee is hereby granted,         *
* provided that the above copyright notice appear in all copies and        *
* that both that copyright notice and this permission notice appear in     *
* supporting documentation, and that the name of IBM not be used in        *
* advertising or publicity pertaining to distribution of the software      *
* without specific, written prior permission.                              *
*                                                                          *
* IBM DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL *
* IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL IBM *
* BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY      *
* DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER  *
* IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING   *
* OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.    *
****************************************************************************
*/

/* Event package */

#ifndef _EVENT_
#define _EVENT_

#ifdef	KERNEL
#include "../rx/rx_queue.h"
#include "../rx/rx_clock.h"
#else				       /* KERNEL */
#include "rx_queue.h"
#include "rx_clock.h"
#endif				       /* KERNEL */

/*
 * An event is something that will happen at (or after) a specified clock
 * time, unless cancelled prematurely.  The user routine (*func)() is called
 * with arguments (event, arg, arg1) when the event occurs.  Warnings:
 * (1) The user supplied routine should NOT cause process preemption.
 * (2) The event passed to the user is still on the event queue at that time.
 * The user must not remove (event_Cancel) it explicitly, but the user may
 * remove or schedule any OTHER event at this time.
 */

struct rxevent {
    struct rx_queue junk;	       /* Events are queued */
    struct clock eventTime;	       /* When this event times out (in
				        * clock.c units) */
    void (*func)();		       /* Function to call when this expires */
    void *arg;			       /* Argument to the function */
    void *arg1;			       /* Another argument */
};

/*
 * Some macros to make macros more reasonable (this allows a block to be
 * used within a macro which does not cause if statements to screw up).
 * That is, you can use "if (...) macro_name(); else ...;" without having
 * things blow up on the semi-colon.
 */

#ifndef BEGIN
#define BEGIN do {
#define END } while(0)
#endif

/*
 * This routine must be called to initialize the event package.
 * nEvents is the number of events to allocate in a batch whenever more
 * are needed.  If this is 0, a default number (10) will be allocated.
 */
void rxevent_Init(int, void (*)());

/*
 * Arrange for the indicated event at the appointed time.  When is a
 * "struct clock", in the clock.c time base
 */
struct rxevent *rxevent_Post(struct clock*, void (*)(), void*, void*);

/*
 * Remove the indicated event from the event queue.  The event must be
 * pending.  Also see the warning, above.  The event pointer supplied is
 * zeroed.
 */
void rxevent_Cancel_1(struct rxevent *);

#define	rxevent_Cancel(event_ptr)		    \
	BEGIN					    \
	    if (event_ptr) {			    \
		rxevent_Cancel_1(event_ptr);	    \
		event_ptr = (struct rxevent *) 0;   \
	    }					    \
	END

/*
 * The actions specified for each event that has reached the current clock
 * time will be taken.  The current time returned by GetTime is used
 * (warning: this may be an old time if the user has not called clock_NewTime)
 */
int rxevent_RaiseEvents(struct clock *);

#endif				       /* _EVENT_ */
@


1.3
log
@Merge
@
text
@@


1.2
log
@New Arla userland from Arla between 0.34.2 and current in arla cvs.
Too many new features and fixes to mention here.
@
text
@d84 1
a84 1
void rxevent_Cancel_1(register struct rxevent *);
@


1.1
log
@Initial revision
@
text
@a0 1
/*	$OpenBSD$	*/
@


1.1.1.1
log
@Initial version of Arla, a free implementation of an AFS cache-manager.
(second try, hopefully into the correct repository this time)
@
text
@@


1.1.1.2
log
@Import of arla-0.35.7
@
text
@d1 1
@


1.1.1.3
log
@Import of arla -current as of Aug 5 2003

ok todd@@ deraadt@@
@
text
@d84 1
a84 1
void rxevent_Cancel_1(struct rxevent *);
@


