head	1.5;
access;
symbols
	OPENBSD_5_2:1.4.0.38
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.36
	OPENBSD_5_0:1.4.0.34
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.32
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.30
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.4.0.26
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.4.0.28
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.4.0.24
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.4.0.22
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.4.0.20
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.4.0.18
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.4.0.16
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.4.0.14
	OPENBSD_4_0_BASE:1.4
	OPENBSD_3_9:1.4.0.12
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.10
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.8
	OPENBSD_3_7_BASE:1.4
	OPENBSD_3_6:1.4.0.6
	OPENBSD_3_6_BASE:1.4
	OPENBSD_3_5:1.4.0.4
	OPENBSD_3_5_BASE:1.4
	OPENBSD_3_4:1.4.0.2
	OPENBSD_3_4_BASE:1.4
	arla-20030805:1.1.1.3
	OPENBSD_3_3:1.3.0.4
	OPENBSD_3_3_BASE:1.3
	OPENBSD_3_2:1.3.0.2
	OPENBSD_3_2_BASE:1.3
	arla-0-35-7:1.1.1.2
	OPENBSD_3_1:1.2.0.8
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.6
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_9:1.2.0.4
	OPENBSD_2_8:1.2.0.2
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.1.1.1.0.8
	OPENBSD_2_7_BASE:1.1.1.1
	OPENBSD_2_6:1.1.1.1.0.6
	OPENBSD_2_6_BASE:1.1.1.1
	OPENBSD_2_5:1.1.1.1.0.4
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.2
	OPENBSD_2_4_BASE:1.1.1.1
	arla-0_9:1.1.1.1
	arla:1.1.1;
locks; strict;
comment	@ * @;


1.5
date	2012.08.23.06.21.53;	author deraadt;	state dead;
branches;
next	1.4;

1.4
date	2003.08.05.09.11.12;	author hin;	state Exp;
branches;
next	1.3;

1.3
date	2002.06.07.04.43.30;	author hin;	state Exp;
branches;
next	1.2;

1.2
date	2000.09.11.14.41.23;	author art;	state Exp;
branches;
next	1.1;

1.1
date	98.09.14.21.53.17;	author art;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.09.14.21.53.17;	author art;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.06.07.04.14.35;	author hin;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2003.08.05.08.21.07;	author hin;	state Exp;
branches;
next	;


desc
@@


1.5
log
@the afs src tree can go away
@
text
@#include "rx_locl.h"

RCSID("$arla: rx_rdwr.c,v 1.9 2002/12/15 11:45:19 lha Exp $");

int 
rx_Read(struct rx_call *call, void *vbuf, int nbytes)
{
    struct rx_packet *rp;
    int requestCount;
    char *buf = (char *)vbuf;

    SPLVAR;
/* XXXX took out clock_NewTime from here.  Was it needed? */
    requestCount = nbytes;

    NETPRI;
    GLOBAL_LOCK();
    RX_MUTEX_ENTER(&call->lock);

    while (nbytes) {
	if (call->nLeft == 0) {
	    /* Get next packet */
	    for (;;) {
		if (call->error || (call->mode != RX_MODE_RECEIVING)) {
		    if (call->error) {
			RX_MUTEX_EXIT(&call->lock);
			GLOBAL_UNLOCK();
			USERPRI;
			return 0;
		    }
		    if (call->mode == RX_MODE_SENDING) {
			rx_FlushWrite(call);
			continue;
		    }
		}
		if (queue_IsNotEmpty(&call->rq)) {
		    /* Check that next packet available is next in sequence */
		    rp = queue_First(&call->rq, rx_packet);
		    if (rp->header.seq == call->rnext) {
			long error;
			struct rx_connection *conn = call->conn;

			queue_Remove(rp);

			/*
			 * RXS_CheckPacket called to undo RXS_PreparePacket's
			 * work.  It may reduce the length of the packet by
			 * up to conn->maxTrailerSize, to reflect the length
			 * of the data + the header.
			 */
			if ((error = RXS_CheckPacket(conn->securityObject,
						    call, rp)) != 0) {

			    /*
			     * Used to merely shut down the call, but now we
			     * shut down the whole connection since this may
			     * indicate an attempt to hijack it
			     */
			    rxi_ConnectionError(conn, error);
			    rp = rxi_SendConnectionAbort(conn, rp);
			    rxi_FreePacket(rp);

			    RX_MUTEX_EXIT(&call->lock);
			    GLOBAL_UNLOCK();
			    USERPRI;
			    return 0;
			}
			call->rnext++;
			call->currentPacket = rp;
			call->curvec = 1;	/* 0th vec is always header */

			/*
			 * begin at the beginning [ more or less ], continue
			 * on until the end, then stop.
			 */
			call->curpos = call->conn->securityHeaderSize;

			/*
			 * Notice that this code works correctly if the data
			 * size is 0 (which it may be--no reply arguments
			 * from server, for example).  This relies heavily on
			 * the fact that the code below immediately frees the
			 * packet (no yields, etc.).  If it didn't, this
			 * would be a problem because a value of zero for
			 * call->nLeft normally means that there is no read
			 * packet
			 */
			call->nLeft = rp->length;
			if (rp->header.flags & RX_LAST_PACKET)
			    call->flags |= RX_CALL_RECEIVE_DONE;

			/*
			 * now, if we haven't send a hard ack for window/2
			 * packets we spontaneously generate one, to take
			 * care of the case where (most likely in the kernel)
			 * we receive a window-full of packets, and ack all
			 * of them before any are read by the user, thus not
			 * hard-acking any of them.  The sender retransmits
			 * in this case only under a timer, which is a real
			 * loser
			 */

			{
			    int ack_window;

#ifdef ADAPT_WINDOW
			    ack_window = call->conn->peer->maxWindow >> 1;
#else /* !ADAPT_WINDOW */
			    ack_window = rx_Window >> 1;
#endif/* ADAPT_WINDOW */

			    if (call->rnext > (call->lastAcked + ack_window)) 
				rxi_SendAck(call, 0, 0, 0, 0, RX_ACK_DELAY);
			}
			break;
		    }
		}
/*
MTUXXX  doesn't there need to be an "else" here ???
*/
		/* Are there ever going to be any more packets? */
		if (call->flags & RX_CALL_RECEIVE_DONE) {
		    RX_MUTEX_EXIT(&call->lock);
		    GLOBAL_UNLOCK();
		    USERPRI;
		    return requestCount - nbytes;
		}
		/* Wait for in-sequence packet */
		call->flags |= RX_CALL_READER_WAIT;
		clock_NewTime();
		call->startWait = clock_Sec();

		RX_MUTEX_EXIT(&call->lock);
		RX_MUTEX_ENTER(&call->lockq);
#ifdef	RX_ENABLE_LOCKS
		while (call->flags & RX_CALL_READER_WAIT)
		    cv_wait(&call->cv_rq, &call->lockq);
#else
		osi_rxSleep(&call->rq);
#endif
		RX_MUTEX_EXIT(&call->lockq);
		RX_MUTEX_ENTER(&call->lock);

		call->startWait = 0;
	    }
	} else {		       /* assert(call->currentPacket); */
                                       /*
				        * MTUXXX  this should be replaced by
				        * some error-recovery code before
					* shipping
					*/
            /*
	     * It's possible for call->nLeft to be smaller than
	     * any particular iov_len. Usually, recvmsg doesn't change the
	     * iov_len, since it reflects the size of the buffer.  We have to
	     * keep track of the number of bytes read in the length field of
	     * the packet struct.  On the final portion of a received packet,
	     * it's almost certain that call->nLeft will be smaller than the
	     * final buffer.
	     */
	    unsigned int t, l1;
	    caddr_t p1;

	    while (nbytes && call->currentPacket) {
		p1 = (char*)call->currentPacket->wirevec[call->curvec].iov_base +
		    call->curpos;
		l1 = call->currentPacket->wirevec[call->curvec].iov_len -
		    call->curpos;

		t = MIN(l1, nbytes);
		t = MIN(t, call->nLeft);
		memcpy(buf, p1, t);
		p1 += t;
		buf += t;
		l1 -= t;
		nbytes -= t;
		call->curpos += t;
		call->nLeft -= t;

		if (call->nLeft == 0) {
		    /* out of packet.  Get another one. */
		    rxi_FreePacket(call->currentPacket);
		    call->currentPacket = NULL;
		} else if (l1 == 0) {
		    /* need to get another struct iov */
		    if (++call->curvec > call->currentPacket->niovecs) {
			/*
			 * current packet is exhausted, get ready for another
			 */

			/*
			 * don't worry about curvec and stuff, they get set
			 * somewhere else
			 */
			rxi_FreePacket(call->currentPacket);
			call->currentPacket = NULL;
			call->nLeft = 0;
		    } else
			call->curpos = 0;
		}
	    }
	    if (nbytes == 0) {
		/* user buffer is full, return */
		RX_MUTEX_EXIT(&call->lock);
		GLOBAL_UNLOCK();
		USERPRI;
		return requestCount;
	    }
	}

    }				       /* while (nbytes) ... */

    RX_MUTEX_EXIT(&call->lock);
    GLOBAL_UNLOCK();
    USERPRI;
    return requestCount;
}

int 
rx_Write(struct rx_call *call, const void *vbuf, int nbytes)
{
    struct rx_connection *conn = call->conn;
    int requestCount = nbytes;
    const char *buf = (const char *)vbuf;

    SPLVAR;

    GLOBAL_LOCK();
    RX_MUTEX_ENTER(&call->lock);
    NETPRI;
    if (call->mode != RX_MODE_SENDING) {
	if ((conn->type == RX_SERVER_CONNECTION)
	    && (call->mode == RX_MODE_RECEIVING)) {
	    call->mode = RX_MODE_SENDING;
	    if (call->currentPacket) {
		rxi_FreePacket(call->currentPacket);
		call->currentPacket = NULL;
		call->nLeft = 0;
		call->nFree = 0;
	    }
	} else {
	    RX_MUTEX_EXIT(&call->lock);
	    GLOBAL_UNLOCK();
	    USERPRI;
	    return 0;
	}
    }

    /*
     * Loop condition is checked at end, so that a write of 0 bytes will
     * force a packet to be created--specially for the case where there are 0
     * bytes on the stream, but we must send a packet anyway.
     */
    do {
	if (call->nFree == 0) {
	    struct rx_packet *cp = call->currentPacket;

	    if (!call->error && call->currentPacket) {
		clock_NewTime();       /* Bogus:  need new time package */

		/*
		 * The 0, below, specifies that it is not the last packet:
		 * there will be others. PrepareSendPacket may alter the
		 * packet length by up to conn->securityMaxTrailerSize
		 */
		rxi_PrepareSendPacket(call, cp, 0);
		queue_Append(&call->tq, cp);
		rxi_Start(0, call);
	    }
	    /* Wait for transmit window to open up */
	    while (!call->error && 
		   call->tnext + 1 > call->tfirst + call->twind) {
		clock_NewTime();
		call->startWait = clock_Sec();

		RX_MUTEX_EXIT(&call->lock);
		RX_MUTEX_ENTER(&call->lockw);

#ifdef	RX_ENABLE_LOCKS
		cv_wait(&call->cv_twind, &call->lockw);
#else
		call->flags |= RX_CALL_WAIT_WINDOW_ALLOC;
		osi_rxSleep(&call->twind);
#endif
		RX_MUTEX_EXIT(&call->lockw);
		RX_MUTEX_ENTER(&call->lock);

		call->startWait = 0;
	    }
	    if ((call->currentPacket = rxi_AllocSendPacket(call, 
							   nbytes)) != 0) {
		call->nFree = call->currentPacket->length;
		call->curvec = 1;      /* 0th vec is always header */

		/*
		 * begin at the beginning [ more or less ], continue on until
		 * the end, then stop.
		 */
		call->curpos = call->conn->securityHeaderSize;
	    }
	    if (call->error) {
		if (call->currentPacket) {
		    rxi_FreePacket(call->currentPacket);
		    call->currentPacket = NULL;
		}
		RX_MUTEX_EXIT(&call->lock);
		GLOBAL_UNLOCK();
		USERPRI;
		return 0;
	    }
	}

	/*
	 * If the remaining bytes fit in the buffer, then store them and
	 * return.  Don't ship a buffer that's full immediately to the
	 * peer--we don't know if it's the last buffer yet
	 */

	if (!(call->currentPacket)) {
	    call->nFree = 0;
	} 
	{
	    struct rx_packet *cp = call->currentPacket;
	    unsigned int t, l1;
	    caddr_t p1;

	    while (nbytes && call->nFree) {
		p1 = (char *)cp->wirevec[call->curvec].iov_base + call->curpos;
		l1 = cp->wirevec[call->curvec].iov_len - call->curpos;

		t = MIN(call->nFree, MIN(l1, nbytes));
		memcpy(p1, buf, t);
		p1 += t;
		buf += t;
		l1 -= t;
		nbytes -= t;
		call->curpos += t;
		call->nFree -= t;

		if (!l1) {
		    call->curpos = 0;
		    /* need to get another struct iov */
		    if (++call->curvec >= cp->niovecs) {
			/* current packet is full, extend or send it */
			call->nFree = 0;
		    }
		}
		if (!call->nFree) {
		    int len, mud;

		    len = cp->length;
		    mud = rx_MaxUserDataSize(conn);
		    if (mud > len) {
			int want;

			if (nbytes)
			    want = MIN(nbytes, mud - len);
			else
			    want = mud - len;
			rxi_AllocDataBuf(cp, want);
			if (cp->length > mud)
			    cp->length = mud;
			call->nFree += (cp->length - len);
		    }
		}
	    }			       /*
					* while bytes to send and room to
				        * send them 
					*/
	    /* might be out of space now */
	    if (!nbytes) {
		RX_MUTEX_EXIT(&call->lock);
		GLOBAL_UNLOCK();
		USERPRI;
		return requestCount;
	    } else;		       /*
					* more data to send, so get another
				        * packet and keep going 
					*/
	}
    } while (nbytes);

    RX_MUTEX_EXIT(&call->lock);
    GLOBAL_UNLOCK();
    USERPRI;
    return requestCount - nbytes;
}

/*
 * Flush any buffered data to the stream, switch to read mode
 * (clients) or to EOF mode (servers)
 */
void 
rx_FlushWrite(struct rx_call *call)
{
    SPLVAR;
    NETPRI;
    if (call->mode == RX_MODE_SENDING) {
	struct rx_packet *cp;

	call->mode = (call->conn->type == RX_CLIENT_CONNECTION ?
		      RX_MODE_RECEIVING : RX_MODE_EOF);

	if (call->currentPacket) {

	    /* cp->length is only supposed to be the user's data */

	    cp = call->currentPacket;

	    /*
	     * cp->length was already set to (then-current) MaxUserDataSize
	     * or less.
	     */
	    cp->length -= call->nFree;
	    call->currentPacket = (struct rx_packet *) 0;
	    call->nFree = 0;


	} else {
	    cp = rxi_AllocSendPacket(call, 0);
	    if (!cp) {
		/* Mode can no longer be MODE_SENDING */
		USERPRI;
		return;
	    }
	    cp->length = 0;
	    cp->niovecs = 1;	       /* just the header */
	    call->nFree = 0;
	}

	/* The 1 specifies that this is the last packet */
	rxi_PrepareSendPacket(call, cp, 1);
	queue_Append(&call->tq, cp);
	rxi_Start(0, call);
    }
    USERPRI;
}
@


1.4
log
@Merge
@
text
@@


1.3
log
@merge
@
text
@d3 1
a3 1
RCSID("$KTH: rx_rdwr.c,v 1.5 1999/11/18 01:51:18 assar Exp $");
a4 1
#ifdef	AFS_SGIMP_ENV
d6 1
a6 35
rx_Read(struct rx_call *call, char *buf, int nbytes)
{
    int rv;

    SPLVAR;
    GLOCKSTATE ms;

    NETPRI;
    AFS_GRELEASE(&ms);
    rv = rx_ReadProc(call, buf, nbytes);
    AFS_GACQUIRE(&ms);
    USERPRI;
    return rv;
}

int 
rx_Write(struct rx_call *call, char *buf, int nbytes)
{
    int rv;

    SPLVAR;
    GLOCKSTATE ms;

    NETPRI;
    AFS_GRELEASE(&ms);
    rv = rx_WriteProc(call, buf, nbytes);
    AFS_GACQUIRE(&ms);
    USERPRI;
    return rv;
}

#endif

int 
rx_ReadProc(struct rx_call *call, void *vbuf, int nbytes)
d18 1
a18 1
    MUTEX_ENTER(&call->lock);
d26 1
a26 1
			MUTEX_EXIT(&call->lock);
d63 1
a63 1
			    MUTEX_EXIT(&call->lock);
a102 6
#ifndef ADAPT_WINDOW
			if (call->rnext > (call->lastAcked + (rx_Window >> 1)))
#else				       /* ADAPT_WINDOW */
			if (call->rnext > (call->lastAcked +
					(call->conn->peer->maxWindow >> 1)))
#endif				       /* ADAPT_WINDOW */
d104 10
a113 1
			    rxi_SendAck(call, 0, 0, 0, 0, RX_ACK_DELAY);
d123 1
a123 1
		    MUTEX_EXIT(&call->lock);
d133 2
a134 2
		MUTEX_EXIT(&call->lock);
		MUTEX_ENTER(&call->lockq);
d141 2
a142 2
		MUTEX_EXIT(&call->lockq);
		MUTEX_ENTER(&call->lock);
d204 1
a204 1
		MUTEX_EXIT(&call->lock);
d213 1
a213 1
    MUTEX_EXIT(&call->lock);
d220 1
a220 1
rx_WriteProc(struct rx_call *call, const void *vbuf, int nbytes)
d229 1
a229 1
    MUTEX_ENTER(&call->lock);
d242 1
a242 1
	    MUTEX_EXIT(&call->lock);
d276 2
a277 2
		MUTEX_EXIT(&call->lock);
		MUTEX_ENTER(&call->lockw);
d285 2
a286 2
		MUTEX_EXIT(&call->lockw);
		MUTEX_ENTER(&call->lock);
d306 1
a306 1
		MUTEX_EXIT(&call->lock);
d356 4
a359 1
			want = MIN(nbytes, mud - len);
d372 1
a372 1
		MUTEX_EXIT(&call->lock);
d383 1
a383 1
    MUTEX_EXIT(&call->lock);
@


1.2
log
@New Arla userland from Arla between 0.34.2 and current in arla cvs.
Too many new features and fixes to mention here.
@
text
@d3 1
a3 1
RCSID("$Id: rx_rdwr.c,v 1.5 1999/11/18 01:51:18 assar Exp $");
@


1.1
log
@Initial revision
@
text
@a0 1
/*	$OpenBSD$	*/
d3 1
a3 1
RCSID("$KTH: rx_rdwr.c,v 1.4 1998/02/22 19:53:57 joda Exp $");
d41 1
a41 1
rx_ReadProc(struct rx_call *call, char *buf, int nbytes)
d45 1
d252 1
a252 1
rx_WriteProc(struct rx_call *call, char *buf, int nbytes)
d256 1
@


1.1.1.1
log
@Initial version of Arla, a free implementation of an AFS cache-manager.
(second try, hopefully into the correct repository this time)
@
text
@@


1.1.1.2
log
@Import of arla-0.35.7
@
text
@d1 1
d4 1
a4 1
RCSID("$KTH: rx_rdwr.c,v 1.5 1999/11/18 01:51:18 assar Exp $");
d42 1
a42 1
rx_ReadProc(struct rx_call *call, void *vbuf, int nbytes)
a45 1
    char *buf = (char *)vbuf;
d252 1
a252 1
rx_WriteProc(struct rx_call *call, const void *vbuf, int nbytes)
a255 1
    const char *buf = (const char *)vbuf;
@


1.1.1.3
log
@Import of arla -current as of Aug 5 2003

ok todd@@ deraadt@@
@
text
@d3 1
a3 1
RCSID("$arla: rx_rdwr.c,v 1.9 2002/12/15 11:45:19 lha Exp $");
d5 1
d7 35
a41 1
rx_Read(struct rx_call *call, void *vbuf, int nbytes)
d53 1
a53 1
    RX_MUTEX_ENTER(&call->lock);
d61 1
a61 1
			RX_MUTEX_EXIT(&call->lock);
d98 1
a98 1
			    RX_MUTEX_EXIT(&call->lock);
d138 6
d145 1
a145 10
			    int ack_window;

#ifdef ADAPT_WINDOW
			    ack_window = call->conn->peer->maxWindow >> 1;
#else /* !ADAPT_WINDOW */
			    ack_window = rx_Window >> 1;
#endif/* ADAPT_WINDOW */

			    if (call->rnext > (call->lastAcked + ack_window)) 
				rxi_SendAck(call, 0, 0, 0, 0, RX_ACK_DELAY);
d155 1
a155 1
		    RX_MUTEX_EXIT(&call->lock);
d165 2
a166 2
		RX_MUTEX_EXIT(&call->lock);
		RX_MUTEX_ENTER(&call->lockq);
d173 2
a174 2
		RX_MUTEX_EXIT(&call->lockq);
		RX_MUTEX_ENTER(&call->lock);
d236 1
a236 1
		RX_MUTEX_EXIT(&call->lock);
d245 1
a245 1
    RX_MUTEX_EXIT(&call->lock);
d252 1
a252 1
rx_Write(struct rx_call *call, const void *vbuf, int nbytes)
d261 1
a261 1
    RX_MUTEX_ENTER(&call->lock);
d274 1
a274 1
	    RX_MUTEX_EXIT(&call->lock);
d308 2
a309 2
		RX_MUTEX_EXIT(&call->lock);
		RX_MUTEX_ENTER(&call->lockw);
d317 2
a318 2
		RX_MUTEX_EXIT(&call->lockw);
		RX_MUTEX_ENTER(&call->lock);
d338 1
a338 1
		RX_MUTEX_EXIT(&call->lock);
d388 1
a388 4
			if (nbytes)
			    want = MIN(nbytes, mud - len);
			else
			    want = mud - len;
d401 1
a401 1
		RX_MUTEX_EXIT(&call->lock);
d412 1
a412 1
    RX_MUTEX_EXIT(&call->lock);
@


