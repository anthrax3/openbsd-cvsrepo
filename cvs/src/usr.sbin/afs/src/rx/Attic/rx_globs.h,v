head	1.5;
access;
symbols
	OPENBSD_5_2:1.4.0.38
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.36
	OPENBSD_5_0:1.4.0.34
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.32
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.30
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.4.0.26
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.4.0.28
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.4.0.24
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.4.0.22
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.4.0.20
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.4.0.18
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.4.0.16
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.4.0.14
	OPENBSD_4_0_BASE:1.4
	OPENBSD_3_9:1.4.0.12
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.10
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.8
	OPENBSD_3_7_BASE:1.4
	OPENBSD_3_6:1.4.0.6
	OPENBSD_3_6_BASE:1.4
	OPENBSD_3_5:1.4.0.4
	OPENBSD_3_5_BASE:1.4
	OPENBSD_3_4:1.4.0.2
	OPENBSD_3_4_BASE:1.4
	arla-20030805:1.1.1.3
	OPENBSD_3_3:1.3.0.4
	OPENBSD_3_3_BASE:1.3
	OPENBSD_3_2:1.3.0.2
	OPENBSD_3_2_BASE:1.3
	arla-0-35-7:1.1.1.2
	OPENBSD_3_1:1.2.0.8
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.6
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_9:1.2.0.4
	OPENBSD_2_8:1.2.0.2
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.1.1.1.0.8
	OPENBSD_2_7_BASE:1.1.1.1
	OPENBSD_2_6:1.1.1.1.0.6
	OPENBSD_2_6_BASE:1.1.1.1
	OPENBSD_2_5:1.1.1.1.0.4
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.2
	OPENBSD_2_4_BASE:1.1.1.1
	arla-0_9:1.1.1.1
	arla:1.1.1;
locks; strict;
comment	@ * @;


1.5
date	2012.08.23.06.21.53;	author deraadt;	state dead;
branches;
next	1.4;

1.4
date	2003.08.05.09.11.12;	author hin;	state Exp;
branches;
next	1.3;

1.3
date	2002.06.07.04.43.30;	author hin;	state Exp;
branches;
next	1.2;

1.2
date	2000.09.11.14.41.21;	author art;	state Exp;
branches;
next	1.1;

1.1
date	98.09.14.21.53.15;	author art;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.09.14.21.53.15;	author art;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.06.07.04.14.34;	author hin;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2003.08.05.08.21.06;	author hin;	state Exp;
branches;
next	;


desc
@@


1.5
log
@the afs src tree can go away
@
text
@/* $arla: rx_globs.h,v 1.10 2003/01/19 08:49:58 lha Exp $ */

/*
****************************************************************************
*        Copyright IBM Corporation 1988, 1989 - All Rights Reserved        *
*                                                                          *
* Permission to use, copy, modify, and distribute this software and its    *
* documentation for any purpose and without fee is hereby granted,         *
* provided that the above copyright notice appear in all copies and        *
* that both that copyright notice and this permission notice appear in     *
* supporting documentation, and that the name of IBM not be used in        *
* advertising or publicity pertaining to distribution of the software      *
* without specific, written prior permission.                              *
*                                                                          *
* IBM DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL *
* IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL IBM *
* BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY      *
* DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER  *
* IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING   *
* OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.    *
****************************************************************************
*/

/* RX:  Globals for internal use, basically */

#ifdef	KERNEL
#include "../rx/rx.h"
#else				       /* KERNEL */
#include "rx.h"
#endif				       /* KERNEL */

#ifndef INIT
#define INIT(x)
#define	EXT extern
#endif				       /* INIT */

/* The array of installed services.  Null terminated. */
EXT struct rx_service *rx_services[RX_MAX_SERVICES + 1];

/* Incoming calls wait on this queue when there are no available server processes */
EXT struct rx_queue rx_incomingCallQueue;

/* Server processes wait on this queue when there are no appropriate calls to process */
EXT struct rx_queue rx_idleServerQueue;

/*
 * Constant delay time before sending an acknowledge of the last
 * packet received.  This is to avoid sending an extra acknowledge
 * when the client is about to make another call, anyway, or the
 * server is about to respond.
 */
EXT struct clock rx_lastAckDelay;

#ifdef SOFT_ACK
/*
 * Constant delay time before sending a hard ack if the receiver
 * consumes a packet while no delayed ack event is scheduled. Ensures
 * that the sender is able to advance its window when the receiver
 * consumes a packet after the sender has exhausted its transmit
 * window.
 */
EXT struct clock rx_hardAckDelay;

/*
 * Constant delay time before sending a soft ack when none was
 * requested.  This is to make sure we send soft acks before the
 * sender times out, Normally we wait and send a hard ack when the
 * receiver consumes the packet
 */
EXT struct clock rx_softAckDelay;

#endif /* SOFT_ACK */

/* Variable to allow introduction of network unreliability */
#ifdef RXDEBUG
EXT int rx_intentionallyDroppedPacketsPer100 INIT(0);	/* Dropped on Send */

#endif

EXT int rx_extraQuota INIT(0);	       /* extra packets to add to the quota */
EXT int rx_extraPackets INIT(32);      /* extra packets to alloc (2 windows
				        * by deflt) */

EXT int rx_stackSize INIT(RX_DEFAULT_STACK_SIZE);

EXT int rx_connDeadTime INIT(12);      /* Time until an unresponsive
				        * connection is declared dead */
EXT int rx_idleConnectionTime INIT(700);	/* Time until we toss an idle
						 * connection */
EXT int rx_idlePeerTime INIT(60);      /* Time until we toss a peer
				        * structure, after all connections
				        * using it have disappeared */

/* These definitions should be in one place */
#ifdef	AFS_SUN5_ENV
#define	RX_CBUF_TIME	180	       /* Check for cbuf deficit */
#define	RX_REAP_TIME	90	       /* Check for tossable connections
				        * every 90 seconds */
#else
#define	RX_CBUF_TIME	120	       /* Check for cbuf deficit */
#define	RX_REAP_TIME	60	       /* Check for tossable connections
				        * every 60 seconds */
#endif

#ifdef SOFT_ACK
#define RX_FAST_ACK_RATE 1

EXT int rxi_SoftAckRate INIT(RX_FAST_ACK_RATE);
EXT int rxi_HardAckRate INIT(RX_FAST_ACK_RATE + 1);

#endif /* SOFT_ACK */

EXT int rx_Window INIT(15);	       /* Temporary HACK:  transmit/receive
				        * window */
EXT int rx_initialWindow INIT(2);      /* "Slow start" with 2 packets */

EXT int rx_nPackets INIT(100);	       /* obsolete; use rx_extraPackets now */

/* List of free packets */
EXT struct rx_queue rx_freePacketQueue;
EXT struct rx_queue rx_freeCbufQueue;

#ifdef RX_ENABLE_LOCKS
EXT afs_lock_t rx_freePktQ_lock;

#endif

/* Number of free packets */
EXT int rx_nFreePackets INIT(0);
EXT int rx_nFreeCbufs INIT(0);
EXT int rx_nCbufs INIT(0);
EXT int rxi_NeedMoreCbufs INIT(0);
EXT int rx_nWaiting INIT(0);

/* largest packet which we can safely receive, initialized to AFS 3.2 value
 * This is provided for backward compatibility with peers which may be unable
 * to swallow anything larger. THIS MUST NEVER DECREASE WHILE AN APPLICATION
 * IS RUNNING! */
EXT u_long rx_maxReceiveSize INIT(OLD_MAX_PACKET_SIZE);

EXT u_long rx_MyMaxSendSize INIT(OLD_MAX_PACKET_SIZE - RX_HEADER_SIZE);


/* List of free queue entries */
EXT struct rx_serverQueueEntry *rx_FreeSQEList INIT(0);

#ifdef	RX_ENABLE_LOCKS
EXT kmutex_t freeSQEList_lock;

#endif

/* List of free call structures */
EXT struct rx_queue rx_freeCallQueue;

#ifdef	RX_ENABLE_LOCKS
EXT kmutex_t rx_freeCallQueue_lock;

#endif
EXT long rxi_nCalls INIT(0);

/* Basic socket for client requests; other sockets (for receiving server requests) are in the service structures */
EXT osi_socket rx_socket;

/* Port requested at rx_Init.  If this is zero, the actual port used will be different--but it will only be used for client operations.  If non-zero, server provided services may use the same port. */
EXT uint16_t rx_port;

/* This is actually the minimum number of packets that must remain free,
    overall, immediately after a packet of the requested class has been
    allocated.  *WARNING* These must be assigned with a great deal of care.
    In order, these are receive quota, send quota and special quota */
#define	RX_PACKET_QUOTAS {1, 10, 0}
/* value large enough to guarantee that no allocation fails due to RX_PACKET_QUOTAS.
   Make it a little bigger, just for fun */
#define	RX_MAX_QUOTA	15	       /* part of min packet computation */
EXT int rx_packetQuota[RX_N_PACKET_CLASSES] INIT(RX_PACKET_QUOTAS);

EXT int rx_nextCid;		       /* Next connection call id */
EXT uint32_t rx_epoch;		       /* Initialization time of rx */

#ifdef	RX_ENABLE_LOCKS
EXT kmutex_t rx_waitingForPackets_lock;
EXT kcondvar_t rx_waitingForPackets_cv;

#endif
EXT char rx_waitingForPackets;	       /* Processes set and wait on this
				        * variable when waiting for packet
				        * buffers */

EXT struct rx_stats rx_stats;

EXT struct rx_peer **rx_peerHashTable;
EXT struct rx_connection **rx_connHashTable;
EXT u_long rx_hashTableSize INIT(256); /* Power of 2 */
EXT u_long rx_hashTableMask INIT(255); /* One less than rx_hashTableSize */

#define CONN_HASH(host, port, cid, epoch, type) ((((cid)>>RX_CIDSHIFT)&rx_hashTableMask))

#define PEER_HASH(host, port)  ((host ^ port) & rx_hashTableMask)

#ifdef	notdef			       /* Use a func for now to measure
				        * allocated structs */
#define	rxi_Free(addr, size)	osi_Free(addr, size)
#endif				       /* notdef */

#define rxi_AllocSecurityObject() (struct rx_securityClass *) rxi_Alloc(sizeof(struct rx_securityClass))
#define	rxi_FreeSecurityObject(obj) rxi_Free(obj, sizeof(struct rx_securityClass))
#define	rxi_AllocService()	(struct rx_service *) rxi_Alloc(sizeof(struct rx_service))
#define	rxi_FreeService(obj)	rxi_Free(obj, sizeof(struct rx_service))
#define	rxi_AllocPeer()		(struct rx_peer *) rxi_Alloc(sizeof(struct rx_peer))
#define	rxi_FreePeer(peer)	rxi_Free(peer, sizeof(struct rx_peer))
#define	rxi_AllocConnection()	(struct rx_connection *) rxi_Alloc(sizeof(struct rx_connection))
#define rxi_FreeConnection(conn) (rxi_Free(conn, sizeof(struct rx_connection)))

/* Forward definitions of internal procedures */
struct rx_packet *	rxi_AllocPacket(int);
struct rx_packet *	rxi_AllocSendPacket(struct rx_call *, int);
void *			rxi_Alloc(int);
struct rx_peer *	rxi_FindPeer(uint32_t, uint16_t);
struct rx_call *	rxi_NewCall(struct rx_connection *, int);
void			rxi_FreeCall(struct rx_call *);
void			rxi_Listener(void);
int			rxi_ReadPacket(int, struct rx_packet *, 
				       uint32_t *, uint16_t *);
struct rx_packet *	rxi_ReceivePacket(struct rx_packet *, osi_socket,
					  uint32_t, uint16_t);
struct rx_packet *	rxi_ReceiveDataPacket(struct rx_call *,
					      struct rx_packet *);
struct rx_packet *	rxi_ReceiveAckPacket(struct rx_call *,
					     struct rx_packet *);
struct rx_packet *	rxi_ReceiveResponsePacket(struct rx_connection *, 
						  struct rx_packet *);
struct rx_packet *	rxi_ReceiveChallengePacket(struct rx_connection *,
						   struct rx_packet *);
void			rx_ServerProc(void);
void			rxi_AttachServerProc(struct rx_call *);
void			rxi_ChallengeOn(struct rx_connection *);
void			rxi_InitPeerParams(struct rx_peer *);


#define	rxi_ChallengeOff(conn)	rxevent_Cancel((conn)->challengeEvent);
void rxi_ChallengeEvent(struct rxevent*, struct rx_connection *, 
			char *);
struct rx_packet *rxi_SendAck(struct rx_call *, 
			      struct rx_packet *, int, int, int, int);
void rxi_ClearTransmitQueue(struct rx_call *);
void rxi_ClearReceiveQueue(struct rx_call *);
void rxi_ResetConnection(struct rx_connection *);
void rxi_InitCall(void); /* obsolete ? */
void rxi_ResetCall(struct rx_call *);
void rxi_CallError(struct rx_call *, int32_t);
void rxi_ConnectionError(struct rx_connection *, int32_t);
void rxi_QueuePackets(void); /* obsolete ? */
void rxi_Start(struct rxevent *, struct rx_call *);
void rxi_CallIsIdle(void); /* obsolete ? */
void rxi_CallTimedOut(void); /* obsolete ? */
void rxi_ComputeRoundTripTime(struct rx_packet *, 
			      struct clock *, 
			      struct rx_peer *);
void rxi_ScheduleKeepAliveEvent(struct rx_call *);
void rxi_KeepAliveEvent(struct rxevent *, struct rx_call *, char *);
void rxi_KeepAliveOn(struct rx_call *);

#define rxi_KeepAliveOff(call) rxevent_Cancel((call)->keepAliveEvent)
void rxi_AckAll(struct rxevent *, struct rx_call *, char *);
void rxi_SendDelayedAck(struct rxevent *, struct rx_call *, char *);
struct rx_packet *rxi_SendSpecial(struct rx_call *,
				  struct rx_connection *,
				  struct rx_packet *, int, char *, int);
struct rx_packet *rxi_SendCallAbort(struct rx_call *, 
				    struct rx_packet *);
struct rx_packet *rxi_SendConnectionAbort(struct rx_connection *,
					  struct rx_packet *);
void rxi_ScheduleDecongestionEvent(struct rx_call *, int);
void rxi_CongestionWait(struct rx_call *);
void rxi_ReapConnections(void);
void rxi_EncodePacketHeader(struct rx_packet *);
void rxi_DecodePacketHeader(struct rx_packet *);
void rxi_DebugPrint(const char *, ...);
void rxi_PrepareSendPacket(struct rx_call *, 
			   struct rx_packet *, int);
void rxi_MoreCbufs(int);
uint32_t rx_SlowGetLong(struct rx_packet *, int);

void rxi_Send(struct rx_call *, struct rx_packet *);
void rxi_FreeAllPackets(void);
void rxi_SendPacket(struct rx_connection *,
		    struct rx_packet *);
int rxi_IsConnInteresting(struct rx_connection *);
struct rx_packet *rxi_ReceiveDebugPacket(struct rx_packet *, osi_socket,
					 uint32_t, uint16_t);
struct rx_packet *rxi_ReceiveVersionPacket(struct rx_packet *, osi_socket,
					   uint32_t, uint16_t);
void rxi_SendDebugPacket(struct rx_packet *, osi_socket, uint32_t, uint16_t);


#ifdef RXDEBUG
/* Some debugging stuff */
EXT FILE *rx_debugFile;		       /* Set by the user to a stdio file for
				        * debugging output */

#define Log rx_debugFile
#define dpf(args) do { if (rx_debugFile) rxi_DebugPrint args; } while(0)

EXT char *rx_packetTypes[RX_N_PACKET_TYPES] INIT(RX_PACKET_TYPES);	/* Strings defined in
									 * rx.h */

#else
#define dpf(args)
#endif				       /* RXDEBUG */
@


1.4
log
@Merge
@
text
@@


1.3
log
@merge
@
text
@d1 1
a1 1
/* $KTH: rx_globs.h,v 1.6 2000/10/08 17:48:15 assar Exp $ */
d46 6
a51 1
/* Constant delay time before sending an acknowledge of the last packet received.  This is to avoid sending an extra acknowledge when the client is about to make another call, anyway, or the server is about to respond. */
d54 20
d105 8
d115 1
a115 4
EXT int rx_ACKHACK INIT(4);	       /* Temporary HACK:  how often to send
				        * request for acknowledge */

#define	ACKHACK(p)  ((((p)->header.seq & 3)==0) && ((p)->header.flags |= RX_REQUEST_ACK))
a140 1
#if (defined(AFS_SUN5_ENV) || defined(AFS_AOS_ENV)) && defined(KERNEL)
a142 5
#else
EXT u_long rx_MyMaxSendSize INIT(RX_MAX_PACKET_DATA_SIZE);

#endif

d165 1
a165 1
EXT u_short rx_port;
d178 1
a178 1
EXT int rx_epoch;		       /* Initialization time of rx */
d215 14
a228 17
struct rx_packet *rxi_AllocPacket(int);
struct rx_packet *rxi_AllocSendPacket(struct rx_call *, int);
char *rxi_Alloc(int);
struct rx_peer *rxi_FindPeer(u_long, u_short);
struct rx_call *rxi_NewCall(struct rx_connection *, int);
void rxi_FreeCall(struct rx_call *);
void rxi_Listener(void);
int rxi_ReadPacket(int, struct rx_packet *, u_long *, u_short *);
struct rx_packet *rxi_ReceivePacket(struct rx_packet *, osi_socket,
				    u_long, u_short);
struct rx_packet *rxi_ReceiveDataPacket(struct rx_call *,
					struct rx_packet *);
struct rx_packet *rxi_ReceiveAckPacket(struct rx_call *,
				       struct rx_packet *);
struct rx_packet *rxi_ReceiveResponsePacket(struct rx_connection *, 
					    struct rx_packet *);
struct rx_packet *rxi_ReceiveChallengePacket(struct rx_connection *,
d230 8
a237 4
void rx_ServerProc(void);
void rxi_AttachServerProc(struct rx_call *);
void rxi_ChallengeOn(struct rx_connection *);
void rxi_InitPeerParams(struct rx_peer *);
d282 1
a282 1
long rx_SlowGetLong(struct rx_packet *, int);
d290 1
a290 1
					 long, short);
d292 2
a293 2
					   long, short);
void rxi_SendDebugPacket(struct rx_packet *, osi_socket, long, short);
d302 1
a302 1
#define dpf(args) if (rx_debugFile) rxi_DebugPrint args; else
@


1.2
log
@New Arla userland from Arla between 0.34.2 and current in arla cvs.
Too many new features and fixes to mention here.
@
text
@d1 1
a1 1
/* $Id: rx_globs.h,v 1.5 1999/10/15 16:12:35 map Exp $ */
a141 5

/* 32-bit select Mask for rx_Listener.  We use 32 bits because IOMGR_Select only supports 32 */
EXT fd_set rx_selectMask;
EXT int rx_maxSocketNumber;	       /* Maximum socket number represented
				        * in the select mask */
@


1.1
log
@Initial revision
@
text
@d1 1
a1 2
/*	$OpenBSD$	*/
/* $KTH: rx_globs.h,v 1.4 1998/02/22 19:46:16 joda Exp $ */
d230 2
a231 2
void rxi_CallError(struct rx_call *, long);
void rxi_ConnectionError(struct rx_connection *, long);
@


1.1.1.1
log
@Initial version of Arla, a free implementation of an AFS cache-manager.
(second try, hopefully into the correct repository this time)
@
text
@@


1.1.1.2
log
@Import of arla-0.35.7
@
text
@d1 2
a2 1
/* $KTH: rx_globs.h,v 1.6 2000/10/08 17:48:15 assar Exp $ */
d144 5
d231 2
a232 2
void rxi_CallError(struct rx_call *, int32_t);
void rxi_ConnectionError(struct rx_connection *, int32_t);
@


1.1.1.3
log
@Import of arla -current as of Aug 5 2003

ok todd@@ deraadt@@
@
text
@d1 1
a1 1
/* $arla: rx_globs.h,v 1.10 2003/01/19 08:49:58 lha Exp $ */
d46 1
a46 6
/*
 * Constant delay time before sending an acknowledge of the last
 * packet received.  This is to avoid sending an extra acknowledge
 * when the client is about to make another call, anyway, or the
 * server is about to respond.
 */
a48 20
#ifdef SOFT_ACK
/*
 * Constant delay time before sending a hard ack if the receiver
 * consumes a packet while no delayed ack event is scheduled. Ensures
 * that the sender is able to advance its window when the receiver
 * consumes a packet after the sender has exhausted its transmit
 * window.
 */
EXT struct clock rx_hardAckDelay;

/*
 * Constant delay time before sending a soft ack when none was
 * requested.  This is to make sure we send soft acks before the
 * sender times out, Normally we wait and send a hard ack when the
 * receiver consumes the packet
 */
EXT struct clock rx_softAckDelay;

#endif /* SOFT_ACK */

a79 8
#ifdef SOFT_ACK
#define RX_FAST_ACK_RATE 1

EXT int rxi_SoftAckRate INIT(RX_FAST_ACK_RATE);
EXT int rxi_HardAckRate INIT(RX_FAST_ACK_RATE + 1);

#endif /* SOFT_ACK */

d82 4
a85 1
EXT int rx_initialWindow INIT(2);      /* "Slow start" with 2 packets */
d111 1
d114 5
d141 1
a141 1
EXT uint16_t rx_port;
d154 1
a154 1
EXT uint32_t rx_epoch;		       /* Initialization time of rx */
d191 17
a207 14
struct rx_packet *	rxi_AllocPacket(int);
struct rx_packet *	rxi_AllocSendPacket(struct rx_call *, int);
void *			rxi_Alloc(int);
struct rx_peer *	rxi_FindPeer(uint32_t, uint16_t);
struct rx_call *	rxi_NewCall(struct rx_connection *, int);
void			rxi_FreeCall(struct rx_call *);
void			rxi_Listener(void);
int			rxi_ReadPacket(int, struct rx_packet *, 
				       uint32_t *, uint16_t *);
struct rx_packet *	rxi_ReceivePacket(struct rx_packet *, osi_socket,
					  uint32_t, uint16_t);
struct rx_packet *	rxi_ReceiveDataPacket(struct rx_call *,
					      struct rx_packet *);
struct rx_packet *	rxi_ReceiveAckPacket(struct rx_call *,
d209 4
a212 8
struct rx_packet *	rxi_ReceiveResponsePacket(struct rx_connection *, 
						  struct rx_packet *);
struct rx_packet *	rxi_ReceiveChallengePacket(struct rx_connection *,
						   struct rx_packet *);
void			rx_ServerProc(void);
void			rxi_AttachServerProc(struct rx_call *);
void			rxi_ChallengeOn(struct rx_connection *);
void			rxi_InitPeerParams(struct rx_peer *);
d257 1
a257 1
uint32_t rx_SlowGetLong(struct rx_packet *, int);
d265 1
a265 1
					 uint32_t, uint16_t);
d267 2
a268 2
					   uint32_t, uint16_t);
void rxi_SendDebugPacket(struct rx_packet *, osi_socket, uint32_t, uint16_t);
d277 1
a277 1
#define dpf(args) do { if (rx_debugFile) rxi_DebugPrint args; } while(0)
@


