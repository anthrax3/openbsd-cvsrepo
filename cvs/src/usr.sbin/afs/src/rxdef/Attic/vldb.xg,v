head	1.6;
access;
symbols
	OPENBSD_5_2:1.5.0.38
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.36
	OPENBSD_5_0:1.5.0.34
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.32
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.30
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.26
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.5.0.28
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.5.0.24
	OPENBSD_4_5_BASE:1.5
	OPENBSD_4_4:1.5.0.22
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3:1.5.0.20
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.5.0.18
	OPENBSD_4_2_BASE:1.5
	OPENBSD_4_1:1.5.0.16
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.5.0.14
	OPENBSD_4_0_BASE:1.5
	OPENBSD_3_9:1.5.0.12
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.5.0.10
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.8
	OPENBSD_3_7_BASE:1.5
	OPENBSD_3_6:1.5.0.6
	OPENBSD_3_6_BASE:1.5
	OPENBSD_3_5:1.5.0.4
	OPENBSD_3_5_BASE:1.5
	OPENBSD_3_4:1.5.0.2
	OPENBSD_3_4_BASE:1.5
	arla-20030805:1.1.1.3
	OPENBSD_3_3:1.4.0.4
	OPENBSD_3_3_BASE:1.4
	OPENBSD_3_2:1.4.0.2
	OPENBSD_3_2_BASE:1.4
	arla-0-35-7:1.1.1.2
	OPENBSD_3_1:1.3.0.8
	OPENBSD_3_1_BASE:1.3
	OPENBSD_3_0:1.3.0.6
	OPENBSD_3_0_BASE:1.3
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_9:1.3.0.4
	OPENBSD_2_8:1.3.0.2
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.2.0.4
	OPENBSD_2_7_BASE:1.2
	OPENBSD_2_6:1.2.0.2
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.1.1.1.0.4
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.2
	OPENBSD_2_4_BASE:1.1.1.1
	arla-0_9:1.1.1.1
	arla:1.1.1;
locks; strict;
comment	@# @;


1.6
date	2012.08.23.06.21.55;	author deraadt;	state dead;
branches;
next	1.5;

1.5
date	2003.08.05.09.16.15;	author hin;	state Exp;
branches;
next	1.4;

1.4
date	2002.06.07.04.44.13;	author hin;	state Exp;
branches;
next	1.3;

1.3
date	2000.09.11.14.41.25;	author art;	state Exp;
branches;
next	1.2;

1.2
date	99.04.30.01.59.16;	author art;	state Exp;
branches;
next	1.1;

1.1
date	98.09.14.21.53.18;	author art;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.09.14.21.53.18;	author art;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.06.07.04.14.36;	author hin;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2003.08.05.08.21.07;	author hin;	state Exp;
branches;
next	;


desc
@@


1.6
log
@the afs src tree can go away
@
text
@/* This is -*-c-*- */

/*
 * Interface to VLDB
 */

package VL_

%#include <fs_errors.h>
%#include <fs.h>

error-function conv_to_arla_errno

#include "common.h"

/*
 * Structures and defines for vldb data
 */

const VLDB_MAXNAMELEN		= 65;
const MAXNSERVERS		= 8;
const NMAXNSERVERS		= 13;
const MAX_NUMBER_OPCODES	= 30;
const MAXTYPES			= 3;
const MAXSERVERID		= 30;
const HASHSIZE			= 8191;
const DEFAULTBULK		= 10000;

typedef opaque bulk<DEFAULTBULK>;

#if 0
typedef struct single_vldbentry *vldblist;
#endif

/*
 * Used in vlentry.server[i].flags
 * ie for each site/server
 */

const VLSF_NEWREPSITE = 0x01;	/* ??? */
const VLSF_ROVOL      = 0x02;	/* Readonly volume on this site */
const VLSF_RWVOL      = 0x04;	/* Readwrite volume on this site */
const VLSF_BACKVOL    = 0x08;	/* Backup volume on this site */
const VLSF_UUID	      = 0x10;	/* Internal flag in Transarc client */
const VLSF_DONTUSE    = 0x20;	/* Not yet released volumes */

/*
 * Used in vlentry.flags
 * ie used for whole entry
 */

/* Internal information in the vldb */
const VLFREE           = 0x1;
const VLDELETED        = 0x2;
const VLLOCKED         = 0x4;

/* Volser information/status */
const VLOP_MOVE		= 0x10;
const VLOP_RELEASE	= 0x20;
const VLOP_BACKUP	= 0x40;
const VLOP_DELETE	= 0x80;
const VLOP_DUMP		= 0x100;

%#define VLOP_ALLOPERS ( VLOP_MOVE | VLOP_RELEASE | VLOP_BACKUP | VLOP_DELETE | VLOP_DUMP)

/* Location  information */
const VLF_RWEXISTS    = 0x1000;
const VLF_ROEXISTS    = 0x2000;
const VLF_BOEXISTS    = 0x4000;
const VLF_BACKEXISTS  = 0x4000;
const VLF_DFSFILESET  = 0x8000;

/* VL error interface */
const VL_IDEXIST       = 363520;
const VL_IO            = 363521;
const VL_NAMEEXIST     = 363522;
const VL_CREATEFAIL    = 363523;
const VL_NOENT         = 363524;
const VL_EMPTY         = 363525;
const VL_ENTDELETED    = 363526;
const VL_BADNAME       = 363527;
const VL_BADINDEX      = 363528;
const VL_BADVOLTYPE    = 363529;
const VL_BADPARTITION  = 363530;
const VL_BADSERVER     = 363531;
const VL_REPSFULL      = 363532;
const VL_NOREPSERVER   = 363533;
const VL_DUPREPSERVER  = 363534;
const VL_RWNOTFOUND    = 363535;
const VL_BADREFCOUNT   = 363536;
const VL_SIZEEXCEEDED  = 363537;
const VL_BADENTRY      = 363538;
const VL_BADVOLIDBUMP  = 363539;
const VL_IDALREADHASED = 363540;
const VL_ENTRYLOCKED   = 363541;
const VL_BADVOLOPER    = 363542;
const VL_BADRELLOCKTYPE= 363543;
const VL_RERELEASE     = 363544;
const VL_BADSERVERFLAG = 363545;
const VL_PERM          = 363546;
const VL_NOMEM         = 363547;
const VL_BADVERSION    = 363548;
const VL_INDEXERANGE   = 363549;
const VL_MULTIPADDR    = 363550;
const VL_BADMASK       = 363551;


/*
 * Opcodes
 */

const VLCREATEENTRY		= 501;
const VLDELETEENTRY		= 502;
const VLGETENTRYBYID		= 503;
const VLGETENTRYBYNAME		= 504;
const VLGETNEWVOLUMEID		= 505;
const VLREPLACEENTRY		= 506;
const VLUPDATEENTRY		= 507;
const VLSETLOCK			= 508;
const VLRELEASELOCK		= 509;
const VLLISTENTRY		= 510;
const VLLISTATTRIBUTES	 	= 511;
const VLLINKEDLIST		= 512;
const VLGETSTATS		= 513;
const VLPROBE			= 514;
const VLGETADDRS		= 515;
const VLCHANGEADDR		= 516;
const VLCREATEENTRYN		= 517;
const VLGETENTRYBYIDN		= 518;
const VLGETENTRYBYNAMEN	 	= 519;
const VLREPLACEENTRYN		= 520;
const VLLISTENTRYN		= 521;
const VLLISTATTRIBUTESN		= 522;
const VLLINKEDLISTN		= 523;
const VLUPDATEENTRYBYNAME	= 524;
const VLCREATEENTRYU		= 525;
const VLGETENTRYBYIDU		= 526;
const VLGETENTRYBYNAMEU		= 527;
const VLREPLACEENTRYU		= 528;
const VLLISTENTRYU		= 529;
const VLLISTATTRIBUTESU		= 530;
const VLLINKEDLISTU		= 531;
const VLREGADDR			= 532;
const VLGETADDRSU		= 533;
const VLLISTATTRIBUTESN2	= 534;

/*
 * ReleaseType argument for VL_ReleaseLock
 */
const LOCKREL_TIMESTAMP = 1;
const LOCKREL_OPCODE    = 2;
const LOCKREL_AFSID     = 4;

struct vldbentry {
     char name[VLDB_MAXNAMELEN];
     long volumeType;		/* currrent unused */
     long nServers;
     long serverNumber[MAXNSERVERS];
     long serverPartition[MAXNSERVERS];
     long serverFlags[MAXNSERVERS];
     u_long volumeId[MAXTYPES];
     long cloneId;
     long flags;
};

struct nvldbentry {
    char name[VLDB_MAXNAMELEN];
    long nServers;
    long serverNumber[NMAXNSERVERS];
    long serverPartition[NMAXNSERVERS];
    long serverFlags[NMAXNSERVERS];
    u_long volumeId[MAXTYPES];
    long cloneId;
    long flags;
    long matchindex;
    long spares2;
    long spares3;
    long spares4;
    long spares5;
    long spares6;
    long spares7;
    long spares8;
    long spares9;
};

struct vlentry {
    u_long volumeId[MAXTYPES];
    long flags;
    long LockAfsId;
    long LockTimestamp;
    long cloneId;
    long AssociatedChain;
    long nextIdHash[MAXTYPES];
    long nextNameHash;
    long spares1[2];
    char name[VLDB_MAXNAMELEN];
    u_char volumeType;
    u_char serverNumber[MAXNSERVERS];
    u_char serverPartition[MAXNSERVERS];
    u_char serverFlags[MAXNSERVERS];
    u_char RefCount;
    char spares2[1];
};

/* disk_vlentry is arla specific */

struct disk_vlentry {
    u_long volumeId[MAXTYPES];
    long flags;
    long cloneId;
    string name<>;
    long serverNumber<>;
    long serverPartition<>;
    long serverFlags<>;
};

struct vital_vlheader {
     long vldbversion;
     long headersize;
     long freePtr;
     long eofPtr;
     long allocs;
     long frees;
     long MaxVolumeId;
     long totalEntries[MAXTYPES];
};

typedef long longarray[MAXTYPES];

struct vlheader {
    struct vital_vlheader vital_header;
    u_long IpMappedAddr[MAXSERVERID];
    long VolnameHash[HASHSIZE];
/*    long VolidHashRW[HASHSIZE];
    long VolidHashRO[HASHSIZE];
    long VolidHashBACK[HASHSIZE];*/
    longarray VolidHash[HASHSIZE];
};


const VLUPDATE_VOLUMENAME 	= 0x1;
const VLUPDATE_FLAGS		= 0x4;
const VLUPDATE_READONLYID	= 0x8;
const VLUPDATE_BACKUPID		= 0x10;
const VLUPDATE_REPSITES		= 0x20;
const VLUPDATE_CLONEID		= 0x80;
const VLUPDATE_VOLNAMEHASH	= 0x100;
const VLUPDATE_RWID		= 0x200;

const VLUPDATE_REPS_DELETE	= 0x100;
const VLUPDATE_REPS_ADD		= 0x200;
const VLUPDATE_REPS_MODSERV	= 0x400;
const VLUPDATE_REPS_MODPART	= 0x800;
const VLUPDATE_REPS_MODFLAG	= 0x1000;

struct VldbUpdateEntry {
     u_long Mask;
     char name[VLDB_MAXNAMELEN];
     long volumeType;
     long flags;
     u_long ReadOnlyId;
     u_long BackupId;
     long cloneid;
     long nModifiedRepsites;
     u_long RepsitesMask[MAXNSERVERS];
     long RepsitesTargetServer[MAXNSERVERS];
     long RepsitesTargetPart[MAXNSERVERS];
     long RepsitesNewServer[MAXNSERVERS];
     long RepsitesNewPart[MAXNSERVERS];
     long RepsitesNewFlags[MAXNSERVERS];
};

/* bit mask for VldbListByAttributes.Mask */
const	VLLIST_SERVER		= 0x1;
const	VLLIST_PARTITION	= 0x2;
/* 0x4 was VLLIST_VOLUMETYPE but now it seems to be depricated */
const	VLLIST_VOLUMEID		= 0x8;
const	VLLIST_FLAG		= 0x10;

struct VldbListByAttributes {
     u_long Mask;
     long server;
     long partition;
     long volumetype; /* depricated */
     long volumeid;
     long flag;
};

struct uvldbentry {
     char name[VLDB_MAXNAMELEN];
     long nServers;
     afsUUID serverNumber[NMAXNSERVERS];
     long serverUnique[NMAXNSERVERS];
     long serverPartition[NMAXNSERVERS];
     long serverFlags[NMAXNSERVERS];
     u_long volumeId[MAXTYPES];
     long cloneId;
     long flags;
     long spares1;
     long spares2;
     long spares3;
     long spares4;
     long spares5;
     long spares6;
     long spares7;
     long spares8;
     long spares9;
};


#if 0
struct single_vldbentry {
     vldbentry VldbEntry;
     vldblist next_vldb;
};

struct vldb_list {
     vldblist node;
};
#endif

struct vldstats {
     unsigned long start_time;
     long requests[MAX_NUMBER_OPCODES];
     long aborts[MAX_NUMBER_OPCODES];
     long reserved[5];
};

const VL_MAX_BULK_ADDRS		= 1024 ;

typedef vldbentry bulkentries<>;
typedef nvldbentry nbulkentries<>;
typedef uvldbentry ubulkentries<>;
typedef int32_t bulkaddrs<VL_MAX_BULK_ADDRS>;


/* 
 * Bits for ListAddrByAttributes.Mask
 * Note, IPADDR/INDEX/UUID are mutually exclusive
 */

const VLADDR_IPADDR = 0x1;
const VLADDR_INDEX  = 0x2;
const VLADDR_UUID   = 0x4;

struct ListAddrByAttributes {
    int32_t Mask;
    uint32_t ipaddr;
    int32_t index;
    int32_t spare;
    afsUUID uuid;
};

struct VL_Callback {
    uint32_t version;
    uint32_t expiration_time;
    uint32_t time;
    uint32_t handle;
};

/*
 * Interface
 */

CreateEntry (IN vldbentry *newentry) = VLCREATEENTRY;

DeleteEntry (IN long Volid,
	     IN long voltype) = VLDELETEENTRY;

GetEntryByID (IN long Volid,
	      IN long voltype,
	      OUT vldbentry *entry) = VLGETENTRYBYID;

GetEntryByName (IN string volumename<VLDB_MAXNAMELEN>,
		OUT vldbentry *entry) = VLGETENTRYBYNAME;

GetNewVolumeId (IN long bumpcount,
		OUT long *newvolumid) = VLGETNEWVOLUMEID;

ReplaceEntry (IN long Volid,
	      IN long voltype,
	      IN vldbentry *newentry,
	      IN long ReleaseType) = VLREPLACEENTRY;

UpdateEntry (IN long Volid,
	     IN long voltype,
	     IN VldbUpdateEntry *UpdateEntry,
	     IN long ReleaseType) = VLUPDATEENTRY;

SetLock (IN long Volid,
	 IN long voltype,
	 IN long voloper) = VLSETLOCK;

ReleaseLock (IN long volid,
	     IN long voltype,
	     IN long ReleaseType) = VLRELEASELOCK;

ListEntry (IN long previous_index,
	   OUT long *count,
	   OUT long *next_index,
	   OUT vldbentry *entry) = VLLISTENTRY;

ListAttributes (IN VldbListByAttributes *attributes,
		OUT long *nentries,
		OUT bulkentries *blkentries) = VLLISTATTRIBUTES;

#if 0
LinkedList (IN VldbListByAttributes *attributes,
	    OUT long *nentries,
	    OUT vldb_list *linkedentries) = 512;
#endif

GetStats (OUT vldstats *stats,
	  OUT vital_vlheader *vital_header) = VLGETSTATS;

Probe () = VLPROBE;

GetAddrs(IN int32_t handle,
	 IN int32_t spare,
	 OUT VL_Callback *spare3,
	 OUT int32_t *nentries,
	 OUT bulkaddrs *blkaddr) = VLGETADDRS;

ChangeAddrs(IN int32_t old_ip,
	    IN int32_t new_ip) = VLCHANGEADDR;		/* obsolete */

CreateEntryN(IN nvldbentry *newentry) = VLCREATEENTRYN;

GetEntryByIDN (IN long Volid,
	       IN long voltype,
	       OUT nvldbentry *entry) = VLGETENTRYBYIDN;

GetEntryByNameN (IN string volumename<VLDB_MAXNAMELEN>,
		 OUT nvldbentry *entry) = VLGETENTRYBYNAMEN;

ReplaceEntryN (IN long Volid,
	      IN long voltype,
	      IN nvldbentry *newentry,
	      IN long ReleaseType) = VLREPLACEENTRYN;

ListEntryN(IN afs_int32 previous_index,
	   OUT afs_int32 *count,
	   OUT afs_int32 *next_index,
	   OUT nvldbentry *entry) = VLLISTENTRYN;

ListAttributesN (IN VldbListByAttributes *attributes,
		OUT long *nentries,
		OUT nbulkentries *blkentries) = VLLISTATTRIBUTESN;

#if 0
LinkedListN() = 523;
#endif

UpdateEntryByName (IN string volname<VLDB_MAXNAMELEN>,
	     IN VldbUpdateEntry *UpdateEntry,
	     IN long ReleaseType) = VLUPDATEENTRYBYNAME;

#ifdef not_implemented_yet
CreateEntryU(IN uvldbentry *newentry) = VLCREATEENTRYU;

GetEntryByIDU() = VLGETENTRYBYIDU;

GetEntryByNameU (IN string volumename<VLDB_MAXNAMELEN>,
		 OUT struct uvldbentry *entry) = VLGETENTRYBYNAMEU;

ReplaceEntryU() = VLREPLACEENTRYU;

ListEntryU() = VLLISTENTRYU;

ListAttributesU (IN VldbListByAttributes *attributes,
		OUT long *nentries,
		OUT ubulkentries *blkentries) = VLLISTATTRIBUTESU;

LinkedListU() = VLLINKEDLISTU;
#endif

GetAddrsU(IN ListAddrByAttributes *inaddr,
	  OUT afsUUID *uuidp1,
	  OUT afs_int32 *uniquifier,
	  OUT afs_int32 *nentries,
	  OUT bulkaddrs *blkaddrs) = VLGETADDRSU;


RegisterAddrs(IN afsUUID *uid,
	      IN int32_t spare,
	      IN bulkaddrs *addrs) = VLREGADDR;


ListAttributesN2(IN VldbListByAttributes *attributes,
		 IN string volumename<VLDB_MAXNAMELEN>,
		 IN  afs_int32 startindex,
		 OUT afs_int32 *nentries,
		 OUT nbulkentries *blkentries,
		 OUT afs_int32 *nextstartindex) = VLLISTATTRIBUTESN2;

#if 0

/*
 *
 */

const	VL_LISTATTRUUID_MAXATTR		= 64;
const	VL_LISTATTRUUID_MAXATTRSIZE	= 512;

struct VL_ListAddrUUID {
    afs_int32 type;
    afs_int32 error;
    opaque data<VL_LISTATTRUUID_MAXATTRSIZE>;
};
    
typedef VL_ListAddrUUID VL_ListAddrUUIDs<>;

const VL_UUID_data_INVALID = 1;

const VL_UUID_data_IPV6	= 1;
struct VL_UUID_data {
    opaque ipv6_addr<128>;
    int ipv6_mtu;
};

const VL_UUID_data_GSSAPI_name	= 2;
struct VL_UUID_data_gss_name {
    opaque gss_name<>;
};

/*
 * `uuid' is the uuid we query information the diffrent types are in
 * `query'. 
 * 
 * For each `query'-item there can be one or more items in `reply'.
 * The reply items have `reply<>.type' set to the same type as in the
 * query. The are always sorted in the same order as the `query'.
 * 
 * If the `query' type isn't supported a `reply<>' is sent back with
 * `reply<>.error' set.
 *
 * The `reply<>.data' is filled with `reply<>.type' specific data.
 * XXX should we use union, I don't think so.
 */

ListAttrUUID(IN afsUUID *uuid,
	     IN afs_int32 query<VL_LISTATTRUUID_MAXATTR>,
	     OUT VL_ListAddrUUIDs *reply) = 10001;

#endif
@


1.5
log
@Merge
@
text
@@


1.4
log
@merge
@
text
@a8 2
%#include <config.h>
%#include <roken.h>
d10 1
a34 10
const VLLIST_SERVER     = 0x1;
const VLLIST_PARTITION  = 0x2;
const VLLIST_VOLUMETYPE = 0x4;
const VLLIST_VOLUMEID   = 0x8;
const VLLIST_FLAG       = 0x10;

const RWVOL   = 0;
const ROVOL   = 1;
const BACKVOL = 2;

d37 1
a37 1
 * ie for each server
d40 6
a45 6
const VLSF_NEWREPSITE = 0x01;
const VLSF_ROVOL      = 0x02;
const VLSF_RWVOL      = 0x04;
const VLSF_BACKVOL    = 0x08;
const VLSF_UUID	      = 0x10;
const VLSF_DONTUSE    = 0x20;
d52 15
d73 1
d102 5
d109 1
a109 1
 * States for struct vlentry
d111 35
a145 8
const VLFREE           = 0x1;
const VLDELETED        = 0x2;
const VLLOCKED         = 0x4;
const VLOP_MOVE        = 0x10;
const VLOP_RELEASE     = 0x20;
const VLOP_BACKUP      = 0x40;
const VLOP_DELETE      = 0x80;
const VLOP_DUMP        = 0x100;
d156 1
a156 1
     long volumeType;		/* spares */
d175 1
a175 1
    long spares1;
d205 2
a209 2
    long LockAfsId;
    long LockTimestamp;
d211 4
a214 11
    long AssociatedChain;
    long nextIdHash[MAXTYPES];
    long nextNameHash;
    long spares1[2];
    char name[VLDB_MAXNAMELEN];
    u_char volumeType;
    long serverNumber[MAXNSERVERS];
    u_char serverPartition[MAXNSERVERS];
    u_char serverFlags[MAXNSERVERS];
    u_char RefCount;
    char spares2[1];
d273 7
d284 1
a284 1
     long volumetype;
d329 2
d334 2
d337 4
a340 1
/* Mask-flags for ListAddrByAttributes */
d347 2
a348 2
    int32_t mask;
    u_int32_t ipaddr;
a353 2
typedef int32_t bulkaddrs<>;

d355 4
a358 4
    u_int32_t version;
    u_int32_t expiration_time;
    u_int32_t time;
    u_int32_t handle;
d365 1
a365 1
CreateEntry (IN vldbentry *newentry) = 501;
d368 1
a368 1
	     IN long voltype) = 502;
d372 1
a372 1
	      OUT vldbentry *entry) = 503;
d375 1
a375 1
		OUT vldbentry *entry) = 504;
d378 1
a378 1
		OUT long *newvolumid) = 505;
d383 1
a383 1
	      IN long ReleaseType) = 506;
d388 1
a388 1
	     IN long ReleaseType) = 507;
d392 1
a392 1
	 IN long voloper) = 508;
d396 1
a396 1
	     IN long ReleaseType) = 509;
d401 1
a401 1
	   OUT vldbentry *entry) = 510;
d405 1
a405 1
		OUT bulkentries *blkentries) = 511;
d414 1
a414 1
	  OUT vital_vlheader *vital_header) = 513;
d416 1
a416 1
Probe () = 514;
d421 2
a422 2
	 IN int32_t *nentries,
	 OUT bulkaddrs *blkaddr) = 515;
d425 1
a425 1
	    IN int32_t new_ip) = 516;		/* obsolete */
d427 1
a427 1
CreateEntryN(IN nvldbentry *newentry) = 517;
d431 1
a431 1
	       OUT nvldbentry *entry) = 518;
d434 1
a434 1
		 OUT nvldbentry *entry) = 519;
d439 1
a439 1
	      IN long ReleaseType) = 520;
d441 4
a444 1
ListEntryN() = 521;
d448 1
a448 1
		OUT nbulkentries *blkentries) = 522;
d450 1
d452 1
d456 1
a456 1
	     IN long ReleaseType) = 524;
d458 2
a459 1
CreateEntryU(IN uvldbentry *newentry) = 525;
d461 1
a461 1
GetEntryByIDU() = 526;
d464 1
a464 1
		 OUT struct uvldbentry *entry) = 527;
d466 1
a466 1
ReplaceEntryU() = 528;
d468 1
a468 1
ListEntryU() = 529;
d472 10
a481 1
		OUT ubulkentries *blkentries) = 530;
a482 1
LinkedListU() = 531;
d486 15
a500 1
	      IN bulkaddrs *addrs) = 532;
d502 44
a545 5
GetAddrsU(IN ListAddrByAttributes *inaddr,
	  OUT afsUUID *uuid,
	  OUT int32_t *uniq,
	  OUT int32_t *nentries,
	  OUT bulkaddrs *addrs) = 533;
@


1.3
log
@New Arla userland from Arla between 0.34.2 and current in arla cvs.
Too many new features and fixes to mention here.
@
text
@d396 1
a396 1
	      IN vldbentry *newentry,
@


1.2
log
@upgrade Arla to fresher code. Too many new features and bugfixes.
@
text
@d15 2
d46 5
d55 7
d98 18
d211 15
a251 9
struct afsUUID {
     u_long time_low;
     u_short time_mid;
     u_short time_hi_and_version;
     char clock_seq_hi_and_reserved;
     char clock_seq_low;
     char node[6];
};

d296 6
a308 4

const VLADDR_IPADDR = 0x1;
const VLADDR_INDEX  = 0x2;
const VLADDR_UUID   = 0x4;
@


1.1
log
@Initial revision
@
text
@d9 5
a13 3
%#include <atypes.h>
%#include <rx/rx.h>
%#include <rx/rx_null.h>
d19 8
a26 14
const VLDB_MAXNAMELEN=65;

const MAXNSERVERS=8;
const NMAXNSERVERS=13;

const MAX_NUMBER_OPCODES=30;

const MAXTYPES=3;

const MAXSERVERID=30;

const HASHSIZE=8191;

const DEFAULTBULK=10000;
d34 6
d53 1
d87 1
a87 1
     long volumeType;
d98 36
a133 17
        char name[VLDB_MAXNAMELEN];
        long nServers;
        long serverNumber[NMAXNSERVERS];
        long serverPartition[NMAXNSERVERS];
        long serverFlags[NMAXNSERVERS];
        u_long volumeId[MAXTYPES];
        long cloneId;
        long flags;
        long spares1;
        long spares2;
        long spares3;
        long spares4;
        long spares5;
        long spares6;
        long spares7;
        long spares8;
        long spares9;
d136 18
d158 1
a158 1
     long feePtr;
d166 13
d255 23
d336 5
a340 2
GetEntryByNameN(IN string volumename<VLDB_MAXNAMELEN>,
		OUT nvldbentry *entry) = 519;
d342 32
d377 20
@


1.1.1.1
log
@Initial version of Arla, a free implementation of an AFS cache-manager.
(second try, hopefully into the correct repository this time)
@
text
@@


1.1.1.2
log
@Import of arla-0.35.7
@
text
@d9 3
a11 7
%#include <config.h>
%#include <roken.h>
%#include <fs_errors.h>

error-function conv_to_arla_errno

#include "common.h"
d17 14
a30 8
const VLDB_MAXNAMELEN		= 65;
const MAXNSERVERS		= 8;
const NMAXNSERVERS		= 13;
const MAX_NUMBER_OPCODES	= 30;
const MAXTYPES			= 3;
const MAXSERVERID		= 30;
const HASHSIZE			= 8191;
const DEFAULTBULK		= 10000;
a37 6
const VLLIST_SERVER     = 0x1;
const VLLIST_PARTITION  = 0x2;
const VLLIST_VOLUMETYPE = 0x4;
const VLLIST_VOLUMEID   = 0x8;
const VLLIST_FLAG       = 0x10;

a41 5
/*
 * Used in vlentry.server[i].flags
 * ie for each server
 */

a45 7
const VLSF_UUID	      = 0x10;
const VLSF_DONTUSE    = 0x20;

/*
 * Used in vlentry.flags
 * ie used for whole entry
 */
a50 1
const VLF_DFSFILESET  = 0x8000;
a80 18
/*
 * States for struct vlentry
 */
const VLFREE           = 0x1;
const VLDELETED        = 0x2;
const VLLOCKED         = 0x4;
const VLOP_MOVE        = 0x10;
const VLOP_RELEASE     = 0x20;
const VLOP_BACKUP      = 0x40;
const VLOP_DELETE      = 0x80;
const VLOP_DUMP        = 0x100;

/*
 * ReleaseType argument for VL_ReleaseLock
 */
const LOCKREL_TIMESTAMP = 1;
const LOCKREL_OPCODE    = 2;
const LOCKREL_AFSID     = 4;
d84 1
a84 1
     long volumeType;		/* spares */
d95 17
a111 17
    char name[VLDB_MAXNAMELEN];
    long nServers;
    long serverNumber[NMAXNSERVERS];
    long serverPartition[NMAXNSERVERS];
    long serverFlags[NMAXNSERVERS];
    u_long volumeId[MAXTYPES];
    long cloneId;
    long flags;
    long spares1;
    long spares2;
    long spares3;
    long spares4;
    long spares5;
    long spares6;
    long spares7;
    long spares8;
    long spares9;
a113 37
struct vlentry {
    u_long volumeId[MAXTYPES];
    long flags;
    long LockAfsId;
    long LockTimestamp;
    long cloneId;
    long AssociatedChain;
    long nextIdHash[MAXTYPES];
    long nextNameHash;
    long spares1[2];
    char name[VLDB_MAXNAMELEN];
    u_char volumeType;
    u_char serverNumber[MAXNSERVERS];
    u_char serverPartition[MAXNSERVERS];
    u_char serverFlags[MAXNSERVERS];
    u_char RefCount;
    char spares2[1];
};

struct disk_vlentry {
    u_long volumeId[MAXTYPES];
    long flags;
    long LockAfsId;
    long LockTimestamp;
    long cloneId;
    long AssociatedChain;
    long nextIdHash[MAXTYPES];
    long nextNameHash;
    long spares1[2];
    char name[VLDB_MAXNAMELEN];
    u_char volumeType;
    long serverNumber[MAXNSERVERS];
    u_char serverPartition[MAXNSERVERS];
    u_char serverFlags[MAXNSERVERS];
    u_char RefCount;
    char spares2[1];
};
d118 1
a118 1
     long freePtr;
a125 28
typedef long longarray[MAXTYPES];

struct vlheader {
    struct vital_vlheader vital_header;
    u_long IpMappedAddr[MAXSERVERID];
    long VolnameHash[HASHSIZE];
/*    long VolidHashRW[HASHSIZE];
    long VolidHashRO[HASHSIZE];
    long VolidHashBACK[HASHSIZE];*/
    longarray VolidHash[HASHSIZE];
};


const VLUPDATE_VOLUMENAME 	= 0x1;
const VLUPDATE_FLAGS		= 0x4;
const VLUPDATE_READONLYID	= 0x8;
const VLUPDATE_BACKUPID		= 0x10;
const VLUPDATE_REPSITES		= 0x20;
const VLUPDATE_CLONEID		= 0x80;
const VLUPDATE_VOLNAMEHASH	= 0x100;
const VLUPDATE_RWID		= 0x200;

const VLUPDATE_REPS_DELETE	= 0x100;
const VLUPDATE_REPS_ADD		= 0x200;
const VLUPDATE_REPS_MODSERV	= 0x400;
const VLUPDATE_REPS_MODPART	= 0x800;
const VLUPDATE_REPS_MODFLAG	= 0x1000;

d152 9
a201 25
typedef nvldbentry nbulkentries<>;
typedef uvldbentry ubulkentries<>;

/* Mask-flags for ListAddrByAttributes */

const VLADDR_IPADDR = 0x1;
const VLADDR_INDEX  = 0x2;
const VLADDR_UUID   = 0x4;

struct ListAddrByAttributes {
    int32_t mask;
    u_int32_t ipaddr;
    int32_t index;
    int32_t spare;
    afsUUID uuid;
};

typedef int32_t bulkaddrs<>;

struct VL_Callback {
    u_int32_t version;
    u_int32_t expiration_time;
    u_int32_t time;
    u_int32_t handle;
};
d260 2
a261 34
GetAddrs(IN int32_t handle,
	 IN int32_t spare,
	 OUT VL_Callback *spare3,
	 IN int32_t *nentries,
	 OUT bulkaddrs *blkaddr) = 515;

ChangeAddrs(IN int32_t old_ip,
	    IN int32_t new_ip) = 516;		/* obsolete */

CreateEntryN(IN nvldbentry *newentry) = 517;

GetEntryByIDN (IN long Volid,
	       IN long voltype,
	       OUT nvldbentry *entry) = 518;

GetEntryByNameN (IN string volumename<VLDB_MAXNAMELEN>,
		 OUT nvldbentry *entry) = 519;

ReplaceEntryN (IN long Volid,
	      IN long voltype,
	      IN nvldbentry *newentry,
	      IN long ReleaseType) = 520;

ListEntryN() = 521;

ListAttributesN (IN VldbListByAttributes *attributes,
		OUT long *nentries,
		OUT nbulkentries *blkentries) = 522;

LinkedListN() = 523;

UpdateEntryByName (IN string volname<VLDB_MAXNAMELEN>,
	     IN VldbUpdateEntry *UpdateEntry,
	     IN long ReleaseType) = 524;
a262 3
CreateEntryU(IN uvldbentry *newentry) = 525;

GetEntryByIDU() = 526;
a265 20

ReplaceEntryU() = 528;

ListEntryU() = 529;

ListAttributesU (IN VldbListByAttributes *attributes,
		OUT long *nentries,
		OUT ubulkentries *blkentries) = 530;

LinkedListU() = 531;

RegisterAddrs(IN afsUUID *uid,
	      IN int32_t spare,
	      IN bulkaddrs *addrs) = 532;

GetAddrsU(IN ListAddrByAttributes *inaddr,
	  OUT afsUUID *uuid,
	  OUT int32_t *uniq,
	  OUT int32_t *nentries,
	  OUT bulkaddrs *addrs) = 533;
@


1.1.1.3
log
@Import of arla -current as of Aug 5 2003

ok todd@@ deraadt@@
@
text
@d9 2
a11 1
%#include <fs.h>
d36 10
d48 1
a48 1
 * ie for each site/server
d51 6
a56 6
const VLSF_NEWREPSITE = 0x01;	/* ??? */
const VLSF_ROVOL      = 0x02;	/* Readonly volume on this site */
const VLSF_RWVOL      = 0x04;	/* Readwrite volume on this site */
const VLSF_BACKVOL    = 0x08;	/* Backup volume on this site */
const VLSF_UUID	      = 0x10;	/* Internal flag in Transarc client */
const VLSF_DONTUSE    = 0x20;	/* Not yet released volumes */
a62 15
/* Internal information in the vldb */
const VLFREE           = 0x1;
const VLDELETED        = 0x2;
const VLLOCKED         = 0x4;

/* Volser information/status */
const VLOP_MOVE		= 0x10;
const VLOP_RELEASE	= 0x20;
const VLOP_BACKUP	= 0x40;
const VLOP_DELETE	= 0x80;
const VLOP_DUMP		= 0x100;

%#define VLOP_ALLOPERS ( VLOP_MOVE | VLOP_RELEASE | VLOP_BACKUP | VLOP_DELETE | VLOP_DUMP)

/* Location  information */
a68 1
/* VL error interface */
a96 5
const VL_BADVERSION    = 363548;
const VL_INDEXERANGE   = 363549;
const VL_MULTIPADDR    = 363550;
const VL_BADMASK       = 363551;

d99 1
a99 1
 * Opcodes
d101 8
a108 35

const VLCREATEENTRY		= 501;
const VLDELETEENTRY		= 502;
const VLGETENTRYBYID		= 503;
const VLGETENTRYBYNAME		= 504;
const VLGETNEWVOLUMEID		= 505;
const VLREPLACEENTRY		= 506;
const VLUPDATEENTRY		= 507;
const VLSETLOCK			= 508;
const VLRELEASELOCK		= 509;
const VLLISTENTRY		= 510;
const VLLISTATTRIBUTES	 	= 511;
const VLLINKEDLIST		= 512;
const VLGETSTATS		= 513;
const VLPROBE			= 514;
const VLGETADDRS		= 515;
const VLCHANGEADDR		= 516;
const VLCREATEENTRYN		= 517;
const VLGETENTRYBYIDN		= 518;
const VLGETENTRYBYNAMEN	 	= 519;
const VLREPLACEENTRYN		= 520;
const VLLISTENTRYN		= 521;
const VLLISTATTRIBUTESN		= 522;
const VLLINKEDLISTN		= 523;
const VLUPDATEENTRYBYNAME	= 524;
const VLCREATEENTRYU		= 525;
const VLGETENTRYBYIDU		= 526;
const VLGETENTRYBYNAMEU		= 527;
const VLREPLACEENTRYU		= 528;
const VLLISTENTRYU		= 529;
const VLLISTATTRIBUTESU		= 530;
const VLLINKEDLISTU		= 531;
const VLREGADDR			= 532;
const VLGETADDRSU		= 533;
const VLLISTATTRIBUTESN2	= 534;
d119 1
a119 1
     long volumeType;		/* currrent unused */
d138 1
a138 1
    long matchindex;
a167 2
/* disk_vlentry is arla specific */

d171 2
d174 11
a184 4
    string name<>;
    long serverNumber<>;
    long serverPartition<>;
    long serverFlags<>;
a242 7
/* bit mask for VldbListByAttributes.Mask */
const	VLLIST_SERVER		= 0x1;
const	VLLIST_PARTITION	= 0x2;
/* 0x4 was VLLIST_VOLUMETYPE but now it seems to be depricated */
const	VLLIST_VOLUMEID		= 0x8;
const	VLLIST_FLAG		= 0x10;

d247 1
a247 1
     long volumetype; /* depricated */
a291 2
const VL_MAX_BULK_ADDRS		= 1024 ;

a294 2
typedef int32_t bulkaddrs<VL_MAX_BULK_ADDRS>;

d296 1
a296 4
/* 
 * Bits for ListAddrByAttributes.Mask
 * Note, IPADDR/INDEX/UUID are mutually exclusive
 */
d303 2
a304 2
    int32_t Mask;
    uint32_t ipaddr;
d310 2
d313 4
a316 4
    uint32_t version;
    uint32_t expiration_time;
    uint32_t time;
    uint32_t handle;
d323 1
a323 1
CreateEntry (IN vldbentry *newentry) = VLCREATEENTRY;
d326 1
a326 1
	     IN long voltype) = VLDELETEENTRY;
d330 1
a330 1
	      OUT vldbentry *entry) = VLGETENTRYBYID;
d333 1
a333 1
		OUT vldbentry *entry) = VLGETENTRYBYNAME;
d336 1
a336 1
		OUT long *newvolumid) = VLGETNEWVOLUMEID;
d341 1
a341 1
	      IN long ReleaseType) = VLREPLACEENTRY;
d346 1
a346 1
	     IN long ReleaseType) = VLUPDATEENTRY;
d350 1
a350 1
	 IN long voloper) = VLSETLOCK;
d354 1
a354 1
	     IN long ReleaseType) = VLRELEASELOCK;
d359 1
a359 1
	   OUT vldbentry *entry) = VLLISTENTRY;
d363 1
a363 1
		OUT bulkentries *blkentries) = VLLISTATTRIBUTES;
d372 1
a372 1
	  OUT vital_vlheader *vital_header) = VLGETSTATS;
d374 1
a374 1
Probe () = VLPROBE;
d379 2
a380 2
	 OUT int32_t *nentries,
	 OUT bulkaddrs *blkaddr) = VLGETADDRS;
d383 1
a383 1
	    IN int32_t new_ip) = VLCHANGEADDR;		/* obsolete */
d385 1
a385 1
CreateEntryN(IN nvldbentry *newentry) = VLCREATEENTRYN;
d389 1
a389 1
	       OUT nvldbentry *entry) = VLGETENTRYBYIDN;
d392 1
a392 1
		 OUT nvldbentry *entry) = VLGETENTRYBYNAMEN;
d397 1
a397 1
	      IN long ReleaseType) = VLREPLACEENTRYN;
d399 1
a399 4
ListEntryN(IN afs_int32 previous_index,
	   OUT afs_int32 *count,
	   OUT afs_int32 *next_index,
	   OUT nvldbentry *entry) = VLLISTENTRYN;
d403 1
a403 1
		OUT nbulkentries *blkentries) = VLLISTATTRIBUTESN;
a404 1
#if 0
a405 1
#endif
d409 1
a409 1
	     IN long ReleaseType) = VLUPDATEENTRYBYNAME;
d411 1
a411 2
#ifdef not_implemented_yet
CreateEntryU(IN uvldbentry *newentry) = VLCREATEENTRYU;
d413 1
a413 1
GetEntryByIDU() = VLGETENTRYBYIDU;
d416 1
a416 1
		 OUT struct uvldbentry *entry) = VLGETENTRYBYNAMEU;
d418 1
a418 1
ReplaceEntryU() = VLREPLACEENTRYU;
d420 1
a420 1
ListEntryU() = VLLISTENTRYU;
d424 1
a424 10
		OUT ubulkentries *blkentries) = VLLISTATTRIBUTESU;

LinkedListU() = VLLINKEDLISTU;
#endif

GetAddrsU(IN ListAddrByAttributes *inaddr,
	  OUT afsUUID *uuidp1,
	  OUT afs_int32 *uniquifier,
	  OUT afs_int32 *nentries,
	  OUT bulkaddrs *blkaddrs) = VLGETADDRSU;
d426 1
d430 1
a430 1
	      IN bulkaddrs *addrs) = VLREGADDR;
d432 5
a436 58

ListAttributesN2(IN VldbListByAttributes *attributes,
		 IN string volumename<VLDB_MAXNAMELEN>,
		 IN  afs_int32 startindex,
		 OUT afs_int32 *nentries,
		 OUT nbulkentries *blkentries,
		 OUT afs_int32 *nextstartindex) = VLLISTATTRIBUTESN2;

#if 0

/*
 *
 */

const	VL_LISTATTRUUID_MAXATTR		= 64;
const	VL_LISTATTRUUID_MAXATTRSIZE	= 512;

struct VL_ListAddrUUID {
    afs_int32 type;
    afs_int32 error;
    opaque data<VL_LISTATTRUUID_MAXATTRSIZE>;
};
    
typedef VL_ListAddrUUID VL_ListAddrUUIDs<>;

const VL_UUID_data_INVALID = 1;

const VL_UUID_data_IPV6	= 1;
struct VL_UUID_data {
    opaque ipv6_addr<128>;
    int ipv6_mtu;
};

const VL_UUID_data_GSSAPI_name	= 2;
struct VL_UUID_data_gss_name {
    opaque gss_name<>;
};

/*
 * `uuid' is the uuid we query information the diffrent types are in
 * `query'. 
 * 
 * For each `query'-item there can be one or more items in `reply'.
 * The reply items have `reply<>.type' set to the same type as in the
 * query. The are always sorted in the same order as the `query'.
 * 
 * If the `query' type isn't supported a `reply<>' is sent back with
 * `reply<>.error' set.
 *
 * The `reply<>.data' is filled with `reply<>.type' specific data.
 * XXX should we use union, I don't think so.
 */

ListAttrUUID(IN afsUUID *uuid,
	     IN afs_int32 query<VL_LISTATTRUUID_MAXATTR>,
	     OUT VL_ListAddrUUIDs *reply) = 10001;

#endif
@


