head	1.9;
access;
symbols
	OPENBSD_5_2:1.8.0.26
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.8
	OPENBSD_5_1:1.8.0.24
	OPENBSD_5_0:1.8.0.22
	OPENBSD_5_0_BASE:1.8
	OPENBSD_4_9:1.8.0.20
	OPENBSD_4_9_BASE:1.8
	OPENBSD_4_8:1.8.0.18
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_7:1.8.0.14
	OPENBSD_4_7_BASE:1.8
	OPENBSD_4_6:1.8.0.16
	OPENBSD_4_6_BASE:1.8
	OPENBSD_4_5:1.8.0.12
	OPENBSD_4_5_BASE:1.8
	OPENBSD_4_4:1.8.0.10
	OPENBSD_4_4_BASE:1.8
	OPENBSD_4_3:1.8.0.8
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.8.0.6
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.8.0.4
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.8.0.2
	OPENBSD_4_0_BASE:1.8
	OPENBSD_3_9:1.7.0.10
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.7.0.8
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.6
	OPENBSD_3_7_BASE:1.7
	OPENBSD_3_6:1.7.0.4
	OPENBSD_3_6_BASE:1.7
	OPENBSD_3_5:1.7.0.2
	OPENBSD_3_5_BASE:1.7
	OPENBSD_3_4:1.5.0.2
	OPENBSD_3_4_BASE:1.5
	arla-20030805:1.1.1.3
	OPENBSD_3_3:1.4.0.4
	OPENBSD_3_3_BASE:1.4
	OPENBSD_3_2:1.4.0.2
	OPENBSD_3_2_BASE:1.4
	arla-0-35-7:1.1.1.2
	OPENBSD_3_1:1.3.0.8
	OPENBSD_3_1_BASE:1.3
	OPENBSD_3_0:1.3.0.6
	OPENBSD_3_0_BASE:1.3
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_9:1.3.0.4
	OPENBSD_2_8:1.3.0.2
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.2.0.4
	OPENBSD_2_7_BASE:1.2
	OPENBSD_2_6:1.2.0.2
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.1.1.1.0.4
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.2
	OPENBSD_2_4_BASE:1.1.1.1
	arla-0_9:1.1.1.1
	arla:1.1.1;
locks; strict;
comment	@ * @;


1.9
date	2012.08.23.06.21.50;	author deraadt;	state dead;
branches;
next	1.8;

1.8
date	2006.04.02.21.38.56;	author djm;	state Exp;
branches;
next	1.7;

1.7
date	2004.02.27.23.58.54;	author biorn;	state Exp;
branches;
next	1.6;

1.6
date	2004.02.27.19.17.36;	author beck;	state Exp;
branches;
next	1.5;

1.5
date	2003.08.05.08.42.41;	author hin;	state Exp;
branches;
next	1.4;

1.4
date	2002.06.07.04.28.57;	author hin;	state Exp;
branches;
next	1.3;

1.3
date	2000.09.11.14.40.43;	author art;	state Exp;
branches;
next	1.2;

1.2
date	99.04.30.01.59.10;	author art;	state Exp;
branches;
next	1.1;

1.1
date	98.09.14.21.52.57;	author art;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.09.14.21.52.57;	author art;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.06.07.04.14.25;	author hin;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2003.08.05.08.21.01;	author hin;	state Exp;
branches;
next	;


desc
@@


1.9
log
@the afs src tree can go away
@
text
@/*
 * Copyright (c) 1995 - 2002 Kungliga Tekniska Högskolan
 * (Royal Institute of Technology, Stockholm, Sweden).
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * Manage our cache of volume information.
 */

#include "arla_local.h"
RCSID("$arla: volcache.c,v 1.116 2003/04/10 15:49:13 lha Exp $") ;

static int volcache_timeout = VOLCACHE_TIMEOUT;

static const char *root_volume_name = "root.afs";

/*
 * Return the root volume name.
 */

const char *
volcache_get_rootvolume (void)
{
    return root_volume_name;
}

/*
 * Set the current root volume name.
 */

void
volcache_set_rootvolume (const char *volname)
{
    assert (volname != NULL);

    root_volume_name = volname;
}

#define VOLCACHE_SIZE	2053
#define VOLCACHE_INC	300

/* Hashtable of entries by name */
static Hashtab *volnamehashtab;

/* Hashtable of entries by number */
static Hashtab *volidhashtab;

/* A list with all entries */
static List *lrulist;

/* # of entries */
static unsigned nvolcacheentries = 0;

/* # of active entries */
static unsigned nactive_volcacheentries = 0;

/*
 * VolCacheEntries are indexed by (name, cell) in volnamehashtab
 */

static int
volnamecmp (void *a, void *b)
{
    struct name_ptr *n1 = (struct name_ptr *)a;
    struct name_ptr *n2 = (struct name_ptr *)b;

    return strcmp (n1->name, n2->name)
	|| n1->cell != n2->cell;
}

static unsigned
volnamehash (void *a)
{
     struct name_ptr *n = (struct name_ptr *)a;

     return hashadd (n->name) + n->cell;
}

/*
 * and by (volid, cell) in volidhashtab
 */

static int
volidcmp (void *a, void *b)
{
    struct num_ptr *n1 = (struct num_ptr *)a;
    struct num_ptr *n2 = (struct num_ptr *)b;

    return n1->cell != n2->cell || n1->vol != n2->vol;
}

static unsigned
volidhash (void *a)
{
    struct num_ptr *n = (struct num_ptr *)a;

    return n->cell + n->vol;
}

/*
 * Compare two `nvldbentry' and return 0 if they are equal.
 */

static int
cmp_nvldbentry (const nvldbentry *n1, const nvldbentry *n2)
{
    int i;

    if (strcmp (n1->name, n2->name) != 0)
	return 1;
    if (n1->nServers != n2->nServers)
	return 1;
    for (i = 0; i < n1->nServers; ++i)
	if (n1->serverNumber[i] != n2->serverNumber[i]
	    || n1->serverPartition[i] != n2->serverPartition[i]
	    || n1->serverFlags[i] != n2->serverFlags[i])
	    return 1;
    if (n1->flags != n2->flags)
	return 1;
    if (n1->flags & VLF_RWEXISTS
	&& n1->volumeId[RWVOL] != n2->volumeId[RWVOL])
	return 1;
    if (n1->flags & VLF_ROEXISTS
	&& n1->volumeId[ROVOL] != n2->volumeId[ROVOL])
	return 1;
    if (n1->flags & VLF_BOEXISTS
	&& n1->volumeId[BACKVOL] != n2->volumeId[BACKVOL])
	return 1;
    if (n1->cloneId != n2->cloneId)
	return 1;
    return 0;
}

/*
 * Do consistency checks and simple clean-ups.
 */

static void
sanitize_nvldbentry (nvldbentry *n)
{
    if (n->nServers > NMAXNSERVERS) {
	arla_warnx (ADEBVOLCACHE, "too many servers %d > %d",
		    n->nServers, NMAXNSERVERS);
	n->nServers = NMAXNSERVERS;
    }
}

/*
 * Create `n' entries and add at the end of `lrulist'
 */

static void
create_new_entries (unsigned n)
{
    VolCacheEntry *entries;
    int i;

    entries = calloc (n, sizeof(VolCacheEntry));
    if (entries == NULL)
	arla_errx (1, ADEBERROR, "volcache: calloc failed");

    for (i = 0; i < n; ++i) {
	entries[i].cell = -1;
	entries[i].li   = listaddtail (lrulist, &entries[i]);
    }
    
    nvolcacheentries += n;
}

/*
 * mark as not being in use
 */

static void
mark_unused (VolCacheEntry *e)
{
    if (e->refcount == 0 && e->vol_refs == 0) {
	listdel (lrulist, e->li);
	e->li = listaddtail (lrulist, e);
	assert (nactive_volcacheentries > 0);
	assert (nactive_volcacheentries <= nvolcacheentries);
	--nactive_volcacheentries;
    }
}

/*
 * Re-cycle an entry:
 * remove it from the hashtab, clear it out.
 */

static void
recycle_entry (VolCacheEntry *e)
{
    int i;

    assert (e->refcount == 0 && e->vol_refs == 0);

    for (i = 0; i < MAXTYPES; ++i)
	if (e->num_ptr[i].ptr != NULL)
	    hashtabdel (volidhashtab, &e->num_ptr[i]);
    if (e->name_ptr.ptr != NULL)
	hashtabdel (volnamehashtab, &e->name_ptr);
    if (e->parent) {
	volcache_volfree (e->parent);
	e->parent = NULL;
    }

    memset (&e->entry, 0, sizeof(e->entry));
    memset (&e->volsync, 0, sizeof(e->volsync));
    e->flags.validp  = FALSE;
    e->flags.stablep = FALSE;
    memset (&e->status, 0, sizeof(e->status));
    memset (&e->name_ptr, 0, sizeof(e->name_ptr));
    memset (&e->num_ptr, 0, sizeof(e->num_ptr));
}

/*
 * Get and return a free entry.
 * Place it at the head of the lrulist.
 */

static VolCacheEntry *
get_free_entry (void)
{
    Listitem *item;
    VolCacheEntry *e;

    assert (!listemptyp(lrulist));

    for(item = listtail (lrulist);
	item;
	item = listprev (lrulist, item)) {
	e = (VolCacheEntry *)listdata(item);
	if (e->refcount == 0 && e->vol_refs == 0) {
	    listdel (lrulist, item);
	    recycle_entry (e);
	    e->li = listaddhead (lrulist, e);
	    return e;
	}
    }

    create_new_entries (VOLCACHE_INC);

    e = (VolCacheEntry *)listdeltail (lrulist);
    assert (e != NULL && e->refcount == 0);
    e->li = listaddhead (lrulist, e);
    return e;
}

/*
 *
 */

static Bool
clones_exists (VolCacheEntry *e)
{
    int i;

    for (i = 0; i < MAXTYPES; ++i)
	if (e->num_ptr[i].ptr != NULL)
	    return TRUE;
    return FALSE;
}

/*
 *
 */

void
volcache_process_marks (VolCacheEntry *ve)
{
    int i, status, inval;

    inval = 0;

    for (i = 0; i < ve->entry.nServers; i++) {
	status = ve->status[i];
	if (status & (VOLCACHE_NOVOL|VOLCACHE_UNAVAILABLE)) {
	    /* already checked ? */
	    if (status & VOLCACHE_CHECKED)
		continue;
	    ve->status[i] |= VOLCACHE_CHECKED;
	    if (ve->flags.stablep)
		inval = 1;
	}
    }
    if (inval)
	volcache_invalidate_ve(ve);
}

/*
 *
 */

static void
volcache_remove_marks (VolCacheEntry *ve)
{
    int i;

    for (i = 0; i < NMAXNSERVERS; i++)
	ve->status[i] = 0;
}

/*
 *
 */

static Bool
volume_uptodatep (VolCacheEntry *e)
{
    if (connected_mode != CONNECTED)
	return e->flags.validp ? TRUE : FALSE;

    if (time(NULL) > e->timeout)
	return FALSE;

    return e->flags.validp && clones_exists(e) == TRUE;
}

/*
 * return it if it's in the hash table.
 */

static VolCacheEntry *
getbyid (uint32_t volid, int32_t cell, int *type)
{
    struct num_ptr *n;
    struct num_ptr key;

    key.cell = cell;
    key.vol  = volid;

    n = (struct num_ptr *)hashtabsearch (volidhashtab, (void *)&key);
    if (n == NULL)
	return NULL;
    if (type != NULL)
	*type = n->type;
    return n->ptr;
}

/*
 * return it if it's in the hash table.
 */

static VolCacheEntry *
getbyname (const char *volname, int32_t cell)
{
    struct name_ptr *n;
    struct name_ptr key;

    key.cell = cell;
    strlcpy (key.name, volname, sizeof(key.name));

    n = (struct name_ptr *)hashtabsearch (volnamehashtab, (void *)&key);
    if (n == NULL)
	return NULL;
    return n->ptr;
}

/*
 * Add a clone to `e' of type `type' with suffix `slot_type' in slot
 * slot_type
 */

static void
add_clone (VolCacheEntry *e, int type)
{
    struct num_ptr *num_ptr = &e->num_ptr[type];

    num_ptr->cell = e->cell;
    num_ptr->vol  = e->entry.volumeId[type];
    num_ptr->ptr  = e;
    num_ptr->type = type;
    hashtabadd (volidhashtab, (void *) num_ptr);
}

/*
 * Add all types of the volume entry `e' to volid hashtable. If there
 * isn't a RW volume, use the RO as the RW.
 */

static void
add_clones_to_hashtab (VolCacheEntry *e)
{
    if (e->entry.flags & VLF_RWEXISTS)
	add_clone (e, RWVOL);
    if (e->entry.flags & VLF_ROEXISTS)
	add_clone (e, ROVOL);
    if (e->entry.flags & VLF_BOEXISTS)
	add_clone (e, BACKVOL);
}

/*
 *
 */

static void
remove_clone (VolCacheEntry *e, int type)
{
    struct num_ptr *num_ptr = &e->num_ptr[type];

    if (num_ptr->ptr) {
	hashtabdel (volidhashtab, (void *) num_ptr);
	num_ptr->ptr = NULL;
    }
}

static void
remove_clones_from_hashtab (VolCacheEntry *e)
{
    int i;
    for (i = 0; i < MAXTYPES; ++i)
	remove_clone(e, i);
}

/*
 *
 */

static void
add_name_to_hashtab (VolCacheEntry *e)
{
    e->name_ptr.cell = e->cell;
    strlcpy (e->name_ptr.name, e->entry.name, sizeof(e->name_ptr.name));
    e->name_ptr.ptr  = e;
    hashtabadd (volnamehashtab, (void *)&e->name_ptr);
}

/*
 *
 */


static void
update_entry(VolCacheEntry *e, nvldbentry *entry)
{
    e->flags.stablep = cmp_nvldbentry (entry, &e->entry) == 0;
    e->flags.validp = TRUE;
    e->entry = *entry;

    if (e->flags.stablep == FALSE) {
	volcache_remove_marks (e);
	remove_clones_from_hashtab (e);
	add_clones_to_hashtab (e);
    }
}

/*
 *
 */

struct vstore_context {
    Listitem *item;
    unsigned n;
};

/*
 *
 */

static int
volcache_recover_entry (struct volcache_store *st, void *ptr)
{
    VolCacheEntry *e = get_free_entry ();
    struct vstore_context *c = (struct vstore_context *)ptr;

    e->cell = cell_name2num (st->cell);
    if (e->cell == -1) {
	arla_warnx(ADEBWARN, "can't resolve cell name");
	return(-1);
    }
    e->entry = st->entry;
    e->volsync = st->volsync;
    e->refcount = st->refcount;

    add_name_to_hashtab (e);
    add_clones_to_hashtab (e);

    c->n++;

    return 0;
}

/*
 *
 */

static void
volcache_recover_state (void)
{
    struct vstore_context c;
    Listitem *item;

    c.n = 0;
    c.item = NULL;

    state_recover_volcache ("volcache", volcache_recover_entry, &c);

    for(item = listhead (lrulist);
	item;
	item = listnext (lrulist, item)) {
	VolCacheEntry *e = (VolCacheEntry *)listdata(item);
	VolCacheEntry *parent;

	if (e->cell == -1)
	    continue;

	parent = getbyid (e->parent_fid.fid.Volume,
			  e->parent_fid.Cell,
			  NULL);
	if (parent != NULL)
	    volcache_volref (e, parent);
    }
    arla_warnx (ADEBVOLCACHE, "recovered %u entries to volcache", c.n);
}

/*
 *
 */

static int
volcache_store_entry (struct volcache_store *st, void *ptr)
{
    struct vstore_context *c;
    VolCacheEntry *e;

    c = (struct vstore_context *)ptr;
    if (c->item == NULL)		/* check if done ? */
	return STORE_DONE;

    e = (VolCacheEntry *)listdata (c->item);
    c->item = listprev (lrulist, c->item);

    if (e->cell == -1)
	return STORE_SKIP;
    
    strlcpy(st->cell, cell_num2name(e->cell), sizeof(st->cell));
    st->entry = e->entry;
    st->volsync = e->volsync;
    st->refcount = e->refcount;

    c->n++;
    return STORE_NEXT;
}

/*
 *
 */

int
volcache_store_state (void)
{
    struct vstore_context c;
    int ret;

    c.item = listtail (lrulist);
    c.n = 0;

    ret = state_store_volcache("volcache", volcache_store_entry, &c);
    if (ret)
	arla_warn(ADEBWARN, ret, "failed to store volcache state");
    else
	arla_warnx (ADEBVOLCACHE, "wrote %u entries to volcache", c.n);

    return 0;
}

/*
 * Initialize the volume cache with `nentries' in the free list.
 * Try to recover state iff `recover'
 */

void
volcache_init (unsigned nentries, Bool recover)
{
    volnamehashtab = hashtabnew (VOLCACHE_SIZE, volnamecmp, volnamehash);
    if (volnamehashtab == NULL)
	arla_errx (1, ADEBERROR, "volcache_init: hashtabnew failed");

    volidhashtab = hashtabnew (VOLCACHE_SIZE, volidcmp, volidhash);
    if (volidhashtab == NULL)
	arla_errx (1, ADEBERROR, "volcache_init: hashtabnew failed");

    lrulist = listnew ();
    if (lrulist == NULL)
	arla_errx (1, ADEBERROR, "volcache_init: listnew failed");
    nvolcacheentries = 0;
    create_new_entries (nentries);
    if (recover)
	volcache_recover_state ();
}

/*
 *
 */

static int
get_info_common (VolCacheEntry *e, nvldbentry *entry)
{
    if (entry->flags & VLF_DFSFILESET)
	arla_warnx (ADEBWARN,
		    "get_info: %s is really a DFS volume. "
		    "This might not work",
		    entry->name);

    if ((entry->volumeId[RWVOL] == entry->volumeId[ROVOL] &&
	 entry->flags & VLF_RWEXISTS && entry->flags & VLF_ROEXISTS) ||
	(entry->volumeId[ROVOL] == entry->volumeId[BACKVOL] &&
	 entry->flags & VLF_ROEXISTS && entry->flags & VLF_BOEXISTS) ||
	(entry->volumeId[RWVOL] == entry->volumeId[BACKVOL] &&
	 entry->flags & VLF_RWEXISTS && entry->flags & VLF_BOEXISTS)) {
      
	arla_warnx (ADEBERROR, "get_info: same id on different volumes: %s",
		    entry->name);
	return ENOENT;
    }

    e->flags.validp = TRUE;
    e->timeout = volcache_timeout + time(NULL);
    return 0;
}

/*
 * A function for checking if a service is up.  Return 0 if succesful.
 */

static int
vl_probe (struct rx_connection *conn)
{
    return VL_Probe (conn);
}

/*
 * Get all the db servers for `e->cell', sort them in order by rtt
 * (with some fuzz) and try to retrieve the entry for `name'.
 * Fill in the vldb entry in `entry'.
 *
 * Return 0 if succesful, else error.
 */

static int
get_info_loop (VolCacheEntry *e, nvldbentry *entry,
	       const char *name, int32_t cell,
	       CredCacheEntry *ce)
{
    const cell_db_entry *db_servers;
    int num_db_servers;
    int num_working_db_servers;
    int error = 0;
    ConnCacheEntry **conns;
    int i, j;
    Bool try_again;

    if (dynroot_isvolumep (cell, name)) {
	dynroot_fetch_root_vldbN (entry);
	return 0;
    }
    
    if (connected_mode == DISCONNECTED)
	return ENETDOWN;

    db_servers = cell_dbservers_by_id (cell, &num_db_servers);
    if (db_servers == NULL || num_db_servers == 0) {
	arla_warnx (ADEBWARN,
		    "Cannot find any db servers in cell %d(%s) while "
		    "getting data for volume `%s'",
		    cell, cell_num2name(cell), name);
	return ENOENT;
    }

    conns = malloc (num_db_servers * sizeof(*conns));
    if (conns == NULL)
	return ENOMEM;

    for (i = 0, j = 0; i < num_db_servers; ++i) {
	ConnCacheEntry *conn;

	conn = conn_get (cell, db_servers[i].addr.s_addr, afsvldbport,
			 VLDB_SERVICE_ID, vl_probe, ce);
	if (conn_isalivep (conn))
	    conn->rtt = rx_PeerOf(conn->connection)->srtt
		+ rand() % RTT_FUZZ - RTT_FUZZ / 2;
	else
	    conn->rtt = INT_MAX / 2;
	conns[j++] = conn;
    }
    num_working_db_servers = j;

    qsort (conns, num_working_db_servers, sizeof(*conns),
	   conn_rtt_cmp);

    try_again = TRUE;

    for (i = 0; i < num_working_db_servers; ++i) {
	if (conns[i] != NULL) {
	retry:
	    if (try_again) {
		if (conns[i]->flags.old) {
		    vldbentry oldentry;
		    error = VL_GetEntryByName (conns[i]->connection,
					       name, &oldentry);
		    if (error == 0)
			vldb2vldbN(&oldentry, entry);
		} else
		    error = VL_GetEntryByNameN (conns[i]->connection,
						name, entry);
		switch (error) {
		case 0 :
		    sanitize_nvldbentry (entry);
		    try_again = FALSE;
		    break;
		case VL_NOENT :
		    error = ENOENT;
		    try_again = FALSE;
		    break;
#ifdef KERBEROS
		case RXKADEXPIRED :
		    try_again = FALSE;
		    break;
		case RXKADSEALEDINCON:
		case RXKADUNKNOWNKEY:
		case RXKADBADTICKET:
		case RXKADBADKEY:
		    try_again = FALSE;
		    break;
#endif
		case RXGEN_OPCODE:
		    if (conns[i]->flags.old == FALSE) {
			conns[i]->flags.old = TRUE;
			goto retry;
		    }
		    break;
		default :
		    if (host_downp(error))
			conn_dead (conns[i]);
		    arla_warn (ADEBVOLCACHE, error,
			       "VL_GetEntryByName%s(%s)", 
			       conns[i]->flags.old ? "" : "N",
			       name);
		    break;
		}
	    }
	    conn_free (conns[i]);
	}
    }

    free (conns);

    if (try_again) {
	arla_warnx (ADEBWARN,
		    "Failed to contact any db servers in cell %d(%s)",
		    cell, cell_num2name(cell));
	error = ETIMEDOUT;
    }

    return error;
}

/*
 * Retrieve the information for the volume `id' into `e' using `ce' as
 * the creds.
 * Return 0 or error.
 */

static int
get_info_byid (VolCacheEntry *e, nvldbentry *entry,
	       uint32_t id, int32_t cell,
	       CredCacheEntry *ce)
{
    int error;
    char s[11];

    snprintf (s, sizeof(s), "%u", id);
    error = get_info_loop (e, entry, s, cell, ce);
    if (error)
	return error;
    return get_info_common (e, entry);
}


/*
 * Retrieve the information for `volname' into `e' using `ce' as the creds.
 * Return 0 or error.
 */

static int
get_info_byname (VolCacheEntry *e, nvldbentry *entry,
		 const char *volname, int32_t cell,
		 CredCacheEntry *ce)
{
    int error;

    error = get_info_loop (e, entry, volname, cell, ce);
    if (error)
	return error;

    /*
     * If the name we looked up is different from the one we got back,
     * replace that one with the canonical looked up name.  Otherwise,
     * we're not going to be able to find the volume in question.
     */

    if (strcmp(volname, entry->name) != 0) {
	arla_warnx (ADEBWARN,
		    "get_info: different volnames: %s - %s",
		    volname, entry->name);

	if (strlcpy (entry->name, volname,
		     sizeof(entry->name)) >= sizeof(entry->name)) {
	    arla_warnx (ADEBWARN,
			"get_info: too long volume (%.*s)",
			(int)strlen(volname), volname);
	    return ENAMETOOLONG;
	}
    }

    return get_info_common (e, entry);
}

/*
 * Add an entry for (volname, cell) to the hash table.
 */

static int
add_entry_byname (VolCacheEntry **ret, const char *volname,
		  int32_t cell, CredCacheEntry *ce)
{
    VolCacheEntry *e;
    int error;

    e = get_free_entry ();

    e->cell		= cell;
    e->refcount		= 0;
    e->vol_refs		= 0;
    e->flags.lookupp	= 1;
    strlcpy(e->entry.name, volname, sizeof(e->entry.name));

    add_name_to_hashtab (e);

    error = get_info_byname (e, &e->entry, volname, cell, ce);
    if (error == 0) {
	*ret = e;
	add_clones_to_hashtab (e);
    }

    e->flags.lookupp	= 0;
    if (e->flags.waiting)
	LWP_NoYieldSignal (e);

    return error;
}

/*
 * Retrieve the entry for (volname, cell).  If it's not in the cache,
 * add it.
 */

int
volcache_getbyname (const char *volname, int32_t cell, CredCacheEntry *ce,
		    VolCacheEntry **e, int *ret_type)
{
    int type, error;
    char real_volname[VLDB_MAXNAMELEN];

    strlcpy (real_volname, volname, sizeof(real_volname));
    type = volname_canonicalize (real_volname);
    if (ret_type)
	*ret_type = type;

    for(;;) {
	*e = getbyname (real_volname, cell);
	if (*e == NULL) {
	    error = add_entry_byname (e, real_volname, cell, ce);
	    if (error)
		return error;
	    continue;
	}

	if ((*e)->flags.lookupp) {
	    (*e)->flags.waiting = 1;
	    volcache_ref (*e);
	    LWP_WaitProcess (*e);
	    if (!(*e)->flags.validp) {
		volcache_free (*e);
		return ENOENT;
	    }
	} else
	    volcache_ref (*e);

	if (volume_uptodatep (*e)) {
	    error = 0;
	    break;
	} else {
	    nvldbentry tmp_e;
	    
	    error = get_info_byname (*e, &tmp_e, real_volname, cell, ce);
	    if (error)
		break;
	    update_entry(*e, &tmp_e);
	    break;
	}
    }

    if (error)
	(*e)->flags.validp = 0;
    if ((*e)->flags.waiting)
	LWP_NoYieldSignal (*e);
    (*e)->flags.lookupp = 0;
    (*e)->flags.waiting = 0;
    if (error) {
	volcache_free (*e);
	*e = NULL;
    }
    return error;
}

/*
 * Retrieve the entry for (volume-id, cell). If it's not in the cache,
 * there is no good way of adding it, and thus fail.
 */

int
volcache_getbyid (uint32_t volid, int32_t cell, CredCacheEntry *ce,
		  VolCacheEntry **e, int *type)
{
    int error = 0;
    for(;;) {
	*e = getbyid (volid, cell, type);
	if (*e == NULL) 
	    return ENOENT;

	if ((*e)->flags.lookupp) {
	    (*e)->flags.waiting = 1;
	    volcache_ref (*e);
	    LWP_WaitProcess (*e);
	    if (!(*e)->flags.validp) {
		volcache_free (*e);
		return ENOENT;
	    }
	} else
	    volcache_ref (*e);

	if (volume_uptodatep (*e)) {
	    error = 0;
	    break;
	} else {
	    nvldbentry tmp_e;

	    error = get_info_byid (*e, &tmp_e, volid, cell, ce);
	    if (error)
		break;
	    update_entry(*e, &tmp_e);
	    break;
	}
    }

    if (error)
	(*e)->flags.validp = 0;
    if ((*e)->flags.waiting)
	LWP_NoYieldSignal (*e);
    (*e)->flags.lookupp = 0;
    (*e)->flags.waiting = 0;
    if (error) {
	volcache_free (*e);
	*e = NULL;
    }
    return error;
}
    
/*
 * Invalidate the volume entry `ve'
 */

void
volcache_invalidate_ve (VolCacheEntry *ve)
{
    ve->flags.validp  = FALSE;
    ve->flags.stablep = FALSE;
}

static Bool
inval (void *ptr, void *arg)
{
    struct num_ptr *n = (struct num_ptr *)ptr;
    VolCacheEntry *e  = n->ptr;

    volcache_invalidate_ve (e);
    return FALSE;
}

/*
 * Invalidate all volume entries
 */

void
volcache_invalidate_all (void)
{
    hashtabforeach (volidhashtab, inval, NULL);
}

/*
 * invalidate this volume if id == data->id
 */

static Bool
invalidate_vol (void *ptr, void *arg)
{
    uint32_t id = *((uint32_t *)arg);
    struct num_ptr *n = (struct num_ptr *)ptr;
    VolCacheEntry *e  = n->ptr;

    if (n->vol == id)
	volcache_invalidate_ve (e);

    return FALSE;
}


/*
 * Invalidate the volume entry for `id'
 */

void
volcache_invalidate (uint32_t id, int32_t cell)
{
    if (cell == -1) {
	hashtabforeach (volidhashtab, invalidate_vol, &id);
    } else {
	VolCacheEntry *e = getbyid (id, cell, NULL);
	if (e != NULL)
	    volcache_invalidate_ve (e);
    }
}

/*
 *
 */

Bool
volume_downp (int error)
{
    switch (error) {
    case ARLA_VNOVOL:
    case ARLA_VMOVED:
	return TRUE;
    default:
	return FALSE;
    }
}

/*
 *
 */

void
volcache_mark_down (VolCacheEntry *ve, int i, int error)
{
    int type;

    assert(i < NMAXNSERVERS && i < ve->entry.nServers);

    switch (error) {
    case ARLA_VNOVOL:
    case ARLA_VMOVED:
	type = VOLCACHE_NOVOL;
	break;
    default:
	type = VOLCACHE_UNAVAILABLE;
	break;
    }

    ve->status[i] |= type;
}


/*
 *
 */

Bool
volcache_reliablep_el (VolCacheEntry *ve, int i)
{
    assert(i < NMAXNSERVERS && i < ve->entry.nServers);

    if (ve->status[i] == 0)
	return TRUE;
    return FALSE;
}

void
volcache_reliable_el (VolCacheEntry *ve, int i)
{
    assert(i < NMAXNSERVERS && i < ve->entry.nServers);
    ve->status[i] = 0;
}

/*
 * Return TRUE if this should be considered reliable (if it's validp,
 * stablep and fresh).
 */

Bool
volcache_reliablep (uint32_t id, int32_t cell)
{
    VolCacheEntry *e = getbyid (id, cell, NULL);

    return e != NULL
	&& e->flags.validp
	&& e->flags.stablep
	&& time(NULL) < e->timeout;
}

/*
 * Save `volsync'
 */

void
volcache_update_volsync (VolCacheEntry *e, AFSVolSync volsync)
{
    e->volsync = volsync;
}

/*
 * Increment the references to `e'
 */

void
volcache_ref (VolCacheEntry *e)
{
    if (e->refcount == 0 && e->vol_refs == 0)
	++nactive_volcacheentries;
    ++e->refcount;
}

/*
 * Decrement the references and possibly remove this entry.
 */

void
volcache_free (VolCacheEntry *e)
{
    --e->refcount;
    mark_unused (e);
}

/*
 * A parent directory of `e' is `parent'.
 * Record it and bump the vol ref count in `parent' iff e does not
 * already have a parent.
 */

void
volcache_volref (VolCacheEntry *e, VolCacheEntry *parent)
{
    if (e->parent == NULL) {
	if (parent->refcount == 0 && parent->vol_refs == 0)
	    ++nactive_volcacheentries;
	++parent->vol_refs;
	e->parent = parent;
    }
}

/*
 * remove one `volume' reference
 */

void
volcache_volfree (VolCacheEntry *e)
{
    --e->vol_refs;
    mark_unused (e);
}

/*
 * Print the entry `ptr' to the FILE `arg'
 */

static Bool
print_entry (void *ptr, void *arg)
{
    struct num_ptr *n = (struct num_ptr *)ptr;
    VolCacheEntry *e = n->ptr;
    int i;
    struct in_addr tmp;

    if (n->vol != e->entry.volumeId[RWVOL])
	return FALSE;

    arla_log(ADEBVLOG, "cell = %d (%s)"
	     "name = \"%s\", nServers = %d",
	     e->cell, cell_num2name (e->cell),
	     e->entry.name,
	     e->entry.nServers);
    for (i = 0; i < e->entry.nServers; ++i) {
	tmp.s_addr = htonl(e->entry.serverNumber[i]);
	arla_log(ADEBVLOG, "%d: server = %s, part = %d(%c), flags = %d",
		 i, inet_ntoa(tmp), e->entry.serverPartition[i],
		 'a' + e->entry.serverPartition[i],
		 e->entry.serverFlags[i]);
    }
    if (e->entry.flags & VLF_RWEXISTS)
	arla_log(ADEBVLOG, "rw clone: %d", e->entry.volumeId[RWVOL]);
    if (e->entry.flags & VLF_ROEXISTS)
	arla_log(ADEBVLOG, "ro clone: %d", e->entry.volumeId[ROVOL]);
    if (e->entry.flags & VLF_BACKEXISTS)
	arla_log(ADEBVLOG, "rw clone: %d", e->entry.volumeId[BACKVOL]);
    arla_log(ADEBVLOG, "refcount = %u", e->refcount);
    arla_log(ADEBVLOG, "vol_refs = %u", e->vol_refs);
    return FALSE;
}

/*
 *
 */

int
volume_make_uptodate (VolCacheEntry *e, CredCacheEntry *ce)
{
    nvldbentry tmp_e;
    int ret;

    if (connected_mode != CONNECTED ||
	volume_uptodatep (e))
	return 0;
    
    ret = get_info_byname (e, &tmp_e, e->entry.name, e->cell, ce);
    if (ret == 0)
	update_entry(e, &tmp_e);
    return ret;
}

/*
 * Get a name for a volume in (name, name_sz).
 * Return 0 if succesful
 */

int
volcache_getname (uint32_t id, int32_t cell,
		  char *name, size_t name_sz)
{
    int type;
    VolCacheEntry *e = getbyid (id, cell, &type);

    if (e == NULL)
	return -1;
    volname_specific (e->name_ptr.name, type, name, name_sz);
    return 0;
}

/*
 * Find out what incarnation of a particular volume we're using
 * return one of (VLSF_RWVOL, VLSF_ROVOL, VLSF_BACKVOL or -1 on error)
 */

int
volcache_volid2bit (const VolCacheEntry *ve, uint32_t volid)
{
    int bit = -1;

    if (ve->entry.flags & VLF_RWEXISTS
	&& ve->entry.volumeId[RWVOL] == volid)
	bit = VLSF_RWVOL;

    if (ve->entry.flags & VLF_ROEXISTS
	&& ve->entry.volumeId[ROVOL] == volid)
	bit = VLSF_ROVOL;

    if (ve->entry.flags & VLF_BACKEXISTS
	&& ve->entry.volumeId[BACKVOL] == volid)
	bit = VLSF_RWVOL;

    return bit;
}

/*
 * Print some status on the volume cache on `f'.
 */

void
volcache_status (void)
{
    arla_log(ADEBVLOG, "%u(%u) volume entries",
	     nactive_volcacheentries, nvolcacheentries);
    hashtabforeach (volidhashtab, print_entry, NULL);
}
@


1.8
log
@malloc(x * y) -> calloc(x, y) from adobriyan AT gmail.com, with tweaks
suggested by kjell@@; ok otto@@ pat@@ millert@@ jaredy@@
@
text
@@


1.7
log
@unbreak
ok beck@@
@
text
@d186 1
a186 1
    entries = (VolCacheEntry *)malloc (n * sizeof(VolCacheEntry));
d188 1
a188 2
	arla_errx (1, ADEBERROR, "volcache: malloc failed");
    memset(entries, 0, n * sizeof(VolCacheEntry));
@


1.6
log
@fix bogus assert() usage in afsd, and avoid an assert when
ThisCell is specified as a nonexeistent cell. found by matthieu@@,
ok deraadt@@
@
text
@d497 1
a497 1
    if (e->cell != -1) {
@


1.5
log
@Merge
@
text
@d497 4
a500 1
    assert (e->cell != -1);
a696 1
	assert (cell_is_sanep (cell));
@


1.4
log
@merge
@
text
@d2 1
a2 1
 * Copyright (c) 1995 - 2001 Kungliga Tekniska Högskolan
d39 3
a41 1
RCSID("$KTH: volcache.c,v 1.95.2.4 2001/03/04 05:11:19 lha Exp $") ;
d186 1
a186 1
    entries = (VolCacheEntry *)calloc (n, sizeof(VolCacheEntry));
d188 3
a190 1
	arla_errx (1, ADEBERROR, "volcache: calloc failed");
d241 1
d284 54
d341 4
a344 1
	return TRUE;
d346 1
a346 1
    return e->flags.validp;
d354 1
a354 1
getbyid (u_int32_t volid, int32_t cell, int *type)
d375 1
a375 1
getbyname (const char *volname, int32_t cell, int *type)
d390 121
d517 1
a517 4
    int fd;
    VolCacheEntry tmp;
    unsigned n;
    u_int32_t u1, u2;
d520 4
a523 41
    fd = open ("volcache", O_RDONLY | O_BINARY, 0);
    if (fd < 0)
	return;
    if (read (fd, &u1, sizeof(u1)) != sizeof(u1)
	|| read (fd, &u2, sizeof(u2)) != sizeof(u2)) {
	close (fd);
	return;
    }
    if (u1 != VOLCACHE_MAGIC_COOKIE) {
	arla_warnx (ADEBVOLCACHE, "dump file not recognized, ignoring");
	close (fd);
	return;
    }
    if (u2 != VOLCACHE_VERSION) {
	arla_warnx (ADEBVOLCACHE, "unknown dump file version number %u", u2);
	close (fd);
	return;
    }

    n = 0;
    while (read (fd, &tmp, sizeof(tmp)) == sizeof(tmp)) {
	VolCacheEntry *e = get_free_entry ();
	int i;

	++n;

	e->entry      = tmp.entry;
	e->volsync    = tmp.volsync;
	e->cell       = tmp.cell;
	e->refcount   = tmp.refcount;
	e->vol_refs   = 0;
	e->mp_fid     = tmp.mp_fid;
	e->parent_fid = tmp.parent_fid;
	e->parent     = NULL;
	if (tmp.name_ptr.ptr != NULL) {
	    e->name_ptr.cell = tmp.name_ptr.cell;
	    strlcpy (e->name_ptr.name, tmp.name_ptr.name,
		     sizeof(e->name_ptr.name));
	    e->name_ptr.ptr  = e;
	    hashtabadd (volnamehashtab, (void *)&e->name_ptr);
	}
a524 11
	for (i = 0; i < MAXTYPES; ++i) {
	    if (tmp.num_ptr[i].ptr != NULL) {
		e->num_ptr[i].cell  = tmp.num_ptr[i].cell;
		e->num_ptr[i].vol   = tmp.num_ptr[i].vol;
		e->num_ptr[i].ptr   = e;
		hashtabadd (volidhashtab, (void *)&e->num_ptr[i]);
	    }
	}
	e->flags.validp  = FALSE;
	e->flags.stablep = FALSE;
    }
d529 8
a536 3
	VolCacheEntry *parent = getbyid (e->parent_fid.fid.Volume,
					 e->parent_fid.Cell,
					 NULL);
d540 30
a569 2
    close (fd);
    arla_warnx (ADEBVOLCACHE, "recovered %u entries to volcache", n);
d579 2
a580 4
    Listitem *item;
    int fd;
    unsigned n;
    u_int32_t u1, u2;
d582 2
a583 17
    fd = open ("volcache.new", O_WRONLY | O_CREAT | O_TRUNC | O_BINARY, 0666);
    if (fd < 0)
	return errno;
    u1 = VOLCACHE_MAGIC_COOKIE;
    u2 = VOLCACHE_VERSION;
    if (write (fd, &u1, sizeof(u1)) != sizeof(u1)
	|| write (fd, &u2, sizeof(u2)) != sizeof(u2)) {
	int save_errno = errno;

	close (fd);
	return save_errno;
    }
    n = 0;
    for (item = listtail (lrulist);
	 item;
	 item = listprev (lrulist, item)) {
	VolCacheEntry *entry = (VolCacheEntry *)listdata (item);
d585 5
a589 15
	if (entry->cell == -1)
	    continue;
	if (write (fd, entry, sizeof(*entry)) != sizeof(*entry)) {
	    close (fd);
	    return errno;
	}
	++n;
    }

    if(close (fd))
	return errno;
    if (rename ("volcache.new", "volcache"))
	return errno;

    arla_warnx (ADEBVOLCACHE, "wrote %u entries to volcache", n);
a619 41
 * Add a clone to `e' of type `type' with suffix `slot_type' in slot
 * slot_type
 */

static void
add_clone (VolCacheEntry *e, int type, int suffix_type)
{
    struct num_ptr *num_ptr = &e->num_ptr[type];

    if (type == suffix_type) {
	num_ptr->cell = e->cell;
	num_ptr->vol  = e->entry.volumeId[type];
	num_ptr->ptr  = e;
	num_ptr->type = type;
	hashtabadd (volidhashtab, (void *) num_ptr);
    }
}

/*
 *
 */

static void
add_to_hashtab (VolCacheEntry *e)
{
    e->name_ptr.cell = e->cell;
    strlcpy (e->name_ptr.name, e->entry.name, sizeof(e->name_ptr.name));
    e->name_ptr.ptr  = e;
    hashtabadd (volnamehashtab, (void *)&e->name_ptr);

    if (e->entry.flags & VLF_RWEXISTS)
	add_clone (e, RWVOL, RWVOL);
    else
	add_clone (e, ROVOL, RWVOL);
    if (e->entry.flags & VLF_ROEXISTS)
	add_clone (e, ROVOL, ROVOL);
    if (e->entry.flags & VLF_BOEXISTS)
	add_clone (e, BACKVOL, BACKVOL);
}

/*
d624 1
a624 1
get_info_common (VolCacheEntry *e)
d626 1
a626 1
    if (e->entry.flags & VLF_DFSFILESET)
d630 1
a630 1
		    e->entry.name);
d632 6
a637 6
    if ((e->entry.volumeId[RWVOL] == e->entry.volumeId[ROVOL] &&
	 e->entry.flags & VLF_RWEXISTS && e->entry.flags & VLF_ROEXISTS) ||
	(e->entry.volumeId[ROVOL] == e->entry.volumeId[BACKVOL] &&
	 e->entry.flags & VLF_ROEXISTS && e->entry.flags & VLF_BOEXISTS) ||
	(e->entry.volumeId[RWVOL] == e->entry.volumeId[BACKVOL] &&
	 e->entry.flags & VLF_RWEXISTS && e->entry.flags & VLF_BOEXISTS)) {
d639 3
a641 3
	arla_warnx (ADEBERROR, "get_info: same id on diffrent volumes: %s",
		    e->entry.name);
	return -1;
d645 1
d662 1
d668 2
a669 1
get_info_loop (VolCacheEntry *e, const char *name, int32_t cell,
d681 1
a681 1
	dynroot_fetch_vldbN (&e->entry);
d684 3
d707 2
a708 2
	if (conn != NULL) {
	    conn->rtt = rx_PeerOf(conn->connection)->rtt
d710 3
a712 2
	    conns[j++] = conn;
	}
d726 1
a726 1
		    vldbentry entry;
d728 1
a728 1
					       name, &entry);
d730 1
a730 1
			vldb2vldbN(&entry, &e->entry);
d733 1
a733 1
						name, &e->entry);
d736 1
a736 1
		    sanitize_nvldbentry (&e->entry);
a737 1
		    e->last_fetch = time(NULL);
d749 2
d793 2
a794 1
get_info_byid (VolCacheEntry *e, u_int32_t id, int32_t cell,
d801 1
a801 1
    error = get_info_loop (e, s, cell, ce);
d804 1
a804 1
    return get_info_common (e);
d814 2
a815 1
get_info_byname (VolCacheEntry *e, const char *volname, int32_t cell,
d820 1
a820 1
    error = get_info_loop (e, volname, cell, ce);
d830 1
a830 1
    if (strcmp(volname, e->entry.name) != 0) {
d833 1
a833 1
		    volname, e->entry.name);
d835 2
a836 2
	if (strlcpy (e->entry.name, volname,
		     sizeof(e->entry.name)) >= sizeof(e->entry.name)) {
d844 1
a844 1
    return get_info_common (e);
d860 5
a864 3
    e->cell = cell;
    e->refcount = 0;
    e->vol_refs = 0;
d866 3
a868 1
    error = get_info_byname (e, volname, cell, ce);
a869 1
	add_to_hashtab (e);
d871 1
a872 15
    return error;
}

/*
 * Add an entry for (volname, cell) to the hash table.
 */

static int
add_entry_byid (VolCacheEntry **ret, u_int32_t id,
		int32_t cell, CredCacheEntry *ce)
{
    int error;
    VolCacheEntry *e;

    e = get_free_entry ();
d874 3
a876 3
    e->cell = cell;
    e->refcount = 0;
    e->vol_refs = 0;
a877 5
    error = get_info_byid (e, id, cell, ce);
    if (error == 0) {
	add_to_hashtab (e);
	*ret = e;
    }
d888 1
a888 1
		    VolCacheEntry **e, int *type)
d890 1
a890 1
    int error = 0;
d894 3
a896 1
    *type = volname_canonicalize (real_volname);
d899 1
a899 1
	*e = getbyname (real_volname, cell, type);
a905 6
	
	volcache_ref (*e);
	if (volume_uptodatep (*e)) {
	    return 0;
	} else {
	    VolCacheEntry tmp_ve;
d907 5
a911 2
	    error = get_info_byname (&tmp_ve, real_volname, cell, ce);
	    if (error) {
d913 1
a913 1
		return error;
d915 14
a928 4
	    (*e)->flags.stablep = cmp_nvldbentry (&tmp_ve.entry,
						  &(*e)->entry) == 0;
	    (*e)->flags.validp = TRUE;
	    (*e)->entry = tmp_ve.entry;
d931 12
d947 1
a947 1
 * add it.
d951 1
a951 1
volcache_getbyid (u_int32_t volid, int32_t cell, CredCacheEntry *ce,
d957 14
a970 7
	if (*e == NULL) {
	    error = add_entry_byid (e, volid, cell, ce);
	    if (error)
		return error;
	    continue;
	}
	volcache_ref(*e);
d972 2
a973 1
	    return 0;
d975 1
a975 1
	    VolCacheEntry tmp_ve;
d977 5
a981 9
	    error = get_info_byid (&tmp_ve, volid, cell, ce);
	    if (error) {
		volcache_free(*e);
		return error;
	    }
	    (*e)->flags.stablep = cmp_nvldbentry (&tmp_ve.entry,
						  &(*e)->entry) == 0;
	    (*e)->flags.validp = TRUE;
	    (*e)->entry = tmp_ve.entry;
d984 12
d997 1
a997 1

d1009 19
d1036 1
a1036 1
    u_int32_t id = *((u_int32_t *)arg);
d1052 1
a1052 1
volcache_invalidate (u_int32_t id, int32_t cell)
d1064 62
d1131 1
a1131 1
volcache_reliable (u_int32_t id, int32_t cell)
d1136 3
a1138 2
	&& e->flags.validp && e->flags.stablep
	&& (time(NULL) - e->last_fetch) < VOLCACHE_OLD;
d1247 3
d1254 4
a1257 1
    return get_info_byname (e, e->entry.name, e->cell, ce);
d1266 1
a1266 1
volcache_getname (u_int32_t id, int32_t cell,
d1284 1
a1284 1
volcache_volid2bit (const VolCacheEntry *ve, u_int32_t volid)
@


1.3
log
@New Arla userland from Arla between 0.34.2 and current in arla cvs.
Too many new features and fixes to mention here.
@
text
@d2 1
a2 1
 * Copyright (c) 1995 - 2000 Kungliga Tekniska Högskolan
d17 1
a17 6
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by the Kungliga Tekniska
 *      Högskolan and its contributors.
 * 
 * 4. Neither the name of the Institute nor the names of its contributors
d39 1
a39 11
RCSID("$Id: volcache.c,v 1.91 2000/08/25 02:52:24 assar Exp $") ;

/*
 * Suffixes for volume names.
 */

static char *volsuffixes[] = {
"",
ROSUFFIX,
BACKSUFFIX
};
d196 1
a196 1
 * re-use `e' if we can.
d200 1
a200 1
try_reuse (VolCacheEntry *e)
a207 4
	if (e->parent != NULL) {
	    volcache_volfree (e->parent);
	    e->parent = NULL;
	}
d223 1
a223 1
    for (i = 0; i < MAXTYPES; ++i) {
d226 2
a227 3
	if (e->name_ptr[i].ptr != NULL)
	    hashtabdel (volnamehashtab, &e->name_ptr[i]);
    }
a323 2
    if (type != NULL)
	*type = n->type;
d374 8
a382 6
	    if (tmp.name_ptr[i].ptr != NULL) {
		e->name_ptr[i].cell = tmp.name_ptr[i].cell;
		strcpy (e->name_ptr[i].name, tmp.name_ptr[i].name);
		e->name_ptr[i].ptr  = e;
		hashtabadd (volnamehashtab, (void *)&e->name_ptr[i]);
	    }
a489 1
    struct name_ptr *name_ptr = &e->name_ptr[suffix_type];
a497 7

    name_ptr->cell = e->cell;
    snprintf (name_ptr->name, VLDB_MAXNAMELEN,
	      "%s%s", e->entry.name, volsuffixes[suffix_type]);
    name_ptr->ptr  = e;
    name_ptr->type = type;
    hashtabadd (volnamehashtab, (void *) name_ptr);
d507 5
a629 2
		if (error == RX_CALL_DEAD)
		    conn_dead (conns[i]);
d644 4
d656 2
a711 3
    int i;
    size_t entry_name_len;
    int name_matched;
a716 11
    entry_name_len = strlen(e->entry.name);
    name_matched = FALSE;

    for (i = 0; i < MAXTYPES; ++i) {
	if (strncmp (volname, e->entry.name, entry_name_len) == 0
	    && strcmp (volname + entry_name_len, volsuffixes[i]) == 0) {
	    name_matched = TRUE;
	    break;
	}
    }

d723 1
a723 3
    if (!name_matched) {
	size_t volname_len = strlen(volname);

d728 2
a729 8
	for (i = MAXTYPES - 1; i >= 0; --i)
	    if (strcmp (volname + volname_len - strlen(volsuffixes[i]),
			volsuffixes[i]) == 0) {
		volname_len -= strlen(volsuffixes[i]);
		break;
	    }

	if (volname_len >= sizeof(e->entry.name)) {
d732 1
a732 1
			volname_len, volname);
a734 2
	memmove (e->entry.name, volname, volname_len);
	e->entry.name[volname_len] = '\0';
d800 4
d806 1
a806 1
	*e = getbyname (volname, cell, type);
d808 1
a808 1
	    error = add_entry_byname (e, volname, cell, ce);
d813 2
a814 3
	if ((*e)->refcount == 0)
	    ++nactive_volcacheentries;
	++(*e)->refcount;
d820 1
a820 1
	    error = get_info_byname (&tmp_ve, volname, cell, ce);
d822 1
a822 2
		--(*e)->refcount;
		try_reuse (*e);
d851 1
a851 3
	if ((*e)->refcount == 0)	
	    ++nactive_volcacheentries;
	++(*e)->refcount;
d859 1
a859 2
		--(*e)->refcount;
		try_reuse (*e);
d942 12
d961 1
a961 1
    try_reuse (e);
d974 2
d989 1
a989 1
    try_reuse (e);
d1045 2
a1046 1
 * Return a name for a volume (or NULL if it doesn't seem to exist).
d1049 3
a1051 2
const char *
volcache_getname (u_int32_t id, int32_t cell)
d1057 3
a1059 2
	return NULL;
    return e->name_ptr[type].name;
@


1.2
log
@upgrade Arla to fresher code. Too many new features and bugfixes.
@
text
@a0 1
/*	$OpenBSD$	*/
d2 1
a2 1
 * Copyright (c) 1995, 1996, 1997, 1998, 1999 Kungliga Tekniska Högskolan
d44 1
a44 1
RCSID("$KTH: volcache.c,v 1.67 1999/04/20 20:58:09 map Exp $") ;
d75 2
d80 2
a81 2
#define VOLCACHE_SIZE 2048
#define VOLCACHE_INC 300
d142 48
d203 2
a204 2
	entries[i].cell        = -1;
	listaddtail (lrulist, &entries[i]);
d211 20
d240 2
d243 1
a243 14
	if (e->num_ptr[i].ptr != NULL) {
	    FCacheEntry *fe;
	    int ret;
	    VenusFid fid;

	    fid.Cell       = e->cell;
	    fid.fid.Vnode  = fid.fid.Unique = 1;
	    fid.fid.Volume = e->num_ptr[i].vol;
	    ret = fcache_find (&fe, fid);
	    if (ret == 0 && fe != NULL) {
		if (fe->refcount > 0)
		    --fe->refcount;
		fcache_release (fe);
	    }
d245 1
a245 2
	}
	if (e->name_ptr[i].ptr != NULL) {
a246 1
	}
d248 5
d255 2
a256 1
    e->flags.validp = FALSE;
d278 1
a278 1
	if (e->refcount == 0) {
d281 1
a281 1
	    listaddhead (lrulist, e);
d290 1
a290 1
    listaddhead (lrulist, e);
d308 42
d359 2
d365 16
d388 8
a395 4
	e->entry    = tmp.entry;
	e->volsync  = tmp.volsync;
	e->cell     = tmp.cell;
	e->refcount = tmp.refcount;
d410 12
a421 1
	e->flags.validp = FALSE;
d437 1
d442 9
d532 17
a569 8
    if (e->entry.flags & VLF_RWEXISTS)
	add_clone (e, RWVOL, RWVOL);
    else
	add_clone (e, ROVOL, RWVOL);
    if (e->entry.flags & VLF_ROEXISTS)
	add_clone (e, ROVOL, ROVOL);
    if (e->entry.flags & VLF_BOEXISTS)
	add_clone (e, BACKVOL, BACKVOL);
d592 2
a593 1
get_info_loop (VolCacheEntry *e, const char *name, CredCacheEntry *ce)
a598 1
    int cell = e->cell;
d603 6
a608 1
    db_servers = cell_dbservers (cell, &num_db_servers);
d611 4
a614 2
		    "Cannot find any db servers in cell %d(%s)",
		    cell, cell_num2name(cell));
d657 1
d659 1
d665 5
d701 3
a703 1
 *
d707 2
a708 1
get_info_byid (VolCacheEntry *e, u_int32_t id, CredCacheEntry *ce)
d714 1
a714 1
    error = get_info_loop (e, s, ce);
d722 2
a723 1
 *
d727 2
a728 1
get_info_byname (VolCacheEntry *e, const char *volname, CredCacheEntry *ce)
d735 1
a735 1
    error = get_info_loop (e, volname, ce);
d770 7
a776 1
	strncpy (e->entry.name, volname, volname_len);
d798 1
d800 1
a800 1
    error = get_info_byname (e, volname, ce);
d802 1
a803 1
	++nactive_volcacheentries;
d823 1
d825 1
a825 1
    error = get_info_byid (e, id, ce);
d827 1
a827 1
	++nactive_volcacheentries;
d840 1
a840 1
		    VolCacheEntry **e, int32_t *type)
a842 6
    struct name_ptr *n;
    struct name_ptr key;

    key.cell = cell;
    strncpy (key.name, volname, VLDB_MAXNAMELEN);
    key.name[VLDB_MAXNAMELEN - 1] = '\0';
d845 2
a846 2
	n = (struct name_ptr *)hashtabsearch (volnamehashtab, (void *)&key);
	if (n == NULL) {
d852 2
a853 2
	*e = n->ptr;
	*type = n->type;
d858 6
a863 4
	    recycle_entry (*e);
	    error = get_info_byname (*e, volname, ce);
	    --(*e)->refcount;
	    if (error)
d865 5
d881 1
a881 1
		  VolCacheEntry **e, int32_t *type)
a883 6
    struct num_ptr *n;
    struct num_ptr key;

    key.cell = cell;
    key.vol  = volid;

d885 2
a886 2
	n = (struct num_ptr *)hashtabsearch (volidhashtab, (void *)&key);
	if (n == NULL) {
d892 2
a893 2
	*e = n->ptr;
	*type = n->type;
d898 6
a903 4
	    recycle_entry (*e);
	    error = get_info_byid (*e, volid, ce);
	    --(*e)->refcount;
	    if (error)
d905 5
d915 30
d951 8
a958 2
    struct num_ptr *n;
    struct num_ptr key;
d960 4
a963 2
    key.cell = cell;
    key.vol  = id;
d965 4
a968 3
    n = (struct num_ptr *)hashtabsearch (volidhashtab, (void *)&key);
    if (n != NULL) {
	VolCacheEntry *e = n->ptr;
d970 3
a972 2
	e->flags.validp = FALSE;
    }
a984 1

d993 27
a1019 2
    if (e->refcount == 0)
	--nactive_volcacheentries;
d1037 2
a1038 2
    arla_log(ADEBVLOG, "cell = %d (%s)\n"
	     "name = \"%s\", nServers = %d\n",
d1044 1
a1044 1
	arla_log(ADEBVLOG, "%d: server = %s, part = %d(%c), flags = %d\n",
d1050 1
a1050 1
	arla_log(ADEBVLOG, "rw clone: %d\n", e->entry.volumeId[RWVOL]);
d1052 1
a1052 1
	arla_log(ADEBVLOG, "ro clone: %d\n", e->entry.volumeId[ROVOL]);
d1054 3
a1056 2
	arla_log(ADEBVLOG, "rw clone: %d\n", e->entry.volumeId[BACKVOL]);
    arla_log(ADEBVLOG, "refcount = %u\n\n", e->refcount);
d1071 41
a1111 1
    return get_info_byname (e, e->entry.name, ce);
d1121 1
a1121 1
    arla_log(ADEBVLOG, "%u(%u) volume entries\n",
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
 * Copyright (c) 1995, 1996, 1997, 1998 Kungliga Tekniska Högskolan
d45 1
a45 1
RCSID("$KTH: volcache.c,v 1.39 1998/07/29 21:31:06 assar Exp $") ;
d172 1
a172 1
	if (e->name_ptr[i].ptr != NULL) {
a176 2
	    assert (e->num_ptr[i].ptr != NULL);

d182 3
a184 2
		assert (fe->refcount > 0 && fe->flags.mountp);
		--fe->refcount;
d186 3
a188 1

a189 1
	    hashtabdel (volidhashtab, &e->num_ptr[i]);
d192 5
a196 1
    memset (e, 0, sizeof(*e));
d355 27
d386 1
a386 1
get_info (VolCacheEntry *e, const char *volname, CredCacheEntry *ce)
d388 5
a392 30
    ConnCacheEntry *conn;
    u_long addr = cell_finddbserver (e->cell).s_addr;
    int error, i;

    conn = conn_get (e->cell, addr, afsvldbport, VLDB_SERVICE_ID, ce);
    if (conn == NULL) {
	struct in_addr ia;

	ia.s_addr = addr;
	arla_warnx (ADEBVOLCACHE,
		    "volcache: failed to make rx-connection to vldb %s",
		    inet_ntoa(ia));
	return -1;
    }

    error = VL_GetEntryByName(conn->connection, volname, &e->entry);
    conn_free (conn);
    if (error) {
	arla_warn (ADEBVOLCACHE, error,
		   "VL_GetEntryByName(%s)",
		    volname);
	return -1;
    }
    
    i = min(strlen(volname), VLDB_MAXNAMELEN);
    if (strncmp(volname, e->entry.name, i)) {
	arla_warnx (ADEBERROR, "get_info: we asked for %s and got %s",
		    volname, e->entry.name);
    }

d402 1
a402 1
		  volname);
d406 8
a413 37
    if (e->entry.flags & VLF_RWEXISTS) {
	e->num_ptr[RWVOL].cell = e->cell;
	e->num_ptr[RWVOL].vol  = e->entry.volumeId[RWVOL];
	e->num_ptr[RWVOL].ptr  = e;
	hashtabadd (volidhashtab, (void *)&e->num_ptr[RWVOL]);

	e->name_ptr[RWVOL].cell = e->cell;
	snprintf (e->name_ptr[RWVOL].name, VLDB_MAXNAMELEN,
		  "%s%s", e->entry.name, volsuffixes[RWVOL]);
	e->name_ptr[RWVOL].ptr  = e;
	hashtabadd (volnamehashtab, (void *)&e->name_ptr[RWVOL]);

    }
    if (e->entry.flags & VLF_ROEXISTS) {
	e->num_ptr[ROVOL].cell = e->cell;
	e->num_ptr[ROVOL].vol  = e->entry.volumeId[ROVOL];
	e->num_ptr[ROVOL].ptr  = e;
	hashtabadd (volidhashtab, (void *)&e->num_ptr[ROVOL]);

	e->name_ptr[ROVOL].cell = e->cell;
	snprintf (e->name_ptr[ROVOL].name, VLDB_MAXNAMELEN,
		  "%s%s", e->entry.name, volsuffixes[ROVOL]);
	e->name_ptr[ROVOL].ptr  = e;
	hashtabadd (volnamehashtab, (void *)&e->name_ptr[ROVOL]);
    }
    if (e->entry.flags & VLF_BOEXISTS) {
	e->num_ptr[BACKVOL].cell = e->cell;
	e->num_ptr[BACKVOL].vol  = e->entry.volumeId[BACKVOL];
	e->num_ptr[BACKVOL].ptr  = e;
	hashtabadd (volidhashtab, (void *)&e->num_ptr[BACKVOL]);

	e->name_ptr[BACKVOL].cell = e->cell;
	snprintf (e->name_ptr[BACKVOL].name, VLDB_MAXNAMELEN,
		  "%s%s", e->entry.name, volsuffixes[BACKVOL]);
	e->name_ptr[BACKVOL].ptr  = e;
	hashtabadd (volnamehashtab, (void *)&e->name_ptr[BACKVOL]);
    }
d419 184
d606 27
a632 2
static VolCacheEntry *
add_entry (const char *volname, int32_t cell, CredCacheEntry *ce)
d634 1
d642 2
a643 1
    if(get_info (e, volname, ce) == 0) {
d645 1
a645 3
	return e;
    } else {
	return NULL;
d647 1
d655 3
a657 2
VolCacheEntry *
volcache_getbyname (const char *volname, int32_t cell, CredCacheEntry *ce)
d659 1
a659 1
    VolCacheEntry *e;
d667 20
a686 11
    n = (struct name_ptr *)hashtabsearch (volnamehashtab, (void *)&key);
    if (n == NULL)
	e = add_entry (volname, cell, ce);
    else
	e = n->ptr;

    if (e != NULL && !volume_uptodatep (e)) {
	recycle_entry (e);
	e->cell = cell;
	if (get_info (e, volname, ce))
	    e = NULL;
a687 4

    if (e != NULL)
	++e->refcount;
    return e;
d695 3
a697 2
VolCacheEntry *
volcache_getbyid (u_int32_t id, int32_t cell, CredCacheEntry *ce)
d699 1
a699 1
    VolCacheEntry *e;
a701 3
    char s[11];

    snprintf (s, sizeof(s), "%u", id);
d704 1
a704 1
    key.vol  = id;
d706 20
a725 5
    n = (struct num_ptr *)hashtabsearch (volidhashtab, (void *)&key);
    if (n == NULL) {
	e = add_entry (s, cell, ce);
    } else {
	e = n->ptr;
a726 11

    if (e != NULL && !volume_uptodatep (e)) {
	recycle_entry (e);
	e->cell = cell;
	if (get_info (e, s, ce))
	    e = NULL;
    }

    if (e != NULL)
	++e->refcount;
    return e;
a781 1
    FILE *f = (FILE *)arg;
d788 2
a789 2
    fprintf (f, "cell = %d (%s)\n"
	     "name = \"%s\", volumeType = %d(%s), nServers = %d\n",
a791 1
	     e->entry.volumeType, volsuffixes[e->entry.volumeType],
d795 1
a795 1
	fprintf (f, "%d: server = %s, part = %d(%c), flags = %d\n",
d801 1
a801 1
	fprintf (f, "rw clone: %d\n", e->entry.volumeId[RWVOL]);
d803 1
a803 1
	fprintf (f, "ro clone: %d\n", e->entry.volumeId[ROVOL]);
d805 2
a806 2
	fprintf (f, "rw clone: %d\n", e->entry.volumeId[BACKVOL]);
    fprintf (f, "refcount = %u\n\n", e->refcount);
d811 14
d829 1
a829 1
volcache_status (FILE *f)
d831 1
a831 1
    fprintf (f, "%u(%u) volume entries\n",
d833 1
a833 1
    hashtabforeach (volidhashtab, print_entry, f);
@


1.1.1.1
log
@Initial version of Arla, a free implementation of an AFS cache-manager.
(second try, hopefully into the correct repository this time)
@
text
@@


1.1.1.2
log
@Import of arla-0.35.7
@
text
@d1 1
d3 1
a3 1
 * Copyright (c) 1995 - 2001 Kungliga Tekniska Högskolan
d18 6
a23 1
 * 3. Neither the name of the Institute nor the names of its contributors
d45 11
a55 1
RCSID("$KTH: volcache.c,v 1.95.2.4 2001/03/04 05:11:19 lha Exp $") ;
a75 2
    assert (volname != NULL);

d79 2
a80 2
#define VOLCACHE_SIZE	2053
#define VOLCACHE_INC	300
a140 48
 * Compare two `nvldbentry' and return 0 if they are equal.
 */

static int
cmp_nvldbentry (const nvldbentry *n1, const nvldbentry *n2)
{
    int i;

    if (strcmp (n1->name, n2->name) != 0)
	return 1;
    if (n1->nServers != n2->nServers)
	return 1;
    for (i = 0; i < n1->nServers; ++i)
	if (n1->serverNumber[i] != n2->serverNumber[i]
	    || n1->serverPartition[i] != n2->serverPartition[i]
	    || n1->serverFlags[i] != n2->serverFlags[i])
	    return 1;
    if (n1->flags != n2->flags)
	return 1;
    if (n1->flags & VLF_RWEXISTS
	&& n1->volumeId[RWVOL] != n2->volumeId[RWVOL])
	return 1;
    if (n1->flags & VLF_ROEXISTS
	&& n1->volumeId[ROVOL] != n2->volumeId[ROVOL])
	return 1;
    if (n1->flags & VLF_BOEXISTS
	&& n1->volumeId[BACKVOL] != n2->volumeId[BACKVOL])
	return 1;
    if (n1->cloneId != n2->cloneId)
	return 1;
    return 0;
}

/*
 * Do consistency checks and simple clean-ups.
 */

static void
sanitize_nvldbentry (nvldbentry *n)
{
    if (n->nServers > NMAXNSERVERS) {
	arla_warnx (ADEBVOLCACHE, "too many servers %d > %d",
		    n->nServers, NMAXNSERVERS);
	n->nServers = NMAXNSERVERS;
    }
}

/*
d154 2
a155 2
	entries[i].cell = -1;
	entries[i].li   = listaddtail (lrulist, &entries[i]);
a161 16
 * mark as not being in use
 */

static void
mark_unused (VolCacheEntry *e)
{
    if (e->refcount == 0 && e->vol_refs == 0) {
	listdel (lrulist, e->li);
	e->li = listaddtail (lrulist, e);
	assert (nactive_volcacheentries > 0);
	assert (nactive_volcacheentries <= nvolcacheentries);
	--nactive_volcacheentries;
    }
}

/*
d171 16
a186 1
    assert (e->refcount == 0 && e->vol_refs == 0);
d188 1
a188 2
    for (i = 0; i < MAXTYPES; ++i)
	if (e->num_ptr[i].ptr != NULL)
d190 1
a190 5
    if (e->name_ptr.ptr != NULL)
	hashtabdel (volnamehashtab, &e->name_ptr);
    if (e->parent) {
	volcache_volfree (e->parent);
	e->parent = NULL;
d192 1
a192 7

    memset (&e->entry, 0, sizeof(e->entry));
    memset (&e->volsync, 0, sizeof(e->volsync));
    e->flags.validp  = FALSE;
    e->flags.stablep = FALSE;
    memset (&e->name_ptr, 0, sizeof(e->name_ptr));
    memset (&e->num_ptr, 0, sizeof(e->num_ptr));
d212 1
a212 1
	if (e->refcount == 0 && e->vol_refs == 0) {
d215 1
a215 1
	    e->li = listaddhead (lrulist, e);
d224 1
a224 1
    e->li = listaddhead (lrulist, e);
a241 40
 * return it if it's in the hash table.
 */

static VolCacheEntry *
getbyid (u_int32_t volid, int32_t cell, int *type)
{
    struct num_ptr *n;
    struct num_ptr key;

    key.cell = cell;
    key.vol  = volid;

    n = (struct num_ptr *)hashtabsearch (volidhashtab, (void *)&key);
    if (n == NULL)
	return NULL;
    if (type != NULL)
	*type = n->type;
    return n->ptr;
}

/*
 * return it if it's in the hash table.
 */

static VolCacheEntry *
getbyname (const char *volname, int32_t cell, int *type)
{
    struct name_ptr *n;
    struct name_ptr key;

    key.cell = cell;
    strlcpy (key.name, volname, sizeof(key.name));

    n = (struct name_ptr *)hashtabsearch (volnamehashtab, (void *)&key);
    if (n == NULL)
	return NULL;
    return n->ptr;
}

/*
a250 2
    u_int32_t u1, u2;
    Listitem *item;
a254 16
    if (read (fd, &u1, sizeof(u1)) != sizeof(u1)
	|| read (fd, &u2, sizeof(u2)) != sizeof(u2)) {
	close (fd);
	return;
    }
    if (u1 != VOLCACHE_MAGIC_COOKIE) {
	arla_warnx (ADEBVOLCACHE, "dump file not recognized, ignoring");
	close (fd);
	return;
    }
    if (u2 != VOLCACHE_VERSION) {
	arla_warnx (ADEBVOLCACHE, "unknown dump file version number %u", u2);
	close (fd);
	return;
    }

d262 4
a265 16
	e->entry      = tmp.entry;
	e->volsync    = tmp.volsync;
	e->cell       = tmp.cell;
	e->refcount   = tmp.refcount;
	e->vol_refs   = 0;
	e->mp_fid     = tmp.mp_fid;
	e->parent_fid = tmp.parent_fid;
	e->parent     = NULL;
	if (tmp.name_ptr.ptr != NULL) {
	    e->name_ptr.cell = tmp.name_ptr.cell;
	    strlcpy (e->name_ptr.name, tmp.name_ptr.name,
		     sizeof(e->name_ptr.name));
	    e->name_ptr.ptr  = e;
	    hashtabadd (volnamehashtab, (void *)&e->name_ptr);
	}

d267 6
d280 1
a280 12
	e->flags.validp  = FALSE;
	e->flags.stablep = FALSE;
    }
    for(item = listhead (lrulist);
	item;
	item = listnext (lrulist, item)) {
	VolCacheEntry *e = (VolCacheEntry *)listdata(item);
	VolCacheEntry *parent = getbyid (e->parent_fid.fid.Volume,
					 e->parent_fid.Cell,
					 NULL);
	if (parent != NULL)
	    volcache_volref (e, parent);
a295 1
    u_int32_t u1, u2;
a299 9
    u1 = VOLCACHE_MAGIC_COOKIE;
    u2 = VOLCACHE_VERSION;
    if (write (fd, &u1, sizeof(u1)) != sizeof(u1)
	|| write (fd, &u2, sizeof(u2)) != sizeof(u2)) {
	int save_errno = errno;

	close (fd);
	return save_errno;
    }
d351 1
a351 2
 * Add a clone to `e' of type `type' with suffix `slot_type' in slot
 * slot_type
d354 2
a355 2
static void
add_clone (VolCacheEntry *e, int type, int suffix_type)
d357 14
a370 1
    struct num_ptr *num_ptr = &e->num_ptr[type];
d372 13
a384 6
    if (type == suffix_type) {
	num_ptr->cell = e->cell;
	num_ptr->vol  = e->entry.volumeId[type];
	num_ptr->ptr  = e;
	num_ptr->type = type;
	hashtabadd (volidhashtab, (void *) num_ptr);
a385 1
}
a386 34
/*
 *
 */

static void
add_to_hashtab (VolCacheEntry *e)
{
    e->name_ptr.cell = e->cell;
    strlcpy (e->name_ptr.name, e->entry.name, sizeof(e->name_ptr.name));
    e->name_ptr.ptr  = e;
    hashtabadd (volnamehashtab, (void *)&e->name_ptr);

    if (e->entry.flags & VLF_RWEXISTS)
	add_clone (e, RWVOL, RWVOL);
    else
	add_clone (e, ROVOL, RWVOL);
    if (e->entry.flags & VLF_ROEXISTS)
	add_clone (e, ROVOL, ROVOL);
    if (e->entry.flags & VLF_BOEXISTS)
	add_clone (e, BACKVOL, BACKVOL);
}

/*
 *
 */

static int
get_info_common (VolCacheEntry *e)
{
    if (e->entry.flags & VLF_DFSFILESET)
	arla_warnx (ADEBWARN,
		    "get_info: %s is really a DFS volume. "
		    "This might not work",
		    e->entry.name);
d396 1
a396 1
		    e->entry.name);
d400 37
a441 189
 * A function for checking if a service is up.  Return 0 if succesful.
 */

static int
vl_probe (struct rx_connection *conn)
{
    return VL_Probe (conn);
}

/*
 * Get all the db servers for `e->cell', sort them in order by rtt
 * (with some fuzz) and try to retrieve the entry for `name'.
 *
 * Return 0 if succesful, else error.
 */

static int
get_info_loop (VolCacheEntry *e, const char *name, int32_t cell,
	       CredCacheEntry *ce)
{
    const cell_db_entry *db_servers;
    int num_db_servers;
    int num_working_db_servers;
    int error = 0;
    ConnCacheEntry **conns;
    int i, j;
    Bool try_again;

    if (dynroot_isvolumep (cell, name)) {
	dynroot_fetch_vldbN (&e->entry);
	return 0;
    }

    db_servers = cell_dbservers_by_id (cell, &num_db_servers);
    if (db_servers == NULL || num_db_servers == 0) {
	arla_warnx (ADEBWARN,
		    "Cannot find any db servers in cell %d(%s) while "
		    "getting data for volume `%s'",
		    cell, cell_num2name(cell), name);
	assert (cell_is_sanep (cell));
	return ENOENT;
    }

    conns = malloc (num_db_servers * sizeof(*conns));
    if (conns == NULL)
	return ENOMEM;

    for (i = 0, j = 0; i < num_db_servers; ++i) {
	ConnCacheEntry *conn;

	conn = conn_get (cell, db_servers[i].addr.s_addr, afsvldbport,
			 VLDB_SERVICE_ID, vl_probe, ce);
	if (conn != NULL) {
	    conn->rtt = rx_PeerOf(conn->connection)->rtt
		+ rand() % RTT_FUZZ - RTT_FUZZ / 2;
	    conns[j++] = conn;
	}
    }
    num_working_db_servers = j;

    qsort (conns, num_working_db_servers, sizeof(*conns),
	   conn_rtt_cmp);

    try_again = TRUE;

    for (i = 0; i < num_working_db_servers; ++i) {
	if (conns[i] != NULL) {
	retry:
	    if (try_again) {
		if (conns[i]->flags.old) {
		    vldbentry entry;
		    error = VL_GetEntryByName (conns[i]->connection,
					       name, &entry);
		    if (error == 0)
			vldb2vldbN(&entry, &e->entry);
		} else
		    error = VL_GetEntryByNameN (conns[i]->connection,
						name, &e->entry);
		switch (error) {
		case 0 :
		    sanitize_nvldbentry (&e->entry);
		    try_again = FALSE;
		    e->last_fetch = time(NULL);
		    break;
		case VL_NOENT :
		    error = ENOENT;
		    try_again = FALSE;
		    break;
#ifdef KERBEROS
		case RXKADEXPIRED :
		    try_again = FALSE;
		    break;
		case RXKADSEALEDINCON:
		case RXKADUNKNOWNKEY:
		    try_again = FALSE;
		    break;
#endif
		case RXGEN_OPCODE:
		    if (conns[i]->flags.old == FALSE) {
			conns[i]->flags.old = TRUE;
			goto retry;
		    }
		    break;
		default :
		    if (host_downp(error))
			conn_dead (conns[i]);
		    arla_warn (ADEBVOLCACHE, error,
			       "VL_GetEntryByName%s(%s)", 
			       conns[i]->flags.old ? "" : "N",
			       name);
		    break;
		}
	    }
	    conn_free (conns[i]);
	}
    }

    free (conns);

    if (try_again) {
	arla_warnx (ADEBWARN,
		    "Failed to contact any db servers in cell %d(%s)",
		    cell, cell_num2name(cell));
	error = ETIMEDOUT;
    }

    return error;
}

/*
 * Retrieve the information for the volume `id' into `e' using `ce' as
 * the creds.
 * Return 0 or error.
 */

static int
get_info_byid (VolCacheEntry *e, u_int32_t id, int32_t cell,
	       CredCacheEntry *ce)
{
    int error;
    char s[11];

    snprintf (s, sizeof(s), "%u", id);
    error = get_info_loop (e, s, cell, ce);
    if (error)
	return error;
    return get_info_common (e);
}


/*
 * Retrieve the information for `volname' into `e' using `ce' as the creds.
 * Return 0 or error.
 */

static int
get_info_byname (VolCacheEntry *e, const char *volname, int32_t cell,
		 CredCacheEntry *ce)
{
    int error;

    error = get_info_loop (e, volname, cell, ce);
    if (error)
	return error;

    /*
     * If the name we looked up is different from the one we got back,
     * replace that one with the canonical looked up name.  Otherwise,
     * we're not going to be able to find the volume in question.
     */

    if (strcmp(volname, e->entry.name) != 0) {
	arla_warnx (ADEBWARN,
		    "get_info: different volnames: %s - %s",
		    volname, e->entry.name);

	if (strlcpy (e->entry.name, volname,
		     sizeof(e->entry.name)) >= sizeof(e->entry.name)) {
	    arla_warnx (ADEBWARN,
			"get_info: too long volume (%.*s)",
			(int)strlen(volname), volname);
	    return ENAMETOOLONG;
	}
    }

    return get_info_common (e);
}

/*
d445 2
a446 3
static int
add_entry_byname (VolCacheEntry **ret, const char *volname,
		  int32_t cell, CredCacheEntry *ce)
a448 1
    int error;
a453 1
    e->vol_refs = 0;
d455 5
a459 4
    error = get_info_byname (e, volname, cell, ce);
    if (error == 0) {
	add_to_hashtab (e);
	*ret = e;
a460 1
    return error;
d464 2
a465 1
 * Add an entry for (volname, cell) to the hash table.
d468 2
a469 3
static int
add_entry_byid (VolCacheEntry **ret, u_int32_t id,
		int32_t cell, CredCacheEntry *ce)
a470 1
    int error;
d472 2
d475 3
a477 1
    e = get_free_entry ();
d479 5
a483 3
    e->cell = cell;
    e->refcount = 0;
    e->vol_refs = 0;
d485 5
a489 4
    error = get_info_byid (e, id, cell, ce);
    if (error == 0) {
	add_to_hashtab (e);
	*ret = e;
a490 2
    return error;
}
d492 3
a494 41
/*
 * Retrieve the entry for (volname, cell).  If it's not in the cache,
 * add it.
 */

int
volcache_getbyname (const char *volname, int32_t cell, CredCacheEntry *ce,
		    VolCacheEntry **e, int *type)
{
    int error = 0;
    char real_volname[VLDB_MAXNAMELEN];

    strlcpy (real_volname, volname, sizeof(real_volname));
    *type = volname_canonicalize (real_volname);

    for(;;) {
	*e = getbyname (real_volname, cell, type);
	if (*e == NULL) {
	    error = add_entry_byname (e, real_volname, cell, ce);
	    if (error)
		return error;
	    continue;
	}
	
	volcache_ref (*e);
	if (volume_uptodatep (*e)) {
	    return 0;
	} else {
	    VolCacheEntry tmp_ve;

	    error = get_info_byname (&tmp_ve, real_volname, cell, ce);
	    if (error) {
		volcache_free (*e);
		return error;
	    }
	    (*e)->flags.stablep = cmp_nvldbentry (&tmp_ve.entry,
						  &(*e)->entry) == 0;
	    (*e)->flags.validp = TRUE;
	    (*e)->entry = tmp_ve.entry;
	}
    }
d502 2
a503 3
int
volcache_getbyid (u_int32_t volid, int32_t cell, CredCacheEntry *ce,
		  VolCacheEntry **e, int *type)
d505 4
a508 27
    int error = 0;
    for(;;) {
	*e = getbyid (volid, cell, type);
	if (*e == NULL) {
	    error = add_entry_byid (e, volid, cell, ce);
	    if (error)
		return error;
	    continue;
	}
	volcache_ref(*e);
	if (volume_uptodatep (*e)) {
	    return 0;
	} else {
	    VolCacheEntry tmp_ve;

	    error = get_info_byid (&tmp_ve, volid, cell, ce);
	    if (error) {
		volcache_free(*e);
		return error;
	    }
	    (*e)->flags.stablep = cmp_nvldbentry (&tmp_ve.entry,
						  &(*e)->entry) == 0;
	    (*e)->flags.validp = TRUE;
	    (*e)->entry = tmp_ve.entry;
	}
    }
}
d510 1
a510 3
/*
 * Invalidate the volume entry `ve'
 */
d512 2
a513 6
void
volcache_invalidate_ve (VolCacheEntry *ve)
{
    ve->flags.validp  = FALSE;
    ve->flags.stablep = FALSE;
}
d515 6
d522 6
a527 3
/*
 * invalidate this volume if id == data->id
 */
d529 3
a531 11
static Bool
invalidate_vol (void *ptr, void *arg)
{
    u_int32_t id = *((u_int32_t *)arg);
    struct num_ptr *n = (struct num_ptr *)ptr;
    VolCacheEntry *e  = n->ptr;

    if (n->vol == id)
	volcache_invalidate_ve (e);

    return FALSE;
a533 1

d541 2
a542 8
    if (cell == -1) {
	hashtabforeach (volidhashtab, invalidate_vol, &id);
    } else {
	VolCacheEntry *e = getbyid (id, cell, NULL);
	if (e != NULL)
	    volcache_invalidate_ve (e);
    }
}
d544 2
a545 4
/*
 * Return TRUE if this should be considered reliable (if it's validp,
 * stablep and fresh).
 */
d547 3
a549 4
Bool
volcache_reliable (u_int32_t id, int32_t cell)
{
    VolCacheEntry *e = getbyid (id, cell, NULL);
d551 2
a552 3
    return e != NULL
	&& e->flags.validp && e->flags.stablep
	&& (time(NULL) - e->last_fetch) < VOLCACHE_OLD;
a564 11
/*
 * Increment the references to `e'
 */

void
volcache_ref (VolCacheEntry *e)
{
    if (e->refcount == 0 && e->vol_refs == 0)
	++nactive_volcacheentries;
    ++e->refcount;
}
d574 2
a575 29
    mark_unused (e);
}

/*
 * A parent directory of `e' is `parent'.
 * Record it and bump the vol ref count in `parent' iff e does not
 * already have a parent.
 */

void
volcache_volref (VolCacheEntry *e, VolCacheEntry *parent)
{
    if (e->parent == NULL) {
	if (parent->refcount == 0 && parent->vol_refs == 0)
	    ++nactive_volcacheentries;
	++parent->vol_refs;
	e->parent = parent;
    }
}

/*
 * remove one `volume' reference
 */

void
volcache_volfree (VolCacheEntry *e)
{
    --e->vol_refs;
    mark_unused (e);
d587 1
d594 2
a595 2
    arla_log(ADEBVLOG, "cell = %d (%s)"
	     "name = \"%s\", nServers = %d",
d598 1
d602 1
a602 1
	arla_log(ADEBVLOG, "%d: server = %s, part = %d(%c), flags = %d",
d608 1
a608 1
	arla_log(ADEBVLOG, "rw clone: %d", e->entry.volumeId[RWVOL]);
d610 1
a610 1
	arla_log(ADEBVLOG, "ro clone: %d", e->entry.volumeId[ROVOL]);
d612 2
a613 3
	arla_log(ADEBVLOG, "rw clone: %d", e->entry.volumeId[BACKVOL]);
    arla_log(ADEBVLOG, "refcount = %u", e->refcount);
    arla_log(ADEBVLOG, "vol_refs = %u", e->vol_refs);
a617 57
 *
 */

int
volume_make_uptodate (VolCacheEntry *e, CredCacheEntry *ce)
{
    if (connected_mode != CONNECTED ||
	volume_uptodatep (e))
	return 0;
    
    return get_info_byname (e, e->entry.name, e->cell, ce);
}

/*
 * Get a name for a volume in (name, name_sz).
 * Return 0 if succesful
 */

int
volcache_getname (u_int32_t id, int32_t cell,
		  char *name, size_t name_sz)
{
    int type;
    VolCacheEntry *e = getbyid (id, cell, &type);

    if (e == NULL)
	return -1;
    volname_specific (e->name_ptr.name, type, name, name_sz);
    return 0;
}

/*
 * Find out what incarnation of a particular volume we're using
 * return one of (VLSF_RWVOL, VLSF_ROVOL, VLSF_BACKVOL or -1 on error)
 */

int
volcache_volid2bit (const VolCacheEntry *ve, u_int32_t volid)
{
    int bit = -1;

    if (ve->entry.flags & VLF_RWEXISTS
	&& ve->entry.volumeId[RWVOL] == volid)
	bit = VLSF_RWVOL;

    if (ve->entry.flags & VLF_ROEXISTS
	&& ve->entry.volumeId[ROVOL] == volid)
	bit = VLSF_ROVOL;

    if (ve->entry.flags & VLF_BACKEXISTS
	&& ve->entry.volumeId[BACKVOL] == volid)
	bit = VLSF_RWVOL;

    return bit;
}

/*
d622 1
a622 1
volcache_status (void)
d624 1
a624 1
    arla_log(ADEBVLOG, "%u(%u) volume entries",
d626 1
a626 1
    hashtabforeach (volidhashtab, print_entry, NULL);
@


1.1.1.3
log
@Import of arla -current as of Aug 5 2003

ok todd@@ deraadt@@
@
text
@d2 1
a2 1
 * Copyright (c) 1995 - 2002 Kungliga Tekniska Högskolan
d39 1
a39 3
RCSID("$arla: volcache.c,v 1.116 2003/04/10 15:49:13 lha Exp $") ;

static int volcache_timeout = VOLCACHE_TIMEOUT;
d184 1
a184 1
    entries = (VolCacheEntry *)malloc (n * sizeof(VolCacheEntry));
d186 1
a186 3
	arla_errx (1, ADEBERROR, "volcache: malloc failed");
    memset(entries, 0, n * sizeof(VolCacheEntry));

a236 1
    memset (&e->status, 0, sizeof(e->status));
a278 54
clones_exists (VolCacheEntry *e)
{
    int i;

    for (i = 0; i < MAXTYPES; ++i)
	if (e->num_ptr[i].ptr != NULL)
	    return TRUE;
    return FALSE;
}

/*
 *
 */

void
volcache_process_marks (VolCacheEntry *ve)
{
    int i, status, inval;

    inval = 0;

    for (i = 0; i < ve->entry.nServers; i++) {
	status = ve->status[i];
	if (status & (VOLCACHE_NOVOL|VOLCACHE_UNAVAILABLE)) {
	    /* already checked ? */
	    if (status & VOLCACHE_CHECKED)
		continue;
	    ve->status[i] |= VOLCACHE_CHECKED;
	    if (ve->flags.stablep)
		inval = 1;
	}
    }
    if (inval)
	volcache_invalidate_ve(ve);
}

/*
 *
 */

static void
volcache_remove_marks (VolCacheEntry *ve)
{
    int i;

    for (i = 0; i < NMAXNSERVERS; i++)
	ve->status[i] = 0;
}

/*
 *
 */

static Bool
d282 1
a282 4
	return e->flags.validp ? TRUE : FALSE;

    if (time(NULL) > e->timeout)
	return FALSE;
d284 1
a284 1
    return e->flags.validp && clones_exists(e) == TRUE;
d292 1
a292 1
getbyid (uint32_t volid, int32_t cell, int *type)
d313 1
a313 1
getbyname (const char *volname, int32_t cell)
a327 33
 * Add a clone to `e' of type `type' with suffix `slot_type' in slot
 * slot_type
 */

static void
add_clone (VolCacheEntry *e, int type)
{
    struct num_ptr *num_ptr = &e->num_ptr[type];

    num_ptr->cell = e->cell;
    num_ptr->vol  = e->entry.volumeId[type];
    num_ptr->ptr  = e;
    num_ptr->type = type;
    hashtabadd (volidhashtab, (void *) num_ptr);
}

/*
 * Add all types of the volume entry `e' to volid hashtable. If there
 * isn't a RW volume, use the RO as the RW.
 */

static void
add_clones_to_hashtab (VolCacheEntry *e)
{
    if (e->entry.flags & VLF_RWEXISTS)
	add_clone (e, RWVOL);
    if (e->entry.flags & VLF_ROEXISTS)
	add_clone (e, ROVOL);
    if (e->entry.flags & VLF_BOEXISTS)
	add_clone (e, BACKVOL);
}

/*
d332 1
a332 12
remove_clone (VolCacheEntry *e, int type)
{
    struct num_ptr *num_ptr = &e->num_ptr[type];

    if (num_ptr->ptr) {
	hashtabdel (volidhashtab, (void *) num_ptr);
	num_ptr->ptr = NULL;
    }
}

static void
remove_clones_from_hashtab (VolCacheEntry *e)
d334 2
a335 43
    int i;
    for (i = 0; i < MAXTYPES; ++i)
	remove_clone(e, i);
}

/*
 *
 */

static void
add_name_to_hashtab (VolCacheEntry *e)
{
    e->name_ptr.cell = e->cell;
    strlcpy (e->name_ptr.name, e->entry.name, sizeof(e->name_ptr.name));
    e->name_ptr.ptr  = e;
    hashtabadd (volnamehashtab, (void *)&e->name_ptr);
}

/*
 *
 */


static void
update_entry(VolCacheEntry *e, nvldbentry *entry)
{
    e->flags.stablep = cmp_nvldbentry (entry, &e->entry) == 0;
    e->flags.validp = TRUE;
    e->entry = *entry;

    if (e->flags.stablep == FALSE) {
	volcache_remove_marks (e);
	remove_clones_from_hashtab (e);
	add_clones_to_hashtab (e);
    }
}

/*
 *
 */

struct vstore_context {
    Listitem *item;
d337 1
a337 34
};

/*
 *
 */

static int
volcache_recover_entry (struct volcache_store *st, void *ptr)
{
    VolCacheEntry *e = get_free_entry ();
    struct vstore_context *c = (struct vstore_context *)ptr;

    e->cell = cell_name2num (st->cell);
    assert (e->cell != -1);
    e->entry = st->entry;
    e->volsync = st->volsync;
    e->refcount = st->refcount;

    add_name_to_hashtab (e);
    add_clones_to_hashtab (e);

    c->n++;

    return 0;
}

/*
 *
 */

static void
volcache_recover_state (void)
{
    struct vstore_context c;
d340 41
a380 4
    c.n = 0;
    c.item = NULL;

    state_recover_volcache ("volcache", volcache_recover_entry, &c);
d382 11
d397 3
a399 8
	VolCacheEntry *parent;

	if (e->cell == -1)
	    continue;

	parent = getbyid (e->parent_fid.fid.Volume,
			  e->parent_fid.Cell,
			  NULL);
d403 2
a404 1
    arla_warnx (ADEBVOLCACHE, "recovered %u entries to volcache", c.n);
d411 2
a412 2
static int
volcache_store_entry (struct volcache_store *st, void *ptr)
d414 4
a417 2
    struct vstore_context *c;
    VolCacheEntry *e;
d419 17
a435 3
    c = (struct vstore_context *)ptr;
    if (c->item == NULL)		/* check if done ? */
	return STORE_DONE;
d437 8
a444 2
    e = (VolCacheEntry *)listdata (c->item);
    c->item = listprev (lrulist, c->item);
d446 4
a449 7
    if (e->cell == -1)
	return STORE_SKIP;
    
    strlcpy(st->cell, cell_num2name(e->cell), sizeof(st->cell));
    st->entry = e->entry;
    st->volsync = e->volsync;
    st->refcount = e->refcount;
d451 1
a451 22
    c->n++;
    return STORE_NEXT;
}

/*
 *
 */

int
volcache_store_state (void)
{
    struct vstore_context c;
    int ret;

    c.item = listtail (lrulist);
    c.n = 0;

    ret = state_store_volcache("volcache", volcache_store_entry, &c);
    if (ret)
	arla_warn(ADEBWARN, ret, "failed to store volcache state");
    else
	arla_warnx (ADEBVOLCACHE, "wrote %u entries to volcache", c.n);
d482 41
d527 1
a527 1
get_info_common (VolCacheEntry *e, nvldbentry *entry)
d529 1
a529 1
    if (entry->flags & VLF_DFSFILESET)
d533 1
a533 1
		    entry->name);
d535 6
a540 6
    if ((entry->volumeId[RWVOL] == entry->volumeId[ROVOL] &&
	 entry->flags & VLF_RWEXISTS && entry->flags & VLF_ROEXISTS) ||
	(entry->volumeId[ROVOL] == entry->volumeId[BACKVOL] &&
	 entry->flags & VLF_ROEXISTS && entry->flags & VLF_BOEXISTS) ||
	(entry->volumeId[RWVOL] == entry->volumeId[BACKVOL] &&
	 entry->flags & VLF_RWEXISTS && entry->flags & VLF_BOEXISTS)) {
d542 3
a544 3
	arla_warnx (ADEBERROR, "get_info: same id on different volumes: %s",
		    entry->name);
	return ENOENT;
a547 1
    e->timeout = volcache_timeout + time(NULL);
a563 1
 * Fill in the vldb entry in `entry'.
d569 1
a569 2
get_info_loop (VolCacheEntry *e, nvldbentry *entry,
	       const char *name, int32_t cell,
d581 1
a581 1
	dynroot_fetch_root_vldbN (entry);
a583 3
    
    if (connected_mode == DISCONNECTED)
	return ENETDOWN;
d604 2
a605 2
	if (conn_isalivep (conn))
	    conn->rtt = rx_PeerOf(conn->connection)->srtt
d607 2
a608 3
	else
	    conn->rtt = INT_MAX / 2;
	conns[j++] = conn;
d622 1
a622 1
		    vldbentry oldentry;
d624 1
a624 1
					       name, &oldentry);
d626 1
a626 1
			vldb2vldbN(&oldentry, entry);
d629 1
a629 1
						name, entry);
d632 1
a632 1
		    sanitize_nvldbentry (entry);
d634 1
a645 2
		case RXKADBADTICKET:
		case RXKADBADKEY:
d688 1
a688 2
get_info_byid (VolCacheEntry *e, nvldbentry *entry,
	       uint32_t id, int32_t cell,
d695 1
a695 1
    error = get_info_loop (e, entry, s, cell, ce);
d698 1
a698 1
    return get_info_common (e, entry);
d708 1
a708 2
get_info_byname (VolCacheEntry *e, nvldbentry *entry,
		 const char *volname, int32_t cell,
d713 1
a713 1
    error = get_info_loop (e, entry, volname, cell, ce);
d723 1
a723 1
    if (strcmp(volname, entry->name) != 0) {
d726 1
a726 1
		    volname, entry->name);
d728 2
a729 2
	if (strlcpy (entry->name, volname,
		     sizeof(entry->name)) >= sizeof(entry->name)) {
d737 1
a737 1
    return get_info_common (e, entry);
d753 3
a755 5
    e->cell		= cell;
    e->refcount		= 0;
    e->vol_refs		= 0;
    e->flags.lookupp	= 1;
    strlcpy(e->entry.name, volname, sizeof(e->entry.name));
d757 1
a757 3
    add_name_to_hashtab (e);

    error = get_info_byname (e, &e->entry, volname, cell, ce);
d759 1
a760 1
	add_clones_to_hashtab (e);
d762 15
d778 3
a780 3
    e->flags.lookupp	= 0;
    if (e->flags.waiting)
	LWP_NoYieldSignal (e);
d782 5
d797 1
a797 1
		    VolCacheEntry **e, int *ret_type)
d799 1
a799 1
    int type, error;
d803 1
a803 3
    type = volname_canonicalize (real_volname);
    if (ret_type)
	*ret_type = type;
d806 1
a806 1
	*e = getbyname (real_volname, cell);
d813 6
d820 2
a821 5
	if ((*e)->flags.lookupp) {
	    (*e)->flags.waiting = 1;
	    volcache_ref (*e);
	    LWP_WaitProcess (*e);
	    if (!(*e)->flags.validp) {
d823 1
a823 1
		return ENOENT;
d825 4
a828 14
	} else
	    volcache_ref (*e);

	if (volume_uptodatep (*e)) {
	    error = 0;
	    break;
	} else {
	    nvldbentry tmp_e;
	    
	    error = get_info_byname (*e, &tmp_e, real_volname, cell, ce);
	    if (error)
		break;
	    update_entry(*e, &tmp_e);
	    break;
a830 12

    if (error)
	(*e)->flags.validp = 0;
    if ((*e)->flags.waiting)
	LWP_NoYieldSignal (*e);
    (*e)->flags.lookupp = 0;
    (*e)->flags.waiting = 0;
    if (error) {
	volcache_free (*e);
	*e = NULL;
    }
    return error;
d835 1
a835 1
 * there is no good way of adding it, and thus fail.
d839 1
a839 1
volcache_getbyid (uint32_t volid, int32_t cell, CredCacheEntry *ce,
d845 7
a851 14
	if (*e == NULL) 
	    return ENOENT;

	if ((*e)->flags.lookupp) {
	    (*e)->flags.waiting = 1;
	    volcache_ref (*e);
	    LWP_WaitProcess (*e);
	    if (!(*e)->flags.validp) {
		volcache_free (*e);
		return ENOENT;
	    }
	} else
	    volcache_ref (*e);

d853 1
a853 2
	    error = 0;
	    break;
d855 1
a855 1
	    nvldbentry tmp_e;
d857 9
a865 5
	    error = get_info_byid (*e, &tmp_e, volid, cell, ce);
	    if (error)
		break;
	    update_entry(*e, &tmp_e);
	    break;
d868 1
a869 13
    if (error)
	(*e)->flags.validp = 0;
    if ((*e)->flags.waiting)
	LWP_NoYieldSignal (*e);
    (*e)->flags.lookupp = 0;
    (*e)->flags.waiting = 0;
    if (error) {
	volcache_free (*e);
	*e = NULL;
    }
    return error;
}
    
a880 19
static Bool
inval (void *ptr, void *arg)
{
    struct num_ptr *n = (struct num_ptr *)ptr;
    VolCacheEntry *e  = n->ptr;

    volcache_invalidate_ve (e);
    return FALSE;
}

/*
 * Invalidate all volume entries
 */

void
volcache_invalidate_all (void)
{
    hashtabforeach (volidhashtab, inval, NULL);
}
d889 1
a889 1
    uint32_t id = *((uint32_t *)arg);
d905 1
a905 1
volcache_invalidate (uint32_t id, int32_t cell)
a916 62
 *
 */

Bool
volume_downp (int error)
{
    switch (error) {
    case ARLA_VNOVOL:
    case ARLA_VMOVED:
	return TRUE;
    default:
	return FALSE;
    }
}

/*
 *
 */

void
volcache_mark_down (VolCacheEntry *ve, int i, int error)
{
    int type;

    assert(i < NMAXNSERVERS && i < ve->entry.nServers);

    switch (error) {
    case ARLA_VNOVOL:
    case ARLA_VMOVED:
	type = VOLCACHE_NOVOL;
	break;
    default:
	type = VOLCACHE_UNAVAILABLE;
	break;
    }

    ve->status[i] |= type;
}


/*
 *
 */

Bool
volcache_reliablep_el (VolCacheEntry *ve, int i)
{
    assert(i < NMAXNSERVERS && i < ve->entry.nServers);

    if (ve->status[i] == 0)
	return TRUE;
    return FALSE;
}

void
volcache_reliable_el (VolCacheEntry *ve, int i)
{
    assert(i < NMAXNSERVERS && i < ve->entry.nServers);
    ve->status[i] = 0;
}

/*
d922 1
a922 1
volcache_reliablep (uint32_t id, int32_t cell)
d927 2
a928 3
	&& e->flags.validp
	&& e->flags.stablep
	&& time(NULL) < e->timeout;
a1036 3
    nvldbentry tmp_e;
    int ret;

d1041 1
a1041 4
    ret = get_info_byname (e, &tmp_e, e->entry.name, e->cell, ce);
    if (ret == 0)
	update_entry(e, &tmp_e);
    return ret;
d1050 1
a1050 1
volcache_getname (uint32_t id, int32_t cell,
d1068 1
a1068 1
volcache_volid2bit (const VolCacheEntry *ve, uint32_t volid)
@


