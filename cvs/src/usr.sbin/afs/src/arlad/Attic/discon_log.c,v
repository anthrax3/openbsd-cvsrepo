head	1.6;
access;
symbols
	arla-20030805:1.1.1.2
	OPENBSD_3_3:1.3.0.4
	OPENBSD_3_3_BASE:1.3
	OPENBSD_3_2:1.3.0.2
	OPENBSD_3_2_BASE:1.3
	arla-0-35-7:1.1.1.1
	arla:1.1.1
	OPENBSD_3_1:1.2.0.8
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.6
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_9:1.2.0.4
	OPENBSD_2_8:1.2.0.2
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.1.0.4
	OPENBSD_2_7_BASE:1.1
	OPENBSD_2_6:1.1.0.2
	OPENBSD_2_6_BASE:1.1;
locks; strict;
comment	@ * @;


1.6
date	2003.08.12.14.58.43;	author hin;	state dead;
branches;
next	1.5;

1.5
date	2003.08.05.08.42.41;	author hin;	state Exp;
branches;
next	1.4;

1.4
date	2003.04.28.19.30.27;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2002.06.07.04.28.57;	author hin;	state Exp;
branches;
next	1.2;

1.2
date	2000.09.11.14.40.41;	author art;	state Exp;
branches;
next	1.1;

1.1
date	99.04.30.01.59.07;	author art;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.06.07.04.14.23;	author hin;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.08.05.08.21.00;	author hin;	state Exp;
branches;
next	;


desc
@@


1.6
log
@More unused files with bad string functions in them. Bye bye.
@
text
@OBSOLETE /* COPYRIGHT  (C)  1998
OBSOLETE  * THE REGENTS OF THE UNIVERSITY OF MICHIGAN
OBSOLETE  * ALL RIGHTS RESERVED
OBSOLETE  * 
OBSOLETE  * PERMISSION IS GRANTED TO USE, COPY, CREATE DERIVATIVE WORKS 
OBSOLETE  * AND REDISTRIBUTE THIS SOFTWARE AND SUCH DERIVATIVE WORKS 
OBSOLETE  * FOR ANY PURPOSE, SO LONG AS THE NAME OF THE UNIVERSITY OF 
OBSOLETE  * MICHIGAN IS NOT USED IN ANY ADVERTISING OR PUBLICITY 
OBSOLETE  * PERTAINING TO THE USE OR DISTRIBUTION OF THIS SOFTWARE 
OBSOLETE  * WITHOUT SPECIFIC, WRITTEN PRIOR AUTHORIZATION.  IF THE 
OBSOLETE  * ABOVE COPYRIGHT NOTICE OR ANY OTHER IDENTIFICATION OF THE 
OBSOLETE  * UNIVERSITY OF MICHIGAN IS INCLUDED IN ANY COPY OF ANY 
OBSOLETE  * PORTION OF THIS SOFTWARE, THEN THE DISCLAIMER BELOW MUST 
OBSOLETE  * ALSO BE INCLUDED.
OBSOLETE  * 
OBSOLETE  * THIS SOFTWARE IS PROVIDED AS IS, WITHOUT REPRESENTATION 
OBSOLETE  * FROM THE UNIVERSITY OF MICHIGAN AS TO ITS FITNESS FOR ANY 
OBSOLETE  * PURPOSE, AND WITHOUT WARRANTY BY THE UNIVERSITY OF 
OBSOLETE  * MICHIGAN OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING 
OBSOLETE  * WITHOUT LIMITATION THE IMPLIED WARRANTIES OF 
OBSOLETE  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE 
OBSOLETE  * REGENTS OF THE UNIVERSITY OF MICHIGAN SHALL NOT BE LIABLE 
OBSOLETE  * FOR ANY DAMAGES, INCLUDING SPECIAL, INDIRECT, INCIDENTAL, OR 
OBSOLETE  * CONSEQUENTIAL DAMAGES, WITH RESPECT TO ANY CLAIM ARISING 
OBSOLETE  * OUT OF OR IN CONNECTION WITH THE USE OF THE SOFTWARE, EVEN 
OBSOLETE  * IF IT HAS BEEN OR IS HEREAFTER ADVISED OF THE POSSIBILITY OF 
OBSOLETE  * SUCH DAMAGES.
OBSOLETE  */
OBSOLETE 
OBSOLETE /*
OBSOLETE  * This file contains functions that relate to performance statistics
OBSOLETE  * for disconnected operation.
OBSOLETE  */
OBSOLETE 
OBSOLETE #include "arla_local.h"
OBSOLETE 
OBSOLETE RCSID("$arla: discon_log.c,v 1.12 2002/09/07 10:43:05 lha Exp $");
OBSOLETE 
OBSOLETE int Log_is_open;
OBSOLETE DARLA_file log_data;
OBSOLETE 
OBSOLETE log_ent_t   log_head;
OBSOLETE 
OBSOLETE #if 0
OBSOLETE /*
OBSOLETE  * read an entry from the log file described by tfile.  The result is
OBSOLETE  * put into the log_ent data.  This return 0 if successful, 1 if
OBSOLETE  * it failed to some reason ( ie. no more data ).
OBSOLETE  */
OBSOLETE 
OBSOLETE int
OBSOLETE read_log_ent(DARLA_file * tfile, log_ent_t *in_log)
OBSOLETE {
OBSOLETE     int len;
OBSOLETE     char *bp;
OBSOLETE 
OBSOLETE     if (DARLA_Read(tfile, (char *) in_log, sizeof (int)) != sizeof(int))
OBSOLETE 	return 1;
OBSOLETE 
OBSOLETE     len = in_log->log_len - sizeof(int);
OBSOLETE     bp = (char *) in_log + sizeof(int);
OBSOLETE 
OBSOLETE     if (DARLA_Read(tfile, bp, len) != len) {
OBSOLETE 	printf("read_log_ent: short read \n");
OBSOLETE 	return 1;
OBSOLETE     }
OBSOLETE     return 0;
OBSOLETE }
OBSOLETE 
OBSOLETE void
OBSOLETE update_log_ent(offset, flags)
OBSOLETE long offset;
OBSOLETE int flags;
OBSOLETE {
OBSOLETE     struct DARLA_file *tfile;
OBSOLETE     log_ent_t *log_ent;
OBSOLETE     int code;
OBSOLETE 
OBSOLETE     tfile = DARLA_UFSOpen(&log_data.bs_dev, log_data.bs_inode);
OBSOLETE     if (!tfile)
OBSOLETE 	panic("update_log_ent: failed to open log file");
OBSOLETE 
OBSOLETE     DARLA_Seek(tfile, offset);
OBSOLETE 
OBSOLETE     log_ent = (log_ent_t *) malloc(sizeof(log_ent_t));
OBSOLETE     code = read_log_ent(tfile, log_ent);
OBSOLETE 
OBSOLETE     if (code) {
OBSOLETE 	printf("update_log_ent: failed to read log entry at %d \n",
OBSOLETE 	       offset);
OBSOLETE     } else {
OBSOLETE 
OBSOLETE 	/* set the log flags */
OBSOLETE 	log_ent->log_flags |= flags;
OBSOLETE 
OBSOLETE 	/* write the entry back out */
OBSOLETE 	DARLA_Seek(tfile, offset);
OBSOLETE 	DARLA_Write(tfile, (char *) log_ent, log_ent->log_len);
OBSOLETE     }
OBSOLETE     free(log_ent);
OBSOLETE     DARLA_Close(tfile);
OBSOLETE }
OBSOLETE #endif
OBSOLETE 
OBSOLETE 
OBSOLETE /* write the log entries to disk */
OBSOLETE static long
OBSOLETE write_log_ent(int len, log_ent_t *log)
OBSOLETE {
OBSOLETE 
OBSOLETE     long new_num;
OBSOLETE     static int index=0;
OBSOLETE 
OBSOLETE     arla_warnx (ADEBDISCONN,"We are writing a log");
OBSOLETE     if (!Log_is_open) {
OBSOLETE 	return -1;
OBSOLETE     }
OBSOLETE 
OBSOLETE     if (log_head.next == 0) { 
OBSOLETE 	log_head.next = (log_ent_t *) malloc(sizeof(log_ent_t));
OBSOLETE 	*log_head.next = *log;
OBSOLETE 	log_head.next->next = 0;
OBSOLETE     }
OBSOLETE     else {
OBSOLETE         log->next = log_head.next;
OBSOLETE         log_head.next = (log_ent_t *) malloc(sizeof(log_ent_t));
OBSOLETE         *log_head.next = *log;
OBSOLETE     }
OBSOLETE 
OBSOLETE     ObtainWriteLock(&log_data.bs_lock);
OBSOLETE 
OBSOLETE     new_num = 0;
OBSOLETE   
OBSOLETE     log->log_opno = new_num;
OBSOLETE     gettimeofday(&log->log_time, 0);
OBSOLETE 
OBSOLETE     log->log_offset = log_data.offset;
OBSOLETE     log->log_flags = 0;
OBSOLETE     log->log_index = index++;
OBSOLETE 
OBSOLETE     DARLA_Write(&log_data, (char *) log, len);
OBSOLETE 
OBSOLETE     ReleaseWriteLock(&log_data.bs_lock);
OBSOLETE 
OBSOLETE     return (new_num);
OBSOLETE }
OBSOLETE 
OBSOLETE long
OBSOLETE log_dis_store(struct vcache *avc)
OBSOLETE {
OBSOLETE     log_ent_t	*store;
OBSOLETE     long	op_no;
OBSOLETE     
OBSOLETE     store = (log_ent_t *) malloc(sizeof(log_ent_t));
OBSOLETE     
OBSOLETE     store->log_op = DIS_STORE;
OBSOLETE     store->st_fid = avc->fid;
OBSOLETE     store->st_origdv =  avc->DataVersion;
OBSOLETE     store->st_flag = avc->flag;
OBSOLETE     
OBSOLETE     /* have to log cred as well */
OBSOLETE     store->cred = avc->cred;
OBSOLETE     
OBSOLETE     /* figure out the length of a store entry */
OBSOLETE     store->log_len = ((char *) &(store->st_origdv)) - ((char *) store)
OBSOLETE 	+ sizeof(store->st_origdv);
OBSOLETE     
OBSOLETE     op_no = write_log_ent(store->log_len, store);
OBSOLETE     
OBSOLETE     free(store);
OBSOLETE     return op_no;
OBSOLETE }
OBSOLETE 
OBSOLETE 
OBSOLETE /* Log a mkdir operation */
OBSOLETE long
OBSOLETE log_dis_mkdir(struct vcache *pvc, struct vcache *dvc, 
OBSOLETE 	      AFSStoreStatus *attrs, char *name)
OBSOLETE {
OBSOLETE     log_ent_t	*mkdir;
OBSOLETE     long	op_no;
OBSOLETE     
OBSOLETE     mkdir = (log_ent_t *) malloc(sizeof(log_ent_t));
OBSOLETE     
OBSOLETE     mkdir->log_op = DIS_MKDIR;
OBSOLETE     mkdir->md_dirfid = dvc->fid;
OBSOLETE     /*Ba Wu: the data vers. for child dir*/
OBSOLETE     mkdir->md_dversion = dvc->DataVersion; 
OBSOLETE     mkdir->md_parentfid = pvc->fid;
OBSOLETE     mkdir->cred = pvc->cred;
OBSOLETE     mkdir->md_vattr = *attrs;
OBSOLETE     
OBSOLETE     /* save the name */
OBSOLETE     strcpy((char *) mkdir->md_name, name);
OBSOLETE     
OBSOLETE     /* calculate the length of this record */
OBSOLETE     mkdir->log_len = ((char *) mkdir->md_name - (char *) mkdir)
OBSOLETE 	+ strlen(name) + 1;
OBSOLETE     
OBSOLETE     op_no = write_log_ent(mkdir->log_len, mkdir);
OBSOLETE     
OBSOLETE     free(mkdir);
OBSOLETE     return op_no;
OBSOLETE }
OBSOLETE 
OBSOLETE 
OBSOLETE long
OBSOLETE log_dis_create(struct vcache *parent, struct vcache *child, char *name)
OBSOLETE {
OBSOLETE     log_ent_t *create;
OBSOLETE     long	op_no;
OBSOLETE     struct vcache *ch;
OBSOLETE     struct vcache *par;
OBSOLETE     
OBSOLETE     ch = child;
OBSOLETE     par = parent;
OBSOLETE     ch->DataVersion = child->DataVersion;
OBSOLETE     
OBSOLETE     create = (log_ent_t *) malloc(sizeof(log_ent_t));
OBSOLETE     
OBSOLETE     create->log_op = DIS_CREATE;
OBSOLETE     create->cr_filefid = ch->fid;
OBSOLETE     create->cr_parentfid = par->fid;
OBSOLETE     create->cr_origdv = ch->DataVersion;
OBSOLETE     create->cred = parent->cred;
OBSOLETE     
OBSOLETE     strcpy((char *) create->cr_name, name);
OBSOLETE     
OBSOLETE     create->log_len = ((char *) create->cr_name - (char *) create) +
OBSOLETE 	strlen(name) + 1;
OBSOLETE     
OBSOLETE     op_no = write_log_ent(create->log_len, create);
OBSOLETE     
OBSOLETE     free(create);
OBSOLETE     return op_no;
OBSOLETE }
OBSOLETE 
OBSOLETE #if 0
OBSOLETE long
OBSOLETE log_dis_remove(struct vcache *avc, FCacheEntry *childentry, char *name)
OBSOLETE {
OBSOLETE     log_ent_t	*remove;
OBSOLETE     long	op_no;
OBSOLETE     remove = (log_ent_t *) malloc(sizeof(log_ent_t));
OBSOLETE     
OBSOLETE     remove->log_op = DIS_REMOVE;
OBSOLETE     remove->cred = avc->cred;
OBSOLETE     remove->rm_filefid = avc->fid;
OBSOLETE     remove->rm_origdv = avc->DataVersion;
OBSOLETE     remove->rm_chentry = childentry;
OBSOLETE     
OBSOLETE     strcpy((char *) remove->rm_name, name);
OBSOLETE     
OBSOLETE     remove->log_len = ((char *) remove->rm_name - (char *) remove) +
OBSOLETE 	strlen(name) + 1;
OBSOLETE     
OBSOLETE     op_no = write_log_ent(remove->log_len, remove);
OBSOLETE     
OBSOLETE     free(remove);
OBSOLETE     arla_log(ADEBDISCONN, "remove: fid.Cell=%ld, fid.fid.Volume=%ld, "
OBSOLETE 	     "fid.Unique=%ld", \
OBSOLETE 	     remove->rm_filefid.Cell, 
OBSOLETE 	     remove->rm_filefid.fid.Volume,
OBSOLETE 	     remove->rm_filefid.fid.Unique);              
OBSOLETE     
OBSOLETE     return op_no;
OBSOLETE }
OBSOLETE 
OBSOLETE 
OBSOLETE long
OBSOLETE log_dis_rmdir(struct vcache *dir, FCacheEntry *cce, const char *name)
OBSOLETE {
OBSOLETE     log_ent_t	*rmdir;
OBSOLETE     long	op_no;
OBSOLETE     
OBSOLETE     rmdir = malloc(sizeof(log_ent_t));
OBSOLETE     
OBSOLETE     rmdir->log_op = DIS_RMDIR;
OBSOLETE     rmdir->cred = dir->cred;
OBSOLETE     rmdir->rd_parentfid = dir->fid;
OBSOLETE     rmdir->rd_direntry = cce;
OBSOLETE     
OBSOLETE     strcpy((char *) rmdir->rd_name, name);
OBSOLETE     
OBSOLETE     rmdir->log_len = ((char *) rmdir->rd_name - (char *) rmdir) +
OBSOLETE 	strlen(name) + 1;
OBSOLETE     
OBSOLETE     op_no = write_log_ent(rmdir->log_len, rmdir);
OBSOLETE     
OBSOLETE     free(rmdir);
OBSOLETE     return op_no;
OBSOLETE }
OBSOLETE 
OBSOLETE 
OBSOLETE long
OBSOLETE log_dis_rename(struct vcache *old_dir, char *old_name, 
OBSOLETE 	       struct vcache *new_dir, char *new_name)
OBSOLETE {
OBSOLETE     log_ent_t	*rename;
OBSOLETE     char *cp;
OBSOLETE     
OBSOLETE     rename = malloc(sizeof(log_ent_t));
OBSOLETE     
OBSOLETE     rename->log_op = DIS_RENAME;
OBSOLETE     rename->rn_oparentfid = old_dir->fid;
OBSOLETE     rename->rn_nparentfid = new_dir->fid;
OBSOLETE     rename->rn_origdv = old_dir->DataVersion;
OBSOLETE     rename->rn_overdv = new_dir->DataVersion;
OBSOLETE     rename->cred = old_dir->cred;
OBSOLETE     
OBSOLETE     strcpy((char *) rename->rn_names, old_name);
OBSOLETE     cp = (char *) rename->rn_names + strlen(old_name) + 1;
OBSOLETE     
OBSOLETE     strcpy((char *) cp, new_name);
OBSOLETE     cp += strlen(new_name) + 1;
OBSOLETE     
OBSOLETE     rename->log_len = (char *) cp - (char *) rename;
OBSOLETE     
OBSOLETE     write_log_ent(rename->log_len, rename);
OBSOLETE     
OBSOLETE     free(rename);
OBSOLETE     return 0;
OBSOLETE }
OBSOLETE 
OBSOLETE 
OBSOLETE 
OBSOLETE /* Log a link operation */
OBSOLETE long
OBSOLETE log_dis_link(struct vcache *pvc, struct vcache *lvc, char *name)
OBSOLETE 
OBSOLETE {
OBSOLETE     log_ent_t *link;
OBSOLETE     long	op_no;
OBSOLETE     
OBSOLETE     link = malloc(sizeof(log_ent_t));
OBSOLETE 
OBSOLETE     link->log_op = DIS_LINK;
OBSOLETE     link->cred   = pvc->cred;
OBSOLETE     link->ln_linkfid = lvc->fid;
OBSOLETE     link->ln_parentfid = pvc->fid;
OBSOLETE     
OBSOLETE     /* save the name */
OBSOLETE     strcpy((char *) link->ln_name, name);
OBSOLETE     /* calculate the length of this record */
OBSOLETE     link->log_len = ((char *) link->ln_name - (char *) link) +
OBSOLETE 	strlen(name) + 1;
OBSOLETE     
OBSOLETE     op_no = write_log_ent(link->log_len, link);
OBSOLETE     
OBSOLETE     free(link);
OBSOLETE     return op_no;
OBSOLETE }
OBSOLETE 
OBSOLETE /* Log a symlink operation */
OBSOLETE long
OBSOLETE log_dis_symlink(struct vcache *pvc, struct vcache *cvc, 
OBSOLETE 		AFSStoreStatus *attr, char *linkname, char *content)
OBSOLETE {
OBSOLETE     log_ent_t *slink;
OBSOLETE     long op_no;
OBSOLETE     
OBSOLETE     slink = malloc(sizeof(log_ent_t));
OBSOLETE     
OBSOLETE     slink->log_op = DIS_SYMLINK;
OBSOLETE     slink->sy_parentfid = pvc->fid;
OBSOLETE     slink->sy_filefid = cvc->fid;
OBSOLETE     slink->sy_attr = *attr;
OBSOLETE     slink->cred = pvc->cred;
OBSOLETE     
OBSOLETE     /* copy in the link name */
OBSOLETE     strcpy((char *) slink->sy_name, linkname);
OBSOLETE     strcpy((char *) slink->sy_content, content);
OBSOLETE     
OBSOLETE     /* calculate the length of this record */
OBSOLETE     slink->log_len = ( (char *) slink->sy_content -
OBSOLETE 		       (char *) slink) + 
OBSOLETE 	strlen(content) + 1;
OBSOLETE     
OBSOLETE     op_no = write_log_ent(slink->log_len, slink);
OBSOLETE     
OBSOLETE     free(slink);
OBSOLETE     return op_no;
OBSOLETE }
OBSOLETE #endif
OBSOLETE 
OBSOLETE /* Log a setattr operation */
OBSOLETE long
OBSOLETE log_dis_setattr(struct vcache *tvc, struct nnpfs_attr *attrs)
OBSOLETE {
OBSOLETE     log_ent_t	*setattr;
OBSOLETE     long op_no;
OBSOLETE     
OBSOLETE     setattr = (log_ent_t *) malloc(sizeof(log_ent_t));
OBSOLETE     
OBSOLETE     setattr->log_op = DIS_SETATTR;
OBSOLETE     setattr->sa_fid = tvc->fid;
OBSOLETE     setattr->cred = tvc->cred;
OBSOLETE     setattr->sa_origdv = tvc->DataVersion;
OBSOLETE     
OBSOLETE     setattr->sa_vattr = *attrs;
OBSOLETE     
OBSOLETE     /* calculate the length of this record */
OBSOLETE     setattr->log_len = ((char *) &setattr->sa_origdv - (char *) setattr) +
OBSOLETE 	sizeof(setattr->sa_origdv);
OBSOLETE     
OBSOLETE     op_no = write_log_ent(setattr->log_len, setattr);
OBSOLETE     
OBSOLETE     arla_log(ADEBDISCONN, "log_dis_setattr: fid.Cell=0x%x, fid.fid.Volume=0x%x,"
OBSOLETE 	     "fid.fid.Vnode=0x%x, fid.fid.Unique=0x%x", 
OBSOLETE 	     tvc->fid.Cell, 
OBSOLETE 	     tvc->fid.fid.Volume, 
OBSOLETE 	     tvc->fid.fid.Vnode, 
OBSOLETE 	     tvc->fid.fid.Unique);
OBSOLETE 
OBSOLETE     arla_log(ADEBDISCONN, "log_dis_setattr: writing %d byte log entry.");
OBSOLETE     
OBSOLETE     free(setattr);
OBSOLETE     return op_no;
OBSOLETE }
OBSOLETE 
OBSOLETE #if 0
OBSOLETE long
OBSOLETE log_dis_nonmutating(struct vcache *tvc, log_ops_t op)
OBSOLETE {
OBSOLETE #ifdef LOGNONMUTE
OBSOLETE     log_ent_t	*non_mute;
OBSOLETE     long	op_no;
OBSOLETE 
OBSOLETE     non_mute = (log_ent_t *) malloc(sizeof(log_ent_t));
OBSOLETE 
OBSOLETE     non_mute->log_op = op;
OBSOLETE     non_mute->cred = tvc->cred;
OBSOLETE     non_mute->nm_fid = tvc->fid;
OBSOLETE     non_mute->nm_origdv =  tvc->DataVersion;
OBSOLETE     non_mute->log_len = ((char *) &non_mute->nm_origdv -
OBSOLETE 			 (char *) non_mute) + sizeof(non_mute->nm_origdv);
OBSOLETE 
OBSOLETE     /* XXX lhuston removed for debugging */
OBSOLETE     op_no = write_log_ent(non_mute->log_len, non_mute);
OBSOLETE 
OBSOLETE     free(non_mute);
OBSOLETE     return op_no;
OBSOLETE #else
OBSOLETE     return 0; /*   0 was current_op_no */
OBSOLETE #endif
OBSOLETE }
OBSOLETE 
OBSOLETE 
OBSOLETE long
OBSOLETE log_dis_access(struct vcache *tvc)
OBSOLETE {
OBSOLETE     return log_dis_nonmutating(tvc, DIS_ACCESS);
OBSOLETE }
OBSOLETE 
OBSOLETE long
OBSOLETE log_dis_readdir(struct vcache *tvc)
OBSOLETE {
OBSOLETE     return log_dis_nonmutating(tvc, DIS_READDIR);
OBSOLETE }
OBSOLETE 
OBSOLETE long
OBSOLETE log_dis_readlink(struct vcache *tvc)
OBSOLETE {
OBSOLETE     return log_dis_nonmutating(tvc, DIS_READLINK);
OBSOLETE }
OBSOLETE 
OBSOLETE long
OBSOLETE log_dis_fsync(struct vcache *tvc)
OBSOLETE {
OBSOLETE     /* treat an fsync as a store */
OBSOLETE     return log_dis_nonmutating(tvc, DIS_FSYNC);
OBSOLETE }
OBSOLETE #endif
@


1.5
log
@Merge
@
text
@@


1.4
log
@more string cleaning; ok beck
@
text
@d1 473
a473 482
/* COPYRIGHT  (C)  1998
 * THE REGENTS OF THE UNIVERSITY OF MICHIGAN
 * ALL RIGHTS RESERVED
 * 
 * PERMISSION IS GRANTED TO USE, COPY, CREATE DERIVATIVE WORKS 
 * AND REDISTRIBUTE THIS SOFTWARE AND SUCH DERIVATIVE WORKS 
 * FOR ANY PURPOSE, SO LONG AS THE NAME OF THE UNIVERSITY OF 
 * MICHIGAN IS NOT USED IN ANY ADVERTISING OR PUBLICITY 
 * PERTAINING TO THE USE OR DISTRIBUTION OF THIS SOFTWARE 
 * WITHOUT SPECIFIC, WRITTEN PRIOR AUTHORIZATION.  IF THE 
 * ABOVE COPYRIGHT NOTICE OR ANY OTHER IDENTIFICATION OF THE 
 * UNIVERSITY OF MICHIGAN IS INCLUDED IN ANY COPY OF ANY 
 * PORTION OF THIS SOFTWARE, THEN THE DISCLAIMER BELOW MUST 
 * ALSO BE INCLUDED.
 * 
 * THIS SOFTWARE IS PROVIDED AS IS, WITHOUT REPRESENTATION 
 * FROM THE UNIVERSITY OF MICHIGAN AS TO ITS FITNESS FOR ANY 
 * PURPOSE, AND WITHOUT WARRANTY BY THE UNIVERSITY OF 
 * MICHIGAN OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING 
 * WITHOUT LIMITATION THE IMPLIED WARRANTIES OF 
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE 
 * REGENTS OF THE UNIVERSITY OF MICHIGAN SHALL NOT BE LIABLE 
 * FOR ANY DAMAGES, INCLUDING SPECIAL, INDIRECT, INCIDENTAL, OR 
 * CONSEQUENTIAL DAMAGES, WITH RESPECT TO ANY CLAIM ARISING 
 * OUT OF OR IN CONNECTION WITH THE USE OF THE SOFTWARE, EVEN 
 * IF IT HAS BEEN OR IS HEREAFTER ADVISED OF THE POSSIBILITY OF 
 * SUCH DAMAGES.
 */

/*
 * This file contains functions that relate to performance statistics
 * for disconnected operation.
 */

#include "arla_local.h"

RCSID("$KTH: discon_log.c,v 1.8.40.1 2001/06/04 22:16:35 ahltorp Exp $");

extern int dlog_mod;
extern long current_op_no;

extern DARLA_file log_data;

extern long  Log_is_open;

log_ent_t   log_head;

int DARLA_Open(DARLA_file *Dfp, char *fname, int oflag);
int DARLA_Read(DARLA_file *Dfp, char *cp, int len);
int DARLA_Write(DARLA_file *Dfp, char *cp, int len);
int DARLA_Seek(DARLA_file *Dfp, int offset, int whence);

#if 0
/*
 * read an entry from the log file described by tfile.  The result is
 * put into the log_ent data.  This return 0 if successful, 1 if
 * it failed to some reason ( ie. no more data ).
 */

int
read_log_ent(DARLA_file * tfile, log_ent_t *in_log)
{
    int len;
    char *bp;

    if (DARLA_Read(tfile, (char *) in_log, sizeof (int)) != sizeof(int))
	return 1;

    len = in_log->log_len - sizeof(int);
    bp = (char *) in_log + sizeof(int);

    if (DARLA_Read(tfile, bp, len) != len) {
	printf("read_log_ent: short read \n");
	return 1;
    }
    return 0;
}

void
update_log_ent(offset, flags)
long offset;
int flags;
{
    struct DARLA_file *tfile;
    log_ent_t *log_ent;
    int code;

    tfile = DARLA_UFSOpen(&log_data.bs_dev, log_data.bs_inode);
    if (!tfile)
	panic("update_log_ent: failed to open log file");

    DARLA_Seek(tfile, offset);

    log_ent = (log_ent_t *) malloc(sizeof(log_ent_t));
    code = read_log_ent(tfile, log_ent);

    if (code) {
	printf("update_log_ent: failed to read log entry at %d \n",
	       offset);
    } else {

	/* set the log flags */
	log_ent->log_flags |= flags;

	/* write the entry back out */
	DARLA_Seek(tfile, offset);
	DARLA_Write(tfile, (char *) log_ent, log_ent->log_len);
    }
    free(log_ent);
    DARLA_Close(tfile);
}
#endif


/* write the log entries to disk */
static long
write_log_ent(int len, log_ent_t *log)
{

    long new_num;
    static int index=0;

    arla_warnx (ADEBDISCONN,"We are writing a log");
    if (!Log_is_open) {
	return -1;
    }

    if (log_head.next == 0) { 
	log_head.next = (log_ent_t *) malloc(sizeof(log_ent_t));
	*log_head.next = *log;
	log_head.next->next = 0;
    }
    else {
        log->next = log_head.next;
        log_head.next = (log_ent_t *) malloc(sizeof(log_ent_t));
        *log_head.next = *log;
    }

    ObtainWriteLock(&log_data.bs_lock);

    new_num = 0;
  
    log->log_opno = new_num;
    gettimeofday(&log->log_time, 0);

    log->log_offset = log_data.offset;
    log->log_flags = 0;
    log->log_index = index++;

    DARLA_Write(&log_data, (char *) log, len);

    ReleaseWriteLock(&log_data.bs_lock);

    return (new_num);
}

long
log_dis_store(struct vcache *avc)
{
    log_ent_t	*store;
    long	op_no;
    
    store = (log_ent_t *) malloc(sizeof(log_ent_t));
    
    store->log_op = DIS_STORE;
    store->st_fid = avc->fid;
    store->st_origdv =  avc->DataVersion;
    store->st_flag = avc->flag;
    
    /* have to log cred as well */
    store->cred = avc->cred;
    
    /* figure out the length of a store entry */
    store->log_len = ((char *) &(store->st_origdv)) - ((char *) store)
	+ sizeof(store->st_origdv);
    
    op_no = write_log_ent(store->log_len, store);
    
    free(store);
    return op_no;
}


/* Log a mkdir operation */
long
log_dis_mkdir(struct vcache *pvc, struct vcache *dvc, 
	      AFSStoreStatus *attrs, char *name)
{
    log_ent_t	*mkdir;
    long	op_no;
    
    mkdir = (log_ent_t *) malloc(sizeof(log_ent_t));
    
    mkdir->log_op = DIS_MKDIR;
    mkdir->md_dirfid = dvc->fid;
    /*Ba Wu: the data vers. for child dir*/
    mkdir->md_dversion = dvc->DataVersion; 
    mkdir->md_parentfid = pvc->fid;
    mkdir->cred = pvc->cred;
    mkdir->md_vattr = *attrs;
    
    /* save the name */
    strlcpy((char *) mkdir->md_name, name, sizeof mkdir->md_name);
    
    /* calculate the length of this record */
    mkdir->log_len = ((char *) mkdir->md_name - (char *) mkdir)
	+ strlen(name) + 1;
    
    op_no = write_log_ent(mkdir->log_len, mkdir);
    
    free(mkdir);
    return op_no;
}


long
log_dis_create(struct vcache *parent, struct vcache *child, char *name)
{
    log_ent_t *create;
    long	op_no;
    struct vcache *ch;
    struct vcache *par;
    
    ch = child;
    par = parent;
    ch->DataVersion = child->DataVersion;
    
    create = (log_ent_t *) malloc(sizeof(log_ent_t));
    
    create->log_op = DIS_CREATE;
    create->cr_filefid = ch->fid;
    create->cr_parentfid = par->fid;
    create->cr_origdv = ch->DataVersion;
    create->cred = parent->cred;
    
    strlcpy((char *) create->cr_name, name, sizeof create->cr_name);
    
    create->log_len = ((char *) create->cr_name - (char *) create) +
	strlen(name) + 1;
    
    op_no = write_log_ent(create->log_len, create);
    
    free(create);
    return op_no;
}

#if 0
long
log_dis_remove(struct vcache *avc, FCacheEntry *childentry, char *name)
{
    log_ent_t	*remove;
    long	op_no;
    remove = (log_ent_t *) malloc(sizeof(log_ent_t));
    
    remove->log_op = DIS_REMOVE;
    remove->cred = avc->cred;
    remove->rm_filefid = avc->fid;
    remove->rm_origdv = avc->DataVersion;
    remove->rm_chentry = childentry;
    
    strlcpy((char *) remove->rm_name, name, sizeof remove->rm_name);
    
    remove->log_len = ((char *) remove->rm_name - (char *) remove) +
	strlen(name) + 1;
    
    op_no = write_log_ent(remove->log_len, remove);
    
    free(remove);
    arla_log(ADEBDISCONN, "remove: fid.Cell=%ld, fid.fid.Volume=%ld, "
	     "fid.Unique=%ld", \
	     remove->rm_filefid.Cell, 
	     remove->rm_filefid.fid.Volume,
	     remove->rm_filefid.fid.Unique);              
    
    return op_no;
}


long
log_dis_rmdir(struct vcache *dir, FCacheEntry *cce, const char *name)
{
    log_ent_t	*rmdir;
    long	op_no;
    
    rmdir = malloc(sizeof(log_ent_t));
    
    rmdir->log_op = DIS_RMDIR;
    rmdir->cred = dir->cred;
    rmdir->rd_parentfid = dir->fid;
    rmdir->rd_direntry = cce;
    
    strlcpy((char *) rmdir->rd_name, name, sizeof rmdir->rd_name);
    
    rmdir->log_len = ((char *) rmdir->rd_name - (char *) rmdir) +
	strlen(name) + 1;
    
    op_no = write_log_ent(rmdir->log_len, rmdir);
    
    free(rmdir);
    return op_no;
}


long
log_dis_rename(struct vcache *old_dir, char *old_name, 
	       struct vcache *new_dir, char *new_name)
{
    log_ent_t	*rename;
    char *cp;
    
    rename = malloc(sizeof(log_ent_t));
    
    rename->log_op = DIS_RENAME;
    rename->rn_oparentfid = old_dir->fid;
    rename->rn_nparentfid = new_dir->fid;
    rename->rn_origdv = old_dir->DataVersion;
    rename->rn_overdv = new_dir->DataVersion;
    rename->cred = old_dir->cred;
    
    strlcpy((char *) rename->rn_names, old_name, MAX_NAME);
    cp = (char *) rename->rn_names + strlen(old_name) + 1;
    
    strlcpy((char *) cp, new_name, MAX_NAME);
    cp += strlen(new_name) + 1;
    
    rename->log_len = (char *) cp - (char *) rename;
    
    write_log_ent(rename->log_len, rename);
    
    free(rename);
    return 0;
}



/* Log a link operation */
long
log_dis_link(struct vcache *pvc, struct vcache *lvc, char *name)

{
    log_ent_t *link;
    long	op_no;
    
    link = malloc(sizeof(log_ent_t));

    link->log_op = DIS_LINK;
    link->cred   = pvc->cred;
    link->ln_linkfid = lvc->fid;
    link->ln_parentfid = pvc->fid;
    
    /* save the name */
    strlcpy((char *) link->ln_name, name, sizeof link->ln_name);
    /* calculate the length of this record */
    link->log_len = ((char *) link->ln_name - (char *) link) +
	strlen(name) + 1;
    
    op_no = write_log_ent(link->log_len, link);
    
    free(link);
    return op_no;
}

/* Log a symlink operation */
long
log_dis_symlink(struct vcache *pvc, struct vcache *cvc, 
		AFSStoreStatus *attr, char *linkname, char *content)
{
    log_ent_t *slink;
    long op_no;
    
    slink = malloc(sizeof(log_ent_t));
    
    slink->log_op = DIS_SYMLINK;
    slink->sy_parentfid = pvc->fid;
    slink->sy_filefid = cvc->fid;
    slink->sy_attr = *attr;
    slink->cred = pvc->cred;
    
    /* copy in the link name */
    strlcpy((char *) slink->sy_name, linkname, sizeof slink->sy_name);
    strlcpy((char *) slink->sy_content, content, sizeof slink->sy_content);
    
    /* calculate the length of this record */
    slink->log_len = ( (char *) slink->sy_content -
		       (char *) slink) + 
	strlen(content) + 1;
    
    op_no = write_log_ent(slink->log_len, slink);
    
    free(slink);
    return op_no;
}
#endif

/* Log a setattr operation */
long
log_dis_setattr(struct vcache *tvc, struct xfs_attr *attrs)
{
    log_ent_t	*setattr;
    long op_no;
    
    setattr = (log_ent_t *) malloc(sizeof(log_ent_t));
    
    setattr->log_op = DIS_SETATTR;
    setattr->sa_fid = tvc->fid;
    setattr->cred = tvc->cred;
    setattr->sa_origdv = tvc->DataVersion;
    
    setattr->sa_vattr = *attrs;
    
    /* calculate the length of this record */
    setattr->log_len = ((char *) &setattr->sa_origdv - (char *) setattr) +
	sizeof(setattr->sa_origdv);
    
    op_no = write_log_ent(setattr->log_len, setattr);
    
    arla_log(ADEBDISCONN, "log_dis_setattr: fid.Cell=0x%x, fid.fid.Volume=0x%x,"
	     "fid.fid.Vnode=0x%x, fid.fid.Unique=0x%x", 
	     tvc->fid.Cell, 
	     tvc->fid.fid.Volume, 
	     tvc->fid.fid.Vnode, 
	     tvc->fid.fid.Unique);

    arla_log(ADEBDISCONN, "log_dis_setattr: writing %d byte log entry.");
    
    free(setattr);
    return op_no;
}

#if 0
long
log_dis_nonmutating(struct vcache *tvc, log_ops_t op)
{
#ifdef LOGNONMUTE
    log_ent_t	*non_mute;
    long	op_no;

    non_mute = (log_ent_t *) malloc(sizeof(log_ent_t));

    non_mute->log_op = op;
    non_mute->cred = tvc->cred;
    non_mute->nm_fid = tvc->fid;
    non_mute->nm_origdv =  tvc->DataVersion;
    non_mute->log_len = ((char *) &non_mute->nm_origdv -
			 (char *) non_mute) + sizeof(non_mute->nm_origdv);

    /* XXX lhuston removed for debugging */
    op_no = write_log_ent(non_mute->log_len, non_mute);

    free(non_mute);
    return op_no;
#else
    return 0; /*   0 was current_op_no */
#endif
}


long
log_dis_access(struct vcache *tvc)
{
    return log_dis_nonmutating(tvc, DIS_ACCESS);
}

long
log_dis_readdir(struct vcache *tvc)
{
    return log_dis_nonmutating(tvc, DIS_READDIR);
}

long
log_dis_readlink(struct vcache *tvc)
{
    return log_dis_nonmutating(tvc, DIS_READLINK);
}

long
log_dis_fsync(struct vcache *tvc)
{
    /* treat an fsync as a store */
    return log_dis_nonmutating(tvc, DIS_FSYNC);
}
#endif
@


1.3
log
@merge
@
text
@d203 1
a203 1
    strcpy((char *) mkdir->md_name, name);
d236 1
a236 1
    strcpy((char *) create->cr_name, name);
d261 1
a261 1
    strcpy((char *) remove->rm_name, name);
d292 1
a292 1
    strcpy((char *) rmdir->rd_name, name);
d320 1
a320 1
    strcpy((char *) rename->rn_names, old_name);
d323 1
a323 1
    strcpy((char *) cp, new_name);
d352 1
a352 1
    strcpy((char *) link->ln_name, name);
d380 2
a381 2
    strcpy((char *) slink->sy_name, linkname);
    strcpy((char *) slink->sy_content, content);
@


1.2
log
@New Arla userland from Arla between 0.34.2 and current in arla cvs.
Too many new features and fixes to mention here.
@
text
@d37 1
a37 1
RCSID("$Id: discon_log.c,v 1.8 1998/12/21 21:54:03 assar Exp $");
d53 1
a78 1
#if 0
d116 1
a116 1
long
d247 1
d393 1
a393 1

d430 1
d482 1
@


1.1
log
@upgrade Arla to fresher code. Too many new features and bugfixes.
@
text
@a0 1
/*	$OpenBSD$	*/
d37 1
a37 1
RCSID("$KTH: discon_log.c,v 1.8 1998/12/21 21:54:03 assar Exp $");
@


1.1.1.1
log
@Import of arla-0.35.7
@
text
@d1 1
d38 1
a38 1
RCSID("$KTH: discon_log.c,v 1.8.40.1 2001/06/04 22:16:35 ahltorp Exp $");
a53 1
#if 0
d79 1
d117 1
a117 1
static long
a247 1
#if 0
d393 1
a393 1
#endif
a429 1
#if 0
a480 1
#endif
@


1.1.1.2
log
@Import of arla -current as of Aug 5 2003

ok todd@@ deraadt@@
@
text
@d1 482
a482 473
OBSOLETE /* COPYRIGHT  (C)  1998
OBSOLETE  * THE REGENTS OF THE UNIVERSITY OF MICHIGAN
OBSOLETE  * ALL RIGHTS RESERVED
OBSOLETE  * 
OBSOLETE  * PERMISSION IS GRANTED TO USE, COPY, CREATE DERIVATIVE WORKS 
OBSOLETE  * AND REDISTRIBUTE THIS SOFTWARE AND SUCH DERIVATIVE WORKS 
OBSOLETE  * FOR ANY PURPOSE, SO LONG AS THE NAME OF THE UNIVERSITY OF 
OBSOLETE  * MICHIGAN IS NOT USED IN ANY ADVERTISING OR PUBLICITY 
OBSOLETE  * PERTAINING TO THE USE OR DISTRIBUTION OF THIS SOFTWARE 
OBSOLETE  * WITHOUT SPECIFIC, WRITTEN PRIOR AUTHORIZATION.  IF THE 
OBSOLETE  * ABOVE COPYRIGHT NOTICE OR ANY OTHER IDENTIFICATION OF THE 
OBSOLETE  * UNIVERSITY OF MICHIGAN IS INCLUDED IN ANY COPY OF ANY 
OBSOLETE  * PORTION OF THIS SOFTWARE, THEN THE DISCLAIMER BELOW MUST 
OBSOLETE  * ALSO BE INCLUDED.
OBSOLETE  * 
OBSOLETE  * THIS SOFTWARE IS PROVIDED AS IS, WITHOUT REPRESENTATION 
OBSOLETE  * FROM THE UNIVERSITY OF MICHIGAN AS TO ITS FITNESS FOR ANY 
OBSOLETE  * PURPOSE, AND WITHOUT WARRANTY BY THE UNIVERSITY OF 
OBSOLETE  * MICHIGAN OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING 
OBSOLETE  * WITHOUT LIMITATION THE IMPLIED WARRANTIES OF 
OBSOLETE  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE 
OBSOLETE  * REGENTS OF THE UNIVERSITY OF MICHIGAN SHALL NOT BE LIABLE 
OBSOLETE  * FOR ANY DAMAGES, INCLUDING SPECIAL, INDIRECT, INCIDENTAL, OR 
OBSOLETE  * CONSEQUENTIAL DAMAGES, WITH RESPECT TO ANY CLAIM ARISING 
OBSOLETE  * OUT OF OR IN CONNECTION WITH THE USE OF THE SOFTWARE, EVEN 
OBSOLETE  * IF IT HAS BEEN OR IS HEREAFTER ADVISED OF THE POSSIBILITY OF 
OBSOLETE  * SUCH DAMAGES.
OBSOLETE  */
OBSOLETE 
OBSOLETE /*
OBSOLETE  * This file contains functions that relate to performance statistics
OBSOLETE  * for disconnected operation.
OBSOLETE  */
OBSOLETE 
OBSOLETE #include "arla_local.h"
OBSOLETE 
OBSOLETE RCSID("$arla: discon_log.c,v 1.12 2002/09/07 10:43:05 lha Exp $");
OBSOLETE 
OBSOLETE int Log_is_open;
OBSOLETE DARLA_file log_data;
OBSOLETE 
OBSOLETE log_ent_t   log_head;
OBSOLETE 
OBSOLETE #if 0
OBSOLETE /*
OBSOLETE  * read an entry from the log file described by tfile.  The result is
OBSOLETE  * put into the log_ent data.  This return 0 if successful, 1 if
OBSOLETE  * it failed to some reason ( ie. no more data ).
OBSOLETE  */
OBSOLETE 
OBSOLETE int
OBSOLETE read_log_ent(DARLA_file * tfile, log_ent_t *in_log)
OBSOLETE {
OBSOLETE     int len;
OBSOLETE     char *bp;
OBSOLETE 
OBSOLETE     if (DARLA_Read(tfile, (char *) in_log, sizeof (int)) != sizeof(int))
OBSOLETE 	return 1;
OBSOLETE 
OBSOLETE     len = in_log->log_len - sizeof(int);
OBSOLETE     bp = (char *) in_log + sizeof(int);
OBSOLETE 
OBSOLETE     if (DARLA_Read(tfile, bp, len) != len) {
OBSOLETE 	printf("read_log_ent: short read \n");
OBSOLETE 	return 1;
OBSOLETE     }
OBSOLETE     return 0;
OBSOLETE }
OBSOLETE 
OBSOLETE void
OBSOLETE update_log_ent(offset, flags)
OBSOLETE long offset;
OBSOLETE int flags;
OBSOLETE {
OBSOLETE     struct DARLA_file *tfile;
OBSOLETE     log_ent_t *log_ent;
OBSOLETE     int code;
OBSOLETE 
OBSOLETE     tfile = DARLA_UFSOpen(&log_data.bs_dev, log_data.bs_inode);
OBSOLETE     if (!tfile)
OBSOLETE 	panic("update_log_ent: failed to open log file");
OBSOLETE 
OBSOLETE     DARLA_Seek(tfile, offset);
OBSOLETE 
OBSOLETE     log_ent = (log_ent_t *) malloc(sizeof(log_ent_t));
OBSOLETE     code = read_log_ent(tfile, log_ent);
OBSOLETE 
OBSOLETE     if (code) {
OBSOLETE 	printf("update_log_ent: failed to read log entry at %d \n",
OBSOLETE 	       offset);
OBSOLETE     } else {
OBSOLETE 
OBSOLETE 	/* set the log flags */
OBSOLETE 	log_ent->log_flags |= flags;
OBSOLETE 
OBSOLETE 	/* write the entry back out */
OBSOLETE 	DARLA_Seek(tfile, offset);
OBSOLETE 	DARLA_Write(tfile, (char *) log_ent, log_ent->log_len);
OBSOLETE     }
OBSOLETE     free(log_ent);
OBSOLETE     DARLA_Close(tfile);
OBSOLETE }
OBSOLETE #endif
OBSOLETE 
OBSOLETE 
OBSOLETE /* write the log entries to disk */
OBSOLETE static long
OBSOLETE write_log_ent(int len, log_ent_t *log)
OBSOLETE {
OBSOLETE 
OBSOLETE     long new_num;
OBSOLETE     static int index=0;
OBSOLETE 
OBSOLETE     arla_warnx (ADEBDISCONN,"We are writing a log");
OBSOLETE     if (!Log_is_open) {
OBSOLETE 	return -1;
OBSOLETE     }
OBSOLETE 
OBSOLETE     if (log_head.next == 0) { 
OBSOLETE 	log_head.next = (log_ent_t *) malloc(sizeof(log_ent_t));
OBSOLETE 	*log_head.next = *log;
OBSOLETE 	log_head.next->next = 0;
OBSOLETE     }
OBSOLETE     else {
OBSOLETE         log->next = log_head.next;
OBSOLETE         log_head.next = (log_ent_t *) malloc(sizeof(log_ent_t));
OBSOLETE         *log_head.next = *log;
OBSOLETE     }
OBSOLETE 
OBSOLETE     ObtainWriteLock(&log_data.bs_lock);
OBSOLETE 
OBSOLETE     new_num = 0;
OBSOLETE   
OBSOLETE     log->log_opno = new_num;
OBSOLETE     gettimeofday(&log->log_time, 0);
OBSOLETE 
OBSOLETE     log->log_offset = log_data.offset;
OBSOLETE     log->log_flags = 0;
OBSOLETE     log->log_index = index++;
OBSOLETE 
OBSOLETE     DARLA_Write(&log_data, (char *) log, len);
OBSOLETE 
OBSOLETE     ReleaseWriteLock(&log_data.bs_lock);
OBSOLETE 
OBSOLETE     return (new_num);
OBSOLETE }
OBSOLETE 
OBSOLETE long
OBSOLETE log_dis_store(struct vcache *avc)
OBSOLETE {
OBSOLETE     log_ent_t	*store;
OBSOLETE     long	op_no;
OBSOLETE     
OBSOLETE     store = (log_ent_t *) malloc(sizeof(log_ent_t));
OBSOLETE     
OBSOLETE     store->log_op = DIS_STORE;
OBSOLETE     store->st_fid = avc->fid;
OBSOLETE     store->st_origdv =  avc->DataVersion;
OBSOLETE     store->st_flag = avc->flag;
OBSOLETE     
OBSOLETE     /* have to log cred as well */
OBSOLETE     store->cred = avc->cred;
OBSOLETE     
OBSOLETE     /* figure out the length of a store entry */
OBSOLETE     store->log_len = ((char *) &(store->st_origdv)) - ((char *) store)
OBSOLETE 	+ sizeof(store->st_origdv);
OBSOLETE     
OBSOLETE     op_no = write_log_ent(store->log_len, store);
OBSOLETE     
OBSOLETE     free(store);
OBSOLETE     return op_no;
OBSOLETE }
OBSOLETE 
OBSOLETE 
OBSOLETE /* Log a mkdir operation */
OBSOLETE long
OBSOLETE log_dis_mkdir(struct vcache *pvc, struct vcache *dvc, 
OBSOLETE 	      AFSStoreStatus *attrs, char *name)
OBSOLETE {
OBSOLETE     log_ent_t	*mkdir;
OBSOLETE     long	op_no;
OBSOLETE     
OBSOLETE     mkdir = (log_ent_t *) malloc(sizeof(log_ent_t));
OBSOLETE     
OBSOLETE     mkdir->log_op = DIS_MKDIR;
OBSOLETE     mkdir->md_dirfid = dvc->fid;
OBSOLETE     /*Ba Wu: the data vers. for child dir*/
OBSOLETE     mkdir->md_dversion = dvc->DataVersion; 
OBSOLETE     mkdir->md_parentfid = pvc->fid;
OBSOLETE     mkdir->cred = pvc->cred;
OBSOLETE     mkdir->md_vattr = *attrs;
OBSOLETE     
OBSOLETE     /* save the name */
OBSOLETE     strcpy((char *) mkdir->md_name, name);
OBSOLETE     
OBSOLETE     /* calculate the length of this record */
OBSOLETE     mkdir->log_len = ((char *) mkdir->md_name - (char *) mkdir)
OBSOLETE 	+ strlen(name) + 1;
OBSOLETE     
OBSOLETE     op_no = write_log_ent(mkdir->log_len, mkdir);
OBSOLETE     
OBSOLETE     free(mkdir);
OBSOLETE     return op_no;
OBSOLETE }
OBSOLETE 
OBSOLETE 
OBSOLETE long
OBSOLETE log_dis_create(struct vcache *parent, struct vcache *child, char *name)
OBSOLETE {
OBSOLETE     log_ent_t *create;
OBSOLETE     long	op_no;
OBSOLETE     struct vcache *ch;
OBSOLETE     struct vcache *par;
OBSOLETE     
OBSOLETE     ch = child;
OBSOLETE     par = parent;
OBSOLETE     ch->DataVersion = child->DataVersion;
OBSOLETE     
OBSOLETE     create = (log_ent_t *) malloc(sizeof(log_ent_t));
OBSOLETE     
OBSOLETE     create->log_op = DIS_CREATE;
OBSOLETE     create->cr_filefid = ch->fid;
OBSOLETE     create->cr_parentfid = par->fid;
OBSOLETE     create->cr_origdv = ch->DataVersion;
OBSOLETE     create->cred = parent->cred;
OBSOLETE     
OBSOLETE     strcpy((char *) create->cr_name, name);
OBSOLETE     
OBSOLETE     create->log_len = ((char *) create->cr_name - (char *) create) +
OBSOLETE 	strlen(name) + 1;
OBSOLETE     
OBSOLETE     op_no = write_log_ent(create->log_len, create);
OBSOLETE     
OBSOLETE     free(create);
OBSOLETE     return op_no;
OBSOLETE }
OBSOLETE 
OBSOLETE #if 0
OBSOLETE long
OBSOLETE log_dis_remove(struct vcache *avc, FCacheEntry *childentry, char *name)
OBSOLETE {
OBSOLETE     log_ent_t	*remove;
OBSOLETE     long	op_no;
OBSOLETE     remove = (log_ent_t *) malloc(sizeof(log_ent_t));
OBSOLETE     
OBSOLETE     remove->log_op = DIS_REMOVE;
OBSOLETE     remove->cred = avc->cred;
OBSOLETE     remove->rm_filefid = avc->fid;
OBSOLETE     remove->rm_origdv = avc->DataVersion;
OBSOLETE     remove->rm_chentry = childentry;
OBSOLETE     
OBSOLETE     strcpy((char *) remove->rm_name, name);
OBSOLETE     
OBSOLETE     remove->log_len = ((char *) remove->rm_name - (char *) remove) +
OBSOLETE 	strlen(name) + 1;
OBSOLETE     
OBSOLETE     op_no = write_log_ent(remove->log_len, remove);
OBSOLETE     
OBSOLETE     free(remove);
OBSOLETE     arla_log(ADEBDISCONN, "remove: fid.Cell=%ld, fid.fid.Volume=%ld, "
OBSOLETE 	     "fid.Unique=%ld", \
OBSOLETE 	     remove->rm_filefid.Cell, 
OBSOLETE 	     remove->rm_filefid.fid.Volume,
OBSOLETE 	     remove->rm_filefid.fid.Unique);              
OBSOLETE     
OBSOLETE     return op_no;
OBSOLETE }
OBSOLETE 
OBSOLETE 
OBSOLETE long
OBSOLETE log_dis_rmdir(struct vcache *dir, FCacheEntry *cce, const char *name)
OBSOLETE {
OBSOLETE     log_ent_t	*rmdir;
OBSOLETE     long	op_no;
OBSOLETE     
OBSOLETE     rmdir = malloc(sizeof(log_ent_t));
OBSOLETE     
OBSOLETE     rmdir->log_op = DIS_RMDIR;
OBSOLETE     rmdir->cred = dir->cred;
OBSOLETE     rmdir->rd_parentfid = dir->fid;
OBSOLETE     rmdir->rd_direntry = cce;
OBSOLETE     
OBSOLETE     strcpy((char *) rmdir->rd_name, name);
OBSOLETE     
OBSOLETE     rmdir->log_len = ((char *) rmdir->rd_name - (char *) rmdir) +
OBSOLETE 	strlen(name) + 1;
OBSOLETE     
OBSOLETE     op_no = write_log_ent(rmdir->log_len, rmdir);
OBSOLETE     
OBSOLETE     free(rmdir);
OBSOLETE     return op_no;
OBSOLETE }
OBSOLETE 
OBSOLETE 
OBSOLETE long
OBSOLETE log_dis_rename(struct vcache *old_dir, char *old_name, 
OBSOLETE 	       struct vcache *new_dir, char *new_name)
OBSOLETE {
OBSOLETE     log_ent_t	*rename;
OBSOLETE     char *cp;
OBSOLETE     
OBSOLETE     rename = malloc(sizeof(log_ent_t));
OBSOLETE     
OBSOLETE     rename->log_op = DIS_RENAME;
OBSOLETE     rename->rn_oparentfid = old_dir->fid;
OBSOLETE     rename->rn_nparentfid = new_dir->fid;
OBSOLETE     rename->rn_origdv = old_dir->DataVersion;
OBSOLETE     rename->rn_overdv = new_dir->DataVersion;
OBSOLETE     rename->cred = old_dir->cred;
OBSOLETE     
OBSOLETE     strcpy((char *) rename->rn_names, old_name);
OBSOLETE     cp = (char *) rename->rn_names + strlen(old_name) + 1;
OBSOLETE     
OBSOLETE     strcpy((char *) cp, new_name);
OBSOLETE     cp += strlen(new_name) + 1;
OBSOLETE     
OBSOLETE     rename->log_len = (char *) cp - (char *) rename;
OBSOLETE     
OBSOLETE     write_log_ent(rename->log_len, rename);
OBSOLETE     
OBSOLETE     free(rename);
OBSOLETE     return 0;
OBSOLETE }
OBSOLETE 
OBSOLETE 
OBSOLETE 
OBSOLETE /* Log a link operation */
OBSOLETE long
OBSOLETE log_dis_link(struct vcache *pvc, struct vcache *lvc, char *name)
OBSOLETE 
OBSOLETE {
OBSOLETE     log_ent_t *link;
OBSOLETE     long	op_no;
OBSOLETE     
OBSOLETE     link = malloc(sizeof(log_ent_t));
OBSOLETE 
OBSOLETE     link->log_op = DIS_LINK;
OBSOLETE     link->cred   = pvc->cred;
OBSOLETE     link->ln_linkfid = lvc->fid;
OBSOLETE     link->ln_parentfid = pvc->fid;
OBSOLETE     
OBSOLETE     /* save the name */
OBSOLETE     strcpy((char *) link->ln_name, name);
OBSOLETE     /* calculate the length of this record */
OBSOLETE     link->log_len = ((char *) link->ln_name - (char *) link) +
OBSOLETE 	strlen(name) + 1;
OBSOLETE     
OBSOLETE     op_no = write_log_ent(link->log_len, link);
OBSOLETE     
OBSOLETE     free(link);
OBSOLETE     return op_no;
OBSOLETE }
OBSOLETE 
OBSOLETE /* Log a symlink operation */
OBSOLETE long
OBSOLETE log_dis_symlink(struct vcache *pvc, struct vcache *cvc, 
OBSOLETE 		AFSStoreStatus *attr, char *linkname, char *content)
OBSOLETE {
OBSOLETE     log_ent_t *slink;
OBSOLETE     long op_no;
OBSOLETE     
OBSOLETE     slink = malloc(sizeof(log_ent_t));
OBSOLETE     
OBSOLETE     slink->log_op = DIS_SYMLINK;
OBSOLETE     slink->sy_parentfid = pvc->fid;
OBSOLETE     slink->sy_filefid = cvc->fid;
OBSOLETE     slink->sy_attr = *attr;
OBSOLETE     slink->cred = pvc->cred;
OBSOLETE     
OBSOLETE     /* copy in the link name */
OBSOLETE     strcpy((char *) slink->sy_name, linkname);
OBSOLETE     strcpy((char *) slink->sy_content, content);
OBSOLETE     
OBSOLETE     /* calculate the length of this record */
OBSOLETE     slink->log_len = ( (char *) slink->sy_content -
OBSOLETE 		       (char *) slink) + 
OBSOLETE 	strlen(content) + 1;
OBSOLETE     
OBSOLETE     op_no = write_log_ent(slink->log_len, slink);
OBSOLETE     
OBSOLETE     free(slink);
OBSOLETE     return op_no;
OBSOLETE }
OBSOLETE #endif
OBSOLETE 
OBSOLETE /* Log a setattr operation */
OBSOLETE long
OBSOLETE log_dis_setattr(struct vcache *tvc, struct nnpfs_attr *attrs)
OBSOLETE {
OBSOLETE     log_ent_t	*setattr;
OBSOLETE     long op_no;
OBSOLETE     
OBSOLETE     setattr = (log_ent_t *) malloc(sizeof(log_ent_t));
OBSOLETE     
OBSOLETE     setattr->log_op = DIS_SETATTR;
OBSOLETE     setattr->sa_fid = tvc->fid;
OBSOLETE     setattr->cred = tvc->cred;
OBSOLETE     setattr->sa_origdv = tvc->DataVersion;
OBSOLETE     
OBSOLETE     setattr->sa_vattr = *attrs;
OBSOLETE     
OBSOLETE     /* calculate the length of this record */
OBSOLETE     setattr->log_len = ((char *) &setattr->sa_origdv - (char *) setattr) +
OBSOLETE 	sizeof(setattr->sa_origdv);
OBSOLETE     
OBSOLETE     op_no = write_log_ent(setattr->log_len, setattr);
OBSOLETE     
OBSOLETE     arla_log(ADEBDISCONN, "log_dis_setattr: fid.Cell=0x%x, fid.fid.Volume=0x%x,"
OBSOLETE 	     "fid.fid.Vnode=0x%x, fid.fid.Unique=0x%x", 
OBSOLETE 	     tvc->fid.Cell, 
OBSOLETE 	     tvc->fid.fid.Volume, 
OBSOLETE 	     tvc->fid.fid.Vnode, 
OBSOLETE 	     tvc->fid.fid.Unique);
OBSOLETE 
OBSOLETE     arla_log(ADEBDISCONN, "log_dis_setattr: writing %d byte log entry.");
OBSOLETE     
OBSOLETE     free(setattr);
OBSOLETE     return op_no;
OBSOLETE }
OBSOLETE 
OBSOLETE #if 0
OBSOLETE long
OBSOLETE log_dis_nonmutating(struct vcache *tvc, log_ops_t op)
OBSOLETE {
OBSOLETE #ifdef LOGNONMUTE
OBSOLETE     log_ent_t	*non_mute;
OBSOLETE     long	op_no;
OBSOLETE 
OBSOLETE     non_mute = (log_ent_t *) malloc(sizeof(log_ent_t));
OBSOLETE 
OBSOLETE     non_mute->log_op = op;
OBSOLETE     non_mute->cred = tvc->cred;
OBSOLETE     non_mute->nm_fid = tvc->fid;
OBSOLETE     non_mute->nm_origdv =  tvc->DataVersion;
OBSOLETE     non_mute->log_len = ((char *) &non_mute->nm_origdv -
OBSOLETE 			 (char *) non_mute) + sizeof(non_mute->nm_origdv);
OBSOLETE 
OBSOLETE     /* XXX lhuston removed for debugging */
OBSOLETE     op_no = write_log_ent(non_mute->log_len, non_mute);
OBSOLETE 
OBSOLETE     free(non_mute);
OBSOLETE     return op_no;
OBSOLETE #else
OBSOLETE     return 0; /*   0 was current_op_no */
OBSOLETE #endif
OBSOLETE }
OBSOLETE 
OBSOLETE 
OBSOLETE long
OBSOLETE log_dis_access(struct vcache *tvc)
OBSOLETE {
OBSOLETE     return log_dis_nonmutating(tvc, DIS_ACCESS);
OBSOLETE }
OBSOLETE 
OBSOLETE long
OBSOLETE log_dis_readdir(struct vcache *tvc)
OBSOLETE {
OBSOLETE     return log_dis_nonmutating(tvc, DIS_READDIR);
OBSOLETE }
OBSOLETE 
OBSOLETE long
OBSOLETE log_dis_readlink(struct vcache *tvc)
OBSOLETE {
OBSOLETE     return log_dis_nonmutating(tvc, DIS_READLINK);
OBSOLETE }
OBSOLETE 
OBSOLETE long
OBSOLETE log_dis_fsync(struct vcache *tvc)
OBSOLETE {
OBSOLETE     /* treat an fsync as a store */
OBSOLETE     return log_dis_nonmutating(tvc, DIS_FSYNC);
OBSOLETE }
OBSOLETE #endif
@


