head	1.10;
access;
symbols
	OPENBSD_5_2:1.9.0.12
	OPENBSD_5_2_BASE:1.9
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.10
	OPENBSD_5_0:1.9.0.8
	OPENBSD_5_0_BASE:1.9
	OPENBSD_4_9:1.9.0.6
	OPENBSD_4_9_BASE:1.9
	OPENBSD_4_8:1.9.0.4
	OPENBSD_4_8_BASE:1.9
	OPENBSD_4_7:1.9.0.2
	OPENBSD_4_7_BASE:1.9
	OPENBSD_4_6:1.8.0.16
	OPENBSD_4_6_BASE:1.8
	OPENBSD_4_5:1.8.0.12
	OPENBSD_4_5_BASE:1.8
	OPENBSD_4_4:1.8.0.10
	OPENBSD_4_4_BASE:1.8
	OPENBSD_4_3:1.8.0.8
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.8.0.6
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.8.0.4
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.8.0.2
	OPENBSD_4_0_BASE:1.8
	OPENBSD_3_9:1.7.0.10
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.7.0.8
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.6
	OPENBSD_3_7_BASE:1.7
	OPENBSD_3_6:1.7.0.4
	OPENBSD_3_6_BASE:1.7
	OPENBSD_3_5:1.7.0.2
	OPENBSD_3_5_BASE:1.7
	OPENBSD_3_4:1.6.0.2
	OPENBSD_3_4_BASE:1.6
	arla-20030805:1.1.1.3
	OPENBSD_3_3:1.4.0.4
	OPENBSD_3_3_BASE:1.4
	OPENBSD_3_2:1.4.0.2
	OPENBSD_3_2_BASE:1.4
	arla-0-35-7:1.1.1.2
	OPENBSD_3_1:1.3.0.8
	OPENBSD_3_1_BASE:1.3
	OPENBSD_3_0:1.3.0.6
	OPENBSD_3_0_BASE:1.3
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_9:1.3.0.4
	OPENBSD_2_8:1.3.0.2
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.2.0.4
	OPENBSD_2_7_BASE:1.2
	OPENBSD_2_6:1.2.0.2
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.1.1.1.0.4
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.2
	OPENBSD_2_4_BASE:1.1.1.1
	arla-0_9:1.1.1.1
	arla:1.1.1;
locks; strict;
comment	@ * @;


1.10
date	2012.08.23.06.21.50;	author deraadt;	state dead;
branches;
next	1.9;

1.9
date	2009.12.14.16.26.19;	author beck;	state Exp;
branches;
next	1.8;

1.8
date	2006.04.02.21.38.56;	author djm;	state Exp;
branches;
next	1.7;

1.7
date	2004.02.27.19.17.36;	author beck;	state Exp;
branches;
next	1.6;

1.6
date	2003.08.05.08.42.41;	author hin;	state Exp;
branches;
next	1.5;

1.5
date	2003.04.28.19.30.27;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2002.06.07.04.28.57;	author hin;	state Exp;
branches;
next	1.3;

1.3
date	2000.09.11.14.40.43;	author art;	state Exp;
branches;
next	1.2;

1.2
date	99.04.30.01.59.09;	author art;	state Exp;
branches;
next	1.1;

1.1
date	98.09.14.21.52.54;	author art;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.09.14.21.52.54;	author art;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.06.07.04.14.24;	author hin;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2003.08.05.08.21.01;	author hin;	state Exp;
branches;
next	;


desc
@@


1.10
log
@the afs src tree can go away
@
text
@/*
 * Copyright (c) 1995-2003 Kungliga Tekniska Högskolan
 * (Royal Institute of Technology, Stockholm, Sweden).
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include "arla_local.h"
RCSID("$arla: messages.c,v 1.318 2003/06/10 04:23:31 lha Exp $");

#include <nnpfs/nnpfs_message.h>

#ifdef HAVE_SYS_IOCTL_H
#include <sys/ioctl.h>
#endif
#include <kafs.h>

#include "messages.h"

static int 
nnpfs_message_getroot (int, struct nnpfs_message_getroot*, u_int);

static int 
nnpfs_message_getnode (int, struct nnpfs_message_getnode*, u_int);

static int 
nnpfs_message_getattr (int, struct nnpfs_message_getattr*, u_int);

static int 
nnpfs_message_open (int, struct nnpfs_message_open*, u_int);

static int 
nnpfs_message_getdata (int, struct nnpfs_message_getdata*, u_int);

static int 
nnpfs_message_inactivenode (int,struct nnpfs_message_inactivenode*,u_int);

static int 
nnpfs_message_putdata (int fd, struct nnpfs_message_putdata *h, u_int size);

static int
nnpfs_message_putattr (int fd, struct nnpfs_message_putattr *h, u_int size);

static int
nnpfs_message_create (int fd, struct nnpfs_message_create *h, u_int size);

static int
nnpfs_message_mkdir (int fd, struct nnpfs_message_mkdir *h, u_int size);

static int
nnpfs_message_link (int fd, struct nnpfs_message_link *h, u_int size);

static int
nnpfs_message_symlink (int fd, struct nnpfs_message_symlink *h, u_int size);

static int
nnpfs_message_remove (int fd, struct nnpfs_message_remove *h, u_int size);

static int
nnpfs_message_rmdir (int fd, struct nnpfs_message_rmdir *h, u_int size);

static int
nnpfs_message_rename (int fd, struct nnpfs_message_rename *h, u_int size);

static int
nnpfs_message_pioctl (int fd, struct nnpfs_message_pioctl *h, u_int size) ;

static u_char
afsrights2nnpfsrights(u_long, uint32_t, uint32_t);

static int
possibly_have_network(void);

/*
 *
 */

nnpfs_message_function rcvfuncs[] = {
    NULL,						/* version */
    (nnpfs_message_function)nnpfs_message_wakeup,	/* wakeup */
    (nnpfs_message_function)nnpfs_message_getroot,	/* getroot */
    NULL,						/* installroot */
    (nnpfs_message_function)nnpfs_message_getnode, 	/* getnode */
    NULL,						/* installnode */
    (nnpfs_message_function)nnpfs_message_getattr,	/* getattr */
    NULL,						/* installattr */
    (nnpfs_message_function)nnpfs_message_getdata,	/* getdata */
    NULL,						/* installdata */
    (nnpfs_message_function)nnpfs_message_inactivenode,	/* inactivenode */
    NULL,						/* invalidnode */
    (nnpfs_message_function)nnpfs_message_open,		/* open */
    (nnpfs_message_function)nnpfs_message_putdata,      /* put_data */
    (nnpfs_message_function)nnpfs_message_putattr,      /* put attr */
    (nnpfs_message_function)nnpfs_message_create,       /* create */
    (nnpfs_message_function)nnpfs_message_mkdir,	/* mkdir */
    (nnpfs_message_function)nnpfs_message_link,		/* link */
    (nnpfs_message_function)nnpfs_message_symlink,      /* symlink */
    (nnpfs_message_function)nnpfs_message_remove,	/* remove */
    (nnpfs_message_function)nnpfs_message_rmdir,	/* rmdir */
    (nnpfs_message_function)nnpfs_message_rename,	/* rename */
    (nnpfs_message_function)nnpfs_message_pioctl,	/* pioctl */
    NULL,	                                        /* wakeup_data */
    NULL,						/* updatefid */
    NULL,						/* advlock */
    NULL						/* gc nodes */
};


/*
 *
 */

long
afsfid2inode (const VenusFid *fid)
{
    return ((fid->fid.Volume & 0x7FFF) << 16 | (fid->fid.Vnode & 0xFFFFFFFF));
}

/*
 * AFSFetchStatus -> nnpfs_attr
 * Setting everything except for length and mode.
 */

static void
afsstatus2nnpfs_attr (AFSFetchStatus *status,
		      const VenusFid *fid,
		      struct nnpfs_attr *attr,
		      int flags)
{
    int mode;

    attr->valid = XA_V_NONE;
    switch (status->FileType) {
    case TYPE_FILE :
	mode = S_IFREG;
	XA_SET_TYPE(attr, NNPFS_FILE_REG);
	break;
    case TYPE_DIR :
	mode = S_IFDIR;
	XA_SET_TYPE(attr, NNPFS_FILE_DIR);
	break;
    case TYPE_LINK :
	mode = S_IFLNK;
	XA_SET_TYPE(attr, NNPFS_FILE_LNK);
	break;
    default :
	arla_warnx (ADEBMSG, "afsstatus2nnpfs_attr: default");
	abort ();
    }
    XA_SET_NLINK(attr, status->LinkCount);
    if (flags & FCACHE2NNPFSNODE_LENGTH)
	XA_SET_SIZE(attr, status->Length);
    XA_SET_UID(attr,status->Owner);
    XA_SET_GID(attr, status->Group);
    XA_SET_ATIME(attr, status->ClientModTime);
    XA_SET_MTIME(attr, status->ClientModTime);
    XA_SET_CTIME(attr, status->ClientModTime);
    XA_SET_FILEID(attr, afsfid2inode(fid));

    /* XXX this is wrong, need to keep track of `our` ae for this req */
    if (fake_stat) {
	u_char rights;
	
	rights = afsrights2nnpfsrights(status->CallerAccess,
				       status->FileType,
				       status->UnixModeBits);
	
	if (rights & NNPFS_RIGHT_R)
	    mode |= 0444;
	if (rights & NNPFS_RIGHT_W)
	    mode |= 0222;
	if (rights & NNPFS_RIGHT_X)
	    mode |= 0111;
    } else
	mode |= status->UnixModeBits;

    XA_SET_MODE(attr, mode);
}

/*
 * Transform `access', `FileType' and `UnixModeBits' into rights.
 *
 * There are different transformations for directories and files to be
 * compatible with the Transarc client.
 */

static u_char
afsrights2nnpfsrights(u_long ar, uint32_t FileType, uint32_t UnixModeBits)
{
    u_char ret = 0;

    if (FileType == TYPE_DIR) {
	if (ar & ALIST)
	    ret |= NNPFS_RIGHT_R | NNPFS_RIGHT_X;
	if (ar & (AINSERT | ADELETE))
	    ret |= NNPFS_RIGHT_W;
    } else {
	if (FileType == TYPE_LINK && (ar & ALIST))
	    ret |= NNPFS_RIGHT_R;
	if ((ar & AREAD) && (UnixModeBits & S_IRUSR))
	    ret |= NNPFS_RIGHT_R;
	if ((ar & AWRITE) && (UnixModeBits & S_IWUSR))
	    ret |= NNPFS_RIGHT_W;
	if ((ar & AREAD) && (UnixModeBits & S_IXUSR))
	    ret |= NNPFS_RIGHT_X;
    }

    return ret;
}

void
fcacheentry2nnpfsnode (const VenusFid *fid,
		       const VenusFid *statfid, 
		       AFSFetchStatus *status,
		       struct nnpfs_msg_node *node,
		       AccessEntry *ae,
		       int flags)
{
    int i;

    memcpy (&node->handle, fid, sizeof(*fid));

    afsstatus2nnpfs_attr (status, statfid, &node->attr, flags);

    node->anonrights = afsrights2nnpfsrights(status->AnonymousAccess,
					     status->FileType,
					     status->UnixModeBits);
    for (i = 0; i < NACCESS; i++) {
	node->id[i] = ae[i].cred;
	node->rights[i] = afsrights2nnpfsrights(ae[i].access,
						status->FileType,
						status->UnixModeBits);
    }
}

/*
 * convert `xa' into `storestatus'
 */

int
nnpfs_attr2afsstorestatus(struct nnpfs_attr *xa,
			  AFSStoreStatus *storestatus)
{
    int mask = 0;

    if (XA_VALID_MODE(xa)) {
	storestatus->UnixModeBits = xa->xa_mode;
	mask |= SS_MODEBITS;
    }
    if (XA_VALID_UID(xa)) {
	storestatus->Owner = xa->xa_uid;
	mask |= SS_OWNER;
    }
    if (XA_VALID_GID(xa)) {
	storestatus->Group = xa->xa_gid;
	mask |= SS_GROUP;
    }
    if (XA_VALID_MTIME(xa)) {
	storestatus->ClientModTime = xa->xa_mtime;
	mask |= SS_MODTIME;
    }
    storestatus->Mask = mask;

    /* SS_SegSize */
    storestatus->SegSize = 0;
    return 0;
}

/*
 * Return true iff we should retry the operation.
 * Also replace `ce' with anonymous creds in case it has expired.
 *
 * There must not be passed in any NULL pointers.
 */

static int
try_again (int *ret, CredCacheEntry **ce, nnpfs_cred *cred, const VenusFid *fid)
{
    switch (*ret) {
#ifdef KERBEROS
    case RXKADEXPIRED : 
    case RXKADBADTICKET:
    case RXKADBADKEY:
    case RXKADUNKNOWNKEY: {
	int32_t cell = (*ce)->cell;

	conn_clearcred (CONN_CS_CRED|CONN_CS_SECIDX, 0, cred->pag, 2);
	cred_expire (*ce);
	cred_free (*ce);
	*ce = cred_get (cell, cred->pag, CRED_ANY);
	if (ce == NULL) {
		arla_warnx (ADEBMISC, "cred_get failed");
		return FALSE;		
	}
	return TRUE;
    }
    case RXKADSEALEDINCON :
	arla_warnx_with_fid (ADEBWARN, fid,
			     "seal error");
	*ret = EINVAL;
	return FALSE;
#endif	 
    case ARLA_VSALVAGE :
	*ret = EIO;
	return FALSE;
    case ARLA_VNOVNODE :
	*ret = ENOENT;
	return FALSE;
    case ARLA_VMOVED :
    case ARLA_VNOVOL :
	if (fid && !volcache_reliablep (fid->fid.Volume, fid->Cell)) {
	    return TRUE;
	} else {
	    *ret = ENOENT;
	    return FALSE;
	}
    case ARLA_VOFFLINE :
	*ret = ENETDOWN;
	return FALSE;
    case ARLA_VDISKFULL :
	*ret = ENOSPC;
	return FALSE;
    case ARLA_VOVERQUOTA:
#ifdef EDQUOT
	*ret = EDQUOT;
#else
	*ret = ENOSPC;
#endif
	return FALSE;
    case ARLA_VBUSY :
	arla_warnx_with_fid (ADEBWARN, fid,
			     "Waiting for busy volume...");
	IOMGR_Sleep (afs_BusyWaitPeriod);
	return TRUE;
    case ARLA_VRESTARTING:
	arla_warnx_with_fid (ADEBWARN, fid,
			     "Waiting for fileserver to restart...");
	IOMGR_Sleep (afs_BusyWaitPeriod);
	return TRUE;
    case ARLA_VIO :
	*ret = EIO;
	return FALSE;
    default :
	return FALSE;
    }
}

/*
 * Fetch data and retry if failing
 */

static int
message_get_data (FCacheEntry **entry,
		  struct nnpfs_cred *cred,
		  CredCacheEntry **ce,
		  size_t wanted_length)
{
    int ret;
    do {
	ret = fcache_get_data (entry, ce, wanted_length);
    } while (try_again (&ret, ce, cred, &(*entry)->fid));
    return ret;
}

/*
 *
 */

static int
nnpfs_message_getroot (int fd, struct nnpfs_message_getroot *h, u_int size)
{
    struct nnpfs_message_installroot msg;
    int ret = 0;
    VenusFid root_fid;
    CredCacheEntry *ce;
    AccessEntry *ae;
    FCacheEntry *entry = NULL;
    struct nnpfs_message_header *h0 = NULL;
    size_t h0_len = 0;
    int32_t cell_id = cell_name2num(cell_getthiscell());

    ce = cred_get (cell_id, h->cred.pag, CRED_ANY);
    if (ce == NULL) {
	    arla_warnx (ADEBMISC, "cred_get failed");
	    ret = -1;
	    goto out;
    }
    do {
	ret = getroot (&root_fid, ce);
    } while (try_again (&ret, &ce, &h->cred, &root_fid));

    if (ret)
	goto out;

    ret = fcache_get(&entry, root_fid, ce);
    if (ret)
	goto out;
	 
    do {
	ret = cm_getattr(entry, ce, &ae);
    } while (try_again (&ret, &ce, &h->cred, &root_fid));

    if (ret == 0) {
	fcacheentry2nnpfsnode (&root_fid, fcache_realfid(entry),
			       &entry->status, &msg.node, ae,
			       FCACHE2NNPFSNODE_ALL);

	entry->tokens |= NNPFS_ATTR_R;
	msg.node.tokens = entry->tokens & ~NNPFS_DATA_MASK;
	msg.header.opcode = NNPFS_MSG_INSTALLROOT;
	h0 = (struct nnpfs_message_header *)&msg;
	h0_len = sizeof(msg);
    }

 out:
    nnpfs_send_message_wakeup_multiple (fd,
					h->header.sequence_num,
					ret,
					h0, h0_len,
					NULL, 0);
    if (entry)
	fcache_release(entry);
    cred_free (ce);

    return 0;
}

static int
nnpfs_message_getnode (int fd, struct nnpfs_message_getnode *h, u_int size)
{
    struct nnpfs_message_installnode msg;
    VenusFid *dirfid = (VenusFid *)&h->parent_handle;
    VenusFid fid;
    VenusFid real_fid;
    AFSFetchStatus status;
    CredCacheEntry *ce;
    AccessEntry *ae;
    FCacheEntry *entry = NULL;
    FCacheEntry *dentry = NULL;
    struct nnpfs_message_header *h0 = NULL;
    size_t h0_len = 0;
    int ret;

    arla_warnx (ADEBMSG, "getnode (%ld.%lu.%lu.%lu) \"%s\"",
		(long)dirfid->Cell, (unsigned long)dirfid->fid.Volume,
		(unsigned long)dirfid->fid.Vnode,
		(unsigned long)dirfid->fid.Unique, h->name);

    ce = cred_get (dirfid->Cell, h->cred.pag, CRED_ANY);
    if (ce == NULL) {
	    arla_warnx (ADEBMISC, "cred_get failed");
	    ret = -1;
	    goto out;
    }
    ret = fcache_get(&dentry, *dirfid, ce);
    if (ret)
	goto out;

    assert_flag(dentry,kernelp);
     
    do {
	ret = cm_lookup (&dentry, h->name, &fid, &ce, TRUE);
	*dirfid = dentry->fid;
    } while (try_again (&ret, &ce, &h->cred, dirfid));

    if (ret)
	goto out;

    fcache_release(dentry);
    dentry = NULL;

    ret = fcache_get(&entry, fid, ce);
    if (ret)
	goto out;

    do {
	ret = cm_getattr (entry, ce, &ae);
	status = entry->status;
	real_fid = *fcache_realfid(entry);
    } while (try_again (&ret, &ce, &h->cred, &fid));

    if (ret == 0) {
	fcacheentry2nnpfsnode (&fid, &real_fid, &status, &msg.node, ae,
			       FCACHE2NNPFSNODE_ALL);

	entry->tokens |= NNPFS_ATTR_R;
	msg.node.tokens = entry->tokens & ~NNPFS_DATA_MASK;
	msg.parent_handle = h->parent_handle;
	strlcpy (msg.name, h->name, sizeof(msg.name));

	msg.header.opcode = NNPFS_MSG_INSTALLNODE;
	h0 = (struct nnpfs_message_header *)&msg;
	h0_len = sizeof(msg);
    }
 out:
    nnpfs_send_message_wakeup_multiple (fd,
					h->header.sequence_num,
					ret,
					h0, h0_len,
					NULL, 0);
    if (entry)
	fcache_release(entry);
    if (dentry)
	fcache_release(dentry);
    cred_free (ce);

    return 0;
}

static int
nnpfs_message_getattr (int fd, struct nnpfs_message_getattr *h, u_int size)
{
    struct nnpfs_message_installattr msg;
    VenusFid fid;
    CredCacheEntry *ce;
    AccessEntry *ae;
    FCacheEntry *entry = NULL;
    struct nnpfs_message_header *h0 = NULL;
    size_t h0_len = 0;
    int ret;

    fid = *(VenusFid *)&h->handle;
    arla_warnx (ADEBMSG, "getattr (%ld.%lu.%lu.%lu)",
		(long)fid.Cell, (unsigned long)fid.fid.Volume,
		(unsigned long)fid.fid.Vnode,
		(unsigned long)fid.fid.Unique);
    ce = cred_get (fid.Cell, h->cred.pag, CRED_ANY);
    if (ce == NULL) {
	    arla_warnx (ADEBMISC, "cred_get failed");
	    ret = -1;
	    goto out;
    }

    ret = fcache_get(&entry, fid, ce);
    if (ret)
	goto out;

    assert_flag(entry,kernelp);

    do {
	ret = cm_getattr (entry, ce, &ae);
    } while (try_again (&ret, &ce, &h->cred, &fid));

    if (ret)
	goto out;

    fcacheentry2nnpfsnode (&fid, fcache_realfid(entry),
			   &entry->status, &msg.node, ae,
			   FCACHE2NNPFSNODE_ALL);
     
    entry->tokens |= NNPFS_ATTR_R;
    msg.node.tokens = entry->tokens;
    msg.header.opcode = NNPFS_MSG_INSTALLATTR;
    h0 = (struct nnpfs_message_header *)&msg;
    h0_len = sizeof(msg);

 out:
    nnpfs_send_message_wakeup_multiple (fd,
					h->header.sequence_num,
					ret,
					h0, h0_len,
					NULL, 0);
    if (entry)
	fcache_release(entry);
    cred_free (ce);

    return 0;
}

static int 
nnpfs_message_putattr (int fd, struct nnpfs_message_putattr *h, u_int size)
{
    struct nnpfs_message_installattr msg;
    VenusFid fid;
    AFSStoreStatus status;
    CredCacheEntry *ce;
    AccessEntry *ae;
    struct nnpfs_message_header *h0 = NULL;
    size_t h0_len = 0;
    int ret;

    FCacheEntry *entry = NULL;

    fid = *(VenusFid *)&h->handle;
    arla_warnx (ADEBMSG, "putattr (%ld.%lu.%lu.%lu)",
		(long)fid.Cell, (unsigned long)fid.fid.Volume,
		(unsigned long)fid.fid.Vnode,
		(unsigned long)fid.fid.Unique);
    nnpfs_attr2afsstorestatus(&h->attr, &status);
    ce = cred_get (fid.Cell, h->cred.pag, CRED_ANY);
    if (ce == NULL) {
	    arla_warnx (ADEBMISC, "cred_get failed");
	    ret = -1;
	    goto out;
    }

    if (connected_mode != CONNECTED) {
	ret = fcache_find (&entry, fid);
	if (ret) {
	    ret = ENETDOWN;
	    goto out;
	}
    } else {
	ret = fcache_get(&entry, fid, ce);
	if (ret)
	    goto out;
    }

    assert_flag(entry,kernelp);

    /* 
     * We can't bits update at the same time as same time as we store
     * data since then fileserver will hate us with we are part of
     * system:administrators. This was fixed in openafs-1.2.7
     */

    if (XA_VALID_SIZE(&h->attr)) {
	AFSStoreStatus null_status;
	memset(&null_status, 0, sizeof(null_status));
	do {
	    ret = cm_ftruncate (entry, h->attr.xa_size, &status, ce);
	} while (try_again (&ret, &ce, &h->cred, &fid));
    }

    if (ret)
	goto out;

    if (status.Mask) {
	do {
	    ret = cm_setattr(entry, &status, ce);
	} while (try_again (&ret, &ce, &h->cred, &fid));
    }

    if (ret)
	goto out;

    do {
	ret = cm_getattr (entry, ce, &ae);
    } while (try_again (&ret, &ce, &h->cred, &fid));

     
    if (ret)
	goto out;
     
    fcacheentry2nnpfsnode (&fid, fcache_realfid(entry),
			   &entry->status, &msg.node, ae,
			   FCACHE2NNPFSNODE_ALL);
     
    entry->tokens |= NNPFS_ATTR_R;
    msg.node.tokens  = entry->tokens;
    msg.header.opcode = NNPFS_MSG_INSTALLATTR;
    h0 = (struct nnpfs_message_header *)&msg;
    h0_len = sizeof(msg);

    if (ret)
	goto out;

    if (connected_mode != CONNECTED)
	entry->disco_id = disco_store_status(&fid, &status, entry->disco_id);

 out:
    nnpfs_send_message_wakeup_multiple (fd,
					h->header.sequence_num, 
					ret,
					h0, h0_len,
					NULL, 0);
    if (entry)
	fcache_release(entry);
    cred_free (ce);

    return 0;
}

static int 
nnpfs_message_create (int fd, struct nnpfs_message_create *h, u_int size)
{
    VenusFid parent_fid, child_fid;
    AFSStoreStatus store_status;
    AFSFetchStatus fetch_status;
    CredCacheEntry *ce;
    int ret;
    struct nnpfs_message_installdata msg1;
    struct nnpfs_message_installnode msg2;
    struct nnpfs_message_installdata msg3;
    struct nnpfs_message_header *h0 = NULL;
    size_t h0_len = 0;
    struct nnpfs_message_header *h1 = NULL;
    size_t h1_len = 0;
    struct nnpfs_message_header *h2 = NULL;
    size_t h2_len = 0;
    FCacheEntry *dir_entry   = NULL;
    FCacheEntry *child_entry = NULL;
    fcache_cache_handle cache_handle;

    parent_fid = *(VenusFid *)&h->parent_handle;
    arla_warnx (ADEBMSG, "create (%ld.%lu.%lu.%lu) \"%s\"",
		(long)parent_fid.Cell,
		(unsigned long)parent_fid.fid.Volume,
		(unsigned long)parent_fid.fid.Vnode,
		(unsigned long)parent_fid.fid.Unique, h->name);

    nnpfs_attr2afsstorestatus(&h->attr, &store_status);
    if (connected_mode != CONNECTED) {
	if (!(store_status.Mask & SS_OWNER)) {
	    store_status.Owner = h->cred.uid;
	    store_status.Mask |= SS_OWNER;
	}
	if (!(store_status.Mask & SS_GROUP)) {
	    store_status.Group = 0;
	    store_status.Mask |= SS_GROUP;
	}
	if (!(store_status.Mask & SS_MODTIME)) {
	    struct timeval now;

	    gettimeofday (&now, NULL);

	    store_status.ClientModTime = now.tv_sec;
	    store_status.Mask |= SS_MODTIME;
	}
    }
    ce = cred_get (parent_fid.Cell, h->cred.pag, CRED_ANY);
    if (ce == NULL) {
	    arla_warnx (ADEBMISC, "cred_get failed");
	    ret = -1;
	    goto out;
    }

    ret = fcache_get(&dir_entry, parent_fid, ce);
    if (ret)
	goto out;

    assert_flag(dir_entry,kernelp);

    do {
	ret = cm_create(&dir_entry, h->name, &store_status,
			&child_fid, &fetch_status, &ce);
    } while (try_again (&ret, &ce, &h->cred, &dir_entry->fid));

    if (ret)
	goto out;
     
    ret = message_get_data (&dir_entry, &h->cred, &ce, 0);
    if (ret)
	goto out;

    ret = conv_dir (dir_entry, ce, 0,
		    &cache_handle,
		    msg1.cache_name,
		    sizeof(msg1.cache_name));
    if (ret)
	goto out;

    msg1.cache_handle = cache_handle.nnpfs_handle;
    msg1.flag = 0;
    if (cache_handle.valid)
	msg1.flag |= NNPFS_ID_HANDLE_VALID;
     
    dir_entry->tokens |= NNPFS_ATTR_R;
    msg1.node.tokens = dir_entry->tokens;
     
    fcacheentry2nnpfsnode (&dir_entry->fid,
			   fcache_realfid(dir_entry),
			   &dir_entry->status,
			   &msg1.node, 
			   dir_entry->acccache,
			   FCACHE2NNPFSNODE_ALL);
     
    ret = fcache_get(&child_entry, child_fid, ce);
    if (ret)
	goto out;
    /* XXX remove this, we don't want to fetch data from the fileserver */
    ret = message_get_data (&child_entry, &h->cred, &ce, 0);
    if (ret) {
	fcache_release(child_entry);
	goto out;
    }
    child_fid = child_entry->fid;
     
    msg3.cache_handle = child_entry->handle.nnpfs_handle;
    fcache_conv_file_name (child_entry,
			   msg3.cache_name, sizeof(msg3.cache_name));
    msg3.flag = 0;
    if (cache_handle.valid)
	msg3.flag |= NNPFS_ID_HANDLE_VALID;
     
    child_entry->flags.kernelp = TRUE;
    child_entry->flags.attrusedp = TRUE;
    child_entry->flags.datausedp = TRUE;
    assert_flag(dir_entry,kernelp);
    assert_flag(dir_entry,attrusedp);
    dir_entry->flags.datausedp = TRUE;
     
    msg1.offset = child_entry->fetched_length;
    msg1.header.opcode = NNPFS_MSG_INSTALLDATA;
    h0 = (struct nnpfs_message_header *)&msg1;
    h0_len = sizeof(msg1);
     
    fcacheentry2nnpfsnode (&child_fid, &child_fid,
			   &fetch_status, &msg2.node, dir_entry->acccache,
			   FCACHE2NNPFSNODE_ALL);
     
    child_entry->tokens |= NNPFS_ATTR_R | NNPFS_DATA_R | NNPFS_DATA_W;
    msg2.node.tokens   = child_entry->tokens & ~(NNPFS_DATA_MASK);
    msg2.parent_handle = h->parent_handle;
    strlcpy (msg2.name, h->name, sizeof(msg2.name));
     
    msg2.header.opcode = NNPFS_MSG_INSTALLNODE;
    h1 = (struct nnpfs_message_header *)&msg2;
    h1_len = sizeof(msg2);
     
    msg3.node          = msg2.node;
    msg3.node.tokens	= child_entry->tokens;
    msg3.offset        = child_entry->fetched_length;
    msg3.header.opcode = NNPFS_MSG_INSTALLDATA;
     
    h2 = (struct nnpfs_message_header *)&msg3;
    h2_len = sizeof(msg3);

    if (connected_mode != CONNECTED)
	child_entry->disco_id = disco_create_file(&parent_fid, &child_fid,
						  h->name, &store_status);

 out:
    nnpfs_send_message_wakeup_multiple (fd,
					h->header.sequence_num,
					ret,
					h0, h0_len,
					h1, h1_len,
					h2, h2_len,
					NULL, 0);
    if (dir_entry)
	fcache_release(dir_entry);
    if (child_entry)
	fcache_release(child_entry);
    cred_free (ce);

    return ret;
}

static int 
nnpfs_message_mkdir (int fd, struct nnpfs_message_mkdir *h, u_int size)
{
    VenusFid parent_fid, child_fid;
    AFSStoreStatus store_status;
    AFSFetchStatus fetch_status;
    CredCacheEntry *ce;
    int ret;
    struct nnpfs_message_installdata msg1;
    struct nnpfs_message_installnode msg2;
    struct nnpfs_message_installdata msg3;
    FCacheEntry *dir_entry = NULL;
    FCacheEntry *child_entry = NULL;

    struct nnpfs_message_header *h0 = NULL;
    size_t h0_len = 0;
    struct nnpfs_message_header *h1 = NULL;
    size_t h1_len = 0;
    struct nnpfs_message_header *h2 = NULL;
    size_t h2_len = 0;
    fcache_cache_handle cache_handle;

#if 0
    parent_fid = *fid_translate((VenusFid *)&h->parent_handle);
#else
    parent_fid = *(VenusFid *)&h->parent_handle;
#endif
    arla_warnx (ADEBMSG, "mkdir (%ld.%lu.%lu.%lu) \"%s\"",
		(long)parent_fid.Cell, (unsigned long)parent_fid.fid.Volume,
		(unsigned long)parent_fid.fid.Vnode,
		(unsigned long)parent_fid.fid.Unique, h->name);

    ce = cred_get (parent_fid.Cell, h->cred.pag, CRED_ANY);
    if (ce == NULL) {
	    arla_warnx (ADEBMISC, "cred_get failed");
	    ret = -1;
	    goto out;
    }

    nnpfs_attr2afsstorestatus(&h->attr, &store_status);
    if (connected_mode != CONNECTED) {
	if (!(store_status.Mask & SS_OWNER)) {
	    store_status.Owner = h->cred.uid;
	    store_status.Mask |= SS_OWNER;
	}
	if (!(store_status.Mask & SS_MODTIME)) {
	    struct timeval now;

	    gettimeofday (&now, NULL);

	    store_status.ClientModTime = now.tv_sec;
	    store_status.Mask |= SS_MODTIME;
	}
    }

    ret = fcache_get(&dir_entry, parent_fid, ce);
    if (ret)
	goto out;
     
    assert_flag(dir_entry,kernelp);

    do {
	ret = cm_mkdir(&dir_entry, h->name, &store_status,
		       &child_fid, &fetch_status, &ce);
    } while(try_again (&ret, &ce, &h->cred, &dir_entry->fid));

    if (ret)
	goto out;

    ret = message_get_data (&dir_entry, &h->cred, &ce, 0);
    if (ret)
	goto out;

    ret = conv_dir (dir_entry, ce, 0,
		    &cache_handle,
		    msg1.cache_name,
		    sizeof(msg1.cache_name));
    if (ret)
	goto out;

    msg1.cache_handle = cache_handle.nnpfs_handle;
    msg1.flag = 0;
    if (cache_handle.valid)
	msg1.flag |= NNPFS_ID_HANDLE_VALID;
    dir_entry->tokens |= NNPFS_ATTR_R;
    msg1.node.tokens = dir_entry->tokens;
     
    fcacheentry2nnpfsnode (&dir_entry->fid,
			   fcache_realfid(dir_entry),
			   &dir_entry->status, &msg1.node, 
			   dir_entry->acccache,
			   FCACHE2NNPFSNODE_ALL);
     
    msg1.offset = dir_entry->fetched_length;
    msg1.header.opcode = NNPFS_MSG_INSTALLDATA;
    h0 = (struct nnpfs_message_header *)&msg1;
    h0_len = sizeof(msg1);
     
    ret = fcache_get(&child_entry, child_fid, ce);
    if (ret)
	goto out;
    ret = message_get_data (&child_entry, &h->cred, &ce, 0);
    if (ret)
	goto out;

    child_fid = child_entry->fid;
     
    ret = conv_dir (child_entry, ce, 0,
		    &cache_handle,
		    msg3.cache_name,
		    sizeof(msg3.cache_name));
    if (ret)
	goto out;

    msg3.cache_handle = cache_handle.nnpfs_handle;
    msg3.flag = 0;
    if (cache_handle.valid)
	msg3.flag |= NNPFS_ID_HANDLE_VALID;
     
    assert_flag(child_entry,kernelp);
    child_entry->flags.attrusedp = TRUE;
    child_entry->flags.datausedp = TRUE;
    assert_flag(dir_entry,kernelp);
    assert_flag(dir_entry,attrusedp);
    dir_entry->flags.datausedp = TRUE;
     
    child_entry->tokens |= NNPFS_ATTR_R;
    msg2.node.tokens = child_entry->tokens & ~(NNPFS_DATA_MASK);
     
    fcacheentry2nnpfsnode (&child_fid, &child_fid,
			   &child_entry->status, &msg2.node,
			   dir_entry->acccache,
			   FCACHE2NNPFSNODE_ALL);
     
    msg2.parent_handle = h->parent_handle;
    strlcpy (msg2.name, h->name, sizeof(msg2.name));
     
    msg2.header.opcode = NNPFS_MSG_INSTALLNODE;
    h1 = (struct nnpfs_message_header *)&msg2;
    h1_len = sizeof(msg2);
     
    msg3.header.opcode = NNPFS_MSG_INSTALLDATA;
    msg3.offset = child_entry->fetched_length;
    msg3.node = msg2.node;
    msg3.node.tokens = child_entry->tokens;
    h2 = (struct nnpfs_message_header *)&msg3;
    h2_len = sizeof(msg3);

    if (connected_mode != CONNECTED)
	child_entry->disco_id = disco_create_dir(&parent_fid, &child_fid, 
						 h->name, &store_status);

 out:
    nnpfs_send_message_wakeup_multiple (fd,
					h->header.sequence_num,
					ret,
					h0, h0_len,
					h1, h1_len,
					h2, h2_len,
					NULL, 0); 
   if (child_entry) 
	fcache_release(child_entry);
    if (dir_entry)
	fcache_release(dir_entry);
    cred_free (ce);

    return ret;
}

static int 
nnpfs_message_link (int fd, struct nnpfs_message_link *h, u_int size)
{
    VenusFid parent_fid, existing_fid;
    AFSFetchStatus fetch_status;
    CredCacheEntry *ce;
    int ret;
    struct nnpfs_message_installdata msg1;
    struct nnpfs_message_installnode msg2;
    struct nnpfs_message_header *h0 = NULL;
    size_t h0_len = 0;
    struct nnpfs_message_header *h1 = NULL;
    size_t h1_len = 0;
    fcache_cache_handle cache_handle;
    FCacheEntry *dir_entry = NULL;

    parent_fid   = *(VenusFid *)&h->parent_handle;
    existing_fid = *(VenusFid *)&h->from_handle;
    arla_warnx (ADEBMSG, "link (%ld.%lu.%lu.%lu) (%ld.%lu.%lu.%lu) \"%s\"",
		(long)parent_fid.Cell, (unsigned long)parent_fid.fid.Volume,
		(unsigned long)parent_fid.fid.Vnode,
		(unsigned long)parent_fid.fid.Unique,
		(long)existing_fid.Cell,
		(unsigned long)existing_fid.fid.Volume,
		(unsigned long)existing_fid.fid.Vnode,
		(unsigned long)existing_fid.fid.Unique,
		h->name);

    ce = cred_get (parent_fid.Cell, h->cred.pag, CRED_ANY);
    if (ce == NULL) {
	    arla_warnx (ADEBMISC, "cred_get failed");
	    ret = -1;
	    goto out;
    }

    ret = fcache_get(&dir_entry, parent_fid, ce);
    if (ret)
	goto out;

    assert_flag(dir_entry,kernelp);

    do {
	ret = cm_link (&dir_entry, h->name, existing_fid,
		       &fetch_status, &ce);
    } while (try_again (&ret, &ce, &h->cred, &dir_entry->fid));

    if (ret)
	goto out;

    ret = message_get_data (&dir_entry, &h->cred, &ce, 0);
    if (ret)
	goto out;

    ret = conv_dir (dir_entry, ce, 0,
		    &cache_handle,
		    msg1.cache_name,
		    sizeof(msg1.cache_name));
    if (ret == -1)
	goto out;

    msg1.cache_handle = cache_handle.nnpfs_handle;
    msg1.flag = 0;
    if (cache_handle.valid)
	msg1.flag |= NNPFS_ID_HANDLE_VALID;
    dir_entry->tokens |= NNPFS_ATTR_R;
    msg1.node.tokens = dir_entry->tokens;
    assert_flag(dir_entry,kernelp);
    assert_flag(dir_entry,attrusedp);
    dir_entry->flags.datausedp = TRUE;
     
    fcacheentry2nnpfsnode (&dir_entry->fid,
			   fcache_realfid(dir_entry),
			   &dir_entry->status, &msg1.node,
			   dir_entry->acccache,
			   FCACHE2NNPFSNODE_ALL);
     
    msg1.offset = dir_entry->fetched_length;
    msg1.header.opcode = NNPFS_MSG_INSTALLDATA;
    h0 = (struct nnpfs_message_header *)&msg1;
    h0_len = sizeof(msg1);
     
    fcacheentry2nnpfsnode (&existing_fid, &existing_fid,
			   &fetch_status, &msg2.node,
			   dir_entry->acccache,
			   FCACHE2NNPFSNODE_ALL);
     
    msg2.node.tokens   = NNPFS_ATTR_R; /* XXX */
    msg2.parent_handle = h->parent_handle;
    strlcpy (msg2.name, h->name, sizeof(msg2.name));
     
    msg2.header.opcode = NNPFS_MSG_INSTALLNODE;
    h1 = (struct nnpfs_message_header *)&msg2;
    h1_len = sizeof(msg2);

 out:
    nnpfs_send_message_wakeup_multiple (fd,
					h->header.sequence_num,
					ret,
					h0, h0_len,
					h1, h1_len,
					NULL, 0);
    if (dir_entry)
	fcache_release(dir_entry);
    cred_free (ce);

    return ret;
}

static int 
nnpfs_message_symlink (int fd, struct nnpfs_message_symlink *h, u_int size)
{
    VenusFid parent_fid, child_fid, real_fid;
    AFSStoreStatus store_status;
    AFSFetchStatus fetch_status;
    CredCacheEntry *ce;
    int ret;
    struct nnpfs_message_installdata msg1;
    struct nnpfs_message_installnode msg2;
    struct nnpfs_message_header *h0 = NULL;
    size_t h0_len = 0;
    struct nnpfs_message_header *h1 = NULL;
    size_t h1_len = 0;
    fcache_cache_handle cache_handle;
    FCacheEntry *dir_entry = NULL;

    parent_fid = *(VenusFid *)&h->parent_handle;
    arla_warnx (ADEBMSG, "symlink (%ld.%lu.%lu.%lu) \"%s\"",
		(long)parent_fid.Cell, (unsigned long)parent_fid.fid.Volume,
		(unsigned long)parent_fid.fid.Vnode,
		(unsigned long)parent_fid.fid.Unique, h->name);

    ce = cred_get (parent_fid.Cell, h->cred.pag, CRED_ANY);
    if (ce == NULL) {
	    arla_warnx (ADEBMISC, "cred_get failed");
	    ret = -1;
	    goto out;
    }

    nnpfs_attr2afsstorestatus(&h->attr, &store_status);

    ret = fcache_get(&dir_entry, parent_fid, ce);
    if (ret)
	goto out;

    assert_flag(dir_entry,kernelp);

    do {
	ret = cm_symlink(&dir_entry, h->name, &store_status,
			 &child_fid, &real_fid,
			 &fetch_status,
			 h->contents, &ce);
    } while (try_again (&ret, &ce, &h->cred, &dir_entry->fid));
     
    cred_free (ce);
    ce = cred_get (dir_entry->fid.Cell, h->cred.pag, CRED_ANY);
    if (ce == NULL) {
	    arla_warnx (ADEBMISC, "cred_get failed");
	    ret = -1;
	    goto out;
    }

    if (ret)
	goto out;
     
    ret = message_get_data (&dir_entry, &h->cred, &ce, 0);
    if (ret)
	goto out;

    ret = conv_dir (dir_entry, ce, 0,
		    &cache_handle,
		    msg1.cache_name,
		    sizeof(msg1.cache_name));
    if (ret)
	goto out;

    msg1.cache_handle = cache_handle.nnpfs_handle;
    msg1.flag = 0;
    if (cache_handle.valid)
	msg1.flag |= NNPFS_ID_HANDLE_VALID;
    dir_entry->tokens |= NNPFS_ATTR_R;
    msg1.node.tokens = dir_entry->tokens;
    assert_flag(dir_entry,kernelp);
    assert_flag(dir_entry,attrusedp);
    dir_entry->flags.datausedp = TRUE;
    
    fcacheentry2nnpfsnode (&dir_entry->fid,
			   fcache_realfid(dir_entry),
			   &dir_entry->status, &msg1.node,
			   dir_entry->acccache,
			   FCACHE2NNPFSNODE_ALL);
    
    msg1.offset = dir_entry->fetched_length;
    msg1.header.opcode = NNPFS_MSG_INSTALLDATA;
    h0 = (struct nnpfs_message_header *)&msg1;
    h0_len = sizeof(msg1);
    
    fcacheentry2nnpfsnode (&child_fid, &real_fid,
			   &fetch_status, &msg2.node,
			   dir_entry->acccache,
			   FCACHE2NNPFSNODE_ALL);
    
    msg2.node.tokens   = NNPFS_ATTR_R; /* XXX */
    msg2.parent_handle = h->parent_handle;
    strlcpy (msg2.name, h->name, sizeof(msg2.name));
    
    msg2.header.opcode = NNPFS_MSG_INSTALLNODE;
    h1 = (struct nnpfs_message_header *)&msg2;
    h1_len = sizeof(msg2);
    
 out:
    nnpfs_send_message_wakeup_multiple (fd,
					h->header.sequence_num,
					ret,
					h0, h0_len,
					h1, h1_len,
					NULL, 0);
    if (dir_entry)
	fcache_release(dir_entry);
    cred_free (ce);

    return ret;
}

/* 
 * Handle the NNPFS remove message in `h', that is, remove name
 * `h->name' in directory `h->parent' with the creds from `h->cred'.
 */

static int 
nnpfs_message_remove (int fd, struct nnpfs_message_remove *h, u_int size)
{
    VenusFid parent_fid;
    VenusFid fid;
    CredCacheEntry *ce;
    int ret;
    struct nnpfs_message_installdata msg1;
    struct nnpfs_message_installattr msg2;
    struct nnpfs_message_header *h0 = NULL;
    size_t h0_len = 0;
    struct nnpfs_message_header *h1 = NULL;
    size_t h1_len = 0;
    FCacheEntry *limbo_entry = NULL;
    unsigned link_count;
    FCacheEntry *dir_entry = NULL;
    AFSFetchStatus limbo_status;
    fcache_cache_handle cache_handle;
    
    parent_fid = *(VenusFid *)&h->parent_handle;
    arla_warnx (ADEBMSG, "remove (%ld.%lu.%lu.%lu) \"%s\"",
		(long)parent_fid.Cell, (unsigned long)parent_fid.fid.Volume,
		(unsigned long)parent_fid.fid.Vnode,
		(unsigned long)parent_fid.fid.Unique, h->name);
    
    ce = cred_get (parent_fid.Cell, h->cred.pag, CRED_ANY);
    if (ce == NULL) {
	    arla_warnx (ADEBMISC, "cred_get failed");
	    ret = -1;
	    goto out;
    }
    
    ret = fcache_get(&dir_entry, parent_fid, ce);
    if (ret)
	goto out;
    
    assert_flag(dir_entry,kernelp);
    
    do {
	ret = cm_lookup (&dir_entry, h->name, &fid, &ce, FALSE);
    } while (try_again (&ret, &ce, &h->cred, &dir_entry->fid));
    
    if (ret)
	goto out;

    /*
     * Fetch the linkcount of the to be removed node
     */
    
    ret = fcache_get (&limbo_entry, fid, ce);
    if (ret)
	goto out;
    
    ret = fcache_verify_attr (limbo_entry, dir_entry, h->name, ce);
    if (ret)
	goto out;
    limbo_status = limbo_entry->status;
    link_count   = limbo_status.LinkCount;
    
    fcache_release (limbo_entry);
    limbo_entry = NULL;
    
    /*
     * Do the actual work
     */
    
    do {
	ret = cm_remove(&dir_entry, h->name, &ce);
    } while (try_again (&ret, &ce, &h->cred, &dir_entry->fid));
    
    if (ret)
	goto out;
    
    ret = message_get_data (&dir_entry, &h->cred, &ce, 0);
    if (ret)
	goto out;
    
    if (!dir_entry->flags.extradirp
	|| dir_remove_name (dir_entry, h->name,
			    &cache_handle,
			    msg1.cache_name,
			    sizeof(msg1.cache_name))) {
	ret = conv_dir (dir_entry, ce, 0,
			&cache_handle,
			msg1.cache_name,
			sizeof(msg1.cache_name));
	if (ret)
	    goto out;
    }
    msg1.cache_handle = cache_handle.nnpfs_handle;
    msg1.flag = NNPFS_ID_INVALID_DNLC;
    if (cache_handle.valid)
	msg1.flag |= NNPFS_ID_HANDLE_VALID;
    dir_entry->tokens |= NNPFS_ATTR_R;
    msg1.node.tokens = dir_entry->tokens | NNPFS_DATA_R;
    
    fcacheentry2nnpfsnode (&dir_entry->fid,
			   fcache_realfid(dir_entry),
			   &dir_entry->status, &msg1.node,
			   dir_entry->acccache,
			   FCACHE2NNPFSNODE_ALL);
    
    msg1.offset = dir_entry->fetched_length;
    msg1.header.opcode = NNPFS_MSG_INSTALLDATA;
    h0 = (struct nnpfs_message_header *)&msg1;
    h0_len = sizeof(msg1);
    
    /*
     * Set datausedp since we push data to kernel in out:
     */
    
    dir_entry->flags.datausedp = TRUE;
    
    /*
     * Make sure that if the removed node is in the kernel it has the
     * right linkcount since some might hold a reference to it.
     */
    
    ret = fcache_get (&limbo_entry, fid, ce);
    if (ret)
	goto out;
    
    if (limbo_entry->flags.kernelp) {
	/*
	 * Now insert the limbo entry to get right linkcount
	 */
	
	ret = fcache_verify_attr (limbo_entry, dir_entry, NULL, ce);
	if (ret == 0)
	    limbo_status = limbo_entry->status;
	ret = 0;
	
	/* Only a silly rename when this is the last file */
	if (link_count == 1)
	    limbo_entry->flags.silly = TRUE;
	
	msg2.header.opcode = NNPFS_MSG_INSTALLATTR;
	limbo_entry->tokens |= NNPFS_ATTR_R;
	msg2.node.tokens   = limbo_entry->tokens;
	if (!limbo_entry->flags.datausedp)
	    msg2.node.tokens &= ~NNPFS_DATA_MASK;
	
	if (link_count == 1 && limbo_status.LinkCount == 1)
	     --limbo_status.LinkCount;
	fcacheentry2nnpfsnode (&fid,
			       fcache_realfid(limbo_entry),
			       &limbo_status,
			       &msg2.node,
			       limbo_entry->acccache,
			       FCACHE2NNPFSNODE_ALL);
	
	h1 = (struct nnpfs_message_header *)&msg2;
	h1_len = sizeof(msg2);
    }
    
 out:
    nnpfs_send_message_wakeup_multiple (fd,
					h->header.sequence_num,
					ret,
					h0, h0_len,
					h1, h1_len,
					NULL, 0);
    if (dir_entry)
	fcache_release(dir_entry);
    if (limbo_entry)
	fcache_release (limbo_entry);
    cred_free (ce);

    return ret;
}

static int 
nnpfs_message_rmdir (int fd, struct nnpfs_message_rmdir *h, u_int size)
{
    VenusFid parent_fid, fid;
    CredCacheEntry *ce;
    int ret;
    struct nnpfs_message_installdata msg0;
    struct nnpfs_message_header *h0 = NULL;
    size_t h0_len = 0;
    struct nnpfs_message_installattr msg1;
    struct nnpfs_message_header *h1 = NULL;
    size_t h1_len = 0;
    FCacheEntry *limbo_entry = NULL;
    FCacheEntry *dir_entry = NULL;
    unsigned link_count = 0;
    fcache_cache_handle cache_handle;

    parent_fid = *(VenusFid *)&h->parent_handle;
    arla_warnx (ADEBMSG, "rmdir (%ld.%lu.%lu.%lu) \"%s\"",
		(long)parent_fid.Cell, (unsigned long)parent_fid.fid.Volume,
		(unsigned long)parent_fid.fid.Vnode,
		(unsigned long)parent_fid.fid.Unique, h->name);

    ce = cred_get (parent_fid.Cell, h->cred.pag, CRED_ANY);
    if (ce == NULL) {
	    arla_warnx (ADEBMISC, "cred_get failed");
	    ret = -1;
	    goto out;
    }

    /*
     * Fetch the child-entry fid.
     */

    ret = fcache_get(&dir_entry, parent_fid, ce);
    if (ret)
	goto out;

    assert_flag(dir_entry,kernelp);

    do {
	ret = cm_lookup (&dir_entry, h->name, &fid, &ce, FALSE);
    } while (try_again (&ret, &ce, &h->cred, &dir_entry->fid));

    if (ret)
	goto out;

    if (VenusFid_cmp(&dir_entry->fid, &fid) == 0) {
	ret = EINVAL;
	goto out;
    }

    /*
     * Need to get linkcount for silly rename.
     */

    ret = fcache_get (&limbo_entry, fid, ce);
    if (ret)
	goto out;

    ret = fcache_verify_attr (limbo_entry, dir_entry, h->name, ce);
    if (ret)
	goto out;
    link_count = limbo_entry->status.LinkCount;

    fcache_release (limbo_entry);
    limbo_entry = NULL;

    /*
     * Do the actual work
     */

    do {
	ret = cm_rmdir(&dir_entry, h->name, &ce);
    } while (try_again (&ret, &ce, &h->cred, &dir_entry->fid));

    if (ret)
	goto out;

    ret = message_get_data (&dir_entry, &h->cred, &ce, 0);
    if (ret)
	goto out;

    if (!dir_entry->flags.extradirp
	|| dir_remove_name (dir_entry, h->name,
			    &cache_handle,
			    msg0.cache_name,
			    sizeof(msg0.cache_name))) {
	ret = conv_dir (dir_entry, ce, 0,
			&cache_handle,
			msg0.cache_name,
			sizeof(msg0.cache_name));
	if (ret)
	    goto out;
    }
    msg0.cache_handle = cache_handle.nnpfs_handle;
    msg0.flag = NNPFS_ID_INVALID_DNLC;
    if (cache_handle.valid)
	msg0.flag |= NNPFS_ID_HANDLE_VALID;

    dir_entry->tokens |= NNPFS_ATTR_R;
    msg0.node.tokens = dir_entry->tokens;

    fcacheentry2nnpfsnode (&dir_entry->fid,
			   fcache_realfid(dir_entry),
			   &dir_entry->status, &msg0.node,
			   dir_entry->acccache,
			   FCACHE2NNPFSNODE_ALL);

    msg0.offset = dir_entry->fetched_length;
    msg0.header.opcode = NNPFS_MSG_INSTALLDATA;
    h0 = (struct nnpfs_message_header *)&msg0;
    h0_len = sizeof(msg0);

    ret = fcache_get (&limbo_entry, fid, ce);
    if (ret)
	goto out;

    /* Only silly rename when this is the last reference. */

    if (link_count == 2)
	limbo_entry->flags.silly = TRUE;

    if (limbo_entry->flags.kernelp) {

	ret = fcache_verify_attr (limbo_entry, dir_entry, NULL, ce);
	if (ret)
	    goto out;

	msg1.header.opcode = NNPFS_MSG_INSTALLATTR;
	limbo_entry->tokens |= NNPFS_ATTR_R;
	msg1.node.tokens   = limbo_entry->tokens;
	if (!limbo_entry->flags.datausedp)
	    msg1.node.tokens &= ~NNPFS_DATA_MASK;

	if (link_count == 2 && limbo_entry->status.LinkCount == 2)
	    limbo_entry->status.LinkCount = 0;
	fcacheentry2nnpfsnode (&fid,
			       fcache_realfid(limbo_entry),
			       &limbo_entry->status,
			       &msg1.node,
			       limbo_entry->acccache,
			       FCACHE2NNPFSNODE_ALL);

	h1 = (struct nnpfs_message_header *)&msg1;
	h1_len = sizeof(msg1);
    }
    assert_flag(dir_entry,kernelp);
    assert_flag(dir_entry,attrusedp);
    dir_entry->flags.datausedp = TRUE;

 out:
    nnpfs_send_message_wakeup_multiple (fd,
					h->header.sequence_num,
					ret,
					h0, h0_len,
					h1, h1_len,
					NULL, 0);
    if (dir_entry)
	fcache_release(dir_entry);
    if (limbo_entry)
	fcache_release (limbo_entry);

    cred_free (ce);

    return ret;
}

static int 
nnpfs_message_rename (int fd, struct nnpfs_message_rename *h, u_int size)
{
    VenusFid old_parent_fid;
    VenusFid new_parent_fid;
    VenusFid child_fid;
    CredCacheEntry *ce;
    int ret;
    struct nnpfs_message_installdata msg1;
    struct nnpfs_message_installdata msg2;
    struct nnpfs_message_installdata msg3;
    struct nnpfs_message_header *h0 = NULL;
    size_t h0_len = 0;
    struct nnpfs_message_header *h1 = NULL;
    size_t h1_len = 0;
    struct nnpfs_message_header *h2 = NULL;
    size_t h2_len = 0;
    FCacheEntry *old_entry   = NULL;
    FCacheEntry *new_entry   = NULL;
    FCacheEntry *child_entry = NULL;
    int update_child = 0;
    fcache_cache_handle cache_handle;
    int diff_dir = 0;

    old_parent_fid = *(VenusFid *)&h->old_parent_handle;
    new_parent_fid = *(VenusFid *)&h->new_parent_handle;
    arla_warnx (ADEBMSG,
		"rename (%ld.%lu.%lu.%lu) (%ld.%lu.%lu.%lu) \"%s\" \"%s\"",
		(long)old_parent_fid.Cell,
		(unsigned long)old_parent_fid.fid.Volume,
		(unsigned long)old_parent_fid.fid.Vnode,
		(unsigned long)old_parent_fid.fid.Unique,
		(long)new_parent_fid.Cell,
		(unsigned long)new_parent_fid.fid.Volume,
		(unsigned long)new_parent_fid.fid.Vnode,
		(unsigned long)new_parent_fid.fid.Unique,
		h->old_name,
		h->new_name);

    ce = cred_get (old_parent_fid.Cell, h->cred.pag, CRED_ANY);
    assert (ce != NULL);

    diff_dir = VenusFid_cmp (&old_parent_fid, &new_parent_fid);

    ret = fcache_get(&old_entry, old_parent_fid, ce);
    if (ret)
	goto out;

    assert_flag(old_entry,kernelp);

    if (diff_dir) {
	ret = fcache_get(&new_entry, new_parent_fid, ce);
	if (ret)
	    goto out;
    } else {
	new_entry = old_entry;
    }

    assert_flag(new_entry,kernelp);

    do {
	ret = cm_rename(&old_entry, h->old_name,
			&new_entry, h->new_name,
			&child_fid, &update_child, &ce);
    } while (try_again (&ret, &ce, &h->cred, &old_entry->fid));

    if (ret)
	goto out;

    ret = message_get_data (&old_entry, &h->cred, &ce, 0);
    if (ret)
	goto out;
     
    if (!old_entry->flags.extradirp
	|| dir_remove_name (old_entry, h->old_name,
			    &cache_handle,
			    msg1.cache_name,
			    sizeof(msg1.cache_name))) {
	ret = conv_dir (old_entry, ce, 0,
			&cache_handle,
			msg1.cache_name,
			sizeof(msg1.cache_name));
	if (ret)
	    goto out;
    }
    msg1.cache_handle = cache_handle.nnpfs_handle;
    msg1.flag = NNPFS_ID_INVALID_DNLC;
    if (cache_handle.valid)
	msg1.flag |= NNPFS_ID_HANDLE_VALID;
     
    old_entry->tokens |= NNPFS_ATTR_R;
    msg1.node.tokens = old_entry->tokens;
     
    fcacheentry2nnpfsnode (&old_entry->fid,
			   fcache_realfid(old_entry),
			   &old_entry->status, &msg1.node,
			   old_entry->acccache,
			   FCACHE2NNPFSNODE_ALL);
     
    msg1.offset = old_entry->fetched_length;
    msg1.header.opcode = NNPFS_MSG_INSTALLDATA;
    h0 = (struct nnpfs_message_header *)&msg1;
    h0_len = sizeof(msg1);
     
    ret = fcache_get_data (&new_entry, &ce, 0); /* XXX - fake_mp? */
    if (ret)
	goto out;
     
    ret = conv_dir (new_entry, ce, 0,
		    &cache_handle,
		    msg2.cache_name,
		    sizeof(msg2.cache_name));
    if (ret)
	goto out;

    msg2.cache_handle = cache_handle.nnpfs_handle;
    msg2.flag = NNPFS_ID_INVALID_DNLC;
    if (cache_handle.valid)
	msg2.flag |= NNPFS_ID_HANDLE_VALID;
     
    new_entry->tokens |= NNPFS_ATTR_R;
    msg2.node.tokens = new_entry->tokens;
     
    fcacheentry2nnpfsnode (&new_entry->fid,
			   fcache_realfid(new_entry),
			   &new_entry->status, &msg2.node,
			   new_entry->acccache,
			   FCACHE2NNPFSNODE_ALL);
     
    msg2.offset = new_entry->fetched_length;
    msg2.header.opcode = NNPFS_MSG_INSTALLDATA;
    h1 = (struct nnpfs_message_header *)&msg2;
    h1_len = sizeof(msg2);
     
    if (old_entry) {
	assert_flag(old_entry,kernelp);
	assert_flag(old_entry,attrusedp);
	old_entry->flags.datausedp = TRUE;
    }
    assert_flag(new_entry,kernelp);
    assert_flag(new_entry,attrusedp);
    new_entry->flags.datausedp = TRUE;
     
    if (update_child) {
	ret = fcache_get(&child_entry, child_fid, ce);
	if (ret)
	    goto out;
	ret = message_get_data (&child_entry, &h->cred, &ce, 0);
	if (ret) {
	    fcache_release(child_entry);
	    goto out;
	}
	child_fid = child_entry->fid;
	 
	ret = conv_dir (child_entry, ce, 0,
			&cache_handle,
			msg3.cache_name,
			sizeof(msg3.cache_name));
	if (ret)
	    goto out;

	msg3.cache_handle = cache_handle.nnpfs_handle;
	msg3.flag = NNPFS_ID_INVALID_DNLC;
	if (cache_handle.valid)
	    msg3.flag |= NNPFS_ID_HANDLE_VALID;
	 
	child_entry->tokens |= NNPFS_ATTR_R;
	msg3.node.tokens = child_entry->tokens;
	 
	fcacheentry2nnpfsnode (&child_fid,
			       fcache_realfid(child_entry),
			       &child_entry->status, &msg3.node,
			       child_entry->acccache,
			       FCACHE2NNPFSNODE_ALL);
	 
	msg3.offset = child_entry->fetched_length;
	msg3.header.opcode = NNPFS_MSG_INSTALLDATA;
	h2 = (struct nnpfs_message_header *)&msg3;
	h2_len = sizeof(msg3);
    }

 out:
    nnpfs_send_message_wakeup_multiple (fd,
					h->header.sequence_num,
					ret,
					h0, h0_len,
					h1, h1_len,
					NULL, 0);
    if (old_entry) fcache_release(old_entry);
    if (new_entry && diff_dir) fcache_release(new_entry);
    if (child_entry) fcache_release(child_entry);
     
    cred_free (ce);

    return ret;
}

static int 
nnpfs_message_putdata (int fd, struct nnpfs_message_putdata *h, u_int size)
{
    VenusFid fid;
    CredCacheEntry *ce;
    int ret;
    AFSStoreStatus status;
    FCacheEntry *entry = NULL;

    fid = *(VenusFid *)&h->handle;
    arla_warnx (ADEBMSG, "putdata (%ld.%lu.%lu.%lu)",
		(long)fid.Cell, (unsigned long)fid.fid.Volume,
		(unsigned long)fid.fid.Vnode,
		(unsigned long)fid.fid.Unique);

    nnpfs_attr2afsstorestatus(&h->attr, &status);

    ce = cred_get (fid.Cell, h->cred.pag, CRED_ANY);
    assert (ce != NULL);

    if (connected_mode != CONNECTED) {
	ret = fcache_find (&entry, fid);
	if (ret) {
	    ret = ENETDOWN;
	    goto out;
	}
    } else {
	ret = fcache_get (&entry, fid, ce);
	if (ret)
	    goto out;
    }

    assert_flag(entry,kernelp);

    do {
	ret = cm_close(entry, h->flag, &status, ce);
    } while (try_again (&ret, &ce, &h->cred, &fid));
     
    if (ret) {
	arla_warn (ADEBMSG, ret, "nnpfs_message_putdata: cm_close");
	goto out;
    }

    if (connected_mode != CONNECTED)
	entry->disco_id = disco_store_data(&fid, &status, entry->disco_id);

 out:
    if (entry)
	fcache_release(entry);
    cred_free (ce);
    nnpfs_send_message_wakeup (fd, h->header.sequence_num, ret);
    return 0;
}

static void
prefetch_data(FCacheEntry **e, CredCacheEntry **ce)
{
    FCacheEntry *entry = *e;
    int ret = 0;

    if (entry->status.FileType != TYPE_FILE)
	return;

    if (entry->status.Length > entry->fetched_length) {
	size_t offset;

	offset = entry->fetched_length + stats_prefetch(NULL, -1);
	if (offset > entry->status.Length)
	    offset = entry->status.Length;
	arla_warnx (ADEBMSG, "  prefetching to %lu", (unsigned long)offset);
	ret = fcache_get_data (e, ce, offset);
	arla_warnx (ADEBMSG, "  prefetched returned %d", ret);
    }

    return;
}

static int
nnpfs_message_open (int fd, struct nnpfs_message_open *h, u_int size)
{
    struct nnpfs_message_installdata msg;
    FCacheEntry *entry = NULL;
    CredCacheEntry *ce;
    AccessEntry *ae;
    VenusFid fid;
    int ret;
    
    fid = *(VenusFid *)&h->handle;
    arla_warnx (ADEBMSG, "open (%ld.%lu.%lu.%lu)",
		(long)fid.Cell, (unsigned long)fid.fid.Volume,
		(unsigned long)fid.fid.Vnode,
		(unsigned long)fid.fid.Unique);
    
    ce = cred_get (fid.Cell, h->cred.pag, CRED_ANY);
    if (ce == NULL) {
	    arla_warnx (ADEBMISC, "cred_get failed");
	    ret = -1;
	    goto out;
    }
    
    ret = fcache_get(&entry, fid, ce);
    if (ret)
	goto out;
    
    assert_flag(entry,kernelp);
    
 tryagain:

    ret = cm_getattr (entry, ce, &ae);

    if (try_again (&ret, &ce, &h->cred, &fid))
	goto tryagain;
    if (ret)
	goto out;

    msg.flag = 0;

    if (entry->status.FileType == TYPE_DIR) {
	fcache_cache_handle cache_handle;
	 
	if (h->tokens & NNPFS_DATA_W) {
	    ret = EACCES;
	    goto out;
	}
	 
	ret = fcache_get_data (&entry, &ce, entry->status.Length);
	if (try_again (&ret, &ce, &h->cred, &fid))
	    goto tryagain;
	if (ret)
	    goto out;
	fid = entry->fid;
	 
	fcacheentry2nnpfsnode (&fid, fcache_realfid(entry),
			       &entry->status, &msg.node, ae,
			       FCACHE2NNPFSNODE_ALL);
	 
	ret = conv_dir (entry, ce, h->tokens,
			&cache_handle,
			msg.cache_name,
			sizeof(msg.cache_name));
	 
	if (ret)
	    goto out;
	 
	entry->tokens |= h->tokens;
	entry->tokens |= NNPFS_ATTR_R;
	msg.node.tokens = entry->tokens;
	msg.flag = NNPFS_ID_INVALID_DNLC;
	msg.cache_handle = cache_handle.nnpfs_handle;
	if (cache_handle.valid)
	    msg.flag |= NNPFS_ID_HANDLE_VALID;
	msg.offset = entry->fetched_length;
	 
	assert_flag(entry,kernelp);
	entry->flags.attrusedp = TRUE;
	entry->flags.datausedp = TRUE;
	 
    } else {
	ret = cm_open (entry, ce, h->tokens);
	if (try_again (&ret, &ce, &h->cred, &fid))
	    goto tryagain;
	if (ret)
	    goto out;

	fcache_conv_file_name (entry, msg.cache_name, sizeof(msg.cache_name));

	msg.cache_handle = entry->handle.nnpfs_handle;
	entry->tokens |= NNPFS_ATTR_R | NNPFS_DATA_R;
	msg.node.tokens = entry->tokens;
	msg.offset = entry->fetched_length;
	fcacheentry2nnpfsnode (&fid, fcache_realfid(entry),
			       &entry->status, &msg.node, ae,
			       FCACHE2NNPFSNODE_ALL);
	if (entry->handle.valid)
	    msg.flag |= NNPFS_ID_HANDLE_VALID;
    }

    msg.header.opcode = NNPFS_MSG_INSTALLDATA;

    nnpfs_send_message_wakeup_multiple (fd,
					h->header.sequence_num,
					ret,
					&msg, sizeof(msg),
					NULL, 0);

    prefetch_data(&entry, &ce);

    fcache_release(entry);
    cred_free (ce);
    return ret;

 out:

    if (entry)
	fcache_release(entry);
    cred_free (ce);
    nnpfs_send_message_wakeup_multiple (fd,
					h->header.sequence_num,
					ret,
					NULL, 0);
    return ret;
}

static int
nnpfs_message_getdata (int fd, struct nnpfs_message_getdata *h, u_int size)
{
    struct nnpfs_message_installdata msg;
    VenusFid fid;
    CredCacheEntry *ce;
    int ret;
    AccessEntry *ae;
    size_t offset;
    FCacheEntry *entry = NULL;

    fid = *(VenusFid *)&h->handle;
    arla_warnx (ADEBMSG, "getdata (%ld.%lu.%lu.%lu)",
		(long)fid.Cell, (unsigned long)fid.fid.Volume,
		(unsigned long)fid.fid.Vnode,
		(unsigned long)fid.fid.Unique);

    ce = cred_get (fid.Cell, h->cred.pag, CRED_ANY);
    assert (ce != NULL);

    ret = fcache_get(&entry, fid, ce);
    if (ret)
	goto out;

    assert_flag(entry,kernelp);

 tryagain:

    ret = cm_getattr (entry, ce, &ae);

    if (try_again (&ret, &ce, &h->cred, &fid))
	goto tryagain;
    if (ret)
	goto out;

    if (entry->status.FileType == TYPE_DIR) {
	offset = entry->status.Length;
    } else {     
	offset = h->offset;
	if (offset > entry->status.Length)
	    offset = entry->status.Length;
    }

    arla_warnx (ADEBMSG, "  requested to byte %lu fetching to byte %lu",
		(unsigned long)h->offset, (unsigned long)offset);

    ret = fcache_get_data (&entry, &ce, offset);
    if (try_again (&ret, &ce, &h->cred, &fid))
	goto tryagain;
    if (ret)
	goto out;
     
    if (entry->status.FileType == TYPE_DIR) {
	fcache_cache_handle cache_handle;

	ret = conv_dir (entry, ce, h->tokens,
			&cache_handle,
			msg.cache_name,
			sizeof(msg.cache_name));
	if (ret)
	    goto out;
	msg.cache_handle = cache_handle.nnpfs_handle;
	msg.flag = NNPFS_ID_INVALID_DNLC;
	if (cache_handle.valid)
	    msg.flag |= NNPFS_ID_HANDLE_VALID;
    } else {
	fcache_conv_file_name(entry, msg.cache_name, sizeof(msg.cache_name));
	msg.cache_handle = entry->handle.nnpfs_handle;
	msg.flag = 0;
	if (entry->handle.valid)
	    msg.flag |= NNPFS_ID_HANDLE_VALID;
    }

    entry->flags.datausedp = TRUE;
    entry->tokens |= NNPFS_ATTR_R | NNPFS_DATA_R;
    if (h->tokens & NNPFS_DATA_W)
	entry->tokens |= NNPFS_DATA_W;
    msg.node.tokens = entry->tokens;
    arla_warnx (ADEBMSG, "  got %lu",
		(unsigned long)entry->fetched_length);
    msg.offset = entry->fetched_length;
    fcacheentry2nnpfsnode (&entry->fid, fcache_realfid(entry),
			   &entry->status, &msg.node, ae,
			   FCACHE2NNPFSNODE_ALL);

    msg.header.opcode = NNPFS_MSG_INSTALLDATA;
    
    nnpfs_send_message_wakeup_multiple (fd,
					h->header.sequence_num,
					ret,
					&msg, sizeof(msg),
					NULL, 0);

    prefetch_data(&entry, &ce);
     
    fcache_release(entry);
    cred_free (ce);
    return ret;

 out:
    if (entry)
	fcache_release(entry);
    cred_free (ce);
    nnpfs_send_message_wakeup_multiple (fd,
					h->header.sequence_num,
					ret,
					NULL, 0);

    return ret;
}

/*
 * Send a invalid node to the kernel to invalidate `entry'
 * and record that it's not being used in the kernel.
 */

void
break_callback (FCacheEntry *entry)
{
    struct nnpfs_message_invalidnode msg;
    enum { CALLBACK_BREAK_WARN = 100 };
    static int failed_callbacks_break = 0;
    int ret;

    assert_flag(entry,kernelp);

    /* 
     * Throw away tokens for all directories and unused entries.
     * needs to be same as NNPFS_MSG_INVALIDNODE processing in
     * nnpfs
     */
    if (entry->status.FileType == TYPE_DIR || !entry->flags.datausedp)
	entry->tokens = 0;

    msg.header.opcode = NNPFS_MSG_INVALIDNODE;
    memcpy (&msg.handle, &entry->fid, sizeof(entry->fid));
    ret = nnpfs_message_send (kernel_fd, (struct nnpfs_message_header *)&msg, 
			      sizeof(msg));
    if (ret) {
	arla_warnx (ADEBMSG, "break_callback: (%ld.%lu.%lu.%lu) failed",
		    (long)entry->fid.Cell, 
		    (unsigned long)entry->fid.fid.Volume,
		    (unsigned long)entry->fid.fid.Vnode,
		    (unsigned long)entry->fid.fid.Unique);
	++failed_callbacks_break;
	if (failed_callbacks_break > CALLBACK_BREAK_WARN) {
	    arla_warnx (ADEBWARN, "break_callback: have failed %d times",
			failed_callbacks_break);
	    failed_callbacks_break = 0;
	}
    }
}

/*
 * Send an unsolicited install-attr for the node in `e'
 */

void
install_attr (FCacheEntry *e, int flags)
{
    struct nnpfs_message_installattr msg;

    memset (&msg, 0, sizeof(msg));
    msg.header.opcode = NNPFS_MSG_INSTALLATTR;
    fcacheentry2nnpfsnode (&e->fid, fcache_realfid(e), &e->status, &msg.node,
			   e->acccache, flags);
    e->tokens |= NNPFS_ATTR_R;
    msg.node.tokens   = e->tokens;
    if (!e->flags.datausedp)
	msg.node.tokens &= ~NNPFS_DATA_MASK;

    nnpfs_message_send (kernel_fd, (struct nnpfs_message_header *)&msg, 
			sizeof(msg));
}

void
update_fid(VenusFid oldfid, FCacheEntry *old_entry,
	   VenusFid newfid, FCacheEntry *new_entry)
{
    struct nnpfs_message_updatefid msg;

    msg.header.opcode = NNPFS_MSG_UPDATEFID;
    memcpy (&msg.old_handle, &oldfid, sizeof(oldfid));
    memcpy (&msg.new_handle, &newfid, sizeof(newfid));
    nnpfs_message_send (kernel_fd, (struct nnpfs_message_header *)&msg,
			sizeof(msg));
    if (new_entry != NULL) {
	assert_flag(new_entry,kernelp);
	new_entry->flags.kernelp   = TRUE;
	new_entry->flags.attrusedp = TRUE;
    }
    if (old_entry != NULL) {
	old_entry->flags.kernelp   = FALSE;
	old_entry->flags.attrusedp = FALSE;
	old_entry->flags.datausedp = FALSE;
    }
}

static int
nnpfs_message_inactivenode (int fd, struct nnpfs_message_inactivenode *h, 
			    u_int size)
{
    FCacheEntry *entry;
    VenusFid *fid;
    int ret;
    CredCacheEntry *ce;

    fid = (VenusFid *)&h->handle;
    arla_warnx (ADEBMSG, "inactivenode (%ld.%lu.%lu.%lu)",
		(long)fid->Cell, (unsigned long)fid->fid.Volume,
		(unsigned long)fid->fid.Vnode,
		(unsigned long)fid->fid.Unique);

    ce = cred_get (fid->Cell, 0, CRED_NONE);
    assert (ce != NULL);

    ret = fcache_get (&entry, *fid, ce);
    cred_free (ce);

    if (ret) {
	arla_warnx (ADEBMSG, "nnpfs_message_inactivenode: node not found");
	return 0;
    }

    assert_flag(entry,kernelp);

    if (h->flag & NNPFS_NOREFS)
	fcache_unused (entry);
    if (h->flag & NNPFS_DELETE) {
	entry->flags.kernelp   = FALSE;
	entry->flags.datausedp = FALSE;
	entry->flags.attrusedp = FALSE;
    }
    fcache_release(entry);
    return 0;
}

/*
 * Do we have powers for changing stuff?
 */

static Bool
all_powerful_p (const nnpfs_cred *cred)
{
    return cred->uid == 0;
}

/*
 * Flush the contents of a volume
 */

static int
viocflushvolume (int fd, struct nnpfs_message_pioctl *h, u_int size)
{
    VenusFid fid ;

    if (!h->handle.a && !h->handle.b && !h->handle.c && !h->handle.d)
	return EINVAL;

    fid.Cell = h->handle.a;
    fid.fid.Volume = h->handle.b;
    fid.fid.Vnode = 0;
    fid.fid.Unique = 0;

    arla_warnx(ADEBMSG,
	       "flushing volume (%d, %u)",
	       fid.Cell, fid.fid.Volume);

    fcache_purge_volume(fid);
    volcache_invalidate (fid.fid.Volume, fid.Cell);
    return 0 ;
}

/*
 * Get an ACL for a directory
 */

static int
viocgetacl(int fd, struct nnpfs_message_pioctl *h, u_int size)
{
    VenusFid fid;
    AFSOpaque opaque;
    CredCacheEntry *ce;
    int error;

    if (!h->handle.a && !h->handle.b && !h->handle.c && !h->handle.d)
	return nnpfs_send_message_wakeup (fd, h->header.sequence_num, EINVAL);

    fid.Cell = h->handle.a;
    fid.fid.Volume = h->handle.b;
    fid.fid.Vnode = h->handle.c;
    fid.fid.Unique = h->handle.d;

    ce = cred_get (fid.Cell, h->cred.pag, CRED_ANY);
    assert (ce != NULL);

    do {
	error = getacl (fid, ce, &opaque);
    } while (try_again (&error, &ce, &h->cred, &fid));

    if (error != 0 && error != EACCES)
	error = EINVAL;

    cred_free (ce);
 
    nnpfs_send_message_wakeup_data (fd, h->header.sequence_num, error,
				    opaque.val, opaque.len);
    if (error == 0)
	free (opaque.val);
    return 0;
}

/*
 * Set an ACL for a directory
 */

static int
viocsetacl(int fd, struct nnpfs_message_pioctl *h, u_int size)
{
    VenusFid fid;
    AFSOpaque opaque;
    CredCacheEntry *ce;
    FCacheEntry *e;
    int error;

    if (!h->handle.a && !h->handle.b && !h->handle.c && !h->handle.d)
	return nnpfs_send_message_wakeup (fd, h->header.sequence_num, EINVAL);

    if (h->insize > AFSOPAQUEMAX || h->insize == 0)
	return nnpfs_send_message_wakeup (fd, h->header.sequence_num, EINVAL);

    opaque.val = malloc(h->insize);
    if(opaque.val == NULL)
	return nnpfs_send_message_wakeup (fd, h->header.sequence_num, ENOMEM);

    fid.Cell       = h->handle.a;
    fid.fid.Volume = h->handle.b;
    fid.fid.Vnode  = h->handle.c;
    fid.fid.Unique = h->handle.d;

    ce = cred_get (fid.Cell, h->cred.pag, CRED_ANY);
    assert (ce != NULL);

    opaque.len = h->insize;
    memcpy(opaque.val, h->msg, h->insize);

    do {
	error = setacl (fid, ce, &opaque, &e);
    } while (try_again (&error, &ce, &h->cred, &fid));

    if (error == 0) {
	install_attr (e, FCACHE2NNPFSNODE_ALL);
	fcache_release (e);
    } else if (error != EACCES)
	error = EINVAL;

    cred_free (ce);
    free (opaque.val);
 
    nnpfs_send_message_wakeup_data (fd, h->header.sequence_num, error, NULL, 0);
    return 0;
}

/*
 * Get volume status
 */

static int
viocgetvolstat(int fd, struct nnpfs_message_pioctl *h, u_int size)
{
    VenusFid fid;
    CredCacheEntry *ce;
    AFSFetchVolumeStatus volstat;
    char volumename[AFSNAMEMAX];
    char offlinemsg[AFSOPAQUEMAX];
    char motd[AFSOPAQUEMAX];
    char out[NNPFS_MSG_MAX_DATASIZE];
    char * outstr;
    int32_t outsize = 0;
    int32_t os = 0;
    int32_t osmax = 0;
    int error;

    if (!h->handle.a && !h->handle.b && !h->handle.c && !h->handle.d)
	return nnpfs_send_message_wakeup (fd, h->header.sequence_num, EINVAL);

    fid.Cell = h->handle.a;
    fid.fid.Volume = h->handle.b;
    fid.fid.Vnode = 0;
    fid.fid.Unique = 0;

    ce = cred_get (fid.Cell, h->cred.pag, CRED_ANY);
    assert (ce != NULL);

    memset (volumename, 0, AFSNAMEMAX);
    memset (offlinemsg, 0, AFSOPAQUEMAX);
    memset (motd, 0, AFSOPAQUEMAX);

    memset (out, 0, sizeof(out));

    do {
	error = getvolstat (fid, ce, &volstat,
			    volumename, sizeof(volumename),
			    offlinemsg,
			    motd);
    } while (try_again (&error, &ce, &h->cred, &fid));

    cred_free (ce);

    if (error != 0 && error != EACCES)
	error = EINVAL;

    memcpy (out, (char *) &volstat, sizeof (AFSFetchVolumeStatus));
    outsize = sizeof (AFSFetchVolumeStatus);
    outstr = out + outsize;
    os = 0;
    osmax = sizeof(out) - outsize;

    if (os < osmax && (volumename[0]))
	os = strlcat(outstr, volumename, osmax);
    else {
	*outstr++ = '\0';
	outsize++;
	osmax--;
    }
    if (os < osmax && (offlinemsg[0]))
	os = strlcat(outstr, offlinemsg, osmax);
    else {
	*outstr++ = '\0';
	outsize++;
	osmax--;
    }
    if (os < osmax && (motd[0]))
	os = strlcat(outstr, motd, osmax);
    else {
	*outstr++ = '\0';
	outsize++;
	osmax--;
    }
    /* this can potentially truncate the motd..  who cares */
    if (os + outsize >= sizeof(out)) {
	    /* XXX warn about trucated motd */
	    arla_warnx(ADEBMSG,
		"truncated motd by %d bytes", os + outsize - sizeof(out));
	    outsize = sizeof(out);
    } else
	    outsize += os;

    nnpfs_send_message_wakeup_data (fd, h->header.sequence_num, error,
				    out, outsize);
    return 0;
}

/*
 * Set volume status
 */

static int
viocsetvolstat(int fd, struct nnpfs_message_pioctl *h, u_int size)
{
    VenusFid fid;
    CredCacheEntry *ce;
    AFSFetchVolumeStatus *involstat;
    AFSStoreVolumeStatus outvolstat;
    char volumename[AFSNAMEMAX];
    char offlinemsg[AFSOPAQUEMAX];
    char motd[AFSOPAQUEMAX];
    int error;
    char *ptr;

    if (!h->handle.a && !h->handle.b && !h->handle.c && !h->handle.d)
	return EINVAL;

    fid.Cell = h->handle.a;
    fid.fid.Volume = h->handle.b;
    fid.fid.Vnode = 0;
    fid.fid.Unique = 0;

    ce = cred_get (fid.Cell, h->cred.pag, CRED_ANY);
    assert (ce != NULL);

    involstat = (AFSFetchVolumeStatus *) h->msg;
    outvolstat.Mask = 0x3; /* Store both the next fields */
    outvolstat.MinQuota = involstat->MinQuota;
    outvolstat.MaxQuota = involstat->MaxQuota;

    ptr = h->msg + sizeof (AFSFetchVolumeStatus);

#if 0
    if (*ptr) {
	strncpy (volumename, ptr, AFSNAMEMAX);
	ptr += strlen (ptr);
    }
    else {
	memset (volumename, 0, AFSNAMEMAX);
	ptr++; /* skip 0 character */
    }

    if (*ptr) {
	strncpy (offlinemsg, ptr, AFSOPAQUEMAX);
	ptr += strlen (ptr);
    }
    else {
	memset (offlinemsg, 0, AFSOPAQUEMAX);
	ptr++;
    }

    strncpy (motd, ptr, AFSOPAQUEMAX);
#else
    volumename[0] = '\0';
    offlinemsg[0] = '\0';
    motd[0] = '\0';
#endif

    do {
	error = setvolstat (fid, ce, &outvolstat, volumename,
			    offlinemsg, motd);
    } while (try_again (&error, &ce, &h->cred, &fid));

    if (error != 0 && error != EACCES)
	error = EINVAL;

    cred_free (ce);

    nnpfs_send_message_wakeup_data (fd, h->header.sequence_num, error,
				    NULL, 0);
    return 0;
}

/*
 * Get the mount point at (`fid', `filename') using the cred in `ce'
 * and returning the fcache entry in `ret_mp_entry'
 * Return 0 or an error.
 */

static int
get_mount_point (VenusFid fid,
		 const char *filename,
		 CredCacheEntry **ce,
		 FCacheEntry **ret_mp_entry)
{
    FCacheEntry *mp_entry;
    FCacheEntry *dentry;
    VenusFid mp_fid;
    int error;

    if (fid.fid.Volume == 0 && fid.fid.Vnode == 0 && fid.fid.Unique == 0)
	return EINVAL;

    error = fcache_get(&dentry, fid, *ce);
    if (error)
	return error;

    error = fcache_get_data(&dentry, ce, 0);
    if (error) {
	fcache_release(dentry);
	return error;
    }

    error = adir_lookup(dentry, filename, &mp_fid);
    fcache_release(dentry);
    if (error)
	return error;

    error = fcache_get(&mp_entry, mp_fid, *ce);
    if (error)
	return error;

    error = fcache_verify_attr (mp_entry, dentry, filename, *ce);
    if (error) {
	fcache_release(mp_entry);
	return error;
    }

    if ((mp_entry->status.FileType != TYPE_LINK
	 && !mp_entry->flags.fake_mp)
	|| mp_entry->status.Length == 0) { 	/* Is not a mount point */
	fcache_release(mp_entry);
	return EINVAL;
    }
    *ret_mp_entry = mp_entry;
    return 0;
}

/*
 * Read the contents of the mount point in `e' and return a fbuf in
 * `the_fbuf' mapped READ|WRITE|PRIVATE.
 * Return 0 or an error
 */

static int
read_mount_point (FCacheEntry **mp_entry, CredCacheEntry **ce,
		  int *fd, fbuf *the_fbuf)
{
    int error;
    char *buf;

    error = fcache_get_data (mp_entry, ce, 0);
    if (error)
	return error;

    *fd = fcache_open_file (*mp_entry, O_RDONLY);
    if (*fd < 0)
	return errno;

    error = fbuf_create (the_fbuf, *fd, (*mp_entry)->status.Length,
			 FBUF_READ|FBUF_WRITE|FBUF_PRIVATE);
    if (error) {
	close (*fd);
	return error;
    }

    buf = (char *)(the_fbuf->buf);
    if (buf[0] != '#' && buf[0] != '%') { /* Is not a mount point */
	fbuf_end (the_fbuf);
	close (*fd);
	return EINVAL;
    }

    return 0;
}

/*
 * Get info for a mount point.
 */

static int
vioc_afs_stat_mt_pt(int fd, struct nnpfs_message_pioctl *h, u_int size)
{
    VenusFid fid;
    int error;
    int mp_fd;
    fbuf the_fbuf;
    CredCacheEntry *ce;
    FCacheEntry *e;
    unsigned char *buf;

    fid.Cell       = h->handle.a;
    fid.fid.Volume = h->handle.b;
    fid.fid.Vnode  = h->handle.c;
    fid.fid.Unique = h->handle.d;

    h->msg[min(h->insize, sizeof(h->msg)-1)] = '\0';

    ce = cred_get (fid.Cell, h->cred.pag, CRED_ANY);
    assert (ce != NULL);

    error = get_mount_point (fid, h->msg, &ce, &e);
    if (error) {
	cred_free(ce);
	return nnpfs_send_message_wakeup (fd, h->header.sequence_num, error);
    }

    error = read_mount_point (&e, &ce, &mp_fd, &the_fbuf);
    if (error) {
	fcache_release (e);
	cred_free(ce);
	return nnpfs_send_message_wakeup (fd, h->header.sequence_num, error);
    }

    /*
     * To confuse us, the volume is passed up w/o the ending
     * dot. It's not even mentioned in the ``VIOC_AFS_STAT_MT_PT''
     * documentation.
     */

    buf = (unsigned char *)the_fbuf.buf;
    buf[the_fbuf.len-1] = '\0';

    nnpfs_send_message_wakeup_data (fd, h->header.sequence_num, error,
				    buf, the_fbuf.len);
    fbuf_end (&the_fbuf);
    close (mp_fd);
    fcache_release (e);
    cred_free (ce);

    return 0;
}

/*
 * Handle the VIOC_AFS_DELETE_MT_PT message in `h' by deleting the
 * mountpoint.  
 */

static int
vioc_afs_delete_mt_pt(int fd, struct nnpfs_message_pioctl *h, u_int size)
{
    VenusFid fid;
    int error = 0;
    CredCacheEntry *ce;
    struct nnpfs_message_remove remove_msg;
    FCacheEntry *entry;

    h->msg[min(h->insize, sizeof(h->msg)-1)] = '\0';

    fid.Cell       = h->handle.a;
    fid.fid.Volume = h->handle.b;
    fid.fid.Vnode  = h->handle.c;
    fid.fid.Unique = h->handle.d;

    ce = cred_get (fid.Cell, h->cred.pag, CRED_ANY);
    assert (ce != NULL);

    error = get_mount_point (fid, h->msg, &ce, &entry);
    cred_free (ce);
    if (error)
	return nnpfs_send_message_wakeup (fd, h->header.sequence_num, error);
    fcache_release(entry);

    remove_msg.header        = h->header;
    remove_msg.header.size   = sizeof(remove_msg);
    remove_msg.parent_handle = h->handle;
    strlcpy(remove_msg.name, h->msg, sizeof(remove_msg.name));
    remove_msg.cred          = h->cred;

    return nnpfs_message_remove (fd, &remove_msg, sizeof(remove_msg));
}

static int
viocwhereis(int fd, struct nnpfs_message_pioctl *h, u_int size)
{
    VenusFid fid;
    CredCacheEntry *ce;
    FCacheEntry *e;
    int error;
    int i, j;
    int32_t addresses[8];
    int bit;

    if (!h->handle.a && !h->handle.b && !h->handle.c && !h->handle.d)
	return nnpfs_send_message_wakeup (fd, h->header.sequence_num, EINVAL);

    fid.Cell       = h->handle.a;
    fid.fid.Volume = h->handle.b;
    fid.fid.Vnode  = h->handle.c;
    fid.fid.Unique = h->handle.d;

    ce = cred_get (fid.Cell, h->cred.pag, CRED_ANY);
    assert (ce != NULL);

    error = fcache_get(&e, fid, ce);
    if (error) {
	cred_free(ce);
	return nnpfs_send_message_wakeup (fd, h->header.sequence_num, error);
    }
    error = fcache_verify_attr (e, NULL, NULL, ce);
    if (error) {
	fcache_release(e);
	cred_free(ce);
	return nnpfs_send_message_wakeup (fd, h->header.sequence_num, error);
    }

    bit = volcache_volid2bit (e->volume, fid.fid.Volume);

    if (bit == -1) {
	fcache_release(e);
	cred_free(ce);
	return nnpfs_send_message_wakeup (fd, h->header.sequence_num, EINVAL);
    }

    memset(addresses, 0, sizeof(addresses));
    for (i = 0, j = 0; i < min(e->volume->entry.nServers, MAXNSERVERS); i++) {
	u_long addr = htonl(e->volume->entry.serverNumber[i]);

	if ((e->volume->entry.serverFlags[i] & bit) && addr != 0)
	    addresses[j++] = addr;
    }
    nnpfs_send_message_wakeup_data (fd, h->header.sequence_num, error,
				    addresses, sizeof(long) * j);

    fcache_release(e);
    cred_free (ce);

    return 0;
}

/*
 * Return all db servers for a particular cell.
 */ 

static int
vioc_get_cell(int fd, struct nnpfs_message_pioctl *h, u_int size)
{
    int i;
    int32_t index;
    const char *cellname;
    int cellname_len;
    int outsize;
    char out[8 * sizeof(int32_t) + MAXPATHLEN]; /* XXX */
    const cell_db_entry *dbservers;
    int num_dbservers;

    index = *((int32_t *) h->msg);
    cellname = cell_num2name(index);
    if (cellname == NULL)
	return nnpfs_send_message_wakeup (fd, h->header.sequence_num, EDOM);
    
    dbservers = cell_dbservers_by_id (index, &num_dbservers);

    if (dbservers == NULL)
	return nnpfs_send_message_wakeup (fd, h->header.sequence_num, EDOM);

    memset(out, 0, sizeof(out));
    cellname_len = min(strlen(cellname), MAXPATHLEN - 1);
    memcpy(out + 8 * sizeof(int32_t), cellname, cellname_len);
    out[8 * sizeof(int32_t) + cellname_len] = '\0';
    outsize = 8 * sizeof(int32_t) + cellname_len + 1;
    for (i = 0; i < min(num_dbservers, 8); ++i) {
	uint32_t addr = dbservers[i].addr.s_addr;
	memcpy (&out[i * sizeof(int32_t)], &addr, sizeof(int32_t));
    }

    nnpfs_send_message_wakeup_data (fd, h->header.sequence_num, 0,
				    out, outsize);

    return 0;
}

/*
 * Return status information about a cell.
 */

static int
vioc_get_cellstatus(int fd, struct nnpfs_message_pioctl *h, u_int size)
{
    char *cellname;
    int32_t cellid;
    uint32_t out = 0;

    cellname = h->msg;
    cellname[h->insize-1]  = '\0';

    cellid = cell_name2num (cellname);
    if (cellid == -1)
	return nnpfs_send_message_wakeup (fd, h->header.sequence_num, ENOENT);

    if (cellid == 0)
	out |= CELLSTATUS_PRIMARY;
    if (cell_issuid_by_num (cellid))
	out |= CELLSTATUS_SETUID;

    nnpfs_send_message_wakeup_data (fd, h->header.sequence_num, 0,
				    &out, sizeof(out));

    return 0;
}

/*
 * Set status information about a cell.
 */

static int
vioc_set_cellstatus(int fd, struct nnpfs_message_pioctl *h, u_int size)
{
    int32_t cellid;
    char *cellname;
    uint32_t in = 0;
    int ret;

    if (!all_powerful_p (&h->cred))
	return nnpfs_send_message_wakeup (fd, h->header.sequence_num, EACCES);

    if (h->insize < sizeof (in) + 2) /* terminating NUL and one char */
	return nnpfs_send_message_wakeup (fd, h->header.sequence_num, EINVAL);

    cellname = h->msg + sizeof (in);
    cellname[h->insize-1-sizeof(in)]  = '\0';

    cellid = cell_name2num (cellname);
    if (cellid == -1)
	return nnpfs_send_message_wakeup (fd, h->header.sequence_num, ENOENT);

    if (in & CELLSTATUS_SETUID) { 
	ret = cell_setsuid_by_num (cellid);
	if (ret)
	    return nnpfs_send_message_wakeup (fd, h->header.sequence_num,EINVAL);
    }

    nnpfs_send_message_wakeup (fd, h->header.sequence_num, 0);

    return 0;
}

/*
 * Set information about a cell or add a new one.
 */

static int
vioc_new_cell(int fd, struct nnpfs_message_pioctl *h, u_int size)
{
    const char *cellname;
    cell_entry *ce;
    int count, i;
    uint32_t *hp;
    cell_db_entry *dbs;

    if (!all_powerful_p (&h->cred))
	return nnpfs_send_message_wakeup (fd, h->header.sequence_num, EPERM);
	    
    if (h->insize < 9)
	return nnpfs_send_message_wakeup (fd, h->header.sequence_num, EINVAL);

    hp = (uint32_t *)h->msg;
    for (count = 0; *hp != 0; ++hp)
	++count;

    dbs = calloc (count, sizeof(*dbs));
    if (dbs == NULL)
	return nnpfs_send_message_wakeup (fd, h->header.sequence_num, ENOMEM);

    hp = (uint32_t *)h->msg;
    for (i = 0; i < count; ++i) {
	dbs[i].name = NULL;
	dbs[i].addr.s_addr = hp[i];
	dbs[i].timeout = 0;
    }

    cellname = h->msg + 8 * sizeof(uint32_t);
    ce = cell_get_by_name (cellname);
    if (ce == NULL) {
	ce = cell_new_dynamic (cellname);

	if (ce == NULL) {
	    free (dbs);
	    return nnpfs_send_message_wakeup (fd, h->header.sequence_num,
					      ENOMEM);
	}
    } else {
	free (ce->dbservers);
    }

    ce->ndbservers = count;
    ce->dbservers  = dbs;

    return nnpfs_send_message_wakeup (fd, h->header.sequence_num, 0);
}

#ifdef KERBEROS

/*
 * Return the token for the cell in `ce'
 */

static int
token_for_cell (int fd, struct nnpfs_message_pioctl *h, u_int size,
		CredCacheEntry *ce)
{
    char buf[NNPFS_MSG_MAX_DATASIZE];
    size_t len, cell_len;
    char *p = buf;
    uint32_t tmp;
    struct cred_rxkad *cred = (struct cred_rxkad *)ce->cred_data;
    const char *cell = cell_num2name (ce->cell);

    cell_len = strlen(cell);

    len = 4 + cred->ticket_len + 4 + sizeof(cred->ct) + 4 + cell_len;
    if (len > sizeof(buf))
	return nnpfs_send_message_wakeup (fd, h->header.sequence_num, EINVAL);

    tmp = cred->ticket_len;
    memcpy (p, &tmp, sizeof(tmp));
    p += sizeof(tmp);
    memcpy (p, cred->ticket, tmp);
    p += tmp;
    tmp = sizeof(cred->ct);
    memcpy (p, &tmp, sizeof(tmp));
    p += sizeof(tmp);
    memcpy (p, &cred->ct, sizeof(cred->ct));
    p += sizeof(cred->ct);
    tmp = 0;
    memcpy (p, &tmp, sizeof(tmp));
    p += sizeof(tmp);
    strlcpy (p, cell, buf + sizeof buf - cell);
    p += strlen(cell) + 1;

    len = p - buf;

    cred_free (ce);

    nnpfs_send_message_wakeup_data (fd, h->header.sequence_num, 0,
				    buf, len);
    return 0;
}

struct get_tok {
    int32_t counter;
    int32_t cell;
};

static int
gettok_func(CredCacheEntry *ce, void *ptr)
{
    struct get_tok *gt = ptr;

    if (gt->counter == 0) {
	gt->cell = ce->cell;
	return 1;
    }

    gt->counter--;
    return 0;
}


/*
 * Handle the GETTOK message in `h'
 */

static int
viocgettok (int fd, struct nnpfs_message_pioctl *h, u_int size)
{
    CredCacheEntry *ce;
    int32_t cell_id;

    if (h->insize == 0) {
	cell_id = cell_name2num(cell_getthiscell());
    } else if (h->insize == sizeof(uint32_t)) {
	struct get_tok gt;
	int32_t n;

	memcpy (&n, h->msg, sizeof(n));

	if (n < 0) {
	    nnpfs_send_message_wakeup (fd, h->header.sequence_num, EINVAL);
	    return 0;
	}

	gt.counter = n;
	gt.cell = -1;

	cred_list_pag(h->cred.pag, CRED_KRB4, gettok_func, &gt);

	if (gt.cell == -1) {
	    nnpfs_send_message_wakeup (fd, h->header.sequence_num, EDOM);
	    return 0;
	}

	cell_id = gt.cell;
    } else {
	nnpfs_send_message_wakeup (fd, h->header.sequence_num, EINVAL);
	return 0;
    }

    ce = cred_get (cell_id, h->cred.pag, CRED_KRB4);
    if (ce == NULL) {
	nnpfs_send_message_wakeup (fd, h->header.sequence_num, ENOTCONN);
	return 0;
    }

    return token_for_cell (fd, h, size, ce);
}

/*
 * Handle the SETTOK message in `h'
 */

static int
viocsettok (int fd, struct nnpfs_message_pioctl *h, u_int size)
{
    struct cred_rxkad cred;
    long cell;
    char realm[256];
    int32_t sizeof_x;
    char *t = h->msg;

    /* someone probed us */
    if (h->insize == 0)
	return EINVAL;
    if (h->insize < 4)
	return EINVAL;

    /* Get ticket_st */
    memcpy(&sizeof_x, t, sizeof(sizeof_x)) ;
    cred.ticket_len = sizeof_x;
    arla_warnx (ADEBMSG, "ticket_st has size %d", sizeof_x);
    t += sizeof(sizeof_x) ;

    /* data used + datalen + cleartoken's length field */
    if ((t - (char *)h->msg) + sizeof_x + 4 > h->insize)
	return EINVAL;
    if (sizeof_x > sizeof(cred.ticket))
	return EINVAL;
    
    memcpy(cred.ticket, t, sizeof_x) ;
    t += sizeof_x ;
    
    /* Get ClearToken */
    memcpy(&sizeof_x, t, sizeof(sizeof_x)) ;
    t += sizeof(sizeof_x) ;
    
    /* data used + datalen + cell's length field */
    if ((t - (char *)h->msg) + sizeof_x + 4 > h->insize)
	return EINVAL;
    
    memcpy(&cred.ct, t, sizeof_x) ;
    t += sizeof_x ;

    /* Get primary cell ? */
    memcpy(&sizeof_x, t, sizeof(sizeof_x)) ;
    t += sizeof(sizeof_x) ;
    
    /* Get Cellname */ 
    strlcpy(realm, t, min(h->insize - (t - (char *)h->msg), sizeof(realm)));
    strlwr(realm);

    cell = cell_name2num(realm);

    if (cell == -1)
	return ENOENT;

    conn_clearcred (CONN_CS_ALL, cell, h->cred.pag, 2);
    fcache_purge_cred(h->cred.pag, cell);
    cred_add (h->cred.pag, CRED_KRB4, 2, cell, cred.ct.EndTimestamp,
	      &cred, sizeof(cred), cred.ct.ViceId);
    return 0;
}

static int
viocunlog (int fd, struct nnpfs_message_pioctl *h, u_int size)
{
    nnpfs_pag_t cred = h->cred.pag;

    cred_remove(cred);
    fcache_purge_cred(cred, -1);
    return 0;
}

#if defined(HAVE_KRB5) && defined(WITH_RXGK)

/*
 * handle rxgk kerberos 5 authenticator
 *
 * format:
 *  int32_t ticket_len
 *  char krb5_ticket[];
 *  int32_t kvno;
 *  int32_t krb5_enctype;
 *  int32_t viceid;
 *  int32_t sessionkey_len;
 *  char sessionkey[];
 *  int64_t start_time;
 *  int64_t expiration_time;
 *  char cell[]
 */

size_t k5ticket_limit_size = 40 * 1024;

static int
k5settok (int fd, struct nnpfs_message_pioctl *h, u_int size)
{
    struct cred_rxgk c;
    char cellname[256];
    uint32_t sizeof_x;
    uint64_t endtime;
    int32_t viceid;
    long cell;
    char *t = h->msg;
    int insize = h->insize;

    if (insize < 4)
	return EINVAL;

    memcpy(&sizeof_x, t, sizeof(sizeof_x)) ;
    arla_warnx (ADEBMSG, "ticket has size %d", sizeof_x);
    t += sizeof(sizeof_x) ;

    if (sizeof_x < k5ticket_limit_size || sizeof_x > insize)
	return EINVAL;

    c.type = CRED_GK_K5;

    c.t.k5.ticket = malloc(sizeof_x);
    if (c.t.k5.ticket == NULL)
	return ENOMEM;

    memcpy(c.t.k5.ticket, t, sizeof_x);
    insize -= sizeof_x;
    t += sizeof_x;

    if (h->insize < 4 + 4 + 4 + 4) {
	free(c.t.k5.ticket);
	return EINVAL;
    }

    memcpy(&sizeof_x, t, sizeof(sizeof_x));
    t += sizeof(sizeof_x); insize -= sizeof(sizeof_x);
    c.t.k5.enctype = sizeof_x;

    memcpy(&sizeof_x, t, sizeof(sizeof_x));
    t += sizeof(sizeof_x); insize -= sizeof(sizeof_x);
    c.t.k5.kvno = sizeof_x;

    memcpy(&sizeof_x, t, sizeof(sizeof_x));
    t += sizeof(sizeof_x); insize -= sizeof(sizeof_x);
    viceid = sizeof_x;

    memcpy(&sizeof_x, t, sizeof(sizeof_x));
    t += sizeof(sizeof_x); insize -= sizeof(sizeof_x);
    c.t.k5.sessionkey_len = sizeof_x;

    if (sizeof_x < k5ticket_limit_size || sizeof_x > insize) {
	free(c.t.k5.ticket);
	return EINVAL;
    }

    c.t.k5.sessionkey = malloc(c.t.k5.sessionkey_len);
    if (c.t.k5.sessionkey == NULL) {
	free(c.t.k5.ticket);
	return EINVAL;
    }

    memcpy(c.t.k5.sessionkey, t, c.t.k5.sessionkey_len);
    t += c.t.k5.sessionkey_len;
    insize -= c.t.k5.sessionkey_len;


    if (insize < 8 + 8 + 1) {
	free(c.t.k5.sessionkey);
	free(c.t.k5.ticket);
	return EINVAL;
    }

    t += 8;
    insize -= 8;

    memcpy(&endtime, t, sizeof(endtime));
    t += 8;
    insize -= 8;
    
    if (insize > sizeof(cellname) || t[insize - 1] != '\0') {
	free(c.t.k5.sessionkey);
	free(c.t.k5.ticket);
	return EINVAL;
    }

    strlcpy(cellname, t, sizeof(cellname));

    cell = cell_name2num(strlwr(cellname));

    if (cell == -1) {
	free(c.t.k5.sessionkey);
	free(c.t.k5.ticket);
	return ENOENT;
    }

    conn_clearcred (CONN_CS_ALL, cell, h->cred.pag, 2);
    fcache_purge_cred(h->cred.pag, cell);
    cred_add (h->cred.pag, CRED_GK_K5, 2, cell, (time_t)endtime,
	      &c, sizeof(c), viceid);
    return 0;
}

#endif /* HAVE_KRB5  && WITH_RXGK */

#endif /* KERBEROS */

/*
 * Flush the fid in `h->handle' from the cache.
 */

static int
viocflush (int fd, struct nnpfs_message_pioctl *h, u_int size)
{
    VenusFid fid ;
    AFSCallBack broken_callback = {0, 0, CBDROPPED};

    if (!h->handle.a && !h->handle.b && !h->handle.c && !h->handle.d)
	return EINVAL;

    fid.Cell       = h->handle.a;
    fid.fid.Volume = h->handle.b;
    fid.fid.Vnode  = h->handle.c;
    fid.fid.Unique = h->handle.d;

    arla_warnx(ADEBMSG,
	       "flushing (%d, %u, %u, %u)",
	       fid.Cell, fid.fid.Volume, fid.fid.Vnode, fid.fid.Unique);

    fcache_stale_entry(fid, broken_callback);
    return 0 ;
}

static int
viocconnect(int fd, struct nnpfs_message_pioctl *h, u_int size)
{
    char *p = h->msg;
    int32_t tmp;
    int32_t ret;
    int error = 0;

    if (h->insize != sizeof(int32_t) ||
	h->outsize != sizeof(int32_t)) {

	ret = -EINVAL;
    } else {
    
	memcpy(&tmp, h->msg, sizeof(tmp));
	p += sizeof(tmp);

	ret = tmp;

	/* check permission */
	switch (tmp) {
	case CONNMODE_PROBE:
	    break;
	default:
	    if (!all_powerful_p(&h->cred))
		return EPERM;
	    break;
	}

	switch(tmp) {
	case CONNMODE_PROBE:
	    switch(connected_mode) {
	    case CONNECTED: ret = CONNMODE_CONN; break;
	    case FETCH_ONLY: ret = CONNMODE_FETCH; break;
	    case DISCONNECTED: ret = CONNMODE_DISCONN; break;
	    default:
		error = EINVAL;
		ret = 0;
		break;
	    }
	    break;
	case CONNMODE_CONN:
	case CONNMODE_CONN_WITHCALLBACKS:
	    disco_closelog();

	    cmcb_reinit();

	    if (disco_need_integrate())
		disco_reintegrate(h->cred.pag);

	    if (tmp == CONNMODE_CONN_WITHCALLBACKS)
		fcache_reobtain_callbacks (&h->cred);

	    connected_mode = CONNECTED ;
	    break;
	case CONNMODE_FETCH:
	    disco_openlog();
	    connected_mode = FETCH_ONLY ;
	    break;
	case CONNMODE_DISCONN:
	    disco_openlog();
	    if (possibly_have_network())
		fcache_giveup_all_callbacks();
	    connected_mode = DISCONNECTED;
	    break;
	default:
	    error = EINVAL;
	    break;
	}
    }

    nnpfs_send_message_wakeup_data (fd, h->header.sequence_num, error,
				    &ret, sizeof(ret));
    return 0;
}

static int
getrxkcrypt(int fd, struct nnpfs_message_pioctl *h, u_int size)
{
    if (h->outsize == sizeof(uint32_t)) {
	uint32_t n;

#ifdef KERBEROS
	if (conn_rxkad_level == rxkad_crypt)
	    n = 1;
	else
#endif
	    n = 0;

	return nnpfs_send_message_wakeup_data (fd,
					       h->header.sequence_num,
					       0,
					       &n,
					       sizeof(n));
    } else
	return nnpfs_send_message_wakeup (fd, h->header.sequence_num, EINVAL);
}

static int
setrxkcrypt(int fd, struct nnpfs_message_pioctl *h, u_int size)
{
#ifdef KERBEROS
    int error = 0;

    if (!all_powerful_p(&h->cred))
	return EPERM;

    if (h->insize == sizeof(uint32_t)) {
	uint32_t n;

	memcpy (&n, h->msg, sizeof(n));

	if (n == 0)
	    conn_rxkad_level = rxkad_auth;
	else if(n == 1)
	    conn_rxkad_level = rxkad_crypt;
	else
	    error = EINVAL;
	if (error == 0)
	    conn_clearcred (CONN_CS_SECIDX, 0, -1, 2);
    } else
	error = EINVAL;
    return error;
#else
    return EOPNOTSUPP;
#endif
}

/*
 * XXX - this function sometimes does a wakeup_data and then an ordinary wakeup is sent in nnpfs_message_pioctl
 */

static int
vioc_fpriostatus (int fd, struct nnpfs_message_pioctl *h, u_int size)
{
    struct vioc_fprio *fprio;
    int error = 0;
    VenusFid fid;

    if (h->insize != sizeof(struct vioc_fprio))
	return EINVAL;

    fprio = (struct vioc_fprio *) h->msg;

    fid.Cell = fprio->Cell ;
    fid.fid.Volume = fprio->Volume ;
    fid.fid.Vnode = fprio->Vnode ;
    fid.fid.Unique = fprio->Unique ;

    if (!all_powerful_p(&h->cred))
	return EPERM;

#if 0
    switch(fprio->cmd) {
    case FPRIO_GET: {
	unsigned prio;

	if (h->outsize != sizeof(unsigned)) {
	    error = EINVAL;
	    break;
	}

	prio = fprio_get(fid);
	nnpfs_send_message_wakeup_data (fd,
					h->header.sequence_num,
					0,
					&prio,
					sizeof(prio));

	break;
    }
    case FPRIO_SET:
	if (fprio->prio == 0) {
	    fprio_remove(fid);
	    error = 0;
	} else if (fprio->prio < FPRIO_MIN ||
		   fprio->prio > FPRIO_MAX)
	    error = EINVAL;
	else {
	    fprio_set(fid, fprio->prio);
	    error = 0;
	}
	break;
    case FPRIO_GETMAX: 
	if (h->outsize != sizeof(unsigned)) {
	    error = EINVAL;
	    break;
	}

	nnpfs_send_message_wakeup_data (fd,
					h->header.sequence_num,
					0,
					&fprioritylevel,
					sizeof(fprioritylevel));
	error = 0;
	break;
    case FPRIO_SETMAX: 
	if (fprio->prio < FPRIO_MIN ||
	    fprio->prio > FPRIO_MAX)
	    error = EINVAL;
	else {
	    fprioritylevel = fprio->prio;
	    error = 0;
	}
	break;
    default:
	error = EINVAL;
	break;
    }
#endif
    return error;
}

static int
viocgetfid (int fd, struct nnpfs_message_pioctl *h, u_int size)
{
    return nnpfs_send_message_wakeup_data(fd, h->header.sequence_num, 0,
					  &h->handle, sizeof(VenusFid));
}

static int
viocvenuslog (int fd, struct nnpfs_message_pioctl *h, u_int size)
{
    if (!all_powerful_p(&h->cred))
	return EPERM;
	    
    conn_status ();
    volcache_status ();
    cred_status ();
    fcache_status ();
    cell_status (stderr);
#if 0
    fprio_status ();
#endif
#ifdef RXDEBUG
    rx_PrintStats(stderr);
#endif
    return 0;
}

/*
 * Set or get the sysname
 */

static int
vioc_afs_sysname (int fd, struct nnpfs_message_pioctl *h, u_int size)
{
    char *t = h->msg;
    int32_t parm = *((int32_t *)t);

    if (parm) {
	char t_sysname[SYSNAMEMAXLEN];
	int size;

	if (!all_powerful_p (&h->cred))
	    return nnpfs_send_message_wakeup (fd,
					      h->header.sequence_num,
					      EPERM);
	t += sizeof(int32_t);
	arla_warnx (ADEBMSG, "VIOC_AFS_SYSNAME: setting sysname: %s", t);

	size = min(h->insize, SYSNAMEMAXLEN);

	memcpy(t_sysname, t, size);
	t_sysname[size - 1] = '\0';

	fcache_setdefsysname (t_sysname);

	return nnpfs_send_message_wakeup(fd, h->header.sequence_num, 0);
    } else {
	char *buf;
	const char *sysname = fcache_getdefsysname ();
	size_t sysname_len = strlen (sysname);
	int ret;

	buf = malloc (sysname_len + 4 + 1);
	if (buf == NULL)
	    return nnpfs_send_message_wakeup (fd, h->header.sequence_num,
					      ENOMEM);
	/* Return always 1 as we do not support sysname lists.             */
	/* Historically the value of this uint32 has been success/failure. */
	/* OpenAFS' utilities treat this value as the number of elements   */
	/* in a list of returned sysnames. It was never meant to be buflen.*/
	*((uint32_t *)buf) = 1;
	memcpy (buf + 4, sysname, sysname_len);
	buf[sysname_len + 4] = '\0';

	ret = nnpfs_send_message_wakeup_data (fd, h->header.sequence_num, 0,
					      buf, sysname_len + 5);
	free (buf);
	return ret;
    }
}

static int
viocfilecellname (int fd, struct nnpfs_message_pioctl *h, u_int size)
{
    char *cellname;

    cellname = (char *) cell_num2name(h->handle.a);

    if (cellname) 
	return nnpfs_send_message_wakeup_data(fd, h->header.sequence_num, 0,
					      cellname, strlen(cellname)+1);
    else 
	return nnpfs_send_message_wakeup_data(fd, h->header.sequence_num, EINVAL,
					      NULL, 0);
}

static int
viocgetwscell (int fd, struct nnpfs_message_pioctl *h, u_int size)
{
    char *cellname;

    cellname = (char*) cell_getthiscell();
    return nnpfs_send_message_wakeup_data(fd, h->header.sequence_num, 0,
					  cellname, strlen(cellname)+1);
}

static int
viocsetcachesize (int fd, struct nnpfs_message_pioctl *h, u_int size)
{
    uint32_t *s = (uint32_t *)h->msg;

    if (!all_powerful_p (&h->cred))
	return EPERM;
	
    if (h->insize >= sizeof(int32_t) * 4) 
	return fcache_reinit(s[0], s[1], s[2], s[3]);
    else
	return fcache_reinit(*s/2, *s, *s*500, *s*1000);
}

/*
 * VIOCCKSERV
 *
 *  in:  flags	- bitmask (1 - dont ping, use cached data, 2 - check fsservers only)
 *       cell	- string (optional)
 *  out: hosts  - uint32_t number of hosts, followed by list of hosts being down.
 */

static int
viocckserv (int fd, struct nnpfs_message_pioctl *h, u_int size)
{
    int32_t cell = cell_name2num (cell_getthiscell());
    int flags = 0;
    int num_entries;
    uint32_t hosts[CKSERV_MAXSERVERS + 1];
    int msg_size;

    if (h->insize < sizeof(int32_t))
	return nnpfs_send_message_wakeup (fd, h->header.sequence_num, EINVAL);

    memset (hosts, 0, sizeof(hosts));

    flags = *(uint32_t *)h->msg;
    flags &= CKSERV_DONTPING|CKSERV_FSONLY;

    if (h->insize > sizeof(int32_t)) {
	h->msg[min(h->insize, sizeof(h->msg)-1)] = '\0';

	cell = cell_name2num (((char *)h->msg) + sizeof(int32_t));
	if (cell == -1)
	    return nnpfs_send_message_wakeup (fd, h->header.sequence_num, ENOENT);
    }
    
    num_entries = CKSERV_MAXSERVERS;
    
    conn_downhosts(cell, hosts + 1, &num_entries, flags);
    
    hosts[0] = num_entries;
    msg_size = sizeof(hosts[0]) * (num_entries + 1);
    return nnpfs_send_message_wakeup_data (fd, h->header.sequence_num, 0,
					   hosts, msg_size);
}


/*
 * Return the number of used KBs and reserved KBs
 */

static int
viocgetcacheparms (int fd, struct nnpfs_message_pioctl *h, u_int size)
{
    uint32_t parms[16];
    
    memset(parms, 0, sizeof(parms));
    parms[0] = fcache_highbytes() / 1024;
    parms[1] = fcache_usedbytes() / 1024;
    parms[2] = fcache_highvnodes();
    parms[3] = fcache_usedvnodes();
    parms[4] = fcache_highbytes();
    parms[5] = fcache_usedbytes();
    parms[6] = fcache_lowbytes();
    parms[7] = fcache_lowvnodes();

    h->outsize = sizeof(parms);
    return nnpfs_send_message_wakeup_data(fd, h->header.sequence_num, 0,
					  parms, sizeof(parms));
}

/*
 * debugging interface to give out statistics of the cache
 */

static int
viocaviator (int fd, struct nnpfs_message_pioctl *h, u_int size)
{
    uint32_t parms[16];
    
    memset(parms, 0, sizeof(parms));
    parms[0] = kernel_highworkers();
    parms[1] = kernel_usedworkers();

    h->outsize = sizeof(parms);
    return nnpfs_send_message_wakeup_data(fd, h->header.sequence_num, 0,
					  parms, sizeof(parms));
}

/*
 * Get/set arla debug level
 */

static int
vioc_arladebug (int fd, struct nnpfs_message_pioctl *h, u_int size)
{
    if (h->insize != 0) {
	if (h->insize < sizeof(int32_t))
	    return nnpfs_send_message_wakeup (fd, h->header.sequence_num,
					      EINVAL);
	if (!all_powerful_p (&h->cred))
	    return nnpfs_send_message_wakeup (fd, h->header.sequence_num,
					      EPERM);
	arla_log_set_level_num (*((int32_t *)h->msg));
    }
    if (h->outsize != 0) {
	int32_t debug_level;

	if (h->outsize < sizeof(int32_t))
	    return nnpfs_send_message_wakeup (fd, h->header.sequence_num,
					      EINVAL);

	debug_level = arla_log_get_level_num ();
	return nnpfs_send_message_wakeup_data (fd, h->header.sequence_num,
					       0, &debug_level,
					       sizeof(debug_level));
    }
    return nnpfs_send_message_wakeup (fd, h->header.sequence_num, 0);
}

/*
 * GC pags --- there shouldn't be any need to do anything here.
 */

static int
vioc_gcpags (int fd, struct nnpfs_message_pioctl *h, u_int size)
{
    return 0;
}

/*
 * Break the callback of the specified fid
 */

static int
vioc_calculate_cache (int fd, struct nnpfs_message_pioctl *h, u_int size)
{
    uint32_t parms[16];
    
    memset(parms, 0, sizeof(parms));
    
    if (!all_powerful_p(&h->cred))
	return EPERM;

    h->outsize = sizeof(parms);

    parms[0] = fcache_calculate_usage();
    parms[1] = fcache_usedbytes();

    arla_warnx (ADEBMISC, 
		"diskusage = %d, usedbytes = %d", 
		parms[0], parms[1]);
    
    return nnpfs_send_message_wakeup_data (fd, h->header.sequence_num, 0,
					   &parms, sizeof(parms));
}

/*
 *
 */

static int
vioc_breakcallback(int fd, struct nnpfs_message_pioctl *h, u_int size)
{
    int error;
    VenusFid fid;
    FCacheEntry *e;
    CredCacheEntry *ce;

    if (!all_powerful_p(&h->cred))
	return EPERM;

    if (!h->handle.a && !h->handle.b && !h->handle.c && !h->handle.d)
	return EINVAL;

    fid.Cell = h->handle.a;
    fid.fid.Volume = h->handle.b;
    fid.fid.Vnode = h->handle.c;
    fid.fid.Unique = h->handle.d;

    ce = cred_get (fid.Cell, h->cred.pag, CRED_ANY);
    assert (ce != NULL);

    error = fcache_get(&e, fid, ce);
    if (error)
	return error;

    if (!e->flags.kernelp) {
	cred_free (ce);
	return -ENOENT;
    }
	
    break_callback (e);
    
    fcache_release (e);
    cred_free (ce);

    return 0;
}

/*
 * check volume mappings
 */

static int
vioc_ckback(int fd, struct nnpfs_message_pioctl *h, u_int size)
{
    volcache_invalidate_all ();
    fcache_invalidate_mp ();
    return 0;
}

static int
statistics_hostpart(int fd, struct nnpfs_message_pioctl *h, u_int size)
{
    uint32_t host[100];
    uint32_t part[100];
    uint32_t outparms[512];
    int n;
    int outsize;
    int maxslots;
    int i;

    if (h->outsize < sizeof(uint32_t))
	return nnpfs_send_message_wakeup (fd, h->header.sequence_num,
					  EINVAL);
    
    n = 100;
    collectstats_hostpart(host, part, &n);
    maxslots = (h->outsize / sizeof(uint32_t) - 1) / 2;
    if (n > maxslots)
	n = maxslots;
    
    outsize = (n * 2 + 1) * sizeof(uint32_t);
    
    outparms[0] = n;
    for (i = 0; i < n; i++) {
	outparms[i*2 + 1] = host[i];
	outparms[i*2 + 2] = part[i];
    }
    
    return nnpfs_send_message_wakeup_data (fd, h->header.sequence_num, 0,
					   (char *) &outparms, outsize);
}

static int
statistics_entry(int fd, struct nnpfs_message_pioctl *h, u_int size)
{
    uint32_t *request = (uint32_t *) h->msg;
    uint32_t host;
    uint32_t part;
    uint32_t type;
    uint32_t items_slot;
    uint32_t count[32];
    int64_t items_total[32];
    int64_t total_time[32];
    uint32_t outparms[160];
    int i;
    int j;

    if (h->insize < sizeof(uint32_t) * 5) {
	return nnpfs_send_message_wakeup (fd, h->header.sequence_num,
					  EINVAL);
    }

    if (h->outsize < sizeof(uint32_t) * 160) {
	return nnpfs_send_message_wakeup (fd, h->header.sequence_num,
					  EINVAL);
    }

    host = request[1];
    part = request[2];
    type = request[3];
    items_slot = request[4];

    collectstats_getentry(host, part, type, items_slot,
			  count, items_total, total_time);

    j = 0;
    for (i = 0; i < 32; i++) {
	outparms[j++] = count[i];
    }
    for (i = 0; i < 32; i++) {
	memcpy(&outparms[j], &items_total[i], 8);
	j+=2;
    }
    for (i = 0; i < 32; i++) {
	memcpy(&outparms[j], &total_time[i], 8);
	j+=2;
    }
    return nnpfs_send_message_wakeup_data (fd, h->header.sequence_num, 0,
					   (char *) &outparms, sizeof(outparms));
}

static int
aioc_statistics(int fd, struct nnpfs_message_pioctl *h, u_int size)
{
    uint32_t opcode;

    if (!all_powerful_p (&h->cred))
	return nnpfs_send_message_wakeup (fd, h->header.sequence_num,
					  EPERM);

    if (h->insize < sizeof(opcode))
	return nnpfs_send_message_wakeup (fd, h->header.sequence_num,
					  EPERM);

    memcpy(&opcode, &h->msg, sizeof(opcode));

    switch (opcode) {
    case STATISTICS_OPCODE_LIST:
	return statistics_hostpart(fd, h, size);
    case STATISTICS_OPCODE_GETENTRY:
	return statistics_entry(fd, h, size);
    default:
	return nnpfs_send_message_wakeup (fd, h->header.sequence_num,
					  EINVAL);
    }
}


static int
aioc_getcacheparam(int fd, struct nnpfs_message_pioctl *h, u_int size)
{
    int32_t opcode;
    int64_t val;
    int error = 0;

    if (h->insize < sizeof(opcode) || h->outsize < sizeof(int64_t))
	return nnpfs_send_message_wakeup (fd, h->header.sequence_num,
					  EINVAL);

    memcpy(&opcode, &h->msg, sizeof(opcode));

    switch(opcode) {
    case GETCACHEPARAMS_OPCODE_HIGHBYTES:
	val = fcache_highbytes();
	break;
    case GETCACHEPARAMS_OPCODE_USEDBYTES:
	val = fcache_usedbytes();
	break;
    case GETCACHEPARAMS_OPCODE_LOWBYTES:
	val = fcache_lowbytes();
	break;
    case GETCACHEPARAMS_OPCODE_HIGHVNODES:
	val = fcache_highvnodes();
	break;
    case GETCACHEPARAMS_OPCODE_USEDVNODES:
	val = fcache_usedvnodes();
	break;
    case GETCACHEPARAMS_OPCODE_LOWVNODES:
	val = fcache_lowvnodes();
	break;
    default:
	error = EINVAL;
	break;
    }

    return nnpfs_send_message_wakeup_data (fd, h->header.sequence_num, 0,
					   (char *) &val, sizeof(val));
}


/*
 * Handle a pioctl message in `h'
 */

static int
nnpfs_message_pioctl (int fd, struct nnpfs_message_pioctl *h, u_int size)
{
    int error;

    switch(h->opcode) {
#ifdef KERBEROS
#ifdef VIOCSETTOK_32
    case VIOCSETTOK_32:
    case VIOCSETTOK_64:
#else
    case VIOCSETTOK:
#endif
	error = viocsettok (fd, h, size);
	break;

#if defined(HAVE_KRB5) && defined(WITH_RXGK)
#ifdef AFSCOMMONIOC_GKK5SETTOK_32
    case AFSCOMMONIOC_GKK5SETTOK_32:
    case AFSCOMMONIOC_GKK5SETTOK_64:
#else
    case AFSCOMMONIOC_GKK5SETTOK:
#endif
	error = k5settok(fd, h, size);
	break;
#endif /* HAVE_KRB5 && WITH_RXGK */

#ifdef VIOCGETTOK_32
    case VIOCGETTOK_32:
    case VIOCGETTOK_64:
#else
    case VIOCGETTOK :
#endif
	return viocgettok (fd, h, size);
#ifdef VIOCUNPAG_32
    case VIOCUNPAG_32:
    case VIOCUNPAG_64:
#else
    case VIOCUNPAG:
#endif
#ifdef VIOCUNLOG_32
    case VIOCUNLOG_32:
    case VIOCUNLOG_64:
#else
    case VIOCUNLOG:
#endif
	error = viocunlog (fd, h, size);
	break;
#endif /* KERBEROS */
#ifdef VIOCCONNECTMODE_32
    case VIOCCONNECTMODE_32:
    case VIOCCONNECTMODE_64:
#else
    case VIOCCONNECTMODE:
#endif
	return viocconnect(fd, h, size);
#ifdef VIOCFLUSH_32
    case VIOCFLUSH_32:
    case VIOCFLUSH_64:
#else
    case VIOCFLUSH:
#endif
        error = viocflush(fd, h, size);
	break;
#ifdef VIOC_FLUSHVOLUME_32
    case VIOC_FLUSHVOLUME_32:
    case VIOC_FLUSHVOLUME_64:
#else
    case VIOC_FLUSHVOLUME:
#endif
	error = viocflushvolume(fd, h, size);
	break;
#ifdef VIOCGETFID_32
    case VIOCGETFID_32:
    case VIOCGETFID_64:
#else
    case VIOCGETFID:
#endif
	return viocgetfid (fd, h, size);
#ifdef VIOCGETAL_32
    case VIOCGETAL_32:
    case VIOCGETAL_64:
#else
    case VIOCGETAL:
#endif
	return viocgetacl(fd, h, size);
#ifdef VIOCSETAL_32
    case VIOCSETAL_32:
    case VIOCSETAL_64:
#else
    case VIOCSETAL:
#endif
	return viocsetacl(fd, h, size);
#ifdef VIOCGETVOLSTAT_32
    case VIOCGETVOLSTAT_32:
    case VIOCGETVOLSTAT_64:
#else
    case VIOCGETVOLSTAT:
#endif
	return viocgetvolstat(fd, h, size);
#ifdef VIOCSETVOLSTAT_32
    case VIOCSETVOLSTAT_32:
    case VIOCSETVOLSTAT_64:
#else
    case VIOCSETVOLSTAT:
#endif
	error = viocsetvolstat(fd, h, size);
	break;
#ifdef VIOC_AFS_STAT_MT_PT_32
    case VIOC_AFS_STAT_MT_PT_32:
    case VIOC_AFS_STAT_MT_PT_64:
#else
    case VIOC_AFS_STAT_MT_PT:
#endif
	return vioc_afs_stat_mt_pt(fd, h, size);
#ifdef VIOC_AFS_DELETE_MT_PT_32
    case VIOC_AFS_DELETE_MT_PT_32:
    case VIOC_AFS_DELETE_MT_PT_64:
#else
    case VIOC_AFS_DELETE_MT_PT:
#endif
	return vioc_afs_delete_mt_pt(fd, h, size);
#ifdef VIOCWHEREIS_32
    case VIOCWHEREIS_32:
    case VIOCWHEREIS_64:
#else
    case VIOCWHEREIS:
#endif
	return viocwhereis(fd, h, size);
#ifdef VIOCNOP_32
    case VIOCNOP_32:
    case VIOCNOP_64:
#else
    case VIOCNOP:
#endif
	error = EINVAL;
	break;
#ifdef VIOCGETCELL_32
    case VIOCGETCELL_32:
    case VIOCGETCELL_64:
#else
    case VIOCGETCELL:
#endif
	return vioc_get_cell(fd, h, size);
#ifdef VIOC_GETCELLSTATUS_32
    case VIOC_GETCELLSTATUS_32:
    case VIOC_GETCELLSTATUS_64:
#else
    case VIOC_GETCELLSTATUS:
#endif
	return vioc_get_cellstatus(fd, h, size);
#ifdef VIOC_SETCELLSTATUS_32
    case VIOC_SETCELLSTATUS_32:
    case VIOC_SETCELLSTATUS_64:
#else
    case VIOC_SETCELLSTATUS:
#endif
	return vioc_set_cellstatus(fd, h, size);
#ifdef VIOCNEWCELL_32
    case VIOCNEWCELL_32:
    case VIOCNEWCELL_64:
#else
    case VIOCNEWCELL:
#endif
	return vioc_new_cell(fd, h, size);
#ifdef VIOC_VENUSLOG_32
    case VIOC_VENUSLOG_32:
    case VIOC_VENUSLOG_64:
#else
    case VIOC_VENUSLOG:
#endif
	error = viocvenuslog (fd, h, size);
	break;
#ifdef VIOC_AFS_SYSNAME_32
    case VIOC_AFS_SYSNAME_32:
    case VIOC_AFS_SYSNAME_64:
#else
    case VIOC_AFS_SYSNAME:
#endif
	return vioc_afs_sysname (fd, h, size);
#ifdef VIOC_FILE_CELL_NAME_32
    case VIOC_FILE_CELL_NAME_32:
    case VIOC_FILE_CELL_NAME_64:
#else
    case VIOC_FILE_CELL_NAME:
#endif
	return viocfilecellname (fd, h, size);
#ifdef VIOC_GET_WS_CELL_32
    case VIOC_GET_WS_CELL_32:
    case VIOC_GET_WS_CELL_64:
#else
    case VIOC_GET_WS_CELL:
#endif
	return viocgetwscell (fd, h, size);
#ifdef VIOCSETCACHESIZE_32
    case VIOCSETCACHESIZE_32:
    case VIOCSETCACHESIZE_64:
#else
    case VIOCSETCACHESIZE:
#endif
	error = viocsetcachesize (fd, h, size);
	break;
#ifdef VIOCCKSERV_32
    case VIOCCKSERV_32:
    case VIOCCKSERV_64:
#else
    case VIOCCKSERV:
#endif
	return viocckserv (fd, h, size);
#ifdef VIOCGETCACHEPARAMS_32
    case VIOCGETCACHEPARAMS_32:
    case VIOCGETCACHEPARAMS_64:
#else
    case VIOCGETCACHEPARAMS:
#endif
	return viocgetcacheparms (fd, h, size);
#ifdef VIOC_GETRXKCRYPT_32
    case VIOC_GETRXKCRYPT_32:
    case VIOC_GETRXKCRYPT_64:
#else
    case VIOC_GETRXKCRYPT:
#endif
	return getrxkcrypt(fd, h, size);
#ifdef VIOC_SETRXKCRYPT_32
    case VIOC_SETRXKCRYPT_32:
    case VIOC_SETRXKCRYPT_64:
#else
    case VIOC_SETRXKCRYPT:
#endif
	error = setrxkcrypt(fd, h, size);
	break;
#ifdef VIOC_FPRIOSTATUS_32
    case VIOC_FPRIOSTATUS_32:
    case VIOC_FPRIOSTATUS_64:
#else
    case VIOC_FPRIOSTATUS:
#endif
	error = vioc_fpriostatus(fd, h, size);
	break;
#ifdef VIOC_AVIATOR_32
    case VIOC_AVIATOR_32:
    case VIOC_AVIATOR_64:
#else
    case VIOC_AVIATOR:
#endif
	return viocaviator (fd, h, size);
#ifdef VIOC_ARLADEBUG_32
    case VIOC_ARLADEBUG_32:
    case VIOC_ARLADEBUG_64:
#else
    case VIOC_ARLADEBUG:
#endif
	return vioc_arladebug (fd, h, size);
#ifdef VIOC_GCPAGS_32
    case VIOC_GCPAGS_32:
    case VIOC_GCPAGS_64:
#else
    case VIOC_GCPAGS:
#endif
	error = vioc_gcpags (fd, h, size);
	break;
#ifdef VIOC_CALCULATE_CACHE_32
    case VIOC_CALCULATE_CACHE_32:
    case VIOC_CALCULATE_CACHE_64:
#else
    case VIOC_CALCULATE_CACHE:
#endif
	return vioc_calculate_cache (fd, h, size);
#ifdef VIOC_BREAKCALLBACK_32
    case VIOC_BREAKCALLBACK_32:
    case VIOC_BREAKCALLBACK_64:
#else
    case VIOC_BREAKCALLBACK:
#endif	
	error = vioc_breakcallback (fd, h, size);
	break;
#ifdef VIOCCKBACK_32
    case VIOCCKBACK_32 :
    case VIOCCKBACK_64 :
#else
    case VIOCCKBACK :
#endif
	error = vioc_ckback (fd, h, size);
	break;

#ifdef AIOC_STATISTICS_32
    case AIOC_STATISTICS_32:
    case AIOC_STATISTICS_64:
#else
    case AIOC_STATISTICS:
#endif
	return aioc_statistics (fd, h, size);

#ifdef AIOC_GETCACHEPARAMS_32
    case AIOC_GETCACHEPARAMS_32:
    case AIOC_GETCACHEPARAMS_64:
#else
    case AIOC_GETCACHEPARAMS:
#endif
	return aioc_getcacheparam(fd, h, size);

    default:
	arla_warnx (ADEBMSG, "unknown pioctl call %d", h->opcode);
	error = EINVAL ;
    }

    nnpfs_send_message_wakeup (fd, h->header.sequence_num, error);
    
    return 0;
}


/*
 * Return non-zero if there is a possibility that we have a network
 * connectivity. Can't tell the existence of network, just the lack of.
 *
 * Ignore lookback interfaces and known loopback addresses.
 */

static int
possibly_have_network(void)
{
    struct ifaddrs *ifa, *ifa0;
    int found_addr = 0;

    if (getifaddrs(&ifa0) != 0)
	return 1; /* well we don't really have a clue, do we ? */

    for (ifa = ifa0; ifa != NULL && !found_addr; ifa = ifa->ifa_next) {
	if (ifa->ifa_addr == NULL)
	    continue;

#if IFF_LOOPBACK
	if (ifa->ifa_flags & IFF_LOOPBACK)
	    continue;
#endif

	switch (ifa->ifa_addr->sa_family) {
	case AF_INET: {
	    struct sockaddr_in *sin = (struct sockaddr_in *)ifa->ifa_addr;
	    if (sin->sin_addr.s_addr == htonl(0x7f000001))
		continue;
	    if (sin->sin_addr.s_addr == htonl(0))
		continue;
	    found_addr = 1;
	    break;
	}
#ifdef RX_SUPPORT_INET6
	case AF_INET6:
	    /* 
	     * XXX avoid link local and local loopback addresses since
	     * those are not allowed in VLDB
	     */
	    found_addr = 1;
	    break;
#endif
	default:
	    break;
	}
    }
    freeifaddrs(ifa0);

    /* if we found an acceptable address, good for us */
    if (found_addr)
	return 1;
    return 0;
}
@


1.9
log
@Fix buffer overflow possibility, noticed by parfait:

Buffer overflow (CWE 120): In memcpy of msg.msg with length 'size'
      Array size is 2048 bytes, size <= 2080
        at line 317 of /usr/src/usr.sbin/afs/src/arlad/nnpfs.c in function 'nnpf
s_send_message_wakeup_data'.

tesing by todd@@ and jj@@ and me
@
text
@@


1.8
log
@malloc(x * y) -> calloc(x, y) from adobriyan AT gmail.com, with tweaks
suggested by kjell@@; ok otto@@ pat@@ millert@@ jaredy@@
@
text
@d2378 2
a2379 1
    char out[SYSNAMEMAXLEN];
d2381 2
d2399 2
a2400 1
    memset (out, 0, SYSNAMEMAXLEN);
d2416 3
d2420 2
a2421 4
    if (volumename[0]) {
	strncpy (out+outsize, volumename, AFSNAMEMAX);
	outsize += strlen (volumename);
    }
d2423 1
a2423 1
	out[outsize] = 0;
d2425 1
d2427 2
a2428 5

    if (offlinemsg[0]) {
	strncpy (out+outsize, offlinemsg, AFSOPAQUEMAX);
	outsize += strlen (offlinemsg);
    }
d2430 1
a2430 1
	out[outsize] = 0;
d2432 1
d2434 2
a2435 5

    if (motd[0]) {
	strncpy (out+outsize, motd, AFSOPAQUEMAX);
	outsize += strlen (motd);
    }
d2437 1
a2437 1
	out[outsize] = 0;
d2439 1
d2441 8
d3446 1
a3446 1
	
@


1.7
log
@fix bogus assert() usage in afsd, and avoid an assert when
ThisCell is specified as a nonexeistent cell. found by matthieu@@,
ok deraadt@@
@
text
@d2898 1
a2898 1
    dbs = malloc (count * sizeof(*dbs));
a2900 2
	
    memset(dbs, 0, count * sizeof(*dbs));
@


1.6
log
@Merge
@
text
@d317 4
a320 1
	assert (*ce != NULL);
d409 5
a413 1
    assert (ce != NULL);
d476 5
a480 2
    assert (ce != NULL);

d554 5
a558 1
    assert (ce != NULL);
d617 5
a621 1
    assert (ce != NULL);
d748 5
a752 1
    assert (ce != NULL);
d899 5
a903 1
    assert (ce != NULL);
d1064 5
a1068 1
    assert (ce != NULL);
d1167 5
a1171 1
    assert (ce != NULL);
d1190 5
a1194 1
    assert (ce != NULL);
d1289 5
a1293 1
    assert (ce != NULL);
a1373 1
    assert(dir_entry->flags.attrusedp);
d1458 5
a1462 1
    assert (ce != NULL);
d1893 5
a1897 1
    assert (ce != NULL);
@


1.5
log
@more string cleaning; ok beck
@
text
@d2 1
a2 1
 * Copyright (c) 1995-2001 Kungliga Tekniska Högskolan
d35 1
a35 1
RCSID("$KTH: messages.c,v 1.231.2.12 2001/10/19 04:25:52 ahltorp Exp $");
d37 1
a37 1
#include <xfs/xfs_message.h>
d46 2
a47 3
/* XXX */
int Log_is_open;
DARLA_file log_data;
d50 1
a50 1
xfs_message_getroot (int, struct xfs_message_getroot*, u_int);
d53 1
a53 1
xfs_message_getnode (int, struct xfs_message_getnode*, u_int);
d56 1
a56 1
xfs_message_getattr (int, struct xfs_message_getattr*, u_int);
d59 1
a59 1
xfs_message_getdata (int, struct xfs_message_getdata*, u_int);
d62 1
a62 1
xfs_message_inactivenode (int,struct xfs_message_inactivenode*,u_int);
d65 1
a65 1
xfs_message_putdata (int fd, struct xfs_message_putdata *h, u_int size);
d68 1
a68 1
xfs_message_putattr (int fd, struct xfs_message_putattr *h, u_int size);
d71 1
a71 1
xfs_message_create (int fd, struct xfs_message_create *h, u_int size);
d74 1
a74 1
xfs_message_mkdir (int fd, struct xfs_message_mkdir *h, u_int size);
d77 1
a77 1
xfs_message_link (int fd, struct xfs_message_link *h, u_int size);
d80 1
a80 1
xfs_message_symlink (int fd, struct xfs_message_symlink *h, u_int size);
d83 1
a83 1
xfs_message_remove (int fd, struct xfs_message_remove *h, u_int size);
d86 1
a86 1
xfs_message_rmdir (int fd, struct xfs_message_rmdir *h, u_int size);
d89 1
a89 1
xfs_message_rename (int fd, struct xfs_message_rename *h, u_int size);
d92 1
a92 1
xfs_message_pioctl (int fd, struct xfs_message_pioctl *h, u_int size) ;
d94 2
d97 2
a98 30
xfs_message_function rcvfuncs[] = {
NULL,						/* version */
(xfs_message_function)xfs_message_wakeup,	/* wakeup */
(xfs_message_function)xfs_message_getroot,	/* getroot */
NULL,						/* installroot */
(xfs_message_function)xfs_message_getnode, 	/* getnode */
NULL,						/* installnode */
(xfs_message_function)xfs_message_getattr,	/* getattr */
NULL,						/* installattr */
(xfs_message_function)xfs_message_getdata,	/* getdata */
NULL,						/* installdata */
(xfs_message_function)xfs_message_inactivenode,	/* inactivenode */
NULL,						/* invalidnode */
(xfs_message_function)xfs_message_getdata,	/* open */
(xfs_message_function)xfs_message_putdata,      /* put_data */
(xfs_message_function)xfs_message_putattr,      /* put attr */
(xfs_message_function)xfs_message_create,       /* create */
(xfs_message_function)xfs_message_mkdir,	/* mkdir */
(xfs_message_function)xfs_message_link,		/* link */
(xfs_message_function)xfs_message_symlink,      /* symlink */
(xfs_message_function)xfs_message_remove,	/* remove */
(xfs_message_function)xfs_message_rmdir,	/* rmdir */
(xfs_message_function)xfs_message_rename,	/* rename */
(xfs_message_function)xfs_message_pioctl,	/* pioctl */
NULL,	                                        /* wakeup_data */
NULL,						/* updatefid */
NULL,						/* advlock */
NULL						/* gc nodes */
};

d101 1
a101 1
 * Return 0 if ``fid1'' eq ``fid2''.
d104 29
a132 10
int
VenusFid_cmp (const VenusFid *fid1, const VenusFid *fid2)
{
    if (fid1->Cell == fid2->Cell &&
	fid1->fid.Volume == fid2->fid.Volume &&
	fid1->fid.Vnode == fid2->fid.Vnode &&
	fid1->fid.Unique == fid2->fid.Unique)
	return 0;
    return 1;
}
d146 2
a147 1
 * AFSFetchStatus -> xfs_attr
d151 53
a203 33
afsstatus2xfs_attr (AFSFetchStatus *status,
		    const VenusFid *fid,
		    struct xfs_attr *attr)
{
     attr->valid = XA_V_NONE;
     switch (status->FileType) {
	  case TYPE_FILE :
	       XA_SET_MODE(attr, S_IFREG);
	       XA_SET_TYPE(attr, XFS_FILE_REG);
	       XA_SET_NLINK(attr, status->LinkCount);
	       break;
	  case TYPE_DIR :
	       XA_SET_MODE(attr, S_IFDIR);
	       XA_SET_TYPE(attr, XFS_FILE_DIR);
	       XA_SET_NLINK(attr, status->LinkCount);
	       break;
	  case TYPE_LINK :
	       XA_SET_MODE(attr, S_IFLNK);
	       XA_SET_TYPE(attr, XFS_FILE_LNK);
	       XA_SET_NLINK(attr, status->LinkCount);
	       break;
	  default :
	       arla_warnx (ADEBMSG, "afsstatus2xfs_attr: default");
	       abort ();
     }
     XA_SET_SIZE(attr, status->Length);
     XA_SET_UID(attr,status->Owner);
     XA_SET_GID(attr, status->Group);
     attr->xa_mode  |= status->UnixModeBits;
     XA_SET_ATIME(attr, status->ClientModTime);
     XA_SET_MTIME(attr, status->ClientModTime);
     XA_SET_CTIME(attr, status->ClientModTime);
     XA_SET_FILEID(attr, afsfid2inode(fid));
d214 1
a214 1
afsrights2xfsrights(u_long ar, u_int32_t FileType, u_int32_t UnixModeBits)
d220 1
a220 1
	    ret |= XFS_RIGHT_R | XFS_RIGHT_X;
d222 1
a222 1
	    ret |= XFS_RIGHT_W;
d225 1
a225 1
	    ret |= XFS_RIGHT_R;
d227 1
a227 1
	    ret |= XFS_RIGHT_R;
d229 1
a229 1
	    ret |= XFS_RIGHT_W;
d231 1
a231 1
	    ret |= XFS_RIGHT_X;
d238 6
a243 6
fcacheentry2xfsnode (const VenusFid *fid,
		     const VenusFid *statfid, 
		     AFSFetchStatus *status,
		     struct xfs_msg_node *node,
                     AccessEntry *ae,
		     int flags)
d248 11
a258 12
    if (flags & FCACHE2XFSNODE_ATTR)
	afsstatus2xfs_attr (status, statfid, &node->attr);
    if (flags & FCACHE2XFSNODE_RIGHT) {
	node->anonrights = afsrights2xfsrights(status->AnonymousAccess,
					       status->FileType,
					       status->UnixModeBits);
	for (i = 0; i < NACCESS; i++) {
	    node->id[i] = ae[i].cred;
	    node->rights[i] = afsrights2xfsrights(ae[i].access,
						  status->FileType,
						  status->UnixModeBits);
	}
d267 2
a268 2
xfs_attr2afsstorestatus(struct xfs_attr *xa,
			AFSStoreStatus *storestatus)
d303 1
a303 1
try_again (int *ret, CredCacheEntry **ce, xfs_cred *cred, const VenusFid *fid)
d308 2
d334 1
a334 1
	if (fid && !volcache_reliable (fid->fid.Volume, fid->Cell)) {
d376 4
a379 2
message_get_data (FCacheEntry **entry, VenusFid *fid, 
		  struct xfs_cred *cred, CredCacheEntry **ce)
d383 2
a384 2
	ret = fcache_get_data (entry, fid, ce);
    } while (try_again (&ret, ce, cred, fid));
d393 1
a393 1
xfs_message_getroot (int fd, struct xfs_message_getroot *h, u_int size)
d395 22
a416 140
     struct xfs_message_installroot msg;
     int ret = 0;
     VenusFid root_fid;
     VenusFid real_fid;
     AFSFetchStatus status;
     Result res;
     CredCacheEntry *ce;
     AccessEntry *ae;
     struct xfs_message_header *h0 = NULL;
     size_t h0_len = 0;
     int32_t cell_id = cell_name2num(cell_getthiscell());

     ce = cred_get (cell_id, h->cred.pag, CRED_ANY);
     assert (ce != NULL);
     do {
	 ret = getroot (&root_fid, ce);

	 if (ret == 0) {
	     res = cm_getattr(root_fid, &status, &real_fid, ce, &ae);
	     if (res.res)
		 ret = res.error;
	     else
		 ret = res.res;
	 }
     } while (try_again (&ret, &ce, &h->cred, &root_fid));

     if (ret == 0) {
	 fcacheentry2xfsnode (&root_fid, &real_fid,
			      &status, &msg.node, ae,
			      FCACHE2XFSNODE_ALL);

	 msg.node.tokens = res.tokens & ~XFS_DATA_MASK;
	 msg.header.opcode = XFS_MSG_INSTALLROOT;
	 h0 = (struct xfs_message_header *)&msg;
	 h0_len = sizeof(msg);
     }

     cred_free (ce);
     xfs_send_message_wakeup_multiple (fd,
				       h->header.sequence_num,
				       ret,
				       h0, h0_len,
				       NULL, 0);
     return 0;
}

static int
xfs_message_getnode (int fd, struct xfs_message_getnode *h, u_int size)
{
     struct xfs_message_installnode msg;
     VenusFid *dirfid = (VenusFid *)&h->parent_handle;
     VenusFid fid;
     VenusFid real_fid;
     Result res;
     AFSFetchStatus status;
     CredCacheEntry *ce;
     AccessEntry *ae;
     struct xfs_message_header *h0 = NULL;
     size_t h0_len = 0;
     int ret;
     const VenusFid *report_fid = NULL;


     arla_warnx (ADEBMSG, "getnode (%ld.%lu.%lu.%lu) \"%s\"",
		 (long)dirfid->Cell, (unsigned long)dirfid->fid.Volume,
		 (unsigned long)dirfid->fid.Vnode,
		 (unsigned long)dirfid->fid.Unique, h->name);

     ce = cred_get (dirfid->Cell, h->cred.pag, CRED_ANY);
     assert (ce != NULL);

     report_fid = dirfid;
     do {
  	 res = cm_lookup (dirfid, h->name, &fid, &ce, TRUE);
	 if (res.res == 0) {
	     res = cm_getattr (fid, &status, &real_fid, ce, &ae);
	     report_fid = &fid;
	 }

	 if (res.res)
	     ret = res.error;
	 else
	     ret = res.res;
     } while (try_again (&ret, &ce, &h->cred, report_fid));

     if (ret == 0) {
	 fcacheentry2xfsnode (&fid, &real_fid, &status, &msg.node, ae,
			      FCACHE2XFSNODE_ALL);

	 msg.node.tokens = res.tokens & ~XFS_DATA_MASK;
	 msg.parent_handle = h->parent_handle;
	 strlcpy (msg.name, h->name, sizeof(msg.name));

	 msg.header.opcode = XFS_MSG_INSTALLNODE;
	 h0 = (struct xfs_message_header *)&msg;
	 h0_len = sizeof(msg);
     }

     cred_free (ce);
     xfs_send_message_wakeup_multiple (fd,
				       h->header.sequence_num,
				       ret,
				       h0, h0_len,
				       NULL, 0);
     return 0;
}

static int
xfs_message_getattr (int fd, struct xfs_message_getattr *h, u_int size)
{
     struct xfs_message_installattr msg;
     VenusFid *fid;
     VenusFid real_fid;
     AFSFetchStatus status;
     Result res;
     CredCacheEntry *ce;
     AccessEntry *ae;
     struct xfs_message_header *h0 = NULL;
     size_t h0_len = 0;
     int ret;

     fid = (VenusFid *)&h->handle;
     arla_warnx (ADEBMSG, "getattr (%ld.%lu.%lu.%lu)",
		 (long)fid->Cell, (unsigned long)fid->fid.Volume,
		 (unsigned long)fid->fid.Vnode,
		 (unsigned long)fid->fid.Unique);
     ce = cred_get (fid->Cell, h->cred.pag, CRED_ANY);
     assert (ce != NULL);

     do {
	 res = cm_getattr (*fid, &status, &real_fid, ce, &ae);
	 if (res.res)
	     ret = res.error;
	 else
	     ret = res.res;
     } while (try_again (&ret, &ce, &h->cred, fid));

     if (ret == 0) {
	 fcacheentry2xfsnode (fid, &real_fid, &status, &msg.node, ae,
			      FCACHE2XFSNODE_ALL);
d418 3
a420 12
	 msg.node.tokens = res.tokens;
	 msg.header.opcode = XFS_MSG_INSTALLATTR;
	 h0 = (struct xfs_message_header *)&msg;
	 h0_len = sizeof(msg);
     }

     cred_free (ce);
     xfs_send_message_wakeup_multiple (fd,
				       h->header.sequence_num,
				       ret,
				       h0, h0_len,
				       NULL, 0);
d422 158
a579 1
     return 0;
d583 1
a583 1
xfs_message_putattr (int fd, struct xfs_message_putattr *h, u_int size)
d585 95
a679 79
     struct xfs_message_installattr msg;
     VenusFid *fid;
     AFSStoreStatus status;
     AFSFetchStatus fetch_status;
     Result res;
     CredCacheEntry *ce;
     AccessEntry *ae;
     VenusFid real_fid;
     struct xfs_message_header *h0 = NULL;
     size_t h0_len = 0;
     int ret;
     struct vcache log_cache;
     FCacheEntry *fce;
     int log_err;

     fid = (VenusFid *)&h->handle;
     arla_warnx (ADEBMSG, "putattr (%ld.%lu.%lu.%lu)",
		 (long)fid->Cell, (unsigned long)fid->fid.Volume,
		 (unsigned long)fid->fid.Vnode,
		 (unsigned long)fid->fid.Unique);
     xfs_attr2afsstorestatus(&h->attr, &status);
     ce = cred_get (fid->Cell, h->cred.pag, CRED_ANY);
     assert (ce != NULL);

     if (connected_mode != CONNECTED) {
	 ret = fcache_find (&fce, *fid);
	 ReleaseWriteLock (&fce->lock);

	 log_cache.fid = *fid;
	 log_cache.DataVersion  = fce->status.DataVersion;
	 log_cache.cred = h->cred;
     }

     do {
	 res.res = 0;
	 if (XA_VALID_SIZE(&h->attr))
	     res = cm_ftruncate (*fid, h->attr.xa_size, ce);

	 if (res.res == 0)
	     res = cm_setattr(*fid, &status, ce);

	 if (res.res)
	     ret = res.error;
	 else
	     ret = res.res;
     } while (try_again (&ret, &ce, &h->cred, fid));

     if (ret == 0) {
	 do {
	     res = cm_getattr (*fid, &fetch_status, &real_fid, ce, &ae);
	     if (res.res)
		 ret = res.error;
	     else
		 ret = res.res;
	 } while (try_again (&ret, &ce, &h->cred, fid));

	 if (ret == 0) {
	     fcacheentry2xfsnode (fid, &real_fid,
				  &fetch_status, &msg.node, ae,
				  FCACHE2XFSNODE_ALL);
	 
	     msg.node.tokens  = res.tokens;
	     msg.header.opcode = XFS_MSG_INSTALLATTR;
	     h0 = (struct xfs_message_header *)&msg;
	     h0_len = sizeof(msg);
	 }
     }

     if (connected_mode != CONNECTED && ret == 0) {
	 log_err = log_dis_setattr (&log_cache, &(h->attr));
     }

     cred_free (ce);
     xfs_send_message_wakeup_multiple (fd,
				       h->header.sequence_num, 
				       ret,
				       h0, h0_len,
				       NULL, 0);
     return 0;
d683 1
a683 1
xfs_message_create (int fd, struct xfs_message_create *h, u_int size)
d685 57
a741 85
     VenusFid *parent_fid, child_fid;
     AFSStoreStatus store_status;
     AFSFetchStatus fetch_status;
     Result res;
     CredCacheEntry *ce;
     int ret;
     struct xfs_message_installdata msg1;
     struct xfs_message_installnode msg2;
     struct xfs_message_installdata msg3;
     struct xfs_message_header *h0 = NULL;
     size_t h0_len = 0;
     struct xfs_message_header *h1 = NULL;
     size_t h1_len = 0;
     struct xfs_message_header *h2 = NULL;
     size_t h2_len = 0;
     FCacheEntry *dir_entry   = NULL;
     FCacheEntry *child_entry = NULL;
     fcache_cache_handle cache_handle;

     parent_fid = (VenusFid *)&h->parent_handle;
     arla_warnx (ADEBMSG, "create (%ld.%lu.%lu.%lu) \"%s\"",
		 (long)parent_fid->Cell,
		 (unsigned long)parent_fid->fid.Volume,
		 (unsigned long)parent_fid->fid.Vnode,
		 (unsigned long)parent_fid->fid.Unique, h->name);

     xfs_attr2afsstorestatus(&h->attr, &store_status);
     if (connected_mode != CONNECTED) {
	 if (!(store_status.Mask & SS_OWNER)) {
	     store_status.Owner = h->cred.uid;
	     store_status.Mask |= SS_OWNER;
	 }
	 if (!(store_status.Mask & SS_MODTIME)) {
	     struct timeval now;

	     gettimeofday (&now, NULL);

	     store_status.ClientModTime = now.tv_sec;
	     store_status.Mask |= SS_MODTIME;
	 }
     }
     ce = cred_get (parent_fid->Cell, h->cred.pag, CRED_ANY);
     assert (ce != NULL);

     do {
	 res = cm_create(parent_fid, h->name, &store_status,
			 &child_fid, &fetch_status, &ce);

	 if (res.res)
	     ret = res.error;
	 else
	     ret = res.res;
     } while (try_again (&ret, &ce, &h->cred, parent_fid));

     if (res.res == 0) {

	 ret = message_get_data (&dir_entry, parent_fid, &h->cred, &ce);
	 if (ret)
	     goto out;
	     
	 res = conv_dir (dir_entry, ce, 0,
			 &cache_handle,
			 msg1.cache_name,
			 sizeof(msg1.cache_name));
	 if (res.res == -1) {
	     ret = res.error;
	     goto out;
	 }
	 msg1.cache_handle = cache_handle.xfs_handle;
	 msg1.flag = 0;
	 if (cache_handle.valid)
	     msg1.flag |= XFS_ID_HANDLE_VALID;

	 msg1.node.tokens = res.tokens;

	 fcacheentry2xfsnode (parent_fid,
			      fcache_realfid(dir_entry),
			      &dir_entry->status,
			      &msg1.node, 
			      dir_entry->acccache,
			      FCACHE2XFSNODE_ALL);

	 ret = message_get_data (&child_entry, &child_fid, &h->cred, &ce);
	 if (ret)
	     goto out;
d743 42
a784 2
	 msg3.cache_handle = child_entry->handle.xfs_handle;
	 fcache_file_name (child_entry,
d786 36
a821 11
	 msg3.flag = 0;
	 if (cache_handle.valid)
	     msg3.flag |= XFS_ID_HANDLE_VALID;

	 child_entry->flags.kernelp = TRUE;
	 child_entry->flags.attrusedp = TRUE;
	 child_entry->flags.datausedp = TRUE;
#if 0
	 assert(dir_entry->flags.attrusedp);
#endif
	 dir_entry->flags.datausedp = TRUE;
d823 17
a839 51
	 msg1.header.opcode = XFS_MSG_INSTALLDATA;
	 h0 = (struct xfs_message_header *)&msg1;
	 h0_len = sizeof(msg1);

	 fcacheentry2xfsnode (&child_fid, &child_fid,
			      &fetch_status, &msg2.node, dir_entry->acccache,
			      FCACHE2XFSNODE_ALL);
			      
	 msg2.node.tokens   = XFS_ATTR_R 
	     | XFS_OPEN_NW | XFS_OPEN_NR
	     | XFS_DATA_R | XFS_DATA_W;
	 msg2.parent_handle = h->parent_handle;
	 strlcpy (msg2.name, h->name, sizeof(msg2.name));

	 msg2.header.opcode = XFS_MSG_INSTALLNODE;
	 h1 = (struct xfs_message_header *)&msg2;
	 h1_len = sizeof(msg2);

	 msg3.node          = msg2.node;
	 msg3.header.opcode = XFS_MSG_INSTALLDATA;

	 h2 = (struct xfs_message_header *)&msg3;
	 h2_len = sizeof(msg3);
     }

     if (connected_mode != CONNECTED && res.res == 0) {
	 struct vcache log_ent_parent, log_ent_child;

	 log_ent_parent.fid = *parent_fid;
	 log_ent_parent.DataVersion = dir_entry->status.DataVersion;
	 log_ent_parent.cred = h->cred;

	 log_ent_child.fid = child_fid;
	 log_ent_child.DataVersion = 1;

	 log_dis_create (&log_ent_parent, &log_ent_child, h->name);
     }

out:
     if (dir_entry)
	 fcache_release(dir_entry);
     if (child_entry)
	 fcache_release(child_entry);
     cred_free (ce);
     xfs_send_message_wakeup_multiple (fd,
				       h->header.sequence_num,
				       ret,
				       h0, h0_len,
				       h1, h1_len,
				       h2, h2_len,
				       NULL, 0);
d841 1
a841 1
     return ret;
d845 1
a845 1
xfs_message_mkdir (int fd, struct xfs_message_mkdir *h, u_int size)
d847 18
a864 23
     VenusFid *parent_fid, child_fid;
     AFSStoreStatus store_status;
     AFSFetchStatus fetch_status;
     Result res;
     CredCacheEntry *ce;
     int ret;
     struct xfs_message_installdata msg1;
     struct xfs_message_installnode msg2;
     struct xfs_message_installdata msg3;
     FCacheEntry *dir_entry = NULL;
     FCacheEntry *child_entry = NULL;

     struct xfs_message_header *h0 = NULL;
     size_t h0_len = 0;
     struct xfs_message_header *h1 = NULL;
     size_t h1_len = 0;
     struct xfs_message_header *h2 = NULL;
     size_t h2_len = 0;
     fcache_cache_handle cache_handle;

     struct vcache log_ent_parent, log_ent_child;
     FCacheEntry parent_entry;
     AFSStoreStatus log_store_status;
d867 1
a867 1
     parent_fid = fid_translate((VenusFid *)&h->parent_handle);
d869 1
a869 1
     parent_fid = (VenusFid *)&h->parent_handle;
d871 348
a1218 23
     arla_warnx (ADEBMSG, "mkdir (%ld.%lu.%lu.%lu) \"%s\"",
		 (long)parent_fid->Cell, (unsigned long)parent_fid->fid.Volume,
		 (unsigned long)parent_fid->fid.Vnode,
		 (unsigned long)parent_fid->fid.Unique, h->name);

     ce = cred_get (parent_fid->Cell, h->cred.pag, CRED_ANY);
     assert (ce != NULL);

     xfs_attr2afsstorestatus(&h->attr, &store_status);
     if (connected_mode != CONNECTED) {
	 if (!(store_status.Mask & SS_OWNER)) {
	     store_status.Owner = h->cred.uid;
	     store_status.Mask |= SS_OWNER;
	 }
	 if (!(store_status.Mask & SS_MODTIME)) {
	     struct timeval now;

	     gettimeofday (&now, NULL);

	     store_status.ClientModTime = now.tv_sec;
	     store_status.Mask |= SS_MODTIME;
	 }
     }
d1220 293
a1512 55
     do {
	 res = cm_mkdir(parent_fid, h->name, &store_status,
			&child_fid, &fetch_status, &ce);
	 if (res.res)
	     ret = res.error;
	 else
	     ret = res.res;
     } while(try_again (&ret, &ce, &h->cred, parent_fid));

     if (res.res == 0) {

	 ret = message_get_data (&dir_entry, parent_fid, &h->cred, &ce);
	 if (ret)
	     goto out;

	 res = conv_dir (dir_entry, ce, 0,
			 &cache_handle,
			 msg1.cache_name,
			 sizeof(msg1.cache_name));
	 if (res.res == -1) {
	     ret = res.error;
	     goto out;
	 }
	 msg1.cache_handle = cache_handle.xfs_handle;
	 msg1.flag = 0;
	 if (cache_handle.valid)
	     msg1.flag |= XFS_ID_HANDLE_VALID;
	 msg1.node.tokens = res.tokens;

	 fcacheentry2xfsnode (parent_fid,
			      fcache_realfid(dir_entry),
			      &dir_entry->status, &msg1.node, 
			      dir_entry->acccache,
			      FCACHE2XFSNODE_ALL);
	 
	 msg1.header.opcode = XFS_MSG_INSTALLDATA;
	 h0 = (struct xfs_message_header *)&msg1;
	 h0_len = sizeof(msg1);

	 ret = message_get_data (&child_entry, &child_fid, &h->cred, &ce);
	 if (ret)
	     goto out;

	 res = conv_dir (child_entry, ce, 0,
			 &cache_handle,
			 msg3.cache_name,
			 sizeof(msg3.cache_name));
	 if (res.res == -1) {
	     ret = res.error;
	     goto out;
	 }
	 msg3.cache_handle = cache_handle.xfs_handle;
	 msg3.flag = 0;
	 if (cache_handle.valid)
	     msg3.flag |= XFS_ID_HANDLE_VALID;
d1514 3
a1516 6
	 child_entry->flags.attrusedp = TRUE;
	 child_entry->flags.datausedp = TRUE;
#if 0
	 assert(dir_entry->flags.attrusedp);
#endif
	 dir_entry->flags.datausedp = TRUE;
d1518 33
a1550 1
	 msg2.node.tokens = res.tokens;
d1552 1
a1552 44
	 fcacheentry2xfsnode (&child_fid, &child_fid,
			      &child_entry->status, &msg2.node,
			      dir_entry->acccache,
			      FCACHE2XFSNODE_ALL);
			      
	 msg2.parent_handle = h->parent_handle;
	 strlcpy (msg2.name, h->name, sizeof(msg2.name));

	 msg2.header.opcode = XFS_MSG_INSTALLNODE;
	 h1 = (struct xfs_message_header *)&msg2;
	 h1_len = sizeof(msg2);

	 msg3.header.opcode = XFS_MSG_INSTALLDATA;
	 msg3.node = msg2.node;
	 h2 = (struct xfs_message_header *)&msg3;
	 h2_len = sizeof(msg3);
	 if (connected_mode != CONNECTED)
	     parent_entry = *dir_entry;
     }

     if (connected_mode != CONNECTED) {
	 log_ent_parent.fid = *parent_fid;
	 log_ent_parent.DataVersion = parent_entry.status.DataVersion;
	 log_ent_parent.cred = h->cred;
	 log_store_status = store_status;
	 log_ent_child.fid = child_fid;
	 log_ent_child.DataVersion = 1;
	 log_dis_mkdir (&log_ent_parent, &log_ent_child, &log_store_status,
			h->name);
     }

out:
     if (child_entry) 
	 fcache_release(child_entry);
     if (dir_entry)
	 fcache_release(dir_entry);
     cred_free (ce);
     xfs_send_message_wakeup_multiple (fd,
				       h->header.sequence_num,
				       ret,
				       h0, h0_len,
				       h1, h1_len,
				       h2, h2_len,
				       NULL, 0);
d1554 1
a1554 1
     return ret;
d1558 1
a1558 1
xfs_message_link (int fd, struct xfs_message_link *h, u_int size)
d1560 157
a1716 62
     VenusFid *parent_fid, *existing_fid;
     AFSFetchStatus fetch_status;
     Result res;
     CredCacheEntry *ce;
     int ret;
     struct xfs_message_installdata msg1;
     struct xfs_message_installnode msg2;
     struct xfs_message_header *h0 = NULL;
     size_t h0_len = 0;
     struct xfs_message_header *h1 = NULL;
     size_t h1_len = 0;
     fcache_cache_handle cache_handle;

     parent_fid   = (VenusFid *)&h->parent_handle;
     existing_fid = (VenusFid *)&h->from_handle;
     arla_warnx (ADEBMSG, "link (%ld.%lu.%lu.%lu) (%ld.%lu.%lu.%lu) \"%s\"",
		 (long)parent_fid->Cell, (unsigned long)parent_fid->fid.Volume,
		 (unsigned long)parent_fid->fid.Vnode,
		 (unsigned long)parent_fid->fid.Unique,
		 (long)existing_fid->Cell,
		 (unsigned long)existing_fid->fid.Volume,
		 (unsigned long)existing_fid->fid.Vnode,
		 (unsigned long)existing_fid->fid.Unique,
		 h->name);

     ce = cred_get (parent_fid->Cell, h->cred.pag, CRED_ANY);
     assert (ce != NULL);

     do {
	 res = cm_link (parent_fid, h->name, *existing_fid,
			&fetch_status, &ce);
	 if (res.res)
	     ret = res.error;
	 else
	     ret = res.res;
     } while (try_again (&ret, &ce, &h->cred, parent_fid));

     if (res.res == 0) {
	 FCacheEntry *dir_entry;

	 ret = message_get_data (&dir_entry, parent_fid, &h->cred, &ce);
	 if (ret)
	     goto out;

	 res = conv_dir (dir_entry, ce, 0,
			 &cache_handle,
			 msg1.cache_name,
			 sizeof(msg1.cache_name));
	 if (res.res == -1) {
	     fcache_release(dir_entry);
	     ret = res.error;
	     goto out;
	 }
	 msg1.cache_handle = cache_handle.xfs_handle;
	 msg1.flag = 0;
	 if (cache_handle.valid)
	     msg1.flag |= XFS_ID_HANDLE_VALID;
	 msg1.node.tokens = res.tokens;
#if 0
	 assert(dir_entry->flags.attrusedp);
#endif
	 dir_entry->flags.datausedp = TRUE;
d1718 32
a1749 33
	 fcacheentry2xfsnode (parent_fid,
			      fcache_realfid(dir_entry),
			      &dir_entry->status, &msg1.node,
			      dir_entry->acccache,
			      FCACHE2XFSNODE_ALL);

	 msg1.header.opcode = XFS_MSG_INSTALLDATA;
	 h0 = (struct xfs_message_header *)&msg1;
	 h0_len = sizeof(msg1);

	 fcacheentry2xfsnode (existing_fid, existing_fid,
			      &fetch_status, &msg2.node,
			      dir_entry->acccache,
			      FCACHE2XFSNODE_ALL);
	 fcache_release(dir_entry);

	 msg2.node.tokens   = XFS_ATTR_R; /* XXX */
	 msg2.parent_handle = h->parent_handle;
	 strlcpy (msg2.name, h->name, sizeof(msg2.name));

	 msg2.header.opcode = XFS_MSG_INSTALLNODE;
	 h1 = (struct xfs_message_header *)&msg2;
	 h1_len = sizeof(msg2);
     }

out:
     cred_free (ce);
     xfs_send_message_wakeup_multiple (fd,
				       h->header.sequence_num,
				       ret,
				       h0, h0_len,
				       h1, h1_len,
				       NULL, 0);
d1751 1
a1751 1
     return ret;
d1755 1
a1755 1
xfs_message_symlink (int fd, struct xfs_message_symlink *h, u_int size)
d1757 185
a1941 62
     VenusFid *parent_fid, child_fid, real_fid;
     AFSStoreStatus store_status;
     AFSFetchStatus fetch_status;
     Result res;
     CredCacheEntry *ce;
     int ret;
     struct xfs_message_installdata msg1;
     struct xfs_message_installnode msg2;
     struct xfs_message_header *h0 = NULL;
     size_t h0_len = 0;
     struct xfs_message_header *h1 = NULL;
     size_t h1_len = 0;
     fcache_cache_handle cache_handle;

     parent_fid = (VenusFid *)&h->parent_handle;
     arla_warnx (ADEBMSG, "symlink (%ld.%lu.%lu.%lu) \"%s\"",
		 (long)parent_fid->Cell, (unsigned long)parent_fid->fid.Volume,
		 (unsigned long)parent_fid->fid.Vnode,
		 (unsigned long)parent_fid->fid.Unique, h->name);

     ce = cred_get (parent_fid->Cell, h->cred.pag, CRED_ANY);
     assert (ce != NULL);

     xfs_attr2afsstorestatus(&h->attr, &store_status);

     do {
	 res = cm_symlink(parent_fid, h->name, &store_status,
			  &child_fid, &real_fid,
			  &fetch_status,
			  h->contents, &ce);
	 ret = res.error;
     } while (try_again (&ret, &ce, &h->cred, parent_fid));
     
     cred_free (ce);
     ce = cred_get (parent_fid->Cell, h->cred.pag, CRED_ANY);
     assert (ce != NULL);

     if (res.res == 0) {
	 FCacheEntry *dir_entry;

	 ret = message_get_data (&dir_entry, parent_fid, &h->cred, &ce);
	 if (ret)
	     goto out;

	 res = conv_dir (dir_entry, ce, 0,
			 &cache_handle,
			 msg1.cache_name,
			 sizeof(msg1.cache_name));
	 if (res.res == -1) {
	     fcache_release(dir_entry);
	     ret = res.error;
	     goto out;
	 }
	 msg1.cache_handle = cache_handle.xfs_handle;
	 msg1.flag = 0;
	 if (cache_handle.valid)
	     msg1.flag |= XFS_ID_HANDLE_VALID;
	 msg1.node.tokens = res.tokens;
#if 0
	 assert(dir_entry->flags.attrusedp);
#endif
	 dir_entry->flags.datausedp = TRUE;
d1943 8
a1950 34
	 fcacheentry2xfsnode (parent_fid,
			      fcache_realfid(dir_entry),
			      &dir_entry->status, &msg1.node,
			      dir_entry->acccache,
			      FCACHE2XFSNODE_ALL);
	 
	 msg1.header.opcode = XFS_MSG_INSTALLDATA;
	 h0 = (struct xfs_message_header *)&msg1;
	 h0_len = sizeof(msg1);

	 fcacheentry2xfsnode (&child_fid, &real_fid,
			      &fetch_status, &msg2.node,
			      dir_entry->acccache,
			      FCACHE2XFSNODE_ALL);
	 fcache_release(dir_entry);
			      
	 msg2.node.tokens   = XFS_ATTR_R; /* XXX */
	 msg2.parent_handle = h->parent_handle;
	 strlcpy (msg2.name, h->name, sizeof(msg2.name));

	 msg2.header.opcode = XFS_MSG_INSTALLNODE;
	 h1 = (struct xfs_message_header *)&msg2;
	 h1_len = sizeof(msg2);
     }

out:
     cred_free (ce);
     xfs_send_message_wakeup_multiple (fd,
				       h->header.sequence_num,
				       ret,
				       h0, h0_len,
				       h1, h1_len,
				       NULL, 0);
     return ret;
d1953 16
a1968 4
/* 
 * Handle the XFS remove message in `h', that is, remove name
 * `h->name' in directory `h->parent' with the creds from `h->cred'.
 */
d1970 2
a1971 108
static int 
xfs_message_remove (int fd, struct xfs_message_remove *h, u_int size)
{
     VenusFid *parent_fid;
     VenusFid fid;
     Result res;
     CredCacheEntry *ce;
     int ret;
     struct xfs_message_installdata msg1;
     struct xfs_message_installattr msg2;
     struct xfs_message_header *h0 = NULL;
     size_t h0_len = 0;
     struct xfs_message_header *h1 = NULL;
     size_t h1_len = 0;
     FCacheEntry *limbo_entry = NULL;
     unsigned link_count;
     FCacheEntry *dir_entry = NULL;
     AFSFetchStatus limbo_status;
     fcache_cache_handle cache_handle;

     parent_fid = (VenusFid *)&h->parent_handle;
     arla_warnx (ADEBMSG, "remove (%ld.%lu.%lu.%lu) \"%s\"",
		 (long)parent_fid->Cell, (unsigned long)parent_fid->fid.Volume,
		 (unsigned long)parent_fid->fid.Vnode,
		 (unsigned long)parent_fid->fid.Unique, h->name);

     ce = cred_get (parent_fid->Cell, h->cred.pag, CRED_ANY);
     assert (ce != NULL);

     do {
	 res = cm_lookup (parent_fid, h->name, &fid, &ce, FALSE);
	 if (res.res)
	     ret = res.error;
	 else
	     ret = res.res;
     } while (try_again (&ret, &ce, &h->cred, parent_fid));

     if (ret)
	 goto out;

     /*
      * Fetch the linkcount of the to be removed node
      */

     ret = fcache_get (&limbo_entry, fid, ce);
     if (ret)
	 goto out;

     ret = fcache_verify_attr (limbo_entry, NULL, NULL, ce);
     if (ret)
	 goto out;
     limbo_status = limbo_entry->status;
     link_count   = limbo_status.LinkCount;

     fcache_release (limbo_entry);
     limbo_entry = NULL;

     /*
      * Do the actual work
      */

     do {
	 res = cm_remove(parent_fid, h->name, &ce);
	 if (res.res)
	     ret = res.error;
	 else
	     ret = res.res;
     } while (try_again (&ret, &ce, &h->cred, parent_fid));

     if (ret == 0) {

	 ret = message_get_data (&dir_entry, parent_fid, &h->cred, &ce);
	 if (ret)
	     goto out;

	 if (!dir_entry->flags.extradirp
	     || dir_remove_name (dir_entry, h->name,
				 &cache_handle,
				 msg1.cache_name,
				 sizeof(msg1.cache_name))) {
	     res = conv_dir (dir_entry, ce, 0,
			     &cache_handle,
			     msg1.cache_name,
			     sizeof(msg1.cache_name));
	     if (res.res == -1) {
		 ret = res.error;
		 goto out;
	     }
	 }
	 msg1.cache_handle = cache_handle.xfs_handle;
	 msg1.flag = XFS_ID_INVALID_DNLC;
	 if (cache_handle.valid)
	     msg1.flag |= XFS_ID_HANDLE_VALID;
	 msg1.node.tokens = res.tokens | XFS_DATA_R;

	 fcacheentry2xfsnode (parent_fid,
			      fcache_realfid(dir_entry),
			      &dir_entry->status, &msg1.node,
			      dir_entry->acccache,
			      FCACHE2XFSNODE_ALL);
	 
	 msg1.header.opcode = XFS_MSG_INSTALLDATA;
	 h0 = (struct xfs_message_header *)&msg1;
	 h0_len = sizeof(msg1);

	 /*
	  * Set datausedp since we push data to kernel in out:
	  */
d1973 3
a1975 4
#if 0
	 assert(dir_entry->flags.attrusedp);
#endif
	 dir_entry->flags.datausedp = TRUE;
d1977 1
a1977 27
	 /*
	  * Make sure that if the removed node is in the
	  * kernel it has the right linkcount since some
	  * might hold a reference to it.
	  */

	 ret = fcache_get (&limbo_entry, fid, ce);
	 if (ret)
	     goto out;

	 /*
	  * Now insert the limbo entry to get right linkcount
	  */

	 ret = fcache_verify_attr (limbo_entry, dir_entry, NULL, ce);
	 if (ret == 0)
	     limbo_status = limbo_entry->status;
	 ret = 0;
	 
	 /* Only a silly rename when this is the last file */
	 if (link_count == 1)
	     limbo_entry->flags.silly = TRUE;

	 msg2.header.opcode = XFS_MSG_INSTALLATTR;
	 msg2.node.tokens   = limbo_entry->tokens;
	 if (!limbo_entry->flags.datausedp)
	     msg2.node.tokens &= ~XFS_DATA_MASK;
d1979 1
a1979 13
	 if (link_count == 1 && limbo_status.LinkCount == 1)
	     --limbo_status.LinkCount;
	 fcacheentry2xfsnode (&fid,
			      fcache_realfid(limbo_entry),
			      &limbo_status,
			      &msg2.node,
			      limbo_entry->acccache,
			      FCACHE2XFSNODE_ALL);
	 
	 h1 = (struct xfs_message_header *)&msg2;
	 h1_len = sizeof(msg2);
	 
     }
d1981 1
a1981 14
out:
     if (dir_entry)
	 fcache_release(dir_entry);
     if (limbo_entry)
	 fcache_release (limbo_entry);
     cred_free (ce);
     xfs_send_message_wakeup_multiple (fd,
				       h->header.sequence_num,
				       ret,
				       h0, h0_len,
				       h1, h1_len,
				       NULL, 0);
     return ret;
}
d1983 4
a1986 144
static int 
xfs_message_rmdir (int fd, struct xfs_message_rmdir *h, u_int size)
{
     VenusFid *parent_fid, fid;
     Result res;
     CredCacheEntry *ce;
     int ret;
     struct xfs_message_installdata msg0;
     struct xfs_message_header *h0 = NULL;
     size_t h0_len = 0;
     struct xfs_message_installattr msg1;
     struct xfs_message_header *h1 = NULL;
     size_t h1_len = 0;
     FCacheEntry *limbo_entry = NULL;
     FCacheEntry *dir_entry = NULL;
     unsigned link_count = 0;
     fcache_cache_handle cache_handle;

     parent_fid = (VenusFid *)&h->parent_handle;
     arla_warnx (ADEBMSG, "rmdir (%ld.%lu.%lu.%lu) \"%s\"",
		 (long)parent_fid->Cell, (unsigned long)parent_fid->fid.Volume,
		 (unsigned long)parent_fid->fid.Vnode,
		 (unsigned long)parent_fid->fid.Unique, h->name);

     ce = cred_get (parent_fid->Cell, h->cred.pag, CRED_ANY);
     assert (ce != NULL);

     /*
      * Fetch the child-entry fid.
      */

     do {
	 res = cm_lookup (parent_fid, h->name, &fid, &ce, FALSE);
	 if (res.res)
	     ret = res.error;
	 else
	     ret = res.res;
     } while (try_again (&ret, &ce, &h->cred, parent_fid));

     if (ret)
	 goto out;

     /*
      * Need to get linkcount for silly rename.
      */

     ret = fcache_get (&limbo_entry, fid, ce);
     if (ret)
	 goto out;

     ret = fcache_verify_attr (limbo_entry, NULL, NULL, ce);
     if (ret)
	 goto out;
     link_count = limbo_entry->status.LinkCount;

     fcache_release (limbo_entry);
     limbo_entry = NULL;

     /*
      * Do the actual work
      */

     do {
	 res = cm_rmdir(parent_fid, h->name, &ce);
	 if (res.res)
	     ret = res.error;
	 else
	     ret = res.res;
     } while (try_again (&ret, &ce, &h->cred, parent_fid));

     if (res.res == 0) {

	 ret = message_get_data (&dir_entry, parent_fid, &h->cred, &ce);
	 if (ret)
	     goto out;

	 if (!dir_entry->flags.extradirp
	     || dir_remove_name (dir_entry, h->name,
				 &cache_handle,
				 msg0.cache_name,
				 sizeof(msg0.cache_name))) {
	     res = conv_dir (dir_entry, ce, 0,
			     &cache_handle,
			     msg0.cache_name,
			     sizeof(msg0.cache_name));
	     if (res.res == -1) {
		 ret = res.error;
		 goto out;
	     }
	 }
	 msg0.cache_handle = cache_handle.xfs_handle;
	 msg0.flag = XFS_ID_INVALID_DNLC;
	 if (cache_handle.valid)
	     msg0.flag |= XFS_ID_HANDLE_VALID;

	 msg0.node.tokens = res.tokens;

	 fcacheentry2xfsnode (parent_fid,
			      fcache_realfid(dir_entry),
			      &dir_entry->status, &msg0.node,
			      dir_entry->acccache,
			      FCACHE2XFSNODE_ALL);
	 
	 msg0.header.opcode = XFS_MSG_INSTALLDATA;
	 h0 = (struct xfs_message_header *)&msg0;
	 h0_len = sizeof(msg0);

	 ret = fcache_get (&limbo_entry, fid, ce);
	 if (ret)
	     goto out;

	 /* Only silly rename when this is the last reference. */

	 if (link_count == 2)
	     limbo_entry->flags.silly = TRUE;

	 if (limbo_entry->flags.kernelp) {

	     ret = fcache_verify_attr (limbo_entry, NULL, NULL, ce);
	     if (ret)
		 goto out;

	     msg1.header.opcode = XFS_MSG_INSTALLATTR;
	     msg1.node.tokens   = limbo_entry->tokens;
	     if (!limbo_entry->flags.datausedp)
		 msg1.node.tokens &= ~XFS_DATA_MASK;

	     if (link_count == 2 && limbo_entry->status.LinkCount == 2)
		 limbo_entry->status.LinkCount = 0;
	     fcacheentry2xfsnode (&fid,
				  fcache_realfid(limbo_entry),
				  &limbo_entry->status,
				  &msg1.node,
				  limbo_entry->acccache,
				  FCACHE2XFSNODE_ALL);
	     
	     h1 = (struct xfs_message_header *)&msg1;
	     h1_len = sizeof(msg1);
	 }
#if 0
	 assert(dir_entry->flags.attrusedp);
#endif
	 dir_entry->flags.datausedp = TRUE;
     }
d1988 7
a1994 15
out:
     if (dir_entry)
	 fcache_release(dir_entry);
     if (limbo_entry)
	 fcache_release (limbo_entry);

     cred_free (ce);
     xfs_send_message_wakeup_multiple (fd,
				       h->header.sequence_num,
				       ret,
				       h0, h0_len,
				       h1, h1_len,
				       NULL, 0);
     return ret;
}
d1996 2
a1997 119
static int 
xfs_message_rename (int fd, struct xfs_message_rename *h, u_int size)
{
     VenusFid *old_parent_fid;
     VenusFid *new_parent_fid;
     VenusFid child_fid;
     Result res;
     CredCacheEntry *ce;
     int ret;
     struct xfs_message_installdata msg1;
     struct xfs_message_installdata msg2;
     struct xfs_message_installdata msg3;
     struct xfs_message_header *h0 = NULL;
     size_t h0_len = 0;
     struct xfs_message_header *h1 = NULL;
     size_t h1_len = 0;
     struct xfs_message_header *h2 = NULL;
     size_t h2_len = 0;
     FCacheEntry *old_entry   = NULL;
     FCacheEntry *new_entry   = NULL;
     FCacheEntry *child_entry = NULL;
     int update_child = 0;
     fcache_cache_handle cache_handle;

     old_parent_fid = (VenusFid *)&h->old_parent_handle;
     new_parent_fid = (VenusFid *)&h->new_parent_handle;
     arla_warnx (ADEBMSG,
		 "rename (%ld.%lu.%lu.%lu) (%ld.%lu.%lu.%lu) \"%s\" \"%s\"",
		 (long)old_parent_fid->Cell,
		 (unsigned long)old_parent_fid->fid.Volume,
		 (unsigned long)old_parent_fid->fid.Vnode,
		 (unsigned long)old_parent_fid->fid.Unique,
		 (long)new_parent_fid->Cell,
		 (unsigned long)new_parent_fid->fid.Volume,
		 (unsigned long)new_parent_fid->fid.Vnode,
		 (unsigned long)new_parent_fid->fid.Unique,
		 h->old_name,
		 h->new_name);

     ce = cred_get (old_parent_fid->Cell, h->cred.pag, CRED_ANY);
     assert (ce != NULL);

     do {
	 res = cm_rename(old_parent_fid, h->old_name,
			 new_parent_fid, h->new_name,
			 &child_fid, &update_child, &ce);
	 if (res.res)
	     ret = res.error;
	 else
	     ret = res.res;
     } while (try_again (&ret, &ce, &h->cred, old_parent_fid));

     if (res.res == 0) {

	 ret = message_get_data (&old_entry, old_parent_fid, &h->cred, &ce);
	 if (ret)
	     goto out;

	 if (!old_entry->flags.extradirp
	     || dir_remove_name (old_entry, h->old_name,
				 &cache_handle,
				 msg1.cache_name,
				 sizeof(msg1.cache_name))) {
	     res = conv_dir (old_entry, ce, 0,
			     &cache_handle,
			     msg1.cache_name,
			     sizeof(msg1.cache_name));
	     if (res.res == -1) {
		 ret = res.error;
		 goto out;
	     }
	 }
	 msg1.cache_handle = cache_handle.xfs_handle;
	 msg1.flag = XFS_ID_INVALID_DNLC;
	 if (cache_handle.valid)
	     msg1.flag |= XFS_ID_HANDLE_VALID;

	 msg1.node.tokens = res.tokens;

	 fcacheentry2xfsnode (old_parent_fid,
			      fcache_realfid(old_entry),
			      &old_entry->status, &msg1.node,
			      old_entry->acccache,
			      FCACHE2XFSNODE_ALL);
	 
	 msg1.header.opcode = XFS_MSG_INSTALLDATA;
	 h0 = (struct xfs_message_header *)&msg1;
	 h0_len = sizeof(msg1);


	 /*
	  * If the new parent is the same as the old parent, reuse
	  */

	 if (VenusFid_cmp(new_parent_fid, old_parent_fid) == 0) {
	     new_entry = old_entry;
	     old_entry = NULL;
	 } else {
	     ret = fcache_get (&new_entry, *new_parent_fid, ce);
	     if (ret)
		 goto out;
	 }
	 
	 ret = fcache_verify_data (new_entry, ce); /* XXX - fake_mp? */
	 if (ret)
	     goto out;
	 
	 res = conv_dir (new_entry, ce, 0,
			 &cache_handle,
			 msg2.cache_name,
			 sizeof(msg2.cache_name));
	 if (res.res == -1) {
	     ret = res.error;
	     goto out;
	 }
	 msg2.cache_handle = cache_handle.xfs_handle;
	 msg2.flag = XFS_ID_INVALID_DNLC;
	 if (cache_handle.valid)
	     msg2.flag |= XFS_ID_HANDLE_VALID;
d1999 8
a2006 11
	 msg2.node.tokens = res.tokens;
	 
	 fcacheentry2xfsnode (new_parent_fid,
			      fcache_realfid(new_entry),
			      &new_entry->status, &msg2.node,
			      new_entry->acccache,
			      FCACHE2XFSNODE_ALL);
	 
	 msg2.header.opcode = XFS_MSG_INSTALLDATA;
	 h1 = (struct xfs_message_header *)&msg2;
	 h1_len = sizeof(msg2);
d2008 29
a2036 10
	 if (old_entry) {
#if 0
	     assert(old_entry->flags.attrusedp);
#endif
	     old_entry->flags.datausedp = TRUE;
	 }
#if 0
	 assert(new_entry->flags.attrusedp);
#endif
	 new_entry->flags.datausedp = TRUE;
d2038 7
a2044 44
	 if (update_child) {
	     ret = message_get_data (&child_entry, &child_fid, &h->cred, &ce);
	     if (ret)
		 goto out;

	     res = conv_dir (child_entry, ce, 0,
			     &cache_handle,
			     msg3.cache_name,
			     sizeof(msg3.cache_name));
	     if (res.res == -1) {
		 ret = res.error;
		 goto out;
	     }
	     msg3.cache_handle = cache_handle.xfs_handle;
	     msg3.flag = XFS_ID_INVALID_DNLC;
	     if (cache_handle.valid)
		 msg3.flag |= XFS_ID_HANDLE_VALID;

	     msg3.node.tokens = res.tokens;

	     fcacheentry2xfsnode (&child_fid,
				  fcache_realfid(child_entry),
				  &child_entry->status, &msg3.node,
				  child_entry->acccache,
				  FCACHE2XFSNODE_ALL);

	     msg3.header.opcode = XFS_MSG_INSTALLDATA;
	     h2 = (struct xfs_message_header *)&msg3;
	     h2_len = sizeof(msg3);
	 }
     }

out:
     if (old_entry) fcache_release(old_entry);
     if (new_entry) fcache_release(new_entry);
     if (child_entry) fcache_release(child_entry);
     
     cred_free (ce);
     xfs_send_message_wakeup_multiple (fd,
				       h->header.sequence_num,
				       ret,
				       h0, h0_len,
				       h1, h1_len,
				       NULL, 0);
d2046 5
a2050 2
     return ret;
}
d2052 8
a2059 151
static int 
xfs_message_putdata (int fd, struct xfs_message_putdata *h, u_int size)
{
     VenusFid *fid;
     Result res;
     CredCacheEntry *ce;
     int ret;
     AFSStoreStatus status;
     struct vcache log_cache;
     FCacheEntry *fce;
     int log_err;

     fid = (VenusFid *)&h->handle;
     arla_warnx (ADEBMSG, "putdata (%ld.%lu.%lu.%lu)",
		 (long)fid->Cell, (unsigned long)fid->fid.Volume,
		 (unsigned long)fid->fid.Vnode,
		 (unsigned long)fid->fid.Unique);

     xfs_attr2afsstorestatus(&h->attr, &status);

     ce = cred_get (fid->Cell, h->cred.pag, CRED_ANY);
     assert (ce != NULL);

     if (connected_mode != CONNECTED) {
	 ret = fcache_find (&fce, *fid);

	 ReleaseWriteLock (&fce->lock);

	 log_cache.fid  = *fid;
	 log_cache.cred = h->cred;
     }

     do {
	 res = cm_close(*fid, h->flag, &status, ce);
	 if (res.res)
	     ret = res.error;
	 else
	     ret = res.res;
     } while (try_again (&ret, &ce, &h->cred, fid));
	 
     if (ret == 0) {
	 if (connected_mode != CONNECTED) {
	     log_cache.DataVersion = ++fce->status.DataVersion;
	     log_err = log_dis_store (&log_cache);
	 }
     } else {
	 arla_warn (ADEBMSG, ret, "xfs_message_putdata: cm_close");
     }

     cred_free (ce);
     xfs_send_message_wakeup (fd, h->header.sequence_num, ret);
     return 0;
}

static int
xfs_message_getdata (int fd, struct xfs_message_getdata *h, u_int size)
{
     struct xfs_message_installdata msg;
     VenusFid *fid;
     VenusFid real_fid;
     Result res;
     AFSFetchStatus status;
     CredCacheEntry *ce;
     int ret;
     AccessEntry *ae;
     struct xfs_message_header *h0 = NULL;
     size_t h0_len = 0;
     fcache_cache_handle cache_handle;

     fid = (VenusFid *)&h->handle;
     arla_warnx (ADEBMSG, "getdata (%ld.%lu.%lu.%lu)",
		 (long)fid->Cell, (unsigned long)fid->fid.Volume,
		 (unsigned long)fid->fid.Vnode,
		 (unsigned long)fid->fid.Unique);

     ce = cred_get (fid->Cell, h->cred.pag, CRED_ANY);
     assert (ce != NULL);

     do {
	 res = cm_getattr (*fid, &status, &real_fid, ce, &ae);
	 if (res.res)
	     ret = res.error;
	 else
	     ret = res.res;
     } while (try_again (&ret, &ce, &h->cred, fid));

     if (ret == 0) {
	  if (status.FileType == TYPE_DIR) {
	       FCacheEntry *entry;

	       ret = message_get_data (&entry, fid, &h->cred, &ce);
	       if (ret)
		   goto out;

	       fcacheentry2xfsnode (fid, fcache_realfid(entry),
				    &entry->status, &msg.node, ae,
				    FCACHE2XFSNODE_ALL);

	       res = conv_dir (entry, ce, h->tokens,
			       &cache_handle,
			       msg.cache_name,
			       sizeof(msg.cache_name));
	       if (res.res)
		   ret = res.error;

	       if (ret == 0) {
		   msg.node.tokens = res.tokens;
		   msg.cache_handle = cache_handle.xfs_handle;
		   msg.flag = XFS_ID_INVALID_DNLC;
		   if (cache_handle.valid)
		       msg.flag |= XFS_ID_HANDLE_VALID;

		   entry->flags.attrusedp = TRUE;
		   entry->flags.datausedp = TRUE;
	       }
	       fcache_release(entry);
	  } else {
	      do {
		  res = cm_open (fid, &ce, h->tokens, &cache_handle,
				 msg.cache_name, sizeof(msg.cache_name));
		  if (res.res)
		      ret = res.error;
		  else
		      ret = res.res;
	      } while (try_again (&ret, &ce, &h->cred, fid));
	      if (ret == 0) {
		  msg.cache_handle = cache_handle.xfs_handle;
		  msg.flag = 0;
		  if (cache_handle.valid)
		      msg.flag |= XFS_ID_HANDLE_VALID;
		  msg.node.tokens = res.tokens;
		  fcacheentry2xfsnode (fid, &real_fid,
				       &status, &msg.node, ae,
				       FCACHE2XFSNODE_ALL);
	      }
	  }
     }

     if (ret == 0) {
	 msg.header.opcode = XFS_MSG_INSTALLDATA;
	 h0 = (struct xfs_message_header *)&msg;
	 h0_len = sizeof(msg);
     }

out:
     cred_free (ce);
     xfs_send_message_wakeup_multiple (fd,
				       h->header.sequence_num,
				       ret,
				       h0, h0_len,
				       NULL, 0);
d2061 1
a2061 1
     return ret;
d2072 32
a2103 24
     struct xfs_message_invalidnode msg;
     enum { CALLBACK_BREAK_WARN = 100 };
     static int failed_callbacks_break = 0;
     int ret;

     assert (entry->flags.kernelp);

     msg.header.opcode = XFS_MSG_INVALIDNODE;
     memcpy (&msg.handle, &entry->fid, sizeof(entry->fid));
     ret = xfs_message_send (kernel_fd, (struct xfs_message_header *)&msg, 
			     sizeof(msg));
     if (ret) {
	 arla_warnx (ADEBMSG, "break_callback: (%ld.%lu.%lu.%lu) failed",
		     (long)entry->fid.Cell, 
		     (unsigned long)entry->fid.fid.Volume,
		     (unsigned long)entry->fid.fid.Vnode,
		     (unsigned long)entry->fid.fid.Unique);
	 ++failed_callbacks_break;
	 if (failed_callbacks_break > CALLBACK_BREAK_WARN) {
	     arla_warnx (ADEBWARN, "break_callback: have failed %d times",
			 failed_callbacks_break);
	     failed_callbacks_break = 0;
	 }
     }
d2113 1
a2113 1
     struct xfs_message_installattr msg;
d2115 8
a2122 7
     memset (&msg, 0, sizeof(msg));
     msg.header.opcode = XFS_MSG_INSTALLATTR;
     fcacheentry2xfsnode (&e->fid, fcache_realfid(e), &e->status, &msg.node,
			  e->acccache, flags);
     msg.node.tokens   = e->tokens;
     if (!e->flags.datausedp)
	 msg.node.tokens &= ~XFS_DATA_MASK;
d2124 2
a2125 2
     xfs_message_send (kernel_fd, (struct xfs_message_header *)&msg, 
		       sizeof(msg));
d2132 1
a2132 1
    struct xfs_message_updatefid msg;
d2134 1
a2134 1
    msg.header.opcode = XFS_MSG_UPDATEFID;
d2137 2
a2138 2
    xfs_message_send (kernel_fd, (struct xfs_message_header *)&msg,
		      sizeof(msg));
d2140 1
d2152 2
a2153 2
xfs_message_inactivenode (int fd, struct xfs_message_inactivenode *h, 
			  u_int size)
d2155 33
a2187 30
     FCacheEntry *entry;
     VenusFid *fid;
     int ret;
     CredCacheEntry *ce;

     fid = (VenusFid *)&h->handle;
     arla_warnx (ADEBMSG, "inactivenode (%ld.%lu.%lu.%lu)",
		 (long)fid->Cell, (unsigned long)fid->fid.Volume,
		 (unsigned long)fid->fid.Vnode,
		 (unsigned long)fid->fid.Unique);

     ce = cred_get (fid->Cell, 0, CRED_NONE);
     assert (ce != NULL);

     ret = fcache_get (&entry, *fid, ce);
     cred_free (ce);

     if (ret) {
	 arla_warnx (ADEBMSG, "xfs_message_inactivenode: node not found");
	 return 0;
     }
     if (h->flag & XFS_NOREFS)
	 fcache_unused (entry);
     if (h->flag & XFS_DELETE) {
	 entry->flags.kernelp   = FALSE;
	 entry->flags.datausedp = FALSE;
	 entry->flags.attrusedp = FALSE;
     }
     fcache_release(entry);
     return 0;
d2195 1
a2195 1
all_powerful_p (const xfs_cred *cred)
d2205 1
a2205 1
viocflushvolume (int fd, struct xfs_message_pioctl *h, u_int size)
d2231 1
a2231 1
viocgetacl(int fd, struct xfs_message_pioctl *h, u_int size)
d2239 1
a2239 1
	return xfs_send_message_wakeup (fd, h->header.sequence_num, EINVAL);
d2258 2
a2259 2
    xfs_send_message_wakeup_data (fd, h->header.sequence_num, error,
				  opaque.val, opaque.len);
d2270 1
a2270 1
viocsetacl(int fd, struct xfs_message_pioctl *h, u_int size)
d2279 1
a2279 1
	return xfs_send_message_wakeup (fd, h->header.sequence_num, EINVAL);
d2282 1
a2282 1
	return xfs_send_message_wakeup (fd, h->header.sequence_num, EINVAL);
d2286 1
a2286 1
	return xfs_send_message_wakeup (fd, h->header.sequence_num, ENOMEM);
d2304 1
a2304 1
	install_attr (e, FCACHE2XFSNODE_ALL);
d2312 1
a2312 1
    xfs_send_message_wakeup_data (fd, h->header.sequence_num, error, NULL, 0);
d2321 1
a2321 1
viocgetvolstat(int fd, struct xfs_message_pioctl *h, u_int size)
d2334 1
a2334 1
	return xfs_send_message_wakeup (fd, h->header.sequence_num, EINVAL);
d2351 1
a2351 1
			    volumename,
d2391 2
a2392 2
    xfs_send_message_wakeup_data (fd, h->header.sequence_num, error,
				  out, outsize);
d2401 1
a2401 1
viocsetvolstat(int fd, struct xfs_message_pioctl *h, u_int size)
d2467 2
a2468 2
    xfs_send_message_wakeup_data (fd, h->header.sequence_num, error,
				  NULL, 0);
d2492 1
a2492 1
    error = fcache_get_data(&dentry, &fid, ce);
d2496 6
d2511 1
a2511 1
    error = fcache_verify_attr (mp_entry, NULL, NULL, *ce);
d2534 1
a2534 1
read_mount_point (FCacheEntry *mp_entry, CredCacheEntry *ce,
d2540 1
a2540 1
    error = fcache_verify_data (mp_entry, ce);
d2544 1
a2544 1
    *fd = fcache_open_file (mp_entry, O_RDONLY);
d2548 1
a2548 1
    error = fbuf_create (the_fbuf, *fd, mp_entry->status.Length,
d2570 1
a2570 1
vioc_afs_stat_mt_pt(int fd, struct xfs_message_pioctl *h, u_int size)
d2593 1
a2593 1
	return xfs_send_message_wakeup (fd, h->header.sequence_num, error);
d2596 1
a2596 1
    error = read_mount_point (e, ce, &mp_fd, &the_fbuf);
d2600 1
a2600 1
	return xfs_send_message_wakeup (fd, h->header.sequence_num, error);
d2612 2
a2613 2
    xfs_send_message_wakeup_data (fd, h->header.sequence_num, error,
				  buf, the_fbuf.len);
d2628 1
a2628 1
vioc_afs_delete_mt_pt(int fd, struct xfs_message_pioctl *h, u_int size)
d2633 1
a2633 1
    struct xfs_message_remove remove_msg;
d2649 1
a2649 1
	return xfs_send_message_wakeup (fd, h->header.sequence_num, error);
d2658 1
a2658 1
    return xfs_message_remove (fd, &remove_msg, sizeof(remove_msg));
d2662 1
a2662 1
viocwhereis(int fd, struct xfs_message_pioctl *h, u_int size)
d2673 1
a2673 1
	return xfs_send_message_wakeup (fd, h->header.sequence_num, EINVAL);
d2686 1
a2686 1
	return xfs_send_message_wakeup (fd, h->header.sequence_num, error);
d2692 1
a2692 1
	return xfs_send_message_wakeup (fd, h->header.sequence_num, error);
d2700 1
a2700 1
	return xfs_send_message_wakeup (fd, h->header.sequence_num, EINVAL);
d2710 2
a2711 2
    xfs_send_message_wakeup_data (fd, h->header.sequence_num, error,
				  addresses, sizeof(long) * j);
d2724 1
a2724 1
vioc_get_cell(int fd, struct xfs_message_pioctl *h, u_int size)
d2738 1
a2738 1
	return xfs_send_message_wakeup (fd, h->header.sequence_num, EDOM);
d2743 1
a2743 1
	return xfs_send_message_wakeup (fd, h->header.sequence_num, EDOM);
d2751 1
a2751 1
	u_int32_t addr = dbservers[i].addr.s_addr;
d2755 2
a2756 2
    xfs_send_message_wakeup_data (fd, h->header.sequence_num, 0,
				  out, outsize);
d2766 1
a2766 1
vioc_get_cellstatus(int fd, struct xfs_message_pioctl *h, u_int size)
d2770 1
a2770 1
    u_int32_t out = 0;
d2777 1
a2777 1
	return xfs_send_message_wakeup (fd, h->header.sequence_num, ENOENT);
d2784 2
a2785 2
    xfs_send_message_wakeup_data (fd, h->header.sequence_num, 0,
				  &out, sizeof(out));
d2795 1
a2795 1
vioc_set_cellstatus(int fd, struct xfs_message_pioctl *h, u_int size)
d2799 1
a2799 1
    u_int32_t in = 0;
d2803 1
a2803 1
	return xfs_send_message_wakeup (fd, h->header.sequence_num, EACCES);
d2806 1
a2806 1
	return xfs_send_message_wakeup (fd, h->header.sequence_num, EINVAL);
d2813 1
a2813 1
	return xfs_send_message_wakeup (fd, h->header.sequence_num, ENOENT);
d2818 1
a2818 1
	    return xfs_send_message_wakeup (fd, h->header.sequence_num,EINVAL);
d2821 1
a2821 1
    xfs_send_message_wakeup (fd, h->header.sequence_num, 0);
d2831 1
a2831 1
vioc_new_cell(int fd, struct xfs_message_pioctl *h, u_int size)
d2836 1
a2836 1
    u_int32_t *hp;
d2840 1
a2840 1
	return xfs_send_message_wakeup (fd, h->header.sequence_num, EPERM);
d2843 1
a2843 1
	return xfs_send_message_wakeup (fd, h->header.sequence_num, EINVAL);
d2845 1
a2845 1
    hp = (u_int32_t *)h->msg;
d2851 1
a2851 1
	return xfs_send_message_wakeup (fd, h->header.sequence_num, ENOMEM);
d2855 1
a2855 1
    hp = (u_int32_t *)h->msg;
d2862 1
a2862 1
    cellname = h->msg + 8 * sizeof(u_int32_t);
d2869 2
a2870 2
	    return xfs_send_message_wakeup (fd, h->header.sequence_num,
					    ENOMEM);
d2879 1
a2879 1
    return xfs_send_message_wakeup (fd, h->header.sequence_num, 0);
d2889 1
a2889 1
token_for_cell (int fd, struct xfs_message_pioctl *h, u_int size,
d2892 2
a2893 3
    struct ClearToken ct;
    char buf[2048];
    size_t len;
d2895 2
a2896 3
    u_int32_t tmp;
    krbstruct *kstruct = (krbstruct *)ce->cred_data;
    CREDENTIALS *cred  = &kstruct->c;
d2899 1
a2899 5
    ct.AuthHandle = cred->kvno;
    memcpy (ct.HandShakeKey, cred->session, sizeof(cred->session));
    ct.ViceId         = ce->uid;
    ct.BeginTimestamp = cred->issue_date + 1;
    ct.EndTimestamp   = ce->expire;
d2901 5
a2905 1
    tmp = cred->ticket_st.length;
d2908 1
a2908 1
    memcpy (p, cred->ticket_st.dat, tmp);
d2910 1
a2910 1
    tmp = sizeof(ct);
d2913 3
a2915 3
    memcpy (p, &ct, sizeof(ct));
    p += sizeof(ct);
    tmp = strlen(cell);
d2923 16
a2938 1
    memset (&ct, 0, sizeof(ct));
d2940 4
a2943 1
    cred_free (ce);
d2945 1
a2945 2
    xfs_send_message_wakeup_data (fd, h->header.sequence_num, 0,
				  buf, len);
d2949 1
d2955 1
a2955 1
viocgettok (int fd, struct xfs_message_pioctl *h, u_int size)
d2957 3
d2961 6
a2966 2
	int32_t cell_id = cell_name2num(cell_getthiscell());
	CredCacheEntry *ce = cred_get (cell_id, h->cred.pag, CRED_KRB4);
d2968 2
a2969 2
	if (ce == NULL) {
	    xfs_send_message_wakeup (fd, h->header.sequence_num, ENOTCONN);
a2971 6
	return token_for_cell (fd, h, size, ce);
    } else if (h->insize == sizeof(u_int32_t)) {
	u_int32_t n;
	int i, c;
	int found;
	CredCacheEntry *ce = NULL;
d2973 2
a2974 1
	memcpy (&n, h->msg, sizeof(n));
d2976 1
a2976 6
	i = 0;
	c = 0;
	found = 0;
	while (!found && i <= n) {
	    if (cell_num2name(c) == NULL)
		break;
d2978 2
a2979 12
	    ce = cred_get (c++, h->cred.pag, CRED_KRB4);
	    if (ce != NULL) {
		if (i == n) {
		    found = 1;
		} else {
		    cred_free (ce);
		    ++i;
		}
	    }
	}
	if (!found) {
	    xfs_send_message_wakeup (fd, h->header.sequence_num, EDOM);
d2982 2
a2983 1
	return token_for_cell (fd, h, size, ce);
d2985 2
a2986 1
	xfs_send_message_wakeup (fd, h->header.sequence_num, EINVAL);
d2988 8
a2995 1
    return 0;
d3003 1
a3003 1
viocsettok (int fd, struct xfs_message_pioctl *h, u_int size)
d3005 1
a3005 2
    struct ClearToken ct;
    CREDENTIALS c;
d3007 1
d3012 3
a3014 1
    if (h->insize == 0) {
a3015 1
    }
d3019 1
a3019 1
    c.ticket_st.length = sizeof_x ;
d3023 7
a3029 1
    memcpy(c.ticket_st.dat, t, sizeof_x) ;
d3031 1
a3031 1

d3035 6
a3040 2

    memcpy(&ct, t, sizeof_x) ;
d3046 1
a3046 1

d3048 2
a3049 2
    strncpy(c.realm, t, REALM_SZ) ;
    c.realm[REALM_SZ-1] = '\0' ;
d3051 1
a3051 6
    /* Make this a sane world again */
    c.kvno = ct.AuthHandle;
    memcpy (c.session, ct.HandShakeKey, sizeof(c.session));
    c.issue_date = ct.BeginTimestamp - 1;
	
    cell = cell_name2num(strlwr(c.realm));
d3058 2
a3059 2
    cred_add (h->cred.pag, CRED_KRB4, 2, cell, ct.EndTimestamp,
	      &c, sizeof(c), ct.ViceId);
d3064 1
a3064 1
viocunlog (int fd, struct xfs_message_pioctl *h, u_int size)
d3066 1
a3066 1
    xfs_pag_t cred = h->cred.pag;
d3073 127
d3207 1
a3207 1
viocflush (int fd, struct xfs_message_pioctl *h, u_int size)
d3229 1
a3229 1
viocconnect(int fd, struct xfs_message_pioctl *h, u_int size)
d3247 10
d3270 10
a3279 3
	    if (Log_is_open) {
		DARLA_Close(&log_data);
		Log_is_open = 0;
a3280 8
#if 0
		do_replay("discon_log", log_data.log_entries, 0);
#endif
	    }
	    if (connected_mode == DISCONNECTED) {
		connected_mode = CONNECTED ;
		fcache_reobtain_callbacks ();
	    }
d3284 1
d3288 3
a3290 7
	    ret = DARLA_Open(&log_data, ARLACACHEDIR"/discon_log",
			     O_WRONLY | O_CREAT | O_BINARY);
	    if (ret < 0) {
		arla_warn (ADEBERROR, errno, "DARLA_Open");
	    } else {
		Log_is_open = 1;
	    }
d3299 2
a3300 2
    xfs_send_message_wakeup_data (fd, h->header.sequence_num, error,
				  &ret, sizeof(ret));
d3305 1
a3305 1
getrxkcrypt(int fd, struct xfs_message_pioctl *h, u_int size)
d3307 2
a3308 2
    if (h->outsize == sizeof(u_int32_t)) {
	u_int32_t n;
d3317 5
a3321 5
	return xfs_send_message_wakeup_data (fd,
					     h->header.sequence_num,
					     0,
					     &n,
					     sizeof(n));
d3323 1
a3323 1
	return xfs_send_message_wakeup (fd, h->header.sequence_num, EINVAL);
d3327 1
a3327 1
setrxkcrypt(int fd, struct xfs_message_pioctl *h, u_int size)
d3332 5
a3336 2
    if (h->insize == sizeof(u_int32_t)) {
	u_int32_t n;
d3347 1
a3347 1
	    conn_clearcred (CONN_CS_NONE, 0, -1, -1);
d3357 1
a3357 1
 * XXX - this function sometimes does a wakeup_data and then an ordinary wakeup is sent in xfs_message_pioctl
d3361 1
a3361 1
vioc_fpriostatus (int fd, struct xfs_message_pioctl *h, u_int size)
d3377 2
d3391 5
a3395 5
	xfs_send_message_wakeup_data (fd,
				      h->header.sequence_num,
				      0,
				      &prio,
				      sizeof(prio));
d3404 1
a3404 1
	    fprio->prio > FPRIO_MAX)
d3417 5
a3421 5
	xfs_send_message_wakeup_data (fd,
				      h->header.sequence_num,
				      0,
				      &fprioritylevel,
				      sizeof(fprioritylevel));
d3442 1
a3442 1
viocgetfid (int fd, struct xfs_message_pioctl *h, u_int size)
d3444 2
a3445 2
    return xfs_send_message_wakeup_data(fd, h->header.sequence_num, 0,
					&h->handle, sizeof(VenusFid));
d3449 1
a3449 1
viocvenuslog (int fd, struct xfs_message_pioctl *h, u_int size)
d3458 1
d3473 1
a3473 1
vioc_afs_sysname (int fd, struct xfs_message_pioctl *h, u_int size)
d3479 3
d3483 3
a3485 3
	    return xfs_send_message_wakeup (fd,
					    h->header.sequence_num,
					    EPERM);
d3488 9
a3496 3
	memcpy(arlasysname, t, h->insize);
	arlasysname[h->insize] = '\0';
	return xfs_send_message_wakeup(fd, h->header.sequence_num, 0);
d3499 2
a3500 1
	size_t sysname_len = strlen (arlasysname);
d3505 8
a3512 3
	    return xfs_send_message_wakeup (fd, h->header.sequence_num, ENOMEM);
	*((u_int32_t *)buf) = sysname_len;
	memcpy (buf + 4, arlasysname, sysname_len);
d3515 2
a3516 2
	ret = xfs_send_message_wakeup_data (fd, h->header.sequence_num, 0,
					    buf, sysname_len + 5);
d3523 1
a3523 1
viocfilecellname (int fd, struct xfs_message_pioctl *h, u_int size)
d3530 2
a3531 2
	return xfs_send_message_wakeup_data(fd, h->header.sequence_num, 0,
					    cellname, strlen(cellname)+1);
d3533 2
a3534 2
	return xfs_send_message_wakeup_data(fd, h->header.sequence_num, EINVAL,
					    NULL, 0);
d3538 1
a3538 1
viocgetwscell (int fd, struct xfs_message_pioctl *h, u_int size)
d3543 2
a3544 2
    return xfs_send_message_wakeup_data(fd, h->header.sequence_num, 0,
					cellname, strlen(cellname)+1);
d3548 1
a3548 1
viocsetcachesize (int fd, struct xfs_message_pioctl *h, u_int size)
d3550 1
a3550 1
    u_int32_t *s = (u_int32_t *)h->msg;
d3566 1
a3566 1
 *  out: hosts  - u_int32_t number of hosts, followed by list of hosts being down.
d3570 1
a3570 1
viocckserv (int fd, struct xfs_message_pioctl *h, u_int size)
d3575 1
a3575 1
    u_int32_t hosts[CKSERV_MAXSERVERS + 1];
d3579 1
a3579 1
	return xfs_send_message_wakeup (fd, h->header.sequence_num, EINVAL);
d3583 1
a3583 1
    flags = *(u_int32_t *)h->msg;
d3591 1
a3591 1
	    return xfs_send_message_wakeup (fd, h->header.sequence_num, ENOENT);
d3600 2
a3601 2
    return xfs_send_message_wakeup_data (fd, h->header.sequence_num, 0,
					 hosts, msg_size);
d3610 1
a3610 1
viocgetcacheparms (int fd, struct xfs_message_pioctl *h, u_int size)
d3612 1
a3612 1
    u_int32_t parms[16];
d3625 2
a3626 2
    return xfs_send_message_wakeup_data(fd, h->header.sequence_num, 0,
					parms, sizeof(parms));
d3634 1
a3634 1
viocaviator (int fd, struct xfs_message_pioctl *h, u_int size)
d3636 1
a3636 1
    u_int32_t parms[16];
d3643 2
a3644 2
    return xfs_send_message_wakeup_data(fd, h->header.sequence_num, 0,
					parms, sizeof(parms));
d3652 1
a3652 1
vioc_arladebug (int fd, struct xfs_message_pioctl *h, u_int size)
d3656 2
a3657 2
	    return xfs_send_message_wakeup (fd, h->header.sequence_num,
					    EINVAL);
d3659 2
a3660 2
	    return xfs_send_message_wakeup (fd, h->header.sequence_num,
					    EPERM);
d3667 2
a3668 2
	    return xfs_send_message_wakeup (fd, h->header.sequence_num,
					    EINVAL);
d3671 3
a3673 3
	return xfs_send_message_wakeup_data (fd, h->header.sequence_num,
					     0, &debug_level,
					     sizeof(debug_level));
d3675 1
a3675 1
    return xfs_send_message_wakeup (fd, h->header.sequence_num, 0);
d3683 1
a3683 1
vioc_gcpags (int fd, struct xfs_message_pioctl *h, u_int size)
d3689 1
a3689 1
 *
d3693 1
a3693 1
vioc_calculate_cache (int fd, struct xfs_message_pioctl *h, u_int size)
d3695 1
a3695 1
    u_int32_t parms[16];
d3711 2
a3712 2
    return xfs_send_message_wakeup_data (fd, h->header.sequence_num, 0,
					 &parms, sizeof(parms));
d3720 1
a3720 1
vioc_breakcallback(int fd, struct xfs_message_pioctl *h, u_int size)
d3763 9
a3771 1
statistics_hostpart(int fd, struct xfs_message_pioctl *h, u_int size)
d3773 3
a3775 3
    u_int32_t host[100];
    u_int32_t part[100];
    u_int32_t outparms[512];
d3781 3
a3783 3
    if (h->outsize < sizeof(u_int32_t))
	return xfs_send_message_wakeup (fd, h->header.sequence_num,
					EINVAL);
d3787 1
a3787 1
    maxslots = (h->outsize / sizeof(u_int32_t) - 1) / 2;
d3791 1
a3791 1
    outsize = (n * 2 + 1) * sizeof(u_int32_t);
d3799 2
a3800 2
    return xfs_send_message_wakeup_data (fd, h->header.sequence_num, 0,
					 (char *) &outparms, outsize);
d3804 1
a3804 1
statistics_entry(int fd, struct xfs_message_pioctl *h, u_int size)
d3806 6
a3811 6
    u_int32_t *request = (u_int32_t *) h->msg;
    u_int32_t host;
    u_int32_t part;
    u_int32_t type;
    u_int32_t items_slot;
    u_int32_t count[32];
d3814 1
a3814 1
    u_int32_t outparms[160];
d3818 3
a3820 3
    if (h->insize < sizeof(u_int32_t) * 5) {
	return xfs_send_message_wakeup (fd, h->header.sequence_num,
					EINVAL);
d3823 3
a3825 3
    if (h->outsize < sizeof(u_int32_t) * 160) {
	return xfs_send_message_wakeup (fd, h->header.sequence_num,
					EINVAL);
d3848 2
a3849 2
    return xfs_send_message_wakeup_data (fd, h->header.sequence_num, 0,
					 (char *) &outparms, sizeof(outparms));
d3853 1
a3853 1
aioc_statistics(int fd, struct xfs_message_pioctl *h, u_int size)
d3855 1
a3855 1
    u_int32_t opcode;
d3858 2
a3859 2
	return xfs_send_message_wakeup (fd, h->header.sequence_num,
					EPERM);
d3861 3
a3863 3
    if (h->insize < sizeof(u_int32_t))
	return xfs_send_message_wakeup (fd, h->header.sequence_num,
					EPERM);
d3865 1
a3865 1
    opcode = *((int32_t *)h->msg);
d3867 2
a3868 1
    if (opcode == 0) {
d3870 1
a3870 1
    } else if (opcode == 1) {
d3872 42
a3913 3
    } else {
	return xfs_send_message_wakeup (fd, h->header.sequence_num,
					EINVAL);
d3915 3
d3926 1
a3926 1
xfs_message_pioctl (int fd, struct xfs_message_pioctl *h, u_int size)
d3940 12
d4207 1
d4210 1
a4210 1
#ifdef VIOCCKBACK_32
d4218 8
d4231 1
a4231 1
    xfs_send_message_wakeup (fd, h->header.sequence_num, error);
d4236 56
@


1.4
log
@merge
@
text
@d2673 1
a2673 1
    strcpy (p, cell);
@


1.3
log
@New Arla userland from Arla between 0.34.2 and current in arla cvs.
Too many new features and fixes to mention here.
@
text
@d2 1
a2 1
 * Copyright (c) 1995-2000 Kungliga Tekniska Högskolan
d17 1
a17 6
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by the Kungliga Tekniska
 *      Högskolan and its contributors.
 * 
 * 4. Neither the name of the Institute nor the names of its contributors
d35 1
a35 1
RCSID("$Id: messages.c,v 1.224 2000/08/25 02:51:03 assar Exp $");
d229 2
a230 1
                     AccessEntry *ae)
a233 1
    afsstatus2xfs_attr (status, statfid, &node->attr);
d235 12
a246 8
    node->anonrights = afsrights2xfsrights(status->AnonymousAccess,
					   status->FileType,
					   status->UnixModeBits);
    for (i = 0; i < NACCESS; i++) {
	node->id[i] = ae[i].cred;
	node->rights[i] = afsrights2xfsrights(ae[i].access,
					      status->FileType,
					      status->UnixModeBits);
d286 2
d295 2
a296 1
    case RXKADEXPIRED : {
d299 1
a299 1
	conn_clearcred (0, cred->pag, 2);
d306 5
a320 1
	    volcache_invalidate (fid->fid.Volume, fid->Cell);
d342 1
a342 1
	IOMGR_Sleep (1);
d347 1
a347 1
	IOMGR_Sleep (1);
d357 19
d384 1
a384 1
     Result result;
d397 5
a401 3
	     result = cm_getattr(root_fid, &status, &real_fid, ce, &ae);
	     if (result.res == -1)
		 ret = result.error;
d407 2
a408 1
			      &status, &msg.node, ae);
d410 1
d465 2
a466 1
	 fcacheentry2xfsnode (&fid, &real_fid, &status, &msg.node, ae);
d517 2
a518 1
	 fcacheentry2xfsnode (fid, &real_fid, &status, &msg.node, ae);
d587 9
a595 2
	 res = cm_getattr (*fid, &fetch_status, &real_fid, ce, &ae);
	 if (res.res == 0) {
d597 2
a598 1
				  &fetch_status, &msg.node, ae);
a603 2
	 } else {
	     ret = res.error;
d640 1
d679 1
a679 1
	 ret = fcache_get_data (&dir_entry, parent_fid, &ce);
d684 1
a684 1
			 &msg1.cache_handle,
d691 5
d702 2
a703 2
			      dir_entry->acccache);
	 msg1.flag = 0;
d705 1
a705 1
	 ret = fcache_get_data (&child_entry, &child_fid, &ce);
d709 1
a709 1
	 msg3.cache_handle = child_entry->handle;
d713 3
d717 1
d719 3
d729 2
a730 1
			      &fetch_status, &msg2.node, dir_entry->acccache);
d800 1
d806 1
d808 3
d846 1
a846 1
	 ret = fcache_get_data (&dir_entry, parent_fid, &ce);
d851 1
a851 1
			 &msg1.cache_handle,
d858 4
d867 2
a868 2
			      dir_entry->acccache);
	 msg1.flag = 0;
d874 1
a874 1
	 ret = fcache_get_data (&child_entry, &child_fid, &ce);
d879 1
a879 1
			 &msg3.cache_handle,
d886 4
d891 1
d893 3
a896 1
	 msg3.flag = 0;
d902 2
a903 1
			      dir_entry->acccache);
d962 1
d991 1
a991 1
	 ret = fcache_get_data (&dir_entry, parent_fid, &ce);
d996 1
a996 1
			 &msg1.cache_handle,
d1004 4
d1009 3
d1017 3
a1019 3
			      dir_entry->acccache);
	 msg1.flag = 0;
	 
d1026 2
a1027 1
			      dir_entry->acccache);
d1066 1
d1094 1
a1094 1
	 ret = fcache_get_data (&dir_entry, parent_fid, &ce);
d1099 1
a1099 1
			 &msg1.cache_handle,
d1107 1
d1109 2
d1112 3
d1120 2
a1121 1
			      dir_entry->acccache);
d1129 2
a1130 1
			      dir_entry->acccache);
d1176 1
a1220 1

d1229 1
a1229 1
	 ret = fcache_get_data (&dir_entry, parent_fid, &ce);
d1235 1
a1235 1
				 &msg1.cache_handle,
d1239 1
a1239 1
			     &msg1.cache_handle,
d1247 1
a1247 1

d1249 2
d1256 2
a1257 1
			      dir_entry->acccache);
d1267 3
d1306 2
a1307 1
			      limbo_entry->acccache);
d1339 1
a1339 1
     struct xfs_message_installdata msg1;
d1345 1
d1401 1
a1401 1
	 ret = fcache_get_data (&dir_entry, parent_fid, &ce);
d1407 1
a1407 1
				 &msg0.cache_handle,
d1411 1
a1411 1
			     &msg0.cache_handle,
d1419 4
a1423 1
	 msg0.flag = XFS_ID_INVALID_DNLC;
d1429 2
a1430 1
			      dir_entry->acccache);
d1462 2
a1463 1
				  limbo_entry->acccache);
d1468 3
d1512 1
d1544 1
a1544 1
	 ret = fcache_get_data (&old_entry, old_parent_fid, &ce);
d1550 1
a1550 1
				 &msg1.cache_handle,
d1554 1
a1554 1
			     &msg1.cache_handle,
d1562 4
a1566 1
	 msg1.flag = XFS_ID_INVALID_DNLC;
d1572 2
a1573 1
			      old_entry->acccache);
d1598 1
a1598 1
			 &msg2.cache_handle,
d1605 1
d1607 3
d1615 2
a1616 1
			      new_entry->acccache);
d1622 4
a1625 1
	 if (old_entry)
d1627 4
d1634 1
a1634 1
	     ret = fcache_get_data (&child_entry, &child_fid, &ce);
d1639 1
a1639 1
			     &msg3.cache_handle,
d1646 4
a1650 1
	     msg3.flag = XFS_ID_INVALID_DNLC;
d1656 2
a1657 1
				  child_entry->acccache);
d1748 1
d1771 2
a1772 3
	       ret = fcache_get_data (&entry, fid, &ce);
	       if (ret) {
		   try_again (&ret, &ce, &h->cred, NULL);
a1773 1
	       }
d1776 2
a1777 1
				    &entry->status, &msg.node, ae);
d1780 1
a1780 1
			       &msg.cache_handle,
d1783 4
a1786 1
	       if (res.res != -1) {
d1788 1
d1790 5
a1795 1
	       entry->flags.datausedp = TRUE;
d1798 18
a1815 8
	       res = cm_open (fid, &ce, h->tokens, &msg.cache_handle,
			      msg.cache_name, sizeof(msg.cache_name));
	       ret = res.error;
	       if (ret == 0) {
		   msg.node.tokens = res.tokens;
		   fcacheentry2xfsnode (fid, &real_fid,
					&status, &msg.node, ae);
	       }
a1850 4
     entry->flags.kernelp   = FALSE;
     entry->flags.attrusedp = FALSE;
     entry->flags.datausedp = FALSE;

d1875 1
a1875 1
install_attr (FCacheEntry *e)
d1879 1
d1882 1
a1882 1
			  e->acccache);
d2063 1
a2063 1
	install_attr (e);
d2244 1
d2251 6
a2256 1
    error = adir_lookup(&fid, filename, &mp_fid, NULL, ce);
d2606 2
d2612 1
d2791 1
a2791 1
    conn_clearcred (cell, h->cred.pag, 2);
d2872 1
d2874 1
d2945 2
d3202 2
d3340 112
d3719 16
@


1.2
log
@upgrade Arla to fresher code. Too many new features and bugfixes.
@
text
@a0 1
/*	$OpenBSD$	*/
d2 1
a2 1
 * Copyright (c) 1995, 1996, 1997, 1998, 1999 Kungliga Tekniska Högskolan
d40 1
a40 1
RCSID("$KTH: messages.c,v 1.126 1999/04/14 15:27:36 map Exp $");
a55 3
xfs_message_wakeup (int, struct xfs_message_wakeup*, u_int);

static int 
a99 2
typedef int 
(*xfs_message_function) (int, struct xfs_message_header*, u_int);
d101 1
a101 1
static xfs_message_function rcvfuncs[] = {
d127 2
a128 1
NULL						/* advlock */
a130 1
static u_int *seqnums;
d132 3
a134 1
static List *sleepers;
d136 10
a145 3
/* number of times each type of message has been sent */

static unsigned sent_stat[XFS_MSG_COUNT];
a146 37
/* number of times each type of message has been received */

static unsigned recv_stat[XFS_MSG_COUNT];

/* count of the number of messages in a write */

static unsigned send_count[9];	/* 8 is the max the multiple stuff handles */

static char *rcvfuncs_name[] = 
{
  "version",
  "wakeup",
  "getroot",
  "installroot",
  "getnode",
  "installnode",
  "getattr",
  "installattr",
  "getdata",
  "installdata",
  "inactivenode",
  "invalidnode",
  "open",
  "put_data",
  "put_attr",
  "create",
  "mkdir",
  "link",
  "symlink",
  "remove",
  "rmdir",
  "rename",
  "pioctl",
  "wakeup_data",
  "updatefid",
  "advlock"
};
d153 1
a153 1
afsfid2inode (VenusFid *fid)
d164 1
a164 1
		    VenusFid *fid,
d172 1
d177 1
d182 1
a187 1
     XA_SET_NLINK(attr, status->LinkCount);
d229 3
a231 3
static void
fcacheentry2xfsnode (VenusFid *fid,
		     VenusFid *statfid, 
d251 4
a284 222
 *
 */

void
xfs_message_init (void)
{
     unsigned i;

     seqnums = (u_int *)malloc (sizeof (*seqnums) * getdtablesize ());
     if (seqnums == NULL)
	 arla_err (1, ADEBERROR, errno, "xfs_message_init: malloc");
     for (i = 0; i < getdtablesize (); ++i)
	  seqnums[i] = 0;
     sleepers = listnew ();
     if (sleepers == NULL)
	 arla_err (1, ADEBERROR, errno, "xfs_message_init: listnew");
     assert (sizeof(rcvfuncs) / sizeof(*rcvfuncs) == XFS_MSG_COUNT);
     assert (sizeof(rcvfuncs_name) / sizeof(*rcvfuncs_name) == XFS_MSG_COUNT);
}

/*
 *
 */

int
xfs_message_receive (int fd, struct xfs_message_header *h, u_int size)
{
     unsigned opcode = h->opcode;

     if (opcode >= XFS_MSG_COUNT || rcvfuncs[opcode] == NULL ) {
	  arla_warnx (ADEBMSG, "Bad message opcode = %u", opcode);
	  return -1;
     }

     ++recv_stat[opcode];

     arla_warnx (ADEBMSG, "Rec message: opcode = %u (%s), size = %u",
		 opcode, rcvfuncs_name[opcode], h->size);

     return (*rcvfuncs[opcode])(fd, h, size);
}

/*
 *
 */

static int
xfs_message_send (int fd, struct xfs_message_header *h, u_int size)
{
     int res;
     unsigned opcode = h->opcode;

     h->size = size;
     h->sequence_num = seqnums[fd]++;

     if (opcode >= XFS_MSG_COUNT) {
	  arla_warnx (ADEBMSG, "Bad message opcode = %u", opcode);
	  return -1;
     }

     ++sent_stat[opcode];
     ++send_count[1];

     arla_warnx (ADEBMSG, "Send message: opcode = %u (%s), size = %u",
		 opcode, rcvfuncs_name[opcode], h->size);

     if ((res = write (fd, h, size)) < 0) {
	 arla_warn (ADEBMSG, errno, "xfs_message_send: write");
	 return -1;
     } else
	 return 0;
}

static int
xfs_message_wakeup (int fd, struct xfs_message_wakeup *h, u_int size)
{
     Listitem *i;
     struct xfs_message_header *w;

     for (i = listhead (sleepers); i; i = listnext (sleepers, i)) {
	  w = (struct xfs_message_header *)listdata(i);
	  if (w->sequence_num == h->sleepers_sequence_num) {
	       listdel (sleepers, i);
	       memcpy (w, h, size);
	       LWP_SignalProcess ((char *)w);
	  }
     }
     return 0;
}

static int
xfs_message_sleep (struct xfs_message_header *h)
{
     listaddtail (sleepers, h);
     LWP_WaitProcess ((char *)h);
     return ((struct xfs_message_wakeup *)h)->error;
}

static int __attribute__ ((unused))
xfs_message_rpc (int fd, struct xfs_message_header *h, u_int size)
{
     if (size < sizeof (struct xfs_message_wakeup)) {
	  arla_warnx (ADEBMSG, "xfs_message_rpc: Too small packet for rpc");
	  return -1;
     }
     return xfs_message_send (fd, h, size) || xfs_message_sleep (h);
}

static int
xfs_send_message_wakeup (int fd, u_int seqnum, int error)
{
     struct xfs_message_wakeup msg;
     
     msg.header.opcode = XFS_MSG_WAKEUP;
     msg.sleepers_sequence_num = seqnum;
     msg.error = error;
     arla_warnx (ADEBMSG, "sending wakeup: seq = %u, error = %d",
		 seqnum, error);
     return xfs_message_send (fd, (struct xfs_message_header *)&msg, 
			      sizeof(msg));
}

/*
 *
 */

static int
xfs_send_message_wakeup_vmultiple (int fd,
				   u_int seqnum,
				   int error,
				   va_list args)
{
    struct iovec iovec[8];
    struct xfs_message_header *h;
    struct xfs_message_wakeup msg;
    size_t size;
    int i = 0;
    int ret;

    h = va_arg (args, struct xfs_message_header *);
    size = va_arg (args, size_t);
    while (h != NULL) {
	h->size = size;
	h->sequence_num = seqnums[fd]++;
	assert (h->opcode >= 0 && h->opcode < XFS_MSG_COUNT);
	assert (i < 8);
	iovec[i].iov_base = (char *)h;
	iovec[i].iov_len  = size;

	++sent_stat[h->opcode];

	arla_warnx (ADEBMSG, "Multi-send: opcode = %u (%s), size = %u",
		    h->opcode, rcvfuncs_name[h->opcode], h->size);

	h = va_arg (args, struct xfs_message_header *);
	size = va_arg (args, size_t);
	++i;
    }
    msg.header.opcode = XFS_MSG_WAKEUP;
    msg.header.size  = sizeof(msg);
    msg.header.sequence_num = seqnums[fd]++;
    msg.sleepers_sequence_num = seqnum;
    msg.error = error;
    iovec[i].iov_base = (char *)&msg;
    iovec[i].iov_len  = sizeof(msg);

    ++sent_stat[XFS_MSG_WAKEUP];

    arla_warnx (ADEBMSG, "multi-sending wakeup: seq = %u, error = %d",
		seqnum, error);

    ++i;
    
    ++send_count[i];

    ret = writev (fd, iovec, i);
    if (ret < 0) {
	arla_warn (ADEBMSG, errno,
		   "xfs_send_message_wakeup_vmultiple: writev");
	return -1;
    }
    return 0;
}

static int
xfs_send_message_wakeup_multiple (int fd,
				  u_int seqnum,
				  int error,
				  ...)
{
    va_list args;
    int ret;

    va_start (args, error);
    ret = xfs_send_message_wakeup_vmultiple (fd, seqnum, error, args);
    va_end (args);
    return ret;
}

static int
xfs_send_message_wakeup_data (int fd, u_int seqnum, int error,
			      void *data, int size)
{
     struct xfs_message_wakeup_data msg;
     
     msg.header.opcode = XFS_MSG_WAKEUP_DATA;
     msg.sleepers_sequence_num = seqnum;
     msg.error = error;
     arla_warnx (ADEBMSG,
		 "sending wakeup: seq = %u, error = %d", seqnum, error);

     if (sizeof(msg) >= size && size != 0) {
	 memcpy(msg.msg, data, size);
     }

     msg.len = size;

     return xfs_message_send (fd, (struct xfs_message_header *)&msg, 
			      sizeof(msg));
}

/*
d286 1
a286 1
 * Magic with `ce' has to be done as well.
d290 1
a290 1
try_again (int *ret, CredCacheEntry **ce, xfs_cred *cred, VenusFid *fid)
d294 4
a297 1
    case RXKADEXPIRED :
d300 1
a300 1
	*ce = cred_get (0, cred->pag, CRED_ANY);
d303 1
d313 1
a313 1
	if (fid) {
d334 2
a335 1
	arla_warnx (ADEBWARN, "Waiting for busy volume...");
d339 2
a340 1
	arla_warnx (ADEBWARN, "Waiting fileserver to restart...");
d364 1
d366 1
a366 1
     ce = cred_get (0, h->cred.pag, CRED_ANY);
d410 7
d421 1
d423 2
a424 2
	 res = cm_lookup (*dirfid, h->name, &fid, &ce);
	 if (res.res == 0)
d426 2
d433 1
a433 1
     } while (try_again (&ret, &ce, &h->cred, &fid));
d438 1
a438 1
	 msg.node.tokens = res.tokens;
d440 1
a440 1
	 strcpy (msg.name, h->name);
d471 4
d489 1
a489 2
	 msg.node.tokens = res.tokens & ~XFS_DATA_MASK;
	 /* XXX - should not clear data mask if kernel already has data */
d519 3
d524 4
d532 9
d561 1
a561 1
	     msg.node.tokens = res.tokens & ~XFS_DATA_MASK;
d570 4
d601 2
a602 1
     FCacheEntry *dir_entry;
d605 6
d612 14
d630 2
a631 2
	 res = cm_create(*parent_fid, h->name, &store_status,
			 &child_fid, &fetch_status, ce);
a639 1
	 FCacheEntry *child_entry;
d641 1
a641 1
	 ret = fcache_get (&dir_entry, *parent_fid, ce);
a643 6

	 ret = fcache_get_data (dir_entry, ce);
	 if (ret) {
	     fcache_release(dir_entry);
	     goto out;
	 }
a649 1
	     fcache_release(dir_entry);
a652 1

d656 1
a656 1
			      &dir_entry->realfid,
d661 2
a662 3
	 fcache_release(dir_entry);
	 
	 ret = fcache_get (&child_entry, child_fid, ce);
a665 6
	 ret = fcache_get_data (child_entry, ce);
	 if (ret) {
	     fcache_release(child_entry);
	     goto out;
	 }

d670 3
a672 1
	 fcache_release(child_entry);
d681 3
a683 1
	 msg2.node.tokens   = XFS_ATTR_R | XFS_OPEN_NW | XFS_OPEN_NR; /* XXX */
d685 1
a685 1
	 strcpy (msg2.name, h->name);
d712 4
d740 2
d750 9
a758 1
     parent_fid = (VenusFid *)&h->parent_handle;
d764 14
d780 2
a781 2
	 res = cm_mkdir(*parent_fid, h->name, &store_status,
			&child_fid, &fetch_status, ce);
a788 2
	 FCacheEntry *dir_entry;
	 FCacheEntry *child_entry;
d790 1
a790 1
	 ret = fcache_get (&dir_entry, *parent_fid, ce);
a793 6
	 ret = fcache_get_data (dir_entry, ce);
	 if (ret) {
	     fcache_release(dir_entry);
	     goto out;
	 }
	     
a798 1
	     fcache_release(dir_entry);
d805 1
a805 1
			      &dir_entry->realfid,
a812 1
	 fcache_release(dir_entry);
d814 1
a814 1
	 ret = fcache_get (&child_entry, child_fid, ce);
a817 6
	 ret = fcache_get_data (child_entry, ce);
	 if (ret) {
	     fcache_release(child_entry);
	     goto out;
	 }

a822 1
	     fcache_release(child_entry);
d826 3
d838 1
a838 1
	 strcpy (msg2.name, h->name);
a842 1
	 fcache_release(child_entry);
d848 13
d864 4
d897 9
d911 2
a912 2
	 res = cm_link (*parent_fid, h->name, *existing_fid,
			&fetch_status, ce);
d922 1
a922 1
	 ret = fcache_get (&dir_entry, *parent_fid, ce);
a925 6
	 ret = fcache_get_data (dir_entry, ce);
	 if (ret) {
	     fcache_release(dir_entry);
	     goto out;
	 }
	     
d936 1
d939 1
a939 1
			      &dir_entry->realfid,
a946 1
	 fcache_release(dir_entry);
d951 2
a952 1
			      
d955 1
a955 1
	 strcpy (msg2.name, h->name);
d977 1
a977 1
     VenusFid *parent_fid, child_fid;
d991 4
d1002 4
a1005 3
	 res = cm_symlink(*parent_fid, h->name, &store_status,
			  &child_fid, &fetch_status,
			  h->contents, ce);
d1016 1
a1016 1
	 ret = fcache_get (&dir_entry, *parent_fid, ce);
a1019 6
	 ret = fcache_get_data (dir_entry, ce);
	 if (ret) {
	     fcache_release(dir_entry);
	     goto out;
	 }
	     
d1031 1
d1034 1
a1034 1
			      &dir_entry->realfid,
a1040 1
	 fcache_release(dir_entry);
d1042 1
a1042 1
	 fcacheentry2xfsnode (&child_fid, &child_fid,
d1045 1
d1049 1
a1049 1
	 strcpy (msg2.name, h->name);
d1067 5
d1076 1
d1080 2
a1081 1
     struct xfs_message_installdata msg;
d1084 6
d1092 4
d1101 33
a1133 1
	 res = cm_remove(*parent_fid, h->name, ce);
d1141 1
a1141 2
     if (res.res == 0) {
	 FCacheEntry *dir_entry;
d1143 1
a1143 1
	 ret = fcache_get (&dir_entry, *parent_fid, ce);
d1147 13
a1159 14
	 ret = fcache_get_data (dir_entry, ce);
	 if (ret) {
	     fcache_release(dir_entry);
	     goto out;
	 }
	     
	 res = conv_dir (dir_entry, ce, 0,
			 &msg.cache_handle,
			 msg.cache_name,
			 sizeof(msg.cache_name));
	 if (res.res == -1) {
	     fcache_release(dir_entry);
	     ret = res.error;
	     goto out;
d1162 2
a1163 2
	 msg.flag = XFS_INVALID_DNLC;
	 msg.node.tokens = res.tokens;
d1166 2
a1167 2
			      &dir_entry->realfid,
			      &dir_entry->status, &msg.node,
d1170 49
a1218 4
	 msg.header.opcode = XFS_MSG_INSTALLDATA;
	 h0 = (struct xfs_message_header *)&msg;
	 h0_len = sizeof(msg);
	 fcache_release(dir_entry);
d1222 4
d1231 1
d1239 1
a1239 1
     VenusFid *parent_fid;
d1243 1
a1243 1
     struct xfs_message_installdata msg;
d1246 6
d1254 4
d1262 35
d1298 1
a1298 1
	 res = cm_rmdir(*parent_fid, h->name, ce);
a1305 1
	 FCacheEntry *dir_entry;
d1307 1
a1307 1
	 ret = fcache_get (&dir_entry, *parent_fid, ce);
d1311 13
a1323 4
	 ret = fcache_get_data (dir_entry, ce);
	 if (ret) {
	     fcache_release(dir_entry);
	     goto out;
d1325 3
a1327 12
	     
	 res = conv_dir (dir_entry, ce, 0,
			 &msg.cache_handle,
			 msg.cache_name,
			 sizeof(msg.cache_name));
	 if (res.res == -1) {
	     fcache_release(dir_entry);
	     ret = res.error;
	     goto out;
	 }
	 msg.flag = XFS_INVALID_DNLC;
	 msg.node.tokens = res.tokens;
d1330 2
a1331 2
			      &dir_entry->realfid,
			      &dir_entry->status, &msg.node,
d1334 36
a1369 4
	 msg.header.opcode = XFS_MSG_INSTALLDATA;
	 h0 = (struct xfs_message_header *)&msg;
	 h0_len = sizeof(msg);
	 fcache_release(dir_entry);
d1373 5
d1383 1
d1393 1
d1399 1
d1404 6
d1413 12
d1430 3
a1432 3
	 res = cm_rename(*old_parent_fid, h->old_name,
			 *new_parent_fid, h->new_name,
			 ce);
a1439 1
	 FCacheEntry *dir_entry;
d1441 1
a1441 1
	 ret = fcache_get (&dir_entry, *old_parent_fid, ce);
d1445 13
a1457 4
	 ret = fcache_get_data (dir_entry, ce);
	 if (ret) {
	     fcache_release(dir_entry);
	     goto out;
d1459 2
a1460 11
	     
	 res = conv_dir (dir_entry, ce, 0,
			 &msg1.cache_handle,
			 msg1.cache_name,
			 sizeof(msg1.cache_name));
	 if (res.res == -1) {
	     fcache_release(dir_entry);
	     ret = res.error;
	     goto out;
	 }
	 msg1.flag = XFS_INVALID_DNLC;
d1464 3
a1466 3
			      &dir_entry->realfid,
			      &dir_entry->status, &msg1.node,
			      dir_entry->acccache);
a1470 1
	 fcache_release(dir_entry);
a1471 1
	 /* new parent */
d1473 14
a1486 1
	 ret = fcache_get (&dir_entry, *new_parent_fid, ce);
d1490 1
a1490 7
	 ret = fcache_get_data (dir_entry, ce);
	 if (ret) {
	     fcache_release(dir_entry);
	     goto out;
	 }
	 
	 res = conv_dir (dir_entry, ce, 0,
d1493 1
a1493 1
			     sizeof(msg2.cache_name));
a1494 1
	     fcache_release(dir_entry);
d1498 1
a1498 1
	 msg2.flag = XFS_INVALID_DNLC;
d1502 3
a1504 3
			      &dir_entry->realfid,
			      &dir_entry->status, &msg2.node,
			      dir_entry->acccache);
d1509 31
a1539 1
	 fcache_release(dir_entry);
d1543 4
d1566 3
d1571 5
d1578 11
a1588 2
     ce = cred_get (fid->Cell, h->cred.pag, CRED_ANY);
     assert (ce != NULL);
d1598 6
a1603 1
     if (ret)
d1605 1
d1608 1
a1608 2
     xfs_send_message_wakeup (fd, h->header.sequence_num,
			      res.res ? res.error : res.res);
d1627 4
d1643 1
a1643 2
     if (res.res == 0) {
	  fcacheentry2xfsnode (fid, &real_fid, &status, &msg.node, ae);
d1647 1
a1647 5
	       ret = fcache_get (&entry, *fid, ce);
	       if (ret)
		   goto out;

	       ret = fcache_get_data (entry, ce);
d1649 1
a1649 1
		   fcache_release(entry);
d1653 3
d1662 1
a1662 1
		   msg.flag = XFS_INVALID_DNLC;
d1664 1
d1667 1
a1667 1
	       res = cm_open (*fid, ce, h->tokens, &msg.cache_handle,
d1669 2
a1670 1
	       if (res.res != -1)
d1672 3
d1678 1
a1678 1
     if (res.res != -1) {
d1688 1
a1688 1
				       res.res ? res.error : res.res,
d1695 5
d1701 1
a1701 1
break_callback (VenusFid fid)
d1704 9
d1715 16
a1730 3
     memcpy (&msg.handle, &fid, sizeof(fid));
     xfs_message_send (kernel_fd, (struct xfs_message_header *)&msg, 
		       sizeof(msg));
d1743 1
a1743 1
     fcacheentry2xfsnode (&e->fid, &e->realfid, &e->status, &msg.node,
d1754 2
a1755 1
update_kernelfid(VenusFid oldfid, VenusFid newfid)
d1764 9
d1785 4
d1802 5
a1806 2
     if (h->flag & XFS_DELETE)
	 entry->flags.kernelp = FALSE;
d1860 1
a1860 1
	return EINVAL;
d1881 2
a1882 1
    free (opaque.val);
d1896 1
d1900 1
a1900 1
	return EINVAL;
d1902 2
a1903 2
    if (h->insize > AFSOPAQUEMAX)
	return EINVAL;
d1905 3
a1907 2
    if((opaque.val=malloc(AFSOPAQUEMAX))==NULL)
	return ENOMEM;
d1909 1
a1909 1
    fid.Cell = h->handle.a;
d1911 1
a1911 1
    fid.fid.Vnode = h->handle.c;
d1917 1
a1917 1
    opaque.len=h->insize;
d1921 1
a1921 1
	error = setacl (fid, ce, &opaque);
d1924 4
a1927 1
    if (error != 0 && error != EACCES)
d1933 1
a1933 2
    xfs_send_message_wakeup_data (fd, h->header.sequence_num, error,
				  NULL, 0);
d1951 1
a1951 1
    int32_t outsize;
d1955 1
a1955 1
	return EINVAL;
d1971 4
a1974 2
	error = getvolstat (fid, ce, &volstat, volumename,
			    offlinemsg, motd);
d2094 3
a2096 2
 * Get the mount point from (fid, filename) and return in `fbuf'.
 * Return 0 or error.
d2100 4
a2103 3
read_mount_point (VenusFid fid, const char *filename, fbuf *the_fbuf,
		  CredCacheEntry *ce,
		  FCacheEntry **ret_mp_entry)
a2107 2
    int mp_fd;
    char *buf;
d2112 2
a2113 2
    error = adir_lookup(fid, filename, &mp_fid, ce);
    if (error) {
a2114 1
    }
d2116 2
a2117 2
    error = fcache_get(&mp_entry, mp_fid, ce);
    if (error) {
a2118 1
    }
d2120 1
a2120 1
    error = fcache_get_attr (mp_entry, ce);
d2125 4
a2128 1
    if (mp_entry->status.FileType != TYPE_LINK) { /* Is not a mount point */
d2132 19
a2150 3
    error = fcache_get_data (mp_entry, ce);
    if (error) {
	fcache_release(mp_entry);
d2152 3
a2154 4
    }
    mp_fd = fcache_open_file (mp_entry, O_RDONLY);
    if (mp_fd < 0) {
	fcache_release(mp_entry);
d2156 3
a2158 3
    }
    error = fbuf_create (the_fbuf, mp_fd, mp_entry->status.Length,
			 FBUF_READ);
d2160 1
a2160 1
	fcache_release(mp_entry);
d2163 1
d2167 1
a2167 1
	fcache_release(mp_entry);
a2170 6
    if(ret_mp_entry)
	*ret_mp_entry = mp_entry;
    else {
	fbuf_end (the_fbuf);
	fcache_release (mp_entry);
    }
d2183 1
d2187 1
d2199 7
a2205 1
    error = read_mount_point (fid, h->msg, &the_fbuf, ce, &e);
d2207 1
d2209 1
a2209 1
	return error;
d2212 9
d2222 1
a2222 1
				  the_fbuf.buf, the_fbuf.len - 1);
d2224 2
d2227 1
a2227 1
    fcache_release (e);
a2240 1
    fbuf the_fbuf;
d2243 1
d2255 1
a2255 1
    error = read_mount_point (fid, h->msg, &the_fbuf, ce, NULL);
d2258 2
a2259 1
	return error;
d2264 1
a2264 1
    strcpy(remove_msg.name, h->msg);
d2277 1
a2277 1
    int i;
d2279 1
d2282 1
a2282 1
	return EINVAL;
d2284 1
a2284 1
    fid.Cell = h->handle.a;
d2286 1
a2286 1
    fid.fid.Vnode = h->handle.c;
d2295 1
a2295 1
	return error;
d2297 1
a2297 1
    error = fcache_get_attr (e, ce);
d2301 9
a2309 1
	return error;
d2311 1
d2313 2
a2314 2
    for (i = 0; (i < e->volume->entry.nServers) && (i < 8); i++)
	addresses[i] = e->volume->entry.serverNumber[i];
d2316 3
d2320 1
a2320 1
				  addresses, sizeof(long) * 8);
d2330 1
a2330 1
 */
d2349 1
a2349 1
    dbservers = cell_dbservers (index, &num_dbservers);
d2471 1
a2471 1
	ce = cell_new (cellname);
d2509 1
a2509 1
    ct.ViceId = h->cred.uid;
d2513 1
a2513 1
    tmp = 0;
d2516 2
d2548 2
a2549 1
	CredCacheEntry *ce = cred_get (0, h->cred.pag, CRED_KRB4);
d2641 3
d2654 1
a2654 1
    pag_t cred = h->cred.pag;
d2725 1
a2725 2
		do_replay(ARLACACHEDIR"/discon_log",
			  log_data.log_entries, 0);
d2764 1
a2764 1
	if (rxkad_min_level == rxkad_crypt)
d2791 1
a2791 1
	    rxkad_min_level = rxkad_auth;
d2793 1
a2793 1
	    rxkad_min_level = rxkad_crypt;
d2804 4
d2826 1
d2883 1
d2904 1
d2906 1
d2941 1
a2941 1
	*((u_int32 *)buf) = sysname_len;
d3002 1
a3002 1
    int32_t cell = 0; /* Default local cell */
d3049 2
d3117 70
d3197 4
d3202 1
d3205 4
d3210 1
d3212 4
d3217 5
d3223 1
d3227 4
d3232 6
a3237 2
	error = viocconnect(fd, h, size);
	break;
d3239 1
d3242 4
d3247 1
d3250 4
d3255 1
d3257 4
d3262 6
a3267 2
	error = viocgetacl(fd, h, size);
	break;
d3269 6
a3274 2
	error = viocsetacl(fd, h, size);
	break;
d3276 6
a3281 2
	error = viocgetvolstat(fd, h, size);
	break;
d3283 1
d3286 4
d3291 6
a3296 2
	error = vioc_afs_stat_mt_pt(fd, h, size);
	break;
d3298 6
a3303 2
	error = vioc_afs_delete_mt_pt(fd, h, size);
	break;
d3305 6
a3310 2
	error = viocwhereis(fd, h, size);
	break;
d3312 1
d3315 4
d3320 1
d3322 4
d3327 1
d3329 4
d3334 1
d3336 4
d3341 1
d3343 4
d3348 1
d3351 4
d3356 1
d3358 4
d3363 1
d3365 4
d3370 1
d3372 4
d3377 1
d3380 4
d3385 1
d3387 4
d3392 1
d3394 6
a3399 1
    case VIOC_GETRXKCRYPT :
d3401 6
a3406 1
    case VIOC_SETRXKCRYPT :
d3409 4
d3414 1
d3417 4
d3422 1
d3424 6
a3429 1
    case VIOC_ARLADEBUG :
d3431 6
a3436 1
    case VIOC_GCPAGS :
d3439 15
d3463 1
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
 * Copyright (c) 1995, 1996, 1997, 1998 Kungliga Tekniska Högskolan
d41 1
a41 1
RCSID("$KTH: messages.c,v 1.79 1998/08/17 21:03:20 art Exp $");
d48 1
a48 1
#include <kerberosIV/kafs.h>
d52 4
d131 3
a133 1
NULL	                                        /* wakeup_data */
d178 2
d182 4
d189 1
a189 1
     return ((fid->fid.Volume & 0x7FFF) << 16 | (fid->fid.Vnode & 0xFFFFFFFF));
d224 3
a226 3
     XA_SET_ATIME(attr, status->ServerModTime);
     XA_SET_MTIME(attr, status->ServerModTime);
     XA_SET_CTIME(attr, status->ServerModTime);
d283 1
a283 1
static int
d305 1
a305 1
    storestatus->Mask = mask ;   
d308 1
a308 1
    storestatus->SegSize = 0 ;
d355 4
a402 1
#ifdef notyet
d411 1
a411 1
static int
a419 1
#endif
d534 61
d611 2
d614 6
a619 3
     ret = getroot (&root_fid, ce);
     if (ret)
	 goto out;
d621 3
a623 12
     result = cm_getattr(root_fid, &status, &real_fid, ce, &ae);
     if (result.res == -1) {
	 ret = result.error;
	 goto out;
     }	 

     fcacheentry2xfsnode (&root_fid, &real_fid,
			  &status, &msg.node, ae);

     msg.header.opcode = XFS_MSG_INSTALLROOT;
     h0 = (struct xfs_message_header *)&msg;
     h0_len = sizeof(msg);
d625 3
a627 5
out:
     if (ret == RXKADEXPIRED) {
	 cred_expire (ce);
	 cred_free (ce);
	 return xfs_message_getroot (fd, h, size);
d636 1
a636 1
     return ret;
d652 1
d657 17
a673 16
     res = cm_lookup (*dirfid, h->name, &fid, &ce);
     if (res.res == 0) {
	  res = cm_getattr (fid, &status, &real_fid, ce, &ae);
	  if (res.res == 0) {
	       fcacheentry2xfsnode (&fid, &real_fid,
				    &status, &msg.node, ae);

	       msg.node.tokens = res.tokens & ~XFS_DATA_MASK;
	       msg.parent_handle = h->parent_handle;
	       strcpy (msg.name, h->name);

	       msg.header.opcode = XFS_MSG_INSTALLNODE;
	       h0 = (struct xfs_message_header *)&msg;
	       h0_len = sizeof(msg);
	  }
     }
d675 3
a677 4
     if (res.res != 0 && res.error == RXKADEXPIRED) {
	 cred_expire (ce);
	 cred_free (ce);
	 return xfs_message_getnode (fd, h, size);
d683 1
a683 1
				       res.res == -1 ? res.error : res.res,
d701 1
a703 1

d707 10
a716 4
     res = cm_getattr (*fid, &status, &real_fid, ce, &ae);
     if (res.res == 0) {
	 fcacheentry2xfsnode (fid, &real_fid,
			      &status, &msg.node, ae);
d719 1
a724 6
     if (res.res != 0 && res.error == RXKADEXPIRED) {
	 cred_expire (ce);
	 cred_free (ce);
	 return xfs_message_getattr (fd, h, size);
     }

d728 1
a728 1
				       res.res ? res.error : res.res,
a734 1

d738 1
d741 1
d744 5
d751 1
a751 1

d755 27
a781 12
     xfs_attr2afsstorestatus(&h->attr, &status);
     res.res = 0;
     if (XA_VALID_SIZE(&h->attr))
	 res = cm_ftruncate (*fid, h->attr.xa_size, ce);

     if (res.res == 0)
	 res = cm_setattr(*fid, &status, ce);

     if (res.res != 0 && res.error == RXKADEXPIRED) {
	 cred_expire (ce);
	 cred_free (ce);
	 return xfs_message_putattr (fd, h, size);
d785 5
a789 2
     xfs_send_message_wakeup (fd, h->header.sequence_num, 
			      res.res ? res.error : res.res);
d811 1
d814 1
a814 1

d818 10
a827 3
     xfs_attr2afsstorestatus(&h->attr, &store_status);
     res = cm_create(*parent_fid, h->name, &store_status,
		     &child_fid, &fetch_status, ce);
a828 1
	 FCacheEntry *dir_entry;
a829 2
	 char tmp[5];
	 VenusFid realfid;
d837 1
a837 1
	     ReleaseWriteLock (&dir_entry->lock);
d841 4
a844 1
	 res = conv_dir (dir_entry, tmp, sizeof(tmp), ce, 0); /* XXX */
d846 1
a846 1
	     ReleaseWriteLock (&dir_entry->lock);
d850 1
a850 1
	 strncpy((char *)&msg1.cache_handle, tmp, 4);
d853 2
a854 6
	 if (dir_entry->flags.mountp)
	     realfid = dir_entry->realfid;
	 else
	     realfid = *parent_fid;

	 fcacheentry2xfsnode (parent_fid, &realfid,
d858 2
a859 1
	 ReleaseWriteLock (&dir_entry->lock);
d867 1
a867 1
	     ReleaseWriteLock (&child_entry->lock);
d871 5
a875 2
	 sprintf (tmp, "%04X", (unsigned)child_entry->inode); /* XXX */
	 ReleaseWriteLock (&child_entry->lock);
d894 1
a894 1
	 strncpy((char *)&msg3.cache_handle, tmp, 4); /* XXX */
d899 13
a911 9
     if (res.res == -1) {
	 ret = res.error;
	 if (ret == RXKADEXPIRED) {
	     cred_expire (ce);
	     cred_free (ce);
	     return xfs_message_create (fd, h, size);
	 }
     } else
	 ret = 0;
d936 2
d942 2
d951 10
a960 2
     res = cm_mkdir(*parent_fid, h->name, &store_status,
		    &child_fid, &fetch_status, ce);
d963 1
a963 2
	 char tmp[5];
	 VenusFid realfid;
d971 1
a971 1
	     ReleaseWriteLock (&dir_entry->lock);
d975 4
a978 1
	 res = conv_dir (dir_entry, tmp, sizeof(tmp), ce, 0); /* XXX */
d980 1
a980 1
	     ReleaseWriteLock (&dir_entry->lock);
a983 1
	 strncpy((char *)&msg1.cache_handle, tmp, 4);
d986 2
a987 6
	 if (dir_entry->flags.mountp)
	     realfid = dir_entry->realfid;
	 else
	     realfid = *parent_fid;

	 fcacheentry2xfsnode (parent_fid, &realfid,
d990 1
d995 24
a1018 1
	 ReleaseWriteLock (&dir_entry->lock);
d1021 1
a1021 1
			      &fetch_status, &msg2.node,
a1023 1
	 msg2.node.tokens   = XFS_ATTR_R; /* XXX */
d1030 6
a1037 9
     if (res.res == -1) {
	 ret = res.error;
	 if (ret == RXKADEXPIRED) {
	     cred_expire (ce);
	     cred_free (ce);
	     return xfs_message_mkdir (fd, h, size);
	 }
     } else
	 ret = 0;
d1045 1
d1072 9
a1080 2
     res = cm_link (*parent_fid, h->name, *existing_fid,
		    &fetch_status, ce);
a1082 2
	 char tmp[5];
	 VenusFid realfid;
d1090 1
a1090 1
	     ReleaseWriteLock (&dir_entry->lock);
d1094 4
a1097 1
	 res = conv_dir (dir_entry, tmp, sizeof(tmp), ce, 0); /* XXX */
d1099 1
a1099 1
	     ReleaseWriteLock (&dir_entry->lock);
a1102 1
	 strncpy((char *)&msg1.cache_handle, tmp, 4);
d1105 2
a1106 6
	 if (dir_entry->flags.mountp)
	     realfid = dir_entry->realfid;
	 else
	     realfid = *parent_fid;

	 fcacheentry2xfsnode (parent_fid, &realfid,
d1109 1
d1114 1
a1114 1
	 ReleaseWriteLock (&dir_entry->lock);
a1128 9
     if (res.res == -1) {
	 ret = res.error;
	 if (ret == RXKADEXPIRED) {
	     cred_expire (ce);
	     cred_free (ce);
	     return xfs_message_link (fd, h, size);
	 }
     } else
	 ret = 0;
d1163 12
a1174 3
     res = cm_symlink(*parent_fid, h->name, &store_status,
		      &child_fid, &fetch_status,
		      h->contents, ce);
a1176 2
	 char tmp[5];
	 VenusFid realfid;
d1184 1
a1184 1
	     ReleaseWriteLock (&dir_entry->lock);
d1188 4
a1191 1
	 res = conv_dir (dir_entry, tmp, sizeof(tmp), ce, 0); /* XXX */
d1193 1
a1193 1
	     ReleaseWriteLock (&dir_entry->lock);
d1197 1
a1197 1
	 strncpy((char *)&msg1.cache_handle, tmp, 4);
d1200 2
a1201 6
	 if (dir_entry->flags.mountp)
	     realfid = dir_entry->realfid;
	 else
	     realfid = *parent_fid;

	 fcacheentry2xfsnode (parent_fid, &realfid,
d1208 1
a1208 1
	 ReleaseWriteLock (&dir_entry->lock);
a1222 9
     if (res.res == -1) {
	 ret = res.error;
	 if (ret == RXKADEXPIRED) {
	     cred_expire (ce);
	     cred_free (ce);
	     return xfs_message_symlink (fd, h, size);
	 }
     } else
	 ret = 0;
d1250 9
a1258 1
     res = cm_remove(*parent_fid, h->name, ce);
a1260 2
	 char tmp[5];
	 VenusFid realfid;
d1268 1
a1268 1
	     ReleaseWriteLock (&dir_entry->lock);
d1272 4
a1275 1
	 res = conv_dir (dir_entry, tmp, sizeof(tmp), ce, 0); /* XXX */
d1277 1
a1277 1
	     ReleaseWriteLock (&dir_entry->lock);
d1281 2
a1282 1
	 strncpy((char *)&msg.cache_handle, tmp, 4);
d1285 2
a1286 6
	 if (dir_entry->flags.mountp)
	     realfid = dir_entry->realfid;
	 else
	     realfid = *parent_fid;

	 fcacheentry2xfsnode (parent_fid, &realfid,
d1293 1
a1293 1
	 ReleaseWriteLock (&dir_entry->lock);
a1295 9
     if (res.res == -1) {
	 ret = res.error;
	 if (ret == RXKADEXPIRED) {
	     cred_expire (ce);
	     cred_free (ce);
	     return xfs_message_remove (fd, h, size);
	 }
     } else
	 ret = 0;
d1322 8
a1329 1
     res = cm_rmdir(*parent_fid, h->name, ce);
a1331 2
	 char tmp[5];
	 VenusFid realfid;
d1339 1
a1339 1
	     ReleaseWriteLock (&dir_entry->lock);
d1343 4
a1346 1
	 res = conv_dir (dir_entry, tmp, sizeof(tmp), ce, 0); /* XXX */
d1348 1
a1348 1
	     ReleaseWriteLock (&dir_entry->lock);
d1352 1
a1352 1
	 strncpy((char *)&msg.cache_handle, tmp, 4);
d1355 2
a1356 6
	 if (dir_entry->flags.mountp)
	     realfid = dir_entry->realfid;
	 else
	     realfid = *parent_fid;

	 fcacheentry2xfsnode (parent_fid, &realfid,
d1363 1
a1363 1
	 ReleaseWriteLock (&dir_entry->lock);
a1365 9
     if (res.res == -1) {
	 ret = res.error;
	 if (ret == RXKADEXPIRED) {
	     cred_expire (ce);
	     cred_free (ce);
	     return xfs_message_rmdir (fd, h, size);
	 }
     } else
	 ret = 0;
d1397 9
a1405 3
     res = cm_rename(*old_parent_fid, h->old_name,
		     *new_parent_fid, h->new_name,
		     ce);
a1408 2
	 char tmp[5];
	 VenusFid realfid;
d1416 1
a1416 1
	     ReleaseWriteLock (&dir_entry->lock);
d1420 4
a1423 1
	 res = conv_dir (dir_entry, tmp, sizeof(tmp), ce, 0); /* XXX */
d1425 1
a1425 1
	     ReleaseWriteLock (&dir_entry->lock);
d1429 1
a1429 1
	 strncpy((char *)&msg1.cache_handle, tmp, 4);
d1432 2
a1433 6
	 if (dir_entry->flags.mountp)
	     realfid = dir_entry->realfid;
	 else
	     realfid = *old_parent_fid;

	 fcacheentry2xfsnode (old_parent_fid, &realfid,
d1440 1
a1440 1
	 ReleaseWriteLock (&dir_entry->lock);
d1447 1
a1447 1

d1450 1
a1450 1
	     ReleaseWriteLock (&dir_entry->lock);
d1453 5
a1457 2
	     
	 res = conv_dir (dir_entry, tmp, sizeof(tmp), ce, 0); /* XXX */
d1459 1
a1459 1
	     ReleaseWriteLock (&dir_entry->lock);
d1463 1
a1463 1
	 strncpy((char *)&msg2.cache_handle, tmp, 4);
d1465 3
a1467 7

	 if (dir_entry->flags.mountp)
	     realfid = dir_entry->realfid;
	 else
	     realfid = *new_parent_fid;

	 fcacheentry2xfsnode (new_parent_fid, &realfid,
d1474 1
a1474 1
	 ReleaseWriteLock (&dir_entry->lock);
a1476 9
     if (res.res == -1) {
	 ret = res.error;
	 if (ret == RXKADEXPIRED) {
	     cred_expire (ce);
	     cred_free (ce);
	     return xfs_message_rename (fd, h, size);
	 }
     } else
	 ret = 0;
d1495 2
d1499 1
d1504 10
a1513 10
     res = cm_close(*fid, h->flag, ce);
     if (res.res != 0)
	 arla_warn (ADEBMSG, res.error, "xfs_message_putdata: cm_close");

     if (res.res != 0 && res.error == RXKADEXPIRED) {
	 cred_expire (ce);
	 cred_free (ce);
	 return xfs_message_putdata (fd, h, size);
     }

a1528 1
     char tmp[5];
d1540 8
a1547 1
     res = cm_getattr (*fid, &status, &real_fid, ce, &ae);
d1559 1
a1559 1
		   ReleaseWriteLock (&entry->lock);
d1563 4
a1566 1
	       res = conv_dir (entry, tmp, sizeof(tmp), ce, h->tokens);
d1568 2
a1569 2
		    strncpy ((char *)&msg.cache_handle, tmp, 4); /* XXX */
		    msg.node.tokens = res.tokens;
d1571 1
a1571 1
	       ReleaseWriteLock(&entry->lock);
d1573 4
a1576 6
	       res = cm_open (*fid, ce, h->tokens);
	       if (res.res != -1) {
		    sprintf (tmp, "%04X", res.res);         /* XXX */
		    strncpy ((char *)&msg.cache_handle, tmp, 4);  /* XXX */
		    msg.node.tokens = res.tokens;
	       }
a1584 9
     if (res.res == -1) {
	 ret = res.error;
	 if (ret == RXKADEXPIRED) {
	     cred_expire (ce);
	     cred_free (ce);
	     return xfs_message_getdata (fd, h, size);
	 }
     } else
	 ret = 0;
d1590 1
a1590 1
				       ret,
d1604 21
a1624 1
     xfs_message_send (kernel_fd , (struct xfs_message_header *)&msg, 
d1628 12
d1662 1
a1662 1
	 entry->flags.datausedp = entry->flags.attrusedp = FALSE;
d1665 1
a1665 1
     ReleaseWriteLock (&entry->lock);
d1669 9
d1679 3
d1701 1
d1728 3
a1730 1
    error = getacl (fid, ce, &opaque);
d1732 1
a1732 5
    if (error == RXKADEXPIRED) {
	cred_expire (ce);
	cred_free (ce);
	return viocgetacl (fd, h, size);
    } else if (error != 0 && error != EACCES)
d1775 3
a1777 1
    error = setacl (fid, ce, &opaque);
d1779 1
a1779 5
    if (error == RXKADEXPIRED) {
	cred_expire (ce);
	cred_free (ce);
	return viocsetacl (fd, h, size);
    } else if (error != 0 && error != EACCES)
d1823 4
a1826 2
    error = getvolstat (fid, ce, &volstat, volumename,
			offlinemsg, motd);
d1830 1
a1830 5
    if (error == RXKADEXPIRED) {
	cred_expire (ce);
	cred_free (ce);
	return viocgetvolstat (fd, h, size);
    } else if (error != 0 && error != EACCES)
d1903 1
d1923 5
d1929 4
a1932 2
    error = setvolstat (fid, ce, &outvolstat, volumename,
			offlinemsg, motd);
d1934 1
a1934 5
    if (error == RXKADEXPIRED) {
	cred_expire (ce);
	cred_free (ce);
	return viocsetvolstat (fd, h, size);
    } else if (error != 0 && error != EACCES)
d1945 2
a1946 1
 * Get info for a mount point.
d1950 3
a1952 1
vioc_afs_stat_mt_pt(int fd, struct xfs_message_pioctl *h, u_int size)
d1954 4
a1957 5
    VenusFid fid;
    VenusFid res;
    CredCacheEntry *ce;
    FCacheEntry *e;
    fbuf the_fbuf;
a1958 2
    int error;
    int symlink_fd;
d1960 1
a1960 1
    if (!h->handle.a && !h->handle.b && !h->handle.c && !h->handle.d)
d1963 1
a1963 9
    fid.Cell = h->handle.a;
    fid.fid.Volume = h->handle.b;
    fid.fid.Vnode = h->handle.c;
    fid.fid.Unique = h->handle.d;

    ce = cred_get (fid.Cell, h->cred.pag, CRED_ANY);
    assert (ce != NULL);

    error = adir_lookup(fid, h->msg, &res, ce);
a1964 1
	cred_free(ce);
d1967 2
a1968 1
    error = fcache_get(&e, res, ce);
a1969 1
	cred_free(ce);
d1972 2
a1973 1
    error = fcache_get_attr (e, ce);
d1975 1
a1975 2
	ReleaseWriteLock (&e->lock);
	cred_free(ce);
d1978 2
a1979 3
    if (e->status.FileType != TYPE_LINK) { /* Is not a mount point */
	ReleaseWriteLock (&e->lock);
	cred_free(ce);
d1982 1
a1982 1
    error = fcache_get_data (e, ce);
d1984 1
a1984 2
	ReleaseWriteLock (&e->lock);
	cred_free(ce);
d1987 3
a1989 4
    symlink_fd = fcache_open_file (e, O_RDONLY, 0);
    if (symlink_fd < 0) {
	ReleaseWriteLock (&e->lock);
	cred_free(ce);
d1992 2
a1993 1
    error = fbuf_create (&the_fbuf, symlink_fd, e->status.Length, FBUF_READ);
d1995 1
a1995 2
	ReleaseWriteLock (&e->lock);
	cred_free(ce);
d1998 1
a1998 1
    buf = (char *)(the_fbuf.buf);
d2000 2
a2001 3
	ReleaseWriteLock (&e->lock);
	fbuf_end (&the_fbuf);
	cred_free (ce);
d2005 38
d2045 21
d2067 9
a2075 2
    ReleaseWriteLock (&e->lock);
    fbuf_end (&the_fbuf);
d2077 8
d2086 1
a2086 1
    return 0;
d2117 1
a2117 1
	ReleaseWriteLock (&e->lock);
d2128 1
a2128 1
    ReleaseWriteLock (&e->lock);
d2134 4
d2139 1
a2139 1
viocgetcell(int fd, struct xfs_message_pioctl *h, u_int size)
d2147 2
d2153 1
a2153 1
	return EDOM;
d2155 5
d2161 1
a2161 3
    cellname_len = strlen(cellname) + 1;
    if (cellname_len > MAXPATHLEN)
	cellname_len = MAXPATHLEN;
d2163 4
a2166 5
    outsize = 8 * sizeof(int32_t) + cellname_len;
    for (i = 0; i < 8; i++) {
	u_long addr = cell_listdbserver(index, i);
	if (addr == 0)
	    break;
d2176 118
d2315 1
a2315 1
    ct.ViceId = h->cred.pag;
d2394 67
d2463 4
d2476 1
a2476 1
    fid.Cell = h->handle.a;
d2478 1
a2478 1
    fid.fid.Vnode = h->handle.c;
d2521 11
d2538 7
d2558 1
a2558 1
static void
d2571 5
a2575 5
	xfs_send_message_wakeup_data (fd,
				      h->header.sequence_num,
				      0,
				      &n,
				      sizeof(n));
d2577 1
a2577 1
	xfs_send_message_wakeup (fd, h->header.sequence_num, EINVAL);
d2683 229
a2913 2
    int32_t sizeof_x;
    char *t;
a2915 1
    t = h->msg ;
d2918 2
a2919 51
    case VIOCSETTOK: {
	struct ClearToken ct;
	CREDENTIALS c;
	long cell;

	/* someone probed us */
	if (h->insize == 0) {
	    error = EINVAL ;
	    break;
	}

	/* Get ticket_st */
	memcpy(&sizeof_x, t, sizeof(sizeof_x)) ;
	c.ticket_st.length = sizeof_x ;
	arla_warnx (ADEBMSG, "ticket_st has size %d", sizeof_x);
	t += sizeof(sizeof_x) ;

	memcpy(c.ticket_st.dat, t, sizeof_x) ;
	t += sizeof_x ;

	/* Get ClearToken */
	memcpy(&sizeof_x, t, sizeof(sizeof_x)) ;
	t += sizeof(sizeof_x) ;

	memcpy(&ct, t, sizeof_x) ;
	t += sizeof_x ;

	/* Get primary cell ? */
	memcpy(&sizeof_x, t, sizeof(sizeof_x)) ;
	t += sizeof(sizeof_x) ;

	/* Get Cellname */ 
	strncpy(c.realm, t, REALM_SZ) ;
	c.realm[REALM_SZ-1] = '\0' ;


	/* Make this a sane world again */
	c.kvno = ct.AuthHandle;
	memcpy (c.session, ct.HandShakeKey, sizeof(c.session));
	c.issue_date = ct.BeginTimestamp - 1;
	
	cell = cell_name2num(strlwr(c.realm));

	/* XXX fix ct.ViceId */
	conn_clearcred (cell, h->cred.pag, 2);
	fcache_purge_cred(h->cred.pag, cell);
	cred_add (h->cred.pag, CRED_KRB4, 2, cell, ct.EndTimestamp,
		  &c, sizeof(c));
	

	error = 0 ;
a2920 1
    }
d2924 3
a2926 8
    case VIOCUNLOG: {
	pag_t cred = h->cred.pag ;

	cred_remove(cred) ;
	fcache_purge_cred(cred, -1);
	error = 0;
	break ;
    }
d2938 1
a2938 3
	error = xfs_send_message_wakeup_data(fd, h->header.sequence_num, 0,
					     &h->handle, sizeof(VenusFid));
	break;
d2954 3
d2964 7
a2970 2
	error = viocgetcell(fd, h, size);
	break;
d2972 1
a2972 72
	if (h->cred.uid != 0) {
	    error = EACCES;
	    break ;
	}
	    
	conn_status (stderr);
	volcache_status (stderr);
	cred_status (stderr);
	fcache_status (stderr);
	rx_PrintStats(stderr);
	error = 0 ;
	break;
    case VIOC_AFS_SYSNAME: {
	char str[SYSNAMEMAXLEN+sizeof(int32_t)];

	error = 0 ;

	if (*((int32_t *)t)) {
	    t += sizeof(int32_t);
	    arla_warnx (ADEBMSG, "VIOC_AFS_SYSNAME: setting sysname: %s", t);
	    memcpy(arlasysname, t, h->insize);
	    arlasysname[h->insize] = '\0';
	    xfs_send_message_wakeup_data(fd, h->header.sequence_num, error,
					 str, 0);
	} else {
	    t = str;
	    sizeof_x = strlen(arlasysname);
	    memcpy(t, &sizeof_x, sizeof(sizeof_x));
	    t += sizeof(sizeof_x);
	    h->outsize = sizeof_x;
	    strncpy(t, arlasysname, SYSNAMEMAXLEN);
	    xfs_send_message_wakeup_data(fd, h->header.sequence_num, error,
					 str, sizeof_x + sizeof(sizeof_x));
	}
	return 0;
    }

    case VIOC_FILE_CELL_NAME: {
	char *cellname ;

	error = 0 ;
	cellname = (char *) cell_num2name(h->handle.a);

	if (cellname) 
	    xfs_send_message_wakeup_data(fd, h->header.sequence_num, error,
					 cellname, strlen(cellname)+1);
	else 
	    xfs_send_message_wakeup_data(fd, h->header.sequence_num, EINVAL,
					 NULL, 0);
	return 0;
    }
    case VIOC_GET_WS_CELL: {
	char *cellname;

	cellname = (char*) cell_getthiscell();
	xfs_send_message_wakeup_data(fd, h->header.sequence_num, 0 /*error*/,
				     cellname, strlen(cellname));

	return 0;
    }
    case VIOCSETCACHESIZE: {
	u_int32_t *s = (u_int32_t *)t;

	if (h->cred.uid != 0) {
	    error = EPERM;
	    break ;
	}
	
	if (h->insize >= sizeof(int32_t) * 4) 
	    error = fcache_reinit(s[0], s[1], s[2], s[3]);
	else
	    error = fcache_reinit(*s/2, *s, *s*500, *s*1000);
d2974 13
a2986 1
    }
d2988 1
a2988 2
	getrxkcrypt(fd, h, size);
	return 0;
d2994 7
@


1.1.1.1
log
@Initial version of Arla, a free implementation of an AFS cache-manager.
(second try, hopefully into the correct repository this time)
@
text
@@


1.1.1.2
log
@Import of arla-0.35.7
@
text
@d1 1
d3 1
a3 1
 * Copyright (c) 1995-2001 Kungliga Tekniska Högskolan
d18 6
a23 1
 * 3. Neither the name of the Institute nor the names of its contributors
d41 1
a41 1
RCSID("$KTH: messages.c,v 1.231.2.12 2001/10/19 04:25:52 ahltorp Exp $");
d48 1
a48 1
#include <kafs.h>
d52 2
a53 3
/* XXX */
int Log_is_open;
DARLA_file log_data;
d100 2
d103 1
a103 1
xfs_message_function rcvfuncs[] = {
d127 1
a127 4
NULL,	                                        /* wakeup_data */
NULL,						/* updatefid */
NULL,						/* advlock */
NULL						/* gc nodes */
d130 1
d132 1
a132 3
/*
 * Return 0 if ``fid1'' eq ``fid2''.
 */
d134 1
a134 10
int
VenusFid_cmp (const VenusFid *fid1, const VenusFid *fid2)
{
    if (fid1->Cell == fid2->Cell &&
	fid1->fid.Volume == fid2->fid.Volume &&
	fid1->fid.Vnode == fid2->fid.Vnode &&
	fid1->fid.Unique == fid2->fid.Unique)
	return 0;
    return 1;
}
d136 1
d138 35
a172 3
/*
 *
 */
d175 1
a175 1
afsfid2inode (const VenusFid *fid)
d177 1
a177 1
    return ((fid->fid.Volume & 0x7FFF) << 16 | (fid->fid.Vnode & 0xFFFFFFFF));
d186 1
a186 1
		    const VenusFid *fid,
a193 1
	       XA_SET_NLINK(attr, status->LinkCount);
a197 1
	       XA_SET_NLINK(attr, status->LinkCount);
a201 1
	       XA_SET_NLINK(attr, status->LinkCount);
d207 1
d212 3
a214 3
     XA_SET_ATIME(attr, status->ClientModTime);
     XA_SET_MTIME(attr, status->ClientModTime);
     XA_SET_CTIME(attr, status->ClientModTime);
d249 3
a251 3
void
fcacheentry2xfsnode (const VenusFid *fid,
		     const VenusFid *statfid, 
d254 1
a254 2
                     AccessEntry *ae,
		     int flags)
d258 1
d260 8
a267 12
    if (flags & FCACHE2XFSNODE_ATTR)
	afsstatus2xfs_attr (status, statfid, &node->attr);
    if (flags & FCACHE2XFSNODE_RIGHT) {
	node->anonrights = afsrights2xfsrights(status->AnonymousAccess,
					       status->FileType,
					       status->UnixModeBits);
	for (i = 0; i < NACCESS; i++) {
	    node->id[i] = ae[i].cred;
	    node->rights[i] = afsrights2xfsrights(ae[i].access,
						  status->FileType,
						  status->UnixModeBits);
	}
d271 1
a271 5
/*
 * convert `xa' into `storestatus'
 */

int
d293 1
a293 1
    storestatus->Mask = mask;
d296 1
a296 1
    storestatus->SegSize = 0;
a300 2
 * Return true iff we should retry the operation.
 * Also replace `ce' with anonymous creds in case it has expired.
a301 1
 * There must not be passed in any NULL pointers.
d304 92
d397 1
a397 1
try_again (int *ret, CredCacheEntry **ce, xfs_cred *cred, const VenusFid *fid)
d399 6
a404 44
    switch (*ret) {
#ifdef KERBEROS
    case RXKADEXPIRED : 
    case RXKADUNKNOWNKEY: {
	int32_t cell = (*ce)->cell;

	conn_clearcred (CONN_CS_CRED|CONN_CS_SECIDX, 0, cred->pag, 2);
	cred_expire (*ce);
	cred_free (*ce);
	*ce = cred_get (cell, cred->pag, CRED_ANY);
	assert (*ce != NULL);
	return TRUE;
    }
    case RXKADSEALEDINCON :
	arla_warnx_with_fid (ADEBWARN, fid,
			     "seal error");
	*ret = EINVAL;
	return FALSE;
#endif	 
    case ARLA_VSALVAGE :
	*ret = EIO;
	return FALSE;
    case ARLA_VNOVNODE :
	*ret = ENOENT;
	return FALSE;
    case ARLA_VMOVED :
    case ARLA_VNOVOL :
	if (fid && !volcache_reliable (fid->fid.Volume, fid->Cell)) {
	    return TRUE;
	} else {
	    *ret = ENOENT;
	    return FALSE;
	}
    case ARLA_VOFFLINE :
	*ret = ENETDOWN;
	return FALSE;
    case ARLA_VDISKFULL :
	*ret = ENOSPC;
	return FALSE;
    case ARLA_VOVERQUOTA:
#ifdef EDQUOT
	*ret = EDQUOT;
#else
	*ret = ENOSPC;
d406 13
a418 17
	return FALSE;
    case ARLA_VBUSY :
	arla_warnx_with_fid (ADEBWARN, fid,
			     "Waiting for busy volume...");
	IOMGR_Sleep (afs_BusyWaitPeriod);
	return TRUE;
    case ARLA_VRESTARTING:
	arla_warnx_with_fid (ADEBWARN, fid,
			     "Waiting for fileserver to restart...");
	IOMGR_Sleep (afs_BusyWaitPeriod);
	return TRUE;
    case ARLA_VIO :
	*ret = EIO;
	return FALSE;
    default :
	return FALSE;
    }
d422 1
a422 1
 * Fetch data and retry if failing
d426 62
a487 2
message_get_data (FCacheEntry **entry, VenusFid *fid, 
		  struct xfs_cred *cred, CredCacheEntry **ce)
d489 1
d491 4
a494 3
    do {
	ret = fcache_get_data (entry, fid, ce);
    } while (try_again (&ret, ce, cred, fid));
d498 21
a518 3
/*
 *
 */
d528 1
a528 1
     Result res;
a532 1
     int32_t cell_id = cell_name2num(cell_getthiscell());
d534 1
a534 1
     ce = cred_get (cell_id, h->cred.pag, CRED_ANY);
a535 2
     do {
	 ret = getroot (&root_fid, ce);
d537 12
a548 13
	 if (ret == 0) {
	     res = cm_getattr(root_fid, &status, &real_fid, ce, &ae);
	     if (res.res)
		 ret = res.error;
	     else
		 ret = res.res;
	 }
     } while (try_again (&ret, &ce, &h->cred, &root_fid));

     if (ret == 0) {
	 fcacheentry2xfsnode (&root_fid, &real_fid,
			      &status, &msg.node, ae,
			      FCACHE2XFSNODE_ALL);
d550 9
a558 4
	 msg.node.tokens = res.tokens & ~XFS_DATA_MASK;
	 msg.header.opcode = XFS_MSG_INSTALLROOT;
	 h0 = (struct xfs_message_header *)&msg;
	 h0_len = sizeof(msg);
d567 1
a567 1
     return 0;
a582 8
     int ret;
     const VenusFid *report_fid = NULL;


     arla_warnx (ADEBMSG, "getnode (%ld.%lu.%lu.%lu) \"%s\"",
		 (long)dirfid->Cell, (unsigned long)dirfid->fid.Volume,
		 (unsigned long)dirfid->fid.Vnode,
		 (unsigned long)dirfid->fid.Unique, h->name);
d587 16
a602 21
     report_fid = dirfid;
     do {
  	 res = cm_lookup (dirfid, h->name, &fid, &ce, TRUE);
	 if (res.res == 0) {
	     res = cm_getattr (fid, &status, &real_fid, ce, &ae);
	     report_fid = &fid;
	 }

	 if (res.res)
	     ret = res.error;
	 else
	     ret = res.res;
     } while (try_again (&ret, &ce, &h->cred, report_fid));

     if (ret == 0) {
	 fcacheentry2xfsnode (&fid, &real_fid, &status, &msg.node, ae,
			      FCACHE2XFSNODE_ALL);

	 msg.node.tokens = res.tokens & ~XFS_DATA_MASK;
	 msg.parent_handle = h->parent_handle;
	 strlcpy (msg.name, h->name, sizeof(msg.name));
d604 4
a607 3
	 msg.header.opcode = XFS_MSG_INSTALLNODE;
	 h0 = (struct xfs_message_header *)&msg;
	 h0_len = sizeof(msg);
d613 1
a613 1
				       ret,
a630 1
     int ret;
d633 1
a633 4
     arla_warnx (ADEBMSG, "getattr (%ld.%lu.%lu.%lu)",
		 (long)fid->Cell, (unsigned long)fid->fid.Volume,
		 (unsigned long)fid->fid.Vnode,
		 (unsigned long)fid->fid.Unique);
d637 4
a640 11
     do {
	 res = cm_getattr (*fid, &status, &real_fid, ce, &ae);
	 if (res.res)
	     ret = res.error;
	 else
	     ret = res.res;
     } while (try_again (&ret, &ce, &h->cred, fid));

     if (ret == 0) {
	 fcacheentry2xfsnode (fid, &real_fid, &status, &msg.node, ae,
			      FCACHE2XFSNODE_ALL);
d642 1
a642 1
	 msg.node.tokens = res.tokens;
d648 6
d657 1
a657 1
				       ret,
d664 1
a667 1
     struct xfs_message_installattr msg;
a669 1
     AFSFetchStatus fetch_status;
a671 8
     AccessEntry *ae;
     VenusFid real_fid;
     struct xfs_message_header *h0 = NULL;
     size_t h0_len = 0;
     int ret;
     struct vcache log_cache;
     FCacheEntry *fce;
     int log_err;
d674 1
a674 5
     arla_warnx (ADEBMSG, "putattr (%ld.%lu.%lu.%lu)",
		 (long)fid->Cell, (unsigned long)fid->fid.Volume,
		 (unsigned long)fid->fid.Vnode,
		 (unsigned long)fid->fid.Unique);
     xfs_attr2afsstorestatus(&h->attr, &status);
d678 12
a689 46
     if (connected_mode != CONNECTED) {
	 ret = fcache_find (&fce, *fid);
	 ReleaseWriteLock (&fce->lock);

	 log_cache.fid = *fid;
	 log_cache.DataVersion  = fce->status.DataVersion;
	 log_cache.cred = h->cred;
     }

     do {
	 res.res = 0;
	 if (XA_VALID_SIZE(&h->attr))
	     res = cm_ftruncate (*fid, h->attr.xa_size, ce);

	 if (res.res == 0)
	     res = cm_setattr(*fid, &status, ce);

	 if (res.res)
	     ret = res.error;
	 else
	     ret = res.res;
     } while (try_again (&ret, &ce, &h->cred, fid));

     if (ret == 0) {
	 do {
	     res = cm_getattr (*fid, &fetch_status, &real_fid, ce, &ae);
	     if (res.res)
		 ret = res.error;
	     else
		 ret = res.res;
	 } while (try_again (&ret, &ce, &h->cred, fid));

	 if (ret == 0) {
	     fcacheentry2xfsnode (fid, &real_fid,
				  &fetch_status, &msg.node, ae,
				  FCACHE2XFSNODE_ALL);
	 
	     msg.node.tokens  = res.tokens;
	     msg.header.opcode = XFS_MSG_INSTALLATTR;
	     h0 = (struct xfs_message_header *)&msg;
	     h0_len = sizeof(msg);
	 }
     }

     if (connected_mode != CONNECTED && ret == 0) {
	 log_err = log_dis_setattr (&log_cache, &(h->attr));
d693 2
a694 5
     xfs_send_message_wakeup_multiple (fd,
				       h->header.sequence_num, 
				       ret,
				       h0, h0_len,
				       NULL, 0);
a715 3
     FCacheEntry *dir_entry   = NULL;
     FCacheEntry *child_entry = NULL;
     fcache_cache_handle cache_handle;
a717 14
     arla_warnx (ADEBMSG, "create (%ld.%lu.%lu.%lu) \"%s\"",
		 (long)parent_fid->Cell,
		 (unsigned long)parent_fid->fid.Volume,
		 (unsigned long)parent_fid->fid.Vnode,
		 (unsigned long)parent_fid->fid.Unique, h->name);

     xfs_attr2afsstorestatus(&h->attr, &store_status);
     if (connected_mode != CONNECTED) {
	 if (!(store_status.Mask & SS_OWNER)) {
	     store_status.Owner = h->cred.uid;
	     store_status.Mask |= SS_OWNER;
	 }
	 if (!(store_status.Mask & SS_MODTIME)) {
	     struct timeval now;
a718 6
	     gettimeofday (&now, NULL);

	     store_status.ClientModTime = now.tv_sec;
	     store_status.Mask |= SS_MODTIME;
	 }
     }
d722 3
a724 10
     do {
	 res = cm_create(parent_fid, h->name, &store_status,
			 &child_fid, &fetch_status, &ce);

	 if (res.res)
	     ret = res.error;
	 else
	     ret = res.res;
     } while (try_again (&ret, &ce, &h->cred, parent_fid));

d726 4
d731 1
a731 1
	 ret = message_get_data (&dir_entry, parent_fid, &h->cred, &ce);
d734 6
d741 1
a741 4
	 res = conv_dir (dir_entry, ce, 0,
			 &cache_handle,
			 msg1.cache_name,
			 sizeof(msg1.cache_name));
d743 1
d747 2
a748 4
	 msg1.cache_handle = cache_handle.xfs_handle;
	 msg1.flag = 0;
	 if (cache_handle.valid)
	     msg1.flag |= XFS_ID_HANDLE_VALID;
d750 4
a753 1
	 msg1.node.tokens = res.tokens;
d755 1
a755 2
	 fcacheentry2xfsnode (parent_fid,
			      fcache_realfid(dir_entry),
d758 6
a763 2
			      dir_entry->acccache,
			      FCACHE2XFSNODE_ALL);
d765 3
a767 2
	 ret = message_get_data (&child_entry, &child_fid, &h->cred, &ce);
	 if (ret)
d769 1
d771 2
a772 14
	 msg3.cache_handle = child_entry->handle.xfs_handle;
	 fcache_file_name (child_entry,
			   msg3.cache_name, sizeof(msg3.cache_name));
	 msg3.flag = 0;
	 if (cache_handle.valid)
	     msg3.flag |= XFS_ID_HANDLE_VALID;

	 child_entry->flags.kernelp = TRUE;
	 child_entry->flags.attrusedp = TRUE;
	 child_entry->flags.datausedp = TRUE;
#if 0
	 assert(dir_entry->flags.attrusedp);
#endif
	 dir_entry->flags.datausedp = TRUE;
d779 1
a779 2
			      &fetch_status, &msg2.node, dir_entry->acccache,
			      FCACHE2XFSNODE_ALL);
d781 1
a781 3
	 msg2.node.tokens   = XFS_ATTR_R 
	     | XFS_OPEN_NW | XFS_OPEN_NR
	     | XFS_DATA_R | XFS_DATA_W;
d783 1
a783 1
	 strlcpy (msg2.name, h->name, sizeof(msg2.name));
d791 1
a791 1

d796 9
a804 13
     if (connected_mode != CONNECTED && res.res == 0) {
	 struct vcache log_ent_parent, log_ent_child;

	 log_ent_parent.fid = *parent_fid;
	 log_ent_parent.DataVersion = dir_entry->status.DataVersion;
	 log_ent_parent.cred = h->cred;

	 log_ent_child.fid = child_fid;
	 log_ent_child.DataVersion = 1;

	 log_dis_create (&log_ent_parent, &log_ent_child, h->name);
     }

a805 4
     if (dir_entry)
	 fcache_release(dir_entry);
     if (child_entry)
	 fcache_release(child_entry);
a828 4
     struct xfs_message_installdata msg3;
     FCacheEntry *dir_entry = NULL;
     FCacheEntry *child_entry = NULL;

a832 3
     struct xfs_message_header *h2 = NULL;
     size_t h2_len = 0;
     fcache_cache_handle cache_handle;
a833 7
     struct vcache log_ent_parent, log_ent_child;
     FCacheEntry parent_entry;
     AFSStoreStatus log_store_status;

#if 0
     parent_fid = fid_translate((VenusFid *)&h->parent_handle);
#else
a834 5
#endif
     arla_warnx (ADEBMSG, "mkdir (%ld.%lu.%lu.%lu) \"%s\"",
		 (long)parent_fid->Cell, (unsigned long)parent_fid->fid.Volume,
		 (unsigned long)parent_fid->fid.Vnode,
		 (unsigned long)parent_fid->fid.Unique, h->name);
d840 2
a841 24
     if (connected_mode != CONNECTED) {
	 if (!(store_status.Mask & SS_OWNER)) {
	     store_status.Owner = h->cred.uid;
	     store_status.Mask |= SS_OWNER;
	 }
	 if (!(store_status.Mask & SS_MODTIME)) {
	     struct timeval now;

	     gettimeofday (&now, NULL);

	     store_status.ClientModTime = now.tv_sec;
	     store_status.Mask |= SS_MODTIME;
	 }
     }

     do {
	 res = cm_mkdir(parent_fid, h->name, &store_status,
			&child_fid, &fetch_status, &ce);
	 if (res.res)
	     ret = res.error;
	 else
	     ret = res.res;
     } while(try_again (&ret, &ce, &h->cred, parent_fid));

d843 3
d847 1
a847 1
	 ret = message_get_data (&dir_entry, parent_fid, &h->cred, &ce);
d851 7
a857 4
	 res = conv_dir (dir_entry, ce, 0,
			 &cache_handle,
			 msg1.cache_name,
			 sizeof(msg1.cache_name));
d859 1
d863 1
a863 4
	 msg1.cache_handle = cache_handle.xfs_handle;
	 msg1.flag = 0;
	 if (cache_handle.valid)
	     msg1.flag |= XFS_ID_HANDLE_VALID;
d866 6
a871 2
	 fcacheentry2xfsnode (parent_fid,
			      fcache_realfid(dir_entry),
d873 1
a873 2
			      dir_entry->acccache,
			      FCACHE2XFSNODE_ALL);
d878 1
a878 26

	 ret = message_get_data (&child_entry, &child_fid, &h->cred, &ce);
	 if (ret)
	     goto out;

	 res = conv_dir (child_entry, ce, 0,
			 &cache_handle,
			 msg3.cache_name,
			 sizeof(msg3.cache_name));
	 if (res.res == -1) {
	     ret = res.error;
	     goto out;
	 }
	 msg3.cache_handle = cache_handle.xfs_handle;
	 msg3.flag = 0;
	 if (cache_handle.valid)
	     msg3.flag |= XFS_ID_HANDLE_VALID;

	 child_entry->flags.attrusedp = TRUE;
	 child_entry->flags.datausedp = TRUE;
#if 0
	 assert(dir_entry->flags.attrusedp);
#endif
	 dir_entry->flags.datausedp = TRUE;

	 msg2.node.tokens = res.tokens;
d881 2
a882 3
			      &child_entry->status, &msg2.node,
			      dir_entry->acccache,
			      FCACHE2XFSNODE_ALL);
d884 1
d886 1
a886 1
	 strlcpy (msg2.name, h->name, sizeof(msg2.name));
a890 18

	 msg3.header.opcode = XFS_MSG_INSTALLDATA;
	 msg3.node = msg2.node;
	 h2 = (struct xfs_message_header *)&msg3;
	 h2_len = sizeof(msg3);
	 if (connected_mode != CONNECTED)
	     parent_entry = *dir_entry;
     }

     if (connected_mode != CONNECTED) {
	 log_ent_parent.fid = *parent_fid;
	 log_ent_parent.DataVersion = parent_entry.status.DataVersion;
	 log_ent_parent.cred = h->cred;
	 log_store_status = store_status;
	 log_ent_child.fid = child_fid;
	 log_ent_child.DataVersion = 1;
	 log_dis_mkdir (&log_ent_parent, &log_ent_child, &log_store_status,
			h->name);
d893 9
a902 4
     if (child_entry) 
	 fcache_release(child_entry);
     if (dir_entry)
	 fcache_release(dir_entry);
a908 1
				       h2, h2_len,
a927 1
     fcache_cache_handle cache_handle;
a930 9
     arla_warnx (ADEBMSG, "link (%ld.%lu.%lu.%lu) (%ld.%lu.%lu.%lu) \"%s\"",
		 (long)parent_fid->Cell, (unsigned long)parent_fid->fid.Volume,
		 (unsigned long)parent_fid->fid.Vnode,
		 (unsigned long)parent_fid->fid.Unique,
		 (long)existing_fid->Cell,
		 (unsigned long)existing_fid->fid.Volume,
		 (unsigned long)existing_fid->fid.Vnode,
		 (unsigned long)existing_fid->fid.Unique,
		 h->name);
d935 2
a936 9
     do {
	 res = cm_link (parent_fid, h->name, *existing_fid,
			&fetch_status, &ce);
	 if (res.res)
	     ret = res.error;
	 else
	     ret = res.res;
     } while (try_again (&ret, &ce, &h->cred, parent_fid));

d939 2
d942 1
a942 1
	 ret = message_get_data (&dir_entry, parent_fid, &h->cred, &ce);
d946 7
a952 4
	 res = conv_dir (dir_entry, ce, 0,
			 &cache_handle,
			 msg1.cache_name,
			 sizeof(msg1.cache_name));
d954 1
a954 1
	     fcache_release(dir_entry);
d958 1
a958 4
	 msg1.cache_handle = cache_handle.xfs_handle;
	 msg1.flag = 0;
	 if (cache_handle.valid)
	     msg1.flag |= XFS_ID_HANDLE_VALID;
a959 4
#if 0
	 assert(dir_entry->flags.attrusedp);
#endif
	 dir_entry->flags.datausedp = TRUE;
d961 6
a966 2
	 fcacheentry2xfsnode (parent_fid,
			      fcache_realfid(dir_entry),
d968 2
a969 3
			      dir_entry->acccache,
			      FCACHE2XFSNODE_ALL);

d973 1
d977 2
a978 4
			      dir_entry->acccache,
			      FCACHE2XFSNODE_ALL);
	 fcache_release(dir_entry);

d981 1
a981 1
	 strlcpy (msg2.name, h->name, sizeof(msg2.name));
d988 9
d1012 1
a1012 1
     VenusFid *parent_fid, child_fid, real_fid;
a1023 1
     fcache_cache_handle cache_handle;
a1025 4
     arla_warnx (ADEBMSG, "symlink (%ld.%lu.%lu.%lu) \"%s\"",
		 (long)parent_fid->Cell, (unsigned long)parent_fid->fid.Volume,
		 (unsigned long)parent_fid->fid.Vnode,
		 (unsigned long)parent_fid->fid.Unique, h->name);
d1031 3
a1033 13

     do {
	 res = cm_symlink(parent_fid, h->name, &store_status,
			  &child_fid, &real_fid,
			  &fetch_status,
			  h->contents, &ce);
	 ret = res.error;
     } while (try_again (&ret, &ce, &h->cred, parent_fid));
     
     cred_free (ce);
     ce = cred_get (parent_fid->Cell, h->cred.pag, CRED_ANY);
     assert (ce != NULL);

d1036 2
d1039 1
a1039 1
	 ret = message_get_data (&dir_entry, parent_fid, &h->cred, &ce);
d1043 7
a1049 4
	 res = conv_dir (dir_entry, ce, 0,
			 &cache_handle,
			 msg1.cache_name,
			 sizeof(msg1.cache_name));
d1051 1
a1051 1
	     fcache_release(dir_entry);
d1055 1
a1055 4
	 msg1.cache_handle = cache_handle.xfs_handle;
	 msg1.flag = 0;
	 if (cache_handle.valid)
	     msg1.flag |= XFS_ID_HANDLE_VALID;
a1056 4
#if 0
	 assert(dir_entry->flags.attrusedp);
#endif
	 dir_entry->flags.datausedp = TRUE;
d1058 6
a1063 2
	 fcacheentry2xfsnode (parent_fid,
			      fcache_realfid(dir_entry),
d1065 1
a1065 2
			      dir_entry->acccache,
			      FCACHE2XFSNODE_ALL);
d1070 1
d1072 1
a1072 1
	 fcacheentry2xfsnode (&child_fid, &real_fid,
d1074 1
a1074 3
			      dir_entry->acccache,
			      FCACHE2XFSNODE_ALL);
	 fcache_release(dir_entry);
d1078 1
a1078 1
	 strlcpy (msg2.name, h->name, sizeof(msg2.name));
d1085 9
a1104 5
/* 
 * Handle the XFS remove message in `h', that is, remove name
 * `h->name' in directory `h->parent' with the creds from `h->cred'.
 */

a1108 1
     VenusFid fid;
d1112 1
a1112 2
     struct xfs_message_installdata msg1;
     struct xfs_message_installattr msg2;
a1114 7
     struct xfs_message_header *h1 = NULL;
     size_t h1_len = 0;
     FCacheEntry *limbo_entry = NULL;
     unsigned link_count;
     FCacheEntry *dir_entry = NULL;
     AFSFetchStatus limbo_status;
     fcache_cache_handle cache_handle;
a1116 4
     arla_warnx (ADEBMSG, "remove (%ld.%lu.%lu.%lu) \"%s\"",
		 (long)parent_fid->Cell, (unsigned long)parent_fid->fid.Volume,
		 (unsigned long)parent_fid->fid.Vnode,
		 (unsigned long)parent_fid->fid.Unique, h->name);
d1121 5
a1125 7
     do {
	 res = cm_lookup (parent_fid, h->name, &fid, &ce, FALSE);
	 if (res.res)
	     ret = res.error;
	 else
	     ret = res.res;
     } while (try_again (&ret, &ce, &h->cred, parent_fid));
d1127 3
a1129 2
     if (ret)
	 goto out;
d1131 9
a1139 24
     /*
      * Fetch the linkcount of the to be removed node
      */

     ret = fcache_get (&limbo_entry, fid, ce);
     if (ret)
	 goto out;

     ret = fcache_verify_attr (limbo_entry, NULL, NULL, ce);
     if (ret)
	 goto out;
     limbo_status = limbo_entry->status;
     link_count   = limbo_status.LinkCount;

     fcache_release (limbo_entry);
     limbo_entry = NULL;

     /*
      * Do the actual work
      */

     do {
	 res = cm_remove(parent_fid, h->name, &ce);
	 if (res.res)
a1140 8
	 else
	     ret = res.res;
     } while (try_again (&ret, &ce, &h->cred, parent_fid));

     if (ret == 0) {

	 ret = message_get_data (&dir_entry, parent_fid, &h->cred, &ce);
	 if (ret)
d1142 3
d1146 4
a1149 19
	 if (!dir_entry->flags.extradirp
	     || dir_remove_name (dir_entry, h->name,
				 &cache_handle,
				 msg1.cache_name,
				 sizeof(msg1.cache_name))) {
	     res = conv_dir (dir_entry, ce, 0,
			     &cache_handle,
			     msg1.cache_name,
			     sizeof(msg1.cache_name));
	     if (res.res == -1) {
		 ret = res.error;
		 goto out;
	     }
	 }
	 msg1.cache_handle = cache_handle.xfs_handle;
	 msg1.flag = XFS_ID_INVALID_DNLC;
	 if (cache_handle.valid)
	     msg1.flag |= XFS_ID_HANDLE_VALID;
	 msg1.node.tokens = res.tokens | XFS_DATA_R;
d1151 3
a1153 5
	 fcacheentry2xfsnode (parent_fid,
			      fcache_realfid(dir_entry),
			      &dir_entry->status, &msg1.node,
			      dir_entry->acccache,
			      FCACHE2XFSNODE_ALL);
d1155 5
a1159 3
	 msg1.header.opcode = XFS_MSG_INSTALLDATA;
	 h0 = (struct xfs_message_header *)&msg1;
	 h0_len = sizeof(msg1);
d1161 8
a1168 26
	 /*
	  * Set datausedp since we push data to kernel in out:
	  */

#if 0
	 assert(dir_entry->flags.attrusedp);
#endif
	 dir_entry->flags.datausedp = TRUE;

	 /*
	  * Make sure that if the removed node is in the
	  * kernel it has the right linkcount since some
	  * might hold a reference to it.
	  */

	 ret = fcache_get (&limbo_entry, fid, ce);
	 if (ret)
	     goto out;

	 /*
	  * Now insert the limbo entry to get right linkcount
	  */

	 ret = fcache_verify_attr (limbo_entry, dir_entry, NULL, ce);
	 if (ret == 0)
	     limbo_status = limbo_entry->status;
a1169 24
	 
	 /* Only a silly rename when this is the last file */
	 if (link_count == 1)
	     limbo_entry->flags.silly = TRUE;

	 msg2.header.opcode = XFS_MSG_INSTALLATTR;
	 msg2.node.tokens   = limbo_entry->tokens;
	 if (!limbo_entry->flags.datausedp)
	     msg2.node.tokens &= ~XFS_DATA_MASK;

	 if (link_count == 1 && limbo_status.LinkCount == 1)
	     --limbo_status.LinkCount;
	 fcacheentry2xfsnode (&fid,
			      fcache_realfid(limbo_entry),
			      &limbo_status,
			      &msg2.node,
			      limbo_entry->acccache,
			      FCACHE2XFSNODE_ALL);
	 
	 h1 = (struct xfs_message_header *)&msg2;
	 h1_len = sizeof(msg2);
	 
     }

a1170 4
     if (dir_entry)
	 fcache_release(dir_entry);
     if (limbo_entry)
	 fcache_release (limbo_entry);
a1175 1
				       h1, h1_len,
d1183 1
a1183 1
     VenusFid *parent_fid, fid;
d1187 1
a1187 1
     struct xfs_message_installdata msg0;
a1189 7
     struct xfs_message_installattr msg1;
     struct xfs_message_header *h1 = NULL;
     size_t h1_len = 0;
     FCacheEntry *limbo_entry = NULL;
     FCacheEntry *dir_entry = NULL;
     unsigned link_count = 0;
     fcache_cache_handle cache_handle;
a1191 4
     arla_warnx (ADEBMSG, "rmdir (%ld.%lu.%lu.%lu) \"%s\"",
		 (long)parent_fid->Cell, (unsigned long)parent_fid->fid.Volume,
		 (unsigned long)parent_fid->fid.Vnode,
		 (unsigned long)parent_fid->fid.Unique, h->name);
d1196 1
a1196 43
     /*
      * Fetch the child-entry fid.
      */

     do {
	 res = cm_lookup (parent_fid, h->name, &fid, &ce, FALSE);
	 if (res.res)
	     ret = res.error;
	 else
	     ret = res.res;
     } while (try_again (&ret, &ce, &h->cred, parent_fid));

     if (ret)
	 goto out;

     /*
      * Need to get linkcount for silly rename.
      */

     ret = fcache_get (&limbo_entry, fid, ce);
     if (ret)
	 goto out;

     ret = fcache_verify_attr (limbo_entry, NULL, NULL, ce);
     if (ret)
	 goto out;
     link_count = limbo_entry->status.LinkCount;

     fcache_release (limbo_entry);
     limbo_entry = NULL;

     /*
      * Do the actual work
      */

     do {
	 res = cm_rmdir(parent_fid, h->name, &ce);
	 if (res.res)
	     ret = res.error;
	 else
	     ret = res.res;
     } while (try_again (&ret, &ce, &h->cred, parent_fid));

d1198 3
d1202 1
a1202 1
	 ret = message_get_data (&dir_entry, parent_fid, &h->cred, &ce);
d1206 10
a1215 33
	 if (!dir_entry->flags.extradirp
	     || dir_remove_name (dir_entry, h->name,
				 &cache_handle,
				 msg0.cache_name,
				 sizeof(msg0.cache_name))) {
	     res = conv_dir (dir_entry, ce, 0,
			     &cache_handle,
			     msg0.cache_name,
			     sizeof(msg0.cache_name));
	     if (res.res == -1) {
		 ret = res.error;
		 goto out;
	     }
	 }
	 msg0.cache_handle = cache_handle.xfs_handle;
	 msg0.flag = XFS_ID_INVALID_DNLC;
	 if (cache_handle.valid)
	     msg0.flag |= XFS_ID_HANDLE_VALID;

	 msg0.node.tokens = res.tokens;

	 fcacheentry2xfsnode (parent_fid,
			      fcache_realfid(dir_entry),
			      &dir_entry->status, &msg0.node,
			      dir_entry->acccache,
			      FCACHE2XFSNODE_ALL);
	 
	 msg0.header.opcode = XFS_MSG_INSTALLDATA;
	 h0 = (struct xfs_message_header *)&msg0;
	 h0_len = sizeof(msg0);

	 ret = fcache_get (&limbo_entry, fid, ce);
	 if (ret)
d1217 3
d1221 4
a1224 1
	 /* Only silly rename when this is the last reference. */
d1226 9
a1234 2
	 if (link_count == 2)
	     limbo_entry->flags.silly = TRUE;
d1236 6
a1241 22
	 if (limbo_entry->flags.kernelp) {

	     ret = fcache_verify_attr (limbo_entry, NULL, NULL, ce);
	     if (ret)
		 goto out;

	     msg1.header.opcode = XFS_MSG_INSTALLATTR;
	     msg1.node.tokens   = limbo_entry->tokens;
	     if (!limbo_entry->flags.datausedp)
		 msg1.node.tokens &= ~XFS_DATA_MASK;

	     if (link_count == 2 && limbo_entry->status.LinkCount == 2)
		 limbo_entry->status.LinkCount = 0;
	     fcacheentry2xfsnode (&fid,
				  fcache_realfid(limbo_entry),
				  &limbo_entry->status,
				  &msg1.node,
				  limbo_entry->acccache,
				  FCACHE2XFSNODE_ALL);
	     
	     h1 = (struct xfs_message_header *)&msg1;
	     h1_len = sizeof(msg1);
d1243 2
a1244 6
#if 0
	 assert(dir_entry->flags.attrusedp);
#endif
	 dir_entry->flags.datausedp = TRUE;
     }

a1245 5
     if (dir_entry)
	 fcache_release(dir_entry);
     if (limbo_entry)
	 fcache_release (limbo_entry);

a1250 1
				       h1, h1_len,
a1259 1
     VenusFid child_fid;
a1264 1
     struct xfs_message_installdata msg3;
a1268 7
     struct xfs_message_header *h2 = NULL;
     size_t h2_len = 0;
     FCacheEntry *old_entry   = NULL;
     FCacheEntry *new_entry   = NULL;
     FCacheEntry *child_entry = NULL;
     int update_child = 0;
     fcache_cache_handle cache_handle;
a1271 12
     arla_warnx (ADEBMSG,
		 "rename (%ld.%lu.%lu.%lu) (%ld.%lu.%lu.%lu) \"%s\" \"%s\"",
		 (long)old_parent_fid->Cell,
		 (unsigned long)old_parent_fid->fid.Volume,
		 (unsigned long)old_parent_fid->fid.Vnode,
		 (unsigned long)old_parent_fid->fid.Unique,
		 (long)new_parent_fid->Cell,
		 (unsigned long)new_parent_fid->fid.Volume,
		 (unsigned long)new_parent_fid->fid.Vnode,
		 (unsigned long)new_parent_fid->fid.Unique,
		 h->old_name,
		 h->new_name);
d1276 3
a1278 9
     do {
	 res = cm_rename(old_parent_fid, h->old_name,
			 new_parent_fid, h->new_name,
			 &child_fid, &update_child, &ce);
	 if (res.res)
	     ret = res.error;
	 else
	     ret = res.res;
     } while (try_again (&ret, &ce, &h->cred, old_parent_fid));
d1281 3
d1285 1
a1285 1
	 ret = message_get_data (&old_entry, old_parent_fid, &h->cred, &ce);
d1289 14
a1302 18
	 if (!old_entry->flags.extradirp
	     || dir_remove_name (old_entry, h->old_name,
				 &cache_handle,
				 msg1.cache_name,
				 sizeof(msg1.cache_name))) {
	     res = conv_dir (old_entry, ce, 0,
			     &cache_handle,
			     msg1.cache_name,
			     sizeof(msg1.cache_name));
	     if (res.res == -1) {
		 ret = res.error;
		 goto out;
	     }
	 }
	 msg1.cache_handle = cache_handle.xfs_handle;
	 msg1.flag = XFS_ID_INVALID_DNLC;
	 if (cache_handle.valid)
	     msg1.flag |= XFS_ID_HANDLE_VALID;
d1304 4
a1307 1
	 msg1.node.tokens = res.tokens;
d1309 3
a1311 5
	 fcacheentry2xfsnode (old_parent_fid,
			      fcache_realfid(old_entry),
			      &old_entry->status, &msg1.node,
			      old_entry->acccache,
			      FCACHE2XFSNODE_ALL);
d1316 1
d1318 1
d1320 1
a1320 14
	 /*
	  * If the new parent is the same as the old parent, reuse
	  */

	 if (VenusFid_cmp(new_parent_fid, old_parent_fid) == 0) {
	     new_entry = old_entry;
	     old_entry = NULL;
	 } else {
	     ret = fcache_get (&new_entry, *new_parent_fid, ce);
	     if (ret)
		 goto out;
	 }
	 
	 ret = fcache_verify_data (new_entry, ce); /* XXX - fake_mp? */
d1323 8
a1330 5
	 
	 res = conv_dir (new_entry, ce, 0,
			 &cache_handle,
			 msg2.cache_name,
			 sizeof(msg2.cache_name));
d1332 1
d1336 7
a1342 4
	 msg2.cache_handle = cache_handle.xfs_handle;
	 msg2.flag = XFS_ID_INVALID_DNLC;
	 if (cache_handle.valid)
	     msg2.flag |= XFS_ID_HANDLE_VALID;
d1344 3
a1346 7
	 msg2.node.tokens = res.tokens;
	 
	 fcacheentry2xfsnode (new_parent_fid,
			      fcache_realfid(new_entry),
			      &new_entry->status, &msg2.node,
			      new_entry->acccache,
			      FCACHE2XFSNODE_ALL);
d1351 2
d1354 6
a1359 5
	 if (old_entry) {
#if 0
	     assert(old_entry->flags.attrusedp);
#endif
	     old_entry->flags.datausedp = TRUE;
d1361 2
a1362 37
#if 0
	 assert(new_entry->flags.attrusedp);
#endif
	 new_entry->flags.datausedp = TRUE;

	 if (update_child) {
	     ret = message_get_data (&child_entry, &child_fid, &h->cred, &ce);
	     if (ret)
		 goto out;

	     res = conv_dir (child_entry, ce, 0,
			     &cache_handle,
			     msg3.cache_name,
			     sizeof(msg3.cache_name));
	     if (res.res == -1) {
		 ret = res.error;
		 goto out;
	     }
	     msg3.cache_handle = cache_handle.xfs_handle;
	     msg3.flag = XFS_ID_INVALID_DNLC;
	     if (cache_handle.valid)
		 msg3.flag |= XFS_ID_HANDLE_VALID;

	     msg3.node.tokens = res.tokens;

	     fcacheentry2xfsnode (&child_fid,
				  fcache_realfid(child_entry),
				  &child_entry->status, &msg3.node,
				  child_entry->acccache,
				  FCACHE2XFSNODE_ALL);

	     msg3.header.opcode = XFS_MSG_INSTALLDATA;
	     h2 = (struct xfs_message_header *)&msg3;
	     h2_len = sizeof(msg3);
	 }
     }

a1363 4
     if (old_entry) fcache_release(old_entry);
     if (new_entry) fcache_release(new_entry);
     if (child_entry) fcache_release(child_entry);
     
a1380 5
     int ret;
     AFSStoreStatus status;
     struct vcache log_cache;
     FCacheEntry *fce;
     int log_err;
a1382 6
     arla_warnx (ADEBMSG, "putdata (%ld.%lu.%lu.%lu)",
		 (long)fid->Cell, (unsigned long)fid->fid.Volume,
		 (unsigned long)fid->fid.Vnode,
		 (unsigned long)fid->fid.Unique);

     xfs_attr2afsstorestatus(&h->attr, &status);
d1387 8
a1394 7
     if (connected_mode != CONNECTED) {
	 ret = fcache_find (&fce, *fid);

	 ReleaseWriteLock (&fce->lock);

	 log_cache.fid  = *fid;
	 log_cache.cred = h->cred;
a1396 16
     do {
	 res = cm_close(*fid, h->flag, &status, ce);
	 if (res.res)
	     ret = res.error;
	 else
	     ret = res.res;
     } while (try_again (&ret, &ce, &h->cred, fid));
	 
     if (ret == 0) {
	 if (connected_mode != CONNECTED) {
	     log_cache.DataVersion = ++fce->status.DataVersion;
	     log_err = log_dis_store (&log_cache);
	 }
     } else {
	 arla_warn (ADEBMSG, ret, "xfs_message_putdata: cm_close");
     }
d1399 2
a1400 1
     xfs_send_message_wakeup (fd, h->header.sequence_num, ret);
d1412 1
a1417 1
     fcache_cache_handle cache_handle;
a1419 4
     arla_warnx (ADEBMSG, "getdata (%ld.%lu.%lu.%lu)",
		 (long)fid->Cell, (unsigned long)fid->fid.Volume,
		 (unsigned long)fid->fid.Vnode,
		 (unsigned long)fid->fid.Unique);
d1424 3
a1426 9
     do {
	 res = cm_getattr (*fid, &status, &real_fid, ce, &ae);
	 if (res.res)
	     ret = res.error;
	 else
	     ret = res.res;
     } while (try_again (&ret, &ce, &h->cred, fid));

     if (ret == 0) {
d1430 1
a1430 1
	       ret = message_get_data (&entry, fid, &h->cred, &ce);
d1434 5
a1438 17
	       fcacheentry2xfsnode (fid, fcache_realfid(entry),
				    &entry->status, &msg.node, ae,
				    FCACHE2XFSNODE_ALL);

	       res = conv_dir (entry, ce, h->tokens,
			       &cache_handle,
			       msg.cache_name,
			       sizeof(msg.cache_name));
	       if (res.res)
		   ret = res.error;

	       if (ret == 0) {
		   msg.node.tokens = res.tokens;
		   msg.cache_handle = cache_handle.xfs_handle;
		   msg.flag = XFS_ID_INVALID_DNLC;
		   if (cache_handle.valid)
		       msg.flag |= XFS_ID_HANDLE_VALID;
d1440 4
a1443 2
		   entry->flags.attrusedp = TRUE;
		   entry->flags.datausedp = TRUE;
d1445 1
a1445 1
	       fcache_release(entry);
d1447 6
a1452 18
	      do {
		  res = cm_open (fid, &ce, h->tokens, &cache_handle,
				 msg.cache_name, sizeof(msg.cache_name));
		  if (res.res)
		      ret = res.error;
		  else
		      ret = res.res;
	      } while (try_again (&ret, &ce, &h->cred, fid));
	      if (ret == 0) {
		  msg.cache_handle = cache_handle.xfs_handle;
		  msg.flag = 0;
		  if (cache_handle.valid)
		      msg.flag |= XFS_ID_HANDLE_VALID;
		  msg.node.tokens = res.tokens;
		  fcacheentry2xfsnode (fid, &real_fid,
				       &status, &msg.node, ae,
				       FCACHE2XFSNODE_ALL);
	      }
d1456 1
a1456 1
     if (ret == 0) {
d1461 9
a1481 5
/*
 * Send a invalid node to the kernel to invalidate `entry'
 * and record that it's not being used in the kernel.
 */

d1483 1
a1483 1
break_callback (FCacheEntry *entry)
a1485 5
     enum { CALLBACK_BREAK_WARN = 100 };
     static int failed_callbacks_break = 0;
     int ret;

     assert (entry->flags.kernelp);
d1488 2
a1489 36
     memcpy (&msg.handle, &entry->fid, sizeof(entry->fid));
     ret = xfs_message_send (kernel_fd, (struct xfs_message_header *)&msg, 
			     sizeof(msg));
     if (ret) {
	 arla_warnx (ADEBMSG, "break_callback: (%ld.%lu.%lu.%lu) failed",
		     (long)entry->fid.Cell, 
		     (unsigned long)entry->fid.fid.Volume,
		     (unsigned long)entry->fid.fid.Vnode,
		     (unsigned long)entry->fid.fid.Unique);
	 ++failed_callbacks_break;
	 if (failed_callbacks_break > CALLBACK_BREAK_WARN) {
	     arla_warnx (ADEBWARN, "break_callback: have failed %d times",
			 failed_callbacks_break);
	     failed_callbacks_break = 0;
	 }
     }
}

/*
 * Send an unsolicited install-attr for the node in `e'
 */

void
install_attr (FCacheEntry *e, int flags)
{
     struct xfs_message_installattr msg;

     memset (&msg, 0, sizeof(msg));
     msg.header.opcode = XFS_MSG_INSTALLATTR;
     fcacheentry2xfsnode (&e->fid, fcache_realfid(e), &e->status, &msg.node,
			  e->acccache, flags);
     msg.node.tokens   = e->tokens;
     if (!e->flags.datausedp)
	 msg.node.tokens &= ~XFS_DATA_MASK;

     xfs_message_send (kernel_fd, (struct xfs_message_header *)&msg, 
a1492 22
void
update_fid(VenusFid oldfid, FCacheEntry *old_entry,
	   VenusFid newfid, FCacheEntry *new_entry)
{
    struct xfs_message_updatefid msg;

    msg.header.opcode = XFS_MSG_UPDATEFID;
    memcpy (&msg.old_handle, &oldfid, sizeof(oldfid));
    memcpy (&msg.new_handle, &newfid, sizeof(newfid));
    xfs_message_send (kernel_fd, (struct xfs_message_header *)&msg,
		      sizeof(msg));
    if (new_entry != NULL) {
	new_entry->flags.kernelp   = TRUE;
	new_entry->flags.attrusedp = TRUE;
    }
    if (old_entry != NULL) {
	old_entry->flags.kernelp   = FALSE;
	old_entry->flags.attrusedp = FALSE;
	old_entry->flags.datausedp = FALSE;
    }
}

a1502 4
     arla_warnx (ADEBMSG, "inactivenode (%ld.%lu.%lu.%lu)",
		 (long)fid->Cell, (unsigned long)fid->fid.Volume,
		 (unsigned long)fid->fid.Vnode,
		 (unsigned long)fid->fid.Unique);
d1515 4
a1518 7
	 fcache_unused (entry);
     if (h->flag & XFS_DELETE) {
	 entry->flags.kernelp   = FALSE;
	 entry->flags.datausedp = FALSE;
	 entry->flags.attrusedp = FALSE;
     }
     fcache_release(entry);
a1521 9
/*
 * Do we have powers for changing stuff?
 */

static Bool
all_powerful_p (const xfs_cred *cred)
{
    return cred->uid == 0;
}
a1522 3
/*
 * Flush the contents of a volume
 */
a1541 1
    volcache_invalidate (fid.fid.Volume, fid.Cell);
d1558 1
a1558 1
	return xfs_send_message_wakeup (fd, h->header.sequence_num, EINVAL);
d1568 1
a1568 3
    do {
	error = getacl (fid, ce, &opaque);
    } while (try_again (&error, &ce, &h->cred, &fid));
d1570 5
a1574 1
    if (error != 0 && error != EACCES)
d1581 1
a1581 2
    if (error == 0)
	free (opaque.val);
a1594 1
    FCacheEntry *e;
d1598 1
a1598 1
	return xfs_send_message_wakeup (fd, h->header.sequence_num, EINVAL);
d1600 2
a1601 2
    if (h->insize > AFSOPAQUEMAX || h->insize == 0)
	return xfs_send_message_wakeup (fd, h->header.sequence_num, EINVAL);
d1603 2
a1604 3
    opaque.val = malloc(h->insize);
    if(opaque.val == NULL)
	return xfs_send_message_wakeup (fd, h->header.sequence_num, ENOMEM);
d1606 1
a1606 1
    fid.Cell       = h->handle.a;
d1608 1
a1608 1
    fid.fid.Vnode  = h->handle.c;
d1614 1
a1614 1
    opaque.len = h->insize;
d1617 7
a1623 8
    do {
	error = setacl (fid, ce, &opaque, &e);
    } while (try_again (&error, &ce, &h->cred, &fid));

    if (error == 0) {
	install_attr (e, FCACHE2XFSNODE_ALL);
	fcache_release (e);
    } else if (error != EACCES)
d1629 2
a1630 1
    xfs_send_message_wakeup_data (fd, h->header.sequence_num, error, NULL, 0);
d1648 1
a1648 1
    int32_t outsize = 0;
d1652 1
a1652 1
	return xfs_send_message_wakeup (fd, h->header.sequence_num, EINVAL);
d1667 2
a1668 6
    do {
	error = getvolstat (fid, ce, &volstat,
			    volumename,
			    offlinemsg,
			    motd);
    } while (try_again (&error, &ce, &h->cred, &fid));
d1672 5
a1676 1
    if (error != 0 && error != EACCES)
a1748 1
#if 0
a1767 5
#else
    volumename[0] = '\0';
    offlinemsg[0] = '\0';
    motd[0] = '\0';
#endif
d1769 2
a1770 4
    do {
	error = setvolstat (fid, ce, &outvolstat, volumename,
			    offlinemsg, motd);
    } while (try_again (&error, &ce, &h->cred, &fid));
d1772 5
a1776 1
    if (error != 0 && error != EACCES)
d1787 1
a1787 3
 * Get the mount point at (`fid', `filename') using the cred in `ce'
 * and returning the fcache entry in `ret_mp_entry'
 * Return 0 or an error.
d1791 8
a1798 8
get_mount_point (VenusFid fid,
		 const char *filename,
		 CredCacheEntry **ce,
		 FCacheEntry **ret_mp_entry)
{
    FCacheEntry *mp_entry;
    FCacheEntry *dentry;
    VenusFid mp_fid;
d1800 1
d1802 1
a1802 1
    if (fid.fid.Volume == 0 && fid.fid.Vnode == 0 && fid.fid.Unique == 0)
d1805 4
a1808 3
    error = fcache_get_data(&dentry, &fid, ce);
    if (error)
	return error;
d1810 2
a1811 4
    error = adir_lookup(dentry, filename, &mp_fid);
    fcache_release(dentry);
    if (error)
	return error;
d1813 3
a1815 2
    error = fcache_get(&mp_entry, mp_fid, *ce);
    if (error)
d1817 2
a1818 2

    error = fcache_verify_attr (mp_entry, NULL, NULL, *ce);
d1820 1
a1820 1
	fcache_release(mp_entry);
d1823 1
a1823 34

    if ((mp_entry->status.FileType != TYPE_LINK
	 && !mp_entry->flags.fake_mp)
	|| mp_entry->status.Length == 0) { 	/* Is not a mount point */
	fcache_release(mp_entry);
	return EINVAL;
    }
    *ret_mp_entry = mp_entry;
    return 0;
}

/*
 * Read the contents of the mount point in `e' and return a fbuf in
 * `the_fbuf' mapped READ|WRITE|PRIVATE.
 * Return 0 or an error
 */

static int
read_mount_point (FCacheEntry *mp_entry, CredCacheEntry *ce,
		  int *fd, fbuf *the_fbuf)
{
    int error;
    char *buf;

    error = fcache_verify_data (mp_entry, ce);
    if (error)
	return error;

    *fd = fcache_open_file (mp_entry, O_RDONLY);
    if (*fd < 0)
	return errno;

    error = fbuf_create (the_fbuf, *fd, mp_entry->status.Length,
			 FBUF_READ|FBUF_WRITE|FBUF_PRIVATE);
d1825 2
a1826 1
	close (*fd);
d1829 3
a1831 5

    buf = (char *)(the_fbuf->buf);
    if (buf[0] != '#' && buf[0] != '%') { /* Is not a mount point */
	fbuf_end (the_fbuf);
	close (*fd);
d1834 1
a1834 30

    return 0;
}

/*
 * Get info for a mount point.
 */

static int
vioc_afs_stat_mt_pt(int fd, struct xfs_message_pioctl *h, u_int size)
{
    VenusFid fid;
    int error;
    int mp_fd;
    fbuf the_fbuf;
    CredCacheEntry *ce;
    FCacheEntry *e;
    unsigned char *buf;

    fid.Cell       = h->handle.a;
    fid.fid.Volume = h->handle.b;
    fid.fid.Vnode  = h->handle.c;
    fid.fid.Unique = h->handle.d;

    h->msg[min(h->insize, sizeof(h->msg)-1)] = '\0';

    ce = cred_get (fid.Cell, h->cred.pag, CRED_ANY);
    assert (ce != NULL);

    error = get_mount_point (fid, h->msg, &ce, &e);
d1836 7
d1844 1
a1844 1
	return xfs_send_message_wakeup (fd, h->header.sequence_num, error);
d1846 1
a1846 2

    error = read_mount_point (e, ce, &mp_fd, &the_fbuf);
d1848 1
a1848 1
	fcache_release (e);
d1850 8
a1857 1
	return xfs_send_message_wakeup (fd, h->header.sequence_num, error);
d1860 2
a1861 5
    /*
     * To confuse us, the volume is passed up w/o the ending
     * dot. It's not even mentioned in the ``VIOC_AFS_STAT_MT_PT''
     * documentation.
     */
d1863 1
a1863 5
    buf = (unsigned char *)the_fbuf.buf;
    buf[the_fbuf.len-1] = '\0';

    xfs_send_message_wakeup_data (fd, h->header.sequence_num, error,
				  buf, the_fbuf.len);
a1864 2
    close (mp_fd);
    fcache_release (e);
a1869 39
/*
 * Handle the VIOC_AFS_DELETE_MT_PT message in `h' by deleting the
 * mountpoint.  
 */

static int
vioc_afs_delete_mt_pt(int fd, struct xfs_message_pioctl *h, u_int size)
{
    VenusFid fid;
    int error = 0;
    CredCacheEntry *ce;
    struct xfs_message_remove remove_msg;
    FCacheEntry *entry;

    h->msg[min(h->insize, sizeof(h->msg)-1)] = '\0';

    fid.Cell       = h->handle.a;
    fid.fid.Volume = h->handle.b;
    fid.fid.Vnode  = h->handle.c;
    fid.fid.Unique = h->handle.d;

    ce = cred_get (fid.Cell, h->cred.pag, CRED_ANY);
    assert (ce != NULL);

    error = get_mount_point (fid, h->msg, &ce, &entry);
    cred_free (ce);
    if (error)
	return xfs_send_message_wakeup (fd, h->header.sequence_num, error);
    fcache_release(entry);

    remove_msg.header        = h->header;
    remove_msg.header.size   = sizeof(remove_msg);
    remove_msg.parent_handle = h->handle;
    strlcpy(remove_msg.name, h->msg, sizeof(remove_msg.name));
    remove_msg.cred          = h->cred;

    return xfs_message_remove (fd, &remove_msg, sizeof(remove_msg));
}

d1877 1
a1877 1
    int i, j;
a1878 1
    int bit;
d1881 1
a1881 1
	return xfs_send_message_wakeup (fd, h->header.sequence_num, EINVAL);
d1883 1
a1883 1
    fid.Cell       = h->handle.a;
d1885 1
a1885 1
    fid.fid.Vnode  = h->handle.c;
d1894 1
a1894 1
	return xfs_send_message_wakeup (fd, h->header.sequence_num, error);
d1896 1
a1896 1
    error = fcache_verify_attr (e, NULL, NULL, ce);
d1898 1
a1898 1
	fcache_release(e);
d1900 1
a1900 1
	return xfs_send_message_wakeup (fd, h->header.sequence_num, error);
a1901 9

    bit = volcache_volid2bit (e->volume, fid.fid.Volume);

    if (bit == -1) {
	fcache_release(e);
	cred_free(ce);
	return xfs_send_message_wakeup (fd, h->header.sequence_num, EINVAL);
    }

d1903 2
a1904 2
    for (i = 0, j = 0; i < min(e->volume->entry.nServers, MAXNSERVERS); i++) {
	u_long addr = htonl(e->volume->entry.serverNumber[i]);
a1905 3
	if ((e->volume->entry.serverFlags[i] & bit) && addr != 0)
	    addresses[j++] = addr;
    }
d1907 1
a1907 1
				  addresses, sizeof(long) * j);
d1909 1
a1909 1
    fcache_release(e);
a1914 4
/*
 * Return all db servers for a particular cell.
 */ 

d1916 1
a1916 1
vioc_get_cell(int fd, struct xfs_message_pioctl *h, u_int size)
a1923 2
    const cell_db_entry *dbservers;
    int num_dbservers;
d1928 1
a1928 1
	return xfs_send_message_wakeup (fd, h->header.sequence_num, EDOM);
a1929 5
    dbservers = cell_dbservers_by_id (index, &num_dbservers);

    if (dbservers == NULL)
	return xfs_send_message_wakeup (fd, h->header.sequence_num, EDOM);

d1931 3
a1933 1
    cellname_len = min(strlen(cellname), MAXPATHLEN - 1);
d1935 5
a1939 4
    out[8 * sizeof(int32_t) + cellname_len] = '\0';
    outsize = 8 * sizeof(int32_t) + cellname_len + 1;
    for (i = 0; i < min(num_dbservers, 8); ++i) {
	u_int32_t addr = dbservers[i].addr.s_addr;
a1948 121
/*
 * Return status information about a cell.
 */

static int
vioc_get_cellstatus(int fd, struct xfs_message_pioctl *h, u_int size)
{
    char *cellname;
    int32_t cellid;
    u_int32_t out = 0;

    cellname = h->msg;
    cellname[h->insize-1]  = '\0';

    cellid = cell_name2num (cellname);
    if (cellid == -1)
	return xfs_send_message_wakeup (fd, h->header.sequence_num, ENOENT);

    if (cellid == 0)
	out |= CELLSTATUS_PRIMARY;
    if (cell_issuid_by_num (cellid))
	out |= CELLSTATUS_SETUID;

    xfs_send_message_wakeup_data (fd, h->header.sequence_num, 0,
				  &out, sizeof(out));

    return 0;
}

/*
 * Set status information about a cell.
 */

static int
vioc_set_cellstatus(int fd, struct xfs_message_pioctl *h, u_int size)
{
    int32_t cellid;
    char *cellname;
    u_int32_t in = 0;
    int ret;

    if (!all_powerful_p (&h->cred))
	return xfs_send_message_wakeup (fd, h->header.sequence_num, EACCES);

    if (h->insize < sizeof (in) + 2) /* terminating NUL and one char */
	return xfs_send_message_wakeup (fd, h->header.sequence_num, EINVAL);

    cellname = h->msg + sizeof (in);
    cellname[h->insize-1-sizeof(in)]  = '\0';

    cellid = cell_name2num (cellname);
    if (cellid == -1)
	return xfs_send_message_wakeup (fd, h->header.sequence_num, ENOENT);

    if (in & CELLSTATUS_SETUID) { 
	ret = cell_setsuid_by_num (cellid);
	if (ret)
	    return xfs_send_message_wakeup (fd, h->header.sequence_num,EINVAL);
    }

    xfs_send_message_wakeup (fd, h->header.sequence_num, 0);

    return 0;
}

/*
 * Set information about a cell or add a new one.
 */

static int
vioc_new_cell(int fd, struct xfs_message_pioctl *h, u_int size)
{
    const char *cellname;
    cell_entry *ce;
    int count, i;
    u_int32_t *hp;
    cell_db_entry *dbs;

    if (!all_powerful_p (&h->cred))
	return xfs_send_message_wakeup (fd, h->header.sequence_num, EPERM);
	    
    if (h->insize < 9)
	return xfs_send_message_wakeup (fd, h->header.sequence_num, EINVAL);

    hp = (u_int32_t *)h->msg;
    for (count = 0; *hp != 0; ++hp)
	++count;

    dbs = malloc (count * sizeof(*dbs));
    if (dbs == NULL)
	return xfs_send_message_wakeup (fd, h->header.sequence_num, ENOMEM);
	
    memset(dbs, 0, count * sizeof(*dbs));

    hp = (u_int32_t *)h->msg;
    for (i = 0; i < count; ++i) {
	dbs[i].name = NULL;
	dbs[i].addr.s_addr = hp[i];
	dbs[i].timeout = 0;
    }

    cellname = h->msg + 8 * sizeof(u_int32_t);
    ce = cell_get_by_name (cellname);
    if (ce == NULL) {
	ce = cell_new_dynamic (cellname);

	if (ce == NULL) {
	    free (dbs);
	    return xfs_send_message_wakeup (fd, h->header.sequence_num,
					    ENOMEM);
	}
    } else {
	free (ce->dbservers);
    }

    ce->ndbservers = count;
    ce->dbservers  = dbs;

    return xfs_send_message_wakeup (fd, h->header.sequence_num, 0);
}

d1970 1
a1970 1
    ct.ViceId         = ce->uid;
d1974 1
a1974 1
    tmp = cred->ticket_st.length;
a1976 2
    memcpy (p, cred->ticket_st.dat, tmp);
    p += tmp;
d2007 1
a2007 2
	int32_t cell_id = cell_name2num(cell_getthiscell());
	CredCacheEntry *ce = cred_get (cell_id, h->cred.pag, CRED_KRB4);
a2048 70

/*
 * Handle the SETTOK message in `h'
 */

static int
viocsettok (int fd, struct xfs_message_pioctl *h, u_int size)
{
    struct ClearToken ct;
    CREDENTIALS c;
    long cell;
    int32_t sizeof_x;
    char *t = h->msg;

    /* someone probed us */
    if (h->insize == 0) {
	return EINVAL;
    }

    /* Get ticket_st */
    memcpy(&sizeof_x, t, sizeof(sizeof_x)) ;
    c.ticket_st.length = sizeof_x ;
    arla_warnx (ADEBMSG, "ticket_st has size %d", sizeof_x);
    t += sizeof(sizeof_x) ;

    memcpy(c.ticket_st.dat, t, sizeof_x) ;
    t += sizeof_x ;

    /* Get ClearToken */
    memcpy(&sizeof_x, t, sizeof(sizeof_x)) ;
    t += sizeof(sizeof_x) ;

    memcpy(&ct, t, sizeof_x) ;
    t += sizeof_x ;

    /* Get primary cell ? */
    memcpy(&sizeof_x, t, sizeof(sizeof_x)) ;
    t += sizeof(sizeof_x) ;

    /* Get Cellname */ 
    strncpy(c.realm, t, REALM_SZ) ;
    c.realm[REALM_SZ-1] = '\0' ;

    /* Make this a sane world again */
    c.kvno = ct.AuthHandle;
    memcpy (c.session, ct.HandShakeKey, sizeof(c.session));
    c.issue_date = ct.BeginTimestamp - 1;
	
    cell = cell_name2num(strlwr(c.realm));

    if (cell == -1)
	return ENOENT;

    conn_clearcred (CONN_CS_ALL, cell, h->cred.pag, 2);
    fcache_purge_cred(h->cred.pag, cell);
    cred_add (h->cred.pag, CRED_KRB4, 2, cell, ct.EndTimestamp,
	      &c, sizeof(c), ct.ViceId);
    return 0;
}

static int
viocunlog (int fd, struct xfs_message_pioctl *h, u_int size)
{
    xfs_pag_t cred = h->cred.pag;

    cred_remove(cred);
    fcache_purge_cred(cred, -1);
    return 0;
}

a2050 4
/*
 * Flush the fid in `h->handle' from the cache.
 */

d2060 1
a2060 1
    fid.Cell       = h->handle.a;
d2062 1
a2062 1
    fid.fid.Vnode  = h->handle.c;
a2104 12
	    if (Log_is_open) {
		DARLA_Close(&log_data);
		Log_is_open = 0;

#if 0
		do_replay("discon_log", log_data.log_entries, 0);
#endif
	    }
	    if (connected_mode == DISCONNECTED) {
		connected_mode = CONNECTED ;
		fcache_reobtain_callbacks ();
	    }
a2110 7
	    ret = DARLA_Open(&log_data, ARLACACHEDIR"/discon_log",
			     O_WRONLY | O_CREAT | O_BINARY);
	    if (ret < 0) {
		arla_warn (ADEBERROR, errno, "DARLA_Open");
	    } else {
		Log_is_open = 1;
	    }
d2124 1
a2124 1
static int
d2131 1
a2131 1
	if (conn_rxkad_level == rxkad_crypt)
d2137 5
a2141 5
	return xfs_send_message_wakeup_data (fd,
					     h->header.sequence_num,
					     0,
					     &n,
					     sizeof(n));
d2143 1
a2143 1
	return xfs_send_message_wakeup (fd, h->header.sequence_num, EINVAL);
d2158 1
a2158 1
	    conn_rxkad_level = rxkad_auth;
d2160 1
a2160 1
	    conn_rxkad_level = rxkad_crypt;
a2162 2
	if (error == 0)
	    conn_clearcred (CONN_CS_NONE, 0, -1, -1);
a2170 4
/*
 * XXX - this function sometimes does a wakeup_data and then an ordinary wakeup is sent in xfs_message_pioctl
 */

a2188 1
#if 0
a2244 1
#endif
d2249 1
a2249 1
viocgetfid (int fd, struct xfs_message_pioctl *h, u_int size)
d2251 3
a2253 3
    return xfs_send_message_wakeup_data(fd, h->header.sequence_num, 0,
					&h->handle, sizeof(VenusFid));
}
d2255 13
a2267 50
static int
viocvenuslog (int fd, struct xfs_message_pioctl *h, u_int size)
{
    if (!all_powerful_p(&h->cred))
	return EPERM;
	    
    conn_status ();
    volcache_status ();
    cred_status ();
    fcache_status ();
#if 0
    fprio_status ();
#endif
#ifdef RXDEBUG
    rx_PrintStats(stderr);
#endif
    return 0;
}

/*
 * Set or get the sysname
 */

static int
vioc_afs_sysname (int fd, struct xfs_message_pioctl *h, u_int size)
{
    char *t = h->msg;
    int32_t parm = *((int32_t *)t);

    if (parm) {
	if (!all_powerful_p (&h->cred))
	    return xfs_send_message_wakeup (fd,
					    h->header.sequence_num,
					    EPERM);
	t += sizeof(int32_t);
	arla_warnx (ADEBMSG, "VIOC_AFS_SYSNAME: setting sysname: %s", t);
	memcpy(arlasysname, t, h->insize);
	arlasysname[h->insize] = '\0';
	return xfs_send_message_wakeup(fd, h->header.sequence_num, 0);
    } else {
	char *buf;
	size_t sysname_len = strlen (arlasysname);
	int ret;

	buf = malloc (sysname_len + 4 + 1);
	if (buf == NULL)
	    return xfs_send_message_wakeup (fd, h->header.sequence_num, ENOMEM);
	*((u_int32_t *)buf) = sysname_len;
	memcpy (buf + 4, arlasysname, sysname_len);
	buf[sysname_len + 4] = '\0';
d2269 29
a2297 39
	ret = xfs_send_message_wakeup_data (fd, h->header.sequence_num, 0,
					    buf, sysname_len + 5);
	free (buf);
	return ret;
    }
}

static int
viocfilecellname (int fd, struct xfs_message_pioctl *h, u_int size)
{
    char *cellname;

    cellname = (char *) cell_num2name(h->handle.a);

    if (cellname) 
	return xfs_send_message_wakeup_data(fd, h->header.sequence_num, 0,
					    cellname, strlen(cellname)+1);
    else 
	return xfs_send_message_wakeup_data(fd, h->header.sequence_num, EINVAL,
					    NULL, 0);
}

static int
viocgetwscell (int fd, struct xfs_message_pioctl *h, u_int size)
{
    char *cellname;

    cellname = (char*) cell_getthiscell();
    return xfs_send_message_wakeup_data(fd, h->header.sequence_num, 0,
					cellname, strlen(cellname)+1);
}

static int
viocsetcachesize (int fd, struct xfs_message_pioctl *h, u_int size)
{
    u_int32_t *s = (u_int32_t *)h->msg;

    if (!all_powerful_p (&h->cred))
	return EPERM;
d2299 1
a2299 174
    if (h->insize >= sizeof(int32_t) * 4) 
	return fcache_reinit(s[0], s[1], s[2], s[3]);
    else
	return fcache_reinit(*s/2, *s, *s*500, *s*1000);
}

/*
 * VIOCCKSERV
 *
 *  in:  flags	- bitmask (1 - dont ping, use cached data, 2 - check fsservers only)
 *       cell	- string (optional)
 *  out: hosts  - u_int32_t number of hosts, followed by list of hosts being down.
 */

static int
viocckserv (int fd, struct xfs_message_pioctl *h, u_int size)
{
    int32_t cell = cell_name2num (cell_getthiscell());
    int flags = 0;
    int num_entries;
    u_int32_t hosts[CKSERV_MAXSERVERS + 1];
    int msg_size;

    if (h->insize < sizeof(int32_t))
	return xfs_send_message_wakeup (fd, h->header.sequence_num, EINVAL);

    memset (hosts, 0, sizeof(hosts));

    flags = *(u_int32_t *)h->msg;
    flags &= CKSERV_DONTPING|CKSERV_FSONLY;

    if (h->insize > sizeof(int32_t)) {
	h->msg[min(h->insize, sizeof(h->msg)-1)] = '\0';

	cell = cell_name2num (((char *)h->msg) + sizeof(int32_t));
	if (cell == -1)
	    return xfs_send_message_wakeup (fd, h->header.sequence_num, ENOENT);
    }
    
    num_entries = CKSERV_MAXSERVERS;
    
    conn_downhosts(cell, hosts + 1, &num_entries, flags);
    
    hosts[0] = num_entries;
    msg_size = sizeof(hosts[0]) * (num_entries + 1);
    return xfs_send_message_wakeup_data (fd, h->header.sequence_num, 0,
					 hosts, msg_size);
}


/*
 * Return the number of used KBs and reserved KBs
 */

static int
viocgetcacheparms (int fd, struct xfs_message_pioctl *h, u_int size)
{
    u_int32_t parms[16];
    
    memset(parms, 0, sizeof(parms));
    parms[0] = fcache_highbytes() / 1024;
    parms[1] = fcache_usedbytes() / 1024;
    parms[2] = fcache_highvnodes();
    parms[3] = fcache_usedvnodes();
    parms[4] = fcache_highbytes();
    parms[5] = fcache_usedbytes();
    parms[6] = fcache_lowbytes();
    parms[7] = fcache_lowvnodes();

    h->outsize = sizeof(parms);
    return xfs_send_message_wakeup_data(fd, h->header.sequence_num, 0,
					parms, sizeof(parms));
}

/*
 * debugging interface to give out statistics of the cache
 */

static int
viocaviator (int fd, struct xfs_message_pioctl *h, u_int size)
{
    u_int32_t parms[16];
    
    memset(parms, 0, sizeof(parms));
    parms[0] = kernel_highworkers();
    parms[1] = kernel_usedworkers();

    h->outsize = sizeof(parms);
    return xfs_send_message_wakeup_data(fd, h->header.sequence_num, 0,
					parms, sizeof(parms));
}

/*
 * Get/set arla debug level
 */

static int
vioc_arladebug (int fd, struct xfs_message_pioctl *h, u_int size)
{
    if (h->insize != 0) {
	if (h->insize < sizeof(int32_t))
	    return xfs_send_message_wakeup (fd, h->header.sequence_num,
					    EINVAL);
	if (!all_powerful_p (&h->cred))
	    return xfs_send_message_wakeup (fd, h->header.sequence_num,
					    EPERM);
	arla_log_set_level_num (*((int32_t *)h->msg));
    }
    if (h->outsize != 0) {
	int32_t debug_level;

	if (h->outsize < sizeof(int32_t))
	    return xfs_send_message_wakeup (fd, h->header.sequence_num,
					    EINVAL);

	debug_level = arla_log_get_level_num ();
	return xfs_send_message_wakeup_data (fd, h->header.sequence_num,
					     0, &debug_level,
					     sizeof(debug_level));
    }
    return xfs_send_message_wakeup (fd, h->header.sequence_num, 0);
}

/*
 * GC pags --- there shouldn't be any need to do anything here.
 */

static int
vioc_gcpags (int fd, struct xfs_message_pioctl *h, u_int size)
{
    return 0;
}

/*
 *
 */

static int
vioc_calculate_cache (int fd, struct xfs_message_pioctl *h, u_int size)
{
    u_int32_t parms[16];
    
    memset(parms, 0, sizeof(parms));
    
    if (!all_powerful_p(&h->cred))
	return EPERM;

    h->outsize = sizeof(parms);

    parms[0] = fcache_calculate_usage();
    parms[1] = fcache_usedbytes();

    arla_warnx (ADEBMISC, 
		"diskusage = %d, usedbytes = %d", 
		parms[0], parms[1]);
    
    return xfs_send_message_wakeup_data (fd, h->header.sequence_num, 0,
					 &parms, sizeof(parms));
}

/*
 *
 */

static int
vioc_breakcallback(int fd, struct xfs_message_pioctl *h, u_int size)
{
    int error;
    VenusFid fid;
    FCacheEntry *e;
    CredCacheEntry *ce;

    if (!all_powerful_p(&h->cred))
	return EPERM;
d2301 5
a2305 19
    if (!h->handle.a && !h->handle.b && !h->handle.c && !h->handle.d)
	return EINVAL;

    fid.Cell = h->handle.a;
    fid.fid.Volume = h->handle.b;
    fid.fid.Vnode = h->handle.c;
    fid.fid.Unique = h->handle.d;

    ce = cred_get (fid.Cell, h->cred.pag, CRED_ANY);
    assert (ce != NULL);

    error = fcache_get(&e, fid, ce);
    if (error)
	return error;

    if (!e->flags.kernelp) {
	cred_free (ce);
	return -ENOENT;
    }
a2306 4
    break_callback (e);
    
    fcache_release (e);
    cred_free (ce);
d2308 2
a2309 76
    return 0;
}

/*
 * check volume mappings
 */

static int
statistics_hostpart(int fd, struct xfs_message_pioctl *h, u_int size)
{
    u_int32_t host[100];
    u_int32_t part[100];
    u_int32_t outparms[512];
    int n;
    int outsize;
    int maxslots;
    int i;

    if (h->outsize < sizeof(u_int32_t))
	return xfs_send_message_wakeup (fd, h->header.sequence_num,
					EINVAL);
    
    n = 100;
    collectstats_hostpart(host, part, &n);
    maxslots = (h->outsize / sizeof(u_int32_t) - 1) / 2;
    if (n > maxslots)
	n = maxslots;
    
    outsize = (n * 2 + 1) * sizeof(u_int32_t);
    
    outparms[0] = n;
    for (i = 0; i < n; i++) {
	outparms[i*2 + 1] = host[i];
	outparms[i*2 + 2] = part[i];
    }
    
    return xfs_send_message_wakeup_data (fd, h->header.sequence_num, 0,
					 (char *) &outparms, outsize);
}

static int
statistics_entry(int fd, struct xfs_message_pioctl *h, u_int size)
{
    u_int32_t *request = (u_int32_t *) h->msg;
    u_int32_t host;
    u_int32_t part;
    u_int32_t type;
    u_int32_t items_slot;
    u_int32_t count[32];
    int64_t items_total[32];
    int64_t total_time[32];
    u_int32_t outparms[160];
    int i;
    int j;

    if (h->insize < sizeof(u_int32_t) * 5) {
	return xfs_send_message_wakeup (fd, h->header.sequence_num,
					EINVAL);
    }

    if (h->outsize < sizeof(u_int32_t) * 160) {
	return xfs_send_message_wakeup (fd, h->header.sequence_num,
					EINVAL);
    }

    host = request[1];
    part = request[2];
    type = request[3];
    items_slot = request[4];

    collectstats_getentry(host, part, type, items_slot,
			  count, items_total, total_time);

    j = 0;
    for (i = 0; i < 32; i++) {
	outparms[j++] = count[i];
a2310 61
    for (i = 0; i < 32; i++) {
	memcpy(&outparms[j], &items_total[i], 8);
	j+=2;
    }
    for (i = 0; i < 32; i++) {
	memcpy(&outparms[j], &total_time[i], 8);
	j+=2;
    }
    return xfs_send_message_wakeup_data (fd, h->header.sequence_num, 0,
					 (char *) &outparms, sizeof(outparms));
}

static int
aioc_statistics(int fd, struct xfs_message_pioctl *h, u_int size)
{
    u_int32_t opcode;

    if (!all_powerful_p (&h->cred))
	return xfs_send_message_wakeup (fd, h->header.sequence_num,
					EPERM);

    if (h->insize < sizeof(u_int32_t))
	return xfs_send_message_wakeup (fd, h->header.sequence_num,
					EPERM);

    opcode = *((int32_t *)h->msg);

    if (opcode == 0) {
	return statistics_hostpart(fd, h, size);
    } else if (opcode == 1) {
	return statistics_entry(fd, h, size);
    } else {
	return xfs_send_message_wakeup (fd, h->header.sequence_num,
					EINVAL);
    }
}


/*
 * Handle a pioctl message in `h'
 */

static int
xfs_message_pioctl (int fd, struct xfs_message_pioctl *h, u_int size)
{
    int error;

    switch(h->opcode) {
#ifdef KERBEROS
#ifdef VIOCSETTOK_32
    case VIOCSETTOK_32:
    case VIOCSETTOK_64:
#else
    case VIOCSETTOK:
#endif
	error = viocsettok (fd, h, size);
	break;
#ifdef VIOCGETTOK_32
    case VIOCGETTOK_32:
    case VIOCGETTOK_64:
#else
a2311 1
#endif
a2312 4
#ifdef VIOCUNPAG_32
    case VIOCUNPAG_32:
    case VIOCUNPAG_64:
#else
d2314 8
a2321 9
#endif
#ifdef VIOCUNLOG_32
    case VIOCUNLOG_32:
    case VIOCUNLOG_64:
#else
    case VIOCUNLOG:
#endif
	error = viocunlog (fd, h, size);
	break;
a2322 4
#ifdef VIOCCONNECTMODE_32
    case VIOCCONNECTMODE_32:
    case VIOCCONNECTMODE_64:
#else
d2324 2
a2325 6
#endif
	return viocconnect(fd, h, size);
#ifdef VIOCFLUSH_32
    case VIOCFLUSH_32:
    case VIOCFLUSH_64:
#else
a2326 1
#endif
a2328 4
#ifdef VIOC_FLUSHVOLUME_32
    case VIOC_FLUSHVOLUME_32:
    case VIOC_FLUSHVOLUME_64:
#else
a2329 1
#endif
a2331 4
#ifdef VIOCGETFID_32
    case VIOCGETFID_32:
    case VIOCGETFID_64:
#else
d2333 3
a2335 6
#endif
	return viocgetfid (fd, h, size);
#ifdef VIOCGETAL_32
    case VIOCGETAL_32:
    case VIOCGETAL_64:
#else
d2337 2
a2338 6
#endif
	return viocgetacl(fd, h, size);
#ifdef VIOCSETAL_32
    case VIOCSETAL_32:
    case VIOCSETAL_64:
#else
d2340 2
a2341 6
#endif
	return viocsetacl(fd, h, size);
#ifdef VIOCGETVOLSTAT_32
    case VIOCGETVOLSTAT_32:
    case VIOCGETVOLSTAT_64:
#else
d2343 2
a2344 6
#endif
	return viocgetvolstat(fd, h, size);
#ifdef VIOCSETVOLSTAT_32
    case VIOCSETVOLSTAT_32:
    case VIOCSETVOLSTAT_64:
#else
a2345 1
#endif
a2347 4
#ifdef VIOC_AFS_STAT_MT_PT_32
    case VIOC_AFS_STAT_MT_PT_32:
    case VIOC_AFS_STAT_MT_PT_64:
#else
d2349 2
a2350 13
#endif
	return vioc_afs_stat_mt_pt(fd, h, size);
#ifdef VIOC_AFS_DELETE_MT_PT_32
    case VIOC_AFS_DELETE_MT_PT_32:
    case VIOC_AFS_DELETE_MT_PT_64:
#else
    case VIOC_AFS_DELETE_MT_PT:
#endif
	return vioc_afs_delete_mt_pt(fd, h, size);
#ifdef VIOCWHEREIS_32
    case VIOCWHEREIS_32:
    case VIOCWHEREIS_64:
#else
d2352 2
a2353 6
#endif
	return viocwhereis(fd, h, size);
#ifdef VIOCNOP_32
    case VIOCNOP_32:
    case VIOCNOP_64:
#else
a2354 1
#endif
a2356 4
#ifdef VIOCGETCELL_32
    case VIOCGETCELL_32:
    case VIOCGETCELL_64:
#else
d2358 2
a2359 27
#endif
	return vioc_get_cell(fd, h, size);
#ifdef VIOC_GETCELLSTATUS_32
    case VIOC_GETCELLSTATUS_32:
    case VIOC_GETCELLSTATUS_64:
#else
    case VIOC_GETCELLSTATUS:
#endif
	return vioc_get_cellstatus(fd, h, size);
#ifdef VIOC_SETCELLSTATUS_32
    case VIOC_SETCELLSTATUS_32:
    case VIOC_SETCELLSTATUS_64:
#else
    case VIOC_SETCELLSTATUS:
#endif
	return vioc_set_cellstatus(fd, h, size);
#ifdef VIOCNEWCELL_32
    case VIOCNEWCELL_32:
    case VIOCNEWCELL_64:
#else
    case VIOCNEWCELL:
#endif
	return vioc_new_cell(fd, h, size);
#ifdef VIOC_VENUSLOG_32
    case VIOC_VENUSLOG_32:
    case VIOC_VENUSLOG_64:
#else
d2361 11
a2371 2
#endif
	error = viocvenuslog (fd, h, size);
d2373 60
a2432 28
#ifdef VIOC_AFS_SYSNAME_32
    case VIOC_AFS_SYSNAME_32:
    case VIOC_AFS_SYSNAME_64:
#else
    case VIOC_AFS_SYSNAME:
#endif
	return vioc_afs_sysname (fd, h, size);
#ifdef VIOC_FILE_CELL_NAME_32
    case VIOC_FILE_CELL_NAME_32:
    case VIOC_FILE_CELL_NAME_64:
#else
    case VIOC_FILE_CELL_NAME:
#endif
	return viocfilecellname (fd, h, size);
#ifdef VIOC_GET_WS_CELL_32
    case VIOC_GET_WS_CELL_32:
    case VIOC_GET_WS_CELL_64:
#else
    case VIOC_GET_WS_CELL:
#endif
	return viocgetwscell (fd, h, size);
#ifdef VIOCSETCACHESIZE_32
    case VIOCSETCACHESIZE_32:
    case VIOCSETCACHESIZE_64:
#else
    case VIOCSETCACHESIZE:
#endif
	error = viocsetcachesize (fd, h, size);
d2434 5
a2438 27
#ifdef VIOCCKSERV_32
    case VIOCCKSERV_32:
    case VIOCCKSERV_64:
#else
    case VIOCCKSERV:
#endif
	return viocckserv (fd, h, size);
#ifdef VIOCGETCACHEPARAMS_32
    case VIOCGETCACHEPARAMS_32:
    case VIOCGETCACHEPARAMS_64:
#else
    case VIOCGETCACHEPARAMS:
#endif
	return viocgetcacheparms (fd, h, size);
#ifdef VIOC_GETRXKCRYPT_32
    case VIOC_GETRXKCRYPT_32:
    case VIOC_GETRXKCRYPT_64:
#else
    case VIOC_GETRXKCRYPT:
#endif
	return getrxkcrypt(fd, h, size);
#ifdef VIOC_SETRXKCRYPT_32
    case VIOC_SETRXKCRYPT_32:
    case VIOC_SETRXKCRYPT_64:
#else
    case VIOC_SETRXKCRYPT:
#endif
a2440 4
#ifdef VIOC_FPRIOSTATUS_32
    case VIOC_FPRIOSTATUS_32:
    case VIOC_FPRIOSTATUS_64:
#else
a2441 1
#endif
a2443 53
#ifdef VIOC_AVIATOR_32
    case VIOC_AVIATOR_32:
    case VIOC_AVIATOR_64:
#else
    case VIOC_AVIATOR:
#endif
	return viocaviator (fd, h, size);
#ifdef VIOC_ARLADEBUG_32
    case VIOC_ARLADEBUG_32:
    case VIOC_ARLADEBUG_64:
#else
    case VIOC_ARLADEBUG:
#endif
	return vioc_arladebug (fd, h, size);
#ifdef VIOC_GCPAGS_32
    case VIOC_GCPAGS_32:
    case VIOC_GCPAGS_64:
#else
    case VIOC_GCPAGS:
#endif
	error = vioc_gcpags (fd, h, size);
	break;
#ifdef VIOC_CALCULATE_CACHE_32
    case VIOC_CALCULATE_CACHE_32:
    case VIOC_CALCULATE_CACHE_64:
#else
    case VIOC_CALCULATE_CACHE:
#endif
	return vioc_calculate_cache (fd, h, size);
#ifdef VIOC_BREAKCALLBACK_32
    case VIOC_BREAKCALLBACK_32:
    case VIOC_BREAKCALLBACK_64:
#else
    case VIOC_BREAKCALLBACK:
#endif	
	error = vioc_breakcallback (fd, h, size);
	break;
#ifdef VIOCCKBACK_32
    case VIOCCKBACK_32 :
    case VIOCCKBACK_64 :
#else
    case VIOCCKBACK :
#endif
	break;

#ifdef VIOCCKBACK_32
    case AIOC_STATISTICS_32:
    case AIOC_STATISTICS_64:
#else
    case AIOC_STATISTICS:
#endif
	return aioc_statistics (fd, h, size);

a2452 1

@


1.1.1.3
log
@Import of arla -current as of Aug 5 2003

ok todd@@ deraadt@@
@
text
@d2 1
a2 1
 * Copyright (c) 1995-2003 Kungliga Tekniska Högskolan
d35 1
a35 1
RCSID("$arla: messages.c,v 1.318 2003/06/10 04:23:31 lha Exp $");
d37 1
a37 1
#include <nnpfs/nnpfs_message.h>
d46 3
a48 2
static int 
nnpfs_message_getroot (int, struct nnpfs_message_getroot*, u_int);
d51 1
a51 1
nnpfs_message_getnode (int, struct nnpfs_message_getnode*, u_int);
d54 1
a54 1
nnpfs_message_getattr (int, struct nnpfs_message_getattr*, u_int);
d57 1
a57 1
nnpfs_message_open (int, struct nnpfs_message_open*, u_int);
d60 1
a60 1
nnpfs_message_getdata (int, struct nnpfs_message_getdata*, u_int);
d63 1
a63 1
nnpfs_message_inactivenode (int,struct nnpfs_message_inactivenode*,u_int);
d66 1
a66 1
nnpfs_message_putdata (int fd, struct nnpfs_message_putdata *h, u_int size);
d69 1
a69 1
nnpfs_message_putattr (int fd, struct nnpfs_message_putattr *h, u_int size);
d72 1
a72 1
nnpfs_message_create (int fd, struct nnpfs_message_create *h, u_int size);
d75 1
a75 1
nnpfs_message_mkdir (int fd, struct nnpfs_message_mkdir *h, u_int size);
d78 1
a78 1
nnpfs_message_link (int fd, struct nnpfs_message_link *h, u_int size);
d81 1
a81 1
nnpfs_message_symlink (int fd, struct nnpfs_message_symlink *h, u_int size);
d84 1
a84 1
nnpfs_message_remove (int fd, struct nnpfs_message_remove *h, u_int size);
d87 1
a87 1
nnpfs_message_rmdir (int fd, struct nnpfs_message_rmdir *h, u_int size);
d90 1
a90 1
nnpfs_message_rename (int fd, struct nnpfs_message_rename *h, u_int size);
d93 2
a94 1
nnpfs_message_pioctl (int fd, struct nnpfs_message_pioctl *h, u_int size) ;
d96 29
a124 2
static u_char
afsrights2nnpfsrights(u_long, uint32_t, uint32_t);
a125 2
static int
possibly_have_network(void);
d128 1
a128 1
 *
d131 10
a140 29
nnpfs_message_function rcvfuncs[] = {
    NULL,						/* version */
    (nnpfs_message_function)nnpfs_message_wakeup,	/* wakeup */
    (nnpfs_message_function)nnpfs_message_getroot,	/* getroot */
    NULL,						/* installroot */
    (nnpfs_message_function)nnpfs_message_getnode, 	/* getnode */
    NULL,						/* installnode */
    (nnpfs_message_function)nnpfs_message_getattr,	/* getattr */
    NULL,						/* installattr */
    (nnpfs_message_function)nnpfs_message_getdata,	/* getdata */
    NULL,						/* installdata */
    (nnpfs_message_function)nnpfs_message_inactivenode,	/* inactivenode */
    NULL,						/* invalidnode */
    (nnpfs_message_function)nnpfs_message_open,		/* open */
    (nnpfs_message_function)nnpfs_message_putdata,      /* put_data */
    (nnpfs_message_function)nnpfs_message_putattr,      /* put attr */
    (nnpfs_message_function)nnpfs_message_create,       /* create */
    (nnpfs_message_function)nnpfs_message_mkdir,	/* mkdir */
    (nnpfs_message_function)nnpfs_message_link,		/* link */
    (nnpfs_message_function)nnpfs_message_symlink,      /* symlink */
    (nnpfs_message_function)nnpfs_message_remove,	/* remove */
    (nnpfs_message_function)nnpfs_message_rmdir,	/* rmdir */
    (nnpfs_message_function)nnpfs_message_rename,	/* rename */
    (nnpfs_message_function)nnpfs_message_pioctl,	/* pioctl */
    NULL,	                                        /* wakeup_data */
    NULL,						/* updatefid */
    NULL,						/* advlock */
    NULL						/* gc nodes */
};
d154 1
a154 2
 * AFSFetchStatus -> nnpfs_attr
 * Setting everything except for length and mode.
d158 33
a190 53
afsstatus2nnpfs_attr (AFSFetchStatus *status,
		      const VenusFid *fid,
		      struct nnpfs_attr *attr,
		      int flags)
{
    int mode;

    attr->valid = XA_V_NONE;
    switch (status->FileType) {
    case TYPE_FILE :
	mode = S_IFREG;
	XA_SET_TYPE(attr, NNPFS_FILE_REG);
	break;
    case TYPE_DIR :
	mode = S_IFDIR;
	XA_SET_TYPE(attr, NNPFS_FILE_DIR);
	break;
    case TYPE_LINK :
	mode = S_IFLNK;
	XA_SET_TYPE(attr, NNPFS_FILE_LNK);
	break;
    default :
	arla_warnx (ADEBMSG, "afsstatus2nnpfs_attr: default");
	abort ();
    }
    XA_SET_NLINK(attr, status->LinkCount);
    if (flags & FCACHE2NNPFSNODE_LENGTH)
	XA_SET_SIZE(attr, status->Length);
    XA_SET_UID(attr,status->Owner);
    XA_SET_GID(attr, status->Group);
    XA_SET_ATIME(attr, status->ClientModTime);
    XA_SET_MTIME(attr, status->ClientModTime);
    XA_SET_CTIME(attr, status->ClientModTime);
    XA_SET_FILEID(attr, afsfid2inode(fid));

    /* XXX this is wrong, need to keep track of `our` ae for this req */
    if (fake_stat) {
	u_char rights;
	
	rights = afsrights2nnpfsrights(status->CallerAccess,
				       status->FileType,
				       status->UnixModeBits);
	
	if (rights & NNPFS_RIGHT_R)
	    mode |= 0444;
	if (rights & NNPFS_RIGHT_W)
	    mode |= 0222;
	if (rights & NNPFS_RIGHT_X)
	    mode |= 0111;
    } else
	mode |= status->UnixModeBits;

    XA_SET_MODE(attr, mode);
d201 1
a201 1
afsrights2nnpfsrights(u_long ar, uint32_t FileType, uint32_t UnixModeBits)
d207 1
a207 1
	    ret |= NNPFS_RIGHT_R | NNPFS_RIGHT_X;
d209 1
a209 1
	    ret |= NNPFS_RIGHT_W;
d212 1
a212 1
	    ret |= NNPFS_RIGHT_R;
d214 1
a214 1
	    ret |= NNPFS_RIGHT_R;
d216 1
a216 1
	    ret |= NNPFS_RIGHT_W;
d218 1
a218 1
	    ret |= NNPFS_RIGHT_X;
d225 6
a230 6
fcacheentry2nnpfsnode (const VenusFid *fid,
		       const VenusFid *statfid, 
		       AFSFetchStatus *status,
		       struct nnpfs_msg_node *node,
		       AccessEntry *ae,
		       int flags)
d235 12
a246 11

    afsstatus2nnpfs_attr (status, statfid, &node->attr, flags);

    node->anonrights = afsrights2nnpfsrights(status->AnonymousAccess,
					     status->FileType,
					     status->UnixModeBits);
    for (i = 0; i < NACCESS; i++) {
	node->id[i] = ae[i].cred;
	node->rights[i] = afsrights2nnpfsrights(ae[i].access,
						status->FileType,
						status->UnixModeBits);
d255 2
a256 2
nnpfs_attr2afsstorestatus(struct nnpfs_attr *xa,
			  AFSStoreStatus *storestatus)
d291 1
a291 1
try_again (int *ret, CredCacheEntry **ce, nnpfs_cred *cred, const VenusFid *fid)
a295 2
    case RXKADBADTICKET:
    case RXKADBADKEY:
d320 1
a320 1
	if (fid && !volcache_reliablep (fid->fid.Volume, fid->Cell)) {
d362 2
a363 4
message_get_data (FCacheEntry **entry,
		  struct nnpfs_cred *cred,
		  CredCacheEntry **ce,
		  size_t wanted_length)
d367 2
a368 2
	ret = fcache_get_data (entry, ce, wanted_length);
    } while (try_again (&ret, ce, cred, &(*entry)->fid));
d377 1
a377 1
nnpfs_message_getroot (int fd, struct nnpfs_message_getroot *h, u_int size)
d379 140
a518 22
    struct nnpfs_message_installroot msg;
    int ret = 0;
    VenusFid root_fid;
    CredCacheEntry *ce;
    AccessEntry *ae;
    FCacheEntry *entry = NULL;
    struct nnpfs_message_header *h0 = NULL;
    size_t h0_len = 0;
    int32_t cell_id = cell_name2num(cell_getthiscell());

    ce = cred_get (cell_id, h->cred.pag, CRED_ANY);
    assert (ce != NULL);
    do {
	ret = getroot (&root_fid, ce);
    } while (try_again (&ret, &ce, &h->cred, &root_fid));

    if (ret)
	goto out;

    ret = fcache_get(&entry, root_fid, ce);
    if (ret)
	goto out;
d520 12
a531 3
    do {
	ret = cm_getattr(entry, ce, &ae);
    } while (try_again (&ret, &ce, &h->cred, &root_fid));
d533 1
a533 158
    if (ret == 0) {
	fcacheentry2nnpfsnode (&root_fid, fcache_realfid(entry),
			       &entry->status, &msg.node, ae,
			       FCACHE2NNPFSNODE_ALL);

	entry->tokens |= NNPFS_ATTR_R;
	msg.node.tokens = entry->tokens & ~NNPFS_DATA_MASK;
	msg.header.opcode = NNPFS_MSG_INSTALLROOT;
	h0 = (struct nnpfs_message_header *)&msg;
	h0_len = sizeof(msg);
    }

 out:
    nnpfs_send_message_wakeup_multiple (fd,
					h->header.sequence_num,
					ret,
					h0, h0_len,
					NULL, 0);
    if (entry)
	fcache_release(entry);
    cred_free (ce);

    return 0;
}

static int
nnpfs_message_getnode (int fd, struct nnpfs_message_getnode *h, u_int size)
{
    struct nnpfs_message_installnode msg;
    VenusFid *dirfid = (VenusFid *)&h->parent_handle;
    VenusFid fid;
    VenusFid real_fid;
    AFSFetchStatus status;
    CredCacheEntry *ce;
    AccessEntry *ae;
    FCacheEntry *entry = NULL;
    FCacheEntry *dentry = NULL;
    struct nnpfs_message_header *h0 = NULL;
    size_t h0_len = 0;
    int ret;

    arla_warnx (ADEBMSG, "getnode (%ld.%lu.%lu.%lu) \"%s\"",
		(long)dirfid->Cell, (unsigned long)dirfid->fid.Volume,
		(unsigned long)dirfid->fid.Vnode,
		(unsigned long)dirfid->fid.Unique, h->name);

    ce = cred_get (dirfid->Cell, h->cred.pag, CRED_ANY);
    assert (ce != NULL);

    ret = fcache_get(&dentry, *dirfid, ce);
    if (ret)
	goto out;

    assert_flag(dentry,kernelp);
     
    do {
	ret = cm_lookup (&dentry, h->name, &fid, &ce, TRUE);
	*dirfid = dentry->fid;
    } while (try_again (&ret, &ce, &h->cred, dirfid));

    if (ret)
	goto out;

    fcache_release(dentry);
    dentry = NULL;

    ret = fcache_get(&entry, fid, ce);
    if (ret)
	goto out;

    do {
	ret = cm_getattr (entry, ce, &ae);
	status = entry->status;
	real_fid = *fcache_realfid(entry);
    } while (try_again (&ret, &ce, &h->cred, &fid));

    if (ret == 0) {
	fcacheentry2nnpfsnode (&fid, &real_fid, &status, &msg.node, ae,
			       FCACHE2NNPFSNODE_ALL);

	entry->tokens |= NNPFS_ATTR_R;
	msg.node.tokens = entry->tokens & ~NNPFS_DATA_MASK;
	msg.parent_handle = h->parent_handle;
	strlcpy (msg.name, h->name, sizeof(msg.name));

	msg.header.opcode = NNPFS_MSG_INSTALLNODE;
	h0 = (struct nnpfs_message_header *)&msg;
	h0_len = sizeof(msg);
    }
 out:
    nnpfs_send_message_wakeup_multiple (fd,
					h->header.sequence_num,
					ret,
					h0, h0_len,
					NULL, 0);
    if (entry)
	fcache_release(entry);
    if (dentry)
	fcache_release(dentry);
    cred_free (ce);

    return 0;
}

static int
nnpfs_message_getattr (int fd, struct nnpfs_message_getattr *h, u_int size)
{
    struct nnpfs_message_installattr msg;
    VenusFid fid;
    CredCacheEntry *ce;
    AccessEntry *ae;
    FCacheEntry *entry = NULL;
    struct nnpfs_message_header *h0 = NULL;
    size_t h0_len = 0;
    int ret;

    fid = *(VenusFid *)&h->handle;
    arla_warnx (ADEBMSG, "getattr (%ld.%lu.%lu.%lu)",
		(long)fid.Cell, (unsigned long)fid.fid.Volume,
		(unsigned long)fid.fid.Vnode,
		(unsigned long)fid.fid.Unique);
    ce = cred_get (fid.Cell, h->cred.pag, CRED_ANY);
    assert (ce != NULL);

    ret = fcache_get(&entry, fid, ce);
    if (ret)
	goto out;

    assert_flag(entry,kernelp);

    do {
	ret = cm_getattr (entry, ce, &ae);
    } while (try_again (&ret, &ce, &h->cred, &fid));

    if (ret)
	goto out;

    fcacheentry2nnpfsnode (&fid, fcache_realfid(entry),
			   &entry->status, &msg.node, ae,
			   FCACHE2NNPFSNODE_ALL);
     
    entry->tokens |= NNPFS_ATTR_R;
    msg.node.tokens = entry->tokens;
    msg.header.opcode = NNPFS_MSG_INSTALLATTR;
    h0 = (struct nnpfs_message_header *)&msg;
    h0_len = sizeof(msg);

 out:
    nnpfs_send_message_wakeup_multiple (fd,
					h->header.sequence_num,
					ret,
					h0, h0_len,
					NULL, 0);
    if (entry)
	fcache_release(entry);
    cred_free (ce);

    return 0;
d537 1
a537 1
nnpfs_message_putattr (int fd, struct nnpfs_message_putattr *h, u_int size)
d539 79
a617 95
    struct nnpfs_message_installattr msg;
    VenusFid fid;
    AFSStoreStatus status;
    CredCacheEntry *ce;
    AccessEntry *ae;
    struct nnpfs_message_header *h0 = NULL;
    size_t h0_len = 0;
    int ret;

    FCacheEntry *entry = NULL;

    fid = *(VenusFid *)&h->handle;
    arla_warnx (ADEBMSG, "putattr (%ld.%lu.%lu.%lu)",
		(long)fid.Cell, (unsigned long)fid.fid.Volume,
		(unsigned long)fid.fid.Vnode,
		(unsigned long)fid.fid.Unique);
    nnpfs_attr2afsstorestatus(&h->attr, &status);
    ce = cred_get (fid.Cell, h->cred.pag, CRED_ANY);
    assert (ce != NULL);

    if (connected_mode != CONNECTED) {
	ret = fcache_find (&entry, fid);
	if (ret) {
	    ret = ENETDOWN;
	    goto out;
	}
    } else {
	ret = fcache_get(&entry, fid, ce);
	if (ret)
	    goto out;
    }

    assert_flag(entry,kernelp);

    /* 
     * We can't bits update at the same time as same time as we store
     * data since then fileserver will hate us with we are part of
     * system:administrators. This was fixed in openafs-1.2.7
     */

    if (XA_VALID_SIZE(&h->attr)) {
	AFSStoreStatus null_status;
	memset(&null_status, 0, sizeof(null_status));
	do {
	    ret = cm_ftruncate (entry, h->attr.xa_size, &status, ce);
	} while (try_again (&ret, &ce, &h->cred, &fid));
    }

    if (ret)
	goto out;

    if (status.Mask) {
	do {
	    ret = cm_setattr(entry, &status, ce);
	} while (try_again (&ret, &ce, &h->cred, &fid));
    }

    if (ret)
	goto out;

    do {
	ret = cm_getattr (entry, ce, &ae);
    } while (try_again (&ret, &ce, &h->cred, &fid));

     
    if (ret)
	goto out;
     
    fcacheentry2nnpfsnode (&fid, fcache_realfid(entry),
			   &entry->status, &msg.node, ae,
			   FCACHE2NNPFSNODE_ALL);
     
    entry->tokens |= NNPFS_ATTR_R;
    msg.node.tokens  = entry->tokens;
    msg.header.opcode = NNPFS_MSG_INSTALLATTR;
    h0 = (struct nnpfs_message_header *)&msg;
    h0_len = sizeof(msg);

    if (ret)
	goto out;

    if (connected_mode != CONNECTED)
	entry->disco_id = disco_store_status(&fid, &status, entry->disco_id);

 out:
    nnpfs_send_message_wakeup_multiple (fd,
					h->header.sequence_num, 
					ret,
					h0, h0_len,
					NULL, 0);
    if (entry)
	fcache_release(entry);
    cred_free (ce);

    return 0;
d621 1
a621 1
nnpfs_message_create (int fd, struct nnpfs_message_create *h, u_int size)
d623 85
a707 57
    VenusFid parent_fid, child_fid;
    AFSStoreStatus store_status;
    AFSFetchStatus fetch_status;
    CredCacheEntry *ce;
    int ret;
    struct nnpfs_message_installdata msg1;
    struct nnpfs_message_installnode msg2;
    struct nnpfs_message_installdata msg3;
    struct nnpfs_message_header *h0 = NULL;
    size_t h0_len = 0;
    struct nnpfs_message_header *h1 = NULL;
    size_t h1_len = 0;
    struct nnpfs_message_header *h2 = NULL;
    size_t h2_len = 0;
    FCacheEntry *dir_entry   = NULL;
    FCacheEntry *child_entry = NULL;
    fcache_cache_handle cache_handle;

    parent_fid = *(VenusFid *)&h->parent_handle;
    arla_warnx (ADEBMSG, "create (%ld.%lu.%lu.%lu) \"%s\"",
		(long)parent_fid.Cell,
		(unsigned long)parent_fid.fid.Volume,
		(unsigned long)parent_fid.fid.Vnode,
		(unsigned long)parent_fid.fid.Unique, h->name);

    nnpfs_attr2afsstorestatus(&h->attr, &store_status);
    if (connected_mode != CONNECTED) {
	if (!(store_status.Mask & SS_OWNER)) {
	    store_status.Owner = h->cred.uid;
	    store_status.Mask |= SS_OWNER;
	}
	if (!(store_status.Mask & SS_GROUP)) {
	    store_status.Group = 0;
	    store_status.Mask |= SS_GROUP;
	}
	if (!(store_status.Mask & SS_MODTIME)) {
	    struct timeval now;

	    gettimeofday (&now, NULL);

	    store_status.ClientModTime = now.tv_sec;
	    store_status.Mask |= SS_MODTIME;
	}
    }
    ce = cred_get (parent_fid.Cell, h->cred.pag, CRED_ANY);
    assert (ce != NULL);

    ret = fcache_get(&dir_entry, parent_fid, ce);
    if (ret)
	goto out;

    assert_flag(dir_entry,kernelp);

    do {
	ret = cm_create(&dir_entry, h->name, &store_status,
			&child_fid, &fetch_status, &ce);
    } while (try_again (&ret, &ce, &h->cred, &dir_entry->fid));
d709 2
a710 42
    if (ret)
	goto out;
     
    ret = message_get_data (&dir_entry, &h->cred, &ce, 0);
    if (ret)
	goto out;

    ret = conv_dir (dir_entry, ce, 0,
		    &cache_handle,
		    msg1.cache_name,
		    sizeof(msg1.cache_name));
    if (ret)
	goto out;

    msg1.cache_handle = cache_handle.nnpfs_handle;
    msg1.flag = 0;
    if (cache_handle.valid)
	msg1.flag |= NNPFS_ID_HANDLE_VALID;
     
    dir_entry->tokens |= NNPFS_ATTR_R;
    msg1.node.tokens = dir_entry->tokens;
     
    fcacheentry2nnpfsnode (&dir_entry->fid,
			   fcache_realfid(dir_entry),
			   &dir_entry->status,
			   &msg1.node, 
			   dir_entry->acccache,
			   FCACHE2NNPFSNODE_ALL);
     
    ret = fcache_get(&child_entry, child_fid, ce);
    if (ret)
	goto out;
    /* XXX remove this, we don't want to fetch data from the fileserver */
    ret = message_get_data (&child_entry, &h->cred, &ce, 0);
    if (ret) {
	fcache_release(child_entry);
	goto out;
    }
    child_fid = child_entry->fid;
     
    msg3.cache_handle = child_entry->handle.nnpfs_handle;
    fcache_conv_file_name (child_entry,
d712 11
a722 36
    msg3.flag = 0;
    if (cache_handle.valid)
	msg3.flag |= NNPFS_ID_HANDLE_VALID;
     
    child_entry->flags.kernelp = TRUE;
    child_entry->flags.attrusedp = TRUE;
    child_entry->flags.datausedp = TRUE;
    assert_flag(dir_entry,kernelp);
    assert_flag(dir_entry,attrusedp);
    dir_entry->flags.datausedp = TRUE;
     
    msg1.offset = child_entry->fetched_length;
    msg1.header.opcode = NNPFS_MSG_INSTALLDATA;
    h0 = (struct nnpfs_message_header *)&msg1;
    h0_len = sizeof(msg1);
     
    fcacheentry2nnpfsnode (&child_fid, &child_fid,
			   &fetch_status, &msg2.node, dir_entry->acccache,
			   FCACHE2NNPFSNODE_ALL);
     
    child_entry->tokens |= NNPFS_ATTR_R | NNPFS_DATA_R | NNPFS_DATA_W;
    msg2.node.tokens   = child_entry->tokens & ~(NNPFS_DATA_MASK);
    msg2.parent_handle = h->parent_handle;
    strlcpy (msg2.name, h->name, sizeof(msg2.name));
     
    msg2.header.opcode = NNPFS_MSG_INSTALLNODE;
    h1 = (struct nnpfs_message_header *)&msg2;
    h1_len = sizeof(msg2);
     
    msg3.node          = msg2.node;
    msg3.node.tokens	= child_entry->tokens;
    msg3.offset        = child_entry->fetched_length;
    msg3.header.opcode = NNPFS_MSG_INSTALLDATA;
     
    h2 = (struct nnpfs_message_header *)&msg3;
    h2_len = sizeof(msg3);
d724 51
a774 17
    if (connected_mode != CONNECTED)
	child_entry->disco_id = disco_create_file(&parent_fid, &child_fid,
						  h->name, &store_status);

 out:
    nnpfs_send_message_wakeup_multiple (fd,
					h->header.sequence_num,
					ret,
					h0, h0_len,
					h1, h1_len,
					h2, h2_len,
					NULL, 0);
    if (dir_entry)
	fcache_release(dir_entry);
    if (child_entry)
	fcache_release(child_entry);
    cred_free (ce);
d776 1
a776 1
    return ret;
d780 1
a780 1
nnpfs_message_mkdir (int fd, struct nnpfs_message_mkdir *h, u_int size)
d782 23
a804 18
    VenusFid parent_fid, child_fid;
    AFSStoreStatus store_status;
    AFSFetchStatus fetch_status;
    CredCacheEntry *ce;
    int ret;
    struct nnpfs_message_installdata msg1;
    struct nnpfs_message_installnode msg2;
    struct nnpfs_message_installdata msg3;
    FCacheEntry *dir_entry = NULL;
    FCacheEntry *child_entry = NULL;

    struct nnpfs_message_header *h0 = NULL;
    size_t h0_len = 0;
    struct nnpfs_message_header *h1 = NULL;
    size_t h1_len = 0;
    struct nnpfs_message_header *h2 = NULL;
    size_t h2_len = 0;
    fcache_cache_handle cache_handle;
d807 1
a807 1
    parent_fid = *fid_translate((VenusFid *)&h->parent_handle);
d809 1
a809 1
    parent_fid = *(VenusFid *)&h->parent_handle;
d811 23
a833 4
    arla_warnx (ADEBMSG, "mkdir (%ld.%lu.%lu.%lu) \"%s\"",
		(long)parent_fid.Cell, (unsigned long)parent_fid.fid.Volume,
		(unsigned long)parent_fid.fid.Vnode,
		(unsigned long)parent_fid.fid.Unique, h->name);
d835 55
a889 2
    ce = cred_get (parent_fid.Cell, h->cred.pag, CRED_ANY);
    assert (ce != NULL);
d891 6
a896 10
    nnpfs_attr2afsstorestatus(&h->attr, &store_status);
    if (connected_mode != CONNECTED) {
	if (!(store_status.Mask & SS_OWNER)) {
	    store_status.Owner = h->cred.uid;
	    store_status.Mask |= SS_OWNER;
	}
	if (!(store_status.Mask & SS_MODTIME)) {
	    struct timeval now;

	    gettimeofday (&now, NULL);
d898 1
a898 10
	    store_status.ClientModTime = now.tv_sec;
	    store_status.Mask |= SS_MODTIME;
	}
    }

    ret = fcache_get(&dir_entry, parent_fid, ce);
    if (ret)
	goto out;
     
    assert_flag(dir_entry,kernelp);
d900 44
a943 104
    do {
	ret = cm_mkdir(&dir_entry, h->name, &store_status,
		       &child_fid, &fetch_status, &ce);
    } while(try_again (&ret, &ce, &h->cred, &dir_entry->fid));

    if (ret)
	goto out;

    ret = message_get_data (&dir_entry, &h->cred, &ce, 0);
    if (ret)
	goto out;

    ret = conv_dir (dir_entry, ce, 0,
		    &cache_handle,
		    msg1.cache_name,
		    sizeof(msg1.cache_name));
    if (ret)
	goto out;

    msg1.cache_handle = cache_handle.nnpfs_handle;
    msg1.flag = 0;
    if (cache_handle.valid)
	msg1.flag |= NNPFS_ID_HANDLE_VALID;
    dir_entry->tokens |= NNPFS_ATTR_R;
    msg1.node.tokens = dir_entry->tokens;
     
    fcacheentry2nnpfsnode (&dir_entry->fid,
			   fcache_realfid(dir_entry),
			   &dir_entry->status, &msg1.node, 
			   dir_entry->acccache,
			   FCACHE2NNPFSNODE_ALL);
     
    msg1.offset = dir_entry->fetched_length;
    msg1.header.opcode = NNPFS_MSG_INSTALLDATA;
    h0 = (struct nnpfs_message_header *)&msg1;
    h0_len = sizeof(msg1);
     
    ret = fcache_get(&child_entry, child_fid, ce);
    if (ret)
	goto out;
    ret = message_get_data (&child_entry, &h->cred, &ce, 0);
    if (ret)
	goto out;

    child_fid = child_entry->fid;
     
    ret = conv_dir (child_entry, ce, 0,
		    &cache_handle,
		    msg3.cache_name,
		    sizeof(msg3.cache_name));
    if (ret)
	goto out;

    msg3.cache_handle = cache_handle.nnpfs_handle;
    msg3.flag = 0;
    if (cache_handle.valid)
	msg3.flag |= NNPFS_ID_HANDLE_VALID;
     
    assert_flag(child_entry,kernelp);
    child_entry->flags.attrusedp = TRUE;
    child_entry->flags.datausedp = TRUE;
    assert_flag(dir_entry,kernelp);
    assert_flag(dir_entry,attrusedp);
    dir_entry->flags.datausedp = TRUE;
     
    child_entry->tokens |= NNPFS_ATTR_R;
    msg2.node.tokens = child_entry->tokens & ~(NNPFS_DATA_MASK);
     
    fcacheentry2nnpfsnode (&child_fid, &child_fid,
			   &child_entry->status, &msg2.node,
			   dir_entry->acccache,
			   FCACHE2NNPFSNODE_ALL);
     
    msg2.parent_handle = h->parent_handle;
    strlcpy (msg2.name, h->name, sizeof(msg2.name));
     
    msg2.header.opcode = NNPFS_MSG_INSTALLNODE;
    h1 = (struct nnpfs_message_header *)&msg2;
    h1_len = sizeof(msg2);
     
    msg3.header.opcode = NNPFS_MSG_INSTALLDATA;
    msg3.offset = child_entry->fetched_length;
    msg3.node = msg2.node;
    msg3.node.tokens = child_entry->tokens;
    h2 = (struct nnpfs_message_header *)&msg3;
    h2_len = sizeof(msg3);

    if (connected_mode != CONNECTED)
	child_entry->disco_id = disco_create_dir(&parent_fid, &child_fid, 
						 h->name, &store_status);

 out:
    nnpfs_send_message_wakeup_multiple (fd,
					h->header.sequence_num,
					ret,
					h0, h0_len,
					h1, h1_len,
					h2, h2_len,
					NULL, 0); 
   if (child_entry) 
	fcache_release(child_entry);
    if (dir_entry)
	fcache_release(dir_entry);
    cred_free (ce);
d945 1
a945 1
    return ret;
d949 1
a949 1
nnpfs_message_link (int fd, struct nnpfs_message_link *h, u_int size)
d951 62
a1012 27
    VenusFid parent_fid, existing_fid;
    AFSFetchStatus fetch_status;
    CredCacheEntry *ce;
    int ret;
    struct nnpfs_message_installdata msg1;
    struct nnpfs_message_installnode msg2;
    struct nnpfs_message_header *h0 = NULL;
    size_t h0_len = 0;
    struct nnpfs_message_header *h1 = NULL;
    size_t h1_len = 0;
    fcache_cache_handle cache_handle;
    FCacheEntry *dir_entry = NULL;

    parent_fid   = *(VenusFid *)&h->parent_handle;
    existing_fid = *(VenusFid *)&h->from_handle;
    arla_warnx (ADEBMSG, "link (%ld.%lu.%lu.%lu) (%ld.%lu.%lu.%lu) \"%s\"",
		(long)parent_fid.Cell, (unsigned long)parent_fid.fid.Volume,
		(unsigned long)parent_fid.fid.Vnode,
		(unsigned long)parent_fid.fid.Unique,
		(long)existing_fid.Cell,
		(unsigned long)existing_fid.fid.Volume,
		(unsigned long)existing_fid.fid.Vnode,
		(unsigned long)existing_fid.fid.Unique,
		h->name);

    ce = cred_get (parent_fid.Cell, h->cred.pag, CRED_ANY);
    assert (ce != NULL);
d1014 33
a1046 3
    ret = fcache_get(&dir_entry, parent_fid, ce);
    if (ret)
	goto out;
d1048 1
a1048 67
    assert_flag(dir_entry,kernelp);

    do {
	ret = cm_link (&dir_entry, h->name, existing_fid,
		       &fetch_status, &ce);
    } while (try_again (&ret, &ce, &h->cred, &dir_entry->fid));

    if (ret)
	goto out;

    ret = message_get_data (&dir_entry, &h->cred, &ce, 0);
    if (ret)
	goto out;

    ret = conv_dir (dir_entry, ce, 0,
		    &cache_handle,
		    msg1.cache_name,
		    sizeof(msg1.cache_name));
    if (ret == -1)
	goto out;

    msg1.cache_handle = cache_handle.nnpfs_handle;
    msg1.flag = 0;
    if (cache_handle.valid)
	msg1.flag |= NNPFS_ID_HANDLE_VALID;
    dir_entry->tokens |= NNPFS_ATTR_R;
    msg1.node.tokens = dir_entry->tokens;
    assert_flag(dir_entry,kernelp);
    assert_flag(dir_entry,attrusedp);
    dir_entry->flags.datausedp = TRUE;
     
    fcacheentry2nnpfsnode (&dir_entry->fid,
			   fcache_realfid(dir_entry),
			   &dir_entry->status, &msg1.node,
			   dir_entry->acccache,
			   FCACHE2NNPFSNODE_ALL);
     
    msg1.offset = dir_entry->fetched_length;
    msg1.header.opcode = NNPFS_MSG_INSTALLDATA;
    h0 = (struct nnpfs_message_header *)&msg1;
    h0_len = sizeof(msg1);
     
    fcacheentry2nnpfsnode (&existing_fid, &existing_fid,
			   &fetch_status, &msg2.node,
			   dir_entry->acccache,
			   FCACHE2NNPFSNODE_ALL);
     
    msg2.node.tokens   = NNPFS_ATTR_R; /* XXX */
    msg2.parent_handle = h->parent_handle;
    strlcpy (msg2.name, h->name, sizeof(msg2.name));
     
    msg2.header.opcode = NNPFS_MSG_INSTALLNODE;
    h1 = (struct nnpfs_message_header *)&msg2;
    h1_len = sizeof(msg2);

 out:
    nnpfs_send_message_wakeup_multiple (fd,
					h->header.sequence_num,
					ret,
					h0, h0_len,
					h1, h1_len,
					NULL, 0);
    if (dir_entry)
	fcache_release(dir_entry);
    cred_free (ce);

    return ret;
d1052 1
a1052 1
nnpfs_message_symlink (int fd, struct nnpfs_message_symlink *h, u_int size)
d1054 62
a1115 490
    VenusFid parent_fid, child_fid, real_fid;
    AFSStoreStatus store_status;
    AFSFetchStatus fetch_status;
    CredCacheEntry *ce;
    int ret;
    struct nnpfs_message_installdata msg1;
    struct nnpfs_message_installnode msg2;
    struct nnpfs_message_header *h0 = NULL;
    size_t h0_len = 0;
    struct nnpfs_message_header *h1 = NULL;
    size_t h1_len = 0;
    fcache_cache_handle cache_handle;
    FCacheEntry *dir_entry = NULL;

    parent_fid = *(VenusFid *)&h->parent_handle;
    arla_warnx (ADEBMSG, "symlink (%ld.%lu.%lu.%lu) \"%s\"",
		(long)parent_fid.Cell, (unsigned long)parent_fid.fid.Volume,
		(unsigned long)parent_fid.fid.Vnode,
		(unsigned long)parent_fid.fid.Unique, h->name);

    ce = cred_get (parent_fid.Cell, h->cred.pag, CRED_ANY);
    assert (ce != NULL);

    nnpfs_attr2afsstorestatus(&h->attr, &store_status);

    ret = fcache_get(&dir_entry, parent_fid, ce);
    if (ret)
	goto out;

    assert_flag(dir_entry,kernelp);

    do {
	ret = cm_symlink(&dir_entry, h->name, &store_status,
			 &child_fid, &real_fid,
			 &fetch_status,
			 h->contents, &ce);
    } while (try_again (&ret, &ce, &h->cred, &dir_entry->fid));
     
    cred_free (ce);
    ce = cred_get (dir_entry->fid.Cell, h->cred.pag, CRED_ANY);
    assert (ce != NULL);

    if (ret)
	goto out;
     
    ret = message_get_data (&dir_entry, &h->cred, &ce, 0);
    if (ret)
	goto out;

    ret = conv_dir (dir_entry, ce, 0,
		    &cache_handle,
		    msg1.cache_name,
		    sizeof(msg1.cache_name));
    if (ret)
	goto out;

    msg1.cache_handle = cache_handle.nnpfs_handle;
    msg1.flag = 0;
    if (cache_handle.valid)
	msg1.flag |= NNPFS_ID_HANDLE_VALID;
    dir_entry->tokens |= NNPFS_ATTR_R;
    msg1.node.tokens = dir_entry->tokens;
    assert_flag(dir_entry,kernelp);
    assert_flag(dir_entry,attrusedp);
    dir_entry->flags.datausedp = TRUE;
    
    fcacheentry2nnpfsnode (&dir_entry->fid,
			   fcache_realfid(dir_entry),
			   &dir_entry->status, &msg1.node,
			   dir_entry->acccache,
			   FCACHE2NNPFSNODE_ALL);
    
    msg1.offset = dir_entry->fetched_length;
    msg1.header.opcode = NNPFS_MSG_INSTALLDATA;
    h0 = (struct nnpfs_message_header *)&msg1;
    h0_len = sizeof(msg1);
    
    fcacheentry2nnpfsnode (&child_fid, &real_fid,
			   &fetch_status, &msg2.node,
			   dir_entry->acccache,
			   FCACHE2NNPFSNODE_ALL);
    
    msg2.node.tokens   = NNPFS_ATTR_R; /* XXX */
    msg2.parent_handle = h->parent_handle;
    strlcpy (msg2.name, h->name, sizeof(msg2.name));
    
    msg2.header.opcode = NNPFS_MSG_INSTALLNODE;
    h1 = (struct nnpfs_message_header *)&msg2;
    h1_len = sizeof(msg2);
    
 out:
    nnpfs_send_message_wakeup_multiple (fd,
					h->header.sequence_num,
					ret,
					h0, h0_len,
					h1, h1_len,
					NULL, 0);
    if (dir_entry)
	fcache_release(dir_entry);
    cred_free (ce);

    return ret;
}

/* 
 * Handle the NNPFS remove message in `h', that is, remove name
 * `h->name' in directory `h->parent' with the creds from `h->cred'.
 */

static int 
nnpfs_message_remove (int fd, struct nnpfs_message_remove *h, u_int size)
{
    VenusFid parent_fid;
    VenusFid fid;
    CredCacheEntry *ce;
    int ret;
    struct nnpfs_message_installdata msg1;
    struct nnpfs_message_installattr msg2;
    struct nnpfs_message_header *h0 = NULL;
    size_t h0_len = 0;
    struct nnpfs_message_header *h1 = NULL;
    size_t h1_len = 0;
    FCacheEntry *limbo_entry = NULL;
    unsigned link_count;
    FCacheEntry *dir_entry = NULL;
    AFSFetchStatus limbo_status;
    fcache_cache_handle cache_handle;
    
    parent_fid = *(VenusFid *)&h->parent_handle;
    arla_warnx (ADEBMSG, "remove (%ld.%lu.%lu.%lu) \"%s\"",
		(long)parent_fid.Cell, (unsigned long)parent_fid.fid.Volume,
		(unsigned long)parent_fid.fid.Vnode,
		(unsigned long)parent_fid.fid.Unique, h->name);
    
    ce = cred_get (parent_fid.Cell, h->cred.pag, CRED_ANY);
    assert (ce != NULL);
    
    ret = fcache_get(&dir_entry, parent_fid, ce);
    if (ret)
	goto out;
    
    assert_flag(dir_entry,kernelp);
    
    do {
	ret = cm_lookup (&dir_entry, h->name, &fid, &ce, FALSE);
    } while (try_again (&ret, &ce, &h->cred, &dir_entry->fid));
    
    if (ret)
	goto out;

    /*
     * Fetch the linkcount of the to be removed node
     */
    
    ret = fcache_get (&limbo_entry, fid, ce);
    if (ret)
	goto out;
    
    ret = fcache_verify_attr (limbo_entry, dir_entry, h->name, ce);
    if (ret)
	goto out;
    limbo_status = limbo_entry->status;
    link_count   = limbo_status.LinkCount;
    
    fcache_release (limbo_entry);
    limbo_entry = NULL;
    
    /*
     * Do the actual work
     */
    
    do {
	ret = cm_remove(&dir_entry, h->name, &ce);
    } while (try_again (&ret, &ce, &h->cred, &dir_entry->fid));
    
    if (ret)
	goto out;
    
    ret = message_get_data (&dir_entry, &h->cred, &ce, 0);
    if (ret)
	goto out;
    
    if (!dir_entry->flags.extradirp
	|| dir_remove_name (dir_entry, h->name,
			    &cache_handle,
			    msg1.cache_name,
			    sizeof(msg1.cache_name))) {
	ret = conv_dir (dir_entry, ce, 0,
			&cache_handle,
			msg1.cache_name,
			sizeof(msg1.cache_name));
	if (ret)
	    goto out;
    }
    msg1.cache_handle = cache_handle.nnpfs_handle;
    msg1.flag = NNPFS_ID_INVALID_DNLC;
    if (cache_handle.valid)
	msg1.flag |= NNPFS_ID_HANDLE_VALID;
    dir_entry->tokens |= NNPFS_ATTR_R;
    msg1.node.tokens = dir_entry->tokens | NNPFS_DATA_R;
    
    fcacheentry2nnpfsnode (&dir_entry->fid,
			   fcache_realfid(dir_entry),
			   &dir_entry->status, &msg1.node,
			   dir_entry->acccache,
			   FCACHE2NNPFSNODE_ALL);
    
    msg1.offset = dir_entry->fetched_length;
    msg1.header.opcode = NNPFS_MSG_INSTALLDATA;
    h0 = (struct nnpfs_message_header *)&msg1;
    h0_len = sizeof(msg1);
    
    /*
     * Set datausedp since we push data to kernel in out:
     */
    
    assert(dir_entry->flags.attrusedp);
    dir_entry->flags.datausedp = TRUE;
    
    /*
     * Make sure that if the removed node is in the kernel it has the
     * right linkcount since some might hold a reference to it.
     */
    
    ret = fcache_get (&limbo_entry, fid, ce);
    if (ret)
	goto out;
    
    if (limbo_entry->flags.kernelp) {
	/*
	 * Now insert the limbo entry to get right linkcount
	 */
	
	ret = fcache_verify_attr (limbo_entry, dir_entry, NULL, ce);
	if (ret == 0)
	    limbo_status = limbo_entry->status;
	ret = 0;
	
	/* Only a silly rename when this is the last file */
	if (link_count == 1)
	    limbo_entry->flags.silly = TRUE;
	
	msg2.header.opcode = NNPFS_MSG_INSTALLATTR;
	limbo_entry->tokens |= NNPFS_ATTR_R;
	msg2.node.tokens   = limbo_entry->tokens;
	if (!limbo_entry->flags.datausedp)
	    msg2.node.tokens &= ~NNPFS_DATA_MASK;
	
	if (link_count == 1 && limbo_status.LinkCount == 1)
	     --limbo_status.LinkCount;
	fcacheentry2nnpfsnode (&fid,
			       fcache_realfid(limbo_entry),
			       &limbo_status,
			       &msg2.node,
			       limbo_entry->acccache,
			       FCACHE2NNPFSNODE_ALL);
	
	h1 = (struct nnpfs_message_header *)&msg2;
	h1_len = sizeof(msg2);
    }
    
 out:
    nnpfs_send_message_wakeup_multiple (fd,
					h->header.sequence_num,
					ret,
					h0, h0_len,
					h1, h1_len,
					NULL, 0);
    if (dir_entry)
	fcache_release(dir_entry);
    if (limbo_entry)
	fcache_release (limbo_entry);
    cred_free (ce);

    return ret;
}

static int 
nnpfs_message_rmdir (int fd, struct nnpfs_message_rmdir *h, u_int size)
{
    VenusFid parent_fid, fid;
    CredCacheEntry *ce;
    int ret;
    struct nnpfs_message_installdata msg0;
    struct nnpfs_message_header *h0 = NULL;
    size_t h0_len = 0;
    struct nnpfs_message_installattr msg1;
    struct nnpfs_message_header *h1 = NULL;
    size_t h1_len = 0;
    FCacheEntry *limbo_entry = NULL;
    FCacheEntry *dir_entry = NULL;
    unsigned link_count = 0;
    fcache_cache_handle cache_handle;

    parent_fid = *(VenusFid *)&h->parent_handle;
    arla_warnx (ADEBMSG, "rmdir (%ld.%lu.%lu.%lu) \"%s\"",
		(long)parent_fid.Cell, (unsigned long)parent_fid.fid.Volume,
		(unsigned long)parent_fid.fid.Vnode,
		(unsigned long)parent_fid.fid.Unique, h->name);

    ce = cred_get (parent_fid.Cell, h->cred.pag, CRED_ANY);
    assert (ce != NULL);

    /*
     * Fetch the child-entry fid.
     */

    ret = fcache_get(&dir_entry, parent_fid, ce);
    if (ret)
	goto out;

    assert_flag(dir_entry,kernelp);

    do {
	ret = cm_lookup (&dir_entry, h->name, &fid, &ce, FALSE);
    } while (try_again (&ret, &ce, &h->cred, &dir_entry->fid));

    if (ret)
	goto out;

    if (VenusFid_cmp(&dir_entry->fid, &fid) == 0) {
	ret = EINVAL;
	goto out;
    }

    /*
     * Need to get linkcount for silly rename.
     */

    ret = fcache_get (&limbo_entry, fid, ce);
    if (ret)
	goto out;

    ret = fcache_verify_attr (limbo_entry, dir_entry, h->name, ce);
    if (ret)
	goto out;
    link_count = limbo_entry->status.LinkCount;

    fcache_release (limbo_entry);
    limbo_entry = NULL;

    /*
     * Do the actual work
     */

    do {
	ret = cm_rmdir(&dir_entry, h->name, &ce);
    } while (try_again (&ret, &ce, &h->cred, &dir_entry->fid));

    if (ret)
	goto out;

    ret = message_get_data (&dir_entry, &h->cred, &ce, 0);
    if (ret)
	goto out;

    if (!dir_entry->flags.extradirp
	|| dir_remove_name (dir_entry, h->name,
			    &cache_handle,
			    msg0.cache_name,
			    sizeof(msg0.cache_name))) {
	ret = conv_dir (dir_entry, ce, 0,
			&cache_handle,
			msg0.cache_name,
			sizeof(msg0.cache_name));
	if (ret)
	    goto out;
    }
    msg0.cache_handle = cache_handle.nnpfs_handle;
    msg0.flag = NNPFS_ID_INVALID_DNLC;
    if (cache_handle.valid)
	msg0.flag |= NNPFS_ID_HANDLE_VALID;

    dir_entry->tokens |= NNPFS_ATTR_R;
    msg0.node.tokens = dir_entry->tokens;

    fcacheentry2nnpfsnode (&dir_entry->fid,
			   fcache_realfid(dir_entry),
			   &dir_entry->status, &msg0.node,
			   dir_entry->acccache,
			   FCACHE2NNPFSNODE_ALL);

    msg0.offset = dir_entry->fetched_length;
    msg0.header.opcode = NNPFS_MSG_INSTALLDATA;
    h0 = (struct nnpfs_message_header *)&msg0;
    h0_len = sizeof(msg0);

    ret = fcache_get (&limbo_entry, fid, ce);
    if (ret)
	goto out;

    /* Only silly rename when this is the last reference. */

    if (link_count == 2)
	limbo_entry->flags.silly = TRUE;

    if (limbo_entry->flags.kernelp) {

	ret = fcache_verify_attr (limbo_entry, dir_entry, NULL, ce);
	if (ret)
	    goto out;

	msg1.header.opcode = NNPFS_MSG_INSTALLATTR;
	limbo_entry->tokens |= NNPFS_ATTR_R;
	msg1.node.tokens   = limbo_entry->tokens;
	if (!limbo_entry->flags.datausedp)
	    msg1.node.tokens &= ~NNPFS_DATA_MASK;

	if (link_count == 2 && limbo_entry->status.LinkCount == 2)
	    limbo_entry->status.LinkCount = 0;
	fcacheentry2nnpfsnode (&fid,
			       fcache_realfid(limbo_entry),
			       &limbo_entry->status,
			       &msg1.node,
			       limbo_entry->acccache,
			       FCACHE2NNPFSNODE_ALL);

	h1 = (struct nnpfs_message_header *)&msg1;
	h1_len = sizeof(msg1);
    }
    assert_flag(dir_entry,kernelp);
    assert_flag(dir_entry,attrusedp);
    dir_entry->flags.datausedp = TRUE;

 out:
    nnpfs_send_message_wakeup_multiple (fd,
					h->header.sequence_num,
					ret,
					h0, h0_len,
					h1, h1_len,
					NULL, 0);
    if (dir_entry)
	fcache_release(dir_entry);
    if (limbo_entry)
	fcache_release (limbo_entry);

    cred_free (ce);

    return ret;
}

static int 
nnpfs_message_rename (int fd, struct nnpfs_message_rename *h, u_int size)
{
    VenusFid old_parent_fid;
    VenusFid new_parent_fid;
    VenusFid child_fid;
    CredCacheEntry *ce;
    int ret;
    struct nnpfs_message_installdata msg1;
    struct nnpfs_message_installdata msg2;
    struct nnpfs_message_installdata msg3;
    struct nnpfs_message_header *h0 = NULL;
    size_t h0_len = 0;
    struct nnpfs_message_header *h1 = NULL;
    size_t h1_len = 0;
    struct nnpfs_message_header *h2 = NULL;
    size_t h2_len = 0;
    FCacheEntry *old_entry   = NULL;
    FCacheEntry *new_entry   = NULL;
    FCacheEntry *child_entry = NULL;
    int update_child = 0;
    fcache_cache_handle cache_handle;
    int diff_dir = 0;

    old_parent_fid = *(VenusFid *)&h->old_parent_handle;
    new_parent_fid = *(VenusFid *)&h->new_parent_handle;
    arla_warnx (ADEBMSG,
		"rename (%ld.%lu.%lu.%lu) (%ld.%lu.%lu.%lu) \"%s\" \"%s\"",
		(long)old_parent_fid.Cell,
		(unsigned long)old_parent_fid.fid.Volume,
		(unsigned long)old_parent_fid.fid.Vnode,
		(unsigned long)old_parent_fid.fid.Unique,
		(long)new_parent_fid.Cell,
		(unsigned long)new_parent_fid.fid.Volume,
		(unsigned long)new_parent_fid.fid.Vnode,
		(unsigned long)new_parent_fid.fid.Unique,
		h->old_name,
		h->new_name);

    ce = cred_get (old_parent_fid.Cell, h->cred.pag, CRED_ANY);
    assert (ce != NULL);

    diff_dir = VenusFid_cmp (&old_parent_fid, &new_parent_fid);

    ret = fcache_get(&old_entry, old_parent_fid, ce);
    if (ret)
	goto out;

    assert_flag(old_entry,kernelp);
d1117 5
a1121 295
    if (diff_dir) {
	ret = fcache_get(&new_entry, new_parent_fid, ce);
	if (ret)
	    goto out;
    } else {
	new_entry = old_entry;
    }

    assert_flag(new_entry,kernelp);

    do {
	ret = cm_rename(&old_entry, h->old_name,
			&new_entry, h->new_name,
			&child_fid, &update_child, &ce);
    } while (try_again (&ret, &ce, &h->cred, &old_entry->fid));

    if (ret)
	goto out;

    ret = message_get_data (&old_entry, &h->cred, &ce, 0);
    if (ret)
	goto out;
     
    if (!old_entry->flags.extradirp
	|| dir_remove_name (old_entry, h->old_name,
			    &cache_handle,
			    msg1.cache_name,
			    sizeof(msg1.cache_name))) {
	ret = conv_dir (old_entry, ce, 0,
			&cache_handle,
			msg1.cache_name,
			sizeof(msg1.cache_name));
	if (ret)
	    goto out;
    }
    msg1.cache_handle = cache_handle.nnpfs_handle;
    msg1.flag = NNPFS_ID_INVALID_DNLC;
    if (cache_handle.valid)
	msg1.flag |= NNPFS_ID_HANDLE_VALID;
     
    old_entry->tokens |= NNPFS_ATTR_R;
    msg1.node.tokens = old_entry->tokens;
     
    fcacheentry2nnpfsnode (&old_entry->fid,
			   fcache_realfid(old_entry),
			   &old_entry->status, &msg1.node,
			   old_entry->acccache,
			   FCACHE2NNPFSNODE_ALL);
     
    msg1.offset = old_entry->fetched_length;
    msg1.header.opcode = NNPFS_MSG_INSTALLDATA;
    h0 = (struct nnpfs_message_header *)&msg1;
    h0_len = sizeof(msg1);
     
    ret = fcache_get_data (&new_entry, &ce, 0); /* XXX - fake_mp? */
    if (ret)
	goto out;
     
    ret = conv_dir (new_entry, ce, 0,
		    &cache_handle,
		    msg2.cache_name,
		    sizeof(msg2.cache_name));
    if (ret)
	goto out;

    msg2.cache_handle = cache_handle.nnpfs_handle;
    msg2.flag = NNPFS_ID_INVALID_DNLC;
    if (cache_handle.valid)
	msg2.flag |= NNPFS_ID_HANDLE_VALID;
     
    new_entry->tokens |= NNPFS_ATTR_R;
    msg2.node.tokens = new_entry->tokens;
     
    fcacheentry2nnpfsnode (&new_entry->fid,
			   fcache_realfid(new_entry),
			   &new_entry->status, &msg2.node,
			   new_entry->acccache,
			   FCACHE2NNPFSNODE_ALL);
     
    msg2.offset = new_entry->fetched_length;
    msg2.header.opcode = NNPFS_MSG_INSTALLDATA;
    h1 = (struct nnpfs_message_header *)&msg2;
    h1_len = sizeof(msg2);
     
    if (old_entry) {
	assert_flag(old_entry,kernelp);
	assert_flag(old_entry,attrusedp);
	old_entry->flags.datausedp = TRUE;
    }
    assert_flag(new_entry,kernelp);
    assert_flag(new_entry,attrusedp);
    new_entry->flags.datausedp = TRUE;
     
    if (update_child) {
	ret = fcache_get(&child_entry, child_fid, ce);
	if (ret)
	    goto out;
	ret = message_get_data (&child_entry, &h->cred, &ce, 0);
	if (ret) {
	    fcache_release(child_entry);
	    goto out;
	}
	child_fid = child_entry->fid;
	 
	ret = conv_dir (child_entry, ce, 0,
			&cache_handle,
			msg3.cache_name,
			sizeof(msg3.cache_name));
	if (ret)
	    goto out;

	msg3.cache_handle = cache_handle.nnpfs_handle;
	msg3.flag = NNPFS_ID_INVALID_DNLC;
	if (cache_handle.valid)
	    msg3.flag |= NNPFS_ID_HANDLE_VALID;
	 
	child_entry->tokens |= NNPFS_ATTR_R;
	msg3.node.tokens = child_entry->tokens;
	 
	fcacheentry2nnpfsnode (&child_fid,
			       fcache_realfid(child_entry),
			       &child_entry->status, &msg3.node,
			       child_entry->acccache,
			       FCACHE2NNPFSNODE_ALL);
	 
	msg3.offset = child_entry->fetched_length;
	msg3.header.opcode = NNPFS_MSG_INSTALLDATA;
	h2 = (struct nnpfs_message_header *)&msg3;
	h2_len = sizeof(msg3);
    }

 out:
    nnpfs_send_message_wakeup_multiple (fd,
					h->header.sequence_num,
					ret,
					h0, h0_len,
					h1, h1_len,
					NULL, 0);
    if (old_entry) fcache_release(old_entry);
    if (new_entry && diff_dir) fcache_release(new_entry);
    if (child_entry) fcache_release(child_entry);
     
    cred_free (ce);

    return ret;
}

static int 
nnpfs_message_putdata (int fd, struct nnpfs_message_putdata *h, u_int size)
{
    VenusFid fid;
    CredCacheEntry *ce;
    int ret;
    AFSStoreStatus status;
    FCacheEntry *entry = NULL;

    fid = *(VenusFid *)&h->handle;
    arla_warnx (ADEBMSG, "putdata (%ld.%lu.%lu.%lu)",
		(long)fid.Cell, (unsigned long)fid.fid.Volume,
		(unsigned long)fid.fid.Vnode,
		(unsigned long)fid.fid.Unique);

    nnpfs_attr2afsstorestatus(&h->attr, &status);

    ce = cred_get (fid.Cell, h->cred.pag, CRED_ANY);
    assert (ce != NULL);

    if (connected_mode != CONNECTED) {
	ret = fcache_find (&entry, fid);
	if (ret) {
	    ret = ENETDOWN;
	    goto out;
	}
    } else {
	ret = fcache_get (&entry, fid, ce);
	if (ret)
	    goto out;
    }

    assert_flag(entry,kernelp);

    do {
	ret = cm_close(entry, h->flag, &status, ce);
    } while (try_again (&ret, &ce, &h->cred, &fid));
     
    if (ret) {
	arla_warn (ADEBMSG, ret, "nnpfs_message_putdata: cm_close");
	goto out;
    }

    if (connected_mode != CONNECTED)
	entry->disco_id = disco_store_data(&fid, &status, entry->disco_id);

 out:
    if (entry)
	fcache_release(entry);
    cred_free (ce);
    nnpfs_send_message_wakeup (fd, h->header.sequence_num, ret);
    return 0;
}

static void
prefetch_data(FCacheEntry **e, CredCacheEntry **ce)
{
    FCacheEntry *entry = *e;
    int ret = 0;

    if (entry->status.FileType != TYPE_FILE)
	return;

    if (entry->status.Length > entry->fetched_length) {
	size_t offset;

	offset = entry->fetched_length + stats_prefetch(NULL, -1);
	if (offset > entry->status.Length)
	    offset = entry->status.Length;
	arla_warnx (ADEBMSG, "  prefetching to %lu", (unsigned long)offset);
	ret = fcache_get_data (e, ce, offset);
	arla_warnx (ADEBMSG, "  prefetched returned %d", ret);
    }

    return;
}

static int
nnpfs_message_open (int fd, struct nnpfs_message_open *h, u_int size)
{
    struct nnpfs_message_installdata msg;
    FCacheEntry *entry = NULL;
    CredCacheEntry *ce;
    AccessEntry *ae;
    VenusFid fid;
    int ret;
    
    fid = *(VenusFid *)&h->handle;
    arla_warnx (ADEBMSG, "open (%ld.%lu.%lu.%lu)",
		(long)fid.Cell, (unsigned long)fid.fid.Volume,
		(unsigned long)fid.fid.Vnode,
		(unsigned long)fid.fid.Unique);
    
    ce = cred_get (fid.Cell, h->cred.pag, CRED_ANY);
    assert (ce != NULL);
    
    ret = fcache_get(&entry, fid, ce);
    if (ret)
	goto out;
    
    assert_flag(entry,kernelp);
    
 tryagain:

    ret = cm_getattr (entry, ce, &ae);

    if (try_again (&ret, &ce, &h->cred, &fid))
	goto tryagain;
    if (ret)
	goto out;

    msg.flag = 0;

    if (entry->status.FileType == TYPE_DIR) {
	fcache_cache_handle cache_handle;
	 
	if (h->tokens & NNPFS_DATA_W) {
	    ret = EACCES;
	    goto out;
	}
	 
	ret = fcache_get_data (&entry, &ce, entry->status.Length);
	if (try_again (&ret, &ce, &h->cred, &fid))
	    goto tryagain;
	if (ret)
	    goto out;
	fid = entry->fid;
	 
	fcacheentry2nnpfsnode (&fid, fcache_realfid(entry),
			       &entry->status, &msg.node, ae,
			       FCACHE2NNPFSNODE_ALL);
	 
	ret = conv_dir (entry, ce, h->tokens,
			&cache_handle,
			msg.cache_name,
			sizeof(msg.cache_name));
	 
	if (ret)
	    goto out;
	 
	entry->tokens |= h->tokens;
	entry->tokens |= NNPFS_ATTR_R;
	msg.node.tokens = entry->tokens;
	msg.flag = NNPFS_ID_INVALID_DNLC;
	msg.cache_handle = cache_handle.nnpfs_handle;
	if (cache_handle.valid)
	    msg.flag |= NNPFS_ID_HANDLE_VALID;
	msg.offset = entry->fetched_length;
d1123 28
a1150 48
	assert_flag(entry,kernelp);
	entry->flags.attrusedp = TRUE;
	entry->flags.datausedp = TRUE;
	 
    } else {
	ret = cm_open (entry, ce, h->tokens);
	if (try_again (&ret, &ce, &h->cred, &fid))
	    goto tryagain;
	if (ret)
	    goto out;

	fcache_conv_file_name (entry, msg.cache_name, sizeof(msg.cache_name));

	msg.cache_handle = entry->handle.nnpfs_handle;
	entry->tokens |= NNPFS_ATTR_R | NNPFS_DATA_R;
	msg.node.tokens = entry->tokens;
	msg.offset = entry->fetched_length;
	fcacheentry2nnpfsnode (&fid, fcache_realfid(entry),
			       &entry->status, &msg.node, ae,
			       FCACHE2NNPFSNODE_ALL);
	if (entry->handle.valid)
	    msg.flag |= NNPFS_ID_HANDLE_VALID;
    }

    msg.header.opcode = NNPFS_MSG_INSTALLDATA;

    nnpfs_send_message_wakeup_multiple (fd,
					h->header.sequence_num,
					ret,
					&msg, sizeof(msg),
					NULL, 0);

    prefetch_data(&entry, &ce);

    fcache_release(entry);
    cred_free (ce);
    return ret;

 out:

    if (entry)
	fcache_release(entry);
    cred_free (ce);
    nnpfs_send_message_wakeup_multiple (fd,
					h->header.sequence_num,
					ret,
					NULL, 0);
    return ret;
d1153 7
a1159 2
static int
nnpfs_message_getdata (int fd, struct nnpfs_message_getdata *h, u_int size)
d1161 105
a1265 13
    struct nnpfs_message_installdata msg;
    VenusFid fid;
    CredCacheEntry *ce;
    int ret;
    AccessEntry *ae;
    size_t offset;
    FCacheEntry *entry = NULL;

    fid = *(VenusFid *)&h->handle;
    arla_warnx (ADEBMSG, "getdata (%ld.%lu.%lu.%lu)",
		(long)fid.Cell, (unsigned long)fid.fid.Volume,
		(unsigned long)fid.fid.Vnode,
		(unsigned long)fid.fid.Unique);
d1267 4
a1270 2
    ce = cred_get (fid.Cell, h->cred.pag, CRED_ANY);
    assert (ce != NULL);
d1272 27
a1298 3
    ret = fcache_get(&entry, fid, ce);
    if (ret)
	goto out;
d1300 13
a1312 1
    assert_flag(entry,kernelp);
d1314 14
a1327 1
 tryagain:
d1329 144
a1472 1
    ret = cm_getattr (entry, ce, &ae);
d1474 15
a1488 4
    if (try_again (&ret, &ce, &h->cred, &fid))
	goto tryagain;
    if (ret)
	goto out;
d1490 119
a1608 7
    if (entry->status.FileType == TYPE_DIR) {
	offset = entry->status.Length;
    } else {     
	offset = h->offset;
	if (offset > entry->status.Length)
	    offset = entry->status.Length;
    }
d1610 11
a1620 2
    arla_warnx (ADEBMSG, "  requested to byte %lu fetching to byte %lu",
		(unsigned long)h->offset, (unsigned long)offset);
d1622 10
a1631 8
    ret = fcache_get_data (&entry, &ce, offset);
    if (try_again (&ret, &ce, &h->cred, &fid))
	goto tryagain;
    if (ret)
	goto out;
     
    if (entry->status.FileType == TYPE_DIR) {
	fcache_cache_handle cache_handle;
d1633 44
a1676 29
	ret = conv_dir (entry, ce, h->tokens,
			&cache_handle,
			msg.cache_name,
			sizeof(msg.cache_name));
	if (ret)
	    goto out;
	msg.cache_handle = cache_handle.nnpfs_handle;
	msg.flag = NNPFS_ID_INVALID_DNLC;
	if (cache_handle.valid)
	    msg.flag |= NNPFS_ID_HANDLE_VALID;
    } else {
	fcache_conv_file_name(entry, msg.cache_name, sizeof(msg.cache_name));
	msg.cache_handle = entry->handle.nnpfs_handle;
	msg.flag = 0;
	if (entry->handle.valid)
	    msg.flag |= NNPFS_ID_HANDLE_VALID;
    }

    entry->flags.datausedp = TRUE;
    entry->tokens |= NNPFS_ATTR_R | NNPFS_DATA_R;
    if (h->tokens & NNPFS_DATA_W)
	entry->tokens |= NNPFS_DATA_W;
    msg.node.tokens = entry->tokens;
    arla_warnx (ADEBMSG, "  got %lu",
		(unsigned long)entry->fetched_length);
    msg.offset = entry->fetched_length;
    fcacheentry2nnpfsnode (&entry->fid, fcache_realfid(entry),
			   &entry->status, &msg.node, ae,
			   FCACHE2NNPFSNODE_ALL);
d1678 2
a1679 7
    msg.header.opcode = NNPFS_MSG_INSTALLDATA;
    
    nnpfs_send_message_wakeup_multiple (fd,
					h->header.sequence_num,
					ret,
					&msg, sizeof(msg),
					NULL, 0);
d1681 151
a1831 14
    prefetch_data(&entry, &ce);
     
    fcache_release(entry);
    cred_free (ce);
    return ret;

 out:
    if (entry)
	fcache_release(entry);
    cred_free (ce);
    nnpfs_send_message_wakeup_multiple (fd,
					h->header.sequence_num,
					ret,
					NULL, 0);
d1833 1
a1833 1
    return ret;
d1844 24
a1867 32
    struct nnpfs_message_invalidnode msg;
    enum { CALLBACK_BREAK_WARN = 100 };
    static int failed_callbacks_break = 0;
    int ret;

    assert_flag(entry,kernelp);

    /* 
     * Throw away tokens for all directories and unused entries.
     * needs to be same as NNPFS_MSG_INVALIDNODE processing in
     * nnpfs
     */
    if (entry->status.FileType == TYPE_DIR || !entry->flags.datausedp)
	entry->tokens = 0;

    msg.header.opcode = NNPFS_MSG_INVALIDNODE;
    memcpy (&msg.handle, &entry->fid, sizeof(entry->fid));
    ret = nnpfs_message_send (kernel_fd, (struct nnpfs_message_header *)&msg, 
			      sizeof(msg));
    if (ret) {
	arla_warnx (ADEBMSG, "break_callback: (%ld.%lu.%lu.%lu) failed",
		    (long)entry->fid.Cell, 
		    (unsigned long)entry->fid.fid.Volume,
		    (unsigned long)entry->fid.fid.Vnode,
		    (unsigned long)entry->fid.fid.Unique);
	++failed_callbacks_break;
	if (failed_callbacks_break > CALLBACK_BREAK_WARN) {
	    arla_warnx (ADEBWARN, "break_callback: have failed %d times",
			failed_callbacks_break);
	    failed_callbacks_break = 0;
	}
    }
d1877 1
a1877 1
    struct nnpfs_message_installattr msg;
d1879 7
a1885 8
    memset (&msg, 0, sizeof(msg));
    msg.header.opcode = NNPFS_MSG_INSTALLATTR;
    fcacheentry2nnpfsnode (&e->fid, fcache_realfid(e), &e->status, &msg.node,
			   e->acccache, flags);
    e->tokens |= NNPFS_ATTR_R;
    msg.node.tokens   = e->tokens;
    if (!e->flags.datausedp)
	msg.node.tokens &= ~NNPFS_DATA_MASK;
d1887 2
a1888 2
    nnpfs_message_send (kernel_fd, (struct nnpfs_message_header *)&msg, 
			sizeof(msg));
d1895 1
a1895 1
    struct nnpfs_message_updatefid msg;
d1897 1
a1897 1
    msg.header.opcode = NNPFS_MSG_UPDATEFID;
d1900 2
a1901 2
    nnpfs_message_send (kernel_fd, (struct nnpfs_message_header *)&msg,
			sizeof(msg));
a1902 1
	assert_flag(new_entry,kernelp);
d1914 2
a1915 2
nnpfs_message_inactivenode (int fd, struct nnpfs_message_inactivenode *h, 
			    u_int size)
d1917 30
a1946 33
    FCacheEntry *entry;
    VenusFid *fid;
    int ret;
    CredCacheEntry *ce;

    fid = (VenusFid *)&h->handle;
    arla_warnx (ADEBMSG, "inactivenode (%ld.%lu.%lu.%lu)",
		(long)fid->Cell, (unsigned long)fid->fid.Volume,
		(unsigned long)fid->fid.Vnode,
		(unsigned long)fid->fid.Unique);

    ce = cred_get (fid->Cell, 0, CRED_NONE);
    assert (ce != NULL);

    ret = fcache_get (&entry, *fid, ce);
    cred_free (ce);

    if (ret) {
	arla_warnx (ADEBMSG, "nnpfs_message_inactivenode: node not found");
	return 0;
    }

    assert_flag(entry,kernelp);

    if (h->flag & NNPFS_NOREFS)
	fcache_unused (entry);
    if (h->flag & NNPFS_DELETE) {
	entry->flags.kernelp   = FALSE;
	entry->flags.datausedp = FALSE;
	entry->flags.attrusedp = FALSE;
    }
    fcache_release(entry);
    return 0;
d1954 1
a1954 1
all_powerful_p (const nnpfs_cred *cred)
d1964 1
a1964 1
viocflushvolume (int fd, struct nnpfs_message_pioctl *h, u_int size)
d1990 1
a1990 1
viocgetacl(int fd, struct nnpfs_message_pioctl *h, u_int size)
d1998 1
a1998 1
	return nnpfs_send_message_wakeup (fd, h->header.sequence_num, EINVAL);
d2017 2
a2018 2
    nnpfs_send_message_wakeup_data (fd, h->header.sequence_num, error,
				    opaque.val, opaque.len);
d2029 1
a2029 1
viocsetacl(int fd, struct nnpfs_message_pioctl *h, u_int size)
d2038 1
a2038 1
	return nnpfs_send_message_wakeup (fd, h->header.sequence_num, EINVAL);
d2041 1
a2041 1
	return nnpfs_send_message_wakeup (fd, h->header.sequence_num, EINVAL);
d2045 1
a2045 1
	return nnpfs_send_message_wakeup (fd, h->header.sequence_num, ENOMEM);
d2063 1
a2063 1
	install_attr (e, FCACHE2NNPFSNODE_ALL);
d2071 1
a2071 1
    nnpfs_send_message_wakeup_data (fd, h->header.sequence_num, error, NULL, 0);
d2080 1
a2080 1
viocgetvolstat(int fd, struct nnpfs_message_pioctl *h, u_int size)
d2093 1
a2093 1
	return nnpfs_send_message_wakeup (fd, h->header.sequence_num, EINVAL);
d2110 1
a2110 1
			    volumename, sizeof(volumename),
d2150 2
a2151 2
    nnpfs_send_message_wakeup_data (fd, h->header.sequence_num, error,
				    out, outsize);
d2160 1
a2160 1
viocsetvolstat(int fd, struct nnpfs_message_pioctl *h, u_int size)
d2226 2
a2227 2
    nnpfs_send_message_wakeup_data (fd, h->header.sequence_num, error,
				    NULL, 0);
d2251 1
a2251 1
    error = fcache_get(&dentry, fid, *ce);
a2254 6
    error = fcache_get_data(&dentry, ce, 0);
    if (error) {
	fcache_release(dentry);
	return error;
    }

d2264 1
a2264 1
    error = fcache_verify_attr (mp_entry, dentry, filename, *ce);
d2287 1
a2287 1
read_mount_point (FCacheEntry **mp_entry, CredCacheEntry **ce,
d2293 1
a2293 1
    error = fcache_get_data (mp_entry, ce, 0);
d2297 1
a2297 1
    *fd = fcache_open_file (*mp_entry, O_RDONLY);
d2301 1
a2301 1
    error = fbuf_create (the_fbuf, *fd, (*mp_entry)->status.Length,
d2323 1
a2323 1
vioc_afs_stat_mt_pt(int fd, struct nnpfs_message_pioctl *h, u_int size)
d2346 1
a2346 1
	return nnpfs_send_message_wakeup (fd, h->header.sequence_num, error);
d2349 1
a2349 1
    error = read_mount_point (&e, &ce, &mp_fd, &the_fbuf);
d2353 1
a2353 1
	return nnpfs_send_message_wakeup (fd, h->header.sequence_num, error);
d2365 2
a2366 2
    nnpfs_send_message_wakeup_data (fd, h->header.sequence_num, error,
				    buf, the_fbuf.len);
d2381 1
a2381 1
vioc_afs_delete_mt_pt(int fd, struct nnpfs_message_pioctl *h, u_int size)
d2386 1
a2386 1
    struct nnpfs_message_remove remove_msg;
d2402 1
a2402 1
	return nnpfs_send_message_wakeup (fd, h->header.sequence_num, error);
d2411 1
a2411 1
    return nnpfs_message_remove (fd, &remove_msg, sizeof(remove_msg));
d2415 1
a2415 1
viocwhereis(int fd, struct nnpfs_message_pioctl *h, u_int size)
d2426 1
a2426 1
	return nnpfs_send_message_wakeup (fd, h->header.sequence_num, EINVAL);
d2439 1
a2439 1
	return nnpfs_send_message_wakeup (fd, h->header.sequence_num, error);
d2445 1
a2445 1
	return nnpfs_send_message_wakeup (fd, h->header.sequence_num, error);
d2453 1
a2453 1
	return nnpfs_send_message_wakeup (fd, h->header.sequence_num, EINVAL);
d2463 2
a2464 2
    nnpfs_send_message_wakeup_data (fd, h->header.sequence_num, error,
				    addresses, sizeof(long) * j);
d2477 1
a2477 1
vioc_get_cell(int fd, struct nnpfs_message_pioctl *h, u_int size)
d2491 1
a2491 1
	return nnpfs_send_message_wakeup (fd, h->header.sequence_num, EDOM);
d2496 1
a2496 1
	return nnpfs_send_message_wakeup (fd, h->header.sequence_num, EDOM);
d2504 1
a2504 1
	uint32_t addr = dbservers[i].addr.s_addr;
d2508 2
a2509 2
    nnpfs_send_message_wakeup_data (fd, h->header.sequence_num, 0,
				    out, outsize);
d2519 1
a2519 1
vioc_get_cellstatus(int fd, struct nnpfs_message_pioctl *h, u_int size)
d2523 1
a2523 1
    uint32_t out = 0;
d2530 1
a2530 1
	return nnpfs_send_message_wakeup (fd, h->header.sequence_num, ENOENT);
d2537 2
a2538 2
    nnpfs_send_message_wakeup_data (fd, h->header.sequence_num, 0,
				    &out, sizeof(out));
d2548 1
a2548 1
vioc_set_cellstatus(int fd, struct nnpfs_message_pioctl *h, u_int size)
d2552 1
a2552 1
    uint32_t in = 0;
d2556 1
a2556 1
	return nnpfs_send_message_wakeup (fd, h->header.sequence_num, EACCES);
d2559 1
a2559 1
	return nnpfs_send_message_wakeup (fd, h->header.sequence_num, EINVAL);
d2566 1
a2566 1
	return nnpfs_send_message_wakeup (fd, h->header.sequence_num, ENOENT);
d2571 1
a2571 1
	    return nnpfs_send_message_wakeup (fd, h->header.sequence_num,EINVAL);
d2574 1
a2574 1
    nnpfs_send_message_wakeup (fd, h->header.sequence_num, 0);
d2584 1
a2584 1
vioc_new_cell(int fd, struct nnpfs_message_pioctl *h, u_int size)
d2589 1
a2589 1
    uint32_t *hp;
d2593 1
a2593 1
	return nnpfs_send_message_wakeup (fd, h->header.sequence_num, EPERM);
d2596 1
a2596 1
	return nnpfs_send_message_wakeup (fd, h->header.sequence_num, EINVAL);
d2598 1
a2598 1
    hp = (uint32_t *)h->msg;
d2604 1
a2604 1
	return nnpfs_send_message_wakeup (fd, h->header.sequence_num, ENOMEM);
d2608 1
a2608 1
    hp = (uint32_t *)h->msg;
d2615 1
a2615 1
    cellname = h->msg + 8 * sizeof(uint32_t);
d2622 2
a2623 2
	    return nnpfs_send_message_wakeup (fd, h->header.sequence_num,
					      ENOMEM);
d2632 1
a2632 1
    return nnpfs_send_message_wakeup (fd, h->header.sequence_num, 0);
d2642 1
a2642 1
token_for_cell (int fd, struct nnpfs_message_pioctl *h, u_int size,
d2645 3
a2647 2
    char buf[NNPFS_MSG_MAX_DATASIZE];
    size_t len, cell_len;
d2649 3
a2651 2
    uint32_t tmp;
    struct cred_rxkad *cred = (struct cred_rxkad *)ce->cred_data;
d2654 5
a2658 1
    cell_len = strlen(cell);
d2660 1
a2660 5
    len = 4 + cred->ticket_len + 4 + sizeof(cred->ct) + 4 + cell_len;
    if (len > sizeof(buf))
	return nnpfs_send_message_wakeup (fd, h->header.sequence_num, EINVAL);

    tmp = cred->ticket_len;
d2663 1
a2663 1
    memcpy (p, cred->ticket, tmp);
d2665 1
a2665 1
    tmp = sizeof(cred->ct);
d2668 3
a2670 3
    memcpy (p, &cred->ct, sizeof(cred->ct));
    p += sizeof(cred->ct);
    tmp = 0;
d2678 2
d2682 2
a2683 21
    nnpfs_send_message_wakeup_data (fd, h->header.sequence_num, 0,
				    buf, len);
    return 0;
}

struct get_tok {
    int32_t counter;
    int32_t cell;
};

static int
gettok_func(CredCacheEntry *ce, void *ptr)
{
    struct get_tok *gt = ptr;

    if (gt->counter == 0) {
	gt->cell = ce->cell;
	return 1;
    }

    gt->counter--;
a2686 1

d2692 1
a2692 1
viocgettok (int fd, struct nnpfs_message_pioctl *h, u_int size)
a2693 3
    CredCacheEntry *ce;
    int32_t cell_id;

d2695 2
a2696 4
	cell_id = cell_name2num(cell_getthiscell());
    } else if (h->insize == sizeof(uint32_t)) {
	struct get_tok gt;
	int32_t n;
d2698 2
a2699 4
	memcpy (&n, h->msg, sizeof(n));

	if (n < 0) {
	    nnpfs_send_message_wakeup (fd, h->header.sequence_num, EINVAL);
d2702 6
d2709 1
a2709 2
	gt.counter = n;
	gt.cell = -1;
d2711 6
a2716 1
	cred_list_pag(h->cred.pag, CRED_KRB4, gettok_func, &gt);
d2718 12
a2729 2
	if (gt.cell == -1) {
	    nnpfs_send_message_wakeup (fd, h->header.sequence_num, EDOM);
d2732 1
a2732 2

	cell_id = gt.cell;
d2734 1
a2734 2
	nnpfs_send_message_wakeup (fd, h->header.sequence_num, EINVAL);
	return 0;
d2736 1
a2736 8

    ce = cred_get (cell_id, h->cred.pag, CRED_KRB4);
    if (ce == NULL) {
	nnpfs_send_message_wakeup (fd, h->header.sequence_num, ENOTCONN);
	return 0;
    }

    return token_for_cell (fd, h, size, ce);
d2744 1
a2744 1
viocsettok (int fd, struct nnpfs_message_pioctl *h, u_int size)
d2746 2
a2747 1
    struct cred_rxkad cred;
a2748 1
    char realm[256];
d2753 1
a2753 3
    if (h->insize == 0)
	return EINVAL;
    if (h->insize < 4)
d2755 1
d2759 1
a2759 1
    cred.ticket_len = sizeof_x;
d2763 1
a2763 7
    /* data used + datalen + cleartoken's length field */
    if ((t - (char *)h->msg) + sizeof_x + 4 > h->insize)
	return EINVAL;
    if (sizeof_x > sizeof(cred.ticket))
	return EINVAL;
    
    memcpy(cred.ticket, t, sizeof_x) ;
d2765 1
a2765 1
    
d2769 2
a2770 6
    
    /* data used + datalen + cell's length field */
    if ((t - (char *)h->msg) + sizeof_x + 4 > h->insize)
	return EINVAL;
    
    memcpy(&cred.ct, t, sizeof_x) ;
d2776 1
a2776 1
    
d2778 2
a2779 2
    strlcpy(realm, t, min(h->insize - (t - (char *)h->msg), sizeof(realm)));
    strlwr(realm);
d2781 6
a2786 1
    cell = cell_name2num(realm);
d2793 2
a2794 2
    cred_add (h->cred.pag, CRED_KRB4, 2, cell, cred.ct.EndTimestamp,
	      &cred, sizeof(cred), cred.ct.ViceId);
d2799 1
a2799 1
viocunlog (int fd, struct nnpfs_message_pioctl *h, u_int size)
d2801 1
a2801 1
    nnpfs_pag_t cred = h->cred.pag;
a2807 127
#if defined(HAVE_KRB5) && defined(WITH_RXGK)

/*
 * handle rxgk kerberos 5 authenticator
 *
 * format:
 *  int32_t ticket_len
 *  char krb5_ticket[];
 *  int32_t kvno;
 *  int32_t krb5_enctype;
 *  int32_t viceid;
 *  int32_t sessionkey_len;
 *  char sessionkey[];
 *  int64_t start_time;
 *  int64_t expiration_time;
 *  char cell[]
 */

size_t k5ticket_limit_size = 40 * 1024;

static int
k5settok (int fd, struct nnpfs_message_pioctl *h, u_int size)
{
    struct cred_rxgk c;
    char cellname[256];
    uint32_t sizeof_x;
    uint64_t endtime;
    int32_t viceid;
    long cell;
    char *t = h->msg;
    int insize = h->insize;

    if (insize < 4)
	return EINVAL;

    memcpy(&sizeof_x, t, sizeof(sizeof_x)) ;
    arla_warnx (ADEBMSG, "ticket has size %d", sizeof_x);
    t += sizeof(sizeof_x) ;

    if (sizeof_x < k5ticket_limit_size || sizeof_x > insize)
	return EINVAL;

    c.type = CRED_GK_K5;

    c.t.k5.ticket = malloc(sizeof_x);
    if (c.t.k5.ticket == NULL)
	return ENOMEM;

    memcpy(c.t.k5.ticket, t, sizeof_x);
    insize -= sizeof_x;
    t += sizeof_x;

    if (h->insize < 4 + 4 + 4 + 4) {
	free(c.t.k5.ticket);
	return EINVAL;
    }

    memcpy(&sizeof_x, t, sizeof(sizeof_x));
    t += sizeof(sizeof_x); insize -= sizeof(sizeof_x);
    c.t.k5.enctype = sizeof_x;

    memcpy(&sizeof_x, t, sizeof(sizeof_x));
    t += sizeof(sizeof_x); insize -= sizeof(sizeof_x);
    c.t.k5.kvno = sizeof_x;

    memcpy(&sizeof_x, t, sizeof(sizeof_x));
    t += sizeof(sizeof_x); insize -= sizeof(sizeof_x);
    viceid = sizeof_x;

    memcpy(&sizeof_x, t, sizeof(sizeof_x));
    t += sizeof(sizeof_x); insize -= sizeof(sizeof_x);
    c.t.k5.sessionkey_len = sizeof_x;

    if (sizeof_x < k5ticket_limit_size || sizeof_x > insize) {
	free(c.t.k5.ticket);
	return EINVAL;
    }

    c.t.k5.sessionkey = malloc(c.t.k5.sessionkey_len);
    if (c.t.k5.sessionkey == NULL) {
	free(c.t.k5.ticket);
	return EINVAL;
    }

    memcpy(c.t.k5.sessionkey, t, c.t.k5.sessionkey_len);
    t += c.t.k5.sessionkey_len;
    insize -= c.t.k5.sessionkey_len;


    if (insize < 8 + 8 + 1) {
	free(c.t.k5.sessionkey);
	free(c.t.k5.ticket);
	return EINVAL;
    }

    t += 8;
    insize -= 8;

    memcpy(&endtime, t, sizeof(endtime));
    t += 8;
    insize -= 8;
    
    if (insize > sizeof(cellname) || t[insize - 1] != '\0') {
	free(c.t.k5.sessionkey);
	free(c.t.k5.ticket);
	return EINVAL;
    }

    strlcpy(cellname, t, sizeof(cellname));

    cell = cell_name2num(strlwr(cellname));

    if (cell == -1) {
	free(c.t.k5.sessionkey);
	free(c.t.k5.ticket);
	return ENOENT;
    }

    conn_clearcred (CONN_CS_ALL, cell, h->cred.pag, 2);
    fcache_purge_cred(h->cred.pag, cell);
    cred_add (h->cred.pag, CRED_GK_K5, 2, cell, (time_t)endtime,
	      &c, sizeof(c), viceid);
    return 0;
}

#endif /* HAVE_KRB5  && WITH_RXGK */

d2815 1
a2815 1
viocflush (int fd, struct nnpfs_message_pioctl *h, u_int size)
d2837 1
a2837 1
viocconnect(int fd, struct nnpfs_message_pioctl *h, u_int size)
a2854 10
	/* check permission */
	switch (tmp) {
	case CONNMODE_PROBE:
	    break;
	default:
	    if (!all_powerful_p(&h->cred))
		return EPERM;
	    break;
	}

d2868 3
a2870 10
	case CONNMODE_CONN_WITHCALLBACKS:
	    disco_closelog();

	    cmcb_reinit();

	    if (disco_need_integrate())
		disco_reintegrate(h->cred.pag);

	    if (tmp == CONNMODE_CONN_WITHCALLBACKS)
		fcache_reobtain_callbacks (&h->cred);
d2872 8
a2882 1
	    disco_openlog();
d2886 7
a2892 3
	    disco_openlog();
	    if (possibly_have_network())
		fcache_giveup_all_callbacks();
d2901 2
a2902 2
    nnpfs_send_message_wakeup_data (fd, h->header.sequence_num, error,
				    &ret, sizeof(ret));
d2907 1
a2907 1
getrxkcrypt(int fd, struct nnpfs_message_pioctl *h, u_int size)
d2909 2
a2910 2
    if (h->outsize == sizeof(uint32_t)) {
	uint32_t n;
d2919 5
a2923 5
	return nnpfs_send_message_wakeup_data (fd,
					       h->header.sequence_num,
					       0,
					       &n,
					       sizeof(n));
d2925 1
a2925 1
	return nnpfs_send_message_wakeup (fd, h->header.sequence_num, EINVAL);
d2929 1
a2929 1
setrxkcrypt(int fd, struct nnpfs_message_pioctl *h, u_int size)
d2934 2
a2935 5
    if (!all_powerful_p(&h->cred))
	return EPERM;

    if (h->insize == sizeof(uint32_t)) {
	uint32_t n;
d2946 1
a2946 1
	    conn_clearcred (CONN_CS_SECIDX, 0, -1, 2);
d2956 1
a2956 1
 * XXX - this function sometimes does a wakeup_data and then an ordinary wakeup is sent in nnpfs_message_pioctl
d2960 1
a2960 1
vioc_fpriostatus (int fd, struct nnpfs_message_pioctl *h, u_int size)
a2975 2
    if (!all_powerful_p(&h->cred))
	return EPERM;
d2988 5
a2992 5
	nnpfs_send_message_wakeup_data (fd,
					h->header.sequence_num,
					0,
					&prio,
					sizeof(prio));
d3001 1
a3001 1
		   fprio->prio > FPRIO_MAX)
d3014 5
a3018 5
	nnpfs_send_message_wakeup_data (fd,
					h->header.sequence_num,
					0,
					&fprioritylevel,
					sizeof(fprioritylevel));
d3039 1
a3039 1
viocgetfid (int fd, struct nnpfs_message_pioctl *h, u_int size)
d3041 2
a3042 2
    return nnpfs_send_message_wakeup_data(fd, h->header.sequence_num, 0,
					  &h->handle, sizeof(VenusFid));
d3046 1
a3046 1
viocvenuslog (int fd, struct nnpfs_message_pioctl *h, u_int size)
a3054 1
    cell_status (stderr);
d3069 1
a3069 1
vioc_afs_sysname (int fd, struct nnpfs_message_pioctl *h, u_int size)
a3074 3
	char t_sysname[SYSNAMEMAXLEN];
	int size;

d3076 3
a3078 3
	    return nnpfs_send_message_wakeup (fd,
					      h->header.sequence_num,
					      EPERM);
d3081 3
a3083 9

	size = min(h->insize, SYSNAMEMAXLEN);

	memcpy(t_sysname, t, size);
	t_sysname[size - 1] = '\0';

	fcache_setdefsysname (t_sysname);

	return nnpfs_send_message_wakeup(fd, h->header.sequence_num, 0);
d3086 1
a3086 2
	const char *sysname = fcache_getdefsysname ();
	size_t sysname_len = strlen (sysname);
d3091 3
a3093 8
	    return nnpfs_send_message_wakeup (fd, h->header.sequence_num,
					      ENOMEM);
	/* Return always 1 as we do not support sysname lists.             */
	/* Historically the value of this uint32 has been success/failure. */
	/* OpenAFS' utilities treat this value as the number of elements   */
	/* in a list of returned sysnames. It was never meant to be buflen.*/
	*((uint32_t *)buf) = 1;
	memcpy (buf + 4, sysname, sysname_len);
d3096 2
a3097 2
	ret = nnpfs_send_message_wakeup_data (fd, h->header.sequence_num, 0,
					      buf, sysname_len + 5);
d3104 1
a3104 1
viocfilecellname (int fd, struct nnpfs_message_pioctl *h, u_int size)
d3111 2
a3112 2
	return nnpfs_send_message_wakeup_data(fd, h->header.sequence_num, 0,
					      cellname, strlen(cellname)+1);
d3114 2
a3115 2
	return nnpfs_send_message_wakeup_data(fd, h->header.sequence_num, EINVAL,
					      NULL, 0);
d3119 1
a3119 1
viocgetwscell (int fd, struct nnpfs_message_pioctl *h, u_int size)
d3124 2
a3125 2
    return nnpfs_send_message_wakeup_data(fd, h->header.sequence_num, 0,
					  cellname, strlen(cellname)+1);
d3129 1
a3129 1
viocsetcachesize (int fd, struct nnpfs_message_pioctl *h, u_int size)
d3131 1
a3131 1
    uint32_t *s = (uint32_t *)h->msg;
d3147 1
a3147 1
 *  out: hosts  - uint32_t number of hosts, followed by list of hosts being down.
d3151 1
a3151 1
viocckserv (int fd, struct nnpfs_message_pioctl *h, u_int size)
d3156 1
a3156 1
    uint32_t hosts[CKSERV_MAXSERVERS + 1];
d3160 1
a3160 1
	return nnpfs_send_message_wakeup (fd, h->header.sequence_num, EINVAL);
d3164 1
a3164 1
    flags = *(uint32_t *)h->msg;
d3172 1
a3172 1
	    return nnpfs_send_message_wakeup (fd, h->header.sequence_num, ENOENT);
d3181 2
a3182 2
    return nnpfs_send_message_wakeup_data (fd, h->header.sequence_num, 0,
					   hosts, msg_size);
d3191 1
a3191 1
viocgetcacheparms (int fd, struct nnpfs_message_pioctl *h, u_int size)
d3193 1
a3193 1
    uint32_t parms[16];
d3206 2
a3207 2
    return nnpfs_send_message_wakeup_data(fd, h->header.sequence_num, 0,
					  parms, sizeof(parms));
d3215 1
a3215 1
viocaviator (int fd, struct nnpfs_message_pioctl *h, u_int size)
d3217 1
a3217 1
    uint32_t parms[16];
d3224 2
a3225 2
    return nnpfs_send_message_wakeup_data(fd, h->header.sequence_num, 0,
					  parms, sizeof(parms));
d3233 1
a3233 1
vioc_arladebug (int fd, struct nnpfs_message_pioctl *h, u_int size)
d3237 2
a3238 2
	    return nnpfs_send_message_wakeup (fd, h->header.sequence_num,
					      EINVAL);
d3240 2
a3241 2
	    return nnpfs_send_message_wakeup (fd, h->header.sequence_num,
					      EPERM);
d3248 2
a3249 2
	    return nnpfs_send_message_wakeup (fd, h->header.sequence_num,
					      EINVAL);
d3252 3
a3254 3
	return nnpfs_send_message_wakeup_data (fd, h->header.sequence_num,
					       0, &debug_level,
					       sizeof(debug_level));
d3256 1
a3256 1
    return nnpfs_send_message_wakeup (fd, h->header.sequence_num, 0);
d3264 1
a3264 1
vioc_gcpags (int fd, struct nnpfs_message_pioctl *h, u_int size)
d3270 1
a3270 1
 * Break the callback of the specified fid
d3274 1
a3274 1
vioc_calculate_cache (int fd, struct nnpfs_message_pioctl *h, u_int size)
d3276 1
a3276 1
    uint32_t parms[16];
d3292 2
a3293 2
    return nnpfs_send_message_wakeup_data (fd, h->header.sequence_num, 0,
					   &parms, sizeof(parms));
d3301 1
a3301 1
vioc_breakcallback(int fd, struct nnpfs_message_pioctl *h, u_int size)
d3344 1
a3344 9
vioc_ckback(int fd, struct nnpfs_message_pioctl *h, u_int size)
{
    volcache_invalidate_all ();
    fcache_invalidate_mp ();
    return 0;
}

static int
statistics_hostpart(int fd, struct nnpfs_message_pioctl *h, u_int size)
d3346 3
a3348 3
    uint32_t host[100];
    uint32_t part[100];
    uint32_t outparms[512];
d3354 3
a3356 3
    if (h->outsize < sizeof(uint32_t))
	return nnpfs_send_message_wakeup (fd, h->header.sequence_num,
					  EINVAL);
d3360 1
a3360 1
    maxslots = (h->outsize / sizeof(uint32_t) - 1) / 2;
d3364 1
a3364 1
    outsize = (n * 2 + 1) * sizeof(uint32_t);
d3372 2
a3373 2
    return nnpfs_send_message_wakeup_data (fd, h->header.sequence_num, 0,
					   (char *) &outparms, outsize);
d3377 1
a3377 1
statistics_entry(int fd, struct nnpfs_message_pioctl *h, u_int size)
d3379 6
a3384 6
    uint32_t *request = (uint32_t *) h->msg;
    uint32_t host;
    uint32_t part;
    uint32_t type;
    uint32_t items_slot;
    uint32_t count[32];
d3387 1
a3387 1
    uint32_t outparms[160];
d3391 3
a3393 3
    if (h->insize < sizeof(uint32_t) * 5) {
	return nnpfs_send_message_wakeup (fd, h->header.sequence_num,
					  EINVAL);
d3396 3
a3398 3
    if (h->outsize < sizeof(uint32_t) * 160) {
	return nnpfs_send_message_wakeup (fd, h->header.sequence_num,
					  EINVAL);
d3421 2
a3422 2
    return nnpfs_send_message_wakeup_data (fd, h->header.sequence_num, 0,
					   (char *) &outparms, sizeof(outparms));
d3426 1
a3426 1
aioc_statistics(int fd, struct nnpfs_message_pioctl *h, u_int size)
d3428 1
a3428 1
    uint32_t opcode;
d3431 2
a3432 2
	return nnpfs_send_message_wakeup (fd, h->header.sequence_num,
					  EPERM);
d3434 3
a3436 3
    if (h->insize < sizeof(opcode))
	return nnpfs_send_message_wakeup (fd, h->header.sequence_num,
					  EPERM);
d3438 1
a3438 1
    memcpy(&opcode, &h->msg, sizeof(opcode));
d3440 1
a3440 2
    switch (opcode) {
    case STATISTICS_OPCODE_LIST:
d3442 1
a3442 1
    case STATISTICS_OPCODE_GETENTRY:
d3444 3
a3446 42
    default:
	return nnpfs_send_message_wakeup (fd, h->header.sequence_num,
					  EINVAL);
    }
}


static int
aioc_getcacheparam(int fd, struct nnpfs_message_pioctl *h, u_int size)
{
    int32_t opcode;
    int64_t val;
    int error = 0;

    if (h->insize < sizeof(opcode) || h->outsize < sizeof(int64_t))
	return nnpfs_send_message_wakeup (fd, h->header.sequence_num,
					  EINVAL);

    memcpy(&opcode, &h->msg, sizeof(opcode));

    switch(opcode) {
    case GETCACHEPARAMS_OPCODE_HIGHBYTES:
	val = fcache_highbytes();
	break;
    case GETCACHEPARAMS_OPCODE_USEDBYTES:
	val = fcache_usedbytes();
	break;
    case GETCACHEPARAMS_OPCODE_LOWBYTES:
	val = fcache_lowbytes();
	break;
    case GETCACHEPARAMS_OPCODE_HIGHVNODES:
	val = fcache_highvnodes();
	break;
    case GETCACHEPARAMS_OPCODE_USEDVNODES:
	val = fcache_usedvnodes();
	break;
    case GETCACHEPARAMS_OPCODE_LOWVNODES:
	val = fcache_lowvnodes();
	break;
    default:
	error = EINVAL;
	break;
a3447 3

    return nnpfs_send_message_wakeup_data (fd, h->header.sequence_num, 0,
					   (char *) &val, sizeof(val));
d3456 1
a3456 1
nnpfs_message_pioctl (int fd, struct nnpfs_message_pioctl *h, u_int size)
a3469 12

#if defined(HAVE_KRB5) && defined(WITH_RXGK)
#ifdef AFSCOMMONIOC_GKK5SETTOK_32
    case AFSCOMMONIOC_GKK5SETTOK_32:
    case AFSCOMMONIOC_GKK5SETTOK_64:
#else
    case AFSCOMMONIOC_GKK5SETTOK:
#endif
	error = k5settok(fd, h, size);
	break;
#endif /* HAVE_KRB5 && WITH_RXGK */

a3724 1
	error = vioc_ckback (fd, h, size);
d3727 1
a3727 1
#ifdef AIOC_STATISTICS_32
a3734 8
#ifdef AIOC_GETCACHEPARAMS_32
    case AIOC_GETCACHEPARAMS_32:
    case AIOC_GETCACHEPARAMS_64:
#else
    case AIOC_GETCACHEPARAMS:
#endif
	return aioc_getcacheparam(fd, h, size);

d3740 1
a3740 1
    nnpfs_send_message_wakeup (fd, h->header.sequence_num, error);
a3744 56

/*
 * Return non-zero if there is a possibility that we have a network
 * connectivity. Can't tell the existence of network, just the lack of.
 *
 * Ignore lookback interfaces and known loopback addresses.
 */

static int
possibly_have_network(void)
{
    struct ifaddrs *ifa, *ifa0;
    int found_addr = 0;

    if (getifaddrs(&ifa0) != 0)
	return 1; /* well we don't really have a clue, do we ? */

    for (ifa = ifa0; ifa != NULL && !found_addr; ifa = ifa->ifa_next) {
	if (ifa->ifa_addr == NULL)
	    continue;

#if IFF_LOOPBACK
	if (ifa->ifa_flags & IFF_LOOPBACK)
	    continue;
#endif

	switch (ifa->ifa_addr->sa_family) {
	case AF_INET: {
	    struct sockaddr_in *sin = (struct sockaddr_in *)ifa->ifa_addr;
	    if (sin->sin_addr.s_addr == htonl(0x7f000001))
		continue;
	    if (sin->sin_addr.s_addr == htonl(0))
		continue;
	    found_addr = 1;
	    break;
	}
#ifdef RX_SUPPORT_INET6
	case AF_INET6:
	    /* 
	     * XXX avoid link local and local loopback addresses since
	     * those are not allowed in VLDB
	     */
	    found_addr = 1;
	    break;
#endif
	default:
	    break;
	}
    }
    freeifaddrs(ifa0);

    /* if we found an acceptable address, good for us */
    if (found_addr)
	return 1;
    return 0;
}
@


