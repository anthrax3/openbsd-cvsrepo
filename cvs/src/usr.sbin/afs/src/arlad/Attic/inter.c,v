head	1.10;
access;
symbols
	OPENBSD_5_2:1.9.0.24
	OPENBSD_5_2_BASE:1.9
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.22
	OPENBSD_5_0:1.9.0.20
	OPENBSD_5_0_BASE:1.9
	OPENBSD_4_9:1.9.0.18
	OPENBSD_4_9_BASE:1.9
	OPENBSD_4_8:1.9.0.16
	OPENBSD_4_8_BASE:1.9
	OPENBSD_4_7:1.9.0.12
	OPENBSD_4_7_BASE:1.9
	OPENBSD_4_6:1.9.0.14
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.9.0.10
	OPENBSD_4_5_BASE:1.9
	OPENBSD_4_4:1.9.0.8
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3:1.9.0.6
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.9.0.4
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.9.0.2
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.8.0.12
	OPENBSD_4_0_BASE:1.8
	OPENBSD_3_9:1.8.0.10
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.8.0.8
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.8.0.6
	OPENBSD_3_7_BASE:1.8
	OPENBSD_3_6:1.8.0.4
	OPENBSD_3_6_BASE:1.8
	OPENBSD_3_5:1.8.0.2
	OPENBSD_3_5_BASE:1.8
	OPENBSD_3_4:1.6.0.2
	OPENBSD_3_4_BASE:1.6
	arla-20030805:1.1.1.3
	OPENBSD_3_3:1.4.0.4
	OPENBSD_3_3_BASE:1.4
	OPENBSD_3_2:1.4.0.2
	OPENBSD_3_2_BASE:1.4
	arla-0-35-7:1.1.1.2
	OPENBSD_3_1:1.3.0.8
	OPENBSD_3_1_BASE:1.3
	OPENBSD_3_0:1.3.0.6
	OPENBSD_3_0_BASE:1.3
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_9:1.3.0.4
	OPENBSD_2_8:1.3.0.2
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.2.0.4
	OPENBSD_2_7_BASE:1.2
	OPENBSD_2_6:1.2.0.2
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.1.1.1.0.4
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.2
	OPENBSD_2_4_BASE:1.1.1.1
	arla-0_9:1.1.1.1
	arla:1.1.1;
locks; strict;
comment	@ * @;


1.10
date	2012.08.23.06.21.50;	author deraadt;	state dead;
branches;
next	1.9;

1.9
date	2006.12.23.21.08.01;	author krw;	state Exp;
branches;
next	1.8;

1.8
date	2004.02.27.19.17.36;	author beck;	state Exp;
branches;
next	1.7;

1.7
date	2003.12.16.20.13.55;	author beck;	state Exp;
branches;
next	1.6;

1.6
date	2003.08.18.11.43.03;	author hin;	state Exp;
branches;
next	1.5;

1.5
date	2003.08.05.08.42.41;	author hin;	state Exp;
branches;
next	1.4;

1.4
date	2002.06.07.04.28.57;	author hin;	state Exp;
branches;
next	1.3;

1.3
date	2000.09.11.14.40.42;	author art;	state Exp;
branches;
next	1.2;

1.2
date	99.04.30.01.59.08;	author art;	state Exp;
branches;
next	1.1;

1.1
date	98.09.14.21.52.56;	author art;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.09.14.21.52.56;	author art;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.06.07.04.14.24;	author hin;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2003.08.05.08.21.01;	author hin;	state Exp;
branches;
next	;


desc
@@


1.10
log
@the afs src tree can go away
@
text
@/*
 * Copyright (c) 1995 - 2002 Kungliga Tekniska Högskolan
 * (Royal Institute of Technology, Stockholm, Sweden).
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * Interface to the cache manager.
 */

#include "arla_local.h"
RCSID("$arla: inter.c,v 1.138 2003/01/10 03:05:44 lha Exp $") ;

#include <nnpfs/nnpfs_message.h>

Bool cm_consistencyp = FALSE;

/*
 * Return the rights for user cred and entry e.
 * If the rights are not existant fill in the entry.
 * The locking of e is up to the caller.
 */

static u_long
getrights (FCacheEntry *e, CredCacheEntry *ce)
{
     AccessEntry *ae;
     int error;

     while (findaccess (ce->cred, e->acccache, &ae) == FALSE) {
	 if ((error = read_attr(e, ce)) != 0)
	     return 0; /* XXXX  we want to return errno */
     }
     return ae->access;
}

/*
 * Check to see if the operation(s) mask are allowed to user cred on
 * file e
 */

static Bool
checkright (FCacheEntry *e, u_long mask, CredCacheEntry *ce)
{
    u_long rights;

    if (e->status.FileType == TYPE_LINK &&
	e->anonaccess & ALIST)
	return TRUE;
    if ((e->anonaccess & mask) == mask)
	return TRUE;
    rights = getrights (e, ce);
    if (e->status.FileType == TYPE_LINK &&
	rights & ALIST)
	return TRUE;
    if ((rights & mask) == mask)
	return TRUE;
    return FALSE;
}

static int log_fd;
static FILE *log_fp;

/*
 *
 */

void
cm_init (void)
{
    log_fd = open ("log", O_WRONLY | O_APPEND | O_CREAT | O_BINARY, 0666);
    if (log_fd < 0)
	arla_err (1, ADEBERROR, errno, "open log");
    log_fp = fdopen (log_fd, "a");
    if (log_fp == NULL)
	arla_err (1, ADEBERROR, errno, "fdopen");
}

/*
 *
 */

void
cm_store_state (void)
{
    fclose (log_fp);
}

/*
 *
 */

static void
log_operation (const char *fmt, ...)
{
    va_list args;
    struct timeval now;

    if(connected_mode == CONNECTED && cm_consistencyp == FALSE)
	return;

    va_start (args, fmt);
    gettimeofday (&now, NULL);
    fprintf (log_fp, "%lu.%lu ",
	     (unsigned long)now.tv_sec,
	     (unsigned long)now.tv_usec);
    vfprintf (log_fp, fmt, args);
    va_end (args);
}

/*
 *
 *
 */

void
cm_turn_on_consistency_check(void)
{
    cm_consistencyp = TRUE;
}

/*
 * Check consistency of the fcache.
 * Will break the log-file.
 */

void
cm_check_consistency (void)
{
    static unsigned int log_times = 0;
    static unsigned int file_times = 0;
    int64_t calc_size, real_size;
    char newname[MAXPATHLEN];

    if (cm_consistencyp == FALSE)
	return;
    
    calc_size = fcache_calculate_usage();
    real_size = fcache_usedbytes ();

    if (calc_size != real_size) {
	    log_operation ("consistency check not guaranteed "
			   "(calc: %d, real: %d, diff %d), exiting\n", 
			   (int) calc_size, (int) real_size,
			   (int)(calc_size - real_size));
	    cm_store_state ();
	    exit(-1);
    }
    if (log_times % 100000 == 0) {
	log_operation ("consistency check ok, rotating logs\n");
	cm_store_state ();
	snprintf (newname, sizeof(newname), "log.%d", file_times++);
	rename ("log", newname);
	cm_init ();	
	log_operation ("brave new world\n");
    }
    log_times++;
}

/*
 * These functions often take a FID as an argument to be general, but
 * they are intended to be called from a vnode-type of layer.
 */

/*
 * The interface to the open-routine.
 */

int
cm_open (FCacheEntry *entry, CredCacheEntry *ce, u_int tokens)
{
     u_long mask;
     int error = 0;

     switch(tokens) {
     case NNPFS_DATA_R:
#if 0
     case NNPFS_OPEN_NR:
     case NNPFS_OPEN_SR:
#endif
	  mask = AREAD;
	  break;
     case NNPFS_DATA_W:
	  mask = AWRITE;
	  break;
     case NNPFS_OPEN_NW:
	  mask = AREAD | AWRITE;
	  tokens |= NNPFS_DATA_R | NNPFS_DATA_W;
	  break;
     default:
	 arla_warnx (ADEBCM, "cm_open(): unknown token: %d, assuming AREAD",
		     tokens);
	 mask = AREAD;
	 tokens |= NNPFS_DATA_R;
     }

     if (checkright (entry, mask, ce)) {
	  assert(entry->flags.attrusedp);
	  entry->flags.datausedp = TRUE;
	  entry->tokens |= tokens;
	  
	  log_operation ("open (%ld,%lu,%lu,%lu) %u\n",
			 entry->fid.Cell,
			 entry->fid.fid.Volume,
			 entry->fid.fid.Vnode,
			 entry->fid.fid.Unique,
			 mask);
     } else
	  error = EACCES;

     cm_check_consistency();
 
     return error;
}

/*
 * close. Set flags and if we opened the file for writing, write it
 * back to the server.
 */

int
cm_close (FCacheEntry *entry, int flag,
	  AFSStoreStatus *status, CredCacheEntry* ce)
{
    int error = 0;

    if (flag & NNPFS_WRITE) {
	if (flag & NNPFS_FSYNC)
	    status->Mask |= SS_FSYNC;

	error = write_data (entry, status, ce);

	if (error) {
	    arla_warn (ADEBCM, error, "writing back file");
	    return error;
	}
    }

    log_operation ("close (%ld,%lu,%lu,%lu) %d\n",
		   entry->fid.Cell,
		   entry->fid.fid.Volume,
		   entry->fid.fid.Vnode,
		   entry->fid.fid.Unique,
		   flag);

    cm_check_consistency();

    return error;
}

/*
 * getattr - read the attributes from this file.
 */

int
cm_getattr (FCacheEntry *entry,
	    CredCacheEntry *ce,
	    AccessEntry **ae)
{
     int error = 0;

     arla_warnx (ADEBCM, "cm_getattr");

     assert (ae);

     AssertExclLocked(&entry->lock);

     error = fcache_verify_attr (entry, NULL, NULL, ce);
     if (error)
	 return error;

     arla_warnx (ADEBCM, "cm_getattr: done get attr");

     if (checkright (entry,
		     entry->status.FileType == TYPE_FILE ? AREAD : 0,
		     ce)) {
	 entry->flags.attrusedp = TRUE;
	 entry->flags.kernelp   = TRUE;
	 *ae = entry->acccache;
	 
	 log_operation ("getattr (%ld,%lu,%lu,%lu)\n",
			entry->fid.Cell,
			entry->fid.fid.Volume,
			entry->fid.fid.Vnode,
			entry->fid.fid.Unique);
	 
     } else {
	 *ae = NULL;
	 error = EACCES;
     }
     if (!entry->flags.datausedp)
	 entry->tokens &= ~(NNPFS_DATA_MASK | NNPFS_OPEN_MASK);
     
     arla_warnx (ADEBCM, "cm_getattr: return: %d", error);
     cm_check_consistency();

     return error;
}

/*
 * setattr - set the attributes of this file. These are immediately
 * sent to the FS.
 */

int
cm_setattr (FCacheEntry *entry, AFSStoreStatus *attr, CredCacheEntry* ce)
{
     int error = 0;

     error = fcache_verify_attr (entry, NULL, NULL, ce);
     if (error)
	 return error;

     if (checkright (entry, AWRITE, ce)) {
	  arla_warnx (ADEBCM, "cm_setattr: Writing status");
	  error = write_attr (entry, attr, ce);

	  log_operation ("setattr (%ld,%lu,%lu,%lu)\n",
			 entry->fid.Cell,
			 entry->fid.fid.Volume,
			 entry->fid.fid.Vnode,
			 entry->fid.fid.Unique);
     } else
	 error = EACCES;

     cm_check_consistency();
     return error;
}

/*
 * ftruncate - make the specified file have a specified size
 */

int
cm_ftruncate (FCacheEntry *entry, off_t size,
	      AFSStoreStatus *storestatus, CredCacheEntry* ce)
{
     int error = 0;

     error = fcache_verify_attr (entry, NULL, NULL, ce);
     if (error)
	 return error;

     if (size) {
	 error = fcache_verify_data (entry, ce);
	 if (error)
	     return error;
     }

     if (checkright (entry, AWRITE, ce)) {
	  error = truncate_file (entry, size, storestatus, ce);

	  log_operation ("ftruncate (%ld,%lu,%lu,%lu) %lu\n",
			 entry->fid.Cell,
			 entry->fid.fid.Volume,
			 entry->fid.fid.Vnode,
			 entry->fid.fid.Unique,
			 (unsigned long)size);
     } else
	 error = EACCES;

     cm_check_consistency();
     return error;
}

/*
 * access - check if user is allowed to perform operation.
 */

int
cm_access (FCacheEntry *entry, int mode, CredCacheEntry* ce)
{
     int error = 0;

     error = fcache_verify_attr (entry, NULL, NULL, ce);
     if (error)
	 return error;

     if (checkright (entry, AWRITE, ce))
	 error = 0;
     else
	 error = EACCES;

     log_operation ("access (%ld,%lu,%lu,%lu)\n",
		    entry->fid.Cell,
		    entry->fid.fid.Volume,
		    entry->fid.fid.Vnode,
		    entry->fid.fid.Unique);

     cm_check_consistency();
     return error;
}

/*
 * Expand `src' into `dest' (of size `dst_sz'), expanding `str' to
 * `replacement'. Return number of characters written to `dest'
 * (excluding terminating zero) or `dst_sz' if there's not enough
 * room.
 */

static int
expand_sys (char *dest, size_t dst_sz, const char *src,
	    const char *str, const char *rep)
{
    char *destp = dest;
    const char *srcp = src;
    char *s;
    int n = 0;
    int len;
    size_t str_len = strlen(str);
    size_t rep_len = strlen(rep);
    size_t src_len = strlen(src);
    
    while ((s = strstr (srcp, str)) != NULL) {
	len = s - srcp;

	if (dst_sz <= n + len + rep_len)
	    return dst_sz;

	memcpy (destp, srcp, len);
	memcpy (destp + len, rep, rep_len);
	n += len + rep_len;
	destp += len + rep_len;
	srcp = s + str_len;
    }
    len = src_len - (srcp - src);
    if (dst_sz <= n + len)
	return dst_sz;
    memcpy (destp, srcp, len);
    n += len;
    destp[len] = '\0';
    return n;
}

/*
 * Find this entry in the directory. If the entry happens to point to
 * a mount point, then we follow that and return the root directory of
 * the volume. Hopefully this is the only place where we need to think
 * about mount points (which are followed iff follow_mount_point).
 */

int
cm_lookup (FCacheEntry **entry,
	   const char *name,
	   VenusFid *res,
	   CredCacheEntry** ce,
	   int follow_mount_point)
{
     char tmp_name[MAXPATHLEN];
     int error = 0;

     error = fcache_get_data(entry, ce, 0);
     if (error)
	 return error;

     if (strstr (name, "@@sys") != NULL) {
	 int i;

	 for (i = 0; i < sysnamenum; i++) {
	     int size = expand_sys (tmp_name, sizeof(tmp_name), name,
				    "@@sys", sysnamelist[i]);
	     if (size >= sizeof(tmp_name))
		 continue;
	     error = adir_lookup (*entry, tmp_name, res);
	     if (error == 0)
		 break;
	 }
	 if (i == sysnamenum)
	     error = ENOENT;

     } else
	 error = adir_lookup (*entry, name, res);

     if (error) 
	 return error;

     /* 
      * The ".." at the top of a volume just points to the volume root,
      * so get the real ".." from the volume cache instead.
      *
      * Or if we are looking up "." we don't want to follow the
      * mountpoint
      */

     if (strcmp(".", name) == 0) {

	 error = fcache_verify_attr (*entry, NULL, NULL, *ce);
	 if (error)
	     goto out;

	 *res = (*entry)->fid;
     } else if (strcmp("..", name) == 0
		&& VenusFid_cmp(&(*entry)->fid, res) == 0) {

	 error = fcache_verify_attr (*entry, NULL, NULL, *ce);
	 if (error)
	     goto out;

	 *res = (*entry)->volume->parent_fid; /* entry->parent */
     } else if (follow_mount_point) {
	 error = followmountpoint (res, &(*entry)->fid, *entry, ce);
	 if (error)
	     goto out;
     }
out:
     log_operation ("lookup (%ld,%lu,%lu,%lu) %s\n",
		    (*entry)->fid.Cell,
		    (*entry)->fid.fid.Volume,
		    (*entry)->fid.fid.Vnode,
		    (*entry)->fid.fid.Unique,
		    name);

     cm_check_consistency();
     return error;
}

/*
 * Create this file and more.
 */

int
cm_create (FCacheEntry **dir, const char *name, AFSStoreStatus *store_attr,
	   VenusFid *res, AFSFetchStatus *fetch_attr,
	   CredCacheEntry **ce)
{
     int error = 0;

     error = fcache_get_data (dir, ce, 0);
     if (error)
	 return error;

     if (checkright (*dir, AINSERT, *ce)) {
	 error = create_file (*dir, name, store_attr,
			      res, fetch_attr, *ce);
	 if (error == 0)
	     error = adir_creat (*dir, name, res->fid);
     } else
	 error = EACCES;

     log_operation ("create (%ld,%lu,%lu,%lu) %s\n",
		    (*dir)->fid.Cell,
		    (*dir)->fid.fid.Volume,
		    (*dir)->fid.fid.Vnode,
		    (*dir)->fid.fid.Unique,
		    name);

     cm_check_consistency();
     return error;
}

/*
 * Create a new directory
 */

int
cm_mkdir (FCacheEntry **dir, const char *name,
	  AFSStoreStatus *store_attr,
	  VenusFid *res, AFSFetchStatus *fetch_attr,
	  CredCacheEntry **ce)
{
     int error = 0;

     error = fcache_get_data (dir, ce, 0);
     if (error)
	 return error;

     if (checkright (*dir, AINSERT, *ce)) {
	 error = create_directory (*dir, name, store_attr,
				   res, fetch_attr, *ce);
	 if (error == 0)
	     error = adir_creat (*dir, name, res->fid);
	 
     } else
	 error = EACCES;

     log_operation ("mkdir (%ld,%lu,%lu,%lu) %s\n",
		    (*dir)->fid.Cell,
		    (*dir)->fid.fid.Volume,
		    (*dir)->fid.fid.Vnode,
		    (*dir)->fid.fid.Unique,
	      name);

     cm_check_consistency();
     return error;
}

/*
 * Create a symlink
 */

int
cm_symlink (FCacheEntry **dir,
	    const char *name, AFSStoreStatus *store_attr,
	    VenusFid *res, VenusFid *realfid,
	    AFSFetchStatus *fetch_attr,
	    const char *contents,
	    CredCacheEntry **ce)
{
     FCacheEntry *symlink_entry;
     int error = 0;

     error = fcache_get_data (dir, ce, 0);
     if (error)
	 return error;

     if (!checkright (*dir, AINSERT, *ce)) {
	 error = EACCES;
	 goto out;
     }

     /* It seems Transarc insists on mount points having mode bits 0644 */

     if (contents[0] == '%' || contents[0] == '#') {
	 store_attr->UnixModeBits = 0644;
	 store_attr->Mask |= SS_MODEBITS;
     } else if (store_attr->Mask & SS_MODEBITS
		&& store_attr->UnixModeBits == 0644)
	 store_attr->UnixModeBits = 0755;

     error = create_symlink (*dir, name, store_attr,
			     res, fetch_attr,
			     contents, *ce);
     if (error)
	 goto out;

     error = adir_creat (*dir, name, res->fid);
     if (error)
	 goto out;

     error = followmountpoint(res, &(*dir)->fid, NULL, ce);
     if (error)
	 goto out;
     
     /*
      * If the new symlink is a mountpoint and it points
      * to dir_fid we will deadlock if we look it up.
      */

     if (VenusFid_cmp (res, &(*dir)->fid) != 0) {

	 error = fcache_get (&symlink_entry, *res, *ce);
	 if (error)
	     goto out;
	 
	 error = fcache_verify_attr (symlink_entry, *dir, name, *ce);
	 if (error) {
	     fcache_release (symlink_entry);
	     goto out;
	 }
	 
	 symlink_entry->flags.kernelp = TRUE;

	 *fetch_attr = symlink_entry->status;
	 *realfid = *fcache_realfid (symlink_entry);

	 fcache_release (symlink_entry);
     } else {
	 *fetch_attr = (*dir)->status;
	 *realfid = *fcache_realfid (*dir);
     }
     
     log_operation ("symlink (%ld,%lu,%lu,%lu) %s %s\n",
		    (*dir)->fid.Cell,
		    (*dir)->fid.fid.Volume,
		    (*dir)->fid.fid.Vnode,
		    (*dir)->fid.fid.Unique,
		    name,
		    contents);
     
 out:
     cm_check_consistency();
     return error;
}

/*
 * Create a hard link.
 */

int
cm_link (FCacheEntry **dir,
	 const char *name,
	 VenusFid existing_fid,
	 AFSFetchStatus *existing_status,
	 CredCacheEntry **ce)
{
     FCacheEntry *file;
     int error = 0;

     error = fcache_get_data (dir, ce, 0);
     if (error)
	 return error;

     error = fcache_get (&file, existing_fid, *ce);
     if (error)
	 return error;

     error = fcache_verify_attr (file, *dir, NULL, *ce);
     if (error)
	 goto out;

     if (checkright (*dir, AINSERT, *ce)) {
	 error = create_link (*dir, name, file, *ce);
	 if (error == 0) {
	     error = adir_creat (*dir, name, existing_fid.fid);
	     if (error == 0)
		 *existing_status = file->status;
	 }
     } else 
	 error = EACCES;

     log_operation ("link (%ld,%lu,%lu,%lu) (%ld,%lu,%lu,%lu) %s\n",
		    (*dir)->fid.Cell,
		    (*dir)->fid.fid.Volume,
		    (*dir)->fid.fid.Vnode,
		    (*dir)->fid.fid.Unique,
		    existing_fid.Cell,
		    existing_fid.fid.Volume,
		    existing_fid.fid.Vnode,
		    existing_fid.fid.Unique,
		    name);

out:
     fcache_release(file);
     cm_check_consistency();
     return error;
}

/*
 * generic function for both remove and rmdir
 */

static int
sub_remove (FCacheEntry **dir, const char *name, CredCacheEntry **ce,
	    const char *operation,
	    int (*func)(FCacheEntry *fe,
			const char *name,
			CredCacheEntry *ce))
{
     int error = 0;

     error = fcache_get_data (dir, ce, 0);
     if (error)
	 return error;

     if (checkright (*dir, ADELETE, *ce)) {
	 error = (*func) (*dir, name, *ce);
	 if (error == 0)
	     error = adir_remove (*dir, name);
     } else 
	 error = EACCES;
     
     log_operation ("%s (%ld,%lu,%lu,%lu) %s\n",
		    operation,
		    (*dir)->fid.Cell,
		    (*dir)->fid.fid.Volume,
		    (*dir)->fid.fid.Vnode,
		    (*dir)->fid.fid.Unique,
		    name);

     cm_check_consistency();
     return error;
}

/*
 * Remove the file named `name' in the directory `dir'.
 */

int
cm_remove(FCacheEntry **dir,
	  const char *name, CredCacheEntry **ce)
{
    return sub_remove (dir, name, ce, "remove", remove_file);
}

/*
 * Remove the directory named `name' in the directory `dir'.
 */

int
cm_rmdir(FCacheEntry **dir,
	 const char *name, CredCacheEntry **ce)
{
    return sub_remove (dir, name, ce, "rmdir", remove_directory);
}

/*
 * Called when the object is being moved to a new directory, to be
 * able to update .. when required.
 */

static int
potential_update_dir(FCacheEntry *child_entry,
		     const VenusFid *new_parent_fid,
		     FCacheEntry *parent_entry,
		     int *update_child,
		     CredCacheEntry **ce)
{
    int error;

    error = fcache_verify_attr (child_entry, parent_entry, NULL, *ce);
    if (error) 
	return error;

    /*
     * if we're moving a directory.
     */

    if (child_entry->status.FileType == TYPE_DIR) {
	int fd;
	fbuf the_fbuf;

	error = fcache_get_data(&child_entry, ce, 0); /* XXX - check fake_mp */
	if (error)
	    return error;

	error = fcache_get_fbuf (child_entry, &fd, &the_fbuf, O_RDWR,
				 FBUF_READ|FBUF_WRITE|FBUF_SHARED);
	if (error)
	    return error;

	error = fdir_changefid (&the_fbuf, "..", new_parent_fid);
	fbuf_end (&the_fbuf);
	close (fd);
	if (error)
	    return error;

	*update_child = 1;
    }
    return 0;
}

/*
 * Rename (old_parent_fid, old_name) -> (new_parent_fid, new_name)
 * update the `child' in the new directory if update_child.
 * set child_fid to the fid of the moved object.
 */

int
cm_rename(FCacheEntry **old_dir, const char *old_name,
	  FCacheEntry **new_dir, const char *new_name,
	  VenusFid *child_fid,
	  int *update_child,
	  CredCacheEntry **ce)
{
    int error = 0;
    VenusFid new_fid, old_fid;
    
    *update_child = 0;

    /* old parent dir */

    error = fcache_get_data (old_dir, ce, 0);
    if (error)
	return error;

    /* new parent dir */

    error = fcache_get_data (new_dir, ce, 0);
    if (error)
	return error;

    if (!checkright (*old_dir, ADELETE, *ce)
	|| !checkright (*new_dir, AINSERT, *ce)) {
	error = EACCES;
	goto out;
    }
	
    error = rename_file (*old_dir, old_name, *new_dir, new_name, *ce);
    if (error)
	goto out;

    /*
     * Lookup the old name (to get the fid of the new name)
     */
    
    error = adir_lookup (*old_dir, old_name, &new_fid);
    
    if (error)
	goto out;
    
    *child_fid = new_fid;
    
    if (VenusFid_cmp (&(*old_dir)->fid, &(*new_dir)->fid)) {
	FCacheEntry *child_entry;
	
	error = fcache_get (&child_entry, *child_fid, *ce);
	if (error)
	    goto out;
	
	child_entry->parent = (*new_dir)->fid;
	
	error = potential_update_dir (child_entry, &(*new_dir)->fid,
				      *new_dir, update_child, ce);
	fcache_release (child_entry);
	if (error)
	    goto out;
    }
    
    /*
     * Lookup the new name, if it exists we need to silly
     * rename it was just killed on the fileserver.
     * XXXDISCO remember mark this node as dead
     */

    error = adir_lookup (*new_dir, new_name, &old_fid);
    if (error == 0) {
	FCacheEntry *old_entry;

	error = fcache_find (&old_entry, old_fid);
	if (error == 0) {
	    old_entry->flags.silly = TRUE;
	    fcache_release (old_entry);
	}
	adir_remove (*new_dir, new_name);
    }
    
    /*
     * Now do the rename, ie create the new name and remove
     * the old name.
     */
    
    error = adir_creat (*new_dir, new_name,  new_fid.fid)
	|| adir_remove (*old_dir, old_name);
    
    log_operation ("rename (%ld,%lu,%lu,%lu) (%ld,%lu,%lu,%lu) %s %s\n",
		   (*old_dir)->fid.Cell,
		   (*old_dir)->fid.fid.Volume,
		   (*old_dir)->fid.fid.Vnode,
		   (*old_dir)->fid.fid.Unique,
		   (*new_dir)->fid.Cell,
		   (*new_dir)->fid.fid.Volume,
		   (*new_dir)->fid.fid.Vnode,
		   (*new_dir)->fid.fid.Unique,
		   old_name, new_name);
    
 out:
    cm_check_consistency();
    return error;
}

/* 
 * An emulation of kernel lookup, convert (fid, name) into
 * (res).  Strips away leading /afs, removes double slashes,
 * and resolves symlinks.
 * Return 0 for success, otherwise -1.
 */

int
cm_walk (VenusFid fid,
	 const char *name,
	 VenusFid *res)
{
    VenusFid cwd = fid;
    char *base;
    VenusFid file;
    FCacheEntry *entry;
    FCacheEntry *dentry;
    int error;
    char symlink[MAXPATHLEN];
    char store_name[MAXPATHLEN];
    char *fname;
    CredCacheEntry *ce;

    ce = cred_get (fid.Cell, getuid(), CRED_ANY);
    
    strlcpy(store_name, name, sizeof(store_name));
    fname = store_name;
    
    do {
        /* set things up so that fname points to the remainder of the path,
         * whereas base points to the whatever precedes the first /
         */
        base = fname;
        fname = strchr(fname, '/');
        if (fname) {
            /* deal with repeated adjacent / chars by eliminating the
             * duplicates. 
             */
            while (*fname == '/') {
                *fname = '\0';
                fname++;
            }
        }
	
        /* deal with absolute pathnames first. */
        if (*base == '\0') {
	    error = getroot(&cwd, ce);
	    if (error) {
		arla_warn(ADEBWARN, error, "getroot");
		cred_free(ce);
		return -1;
	    }
	    
	    if (fname) {
		if (strncmp("afs",fname,3) == 0) {
		    fname += 3;
		    }
		continue;
	    } else {
		break;
	    }
	}
	error = fcache_get(&dentry, cwd, ce);
	if (error) {
	    arla_warn (ADEBWARN, error, "fcache_get");
	    cred_free(ce);
	    return -1;
	}
	error = cm_lookup (&dentry, base, &file, &ce, TRUE);
	if (error) {
	    fcache_release(dentry);
	    arla_warn (ADEBWARN, error, "lookup(%s)", base);
	    cred_free(ce);
	    return -1;
	}
	fcache_release(dentry);
	error = fcache_get(&entry, file, ce);
	if (error) {
	    arla_warn (ADEBWARN, error, "fcache_get");
	    cred_free(ce);
	    return -1;
	}
	
	error = fcache_get_data (&entry, &ce, 0);
	if (error) {
	    fcache_release(entry);
	    arla_warn (ADEBWARN, error, "fcache_get_data");
	    cred_free(ce);
	    return -1;
	}
	
	/* handle symlinks here */
	if (entry->status.FileType == TYPE_LINK) {
	    int len;
	    int fd;
	    
	    fd = fcache_open_file (entry, O_RDONLY);
	    /* read the symlink and null-terminate it */
	    if (fd < 0) {
		fcache_release(entry);
		arla_warn (ADEBWARN, errno, "fcache_open_file");
		cred_free(ce);
		return -1;
	    }
	    len = read (fd, symlink, sizeof(symlink));
	    close (fd);
	    if (len <= 0) {
		fcache_release(entry);
		arla_warnx (ADEBWARN, "cannot read symlink");
		cred_free(ce);
		return -1;
	    }
	    symlink[len] = '\0';
	    /* if we're not at the end (i.e. fname is not null), take
	     * the expansion of the symlink and append fname to it.
	     */
	    if (fname != NULL) {
		    
		strlcat (symlink, "/", sizeof(symlink));
		strlcat (symlink, fname, sizeof(symlink));
	    }
	    strlcpy(store_name, symlink, sizeof(store_name));
	    fname = store_name;
	} else {
	    /* if not a symlink, just update cwd */
	    cwd = entry->fid;
	}
	fcache_release(entry);
	
	/* the *fname condition below deals with a trailing / in a
	 * path-name */
    } while (fname != NULL && *fname);
    *res = cwd;
    cred_free(ce);
    return 0;
}
@


1.9
log
@Spelling.

'preceeding' -> 'preceding'
'preceeds' -> 'precedes'
'preceeded' -> 'preceded'
@
text
@@


1.8
log
@fix bogus assert() usage in afsd, and avoid an assert when
ThisCell is specified as a nonexeistent cell. found by matthieu@@,
ok deraadt@@
@
text
@d998 1
a998 1
         * whereas base points to the whatever preceeds the first /
@


1.7
log
@afs cleanup, realloc strings, abort, etc.
testing by beck, hin, jose, fries. ok deraadt@@
@
text
@a221 3
#if 0
	 assert(FALSE);
#endif
@


1.6
log
@Simple string cleanup.

ok todd@@
@
text
@d170 1
a170 1
			   "(calc: %d, real: %d, diff %d), aborting\n", 
d174 1
a174 1
	    abort();
@


1.5
log
@Merge
@
text
@d1088 3
a1090 2
		strcat (symlink, "/");
		strcat (symlink, fname);
@


1.4
log
@merge
@
text
@d2 1
a2 1
 * Copyright (c) 1995 - 2000 Kungliga Tekniska Högskolan
d39 1
a39 1
RCSID("$KTH: inter.c,v 1.110.2.3 2001/06/05 01:27:05 ahltorp Exp $") ;
d41 1
a41 1
#include <xfs/xfs_message.h>
a129 3
#ifdef USE_MMAPTIME
    mmaptime_gettimeofday (&now, NULL);
#else
a130 1
#endif
d159 1
a159 2
    u_long calc_size;
    u_long real_size;
d170 3
a172 2
			   "(calc: %d, real: %d), aborting\n", 
			   (int) calc_size, (int) real_size);
d194 4
a197 13
 * This means that the file should be in the local cache and that the
 * cache manager should recall that some process has this file opened
 * for reading and/or writing.
 * We do no checking here. Should we?
 */

Result
cm_open (VenusFid *fid,
	 CredCacheEntry **ce,
	 u_int tokens,
	 fcache_cache_handle *cache_handle,
	 char *cache_name,
	 size_t cache_name_sz)
a198 2
     FCacheEntry *entry;
     Result ret;
d200 1
a200 8
     int error;

     error = fcache_get_data (&entry, fid, ce);
     if (error) {
	 ret.res = -1;
	 ret.error = error;
	 return ret;
     }
d203 5
a207 3
     case XFS_DATA_R:
       /*     case XFS_OPEN_NR:
     case XFS_OPEN_SR: */
d210 1
a210 1
     case XFS_DATA_W:
d213 1
a213 1
     case XFS_OPEN_NW:
d215 1
d221 4
a224 1
/*	  assert(FALSE); */
d227 1
a227 2
     if (checkright (entry, mask, *ce)) {
#if 0
a228 1
#endif
a230 3
	  ret.res    = 0;
	  ret.error  = 0;
	  ret.tokens = entry->tokens;
a231 3
	  *cache_handle = entry->handle;
	  fcache_file_name (entry, cache_name, cache_name_sz);

d233 4
a236 2
			 fid->Cell,
			 fid->fid.Volume, fid->fid.Vnode, fid->fid.Unique,
d238 2
a239 5
     } else {
	  ret.res = -1;
	  ret.error = EACCES;
     }
     fcache_release(entry);
d243 1
a243 1
     return ret;
d251 3
a253 2
Result
cm_close (VenusFid fid, int flag, AFSStoreStatus *status, CredCacheEntry* ce)
d255 1
a255 10
    FCacheEntry *entry;
    Result ret;
    int error;

    error = fcache_get (&entry, fid, ce);
    if (error) {
	ret.res   = -1;
	ret.error = error;
	return ret;
    }
d257 2
a258 2
    if (flag & XFS_WRITE) {
	if (flag & XFS_FSYNC)
a263 1
	    fcache_release(entry);
d265 1
a265 3
	    ret.res   = -1;
	    ret.error = error;
	    return ret;
d270 5
a274 5
	     fid.Cell, fid.fid.Volume, fid.fid.Vnode, fid.fid.Unique,
	     flag);
    fcache_release(entry);
    ret.res   = 0;
    ret.error = 0;
d278 1
a278 1
    return ret;
d285 2
a286 4
Result
cm_getattr (VenusFid fid,
	    AFSFetchStatus *attr,
	    VenusFid *realfid,
d290 1
a290 3
     FCacheEntry *entry;
     Result ret;
     int error;
a295 7
     error = fcache_get (&entry, fid, ce);
     if (error) {
	 ret.res   = -1;
	 ret.error = error;
	 return ret;
     }
     
d299 2
a300 6
     if (error) {
	 fcache_release(entry);
	 ret.res   = -1;
	 ret.error = error;
	 return ret;
     }
a306 3
	 *attr = entry->status;
	 ret.res   = 0;
	 ret.error = 0;
d312 4
a315 1
			fid.Cell, fid.fid.Volume, fid.fid.Vnode, fid.fid.Unique);
d319 1
a319 2
	 ret.res   = -1;
	 ret.error = EACCES;
a320 2
     *realfid = *fcache_realfid (entry);
     ret.tokens = entry->tokens;
d322 1
a322 2
	 ret.tokens &= ~(XFS_DATA_MASK | XFS_OPEN_MASK);
     fcache_release(entry);
d324 1
a324 1
     arla_warnx (ADEBCM, "cm_getattr: return: %d.%d", ret.res, ret.error);
d327 1
a327 3
     AssertNotExclLocked(&entry->lock);

     return ret;
d335 2
a336 2
Result
cm_setattr (VenusFid fid, AFSStoreStatus *attr, CredCacheEntry* ce)
d338 1
a338 3
     FCacheEntry *entry;
     Result ret;
     int error;
d340 3
a342 6
     error = fcache_get (&entry, fid, ce);
     if (error) {
	 ret.res   = -1;
	 ret.error = error;
	 return ret;
     }
a343 7
     error = fcache_verify_attr (entry, NULL, NULL, ce);
     if (error) {
	 fcache_release(entry);
	 ret.res   = -1;
	 ret.error = error;
	 return ret;
     }
d346 1
a346 2
	  ret.res   = write_attr (entry, attr, ce);
	  ret.error = ret.res;
d349 6
a354 1
		   fid.Cell, fid.fid.Volume, fid.fid.Vnode, fid.fid.Unique);
a355 5
     } else {
	  ret.res   = -1;
	  ret.error = EACCES;
     }
     fcache_release(entry);
d357 1
a357 1
     return ret;
d364 3
a366 2
Result
cm_ftruncate (VenusFid fid, off_t size, CredCacheEntry* ce)
d368 1
a368 10
     FCacheEntry *entry;
     Result ret;
     int error;

     error = fcache_get (&entry, fid, ce);
     if (error) {
	 ret.res   = -1;
	 ret.error = error;
	 return ret;
     }
d371 2
a372 6
     if (error) {
	 fcache_release(entry);
	 ret.res   = -1;
	 ret.error = error;
	 return ret;
     }
d376 2
a377 6
	 if (error) {
	     fcache_release (entry);
	     ret.res   = -1;
	     ret.error = error;
	     return ret;
	 }
d381 1
a381 2
	  ret.res   = truncate_file (entry, size, ce);
	  ret.error = ret.res;
d384 8
a391 7
		   fid.Cell, fid.fid.Volume, fid.fid.Vnode, fid.fid.Unique,
		   (unsigned long)size);
     } else {
	  ret.res   = -1;
	  ret.error = EACCES;
     }
     fcache_release(entry);
d393 1
a393 1
     return ret;
d400 2
a401 2
Result
cm_access (VenusFid fid, int mode, CredCacheEntry* ce)
d403 1
a403 10
     FCacheEntry *entry;
     Result ret;
     int error;

     error = fcache_get (&entry, fid, ce);
     if (error) {
	 ret.res   = -1;
	 ret.error = error;
	 return ret;
     }
d406 2
a407 6
     if (error) {
	 fcache_release(entry);
	 ret.res   = -1;
	 ret.error = error;
	 return ret;
     }
d409 4
a412 7
     if (checkright (entry, AWRITE, ce)) {
	  ret.res   = 0;		/**/
	  ret.error = 0;
     } else {
	  ret.res   = -1;
	  ret.error = EACCES;
     }
d415 4
a418 1
	      fid.Cell, fid.fid.Volume, fid.fid.Vnode, fid.fid.Unique);
a419 1
     fcache_release(entry);
d421 1
a421 1
     return ret;
d472 2
a473 2
Result
cm_lookup (VenusFid *dir_fid,
d480 5
a484 3
     FCacheEntry *entry;
     Result ret;
     int error;
d487 10
a496 5
	 if (expand_sys (tmp_name, sizeof(tmp_name), name,
			 "@@sys", arlasysname) >= sizeof(tmp_name)) {
	     ret.res   = -1;
	     ret.error = ENAMETOOLONG;
	     return ret;
d498 2
a499 2
	 name = tmp_name;
     }
d501 2
a502 14
     error = fcache_get_data(&entry, dir_fid, ce);
     if (error) {
	 ret.res   = -1;
	 ret.error = error;
	 return ret;
     }

     error = adir_lookup (entry, name, res);
     if (error) {
	 fcache_release(entry);
	 ret.res   = -1;
	 ret.error = error;
	 return ret;
     }
d504 2
a505 3
     ret.res    = 0;
     ret.error  = 0; 
     ret.tokens = 0;
d517 2
a518 4
	 error = fcache_verify_attr (entry, NULL, NULL, *ce);
	 if (error) {
	     ret.res   = -1;
	     ret.error = error;
a519 1
	 }
d521 3
a523 3
	 *res = *dir_fid;
	 ret.tokens = entry->tokens;
     } else if ((strcmp("..", name) == 0 && VenusFid_cmp(dir_fid, res) == 0)) {
d525 2
a526 4
	 error = fcache_verify_attr (entry, NULL, NULL, *ce);
	 if (error) {
	     ret.res   = -1;
	     ret.error = error;
a527 1
	 }
d529 1
a529 2
	 *res = entry->volume->parent_fid; /* entry->parent */
	 ret.tokens = entry->tokens;
d531 2
a532 4
	 error = followmountpoint (res, dir_fid, entry, ce);
	 if (error) {
	     ret.res   = -1;
	     ret.error = error;
a533 1
	 }
a535 2
     fcache_release(entry);

d537 4
a540 4
		    dir_fid->Cell,
		    dir_fid->fid.Volume,
		    dir_fid->fid.Vnode,
		    dir_fid->fid.Unique,
d544 1
a544 1
     return ret;
d551 2
a552 2
Result
cm_create (VenusFid *dir_fid, const char *name, AFSStoreStatus *store_attr,
d556 1
a556 3
     FCacheEntry *dire;
     Result ret;
     int error;
d558 11
a568 6
     error = fcache_get_data (&dire, dir_fid, ce);
     if (error) {
	 ret.res   = -1;
	 ret.error = error;
	 return ret;
     }
a569 20
     if (checkright (dire, AINSERT, *ce)) {
	  error = create_file (dire, name, store_attr,
			       res, fetch_attr, *ce);
	  if (error) {
	      ret.res   = -1;
	      ret.error = error;
	  } else {
	      error = adir_creat (dire, name, res->fid);
	      if (error) {
		  ret.res   = -1;
		  ret.error = error;
	      } else {
		  ret.res   = 0;
		  ret.error = 0;
	      }
	  }
     } else {
	  ret.res   = -1;
	  ret.error = EACCES;
     }
d571 5
a575 3
	      dir_fid->Cell,
	      dir_fid->fid.Volume, dir_fid->fid.Vnode, dir_fid->fid.Unique,
	      name);
a576 1
     fcache_release(dire);
d578 1
a578 1
     return ret;
d585 2
a586 2
Result
cm_mkdir (VenusFid *dir_fid, const char *name,
d591 1
a591 3
     FCacheEntry *dire;
     Result ret;
     int error;
d593 12
a604 27
     error = fcache_get_data (&dire, dir_fid, ce);
     if (error) {
	 ret.res   = -1;
	 ret.error = error;
	 return ret;
     }

     if (checkright (dire, AINSERT, *ce)) {
	  error = create_directory (dire, name, store_attr,
				    res, fetch_attr, *ce);
	  if (error) {
	      ret.res   = -1;
	      ret.error = error;
	  } else {
	      error = adir_creat (dire, name, res->fid);
	      if (error) {
		  ret.res   = -1;
		  ret.error = error;
	      } else {
		  ret.res   = 0;
		  ret.error = 0;
	      }
	  }
     } else {
	  ret.res   = -1;
	  ret.error = EACCES;
     }
d607 4
a610 4
		    dir_fid->Cell,
		    dir_fid->fid.Volume,
		    dir_fid->fid.Vnode,
		    dir_fid->fid.Unique,
a612 1
     ReleaseWriteLock (&dire->lock);
d614 1
a614 1
     return ret;
d621 2
a622 2
Result
cm_symlink (VenusFid *dir_fid,
d629 2
a630 3
     FCacheEntry *dire, *symlink_entry;
     Result ret;
     int error;
d632 3
a634 6
     error = fcache_get_data (&dire, dir_fid, ce);
     if (error) {
	 ret.res   = -1;
	 ret.error = error;
	 return ret;
     }
d636 2
a637 3
     if (!checkright (dire, AINSERT, *ce)) {
	 ret.res   = -1;
	 ret.error = EACCES;
d650 1
a650 1
     error = create_symlink (dire, name, store_attr,
d653 1
a653 3
     if (error) {
	 ret.res   = -1;
	 ret.error = error;
a654 1
     }
d656 2
a657 4
     error = adir_creat (dire, name, res->fid);
     if (error) {
	 ret.res   = -1;
	 ret.error = error;
a658 1
     }
d660 2
a661 4
     error = followmountpoint(res, dir_fid, NULL, ce);
     if (error) {
	 ret.res   = -1;
	 ret.error = error;
a662 1
     }
d669 1
a669 1
     if (VenusFid_cmp (res, dir_fid) != 0) {
d672 1
a672 3
	 if (error) {
	     ret.res   = -1;
	     ret.error = error;
a673 1
	 }
d675 1
a675 1
	 error = fcache_verify_attr (symlink_entry, NULL, NULL, *ce);
a677 2
	     ret.res   = -1;
	     ret.error = error;
d688 2
a689 2
	 *fetch_attr = dire->status;
	 *realfid = *fcache_realfid (dire);
a691 3
     ret.res   = 0;
     ret.error = 0;
     
d693 4
a696 4
		    dir_fid->Cell,
		    dir_fid->fid.Volume,
		    dir_fid->fid.Vnode,
		    dir_fid->fid.Unique,
a700 1
     fcache_release(dire);
d702 1
a702 1
     return ret;
d709 2
a710 2
Result
cm_link (VenusFid *dir_fid,
d716 2
a717 3
     FCacheEntry *dire, *file;
     Result ret;
     int error;
d719 3
a721 6
     error = fcache_get_data (&dire, dir_fid, ce);
     if (error) {
	 ret.res   = -1;
	 ret.error = error;
	 return ret;
     }
d724 2
a725 6
     if (error) {
	 fcache_release(dire);
	 ret.res   = -1;
	 ret.error = error;
	 return ret;
     }
d727 2
a728 4
     error = fcache_verify_attr (file, NULL, NULL, *ce);
     if (error) {
	 ret.res   = -1;
	 ret.error = error;
a729 1
     }
d731 10
a740 20
     if (checkright (dire, AINSERT, *ce)) {
	  error = create_link (dire, name, file, *ce);
	  if (error) {
	      ret.res   = -1;
	      ret.error = error;
	  } else {
	      error = adir_creat (dire, name, existing_fid.fid);
	      if (error) {
		  ret.res   = -1;
		  ret.error = error;
	      } else {
		  *existing_status = file->status;
		  ret.res   = 0;
		  ret.error = 0;
	      }
	  }
     } else {
	  ret.res   = -1;
	  ret.error = EACCES;
     }
d742 9
a750 7
	      dir_fid->Cell,
	      dir_fid->fid.Volume, dir_fid->fid.Vnode, dir_fid->fid.Unique,
	      existing_fid.Cell,
	      existing_fid.fid.Volume,
	      existing_fid.fid.Vnode,
	      existing_fid.fid.Unique,
	      name);
a752 1
     fcache_release(dire);
d755 1
a755 1
     return ret;
d762 2
a763 2
static Result
sub_remove (VenusFid *dir_fid, const char *name, CredCacheEntry **ce,
d769 1
a769 3
     FCacheEntry *dire;
     Result ret;
     int error;
d771 11
a781 26
     error = fcache_get_data (&dire, dir_fid, ce);
     if (error) {
	 ret.res   = -1;
	 ret.error = error;
	 return ret;
     }

     if (checkright (dire, ADELETE, *ce)) {
	  error = (*func) (dire, name, *ce);
	  if (error) {
	      ret.res   = -1;
	      ret.error = error;
	  } else {
	      error = adir_remove (dire, name);
	      if (error) {
		  ret.res   = -1;
		  ret.error = error;
	      } else {
		  ret.res   = 0;
		  ret.error = 0;
	      }
	  }
     } else {
	  ret.res   = -1;
	  ret.error = EACCES;
     }
d784 4
a787 4
		    dir_fid->Cell,
		    dir_fid->fid.Volume,
		    dir_fid->fid.Vnode,
		    dir_fid->fid.Unique,
a789 1
     fcache_release(dire);
d791 1
a791 1
     return ret;
d795 1
a795 1
 * Remove the file named `name' in the directory `dir_fid'.
d798 2
a799 2
Result
cm_remove(VenusFid *dir_fid,
d802 1
a802 1
    return sub_remove (dir_fid, name, ce, "remove", remove_file);
d806 1
a806 1
 * Remove the directory named `name' in the directory `dir_fid'.
d809 2
a810 2
Result
cm_rmdir(VenusFid *dir_fid,
d813 1
a813 1
    return sub_remove (dir_fid, name, ce, "rmdir", remove_directory);
d826 1
a826 1
		     CredCacheEntry *ce)
d830 1
a830 1
    error = fcache_verify_attr (child_entry, parent_entry, NULL, ce);
d842 1
a842 1
	error = fcache_verify_data (child_entry, ce); /* XXX - check fake_mp */
d868 3
a870 3
Result
cm_rename(VenusFid *old_parent_fid, const char *old_name,
	  VenusFid *new_parent_fid, const char *new_name,
d875 3
a877 6
    FCacheEntry *old_dir;
    FCacheEntry *new_dir;
    Result ret;
    int error;
    int diff_dir;

d882 14
a895 5
    error = fcache_get_data (&old_dir, old_parent_fid, ce);
    if (error) {
	ret.res   = -1;
	ret.error = error;
	return ret;
d897 4
d902 32
a933 3
    diff_dir = VenusFid_cmp (old_parent_fid, new_parent_fid);

     /* new parent dir */
d935 8
a942 7
    if (diff_dir) {
	error = fcache_get_data (&new_dir, new_parent_fid, ce);
	if (error) {
	    fcache_release(old_dir);
	    ret.res   = -1;
	    ret.error = error;
	    return ret;
d944 1
a944 2
    } else {
	new_dir = old_dir;
d946 31
d978 36
a1013 2
    if (checkright (old_dir, ADELETE, *ce)
	&& checkright (new_dir, AINSERT, *ce)) {
d1015 3
a1017 13
	error = rename_file (old_dir, old_name, new_dir, new_name, *ce);
	if (error) {
	    ret.res   = -1;
	    ret.error = error;
	} else {
	    VenusFid new_fid, old_fid;
	    
	    /*
	     * Lookup the old name (to get the fid of the new name)
	     */
	    
	    error = adir_lookup (old_dir, old_name, &new_fid);
	    
d1019 3
a1021 3
		ret.res   = -1;
		ret.error = error;
		goto out;
d1024 42
a1065 1
	    *child_fid = new_fid;
d1067 15
a1081 20
	    if (diff_dir) {
		FCacheEntry *child_entry;
		
		error = fcache_get (&child_entry, *child_fid, *ce);
		if (error) {
		    ret.res   = -1;
		    ret.error = error;
		    goto out;
		}
		
		child_entry->parent = *new_parent_fid;

		error = potential_update_dir (child_entry, new_parent_fid,
					      new_dir, update_child, *ce);
		fcache_release (child_entry);
		if (error) {
		    ret.res   = -1;
		    ret.error = error;
		    goto out;
		}
d1083 3
a1085 4
	    
	    /*
	     * Lookup the new name, if it exists we need to clear it out.
	     * XXX Should we check the lnkcount and clear it from fcache ?
d1087 3
a1089 19
	    
	    error = adir_lookup (new_dir, new_name, &old_fid);
	    if (error == 0)
		adir_remove (new_dir, new_name);
	    
	    /*
	     * Now do the rename, ie create the new name and remove
	     * the old name.
	     */
	    
	    error = adir_creat (new_dir, new_name,  new_fid.fid)
		|| adir_remove (old_dir, old_name);
	    
	    if (error) {
		ret.res   = -1;
		ret.error = error;
	    } else {
		ret.res   = 0;
		ret.error = 0;
d1091 5
d1097 8
a1104 22
    } else {
	ret.res   = -1;
	ret.error = EACCES;
    }
    
    log_operation ("rename (%ld,%lu,%lu,%lu) (%ld,%lu,%lu,%lu) %s %s\n",
		   old_parent_fid->Cell,
		   old_parent_fid->fid.Volume,
		   old_parent_fid->fid.Vnode,
		   old_parent_fid->fid.Unique,
		   new_parent_fid->Cell,
		   new_parent_fid->fid.Volume,
		   new_parent_fid->fid.Vnode,
		   new_parent_fid->fid.Unique,
		   old_name, new_name);
    
 out:
    fcache_release(old_dir);
    if (diff_dir)
	fcache_release(new_dir);
    cm_check_consistency();
    return ret;
@


1.3
log
@New Arla userland from Arla between 0.34.2 and current in arla cvs.
Too many new features and fixes to mention here.
@
text
@d17 1
a17 6
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by the Kungliga Tekniska
 *      Högskolan and its contributors.
 * 
 * 4. Neither the name of the Institute nor the names of its contributors
d39 1
a39 1
RCSID("$Id: inter.c,v 1.99 2000/07/12 16:54:05 assar Exp $") ;
d43 1
a43 1
Bool usedbytes_consistencyp = FALSE;
d126 1
a126 1
    if(connected_mode == CONNECTED && usedbytes_consistencyp == FALSE)
d148 1
a148 1
cm_turn_on_usedbytes_consistency(void)
d150 1
a150 1
    usedbytes_consistencyp = TRUE;
d159 1
a159 1
cm_check_usedbytes_consistency (void)
d167 1
a167 1
    if (usedbytes_consistencyp == FALSE)
d174 1
a174 1
	    log_operation ("usedbytes consistency not guaranteed "
d181 1
a181 1
	log_operation ("usedbytes consistency ok, rotating logs\n");
d208 1
a208 1
	 xfs_cache_handle *cache_handle,
d244 3
d266 1
a266 1
     cm_check_usedbytes_consistency();
d312 1
a312 1
    cm_check_usedbytes_consistency();
d343 1
a343 1
     assert (CheckLock (&entry->lock) == -1);
d356 1
a356 1
		     entry->status.FileType == TYPE_FILE ? AREAD : ALIST,
d376 1
a376 1
	 ret.tokens &= ~XFS_DATA_MASK;
d380 1
a380 1
     cm_check_usedbytes_consistency();
d382 1
a382 1
     assert (CheckLock (&entry->lock) != -1);
d426 1
a426 1
     cm_check_usedbytes_consistency();
d478 1
a478 1
     cm_check_usedbytes_consistency();
d520 1
a520 1
     cm_check_usedbytes_consistency();
d594 1
a594 1
     error = adir_lookup (dir_fid, name, res, &entry, ce);
a599 1
     fcache_release (entry);
d601 3
a603 2
     if (follow_mount_point &&
	 ((error = followmountpoint (res, dir_fid, ce)) != 0)) {
d606 1
a606 4
     } else {
	 ret.res    = 0;
	 ret.tokens = 0;
	 ret.error  = 0;
d609 11
a619 5
     /* Assume that this means a bad .. */
     if ( strcmp("..", name) == 0 
	  && VenusFid_cmp(dir_fid, res) == 0) {
	  FCacheEntry *e;
	  int error;
d621 12
a632 6
	  error = fcache_get (&e, *dir_fid, *ce);
	  if (error) {
	      ret.res   = -1;
	      ret.error = error;
	      return ret;
	  }
d634 6
a639 7
	  error = fcache_verify_attr (e, NULL, NULL, *ce);
	  if (error) {
	      fcache_release(e);
	      ret.res   = -1;
	      ret.error = error;
	      return ret;
	  }
d641 9
a649 5
	  *res = e->volume->parent_fid; /* e->parent */
	  ret.res    = 0;
	  ret.error  = 0;
	  ret.tokens = e->tokens;
	  fcache_release(e);
d651 3
a653 1
     
d659 1
a659 1
	      name);
d661 1
a661 1
     cm_check_usedbytes_consistency();
d711 1
a711 1
     cm_check_usedbytes_consistency();
d765 1
a765 1
     cm_check_usedbytes_consistency();
d823 1
a823 1
     error = followmountpoint(res, dir_fid, ce);
d830 26
a855 6
     error = fcache_get (&symlink_entry, *res, *ce);
     if (error) {
	 ret.res   = -1;
	 ret.error = error;
	 goto out;
     }
a856 2
     error = fcache_verify_attr (symlink_entry, NULL, NULL, *ce);
     if (error) {
d858 3
a860 3
	 ret.res   = -1;
	 ret.error = error;
	 goto out;
a861 2

     symlink_entry->flags.kernelp = TRUE;
a862 3
     *fetch_attr = symlink_entry->status;
     *realfid = *fcache_realfid (symlink_entry);
     fcache_release (symlink_entry);
d865 1
a865 1

d873 2
a874 2

out:
d876 1
a876 1
     cm_check_usedbytes_consistency();
d949 1
a949 1
     cm_check_usedbytes_consistency();
d1003 1
a1003 1
     cm_check_usedbytes_consistency();
d1035 1
a1035 1
potential_update_dir(const VenusFid *child_fid,
d1037 1
a1040 1
    FCacheEntry *fe;
d1043 2
a1044 2
    error = fcache_get (&fe, *child_fid, ce);
    if (error)
a1046 6
    error = fcache_verify_attr (fe, NULL, NULL, ce);
    if (error) {
	fcache_release (fe);
	return error;
    }

d1051 1
a1051 1
    if (fe->status.FileType == TYPE_DIR) {
d1055 2
a1056 3
	error = fcache_verify_data (fe, ce); /* XXX - check fake_mp */
	if (error) {
	    fcache_release (fe);
d1058 2
a1059 2
	}
	error = fcache_get_fbuf (fe, &fd, &the_fbuf, O_RDWR,
d1061 1
a1061 2
	if (error) {
	    fcache_release (fe);
d1063 1
a1063 1
	}
d1067 1
a1067 2
	if (error) {
	    fcache_release (fe);
d1069 1
a1069 1
	}
a1071 1
    fcache_release (fe);
d1123 1
a1123 1

d1130 7
a1136 9

	      /*
	       * Lookup the old name (to get the fid of the new name)
	       */

	    error = adir_lookup_fcacheentry (old_dir,
					     *old_parent_fid,
					     old_name, &new_fid, *ce);

d1142 1
a1142 1

d1144 12
d1157 3
a1159 3
	    if (diff_dir) {
		error = potential_update_dir (child_fid, new_parent_fid,
					      update_child, *ce);
d1166 48
a1213 50

	      /*
	       * Lookup the new name, if it exists we need to clear it out.
	       * XXX Should we check the lnkcount and clear it from fcache ?
	       */

	      error = adir_lookup_fcacheentry (new_dir,
					       *new_parent_fid,
					       new_name, &old_fid, *ce);
	      if (error == 0)
		  adir_remove (new_dir, new_name);

	      /*
	       * Now do the rename, ie create the new name and remove
	       * the old name.
	       */

	      error = adir_creat (new_dir, new_name,  new_fid.fid)
		  || adir_remove (old_dir, old_name);

	      if (error) {
		  ret.res   = -1;
		  ret.error = error;
	      } else {
		  ret.res   = 0;
		  ret.error = 0;
	      }
	  }
     } else {
	  ret.res   = -1;
	  ret.error = EACCES;
     }

     log_operation ("rename (%ld,%lu,%lu,%lu) (%ld,%lu,%lu,%lu) %s %s\n",
	      old_parent_fid->Cell,
	      old_parent_fid->fid.Volume,
	      old_parent_fid->fid.Vnode,
	      old_parent_fid->fid.Unique,
	      new_parent_fid->Cell,
	      new_parent_fid->fid.Volume,
	      new_parent_fid->fid.Vnode,
	      new_parent_fid->fid.Unique,
	      old_name, new_name);

out:
     fcache_release(old_dir);
     if (diff_dir)
	 fcache_release(new_dir);
     cm_check_usedbytes_consistency();
     return ret;
@


1.2
log
@upgrade Arla to fresher code. Too many new features and bugfixes.
@
text
@a0 1
/*	$OpenBSD$	*/
d2 1
a2 1
 * Copyright (c) 1995, 1996, 1997, 1998, 1999 Kungliga Tekniska Högskolan
d44 1
a44 1
RCSID("$KTH: inter.c,v 1.71 1999/02/05 02:43:33 assar Exp $") ;
d48 2
d56 1
a56 1
u_long
d121 4
d131 1
a131 1
    if(connected_mode == CONNECTED)
d147 48
d210 2
a211 2
cm_open (VenusFid fid,
	 CredCacheEntry* ce,
d222 1
a222 1
     error = fcache_get (&entry, fid, ce);
a228 10
     assert (CheckLock (&entry->lock) == -1);

     error = fcache_get_data (entry, ce);
     if(error) {
	 fcache_release(entry);
	 ret.res = -1;
	 ret.error = error;
	 return ret;
     }

d248 1
a248 1
     if (checkright (entry, mask, ce)) {
d259 2
a260 2
			 fid.Cell,
			 fid.fid.Volume, fid.fid.Vnode, fid.fid.Unique,
d268 2
d293 3
a309 1

d313 3
d327 1
a327 1
	    CredCacheEntry* ce,
d334 4
d344 2
d347 1
a347 1
     error = fcache_get_attr (entry, ce);
d355 2
d360 10
a369 11
	  *attr = entry->status;
	  ret.res   = 0;
	  ret.error = 0;
	  entry->flags.attrusedp = TRUE;
	  entry->flags.kernelp   = TRUE;
	  if (ae != NULL)
	      *ae = entry->acccache;

	  log_operation ("getattr (%ld,%lu,%lu,%lu)\n",
		   fid.Cell, fid.fid.Volume, fid.fid.Vnode, fid.fid.Unique);

d371 3
a373 2
	  ret.res   = -1;
	  ret.error = EACCES;
d375 4
a378 1
     *realfid = entry->realfid;
d380 6
a385 1
     ret.tokens = entry->tokens;
d408 1
a408 1
     error = fcache_get_attr (entry, ce);
d428 1
d450 1
a450 1
     error = fcache_get_attr (entry, ce);
d458 10
d480 1
d502 1
a502 1
     error = fcache_get_attr (entry, ce);
d522 1
d571 1
a571 1
 * about mount points.
d575 1
a575 1
cm_lookup (VenusFid dir_fid,
d578 2
a579 1
	   CredCacheEntry** ce)
d582 1
d596 1
a596 1
     error = adir_lookup (dir_fid, name, res, *ce);
d598 3
a600 3
	  ret.res   = -1;
	  ret.error = error;
	  return ret;
d602 6
a607 4
     error = followmountpoint (res, &dir_fid, ce);
     if (error) {
	  ret.res   = -1;
	  ret.error = error;
d609 3
a611 3
	  ret.res    = 0;
	  ret.tokens = 0;
	  ret.error  = 0;
d615 2
a616 5
     if (   strcmp("..", name) == 0 
	 && dir_fid.Cell == res->Cell 
	 && dir_fid.fid.Volume == res->fid.Volume
	 && dir_fid.fid.Vnode == res->fid.Vnode 
	 && dir_fid.fid.Unique == res->fid.Unique) {
d620 1
a620 1
	  error = fcache_get (&e, dir_fid, *ce);
d627 1
a627 1
	  error = fcache_get_attr (e, *ce);
d635 1
a635 6
	  assert (e->flags.mountp);

#if 0
	  *res = e->mp_traversal->parent;
#endif
	  *res = e->parent;
d643 4
a646 2
	      dir_fid.Cell,
	      dir_fid.fid.Volume, dir_fid.fid.Vnode, dir_fid.fid.Unique,
d649 1
d658 1
a658 1
cm_create (VenusFid dir_fid, const char *name, AFSStoreStatus *store_attr,
d660 1
a660 1
	   CredCacheEntry* ce)
d666 1
a666 1
     error = fcache_get (&dire, dir_fid, ce);
d673 1
a673 8
     error = fcache_get_data (dire, ce);
     if (error) {
	 ret.res   = -1;
	 ret.error = error;
	 goto out;
     }

     if (checkright (dire, AINSERT, ce)) {
d675 1
a675 1
			       res, fetch_attr, ce);
a692 1
out:
d694 2
a695 2
	      dir_fid.Cell,
	      dir_fid.fid.Volume, dir_fid.fid.Vnode, dir_fid.fid.Unique,
d699 1
d708 1
a708 1
cm_mkdir (VenusFid dir_fid, const char *name,
d711 1
a711 1
	  CredCacheEntry* ce)
d717 1
a717 1
     error = fcache_get (&dire, dir_fid, ce);
d724 1
a724 8
     error = fcache_get_data (dire, ce);
     if (error) {
	 ret.res   = -1;
	 ret.error = error;
	 goto out;
     }

     if (checkright (dire, AINSERT, ce)) {
d726 1
a726 1
				    res, fetch_attr, ce);
d746 4
a749 2
	      dir_fid.Cell,
	      dir_fid.fid.Volume, dir_fid.fid.Vnode, dir_fid.fid.Unique,
a751 1
out:
d753 1
d762 1
a762 1
cm_symlink (VenusFid dir_fid,
d764 2
a765 1
	    VenusFid *res, AFSFetchStatus *fetch_attr,
d767 1
a767 1
	    CredCacheEntry* ce)
d773 1
a773 1
     error = fcache_get (&dire, dir_fid, ce);
d780 1
a780 8
     error = fcache_get_data (dire, ce);
     if (error) {
	 ret.res   = -1;
	 ret.error = error;
	 goto out;
     }

     if (!checkright (dire, AINSERT, ce)) {
d786 9
d797 1
a797 1
			     contents, ce);
d811 1
a811 1
     error = followmountpoint(res, &dir_fid, &ce);
d818 1
a818 1
     error = fcache_get (&symlink_entry, *res, ce);
d825 1
a825 1
     error = fcache_get_attr (symlink_entry, ce);
d833 2
d836 1
d842 4
a845 2
		    dir_fid.Cell,
		    dir_fid.fid.Volume, dir_fid.fid.Vnode, dir_fid.fid.Unique,
d851 1
d860 1
a860 1
cm_link (VenusFid dir_fid,
d864 1
a864 1
	 CredCacheEntry* ce)
d870 1
a870 8
     error = fcache_get (&dire, dir_fid, ce);
     if (error) {
	 ret.res   = -1;
	 ret.error = error;
	 return ret;
     }

     error = fcache_get_data (dire, ce);
a871 1
	 fcache_release(dire);
d877 1
a877 1
     error = fcache_get (&file, existing_fid, ce);
d885 1
a885 1
     error = fcache_get_attr (file, ce);
d892 2
a893 2
     if (checkright (dire, AINSERT, ce)) {
	  error = create_link (dire, name, file, ce);
d913 2
a914 2
	      dir_fid.Cell,
	      dir_fid.fid.Volume, dir_fid.fid.Vnode, dir_fid.fid.Unique,
d924 1
d929 1
a929 1
 * Remove the file named `name' in the directory `dir_fid'.
d932 6
a937 3
Result
cm_remove(VenusFid dir_fid,
	  const char *name, CredCacheEntry* ce)
d943 1
a943 1
     error = fcache_get (&dire, dir_fid, ce);
d950 2
a951 9
     error = fcache_get_data (dire, ce);
     if (error) {
	 ret.res   = -1;
	 ret.error = error;
	 goto out;
     }

     if (checkright (dire, ADELETE, ce)) {
	  error = remove_file (dire, name, ce);
d969 7
a975 4
     log_operation ("remove (%ld,%lu,%lu,%lu) %s\n",
	      dir_fid.Cell,
	      dir_fid.fid.Volume, dir_fid.fid.Vnode, dir_fid.fid.Unique,
	      name);
a976 1
out:
d978 1
d983 11
d998 2
a999 2
cm_rmdir(VenusFid dir_fid,
	 const char *name, CredCacheEntry* ce)
d1001 7
a1007 3
     FCacheEntry *dire;
     Result ret;
     int error;
d1009 8
a1016 6
     error = fcache_get (&dire, dir_fid, ce);
     if (error) {
	 ret.res   = -1;
	 ret.error = error;
	 return ret;
     }
d1018 3
a1020 6
     error = fcache_get_data (dire, ce);
     if (error) {
	 ret.res   = -1;
	 ret.error = error;
	 goto out;
     }
d1022 5
a1026 19
     if (checkright (dire, ADELETE, ce)) {
	  error = remove_directory (dire, name, ce);
	  if (error) {
	      ret.res   = -1;
	      ret.error = error;
	  } else {
	      error = adir_remove (dire, name);
	      if (error) {
		  ret.res   = -1;
		  ret.error = error;
	      } else {
		  ret.res   = 0;
		  ret.error = 0;
	      }
	  }
     } else {
	  ret.res   = -1;
	  ret.error = EACCES;
     }
d1028 7
a1034 4
     log_operation ("rmdir (%ld,%lu,%lu,%lu) %s\n",
	      dir_fid.Cell,
	      dir_fid.fid.Volume, dir_fid.fid.Vnode, dir_fid.fid.Unique,
	      name);
d1036 22
a1057 3
out:
     fcache_release(dire);
     return ret;
d1062 2
d1067 5
a1071 3
cm_rename(VenusFid old_parent_fid, const char *old_name,
	  VenusFid new_parent_fid, const char *new_name,
	  CredCacheEntry* ce)
d1073 7
a1079 4
     FCacheEntry *old_dir;
     FCacheEntry *new_dir;
     Result ret;
     int error;
d1081 1
a1081 1
     /* old parent dir */
d1083 6
a1088 6
     error = fcache_get (&old_dir, old_parent_fid, ce);
     if (error) {
	 ret.res   = -1;
	 ret.error = error;
	 return ret;
     }
d1090 1
a1090 7
     error = fcache_get_data (old_dir, ce);
     if (error) {
	 fcache_release(old_dir);
	 ret.res   = -1;
	 ret.error = error;
	 return ret;
     }
d1094 11
a1104 2
     if (old_parent_fid.fid.Vnode != new_parent_fid.fid.Vnode
	 || old_parent_fid.fid.Unique != new_parent_fid.fid.Unique) {
d1106 2
a1107 7
	 error = fcache_get (&new_dir, new_parent_fid, ce);
	 if (error) {
	     fcache_release(old_dir);
	     ret.res   = -1;
	     ret.error = error;
	     return ret;
	 }
d1109 6
a1114 22
	 error = fcache_get_data (new_dir, ce);
	 if (error) {
	     ret.res   = -1;
	     ret.error = error;
	     goto out;
	 }

     } else {
	 new_dir = old_dir;
     }

     if (checkright (old_dir, ADELETE, ce)
	 && checkright (new_dir, AINSERT, ce)) {

	 error = rename_file (old_dir, old_name,
			      new_dir, new_name,
			      ce);
	  if (error) {
	      ret.res   = -1;
	      ret.error = error;
	  } else {
	      VenusFid new_fid, old_fid;
d1120 21
a1140 7
	      error = adir_lookup_fcacheentry (old_dir, old_name, &new_fid, ce);

	      if (error) {
		  ret.res   = -1;
		  ret.error = error;
		  goto out;
	      }
d1147 3
a1149 1
	      error = adir_lookup_fcacheentry (new_dir, new_name, &old_fid, ce);
d1175 8
a1182 8
	      old_parent_fid.Cell,
	      old_parent_fid.fid.Volume,
	      old_parent_fid.fid.Vnode,
	      old_parent_fid.fid.Unique,
	      new_parent_fid.Cell,
	      new_parent_fid.fid.Volume,
	      new_parent_fid.fid.Vnode,
	      new_parent_fid.fid.Unique,
d1187 1
a1187 2
     if (old_parent_fid.fid.Vnode != new_parent_fid.fid.Vnode
	 || old_parent_fid.fid.Unique != new_parent_fid.fid.Unique)
d1189 1
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
 * Copyright (c) 1995, 1996, 1997, 1998 Kungliga Tekniska Högskolan
d45 1
a45 1
RCSID("$KTH: inter.c,v 1.55 1998/07/29 21:31:59 assar Exp $") ;
d157 6
a162 1
cm_open (VenusFid fid, CredCacheEntry* ce, u_int tokens)
d180 1
a180 1
	 ReleaseWriteLock (&entry->lock);
a205 1
	  ret.res = entry->inode;
d208 2
a209 2

	  ret.res = entry->inode;
d211 3
d216 3
a218 2
		   fid.Cell, fid.fid.Volume, fid.fid.Vnode, fid.fid.Unique,
		   mask);
d223 1
a223 1
     ReleaseWriteLock (&entry->lock);
d234 1
a234 1
cm_close (VenusFid fid, int flag, CredCacheEntry* ce)
d242 1
a242 1
	ret.res = -1;
d248 1
a248 1
	error = write_data (entry, ce);
d251 1
a251 1
	    ReleaseWriteLock (&entry->lock);
d253 2
a254 2
	    ret.res = -1 ;
	    ret.error = EPERM ;
d263 3
a265 2
    ReleaseWriteLock (&entry->lock);
    ret.res = 0;
d286 1
a286 1
	 ret.res = -1;
d293 2
a294 2
	 ReleaseWriteLock (&entry->lock);
	 ret.res = -1;
d303 2
a304 1
	  ret.res = 0;
d306 1
a306 2
	  entry->flags.kernelp = TRUE;
	  entry->tokens |= XFS_ATTR_R;
d317 2
a318 6
     if(entry->flags.mountp)
	 *realfid = entry->realfid;
     else
	 *realfid = fid;

     ReleaseWriteLock (&entry->lock);
d337 1
a337 1
	 ret.res = -1;
d344 2
a345 2
	 ReleaseWriteLock (&entry->lock);
	 ret.res = -1;
d351 2
a352 3
	  ret.res = write_attr (entry, attr, ce);
	  if (ret.res != 0)
	      ret.error = ret.res;
d358 1
a358 1
	  ret.res = -1;
d361 1
a361 1
     ReleaseWriteLock (&entry->lock);
d378 1
a378 1
	 ret.res = -1;
d385 2
a386 2
	 ReleaseWriteLock (&entry->lock);
	 ret.res = -1;
d392 2
a393 1
	  ret.res = truncate_file (entry, size, ce);
d399 1
a399 1
	  ret.res = -1;
d402 1
a402 1
     ReleaseWriteLock (&entry->lock);
d419 1
a419 1
	 ret.res = -1;
d426 2
a427 2
	 ReleaseWriteLock (&entry->lock);
	 ret.res = -1;
d433 2
a434 1
	  ret.res = 0;		/**/
d436 1
a436 1
	  ret.res = -1;
d443 1
a443 1
     ReleaseWriteLock (&entry->lock);
d528 1
d542 1
a542 1
	      ret.res = -1;
d549 2
a550 2
	      ReleaseWriteLock (&e->lock);
	      ret.res = -1;
d557 3
d561 2
a562 1
	  ret.res = 0;
d564 1
a564 1
	  ReleaseWriteLock (&e->lock);
d590 1
a590 1
	 ret.res = -1;
d597 1
a597 1
	 ret.res = -1;
d606 1
a606 1
	      ret.res = -1;
d611 1
a611 1
		  ret.res = -1;
d614 2
a615 1
		  ret.res = 0;
d619 1
a619 1
	  ret.res = -1;
d628 1
a628 1
     ReleaseWriteLock (&dire->lock);
d648 1
a648 1
	 ret.res = -1;
d655 1
a655 1
	 ret.res = -1;
d664 1
a664 1
	      ret.res = -1;
d669 1
a669 1
		  ret.res = -1;
d672 2
a673 1
		  ret.res = 0;
d677 1
a677 1
	  ret.res = -1;
d687 1
a687 1
     ReleaseSharedLock (&dire->lock);
d702 1
a702 1
     FCacheEntry *dire;
d708 1
a708 1
	 ret.res = -1;
d715 37
a751 1
	 ret.res = -1;
d756 6
a761 19
     if (checkright (dire, AINSERT, ce)) {
	  error = create_symlink (dire, name, store_attr,
				  res, fetch_attr,
				  contents, ce);
	  if (error) {
	      ret.res = -1;
	      ret.error = error;
	  } else {
	      error = adir_creat (dire, name, res->fid);
	      if (error) {
		  ret.res = -1;
		  ret.error = error;
	      } else {
		  ret.res = 0;
	      }
	  }
     } else {
	  ret.res = -1;
	  ret.error = EACCES;
d763 6
d770 4
a773 4
	      dir_fid.Cell,
	      dir_fid.fid.Volume, dir_fid.fid.Vnode, dir_fid.fid.Unique,
	      name,
	      contents);
d776 1
a776 1
     ReleaseWriteLock (&dire->lock);
d797 1
a797 1
	 ret.res = -1;
d804 2
a805 2
	 ReleaseWriteLock (&dire->lock);
	 ret.res = -1;
d812 2
a813 2
	 ReleaseWriteLock (&dire->lock);
	 ret.res = -1;
d820 1
a820 1
	 ret.res = -1;
d826 1
a826 2
	  error = create_link (dire, name, 
			       file, ce);
d828 1
a828 1
	      ret.res = -1;
d833 1
a833 1
		  ret.res = -1;
d837 2
a838 1
		  ret.res = 0;
d842 1
a842 1
	  ret.res = -1;
d855 2
a856 2
     ReleaseWriteLock (&dire->lock);
     ReleaseWriteLock (&file->lock);
d859 1
d861 1
a861 1
 *
d874 1
a874 1
	 ret.res = -1;
d881 1
a881 1
	 ret.res = -1;
d889 1
a889 1
	      ret.res = -1;
d894 1
a894 1
		  ret.res = -1;
d897 2
a898 1
		  ret.res = 0;
d902 1
a902 1
	  ret.res = -1;
d911 1
a911 1
     ReleaseWriteLock (&dire->lock);
d916 1
a916 1
 *
d929 1
a929 1
	 ret.res = -1;
d936 1
a936 1
	 ret.res = -1;
d944 1
a944 1
	      ret.res = -1;
d949 1
a949 1
		  ret.res = -1;
d952 2
a953 1
		  ret.res = 0;
d957 1
a957 1
	  ret.res = -1;
d967 1
a967 1
     ReleaseWriteLock (&dire->lock);
d972 1
a972 1
 *
d989 1
a989 1
	 ret.res = -1;
d996 2
a997 2
	 ReleaseWriteLock (&old_dir->lock);
	 ret.res = -1;
d1009 2
a1010 2
	     ReleaseWriteLock (&old_dir->lock);
	     ret.res = -1;
d1017 1
a1017 1
	     ret.res = -1;
d1033 1
a1033 1
	      ret.res = -1;
d1036 5
a1040 1
	      VenusFid foo_fid;
d1042 1
a1042 3
	      ReleaseWriteLock (&old_dir->lock);
	      error = adir_lookup (old_dir->fid, old_name, &foo_fid, ce);
	      ObtainWriteLock (&old_dir->lock);
d1045 1
a1045 1
		  ret.res = -1;
d1049 17
a1065 2
	      error = adir_remove (old_dir, old_name)
		  || adir_creat (new_dir, new_name, foo_fid.fid);
d1068 1
a1068 1
		  ret.res = -1;
d1071 2
a1072 1
		  ret.res = 0;
d1076 1
a1076 1
	  ret.res = -1;
d1092 1
a1092 1
     ReleaseWriteLock (&old_dir->lock);
d1095 1
a1095 1
	 ReleaseWriteLock (&new_dir->lock);
@


1.1.1.1
log
@Initial version of Arla, a free implementation of an AFS cache-manager.
(second try, hopefully into the correct repository this time)
@
text
@@


1.1.1.2
log
@Import of arla-0.35.7
@
text
@d1 1
d3 1
a3 1
 * Copyright (c) 1995 - 2000 Kungliga Tekniska Högskolan
d18 6
a23 1
 * 3. Neither the name of the Institute nor the names of its contributors
d45 1
a45 1
RCSID("$KTH: inter.c,v 1.110.2.3 2001/06/05 01:27:05 ahltorp Exp $") ;
a48 2
Bool cm_consistencyp = FALSE;

d55 1
a55 1
static u_long
a119 4
/*
 *
 */

d126 1
a126 1
    if(connected_mode == CONNECTED && cm_consistencyp == FALSE)
a141 48
/*
 *
 *
 */

void
cm_turn_on_consistency_check(void)
{
    cm_consistencyp = TRUE;
}

/*
 * Check consistency of the fcache.
 * Will break the log-file.
 */

void
cm_check_consistency (void)
{
    static unsigned int log_times = 0;
    static unsigned int file_times = 0;
    u_long calc_size;
    u_long real_size;
    char newname[MAXPATHLEN];

    if (cm_consistencyp == FALSE)
	return;
    
    calc_size = fcache_calculate_usage();
    real_size = fcache_usedbytes ();

    if (calc_size != real_size) {
	    log_operation ("consistency check not guaranteed "
			   "(calc: %d, real: %d), aborting\n", 
			   (int) calc_size, (int) real_size);
	    cm_store_state ();
	    abort();
    }
    if (log_times % 100000 == 0) {
	log_operation ("consistency check ok, rotating logs\n");
	cm_store_state ();
	snprintf (newname, sizeof(newname), "log.%d", file_times++);
	rename ("log", newname);
	cm_init ();	
	log_operation ("brave new world\n");
    }
    log_times++;
}
d157 1
a157 6
cm_open (VenusFid *fid,
	 CredCacheEntry **ce,
	 u_int tokens,
	 fcache_cache_handle *cache_handle,
	 char *cache_name,
	 size_t cache_name_sz)
d164 1
a164 1
     error = fcache_get_data (&entry, fid, ce);
d171 10
d200 2
a201 4
     if (checkright (entry, mask, *ce)) {
#if 0
	  assert(entry->flags.attrusedp);
#endif
d204 2
a205 2
	  ret.res    = 0;
	  ret.error  = 0;
a206 3
	  
	  *cache_handle = entry->handle;
	  fcache_file_name (entry, cache_name, cache_name_sz);
d209 2
a210 3
			 fid->Cell,
			 fid->fid.Volume, fid->fid.Vnode, fid->fid.Unique,
			 mask);
d215 1
a215 1
     fcache_release(entry);
a216 2
     cm_check_consistency();
 
d226 1
a226 1
cm_close (VenusFid fid, int flag, AFSStoreStatus *status, CredCacheEntry* ce)
d234 1
a234 1
	ret.res   = -1;
d240 1
a240 4
	if (flag & XFS_FSYNC)
	    status->Mask |= SS_FSYNC;

	error = write_data (entry, status, ce);
d243 1
a243 1
	    fcache_release(entry);
d245 2
a246 2
	    ret.res   = -1;
	    ret.error = error;
a253 5
    fcache_release(entry);
    ret.res   = 0;
    ret.error = 0;

    cm_check_consistency();
d255 2
d268 1
a268 1
	    CredCacheEntry *ce,
a274 4
     arla_warnx (ADEBCM, "cm_getattr");

     assert (ae);

d277 1
a277 1
	 ret.res   = -1;
a280 2
     
     AssertExclLocked(&entry->lock);
d282 1
a282 1
     error = fcache_verify_attr (entry, NULL, NULL, ce);
d284 2
a285 2
	 fcache_release(entry);
	 ret.res   = -1;
a289 2
     arla_warnx (ADEBCM, "cm_getattr: done get attr");

d291 1
a291 1
		     entry->status.FileType == TYPE_FILE ? AREAD : 0,
d293 11
a303 10
	 *attr = entry->status;
	 ret.res   = 0;
	 ret.error = 0;
	 entry->flags.attrusedp = TRUE;
	 entry->flags.kernelp   = TRUE;
	 *ae = entry->acccache;
	 
	 log_operation ("getattr (%ld,%lu,%lu,%lu)\n",
			fid.Cell, fid.fid.Volume, fid.fid.Vnode, fid.fid.Unique);
	 
d305 2
a306 3
	 *ae = NULL;
	 ret.res   = -1;
	 ret.error = EACCES;
d308 6
a313 1
     *realfid = *fcache_realfid (entry);
a314 9
     if (!entry->flags.datausedp)
	 ret.tokens &= ~(XFS_DATA_MASK | XFS_OPEN_MASK);
     fcache_release(entry);
     
     arla_warnx (ADEBCM, "cm_getattr: return: %d.%d", ret.res, ret.error);
     cm_check_consistency();

     AssertNotExclLocked(&entry->lock);

d332 1
a332 1
	 ret.res   = -1;
d337 1
a337 1
     error = fcache_verify_attr (entry, NULL, NULL, ce);
d339 2
a340 2
	 fcache_release(entry);
	 ret.res   = -1;
d346 3
a348 2
	  ret.res   = write_attr (entry, attr, ce);
	  ret.error = ret.res;
d354 1
a354 1
	  ret.res   = -1;
d357 1
a357 2
     fcache_release(entry);
     cm_check_consistency();
d374 1
a374 1
	 ret.res   = -1;
d379 1
a379 1
     error = fcache_verify_attr (entry, NULL, NULL, ce);
d381 2
a382 2
	 fcache_release(entry);
	 ret.res   = -1;
a386 10
     if (size) {
	 error = fcache_verify_data (entry, ce);
	 if (error) {
	     fcache_release (entry);
	     ret.res   = -1;
	     ret.error = error;
	     return ret;
	 }
     }

d388 1
a388 2
	  ret.res   = truncate_file (entry, size, ce);
	  ret.error = ret.res;
d394 1
a394 1
	  ret.res   = -1;
d397 1
a397 2
     fcache_release(entry);
     cm_check_consistency();
d414 1
a414 1
	 ret.res   = -1;
d419 1
a419 1
     error = fcache_verify_attr (entry, NULL, NULL, ce);
d421 2
a422 2
	 fcache_release(entry);
	 ret.res   = -1;
d428 1
a428 2
	  ret.res   = 0;		/**/
	  ret.error = 0;
d430 1
a430 1
	  ret.res   = -1;
d437 1
a437 2
     fcache_release(entry);
     cm_check_consistency();
d486 1
a486 1
 * about mount points (which are followed iff follow_mount_point).
d490 1
a490 1
cm_lookup (VenusFid *dir_fid,
d493 1
a493 2
	   CredCacheEntry** ce,
	   int follow_mount_point)
a495 1
     FCacheEntry *entry;
d509 1
a509 1
     error = fcache_get_data(&entry, dir_fid, ce);
d511 3
a513 3
	 ret.res   = -1;
	 ret.error = error;
	 return ret;
d515 1
a515 2

     error = adir_lookup (entry, name, res);
d517 5
a521 4
	 fcache_release(entry);
	 ret.res   = -1;
	 ret.error = error;
	 return ret;
d524 8
a531 11
     ret.res    = 0;
     ret.error  = 0; 
     ret.tokens = 0;

     /* 
      * The ".." at the top of a volume just points to the volume root,
      * so get the real ".." from the volume cache instead.
      *
      * Or if we are looking up "." we don't want to follow the
      * mountpoint
      */
d533 6
a538 1
     if (strcmp(".", name) == 0) {
d540 7
a546 10
	 error = fcache_verify_attr (entry, NULL, NULL, *ce);
	 if (error) {
	     ret.res   = -1;
	     ret.error = error;
	     goto out;
	 }

	 *res = *dir_fid;
	 ret.tokens = entry->tokens;
     } else if ((strcmp("..", name) == 0 && VenusFid_cmp(dir_fid, res) == 0)) {
d548 1
a548 6
	 error = fcache_verify_attr (entry, NULL, NULL, *ce);
	 if (error) {
	     ret.res   = -1;
	     ret.error = error;
	     goto out;
	 }
d550 4
a553 9
	 *res = entry->volume->parent_fid; /* entry->parent */
	 ret.tokens = entry->tokens;
     } else if (follow_mount_point) {
	 error = followmountpoint (res, dir_fid, entry, ce);
	 if (error) {
	     ret.res   = -1;
	     ret.error = error;
	     goto out;
	 }
d555 1
a555 3
out:
     fcache_release(entry);

d557 3
a559 5
		    dir_fid->Cell,
		    dir_fid->fid.Volume,
		    dir_fid->fid.Vnode,
		    dir_fid->fid.Unique,
		    name);
a560 1
     cm_check_consistency();
d569 1
a569 1
cm_create (VenusFid *dir_fid, const char *name, AFSStoreStatus *store_attr,
d571 1
a571 1
	   CredCacheEntry **ce)
d577 1
a577 1
     error = fcache_get_data (&dire, dir_fid, ce);
d579 1
a579 1
	 ret.res   = -1;
d584 8
a591 1
     if (checkright (dire, AINSERT, *ce)) {
d593 1
a593 1
			       res, fetch_attr, *ce);
d595 1
a595 1
	      ret.res   = -1;
d600 1
a600 1
		  ret.res   = -1;
d603 1
a603 2
		  ret.res   = 0;
		  ret.error = 0;
d607 1
a607 1
	  ret.res   = -1;
d610 1
d612 2
a613 2
	      dir_fid->Cell,
	      dir_fid->fid.Volume, dir_fid->fid.Vnode, dir_fid->fid.Unique,
d616 1
a616 2
     fcache_release(dire);
     cm_check_consistency();
d625 1
a625 1
cm_mkdir (VenusFid *dir_fid, const char *name,
d628 1
a628 1
	  CredCacheEntry **ce)
d634 1
a634 1
     error = fcache_get_data (&dire, dir_fid, ce);
d636 1
a636 1
	 ret.res   = -1;
d641 8
a648 1
     if (checkright (dire, AINSERT, *ce)) {
d650 1
a650 1
				    res, fetch_attr, *ce);
d652 1
a652 1
	      ret.res   = -1;
d657 1
a657 1
		  ret.res   = -1;
d660 1
a660 2
		  ret.res   = 0;
		  ret.error = 0;
d664 1
a664 1
	  ret.res   = -1;
d669 2
a670 4
		    dir_fid->Cell,
		    dir_fid->fid.Volume,
		    dir_fid->fid.Vnode,
		    dir_fid->fid.Unique,
d673 2
a674 2
     ReleaseWriteLock (&dire->lock);
     cm_check_consistency();
d683 1
a683 1
cm_symlink (VenusFid *dir_fid,
d685 1
a685 2
	    VenusFid *res, VenusFid *realfid,
	    AFSFetchStatus *fetch_attr,
d687 1
a687 1
	    CredCacheEntry **ce)
d689 1
a689 1
     FCacheEntry *dire, *symlink_entry;
d693 1
a693 1
     error = fcache_get_data (&dire, dir_fid, ce);
d695 1
a695 1
	 ret.res   = -1;
d700 1
a700 18
     if (!checkright (dire, AINSERT, *ce)) {
	 ret.res   = -1;
	 ret.error = EACCES;
	 goto out;
     }

     /* It seems Transarc insists on mount points having mode bits 0644 */

     if (contents[0] == '%' || contents[0] == '#') {
	 store_attr->UnixModeBits = 0644;
	 store_attr->Mask |= SS_MODEBITS;
     } else if (store_attr->Mask & SS_MODEBITS
		&& store_attr->UnixModeBits == 0644)
	 store_attr->UnixModeBits = 0755;

     error = create_symlink (dire, name, store_attr,
			     res, fetch_attr,
			     contents, *ce);
d702 1
a702 1
	 ret.res   = -1;
d707 16
a722 42
     error = adir_creat (dire, name, res->fid);
     if (error) {
	 ret.res   = -1;
	 ret.error = error;
	 goto out;
     }

     error = followmountpoint(res, dir_fid, NULL, ce);
     if (error) {
	 ret.res   = -1;
	 ret.error = error;
	 goto out;
     }
     
     /*
      * If the new symlink is a mountpoint and it points
      * to dir_fid we will deadlock if we look it up.
      */

     if (VenusFid_cmp (res, dir_fid) != 0) {

	 error = fcache_get (&symlink_entry, *res, *ce);
	 if (error) {
	     ret.res   = -1;
	     ret.error = error;
	     goto out;
	 }
	 
	 error = fcache_verify_attr (symlink_entry, NULL, NULL, *ce);
	 if (error) {
	     fcache_release (symlink_entry);
	     ret.res   = -1;
	     ret.error = error;
	     goto out;
	 }
	 
	 symlink_entry->flags.kernelp = TRUE;

	 *fetch_attr = symlink_entry->status;
	 *realfid = *fcache_realfid (symlink_entry);

	 fcache_release (symlink_entry);
d724 2
a725 2
	 *fetch_attr = dire->status;
	 *realfid = *fcache_realfid (dire);
a726 4
     
     ret.res   = 0;
     ret.error = 0;
     
d728 7
a734 10
		    dir_fid->Cell,
		    dir_fid->fid.Volume,
		    dir_fid->fid.Vnode,
		    dir_fid->fid.Unique,
		    name,
		    contents);
     
 out:
     fcache_release(dire);
     cm_check_consistency();
d743 1
a743 1
cm_link (VenusFid *dir_fid,
d747 1
a747 1
	 CredCacheEntry **ce)
d753 8
a760 1
     error = fcache_get_data (&dire, dir_fid, ce);
d762 2
a763 1
	 ret.res   = -1;
d768 1
a768 1
     error = fcache_get (&file, existing_fid, *ce);
d770 2
a771 2
	 fcache_release(dire);
	 ret.res   = -1;
d776 1
a776 1
     error = fcache_verify_attr (file, NULL, NULL, *ce);
d778 1
a778 1
	 ret.res   = -1;
d783 3
a785 2
     if (checkright (dire, AINSERT, *ce)) {
	  error = create_link (dire, name, file, *ce);
d787 1
a787 1
	      ret.res   = -1;
d792 1
a792 1
		  ret.res   = -1;
d796 1
a796 2
		  ret.res   = 0;
		  ret.error = 0;
d800 1
a800 1
	  ret.res   = -1;
d804 2
a805 2
	      dir_fid->Cell,
	      dir_fid->fid.Volume, dir_fid->fid.Vnode, dir_fid->fid.Unique,
d813 2
a814 3
     fcache_release(dire);
     fcache_release(file);
     cm_check_consistency();
a816 1

d818 1
a818 1
 * generic function for both remove and rmdir
d821 3
a823 6
static Result
sub_remove (VenusFid *dir_fid, const char *name, CredCacheEntry **ce,
	    const char *operation,
	    int (*func)(FCacheEntry *fe,
			const char *name,
			CredCacheEntry *ce))
d829 1
a829 1
     error = fcache_get_data (&dire, dir_fid, ce);
d831 1
a831 1
	 ret.res   = -1;
d836 9
a844 2
     if (checkright (dire, ADELETE, *ce)) {
	  error = (*func) (dire, name, *ce);
d846 1
a846 1
	      ret.res   = -1;
d851 1
a851 1
		  ret.res   = -1;
d854 1
a854 2
		  ret.res   = 0;
		  ret.error = 0;
d858 1
a858 1
	  ret.res   = -1;
d861 4
a864 7
     log_operation ("%s (%ld,%lu,%lu,%lu) %s\n",
		    operation,
		    dir_fid->Cell,
		    dir_fid->fid.Volume,
		    dir_fid->fid.Vnode,
		    dir_fid->fid.Unique,
		    name);
d866 2
a867 2
     fcache_release(dire);
     cm_check_consistency();
d872 1
a872 1
 * Remove the file named `name' in the directory `dir_fid'.
d876 2
a877 2
cm_remove(VenusFid *dir_fid,
	  const char *name, CredCacheEntry **ce)
d879 45
a923 1
    return sub_remove (dir_fid, name, ce, "remove", remove_file);
d927 1
a927 1
 * Remove the directory named `name' in the directory `dir_fid'.
d931 3
a933 2
cm_rmdir(VenusFid *dir_fid,
	 const char *name, CredCacheEntry **ce)
d935 13
a947 2
    return sub_remove (dir_fid, name, ce, "rmdir", remove_directory);
}
d949 7
a955 4
/*
 * Called when the object is being moved to a new directory, to be
 * able to update .. when required.
 */
d957 1
a957 8
static int
potential_update_dir(FCacheEntry *child_entry,
		     const VenusFid *new_parent_fid,
		     FCacheEntry *parent_entry,
		     int *update_child,
		     CredCacheEntry *ce)
{
    int error;
d959 2
a960 26
    error = fcache_verify_attr (child_entry, parent_entry, NULL, ce);
    if (error) 
	return error;

    /*
     * if we're moving a directory.
     */

    if (child_entry->status.FileType == TYPE_DIR) {
	int fd;
	fbuf the_fbuf;

	error = fcache_verify_data (child_entry, ce); /* XXX - check fake_mp */
	if (error)
	    return error;

	error = fcache_get_fbuf (child_entry, &fd, &the_fbuf, O_RDWR,
				 FBUF_READ|FBUF_WRITE|FBUF_SHARED);
	if (error)
	    return error;

	error = fdir_changefid (&the_fbuf, "..", new_parent_fid);
	fbuf_end (&the_fbuf);
	close (fd);
	if (error)
	    return error;
d962 7
a968 4
	*update_child = 1;
    }
    return 0;
}
d970 6
a975 5
/*
 * Rename (old_parent_fid, old_name) -> (new_parent_fid, new_name)
 * update the `child' in the new directory if update_child.
 * set child_fid to the fid of the moved object.
 */
d977 3
a979 12
Result
cm_rename(VenusFid *old_parent_fid, const char *old_name,
	  VenusFid *new_parent_fid, const char *new_name,
	  VenusFid *child_fid,
	  int *update_child,
	  CredCacheEntry **ce)
{
    FCacheEntry *old_dir;
    FCacheEntry *new_dir;
    Result ret;
    int error;
    int diff_dir;
d981 2
a982 1
    *update_child = 0;
d984 8
a991 1
    /* old parent dir */
d993 3
a995 6
    error = fcache_get_data (&old_dir, old_parent_fid, ce);
    if (error) {
	ret.res   = -1;
	ret.error = error;
	return ret;
    }
d997 7
a1003 1
    diff_dir = VenusFid_cmp (old_parent_fid, new_parent_fid);
d1005 11
a1015 1
     /* new parent dir */
d1017 10
a1026 11
    if (diff_dir) {
	error = fcache_get_data (&new_dir, new_parent_fid, ce);
	if (error) {
	    fcache_release(old_dir);
	    ret.res   = -1;
	    ret.error = error;
	    return ret;
	}
    } else {
	new_dir = old_dir;
    }
d1028 6
a1033 93
    if (checkright (old_dir, ADELETE, *ce)
	&& checkright (new_dir, AINSERT, *ce)) {
	
	error = rename_file (old_dir, old_name, new_dir, new_name, *ce);
	if (error) {
	    ret.res   = -1;
	    ret.error = error;
	} else {
	    VenusFid new_fid, old_fid;
	    
	    /*
	     * Lookup the old name (to get the fid of the new name)
	     */
	    
	    error = adir_lookup (old_dir, old_name, &new_fid);
	    
	    if (error) {
		ret.res   = -1;
		ret.error = error;
		goto out;
	    }
	    
	    *child_fid = new_fid;
	    
	    if (diff_dir) {
		FCacheEntry *child_entry;
		
		error = fcache_get (&child_entry, *child_fid, *ce);
		if (error) {
		    ret.res   = -1;
		    ret.error = error;
		    goto out;
		}
		
		child_entry->parent = *new_parent_fid;

		error = potential_update_dir (child_entry, new_parent_fid,
					      new_dir, update_child, *ce);
		fcache_release (child_entry);
		if (error) {
		    ret.res   = -1;
		    ret.error = error;
		    goto out;
		}
	    }
	    
	    /*
	     * Lookup the new name, if it exists we need to clear it out.
	     * XXX Should we check the lnkcount and clear it from fcache ?
	     */
	    
	    error = adir_lookup (new_dir, new_name, &old_fid);
	    if (error == 0)
		adir_remove (new_dir, new_name);
	    
	    /*
	     * Now do the rename, ie create the new name and remove
	     * the old name.
	     */
	    
	    error = adir_creat (new_dir, new_name,  new_fid.fid)
		|| adir_remove (old_dir, old_name);
	    
	    if (error) {
		ret.res   = -1;
		ret.error = error;
	    } else {
		ret.res   = 0;
		ret.error = 0;
	    }
	}
    } else {
	ret.res   = -1;
	ret.error = EACCES;
    }
    
    log_operation ("rename (%ld,%lu,%lu,%lu) (%ld,%lu,%lu,%lu) %s %s\n",
		   old_parent_fid->Cell,
		   old_parent_fid->fid.Volume,
		   old_parent_fid->fid.Vnode,
		   old_parent_fid->fid.Unique,
		   new_parent_fid->Cell,
		   new_parent_fid->fid.Volume,
		   new_parent_fid->fid.Vnode,
		   new_parent_fid->fid.Unique,
		   old_name, new_name);
    
 out:
    fcache_release(old_dir);
    if (diff_dir)
	fcache_release(new_dir);
    cm_check_consistency();
    return ret;
@


1.1.1.3
log
@Import of arla -current as of Aug 5 2003

ok todd@@ deraadt@@
@
text
@d2 1
a2 1
 * Copyright (c) 1995 - 2002 Kungliga Tekniska Högskolan
d39 1
a39 1
RCSID("$arla: inter.c,v 1.138 2003/01/10 03:05:44 lha Exp $") ;
d41 1
a41 1
#include <nnpfs/nnpfs_message.h>
d130 3
d134 1
d163 2
a164 1
    int64_t calc_size, real_size;
d175 2
a176 3
			   "(calc: %d, real: %d, diff %d), aborting\n", 
			   (int) calc_size, (int) real_size,
			   (int)(calc_size - real_size));
d198 13
a210 4
 */

int
cm_open (FCacheEntry *entry, CredCacheEntry *ce, u_int tokens)
d212 2
d215 8
a222 1
     int error = 0;
d225 3
a227 5
     case NNPFS_DATA_R:
#if 0
     case NNPFS_OPEN_NR:
     case NNPFS_OPEN_SR:
#endif
d230 1
a230 1
     case NNPFS_DATA_W:
d233 1
a233 1
     case NNPFS_OPEN_NW:
a234 1
	  tokens |= NNPFS_DATA_R | NNPFS_DATA_W;
d240 1
a240 4
	 tokens |= NNPFS_DATA_R;
#if 0
	 assert(FALSE);
#endif
d243 2
a244 1
     if (checkright (entry, mask, ce)) {
d246 1
d249 3
d253 3
d257 2
a258 4
			 entry->fid.Cell,
			 entry->fid.fid.Volume,
			 entry->fid.fid.Vnode,
			 entry->fid.fid.Unique,
d260 5
a264 2
     } else
	  error = EACCES;
d268 1
a268 1
     return error;
d276 2
a277 3
int
cm_close (FCacheEntry *entry, int flag,
	  AFSStoreStatus *status, CredCacheEntry* ce)
d279 10
a288 1
    int error = 0;
d290 2
a291 2
    if (flag & NNPFS_WRITE) {
	if (flag & NNPFS_FSYNC)
d297 1
d299 3
a301 1
	    return error;
d306 5
a310 5
		   entry->fid.Cell,
		   entry->fid.fid.Volume,
		   entry->fid.fid.Vnode,
		   entry->fid.fid.Unique,
		   flag);
d314 1
a314 1
    return error;
d321 4
a324 2
int
cm_getattr (FCacheEntry *entry,
d328 3
a330 1
     int error = 0;
d336 7
d346 6
a351 2
     if (error)
	 return error;
d358 3
d366 1
a366 4
			entry->fid.Cell,
			entry->fid.fid.Volume,
			entry->fid.fid.Vnode,
			entry->fid.fid.Unique);
d370 2
a371 1
	 error = EACCES;
d373 2
d376 2
a377 1
	 entry->tokens &= ~(NNPFS_DATA_MASK | NNPFS_OPEN_MASK);
d379 1
a379 1
     arla_warnx (ADEBCM, "cm_getattr: return: %d", error);
d382 3
a384 1
     return error;
d392 2
a393 2
int
cm_setattr (FCacheEntry *entry, AFSStoreStatus *attr, CredCacheEntry* ce)
d395 10
a404 1
     int error = 0;
d407 6
a412 3
     if (error)
	 return error;

d415 2
a416 1
	  error = write_attr (entry, attr, ce);
d419 1
a419 6
			 entry->fid.Cell,
			 entry->fid.fid.Volume,
			 entry->fid.fid.Vnode,
			 entry->fid.fid.Unique);
     } else
	 error = EACCES;
d421 5
d427 1
a427 1
     return error;
d434 2
a435 3
int
cm_ftruncate (FCacheEntry *entry, off_t size,
	      AFSStoreStatus *storestatus, CredCacheEntry* ce)
d437 10
a446 1
     int error = 0;
d449 6
a454 2
     if (error)
	 return error;
d458 6
a463 2
	 if (error)
	     return error;
d467 2
a468 1
	  error = truncate_file (entry, size, storestatus, ce);
d471 7
a477 8
			 entry->fid.Cell,
			 entry->fid.fid.Volume,
			 entry->fid.fid.Vnode,
			 entry->fid.fid.Unique,
			 (unsigned long)size);
     } else
	 error = EACCES;

d479 1
a479 1
     return error;
d486 2
a487 2
int
cm_access (FCacheEntry *entry, int mode, CredCacheEntry* ce)
d489 10
a498 1
     int error = 0;
d501 6
a506 2
     if (error)
	 return error;
d508 7
a514 4
     if (checkright (entry, AWRITE, ce))
	 error = 0;
     else
	 error = EACCES;
d517 1
a517 4
		    entry->fid.Cell,
		    entry->fid.fid.Volume,
		    entry->fid.fid.Vnode,
		    entry->fid.fid.Unique);
d519 1
d521 1
a521 1
     return error;
d572 2
a573 2
int
cm_lookup (FCacheEntry **entry,
d580 3
a582 5
     int error = 0;

     error = fcache_get_data(entry, ce, 0);
     if (error)
	 return error;
d585 8
a592 1
	 int i;
d594 6
a599 11
	 for (i = 0; i < sysnamenum; i++) {
	     int size = expand_sys (tmp_name, sizeof(tmp_name), name,
				    "@@sys", sysnamelist[i]);
	     if (size >= sizeof(tmp_name))
		 continue;
	     error = adir_lookup (*entry, tmp_name, res);
	     if (error == 0)
		 break;
	 }
	 if (i == sysnamenum)
	     error = ENOENT;
d601 7
a607 2
     } else
	 error = adir_lookup (*entry, name, res);
d609 3
a611 2
     if (error) 
	 return error;
d623 4
a626 2
	 error = fcache_verify_attr (*entry, NULL, NULL, *ce);
	 if (error)
d628 1
d630 3
a632 3
	 *res = (*entry)->fid;
     } else if (strcmp("..", name) == 0
		&& VenusFid_cmp(&(*entry)->fid, res) == 0) {
d634 4
a637 2
	 error = fcache_verify_attr (*entry, NULL, NULL, *ce);
	 if (error)
d639 1
d641 2
a642 1
	 *res = (*entry)->volume->parent_fid; /* entry->parent */
d644 4
a647 2
	 error = followmountpoint (res, &(*entry)->fid, *entry, ce);
	 if (error)
d649 1
d652 2
d655 4
a658 4
		    (*entry)->fid.Cell,
		    (*entry)->fid.fid.Volume,
		    (*entry)->fid.fid.Vnode,
		    (*entry)->fid.fid.Unique,
d662 1
a662 1
     return error;
d669 2
a670 2
int
cm_create (FCacheEntry **dir, const char *name, AFSStoreStatus *store_attr,
d674 3
a676 1
     int error = 0;
d678 6
a683 11
     error = fcache_get_data (dir, ce, 0);
     if (error)
	 return error;

     if (checkright (*dir, AINSERT, *ce)) {
	 error = create_file (*dir, name, store_attr,
			      res, fetch_attr, *ce);
	 if (error == 0)
	     error = adir_creat (*dir, name, res->fid);
     } else
	 error = EACCES;
d685 20
d706 3
a708 5
		    (*dir)->fid.Cell,
		    (*dir)->fid.fid.Volume,
		    (*dir)->fid.fid.Vnode,
		    (*dir)->fid.fid.Unique,
		    name);
d710 1
d712 1
a712 1
     return error;
d719 2
a720 2
int
cm_mkdir (FCacheEntry **dir, const char *name,
d725 3
a727 1
     int error = 0;
d729 27
a755 12
     error = fcache_get_data (dir, ce, 0);
     if (error)
	 return error;

     if (checkright (*dir, AINSERT, *ce)) {
	 error = create_directory (*dir, name, store_attr,
				   res, fetch_attr, *ce);
	 if (error == 0)
	     error = adir_creat (*dir, name, res->fid);
	 
     } else
	 error = EACCES;
d758 4
a761 4
		    (*dir)->fid.Cell,
		    (*dir)->fid.fid.Volume,
		    (*dir)->fid.fid.Vnode,
		    (*dir)->fid.fid.Unique,
d764 1
d766 1
a766 1
     return error;
d773 2
a774 2
int
cm_symlink (FCacheEntry **dir,
d781 3
a783 2
     FCacheEntry *symlink_entry;
     int error = 0;
d785 6
a790 3
     error = fcache_get_data (dir, ce, 0);
     if (error)
	 return error;
d792 3
a794 2
     if (!checkright (*dir, AINSERT, *ce)) {
	 error = EACCES;
d807 1
a807 1
     error = create_symlink (*dir, name, store_attr,
d810 3
a812 1
     if (error)
d814 1
d816 4
a819 2
     error = adir_creat (*dir, name, res->fid);
     if (error)
d821 1
d823 4
a826 2
     error = followmountpoint(res, &(*dir)->fid, NULL, ce);
     if (error)
d828 1
d835 1
a835 1
     if (VenusFid_cmp (res, &(*dir)->fid) != 0) {
d838 3
a840 1
	 if (error)
d842 1
d844 1
a844 1
	 error = fcache_verify_attr (symlink_entry, *dir, name, *ce);
d847 2
d859 2
a860 2
	 *fetch_attr = (*dir)->status;
	 *realfid = *fcache_realfid (*dir);
d863 3
d867 4
a870 4
		    (*dir)->fid.Cell,
		    (*dir)->fid.fid.Volume,
		    (*dir)->fid.fid.Vnode,
		    (*dir)->fid.fid.Unique,
d875 1
d877 1
a877 1
     return error;
d884 2
a885 2
int
cm_link (FCacheEntry **dir,
d891 3
a893 2
     FCacheEntry *file;
     int error = 0;
d895 6
a900 3
     error = fcache_get_data (dir, ce, 0);
     if (error)
	 return error;
d903 6
a908 2
     if (error)
	 return error;
d910 4
a913 2
     error = fcache_verify_attr (file, *dir, NULL, *ce);
     if (error)
d915 1
d917 20
a936 10
     if (checkright (*dir, AINSERT, *ce)) {
	 error = create_link (*dir, name, file, *ce);
	 if (error == 0) {
	     error = adir_creat (*dir, name, existing_fid.fid);
	     if (error == 0)
		 *existing_status = file->status;
	 }
     } else 
	 error = EACCES;

d938 7
a944 9
		    (*dir)->fid.Cell,
		    (*dir)->fid.fid.Volume,
		    (*dir)->fid.fid.Vnode,
		    (*dir)->fid.fid.Unique,
		    existing_fid.Cell,
		    existing_fid.fid.Volume,
		    existing_fid.fid.Vnode,
		    existing_fid.fid.Unique,
		    name);
d947 1
d950 1
a950 1
     return error;
d957 2
a958 2
static int
sub_remove (FCacheEntry **dir, const char *name, CredCacheEntry **ce,
d964 10
a973 1
     int error = 0;
d975 19
a993 11
     error = fcache_get_data (dir, ce, 0);
     if (error)
	 return error;

     if (checkright (*dir, ADELETE, *ce)) {
	 error = (*func) (*dir, name, *ce);
	 if (error == 0)
	     error = adir_remove (*dir, name);
     } else 
	 error = EACCES;
     
d996 4
a999 4
		    (*dir)->fid.Cell,
		    (*dir)->fid.fid.Volume,
		    (*dir)->fid.fid.Vnode,
		    (*dir)->fid.fid.Unique,
d1002 1
d1004 1
a1004 1
     return error;
d1008 1
a1008 1
 * Remove the file named `name' in the directory `dir'.
d1011 2
a1012 2
int
cm_remove(FCacheEntry **dir,
d1015 1
a1015 1
    return sub_remove (dir, name, ce, "remove", remove_file);
d1019 1
a1019 1
 * Remove the directory named `name' in the directory `dir'.
d1022 2
a1023 2
int
cm_rmdir(FCacheEntry **dir,
d1026 1
a1026 1
    return sub_remove (dir, name, ce, "rmdir", remove_directory);
d1039 1
a1039 1
		     CredCacheEntry **ce)
d1043 1
a1043 1
    error = fcache_verify_attr (child_entry, parent_entry, NULL, *ce);
d1055 1
a1055 1
	error = fcache_get_data(&child_entry, ce, 0); /* XXX - check fake_mp */
d1081 3
a1083 3
int
cm_rename(FCacheEntry **old_dir, const char *old_name,
	  FCacheEntry **new_dir, const char *new_name,
d1088 6
a1093 3
    int error = 0;
    VenusFid new_fid, old_fid;
    
d1098 6
a1103 3
    error = fcache_get_data (old_dir, ce, 0);
    if (error)
	return error;
d1105 1
a1105 1
    /* new parent dir */
d1107 1
a1107 3
    error = fcache_get_data (new_dir, ce, 0);
    if (error)
	return error;
d1109 7
a1115 51
    if (!checkright (*old_dir, ADELETE, *ce)
	|| !checkright (*new_dir, AINSERT, *ce)) {
	error = EACCES;
	goto out;
    }
	
    error = rename_file (*old_dir, old_name, *new_dir, new_name, *ce);
    if (error)
	goto out;

    /*
     * Lookup the old name (to get the fid of the new name)
     */
    
    error = adir_lookup (*old_dir, old_name, &new_fid);
    
    if (error)
	goto out;
    
    *child_fid = new_fid;
    
    if (VenusFid_cmp (&(*old_dir)->fid, &(*new_dir)->fid)) {
	FCacheEntry *child_entry;
	
	error = fcache_get (&child_entry, *child_fid, *ce);
	if (error)
	    goto out;
	
	child_entry->parent = (*new_dir)->fid;
	
	error = potential_update_dir (child_entry, &(*new_dir)->fid,
				      *new_dir, update_child, ce);
	fcache_release (child_entry);
	if (error)
	    goto out;
    }
    
    /*
     * Lookup the new name, if it exists we need to silly
     * rename it was just killed on the fileserver.
     * XXXDISCO remember mark this node as dead
     */

    error = adir_lookup (*new_dir, new_name, &old_fid);
    if (error == 0) {
	FCacheEntry *old_entry;

	error = fcache_find (&old_entry, old_fid);
	if (error == 0) {
	    old_entry->flags.silly = TRUE;
	    fcache_release (old_entry);
d1117 2
a1118 1
	adir_remove (*new_dir, new_name);
a1119 31
    
    /*
     * Now do the rename, ie create the new name and remove
     * the old name.
     */
    
    error = adir_creat (*new_dir, new_name,  new_fid.fid)
	|| adir_remove (*old_dir, old_name);
    
    log_operation ("rename (%ld,%lu,%lu,%lu) (%ld,%lu,%lu,%lu) %s %s\n",
		   (*old_dir)->fid.Cell,
		   (*old_dir)->fid.fid.Volume,
		   (*old_dir)->fid.fid.Vnode,
		   (*old_dir)->fid.fid.Unique,
		   (*new_dir)->fid.Cell,
		   (*new_dir)->fid.fid.Volume,
		   (*new_dir)->fid.fid.Vnode,
		   (*new_dir)->fid.fid.Unique,
		   old_name, new_name);
    
 out:
    cm_check_consistency();
    return error;
}

/* 
 * An emulation of kernel lookup, convert (fid, name) into
 * (res).  Strips away leading /afs, removes double slashes,
 * and resolves symlinks.
 * Return 0 for success, otherwise -1.
 */
d1121 2
a1122 36
int
cm_walk (VenusFid fid,
	 const char *name,
	 VenusFid *res)
{
    VenusFid cwd = fid;
    char *base;
    VenusFid file;
    FCacheEntry *entry;
    FCacheEntry *dentry;
    int error;
    char symlink[MAXPATHLEN];
    char store_name[MAXPATHLEN];
    char *fname;
    CredCacheEntry *ce;

    ce = cred_get (fid.Cell, getuid(), CRED_ANY);
    
    strlcpy(store_name, name, sizeof(store_name));
    fname = store_name;
    
    do {
        /* set things up so that fname points to the remainder of the path,
         * whereas base points to the whatever preceeds the first /
         */
        base = fname;
        fname = strchr(fname, '/');
        if (fname) {
            /* deal with repeated adjacent / chars by eliminating the
             * duplicates. 
             */
            while (*fname == '/') {
                *fname = '\0';
                fname++;
            }
        }
d1124 13
a1136 3
        /* deal with absolute pathnames first. */
        if (*base == '\0') {
	    error = getroot(&cwd, ce);
d1138 3
a1140 3
		arla_warn(ADEBWARN, error, "getroot");
		cred_free(ce);
		return -1;
d1143 22
a1164 7
	    if (fname) {
		if (strncmp("afs",fname,3) == 0) {
		    fname += 3;
		    }
		continue;
	    } else {
		break;
a1165 34
	}
	error = fcache_get(&dentry, cwd, ce);
	if (error) {
	    arla_warn (ADEBWARN, error, "fcache_get");
	    cred_free(ce);
	    return -1;
	}
	error = cm_lookup (&dentry, base, &file, &ce, TRUE);
	if (error) {
	    fcache_release(dentry);
	    arla_warn (ADEBWARN, error, "lookup(%s)", base);
	    cred_free(ce);
	    return -1;
	}
	fcache_release(dentry);
	error = fcache_get(&entry, file, ce);
	if (error) {
	    arla_warn (ADEBWARN, error, "fcache_get");
	    cred_free(ce);
	    return -1;
	}
	
	error = fcache_get_data (&entry, &ce, 0);
	if (error) {
	    fcache_release(entry);
	    arla_warn (ADEBWARN, error, "fcache_get_data");
	    cred_free(ce);
	    return -1;
	}
	
	/* handle symlinks here */
	if (entry->status.FileType == TYPE_LINK) {
	    int len;
	    int fd;
d1167 12
a1178 19
	    fd = fcache_open_file (entry, O_RDONLY);
	    /* read the symlink and null-terminate it */
	    if (fd < 0) {
		fcache_release(entry);
		arla_warn (ADEBWARN, errno, "fcache_open_file");
		cred_free(ce);
		return -1;
	    }
	    len = read (fd, symlink, sizeof(symlink));
	    close (fd);
	    if (len <= 0) {
		fcache_release(entry);
		arla_warnx (ADEBWARN, "cannot read symlink");
		cred_free(ce);
		return -1;
	    }
	    symlink[len] = '\0';
	    /* if we're not at the end (i.e. fname is not null), take
	     * the expansion of the symlink and append fname to it.
d1180 10
a1189 3
	    if (fname != NULL) {
		strcat (symlink, "/");
		strcat (symlink, fname);
a1190 5
	    strlcpy(store_name, symlink, sizeof(store_name));
	    fname = store_name;
	} else {
	    /* if not a symlink, just update cwd */
	    cwd = entry->fid;
d1192 22
a1213 8
	fcache_release(entry);
	
	/* the *fname condition below deals with a trailing / in a
	 * path-name */
    } while (fname != NULL && *fname);
    *res = cwd;
    cred_free(ce);
    return 0;
@


