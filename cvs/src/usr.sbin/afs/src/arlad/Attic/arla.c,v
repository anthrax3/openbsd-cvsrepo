head	1.8;
access;
symbols
	OPENBSD_5_2:1.7.0.34
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.32
	OPENBSD_5_0:1.7.0.30
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.7.0.28
	OPENBSD_4_9_BASE:1.7
	OPENBSD_4_8:1.7.0.26
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.7.0.22
	OPENBSD_4_7_BASE:1.7
	OPENBSD_4_6:1.7.0.24
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.7.0.20
	OPENBSD_4_5_BASE:1.7
	OPENBSD_4_4:1.7.0.18
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.7.0.16
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.7.0.14
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.12
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.10
	OPENBSD_4_0_BASE:1.7
	OPENBSD_3_9:1.7.0.8
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.7.0.6
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.4
	OPENBSD_3_7_BASE:1.7
	OPENBSD_3_6:1.7.0.2
	OPENBSD_3_6_BASE:1.7
	OPENBSD_3_5:1.6.0.2
	OPENBSD_3_5_BASE:1.6
	OPENBSD_3_4:1.5.0.2
	OPENBSD_3_4_BASE:1.5
	arla-20030805:1.1.1.3
	OPENBSD_3_3:1.4.0.4
	OPENBSD_3_3_BASE:1.4
	OPENBSD_3_2:1.4.0.2
	OPENBSD_3_2_BASE:1.4
	arla-0-35-7:1.1.1.2
	OPENBSD_3_1:1.3.0.8
	OPENBSD_3_1_BASE:1.3
	OPENBSD_3_0:1.3.0.6
	OPENBSD_3_0_BASE:1.3
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_9:1.3.0.4
	OPENBSD_2_8:1.3.0.2
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.2.0.4
	OPENBSD_2_7_BASE:1.2
	OPENBSD_2_6:1.2.0.2
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.1.1.1.0.4
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.2
	OPENBSD_2_4_BASE:1.1.1.1
	arla-0_9:1.1.1.1
	arla:1.1.1;
locks; strict;
comment	@ * @;


1.8
date	2012.08.23.06.21.50;	author deraadt;	state dead;
branches;
next	1.7;

1.7
date	2004.05.07.23.04.07;	author beck;	state Exp;
branches;
next	1.6;

1.6
date	2003.12.16.20.13.55;	author beck;	state Exp;
branches;
next	1.5;

1.5
date	2003.08.05.08.42.41;	author hin;	state Exp;
branches;
next	1.4;

1.4
date	2002.06.07.04.28.57;	author hin;	state Exp;
branches;
next	1.3;

1.3
date	2000.09.11.14.40.39;	author art;	state Exp;
branches;
next	1.2;

1.2
date	99.04.30.01.59.06;	author art;	state Exp;
branches;
next	1.1;

1.1
date	98.09.14.21.52.54;	author art;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.09.14.21.52.54;	author art;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.06.07.04.14.22;	author hin;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2003.08.05.08.21.00;	author hin;	state Exp;
branches;
next	;


desc
@@


1.8
log
@the afs src tree can go away
@
text
@/*
 * Copyright (c) 1995 - 2003 Kungliga Tekniska Högskolan
 * (Royal Institute of Technology, Stockholm, Sweden).
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * Test to talk with FS
 */

#include "arla_local.h"
#include <parse_units.h>
#include <getarg.h>

RCSID("$arla: arla.c,v 1.163 2003/06/10 16:25:07 lha Exp $") ;

enum connected_mode connected_mode = CONNECTED;

static void
initrx (int port)
{
    int error;

    if (port == 0)
	port = afscallbackport;

    error = rx_Init (htons(port));
    if (error)
	arla_err (1, ADEBERROR, error, "rx_init");
}


void
store_state (void)
{
    arla_warnx (ADEBMISC, "storing state");
    fcache_store_state ();
    volcache_store_state ();
    cm_store_state ();
}

typedef enum { CONF_PARAM_INT, 
	       CONF_PARAM_STR,
	       CONF_PARAM_BOOL,
	       CONF_PARAM_INT64
} conf_type;

struct conf_param {
    const char *name;
    conf_type type;
    void *val;
};

/*
 * Reads in a configuration file, and sets some defaults.
 */

static struct units size_units[] = {
    { "G", 1024 * 1024 * 1024 },
    { "M", 1024 * 1024 },
    { "k", 1024 },
    { NULL, 0 }
};

static void
read_conffile(const char *fname,
	      struct conf_param *params)
{
    FILE *fp;
    char buf[256];
    int lineno;
    struct conf_param *p;

    arla_warnx (ADEBINIT, "read_conffile: %s", fname);

    fp = fopen(fname, "r");
    if (fp == NULL) {
	arla_warn (ADEBINIT, errno, "open %s", fname);
	return;
    }

    lineno = 0;

    while (fgets (buf, sizeof(buf), fp) != NULL) {
	struct conf_param *partial_param = NULL;
	int partial_match = 0;
	char *save = NULL;
	char *n;
	char *v;
	int64_t val;
	char *endptr;

	++lineno;
	buf[strcspn(buf, "\n")] = '\0';
	if (buf[0] == '\0' || buf[0] == '#')
	    continue;

	n = strtok_r (buf, " \t", &save);
	if (n == NULL) {
	    fprintf (stderr, "%s:%d: no parameter?\n", fname, lineno);
	    continue;
	}

	v = strtok_r (NULL, " \t", &save);
	if (v == NULL) {
	    fprintf (stderr, "%s:%d: no value?\n", fname, lineno);
	    continue;
	}

    
	for (p = params; p->name; ++p) {
	    if (strcmp(n, p->name) == 0) {
		partial_match = 1;
		partial_param = p;
		break;
	    } else if(strncmp(n, p->name, strlen(n)) == 0) {
		++partial_match;
		partial_param = p;
	    }
	}
	if (partial_match == 0) {
	    fprintf (stderr, "%s:%d: unknown parameter `%s'\n",
		     fname, lineno, n);
	    continue;
	} else if (partial_match != 1) {
	    fprintf (stderr, "%s:%d: ambiguous parameter `%s'\n",
		     fname, lineno, n);
	    continue;
	}

	p = partial_param;

	switch (p->type) {
	case CONF_PARAM_INT:
	case CONF_PARAM_INT64:

	    val = parse_units(v, size_units, NULL);
	    if(val == -1 || val < 0) {
#ifdef HAVE_STRTOLL
		val = strtoll(v, &endptr, 0);
#else
		val = strtol(v, &endptr, 0);
#endif
		if (*endptr != '\0')
		    fprintf (stderr, "%s:%d: bad value `%s'\n",
			     fname, lineno, v);
	    }

	    if (p->type == CONF_PARAM_INT)
		    *((unsigned *)partial_param->val) = val;
	    else if (p->type == CONF_PARAM_INT64)
		    *((int64_t *)partial_param->val) = val;
	    else
		    errx(-1, "Unknown conf_param p->type");
	    break;

	case CONF_PARAM_STR:

	    *((char **)partial_param->val) = strdup(v);
	    
	    break;

	case CONF_PARAM_BOOL:

	    if (strcasecmp(v, "yes") == 0 || strcasecmp(v, "true") == 0)
		*((unsigned *)partial_param->val) = 1;
	    else if (strcasecmp(v, "no") == 0 || strcasecmp(v, "false") == 0)
		*((unsigned *)partial_param->val) = 0;
	    else
		fprintf (stderr, "%s:%d: bad boolean value `%s'\n",
			 fname, lineno, v);
	    break;
	default:
	    errx(-1, "read_conffile: Unknown type"); 
	}
    }
    fclose(fp);
}

#ifdef HAVE_KRB4
#ifndef HAVE_KRB_GET_ERR_TEXT

#ifndef MAX_KRB_ERRORS
#define MAX_KRB_ERRORS 256
#endif

static const char err_failure[] = "Unknown error code passed (krb_get_err_text)";

const char *
krb_get_err_text(int code)
{
  if(code < 0 || code >= MAX_KRB_ERRORS)
    return err_failure;
  return krb_err_txt[code];
}

#endif
#endif

static unsigned low_vnodes	= ARLA_LOW_VNODES;
static unsigned high_vnodes	= ARLA_HIGH_VNODES;
static int64_t low_bytes	= ARLA_LOW_BYTES;
static int64_t high_bytes	= ARLA_HIGH_BYTES;
static unsigned numcreds	= ARLA_NUMCREDS;
static unsigned numconns	= ARLA_NUMCONNS;
static unsigned numvols		= ARLA_NUMVOLS;
static unsigned dynrootlevel	= DYNROOT_DEFAULT;
static char *conf_sysname	= NULL;	/* sysname from conf file */
const char *argv_sysname	= NULL; /* sysname from argv */
#ifdef KERBEROS
const char *rxkad_level_string = "crypt";
#endif

static struct conf_param conf_params[] = {
    {"dynroot",			CONF_PARAM_BOOL,	&dynrootlevel},
    {"fake_stat",		CONF_PARAM_BOOL,	&fake_stat},
    {"fetch_block",		CONF_PARAM_INT,		&fetch_block_size},
    {"low_vnodes",		CONF_PARAM_INT,		&low_vnodes},
    {"high_vnodes",		CONF_PARAM_INT,		&high_vnodes},
    {"low_bytes",		CONF_PARAM_INT64,	&low_bytes},
    {"high_bytes",		CONF_PARAM_INT64,	&high_bytes},
    {"numcreds",		CONF_PARAM_INT,		&numcreds},
    {"numconns",		CONF_PARAM_INT,		&numconns},
    {"numvols",			CONF_PARAM_INT,		&numvols},
    {"sysname",			CONF_PARAM_STR,		&conf_sysname},
#ifdef KERBEROS
    {"rxkad-level",		CONF_PARAM_STR,		&rxkad_level_string},
#endif
    { NULL }
};

const char *conf_file = ARLACONFFILE;
char *log_file  = NULL;
char *debug_levels = NULL;
char *connected_mode_string = NULL;
char *root_volume;
int cpu_usage;
int version_flag;
int help_flag;
int recover = 0;
int dynroot_enable = 0;
int cm_consistency = 0;
int fake_stat = 0;

/*
 * These are exported to other modules
 */

int num_workers = 16;
char *cache_dir;
struct passwd *pw;
int fake_mp;
int fork_flag = 1;

/*
 * Global AFS variables, se arla_local.h for comment
 */

int afs_BusyWaitPeriod = 15;

/*
 *
 */

static int
parse_string_list (const char *s, const char **units)
{
    const char **p;
    int partial_val = 0;
    int partial_match = 0;
    
    for (p = units; *p; ++p) {
	if (strcmp (s, *p) == 0)
	    return p - units;
	if (strncmp (s, *p, strlen(s)) == 0) {
	    partial_match++;
	    partial_val = p - units;
	}
    }
    if (partial_match == 1)
	return partial_val;
    else
	return -1;
}

#ifdef KERBEROS
static const char *rxkad_level_units[] = {
"clear",			/* 0 */
"auth",				/* 1 */
"crypt",			/* 2 */
NULL
};

static int
parse_rxkad_level (const char *s)
{
    return parse_string_list (s, rxkad_level_units);
}
#endif

static const char *connected_levels[] = {
"connected",			/* CONNECTED   = 0 */
"fetch-only",			/* FETCH_ONLY  = 1 */
"disconnected",			/* DISCONNCTED = 2 */
NULL
};

static int
set_connected_mode (const char *s)
{
    return parse_string_list (s, connected_levels);
}

/*
 *
 */

int
arla_init (void)
{
    log_flags log_flags;
    char fpriofile[MAXPATHLEN];
    const char *temp_sysname;

    if (log_file == NULL)
	log_file = default_log_file;

    if (strcmp(log_file, "syslog") == 0)
	log_file = "syslog:no-delay";

    log_flags = 0;
    if (cpu_usage)
	log_flags |= LOG_CPU_USAGE;
    arla_loginit(log_file, log_flags);
     
    if (debug_levels != NULL) {
	if (arla_log_set_level (debug_levels) < 0) {
	    warnx ("bad debug levels: `%s'", debug_levels);
	    arla_log_print_levels (stderr);
	    exit (1);
	}
    }

    if (connected_mode_string != NULL) {
	int tmp = set_connected_mode (connected_mode_string);

	if (tmp < 0)
	    errx (1, "bad connected mode: `%s'", connected_mode_string);
	connected_mode = tmp;
    }

    read_conffile(conf_file, conf_params);

#ifdef KERBEROS
    conn_rxkad_level = parse_rxkad_level (rxkad_level_string);
    if (conn_rxkad_level < 0)
	errx (1, "bad rxkad level `%s'", rxkad_level_string);
#endif
    pw = getpwnam("_afs");
    if (pw == NULL)
	errx (1, "Unable to find user '_afs'");	

    if (cache_dir == NULL)
	cache_dir = get_default_cache_dir();

    if (mkdir (cache_dir, 0777) < 0 && errno != EEXIST)
	arla_err (1, ADEBERROR, errno, "mkdir %s", cache_dir);
    if (pw && chown(cache_dir, pw->pw_uid, pw->pw_gid) == -1)
	arla_err (1, ADEBERROR, errno, "chown %s", cache_dir);
    if (chdir (cache_dir) < 0)
	arla_err (1, ADEBERROR, errno, "chdir %s", cache_dir);


    if (argv_sysname)
	temp_sysname = argv_sysname;
    else if (conf_sysname)
	temp_sysname = conf_sysname;
    else
	temp_sysname = arla_getsysname ();

    if (temp_sysname != NULL)
	fcache_setdefsysname(temp_sysname);

    if (dynrootlevel || dynroot_enable)
	dynroot_setenable (TRUE);

    snprintf(fpriofile, sizeof(fpriofile), "%s/%s", cache_dir, "fprio");

    /*
     * Init
     */ 

    arla_warnx (ADEBINIT,"Arlad booting sequence:");
    arla_warnx (ADEBINIT, "connected mode: %s",
		connected_levels[connected_mode]);
    arla_warnx (ADEBINIT, "ports_init");
    ports_init ();
    arla_warnx (ADEBINIT, "uae_init");
    uae_init ();
    arla_warnx (ADEBINIT, "rx");
    initrx (client_port);
    arla_warnx (ADEBINIT, "conn_init numconns = %u", numconns);
    conn_init (numconns);
    arla_warnx (ADEBINIT, "cellcache");
    cell_init (0, arla_log_method);
    arla_warnx (ADEBINIT, "poller");
    poller_init();
    arla_warnx (ADEBINIT, "fprio");
    fprio_init(fpriofile);
    arla_warnx (ADEBINIT, "volcache numvols = %u", numvols);
    volcache_init (numvols, recover);
    if (root_volume != NULL)
	volcache_set_rootvolume (root_volume);
#ifdef KERBEROS
    arla_warnx (ADEBINIT, "using rxkad level %s",
		rxkad_level_units[conn_rxkad_level]);
#endif

    /*
     * Credential cache
     */
    arla_warnx (ADEBINIT, "credcache numcreds = %u", numcreds);
    cred_init (numcreds);

    arla_warnx (ADEBINIT,
		"fcache low_vnodes = %u, high_vnodes = %u"
		"low_bytes = %ld, high_bytes = %ld",
		low_vnodes, high_vnodes,
		(long)low_bytes, (long)high_bytes);
    fcache_init (low_vnodes, high_vnodes,
		 low_bytes, high_bytes, recover);

    arla_warnx (ADEBINIT, "cmcb");
    cmcb_init ();

    arla_warnx(ADEBINIT, "cm");
    cm_init ();

    if (cm_consistency) {
	arla_warnx(ADEBINIT, "turning on consistency test");
	cm_turn_on_consistency_check();
    }

    arla_warnx(ADEBINIT, "arla init done.");

    return 0;
}
@


1.7
log
@This makes afsd drop priviledge to user _afs inside a chroot (the
cache directory). This is privledge dropping, not full privsep.
@
text
@@


1.6
log
@afs cleanup, realloc strings, abort, etc.
testing by beck, hin, jose, fries. ok deraadt@@
@
text
@d278 1
d386 3
d395 2
@


1.5
log
@Merge
@
text
@d181 1
a181 1
		    abort();
d201 1
a201 1
	    abort();
a202 3



@


1.4
log
@merge
@
text
@d2 1
a2 1
 * Copyright (c) 1995 - 2000 Kungliga Tekniska Högskolan
d42 1
a42 1
RCSID("$KTH: arla.c,v 1.135.2.2 2001/09/14 13:26:31 lha Exp $") ;
d49 1
a49 1
     int error;
d51 6
a56 3
     error = rx_Init (htons(port));
     if (error)
	  arla_err (1, ADEBERROR, error, "rx_init");
d69 6
d77 2
a78 2
    unsigned *val;
    unsigned default_val;
d86 1
d93 1
a93 1
read_conffile(char *fname,
a100 3
    for (p = params; p->name; ++p)
	*(p->val) = p->default_val;

d117 1
a117 1
	unsigned val;
d121 2
a122 3
	if (buf[strlen(buf) - 1] == '\n')
	    buf[strlen(buf) - 1] = '\0';
	if (buf[0] == '#')
d137 1
a137 8
	val = parse_units(v, size_units, NULL);
	if(val == (unsigned)-1) {
	    val = strtol(v, &endptr, 0);
	    if (endptr == v)
		fprintf (stderr, "%s:%d: bad value `%s'\n",
			 fname, lineno, v);
	}
	    
d148 1
a148 3
	if (partial_match == 1)
	    *(partial_param->val) = val;
	else if (partial_match == 0)
d151 2
a152 1
	else
d155 51
d210 2
a211 1
#if KERBEROS && !defined(HAVE_KRB_GET_ERR_TEXT)
d226 2
d230 13
a242 2
static unsigned low_vnodes, high_vnodes, low_bytes, high_bytes;
static unsigned numcreds, numconns, numvols, dynrootlevel;
d245 16
a260 10
    {"low_vnodes",		&low_vnodes,	 ARLA_LOW_VNODES},
    {"high_vnodes",		&high_vnodes,	 ARLA_HIGH_VNODES},
    {"low_bytes",		&low_bytes,	 ARLA_LOW_BYTES},
    {"high_bytes",		&high_bytes,	 ARLA_HIGH_BYTES},
    {"numcreds",		&numcreds,	 ARLA_NUMCREDS},
    {"numconns",		&numconns,	 ARLA_NUMCREDS},
    {"numvols",			&numvols,	 ARLA_NUMVOLS},
    {"fpriority",               &fprioritylevel, FPRIO_DEFAULT},
    {"dynroot",                 &dynrootlevel,   DYNROOT_DEFAULT},
    {NULL,			NULL,		 0}};
d262 1
a262 1
char *conf_file = ARLACONFFILE;
a265 4
#ifdef KERBEROS
char *rxkad_level_string = "auth";
#endif
const char *temp_sysname = NULL;
d273 1
d348 1
a348 1
arla_init (int argc, char **argv)
d352 1
a352 12

    if (temp_sysname == NULL)
	temp_sysname = arla_getsysname ();

    if (temp_sysname != NULL)
        strlcpy(arlasysname, temp_sysname, SYSNAMEMAXLEN);

#ifdef KERBEROS
    conn_rxkad_level = parse_rxkad_level (rxkad_level_string);
    if (conn_rxkad_level < 0)
	errx (1, "bad rxkad level `%s'", rxkad_level_string);
#endif
d357 3
d383 6
d398 10
d422 2
d430 2
d451 1
a451 1
		"low_bytes = %u, high_bytes = %u",
d453 1
a453 1
		low_bytes, high_bytes);
@


1.3
log
@New Arla userland from Arla between 0.34.2 and current in arla cvs.
Too many new features and fixes to mention here.
@
text
@d17 1
a17 6
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by the Kungliga Tekniska
 *      Högskolan and its contributors.
 * 
 * 4. Neither the name of the Institute nor the names of its contributors
a38 1
#include <sl.h>
d42 1
a42 3
#include <arla-version.h>

RCSID("$Id: arla.c,v 1.129 2000/08/25 02:55:33 assar Exp $") ;
a45 488
/* creds used for all the interactive usage */

static CredCacheEntry *ce;

static VenusFid cwd;
static VenusFid rootcwd;

static int arla_chdir(int, char **);
static int arla_ls(int, char **);
static int arla_cat(int, char **);
static int arla_cp(int, char **);
static int arla_wc(int, char **);
static int help(int, char **);
static int arla_quit(int, char **);
static int arla_checkserver(int, char **);
static int arla_conn_status(int, char **);
static int arla_vol_status(int, char **);
static int arla_cred_status(int, char **);
static int arla_fcache_status(int, char **);
static int arla_sysname(int, char**);
#ifdef RXDEBUG
static int arla_rx_status(int argc, char **argv);
#endif
static int arla_flushfid(int argc, char **argv);

static SL_cmd cmds[] = {
    {"chdir", arla_chdir, "chdir directory"},
    {"cd"},
    {"ls",    arla_ls, "ls"},
    {"cat",   arla_cat, "cat file"},
    {"cp",    arla_cp, "copy file"},
    {"wc",    arla_wc, "wc file"},
    {"help",  help, "help"},
    {"?"},
    {"checkservers", arla_checkserver, "poll servers are down"},
    {"conn-status", arla_conn_status, "connection status"},
    {"vol-status", arla_vol_status, "volume cache status"},
    {"cred-status", arla_cred_status, "credentials status"},
    {"fcache-status", arla_fcache_status, "file cache status"},
#ifdef RXDEBUG
    {"rx-status", arla_rx_status, "rx connection status"},
#endif
    {"flushfid", arla_flushfid, "flush a fid from the cache"},
    {"quit", arla_quit, "quit"},
    {"exit"},
    {"sysname", arla_sysname, "sysname"},
    { NULL }
};

/* An emulation of kernel lookup, convert (startdir, fname) into
 * (startdir).  Strips away leading /afs, removes duobles slashes,
 * and resolves symlinks.
 * Return 0 for success, otherwise -1.
 */

static int
walk (VenusFid *startdir, char *fname)
{
     VenusFid cwd = *startdir;
     char *base;
     VenusFid file;
     Result ret;
     FCacheEntry *entry;
     int error;
     char symlink[MAXPATHLEN];
     char store_name[MAXPATHLEN];

     strlcpy(store_name, fname, sizeof(store_name));
     fname = store_name;

     do {
        /* set things up so that fname points to the remainder of the path,
         * whereas base points to the whatever preceeds the first /
         */
        base = fname;
        fname = strchr(fname, '/');
        if (fname) {
            /* deal with repeated adjacent / chars by eliminating the
             * duplicates. 
             */
            while (*fname == '/') {
                *fname = '\0';
                fname++;
            }
        }
 
        /* deal with absolute pathnames first. */
        if (*base == '\0') {
            cwd = rootcwd;
            if (fname) {
                if (strncmp("afs",fname,3) == 0) {
                    fname += 3;
                }
                continue;
            } else {
                break;
            }
	 }
	 ret = cm_lookup (&cwd, base, &file, &ce, TRUE);
	 if (ret.res) {
	     arla_warn (ADEBWARN, ret.error, "lookup(%s)", base);
	     return -1;
	 }
	 error = fcache_get_data (&entry, &file, &ce);
	 if (error) {
	     arla_warn (ADEBWARN, error, "fcache_get");
	     return -1;
	 }

	 /* handle symlinks here */
	 if (entry->status.FileType == TYPE_LINK) {
	     int len;
	     int fd;

	     fd = fcache_open_file (entry, O_RDONLY);
	     /* read the symlink and null-terminate it */
	     if (fd < 0) {
		 fcache_release(entry);
		 arla_warn (ADEBWARN, errno, "fcache_open_file");
		 return -1;
	     }
	     len = read (fd, symlink, sizeof(symlink));
	     close (fd);
	     if (len <= 0) {
		 fcache_release(entry);
		 arla_warnx (ADEBWARN, "cannot read symlink");
		 return -1;
	     }
	     symlink[len] = '\0';
	     /* if we're not at the end (i.e. fname is not null), take
	      * the expansion of the symlink and append fname to it.
	      */
	     if (fname != NULL) {
		 strcat (symlink, "/");
		 strcat (symlink, fname);
	     }
	     strlcpy(store_name, symlink, sizeof(store_name));
	     fname = store_name;
	 } else {
	     /* if not a symlink, just update cwd */
	     cwd = file;
	 }
	 fcache_release(entry);

	 /* the *fname condition below deals with a trailing / in a
	  * path-name */
     } while (fname != NULL && *fname);
     *startdir = cwd;
     return 0;
}

static int
arla_quit (int argc, char **argv)
{
    printf("Thank you for using arla\n");
    return 1;
}

static int
arla_flushfid(int argc, char **argv)
{
    AFSCallBack broken_callback = {0, 0, CBDROPPED};
    VenusFid fid;
    
    if (argc != 2) {
	fprintf(stderr, "flushfid fid\n");
	return 0;
    }
    
    if ((sscanf(argv[1], "%d.%d.%d.%d", &fid.Cell, &fid.fid.Volume, 
		&fid.fid.Vnode, &fid.fid.Unique)) == 4) {
	;
    } else if ((sscanf(argv[1], "%d.%d.%d", &fid.fid.Volume, 
		       &fid.fid.Vnode, &fid.fid.Unique)) == 3) {
	fid.Cell = cwd.Cell;
    } else {
	fprintf(stderr, "flushfid fid\n");
	return 0;
    }
    
    fcache_stale_entry(fid, broken_callback);
    
    return 0;
}


static int
arla_chdir (int argc, char **argv)
{
    if (argc != 2) {
	printf ("usage: %s dir\n", argv[0]);
	return 0;
    }

    if(walk (&cwd, argv[1]))
	printf ("walk %s failed\n", argv[1]);
    return 0;
}

static void
print_dir (VenusFid *fid, const char *name, void *v)
{
     printf("(%d, %d, %d, %d): %s\n", fid->Cell,
	    fid->fid.Volume,
	    fid->fid.Vnode,
	    fid->fid.Unique, name);
}

struct ls_context {
    VenusFid *dir_fid;
    CredCacheEntry *ce;
};

static void
print_dir_long (VenusFid *fid, const char *name, void *v)
{
    Result res;
    int ret;
    AFSFetchStatus status;
    VenusFid realfid;
    AccessEntry *ae;
    struct ls_context *context = (struct ls_context *)v;
    char type;
    CredCacheEntry *ce = context->ce;
    VenusFid *dir_fid  = context->dir_fid;
    char timestr[20];
    struct tm *t;
    time_t ti;

    if (VenusFid_cmp(fid, dir_fid) == 0)
	return;

    ret = followmountpoint (fid, dir_fid, &ce);
    if (ret) {
	printf ("follow %s: %d\n", name, ret);
	return;
    }

    res = cm_getattr (*fid, &status, &realfid, context->ce, &ae);
    if (res.res) {
	printf ("%s: %d\n", name, res.res);
	return;
    }

    switch (status.FileType) {
    case TYPE_FILE :
	type = '-';
	break;
    case TYPE_DIR :
	type = 'd';
	break;
    case TYPE_LINK :
	type = 'l';
	break;
    default :
	abort ();
    }

    printf("(%4d, %8d, %8d, %8d): ",
	   fid->Cell,
	   fid->fid.Volume,
	   fid->fid.Vnode,
	   fid->fid.Unique);

    ti = status.ClientModTime;
    t = localtime (&ti);
    strftime (timestr, sizeof(timestr), "%Y-%m-%d", t);
    printf ("%c%c%c%c%c%c%c%c%c%c %2d %6d %6d %8d %s ",
	    type,
	    status.UnixModeBits & 0x100 ? 'w' : '-',
	    status.UnixModeBits & 0x080 ? 'r' : '-',
	    status.UnixModeBits & 0x040 ? 'x' : '-',
	    status.UnixModeBits & 0x020 ? 'w' : '-',
	    status.UnixModeBits & 0x010 ? 'r' : '-',
	    status.UnixModeBits & 0x008 ? 'x' : '-',
	    status.UnixModeBits & 0x004 ? 'w' : '-',
	    status.UnixModeBits & 0x002 ? 'r' : '-',
	    status.UnixModeBits & 0x001 ? 'x' : '-',
	    status.LinkCount,
	    status.Owner,
	    status.Group,
	    status.Length,
	    timestr);

    printf ("v %d ", status.DataVersion);

    printf ("%s\n", name);
}

static int
arla_ls (int argc, char **argv)
{
    struct getargs args[] = {
	{NULL, 'l', arg_flag, NULL},
	{NULL, 0,   arg_end,  NULL}
    };
    int l_flag = 0;
    int error;
    int optind = 0;
    struct ls_context context;

    args[0].value = &l_flag;

    if (getarg (args, argc, argv, &optind, ARG_SHORTARG)) {
	arg_printusage (args, "ls", NULL, ARG_SHORTARG);
	return 0;
    }
    context.dir_fid = &cwd;
    context.ce      = ce;
    error = adir_readdir (&cwd, l_flag ? print_dir_long : print_dir,
			  &context, &ce);
    if (error)
	printf ("adir_readdir failed: %s\n", koerr_gettext(error));
    return 0;
}

static int
arla_sysname (int argc, char **argv)
{
    switch (argc) {
    case 1:
	printf("sysname: %s\n", arlasysname);
	break;
    case 2:
	strlcpy(arlasysname, argv[1], SYSNAMEMAXLEN);
	printf("setting sysname to: %s\n", arlasysname);
	break;
    default:
	printf("syntax: sysname <sysname>\n");
	break;
    }
    return 0;
}


static int
arla_cat_et_wc (int argc, char **argv, int do_cat, int out_fd)
{
    VenusFid fid;
    int fd;
    char buf[8192];
    int ret;
    FCacheEntry *e;
    size_t size = 0;
    
    if (argc != 2) {
	printf ("usage: %s file\n", argv[0]);
	return 0;
    }
    fid = cwd;
    if(walk (&fid, argv[1]) == 0) {

	ret = fcache_get_data (&e, &fid, &ce);
	if (ret) {
	    printf ("fcache_get_data failed: %d\n", ret);
	    return 0;
	}

	fd = fcache_open_file (e, O_RDONLY);

	if (fd < 0) {
	    fcache_release(e);
	    printf ("fcache_open_file failed: %d\n", errno);
	    return 0;
	}
	while ((ret = read (fd, buf, sizeof(buf))) > 0) {
	    if(do_cat)
		write (out_fd, buf, ret);
	    else
		size += ret;
	}
	if(!do_cat)
	    printf("%lu %s\n", (unsigned long)size, argv[1]);
	close (fd);
	fcache_release(e);
    }
    return 0;
}

static int
arla_cat (int argc, char **argv)
{
    return arla_cat_et_wc(argc, argv, 1, STDOUT_FILENO);
}

static int
arla_cp (int argc, char **argv)
{
    char *nargv[3];
    int fd, ret;

    if (argc != 3) {
	printf ("usage: %s from-file to-file\n", argv[0]);
	return 0;
    }
    
    fd = open (argv[2], O_CREAT|O_WRONLY|O_TRUNC, 0600);
    if (fd < 0) {
	warn ("open");
	return 0;
    }	

    nargv[0] = argv[0];
    nargv[1] = argv[1];
    nargv[2] = NULL;

    ret = arla_cat_et_wc(argc-1, nargv, 1, fd);
    close (fd);
    return ret;
	
}

static int
arla_wc (int argc, char **argv)
{
    return arla_cat_et_wc(argc, argv, 0, -1);
}


static int
help (int argc, char **argv)
{
    sl_help(cmds, argc, argv);
    return 0;
}

static int
arla_checkserver (int argc, char **argv)
{
    u_int32_t hosts[12];
    int num = sizeof(hosts)/sizeof(hosts[0]);

    conn_downhosts(cwd.Cell, hosts, &num, 0);
    if (num < 0 || num > sizeof(hosts)/sizeof(hosts[0])) {
	fprintf (stderr, "conn_downhosts returned bogus num: %d\n", num);
	return 0;
    }
    if (num == 0) {
	printf ("no servers down in %s\n", cell_num2name(cwd.Cell));
    } else {
	while (num) {
	    struct in_addr in;
	    in.s_addr = hosts[num];
	    printf ("down: %s\n", inet_ntoa(in));
	    num--;
	}
    }
    
    return 0;
}

static int
arla_conn_status (int argc, char **argv)
{
    conn_status ();
    return 0;
}

static int
arla_vol_status (int argc, char **argv)
{
    volcache_status ();
    return 0;
}

static int
arla_cred_status (int argc, char **argv)
{
    cred_status ();
    return 0;
}

static int
arla_fcache_status (int argc, char **argv)
{
    fcache_status ();
    return 0;
}

#ifdef RXDEBUG
static int
arla_rx_status(int argc, char **argv)
{
    rx_PrintStats(stderr);
    return 0;
}
#endif

a55 21
#ifdef KERBEROS

static int
get_cred(const char *princ, const char *inst, const char *krealm, 
         CREDENTIALS *c)
{
  KTEXT_ST foo;
  int k_errno;

  k_errno = krb_get_cred((char*)princ, (char*)inst, (char*)krealm, c);

  if(k_errno != KSUCCESS) {
    k_errno = krb_mk_req(&foo, (char*)princ, (char*)inst, (char*)krealm, 0);
    if (k_errno == KSUCCESS)
      k_errno = krb_get_cred((char*)princ, (char*)inst, (char*)krealm, c);
  }
  return k_errno;
}


#endif /* KERBEROS */
d57 1
a57 7
#define KERNEL_STACKSIZE (16*1024)

/*
 *
 */

static void
a65 70
char *pid_filename;

static void
write_pid_file (const char *progname)
{
    FILE *fp;

    asprintf (&pid_filename, "/var/run/%s.pid", progname);
    if (pid_filename == NULL)
	return;
    fp = fopen (pid_filename, "w");
    if (fp == NULL)
	return;
    fprintf (fp, "%u", (unsigned)getpid());
    fclose (fp);
}

static void
delete_pid_file (void)
{
    if (pid_filename != NULL) {
	unlink (pid_filename);
	free (pid_filename);
	pid_filename = NULL;
    }
}

/*
 * signal handlers...
 */

static void
sigint (int foo)
{
    arla_warnx (ADEBMISC, "fatal signal received");
    store_state ();
    delete_pid_file ();
    exit (0);
}

static void
sighup (int foo)
{
    store_state ();
    delete_pid_file ();
}

static void
daemonify (void)
{
    pid_t pid;
    int fd;

    pid = fork ();
    if (pid < 0)
	arla_err (1, ADEBERROR, errno, "fork");
    else if (pid > 0)
	exit(0);
    if (setsid() == -1)
	arla_err (1, ADEBERROR, errno, "setsid");
    fd = open(_PATH_DEVNULL, O_RDWR, 0);
    if (fd < 0)
	arla_err (1, ADEBERROR, errno, "open " _PATH_DEVNULL);
    dup2 (fd, STDIN_FILENO);
    dup2 (fd, STDOUT_FILENO);
    dup2 (fd, STDERR_FILENO);
    if (fd > 2)
	    close (fd);
}

d193 4
a196 6
static int test_flag;
static char *conf_file = ARLACONFFILE;
static char *log_file  = NULL;
static char *device_file = "/dev/xfs0";
static char *debug_levels = NULL;
static char *connected_mode_string = NULL;
d198 1
a198 1
static char *rxkad_level_string = "auth";
d200 12
a211 11
static const char *temp_sysname = NULL;
static char *root_volume;
static char *cache_dir;
static int version_flag;
static int help_flag;
static int fork_flag = 1;
static int client_port = 4711;
static int recover = 0;
static int dynroot_enable = 0;
static int num_workers = 16;
static int usedbytes_consistency = 0;
d213 2
d216 5
d222 5
a226 42
static struct getargs args[] = {
    {"test",	't',	arg_flag,	&test_flag,
     "run in test mode", NULL},
    {"conffile", 'c',	arg_string,	&conf_file,
     "path to configuration file", "file"},
    {"usedbytes-consistency", 'b', arg_flag, &usedbytes_consistency,
     "if we want extra paranoid usedbytes consistency check", NULL },
    {"log",	'l',	arg_string,	&log_file,
     "where to write log (stderr (default), syslog, or path to file)", NULL},
    {"debug",	0,	arg_string,	&debug_levels,
     "what to write in the log", NULL},
    {"device",	'd',	arg_string,	&device_file,
     "the XFS device to use [/dev/xfs0]", "path"},
    {"connected-mode", 0, arg_string,	&connected_mode_string,
     "initial connected mode [conncted|fetch-only|disconnected]", NULL},
    {"dynroot", 'D', arg_flag,	&dynroot_enable,
     "if dynroot is enabled", NULL},
    {"fork",	'n',	arg_negative_flag,	&fork_flag,
     "don't fork and demonize", NULL},
#ifdef KERBEROS
    {"rxkad-level", 'r', arg_string,	&rxkad_level_string,
     "the rxkad level to use (clear, auth or crypt)", NULL},
#endif
    {"sysname",	 's',	arg_string,	&temp_sysname,
     "set the sysname of this system", NULL},
    {"root-volume",0,   arg_string,     &root_volume},
    {"port",	0,	arg_integer,	&client_port,
     "port number to use",	"number"},
    {"recover",	'z',	arg_negative_flag, &recover,
     "don't recover state",	NULL},
    {"cache-dir", 0,	arg_string,	&cache_dir,
     "cache directory",	"directory"},
    {"workers",	  0,	arg_integer,	&num_workers,
     "number of worker threads", NULL},
    {"fake-mp",	  0,	arg_flag,	&fake_mp,
     "enable fake mountpoints", NULL},
    {"version",	0,	arg_flag,	&version_flag,
     NULL, NULL},
    {"help",	0,	arg_flag,	&help_flag,
     NULL, NULL},
    {NULL,      0,      arg_end,        NULL, NULL, NULL}
};
a276 8
static void
usage (int ret)
{
    arg_printusage (args, NULL, "[device]", ARG_GNUSTYLE);
    exit (ret);
}


d282 1
a282 1
main (int argc, char **argv)
d284 1
a284 4
    PROCESS kernelpid;
    int error;
    int optind = 0;
    char *default_log_file;
a286 23
    set_progname (argv[0]);

    if (getarg (args, argc, argv, &optind, ARG_GNUSTYLE))
	usage (1);

    argc -= optind;
    argv += optind;

    if (help_flag)
	usage (0);

    if (version_flag)
	errx (1, "%s", arla_version);
    
    if (argc > 0) {
	device_file = *argv;
	argc--;
	argv++;
    }

    if (argc != 0)
	usage (1);

a298 11
    signal (SIGINT, sigint);
    signal (SIGTERM, sigint);
    signal (SIGHUP, sighup);
    umask (S_IRWXG|S_IRWXO); /* 077 */

    if (!test_flag && fork_flag) {
	default_log_file = "syslog";
    } else {
	default_log_file = "/dev/stderr";
    }

d302 4
a305 1
    arla_loginit(log_file);
d326 1
a326 1
	cache_dir = ARLACACHEDIR;
d353 1
a353 1
    cell_init (0);
d385 3
a387 3
    if (usedbytes_consistency) {
	arla_warnx(ADEBINIT, "turning on usedbytes consistency test");
	cm_turn_on_usedbytes_consistency();
a390 69

    if (test_flag) {
#ifdef KERBEROS
	{
	    krbstruct krbdata;
	    int ret;
	    char *realm;
	    const char *this_cell = cell_getthiscell ();
	    const char *db_server = cell_findnamedbbyname (this_cell);

	    if (db_server == NULL)
		arla_errx (1, ADEBERROR,
			   "no db server for cell %s", this_cell);
	    realm = krb_realmofhost (db_server);
	    
	    ret = get_cred("afs", this_cell, realm, &krbdata.c);
	    if (ret)
		ret = get_cred("afs", "", realm, &krbdata.c);

	    if (ret) {
		arla_warnx (ADEBWARN,
			    "getting ticket for %s: %s",
			    this_cell,
			    krb_get_err_text (ret));
	    } else if (cred_add_krb4(getuid(), getuid(), &krbdata.c) == NULL) {
		arla_warnx (ADEBWARN, "Could not insert tokens to arla");
	    }
	}
#endif

	ce = cred_get (cell_name2num(cell_getthiscell()), getuid(), CRED_ANY);
	 
	xfs_message_init ();
	kernel_opendevice ("null");

	arla_warnx (ADEBINIT, "Getting root...");
	error = getroot (&rootcwd, ce);
	if (error)
	    arla_err (1, ADEBERROR, error, "getroot");
	cwd = rootcwd;
	arla_warnx(ADEBINIT, "arla loop started");
	sl_loop(cmds, "arla> ");
	store_state ();
    } else {
	struct kernel_args kernel_args;

	xfs_message_init ();
	kernel_opendevice (device_file);

	kernel_args.num_workers = num_workers;

	if (LWP_CreateProcess (kernel_interface, KERNEL_STACKSIZE, 1,
			       (char *)&kernel_args,
			       "Kernel-interface", &kernelpid))
	    arla_errx (1, ADEBERROR,
		       "Cannot create kernel-interface process");
	if (fork_flag) {
	    daemonify ();
	    clock_ReInit ();
	}

	write_pid_file ("arlad");

	if (chroot (cache_dir) < 0)
	    arla_err (1, ADEBERROR, errno, "chroot %s", cache_dir);

	LWP_WaitProcess ((char *)main);
	abort ();
    }
@


1.2
log
@upgrade Arla to fresher code. Too many new features and bugfixes.
@
text
@a0 1
/*	$OpenBSD$	*/
d2 1
a2 1
 * Copyright (c) 1995, 1996, 1997, 1998, 1999 Kungliga Tekniska Högskolan
d48 1
a48 1
#include <version.h>
d50 1
a50 1
RCSID("$KTH: arla.c,v 1.101 1999/04/14 16:00:16 map Exp $") ;
d54 3
a56 1
static CredCacheEntry *tmpce;
d68 1
d88 1
d103 4
a106 11
static void
print_dir (VenusFid *fid, const char *name, void *v)
{
     printf("(%d, %d, %d, %d): %s\n", fid->Cell,
	    fid->fid.Volume,
	    fid->fid.Vnode,
	    fid->fid.Unique, name);
}

/*
 * Return 0 iff OK.
d110 1
a110 1
newwalk (VenusFid *startdir, char *fname)
d121 1
a121 1
     strcpy(store_name, fname);
d152 1
a152 1
	 ret = cm_lookup (cwd, base, &file, &tmpce);
d157 1
a157 1
	 error = fcache_get (&entry, file, tmpce);
a161 3
	 error = fcache_get_data (entry, tmpce);
	 if (error) {
	     fcache_release(entry);
a162 3
	     arla_warn (ADEBWARN, error, "fcache_get_data");
	     return -1;
	 }
d190 1
a190 1
	     strcpy(store_name,symlink);
d248 2
a249 1
    newwalk (&cwd, argv[1]);
d253 90
d346 5
d352 2
d355 11
a365 2
    error = adir_readdir (cwd, print_dir, NULL, tmpce);
    if (error) {
a366 1
    }
d378 1
a378 2
	strncpy(arlasysname, argv[1], SYSNAMEMAXLEN);
	arlasysname[SYSNAMEMAXLEN-1] = '\0';
d404 1
a404 1
    if( newwalk (&fid, argv[1]) == 0) {
d406 1
a406 6
	ret = fcache_get (&e, fid, tmpce);
	if (ret) {
	    printf ("fcache_get failed: %d\n", ret);
	    return 0;
	}
	ret = fcache_get_data (e, tmpce);
a407 1
	    fcache_release(e);
d481 25
d589 27
d625 1
d633 1
d772 1
a772 1
static unsigned numcreds, numconns, numvols;
d783 1
d800 1
a800 1
static int no_fork;
d802 2
a803 1
static int recover = 1;
d805 3
d813 3
a815 1
     "path to configuration file", NULL},
d821 1
a821 1
     "the XFS device to use [/dev/xfs0]", NULL},
d824 3
a826 1
    {"no-fork",	'n',	arg_flag,	&no_fork,
d836 1
a836 1
     "port number to use",	NULL},
d840 1
a840 1
     "cache directory",	NULL},
d843 2
d904 1
a904 4
    arg_printusage (args,
		    NULL,
		    "[device]",
		    0);
a944 3
    if (!no_fork)
	daemonify ();

d948 2
a949 4
    if (temp_sysname != NULL) {
        strncpy(arlasysname, temp_sysname, SYSNAMEMAXLEN - 1);
	arlasysname[SYSNAMEMAXLEN - 1] = '\0';
    }
d952 2
a953 2
    rxkad_min_level = parse_rxkad_level (rxkad_level_string);
    if (rxkad_min_level < 0)
d962 1
a962 1
    if (!test_flag && !no_fork) {
d994 2
a995 1
    mkdir (cache_dir, 0777);
d1000 3
d1028 1
a1028 1
		rxkad_level_units[rxkad_min_level]);
d1051 5
d1063 1
d1066 5
a1070 1
	    char *realm = krb_realmofhost (db_server);
d1087 1
a1087 1
	tmpce = cred_get (0, getuid(), CRED_ANY);
d1089 3
d1093 1
a1093 1
	error = getroot (&rootcwd, tmpce);
d1104 1
a1105 1
	kernel_args.device      = device_file;
d1113 9
@


1.1
log
@Initial revision
@
text
@a1 1
/*	$OpenBSD$	*/
d3 1
a3 1
 * Copyright (c) 1995, 1996, 1997, 1998 Kungliga Tekniska Högskolan
d51 1
a51 1
RCSID("$KTH: arla.c,v 1.87 1998/08/23 22:50:22 assar Exp $") ;
d63 2
d72 1
d74 1
d82 2
d90 1
d92 1
d168 1
a168 1
	     ReleaseWriteLock (&entry->lock);
d178 1
a178 1
	     fd = fcache_open_file (entry, O_RDONLY, 0);
d181 1
a181 1
		 ReleaseWriteLock(&entry->lock);
d188 1
a188 1
		 ReleaseWriteLock(&entry->lock);
d206 1
a206 1
	 ReleaseWriteLock (&entry->lock);
a293 1

d295 1
a295 1
arla_cat (int argc, char **argv)
d302 1
d318 1
a318 1
	    ReleaseWriteLock (&e->lock);
d323 1
a323 1
	fd = fcache_open_file (e, O_RDONLY, 0);
d326 1
a326 1
	    ReleaseWriteLock (&e->lock);
d331 4
a334 1
	    write (STDOUT_FILENO, buf, ret);
d336 2
d339 1
a339 1
	ReleaseWriteLock (&e->lock);
d345 40
d394 1
a394 1
    conn_status (stderr);
d401 1
a401 1
    volcache_status (stderr);
d408 1
a408 1
    cred_status (stderr);
d415 1
a415 1
    fcache_status (stderr);
d419 1
d426 1
a426 1

d462 4
d512 2
a513 1
    close (fd);
d611 17
d659 1
d689 2
d752 2
a753 1
		    "[device]");
d794 3
a844 3
    if (!test_flag && !no_fork)
	daemonify ();

d862 4
a865 2
    arla_warnx (ADEBINIT, "initports");
    initports ();
a875 2
    arla_warnx (ADEBINIT, "rx");
    initrx (client_port);
d921 1
a921 1
	    } else if (cred_add_krb4(getuid(), &krbdata.c) == NULL) {
d938 2
d942 3
d946 2
a947 1
			       device_file, "Kernel-interface", &kernelpid))
d950 1
@


1.1.1.1
log
@Initial version of Arla, a free implementation of an AFS cache-manager.
(second try, hopefully into the correct repository this time)
@
text
@@


1.1.1.2
log
@Import of arla-0.35.7
@
text
@d1 2
d4 1
a4 1
 * Copyright (c) 1995 - 2000 Kungliga Tekniska Högskolan
d19 6
a24 1
 * 3. Neither the name of the Institute nor the names of its contributors
d46 1
d50 3
a52 1
RCSID("$KTH: arla.c,v 1.135.2.2 2001/09/14 13:26:31 lha Exp $") ;
d56 319
d385 21
d407 3
a409 1
void
d418 40
a552 17
#if KERBEROS && !defined(HAVE_KRB_GET_ERR_TEXT)

#ifndef MAX_KRB_ERRORS
#define MAX_KRB_ERRORS 256
#endif

static const char err_failure[] = "Unknown error code passed (krb_get_err_text)";

const char *
krb_get_err_text(int code)
{
  if(code < 0 || code >= MAX_KRB_ERRORS)
    return err_failure;
  return krb_err_txt[code];
}
#endif

d554 1
a554 1
static unsigned numcreds, numconns, numvols, dynrootlevel;
a564 1
    {"dynroot",                 &dynrootlevel,   DYNROOT_DEFAULT},
d567 33
a599 4
char *conf_file = ARLACONFFILE;
char *log_file  = NULL;
char *debug_levels = NULL;
char *connected_mode_string = NULL;
d601 2
a602 1
char *rxkad_level_string = "auth";
d604 15
a618 27
const char *temp_sysname = NULL;
char *root_volume;
int cpu_usage;
int version_flag;
int help_flag;
int recover = 0;
int dynroot_enable = 0;
int cm_consistency = 0;

/*
 * These are exported to other modules
 */

int num_workers = 16;
char *cache_dir;
int fake_mp;
int fork_flag = 1;

/*
 * Global AFS variables, se arla_local.h for comment
 */

int afs_BusyWaitPeriod = 15;

/*
 *
 */
d669 10
d684 1
a684 1
arla_init (int argc, char **argv)
d686 4
a689 1
    log_flags log_flags;
d692 23
d718 4
a721 2
    if (temp_sysname != NULL)
        strlcpy(arlasysname, temp_sysname, SYSNAMEMAXLEN);
d724 2
a725 2
    conn_rxkad_level = parse_rxkad_level (rxkad_level_string);
    if (conn_rxkad_level < 0)
d729 11
d743 1
a743 4
    log_flags = 0;
    if (cpu_usage)
	log_flags |= LOG_CPU_USAGE;
    arla_loginit(log_file, log_flags);
d763 3
d767 1
a767 1
	cache_dir = get_default_cache_dir();
d769 1
a769 2
    if (mkdir (cache_dir, 0777) < 0 && errno != EEXIST)
	arla_err (1, ADEBERROR, errno, "mkdir %s", cache_dir);
a773 3
    if (dynrootlevel || dynroot_enable)
	dynroot_setenable (TRUE);

d783 2
a784 4
    arla_warnx (ADEBINIT, "ports_init");
    ports_init ();
    arla_warnx (ADEBINIT, "rx");
    initrx (client_port);
d788 1
a788 1
    cell_init (0, arla_log_method);
d795 2
d799 1
a799 1
		rxkad_level_units[conn_rxkad_level]);
d822 45
a866 3
    if (cm_consistency) {
	arla_warnx(ADEBINIT, "turning on consistency test");
	cm_turn_on_consistency_check();
a867 2

    arla_warnx(ADEBINIT, "arla init done.");
@


1.1.1.3
log
@Import of arla -current as of Aug 5 2003

ok todd@@ deraadt@@
@
text
@d2 1
a2 1
 * Copyright (c) 1995 - 2003 Kungliga Tekniska Högskolan
d42 1
a42 1
RCSID("$arla: arla.c,v 1.163 2003/06/10 16:25:07 lha Exp $") ;
d49 1
a49 1
    int error;
d51 3
a53 6
    if (port == 0)
	port = afscallbackport;

    error = rx_Init (htons(port));
    if (error)
	arla_err (1, ADEBERROR, error, "rx_init");
a65 6
typedef enum { CONF_PARAM_INT, 
	       CONF_PARAM_STR,
	       CONF_PARAM_BOOL,
	       CONF_PARAM_INT64
} conf_type;

d68 2
a69 2
    conf_type type;
    void *val;
a76 1
    { "G", 1024 * 1024 * 1024 },
d83 1
a83 1
read_conffile(const char *fname,
d91 3
d110 1
a110 1
	int64_t val;
d114 3
a116 2
	buf[strcspn(buf, "\n")] = '\0';
	if (buf[0] == '\0' || buf[0] == '#')
d131 8
a138 1
    
d149 3
a151 1
	if (partial_match == 0) {
d154 1
a154 2
	    continue;
	} else if (partial_match != 1) {
a156 51
	    continue;
	}

	p = partial_param;

	switch (p->type) {
	case CONF_PARAM_INT:
	case CONF_PARAM_INT64:

	    val = parse_units(v, size_units, NULL);
	    if(val == -1 || val < 0) {
#ifdef HAVE_STRTOLL
		val = strtoll(v, &endptr, 0);
#else
		val = strtol(v, &endptr, 0);
#endif
		if (*endptr != '\0')
		    fprintf (stderr, "%s:%d: bad value `%s'\n",
			     fname, lineno, v);
	    }

	    if (p->type == CONF_PARAM_INT)
		    *((unsigned *)partial_param->val) = val;
	    else if (p->type == CONF_PARAM_INT64)
		    *((int64_t *)partial_param->val) = val;
	    else
		    abort();
	    break;

	case CONF_PARAM_STR:

	    *((char **)partial_param->val) = strdup(v);
	    
	    break;

	case CONF_PARAM_BOOL:

	    if (strcasecmp(v, "yes") == 0 || strcasecmp(v, "true") == 0)
		*((unsigned *)partial_param->val) = 1;
	    else if (strcasecmp(v, "no") == 0 || strcasecmp(v, "false") == 0)
		*((unsigned *)partial_param->val) = 0;
	    else
		fprintf (stderr, "%s:%d: bad boolean value `%s'\n",
			 fname, lineno, v);
	    break;
	default:
	    abort();
	}



d161 1
a161 2
#ifdef HAVE_KRB4
#ifndef HAVE_KRB_GET_ERR_TEXT
a175 2

#endif
d178 2
a179 13
static unsigned low_vnodes	= ARLA_LOW_VNODES;
static unsigned high_vnodes	= ARLA_HIGH_VNODES;
static int64_t low_bytes	= ARLA_LOW_BYTES;
static int64_t high_bytes	= ARLA_HIGH_BYTES;
static unsigned numcreds	= ARLA_NUMCREDS;
static unsigned numconns	= ARLA_NUMCONNS;
static unsigned numvols		= ARLA_NUMVOLS;
static unsigned dynrootlevel	= DYNROOT_DEFAULT;
static char *conf_sysname	= NULL;	/* sysname from conf file */
const char *argv_sysname	= NULL; /* sysname from argv */
#ifdef KERBEROS
const char *rxkad_level_string = "crypt";
#endif
d182 10
a191 16
    {"dynroot",			CONF_PARAM_BOOL,	&dynrootlevel},
    {"fake_stat",		CONF_PARAM_BOOL,	&fake_stat},
    {"fetch_block",		CONF_PARAM_INT,		&fetch_block_size},
    {"low_vnodes",		CONF_PARAM_INT,		&low_vnodes},
    {"high_vnodes",		CONF_PARAM_INT,		&high_vnodes},
    {"low_bytes",		CONF_PARAM_INT64,	&low_bytes},
    {"high_bytes",		CONF_PARAM_INT64,	&high_bytes},
    {"numcreds",		CONF_PARAM_INT,		&numcreds},
    {"numconns",		CONF_PARAM_INT,		&numconns},
    {"numvols",			CONF_PARAM_INT,		&numvols},
    {"sysname",			CONF_PARAM_STR,		&conf_sysname},
#ifdef KERBEROS
    {"rxkad-level",		CONF_PARAM_STR,		&rxkad_level_string},
#endif
    { NULL }
};
d193 1
a193 1
const char *conf_file = ARLACONFFILE;
d197 4
a207 1
int fake_stat = 0;
d282 1
a282 1
arla_init (void)
d286 12
a297 1
    const char *temp_sysname;
a301 3
    if (strcmp(log_file, "syslog") == 0)
	log_file = "syslog:no-delay";

a324 6
#ifdef KERBEROS
    conn_rxkad_level = parse_rxkad_level (rxkad_level_string);
    if (conn_rxkad_level < 0)
	errx (1, "bad rxkad level `%s'", rxkad_level_string);
#endif

a333 10
    if (argv_sysname)
	temp_sysname = argv_sysname;
    else if (conf_sysname)
	temp_sysname = conf_sysname;
    else
	temp_sysname = arla_getsysname ();

    if (temp_sysname != NULL)
	fcache_setdefsysname(temp_sysname);

a347 2
    arla_warnx (ADEBINIT, "uae_init");
    uae_init ();
a353 2
    arla_warnx (ADEBINIT, "poller");
    poller_init();
d373 1
a373 1
		"low_bytes = %ld, high_bytes = %ld",
d375 1
a375 1
		(long)low_bytes, (long)high_bytes);
@


