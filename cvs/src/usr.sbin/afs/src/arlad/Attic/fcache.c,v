head	1.10;
access;
symbols
	OPENBSD_5_2:1.9.0.30
	OPENBSD_5_2_BASE:1.9
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.28
	OPENBSD_5_0:1.9.0.26
	OPENBSD_5_0_BASE:1.9
	OPENBSD_4_9:1.9.0.24
	OPENBSD_4_9_BASE:1.9
	OPENBSD_4_8:1.9.0.22
	OPENBSD_4_8_BASE:1.9
	OPENBSD_4_7:1.9.0.18
	OPENBSD_4_7_BASE:1.9
	OPENBSD_4_6:1.9.0.20
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.9.0.16
	OPENBSD_4_5_BASE:1.9
	OPENBSD_4_4:1.9.0.14
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3:1.9.0.12
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.9.0.10
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.9.0.8
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.9.0.6
	OPENBSD_4_0_BASE:1.9
	OPENBSD_3_9:1.9.0.4
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.9.0.2
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.8.0.6
	OPENBSD_3_7_BASE:1.8
	OPENBSD_3_6:1.8.0.4
	OPENBSD_3_6_BASE:1.8
	OPENBSD_3_5:1.8.0.2
	OPENBSD_3_5_BASE:1.8
	OPENBSD_3_4:1.6.0.2
	OPENBSD_3_4_BASE:1.6
	arla-20030805:1.1.1.3
	OPENBSD_3_3:1.5.0.4
	OPENBSD_3_3_BASE:1.5
	OPENBSD_3_2:1.5.0.2
	OPENBSD_3_2_BASE:1.5
	arla-0-35-7:1.1.1.2
	OPENBSD_3_1:1.3.0.8
	OPENBSD_3_1_BASE:1.3
	OPENBSD_3_0:1.3.0.6
	OPENBSD_3_0_BASE:1.3
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_9:1.3.0.4
	OPENBSD_2_8:1.3.0.2
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.2.0.4
	OPENBSD_2_7_BASE:1.2
	OPENBSD_2_6:1.2.0.2
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.1.1.1.0.4
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.2
	OPENBSD_2_4_BASE:1.1.1.1
	arla-0_9:1.1.1.1
	arla:1.1.1;
locks; strict;
comment	@ * @;


1.10
date	2012.08.23.06.21.50;	author deraadt;	state dead;
branches;
next	1.9;

1.9
date	2005.05.02.17.51.36;	author moritz;	state Exp;
branches;
next	1.8;

1.8
date	2004.02.27.19.17.36;	author beck;	state Exp;
branches;
next	1.7;

1.7
date	2003.12.16.20.13.55;	author beck;	state Exp;
branches;
next	1.6;

1.6
date	2003.08.05.08.42.41;	author hin;	state Exp;
branches;
next	1.5;

1.5
date	2002.06.07.05.05.15;	author hin;	state Exp;
branches;
next	1.4;

1.4
date	2002.06.07.04.28.57;	author hin;	state Exp;
branches;
next	1.3;

1.3
date	2000.09.11.14.40.42;	author art;	state Exp;
branches;
next	1.2;

1.2
date	99.04.30.01.59.07;	author art;	state Exp;
branches;
next	1.1;

1.1
date	98.09.14.21.52.56;	author art;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.09.14.21.52.56;	author art;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.06.07.04.14.23;	author hin;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2003.08.05.08.21.00;	author hin;	state Exp;
branches;
next	;


desc
@@


1.10
log
@the afs src tree can go away
@
text
@/*
 * Copyright (c) 1995 - 2003 Kungliga Tekniska Högskolan
 * (Royal Institute of Technology, Stockholm, Sweden).
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * This is the cache for files.
 * The hash-table is keyed with (cell, volume, fid).
 */

#include "arla_local.h"
RCSID("$arla: fcache.c,v 1.417 2003/04/08 00:38:09 mattiasa Exp $") ;

#ifdef __CYGWIN32__
#include <windows.h>
#endif

/*
 * Prototypes
 */

static int get_attr_bulk (FCacheEntry *parent_entry, 
			  FCacheEntry *prefered_entry,
			  VenusFid *prefered_fid,
			  const char *prefered_name,
			  CredCacheEntry *ce);

static int
resolve_mp (FCacheEntry **e, VenusFid *ret_fid, CredCacheEntry **ce);

/*
 * Local data for this module.
 */

/*
 * Hash table for all the vnodes known by the cache manager keyed by
 * (cell, volume, vnode, unique).
 */

static Hashtab *hashtab;

/*
 * List of all hash table entries. This list is sorted in LRU-order.
 * The head is the MRU and the tail the LRU, which is from where we
 * take entries when we need to add new ones.
 */

static List *lrulist;

/*
 * Heap of entries to be invalidated.
 */

static Heap *invalid_heap;

/* low and high-water marks for vnodes and space */

static u_long highvnodes, lowvnodes, current_vnodes;
static int64_t highbytes, lowbytes;

/* current values */

static int64_t usedbytes, needbytes;
static u_long usedvnodes;

/* Map with recovered nodes */

static u_long maxrecovered;

static char *recovered_map;

static void
set_recovered(u_long index)
{
    char *p;
    u_long oldmax;

    if (index >= maxrecovered) {
	oldmax = maxrecovered;
	maxrecovered = (index + 16) * 2;
	p = realloc(recovered_map, maxrecovered);
	if (p == NULL) {
	    u_long m = maxrecovered;
	    free(recovered_map);
	    recovered_map = NULL; 
	    maxrecovered = 0;
	    arla_errx(1, ADEBERROR, "fcache: realloc %lu recovered_map failed",
		      m);
	}
	recovered_map = p;
	memset(recovered_map + oldmax, 0, maxrecovered - oldmax);
    }
    recovered_map[index] = 1;
}

#define IS_RECOVERED(index) (recovered_map[(index)])

/* 
 * This is how far the cleaner will go to clean out entries.
 * The higher this is, the higher is the risk that you will
 * lose any file that you feel is important to disconnected
 * operation. 
 */

Bool fprioritylevel = FPRIO_DEFAULT;

static int node_count;		/* XXX */

/*
 * This is set to non-zero when we want to use bulkstatus().  2 means
 * that the nodes should be installed into the kernel.
 */

static int fcache_enable_bulkstatus = 1;
static int fcache_bulkstatus_num = 14; /* XXX should use the [P]MTU */

#define FCHASHSIZE 997

/*
 * The cleaner
 */

#define CLEANER_STACKSIZE (16*1024)
#define CLEANER_SLEEP 10

static PROCESS cleaner_pid;

/*
 * The creator of nodes.
 */

#define CREATE_NODES_STACKSIZE (16*1024)

static PROCESS create_nodes_pid;

/*
 * The invalidator
 */

#define INVALIDATOR_STACKSIZE (16*1024)

static PROCESS invalidator_pid;

/*
 * Smalltalk emulation
 */

int64_t
fcache_highbytes(void)
{
    return highbytes;
}

int64_t
fcache_usedbytes(void)
{
    return usedbytes;
}

int64_t
fcache_lowbytes(void)
{
    return lowbytes;
}

u_long
fcache_highvnodes(void)
{
    return highvnodes;
}

u_long
fcache_usedvnodes(void)
{
    return usedvnodes;
}

u_long
fcache_lowvnodes(void)
{
    return lowvnodes;
}

/*
 * Counters
 */

static struct {
    unsigned long fetch_attr;
    unsigned long fetch_attr_cached;
    unsigned long fetch_attr_bulk;
    unsigned long fetch_data;
    unsigned long fetch_data_cached;
    unsigned long store_attr;
    unsigned long store_data;
} fcache_counter;

/*
 * Compare two entries. Return 0 if and only if the same.
 */

static int
fcachecmp (void *a, void *b)
{
    FCacheEntry *f1 = (FCacheEntry*)a;
    FCacheEntry *f2 = (FCacheEntry*)b;

    return VenusFid_cmp(&f1->fid, &f2->fid);
}

/*
 * Hash the value of an entry.
 */

static unsigned
fcachehash (void *e)
{
    FCacheEntry *f = (FCacheEntry*)e;

    return f->fid.Cell + f->fid.fid.Volume + f->fid.fid.Vnode 
	+ f->fid.fid.Unique;
}

/*
 * Compare expiration times.
 */

static int
expiration_time_cmp (const void *a, const void *b)
{
    const FCacheEntry *f1 = (const FCacheEntry *)a;
    const FCacheEntry *f2 = (const FCacheEntry *)b;

    return f1->callback.ExpirationTime - f2->callback.ExpirationTime;
}

void
recon_hashtabadd(FCacheEntry *entry)
{
    hashtabadd(hashtab,entry);
}
 
void
recon_hashtabdel(FCacheEntry *entry)
{
    hashtabdel(hashtab,entry);
}

/*
 * Globalnames 
 */

char **sysnamelist = NULL;
int sysnamenum = 0;

/*
 *
 */

static void
fcache_poller_unref(FCacheEntry *e)
{
    AssertExclLocked(&e->lock);

    if (e->poll) {
	poller_remove(e->poll);
	e->poll = NULL;
    }
}

static void
fcache_poller_reref(FCacheEntry *e, ConnCacheEntry *conn)
{
    PollerEntry *pe = e->poll;
    AssertExclLocked(&e->lock);

    e->poll = poller_add_conn(conn);
    if (pe)
	poller_remove(pe);
}


/*
 *
 */

const char *
fcache_getdefsysname (void)
{
    if (sysnamenum == 0)
	return "fool-dont-remove-all-sysnames";
    return sysnamelist[0];
}

/*
 *
 */

int
fcache_setdefsysname (const char *sysname)
{
    if (sysnamenum == 0)
	return fcache_addsysname (sysname);
    free (sysnamelist[0]);
    sysnamelist[0] = estrdup (sysname);
    return 0;
}

/*
 *
 */

int
fcache_addsysname (const char *sysname)
{
    sysnamenum += 1;
    sysnamelist = erealloc (sysnamelist, 
			    sysnamenum * sizeof(char *));
    sysnamelist[sysnamenum - 1] = estrdup(sysname);
    return 0;
}

/*
 *
 */

int
fcache_removesysname (const char *sysname)
{
    int i;
    for (i = 0; i < sysnamenum; i++)
	if (strcmp (sysnamelist[i], sysname) == 0)
	    break;
    if (i == sysnamenum)
	return 1;
    free (sysnamelist[i]);
    for (;i < sysnamenum; i++)
	sysnamelist[i] = sysnamelist[i + 1];
    sysnamenum--;
    sysnamelist = erealloc (sysnamelist, 
			    sysnamenum * sizeof(char *));
    return 0;
}

/*
 * return the directory name of the cached file for `entry'
 */

int
fcache_dir_name (FCacheEntry *entry, char *s, size_t len)
{
    return snprintf (s, len, "%02X", entry->index / 0x100);
}

/*
 * return the file name of the cached file for `entry'.
 */

int
fcache_file_name (FCacheEntry *entry, char *s, size_t len)
{
    return snprintf (s, len, "%02X/%02X",
		     entry->index / 0x100, entry->index % 0x100);
}

/*
 * return kernel version of path to the cache file for `entry'.
 */

int
fcache_conv_file_name (FCacheEntry *entry, char *s, size_t len)
{
#ifdef __CYGWIN32__
    char buf[1024];
    GetCurrentDirectory(1024, buf);

    return snprintf (s, len, "%s\\%02X\\%02X",
		     buf, entry->index / 0x100, entry->index % 0x100);
#else
    return snprintf (s, len, "%02X/%02X",
		     entry->index / 0x100, entry->index % 0x100);
#endif
}

/*
 * the filename for the extra (converted) directory
 */

static int
real_extra_file_name (FCacheEntry *entry, char *s, size_t len)
{
    int ret;

    ret = fcache_file_name (entry, s, len - 1);
    if (ret < len - 1) {
	s[ret++] = '@@';
	s[ret]   = '\0';
    }
    return ret;
}

/*
 * return the file name of the converted directory for `entry'.
 */

int
fcache_extra_file_name (FCacheEntry *entry, char *s, size_t len)
{
    assert (entry->flags.extradirp &&
	    entry->status.FileType == TYPE_DIR);

    return real_extra_file_name (entry, s, len);
}

static int fhopen_working;

/*
 * open file by handle
 */

static int
fcache_fhopen (fcache_cache_handle *handle, int flags)
{
    if (!handle->valid) {
	errno = EINVAL;
	return -1;
    }

#ifdef __CYGWIN32__
    return -1;
#endif

#if defined(HAVE_GETFH) && defined(HAVE_FHOPEN)
    {
	int ret;
	fhandle_t fh;

	memcpy (&fh, &handle->nnpfs_handle, sizeof(fh));
	ret = fhopen (&fh, flags);
	if (ret >= 0)
	    return ret;
    }
#endif

#ifdef KERBEROS			/* really KAFS */
    {
	struct ViceIoctl vice_ioctl;
	
	vice_ioctl.in      = (caddr_t)&handle->nnpfs_handle;
	vice_ioctl.in_size = sizeof(handle->nnpfs_handle);
	
	vice_ioctl.out      = NULL;
	vice_ioctl.out_size = 0;
	
	return k_pioctl (NULL, VIOC_FHOPEN, &vice_ioctl, flags);
    }
#else
    errno = EINVAL;
    return -1;
#endif
}

/*
 * get the handle of `filename'
 */

int
fcache_fhget (char *filename, fcache_cache_handle *handle)
{
    handle->valid = 0;

#ifdef __CYGWIN32__
    {
	int ret, a, b;
	char buf[1024]; /* XXX */

	ret = sscanf(filename, "%02X/%02X", &a, &b);
	if (ret != 2)
	    return EINVAL;

	GetCurrentDirectory(1024, buf);
	
	ret = snprintf ((char *)handle, CACHEHANDLESIZE,
	    "%s\\%02X\\%02X", buf, a, b);

	if (ret > 0 && ret < CACHEHANDLESIZE)
	    handle->valid = 1;

	return ret;
    }
#endif

#if defined(HAVE_GETFH) && defined(HAVE_FHOPEN)
    {
	int ret;
	fhandle_t fh;

	ret = getfh (filename, &fh);
	if (ret == 0) {
	    memcpy (&handle->nnpfs_handle, &fh, sizeof(fh));
	    handle->valid = 1;
	}

	return ret;
    }
#endif
#ifdef KERBEROS
    {
	struct ViceIoctl vice_ioctl;
	int ret;
	
	if (!fhopen_working)
	    return 0;
	
	vice_ioctl.in      = NULL;
	vice_ioctl.in_size = 0;
	
	vice_ioctl.out      = (caddr_t)&handle->nnpfs_handle;
	vice_ioctl.out_size = sizeof(handle->nnpfs_handle);
	
	ret = k_pioctl (filename, VIOC_FHGET, &vice_ioctl, 0);
	if (ret == 0)
	    handle->valid = 1;

	return ret;
    }
#else
    errno = EINVAL;
    return -1;
#endif
}

/*
 * create a new cache vnode, assume the entry is locked or private
 */

static int
fcache_create_file (FCacheEntry *entry, int create)
{
    char fname[MAXPATHLEN];
    char extra_fname[MAXPATHLEN];
    int fd;
    int ret;
    int flags;

    flags = O_RDWR | O_BINARY;

    if (create)
	flags |= O_CREAT | O_TRUNC;

    fcache_file_name (entry, fname, sizeof(fname));
    fd = open (fname, flags, 0666);
    if (fd < 0) {
	if (errno == ENOENT && create) {
	    char dname[MAXPATHLEN];

	    fcache_dir_name (entry, dname, sizeof(dname));
	    ret = mkdir (dname, 0777);
	    if (ret < 0)
		arla_err (1, ADEBERROR, errno, "mkdir %s", dname);
	    fd = open (fname, flags, 0666);
	    if (fd < 0)
		arla_err (1, ADEBERROR, errno, "open %s", fname);
	} else {
	    arla_err (1, ADEBERROR, errno, "open %s", fname);
	}
    }
    if (close (fd) < 0)
	arla_err (1, ADEBERROR, errno, "close %s", fname);
    fcache_fhget (fname, &entry->handle);
    real_extra_file_name (entry, extra_fname, sizeof(extra_fname));
    unlink (extra_fname);
    return 0;
}

/*
 * return a fd to the cache file of `entry'
 */

int
fcache_open_file (FCacheEntry *entry, int flag)
{
    int ret;
    char fname[MAXPATHLEN];

    if (fhopen_working) {
	ret = fcache_fhopen (&entry->handle, flag);
	if (ret < 0 && (errno == EINVAL || errno == EPERM))
	    fhopen_working = 0;
	else
	    return ret;
    }
    fcache_file_name (entry, fname, sizeof(fname));
    return open (fname, flag | O_BINARY);
}

/*
 * return a fd to the converted directory for `entry'
 */

int
fcache_open_extra_dir (FCacheEntry *entry, int flag, mode_t mode)
{
    char fname[MAXPATHLEN];

    assert (entry->flags.extradirp &&
	    entry->status.FileType == TYPE_DIR);

    fcache_extra_file_name (entry, fname, sizeof(fname));
    return open (fname, flag | O_BINARY, mode);
}

/*
 * Discard the data cached for `entry'.
 */

static void
throw_data (FCacheEntry *entry)
{
    int fd;
    struct stat sb;

    assert (entry->flags.usedp);
    AssertExclLocked(&entry->lock);

    fd = fcache_open_file (entry, O_WRONLY);
    if (fd < 0) {
	arla_warn (ADEBFCACHE, errno, "fcache_open_file");
	goto out;
    }
    if (fstat (fd, &sb) < 0) {
	arla_warn (ADEBFCACHE, errno, "fstat");
	close (fd);
	goto out;
    }
    if (ftruncate (fd, 0) < 0) {
	arla_warn (ADEBFCACHE, errno, "ftruncate");
	close (fd);
	goto out;
    }
    close (fd);
    if (entry->flags.extradirp) {
	char fname[MAXPATHLEN];

	fcache_extra_file_name (entry, fname, sizeof(fname));
	unlink (fname);
    }
    if (usedbytes < entry->length) {
	arla_warnx(ADEBCONN, "usedbytes %d < entry->length %d", usedbytes, 
	    entry->length);
	exit(-1);
    }
    /* XXX - things are wrong - continue anyway */
    if (usedbytes < entry->length)
	usedbytes  = entry->length;
    usedbytes -= entry->length;
    entry->length = 0;
    entry->wanted_length = 0;
    entry->fetched_length = 0;
    entry->flags.extradirp = FALSE;

 out:
    cm_check_consistency();
}

/*
 * A probe function for a file server.
 */

int
fs_probe (struct rx_connection *conn)
{
    uint32_t sec, usec;

    return RXAFS_GetTime (conn, &sec, &usec);
}

/*
 *
 */

static void
throw_entry (FCacheEntry *entry)
{
    CredCacheEntry *ce;
    ConnCacheEntry *conn;
    AFSCBFids fids;
    AFSCBs cbs;
    int ret;

    assert (entry->flags.usedp);
    assert (!entry->flags.kernelp);

    AssertExclLocked(&entry->lock);
    assert(LockWaiters(&entry->lock) == 0);

    hashtabdel (hashtab, entry);

    /* 
     * Throw data when there is data, length is a good test since the
     * node most not be used (in kernel) when we get here.
     */
    if (entry->length)
	throw_data (entry);

    if (entry->invalid_ptr != -1) {
	heap_remove (invalid_heap, entry->invalid_ptr);
	entry->invalid_ptr = -1;
    }

    fcache_poller_unref(entry);

    if (entry->flags.attrp && entry->host) {
	ce = cred_get (entry->fid.Cell, 0, CRED_NONE);
	if (ce == NULL) {
		arla_warnx (ADEBMISC, "cred_get failed");
		exit(-1);
	}

	conn = conn_get (entry->fid.Cell, entry->host, afsport,
			 FS_SERVICE_ID, fs_probe, ce);
	cred_free (ce);
	
	if (conn_isalivep(conn)) {
	    fids.len = cbs.len = 1;
	    fids.val = &entry->fid.fid;
	    cbs.val  = &entry->callback;
	    if (conn_isalivep (conn))
		ret = RXAFS_GiveUpCallBacks(conn->connection, &fids, &cbs);
	    else
		ret = ENETDOWN;
	    conn_free (conn);
	    if (ret)
		arla_warn (ADEBFCACHE, ret, "RXAFS_GiveUpCallBacks");
	}
    }
    if (entry->volume) {
	volcache_free (entry->volume);
	entry->volume = NULL;
    }
    assert_not_flag(entry,kernelp);
    entry->flags.attrp = FALSE;
    entry->flags.usedp = FALSE;
    --usedvnodes;
    LWP_NoYieldSignal (lrulist);
}

/*
 * Return the next cache node number.
 */

static unsigned
next_cache_index (void)
{
    do {
	node_count++;
    } while ((node_count < maxrecovered)
	     && IS_RECOVERED(node_count));
    
    return node_count;
}

/*
 * Pre-create cache nodes up to the limit highvnodes.  If you want to
 * create more increase highnodes and signal create_nodes.
 */

static void
create_nodes (char *arg)
{
    FCacheEntry *entries;
    unsigned count = 0;
    struct timeval tv;

    while (1) {
       	unsigned int n, i, j;

	while (highvnodes <= current_vnodes)
	    LWP_WaitProcess (create_nodes);

	n = highvnodes - current_vnodes;

	count = 0;
	
	arla_warnx (ADEBFCACHE,
		    "pre-creating nodes");
	
	entries = calloc (n, sizeof(FCacheEntry));
	if (n != 0 && entries == NULL)
	    arla_errx (1, ADEBERROR, "fcache: calloc failed");
	
	for (i = 0; i < n; ++i) {
	    entries[i].invalid_ptr = -1;
	    entries[i].volume      = NULL;
	    entries[i].refcount    = 0;
	    entries[i].anonaccess  = 0;
	    entries[i].cleanergen  = 0;
	    entries[i].poll = NULL;
	    for (j = 0; j < NACCESS; j++) {
		entries[i].acccache[j].cred = ARLA_NO_AUTH_CRED;
		entries[i].acccache[j].access = 0;
	    }
	    entries[i].length      = 0;
	    Lock_Init(&entries[i].lock);
	    entries[i].index = next_cache_index ();
	    fcache_create_file (&entries[i], 1);

	    current_vnodes++;

	    ++count;
	    tv.tv_sec = 0;
	    tv.tv_usec = 1000;

	    entries[i].lru_le      = listaddhead (lrulist, &entries[i]);
	    assert (entries[i].lru_le);

	    LWP_NoYieldSignal (lrulist);
	    IOMGR_Select(0, NULL, NULL, NULL, &tv);
	}

	arla_warnx (ADEBFCACHE,
		    "pre-created %u nodes", count);
    }
}

/*
 * This is the almighty cleaner loop
 */

static Bool cleaner_working = FALSE;

static void
cleaner (char *arg)
{
    enum { CL_OPPORTUNISTIC, CL_FORCE, CL_COLLECT } state;
    int cnt = 0, numnodes;
    VenusFid *fids;
    int cleanerrun = 0;
    
    numnodes = NNPFS_GC_NODES_MAX_HANDLE;
    
    fids = malloc (sizeof(*fids) * numnodes);
    if (fids == NULL)
	arla_err (1, ADEBERROR, errno, "cleaner: malloc");
    
    for (;;) {
	Listitem *item, *prev;
	FCacheEntry *entry;
	
	arla_warnx (ADEBCLEANER,
		    "running cleaner: "
		    "%lu (%lu-(%lu)-%lu) files, "
		    "%lu (%lu-%lu) bytes "
		    "%lu needed bytes",
		    usedvnodes, lowvnodes, current_vnodes, highvnodes,
		    (long)usedbytes, (long)lowbytes, (long)highbytes,
		    (long)needbytes);
	
	cleaner_working = TRUE;

	state = CL_OPPORTUNISTIC;
	cleanerrun++;

	while (usedvnodes > lowvnodes 
	       || usedbytes > lowbytes
	       || needbytes > highbytes - usedbytes)
	{
	    
	    for (item = listtail (lrulist);
		 item &&
		     (usedvnodes > lowvnodes
		      || usedbytes > lowbytes
		      || needbytes > highbytes - usedbytes);
		 item = prev) {
		prev = listprev (lrulist, item);
		entry = (FCacheEntry *)listdata (item);
		
		if (fprioritylevel && entry->priority)
		    continue;
		
		if (entry->cleanergen == cleanerrun)
		    continue;
		entry->cleanergen = cleanerrun;

		if (entry->flags.usedp
		    && (usedvnodes > lowvnodes 
			|| usedbytes > lowbytes 
			|| needbytes > highbytes - usedbytes)
		    && entry->refcount == 0
		    && CheckLock(&entry->lock) == 0) 
		{
		    if (!entry->flags.datausedp
			&& !entry->flags.kernelp
			/* && this_is_a_good_node_to_gc(entry,state) */) {

			ObtainWriteLock (&entry->lock);
			listdel (lrulist, item);
			throw_entry (entry);
			entry->lru_le = listaddtail (lrulist, entry);
			if(!entry->lru_le)
				exit(-1);
			ReleaseWriteLock (&entry->lock);
			break;
		    }

		    if (state == CL_FORCE && entry->flags.kernelp) {
			
			fids[cnt++] = entry->fid;
			
			if (cnt >= numnodes) {
			    nnpfs_send_message_gc_nodes (kernel_fd, cnt, fids);
			    IOMGR_Poll();
			    cnt = 0;
			}
			break;
		    }
		}
		assert (entry->lru_le == item);
	    }
	    if (item == NULL) {
		switch (state) {
		case CL_OPPORTUNISTIC:
		    state = CL_FORCE;
		    LWP_DispatchProcess(); /* Yield */
		    break;
		case CL_FORCE:
		    state = CL_COLLECT;		    
		    if (cnt > 0) {
			nnpfs_send_message_gc_nodes (kernel_fd, cnt, fids);
			IOMGR_Poll();
			cnt = 0;
		    }
		    break;
		case CL_COLLECT:
		    goto out;
		    break;
		default:
		    errx(-1, "fcache.c: uknown state %d\n", state);
		    /* NOTREACHED */
		}
		cleanerrun++;
	    }
	}
    out:
	
	arla_warnx(ADEBCLEANER,
		   "cleaner done: "
		   "%lu (%lu-(%lu)-%lu) files, "
		   "%ld (%ld-%ld) bytes "
		   "%ld needed bytes",
		   usedvnodes, lowvnodes, current_vnodes, highvnodes,
		   (long)usedbytes, (long)lowbytes, (long)highbytes,
		   (long)needbytes);
	
	cm_check_consistency();
	if (needbytes)
	    LWP_NoYieldSignal (fcache_need_bytes);
	cleaner_working = FALSE;
	IOMGR_Sleep (CLEANER_SLEEP);
    }
}

static void
fcache_wakeup_cleaner (void *wait)
{
    if (cleaner_working == FALSE)
	IOMGR_Cancel (cleaner_pid);
    LWP_WaitProcess (wait);
}

int
fcache_need_bytes (u_long needed)
{
    if (needed + needbytes > highbytes) {
	arla_warnx (ADEBWARN, 
		    "Out of space since there is outstanding requests "
		    "(%ld needed, %ld outstanding, %ld highbytes)", 
		    (long)needed, (long)needbytes, (long)highbytes);
	return ENOSPC;
    }

    needbytes += needed;
    fcache_wakeup_cleaner(fcache_need_bytes);
    needbytes -= needed;
    if (needed > highbytes - usedbytes) {
	arla_warnx (ADEBWARN, 
		    "Out of space, couldn't get needed bytes after cleaner "
		    "(%lu bytes missing, %lu used, %lu highbytes)",
		    (long)(needed - (highbytes - usedbytes)), 
		    (long)usedbytes, (long)highbytes);
	return ENOSPC;
    }
    return 0;
}

Bool
fcache_need_nodes (void)
{
    fcache_wakeup_cleaner (lrulist);
    if (current_vnodes == usedvnodes)
	return FALSE;
    return TRUE;
}


/*
 * Run through the heap of objects to be invalidated and throw them away
 * when they time arrive.
 */

static void
invalidator (char *arg)
{
    for (;;) {
	const void *head;
	struct timeval tv;

	arla_warnx(ADEBINVALIDATOR,
		   "running invalidator");

	while ((head = heap_head (invalid_heap)) == NULL)
	    LWP_WaitProcess (invalid_heap);

	gettimeofday (&tv, NULL);

	while ((head = heap_head (invalid_heap)) != NULL) {
	    FCacheEntry *entry = (FCacheEntry *)head;

	    if (tv.tv_sec < entry->callback.ExpirationTime) {
		unsigned long t = entry->callback.ExpirationTime - tv.tv_sec;

		arla_warnx (ADEBINVALIDATOR,
			    "invalidator: sleeping for %lu second(s)", t);
		IOMGR_Sleep (t);
		break;
	    }

	    ObtainWriteLock (&entry->lock);
	    if (head == heap_head (invalid_heap)) {
		heap_remove_head (invalid_heap);
		entry->invalid_ptr = -1;
		if (entry->flags.kernelp)
		    break_callback (entry);
		fcache_poller_unref(entry);
	    }
	    ReleaseWriteLock (&entry->lock);
	}
    }
}

/*
 * Add `entry' to the list of to invalidate when its time is up.
 */

static void
add_to_invalidate (FCacheEntry *e)
{
    if (e->invalid_ptr != -1)
	heap_remove (invalid_heap, e->invalid_ptr);
    heap_insert (invalid_heap, (const void *)e, &e->invalid_ptr);
    LWP_NoYieldSignal (invalid_heap);
    IOMGR_Cancel(invalidator_pid);
}

/*
 * Remove the entry least-recently used and return it locked.  Sleep until
 * there's an entry.
 */

static FCacheEntry *
unlink_lru_entry (void)
{
    FCacheEntry *entry = NULL;
    Listitem *item;

    if (current_vnodes == usedvnodes)
	fcache_need_nodes();
     
    for (;;) {

	assert (!listemptyp (lrulist));
	for (item = listtail (lrulist);
	     item;
	     item = listprev (lrulist, item)) {

	    entry = (FCacheEntry *)listdata (item);
	    if (!entry->flags.usedp
		&& CheckLock(&entry->lock) == 0) {
		assert_not_flag(entry,kernelp);
		ObtainWriteLock (&entry->lock);
		listdel (lrulist, entry->lru_le);
		entry->lru_le = NULL;
		return entry;
	    }
	}

	assert (!listemptyp (lrulist));
	for (item = listtail (lrulist);
	     item;
	     item = listprev (lrulist, item)) {

	    entry = (FCacheEntry *)listdata (item);
	    if (entry->flags.usedp
		&& !entry->flags.attrusedp
		&& !entry->flags.kernelp
		&& entry->refcount == 0
		&& CheckLock(&entry->lock) == 0) {
		assert_not_flag(entry,kernelp);
		ObtainWriteLock (&entry->lock);
		listdel (lrulist, entry->lru_le);
		entry->lru_le = NULL;
		throw_entry (entry);
		return entry;
	    }
	}

	arla_warnx (ADEBFCACHE, "unlink_lru_entry: sleeping");
	fcache_need_nodes();
    }
}

/*
 * Return a usable locked entry.
 */

static FCacheEntry *
find_free_entry (void)
{
    FCacheEntry *entry;

    entry = unlink_lru_entry ();
    if (entry == NULL)
	arla_warnx (ADEBWARN, "All vnode entries in use");
    else {
	AssertExclLocked(&entry->lock);
	++usedvnodes;
    }
    return entry;
}

/*
 *
 */

struct fstore_context {
    Listitem *item;
    unsigned n;
};

static int
fcache_store_entry (struct fcache_store *st, void *ptr)
{
    struct fstore_context *c;
    FCacheEntry *entry;

    c = (struct fstore_context *)ptr;
    if (c->item == NULL)		/* check if done ? */
	return STORE_DONE;

    entry = (FCacheEntry *)listdata (c->item);
    c->item = listprev (lrulist, c->item);

    if (!entry->flags.usedp)
	return STORE_SKIP;
    
    strlcpy(st->cell, cell_num2name(entry->fid.Cell), sizeof(st->cell));
    st->fid		= entry->fid.fid;
    st->refcount	= entry->refcount;
    st->length		= entry->length;
    st->fetched_length	= entry->fetched_length;
    st->volsync		= entry->volsync;
    st->status		= entry->status;
    st->anonaccess	= entry->anonaccess;
    st->index		= entry->index;
    st->flags.attrp	= entry->flags.attrp;
    st->flags.datap	= entry->length ? TRUE : FALSE;
    st->flags.extradirp = entry->flags.extradirp;
    st->flags.mountp    = entry->flags.mountp;
    st->flags.fake_mp   = entry->flags.fake_mp;
    st->flags.vol_root  = entry->flags.vol_root;
    strlcpy(st->parentcell, cell_num2name(entry->parent.Cell), 
	    sizeof(st->parentcell));
    st->parent		= entry->parent.fid;
    st->priority	= entry->priority;
    
    c->n++;
    return STORE_NEXT;
}

/*
 *
 */

int
fcache_store_state (void)
{
    struct fstore_context c;
    int ret;

    if (lrulist == NULL) {
	arla_warnx (ADEBFCACHE, "store_state: lrulist is NULL\n");
	return 0;
    }

    c.item = listtail(lrulist);
    c.n = 0;

    ret = state_store_fcache("fcache", fcache_store_entry, &c);
    if (ret)
	arla_warn(ADEBWARN, ret, "failed to write fcache state");
    else
	arla_warnx (ADEBFCACHE, "wrote %u entries to fcache", c.n);

    return 0;
}

/*
 *
 */

static int
fcache_recover_entry (struct fcache_store *st, void *ptr)
{
    AFSCallBack broken_callback = {0, 0, CBDROPPED};
    unsigned *n = (unsigned *)ptr;

    CredCacheEntry *ce;
    FCacheEntry *e;
    int i;
    VolCacheEntry *vol;
    int res;
    int32_t cellid;

    cellid = cell_name2num(st->cell);
    assert (cellid != -1);
    
    ce = cred_get (cellid, 0, 0);
    if (ce == NULL) {
	    arla_warnx (ADEBMISC, "cred_get failed");
	    exit(-1);
    }
    
    res = volcache_getbyid (st->fid.Volume, cellid, ce, &vol, NULL);
    cred_free (ce);
    if (res)
	return 0;
    if (!vol)
	    exit(-1);
    
    e = calloc(1, sizeof(FCacheEntry));
    e->invalid_ptr = -1;
    Lock_Init(&e->lock);
    ObtainWriteLock(&e->lock);
    

    e->fid.Cell = cellid;
    e->fid.fid  = st->fid;
    e->host     = 0;
    e->status   = st->status;
    e->length   = st->length;
    e->fetched_length = st->fetched_length;
    e->callback = broken_callback;
    e->volsync  = st->volsync;
    e->refcount = st->refcount;
    
    /* Better not restore the rights. pags don't have to be the same */
    for (i = 0; i < NACCESS; ++i) {
	e->acccache[i].cred = ARLA_NO_AUTH_CRED;
	e->acccache[i].access = ANONE;
    }
    
    e->anonaccess = st->anonaccess;
    e->index      = st->index;
    fcache_create_file(e, 0);
    set_recovered(e->index);
    e->flags.usedp = TRUE;
    e->flags.attrp = st->flags.attrp;
    /* st->flags.datap */
    e->flags.attrusedp = FALSE;
    e->flags.datausedp = FALSE;
    e->flags.kernelp   = FALSE;
    e->flags.extradirp = st->flags.extradirp;
    e->flags.mountp    = st->flags.mountp;
    e->flags.fake_mp   = st->flags.fake_mp;
    e->flags.vol_root  = st->flags.vol_root;
    e->flags.sentenced = FALSE;
    e->flags.silly 	   = FALSE;
    e->tokens	       = 0;
    e->parent.Cell = cell_name2num(st->parentcell);
    if (e->parent.Cell == -1)
	    exit(-1);
    e->parent.fid = st->parent;
    e->priority = st->priority;
    e->hits = 0;
    e->cleanergen = 0;
    e->lru_le = listaddhead (lrulist, e);
    if (!e->lru_le)
	    exit(-1);
    e->volume = vol;
    hashtabadd (hashtab, e);
    if (e->length)
	usedbytes += e->length;
    ReleaseWriteLock (&e->lock);
    
    (*n)++;

    return 0;
}

/*
 *
 */

static void
fcache_recover_state (void)
{
    unsigned n;

    n = 0;
    state_recover_fcache("fcache", fcache_recover_entry, &n);

    arla_warnx (ADEBFCACHE, "recovered %u entries to fcache", n);
    current_vnodes = n;
}

/*
 * Search for `cred' in `ae' and return a pointer in `pos'.  If it
 * already exists return TRUE, else return FALSE and set pos to a
 * random slot.
 */

Bool
findaccess (nnpfs_pag_t cred, AccessEntry *ae, AccessEntry **pos)
{
    int i;

    for(i = 0; i < NACCESS ; ++i)
	if(ae[i].cred == cred) {
	    *pos = &ae[i];
	    return TRUE;
	}

    i = rand() % NACCESS;
    *pos = &ae[i];
    return FALSE;
}

/*
 *
 */


static int
fs_rtt_cmp (const void *v1, const void *v2)
{
    struct fs_server_entry *e1 = (struct fs_server_entry *)v1;
    struct fs_server_entry *e2 = (struct fs_server_entry *)v2;
    
    return conn_rtt_cmp(&e1->conn, &e2->conn);
}

/*
 * Initialize a `fs_server_context'.
 */

static void
init_fs_server_context (fs_server_context *context)
{
    context->num_conns = 0;
}

static long
find_partition (fs_server_context *context)
{
    int i = context->conns[context->i - 1].ve_ent;

    if (i < 0 || i >= context->ve->entry.nServers)
	return 0;
    return context->ve->entry.serverPartition[i];
}

/*
 * Find the next fileserver for the request in `context'.
 * Returns a ConnCacheEntry or NULL.
 */

ConnCacheEntry *
find_next_fs (fs_server_context *context,
	      ConnCacheEntry *prev_conn,
	      int error)
{
    if (error) {
	if (host_downp(error))
	    conn_dead (prev_conn);
	if (volume_downp(error))
	    volcache_mark_down (context->ve, 
				context->conns[context->i - 1].ve_ent,
				error);
    } else if (prev_conn) {
	if(prev_conn != context->conns[context->i - 1].conn)
		exit(-1);
	volcache_reliable_el(context->ve, context->conns[context->i - 1].ve_ent);
    }

    if (context->i < context->num_conns)
	return context->conns[context->i++].conn;
    else
	return NULL;
}

/*
 * Clean up a `fs_server_context'
 */

void
free_fs_server_context (fs_server_context *context)
{
    int i;

    for (i = 0; i < context->num_conns; ++i)
	conn_free (context->conns[i].conn);

    if (context->ve)
	volcache_process_marks(context->ve);
}

/*
 * Find the the file servers housing the volume for `e' and store it
 * in the `context'.
 */

int
init_fs_context (FCacheEntry *e,
		 CredCacheEntry *ce,
		 fs_server_context *context)
{
    VolCacheEntry  *ve = e->volume;
    int i;
    int bit;
    int num_clones;
    int cell = e->fid.Cell;
    int ret;

    memset(context, 0, sizeof(*context));

    if (ve == NULL) {
	ret = volcache_getbyid (e->fid.fid.Volume, e->fid.Cell,
				ce, &e->volume, NULL);
	if (ret)
	    return ret;
	ve = e->volume;
    }

    ret = volume_make_uptodate (ve, ce);
    if (ret)
	return ret;

    bit = volcache_volid2bit (ve, e->fid.fid.Volume);

    if (bit == -1) {
	/* the volume entry is inconsistent. */
	volcache_invalidate_ve (ve);
	return ENOENT;
    }

    num_clones = 0;
    for (i = 0; i < min(NMAXNSERVERS,ve->entry.nServers); ++i) {
	u_long addr = htonl(ve->entry.serverNumber[i]);

	if (ve->entry.serverFlags[i] & bit
	    && addr != 0
	    && (ve->entry.serverFlags[i] & VLSF_DONTUSE) == 0) {
	    ConnCacheEntry *conn;

	    conn = conn_get (cell, addr, afsport,
			     FS_SERVICE_ID, fs_probe, ce);
	    if (!conn_isalivep (conn))
		conn->rtt = INT_MAX/2 ;
	    else if (!volcache_reliablep_el(ve, i))
		conn->rtt = INT_MAX/4;
	    else
		conn->rtt = rx_PeerOf(conn->connection)->srtt
		    + rand() % RTT_FUZZ - RTT_FUZZ / 2;
	    context->conns[num_clones].conn = conn;
	    context->conns[num_clones].ve_ent = i;
	    ++num_clones;
	}
    }

    if (num_clones == 0)
	return ENOENT;
    
    context->ve = ve;

    qsort (context->conns, num_clones, sizeof(*context->conns),
	   fs_rtt_cmp);

    context->num_conns = num_clones;
    context->i	       = 0;

    return 0;
}

/*
 * Find the first file server housing the volume for `e'.
 */

ConnCacheEntry *
find_first_fs (fs_server_context *context)
{
    return find_next_fs (context, NULL, 0);
}

/*
 * Initialize the file cache in `cachedir', with these values for high
 * and low-water marks.
 */

void
fcache_init (u_long alowvnodes,
	     u_long ahighvnodes,
	     int64_t alowbytes,
	     int64_t ahighbytes,
	     Bool recover)
{
    /*
     * Initialize all variables.
     */

#ifdef KERBEROS
    fhopen_working = k_hasafs ();
#else
    fhopen_working = 0;
#endif

    collectstats_init ();

    node_count     = 0;
    lowvnodes      = alowvnodes;
    highvnodes     = ahighvnodes;
    lowbytes       = alowbytes;
    highbytes      = ahighbytes;

    hashtab      = hashtabnew (FCHASHSIZE, fcachecmp, fcachehash);
    if (hashtab == NULL)
	arla_errx (1, ADEBERROR, "fcache: hashtabnew failed");

    lrulist      = listnew ();
    if (lrulist == NULL)
	arla_errx (1, ADEBERROR, "fcache: listnew failed");

    invalid_heap = heap_new (ahighvnodes, expiration_time_cmp);
    if (invalid_heap == NULL)
	arla_errx (1, ADEBERROR, "fcache: heap_new failed");

    if (recover)
	fcache_recover_state ();

    if (LWP_CreateProcess (create_nodes, CREATE_NODES_STACKSIZE, 1,
 			   NULL, "fcache-create-nodes",
 			   &create_nodes_pid))
 	arla_errx (1, ADEBERROR,
 		   "fcache: cannot create create-nodes thread");

    if (LWP_CreateProcess (cleaner, CLEANER_STACKSIZE, 1,
			   NULL, "fcache-cleaner", &cleaner_pid))
	arla_errx (1, ADEBERROR,
		   "fcache: cannot create cleaner thread");

    if (LWP_CreateProcess (invalidator, CLEANER_STACKSIZE, 1,
			   NULL, "fcache-invalidator", &invalidator_pid))
	arla_errx (1, ADEBERROR,
		   "fcache: cannot create invalidator thread");
}

/*
 * set new values for those of lowvnodes, highvnodes, lowbytes, highbytes
 * that are not zero.
 * return 0 or an error code
 */

int
fcache_reinit(u_long alowvnodes, 
	      u_long ahighvnodes, 
	      int64_t alowbytes,
	      int64_t ahighbytes)
{
    arla_warnx (ADEBFCACHE, "fcache_reinit");
    
    if (ahighvnodes != 0) {
	if (ahighvnodes > highvnodes) {
	    highvnodes = ahighvnodes;
	    LWP_NoYieldSignal (create_nodes);
	} else
	    highvnodes = ahighvnodes;
    }

    if (alowvnodes != 0)
	lowvnodes = alowvnodes;

    if (alowbytes != 0)
	lowbytes = alowbytes;

    if (ahighbytes != 0)
	highbytes = ahighbytes;

    return 0;
}

/*
 * Find the entry for `fid' in the hash table.
 * If it's found, move it to the front of `lrulist' as well.
 */

static FCacheEntry *
find_entry_nolock (VenusFid fid)
{
    FCacheEntry key;
    FCacheEntry *e;

    if (hashtab == NULL)
	return NULL;

    key.fid = fid;
    e = (FCacheEntry *)hashtabsearch (hashtab, (void *)&key);
    if (e != NULL) {
	listdel (lrulist, e->lru_le);
	e->lru_le = listaddhead (lrulist, e);
	if(!e->lru_le)
		return NULL;
    }
    return e;
}

/*
 * Find the entry and return it locked.
 */

static FCacheEntry *
find_entry (VenusFid fid)
{
    FCacheEntry *e;

    e = find_entry_nolock (fid);
    
    if (e != NULL)
	ObtainWriteLock (&e->lock);
    return e;
}

/*
 * Mark `e' as having `callback' and notify the kernel.
 * This might be overly hash to opened files.
 */

static void
stale (FCacheEntry *e, AFSCallBack callback)
{
    if (callback.CallBackType == CBDROPPED &&
	e->callback.CallBackType == CBDROPPED)
	return;

    if (CheckLock (&e->lock) != 0)
	e->flags.sentenced = TRUE;
    else {
	ObtainWriteLock (&e->lock);
	fcache_poller_unref(e);
	e->callback = callback;

	if (e->flags.kernelp)
	    break_callback (e);
	else
	    e->tokens = 0;
	if (e->status.FileType == TYPE_DIR && e->length)
	    throw_data(e);
	ReleaseWriteLock (&e->lock);
    }
}

struct stale_arg {
    VenusFid fid;
    AFSCallBack callback;
};

/*
 * Iterate over all entries till we find an entry that matches in only
 * fid (without cell) and stale it.
 */

static Bool
stale_unknown_cell (void *ptr, void *arg)
{
    FCacheEntry *e = (FCacheEntry *)ptr;
    struct stale_arg *sa = (struct stale_arg *)arg;

    if (e->fid.fid.Volume    == sa->fid.fid.Volume
	&& e->fid.fid.Vnode  == sa->fid.fid.Vnode
	&& e->fid.fid.Unique == sa->fid.fid.Unique)
	stale (e, sa->callback);

    return FALSE;
}

/*
 * Call stale on the entry corresponding to `fid', if any.
 */

void
fcache_stale_entry (VenusFid fid, AFSCallBack callback)
{
    FCacheEntry *e;

    if (fid.Cell == -1) {
	struct stale_arg arg;

	arg.fid = fid;
	arg.callback = callback;

	hashtabforeach (hashtab, stale_unknown_cell, &arg);
	return;
    }

    e = find_entry_nolock (fid);
    if (e == NULL) {
	arla_warnx (ADEBFCACHE,
		    "callback for non-existing file (%d, %u, %u, %u)",
		    fid.Cell, fid.fid.Volume, fid.fid.Vnode, fid.fid.Unique);
	return;
    }
    stale (e, callback);
}

typedef struct {
    nnpfs_pag_t pag;
    int32_t cell;
} fc_purgecred;

/*
 * If ptr has cred arg, set it invalid
 */

static Bool
purge_cred (void *ptr, void *arg)
{
    FCacheEntry *e = (FCacheEntry *)ptr;
    fc_purgecred *cred = (fc_purgecred *) arg;
    AccessEntry *ae = e->acccache;
    int i;

    if (e->fid.Cell == cred->cell ||  cred->cell == -1) {

	for(i = 0; i < NACCESS ; ++i)
	    if(ae[i].cred == cred->pag) {
		ae[i].cred = ARLA_NO_AUTH_CRED;
		ae[i].access = ANONE;
		if (e->flags.kernelp)
		    install_attr (e, FCACHE2NNPFSNODE_NO_LENGTH);
		break;
	    }
    }
    return FALSE;
}
    

/*
 * Mark as cred as stale in kernel and all fcache-entries,
 * When cell == -1, flush all creds in this pag.
 */

void
fcache_purge_cred (nnpfs_pag_t pag, int32_t cell)
{
    fc_purgecred cred;

    cred.pag = pag;
    cred.cell = cell;

    hashtabforeach(hashtab, purge_cred, &cred);
}

/*
 * If ptr was retrieved from cell - volume , try to mark stale
 */

static Bool
purge_volume (void *ptr, void *arg)
{
    FCacheEntry *e = (FCacheEntry *)ptr;
    VenusFid *fid = (VenusFid *) arg;
    AFSCallBack broken_callback = {0, 0, CBDROPPED};

    if ((e->fid.Cell == fid->Cell || fid->Cell == -1)
	&& e->fid.fid.Volume == fid->fid.Volume) {
	stale (e, broken_callback);
    }
    return FALSE;
}

/*
 * Mark as stale all entries from cell.volume
 */

void
fcache_purge_volume (VenusFid fid)
{
    hashtabforeach(hashtab, purge_volume, &fid);
}

/*
 * If `ptr' was retrieved from `host', mark it as stale.
 */

static Bool
purge_host (void *ptr, void *arg)
{
    FCacheEntry *e = (FCacheEntry *)ptr;
    u_long *host = (u_long *)arg;
    AFSCallBack broken_callback = {0, 0, CBDROPPED};

    assert (*host);
    if (e->host == *host)
	stale (e, broken_callback);
    return FALSE;
}

/*
 * Mark as stale all entries from the host `host'.
 */

void
fcache_purge_host (u_long host)
{
    hashtabforeach (hashtab, purge_host, &host);
}


/*
 * If `ptr' is a mountpoint, mark it as stale.
 */

static Bool
invalidate_mp (void *ptr, void *arg)
{
    FCacheEntry *e = (FCacheEntry *)ptr;
    AFSCallBack broken_callback = {0, 0, CBDROPPED};

    if (e->flags.mountp)
	stale (e, broken_callback);
    return FALSE;


}

/*
 * Invalidate all mountpoints to force the to be reread.
 */

void
fcache_invalidate_mp (void)
{
    hashtabforeach (hashtab, invalidate_mp, NULL);
}

/*
 * Mark `entry' as not being used.
 */

void
fcache_unused (FCacheEntry *entry)
{
    entry->flags.datausedp = entry->flags.attrusedp = FALSE;
    listdel (lrulist, entry->lru_le);
    entry->lru_le = listaddtail (lrulist, entry);
    assert (entry->lru_le);
    /* 
     * we don't signal lrulist here since we never
     * free the node (usedvnode--);
     */
}

/*
 * make up some status that might be valid for a mount-point
 */

static void
fake_mp_status (FCacheEntry *e)
{
    AFSFetchStatus *status = &e->status;

    status->FileType      = TYPE_DIR;
    status->LinkCount     = 100;
    status->UnixModeBits  = 0777;
    status->ClientModTime = 0;
    status->ServerModTime = 0;
    status->Owner         = 0;
    status->Group         = 0;
}

/*
 * Return true if `entry' is a mountpoint
 */

static Bool
mountpointp (FCacheEntry *entry)
{
    if (entry->status.FileType == TYPE_LINK
	&& entry->status.Length != 0
	&& entry->status.UnixModeBits == 0644)
	return TRUE;
    return FALSE;
}

/*
 * Mark `entry' as mountpoint or a fake mountpoint depending on
 * fake_mp is used or not.
 */

void
fcache_mark_as_mountpoint (FCacheEntry *entry)
{
    if (fake_mp) {
	entry->flags.fake_mp = TRUE;
	fake_mp_status (entry);
    } else {
	entry->flags.mountp = TRUE;
    }
}

/*
 * Update all the relevant parts of `entry' after having received new
 * data from the file server.
 */

static void
update_entry (FCacheEntry *entry,
	      AFSFetchStatus *status,
	      AFSCallBack *callback,
	      AFSVolSync *volsync,
	      ConnCacheEntry *conn,
	      nnpfs_pag_t cred)
{
    struct timeval tv;
    AccessEntry *ae;
    unsigned long bitmask = 0141777; /* REG, DIR, STICKY, USR, GRP, OTH */

    if (entry->volume && cell_issuid_by_num (entry->volume->cell))
	bitmask |= 0006000; /* SUID, SGID */

    gettimeofday (&tv, NULL);

    entry->status   = *status;
    entry->status.UnixModeBits &= bitmask;
    if (callback) {
	entry->callback = *callback;
	entry->callback.ExpirationTime += tv.tv_sec;
	add_to_invalidate (entry);
    }
    if (volsync) {
	entry->volsync  = *volsync;
	if (entry->volume)
	    volcache_update_volsync (entry->volume, *volsync);
    }

    if (conn) {
	fcache_poller_reref(entry, conn);
	entry->host     = rx_HostOf(rx_PeerOf(conn->connection));
    } else {
	fcache_poller_unref(entry);
	entry->host = 0;
    }

    entry->anonaccess = status->AnonymousAccess;
    findaccess (cred, entry->acccache, &ae);
    ae->cred   = cred;
    ae->access = status->CallerAccess;
    if (!entry->flags.mountp && mountpointp (entry))
	fcache_mark_as_mountpoint (entry);
}

/*
 * Update entry, common code for do_read_attr and get_attr_bulk
 */

static void
update_attr_entry (FCacheEntry *entry,
		   AFSFetchStatus *status,
		   AFSCallBack *callback,
		   AFSVolSync *volsync,
		   ConnCacheEntry *conn,
		   nnpfs_pag_t cred)
{
    if (entry->fetched_length
	&& entry->status.DataVersion != status->DataVersion
	&& !entry->flags.datausedp) 
    {
	throw_data (entry);
	entry->tokens &= ~(NNPFS_DATA_R|NNPFS_DATA_W);
    }
    
    update_entry (entry, status, callback, volsync,
		  conn, cred);
    
    entry->tokens |= NNPFS_ATTR_R;
    entry->flags.attrp = TRUE;
}


/*
 * Give up all callbacks.
 */

static int
giveup_all_callbacks (uint32_t cell, uint32_t host, void *arg)
{
    CredCacheEntry *ce;	
    ConnCacheEntry *conn;
    Listitem *item;
    int ret;

    ce = cred_get (cell, 0, CRED_ANY);
    assert (ce != NULL);
    
    conn = conn_get (cell, host, afsport, FS_SERVICE_ID, fs_probe, ce);
    cred_free (ce);

    if (!conn_isalivep (conn))
	goto out;

    ret = RXAFS_GiveUpAllCallBacks(conn->connection);
    if (ret == 0) {
	for (item = listtail(lrulist);
	     item != NULL;
	     item = listprev(lrulist, item)) {
	    FCacheEntry *entry = (FCacheEntry *)listdata(item);
	    
	    if (entry->host == host)
		entry->flags.attrp = FALSE;
	}
    } else if (ret != RXGEN_OPCODE) {
	struct in_addr in_addr;

	in_addr.s_addr = rx_HostOf(rx_PeerOf(conn->connection));
	arla_warn (ADEBWARN, ret, "GiveUpAllCallBacks %s",
		   inet_ntoa (in_addr));
    }

 out:
    conn_free (conn);

    return 0;
}

int
fcache_giveup_all_callbacks (void)
{
    Listitem *item;

    poller_foreach(giveup_all_callbacks, NULL);

    for (item = listtail(lrulist);
	 item != NULL;
	 item = listprev(lrulist, item)) {
	FCacheEntry *entry = (FCacheEntry *)listdata(item);

	if (entry->flags.attrp && 
	    entry->flags.silly == FALSE &&
	    entry->host != 0) {

	    CredCacheEntry *ce;	
	    ConnCacheEntry *conn;
	    AFSCBFids fids;
	    AFSCBs cbs;
	    int ret;

	    ce = cred_get (entry->fid.Cell, 0, CRED_ANY);
	    assert (ce != NULL);

	    conn = conn_get (entry->fid.Cell, entry->host, afsport,
			     FS_SERVICE_ID, fs_probe, ce);
	    cred_free (ce);

	    if (conn != NULL) {
		fids.len = cbs.len = 1;
		fids.val = &entry->fid.fid;
		cbs.val  = &entry->callback;
		
		ret = RXAFS_GiveUpCallBacks (conn->connection, &fids, &cbs);
		conn_free (conn);
		if (ret) {
		    struct in_addr in_addr;

		    in_addr.s_addr = rx_HostOf(rx_PeerOf(conn->connection));
		    arla_warn (ADEBFCACHE, ret, "RXAFS_GiveUpCallBacks %s",
			       inet_ntoa (in_addr));
		} else
		    entry->flags.attrp = FALSE;
	    }
	}
    }
    return 0;			/* XXX */
}

/*
 * Obtain new callbacks for all entries in the cache.
 */

int
fcache_reobtain_callbacks (struct nnpfs_cred *cred)
{
    Listitem *item;
    int ret;

    for (item = listtail(lrulist);
	 item != NULL;
	 item = listprev(lrulist, item)) {
	FCacheEntry *entry = (FCacheEntry *)listdata(item);

	ObtainWriteLock (&entry->lock);
	if (entry->flags.usedp && 
	    entry->flags.silly == FALSE &&
	    entry->host != 0) {

	    CredCacheEntry *ce;	
	    ConnCacheEntry *conn;
	    AFSFetchStatus status;
	    AFSCallBack callback;
	    AFSVolSync volsync;
	    VolCacheEntry *vol;

	    ce = cred_get (entry->fid.Cell, cred->pag, CRED_ANY);
	    assert (ce != NULL);

	    conn = conn_get (entry->fid.Cell, entry->host, afsport,
			     FS_SERVICE_ID, fs_probe, ce);
	    if (!conn_isalivep(conn))
		goto out;
	    /*
	     * does this belong here?
	     */

	    ret = volcache_getbyid (entry->fid.fid.Volume,
				    entry->fid.Cell, ce, &vol, NULL);
	    if (ret == 0)
		entry->volume = vol;

	    ret = RXAFS_FetchStatus (conn->connection,
				     &entry->fid.fid,
				     &status,
				     &callback,
				     &volsync);
	    if (ret)
		arla_warn (ADEBFCACHE, ret, "RXAFS_FetchStatus");
	    else {
		update_attr_entry (entry, &status, &callback, &volsync,
				   conn, ce->cred);
		if (entry->flags.kernelp)
		    break_callback (entry);
	    }
	    fcache_counter.fetch_attr++;
	out:
	    if (conn)
		conn_free (conn);
	    cred_free (ce);
	}
	ReleaseWriteLock (&entry->lock);
    }
    return 0;			/* XXX */
}

/*
 * Return true iff there's any point in trying the next fs.
 */

static Bool
try_next_fs (int error, const VenusFid *fid)
{
    switch (error) {
#ifdef KERBEROS
    case RXKADUNKNOWNKEY:
#endif
    case ARLA_CALL_DEAD :
    case ARLA_INVALID_OPERATION :
    case ARLA_CALL_TIMEOUT :
    case ARLA_EOF :
    case ARLA_PROTOCOL_ERROR :
    case ARLA_USER_ABORT :
    case ARLA_ADDRINUSE :
    case ARLA_MSGSIZE :
    case ARLA_VSALVAGE :
    case ARLA_VNOSERVICE :
    case ARLA_VOFFLINE :
    case ARLA_VBUSY :
    case ARLA_VIO :
	return TRUE;
    case ARLA_VNOVOL :
    case ARLA_VMOVED :
	if (fid && !volcache_reliablep (fid->fid.Volume, fid->Cell))
	    volcache_invalidate (fid->fid.Volume, fid->Cell);
	return TRUE;
    case 0 :
	return FALSE;
    default :
	return FALSE;
    }
}

/*
 * If the whole file is fetched as we last saw it, lets write down
 * the whole file to the fileserver. If the file is shrinking,
 * make sure we don't cache non-existing bytes.
 */

static size_t
new_fetched_length(FCacheEntry *entry, size_t cache_file_size)
{
    size_t have_len;

    AssertExclLocked(&entry->lock);

    if (entry->fetched_length == entry->status.Length)
	have_len = cache_file_size;
    else {
	have_len = entry->fetched_length;
	/* have file shrinked ? */
	if (have_len > cache_file_size)
	    have_len = cache_file_size;
    }

    return have_len;
}

/*
 * Fetch the attributes for the file in `entry' from the file_server,
 * using the credentials in `ce' and returning the connection in
 * `ret_conn'
 *
 * `entry' must be write-locked.
 *
 * If an error code is returned `fs_server_context' is already freed.
 * If everything is ok, `fs_server_context' must be freed by the caller.
 */

static int
do_read_attr (FCacheEntry *entry,
	      CredCacheEntry *ce,
	      ConnCacheEntry **ret_conn,
	      fs_server_context *ret_context)
{
    ConnCacheEntry *conn;
    AFSFetchStatus status;
    AFSCallBack callback;
    AFSVolSync volsync;
    struct collect_stat collectstat;
    int ret;

    AssertExclLocked(&entry->lock);

    *ret_conn = NULL;

    ret = init_fs_context(entry, ce, ret_context);
    if (ret)
	return ret;

    for (conn = find_first_fs (ret_context);
	 conn != NULL;
	 conn = find_next_fs (ret_context, conn, ret)) {

	collectstats_start(&collectstat);
	ret = RXAFS_FetchStatus (conn->connection,
				 &entry->fid.fid,
				 &status,
				 &callback,
				 &volsync);
	collectstats_stop(&collectstat, entry, conn,
			  find_partition(ret_context),
			  STATISTICS_REQTYPE_FETCHSTATUS, 1);
	arla_warnx (ADEBFCACHE, "trying to fetch status: %d", ret);
	if (!try_next_fs (ret, &entry->fid))
	    break;
    }
    if (ret) {
	arla_warn (ADEBFCACHE, ret, "fetch-status");
	if (host_downp(ret))
	    ret = ENETDOWN;
	free_fs_server_context (ret_context);
	return ret;
    }

    fcache_counter.fetch_attr++;

    update_attr_entry (entry, &status, &callback, &volsync,
		       conn, ce->cred);
    
    AssertExclLocked(&entry->lock);

    *ret_conn = conn;
    return 0;
}


/*
 * Read the attributes of `entry' from the file server and store them.
 * `e' must be write-locked.
 */

int
read_attr (FCacheEntry *entry, CredCacheEntry *ce)
{
    int ret;
    ConnCacheEntry *conn;
    fs_server_context context;

    AssertExclLocked(&entry->lock);

    init_fs_server_context (&context);
    ret = do_read_attr (entry, ce, &conn, &context);
    if (ret)
	return ret;
    free_fs_server_context (&context);
    return 0;
}

/*
 * Read the contents of `entry' from the file server and store it.
 */

static int
read_data (FCacheEntry *entry, ConnCacheEntry *conn, CredCacheEntry *ce,
	   long partition)
{
    struct rx_call *call;
    int ret = 0;
    uint32_t wanted_length, sizefs, nbytes = 0;
    int32_t sizediff;
    int fd;
    AFSFetchStatus status;
    AFSCallBack callback;
    AFSVolSync volsync;
    struct collect_stat collectstat;

    arla_warnx (ADEBMISC, "read_data");

    AssertExclLocked(&entry->lock);

    if (connected_mode == DISCONNECTED) {
	ret = ENETDOWN;
	goto out;
    }

    /* are we already done ? */
    if (entry->wanted_length <= entry->fetched_length) {
	ret = 0;
	goto out;
    }

    /* figure out how much more then we need we want to fetch */
    wanted_length = stats_fetch_round(conn, partition, entry->wanted_length);
    if (wanted_length > entry->status.Length)
	wanted_length = entry->status.Length;

    /* we need more space ? */
    if (wanted_length > entry->length)
	nbytes = wanted_length - entry->length;

    if (usedbytes + nbytes > highbytes) {
	ret = fcache_need_bytes (nbytes);
	if (ret)
	    goto out;
    }

    if (usedbytes + nbytes > highbytes) {
	arla_warnx (ADEBWARN, "Out of space, not enough cache "
		    "(file-length: %d need bytes: %ld usedbytes: %ld)",
		    entry->status.Length, (long)nbytes, (long)usedbytes);
	ret = ENOSPC;
	goto out;
    }

    /* now go talk to the world */
    call = rx_NewCall (conn->connection);
    if (call == NULL) {
	arla_warnx (ADEBMISC, "rx_NewCall failed");
	ret = ENOMEM;
	goto out;
    }

    collectstats_start(&collectstat);
    ret = StartRXAFS_FetchData (call, &entry->fid.fid, entry->fetched_length,
				wanted_length - entry->fetched_length);
    if(ret) {
	arla_warn (ADEBFCACHE, ret, "fetch-data");
	rx_EndCall(call,ret);
	goto out;
    }

    ret = rx_Read (call, &sizefs, sizeof(sizefs));
    if (ret != sizeof(sizefs)) {
	ret = conv_to_arla_errno(rx_GetCallError(call));
	arla_warn (ADEBFCACHE, ret, "Error reading length");
	rx_EndCall(call, 0);
	goto out;
    }
    sizefs = ntohl (sizefs);

    fd = fcache_open_file (entry, O_RDWR);
    if (fd < 0) {
	ret = errno;
	arla_warn (ADEBFCACHE, ret, "open cache file %u",
		   (unsigned)entry->index);
	rx_EndCall(call, 0);
	goto out;
    }

    if (ftruncate(fd, entry->status.Length) < 0) {
	close(fd);
	ret = errno;
	rx_EndCall(call, 0);
	goto out;
    }

    ret = copyrx2fd (call, fd, entry->fetched_length, sizefs);
    close (fd);
    if (ret) {
	arla_warn (ADEBFCACHE, ret, "copyrx2fd");
	rx_EndCall(call, ret);
	goto out;
    }

    ret = rx_EndCall (call, EndRXAFS_FetchData (call,
						&status,
						&callback,
						&volsync));
    if(ret) {
	arla_warn (ADEBFCACHE, ret, "rx_EndCall");
	goto out;
    }
    collectstats_stop(&collectstat, entry, conn,
		      partition, STATISTICS_REQTYPE_FETCHDATA, sizefs);

    entry->fetched_length += sizefs;
    sizediff = entry->fetched_length - entry->length;
    entry->length = entry->fetched_length;
    usedbytes += sizediff;

    fcache_counter.fetch_data++;
    
    update_entry (entry, &status, &callback, &volsync,
		  conn, ce->cred);

    entry->tokens |= NNPFS_DATA_R | NNPFS_DATA_W | NNPFS_OPEN_NR | NNPFS_OPEN_NW;

 out:
    AssertExclLocked(&entry->lock);

    return ret;
}

/*
 * Write the contents of the cache file back to the file server.
 */

int
write_data (FCacheEntry *entry, AFSStoreStatus *storestatus,
	    CredCacheEntry *ce)
{
    ConnCacheEntry *conn;
    struct rx_call *call;
    int ret;
    uint32_t sizefs;
    size_t have_len;
    int fd;
    struct stat statinfo;
    AFSFetchStatus status;
    AFSVolSync volsync;
    fs_server_context context;
    struct collect_stat collectstat;

    AssertExclLocked(&entry->lock);

    /* Don't write data to deleted files */
    if (entry->flags.silly)
	return 0;

    fd = fcache_open_file (entry, O_RDWR);
    if (fd < 0) {
	ret = errno;
	arla_warn (ADEBFCACHE, ret, "open cache file %u",
		   (unsigned)entry->index);
	return ret;
    }

    if (fstat (fd, &statinfo) < 0) {
	ret = errno;
	close (fd);
	arla_warn (ADEBFCACHE, ret, "stat cache file %u",
		   (unsigned)entry->index);
	return ret;
    }
    sizefs = statinfo.st_size;

    have_len = new_fetched_length(entry, sizefs);
    if (entry->status.Length < have_len)
	entry->status.Length = have_len;

    /*
     *
     */

    fcache_update_length (entry, have_len, have_len);
    if (connected_mode != CONNECTED) {
	close (fd);
	return 0;
    }

    ret = init_fs_context(entry, ce, &context);
    if (ret)
	return ret;

    for (conn = find_first_fs (&context);
	 conn != NULL;
	 conn = find_next_fs (&context, conn, ret)) {

	call = rx_NewCall (conn->connection);
	if (call == NULL) {
	    arla_warnx (ADEBMISC, "rx_NewCall failed");
	    ret = ENOMEM;
	    break;
	}

	collectstats_start(&collectstat);
	ret = StartRXAFS_StoreData (call, &entry->fid.fid,
				    storestatus,
				    0,
				    have_len,
				    entry->status.Length);
	if (host_downp(ret)) {
	    rx_EndCall(call, ret);
	    continue;
	} else if (ret) {
	    arla_warn (ADEBFCACHE, ret, "store-data");
	    rx_EndCall(call, 0);
	    break;
	}

	ret = copyfd2rx (fd, call, 0, have_len);
	if (ret) {
	    rx_EndCall(call, ret);
	    arla_warn (ADEBFCACHE, ret, "copyfd2rx");
	    break;
	}

	ret = EndRXAFS_StoreData (call,
				  &status,
				  &volsync);
	if (ret) {
	    rx_EndCall (call, ret);
	    arla_warnx (ADEBFCACHE, "EndRXAFS_StoreData");
	    break;
	}

	ret = rx_EndCall (call, 0);
	if (ret) {
	    arla_warn (ADEBFCACHE, ret, "rx_EndCall");
	}
	collectstats_stop(&collectstat, entry, conn,
			  find_partition(&context),
			  STATISTICS_REQTYPE_STOREDATA, sizefs);
	break;
    }

    if (conn != NULL) {
	if (ret == 0) {
	    fcache_counter.store_data++;
	    update_entry (entry, &status, NULL, &volsync,
			  conn, ce->cred);
	} else {
	    ftruncate (fd, 0);
	    usedbytes -= entry->length; 
	    entry->length = 0;
	    entry->wanted_length = 0;
	    entry->fetched_length = 0;
	}
    }
    if (host_downp(ret))
	ret = ENETDOWN;
    free_fs_server_context (&context);
    AssertExclLocked(&entry->lock);
    close (fd);
    return ret;
}

/*
 * Truncate the file in `entry' to `size' bytes.
 */

int
truncate_file (FCacheEntry *entry, off_t size, 
	       AFSStoreStatus *storestatus, CredCacheEntry *ce)
{
    fs_server_context context;
    ConnCacheEntry *conn;
    struct rx_call *call;
    AFSFetchStatus status;
    AFSVolSync volsync;
    size_t have_len;
    int ret;

    AssertExclLocked(&entry->lock);

    if (connected_mode != CONNECTED)
	return 0;

    have_len = new_fetched_length(entry, size);

    ret = init_fs_context(entry, ce, &context);
    if (ret)
	return ret;

    for (conn = find_first_fs (&context);
	 conn != NULL;
	 conn = find_next_fs (&context, conn, ret)) {

	call = rx_NewCall (conn->connection);
	if (call == NULL) {
	    arla_warnx (ADEBMISC, "rx_NewCall failed");
	    ret = ENOMEM;
	    break;
	}

	ret = StartRXAFS_StoreData (call,
				    &entry->fid.fid, 
				    storestatus,
				    size,
				    0,
				    size);
	if (host_downp(ret)) {
	    rx_EndCall(call, ret);
	    continue;
	} else if(ret) {
	    arla_warn (ADEBFCACHE, ret, "store-data");
	    rx_EndCall(call, 0);
	    break;
	}

	ret = EndRXAFS_StoreData (call,
				  &status,
				  &volsync);
	if (ret) {
	    rx_EndCall (call, ret);
	    arla_warnx (ADEBFCACHE, "EndRXAFS_StoreData");
	    break;
	}

	ret = rx_EndCall (call, 0);
	if (ret)
	    arla_warn (ADEBFCACHE, ret, "rx_EndCall");

	break;
    }

    if (ret == 0) {
	int fd;

	fd = fcache_open_file (entry, O_RDWR);
	if (fd < 0) {
	    ret = errno;
	    arla_warn (ADEBFCACHE, ret, "open fache file %u",
		       (unsigned)entry->index);
	    return ret;
	}
	
	if(ftruncate (fd, size) < 0) {
	    ret = errno;
	    arla_warn (ADEBFCACHE, ret, "ftruncate %ld", (long)size);
	    close (fd);
	    return ret;
	}
	
	close (fd);
	
	fcache_update_length (entry, size, have_len);
	
	fcache_counter.store_data++;
	update_entry (entry, &status, NULL, &volsync,
		      conn, ce->cred);
    }

    free_fs_server_context (&context);

    if (host_downp(ret))
	ret = ENETDOWN;

    AssertExclLocked(&entry->lock);
    return ret;
}

/*
 * Set the attributes of the file in `entry' to `status'.
 */

int
write_attr (FCacheEntry *entry,
	    const AFSStoreStatus *store_status,
	    CredCacheEntry *ce)
{
    ConnCacheEntry *conn = NULL;
    int ret;
    AFSFetchStatus status;
    AFSVolSync volsync;

    AssertExclLocked(&entry->lock);

    /* Don't write attributes to deleted files */
    if (entry->flags.silly)
	return 0;

    if (connected_mode == CONNECTED) {
	fs_server_context context;
	struct collect_stat collectstat;

	ret = init_fs_context(entry, ce, &context);
	if (ret)
	    return ret;

	for (conn = find_first_fs (&context);
	     conn != NULL;
	     conn = find_next_fs (&context, conn, ret)) {

	    collectstats_start(&collectstat);
	    ret = RXAFS_StoreStatus (conn->connection,
				     &entry->fid.fid,
				     store_status,
				     &status,
				     &volsync);
	    if (host_downp(ret)) {
		continue;
	    } else if (ret) {
		arla_warn (ADEBFCACHE, ret, "store-status");
		free_fs_server_context (&context);
		conn = NULL;
		goto out;
	    }
	    conn_ref(conn);
	    break;
	}

	if (ret == 0)
	    collectstats_stop(&collectstat, entry, conn,
			      find_partition(&context),
			      STATISTICS_REQTYPE_STORESTATUS, 1);


	free_fs_server_context (&context);

	if (host_downp(ret)) {
	    ret = ENETDOWN;
	    goto out;
	}
	update_entry (entry, &status, NULL, &volsync, conn, ce->cred);

    } else {
	assert (conn == NULL);

	fcache_counter.store_attr++;
	if (store_status->Mask & SS_MODTIME) {
	    entry->status.ClientModTime = store_status->ClientModTime;
	    entry->status.ServerModTime = store_status->ClientModTime;
	}
	if (store_status->Mask & SS_OWNER)
	    entry->status.Owner = store_status->Owner;
	if (store_status->Mask & SS_GROUP)
	    entry->status.Group = store_status->Group;
	if (store_status->Mask & SS_MODEBITS)
	    entry->status.UnixModeBits = store_status->UnixModeBits;
	if (store_status->Mask & SS_SEGSIZE)
	    entry->status.SegSize = store_status->SegSize;
	ret = 0;
    }

 out:
    if (conn)
	conn_free(conn);
    AssertExclLocked(&entry->lock);

    return ret;
}

/*
 * Create a file.
 */

int
create_file (FCacheEntry *dir_entry,
	     const char *name, AFSStoreStatus *store_attr,
	     VenusFid *child_fid, AFSFetchStatus *fetch_attr,
	     CredCacheEntry *ce)
{
    ConnCacheEntry *conn = NULL;
    int ret;
    AFSFid OutFid;
    FCacheEntry *child_entry;
    AFSFetchStatus status;
    AFSCallBack callback;
    AFSVolSync volsync;
    int fd;

    AssertExclLocked(&dir_entry->lock);

    if (connected_mode == CONNECTED) {
	fs_server_context context;

	ret = init_fs_context(dir_entry, ce, &context);
	if (ret)
	    return ret;

	for (conn = find_first_fs (&context);
	     conn != NULL;
	     conn = find_next_fs (&context, conn, ret)) {

	    ret = RXAFS_CreateFile (conn->connection,
				    &dir_entry->fid.fid,
				    name,
				    store_attr,
				    &OutFid,
				    fetch_attr,
				    &status,
				    &callback,
				    &volsync);
	    if (host_downp(ret)) {
		continue;
	    } else if (ret) {
		free_fs_server_context (&context);
		arla_warn (ADEBFCACHE, ret, "CreateFile");
		conn = NULL;
		goto out;
	    }
	    conn_ref(conn);
	    break;
	}

	free_fs_server_context (&context);

	if (host_downp(ret)) {
	    ret = ENETDOWN;
	    goto out;
	}

	update_entry (dir_entry, &status, &callback, &volsync,
		      conn, ce->cred);

    } else {
	static int fakefid = 1001;

	if (conn != NULL)
		exit(-1);

	ret = 0;

	OutFid.Volume = dir_entry->fid.fid.Volume;
	OutFid.Vnode  = fakefid;
	OutFid.Unique = fakefid;
	fakefid += 2;

	fetch_attr->InterfaceVersion = 1;
	fetch_attr->FileType         = TYPE_FILE;
	fetch_attr->LinkCount        = 1;
	fetch_attr->Length	     = 0;
	fetch_attr->DataVersion      = 1;
	fetch_attr->Author           = store_attr->Owner;
	fetch_attr->Owner            = store_attr->Owner;
	fetch_attr->CallerAccess     = dir_entry->status.CallerAccess;
	fetch_attr->AnonymousAccess  = dir_entry->status.AnonymousAccess;
	fetch_attr->UnixModeBits     = store_attr->UnixModeBits;
	fetch_attr->ParentVnode      = dir_entry->fid.fid.Vnode;
	fetch_attr->ParentUnique     = dir_entry->fid.fid.Unique;
	fetch_attr->SegSize          = store_attr->SegSize;
	fetch_attr->ClientModTime    = store_attr->ClientModTime;
	fetch_attr->ServerModTime    = store_attr->ClientModTime;
	fetch_attr->Group            = store_attr->Group;
	fetch_attr->SyncCount        = 0;
	fetch_attr->DataVersionHigh  = 0;
	fetch_attr->LockCount        = 0;
	fetch_attr->LengthHigh       = 0;
	fetch_attr->ErrorCode        = 0;
    }

    child_fid->Cell = dir_entry->fid.Cell;
    child_fid->fid  = OutFid;

    ret = fcache_get (&child_entry, *child_fid, ce);
    if (ret) {
	arla_warn (ADEBFCACHE, ret, "fcache_get");
	goto out;
    }

    update_entry (child_entry, fetch_attr, NULL, NULL,
		  conn, ce->cred);

    child_entry->flags.attrp = TRUE;
    child_entry->flags.kernelp = TRUE;

    fd = fcache_open_file (child_entry, O_WRONLY);
    if (fd < 0) {
	ret = errno;
	arla_warn (ADEBFCACHE, ret, "open cache file %u",
		   (unsigned)child_entry->index);
	fcache_release(child_entry);
	goto out;
    }
    if (ftruncate (fd, 0) < 0) {
	ret = errno;
	arla_warn (ADEBFCACHE, ret, "ftruncate cache file %u",
		   (unsigned)child_entry->index);
	close (fd);
	fcache_release(child_entry);
	goto out;
    }
    close (fd);
    child_entry->length = 0;

    child_entry->tokens |= NNPFS_ATTR_R | NNPFS_DATA_R | NNPFS_DATA_W;
	
    fcache_release(child_entry);

 out:
    if (conn)
	conn_free(conn);

    AssertExclLocked(&dir_entry->lock);

    return ret;
}

/*
 * Create a directory.
 */

int
create_directory (FCacheEntry *dir_entry,
		  const char *name, AFSStoreStatus *store_attr,
		  VenusFid *child_fid, AFSFetchStatus *fetch_attr,
		  CredCacheEntry *ce)
{
    ConnCacheEntry *conn = NULL;
    int ret;
    AFSFid OutFid;
    FCacheEntry *child_entry;
    AFSFetchStatus status;
    AFSCallBack callback;
    AFSVolSync volsync;


    AssertExclLocked(&dir_entry->lock);

    if (connected_mode == CONNECTED) {
	fs_server_context context;

	ret = init_fs_context(dir_entry, ce, &context);
	if (ret)
	    return ret;

	for (conn = find_first_fs (&context);
	     conn != NULL;
	     conn = find_next_fs (&context, conn, ret)) {

	    ret = RXAFS_MakeDir (conn->connection,
				 &dir_entry->fid.fid,
				 name,
				 store_attr,
				 &OutFid,
				 fetch_attr,
				 &status,
				 &callback,
				 &volsync);

	    if (host_downp(ret)) {
		continue;
	    } else if (ret) {
		free_fs_server_context (&context);
		arla_warn (ADEBFCACHE, ret, "MakeDir");
		conn = NULL;
		goto out;
	    }
	    conn_ref(conn);
	    break;
	}
	free_fs_server_context (&context);

	if (host_downp(ret)) {
	    ret = ENETDOWN;
	    goto out;
	}

	update_entry (dir_entry, &status, &callback, &volsync,
		      conn, ce->cred);
    } else {
	static int fakedir = 1000;

	ret = 0;

	if (conn != NULL)
		exit(-1);

	OutFid.Volume = dir_entry->fid.fid.Volume;
	OutFid.Vnode  = fakedir;
	OutFid.Unique = fakedir;
	fakedir += 2;

	fetch_attr->InterfaceVersion = 1;
	fetch_attr->FileType         = TYPE_DIR;
	fetch_attr->LinkCount        = 2;
	fetch_attr->Length           = AFSDIR_PAGESIZE;
	fetch_attr->DataVersion      = 1;
	fetch_attr->Author           = store_attr->Owner;
	fetch_attr->Owner            = store_attr->Owner;
	fetch_attr->CallerAccess     = dir_entry->status.CallerAccess;
	fetch_attr->AnonymousAccess  = dir_entry->status.AnonymousAccess;
	fetch_attr->UnixModeBits     = store_attr->UnixModeBits;
	fetch_attr->ParentVnode      = dir_entry->fid.fid.Vnode;
	fetch_attr->ParentUnique     = dir_entry->fid.fid.Unique;
	fetch_attr->SegSize          = store_attr->SegSize;
	fetch_attr->ClientModTime    = store_attr->ClientModTime;
	fetch_attr->ServerModTime    = store_attr->ClientModTime;
	fetch_attr->Group            = store_attr->Group;
	fetch_attr->SyncCount        = 0;
	fetch_attr->DataVersionHigh  = 0;
	fetch_attr->LockCount        = 0;
	fetch_attr->LengthHigh       = 0;
	fetch_attr->ErrorCode        = 0;
    }

    child_fid->Cell = dir_entry->fid.Cell;
    child_fid->fid  = OutFid;

    ret = fcache_get (&child_entry, *child_fid, ce);
    if (ret) {
	arla_warn (ADEBFCACHE, ret, "fcache_get");
	goto out;
    }

    assert(child_entry->length == 0);

    update_entry (child_entry, fetch_attr, NULL, NULL,
		  conn, ce->cred);

    child_entry->flags.attrp = TRUE;
    child_entry->flags.kernelp = TRUE;

    ret = adir_mkdir (child_entry, child_fid->fid, dir_entry->fid.fid);
    if (ret) {
	arla_warn (ADEBFCACHE, ret, "adir_mkdir");
	fcache_release(child_entry);
	goto out;
    }

    child_entry->tokens |= NNPFS_ATTR_R | NNPFS_DATA_R | NNPFS_DATA_W;
	
    fcache_release(child_entry);

 out:
    if (conn)
	conn_free(conn);
    AssertExclLocked(&dir_entry->lock);
    return ret;
}

/*
 * Create a symbolic link.
 *
 * Note: create_symlink->flags.kernelp is not set on success
 * and that must be done by the caller.
 */

int
create_symlink (FCacheEntry *dir_entry,
		const char *name, AFSStoreStatus *store_attr,
		VenusFid *child_fid, AFSFetchStatus *fetch_attr,
		const char *contents,
		CredCacheEntry *ce)
{
    int ret;
    ConnCacheEntry *conn;
    AFSFid OutFid;
    FCacheEntry *child_entry;
    AFSVolSync volsync;
    AFSFetchStatus new_status;
    fs_server_context context;

    AssertExclLocked(&dir_entry->lock);

    if (connected_mode != CONNECTED)
	return EINVAL;

    ret = init_fs_context(dir_entry, ce, &context);
    if (ret)
	return ret;

    for (conn = find_first_fs (&context);
	 conn != NULL;
	 conn = find_next_fs (&context, conn, ret)) {

	ret = RXAFS_Symlink (conn->connection,
			     &dir_entry->fid.fid,
			     name,
			     contents,
			     store_attr,
			     &OutFid,
			     fetch_attr,
			     &new_status,
			     &volsync);
	if (host_downp(ret)) {
	    continue;
	} else if (ret) {
	    arla_warn (ADEBFCACHE, ret, "Symlink");
	    free_fs_server_context (&context);
	    conn = NULL;
	    goto out;
	}
	conn_ref(conn);
	break;
    }
    free_fs_server_context (&context);

    if (host_downp(ret)) {
	ret = ENETDOWN;
	goto out;
    }

    update_entry (dir_entry, &new_status, NULL, &volsync,
		  conn, ce->cred);

    child_fid->Cell = dir_entry->fid.Cell;
    child_fid->fid  = OutFid;

    ret = fcache_get (&child_entry, *child_fid, ce);
    if (ret) {
	arla_warn (ADEBFCACHE, ret, "fcache_get");
	goto out;
    }

    update_entry (child_entry, fetch_attr, NULL, NULL,
		  conn, ce->cred);

    /* 
     * flags.kernelp is set in cm_symlink since the symlink
     * might be a mountpoint and this entry is never install
     * into the kernel.
     */

    child_entry->flags.attrp = TRUE;
    child_entry->tokens |= NNPFS_ATTR_R;
	
    fcache_release(child_entry);

 out:
    if (conn)
	conn_free(conn);
    AssertExclLocked(&dir_entry->lock);
    return ret;
}

/*
 * Create a hard link.
 */

int
create_link (FCacheEntry *dir_entry,
	     const char *name,
	     FCacheEntry *existing_entry,
	     CredCacheEntry *ce)
{
    ConnCacheEntry *conn = NULL;
    int ret;
    AFSFetchStatus new_status;
    AFSFetchStatus status;
    AFSVolSync volsync;
    fs_server_context context;

    AssertExclLocked(&dir_entry->lock);

    if (connected_mode != CONNECTED)
	return EINVAL;

    ret = init_fs_context(dir_entry, ce, &context);
    if (ret)
	return ret;

    for (conn = find_first_fs (&context);
	 conn != NULL;
	 conn = find_next_fs (&context, conn, ret)) {

	ret = RXAFS_Link (conn->connection,
			  &dir_entry->fid.fid,
			  name,
			  &existing_entry->fid.fid,
			  &new_status,
			  &status,
			  &volsync);
	if (host_downp(ret)) {
	    continue;
	} else if (ret) {
	    free_fs_server_context (&context);
	    arla_warn (ADEBFCACHE, ret, "Link");
	    conn = NULL;
	    goto out;
	}
	conn_ref(conn);
	break;
    }
    free_fs_server_context (&context);

    if (host_downp(ret)) {
	ret = ENETDOWN;
	goto out;
    }

    update_entry (dir_entry, &status, NULL, &volsync,
		  conn, ce->cred);

    update_entry (existing_entry, &new_status, NULL, NULL,
		  conn, ce->cred);

 out:
    if (conn)
	conn_free(conn);
    AssertExclLocked(&dir_entry->lock);
    return ret;
}

/*
 * Remove a file from a directory.
 */

int
remove_file (FCacheEntry *dir_entry, const char *name, CredCacheEntry *ce)
{
    int ret;
    ConnCacheEntry *conn;
    AFSFetchStatus status;
    AFSVolSync volsync;
    fs_server_context context;

    AssertExclLocked(&dir_entry->lock);

    if (connected_mode == CONNECTED) {

	ret = init_fs_context(dir_entry, ce, &context);
	if (ret)
	    return ret;

	for (conn = find_first_fs (&context);
	     conn != NULL;
	     conn = find_next_fs (&context, conn, ret)) {
	    
	    ret = RXAFS_RemoveFile (conn->connection,
				    &dir_entry->fid.fid,
				    name,
				    &status,
				    &volsync);
	    if (host_downp(ret)) {
		continue;
	    } else if (ret) {
		free_fs_server_context (&context);
		arla_warn (ADEBFCACHE, ret, "RemoveFile");
		conn = NULL;
		goto out;
	    }
	    conn_ref(conn);
	    break;
	}
	free_fs_server_context (&context);
	
	if (host_downp(ret))
	    ret = ENETDOWN;

    } else {
	fbuf the_fbuf;
	VenusFid child_fid;
	int fd;

	status = dir_entry->status;
	
	conn = NULL;

	ret = fcache_get_fbuf (dir_entry, &fd, &the_fbuf,
			       O_RDONLY, FBUF_READ|FBUF_SHARED);
	if (ret)
	    goto out;
	
	ret = fdir_lookup(&the_fbuf, &dir_entry->fid, name, &child_fid);
	if (ret == 0) {
	    FCacheEntry *child_entry = NULL;
	    uint32_t disco_id = 0;

	    ret = fcache_find(&child_entry, child_fid);
	    if (ret == 0)
		disco_id = child_entry->disco_id;

	    disco_id = disco_unlink(&dir_entry->fid, &child_fid,
				    name, disco_id);

	    if (child_entry) {
		child_entry->disco_id = disco_id;
		fcache_release(child_entry);
	    }
	    ret = 0;
	}
	    
	fbuf_end (&the_fbuf);
	close (fd);
    }

    if (ret == 0)
	update_entry (dir_entry, &status, NULL, &volsync,
		      conn, ce->cred);

 out:
    if (conn)
	conn_free(conn);
    AssertExclLocked(&dir_entry->lock);
    return ret;
}

/*
 * Remove a directory from a directory.
 */

int
remove_directory (FCacheEntry *dir_entry,
		  const char *name,
		  CredCacheEntry *ce)
{
    int ret;
    ConnCacheEntry *conn;
    AFSFetchStatus status;
    AFSVolSync volsync;
    fs_server_context context;

    AssertExclLocked(&dir_entry->lock);

    if (connected_mode != CONNECTED)
	return EINVAL;

    ret = init_fs_context(dir_entry, ce, &context);
    if (ret)
	return ret;

    for (conn = find_first_fs (&context);
	 conn != NULL;
	 conn = find_next_fs (&context, conn, ret)) {

	ret = RXAFS_RemoveDir (conn->connection,
			       &dir_entry->fid.fid,
			       name,
			       &status,
			       &volsync);
	if (host_downp(ret)) {
	    continue;
	} else if (ret) {
	    free_fs_server_context (&context);
	    arla_warn (ADEBFCACHE, ret, "RemoveDir");
	    conn = NULL;
	    goto out;
	}
	conn_ref(conn);
	break;
    }
    free_fs_server_context (&context);

    if (host_downp(ret)) {
	ret = ENETDOWN;
	goto out;
    }

    update_entry (dir_entry, &status, NULL, &volsync,
		  conn, ce->cred);

 out:
    if (conn)
	conn_free(conn);
    AssertExclLocked(&dir_entry->lock);
    return ret;
}

/*
 * Rename a file
 */

int
rename_file (FCacheEntry *old_dir,
	     const char *old_name,
	     FCacheEntry *new_dir,
	     const char *new_name,
	     CredCacheEntry *ce)
{
    int ret = ARLA_CALL_DEAD;
    ConnCacheEntry *conn;
    AFSFetchStatus orig_status, new_status;
    AFSVolSync volsync;
    fs_server_context context;

    AssertExclLocked(&old_dir->lock);
    AssertExclLocked(&new_dir->lock);

    if (connected_mode != CONNECTED)
	return EINVAL;

    ret = init_fs_context(old_dir, ce, &context);
    if (ret)
	return ret;

    for (conn = find_first_fs (&context);
	 conn != NULL;
	 conn = find_next_fs (&context, conn, ret)) {

	ret = RXAFS_Rename (conn->connection,
			    &old_dir->fid.fid,
			    old_name,
			    &new_dir->fid.fid,
			    new_name,
			    &orig_status,
			    &new_status,
			    &volsync);
	if (host_downp(ret)) {
	    continue;
	} else if (ret) {
	    free_fs_server_context (&context);
	    arla_warn (ADEBFCACHE, ret, "Rename");
	    conn = NULL;
	    goto out;
	}
	conn_ref(conn);
	break;
    }
    free_fs_server_context (&context);

    if (host_downp(ret)) {
	ret = ENETDOWN;
	goto out;
    }

    update_entry (old_dir, &orig_status, NULL, &volsync,
		  conn, ce->cred);

    update_entry (new_dir, &new_status, NULL, &volsync,
		  conn, ce->cred);

 out:
    if (conn)
	conn_free(conn);
    AssertExclLocked(&old_dir->lock);
    AssertExclLocked(&new_dir->lock);
    return ret;
}

/*
 * Return the fid to the root.
 */

int
getroot (VenusFid *res, CredCacheEntry *ce)
{
    VolCacheEntry *ve;
    VenusFid fid;
    const char *root_volume = volcache_get_rootvolume ();
    int ret;
    const char *this_cell = cell_getthiscell ();
    int32_t this_cell_id;

    if (dynroot_enablep()) {
	this_cell = "dynroot";
	this_cell_id = dynroot_cellid();
    } else {
	this_cell_id = cell_name2num (this_cell);
	if (this_cell_id == -1)
	    arla_errx (1, ADEBERROR, "cell %s does not exist", this_cell);
    }

    ret = volcache_getbyname (root_volume, this_cell_id, ce, &ve, NULL);
    if (ret) {
	arla_warn (ADEBWARN, ret,
		   "Cannot find the root volume (%s) in cell %s",
		   root_volume, this_cell);
	return ret;
    }

    fid.Cell = this_cell_id;
    if (ve->entry.flags & VLF_ROEXISTS) {
	fid.fid.Volume = ve->entry.volumeId[ROVOL];
    } else if (ve->entry.flags & VLF_RWEXISTS) {
	arla_warnx(ADEBERROR,
		   "getroot: %s in cell %s is missing a RO clone, not good",
		   root_volume, this_cell);
	fid.fid.Volume = ve->entry.volumeId[RWVOL];
    } else {
	arla_errx(1, ADEBERROR,
		  "getroot: %s in cell %s has no RW or RO clone?",
		  root_volume, this_cell);
    }
    fid.fid.Vnode = fid.fid.Unique = 1;

    volcache_free (ve);

    *res = fid;
    return 0;
}

/*
 * Return the type for this volume.
 */

static long
gettype (int32_t volid, const VolCacheEntry *ve)
{
    int i;

    for (i = RWVOL; i <= BACKVOL; ++i)
	if (ve->entry.volumeId[i] == volid)
	    return i;
    assert (FALSE);
    return -1; /* NOT REACHED */
}

/*
 * Return the entry for `fid' or NULL.
 */

int
fcache_find (FCacheEntry **res, VenusFid fid)
{
    *res = find_entry (fid);
    if (*res != NULL)
	return 0;
    else
	return -1;
}

/*
 * Return the entry for `fid'.  If it's not cached, add it.
 */

int
fcache_get (FCacheEntry **res, VenusFid fid, CredCacheEntry *ce)
{
    FCacheEntry *old;
    FCacheEntry *e;
    VolCacheEntry *vol;
    int i, error;

    *res = NULL;

    old = find_entry (fid);
    if (old) {
	assert (old->flags.usedp);
	*res = old;
	return 0;
    }

    error = volcache_getbyid (fid.fid.Volume, fid.Cell, ce, &vol, NULL);
    if (error) {
	if (connected_mode == DISCONNECTED && error == ENOENT)
	    return ENETDOWN;
	return error;
    }

    e = find_free_entry ();
    if (e == NULL) {
	    arla_warnx(ADEBMISC, "find_free_entry failed");
	    return(-1);
    }

    old = find_entry (fid);
    if (old) {
	AssertExclLocked(&e->lock);
	ReleaseWriteLock (&e->lock);

	e->lru_le = listaddtail (lrulist, e);
	if (e->lru_le == NULL)
		exit(-1);

	if (!old->flags.usedp) 
		exit(-1);
	*res = old;
	return 0;
    }

    e->fid     	       = fid;
    e->refcount        = 0;
    e->host	       = 0;
    e->length          = 0;
    e->wanted_length   = 0;
    e->fetched_length  = 0;
    memset (&e->status,   0, sizeof(e->status));
    memset (&e->callback, 0, sizeof(e->callback));
    memset (&e->volsync,  0, sizeof(e->volsync));
    for (i = 0; i < NACCESS; i++) {
	e->acccache[i].cred = ARLA_NO_AUTH_CRED;
	e->acccache[i].access = 0;
    }
    e->anonaccess      = 0;
    e->flags.usedp     = TRUE;
    e->flags.attrp     = FALSE;
    e->flags.attrusedp = FALSE;
    e->flags.datausedp = FALSE;
    e->flags.extradirp = FALSE;
    e->flags.mountp    = FALSE;
    e->flags.fake_mp   = FALSE;
    e->flags.vol_root  = FALSE;
    e->flags.kernelp   = FALSE;
    e->flags.sentenced = FALSE;
    e->flags.silly     = FALSE;
    e->tokens          = 0;
    memset (&e->parent, 0, sizeof(e->parent));
    e->lru_le = listaddhead (lrulist, e);
    if(!e->lru_le)
	    exit(-1);
    e->invalid_ptr     = -1;
    e->volume	       = vol;
    e->priority	       = fprio_get(fid);
    e->hits	       = 0;
    e->cleanergen      = 0;
    
    hashtabadd (hashtab, e);

    *res = e;
    return 0;
}

/*
 * Release the lock on `e' and mark it as stale if it has been sentenced.
 */

void
fcache_release (FCacheEntry *e)
{
    AssertExclLocked(&e->lock);

    ReleaseWriteLock (&e->lock);

    if (e->flags.sentenced) {
	AFSCallBack broken_callback = {0, 0, CBDROPPED};

	stale (e, broken_callback);
	e->flags.sentenced = FALSE;
    }
}

/*
 *
 */

static Bool
uptodatep (FCacheEntry *e)
{
    struct timeval tv;
    assert (e->flags.usedp);

    if (connected_mode != CONNECTED && 
	connected_mode != FETCH_ONLY)
	return TRUE;

    gettimeofday(&tv, NULL);
    
    if (tv.tv_sec < e->callback.ExpirationTime &&
	e->callback.CallBackType != CBDROPPED &&
	(e->callback.CallBackType != 0
	 || e->volume->volsync.spare1 != e->volsync.spare1))
        return TRUE;
    
    return FALSE;
}

/*
 * The idea is that we start to stat everything after the prefered
 * entry, everything before that is probably not useful to get, the
 * user is probably trying to stat() everything _after_ that node.
 * This might be somewhat bogus, but we dont care (for now).
 */

struct bulkstat {
    int 		len;		   /* used entries in fids and names */
    AFSFid		fids[AFSCBMAX];    /* fids to fetch */
    char		*names[AFSCBMAX];  /* names it install */
    AFSFid		*used;		   /* do we have a prefered node */
    CredCacheEntry	*ce;		   /* cred to use */
};

typedef union {
    struct nnpfs_message_installnode node;
    struct nnpfs_message_installattr attr;
} nnpfs_message_install_node_attr;

static int
bulkstat_help_func (VenusFid *fid, const char *name, void *ptr)
{
    struct bulkstat *bs = (struct bulkstat *) ptr;
    AccessEntry *ae;
    FCacheEntry key;
    FCacheEntry *e;

    /* Is bs full ? */
    if (bs->len > fcache_bulkstatus_num)
	return 0;

    /* Ignore . and .. */
    if (strcmp(name, ".") == 0 || strcmp(name, "..") == 0)
	return 0;

    /* 
     * Do we have a prefered node, and is this the one. If we don't know
     * the name of the node (ie bs.names[0] == NULL), fill it in.
     * Set bs->used to NULL it indicate that we should start stat stuff
     * from here, remeber that bs->len == 1 if bs->used is set.
     */
    if (bs->used) { 
	if (memcmp(bs->used, &fid->fid, sizeof(fid->fid)) == 0) {
	    if (bs->names[0] == NULL)
		bs->names[0] = strdup (name);
	    bs->used = NULL; /* stat everything after this */
	}
	return 0;
    }

    /*
     * Already cached for this pag ?
     */
    key.fid = *fid;
    e = (FCacheEntry *)hashtabsearch (hashtab, (void *)&key);
    if (e 
	&& e->flags.usedp
	&& e->flags.attrp
	&& uptodatep (e)
	&& findaccess (bs->ce->cred, e->acccache, &ae) == TRUE) {
	arla_warnx (ADEBFCACHE, 
		    "bulkstat_help_func: already cached "
		    "(%d.%d.%d.%d) name: %s",
		    fid->Cell, fid->fid.Volume, fid->fid.Vnode, 
		    fid->fid.Unique, name);
	return 0;
    }

    if (fcache_enable_bulkstatus == 2) {
	/* cache the name for the installnode */
	bs->names[bs->len] = strdup (name);
	if (bs->names[bs->len] == NULL)
	    return 0;
    } else {
	bs->names[bs->len] = NULL;
    }
    

    bs->fids[bs->len] = fid->fid;
    bs->len++;

    return 0;
}

/*
 * Do bulkstat for ``parent_entry''. Make sure that ``prefered_entry''
 * is in the list of fids it not NULL, and it ``prefered_name'' is NULL
 * try to find it in the list files in the directory.
 *
 * 			Entry		Success		Failure
 * parent_entry		locked		locked		locked
 * prefered_entry	locked		locked		locked
 *   or if NULL		if set to NULL must not be locked
 * prefered_fid		related fcache-entry must not be locked
 * ce			not NULL
 */

static int
get_attr_bulk (FCacheEntry *parent_entry, 
	       FCacheEntry *prefered_entry,
	       VenusFid *prefered_fid, 
	       const char *prefered_name,
	       CredCacheEntry *ce)
{
    fs_server_context context;
    ConnCacheEntry *conn = NULL;
    struct bulkstat bs;
    AFSBulkStats stats;
    AFSVolSync sync;
    AFSCBFids fids;
    fbuf the_fbuf;
    int ret, fd;
    AFSCBs cbs;
    int i;
    int len;
    struct collect_stat collectstat;

    arla_warnx (ADEBFCACHE, "get_attr_bulk");

    if (fcache_enable_bulkstatus == 0)
	return -1;

    if (parent_entry->length == 0) {
	arla_warnx (ADEBFCACHE, "get_attr_bulk: parent doesn't have data");
	return -1;
    }
    
    fids.val = bs.fids;

    memset (bs.names, 0, sizeof(bs.names));
    memset (bs.fids,  0, sizeof(bs.fids));
    bs.len	= 0;
    bs.ce	= ce;
    bs.used	= NULL;
    
    /*
     * If we have a prefered_entry, and that to the first entry in the
     * array. This is used later. If we find the prefered_entry in the
     * directory-structure its ignored.
     */

    if (prefered_fid) {
	arla_warnx (ADEBFCACHE, "get_attr_bulk: using prefered_entry");
	bs.used			= &prefered_fid->fid;
	fids.val[bs.len]	= prefered_fid->fid;
	if (prefered_name != NULL) {
	    bs.names[bs.len]	= strdup(prefered_name);
	    if (bs.names[bs.len] == NULL)
		return ENOMEM;
	} else {
	    bs.names[bs.len]    = NULL;
	}
	bs.len++;
    }

    ret = fcache_get_fbuf (parent_entry, &fd, &the_fbuf,
			   O_RDONLY, FBUF_READ|FBUF_SHARED);
    if (ret)
	return ret;

    ret = fdir_readdir (&the_fbuf,
			bulkstat_help_func,
			&bs,
			parent_entry->fid,
			NULL);
    fbuf_end (&the_fbuf);
    close (fd);
    if (ret)
	goto out_names;
    
    fids.len = bs.len;

    /*
     * Don't do BulkStatus when fids.len == 0 since we should never do it.
     * There should at least be the node that we want in the BulkStatus.
     */

    if (fids.len == 0) {
	if (prefered_fid)
	    arla_warnx (ADEBERROR, 
			"get_attr_bulk: "
			"prefered_fid not found in dir");
	/* XXX MAGIC send it back so we don't do it again soon */
	parent_entry->hits -= 64;
	ret = EINVAL;
	goto out_names;
    }

    /*
     * XXX if there is a prefered fid, and and we didn't find the name for it
     * return an error.
     */

    if (prefered_fid && bs.names[0] == NULL) {
	arla_warnx (ADEBFCACHE, 
		    "get_attr_bulk: didn't find prefered_fid's name");
	ret = EINVAL;
	goto out_names;
    }
    
    ret = ARLA_CALL_DEAD;

    ret = init_fs_context(parent_entry, ce, &context);
    if (ret)
	return ret;

    for (conn = find_first_fs (&context);
	 conn != NULL;
	 conn = find_next_fs (&context, conn, ret)) {

	stats.val = NULL;
	cbs.val   = NULL;
	stats.len = cbs.len = 0;

	collectstats_start(&collectstat);
	ret = RXAFS_BulkStatus (conn->connection, &fids, &stats, &cbs, &sync);
	collectstats_stop(&collectstat, parent_entry, conn,
			  find_partition(&context),
			  STATISTICS_REQTYPE_BULKSTATUS, fids.len);
	if (ret) {
	    free (stats.val);
	    free (cbs.val);
	}

	if (host_downp(ret)) {
	    continue;
	} else if (ret) {
	    free_fs_server_context(&context);
	    arla_warn(ADEBFCACHE, ret, "BulkStatus");
	    conn = NULL;
	    goto out_names;
	}
	conn_ref(conn);
	break;
    }

    free_fs_server_context (&context);

    if (ret) {
	ret = ENETDOWN;
	goto out_names;
    }

    arla_warnx (ADEBFCACHE,"get_attr_bulk: BulkStatus returned %d",ret);
    
    len = min(fids.len, min(stats.len, cbs.len));

    /*
     * Save results of bulkstatus
     */

    if (ret == 0) {
	FCacheEntry *e;
	VenusFid fid;

	fcache_counter.fetch_attr_bulk += len;

	fid.Cell = parent_entry->fid.Cell;
	for (i = 0; i < len && ret == 0; i++) {

	    fid.fid = fids.val[i];
	    
	    if (VenusFid_cmp(prefered_fid, &fid) == 0) {
		e = prefered_entry;
	    } else {
		e = find_entry_nolock (fid);
		if (e != NULL && CheckLock(&e->lock) != 0)
		    continue;

		ret = fcache_get (&e, fid, ce);
		if (ret)
		    break;
	    }
	    update_attr_entry (e,
			       &stats.val[i],
			       &cbs.val[i],
			       &sync,
			       conn,
			       ce->cred);
	    e->parent		= parent_entry->fid;
	    if (prefered_entry != e) {
		fcache_release(e);
	    }
	}
    }

    /*
     * Insert result into kernel
     */

    if (fcache_enable_bulkstatus == 2 && ret == 0)  {
	nnpfs_message_install_node_attr msg[AFSCBMAX];
	struct nnpfs_msg_node *node;
	nnpfs_handle *parent;
	FCacheEntry *e;
	VenusFid fid;
	int j;

	fid.Cell = parent_entry->fid.Cell;
	for (i = 0 , j = 0; i < len && ret == 0; i++) {
	    u_int tokens;

	    fid.fid = fids.val[i];
	    
	    if (VenusFid_cmp(prefered_fid, &fid) == 0) {
		e = prefered_entry;
	    } else {
		e = find_entry_nolock (fid);
		if (e != NULL && CheckLock(&e->lock) != 0)
		    continue;

		ret = fcache_get (&e, fid, ce);
		if (ret)
		    break;
	    }


	    arla_warnx (ADEBFCACHE, "installing %d.%d.%d\n",
			e->fid.fid.Volume,
			e->fid.fid.Vnode,
			e->fid.fid.Unique);
	    assert_flag(e,kernelp);
	    e->flags.attrusedp 	= TRUE;
	    
	    /*
	     * Its its already installed, just update with installattr
	     */
	    
	    e->tokens			|= NNPFS_ATTR_R;
	    tokens				= e->tokens;
	    if (!e->flags.kernelp || !e->flags.datausedp)
		tokens			&= ~NNPFS_DATA_MASK;
	    
	    if (e->flags.kernelp) {
		msg[j].attr.header.opcode	= NNPFS_MSG_INSTALLATTR;
		node			= &msg[j].attr.node;
		parent			= NULL;
	    } else {
		msg[j].node.header.opcode	= NNPFS_MSG_INSTALLNODE;
		node			= &msg[j].node.node;
		parent			= &msg[j].node.parent_handle;
		e->flags.kernelp		= TRUE;
		strlcpy (msg[j].node.name, bs.names[i],
			 sizeof(msg[j].node.name));
	    }
	    node->tokens = tokens;
	    
	    /*
	     * Don't install symlink since they might be
	     * mount-points.
	     */
	    
	    if (e->status.FileType != TYPE_LINK) {
		fcacheentry2nnpfsnode (&e->fid,
				       &e->fid,
				       &stats.val[i],
				       node, 
				       parent_entry->acccache,
				       FCACHE2NNPFSNODE_ALL);
		
		if (parent)
		    *parent = *(struct nnpfs_handle*) &parent_entry->fid;
		j++;
	    }
	    if (prefered_entry != e)
		fcache_release(e);
	}

	/*
	 * Install if there is no error and we have something to install
	 */
	
	if (ret == 0 && j != 0)
	    ret = nnpfs_send_message_multiple_list (kernel_fd,
						    (struct nnpfs_message_header *) msg,
						    sizeof (msg[0]),
						    j);
	/* We have what we wanted, ignore errors */
  	if (ret && i > 0 && prefered_entry)
	    ret = 0;
    }
    
    free (stats.val);
    free (cbs.val);

 out_names:
    for (i = 0 ; i < bs.len && ret == 0; i++)
	free (bs.names[i]);

    if (conn)
	conn_free(conn);

    arla_warnx (ADEBFCACHE, "get_attr_bulk: returned %d", ret);

    return ret;
}


/*
 * fetch attributes for the note `entry' with the rights `ce'.  If
 * `parent_entry' is no NULL, its used for doing bulkstatus when guess
 * necessary. If there is a named associated with `entry' it should be
 * filled into `prefered_name' as that will be used for guessing that
 * nodes should be bulkstat:ed.
 *
 * If there is no bulkstatus done, a plain FetchStatus is done.
 */

int
fcache_verify_attr (FCacheEntry *entry, FCacheEntry *parent,
		    const char *prefered_name, CredCacheEntry* ce)
{
    AccessEntry *ae;

    if (dynroot_is_dynrootp (entry))
	return dynroot_get_attr (entry, ce);

    if (entry->flags.usedp
	&& entry->flags.attrp
	&& uptodatep(entry)
	&& findaccess (ce->cred, entry->acccache, &ae) == TRUE)
    {
	arla_warnx (ADEBFCACHE, "fcache_get_attr: have attr");
	fcache_counter.fetch_attr_cached++;
	return 0;
    }

    /* 
     * XXX is this right ?
     * Dont ask fileserver if this file is deleted
     */
    if (entry->flags.silly) {
	entry->tokens |= NNPFS_ATTR_R;
	entry->flags.attrp = TRUE;
	return 0;
    }

    if (connected_mode == DISCONNECTED) {
	if (entry->flags.attrp) {
	    AccessEntry *ae;
	    findaccess(ce->cred, entry->acccache, &ae);
	    ae->cred = ce->cred;
	    ae->access = 0x7f; /* XXXDISCO */
	    return 0;
	}
	else
	    return ENETDOWN;
    }

    /*
     * If there is no parent, `entry' is a root-node, or the parent is
     * un-initialized, don't bother bulkstatus.
     */
    if (parent			    != NULL
	&& entry->fid.fid.Vnode     != 1
	&& entry->fid.fid.Unique    != 1
	&& !entry->flags.mountp
	&& !entry->flags.fake_mp
	&& entry->parent.Cell       != 0
	&& entry->parent.fid.Volume != 0
	&& entry->parent.fid.Vnode  != 0
	&& entry->parent.fid.Unique != 0)
    {
	/*
	 * Check if the entry is used, that means that
	 * there is greater chance that we we'll succeed
	 * when doing bulkstatus.
	 */

	if (parent->hits++ > fcache_bulkstatus_num &&
	    parent->flags.datausedp) {
	    int error;
	
	    arla_warnx (ADEBFCACHE, "fcache_get_attr: doing bulk get_attr");

	    error = get_attr_bulk (parent,
				   entry, &entry->fid,
				   prefered_name, ce);
	    /* magic calculation when we are going to do next bulkstat */
	    parent->hits = 0;

	    if (error == 0)
		return 0;
	}
    }

    /*
     * We got here because the bulkstatus failed, didn't want to do a
     * bulkstatus or we didn't get a parent for the entry
     */

    arla_warnx (ADEBFCACHE, "fcache_get_attr: doing read_attr");

    return read_attr (entry, ce);
}



/*
 * Make sure that `e' has attributes and that they are up-to-date.
 * `e' must be write-locked.
 */


static int
do_read_data (FCacheEntry *e, CredCacheEntry *ce)
{
    int ret = ARLA_CALL_DEAD;
    fs_server_context context;
    ConnCacheEntry *conn;

    if (connected_mode != CONNECTED)
	return ENETDOWN;

    ret = init_fs_context(e, ce, &context);
    if (ret)
	return ret;

    for (conn = find_first_fs (&context);
	 conn != NULL;
	 conn = find_next_fs (&context, conn, ret)) {
	ret = read_data (e, conn, ce, find_partition(&context));
	if (!try_next_fs (ret, &e->fid))
	    break;
    }
    free_fs_server_context (&context);

    if (host_downp(ret))
	ret = ENETDOWN;
    return ret;
}

/*
 * Make sure that `e' has file data and is up-to-date.
 */

int
fcache_verify_data (FCacheEntry *e, CredCacheEntry *ce)
{
    ConnCacheEntry *conn = NULL;
    int ret;
    fs_server_context context;

    assert (e->flags.usedp);
    AssertExclLocked(&e->lock);

    if (dynroot_is_dynrootp (e))
	return dynroot_get_data (e, ce);

    /* Don't get data for deleted files */
    if (e->flags.silly)
	return 0;

    if (e->flags.attrp && uptodatep(e)) {
	if (e->wanted_length <= e->fetched_length) {
	    fcache_counter.fetch_data_cached++;
	    return 0;
	} else
	    return do_read_data (e, ce);
    } else {
	ret = do_read_attr (e, ce, &conn, &context);
	if (ret)
	    return ret;
	if (e->wanted_length <= e->fetched_length) {
	    fcache_counter.fetch_data_cached++;
	    free_fs_server_context (&context);
	    return 0;
	}
    }
    ret = read_data (e, conn, ce, find_partition(&context));
    free_fs_server_context (&context);
    return ret;
}

/*
 * Fetch `fid' with data, returning the cache entry in `res'.
 * note that `fid' might change.
 */

int
fcache_get_data (FCacheEntry **e, CredCacheEntry **ce,
		 size_t wanted_length)
{
    int ret;

    if ((*e)->flags.fake_mp) {
	VenusFid new_fid;
	FCacheEntry *new_root;

	ret = resolve_mp (e, &new_fid, ce);
	if (ret) {
	    return ret;
	}
	ret = fcache_get (&new_root, new_fid, *ce);
	if (ret) {
	    return ret;
	}
	ret = fcache_verify_attr (new_root, NULL, NULL, *ce);
	if (ret) {
	    fcache_release (new_root);
	    return ret;
	}
	(*e)->flags.fake_mp   = FALSE;
	(*e)->flags.mountp    = TRUE;
	(*e)->status.FileType = TYPE_LINK;
	update_fid ((*e)->fid, *e, new_fid, new_root);
	fcache_release (*e);
	*e  = new_root;
	install_attr (*e, FCACHE2NNPFSNODE_ALL);
    }

    if (wanted_length) {
	(*e)->wanted_length = wanted_length;
    } else {
	/*
	 * XXX remove this case, attr should either be known already
	 * here, or we should just fetch `whole file'/next block.
	 */

        ret = fcache_verify_attr (*e, NULL, NULL, *ce);
        if (ret) {
            return ret;
        }
        if ((*e)->length == 0 || !uptodatep(*e)) {
            (*e)->wanted_length = (*e)->status.Length;
        }
    }
	
    ret = fcache_verify_data (*e, *ce);
    return ret;
}

/*
 * Helper function for followmountpoint.
 * Given the contents of a mount-point, figure out the cell and volume name.
 *
 * ``mp'' must be writeable and should not be used afterwards.
 * ``*volname'' is a pointer to somewhere in the mp string.
 * ``cell'' should be set before function is called to default cell.
 */

static int
parse_mountpoint (char *mp, size_t len, int32_t *cell, char **volname)
{
    char *colon;
    
    mp[len - 1] = '\0';
    colon = strchr (mp, ':');
    if (colon != NULL) {
	*colon++ = '\0';
	*cell    = cell_name2num (mp + 1);
	if (*cell == -1)
	    return ENOENT;
	*volname = colon;
    } else {
	*volname = mp + 1;
    }
    return 0;
}

/*
 * Used by followmountpoint to figure out what clone of a volume
 * should be used.
 *
 * Given a `volname', `cell', it uses the given `ce', `mount_symbol'
 * and `parent_type' to return a volume id in `volume'.
 *
 * The rules are:
 *
 * "readonly" -> RO
 * BK + "backup" -> fail
 * "backup" -> BK
 * BK + "" + # -> RO
 * RO + "" + # -> RO
 * * -> RW
 *
 * this_type = "" | "readonly" | "backup"
 * parent_type = RW | RO | BK
 * mount_symbol = "#" | "%"
 */

static int
find_volume (const char *volname, int32_t cell, 
	     CredCacheEntry *ce, char mount_symbol, int parent_type,
	     uint32_t *volid, VolCacheEntry **ve)
{
    int result_type;
    int this_type;
    int res;

    res = volcache_getbyname (volname, cell, ce, ve, &this_type);
    if (res)
	return res;

    assert (this_type == RWVOL ||
	    this_type == ROVOL ||
	    this_type == BACKVOL);

    if (this_type == ROVOL) {
	if (!((*ve)->entry.flags & VLF_ROEXISTS)) {
	    volcache_free (*ve);
	    return ENOENT;
	}
	result_type = ROVOL;
    } else if (this_type == BACKVOL && parent_type == BACKVOL) {
	volcache_free (*ve);
	return ENOENT;
    } else if (this_type == BACKVOL) {
	if (!((*ve)->entry.flags & VLF_BOEXISTS)) {
	    volcache_free (*ve);
	    return ENOENT;
	}
	result_type = BACKVOL;
    } else if (this_type == RWVOL &&
	       parent_type != RWVOL &&
	       mount_symbol == '#') {
	if ((*ve)->entry.flags & VLF_ROEXISTS)
	    result_type = ROVOL;
	else if ((*ve)->entry.flags & VLF_RWEXISTS)
	    result_type = RWVOL;
	else {
	    volcache_free (*ve);
	    return ENOENT;
	}
    } else {
	if ((*ve)->entry.flags & VLF_RWEXISTS)
	    result_type = RWVOL;
	else if ((*ve)->entry.flags & VLF_ROEXISTS)
	    result_type = ROVOL;
	else {
	    volcache_free (*ve);
	    return ENOENT;
	}
    }
    *volid = (*ve)->entry.volumeId[result_type];
    return 0;
}

/*
 * Set `fid' to point to the root of the volume pointed to by the
 * mount-point in (buf, len).
 *
 * If succesful, `fid' will be update to the root of the volume, and
 * `ce' will point to a cred in the new cell.
 */

static int
get_root_of_volume (VenusFid *fid, const VenusFid *parent,
		    VolCacheEntry *volume,
		    CredCacheEntry **ce,
		    char *buf, size_t len)
{
    VenusFid oldfid = *fid;
    char *volname;
    int32_t cell;
    uint32_t volid;
    int res;
    long parent_type;
    char mount_symbol;
    VolCacheEntry *ve;
    FCacheEntry *e;

    cell = fid->Cell;

    res = parse_mountpoint (buf, len, &cell, &volname);
    if (res)
	return res;

    /*
     * If this is a cross-cell mountpoint we need new credentials. 
     */

    if ((*ce)->cell != cell) {
	CredCacheEntry *new_ce;

	new_ce = cred_get(cell, (*ce)->cred, CRED_ANY);
	if (new_ce == NULL)
	    return ENOMEM;
	cred_free (*ce);
	*ce = new_ce;
    }

    parent_type = gettype (fid->fid.Volume, volume);
    mount_symbol = *buf;

    res = find_volume (volname, cell, *ce, mount_symbol,
		       parent_type, &volid, &ve);
    if (res)
	return res;

    /*
     * Create the new fid. The root of a volume always has
     * (Vnode, Unique) = (1,1)
     */

    fid->Cell = cell;
    fid->fid.Volume = volid;
    fid->fid.Vnode = fid->fid.Unique = 1;

    /*
     * Check if we are looking up ourself, if we are, just return.
     */

    if (VenusFid_cmp(fid, parent) == 0) {
	volcache_free (ve);
	return 0;
    }

    res = fcache_get (&e, *fid, *ce);
    if (res) {
	volcache_free (ve);
	return res;
    }

    /*
     * Root nodes are a little bit special.  We keep track of
     * their parent in `parent' so that `..' can be handled
     * properly.
     */

    e->flags.vol_root  = TRUE;
    e->parent          = *parent;
    if (ve->parent == NULL) {
	ve->parent_fid = *parent;
	ve->mp_fid     = oldfid;
    }
    volcache_volref (ve, volume);
    fcache_release (e);
    volcache_free (ve);
    return 0;
}

/*
 * If this entry is a mount point, set the fid data to
 * the root directory of the volume it's pointing at,
 * otherwise just leave it.
 *
 * Mount points are symbol links with the following contents:
 *
 * '#' | '%' [ cell ':' ] volume-name [ '.' ]
 *
 * This function tries to the minimal amount of work.  It always has
 * to fetch the attributes of `fid' and if it's a symbolic link, the
 * contents as well.
 */

int
followmountpoint (VenusFid *fid, const VenusFid *parent, FCacheEntry *parent_e,
		  CredCacheEntry **ce)
{
    FCacheEntry *e;
    int ret;

    /*
     * Get the node for `fid' and verify that it's a symbolic link
     * with the correct bits.  Otherwise, just return the old
     * `fid' without any change.
     */

    ret = fcache_get (&e, *fid, *ce);
    if (ret)
	return ret;

    e->parent = *parent;
    ret = fcache_verify_attr (e, parent_e, NULL, *ce);
    if (ret) {
	fcache_release(e);
	return ret;
    }

    if (e->flags.mountp)
	ret = resolve_mp (&e, fid, ce);
     
    fcache_release(e);
    return ret;
}

/*
 * actually resolve a mount-point
 */

static int
resolve_mp (FCacheEntry **e, VenusFid *ret_fid, CredCacheEntry **ce)
{
    VenusFid fid = (*e)->fid;
    int ret;
    fbuf the_fbuf;
    char *buf;
    int fd;
    uint32_t length;

    assert ((*e)->flags.fake_mp || (*e)->flags.mountp);
    AssertExclLocked(&(*e)->lock);

    (*e)->wanted_length = (*e)->status.Length;

    ret = fcache_verify_data (*e, *ce);
    if (ret)
	return ret;

    length = (*e)->status.Length;

    fd = fcache_open_file (*e, O_RDONLY);
    if (fd < 0)
	return errno;

    ret = fbuf_create (&the_fbuf, fd, length,
		       FBUF_READ|FBUF_WRITE|FBUF_PRIVATE);
    if (ret) {
	close (fd);
	return ret;
    }
    buf = fbuf_buf (&the_fbuf);

    ret = get_root_of_volume (&fid, &(*e)->parent, (*e)->volume, 
			      ce, buf, length);

    fbuf_end (&the_fbuf);
    close (fd);
    if (ret) 
	return ret;
    *ret_fid = fid;
    return 0;
}

/*
 *
 */

static Bool
print_entry (void *ptr, void *arg)
{
    FCacheEntry *e = (FCacheEntry *)ptr;

    arla_log(ADEBVLOG, "(%d, %u, %u, %u)%s%s%s%s%s%s%s%s%s%s%s length: %ld",
	     e->fid.Cell,
	     e->fid.fid.Volume, e->fid.fid.Vnode, e->fid.fid.Unique,
	     e->flags.usedp?" used":"",
	     e->flags.attrp?" attr":"",
	     e->length != 0 ?" data":"",
	     e->flags.attrusedp?" attrused":"",
	     e->flags.datausedp?" dataused":"",
	     e->flags.extradirp?" extradir":"",
	     e->flags.mountp?" mount":"",
	     e->flags.kernelp?" kernel":"",
	     e->flags.sentenced?" sentenced":"",
	     e->flags.silly?" silly":"",
	     e->flags.fake_mp ? " fake mp" : "",
	     e->flags.vol_root ? " vol root" : "",
	     e->status.Length);
    return FALSE;
}


/*
 *
 */

void
fcache_status (void)
{
    arla_log(ADEBVLOG, "%lu (%lu-/%lu)-%lu) files"
	     "%lu (%lu-%lu) bytes\n",
	     usedvnodes, lowvnodes, current_vnodes, highvnodes,
	     (long)usedbytes, (long)lowbytes, (long)highbytes);
    hashtabforeach (hashtab, print_entry, NULL);
}

/*
 *
 */

void
fcache_update_length (FCacheEntry *e, size_t len, size_t have_len)
{
    AssertExclLocked(&e->lock);

    assert (len >= e->length || e->length - len <= usedbytes);
    assert (have_len <= len);

    usedbytes = usedbytes - e->length + len;
    e->length = len;
    e->wanted_length = min(have_len,len);
    e->fetched_length = have_len;
}

/*
 * Request an ACL and put it in opaque
 */

int
getacl(VenusFid fid,
       CredCacheEntry *ce,
       AFSOpaque *opaque)
{
    FCacheEntry *dire;
    ConnCacheEntry *conn;
    AFSFetchStatus status;
    AFSVolSync volsync;
    int ret;
    fs_server_context context;
  
    opaque->val = NULL;
    opaque->len = 0;

    if (connected_mode != CONNECTED)
	return EINVAL;

    ret = fcache_get (&dire, fid, ce);
    if (ret) {
	arla_warn (ADEBFCACHE, ret, "fcache_get");
	return ret;
    }

    ret = init_fs_context(dire, ce, &context);
    if (ret)
	return ret;

    for (conn = find_first_fs (&context);
	 conn != NULL;
	 conn = find_next_fs (&context, conn, ret)) {

	ret = RXAFS_FetchACL (conn->connection, &fid.fid,
			      opaque, &status, &volsync);
	if (ret) {
	    free(opaque->val);
	    opaque->val = NULL;
	    opaque->len = 0;
	}

	if (!try_next_fs (ret, &fid))
	    break;
    }
    if (ret)
	arla_warn (ADEBFCACHE, ret, "FetchACL");

    if (ret == 0)
	update_entry (dire, &status, NULL, &volsync,
		      conn, ce->cred);
    else if (host_downp(ret))
	ret = ENETDOWN;

    free_fs_server_context (&context);
    fcache_release (dire);
    return ret;
}

/*
 * Store the ACL read from opaque
 *
 * If the function return 0, ret_e is set to the dir-entry and must
 * be fcache_released().
 */

int
setacl(VenusFid fid,
       CredCacheEntry *ce,
       AFSOpaque *opaque,
       FCacheEntry **ret_e)
{
    FCacheEntry *dire;
    ConnCacheEntry *conn;
    AFSFetchStatus status;
    AFSVolSync volsync;
    int ret;
    fs_server_context context;
  
    if (connected_mode != CONNECTED)
	return EINVAL;

    ret = fcache_get (&dire, fid, ce);
    if (ret) {
	arla_warn (ADEBFCACHE, ret, "fcache_get");
	return EINVAL;
    }

    ret = init_fs_context(dire, ce, &context);
    if (ret)
	return ret;

    for (conn = find_first_fs (&context);
	 conn != NULL;
	 conn = find_next_fs (&context, conn, ret)) {
	ret = RXAFS_StoreACL (conn->connection, &fid.fid,
			      opaque, &status, &volsync);
	if (!try_next_fs (ret, &fid))
	    break;
    }
    if (ret)
	arla_warn (ADEBFCACHE, ret, "StoreACL");

    if (ret == 0)
	update_entry (dire, &status, NULL, &volsync,
		      conn, ce->cred);
    else if (host_downp(ret))
	ret = ENETDOWN;

    free_fs_server_context (&context);

    if (ret == 0) {
	*ret_e = dire;
    } else {
	*ret_e = NULL;
	fcache_release (dire);
    }
    return ret;
}

/*
 * Request volume status
 */

int
getvolstat(VenusFid fid, CredCacheEntry *ce,
	   AFSFetchVolumeStatus *volstat,
	   char *volumename, size_t volumenamesz,
	   char *offlinemsg,
	   char *motd)
{
    FCacheEntry *dire;
    ConnCacheEntry *conn;
    int ret;
    fs_server_context context;
  
    if (connected_mode != CONNECTED)
	return EINVAL;

    ret = fcache_get (&dire, fid, ce);
    if (ret) {
	arla_warn (ADEBFCACHE, ret, "fcache_get");
	return EINVAL;
    }

    ret = init_fs_context(dire, ce, &context);
    if (ret)
	return ret;

    for (conn = find_first_fs (&context);
	 conn != NULL;
	 conn = find_next_fs (&context, conn, ret)) {
	ret = RXAFS_GetVolumeStatus (conn->connection, fid.fid.Volume,
				     volstat, volumename, offlinemsg,
				     motd);
	if (!try_next_fs (ret, &fid))
	    break;
    }
    if (ret)
	arla_warn (ADEBFCACHE, ret, "GetVolumeStatus");
    free_fs_server_context (&context);
    if (host_downp(ret))
	ret = ENETDOWN;
    if (ret == 0 && volumename[0] == '\0') {
	if (volcache_getname (fid.fid.Volume, fid.Cell,
			      volumename, volumenamesz) == -1)
	    strlcpy(volumename, "<unknown>", volumenamesz);
    }

    fcache_release (dire);
    return ret;
}

/*
 * Store volume status
 */

int
setvolstat(VenusFid fid, CredCacheEntry *ce,
	   AFSStoreVolumeStatus *volstat,
	   char *volumename,
	   char *offlinemsg,
	   char *motd)
{
    FCacheEntry *dire;
    ConnCacheEntry *conn;
    int ret;
    fs_server_context context;
  
    if (connected_mode != CONNECTED)
	return EINVAL;

    ret = fcache_get (&dire, fid, ce);
    if (ret) {
	arla_warn (ADEBFCACHE, ret, "fcache_get");
	return EINVAL;
    }

    ret = init_fs_context(dire, ce, &context);
    if (ret)
	return ret;

    for (conn = find_first_fs (&context);
	 conn != NULL;
	 conn = find_next_fs (&context, conn, ret)) {
	ret = RXAFS_SetVolumeStatus (conn->connection, fid.fid.Volume,
				     volstat, volumename, offlinemsg,
				     motd);
	if (!try_next_fs (ret, &fid))
	    break;
    }
    if (ret) {
	if (host_downp(ret))
	    ret = ENETDOWN;
	arla_warn (ADEBFCACHE, ret, "SetVolumeStatus");
    }
    free_fs_server_context (&context);

    fcache_release (dire);
    return ret;
}

/*
 * Get `fbuf' from `centry' that is opened with openflags
 * `open_flags' and fbuf flags with `fbuf_flags'
 *
 * Assume that data is valid and `centry' is exclusive locked.
 */

int
fcache_get_fbuf (FCacheEntry *centry, int *fd, fbuf *fbuf,
		 int open_flags, int fbuf_flags)
{
    int ret;
    unsigned len;
    struct stat sb;

    AssertExclLocked(&centry->lock);

    *fd = fcache_open_file (centry, open_flags);
    if (*fd < 0)
	return errno;

    if (fstat (*fd, &sb)) {
	ret = errno;
	close (*fd);
	return ret;
    }

    len = sb.st_size;

    ret = fbuf_create (fbuf, *fd, len, fbuf_flags);
    if (ret) {
	close (*fd);
	return ret;
    }
    return 0;
}

/*
 *
 */

static Bool 
sum_node (List *list, Listitem *li, void *arg)
{
    int64_t *a = arg;
    FCacheEntry *e = listdata (li);

    *a += e->length;
    
    return FALSE;
}


int64_t
fcache_calculate_usage (void)
{
    int64_t size = 0;

    listiter (lrulist, sum_node, &size);

    return size;
}

/*
 *
 */

const VenusFid *
fcache_realfid (const FCacheEntry *entry)
{
    if (entry->flags.vol_root
	|| (entry->fid.fid.Vnode == 1 && entry->fid.fid.Unique == 1))
	return &entry->volume->mp_fid;
    else
	return &entry->fid;
}
@


1.9
log
@fix snprintf misuse. ok bob@@ hin@@
@
text
@@


1.8
log
@fix bogus assert() usage in afsd, and avoid an assert when
ThisCell is specified as a nonexeistent cell. found by matthieu@@,
ok deraadt@@
@
text
@d511 2
a512 2
	/* XXX CACHEHANDLESIZE */
	ret = snprintf ((char *)handle, 80, "%s\\%02X\\%02X", buf, a, b);
d514 1
a514 1
	if (ret > 0)
@


1.7
log
@afs cleanup, realloc strings, abort, etc.
testing by beck, hin, jose, fries. ok deraadt@@
@
text
@d676 5
a680 1
    assert(usedbytes >= entry->length);
d743 5
a747 2
	assert (ce != NULL);
	
d928 2
a929 1
			assert(entry->lru_le);
d1266 4
a1269 1
    assert (ce != NULL);
d1275 2
a1276 1
    assert(vol);
d1318 2
a1319 1
    assert(e->parent.Cell != -1);
d1325 2
a1326 1
    assert(e->lru_le);
d1428 2
a1429 1
	assert(prev_conn == context->conns[context->i - 1].conn);
d1657 2
a1658 1
	assert(e->lru_le);
d2882 2
a2883 1
	assert(conn == NULL);
d3029 2
a3030 1
	assert(conn == NULL);
d3595 4
a3598 1
    assert (e != NULL);
d3606 2
a3607 1
	assert(e->lru_le);
d3609 2
a3610 1
	assert (old->flags.usedp);
d3643 2
a3644 1
    assert(e->lru_le);
@


1.6
log
@Merge
@
text
@d111 4
d116 1
a116 1
		      maxrecovered);
d958 2
a959 1
		    abort();
@


1.5
log
@Merge in some progname changes, and a couple of bugfixes from arla.
@
text
@d2 1
a2 1
 * Copyright (c) 1995 - 2001 Kungliga Tekniska Högskolan
d40 5
a44 1
RCSID("$KTH: fcache.c,v 1.311.2.20 2001/12/20 16:36:24 mattiasa Exp $") ;
d57 1
a57 1
resolve_mp (FCacheEntry *e, VenusFid *ret_fid, CredCacheEntry **ce);
d86 2
a87 1
static u_long lowvnodes, highvnodes, current_vnodes, lowbytes, highbytes;
d91 30
a120 1
static u_long usedbytes, usedvnodes, needbytes;
d129 1
a129 1
Bool fprioritylevel;
d172 1
a172 1
u_long
d178 1
a178 1
u_long
d184 1
a184 1
u_long
a207 254
#define HISTOGRAM_SLOTS 32
#define STATHASHSIZE 997

/* Struct with collected statistics */
struct collect_stat{
    int64_t starttime;
};

struct time_statistics {
    u_int32_t measure_type;
    u_int32_t host;
    u_int32_t partition;
    u_int32_t measure_items; /* normed by get_histgram_slots */
    u_int32_t count[HISTOGRAM_SLOTS];    
    int64_t measure_items_total[HISTOGRAM_SLOTS];
    int64_t elapsed_time[HISTOGRAM_SLOTS];
};

static unsigned
statistics_hash (void *p)
{
    struct time_statistics *stats = (struct time_statistics*)p;

    return stats->measure_type + stats->host +
	stats->partition * 32 * 32 + stats->measure_items * 32;
}

/*
 * Compare two entries. Return 0 if and only if the same.
 */

static int
statistics_cmp (void *a, void *b)
{
    struct time_statistics *f1 = (struct time_statistics*)a;
    struct time_statistics *f2 = (struct time_statistics*)b;

    return f1->measure_type  != f2->measure_type
	|| f1->host          != f2->host
	|| f1->partition     != f2->partition
	|| f1->measure_items != f2->measure_items;
}

static Hashtab *statistics;

static int
get_histogram_slot(u_int32_t value)
{
    int i;

    for (i = HISTOGRAM_SLOTS - 1; i > 0; i--) {
	if (value >> i)
	    return i;
    }
    return 0;
}

static void
add_time_statistics(u_int32_t measure_type, u_int32_t host,
		    u_int32_t partition, u_int32_t measure_items,
		    int64_t elapsed_time)
{
    u_int32_t time_slot;
    struct time_statistics *ts;
    struct time_statistics *ts2;

    ts = malloc(sizeof(*ts));

    time_slot = get_histogram_slot(elapsed_time);
    ts->measure_type = measure_type;
    ts->measure_items = get_histogram_slot(measure_items);
    ts->host = host;
    ts->partition = partition;
    ts2 = hashtabsearch (statistics, (void*)(ts));
    if (ts2) {
	ts2->count[time_slot]++;
	ts2->elapsed_time[time_slot] += elapsed_time;
	ts2->measure_items_total[time_slot] += measure_items;
	free(ts);
    } else {
	memset(ts->count, 0, sizeof(ts->count));
	memset(ts->measure_items_total, 0, sizeof(ts->measure_items_total));
	memset(ts->elapsed_time, 0, sizeof(ts->elapsed_time));
	ts->count[time_slot]++;
	ts->elapsed_time[time_slot] += elapsed_time;
	ts->measure_items_total[time_slot] += measure_items;
	hashtabadd(statistics, ts);
    }

    time_slot = get_histogram_slot(elapsed_time);
}

static void
collectstats_init (void)
{
    statistics = hashtabnew (STATHASHSIZE, statistics_cmp, statistics_hash);

    if (statistics == NULL)
	arla_err(1, ADEBINIT, errno, "collectstats_init: cannot malloc");
}

static void
collectstats_start (struct collect_stat *p)
{
    struct timeval starttime;

    gettimeofday(&starttime, NULL);
    p->starttime = starttime.tv_sec * 1000000LL + starttime.tv_usec;
}

static void
collectstats_stop (struct collect_stat *p,
		   FCacheEntry *entry,
		   ConnCacheEntry *conn,
		   int measure_type, int measure_items)
{
    u_int32_t host = conn->host;
    long partition = -1;
    int volumetype;
    struct nvldbentry vldbentry;
    struct timeval stoptime;
    int64_t elapsed_time;
    int i;

    gettimeofday(&stoptime, NULL);

    volumetype = volcache_volid2bit (entry->volume, entry->fid.fid.Volume);
    vldbentry = entry->volume->entry;

    for (i = 0; i < min(NMAXNSERVERS, vldbentry.nServers); ++i) {
	if (host == htonl(vldbentry.serverNumber[i]) &&
	    vldbentry.serverFlags[i] & volumetype) {
	    partition = vldbentry.serverPartition[i];
	}
    }
    assert(partition != -1);
    elapsed_time = stoptime.tv_sec * 1000000LL + stoptime.tv_usec;
    elapsed_time -= p->starttime;
    add_time_statistics(measure_type, host, partition,
			measure_items, elapsed_time);
}

struct hostpart {
    u_int32_t host;
    u_int32_t part;
};

static unsigned
hostpart_hash (void *p)
{
    struct hostpart *h = (struct hostpart*)p;

    return h->host * 256 + h->part;
}

static int
hostpart_cmp (void *a, void *b)
{
    struct hostpart *h1 = (struct hostpart*)a;
    struct hostpart *h2 = (struct hostpart*)b;

    return h1->host != h2->host ||
	h1->part != h2->part;
}

static Bool
hostpart_addhash (void *ptr, void *arg)
{
    Hashtab *hostparthash = (Hashtab *) arg;
    struct time_statistics *s = (struct time_statistics *) ptr;
    struct hostpart *h;
    
    h = malloc(sizeof(*h));
    h->host = s->host;
    h->part = s->partition;

    hashtabadd(hostparthash, h);
    return FALSE;
}

struct hostpart_collect_args {
    u_int32_t *host;
    u_int32_t *part;
    int *i;
    int max;
};

static Bool
hostpart_collect (void *ptr, void *arg)
{
    struct hostpart_collect_args *collect_args =
	(struct hostpart_collect_args *) arg;
    struct hostpart *h = (struct hostpart *) ptr;

    if (*collect_args->i >= collect_args->max)
	return TRUE;

    collect_args->host[*collect_args->i] = h->host;
    collect_args->part[*collect_args->i] = h->part;
    (*collect_args->i)++;

    return FALSE;
}

int
collectstats_hostpart(u_int32_t *host, u_int32_t *part, int *n)
{
    Hashtab *hostparthash;
    int i;
    struct hostpart_collect_args collect_args;

    hostparthash = hashtabnew (100, hostpart_cmp, hostpart_hash);

    hashtabforeach(statistics, hostpart_addhash, hostparthash);

    i = 0;
    collect_args.host = host;
    collect_args.part = part;
    collect_args.i = &i;
    collect_args.max = *n;
    hashtabforeach(hostparthash, hostpart_collect, &collect_args);
    *n = i;

    hashtabrelease(hostparthash);

    return 0;
}

int
collectstats_getentry(u_int32_t host, u_int32_t part, u_int32_t type,
		      u_int32_t items_slot, u_int32_t *count,
		      int64_t *items_total, int64_t *total_time)
{
    struct time_statistics ts;
    struct time_statistics *ts2;

    ts.measure_type = type;
    ts.measure_items = items_slot;
    ts.host = host;
    ts.partition = part;
    ts2 = hashtabsearch (statistics, (void*)(&ts));
    if (ts2 == NULL) {
	memset(count, 0, 4 * 32);
	memset(items_total, 0, 8 * 32);
	memset(total_time, 0, 8 * 32);
    } else {
	memcpy(count, ts2->count, 4 * 32);
	memcpy(items_total, ts2->measure_items_total, 8 * 32);
	memcpy(total_time, ts2->elapsed_time, 8 * 32);
    }

    return 0;
}

d229 2
a230 2
     FCacheEntry *f1 = (FCacheEntry*)a;
     FCacheEntry *f2 = (FCacheEntry*)b;
d232 1
a232 4
     return f1->fid.Cell != f2->fid.Cell 
	 || f1->fid.fid.Volume != f2->fid.fid.Volume 
	 || f1->fid.fid.Vnode  != f2->fid.fid.Vnode
	 || f1->fid.fid.Unique != f2->fid.fid.Unique;
d242 1
a242 1
     FCacheEntry *f = (FCacheEntry*)e;
d244 2
a245 2
     return f->fid.Cell + f->fid.fid.Volume + f->fid.fid.Vnode 
	  + f->fid.fid.Unique;
d270 1
a270 1
   hashtabdel(hashtab,entry);
d277 91
a367 1
char arlasysname[SYSNAMEMAXLEN];
d391 19
d433 1
a433 2
    assert (entry->flags.datap &&
	    entry->flags.extradirp &&
d453 4
d462 1
a462 1
	memcpy (&fh, &handle->xfs_handle, sizeof(fh));
d473 2
a474 2
	vice_ioctl.in      = (caddr_t)&handle->xfs_handle;
	vice_ioctl.in_size = sizeof(handle->xfs_handle);
d495 22
d524 1
a524 1
	    memcpy (&handle->xfs_handle, &fh, sizeof(fh));
d542 2
a543 2
	vice_ioctl.out      = (caddr_t)&handle->xfs_handle;
	vice_ioctl.out_size = sizeof(handle->xfs_handle);
d561 2
a562 2
int
fcache_create_file (FCacheEntry *entry)
d568 6
d576 1
a576 1
    fd = open (fname, O_RDWR | O_CREAT | O_TRUNC | O_BINARY, 0666);
d578 1
a578 1
	if (errno == ENOENT) {
d585 1
a585 1
	    fd = open (fname, O_RDWR | O_CREAT | O_TRUNC | O_BINARY, 0666);
d612 1
a612 1
	if (ret < 0 && errno == EINVAL)
d630 1
a630 1
    assert (entry->flags.datap && entry->flags.extradirp &&
d647 1
a647 1
    assert (entry->flags.datap && entry->flags.usedp);
d678 2
a679 1
    entry->flags.datap = FALSE;
d690 1
a690 1
static int
d693 1
a693 1
    u_int32_t sec, usec;
d712 2
d715 1
d719 5
a723 1
    if (entry->flags.datap)
d731 2
d741 1
a741 1
	if (conn != NULL) {
d745 4
a748 1
	    ret = RXAFS_GiveUpCallBacks (conn->connection, &fids, &cbs);
d758 1
d772 6
a777 1
     return node_count++;
d815 1
d823 1
a823 1
	    fcache_create_file (&entries[i]);
d857 1
a857 1
    numnodes = 50;
d873 2
a874 2
		    usedbytes, lowbytes, highbytes,
		    needbytes);
d898 4
d905 1
a905 2
			|| (needbytes > highbytes - usedbytes
			    && !entry->flags.attrusedp))
d910 1
a910 1
			&& CheckLock(&entry->lock) == 0
d912 1
d922 1
a922 4
		    if (state == CL_FORCE) {
			if (entry->cleanergen == cleanerrun)
			    continue;
			entry->cleanergen = cleanerrun;
d927 1
a927 1
			    xfs_send_message_gc_nodes (kernel_fd, cnt, fids);
d945 1
a945 1
			xfs_send_message_gc_nodes (kernel_fd, cnt, fids);
d951 1
a951 8
		    if (needbytes > highbytes - usedbytes) {
			int cleaner_again = 0;
			if (!cleaner_again)
			    goto out;
			state = CL_OPPORTUNISTIC;
		    } else {
			goto out;
		    }
d956 1
d964 2
a965 2
		   "%lu (%lu-%lu) bytes "
		   "%lu needed bytes",
d967 2
a968 2
		   usedbytes, lowbytes, highbytes,
		   needbytes);
d992 2
a993 2
		    "(%lu needed, %lu outstanding, %lu highbytes", 
		    needed, needbytes, highbytes);
d1004 2
a1005 2
		    needed - (highbytes - usedbytes), 
		    usedbytes, highbytes);
d1033 1
a1033 1
	arla_warnx(ADEBCLEANER,
d1047 1
a1047 1
		arla_warnx (ADEBCLEANER,
d1059 1
d1088 2
a1089 2
     FCacheEntry *entry = NULL;
     Listitem *item;
d1091 2
a1092 2
     if (highvnodes == usedvnodes)
	 fcache_need_nodes();
d1094 1
a1094 1
     for (;;) {
d1096 39
a1134 36
	 assert (!listemptyp (lrulist));
	 for (item = listtail (lrulist);
	      item;
	      item = listprev (lrulist, item)) {

	     entry = (FCacheEntry *)listdata (item);
	     if (!entry->flags.usedp
		 && CheckLock(&entry->lock) == 0) {
		 ObtainWriteLock (&entry->lock);
		 listdel (lrulist, entry->lru_le);
		 entry->lru_le = NULL;
		 return entry;
	     }
	 }

	 assert (!listemptyp (lrulist));
	 for (item = listtail (lrulist);
	      item;
	      item = listprev (lrulist, item)) {

	     entry = (FCacheEntry *)listdata (item);
	     if (entry->flags.usedp
		 && !entry->flags.attrusedp
		 && entry->refcount == 0
		 && CheckLock(&entry->lock) == 0) {
		 ObtainWriteLock (&entry->lock);
		 listdel (lrulist, entry->lru_le);
		 entry->lru_le = NULL;
		 throw_entry (entry);
		 return entry;
	     }
	 }

	 arla_warnx (ADEBFCACHE, "unlink_lru_entry: sleeping");
	 fcache_need_nodes();
     }
d1160 49
d1212 2
a1213 4
    Listitem *item;
    int fd;
    unsigned n;
    u_int32_t u1, u2;
d1216 1
a1216 1
	arla_warnx (ADEBFCACHE, "store_state: lrulist is NULL");
d1220 11
a1230 8
    fd = open ("fcache.new", O_WRONLY | O_CREAT | O_TRUNC | O_BINARY, 0666);
    if (fd < 0)
	return errno;
    u1 = FCACHE_MAGIC_COOKIE;
    u2 = FCACHE_VERSION;
    if (write (fd, &u1, sizeof(u1)) != sizeof(u1)
	|| write (fd, &u2, sizeof(u2)) != sizeof(u2)) {
	int save_errno = errno;
d1232 3
a1234 9
	close (fd);
	return save_errno;
    }
    
    n = 0;
    for (item = listtail (lrulist);
	 item;
	 item = listprev (lrulist, item)) {
	FCacheEntry *entry = (FCacheEntry *)listdata (item);
d1236 5
a1240 4
	if (!entry->flags.usedp)
	    continue;
	if (write (fd, entry, sizeof(*entry)) != sizeof(*entry)) {
	    int save_errno = errno;
d1242 6
a1247 5
	    close (fd);
	    return save_errno;
	}
	++n;
    }
d1249 17
a1265 4
    if(close (fd))
	return errno;
    if (rename ("fcache.new", "fcache"))
	return errno;
d1267 48
a1314 1
    arla_warnx (ADEBFCACHE, "wrote %u entries to fcache", n);
a1325 2
    int fd;
    FCacheEntry tmp;
a1326 21
    AFSCallBack broken_callback = {0, 0, CBDROPPED};
    u_int32_t u1, u2;

    fd = open ("fcache", O_RDONLY | O_BINARY, 0);
    if (fd < 0)
	return;
    if (read (fd, &u1, sizeof(u1)) != sizeof(u1)
	|| read (fd, &u2, sizeof(u2)) != sizeof(u2)) {
	close (fd);
	return;
    }
    if (u1 != FCACHE_MAGIC_COOKIE) {
	arla_warnx (ADEBFCACHE, "dump file not recognized, ignoring");
	close (fd);
	return;
    }
    if (u2 != FCACHE_VERSION) {
	arla_warnx (ADEBFCACHE, "unknown dump file version number %u", u2);
	close (fd);
	return;
    }
d1329 1
a1329 16
    while (read (fd, &tmp, sizeof(tmp)) == sizeof(tmp)) {
	CredCacheEntry *ce;
	FCacheEntry *e;
	int i;
	VolCacheEntry *vol;
	int res;
	int type;

	ce = cred_get (tmp.fid.Cell, 0, 0);
	assert (ce != NULL);

	res = volcache_getbyid (tmp.fid.fid.Volume, tmp.fid.Cell,
				ce, &vol, &type);
	cred_free (ce);
	if (res)
	    continue;
a1330 49
	e = find_free_entry ();
	assert (e != NULL);

	++n;

	e->fid      = tmp.fid;
	e->host     = 0;
	e->status   = tmp.status;
	e->length   = tmp.length;
	e->callback = broken_callback;
	e->volsync  = tmp.volsync;
	e->refcount = tmp.refcount;

	/* Better not restore the rights. pags don't have to be the same */
	for (i = 0; i < NACCESS; ++i) {
	    e->acccache[i].cred = ARLA_NO_AUTH_CRED;
	    e->acccache[i].access = ANONE;
	}

	e->anonaccess = tmp.anonaccess;
	e->index      = tmp.index;
	e->handle     = tmp.handle; /* XXX */
	node_count = max(node_count, tmp.index + 1);
	e->flags.usedp = TRUE;
	e->flags.attrp = tmp.flags.attrp;
	e->flags.datap = tmp.flags.datap;
	e->flags.attrusedp = FALSE;
	e->flags.datausedp = FALSE;
	e->flags.kernelp   = FALSE;
	e->flags.extradirp = tmp.flags.extradirp;
	e->flags.mountp    = tmp.flags.mountp;
	e->flags.fake_mp   = tmp.flags.fake_mp;
	e->flags.vol_root  = tmp.flags.vol_root;
	e->flags.sentenced = FALSE;
	e->flags.silly 	   = FALSE;
	e->tokens = tmp.tokens;
	e->parent = tmp.parent;
	e->priority = tmp.priority;
	e->hits = 0;
	e->cleanergen = 0;
	e->lru_le = listaddhead (lrulist, e);
	assert(e->lru_le);
	e->volume = vol;
	hashtabadd (hashtab, e);
	if (e->flags.datap)
	    usedbytes += e->length;
	ReleaseWriteLock (&e->lock);
    }
    close (fd);
d1342 1
a1342 1
findaccess (xfs_pag_t cred, AccessEntry *ae, AccessEntry **pos)
d1344 17
a1360 1
     int i;
d1362 7
a1368 9
     for(i = 0; i < NACCESS ; ++i)
	  if(ae[i].cred == cred) {
	      *pos = &ae[i];
	      return TRUE;
	  }

     i = rand() % NACCESS;
     *pos = &ae[i];
     return FALSE;
d1381 10
d1399 1
a1399 1
	      int mark_as_dead)
d1401 11
a1411 2
    if (mark_as_dead)
	conn_dead (prev_conn);
d1414 1
a1414 1
	return context->conns[context->i++];
d1429 4
a1432 1
	conn_free (context->conns[i]);
d1436 2
a1437 3
 * Find the first file server housing the volume for `e'.
 * The context is saved in `context' and can later be sent to find_next_fs.
 * Returns a ConnCacheEntry or NULL.
d1440 4
a1443 4
ConnCacheEntry *
find_first_fs (FCacheEntry *e,
	       CredCacheEntry *ce,
	       fs_server_context *context)
a1454 2
	int type;

d1456 1
a1456 1
				ce, &e->volume, &type);
d1458 1
a1458 1
	    return NULL;
d1464 1
a1464 1
	return NULL;
d1471 1
a1471 1
	return NULL;
d1485 6
a1490 2
	    if (conn != NULL) {
		conn->rtt = rx_PeerOf(conn->connection)->rtt
d1492 3
a1494 3
		context->conns[num_clones] = conn;
		++num_clones;
	    }
d1498 5
d1504 1
a1504 1
	   conn_rtt_cmp);
d1509 11
a1519 1
    return find_next_fs (context, NULL, FALSE);
d1530 2
a1531 2
	     u_long alowbytes,
	     u_long ahighbytes,
d1543 1
d1546 1
a1546 1
    node_count     = 1;		/* XXX */
a1550 1
    fprioritylevel = FPRIO_DEFAULT;
d1593 2
a1594 2
	      u_long alowbytes,
	      u_long ahighbytes)
d1674 1
d1676 1
a1676 1
	e->tokens   = 0;
d1679 4
d1741 1
a1741 1
    xfs_pag_t pag;
d1764 1
a1764 1
		    install_attr (e, FCACHE2XFSNODE_RIGHT);
d1778 1
a1778 1
fcache_purge_cred (xfs_pag_t pag, int32_t cell)
d1843 28
d1946 2
a1947 2
	      u_int32_t host,
	      xfs_pag_t cred)
d1970 8
a1977 1
    entry->host     = host;
d1996 2
a1997 2
		   u_int32_t host,
		   xfs_pag_t cred)
d1999 4
a2002 2
    if (entry->flags.datap
	&& entry->status.DataVersion != status->DataVersion) {
d2004 1
a2004 1
	entry->tokens &= ~(XFS_DATA_R|XFS_DATA_W);
d2008 1
a2008 1
		  host, cred);
d2010 1
a2010 1
    entry->tokens |= XFS_ATTR_R;
d2019 41
d2065 2
d2096 8
a2103 2
		if (ret)
		    arla_warn (ADEBFCACHE, ret, "RXAFS_GiveUpCallBacks");
d2115 1
a2115 1
fcache_reobtain_callbacks (void)
d2125 1
a2135 1
	    int type;
d2137 1
a2137 1
	    ce = cred_get (entry->fid.Cell, 0, CRED_ANY);
d2142 2
d2149 1
a2149 1
				    entry->fid.Cell, ce, &vol, &type);
a2151 1
	    cred_free (ce);
d2153 16
a2168 12
	    if (conn != NULL) {
		ret = RXAFS_FetchStatus (conn->connection,
					 &entry->fid.fid,
					 &status,
					 &callback,
					 &volsync);
		if (ret)
		    arla_warn (ADEBFCACHE, ret, "RXAFS_FetchStatus");
		else
		    update_entry (entry, &status, &callback, &volsync,
				  rx_HostOf(rx_PeerOf (conn->connection)),
				  ce->cred);
d2170 1
a2170 2
		fcache_counter.fetch_attr++;
	    }
d2172 1
d2185 1
d2187 1
d2204 1
a2204 1
	if (fid && !volcache_reliable (fid->fid.Volume, fid->Cell))
d2215 25
a2255 1
    int ret = ARLA_CALL_DEAD;
d2261 1
d2267 3
a2269 6
    if (connected_mode == DISCONNECTED) {
	if (entry->flags.attrp)
	    return 0;
	else
	    return ENETDOWN;
    }
d2271 1
a2271 1
    for (conn = find_first_fs (entry, ce, ret_context);
d2273 1
a2273 1
	 conn = find_next_fs (ret_context, conn, host_downp (ret))) {
d2282 1
d2289 1
a2291 1
	arla_warn (ADEBFCACHE, ret, "fetch-status");
d2299 1
a2299 2
		       rx_HostOf (rx_PeerOf (conn->connection)),
		       ce->cred);
d2335 2
a2336 1
read_data (FCacheEntry *entry, ConnCacheEntry *conn, CredCacheEntry *ce)
d2340 2
a2341 1
    u_int32_t sizefs;
d2357 19
a2375 3
    if (usedbytes + entry->status.Length > highbytes) {
	ret = fcache_need_bytes (entry->status.Length);
	if (ret) goto out;
d2378 1
a2378 1
    if (usedbytes + entry->status.Length > highbytes) {
d2380 2
a2381 2
		    "(%d file-length %lu usedbytes)",
		    entry->status.Length,  usedbytes);
d2386 1
d2395 2
a2396 2
    ret = StartRXAFS_FetchData (call, &entry->fid.fid, 
				0, entry->status.Length);
d2399 1
d2405 1
a2405 1
	ret = conv_to_arla_errno(rx_Error(call));
d2421 1
a2421 1
    if (ftruncate(fd, sizefs) < 0) {
d2428 1
a2428 1
    ret = copyrx2fd (call, fd, 0, sizefs);
d2445 6
a2450 1
		      STATISTICS_REQTYPE_FETCHDATA, sizefs);
d2455 1
a2455 4
		  rx_HostOf(rx_PeerOf(conn->connection)),
		  ce->cred);
    entry->length = sizefs;
    usedbytes += sizefs;		/* XXX - sync */
d2457 1
a2457 2
    entry->flags.datap = TRUE;
    entry->tokens |= XFS_DATA_R | XFS_DATA_W | XFS_OPEN_NR | XFS_OPEN_NW;
d2459 1
a2459 1
out:
a2472 117
     ConnCacheEntry *conn;
     struct rx_call *call;
     int ret = ARLA_CALL_DEAD;
     u_int32_t sizefs;
     int fd;
     struct stat statinfo;
     AFSFetchStatus status;
     AFSVolSync volsync;
     fs_server_context context;

     AssertExclLocked(&entry->lock);

     /* Don't write data to deleted files */
     if (entry->flags.silly)
	 return 0;

     fd = fcache_open_file (entry, O_RDWR);
     if (fd < 0) {
	 ret = errno;
	 arla_warn (ADEBFCACHE, ret, "open cache file %u",
		    (unsigned)entry->index);
	 return ret;
     }

     if (fstat (fd, &statinfo) < 0) {
	 ret = errno;
	 close (fd);
	 arla_warn (ADEBFCACHE, ret, "stat cache file %u",
		    (unsigned)entry->index);
	 return ret;
     }

     sizefs = statinfo.st_size;

     fcache_update_length (entry, sizefs);
     if (connected_mode != CONNECTED) {
	 close (fd);
	 return 0;
     }

     for (conn = find_first_fs (entry, ce, &context);
	  conn != NULL;
	  conn = find_next_fs (&context, conn, host_downp (ret))) {

	 call = rx_NewCall (conn->connection);
	 if (call == NULL) {
	     arla_warnx (ADEBMISC, "rx_NewCall failed");
	     ret = ENOMEM;
	     break;
	 }

	 ret = StartRXAFS_StoreData (call, &entry->fid.fid,
				     storestatus,
				     0,
				     sizefs,
				     sizefs);
	 if (host_downp(ret)) {
	     rx_EndCall(call, ret);
	     continue;
	 } else if (ret) {
	     arla_warn (ADEBFCACHE, ret, "store-data");
	     rx_EndCall(call, 0);
	     break;
	 }

	 ret = copyfd2rx (fd, call, 0, sizefs);
	 if (ret) {
	     rx_EndCall(call, ret);
	     arla_warn (ADEBFCACHE, ret, "copyfd2rx");
	     break;
	 }

	 ret = EndRXAFS_StoreData (call,
				   &status,
				   &volsync);
	 if (ret) {
	     rx_EndCall (call, ret);
	     arla_warnx (ADEBFCACHE, "EndRXAFS_StoreData");
	     break;
	 }

	 ret = rx_EndCall (call, 0);
	 if (ret) {
	     arla_warn (ADEBFCACHE, ret, "rx_EndCall");
	 }
	 break;
     }

     if (conn != NULL) {
	 if (ret == 0) {
	     fcache_counter.store_data++;
	     update_entry (entry, &status, NULL, &volsync,
			   rx_HostOf(rx_PeerOf(conn->connection)),
			   ce->cred);
	 } else {
	     ftruncate (fd, 0);
	     entry->length = 0;
	     /* undo the work of the fcache_update_size just above the loop */
	     usedbytes -= sizefs; 
	     entry->flags.datap = FALSE;
	 }
     }
     if (host_downp(ret))
	 ret = ENETDOWN;
     free_fs_server_context (&context);
     AssertExclLocked(&entry->lock);
     close (fd);
     return ret;
}

/*
 * Truncate the file in `entry' to `size' bytes.
 */

int
truncate_file (FCacheEntry *entry, off_t size, CredCacheEntry *ce)
{
d2475 3
a2477 2
    int ret = ARLA_CALL_DEAD;
    AFSStoreStatus storestatus;
d2479 1
d2483 1
d2487 4
d2494 1
a2494 1
	arla_warn (ADEBFCACHE, ret, "open fache file %u",
d2499 1
a2499 1
    if(ftruncate (fd, size) < 0) {
a2500 1
	arla_warn (ADEBFCACHE, ret, "ftruncate %ld", (long)size);
d2502 22
d2525 65
d2591 4
a2594 1
    
d2596 6
d2603 11
a2613 2
    if (!entry->flags.datap)
	entry->length = 0;
d2615 1
a2615 1
    fcache_update_length (entry, size);
d2620 7
a2626 2
    ret = ENETDOWN;
    for (conn = find_first_fs (entry, ce, &context);
d2628 1
a2628 1
	 conn = find_next_fs (&context, conn, host_downp (ret))) {
a2636 1
	storestatus.Mask = 0;
d2639 1
a2639 1
				    &storestatus,
a2651 1

d2662 1
a2662 1
	if (ret) {
d2664 1
a2664 1
	}
d2669 21
d2692 1
a2692 2
		      rx_HostOf(rx_PeerOf(conn->connection)),
		      ce->cred);
d2694 3
d2699 1
a2699 1
    free_fs_server_context (&context);
d2713 2
a2714 1
    int ret = ARLA_CALL_DEAD;
a2724 1
	ConnCacheEntry *conn;
d2726 5
a2730 1
	u_int32_t host = 0;
d2732 1
a2732 1
	for (conn = find_first_fs (entry, ce, &context);
d2734 1
a2734 3
	     conn = find_next_fs (&context, conn, host_downp (ret))) {

	    host = rx_HostOf (rx_PeerOf (conn->connection));
d2736 1
d2747 1
d2750 1
d2753 7
d2766 1
a2767 1
	update_entry (entry, &status, NULL, &volsync, host, ce->cred);
d2769 2
d2784 1
d2787 3
a2789 1
out:
d2805 2
a2806 1
    int ret = ARLA_CALL_DEAD;
a2812 1
    u_int32_t host;
d2817 5
a2821 2
	ConnCacheEntry *conn;
	fs_server_context context;
d2823 1
a2823 1
	for (conn = find_first_fs (dir_entry, ce, &context);
d2825 1
a2825 3
	     conn = find_next_fs (&context, conn, host_downp (ret))) {

	    host = rx_HostOf (rx_PeerOf (conn->connection));
d2841 1
d2844 1
d2847 1
d2856 2
a2857 1
		      host, ce->cred);
d2861 4
d2887 4
a2890 6
	fetch_attr->spare1           = 0;
	fetch_attr->spare2           = 0;
	fetch_attr->spare3           = 0;
	fetch_attr->spare4           = 0;

	host = dir_entry->host;
d2903 1
a2903 1
		  host, ce->cred);
d2927 1
a2927 2
    child_entry->flags.datap = TRUE;
    child_entry->tokens |= XFS_ATTR_R | XFS_DATA_R | XFS_DATA_W;
d2931 4
a2934 1
out:
d2950 2
a2951 1
    int ret = ARLA_CALL_DEAD;
d2957 1
a2957 1
    u_int32_t host;
a2961 1
	ConnCacheEntry *conn;
d2964 5
a2968 1
	for (conn = find_first_fs (dir_entry, ce, &context);
d2970 1
a2970 3
	     conn = find_next_fs (&context, conn, host_downp (ret))) {

	    host = rx_HostOf(rx_PeerOf(conn->connection));
d2987 1
d2990 1
d3001 1
a3001 1
		      host, ce->cred);
d3005 4
d3031 4
a3034 6
	fetch_attr->spare1           = 0;
	fetch_attr->spare2           = 0;
	fetch_attr->spare3           = 0;
	fetch_attr->spare4           = 0;

	host = dir_entry->host;
d3046 1
a3046 2
    if(child_entry->flags.datap)
	throw_data (child_entry);
d3049 1
a3049 1
		  host, ce->cred);
d3061 1
a3061 2
    child_entry->flags.datap = TRUE;
    child_entry->tokens |= XFS_ATTR_R | XFS_DATA_R | XFS_DATA_W;
d3065 3
a3067 1
out:
d3086 1
a3086 1
    int ret = ARLA_CALL_DEAD;
a3091 1
    u_int32_t host;
d3099 5
a3103 1
    for (conn = find_first_fs (dir_entry, ce, &context);
d3105 1
a3105 3
	 conn = find_next_fs (&context, conn, host_downp (ret))) {

	host = rx_HostOf(rx_PeerOf(conn->connection));
d3121 1
d3124 1
d3135 1
a3135 1
		  host, ce->cred);
d3147 1
a3147 1
		  host, ce->cred);
d3156 1
a3156 1
    child_entry->tokens |= XFS_ATTR_R;
d3160 3
a3162 1
out:
d3177 2
a3178 2
    int ret = 0;
    ConnCacheEntry *conn;
a3181 1
    u_int32_t host;
d3189 5
a3193 1
    for (conn = find_first_fs (dir_entry, ce, &context);
d3195 1
a3195 3
	 conn = find_next_fs (&context, conn, host_downp (ret))) {

	host = rx_HostOf(rx_PeerOf(conn->connection));
d3209 1
d3212 1
d3223 1
a3223 1
		  host, ce->cred);
d3226 1
a3226 1
		  host, ce->cred);
d3228 3
a3230 1
out:
d3242 1
a3242 1
    int ret = ARLA_CALL_DEAD;
a3245 1
    u_int32_t host;
d3250 30
a3279 2
    if (connected_mode != CONNECTED)
	return EINVAL;
d3281 4
a3284 3
    for (conn = find_first_fs (dir_entry, ce, &context);
	 conn != NULL;
	 conn = find_next_fs (&context, conn, host_downp (ret))) {
d3286 3
a3288 1
	host = rx_HostOf(rx_PeerOf(conn->connection));
d3290 3
a3292 10
	ret = RXAFS_RemoveFile (conn->connection,
				&dir_entry->fid.fid,
				name,
				&status,
				&volsync);
	if (host_downp(ret)) {
	    continue;
	} else if (ret) {
	    free_fs_server_context (&context);
	    arla_warn (ADEBFCACHE, ret, "RemoveFile");
d3294 18
d3313 3
a3315 1
	break;
a3316 1
    free_fs_server_context (&context);
d3318 3
a3320 4
    if (host_downp(ret)) {
	ret = ENETDOWN;
	goto out;
    }
d3322 3
a3324 4
    update_entry (dir_entry, &status, NULL, &volsync,
		  host, ce->cred);

out:
d3338 1
a3338 1
    int ret = ARLA_CALL_DEAD;
a3341 1
    u_int32_t host;
d3349 5
a3353 1
    for (conn = find_first_fs (dir_entry, ce, &context);
d3355 1
a3355 3
	 conn = find_next_fs (&context, conn, host_downp (ret))) {

	host = rx_HostOf(rx_PeerOf(conn->connection));
d3367 1
d3370 1
d3381 1
a3381 1
		  host, ce->cred);
d3383 3
a3385 1
out:
a3404 1
    u_int32_t host;
d3413 5
a3417 1
    for (conn = find_first_fs (old_dir, ce, &context);
d3419 1
a3419 3
	 conn = find_next_fs (&context, conn, host_downp (ret))) {

	host = rx_HostOf(rx_PeerOf(conn->connection));
d3434 1
d3437 1
d3448 1
a3448 1
		  host, ce->cred);
d3451 1
a3451 1
		  host, ce->cred);
d3453 3
a3455 1
out:
d3468 20
a3487 46
     VolCacheEntry *ve;
     VenusFid fid;
     const char *root_volume = volcache_get_rootvolume ();
     int type;
     int ret;
     const char *this_cell = cell_getthiscell ();
     int32_t this_cell_id;
     static int busy_wait = 0;

     if (dynroot_enablep()) {
	 res->Cell = dynroot_cellid ();
	 res->fid.Volume = dynroot_volumeid ();
	 res->fid.Vnode = fid.fid.Unique = 1;

	 return 0;
     }

     this_cell_id = cell_name2num (this_cell);
     if (this_cell_id == -1)
	 arla_errx (1, ADEBERROR, "cell %s does not exist", this_cell);

     while (busy_wait)
	 LWP_WaitProcess (getroot);

     busy_wait = 1;
     ret = volcache_getbyname (root_volume, this_cell_id, ce, &ve, &type);
     busy_wait = 0;
     LWP_NoYieldSignal (getroot);
     if (ret) {
	 arla_warn (ADEBWARN, ret,
		    "Cannot find the root volume (%s) in cell %s",
		    root_volume, this_cell);
	 return ret;
     }

     fid.Cell = this_cell_id;
     if (ve->entry.flags & VLF_ROEXISTS) {
	 fid.fid.Volume = ve->entry.volumeId[ROVOL];
     } else if (ve->entry.flags & VLF_RWEXISTS) {
	 arla_warnx(ADEBERROR,
		    "getroot: %s in cell %s is missing a RO clone, not good",
		    root_volume, this_cell);
	 fid.fid.Volume = ve->entry.volumeId[RWVOL];
     } else {
	 arla_errx(1, ADEBERROR,
		   "getroot: %s in cell %s has no RW or RO clone?",
d3489 17
a3505 2
     }
     fid.fid.Vnode = fid.fid.Unique = 1;
d3507 1
a3507 1
     volcache_free (ve);
d3509 2
a3510 2
     *res = fid;
     return 0;
d3520 1
a3520 1
     int i;
d3522 5
a3526 5
     for (i = RWVOL; i <= BACKVOL; ++i)
	  if (ve->entry.volumeId[i] == volid)
	      return i;
     assert (FALSE);
     return -1; /* NOT REACHED */
d3552 2
a3553 2
    int type, i;
    int error;
d3564 7
d3591 2
a3601 1
    e->flags.datap     = FALSE;
d3617 1
a3617 1
    e->volume          = NULL;
a3623 13
    if (connected_mode != DISCONNECTED) {
	VolCacheEntry *vol;

	error = volcache_getbyid (fid.fid.Volume, fid.Cell, ce, &vol, &type);
	if (error) {
	    e->volume = NULL;
	    *res = NULL;
	    ReleaseWriteLock (&e->lock);
	    return error;
	}
	e->volume = vol;
    }

d3688 3
a3690 3
    struct xfs_message_installnode node;
    struct xfs_message_installattr attr;
} xfs_message_install_node_attr;
d3692 1
a3692 1
static void
d3702 1
a3702 1
	return;
d3706 1
a3706 1
	return;
d3720 1
a3720 1
	return;
d3738 1
a3738 1
	return;
d3745 1
a3745 1
	    return;
d3752 3
a3754 1
    bs->len++;    
d3778 1
a3778 1
    ConnCacheEntry *conn;
d3788 1
a3788 1
    u_int32_t host;
d3795 1
a3795 1
    if (!parent_entry->flags.datap) {
d3836 2
a3837 1
			&parent_entry->fid);
d3875 5
a3879 1
    for (conn = find_first_fs (parent_entry, ce, &context);
d3881 1
a3881 1
	 conn = find_next_fs (&context, conn, host_downp (ret))) {
d3887 1
d3889 3
d3896 11
a3906 2
	if (!try_next_fs (ret, &parent_entry->fid))
	    break;	
a3908 2
    if (conn != NULL)
	host = rx_HostOf (rx_PeerOf (conn->connection));
d3926 1
d3930 1
d3932 4
a3935 1
	    if (prefered_entry && i == 0) {
a3937 5
		VenusFid fid;

		fid.Cell = parent_entry->fid.Cell;
		fid.fid = fids.val[i];

d3950 1
a3950 1
			       host,
d3964 3
a3966 3
	xfs_message_install_node_attr msg[AFSCBMAX];
	struct xfs_msg_node *node;
	xfs_handle *parent;
d3973 1
d3977 1
a3977 1
	    if (prefered_entry && i == 0) {
a3978 1
		ret = 0;
d3985 2
a3987 2
	    if (ret == 0) {
		u_int tokens;
a3988 28
		arla_warnx (ADEBFCACHE, "installing %d.%d.%d\n",
			    e->fid.fid.Volume,
			    e->fid.fid.Vnode,
			    e->fid.fid.Unique);
		e->flags.attrusedp 	= TRUE;

		/*
		 * Its its already installed, just update with installattr
		 */

		e->tokens			|= XFS_ATTR_R;
		tokens				= e->tokens;
		if (!e->flags.kernelp || !e->flags.datausedp)
		    tokens			&= ~XFS_DATA_MASK;

		if (e->flags.kernelp) {
		    msg[j].attr.header.opcode	= XFS_MSG_INSTALLATTR;
		    node			= &msg[j].attr.node;
		    parent			= NULL;
		} else {
		    msg[j].node.header.opcode	= XFS_MSG_INSTALLNODE;
		    node			= &msg[j].node.node;
		    parent			= &msg[j].node.parent_handle;
		    e->flags.kernelp		= TRUE;
		    strlcpy (msg[j].node.name, bs.names[i],
			     sizeof(msg[j].node.name));
		}
		node->tokens = tokens;
d3990 46
a4035 20
		/*
		 * Don't install symlink since they might be
		 * mount-points.
		 */

		if (e->status.FileType != TYPE_LINK) {
		    fcacheentry2xfsnode (&e->fid,
					 &e->fid,
					 &stats.val[i],
					 node, 
					 parent_entry->acccache,
					 FCACHE2XFSNODE_ALL);

		    if (parent)
			*parent = *(struct xfs_handle*) &parent_entry->fid;
		    j++;
		}
		if (!(prefered_entry && i == 0)) {
		    fcache_release(e);
		}
d4037 2
d4044 1
a4044 1

d4046 4
a4049 4
	    ret = xfs_send_message_multiple_list (kernel_fd,
						  (struct xfs_message_header *) msg,
						  sizeof (msg[0]),
						  j);
d4054 1
a4054 1

d4059 1
a4059 1
    for (i = 0 ; i < bs.len && ret == 0; i++) {
d4061 3
a4063 1
    }
d4082 1
a4082 1
fcache_verify_attr (FCacheEntry *entry, FCacheEntry *parent_entry,
a4084 1
    FCacheEntry *parent = parent_entry;
a4085 1
    int error;
d4105 1
a4105 1
	entry->tokens |= XFS_ATTR_R;
d4110 12
d4123 1
a4123 1
     * If `entry' is a root-node or the parent is
d4126 2
a4127 1
    if (entry->fid.fid.Vnode        != 1
a4135 6
	if (parent == NULL) {
	    arla_warnx (ADEBFCACHE, "fcache_get_attr: getting parent");
	    error = fcache_get (&parent, entry->parent, ce);
	} else
	    error = 0;

d4142 13
a4154 17
	if (error == 0) {
	    int error2 = -1;
	    
	    if (parent->hits++ > fcache_bulkstatus_num &&
		parent->flags.datausedp) {
		
		arla_warnx (ADEBFCACHE,
			    "fcache_get_attr: doing bulk get_attr");
		error2 = get_attr_bulk (parent,
					entry, &entry->fid,
					prefered_name, ce);
		/* magic calculation when we are going to do next bulkstat */
		parent->hits = 0;
	    }
	    if (parent_entry == NULL)
		fcache_release (parent);
	    if (error2 == 0)
d4185 5
a4189 1
	return EINVAL;
d4191 1
a4191 1
    for (conn = find_first_fs (e, ce, &context);
d4193 2
a4194 2
	 conn = find_next_fs (&context, conn, host_downp (ret))) {
	ret = read_data (e, conn, ce);
d4227 1
a4227 1
	if (e->flags.datap) {
d4236 1
a4236 1
	if (e->flags.datap) {
d4242 1
a4242 1
    ret = read_data (e, conn, ce);
d4253 2
a4254 1
fcache_get_data (FCacheEntry **res, VenusFid *fid, CredCacheEntry **ce)
a4255 1
    FCacheEntry *e;
d4258 1
a4258 5
    ret = fcache_get (&e, *fid, *ce);
    if (ret)
	return ret;

    if (e->flags.fake_mp) {
a4263 1
	    fcache_release (e);
a4267 1
	    fcache_release (e);
a4271 1
	    fcache_release (e);
d4275 7
a4281 8
	e->flags.fake_mp   = FALSE;
	e->flags.mountp    = TRUE;
	e->status.FileType = TYPE_LINK;
	update_fid (*fid, e, new_fid, new_root);
	fcache_release (e);
	*fid = new_fid;
	e  = new_root;
	install_attr (e, FCACHE2XFSNODE_ALL);
d4284 18
a4301 5
    ret = fcache_verify_data (e, *ce);
    if (ret == 0)
	*res = e;
    else
	fcache_release (e);
d4357 1
a4357 1
	     u_int32_t *volid, VolCacheEntry **ve)
d4391 1
a4391 1
	else
d4393 4
d4428 1
a4428 1
    u_int32_t volid;
d4523 12
a4534 2
     FCacheEntry *e;
     int ret;
d4536 9
a4544 19
     /*
      * Get the node for `fid' and verify that it's a symbolic link
      * with the correct bits.  Otherwise, just return the old
      * `fid' without any change.
      */

     ret = fcache_get (&e, *fid, *ce);
     if (ret)
	 return ret;

     ret = fcache_verify_attr (e, parent_e, NULL, *ce);
     if (ret) {
	 fcache_release(e);
	 return ret;
     }

     e->parent = *parent;
     if (e->flags.mountp)
	 ret = resolve_mp (e, fid, ce);
d4546 2
a4547 2
     fcache_release(e);
     return ret;
d4555 1
a4555 1
resolve_mp (FCacheEntry *e, VenusFid *ret_fid, CredCacheEntry **ce)
d4557 1
a4557 1
    VenusFid fid = e->fid;
d4562 4
a4565 1
    u_int32_t length;
d4567 1
a4567 2
    assert (e->flags.fake_mp || e->flags.mountp);
    AssertExclLocked(&e->lock);
d4569 1
a4569 1
    ret = fcache_verify_data (e, *ce);
d4573 1
a4573 1
    length = e->status.Length;
d4575 1
a4575 1
    fd = fcache_open_file (e, O_RDONLY);
d4587 2
a4588 1
    ret = get_root_of_volume (&fid, &e->parent, e->volume, ce, buf, length);
d4612 1
a4612 1
	     e->flags.datap?" data":"",
d4637 1
a4637 1
	     usedbytes, lowbytes, highbytes);
d4646 1
a4646 1
fcache_update_length (FCacheEntry *e, size_t len)
d4651 1
d4655 2
d4687 3
a4689 1
    ret = ARLA_CALL_DEAD;
d4691 1
a4691 1
    for (conn = find_first_fs (dire, ce, &context);
d4693 1
a4693 1
	 conn = find_next_fs (&context, conn, host_downp (ret))) {
d4711 1
a4711 2
		      rx_HostOf(rx_PeerOf(conn->connection)),
		      ce->cred);
d4749 3
a4751 1
    ret = ARLA_CALL_DEAD;
d4753 1
a4753 1
    for (conn = find_first_fs (dire, ce, &context);
d4755 1
a4755 1
	 conn = find_next_fs (&context, conn, host_downp (ret))) {
d4766 1
a4766 2
		      rx_HostOf(rx_PeerOf(conn->connection)),
		      ce->cred);
d4788 1
a4788 1
	   char *volumename,
d4806 3
a4808 1
    ret = ARLA_CALL_DEAD;
d4810 1
a4810 1
    for (conn = find_first_fs (dire, ce, &context);
d4812 1
a4812 1
	 conn = find_next_fs (&context, conn, host_downp (ret))) {
d4824 5
a4828 3
    if (ret == 0 && volumename[0] == '\0')
	volcache_getname (fid.fid.Volume, fid.Cell,
			  volumename, sizeof(volumename));
d4859 3
a4861 1
    ret = ARLA_CALL_DEAD;
d4863 1
a4863 1
    for (conn = find_first_fs (dire, ce, &context);
d4865 1
a4865 1
	 conn = find_next_fs (&context, conn, host_downp (ret))) {
d4927 1
a4927 1
    u_long *a = (u_long *) arg;
d4930 1
a4930 6
    if (e->flags.attrp
	&& e->flags.datap
	&& !dynroot_is_dynrootp (e)) {

	*a += e->length;
    }
d4936 1
a4936 1
u_long
d4939 1
a4939 1
    u_long size = 0;
@


1.4
log
@merge
@
text
@d2558 1
a2558 1
	u_int32_t host;
@


1.3
log
@New Arla userland from Arla between 0.34.2 and current in arla cvs.
Too many new features and fixes to mention here.
@
text
@d2 1
a2 1
 * Copyright (c) 1995 - 2000 Kungliga Tekniska Högskolan
d17 1
a17 6
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by the Kungliga Tekniska
 *      Högskolan and its contributors.
 * 
 * 4. Neither the name of the Institute nor the names of its contributors
d40 1
a40 1
RCSID("$Id: fcache.c,v 1.290 2000/08/25 02:51:46 assar Exp $") ;
d151 6
d168 260
d561 1
a561 1
fcache_fhopen (xfs_cache_handle *handle, int flags)
d563 5
d573 1
a573 1
	memcpy (&fh, handle, sizeof(fh));
d584 2
a585 2
	vice_ioctl.in      = (caddr_t)handle;
	vice_ioctl.in_size = sizeof(*handle);
d603 1
a603 1
fcache_fhget (char *filename, xfs_cache_handle *handle)
d605 1
d612 4
a615 2
	if (ret == 0)
	    memcpy (handle, &fh, sizeof(fh));
d623 1
d631 2
a632 2
	vice_ioctl.out      = (caddr_t)handle;
	vice_ioctl.out_size = sizeof(*handle);
d634 5
a638 1
	return k_pioctl (filename, VIOC_FHGET, &vice_ioctl, 0);
d730 2
a731 2
    assert (entry->flags.datap && entry->flags.usedp
	    && CheckLock(&entry->lock) == -1);
d765 1
a765 1
    cm_check_usedbytes_consistency();
d793 2
a794 2
    assert (entry->flags.usedp
	    && CheckLock(&entry->lock) == -1);
d859 1
a859 1
	if (highvnodes <= current_vnodes)
d970 1
d972 1
a973 1
			ObtainWriteLock (&entry->lock);
d976 1
d1038 1
a1038 1
	cm_check_usedbytes_consistency();
d1214 1
a1214 1
	assert (CheckLock(&entry->lock) == -1);
d1232 5
d1368 1
d1462 2
d1491 2
a1492 1
	    && addr != 0) {
d1536 1
d1578 3
a1580 1
 *
a1589 3

    if (ahighvnodes < highvnodes)
	return EINVAL;
d1591 6
a1596 6
    if (ahighvnodes > highvnodes) {
	return EINVAL;
	highvnodes = ahighvnodes;
	LWP_NoYieldSignal (create_nodes);

	abort(); /* XXX resize heap */
d1630 1
a1670 9
#if 0
	if (e->flags.datap)
	    throw_data (e);
#endif
#if 0
	e->flags.attrp     = FALSE;
#endif
	e->flags.attrusedp = FALSE;
	e->flags.datausedp = FALSE;
d1752 1
a1752 1
		    install_attr (e);
d1881 16
d1936 2
a1937 8
    if (!entry->flags.mountp && mountpointp (entry)) {
	if (fake_mp) {
	    entry->flags.fake_mp = TRUE;
	    fake_mp_status (entry);
	} else {
	    entry->flags.mountp = TRUE;
	}
    }
d2079 1
a2079 1
try_next_fs (int error)
d2082 9
a2090 1
    case RX_CALL_DEAD :
d2096 1
d2098 3
a2101 1
    case ARLA_VMOVED :
a2108 24

/*
 * Return true iff this error means we should mark the fs as down
 */

static Bool
fs_downp (int error)
{
    switch (error) {
    case RX_CALL_DEAD :
    case RXGEN_CC_MARSHAL :
    case RXGEN_CC_UNMARSHAL :
    case RXGEN_SS_MARSHAL :
    case RXGEN_SS_UNMARSHAL :
    case RXGEN_DECODE :
    case RXGEN_OPCODE :
    case RXGEN_SS_XDRFREE :
    case RXGEN_CC_XDRFREE :
	return TRUE;
    default :
	return FALSE;
    }
}

d2126 1
a2126 1
    int ret = RX_CALL_DEAD;
d2131 1
d2133 1
a2133 1
    assert (CheckLock(&entry->lock) == -1);
d2146 1
a2146 1
	 conn = find_next_fs (ret_context, conn, fs_downp (ret))) {
d2148 1
d2154 4
a2157 2

	if (!try_next_fs (ret))
d2161 1
a2161 1
	if (ret == RX_CALL_DEAD)
d2174 1
a2174 1
    assert (CheckLock(&entry->lock) == -1);
d2193 1
a2193 1
    assert (CheckLock(&entry->lock) == -1);
d2217 1
d2221 1
a2221 1
    assert (CheckLock(&entry->lock) == -1);
d2248 1
a2264 2
    assert (sizefs == entry->status.Length);

d2297 2
d2312 1
a2312 1
    assert (CheckLock(&entry->lock) == -1);
d2327 1
a2327 1
     int ret = RX_CALL_DEAD;
d2335 1
a2335 1
     assert (CheckLock(&entry->lock) == -1);
d2367 1
a2367 1
	  conn = find_next_fs (&context, conn, fs_downp (ret))) {
d2381 1
a2381 1
	 if (ret == RX_CALL_DEAD) {
d2427 1
a2427 1
     if (ret == RX_CALL_DEAD)
d2430 1
a2430 1
     assert (CheckLock(&entry->lock) == -1);
d2444 1
a2444 1
    int ret = RX_CALL_DEAD;
a2445 1
    u_int32_t sizefs;
d2451 1
a2451 1
    assert (CheckLock(&entry->lock) == -1);
d2478 1
d2481 1
a2481 1
	 conn = find_next_fs (&context, conn, fs_downp (ret))) {
d2497 1
a2497 1
	if (ret == RX_CALL_DEAD) {
a2505 7
	sizefs = htonl (0);
	if (rx_Write (call, &sizefs, sizeof(sizefs)) != sizeof(sizefs)) {
	    ret = conv_to_arla_errno(rx_Error(call));
	    arla_warn (ADEBFCACHE, ret, "writing length");
	    rx_EndCall(call, 0);
	    break;
	}
d2510 5
a2514 5
	 if (ret) {
	     rx_EndCall (call, ret);
	     arla_warnx (ADEBFCACHE, "EndRXAFS_StoreData");
	     break;
	 }
d2516 5
a2520 5
	 ret = rx_EndCall (call, 0);
	 if (ret) {
	     arla_warn (ADEBFCACHE, ret, "rx_EndCall");
	 }
	 break;
a2527 2

	assert (entry->status.Length == size);
d2529 1
a2529 1
    if (ret == RX_CALL_DEAD)
d2532 1
a2532 1
    assert (CheckLock(&entry->lock) == -1);
d2545 1
a2545 1
    int ret = RX_CALL_DEAD;
d2549 1
a2549 1
    assert (CheckLock(&entry->lock) == -1);
d2562 1
a2562 1
	     conn = find_next_fs (&context, conn, fs_downp (ret))) {
d2571 1
a2571 1
	    if (ret == RX_CALL_DEAD) {
d2582 1
a2582 1
	if (ret == RX_CALL_DEAD) {
d2605 1
a2605 1
    assert (CheckLock(&entry->lock) == -1);
d2620 1
a2620 1
    int ret = RX_CALL_DEAD;
d2629 1
a2629 1
    assert (CheckLock(&dir_entry->lock) == -1);
d2637 1
a2637 1
	     conn = find_next_fs (&context, conn, fs_downp (ret))) {
d2650 1
a2650 1
	    if (ret == RX_CALL_DEAD) {
d2661 1
a2661 1
	if (ret == RX_CALL_DEAD) {
d2741 1
a2741 1
    assert (CheckLock(&dir_entry->lock) == -1);
d2756 1
a2756 1
    int ret = RX_CALL_DEAD;
d2764 1
a2764 1
    assert (CheckLock(&dir_entry->lock) == -1);
d2772 1
a2772 1
	     conn = find_next_fs (&context, conn, fs_downp (ret))) {
d2786 1
a2786 1
	    if (ret == RX_CALL_DEAD) {
d2797 1
a2797 1
	if (ret == RX_CALL_DEAD) {
d2868 1
a2868 1
    assert (CheckLock(&dir_entry->lock) == -1);
d2886 1
a2886 1
    int ret = RX_CALL_DEAD;
d2895 1
a2895 1
    assert (CheckLock(&dir_entry->lock) == -1);
d2902 1
a2902 1
	 conn = find_next_fs (&context, conn, fs_downp (ret))) {
d2915 1
a2915 1
	if (ret == RX_CALL_DEAD) {
d2926 1
a2926 1
    if (ret == RX_CALL_DEAD) {
d2958 1
a2958 1
    assert (CheckLock(&dir_entry->lock) == -1);
d2980 1
a2980 1
    assert (CheckLock(&dir_entry->lock) == -1);
d2987 1
a2987 1
	 conn = find_next_fs (&context, conn, fs_downp (ret))) {
d2998 1
a2998 1
	if (ret == RX_CALL_DEAD) {
d3009 1
a3009 1
    if (ret == RX_CALL_DEAD) {
d3021 1
a3021 1
    assert (CheckLock(&dir_entry->lock) == -1);
d3032 1
a3032 1
    int ret = RX_CALL_DEAD;
d3039 1
a3039 1
    assert (CheckLock(&dir_entry->lock) == -1);
d3046 1
a3046 1
	 conn = find_next_fs (&context, conn, fs_downp (ret))) {
d3055 1
a3055 1
	if (ret == RX_CALL_DEAD) {
d3066 1
a3066 1
    if (ret == RX_CALL_DEAD) {
d3075 1
a3075 1
    assert (CheckLock(&dir_entry->lock) == -1);
d3088 1
a3088 1
    int ret = RX_CALL_DEAD;
d3095 1
a3095 1
    assert (CheckLock(&dir_entry->lock) == -1);
d3102 1
a3102 1
	 conn = find_next_fs (&context, conn, fs_downp (ret))) {
d3111 1
a3111 1
	if (ret == RX_CALL_DEAD) {
d3122 1
a3122 1
    if (ret == RX_CALL_DEAD) {
d3131 1
a3131 1
    assert (CheckLock(&dir_entry->lock) == -1);
d3146 1
a3146 1
    int ret = RX_CALL_DEAD;
d3153 2
a3154 2
    assert (CheckLock(&old_dir->lock) == -1
	    && CheckLock(&new_dir->lock) == -1);
d3161 1
a3161 1
	 conn = find_next_fs (&context, conn, fs_downp (ret))) {
d3173 1
a3173 1
	if (ret == RX_CALL_DEAD) {
d3184 1
a3184 1
    if (ret == RX_CALL_DEAD) {
d3196 2
a3197 2
    assert (CheckLock(&old_dir->lock) == -1
	    && CheckLock(&new_dir->lock) == -1);
d3303 1
a3303 1
    int type;
d3320 1
a3320 1
	assert (CheckLock(&e->lock) == -1);
d3324 1
d3338 4
a3341 1
    memset (e->acccache,  0, sizeof(e->acccache));
d3358 1
d3391 1
a3391 1
    assert (CheckLock (&e->lock) == -1);
d3542 1
d3549 5
d3626 1
a3626 1
    ret = RX_CALL_DEAD;
d3630 1
a3630 1
	 conn = find_next_fs (&context, conn, fs_downp (ret))) {
d3641 1
a3641 1
	if (!try_next_fs (ret))
d3645 2
a3663 1
	VenusFid fid;
a3666 1
	fid.Cell = parent_entry->fid.Cell;
a3669 1
		ret = 0;
d3671 9
d3681 2
a3683 2
	    if (ret)
		break;
d3688 1
a3688 1
			       rx_HostOf (rx_PeerOf (conn->connection)),
d3691 1
a3691 1
	    if (!(prefered_entry && i == 0)) {
d3718 4
d3766 2
a3767 1
					 parent_entry->acccache);
d3826 1
a3826 1
	return dynroot_get_attr (entry);
d3915 1
a3915 1
    int ret = RX_CALL_DEAD;
d3924 1
a3924 1
	 conn = find_next_fs (&context, conn, fs_downp (ret))) {
d3926 1
a3926 1
	if (!try_next_fs (ret))
d3931 1
a3931 1
    if (ret == RX_CALL_DEAD)
d3948 1
a3948 1
    assert (CheckLock(&e->lock) == -1);
d3951 1
a3951 1
	return dynroot_get_data (e);
d4020 1
a4020 1
	install_attr (e);
d4136 3
a4138 1
 * If succesful, `
d4170 1
a4170 3
	new_ce = cred_get (cell, (*ce)->cred, (*ce)->type);
	if (new_ce == NULL)
	    new_ce = cred_get(cell, (*ce)->cred, CRED_ANY);
d4194 9
d4215 6
a4220 4
    e->flags.vol_root = TRUE;
    e->parent         = *parent;
    ve->parent_fid    = *parent;
    ve->mp_fid        = oldfid;
d4242 2
a4243 1
followmountpoint (VenusFid *fid, const VenusFid *parent, CredCacheEntry **ce)
d4258 1
a4258 1
     ret = fcache_verify_attr (e, NULL, NULL, *ce);
d4287 1
a4287 1
    assert (CheckLock(&e->lock) == -1);
d4367 1
a4367 10
    int fd;
    struct stat sb;

    fd = fcache_open_file (e, O_RDONLY);
    if (fd < 0)
	arla_err (1, ADEBERROR, errno, "fcache_open_file");

    if (fstat (fd, &sb) < 0)
	arla_err (1, ADEBERROR, errno, "fstat");
    close(fd);
d4369 1
a4369 3
    assert (len == sb.st_size);

    assert (usedbytes + len >= e->length);
d4391 3
d4403 1
a4403 1
    ret = RX_CALL_DEAD;
d4407 2
a4408 1
	 conn = find_next_fs (&context, conn, fs_downp (ret))) {
d4411 7
a4417 1
	if (!try_next_fs (ret))
d4427 1
a4427 1
    else if (ret == RX_CALL_DEAD)
d4464 1
a4464 1
    ret = RX_CALL_DEAD;
d4468 1
a4468 1
	 conn = find_next_fs (&context, conn, fs_downp (ret))) {
d4471 1
a4471 1
	if (!try_next_fs (ret))
d4481 1
a4481 1
    else if (ret == RX_CALL_DEAD)
d4520 1
a4520 1
    ret = RX_CALL_DEAD;
d4524 1
a4524 1
	 conn = find_next_fs (&context, conn, fs_downp (ret))) {
d4528 1
a4528 1
	if (!try_next_fs (ret))
d4534 1
a4534 1
    if (ret == RX_CALL_DEAD)
d4536 3
a4538 5
    if (ret == 0 && volumename[0] == '\0') {
	const char *tmp = volcache_getname (fid.fid.Volume, fid.Cell);
	if (tmp != NULL)
	    strlcpy (volumename, tmp, AFSNAMEMAX);
    }
d4569 1
a4569 1
    ret = RX_CALL_DEAD;
d4573 1
a4573 1
	 conn = find_next_fs (&context, conn, fs_downp (ret))) {
d4577 1
a4577 1
	if (!try_next_fs (ret))
d4581 1
a4581 1
	if (ret == RX_CALL_DEAD)
d4606 1
a4606 1
    assert (CheckLock (&centry->lock) == -1);
@


1.2
log
@upgrade Arla to fresher code. Too many new features and bugfixes.
@
text
@a0 1
/*	$OpenBSD$	*/
d2 1
a2 1
 * Copyright (c) 1995, 1996, 1997, 1998, 1999 Kungliga Tekniska Högskolan
d45 14
a58 1
RCSID("$KTH: fcache.c,v 1.189 1999/04/20 20:58:08 map Exp $") ;
d87 1
a87 1
static u_long lowvnodes, highvnodes, lowbytes, highbytes;
d91 1
a91 1
static u_long usedbytes, usedvnodes;
d100 1
a100 1
unsigned fprioritylevel;
d104 8
d168 14
d223 12
d242 10
d258 19
a276 1
    return snprintf (s, len, "%04X", (unsigned)entry->index);
a285 2
    int ret;

d290 1
a290 3
    ret = fcache_file_name (entry, s, len);
    *s += 0x10;
    return ret;
d300 1
a300 1
fhopen (xfs_cache_handle *handle, int flags)
d302 11
a312 1
    struct ViceIoctl vice_ioctl;
d314 16
a329 7
    vice_ioctl.in      = (caddr_t)handle;
    vice_ioctl.in_size = sizeof(*handle);

    vice_ioctl.out      = NULL;
    vice_ioctl.out_size = 0;

    return k_pioctl (NULL, VIOC_FHOPEN, &vice_ioctl, flags);
d339 8
a346 1
    struct ViceIoctl vice_ioctl;
d348 22
a369 10
    if (!fhopen_working)
	return 0;

    vice_ioctl.in      = NULL;
    vice_ioctl.in_size = 0;

    vice_ioctl.out      = (caddr_t)handle;
    vice_ioctl.out_size = sizeof(*handle);

    return k_pioctl (filename, VIOC_FHGET, &vice_ioctl, 0);
d373 1
a373 1
 * create a new cache vnode
d380 1
d386 21
a406 4
    assert (fd >= 0);
    ret = close (fd);
    assert (ret == 0);
    return fcache_fhget (fname, &entry->handle);
d420 1
a420 1
	ret = fhopen (&entry->handle, flag);
a446 29
 * Create `n' new entries
 */

static void
create_new_entries (unsigned n)
{
    FCacheEntry *entries;
    unsigned int i, j;

    entries = calloc (n, sizeof(FCacheEntry));
    if (entries == NULL)
	arla_errx (1, ADEBERROR, "fcache: calloc failed");
    
    for (i = 0; i < n; ++i) {
	entries[i].lru_le      = listaddhead (lrulist, &entries[i]);
	entries[i].invalid_ptr = -1;
	entries[i].volume      = NULL;
	entries[i].refcount    = 0;
	entries[i].anonaccess  = 0;
	for (j = 0; j < NACCESS; j++) {
	    entries[i].acccache[j].cred = ARLA_NO_AUTH_CRED;
	    entries[i].acccache[j].access = 0;
	}
	Lock_Init(&entries[i].lock);
    }
}


/*
a454 1
    int ret;
d462 1
a462 1
	return;
d466 2
a467 6
	ret = close (fd);
	assert (ret == 0);
	return;
    }
    if (entry->status.FileType != TYPE_DIR) {
	assert (sb.st_size == entry->status.Length);
d471 2
a472 3
	ret = close (fd);
	assert (ret == 0);
	return;
d474 1
a474 2
    ret = close (fd);
    assert (ret == 0);
d481 6
a486 2
    assert(usedbytes >= entry->status.Length);
    usedbytes -= sb.st_size;
d489 3
d519 1
a519 1
    assert (entry->flags.usedp && entry->volume != NULL
d550 4
a553 3
    volcache_free (entry->volume);
    entry->volume = NULL;
/*    entry->inode  = 0;*/
d564 1
a564 1
static ino_t
d571 2
a572 1
 * Allocate a cache file for `e'
d576 1
a576 1
create_node (FCacheEntry *e)
d578 3
a580 4
    assert (CheckLock (&e->lock) == -1);
    e->index = next_cache_index ();
    fcache_create_file (e);
}
d582 2
a583 3
/*
 * Pre-create cache nodes for all entries in lrulist that doesn't have any.
 */
d585 2
a586 6
static void
create_nodes (char *arg)
{
    Listitem *item;
    FCacheEntry *entry;
    unsigned count = 0;
d588 1
a588 2
    arla_warnx (ADEBFCACHE,
		"pre-creating nodes");
d590 23
a612 3
    for (item = listtail (lrulist);
	 item;
	 item = listprev (lrulist, item)) {
d614 1
a614 6
	entry = (FCacheEntry *)listdata (item);
	assert (entry->lru_le == item);
	if (!entry->flags.usedp
	    && CheckLock(&entry->lock) == 0
	    && entry->index == 0) {
	    struct timeval tv;
a615 3
	    ObtainWriteLock (&entry->lock);
	    create_node (entry);
	    ReleaseWriteLock (&entry->lock);
d619 5
d626 3
a629 3

    arla_warnx (ADEBFCACHE,
		"pre-created %u nodes", count);
d633 1
a633 1
 *
d636 2
d641 11
d655 14
a668 1
	int prio;
d670 27
a696 23
	arla_warnx(ADEBCLEANER,
		   "running cleaner: "
		   "%lu (%lu-%lu) files, "
		   "%lu (%lu-%lu) bytes",
		   usedvnodes, lowvnodes, highvnodes,
		   usedbytes, lowbytes, highbytes);

	for (prio = 0 ; prio <= fprioritylevel ; prio += 10) {

	    while (usedvnodes > lowvnodes) {

		for (item = listtail (lrulist);
		     item && usedvnodes > lowvnodes;
		     item = prev) {
		    prev = listprev (lrulist, item);
		    entry = (FCacheEntry *)listdata (item);
		    assert (entry->lru_le == item);
		    if (entry->flags.usedp
			&& !entry->flags.attrusedp
			&& !entry->flags.datausedp
			&& entry->priority < prio
			&& entry->refcount == 0
			&& CheckLock(&entry->lock) == 0) {
d700 1
d702 15
a716 1
			entry->lru_le = listaddtail (lrulist, entry);
d720 25
a744 1
		if (item == NULL)
d746 2
a747 15
	    }

	    for (item = listtail (lrulist);
		 item && usedbytes > lowbytes;
		 item = listprev (lrulist, item)) {
		entry = (FCacheEntry *)listdata (item);
		assert (entry->lru_le == item);
		if (entry->flags.datap
		    && !entry->flags.datausedp
		    && entry->priority < prio
		    && entry->refcount == 0
		    && CheckLock(&entry->lock) == 0) {
		    ObtainWriteLock (&entry->lock);
		    throw_data (entry);
		    ReleaseWriteLock (&entry->lock);
d751 2
a752 1

d755 22
a776 4
		   "%lu (%lu-%lu) files, "
		   "%lu (%lu-%lu) bytes",
		   usedvnodes, lowvnodes, highvnodes,
		   usedbytes, lowbytes, highbytes);
d778 21
a798 1
	IOMGR_Sleep (CLEANER_SLEEP);
d800 10
d812 1
d814 2
a815 2
 * XXX: will not work if an entry with shorter invalidation time
 *      than the shortest existing invalidation time is inserted.
d846 6
a851 4
	    heap_remove_head (invalid_heap);
	    entry->invalid_ptr = -1;
	    if (entry->flags.kernelp)
		break_callback (entry->fid);
d864 2
d868 1
d872 1
a872 1
 * Remove the entry least-recently used and return it.  Sleep until
d881 3
d921 1
a921 30
	 LWP_WaitProcess (lrulist);
     }
}

/*
 *
 */

static void
emergency_remove_data (size_t sz)
{
     FCacheEntry *entry = NULL;
     Listitem *item;
     int prio;

     for (prio = 0 ; prio <= fprioritylevel ; prio += 10) {
     
	 for (item = listtail (lrulist);
	      item && usedbytes + sz > highbytes;
	      item = listprev (lrulist, item)) {
	     entry = (FCacheEntry *)listdata (item);
	     if (entry->flags.datap
		 && !entry->flags.datausedp
		 && entry->priority < prio
		 && CheckLock(&entry->lock) == 0) {
		 ObtainWriteLock (&entry->lock);
		 throw_data (entry);
		 ReleaseWriteLock (&entry->lock);
	     }
	 }
d926 1
a926 1
 * Return a usable entry.
d936 1
a936 1
	arla_warnx (ADEBFCACHE, "All vnode entries in use");
d954 1
d959 10
a978 1
	    int ret;
d980 1
a980 2
	    ret = close (fd);
	    assert (ret == 0);
d1007 1
a1007 1
    int ret;
d1012 16
d1035 1
a1035 1
	int32_t type;
d1047 1
d1054 1
d1077 2
d1080 1
a1082 1
	e->realfid = tmp.realfid;
d1084 2
d1090 1
a1090 1
	    usedbytes += e->status.Length;
d1093 1
a1093 2
    ret = close (fd);
    assert (ret == 0);
d1095 1
d1105 1
a1105 1
findaccess (pag_t cred, AccessEntry *ae, AccessEntry **pos)
a1114 1
     assert (i == NACCESS);
a1116 1
     
d1121 10
d1136 3
a1138 1
find_next_fs (fs_server_context *context, ConnCacheEntry *prev_conn)
d1140 1
a1140 1
    if (prev_conn != NULL)
d1175 1
a1175 1
    int bit = 0;
d1180 8
a1187 3
    if (connected_mode == DISCONNECTED) {
	context->num_conns = 0;
	return NULL;
d1194 1
d1196 5
a1200 13
    if (ve->entry.volumeId[RWVOL] == e->fid.fid.Volume
	&& ve->entry.flags & VLF_RWEXISTS)
	bit = VLSF_RWVOL;

    if (ve->entry.volumeId[ROVOL] == e->fid.fid.Volume
	&& ve->entry.flags & VLF_ROEXISTS)
	bit = VLSF_ROVOL;

    if (ve->entry.volumeId[BACKVOL] == e->fid.fid.Volume
	&& ve->entry.flags & VLF_BACKEXISTS)
	bit = VLSF_RWVOL;

    assert (bit);
d1203 1
a1203 1
    for (i = 0; i < NMAXNSERVERS; ++i) {
d1227 1
a1227 1
    return find_next_fs (context, NULL);
d1246 1
d1248 3
d1267 1
a1267 1
    invalid_heap = heap_new (highvnodes, expiration_time_cmp);
a1270 2
    create_new_entries (highvnodes);

d1303 3
d1307 1
a1307 1
	create_new_entries(ahighvnodes - highvnodes);
d1309 4
a1312 2
    } else
	return EINVAL;
d1367 1
d1384 6
a1389 2
	    break_callback (e->fid);
	e->flags.kernelp   = FALSE;
d1391 1
a1391 1
	e->flags.datap     = FALSE;
d1398 24
d1431 10
d1452 1
a1452 1
    pag_t pag;
d1489 1
a1489 1
fcache_purge_cred (pag_t pag, int32_t cell)
d1510 2
a1511 2
    if (e->fid.Cell == fid->Cell &&
	e->fid.fid.Volume == fid->fid.Volume) {
d1555 1
a1555 2
 * Mark `entry' as not being used. Wake up any threads sleeping in
 * unlink_lru_entry
d1562 7
a1568 1
    LWP_NoYieldSignal (lrulist);
d1572 1
a1572 2
 * Update all the relevant parts of `entry' after having received new
 * data from the file server.
d1576 39
a1614 6
update_entry (FCacheEntry *entry,
	      AFSFetchStatus *status,
	      AFSCallBack *callback,
	      AFSVolSync *volsync,
	      u_int32_t host,
	      pag_t cred)
d1620 1
a1620 1
    if (cell_issuid_by_num (entry->volume->cell))
d1634 2
a1635 1
	volcache_update_volsync (entry->volume, *volsync);
d1643 33
d1678 1
d1693 4
a1696 1
	if (entry->flags.attrp && entry->host != 0) {
d1740 4
a1743 1
	if (entry->flags.usedp && entry->host != 0) {
d1749 2
d1757 8
d1780 1
d1801 1
a1803 1
    case ARLA_VNOVOL :
d1813 23
d1841 3
d1860 9
d1871 2
a1872 1
	 conn = find_next_fs (ret_context, conn)) {
a1881 2
    assert (CheckLock(&entry->lock) == -1);

d1883 1
a1883 3
	if (ret == RX_CALL_DEAD) {
	    if (connected_mode == DISCONNECTED && entry->flags.attrp)
		return 0;
a1884 1
	}
d1886 1
d1890 1
a1890 9
    if (entry->flags.datap
	&& entry->status.DataVersion != status.DataVersion) {
	throw_data (entry);
	entry->tokens &= ~(XFS_DATA_R|XFS_DATA_W);
    }

    update_entry (entry, &status, &callback, &volsync,
		  rx_HostOf (rx_PeerOf (conn->connection)),
		  ce->cred);
d1892 3
a1894 2
    entry->tokens |= XFS_ATTR_R;
    entry->flags.attrp = TRUE;
d1917 1
a1918 1
    free_fs_server_context (&context);
d1921 1
d1944 4
a1947 2
    if (connected_mode == DISCONNECTED) 
	return ENETDOWN;
d1949 4
a1952 2
    if (usedbytes + entry->status.Length > highbytes)
	emergency_remove_data (entry->status.Length);
d1955 3
a1968 2
    assert (CheckLock(&entry->lock) == -1);

a1970 3

    assert (CheckLock(&entry->lock) == -1);

a1975 2
    assert (CheckLock(&entry->lock) == -1);

a1976 3

    assert (CheckLock(&entry->lock) == -1);

d1978 1
a1978 1
	ret = rx_Error(call);
a1986 2
    assert (CheckLock(&entry->lock) == -1);

d1996 6
a2001 1
    assert (CheckLock(&entry->lock) == -1);
d2003 1
a2003 1
    ret = copyrx2fd (call, fd, sizefs);
a2010 4
    assert (CheckLock(&entry->lock) == -1);

    usedbytes += sizefs;		/* XXX - sync */

a2014 2
    assert (CheckLock(&entry->lock) == -1);

d2019 2
d2025 2
d2047 1
a2047 2
     int ret = 0;
     int close_ret;
a2051 1
     AFSCallBack callback;
d2057 5
a2061 1
     fd = fcache_open_file (entry, O_RDONLY);
a2069 2
	 int close_ret;

d2071 1
a2071 2
	 close_ret = close (fd);
	 assert (close_ret == 0);
d2081 1
a2081 4
	 int close_ret;

	 close_ret = close (fd);
	 assert (close_ret == 0);
d2087 1
a2087 1
	  conn = find_next_fs (&context, conn)) {
d2110 1
a2110 1
	 ret = copyfd2rx (fd, call, sizefs);
a2118 1
				   &callback,
d2134 3
a2136 2
	 if (ret == 0)
	     update_entry (entry, &status, &callback, &volsync,
d2139 9
a2147 1
     } else {
a2148 1
     }
d2150 2
a2151 2
     close_ret = close (fd);
     assert(close_ret == 0);
d2164 1
a2164 1
    int ret = 0;
a2168 1
    AFSCallBack callback;
a2170 1
    int close_ret;
d2185 1
a2185 2
	close_ret = close (fd);
	assert (close_ret == 0);
d2189 1
a2189 2
    close_ret = close (fd);
    assert (close_ret == 0);
d2192 1
a2192 1
	entry->status.Length = 0;
d2201 1
a2201 1
	 conn = find_next_fs (&context, conn)) {
d2228 1
a2228 1
	    ret = rx_Error(call);
a2235 1
				  &callback,
d2250 5
a2254 5
    if (conn != NULL) {
	if (ret == 0) {
	    update_entry (entry, &status, &callback, &volsync,
			  rx_HostOf(rx_PeerOf(conn->connection)),
			  ce->cred);
d2256 3
a2258 3
	    assert (entry->status.Length == size);
	}
    } else {
a2259 1
    } 
d2261 1
d2274 1
a2274 2
    ConnCacheEntry *conn;
    int ret = 0;
a2276 2
    fs_server_context context;
    u_int32_t host;
d2280 14
a2293 3
    for (conn = find_first_fs (entry, ce, &context);
	 conn != NULL;
	 conn = find_next_fs (&context, conn)) {
d2295 15
a2309 1
	host = rx_HostOf (rx_PeerOf (conn->connection));
a2310 5
	ret = RXAFS_StoreStatus (conn->connection,
				 &entry->fid.fid,
				 store_status,
				 &status,
				 &volsync);
d2312 1
a2312 3
	    continue;
	} else if (ret) {
	    arla_warn (ADEBFCACHE, ret, "store-status");
a2314 2
	break;
    }
d2316 15
a2330 3
    if (conn == NULL) {
	ret = ENETDOWN;
	goto out;
d2333 2
a2334 1
    update_entry (entry, &status, NULL, &volsync, host, ce->cred);
a2335 2
out:
    free_fs_server_context (&context);
d2349 1
a2349 2
    int ret = 0;
    int close_ret;
a2355 1
    fs_server_context context;
d2362 1
d2366 1
a2366 1
	     conn = find_next_fs (&context, conn)) {
d2390 4
a2393 2
	if (conn == NULL)
	    return ENETDOWN;
a2394 1
	status.Length = dir_entry->status.Length;
d2398 1
a2398 1
	static int fakefid = 100;
d2403 1
a2403 1
	++fakefid;
d2405 6
a2410 1
	fetch_attr->ClientModTime    = store_attr->ClientModTime;
d2412 2
a2413 1
	fetch_attr->Group            = store_attr->Group;
d2415 2
d2418 1
d2420 1
a2420 5
	fetch_attr->FileType         = TYPE_FILE;
	fetch_attr->DataVersion      = 1;
	fetch_attr->InterfaceVersion = 1;
	fetch_attr->Author           = fetch_attr->Owner;
	fetch_attr->LinkCount        = 1;
d2426 2
a2427 4
	fetch_attr->ParentVnode      = dir_entry->fid.fid.Vnode;
	fetch_attr->ParentUnique     = dir_entry->fid.fid.Unique;
	fetch_attr->CallerAccess     = dir_entry->status.CallerAccess;
	fetch_attr->AnonymousAccess  = dir_entry->status.AnonymousAccess;
d2457 1
a2457 2
	close_ret = close (fd);
	assert (close_ret == 0);
d2461 2
a2462 2
    close_ret = close (fd);
    assert (close_ret == 0);
d2470 2
d2485 1
a2485 2
    int ret = 0;
    ConnCacheEntry *conn;
a2491 1
    fs_server_context context;
d2495 9
a2503 3
    for (conn = find_first_fs (dir_entry, ce, &context);
	 conn != NULL;
	 conn = find_next_fs (&context, conn)) {
d2505 9
a2513 1
	host = rx_HostOf(rx_PeerOf(conn->connection));
d2515 10
a2524 9
	ret = RXAFS_MakeDir (conn->connection,
			     &dir_entry->fid.fid,
			     name,
			     store_attr,
			     &OutFid,
			     fetch_attr,
			     &status,
			     &callback,
			     &volsync);
d2527 1
a2527 4
	    continue;
	} else if (ret) {
	    free_fs_server_context (&context);
	    arla_warn (ADEBFCACHE, ret, "MakeDir");
a2529 3
	break;
    }
    free_fs_server_context (&context);
d2531 4
a2534 2
    if (conn == NULL)
	return ENETDOWN;
d2536 29
a2564 3
    status.Length = dir_entry->status.Length;
    update_entry (dir_entry, &status, &callback, &volsync,
		  host, ce->cred);
d2575 3
a2590 2
    usedbytes += child_entry->status.Length;

d2597 1
d2603 3
d2615 1
a2615 1
    int ret = 0;
d2626 3
d2631 1
a2631 1
	 conn = find_next_fs (&context, conn)) {
d2655 4
a2658 2
    if (conn == NULL)
	return ENETDOWN;
a2659 1
    new_status.Length = dir_entry->status.Length;
d2674 6
a2679 1
    usedbytes += child_entry->status.Length;
a2681 1
    child_entry->flags.kernelp = TRUE;
d2687 1
d2711 3
d2716 1
a2716 1
	 conn = find_next_fs (&context, conn)) {
d2738 4
a2741 4
    if (conn == NULL)
	return ENETDOWN;

    status.Length = dir_entry->status.Length;
d2750 1
d2761 1
a2761 1
    int ret = 0;
d2770 3
d2775 1
a2775 1
	 conn = find_next_fs (&context, conn)) {
d2795 4
a2798 4
    if (conn == NULL)
	return ENETDOWN;

    status.Length = dir_entry->status.Length;
d2804 1
d2817 1
a2817 1
    int ret = 0;
d2826 3
d2831 1
a2831 1
	 conn = find_next_fs (&context, conn)) {
d2851 4
a2854 4
    if (conn == NULL)
	return ENETDOWN;

    status.Length = dir_entry->status.Length;
d2860 1
d2875 1
a2875 1
    int ret = 0;
d2885 3
d2890 1
a2890 1
	 conn = find_next_fs (&context, conn)) {
d2913 4
a2916 5
    if (conn == NULL)
	return ENETDOWN;

    orig_status.Length = old_dir->status.Length;
    new_status.Length  = new_dir->status.Length;
d2925 2
d2940 1
a2940 1
     int32_t type;
d2942 8
d2951 14
a2964 1
     ret = volcache_getbyname (root_volume, 0, ce, &ve, &type);
d2966 3
a2968 1
	 arla_warnx (ADEBFCACHE, "Cannot find the root volume");
d2972 1
a2972 1
     fid.Cell = 0;
d2977 2
a2978 2
		    "getroot: %s is missing a RO clone, not good",
		    root_volume);
d2982 2
a2983 2
		   "getroot: %s has no RW or RO clone?",
		   root_volume);
d2998 1
a2998 1
gettype (int32_t volid, VolCacheEntry *ve)
d3032 1
a3032 1
    int32_t type;
d3035 2
d3049 3
d3059 8
a3066 4
    e->fid     = fid;
    e->realfid = fid;
    if (e->index == 0)
	create_node (e);
a3067 1
    e->tokens          = 0;
d3075 2
d3079 6
a3084 1
    e->host	       = 0;
d3086 2
a3087 1
    e->volume          = NULL;
a3088 1
    e->lru_le = listaddhead (lrulist, e);
d3153 367
a3519 2
 * Make sure that `e' has attributes and that they are up-to-date.
 * `e' must be write-locked.
d3523 2
a3524 1
fcache_get_attr (FCacheEntry *e, CredCacheEntry *ce)
d3526 1
d3528 4
a3531 1
    assert (e->flags.usedp);
d3533 9
a3541 1
    assert (CheckLock(&e->lock) == -1);
d3543 7
a3549 2
    if (e->flags.attrp && uptodatep(e) &&
	findaccess(ce->cred, e->acccache, &ae) != FALSE)
d3551 52
d3604 3
a3606 1
    return read_attr (e, ce);
d3609 8
d3624 3
d3629 1
a3629 1
	 conn = find_next_fs (&context, conn)) {
d3636 2
a3637 2
    if (conn == NULL)
	return ENETDOWN;
d3646 1
a3646 1
fcache_get_data (FCacheEntry *e, CredCacheEntry *ce)
d3653 4
d3658 3
a3660 1
    assert (CheckLock(&e->lock) == -1);
d3663 2
a3664 1
	if (e->flags.datap)
d3666 1
a3666 1
	else
d3670 1
a3670 2
	if (ret) {
	    free_fs_server_context (&context);
a3671 1
	}
d3673 1
d3684 53
d3739 4
d3749 1
a3749 1

d3788 1
a3788 1
	     u_int32_t *volid)
a3789 1
    VolCacheEntry *ve;
d3794 1
a3794 1
    res = volcache_getbyname (volname, cell, ce, &ve, &this_type);
d3803 4
a3806 1
	assert (ve->entry.flags & VLF_ROEXISTS);
d3809 1
a3809 1
	volcache_free (ve);
d3812 4
a3815 1
	assert (ve->entry.flags & VLF_BOEXISTS);
d3820 1
a3820 1
	if (ve->entry.flags & VLF_ROEXISTS)
d3825 1
a3825 1
	if (ve->entry.flags & VLF_RWEXISTS)
d3827 1
a3827 1
	else if (ve->entry.flags & VLF_ROEXISTS)
d3830 1
a3830 1
	    volcache_free (ve);
d3834 1
a3834 2
    *volid = ve->entry.volumeId[result_type];
    volcache_free (ve);
d3841 1
d3845 3
a3847 2
get_root_of_volume (VenusFid *fid, VenusFid *parent,
		    VolCacheEntry *volume, CredCacheEntry **ce,
d3857 1
d3886 1
a3886 1
		       parent_type, &volid);
d3900 2
a3901 1
    if (res)
d3903 1
d3906 1
a3906 1
     * Mount points are a little bit special.  We keep track of
d3908 1
a3908 2
     * properly.  Also, increment the refcount so that this entry
     * doesn't get gc:ed away under out feet.
d3911 5
a3915 4
    ++e->refcount;
    e->flags.mountp = TRUE;
    e->realfid = oldfid;
    e->parent = *parent;
d3917 1
d3936 1
a3936 1
followmountpoint (VenusFid *fid, VenusFid *parent, CredCacheEntry **ce)
a3937 3
     int fd;
     fbuf the_fbuf;
     char *buf;
d3939 1
a3939 3
     int res;
     u_int32_t length;
     int close_ret;
d3943 1
a3943 1
      * with the correct contents.  Otherwise, just return the old
d3947 3
a3949 3
     res = fcache_get (&e, *fid, *ce);
     if (res)
	 return res;
d3951 2
a3952 2
     res = fcache_get_attr (e, *ce);
     if (res) {
d3954 1
a3954 1
	 return res;
d3957 34
a3990 5
     if (e->status.FileType != TYPE_LINK
	 || e->status.Length == 0) {
	 fcache_release(e);
	 return 0;
     }
d3992 7
a3998 11
     res = fcache_get_data (e, *ce);
     if (res) {
	 fcache_release(e);
	 return res;
     }
     
     length = e->status.Length;
     if (length == 0) {
	 fcache_release(e);
	 return 0;
     }
d4000 1
a4000 5
     fd = fcache_open_file (e, O_RDONLY);
     if (fd < 0) {
	 fcache_release(e);
	 return errno;
     }
d4002 6
a4007 14
     res = fbuf_create (&the_fbuf, fd, length, FBUF_READ);
     if (res) {
	 close_ret = close (fd);
	 assert (close_ret == 0);
	 fcache_release(e);
	 return res;
     }
     buf = (char *)(the_fbuf.buf);
     if (*buf == '#' || *buf == '%')
	 res = get_root_of_volume (fid, parent, e->volume, ce,
				   buf, e->status.Length);
     fcache_release(e);
     fbuf_end (&the_fbuf);
     return res;
d4019 1
a4019 1
    arla_log(ADEBVLOG, "(%d, %u, %u, %u)%s%s%s%s%s%s%s%s%s length: %ld\n",
d4031 3
d4046 1
a4046 1
    arla_log(ADEBVLOG, "%lu (%lu-%lu) files\n"
d4048 1
a4048 1
	     usedvnodes, lowvnodes, highvnodes,
a4061 1
    int close_ret;
d4064 2
a4065 4
    if (fd < 0) {
	arla_warn (ADEBFCACHE, errno, "fcache_open_file");
	assert(FALSE);
    }
d4067 3
a4069 8
    if (fstat (fd, &sb) < 0) {
	arla_warn (ADEBFCACHE, errno, "fstat");
	close_ret = close (fd);
	assert (close_ret);
	assert (FALSE);
    }
    close_ret = close(fd);
    assert(close_ret == 0);
d4073 1
a4073 1
    assert (usedbytes + len >= e->status.Length);
d4075 2
a4076 2
    usedbytes = usedbytes - e->status.Length + len;
    e->status.Length = len;
d4095 3
d4108 1
a4108 1
	 conn = find_next_fs (&context, conn)) {
a4115 1
    free_fs_server_context (&context);
d4117 5
a4121 1
    if (conn == NULL)
d4124 1
d4131 3
d4139 2
a4140 1
       AFSOpaque *opaque)
d4149 3
d4162 1
a4162 1
	 conn = find_next_fs (&context, conn)) {
a4169 1
    free_fs_server_context (&context);
d4171 5
a4175 1
    if (conn == NULL)
d4178 7
a4184 3
    if (ret == 0 && dire->flags.kernelp) {
	break_callback (dire->fid);
	dire->flags.kernelp = FALSE;
a4185 2

    fcache_release (dire);
d4205 3
d4218 1
a4218 1
	 conn = find_next_fs (&context, conn)) {
d4228 1
a4228 2

    if (conn == NULL)
d4230 5
d4256 3
d4269 1
a4269 1
	 conn = find_next_fs (&context, conn)) {
d4276 3
a4278 1
    if (ret)
d4280 1
a4282 3
    if (conn == NULL)
	ret = ENETDOWN;

d4285 82
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
 * Copyright (c) 1995, 1996, 1997, 1998 Kungliga Tekniska Högskolan
d46 1
a46 1
RCSID("$KTH: fcache.c,v 1.114 1998/08/13 21:32:38 assar Exp $") ;
d68 1
a68 1
 * List of entries to be invalidated.
d71 1
a71 1
static List *invalid_list;
d90 1
a90 3
/* This is just temporary for allocating "inode"-numbers. */

static int inode_count;		/* XXX */
d120 28
d177 13
d196 125
d335 5
a339 5
	entries[i].lru_le     = listaddhead (lrulist, &entries[i]);
	entries[i].invalid_le = NULL;
	entries[i].volume     = NULL;
	entries[i].refcount   = 0;
	entries[i].anonaccess = 0;
d357 2
d363 1
a363 1
    fd = fcache_open_file (entry, O_WRONLY | O_TRUNC, 0);
d368 17
a384 1
    close (fd);
d392 1
a392 1
    usedbytes -= entry->status.Length;
d398 12
d430 3
a432 3
    if (entry->invalid_le != NULL) {
	listdel (invalid_list, entry->invalid_le);
	entry->invalid_le = NULL;
d440 1
a440 1
			 FS_SERVICE_ID, ce);
d442 10
a451 8

	fids.len = cbs.len = 1;
	fids.val = &entry->fid.fid;
	cbs.val  = &entry->callback;
	ret = RXAFS_GiveUpCallBacks (conn->connection, &fids, &cbs);
	conn_free (conn);
	if (ret)
	    arla_warn (ADEBFCACHE, ret, "RXAFS_GiveUpCallBacks");
d459 1
d463 1
a463 1
 * Return the next inode-number.
d467 11
a477 1
nextinode (void)
d479 3
a481 1
     return inode_count++;
d485 1
a485 1
 *
a492 1
    int fd;
d506 1
a506 1
	    && entry->inode == 0) {
d510 1
a510 3
	    entry->inode = nextinode ();
	    fd = fcache_open_file (entry, O_RDWR | O_CREAT | O_TRUNC, 0666);
	    close (fd);
d599 2
a600 1
 *
d607 1
a607 1
	Listitem *item, *next;
d610 5
a614 2
	while (listemptyp (invalid_list))
	    LWP_WaitProcess (invalid_list);
d618 2
a619 4
	for (item = listhead (invalid_list);
	     item;
	     item = next) {
	    FCacheEntry *entry = (FCacheEntry *)listdata(item);
d621 2
a622 1
	    assert (entry->invalid_le == item);
d624 3
a626 3
	    next = listnext (invalid_list, item);
	    if (tv.tv_sec < entry->callback.ExpirationTime) {
		IOMGR_Sleep (entry->callback.ExpirationTime - tv.tv_sec);
d629 1
a629 1
	    
d631 2
a632 2
	    listdel (invalid_list, item);
	    entry->invalid_le = NULL;
d647 2
a648 21
    Listitem *item;

    if (e->invalid_le != NULL) {
	listdel (invalid_list, e->invalid_le);
	e->invalid_le = NULL;
    }

    for (item = listhead (invalid_list);
	 item;
	 item = listnext (invalid_list, item)) {
	FCacheEntry *this_entry = (FCacheEntry *)listdata (item);

	if (e->callback.ExpirationTime < this_entry->callback.ExpirationTime) {
	    e->invalid_le = listaddbefore (invalid_list,
					   item,
					   e);
	    return;
	}
    }
    e->invalid_le = listaddhead (invalid_list, e);
    LWP_NoYieldSignal (invalid_list);
d652 2
a653 2
 * Remove the entry least-recently used and return it or NULL if none
 * is found.
d662 21
a682 14
     assert (!listemptyp (lrulist));
     for (item = listtail (lrulist);
	  item;
	  item = listprev (lrulist, item)) {

	  entry = (FCacheEntry *)listdata (item);
	  if (!entry->flags.usedp
	      && CheckLock(&entry->lock) == 0) {
	      ObtainWriteLock (&entry->lock);
	      listdel (lrulist, entry->lru_le);
	      entry->lru_le = NULL;
	      return entry;
	  }
     }
d684 12
a695 17
     assert (!listemptyp (lrulist));
     for (item = listtail (lrulist);
	  item;
	  item = listprev (lrulist, item)) {

	  entry = (FCacheEntry *)listdata (item);
	  if (entry->flags.usedp
	      && !entry->flags.attrusedp
	      && entry->refcount == 0
	      && CheckLock(&entry->lock) == 0) {
	      ObtainWriteLock (&entry->lock);
	      listdel (lrulist, entry->lru_le);
	      entry->lru_le = NULL;
	      throw_entry (entry);
	      return entry;
	  }
     }
d697 2
a698 17
     assert (!listemptyp (lrulist));
     for (item = listtail (lrulist);
	  item;
	  item = listprev (lrulist, item)) {

	  entry = (FCacheEntry *)listdata (item);
	  if (entry->flags.usedp
	      && entry->refcount == 0
	      && CheckLock(&entry->lock) == 0) {
	      ObtainWriteLock (&entry->lock);
	      listdel (lrulist, entry->lru_le);
	      entry->lru_le = NULL;
	      if (entry->flags.kernelp)
		  break_callback (entry->fid);
	      throw_entry (entry);
	      return entry;
	  }
a699 2

     return NULL;
a727 13
	 
	 for (item = listtail (lrulist);
	      item && usedbytes + sz > highbytes;
	      item = listprev (lrulist, item)) {
	     entry = (FCacheEntry *)listdata (item);
	     if (entry->flags.datap
		 && entry->priority < prio
		 && CheckLock(&entry->lock) == 0) {
		 ObtainWriteLock (&entry->lock);
		 throw_data (entry);
		 ReleaseWriteLock (&entry->lock);
	     }
	 }
a728 1

d773 6
a778 2
	    close (fd);
	    return errno;
d804 1
d815 2
d821 2
a822 1
	vol = volcache_getbyid (tmp.fid.fid.Volume, tmp.fid.Cell, ce);
d824 1
a824 1
	if (vol == NULL)
d845 3
a847 2
	e->inode = tmp.inode;
	inode_count = max(inode_count, tmp.inode + 1);
d855 2
a856 1
	e->flags.mountp = tmp.flags.mountp;
d868 2
a869 1
    close (fd);
d898 33
a930 2
 * Find the file server we should be talking to for a given fid and
 * user and return the connection.
d933 4
a936 2
static ConnCacheEntry *
findconn (FCacheEntry *e, CredCacheEntry *ce)
a937 1
    ConnCacheEntry *conn;
d940 13
a952 2
    u_long addr = 0;
    int type = -1, bit;
a953 5
    for (i = RWVOL; i <= BACKVOL; ++i)
	if (ve->entry.volumeId[i] == e->fid.fid.Volume) {
	    type = i;
	    break;
	}
d955 2
a956 2
    switch (type) {
    case RWVOL :
d958 3
a960 2
	break;
    case ROVOL :
d962 24
a985 6
	break;
    case BACKVOL :
	bit = VLSF_BACKVOL;
	break;
    default :
	abort ();
d988 2
a989 5
    for (i = 0; i < MAXNSERVERS; ++i)
	if (ve->entry.serverFlags[i] & bit) {
	    addr = htonl(ve->entry.serverNumber[i]);
	    break;
	}
d991 2
a992 1
    assert (addr != 0);
d994 1
a994 6
    conn = conn_get (e->fid.Cell, addr, afsport, FS_SERVICE_ID, ce);
    if (conn == NULL) {
	  arla_warnx (ADEBFCACHE, "Cannot connect to FS");
	  return NULL;
    }
    return conn;
d1013 3
a1015 1
    inode_count    = 1;		/* XXX */
d1030 3
a1032 3
    invalid_list = listnew ();
    if (invalid_list == NULL)
	arla_errx (1, ADEBERROR, "fcache: listnew failed");
d1088 1
a1088 1
 * If it's found, move it to the front of the lrulist as well.
d1092 1
a1092 1
find_entry (VenusFid fid)
d1097 3
a1102 1
	ObtainWriteLock (&e->lock);
d1110 16
d1136 15
a1150 9
    assert (CheckLock (&e->lock) == 0);

    ObtainWriteLock (&e->lock);
    e->callback = callback;
    e->tokens   = 0;
    if (e->flags.kernelp)
	break_callback (e->fid);
    e->flags.kernelp = FALSE;
    ReleaseWriteLock (&e->lock);
d1162 1
a1162 1
    e = find_entry (fid);
a1168 2

    ReleaseWriteLock(&e->lock);
a1171 1

a1176 1

d1195 2
a1196 1
		stale(e, e->callback);
d1260 2
a1261 4
    if (e->host == *host) {
	if (CheckLock (&e->lock) == 0)
	    stale (e, broken_callback);
    }
d1276 2
a1277 1
 * return the file name of the cached file for `entry'.
d1280 2
a1281 2
int
fcache_file_name (FCacheEntry *entry, char *s, size_t len)
d1283 2
a1284 48
    return snprintf (s, len, "%04X", (unsigned)entry->inode);
}

/*
 * return the file name of the converted directory for `entry'.
 */

int
fcache_extra_file_name (FCacheEntry *entry, char *s, size_t len)
{
    int ret;

    assert (entry->flags.datap &&
	entry->flags.extradirp &&
	entry->status.FileType == TYPE_DIR);

    ret = fcache_file_name (entry, s, len);
    *s += 0x10;
    return ret;
}

/*
 * return a fd to the cache file of `entry'
 */

int
fcache_open_file (FCacheEntry *entry, int flag, mode_t mode)
{
    char fname[MAXPATHLEN];

    fcache_file_name (entry, fname, sizeof(fname));
    return open (fname, flag | O_BINARY, mode);
}

/*
 * return a fd to the converted directory for `entry'
 */

int
fcache_open_extra_dir (FCacheEntry *entry, int flag, mode_t mode)
{
    char fname[MAXPATHLEN];

    assert (entry->flags.datap && entry->flags.extradirp &&
	    entry->status.FileType == TYPE_DIR);

    fcache_extra_file_name (entry, fname, sizeof(fname));
    return open (fname, flag | O_BINARY, mode);
d1302 4
d1310 1
d1329 116
d1447 4
a1450 1
 * `ret_conn' */
d1455 2
a1456 1
	      ConnCacheEntry **ret_conn)
d1458 1
a1458 1
    int ret;
d1466 11
a1476 5
    if (connected_mode == DISCONNECTED) {
	*ret_conn = NULL;
	if (entry->flags.attrp == TRUE)
	    return 0;
	return ENETDOWN;
d1478 1
a1479 10
    conn = findconn (entry, ce);

    if (conn == NULL)
	return ENETDOWN;

    ret = RXAFS_FetchStatus (conn->connection,
			     &entry->fid.fid,
			     &status,
			     &callback,
			     &volsync);
d1481 3
a1483 1
	if (ret == -1)
d1485 1
a1485 1
	conn_free(conn);
d1503 2
d1512 1
d1520 1
d1524 2
a1525 1
    ret = do_read_attr (entry, ce, &conn);
a1527 1
    conn_free (conn);
d1568 2
d1572 3
d1580 2
d1583 3
d1596 3
a1598 1
    fd = fcache_open_file (entry, O_RDWR | O_CREAT | O_TRUNC, 0666);
d1602 1
a1602 1
		   (unsigned)entry->inode);
d1607 6
a1612 2
    if (copyrx2fd (call, fd, sizefs)) {
	ret = errno;
d1614 1
a1614 1
	arla_warn (ADEBFCACHE, ret, "copyrx2fd");
d1617 2
d1625 2
d1640 2
d1650 2
a1651 1
write_data (FCacheEntry *entry, CredCacheEntry *ce)
d1656 1
a1659 1
     AFSStoreStatus storestatus;
d1663 1
d1667 1
a1667 6
     conn = findconn (entry, ce);

     if (conn == NULL)
	 return ENETDOWN;

     fd = fcache_open_file (entry, O_RDONLY, 0666);
d1671 2
a1672 2
		    (unsigned)entry->inode);
	 goto out;
d1676 8
a1683 4
	  ret = errno;
	  arla_warn (ADEBFCACHE, ret, "stat cache file %u",
		     (unsigned)entry->inode);
	  goto out;
d1688 3
a1690 1
     usedbytes = usedbytes - entry->status.Length + sizefs;
d1692 3
a1694 5
     call = rx_NewCall (conn->connection);
     if (call == NULL) {
	 arla_warnx (ADEBMISC, "rx_NewCall failed");
	 ret = ENOMEM;
	 goto out;
d1697 41
a1737 11
     storestatus.Mask = 0; /* Dont save anything */
     ret = StartRXAFS_StoreData (call, &entry->fid.fid,
				 &storestatus, 
				 0,
				 sizefs,
				 sizefs);
     if (ret) {
	 arla_warn (ADEBFCACHE, ret, "store-data");
	 rx_EndCall(call, 0);
	 goto out;
     }
d1739 5
a1743 5
     if (copyfd2rx (fd, call, sizefs)) {
	  ret = errno;
	  rx_EndCall(call, ret);
	  arla_warnx (ADEBFCACHE, "copyfd2rx");
	  goto out;
d1746 7
a1752 7
     ret = rx_EndCall (call, EndRXAFS_StoreData (call,
						 &status,
						 &callback,
						 &volsync));
     if (ret) {
	 arla_warn (ADEBFCACHE, ret, "rx_EndCall");
	 goto out;
d1754 3
a1756 8

     update_entry (entry, &status, &callback, &volsync,
		   rx_HostOf(rx_PeerOf(conn->connection)),
		   ce->cred);

out:
     close (fd);
     conn_free (conn);
d1771 1
a1771 1
    u_int32_t sizefs = sizeof(entry->status.Length);
d1776 2
d1781 1
a1781 6
    conn = findconn (entry, ce);

    if (conn == NULL)
	return ENETDOWN;

    fd = fcache_open_file (entry, O_RDWR | O_CREAT, 0);
d1785 2
a1786 2
		   (unsigned)entry->inode);
	goto out;
d1792 3
a1794 2
	close (fd);
	goto out;
d1797 5
a1801 1
    close (fd);
d1803 1
a1803 5
    if (entry->flags.datap) {
	assert (usedbytes >= entry->status.Length);
	usedbytes -= entry->status.Length;
    }
    usedbytes += size;
d1805 2
a1806 1
    entry->status.Length = size;
d1808 10
a1817 6
    call = rx_NewCall (conn->connection);
    if (call == NULL) {
	arla_warnx (ADEBMISC, "rx_NewCall failed");
	ret = ENOMEM;
	goto out;
    }
d1819 15
a1833 10
    storestatus.Mask = 0;
    ret = StartRXAFS_StoreData (call,
				&entry->fid.fid, 
				&storestatus,
				0, 0, entry->status.Length);
    if(ret) {
	arla_warn (ADEBFCACHE, ret, "store-data");
	rx_EndCall(call, 0);
	goto out;
    }
d1835 7
a1841 7
    sizefs = htonl (sizefs);
    if (rx_Write (call, &sizefs, sizeof(sizefs)) != sizeof(sizefs)) {
	ret = rx_Error(call);
	arla_warn (ADEBFCACHE, ret, "writing length");
	rx_EndCall(call, 0);
	goto out;
    }
d1843 9
a1851 6
    if (rx_Write (call, 0, 0) != 0) {
	ret = rx_Error(call);
	arla_warn (ADEBFCACHE, ret, "writing length");
	rx_EndCall(call, 0);
	goto out;
    }
d1853 5
a1857 7
    ret = rx_EndCall (call, EndRXAFS_StoreData (call,
						&status,
						&callback,
						&volsync));
    if (ret) {
	arla_warn (ADEBFCACHE, ret, "rx_EndCall");
	goto out;
d1860 5
a1864 3
    update_entry (entry, &status, &callback, &volsync,
		  rx_HostOf(rx_PeerOf(conn->connection)),
		  ce->cred);
d1866 6
a1871 2
out:
    conn_free(conn);
d1888 2
d1893 19
a1911 1
    conn = findconn (entry, ce);
d1913 2
a1914 10
    if (conn == NULL)
	return ENETDOWN;

    ret = RXAFS_StoreStatus (conn->connection,
			     &entry->fid.fid,
			     store_status,
			     &status,
			     &volsync);
    if (ret) {
	arla_warn (ADEBFCACHE, ret, "store-status");
d1917 2
a1918 4
    
    update_entry (entry, &status, NULL, &volsync,
		  rx_HostOf (rx_PeerOf (conn->connection)),
		  ce->cred);
d1921 1
a1921 1
    conn_free (conn);
d1936 1
a1936 1
    ConnCacheEntry *conn;
d1943 2
d1948 31
a1978 1
    conn = findconn (dir_entry, ce);
d1980 5
a1984 2
    if (conn == NULL)
	return ENETDOWN;
d1986 25
a2010 12
    ret = RXAFS_CreateFile (conn->connection,
			    &dir_entry->fid.fid,
			    name,
			    store_attr,
			    &OutFid,
			    fetch_attr,
			    &status,
			    &callback,
			    &volsync);
    if (ret) {
	arla_warn (ADEBFCACHE, ret, "CreateFile");
	goto out;
a2012 4
    update_entry (dir_entry, &status, &callback, &volsync,
		  rx_HostOf (rx_PeerOf (conn->connection)),
		  ce->cred);

d2023 1
a2023 2
		  rx_HostOf (rx_PeerOf (conn->connection)),
		  ce->cred);
d2028 1
a2028 1
    fd = fcache_open_file (child_entry, O_WRONLY | O_CREAT | O_TRUNC, 0666);
d2032 11
a2042 2
		   (unsigned)child_entry->inode);
	ReleaseWriteLock (&child_entry->lock);
d2045 2
a2046 1
    close (fd);
d2051 1
a2051 1
    ReleaseWriteLock (&child_entry->lock);
a2053 1
    conn_free (conn);
d2074 2
d2079 26
a2104 1
    conn = findconn (dir_entry, ce);
d2109 1
a2109 15
    ret = RXAFS_MakeDir (conn->connection,
			 &dir_entry->fid.fid,
			 name,
			 store_attr,
			 &OutFid,
			 fetch_attr,
			 &status,
			 &callback,
			 &volsync);

    if (ret) {
	arla_warn (ADEBFCACHE, ret, "MakeDir");
	goto out;
    }

d2111 1
a2111 2
		  rx_HostOf(rx_PeerOf(conn->connection)),
		  ce->cred);
d2123 1
a2123 2
		  rx_HostOf(rx_PeerOf(conn->connection)),
		  ce->cred);
d2131 1
a2131 1
	ReleaseWriteLock (&child_entry->lock);
d2140 1
a2140 1
    ReleaseWriteLock (&child_entry->lock);
a2142 1
    conn_free (conn);
d2163 2
d2168 25
a2192 1
    conn = findconn (dir_entry, ce);
d2197 1
a2197 16
    ret = RXAFS_Symlink (conn->connection,
			 &dir_entry->fid.fid,
			 name,
			 contents,
			 store_attr,
			 &OutFid,
			 fetch_attr,
			 &new_status,
			 &volsync);
    if (ret) {
	arla_warn (ADEBFCACHE, ret, "Symlink");
	goto out;
    }

    usedbytes = usedbytes - dir_entry->status.Length + new_status.Length;

d2199 1
a2199 2
		  rx_HostOf(rx_PeerOf(conn->connection)),
		  ce->cred);
d2211 2
a2212 2
		  rx_HostOf(rx_PeerOf(conn->connection)),
		  ce->cred);
d2218 1
a2218 1
    ReleaseWriteLock (&child_entry->lock);
a2220 1
    conn_free (conn);
d2239 2
d2244 23
a2266 1
    conn = findconn (dir_entry, ce);
d2271 1
a2271 13
    ret = RXAFS_Link (conn->connection,
		      &dir_entry->fid.fid,
		      name,
		      &existing_entry->fid.fid,
		      &new_status,
		      &status,
		      &volsync);
    if (ret) {
	arla_warn (ADEBFCACHE, ret, "Link");
	goto out;
    }

    usedbytes = usedbytes - dir_entry->status.Length + status.Length;
d2274 1
a2274 2
		  rx_HostOf(rx_PeerOf(conn->connection)),
		  ce->cred);
d2277 1
a2277 2
		  rx_HostOf(rx_PeerOf(conn->connection)),
		  ce->cred);
a2279 1
    conn_free (conn);
d2294 2
d2299 21
a2319 1
    conn = findconn (dir_entry, ce);
d2324 1
a2324 11
    ret = RXAFS_RemoveFile (conn->connection,
			    &dir_entry->fid.fid,
			    name,
			    &status,
			    &volsync);
    if (ret) {
	arla_warn (ADEBFCACHE, ret, "RemoveFile");
	goto out;
    }

    usedbytes = usedbytes - dir_entry->status.Length + status.Length;
d2327 1
a2327 2
		  rx_HostOf(rx_PeerOf(conn->connection)),
		  ce->cred);
a2329 1
    conn_free (conn);
d2334 1
a2334 1
 * Remove a file from a directory.
d2346 2
d2351 21
a2371 1
    conn = findconn (dir_entry, ce);
d2376 1
a2376 11
    ret = RXAFS_RemoveDir (conn->connection,
			   &dir_entry->fid.fid,
			   name,
			   &status,
			   &volsync);
    if (ret) {
	arla_warn (ADEBFCACHE, ret, "RemoveDir");
	goto out;
    }

    usedbytes = usedbytes - dir_entry->status.Length + status.Length;
d2379 1
a2379 2
		  rx_HostOf(rx_PeerOf(conn->connection)),
		  ce->cred);
a2381 1
    conn_free (conn);
d2400 2
d2406 24
a2429 1
    conn = findconn (old_dir, ce);
d2434 2
a2435 17
    ret = RXAFS_Rename (conn->connection,
			&old_dir->fid.fid,
			old_name,
			&new_dir->fid.fid,
			new_name,
			&orig_status,
			&new_status,
			&volsync);

    if (ret) {
	arla_warn (ADEBFCACHE, ret, "Rename");
	goto out;
    }

    usedbytes = usedbytes - old_dir->status.Length + orig_status.Length;

    usedbytes = usedbytes - new_dir->status.Length + new_status.Length;
d2438 1
a2438 2
		  rx_HostOf(rx_PeerOf(conn->connection)),
		  ce->cred);
d2441 1
a2441 2
		  rx_HostOf(rx_PeerOf(conn->connection)),
		  ce->cred);
a2443 1
    conn_free (conn);
d2457 2
d2460 2
a2461 2
     ve = volcache_getbyname (root_volume, 0, ce);
     if (ve == NULL) {
d2463 1
a2463 1
	 return ENODEV;
d2524 1
d2526 2
a2527 1
    VolCacheEntry *vol;
d2529 4
a2532 4
    e = find_entry (fid);
    if (e) {
	assert (e->flags.usedp);
	*res = e;
d2536 10
a2545 3
    if (connected_mode == DISCONNECTED) {
	*res = NULL;
	return ENETDOWN;
d2548 4
a2551 8
    vol = volcache_getbyid (fid.fid.Volume, fid.Cell, ce);
    if (vol == NULL)
	return ENODEV;

    e = find_free_entry ();
    e->fid = fid;
    if (e->inode == 0)
	e->inode = nextinode ();
d2562 1
d2565 1
a2565 1
    e->volume          = vol;
d2570 13
d2588 19
d2617 1
a2617 1
	connected_mode != CONNECTEDLOG)
d2633 1
d2651 21
d2679 1
a2679 1
    ConnCacheEntry *conn;
d2681 1
d2690 2
a2691 5
	else {
	    conn = findconn (e, ce);
	    if (conn == NULL)
		return ENETDOWN;
	}
d2693 3
a2695 2
	ret = do_read_attr (e, ce, &conn);
	if (ret)
d2697 1
d2699 1
a2699 1
	    conn_free (conn);
d2704 1
a2704 1
    conn_free (conn);
d2709 171
d2883 8
a2898 2
     long cell;
     long type;
a2899 1
     VenusFid oldfid = *fid;
d2902 7
d2916 1
a2916 1
	 ReleaseWriteLock (&e->lock);
d2920 3
a2922 2
     if (e->status.FileType != TYPE_LINK) {
	 ReleaseWriteLock (&e->lock);
d2928 1
a2928 1
	 ReleaseWriteLock (&e->lock);
d2931 6
d2938 1
a2938 1
     fd = fcache_open_file (e, O_RDONLY, 0);
d2940 1
a2940 1
	 ReleaseWriteLock (&e->lock);
a2943 1
     length = e->status.Length;
d2946 3
a2948 2
	 close (fd);
	 ReleaseWriteLock (&e->lock);
d2952 4
a2955 95
     switch (*buf) {
     case '#' :
     case '%' : {
	 int founderr;
	 char *dot;

	 dot = buf + e->status.Length - 1;
	 *dot = '\0';
	 dot = strchr (buf, ':');
	 if (dot) {
	     *dot++ = '\0';
	     cell   = cell_name2num (buf + 1);
	 } else {
	     cell = fid->Cell;
	     dot  = buf + 1;
	 }
	 if (*buf == '%')
	     type = RWVOL;
	 else
	     type = gettype (fid->fid.Volume, e->volume);

	 founderr = 0;

	 /*
	  * If this is a cross-cell mountpoint we need new credentials.
	  */

	 if ((*ce)->cell != cell) {
	     CredCacheEntry *new_ce;

	     new_ce = cred_get (cell, (*ce)->cred, (*ce)->type);
	     if (new_ce == NULL) {
		 new_ce = cred_get(cell, (*ce)->cred, CRED_ANY);
	     }
	     if (new_ce == NULL) {
		 ReleaseWriteLock (&e->lock);
		 return ENOMEM;
	     }
	     cred_free (*ce);
	     *ce = new_ce;
	 }

	 /* is the cell is invalid the rest should be bougs too */
	 if (cell== -1)
	     founderr = -1;  
	 else {
	     VolCacheEntry *ve;

	     ve = volcache_getbyname (dot, cell, *ce);
	     if (ve == NULL)
		 founderr = -1;
	     else {
		 switch (type) {
		 case ROVOL :
		     if (ve->entry.flags & VLF_ROEXISTS) {
			 fid->fid.Volume = ve->entry.volumeId[ROVOL];
			 break;
		     }
		     /* fall through */
		 case RWVOL :
		     if (ve->entry.flags & VLF_RWEXISTS)
			 fid->fid.Volume = ve->entry.volumeId[RWVOL];
		     else
			 founderr = -1;
		     break;
		 case BACKVOL :
		     if (ve->entry.flags & VLF_BOEXISTS)
			 fid->fid.Volume = ve->entry.volumeId[BACKVOL];
		     else
			 founderr = -1;
		     break;
		 default :
		     abort ();
		 }
		 volcache_free (ve);
	     }
	 }
	 if (founderr) {
	     res = ENODEV;
	     break;
	 }
	 fid->Cell = cell;
	 fid->fid.Vnode = fid->fid.Unique = 1;

	 ReleaseWriteLock (&e->lock);
	 res = fcache_get (&e, *fid, *ce);
	 if (res)
	     break;
	 ++e->refcount;
	 e->flags.mountp = TRUE;
	 e->realfid = oldfid;
	 e->parent = *parent;
     }
     }
     ReleaseWriteLock (&e->lock);
a2967 1
    FILE *f = (FILE *)arg;
d2969 1
a2969 1
    fprintf (f, "(%d, %u, %u, %u)\n",
d2971 11
a2981 1
	     e->fid.fid.Volume, e->fid.fid.Vnode, e->fid.fid.Unique);
d2991 1
a2991 1
fcache_status (FILE *f)
d2993 1
a2993 1
    fprintf (f, "%lu (%lu-%lu) files\n"
d2997 35
a3031 1
    hashtabforeach (hashtab, print_entry, f);
d3048 1
d3056 14
a3069 1
    conn = findconn (dire, ce);
d3071 1
a3071 1
	return ENETDOWN;
d3073 1
a3073 5
    ret = RXAFS_FetchACL (conn->connection, &fid.fid,
			  opaque, &status, &volsync);
    conn_free (conn);
    throw_entry (dire);
    
d3091 1
d3099 14
a3112 1
    conn = findconn (dire, ce);
d3114 1
a3114 1
      return ENETDOWN;
d3116 6
a3121 6
    ret = RXAFS_StoreACL (conn->connection, &fid.fid,
			    opaque, &status, &volsync);
    
    conn_free (conn);
    throw_entry (dire);
    
d3139 1
d3147 15
a3161 1
    conn = findconn (dire, ce);
d3163 1
a3163 1
      return ENETDOWN;
d3165 1
a3165 6
    ret = RXAFS_GetVolumeStatus (conn->connection, fid.fid.Volume,
				 volstat, volumename, offlinemsg,
				 motd);
    conn_free (conn);
    throw_entry (dire);
    
d3183 1
d3191 15
a3205 1
    conn = findconn (dire, ce);
d3207 1
a3207 1
      return ENETDOWN;
d3209 1
a3209 6
    ret = RXAFS_SetVolumeStatus (conn->connection, fid.fid.Volume,
				 volstat, volumename, offlinemsg,
				 motd);
    conn_free (conn);
    throw_entry (dire);
    
@


1.1.1.1
log
@Initial version of Arla, a free implementation of an AFS cache-manager.
(second try, hopefully into the correct repository this time)
@
text
@@


1.1.1.2
log
@Import of arla-0.35.7
@
text
@d1 1
d3 1
a3 1
 * Copyright (c) 1995 - 2001 Kungliga Tekniska Högskolan
d18 6
a23 1
 * 3. Neither the name of the Institute nor the names of its contributors
d46 1
a46 14
RCSID("$KTH: fcache.c,v 1.311.2.20 2001/12/20 16:36:24 mattiasa Exp $") ;

/*
 * Prototypes
 */

static int get_attr_bulk (FCacheEntry *parent_entry, 
			  FCacheEntry *prefered_entry,
			  VenusFid *prefered_fid,
			  const char *prefered_name,
			  CredCacheEntry *ce);

static int
resolve_mp (FCacheEntry *e, VenusFid *ret_fid, CredCacheEntry **ce);
d68 1
a68 1
 * Heap of entries to be invalidated.
d71 1
a71 1
static Heap *invalid_heap;
d75 1
a75 1
static u_long lowvnodes, highvnodes, current_vnodes, lowbytes, highbytes;
d79 1
a79 1
static u_long usedbytes, usedvnodes, needbytes;
d88 1
a88 3
Bool fprioritylevel;

static int node_count;		/* XXX */
d90 1
a90 4
/*
 * This is set to non-zero when we want to use bulkstatus().  2 means
 * that the nodes should be installed into the kernel.
 */
d92 1
a92 2
static int fcache_enable_bulkstatus = 1;
static int fcache_bulkstatus_num = 14; /* XXX should use the [P]MTU */
d122 1
a122 1
 * Smalltalk emulation
d125 2
a126 2
u_long
fcache_highbytes(void)
d128 2
a129 2
    return highbytes;
}
d131 4
a134 4
u_long
fcache_usedbytes(void)
{
    return usedbytes;
d137 3
a139 5
u_long
fcache_lowbytes(void)
{
    return lowbytes;
}
d141 2
a142 2
u_long
fcache_highvnodes(void)
d144 1
a144 2
    return highvnodes;
}
d146 2
a147 4
u_long
fcache_usedvnodes(void)
{
    return usedvnodes;
d150 3
a152 5
u_long
fcache_lowvnodes(void)
{
    return lowvnodes;
}
d154 1
a154 2
#define HISTOGRAM_SLOTS 32
#define STATHASHSIZE 997
d156 3
a158 4
/* Struct with collected statistics */
struct collect_stat{
    int64_t starttime;
};
d160 2
a161 12
struct time_statistics {
    u_int32_t measure_type;
    u_int32_t host;
    u_int32_t partition;
    u_int32_t measure_items; /* normed by get_histgram_slots */
    u_int32_t count[HISTOGRAM_SLOTS];    
    int64_t measure_items_total[HISTOGRAM_SLOTS];
    int64_t elapsed_time[HISTOGRAM_SLOTS];
};

static unsigned
statistics_hash (void *p)
d163 2
a164 1
    struct time_statistics *stats = (struct time_statistics*)p;
d166 16
a181 2
    return stats->measure_type + stats->host +
	stats->partition * 32 * 32 + stats->measure_items * 32;
d184 1
d186 1
a186 1
 * Compare two entries. Return 0 if and only if the same.
d189 2
a190 2
static int
statistics_cmp (void *a, void *b)
d192 1
a192 2
    struct time_statistics *f1 = (struct time_statistics*)a;
    struct time_statistics *f2 = (struct time_statistics*)b;
d194 2
a195 5
    return f1->measure_type  != f2->measure_type
	|| f1->host          != f2->host
	|| f1->partition     != f2->partition
	|| f1->measure_items != f2->measure_items;
}
d197 8
a204 1
static Hashtab *statistics;
d206 2
a207 8
static int
get_histogram_slot(u_int32_t value)
{
    int i;

    for (i = HISTOGRAM_SLOTS - 1; i > 0; i--) {
	if (value >> i)
	    return i;
d209 4
a212 1
    return 0;
d215 3
a217 34
static void
add_time_statistics(u_int32_t measure_type, u_int32_t host,
		    u_int32_t partition, u_int32_t measure_items,
		    int64_t elapsed_time)
{
    u_int32_t time_slot;
    struct time_statistics *ts;
    struct time_statistics *ts2;

    ts = malloc(sizeof(*ts));

    time_slot = get_histogram_slot(elapsed_time);
    ts->measure_type = measure_type;
    ts->measure_items = get_histogram_slot(measure_items);
    ts->host = host;
    ts->partition = partition;
    ts2 = hashtabsearch (statistics, (void*)(ts));
    if (ts2) {
	ts2->count[time_slot]++;
	ts2->elapsed_time[time_slot] += elapsed_time;
	ts2->measure_items_total[time_slot] += measure_items;
	free(ts);
    } else {
	memset(ts->count, 0, sizeof(ts->count));
	memset(ts->measure_items_total, 0, sizeof(ts->measure_items_total));
	memset(ts->elapsed_time, 0, sizeof(ts->elapsed_time));
	ts->count[time_slot]++;
	ts->elapsed_time[time_slot] += elapsed_time;
	ts->measure_items_total[time_slot] += measure_items;
	hashtabadd(statistics, ts);
    }

    time_slot = get_histogram_slot(elapsed_time);
}
d220 1
a220 1
collectstats_init (void)
d222 5
a226 1
    statistics = hashtabnew (STATHASHSIZE, statistics_cmp, statistics_hash);
d228 2
a229 3
    if (statistics == NULL)
	arla_err(1, ADEBINIT, errno, "collectstats_init: cannot malloc");
}
d231 1
a231 4
static void
collectstats_start (struct collect_stat *p)
{
    struct timeval starttime;
d233 2
a234 3
    gettimeofday(&starttime, NULL);
    p->starttime = starttime.tv_sec * 1000000LL + starttime.tv_usec;
}
d236 4
a239 13
static void
collectstats_stop (struct collect_stat *p,
		   FCacheEntry *entry,
		   ConnCacheEntry *conn,
		   int measure_type, int measure_items)
{
    u_int32_t host = conn->host;
    long partition = -1;
    int volumetype;
    struct nvldbentry vldbentry;
    struct timeval stoptime;
    int64_t elapsed_time;
    int i;
d241 7
a247 1
    gettimeofday(&stoptime, NULL);
d249 7
a255 8
    volumetype = volcache_volid2bit (entry->volume, entry->fid.fid.Volume);
    vldbentry = entry->volume->entry;

    for (i = 0; i < min(NMAXNSERVERS, vldbentry.nServers); ++i) {
	if (host == htonl(vldbentry.serverNumber[i]) &&
	    vldbentry.serverFlags[i] & volumetype) {
	    partition = vldbentry.serverPartition[i];
	}
d257 6
a262 5
    assert(partition != -1);
    elapsed_time = stoptime.tv_sec * 1000000LL + stoptime.tv_usec;
    elapsed_time -= p->starttime;
    add_time_statistics(measure_type, host, partition,
			measure_items, elapsed_time);
d265 3
a267 4
struct hostpart {
    u_int32_t host;
    u_int32_t part;
};
d269 2
a270 2
static unsigned
hostpart_hash (void *p)
d272 1
a272 3
    struct hostpart *h = (struct hostpart*)p;

    return h->host * 256 + h->part;
d275 3
a277 5
static int
hostpart_cmp (void *a, void *b)
{
    struct hostpart *h1 = (struct hostpart*)a;
    struct hostpart *h2 = (struct hostpart*)b;
d279 2
a280 6
    return h1->host != h2->host ||
	h1->part != h2->part;
}

static Bool
hostpart_addhash (void *ptr, void *arg)
d282 4
a285 11
    Hashtab *hostparthash = (Hashtab *) arg;
    struct time_statistics *s = (struct time_statistics *) ptr;
    struct hostpart *h;
    
    h = malloc(sizeof(*h));
    h->host = s->host;
    h->part = s->partition;

    hashtabadd(hostparthash, h);
    return FALSE;
}
d287 2
a288 6
struct hostpart_collect_args {
    u_int32_t *host;
    u_int32_t *part;
    int *i;
    int max;
};
d290 3
a292 6
static Bool
hostpart_collect (void *ptr, void *arg)
{
    struct hostpart_collect_args *collect_args =
	(struct hostpart_collect_args *) arg;
    struct hostpart *h = (struct hostpart *) ptr;
d294 6
a299 2
    if (*collect_args->i >= collect_args->max)
	return TRUE;
d301 11
a311 3
    collect_args->host[*collect_args->i] = h->host;
    collect_args->part[*collect_args->i] = h->part;
    (*collect_args->i)++;
d313 2
a314 1
    return FALSE;
d317 6
a322 2
int
collectstats_hostpart(u_int32_t *host, u_int32_t *part, int *n)
d324 4
a327 3
    Hashtab *hostparthash;
    int i;
    struct hostpart_collect_args collect_args;
d329 34
a362 1
    hostparthash = hashtabnew (100, hostpart_cmp, hostpart_hash);
d364 16
a379 1
    hashtabforeach(statistics, hostpart_addhash, hostparthash);
d381 6
a386 7
    i = 0;
    collect_args.host = host;
    collect_args.part = part;
    collect_args.i = &i;
    collect_args.max = *n;
    hashtabforeach(hostparthash, hostpart_collect, &collect_args);
    *n = i;
d388 1
a388 26
    hashtabrelease(hostparthash);

    return 0;
}

int
collectstats_getentry(u_int32_t host, u_int32_t part, u_int32_t type,
		      u_int32_t items_slot, u_int32_t *count,
		      int64_t *items_total, int64_t *total_time)
{
    struct time_statistics ts;
    struct time_statistics *ts2;

    ts.measure_type = type;
    ts.measure_items = items_slot;
    ts.host = host;
    ts.partition = part;
    ts2 = hashtabsearch (statistics, (void*)(&ts));
    if (ts2 == NULL) {
	memset(count, 0, 4 * 32);
	memset(items_total, 0, 8 * 32);
	memset(total_time, 0, 8 * 32);
    } else {
	memcpy(count, ts2->count, 4 * 32);
	memcpy(items_total, ts2->measure_items_total, 8 * 32);
	memcpy(total_time, ts2->elapsed_time, 8 * 32);
a389 2

    return 0;
d393 1
a393 1
 * Counters
d396 9
a404 9
static struct {
    unsigned long fetch_attr;
    unsigned long fetch_attr_cached;
    unsigned long fetch_attr_bulk;
    unsigned long fetch_data;
    unsigned long fetch_data_cached;
    unsigned long store_attr;
    unsigned long store_data;
} fcache_counter;
d406 6
a411 3
/*
 * Compare two entries. Return 0 if and only if the same.
 */
d413 1
a413 5
static int
fcachecmp (void *a, void *b)
{
     FCacheEntry *f1 = (FCacheEntry*)a;
     FCacheEntry *f2 = (FCacheEntry*)b;
d415 14
a428 4
     return f1->fid.Cell != f2->fid.Cell 
	 || f1->fid.fid.Volume != f2->fid.fid.Volume 
	 || f1->fid.fid.Vnode  != f2->fid.fid.Vnode
	 || f1->fid.fid.Unique != f2->fid.fid.Unique;
d432 1
a432 1
 * Hash the value of an entry.
d435 2
a436 2
static unsigned
fcachehash (void *e)
d438 11
a448 1
     FCacheEntry *f = (FCacheEntry*)e;
d450 9
a458 2
     return f->fid.Cell + f->fid.fid.Volume + f->fid.fid.Vnode 
	  + f->fid.fid.Unique;
d462 2
a463 1
 * Compare expiration times.
d466 2
a467 2
static int
expiration_time_cmp (const void *a, const void *b)
d469 35
a503 2
    const FCacheEntry *f1 = (const FCacheEntry *)a;
    const FCacheEntry *f2 = (const FCacheEntry *)b;
d505 18
a522 2
    return f1->callback.ExpirationTime - f2->callback.ExpirationTime;
}
d524 1
a524 10
void
recon_hashtabadd(FCacheEntry *entry)
{
    hashtabadd(hashtab,entry);
}
 
void
recon_hashtabdel(FCacheEntry *entry)
{
   hashtabdel(hashtab,entry);
d528 1
a528 1
 * Globalnames 
d531 6
a536 411
char arlasysname[SYSNAMEMAXLEN];

/*
 * return the directory name of the cached file for `entry'
 */

int
fcache_dir_name (FCacheEntry *entry, char *s, size_t len)
{
    return snprintf (s, len, "%02X", entry->index / 0x100);
}

/*
 * return the file name of the cached file for `entry'.
 */

int
fcache_file_name (FCacheEntry *entry, char *s, size_t len)
{
    return snprintf (s, len, "%02X/%02X",
		     entry->index / 0x100, entry->index % 0x100);
}

/*
 * the filename for the extra (converted) directory
 */

static int
real_extra_file_name (FCacheEntry *entry, char *s, size_t len)
{
    int ret;

    ret = fcache_file_name (entry, s, len - 1);
    if (ret < len - 1) {
	s[ret++] = '@@';
	s[ret]   = '\0';
    }
    return ret;
}

/*
 * return the file name of the converted directory for `entry'.
 */

int
fcache_extra_file_name (FCacheEntry *entry, char *s, size_t len)
{
    assert (entry->flags.datap &&
	    entry->flags.extradirp &&
	    entry->status.FileType == TYPE_DIR);

    return real_extra_file_name (entry, s, len);
}

static int fhopen_working;

/*
 * open file by handle
 */

static int
fcache_fhopen (fcache_cache_handle *handle, int flags)
{
    if (!handle->valid) {
	errno = EINVAL;
	return -1;
    }

#if defined(HAVE_GETFH) && defined(HAVE_FHOPEN)
    {
	int ret;
	fhandle_t fh;

	memcpy (&fh, &handle->xfs_handle, sizeof(fh));
	ret = fhopen (&fh, flags);
	if (ret >= 0)
	    return ret;
    }
#endif

#ifdef KERBEROS			/* really KAFS */
    {
	struct ViceIoctl vice_ioctl;
	
	vice_ioctl.in      = (caddr_t)&handle->xfs_handle;
	vice_ioctl.in_size = sizeof(handle->xfs_handle);
	
	vice_ioctl.out      = NULL;
	vice_ioctl.out_size = 0;
	
	return k_pioctl (NULL, VIOC_FHOPEN, &vice_ioctl, flags);
    }
#else
    errno = EINVAL;
    return -1;
#endif
}

/*
 * get the handle of `filename'
 */

int
fcache_fhget (char *filename, fcache_cache_handle *handle)
{
    handle->valid = 0;
#if defined(HAVE_GETFH) && defined(HAVE_FHOPEN)
    {
	int ret;
	fhandle_t fh;

	ret = getfh (filename, &fh);
	if (ret == 0) {
	    memcpy (&handle->xfs_handle, &fh, sizeof(fh));
	    handle->valid = 1;
	}

	return ret;
    }
#endif
#ifdef KERBEROS
    {
	struct ViceIoctl vice_ioctl;
	int ret;
	
	if (!fhopen_working)
	    return 0;
	
	vice_ioctl.in      = NULL;
	vice_ioctl.in_size = 0;
	
	vice_ioctl.out      = (caddr_t)&handle->xfs_handle;
	vice_ioctl.out_size = sizeof(handle->xfs_handle);
	
	ret = k_pioctl (filename, VIOC_FHGET, &vice_ioctl, 0);
	if (ret == 0)
	    handle->valid = 1;

	return ret;
    }
#else
    errno = EINVAL;
    return -1;
#endif
}

/*
 * create a new cache vnode, assume the entry is locked or private
 */

int
fcache_create_file (FCacheEntry *entry)
{
    char fname[MAXPATHLEN];
    char extra_fname[MAXPATHLEN];
    int fd;
    int ret;

    fcache_file_name (entry, fname, sizeof(fname));
    fd = open (fname, O_RDWR | O_CREAT | O_TRUNC | O_BINARY, 0666);
    if (fd < 0) {
	if (errno == ENOENT) {
	    char dname[MAXPATHLEN];

	    fcache_dir_name (entry, dname, sizeof(dname));
	    ret = mkdir (dname, 0777);
	    if (ret < 0)
		arla_err (1, ADEBERROR, errno, "mkdir %s", dname);
	    fd = open (fname, O_RDWR | O_CREAT | O_TRUNC | O_BINARY, 0666);
	    if (fd < 0)
		arla_err (1, ADEBERROR, errno, "open %s", fname);
	} else {
	    arla_err (1, ADEBERROR, errno, "open %s", fname);
	}
    }
    if (close (fd) < 0)
	arla_err (1, ADEBERROR, errno, "close %s", fname);
    fcache_fhget (fname, &entry->handle);
    real_extra_file_name (entry, extra_fname, sizeof(extra_fname));
    unlink (extra_fname);
    return 0;
}

/*
 * return a fd to the cache file of `entry'
 */

int
fcache_open_file (FCacheEntry *entry, int flag)
{
    int ret;
    char fname[MAXPATHLEN];

    if (fhopen_working) {
	ret = fcache_fhopen (&entry->handle, flag);
	if (ret < 0 && errno == EINVAL)
	    fhopen_working = 0;
	else
	    return ret;
    }
    fcache_file_name (entry, fname, sizeof(fname));
    return open (fname, flag | O_BINARY);
}

/*
 * return a fd to the converted directory for `entry'
 */

int
fcache_open_extra_dir (FCacheEntry *entry, int flag, mode_t mode)
{
    char fname[MAXPATHLEN];

    assert (entry->flags.datap && entry->flags.extradirp &&
	    entry->status.FileType == TYPE_DIR);

    fcache_extra_file_name (entry, fname, sizeof(fname));
    return open (fname, flag | O_BINARY, mode);
}

/*
 * Discard the data cached for `entry'.
 */

static void
throw_data (FCacheEntry *entry)
{
    int fd;
    struct stat sb;

    assert (entry->flags.datap && entry->flags.usedp);
    AssertExclLocked(&entry->lock);

    fd = fcache_open_file (entry, O_WRONLY);
    if (fd < 0) {
	arla_warn (ADEBFCACHE, errno, "fcache_open_file");
	goto out;
    }
    if (fstat (fd, &sb) < 0) {
	arla_warn (ADEBFCACHE, errno, "fstat");
	close (fd);
	goto out;
    }
    if (ftruncate (fd, 0) < 0) {
	arla_warn (ADEBFCACHE, errno, "ftruncate");
	close (fd);
	goto out;
    }
    close (fd);
    if (entry->flags.extradirp) {
	char fname[MAXPATHLEN];

	fcache_extra_file_name (entry, fname, sizeof(fname));
	unlink (fname);
    }
    assert(usedbytes >= entry->length);
    /* XXX - things are wrong - continue anyway */
    if (usedbytes < entry->length)
	usedbytes  = entry->length;
    usedbytes -= entry->length;
    entry->length = 0;
    entry->flags.datap = FALSE;
    entry->flags.extradirp = FALSE;

 out:
    cm_check_consistency();
}

/*
 * A probe function for a file server.
 */

static int
fs_probe (struct rx_connection *conn)
{
    u_int32_t sec, usec;

    return RXAFS_GetTime (conn, &sec, &usec);
}

/*
 *
 */

static void
throw_entry (FCacheEntry *entry)
{
    CredCacheEntry *ce;
    ConnCacheEntry *conn;
    AFSCBFids fids;
    AFSCBs cbs;
    int ret;

    assert (entry->flags.usedp);
    AssertExclLocked(&entry->lock);

    hashtabdel (hashtab, entry);

    if (entry->flags.datap)
	throw_data (entry);

    if (entry->invalid_ptr != -1) {
	heap_remove (invalid_heap, entry->invalid_ptr);
	entry->invalid_ptr = -1;
    }

    if (entry->flags.attrp && entry->host) {
	ce = cred_get (entry->fid.Cell, 0, CRED_NONE);
	assert (ce != NULL);
	
	conn = conn_get (entry->fid.Cell, entry->host, afsport,
			 FS_SERVICE_ID, fs_probe, ce);
	cred_free (ce);
	
	if (conn != NULL) {
	    fids.len = cbs.len = 1;
	    fids.val = &entry->fid.fid;
	    cbs.val  = &entry->callback;
	    ret = RXAFS_GiveUpCallBacks (conn->connection, &fids, &cbs);
	    conn_free (conn);
	    if (ret)
		arla_warn (ADEBFCACHE, ret, "RXAFS_GiveUpCallBacks");
	}
    }
    if (entry->volume) {
	volcache_free (entry->volume);
	entry->volume = NULL;
    }
    entry->flags.attrp = FALSE;
    entry->flags.usedp = FALSE;
    --usedvnodes;
    LWP_NoYieldSignal (lrulist);
}

/*
 * Return the next cache node number.
 */

static unsigned
next_cache_index (void)
{
     return node_count++;
}

/*
 * Pre-create cache nodes up to the limit highvnodes.  If you want to
 * create more increase highnodes and signal create_nodes.
 */

static void
create_nodes (char *arg)
{
    FCacheEntry *entries;
    unsigned count = 0;
    struct timeval tv;

    while (1) {
       	unsigned int n, i, j;

	while (highvnodes <= current_vnodes)
	    LWP_WaitProcess (create_nodes);

	n = highvnodes - current_vnodes;

	count = 0;
	
	arla_warnx (ADEBFCACHE,
		    "pre-creating nodes");
	
	entries = calloc (n, sizeof(FCacheEntry));
	if (n != 0 && entries == NULL)
	    arla_errx (1, ADEBERROR, "fcache: calloc failed");
	
	for (i = 0; i < n; ++i) {
	    entries[i].invalid_ptr = -1;
	    entries[i].volume      = NULL;
	    entries[i].refcount    = 0;
	    entries[i].anonaccess  = 0;
	    entries[i].cleanergen  = 0;
	    for (j = 0; j < NACCESS; j++) {
		entries[i].acccache[j].cred = ARLA_NO_AUTH_CRED;
		entries[i].acccache[j].access = 0;
	    }
	    entries[i].length      = 0;
	    Lock_Init(&entries[i].lock);
	    entries[i].index = next_cache_index ();
	    fcache_create_file (&entries[i]);

	    current_vnodes++;

	    ++count;
	    tv.tv_sec = 0;
	    tv.tv_usec = 1000;

	    entries[i].lru_le      = listaddhead (lrulist, &entries[i]);
	    assert (entries[i].lru_le);

	    LWP_NoYieldSignal (lrulist);
	    IOMGR_Select(0, NULL, NULL, NULL, &tv);
	}

	arla_warnx (ADEBFCACHE,
		    "pre-created %u nodes", count);
    }
}

/*
 * This is the almighty cleaner loop
 */

static Bool cleaner_working = FALSE;
d538 1
a538 248
static void
cleaner (char *arg)
{
    enum { CL_OPPORTUNISTIC, CL_FORCE, CL_COLLECT } state;
    int cnt = 0, numnodes;
    VenusFid *fids;
    int cleanerrun = 0;
    
    numnodes = 50;
    
    fids = malloc (sizeof(*fids) * numnodes);
    if (fids == NULL)
	arla_err (1, ADEBERROR, errno, "cleaner: malloc");
    
    for (;;) {
	Listitem *item, *prev;
	FCacheEntry *entry;
	
	arla_warnx (ADEBCLEANER,
		    "running cleaner: "
		    "%lu (%lu-(%lu)-%lu) files, "
		    "%lu (%lu-%lu) bytes "
		    "%lu needed bytes",
		    usedvnodes, lowvnodes, current_vnodes, highvnodes,
		    usedbytes, lowbytes, highbytes,
		    needbytes);
	
	cleaner_working = TRUE;

	state = CL_OPPORTUNISTIC;
	cleanerrun++;

	while (usedvnodes > lowvnodes 
	       || usedbytes > lowbytes
	       || needbytes > highbytes - usedbytes)
	{
	    
	    for (item = listtail (lrulist);
		 item &&
		     (usedvnodes > lowvnodes
		      || usedbytes > lowbytes
		      || needbytes > highbytes - usedbytes);
		 item = prev) {
		prev = listprev (lrulist, item);
		entry = (FCacheEntry *)listdata (item);
		
		if (fprioritylevel && entry->priority)
		    continue;
		
		if (entry->flags.usedp
		    && (usedvnodes > lowvnodes 
			|| usedbytes > lowbytes 
			|| (needbytes > highbytes - usedbytes
			    && !entry->flags.attrusedp))
		    && entry->refcount == 0
		    && CheckLock(&entry->lock) == 0) 
		{
		    if (!entry->flags.datausedp
			&& CheckLock(&entry->lock) == 0
			/* && this_is_a_good_node_to_gc(entry,state) */) {
			ObtainWriteLock (&entry->lock);
			listdel (lrulist, item);
			throw_entry (entry);
			entry->lru_le = listaddtail (lrulist, entry);
			assert(entry->lru_le);
			ReleaseWriteLock (&entry->lock);
			break;
		    }

		    if (state == CL_FORCE) {
			if (entry->cleanergen == cleanerrun)
			    continue;
			entry->cleanergen = cleanerrun;
			
			fids[cnt++] = entry->fid;
			
			if (cnt >= numnodes) {
			    xfs_send_message_gc_nodes (kernel_fd, cnt, fids);
			    IOMGR_Poll();
			    cnt = 0;
			}
			break;
		    }
		}
		assert (entry->lru_le == item);
	    }
	    if (item == NULL) {
		switch (state) {
		case CL_OPPORTUNISTIC:
		    state = CL_FORCE;
		    LWP_DispatchProcess(); /* Yield */
		    break;
		case CL_FORCE:
		    state = CL_COLLECT;		    
		    if (cnt > 0) {
			xfs_send_message_gc_nodes (kernel_fd, cnt, fids);
			IOMGR_Poll();
			cnt = 0;
		    }
		    break;
		case CL_COLLECT:
		    if (needbytes > highbytes - usedbytes) {
			int cleaner_again = 0;
			if (!cleaner_again)
			    goto out;
			state = CL_OPPORTUNISTIC;
		    } else {
			goto out;
		    }
		    break;
		default:
		    abort();
		}
	    }
	}
    out:
	
	arla_warnx(ADEBCLEANER,
		   "cleaner done: "
		   "%lu (%lu-(%lu)-%lu) files, "
		   "%lu (%lu-%lu) bytes "
		   "%lu needed bytes",
		   usedvnodes, lowvnodes, current_vnodes, highvnodes,
		   usedbytes, lowbytes, highbytes,
		   needbytes);
	
	cm_check_consistency();
	if (needbytes)
	    LWP_NoYieldSignal (fcache_need_bytes);
	cleaner_working = FALSE;
	IOMGR_Sleep (CLEANER_SLEEP);
    }
}

static void
fcache_wakeup_cleaner (void *wait)
{
    if (cleaner_working == FALSE)
	IOMGR_Cancel (cleaner_pid);
    LWP_WaitProcess (wait);
}

int
fcache_need_bytes (u_long needed)
{
    if (needed + needbytes > highbytes) {
	arla_warnx (ADEBWARN, 
		    "Out of space since there is outstanding requests "
		    "(%lu needed, %lu outstanding, %lu highbytes", 
		    needed, needbytes, highbytes);
	return ENOSPC;
    }

    needbytes += needed;
    fcache_wakeup_cleaner(fcache_need_bytes);
    needbytes -= needed;
    if (needed > highbytes - usedbytes) {
	arla_warnx (ADEBWARN, 
		    "Out of space, couldn't get needed bytes after cleaner "
		    "(%lu bytes missing, %lu used, %lu highbytes)",
		    needed - (highbytes - usedbytes), 
		    usedbytes, highbytes);
	return ENOSPC;
    }
    return 0;
}

Bool
fcache_need_nodes (void)
{
    fcache_wakeup_cleaner (lrulist);
    if (current_vnodes == usedvnodes)
	return FALSE;
    return TRUE;
}


/*
 * Run through the heap of objects to be invalidated and throw them away
 * when they time arrive.
 */

static void
invalidator (char *arg)
{
    for (;;) {
	const void *head;
	struct timeval tv;

	arla_warnx(ADEBCLEANER,
		   "running invalidator");

	while ((head = heap_head (invalid_heap)) == NULL)
	    LWP_WaitProcess (invalid_heap);

	gettimeofday (&tv, NULL);

	while ((head = heap_head (invalid_heap)) != NULL) {
	    FCacheEntry *entry = (FCacheEntry *)head;

	    if (tv.tv_sec < entry->callback.ExpirationTime) {
		unsigned long t = entry->callback.ExpirationTime - tv.tv_sec;

		arla_warnx (ADEBCLEANER,
			    "invalidator: sleeping for %lu second(s)", t);
		IOMGR_Sleep (t);
		break;
	    }

	    ObtainWriteLock (&entry->lock);
	    if (head == heap_head (invalid_heap)) {
		heap_remove_head (invalid_heap);
		entry->invalid_ptr = -1;
		if (entry->flags.kernelp)
		    break_callback (entry);
	    }
	    ReleaseWriteLock (&entry->lock);
	}
    }
}

/*
 * Add `entry' to the list of to invalidate when its time is up.
 */

static void
add_to_invalidate (FCacheEntry *e)
{
    if (e->invalid_ptr != -1)
	heap_remove (invalid_heap, e->invalid_ptr);
    heap_insert (invalid_heap, (const void *)e, &e->invalid_ptr);
    LWP_NoYieldSignal (invalid_heap);
    IOMGR_Cancel(invalidator_pid);
}

/*
 * Remove the entry least-recently used and return it locked.  Sleep until
 * there's an entry.
 */

static FCacheEntry *
unlink_lru_entry (void)
{
     FCacheEntry *entry = NULL;
     Listitem *item;

     if (highvnodes == usedvnodes)
	 fcache_need_nodes();
a539 3
     for (;;) {

	 assert (!listemptyp (lrulist));
d541 1
a541 1
	      item;
a542 1

d544 3
a546 1
	     if (!entry->flags.usedp
d549 2
a550 3
		 listdel (lrulist, entry->lru_le);
		 entry->lru_le = NULL;
		 return entry;
d553 1
a553 2

	 assert (!listemptyp (lrulist));
d555 1
a555 1
	      item;
a556 1

d558 2
a559 3
	     if (entry->flags.usedp
		 && !entry->flags.attrusedp
		 && entry->refcount == 0
d562 2
a563 4
		 listdel (lrulist, entry->lru_le);
		 entry->lru_le = NULL;
		 throw_entry (entry);
		 return entry;
d566 1
a567 3
	 arla_warnx (ADEBFCACHE, "unlink_lru_entry: sleeping");
	 fcache_need_nodes();
     }
d571 1
a571 1
 * Return a usable locked entry.
d581 1
a581 1
	arla_warnx (ADEBWARN, "All vnode entries in use");
d583 1
a583 1
	AssertExclLocked(&entry->lock);
a598 6
    u_int32_t u1, u2;

    if (lrulist == NULL) {
	arla_warnx (ADEBFCACHE, "store_state: lrulist is NULL");
	return 0;
    }
a602 10
    u1 = FCACHE_MAGIC_COOKIE;
    u2 = FCACHE_VERSION;
    if (write (fd, &u1, sizeof(u1)) != sizeof(u1)
	|| write (fd, &u2, sizeof(u2)) != sizeof(u2)) {
	int save_errno = errno;

	close (fd);
	return save_errno;
    }
    
a611 2
	    int save_errno = errno;

d613 1
a613 1
	    return save_errno;
a638 1
    u_int32_t u1, u2;
a642 16
    if (read (fd, &u1, sizeof(u1)) != sizeof(u1)
	|| read (fd, &u2, sizeof(u2)) != sizeof(u2)) {
	close (fd);
	return;
    }
    if (u1 != FCACHE_MAGIC_COOKIE) {
	arla_warnx (ADEBFCACHE, "dump file not recognized, ignoring");
	close (fd);
	return;
    }
    if (u2 != FCACHE_VERSION) {
	arla_warnx (ADEBFCACHE, "unknown dump file version number %u", u2);
	close (fd);
	return;
    }

a648 2
	int res;
	int type;
d653 1
a653 2
	res = volcache_getbyid (tmp.fid.fid.Volume, tmp.fid.Cell,
				ce, &vol, &type);
d655 1
a655 1
	if (res)
a658 1
	assert (e != NULL);
a664 1
	e->length   = tmp.length;
d676 2
a677 3
	e->index      = tmp.index;
	e->handle     = tmp.handle; /* XXX */
	node_count = max(node_count, tmp.index + 1);
d685 1
a685 5
	e->flags.mountp    = tmp.flags.mountp;
	e->flags.fake_mp   = tmp.flags.fake_mp;
	e->flags.vol_root  = tmp.flags.vol_root;
	e->flags.sentenced = FALSE;
	e->flags.silly 	   = FALSE;
d688 1
a689 2
	e->hits = 0;
	e->cleanergen = 0;
a690 1
	assert(e->lru_le);
d694 1
a694 1
	    usedbytes += e->length;
a698 1
    current_vnodes = n;
d708 1
a708 1
findaccess (xfs_pag_t cred, AccessEntry *ae, AccessEntry **pos)
d718 1
d721 1
d726 2
a727 1
 * Initialize a `fs_server_context'.
d730 2
a731 48
static void
init_fs_server_context (fs_server_context *context)
{
    context->num_conns = 0;
}

/*
 * Find the next fileserver for the request in `context'.
 * Returns a ConnCacheEntry or NULL.
 */

ConnCacheEntry *
find_next_fs (fs_server_context *context,
	      ConnCacheEntry *prev_conn,
	      int mark_as_dead)
{
    if (mark_as_dead)
	conn_dead (prev_conn);

    if (context->i < context->num_conns)
	return context->conns[context->i++];
    else
	return NULL;
}

/*
 * Clean up a `fs_server_context'
 */

void
free_fs_server_context (fs_server_context *context)
{
    int i;

    for (i = 0; i < context->num_conns; ++i)
	conn_free (context->conns[i]);
}

/*
 * Find the first file server housing the volume for `e'.
 * The context is saved in `context' and can later be sent to find_next_fs.
 * Returns a ConnCacheEntry or NULL.
 */

ConnCacheEntry *
find_first_fs (FCacheEntry *e,
	       CredCacheEntry *ce,
	       fs_server_context *context)
d733 1
d736 2
a737 4
    int bit;
    int num_clones;
    int cell = e->fid.Cell;
    int ret;
d739 5
a743 1
    memset(context, 0, sizeof(*context));
d745 12
a756 8
    if (ve == NULL) {
	int type;

	ret = volcache_getbyid (e->fid.fid.Volume, e->fid.Cell,
				ce, &e->volume, &type);
	if (ret)
	    return NULL;
	ve = e->volume;
d759 5
a763 3
    ret = volume_make_uptodate (ve, ce);
    if (ret)
	return NULL;
d765 1
a765 1
    bit = volcache_volid2bit (ve, e->fid.fid.Volume);
d767 4
a770 24
    if (bit == -1) {
	/* the volume entry is inconsistent. */
	volcache_invalidate_ve (ve);
	return NULL;
    }

    num_clones = 0;
    for (i = 0; i < min(NMAXNSERVERS,ve->entry.nServers); ++i) {
	u_long addr = htonl(ve->entry.serverNumber[i]);

	if (ve->entry.serverFlags[i] & bit
	    && addr != 0
	    && (ve->entry.serverFlags[i] & VLSF_DONTUSE) == 0) {
	    ConnCacheEntry *conn;

	    conn = conn_get (cell, addr, afsport,
			     FS_SERVICE_ID, fs_probe, ce);
	    if (conn != NULL) {
		conn->rtt = rx_PeerOf(conn->connection)->rtt
		    + rand() % RTT_FUZZ - RTT_FUZZ / 2;
		context->conns[num_clones] = conn;
		++num_clones;
	    }
	}
d772 1
a772 8

    qsort (context->conns, num_clones, sizeof(*context->conns),
	   conn_rtt_cmp);

    context->num_conns = num_clones;
    context->i	       = 0;

    return find_next_fs (context, NULL, FALSE);
d791 1
a791 8
#ifdef KERBEROS
    fhopen_working = k_hasafs ();
#else
    fhopen_working = 0;
#endif
    collectstats_init ();

    node_count     = 1;		/* XXX */
d806 5
a810 3
    invalid_heap = heap_new (ahighvnodes, expiration_time_cmp);
    if (invalid_heap == NULL)
	arla_errx (1, ADEBERROR, "fcache: heap_new failed");
d833 1
a833 3
 * set new values for those of lowvnodes, highvnodes, lowbytes, highbytes
 * that are not zero.
 * return 0 or an error code
d843 6
a848 8
    
    if (ahighvnodes != 0) {
	if (ahighvnodes > highvnodes) {
	    highvnodes = ahighvnodes;
	    LWP_NoYieldSignal (create_nodes);
	} else
	    highvnodes = ahighvnodes;
    }
d864 1
a864 1
 * If it's found, move it to the front of `lrulist' as well.
d868 1
a868 1
find_entry_nolock (VenusFid fid)
a872 3
    if (hashtab == NULL)
	return NULL;

d876 1
a878 1
	assert(e->lru_le);
a883 16
 * Find the entry and return it locked.
 */

static FCacheEntry *
find_entry (VenusFid fid)
{
    FCacheEntry *e;

    e = find_entry_nolock (fid);
    
    if (e != NULL)
	ObtainWriteLock (&e->lock);
    return e;
}

/*
a884 1
 * This might be overly hash to opened files.
d894 1
a894 11
    if (CheckLock (&e->lock) != 0)
	e->flags.sentenced = TRUE;
    else {
	ObtainWriteLock (&e->lock);
	e->callback = callback;
	e->tokens   = 0;
	if (e->flags.kernelp)
	    break_callback (e);
	ReleaseWriteLock (&e->lock);
    }
}
d896 7
a902 22
struct stale_arg {
    VenusFid fid;
    AFSCallBack callback;
};

/*
 * Iterate over all entries till we find an entry that matches in only
 * fid (without cell) and stale it.
 */

static Bool
stale_unknown_cell (void *ptr, void *arg)
{
    FCacheEntry *e = (FCacheEntry *)ptr;
    struct stale_arg *sa = (struct stale_arg *)arg;

    if (e->fid.fid.Volume    == sa->fid.fid.Volume
	&& e->fid.fid.Vnode  == sa->fid.fid.Vnode
	&& e->fid.fid.Unique == sa->fid.fid.Unique)
	stale (e, sa->callback);

    return FALSE;
d914 1
a914 11
    if (fid.Cell == -1) {
	struct stale_arg arg;

	arg.fid = fid;
	arg.callback = callback;

	hashtabforeach (hashtab, stale_unknown_cell, &arg);
	return;
    }

    e = find_entry_nolock (fid);
d921 2
d926 1
d928 1
a928 1
    xfs_pag_t pag;
d932 1
d951 1
a951 2
		if (e->flags.kernelp)
		    install_attr (e, FCACHE2XFSNODE_RIGHT);
d965 1
a965 1
fcache_purge_cred (xfs_pag_t pag, int32_t cell)
d986 2
a987 2
    if ((e->fid.Cell == fid->Cell || fid->Cell == -1)
	&& e->fid.fid.Volume == fid->fid.Volume) {
d1015 4
a1018 2
    if (e->host == *host)
	stale (e, broken_callback);
d1033 11
a1043 1
 * Mark `entry' as not being used.
d1046 2
a1047 2
void
fcache_unused (FCacheEntry *entry)
d1049 9
a1057 8
    entry->flags.datausedp = entry->flags.attrusedp = FALSE;
    listdel (lrulist, entry->lru_le);
    entry->lru_le = listaddtail (lrulist, entry);
    assert (entry->lru_le);
    /* 
     * we don't signal lrulist here since we never
     * free the node (usedvnode--);
     */
d1061 1
a1061 1
 * make up some status that might be valid for a mount-point
d1064 2
a1065 2
static void
fake_mp_status (FCacheEntry *e)
d1067 1
a1067 1
    AFSFetchStatus *status = &e->status;
d1069 2
a1070 7
    status->FileType      = TYPE_DIR;
    status->LinkCount     = 100;
    status->UnixModeBits  = 0777;
    status->ClientModTime = 0;
    status->ServerModTime = 0;
    status->Owner         = 0;
    status->Group         = 0;
d1074 1
a1074 1
 * Return true if `entry' is a mountpoint
d1077 2
a1078 2
static Bool
mountpointp (FCacheEntry *entry)
d1080 1
a1080 6
    if (entry->status.FileType == TYPE_LINK
	&& entry->status.Length != 0
	&& entry->status.UnixModeBits == 0644)
	return TRUE;
    return FALSE;
}
d1082 2
a1083 4
/*
 * Mark `entry' as mountpoint or a fake mountpoint depending on
 * fake_mp is used or not.
 */
d1085 2
a1086 9
void
fcache_mark_as_mountpoint (FCacheEntry *entry)
{
    if (fake_mp) {
	entry->flags.fake_mp = TRUE;
	fake_mp_status (entry);
    } else {
	entry->flags.mountp = TRUE;
    }
d1100 1
a1100 1
	      xfs_pag_t cred)
a1103 4
    unsigned long bitmask = 0141777; /* REG, DIR, STICKY, USR, GRP, OTH */

    if (entry->volume && cell_issuid_by_num (entry->volume->cell))
	bitmask |= 0006000; /* SUID, SGID */
a1107 1
    entry->status.UnixModeBits &= bitmask;
d1115 1
a1115 2
	if (entry->volume)
	    volcache_update_volsync (entry->volume, *volsync);
a1122 171
    if (!entry->flags.mountp && mountpointp (entry))
	fcache_mark_as_mountpoint (entry);
}

/*
 * Update entry, common code for do_read_attr and get_attr_bulk
 */

static void
update_attr_entry (FCacheEntry *entry,
		   AFSFetchStatus *status,
		   AFSCallBack *callback,
		   AFSVolSync *volsync,
		   u_int32_t host,
		   xfs_pag_t cred)
{
    if (entry->flags.datap
	&& entry->status.DataVersion != status->DataVersion) {
	throw_data (entry);
	entry->tokens &= ~(XFS_DATA_R|XFS_DATA_W);
    }
    
    update_entry (entry, status, callback, volsync,
		  host, cred);
    
    entry->tokens |= XFS_ATTR_R;
    entry->flags.attrp = TRUE;
}


/*
 * Give up all callbacks.
 */

int
fcache_giveup_all_callbacks (void)
{
    Listitem *item;

    for (item = listtail(lrulist);
	 item != NULL;
	 item = listprev(lrulist, item)) {
	FCacheEntry *entry = (FCacheEntry *)listdata(item);

	if (entry->flags.attrp && 
	    entry->flags.silly == FALSE &&
	    entry->host != 0) {

	    CredCacheEntry *ce;	
	    ConnCacheEntry *conn;
	    AFSCBFids fids;
	    AFSCBs cbs;
	    int ret;

	    ce = cred_get (entry->fid.Cell, 0, CRED_ANY);
	    assert (ce != NULL);

	    conn = conn_get (entry->fid.Cell, entry->host, afsport,
			     FS_SERVICE_ID, fs_probe, ce);
	    cred_free (ce);

	    if (conn != NULL) {
		fids.len = cbs.len = 1;
		fids.val = &entry->fid.fid;
		cbs.val  = &entry->callback;
		
		ret = RXAFS_GiveUpCallBacks (conn->connection, &fids, &cbs);
		conn_free (conn);
		if (ret)
		    arla_warn (ADEBFCACHE, ret, "RXAFS_GiveUpCallBacks");
	    }
	}
    }
    return 0;			/* XXX */
}

/*
 * Obtain new callbacks for all entries in the cache.
 */

int
fcache_reobtain_callbacks (void)
{
    Listitem *item;
    int ret;

    for (item = listtail(lrulist);
	 item != NULL;
	 item = listprev(lrulist, item)) {
	FCacheEntry *entry = (FCacheEntry *)listdata(item);

	if (entry->flags.usedp && 
	    entry->flags.silly == FALSE &&
	    entry->host != 0) {

	    CredCacheEntry *ce;	
	    ConnCacheEntry *conn;
	    AFSFetchStatus status;
	    AFSCallBack callback;
	    AFSVolSync volsync;
	    VolCacheEntry *vol;
	    int type;

	    ce = cred_get (entry->fid.Cell, 0, CRED_ANY);
	    assert (ce != NULL);

	    conn = conn_get (entry->fid.Cell, entry->host, afsport,
			     FS_SERVICE_ID, fs_probe, ce);
	    /*
	     * does this belong here?
	     */

	    ret = volcache_getbyid (entry->fid.fid.Volume,
				    entry->fid.Cell, ce, &vol, &type);
	    if (ret == 0)
		entry->volume = vol;
	    cred_free (ce);

	    if (conn != NULL) {
		ret = RXAFS_FetchStatus (conn->connection,
					 &entry->fid.fid,
					 &status,
					 &callback,
					 &volsync);
		if (ret)
		    arla_warn (ADEBFCACHE, ret, "RXAFS_FetchStatus");
		else
		    update_entry (entry, &status, &callback, &volsync,
				  rx_HostOf(rx_PeerOf (conn->connection)),
				  ce->cred);
		conn_free (conn);
		fcache_counter.fetch_attr++;
	    }
	}
    }
    return 0;			/* XXX */
}

/*
 * Return true iff there's any point in trying the next fs.
 */

static Bool
try_next_fs (int error, const VenusFid *fid)
{
    switch (error) {
    case RXKADUNKNOWNKEY:
    case ARLA_CALL_DEAD :
    case ARLA_INVALID_OPERATION :
    case ARLA_CALL_TIMEOUT :
    case ARLA_EOF :
    case ARLA_PROTOCOL_ERROR :
    case ARLA_USER_ABORT :
    case ARLA_ADDRINUSE :
    case ARLA_MSGSIZE :
    case ARLA_VSALVAGE :
    case ARLA_VNOSERVICE :
    case ARLA_VOFFLINE :
    case ARLA_VBUSY :
    case ARLA_VIO :
	return TRUE;
    case ARLA_VNOVOL :
    case ARLA_VMOVED :
	if (fid && !volcache_reliable (fid->fid.Volume, fid->Cell))
	    volcache_invalidate (fid->fid.Volume, fid->Cell);
	return TRUE;
    case 0 :
	return FALSE;
    default :
	return FALSE;
    }
d1128 1
a1128 7
 * `ret_conn'
 *
 * `entry' must be write-locked.
 *
 * If an error code is returned `fs_server_context' is already freed.
 * If everything is ok, `fs_server_context' must be freed by the caller.
 */
d1133 1
a1133 2
	      ConnCacheEntry **ret_conn,
	      fs_server_context *ret_context)
d1135 1
a1135 1
    int ret = ARLA_CALL_DEAD;
a1139 1
    struct collect_stat collectstat;
d1141 1
a1141 3
    AssertExclLocked(&entry->lock);

    *ret_conn = NULL;
d1144 2
a1145 1
	if (entry->flags.attrp)
d1147 1
a1147 2
	else
	    return ENETDOWN;
d1150 10
a1159 16
    for (conn = find_first_fs (entry, ce, ret_context);
	 conn != NULL;
	 conn = find_next_fs (ret_context, conn, host_downp (ret))) {

	collectstats_start(&collectstat);
	ret = RXAFS_FetchStatus (conn->connection,
				 &entry->fid.fid,
				 &status,
				 &callback,
				 &volsync);
	collectstats_stop(&collectstat, entry, conn,
			  STATISTICS_REQTYPE_FETCHSTATUS, 1);
	arla_warnx (ADEBFCACHE, "trying to fetch status: %d", ret);
	if (!try_next_fs (ret, &entry->fid))
	    break;
    }
d1161 1
a1161 1
	if (host_downp(ret))
d1163 1
a1164 1
	free_fs_server_context (ret_context);
d1168 5
a1172 1
    fcache_counter.fetch_attr++;
d1174 6
a1179 3
    update_attr_entry (entry, &status, &callback, &volsync,
		       rx_HostOf (rx_PeerOf (conn->connection)),
		       ce->cred);
a1180 2
    AssertExclLocked(&entry->lock);

a1187 1
 * `e' must be write-locked.
a1194 1
    fs_server_context context;
d1196 1
a1196 1
    AssertExclLocked(&entry->lock);
d1198 1
a1198 2
    init_fs_server_context (&context);
    ret = do_read_attr (entry, ce, &conn, &context);
d1201 1
a1201 1
    free_fs_server_context (&context);
a1218 1
    struct collect_stat collectstat;
d1222 1
a1222 1
    AssertExclLocked(&entry->lock);
d1224 2
a1225 4
    if (connected_mode == DISCONNECTED) {
	ret = ENETDOWN;
	goto out;
    }
d1227 2
a1228 4
    if (usedbytes + entry->status.Length > highbytes) {
	ret = fcache_need_bytes (entry->status.Length);
	if (ret) goto out;
    }
a1230 3
	arla_warnx (ADEBWARN, "Out of space, not enough cache "
		    "(%d file-length %lu usedbytes)",
		    entry->status.Length,  usedbytes);
a1241 1
    collectstats_start(&collectstat);
d1251 1
a1251 1
	ret = conv_to_arla_errno(rx_Error(call));
d1258 3
a1260 1
    fd = fcache_open_file (entry, O_RDWR);
d1264 1
a1264 1
		   (unsigned)entry->index);
d1269 1
a1269 2
    if (ftruncate(fd, sizefs) < 0) {
	close(fd);
d1271 2
a1272 2
	rx_EndCall(call, 0);
	goto out;
d1275 1
a1275 7
    ret = copyrx2fd (call, fd, 0, sizefs);
    close (fd);
    if (ret) {
	arla_warn (ADEBFCACHE, ret, "copyrx2fd");
	rx_EndCall(call, ret);
	goto out;
    }
a1284 4
    collectstats_stop(&collectstat, entry, conn,
		      STATISTICS_REQTYPE_FETCHDATA, sizefs);

    fcache_counter.fetch_data++;
a1288 2
    entry->length = sizefs;
    usedbytes += sizefs;		/* XXX - sync */
a1293 2
    AssertExclLocked(&entry->lock);

d1302 1
a1302 2
write_data (FCacheEntry *entry, AFSStoreStatus *storestatus,
	    CredCacheEntry *ce)
d1306 1
a1306 1
     int ret = ARLA_CALL_DEAD;
d1310 1
d1312 1
a1313 1
     fs_server_context context;
d1315 3
a1317 1
     AssertExclLocked(&entry->lock);
d1319 2
a1320 3
     /* Don't write data to deleted files */
     if (entry->flags.silly)
	 return 0;
d1322 1
a1322 1
     fd = fcache_open_file (entry, O_RDWR);
d1326 2
a1327 2
		    (unsigned)entry->index);
	 return ret;
d1331 4
a1334 5
	 ret = errno;
	 close (fd);
	 arla_warn (ADEBFCACHE, ret, "stat cache file %u",
		    (unsigned)entry->index);
	 return ret;
d1339 7
a1345 4
     fcache_update_length (entry, sizefs);
     if (connected_mode != CONNECTED) {
	 close (fd);
	 return 0;
d1348 11
a1358 10
     for (conn = find_first_fs (entry, ce, &context);
	  conn != NULL;
	  conn = find_next_fs (&context, conn, host_downp (ret))) {

	 call = rx_NewCall (conn->connection);
	 if (call == NULL) {
	     arla_warnx (ADEBMISC, "rx_NewCall failed");
	     ret = ENOMEM;
	     break;
	 }
d1360 6
a1365 13
	 ret = StartRXAFS_StoreData (call, &entry->fid.fid,
				     storestatus,
				     0,
				     sizefs,
				     sizefs);
	 if (host_downp(ret)) {
	     rx_EndCall(call, ret);
	     continue;
	 } else if (ret) {
	     arla_warn (ADEBFCACHE, ret, "store-data");
	     rx_EndCall(call, 0);
	     break;
	 }
d1367 8
a1374 6
	 ret = copyfd2rx (fd, call, 0, sizefs);
	 if (ret) {
	     rx_EndCall(call, ret);
	     arla_warn (ADEBFCACHE, ret, "copyfd2rx");
	     break;
	 }
d1376 3
a1378 8
	 ret = EndRXAFS_StoreData (call,
				   &status,
				   &volsync);
	 if (ret) {
	     rx_EndCall (call, ret);
	     arla_warnx (ADEBFCACHE, "EndRXAFS_StoreData");
	     break;
	 }
d1380 1
a1380 25
	 ret = rx_EndCall (call, 0);
	 if (ret) {
	     arla_warn (ADEBFCACHE, ret, "rx_EndCall");
	 }
	 break;
     }

     if (conn != NULL) {
	 if (ret == 0) {
	     fcache_counter.store_data++;
	     update_entry (entry, &status, NULL, &volsync,
			   rx_HostOf(rx_PeerOf(conn->connection)),
			   ce->cred);
	 } else {
	     ftruncate (fd, 0);
	     entry->length = 0;
	     /* undo the work of the fcache_update_size just above the loop */
	     usedbytes -= sizefs; 
	     entry->flags.datap = FALSE;
	 }
     }
     if (host_downp(ret))
	 ret = ENETDOWN;
     free_fs_server_context (&context);
     AssertExclLocked(&entry->lock);
d1382 1
d1395 1
a1395 1
    int ret = ARLA_CALL_DEAD;
d1397 1
d1400 1
a1401 1
    fs_server_context context;
d1403 1
a1403 1
    AssertExclLocked(&entry->lock);
d1405 6
a1410 1
    fd = fcache_open_file (entry, O_RDWR);
d1414 2
a1415 2
		   (unsigned)entry->index);
	return ret;
d1422 1
a1422 1
	return ret;
d1427 5
a1431 2
    if (!entry->flags.datap)
	entry->length = 0;
d1433 1
a1433 1
    fcache_update_length (entry, size);
d1435 6
a1440 2
    if (connected_mode != CONNECTED)
	return 0;
d1442 10
a1451 11
    ret = ENETDOWN;
    for (conn = find_first_fs (entry, ce, &context);
	 conn != NULL;
	 conn = find_next_fs (&context, conn, host_downp (ret))) {

	call = rx_NewCall (conn->connection);
	if (call == NULL) {
	    arla_warnx (ADEBMISC, "rx_NewCall failed");
	    ret = ENOMEM;
	    break;
	}
d1453 7
a1459 15
	storestatus.Mask = 0;
	ret = StartRXAFS_StoreData (call,
				    &entry->fid.fid, 
				    &storestatus,
				    size,
				    0,
				    size);
	if (host_downp(ret)) {
	    rx_EndCall(call, ret);
	    continue;
	} else if(ret) {
	    arla_warn (ADEBFCACHE, ret, "store-data");
	    rx_EndCall(call, 0);
	    break;
	}
d1461 6
d1468 8
a1475 8
	ret = EndRXAFS_StoreData (call,
				  &status,
				  &volsync);
	if (ret) {
	    rx_EndCall (call, ret);
	    arla_warnx (ADEBFCACHE, "EndRXAFS_StoreData");
	    break;
	}
d1477 3
a1479 6
	ret = rx_EndCall (call, 0);
	if (ret) {
	    arla_warn (ADEBFCACHE, ret, "rx_EndCall");
	}
	break;
    }
d1481 2
a1482 10
    if (ret == 0) {
	fcache_counter.store_data++;
	update_entry (entry, &status, NULL, &volsync,
		      rx_HostOf(rx_PeerOf(conn->connection)),
		      ce->cred);
    }
    if (host_downp(ret))
	ret = ENETDOWN;
    free_fs_server_context (&context);
    AssertExclLocked(&entry->lock);
d1495 2
a1496 1
    int ret = ARLA_CALL_DEAD;
d1500 1
a1500 1
    AssertExclLocked(&entry->lock);
d1502 1
a1502 3
    /* Don't write attributes to deleted files */
    if (entry->flags.silly)
	return 0;
d1504 2
a1505 26
    if (connected_mode == CONNECTED) {
	ConnCacheEntry *conn;
	fs_server_context context;
	u_int32_t host;

	for (conn = find_first_fs (entry, ce, &context);
	     conn != NULL;
	     conn = find_next_fs (&context, conn, host_downp (ret))) {

	    host = rx_HostOf (rx_PeerOf (conn->connection));

	    ret = RXAFS_StoreStatus (conn->connection,
				     &entry->fid.fid,
				     store_status,
				     &status,
				     &volsync);
	    if (host_downp(ret)) {
		continue;
	    } else if (ret) {
		arla_warn (ADEBFCACHE, ret, "store-status");
		free_fs_server_context (&context);
		goto out;
	    }
	    break;
	}
	free_fs_server_context (&context);
d1507 8
a1514 20
	if (host_downp(ret)) {
	    ret = ENETDOWN;
	    goto out;
	}

	update_entry (entry, &status, NULL, &volsync, host, ce->cred);
    } else {
	fcache_counter.store_attr++;
	if (store_status->Mask & SS_MODTIME) {
	    entry->status.ClientModTime = store_status->ClientModTime;
	    entry->status.ServerModTime = store_status->ClientModTime;
	}
	if (store_status->Mask & SS_OWNER)
	    entry->status.Owner = store_status->Owner;
	if (store_status->Mask & SS_GROUP)
	    entry->status.Group = store_status->Group;
	if (store_status->Mask & SS_MODEBITS)
	    entry->status.UnixModeBits = store_status->UnixModeBits;
	if (store_status->Mask & SS_SEGSIZE)
	    entry->status.SegSize = store_status->SegSize;
d1516 4
d1522 1
a1522 2
    AssertExclLocked(&entry->lock);

d1536 2
a1537 1
    int ret = ARLA_CALL_DEAD;
a1543 1
    u_int32_t host;
d1545 1
a1545 31
    AssertExclLocked(&dir_entry->lock);

    if (connected_mode == CONNECTED) {
	ConnCacheEntry *conn;
	fs_server_context context;

	for (conn = find_first_fs (dir_entry, ce, &context);
	     conn != NULL;
	     conn = find_next_fs (&context, conn, host_downp (ret))) {

	    host = rx_HostOf (rx_PeerOf (conn->connection));

	    ret = RXAFS_CreateFile (conn->connection,
				    &dir_entry->fid.fid,
				    name,
				    store_attr,
				    &OutFid,
				    fetch_attr,
				    &status,
				    &callback,
				    &volsync);
	    if (host_downp(ret)) {
		continue;
	    } else if (ret) {
		free_fs_server_context (&context);
		arla_warn (ADEBFCACHE, ret, "CreateFile");
		goto out;
	    }
	    break;
	}
	free_fs_server_context (&context);
d1547 1
a1547 4
	if (host_downp(ret)) {
	    ret = ENETDOWN;
	    goto out;
	}
d1549 2
a1550 4
	update_entry (dir_entry, &status, &callback, &volsync,
		      host, ce->cred);
    } else {
	static int fakefid = 1001;
d1552 13
a1564 26
	OutFid.Volume = dir_entry->fid.fid.Volume;
	OutFid.Vnode  = fakefid;
	OutFid.Unique = fakefid;
	fakefid += 2;

	fetch_attr->InterfaceVersion = 1;
	fetch_attr->FileType         = TYPE_FILE;
	fetch_attr->LinkCount        = 1;
	fetch_attr->Length	     = 0;
	fetch_attr->DataVersion      = 1;
	fetch_attr->Author           = store_attr->Owner;
	fetch_attr->Owner            = store_attr->Owner;
	fetch_attr->CallerAccess     = dir_entry->status.CallerAccess;
	fetch_attr->AnonymousAccess  = dir_entry->status.AnonymousAccess;
	fetch_attr->UnixModeBits     = store_attr->UnixModeBits;
	fetch_attr->ParentVnode      = dir_entry->fid.fid.Vnode;
	fetch_attr->ParentUnique     = dir_entry->fid.fid.Unique;
	fetch_attr->SegSize          = store_attr->SegSize;
	fetch_attr->ClientModTime    = store_attr->ClientModTime;
	fetch_attr->ServerModTime    = store_attr->ClientModTime;
	fetch_attr->Group            = store_attr->Group;
	fetch_attr->SyncCount        = 0;
	fetch_attr->spare1           = 0;
	fetch_attr->spare2           = 0;
	fetch_attr->spare3           = 0;
	fetch_attr->spare4           = 0;
d1566 3
a1568 2
	host = dir_entry->host;
    }
d1580 2
a1581 1
		  host, ce->cred);
d1586 1
a1586 1
    fd = fcache_open_file (child_entry, O_WRONLY);
d1590 2
a1591 10
		   (unsigned)child_entry->index);
	fcache_release(child_entry);
	goto out;
    }
    if (ftruncate (fd, 0) < 0) {
	ret = errno;
	arla_warn (ADEBFCACHE, ret, "ftruncate cache file %u",
		   (unsigned)child_entry->index);
	close (fd);
	fcache_release(child_entry);
a1594 1
    child_entry->length = 0;
d1599 1
a1599 1
    fcache_release(child_entry);
d1602 1
a1602 2
    AssertExclLocked(&dir_entry->lock);

d1616 2
a1617 1
    int ret = ARLA_CALL_DEAD;
a1622 1
    u_int32_t host;
d1624 1
a1624 1
    AssertExclLocked(&dir_entry->lock);
d1626 1
a1626 30
    if (connected_mode == CONNECTED) {
	ConnCacheEntry *conn;
	fs_server_context context;

	for (conn = find_first_fs (dir_entry, ce, &context);
	     conn != NULL;
	     conn = find_next_fs (&context, conn, host_downp (ret))) {

	    host = rx_HostOf(rx_PeerOf(conn->connection));

	    ret = RXAFS_MakeDir (conn->connection,
				 &dir_entry->fid.fid,
				 name,
				 store_attr,
				 &OutFid,
				 fetch_attr,
				 &status,
				 &callback,
				 &volsync);

	    if (host_downp(ret)) {
		continue;
	    } else if (ret) {
		free_fs_server_context (&context);
		arla_warn (ADEBFCACHE, ret, "MakeDir");
		goto out;
	    }
	    break;
	}
	free_fs_server_context (&context);
d1628 2
a1629 4
	if (host_downp(ret)) {
	    ret = ENETDOWN;
	    goto out;
	}
d1631 9
a1639 4
	update_entry (dir_entry, &status, &callback, &volsync,
		      host, ce->cred);
    } else {
	static int fakedir = 1000;
d1641 4
a1644 26
	OutFid.Volume = dir_entry->fid.fid.Volume;
	OutFid.Vnode  = fakedir;
	OutFid.Unique = fakedir;
	fakedir += 2;

	fetch_attr->InterfaceVersion = 1;
	fetch_attr->FileType         = TYPE_DIR;
	fetch_attr->LinkCount        = 2;
	fetch_attr->Length           = AFSDIR_PAGESIZE;
	fetch_attr->DataVersion      = 1;
	fetch_attr->Author           = store_attr->Owner;
	fetch_attr->Owner            = store_attr->Owner;
	fetch_attr->CallerAccess     = dir_entry->status.CallerAccess;
	fetch_attr->AnonymousAccess  = dir_entry->status.AnonymousAccess;
	fetch_attr->UnixModeBits     = store_attr->UnixModeBits;
	fetch_attr->ParentVnode      = dir_entry->fid.fid.Vnode;
	fetch_attr->ParentUnique     = dir_entry->fid.fid.Unique;
	fetch_attr->SegSize          = store_attr->SegSize;
	fetch_attr->ClientModTime    = store_attr->ClientModTime;
	fetch_attr->ServerModTime    = store_attr->ClientModTime;
	fetch_attr->Group            = store_attr->Group;
	fetch_attr->SyncCount        = 0;
	fetch_attr->spare1           = 0;
	fetch_attr->spare2           = 0;
	fetch_attr->spare3           = 0;
	fetch_attr->spare4           = 0;
d1646 3
a1648 2
	host = dir_entry->host;
    }
a1658 3
    if(child_entry->flags.datap)
	throw_data (child_entry);

d1660 2
a1661 1
		  host, ce->cred);
d1669 1
a1669 1
	fcache_release(child_entry);
d1673 2
d1678 1
a1678 1
    fcache_release(child_entry);
d1681 1
a1681 1
    AssertExclLocked(&dir_entry->lock);
a1686 3
 *
 * Note: create_symlink->flags.kernelp is not set on success
 * and that must be done by the caller.
d1696 1
a1696 1
    int ret = ARLA_CALL_DEAD;
a1701 2
    u_int32_t host;
    fs_server_context context;
d1703 1
a1703 1
    AssertExclLocked(&dir_entry->lock);
d1705 1
a1705 2
    if (connected_mode != CONNECTED)
	return EINVAL;
d1707 2
a1708 25
    for (conn = find_first_fs (dir_entry, ce, &context);
	 conn != NULL;
	 conn = find_next_fs (&context, conn, host_downp (ret))) {

	host = rx_HostOf(rx_PeerOf(conn->connection));

	ret = RXAFS_Symlink (conn->connection,
			     &dir_entry->fid.fid,
			     name,
			     contents,
			     store_attr,
			     &OutFid,
			     fetch_attr,
			     &new_status,
			     &volsync);
	if (host_downp(ret)) {
	    continue;
	} else if (ret) {
	    arla_warn (ADEBFCACHE, ret, "Symlink");
	    free_fs_server_context (&context);
	    goto out;
	}
	break;
    }
    free_fs_server_context (&context);
d1710 11
a1720 2
    if (host_downp(ret)) {
	ret = ENETDOWN;
d1724 2
d1727 2
a1728 1
		  host, ce->cred);
d1740 2
a1741 7
		  host, ce->cred);

    /* 
     * flags.kernelp is set in cm_symlink since the symlink
     * might be a mountpoint and this entry is never install
     * into the kernel.
     */
d1744 1
d1747 1
a1747 1
    fcache_release(child_entry);
d1750 1
a1750 1
    AssertExclLocked(&dir_entry->lock);
a1768 2
    u_int32_t host;
    fs_server_context context;
d1770 1
a1770 1
    AssertExclLocked(&dir_entry->lock);
d1772 1
a1772 2
    if (connected_mode != CONNECTED)
	return EINVAL;
d1774 2
a1775 23
    for (conn = find_first_fs (dir_entry, ce, &context);
	 conn != NULL;
	 conn = find_next_fs (&context, conn, host_downp (ret))) {

	host = rx_HostOf(rx_PeerOf(conn->connection));

	ret = RXAFS_Link (conn->connection,
			  &dir_entry->fid.fid,
			  name,
			  &existing_entry->fid.fid,
			  &new_status,
			  &status,
			  &volsync);
	if (host_downp(ret)) {
	    continue;
	} else if (ret) {
	    free_fs_server_context (&context);
	    arla_warn (ADEBFCACHE, ret, "Link");
	    goto out;
	}
	break;
    }
    free_fs_server_context (&context);
d1777 9
a1785 2
    if (host_downp(ret)) {
	ret = ENETDOWN;
d1789 2
d1792 2
a1793 1
		  host, ce->cred);
d1796 2
a1797 1
		  host, ce->cred);
d1800 1
a1800 1
    AssertExclLocked(&dir_entry->lock);
d1811 1
a1811 1
    int ret = ARLA_CALL_DEAD;
a1814 2
    u_int32_t host;
    fs_server_context context;
d1816 1
a1816 1
    AssertExclLocked(&dir_entry->lock);
d1818 1
a1818 2
    if (connected_mode != CONNECTED)
	return EINVAL;
d1820 2
a1821 21
    for (conn = find_first_fs (dir_entry, ce, &context);
	 conn != NULL;
	 conn = find_next_fs (&context, conn, host_downp (ret))) {

	host = rx_HostOf(rx_PeerOf(conn->connection));

	ret = RXAFS_RemoveFile (conn->connection,
				&dir_entry->fid.fid,
				name,
				&status,
				&volsync);
	if (host_downp(ret)) {
	    continue;
	} else if (ret) {
	    free_fs_server_context (&context);
	    arla_warn (ADEBFCACHE, ret, "RemoveFile");
	    goto out;
	}
	break;
    }
    free_fs_server_context (&context);
d1823 7
a1829 2
    if (host_downp(ret)) {
	ret = ENETDOWN;
d1833 2
d1836 2
a1837 1
		  host, ce->cred);
d1840 1
a1840 1
    AssertExclLocked(&dir_entry->lock);
d1845 1
a1845 1
 * Remove a directory from a directory.
d1853 1
a1853 1
    int ret = ARLA_CALL_DEAD;
a1856 2
    u_int32_t host;
    fs_server_context context;
d1858 1
a1858 1
    AssertExclLocked(&dir_entry->lock);
d1860 1
a1860 2
    if (connected_mode != CONNECTED)
	return EINVAL;
d1862 2
a1863 21
    for (conn = find_first_fs (dir_entry, ce, &context);
	 conn != NULL;
	 conn = find_next_fs (&context, conn, host_downp (ret))) {

	host = rx_HostOf(rx_PeerOf(conn->connection));

	ret = RXAFS_RemoveDir (conn->connection,
			       &dir_entry->fid.fid,
			       name,
			       &status,
			       &volsync);
	if (host_downp(ret)) {
	    continue;
	} else if (ret) {
	    free_fs_server_context (&context);
	    arla_warn (ADEBFCACHE, ret, "RemoveDir");
	    goto out;
	}
	break;
    }
    free_fs_server_context (&context);
d1865 7
a1871 2
    if (host_downp(ret)) {
	ret = ENETDOWN;
d1875 2
d1878 2
a1879 1
		  host, ce->cred);
d1882 1
a1882 1
    AssertExclLocked(&dir_entry->lock);
d1897 1
a1897 1
    int ret = ARLA_CALL_DEAD;
a1900 2
    u_int32_t host;
    fs_server_context context;
d1902 2
a1903 2
    AssertExclLocked(&old_dir->lock);
    AssertExclLocked(&new_dir->lock);
d1905 4
a1908 2
    if (connected_mode != CONNECTED)
	return EINVAL;
d1910 8
a1917 24
    for (conn = find_first_fs (old_dir, ce, &context);
	 conn != NULL;
	 conn = find_next_fs (&context, conn, host_downp (ret))) {

	host = rx_HostOf(rx_PeerOf(conn->connection));

	ret = RXAFS_Rename (conn->connection,
			    &old_dir->fid.fid,
			    old_name,
			    &new_dir->fid.fid,
			    new_name,
			    &orig_status,
			    &new_status,
			    &volsync);
	if (host_downp(ret)) {
	    continue;
	} else if (ret) {
	    free_fs_server_context (&context);
	    arla_warn (ADEBFCACHE, ret, "Rename");
	    goto out;
	}
	break;
    }
    free_fs_server_context (&context);
d1919 2
a1920 2
    if (host_downp(ret)) {
	ret = ENETDOWN;
d1924 4
d1929 2
a1930 1
		  host, ce->cred);
d1933 2
a1934 1
		  host, ce->cred);
d1937 1
a1937 2
    AssertExclLocked(&old_dir->lock);
    AssertExclLocked(&new_dir->lock);
a1950 13
     int type;
     int ret;
     const char *this_cell = cell_getthiscell ();
     int32_t this_cell_id;
     static int busy_wait = 0;

     if (dynroot_enablep()) {
	 res->Cell = dynroot_cellid ();
	 res->fid.Volume = dynroot_volumeid ();
	 res->fid.Vnode = fid.fid.Unique = 1;

	 return 0;
     }
d1952 4
a1955 16
     this_cell_id = cell_name2num (this_cell);
     if (this_cell_id == -1)
	 arla_errx (1, ADEBERROR, "cell %s does not exist", this_cell);

     while (busy_wait)
	 LWP_WaitProcess (getroot);

     busy_wait = 1;
     ret = volcache_getbyname (root_volume, this_cell_id, ce, &ve, &type);
     busy_wait = 0;
     LWP_NoYieldSignal (getroot);
     if (ret) {
	 arla_warn (ADEBWARN, ret,
		    "Cannot find the root volume (%s) in cell %s",
		    root_volume, this_cell);
	 return ret;
d1958 1
a1958 1
     fid.Cell = this_cell_id;
d1963 2
a1964 2
		    "getroot: %s in cell %s is missing a RO clone, not good",
		    root_volume, this_cell);
d1968 2
a1969 2
		   "getroot: %s in cell %s has no RW or RO clone?",
		   root_volume, this_cell);
d1984 1
a1984 1
gettype (int32_t volid, const VolCacheEntry *ve)
a2015 1
    FCacheEntry *old;
d2017 1
a2017 2
    int type, i;
    int error;
d2019 4
a2022 6
    *res = NULL;

    old = find_entry (fid);
    if (old) {
	assert (old->flags.usedp);
	*res = old;
d2026 4
a2029 7
    e = find_free_entry ();
    assert (e != NULL);

    old = find_entry (fid);
    if (old) {
	AssertExclLocked(&e->lock);
	ReleaseWriteLock (&e->lock);
d2031 3
a2033 2
	e->lru_le = listaddtail (lrulist, e);
	assert(e->lru_le);
d2035 4
a2038 16
	assert (old->flags.usedp);
	*res = old;
	return 0;
    }

    e->fid     	       = fid;
    e->refcount        = 0;
    e->host	       = 0;
    e->length          = 0;
    memset (&e->status,   0, sizeof(e->status));
    memset (&e->callback, 0, sizeof(e->callback));
    memset (&e->volsync,  0, sizeof(e->volsync));
    for (i = 0; i < NACCESS; i++) {
	e->acccache[i].cred = ARLA_NO_AUTH_CRED;
	e->acccache[i].access = 0;
    }
d2040 1
a2047 2
    e->flags.fake_mp   = FALSE;
    e->flags.vol_root  = FALSE;
d2049 1
a2049 8
    e->flags.sentenced = FALSE;
    e->flags.silly     = FALSE;
    e->tokens          = 0;
    memset (&e->parent, 0, sizeof(e->parent));
    e->lru_le = listaddhead (lrulist, e);
    assert(e->lru_le);
    e->invalid_ptr     = -1;
    e->volume          = NULL;
d2051 1
a2051 2
    e->hits	       = 0;
    e->cleanergen      = 0;
d2053 1
a2055 13
    if (connected_mode != DISCONNECTED) {
	VolCacheEntry *vol;

	error = volcache_getbyid (fid.fid.Volume, fid.Cell, ce, &vol, &type);
	if (error) {
	    e->volume = NULL;
	    *res = NULL;
	    ReleaseWriteLock (&e->lock);
	    return error;
	}
	e->volume = vol;
    }

a2060 19
 * Release the lock on `e' and mark it as stale if it has been sentenced.
 */

void
fcache_release (FCacheEntry *e)
{
    AssertExclLocked(&e->lock);

    ReleaseWriteLock (&e->lock);

    if (e->flags.sentenced) {
	AFSCallBack broken_callback = {0, 0, CBDROPPED};

	stale (e, broken_callback);
	e->flags.sentenced = FALSE;
    }
}

/*
d2071 1
a2071 1
	connected_mode != FETCH_ONLY)
d2086 1
a2086 386
 * The idea is that we start to stat everything after the prefered
 * entry, everything before that is probably not useful to get, the
 * user is probably trying to stat() everything _after_ that node.
 * This might be somewhat bogus, but we dont care (for now).
 */

struct bulkstat {
    int 		len;		   /* used entries in fids and names */
    AFSFid		fids[AFSCBMAX];    /* fids to fetch */
    char		*names[AFSCBMAX];  /* names it install */
    AFSFid		*used;		   /* do we have a prefered node */
    CredCacheEntry	*ce;		   /* cred to use */
};

typedef union {
    struct xfs_message_installnode node;
    struct xfs_message_installattr attr;
} xfs_message_install_node_attr;

static void
bulkstat_help_func (VenusFid *fid, const char *name, void *ptr)
{
    struct bulkstat *bs = (struct bulkstat *) ptr;
    AccessEntry *ae;
    FCacheEntry key;
    FCacheEntry *e;

    /* Is bs full ? */
    if (bs->len > fcache_bulkstatus_num)
	return;

    /* Ignore . and .. */
    if (strcmp(name, ".") == 0 || strcmp(name, "..") == 0)
	return;

    /* 
     * Do we have a prefered node, and is this the one. If we don't know
     * the name of the node (ie bs.names[0] == NULL), fill it in.
     * Set bs->used to NULL it indicate that we should start stat stuff
     * from here, remeber that bs->len == 1 if bs->used is set.
     */
    if (bs->used) { 
	if (memcmp(bs->used, &fid->fid, sizeof(fid->fid)) == 0) {
	    if (bs->names[0] == NULL)
		bs->names[0] = strdup (name);
	    bs->used = NULL; /* stat everything after this */
	}
	return;
    }

    /*
     * Already cached for this pag ?
     */
    key.fid = *fid;
    e = (FCacheEntry *)hashtabsearch (hashtab, (void *)&key);
    if (e 
	&& e->flags.usedp
	&& e->flags.attrp
	&& uptodatep (e)
	&& findaccess (bs->ce->cred, e->acccache, &ae) == TRUE) {
	arla_warnx (ADEBFCACHE, 
		    "bulkstat_help_func: already cached "
		    "(%d.%d.%d.%d) name: %s",
		    fid->Cell, fid->fid.Volume, fid->fid.Vnode, 
		    fid->fid.Unique, name);
	return;
    }

    if (fcache_enable_bulkstatus == 2) {
	/* cache the name for the installnode */
	bs->names[bs->len] = strdup (name);
	if (bs->names[bs->len] == NULL)
	    return;
    } else {
	bs->names[bs->len] = NULL;
    }
    

    bs->fids[bs->len] = fid->fid;
    bs->len++;    
}

/*
 * Do bulkstat for ``parent_entry''. Make sure that ``prefered_entry''
 * is in the list of fids it not NULL, and it ``prefered_name'' is NULL
 * try to find it in the list files in the directory.
 *
 * 			Entry		Success		Failure
 * parent_entry		locked		locked		locked
 * prefered_entry	locked		locked		locked
 *   or if NULL		if set to NULL must not be locked
 * prefered_fid		related fcache-entry must not be locked
 * ce			not NULL
 */

static int
get_attr_bulk (FCacheEntry *parent_entry, 
	       FCacheEntry *prefered_entry,
	       VenusFid *prefered_fid, 
	       const char *prefered_name,
	       CredCacheEntry *ce)
{
    fs_server_context context;
    ConnCacheEntry *conn;
    struct bulkstat bs;
    AFSBulkStats stats;
    AFSVolSync sync;
    AFSCBFids fids;
    fbuf the_fbuf;
    int ret, fd;
    AFSCBs cbs;
    int i;
    int len;
    u_int32_t host;

    arla_warnx (ADEBFCACHE, "get_attr_bulk");

    if (fcache_enable_bulkstatus == 0)
	return -1;

    if (!parent_entry->flags.datap) {
	arla_warnx (ADEBFCACHE, "get_attr_bulk: parent doesn't have data");
	return -1;
    }
    
    fids.val = bs.fids;

    memset (bs.names, 0, sizeof(bs.names));
    memset (bs.fids,  0, sizeof(bs.fids));
    bs.len	= 0;
    bs.ce	= ce;
    bs.used	= NULL;
    
    /*
     * If we have a prefered_entry, and that to the first entry in the
     * array. This is used later. If we find the prefered_entry in the
     * directory-structure its ignored.
     */

    if (prefered_fid) {
	arla_warnx (ADEBFCACHE, "get_attr_bulk: using prefered_entry");
	bs.used			= &prefered_fid->fid;
	fids.val[bs.len]	= prefered_fid->fid;
	if (prefered_name != NULL) {
	    bs.names[bs.len]	= strdup(prefered_name);
	    if (bs.names[bs.len] == NULL)
		return ENOMEM;
	} else {
	    bs.names[bs.len]    = NULL;
	}
	bs.len++;
    }

    ret = fcache_get_fbuf (parent_entry, &fd, &the_fbuf,
			   O_RDONLY, FBUF_READ|FBUF_SHARED);
    if (ret)
	return ret;

    ret = fdir_readdir (&the_fbuf,
			bulkstat_help_func,
			&bs,
			&parent_entry->fid);
    fbuf_end (&the_fbuf);
    close (fd);
    if (ret)
	goto out_names;
    
    fids.len = bs.len;

    /*
     * Don't do BulkStatus when fids.len == 0 since we should never do it.
     * There should at least be the node that we want in the BulkStatus.
     */

    if (fids.len == 0) {
	if (prefered_fid)
	    arla_warnx (ADEBERROR, 
			"get_attr_bulk: "
			"prefered_fid not found in dir");
	/* XXX MAGIC send it back so we don't do it again soon */
	parent_entry->hits -= 64;
	ret = EINVAL;
	goto out_names;
    }

    /*
     * XXX if there is a prefered fid, and and we didn't find the name for it
     * return an error.
     */

    if (prefered_fid && bs.names[0] == NULL) {
	arla_warnx (ADEBFCACHE, 
		    "get_attr_bulk: didn't find prefered_fid's name");
	ret = EINVAL;
	goto out_names;
    }
    
    ret = ARLA_CALL_DEAD;

    for (conn = find_first_fs (parent_entry, ce, &context);
	 conn != NULL;
	 conn = find_next_fs (&context, conn, host_downp (ret))) {

	stats.val = NULL;
	cbs.val   = NULL;
	stats.len = cbs.len = 0;

	ret = RXAFS_BulkStatus (conn->connection, &fids, &stats, &cbs, &sync);
	if (ret) {
	    free (stats.val);
	    free (cbs.val);
	}
	if (!try_next_fs (ret, &parent_entry->fid))
	    break;	
    }

    if (conn != NULL)
	host = rx_HostOf (rx_PeerOf (conn->connection));
    free_fs_server_context (&context);

    if (ret) {
	ret = ENETDOWN;
	goto out_names;
    }

    arla_warnx (ADEBFCACHE,"get_attr_bulk: BulkStatus returned %d",ret);
    
    len = min(fids.len, min(stats.len, cbs.len));

    /*
     * Save results of bulkstatus
     */

    if (ret == 0) {
	FCacheEntry *e;

	fcache_counter.fetch_attr_bulk += len;

	for (i = 0; i < len && ret == 0; i++) {
	    if (prefered_entry && i == 0) {
		e = prefered_entry;
	    } else {
		VenusFid fid;

		fid.Cell = parent_entry->fid.Cell;
		fid.fid = fids.val[i];

		e = find_entry_nolock (fid);
		if (e != NULL && CheckLock(&e->lock) != 0)
		    continue;

		ret = fcache_get (&e, fid, ce);
		if (ret)
		    break;
	    }
	    update_attr_entry (e,
			       &stats.val[i],
			       &cbs.val[i],
			       &sync,
			       host,
			       ce->cred);
	    e->parent		= parent_entry->fid;
	    if (prefered_entry != e) {
		fcache_release(e);
	    }
	}
    }

    /*
     * Insert result into kernel
     */

    if (fcache_enable_bulkstatus == 2 && ret == 0)  {
	xfs_message_install_node_attr msg[AFSCBMAX];
	struct xfs_msg_node *node;
	xfs_handle *parent;
	FCacheEntry *e;
	VenusFid fid;
	int j;

	fid.Cell = parent_entry->fid.Cell;
	for (i = 0 , j = 0; i < len && ret == 0; i++) {

	    fid.fid = fids.val[i];
	    
	    if (prefered_entry && i == 0) {
		e = prefered_entry;
		ret = 0;
	    } else {
		e = find_entry_nolock (fid);
		if (e != NULL && CheckLock(&e->lock) != 0)
		    continue;

		ret = fcache_get (&e, fid, ce);
	    }
	    if (ret == 0) {
		u_int tokens;

		arla_warnx (ADEBFCACHE, "installing %d.%d.%d\n",
			    e->fid.fid.Volume,
			    e->fid.fid.Vnode,
			    e->fid.fid.Unique);
		e->flags.attrusedp 	= TRUE;

		/*
		 * Its its already installed, just update with installattr
		 */

		e->tokens			|= XFS_ATTR_R;
		tokens				= e->tokens;
		if (!e->flags.kernelp || !e->flags.datausedp)
		    tokens			&= ~XFS_DATA_MASK;

		if (e->flags.kernelp) {
		    msg[j].attr.header.opcode	= XFS_MSG_INSTALLATTR;
		    node			= &msg[j].attr.node;
		    parent			= NULL;
		} else {
		    msg[j].node.header.opcode	= XFS_MSG_INSTALLNODE;
		    node			= &msg[j].node.node;
		    parent			= &msg[j].node.parent_handle;
		    e->flags.kernelp		= TRUE;
		    strlcpy (msg[j].node.name, bs.names[i],
			     sizeof(msg[j].node.name));
		}
		node->tokens = tokens;

		/*
		 * Don't install symlink since they might be
		 * mount-points.
		 */

		if (e->status.FileType != TYPE_LINK) {
		    fcacheentry2xfsnode (&e->fid,
					 &e->fid,
					 &stats.val[i],
					 node, 
					 parent_entry->acccache,
					 FCACHE2XFSNODE_ALL);

		    if (parent)
			*parent = *(struct xfs_handle*) &parent_entry->fid;
		    j++;
		}
		if (!(prefered_entry && i == 0)) {
		    fcache_release(e);
		}
	    }
	}

	/*
	 * Install if there is no error and we have something to install
	 */

	if (ret == 0 && j != 0)
	    ret = xfs_send_message_multiple_list (kernel_fd,
						  (struct xfs_message_header *) msg,
						  sizeof (msg[0]),
						  j);
	/* We have what we wanted, ignore errors */
  	if (ret && i > 0 && prefered_entry)
	    ret = 0;
    }

    free (stats.val);
    free (cbs.val);

 out_names:
    for (i = 0 ; i < bs.len && ret == 0; i++) {
	free (bs.names[i]);
    }

    arla_warnx (ADEBFCACHE, "get_attr_bulk: returned %d", ret);

    return ret;
}


/*
 * fetch attributes for the note `entry' with the rights `ce'.  If
 * `parent_entry' is no NULL, its used for doing bulkstatus when guess
 * necessary. If there is a named associated with `entry' it should be
 * filled into `prefered_name' as that will be used for guessing that
 * nodes should be bulkstat:ed.
 *
 * If there is no bulkstatus done, a plain FetchStatus is done.
d2090 1
a2090 96
fcache_verify_attr (FCacheEntry *entry, FCacheEntry *parent_entry,
		    const char *prefered_name, CredCacheEntry* ce)
{
    FCacheEntry *parent = parent_entry;
    AccessEntry *ae;
    int error;

    if (dynroot_is_dynrootp (entry))
	return dynroot_get_attr (entry, ce);

    if (entry->flags.usedp
	&& entry->flags.attrp
	&& uptodatep(entry)
	&& findaccess (ce->cred, entry->acccache, &ae) == TRUE)
    {
	arla_warnx (ADEBFCACHE, "fcache_get_attr: have attr");
	fcache_counter.fetch_attr_cached++;
	return 0;
    }

    /* 
     * XXX is this right ?
     * Dont ask fileserver if this file is deleted
     */
    if (entry->flags.silly) {
	entry->tokens |= XFS_ATTR_R;
	entry->flags.attrp = TRUE;
	return 0;
    }

    /*
     * If `entry' is a root-node or the parent is
     * un-initialized, don't bother bulkstatus.
     */
    if (entry->fid.fid.Vnode        != 1
	&& entry->fid.fid.Unique    != 1
	&& !entry->flags.mountp
	&& !entry->flags.fake_mp
	&& entry->parent.Cell       != 0
	&& entry->parent.fid.Volume != 0
	&& entry->parent.fid.Vnode  != 0
	&& entry->parent.fid.Unique != 0)
    {
	if (parent == NULL) {
	    arla_warnx (ADEBFCACHE, "fcache_get_attr: getting parent");
	    error = fcache_get (&parent, entry->parent, ce);
	} else
	    error = 0;

	/*
	 * Check if the entry is used, that means that
	 * there is greater chance that we we'll succeed
	 * when doing bulkstatus.
	 */

	if (error == 0) {
	    int error2 = -1;
	    
	    if (parent->hits++ > fcache_bulkstatus_num &&
		parent->flags.datausedp) {
		
		arla_warnx (ADEBFCACHE,
			    "fcache_get_attr: doing bulk get_attr");
		error2 = get_attr_bulk (parent,
					entry, &entry->fid,
					prefered_name, ce);
		/* magic calculation when we are going to do next bulkstat */
		parent->hits = 0;
	    }
	    if (parent_entry == NULL)
		fcache_release (parent);
	    if (error2 == 0)
		return 0;
	}
    }

    /*
     * We got here because the bulkstatus failed, didn't want to do a
     * bulkstatus or we didn't get a parent for the entry
     */

    arla_warnx (ADEBFCACHE, "fcache_get_attr: doing read_attr");

    return read_attr (entry, ce);
}



/*
 * Make sure that `e' has attributes and that they are up-to-date.
 * `e' must be write-locked.
 */


static int
do_read_data (FCacheEntry *e, CredCacheEntry *ce)
d2092 2
a2093 3
    int ret = ARLA_CALL_DEAD;
    fs_server_context context;
    ConnCacheEntry *conn;
d2095 1
a2095 2
    if (connected_mode != CONNECTED)
	return EINVAL;
d2097 3
a2099 8
    for (conn = find_first_fs (e, ce, &context);
	 conn != NULL;
	 conn = find_next_fs (&context, conn, host_downp (ret))) {
	ret = read_data (e, conn, ce);
	if (!try_next_fs (ret, &e->fid))
	    break;
    }
    free_fs_server_context (&context);
d2101 1
a2101 3
    if (host_downp(ret))
	ret = ENETDOWN;
    return ret;
d2109 1
a2109 1
fcache_verify_data (FCacheEntry *e, CredCacheEntry *ce)
d2111 1
a2111 1
    ConnCacheEntry *conn = NULL;
a2112 1
    fs_server_context context;
a2114 1
    AssertExclLocked(&e->lock);
d2116 1
a2116 6
    if (dynroot_is_dynrootp (e))
	return dynroot_get_data (e, ce);

    /* Don't get data for deleted files */
    if (e->flags.silly)
	return 0;
d2119 1
a2119 2
	if (e->flags.datap) {
	    fcache_counter.fetch_data_cached++;
d2121 5
a2125 2
	} else
	    return do_read_data (e, ce);
d2127 1
a2127 1
	ret = do_read_attr (e, ce, &conn, &context);
d2131 1
a2131 2
	    fcache_counter.fetch_data_cached++;
	    free_fs_server_context (&context);
d2136 1
a2136 54
    free_fs_server_context (&context);
    return ret;
}

/*
 * Fetch `fid' with data, returning the cache entry in `res'.
 * note that `fid' might change.
 */

int
fcache_get_data (FCacheEntry **res, VenusFid *fid, CredCacheEntry **ce)
{
    FCacheEntry *e;
    int ret;

    ret = fcache_get (&e, *fid, *ce);
    if (ret)
	return ret;

    if (e->flags.fake_mp) {
	VenusFid new_fid;
	FCacheEntry *new_root;

	ret = resolve_mp (e, &new_fid, ce);
	if (ret) {
	    fcache_release (e);
	    return ret;
	}
	ret = fcache_get (&new_root, new_fid, *ce);
	if (ret) {
	    fcache_release (e);
	    return ret;
	}
	ret = fcache_verify_attr (new_root, NULL, NULL, *ce);
	if (ret) {
	    fcache_release (e);
	    fcache_release (new_root);
	    return ret;
	}
	e->flags.fake_mp   = FALSE;
	e->flags.mountp    = TRUE;
	e->status.FileType = TYPE_LINK;
	update_fid (*fid, e, new_fid, new_root);
	fcache_release (e);
	*fid = new_fid;
	e  = new_root;
	install_attr (e, FCACHE2XFSNODE_ALL);
    }

    ret = fcache_verify_data (e, *ce);
    if (ret == 0)
	*res = e;
    else
	fcache_release (e);
a2140 196
 * Helper function for followmountpoint.
 * Given the contents of a mount-point, figure out the cell and volume name.
 *
 * ``mp'' must be writeable and should not be used afterwards.
 * ``*volname'' is a pointer to somewhere in the mp string.
 * ``cell'' should be set before function is called to default cell.
 */

static int
parse_mountpoint (char *mp, size_t len, int32_t *cell, char **volname)
{
    char *colon;
    
    mp[len - 1] = '\0';
    colon = strchr (mp, ':');
    if (colon != NULL) {
	*colon++ = '\0';
	*cell    = cell_name2num (mp + 1);
	if (*cell == -1)
	    return ENOENT;
	*volname = colon;
    } else {
	*volname = mp + 1;
    }
    return 0;
}

/*
 * Used by followmountpoint to figure out what clone of a volume
 * should be used.
 *
 * Given a `volname', `cell', it uses the given `ce', `mount_symbol'
 * and `parent_type' to return a volume id in `volume'.
 *
 * The rules are:
 *
 * "readonly" -> RO
 * BK + "backup" -> fail
 * "backup" -> BK
 * BK + "" + # -> RO
 * RO + "" + # -> RO
 * * -> RW
 *
 * this_type = "" | "readonly" | "backup"
 * parent_type = RW | RO | BK
 * mount_symbol = "#" | "%"
 */

static int
find_volume (const char *volname, int32_t cell, 
	     CredCacheEntry *ce, char mount_symbol, int parent_type,
	     u_int32_t *volid, VolCacheEntry **ve)
{
    int result_type;
    int this_type;
    int res;

    res = volcache_getbyname (volname, cell, ce, ve, &this_type);
    if (res)
	return res;

    assert (this_type == RWVOL ||
	    this_type == ROVOL ||
	    this_type == BACKVOL);

    if (this_type == ROVOL) {
	if (!((*ve)->entry.flags & VLF_ROEXISTS)) {
	    volcache_free (*ve);
	    return ENOENT;
	}
	result_type = ROVOL;
    } else if (this_type == BACKVOL && parent_type == BACKVOL) {
	volcache_free (*ve);
	return ENOENT;
    } else if (this_type == BACKVOL) {
	if (!((*ve)->entry.flags & VLF_BOEXISTS)) {
	    volcache_free (*ve);
	    return ENOENT;
	}
	result_type = BACKVOL;
    } else if (this_type == RWVOL &&
	       parent_type != RWVOL &&
	       mount_symbol == '#') {
	if ((*ve)->entry.flags & VLF_ROEXISTS)
	    result_type = ROVOL;
	else
	    result_type = RWVOL;
    } else {
	if ((*ve)->entry.flags & VLF_RWEXISTS)
	    result_type = RWVOL;
	else if ((*ve)->entry.flags & VLF_ROEXISTS)
	    result_type = ROVOL;
	else {
	    volcache_free (*ve);
	    return ENOENT;
	}
    }
    *volid = (*ve)->entry.volumeId[result_type];
    return 0;
}

/*
 * Set `fid' to point to the root of the volume pointed to by the
 * mount-point in (buf, len).
 *
 * If succesful, `fid' will be update to the root of the volume, and
 * `ce' will point to a cred in the new cell.
 */

static int
get_root_of_volume (VenusFid *fid, const VenusFid *parent,
		    VolCacheEntry *volume,
		    CredCacheEntry **ce,
		    char *buf, size_t len)
{
    VenusFid oldfid = *fid;
    char *volname;
    int32_t cell;
    u_int32_t volid;
    int res;
    long parent_type;
    char mount_symbol;
    VolCacheEntry *ve;
    FCacheEntry *e;

    cell = fid->Cell;

    res = parse_mountpoint (buf, len, &cell, &volname);
    if (res)
	return res;

    /*
     * If this is a cross-cell mountpoint we need new credentials. 
     */

    if ((*ce)->cell != cell) {
	CredCacheEntry *new_ce;

	new_ce = cred_get(cell, (*ce)->cred, CRED_ANY);
	if (new_ce == NULL)
	    return ENOMEM;
	cred_free (*ce);
	*ce = new_ce;
    }

    parent_type = gettype (fid->fid.Volume, volume);
    mount_symbol = *buf;

    res = find_volume (volname, cell, *ce, mount_symbol,
		       parent_type, &volid, &ve);
    if (res)
	return res;

    /*
     * Create the new fid. The root of a volume always has
     * (Vnode, Unique) = (1,1)
     */

    fid->Cell = cell;
    fid->fid.Volume = volid;
    fid->fid.Vnode = fid->fid.Unique = 1;

    /*
     * Check if we are looking up ourself, if we are, just return.
     */

    if (VenusFid_cmp(fid, parent) == 0) {
	volcache_free (ve);
	return 0;
    }

    res = fcache_get (&e, *fid, *ce);
    if (res) {
	volcache_free (ve);
	return res;
    }

    /*
     * Root nodes are a little bit special.  We keep track of
     * their parent in `parent' so that `..' can be handled
     * properly.
     */

    e->flags.vol_root  = TRUE;
    e->parent          = *parent;
    if (ve->parent == NULL) {
	ve->parent_fid = *parent;
	ve->mp_fid     = oldfid;
    }
    volcache_volref (ve, volume);
    fcache_release (e);
    volcache_free (ve);
    return 0;
}

/*
a2143 8
 *
 * Mount points are symbol links with the following contents:
 *
 * '#' | '%' [ cell ':' ] volume-name [ '.' ]
 *
 * This function tries to the minimal amount of work.  It always has
 * to fetch the attributes of `fid' and if it's a symbolic link, the
 * contents as well.
d2147 1
a2147 2
followmountpoint (VenusFid *fid, const VenusFid *parent, FCacheEntry *parent_e,
		  CredCacheEntry **ce)
d2149 5
d2155 13
a2167 1
     int ret;
d2169 4
a2172 9
     /*
      * Get the node for `fid' and verify that it's a symbolic link
      * with the correct bits.  Otherwise, just return the old
      * `fid' without any change.
      */

     ret = fcache_get (&e, *fid, *ce);
     if (ret)
	 return ret;
d2174 4
a2177 4
     ret = fcache_verify_attr (e, parent_e, NULL, *ce);
     if (ret) {
	 fcache_release(e);
	 return ret;
d2180 5
a2184 7
     e->parent = *parent;
     if (e->flags.mountp)
	 ret = resolve_mp (e, fid, ce);
     
     fcache_release(e);
     return ret;
}
d2186 49
a2234 3
/*
 * actually resolve a mount-point
 */
d2236 41
a2276 9
static int
resolve_mp (FCacheEntry *e, VenusFid *ret_fid, CredCacheEntry **ce)
{
    VenusFid fid = e->fid;
    int ret;
    fbuf the_fbuf;
    char *buf;
    int fd;
    u_int32_t length;
d2278 13
a2290 29
    assert (e->flags.fake_mp || e->flags.mountp);
    AssertExclLocked(&e->lock);

    ret = fcache_verify_data (e, *ce);
    if (ret)
	return ret;

    length = e->status.Length;

    fd = fcache_open_file (e, O_RDONLY);
    if (fd < 0)
	return errno;

    ret = fbuf_create (&the_fbuf, fd, length,
		       FBUF_READ|FBUF_WRITE|FBUF_PRIVATE);
    if (ret) {
	close (fd);
	return ret;
    }
    buf = fbuf_buf (&the_fbuf);

    ret = get_root_of_volume (&fid, &e->parent, e->volume, ce, buf, length);

    fbuf_end (&the_fbuf);
    close (fd);
    if (ret) 
	return ret;
    *ret_fid = fid;
    return 0;
d2301 1
d2303 1
a2303 1
    arla_log(ADEBVLOG, "(%d, %u, %u, %u)%s%s%s%s%s%s%s%s%s%s%s length: %ld",
d2305 1
a2305 14
	     e->fid.fid.Volume, e->fid.fid.Vnode, e->fid.fid.Unique,
	     e->flags.usedp?" used":"",
	     e->flags.attrp?" attr":"",
	     e->flags.datap?" data":"",
	     e->flags.attrusedp?" attrused":"",
	     e->flags.datausedp?" dataused":"",
	     e->flags.extradirp?" extradir":"",
	     e->flags.mountp?" mount":"",
	     e->flags.kernelp?" kernel":"",
	     e->flags.sentenced?" sentenced":"",
	     e->flags.silly?" silly":"",
	     e->flags.fake_mp ? " fake mp" : "",
	     e->flags.vol_root ? " vol root" : "",
	     e->status.Length);
d2315 1
a2315 1
fcache_status (void)
d2317 1
a2317 1
    arla_log(ADEBVLOG, "%lu (%lu-/%lu)-%lu) files"
d2319 1
a2319 1
	     usedvnodes, lowvnodes, current_vnodes, highvnodes,
d2321 1
a2321 16
    hashtabforeach (hashtab, print_entry, NULL);
}

/*
 *
 */

void
fcache_update_length (FCacheEntry *e, size_t len)
{
    AssertExclLocked(&e->lock);

    assert (len >= e->length || e->length - len <= usedbytes);

    usedbytes = usedbytes - e->length + len;
    e->length = len;
a2337 1
    fs_server_context context;
a2338 6
    opaque->val = NULL;
    opaque->len = 0;

    if (connected_mode != CONNECTED)
	return EINVAL;

d2345 9
a2353 29
    ret = ARLA_CALL_DEAD;

    for (conn = find_first_fs (dire, ce, &context);
	 conn != NULL;
	 conn = find_next_fs (&context, conn, host_downp (ret))) {

	ret = RXAFS_FetchACL (conn->connection, &fid.fid,
			      opaque, &status, &volsync);
	if (ret) {
	    free(opaque->val);
	    opaque->val = NULL;
	    opaque->len = 0;
	}

	if (!try_next_fs (ret, &fid))
	    break;
    }
    if (ret)
	arla_warn (ADEBFCACHE, ret, "FetchACL");

    if (ret == 0)
	update_entry (dire, &status, NULL, &volsync,
		      rx_HostOf(rx_PeerOf(conn->connection)),
		      ce->cred);
    else if (host_downp(ret))
	ret = ENETDOWN;

    free_fs_server_context (&context);
    fcache_release (dire);
a2358 3
 *
 * If the function return 0, ret_e is set to the dir-entry and must
 * be fcache_released().
d2364 1
a2364 2
       AFSOpaque *opaque,
       FCacheEntry **ret_e)
a2370 1
    fs_server_context context;
a2371 3
    if (connected_mode != CONNECTED)
	return EINVAL;

d2378 3
a2380 1
    ret = ARLA_CALL_DEAD;
d2382 6
a2387 26
    for (conn = find_first_fs (dire, ce, &context);
	 conn != NULL;
	 conn = find_next_fs (&context, conn, host_downp (ret))) {
	ret = RXAFS_StoreACL (conn->connection, &fid.fid,
			      opaque, &status, &volsync);
	if (!try_next_fs (ret, &fid))
	    break;
    }
    if (ret)
	arla_warn (ADEBFCACHE, ret, "StoreACL");

    if (ret == 0)
	update_entry (dire, &status, NULL, &volsync,
		      rx_HostOf(rx_PeerOf(conn->connection)),
		      ce->cred);
    else if (host_downp(ret))
	ret = ENETDOWN;

    free_fs_server_context (&context);

    if (ret == 0) {
	*ret_e = dire;
    } else {
	*ret_e = NULL;
	fcache_release (dire);
    }
a2404 1
    fs_server_context context;
a2405 3
    if (connected_mode != CONNECTED)
	return EINVAL;

d2412 10
a2421 21
    ret = ARLA_CALL_DEAD;

    for (conn = find_first_fs (dire, ce, &context);
	 conn != NULL;
	 conn = find_next_fs (&context, conn, host_downp (ret))) {
	ret = RXAFS_GetVolumeStatus (conn->connection, fid.fid.Volume,
				     volstat, volumename, offlinemsg,
				     motd);
	if (!try_next_fs (ret, &fid))
	    break;
    }
    if (ret)
	arla_warn (ADEBFCACHE, ret, "GetVolumeStatus");
    free_fs_server_context (&context);
    if (host_downp(ret))
	ret = ENETDOWN;
    if (ret == 0 && volumename[0] == '\0')
	volcache_getname (fid.fid.Volume, fid.Cell,
			  volumename, sizeof(volumename));

    fcache_release (dire);
a2438 1
    fs_server_context context;
a2439 3
    if (connected_mode != CONNECTED)
	return EINVAL;

d2446 10
a2455 19
    ret = ARLA_CALL_DEAD;

    for (conn = find_first_fs (dire, ce, &context);
	 conn != NULL;
	 conn = find_next_fs (&context, conn, host_downp (ret))) {
	ret = RXAFS_SetVolumeStatus (conn->connection, fid.fid.Volume,
				     volstat, volumename, offlinemsg,
				     motd);
	if (!try_next_fs (ret, &fid))
	    break;
    }
    if (ret) {
	if (host_downp(ret))
	    ret = ENETDOWN;
	arla_warn (ADEBFCACHE, ret, "SetVolumeStatus");
    }
    free_fs_server_context (&context);

    fcache_release (dire);
a2456 82
}

/*
 * Get `fbuf' from `centry' that is opened with openflags
 * `open_flags' and fbuf flags with `fbuf_flags'
 *
 * Assume that data is valid and `centry' is exclusive locked.
 */

int
fcache_get_fbuf (FCacheEntry *centry, int *fd, fbuf *fbuf,
		 int open_flags, int fbuf_flags)
{
    int ret;
    unsigned len;
    struct stat sb;

    AssertExclLocked(&centry->lock);

    *fd = fcache_open_file (centry, open_flags);
    if (*fd < 0)
	return errno;

    if (fstat (*fd, &sb)) {
	ret = errno;
	close (*fd);
	return ret;
    }

    len = sb.st_size;

    ret = fbuf_create (fbuf, *fd, len, fbuf_flags);
    if (ret) {
	close (*fd);
	return ret;
    }
    return 0;
}

/*
 *
 */

static Bool 
sum_node (List *list, Listitem *li, void *arg)
{
    u_long *a = (u_long *) arg;
    FCacheEntry *e = listdata (li);

    if (e->flags.attrp
	&& e->flags.datap
	&& !dynroot_is_dynrootp (e)) {

	*a += e->length;
    }
    
    return FALSE;
}


u_long
fcache_calculate_usage (void)
{
    u_long size = 0;

    listiter (lrulist, sum_node, &size);

    return size;
}

/*
 *
 */

const VenusFid *
fcache_realfid (const FCacheEntry *entry)
{
    if (entry->flags.vol_root
	|| (entry->fid.fid.Vnode == 1 && entry->fid.fid.Unique == 1))
	return &entry->volume->mp_fid;
    else
	return &entry->fid;
@


1.1.1.3
log
@Import of arla -current as of Aug 5 2003

ok todd@@ deraadt@@
@
text
@d2 1
a2 1
 * Copyright (c) 1995 - 2003 Kungliga Tekniska Högskolan
d40 1
a40 5
RCSID("$arla: fcache.c,v 1.417 2003/04/08 00:38:09 mattiasa Exp $") ;

#ifdef __CYGWIN32__
#include <windows.h>
#endif
d53 1
a53 1
resolve_mp (FCacheEntry **e, VenusFid *ret_fid, CredCacheEntry **ce);
d82 1
a82 2
static u_long highvnodes, lowvnodes, current_vnodes;
static int64_t highbytes, lowbytes;
d86 1
a86 30
static int64_t usedbytes, needbytes;
static u_long usedvnodes;

/* Map with recovered nodes */

static u_long maxrecovered;

static char *recovered_map;

static void
set_recovered(u_long index)
{
    char *p;
    u_long oldmax;

    if (index >= maxrecovered) {
	oldmax = maxrecovered;
	maxrecovered = (index + 16) * 2;
	p = realloc(recovered_map, maxrecovered);
	if (p == NULL) {
	    arla_errx(1, ADEBERROR, "fcache: realloc %lu recovered_map failed",
		      maxrecovered);
	}
	recovered_map = p;
	memset(recovered_map + oldmax, 0, maxrecovered - oldmax);
    }
    recovered_map[index] = 1;
}

#define IS_RECOVERED(index) (recovered_map[(index)])
d95 1
a95 1
Bool fprioritylevel = FPRIO_DEFAULT;
d138 1
a138 1
int64_t
d144 1
a144 1
int64_t
d150 1
a150 1
int64_t
d174 254
d449 2
a450 2
    FCacheEntry *f1 = (FCacheEntry*)a;
    FCacheEntry *f2 = (FCacheEntry*)b;
d452 4
a455 1
    return VenusFid_cmp(&f1->fid, &f2->fid);
d465 1
a465 1
    FCacheEntry *f = (FCacheEntry*)e;
d467 2
a468 2
    return f->fid.Cell + f->fid.fid.Volume + f->fid.fid.Vnode 
	+ f->fid.fid.Unique;
d493 1
a493 1
    hashtabdel(hashtab,entry);
d500 1
a500 91
char **sysnamelist = NULL;
int sysnamenum = 0;

/*
 *
 */

static void
fcache_poller_unref(FCacheEntry *e)
{
    AssertExclLocked(&e->lock);

    if (e->poll) {
	poller_remove(e->poll);
	e->poll = NULL;
    }
}

static void
fcache_poller_reref(FCacheEntry *e, ConnCacheEntry *conn)
{
    PollerEntry *pe = e->poll;
    AssertExclLocked(&e->lock);

    e->poll = poller_add_conn(conn);
    if (pe)
	poller_remove(pe);
}


/*
 *
 */

const char *
fcache_getdefsysname (void)
{
    if (sysnamenum == 0)
	return "fool-dont-remove-all-sysnames";
    return sysnamelist[0];
}

/*
 *
 */

int
fcache_setdefsysname (const char *sysname)
{
    if (sysnamenum == 0)
	return fcache_addsysname (sysname);
    free (sysnamelist[0]);
    sysnamelist[0] = estrdup (sysname);
    return 0;
}

/*
 *
 */

int
fcache_addsysname (const char *sysname)
{
    sysnamenum += 1;
    sysnamelist = erealloc (sysnamelist, 
			    sysnamenum * sizeof(char *));
    sysnamelist[sysnamenum - 1] = estrdup(sysname);
    return 0;
}

/*
 *
 */

int
fcache_removesysname (const char *sysname)
{
    int i;
    for (i = 0; i < sysnamenum; i++)
	if (strcmp (sysnamelist[i], sysname) == 0)
	    break;
    if (i == sysnamenum)
	return 1;
    free (sysnamelist[i]);
    for (;i < sysnamenum; i++)
	sysnamelist[i] = sysnamelist[i + 1];
    sysnamenum--;
    sysnamelist = erealloc (sysnamelist, 
			    sysnamenum * sizeof(char *));
    return 0;
}
a523 19
 * return kernel version of path to the cache file for `entry'.
 */

int
fcache_conv_file_name (FCacheEntry *entry, char *s, size_t len)
{
#ifdef __CYGWIN32__
    char buf[1024];
    GetCurrentDirectory(1024, buf);

    return snprintf (s, len, "%s\\%02X\\%02X",
		     buf, entry->index / 0x100, entry->index % 0x100);
#else
    return snprintf (s, len, "%02X/%02X",
		     entry->index / 0x100, entry->index % 0x100);
#endif
}

/*
d547 2
a548 1
    assert (entry->flags.extradirp &&
a567 4
#ifdef __CYGWIN32__
    return -1;
#endif

d573 1
a573 1
	memcpy (&fh, &handle->nnpfs_handle, sizeof(fh));
d584 2
a585 2
	vice_ioctl.in      = (caddr_t)&handle->nnpfs_handle;
	vice_ioctl.in_size = sizeof(handle->nnpfs_handle);
a605 22

#ifdef __CYGWIN32__
    {
	int ret, a, b;
	char buf[1024]; /* XXX */

	ret = sscanf(filename, "%02X/%02X", &a, &b);
	if (ret != 2)
	    return EINVAL;

	GetCurrentDirectory(1024, buf);
	
	/* XXX CACHEHANDLESIZE */
	ret = snprintf ((char *)handle, 80, "%s\\%02X\\%02X", buf, a, b);

	if (ret > 0)
	    handle->valid = 1;

	return ret;
    }
#endif

d613 1
a613 1
	    memcpy (&handle->nnpfs_handle, &fh, sizeof(fh));
d631 2
a632 2
	vice_ioctl.out      = (caddr_t)&handle->nnpfs_handle;
	vice_ioctl.out_size = sizeof(handle->nnpfs_handle);
d650 2
a651 2
static int
fcache_create_file (FCacheEntry *entry, int create)
a656 6
    int flags;

    flags = O_RDWR | O_BINARY;

    if (create)
	flags |= O_CREAT | O_TRUNC;
d659 1
a659 1
    fd = open (fname, flags, 0666);
d661 1
a661 1
	if (errno == ENOENT && create) {
d668 1
a668 1
	    fd = open (fname, flags, 0666);
d695 1
a695 1
	if (ret < 0 && (errno == EINVAL || errno == EPERM))
d713 1
a713 1
    assert (entry->flags.extradirp &&
d730 1
a730 1
    assert (entry->flags.usedp);
d761 1
a761 2
    entry->wanted_length = 0;
    entry->fetched_length = 0;
d772 1
a772 1
int
d775 1
a775 1
    uint32_t sec, usec;
a793 2
    assert (!entry->flags.kernelp);

a794 1
    assert(LockWaiters(&entry->lock) == 0);
d798 1
a798 5
    /* 
     * Throw data when there is data, length is a good test since the
     * node most not be used (in kernel) when we get here.
     */
    if (entry->length)
a805 2
    fcache_poller_unref(entry);

d814 1
a814 1
	if (conn_isalivep(conn)) {
d818 1
a818 4
	    if (conn_isalivep (conn))
		ret = RXAFS_GiveUpCallBacks(conn->connection, &fids, &cbs);
	    else
		ret = ENETDOWN;
a827 1
    assert_not_flag(entry,kernelp);
d841 1
a841 6
    do {
	node_count++;
    } while ((node_count < maxrecovered)
	     && IS_RECOVERED(node_count));
    
    return node_count;
a878 1
	    entries[i].poll = NULL;
d886 1
a886 1
	    fcache_create_file (&entries[i], 1);
d920 1
a920 1
    numnodes = NNPFS_GC_NODES_MAX_HANDLE;
d936 2
a937 2
		    (long)usedbytes, (long)lowbytes, (long)highbytes,
		    (long)needbytes);
a960 4
		if (entry->cleanergen == cleanerrun)
		    continue;
		entry->cleanergen = cleanerrun;

d964 2
a965 1
			|| needbytes > highbytes - usedbytes)
d970 1
a970 1
			&& !entry->flags.kernelp
a971 1

d981 4
a984 1
		    if (state == CL_FORCE && entry->flags.kernelp) {
d989 1
a989 1
			    nnpfs_send_message_gc_nodes (kernel_fd, cnt, fids);
d1007 1
a1007 1
			nnpfs_send_message_gc_nodes (kernel_fd, cnt, fids);
d1013 8
a1020 1
		    goto out;
a1024 1
		cleanerrun++;
d1032 2
a1033 2
		   "%ld (%ld-%ld) bytes "
		   "%ld needed bytes",
d1035 2
a1036 2
		   (long)usedbytes, (long)lowbytes, (long)highbytes,
		   (long)needbytes);
d1060 2
a1061 2
		    "(%ld needed, %ld outstanding, %ld highbytes)", 
		    (long)needed, (long)needbytes, (long)highbytes);
d1072 2
a1073 2
		    (long)(needed - (highbytes - usedbytes)), 
		    (long)usedbytes, (long)highbytes);
d1101 1
a1101 1
	arla_warnx(ADEBINVALIDATOR,
d1115 1
a1115 1
		arla_warnx (ADEBINVALIDATOR,
a1126 1
		fcache_poller_unref(entry);
d1155 2
a1156 2
    FCacheEntry *entry = NULL;
    Listitem *item;
d1158 2
a1159 2
    if (current_vnodes == usedvnodes)
	fcache_need_nodes();
d1161 1
a1161 1
    for (;;) {
d1163 36
a1198 39
	assert (!listemptyp (lrulist));
	for (item = listtail (lrulist);
	     item;
	     item = listprev (lrulist, item)) {

	    entry = (FCacheEntry *)listdata (item);
	    if (!entry->flags.usedp
		&& CheckLock(&entry->lock) == 0) {
		assert_not_flag(entry,kernelp);
		ObtainWriteLock (&entry->lock);
		listdel (lrulist, entry->lru_le);
		entry->lru_le = NULL;
		return entry;
	    }
	}

	assert (!listemptyp (lrulist));
	for (item = listtail (lrulist);
	     item;
	     item = listprev (lrulist, item)) {

	    entry = (FCacheEntry *)listdata (item);
	    if (entry->flags.usedp
		&& !entry->flags.attrusedp
		&& !entry->flags.kernelp
		&& entry->refcount == 0
		&& CheckLock(&entry->lock) == 0) {
		assert_not_flag(entry,kernelp);
		ObtainWriteLock (&entry->lock);
		listdel (lrulist, entry->lru_le);
		entry->lru_le = NULL;
		throw_entry (entry);
		return entry;
	    }
	}

	arla_warnx (ADEBFCACHE, "unlink_lru_entry: sleeping");
	fcache_need_nodes();
    }
d1224 3
a1226 1
struct fstore_context {
d1228 1
d1230 1
a1230 1
};
d1232 4
a1235 5
static int
fcache_store_entry (struct fcache_store *st, void *ptr)
{
    struct fstore_context *c;
    FCacheEntry *entry;
d1237 8
a1244 3
    c = (struct fstore_context *)ptr;
    if (c->item == NULL)		/* check if done ? */
	return STORE_DONE;
d1246 3
a1248 5
    entry = (FCacheEntry *)listdata (c->item);
    c->item = listprev (lrulist, c->item);

    if (!entry->flags.usedp)
	return STORE_SKIP;
d1250 5
a1254 23
    strlcpy(st->cell, cell_num2name(entry->fid.Cell), sizeof(st->cell));
    st->fid		= entry->fid.fid;
    st->refcount	= entry->refcount;
    st->length		= entry->length;
    st->fetched_length	= entry->fetched_length;
    st->volsync		= entry->volsync;
    st->status		= entry->status;
    st->anonaccess	= entry->anonaccess;
    st->index		= entry->index;
    st->flags.attrp	= entry->flags.attrp;
    st->flags.datap	= entry->length ? TRUE : FALSE;
    st->flags.extradirp = entry->flags.extradirp;
    st->flags.mountp    = entry->flags.mountp;
    st->flags.fake_mp   = entry->flags.fake_mp;
    st->flags.vol_root  = entry->flags.vol_root;
    strlcpy(st->parentcell, cell_num2name(entry->parent.Cell), 
	    sizeof(st->parentcell));
    st->parent		= entry->parent.fid;
    st->priority	= entry->priority;
    
    c->n++;
    return STORE_NEXT;
}
d1256 4
a1259 3
/*
 *
 */
d1261 4
a1264 9
int
fcache_store_state (void)
{
    struct fstore_context c;
    int ret;

    if (lrulist == NULL) {
	arla_warnx (ADEBFCACHE, "store_state: lrulist is NULL\n");
	return 0;
d1267 4
a1270 2
    c.item = listtail(lrulist);
    c.n = 0;
d1272 1
a1272 5
    ret = state_store_fcache("fcache", fcache_store_entry, &c);
    if (ret)
	arla_warn(ADEBWARN, ret, "failed to write fcache state");
    else
	arla_warnx (ADEBFCACHE, "wrote %u entries to fcache", c.n);
d1281 2
a1282 2
static int
fcache_recover_entry (struct fcache_store *st, void *ptr)
d1284 3
d1288 1
a1288 1
    unsigned *n = (unsigned *)ptr;
d1290 18
a1307 6
    CredCacheEntry *ce;
    FCacheEntry *e;
    int i;
    VolCacheEntry *vol;
    int res;
    int32_t cellid;
d1309 8
a1316 17
    cellid = cell_name2num(st->cell);
    assert (cellid != -1);
    
    ce = cred_get (cellid, 0, 0);
    assert (ce != NULL);
    
    res = volcache_getbyid (st->fid.Volume, cellid, ce, &vol, NULL);
    cred_free (ce);
    if (res)
	return 0;
    assert(vol);
    
    e = calloc(1, sizeof(FCacheEntry));
    e->invalid_ptr = -1;
    Lock_Init(&e->lock);
    ObtainWriteLock(&e->lock);
    
d1318 2
a1319 48
    e->fid.Cell = cellid;
    e->fid.fid  = st->fid;
    e->host     = 0;
    e->status   = st->status;
    e->length   = st->length;
    e->fetched_length = st->fetched_length;
    e->callback = broken_callback;
    e->volsync  = st->volsync;
    e->refcount = st->refcount;
    
    /* Better not restore the rights. pags don't have to be the same */
    for (i = 0; i < NACCESS; ++i) {
	e->acccache[i].cred = ARLA_NO_AUTH_CRED;
	e->acccache[i].access = ANONE;
    }
    
    e->anonaccess = st->anonaccess;
    e->index      = st->index;
    fcache_create_file(e, 0);
    set_recovered(e->index);
    e->flags.usedp = TRUE;
    e->flags.attrp = st->flags.attrp;
    /* st->flags.datap */
    e->flags.attrusedp = FALSE;
    e->flags.datausedp = FALSE;
    e->flags.kernelp   = FALSE;
    e->flags.extradirp = st->flags.extradirp;
    e->flags.mountp    = st->flags.mountp;
    e->flags.fake_mp   = st->flags.fake_mp;
    e->flags.vol_root  = st->flags.vol_root;
    e->flags.sentenced = FALSE;
    e->flags.silly 	   = FALSE;
    e->tokens	       = 0;
    e->parent.Cell = cell_name2num(st->parentcell);
    assert(e->parent.Cell != -1);
    e->parent.fid = st->parent;
    e->priority = st->priority;
    e->hits = 0;
    e->cleanergen = 0;
    e->lru_le = listaddhead (lrulist, e);
    assert(e->lru_le);
    e->volume = vol;
    hashtabadd (hashtab, e);
    if (e->length)
	usedbytes += e->length;
    ReleaseWriteLock (&e->lock);
    
    (*n)++;
d1321 5
a1325 2
    return 0;
}
d1327 2
a1328 3
/*
 *
 */
d1330 1
a1330 7
static void
fcache_recover_state (void)
{
    unsigned n;

    n = 0;
    state_recover_fcache("fcache", fcache_recover_entry, &n);
d1332 44
d1387 1
a1387 1
findaccess (nnpfs_pag_t cred, AccessEntry *ae, AccessEntry **pos)
d1389 1
a1389 12
    int i;

    for(i = 0; i < NACCESS ; ++i)
	if(ae[i].cred == cred) {
	    *pos = &ae[i];
	    return TRUE;
	}

    i = rand() % NACCESS;
    *pos = &ae[i];
    return FALSE;
}
d1391 9
a1399 12
/*
 *
 */


static int
fs_rtt_cmp (const void *v1, const void *v2)
{
    struct fs_server_entry *e1 = (struct fs_server_entry *)v1;
    struct fs_server_entry *e2 = (struct fs_server_entry *)v2;
    
    return conn_rtt_cmp(&e1->conn, &e2->conn);
a1411 10
static long
find_partition (fs_server_context *context)
{
    int i = context->conns[context->i - 1].ve_ent;

    if (i < 0 || i >= context->ve->entry.nServers)
	return 0;
    return context->ve->entry.serverPartition[i];
}

d1420 1
a1420 1
	      int error)
d1422 2
a1423 11
    if (error) {
	if (host_downp(error))
	    conn_dead (prev_conn);
	if (volume_downp(error))
	    volcache_mark_down (context->ve, 
				context->conns[context->i - 1].ve_ent,
				error);
    } else if (prev_conn) {
	assert(prev_conn == context->conns[context->i - 1].conn);
	volcache_reliable_el(context->ve, context->conns[context->i - 1].ve_ent);
    }
d1426 1
a1426 1
	return context->conns[context->i++].conn;
d1441 1
a1441 4
	conn_free (context->conns[i].conn);

    if (context->ve)
	volcache_process_marks(context->ve);
d1445 3
a1447 2
 * Find the the file servers housing the volume for `e' and store it
 * in the `context'.
d1450 4
a1453 4
int
init_fs_context (FCacheEntry *e,
		 CredCacheEntry *ce,
		 fs_server_context *context)
d1465 2
d1468 1
a1468 1
				ce, &e->volume, NULL);
d1470 1
a1470 1
	    return ret;
d1476 1
a1476 1
	return ret;
d1483 1
a1483 1
	return ENOENT;
d1497 2
a1498 6
	    if (!conn_isalivep (conn))
		conn->rtt = INT_MAX/2 ;
	    else if (!volcache_reliablep_el(ve, i))
		conn->rtt = INT_MAX/4;
	    else
		conn->rtt = rx_PeerOf(conn->connection)->srtt
d1500 3
a1502 3
	    context->conns[num_clones].conn = conn;
	    context->conns[num_clones].ve_ent = i;
	    ++num_clones;
a1505 5
    if (num_clones == 0)
	return ENOENT;
    
    context->ve = ve;

d1507 1
a1507 1
	   fs_rtt_cmp);
d1512 1
a1512 11
    return 0;
}

/*
 * Find the first file server housing the volume for `e'.
 */

ConnCacheEntry *
find_first_fs (fs_server_context *context)
{
    return find_next_fs (context, NULL, 0);
d1523 2
a1524 2
	     int64_t alowbytes,
	     int64_t ahighbytes,
a1535 1

d1538 1
a1538 1
    node_count     = 0;
d1543 1
d1586 2
a1587 2
	      int64_t alowbytes,
	      int64_t ahighbytes)
a1666 1
	fcache_poller_unref(e);
d1668 1
a1668 1

a1670 4
	else
	    e->tokens = 0;
	if (e->status.FileType == TYPE_DIR && e->length)
	    throw_data(e);
d1729 1
a1729 1
    nnpfs_pag_t pag;
d1752 1
a1752 1
		    install_attr (e, FCACHE2NNPFSNODE_NO_LENGTH);
d1766 1
a1766 1
fcache_purge_cred (nnpfs_pag_t pag, int32_t cell)
a1830 28

/*
 * If `ptr' is a mountpoint, mark it as stale.
 */

static Bool
invalidate_mp (void *ptr, void *arg)
{
    FCacheEntry *e = (FCacheEntry *)ptr;
    AFSCallBack broken_callback = {0, 0, CBDROPPED};

    if (e->flags.mountp)
	stale (e, broken_callback);
    return FALSE;


}

/*
 * Invalidate all mountpoints to force the to be reread.
 */

void
fcache_invalidate_mp (void)
{
    hashtabforeach (hashtab, invalidate_mp, NULL);
}

d1906 2
a1907 2
	      ConnCacheEntry *conn,
	      nnpfs_pag_t cred)
d1930 1
a1930 8

    if (conn) {
	fcache_poller_reref(entry, conn);
	entry->host     = rx_HostOf(rx_PeerOf(conn->connection));
    } else {
	fcache_poller_unref(entry);
	entry->host = 0;
    }
d1949 2
a1950 2
		   ConnCacheEntry *conn,
		   nnpfs_pag_t cred)
d1952 2
a1953 4
    if (entry->fetched_length
	&& entry->status.DataVersion != status->DataVersion
	&& !entry->flags.datausedp) 
    {
d1955 1
a1955 1
	entry->tokens &= ~(NNPFS_DATA_R|NNPFS_DATA_W);
d1959 1
a1959 1
		  conn, cred);
d1961 1
a1961 1
    entry->tokens |= NNPFS_ATTR_R;
a1969 41
static int
giveup_all_callbacks (uint32_t cell, uint32_t host, void *arg)
{
    CredCacheEntry *ce;	
    ConnCacheEntry *conn;
    Listitem *item;
    int ret;

    ce = cred_get (cell, 0, CRED_ANY);
    assert (ce != NULL);
    
    conn = conn_get (cell, host, afsport, FS_SERVICE_ID, fs_probe, ce);
    cred_free (ce);

    if (!conn_isalivep (conn))
	goto out;

    ret = RXAFS_GiveUpAllCallBacks(conn->connection);
    if (ret == 0) {
	for (item = listtail(lrulist);
	     item != NULL;
	     item = listprev(lrulist, item)) {
	    FCacheEntry *entry = (FCacheEntry *)listdata(item);
	    
	    if (entry->host == host)
		entry->flags.attrp = FALSE;
	}
    } else if (ret != RXGEN_OPCODE) {
	struct in_addr in_addr;

	in_addr.s_addr = rx_HostOf(rx_PeerOf(conn->connection));
	arla_warn (ADEBWARN, ret, "GiveUpAllCallBacks %s",
		   inet_ntoa (in_addr));
    }

 out:
    conn_free (conn);

    return 0;
}

a1974 2
    poller_foreach(giveup_all_callbacks, NULL);

d2004 2
a2005 8
		if (ret) {
		    struct in_addr in_addr;

		    in_addr.s_addr = rx_HostOf(rx_PeerOf(conn->connection));
		    arla_warn (ADEBFCACHE, ret, "RXAFS_GiveUpCallBacks %s",
			       inet_ntoa (in_addr));
		} else
		    entry->flags.attrp = FALSE;
d2017 1
a2017 1
fcache_reobtain_callbacks (struct nnpfs_cred *cred)
a2026 1
	ObtainWriteLock (&entry->lock);
d2037 1
d2039 1
a2039 1
	    ce = cred_get (entry->fid.Cell, cred->pag, CRED_ANY);
a2043 2
	    if (!conn_isalivep(conn))
		goto out;
d2049 1
a2049 1
				    entry->fid.Cell, ce, &vol, NULL);
d2052 1
d2054 14
a2067 12
	    ret = RXAFS_FetchStatus (conn->connection,
				     &entry->fid.fid,
				     &status,
				     &callback,
				     &volsync);
	    if (ret)
		arla_warn (ADEBFCACHE, ret, "RXAFS_FetchStatus");
	    else {
		update_attr_entry (entry, &status, &callback, &volsync,
				   conn, ce->cred);
		if (entry->flags.kernelp)
		    break_callback (entry);
a2068 5
	    fcache_counter.fetch_attr++;
	out:
	    if (conn)
		conn_free (conn);
	    cred_free (ce);
a2069 1
	ReleaseWriteLock (&entry->lock);
a2081 1
#ifdef KERBEROS
a2082 1
#endif
d2099 1
a2099 1
	if (fid && !volcache_reliablep (fid->fid.Volume, fid->Cell))
a2109 25
 * If the whole file is fetched as we last saw it, lets write down
 * the whole file to the fileserver. If the file is shrinking,
 * make sure we don't cache non-existing bytes.
 */

static size_t
new_fetched_length(FCacheEntry *entry, size_t cache_file_size)
{
    size_t have_len;

    AssertExclLocked(&entry->lock);

    if (entry->fetched_length == entry->status.Length)
	have_len = cache_file_size;
    else {
	have_len = entry->fetched_length;
	/* have file shrinked ? */
	if (have_len > cache_file_size)
	    have_len = cache_file_size;
    }

    return have_len;
}

/*
d2126 1
a2131 1
    int ret;
d2137 6
a2142 3
    ret = init_fs_context(entry, ce, ret_context);
    if (ret)
	return ret;
d2144 1
a2144 1
    for (conn = find_first_fs (ret_context);
d2146 1
a2146 1
	 conn = find_next_fs (ret_context, conn, ret)) {
a2154 1
			  find_partition(ret_context),
a2160 1
	arla_warn (ADEBFCACHE, ret, "fetch-status");
d2163 1
d2171 2
a2172 1
		       conn, ce->cred);
d2208 1
a2208 2
read_data (FCacheEntry *entry, ConnCacheEntry *conn, CredCacheEntry *ce,
	   long partition)
d2212 1
a2212 2
    uint32_t wanted_length, sizefs, nbytes = 0;
    int32_t sizediff;
d2228 3
a2230 19
    /* are we already done ? */
    if (entry->wanted_length <= entry->fetched_length) {
	ret = 0;
	goto out;
    }

    /* figure out how much more then we need we want to fetch */
    wanted_length = stats_fetch_round(conn, partition, entry->wanted_length);
    if (wanted_length > entry->status.Length)
	wanted_length = entry->status.Length;

    /* we need more space ? */
    if (wanted_length > entry->length)
	nbytes = wanted_length - entry->length;

    if (usedbytes + nbytes > highbytes) {
	ret = fcache_need_bytes (nbytes);
	if (ret)
	    goto out;
d2233 1
a2233 1
    if (usedbytes + nbytes > highbytes) {
d2235 2
a2236 2
		    "(file-length: %d need bytes: %ld usedbytes: %ld)",
		    entry->status.Length, (long)nbytes, (long)usedbytes);
a2240 1
    /* now go talk to the world */
d2249 2
a2250 2
    ret = StartRXAFS_FetchData (call, &entry->fid.fid, entry->fetched_length,
				wanted_length - entry->fetched_length);
a2252 1
	rx_EndCall(call,ret);
d2258 1
a2258 1
	ret = conv_to_arla_errno(rx_GetCallError(call));
d2274 1
a2274 1
    if (ftruncate(fd, entry->status.Length) < 0) {
d2281 1
a2281 1
    ret = copyrx2fd (call, fd, entry->fetched_length, sizefs);
d2298 1
a2298 6
		      partition, STATISTICS_REQTYPE_FETCHDATA, sizefs);

    entry->fetched_length += sizefs;
    sizediff = entry->fetched_length - entry->length;
    entry->length = entry->fetched_length;
    usedbytes += sizediff;
d2303 4
a2306 1
		  conn, ce->cred);
d2308 2
a2309 1
    entry->tokens |= NNPFS_DATA_R | NNPFS_DATA_W | NNPFS_OPEN_NR | NNPFS_OPEN_NW;
d2311 1
a2311 1
 out:
d2325 117
d2444 2
a2445 3
    int ret;
    uint32_t sizefs;
    size_t have_len;
a2446 1
    struct stat statinfo;
a2449 1
    struct collect_stat collectstat;
a2452 4
    /* Don't write data to deleted files */
    if (entry->flags.silly)
	return 0;

d2456 1
a2456 1
	arla_warn (ADEBFCACHE, ret, "open cache file %u",
d2461 1
a2461 1
    if (fstat (fd, &statinfo) < 0) {
d2463 1
a2464 2
	arla_warn (ADEBFCACHE, ret, "stat cache file %u",
		   (unsigned)entry->index);
d2467 1
a2467 89
    sizefs = statinfo.st_size;

    have_len = new_fetched_length(entry, sizefs);
    if (entry->status.Length < have_len)
	entry->status.Length = have_len;

    /*
     *
     */

    fcache_update_length (entry, have_len, have_len);
    if (connected_mode != CONNECTED) {
	close (fd);
	return 0;
    }

    ret = init_fs_context(entry, ce, &context);
    if (ret)
	return ret;

    for (conn = find_first_fs (&context);
	 conn != NULL;
	 conn = find_next_fs (&context, conn, ret)) {

	call = rx_NewCall (conn->connection);
	if (call == NULL) {
	    arla_warnx (ADEBMISC, "rx_NewCall failed");
	    ret = ENOMEM;
	    break;
	}

	collectstats_start(&collectstat);
	ret = StartRXAFS_StoreData (call, &entry->fid.fid,
				    storestatus,
				    0,
				    have_len,
				    entry->status.Length);
	if (host_downp(ret)) {
	    rx_EndCall(call, ret);
	    continue;
	} else if (ret) {
	    arla_warn (ADEBFCACHE, ret, "store-data");
	    rx_EndCall(call, 0);
	    break;
	}

	ret = copyfd2rx (fd, call, 0, have_len);
	if (ret) {
	    rx_EndCall(call, ret);
	    arla_warn (ADEBFCACHE, ret, "copyfd2rx");
	    break;
	}

	ret = EndRXAFS_StoreData (call,
				  &status,
				  &volsync);
	if (ret) {
	    rx_EndCall (call, ret);
	    arla_warnx (ADEBFCACHE, "EndRXAFS_StoreData");
	    break;
	}

	ret = rx_EndCall (call, 0);
	if (ret) {
	    arla_warn (ADEBFCACHE, ret, "rx_EndCall");
	}
	collectstats_stop(&collectstat, entry, conn,
			  find_partition(&context),
			  STATISTICS_REQTYPE_STOREDATA, sizefs);
	break;
    }

    if (conn != NULL) {
	if (ret == 0) {
	    fcache_counter.store_data++;
	    update_entry (entry, &status, NULL, &volsync,
			  conn, ce->cred);
	} else {
	    ftruncate (fd, 0);
	    usedbytes -= entry->length; 
	    entry->length = 0;
	    entry->wanted_length = 0;
	    entry->fetched_length = 0;
	}
    }
    if (host_downp(ret))
	ret = ENETDOWN;
    free_fs_server_context (&context);
    AssertExclLocked(&entry->lock);
a2468 2
    return ret;
}
d2470 2
a2471 15
/*
 * Truncate the file in `entry' to `size' bytes.
 */

int
truncate_file (FCacheEntry *entry, off_t size, 
	       AFSStoreStatus *storestatus, CredCacheEntry *ce)
{
    fs_server_context context;
    ConnCacheEntry *conn;
    struct rx_call *call;
    AFSFetchStatus status;
    AFSVolSync volsync;
    size_t have_len;
    int ret;
d2473 1
a2473 1
    AssertExclLocked(&entry->lock);
d2478 2
a2479 7
    have_len = new_fetched_length(entry, size);

    ret = init_fs_context(entry, ce, &context);
    if (ret)
	return ret;

    for (conn = find_first_fs (&context);
d2481 1
a2481 1
	 conn = find_next_fs (&context, conn, ret)) {
d2490 1
d2493 1
a2493 1
				    storestatus,
d2506 1
d2517 1
a2517 1
	if (ret)
d2519 1
a2519 1

a2523 21
	int fd;

	fd = fcache_open_file (entry, O_RDWR);
	if (fd < 0) {
	    ret = errno;
	    arla_warn (ADEBFCACHE, ret, "open fache file %u",
		       (unsigned)entry->index);
	    return ret;
	}
	
	if(ftruncate (fd, size) < 0) {
	    ret = errno;
	    arla_warn (ADEBFCACHE, ret, "ftruncate %ld", (long)size);
	    close (fd);
	    return ret;
	}
	
	close (fd);
	
	fcache_update_length (entry, size, have_len);
	
d2526 2
a2527 1
		      conn, ce->cred);
a2528 3

    free_fs_server_context (&context);

d2531 1
a2531 1

d2545 1
a2545 2
    ConnCacheEntry *conn = NULL;
    int ret;
d2556 1
d2558 1
a2558 1
	struct collect_stat collectstat;
d2560 3
a2562 3
	ret = init_fs_context(entry, ce, &context);
	if (ret)
	    return ret;
d2564 1
a2564 3
	for (conn = find_first_fs (&context);
	     conn != NULL;
	     conn = find_next_fs (&context, conn, ret)) {
a2565 1
	    collectstats_start(&collectstat);
a2575 1
		conn = NULL;
a2577 1
	    conn_ref(conn);
a2579 7

	if (ret == 0)
	    collectstats_stop(&collectstat, entry, conn,
			      find_partition(&context),
			      STATISTICS_REQTYPE_STORESTATUS, 1);


a2585 1
	update_entry (entry, &status, NULL, &volsync, conn, ce->cred);
d2587 1
a2588 2
	assert (conn == NULL);

a2601 1
	ret = 0;
d2604 1
a2604 3
 out:
    if (conn)
	conn_free(conn);
d2620 1
a2620 2
    ConnCacheEntry *conn = NULL;
    int ret;
d2627 1
d2632 1
d2635 1
a2635 5
	ret = init_fs_context(dir_entry, ce, &context);
	if (ret)
	    return ret;

	for (conn = find_first_fs (&context);
d2637 3
a2639 1
	     conn = find_next_fs (&context, conn, ret)) {
a2654 1
		conn = NULL;
a2656 1
	    conn_ref(conn);
a2658 1

d2667 1
a2667 2
		      conn, ce->cred);

a2670 4
	assert(conn == NULL);

	ret = 0;

d2693 6
a2698 4
	fetch_attr->DataVersionHigh  = 0;
	fetch_attr->LockCount        = 0;
	fetch_attr->LengthHigh       = 0;
	fetch_attr->ErrorCode        = 0;
d2711 1
a2711 1
		  conn, ce->cred);
d2735 2
a2736 1
    child_entry->tokens |= NNPFS_ATTR_R | NNPFS_DATA_R | NNPFS_DATA_W;
d2740 1
a2740 4
 out:
    if (conn)
	conn_free(conn);

d2756 1
a2756 2
    ConnCacheEntry *conn = NULL;
    int ret;
d2762 1
a2762 1

d2767 1
d2770 3
a2772 3
	ret = init_fs_context(dir_entry, ce, &context);
	if (ret)
	    return ret;
d2774 1
a2774 3
	for (conn = find_first_fs (&context);
	     conn != NULL;
	     conn = find_next_fs (&context, conn, ret)) {
a2790 1
		conn = NULL;
a2792 1
	    conn_ref(conn);
d2803 1
a2803 1
		      conn, ce->cred);
a2806 4
	ret = 0;

	assert(conn == NULL);

d2829 6
a2834 4
	fetch_attr->DataVersionHigh  = 0;
	fetch_attr->LockCount        = 0;
	fetch_attr->LengthHigh       = 0;
	fetch_attr->ErrorCode        = 0;
d2846 2
a2847 1
    assert(child_entry->length == 0);
d2850 1
a2850 1
		  conn, ce->cred);
d2862 2
a2863 1
    child_entry->tokens |= NNPFS_ATTR_R | NNPFS_DATA_R | NNPFS_DATA_W;
d2867 1
a2867 3
 out:
    if (conn)
	conn_free(conn);
d2886 1
a2886 1
    int ret;
d2892 1
d2900 3
a2902 3
    ret = init_fs_context(dir_entry, ce, &context);
    if (ret)
	return ret;
d2904 1
a2904 3
    for (conn = find_first_fs (&context);
	 conn != NULL;
	 conn = find_next_fs (&context, conn, ret)) {
a2919 1
	    conn = NULL;
a2921 1
	conn_ref(conn);
d2932 1
a2932 1
		  conn, ce->cred);
d2944 1
a2944 1
		  conn, ce->cred);
d2953 1
a2953 1
    child_entry->tokens |= NNPFS_ATTR_R;
d2957 1
a2957 3
 out:
    if (conn)
	conn_free(conn);
d2972 2
a2973 2
    ConnCacheEntry *conn = NULL;
    int ret;
d2977 1
d2985 3
a2987 3
    ret = init_fs_context(dir_entry, ce, &context);
    if (ret)
	return ret;
d2989 1
a2989 3
    for (conn = find_first_fs (&context);
	 conn != NULL;
	 conn = find_next_fs (&context, conn, ret)) {
a3002 1
	    conn = NULL;
a3004 1
	conn_ref(conn);
d3015 1
a3015 1
		  conn, ce->cred);
d3018 1
a3018 1
		  conn, ce->cred);
d3020 1
a3020 3
 out:
    if (conn)
	conn_free(conn);
d3032 1
a3032 1
    int ret;
d3036 1
d3041 2
a3042 1
    if (connected_mode == CONNECTED) {
d3044 3
a3046 3
	ret = init_fs_context(dir_entry, ce, &context);
	if (ret)
	    return ret;
d3048 1
a3048 24
	for (conn = find_first_fs (&context);
	     conn != NULL;
	     conn = find_next_fs (&context, conn, ret)) {
	    
	    ret = RXAFS_RemoveFile (conn->connection,
				    &dir_entry->fid.fid,
				    name,
				    &status,
				    &volsync);
	    if (host_downp(ret)) {
		continue;
	    } else if (ret) {
		free_fs_server_context (&context);
		arla_warn (ADEBFCACHE, ret, "RemoveFile");
		conn = NULL;
		goto out;
	    }
	    conn_ref(conn);
	    break;
	}
	free_fs_server_context (&context);
	
	if (host_downp(ret))
	    ret = ENETDOWN;
d3050 10
a3059 12
    } else {
	fbuf the_fbuf;
	VenusFid child_fid;
	int fd;

	status = dir_entry->status;
	
	conn = NULL;

	ret = fcache_get_fbuf (dir_entry, &fd, &the_fbuf,
			       O_RDONLY, FBUF_READ|FBUF_SHARED);
	if (ret)
d3061 4
a3064 5
	
	ret = fdir_lookup(&the_fbuf, &dir_entry->fid, name, &child_fid);
	if (ret == 0) {
	    FCacheEntry *child_entry = NULL;
	    uint32_t disco_id = 0;
d3066 3
a3068 16
	    ret = fcache_find(&child_entry, child_fid);
	    if (ret == 0)
		disco_id = child_entry->disco_id;

	    disco_id = disco_unlink(&dir_entry->fid, &child_fid,
				    name, disco_id);

	    if (child_entry) {
		child_entry->disco_id = disco_id;
		fcache_release(child_entry);
	    }
	    ret = 0;
	}
	    
	fbuf_end (&the_fbuf);
	close (fd);
d3071 2
a3072 3
    if (ret == 0)
	update_entry (dir_entry, &status, NULL, &volsync,
		      conn, ce->cred);
d3074 1
a3074 3
 out:
    if (conn)
	conn_free(conn);
d3088 1
a3088 1
    int ret;
d3092 1
d3100 3
a3102 3
    ret = init_fs_context(dir_entry, ce, &context);
    if (ret)
	return ret;
d3104 1
a3104 3
    for (conn = find_first_fs (&context);
	 conn != NULL;
	 conn = find_next_fs (&context, conn, ret)) {
a3115 1
	    conn = NULL;
a3117 1
	conn_ref(conn);
d3128 1
a3128 1
		  conn, ce->cred);
d3130 1
a3130 3
 out:
    if (conn)
	conn_free(conn);
d3150 1
d3159 3
a3161 3
    ret = init_fs_context(old_dir, ce, &context);
    if (ret)
	return ret;
d3163 1
a3163 3
    for (conn = find_first_fs (&context);
	 conn != NULL;
	 conn = find_next_fs (&context, conn, ret)) {
a3177 1
	    conn = NULL;
a3179 1
	conn_ref(conn);
d3190 1
a3190 1
		  conn, ce->cred);
d3193 1
a3193 1
		  conn, ce->cred);
d3195 1
a3195 3
 out:
    if (conn)
	conn_free(conn);
d3208 46
a3253 20
    VolCacheEntry *ve;
    VenusFid fid;
    const char *root_volume = volcache_get_rootvolume ();
    int ret;
    const char *this_cell = cell_getthiscell ();
    int32_t this_cell_id;

    if (dynroot_enablep()) {
	this_cell = "dynroot";
	this_cell_id = dynroot_cellid();
    } else {
	this_cell_id = cell_name2num (this_cell);
	if (this_cell_id == -1)
	    arla_errx (1, ADEBERROR, "cell %s does not exist", this_cell);
    }

    ret = volcache_getbyname (root_volume, this_cell_id, ce, &ve, NULL);
    if (ret) {
	arla_warn (ADEBWARN, ret,
		   "Cannot find the root volume (%s) in cell %s",
d3255 2
a3256 17
	return ret;
    }

    fid.Cell = this_cell_id;
    if (ve->entry.flags & VLF_ROEXISTS) {
	fid.fid.Volume = ve->entry.volumeId[ROVOL];
    } else if (ve->entry.flags & VLF_RWEXISTS) {
	arla_warnx(ADEBERROR,
		   "getroot: %s in cell %s is missing a RO clone, not good",
		   root_volume, this_cell);
	fid.fid.Volume = ve->entry.volumeId[RWVOL];
    } else {
	arla_errx(1, ADEBERROR,
		  "getroot: %s in cell %s has no RW or RO clone?",
		  root_volume, this_cell);
    }
    fid.fid.Vnode = fid.fid.Unique = 1;
d3258 1
a3258 1
    volcache_free (ve);
d3260 2
a3261 2
    *res = fid;
    return 0;
d3271 1
a3271 1
    int i;
d3273 5
a3277 5
    for (i = RWVOL; i <= BACKVOL; ++i)
	if (ve->entry.volumeId[i] == volid)
	    return i;
    assert (FALSE);
    return -1; /* NOT REACHED */
d3303 2
a3304 2
    VolCacheEntry *vol;
    int i, error;
a3314 7
    error = volcache_getbyid (fid.fid.Volume, fid.Cell, ce, &vol, NULL);
    if (error) {
	if (connected_mode == DISCONNECTED && error == ENOENT)
	    return ENETDOWN;
	return error;
    }

a3334 2
    e->wanted_length   = 0;
    e->fetched_length  = 0;
d3344 1
d3360 1
a3360 1
    e->volume	       = vol;
d3367 13
d3444 3
a3446 3
    struct nnpfs_message_installnode node;
    struct nnpfs_message_installattr attr;
} nnpfs_message_install_node_attr;
d3448 1
a3448 1
static int
d3458 1
a3458 1
	return 0;
d3462 1
a3462 1
	return 0;
d3476 1
a3476 1
	return 0;
d3494 1
a3494 1
	return 0;
d3501 1
a3501 1
	    return 0;
d3508 1
a3508 3
    bs->len++;

    return 0;
d3532 1
a3532 1
    ConnCacheEntry *conn = NULL;
d3542 1
a3542 1
    struct collect_stat collectstat;
d3549 1
a3549 1
    if (parent_entry->length == 0) {
d3590 1
a3590 2
			parent_entry->fid,
			NULL);
d3628 1
a3628 5
    ret = init_fs_context(parent_entry, ce, &context);
    if (ret)
	return ret;

    for (conn = find_first_fs (&context);
d3630 1
a3630 1
	 conn = find_next_fs (&context, conn, ret)) {
a3635 1
	collectstats_start(&collectstat);
a3636 3
	collectstats_stop(&collectstat, parent_entry, conn,
			  find_partition(&context),
			  STATISTICS_REQTYPE_BULKSTATUS, fids.len);
d3641 2
a3642 11

	if (host_downp(ret)) {
	    continue;
	} else if (ret) {
	    free_fs_server_context(&context);
	    arla_warn(ADEBFCACHE, ret, "BulkStatus");
	    conn = NULL;
	    goto out_names;
	}
	conn_ref(conn);
	break;
d3645 2
a3663 1
	VenusFid fid;
a3666 1
	fid.Cell = parent_entry->fid.Cell;
d3668 1
a3668 4

	    fid.fid = fids.val[i];
	    
	    if (VenusFid_cmp(prefered_fid, &fid) == 0) {
d3671 5
d3688 1
a3688 1
			       conn,
d3702 3
a3704 3
	nnpfs_message_install_node_attr msg[AFSCBMAX];
	struct nnpfs_msg_node *node;
	nnpfs_handle *parent;
a3710 1
	    u_int tokens;
d3714 1
a3714 1
	    if (VenusFid_cmp(prefered_fid, &fid) == 0) {
d3716 1
a3722 2
		if (ret)
		    break;
d3724 2
d3727 28
d3756 20
a3775 46
	    arla_warnx (ADEBFCACHE, "installing %d.%d.%d\n",
			e->fid.fid.Volume,
			e->fid.fid.Vnode,
			e->fid.fid.Unique);
	    assert_flag(e,kernelp);
	    e->flags.attrusedp 	= TRUE;
	    
	    /*
	     * Its its already installed, just update with installattr
	     */
	    
	    e->tokens			|= NNPFS_ATTR_R;
	    tokens				= e->tokens;
	    if (!e->flags.kernelp || !e->flags.datausedp)
		tokens			&= ~NNPFS_DATA_MASK;
	    
	    if (e->flags.kernelp) {
		msg[j].attr.header.opcode	= NNPFS_MSG_INSTALLATTR;
		node			= &msg[j].attr.node;
		parent			= NULL;
	    } else {
		msg[j].node.header.opcode	= NNPFS_MSG_INSTALLNODE;
		node			= &msg[j].node.node;
		parent			= &msg[j].node.parent_handle;
		e->flags.kernelp		= TRUE;
		strlcpy (msg[j].node.name, bs.names[i],
			 sizeof(msg[j].node.name));
	    }
	    node->tokens = tokens;
	    
	    /*
	     * Don't install symlink since they might be
	     * mount-points.
	     */
	    
	    if (e->status.FileType != TYPE_LINK) {
		fcacheentry2nnpfsnode (&e->fid,
				       &e->fid,
				       &stats.val[i],
				       node, 
				       parent_entry->acccache,
				       FCACHE2NNPFSNODE_ALL);
		
		if (parent)
		    *parent = *(struct nnpfs_handle*) &parent_entry->fid;
		j++;
a3776 2
	    if (prefered_entry != e)
		fcache_release(e);
d3782 1
a3782 1
	
d3784 4
a3787 4
	    ret = nnpfs_send_message_multiple_list (kernel_fd,
						    (struct nnpfs_message_header *) msg,
						    sizeof (msg[0]),
						    j);
d3792 1
a3792 1
    
d3797 1
a3797 1
    for (i = 0 ; i < bs.len && ret == 0; i++)
d3799 1
a3799 3

    if (conn)
	conn_free(conn);
d3818 1
a3818 1
fcache_verify_attr (FCacheEntry *entry, FCacheEntry *parent,
d3821 1
d3823 1
d3843 1
a3843 1
	entry->tokens |= NNPFS_ATTR_R;
a3847 12
    if (connected_mode == DISCONNECTED) {
	if (entry->flags.attrp) {
	    AccessEntry *ae;
	    findaccess(ce->cred, entry->acccache, &ae);
	    ae->cred = ce->cred;
	    ae->access = 0x7f; /* XXXDISCO */
	    return 0;
	}
	else
	    return ENETDOWN;
    }

d3849 1
a3849 1
     * If there is no parent, `entry' is a root-node, or the parent is
d3852 1
a3852 2
    if (parent			    != NULL
	&& entry->fid.fid.Vnode     != 1
d3861 6
d3873 17
a3889 13
	if (parent->hits++ > fcache_bulkstatus_num &&
	    parent->flags.datausedp) {
	    int error;
	
	    arla_warnx (ADEBFCACHE, "fcache_get_attr: doing bulk get_attr");

	    error = get_attr_bulk (parent,
				   entry, &entry->fid,
				   prefered_name, ce);
	    /* magic calculation when we are going to do next bulkstat */
	    parent->hits = 0;

	    if (error == 0)
d3920 1
a3920 5
	return ENETDOWN;

    ret = init_fs_context(e, ce, &context);
    if (ret)
	return ret;
d3922 1
a3922 1
    for (conn = find_first_fs (&context);
d3924 2
a3925 2
	 conn = find_next_fs (&context, conn, ret)) {
	ret = read_data (e, conn, ce, find_partition(&context));
d3958 1
a3958 1
	if (e->wanted_length <= e->fetched_length) {
d3967 1
a3967 1
	if (e->wanted_length <= e->fetched_length) {
d3973 1
a3973 1
    ret = read_data (e, conn, ce, find_partition(&context));
d3984 1
a3984 2
fcache_get_data (FCacheEntry **e, CredCacheEntry **ce,
		 size_t wanted_length)
d3986 1
d3989 5
a3993 1
    if ((*e)->flags.fake_mp) {
d3999 1
d4004 1
d4009 1
d4013 8
a4020 7
	(*e)->flags.fake_mp   = FALSE;
	(*e)->flags.mountp    = TRUE;
	(*e)->status.FileType = TYPE_LINK;
	update_fid ((*e)->fid, *e, new_fid, new_root);
	fcache_release (*e);
	*e  = new_root;
	install_attr (*e, FCACHE2NNPFSNODE_ALL);
d4023 5
a4027 18
    if (wanted_length) {
	(*e)->wanted_length = wanted_length;
    } else {
	/*
	 * XXX remove this case, attr should either be known already
	 * here, or we should just fetch `whole file'/next block.
	 */

        ret = fcache_verify_attr (*e, NULL, NULL, *ce);
        if (ret) {
            return ret;
        }
        if ((*e)->length == 0 || !uptodatep(*e)) {
            (*e)->wanted_length = (*e)->status.Length;
        }
    }
	
    ret = fcache_verify_data (*e, *ce);
d4083 1
a4083 1
	     uint32_t *volid, VolCacheEntry **ve)
d4117 1
a4117 1
	else if ((*ve)->entry.flags & VLF_RWEXISTS)
a4118 4
	else {
	    volcache_free (*ve);
	    return ENOENT;
	}
d4150 1
a4150 1
    uint32_t volid;
d4245 2
a4246 12
    FCacheEntry *e;
    int ret;

    /*
     * Get the node for `fid' and verify that it's a symbolic link
     * with the correct bits.  Otherwise, just return the old
     * `fid' without any change.
     */

    ret = fcache_get (&e, *fid, *ce);
    if (ret)
	return ret;
d4248 19
a4266 9
    e->parent = *parent;
    ret = fcache_verify_attr (e, parent_e, NULL, *ce);
    if (ret) {
	fcache_release(e);
	return ret;
    }

    if (e->flags.mountp)
	ret = resolve_mp (&e, fid, ce);
d4268 2
a4269 2
    fcache_release(e);
    return ret;
d4277 1
a4277 1
resolve_mp (FCacheEntry **e, VenusFid *ret_fid, CredCacheEntry **ce)
d4279 1
a4279 1
    VenusFid fid = (*e)->fid;
d4284 1
a4284 1
    uint32_t length;
d4286 2
a4287 2
    assert ((*e)->flags.fake_mp || (*e)->flags.mountp);
    AssertExclLocked(&(*e)->lock);
d4289 1
a4289 3
    (*e)->wanted_length = (*e)->status.Length;

    ret = fcache_verify_data (*e, *ce);
d4293 1
a4293 1
    length = (*e)->status.Length;
d4295 1
a4295 1
    fd = fcache_open_file (*e, O_RDONLY);
d4307 1
a4307 2
    ret = get_root_of_volume (&fid, &(*e)->parent, (*e)->volume, 
			      ce, buf, length);
d4331 1
a4331 1
	     e->length != 0 ?" data":"",
d4356 1
a4356 1
	     (long)usedbytes, (long)lowbytes, (long)highbytes);
d4365 1
a4365 1
fcache_update_length (FCacheEntry *e, size_t len, size_t have_len)
a4369 1
    assert (have_len <= len);
a4372 2
    e->wanted_length = min(have_len,len);
    e->fetched_length = have_len;
d4403 1
a4403 3
    ret = init_fs_context(dire, ce, &context);
    if (ret)
	return ret;
d4405 1
a4405 1
    for (conn = find_first_fs (&context);
d4407 1
a4407 1
	 conn = find_next_fs (&context, conn, ret)) {
d4425 2
a4426 1
		      conn, ce->cred);
d4464 1
a4464 3
    ret = init_fs_context(dire, ce, &context);
    if (ret)
	return ret;
d4466 1
a4466 1
    for (conn = find_first_fs (&context);
d4468 1
a4468 1
	 conn = find_next_fs (&context, conn, ret)) {
d4479 2
a4480 1
		      conn, ce->cred);
d4502 1
a4502 1
	   char *volumename, size_t volumenamesz,
d4520 1
a4520 3
    ret = init_fs_context(dire, ce, &context);
    if (ret)
	return ret;
d4522 1
a4522 1
    for (conn = find_first_fs (&context);
d4524 1
a4524 1
	 conn = find_next_fs (&context, conn, ret)) {
d4536 3
a4538 5
    if (ret == 0 && volumename[0] == '\0') {
	if (volcache_getname (fid.fid.Volume, fid.Cell,
			      volumename, volumenamesz) == -1)
	    strlcpy(volumename, "<unknown>", volumenamesz);
    }
d4569 1
a4569 3
    ret = init_fs_context(dire, ce, &context);
    if (ret)
	return ret;
d4571 1
a4571 1
    for (conn = find_first_fs (&context);
d4573 1
a4573 1
	 conn = find_next_fs (&context, conn, ret)) {
d4635 1
a4635 1
    int64_t *a = arg;
d4638 6
a4643 1
    *a += e->length;
d4649 1
a4649 1
int64_t
d4652 1
a4652 1
    int64_t size = 0;
@


