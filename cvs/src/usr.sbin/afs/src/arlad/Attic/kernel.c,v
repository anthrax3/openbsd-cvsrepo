head	1.8;
access;
symbols
	OPENBSD_5_2:1.7.0.34
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.32
	OPENBSD_5_0:1.7.0.30
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.7.0.28
	OPENBSD_4_9_BASE:1.7
	OPENBSD_4_8:1.7.0.26
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.7.0.22
	OPENBSD_4_7_BASE:1.7
	OPENBSD_4_6:1.7.0.24
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.7.0.20
	OPENBSD_4_5_BASE:1.7
	OPENBSD_4_4:1.7.0.18
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.7.0.16
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.7.0.14
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.12
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.10
	OPENBSD_4_0_BASE:1.7
	OPENBSD_3_9:1.7.0.8
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.7.0.6
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.4
	OPENBSD_3_7_BASE:1.7
	OPENBSD_3_6:1.7.0.2
	OPENBSD_3_6_BASE:1.7
	OPENBSD_3_5:1.6.0.4
	OPENBSD_3_5_BASE:1.6
	OPENBSD_3_4:1.6.0.2
	OPENBSD_3_4_BASE:1.6
	arla-20030805:1.1.1.3
	OPENBSD_3_3:1.4.0.4
	OPENBSD_3_3_BASE:1.4
	OPENBSD_3_2:1.4.0.2
	OPENBSD_3_2_BASE:1.4
	arla-0-35-7:1.1.1.2
	OPENBSD_3_1:1.3.0.8
	OPENBSD_3_1_BASE:1.3
	OPENBSD_3_0:1.3.0.6
	OPENBSD_3_0_BASE:1.3
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_9:1.3.0.4
	OPENBSD_2_8:1.3.0.2
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.2.0.4
	OPENBSD_2_7_BASE:1.2
	OPENBSD_2_6:1.2.0.2
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.1.1.1.0.4
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.2
	OPENBSD_2_4_BASE:1.1.1.1
	arla-0_9:1.1.1.1
	arla:1.1.1;
locks; strict;
comment	@ * @;


1.8
date	2012.08.23.06.21.50;	author deraadt;	state dead;
branches;
next	1.7;

1.7
date	2004.04.06.09.34.42;	author avsm;	state Exp;
branches;
next	1.6;

1.6
date	2003.08.26.16.14.53;	author beck;	state Exp;
branches;
next	1.5;

1.5
date	2003.08.05.08.42.41;	author hin;	state Exp;
branches;
next	1.4;

1.4
date	2002.06.07.04.28.57;	author hin;	state Exp;
branches;
next	1.3;

1.3
date	2000.09.11.14.40.42;	author art;	state Exp;
branches;
next	1.2;

1.2
date	99.04.30.01.59.08;	author art;	state Exp;
branches;
next	1.1;

1.1
date	98.09.14.21.52.57;	author art;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.09.14.21.52.57;	author art;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.06.07.04.14.24;	author hin;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2003.08.05.08.21.01;	author hin;	state Exp;
branches;
next	;


desc
@@


1.8
log
@the afs src tree can go away
@
text
@/*
 * Copyright (c) 1995 - 2002 Kungliga Tekniska Högskolan
 * (Royal Institute of Technology, Stockholm, Sweden).
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include "arla_local.h"
RCSID("$arla: kernel.c,v 1.35 2003/01/10 17:33:44 tol Exp $");

/*
 * The fd we use to talk with the kernel on.
 */

int kernel_fd = -1;

/* count of the number of messages in a read */

static unsigned recv_count[20];

/* for more than above... */

static unsigned recv_count_overflow;

/*
 * Number of workers used and high
 */

static unsigned long workers_high, workers_used;


unsigned long
kernel_highworkers(void)
{
    return workers_high;
}

unsigned long
kernel_usedworkers(void)
{
    return workers_used;
}

/*
 *
 */

static int
process_message (int msg_length, char *msg)
{
    struct nnpfs_message_header *header;
    char *p;
    int cnt;

    cnt = 0;
    for (p = msg;
	 msg_length > 0;
	 p += header->size, msg_length -= header->size) {
	header = (struct nnpfs_message_header *)p;
	nnpfs_message_receive (kernel_fd, header, header->size);
	++cnt;
    }
    if (cnt < sizeof(recv_count)/sizeof(recv_count[0]))
	++recv_count[cnt];
    else
	++recv_count_overflow;
     
    return 0;
}

/* no threads available to handle messages */

static int overload = FALSE;

/*
 * The work threads.
 */

struct worker {
    char name[10];
    char pad[6]; /* make sure we're aligned for the data */
    char data[MAX_XMSG_SIZE];
    PROCESS pid;
    int  msg_length;
    int  busyp;
    int  number;
} *workers;

static void
sub_thread (void *v_myself)
{
    struct worker *self = (struct worker *)v_myself;

    for (;;) {
	arla_warnx (ADEBKERNEL, "worker %d waiting", self->number);
	LWP_WaitProcess (self);
	self->busyp = 1;
	++workers_used;
	arla_warnx (ADEBKERNEL, "worker %d: processing", self->number);
	process_message (self->msg_length, self->data);
	arla_warnx (ADEBKERNEL, "worker %d: done", self->number);
	--workers_used;
	self->busyp = 0;
	overload = FALSE;
	LWP_NoYieldSignal(&overload);
    }
}

PROCESS version_pid;

static void
version_thread (void *foo)
{
    nnpfs_probe_version (kernel_fd, NNPFS_VERSION);
}

/*
 * The tcp communication unit
 */

static int
tcp_open (const char *filename)
{
    int s, ret, port;
    struct sockaddr_in addr;

    if (strlen (filename) == 0)
	arla_errx (1, ADEBERROR, "tcp_open doesn't contain tcp-port");

    port = atoi (filename);
    if (port == 0)
	arla_errx (1, ADEBERROR, "tcp_open couldn't parse %s as a port#",
		   filename);

    s = socket (PF_INET, SOCK_STREAM, IPPROTO_TCP);
    if (s < 0) {
	arla_warn (ADEBWARN, errno, "tcp_open: socket failed");
	return s;
    }

    addr.sin_family = AF_INET;
    addr.sin_addr.s_addr = htonl(0x7f000001); /* 127.0.0.1 */
    addr.sin_port = htons(port);
    ret = connect (s, (struct sockaddr *)&addr, sizeof(addr));
    if (ret < 0) {
	arla_warn (ADEBWARN, errno, "tcp_open: connect failed");
	return s;
    }
    return s;
}

static int
tcp_opendef (const char *filename)
{
    if (strlen (filename) != 0)
	arla_warnx (ADEBWARN, "tcp_opendef ignoring extra data");

    return tcp_open ("5000"); /* XXX */
}

static ssize_t
tcp_read (int fd, void *data, size_t len)
{
    int32_t slen;
    char in_len[4];
    if (recv (fd, in_len, sizeof(in_len), 0) != sizeof(in_len)) {
	arla_warn (ADEBWARN, errno, "tcp_read: failed to read length");
	return -1;
    }
    memcpy(&slen, in_len, sizeof(slen));
    slen = ntohl(slen);
    if (len < slen) {
	arla_warnx (ADEBWARN, 
		    "tcp_read: recv a too large message %d",
		    slen);	
	return -1;
    }
    return recv (fd, data, slen, 0) == slen ? slen : -1;
}

static ssize_t
tcp_write (int fd, const void *data, size_t len)
{
    int ret;
    int32_t slen = htonl(len);
    char out_len[4];

    memcpy (out_len, &slen, sizeof(slen));
    if (send (fd, out_len, sizeof(slen), 0) != sizeof(out_len)) {
	arla_warn (ADEBWARN, errno, "tcp_write: failed to write length");
	return -1;
    }
    ret = send (fd, data, len, 0);
    if (ret != len) {
	arla_warn (ADEBWARN, errno, "tcp_write: failed to write msg (%d)", 
		   ret);
	return -1;
    }

    return ret;
}

/*
 * The cdev communication unit
 */

static int
dev_open (const char *filename)
{
    char fn[MAXPATHLEN];
    snprintf (fn, MAXPATHLEN, "/%s", filename);
    return open (fn, O_RDWR);
}

static int
dev_fileopen (const char *filename)
{
    return dev_open (filename);
}

static ssize_t
dev_read (int fd, void *msg, size_t len)
{
    return read (fd, msg, len);
}

static ssize_t
dev_write (int fd, const void *msg, size_t len)
{
    return write (fd, msg, len);
}

/*
 * The null communication unit
 */

static int
null_open (const char *filename)
{
    return 0;
}

static ssize_t
null_read (int fd, void *msg, size_t len)
{
    return 0;
}

static ssize_t
null_write (int fd, const void *msg, size_t len)
{
    return len;
}

/*
 * Way to communticate with the kernel
 */ 

struct kern_interface {
    const char *prefix;
    int (*open) (const char *filename);
    ssize_t (*read) (int fd, void *msg, size_t len);
    ssize_t (*write) (int fd, const void *msg, size_t len);
} kern_comm[] = {
    { "/",	dev_open, dev_read, dev_write},
    { "file:/",	dev_fileopen, dev_read, dev_write},
    { "tcpport:", tcp_open, tcp_read, tcp_write},
    { "tcp",	tcp_opendef, tcp_read, tcp_write},
    { "null",	null_open, null_read, null_write},
    { NULL }
} ;

struct kern_interface *kern_cur = NULL;

static int
kern_open (const char *filename)
{
    struct kern_interface *ki = &kern_comm[0];
    int len;

    while (ki->prefix) {
	len = strlen (ki->prefix);
	if (strncasecmp (ki->prefix, filename, len) == 0) {
	    break;
	}    
	ki++;
    }
    if (ki->prefix == NULL)
	return -1;
    kern_cur = ki;
    return (ki->open) (filename+len);
}

ssize_t
kern_read (int fd, void *data, size_t len)
{
    assert (kern_cur != NULL);
    return (kern_cur->read) (fd, data, len);
}

ssize_t
kern_write (int fd, const void *data, size_t len)
{
    assert (kern_cur != NULL);
    return (kern_cur->write) (fd, data, len);
}

/*
 *
 */

void
kernel_opendevice (const char *dev)
{
    int fd;

    fd = kern_open (dev);
    if (fd < 0)
	arla_err (1, ADEBERROR, errno, "kern_open %s", dev);
    kernel_fd = fd;
    if (kernel_fd >= FD_SETSIZE)
	arla_errx (1, ADEBERROR, "kernel fd too large");
}


/*
 *
 */

#define WORKER_STACKSIZE (16*1024)

void
kernel_interface (struct kernel_args *args)
{
    int i;

    assert (kernel_fd >= 0);

    workers = malloc (sizeof(*workers) * args->num_workers);
    if (workers == NULL)
	arla_err (1, ADEBERROR, errno, "malloc %lu failed",
		  (unsigned long)sizeof(*workers) * args->num_workers);

    workers_high = args->num_workers;
    workers_used = 0;
 
    for (i = 0; i < args->num_workers; ++i) {
	workers[i].busyp  = 0;
	workers[i].number = i;
	snprintf(workers[i].name, sizeof(workers[i].name), "worker %d", i);

	if (LWP_CreateProcess (sub_thread, WORKER_STACKSIZE, 1,
			       (char *)&workers[i],
			       workers[i].name, &workers[i].pid))
	    arla_errx (1, ADEBERROR, "CreateProcess of worker failed");
    }

    if (LWP_CreateProcess (version_thread, WORKER_STACKSIZE, 1,
			   NULL,
			   "version", &version_pid))
	arla_errx (1, ADEBERROR, "CreateProcess of version thread failed");

    arla_warnx(ADEBKERNEL, "Arla: selecting on fd: %d", kernel_fd);

    for (;;) {
	fd_set readset;
	int ret;
	  
	FD_ZERO(&readset);
	FD_SET(kernel_fd, &readset);

	ret = IOMGR_Select (kernel_fd + 1, &readset, NULL, NULL, NULL); 

	if (ret < 0)
	    arla_warn (ADEBKERNEL, errno, "select");
	else if (ret == 0)
	    arla_warnx (ADEBKERNEL,
			"Arla: select returned with 0. strange.");
	else if (FD_ISSET(kernel_fd, &readset)) {
	    for (i = 0; i < args->num_workers; ++i) {
		if (workers[i].busyp == 0) {
		    ret = kern_read (kernel_fd, workers[i].data,
				     sizeof(workers[i].data));
		    if (ret <= 0) {
			arla_warn (ADEBWARN, errno, "read");
		    } else {
			workers[i].msg_length = ret;
			LWP_SignalProcess (&workers[i]);
		    }
		    break;
		}
	    }
	    if (i == args->num_workers) {
		arla_warnx (ADEBWARN, "kernel: all %u workers busy",
			    args->num_workers);
		overload = TRUE;
		LWP_WaitProcess(&overload);
	    }
	}
    }
}
@


1.7
log
@dont write more than 4 bytes even on 64-bit. beck@@ ok
@
text
@@


1.6
log
@Fix afsd on architectures that care about alignment. This corrects a problem
that would manifest itself as afsd bus erroring on startup. Tested on
sparc64 and again on i386, Ok hin@@
@
text
@d214 2
a215 2
    memcpy (out_len, &slen, sizeof(len));
    if (send (fd, out_len, sizeof(len), 0) != sizeof(out_len)) {
@


1.5
log
@Merge
@
text
@d107 1
@


1.4
log
@merge
@
text
@d2 1
a2 1
 * Copyright (c) 1995 - 2001 Kungliga Tekniska Högskolan
d35 1
a35 1
RCSID("$KTH: kernel.c,v 1.27.2.1 2001/03/12 12:22:41 lha Exp $");
d77 16
a92 16
     struct xfs_message_header *header;
     char *p;
     int cnt;

     cnt = 0;
     for (p = msg;
	  msg_length > 0;
	  p += header->size, msg_length -= header->size) {
	 header = (struct xfs_message_header *)p;
	 xfs_message_receive (kernel_fd, header, header->size);
	 ++cnt;
     }
     if (cnt < sizeof(recv_count)/sizeof(recv_count[0]))
	 ++recv_count[cnt];
     else
	 ++recv_count_overflow;
d94 1
a94 1
     return 0;
d106 1
d139 1
a139 1
    xfs_probe_version (kernel_fd, XFS_VERSION);
d167 1
a167 1
    addr.sin_addr.s_addr = 0x7f000001; /* 127.0.0.1 */
d172 1
a172 1
	return ret;
d174 1
a174 1
    return ret;
d199 1
a199 1
		    "tcp_read: recv a too large messsage %d",
d209 1
d212 1
d218 8
a225 1
    return send (fd, data, len, 0) == len ? len : -1;
d285 1
a285 1
    char *prefix;
d360 1
a360 1
     int i;
d362 1
a362 1
     assert (kernel_fd >= 0);
d364 4
a367 4
     workers = malloc (sizeof(*workers) * args->num_workers);
     if (workers == NULL)
	 arla_err (1, ADEBERROR, errno, "malloc %lu failed",
		   (unsigned long)sizeof(*workers) * args->num_workers);
d369 2
a370 2
     workers_high = args->num_workers;
     workers_used = 0;
d373 20
a392 18
	 workers[i].busyp  = 0;
	 workers[i].number = i;
	 if (LWP_CreateProcess (sub_thread, WORKER_STACKSIZE, 1,
				(char *)&workers[i],
				"worker", &workers[i].pid))
	     arla_errx (1, ADEBERROR, "CreateProcess of worker failed");
     }

     if (LWP_CreateProcess (version_thread, WORKER_STACKSIZE, 1,
			    NULL,
			    "version", &version_pid))
	 arla_errx (1, ADEBERROR, "CreateProcess of version thread failed");

     arla_warnx(ADEBKERNEL, "Arla: selecting on fd: %d", kernel_fd);

     for (;;) {
	  fd_set readset;
	  int ret;
d394 2
a395 2
	  FD_ZERO(&readset);
	  FD_SET(kernel_fd, &readset);
d397 1
a397 1
	  ret = IOMGR_Select (kernel_fd + 1, &readset, NULL, NULL, NULL); 
d399 27
a425 27
	  if (ret < 0)
	      arla_warn (ADEBKERNEL, errno, "select");
	  else if (ret == 0)
	      arla_warnx (ADEBKERNEL,
			  "Arla: select returned with 0. strange.");
	  else if (FD_ISSET(kernel_fd, &readset)) {
	      for (i = 0; i < args->num_workers; ++i) {
		  if (workers[i].busyp == 0) {
		      ret = kern_read (kernel_fd, workers[i].data,
				       sizeof(workers[i].data));
		      if (ret <= 0) {
			  arla_warn (ADEBWARN, errno, "read");
		      } else {
			  workers[i].msg_length = ret;
			  LWP_SignalProcess (&workers[i]);
		      }
		      break;
		  }
	      }
	      if (i == args->num_workers) {
		  arla_warnx (ADEBWARN, "kernel: all %u workers busy",
			      args->num_workers);
		  overload = TRUE;
		  LWP_WaitProcess(&overload);
	      }
	  }
     }
@


1.3
log
@New Arla userland from Arla between 0.34.2 and current in arla cvs.
Too many new features and fixes to mention here.
@
text
@d2 1
a2 1
 * Copyright (c) 1995 - 2000 Kungliga Tekniska Högskolan
d17 1
a17 6
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by the Kungliga Tekniska
 *      Högskolan and its contributors.
 * 
 * 4. Neither the name of the Institute nor the names of its contributors
d35 1
a35 1
RCSID("$Id: kernel.c,v 1.25 2000/06/11 09:17:11 assar Exp $");
d97 4
d128 2
d336 2
d406 6
a411 2
	      if (i == args->num_workers)
		  arla_warnx (ADEBWARN, "kernel: all workers busy");
@


1.2
log
@upgrade Arla to fresher code. Too many new features and bugfixes.
@
text
@a0 1
/*	$OpenBSD$	*/
d2 1
a2 1
 * Copyright (c) 1995, 1996, 1997, 1998 Kungliga Tekniska Högskolan
d40 1
a40 1
RCSID("$KTH: kernel.c,v 1.17 1998/12/06 20:48:40 lha Exp $");
d46 1
a46 1
int kernel_fd;
d132 210
a346 1
     int fd;
d349 1
a349 4
     fd = open (args->device, O_RDWR);
     if (fd < 0)
	 arla_err (1, ADEBERROR, errno, "open %s", args->device);
     kernel_fd = fd;
d353 2
a354 2
	 arla_err (1, ADEBERROR, errno, "malloc %u failed",
		   sizeof(*workers) * args->num_workers);
d368 6
a373 1
     arla_warnx(ADEBKERNEL, "Arla: selecting on fd: %d", fd);
d380 1
a380 1
	  FD_SET(fd, &readset);
d382 1
a382 1
	  ret = IOMGR_Select (fd + 1, &readset, NULL, NULL, NULL); 
d389 1
a389 1
	  else if (FD_ISSET(fd, &readset)) {
d392 2
a393 2
		      ret = read (fd, workers[i].data,
				  sizeof(workers[i].data));
@


1.1
log
@Initial revision
@
text
@d41 1
a41 1
RCSID("$KTH: kernel.c,v 1.12 1998/07/13 19:19:02 assar Exp $");
d57 23
d81 1
a81 1
process_message (int fd)
a82 2
     static char data[MAX_XMSG_SIZE];
     int res;
a86 7
     res = read (fd, data, sizeof (data));

     if (res < 0) {
	  arla_warn (ADEBWARN, errno, "read");
	  /* XXX process the errno? Are we supposed to exit on every error?*/
	  return -1;
     }
d88 3
a90 1
     for (p = data; res > 0; p += header->size, res -= header->size) {
d92 1
a92 1
	 xfs_message_receive (fd, header, header->size);
d103 32
d136 1
a136 1
kernel_interface (char *device)
d139 1
d141 1
a141 1
     fd = open (device, O_RDWR);
d143 1
a143 1
	 arla_err (1, ADEBERROR, errno, "open %s", device);
d146 17
d180 15
a194 3
	      
	      if (process_message (fd))
		  arla_errx (1, ADEBKERNEL, "error processing message");
@


1.1.1.1
log
@Initial version of Arla, a free implementation of an AFS cache-manager.
(second try, hopefully into the correct repository this time)
@
text
@@


1.1.1.2
log
@Import of arla-0.35.7
@
text
@d1 1
d3 1
a3 1
 * Copyright (c) 1995 - 2001 Kungliga Tekniska Högskolan
d18 6
a23 1
 * 3. Neither the name of the Institute nor the names of its contributors
d41 1
a41 1
RCSID("$KTH: kernel.c,v 1.27.2.1 2001/03/12 12:22:41 lha Exp $");
d47 1
a47 1
int kernel_fd = -1;
a56 23
/*
 * Number of workers used and high
 */

static unsigned long workers_high, workers_used;


unsigned long
kernel_highworkers(void)
{
    return workers_high;
}

unsigned long
kernel_usedworkers(void)
{
    return workers_used;
}

/*
 *
 */

d58 1
a58 1
process_message (int msg_length, char *msg)
d60 2
d66 7
d74 1
a74 3
     for (p = msg;
	  msg_length > 0;
	  p += header->size, msg_length -= header->size) {
d76 1
a76 1
	 xfs_message_receive (kernel_fd, header, header->size);
a86 250
/* no threads available to handle messages */

static int overload = FALSE;

/*
 * The work threads.
 */

struct worker {
    char data[MAX_XMSG_SIZE];
    PROCESS pid;
    int  msg_length;
    int  busyp;
    int  number;
} *workers;

static void
sub_thread (void *v_myself)
{
    struct worker *self = (struct worker *)v_myself;

    for (;;) {
	arla_warnx (ADEBKERNEL, "worker %d waiting", self->number);
	LWP_WaitProcess (self);
	self->busyp = 1;
	++workers_used;
	arla_warnx (ADEBKERNEL, "worker %d: processing", self->number);
	process_message (self->msg_length, self->data);
	arla_warnx (ADEBKERNEL, "worker %d: done", self->number);
	--workers_used;
	self->busyp = 0;
	overload = FALSE;
	LWP_NoYieldSignal(&overload);
    }
}

PROCESS version_pid;

static void
version_thread (void *foo)
{
    xfs_probe_version (kernel_fd, XFS_VERSION);
}

/*
 * The tcp communication unit
 */

static int
tcp_open (const char *filename)
{
    int s, ret, port;
    struct sockaddr_in addr;

    if (strlen (filename) == 0)
	arla_errx (1, ADEBERROR, "tcp_open doesn't contain tcp-port");

    port = atoi (filename);
    if (port == 0)
	arla_errx (1, ADEBERROR, "tcp_open couldn't parse %s as a port#",
		   filename);

    s = socket (PF_INET, SOCK_STREAM, IPPROTO_TCP);
    if (s < 0) {
	arla_warn (ADEBWARN, errno, "tcp_open: socket failed");
	return s;
    }

    addr.sin_family = AF_INET;
    addr.sin_addr.s_addr = 0x7f000001; /* 127.0.0.1 */
    addr.sin_port = htons(port);
    ret = connect (s, (struct sockaddr *)&addr, sizeof(addr));
    if (ret < 0) {
	arla_warn (ADEBWARN, errno, "tcp_open: connect failed");
	return ret;
    }
    return ret;
}

static int
tcp_opendef (const char *filename)
{
    if (strlen (filename) != 0)
	arla_warnx (ADEBWARN, "tcp_opendef ignoring extra data");

    return tcp_open ("5000"); /* XXX */
}

static ssize_t
tcp_read (int fd, void *data, size_t len)
{
    int32_t slen;
    char in_len[4];
    if (recv (fd, in_len, sizeof(in_len), 0) != sizeof(in_len)) {
	arla_warn (ADEBWARN, errno, "tcp_read: failed to read length");
	return -1;
    }
    memcpy(&slen, in_len, sizeof(slen));
    slen = ntohl(slen);
    if (len < slen) {
	arla_warnx (ADEBWARN, 
		    "tcp_read: recv a too large messsage %d",
		    slen);	
	return -1;
    }
    return recv (fd, data, slen, 0) == slen ? slen : -1;
}

static ssize_t
tcp_write (int fd, const void *data, size_t len)
{
    int32_t slen = htonl(len);
    char out_len[4];
    memcpy (out_len, &slen, sizeof(len));
    if (send (fd, out_len, sizeof(len), 0) != sizeof(out_len)) {
	arla_warn (ADEBWARN, errno, "tcp_write: failed to write length");
	return -1;
    }
    return send (fd, data, len, 0) == len ? len : -1;
}

/*
 * The cdev communication unit
 */

static int
dev_open (const char *filename)
{
    char fn[MAXPATHLEN];
    snprintf (fn, MAXPATHLEN, "/%s", filename);
    return open (fn, O_RDWR);
}

static int
dev_fileopen (const char *filename)
{
    return dev_open (filename);
}

static ssize_t
dev_read (int fd, void *msg, size_t len)
{
    return read (fd, msg, len);
}

static ssize_t
dev_write (int fd, const void *msg, size_t len)
{
    return write (fd, msg, len);
}

/*
 * The null communication unit
 */

static int
null_open (const char *filename)
{
    return 0;
}

static ssize_t
null_read (int fd, void *msg, size_t len)
{
    return 0;
}

static ssize_t
null_write (int fd, const void *msg, size_t len)
{
    return len;
}

/*
 * Way to communticate with the kernel
 */ 

struct kern_interface {
    char *prefix;
    int (*open) (const char *filename);
    ssize_t (*read) (int fd, void *msg, size_t len);
    ssize_t (*write) (int fd, const void *msg, size_t len);
} kern_comm[] = {
    { "/",	dev_open, dev_read, dev_write},
    { "file:/",	dev_fileopen, dev_read, dev_write},
    { "tcpport:", tcp_open, tcp_read, tcp_write},
    { "tcp",	tcp_opendef, tcp_read, tcp_write},
    { "null",	null_open, null_read, null_write},
    { NULL }
} ;

struct kern_interface *kern_cur = NULL;

static int
kern_open (const char *filename)
{
    struct kern_interface *ki = &kern_comm[0];
    int len;

    while (ki->prefix) {
	len = strlen (ki->prefix);
	if (strncasecmp (ki->prefix, filename, len) == 0) {
	    break;
	}    
	ki++;
    }
    if (ki->prefix == NULL)
	return -1;
    kern_cur = ki;
    return (ki->open) (filename+len);
}

ssize_t
kern_read (int fd, void *data, size_t len)
{
    assert (kern_cur != NULL);
    return (kern_cur->read) (fd, data, len);
}

ssize_t
kern_write (int fd, const void *data, size_t len)
{
    assert (kern_cur != NULL);
    return (kern_cur->write) (fd, data, len);
}

/*
 *
 */

void
kernel_opendevice (const char *dev)
{
    int fd;

    fd = kern_open (dev);
    if (fd < 0)
	arla_err (1, ADEBERROR, errno, "kern_open %s", dev);
    kernel_fd = fd;
    if (kernel_fd >= FD_SETSIZE)
	arla_errx (1, ADEBERROR, "kernel fd too large");
}


/*
 *
 */

#define WORKER_STACKSIZE (16*1024)

d88 1
a88 1
kernel_interface (struct kernel_args *args)
d90 1
a90 20
     int i;

     assert (kernel_fd >= 0);

     workers = malloc (sizeof(*workers) * args->num_workers);
     if (workers == NULL)
	 arla_err (1, ADEBERROR, errno, "malloc %lu failed",
		   (unsigned long)sizeof(*workers) * args->num_workers);

     workers_high = args->num_workers;
     workers_used = 0;
 
    for (i = 0; i < args->num_workers; ++i) {
	 workers[i].busyp  = 0;
	 workers[i].number = i;
	 if (LWP_CreateProcess (sub_thread, WORKER_STACKSIZE, 1,
				(char *)&workers[i],
				"worker", &workers[i].pid))
	     arla_errx (1, ADEBERROR, "CreateProcess of worker failed");
     }
d92 4
a95 4
     if (LWP_CreateProcess (version_thread, WORKER_STACKSIZE, 1,
			    NULL,
			    "version", &version_pid))
	 arla_errx (1, ADEBERROR, "CreateProcess of version thread failed");
d97 1
a97 1
     arla_warnx(ADEBKERNEL, "Arla: selecting on fd: %d", kernel_fd);
d104 1
a104 1
	  FD_SET(kernel_fd, &readset);
d106 1
a106 1
	  ret = IOMGR_Select (kernel_fd + 1, &readset, NULL, NULL, NULL); 
d113 4
a116 20
	  else if (FD_ISSET(kernel_fd, &readset)) {
	      for (i = 0; i < args->num_workers; ++i) {
		  if (workers[i].busyp == 0) {
		      ret = kern_read (kernel_fd, workers[i].data,
				       sizeof(workers[i].data));
		      if (ret <= 0) {
			  arla_warn (ADEBWARN, errno, "read");
		      } else {
			  workers[i].msg_length = ret;
			  LWP_SignalProcess (&workers[i]);
		      }
		      break;
		  }
	      }
	      if (i == args->num_workers) {
		  arla_warnx (ADEBWARN, "kernel: all %u workers busy",
			      args->num_workers);
		  overload = TRUE;
		  LWP_WaitProcess(&overload);
	      }
@


1.1.1.3
log
@Import of arla -current as of Aug 5 2003

ok todd@@ deraadt@@
@
text
@d2 1
a2 1
 * Copyright (c) 1995 - 2002 Kungliga Tekniska Högskolan
d35 1
a35 1
RCSID("$arla: kernel.c,v 1.35 2003/01/10 17:33:44 tol Exp $");
d77 16
a92 16
    struct nnpfs_message_header *header;
    char *p;
    int cnt;

    cnt = 0;
    for (p = msg;
	 msg_length > 0;
	 p += header->size, msg_length -= header->size) {
	header = (struct nnpfs_message_header *)p;
	nnpfs_message_receive (kernel_fd, header, header->size);
	++cnt;
    }
    if (cnt < sizeof(recv_count)/sizeof(recv_count[0]))
	++recv_count[cnt];
    else
	++recv_count_overflow;
d94 1
a94 1
    return 0;
a105 1
    char name[10];
d138 1
a138 1
    nnpfs_probe_version (kernel_fd, NNPFS_VERSION);
d166 1
a166 1
    addr.sin_addr.s_addr = htonl(0x7f000001); /* 127.0.0.1 */
d171 1
a171 1
	return s;
d173 1
a173 1
    return s;
d198 1
a198 1
		    "tcp_read: recv a too large message %d",
a207 1
    int ret;
a209 1

d215 1
a215 8
    ret = send (fd, data, len, 0);
    if (ret != len) {
	arla_warn (ADEBWARN, errno, "tcp_write: failed to write msg (%d)", 
		   ret);
	return -1;
    }

    return ret;
d275 1
a275 1
    const char *prefix;
d350 1
a350 1
    int i;
d352 1
a352 1
    assert (kernel_fd >= 0);
d354 4
a357 4
    workers = malloc (sizeof(*workers) * args->num_workers);
    if (workers == NULL)
	arla_err (1, ADEBERROR, errno, "malloc %lu failed",
		  (unsigned long)sizeof(*workers) * args->num_workers);
d359 2
a360 2
    workers_high = args->num_workers;
    workers_used = 0;
d363 18
a380 20
	workers[i].busyp  = 0;
	workers[i].number = i;
	snprintf(workers[i].name, sizeof(workers[i].name), "worker %d", i);

	if (LWP_CreateProcess (sub_thread, WORKER_STACKSIZE, 1,
			       (char *)&workers[i],
			       workers[i].name, &workers[i].pid))
	    arla_errx (1, ADEBERROR, "CreateProcess of worker failed");
    }

    if (LWP_CreateProcess (version_thread, WORKER_STACKSIZE, 1,
			   NULL,
			   "version", &version_pid))
	arla_errx (1, ADEBERROR, "CreateProcess of version thread failed");

    arla_warnx(ADEBKERNEL, "Arla: selecting on fd: %d", kernel_fd);

    for (;;) {
	fd_set readset;
	int ret;
d382 2
a383 2
	FD_ZERO(&readset);
	FD_SET(kernel_fd, &readset);
d385 1
a385 1
	ret = IOMGR_Select (kernel_fd + 1, &readset, NULL, NULL, NULL); 
d387 27
a413 27
	if (ret < 0)
	    arla_warn (ADEBKERNEL, errno, "select");
	else if (ret == 0)
	    arla_warnx (ADEBKERNEL,
			"Arla: select returned with 0. strange.");
	else if (FD_ISSET(kernel_fd, &readset)) {
	    for (i = 0; i < args->num_workers; ++i) {
		if (workers[i].busyp == 0) {
		    ret = kern_read (kernel_fd, workers[i].data,
				     sizeof(workers[i].data));
		    if (ret <= 0) {
			arla_warn (ADEBWARN, errno, "read");
		    } else {
			workers[i].msg_length = ret;
			LWP_SignalProcess (&workers[i]);
		    }
		    break;
		}
	    }
	    if (i == args->num_workers) {
		arla_warnx (ADEBWARN, "kernel: all %u workers busy",
			    args->num_workers);
		overload = TRUE;
		LWP_WaitProcess(&overload);
	    }
	}
    }
@


