head	1.8;
access;
symbols
	OPENBSD_5_2:1.7.0.10
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.8
	OPENBSD_5_0:1.7.0.6
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.7.0.4
	OPENBSD_4_9_BASE:1.7
	OPENBSD_4_8:1.7.0.2
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.6.0.18
	OPENBSD_4_7_BASE:1.6
	OPENBSD_4_6:1.6.0.20
	OPENBSD_4_6_BASE:1.6
	OPENBSD_4_5:1.6.0.16
	OPENBSD_4_5_BASE:1.6
	OPENBSD_4_4:1.6.0.14
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3:1.6.0.12
	OPENBSD_4_3_BASE:1.6
	OPENBSD_4_2:1.6.0.10
	OPENBSD_4_2_BASE:1.6
	OPENBSD_4_1:1.6.0.8
	OPENBSD_4_1_BASE:1.6
	OPENBSD_4_0:1.6.0.6
	OPENBSD_4_0_BASE:1.6
	OPENBSD_3_9:1.6.0.4
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.6.0.2
	OPENBSD_3_8_BASE:1.6
	OPENBSD_3_7:1.5.0.6
	OPENBSD_3_7_BASE:1.5
	OPENBSD_3_6:1.5.0.4
	OPENBSD_3_6_BASE:1.5
	OPENBSD_3_5:1.5.0.2
	OPENBSD_3_5_BASE:1.5
	OPENBSD_3_4:1.4.0.2
	OPENBSD_3_4_BASE:1.4
	arla-20030805:1.1.1.2
	OPENBSD_3_3:1.3.0.4
	OPENBSD_3_3_BASE:1.3
	OPENBSD_3_2:1.3.0.2
	OPENBSD_3_2_BASE:1.3
	arla-0-35-7:1.1.1.1
	arla:1.1.1
	OPENBSD_3_1:1.1.0.8
	OPENBSD_3_1_BASE:1.1
	OPENBSD_3_0:1.1.0.6
	OPENBSD_3_0_BASE:1.1
	OPENBSD_2_9_BASE:1.1
	OPENBSD_2_9:1.1.0.4
	OPENBSD_2_8:1.1.0.2
	OPENBSD_2_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.8
date	2012.08.23.06.21.50;	author deraadt;	state dead;
branches;
next	1.7;

1.7
date	2010.05.01.20.47.36;	author jsg;	state Exp;
branches;
next	1.6;

1.6
date	2005.05.02.17.51.36;	author moritz;	state Exp;
branches;
next	1.5;

1.5
date	2003.12.16.20.13.55;	author beck;	state Exp;
branches;
next	1.4;

1.4
date	2003.08.05.08.42.41;	author hin;	state Exp;
branches;
next	1.3;

1.3
date	2002.06.07.04.28.57;	author hin;	state Exp;
branches;
next	1.2;

1.2
date	2002.04.25.22.55.40;	author espie;	state Exp;
branches;
next	1.1;

1.1
date	2000.09.11.14.40.41;	author art;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.06.07.04.14.23;	author hin;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.08.05.08.21.00;	author hin;	state Exp;
branches;
next	;


desc
@@


1.8
log
@the afs src tree can go away
@
text
@/*
 * Copyright (c) 1999 - 2003 Kungliga Tekniska Högskolan
 * (Royal Institute of Technology, Stockholm, Sweden).
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * Keep our own root.afs
 *
 * uses cell DYNROOTCELL as cell number.
 */

#include <arla_local.h>

RCSID("$arla: dynroot.c,v 1.25 2003/01/20 14:21:02 lha Exp $");

struct create_entry {
    fbuf *thedir;	/* pointer to the fbuf that contains the dir */
    AFSFid fid;		/* the current fid */
    int len;		/* num of links in the dir */
    int type;
};

#define DYNROOT_ROOTVOLUME 1		/* make sure that these */
#define DYNROOT_ROOTVOLUME_STR "1"	/* two are the same */
#define DYNROOT_ROOTDIR 1
#define DYNROOT_UNIQUE 1

static Bool dynroot_enabled  = 0;		/* is dynroot enabled ? */
static unsigned long last_celldb_version = 0;	/* last version of celldb */

/*
 * Magic glue wrt afsvnode#
 */

static int32_t
cellnum2afs (int cellno, int rw)
{
    if (rw)
	return (cellno << 2) + 0x2;
    else
	return (cellno << 2) + 0x1;
}

static int
afs2cellnum (int32_t afsvnode, int *rw)
{
    if (afsvnode & 0x2)
	*rw = 1;
    else
	*rw = 0;
    return afsvnode >> 2;
}

/*
 * helper functions for dynroot_create_root that for
 * each `cell' with 'cellid' a entry in the root directory.
 */

static int
create_entry_func (const char *name, uint32_t cellid, int type, void *arg)
{
    struct create_entry *entry = (struct create_entry *) arg;
    int ret;

    entry->fid.Vnode = cellnum2afs (cellid, type & DYNROOT_ALIAS_READWRITE);

    ret = fdir_creat (entry->thedir, name, entry->fid);
    if (ret)
	return ret;

    entry->len++;

    return 0;
}

/*
 * Wrapper function for cell_foreach that takes a `cell' instead of a
 * string and a cellid.
 */

static int
create_cell_entry_func (const cell_entry *cell, void *arg)
{
    if (!cell_dynroot(cell))
	return 0;
    return create_entry_func(cell->name, cell->id, 
			     DYNROOT_ALIAS_READONLY, arg);
}

/*
 *
 */

static int
create_alias_entry_func (const char *cellname, const char *alias, 
			 int type, void *arg)
{
    cell_entry *cell;

    cell = cell_get_by_name (cellname);
    if (cell == NULL)
	return 0;
    return create_entry_func(alias, cell->id, type, arg);

}


/*
 * create the dynroot root directory in `fbuf', return number
 * of entries in `len'.
 */

static int
dynroot_create_root (fbuf *fbuf, size_t *len)
{
    int ret;
    AFSFid dot = { DYNROOT_ROOTVOLUME,
		   DYNROOT_ROOTDIR,
		   DYNROOT_UNIQUE};
    struct create_entry entry;

    ret = fdir_mkdir (fbuf, dot, dot);
    if (ret)
	return ret;

    entry.thedir	= fbuf;

    entry.fid.Volume	= DYNROOT_ROOTVOLUME;
    entry.fid.Vnode	= DYNROOT_ROOTDIR + 2;
    entry.fid.Unique	= DYNROOT_UNIQUE;
    entry.len = 0;
    
    ret = cell_foreach (create_cell_entry_func, &entry);
    if (ret)
	return ret;

    ret = cell_alias_foreach(create_alias_entry_func, &entry);
    if (ret)
	return ret;

    *len = entry.len;

    return 0;
}

/*
 * for the `vnode' create apropriate symlink in `fbuf'
 */

static int
dynroot_create_symlink (fbuf *fbuf, int32_t vnode)
{
    char name[MAXPATHLEN];
    cell_entry *cell;
    int len, ret, rw = 0;

    cell = cell_get_by_id (afs2cellnum (vnode, &rw));
    if (cell == NULL)
	return ENOENT;

    len = snprintf (name, sizeof(name), "%c%s:root.cell.", 
		    rw ? '%' : '#', cell->name);
    assert (len > 0 && len < sizeof (name));

    ret = fbuf_truncate (fbuf, len);
    if (ret)
	return ret;

    memmove (fbuf_buf(fbuf), name, len);
    return 0;
}

/*
 * Return TRUE if the combination `cell' and `volume' is
 * in the dynroot.
 */

Bool
dynroot_isvolumep (int cell, const char *volume)
{
    assert (volume);
    
    if (cell == 0 &&
	(strcmp (volume, "root.afs") == 0
	 || strcmp (volume, DYNROOT_ROOTVOLUME_STR) == 0))
	return TRUE;

    return FALSE;
}

/*
 * Create a dummy nvldbentry in `entry'
 */

int
dynroot_fetch_root_vldbN (nvldbentry *entry)
{
    memset (entry, 0, sizeof(*entry));

    strlcpy(entry->name, "root.afs", sizeof(entry->name));
    entry->nServers = 0;
    entry->volumeId[ROVOL] = DYNROOT_ROOTVOLUME;
    entry->flags = VLF_ROEXISTS;

    return 0;
}

/*
 * Update `entry' to contain the correct information
 * Note: doesn't update status.Length and status.LinkCount
 */

static void
dynroot_update_entry (FCacheEntry *entry, int32_t filetype,
		      nnpfs_pag_t cred)
{
    struct timeval tv;
    AccessEntry *ae;

    assert (entry);
    entry->status.InterfaceVersion = 1;
    entry->status.FileType	= filetype;
    entry->status.DataVersion	= 1;
    entry->status.Author	= 0;
    entry->status.Owner		= 0;
    entry->status.CallerAccess 	= ALIST | AREAD;
    entry->status.AnonymousAccess = ALIST | AREAD;
    switch (filetype) {
    case TYPE_DIR: 
	entry->status.UnixModeBits = 0755;
	break;
    case TYPE_LINK:
	entry->status.UnixModeBits = 0644;
	break;
    default:
	errx(-1, "dynroot_update_entry: unknowrn file type %d\n", filetype);
	/* NOTREACHED */
    }
    entry->status.ParentVnode	= DYNROOT_ROOTDIR;
    entry->status.ParentUnique	= DYNROOT_UNIQUE;
    entry->status.SegSize	= 64*1024;
    entry->status.ClientModTime	= 0;
    entry->status.ServerModTime	= 0;
    entry->status.Group		= 0;
    entry->status.SyncCount	= 0;
    entry->status.DataVersionHigh= 0;
    entry->status.LockCount	= 0;
    entry->status.LengthHigh	= 0;
    entry->status.ErrorCode	= 0;

    gettimeofday (&tv, NULL);

    memset (&entry->volsync, 0, sizeof (entry->volsync));

    entry->callback.CallBackVersion = 1;
    entry->callback.ExpirationTime = tv.tv_sec + 3600 * 24 * 7;
    entry->callback.CallBackType = CBSHARED;

    entry->anonaccess = entry->status.AnonymousAccess;

    findaccess(cred, entry->acccache, &ae);
    ae->cred = cred;
    ae->access = entry->status.CallerAccess;
}

/*
 * Fetch data and attr for `entry'
 */

static int
dynroot_get_node (FCacheEntry *entry, CredCacheEntry *ce)
{
    int ret, fd, rootnode;
    size_t len;
    fbuf dir;

    rootnode = entry->fid.fid.Vnode == DYNROOT_ROOTDIR ? 1 : 0;

    if (entry->length != 0 &&
	(!rootnode || last_celldb_version == cell_get_version()))
	return 0;

    fd = fcache_open_file (entry, O_RDWR);
    if (fd < 0)
	return errno; 

    ret = fbuf_create (&dir, fd, 0, FBUF_READ | FBUF_WRITE | FBUF_SHARED);
    if (ret) {
	close (fd);
	return ret;
    }    

    if (rootnode) {
	ret = dynroot_create_root (&dir, &len);
	entry->status.LinkCount = len;
    } else {
	ret = dynroot_create_symlink (&dir, entry->fid.fid.Vnode);
	entry->status.LinkCount = 1;
	fcache_mark_as_mountpoint (entry);
    }

    if (ret) {
	fbuf_end (&dir);
	close(fd);
	return ret;
    }

    entry->flags.attrp = TRUE;

    dynroot_update_entry (entry, rootnode ? TYPE_DIR : TYPE_LINK,
			  ce->cred);

    entry->status.Length 	= dir.len;
    fcache_update_length(entry, dir.len, dir.len);

    ret = fbuf_end (&dir);
    close(fd);
    if (ret)
	return ret;

    entry->tokens |= NNPFS_ATTR_R|NNPFS_DATA_R;

    return 0;
}

/*
 * Fetch attr for `entry'
 */

int
dynroot_get_attr (FCacheEntry *entry, CredCacheEntry *ce)
{
    return dynroot_get_node (entry, ce);
}


/*
 * Fetch data for `entry'
 */

int
dynroot_get_data (FCacheEntry *entry, CredCacheEntry *ce)
{
    return dynroot_get_node (entry, ce);
}

/*
 * returns TRUE if `entry' is a dynroot entry.
 */

Bool
dynroot_is_dynrootp (FCacheEntry *entry)
{
    assert (entry);

    if (dynroot_enabled &&
	entry->fid.Cell == DYNROOT_CELLID &&
	entry->fid.fid.Volume == DYNROOT_ROOTVOLUME)
	return TRUE;

    return FALSE;
}

/*
 * Return what status the dynroot is in.
 */

Bool
dynroot_enablep (void)
{
    return dynroot_enabled;
}

/*
 * Enable/Disable the dynroot depending on `enable', returns previous state.
 */

Bool
dynroot_setenable (Bool enable)
{
    Bool was = dynroot_enabled;
    dynroot_enabled = enable;
    return was;
}

/*
 * Returns the dynroot_cellid.
 */

int32_t dynroot_cellid (void)
{
    return DYNROOT_CELLID;
}

/*
 * Return the dynroot volumeid.
 */

int32_t dynroot_volumeid (void)
{
    return DYNROOT_ROOTVOLUME;
}
@


1.7
log
@As suggested by miod, rename dynroot_enable so we don't conflict with
a definition from a header.  This turns out to be the same change made
in the upstream arla code.

ok miod@@
@
text
@@


1.6
log
@fix snprintf misuse. ok bob@@ hin@@
@
text
@d56 1
a56 1
static Bool dynroot_enable  = 0;		/* is dynroot enabled ? */
d384 1
a384 1
    if (dynroot_enable &&
d399 1
a399 1
    return dynroot_enable;
d409 2
a410 2
    Bool was = dynroot_enable;
    dynroot_enable = enable;
@


1.5
log
@afs cleanup, realloc strings, abort, etc.
testing by beck, hin, jose, fries. ok deraadt@@
@
text
@d191 1
a191 1
    assert (len > 0 && len <= sizeof (name));
@


1.4
log
@Merge
@
text
@d264 2
a265 1
	abort();
@


1.3
log
@merge
@
text
@d2 1
a2 1
 * Copyright (c) 1999 - 2000 Kungliga Tekniska Högskolan
d42 1
a42 1
RCSID("$KTH: dynroot.c,v 1.13.2.2 2001/05/28 15:19:20 map Exp $");
d48 1
d51 2
a52 1
#define DYNROOT_ROOTVOLUME 1
a55 1
static int32_t dynrootcell = 0;			/* this is the dynroocell */
d64 1
a64 1
cellnum2afs (int cellno)
d66 4
a69 1
    return (cellno << 1) + 1;
d73 1
a73 1
afs2cellnum (int32_t afsvnode)
d75 5
a79 1
    return (afsvnode - 1) >> 1;
d84 1
a84 1
 * each `cell' creates a entry in the root directory.
d88 1
a88 1
create_entry_func (const cell_entry *cell, void *arg)
d93 1
a93 4
    if (!cell_dynroot(cell))
	return 0;

    entry->fid.Vnode = cellnum2afs (cell->id);
d95 1
a95 1
    ret = fdir_creat (entry->thedir, cell->name, entry->fid);
d105 32
d161 5
a165 1
    ret = cell_foreach (create_entry_func, &entry);
d183 1
a183 1
    int len, ret;
d185 1
a185 1
    cell = cell_get_by_id (afs2cellnum (vnode));
d189 2
a190 1
    len = snprintf (name, sizeof(name), "#%s:root.cell.", cell->name);
d211 3
a213 1
    if (cell == 0 && strcmp (volume, "1") == 0)
d224 1
a224 1
dynroot_fetch_vldbN (nvldbentry *entry)
d228 1
a228 1
    strlcpy(entry->name, "root.cell", sizeof(entry->name));
d230 2
a231 2
    entry->volumeId[RWVOL] = DYNROOT_ROOTVOLUME;
    entry->flags = VLF_RWEXISTS;
d243 1
a243 1
		      xfs_pag_t cred)
d273 4
a276 4
    entry->status.spare1	= 0;
    entry->status.spare2	= 0;
    entry->status.spare3	= 0;
    entry->status.spare4	= 0;
d306 1
a306 2
    if (entry->flags.attrp &&
	entry->flags.datap &&
d335 5
d341 1
a341 1
    entry->length	 	= dir.len;
d348 1
a348 7
    dynroot_update_entry (entry, rootnode ? TYPE_DIR : TYPE_LINK,
			  ce->cred);

    entry->flags.attrp = TRUE;
    entry->flags.datap = TRUE;

    entry->tokens |= XFS_ATTR_R|XFS_DATA_R;
d384 1
a384 1
	entry->fid.Cell == dynrootcell &&
d419 1
a419 1
    return dynrootcell;
@


1.2
log
@don't play games with size_t (seeing a pattern yet ?)
@
text
@d17 1
a17 6
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by the Kungliga Tekniska
 *      Högskolan and its contributors.
 * 
 * 4. Neither the name of the Institute nor the names of its contributors
d42 1
a42 1
RCSID("$Id: dynroot.c,v 1.1 2000/09/11 14:40:41 art Exp $");
d85 3
d168 1
a168 1

d198 2
a199 1
dynroot_update_entry (FCacheEntry *entry, int32_t filetype)
d202 1
d212 10
a221 4
    entry->status.UnixModeBits	= 
	S_IRUSR|S_IXUSR|
	S_IRGRP|S_IXGRP|
	S_IROTH|S_IXOTH;
d244 3
a246 1
    /* XXX CallerAccess */
d254 1
a254 1
dynroot_get_node (FCacheEntry *entry)
d283 1
d300 2
a301 1
    dynroot_update_entry (entry, rootnode ? TYPE_DIR : TYPE_LINK);
d316 1
a316 1
dynroot_get_attr (FCacheEntry *entry)
d318 1
a318 1
    return dynroot_get_node (entry);
d327 1
a327 1
dynroot_get_data (FCacheEntry *entry)
d329 1
a329 1
    return dynroot_get_node (entry);
@


1.1
log
@New Arla userland from Arla between 0.34.2 and current in arla cvs.
Too many new features and fixes to mention here.
@
text
@d47 1
a47 1
RCSID("$Id: dynroot.c,v 1.9 2000/08/16 11:55:02 assar Exp $");
d248 2
a249 1
    int ret, fd, len, rootnode;
@


1.1.1.1
log
@Import of arla-0.35.7
@
text
@d17 6
a22 1
 * 3. Neither the name of the Institute nor the names of its contributors
d47 1
a47 1
RCSID("$KTH: dynroot.c,v 1.13.2.2 2001/05/28 15:19:20 map Exp $");
a89 3
    if (!cell_dynroot(cell))
	return 0;

d170 1
a170 1
    
d200 1
a200 2
dynroot_update_entry (FCacheEntry *entry, int32_t filetype,
		      xfs_pag_t cred)
a202 1
    AccessEntry *ae;
d212 4
a215 10
    switch (filetype) {
    case TYPE_DIR: 
	entry->status.UnixModeBits = 0755;
	break;
    case TYPE_LINK:
	entry->status.UnixModeBits = 0644;
	break;
    default:
	abort();
    }
d238 1
a238 3
    findaccess(cred, entry->acccache, &ae);
    ae->cred = cred;
    ae->access = entry->status.CallerAccess;
d246 1
a246 1
dynroot_get_node (FCacheEntry *entry, CredCacheEntry *ce)
d248 1
a248 2
    int ret, fd, rootnode;
    size_t len;
a273 1
	fcache_mark_as_mountpoint (entry);
d290 1
a290 2
    dynroot_update_entry (entry, rootnode ? TYPE_DIR : TYPE_LINK,
			  ce->cred);
d305 1
a305 1
dynroot_get_attr (FCacheEntry *entry, CredCacheEntry *ce)
d307 1
a307 1
    return dynroot_get_node (entry, ce);
d316 1
a316 1
dynroot_get_data (FCacheEntry *entry, CredCacheEntry *ce)
d318 1
a318 1
    return dynroot_get_node (entry, ce);
@


1.1.1.2
log
@Import of arla -current as of Aug 5 2003

ok todd@@ deraadt@@
@
text
@d2 1
a2 1
 * Copyright (c) 1999 - 2003 Kungliga Tekniska Högskolan
d42 1
a42 1
RCSID("$arla: dynroot.c,v 1.25 2003/01/20 14:21:02 lha Exp $");
a47 1
    int type;
d50 1
a50 2
#define DYNROOT_ROOTVOLUME 1		/* make sure that these */
#define DYNROOT_ROOTVOLUME_STR "1"	/* two are the same */
d54 1
d63 1
a63 1
cellnum2afs (int cellno, int rw)
d65 1
a65 4
    if (rw)
	return (cellno << 2) + 0x2;
    else
	return (cellno << 2) + 0x1;
d69 1
a69 1
afs2cellnum (int32_t afsvnode, int *rw)
d71 1
a71 5
    if (afsvnode & 0x2)
	*rw = 1;
    else
	*rw = 0;
    return afsvnode >> 2;
d76 1
a76 1
 * each `cell' with 'cellid' a entry in the root directory.
d80 1
a80 1
create_entry_func (const char *name, uint32_t cellid, int type, void *arg)
d85 4
a88 1
    entry->fid.Vnode = cellnum2afs (cellid, type & DYNROOT_ALIAS_READWRITE);
d90 1
a90 1
    ret = fdir_creat (entry->thedir, name, entry->fid);
a99 32
 * Wrapper function for cell_foreach that takes a `cell' instead of a
 * string and a cellid.
 */

static int
create_cell_entry_func (const cell_entry *cell, void *arg)
{
    if (!cell_dynroot(cell))
	return 0;
    return create_entry_func(cell->name, cell->id, 
			     DYNROOT_ALIAS_READONLY, arg);
}

/*
 *
 */

static int
create_alias_entry_func (const char *cellname, const char *alias, 
			 int type, void *arg)
{
    cell_entry *cell;

    cell = cell_get_by_name (cellname);
    if (cell == NULL)
	return 0;
    return create_entry_func(alias, cell->id, type, arg);

}


/*
d124 1
a124 5
    ret = cell_foreach (create_cell_entry_func, &entry);
    if (ret)
	return ret;

    ret = cell_alias_foreach(create_alias_entry_func, &entry);
d142 1
a142 1
    int len, ret, rw = 0;
d144 1
a144 1
    cell = cell_get_by_id (afs2cellnum (vnode, &rw));
d148 1
a148 2
    len = snprintf (name, sizeof(name), "%c%s:root.cell.", 
		    rw ? '%' : '#', cell->name);
d169 1
a169 3
    if (cell == 0 &&
	(strcmp (volume, "root.afs") == 0
	 || strcmp (volume, DYNROOT_ROOTVOLUME_STR) == 0))
d180 1
a180 1
dynroot_fetch_root_vldbN (nvldbentry *entry)
d184 1
a184 1
    strlcpy(entry->name, "root.afs", sizeof(entry->name));
d186 2
a187 2
    entry->volumeId[ROVOL] = DYNROOT_ROOTVOLUME;
    entry->flags = VLF_ROEXISTS;
d199 1
a199 1
		      nnpfs_pag_t cred)
d229 4
a232 4
    entry->status.DataVersionHigh= 0;
    entry->status.LockCount	= 0;
    entry->status.LengthHigh	= 0;
    entry->status.ErrorCode	= 0;
d262 2
a263 1
    if (entry->length != 0 &&
a291 5
    entry->flags.attrp = TRUE;

    dynroot_update_entry (entry, rootnode ? TYPE_DIR : TYPE_LINK,
			  ce->cred);

d293 1
a293 1
    fcache_update_length(entry, dir.len, dir.len);
d300 7
a306 1
    entry->tokens |= NNPFS_ATTR_R|NNPFS_DATA_R;
d342 1
a342 1
	entry->fid.Cell == DYNROOT_CELLID &&
d377 1
a377 1
    return DYNROOT_CELLID;
@


