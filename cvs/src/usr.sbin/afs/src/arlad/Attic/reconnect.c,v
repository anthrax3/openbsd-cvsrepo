head	1.7;
access;
symbols
	arla-20030805:1.1.1.2
	OPENBSD_3_3:1.4.0.4
	OPENBSD_3_3_BASE:1.4
	OPENBSD_3_2:1.4.0.2
	OPENBSD_3_2_BASE:1.4
	arla-0-35-7:1.1.1.1
	arla:1.1.1
	OPENBSD_3_1:1.2.0.8
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.6
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_9:1.2.0.4
	OPENBSD_2_8:1.2.0.2
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.1.0.4
	OPENBSD_2_7_BASE:1.1
	OPENBSD_2_6:1.1.0.2
	OPENBSD_2_6_BASE:1.1;
locks; strict;
comment	@ * @;


1.7
date	2003.08.12.14.40.59;	author hin;	state dead;
branches;
next	1.6;

1.6
date	2003.08.05.08.42.41;	author hin;	state Exp;
branches;
next	1.5;

1.5
date	2003.04.06.19.09.04;	author pvalchev;	state Exp;
branches;
next	1.4;

1.4
date	2002.08.08.09.25.13;	author ho;	state Exp;
branches;
next	1.3;

1.3
date	2002.06.07.04.28.57;	author hin;	state Exp;
branches;
next	1.2;

1.2
date	2000.09.11.14.40.43;	author art;	state Exp;
branches;
next	1.1;

1.1
date	99.04.30.01.59.10;	author art;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.06.07.04.14.25;	author hin;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.08.05.08.21.01;	author hin;	state Exp;
branches;
next	;


desc
@@


1.7
log
@These files are unused by us and have strcat/strcpy badness in them,
so they'll just go away.
@
text
@OBSOLETE /* COPYRIGHT  (C)  1998
OBSOLETE  * THE REGENTS OF THE UNIVERSITY OF MICHIGAN
OBSOLETE  * ALL RIGHTS RESERVED
OBSOLETE  * 
OBSOLETE  * PERMISSION IS GRANTED TO USE, COPY, CREATE DERIVATIVE WORKS 
OBSOLETE  * AND REDISTRIBUTE THIS SOFTWARE AND SUCH DERIVATIVE WORKS 
OBSOLETE  * FOR ANY PURPOSE, SO LONG AS THE NAME OF THE UNIVERSITY OF 
OBSOLETE  * MICHIGAN IS NOT USED IN ANY ADVERTISING OR PUBLICITY 
OBSOLETE  * PERTAINING TO THE USE OR DISTRIBUTION OF THIS SOFTWARE 
OBSOLETE  * WITHOUT SPECIFIC, WRITTEN PRIOR AUTHORIZATION.  IF THE 
OBSOLETE  * ABOVE COPYRIGHT NOTICE OR ANY OTHER IDENTIFICATION OF THE 
OBSOLETE  * UNIVERSITY OF MICHIGAN IS INCLUDED IN ANY COPY OF ANY 
OBSOLETE  * PORTION OF THIS SOFTWARE, THEN THE DISCLAIMER BELOW MUST 
OBSOLETE  * ALSO BE INCLUDED.
OBSOLETE  * 
OBSOLETE  * THIS SOFTWARE IS PROVIDED AS IS, WITHOUT REPRESENTATION 
OBSOLETE  * FROM THE UNIVERSITY OF MICHIGAN AS TO ITS FITNESS FOR ANY 
OBSOLETE  * PURPOSE, AND WITHOUT WARRANTY BY THE UNIVERSITY OF 
OBSOLETE  * MICHIGAN OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING 
OBSOLETE  * WITHOUT LIMITATION THE IMPLIED WARRANTIES OF 
OBSOLETE  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE 
OBSOLETE  * REGENTS OF THE UNIVERSITY OF MICHIGAN SHALL NOT BE LIABLE 
OBSOLETE  * FOR ANY DAMAGES, INCLUDING SPECIAL, INDIRECT, INCIDENTAL, OR 
OBSOLETE  * CONSEQUENTIAL DAMAGES, WITH RESPECT TO ANY CLAIM ARISING 
OBSOLETE  * OUT OF OR IN CONNECTION WITH THE USE OF THE SOFTWARE, EVEN 
OBSOLETE  * IF IT HAS BEEN OR IS HEREAFTER ADVISED OF THE POSSIBILITY OF 
OBSOLETE  * SUCH DAMAGES.
OBSOLETE  */
OBSOLETE 
OBSOLETE /*
OBSOLETE  * Do merging of the files that changed with we was in disconnected mode
OBSOLETE  */
OBSOLETE 
OBSOLETE #if 0
OBSOLETE 
OBSOLETE #include "arla_local.h"
OBSOLETE 
OBSOLETE RCSID("$arla: reconnect.c,v 1.37 2002/09/07 10:43:27 lha Exp $");
OBSOLETE 
OBSOLETE static int reconnect_nonmute(struct vcache *, int, struct timeval);
OBSOLETE static int reconnect_putattr(struct vcache *, struct nnpfs_attr *);
OBSOLETE static int reconnect_putdata(struct vcache *);    
OBSOLETE static int reconnect_remove(struct vcache *, FCacheEntry *childentry, char *);
OBSOLETE static int reconnect_rename(struct vcache *, struct vcache *, char *, char *);
OBSOLETE static int reconnect_rmdir(struct vcache *vcp, FCacheEntry *childEntry,
OBSOLETE 			   char *name);
OBSOLETE static int reconnect_mkdir(struct vcache *parent, struct vcache *curdir, 
OBSOLETE 			   AFSStoreStatus *store_status, char *name);
OBSOLETE static int reconnect_link(struct vcache *parent, struct vcache *existing,
OBSOLETE 			  char *name);
OBSOLETE static int reconnect_symlink(struct vcache *parent, struct vcache *child,
OBSOLETE 			     AFSStoreStatus *store_attr, char *name, 
OBSOLETE 			     char *contents);
OBSOLETE static int reconnect_create(struct vcache *parent, struct vcache *child,
OBSOLETE 			    char *name);
OBSOLETE static int reconnect_mut_chk(FCacheEntry *fce, CredCacheEntry *ce,
OBSOLETE 			     int version);
OBSOLETE 
OBSOLETE static int check_log_todo(log_ent_t * , VenusFid *, VenusFid *);
OBSOLETE static int is_done_before(int no);
OBSOLETE static void add_done_list(int no);
OBSOLETE static void clear_log_entry(void);
OBSOLETE static void clear_index_list(void);
OBSOLETE 
OBSOLETE typedef struct _fid_trans{
OBSOLETE     VenusFid logged_fid;
OBSOLETE     VenusFid fetched_fid;
OBSOLETE     struct _fid_trans *next, *prev;
OBSOLETE } fid_trans;
OBSOLETE 
OBSOLETE typedef struct _fid_keep{
OBSOLETE     char name[MAX_NAME];
OBSOLETE     AFSFid kept_fid;
OBSOLETE     struct _fid_keep *next;
OBSOLETE } fid_keep;
OBSOLETE 
OBSOLETE typedef struct _index_list{
OBSOLETE     int   index;
OBSOLETE     struct _index_list * next;
OBSOLETE } index_list;
OBSOLETE 
OBSOLETE fid_trans *fid_AD_head, *fid_AD_tail;
OBSOLETE fid_keep  *fid_KP_head;
OBSOLETE index_list * index_head;
OBSOLETE extern log_ent_t  log_head;
OBSOLETE 
OBSOLETE 
OBSOLETE /*
OBSOLETE  *
OBSOLETE  */
OBSOLETE 
OBSOLETE static void
OBSOLETE set_fid_value(VenusFid *new, VenusFid *old)
OBSOLETE {
OBSOLETE     if(old==0) {
OBSOLETE 	new->fid.Volume = 0;
OBSOLETE 	new->fid.Vnode = 0;
OBSOLETE 	new->fid.Unique = 0;
OBSOLETE     } else {
OBSOLETE 	new->fid.Volume = old->fid.Volume;
OBSOLETE 	new->fid.Vnode  = old->fid.Vnode;
OBSOLETE         new->fid.Unique = old->fid.Unique;
OBSOLETE     }
OBSOLETE }
OBSOLETE 
OBSOLETE /*
OBSOLETE  *
OBSOLETE  */
OBSOLETE 
OBSOLETE void 
OBSOLETE do_replay(char *log_file, int log_entries, VenusFid *changed_fid)
OBSOLETE {
OBSOLETE     int fd, len, i;
OBSOLETE     log_ent_t *cur_log;
OBSOLETE     struct vcache vc, vc_new;
OBSOLETE     char *name, *name_new;
OBSOLETE     fid_trans *fid_tmp;
OBSOLETE     fid_keep * fid_KP_tail;
OBSOLETE     VenusFid new_fid; 
OBSOLETE 
OBSOLETE     int count=1; /* Used to record how may actions we have done*/
OBSOLETE 
OBSOLETE     fid_AD_tail = fid_AD_head;
OBSOLETE     cur_log = (log_ent_t *) malloc(sizeof(log_ent_t));
OBSOLETE     fd = open(log_file, O_RDWR | O_BINARY);
OBSOLETE 
OBSOLETE     set_fid_value(&new_fid , 0);
OBSOLETE 
OBSOLETE     while (read(fd, cur_log, sizeof(int))){
OBSOLETE 
OBSOLETE 	if (cur_log->log_len < sizeof(*cur_log) - sizeof(cur_log->log_data) ||
OBSOLETE             cur_log->log_len > sizeof(log_ent_t)) {
OBSOLETE 	    arla_log(ADEBDISCONN, "do_replay: corrupt log entry, log_len %d",
OBSOLETE 		     cur_log->log_len);
OBSOLETE 	    goto terminate;
OBSOLETE 	}
OBSOLETE 
OBSOLETE 	len = cur_log->log_len - sizeof(int);
OBSOLETE 
OBSOLETE 	if (!read(fd, ((char *)cur_log + sizeof(int)), len)){
OBSOLETE 	    arla_log(ADEBDISCONN, "do_replay: read bad log entry...");
OBSOLETE 	    goto terminate;
OBSOLETE 	}
OBSOLETE 
OBSOLETE 	arla_log(ADEBDISCONN, 
OBSOLETE 		 "do_replay: read %d bytes of log entry.", 
OBSOLETE 		 cur_log->log_len);
OBSOLETE 
OBSOLETE 	if (is_done_before(cur_log->log_index)==1)
OBSOLETE 	    continue; /* the log entry has been executed */
OBSOLETE 	else {
OBSOLETE 	    if (changed_fid !=0) {
OBSOLETE 		int is_log_todo = 0;
OBSOLETE  
OBSOLETE 		is_log_todo = check_log_todo(cur_log, changed_fid, &new_fid);
OBSOLETE 		if (is_log_todo ==0)
OBSOLETE 		    continue; /* This log should not be  executed */
OBSOLETE 	    }
OBSOLETE 	}
OBSOLETE 
OBSOLETE 	add_done_list(cur_log->log_index);
OBSOLETE 
OBSOLETE 	/* big case/switch statement to switch log_op  */
OBSOLETE 	switch (cur_log->log_op){
OBSOLETE 
OBSOLETE 	case DIS_STORE:
OBSOLETE 	    vc.fid = cur_log->st_fid;
OBSOLETE 	    vc.DataVersion = cur_log->st_origdv-1;
OBSOLETE 	    vc.flag = cur_log->st_flag;
OBSOLETE 	    vc.cred = cur_log->cred;
OBSOLETE 	    arla_log(ADEBDISCONN, 
OBSOLETE 		     "%d action is to do_replay: **replay** (putdata) op...",
OBSOLETE 		     count++);
OBSOLETE 	    reconnect_putdata(&vc);
OBSOLETE 	    break;
OBSOLETE 	case DIS_SETATTR:
OBSOLETE 	    vc.fid = cur_log->sa_fid;
OBSOLETE 	    vc.DataVersion = cur_log->sa_origdv;
OBSOLETE 	    vc.flag = 0;
OBSOLETE 	    vc.cred = cur_log->cred;
OBSOLETE 	    arla_log(ADEBDISCONN, 
OBSOLETE 		     "%d action is to do_replay: **replay** (putattr) op...",
OBSOLETE 		     count++);
OBSOLETE 	    reconnect_putattr(&vc, &(cur_log->sa_vattr));
OBSOLETE 	    break;
OBSOLETE 	case DIS_REMOVE: {
OBSOLETE 	    FCacheEntry *childentry;
OBSOLETE 	    vc.fid = cur_log->rm_filefid;
OBSOLETE 	    vc.DataVersion = cur_log->rm_origdv;
OBSOLETE 	    vc.flag = 0;
OBSOLETE 	    vc.cred = cur_log->cred;
OBSOLETE 	    childentry = cur_log->rm_chentry;
OBSOLETE 	    name = cur_log->rm_name;
OBSOLETE 	    arla_log(ADEBDISCONN, 
OBSOLETE 		     "%d action is to do_replay: **replay** "
OBSOLETE 		     "(file remove) op...",
OBSOLETE 		     count++);
OBSOLETE 	    reconnect_remove(&vc, childentry, name);
OBSOLETE 	    break;
OBSOLETE 	}
OBSOLETE 	case DIS_RMDIR: {
OBSOLETE 	    FCacheEntry *child;
OBSOLETE 	    vc.fid = cur_log->rd_parentfid;
OBSOLETE 	    name = cur_log->rd_name;
OBSOLETE 	    vc.cred = cur_log->cred;
OBSOLETE 	    child = cur_log->rd_direntry;
OBSOLETE 	    arla_log (ADEBDISCONN,
OBSOLETE 		      "%d action is to do_replay: **rmdir** "
OBSOLETE 		      "(directory remove) op...",
OBSOLETE 		      count++);
OBSOLETE 	    reconnect_rmdir(&vc, child, name);
OBSOLETE 	    break;
OBSOLETE 	}
OBSOLETE 	case DIS_RENAME:
OBSOLETE 	    vc.fid = cur_log->rn_oparentfid;
OBSOLETE 	    vc.DataVersion = cur_log->rn_origdv;
OBSOLETE 	    vc.flag = 0;
OBSOLETE 	    vc.cred = cur_log->cred;
OBSOLETE 	    vc_new.fid = cur_log->rn_nparentfid;
OBSOLETE 	    vc_new.DataVersion = cur_log->rn_overdv;
OBSOLETE 	    vc_new.flag = 0;
OBSOLETE 	    vc_new.cred = cur_log->cred;
OBSOLETE 	    name = cur_log->rn_names;
OBSOLETE 	    for (i=0; *(name+i)!='\0';++i);
OBSOLETE 	    name_new = name+i+1; 
OBSOLETE 	    arla_log(ADEBDISCONN, 
OBSOLETE 		     "%d action is to do_replay: **replay** (rename) op...",
OBSOLETE 		     count++);
OBSOLETE 	    reconnect_rename(&vc, &vc_new, name, name_new);
OBSOLETE 	    break;
OBSOLETE 	case DIS_MKDIR:	{ 
OBSOLETE 	    AFSStoreStatus store_status;
OBSOLETE 	    vc.fid = cur_log->md_parentfid;
OBSOLETE 	    vc.cred = cur_log->cred;
OBSOLETE 	    store_status = cur_log->md_vattr;
OBSOLETE 	    vc_new.fid = cur_log->md_dirfid;
OBSOLETE 	    /*Ba Wu: child's data vers*/
OBSOLETE 	    vc_new.DataVersion = cur_log->md_dversion; 
OBSOLETE 	    name = cur_log->md_name;
OBSOLETE 	    arla_log(ADEBDISCONN, 
OBSOLETE 		     "%d action is to DO_Replay: **replay** (mkdir) op...",
OBSOLETE 		     count++);
OBSOLETE 	    reconnect_mkdir(&vc, &vc_new, &store_status, name);
OBSOLETE 	    break; 
OBSOLETE 	}
OBSOLETE 	case DIS_LINK:
OBSOLETE 	    vc.cred = cur_log->cred;
OBSOLETE 	    vc.fid = cur_log->ln_parentfid;
OBSOLETE 	    vc_new.fid = cur_log->ln_linkfid;
OBSOLETE 	    name = cur_log->ln_name;
OBSOLETE 	    arla_log(ADEBDISCONN, 
OBSOLETE 		     "%d action is to do_replay: **replay** (link) op...",
OBSOLETE 		     count++);
OBSOLETE 	    reconnect_link(&vc, &vc_new, name);
OBSOLETE 	    break;
OBSOLETE 	case DIS_SYMLINK: {
OBSOLETE 	    char *new_name;
OBSOLETE 	    AFSStoreStatus store_attr;
OBSOLETE 	    
OBSOLETE 	    vc.fid = cur_log->sy_parentfid;
OBSOLETE 	    vc.cred = cur_log->cred;
OBSOLETE 	    name = cur_log->sy_name;
OBSOLETE 	    new_name = cur_log->sy_content;
OBSOLETE 	    vc_new.fid = cur_log->sy_filefid;
OBSOLETE 	    store_attr = cur_log->sy_attr;
OBSOLETE 	    arla_log(ADEBDISCONN, 
OBSOLETE 		     "%d action is to do_replay: **replay** (symlink) op...",
OBSOLETE 		     count++);
OBSOLETE 	    reconnect_symlink(&vc, &vc_new, &store_attr, name, new_name);
OBSOLETE 	    break;
OBSOLETE 	}
OBSOLETE 	case DIS_CREATE:
OBSOLETE 	    vc.fid = cur_log->cr_parentfid;
OBSOLETE 	    vc.cred = cur_log->cred;
OBSOLETE  
OBSOLETE 	    vc_new.fid = cur_log->cr_filefid;
OBSOLETE 	    vc_new.DataVersion = cur_log->cr_origdv;
OBSOLETE 	    arla_log(ADEBDISCONN, 
OBSOLETE 		     "%d action is to DO_Replay: **replay** (create) op...",
OBSOLETE 		     count++);
OBSOLETE 	    name = cur_log->cr_name;
OBSOLETE 	    reconnect_create(&vc, &vc_new, name); 
OBSOLETE 	    break; 
OBSOLETE 	case DIS_ACCESS:
OBSOLETE 	    vc.fid = cur_log->nm_fid;
OBSOLETE 	    vc.DataVersion = cur_log->nm_origdv;
OBSOLETE 	    vc.cred = cur_log->cred;
OBSOLETE 	    arla_log(ADEBDISCONN, 
OBSOLETE 		     "%d action is to do_replay: **replay** (nonmutating) op",
OBSOLETE 		     count++);
OBSOLETE 	    reconnect_nonmute(&vc, cur_log->log_op, cur_log->log_time);
OBSOLETE 	    break; 
OBSOLETE 
OBSOLETE 	default:
OBSOLETE 	    arla_log(ADEBDISCONN, 
OBSOLETE 		     "%d action is to do_replay: skipping the current op=%d", 
OBSOLETE 		     count++,cur_log->log_op);
OBSOLETE 	}
OBSOLETE     }  
OBSOLETE 
OBSOLETE     if (changed_fid ==0) {
OBSOLETE 	clear_index_list();  /* clean all index when after discon */
OBSOLETE 	clear_log_entry();
OBSOLETE         /* clean up, remove all associative data structures */
OBSOLETE         fid_AD_tail = fid_AD_head;
OBSOLETE   	while(fid_AD_tail)
OBSOLETE   	{
OBSOLETE 	    fid_tmp = fid_AD_tail->next;
OBSOLETE 	    free(fid_AD_tail);
OBSOLETE 	    fid_AD_tail = fid_tmp; 
OBSOLETE   	}   
OBSOLETE 	/* SWW Qiyue 28: We need to reset head to 0*/
OBSOLETE   	fid_AD_head = 0;
OBSOLETE   	fid_KP_tail = fid_KP_head;
OBSOLETE     	while(fid_KP_tail)
OBSOLETE     	{
OBSOLETE 	    fid_keep *fid_tmp;
OBSOLETE 	
OBSOLETE 	    fid_tmp = fid_KP_tail->next;
OBSOLETE 	    free(fid_KP_tail);
OBSOLETE 	    fid_KP_tail = fid_tmp;
OBSOLETE     	}
OBSOLETE    	 
OBSOLETE   	fid_KP_head = 0;
OBSOLETE     }
OBSOLETE     i = ftruncate (fd, 0);
OBSOLETE     assert (i == 0);
OBSOLETE 
OBSOLETE  terminate:
OBSOLETE 
OBSOLETE     arla_warnx (ADEBDISCONN,"We have done total %d replays",count-1);
OBSOLETE     close(fd);  
OBSOLETE     free(cur_log);
OBSOLETE     return;
OBSOLETE }
OBSOLETE 
OBSOLETE /*
OBSOLETE  *
OBSOLETE  */
OBSOLETE 
OBSOLETE static int 
OBSOLETE check_rm_fid (VenusFid v1, VenusFid v2)
OBSOLETE {
OBSOLETE     if(v1.fid.Vnode == v2.fid.Vnode &&
OBSOLETE        v1.fid.Volume == v2.fid.Volume &&
OBSOLETE        v1.fid.Unique == v2.fid.Unique )
OBSOLETE 	return 1;
OBSOLETE     else
OBSOLETE 	return 0;
OBSOLETE }
OBSOLETE 
OBSOLETE /*
OBSOLETE  *
OBSOLETE  */
OBSOLETE 
OBSOLETE static int 
OBSOLETE check_log_fid(struct vcache vc, VenusFid *fid)
OBSOLETE {
OBSOLETE     log_ent_t *temp = log_head.next;
OBSOLETE 
OBSOLETE     if (vc.fid.fid.Vnode == fid->fid.Vnode &&
OBSOLETE 	vc.fid.fid.Volume == fid->fid.Volume &&
OBSOLETE 	vc.fid.fid.Unique == fid->fid.Unique)
OBSOLETE 	return 1;
OBSOLETE 
OBSOLETE     while (temp!=0) {
OBSOLETE 	switch(temp->log_op) {
OBSOLETE 	case DIS_RENAME:
OBSOLETE 	    if (check_rm_fid(temp->rn_oparentfid,*fid)==1) 
OBSOLETE 		return 1;
OBSOLETE 	default: 
OBSOLETE 	    temp = temp->next;
OBSOLETE 	    break;
OBSOLETE         }
OBSOLETE     }
OBSOLETE     return 0;
OBSOLETE }
OBSOLETE 
OBSOLETE /*
OBSOLETE  *
OBSOLETE  */
OBSOLETE 
OBSOLETE static int 
OBSOLETE check_log_todo(log_ent_t * cur_log , VenusFid *fid, VenusFid *newfid)
OBSOLETE {
OBSOLETE     VenusFid *lookfid;
OBSOLETE     struct vcache vc, vc_new;
OBSOLETE     int will_do = 0;
OBSOLETE 
OBSOLETE     if (newfid->fid.Vnode ==0 &&
OBSOLETE 	newfid->fid.Volume == 0 &&
OBSOLETE 	newfid->fid.Unique ==0)
OBSOLETE 	lookfid = fid;
OBSOLETE     else
OBSOLETE 	lookfid = newfid; /* For create and putdata */
OBSOLETE 
OBSOLETE     switch (cur_log->log_op){
OBSOLETE     case DIS_STORE:
OBSOLETE         vc.fid = cur_log->st_fid;
OBSOLETE 	will_do = check_log_fid(vc, lookfid);
OBSOLETE         if (will_do==1) {
OBSOLETE 	    set_fid_value(newfid, 0);
OBSOLETE 	    return 1;
OBSOLETE         }
OBSOLETE         break;
OBSOLETE     case DIS_SETATTR:
OBSOLETE 	vc.fid = cur_log->sa_fid;
OBSOLETE 	will_do = check_log_fid(vc, lookfid);
OBSOLETE         if (will_do==1) {
OBSOLETE 	    set_fid_value(newfid , &cur_log->sa_fid);
OBSOLETE 	    return 1;
OBSOLETE         }
OBSOLETE         break;
OBSOLETE     case DIS_REMOVE:
OBSOLETE 	vc.fid = cur_log->rm_filefid;
OBSOLETE 	will_do = check_log_fid(vc, lookfid);
OBSOLETE         if (will_do==1) {
OBSOLETE 	    return 1;
OBSOLETE         }
OBSOLETE         break;
OBSOLETE     case DIS_RMDIR:
OBSOLETE 	vc.fid = cur_log->rd_parentfid;
OBSOLETE 	will_do = check_log_fid(vc, lookfid);
OBSOLETE         if (will_do==1) {
OBSOLETE 	    return 1;
OBSOLETE         }
OBSOLETE         break;
OBSOLETE     case DIS_RENAME:
OBSOLETE 	vc.fid = cur_log->rn_oparentfid;
OBSOLETE 	will_do = check_log_fid(vc, lookfid);
OBSOLETE         if (will_do==1) {
OBSOLETE 	    return 1;
OBSOLETE         }
OBSOLETE 	vc_new.fid = cur_log->rn_nparentfid;
OBSOLETE 	will_do = check_log_fid(vc_new, lookfid);
OBSOLETE         if (will_do==1) {
OBSOLETE 	    return 1;
OBSOLETE         }
OBSOLETE         break;
OBSOLETE     case DIS_MKDIR:
OBSOLETE 	vc.fid = cur_log->md_parentfid;
OBSOLETE 	will_do = check_log_fid(vc, lookfid);
OBSOLETE         if (will_do==1) {
OBSOLETE 	    return 1;
OBSOLETE         }
OBSOLETE 	break;
OBSOLETE     case DIS_LINK:
OBSOLETE         break;
OBSOLETE     case DIS_SYMLINK:
OBSOLETE 	will_do = check_log_fid(vc, lookfid);
OBSOLETE         if (will_do==1) {
OBSOLETE 	    return 1;
OBSOLETE         }
OBSOLETE         break;
OBSOLETE     case DIS_CREATE:
OBSOLETE 	vc.fid = cur_log->cr_parentfid;
OBSOLETE         will_do = check_log_fid(vc, lookfid);
OBSOLETE 	if (will_do==1) {
OBSOLETE 	    set_fid_value(newfid , &cur_log->cr_filefid);
OBSOLETE 	    return 1;
OBSOLETE 	}
OBSOLETE 	break;
OBSOLETE     case DIS_FSYNC:
OBSOLETE     case DIS_ACCESS:
OBSOLETE     case DIS_READDIR:
OBSOLETE     case DIS_READLINK:
OBSOLETE     case DIS_INFO:
OBSOLETE     case DIS_START_OPT:
OBSOLETE     case DIS_END_OPT:
OBSOLETE     case DIS_REPLAYED:
OBSOLETE 	/* A no op */
OBSOLETE 	break;
OBSOLETE     }
OBSOLETE     return 0;
OBSOLETE }
OBSOLETE 
OBSOLETE 
OBSOLETE #if 0
OBSOLETE 
OBSOLETE /*
OBSOLETE  *
OBSOLETE  */
OBSOLETE 
OBSOLETE void
OBSOLETE keepfid_newrename(char *name,
OBSOLETE 		  AFSFid fid)
OBSOLETE {
OBSOLETE     if (fid_KP_head == 0) {
OBSOLETE         fid_KP_head = (fid_keep *)malloc(sizeof(fid_keep));
OBSOLETE         assert(fid_KP_head);
OBSOLETE 
OBSOLETE         strcpy(fid_KP_head->name, name);
OBSOLETE 	fid_KP_head->kept_fid = fid;
OBSOLETE 	fid_KP_head->next = 0;
OBSOLETE     }
OBSOLETE     else { 
OBSOLETE         fid_keep *temp;
OBSOLETE 
OBSOLETE         temp = (fid_keep *)malloc(sizeof(fid_keep));
OBSOLETE 	assert(temp);
OBSOLETE 
OBSOLETE         strcpy(temp->name, name);
OBSOLETE 	temp->name[strlen(name)] = '\0';
OBSOLETE 	temp->kept_fid = fid;
OBSOLETE 	temp->next = fid_KP_head->next;
OBSOLETE 	fid_KP_head->next = temp;
OBSOLETE     }
OBSOLETE }
OBSOLETE 
OBSOLETE #endif
OBSOLETE 
OBSOLETE /*
OBSOLETE  *
OBSOLETE  */
OBSOLETE 
OBSOLETE static int 
OBSOLETE find_venus (char *name, VenusFid *fid)
OBSOLETE {
OBSOLETE     fid_keep *fid_temp;
OBSOLETE 
OBSOLETE     if(fid_KP_head == 0 )
OBSOLETE 	return 1;  /*error */
OBSOLETE   	
OBSOLETE     fid_temp = fid_KP_head;
OBSOLETE 
OBSOLETE     while(fid_temp) {
OBSOLETE 	if (strcmp(fid_temp->name,name) == 0) {
OBSOLETE 	    fid->fid.Volume = fid_temp->kept_fid.Volume;
OBSOLETE 	    fid->fid.Vnode = fid_temp->kept_fid.Vnode;
OBSOLETE 	    fid->fid.Unique = fid_temp->kept_fid.Unique;
OBSOLETE 	    return 0;
OBSOLETE         }
OBSOLETE 	fid_temp = fid_temp->next;
OBSOLETE     }
OBSOLETE     arla_warnx (ADEBDISCONN, "find_venus: *PANIC* not found fid for %s", name);
OBSOLETE     return 1;
OBSOLETE }
OBSOLETE 
OBSOLETE 
OBSOLETE /*
OBSOLETE  *
OBSOLETE  */
OBSOLETE 
OBSOLETE VenusFid *
OBSOLETE fid_translate(VenusFid *fid_in)
OBSOLETE {
OBSOLETE     fid_trans *fid_tmp;
OBSOLETE     VenusFid *fid_ret;
OBSOLETE 
OBSOLETE     if (!fid_AD_head)
OBSOLETE 	return fid_in;
OBSOLETE 
OBSOLETE     fid_tmp = fid_AD_head;
OBSOLETE 
OBSOLETE     while(fid_tmp){
OBSOLETE 
OBSOLETE 	fid_ret=&fid_tmp->logged_fid;
OBSOLETE 
OBSOLETE 	if ((fid_ret->Cell == fid_in->Cell) && 
OBSOLETE 	    (fid_ret->fid.Volume == fid_in->fid.Volume) && 
OBSOLETE 	    (fid_ret->fid.Vnode == fid_in->fid.Vnode) && 
OBSOLETE 	    (fid_ret->fid.Unique == fid_in->fid.Unique))
OBSOLETE 	    return &fid_tmp->fetched_fid;
OBSOLETE 
OBSOLETE 	fid_tmp = fid_tmp->next;	   
OBSOLETE     }
OBSOLETE     return fid_in; 
OBSOLETE }
OBSOLETE 
OBSOLETE /*
OBSOLETE  *
OBSOLETE  */
OBSOLETE 
OBSOLETE static void 
OBSOLETE clear_index_list(void)
OBSOLETE {
OBSOLETE     index_list *temp=index_head;
OBSOLETE 
OBSOLETE     while(temp!=0) {
OBSOLETE 	index_list *tmp;
OBSOLETE     
OBSOLETE   	tmp = temp->next;
OBSOLETE         free(temp);
OBSOLETE 	temp = tmp;
OBSOLETE     }
OBSOLETE     index_head = 0;
OBSOLETE }
OBSOLETE 
OBSOLETE /*
OBSOLETE  *
OBSOLETE  */
OBSOLETE 
OBSOLETE static void 
OBSOLETE clear_log_entry(void)
OBSOLETE {
OBSOLETE     log_ent_t *temp=log_head.next;
OBSOLETE 
OBSOLETE     while(temp!=0) {             
OBSOLETE         log_ent_t *tmp;
OBSOLETE 
OBSOLETE         tmp = temp->next;
OBSOLETE         free(temp);                          
OBSOLETE         temp = tmp;
OBSOLETE     }                        
OBSOLETE     log_head.next = 0;    
OBSOLETE }
OBSOLETE 
OBSOLETE /*
OBSOLETE  *
OBSOLETE  */
OBSOLETE 
OBSOLETE static int 
OBSOLETE is_done_before(int no)
OBSOLETE {
OBSOLETE     index_list * temp = index_head;
OBSOLETE 
OBSOLETE     while(temp !=0) {
OBSOLETE 	if (temp->index == no)
OBSOLETE 	    return 1;
OBSOLETE 	else
OBSOLETE 	    temp = temp->next;
OBSOLETE     }
OBSOLETE     return 0;
OBSOLETE }
OBSOLETE 
OBSOLETE /*
OBSOLETE  *
OBSOLETE  */
OBSOLETE 
OBSOLETE static void 
OBSOLETE add_done_list(int no)
OBSOLETE {
OBSOLETE     if (!index_head) {
OBSOLETE 	index_head = (index_list *)malloc(sizeof(index_list));
OBSOLETE 	assert(index_head);
OBSOLETE 	index_head->index = no;
OBSOLETE 	index_head->next = 0;
OBSOLETE     } else {
OBSOLETE 	index_list * temp;
OBSOLETE 	temp = (index_list *) malloc(sizeof(index_list));
OBSOLETE 	assert(temp);
OBSOLETE 	temp->next = index_head->next;
OBSOLETE 	index_head->next = temp;
OBSOLETE 	temp->index = no;
OBSOLETE     }
OBSOLETE }
OBSOLETE 
OBSOLETE /*
OBSOLETE  *
OBSOLETE  */
OBSOLETE 
OBSOLETE static void 
OBSOLETE alloc_fid_trans(VenusFid *logged_fid)
OBSOLETE {
OBSOLETE     if (!fid_AD_head)
OBSOLETE     {
OBSOLETE 	/*SWW Qiyue 28 Make sure we have the memory*/
OBSOLETE 	fid_AD_head = (fid_trans *) malloc(sizeof(fid_trans)); 
OBSOLETE 	assert(fid_AD_head);
OBSOLETE 
OBSOLETE 	fid_AD_head->prev=fid_AD_head->next = 0;
OBSOLETE 	fid_AD_tail = fid_AD_head;
OBSOLETE 	fid_AD_tail->logged_fid = *logged_fid;
OBSOLETE 
OBSOLETE     } else{
OBSOLETE 
OBSOLETE 	/*SWW Qiyue 28 Make sure we have the memory*/
OBSOLETE 	fid_AD_tail->next = (fid_trans *) malloc(sizeof(fid_trans)); 
OBSOLETE 	assert(fid_AD_tail->next);
OBSOLETE 
OBSOLETE 	fid_AD_tail->next->prev = fid_AD_tail;
OBSOLETE 	fid_AD_tail->next->next = 0;
OBSOLETE 	fid_AD_tail = fid_AD_tail->next;  /*Ba ba: move tail ahead */
OBSOLETE 	fid_AD_tail->logged_fid = *logged_fid;
OBSOLETE     }
OBSOLETE }
OBSOLETE 
OBSOLETE /*
OBSOLETE  *
OBSOLETE  */
OBSOLETE 
OBSOLETE static void 
OBSOLETE fill_fid_trans (VenusFid *fetched_fid)
OBSOLETE {
OBSOLETE     fid_AD_tail->fetched_fid = *fetched_fid;
OBSOLETE }
OBSOLETE 
OBSOLETE /*
OBSOLETE  *
OBSOLETE  */
OBSOLETE 
OBSOLETE #if 0
OBSOLETE void
OBSOLETE update_entry_flag (FCacheEntry *entry)
OBSOLETE {
OBSOLETE     entry->flags.attrp = FALSE;
OBSOLETE     entry->flags.datap = FALSE;
OBSOLETE }
OBSOLETE #endif
OBSOLETE 
OBSOLETE /*
OBSOLETE  *
OBSOLETE  */
OBSOLETE 
OBSOLETE int reconnect_nonmute(struct vcache *vcp, int op, struct timeval log_time)
OBSOLETE {
OBSOLETE     FCacheEntry *fce, fce_fetched;
OBSOLETE     CredCacheEntry *ce;
OBSOLETE     int error;
OBSOLETE     VenusFid *fid; 
OBSOLETE #if 0
OBSOLETE     ConnCacheEntry *conn;
OBSOLETE #endif
OBSOLETE 
OBSOLETE     arla_warnx (ADEBDISCONN,
OBSOLETE 		"Start of reconnect_nonmute by sww"); /*SWW Qiyue 25*/
OBSOLETE 
OBSOLETE     fid = &(vcp->fid);
OBSOLETE     if (fid->Cell == -1) /* newly created file, skip reconnect */
OBSOLETE 	return 0;
OBSOLETE 
OBSOLETE     error = fcache_find(&fce, *fid);
OBSOLETE     /* assert(fce); */
OBSOLETE     if (error) /* nonmute op on nonexisting data */
OBSOLETE     {     
OBSOLETE 	arla_log(ADEBDISCONN, 
OBSOLETE 		 "reconnect: nonmute op %d performed on cache "
OBSOLETE 		 "entry no longer exist locally!", 
OBSOLETE 		 op); 
OBSOLETE 	return -1;
OBSOLETE     }   
OBSOLETE 
OBSOLETE     arla_log(ADEBDISCONN, 
OBSOLETE 	     "reconnect: DISCONNECTED nonmute "
OBSOLETE 	     "on fid.Cell=0x%x, fid.fid.Volume= 0x%x, fid.fid.Vnode=0x%x, "
OBSOLETE 	     "fid.fid.Unique=0x%x", fid->Cell, 
OBSOLETE 	     fid->fid.Volume,
OBSOLETE 	     fid->fid.Vnode, 
OBSOLETE 	     fid->fid.Unique);  
OBSOLETE 
OBSOLETE     ce = cred_get (fid->Cell, vcp->cred.pag, CRED_ANY);
OBSOLETE     assert (ce != NULL);
OBSOLETE     error = 0;
OBSOLETE   
OBSOLETE     /* setting some stuff so do_read_attr would work */
OBSOLETE     fce->flags.attrp = TRUE;
OBSOLETE     fce->callback.CallBackType = 2;
OBSOLETE     fce_fetched = *fce;
OBSOLETE     /*conn = findconn (fce, ce);*/
OBSOLETE 
OBSOLETE     error = read_attr(&fce_fetched, ce);
OBSOLETE 
OBSOLETE     arla_log(ADEBDISCONN, 
OBSOLETE 	     "reconnect: logged DataVersion=%d, "
OBSOLETE 	     "fetched DataVersion=%d", 
OBSOLETE 	     vcp->DataVersion,
OBSOLETE 	     fce_fetched.status.DataVersion);
OBSOLETE  
OBSOLETE     if (vcp->DataVersion < fce_fetched.status.DataVersion)
OBSOLETE     {
OBSOLETE 	if (log_time.tv_usec >= fce_fetched.status.ServerModTime)
OBSOLETE 	    arla_log(ADEBDISCONN, 
OBSOLETE 		     "Warning: nonmutating operation %d read stale data!", 
OBSOLETE 		     op);
OBSOLETE 	else if (log_time.tv_usec <= fce_fetched.status.ServerModTime && 
OBSOLETE 		 (vcp->DataVersion +1) == fce_fetched.status.DataVersion)
OBSOLETE 	    arla_log(ADEBDISCONN, 
OBSOLETE 		     "Notice: file modified once after nonmutating "
OBSOLETE 		     "operation %d.",
OBSOLETE 		     op);
OBSOLETE 	else
OBSOLETE 	    arla_log(ADEBDISCONN, 
OBSOLETE 		     "Warning: nonmutating operation %d might have read "
OBSOLETE 		     "stale data!", op);
OBSOLETE     } 
OBSOLETE  
OBSOLETE     ReleaseWriteLock(&fce->lock);
OBSOLETE     cred_free(ce);
OBSOLETE     /*conn_free(conn);*/
OBSOLETE 
OBSOLETE     return error;
OBSOLETE }
OBSOLETE 
OBSOLETE /*
OBSOLETE  *
OBSOLETE  */
OBSOLETE 
OBSOLETE int reconnect_remove(struct vcache *vcp, FCacheEntry *childentry, char *name)
OBSOLETE {
OBSOLETE     FCacheEntry *fce;
OBSOLETE     CredCacheEntry *ce;
OBSOLETE     int error;
OBSOLETE     VenusFid *fid, tempfid; /* Ba san: to check the deletion of file*/
OBSOLETE     Result res;
OBSOLETE     int    isupdate;
OBSOLETE 
OBSOLETE     ConnCacheEntry *conn;
OBSOLETE     fs_server_context context;
OBSOLETE     AFSFetchStatus status;
OBSOLETE     AFSVolSync volsync; 
OBSOLETE     char tmp[2 * sizeof(int) + 2];
OBSOLETE     fcache_cache_handle cache_handle;
OBSOLETE 
OBSOLETE     fid = &(vcp->fid); /* points to the VenusFid structure */
OBSOLETE     fid = fid_translate(fid);
OBSOLETE 
OBSOLETE     arla_log(ADEBDISCONN, "reconnect: DISCONNECTED remove on "
OBSOLETE 	     "fid.Cell=0x%x, fid.fid.  Volume= 0x%x, fid.fid.Vnode=0x%x, "
OBSOLETE 	     "fid.fid.Unique=0x%x", 
OBSOLETE 	     fid->Cell, fid->fid.Volume, fid->fid.Vnode, fid->fid.Unique);
OBSOLETE 
OBSOLETE     /* ObtainWriteLock called in fcache_find */
OBSOLETE     error = fcache_find(&fce, *fid); 
OBSOLETE     assert (error == 0);
OBSOLETE 
OBSOLETE     ce = cred_get (fid->Cell, vcp->cred.pag, CRED_ANY);
OBSOLETE     assert (ce != NULL);
OBSOLETE 
OBSOLETE     if (connected_mode != CONNMODE_PARCONNECTED) {
OBSOLETE 	ObtainWriteLock(&childentry->lock);
OBSOLETE 	isupdate = reconnect_mut_chk(childentry, ce, 
OBSOLETE 				     childentry->status.DataVersion);
OBSOLETE 	ReleaseWriteLock(&childentry->lock);
OBSOLETE   
OBSOLETE 	if (isupdate)
OBSOLETE 	{
OBSOLETE 	    fcache_cache_handle cache_handle;
OBSOLETE 
OBSOLETE 	    arla_log(ADEBDISCONN, 
OBSOLETE 		     "reconnect_remove: can't remove because file modified!");
OBSOLETE 	    cred_free(ce);
OBSOLETE 	    adir_creat (fce, name, childentry->fid.fid);
OBSOLETE 	    childentry->flags.attrp = FALSE;
OBSOLETE 	    ReleaseWriteLock(&fce->lock);
OBSOLETE 	    conv_dir (fce, ce, 0, &cache_handle, tmp, sizeof(tmp));
OBSOLETE 	    ReleaseWriteLock(&fce->lock);
OBSOLETE 	    return -1;
OBSOLETE 	}
OBSOLETE     }  /* Ba ershi: we dont need to do it in parconn */
OBSOLETE 
OBSOLETE     res.res = 0;
OBSOLETE 
OBSOLETE     AssertExclLocked(&fce->lock);
OBSOLETE 
OBSOLETE     conn = find_first_fs (fce, ce, &context);
OBSOLETE     if (conn == NULL) {
OBSOLETE 	arla_log (ADEBDISCONN, "find_first_fs failed", fce->index);
OBSOLETE 	cred_free(ce);
OBSOLETE 	ReleaseWriteLock(&fce->lock);
OBSOLETE 	return ENETDOWN;
OBSOLETE     }
OBSOLETE 
OBSOLETE /* Ba san: check the file exists 
OBSOLETE 
OBSOLETE    ReleaseWriteLock(&fce->lock);
OBSOLETE    error = adir_lookup(fce->fid, name, &tempfid, NULL, &ce);
OBSOLETE    assert (error == 0);                                             
OBSOLETE    ObtainWriteLock(&fce->lock);  */
OBSOLETE      
OBSOLETE     res.res = RXAFS_RemoveFile (conn->connection,
OBSOLETE 				&fce->fid.fid,
OBSOLETE 				name,
OBSOLETE 				&status,
OBSOLETE 				&volsync);
OBSOLETE     if (res.res) {
OBSOLETE 	arla_log (ADEBDISCONN, "Could not RemoveFile: %s (%d)",
OBSOLETE 		  koerr_gettext(res.res), res.res);
OBSOLETE 	goto out;
OBSOLETE     }
OBSOLETE 
OBSOLETE     arla_warnx (ADEBDISCONN,"In reconnect_remove: Remove the file %s",name);
OBSOLETE 
OBSOLETE /* Ba san: Chcek the deletion of the file */
OBSOLETE     ReleaseWriteLock(&fce->lock);
OBSOLETE     error = adir_lookup(&fce->fid, name, &tempfid, NULL, &ce);
OBSOLETE     ObtainWriteLock(&fce->lock);
OBSOLETE 
OBSOLETE     if (error == 0) {
OBSOLETE 	int result;
OBSOLETE         
OBSOLETE 	arla_warnx (ADEBDISCONN,
OBSOLETE 		    "In reconnect_remove: file %s needs to be deleted",
OBSOLETE 		    name);
OBSOLETE 	result = adir_remove (fce,name);
OBSOLETE 	assert ( result == 0);
OBSOLETE     } /* This is for the file produced during disconnect mode,
OBSOLETE 	 if error==ENOENT then the file is created during connect mode*/
OBSOLETE   
OBSOLETE 
OBSOLETE     fce->status  = status;
OBSOLETE     fce->volsync = volsync;
OBSOLETE     childentry->host = 0;  /* Ba shiliu dont get callback */
OBSOLETE 
OBSOLETE     volcache_update_volsync (fce->volume, fce->volsync);
OBSOLETE     conv_dir (fce, ce, 0, &cache_handle, tmp, sizeof(tmp));
OBSOLETE 
OBSOLETE  out:
OBSOLETE 
OBSOLETE     cred_free(ce);
OBSOLETE     free_fs_server_context(&context);
OBSOLETE     ReleaseWriteLock(&fce->lock); 
OBSOLETE     return error;
OBSOLETE }
OBSOLETE 
OBSOLETE /*
OBSOLETE  *
OBSOLETE  */
OBSOLETE 
OBSOLETE int 
OBSOLETE reconnect_rmdir(struct vcache *vcp, FCacheEntry *childEntry, char *name)
OBSOLETE {
OBSOLETE     FCacheEntry *fce;
OBSOLETE     CredCacheEntry *ce;
OBSOLETE     int error;               
OBSOLETE     VenusFid *fid, tempfid; /* Ba san: to check the deletion of file*/
OBSOLETE     Result res;
OBSOLETE     char tmp[2 * sizeof(int) + 2];
OBSOLETE     int ret = 0; 
OBSOLETE     Result tempres; 
OBSOLETE     fcache_cache_handle cache_handle;
OBSOLETE   
OBSOLETE     ConnCacheEntry *conn;
OBSOLETE     fs_server_context context;
OBSOLETE     AFSFetchStatus status;
OBSOLETE     AFSVolSync volsync;
OBSOLETE 
OBSOLETE     fid = &(vcp->fid); /* points to the VenusFid structure */
OBSOLETE     fid = fid_translate(fid);
OBSOLETE 
OBSOLETE     ret = fcache_find(&fce, *fid);
OBSOLETE     assert (ret == 0);
OBSOLETE 
OBSOLETE     ce = cred_get (fid->Cell, vcp->cred.pag, CRED_ANY);
OBSOLETE     assert (ce != NULL);
OBSOLETE 
OBSOLETE     AssertExclLocked(&fce->lock);
OBSOLETE 
OBSOLETE     conn = find_first_fs (fce, ce, &context);
OBSOLETE     if (conn == NULL) {
OBSOLETE 	arla_log (ADEBDISCONN, "find_first_fs failed", fce->index);
OBSOLETE 	cred_free(ce);
OBSOLETE 	ReleaseWriteLock(&fce->lock);
OBSOLETE 	return ENETDOWN;
OBSOLETE     }
OBSOLETE 
OBSOLETE     ret = RXAFS_RemoveDir (conn->connection,
OBSOLETE 			   &fce->fid.fid,
OBSOLETE 			   name,
OBSOLETE 			   &status,
OBSOLETE 			   &volsync);
OBSOLETE     if (ret) {
OBSOLETE 	arla_log (ADEBDISCONN, 
OBSOLETE 		  "Could not RemoveDir : %s (%d)", 
OBSOLETE 		  koerr_gettext(res.res),res.res);
OBSOLETE 	goto out;
OBSOLETE     }
OBSOLETE 
OBSOLETE /* Ba san: Chcek the deletion of the file */
OBSOLETE     ReleaseWriteLock(&fce->lock);
OBSOLETE     error = adir_lookup(&fce->fid, name, &tempfid, NULL, &ce);
OBSOLETE     ObtainWriteLock(&fce->lock);
OBSOLETE 
OBSOLETE     if (error == 0) {
OBSOLETE         int result;
OBSOLETE 
OBSOLETE         arla_warnx (ADEBDISCONN,
OBSOLETE 		    "In reconnect_rmdir: file %s needs to be deleted",name);
OBSOLETE         result = adir_remove (fce,name);
OBSOLETE         assert ( result == 0);
OBSOLETE     } /* This is for the file produced during disconnect mode,
OBSOLETE 	 if error==ENOENT then the file is created during connect mode*/
OBSOLETE 
OBSOLETE     fce->status  = status;
OBSOLETE     fce->volsync = volsync;
OBSOLETE 
OBSOLETE     volcache_update_volsync (fce->volume, fce->volsync);
OBSOLETE 
OBSOLETE     tempres = conv_dir(fce, ce, 0, &cache_handle, tmp, sizeof(tmp));
OBSOLETE 
OBSOLETE     childEntry->host = 0; /*Ba shiqi: no callback for this entry*/
OBSOLETE 
OBSOLETE  out:
OBSOLETE 
OBSOLETE     cred_free(ce);
OBSOLETE     free_fs_server_context(&context);
OBSOLETE     ReleaseWriteLock(&fce->lock);
OBSOLETE     return error;
OBSOLETE }
OBSOLETE 
OBSOLETE /*
OBSOLETE  *
OBSOLETE  */
OBSOLETE 
OBSOLETE static int 
OBSOLETE reconnect_mut_chk(FCacheEntry *fce, CredCacheEntry *ce, int version)
OBSOLETE {
OBSOLETE     ConnCacheEntry *conn;
OBSOLETE     fs_server_context context;
OBSOLETE     FCacheEntry fetched = *fce;
OBSOLETE     int ret;
OBSOLETE 
OBSOLETE     AFSFetchStatus status;                                                   
OBSOLETE     AFSCallBack callback;                                                    
OBSOLETE     AFSVolSync volsync;      
OBSOLETE 
OBSOLETE     AssertExclLocked(&fetched.lock);
OBSOLETE 
OBSOLETE /*SWW Aug 01: >= is changed into > */
OBSOLETE     conn = find_first_fs (&fetched, ce, &context);
OBSOLETE     if (conn == NULL) {
OBSOLETE 	arla_log (ADEBDISCONN, "find_first_fs failed", fce->index);
OBSOLETE 	return ENETDOWN;
OBSOLETE     }
OBSOLETE  
OBSOLETE     ret = RXAFS_FetchStatus (conn->connection,
OBSOLETE                              &fce->fid.fid,
OBSOLETE                              &status,
OBSOLETE                              &callback,
OBSOLETE                              &volsync);
OBSOLETE     if (ret) {
OBSOLETE         if (ret == -1)
OBSOLETE             ret = ENETDOWN;
OBSOLETE         free_fs_server_context(&context);
OBSOLETE         arla_warn (ADEBFCACHE, ret, "fetch-status");
OBSOLETE         return ret;
OBSOLETE     }
OBSOLETE 
OBSOLETE     if (status.DataVersion > version)
OBSOLETE     {
OBSOLETE 	arla_log(ADEBDISCONN, "reconnect_mut_chk: concurrent writes detected!");
OBSOLETE 	return 1;
OBSOLETE     }
OBSOLETE     free_fs_server_context(&context);
OBSOLETE     return 0;
OBSOLETE }
OBSOLETE 
OBSOLETE /*
OBSOLETE  *
OBSOLETE  */
OBSOLETE 
OBSOLETE static void
OBSOLETE fcache_backfile_name(char *name, size_t len)
OBSOLETE {
OBSOLETE     static int no = 1;
OBSOLETE 
OBSOLETE     snprintf (name, len, "%04X",no++);
OBSOLETE     strcat (name, "bak");
OBSOLETE     name[strlen(name)+1] = '\0';
OBSOLETE }
OBSOLETE 
OBSOLETE /*
OBSOLETE  *
OBSOLETE  */
OBSOLETE 
OBSOLETE static void
OBSOLETE copy_cached_file(int from, int to)
OBSOLETE {
OBSOLETE     char name_from[2 * sizeof(int) + 1], name_to[2 * sizeof(int) + 1];
OBSOLETE     int fd_from, n, fd_to;
OBSOLETE     char buf[BUFSIZE];
OBSOLETE 
OBSOLETE     snprintf (name_from, sizeof(name_from), "%04X", from);
OBSOLETE     snprintf (name_to,   sizeof(name_to),   "%04X", to);
OBSOLETE 
OBSOLETE     fd_from = open(name_from,O_RDONLY | O_BINARY, 0);  
OBSOLETE     fd_to   = open(name_to,  O_WRONLY | O_CREAT | O_BINARY | O_TRUNC, 0600);
OBSOLETE 
OBSOLETE     while((n = read(fd_from, buf, BUFSIZE)) > 0)
OBSOLETE 	write(fd_to, buf, n);
OBSOLETE 
OBSOLETE #if 0
OBSOLETE     if(fstat(fd_to, &statinfo)<0) {
OBSOLETE 	arla_warnx(ADEBDISCONN,"ERROR");
OBSOLETE     }
OBSOLETE #endif   
OBSOLETE 
OBSOLETE     close(fd_from);
OBSOLETE     close(fd_to);
OBSOLETE }
OBSOLETE 
OBSOLETE /*
OBSOLETE  *
OBSOLETE  */
OBSOLETE 
OBSOLETE static void
OBSOLETE reconnect_update_fid (FCacheEntry *entry, VenusFid oldfid)
OBSOLETE {
OBSOLETE     if (entry->flags.kernelp)
OBSOLETE 	update_fid (oldfid, NULL, entry->fid, entry);
OBSOLETE }
OBSOLETE 
OBSOLETE /*
OBSOLETE  *
OBSOLETE  */
OBSOLETE 
OBSOLETE static int
OBSOLETE reconnect_mut_newfile(FCacheEntry **fcep, nnpfs_pag_t cred,VenusFid *new_fid)
OBSOLETE {
OBSOLETE 
OBSOLETE     FCacheEntry *parent_fce;
OBSOLETE     u_long host;
OBSOLETE     char name[2 * sizeof(int) + 3 + 1], tmp[2 * sizeof(int) + 2];
OBSOLETE     AFSStoreStatus store_attr;
OBSOLETE     AFSFetchStatus fetch_attr;
OBSOLETE     CredCacheEntry *ce; 
OBSOLETE     AccessEntry *ae;
OBSOLETE     VenusFid newfid;
OBSOLETE     int ret;
OBSOLETE     int from, to;
OBSOLETE     fcache_cache_handle cache_handle;
OBSOLETE 
OBSOLETE     ret = fcache_find (&parent_fce, (*fcep)->parent);
OBSOLETE     assert (ret == 0);
OBSOLETE 
OBSOLETE     host = (*fcep)->host;
OBSOLETE 
OBSOLETE     ce = cred_get((*fcep)->parent.Cell, cred, CRED_ANY);
OBSOLETE 
OBSOLETE     fcache_backfile_name (name, sizeof(name));
OBSOLETE 
OBSOLETE     store_attr.Mask = 8;
OBSOLETE     store_attr.ClientModTime = 430144;
OBSOLETE     store_attr.Owner = 1957724;
OBSOLETE     store_attr.Group = 21516;
OBSOLETE     store_attr.UnixModeBits = 420;
OBSOLETE     store_attr.SegSize = 0;
OBSOLETE 
OBSOLETE     create_file(parent_fce, name, &store_attr, &newfid, &fetch_attr, ce);
OBSOLETE 
OBSOLETE     (*fcep)->flags.datap = FALSE; /* Ba shiqi: we need to get the old from FS*/
OBSOLETE     *new_fid = newfid;
OBSOLETE     from = (*fcep)->index;
OBSOLETE     ret = fcache_find(fcep, newfid);
OBSOLETE     assert (ret == 0);
OBSOLETE     to   = (*fcep)->index;
OBSOLETE     (*fcep)->host = host;
OBSOLETE     (*fcep)->flags.attrp = TRUE;
OBSOLETE     (*fcep)->flags.datap = TRUE;
OBSOLETE     findaccess(ce->cred, (*fcep)->acccache, &ae); /*Ba shijiu obtain access */
OBSOLETE     ae->cred   = ce->cred;
OBSOLETE     ae->access = (*fcep)->status.CallerAccess;
OBSOLETE 
OBSOLETE     ReleaseWriteLock(&(*fcep)->lock);
OBSOLETE 
OBSOLETE     copy_cached_file(from, to);
OBSOLETE     ret = adir_creat (parent_fce, name, newfid.fid);
OBSOLETE     assert (ret ==0);
OBSOLETE     conv_dir (parent_fce, ce, 0, &cache_handle, tmp, sizeof(tmp));
OBSOLETE     ReleaseWriteLock(&parent_fce->lock);
OBSOLETE 
OBSOLETE     return 0;
OBSOLETE }
OBSOLETE 
OBSOLETE    
OBSOLETE /*
OBSOLETE  *
OBSOLETE  */
OBSOLETE 
OBSOLETE int reconnect_putattr(struct vcache *vcp, struct nnpfs_attr *xap)
OBSOLETE {
OBSOLETE 
OBSOLETE     ConnCacheEntry *conn;
OBSOLETE     fs_server_context context;
OBSOLETE     struct rx_call *call;
OBSOLETE     VenusFid *fid;
OBSOLETE     CredCacheEntry *ce;
OBSOLETE     FCacheEntry *fce, *tempce;
OBSOLETE     AFSFetchStatus status;
OBSOLETE     Result res;
OBSOLETE     uint32_t sizefs;
OBSOLETE     AFSStoreStatus storestatus;
OBSOLETE     AFSVolSync volsync;
OBSOLETE     int ret;
OBSOLETE 
OBSOLETE     fid = &(vcp->fid); /* points to the VenusFid structure */
OBSOLETE     fid = fid_translate(fid);
OBSOLETE 
OBSOLETE #if 0
OBSOLETE     arla_log(ADEBDISCONN, "reconnect: DISCONNECTED write on fid.Cell=0x%x, "
OBSOLETE 	     "fid.fid.Volume= 0x%x, fid.fid.Vnode=0x%x, fid.fid.Unique=0x%x",
OBSOLETE 	     fid->Cell, 
OBSOLETE 	     fid->fid.Volume, 
OBSOLETE 	     fid->fid.Vnode, 
OBSOLETE 	     fid->fid.Unique);
OBSOLETE #endif
OBSOLETE 
OBSOLETE     ce = cred_get (fid->Cell, vcp->cred.pag, CRED_ANY);
OBSOLETE     assert (ce != NULL);
OBSOLETE     res.res = 0;
OBSOLETE 
OBSOLETE #if 0
OBSOLETE /* Ba shier: should we send the file back to server?  */
OBSOLETE     if (XA_VALID_SIZE(xap)){
OBSOLETE 	AFSStoreStatus storestatus;
OBSOLETE 	memset(&storestatus, 0, sizeof(storestatus));
OBSOLETE 	storestatus.Mask = 0;
OBSOLETE 
OBSOLETE 	res = cm_ftruncate (*fid, xap->xa_size, &storestatus, ce);
OBSOLETE     }  
OBSOLETE #endif
OBSOLETE 
OBSOLETE     ret = fcache_find(&fce, *fid);
OBSOLETE     assert (ret == 0);
OBSOLETE     tempce = fce;
OBSOLETE 
OBSOLETE     sizefs=fce->status.Length;
OBSOLETE 
OBSOLETE #if 0 /* XXX */
OBSOLETE     /* some people have written to the file while we are disconnected */
OBSOLETE     /* we have to give it a different name on the server  */
OBSOLETE     if (reconnect_mut_chk(fce, ce, vcp->DataVersion))
OBSOLETE     {
OBSOLETE 	VenusFid new_fid;
OBSOLETE 
OBSOLETE 	alloc_fid_trans(fid);
OBSOLETE 	reconnect_mut_newfile(&fce,vcp->cred.pag,&new_fid);  
OBSOLETE 	fce->status.Length = sizefs;
OBSOLETE 	fce->length = sizefs;
OBSOLETE 	ReleaseWriteLock(&tempce->lock);
OBSOLETE 	fill_fid_trans(&new_fid);
OBSOLETE 	tempce->flags.attrp = FALSE;
OBSOLETE 	tempce->flags.kernelp = FALSE;
OBSOLETE     }   
OBSOLETE #endif
OBSOLETE 
OBSOLETE     /* code from truncate file XXX join */
OBSOLETE     conn = find_first_fs (fce, ce, &context);
OBSOLETE     if (conn == NULL) {
OBSOLETE 	arla_log (ADEBDISCONN, "find_first_fs failed.");
OBSOLETE 	ReleaseWriteLock(&fce->lock);
OBSOLETE 	cred_free(ce);
OBSOLETE 	return ENETDOWN;
OBSOLETE     }
OBSOLETE 
OBSOLETE     if (fce->status.FileType != TYPE_DIR) {
OBSOLETE 
OBSOLETE 	call = rx_NewCall (conn->connection);
OBSOLETE 	if (call == NULL) {
OBSOLETE 	    arla_log (ADEBDISCONN, "Cannot call");
OBSOLETE 	    res.res = ENOMEM;
OBSOLETE 	    goto out;
OBSOLETE 	}
OBSOLETE 
OBSOLETE 	storestatus.Mask = 0;
OBSOLETE 	res.res = StartRXAFS_StoreData (call,
OBSOLETE 					&(fce->fid.fid),
OBSOLETE 					&storestatus,
OBSOLETE 					0, 0, fce->status.Length);
OBSOLETE 	if(res.res) {
OBSOLETE 	    arla_log (ADEBDISCONN, "Could not start store, %s (%d)",
OBSOLETE 		      koerr_gettext(res.res), res.res);
OBSOLETE 	    rx_EndCall(call, 0);
OBSOLETE 	    goto out;
OBSOLETE 	}
OBSOLETE 
OBSOLETE 	sizefs = htonl (sizefs);
OBSOLETE 	if (rx_Write (call, &sizefs, sizeof(sizefs)) != sizeof(sizefs)) {
OBSOLETE 	    res.res = conv_to_arla_errno(rx_GetCallError(call));
OBSOLETE 	    arla_log (ADEBDISCONN, "Error writing length: %d", res.res);
OBSOLETE 	    rx_EndCall(call, 0);
OBSOLETE 	    goto out;
OBSOLETE 	}
OBSOLETE 
OBSOLETE 	if (rx_Write (call, 0, 0) != 0) {
OBSOLETE 	    res.res = conv_to_arla_errno(rx_GetCallError(call));
OBSOLETE 	    arla_log (ADEBDISCONN, "Error writing: %d", res.res);
OBSOLETE 	    rx_EndCall(call, 0);
OBSOLETE 	    goto out;
OBSOLETE 	}
OBSOLETE 
OBSOLETE 	res.res = rx_EndCall (call, EndRXAFS_StoreData (call,
OBSOLETE 							&status,
OBSOLETE 							&volsync));
OBSOLETE 	if (res.res) {
OBSOLETE 	    arla_log (ADEBDISCONN, "Error rx_EndCall: %s (%d)",
OBSOLETE 		      koerr_gettext(res.res), res.res);
OBSOLETE 	    goto out;
OBSOLETE 	}
OBSOLETE 
OBSOLETE 	fce->status   = status;
OBSOLETE 	fce->volsync  = volsync;
OBSOLETE 
OBSOLETE 	volcache_update_volsync (fce->volume, fce->volsync);
OBSOLETE 
OBSOLETE     }
OBSOLETE     /* code from write_attr XXX join */
OBSOLETE     nnpfs_attr2afsstorestatus(xap, &storestatus);
OBSOLETE 
OBSOLETE     res.res = RXAFS_StoreStatus (conn->connection,
OBSOLETE 				 &fce->fid.fid,
OBSOLETE 				 &storestatus,
OBSOLETE 				 &status,
OBSOLETE 				 &volsync);
OBSOLETE     if (res.res) {
OBSOLETE         arla_log (ADEBDISCONN, "Could not make store-status call, %s (%d)",
OBSOLETE 		  koerr_gettext(res.res), res.res);
OBSOLETE         goto out;
OBSOLETE     }
OBSOLETE     arla_log(ADEBDISCONN, 
OBSOLETE 	     "write_attr: status.Length = %d", status.Length);
OBSOLETE     fce->status  = status;
OBSOLETE     fce->volsync = volsync;
OBSOLETE 
OBSOLETE     volcache_update_volsync (fce->volume, fce->volsync);
OBSOLETE 
OBSOLETE  out:
OBSOLETE 
OBSOLETE     free_fs_server_context(&context);
OBSOLETE     ReleaseWriteLock(&fce->lock);
OBSOLETE     cred_free(ce);
OBSOLETE     return res.res;
OBSOLETE }
OBSOLETE 
OBSOLETE /*
OBSOLETE  *
OBSOLETE  */
OBSOLETE 
OBSOLETE static int 
OBSOLETE reconnect_putdata(struct vcache *vcp)
OBSOLETE {
OBSOLETE     VenusFid *fid;
OBSOLETE     FCacheEntry *fce;
OBSOLETE     CredCacheEntry *ce;
OBSOLETE     Result res;
OBSOLETE 
OBSOLETE     uint32_t sizefs;
OBSOLETE     int fd = -1;
OBSOLETE     struct rx_call *call;
OBSOLETE     ConnCacheEntry *conn;
OBSOLETE     fs_server_context context;
OBSOLETE     struct stat statinfo;
OBSOLETE     AFSStoreStatus storestatus;
OBSOLETE     AFSFetchStatus status;
OBSOLETE     AFSVolSync volsync;
OBSOLETE     int ret;
OBSOLETE 
OBSOLETE     fid = &(vcp->fid); /* points to the VenusFid structure */
OBSOLETE     arla_log(ADEBDISCONN, "reconnect: putdata before fid_translate, "
OBSOLETE 	     "fid->Cell=0x%x, fid->fid.Volume=0x%x, fid->fid.Vnode=0x%x, "
OBSOLETE 	     "fid->fid.Unique=0x%x", 
OBSOLETE 	     fid->Cell, 
OBSOLETE 	     fid->fid.Volume, 
OBSOLETE 	     fid->fid.Vnode, 
OBSOLETE 	     fid->fid.Unique);
OBSOLETE 
OBSOLETE     fid = fid_translate(fid);
OBSOLETE 
OBSOLETE     arla_log(ADEBDISCONN, "reconnect: putdata after fid_translate, "
OBSOLETE 	     "fid->Cell=0x%x, fid->fid.Volume=0x%x, fid->fid.Vnode=0x%x, "
OBSOLETE 	     "fid->fid.Unique=0x%x", 
OBSOLETE 	     fid->Cell, 
OBSOLETE 	     fid->fid.Volume, 
OBSOLETE 	     fid->fid.Vnode, 
OBSOLETE 	     fid->fid.Unique);
OBSOLETE 
OBSOLETE 
OBSOLETE     ce = cred_get (fid->Cell, vcp->cred.pag, CRED_ANY);
OBSOLETE     assert (ce != NULL);
OBSOLETE 
OBSOLETE     ret = fcache_find (&fce, *fid);
OBSOLETE     assert (ret == 0);
OBSOLETE 
OBSOLETE #if 0
OBSOLETE     isupdate = reconnect_mut_chk(fce, ce, vcp->DataVersion);
OBSOLETE     if (isupdate)
OBSOLETE     {
OBSOLETE 	arla_log(ADEBDISCONN, 
OBSOLETE 		 "reconnect_putdata: send data back because "
OBSOLETE 		 "the file was modified!");
OBSOLETE 	cred_free(ce);
OBSOLETE 	ReleaseWriteLock(&fce->lock);
OBSOLETE 	reconnect_mut_newfile(&fce, vcp->cred.pag);  
OBSOLETE 	return -1;
OBSOLETE     }
OBSOLETE 
OBSOLETE     if (reconnect_mut_chk (fce, ce)) {
OBSOLETE 	arla_log (ADEBDISCONN, "Reconnect_putdata: can not send the file"
OBSOLETE 		  "to FS becausethis file has been modified!");
OBSOLETE 	ReleaseWriteLock(&fce->lock);
OBSOLETE 	return -1;
OBSOLETE     } 
OBSOLETE #endif
OBSOLETE 
OBSOLETE     /* code taken from write_data XXX join */ 
OBSOLETE     AssertExclLocked(&fce->lock);
OBSOLETE 
OBSOLETE     conn = find_first_fs (fce, ce, &context);
OBSOLETE     if (conn == NULL) {
OBSOLETE 	arla_log (ADEBDISCONN, "find_first_fs failed");
OBSOLETE 	ReleaseWriteLock(&fce->lock); 
OBSOLETE 	cred_free(ce);
OBSOLETE 	return ENETDOWN;
OBSOLETE     }
OBSOLETE 
OBSOLETE     fd = fcache_open_file (fce, O_RDONLY);
OBSOLETE     if (fd < 0) {
OBSOLETE 	arla_log (ADEBDISCONN, "open %u failed", fce->index);
OBSOLETE 	res.res = errno;
OBSOLETE 	goto out;
OBSOLETE     }
OBSOLETE 
OBSOLETE     if (fstat (fd, &statinfo) < 0) {
OBSOLETE 	arla_log (ADEBDISCONN, "Cannot stat file %u", fce->index);
OBSOLETE 	res.res = errno;
OBSOLETE 	goto out;
OBSOLETE     }
OBSOLETE 
OBSOLETE     sizefs = statinfo.st_size;
OBSOLETE 
OBSOLETE     call = rx_NewCall (conn->connection);
OBSOLETE     if (call == NULL) {
OBSOLETE 	arla_log (ADEBDISCONN, "Cannot call");
OBSOLETE 	res.res = ENOMEM;
OBSOLETE 	goto out;
OBSOLETE     }
OBSOLETE 
OBSOLETE     storestatus.Mask = 0; /* Dont save anything */
OBSOLETE     res.res = StartRXAFS_StoreData (call, &fce->fid.fid,
OBSOLETE 				    &storestatus,
OBSOLETE 				    0,
OBSOLETE 				    sizefs,
OBSOLETE 				    sizefs);
OBSOLETE     if (res.res) {
OBSOLETE 	arla_log (ADEBDISCONN, "Could not start store, %s (%d)",
OBSOLETE 		  koerr_gettext(res.res), res.res);
OBSOLETE 	rx_EndCall(call, 0);
OBSOLETE 	goto out;
OBSOLETE     }
OBSOLETE 
OBSOLETE     res.res = copyfd2rx (fd, call, 0, sizefs);
OBSOLETE     if (res.res) {
OBSOLETE 	rx_EndCall(call, res.res);
OBSOLETE 	arla_log (ADEBDISCONN, "copyfd2rx failed: %d", res.res);
OBSOLETE 	goto out;
OBSOLETE     }
OBSOLETE      
OBSOLETE     res.res = rx_EndCall (call, EndRXAFS_StoreData (call,
OBSOLETE 						    &status,
OBSOLETE 						    &volsync));
OBSOLETE     if (res.res) {
OBSOLETE 	arla_log (ADEBDISCONN, "Error rx_EndCall: %s (%d)", 
OBSOLETE 		  koerr_gettext(res.res), res.res);
OBSOLETE 	goto out;
OBSOLETE     }
OBSOLETE     if (status.DataVersion > fce->status.DataVersion)
OBSOLETE 	arla_log(ADEBDISCONN, 
OBSOLETE 		 "reconnect: putdata, server incremented DataVersion!");
OBSOLETE 
OBSOLETE     fce->status   = status;
OBSOLETE     fce->volsync  = volsync;
OBSOLETE 
OBSOLETE     volcache_update_volsync (fce->volume, fce->volsync);
OBSOLETE 
OBSOLETE  out:
OBSOLETE 
OBSOLETE     ReleaseWriteLock(&fce->lock); 
OBSOLETE     if (fd != -1)
OBSOLETE 	close (fd);
OBSOLETE     free_fs_server_context (&context);
OBSOLETE   
OBSOLETE     cred_free(ce);
OBSOLETE     return res.res;
OBSOLETE }
OBSOLETE 
OBSOLETE /*
OBSOLETE  *
OBSOLETE  */
OBSOLETE 
OBSOLETE int reconnect_rename(struct vcache *vcp_old, struct vcache *vcp_new, 
OBSOLETE 		     char *name_old, char *name_new)
OBSOLETE {
OBSOLETE 
OBSOLETE     FCacheEntry *fce_old, *fce_new;
OBSOLETE     CredCacheEntry *ce;
OBSOLETE     VenusFid *fid_old, *fid_new,foo_fid,*tempnew_fid;
OBSOLETE     int error;
OBSOLETE 
OBSOLETE     int ret = 0;
OBSOLETE     Result res;
OBSOLETE     char tmp[2 * sizeof(int) + 2];
OBSOLETE     int isnewpar = 0;
OBSOLETE     ConnCacheEntry *conn;
OBSOLETE     fs_server_context context;
OBSOLETE     AFSFetchStatus orig_status, new_status;
OBSOLETE     AFSVolSync volsync;
OBSOLETE     fcache_cache_handle cache_handle;
OBSOLETE 
OBSOLETE     fid_old = &vcp_old->fid;
OBSOLETE     fid_old = fid_translate(fid_old);
OBSOLETE  
OBSOLETE     ret = fcache_find (&fce_old, *fid_old);
OBSOLETE     assert (ret == 0);
OBSOLETE 
OBSOLETE     /* ReleaseWriteLock(&fce_old->lock);  SWW Qiyue 28 Maybe we dont need it*/
OBSOLETE     assert(fce_old);
OBSOLETE     arla_log(ADEBDISCONN, "reconnect: old rename on Cell=0x%x, "
OBSOLETE 	     "fid.Volume= 0x%x, fid.Vnode=0x%x, fid.Unique=0x%x", 
OBSOLETE 	     fce_old->fid.Cell,
OBSOLETE 	     fce_old->fid.fid.Volume,
OBSOLETE 	     fce_old->fid.fid.Vnode, 
OBSOLETE 	     fce_old->fid.fid.Unique);
OBSOLETE 
OBSOLETE     fid_new = tempnew_fid = &vcp_new->fid;
OBSOLETE     fid_new = fid_translate(fid_new);
OBSOLETE     
OBSOLETE     if (tempnew_fid->fid.Volume != fid_new->fid.Volume ||
OBSOLETE 	tempnew_fid->fid.Vnode != fid_new->fid.Vnode ||
OBSOLETE 	tempnew_fid->fid.Unique != fid_new->fid.Unique)
OBSOLETE         isnewpar = 1; 
OBSOLETE 
OBSOLETE /*Ba ba: the parent dir was created during disconnected */
OBSOLETE 
OBSOLETE     if (fid_old->fid.Volume == fid_new->fid.Volume &&
OBSOLETE 	fid_old->fid.Vnode == fid_new->fid.Vnode   &&
OBSOLETE 	fid_old->fid.Unique == fid_new->fid.Unique )
OBSOLETE         ReleaseWriteLock(&fce_old->lock); /* old and new are the same*/
OBSOLETE 
OBSOLETE     ret = fcache_find (&fce_new, *fid_new);
OBSOLETE     assert (ret == 0);
OBSOLETE 
OBSOLETE     arla_log(ADEBDISCONN, "reconnect: new rename on Cell=0x%x, "
OBSOLETE 	     "fid.Volume= 0x%x, fid.Vnode=0x%x, fid.Unique=0x%x", 
OBSOLETE 	     fce_new->fid.Cell, 
OBSOLETE 	     fce_new->fid.fid.Volume, 
OBSOLETE 	     fce_new->fid.fid.Vnode, 
OBSOLETE 	     fce_new->fid.fid.Unique);
OBSOLETE 
OBSOLETE 
OBSOLETE 
OBSOLETE     arla_log(ADEBDISCONN, 
OBSOLETE 	     "reconnect_rename: fce_old = 0x%x, fce_new = 0x%x",
OBSOLETE 	     fce_old, fce_new);
OBSOLETE 
OBSOLETE     ce = cred_get (vcp_old->fid.Cell, vcp_old->cred.pag, CRED_ANY);
OBSOLETE     assert (ce != NULL);
OBSOLETE 
OBSOLETE     AssertExclLocked(&fce_old->lock);
OBSOLETE     AssertExclLocked(&fce_new->lock);
OBSOLETE 
OBSOLETE     conn = find_first_fs (fce_old, ce, &context);
OBSOLETE     if (conn == NULL) {
OBSOLETE 	arla_log (ADEBDISCONN, "find_first_fs failed");
OBSOLETE 	ReleaseWriteLock(&fce_new->lock);
OBSOLETE 	
OBSOLETE 	if (fid_old->fid.Volume != fid_new->fid.Volume ||
OBSOLETE 	    fid_old->fid.Vnode != fid_new->fid.Vnode   ||
OBSOLETE 	    fid_old->fid.Unique != fid_new->fid.Unique )
OBSOLETE 	    ReleaseWriteLock(&fce_old->lock); /* old and new are the same*/
OBSOLETE 	
OBSOLETE 	cred_free(ce);
OBSOLETE 	return ENETDOWN;
OBSOLETE     }
OBSOLETE 
OBSOLETE     error = RXAFS_Rename (conn->connection,
OBSOLETE 			  &fce_old->fid.fid,
OBSOLETE 			  name_old,
OBSOLETE 			  &fce_new->fid.fid,
OBSOLETE 			  name_new,
OBSOLETE 			  &orig_status,
OBSOLETE 			  &new_status,
OBSOLETE 			  &volsync);
OBSOLETE 
OBSOLETE     if (error) {
OBSOLETE 	arla_log (ADEBDISCONN, "Could not Rename: %s (%d)", koerr_gettext(error), error); 
OBSOLETE 	goto out; }
OBSOLETE 
OBSOLETE     fce_old->status = orig_status;
OBSOLETE     fce_new->status = new_status;
OBSOLETE 
OBSOLETE     fce_old->volsync = fce_new->volsync = volsync;
OBSOLETE 
OBSOLETE     volcache_update_volsync (fce_old->volume, fce_old->volsync);
OBSOLETE 
OBSOLETE 
OBSOLETE /*SWW Aug 01 */
OBSOLETE     arla_warnx (ADEBDISCONN,
OBSOLETE 		"reconnect_rename: we delete the old one %s volumn=0x%x, "
OBSOLETE 		"vnode=0x%x,unique=0x%x",
OBSOLETE 		name_old,fce_old->fid.fid.Volume,
OBSOLETE 		fce_old->fid.fid.Vnode,
OBSOLETE 		fce_old->fid.fid.Unique);                      
OBSOLETE 
OBSOLETE /*Ba Yi: get the VenuseFid for new file */
OBSOLETE   #if 0
OBSOLETE     if (fid_old->fid.Volume == fid_new->fid.Volume &&
OBSOLETE 	fid_old->fid.Vnode == fid_new->fid.Vnode   &&
OBSOLETE 	fid_old->fid.Unique == fid_new->fid.Unique ) ;
OBSOLETE #endif
OBSOLETE     ReleaseWriteLock(&fce_old->lock); /* old and new are the same*/
OBSOLETE     
OBSOLETE     error = adir_lookup (&fce_old->fid, name_old, &foo_fid, NULL, &ce);
OBSOLETE     
OBSOLETE #if 0
OBSOLETE     if (fid_old->fid.Volume == fid_new->fid.Volume &&
OBSOLETE        fid_old->fid.Vnode == fid_new->fid.Vnode   &&
OBSOLETE        fid_old->fid.Unique == fid_new->fid.Unique );
OBSOLETE #endif
OBSOLETE     ObtainWriteLock (&fce_old->lock);
OBSOLETE 
OBSOLETE /*Ba San: delete the old which was created during dis */
OBSOLETE     if (error == 0) {
OBSOLETE 	arla_warnx (ADEBDISCONN,"reconnect_rename: we delete the old one %s "
OBSOLETE 		    "volumn=0x%x,vnode=0x%x,unique=0x%x",
OBSOLETE 		    name_old,
OBSOLETE 		    foo_fid.fid.Volume,
OBSOLETE 		    foo_fid.fid.Vnode,
OBSOLETE 		    foo_fid.fid.Unique);
OBSOLETE 
OBSOLETE 	adir_remove(fce_old,name_old);
OBSOLETE 	adir_remove(fce_new,name_new);
OBSOLETE 
OBSOLETE 	res = conv_dir (fce_old, ce, 0, &cache_handle, tmp, sizeof(tmp));
OBSOLETE 
OBSOLETE     } else {
OBSOLETE 	/* if found delete it */
OBSOLETE /*Ba San: try to find the previous VenuseFid for old name */
OBSOLETE 	if (error == ENOENT) {
OBSOLETE #if 0
OBSOLETE 	    if (fid_old->fid.Volume == fid_new->fid.Volume &&
OBSOLETE 		fid_old->fid.Vnode == fid_new->fid.Vnode   &&
OBSOLETE 		fid_old->fid.Unique == fid_new->fid.Unique );
OBSOLETE #endif
OBSOLETE 	    ReleaseWriteLock(&fce_new->lock);
OBSOLETE 	    
OBSOLETE 	    error = adir_lookup (&fce_new->fid, name_new, &foo_fid, NULL, &ce);
OBSOLETE 	    
OBSOLETE #if 0
OBSOLETE 	    if (fid_old->fid.Volume == fid_new->fid.Volume &&
OBSOLETE                fid_old->fid.Vnode == fid_new->fid.Vnode   &&
OBSOLETE                fid_old->fid.Unique == fid_new->fid.Unique );
OBSOLETE #endif
OBSOLETE 	    ObtainWriteLock (&fce_new->lock);
OBSOLETE 	    if (error == 0) /*Ba Si: We need delete the faked new */
OBSOLETE 		adir_remove(fce_new,name_new);
OBSOLETE 	    else if (error == ENOENT) {
OBSOLETE                 int venusret;
OBSOLETE 		
OBSOLETE                 venusret = find_venus (name_new,&foo_fid);
OBSOLETE                 assert (venusret==0);
OBSOLETE                 arla_warnx (ADEBDISCONN,"I MUST WRITE A PROGRAM HERE");
OBSOLETE                 if (isnewpar == 1) {
OBSOLETE 
OBSOLETE 		    arla_warnx(ADEBDISCONN,"In reconnect_rename: "
OBSOLETE 			       "new Volume=0x%x,Vnode=0x%x,Unique=0x%x",
OBSOLETE 			       fce_new->fid.fid.Volume,
OBSOLETE 			       fce_new->fid.fid.Vnode,
OBSOLETE 			       fce_new->fid.fid.Unique);
OBSOLETE #if 0
OBSOLETE 		    error = adir_creat(fce_new, name_new, foo_fid.fid);
OBSOLETE #endif
OBSOLETE 		}
OBSOLETE 	    }
OBSOLETE 	}
OBSOLETE     }
OBSOLETE 
OBSOLETE     arla_warnx (ADEBDISCONN,"reconnect_rename: we add the new one %s "
OBSOLETE 		"volumn=0x%x,vnode=0x%x,unique=0x%x",
OBSOLETE 		name_new,
OBSOLETE 		foo_fid.fid.Volume,
OBSOLETE 		foo_fid.fid.Vnode,
OBSOLETE 		foo_fid.fid.Unique);
OBSOLETE     error = adir_creat (fce_new, name_new, foo_fid.fid);
OBSOLETE     res = conv_dir (fce_new, ce, 0, &cache_handle, tmp, sizeof(tmp));
OBSOLETE 
OBSOLETE /* Aug 1 */
OBSOLETE 
OBSOLETE  out:
OBSOLETE 
OBSOLETE     free_fs_server_context (&context);
OBSOLETE 
OBSOLETE     ReleaseWriteLock(&fce_new->lock);
OBSOLETE 
OBSOLETE     if (fid_old->fid.Volume != fid_new->fid.Volume ||
OBSOLETE 	fid_old->fid.Vnode != fid_new->fid.Vnode   ||
OBSOLETE 	fid_old->fid.Unique != fid_new->fid.Unique )
OBSOLETE         ReleaseWriteLock(&fce_old->lock); /* old and new are the same*/
OBSOLETE 
OBSOLETE     cred_free(ce);
OBSOLETE     return error;
OBSOLETE }
OBSOLETE 
OBSOLETE /*
OBSOLETE  *
OBSOLETE  */
OBSOLETE 
OBSOLETE int reconnect_create(struct vcache *parent, struct vcache *child, char *name)
OBSOLETE {
OBSOLETE 
OBSOLETE     ConnCacheEntry *conn;
OBSOLETE     fs_server_context context;
OBSOLETE     VenusFid *parent_fid;
OBSOLETE     VenusFid *child_fid;
OBSOLETE     VenusFid fakeFid; 
OBSOLETE 
OBSOLETE     CredCacheEntry *ce;
OBSOLETE     FCacheEntry *parentEntry;
OBSOLETE     FCacheEntry *childEntry;
OBSOLETE 
OBSOLETE     AFSFetchStatus fetch_attr;
OBSOLETE     AFSStoreStatus store_attr; 
OBSOLETE 
OBSOLETE     AFSFetchStatus status;
OBSOLETE     AFSCallBack callback;
OBSOLETE     AFSVolSync volsync;
OBSOLETE     int ret; 
OBSOLETE     char tmp[2 * sizeof(int) + 2];
OBSOLETE     fcache_cache_handle cache_handle;
OBSOLETE     int32_t type;
OBSOLETE 
OBSOLETE     parent_fid = &(parent->fid); /* points to the VenusFid structure */
OBSOLETE     child_fid = &(child->fid);
OBSOLETE     fakeFid = *child_fid;
OBSOLETE 
OBSOLETE     /*Ba Liu: the parent dir may be created during dison mode*/
OBSOLETE     parent_fid = fid_translate(parent_fid);
OBSOLETE 
OBSOLETE     ce = cred_get (parent->fid.Cell, parent->cred.pag, CRED_ANY);
OBSOLETE     assert (ce != NULL);
OBSOLETE 
OBSOLETE     ret = fcache_find (&parentEntry, *parent_fid);
OBSOLETE     assert (ret == 0);
OBSOLETE 
OBSOLETE #if 0
OBSOLETE     is_change = reconnect_mut_chk(parentEntry, 
OBSOLETE 				  ce, 
OBSOLETE 				  parentEntry->status.DataVersion);
OBSOLETE #endif
OBSOLETE 
OBSOLETE /*SWW Qiyue 30 delete the old file entry in dir  */
OBSOLETE     arla_warnx (ADEBDISCONN,
OBSOLETE 		"reconnect_rename: we delete the old one volumn=0x%x, "
OBSOLETE 		"vnode=0x%x,unique=0x%x",
OBSOLETE 		parentEntry->fid.fid.Volume,
OBSOLETE 		parentEntry->fid.fid.Vnode,
OBSOLETE 		parentEntry->fid.fid.Unique);
OBSOLETE 
OBSOLETE     adir_remove(parentEntry,name);  
OBSOLETE 
OBSOLETE     conn = find_first_fs (parentEntry, ce, &context);
OBSOLETE     if (conn == NULL) {
OBSOLETE 	arla_log (ADEBDISCONN, "find_first_fs failed");
OBSOLETE 	ReleaseWriteLock(&parentEntry->lock);
OBSOLETE 	ReleaseWriteLock(&childEntry->lock);
OBSOLETE 	free_fs_server_context(&context);
OBSOLETE 	cred_free(ce);
OBSOLETE 	return ENETDOWN;
OBSOLETE     }
OBSOLETE 
OBSOLETE     ret = fcache_find (&childEntry, *child_fid);
OBSOLETE     assert (ret == 0);
OBSOLETE 
OBSOLETE     recon_hashtabdel(childEntry);
OBSOLETE 
OBSOLETE #if 0
OBSOLETE     fetch_attr = &childEntry->status;
OBSOLETE #endif
OBSOLETE 
OBSOLETE     store_attr.Mask 	   =    8;
OBSOLETE     store_attr.ClientModTime =    childEntry->status.ClientModTime;
OBSOLETE     store_attr.Owner = 	 	childEntry->status.Owner;
OBSOLETE     store_attr.Group = 		childEntry->status.Group;
OBSOLETE     store_attr.UnixModeBits = 	childEntry->status.UnixModeBits;
OBSOLETE     store_attr.SegSize = 		childEntry->status.SegSize;
OBSOLETE 
OBSOLETE     arla_log(ADEBDISCONN, 
OBSOLETE 	     "reconnect: create before RXAFS_CreateFile, "
OBSOLETE 	     "Cell=0x%x, fid.Volume= 0x%x, fid.Vnode=0x%x, fid.Unique=0x%x", 
OBSOLETE 	     childEntry->fid.Cell, 
OBSOLETE 	     childEntry->fid.fid.Volume, 
OBSOLETE 	     childEntry->fid.fid.Vnode, 
OBSOLETE 	     childEntry->fid.fid.Unique);
OBSOLETE 
OBSOLETE     alloc_fid_trans(&childEntry->fid);
OBSOLETE   
OBSOLETE 
OBSOLETE     ret = RXAFS_CreateFile (conn->connection,
OBSOLETE                             &(parentEntry->fid.fid),
OBSOLETE                             name, &store_attr,
OBSOLETE                             &(childEntry->fid.fid), &fetch_attr,
OBSOLETE                             &status,
OBSOLETE                             &callback,
OBSOLETE                             &volsync);
OBSOLETE  
OBSOLETE     if (ret) {
OBSOLETE 	if (ret == 17) {
OBSOLETE 	    ReleaseWriteLock(&parentEntry->lock);
OBSOLETE 	    reconnect_mut_newfile(&childEntry, 
OBSOLETE 				  parent->cred.pag, 
OBSOLETE 				  &childEntry->fid);
OBSOLETE 	    ObtainWriteLock(&parentEntry->lock);
OBSOLETE 	    fill_fid_trans(&childEntry->fid);
OBSOLETE 	    recon_hashtabadd(childEntry);
OBSOLETE 	    childEntry->host = rx_HostOf (rx_PeerOf (conn->connection));
OBSOLETE 	    reconnect_update_fid (childEntry, fakeFid);
OBSOLETE 	} else {
OBSOLETE 	    arla_log (ADEBDISCONN, "Could not CreateFile: %s (%d)",
OBSOLETE 		      koerr_gettext(ret), ret);
OBSOLETE 	}
OBSOLETE 	goto out;
OBSOLETE     }
OBSOLETE    
OBSOLETE     parentEntry->status   = status;   
OBSOLETE     parentEntry->callback = callback;
OBSOLETE     parentEntry->volsync  = volsync;
OBSOLETE 
OBSOLETE     childEntry->fid.Cell = parentEntry->fid.Cell;
OBSOLETE 
OBSOLETE     arla_log(ADEBDISCONN, "reconnect: create after RXAFS_CreateFile, "
OBSOLETE 	     "Cell=0x%x, fid.Volume= 0x%x, fid .Vnode=0x%x, fid.Unique=0x%x", 
OBSOLETE 	     childEntry->fid.Cell,
OBSOLETE 	     childEntry->fid.fid.Volume, 
OBSOLETE 	     childEntry->fid.fid.Vnode, 
OBSOLETE 	     childEntry->fid.fid.Unique); 
OBSOLETE 
OBSOLETE     fill_fid_trans(&childEntry->fid);
OBSOLETE 
OBSOLETE #if 0
OBSOLETE     ReleaseWriteLock(&childEntry->lock);
OBSOLETE #endif
OBSOLETE 
OBSOLETE 
OBSOLETE     ret = volcache_getbyid (childEntry->fid.fid.Volume,
OBSOLETE 			    childEntry->fid.Cell,
OBSOLETE 			    ce,
OBSOLETE 			    &childEntry->volume,
OBSOLETE 			    &type);
OBSOLETE 
OBSOLETE     recon_hashtabadd(childEntry); 
OBSOLETE 
OBSOLETE     arla_log(ADEBDISCONN, 
OBSOLETE 	     "reconnect: create after volcache_getbyid, Cell=0x%x, "
OBSOLETE 	     "fid.Volume= 0x%x, fid .Vnode=0x%x, fid.Unique=0x%x",
OBSOLETE 	     childEntry->fid.Cell, 
OBSOLETE 	     childEntry->fid.fid.Volume, 
OBSOLETE 	     childEntry->fid.fid.Vnode, 
OBSOLETE 	     childEntry->fid.fid.Unique); 
OBSOLETE 
OBSOLETE /* SWW Qiyue 30: add the new file entry in dir */
OBSOLETE     arla_warnx (ADEBDISCONN,"reconnect_rename: we add the new one "
OBSOLETE 		"volumn=0x%x,vnode=0x%x,unique=0x%x",
OBSOLETE 		parentEntry->fid.fid.Volume,
OBSOLETE 		parentEntry->fid.fid.Vnode,
OBSOLETE 		parentEntry->fid.fid.Unique);
OBSOLETE 
OBSOLETE     adir_creat (parentEntry, name, childEntry->fid.fid);  
OBSOLETE 
OBSOLETE     childEntry->status = fetch_attr;
OBSOLETE   
OBSOLETE     childEntry->flags.attrp = TRUE;
OBSOLETE     childEntry->flags.kernelp = TRUE;
OBSOLETE 
OBSOLETE     childEntry->flags.datap = TRUE;
OBSOLETE     childEntry->tokens |= NNPFS_ATTR_R | NNPFS_DATA_R | NNPFS_DATA_W;
OBSOLETE 
OBSOLETE     if (parentEntry->volume == NULL)
OBSOLETE 	ret = volcache_getbyid (parentEntry->fid.fid.Volume,
OBSOLETE 				parentEntry->fid.Cell,
OBSOLETE 				ce,
OBSOLETE 				&parentEntry->volume,
OBSOLETE 				&type);
OBSOLETE 
OBSOLETE     volcache_update_volsync (parentEntry->volume, parentEntry->volsync);
OBSOLETE 
OBSOLETE 
OBSOLETE 
OBSOLETE /*SWW Qiyue 28: Set the host for child entry */
OBSOLETE 
OBSOLETE     childEntry->host = rx_HostOf (rx_PeerOf (conn->connection));
OBSOLETE     assert(childEntry->host);
OBSOLETE 
OBSOLETE /*SWW Qiyue 29:  */
OBSOLETE     arla_warnx (ADEBDISCONN,
OBSOLETE 		"Replace fid.Volume=0x%x,Vnode=0x%x,Unique=0x%x with "
OBSOLETE 		"Volume=0x%x,Vnode=0x%x,Unqiue=0x%x",
OBSOLETE 		fakeFid.fid.Volume,
OBSOLETE 		fakeFid.fid.Vnode,
OBSOLETE 		fakeFid.fid.Unique,
OBSOLETE 		childEntry->fid.fid.Volume,
OBSOLETE 		childEntry->fid.fid.Vnode,
OBSOLETE 		childEntry->fid.fid.Unique);
OBSOLETE 
OBSOLETE     reconnect_update_fid (childEntry, fakeFid);
OBSOLETE 
OBSOLETE     conv_dir(parentEntry, ce, 0, &cache_handle, tmp, sizeof(tmp));
OBSOLETE 
OBSOLETE     ReleaseWriteLock(&childEntry->lock);
OBSOLETE 
OBSOLETE  out:
OBSOLETE 
OBSOLETE     ReleaseWriteLock(&parentEntry->lock);
OBSOLETE     ReleaseWriteLock(&childEntry->lock);
OBSOLETE     free_fs_server_context(&context);
OBSOLETE     cred_free(ce);
OBSOLETE     return ret;
OBSOLETE }
OBSOLETE 
OBSOLETE /*
OBSOLETE  *
OBSOLETE  */
OBSOLETE 
OBSOLETE int reconnect_mkdir(struct vcache *parent, struct vcache *curdir, 
OBSOLETE                     AFSStoreStatus *store_status, char *name)
OBSOLETE {
OBSOLETE     ConnCacheEntry *conn; 
OBSOLETE     fs_server_context context;
OBSOLETE     CredCacheEntry *ce;
OBSOLETE     VenusFid *parent_fid;
OBSOLETE     VenusFid *child_fid;
OBSOLETE     VenusFid fakeFid;
OBSOLETE 
OBSOLETE     FCacheEntry *parentEntry, *childEntry, *tempEntry, *tempparEntry;
OBSOLETE     Result tempres;
OBSOLETE     int    ret = 0;
OBSOLETE     int    tempret = 0;
OBSOLETE     struct timeval tv;
OBSOLETE     char tmp[2 * sizeof(int) + 2];
OBSOLETE 
OBSOLETE     AFSFid  Outfid;   /* Ba Wu: These are used to get the info from FS*/
OBSOLETE     AFSFetchStatus fetch_attr;
OBSOLETE     AFSFetchStatus status;
OBSOLETE     AFSCallBack  callback;
OBSOLETE     AFSVolSync   volsync;
OBSOLETE     fcache_cache_handle cache_handle;
OBSOLETE     int32_t type;
OBSOLETE 
OBSOLETE     parent_fid = &(parent->fid); /* points to the VenusFid structure */
OBSOLETE     child_fid = &(curdir->fid);
OBSOLETE     fakeFid = *child_fid;
OBSOLETE 
OBSOLETE     parent_fid = fid_translate(parent_fid);
OBSOLETE 
OBSOLETE     ce = cred_get (parent->fid.Cell, parent->cred.pag, CRED_ANY);
OBSOLETE     assert (ce != NULL);
OBSOLETE 
OBSOLETE     ret = fcache_find (&parentEntry, *parent_fid);
OBSOLETE     assert (ret == 0);
OBSOLETE 
OBSOLETE     tempparEntry = parentEntry;
OBSOLETE 
OBSOLETE /*Ba ba: used to check whether name can be find  Deleted !!!
OBSOLETE   ReleaseWriteLock(&parentEntry->lock);
OBSOLETE   tempret = adir_lookup (parentEntry->fid , name , &foo_fid , NULL, ce);  */
OBSOLETE /*Ba ba: used to check whether name can be find  Deleted !!! */
OBSOLETE 
OBSOLETE     /*Ba Wu Remove the dir name from itsparent dir */
OBSOLETE     tempret = adir_remove(parentEntry,name);  
OBSOLETE     conn = find_first_fs (parentEntry, ce, &context);
OBSOLETE     if (conn == NULL) {
OBSOLETE 	arla_log (ADEBDISCONN,"Cannot make this connection");
OBSOLETE 	ReleaseWriteLock(&parentEntry->lock);
OBSOLETE 	ReleaseWriteLock(&childEntry->lock);
OBSOLETE 	cred_free(ce);
OBSOLETE 	return ENETDOWN;
OBSOLETE     }
OBSOLETE 
OBSOLETE     ret = fcache_find(&childEntry, *child_fid);/*Ba Wu: remove the newly created dir */
OBSOLETE     assert (ret == 0);
OBSOLETE 
OBSOLETE     recon_hashtabdel(childEntry);
OBSOLETE 
OBSOLETE     alloc_fid_trans(&childEntry->fid);
OBSOLETE 
OBSOLETE     gettimeofday(&tv, NULL);
OBSOLETE 
OBSOLETE     ret = RXAFS_MakeDir (conn->connection,
OBSOLETE 			 &parentEntry->fid.fid,
OBSOLETE 			 name,
OBSOLETE 			 store_status, 
OBSOLETE 			 &Outfid,
OBSOLETE 			 &fetch_attr,
OBSOLETE 			 &status,
OBSOLETE 			 &callback,
OBSOLETE 			 &volsync);
OBSOLETE 
OBSOLETE     if (ret) {
OBSOLETE 	arla_log (ADEBDISCONN, "Could not CreateFile: %s (%d)",
OBSOLETE 		  koerr_gettext(ret), ret);
OBSOLETE 	goto out;
OBSOLETE     }
OBSOLETE 
OBSOLETE     parentEntry->status   = status;
OBSOLETE     parentEntry->callback = callback;
OBSOLETE     parentEntry->callback.ExpirationTime += tv.tv_sec;
OBSOLETE     parentEntry->volsync  = volsync;
OBSOLETE 
OBSOLETE     childEntry->fid.Cell = parentEntry->fid.Cell;
OBSOLETE     childEntry->fid.fid = Outfid;
OBSOLETE     childEntry->status = fetch_attr;
OBSOLETE     childEntry->flags.attrp = TRUE;
OBSOLETE     childEntry->flags.kernelp = TRUE;
OBSOLETE     childEntry->flags.datap = TRUE;
OBSOLETE     childEntry->tokens |= NNPFS_ATTR_R | NNPFS_DATA_R | NNPFS_DATA_W;
OBSOLETE 
OBSOLETE     fill_fid_trans(&childEntry->fid);
OBSOLETE 
OBSOLETE     ret = volcache_getbyid (childEntry->fid.fid.Volume,
OBSOLETE 			    childEntry->fid.Cell,
OBSOLETE 			    ce,
OBSOLETE 			    &childEntry->volume,
OBSOLETE 			    &type);
OBSOLETE 
OBSOLETE     recon_hashtabadd(childEntry);
OBSOLETE 
OBSOLETE /*Ba ba: Need to change later!!! */
OBSOLETE #if 0
OBSOLETE     ReleaseWriteLock(&tempparEntry->lock);
OBSOLETE     tempret = adir_changefid (tempparEntry->fid ,name, &Outfid,  ce);
OBSOLETE     ReleaseWriteLock(&tempparEntry->lock);
OBSOLETE     tempret = adir_lookup (tempparEntry->fid ,name, &foo_fid, NULL, ce);
OBSOLETE #endif
OBSOLETE 
OBSOLETE     tempret = adir_creat (parentEntry, name, childEntry->fid.fid); 
OBSOLETE 
OBSOLETE     childEntry->host = rx_HostOf (rx_PeerOf (conn->connection));
OBSOLETE     assert(childEntry->host);
OBSOLETE 
OBSOLETE     reconnect_update_fid(childEntry, fakeFid);
OBSOLETE      
OBSOLETE     tempres = conv_dir(parentEntry, ce, 0, &cache_handle,
OBSOLETE 		       tmp, sizeof(tmp));
OBSOLETE 
OBSOLETE     ReleaseWriteLock(&childEntry->lock);
OBSOLETE 
OBSOLETE     /*SWW Qiyue 29: This should be deleted later */                      
OBSOLETE     ret = fcache_find (&tempEntry, childEntry->fid);  
OBSOLETE 
OBSOLETE     assert (ret == 0);
OBSOLETE     ReleaseWriteLock(&tempEntry->lock);
OBSOLETE 
OBSOLETE  out:
OBSOLETE 
OBSOLETE     ReleaseWriteLock(&parentEntry->lock);
OBSOLETE     ReleaseWriteLock(&childEntry->lock);
OBSOLETE     free_fs_server_context(&context);
OBSOLETE     cred_free(ce);
OBSOLETE     return ret;
OBSOLETE }
OBSOLETE 
OBSOLETE /*
OBSOLETE  *
OBSOLETE  */
OBSOLETE 
OBSOLETE int reconnect_link(struct vcache *parent, struct vcache *existing,
OBSOLETE 		   char *name)
OBSOLETE {
OBSOLETE     ConnCacheEntry *conn;
OBSOLETE     fs_server_context context;
OBSOLETE     CredCacheEntry *ce;
OBSOLETE     VenusFid *parent_fid;  
OBSOLETE     VenusFid *existing_fid;
OBSOLETE     char tmp[2 * sizeof(int) + 2];
OBSOLETE     int ret = 0;
OBSOLETE     FCacheEntry *dir_entry,*existing_entry;
OBSOLETE     Result res;
OBSOLETE 
OBSOLETE     AFSFetchStatus new_status;
OBSOLETE     AFSFetchStatus status;
OBSOLETE     AFSVolSync volsync;
OBSOLETE     fcache_cache_handle cache_handle;
OBSOLETE 
OBSOLETE 
OBSOLETE     parent_fid = &(parent->fid);
OBSOLETE     existing_fid = &(existing->fid);
OBSOLETE 
OBSOLETE     parent_fid = fid_translate(parent_fid);
OBSOLETE 
OBSOLETE     ce = cred_get (parent->fid.Cell, parent->cred.pag, CRED_ANY);
OBSOLETE     assert (ce != NULL);
OBSOLETE 
OBSOLETE     ret = fcache_find (&dir_entry, *parent_fid);
OBSOLETE     assert (ret == 0);
OBSOLETE 
OBSOLETE     ret = fcache_find (&existing_entry, *existing_fid);
OBSOLETE     assert (ret == 0);
OBSOLETE 
OBSOLETE     conn = find_first_fs (dir_entry, ce, &context);
OBSOLETE     if (conn == NULL) {
OBSOLETE 	arla_log (ADEBDISCONN,"Cannot make this connection");
OBSOLETE 	ReleaseWriteLock(&dir_entry->lock);
OBSOLETE 	ReleaseWriteLock(&existing_entry->lock);
OBSOLETE 	cred_free(ce);
OBSOLETE 	return ENETDOWN;
OBSOLETE     }
OBSOLETE 
OBSOLETE     ret = RXAFS_Link (conn->connection,
OBSOLETE 		      &dir_entry->fid.fid,
OBSOLETE 		      name,
OBSOLETE 		      &existing_entry->fid.fid,
OBSOLETE 		      &new_status,
OBSOLETE 		      &status,
OBSOLETE 		      &volsync);
OBSOLETE     if (ret) {
OBSOLETE 	arla_warn (ADEBFCACHE, ret, "Link");
OBSOLETE 	goto out;
OBSOLETE     }
OBSOLETE 
OBSOLETE     dir_entry->status  = status;
OBSOLETE     dir_entry->volsync = volsync;
OBSOLETE 
OBSOLETE     existing_entry->status = new_status;
OBSOLETE     
OBSOLETE     volcache_update_volsync (dir_entry->volume, dir_entry->volsync);
OBSOLETE 
OBSOLETE     res = conv_dir (dir_entry, ce, 0, &cache_handle, tmp, sizeof(tmp));
OBSOLETE 	
OBSOLETE  out:
OBSOLETE     ReleaseWriteLock(&dir_entry->lock);
OBSOLETE     ReleaseWriteLock(&existing_entry->lock);
OBSOLETE     cred_free(ce);
OBSOLETE     free_fs_server_context (&context);
OBSOLETE     return ret;
OBSOLETE }
OBSOLETE 
OBSOLETE /*
OBSOLETE  *
OBSOLETE  */
OBSOLETE 
OBSOLETE int reconnect_symlink(struct vcache *parent, struct vcache *child,
OBSOLETE 		      AFSStoreStatus *store_attr, char *name, 
OBSOLETE 		      char *contents)
OBSOLETE {
OBSOLETE     ConnCacheEntry *conn;
OBSOLETE     fs_server_context context;
OBSOLETE     CredCacheEntry *ce;
OBSOLETE     VenusFid *parent_fid, *child_fid, fakeFid;
OBSOLETE     char tmp[2 * sizeof(int) + 2];
OBSOLETE     int ret = 0;
OBSOLETE     FCacheEntry *dir_entry, *childEntry;
OBSOLETE     Result res;
OBSOLETE 
OBSOLETE     AFSFetchStatus fetch_attr, new_status;
OBSOLETE     AFSVolSync volsync;
OBSOLETE     fcache_cache_handle cache_handle;
OBSOLETE     int32_t type;
OBSOLETE 
OBSOLETE     parent_fid = &(parent->fid);
OBSOLETE     child_fid  = &(child->fid);
OBSOLETE     fakeFid    = *child_fid;
OBSOLETE     parent_fid = fid_translate(parent_fid);
OBSOLETE 
OBSOLETE     ce = cred_get (parent->fid.Cell, parent->cred.pag, CRED_ANY);
OBSOLETE     assert (ce != NULL);
OBSOLETE 
OBSOLETE     ret = fcache_find (&dir_entry, *parent_fid);
OBSOLETE     assert (ret == 0);
OBSOLETE 
OBSOLETE     adir_remove(dir_entry,name);
OBSOLETE 
OBSOLETE     ret = fcache_find (&childEntry, *child_fid);
OBSOLETE     assert (ret == 0);
OBSOLETE 
OBSOLETE     recon_hashtabdel(childEntry);
OBSOLETE 
OBSOLETE     assert(ret==0);
OBSOLETE     conn = find_first_fs (dir_entry, ce, &context);
OBSOLETE     if (conn == NULL) {
OBSOLETE 	arla_log (ADEBDISCONN,"Cannot make this connection");
OBSOLETE 	ReleaseWriteLock(&dir_entry->lock);
OBSOLETE 	ReleaseWriteLock(&childEntry->lock);
OBSOLETE 	cred_free(ce);
OBSOLETE 	return ENOMEM;
OBSOLETE     }
OBSOLETE   
OBSOLETE     alloc_fid_trans(&childEntry->fid);
OBSOLETE 
OBSOLETE     ret = RXAFS_Symlink (conn->connection,
OBSOLETE 			 &dir_entry->fid.fid,
OBSOLETE 			 name,
OBSOLETE 			 contents,
OBSOLETE 			 store_attr,
OBSOLETE 			 &(childEntry->fid.fid),
OBSOLETE 			 &fetch_attr,
OBSOLETE 			 &new_status,
OBSOLETE 			 &volsync);
OBSOLETE     if (ret) {
OBSOLETE 	arla_warn (ADEBFCACHE, ret, "Symlink");
OBSOLETE 	goto out;
OBSOLETE     }
OBSOLETE 
OBSOLETE     child_fid->Cell = dir_entry->fid.Cell;
OBSOLETE 
OBSOLETE     fill_fid_trans (&childEntry->fid);
OBSOLETE     ret = volcache_getbyid (childEntry->fid.fid.Volume,
OBSOLETE 			    childEntry->fid.Cell,
OBSOLETE 			    ce,
OBSOLETE 			    &childEntry->volume,
OBSOLETE 			    &type);
OBSOLETE 
OBSOLETE     recon_hashtabadd (childEntry);
OBSOLETE 
OBSOLETE     adir_creat(dir_entry, name, childEntry->fid.fid);
OBSOLETE 
OBSOLETE     childEntry->status = fetch_attr;
OBSOLETE     childEntry->flags.attrp = TRUE;
OBSOLETE     childEntry->flags.kernelp = TRUE;
OBSOLETE     childEntry->tokens |= NNPFS_ATTR_R;
OBSOLETE     volcache_update_volsync (dir_entry->volume, dir_entry->volsync);
OBSOLETE 
OBSOLETE     childEntry->host = rx_HostOf (rx_PeerOf (conn->connection));
OBSOLETE     assert(childEntry->host);
OBSOLETE 
OBSOLETE     reconnect_update_fid(childEntry, fakeFid);
OBSOLETE     res = conv_dir (dir_entry, ce, 0, &cache_handle, tmp, sizeof(tmp));
OBSOLETE 
OBSOLETE  out: 
OBSOLETE     ReleaseWriteLock(&dir_entry->lock);
OBSOLETE     ReleaseWriteLock(&childEntry->lock);
OBSOLETE     free_fs_server_context(&context);
OBSOLETE     cred_free(ce);
OBSOLETE     return ret;
OBSOLETE }
OBSOLETE 
OBSOLETE #endif
@


1.6
log
@Merge
@
text
@@


1.5
log
@strcpy/strcat/sprintf cleanups; ok krw deraadt
@
text
@d1 2213
a2213 2207
/* COPYRIGHT  (C)  1998
 * THE REGENTS OF THE UNIVERSITY OF MICHIGAN
 * ALL RIGHTS RESERVED
 * 
 * PERMISSION IS GRANTED TO USE, COPY, CREATE DERIVATIVE WORKS 
 * AND REDISTRIBUTE THIS SOFTWARE AND SUCH DERIVATIVE WORKS 
 * FOR ANY PURPOSE, SO LONG AS THE NAME OF THE UNIVERSITY OF 
 * MICHIGAN IS NOT USED IN ANY ADVERTISING OR PUBLICITY 
 * PERTAINING TO THE USE OR DISTRIBUTION OF THIS SOFTWARE 
 * WITHOUT SPECIFIC, WRITTEN PRIOR AUTHORIZATION.  IF THE 
 * ABOVE COPYRIGHT NOTICE OR ANY OTHER IDENTIFICATION OF THE 
 * UNIVERSITY OF MICHIGAN IS INCLUDED IN ANY COPY OF ANY 
 * PORTION OF THIS SOFTWARE, THEN THE DISCLAIMER BELOW MUST 
 * ALSO BE INCLUDED.
 * 
 * THIS SOFTWARE IS PROVIDED AS IS, WITHOUT REPRESENTATION 
 * FROM THE UNIVERSITY OF MICHIGAN AS TO ITS FITNESS FOR ANY 
 * PURPOSE, AND WITHOUT WARRANTY BY THE UNIVERSITY OF 
 * MICHIGAN OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING 
 * WITHOUT LIMITATION THE IMPLIED WARRANTIES OF 
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE 
 * REGENTS OF THE UNIVERSITY OF MICHIGAN SHALL NOT BE LIABLE 
 * FOR ANY DAMAGES, INCLUDING SPECIAL, INDIRECT, INCIDENTAL, OR 
 * CONSEQUENTIAL DAMAGES, WITH RESPECT TO ANY CLAIM ARISING 
 * OUT OF OR IN CONNECTION WITH THE USE OF THE SOFTWARE, EVEN 
 * IF IT HAS BEEN OR IS HEREAFTER ADVISED OF THE POSSIBILITY OF 
 * SUCH DAMAGES.
 */

/*
 * Do merging of the files that changed with we was in disconnected mode
 */

#if 0

#include "arla_local.h"

RCSID("$KTH: reconnect.c,v 1.30.2.1 2001/06/04 22:16:39 ahltorp Exp $");

static int reconnect_nonmute(struct vcache *, int, struct timeval);
static int reconnect_putattr(struct vcache *, struct xfs_attr *);
static int reconnect_putdata(struct vcache *);    
static int reconnect_remove(struct vcache *, FCacheEntry *childentry, char *);
static int reconnect_rename(struct vcache *, struct vcache *, char *, char *);
static int reconnect_rmdir(struct vcache *vcp, FCacheEntry *childEntry,
			   char *name);
static int reconnect_mkdir(struct vcache *parent, struct vcache *curdir, 
			   AFSStoreStatus *store_status, char *name);
static int reconnect_link(struct vcache *parent, struct vcache *existing,
			  char *name);
static int reconnect_symlink(struct vcache *parent, struct vcache *child,
			     AFSStoreStatus *store_attr, char *name, 
			     char *contents);
static int reconnect_create(struct vcache *parent, struct vcache *child,
			    char *name);
static int reconnect_mut_chk(FCacheEntry *fce, CredCacheEntry *ce,
			     int version);

static int check_log_todo(log_ent_t * , VenusFid *, VenusFid *);
static int is_done_before(int no);
static void add_done_list(int no);
static void clear_log_entry(void);
static void clear_index_list(void);

typedef struct _fid_trans{
    VenusFid logged_fid;
    VenusFid fetched_fid;
    struct _fid_trans *next, *prev;
} fid_trans;

typedef struct _fid_keep{
    char name[MAX_NAME];
    AFSFid kept_fid;
    struct _fid_keep *next;
} fid_keep;

typedef struct _index_list{
    int   index;
    struct _index_list * next;
} index_list;

fid_trans *fid_AD_head, *fid_AD_tail;
fid_keep  *fid_KP_head;
index_list * index_head;
extern log_ent_t  log_head;


/*
 *
 */

static void
set_fid_value(VenusFid *new, VenusFid *old)
{
    if(old==0) {
	new->fid.Volume = 0;
	new->fid.Vnode = 0;
	new->fid.Unique = 0;
    } else {
	new->fid.Volume = old->fid.Volume;
	new->fid.Vnode  = old->fid.Vnode;
        new->fid.Unique = old->fid.Unique;
    }
}

/*
 *
 */

void 
do_replay(char *log_file, int log_entries, VenusFid *changed_fid)
{
    int fd, len, i;
    log_ent_t *cur_log;
    struct vcache vc, vc_new;
    char *name, *name_new;
    fid_trans *fid_tmp;
    fid_keep * fid_KP_tail;
    VenusFid new_fid; 

    int count=1; /* Used to record how may actions we have done*/

    fid_AD_tail = fid_AD_head;
    cur_log = (log_ent_t *) malloc(sizeof(log_ent_t));
    fd = open(log_file, O_RDWR | O_BINARY);

    set_fid_value(&new_fid , 0);

    while (read(fd, cur_log, sizeof(int))){

	if (cur_log->log_len < sizeof(*cur_log) - sizeof(cur_log->log_data) ||
            cur_log->log_len > sizeof(log_ent_t)) {
	    arla_log(ADEBDISCONN, "do_replay: corrupt log entry, log_len %d",
		     cur_log->log_len);
	    goto terminate;
	}

	len = cur_log->log_len - sizeof(int);

	if (!read(fd, ((char *)cur_log + sizeof(int)), len)){
	    arla_log(ADEBDISCONN, "do_replay: read bad log entry...");
	    goto terminate;
	}

	arla_log(ADEBDISCONN, 
		 "do_replay: read %d bytes of log entry.", 
		 cur_log->log_len);

	if (is_done_before(cur_log->log_index)==1)
	    continue; /* the log entry has been executed */
	else {
	    if (changed_fid !=0) {
		int is_log_todo = 0;
 
		is_log_todo = check_log_todo(cur_log, changed_fid, &new_fid);
		if (is_log_todo ==0)
		    continue; /* This log should not be  executed */
	    }
	}

	add_done_list(cur_log->log_index);

	/* big case/switch statement to switch log_op  */
	switch (cur_log->log_op){

	case DIS_STORE:
	    vc.fid = cur_log->st_fid;
	    vc.DataVersion = cur_log->st_origdv-1;
	    vc.flag = cur_log->st_flag;
	    vc.cred = cur_log->cred;
	    arla_log(ADEBDISCONN, 
		     "%d action is to do_replay: **replay** (putdata) op...",
		     count++);
	    reconnect_putdata(&vc);
	    break;
	case DIS_SETATTR:
	    vc.fid = cur_log->sa_fid;
	    vc.DataVersion = cur_log->sa_origdv;
	    vc.flag = 0;
	    vc.cred = cur_log->cred;
	    arla_log(ADEBDISCONN, 
		     "%d action is to do_replay: **replay** (putattr) op...",
		     count++);
	    reconnect_putattr(&vc, &(cur_log->sa_vattr));
	    break;
	case DIS_REMOVE: {
	    FCacheEntry *childentry;
	    vc.fid = cur_log->rm_filefid;
	    vc.DataVersion = cur_log->rm_origdv;
	    vc.flag = 0;
	    vc.cred = cur_log->cred;
	    childentry = cur_log->rm_chentry;
	    name = cur_log->rm_name;
	    arla_log(ADEBDISCONN, 
		     "%d action is to do_replay: **replay** "
		     "(file remove) op...",
		     count++);
	    reconnect_remove(&vc, childentry, name);
	    break;
	}
	case DIS_RMDIR: {
	    FCacheEntry *child;
	    vc.fid = cur_log->rd_parentfid;
	    name = cur_log->rd_name;
	    vc.cred = cur_log->cred;
	    child = cur_log->rd_direntry;
	    arla_log (ADEBDISCONN,
		      "%d action is to do_replay: **rmdir** "
		      "(directory remove) op...",
		      count++);
	    reconnect_rmdir(&vc, child, name);
	    break;
	}
	case DIS_RENAME:
	    vc.fid = cur_log->rn_oparentfid;
	    vc.DataVersion = cur_log->rn_origdv;
	    vc.flag = 0;
	    vc.cred = cur_log->cred;
	    vc_new.fid = cur_log->rn_nparentfid;
	    vc_new.DataVersion = cur_log->rn_overdv;
	    vc_new.flag = 0;
	    vc_new.cred = cur_log->cred;
	    name = cur_log->rn_names;
	    for (i=0; *(name+i)!='\0';++i);
	    name_new = name+i+1; 
	    arla_log(ADEBDISCONN, 
		     "%d action is to do_replay: **replay** (rename) op...",
		     count++);
	    reconnect_rename(&vc, &vc_new, name, name_new);
	    break;
	case DIS_MKDIR:	{ 
	    AFSStoreStatus store_status;
	    vc.fid = cur_log->md_parentfid;
	    vc.cred = cur_log->cred;
	    store_status = cur_log->md_vattr;
	    vc_new.fid = cur_log->md_dirfid;
	    /*Ba Wu: child's data vers*/
	    vc_new.DataVersion = cur_log->md_dversion; 
	    name = cur_log->md_name;
	    arla_log(ADEBDISCONN, 
		     "%d action is to DO_Replay: **replay** (mkdir) op...",
		     count++);
	    reconnect_mkdir(&vc, &vc_new, &store_status, name);
	    break; 
	}
	case DIS_LINK:
	    vc.cred = cur_log->cred;
	    vc.fid = cur_log->ln_parentfid;
	    vc_new.fid = cur_log->ln_linkfid;
	    name = cur_log->ln_name;
	    arla_log(ADEBDISCONN, 
		     "%d action is to do_replay: **replay** (link) op...",
		     count++);
	    reconnect_link(&vc, &vc_new, name);
	    break;
	case DIS_SYMLINK: {
	    char *new_name;
	    AFSStoreStatus store_attr;
	    
	    vc.fid = cur_log->sy_parentfid;
	    vc.cred = cur_log->cred;
	    name = cur_log->sy_name;
	    new_name = cur_log->sy_content;
	    vc_new.fid = cur_log->sy_filefid;
	    store_attr = cur_log->sy_attr;
	    arla_log(ADEBDISCONN, 
		     "%d action is to do_replay: **replay** (symlink) op...",
		     count++);
	    reconnect_symlink(&vc, &vc_new, &store_attr, name, new_name);
	    break;
	}
	case DIS_CREATE:
	    vc.fid = cur_log->cr_parentfid;
	    vc.cred = cur_log->cred;
 
	    vc_new.fid = cur_log->cr_filefid;
	    vc_new.DataVersion = cur_log->cr_origdv;
	    arla_log(ADEBDISCONN, 
		     "%d action is to DO_Replay: **replay** (create) op...",
		     count++);
	    name = cur_log->cr_name;
	    reconnect_create(&vc, &vc_new, name); 
	    break; 
	case DIS_ACCESS:
	    vc.fid = cur_log->nm_fid;
	    vc.DataVersion = cur_log->nm_origdv;
	    vc.cred = cur_log->cred;
	    arla_log(ADEBDISCONN, 
		     "%d action is to do_replay: **replay** (nonmutating) op",
		     count++);
	    reconnect_nonmute(&vc, cur_log->log_op, cur_log->log_time);
	    break; 

	default:
	    arla_log(ADEBDISCONN, 
		     "%d action is to do_replay: skipping the current op=%d", 
		     count++,cur_log->log_op);
	}
    }  

    if (changed_fid ==0) {
	clear_index_list();  /* clean all index when after discon */
	clear_log_entry();
        /* clean up, remove all associative data structures */
        fid_AD_tail = fid_AD_head;
  	while(fid_AD_tail)
  	{
	    fid_tmp = fid_AD_tail->next;
	    free(fid_AD_tail);
	    fid_AD_tail = fid_tmp; 
  	}   
	/* SWW Qiyue 28: We need to reset head to 0*/
  	fid_AD_head = 0;
  	fid_KP_tail = fid_KP_head;
    	while(fid_KP_tail)
    	{
	    fid_keep *fid_tmp;
	
	    fid_tmp = fid_KP_tail->next;
	    free(fid_KP_tail);
	    fid_KP_tail = fid_tmp;
    	}
   	 
  	fid_KP_head = 0;
    }
    i = ftruncate (fd, 0);
    assert (i == 0);

 terminate:

    arla_warnx (ADEBDISCONN,"We have done total %d replays",count-1);
    close(fd);  
    free(cur_log);
    return;
}

/*
 *
 */

static int 
check_rm_fid (VenusFid v1, VenusFid v2)
{
    if(v1.fid.Vnode == v2.fid.Vnode &&
       v1.fid.Volume == v2.fid.Volume &&
       v1.fid.Unique == v2.fid.Unique )
	return 1;
    else
	return 0;
}

/*
 *
 */

static int 
check_log_fid(struct vcache vc, VenusFid *fid)
{
    log_ent_t *temp = log_head.next;

    if (vc.fid.fid.Vnode == fid->fid.Vnode &&
	vc.fid.fid.Volume == fid->fid.Volume &&
	vc.fid.fid.Unique == fid->fid.Unique)
	return 1;

    while (temp!=0) {
	switch(temp->log_op) {
	case DIS_RENAME:
	    if (check_rm_fid(temp->rn_oparentfid,*fid)==1) 
		return 1;
	default: 
	    temp = temp->next;
	    break;
        }
    }
    return 0;
}

/*
 *
 */

static int 
check_log_todo(log_ent_t * cur_log , VenusFid *fid, VenusFid *newfid)
{
    VenusFid *lookfid;
    struct vcache vc, vc_new;
    int will_do = 0;

    if (newfid->fid.Vnode ==0 &&
	newfid->fid.Volume == 0 &&
	newfid->fid.Unique ==0)
	lookfid = fid;
    else
	lookfid = newfid; /* For create and putdata */

    switch (cur_log->log_op){
    case DIS_STORE:
        vc.fid = cur_log->st_fid;
	will_do = check_log_fid(vc, lookfid);
        if (will_do==1) {
	    set_fid_value(newfid, 0);
	    return 1;
        }
        break;
    case DIS_SETATTR:
	vc.fid = cur_log->sa_fid;
	will_do = check_log_fid(vc, lookfid);
        if (will_do==1) {
	    set_fid_value(newfid , &cur_log->sa_fid);
	    return 1;
        }
        break;
    case DIS_REMOVE:
	vc.fid = cur_log->rm_filefid;
	will_do = check_log_fid(vc, lookfid);
        if (will_do==1) {
	    return 1;
        }
        break;
    case DIS_RMDIR:
	vc.fid = cur_log->rd_parentfid;
	will_do = check_log_fid(vc, lookfid);
        if (will_do==1) {
	    return 1;
        }
        break;
    case DIS_RENAME:
	vc.fid = cur_log->rn_oparentfid;
	will_do = check_log_fid(vc, lookfid);
        if (will_do==1) {
	    return 1;
        }
	vc_new.fid = cur_log->rn_nparentfid;
	will_do = check_log_fid(vc_new, lookfid);
        if (will_do==1) {
	    return 1;
        }
        break;
    case DIS_MKDIR:
	vc.fid = cur_log->md_parentfid;
	will_do = check_log_fid(vc, lookfid);
        if (will_do==1) {
	    return 1;
        }
	break;
    case DIS_LINK:
        break;
    case DIS_SYMLINK:
	will_do = check_log_fid(vc, lookfid);
        if (will_do==1) {
	    return 1;
        }
        break;
    case DIS_CREATE:
	vc.fid = cur_log->cr_parentfid;
        will_do = check_log_fid(vc, lookfid);
	if (will_do==1) {
	    set_fid_value(newfid , &cur_log->cr_filefid);
	    return 1;
	}
	break;
    case DIS_FSYNC:
    case DIS_ACCESS:
    case DIS_READDIR:
    case DIS_READLINK:
    case DIS_INFO:
    case DIS_START_OPT:
    case DIS_END_OPT:
    case DIS_REPLAYED:
	/* A no op */
	break;
    }
    return 0;
}


#if 0

/*
 *
 */

void
keepfid_newrename(char *name,
		  AFSFid fid)
{
    if (fid_KP_head == 0) {
        fid_KP_head = (fid_keep *)malloc(sizeof(fid_keep));
        assert(fid_KP_head);

        strlcpy(fid_KP_head->name, name, sizeof(fid_KP_head->name));
	fid_KP_head->kept_fid = fid;
	fid_KP_head->next = 0;
    }
    else { 
        fid_keep *temp;

        temp = (fid_keep *)malloc(sizeof(fid_keep));
	assert(temp);

        strlcpy(temp->name, name, sizeof(temp->name));
	temp->kept_fid = fid;
	temp->next = fid_KP_head->next;
	fid_KP_head->next = temp;
    }
}

#endif

/*
 *
 */

static int 
find_venus (char *name, VenusFid *fid)
{
    fid_keep *fid_temp;

    if(fid_KP_head == 0 )
	return 1;  /*error */
  	
    fid_temp = fid_KP_head;

    while(fid_temp) {
	if (strcmp(fid_temp->name,name) == 0) {
	    fid->fid.Volume = fid_temp->kept_fid.Volume;
	    fid->fid.Vnode = fid_temp->kept_fid.Vnode;
	    fid->fid.Unique = fid_temp->kept_fid.Unique;
	    return 0;
        }
	fid_temp = fid_temp->next;
    }
    arla_warnx (ADEBDISCONN, "find_venus: *PANIC* not found fid for %s", name);
    return 1;
}


/*
 *
 */

VenusFid *
fid_translate(VenusFid *fid_in)
{
    fid_trans *fid_tmp;
    VenusFid *fid_ret;

    if (!fid_AD_head)
	return fid_in;

    fid_tmp = fid_AD_head;

    while(fid_tmp){

	fid_ret=&fid_tmp->logged_fid;

	if ((fid_ret->Cell == fid_in->Cell) && 
	    (fid_ret->fid.Volume == fid_in->fid.Volume) && 
	    (fid_ret->fid.Vnode == fid_in->fid.Vnode) && 
	    (fid_ret->fid.Unique == fid_in->fid.Unique))
	    return &fid_tmp->fetched_fid;

	fid_tmp = fid_tmp->next;	   
    }
    return fid_in; 
}

/*
 *
 */

static void 
clear_index_list(void)
{
    index_list *temp=index_head;

    while(temp!=0) {
	index_list *tmp;
    
  	tmp = temp->next;
        free(temp);
	temp = tmp;
    }
    index_head = 0;
}

/*
 *
 */

static void 
clear_log_entry(void)
{
    log_ent_t *temp=log_head.next;

    while(temp!=0) {             
        log_ent_t *tmp;

        tmp = temp->next;
        free(temp);                          
        temp = tmp;
    }                        
    log_head.next = 0;    
}

/*
 *
 */

static int 
is_done_before(int no)
{
    index_list * temp = index_head;

    while(temp !=0) {
	if (temp->index == no)
	    return 1;
	else
	    temp = temp->next;
    }
    return 0;
}

/*
 *
 */

static void 
add_done_list(int no)
{
    if (!index_head) {
	index_head = (index_list *)malloc(sizeof(index_list));
	assert(index_head);
	index_head->index = no;
	index_head->next = 0;
    } else {
	index_list * temp;
	temp = (index_list *) malloc(sizeof(index_list));
	assert(temp);
	temp->next = index_head->next;
	index_head->next = temp;
	temp->index = no;
    }
}

/*
 *
 */

static void 
alloc_fid_trans(VenusFid *logged_fid)
{
    if (!fid_AD_head)
    {
	/*SWW Qiyue 28 Make sure we have the memory*/
	fid_AD_head = (fid_trans *) malloc(sizeof(fid_trans)); 
	assert(fid_AD_head);

	fid_AD_head->prev=fid_AD_head->next = 0;
	fid_AD_tail = fid_AD_head;
	fid_AD_tail->logged_fid = *logged_fid;

    } else{

	/*SWW Qiyue 28 Make sure we have the memory*/
	fid_AD_tail->next = (fid_trans *) malloc(sizeof(fid_trans)); 
	assert(fid_AD_tail->next);

	fid_AD_tail->next->prev = fid_AD_tail;
	fid_AD_tail->next->next = 0;
	fid_AD_tail = fid_AD_tail->next;  /*Ba ba: move tail ahead */
	fid_AD_tail->logged_fid = *logged_fid;
    }
}

/*
 *
 */

static void 
fill_fid_trans (VenusFid *fetched_fid)
{
    fid_AD_tail->fetched_fid = *fetched_fid;
}

/*
 *
 */

#if 0
void
update_entry_flag (FCacheEntry *entry)
{
    entry->flags.attrp = FALSE;
    entry->flags.datap = FALSE;
}
#endif

/*
 *
 */

int reconnect_nonmute(struct vcache *vcp, int op, struct timeval log_time)
{
    FCacheEntry *fce, fce_fetched;
    CredCacheEntry *ce;
    int error;
    VenusFid *fid; 
#if 0
    ConnCacheEntry *conn;
#endif

    arla_warnx (ADEBDISCONN,
		"Start of reconnect_nonmute by sww"); /*SWW Qiyue 25*/

    fid = &(vcp->fid);
    if (fid->Cell == -1) /* newly created file, skip reconnect */
	return 0;

    error = fcache_find(&fce, *fid);
    /* assert(fce); */
    if (error) /* nonmute op on nonexisting data */
    {     
	arla_log(ADEBDISCONN, 
		 "reconnect: nonmute op %d performed on cache "
		 "entry no longer exist locally!", 
		 op); 
	return -1;
    }   

    arla_log(ADEBDISCONN, 
	     "reconnect: DISCONNECTED nonmute "
	     "on fid.Cell=0x%x, fid.fid.Volume= 0x%x, fid.fid.Vnode=0x%x, "
	     "fid.fid.Unique=0x%x", fid->Cell, 
	     fid->fid.Volume,
	     fid->fid.Vnode, 
	     fid->fid.Unique);  

    ce = cred_get (fid->Cell, vcp->cred.pag, CRED_ANY);
    assert (ce != NULL);
    error = 0;
  
    /* setting some stuff so do_read_attr would work */
    fce->flags.attrp = TRUE;
    fce->callback.CallBackType = 2;
    fce_fetched = *fce;
    /*conn = findconn (fce, ce);*/

    error = read_attr(&fce_fetched, ce);

    arla_log(ADEBDISCONN, 
	     "reconnect: logged DataVersion=%d, "
	     "fetched DataVersion=%d", 
	     vcp->DataVersion,
	     fce_fetched.status.DataVersion);
 
    if (vcp->DataVersion < fce_fetched.status.DataVersion)
    {
	if (log_time.tv_usec >= fce_fetched.status.ServerModTime)
	    arla_log(ADEBDISCONN, 
		     "Warning: nonmutating operation %d read stale data!", 
		     op);
	else if (log_time.tv_usec <= fce_fetched.status.ServerModTime && 
		 (vcp->DataVersion +1) == fce_fetched.status.DataVersion)
	    arla_log(ADEBDISCONN, 
		     "Notice: file modified once after nonmutating "
		     "operation %d.",
		     op);
	else
	    arla_log(ADEBDISCONN, 
		     "Warning: nonmutating operation %d might have read "
		     "stale data!", op);
    } 
 
    ReleaseWriteLock(&fce->lock);
    cred_free(ce);
    /*conn_free(conn);*/

    return error;
}

/*
 *
 */

int reconnect_remove(struct vcache *vcp, FCacheEntry *childentry, char *name)
{
    FCacheEntry *fce;
    CredCacheEntry *ce;
    int error;
    VenusFid *fid, tempfid; /* Ba san: to check the deletion of file*/
    Result res;
    int    isupdate;

    ConnCacheEntry *conn;
    fs_server_context context;
    AFSFetchStatus status;
    AFSVolSync volsync; 
    char tmp[2 * sizeof(int) + 2];
    fcache_cache_handle cache_handle;

    fid = &(vcp->fid); /* points to the VenusFid structure */
    fid = fid_translate(fid);

    arla_log(ADEBDISCONN, "reconnect: DISCONNECTED remove on "
	     "fid.Cell=0x%x, fid.fid.  Volume= 0x%x, fid.fid.Vnode=0x%x, "
	     "fid.fid.Unique=0x%x", 
	     fid->Cell, fid->fid.Volume, fid->fid.Vnode, fid->fid.Unique);

    /* ObtainWriteLock called in fcache_find */
    error = fcache_find(&fce, *fid); 
    assert (error == 0);

    ce = cred_get (fid->Cell, vcp->cred.pag, CRED_ANY);
    assert (ce != NULL);

    if (connected_mode != CONNMODE_PARCONNECTED) {
	ObtainWriteLock(&childentry->lock);
	isupdate = reconnect_mut_chk(childentry, ce, 
				     childentry->status.DataVersion);
	ReleaseWriteLock(&childentry->lock);
  
	if (isupdate)
	{
	    fcache_cache_handle cache_handle;

	    arla_log(ADEBDISCONN, 
		     "reconnect_remove: can't remove because file modified!");
	    cred_free(ce);
	    adir_creat (fce, name, childentry->fid.fid);
	    childentry->flags.attrp = FALSE;
	    ReleaseWriteLock(&fce->lock);
	    conv_dir (fce, ce, 0, &cache_handle, tmp, sizeof(tmp));
	    ReleaseWriteLock(&fce->lock);
	    return -1;
	}
    }  /* Ba ershi: we dont need to do it in parconn */

    res.res = 0;

    AssertExclLocked(&fce->lock);

    conn = find_first_fs (fce, ce, &context);
    if (conn == NULL) {
	arla_log (ADEBDISCONN, "find_first_fs failed", fce->index);
	cred_free(ce);
	ReleaseWriteLock(&fce->lock);
	return ENETDOWN;
    }

/* Ba san: check the file exists 

   ReleaseWriteLock(&fce->lock);
   error = adir_lookup(fce->fid, name, &tempfid, NULL, &ce);
   assert (error == 0);                                             
   ObtainWriteLock(&fce->lock);  */
     
    res.res = RXAFS_RemoveFile (conn->connection,
				&fce->fid.fid,
				name,
				&status,
				&volsync);
    if (res.res) {
	arla_log (ADEBDISCONN, "Could not RemoveFile: %s (%d)",
		  koerr_gettext(res.res), res.res);
	goto out;
    }

    arla_warnx (ADEBDISCONN,"In reconnect_remove: Remove the file %s",name);

/* Ba san: Chcek the deletion of the file */
    ReleaseWriteLock(&fce->lock);
    error = adir_lookup(&fce->fid, name, &tempfid, NULL, &ce);
    ObtainWriteLock(&fce->lock);

    if (error == 0) {
	int result;
        
	arla_warnx (ADEBDISCONN,
		    "In reconnect_remove: file %s needs to be deleted",
		    name);
	result = adir_remove (fce,name);
	assert ( result == 0);
    } /* This is for the file produced during disconnect mode,
	 if error==ENOENT then the file is created during connect mode*/
  

    fce->status  = status;
    fce->volsync = volsync;
    childentry->host = 0;  /* Ba shiliu dont get callback */

    volcache_update_volsync (fce->volume, fce->volsync);
    conv_dir (fce, ce, 0, &cache_handle, tmp, sizeof(tmp));

 out:

    cred_free(ce);
    free_fs_server_context(&context);
    ReleaseWriteLock(&fce->lock); 
    return error;
}

/*
 *
 */

int 
reconnect_rmdir(struct vcache *vcp, FCacheEntry *childEntry, char *name)
{
    FCacheEntry *fce;
    CredCacheEntry *ce;
    int error;               
    VenusFid *fid, tempfid; /* Ba san: to check the deletion of file*/
    Result res;
    char tmp[2 * sizeof(int) + 2];
    int ret = 0; 
    Result tempres; 
    fcache_cache_handle cache_handle;
  
    ConnCacheEntry *conn;
    fs_server_context context;
    AFSFetchStatus status;
    AFSVolSync volsync;

    fid = &(vcp->fid); /* points to the VenusFid structure */
    fid = fid_translate(fid);

    ret = fcache_find(&fce, *fid);
    assert (ret == 0);

    ce = cred_get (fid->Cell, vcp->cred.pag, CRED_ANY);
    assert (ce != NULL);

    AssertExclLocked(&fce->lock);

    conn = find_first_fs (fce, ce, &context);
    if (conn == NULL) {
	arla_log (ADEBDISCONN, "find_first_fs failed", fce->index);
	cred_free(ce);
	ReleaseWriteLock(&fce->lock);
	return ENETDOWN;
    }

    ret = RXAFS_RemoveDir (conn->connection,
			   &fce->fid.fid,
			   name,
			   &status,
			   &volsync);
    if (ret) {
	arla_log (ADEBDISCONN, 
		  "Could not RemoveDir : %s (%d)", 
		  koerr_gettext(res.res),res.res);
	goto out;
    }

/* Ba san: Chcek the deletion of the file */
    ReleaseWriteLock(&fce->lock);
    error = adir_lookup(&fce->fid, name, &tempfid, NULL, &ce);
    ObtainWriteLock(&fce->lock);

    if (error == 0) {
        int result;

        arla_warnx (ADEBDISCONN,
		    "In reconnect_rmdir: file %s needs to be deleted",name);
        result = adir_remove (fce,name);
        assert ( result == 0);
    } /* This is for the file produced during disconnect mode,
	 if error==ENOENT then the file is created during connect mode*/

    fce->status  = status;
    fce->volsync = volsync;

    volcache_update_volsync (fce->volume, fce->volsync);

    tempres = conv_dir(fce, ce, 0, &cache_handle, tmp, sizeof(tmp));

    childEntry->host = 0; /*Ba shiqi: no callback for this entry*/

 out:

    cred_free(ce);
    free_fs_server_context(&context);
    ReleaseWriteLock(&fce->lock);
    return error;
}

/*
 *
 */

static int 
reconnect_mut_chk(FCacheEntry *fce, CredCacheEntry *ce, int version)
{
    ConnCacheEntry *conn;
    fs_server_context context;
    FCacheEntry fetched = *fce;
    int ret;

    AFSFetchStatus status;                                                   
    AFSCallBack callback;                                                    
    AFSVolSync volsync;      

    AssertExclLocked(&fetched.lock);

/*SWW Aug 01: >= is changed into > */
    conn = find_first_fs (&fetched, ce, &context);
    if (conn == NULL) {
	arla_log (ADEBDISCONN, "find_first_fs failed", fce->index);
	return ENETDOWN;
    }
 
    ret = RXAFS_FetchStatus (conn->connection,
                             &fce->fid.fid,
                             &status,
                             &callback,
                             &volsync);
    if (ret) {
        if (ret == -1)
            ret = ENETDOWN;
        free_fs_server_context(&context);
        arla_warn (ADEBFCACHE, ret, "fetch-status");
        return ret;
    }

    if (status.DataVersion > version)
    {
	arla_log(ADEBDISCONN, "reconnect_mut_chk: concurrent writes detected!");
	return 1;
    }
    free_fs_server_context(&context);
    return 0;
}

/*
 *
 */

static void
fcache_backfile_name(char *name, size_t len)
{
    static int no = 1;

    snprintf (name, len, "%04X",no++);
    strlcat (name, "bak", len);
}

/*
 *
 */

static void
copy_cached_file(int from, int to)
{
    char name_from[2 * sizeof(int) + 1], name_to[2 * sizeof(int) + 1];
    int fd_from, n, fd_to;
    char buf[BUFSIZE];

    snprintf (name_from, sizeof(name_from), "%04X", from);
    snprintf (name_to,   sizeof(name_to),   "%04X", to);

    fd_from = open(name_from,O_RDONLY | O_BINARY);  
    fd_to   = open(name_to,  O_WRONLY | O_CREAT | O_BINARY | O_TRUNC, 0600);

    while((n = read(fd_from, buf, BUFSIZE)) > 0)
	write(fd_to, buf, n);

#if 0
    if(fstat(fd_to, &statinfo)<0) {
	arla_warnx(ADEBDISCONN,"ERROR");
    }
#endif   

    close(fd_from);
    close(fd_to);
}

/*
 *
 */

static void
reconnect_update_fid (FCacheEntry *entry, VenusFid oldfid)
{
    if (entry->flags.kernelp)
	update_fid (oldfid, NULL, entry->fid, entry);
}

/*
 *
 */

static int
reconnect_mut_newfile(FCacheEntry **fcep, xfs_pag_t cred,VenusFid *new_fid)
{

    FCacheEntry *parent_fce;
    u_long host;
    char name[2 * sizeof(int) + 3 + 1], tmp[2 * sizeof(int) + 2];
    AFSStoreStatus store_attr;
    AFSFetchStatus fetch_attr;
    CredCacheEntry *ce; 
    AccessEntry *ae;
    VenusFid newfid;
    int ret;
    int from, to;
    fcache_cache_handle cache_handle;

    ret = fcache_find (&parent_fce, (*fcep)->parent);
    assert (ret == 0);

    host = (*fcep)->host;

    ce = cred_get((*fcep)->parent.Cell, cred, CRED_ANY);

    fcache_backfile_name (name, sizeof(name));

    store_attr.Mask = 8;
    store_attr.ClientModTime = 430144;
    store_attr.Owner = 1957724;
    store_attr.Group = 21516;
    store_attr.UnixModeBits = 420;
    store_attr.SegSize = 0;

    create_file(parent_fce, name, &store_attr, &newfid, &fetch_attr, ce);

    (*fcep)->flags.datap = FALSE; /* Ba shiqi: we need to get the old from FS*/
    *new_fid = newfid;
    from = (*fcep)->index;
    ret = fcache_find(fcep, newfid);
    assert (ret == 0);
    to   = (*fcep)->index;
    (*fcep)->host = host;
    (*fcep)->flags.attrp = TRUE;
    (*fcep)->flags.datap = TRUE;
    findaccess(ce->cred, (*fcep)->acccache, &ae); /*Ba shijiu obtain access */
    ae->cred   = ce->cred;
    ae->access = (*fcep)->status.CallerAccess;

    ReleaseWriteLock(&(*fcep)->lock);

    copy_cached_file(from, to);
    ret = adir_creat (parent_fce, name, newfid.fid);
    assert (ret ==0);
    conv_dir (parent_fce, ce, 0, &cache_handle, tmp, sizeof(tmp));
    ReleaseWriteLock(&parent_fce->lock);

    return 0;
}

   
/*
 *
 */

int reconnect_putattr(struct vcache *vcp, struct xfs_attr *xap)
{

    ConnCacheEntry *conn;
    fs_server_context context;
    struct rx_call *call;
    VenusFid *fid;
    CredCacheEntry *ce;
    FCacheEntry *fce, *tempce;
    AFSFetchStatus status;
    Result res;
    u_int32_t sizefs;
    AFSStoreStatus storestatus;
    AFSVolSync volsync;
    int ret;

    fid = &(vcp->fid); /* points to the VenusFid structure */
    fid = fid_translate(fid);

#if 0
    arla_log(ADEBDISCONN, "reconnect: DISCONNECTED write on fid.Cell=0x%x, "
	     "fid.fid.Volume= 0x%x, fid.fid.Vnode=0x%x, fid.fid.Unique=0x%x",
	     fid->Cell, 
	     fid->fid.Volume, 
	     fid->fid.Vnode, 
	     fid->fid.Unique);
#endif

    ce = cred_get (fid->Cell, vcp->cred.pag, CRED_ANY);
    assert (ce != NULL);
    res.res = 0;

#if 0
/* Ba shier: should we send the file back to server?  */
    if (XA_VALID_SIZE(xap)){
	res = cm_ftruncate (*fid, xap->xa_size, ce);
    }  
#endif

    ret = fcache_find(&fce, *fid);
    assert (ret == 0);
    tempce = fce;

    sizefs=fce->status.Length;

#if 0 /* XXX */
    /* some people have written to the file while we are disconnected */
    /* we have to give it a different name on the server  */
    if (reconnect_mut_chk(fce, ce, vcp->DataVersion))
    {
	VenusFid new_fid;

	alloc_fid_trans(fid);
	reconnect_mut_newfile(&fce,vcp->cred.pag,&new_fid);  
	fce->status.Length = sizefs;
	fce->length = sizefs;
	ReleaseWriteLock(&tempce->lock);
	fill_fid_trans(&new_fid);
	tempce->flags.attrp = FALSE;
	tempce->flags.kernelp = FALSE;
    }   
#endif

    /* code from truncate file XXX join */
    conn = find_first_fs (fce, ce, &context);
    if (conn == NULL) {
	arla_log (ADEBDISCONN, "find_first_fs failed.");
	ReleaseWriteLock(&fce->lock);
	cred_free(ce);
	return ENETDOWN;
    }

    if (fce->status.FileType != TYPE_DIR) {

	call = rx_NewCall (conn->connection);
	if (call == NULL) {
	    arla_log (ADEBDISCONN, "Cannot call");
	    res.res = ENOMEM;
	    goto out;
	}

	storestatus.Mask = 0;
	res.res = StartRXAFS_StoreData (call,
					&(fce->fid.fid),
					&storestatus,
					0, 0, fce->status.Length);
	if(res.res) {
	    arla_log (ADEBDISCONN, "Could not start store, %s (%d)",
		      koerr_gettext(res.res), res.res);
	    rx_EndCall(call, 0);
	    goto out;
	}

	sizefs = htonl (sizefs);
	if (rx_Write (call, &sizefs, sizeof(sizefs)) != sizeof(sizefs)) {
	    res.res = conv_to_arla_errno(rx_Error(call));
	    arla_log (ADEBDISCONN, "Error writing length: %d", res.res);
	    rx_EndCall(call, 0);
	    goto out;
	}

	if (rx_Write (call, 0, 0) != 0) {
	    res.res = conv_to_arla_errno(rx_Error(call));
	    arla_log (ADEBDISCONN, "Error writing: %d", res.res);
	    rx_EndCall(call, 0);
	    goto out;
	}

	res.res = rx_EndCall (call, EndRXAFS_StoreData (call,
							&status,
							&volsync));
	if (res.res) {
	    arla_log (ADEBDISCONN, "Error rx_EndCall: %s (%d)",
		      koerr_gettext(res.res), res.res);
	    goto out;
	}

	fce->status   = status;
	fce->volsync  = volsync;

	volcache_update_volsync (fce->volume, fce->volsync);

    }
    /* code from write_attr XXX join */
    xfs_attr2afsstorestatus(xap, &storestatus);

    res.res = RXAFS_StoreStatus (conn->connection,
				 &fce->fid.fid,
				 &storestatus,
				 &status,
				 &volsync);
    if (res.res) {
        arla_log (ADEBDISCONN, "Could not make store-status call, %s (%d)",
		  koerr_gettext(res.res), res.res);
        goto out;
    }
    arla_log(ADEBDISCONN, 
	     "write_attr: status.Length = %d", status.Length);
    fce->status  = status;
    fce->volsync = volsync;

    volcache_update_volsync (fce->volume, fce->volsync);

 out:

    free_fs_server_context(&context);
    ReleaseWriteLock(&fce->lock);
    cred_free(ce);
    return res.res;
}

/*
 *
 */

static int 
reconnect_putdata(struct vcache *vcp)
{
    VenusFid *fid;
    FCacheEntry *fce;
    CredCacheEntry *ce;
    Result res;

    u_int32_t sizefs;
    int fd = -1;
    struct rx_call *call;
    ConnCacheEntry *conn;
    fs_server_context context;
    struct stat statinfo;
    AFSStoreStatus storestatus;
    AFSFetchStatus status;
    AFSVolSync volsync;
    int ret;

    fid = &(vcp->fid); /* points to the VenusFid structure */
    arla_log(ADEBDISCONN, "reconnect: putdata before fid_translate, "
	     "fid->Cell=0x%x, fid->fid.Volume=0x%x, fid->fid.Vnode=0x%x, "
	     "fid->fid.Unique=0x%x", 
	     fid->Cell, 
	     fid->fid.Volume, 
	     fid->fid.Vnode, 
	     fid->fid.Unique);

    fid = fid_translate(fid);

    arla_log(ADEBDISCONN, "reconnect: putdata after fid_translate, "
	     "fid->Cell=0x%x, fid->fid.Volume=0x%x, fid->fid.Vnode=0x%x, "
	     "fid->fid.Unique=0x%x", 
	     fid->Cell, 
	     fid->fid.Volume, 
	     fid->fid.Vnode, 
	     fid->fid.Unique);


    ce = cred_get (fid->Cell, vcp->cred.pag, CRED_ANY);
    assert (ce != NULL);

    ret = fcache_find (&fce, *fid);
    assert (ret == 0);

#if 0
    isupdate = reconnect_mut_chk(fce, ce, vcp->DataVersion);
    if (isupdate)
    {
	arla_log(ADEBDISCONN, 
		 "reconnect_putdata: send data back because "
		 "the file was modified!");
	cred_free(ce);
	ReleaseWriteLock(&fce->lock);
	reconnect_mut_newfile(&fce, vcp->cred.pag);  
	return -1;
    }

    if (reconnect_mut_chk (fce, ce)) {
	arla_log (ADEBDISCONN, "Reconnect_putdata: can not send the file"
		  "to FS becausethis file has been modified!");
	ReleaseWriteLock(&fce->lock);
	return -1;
    } 
#endif

    /* code taken from write_data XXX join */ 
    AssertExclLocked(&fce->lock);

    conn = find_first_fs (fce, ce, &context);
    if (conn == NULL) {
	arla_log (ADEBDISCONN, "find_first_fs failed");
	ReleaseWriteLock(&fce->lock); 
	cred_free(ce);
	return ENETDOWN;
    }

    fd = fcache_open_file (fce, O_RDONLY);
    if (fd < 0) {
	arla_log (ADEBDISCONN, "open %u failed", fce->index);
	res.res = errno;
	goto out;
    }

    if (fstat (fd, &statinfo) < 0) {
	arla_log (ADEBDISCONN, "Cannot stat file %u", fce->index);
	res.res = errno;
	goto out;
    }

    sizefs = statinfo.st_size;

    call = rx_NewCall (conn->connection);
    if (call == NULL) {
	arla_log (ADEBDISCONN, "Cannot call");
	res.res = ENOMEM;
	goto out;
    }

    storestatus.Mask = 0; /* Dont save anything */
    res.res = StartRXAFS_StoreData (call, &fce->fid.fid,
				    &storestatus,
				    0,
				    sizefs,
				    sizefs);
    if (res.res) {
	arla_log (ADEBDISCONN, "Could not start store, %s (%d)",
		  koerr_gettext(res.res), res.res);
	rx_EndCall(call, 0);
	goto out;
    }

    res.res = copyfd2rx (fd, call, 0, sizefs);
    if (res.res) {
	rx_EndCall(call, res.res);
	arla_log (ADEBDISCONN, "copyfd2rx failed: %d", res.res);
	goto out;
    }
     
    res.res = rx_EndCall (call, EndRXAFS_StoreData (call,
						    &status,
						    &volsync));
    if (res.res) {
	arla_log (ADEBDISCONN, "Error rx_EndCall: %s (%d)", 
		  koerr_gettext(res.res), res.res);
	goto out;
    }
    if (status.DataVersion > fce->status.DataVersion)
	arla_log(ADEBDISCONN, 
		 "reconnect: putdata, server incremented DataVersion!");

    fce->status   = status;
    fce->volsync  = volsync;

    volcache_update_volsync (fce->volume, fce->volsync);

 out:

    ReleaseWriteLock(&fce->lock); 
    if (fd != -1)
	close (fd);
    free_fs_server_context (&context);
  
    cred_free(ce);
    return res.res;
}

/*
 *
 */

int reconnect_rename(struct vcache *vcp_old, struct vcache *vcp_new, 
		     char *name_old, char *name_new)
{

    FCacheEntry *fce_old, *fce_new;
    CredCacheEntry *ce;
    VenusFid *fid_old, *fid_new,foo_fid,*tempnew_fid;
    int error;

    int ret = 0;
    Result res;
    char tmp[2 * sizeof(int) + 2];
    int isnewpar = 0;
    ConnCacheEntry *conn;
    fs_server_context context;
    AFSFetchStatus orig_status, new_status;
    AFSVolSync volsync;
    fcache_cache_handle cache_handle;

    fid_old = &vcp_old->fid;
    fid_old = fid_translate(fid_old);
 
    ret = fcache_find (&fce_old, *fid_old);
    assert (ret == 0);

    /* ReleaseWriteLock(&fce_old->lock);  SWW Qiyue 28 Maybe we dont need it*/
    assert(fce_old);
    arla_log(ADEBDISCONN, "reconnect: old rename on Cell=0x%x, "
	     "fid.Volume= 0x%x, fid.Vnode=0x%x, fid.Unique=0x%x", 
	     fce_old->fid.Cell,
	     fce_old->fid.fid.Volume,
	     fce_old->fid.fid.Vnode, 
	     fce_old->fid.fid.Unique);

    fid_new = tempnew_fid = &vcp_new->fid;
    fid_new = fid_translate(fid_new);
    
    if (tempnew_fid->fid.Volume != fid_new->fid.Volume ||
	tempnew_fid->fid.Vnode != fid_new->fid.Vnode ||
	tempnew_fid->fid.Unique != fid_new->fid.Unique)
        isnewpar = 1; 

/*Ba ba: the parent dir was created during disconnected */

    if (fid_old->fid.Volume == fid_new->fid.Volume &&
	fid_old->fid.Vnode == fid_new->fid.Vnode   &&
	fid_old->fid.Unique == fid_new->fid.Unique )
        ReleaseWriteLock(&fce_old->lock); /* old and new are the same*/

    ret = fcache_find (&fce_new, *fid_new);
    assert (ret == 0);

    arla_log(ADEBDISCONN, "reconnect: new rename on Cell=0x%x, "
	     "fid.Volume= 0x%x, fid.Vnode=0x%x, fid.Unique=0x%x", 
	     fce_new->fid.Cell, 
	     fce_new->fid.fid.Volume, 
	     fce_new->fid.fid.Vnode, 
	     fce_new->fid.fid.Unique);



    arla_log(ADEBDISCONN, 
	     "reconnect_rename: fce_old = 0x%x, fce_new = 0x%x",
	     fce_old, fce_new);

    ce = cred_get (vcp_old->fid.Cell, vcp_old->cred.pag, CRED_ANY);
    assert (ce != NULL);

    AssertExclLocked(&fce_old->lock);
    AssertExclLocked(&fce_new->lock);

    conn = find_first_fs (fce_old, ce, &context);
    if (conn == NULL) {
	arla_log (ADEBDISCONN, "find_first_fs failed");
	ReleaseWriteLock(&fce_new->lock);
	
	if (fid_old->fid.Volume != fid_new->fid.Volume ||
	    fid_old->fid.Vnode != fid_new->fid.Vnode   ||
	    fid_old->fid.Unique != fid_new->fid.Unique )
	    ReleaseWriteLock(&fce_old->lock); /* old and new are the same*/
	
	cred_free(ce);
	return ENETDOWN;
    }

    error = RXAFS_Rename (conn->connection,
			  &fce_old->fid.fid,
			  name_old,
			  &fce_new->fid.fid,
			  name_new,
			  &orig_status,
			  &new_status,
			  &volsync);

    if (error) {
	arla_log (ADEBDISCONN, "Could not Rename: %s (%d)", koerr_gettext(error), error); 
	goto out; }

    fce_old->status = orig_status;
    fce_new->status = new_status;

    fce_old->volsync = fce_new->volsync = volsync;

    volcache_update_volsync (fce_old->volume, fce_old->volsync);


/*SWW Aug 01 */
    arla_warnx (ADEBDISCONN,
		"reconnect_rename: we delete the old one %s volumn=0x%x, "
		"vnode=0x%x,unique=0x%x",
		name_old,fce_old->fid.fid.Volume,
		fce_old->fid.fid.Vnode,
		fce_old->fid.fid.Unique);                      

/*Ba Yi: get the VenuseFid for new file */
  #if 0
    if (fid_old->fid.Volume == fid_new->fid.Volume &&
	fid_old->fid.Vnode == fid_new->fid.Vnode   &&
	fid_old->fid.Unique == fid_new->fid.Unique ) ;
#endif
    ReleaseWriteLock(&fce_old->lock); /* old and new are the same*/
    
    error = adir_lookup (&fce_old->fid, name_old, &foo_fid, NULL, &ce);
    
#if 0
    if (fid_old->fid.Volume == fid_new->fid.Volume &&
       fid_old->fid.Vnode == fid_new->fid.Vnode   &&
       fid_old->fid.Unique == fid_new->fid.Unique );
#endif
    ObtainWriteLock (&fce_old->lock);

/*Ba San: delete the old which was created during dis */
    if (error == 0) {
	arla_warnx (ADEBDISCONN,"reconnect_rename: we delete the old one %s "
		    "volumn=0x%x,vnode=0x%x,unique=0x%x",
		    name_old,
		    foo_fid.fid.Volume,
		    foo_fid.fid.Vnode,
		    foo_fid.fid.Unique);

	adir_remove(fce_old,name_old);
	adir_remove(fce_new,name_new);

	res = conv_dir (fce_old, ce, 0, &cache_handle, tmp, sizeof(tmp));

    } else {
	/* if found delete it */
/*Ba San: try to find the previous VenuseFid for old name */
	if (error == ENOENT) {
#if 0
	    if (fid_old->fid.Volume == fid_new->fid.Volume &&
		fid_old->fid.Vnode == fid_new->fid.Vnode   &&
		fid_old->fid.Unique == fid_new->fid.Unique );
#endif
	    ReleaseWriteLock(&fce_new->lock);
	    
	    error = adir_lookup (&fce_new->fid, name_new, &foo_fid, NULL, &ce);
	    
#if 0
	    if (fid_old->fid.Volume == fid_new->fid.Volume &&
               fid_old->fid.Vnode == fid_new->fid.Vnode   &&
               fid_old->fid.Unique == fid_new->fid.Unique );
#endif
	    ObtainWriteLock (&fce_new->lock);
	    if (error == 0) /*Ba Si: We need delete the faked new */
		adir_remove(fce_new,name_new);
	    else if (error == ENOENT) {
                int venusret;
		
                venusret = find_venus (name_new,&foo_fid);
                assert (venusret==0);
                arla_warnx (ADEBDISCONN,"I MUST WRITE A PROGRAM HERE");
                if (isnewpar == 1) {

		    arla_warnx(ADEBDISCONN,"In reconnect_rename: "
			       "new Volume=0x%x,Vnode=0x%x,Unique=0x%x",
			       fce_new->fid.fid.Volume,
			       fce_new->fid.fid.Vnode,
			       fce_new->fid.fid.Unique);
#if 0
		    error = adir_creat(fce_new, name_new, foo_fid.fid);
#endif
		}
	    }
	}
    }

    arla_warnx (ADEBDISCONN,"reconnect_rename: we add the new one %s "
		"volumn=0x%x,vnode=0x%x,unique=0x%x",
		name_new,
		foo_fid.fid.Volume,
		foo_fid.fid.Vnode,
		foo_fid.fid.Unique);
    error = adir_creat (fce_new, name_new, foo_fid.fid);
    res = conv_dir (fce_new, ce, 0, &cache_handle, tmp, sizeof(tmp));

/* Aug 1 */

 out:

    free_fs_server_context (&context);

    ReleaseWriteLock(&fce_new->lock);

    if (fid_old->fid.Volume != fid_new->fid.Volume ||
	fid_old->fid.Vnode != fid_new->fid.Vnode   ||
	fid_old->fid.Unique != fid_new->fid.Unique )
        ReleaseWriteLock(&fce_old->lock); /* old and new are the same*/

    cred_free(ce);
    return error;
}

/*
 *
 */

int reconnect_create(struct vcache *parent, struct vcache *child, char *name)
{

    ConnCacheEntry *conn;
    fs_server_context context;
    VenusFid *parent_fid;
    VenusFid *child_fid;
    VenusFid fakeFid; 

    CredCacheEntry *ce;
    FCacheEntry *parentEntry;
    FCacheEntry *childEntry;

    AFSFetchStatus fetch_attr;
    AFSStoreStatus store_attr; 

    AFSFetchStatus status;
    AFSCallBack callback;
    AFSVolSync volsync;
    int ret; 
    char tmp[2 * sizeof(int) + 2];
    fcache_cache_handle cache_handle;
    int32_t type;

    parent_fid = &(parent->fid); /* points to the VenusFid structure */
    child_fid = &(child->fid);
    fakeFid = *child_fid;

    /*Ba Liu: the parent dir may be created during dison mode*/
    parent_fid = fid_translate(parent_fid);

    ce = cred_get (parent->fid.Cell, parent->cred.pag, CRED_ANY);
    assert (ce != NULL);

    ret = fcache_find (&parentEntry, *parent_fid);
    assert (ret == 0);

#if 0
    is_change = reconnect_mut_chk(parentEntry, 
				  ce, 
				  parentEntry->status.DataVersion);
#endif

/*SWW Qiyue 30 delete the old file entry in dir  */
    arla_warnx (ADEBDISCONN,
		"reconnect_rename: we delete the old one volumn=0x%x, "
		"vnode=0x%x,unique=0x%x",
		parentEntry->fid.fid.Volume,
		parentEntry->fid.fid.Vnode,
		parentEntry->fid.fid.Unique);

    adir_remove(parentEntry,name);  

    conn = find_first_fs (parentEntry, ce, &context);
    if (conn == NULL) {
	arla_log (ADEBDISCONN, "find_first_fs failed");
	ReleaseWriteLock(&parentEntry->lock);
	ReleaseWriteLock(&childEntry->lock);
	free_fs_server_context(&context);
	cred_free(ce);
	return ENETDOWN;
    }

    ret = fcache_find (&childEntry, *child_fid);
    assert (ret == 0);

    recon_hashtabdel(childEntry);

#if 0
    fetch_attr = &childEntry->status;
#endif

    store_attr.Mask 	   =    8;
    store_attr.ClientModTime =    childEntry->status.ClientModTime;
    store_attr.Owner = 	 	childEntry->status.Owner;
    store_attr.Group = 		childEntry->status.Group;
    store_attr.UnixModeBits = 	childEntry->status.UnixModeBits;
    store_attr.SegSize = 		childEntry->status.SegSize;

    arla_log(ADEBDISCONN, 
	     "reconnect: create before RXAFS_CreateFile, "
	     "Cell=0x%x, fid.Volume= 0x%x, fid.Vnode=0x%x, fid.Unique=0x%x", 
	     childEntry->fid.Cell, 
	     childEntry->fid.fid.Volume, 
	     childEntry->fid.fid.Vnode, 
	     childEntry->fid.fid.Unique);

    alloc_fid_trans(&childEntry->fid);
  

    ret = RXAFS_CreateFile (conn->connection,
                            &(parentEntry->fid.fid),
                            name, &store_attr,
                            &(childEntry->fid.fid), &fetch_attr,
                            &status,
                            &callback,
                            &volsync);
 
    if (ret) {
	if (ret == 17) {
	    ReleaseWriteLock(&parentEntry->lock);
	    reconnect_mut_newfile(&childEntry, 
				  parent->cred.pag, 
				  &childEntry->fid);
	    ObtainWriteLock(&parentEntry->lock);
	    fill_fid_trans(&childEntry->fid);
	    recon_hashtabadd(childEntry);
	    childEntry->host = rx_HostOf (rx_PeerOf (conn->connection));
	    reconnect_update_fid (childEntry, fakeFid);
	} else {
	    arla_log (ADEBDISCONN, "Could not CreateFile: %s (%d)",
		      koerr_gettext(ret), ret);
	}
	goto out;
    }
   
    parentEntry->status   = status;   
    parentEntry->callback = callback;
    parentEntry->volsync  = volsync;

    childEntry->fid.Cell = parentEntry->fid.Cell;

    arla_log(ADEBDISCONN, "reconnect: create after RXAFS_CreateFile, "
	     "Cell=0x%x, fid.Volume= 0x%x, fid .Vnode=0x%x, fid.Unique=0x%x", 
	     childEntry->fid.Cell,
	     childEntry->fid.fid.Volume, 
	     childEntry->fid.fid.Vnode, 
	     childEntry->fid.fid.Unique); 

    fill_fid_trans(&childEntry->fid);

#if 0
    ReleaseWriteLock(&childEntry->lock);
#endif


    ret = volcache_getbyid (childEntry->fid.fid.Volume,
			    childEntry->fid.Cell,
			    ce,
			    &childEntry->volume,
			    &type);

    recon_hashtabadd(childEntry); 

    arla_log(ADEBDISCONN, 
	     "reconnect: create after volcache_getbyid, Cell=0x%x, "
	     "fid.Volume= 0x%x, fid .Vnode=0x%x, fid.Unique=0x%x",
	     childEntry->fid.Cell, 
	     childEntry->fid.fid.Volume, 
	     childEntry->fid.fid.Vnode, 
	     childEntry->fid.fid.Unique); 

/* SWW Qiyue 30: add the new file entry in dir */
    arla_warnx (ADEBDISCONN,"reconnect_rename: we add the new one "
		"volumn=0x%x,vnode=0x%x,unique=0x%x",
		parentEntry->fid.fid.Volume,
		parentEntry->fid.fid.Vnode,
		parentEntry->fid.fid.Unique);

    adir_creat (parentEntry, name, childEntry->fid.fid);  

    childEntry->status = fetch_attr;
  
    childEntry->flags.attrp = TRUE;
    childEntry->flags.kernelp = TRUE;

    childEntry->flags.datap = TRUE;
    childEntry->tokens |= XFS_ATTR_R | XFS_DATA_R | XFS_DATA_W;

    if (parentEntry->volume == NULL)
	ret = volcache_getbyid (parentEntry->fid.fid.Volume,
				parentEntry->fid.Cell,
				ce,
				&parentEntry->volume,
				&type);

    volcache_update_volsync (parentEntry->volume, parentEntry->volsync);



/*SWW Qiyue 28: Set the host for child entry */

    childEntry->host = rx_HostOf (rx_PeerOf (conn->connection));
    assert(childEntry->host);

/*SWW Qiyue 29:  */
    arla_warnx (ADEBDISCONN,
		"Replace fid.Volume=0x%x,Vnode=0x%x,Unique=0x%x with "
		"Volume=0x%x,Vnode=0x%x,Unqiue=0x%x",
		fakeFid.fid.Volume,
		fakeFid.fid.Vnode,
		fakeFid.fid.Unique,
		childEntry->fid.fid.Volume,
		childEntry->fid.fid.Vnode,
		childEntry->fid.fid.Unique);

    reconnect_update_fid (childEntry, fakeFid);

    conv_dir(parentEntry, ce, 0, &cache_handle, tmp, sizeof(tmp));

    ReleaseWriteLock(&childEntry->lock);

 out:

    ReleaseWriteLock(&parentEntry->lock);
    ReleaseWriteLock(&childEntry->lock);
    free_fs_server_context(&context);
    cred_free(ce);
    return ret;
}

/*
 *
 */

int reconnect_mkdir(struct vcache *parent, struct vcache *curdir, 
                    AFSStoreStatus *store_status, char *name)
{
    ConnCacheEntry *conn; 
    fs_server_context context;
    CredCacheEntry *ce;
    VenusFid *parent_fid;
    VenusFid *child_fid;
    VenusFid fakeFid;

    FCacheEntry *parentEntry, *childEntry, *tempEntry, *tempparEntry;
    Result tempres;
    int    ret = 0;
    int    tempret = 0;
    struct timeval tv;
    char tmp[2 * sizeof(int) + 2];

    AFSFid  Outfid;   /* Ba Wu: These are used to get the info from FS*/
    AFSFetchStatus fetch_attr;
    AFSFetchStatus status;
    AFSCallBack  callback;
    AFSVolSync   volsync;
    fcache_cache_handle cache_handle;
    int32_t type;

    parent_fid = &(parent->fid); /* points to the VenusFid structure */
    child_fid = &(curdir->fid);
    fakeFid = *child_fid;

    parent_fid = fid_translate(parent_fid);

    ce = cred_get (parent->fid.Cell, parent->cred.pag, CRED_ANY);
    assert (ce != NULL);

    ret = fcache_find (&parentEntry, *parent_fid);
    assert (ret == 0);

    tempparEntry = parentEntry;

/*Ba ba: used to check whether name can be find  Deleted !!!
  ReleaseWriteLock(&parentEntry->lock);
  tempret = adir_lookup (parentEntry->fid , name , &foo_fid , NULL, ce);  */
/*Ba ba: used to check whether name can be find  Deleted !!! */

    /*Ba Wu Remove the dir name from itsparent dir */
    tempret = adir_remove(parentEntry,name);  
    conn = find_first_fs (parentEntry, ce, &context);
    if (conn == NULL) {
	arla_log (ADEBDISCONN,"Cannot make this connection");
	ReleaseWriteLock(&parentEntry->lock);
	ReleaseWriteLock(&childEntry->lock);
	cred_free(ce);
	return ENETDOWN;
    }

    ret = fcache_find(&childEntry, *child_fid);/*Ba Wu: remove the newly created dir */
    assert (ret == 0);

    recon_hashtabdel(childEntry);

    alloc_fid_trans(&childEntry->fid);

    gettimeofday(&tv, NULL);

    ret = RXAFS_MakeDir (conn->connection,
			 &parentEntry->fid.fid,
			 name,
			 store_status, 
			 &Outfid,
			 &fetch_attr,
			 &status,
			 &callback,
			 &volsync);

    if (ret) {
	arla_log (ADEBDISCONN, "Could not CreateFile: %s (%d)",
		  koerr_gettext(ret), ret);
	goto out;
    }

    parentEntry->status   = status;
    parentEntry->callback = callback;
    parentEntry->callback.ExpirationTime += tv.tv_sec;
    parentEntry->volsync  = volsync;

    childEntry->fid.Cell = parentEntry->fid.Cell;
    childEntry->fid.fid = Outfid;
    childEntry->status = fetch_attr;
    childEntry->flags.attrp = TRUE;
    childEntry->flags.kernelp = TRUE;
    childEntry->flags.datap = TRUE;
    childEntry->tokens |= XFS_ATTR_R | XFS_DATA_R | XFS_DATA_W;

    fill_fid_trans(&childEntry->fid);

    ret = volcache_getbyid (childEntry->fid.fid.Volume,
			    childEntry->fid.Cell,
			    ce,
			    &childEntry->volume,
			    &type);

    recon_hashtabadd(childEntry);

/*Ba ba: Need to change later!!! */
#if 0
    ReleaseWriteLock(&tempparEntry->lock);
    tempret = adir_changefid (tempparEntry->fid ,name, &Outfid,  ce);
    ReleaseWriteLock(&tempparEntry->lock);
    tempret = adir_lookup (tempparEntry->fid ,name, &foo_fid, NULL, ce);
#endif

    tempret = adir_creat (parentEntry, name, childEntry->fid.fid); 

    childEntry->host = rx_HostOf (rx_PeerOf (conn->connection));
    assert(childEntry->host);

    reconnect_update_fid(childEntry, fakeFid);
     
    tempres = conv_dir(parentEntry, ce, 0, &cache_handle,
		       tmp, sizeof(tmp));

    ReleaseWriteLock(&childEntry->lock);

    /*SWW Qiyue 29: This should be deleted later */                      
    ret = fcache_find (&tempEntry, childEntry->fid);  

    assert (ret == 0);
    ReleaseWriteLock(&tempEntry->lock);

 out:

    ReleaseWriteLock(&parentEntry->lock);
    ReleaseWriteLock(&childEntry->lock);
    free_fs_server_context(&context);
    cred_free(ce);
    return ret;
}

/*
 *
 */

int reconnect_link(struct vcache *parent, struct vcache *existing,
		   char *name)
{
    ConnCacheEntry *conn;
    fs_server_context context;
    CredCacheEntry *ce;
    VenusFid *parent_fid;  
    VenusFid *existing_fid;
    char tmp[2 * sizeof(int) + 2];
    int ret = 0;
    FCacheEntry *dir_entry,*existing_entry;
    Result res;

    AFSFetchStatus new_status;
    AFSFetchStatus status;
    AFSVolSync volsync;
    fcache_cache_handle cache_handle;


    parent_fid = &(parent->fid);
    existing_fid = &(existing->fid);

    parent_fid = fid_translate(parent_fid);

    ce = cred_get (parent->fid.Cell, parent->cred.pag, CRED_ANY);
    assert (ce != NULL);

    ret = fcache_find (&dir_entry, *parent_fid);
    assert (ret == 0);

    ret = fcache_find (&existing_entry, *existing_fid);
    assert (ret == 0);

    conn = find_first_fs (dir_entry, ce, &context);
    if (conn == NULL) {
	arla_log (ADEBDISCONN,"Cannot make this connection");
	ReleaseWriteLock(&dir_entry->lock);
	ReleaseWriteLock(&existing_entry->lock);
	cred_free(ce);
	return ENETDOWN;
    }

    ret = RXAFS_Link (conn->connection,
		      &dir_entry->fid.fid,
		      name,
		      &existing_entry->fid.fid,
		      &new_status,
		      &status,
		      &volsync);
    if (ret) {
	arla_warn (ADEBFCACHE, ret, "Link");
	goto out;
    }

    dir_entry->status  = status;
    dir_entry->volsync = volsync;

    existing_entry->status = new_status;
    
    volcache_update_volsync (dir_entry->volume, dir_entry->volsync);

    res = conv_dir (dir_entry, ce, 0, &cache_handle, tmp, sizeof(tmp));
	
 out:
    ReleaseWriteLock(&dir_entry->lock);
    ReleaseWriteLock(&existing_entry->lock);
    cred_free(ce);
    free_fs_server_context (&context);
    return ret;
}

/*
 *
 */

int reconnect_symlink(struct vcache *parent, struct vcache *child,
		      AFSStoreStatus *store_attr, char *name, 
		      char *contents)
{
    ConnCacheEntry *conn;
    fs_server_context context;
    CredCacheEntry *ce;
    VenusFid *parent_fid, *child_fid, fakeFid;
    char tmp[2 * sizeof(int) + 2];
    int ret = 0;
    FCacheEntry *dir_entry, *childEntry;
    Result res;

    AFSFetchStatus fetch_attr, new_status;
    AFSVolSync volsync;
    fcache_cache_handle cache_handle;
    int32_t type;

    parent_fid = &(parent->fid);
    child_fid  = &(child->fid);
    fakeFid    = *child_fid;
    parent_fid = fid_translate(parent_fid);

    ce = cred_get (parent->fid.Cell, parent->cred.pag, CRED_ANY);
    assert (ce != NULL);

    ret = fcache_find (&dir_entry, *parent_fid);
    assert (ret == 0);

    adir_remove(dir_entry,name);

    ret = fcache_find (&childEntry, *child_fid);
    assert (ret == 0);

    recon_hashtabdel(childEntry);

    assert(ret==0);
    conn = find_first_fs (dir_entry, ce, &context);
    if (conn == NULL) {
	arla_log (ADEBDISCONN,"Cannot make this connection");
	ReleaseWriteLock(&dir_entry->lock);
	ReleaseWriteLock(&childEntry->lock);
	cred_free(ce);
	return ENOMEM;
    }
  
    alloc_fid_trans(&childEntry->fid);

    ret = RXAFS_Symlink (conn->connection,
			 &dir_entry->fid.fid,
			 name,
			 contents,
			 store_attr,
			 &(childEntry->fid.fid),
			 &fetch_attr,
			 &new_status,
			 &volsync);
    if (ret) {
	arla_warn (ADEBFCACHE, ret, "Symlink");
	goto out;
    }

    child_fid->Cell = dir_entry->fid.Cell;

    fill_fid_trans (&childEntry->fid);
    ret = volcache_getbyid (childEntry->fid.fid.Volume,
			    childEntry->fid.Cell,
			    ce,
			    &childEntry->volume,
			    &type);

    recon_hashtabadd (childEntry);

    adir_creat(dir_entry, name, childEntry->fid.fid);

    childEntry->status = fetch_attr;
    childEntry->flags.attrp = TRUE;
    childEntry->flags.kernelp = TRUE;
    childEntry->tokens |= XFS_ATTR_R;
    volcache_update_volsync (dir_entry->volume, dir_entry->volsync);

    childEntry->host = rx_HostOf (rx_PeerOf (conn->connection));
    assert(childEntry->host);

    reconnect_update_fid(childEntry, fakeFid);
    res = conv_dir (dir_entry, ce, 0, &cache_handle, tmp, sizeof(tmp));

 out: 
    ReleaseWriteLock(&dir_entry->lock);
    ReleaseWriteLock(&childEntry->lock);
    free_fs_server_context(&context);
    cred_free(ce);
    return ret;
}

#endif
@


1.4
log
@Use open() with proper 3rd arg. From arla cvs. miod@@ ok.
@
text
@d492 1
a492 1
        strcpy(fid_KP_head->name, name);
d502 1
a502 2
        strcpy(temp->name, name);
	temp->name[strlen(name)] = '\0';
d1046 1
a1046 2
    strcat (name, "bak");
    name[strlen(name)+1] = '\0';
@


1.3
log
@merge
@
text
@d1066 1
a1066 1
    fd_to   = open(name_to,  O_WRONLY | O_CREAT | O_BINARY);
@


1.2
log
@New Arla userland from Arla between 0.34.2 and current in arla cvs.
Too many new features and fixes to mention here.
@
text
@d34 2
d38 1
a38 1
RCSID("$Id: reconnect.c,v 1.28 2000/06/10 16:46:04 assar Exp $");
d802 1
a802 1
    xfs_cache_handle cache_handle;
d827 1
a827 1
	    xfs_cache_handle cache_handle;
d843 1
a843 1
    assert (CheckLock(&fce->lock) == -1);
d920 1
a920 1
    xfs_cache_handle cache_handle;
d936 1
a936 1
    assert (CheckLock(&fce->lock) == -1);
d1006 1
a1006 1
    assert (CheckLock (&fetched.lock) == -1);
d1110 1
a1110 1
    xfs_cache_handle cache_handle;
d1381 1
a1381 1
    assert (CheckLock(&fce->lock) == -1);
d1482 1
a1482 1
    xfs_cache_handle cache_handle;
d1533 2
a1534 2
    assert (CheckLock(&fce_old->lock) == -1
            && CheckLock(&fce_new->lock) == -1);
d1703 1
a1703 1
    xfs_cache_handle cache_handle;
d1919 1
a1919 1
    xfs_cache_handle cache_handle;
d2055 1
a2055 1
    xfs_cache_handle cache_handle;
d2129 1
a2129 1
    xfs_cache_handle cache_handle;
d2209 1
@


1.1
log
@upgrade Arla to fresher code. Too many new features and bugfixes.
@
text
@a0 1
/*	$OpenBSD$	*/
d36 1
a36 1
RCSID("$KTH: reconnect.c,v 1.11 1999/02/15 04:49:43 art Exp $");
d123 1
a123 1
    fd = open(log_file, O_RDONLY | O_BINARY);
d324 3
d542 1
a542 1
static VenusFid *
d799 1
a799 1
    char tmp[5];
d844 6
d854 1
a854 1
   error = adir_lookup(fce->fid, name, &tempfid, ce);
d873 1
a873 1
    error = adir_lookup(fce->fid, name, &tempfid, ce);
d915 1
a915 1
    char tmp[5];
d937 6
d958 1
a958 1
    error = adir_lookup(fce->fid, name, &tempfid, ce);
d1008 4
d1039 2
a1040 1
void fcache_backfile_name(char *name, size_t len)
d1053 1
a1053 1
void
d1056 1
a1056 1
    char tmpname[5],name_from[21],name_to[27];
d1060 3
a1062 6
    strcpy(name_from,ARLACACHEDIR);
    strcpy(name_to,ARLACACHEDIR);
    sprintf(tmpname,"%04X",from);
    strcat(name_from, tmpname);
    sprintf(tmpname,"%04X",to);
    strcat(name_to, tmpname);
d1083 13
a1095 2
int
reconnect_mut_newfile(FCacheEntry **fcep, pag_t cred,VenusFid *new_fid)
d1100 1
a1100 1
    char name[9],tmp[5];
a1169 1
    AFSCallBack callback;
d1202 1
d1212 1
a1217 6

#if 0
    usedbytes -= entry->status.Length;
    usedbytes += size;
    
    fce->status.Length = size;  
d1222 8
d1231 6
a1236 6
    call = rx_NewCall (conn->connection);
    if (call == NULL) {
	arla_log (ADEBDISCONN, "Cannot call");
	res.res = ENOMEM;
	goto out;
    }
d1238 11
a1248 11
    storestatus.Mask = 0;
    res.res = StartRXAFS_StoreData (call,
				    &(fce->fid.fid),
				    &storestatus,
				    0, 0, fce->status.Length);
    if(res.res) {
	arla_log (ADEBDISCONN, "Could not start store, %s (%d)",
                  koerr_gettext(res.res), res.res);
	rx_EndCall(call, 0);
	goto out;
    }
d1250 7
a1256 7
    sizefs = htonl (sizefs);
    if (rx_Write (call, &sizefs, sizeof(sizefs)) != sizeof(sizefs)) {
	res.res = rx_Error(call);
	arla_log (ADEBDISCONN, "Error writing length: %d", res.res);
	rx_EndCall(call, 0);
	goto out;
    }
d1258 6
a1263 6
    if (rx_Write (call, 0, 0) != 0) {
	res.res = rx_Error(call);
	arla_log (ADEBDISCONN, "Error writing: %d", res.res);
	rx_EndCall(call, 0);
	goto out;
    }
d1265 8
a1272 9
    res.res = rx_EndCall (call, EndRXAFS_StoreData (call,
						    &status,
						    &callback,
						    &volsync));
    if (res.res) {
	arla_log (ADEBDISCONN, "Error rx_EndCall: %s (%d)",
		  koerr_gettext(res.res), res.res);
	goto out;
    }
d1274 2
a1275 3
    fce->status   = status;
    fce->callback = callback;
    fce->volsync  = volsync;
d1277 1
a1277 1
    volcache_update_volsync (fce->volume, fce->volsync);
d1279 1
a1327 1
    AFSCallBack callback;
d1382 6
d1424 1
a1424 1
    res.res = copyfd2rx (fd, call, sizefs);
a1432 1
						    &callback,
a1443 1
    fce->callback = callback;
d1474 1
a1474 1
    char tmp[5];
d1535 12
d1585 1
a1585 1
    error = adir_lookup (fce_old->fid, name_old, &foo_fid, ce);
d1619 1
a1619 1
	    error = adir_lookup (fce_new->fid, name_new, &foo_fid, ce);
a1675 20
/* XXX */

/*
 *
 */

static void
recon_hashtabdel (FCacheEntry *e)
{
}

/*
 *
 */

static void
recon_hashtabadd (FCacheEntry *e)
{
}

a1695 1
    Result res;
d1700 1
a1700 1
    char tmp[5];
a1733 1

d1735 6
a1740 3
	arla_log (ADEBDISCONN, "Cannot call");
	res.res = ENOMEM;
	goto out;
d1788 1
a1788 1
	    update_kernelfid(fakeFid, childEntry->fid); 
d1849 7
d1876 1
a1876 1
    update_kernelfid(fakeFid, childEntry->fid); 
a1906 1
    Result res;
d1910 1
a1910 1
    char tmp[5];
d1936 1
a1936 1
  tempret = adir_lookup (parentEntry->fid , name , &foo_fid , ce);  */
a1941 1

d1944 4
a1947 2
	res.res = ENOMEM;
	goto out;
d2003 1
a2003 1
    tempret = adir_lookup (tempparEntry->fid ,name, &foo_fid, ce);
a2007 2
    tempret = adir_mkdir (childEntry, childEntry->fid.fid,parentEntry->fid.fid); 

d2011 1
a2011 1
    update_kernelfid(fakeFid, childEntry->fid);
d2022 1
a2022 1
    assert (tempEntry == NULL);
d2045 1
a2045 1
    char tmp[5];
a2070 1

d2073 4
a2076 2
	res.res = ENOMEM;
	goto out;
d2103 1
d2120 1
a2120 1
    char tmp[5];
a2149 1

d2152 4
a2155 1
	goto out;
d2196 1
a2196 1
    update_kernelfid(fakeFid, childEntry->fid);
@


1.1.1.1
log
@Import of arla-0.35.7
@
text
@d1 1
a34 2
#if 0

d37 1
a37 1
RCSID("$KTH: reconnect.c,v 1.30.2.1 2001/06/04 22:16:39 ahltorp Exp $");
d124 1
a124 1
    fd = open(log_file, O_RDWR | O_BINARY);
a324 3
    i = ftruncate (fd, 0);
    assert (i == 0);

d540 1
a540 1
VenusFid *
d797 2
a798 2
    char tmp[2 * sizeof(int) + 2];
    fcache_cache_handle cache_handle;
d823 1
a823 1
	    fcache_cache_handle cache_handle;
d839 1
a839 1
    AssertExclLocked(&fce->lock);
a841 6
    if (conn == NULL) {
	arla_log (ADEBDISCONN, "find_first_fs failed", fce->index);
	cred_free(ce);
	ReleaseWriteLock(&fce->lock);
	return ENETDOWN;
    }
d846 1
a846 1
   error = adir_lookup(fce->fid, name, &tempfid, NULL, &ce);
d865 1
a865 1
    error = adir_lookup(&fce->fid, name, &tempfid, NULL, &ce);
d907 1
a907 1
    char tmp[2 * sizeof(int) + 2];
d910 1
a910 1
    fcache_cache_handle cache_handle;
d926 1
a926 1
    AssertExclLocked(&fce->lock);
a928 6
    if (conn == NULL) {
	arla_log (ADEBDISCONN, "find_first_fs failed", fce->index);
	cred_free(ce);
	ReleaseWriteLock(&fce->lock);
	return ENETDOWN;
    }
d944 1
a944 1
    error = adir_lookup(&fce->fid, name, &tempfid, NULL, &ce);
d990 1
a990 1
    AssertExclLocked(&fetched.lock);
a993 4
    if (conn == NULL) {
	arla_log (ADEBDISCONN, "find_first_fs failed", fce->index);
	return ENETDOWN;
    }
d1021 1
a1021 2
static void
fcache_backfile_name(char *name, size_t len)
d1034 1
a1034 1
static void
d1037 1
a1037 1
    char name_from[2 * sizeof(int) + 1], name_to[2 * sizeof(int) + 1];
d1041 6
a1046 3
    snprintf (name_from, sizeof(name_from), "%04X", from);
    snprintf (name_to,   sizeof(name_to),   "%04X", to);

d1067 2
a1068 13
static void
reconnect_update_fid (FCacheEntry *entry, VenusFid oldfid)
{
    if (entry->flags.kernelp)
	update_fid (oldfid, NULL, entry->fid, entry);
}

/*
 *
 */

static int
reconnect_mut_newfile(FCacheEntry **fcep, xfs_pag_t cred,VenusFid *new_fid)
d1073 1
a1073 1
    char name[2 * sizeof(int) + 3 + 1], tmp[2 * sizeof(int) + 2];
d1081 1
a1081 1
    fcache_cache_handle cache_handle;
d1143 1
a1175 1
#if 0 /* XXX */
a1184 1
	fce->length = sizefs;
d1190 6
d1200 6
a1205 5
    if (conn == NULL) {
	arla_log (ADEBDISCONN, "find_first_fs failed.");
	ReleaseWriteLock(&fce->lock);
	cred_free(ce);
	return ENETDOWN;
d1208 11
a1218 1
    if (fce->status.FileType != TYPE_DIR) {
d1220 7
a1226 6
	call = rx_NewCall (conn->connection);
	if (call == NULL) {
	    arla_log (ADEBDISCONN, "Cannot call");
	    res.res = ENOMEM;
	    goto out;
	}
d1228 6
a1233 11
	storestatus.Mask = 0;
	res.res = StartRXAFS_StoreData (call,
					&(fce->fid.fid),
					&storestatus,
					0, 0, fce->status.Length);
	if(res.res) {
	    arla_log (ADEBDISCONN, "Could not start store, %s (%d)",
		      koerr_gettext(res.res), res.res);
	    rx_EndCall(call, 0);
	    goto out;
	}
d1235 9
a1243 7
	sizefs = htonl (sizefs);
	if (rx_Write (call, &sizefs, sizeof(sizefs)) != sizeof(sizefs)) {
	    res.res = conv_to_arla_errno(rx_Error(call));
	    arla_log (ADEBDISCONN, "Error writing length: %d", res.res);
	    rx_EndCall(call, 0);
	    goto out;
	}
d1245 3
a1247 6
	if (rx_Write (call, 0, 0) != 0) {
	    res.res = conv_to_arla_errno(rx_Error(call));
	    arla_log (ADEBDISCONN, "Error writing: %d", res.res);
	    rx_EndCall(call, 0);
	    goto out;
	}
d1249 1
a1249 13
	res.res = rx_EndCall (call, EndRXAFS_StoreData (call,
							&status,
							&volsync));
	if (res.res) {
	    arla_log (ADEBDISCONN, "Error rx_EndCall: %s (%d)",
		      koerr_gettext(res.res), res.res);
	    goto out;
	}

	fce->status   = status;
	fce->volsync  = volsync;

	volcache_update_volsync (fce->volume, fce->volsync);
a1250 1
    }
d1299 1
d1351 1
a1351 1
    AssertExclLocked(&fce->lock);
a1353 6
    if (conn == NULL) {
	arla_log (ADEBDISCONN, "find_first_fs failed");
	ReleaseWriteLock(&fce->lock); 
	cred_free(ce);
	return ENETDOWN;
    }
d1390 1
a1390 1
    res.res = copyfd2rx (fd, call, 0, sizefs);
d1399 1
d1411 1
d1442 1
a1442 1
    char tmp[2 * sizeof(int) + 2];
d1448 1
a1448 1
    fcache_cache_handle cache_handle;
d1499 2
a1500 2
    AssertExclLocked(&fce_old->lock);
    AssertExclLocked(&fce_new->lock);
a1502 12
    if (conn == NULL) {
	arla_log (ADEBDISCONN, "find_first_fs failed");
	ReleaseWriteLock(&fce_new->lock);
	
	if (fid_old->fid.Volume != fid_new->fid.Volume ||
	    fid_old->fid.Vnode != fid_new->fid.Vnode   ||
	    fid_old->fid.Unique != fid_new->fid.Unique )
	    ReleaseWriteLock(&fce_old->lock); /* old and new are the same*/
	
	cred_free(ce);
	return ENETDOWN;
    }
d1541 1
a1541 1
    error = adir_lookup (&fce_old->fid, name_old, &foo_fid, NULL, &ce);
d1575 1
a1575 1
	    error = adir_lookup (&fce_new->fid, name_new, &foo_fid, NULL, &ce);
d1632 20
d1672 1
d1677 2
a1678 2
    char tmp[2 * sizeof(int) + 2];
    fcache_cache_handle cache_handle;
d1711 1
d1713 3
a1715 6
	arla_log (ADEBDISCONN, "find_first_fs failed");
	ReleaseWriteLock(&parentEntry->lock);
	ReleaseWriteLock(&childEntry->lock);
	free_fs_server_context(&context);
	cred_free(ce);
	return ENETDOWN;
d1763 1
a1763 1
	    reconnect_update_fid (childEntry, fakeFid);
a1823 7
    if (parentEntry->volume == NULL)
	ret = volcache_getbyid (parentEntry->fid.fid.Volume,
				parentEntry->fid.Cell,
				ce,
				&parentEntry->volume,
				&type);

d1844 1
a1844 1
    reconnect_update_fid (childEntry, fakeFid);
d1875 1
d1879 1
a1879 1
    char tmp[2 * sizeof(int) + 2];
d1886 1
a1886 1
    fcache_cache_handle cache_handle;
d1905 1
a1905 1
  tempret = adir_lookup (parentEntry->fid , name , &foo_fid , NULL, ce);  */
d1911 1
d1914 2
a1915 4
	ReleaseWriteLock(&parentEntry->lock);
	ReleaseWriteLock(&childEntry->lock);
	cred_free(ce);
	return ENETDOWN;
d1971 1
a1971 1
    tempret = adir_lookup (tempparEntry->fid ,name, &foo_fid, NULL, ce);
d1976 2
d1981 1
a1981 1
    reconnect_update_fid(childEntry, fakeFid);
d1992 1
a1992 1
    ReleaseWriteLock(&tempEntry->lock);
d2015 1
a2015 1
    char tmp[2 * sizeof(int) + 2];
d2023 1
a2023 1
    fcache_cache_handle cache_handle;
d2041 1
d2044 2
a2045 4
	ReleaseWriteLock(&dir_entry->lock);
	ReleaseWriteLock(&existing_entry->lock);
	cred_free(ce);
	return ENETDOWN;
a2071 1
    cred_free(ce);
d2088 1
a2088 1
    char tmp[2 * sizeof(int) + 2];
d2095 1
a2095 1
    fcache_cache_handle cache_handle;
d2118 1
d2121 1
a2121 4
	ReleaseWriteLock(&dir_entry->lock);
	ReleaseWriteLock(&childEntry->lock);
	cred_free(ce);
	return ENOMEM;
d2162 1
a2162 1
    reconnect_update_fid(childEntry, fakeFid);
a2172 1
#endif
@


1.1.1.2
log
@Import of arla -current as of Aug 5 2003

ok todd@@ deraadt@@
@
text
@d1 2209
a2209 2213
OBSOLETE /* COPYRIGHT  (C)  1998
OBSOLETE  * THE REGENTS OF THE UNIVERSITY OF MICHIGAN
OBSOLETE  * ALL RIGHTS RESERVED
OBSOLETE  * 
OBSOLETE  * PERMISSION IS GRANTED TO USE, COPY, CREATE DERIVATIVE WORKS 
OBSOLETE  * AND REDISTRIBUTE THIS SOFTWARE AND SUCH DERIVATIVE WORKS 
OBSOLETE  * FOR ANY PURPOSE, SO LONG AS THE NAME OF THE UNIVERSITY OF 
OBSOLETE  * MICHIGAN IS NOT USED IN ANY ADVERTISING OR PUBLICITY 
OBSOLETE  * PERTAINING TO THE USE OR DISTRIBUTION OF THIS SOFTWARE 
OBSOLETE  * WITHOUT SPECIFIC, WRITTEN PRIOR AUTHORIZATION.  IF THE 
OBSOLETE  * ABOVE COPYRIGHT NOTICE OR ANY OTHER IDENTIFICATION OF THE 
OBSOLETE  * UNIVERSITY OF MICHIGAN IS INCLUDED IN ANY COPY OF ANY 
OBSOLETE  * PORTION OF THIS SOFTWARE, THEN THE DISCLAIMER BELOW MUST 
OBSOLETE  * ALSO BE INCLUDED.
OBSOLETE  * 
OBSOLETE  * THIS SOFTWARE IS PROVIDED AS IS, WITHOUT REPRESENTATION 
OBSOLETE  * FROM THE UNIVERSITY OF MICHIGAN AS TO ITS FITNESS FOR ANY 
OBSOLETE  * PURPOSE, AND WITHOUT WARRANTY BY THE UNIVERSITY OF 
OBSOLETE  * MICHIGAN OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING 
OBSOLETE  * WITHOUT LIMITATION THE IMPLIED WARRANTIES OF 
OBSOLETE  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE 
OBSOLETE  * REGENTS OF THE UNIVERSITY OF MICHIGAN SHALL NOT BE LIABLE 
OBSOLETE  * FOR ANY DAMAGES, INCLUDING SPECIAL, INDIRECT, INCIDENTAL, OR 
OBSOLETE  * CONSEQUENTIAL DAMAGES, WITH RESPECT TO ANY CLAIM ARISING 
OBSOLETE  * OUT OF OR IN CONNECTION WITH THE USE OF THE SOFTWARE, EVEN 
OBSOLETE  * IF IT HAS BEEN OR IS HEREAFTER ADVISED OF THE POSSIBILITY OF 
OBSOLETE  * SUCH DAMAGES.
OBSOLETE  */
OBSOLETE 
OBSOLETE /*
OBSOLETE  * Do merging of the files that changed with we was in disconnected mode
OBSOLETE  */
OBSOLETE 
OBSOLETE #if 0
OBSOLETE 
OBSOLETE #include "arla_local.h"
OBSOLETE 
OBSOLETE RCSID("$arla: reconnect.c,v 1.37 2002/09/07 10:43:27 lha Exp $");
OBSOLETE 
OBSOLETE static int reconnect_nonmute(struct vcache *, int, struct timeval);
OBSOLETE static int reconnect_putattr(struct vcache *, struct nnpfs_attr *);
OBSOLETE static int reconnect_putdata(struct vcache *);    
OBSOLETE static int reconnect_remove(struct vcache *, FCacheEntry *childentry, char *);
OBSOLETE static int reconnect_rename(struct vcache *, struct vcache *, char *, char *);
OBSOLETE static int reconnect_rmdir(struct vcache *vcp, FCacheEntry *childEntry,
OBSOLETE 			   char *name);
OBSOLETE static int reconnect_mkdir(struct vcache *parent, struct vcache *curdir, 
OBSOLETE 			   AFSStoreStatus *store_status, char *name);
OBSOLETE static int reconnect_link(struct vcache *parent, struct vcache *existing,
OBSOLETE 			  char *name);
OBSOLETE static int reconnect_symlink(struct vcache *parent, struct vcache *child,
OBSOLETE 			     AFSStoreStatus *store_attr, char *name, 
OBSOLETE 			     char *contents);
OBSOLETE static int reconnect_create(struct vcache *parent, struct vcache *child,
OBSOLETE 			    char *name);
OBSOLETE static int reconnect_mut_chk(FCacheEntry *fce, CredCacheEntry *ce,
OBSOLETE 			     int version);
OBSOLETE 
OBSOLETE static int check_log_todo(log_ent_t * , VenusFid *, VenusFid *);
OBSOLETE static int is_done_before(int no);
OBSOLETE static void add_done_list(int no);
OBSOLETE static void clear_log_entry(void);
OBSOLETE static void clear_index_list(void);
OBSOLETE 
OBSOLETE typedef struct _fid_trans{
OBSOLETE     VenusFid logged_fid;
OBSOLETE     VenusFid fetched_fid;
OBSOLETE     struct _fid_trans *next, *prev;
OBSOLETE } fid_trans;
OBSOLETE 
OBSOLETE typedef struct _fid_keep{
OBSOLETE     char name[MAX_NAME];
OBSOLETE     AFSFid kept_fid;
OBSOLETE     struct _fid_keep *next;
OBSOLETE } fid_keep;
OBSOLETE 
OBSOLETE typedef struct _index_list{
OBSOLETE     int   index;
OBSOLETE     struct _index_list * next;
OBSOLETE } index_list;
OBSOLETE 
OBSOLETE fid_trans *fid_AD_head, *fid_AD_tail;
OBSOLETE fid_keep  *fid_KP_head;
OBSOLETE index_list * index_head;
OBSOLETE extern log_ent_t  log_head;
OBSOLETE 
OBSOLETE 
OBSOLETE /*
OBSOLETE  *
OBSOLETE  */
OBSOLETE 
OBSOLETE static void
OBSOLETE set_fid_value(VenusFid *new, VenusFid *old)
OBSOLETE {
OBSOLETE     if(old==0) {
OBSOLETE 	new->fid.Volume = 0;
OBSOLETE 	new->fid.Vnode = 0;
OBSOLETE 	new->fid.Unique = 0;
OBSOLETE     } else {
OBSOLETE 	new->fid.Volume = old->fid.Volume;
OBSOLETE 	new->fid.Vnode  = old->fid.Vnode;
OBSOLETE         new->fid.Unique = old->fid.Unique;
OBSOLETE     }
OBSOLETE }
OBSOLETE 
OBSOLETE /*
OBSOLETE  *
OBSOLETE  */
OBSOLETE 
OBSOLETE void 
OBSOLETE do_replay(char *log_file, int log_entries, VenusFid *changed_fid)
OBSOLETE {
OBSOLETE     int fd, len, i;
OBSOLETE     log_ent_t *cur_log;
OBSOLETE     struct vcache vc, vc_new;
OBSOLETE     char *name, *name_new;
OBSOLETE     fid_trans *fid_tmp;
OBSOLETE     fid_keep * fid_KP_tail;
OBSOLETE     VenusFid new_fid; 
OBSOLETE 
OBSOLETE     int count=1; /* Used to record how may actions we have done*/
OBSOLETE 
OBSOLETE     fid_AD_tail = fid_AD_head;
OBSOLETE     cur_log = (log_ent_t *) malloc(sizeof(log_ent_t));
OBSOLETE     fd = open(log_file, O_RDWR | O_BINARY);
OBSOLETE 
OBSOLETE     set_fid_value(&new_fid , 0);
OBSOLETE 
OBSOLETE     while (read(fd, cur_log, sizeof(int))){
OBSOLETE 
OBSOLETE 	if (cur_log->log_len < sizeof(*cur_log) - sizeof(cur_log->log_data) ||
OBSOLETE             cur_log->log_len > sizeof(log_ent_t)) {
OBSOLETE 	    arla_log(ADEBDISCONN, "do_replay: corrupt log entry, log_len %d",
OBSOLETE 		     cur_log->log_len);
OBSOLETE 	    goto terminate;
OBSOLETE 	}
OBSOLETE 
OBSOLETE 	len = cur_log->log_len - sizeof(int);
OBSOLETE 
OBSOLETE 	if (!read(fd, ((char *)cur_log + sizeof(int)), len)){
OBSOLETE 	    arla_log(ADEBDISCONN, "do_replay: read bad log entry...");
OBSOLETE 	    goto terminate;
OBSOLETE 	}
OBSOLETE 
OBSOLETE 	arla_log(ADEBDISCONN, 
OBSOLETE 		 "do_replay: read %d bytes of log entry.", 
OBSOLETE 		 cur_log->log_len);
OBSOLETE 
OBSOLETE 	if (is_done_before(cur_log->log_index)==1)
OBSOLETE 	    continue; /* the log entry has been executed */
OBSOLETE 	else {
OBSOLETE 	    if (changed_fid !=0) {
OBSOLETE 		int is_log_todo = 0;
OBSOLETE  
OBSOLETE 		is_log_todo = check_log_todo(cur_log, changed_fid, &new_fid);
OBSOLETE 		if (is_log_todo ==0)
OBSOLETE 		    continue; /* This log should not be  executed */
OBSOLETE 	    }
OBSOLETE 	}
OBSOLETE 
OBSOLETE 	add_done_list(cur_log->log_index);
OBSOLETE 
OBSOLETE 	/* big case/switch statement to switch log_op  */
OBSOLETE 	switch (cur_log->log_op){
OBSOLETE 
OBSOLETE 	case DIS_STORE:
OBSOLETE 	    vc.fid = cur_log->st_fid;
OBSOLETE 	    vc.DataVersion = cur_log->st_origdv-1;
OBSOLETE 	    vc.flag = cur_log->st_flag;
OBSOLETE 	    vc.cred = cur_log->cred;
OBSOLETE 	    arla_log(ADEBDISCONN, 
OBSOLETE 		     "%d action is to do_replay: **replay** (putdata) op...",
OBSOLETE 		     count++);
OBSOLETE 	    reconnect_putdata(&vc);
OBSOLETE 	    break;
OBSOLETE 	case DIS_SETATTR:
OBSOLETE 	    vc.fid = cur_log->sa_fid;
OBSOLETE 	    vc.DataVersion = cur_log->sa_origdv;
OBSOLETE 	    vc.flag = 0;
OBSOLETE 	    vc.cred = cur_log->cred;
OBSOLETE 	    arla_log(ADEBDISCONN, 
OBSOLETE 		     "%d action is to do_replay: **replay** (putattr) op...",
OBSOLETE 		     count++);
OBSOLETE 	    reconnect_putattr(&vc, &(cur_log->sa_vattr));
OBSOLETE 	    break;
OBSOLETE 	case DIS_REMOVE: {
OBSOLETE 	    FCacheEntry *childentry;
OBSOLETE 	    vc.fid = cur_log->rm_filefid;
OBSOLETE 	    vc.DataVersion = cur_log->rm_origdv;
OBSOLETE 	    vc.flag = 0;
OBSOLETE 	    vc.cred = cur_log->cred;
OBSOLETE 	    childentry = cur_log->rm_chentry;
OBSOLETE 	    name = cur_log->rm_name;
OBSOLETE 	    arla_log(ADEBDISCONN, 
OBSOLETE 		     "%d action is to do_replay: **replay** "
OBSOLETE 		     "(file remove) op...",
OBSOLETE 		     count++);
OBSOLETE 	    reconnect_remove(&vc, childentry, name);
OBSOLETE 	    break;
OBSOLETE 	}
OBSOLETE 	case DIS_RMDIR: {
OBSOLETE 	    FCacheEntry *child;
OBSOLETE 	    vc.fid = cur_log->rd_parentfid;
OBSOLETE 	    name = cur_log->rd_name;
OBSOLETE 	    vc.cred = cur_log->cred;
OBSOLETE 	    child = cur_log->rd_direntry;
OBSOLETE 	    arla_log (ADEBDISCONN,
OBSOLETE 		      "%d action is to do_replay: **rmdir** "
OBSOLETE 		      "(directory remove) op...",
OBSOLETE 		      count++);
OBSOLETE 	    reconnect_rmdir(&vc, child, name);
OBSOLETE 	    break;
OBSOLETE 	}
OBSOLETE 	case DIS_RENAME:
OBSOLETE 	    vc.fid = cur_log->rn_oparentfid;
OBSOLETE 	    vc.DataVersion = cur_log->rn_origdv;
OBSOLETE 	    vc.flag = 0;
OBSOLETE 	    vc.cred = cur_log->cred;
OBSOLETE 	    vc_new.fid = cur_log->rn_nparentfid;
OBSOLETE 	    vc_new.DataVersion = cur_log->rn_overdv;
OBSOLETE 	    vc_new.flag = 0;
OBSOLETE 	    vc_new.cred = cur_log->cred;
OBSOLETE 	    name = cur_log->rn_names;
OBSOLETE 	    for (i=0; *(name+i)!='\0';++i);
OBSOLETE 	    name_new = name+i+1; 
OBSOLETE 	    arla_log(ADEBDISCONN, 
OBSOLETE 		     "%d action is to do_replay: **replay** (rename) op...",
OBSOLETE 		     count++);
OBSOLETE 	    reconnect_rename(&vc, &vc_new, name, name_new);
OBSOLETE 	    break;
OBSOLETE 	case DIS_MKDIR:	{ 
OBSOLETE 	    AFSStoreStatus store_status;
OBSOLETE 	    vc.fid = cur_log->md_parentfid;
OBSOLETE 	    vc.cred = cur_log->cred;
OBSOLETE 	    store_status = cur_log->md_vattr;
OBSOLETE 	    vc_new.fid = cur_log->md_dirfid;
OBSOLETE 	    /*Ba Wu: child's data vers*/
OBSOLETE 	    vc_new.DataVersion = cur_log->md_dversion; 
OBSOLETE 	    name = cur_log->md_name;
OBSOLETE 	    arla_log(ADEBDISCONN, 
OBSOLETE 		     "%d action is to DO_Replay: **replay** (mkdir) op...",
OBSOLETE 		     count++);
OBSOLETE 	    reconnect_mkdir(&vc, &vc_new, &store_status, name);
OBSOLETE 	    break; 
OBSOLETE 	}
OBSOLETE 	case DIS_LINK:
OBSOLETE 	    vc.cred = cur_log->cred;
OBSOLETE 	    vc.fid = cur_log->ln_parentfid;
OBSOLETE 	    vc_new.fid = cur_log->ln_linkfid;
OBSOLETE 	    name = cur_log->ln_name;
OBSOLETE 	    arla_log(ADEBDISCONN, 
OBSOLETE 		     "%d action is to do_replay: **replay** (link) op...",
OBSOLETE 		     count++);
OBSOLETE 	    reconnect_link(&vc, &vc_new, name);
OBSOLETE 	    break;
OBSOLETE 	case DIS_SYMLINK: {
OBSOLETE 	    char *new_name;
OBSOLETE 	    AFSStoreStatus store_attr;
OBSOLETE 	    
OBSOLETE 	    vc.fid = cur_log->sy_parentfid;
OBSOLETE 	    vc.cred = cur_log->cred;
OBSOLETE 	    name = cur_log->sy_name;
OBSOLETE 	    new_name = cur_log->sy_content;
OBSOLETE 	    vc_new.fid = cur_log->sy_filefid;
OBSOLETE 	    store_attr = cur_log->sy_attr;
OBSOLETE 	    arla_log(ADEBDISCONN, 
OBSOLETE 		     "%d action is to do_replay: **replay** (symlink) op...",
OBSOLETE 		     count++);
OBSOLETE 	    reconnect_symlink(&vc, &vc_new, &store_attr, name, new_name);
OBSOLETE 	    break;
OBSOLETE 	}
OBSOLETE 	case DIS_CREATE:
OBSOLETE 	    vc.fid = cur_log->cr_parentfid;
OBSOLETE 	    vc.cred = cur_log->cred;
OBSOLETE  
OBSOLETE 	    vc_new.fid = cur_log->cr_filefid;
OBSOLETE 	    vc_new.DataVersion = cur_log->cr_origdv;
OBSOLETE 	    arla_log(ADEBDISCONN, 
OBSOLETE 		     "%d action is to DO_Replay: **replay** (create) op...",
OBSOLETE 		     count++);
OBSOLETE 	    name = cur_log->cr_name;
OBSOLETE 	    reconnect_create(&vc, &vc_new, name); 
OBSOLETE 	    break; 
OBSOLETE 	case DIS_ACCESS:
OBSOLETE 	    vc.fid = cur_log->nm_fid;
OBSOLETE 	    vc.DataVersion = cur_log->nm_origdv;
OBSOLETE 	    vc.cred = cur_log->cred;
OBSOLETE 	    arla_log(ADEBDISCONN, 
OBSOLETE 		     "%d action is to do_replay: **replay** (nonmutating) op",
OBSOLETE 		     count++);
OBSOLETE 	    reconnect_nonmute(&vc, cur_log->log_op, cur_log->log_time);
OBSOLETE 	    break; 
OBSOLETE 
OBSOLETE 	default:
OBSOLETE 	    arla_log(ADEBDISCONN, 
OBSOLETE 		     "%d action is to do_replay: skipping the current op=%d", 
OBSOLETE 		     count++,cur_log->log_op);
OBSOLETE 	}
OBSOLETE     }  
OBSOLETE 
OBSOLETE     if (changed_fid ==0) {
OBSOLETE 	clear_index_list();  /* clean all index when after discon */
OBSOLETE 	clear_log_entry();
OBSOLETE         /* clean up, remove all associative data structures */
OBSOLETE         fid_AD_tail = fid_AD_head;
OBSOLETE   	while(fid_AD_tail)
OBSOLETE   	{
OBSOLETE 	    fid_tmp = fid_AD_tail->next;
OBSOLETE 	    free(fid_AD_tail);
OBSOLETE 	    fid_AD_tail = fid_tmp; 
OBSOLETE   	}   
OBSOLETE 	/* SWW Qiyue 28: We need to reset head to 0*/
OBSOLETE   	fid_AD_head = 0;
OBSOLETE   	fid_KP_tail = fid_KP_head;
OBSOLETE     	while(fid_KP_tail)
OBSOLETE     	{
OBSOLETE 	    fid_keep *fid_tmp;
OBSOLETE 	
OBSOLETE 	    fid_tmp = fid_KP_tail->next;
OBSOLETE 	    free(fid_KP_tail);
OBSOLETE 	    fid_KP_tail = fid_tmp;
OBSOLETE     	}
OBSOLETE    	 
OBSOLETE   	fid_KP_head = 0;
OBSOLETE     }
OBSOLETE     i = ftruncate (fd, 0);
OBSOLETE     assert (i == 0);
OBSOLETE 
OBSOLETE  terminate:
OBSOLETE 
OBSOLETE     arla_warnx (ADEBDISCONN,"We have done total %d replays",count-1);
OBSOLETE     close(fd);  
OBSOLETE     free(cur_log);
OBSOLETE     return;
OBSOLETE }
OBSOLETE 
OBSOLETE /*
OBSOLETE  *
OBSOLETE  */
OBSOLETE 
OBSOLETE static int 
OBSOLETE check_rm_fid (VenusFid v1, VenusFid v2)
OBSOLETE {
OBSOLETE     if(v1.fid.Vnode == v2.fid.Vnode &&
OBSOLETE        v1.fid.Volume == v2.fid.Volume &&
OBSOLETE        v1.fid.Unique == v2.fid.Unique )
OBSOLETE 	return 1;
OBSOLETE     else
OBSOLETE 	return 0;
OBSOLETE }
OBSOLETE 
OBSOLETE /*
OBSOLETE  *
OBSOLETE  */
OBSOLETE 
OBSOLETE static int 
OBSOLETE check_log_fid(struct vcache vc, VenusFid *fid)
OBSOLETE {
OBSOLETE     log_ent_t *temp = log_head.next;
OBSOLETE 
OBSOLETE     if (vc.fid.fid.Vnode == fid->fid.Vnode &&
OBSOLETE 	vc.fid.fid.Volume == fid->fid.Volume &&
OBSOLETE 	vc.fid.fid.Unique == fid->fid.Unique)
OBSOLETE 	return 1;
OBSOLETE 
OBSOLETE     while (temp!=0) {
OBSOLETE 	switch(temp->log_op) {
OBSOLETE 	case DIS_RENAME:
OBSOLETE 	    if (check_rm_fid(temp->rn_oparentfid,*fid)==1) 
OBSOLETE 		return 1;
OBSOLETE 	default: 
OBSOLETE 	    temp = temp->next;
OBSOLETE 	    break;
OBSOLETE         }
OBSOLETE     }
OBSOLETE     return 0;
OBSOLETE }
OBSOLETE 
OBSOLETE /*
OBSOLETE  *
OBSOLETE  */
OBSOLETE 
OBSOLETE static int 
OBSOLETE check_log_todo(log_ent_t * cur_log , VenusFid *fid, VenusFid *newfid)
OBSOLETE {
OBSOLETE     VenusFid *lookfid;
OBSOLETE     struct vcache vc, vc_new;
OBSOLETE     int will_do = 0;
OBSOLETE 
OBSOLETE     if (newfid->fid.Vnode ==0 &&
OBSOLETE 	newfid->fid.Volume == 0 &&
OBSOLETE 	newfid->fid.Unique ==0)
OBSOLETE 	lookfid = fid;
OBSOLETE     else
OBSOLETE 	lookfid = newfid; /* For create and putdata */
OBSOLETE 
OBSOLETE     switch (cur_log->log_op){
OBSOLETE     case DIS_STORE:
OBSOLETE         vc.fid = cur_log->st_fid;
OBSOLETE 	will_do = check_log_fid(vc, lookfid);
OBSOLETE         if (will_do==1) {
OBSOLETE 	    set_fid_value(newfid, 0);
OBSOLETE 	    return 1;
OBSOLETE         }
OBSOLETE         break;
OBSOLETE     case DIS_SETATTR:
OBSOLETE 	vc.fid = cur_log->sa_fid;
OBSOLETE 	will_do = check_log_fid(vc, lookfid);
OBSOLETE         if (will_do==1) {
OBSOLETE 	    set_fid_value(newfid , &cur_log->sa_fid);
OBSOLETE 	    return 1;
OBSOLETE         }
OBSOLETE         break;
OBSOLETE     case DIS_REMOVE:
OBSOLETE 	vc.fid = cur_log->rm_filefid;
OBSOLETE 	will_do = check_log_fid(vc, lookfid);
OBSOLETE         if (will_do==1) {
OBSOLETE 	    return 1;
OBSOLETE         }
OBSOLETE         break;
OBSOLETE     case DIS_RMDIR:
OBSOLETE 	vc.fid = cur_log->rd_parentfid;
OBSOLETE 	will_do = check_log_fid(vc, lookfid);
OBSOLETE         if (will_do==1) {
OBSOLETE 	    return 1;
OBSOLETE         }
OBSOLETE         break;
OBSOLETE     case DIS_RENAME:
OBSOLETE 	vc.fid = cur_log->rn_oparentfid;
OBSOLETE 	will_do = check_log_fid(vc, lookfid);
OBSOLETE         if (will_do==1) {
OBSOLETE 	    return 1;
OBSOLETE         }
OBSOLETE 	vc_new.fid = cur_log->rn_nparentfid;
OBSOLETE 	will_do = check_log_fid(vc_new, lookfid);
OBSOLETE         if (will_do==1) {
OBSOLETE 	    return 1;
OBSOLETE         }
OBSOLETE         break;
OBSOLETE     case DIS_MKDIR:
OBSOLETE 	vc.fid = cur_log->md_parentfid;
OBSOLETE 	will_do = check_log_fid(vc, lookfid);
OBSOLETE         if (will_do==1) {
OBSOLETE 	    return 1;
OBSOLETE         }
OBSOLETE 	break;
OBSOLETE     case DIS_LINK:
OBSOLETE         break;
OBSOLETE     case DIS_SYMLINK:
OBSOLETE 	will_do = check_log_fid(vc, lookfid);
OBSOLETE         if (will_do==1) {
OBSOLETE 	    return 1;
OBSOLETE         }
OBSOLETE         break;
OBSOLETE     case DIS_CREATE:
OBSOLETE 	vc.fid = cur_log->cr_parentfid;
OBSOLETE         will_do = check_log_fid(vc, lookfid);
OBSOLETE 	if (will_do==1) {
OBSOLETE 	    set_fid_value(newfid , &cur_log->cr_filefid);
OBSOLETE 	    return 1;
OBSOLETE 	}
OBSOLETE 	break;
OBSOLETE     case DIS_FSYNC:
OBSOLETE     case DIS_ACCESS:
OBSOLETE     case DIS_READDIR:
OBSOLETE     case DIS_READLINK:
OBSOLETE     case DIS_INFO:
OBSOLETE     case DIS_START_OPT:
OBSOLETE     case DIS_END_OPT:
OBSOLETE     case DIS_REPLAYED:
OBSOLETE 	/* A no op */
OBSOLETE 	break;
OBSOLETE     }
OBSOLETE     return 0;
OBSOLETE }
OBSOLETE 
OBSOLETE 
OBSOLETE #if 0
OBSOLETE 
OBSOLETE /*
OBSOLETE  *
OBSOLETE  */
OBSOLETE 
OBSOLETE void
OBSOLETE keepfid_newrename(char *name,
OBSOLETE 		  AFSFid fid)
OBSOLETE {
OBSOLETE     if (fid_KP_head == 0) {
OBSOLETE         fid_KP_head = (fid_keep *)malloc(sizeof(fid_keep));
OBSOLETE         assert(fid_KP_head);
OBSOLETE 
OBSOLETE         strcpy(fid_KP_head->name, name);
OBSOLETE 	fid_KP_head->kept_fid = fid;
OBSOLETE 	fid_KP_head->next = 0;
OBSOLETE     }
OBSOLETE     else { 
OBSOLETE         fid_keep *temp;
OBSOLETE 
OBSOLETE         temp = (fid_keep *)malloc(sizeof(fid_keep));
OBSOLETE 	assert(temp);
OBSOLETE 
OBSOLETE         strcpy(temp->name, name);
OBSOLETE 	temp->name[strlen(name)] = '\0';
OBSOLETE 	temp->kept_fid = fid;
OBSOLETE 	temp->next = fid_KP_head->next;
OBSOLETE 	fid_KP_head->next = temp;
OBSOLETE     }
OBSOLETE }
OBSOLETE 
OBSOLETE #endif
OBSOLETE 
OBSOLETE /*
OBSOLETE  *
OBSOLETE  */
OBSOLETE 
OBSOLETE static int 
OBSOLETE find_venus (char *name, VenusFid *fid)
OBSOLETE {
OBSOLETE     fid_keep *fid_temp;
OBSOLETE 
OBSOLETE     if(fid_KP_head == 0 )
OBSOLETE 	return 1;  /*error */
OBSOLETE   	
OBSOLETE     fid_temp = fid_KP_head;
OBSOLETE 
OBSOLETE     while(fid_temp) {
OBSOLETE 	if (strcmp(fid_temp->name,name) == 0) {
OBSOLETE 	    fid->fid.Volume = fid_temp->kept_fid.Volume;
OBSOLETE 	    fid->fid.Vnode = fid_temp->kept_fid.Vnode;
OBSOLETE 	    fid->fid.Unique = fid_temp->kept_fid.Unique;
OBSOLETE 	    return 0;
OBSOLETE         }
OBSOLETE 	fid_temp = fid_temp->next;
OBSOLETE     }
OBSOLETE     arla_warnx (ADEBDISCONN, "find_venus: *PANIC* not found fid for %s", name);
OBSOLETE     return 1;
OBSOLETE }
OBSOLETE 
OBSOLETE 
OBSOLETE /*
OBSOLETE  *
OBSOLETE  */
OBSOLETE 
OBSOLETE VenusFid *
OBSOLETE fid_translate(VenusFid *fid_in)
OBSOLETE {
OBSOLETE     fid_trans *fid_tmp;
OBSOLETE     VenusFid *fid_ret;
OBSOLETE 
OBSOLETE     if (!fid_AD_head)
OBSOLETE 	return fid_in;
OBSOLETE 
OBSOLETE     fid_tmp = fid_AD_head;
OBSOLETE 
OBSOLETE     while(fid_tmp){
OBSOLETE 
OBSOLETE 	fid_ret=&fid_tmp->logged_fid;
OBSOLETE 
OBSOLETE 	if ((fid_ret->Cell == fid_in->Cell) && 
OBSOLETE 	    (fid_ret->fid.Volume == fid_in->fid.Volume) && 
OBSOLETE 	    (fid_ret->fid.Vnode == fid_in->fid.Vnode) && 
OBSOLETE 	    (fid_ret->fid.Unique == fid_in->fid.Unique))
OBSOLETE 	    return &fid_tmp->fetched_fid;
OBSOLETE 
OBSOLETE 	fid_tmp = fid_tmp->next;	   
OBSOLETE     }
OBSOLETE     return fid_in; 
OBSOLETE }
OBSOLETE 
OBSOLETE /*
OBSOLETE  *
OBSOLETE  */
OBSOLETE 
OBSOLETE static void 
OBSOLETE clear_index_list(void)
OBSOLETE {
OBSOLETE     index_list *temp=index_head;
OBSOLETE 
OBSOLETE     while(temp!=0) {
OBSOLETE 	index_list *tmp;
OBSOLETE     
OBSOLETE   	tmp = temp->next;
OBSOLETE         free(temp);
OBSOLETE 	temp = tmp;
OBSOLETE     }
OBSOLETE     index_head = 0;
OBSOLETE }
OBSOLETE 
OBSOLETE /*
OBSOLETE  *
OBSOLETE  */
OBSOLETE 
OBSOLETE static void 
OBSOLETE clear_log_entry(void)
OBSOLETE {
OBSOLETE     log_ent_t *temp=log_head.next;
OBSOLETE 
OBSOLETE     while(temp!=0) {             
OBSOLETE         log_ent_t *tmp;
OBSOLETE 
OBSOLETE         tmp = temp->next;
OBSOLETE         free(temp);                          
OBSOLETE         temp = tmp;
OBSOLETE     }                        
OBSOLETE     log_head.next = 0;    
OBSOLETE }
OBSOLETE 
OBSOLETE /*
OBSOLETE  *
OBSOLETE  */
OBSOLETE 
OBSOLETE static int 
OBSOLETE is_done_before(int no)
OBSOLETE {
OBSOLETE     index_list * temp = index_head;
OBSOLETE 
OBSOLETE     while(temp !=0) {
OBSOLETE 	if (temp->index == no)
OBSOLETE 	    return 1;
OBSOLETE 	else
OBSOLETE 	    temp = temp->next;
OBSOLETE     }
OBSOLETE     return 0;
OBSOLETE }
OBSOLETE 
OBSOLETE /*
OBSOLETE  *
OBSOLETE  */
OBSOLETE 
OBSOLETE static void 
OBSOLETE add_done_list(int no)
OBSOLETE {
OBSOLETE     if (!index_head) {
OBSOLETE 	index_head = (index_list *)malloc(sizeof(index_list));
OBSOLETE 	assert(index_head);
OBSOLETE 	index_head->index = no;
OBSOLETE 	index_head->next = 0;
OBSOLETE     } else {
OBSOLETE 	index_list * temp;
OBSOLETE 	temp = (index_list *) malloc(sizeof(index_list));
OBSOLETE 	assert(temp);
OBSOLETE 	temp->next = index_head->next;
OBSOLETE 	index_head->next = temp;
OBSOLETE 	temp->index = no;
OBSOLETE     }
OBSOLETE }
OBSOLETE 
OBSOLETE /*
OBSOLETE  *
OBSOLETE  */
OBSOLETE 
OBSOLETE static void 
OBSOLETE alloc_fid_trans(VenusFid *logged_fid)
OBSOLETE {
OBSOLETE     if (!fid_AD_head)
OBSOLETE     {
OBSOLETE 	/*SWW Qiyue 28 Make sure we have the memory*/
OBSOLETE 	fid_AD_head = (fid_trans *) malloc(sizeof(fid_trans)); 
OBSOLETE 	assert(fid_AD_head);
OBSOLETE 
OBSOLETE 	fid_AD_head->prev=fid_AD_head->next = 0;
OBSOLETE 	fid_AD_tail = fid_AD_head;
OBSOLETE 	fid_AD_tail->logged_fid = *logged_fid;
OBSOLETE 
OBSOLETE     } else{
OBSOLETE 
OBSOLETE 	/*SWW Qiyue 28 Make sure we have the memory*/
OBSOLETE 	fid_AD_tail->next = (fid_trans *) malloc(sizeof(fid_trans)); 
OBSOLETE 	assert(fid_AD_tail->next);
OBSOLETE 
OBSOLETE 	fid_AD_tail->next->prev = fid_AD_tail;
OBSOLETE 	fid_AD_tail->next->next = 0;
OBSOLETE 	fid_AD_tail = fid_AD_tail->next;  /*Ba ba: move tail ahead */
OBSOLETE 	fid_AD_tail->logged_fid = *logged_fid;
OBSOLETE     }
OBSOLETE }
OBSOLETE 
OBSOLETE /*
OBSOLETE  *
OBSOLETE  */
OBSOLETE 
OBSOLETE static void 
OBSOLETE fill_fid_trans (VenusFid *fetched_fid)
OBSOLETE {
OBSOLETE     fid_AD_tail->fetched_fid = *fetched_fid;
OBSOLETE }
OBSOLETE 
OBSOLETE /*
OBSOLETE  *
OBSOLETE  */
OBSOLETE 
OBSOLETE #if 0
OBSOLETE void
OBSOLETE update_entry_flag (FCacheEntry *entry)
OBSOLETE {
OBSOLETE     entry->flags.attrp = FALSE;
OBSOLETE     entry->flags.datap = FALSE;
OBSOLETE }
OBSOLETE #endif
OBSOLETE 
OBSOLETE /*
OBSOLETE  *
OBSOLETE  */
OBSOLETE 
OBSOLETE int reconnect_nonmute(struct vcache *vcp, int op, struct timeval log_time)
OBSOLETE {
OBSOLETE     FCacheEntry *fce, fce_fetched;
OBSOLETE     CredCacheEntry *ce;
OBSOLETE     int error;
OBSOLETE     VenusFid *fid; 
OBSOLETE #if 0
OBSOLETE     ConnCacheEntry *conn;
OBSOLETE #endif
OBSOLETE 
OBSOLETE     arla_warnx (ADEBDISCONN,
OBSOLETE 		"Start of reconnect_nonmute by sww"); /*SWW Qiyue 25*/
OBSOLETE 
OBSOLETE     fid = &(vcp->fid);
OBSOLETE     if (fid->Cell == -1) /* newly created file, skip reconnect */
OBSOLETE 	return 0;
OBSOLETE 
OBSOLETE     error = fcache_find(&fce, *fid);
OBSOLETE     /* assert(fce); */
OBSOLETE     if (error) /* nonmute op on nonexisting data */
OBSOLETE     {     
OBSOLETE 	arla_log(ADEBDISCONN, 
OBSOLETE 		 "reconnect: nonmute op %d performed on cache "
OBSOLETE 		 "entry no longer exist locally!", 
OBSOLETE 		 op); 
OBSOLETE 	return -1;
OBSOLETE     }   
OBSOLETE 
OBSOLETE     arla_log(ADEBDISCONN, 
OBSOLETE 	     "reconnect: DISCONNECTED nonmute "
OBSOLETE 	     "on fid.Cell=0x%x, fid.fid.Volume= 0x%x, fid.fid.Vnode=0x%x, "
OBSOLETE 	     "fid.fid.Unique=0x%x", fid->Cell, 
OBSOLETE 	     fid->fid.Volume,
OBSOLETE 	     fid->fid.Vnode, 
OBSOLETE 	     fid->fid.Unique);  
OBSOLETE 
OBSOLETE     ce = cred_get (fid->Cell, vcp->cred.pag, CRED_ANY);
OBSOLETE     assert (ce != NULL);
OBSOLETE     error = 0;
OBSOLETE   
OBSOLETE     /* setting some stuff so do_read_attr would work */
OBSOLETE     fce->flags.attrp = TRUE;
OBSOLETE     fce->callback.CallBackType = 2;
OBSOLETE     fce_fetched = *fce;
OBSOLETE     /*conn = findconn (fce, ce);*/
OBSOLETE 
OBSOLETE     error = read_attr(&fce_fetched, ce);
OBSOLETE 
OBSOLETE     arla_log(ADEBDISCONN, 
OBSOLETE 	     "reconnect: logged DataVersion=%d, "
OBSOLETE 	     "fetched DataVersion=%d", 
OBSOLETE 	     vcp->DataVersion,
OBSOLETE 	     fce_fetched.status.DataVersion);
OBSOLETE  
OBSOLETE     if (vcp->DataVersion < fce_fetched.status.DataVersion)
OBSOLETE     {
OBSOLETE 	if (log_time.tv_usec >= fce_fetched.status.ServerModTime)
OBSOLETE 	    arla_log(ADEBDISCONN, 
OBSOLETE 		     "Warning: nonmutating operation %d read stale data!", 
OBSOLETE 		     op);
OBSOLETE 	else if (log_time.tv_usec <= fce_fetched.status.ServerModTime && 
OBSOLETE 		 (vcp->DataVersion +1) == fce_fetched.status.DataVersion)
OBSOLETE 	    arla_log(ADEBDISCONN, 
OBSOLETE 		     "Notice: file modified once after nonmutating "
OBSOLETE 		     "operation %d.",
OBSOLETE 		     op);
OBSOLETE 	else
OBSOLETE 	    arla_log(ADEBDISCONN, 
OBSOLETE 		     "Warning: nonmutating operation %d might have read "
OBSOLETE 		     "stale data!", op);
OBSOLETE     } 
OBSOLETE  
OBSOLETE     ReleaseWriteLock(&fce->lock);
OBSOLETE     cred_free(ce);
OBSOLETE     /*conn_free(conn);*/
OBSOLETE 
OBSOLETE     return error;
OBSOLETE }
OBSOLETE 
OBSOLETE /*
OBSOLETE  *
OBSOLETE  */
OBSOLETE 
OBSOLETE int reconnect_remove(struct vcache *vcp, FCacheEntry *childentry, char *name)
OBSOLETE {
OBSOLETE     FCacheEntry *fce;
OBSOLETE     CredCacheEntry *ce;
OBSOLETE     int error;
OBSOLETE     VenusFid *fid, tempfid; /* Ba san: to check the deletion of file*/
OBSOLETE     Result res;
OBSOLETE     int    isupdate;
OBSOLETE 
OBSOLETE     ConnCacheEntry *conn;
OBSOLETE     fs_server_context context;
OBSOLETE     AFSFetchStatus status;
OBSOLETE     AFSVolSync volsync; 
OBSOLETE     char tmp[2 * sizeof(int) + 2];
OBSOLETE     fcache_cache_handle cache_handle;
OBSOLETE 
OBSOLETE     fid = &(vcp->fid); /* points to the VenusFid structure */
OBSOLETE     fid = fid_translate(fid);
OBSOLETE 
OBSOLETE     arla_log(ADEBDISCONN, "reconnect: DISCONNECTED remove on "
OBSOLETE 	     "fid.Cell=0x%x, fid.fid.  Volume= 0x%x, fid.fid.Vnode=0x%x, "
OBSOLETE 	     "fid.fid.Unique=0x%x", 
OBSOLETE 	     fid->Cell, fid->fid.Volume, fid->fid.Vnode, fid->fid.Unique);
OBSOLETE 
OBSOLETE     /* ObtainWriteLock called in fcache_find */
OBSOLETE     error = fcache_find(&fce, *fid); 
OBSOLETE     assert (error == 0);
OBSOLETE 
OBSOLETE     ce = cred_get (fid->Cell, vcp->cred.pag, CRED_ANY);
OBSOLETE     assert (ce != NULL);
OBSOLETE 
OBSOLETE     if (connected_mode != CONNMODE_PARCONNECTED) {
OBSOLETE 	ObtainWriteLock(&childentry->lock);
OBSOLETE 	isupdate = reconnect_mut_chk(childentry, ce, 
OBSOLETE 				     childentry->status.DataVersion);
OBSOLETE 	ReleaseWriteLock(&childentry->lock);
OBSOLETE   
OBSOLETE 	if (isupdate)
OBSOLETE 	{
OBSOLETE 	    fcache_cache_handle cache_handle;
OBSOLETE 
OBSOLETE 	    arla_log(ADEBDISCONN, 
OBSOLETE 		     "reconnect_remove: can't remove because file modified!");
OBSOLETE 	    cred_free(ce);
OBSOLETE 	    adir_creat (fce, name, childentry->fid.fid);
OBSOLETE 	    childentry->flags.attrp = FALSE;
OBSOLETE 	    ReleaseWriteLock(&fce->lock);
OBSOLETE 	    conv_dir (fce, ce, 0, &cache_handle, tmp, sizeof(tmp));
OBSOLETE 	    ReleaseWriteLock(&fce->lock);
OBSOLETE 	    return -1;
OBSOLETE 	}
OBSOLETE     }  /* Ba ershi: we dont need to do it in parconn */
OBSOLETE 
OBSOLETE     res.res = 0;
OBSOLETE 
OBSOLETE     AssertExclLocked(&fce->lock);
OBSOLETE 
OBSOLETE     conn = find_first_fs (fce, ce, &context);
OBSOLETE     if (conn == NULL) {
OBSOLETE 	arla_log (ADEBDISCONN, "find_first_fs failed", fce->index);
OBSOLETE 	cred_free(ce);
OBSOLETE 	ReleaseWriteLock(&fce->lock);
OBSOLETE 	return ENETDOWN;
OBSOLETE     }
OBSOLETE 
OBSOLETE /* Ba san: check the file exists 
OBSOLETE 
OBSOLETE    ReleaseWriteLock(&fce->lock);
OBSOLETE    error = adir_lookup(fce->fid, name, &tempfid, NULL, &ce);
OBSOLETE    assert (error == 0);                                             
OBSOLETE    ObtainWriteLock(&fce->lock);  */
OBSOLETE      
OBSOLETE     res.res = RXAFS_RemoveFile (conn->connection,
OBSOLETE 				&fce->fid.fid,
OBSOLETE 				name,
OBSOLETE 				&status,
OBSOLETE 				&volsync);
OBSOLETE     if (res.res) {
OBSOLETE 	arla_log (ADEBDISCONN, "Could not RemoveFile: %s (%d)",
OBSOLETE 		  koerr_gettext(res.res), res.res);
OBSOLETE 	goto out;
OBSOLETE     }
OBSOLETE 
OBSOLETE     arla_warnx (ADEBDISCONN,"In reconnect_remove: Remove the file %s",name);
OBSOLETE 
OBSOLETE /* Ba san: Chcek the deletion of the file */
OBSOLETE     ReleaseWriteLock(&fce->lock);
OBSOLETE     error = adir_lookup(&fce->fid, name, &tempfid, NULL, &ce);
OBSOLETE     ObtainWriteLock(&fce->lock);
OBSOLETE 
OBSOLETE     if (error == 0) {
OBSOLETE 	int result;
OBSOLETE         
OBSOLETE 	arla_warnx (ADEBDISCONN,
OBSOLETE 		    "In reconnect_remove: file %s needs to be deleted",
OBSOLETE 		    name);
OBSOLETE 	result = adir_remove (fce,name);
OBSOLETE 	assert ( result == 0);
OBSOLETE     } /* This is for the file produced during disconnect mode,
OBSOLETE 	 if error==ENOENT then the file is created during connect mode*/
OBSOLETE   
OBSOLETE 
OBSOLETE     fce->status  = status;
OBSOLETE     fce->volsync = volsync;
OBSOLETE     childentry->host = 0;  /* Ba shiliu dont get callback */
OBSOLETE 
OBSOLETE     volcache_update_volsync (fce->volume, fce->volsync);
OBSOLETE     conv_dir (fce, ce, 0, &cache_handle, tmp, sizeof(tmp));
OBSOLETE 
OBSOLETE  out:
OBSOLETE 
OBSOLETE     cred_free(ce);
OBSOLETE     free_fs_server_context(&context);
OBSOLETE     ReleaseWriteLock(&fce->lock); 
OBSOLETE     return error;
OBSOLETE }
OBSOLETE 
OBSOLETE /*
OBSOLETE  *
OBSOLETE  */
OBSOLETE 
OBSOLETE int 
OBSOLETE reconnect_rmdir(struct vcache *vcp, FCacheEntry *childEntry, char *name)
OBSOLETE {
OBSOLETE     FCacheEntry *fce;
OBSOLETE     CredCacheEntry *ce;
OBSOLETE     int error;               
OBSOLETE     VenusFid *fid, tempfid; /* Ba san: to check the deletion of file*/
OBSOLETE     Result res;
OBSOLETE     char tmp[2 * sizeof(int) + 2];
OBSOLETE     int ret = 0; 
OBSOLETE     Result tempres; 
OBSOLETE     fcache_cache_handle cache_handle;
OBSOLETE   
OBSOLETE     ConnCacheEntry *conn;
OBSOLETE     fs_server_context context;
OBSOLETE     AFSFetchStatus status;
OBSOLETE     AFSVolSync volsync;
OBSOLETE 
OBSOLETE     fid = &(vcp->fid); /* points to the VenusFid structure */
OBSOLETE     fid = fid_translate(fid);
OBSOLETE 
OBSOLETE     ret = fcache_find(&fce, *fid);
OBSOLETE     assert (ret == 0);
OBSOLETE 
OBSOLETE     ce = cred_get (fid->Cell, vcp->cred.pag, CRED_ANY);
OBSOLETE     assert (ce != NULL);
OBSOLETE 
OBSOLETE     AssertExclLocked(&fce->lock);
OBSOLETE 
OBSOLETE     conn = find_first_fs (fce, ce, &context);
OBSOLETE     if (conn == NULL) {
OBSOLETE 	arla_log (ADEBDISCONN, "find_first_fs failed", fce->index);
OBSOLETE 	cred_free(ce);
OBSOLETE 	ReleaseWriteLock(&fce->lock);
OBSOLETE 	return ENETDOWN;
OBSOLETE     }
OBSOLETE 
OBSOLETE     ret = RXAFS_RemoveDir (conn->connection,
OBSOLETE 			   &fce->fid.fid,
OBSOLETE 			   name,
OBSOLETE 			   &status,
OBSOLETE 			   &volsync);
OBSOLETE     if (ret) {
OBSOLETE 	arla_log (ADEBDISCONN, 
OBSOLETE 		  "Could not RemoveDir : %s (%d)", 
OBSOLETE 		  koerr_gettext(res.res),res.res);
OBSOLETE 	goto out;
OBSOLETE     }
OBSOLETE 
OBSOLETE /* Ba san: Chcek the deletion of the file */
OBSOLETE     ReleaseWriteLock(&fce->lock);
OBSOLETE     error = adir_lookup(&fce->fid, name, &tempfid, NULL, &ce);
OBSOLETE     ObtainWriteLock(&fce->lock);
OBSOLETE 
OBSOLETE     if (error == 0) {
OBSOLETE         int result;
OBSOLETE 
OBSOLETE         arla_warnx (ADEBDISCONN,
OBSOLETE 		    "In reconnect_rmdir: file %s needs to be deleted",name);
OBSOLETE         result = adir_remove (fce,name);
OBSOLETE         assert ( result == 0);
OBSOLETE     } /* This is for the file produced during disconnect mode,
OBSOLETE 	 if error==ENOENT then the file is created during connect mode*/
OBSOLETE 
OBSOLETE     fce->status  = status;
OBSOLETE     fce->volsync = volsync;
OBSOLETE 
OBSOLETE     volcache_update_volsync (fce->volume, fce->volsync);
OBSOLETE 
OBSOLETE     tempres = conv_dir(fce, ce, 0, &cache_handle, tmp, sizeof(tmp));
OBSOLETE 
OBSOLETE     childEntry->host = 0; /*Ba shiqi: no callback for this entry*/
OBSOLETE 
OBSOLETE  out:
OBSOLETE 
OBSOLETE     cred_free(ce);
OBSOLETE     free_fs_server_context(&context);
OBSOLETE     ReleaseWriteLock(&fce->lock);
OBSOLETE     return error;
OBSOLETE }
OBSOLETE 
OBSOLETE /*
OBSOLETE  *
OBSOLETE  */
OBSOLETE 
OBSOLETE static int 
OBSOLETE reconnect_mut_chk(FCacheEntry *fce, CredCacheEntry *ce, int version)
OBSOLETE {
OBSOLETE     ConnCacheEntry *conn;
OBSOLETE     fs_server_context context;
OBSOLETE     FCacheEntry fetched = *fce;
OBSOLETE     int ret;
OBSOLETE 
OBSOLETE     AFSFetchStatus status;                                                   
OBSOLETE     AFSCallBack callback;                                                    
OBSOLETE     AFSVolSync volsync;      
OBSOLETE 
OBSOLETE     AssertExclLocked(&fetched.lock);
OBSOLETE 
OBSOLETE /*SWW Aug 01: >= is changed into > */
OBSOLETE     conn = find_first_fs (&fetched, ce, &context);
OBSOLETE     if (conn == NULL) {
OBSOLETE 	arla_log (ADEBDISCONN, "find_first_fs failed", fce->index);
OBSOLETE 	return ENETDOWN;
OBSOLETE     }
OBSOLETE  
OBSOLETE     ret = RXAFS_FetchStatus (conn->connection,
OBSOLETE                              &fce->fid.fid,
OBSOLETE                              &status,
OBSOLETE                              &callback,
OBSOLETE                              &volsync);
OBSOLETE     if (ret) {
OBSOLETE         if (ret == -1)
OBSOLETE             ret = ENETDOWN;
OBSOLETE         free_fs_server_context(&context);
OBSOLETE         arla_warn (ADEBFCACHE, ret, "fetch-status");
OBSOLETE         return ret;
OBSOLETE     }
OBSOLETE 
OBSOLETE     if (status.DataVersion > version)
OBSOLETE     {
OBSOLETE 	arla_log(ADEBDISCONN, "reconnect_mut_chk: concurrent writes detected!");
OBSOLETE 	return 1;
OBSOLETE     }
OBSOLETE     free_fs_server_context(&context);
OBSOLETE     return 0;
OBSOLETE }
OBSOLETE 
OBSOLETE /*
OBSOLETE  *
OBSOLETE  */
OBSOLETE 
OBSOLETE static void
OBSOLETE fcache_backfile_name(char *name, size_t len)
OBSOLETE {
OBSOLETE     static int no = 1;
OBSOLETE 
OBSOLETE     snprintf (name, len, "%04X",no++);
OBSOLETE     strcat (name, "bak");
OBSOLETE     name[strlen(name)+1] = '\0';
OBSOLETE }
OBSOLETE 
OBSOLETE /*
OBSOLETE  *
OBSOLETE  */
OBSOLETE 
OBSOLETE static void
OBSOLETE copy_cached_file(int from, int to)
OBSOLETE {
OBSOLETE     char name_from[2 * sizeof(int) + 1], name_to[2 * sizeof(int) + 1];
OBSOLETE     int fd_from, n, fd_to;
OBSOLETE     char buf[BUFSIZE];
OBSOLETE 
OBSOLETE     snprintf (name_from, sizeof(name_from), "%04X", from);
OBSOLETE     snprintf (name_to,   sizeof(name_to),   "%04X", to);
OBSOLETE 
OBSOLETE     fd_from = open(name_from,O_RDONLY | O_BINARY, 0);  
OBSOLETE     fd_to   = open(name_to,  O_WRONLY | O_CREAT | O_BINARY | O_TRUNC, 0600);
OBSOLETE 
OBSOLETE     while((n = read(fd_from, buf, BUFSIZE)) > 0)
OBSOLETE 	write(fd_to, buf, n);
OBSOLETE 
OBSOLETE #if 0
OBSOLETE     if(fstat(fd_to, &statinfo)<0) {
OBSOLETE 	arla_warnx(ADEBDISCONN,"ERROR");
OBSOLETE     }
OBSOLETE #endif   
OBSOLETE 
OBSOLETE     close(fd_from);
OBSOLETE     close(fd_to);
OBSOLETE }
OBSOLETE 
OBSOLETE /*
OBSOLETE  *
OBSOLETE  */
OBSOLETE 
OBSOLETE static void
OBSOLETE reconnect_update_fid (FCacheEntry *entry, VenusFid oldfid)
OBSOLETE {
OBSOLETE     if (entry->flags.kernelp)
OBSOLETE 	update_fid (oldfid, NULL, entry->fid, entry);
OBSOLETE }
OBSOLETE 
OBSOLETE /*
OBSOLETE  *
OBSOLETE  */
OBSOLETE 
OBSOLETE static int
OBSOLETE reconnect_mut_newfile(FCacheEntry **fcep, nnpfs_pag_t cred,VenusFid *new_fid)
OBSOLETE {
OBSOLETE 
OBSOLETE     FCacheEntry *parent_fce;
OBSOLETE     u_long host;
OBSOLETE     char name[2 * sizeof(int) + 3 + 1], tmp[2 * sizeof(int) + 2];
OBSOLETE     AFSStoreStatus store_attr;
OBSOLETE     AFSFetchStatus fetch_attr;
OBSOLETE     CredCacheEntry *ce; 
OBSOLETE     AccessEntry *ae;
OBSOLETE     VenusFid newfid;
OBSOLETE     int ret;
OBSOLETE     int from, to;
OBSOLETE     fcache_cache_handle cache_handle;
OBSOLETE 
OBSOLETE     ret = fcache_find (&parent_fce, (*fcep)->parent);
OBSOLETE     assert (ret == 0);
OBSOLETE 
OBSOLETE     host = (*fcep)->host;
OBSOLETE 
OBSOLETE     ce = cred_get((*fcep)->parent.Cell, cred, CRED_ANY);
OBSOLETE 
OBSOLETE     fcache_backfile_name (name, sizeof(name));
OBSOLETE 
OBSOLETE     store_attr.Mask = 8;
OBSOLETE     store_attr.ClientModTime = 430144;
OBSOLETE     store_attr.Owner = 1957724;
OBSOLETE     store_attr.Group = 21516;
OBSOLETE     store_attr.UnixModeBits = 420;
OBSOLETE     store_attr.SegSize = 0;
OBSOLETE 
OBSOLETE     create_file(parent_fce, name, &store_attr, &newfid, &fetch_attr, ce);
OBSOLETE 
OBSOLETE     (*fcep)->flags.datap = FALSE; /* Ba shiqi: we need to get the old from FS*/
OBSOLETE     *new_fid = newfid;
OBSOLETE     from = (*fcep)->index;
OBSOLETE     ret = fcache_find(fcep, newfid);
OBSOLETE     assert (ret == 0);
OBSOLETE     to   = (*fcep)->index;
OBSOLETE     (*fcep)->host = host;
OBSOLETE     (*fcep)->flags.attrp = TRUE;
OBSOLETE     (*fcep)->flags.datap = TRUE;
OBSOLETE     findaccess(ce->cred, (*fcep)->acccache, &ae); /*Ba shijiu obtain access */
OBSOLETE     ae->cred   = ce->cred;
OBSOLETE     ae->access = (*fcep)->status.CallerAccess;
OBSOLETE 
OBSOLETE     ReleaseWriteLock(&(*fcep)->lock);
OBSOLETE 
OBSOLETE     copy_cached_file(from, to);
OBSOLETE     ret = adir_creat (parent_fce, name, newfid.fid);
OBSOLETE     assert (ret ==0);
OBSOLETE     conv_dir (parent_fce, ce, 0, &cache_handle, tmp, sizeof(tmp));
OBSOLETE     ReleaseWriteLock(&parent_fce->lock);
OBSOLETE 
OBSOLETE     return 0;
OBSOLETE }
OBSOLETE 
OBSOLETE    
OBSOLETE /*
OBSOLETE  *
OBSOLETE  */
OBSOLETE 
OBSOLETE int reconnect_putattr(struct vcache *vcp, struct nnpfs_attr *xap)
OBSOLETE {
OBSOLETE 
OBSOLETE     ConnCacheEntry *conn;
OBSOLETE     fs_server_context context;
OBSOLETE     struct rx_call *call;
OBSOLETE     VenusFid *fid;
OBSOLETE     CredCacheEntry *ce;
OBSOLETE     FCacheEntry *fce, *tempce;
OBSOLETE     AFSFetchStatus status;
OBSOLETE     Result res;
OBSOLETE     uint32_t sizefs;
OBSOLETE     AFSStoreStatus storestatus;
OBSOLETE     AFSVolSync volsync;
OBSOLETE     int ret;
OBSOLETE 
OBSOLETE     fid = &(vcp->fid); /* points to the VenusFid structure */
OBSOLETE     fid = fid_translate(fid);
OBSOLETE 
OBSOLETE #if 0
OBSOLETE     arla_log(ADEBDISCONN, "reconnect: DISCONNECTED write on fid.Cell=0x%x, "
OBSOLETE 	     "fid.fid.Volume= 0x%x, fid.fid.Vnode=0x%x, fid.fid.Unique=0x%x",
OBSOLETE 	     fid->Cell, 
OBSOLETE 	     fid->fid.Volume, 
OBSOLETE 	     fid->fid.Vnode, 
OBSOLETE 	     fid->fid.Unique);
OBSOLETE #endif
OBSOLETE 
OBSOLETE     ce = cred_get (fid->Cell, vcp->cred.pag, CRED_ANY);
OBSOLETE     assert (ce != NULL);
OBSOLETE     res.res = 0;
OBSOLETE 
OBSOLETE #if 0
OBSOLETE /* Ba shier: should we send the file back to server?  */
OBSOLETE     if (XA_VALID_SIZE(xap)){
OBSOLETE 	AFSStoreStatus storestatus;
OBSOLETE 	memset(&storestatus, 0, sizeof(storestatus));
OBSOLETE 	storestatus.Mask = 0;
OBSOLETE 
OBSOLETE 	res = cm_ftruncate (*fid, xap->xa_size, &storestatus, ce);
OBSOLETE     }  
OBSOLETE #endif
OBSOLETE 
OBSOLETE     ret = fcache_find(&fce, *fid);
OBSOLETE     assert (ret == 0);
OBSOLETE     tempce = fce;
OBSOLETE 
OBSOLETE     sizefs=fce->status.Length;
OBSOLETE 
OBSOLETE #if 0 /* XXX */
OBSOLETE     /* some people have written to the file while we are disconnected */
OBSOLETE     /* we have to give it a different name on the server  */
OBSOLETE     if (reconnect_mut_chk(fce, ce, vcp->DataVersion))
OBSOLETE     {
OBSOLETE 	VenusFid new_fid;
OBSOLETE 
OBSOLETE 	alloc_fid_trans(fid);
OBSOLETE 	reconnect_mut_newfile(&fce,vcp->cred.pag,&new_fid);  
OBSOLETE 	fce->status.Length = sizefs;
OBSOLETE 	fce->length = sizefs;
OBSOLETE 	ReleaseWriteLock(&tempce->lock);
OBSOLETE 	fill_fid_trans(&new_fid);
OBSOLETE 	tempce->flags.attrp = FALSE;
OBSOLETE 	tempce->flags.kernelp = FALSE;
OBSOLETE     }   
OBSOLETE #endif
OBSOLETE 
OBSOLETE     /* code from truncate file XXX join */
OBSOLETE     conn = find_first_fs (fce, ce, &context);
OBSOLETE     if (conn == NULL) {
OBSOLETE 	arla_log (ADEBDISCONN, "find_first_fs failed.");
OBSOLETE 	ReleaseWriteLock(&fce->lock);
OBSOLETE 	cred_free(ce);
OBSOLETE 	return ENETDOWN;
OBSOLETE     }
OBSOLETE 
OBSOLETE     if (fce->status.FileType != TYPE_DIR) {
OBSOLETE 
OBSOLETE 	call = rx_NewCall (conn->connection);
OBSOLETE 	if (call == NULL) {
OBSOLETE 	    arla_log (ADEBDISCONN, "Cannot call");
OBSOLETE 	    res.res = ENOMEM;
OBSOLETE 	    goto out;
OBSOLETE 	}
OBSOLETE 
OBSOLETE 	storestatus.Mask = 0;
OBSOLETE 	res.res = StartRXAFS_StoreData (call,
OBSOLETE 					&(fce->fid.fid),
OBSOLETE 					&storestatus,
OBSOLETE 					0, 0, fce->status.Length);
OBSOLETE 	if(res.res) {
OBSOLETE 	    arla_log (ADEBDISCONN, "Could not start store, %s (%d)",
OBSOLETE 		      koerr_gettext(res.res), res.res);
OBSOLETE 	    rx_EndCall(call, 0);
OBSOLETE 	    goto out;
OBSOLETE 	}
OBSOLETE 
OBSOLETE 	sizefs = htonl (sizefs);
OBSOLETE 	if (rx_Write (call, &sizefs, sizeof(sizefs)) != sizeof(sizefs)) {
OBSOLETE 	    res.res = conv_to_arla_errno(rx_GetCallError(call));
OBSOLETE 	    arla_log (ADEBDISCONN, "Error writing length: %d", res.res);
OBSOLETE 	    rx_EndCall(call, 0);
OBSOLETE 	    goto out;
OBSOLETE 	}
OBSOLETE 
OBSOLETE 	if (rx_Write (call, 0, 0) != 0) {
OBSOLETE 	    res.res = conv_to_arla_errno(rx_GetCallError(call));
OBSOLETE 	    arla_log (ADEBDISCONN, "Error writing: %d", res.res);
OBSOLETE 	    rx_EndCall(call, 0);
OBSOLETE 	    goto out;
OBSOLETE 	}
OBSOLETE 
OBSOLETE 	res.res = rx_EndCall (call, EndRXAFS_StoreData (call,
OBSOLETE 							&status,
OBSOLETE 							&volsync));
OBSOLETE 	if (res.res) {
OBSOLETE 	    arla_log (ADEBDISCONN, "Error rx_EndCall: %s (%d)",
OBSOLETE 		      koerr_gettext(res.res), res.res);
OBSOLETE 	    goto out;
OBSOLETE 	}
OBSOLETE 
OBSOLETE 	fce->status   = status;
OBSOLETE 	fce->volsync  = volsync;
OBSOLETE 
OBSOLETE 	volcache_update_volsync (fce->volume, fce->volsync);
OBSOLETE 
OBSOLETE     }
OBSOLETE     /* code from write_attr XXX join */
OBSOLETE     nnpfs_attr2afsstorestatus(xap, &storestatus);
OBSOLETE 
OBSOLETE     res.res = RXAFS_StoreStatus (conn->connection,
OBSOLETE 				 &fce->fid.fid,
OBSOLETE 				 &storestatus,
OBSOLETE 				 &status,
OBSOLETE 				 &volsync);
OBSOLETE     if (res.res) {
OBSOLETE         arla_log (ADEBDISCONN, "Could not make store-status call, %s (%d)",
OBSOLETE 		  koerr_gettext(res.res), res.res);
OBSOLETE         goto out;
OBSOLETE     }
OBSOLETE     arla_log(ADEBDISCONN, 
OBSOLETE 	     "write_attr: status.Length = %d", status.Length);
OBSOLETE     fce->status  = status;
OBSOLETE     fce->volsync = volsync;
OBSOLETE 
OBSOLETE     volcache_update_volsync (fce->volume, fce->volsync);
OBSOLETE 
OBSOLETE  out:
OBSOLETE 
OBSOLETE     free_fs_server_context(&context);
OBSOLETE     ReleaseWriteLock(&fce->lock);
OBSOLETE     cred_free(ce);
OBSOLETE     return res.res;
OBSOLETE }
OBSOLETE 
OBSOLETE /*
OBSOLETE  *
OBSOLETE  */
OBSOLETE 
OBSOLETE static int 
OBSOLETE reconnect_putdata(struct vcache *vcp)
OBSOLETE {
OBSOLETE     VenusFid *fid;
OBSOLETE     FCacheEntry *fce;
OBSOLETE     CredCacheEntry *ce;
OBSOLETE     Result res;
OBSOLETE 
OBSOLETE     uint32_t sizefs;
OBSOLETE     int fd = -1;
OBSOLETE     struct rx_call *call;
OBSOLETE     ConnCacheEntry *conn;
OBSOLETE     fs_server_context context;
OBSOLETE     struct stat statinfo;
OBSOLETE     AFSStoreStatus storestatus;
OBSOLETE     AFSFetchStatus status;
OBSOLETE     AFSVolSync volsync;
OBSOLETE     int ret;
OBSOLETE 
OBSOLETE     fid = &(vcp->fid); /* points to the VenusFid structure */
OBSOLETE     arla_log(ADEBDISCONN, "reconnect: putdata before fid_translate, "
OBSOLETE 	     "fid->Cell=0x%x, fid->fid.Volume=0x%x, fid->fid.Vnode=0x%x, "
OBSOLETE 	     "fid->fid.Unique=0x%x", 
OBSOLETE 	     fid->Cell, 
OBSOLETE 	     fid->fid.Volume, 
OBSOLETE 	     fid->fid.Vnode, 
OBSOLETE 	     fid->fid.Unique);
OBSOLETE 
OBSOLETE     fid = fid_translate(fid);
OBSOLETE 
OBSOLETE     arla_log(ADEBDISCONN, "reconnect: putdata after fid_translate, "
OBSOLETE 	     "fid->Cell=0x%x, fid->fid.Volume=0x%x, fid->fid.Vnode=0x%x, "
OBSOLETE 	     "fid->fid.Unique=0x%x", 
OBSOLETE 	     fid->Cell, 
OBSOLETE 	     fid->fid.Volume, 
OBSOLETE 	     fid->fid.Vnode, 
OBSOLETE 	     fid->fid.Unique);
OBSOLETE 
OBSOLETE 
OBSOLETE     ce = cred_get (fid->Cell, vcp->cred.pag, CRED_ANY);
OBSOLETE     assert (ce != NULL);
OBSOLETE 
OBSOLETE     ret = fcache_find (&fce, *fid);
OBSOLETE     assert (ret == 0);
OBSOLETE 
OBSOLETE #if 0
OBSOLETE     isupdate = reconnect_mut_chk(fce, ce, vcp->DataVersion);
OBSOLETE     if (isupdate)
OBSOLETE     {
OBSOLETE 	arla_log(ADEBDISCONN, 
OBSOLETE 		 "reconnect_putdata: send data back because "
OBSOLETE 		 "the file was modified!");
OBSOLETE 	cred_free(ce);
OBSOLETE 	ReleaseWriteLock(&fce->lock);
OBSOLETE 	reconnect_mut_newfile(&fce, vcp->cred.pag);  
OBSOLETE 	return -1;
OBSOLETE     }
OBSOLETE 
OBSOLETE     if (reconnect_mut_chk (fce, ce)) {
OBSOLETE 	arla_log (ADEBDISCONN, "Reconnect_putdata: can not send the file"
OBSOLETE 		  "to FS becausethis file has been modified!");
OBSOLETE 	ReleaseWriteLock(&fce->lock);
OBSOLETE 	return -1;
OBSOLETE     } 
OBSOLETE #endif
OBSOLETE 
OBSOLETE     /* code taken from write_data XXX join */ 
OBSOLETE     AssertExclLocked(&fce->lock);
OBSOLETE 
OBSOLETE     conn = find_first_fs (fce, ce, &context);
OBSOLETE     if (conn == NULL) {
OBSOLETE 	arla_log (ADEBDISCONN, "find_first_fs failed");
OBSOLETE 	ReleaseWriteLock(&fce->lock); 
OBSOLETE 	cred_free(ce);
OBSOLETE 	return ENETDOWN;
OBSOLETE     }
OBSOLETE 
OBSOLETE     fd = fcache_open_file (fce, O_RDONLY);
OBSOLETE     if (fd < 0) {
OBSOLETE 	arla_log (ADEBDISCONN, "open %u failed", fce->index);
OBSOLETE 	res.res = errno;
OBSOLETE 	goto out;
OBSOLETE     }
OBSOLETE 
OBSOLETE     if (fstat (fd, &statinfo) < 0) {
OBSOLETE 	arla_log (ADEBDISCONN, "Cannot stat file %u", fce->index);
OBSOLETE 	res.res = errno;
OBSOLETE 	goto out;
OBSOLETE     }
OBSOLETE 
OBSOLETE     sizefs = statinfo.st_size;
OBSOLETE 
OBSOLETE     call = rx_NewCall (conn->connection);
OBSOLETE     if (call == NULL) {
OBSOLETE 	arla_log (ADEBDISCONN, "Cannot call");
OBSOLETE 	res.res = ENOMEM;
OBSOLETE 	goto out;
OBSOLETE     }
OBSOLETE 
OBSOLETE     storestatus.Mask = 0; /* Dont save anything */
OBSOLETE     res.res = StartRXAFS_StoreData (call, &fce->fid.fid,
OBSOLETE 				    &storestatus,
OBSOLETE 				    0,
OBSOLETE 				    sizefs,
OBSOLETE 				    sizefs);
OBSOLETE     if (res.res) {
OBSOLETE 	arla_log (ADEBDISCONN, "Could not start store, %s (%d)",
OBSOLETE 		  koerr_gettext(res.res), res.res);
OBSOLETE 	rx_EndCall(call, 0);
OBSOLETE 	goto out;
OBSOLETE     }
OBSOLETE 
OBSOLETE     res.res = copyfd2rx (fd, call, 0, sizefs);
OBSOLETE     if (res.res) {
OBSOLETE 	rx_EndCall(call, res.res);
OBSOLETE 	arla_log (ADEBDISCONN, "copyfd2rx failed: %d", res.res);
OBSOLETE 	goto out;
OBSOLETE     }
OBSOLETE      
OBSOLETE     res.res = rx_EndCall (call, EndRXAFS_StoreData (call,
OBSOLETE 						    &status,
OBSOLETE 						    &volsync));
OBSOLETE     if (res.res) {
OBSOLETE 	arla_log (ADEBDISCONN, "Error rx_EndCall: %s (%d)", 
OBSOLETE 		  koerr_gettext(res.res), res.res);
OBSOLETE 	goto out;
OBSOLETE     }
OBSOLETE     if (status.DataVersion > fce->status.DataVersion)
OBSOLETE 	arla_log(ADEBDISCONN, 
OBSOLETE 		 "reconnect: putdata, server incremented DataVersion!");
OBSOLETE 
OBSOLETE     fce->status   = status;
OBSOLETE     fce->volsync  = volsync;
OBSOLETE 
OBSOLETE     volcache_update_volsync (fce->volume, fce->volsync);
OBSOLETE 
OBSOLETE  out:
OBSOLETE 
OBSOLETE     ReleaseWriteLock(&fce->lock); 
OBSOLETE     if (fd != -1)
OBSOLETE 	close (fd);
OBSOLETE     free_fs_server_context (&context);
OBSOLETE   
OBSOLETE     cred_free(ce);
OBSOLETE     return res.res;
OBSOLETE }
OBSOLETE 
OBSOLETE /*
OBSOLETE  *
OBSOLETE  */
OBSOLETE 
OBSOLETE int reconnect_rename(struct vcache *vcp_old, struct vcache *vcp_new, 
OBSOLETE 		     char *name_old, char *name_new)
OBSOLETE {
OBSOLETE 
OBSOLETE     FCacheEntry *fce_old, *fce_new;
OBSOLETE     CredCacheEntry *ce;
OBSOLETE     VenusFid *fid_old, *fid_new,foo_fid,*tempnew_fid;
OBSOLETE     int error;
OBSOLETE 
OBSOLETE     int ret = 0;
OBSOLETE     Result res;
OBSOLETE     char tmp[2 * sizeof(int) + 2];
OBSOLETE     int isnewpar = 0;
OBSOLETE     ConnCacheEntry *conn;
OBSOLETE     fs_server_context context;
OBSOLETE     AFSFetchStatus orig_status, new_status;
OBSOLETE     AFSVolSync volsync;
OBSOLETE     fcache_cache_handle cache_handle;
OBSOLETE 
OBSOLETE     fid_old = &vcp_old->fid;
OBSOLETE     fid_old = fid_translate(fid_old);
OBSOLETE  
OBSOLETE     ret = fcache_find (&fce_old, *fid_old);
OBSOLETE     assert (ret == 0);
OBSOLETE 
OBSOLETE     /* ReleaseWriteLock(&fce_old->lock);  SWW Qiyue 28 Maybe we dont need it*/
OBSOLETE     assert(fce_old);
OBSOLETE     arla_log(ADEBDISCONN, "reconnect: old rename on Cell=0x%x, "
OBSOLETE 	     "fid.Volume= 0x%x, fid.Vnode=0x%x, fid.Unique=0x%x", 
OBSOLETE 	     fce_old->fid.Cell,
OBSOLETE 	     fce_old->fid.fid.Volume,
OBSOLETE 	     fce_old->fid.fid.Vnode, 
OBSOLETE 	     fce_old->fid.fid.Unique);
OBSOLETE 
OBSOLETE     fid_new = tempnew_fid = &vcp_new->fid;
OBSOLETE     fid_new = fid_translate(fid_new);
OBSOLETE     
OBSOLETE     if (tempnew_fid->fid.Volume != fid_new->fid.Volume ||
OBSOLETE 	tempnew_fid->fid.Vnode != fid_new->fid.Vnode ||
OBSOLETE 	tempnew_fid->fid.Unique != fid_new->fid.Unique)
OBSOLETE         isnewpar = 1; 
OBSOLETE 
OBSOLETE /*Ba ba: the parent dir was created during disconnected */
OBSOLETE 
OBSOLETE     if (fid_old->fid.Volume == fid_new->fid.Volume &&
OBSOLETE 	fid_old->fid.Vnode == fid_new->fid.Vnode   &&
OBSOLETE 	fid_old->fid.Unique == fid_new->fid.Unique )
OBSOLETE         ReleaseWriteLock(&fce_old->lock); /* old and new are the same*/
OBSOLETE 
OBSOLETE     ret = fcache_find (&fce_new, *fid_new);
OBSOLETE     assert (ret == 0);
OBSOLETE 
OBSOLETE     arla_log(ADEBDISCONN, "reconnect: new rename on Cell=0x%x, "
OBSOLETE 	     "fid.Volume= 0x%x, fid.Vnode=0x%x, fid.Unique=0x%x", 
OBSOLETE 	     fce_new->fid.Cell, 
OBSOLETE 	     fce_new->fid.fid.Volume, 
OBSOLETE 	     fce_new->fid.fid.Vnode, 
OBSOLETE 	     fce_new->fid.fid.Unique);
OBSOLETE 
OBSOLETE 
OBSOLETE 
OBSOLETE     arla_log(ADEBDISCONN, 
OBSOLETE 	     "reconnect_rename: fce_old = 0x%x, fce_new = 0x%x",
OBSOLETE 	     fce_old, fce_new);
OBSOLETE 
OBSOLETE     ce = cred_get (vcp_old->fid.Cell, vcp_old->cred.pag, CRED_ANY);
OBSOLETE     assert (ce != NULL);
OBSOLETE 
OBSOLETE     AssertExclLocked(&fce_old->lock);
OBSOLETE     AssertExclLocked(&fce_new->lock);
OBSOLETE 
OBSOLETE     conn = find_first_fs (fce_old, ce, &context);
OBSOLETE     if (conn == NULL) {
OBSOLETE 	arla_log (ADEBDISCONN, "find_first_fs failed");
OBSOLETE 	ReleaseWriteLock(&fce_new->lock);
OBSOLETE 	
OBSOLETE 	if (fid_old->fid.Volume != fid_new->fid.Volume ||
OBSOLETE 	    fid_old->fid.Vnode != fid_new->fid.Vnode   ||
OBSOLETE 	    fid_old->fid.Unique != fid_new->fid.Unique )
OBSOLETE 	    ReleaseWriteLock(&fce_old->lock); /* old and new are the same*/
OBSOLETE 	
OBSOLETE 	cred_free(ce);
OBSOLETE 	return ENETDOWN;
OBSOLETE     }
OBSOLETE 
OBSOLETE     error = RXAFS_Rename (conn->connection,
OBSOLETE 			  &fce_old->fid.fid,
OBSOLETE 			  name_old,
OBSOLETE 			  &fce_new->fid.fid,
OBSOLETE 			  name_new,
OBSOLETE 			  &orig_status,
OBSOLETE 			  &new_status,
OBSOLETE 			  &volsync);
OBSOLETE 
OBSOLETE     if (error) {
OBSOLETE 	arla_log (ADEBDISCONN, "Could not Rename: %s (%d)", koerr_gettext(error), error); 
OBSOLETE 	goto out; }
OBSOLETE 
OBSOLETE     fce_old->status = orig_status;
OBSOLETE     fce_new->status = new_status;
OBSOLETE 
OBSOLETE     fce_old->volsync = fce_new->volsync = volsync;
OBSOLETE 
OBSOLETE     volcache_update_volsync (fce_old->volume, fce_old->volsync);
OBSOLETE 
OBSOLETE 
OBSOLETE /*SWW Aug 01 */
OBSOLETE     arla_warnx (ADEBDISCONN,
OBSOLETE 		"reconnect_rename: we delete the old one %s volumn=0x%x, "
OBSOLETE 		"vnode=0x%x,unique=0x%x",
OBSOLETE 		name_old,fce_old->fid.fid.Volume,
OBSOLETE 		fce_old->fid.fid.Vnode,
OBSOLETE 		fce_old->fid.fid.Unique);                      
OBSOLETE 
OBSOLETE /*Ba Yi: get the VenuseFid for new file */
OBSOLETE   #if 0
OBSOLETE     if (fid_old->fid.Volume == fid_new->fid.Volume &&
OBSOLETE 	fid_old->fid.Vnode == fid_new->fid.Vnode   &&
OBSOLETE 	fid_old->fid.Unique == fid_new->fid.Unique ) ;
OBSOLETE #endif
OBSOLETE     ReleaseWriteLock(&fce_old->lock); /* old and new are the same*/
OBSOLETE     
OBSOLETE     error = adir_lookup (&fce_old->fid, name_old, &foo_fid, NULL, &ce);
OBSOLETE     
OBSOLETE #if 0
OBSOLETE     if (fid_old->fid.Volume == fid_new->fid.Volume &&
OBSOLETE        fid_old->fid.Vnode == fid_new->fid.Vnode   &&
OBSOLETE        fid_old->fid.Unique == fid_new->fid.Unique );
OBSOLETE #endif
OBSOLETE     ObtainWriteLock (&fce_old->lock);
OBSOLETE 
OBSOLETE /*Ba San: delete the old which was created during dis */
OBSOLETE     if (error == 0) {
OBSOLETE 	arla_warnx (ADEBDISCONN,"reconnect_rename: we delete the old one %s "
OBSOLETE 		    "volumn=0x%x,vnode=0x%x,unique=0x%x",
OBSOLETE 		    name_old,
OBSOLETE 		    foo_fid.fid.Volume,
OBSOLETE 		    foo_fid.fid.Vnode,
OBSOLETE 		    foo_fid.fid.Unique);
OBSOLETE 
OBSOLETE 	adir_remove(fce_old,name_old);
OBSOLETE 	adir_remove(fce_new,name_new);
OBSOLETE 
OBSOLETE 	res = conv_dir (fce_old, ce, 0, &cache_handle, tmp, sizeof(tmp));
OBSOLETE 
OBSOLETE     } else {
OBSOLETE 	/* if found delete it */
OBSOLETE /*Ba San: try to find the previous VenuseFid for old name */
OBSOLETE 	if (error == ENOENT) {
OBSOLETE #if 0
OBSOLETE 	    if (fid_old->fid.Volume == fid_new->fid.Volume &&
OBSOLETE 		fid_old->fid.Vnode == fid_new->fid.Vnode   &&
OBSOLETE 		fid_old->fid.Unique == fid_new->fid.Unique );
OBSOLETE #endif
OBSOLETE 	    ReleaseWriteLock(&fce_new->lock);
OBSOLETE 	    
OBSOLETE 	    error = adir_lookup (&fce_new->fid, name_new, &foo_fid, NULL, &ce);
OBSOLETE 	    
OBSOLETE #if 0
OBSOLETE 	    if (fid_old->fid.Volume == fid_new->fid.Volume &&
OBSOLETE                fid_old->fid.Vnode == fid_new->fid.Vnode   &&
OBSOLETE                fid_old->fid.Unique == fid_new->fid.Unique );
OBSOLETE #endif
OBSOLETE 	    ObtainWriteLock (&fce_new->lock);
OBSOLETE 	    if (error == 0) /*Ba Si: We need delete the faked new */
OBSOLETE 		adir_remove(fce_new,name_new);
OBSOLETE 	    else if (error == ENOENT) {
OBSOLETE                 int venusret;
OBSOLETE 		
OBSOLETE                 venusret = find_venus (name_new,&foo_fid);
OBSOLETE                 assert (venusret==0);
OBSOLETE                 arla_warnx (ADEBDISCONN,"I MUST WRITE A PROGRAM HERE");
OBSOLETE                 if (isnewpar == 1) {
OBSOLETE 
OBSOLETE 		    arla_warnx(ADEBDISCONN,"In reconnect_rename: "
OBSOLETE 			       "new Volume=0x%x,Vnode=0x%x,Unique=0x%x",
OBSOLETE 			       fce_new->fid.fid.Volume,
OBSOLETE 			       fce_new->fid.fid.Vnode,
OBSOLETE 			       fce_new->fid.fid.Unique);
OBSOLETE #if 0
OBSOLETE 		    error = adir_creat(fce_new, name_new, foo_fid.fid);
OBSOLETE #endif
OBSOLETE 		}
OBSOLETE 	    }
OBSOLETE 	}
OBSOLETE     }
OBSOLETE 
OBSOLETE     arla_warnx (ADEBDISCONN,"reconnect_rename: we add the new one %s "
OBSOLETE 		"volumn=0x%x,vnode=0x%x,unique=0x%x",
OBSOLETE 		name_new,
OBSOLETE 		foo_fid.fid.Volume,
OBSOLETE 		foo_fid.fid.Vnode,
OBSOLETE 		foo_fid.fid.Unique);
OBSOLETE     error = adir_creat (fce_new, name_new, foo_fid.fid);
OBSOLETE     res = conv_dir (fce_new, ce, 0, &cache_handle, tmp, sizeof(tmp));
OBSOLETE 
OBSOLETE /* Aug 1 */
OBSOLETE 
OBSOLETE  out:
OBSOLETE 
OBSOLETE     free_fs_server_context (&context);
OBSOLETE 
OBSOLETE     ReleaseWriteLock(&fce_new->lock);
OBSOLETE 
OBSOLETE     if (fid_old->fid.Volume != fid_new->fid.Volume ||
OBSOLETE 	fid_old->fid.Vnode != fid_new->fid.Vnode   ||
OBSOLETE 	fid_old->fid.Unique != fid_new->fid.Unique )
OBSOLETE         ReleaseWriteLock(&fce_old->lock); /* old and new are the same*/
OBSOLETE 
OBSOLETE     cred_free(ce);
OBSOLETE     return error;
OBSOLETE }
OBSOLETE 
OBSOLETE /*
OBSOLETE  *
OBSOLETE  */
OBSOLETE 
OBSOLETE int reconnect_create(struct vcache *parent, struct vcache *child, char *name)
OBSOLETE {
OBSOLETE 
OBSOLETE     ConnCacheEntry *conn;
OBSOLETE     fs_server_context context;
OBSOLETE     VenusFid *parent_fid;
OBSOLETE     VenusFid *child_fid;
OBSOLETE     VenusFid fakeFid; 
OBSOLETE 
OBSOLETE     CredCacheEntry *ce;
OBSOLETE     FCacheEntry *parentEntry;
OBSOLETE     FCacheEntry *childEntry;
OBSOLETE 
OBSOLETE     AFSFetchStatus fetch_attr;
OBSOLETE     AFSStoreStatus store_attr; 
OBSOLETE 
OBSOLETE     AFSFetchStatus status;
OBSOLETE     AFSCallBack callback;
OBSOLETE     AFSVolSync volsync;
OBSOLETE     int ret; 
OBSOLETE     char tmp[2 * sizeof(int) + 2];
OBSOLETE     fcache_cache_handle cache_handle;
OBSOLETE     int32_t type;
OBSOLETE 
OBSOLETE     parent_fid = &(parent->fid); /* points to the VenusFid structure */
OBSOLETE     child_fid = &(child->fid);
OBSOLETE     fakeFid = *child_fid;
OBSOLETE 
OBSOLETE     /*Ba Liu: the parent dir may be created during dison mode*/
OBSOLETE     parent_fid = fid_translate(parent_fid);
OBSOLETE 
OBSOLETE     ce = cred_get (parent->fid.Cell, parent->cred.pag, CRED_ANY);
OBSOLETE     assert (ce != NULL);
OBSOLETE 
OBSOLETE     ret = fcache_find (&parentEntry, *parent_fid);
OBSOLETE     assert (ret == 0);
OBSOLETE 
OBSOLETE #if 0
OBSOLETE     is_change = reconnect_mut_chk(parentEntry, 
OBSOLETE 				  ce, 
OBSOLETE 				  parentEntry->status.DataVersion);
OBSOLETE #endif
OBSOLETE 
OBSOLETE /*SWW Qiyue 30 delete the old file entry in dir  */
OBSOLETE     arla_warnx (ADEBDISCONN,
OBSOLETE 		"reconnect_rename: we delete the old one volumn=0x%x, "
OBSOLETE 		"vnode=0x%x,unique=0x%x",
OBSOLETE 		parentEntry->fid.fid.Volume,
OBSOLETE 		parentEntry->fid.fid.Vnode,
OBSOLETE 		parentEntry->fid.fid.Unique);
OBSOLETE 
OBSOLETE     adir_remove(parentEntry,name);  
OBSOLETE 
OBSOLETE     conn = find_first_fs (parentEntry, ce, &context);
OBSOLETE     if (conn == NULL) {
OBSOLETE 	arla_log (ADEBDISCONN, "find_first_fs failed");
OBSOLETE 	ReleaseWriteLock(&parentEntry->lock);
OBSOLETE 	ReleaseWriteLock(&childEntry->lock);
OBSOLETE 	free_fs_server_context(&context);
OBSOLETE 	cred_free(ce);
OBSOLETE 	return ENETDOWN;
OBSOLETE     }
OBSOLETE 
OBSOLETE     ret = fcache_find (&childEntry, *child_fid);
OBSOLETE     assert (ret == 0);
OBSOLETE 
OBSOLETE     recon_hashtabdel(childEntry);
OBSOLETE 
OBSOLETE #if 0
OBSOLETE     fetch_attr = &childEntry->status;
OBSOLETE #endif
OBSOLETE 
OBSOLETE     store_attr.Mask 	   =    8;
OBSOLETE     store_attr.ClientModTime =    childEntry->status.ClientModTime;
OBSOLETE     store_attr.Owner = 	 	childEntry->status.Owner;
OBSOLETE     store_attr.Group = 		childEntry->status.Group;
OBSOLETE     store_attr.UnixModeBits = 	childEntry->status.UnixModeBits;
OBSOLETE     store_attr.SegSize = 		childEntry->status.SegSize;
OBSOLETE 
OBSOLETE     arla_log(ADEBDISCONN, 
OBSOLETE 	     "reconnect: create before RXAFS_CreateFile, "
OBSOLETE 	     "Cell=0x%x, fid.Volume= 0x%x, fid.Vnode=0x%x, fid.Unique=0x%x", 
OBSOLETE 	     childEntry->fid.Cell, 
OBSOLETE 	     childEntry->fid.fid.Volume, 
OBSOLETE 	     childEntry->fid.fid.Vnode, 
OBSOLETE 	     childEntry->fid.fid.Unique);
OBSOLETE 
OBSOLETE     alloc_fid_trans(&childEntry->fid);
OBSOLETE   
OBSOLETE 
OBSOLETE     ret = RXAFS_CreateFile (conn->connection,
OBSOLETE                             &(parentEntry->fid.fid),
OBSOLETE                             name, &store_attr,
OBSOLETE                             &(childEntry->fid.fid), &fetch_attr,
OBSOLETE                             &status,
OBSOLETE                             &callback,
OBSOLETE                             &volsync);
OBSOLETE  
OBSOLETE     if (ret) {
OBSOLETE 	if (ret == 17) {
OBSOLETE 	    ReleaseWriteLock(&parentEntry->lock);
OBSOLETE 	    reconnect_mut_newfile(&childEntry, 
OBSOLETE 				  parent->cred.pag, 
OBSOLETE 				  &childEntry->fid);
OBSOLETE 	    ObtainWriteLock(&parentEntry->lock);
OBSOLETE 	    fill_fid_trans(&childEntry->fid);
OBSOLETE 	    recon_hashtabadd(childEntry);
OBSOLETE 	    childEntry->host = rx_HostOf (rx_PeerOf (conn->connection));
OBSOLETE 	    reconnect_update_fid (childEntry, fakeFid);
OBSOLETE 	} else {
OBSOLETE 	    arla_log (ADEBDISCONN, "Could not CreateFile: %s (%d)",
OBSOLETE 		      koerr_gettext(ret), ret);
OBSOLETE 	}
OBSOLETE 	goto out;
OBSOLETE     }
OBSOLETE    
OBSOLETE     parentEntry->status   = status;   
OBSOLETE     parentEntry->callback = callback;
OBSOLETE     parentEntry->volsync  = volsync;
OBSOLETE 
OBSOLETE     childEntry->fid.Cell = parentEntry->fid.Cell;
OBSOLETE 
OBSOLETE     arla_log(ADEBDISCONN, "reconnect: create after RXAFS_CreateFile, "
OBSOLETE 	     "Cell=0x%x, fid.Volume= 0x%x, fid .Vnode=0x%x, fid.Unique=0x%x", 
OBSOLETE 	     childEntry->fid.Cell,
OBSOLETE 	     childEntry->fid.fid.Volume, 
OBSOLETE 	     childEntry->fid.fid.Vnode, 
OBSOLETE 	     childEntry->fid.fid.Unique); 
OBSOLETE 
OBSOLETE     fill_fid_trans(&childEntry->fid);
OBSOLETE 
OBSOLETE #if 0
OBSOLETE     ReleaseWriteLock(&childEntry->lock);
OBSOLETE #endif
OBSOLETE 
OBSOLETE 
OBSOLETE     ret = volcache_getbyid (childEntry->fid.fid.Volume,
OBSOLETE 			    childEntry->fid.Cell,
OBSOLETE 			    ce,
OBSOLETE 			    &childEntry->volume,
OBSOLETE 			    &type);
OBSOLETE 
OBSOLETE     recon_hashtabadd(childEntry); 
OBSOLETE 
OBSOLETE     arla_log(ADEBDISCONN, 
OBSOLETE 	     "reconnect: create after volcache_getbyid, Cell=0x%x, "
OBSOLETE 	     "fid.Volume= 0x%x, fid .Vnode=0x%x, fid.Unique=0x%x",
OBSOLETE 	     childEntry->fid.Cell, 
OBSOLETE 	     childEntry->fid.fid.Volume, 
OBSOLETE 	     childEntry->fid.fid.Vnode, 
OBSOLETE 	     childEntry->fid.fid.Unique); 
OBSOLETE 
OBSOLETE /* SWW Qiyue 30: add the new file entry in dir */
OBSOLETE     arla_warnx (ADEBDISCONN,"reconnect_rename: we add the new one "
OBSOLETE 		"volumn=0x%x,vnode=0x%x,unique=0x%x",
OBSOLETE 		parentEntry->fid.fid.Volume,
OBSOLETE 		parentEntry->fid.fid.Vnode,
OBSOLETE 		parentEntry->fid.fid.Unique);
OBSOLETE 
OBSOLETE     adir_creat (parentEntry, name, childEntry->fid.fid);  
OBSOLETE 
OBSOLETE     childEntry->status = fetch_attr;
OBSOLETE   
OBSOLETE     childEntry->flags.attrp = TRUE;
OBSOLETE     childEntry->flags.kernelp = TRUE;
OBSOLETE 
OBSOLETE     childEntry->flags.datap = TRUE;
OBSOLETE     childEntry->tokens |= NNPFS_ATTR_R | NNPFS_DATA_R | NNPFS_DATA_W;
OBSOLETE 
OBSOLETE     if (parentEntry->volume == NULL)
OBSOLETE 	ret = volcache_getbyid (parentEntry->fid.fid.Volume,
OBSOLETE 				parentEntry->fid.Cell,
OBSOLETE 				ce,
OBSOLETE 				&parentEntry->volume,
OBSOLETE 				&type);
OBSOLETE 
OBSOLETE     volcache_update_volsync (parentEntry->volume, parentEntry->volsync);
OBSOLETE 
OBSOLETE 
OBSOLETE 
OBSOLETE /*SWW Qiyue 28: Set the host for child entry */
OBSOLETE 
OBSOLETE     childEntry->host = rx_HostOf (rx_PeerOf (conn->connection));
OBSOLETE     assert(childEntry->host);
OBSOLETE 
OBSOLETE /*SWW Qiyue 29:  */
OBSOLETE     arla_warnx (ADEBDISCONN,
OBSOLETE 		"Replace fid.Volume=0x%x,Vnode=0x%x,Unique=0x%x with "
OBSOLETE 		"Volume=0x%x,Vnode=0x%x,Unqiue=0x%x",
OBSOLETE 		fakeFid.fid.Volume,
OBSOLETE 		fakeFid.fid.Vnode,
OBSOLETE 		fakeFid.fid.Unique,
OBSOLETE 		childEntry->fid.fid.Volume,
OBSOLETE 		childEntry->fid.fid.Vnode,
OBSOLETE 		childEntry->fid.fid.Unique);
OBSOLETE 
OBSOLETE     reconnect_update_fid (childEntry, fakeFid);
OBSOLETE 
OBSOLETE     conv_dir(parentEntry, ce, 0, &cache_handle, tmp, sizeof(tmp));
OBSOLETE 
OBSOLETE     ReleaseWriteLock(&childEntry->lock);
OBSOLETE 
OBSOLETE  out:
OBSOLETE 
OBSOLETE     ReleaseWriteLock(&parentEntry->lock);
OBSOLETE     ReleaseWriteLock(&childEntry->lock);
OBSOLETE     free_fs_server_context(&context);
OBSOLETE     cred_free(ce);
OBSOLETE     return ret;
OBSOLETE }
OBSOLETE 
OBSOLETE /*
OBSOLETE  *
OBSOLETE  */
OBSOLETE 
OBSOLETE int reconnect_mkdir(struct vcache *parent, struct vcache *curdir, 
OBSOLETE                     AFSStoreStatus *store_status, char *name)
OBSOLETE {
OBSOLETE     ConnCacheEntry *conn; 
OBSOLETE     fs_server_context context;
OBSOLETE     CredCacheEntry *ce;
OBSOLETE     VenusFid *parent_fid;
OBSOLETE     VenusFid *child_fid;
OBSOLETE     VenusFid fakeFid;
OBSOLETE 
OBSOLETE     FCacheEntry *parentEntry, *childEntry, *tempEntry, *tempparEntry;
OBSOLETE     Result tempres;
OBSOLETE     int    ret = 0;
OBSOLETE     int    tempret = 0;
OBSOLETE     struct timeval tv;
OBSOLETE     char tmp[2 * sizeof(int) + 2];
OBSOLETE 
OBSOLETE     AFSFid  Outfid;   /* Ba Wu: These are used to get the info from FS*/
OBSOLETE     AFSFetchStatus fetch_attr;
OBSOLETE     AFSFetchStatus status;
OBSOLETE     AFSCallBack  callback;
OBSOLETE     AFSVolSync   volsync;
OBSOLETE     fcache_cache_handle cache_handle;
OBSOLETE     int32_t type;
OBSOLETE 
OBSOLETE     parent_fid = &(parent->fid); /* points to the VenusFid structure */
OBSOLETE     child_fid = &(curdir->fid);
OBSOLETE     fakeFid = *child_fid;
OBSOLETE 
OBSOLETE     parent_fid = fid_translate(parent_fid);
OBSOLETE 
OBSOLETE     ce = cred_get (parent->fid.Cell, parent->cred.pag, CRED_ANY);
OBSOLETE     assert (ce != NULL);
OBSOLETE 
OBSOLETE     ret = fcache_find (&parentEntry, *parent_fid);
OBSOLETE     assert (ret == 0);
OBSOLETE 
OBSOLETE     tempparEntry = parentEntry;
OBSOLETE 
OBSOLETE /*Ba ba: used to check whether name can be find  Deleted !!!
OBSOLETE   ReleaseWriteLock(&parentEntry->lock);
OBSOLETE   tempret = adir_lookup (parentEntry->fid , name , &foo_fid , NULL, ce);  */
OBSOLETE /*Ba ba: used to check whether name can be find  Deleted !!! */
OBSOLETE 
OBSOLETE     /*Ba Wu Remove the dir name from itsparent dir */
OBSOLETE     tempret = adir_remove(parentEntry,name);  
OBSOLETE     conn = find_first_fs (parentEntry, ce, &context);
OBSOLETE     if (conn == NULL) {
OBSOLETE 	arla_log (ADEBDISCONN,"Cannot make this connection");
OBSOLETE 	ReleaseWriteLock(&parentEntry->lock);
OBSOLETE 	ReleaseWriteLock(&childEntry->lock);
OBSOLETE 	cred_free(ce);
OBSOLETE 	return ENETDOWN;
OBSOLETE     }
OBSOLETE 
OBSOLETE     ret = fcache_find(&childEntry, *child_fid);/*Ba Wu: remove the newly created dir */
OBSOLETE     assert (ret == 0);
OBSOLETE 
OBSOLETE     recon_hashtabdel(childEntry);
OBSOLETE 
OBSOLETE     alloc_fid_trans(&childEntry->fid);
OBSOLETE 
OBSOLETE     gettimeofday(&tv, NULL);
OBSOLETE 
OBSOLETE     ret = RXAFS_MakeDir (conn->connection,
OBSOLETE 			 &parentEntry->fid.fid,
OBSOLETE 			 name,
OBSOLETE 			 store_status, 
OBSOLETE 			 &Outfid,
OBSOLETE 			 &fetch_attr,
OBSOLETE 			 &status,
OBSOLETE 			 &callback,
OBSOLETE 			 &volsync);
OBSOLETE 
OBSOLETE     if (ret) {
OBSOLETE 	arla_log (ADEBDISCONN, "Could not CreateFile: %s (%d)",
OBSOLETE 		  koerr_gettext(ret), ret);
OBSOLETE 	goto out;
OBSOLETE     }
OBSOLETE 
OBSOLETE     parentEntry->status   = status;
OBSOLETE     parentEntry->callback = callback;
OBSOLETE     parentEntry->callback.ExpirationTime += tv.tv_sec;
OBSOLETE     parentEntry->volsync  = volsync;
OBSOLETE 
OBSOLETE     childEntry->fid.Cell = parentEntry->fid.Cell;
OBSOLETE     childEntry->fid.fid = Outfid;
OBSOLETE     childEntry->status = fetch_attr;
OBSOLETE     childEntry->flags.attrp = TRUE;
OBSOLETE     childEntry->flags.kernelp = TRUE;
OBSOLETE     childEntry->flags.datap = TRUE;
OBSOLETE     childEntry->tokens |= NNPFS_ATTR_R | NNPFS_DATA_R | NNPFS_DATA_W;
OBSOLETE 
OBSOLETE     fill_fid_trans(&childEntry->fid);
OBSOLETE 
OBSOLETE     ret = volcache_getbyid (childEntry->fid.fid.Volume,
OBSOLETE 			    childEntry->fid.Cell,
OBSOLETE 			    ce,
OBSOLETE 			    &childEntry->volume,
OBSOLETE 			    &type);
OBSOLETE 
OBSOLETE     recon_hashtabadd(childEntry);
OBSOLETE 
OBSOLETE /*Ba ba: Need to change later!!! */
OBSOLETE #if 0
OBSOLETE     ReleaseWriteLock(&tempparEntry->lock);
OBSOLETE     tempret = adir_changefid (tempparEntry->fid ,name, &Outfid,  ce);
OBSOLETE     ReleaseWriteLock(&tempparEntry->lock);
OBSOLETE     tempret = adir_lookup (tempparEntry->fid ,name, &foo_fid, NULL, ce);
OBSOLETE #endif
OBSOLETE 
OBSOLETE     tempret = adir_creat (parentEntry, name, childEntry->fid.fid); 
OBSOLETE 
OBSOLETE     childEntry->host = rx_HostOf (rx_PeerOf (conn->connection));
OBSOLETE     assert(childEntry->host);
OBSOLETE 
OBSOLETE     reconnect_update_fid(childEntry, fakeFid);
OBSOLETE      
OBSOLETE     tempres = conv_dir(parentEntry, ce, 0, &cache_handle,
OBSOLETE 		       tmp, sizeof(tmp));
OBSOLETE 
OBSOLETE     ReleaseWriteLock(&childEntry->lock);
OBSOLETE 
OBSOLETE     /*SWW Qiyue 29: This should be deleted later */                      
OBSOLETE     ret = fcache_find (&tempEntry, childEntry->fid);  
OBSOLETE 
OBSOLETE     assert (ret == 0);
OBSOLETE     ReleaseWriteLock(&tempEntry->lock);
OBSOLETE 
OBSOLETE  out:
OBSOLETE 
OBSOLETE     ReleaseWriteLock(&parentEntry->lock);
OBSOLETE     ReleaseWriteLock(&childEntry->lock);
OBSOLETE     free_fs_server_context(&context);
OBSOLETE     cred_free(ce);
OBSOLETE     return ret;
OBSOLETE }
OBSOLETE 
OBSOLETE /*
OBSOLETE  *
OBSOLETE  */
OBSOLETE 
OBSOLETE int reconnect_link(struct vcache *parent, struct vcache *existing,
OBSOLETE 		   char *name)
OBSOLETE {
OBSOLETE     ConnCacheEntry *conn;
OBSOLETE     fs_server_context context;
OBSOLETE     CredCacheEntry *ce;
OBSOLETE     VenusFid *parent_fid;  
OBSOLETE     VenusFid *existing_fid;
OBSOLETE     char tmp[2 * sizeof(int) + 2];
OBSOLETE     int ret = 0;
OBSOLETE     FCacheEntry *dir_entry,*existing_entry;
OBSOLETE     Result res;
OBSOLETE 
OBSOLETE     AFSFetchStatus new_status;
OBSOLETE     AFSFetchStatus status;
OBSOLETE     AFSVolSync volsync;
OBSOLETE     fcache_cache_handle cache_handle;
OBSOLETE 
OBSOLETE 
OBSOLETE     parent_fid = &(parent->fid);
OBSOLETE     existing_fid = &(existing->fid);
OBSOLETE 
OBSOLETE     parent_fid = fid_translate(parent_fid);
OBSOLETE 
OBSOLETE     ce = cred_get (parent->fid.Cell, parent->cred.pag, CRED_ANY);
OBSOLETE     assert (ce != NULL);
OBSOLETE 
OBSOLETE     ret = fcache_find (&dir_entry, *parent_fid);
OBSOLETE     assert (ret == 0);
OBSOLETE 
OBSOLETE     ret = fcache_find (&existing_entry, *existing_fid);
OBSOLETE     assert (ret == 0);
OBSOLETE 
OBSOLETE     conn = find_first_fs (dir_entry, ce, &context);
OBSOLETE     if (conn == NULL) {
OBSOLETE 	arla_log (ADEBDISCONN,"Cannot make this connection");
OBSOLETE 	ReleaseWriteLock(&dir_entry->lock);
OBSOLETE 	ReleaseWriteLock(&existing_entry->lock);
OBSOLETE 	cred_free(ce);
OBSOLETE 	return ENETDOWN;
OBSOLETE     }
OBSOLETE 
OBSOLETE     ret = RXAFS_Link (conn->connection,
OBSOLETE 		      &dir_entry->fid.fid,
OBSOLETE 		      name,
OBSOLETE 		      &existing_entry->fid.fid,
OBSOLETE 		      &new_status,
OBSOLETE 		      &status,
OBSOLETE 		      &volsync);
OBSOLETE     if (ret) {
OBSOLETE 	arla_warn (ADEBFCACHE, ret, "Link");
OBSOLETE 	goto out;
OBSOLETE     }
OBSOLETE 
OBSOLETE     dir_entry->status  = status;
OBSOLETE     dir_entry->volsync = volsync;
OBSOLETE 
OBSOLETE     existing_entry->status = new_status;
OBSOLETE     
OBSOLETE     volcache_update_volsync (dir_entry->volume, dir_entry->volsync);
OBSOLETE 
OBSOLETE     res = conv_dir (dir_entry, ce, 0, &cache_handle, tmp, sizeof(tmp));
OBSOLETE 	
OBSOLETE  out:
OBSOLETE     ReleaseWriteLock(&dir_entry->lock);
OBSOLETE     ReleaseWriteLock(&existing_entry->lock);
OBSOLETE     cred_free(ce);
OBSOLETE     free_fs_server_context (&context);
OBSOLETE     return ret;
OBSOLETE }
OBSOLETE 
OBSOLETE /*
OBSOLETE  *
OBSOLETE  */
OBSOLETE 
OBSOLETE int reconnect_symlink(struct vcache *parent, struct vcache *child,
OBSOLETE 		      AFSStoreStatus *store_attr, char *name, 
OBSOLETE 		      char *contents)
OBSOLETE {
OBSOLETE     ConnCacheEntry *conn;
OBSOLETE     fs_server_context context;
OBSOLETE     CredCacheEntry *ce;
OBSOLETE     VenusFid *parent_fid, *child_fid, fakeFid;
OBSOLETE     char tmp[2 * sizeof(int) + 2];
OBSOLETE     int ret = 0;
OBSOLETE     FCacheEntry *dir_entry, *childEntry;
OBSOLETE     Result res;
OBSOLETE 
OBSOLETE     AFSFetchStatus fetch_attr, new_status;
OBSOLETE     AFSVolSync volsync;
OBSOLETE     fcache_cache_handle cache_handle;
OBSOLETE     int32_t type;
OBSOLETE 
OBSOLETE     parent_fid = &(parent->fid);
OBSOLETE     child_fid  = &(child->fid);
OBSOLETE     fakeFid    = *child_fid;
OBSOLETE     parent_fid = fid_translate(parent_fid);
OBSOLETE 
OBSOLETE     ce = cred_get (parent->fid.Cell, parent->cred.pag, CRED_ANY);
OBSOLETE     assert (ce != NULL);
OBSOLETE 
OBSOLETE     ret = fcache_find (&dir_entry, *parent_fid);
OBSOLETE     assert (ret == 0);
OBSOLETE 
OBSOLETE     adir_remove(dir_entry,name);
OBSOLETE 
OBSOLETE     ret = fcache_find (&childEntry, *child_fid);
OBSOLETE     assert (ret == 0);
OBSOLETE 
OBSOLETE     recon_hashtabdel(childEntry);
OBSOLETE 
OBSOLETE     assert(ret==0);
OBSOLETE     conn = find_first_fs (dir_entry, ce, &context);
OBSOLETE     if (conn == NULL) {
OBSOLETE 	arla_log (ADEBDISCONN,"Cannot make this connection");
OBSOLETE 	ReleaseWriteLock(&dir_entry->lock);
OBSOLETE 	ReleaseWriteLock(&childEntry->lock);
OBSOLETE 	cred_free(ce);
OBSOLETE 	return ENOMEM;
OBSOLETE     }
OBSOLETE   
OBSOLETE     alloc_fid_trans(&childEntry->fid);
OBSOLETE 
OBSOLETE     ret = RXAFS_Symlink (conn->connection,
OBSOLETE 			 &dir_entry->fid.fid,
OBSOLETE 			 name,
OBSOLETE 			 contents,
OBSOLETE 			 store_attr,
OBSOLETE 			 &(childEntry->fid.fid),
OBSOLETE 			 &fetch_attr,
OBSOLETE 			 &new_status,
OBSOLETE 			 &volsync);
OBSOLETE     if (ret) {
OBSOLETE 	arla_warn (ADEBFCACHE, ret, "Symlink");
OBSOLETE 	goto out;
OBSOLETE     }
OBSOLETE 
OBSOLETE     child_fid->Cell = dir_entry->fid.Cell;
OBSOLETE 
OBSOLETE     fill_fid_trans (&childEntry->fid);
OBSOLETE     ret = volcache_getbyid (childEntry->fid.fid.Volume,
OBSOLETE 			    childEntry->fid.Cell,
OBSOLETE 			    ce,
OBSOLETE 			    &childEntry->volume,
OBSOLETE 			    &type);
OBSOLETE 
OBSOLETE     recon_hashtabadd (childEntry);
OBSOLETE 
OBSOLETE     adir_creat(dir_entry, name, childEntry->fid.fid);
OBSOLETE 
OBSOLETE     childEntry->status = fetch_attr;
OBSOLETE     childEntry->flags.attrp = TRUE;
OBSOLETE     childEntry->flags.kernelp = TRUE;
OBSOLETE     childEntry->tokens |= NNPFS_ATTR_R;
OBSOLETE     volcache_update_volsync (dir_entry->volume, dir_entry->volsync);
OBSOLETE 
OBSOLETE     childEntry->host = rx_HostOf (rx_PeerOf (conn->connection));
OBSOLETE     assert(childEntry->host);
OBSOLETE 
OBSOLETE     reconnect_update_fid(childEntry, fakeFid);
OBSOLETE     res = conv_dir (dir_entry, ce, 0, &cache_handle, tmp, sizeof(tmp));
OBSOLETE 
OBSOLETE  out: 
OBSOLETE     ReleaseWriteLock(&dir_entry->lock);
OBSOLETE     ReleaseWriteLock(&childEntry->lock);
OBSOLETE     free_fs_server_context(&context);
OBSOLETE     cred_free(ce);
OBSOLETE     return ret;
OBSOLETE }
OBSOLETE 
OBSOLETE #endif
@


