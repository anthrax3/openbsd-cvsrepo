head	1.6;
access;
symbols
	OPENBSD_5_2:1.5.0.38
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.36
	OPENBSD_5_0:1.5.0.34
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.32
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.30
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.26
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.5.0.28
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.5.0.24
	OPENBSD_4_5_BASE:1.5
	OPENBSD_4_4:1.5.0.22
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3:1.5.0.20
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.5.0.18
	OPENBSD_4_2_BASE:1.5
	OPENBSD_4_1:1.5.0.16
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.5.0.14
	OPENBSD_4_0_BASE:1.5
	OPENBSD_3_9:1.5.0.12
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.5.0.10
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.8
	OPENBSD_3_7_BASE:1.5
	OPENBSD_3_6:1.5.0.6
	OPENBSD_3_6_BASE:1.5
	OPENBSD_3_5:1.5.0.4
	OPENBSD_3_5_BASE:1.5
	OPENBSD_3_4:1.5.0.2
	OPENBSD_3_4_BASE:1.5
	arla-20030805:1.1.1.3
	OPENBSD_3_3:1.4.0.4
	OPENBSD_3_3_BASE:1.4
	OPENBSD_3_2:1.4.0.2
	OPENBSD_3_2_BASE:1.4
	arla-0-35-7:1.1.1.2
	OPENBSD_3_1:1.3.0.8
	OPENBSD_3_1_BASE:1.3
	OPENBSD_3_0:1.3.0.6
	OPENBSD_3_0_BASE:1.3
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_9:1.3.0.4
	OPENBSD_2_8:1.3.0.2
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.2.0.4
	OPENBSD_2_7_BASE:1.2
	OPENBSD_2_6:1.2.0.2
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.1.1.1.0.4
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.2
	OPENBSD_2_4_BASE:1.1.1.1
	arla-0_9:1.1.1.1
	arla:1.1.1;
locks; strict;
comment	@ * @;


1.6
date	2012.08.23.06.21.50;	author deraadt;	state dead;
branches;
next	1.5;

1.5
date	2003.08.05.08.42.41;	author hin;	state Exp;
branches;
next	1.4;

1.4
date	2002.06.07.04.28.57;	author hin;	state Exp;
branches;
next	1.3;

1.3
date	2000.09.11.14.40.42;	author art;	state Exp;
branches;
next	1.2;

1.2
date	99.04.30.01.59.08;	author art;	state Exp;
branches;
next	1.1;

1.1
date	98.09.14.21.52.56;	author art;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.09.14.21.52.56;	author art;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.06.07.04.14.23;	author hin;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2003.08.05.08.21.01;	author hin;	state Exp;
branches;
next	;


desc
@@


1.6
log
@the afs src tree can go away
@
text
@/*
 * Copyright (c) 1995-2002 Kungliga Tekniska Högskolan
 * (Royal Institute of Technology, Stockholm, Sweden).
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * The interface for the file-cache.
 */

/* $arla: fcache.h,v 1.97 2003/01/10 03:20:42 lha Exp $ */

#ifndef _FCACHE_H_
#define _FCACHE_H_

#include <nnpfs/nnpfs_message.h>
#include <fcntl.h>
#include <cred.h>
#include <heap.h>

/*
 * For each entry in the filecache we save the rights of NACCESS users.
 * The value should be the same as MAXRIGHTS from nnpfs_message.h
 * If it isn't you can get some very strange behavior from nnpfs, so don't
 * even try. XXX
 */ 

#define NACCESS MAXRIGHTS

typedef struct {
     nnpfs_pag_t cred;
     u_long access;
} AccessEntry;

enum Access { ANONE   = 0x0,
              AREAD   = 0x01,
	      AWRITE  = 0x02,
	      AINSERT = 0x04,
	      ALIST   = 0x08,
	      ADELETE = 0x10,
	      ALOCK   = 0x20,
	      AADMIN  = 0x40 };

typedef struct {
    Bool valid;
    nnpfs_cache_handle nnpfs_handle;
} fcache_cache_handle;

typedef struct {
    struct Lock lock;		/* locking information for this entry */
    VenusFid fid;		/* The fid of the file for this entry */
    unsigned refcount;		/* reference count */
    uint32_t host;		/* the source of this entry */
    size_t length;		/* the cache usage size */
    size_t wanted_length;	/* this much data should be fetched */
    size_t fetched_length;	/* this much data has been fetched */
    AFSFetchStatus status;	/* Removed unused stuff later */
    AFSCallBack callback;	/* Callback to the AFS-server */
    AFSVolSync volsync;		/* Sync info for ro-volumes */
    AccessEntry acccache[NACCESS]; /* cache for the access rights */
    uint32_t anonaccess;	/* the access mask for system:anyuser */
    unsigned index;		/* this is V%u */
    fcache_cache_handle handle;	/* handle */
    struct {
	unsigned usedp : 1;	/* Is this entry used? */
	unsigned attrp : 1;	/* Are the attributes in status valid? */
	unsigned attrusedp : 1;	/* Attr is used in the kernel */
	unsigned datausedp : 1;	/* Data is used in the kernel */
	unsigned extradirp : 1;	/* Has this directory been "converted"? */
	unsigned mountp : 1;	/* Is this an AFS mount point? */
	unsigned kernelp : 1;	/* Does this entry exist in the kernel? */
	unsigned sentenced : 1;	/* This entry should die */
	unsigned silly : 1;	/* Instead of silly-rename */
	unsigned fake_mp : 1;	/* a `fake' mount point */
	unsigned vol_root : 1;	/* root of a volume */
    } flags;
    u_int tokens;		/* read/write tokens for the kernel */
    VenusFid parent;
    Listitem *lru_le;		/* lru */
    heap_ptr invalid_ptr;	/* pointer into the heap */
    VolCacheEntry *volume;	/* pointer to the volume entry */
    Bool priority;		/* is the file worth keeping */
    int hits;			/* number of lookups */
    int cleanergen;		/* generation cleaner */
    PollerEntry *poll;		/* poller entry */
    uint32_t disco_id;		/* id in disconncted log */
} FCacheEntry;

/*
 * The fileservers to ask for a particular volume.
 */

struct fs_server_context {
    int i;			/* current number being probed */
    int num_conns;		/* number in `conns' */
    VolCacheEntry *ve;		/*  */
    struct fs_server_entry {
	ConnCacheEntry *conn;	/* rx connection to server */
	int ve_ent;		/* entry in `ve' */
    } conns[NMAXNSERVERS];
};

typedef struct fs_server_context fs_server_context;

/*
 * How far the cleaner will go went cleaning things up.
 */

extern Bool fprioritylevel;

void
fcache_init (u_long alowvnodes,
	     u_long ahighvnodes,
	     int64_t alowbytes,
	     int64_t ahighbytes,
	     Bool recover);

int
fcache_reinit(u_long alowvnodes,
	      u_long ahighvnodes,
	      int64_t alowbytes,
	      int64_t ahighbytes);

void
fcache_purge_volume (VenusFid fid);

void
fcache_purge_host (u_long host);

void
fcache_purge_cred (nnpfs_pag_t cred, int32_t cell);

void
fcache_stale_entry (VenusFid fid, AFSCallBack callback);

void
fcache_invalidate_mp (void);

int
fcache_file_name (FCacheEntry *entry, char *s, size_t len);

int
fcache_conv_file_name (FCacheEntry *entry, char *s, size_t len);

int
fcache_dir_name (FCacheEntry *entry, char *s, size_t len);

int
fcache_extra_file_name (FCacheEntry *entry, char *s, size_t len);

int
fcache_open_file (FCacheEntry *entry, int flag);

int
fcache_open_extra_dir (FCacheEntry *entry, int flag, mode_t mode);

int
fcache_fhget (char *filename, fcache_cache_handle *handle);

int
write_data (FCacheEntry *entry, AFSStoreStatus *status, CredCacheEntry *ce);

int
truncate_file (FCacheEntry *entry, off_t size,
	       AFSStoreStatus *status, CredCacheEntry *ce);

int
write_attr (FCacheEntry *entry, const AFSStoreStatus *status,
	    CredCacheEntry *ce);

int
create_file (FCacheEntry *dir_entry,
	     const char *name, AFSStoreStatus *store_attr,
	     VenusFid *child_fid, AFSFetchStatus *fetch_attr,
	     CredCacheEntry *ce);

int
create_directory (FCacheEntry *dir_entry,
		  const char *name, AFSStoreStatus *store_attr,
		  VenusFid *child_fid, AFSFetchStatus *fetch_attr,
		  CredCacheEntry *ce);

int
create_symlink (FCacheEntry *dir_entry,
		const char *name, AFSStoreStatus *store_attr,
		VenusFid *child_fid, AFSFetchStatus *fetch_attr,
		const char *contents,
		CredCacheEntry *ce);

int
create_link (FCacheEntry *dir_entry,
	     const char *name,
	     FCacheEntry *existing_entry,
	     CredCacheEntry *ce);

int
remove_file (FCacheEntry *dire, const char *name, CredCacheEntry *ce);

int
remove_directory (FCacheEntry *dire, const char *name, CredCacheEntry *ce);

int
rename_file (FCacheEntry *old_dir,
	     const char *old_name,
	     FCacheEntry *new_dir,
	     const char *new_name,
	     CredCacheEntry *ce);

int
getroot (VenusFid *res, CredCacheEntry *ce);

int
fcache_get (FCacheEntry **res, VenusFid fid, CredCacheEntry *ce);

void
fcache_release (FCacheEntry *e);

int
fcache_find (FCacheEntry **res, VenusFid fid);

int
fcache_get_data (FCacheEntry **e, CredCacheEntry **ce,
		 size_t wanted_length);

int
fcache_verify_attr (FCacheEntry *entry, FCacheEntry *parent_entry,
		    const char *prefered_name, CredCacheEntry* ce);

int
fcache_verify_data (FCacheEntry *e, CredCacheEntry *ce);

int
followmountpoint (VenusFid *fid, const VenusFid *parent, FCacheEntry *parent_e,
		  CredCacheEntry **ce);

void
fcache_status (void);

int
fcache_store_state (void);

int
getacl(VenusFid fid, CredCacheEntry *ce,
       AFSOpaque *opaque);

int
setacl(VenusFid fid, CredCacheEntry *ce,
       AFSOpaque *opaque, FCacheEntry **ret);

int
getvolstat(VenusFid fid, CredCacheEntry *ce,
	   AFSFetchVolumeStatus *volstat,
	   char *volumename, size_t volumenamesz,
	   char *offlinemsg,
	   char *motd);

int
setvolstat(VenusFid fid, CredCacheEntry *ce,
	   AFSStoreVolumeStatus *volstat,
	   char *volumename,
	   char *offlinemsg,
	   char *motd);

int64_t
fcache_highbytes(void);

int64_t
fcache_usedbytes(void);

int64_t
fcache_lowbytes(void);

u_long
fcache_highvnodes(void);

u_long
fcache_usedvnodes(void);

u_long
fcache_lowvnodes(void);

int
fcache_need_bytes(u_long needed);

Bool
fcache_need_nodes (void);

int
fcache_giveup_all_callbacks (void);

int
fcache_reobtain_callbacks (struct nnpfs_cred *cred);

/* XXX - this shouldn't be public, but getrights in inter.c needs it */
int
read_attr (FCacheEntry *, CredCacheEntry *);

Bool
findaccess (nnpfs_pag_t cred, AccessEntry *ae, AccessEntry **pos);

void
fcache_unused(FCacheEntry *entry);

void
fcache_update_length (FCacheEntry *entry, size_t len, size_t have_len);

int
init_fs_context (FCacheEntry *e,
		 CredCacheEntry *ce,
		 fs_server_context *context);

ConnCacheEntry *
find_first_fs (fs_server_context *context);

ConnCacheEntry *
find_next_fs (fs_server_context *context,
	      ConnCacheEntry *prev_conn,
	      int mark_as_dead);

void
free_fs_server_context (fs_server_context *context);

void
recon_hashtabadd(FCacheEntry *entry);
 
void
recon_hashtabdel(FCacheEntry *entry);

int
fcache_get_fbuf (FCacheEntry *centry, int *fd, fbuf *fbuf,
		 int open_flags, int fbuf_flags);

int64_t
fcache_calculate_usage (void);

const VenusFid *
fcache_realfid (const FCacheEntry *entry);

void
fcache_mark_as_mountpoint (FCacheEntry *entry);

const char *
fcache_getdefsysname (void);

int
fcache_addsysname (const char *sysname);

int
fcache_removesysname (const char *sysname);

int
fcache_setdefsysname (const char *sysname);

int
fs_probe (struct rx_connection *conn);

#endif /* _FCACHE_H_ */
@


1.5
log
@Merge
@
text
@@


1.4
log
@merge
@
text
@d2 1
a2 1
 * Copyright (c) 1995-2000 Kungliga Tekniska Högskolan
d38 1
a38 1
/* $KTH: fcache.h,v 1.72.2.2 2001/10/02 16:13:07 jimmy Exp $ */
d43 1
a43 1
#include <xfs/xfs_message.h>
d50 2
a51 2
 * The value should be the same as MAXRIGHTS from xfs_message.h
 * If it isn't you can get some very strange behavior from xfs, so don't
d58 1
a58 1
     xfs_pag_t cred;
d73 1
a73 1
    xfs_cache_handle xfs_handle;
d80 4
a83 2
    u_int32_t host;		/* the source of this entry */
    size_t length;		/* length of our cached copy */
d88 1
a88 1
    u_int32_t anonaccess;	/* the access mask for system:anyuser */
a93 1
	unsigned datap : 1;	/* Is the cache-file valid? */
d112 2
a120 1
    ConnCacheEntry *conns[NMAXNSERVERS];
d123 5
a132 14
 * This is magic cookie for the dump of the fcache.
 * It's supposed not to be able to be confused with an old-style
 * dump (with no header)
 */

#define FCACHE_MAGIC_COOKIE	0xff1201ff

/*
 * current version number of the dump file
 */

#define FCACHE_VERSION		0x2

/*
d141 2
a142 2
	     u_long alowbytes,
	     u_long ahighbytes,
d148 2
a149 2
	      u_long alowbytes,
	      u_long ahighbytes);
d158 1
a158 1
fcache_purge_cred (xfs_pag_t cred, int32_t cell);
d163 3
d170 3
a178 3
fcache_create_file (FCacheEntry *entry);

int
d191 2
a192 1
truncate_file (FCacheEntry *entry, off_t size, CredCacheEntry *ce);
d249 2
a250 1
fcache_get_data (FCacheEntry **res, VenusFid *fid, CredCacheEntry **ce);
d280 1
a280 1
	   char *volumename,
d291 1
a291 1
u_long
d294 1
a294 1
u_long
d297 1
a297 1
u_long
d319 1
a319 1
fcache_reobtain_callbacks (void);
d326 1
a326 1
findaccess (xfs_pag_t cred, AccessEntry *ae, AccessEntry **pos);
d332 6
a337 1
fcache_update_length (FCacheEntry *entry, size_t len);
d340 1
a340 3
find_first_fs (FCacheEntry *e,
	       CredCacheEntry *ce,
	       fs_server_context *context);
d360 1
a360 1
u_long
d369 9
d379 1
a379 1
collectstats_hostpart(u_int32_t *host, u_int32_t *part, int *n);
d382 1
a382 3
collectstats_getentry(u_int32_t host, u_int32_t part, u_int32_t type,
		      u_int32_t items_slot, u_int32_t *count,
		      int64_t *items_total, int64_t *total_time);
@


1.3
log
@New Arla userland from Arla between 0.34.2 and current in arla cvs.
Too many new features and fixes to mention here.
@
text
@d17 1
a17 6
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by the Kungliga Tekniska
 *      Högskolan and its contributors.
 * 
 * 4. Neither the name of the Institute nor the names of its contributors
d38 1
a38 1
/* $Id: fcache.h,v 1.68 2000/06/05 02:15:22 assar Exp $ */
d72 5
d88 1
a88 1
    xfs_cache_handle handle;	/* handle */
d189 1
a189 1
fcache_fhget (char *filename, xfs_cache_handle *handle);
d262 2
a263 1
followmountpoint (VenusFid *fid, const VenusFid *parent, CredCacheEntry **ce);
d300 3
d308 3
d364 11
@


1.2
log
@upgrade Arla to fresher code. Too many new features and bugfixes.
@
text
@a0 1
/*	$OpenBSD$	*/
d2 1
a2 1
 * Copyright (c) 1995, 1996, 1997, 1998 Kungliga Tekniska Högskolan
d43 1
a43 1
/* $KTH: fcache.h,v 1.49 1999/04/14 15:27:35 map Exp $ */
d63 1
a63 1
     pag_t cred;
a75 12
/*
 * Keep the necessary state with traversing mount points.
 * Might want to make this per-user/per-process in some distant future.
 */

struct mp_traversal {
    VenusFid parent;		/* the point where the traversal started */
    unsigned refcount;
};

typedef struct mp_traversal mp_traversal;

d81 1
d99 3
a103 3
#if 0
    mp_traversal *mp_traversal;	/* valid iff flags.mountp */
#endif
a104 1
    VenusFid realfid;		/* Real fid (mountpoints) */
a105 3
#if 0
    Listitem *invalid_le;	/* invalidation list */
#else
a106 1
#endif
d108 3
a110 1
    unsigned priority;		/* the priority of keeping the file 0-100 */
d126 14
d143 1
a143 1
extern unsigned fprioritylevel;
d165 1
a165 1
fcache_purge_cred (pag_t cred, int32_t cell);
d174 3
d252 1
a252 1
fcache_get_attr (FCacheEntry *e, CredCacheEntry *ce);
d255 2
a256 1
fcache_get_data (FCacheEntry *e, CredCacheEntry *ce);
d259 4
a262 1
followmountpoint (VenusFid *fid, VenusFid *parent, CredCacheEntry **ce);
d276 1
a276 1
       AFSOpaque *opaque);
d305 6
d321 1
a321 1
findaccess (pag_t cred, AccessEntry *ae, AccessEntry **pos);
d335 3
a337 1
find_next_fs (fs_server_context *context, ConnCacheEntry *prev_conn);
d341 16
@


1.1
log
@Initial revision
@
text
@d44 1
a44 1
/* $KTH: fcache.h,v 1.37 1998/07/22 07:02:04 assar Exp $ */
d52 1
d77 12
d93 1
a93 1
    u_long host;		/* the source of this entry */
d98 3
a100 2
    u_long anonaccess;		/* the access mask for system:anyuser */
    ino_t inode;		/* right now only an index */
d110 1
d113 4
a116 1
    VenusFid parent;		/* fid of the parent */
d119 1
d121 3
d128 11
d178 4
a181 1
fcache_open_file (FCacheEntry *entry, int flag, mode_t mode);
d187 4
a190 1
write_data (FCacheEntry *entry, CredCacheEntry *ce);
d243 3
d259 1
a259 1
fcache_status (FILE *f);
d286 17
d310 17
@


1.1.1.1
log
@Initial version of Arla, a free implementation of an AFS cache-manager.
(second try, hopefully into the correct repository this time)
@
text
@@


1.1.1.2
log
@Import of arla-0.35.7
@
text
@d1 1
d3 1
a3 1
 * Copyright (c) 1995-2000 Kungliga Tekniska Högskolan
d18 6
a23 1
 * 3. Neither the name of the Institute nor the names of its contributors
d44 1
a44 1
/* $KTH: fcache.h,v 1.72.2.2 2001/10/02 16:13:07 jimmy Exp $ */
a51 1
#include <heap.h>
d63 1
a63 1
     xfs_pag_t cred;
a76 5
    Bool valid;
    xfs_cache_handle xfs_handle;
} fcache_cache_handle;

typedef struct {
d80 1
a80 2
    u_int32_t host;		/* the source of this entry */
    size_t length;		/* length of our cached copy */
d85 2
a86 3
    u_int32_t anonaccess;	/* the access mask for system:anyuser */
    unsigned index;		/* this is V%u */
    fcache_cache_handle handle;	/* handle */
a95 4
	unsigned sentenced : 1;	/* This entry should die */
	unsigned silly : 1;	/* Instead of silly-rename */
	unsigned fake_mp : 1;	/* a `fake' mount point */
	unsigned vol_root : 1;	/* root of a volume */
d98 2
a99 1
    VenusFid parent;
d101 1
a101 1
    heap_ptr invalid_ptr;	/* pointer into the heap */
d103 1
a103 3
    Bool priority;		/* is the file worth keeping */
    int hits;			/* number of lookups */
    int cleanergen;		/* generation cleaner */
a105 25
/*
 * The fileservers to ask for a particular volume.
 */

struct fs_server_context {
    ConnCacheEntry *conns[NMAXNSERVERS];
    int i;			/* current number being probed */
    int num_conns;		/* number in `conns' */
};

typedef struct fs_server_context fs_server_context;

/*
 * This is magic cookie for the dump of the fcache.
 * It's supposed not to be able to be confused with an old-style
 * dump (with no header)
 */

#define FCACHE_MAGIC_COOKIE	0xff1201ff

/*
 * current version number of the dump file
 */

#define FCACHE_VERSION		0x2
d111 1
a111 1
extern Bool fprioritylevel;
d133 1
a133 1
fcache_purge_cred (xfs_pag_t cred, int32_t cell);
a141 3
fcache_dir_name (FCacheEntry *entry, char *s, size_t len);

int
d145 1
a145 4
fcache_create_file (FCacheEntry *entry);

int
fcache_open_file (FCacheEntry *entry, int flag);
d151 1
a151 4
fcache_fhget (char *filename, fcache_cache_handle *handle);

int
write_data (FCacheEntry *entry, AFSStoreStatus *status, CredCacheEntry *ce);
a203 3
void
fcache_release (FCacheEntry *e);

d208 1
a208 1
fcache_get_data (FCacheEntry **res, VenusFid *fid, CredCacheEntry **ce);
d211 1
a211 2
fcache_verify_attr (FCacheEntry *entry, FCacheEntry *parent_entry,
		    const char *prefered_name, CredCacheEntry* ce);
d214 1
a214 5
fcache_verify_data (FCacheEntry *e, CredCacheEntry *ce);

int
followmountpoint (VenusFid *fid, const VenusFid *parent, FCacheEntry *parent_e,
		  CredCacheEntry **ce);
d217 1
a217 1
fcache_status (void);
d228 1
a228 1
       AFSOpaque *opaque, FCacheEntry **ret);
a243 29
u_long
fcache_highbytes(void);

u_long
fcache_usedbytes(void);

u_long
fcache_lowbytes(void);

u_long
fcache_highvnodes(void);

u_long
fcache_usedvnodes(void);

u_long
fcache_lowvnodes(void);

int
fcache_need_bytes(u_long needed);

Bool
fcache_need_nodes (void);

int
fcache_giveup_all_callbacks (void);

int
fcache_reobtain_callbacks (void);
d250 1
a250 47
findaccess (xfs_pag_t cred, AccessEntry *ae, AccessEntry **pos);

void
fcache_unused(FCacheEntry *entry);

void
fcache_update_length (FCacheEntry *entry, size_t len);

ConnCacheEntry *
find_first_fs (FCacheEntry *e,
	       CredCacheEntry *ce,
	       fs_server_context *context);

ConnCacheEntry *
find_next_fs (fs_server_context *context,
	      ConnCacheEntry *prev_conn,
	      int mark_as_dead);

void
free_fs_server_context (fs_server_context *context);

void
recon_hashtabadd(FCacheEntry *entry);
 
void
recon_hashtabdel(FCacheEntry *entry);

int
fcache_get_fbuf (FCacheEntry *centry, int *fd, fbuf *fbuf,
		 int open_flags, int fbuf_flags);

u_long
fcache_calculate_usage (void);

const VenusFid *
fcache_realfid (const FCacheEntry *entry);

void
fcache_mark_as_mountpoint (FCacheEntry *entry);

int
collectstats_hostpart(u_int32_t *host, u_int32_t *part, int *n);

int
collectstats_getentry(u_int32_t host, u_int32_t part, u_int32_t type,
		      u_int32_t items_slot, u_int32_t *count,
		      int64_t *items_total, int64_t *total_time);
@


1.1.1.3
log
@Import of arla -current as of Aug 5 2003

ok todd@@ deraadt@@
@
text
@d2 1
a2 1
 * Copyright (c) 1995-2002 Kungliga Tekniska Högskolan
d38 1
a38 1
/* $arla: fcache.h,v 1.97 2003/01/10 03:20:42 lha Exp $ */
d43 1
a43 1
#include <nnpfs/nnpfs_message.h>
d50 2
a51 2
 * The value should be the same as MAXRIGHTS from nnpfs_message.h
 * If it isn't you can get some very strange behavior from nnpfs, so don't
d58 1
a58 1
     nnpfs_pag_t cred;
d73 1
a73 1
    nnpfs_cache_handle nnpfs_handle;
d80 2
a81 4
    uint32_t host;		/* the source of this entry */
    size_t length;		/* the cache usage size */
    size_t wanted_length;	/* this much data should be fetched */
    size_t fetched_length;	/* this much data has been fetched */
d86 1
a86 1
    uint32_t anonaccess;	/* the access mask for system:anyuser */
d92 1
a110 2
    PollerEntry *poll;		/* poller entry */
    uint32_t disco_id;		/* id in disconncted log */
d118 1
a120 5
    VolCacheEntry *ve;		/*  */
    struct fs_server_entry {
	ConnCacheEntry *conn;	/* rx connection to server */
	int ve_ent;		/* entry in `ve' */
    } conns[NMAXNSERVERS];
d126 14
d148 2
a149 2
	     int64_t alowbytes,
	     int64_t ahighbytes,
d155 2
a156 2
	      int64_t alowbytes,
	      int64_t ahighbytes);
d165 1
a165 1
fcache_purge_cred (nnpfs_pag_t cred, int32_t cell);
a169 3
void
fcache_invalidate_mp (void);

d174 1
a174 1
fcache_conv_file_name (FCacheEntry *entry, char *s, size_t len);
d177 1
a177 1
fcache_dir_name (FCacheEntry *entry, char *s, size_t len);
d180 1
a180 1
fcache_extra_file_name (FCacheEntry *entry, char *s, size_t len);
d195 1
a195 2
truncate_file (FCacheEntry *entry, off_t size,
	       AFSStoreStatus *status, CredCacheEntry *ce);
d252 1
a252 2
fcache_get_data (FCacheEntry **e, CredCacheEntry **ce,
		 size_t wanted_length);
d282 1
a282 1
	   char *volumename, size_t volumenamesz,
d293 1
a293 1
int64_t
d296 1
a296 1
int64_t
d299 1
a299 1
int64_t
d321 1
a321 1
fcache_reobtain_callbacks (struct nnpfs_cred *cred);
d328 1
a328 1
findaccess (nnpfs_pag_t cred, AccessEntry *ae, AccessEntry **pos);
d334 1
a334 6
fcache_update_length (FCacheEntry *entry, size_t len, size_t have_len);

int
init_fs_context (FCacheEntry *e,
		 CredCacheEntry *ce,
		 fs_server_context *context);
d337 3
a339 1
find_first_fs (fs_server_context *context);
d359 1
a359 1
int64_t
a367 9
const char *
fcache_getdefsysname (void);

int
fcache_addsysname (const char *sysname);

int
fcache_removesysname (const char *sysname);

d369 1
a369 1
fcache_setdefsysname (const char *sysname);
d372 3
a374 1
fs_probe (struct rx_connection *conn);
@


