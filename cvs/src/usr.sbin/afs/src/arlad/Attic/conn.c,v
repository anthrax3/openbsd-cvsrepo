head	1.7;
access;
symbols
	OPENBSD_5_2:1.6.0.36
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.34
	OPENBSD_5_0:1.6.0.32
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.30
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.6.0.28
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.6.0.24
	OPENBSD_4_7_BASE:1.6
	OPENBSD_4_6:1.6.0.26
	OPENBSD_4_6_BASE:1.6
	OPENBSD_4_5:1.6.0.22
	OPENBSD_4_5_BASE:1.6
	OPENBSD_4_4:1.6.0.20
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3:1.6.0.18
	OPENBSD_4_3_BASE:1.6
	OPENBSD_4_2:1.6.0.16
	OPENBSD_4_2_BASE:1.6
	OPENBSD_4_1:1.6.0.14
	OPENBSD_4_1_BASE:1.6
	OPENBSD_4_0:1.6.0.12
	OPENBSD_4_0_BASE:1.6
	OPENBSD_3_9:1.6.0.10
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.6.0.8
	OPENBSD_3_8_BASE:1.6
	OPENBSD_3_7:1.6.0.6
	OPENBSD_3_7_BASE:1.6
	OPENBSD_3_6:1.6.0.4
	OPENBSD_3_6_BASE:1.6
	OPENBSD_3_5:1.6.0.2
	OPENBSD_3_5_BASE:1.6
	OPENBSD_3_4:1.5.0.2
	OPENBSD_3_4_BASE:1.5
	arla-20030805:1.1.1.3
	OPENBSD_3_3:1.4.0.4
	OPENBSD_3_3_BASE:1.4
	OPENBSD_3_2:1.4.0.2
	OPENBSD_3_2_BASE:1.4
	arla-0-35-7:1.1.1.2
	OPENBSD_3_1:1.3.0.8
	OPENBSD_3_1_BASE:1.3
	OPENBSD_3_0:1.3.0.6
	OPENBSD_3_0_BASE:1.3
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_9:1.3.0.4
	OPENBSD_2_8:1.3.0.2
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.2.0.4
	OPENBSD_2_7_BASE:1.2
	OPENBSD_2_6:1.2.0.2
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.1.1.1.0.4
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.2
	OPENBSD_2_4_BASE:1.1.1.1
	arla-0_9:1.1.1.1
	arla:1.1.1;
locks; strict;
comment	@ * @;


1.7
date	2012.08.23.06.21.50;	author deraadt;	state dead;
branches;
next	1.6;

1.6
date	2003.12.16.20.13.55;	author beck;	state Exp;
branches;
next	1.5;

1.5
date	2003.08.05.08.42.41;	author hin;	state Exp;
branches;
next	1.4;

1.4
date	2002.06.07.04.28.57;	author hin;	state Exp;
branches;
next	1.3;

1.3
date	2000.09.11.14.40.41;	author art;	state Exp;
branches;
next	1.2;

1.2
date	99.04.30.01.59.07;	author art;	state Exp;
branches;
next	1.1;

1.1
date	98.09.14.21.52.55;	author art;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.09.14.21.52.55;	author art;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.06.07.04.14.22;	author hin;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2003.08.05.08.21.00;	author hin;	state Exp;
branches;
next	;


desc
@@


1.7
log
@the afs src tree can go away
@
text
@/*
 * Copyright (c) 1995 - 2002 Kungliga Tekniska Högskolan
 * (Royal Institute of Technology, Stockholm, Sweden).
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * Cache of connections
 */


#include "arla_local.h"
#ifdef RCSID
RCSID("$arla: conn.c,v 1.75 2003/06/10 04:23:20 lha Exp $") ;
#endif

#define CONNCACHESIZE 101

#define CONNFREELISTINC 17

/* Hashtable of connections */
static Hashtab *connhtab;

/* A list with free connections */
static List *connfreelist;

/* # of connections */
static unsigned nconnections;

/* # of active connections */
static unsigned nactive_connections;

/* List of connections to probe */
static List *connprobelist;

#ifdef KERBEROS
int conn_rxkad_level = rxkad_auth;
#endif

/*
 * Functions for handling entries into the connection cache.
 */

static int
conncmp (void *a, void *b)
{
    ConnCacheEntry *c1 = (ConnCacheEntry*)a;
    ConnCacheEntry *c2 = (ConnCacheEntry*)b;

    return  c1->cred          != c2->cred
	|| c1->host          != c2->host
	|| c1->service       != c2->service
	|| c1->port          != c2->port
	|| c1->securityindex != c2->securityindex;
}

static unsigned int
connhash (void *a)
{
    ConnCacheEntry *c = (ConnCacheEntry*)a;

    return c->cred + c->host + c->service + c->port + c->securityindex;
}

/* 2^MAX_RETRIES is the maximum number of seconds between probes */

#define MAX_RETRIES 8

/*
 * Add this entry again to the probe list but without restarting ntries.
 */

static void
re_probe (ConnCacheEntry *e)
{
    Listitem *item;
    struct timeval tv;

    assert (e->probe != NULL);

    gettimeofday (&tv, NULL);
    if (e->probe_le) {
	listdel (connprobelist, e->probe_le);
	e->probe_next = min(tv.tv_sec + (1 << e->ntries), e->probe_next);
    } else
	e->probe_next = tv.tv_sec + (1 << e->ntries);

    if (e->ntries <= MAX_RETRIES)
	++e->ntries;

    for (item = listhead (connprobelist);
	 item;
	 item = listnext (connprobelist, item)) {
	ConnCacheEntry *this = (ConnCacheEntry *)listdata (item);

	if (e->probe_next < this->probe_next) {
	    e->probe_le = listaddbefore (connprobelist, item, e);
	    LWP_NoYieldSignal (connprobelist);
	    return;
	}
    }
    e->probe_le = listaddtail (connprobelist, e);
    LWP_NoYieldSignal (connprobelist);
}

/*
 * Initial add to probe list.
 */

static void
add_to_probe_list (ConnCacheEntry *e, int ntries)
{
    e->ntries = ntries;
    re_probe (e);
}

/*
 *
 */

#define PINGER_STACKSIZE (16*1024)


static PROCESS pinger_pid;

/*
 * Loop waiting for things servers to probe.
 */

static void
pinger (char *arg)
{
    for (;;) {
	struct timeval tv;
	Listitem *item;
	ConnCacheEntry *e;
	struct in_addr addr;
	const char *port_str;

	arla_warnx(ADEBCONN, "running pinger");

	while (listemptyp (connprobelist))
	    LWP_WaitProcess (connprobelist);

	item = listhead (connprobelist);
	e = (ConnCacheEntry *)listdata (item);

	assert (e->probe_le == item);

	gettimeofday (&tv, NULL);
	if (tv.tv_sec < e->probe_next) {
	    unsigned long t = e->probe_next - tv.tv_sec;

	    arla_warnx(ADEBCONN,
		       "pinger: sleeping %lu second(s)", t);
	    IOMGR_Sleep (t);
	    continue;
	}

	listdel (connprobelist, item);
	e->probe_le = NULL;

	if (e->flags.alivep)
	    continue;

	addr.s_addr = e->host;
	port_str    = ports_num2name (e->port);

	if (port_str != NULL)
	    arla_warnx (ADEBCONN, "pinger: probing %s/%s",
			inet_ntoa(addr), port_str);
	else
	    arla_warnx (ADEBCONN, "pinger: probing %s/%d",
			inet_ntoa(addr), e->port);
	++e->refcount;
	if (e->probe == NULL)
	    arla_warnx(ADEBWARN, "pinger: probe function is NULL, "
		       "host: %s cell: %d port: %d",
		       inet_ntoa(addr), e->cell, e->port);

	if (connected_mode == DISCONNECTED) {
	    arla_warnx(ADEBCONN, "pinger: ignoring host in disconnected mode");
	} else if (e->probe && ((*(e->probe))(e->connection) == 0)) {
	    conn_alive (e);
	} else {
	    re_probe (e);
	}

	conn_free (e);
    }
}

/*
 * Create `n' ConnCacheEntry's and add them to `connfreelist'
 */

static void
create_new_connections (unsigned n)
{
     unsigned i;
     ConnCacheEntry *entries;

     entries = (ConnCacheEntry*)calloc (n, sizeof (ConnCacheEntry));
     if (entries == NULL)
	 arla_errx (1, ADEBERROR, "conncache: calloc failed");
     for (i = 0; i < n; ++i) {
	  entries[i].connection = NULL;
	  entries[i].refcount   = 0;
	  entries[i].parent     = NULL;
	  entries[i].probe_le	= NULL;
	  listaddhead (connfreelist, &entries[i]);
     }
     nconnections += n;
}

/* 
 * Initialize the connection cache.
 */

void
conn_init (unsigned nentries)
{
     arla_warnx (ADEBCONN, "initconncache");

     connhtab = hashtabnew (CONNCACHESIZE, conncmp, connhash);
     if (connhtab == NULL)
	 arla_errx (1, ADEBERROR, "conn_init: hashtabnew failed");
     connfreelist = listnew ();
     if (connfreelist == NULL)
	 arla_errx (1, ADEBERROR, "conn_init: listnew failed");
     connprobelist = listnew ();
     if (connprobelist == NULL)
	 arla_errx (1, ADEBERROR, "conn_init: listnew failed");
     nconnections = 0;

     if (LWP_CreateProcess (pinger, PINGER_STACKSIZE, 1,
			    NULL, "pinger", &pinger_pid))
	 arla_errx (1, ADEBERROR,
		    "conn: cannot create pinger thread");

     create_new_connections (nentries);
}

/*
 * Re-cycle an entry:
 * remove it from the hashtab, clear it out and place it on the freelist.
 */

static void
recycle_conn (ConnCacheEntry *e)
{
    assert (e->refcount == 0);

    if (e->parent != NULL) {
	conn_free (e->parent);
	e->parent = NULL;
    }
    if (e->probe_le != NULL) {
	listdel (connprobelist, e->probe_le);
	e->probe_le = NULL;
    }
    if (!e->flags.killme)
	hashtabdel (connhtab, e);
    rx_DestroyConnection (e->connection);
    memset (e, 0, sizeof(*e));
    listaddhead (connfreelist, e);
    --nactive_connections;
}

/*
 * Remove this connection from the hashtab and add it to the freelist
 * iff refcount == 0.
 */

static Bool
clear_conn (void *ptr, void *arg)
{
    ConnCacheEntry *e = (ConnCacheEntry *)ptr;

    if (e->refcount == 0)
	recycle_conn (e);
    return FALSE;
}

/*
 * Get a free connection to use.  Try to pick it from `connfreelist'.
 * If there are no there, it's time to go through `connhtab' and GC
 * unused connections.  If that fails, allocate some more.
 * And if that fails, give up.
 */

static ConnCacheEntry *
get_free_connection (void)
{
    ConnCacheEntry *e;

    e = (ConnCacheEntry *)listdelhead (connfreelist);
    if (e != NULL)
	return e;

    hashtabforeach (connhtab, clear_conn, NULL);

    e = (ConnCacheEntry *)listdelhead (connfreelist);
    if (e != NULL)
	return e;

    create_new_connections (CONNFREELISTINC);

    e = (ConnCacheEntry *)listdelhead (connfreelist);
    if (e != NULL)
	return e;

    arla_errx (1, ADEBERROR,
	       "conncache: there was no way of getting a connection");
}

/*
 * Get a free connection, fill in all parameters and create a
 * rx_connection.
 */

static ConnCacheEntry *
new_connection (int32_t cell,
		uint32_t host,
		uint16_t port,
		uint16_t service,
		nnpfs_pag_t cred,
		int securityindex,
		int (*probe)(struct rx_connection *),
		struct rx_securityClass *securityobject)
{
    ConnCacheEntry *e;

    assert (probe != NULL);

    e = get_free_connection ();

    e->cell          = cell;
    e->host          = host;
    e->port          = port;
    e->service       = service;
    e->flags.alivep  = TRUE;
    e->flags.old     = FALSE;
    e->refcount      = 0;
    e->cred          = cred;
    e->securityindex = securityindex;
    e->probe	     = probe;

    e->connection   = rx_NewConnection (host,
					htons (port),
					service,
					securityobject,
					securityindex);
    if (e->connection == NULL)
	arla_errx (1, ADEBERROR, "rx_NewConnection failed");
    return e;
}

/*
 * Create a new connection and add it to `connhtab'.
 */

static ConnCacheEntry *
add_connection(int32_t cell,
	       uint32_t host,
	       uint16_t port,
	       uint16_t service,
	       int (*probe)(struct rx_connection *),
	       CredCacheEntry *ce)
{
    ConnCacheEntry *e;
    struct rx_securityClass *securityobj;
    int securityindex;
    nnpfs_pag_t cred;

    if (ce) {
	securityindex = ce->securityindex;
	cred = ce->cred;

	switch (ce->type) {
#ifdef KERBEROS
	case CRED_KRB4 : {
	    struct cred_rxkad *cred = (struct cred_rxkad *)ce->cred_data;
	    
	    securityobj = rxkad_NewClientSecurityObject(conn_rxkad_level,
							cred->ct.HandShakeKey,
							cred->ct.AuthHandle,
							cred->ticket_len,
							cred->ticket);
	    break;
	}
#endif
	case CRED_NONE :
	    securityobj = rxnull_NewClientSecurityObject ();
	    break;
	default :
	    errx(1, "Unknown credentials type %d\n", ce->type);
	}
    } else {
	securityobj = rxnull_NewClientSecurityObject ();
	securityindex = 0;
	cred = 0;
    }

    e = new_connection (cell, host, port, service,
			cred, securityindex, probe, securityobj);

    hashtabadd (connhtab, (void *)e);
    ++nactive_connections;

    return e;
}


/*
 * Find a connection from the cache given:
 * (cell, host, port, service, cred).
 * If there's no connection at all, create one.
 */

static ConnCacheEntry *
internal_get (int32_t cell,
	      uint32_t host,
	      uint16_t port,
	      uint16_t service,
	      int (*probe)(struct rx_connection *),
	      CredCacheEntry *ce)
{
    ConnCacheEntry *e;
    ConnCacheEntry key;

#if 0
    if (connected_mode == DISCONNECTED)
	return NULL;
#endif

    key.host          = host;
    key.port          = port;
    key.service       = service;
    key.cred          = ce->cred;
    key.securityindex = ce->securityindex;

    e = (ConnCacheEntry *)hashtabsearch (connhtab, (void *)&key);

    if (e == NULL) {
	ConnCacheEntry *parent = NULL;

	if (ce->securityindex || ce->cred) {
	    key.cred = 0;
	    key.securityindex = 0;
	    parent = (ConnCacheEntry *)hashtabsearch (connhtab, (void *)&key);
	    if (parent == NULL) {
		parent = add_connection (cell, host, port, service,
					 probe, NULL);
	    }
	    ++parent->refcount;
	}

	e = add_connection (cell, host, port, service, probe, ce);
	if (parent != NULL)
	    e->parent = parent;
    }

    /*
     * Since we only probe the parent entry (ie noauth), we make sure
     * the status from the parent entry is pushed down to the
     * children.
     */
    if(e->parent != NULL) {
	e->flags.alivep = e->parent->flags.alivep;
    }

    return e;
}

/*
 * Return a connection to (cell, host, port, service, ce)
 */

ConnCacheEntry *
conn_get (int32_t cell,
	  uint32_t host,
	  uint16_t port,
	  uint16_t service,
	  int (*probe)(struct rx_connection *),
	  CredCacheEntry *ce)
{
    ConnCacheEntry *e = internal_get (cell, host, port, service, probe, ce);

    ++e->refcount;
    return e;
}

/*
 * Add a new reference to a connection
 */

void
conn_ref(ConnCacheEntry *e)
{
    assert(e->refcount > 0);
    e->refcount++;
}

/*
 * Free a reference to a ConnCacheEntry.
 * If refcount drops to zero, it makes it eligible for re-use.
 */

void
conn_free (ConnCacheEntry *e)
{
    if (e == NULL)  /* When in disconnected mode conn sets to NULL */
	return;

    assert (e->refcount > 0);

    --e->refcount;
    if (e->refcount == 0 && e->flags.killme)
	recycle_conn (e);
}

/*
 * Given a host try to figure out what cell it's in.
 */

int32_t
conn_host2cell (uint32_t host, uint16_t port, uint16_t service)
{
    ConnCacheEntry *e;
    ConnCacheEntry key;

    key.host          = host;
    key.port          = port;
    key.service       = service;
    key.cred          = 0;
    key.securityindex = 0;

    e = (ConnCacheEntry *)hashtabsearch(connhtab, (void *)&key);
    if (e == NULL)
	return -1;
    else
	return e->cell;
}

/*
 * Mark the server in `e' as being down.
 */

void
conn_dead (ConnCacheEntry *e)
{
    struct in_addr a;
    char buf[10];
    const char *port;

    assert (e->probe != NULL);

    e->flags.alivep = FALSE;
    if (e->parent != NULL) {
	e = e->parent;
	e->flags.alivep = FALSE;
    }
    add_to_probe_list (e, 0);
    a.s_addr = e->host;
    port = ports_num2name (e->port);
    if (port == NULL) {
	snprintf(buf, sizeof(buf), "%d", e->port);
	port = buf;
    }

    arla_warnx (ADEBWARN, "Lost connection to %s/%s in cell %s",
		inet_ntoa(a), port, cell_num2name (e->cell));
}

/*
 * Mark the server in `e' as being up.
 */

void
conn_alive (ConnCacheEntry *e)
{
    struct in_addr a;
    const char *s;

    a.s_addr = e->host;
    s = ports_num2name (e->port);
    if (s != NULL)
	arla_warnx (ADEBWARN, "Server %s/%s up again", inet_ntoa(a), s);
    else
	arla_warnx (ADEBWARN, "Server %s/%d up again", inet_ntoa(a), e->port);
    e->flags.alivep = TRUE;
    if (e->parent != NULL)
	e->parent->flags.alivep = TRUE;
}

/*
 * Is this server known to be up?
 */

Bool
conn_isalivep (ConnCacheEntry *e)
{
    if (e->parent != NULL)
	e->flags.alivep = e->parent->flags.alivep;

    return e->flags.alivep;
}

/*
 * Probe the service in `e'
 */

void
conn_probe (ConnCacheEntry *e)
{
    ++e->refcount;
    {
	struct in_addr a;
	a.s_addr = e->host;
	
	if (e->probe == NULL)
	    arla_warnx(ADEBWARN, "conn_probe: probe function is NULL, "
		       "host: %s cell: %d port: %d",
		       inet_ntoa(a), e->cell, e->port);
    }
    if (e->probe && ((*(e->probe))(e->connection) == 0)) {
	if (!e->flags.alivep)
	    conn_alive (e);
    } else {
	if (e->flags.alivep)
	    conn_dead (e);
    }
    conn_free (e);
}

/*
 * Is the service at (cell, host, port, service) up?
 */

Bool
conn_serverupp (uint32_t host, uint16_t port, uint16_t service)
{
    ConnCacheEntry *e;
    ConnCacheEntry key;

    key.host          = host;
    key.port          = port;
    key.service       = service;
    key.cred          = 0;
    key.securityindex = 0;

    e = (ConnCacheEntry *)hashtabsearch (connhtab, (void *)&key);
    if (e != NULL)
	return e->flags.alivep;
    else
	return TRUE;
}

/*
 * Print an entry.
 */

static Bool
print_conn (void *ptr, void *arg)
{
    ConnCacheEntry *e = (ConnCacheEntry *)ptr;
    struct in_addr tmp;

    tmp.s_addr = e->host;

    arla_log(ADEBVLOG, "host = %s, port = %d, service = %d, "
	     "cell = %d (%s), "
	     "securityindex = %d, cred = %u, "
	     "conn = %p, alive = %d, "
	     "killme = %d, refcount = %d",
	     inet_ntoa(tmp), e->port, e->service, e->cell,
	     cell_num2name (e->cell),
	     e->securityindex, e->cred, e->connection,
	     e->flags.alivep, e->flags.killme, e->refcount);

    return FALSE;
}

/*
 * Print the status of the connection cache.
 */

void
conn_status (void)
{
    arla_log(ADEBVLOG, "%u(%u) connections",
	     nactive_connections, nconnections);
    hashtabforeach (connhtab, print_conn, NULL);
}

struct clear_state {
    clear_state_mask mask;
    int32_t cell;
    nnpfs_pag_t cred;
    int securityindex;
};

static Bool
clear_cred (void *ptr, void *arg)
{
    ConnCacheEntry *e = (ConnCacheEntry *)ptr;
    struct clear_state *s = (struct clear_state *)arg;

    if ((s->mask & CONN_CS_CRED) && s->cred != e->cred)
	return FALSE;
    if ((s->mask & CONN_CS_CELL) && s->cell != e->cell)
	return FALSE;
    if ((s->mask & CONN_CS_SECIDX) && s->securityindex != e->securityindex)
	return FALSE;
    
    if (e->refcount > 0) {
	e->flags.killme = 1;
	hashtabdel (connhtab, e);	
    } else
	recycle_conn (e);

    return FALSE;
}

/*
 * Remove all connections matching mask + (cell, cred, securityindex).
 */

void
conn_clearcred(clear_state_mask mask,
	       int32_t cell, nnpfs_pag_t cred, int securityindex)
{
    struct clear_state s;

    s.mask	    = mask;
    s.cell          = cell;
    s.cred          = cred;
    s.securityindex = securityindex;

    hashtabforeach (connhtab, clear_cred, (void *)&s);
}

/*
 * check if servers are up for cell `cell'
 */

struct down_state {
    int32_t cell;
    uint32_t *hosts;
    int len;
    int i;
    int flags;
};

static Bool
host_down (void *ptr, void *arg)
{
    ConnCacheEntry *e = (ConnCacheEntry *)ptr;
    struct down_state *s = (struct down_state *)arg;
    int i;

    if (s->cell == e->cell) {

	if (!(s->flags & CKSERV_DONTPING)) {
	    conn_probe (e);
	}

	if (e->flags.alivep)
	    return FALSE;
	
	if (s->flags & CKSERV_FSONLY && e->port != afsport)
	    return FALSE;

	for (i = 0; i < s->i; ++i)
	    if (s->hosts[i] == e->host)
		return FALSE;

	s->hosts[s->i] = e->host;
	++s->i;

	if (s->i == s->len)
	    return TRUE;
    }
    return FALSE;
}

/*
 * Check what hosts are down.
 *
 * Flags is VIOCCKFLAGS
 */

void
conn_downhosts(int32_t cell, uint32_t *hosts, int *num, int flags)
{
    struct down_state s;

    if (*num == 0)
	return;

    s.cell          = cell;
    s.hosts	    = hosts;
    s.len           = *num;
    s.i	            = 0;
    s.flags         = flags;

    hashtabforeach (connhtab, host_down, (void *)&s);

    *num = s.i;
}

/*
 * Compare two ConnCacheEntries rtt-wise.  Typically used when sorting
 * entries.
 */

int
conn_rtt_cmp (const void *v1, const void *v2)
{
    ConnCacheEntry **e1 = (ConnCacheEntry **)v1;
    ConnCacheEntry **e2 = (ConnCacheEntry **)v2;
    
    return (*e1)->rtt - (*e2)->rtt;
}

/*
 * Return true iff this error means we should mark the host as down
 * due to network errors
 */

Bool
host_downp (int error)
{
    switch (error) {
    case ARLA_CALL_DEAD :
    case ARLA_INVALID_OPERATION :
    case ARLA_CALL_TIMEOUT :
    case ARLA_EOF :
    case ARLA_PROTOCOL_ERROR :
    case ARLA_USER_ABORT :
    case ARLA_ADDRINUSE :
    case ARLA_MSGSIZE :
    case RXGEN_CC_MARSHAL :
    case RXGEN_CC_UNMARSHAL :
    case RXGEN_SS_MARSHAL :
    case RXGEN_SS_UNMARSHAL :
    case RXGEN_DECODE :
    case RXGEN_OPCODE :
    case RXGEN_SS_XDRFREE :
    case RXGEN_CC_XDRFREE :
	return TRUE;
    default :
	return FALSE;
    }
}

@


1.6
log
@afs cleanup, realloc strings, abort, etc.
testing by beck, hin, jose, fries. ok deraadt@@
@
text
@@


1.5
log
@Merge
@
text
@d424 1
a424 1
	    abort();
@


1.4
log
@merge
@
text
@d2 1
a2 1
 * Copyright (c) 1995 - 2001 Kungliga Tekniska Högskolan
d41 1
a41 1
RCSID("$KTH: conn.c,v 1.61.2.3 2001/09/03 22:12:07 ahltorp Exp $") ;
d92 3
d108 2
a109 1
    if (e->probe_le != NULL)
a110 3

    gettimeofday (&tv, NULL);
    if (e->probe_le)
d112 1
a112 1
    else
d114 3
a116 1
    ++e->ntries;
a148 1
#define PINGER_SLEEP 10
a149 1
#define MAX_RETRIES 5
d208 3
a210 1
	if (e->probe && ((*(e->probe))(e->connection) == 0)) {
d212 1
a212 1
	} else if (e->ntries <= MAX_RETRIES) {
d215 1
d351 4
a354 4
		u_int32_t host,
		u_int16_t port,
		u_int16_t service,
		xfs_pag_t cred,
d392 3
a394 3
	       u_int32_t host,
	       u_int16_t port,
	       u_int16_t service,
d401 1
a401 1
    xfs_pag_t cred;
d409 2
a410 3
	case CRED_KRB4 :
	case CRED_KRB5 : {
	    krbstruct *krbdata = (krbstruct *)ce->cred_data;
d412 5
a416 6
	    securityobj = rxkad_NewClientSecurityObject(
		conn_rxkad_level,
		&krbdata->c.session,
		krbdata->c.kvno,
		krbdata->c.ticket_st.length,
		krbdata->c.ticket_st.dat);
d450 3
a452 3
	      u_int32_t host,
	      u_int16_t port,
	      u_int16_t service,
d490 6
d504 1
a504 1
 * Dead servers don't exist.
d509 3
a511 3
	  u_int32_t host,
	  u_int16_t port,
	  u_int16_t service,
a515 1
    ConnCacheEntry *parent = e;
d517 1
a517 11
    if (e != NULL) {
	if (e->parent != NULL)
	    parent = e->parent;
	if (e->flags.alivep) {
	    ++e->refcount;
	} else {
	    e = NULL;
	    add_to_probe_list (parent,
			       min(parent->ntries, MAX_RETRIES));
	}
    }
d522 11
d555 1
a555 1
conn_host2cell (u_int32_t host, u_int16_t port, u_int16_t service)
d581 2
a582 1
    const char *s;
d593 8
a600 7
    s = ports_num2name (e->port);
    if (s != NULL)
	arla_warnx (ADEBWARN, "Lost connection to %s/%s",
		    inet_ntoa(a), s);
    else
	arla_warnx (ADEBWARN, "Lost connection to %s/%d",
		    inet_ntoa(a), e->port);
d625 13
d669 1
a669 1
conn_serverupp (u_int32_t host, u_int16_t port, u_int16_t service)
d727 1
a727 1
    xfs_pag_t cred;
d759 1
a759 1
	       int32_t cell, xfs_pag_t cred, int securityindex)
d777 1
a777 1
    u_int32_t *hosts;
d822 1
a822 1
conn_downhosts(int32_t cell, u_int32_t *hosts, int *num, int flags)
@


1.3
log
@New Arla userland from Arla between 0.34.2 and current in arla cvs.
Too many new features and fixes to mention here.
@
text
@d2 1
a2 1
 * Copyright (c) 1995-2000 Kungliga Tekniska Högskolan
d17 1
a17 6
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by the Kungliga Tekniska
 *      Högskolan and its contributors.
 * 
 * 4. Neither the name of the Institute nor the names of its contributors
d41 1
a41 1
RCSID("$Id: conn.c,v 1.59 2000/05/23 04:04:12 assar Exp $") ;
d109 4
a112 1
    e->probe_next = tv.tv_sec + (1 << e->ntries);
d285 2
a286 1
    hashtabdel (connhtab, e);
d702 1
d714 13
a726 8
    if (e->cred == s->cred
	&& (s->cell == 0 || e->cell == s->cell)
	&& e->securityindex == s->securityindex) {
	if (e->refcount > 0)
	    e->flags.killme = 1;
	else
	    recycle_conn (e);
    }
d731 1
a731 1
 * Remove all connections matching (cell, cred, securityindex).
d735 2
a736 1
conn_clearcred(int32_t cell, xfs_pag_t cred, int securityindex)
d740 1
d830 32
@


1.2
log
@upgrade Arla to fresher code. Too many new features and bugfixes.
@
text
@a0 1
/*	$OpenBSD$	*/
d2 1
a2 1
 * Copyright (c) 1995, 1996, 1997, 1998, 1999 Kungliga Tekniska Högskolan
d46 1
a46 1
RCSID("$KTH: conn.c,v 1.52 1999/04/20 20:58:07 map Exp $") ;
d68 4
a107 1
    assert (!e->flags.alivep);
d351 1
a351 1
		pag_t cred,
d398 1
a398 1
    pag_t cred;
d411 1
a411 1
		rxkad_auth,
d458 1
d461 1
d681 1
a681 1
	     "killme = %d, refcount = %d\n\n",
d697 1
a697 1
    arla_log(ADEBVLOG, "%u(%u) connections\n",
d704 1
a704 1
    pag_t cred;
d730 1
a730 1
conn_clearcred(int32_t cell, pag_t cred, int securityindex)
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
 * Copyright (c) 1995, 1996, 1997, 1998 Kungliga Tekniska Högskolan
d47 1
a47 1
RCSID("$KTH: conn.c,v 1.39 1998/07/13 19:16:55 assar Exp $") ;
d66 3
d76 2
a77 2
     ConnCacheEntry *c1 = (ConnCacheEntry*)a;
     ConnCacheEntry *c2 = (ConnCacheEntry*)b;
d79 5
a83 5
     return  c1->cred          != c2->cred
	  || c1->host          != c2->host
	  || c1->service       != c2->service
	  || c1->port          != c2->port
	  || c1->securityindex != c2->securityindex;
d89 15
a103 1
     ConnCacheEntry *c = (ConnCacheEntry*)a;
d105 34
a138 1
     return c->cred + c->host + c->service + c->port + c->securityindex;
d141 74
d231 3
a233 1
	  entries[i].refcount = 0 ;
d254 3
d258 6
d275 10
d351 1
d356 2
d365 1
d369 1
d390 1
d430 1
a430 1
			cred, securityindex, securityobj);
d445 7
a451 6
ConnCacheEntry *
conn_get (int32_t cell,
	  u_int32_t host,
	  u_int16_t port,
	  u_int16_t service,
	  CredCacheEntry *ce)
d468 2
d473 6
a478 3
	    e = (ConnCacheEntry *)hashtabsearch (connhtab, (void *)&key);
	    if (e == NULL)
		add_connection (cell, host, port, service, NULL);
d481 6
a486 1
	e = add_connection (cell, host, port, service, ce);
d489 29
a517 1
    ++e->refcount;
d532 2
d563 76
a668 1
    FILE *f = (FILE *)arg;
d673 1
a673 1
    fprintf (f, "host = %s, port = %d, service = %d, "
d691 1
a691 1
conn_status (FILE *f)
d693 1
a693 1
    fprintf (f, "%u(%u) connections\n",
d695 1
a695 1
    hashtabforeach (connhtab, print_conn, f);
d735 83
@


1.1.1.1
log
@Initial version of Arla, a free implementation of an AFS cache-manager.
(second try, hopefully into the correct repository this time)
@
text
@@


1.1.1.2
log
@Import of arla-0.35.7
@
text
@d1 1
d3 1
a3 1
 * Copyright (c) 1995 - 2001 Kungliga Tekniska Högskolan
d18 6
a23 1
 * 3. Neither the name of the Institute nor the names of its contributors
d47 1
a47 1
RCSID("$KTH: conn.c,v 1.61.2.3 2001/09/03 22:12:07 ahltorp Exp $") ;
a65 7
/* List of connections to probe */
static List *connprobelist;

#ifdef KERBEROS
int conn_rxkad_level = rxkad_auth;
#endif

d73 2
a74 2
    ConnCacheEntry *c1 = (ConnCacheEntry*)a;
    ConnCacheEntry *c2 = (ConnCacheEntry*)b;
d76 5
a80 5
    return  c1->cred          != c2->cred
	|| c1->host          != c2->host
	|| c1->service       != c2->service
	|| c1->port          != c2->port
	|| c1->securityindex != c2->securityindex;
d86 1
a86 15
    ConnCacheEntry *c = (ConnCacheEntry*)a;

    return c->cred + c->host + c->service + c->port + c->securityindex;
}


/*
 * Add this entry again to the probe list but without restarting ntries.
 */

static void
re_probe (ConnCacheEntry *e)
{
    Listitem *item;
    struct timeval tv;
d88 1
a88 25
    assert (e->probe != NULL);

    if (e->probe_le != NULL)
	listdel (connprobelist, e->probe_le);

    gettimeofday (&tv, NULL);
    if (e->probe_le)
	e->probe_next = min(tv.tv_sec + (1 << e->ntries), e->probe_next);
    else
	e->probe_next = tv.tv_sec + (1 << e->ntries);
    ++e->ntries;

    for (item = listhead (connprobelist);
	 item;
	 item = listnext (connprobelist, item)) {
	ConnCacheEntry *this = (ConnCacheEntry *)listdata (item);

	if (e->probe_next < this->probe_next) {
	    e->probe_le = listaddbefore (connprobelist, item, e);
	    LWP_NoYieldSignal (connprobelist);
	    return;
	}
    }
    e->probe_le = listaddtail (connprobelist, e);
    LWP_NoYieldSignal (connprobelist);
a90 85
/*
 * Initial add to probe list.
 */

static void
add_to_probe_list (ConnCacheEntry *e, int ntries)
{
    e->ntries = ntries;
    re_probe (e);
}

/*
 *
 */

#define PINGER_STACKSIZE (16*1024)
#define PINGER_SLEEP 10

#define MAX_RETRIES 5

static PROCESS pinger_pid;

/*
 * Loop waiting for things servers to probe.
 */

static void
pinger (char *arg)
{
    for (;;) {
	struct timeval tv;
	Listitem *item;
	ConnCacheEntry *e;
	struct in_addr addr;
	const char *port_str;

	arla_warnx(ADEBCONN, "running pinger");

	while (listemptyp (connprobelist))
	    LWP_WaitProcess (connprobelist);

	item = listhead (connprobelist);
	e = (ConnCacheEntry *)listdata (item);

	assert (e->probe_le == item);

	gettimeofday (&tv, NULL);
	if (tv.tv_sec < e->probe_next) {
	    unsigned long t = e->probe_next - tv.tv_sec;

	    arla_warnx(ADEBCONN,
		       "pinger: sleeping %lu second(s)", t);
	    IOMGR_Sleep (t);
	    continue;
	}

	listdel (connprobelist, item);
	e->probe_le = NULL;

	if (e->flags.alivep)
	    continue;

	addr.s_addr = e->host;
	port_str    = ports_num2name (e->port);

	if (port_str != NULL)
	    arla_warnx (ADEBCONN, "pinger: probing %s/%s",
			inet_ntoa(addr), port_str);
	else
	    arla_warnx (ADEBCONN, "pinger: probing %s/%d",
			inet_ntoa(addr), e->port);
	++e->refcount;
	if (e->probe == NULL)
	    arla_warnx(ADEBWARN, "pinger: probe function is NULL, "
		       "host: %s cell: %d port: %d",
		       inet_ntoa(addr), e->cell, e->port);

	if (e->probe && ((*(e->probe))(e->connection) == 0)) {
	    conn_alive (e);
	} else if (e->ntries <= MAX_RETRIES) {
	    re_probe (e);
	}
	conn_free (e);
    }
}
d107 1
a107 3
	  entries[i].refcount   = 0;
	  entries[i].parent     = NULL;
	  entries[i].probe_le	= NULL;
a127 3
     connprobelist = listnew ();
     if (connprobelist == NULL)
	 arla_errx (1, ADEBERROR, "conn_init: listnew failed");
a128 6

     if (LWP_CreateProcess (pinger, PINGER_STACKSIZE, 1,
			    NULL, "pinger", &pinger_pid))
	 arla_errx (1, ADEBERROR,
		    "conn: cannot create pinger thread");

d140 1
a140 12
    assert (e->refcount == 0);

    if (e->parent != NULL) {
	conn_free (e->parent);
	e->parent = NULL;
    }
    if (e->probe_le != NULL) {
	listdel (connprobelist, e->probe_le);
	e->probe_le = NULL;
    }
    if (!e->flags.killme)
	hashtabdel (connhtab, e);
d204 1
a204 1
		xfs_pag_t cred,
a205 1
		int (*probe)(struct rx_connection *),
a209 2
    assert (probe != NULL);

a216 1
    e->flags.old     = FALSE;
a219 1
    e->probe	     = probe;
a239 1
	       int (*probe)(struct rx_connection *),
d245 1
a245 1
    xfs_pag_t cred;
d258 1
a258 1
		conn_rxkad_level,
d279 1
a279 1
			cred, securityindex, probe, securityobj);
d294 6
a299 7
static ConnCacheEntry *
internal_get (int32_t cell,
	      u_int32_t host,
	      u_int16_t port,
	      u_int16_t service,
	      int (*probe)(struct rx_connection *),
	      CredCacheEntry *ce)
a303 1
#if 0
a305 1
#endif
a315 2
	ConnCacheEntry *parent = NULL;

d319 3
a321 6
	    parent = (ConnCacheEntry *)hashtabsearch (connhtab, (void *)&key);
	    if (parent == NULL) {
		parent = add_connection (cell, host, port, service,
					 probe, NULL);
	    }
	    ++parent->refcount;
d324 1
a324 6
	e = add_connection (cell, host, port, service, probe, ce);
	if (parent != NULL)
	    e->parent = parent;
    }
    if(e->parent != NULL) {
	e->flags.alivep = e->parent->flags.alivep;
d327 1
a327 29
    return e;
}

/*
 * Dead servers don't exist.
 */

ConnCacheEntry *
conn_get (int32_t cell,
	  u_int32_t host,
	  u_int16_t port,
	  u_int16_t service,
	  int (*probe)(struct rx_connection *),
	  CredCacheEntry *ce)
{
    ConnCacheEntry *e = internal_get (cell, host, port, service, probe, ce);
    ConnCacheEntry *parent = e;

    if (e != NULL) {
	if (e->parent != NULL)
	    parent = e->parent;
	if (e->flags.alivep) {
	    ++e->refcount;
	} else {
	    e = NULL;
	    add_to_probe_list (parent,
			       min(parent->ntries, MAX_RETRIES));
	}
    }
a341 2
    assert (e->refcount > 0);

a370 76
 * Mark the server in `e' as being down.
 */

void
conn_dead (ConnCacheEntry *e)
{
    struct in_addr a;
    const char *s;

    assert (e->probe != NULL);

    e->flags.alivep = FALSE;
    if (e->parent != NULL) {
	e = e->parent;
	e->flags.alivep = FALSE;
    }
    add_to_probe_list (e, 0);
    a.s_addr = e->host;
    s = ports_num2name (e->port);
    if (s != NULL)
	arla_warnx (ADEBWARN, "Lost connection to %s/%s",
		    inet_ntoa(a), s);
    else
	arla_warnx (ADEBWARN, "Lost connection to %s/%d",
		    inet_ntoa(a), e->port);
}

/*
 * Mark the server in `e' as being up.
 */

void
conn_alive (ConnCacheEntry *e)
{
    struct in_addr a;
    const char *s;

    a.s_addr = e->host;
    s = ports_num2name (e->port);
    if (s != NULL)
	arla_warnx (ADEBWARN, "Server %s/%s up again", inet_ntoa(a), s);
    else
	arla_warnx (ADEBWARN, "Server %s/%d up again", inet_ntoa(a), e->port);
    e->flags.alivep = TRUE;
    if (e->parent != NULL)
	e->parent->flags.alivep = TRUE;
}

/*
 * Probe the service in `e'
 */

void
conn_probe (ConnCacheEntry *e)
{
    ++e->refcount;
    {
	struct in_addr a;
	a.s_addr = e->host;
	
	if (e->probe == NULL)
	    arla_warnx(ADEBWARN, "conn_probe: probe function is NULL, "
		       "host: %s cell: %d port: %d",
		       inet_ntoa(a), e->cell, e->port);
    }
    if (e->probe && ((*(e->probe))(e->connection) == 0)) {
	if (!e->flags.alivep)
	    conn_alive (e);
    } else {
	if (e->flags.alivep)
	    conn_dead (e);
    }
    conn_free (e);
}

/*
d401 1
d406 1
a406 1
    arla_log(ADEBVLOG, "host = %s, port = %d, service = %d, "
d410 1
a410 1
	     "killme = %d, refcount = %d",
d424 1
a424 1
conn_status (void)
d426 1
a426 1
    arla_log(ADEBVLOG, "%u(%u) connections",
d428 1
a428 1
    hashtabforeach (connhtab, print_conn, NULL);
a431 1
    clear_state_mask mask;
d433 1
a433 1
    xfs_pag_t cred;
d443 8
a450 13
    if ((s->mask & CONN_CS_CRED) && s->cred != e->cred)
	return FALSE;
    if ((s->mask & CONN_CS_CELL) && s->cell != e->cell)
	return FALSE;
    if ((s->mask & CONN_CS_SECIDX) && s->securityindex != e->securityindex)
	return FALSE;
    
    if (e->refcount > 0) {
	e->flags.killme = 1;
	hashtabdel (connhtab, e);	
    } else
	recycle_conn (e);

d455 1
a455 1
 * Remove all connections matching mask + (cell, cred, securityindex).
d459 1
a459 2
conn_clearcred(clear_state_mask mask,
	       int32_t cell, xfs_pag_t cred, int securityindex)
a462 1
    s.mask	    = mask;
a468 115

/*
 * check if servers are up for cell `cell'
 */

struct down_state {
    int32_t cell;
    u_int32_t *hosts;
    int len;
    int i;
    int flags;
};

static Bool
host_down (void *ptr, void *arg)
{
    ConnCacheEntry *e = (ConnCacheEntry *)ptr;
    struct down_state *s = (struct down_state *)arg;
    int i;

    if (s->cell == e->cell) {

	if (!(s->flags & CKSERV_DONTPING)) {
	    conn_probe (e);
	}

	if (e->flags.alivep)
	    return FALSE;
	
	if (s->flags & CKSERV_FSONLY && e->port != afsport)
	    return FALSE;

	for (i = 0; i < s->i; ++i)
	    if (s->hosts[i] == e->host)
		return FALSE;

	s->hosts[s->i] = e->host;
	++s->i;

	if (s->i == s->len)
	    return TRUE;
    }
    return FALSE;
}

/*
 * Check what hosts are down.
 *
 * Flags is VIOCCKFLAGS
 */

void
conn_downhosts(int32_t cell, u_int32_t *hosts, int *num, int flags)
{
    struct down_state s;

    if (*num == 0)
	return;

    s.cell          = cell;
    s.hosts	    = hosts;
    s.len           = *num;
    s.i	            = 0;
    s.flags         = flags;

    hashtabforeach (connhtab, host_down, (void *)&s);

    *num = s.i;
}

/*
 * Compare two ConnCacheEntries rtt-wise.  Typically used when sorting
 * entries.
 */

int
conn_rtt_cmp (const void *v1, const void *v2)
{
    ConnCacheEntry **e1 = (ConnCacheEntry **)v1;
    ConnCacheEntry **e2 = (ConnCacheEntry **)v2;
    
    return (*e1)->rtt - (*e2)->rtt;
}

/*
 * Return true iff this error means we should mark the host as down
 * due to network errors
 */

Bool
host_downp (int error)
{
    switch (error) {
    case ARLA_CALL_DEAD :
    case ARLA_INVALID_OPERATION :
    case ARLA_CALL_TIMEOUT :
    case ARLA_EOF :
    case ARLA_PROTOCOL_ERROR :
    case ARLA_USER_ABORT :
    case ARLA_ADDRINUSE :
    case ARLA_MSGSIZE :
    case RXGEN_CC_MARSHAL :
    case RXGEN_CC_UNMARSHAL :
    case RXGEN_SS_MARSHAL :
    case RXGEN_SS_UNMARSHAL :
    case RXGEN_DECODE :
    case RXGEN_OPCODE :
    case RXGEN_SS_XDRFREE :
    case RXGEN_CC_XDRFREE :
	return TRUE;
    default :
	return FALSE;
    }
}

@


1.1.1.3
log
@Import of arla -current as of Aug 5 2003

ok todd@@ deraadt@@
@
text
@d2 1
a2 1
 * Copyright (c) 1995 - 2002 Kungliga Tekniska Högskolan
d41 1
a41 1
RCSID("$arla: conn.c,v 1.75 2003/06/10 04:23:20 lha Exp $") ;
a91 3
/* 2^MAX_RETRIES is the maximum number of seconds between probes */

#define MAX_RETRIES 8
d105 3
d109 1
a109 2
    if (e->probe_le) {
	listdel (connprobelist, e->probe_le);
d111 1
a111 1
    } else
d113 1
a113 3

    if (e->ntries <= MAX_RETRIES)
	++e->ntries;
d146 1
d148 1
d207 1
a207 3
	if (connected_mode == DISCONNECTED) {
	    arla_warnx(ADEBCONN, "pinger: ignoring host in disconnected mode");
	} else if (e->probe && ((*(e->probe))(e->connection) == 0)) {
d209 1
a209 1
	} else {
a211 1

d347 4
a350 4
		uint32_t host,
		uint16_t port,
		uint16_t service,
		nnpfs_pag_t cred,
d388 3
a390 3
	       uint32_t host,
	       uint16_t port,
	       uint16_t service,
d397 1
a397 1
    nnpfs_pag_t cred;
d405 3
a407 2
	case CRED_KRB4 : {
	    struct cred_rxkad *cred = (struct cred_rxkad *)ce->cred_data;
d409 6
a414 5
	    securityobj = rxkad_NewClientSecurityObject(conn_rxkad_level,
							cred->ct.HandShakeKey,
							cred->ct.AuthHandle,
							cred->ticket_len,
							cred->ticket);
d448 3
a450 3
	      uint32_t host,
	      uint16_t port,
	      uint16_t service,
a487 6

    /*
     * Since we only probe the parent entry (ie noauth), we make sure
     * the status from the parent entry is pushed down to the
     * children.
     */
d496 1
a496 1
 * Return a connection to (cell, host, port, service, ce)
d501 3
a503 3
	  uint32_t host,
	  uint16_t port,
	  uint16_t service,
d508 1
d510 11
a520 1
    ++e->refcount;
a524 11
 * Add a new reference to a connection
 */

void
conn_ref(ConnCacheEntry *e)
{
    assert(e->refcount > 0);
    e->refcount++;
}

/*
d547 1
a547 1
conn_host2cell (uint32_t host, uint16_t port, uint16_t service)
d573 1
a573 2
    char buf[10];
    const char *port;
d584 7
a590 8
    port = ports_num2name (e->port);
    if (port == NULL) {
	snprintf(buf, sizeof(buf), "%d", e->port);
	port = buf;
    }

    arla_warnx (ADEBWARN, "Lost connection to %s/%s in cell %s",
		inet_ntoa(a), port, cell_num2name (e->cell));
a614 13
 * Is this server known to be up?
 */

Bool
conn_isalivep (ConnCacheEntry *e)
{
    if (e->parent != NULL)
	e->flags.alivep = e->parent->flags.alivep;

    return e->flags.alivep;
}

/*
d646 1
a646 1
conn_serverupp (uint32_t host, uint16_t port, uint16_t service)
d704 1
a704 1
    nnpfs_pag_t cred;
d736 1
a736 1
	       int32_t cell, nnpfs_pag_t cred, int securityindex)
d754 1
a754 1
    uint32_t *hosts;
d799 1
a799 1
conn_downhosts(int32_t cell, uint32_t *hosts, int *num, int flags)
@


