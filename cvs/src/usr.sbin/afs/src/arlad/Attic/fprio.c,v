head	1.7;
access;
symbols
	OPENBSD_5_2:1.6.0.10
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.8
	OPENBSD_5_0:1.6.0.6
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.4
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.6.0.2
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.5.0.26
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.5.0.28
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.5.0.24
	OPENBSD_4_5_BASE:1.5
	OPENBSD_4_4:1.5.0.22
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3:1.5.0.20
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.5.0.18
	OPENBSD_4_2_BASE:1.5
	OPENBSD_4_1:1.5.0.16
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.5.0.14
	OPENBSD_4_0_BASE:1.5
	OPENBSD_3_9:1.5.0.12
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.5.0.10
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.8
	OPENBSD_3_7_BASE:1.5
	OPENBSD_3_6:1.5.0.6
	OPENBSD_3_6_BASE:1.5
	OPENBSD_3_5:1.5.0.4
	OPENBSD_3_5_BASE:1.5
	OPENBSD_3_4:1.5.0.2
	OPENBSD_3_4_BASE:1.5
	arla-20030805:1.1.1.3
	OPENBSD_3_3:1.4.0.4
	OPENBSD_3_3_BASE:1.4
	OPENBSD_3_2:1.4.0.2
	OPENBSD_3_2_BASE:1.4
	arla-0-35-7:1.1.1.2
	OPENBSD_3_1:1.3.0.8
	OPENBSD_3_1_BASE:1.3
	OPENBSD_3_0:1.3.0.6
	OPENBSD_3_0_BASE:1.3
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_9:1.3.0.4
	OPENBSD_2_8:1.3.0.2
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.2.0.4
	OPENBSD_2_7_BASE:1.2
	OPENBSD_2_6:1.2.0.2
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.1.1.1.0.4
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.2
	OPENBSD_2_4_BASE:1.1.1.1
	arla-0_9:1.1.1.1
	arla:1.1.1;
locks; strict;
comment	@ * @;


1.7
date	2012.08.23.06.21.50;	author deraadt;	state dead;
branches;
next	1.6;

1.6
date	2010.06.01.15.44.53;	author zinovik;	state Exp;
branches;
next	1.5;

1.5
date	2003.08.05.08.42.41;	author hin;	state Exp;
branches;
next	1.4;

1.4
date	2002.06.07.04.28.57;	author hin;	state Exp;
branches;
next	1.3;

1.3
date	2000.09.11.14.40.42;	author art;	state Exp;
branches;
next	1.2;

1.2
date	99.04.30.01.59.08;	author art;	state Exp;
branches;
next	1.1;

1.1
date	98.09.14.21.52.56;	author art;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.09.14.21.52.56;	author art;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.06.07.04.14.23;	author hin;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2003.08.05.08.21.01;	author hin;	state Exp;
branches;
next	;


desc
@@


1.7
log
@the afs src tree can go away
@
text
@/*
 * Copyright (c) 1998 - 2000 Kungliga Tekniska Högskolan
 * (Royal Institute of Technology, Stockholm, Sweden).
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * Manage the priority of the files
 */

#include "arla_local.h"
#include <kafs.h>
RCSID("$arla: fprio.c,v 1.12 2002/10/02 00:54:21 lha Exp $");

/* Hashtable of entries by name */
static Hashtab *fpriohashtab;

/*
 * fprio - hash help functions
 */

static int
fpriocmp (void *a, void *b)
{
    struct fpriorityentry *n1 = (struct fpriorityentry *)a;
    struct fpriorityentry *n2 = (struct fpriorityentry *)b;

    return n1->fid.Cell != n2->fid.Cell || 
	n1->fid.fid.Volume != n2->fid.fid.Volume ||
	n1->fid.fid.Vnode != n2->fid.fid.Vnode ||
	n1->fid.fid.Unique != n2->fid.fid.Unique;
}

static unsigned
fpriohash (void *a)
{
     struct fpriorityentry *n = (struct fpriorityentry *)a;

     return n->fid.Cell ^ n->fid.fid.Volume ^ 
	 n->fid.fid.Vnode ^ n->fid.fid.Unique;
}

/*
 * fprio_init
 * 
 *  Just create the hashtab. Leave the smartness to the user.
 */

void
fprio_init (char *file)
{
    fpriohashtab = hashtabnew (FPRIOCACHE_SIZE, fpriocmp, fpriohash);
    if (fpriohashtab == NULL)
	arla_errx (1, ADEBERROR, "fprio_init: hashtabnew failed");

    if (file)
	fprio_readin(file);
}

/*
 * Cleanout unwanted enteries
 */

static Bool
cleanupfpriohash(void *ptr, void *arg)
{
    struct fpriorityentry *n = (struct fpriorityentry *)ptr;
    struct fpriorityentry *a = (struct fpriorityentry *)arg;

    /* Clean out if
     *
     *   NULL cleanout argument
     *   cleanout argument is in the same Cell and
     *      Volume == Vnode == 0  (ie, when whole cell), or
     *      Volume == the victim entry's Volume
     *             && Vnode == 0  (ie, whole volume), or
     *      the Vnode and Unique also match (ie the file/direntry)
     *
     *  This means that memset(&myarg, 0, sizeof(stuct fprioentry))
     *  is probably not what you want. (Cleaning out the localcell's
     *  all entries)
     */

    if (a == NULL ||
	(a->fid.Cell == n->fid.Cell && 
	 ((a->fid.fid.Volume == 0 && a->fid.fid.Vnode ==0) ||
	  (a->fid.fid.Volume == n->fid.fid.Volume &&
	   (a->fid.fid.Vnode == 0 ||
	    (a->fid.fid.Vnode == n->fid.fid.Vnode &&
	     a->fid.fid.Unique == n->fid.fid.Unique)))))) {
	
	AFSCallBack broken_callback = {0, 0, CBDROPPED};
	
	fcache_stale_entry (n->fid, broken_callback);
	free(n);
	
	return TRUE;
    }
    
    return FALSE;
}


int
fprio_clear(void)
{
    hashtabcleantab(fpriohashtab, cleanupfpriohash, NULL);
    return 0;
}

/*
 * zapp the `fid'
 */

void
fprio_remove(VenusFid fid)
{
    struct fpriorityentry key; 

    key.fid = fid;
    hashtabfree(fpriohashtab, &key);
    return;
}

/*
 * set a `fid' with `prio' to the hashtab
 */

void
fprio_set(VenusFid fid, Bool prio)
{
    struct fpriorityentry *e; 
    struct fpriorityentry key; 

    key.fid = fid;

    e = hashtabsearch(fpriohashtab, &key);
    if (e) {
	e->priority = prio;
	return;
    }

    e = calloc(1, sizeof(*e));
    if (e == NULL) {
	arla_warn(ADEBFCACHE, 1, "fprio_set: Out of memory");
	return;
    }
    e->fid = fid;
    e->priority = prio;
    
    hashtabadd(fpriohashtab, e);
}

/*
 * Read in new data from the file
 */

#define MAXFPRIOLINE 1024

int
fprio_readin(char *file)
{
    FILE *f;
    char line[MAXFPRIOLINE];
    unsigned prio;
    char cell[MAXFPRIOLINE];
    int32_t cellnum;
    VenusFid fid;
    int lineno = 0 ;

    f = fopen(file, "r");
    if (f == NULL)
	return -1;

    while(fgets(line, sizeof(line), f) != NULL) {
	lineno++;

	line[strcspn(line, "\n")] = '\0';

	if (line[0] == '#')
	    continue;

	if (sscanf(line, "%d:%s:%u:%u:%u", &prio, 
		   cell,
		   &fid.fid.Volume, 
		   &fid.fid.Vnode, 
		   &fid.fid.Unique) != 5) {
	    arla_warn(ADEBFCACHE, 1, 
		      "fprio_readin: %s:%d contain error(s)", 
		      file, lineno);
	    continue;
	}
	
	cellnum = cell_name2num(cell);
	if (cellnum == -1) {
	    arla_warn(ADEBFCACHE, 1, 
		      "fprio_readin: the cell %s does not exist", cell);
	    continue;
	}

	fid.Cell = cellnum;
	fprio_set(fid, prio ? TRUE : FALSE);
    }
    fclose(f);
    return 0;
}

/*
 * Find the priority of a fid
 */

Bool
fprio_get(VenusFid fid)
{
    struct fpriorityentry a;
    struct fpriorityentry *b;

    a.fid = fid;

    b = hashtabsearch(fpriohashtab, &a);
    if (b)
	return b->priority;
    return FALSE;
}

/*
 * Print the entry `ptr' to the FILE `arg'
 */

static Bool
fprio_print_entry (void *ptr, void *arg)
{
    struct fpriorityentry *n = (struct fpriorityentry *)ptr;
    const char *cell = cell_num2name(n->fid.Cell);
    const char *comment;

    if (cell == NULL)  /* If we cant find the cell comment it out */
	comment = "#";
    else
	comment = "";

    arla_log(ADEBVLOG, "%s%d:%s:%d:%d:%d", 
	     comment, n->priority == TRUE ? 1 : 0, cell?cell:"unknowncell", 
	     n->fid.fid.Volume, n->fid.fid.Vnode, n->fid.fid.Unique);
    return FALSE;
}

/*
 * Print the status of the fprio module in some strange format...
 */

void
fprio_status (void)
{
    time_t the_time = time(NULL);

    arla_log(ADEBVLOG, "#fprio entries\n#\n#  Date: %s\n#"
	     "#Syntax: (# means comment)\n"
	     "#priority:cell:volume:vnode:unique\n",
	     ctime(&the_time));
    hashtabforeach (fpriohashtab, fprio_print_entry, NULL);
}



@


1.6
log
@close FILE `f' when we leave function fprio_readin(), so it wont get lost

ok beck@@, todd@@
@
text
@@


1.5
log
@Merge
@
text
@d231 1
@


1.4
log
@merge
@
text
@d40 1
a40 1
RCSID("$KTH: fprio.c,v 1.9 2000/10/02 22:31:43 lha Exp $");
d202 1
a202 1
    while(fgets(line, sizeof(line)-1, f) != NULL) {
d205 2
d261 1
a261 1
    char *comment;
@


1.3
log
@New Arla userland from Arla between 0.34.2 and current in arla cvs.
Too many new features and fixes to mention here.
@
text
@d17 1
a17 6
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by the Kungliga Tekniska
 *      Högskolan and its contributors.
 * 
 * 4. Neither the name of the Institute nor the names of its contributors
d40 1
a40 1
RCSID("$Id: fprio.c,v 1.8 2000/02/12 16:57:42 assar Exp $");
@


1.2
log
@upgrade Arla to fresher code. Too many new features and bugfixes.
@
text
@a0 1
/*	$OpenBSD$	*/
d2 1
a2 1
 * Copyright (c) 1998, 1999 Kungliga Tekniska Högskolan
d45 1
a45 1
RCSID("$KTH: fprio.c,v 1.6 1999/04/20 20:58:08 map Exp $");
d162 1
a162 1
fprio_set(VenusFid fid, unsigned prio)
d232 1
a232 1
	fprio_set(fid, prio);
d241 1
a241 1
int 
d252 1
a252 1
    return 0;
d272 2
a273 3
	     comment, n->priority, cell?cell:"unknowncell", n->fid.fid.Volume, 
	     n->fid.fid.Vnode, n->fid.fid.Unique);

d286 1
a286 2
    arla_log(ADEBVLOG, "#fprio entries\n#\n#  Date: %s\n#\n"
	     "#priority range from %d to %d\n#\n"
d289 1
a289 1
	     ctime(&the_time), FPRIO_MIN, FPRIO_MAX);
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
 * Copyright (c) 1998 Kungliga Tekniska Högskolan
d45 2
a46 2
#include <kerberosIV/kafs.h>
RCSID("$KTH: fprio.c,v 1.3 1998/06/08 18:55:13 lha Exp $");
d205 1
a205 2
    if (f == NULL) {
	arla_warn(ADEBFCACHE, 1, "fprio_readin: cant open file %s", file);
a206 1
    }
a263 1
    FILE *f = (FILE *) ptr;
d272 3
a274 3
    fprintf(f, "%s%d:%s:%d:%d:%d", 
	    comment, n->priority, cell?cell:"unknowncell", n->fid.fid.Volume, 
	    n->fid.fid.Vnode, n->fid.fid.Unique);
d284 1
a284 1
fprio_status (FILE *f)
d288 1
a288 1
    fprintf (f, "#fprio entries\n#\n#  Date: %s\n#\n"
d293 1
a293 1
    hashtabforeach (fpriohashtab, fprio_print_entry, f);
@


1.1.1.1
log
@Initial version of Arla, a free implementation of an AFS cache-manager.
(second try, hopefully into the correct repository this time)
@
text
@@


1.1.1.2
log
@Import of arla-0.35.7
@
text
@d1 1
d3 1
a3 1
 * Copyright (c) 1998 - 2000 Kungliga Tekniska Högskolan
d18 6
a23 1
 * 3. Neither the name of the Institute nor the names of its contributors
d45 2
a46 2
#include <kafs.h>
RCSID("$KTH: fprio.c,v 1.9 2000/10/02 22:31:43 lha Exp $");
d163 1
a163 1
fprio_set(VenusFid fid, Bool prio)
d205 2
a206 1
    if (f == NULL)
d208 1
d235 1
a235 1
	fprio_set(fid, prio ? TRUE : FALSE);
d244 1
a244 1
Bool
d255 1
a255 1
    return FALSE;
d266 1
d275 4
a278 3
    arla_log(ADEBVLOG, "%s%d:%s:%d:%d:%d", 
	     comment, n->priority == TRUE ? 1 : 0, cell?cell:"unknowncell", 
	     n->fid.fid.Volume, n->fid.fid.Vnode, n->fid.fid.Unique);
d287 1
a287 1
fprio_status (void)
d291 2
a292 1
    arla_log(ADEBVLOG, "#fprio entries\n#\n#  Date: %s\n#"
d295 2
a296 2
	     ctime(&the_time));
    hashtabforeach (fpriohashtab, fprio_print_entry, NULL);
@


1.1.1.3
log
@Import of arla -current as of Aug 5 2003

ok todd@@ deraadt@@
@
text
@d40 1
a40 1
RCSID("$arla: fprio.c,v 1.12 2002/10/02 00:54:21 lha Exp $");
d202 1
a202 1
    while(fgets(line, sizeof(line), f) != NULL) {
a204 2
	line[strcspn(line, "\n")] = '\0';

d259 1
a259 1
    const char *comment;
@


