head	1.6;
access;
symbols
	OPENBSD_5_2:1.5.0.38
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.36
	OPENBSD_5_0:1.5.0.34
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.32
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.30
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.26
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.5.0.28
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.5.0.24
	OPENBSD_4_5_BASE:1.5
	OPENBSD_4_4:1.5.0.22
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3:1.5.0.20
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.5.0.18
	OPENBSD_4_2_BASE:1.5
	OPENBSD_4_1:1.5.0.16
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.5.0.14
	OPENBSD_4_0_BASE:1.5
	OPENBSD_3_9:1.5.0.12
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.5.0.10
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.8
	OPENBSD_3_7_BASE:1.5
	OPENBSD_3_6:1.5.0.6
	OPENBSD_3_6_BASE:1.5
	OPENBSD_3_5:1.5.0.4
	OPENBSD_3_5_BASE:1.5
	OPENBSD_3_4:1.5.0.2
	OPENBSD_3_4_BASE:1.5
	arla-20030805:1.1.1.3
	OPENBSD_3_3:1.4.0.4
	OPENBSD_3_3_BASE:1.4
	OPENBSD_3_2:1.4.0.2
	OPENBSD_3_2_BASE:1.4
	arla-0-35-7:1.1.1.2
	OPENBSD_3_1:1.3.0.8
	OPENBSD_3_1_BASE:1.3
	OPENBSD_3_0:1.3.0.6
	OPENBSD_3_0_BASE:1.3
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_9:1.3.0.4
	OPENBSD_2_8:1.3.0.2
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.2.0.4
	OPENBSD_2_7_BASE:1.2
	OPENBSD_2_6:1.2.0.2
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.1.1.1.0.4
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.2
	OPENBSD_2_4_BASE:1.1.1.1
	arla-0_9:1.1.1.1
	arla:1.1.1;
locks; strict;
comment	@ * @;


1.6
date	2012.08.23.06.21.50;	author deraadt;	state dead;
branches;
next	1.5;

1.5
date	2003.08.05.08.42.41;	author hin;	state Exp;
branches;
next	1.4;

1.4
date	2002.06.07.04.28.57;	author hin;	state Exp;
branches;
next	1.3;

1.3
date	2000.09.11.14.40.39;	author art;	state Exp;
branches;
next	1.2;

1.2
date	99.04.30.01.59.06;	author art;	state Exp;
branches;
next	1.1;

1.1
date	98.09.14.21.52.54;	author art;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.09.14.21.52.54;	author art;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.06.07.04.14.22;	author hin;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2003.08.05.08.21.00;	author hin;	state Exp;
branches;
next	;


desc
@@


1.6
log
@the afs src tree can go away
@
text
@/*
 * Copyright (c) 1995 - 2002 Kungliga Tekniska Högskolan
 * (Royal Institute of Technology, Stockholm, Sweden).
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * Routines for reading an AFS directory
 */

#include "arla_local.h"

RCSID("$arla: adir.c,v 1.73 2002/07/24 05:56:27 lha Exp $") ;

/*
 *
 */

static int
get_fbuf_from_centry (CredCacheEntry **ce,
		      int *fd, fbuf *fbuf,
		      FCacheEntry **centry,
		      int open_flags, int fbuf_flags)
{
    int ret;

    ret = fcache_get_data (centry, ce, 0);
    if (ret)
	return ret;

    ret = fcache_get_fbuf (*centry, fd, fbuf, open_flags, fbuf_flags);
    if (ret) {
	return ret;
    }
    return 0;
}

/*
 * Lookup `name' in the AFS directory identified by `centry' and return
 * the Fid in `file'.  All operations are done as `cred' and return
 * value is 0 or error code.
 *
 *
 * Locking:
 *            In        Out       Fail
 *    centry: Locked    Locked    Locked
 *  
 */

int
adir_lookup (FCacheEntry *centry, const char *name, VenusFid *file)
{
     int ret;
     int fd;
     fbuf the_fbuf;

     ret = fcache_get_fbuf (centry, &fd, &the_fbuf, O_RDONLY,
			    FBUF_READ|FBUF_PRIVATE);
     if (ret)
	 return ret;

     ret = fdir_lookup (&the_fbuf, &centry->fid, name, file);
     fbuf_end (&the_fbuf);
     close (fd);
     return ret;
}

/*
 * Lookup `name' in the AFS directory identified by `dir' and change the
 * fid to `fid'.
 */

int
adir_changefid (FCacheEntry **centry,
		const char *name,
		VenusFid *file,
		CredCacheEntry **ce)
{
    int ret;
    int fd;
    fbuf the_fbuf;

    ret = get_fbuf_from_centry (ce, &fd, &the_fbuf, centry, O_RDWR, 
				FBUF_READ|FBUF_WRITE|FBUF_SHARED);
    if (ret)
	return ret;

    ret = fdir_changefid (&the_fbuf, name, file);
    fbuf_end (&the_fbuf);
    close (fd);
    return ret;
}

/*
 * Return TRUE if dir is empty.
 */

int
adir_emptyp (FCacheEntry **centry,
	     CredCacheEntry **ce)
{
     int ret;
     int fd;
     fbuf the_fbuf;

     ret = get_fbuf_from_centry (ce, &fd, &the_fbuf, centry,
				 O_RDONLY, FBUF_READ|FBUF_PRIVATE);
     if (ret)
	 return ret;

     ret = fdir_emptyp (&the_fbuf);
     fbuf_end (&the_fbuf);
     close (fd);
     return ret;
}

/*
 * Read all entries in the AFS directory identified by `dir' and call
 * `func' on each entry with the fid, the name, and `arg'.
 */

int
adir_readdir (FCacheEntry **centry,
	      fdir_readdir_func func,
	      void *arg,
	      CredCacheEntry **ce)
{
     int fd;
     fbuf the_fbuf;
     int ret;

     ret = get_fbuf_from_centry (ce, &fd, &the_fbuf, centry,
				 O_RDONLY, FBUF_READ|FBUF_PRIVATE);
     if (ret)
	 return ret;

     ret = fdir_readdir (&the_fbuf, func, arg, (*centry)->fid, NULL);
     fbuf_end (&the_fbuf);
     close (fd);
     return ret;
}

/*
 * Create a new directory with only . and ..
 */

int
adir_mkdir (FCacheEntry *dir,
	    AFSFid dot,
	    AFSFid dot_dot)
{
    int fd;
    fbuf the_fbuf;
    int ret;

    AssertExclLocked(&dir->lock);

    ret = fcache_get_fbuf (dir, &fd, &the_fbuf, O_RDWR,
			   FBUF_READ|FBUF_WRITE|FBUF_SHARED);
    if (ret)
	return ret;

    ret = fdir_mkdir (&the_fbuf, dot, dot_dot);
    fcache_update_length (dir, fbuf_len(&the_fbuf), fbuf_len(&the_fbuf));
    fbuf_end (&the_fbuf);
    close (fd);
    return ret;
}

/*
 * Create a new entry with name `filename' and contents `fid' in `dir'.
 */

int
adir_creat (FCacheEntry *dir,
	    const char *name,
	    AFSFid fid)
{
    int fd;
    fbuf the_fbuf;
    int ret;

    ret = fcache_get_fbuf (dir, &fd, &the_fbuf, O_RDWR, 
			   FBUF_READ|FBUF_WRITE|FBUF_SHARED);
    if (ret)
	return ret;

    ret = fdir_creat (&the_fbuf, name, fid);
    fcache_update_length (dir, fbuf_len(&the_fbuf), fbuf_len(&the_fbuf));
    fbuf_end (&the_fbuf);
    close (fd);
    return ret;
}

/*
 * Remove the entry named `name' in dir.
 */

int
adir_remove (FCacheEntry *dir,
	     const char *name)
{
    int fd;
    fbuf the_fbuf;
    int ret;

    ret = fcache_get_fbuf (dir, &fd, &the_fbuf, O_RDWR, 
			   FBUF_READ|FBUF_WRITE|FBUF_SHARED);
    if (ret)
	return ret;

    ret = fdir_remove(&the_fbuf, name, NULL);
    fcache_update_length (dir, fbuf_len(&the_fbuf), fbuf_len(&the_fbuf));
    fbuf_end (&the_fbuf);
    close (fd);
    return ret;
}
@


1.5
log
@Merge
@
text
@@


1.4
log
@merge
@
text
@d2 1
a2 1
 * Copyright (c) 1995 - 2000 Kungliga Tekniska Högskolan
d40 1
a40 1
RCSID("$KTH: adir.c,v 1.66.2.1 2001/06/04 22:16:34 ahltorp Exp $") ;
d47 4
a50 4
get_fbuf_from_fid (VenusFid *fid, CredCacheEntry **ce,
		   int *fd, fbuf *fbuf,
		   FCacheEntry **centry,
		   int open_flags, int fbuf_flags)
d54 1
a54 1
    ret = fcache_get_data (centry, fid, ce);
a59 1
	fcache_release(*centry);
d101 1
a101 1
adir_changefid (VenusFid *dir,
a105 1
    FCacheEntry *centry;
d110 2
a111 2
    ret = get_fbuf_from_fid (dir, ce, &fd, &the_fbuf, &centry, O_RDWR, 
			     FBUF_READ|FBUF_WRITE|FBUF_SHARED);
a117 1
    fcache_release (centry);
d126 1
a126 1
adir_emptyp (VenusFid *dir,
a128 1
     FCacheEntry *centry;
d133 2
a134 2
     ret = get_fbuf_from_fid (dir, ce, &fd, &the_fbuf, &centry,
			      O_RDONLY, FBUF_READ|FBUF_PRIVATE);
a140 1
     fcache_release (centry);
d150 2
a151 2
adir_readdir (VenusFid *dir,
	      void (*func)(VenusFid *, const char *, void *), 
a156 1
     FCacheEntry *centry;
d159 2
a160 2
     ret = get_fbuf_from_fid (dir, ce, &fd, &the_fbuf, &centry,
			      O_RDONLY, FBUF_READ|FBUF_PRIVATE);
d164 1
a164 1
     ret = fdir_readdir (&the_fbuf, func, arg, dir);
a166 1
     fcache_release (centry);
d191 1
a191 1
    fcache_update_length (dir, fbuf_len(&the_fbuf));
d216 1
a216 1
    fcache_update_length (dir, fbuf_len(&the_fbuf));
d240 1
a240 1
    fcache_update_length (dir, fbuf_len(&the_fbuf));
@


1.3
log
@New Arla userland from Arla between 0.34.2 and current in arla cvs.
Too many new features and fixes to mention here.
@
text
@d17 1
a17 6
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by the Kungliga Tekniska
 *      Högskolan and its contributors.
 * 
 * 4. Neither the name of the Institute nor the names of its contributors
d40 1
a40 1
RCSID("$Id: adir.c,v 1.64 2000/06/05 02:04:51 assar Exp $") ;
d79 1
a79 5
adir_lookup_fcacheentry (FCacheEntry *centry,
			 VenusFid dir,
			 const char *name,
			 VenusFid *file,
			 CredCacheEntry *ce)
d90 1
a90 1
     ret = fdir_lookup (&the_fbuf, &dir, name, file);
a96 40
 * Lookup ``name'' in the AFS directory identified by ``dir'' and
 * return the Fid in ``file''.  All operations are done as ``cred''
 * and return value is 0 or error code. If ``dentry'' is set, its the
 * entry of the ``dir'' if returnvalue is 0.
 */

int
adir_lookup (VenusFid *dir,
	     const char *name,
	     VenusFid *file,
	     FCacheEntry **dentry, 
	     CredCacheEntry **ce)
{
    int fd;
    fbuf the_fbuf;
    FCacheEntry *centry;
    int ret;

    ret = get_fbuf_from_fid (dir, ce, &fd, &the_fbuf, &centry, O_RDONLY, 
			     FBUF_READ|FBUF_PRIVATE);
    if (ret)
	return ret;

    ret = fdir_lookup (&the_fbuf, dir, name, file);
    fbuf_end (&the_fbuf);
    close (fd);
    if (dentry) {
	if (ret) {
	    *dentry = NULL;
	    fcache_release (centry);
	} else {
	    *dentry = centry;
	}
    } else {
	fcache_release (centry);
    }
    return ret;
}

/*
d190 1
a190 1
    assert (CheckLock(&dir->lock) == -1);
@


1.2
log
@upgrade Arla to fresher code. Too many new features and bugfixes.
@
text
@a0 1
/*	$OpenBSD$	*/
d2 1
a2 1
 * Copyright (c) 1995, 1996, 1997, 1998 Kungliga Tekniska Högskolan
d45 1
a45 1
RCSID("$KTH: adir.c,v 1.55 1998/12/25 04:39:55 assar Exp $") ;
d48 1
a48 124
 * Hash the filename of one entry.
 */

static unsigned
hashentry (const unsigned char *entry)
{
     int s = 0, h;

     while (*entry)
	  s = s * 173 + *entry++;
     h = s & (ADIRHASHSIZE - 1);
     if (h == 0)
	  return h;
     else if( s < 0 )
	  h = ADIRHASHSIZE - h;
     return h;
}

/*
 * Return the number of additional DirEntries used by an entry with
 * the filename `name`.
 */

static unsigned
additional_entries (const char *filename)
{
    static DirEntry dummy;

    return (strlen(filename) - sizeof(dummy.name) + 1
	    + sizeof(DirEntry) - 1)
	/ sizeof(DirEntry);
}

/*
 * Return a pointer to page number `pageno'.
 */

static DirPage1 *
getpage (DirPage0 *page0, unsigned pageno)
{
    return (DirPage1 *)((char *)page0 + AFSDIR_PAGESIZE * pageno);
}

/*
 * Return the entry `num' in the directory `page0'.
 * The directory must be continuous in memory after page0.
 */

static DirEntry *
getentry (DirPage0 *page0,
	  unsigned short num)
{
     DirPage1 *page = getpage (page0, num / ENTRIESPERPAGE);

     assert (page->header.pg_tag == htons(AFSDIRMAGIC));
     return &page->entry[num % ENTRIESPERPAGE];
}

/*
 * Return a pointer to the entry with name `name' in the directory `page0'.
 */

static DirEntry *
find_entry(DirPage0 *page0, const char *name)
{
    DirEntry *entry;
    unsigned i;

    for (i = ntohs(page0->dheader.hash[hashentry (name)]);
	 i != 0;
	 i = ntohs(entry->next)) {
	entry = getentry (page0, i - 1);

	if (strcmp (entry->name, name) == 0)
	    return entry;
    }
    return NULL;
}

/*
 * Return the fid for the entry with `name' in `page0'.  `fid' is set
 * to the fid of that file.  `dir' should be the fid of the directory.
 * Return zero if succesful, and -1 otherwise.
 */

static int
find_by_name (DirPage0 *page0,
	      const char *name,
	      VenusFid *fid,
	      const VenusFid *dir)
{
    const DirEntry *entry = find_entry (page0, name);

    if (entry == NULL)
	return -1;
    fid->Cell       = dir->Cell;
    fid->fid.Volume = dir->fid.Volume;
    fid->fid.Vnode  = ntohl (entry->fid.Vnode);
    fid->fid.Unique = ntohl (entry->fid.Unique);
    return 0;
}

/*
 * Change the fid for `name' to `fid'.  Return 0 or -1.
 */

static int
update_fid_by_name (DirPage0 *page0,
		    const char *name,
		    const VenusFid *fid,
		    const VenusFid *dir)
{
    DirEntry *entry = find_entry (page0, name);

    if (entry == NULL)
	return -1;

    entry->fid.Vnode = htonl (fid->fid.Vnode);
    entry->fid.Vnode = htonl (fid->fid.Unique);
    return 0;
}

/*
 * Return true if slot `off' on `page' is being used.
d52 4
a55 55
used_slot (DirPage1 *page, int off)
{
    return page->header.pg_bitmap[off / 8] & (1 << (off % 8));
}

/*
 * Mark slot `off' on `page' as being used.
 */

static void
set_used (DirPage1 *page, int off)
{
    page->header.pg_bitmap[off / 8] |= 1 << (off % 8);
}

/*
 * Mark slot `off' on `page' as not being used.
 */

static void
set_unused (DirPage1 *page, int off)
{
    page->header.pg_bitmap[off / 8] &= ~(1 << (off % 8));
}

/*
 * Is this page `pageno' empty?
 */

static int
is_page_empty (DirPage0 *page0, unsigned pageno)
{
    DirPage1 *page;
    int i;

    if (pageno < MAXPAGES)
	return page0->dheader.map[pageno] == ENTRIESPERPAGE - 1;
    page = getpage (page0, pageno);
    if (page->header.pg_bitmap[0] != 1)
	return 0;
    for (i = 1; i < sizeof(page->header.pg_bitmap); ++i)
	if (page->header.pg_bitmap[i] != 0)
	    return 0;
    return 1;
}

/*
 * Add a new page to the directory in `the_fbuf', returning a pointer
 * to the new page in `ret_page'.
 * Return 0 iff succesful.
 */

static int
create_new_page (DirPage1 **ret_page,
		 fbuf *the_fbuf)
a57 2
    DirPage1 *page1;
    size_t len = the_fbuf->len;
d59 1
a59 1
    ret = fbuf_truncate (the_fbuf, len + AFSDIR_PAGESIZE);
d63 4
a66 54
    page1 = (DirPage1 *)((char *)(the_fbuf->buf) + len);
    page1->header.pg_pgcount   = htons(0);
    page1->header.pg_tag       = htons(AFSDIRMAGIC);
    page1->header.pg_freecount = ENTRIESPERPAGE - 1;
    memset (page1->header.pg_bitmap, 0, sizeof(page1->header.pg_bitmap));
    set_used (page1, 0);
    *ret_page = page1;

    return 0;
}

/*
 * Create a new entry with name `filename', fid `fid', and next
 * pointer `next' in the page `page' with page number `pageno'.
 * Return the index in the page or -1 if unsuccesful.
 */

static int
add_to_page (DirPage0 *page0,
	     DirPage1 *page,
	     unsigned pageno,
	     const char *filename,
	     AFSFid fid,
	     unsigned next)
{
    int i, j;
    unsigned n;

    n = 1 + additional_entries (filename);

    if (pageno < MAXPAGES && page0->dheader.map[pageno] < n)
	return -1;

    for (i = 0; i < ENTRIESPERPAGE - n;) {
	for (j = 0; j < n && !used_slot (page, i + j + 1); ++j)
	    ;
	if (j == n) {
	    int k;

	    for (k = i + 1; k < i + j + 1; ++k)
		page->header.pg_bitmap[k / 8] |= (1 << (k % 8));

	    page->entry[i].flag = 1;
	    page->entry[i].length = 0;
	    page->entry[i].next = next;
	    page->entry[i].fid.Vnode  = htonl(fid.Vnode);
	    page->entry[i].fid.Unique = htonl(fid.Unique);
	    strcpy (page->entry[i].name, filename);
	    memset(page->entry[i + j - 1].fill, 0, 4);
	    if (pageno < MAXPAGES)
		page0->dheader.map[pageno] -= n;
	    return i;
	}
	i += j + 1;
a67 27
    return -1;
}

/*
 * Remove the entry `off' from the page `page' (page number `pageno').
 */

static int
remove_from_page (DirPage0 *page0,
		  DirPage1 *page,
		  unsigned pageno,
		  unsigned off)
{
    DirEntry *entry = &page->entry[off];
    unsigned n, i;

    n = 1 + additional_entries (entry->name);

    if (pageno < MAXPAGES)
	page0->dheader.map[pageno] += n;

    entry->next = 0;
    entry->fid.Vnode  = 0;
    entry->fid.Unique = 0;

    for (i = off + 1; i < off + n + 1; ++i)
	set_unused (page, i);
d85 1
d90 1
a91 5
     DirPage0 *page0;
     unsigned ind;
     unsigned len;
     int ret;
     int close_ret;
a92 1
     struct stat sb;
d94 3
a96 27
     assert (CheckLock (&centry->lock) == -1);

     if (centry->status.FileType != TYPE_DIR) {
	 return ENOTDIR;
     }

     assert (CheckLock (&centry->lock) == -1);

     fd = fcache_open_file (centry, O_RDONLY);
     if (fd < 0) {
	 return errno;
     }

     assert (CheckLock (&centry->lock) == -1);

     if (fstat (fd, &sb)) {
	 close_ret = close (fd);
	 assert (close_ret == 0);
	 return errno;
     }

     len = sb.st_size;

     assert (CheckLock (&centry->lock) == -1);

     ret = fbuf_create (&the_fbuf, fd, len, FBUF_READ);
     if (ret) 
d99 1
a99 4
     assert (CheckLock (&centry->lock) == -1);

     page0 = (DirPage0 *)(the_fbuf.buf);
     ind = find_by_name (page0, name, file, &centry->fid);
d101 2
a102 5

     if (ind == 0)
	 return 0;
     else
	 return ENOENT;
d106 4
a109 3
 * Lookup `name' in the AFS directory identified by `dir' and return
 * the Fid in `file'.  All operations are done as `cred' and return
 * value is 0 or error code.
d113 1
a113 1
adir_lookup (VenusFid dir,
d116 2
a117 1
	     CredCacheEntry *ce)
d119 2
d124 2
a125 1
    ret = fcache_get (&centry, dir, ce);
d128 12
a139 5
    
    assert (CheckLock (&centry->lock) == -1);
    
    ret = fcache_get_data (centry, ce);
    if (ret) {
a140 1
	return ret;
a141 5
    
    ret = adir_lookup_fcacheentry (centry, name, file, ce);

    fcache_release (centry);
    
a142 1
	
d151 1
a151 1
adir_changefid (VenusFid dir,
d154 1
a154 1
		CredCacheEntry *ce)
a155 2
    int fd;
    DirPage0 *page0;
a156 1
    unsigned len;
d158 1
a158 1
    int close_ret;
a159 1
    struct stat sb;
d161 2
a162 1
    ret = fcache_get (&centry, dir, ce);
d166 1
a166 35
    ret = fcache_get_data (centry, ce);
    if (ret) {
	fcache_release (centry);
	return ret;
    }

    if (centry->status.FileType != TYPE_DIR) {
	fcache_release(centry);
	return ENOTDIR;
    }

    fd = fcache_open_file (centry, O_RDWR);
    if (fd < 0) {
	fcache_release(centry);
	return errno;
    }

    if (fstat (fd, &sb)) {
	close_ret = close (fd);
	assert (close_ret == 0);
	fcache_release(centry);
	return errno;
    }

    len = sb.st_size;

    ret = fbuf_create (&the_fbuf, fd, len, FBUF_WRITE);
    if (ret) {
	fcache_release(centry);
	return ret;
    }

    page0 = (DirPage0 *)(the_fbuf.buf);
    ret = update_fid_by_name (page0, name, file, &dir);
    fcache_release(centry);
d168 3
a170 5

    if (ret == 0)
	return 0;
    else
	return ENOENT;
d178 2
a179 2
adir_emptyp (VenusFid dir,
	     CredCacheEntry *ce)
a180 2
     int fd;
     DirPage0 *page0;
a181 1
     unsigned len;
d183 1
a183 1
     int close_ret;
a184 2
     struct stat sb;
     unsigned npages;
d186 2
a187 1
     ret = fcache_get (&centry, dir, ce);
d191 1
a191 35
     ret = fcache_get_data (centry, ce);
     if (ret) {
	 fcache_release (centry);
	 return ret;
     }

     if (centry->status.FileType != TYPE_DIR) {
	 fcache_release (centry);
	 return ENOTDIR;
     }

     fd = fcache_open_file (centry, O_RDONLY);
     if (fd < 0) {
	 fcache_release(centry);
	 return errno;
     }

     if (fstat (fd, &sb)) {
	 fcache_release(centry);
	 close_ret = close (fd);
	 assert (close_ret == 0);
	 return errno;
     }

     len = sb.st_size;

     ret = fbuf_create (&the_fbuf, fd, len, FBUF_READ);
     if (ret) {
	 fcache_release(centry);
	 return ret;
     }
     page0 = (DirPage0 *)(the_fbuf.buf);
     npages = ntohs(page0->header.pg_pgcount);

     ret = (npages == 1) && (page0->dheader.map[0] == 2);
d193 1
d204 1
a204 1
adir_readdir (VenusFid dir,
d207 1
a207 1
	      CredCacheEntry *ce)
a210 2
     DirPage0 *page0;
     unsigned i, j;
a212 5
     int close_ret;
     VenusFid fid;
     unsigned len;
     struct stat sb;
     unsigned npages;
d214 2
a215 1
     ret = fcache_get (&centry, dir, ce);
d219 1
a219 64
     ret = fcache_get_data (centry, ce);
     if (ret) {
	 fcache_release (centry);
	 return ret;
     }

     if (centry->status.FileType != TYPE_DIR) {
	 fcache_release (centry);
	 return ENOTDIR;
     }

     fd = fcache_open_file (centry, O_RDONLY);
     if (fd < 0) {
	 fcache_release(centry);
	 return errno;
     }

     if (fstat (fd, &sb)) {
	 fcache_release(centry);
	 close_ret = close (fd);
	 assert (close_ret == 0);
	 return errno;
     }

     len = sb.st_size;

     ret = fbuf_create (&the_fbuf, fd, len, FBUF_READ);
     if (ret) {
	 fcache_release(centry);
	 return ret;
     }
     page0 = (DirPage0 *)(the_fbuf.buf);
     npages = ntohs(page0->header.pg_pgcount);

     if (npages < len / AFSDIR_PAGESIZE)
	 npages = len / AFSDIR_PAGESIZE;

     for (i = 0; i < npages; ++i) {
	 DirPage1 *page = getpage (page0, i);
	 unsigned first_slot;

	 if (i == 0)
	     first_slot = 12;
	 else
	     first_slot = 0;

	 for (j = first_slot; j < ENTRIESPERPAGE - 1; ++j) {
	     if (used_slot (page, j + 1)) {
		 DirEntry *entry = &page->entry[j];

		 assert (entry->flag);

		 fid.Cell       = dir.Cell;
		 fid.fid.Volume = dir.fid.Volume;
		 fid.fid.Vnode  = ntohl (entry->fid.Vnode);
		 fid.fid.Unique = ntohl (entry->fid.Unique);

		 (*func)(&fid, entry->name, arg);

		 j += additional_entries (entry->name);
	     }
	 }
     }

d221 3
a223 2
     fcache_release(centry);
     return 0;
d235 1
a237 7
    int fd;
    DirPage0 *page0;
    DirPage1 *page;
    int ind;
    int i;
    int tmp;
    int close_ret;
d241 2
a242 11
    fd = fcache_open_file (dir, O_RDWR);
    if (fd < 0)
	return errno;

    if (ftruncate (fd, 0) < 0) {
	close_ret = close (fd);
	assert (close_ret == 0);
	return errno;
    }

    ret = fbuf_create (&the_fbuf, fd, 0, FBUF_WRITE);
d246 1
a246 32
    ret = create_new_page (&page, &the_fbuf);
    if (ret)
	goto out;

    page0 = (DirPage0 *)(the_fbuf.buf);
    memset (&page0->dheader, 0, sizeof(page0->dheader));
    tmp = ENTRIESPERPAGE
	- (sizeof(PageHeader) + sizeof(DirHeader)) / sizeof(DirEntry);
    page0->header.pg_freecount = tmp;
    page0->dheader.map[0]      = tmp;
    page0->header.pg_pgcount   = htons(1);

    for (i = 0; i < 13; ++i)
	set_used (page, i);

    assert (page0->dheader.hash[hashentry(".")] == 0);

    ind = add_to_page (page0, page, 0, ".", dot, 0);

    assert (ind >= 0);

    page0->dheader.hash[hashentry(".")] = htons(ind + 1);

    assert (page0->dheader.hash[hashentry("..")] == 0);

    ind = add_to_page (page0, page, 0, "..", dot_dot, 0);

    assert (ind >= 0);

    page0->dheader.hash[hashentry("..")] = htons(ind + 1);

out:
d249 1
d262 1
a264 24
    int close_ret;
    int fd;
    int i;
    size_t len;
    unsigned npages;
    DirPage0 *page0;
    DirPage1 *page;
    int ind = 0;
    unsigned hash_value, next;
    struct stat statbuf;

    assert (CheckLock(&dir->lock) == -1);

    assert (dir->flags.datap);

    fd = fcache_open_file (dir, O_RDWR);
    if (fd < 0)
	return errno;

    if(fstat (fd, &statbuf) < 0) {
	close_ret = close (fd);
	assert (close_ret == 0);
	return errno;
    }
d266 2
a267 3
    len = statbuf.st_size;

    ret = fbuf_create (&the_fbuf, fd, len, FBUF_WRITE);
d271 1
a271 32
    assert (the_fbuf.len != 0);

    page0 = (DirPage0 *)(the_fbuf.buf);
    npages = ntohs(page0->header.pg_pgcount);

    assert (npages == the_fbuf.len / AFSDIR_PAGESIZE);

    hash_value = hashentry (name);
    next = page0->dheader.hash[hash_value];

    for (i = 0; i < npages; ++i) {
	page = getpage (page0, i);
	ind = add_to_page (page0, page, i, name, fid, next);
	if (ind >= 0)
	    break;
    }
    if (i == npages) {
	ret = create_new_page (&page, &the_fbuf);
	if (ret)
	    goto out;
	page0 = (DirPage0 *)(the_fbuf.buf);
	page0->header.pg_pgcount = htons(npages + 1);
	if (i < MAXPAGES)
	    page0->dheader.map[i] = ENTRIESPERPAGE - 1;
	ind = add_to_page (page0, page, i, name, fid, next);
	assert (ind >= 0);
    }
    ind += i * ENTRIESPERPAGE;

    page0->dheader.hash[hash_value] = htons(ind + 1);
    
out:
d274 1
d286 1
a288 13
    int close_ret;
    int fd;
    int i;
    unsigned len;
    DirPage0 *page0;
    DirPage1 *page;
    unsigned hash_value;
    DirEntry *entry = NULL;
    DirEntry *prev_entry;
    unsigned pageno;
    int found;
    struct stat sb;
    unsigned npages;
d290 3
a292 20
    assert (CheckLock(&dir->lock) == -1);

    assert (dir->flags.datap);

    fd = fcache_open_file (dir, O_RDWR);
    if (fd < 0)
	return errno;

    if (fstat (fd, &sb)) {
	close_ret = close (fd);
	assert (close_ret == 0);
	return errno;
    }

    assert (dir->status.Length == sb.st_size);

    len = sb.st_size;

    ret = fbuf_create (&the_fbuf, fd, len, FBUF_WRITE);
    if (ret) {
a293 1
    }
d295 5
a299 44
    page0 = (DirPage0 *)(the_fbuf.buf);
    npages = ntohs(page0->header.pg_pgcount);
    hash_value = hashentry (name);
    i = ntohs(page0->dheader.hash[hash_value]);
    found = i == 0;
    prev_entry = NULL;
    while (!found) {
	entry = getentry (page0, i - 1);

	if (strcmp (entry->name, name) == 0) {
	    found = TRUE;
	} else {
	    i = ntohs(entry->next);
	    if (i == 0)
		found = TRUE;
	    prev_entry = entry;
	}
    }
    if (i == 0) {
	fbuf_end (&the_fbuf);
	return ENOENT;
    } else {
	if (prev_entry == NULL)
	    page0->dheader.hash[hash_value] = entry->next;
	else
	    prev_entry->next = entry->next;

	pageno = (i - 1) / ENTRIESPERPAGE;
	page = getpage (page0, pageno);
	remove_from_page (page0, page, pageno, (i - 1) % ENTRIESPERPAGE);
	if (pageno == npages - 1
	    && is_page_empty (page0, pageno)) {
	    do {
		len -= AFSDIR_PAGESIZE;
		--pageno;
		--npages;
	    } while(is_page_empty(page0, pageno));
	    page0->header.pg_pgcount = htons(npages);
	    fbuf_truncate (&the_fbuf, len);
	    fcache_update_length (dir, len);
	}
	fbuf_end (&the_fbuf);
	return 0;
    }
@


1.1
log
@Initial revision
@
text
@d46 1
a46 1
RCSID("$KTH: adir.c,v 1.33 1998/07/29 14:38:51 assar Exp $") ;
d53 1
a53 1
hashentry (const char *entry)
d68 27
a94 2
 * Return the entry in the directory given the number.
 * The directory must be contiounsly in memory after page0.
d101 1
a101 1
     DirPage1 *page;
a102 2
     page = (DirPage1 *)((char *)page0 +
			 AFSDIR_PAGESIZE * (num / ENTRIESPERPAGE));
d108 1
a108 1
 *
d111 2
a112 5
static unsigned
find_by_name (DirPage0 *page0,
	      const char *name,
	      VenusFid *fid,
	      const VenusFid *dir)
d114 1
d117 4
a120 3
    i = ntohs(page0->dheader.hash[hashentry (name)]);
    while (i != 0) {
	const DirEntry *entry = getentry (page0, i - 1);
d122 2
a123 8
	if (strcmp (entry->name, name) == 0) {
	    fid->Cell = dir->Cell;
	    fid->fid.Volume = dir->fid.Volume;
	    fid->fid.Vnode  = ntohl (entry->fid.Vnode);
	    fid->fid.Unique = ntohl (entry->fid.Unique);
	    return i;
	}
	i = ntohs(entry->next);
d125 1
a125 1
    return i;
a127 1

d129 3
a131 3
 * Lookup `name' in the AFS directory identified by `dir' and return
 * the Fid in `file'.  All operations are done as `cred' and return
 * value is 0 or error code.
d134 5
a138 5
int
adir_lookup (VenusFid dir,
	     const char *name,
	     VenusFid *file,
	     CredCacheEntry *ce)
d140 1
a140 8
     int fd;
     DirPage0 *page0;
     FCacheEntry *centry;
     unsigned ind;
     unsigned len;
     int ret;
     fbuf the_fbuf;
     struct stat sb;
d142 7
a148 51
     ret = fcache_get (&centry, dir, ce);
     if (ret) {
	 ReleaseWriteLock (&centry->lock);
	 return ret;
     }

     ret = fcache_get_data (centry, ce);
     if (ret) {
	 ReleaseWriteLock (&centry->lock);
	 return ret;
     }

     if (centry->status.FileType != TYPE_DIR) {
	 ReleaseWriteLock (&centry->lock);
	 return ENOTDIR;
     }

#if 0
     len = centry->status.Length;
#endif

     fd = fcache_open_file (centry, O_RDONLY, 0);
     if (fd < 0) {
	 ReleaseWriteLock (&centry->lock);
	 return errno;
     }

     if (fstat (fd, &sb)) {
	 close (fd);
	 ReleaseWriteLock (&centry->lock);
	 return errno;
     }

     len = sb.st_size;

     ret = fbuf_create (&the_fbuf, fd, len, FBUF_READ);
     if (ret) {
	 close (fd);
	 ReleaseWriteLock (&centry->lock);
	 return ret;
     }

     page0 = (DirPage0 *)(the_fbuf.buf);
     ind = find_by_name (page0, name, file, &dir);

     fbuf_end (&the_fbuf);
     ReleaseWriteLock (&centry->lock);
     if (ind != 0)
	  return 0;
     else
	  return ENOENT;
d152 1
a152 2
 * Read all entries in the AFS directory identified by `dir' and call
 * `func' on each entry with the fid, the name, and `arg'.
d155 5
a159 5
int
adir_readdir (VenusFid dir,
	      void (*func)(VenusFid *, const char *, void *), 
	      void *arg,
	      CredCacheEntry *ce)
d161 1
a161 10
     int fd;
     fbuf the_fbuf;
     DirPage0 *page0;
     unsigned i;
     FCacheEntry *centry;
     int ret;
     unsigned ind, dotind, dotdotind;
     VenusFid fid;
     unsigned len;
     struct stat sb;
d163 2
a164 3
     ret = fcache_get (&centry, dir, ce);
     if (ret)
	 return ret;
d166 3
a168 65
     ret = fcache_get_data (centry, ce);
     if (ret) {
	 ReleaseWriteLock (&centry->lock);
	 return ret;
     }

     if (centry->status.FileType != TYPE_DIR) {
	 ReleaseWriteLock (&centry->lock);
	 return ENOTDIR;
     }

     fd = fcache_open_file (centry, O_RDONLY, 0);
     if (fd < 0) {
	 ReleaseWriteLock (&centry->lock);
	 return errno;
     }

     if (fstat (fd, &sb)) {
	 ReleaseWriteLock (&centry->lock);
	 close (fd);
	 return errno;
     }

     len = sb.st_size;

     ret = fbuf_create (&the_fbuf, fd, len, FBUF_READ);
     if (ret) {
	 ReleaseWriteLock (&centry->lock);
	 close (fd);
	 return ret;
     }
     page0 = (DirPage0 *)(the_fbuf.buf);

     /*
      * Begin with placing `.' and `..' first. (some system seem to need that)
      */

     dotind = find_by_name (page0, ".", &fid, &dir);
     assert (dotind != 0);
     (*func)(&fid, ".", arg);

     dotdotind = find_by_name (page0, "..", &fid, &dir);
     assert (dotind != 0);
     (*func)(&fid, "..", arg);

     for (i = 0; i < ADIRHASHSIZE; ++i) {
	  const DirEntry *entry;

	  for(ind = ntohs(page0->dheader.hash[i]);
	      ind;
	      ind = ntohs(entry->next)) {

	      entry = getentry (page0, ind - 1);
	      
	      fid.Cell = dir.Cell;
	      fid.fid.Volume = dir.fid.Volume;
	      fid.fid.Vnode  = ntohl (entry->fid.Vnode);
	      fid.fid.Unique = ntohl (entry->fid.Unique);
	      if (ind != dotind && ind != dotdotind) /* already did them */
		  (*func)(&fid, entry->name, arg);
	  }
     }
     fbuf_end (&the_fbuf);
     ReleaseWriteLock (&centry->lock);
     return 0;
d172 1
a172 1
 *
d182 1
a182 1
 *
d192 34
a225 1
 * Add a new page to a directory.
d252 3
a254 1
 * return index into `page'
a264 1
    int len = strlen (filename);
d266 1
a266 1
    unsigned n = 1;
d268 1
a268 4
    for (len = strlen(filename), n = 1;
	 len > 15;
	 len -= sizeof(DirEntry), ++n)
	;
d270 1
a270 1
    if (page0->dheader.map[pageno] < n)
d282 1
a282 1
	    page->entry[i].flag = 0;
d289 2
a290 1
	    page0->dheader.map[pageno] -= n;
d299 1
a299 1
 *
d309 1
a309 2
    int len;
    unsigned n = 1, i;
d311 1
a311 4
    for (len = strlen(entry->name), n = 1;
	 len > 15;
	 len -= sizeof(DirEntry), ++n)
	;
d313 2
a314 1
    page0->dheader.map[pageno] += n;
d321 1
a321 1
	page->header.pg_bitmap[i / 8] &= ~(1 << (i % 8));
d326 328
d670 1
d674 1
a674 1
    fd = fcache_open_file (dir, O_RDWR | O_CREAT | O_TRUNC, 0666);
d678 6
d720 1
a720 1
    assert (dir->status.Length == the_fbuf.len);
d726 1
a726 1
 * Create a new entry with name `filename' and contents `fid' in `dir.
d736 1
d751 1
a751 1
    fd = fcache_open_file (dir, O_RDWR, 0);
d756 2
a757 1
	close (fd);
d767 2
d777 6
a782 7
    for (i = 0; i < npages; ++i)
	if (page0->dheader.map[i]) {
	    page = (DirPage1 *)((char *)page0 + i * AFSDIR_PAGESIZE);
	    ind = add_to_page (page0, page, i, name, fid, next);
	    if (ind >= 0)
		break;
	}
d789 2
a790 1
	page0->dheader.map[i] = ENTRIESPERPAGE - 1;
d799 1
a799 1
    /* assert (dir->status.Length == the_fbuf.len); */
d814 1
d832 1
a832 1
    fd = fcache_open_file (dir, O_RDWR, 0);
a835 3
#if 0
    len = dir->status.Length;
#endif
d837 2
a838 1
	close (fd);
d842 2
a847 1
	close (fd);
d879 1
a879 1
	page = (DirPage1 *)((char *)page0 + pageno * AFSDIR_PAGESIZE);
d882 1
a882 1
	    && page0->dheader.map[pageno] == ENTRIESPERPAGE - 1) {
d887 1
a887 1
	    } while(page0->dheader.map[pageno] == ENTRIESPERPAGE - 1);
d890 1
@


1.1.1.1
log
@Initial version of Arla, a free implementation of an AFS cache-manager.
(second try, hopefully into the correct repository this time)
@
text
@@


1.1.1.2
log
@Import of arla-0.35.7
@
text
@d1 1
d3 1
a3 1
 * Copyright (c) 1995 - 2000 Kungliga Tekniska Högskolan
d18 6
a23 1
 * 3. Neither the name of the Institute nor the names of its contributors
d46 1
a46 1
RCSID("$KTH: adir.c,v 1.66.2.1 2001/06/04 22:16:34 ahltorp Exp $") ;
d49 1
a49 1
 *
d52 2
a53 5
static int
get_fbuf_from_fid (VenusFid *fid, CredCacheEntry **ce,
		   int *fd, fbuf *fbuf,
		   FCacheEntry **centry,
		   int open_flags, int fbuf_flags)
d55 1
a55 1
    int ret;
d57 8
a64 10
    ret = fcache_get_data (centry, fid, ce);
    if (ret)
	return ret;

    ret = fcache_get_fbuf (*centry, fd, fbuf, open_flags, fbuf_flags);
    if (ret) {
	fcache_release(*centry);
	return ret;
    }
    return 0;
d68 2
a69 9
 * Lookup `name' in the AFS directory identified by `centry' and return
 * the Fid in `file'.  All operations are done as `cred' and return
 * value is 0 or error code.
 *
 *
 * Locking:
 *            In        Out       Fail
 *    centry: Locked    Locked    Locked
 *  
d72 3
a74 2
int
adir_lookup (FCacheEntry *centry, const char *name, VenusFid *file)
d76 1
a76 8
     int ret;
     int fd;
     fbuf the_fbuf;

     ret = fcache_get_fbuf (centry, &fd, &the_fbuf, O_RDONLY,
			    FBUF_READ|FBUF_PRIVATE);
     if (ret)
	 return ret;
d78 4
a81 4
     ret = fdir_lookup (&the_fbuf, &centry->fid, name, file);
     fbuf_end (&the_fbuf);
     close (fd);
     return ret;
d85 1
a85 2
 * Lookup `name' in the AFS directory identified by `dir' and change the
 * fid to `fid'.
d88 5
a92 5
int
adir_changefid (VenusFid *dir,
		const char *name,
		VenusFid *file,
		CredCacheEntry **ce)
d94 1
a94 4
    FCacheEntry *centry;
    int ret;
    int fd;
    fbuf the_fbuf;
d96 15
a110 4
    ret = get_fbuf_from_fid (dir, ce, &fd, &the_fbuf, &centry, O_RDWR, 
			     FBUF_READ|FBUF_WRITE|FBUF_SHARED);
    if (ret)
	return ret;
a111 6
    ret = fdir_changefid (&the_fbuf, name, file);
    fbuf_end (&the_fbuf);
    close (fd);
    fcache_release (centry);
    return ret;
}
d114 3
a116 1
 * Return TRUE if dir is empty.
d120 4
a123 2
adir_emptyp (VenusFid *dir,
	     CredCacheEntry **ce)
d125 2
d128 2
a130 1
     int fd;
d132 7
d140 33
a172 3
     ret = get_fbuf_from_fid (dir, ce, &fd, &the_fbuf, &centry,
			      O_RDONLY, FBUF_READ|FBUF_PRIVATE);
     if (ret)
d174 4
a178 1
     ret = fdir_emptyp (&the_fbuf);
d180 5
a184 3
     close (fd);
     fcache_release (centry);
     return ret;
d193 1
a193 1
adir_readdir (VenusFid *dir,
d196 1
a196 1
	      CredCacheEntry **ce)
d200 2
d204 4
d209 1
a209 2
     ret = get_fbuf_from_fid (dir, ce, &fd, &the_fbuf, &centry,
			      O_RDONLY, FBUF_READ|FBUF_PRIVATE);
d213 62
a274 1
     ret = fdir_readdir (&the_fbuf, func, arg, dir);
d276 127
a402 3
     close (fd);
     fcache_release (centry);
     return ret;
a413 1
    int fd;
d416 12
d429 3
a431 1
    AssertExclLocked(&dir->lock);
d433 1
a433 2
    ret = fcache_get_fbuf (dir, &fd, &the_fbuf, O_RDWR,
			   FBUF_READ|FBUF_WRITE|FBUF_SHARED);
d435 28
a462 1
	return ret;
d464 2
a465 2
    ret = fdir_mkdir (&the_fbuf, dot, dot_dot);
    fcache_update_length (dir, fbuf_len(&the_fbuf));
a466 1
    close (fd);
d471 1
a471 1
 * Create a new entry with name `filename' and contents `fid' in `dir'.
a478 1
    int fd;
d481 24
d506 1
a506 2
    ret = fcache_get_fbuf (dir, &fd, &the_fbuf, O_RDWR, 
			   FBUF_READ|FBUF_WRITE|FBUF_SHARED);
d510 31
a540 2
    ret = fdir_creat (&the_fbuf, name, fid);
    fcache_update_length (dir, fbuf_len(&the_fbuf));
a541 1
    close (fd);
a552 1
    int fd;
d555 28
d584 5
a588 3
    ret = fcache_get_fbuf (dir, &fd, &the_fbuf, O_RDWR, 
			   FBUF_READ|FBUF_WRITE|FBUF_SHARED);
    if (ret)
d590 1
d592 43
a634 5
    ret = fdir_remove(&the_fbuf, name, NULL);
    fcache_update_length (dir, fbuf_len(&the_fbuf));
    fbuf_end (&the_fbuf);
    close (fd);
    return ret;
@


1.1.1.3
log
@Import of arla -current as of Aug 5 2003

ok todd@@ deraadt@@
@
text
@d2 1
a2 1
 * Copyright (c) 1995 - 2002 Kungliga Tekniska Högskolan
d40 1
a40 1
RCSID("$arla: adir.c,v 1.73 2002/07/24 05:56:27 lha Exp $") ;
d47 4
a50 4
get_fbuf_from_centry (CredCacheEntry **ce,
		      int *fd, fbuf *fbuf,
		      FCacheEntry **centry,
		      int open_flags, int fbuf_flags)
d54 1
a54 1
    ret = fcache_get_data (centry, ce, 0);
d60 1
d102 1
a102 1
adir_changefid (FCacheEntry **centry,
d107 1
d112 2
a113 2
    ret = get_fbuf_from_centry (ce, &fd, &the_fbuf, centry, O_RDWR, 
				FBUF_READ|FBUF_WRITE|FBUF_SHARED);
d120 1
d129 1
a129 1
adir_emptyp (FCacheEntry **centry,
d132 1
d137 2
a138 2
     ret = get_fbuf_from_centry (ce, &fd, &the_fbuf, centry,
				 O_RDONLY, FBUF_READ|FBUF_PRIVATE);
d145 1
d155 2
a156 2
adir_readdir (FCacheEntry **centry,
	      fdir_readdir_func func,
d162 1
d165 2
a166 2
     ret = get_fbuf_from_centry (ce, &fd, &the_fbuf, centry,
				 O_RDONLY, FBUF_READ|FBUF_PRIVATE);
d170 1
a170 1
     ret = fdir_readdir (&the_fbuf, func, arg, (*centry)->fid, NULL);
d173 1
d198 1
a198 1
    fcache_update_length (dir, fbuf_len(&the_fbuf), fbuf_len(&the_fbuf));
d223 1
a223 1
    fcache_update_length (dir, fbuf_len(&the_fbuf), fbuf_len(&the_fbuf));
d247 1
a247 1
    fcache_update_length (dir, fbuf_len(&the_fbuf), fbuf_len(&the_fbuf));
@


