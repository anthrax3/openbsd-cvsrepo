head	1.12;
access;
symbols
	OPENBSD_5_2:1.11.0.22
	OPENBSD_5_2_BASE:1.11
	OPENBSD_5_1_BASE:1.11
	OPENBSD_5_1:1.11.0.20
	OPENBSD_5_0:1.11.0.18
	OPENBSD_5_0_BASE:1.11
	OPENBSD_4_9:1.11.0.16
	OPENBSD_4_9_BASE:1.11
	OPENBSD_4_8:1.11.0.14
	OPENBSD_4_8_BASE:1.11
	OPENBSD_4_7:1.11.0.10
	OPENBSD_4_7_BASE:1.11
	OPENBSD_4_6:1.11.0.12
	OPENBSD_4_6_BASE:1.11
	OPENBSD_4_5:1.11.0.8
	OPENBSD_4_5_BASE:1.11
	OPENBSD_4_4:1.11.0.6
	OPENBSD_4_4_BASE:1.11
	OPENBSD_4_3:1.11.0.4
	OPENBSD_4_3_BASE:1.11
	OPENBSD_4_2:1.11.0.2
	OPENBSD_4_2_BASE:1.11
	OPENBSD_4_1:1.10.0.8
	OPENBSD_4_1_BASE:1.10
	OPENBSD_4_0:1.10.0.6
	OPENBSD_4_0_BASE:1.10
	OPENBSD_3_9:1.10.0.4
	OPENBSD_3_9_BASE:1.10
	OPENBSD_3_8:1.10.0.2
	OPENBSD_3_8_BASE:1.10
	OPENBSD_3_7:1.8.0.6
	OPENBSD_3_7_BASE:1.8
	OPENBSD_3_6:1.8.0.4
	OPENBSD_3_6_BASE:1.8
	OPENBSD_3_5:1.8.0.2
	OPENBSD_3_5_BASE:1.8
	OPENBSD_3_4:1.7.0.2
	OPENBSD_3_4_BASE:1.7
	arla-20030805:1.1.1.3
	OPENBSD_3_3:1.6.0.4
	OPENBSD_3_3_BASE:1.6
	OPENBSD_3_2:1.6.0.2
	OPENBSD_3_2_BASE:1.6
	arla-0-35-7:1.1.1.2
	OPENBSD_3_1:1.4.0.8
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.4.0.6
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_9:1.4.0.4
	OPENBSD_2_8:1.4.0.2
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.2.0.4
	OPENBSD_2_7_BASE:1.2
	OPENBSD_2_6:1.2.0.2
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.1.1.1.0.4
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.2
	OPENBSD_2_4_BASE:1.1.1.1
	arla-0_9:1.1.1.1
	arla:1.1.1;
locks; strict;
comment	@ * @;


1.12
date	2012.08.23.06.21.56;	author deraadt;	state dead;
branches;
next	1.11;

1.11
date	2007.03.20.03.31.22;	author tedu;	state Exp;
branches;
next	1.10;

1.10
date	2005.05.02.17.51.37;	author moritz;	state Exp;
branches;
next	1.9;

1.9
date	2005.04.17.01.57.54;	author beck;	state Exp;
branches;
next	1.8;

1.8
date	2003.12.16.20.13.56;	author beck;	state Exp;
branches;
next	1.7;

1.7
date	2003.08.05.09.16.15;	author hin;	state Exp;
branches;
next	1.6;

1.6
date	2002.06.07.05.05.15;	author hin;	state Exp;
branches;
next	1.5;

1.5
date	2002.06.07.04.45.18;	author hin;	state Exp;
branches;
next	1.4;

1.4
date	2000.09.11.14.41.39;	author art;	state Exp;
branches;
next	1.3;

1.3
date	2000.06.29.00.12.28;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	99.04.30.01.59.17;	author art;	state Exp;
branches
	1.2.4.1;
next	1.1;

1.1
date	98.09.14.21.53.23;	author art;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.09.14.21.53.23;	author art;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.06.07.04.14.38;	author hin;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2003.08.05.08.21.08;	author hin;	state Exp;
branches;
next	;

1.2.4.1
date	2000.10.07.04.15.45;	author jason;	state Exp;
branches;
next	;


desc
@@


1.12
log
@the afs src tree can go away
@
text
@/*
 * Copyright (c) 1995 - 2003 Kungliga Tekniska Högskolan
 * (Royal Institute of Technology, Stockholm, Sweden).
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * Logging functions
 */

#ifdef HAVE_CONFIG_H
#include <config.h>
RCSID("$arla: log.c,v 1.38 2003/03/13 14:50:58 lha Exp $");
#endif

#include <sys/types.h>
#include <sys/time.h>
#include <sys/time.h>
#ifdef HAVE_SYS_RESOURCE_H
#include <sys/resource.h>
#endif
#include <stdio.h>
#include <stdarg.h>
#include <ctype.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <time.h>
#if HAVE_SYSLOG
#include <syslog.h>
#endif /* HAVE_SYSLOG */

#include <assert.h>
#include <roken.h>
#include <err.h>
#include "log.h"

extern char *__progname;

/*
 * The structure for each logging method.
 */

struct log_method;

struct log_unit {
    struct log_method *method;
    char *name;
    const struct units *unit;
    unsigned mask;
};

struct log_method {
    char *name;
    void (*open)(Log_method *, const char *progname, char *fname,
		 char *extra_args);
    void (*vprint)(Log_method *, char *, va_list);
    void (*print)(Log_method *, char *);
    void (*close)(Log_method *);
    union {
	void *v;
	int i;
    } data;
    log_flags flags;
    int num_units;
    int alloc_units;
    struct log_unit **units;
};

struct log_method_file_data {
    FILE *f;
    int flags;
#define LOGFILE_NO_TIME 1
    char *progname;
};

#if HAVE_SYSLOG
static void log_open_syslog (Log_method *lm, const char *progname,
			     char *fname, char *extra_args);

static void log_close_syslog (Log_method *lm);
#if HAVE_VSYSLOG
static void log_vprint_syslog (Log_method *lm, char *, va_list);
#endif /* HAVE_VSYSLOG */
static void log_print_syslog (Log_method *lm, char *);
#endif /* HAVE_SYSLOG */

static void
log_open_stderr (Log_method *lm, const char *progname, char *fname,
		 char *extra_args);

static void
log_open_file (Log_method *lm, const char *progname, char *fname,
	       char *extra_args);

static void
log_close_file (Log_method *lm);

static void
log_print_file (Log_method *lm, char *);

static void
log_vprint_file (Log_method *lm, char *, va_list);

/*
 * The names for which we do special handling in the logging routines.
 */

static
Log_method special_names[] = {
#if HAVE_SYSLOG
{"syslog",	log_open_syslog,
#if HAVE_VSYSLOG
                                log_vprint_syslog, log_print_syslog
#else
                                NULL, log_print_syslog
#endif /* HAVE_VSYSLOG */
                                                        , log_close_syslog},
#endif /* HAVE_SYSLOG */
{"/dev/stderr",	log_open_stderr, log_vprint_file, log_print_file, NULL},
{NULL,		log_open_file, log_vprint_file, log_print_file, log_close_file}
/* Should be last */
};

#if HAVE_SYSLOG

struct units syslog_opt_units[] = {
#ifdef LOG_PERROR
    { "stderr", LOG_PERROR },
#endif
#ifdef LOG_NDELAY
    { "no-delay", LOG_NDELAY },
#endif
#ifdef LOG_CONS
    { "console", LOG_CONS },
#endif
#ifdef LOG_PID
    { "pid", LOG_PID },
#endif
    { NULL }
};

struct units syslog_facility_units[] = {
#ifdef LOG_AUTH
    { "auth",	LOG_AUTH },
#endif
#ifdef LOG_AUTHPRIV
    { "authpriv",	LOG_AUTHPRIV },
#endif
#ifdef LOG_CRON
    { "cron", 	LOG_CRON },
#endif
#ifdef LOG_DAEMON
    { "daemon",	LOG_DAEMON },
#endif
#ifdef LOG_FTP
    { "ftp",	LOG_FTP },
#endif
#ifdef LOG_KERN
    { "kern",	LOG_KERN },
#endif
#ifdef LOG_LPR
    { "lpr",	LOG_LPR },
#endif
#ifdef LOG_MAIL
    { "mail",	LOG_MAIL },
#endif
#ifdef LOG_NEWS
    { "news",	LOG_NEWS },
#endif
#ifdef LOG_SYSLOG
    { "syslog",	LOG_SYSLOG },
#endif
#ifdef LOG_USER
    { "user",	LOG_USER },
#endif
#ifdef LOG_UUCP
    { "uucp",	LOG_UUCP },
#endif
#ifdef LOG_LOCAL0
    { "local0",	LOG_LOCAL0 },
#endif
#ifdef LOG_LOCAL1
    { "local1",	LOG_LOCAL1 },
#endif
#ifdef LOG_LOCAL2
    { "local2",	LOG_LOCAL2 },
#endif
#ifdef LOG_LOCAL3
    { "local3",	LOG_LOCAL3 },
#endif
#ifdef LOG_LOCAL4
    { "local4",	LOG_LOCAL4 },
#endif
#ifdef LOG_LOCAL5
    { "local5",	LOG_LOCAL5 },
#endif
#ifdef LOG_LOCAL6
    { "local6",	LOG_LOCAL6 },
#endif
#ifdef LOG_LOCAL7
    { "local7",	LOG_LOCAL7 },
#endif
    { NULL }
};

static void
log_open_syslog (Log_method *lm, const char *progname, char *fname,
		 char *extra_args)
{
    int logopt = LOG_PID | LOG_NDELAY;
    int facility = LOG_DAEMON;
    char *opt = NULL;
    char *facility_str = NULL;

    opt = extra_args;
    if (opt) {
	facility_str = opt;
	strsep (&facility_str, ":");

	logopt = parse_flags (opt, syslog_opt_units, logopt);
	if (logopt < 0) {
	    fprintf (stderr, "log_open: error parsing syslog "
		     "optional flags: %s\n", opt);
	    print_flags_table (syslog_opt_units, stderr);
	    exit (1);
	}
    }
    if (facility_str) {
	struct units *best_match = NULL, *u = syslog_facility_units;
	int len = strlen(facility_str);

	while (u->name) {
	    if (strcasecmp(u->name, facility_str) == 0) {
		best_match = u;
		break;
	    }
	    if (strncasecmp(u->name, facility_str, len) == 0) {
		if (best_match)
		    errx (1, "log_open: log facility %s is ambiguous", 
			  facility_str);
		best_match = u;
	    }
	    u++;
	}
	if (best_match == NULL)
	    errx (1, "log_open: unknown facility %s", facility_str);
	facility = u->mult;
    }

    openlog (progname, logopt, facility);
}

#if HAVE_VSYSLOG

static void
log_vprint_syslog (Log_method *lm, char *fmt, va_list args)
{
     vsyslog (LOG_NOTICE, fmt, args);
}
#endif /* HAVE_VSYSLOG */

static void
log_print_syslog (Log_method *lm, char *str)
{
     syslog (LOG_NOTICE, "%s", str);
}

static void
log_close_syslog (Log_method *lm)
{
     closelog ();
}

#endif /* HAVE_SYSLOG */

static int
file_parse_extra(FILE *f, char *extra_args)
{
    int flags = 0;
    char *str;
    if (extra_args == NULL)
	return 0;
    do {
	if (strlen(extra_args) == 0)
	    return flags;

	str = strsep(&extra_args, ":");
	if (extra_args) {
	    *extra_args = '\0';
	    extra_args++;
	}
	if (strncasecmp(str, "notime", 6) == 0)
	    flags |= LOGFILE_NO_TIME;
	else
	    fprintf (f, "unknown flag: `%s'\n", str);
    } while (extra_args != NULL);
    
    return flags;
}

static void
log_open_file_common(struct log_method_file_data *data, 
		     const char *progname, char *extra_args)
{
    if (progname != NULL)
	data->progname = strdup(progname);
    else
	progname = "unknown-program";
    if (data->progname == NULL)
	data->progname = "out of memory";
    data->flags = file_parse_extra(data->f, extra_args);
}

static void
log_open_stderr (Log_method *lm, const char *progname, char *fname,
		 char *extra_args)
{
     struct log_method_file_data *data;
     data = malloc(sizeof(*data));
     if (data == NULL)
	 errx (1, "log_open_stderr: failed to malloc");
     lm->data.v = data;

     data->f = stderr;
     log_open_file_common(data, progname, extra_args);
}

static void
log_open_file (Log_method *lm, const char *progname, char *fname,
	       char *extra_args)
{
     struct log_method_file_data *data;
     data = malloc(sizeof(*data));
     if (data == NULL)
	 errx (1, "log_open_stderr: failed to malloc");
     lm->data.v = data;

     data->f = fopen (fname, "a");
     if (data->f == NULL)
	  data->f = stderr;
     log_open_file_common(data, progname, extra_args);
}

static void
log_printf_file(Log_method *lm, char *fmt, ...)
{
    va_list args;

    va_start (args, fmt);
    log_vprint_file(lm, fmt, args);
    va_end (args);
}

static void
log_print_file(Log_method *lm, char *str)
{
    log_printf_file(lm, "%s", str);
}

static void
log_vprint_file (Log_method *lm,  char *fmt, va_list args)
{
    struct timeval tv = { 0, 0 };
    char time[128];
    time_t t;
    struct log_method_file_data *data = lm->data.v;
    FILE *f = data->f;

    if ((data->flags & LOGFILE_NO_TIME) == 0) {
	struct tm tm;
	gettimeofday(&tv, NULL);
	t = tv.tv_sec;
	strftime(time, sizeof(time), "%Y-%m-%d %H:%M:%S %Z", 
		 localtime_r(&t, &tm));
	time[sizeof(time)-1] = '\0';
	fprintf (f, "%s: ", time);
    }

    fprintf (f, "%s: ", data->progname);
    vfprintf (f, fmt, args);
    putc ('\n', f);
    fflush (f);
}

static void
log_close_file (Log_method *lm)
{
    struct log_method_file_data *data = lm->data.v;
    fclose(data->f);
    free (data);
}

Log_method *
log_open (const char *progname, char *fname)
{
     int i;
     Log_method *logm;
     char *name, *extra;

     name = strdup(fname);
     if (name == NULL)
	 return NULL;

     logm = (Log_method *)malloc (sizeof(Log_method));
     if (logm == NULL) {
	 free (name);
	 return logm;
     }
     for (i = 0; i < sizeof(special_names) / sizeof(*special_names);
	  ++i) {
	 int len = 0;
	 if (special_names[i].name)
	     len = strlen(special_names[i].name);
	 if (special_names[i].name == NULL
	     || (strncmp (special_names[i].name, fname, len) == 0 &&
		 (special_names[i].name[len] == '\0'
		  || special_names[i].name[len] == ':'))) {
	     *logm = special_names[i];
	     break;
	 }
     }
     extra = name;
     strsep(&extra, ":");
     logm->num_units = 0;
     logm->alloc_units = 0;
     logm->units = NULL;
     (*logm->open)(logm, progname, name, extra);
     free (name);
     return logm;
}

log_flags
log_setflags(Log_method *method, log_flags flags)
{
    log_flags oldflags;

    oldflags = method->flags;
    method->flags = flags;
    return oldflags;
}

log_flags
log_getflags(Log_method *method)
{
    return method->flags;
}

void
log_set_mask (Log_unit *logu, unsigned m)
{
     logu->mask = m;
}

unsigned
log_get_mask (Log_unit *unit)
{
     return unit->mask;
}

static void
_internal_vlog (Log_method *method, const char *fmt, va_list args)
{
    if (method->vprint && (method->flags & LOG_CPU_USAGE) == 0)
	    (*method->vprint)(method, (char *) fmt, args);
    else {
	char *buf;
	
	vasprintf (&buf, fmt, args);

	if (buf != NULL) {
#ifdef HAVE_GETRUSAGE
	    if (method->flags & LOG_CPU_USAGE) {
		struct rusage usage;
		int ret;
		char *rbuf = NULL;
		
		ret = getrusage(RUSAGE_SELF, &usage);
		if (ret == 0) {
		    asprintf(&rbuf, "s: %d.%d u: %d.%d",
			     (int)usage.ru_stime.tv_sec, 
			     (int)usage.ru_stime.tv_usec,
			     (int)usage.ru_utime.tv_sec,
			     (int)usage.ru_utime.tv_usec);
		    if (rbuf) {
			char *buf2;
			
			asprintf(&buf2, "%s %s", buf, rbuf);
			if (buf2) {
			    free(buf);
			    buf = buf2;
			}
			free(rbuf);
		    }
		}
	    }
#endif /* HAVE_GETRUSAGE */
	    (*method->print)(method, buf);
	} else
	    (*method->print)(method, "not enough memory to print");
	free(buf);
    }
}

static void
_internal_log (Log_method *method, const char *fmt, ...)
{
    va_list args;
    
    va_start (args, fmt);
    _internal_vlog(method, fmt, args);
    va_end (args);
}

void
log_vlog(Log_unit *unit, unsigned level, const char *fmt, va_list args)
{
    if (level & unit->mask)
	_internal_vlog (unit->method, fmt, args);
}


void
log_log (Log_unit *logu, unsigned level, const char *fmt, ...)
{
    va_list args;
    
    va_start (args, fmt);
    log_vlog(logu, level, fmt, args);
    va_end (args);
}

void
log_close (Log_method *method)
{
    int i;
    if (method->close)
	(*method->close)(method);
    for (i = 0 ; i < method->num_units; i++)
	log_unit_free (method, method->units[i]);
    free (method->units);
    method->units = NULL;
    free (method);
}

Log_unit *
log_unit_init (Log_method *method, const char *name, struct units *unit,
	       unsigned long default_mask)
{
    Log_unit *u, **list;
    
    u = malloc (sizeof(Log_unit));
    if (u == NULL)
	return NULL;
    if (method->alloc_units == method->num_units) {
	    list = realloc (method->units,
			    (method->alloc_units + 1) * sizeof(Log_unit *));
	    if (list == NULL) {
		    free (u);
		    return NULL;
	    }
	    method->alloc_units += 1;
    }
    method->units = list;
    method->units[method->num_units] = u;
    method->num_units += 1;

    u->method = method;
    u->name   = estrdup (name);
    u->unit   = unit;
    u->mask   = default_mask;
    return u;
}

void
log_unit_free (Log_method *method, Log_unit *logu)
{
    Log_unit **list;
    int i;

    for (i = 0; i < method->num_units; i++)
	if (logu == method->units[method->num_units])
	    break;
    if (i < method->num_units - 1)
	memmove (&method->units[i], &method->units[i+1],
		 method->num_units - i);

    method->num_units -= 1;
    list = realloc (method->units, method->num_units * sizeof(Log_unit *));
    if (list != NULL)
	method->alloc_units = method->num_units;
    method->units = list;
    free (logu->name);
    assert (logu->method == method);
    logu->name = NULL;
    logu->unit = NULL;
    logu->mask = 0;
    free (logu);
}

static int
parse_word (Log_method *m, char **str, Log_unit **u, char **log_str)
{
    int j;
    char *first;

    if (**str == '\0') return 1;
    while (isspace((unsigned char)**str) || **str == ';')
	(*str)++;
    if (**str == '\0') return 1;

    first = *str;
    while (**str != '\0' && !isspace((unsigned char)**str) && **str != ':')
	(*str)++;
    if (**str == ':') {
	int best_fit = -1;
	int str_len;
	**str = '\0';
	(*str)++;
	str_len = strlen(first);
	for (j = 0; j < m->num_units; j++) {
	    if (strcasecmp(m->units[j]->name, first) == 0)
		break;
	    if (strncasecmp(m->units[j]->name, first, str_len) == 0) {
		if (best_fit != -1)
		    return 1;
		best_fit = j;
	    }
	}
	if (j == m->num_units) {
	    if (best_fit != -1)
		*u = m->units[best_fit];
	    else
		return 1;
	} else
	    *u = m->units[j];
	*log_str = *str;
    } else {
	*u = NULL;
	*log_str = first;
    }
    while (**str != '\0' && **str != ';')
	(*str)++;
    if (**str == '\0')
	return 0;
    **str = '\0';
    (*str)++;
    return 0;
}

static int
unit_parse_flags (const char *log_str, struct log_unit *unit)
{
    int ret;
    ret = parse_flags (log_str, unit->unit, log_get_mask(unit));
    if (ret < 0)
	return ret;
    log_set_mask (unit, ret);
    return 0;
}

void
log_set_mask_str (Log_method *method, Log_unit *default_unit, const char *str)
{
    char *log_str, *ptr, *str2;
    Log_unit *unit = NULL;
    int ret;

    str2 = ptr = estrdup (str);
    while (parse_word (method, &ptr, &unit, &log_str) == 0) {
	if (unit || default_unit) {
	    if ((unit && default_unit) && unit != default_unit)
		_internal_log (method,
			       "log_set_mask_str: default with unit string"
			       "%s:%s", unit->name, log_str);
	    if (unit == NULL)
		unit = default_unit;
	    ret = unit_parse_flags (log_str, unit);
	    if (ret)
		_internal_log (unit->method,
			       "log error parsing: %s:%s\n", 
			       unit->name, log_str);
	    unit = NULL;
	} else {
	    int i;
	    ret = 1;
	    /* If something matches, be merry */
	    for (i = 0; i < method->num_units; i++) {
		if (unit_parse_flags (log_str, method->units[i]) != -1)
		    ret = 0;
	    }
	    if (ret)
		_internal_log (method,
			       "log error parsing: %s\n", 
			       log_str);
	}
    }
    free (str2);
}

#define UPDATESZ(str,len,update) \
	do { (str) += (update); (len) -= min((len),(update)); } while (0)

static size_t
_print_unit (Log_unit *unit, char *buf, size_t sz)
{
    size_t ret, orig_sz = sz;
    if (sz <= 0)
    	return(0);
    ret = snprintf (buf, sz, "%s:", unit->name);
    if (ret == -1)
      ret = 0;
    if (ret >= sz)
      ret = sz - 1;
    UPDATESZ(buf,sz,ret);
    ret = unparse_flags (log_get_mask (unit), unit->unit, buf, sz);
    UPDATESZ(buf,sz,ret);
    return orig_sz - sz;
}

size_t
log_mask2str (Log_method *method, Log_unit *unit, char *buf, size_t sz)
{
    size_t ret, orig_sz = sz;
    int i, printed = 0;

    if (sz) buf[0] = '\0';

    if (unit)
	return _print_unit (unit, buf, sz);
    
    for (i = 0; i < method->num_units; i++) {
	if (log_get_mask (method->units[i])) {
	    if (printed && sz > 0) {
		ret = snprintf (buf, sz, ";");
		if (ret == -1)
	 	    ret = 0;
		if (ret >= sz)
		    ret = sz - 1;
		UPDATESZ(buf,sz,ret);
	    }
	    ret = _print_unit (method->units[i], buf, sz);
	    UPDATESZ(buf,sz,ret);
	    printed = 1;
	}
    }
    return orig_sz - sz;
}

#undef UPDATESZ
@


1.11
log
@remove some bogus *p tests from charles longeau
ok deraadt millert
@
text
@@


1.10
log
@fix snprintf misuse. ok bob@@ hin@@
@
text
@d635 1
a635 1
    while (**str != '\0' && (isspace((unsigned char)**str) || **str == ';'))
@


1.9
log
@fix snprintf abuse, partly from, and ok deraadt@@
@
text
@d738 3
a740 1
    if (ret == -1 || ret >= sz)
d763 3
a765 1
		if (ret == -1 || ret >= sz)
@


1.8
log
@afs cleanup, realloc strings, abort, etc.
testing by beck, hin, jose, fries. ok deraadt@@
@
text
@d735 2
d738 2
d759 1
a759 1
	    if (printed) {
d761 2
@


1.7
log
@Merge
@
text
@d93 1
d453 1
d582 8
a589 5
    list = realloc (method->units,
		    (method->num_units + 1) * sizeof(Log_unit *));
    if (list == NULL) {
	free (u);
	return NULL;
d617 2
a618 2
    if (list == NULL)
	abort();
a619 1

@


1.6
log
@Merge in some progname changes, and a couple of bugfixes from arla.
@
text
@d2 1
a2 1
 * Copyright (c) 1995 - 2001 Kungliga Tekniska Högskolan
d40 1
a40 1
RCSID("$KTH: log.c,v 1.28.2.2 2001/04/30 02:55:41 lha Exp $");
d100 1
d285 1
a285 1
     vsyslog (LOG_INFO, fmt, args);
d292 1
a292 1
     syslog (LOG_INFO, "%s", str);
d329 13
d352 1
a352 1
     data->flags = file_parse_extra(stderr, extra_args);
d368 1
a368 1
     data->flags = file_parse_extra(data->f, extra_args);
d400 1
a400 1
	strftime(time, sizeof(time), "%Y-%m-%d %H:%M:%S", 
d406 1
a406 1
    fprintf (f, "%s: ", __progname);
d424 1
a424 1
     Log_method *log;
d431 2
a432 2
     log = (Log_method *)malloc (sizeof(Log_method));
     if (log == NULL) {
d434 1
a434 1
	 return log;
d445 1
a445 1
	     *log = special_names[i];
d451 3
a453 3
     log->num_units = 0;
     log->units = NULL;
     (*log->open)(log, progname, name, extra);
d455 1
a455 1
     return log;
d475 1
a475 1
log_set_mask (Log_unit *log, unsigned m)
d477 1
a477 1
     log->mask = m;
d549 1
a549 1
log_log (Log_unit *log, unsigned level, const char *fmt, ...)
d554 1
a554 1
    log_vlog(log, level, fmt, args);
d598 1
a598 1
log_unit_free (Log_method *method, Log_unit *log)
d604 1
a604 1
	if (log == method->units[method->num_units])
d616 6
a621 6
    free (log->name);
    assert (log->method == method);
    log->name = NULL;
    log->unit = NULL;
    log->mask = 0;
    free (log);
@


1.5
log
@merge
@
text
@d65 2
@


1.4
log
@New Arla userland from Arla between 0.34.2 and current in arla cvs.
Too many new features and fixes to mention here.
@
text
@d2 1
a2 1
 * Copyright (c) 1995 - 2000 Kungliga Tekniska Högskolan
d17 1
a17 6
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by the Kungliga Tekniska
 *      Högskolan and its contributors.
 * 
 * 4. Neither the name of the Institute nor the names of its contributors
d40 1
a40 1
RCSID("$Id: log.c,v 1.17 2000/08/24 21:42:38 lha Exp $");
d45 4
d56 4
d62 1
d80 2
a81 1
    void (*open)(Log_method *, char *progname, char *fname);
d89 1
d94 6
d101 2
a102 1
static void log_open_syslog (Log_method *lm, char *progname, char *fname);
d107 1
a107 1
#else
a108 1
#endif /* HAVE_VSYSLOG */
d112 2
a113 1
log_open_stderr (Log_method *lm, char *progname, char *fname);
d116 2
a117 1
log_open_file (Log_method *lm, char *progname, char *fname);
d123 3
d137 1
a137 1
                                log_vprint_syslog, NULL
d143 2
a144 2
{"/dev/stderr",	log_open_stderr, log_vprint_file, NULL, NULL},
{NULL,		log_open_file, log_vprint_file, NULL, log_close_file}
d149 81
d231 2
a232 1
log_open_syslog (Log_method *lm, char *progname, char *fname)
d234 41
a274 1
     openlog (progname, LOG_PID, LOG_DAEMON);
d284 1
a284 1
#else
a290 1
#endif /* HAVE_VSYSLOG */
d300 55
d356 1
a356 1
log_open_stderr (Log_method *lm, char *progname, char *fname)
d358 5
a362 5
#if 0
     lm = &special_names[sizeof(special_names) /
			 sizeof(*special_names) - 1];
#endif
     lm->data.v = stderr;
d366 1
a366 1
log_open_file (Log_method *lm, char *progname, char *fname)
d368 1
a368 3
     lm->data.v = (void *)fopen (fname, "a");
     if (lm->data.v == NULL)
	  lm->data.v = stderr;
d375 1
a375 1
    char *time;
d377 2
a378 1
    FILE *f = (FILE *)lm->data.v;
d380 7
a386 5
    gettimeofday(&tv, NULL);
    t = tv.tv_sec;
    time = strdup(ctime(&t));
    if (time) {
	time[strlen(time)-1] = '\0';
d388 1
a388 3
	free(time);
    } else
	fprintf (f, "unknown time:");
d399 3
a401 1
     fclose ((FILE *)lm->data.v);
d405 1
a405 1
log_open (char *progname, char *fname)
d409 5
d416 4
a419 2
     if (log == NULL)
	  return log;
d421 14
a434 8
	  ++i)
	  if (special_names[i].name == NULL
	      || strcmp (special_names[i].name, fname) == 0) {
	       *log = special_names[i];
	       break;
	  }
     if (log == NULL)
	 return NULL;
d437 2
a438 1
     (*log->open)(log, progname, fname);
d442 16
d473 1
a473 1
    if (method->vprint)
d479 28
a506 1
	if (buf != NULL)
d508 1
a508 1
	else
d615 1
a615 1
    while (**str != '\0' && isspace(**str) && **str == ';')
d620 1
a620 1
    while (**str != '\0' && !isspace(**str) && **str != ':')
d623 2
a624 1
	int best_fit = m->num_units;
d627 2
a628 1
	for (j = 0; j < m->num_units; j++)
d631 6
d638 1
a638 1
	    if (best_fit != m->num_units)
d658 1
a658 1
static void
d664 3
a666 5
	_internal_log (unit->method,
		       "log internal error parsing: %s\n", 
		       log_str);
    else
	log_set_mask (unit, ret);
d674 1
d685 5
a689 1
	    unit_parse_flags (log_str, unit);
d693 10
a702 2
	    for (i = 0; i < method->num_units; i++) 
		unit_parse_flags (log_str, method->units[i]);
d709 1
a709 1
	do { (str) += (update); (len) -= (update); } while (0)
d727 2
@


1.3
log
@use %s with syslog
@
text
@a0 1
/*	$OpenBSD: log.c,v 1.2 1999/04/30 01:59:17 art Exp $	*/
d2 1
a2 1
 * Copyright (c) 1995, 1996, 1997, 1998 Kungliga Tekniska Högskolan
d45 1
a45 1
RCSID("$KTH: log.c,v 1.13 1998/10/04 19:41:10 assar Exp $");
d48 2
d52 1
a53 1
#include <sys/time.h>
d57 1
d65 9
d75 11
a85 10
     char *name;
     void (*open)(Log_method *, char *progname, char *fname);
     void (*vprint)(Log_method *, char *, va_list);
     void (*print)(Log_method *, char *);
     void (*close)(Log_method *);
     union {
	  void *v;
	  int i;
     } data;
     unsigned mask;
d226 4
d235 1
a235 1
log_set_mask (Log_method *log, unsigned m)
d241 52
a292 1
log_get_mask (Log_method *log)
d294 34
a327 1
     return log->mask;
d331 1
a331 1
log_vlog(Log_method *log, unsigned level, const char *fmt, va_list args)
d333 56
a388 11
    if (level & log->mask) {
	if (log->vprint)
	    (*log->vprint)(log, (char *) fmt, args);
	else {
	    char *buf;
	    
	    vasprintf (&buf, fmt, args);
	    (*log->print)(log, buf);
	    
	    free(buf);
	}
d390 7
d399 12
d413 1
a413 1
log_log (Log_method *log, unsigned level, const char *fmt, ...)
d415 2
a416 1
     va_list args;
d418 18
a435 3
     va_start (args, fmt);
     log_vlog(log, level, fmt, args);
     va_end (args);
d438 5
a442 2
void
log_close (Log_method *log)
d444 29
a472 2
     (*log->close)(log);
     free (log);
d474 2
@


1.2
log
@upgrade Arla to fresher code. Too many new features and bugfixes.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d138 1
a138 1
     syslog (LOG_INFO, str);
@


1.2.4.1
log
@Pull in patch from current:
Fix (deraadt):
use %s with syslog
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.3 2000/06/29 00:12:28 deraadt Exp $	*/
d138 1
a138 1
     syslog (LOG_INFO, "%s", str);
@


1.1
log
@Initial revision
@
text
@d46 1
a46 1
RCSID("$KTH: log.c,v 1.12 1998/07/09 19:57:26 art Exp $");
d174 1
d181 1
a181 1
	fprintf ((FILE *)lm->data.v, "%s: ", time);
d184 1
a184 1
	fprintf ((FILE *)lm->data.v, "unknown time:");
d186 4
a189 3
    fprintf ((FILE *)lm->data.v, "%s: ", __progname);
    vfprintf ((FILE *)lm->data.v, fmt, args);
    putc ('\n', (FILE *)lm->data.v);
@


1.1.1.1
log
@Initial version of Arla, a free implementation of an AFS cache-manager.
(second try, hopefully into the correct repository this time)
@
text
@@


1.1.1.2
log
@Import of arla-0.35.7
@
text
@d1 1
d3 1
a3 1
 * Copyright (c) 1995 - 2001 Kungliga Tekniska Högskolan
d18 6
a23 1
 * 3. Neither the name of the Institute nor the names of its contributors
d46 1
a46 1
RCSID("$KTH: log.c,v 1.28.2.2 2001/04/30 02:55:41 lha Exp $");
a48 6
#include <sys/types.h>
#include <sys/time.h>
#include <sys/time.h>
#ifdef HAVE_SYS_RESOURCE_H
#include <sys/resource.h>
#endif
a50 1
#include <ctype.h>
d52 1
a55 5
#if HAVE_SYSLOG
#include <syslog.h>
#endif /* HAVE_SYSLOG */

#include <assert.h>
a56 1
#include <err.h>
a62 9
struct log_method;

struct log_unit {
    struct log_method *method;
    char *name;
    const struct units *unit;
    unsigned mask;
};

d64 10
a73 19
    char *name;
    void (*open)(Log_method *, const char *progname, char *fname,
		 char *extra_args);
    void (*vprint)(Log_method *, char *, va_list);
    void (*print)(Log_method *, char *);
    void (*close)(Log_method *);
    union {
	void *v;
	int i;
    } data;
    log_flags flags;
    int num_units;
    struct log_unit **units;
};

struct log_method_file_data {
    FILE *f;
    int flags;
#define LOGFILE_NO_TIME 1
d77 1
a77 2
static void log_open_syslog (Log_method *lm, const char *progname,
			     char *fname, char *extra_args);
d82 2
a84 1
static void log_print_syslog (Log_method *lm, char *);
d88 1
a88 2
log_open_stderr (Log_method *lm, const char *progname, char *fname,
		 char *extra_args);
d91 1
a91 2
log_open_file (Log_method *lm, const char *progname, char *fname,
	       char *extra_args);
a96 3
log_print_file (Log_method *lm, char *);

static void
d108 1
a108 1
                                log_vprint_syslog, log_print_syslog
d114 2
a115 2
{"/dev/stderr",	log_open_stderr, log_vprint_file, log_print_file, NULL},
{NULL,		log_open_file, log_vprint_file, log_print_file, log_close_file}
a119 81

struct units syslog_opt_units[] = {
#ifdef LOG_PERROR
    { "stderr", LOG_PERROR },
#endif
#ifdef LOG_NDELAY
    { "no-delay", LOG_NDELAY },
#endif
#ifdef LOG_CONS
    { "console", LOG_CONS },
#endif
#ifdef LOG_PID
    { "pid", LOG_PID },
#endif
    { NULL }
};

struct units syslog_facility_units[] = {
#ifdef LOG_AUTH
    { "auth",	LOG_AUTH },
#endif
#ifdef LOG_AUTHPRIV
    { "authpriv",	LOG_AUTHPRIV },
#endif
#ifdef LOG_CRON
    { "cron", 	LOG_CRON },
#endif
#ifdef LOG_DAEMON
    { "daemon",	LOG_DAEMON },
#endif
#ifdef LOG_FTP
    { "ftp",	LOG_FTP },
#endif
#ifdef LOG_KERN
    { "kern",	LOG_KERN },
#endif
#ifdef LOG_LPR
    { "lpr",	LOG_LPR },
#endif
#ifdef LOG_MAIL
    { "mail",	LOG_MAIL },
#endif
#ifdef LOG_NEWS
    { "news",	LOG_NEWS },
#endif
#ifdef LOG_SYSLOG
    { "syslog",	LOG_SYSLOG },
#endif
#ifdef LOG_USER
    { "user",	LOG_USER },
#endif
#ifdef LOG_UUCP
    { "uucp",	LOG_UUCP },
#endif
#ifdef LOG_LOCAL0
    { "local0",	LOG_LOCAL0 },
#endif
#ifdef LOG_LOCAL1
    { "local1",	LOG_LOCAL1 },
#endif
#ifdef LOG_LOCAL2
    { "local2",	LOG_LOCAL2 },
#endif
#ifdef LOG_LOCAL3
    { "local3",	LOG_LOCAL3 },
#endif
#ifdef LOG_LOCAL4
    { "local4",	LOG_LOCAL4 },
#endif
#ifdef LOG_LOCAL5
    { "local5",	LOG_LOCAL5 },
#endif
#ifdef LOG_LOCAL6
    { "local6",	LOG_LOCAL6 },
#endif
#ifdef LOG_LOCAL7
    { "local7",	LOG_LOCAL7 },
#endif
    { NULL }
};

d121 1
a121 2
log_open_syslog (Log_method *lm, const char *progname, char *fname,
		 char *extra_args)
d123 1
a123 41
    int logopt = LOG_PID | LOG_NDELAY;
    int facility = LOG_DAEMON;
    char *opt = NULL;
    char *facility_str = NULL;

    opt = extra_args;
    if (opt) {
	facility_str = opt;
	strsep (&facility_str, ":");

	logopt = parse_flags (opt, syslog_opt_units, logopt);
	if (logopt < 0) {
	    fprintf (stderr, "log_open: error parsing syslog "
		     "optional flags: %s\n", opt);
	    print_flags_table (syslog_opt_units, stderr);
	    exit (1);
	}
    }
    if (facility_str) {
	struct units *best_match = NULL, *u = syslog_facility_units;
	int len = strlen(facility_str);

	while (u->name) {
	    if (strcasecmp(u->name, facility_str) == 0) {
		best_match = u;
		break;
	    }
	    if (strncasecmp(u->name, facility_str, len) == 0) {
		if (best_match)
		    errx (1, "log_open: log facility %s is ambiguous", 
			  facility_str);
		best_match = u;
	    }
	    u++;
	}
	if (best_match == NULL)
	    errx (1, "log_open: unknown facility %s", facility_str);
	facility = u->mult;
    }

    openlog (progname, logopt, facility);
d133 1
a133 1
#endif /* HAVE_VSYSLOG */
d138 1
a138 1
     syslog (LOG_INFO, "%s", str);
d140 1
a149 25
static int
file_parse_extra(FILE *f, char *extra_args)
{
    int flags = 0;
    char *str;
    if (extra_args == NULL)
	return 0;
    do {
	if (strlen(extra_args) == 0)
	    return flags;

	str = strsep(&extra_args, ":");
	if (extra_args) {
	    *extra_args = '\0';
	    extra_args++;
	}
	if (strncasecmp(str, "notime", 6) == 0)
	    flags |= LOGFILE_NO_TIME;
	else
	    fprintf (f, "unknown flag: `%s'\n", str);
    } while (extra_args != NULL);
    
    return flags;
}

d151 1
a151 2
log_open_stderr (Log_method *lm, const char *progname, char *fname,
		 char *extra_args)
d153 5
a157 34
     struct log_method_file_data *data;
     data = malloc(sizeof(*data));
     if (data == NULL)
	 errx (1, "log_open_stderr: failed to malloc");
     lm->data.v = data;

     data->f = stderr;
     data->flags = file_parse_extra(stderr, extra_args);
}

static void
log_open_file (Log_method *lm, const char *progname, char *fname,
	       char *extra_args)
{
     struct log_method_file_data *data;
     data = malloc(sizeof(*data));
     if (data == NULL)
	 errx (1, "log_open_stderr: failed to malloc");
     lm->data.v = data;

     data->f = fopen (fname, "a");
     if (data->f == NULL)
	  data->f = stderr;
     data->flags = file_parse_extra(data->f, extra_args);
}

static void
log_printf_file(Log_method *lm, char *fmt, ...)
{
    va_list args;

    va_start (args, fmt);
    log_vprint_file(lm, fmt, args);
    va_end (args);
d161 1
a161 1
log_print_file(Log_method *lm, char *str)
d163 3
a165 1
    log_printf_file(lm, "%s", str);
d172 1
a172 1
    char time[128];
a173 12
    struct log_method_file_data *data = lm->data.v;
    FILE *f = data->f;

    if ((data->flags & LOGFILE_NO_TIME) == 0) {
	struct tm tm;
	gettimeofday(&tv, NULL);
	t = tv.tv_sec;
	strftime(time, sizeof(time), "%Y-%m-%d %H:%M:%S", 
		 localtime_r(&t, &tm));
	time[sizeof(time)-1] = '\0';
	fprintf (f, "%s: ", time);
    }
d175 13
a187 4
    fprintf (f, "%s: ", __progname);
    vfprintf (f, fmt, args);
    putc ('\n', f);
    fflush (f);
d193 1
a193 3
    struct log_method_file_data *data = lm->data.v;
    fclose(data->f);
    free (data);
d197 1
a197 1
log_open (const char *progname, char *fname)
a200 5
     char *name, *extra;

     name = strdup(fname);
     if (name == NULL)
	 return NULL;
d203 2
a204 4
     if (log == NULL) {
	 free (name);
	 return log;
     }
d206 7
a212 18
	  ++i) {
	 int len = 0;
	 if (special_names[i].name)
	     len = strlen(special_names[i].name);
	 if (special_names[i].name == NULL
	     || (strncmp (special_names[i].name, fname, len) == 0 &&
		 (special_names[i].name[len] == '\0'
		  || special_names[i].name[len] == ':'))) {
	     *log = special_names[i];
	     break;
	 }
     }
     extra = name;
     strsep(&extra, ":");
     log->num_units = 0;
     log->units = NULL;
     (*log->open)(log, progname, name, extra);
     free (name);
a215 16
log_flags
log_setflags(Log_method *method, log_flags flags)
{
    log_flags oldflags;

    oldflags = method->flags;
    method->flags = flags;
    return oldflags;
}

log_flags
log_getflags(Log_method *method)
{
    return method->flags;
}

d217 1
a217 1
log_set_mask (Log_unit *log, unsigned m)
d223 1
a223 1
log_get_mask (Log_unit *unit)
d225 1
a225 1
     return unit->mask;
d228 2
a229 2
static void
_internal_vlog (Log_method *method, const char *fmt, va_list args)
d231 11
a241 38
    if (method->vprint && (method->flags & LOG_CPU_USAGE) == 0)
	    (*method->vprint)(method, (char *) fmt, args);
    else {
	char *buf;
	
	vasprintf (&buf, fmt, args);

	if (buf != NULL) {
#ifdef HAVE_GETRUSAGE
	    if (method->flags & LOG_CPU_USAGE) {
		struct rusage usage;
		int ret;
		char *rbuf = NULL;
		
		ret = getrusage(RUSAGE_SELF, &usage);
		if (ret == 0) {
		    asprintf(&rbuf, "s: %d.%d u: %d.%d",
			     (int)usage.ru_stime.tv_sec, 
			     (int)usage.ru_stime.tv_usec,
			     (int)usage.ru_utime.tv_sec,
			     (int)usage.ru_utime.tv_usec);
		    if (rbuf) {
			char *buf2;
			
			asprintf(&buf2, "%s %s", buf, rbuf);
			if (buf2) {
			    free(buf);
			    buf = buf2;
			}
			free(rbuf);
		    }
		}
	    }
#endif /* HAVE_GETRUSAGE */
	    (*method->print)(method, buf);
	} else
	    (*method->print)(method, "not enough memory to print");
	free(buf);
a244 66
static void
_internal_log (Log_method *method, const char *fmt, ...)
{
    va_list args;
    
    va_start (args, fmt);
    _internal_vlog(method, fmt, args);
    va_end (args);
}

void
log_vlog(Log_unit *unit, unsigned level, const char *fmt, va_list args)
{
    if (level & unit->mask)
	_internal_vlog (unit->method, fmt, args);
}


void
log_log (Log_unit *log, unsigned level, const char *fmt, ...)
{
    va_list args;
    
    va_start (args, fmt);
    log_vlog(log, level, fmt, args);
    va_end (args);
}

void
log_close (Log_method *method)
{
    int i;
    if (method->close)
	(*method->close)(method);
    for (i = 0 ; i < method->num_units; i++)
	log_unit_free (method, method->units[i]);
    free (method->units);
    method->units = NULL;
    free (method);
}

Log_unit *
log_unit_init (Log_method *method, const char *name, struct units *unit,
	       unsigned long default_mask)
{
    Log_unit *u, **list;
    
    u = malloc (sizeof(Log_unit));
    if (u == NULL)
	return NULL;
    list = realloc (method->units,
		    (method->num_units + 1) * sizeof(Log_unit *));
    if (list == NULL) {
	free (u);
	return NULL;
    }
    method->units = list;
    method->units[method->num_units] = u;
    method->num_units += 1;

    u->method = method;
    u->name   = estrdup (name);
    u->unit   = unit;
    u->mask   = default_mask;
    return u;
}
d247 1
a247 1
log_unit_free (Log_method *method, Log_unit *log)
d249 1
a249 2
    Log_unit **list;
    int i;
d251 3
a253 80
    for (i = 0; i < method->num_units; i++)
	if (log == method->units[method->num_units])
	    break;
    if (i < method->num_units - 1)
	memmove (&method->units[i], &method->units[i+1],
		 method->num_units - i);

    method->num_units -= 1;
    list = realloc (method->units, method->num_units * sizeof(Log_unit *));
    if (list == NULL)
	abort();
    method->units = list;

    free (log->name);
    assert (log->method == method);
    log->name = NULL;
    log->unit = NULL;
    log->mask = 0;
    free (log);
}

static int
parse_word (Log_method *m, char **str, Log_unit **u, char **log_str)
{
    int j;
    char *first;

    if (**str == '\0') return 1;
    while (**str != '\0' && (isspace((unsigned char)**str) || **str == ';'))
	(*str)++;
    if (**str == '\0') return 1;

    first = *str;
    while (**str != '\0' && !isspace((unsigned char)**str) && **str != ':')
	(*str)++;
    if (**str == ':') {
	int best_fit = -1;
	int str_len;
	**str = '\0';
	(*str)++;
	str_len = strlen(first);
	for (j = 0; j < m->num_units; j++) {
	    if (strcasecmp(m->units[j]->name, first) == 0)
		break;
	    if (strncasecmp(m->units[j]->name, first, str_len) == 0) {
		if (best_fit != -1)
		    return 1;
		best_fit = j;
	    }
	}
	if (j == m->num_units) {
	    if (best_fit != -1)
		*u = m->units[best_fit];
	    else
		return 1;
	} else
	    *u = m->units[j];
	*log_str = *str;
    } else {
	*u = NULL;
	*log_str = first;
    }
    while (**str != '\0' && **str != ';')
	(*str)++;
    if (**str == '\0')
	return 0;
    **str = '\0';
    (*str)++;
    return 0;
}

static int
unit_parse_flags (const char *log_str, struct log_unit *unit)
{
    int ret;
    ret = parse_flags (log_str, unit->unit, log_get_mask(unit));
    if (ret < 0)
	return ret;
    log_set_mask (unit, ret);
    return 0;
d257 1
a257 43
log_set_mask_str (Log_method *method, Log_unit *default_unit, const char *str)
{
    char *log_str, *ptr, *str2;
    Log_unit *unit = NULL;
    int ret;

    str2 = ptr = estrdup (str);
    while (parse_word (method, &ptr, &unit, &log_str) == 0) {
	if (unit || default_unit) {
	    if ((unit && default_unit) && unit != default_unit)
		_internal_log (method,
			       "log_set_mask_str: default with unit string"
			       "%s:%s", unit->name, log_str);
	    if (unit == NULL)
		unit = default_unit;
	    ret = unit_parse_flags (log_str, unit);
	    if (ret)
		_internal_log (unit->method,
			       "log error parsing: %s:%s\n", 
			       unit->name, log_str);
	    unit = NULL;
	} else {
	    int i;
	    ret = 1;
	    /* If something matches, be merry */
	    for (i = 0; i < method->num_units; i++) {
		if (unit_parse_flags (log_str, method->units[i]) != -1)
		    ret = 0;
	    }
	    if (ret)
		_internal_log (method,
			       "log error parsing: %s\n", 
			       log_str);
	}
    }
    free (str2);
}

#define UPDATESZ(str,len,update) \
	do { (str) += (update); (len) -= min((len),(update)); } while (0)

static size_t
_print_unit (Log_unit *unit, char *buf, size_t sz)
d259 2
a260 31
    size_t ret, orig_sz = sz;
    ret = snprintf (buf, sz, "%s:", unit->name);
    UPDATESZ(buf,sz,ret);
    ret = unparse_flags (log_get_mask (unit), unit->unit, buf, sz);
    UPDATESZ(buf,sz,ret);
    return orig_sz - sz;
}

size_t
log_mask2str (Log_method *method, Log_unit *unit, char *buf, size_t sz)
{
    size_t ret, orig_sz = sz;
    int i, printed = 0;

    if (sz) buf[0] = '\0';

    if (unit)
	return _print_unit (unit, buf, sz);
    
    for (i = 0; i < method->num_units; i++) {
	if (log_get_mask (method->units[i])) {
	    if (printed) {
		ret = snprintf (buf, sz, ";");
		UPDATESZ(buf,sz,ret);
	    }
	    ret = _print_unit (method->units[i], buf, sz);
	    UPDATESZ(buf,sz,ret);
	    printed = 1;
	}
    }
    return orig_sz - sz;
a261 2

#undef UPDATESZ
@


1.1.1.3
log
@Import of arla -current as of Aug 5 2003

ok todd@@ deraadt@@
@
text
@d2 1
a2 1
 * Copyright (c) 1995 - 2003 Kungliga Tekniska Högskolan
d40 1
a40 1
RCSID("$arla: log.c,v 1.38 2003/03/13 14:50:58 lha Exp $");
a97 1
    char *progname;
d282 1
a282 1
     vsyslog (LOG_NOTICE, fmt, args);
d289 1
a289 1
     syslog (LOG_NOTICE, "%s", str);
a325 13
log_open_file_common(struct log_method_file_data *data, 
		     const char *progname, char *extra_args)
{
    if (progname != NULL)
	data->progname = strdup(progname);
    else
	progname = "unknown-program";
    if (data->progname == NULL)
	data->progname = "out of memory";
    data->flags = file_parse_extra(data->f, extra_args);
}

static void
d336 1
a336 1
     log_open_file_common(data, progname, extra_args);
d352 1
a352 1
     log_open_file_common(data, progname, extra_args);
d384 1
a384 1
	strftime(time, sizeof(time), "%Y-%m-%d %H:%M:%S %Z", 
d390 1
a390 1
    fprintf (f, "%s: ", data->progname);
d408 1
a408 1
     Log_method *logm;
d415 2
a416 2
     logm = (Log_method *)malloc (sizeof(Log_method));
     if (logm == NULL) {
d418 1
a418 1
	 return logm;
d429 1
a429 1
	     *logm = special_names[i];
d435 3
a437 3
     logm->num_units = 0;
     logm->units = NULL;
     (*logm->open)(logm, progname, name, extra);
d439 1
a439 1
     return logm;
d459 1
a459 1
log_set_mask (Log_unit *logu, unsigned m)
d461 1
a461 1
     logu->mask = m;
d533 1
a533 1
log_log (Log_unit *logu, unsigned level, const char *fmt, ...)
d538 1
a538 1
    log_vlog(logu, level, fmt, args);
d582 1
a582 1
log_unit_free (Log_method *method, Log_unit *logu)
d588 1
a588 1
	if (logu == method->units[method->num_units])
d600 6
a605 6
    free (logu->name);
    assert (logu->method == method);
    logu->name = NULL;
    logu->unit = NULL;
    logu->mask = 0;
    free (logu);
@


