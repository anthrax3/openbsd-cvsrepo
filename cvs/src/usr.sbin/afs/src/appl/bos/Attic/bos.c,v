head	1.5;
access;
symbols
	OPENBSD_5_2:1.4.0.38
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.36
	OPENBSD_5_0:1.4.0.34
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.32
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.30
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.4.0.26
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.4.0.28
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.4.0.24
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.4.0.22
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.4.0.20
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.4.0.18
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.4.0.16
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.4.0.14
	OPENBSD_4_0_BASE:1.4
	OPENBSD_3_9:1.4.0.12
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.10
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.8
	OPENBSD_3_7_BASE:1.4
	OPENBSD_3_6:1.4.0.6
	OPENBSD_3_6_BASE:1.4
	OPENBSD_3_5:1.4.0.4
	OPENBSD_3_5_BASE:1.4
	OPENBSD_3_4:1.4.0.2
	OPENBSD_3_4_BASE:1.4
	arla-20030805:1.1.1.2
	OPENBSD_3_3:1.3.0.4
	OPENBSD_3_3_BASE:1.3
	OPENBSD_3_2:1.3.0.2
	OPENBSD_3_2_BASE:1.3
	arla-0-35-7:1.1.1.1
	arla:1.1.1
	OPENBSD_3_1:1.1.0.8
	OPENBSD_3_1_BASE:1.1
	OPENBSD_3_0:1.1.0.6
	OPENBSD_3_0_BASE:1.1
	OPENBSD_2_9_BASE:1.1
	OPENBSD_2_9:1.1.0.4
	OPENBSD_2_8:1.1.0.2
	OPENBSD_2_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.5
date	2012.08.23.06.21.47;	author deraadt;	state dead;
branches;
next	1.4;

1.4
date	2003.08.05.09.05.48;	author hin;	state Exp;
branches;
next	1.3;

1.3
date	2002.06.07.05.05.15;	author hin;	state Exp;
branches;
next	1.2;

1.2
date	2002.06.07.04.28.42;	author hin;	state Exp;
branches;
next	1.1;

1.1
date	2000.09.11.14.40.35;	author art;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.06.07.04.14.19;	author hin;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.08.05.08.20.58;	author hin;	state Exp;
branches;
next	;


desc
@@


1.5
log
@the afs src tree can go away
@
text
@/*
 * Copyright (c) 1995, 1996, 1997, 1998, 1999 Kungliga Tekniska Högskolan
 * (Royal Institute of Technology, Stockholm, Sweden).
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include "appl_locl.h"
#include <sl.h>
#include "bos_local.h"

RCSID("$arla: bos.c,v 1.11 2003/01/17 03:24:48 lha Exp $");

int bos_interactive = 0;

static int empty_cmd(int argc, char **argv);
static int quit_cmd(int argc, char **argv);
static int help_cmd(int argc, char **argv);
static int apropos_cmd(int argc, char **argv);


/*
 * command table
 */

static SL_cmd cmds[] = {
    {"addhost",		bos_addhost,	"add host to cell database"},
    {"addkey",		empty_cmd,	"not yet implemented"},
    {"adduser",		bos_adduser,	"add users to super-user list"},
    {"apropos",		apropos_cmd,	"apropos help"},
    {"create",		empty_cmd,	"not yet implemented"},
    {"delete",		empty_cmd,	"not yet implemented"},
    {"exec",		empty_cmd,	"not yet implemented"},
    {"exit",		quit_cmd,    	"exit interactive mode"},
    {"getdate",		empty_cmd,	"not yet implemented"},
    {"getlog",		empty_cmd,	"not yet implemented"},
    {"getrestart",	bos_getrestart,	"get restart times"},
    {"help",		help_cmd,	"print help"},
    {"install",		empty_cmd,	"not yet implemented"},
    {"listhosts",	bos_listhosts,	"list VLDB-servers"},
    {"listkeys",	empty_cmd,	"not yet implemented"},
    {"listusers",	bos_listusers,	"list super-users"},
    {"prune",		empty_cmd,	"not yet implemented"},
    {"removehost",	bos_removehost,	"remove host from cell database"},
    {"removekey",	empty_cmd,	"not yet implemented"},
    {"removeuser",	empty_cmd,	"not yet implemented"},
    {"restart",		bos_restart,	"restarts an instace"},
    {"salvage",		empty_cmd,	"not yet implemented"},
    {"setauth",		empty_cmd,	"not yet implemented"},
    {"setcellname",	empty_cmd,	"not yet implemented"},
    {"setrestart",	empty_cmd,	"not yet implemented"},
    {"shutdown",	empty_cmd,	"not yet implemented"},
    {"start",		bos_start,	"start a server instance"},
    {"status",		bos_status,
     "Show volume server transactions"},
    {"stop",		bos_stop,	"stop a server instance"},
    {"version",		arlalib_version_cmd, "print version"},
    {"uninstall",	empty_cmd,	"not yet implemented"},
    {"quit",		quit_cmd,	"exit interactive mode"},
    {NULL}
};

/*
 * Dummy command
 */

static int
empty_cmd(int argc, char **argv)
{
    printf("%s%s has not been implemented yet!\n", PROGNAME, argv[0]);
    return 0;
}

/*
 * quit
 */

static int
quit_cmd(int argc, char **argv)
{
    printf("exiting\n");
    return 1;
}

/*
 * help
 */

static int
help_cmd (int argc, char **argv)
{
  SL_cmd *cmd;

  for (cmd = cmds; cmd->name != NULL; ++cmd)
    if (cmd->usage != NULL)
      printf ("%-20s%s\n", cmd->name, cmd->usage);

  return 0;
}

/*
 * apropos
 */

static int
apropos_cmd(int argc, char **argv)
{
    if (argc == 0) {
	fprintf (stderr, "apropos: missing topic");
	return 0;
    }
    
    sl_apropos(cmds, argv[1]);
    return 0;
}


/*
 * Main program
 */

int
main(int argc, char **argv)
{
    Log_method *method;
    int ret = 0;
    
    method = log_open (__progname, "/dev/stderr:notime");
    if (method == NULL)
	errx (1, "log_open failed");
    cell_init(0, method);
    ports_init();
    
    if (argc > 1)
	ret = sl_command(cmds, argc - 1, argv + 1);
    else {
	bos_interactive = 1;
	printf("bos - an arla tool for administrating AFS-servers.\n");
	printf("Type \"help\" to get a list of commands.\n");
	ret = sl_loop(cmds, __progname": ");
    }
    return ret;
}
@


1.4
log
@Merge
@
text
@@


1.3
log
@Merge in some progname changes, and a couple of bugfixes from arla.
@
text
@d38 1
a38 1
RCSID("$KTH: bos.c,v 1.7 2000/10/03 00:06:57 lha Exp $");
d53 1
a53 1
    {"addhost",		empty_cmd,	"not yet implemented"},
d70 1
a70 1
    {"removehost",	empty_cmd,	"not yet implemented"},
d73 1
a73 1
    {"restart",		empty_cmd,	"not yet implemented"},
d79 1
a79 1
    {"start",		empty_cmd,	"not yet implemented"},
d82 2
a83 1
    {"stop",		empty_cmd,	"not yet implemented"},
d116 1
a116 1
help_cmd(int argc, char **argv)
d118 7
a124 2
    sl_help(cmds, argc, argv);
    return 0;
@


1.2
log
@merge
@
text
@d148 1
a148 3
    set_progname(argv[0]);

    method = log_open (get_progname(), "/dev/stderr:notime");
@


1.1
log
@New Arla userland from Arla between 0.34.2 and current in arla cvs.
Too many new features and fixes to mention here.
@
text
@d17 1
a17 6
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by the Kungliga Tekniska
 *      Högskolan and its contributors.
 * 
 * 4. Neither the name of the Institute nor the names of its contributors
d38 1
a38 1
RCSID("$Id: bos.c,v 1.3 2000/08/28 03:02:58 jimmy Exp $");
d53 33
a85 32
  {"addhost",	empty_cmd,	"not yet implemented"},
  {"addkey",	empty_cmd,	"not yet implemented"},
  {"adduser",	bos_adduser,	"add users to super-user list"},
  {"apropos",    apropos_cmd,     "apropos help"},
  {"create",	empty_cmd,	"not yet implemented"},
  {"delete",	empty_cmd,	"not yet implemented"},
  {"exec",	empty_cmd,	"not yet implemented"},
  {"exit",      quit_cmd,        "exit interactive mode"},
  {"getdate",	empty_cmd,	"not yet implemented"},
  {"getlog",	empty_cmd,	"not yet implemented"},
  {"getrestart",bos_getrestart,	"get restart times"},
  {"help",        help_cmd,       "print help"},
  {"install",	empty_cmd,	"not yet implemented"},
  {"listhosts",	bos_listhosts,	"list VLDB-servers"},
  {"listkeys",	empty_cmd,	"not yet implemented"},
  {"listusers",	bos_listusers,	"list super-users"},
  {"prune",	empty_cmd,	"not yet implemented"},
  {"removehost",	empty_cmd,	"not yet implemented"},
  {"removekey",	empty_cmd,	"not yet implemented"},
  {"removeuser",	empty_cmd,	"not yet implemented"},
  {"restart",	empty_cmd,	"not yet implemented"},
  {"salvage",	empty_cmd,	"not yet implemented"},
  {"setauth",	empty_cmd,	"not yet implemented"},
  {"setcellname",	empty_cmd,	"not yet implemented"},
  {"setrestart",	empty_cmd,	"not yet implemented"},
  {"shutdown",	empty_cmd,	"not yet implemented"},
  {"start",	empty_cmd,	"not yet implemented"},
  {"status",      bos_status,     "Show volume server transactions"},
  {"stop",	empty_cmd,	"not yet implemented"},
  {"uninstall",	empty_cmd,	"not yet implemented"},
  {"quit",       quit_cmd,        "exit interactive mode"},
  {NULL}
d95 2
a96 2
  printf("%s%s has not been implemented yet!\n", PROGNAME, argv[0]);
  return 0;
d106 2
a107 2
  printf("exiting\n");
  return 1;
d117 2
a118 2
  sl_help(cmds, argc, argv);
  return 0;
d128 6
a133 2
  if (argc == 0) {
    fprintf (stderr, "apropos: missing topic");
a134 4
  }

  sl_apropos(cmds, argv[1]);
  return 0;
d145 2
a146 1
  int ret = 0;
d148 1
a148 2
  cell_init(0);
  ports_init();
d150 15
a164 9
  if (argc > 1)
    ret = sl_command(cmds, argc - 1, argv + 1);
  else {
    bos_interactive = 1;
    printf("bos - an arla tool for administrating AFS-servers.\n");
    printf("Type \"help\" to get a list of commands.\n");
    ret = sl_loop(cmds, __progname": ");
  }
  return ret;
@


1.1.1.1
log
@Import of arla-0.35.7
@
text
@d17 6
a22 1
 * 3. Neither the name of the Institute nor the names of its contributors
d43 1
a43 1
RCSID("$KTH: bos.c,v 1.7 2000/10/03 00:06:57 lha Exp $");
d58 32
a89 33
    {"addhost",		empty_cmd,	"not yet implemented"},
    {"addkey",		empty_cmd,	"not yet implemented"},
    {"adduser",		bos_adduser,	"add users to super-user list"},
    {"apropos",		apropos_cmd,	"apropos help"},
    {"create",		empty_cmd,	"not yet implemented"},
    {"delete",		empty_cmd,	"not yet implemented"},
    {"exec",		empty_cmd,	"not yet implemented"},
    {"exit",		quit_cmd,    	"exit interactive mode"},
    {"getdate",		empty_cmd,	"not yet implemented"},
    {"getlog",		empty_cmd,	"not yet implemented"},
    {"getrestart",	bos_getrestart,	"get restart times"},
    {"help",		help_cmd,	"print help"},
    {"install",		empty_cmd,	"not yet implemented"},
    {"listhosts",	bos_listhosts,	"list VLDB-servers"},
    {"listkeys",	empty_cmd,	"not yet implemented"},
    {"listusers",	bos_listusers,	"list super-users"},
    {"prune",		empty_cmd,	"not yet implemented"},
    {"removehost",	empty_cmd,	"not yet implemented"},
    {"removekey",	empty_cmd,	"not yet implemented"},
    {"removeuser",	empty_cmd,	"not yet implemented"},
    {"restart",		empty_cmd,	"not yet implemented"},
    {"salvage",		empty_cmd,	"not yet implemented"},
    {"setauth",		empty_cmd,	"not yet implemented"},
    {"setcellname",	empty_cmd,	"not yet implemented"},
    {"setrestart",	empty_cmd,	"not yet implemented"},
    {"shutdown",	empty_cmd,	"not yet implemented"},
    {"start",		empty_cmd,	"not yet implemented"},
    {"status",		bos_status,
     "Show volume server transactions"},
    {"stop",		empty_cmd,	"not yet implemented"},
    {"uninstall",	empty_cmd,	"not yet implemented"},
    {"quit",		quit_cmd,	"exit interactive mode"},
    {NULL}
d99 2
a100 2
    printf("%s%s has not been implemented yet!\n", PROGNAME, argv[0]);
    return 0;
d110 2
a111 2
    printf("exiting\n");
    return 1;
d121 2
a122 2
    sl_help(cmds, argc, argv);
    return 0;
d132 2
a133 6
    if (argc == 0) {
	fprintf (stderr, "apropos: missing topic");
	return 0;
    }
    
    sl_apropos(cmds, argv[1]);
d135 4
d149 1
a149 2
    Log_method *method;
    int ret = 0;
d151 2
a152 1
    set_progname(argv[0]);
d154 9
a162 15
    method = log_open (get_progname(), "/dev/stderr:notime");
    if (method == NULL)
	errx (1, "log_open failed");
    cell_init(0, method);
    ports_init();
    
    if (argc > 1)
	ret = sl_command(cmds, argc - 1, argv + 1);
    else {
	bos_interactive = 1;
	printf("bos - an arla tool for administrating AFS-servers.\n");
	printf("Type \"help\" to get a list of commands.\n");
	ret = sl_loop(cmds, __progname": ");
    }
    return ret;
@


1.1.1.2
log
@Import of arla -current as of Aug 5 2003

ok todd@@ deraadt@@
@
text
@d38 1
a38 1
RCSID("$arla: bos.c,v 1.11 2003/01/17 03:24:48 lha Exp $");
d53 1
a53 1
    {"addhost",		bos_addhost,	"add host to cell database"},
d70 1
a70 1
    {"removehost",	bos_removehost,	"remove host from cell database"},
d73 1
a73 1
    {"restart",		bos_restart,	"restarts an instace"},
d79 1
a79 1
    {"start",		bos_start,	"start a server instance"},
d82 1
a82 2
    {"stop",		bos_stop,	"stop a server instance"},
    {"version",		arlalib_version_cmd, "print version"},
d115 1
a115 1
help_cmd (int argc, char **argv)
d117 2
a118 7
  SL_cmd *cmd;

  for (cmd = cmds; cmd->name != NULL; ++cmd)
    if (cmd->usage != NULL)
      printf ("%-20s%s\n", cmd->name, cmd->usage);

  return 0;
d148 1
a148 1
    setprogname(argv[0]);
d150 1
a150 1
    method = log_open (getprogname(), "/dev/stderr:notime");
@


