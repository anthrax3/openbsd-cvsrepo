head	1.4;
access;
symbols
	OPENBSD_5_2:1.3.0.38
	OPENBSD_5_2_BASE:1.3
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.36
	OPENBSD_5_0:1.3.0.34
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.32
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.3.0.30
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.3.0.26
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.28
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.3.0.24
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.3.0.22
	OPENBSD_4_4_BASE:1.3
	OPENBSD_4_3:1.3.0.20
	OPENBSD_4_3_BASE:1.3
	OPENBSD_4_2:1.3.0.18
	OPENBSD_4_2_BASE:1.3
	OPENBSD_4_1:1.3.0.16
	OPENBSD_4_1_BASE:1.3
	OPENBSD_4_0:1.3.0.14
	OPENBSD_4_0_BASE:1.3
	OPENBSD_3_9:1.3.0.12
	OPENBSD_3_9_BASE:1.3
	OPENBSD_3_8:1.3.0.10
	OPENBSD_3_8_BASE:1.3
	OPENBSD_3_7:1.3.0.8
	OPENBSD_3_7_BASE:1.3
	OPENBSD_3_6:1.3.0.6
	OPENBSD_3_6_BASE:1.3
	OPENBSD_3_5:1.3.0.4
	OPENBSD_3_5_BASE:1.3
	OPENBSD_3_4:1.3.0.2
	OPENBSD_3_4_BASE:1.3
	arla-20030805:1.1.1.2
	OPENBSD_3_3:1.2.0.4
	OPENBSD_3_3_BASE:1.2
	OPENBSD_3_2:1.2.0.2
	OPENBSD_3_2_BASE:1.2
	arla-0-35-7:1.1.1.1
	arla:1.1.1
	OPENBSD_3_1:1.1.0.8
	OPENBSD_3_1_BASE:1.1
	OPENBSD_3_0:1.1.0.6
	OPENBSD_3_0_BASE:1.1
	OPENBSD_2_9_BASE:1.1
	OPENBSD_2_9:1.1.0.4
	OPENBSD_2_8:1.1.0.2
	OPENBSD_2_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.4
date	2012.08.23.06.21.49;	author deraadt;	state dead;
branches;
next	1.3;

1.3
date	2003.08.05.09.05.48;	author hin;	state Exp;
branches;
next	1.2;

1.2
date	2002.06.07.04.28.42;	author hin;	state Exp;
branches;
next	1.1;

1.1
date	2000.09.11.14.40.37;	author art;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.06.07.04.14.21;	author hin;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.08.05.08.20.59;	author hin;	state Exp;
branches;
next	;


desc
@@


1.4
log
@the afs src tree can go away
@
text
@/*
 * Copyright (c) 1999 Kungliga Tekniska Högskolan
 * (Royal Institute of Technology, Stockholm, Sweden).
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include "appl_locl.h"
#include "vos_local.h"

RCSID("$arla: vos_createvolume.c,v 1.7 2002/04/10 15:35:51 joda Exp $");

/*
 * create volume
 */


static int
vos_createvolume (char *host, int32_t part, char *cell, 
		  arlalib_authflags_t auth,
		  char *name, int quota, int verbose)
{
    struct rx_connection *connvldb = NULL;
    struct rx_connection *volser = NULL;
    nvldbentry entry;
    int32_t dbhost;
    int32_t fshost;
    int32_t volid;
    int32_t rcode;
    int32_t trans; /* transaction id */
    int error;

    if (host == NULL && name == NULL)
	return EINVAL;

    if (cell == NULL)
	cell = (char *)cell_getthiscell();

    error = arlalib_getsyncsite (cell, NULL, afsvldbport,
				 &dbhost, auth);
    if (error) {
	fprintf (stderr, "vos_createvolume: arla_getsyncsite: %s\n", 
	       koerr_gettext(error));
	return -1;
    }
    
    connvldb = arlalib_getconnbyaddr(cell, dbhost, NULL,
				     afsvldbport,
				     VLDB_SERVICE_ID,
				     auth);
    if (connvldb == NULL) {
	fprintf (stderr,
		 "vos_createvolume: arlalib_getconnbyaddr: vldb-host: 0x%x\n",
	       dbhost);
	return -1;
    }

    volser = arlalib_getconnbyname (cell, host,
				    afsvolport,
				    VOLSERVICE_ID,
				    auth);
    if (volser == NULL) {
	fprintf (stderr,"vos_createvolume: arlalib_getconnbyname: volser: %s\n",
	       host);
	arlalib_destroyconn (connvldb);
	return -1;
    }

    fshost = rx_HostOf(rx_PeerOf(volser));
    if (fshost == 0) {
	fprintf (stderr, "vos_createvolume: address of 0 is not permited\n");
	goto errout;
    }

    /*
     * Get three (3) new Id's from the vldb server's
     */

    error = VL_GetNewVolumeId (connvldb, 3, &volid);
    if (error) {
	fprintf (stderr, "vos_createvolume: VL_GetNewVolumeID: %s\n", 
	       koerr_gettext (error));
	goto errout;
    }
    if (verbose)
	printf ("vos_createvolume: got a VolumeID: %d\n", volid);
	
    /*
     * Create new volume on the server
     */

    error = VOLSER_AFSVolCreateVolume (volser, part, name,
				       RWVOL,
				       /* parent */ 0, &volid,
				       &trans);
    if (error) {
	fprintf (stderr, "vos_createvolume: VOLSER_AFSVolCreateVolume: %s\n", 
	       koerr_gettext (error));
	goto errout;
    }
    if (verbose)
	printf ("vos_createvolume: created volume on %s, got trans %d\n", 
		host, trans);
	
    /*
     * Set quota
     */
    if(quota != 0) {
	struct volintInfo volinfo;
	memset(&volinfo, 0, sizeof(volinfo));
	volinfo.dayUse = -1;
	volinfo.maxquota = quota;
	error = VOLSER_AFSVolSetInfo (volser, trans, &volinfo);
	if (error) {
	    fprintf (stderr, "vos_createvolume: VOLSER_AFSVolSetInfo: %s (continuing)\n", 
		     koerr_gettext (error));
	}
    }

    /*
     * Bring the volume on-line
     */

    error = VOLSER_AFSVolSetFlags(volser, trans, 0);
    if (error) {
	fprintf (stderr, "vos_createvolume: VOLSER_AFSVolSetFlags: %s\n", 
	       koerr_gettext (error));
	goto errout;
    }
    if (verbose)
	printf  ("vos_createvolume: updated flag for trans %d\n", trans);    

    /* 
     * Create vldb-entry for the volume, if that failes, remove the volume
     * from the server.
     */

    memset (&entry, 0, sizeof (entry));
    strlcpy (entry.name, name, sizeof(entry.name));
    entry.nServers = 1;
    entry.serverNumber[0] = ntohl(fshost);
    entry.serverPartition[0] = part;
    entry.serverFlags[0] = VLSF_RWVOL;
    entry.volumeId[RWVOL] = volid;
    entry.volumeId[ROVOL] = volid+1;
    entry.volumeId[BACKVOL] = volid+2;
    entry.cloneId = 0;
    entry.flags = VLF_RWEXISTS;

    error = new_vlentry (connvldb, NULL, NULL, &entry, auth);
    if (error) {
	fprintf (stderr, "vos_createvolume: new_vlentry: %s\n", 
	       koerr_gettext (error));

	fprintf (stderr, "vos_createvolume: removing new volume");
	error = VOLSER_AFSVolDeleteVolume (volser, trans);
	if (error)
	    fprintf (stderr, "vos_createvolume: failed to remove volume: %s\n", 
		     koerr_gettext (error));
	else
	    fprintf (stderr, "vos_createvolume: removed volume\n");
	
    } else if (verbose)
	printf  ("vos_createvolume: added entry to vldb\n");
    
    /*
     * End transaction to volumeserver
     */

 errout:
    error = VOLSER_AFSVolEndTrans(volser, trans, &rcode);
    if (error) {
	fprintf (stderr, 
		 "vos_createvolume: VOLSER_AFSVolEndTrans: %s, rcode: %d\n", 
		 koerr_gettext (error),
		 rcode);
	return -1;
    }
    if (verbose)
	printf  ("vos_createvolume: ending transaction %d, rcode %d\n", 
		 trans, rcode);    

    arlalib_destroyconn(volser);
    arlalib_destroyconn(connvldb);
    return error;
}

/*
 * list vldb
 */

static char *server;
static char *part;
static char *volume;
static int maxquota;
static char *cell;
static int noauth;
static int localauth;
static int helpflag;
static int verbose;

static struct agetargs args[] = {
    {"server",	0, aarg_string,  &server,  
     "server", NULL, aarg_mandatory},
    {"part",	0, aarg_string,  &part,  
     "part", NULL, aarg_mandatory},
    {"volume",	0, aarg_string,  &volume,  
     "volume", NULL, aarg_mandatory},
    {"maxquota",0, aarg_integer,  &maxquota,  
     "initial quota", NULL, aarg_optional_swless },
    {"cell",	0, aarg_string,  &cell, 
     "cell", NULL},
    {"noauth",	0, aarg_flag,    &noauth, 
     "do not authenticate", NULL},
    {"localauth",	0, aarg_flag,    &localauth, 
     "use local authentication", NULL},
    {"verbose",	0, aarg_flag,    &verbose, 
     "verbose output", NULL},
    {"help",	0, aarg_flag,    &helpflag,
     NULL, NULL},
    {NULL,      0, aarg_end, NULL}
};

/*
 * print usage
 */

static void
usage(void)
{
    aarg_printusage (args, "vos create", "", AARG_AFSSTYLE);
}

/*
 * createvolume, to be called from libsl
 */

int
vos_create(int argc, char **argv)
{
    int optind = 0;
    int npart = -1;
    int error;

    server = cell = NULL;
    noauth = localauth = helpflag = 0;

    if (agetarg (args, argc, argv, &optind, AARG_AFSSTYLE)) {
	usage();
	return 0;
    }

    if(helpflag) {
	usage();
	return 0;
    }
    
    argc -= optind;
    argv += optind;

    if (argc > 0) {
	fprintf (stderr, "create volume: unparsed arguments\n");
	return 0;
    }

    npart = partition_name2num (part);

    error = vos_createvolume (server, npart, cell, 
			      arlalib_getauthflag (noauth, localauth, 0, 0),
			      volume, maxquota, verbose);
    if (error) {
	fprintf (stderr, "vos_createvolume failed (%d)\n", error);
	return 0;
    }

    return 0;
}

@


1.3
log
@Merge
@
text
@@


1.2
log
@merge
@
text
@d37 1
a37 1
RCSID("$KTH: vos_createvolume.c,v 1.5 2000/10/03 00:08:35 lha Exp $");
d44 1
a44 1
int
d47 1
a47 1
		  char *name, int verbose)
d123 1
a123 1
	fprintf (stderr, "vosler_createvolume: VOLSER_AFSVolCreateVolume: %s\n", 
d132 15
d221 1
d235 2
d296 1
a296 1
			      volume, verbose);
@


1.1
log
@New Arla userland from Arla between 0.34.2 and current in arla cvs.
Too many new features and fixes to mention here.
@
text
@d17 1
a17 6
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by the Kungliga Tekniska
 *      Högskolan and its contributors.
 * 
 * 4. Neither the name of the Institute nor the names of its contributors
d37 1
a37 1
RCSID("$Id: vos_createvolume.c,v 1.2 2000/08/16 02:31:09 lha Exp $");
d212 8
a219 8
static struct getargs args[] = {
    {"server",	0, arg_string,  &server,  
     "server", NULL, arg_mandatory},
    {"part",	0, arg_string,  &part,  
     "part", NULL, arg_mandatory},
    {"volume",	0, arg_string,  &volume,  
     "volume", NULL, arg_mandatory},
    {"cell",	0, arg_string,  &cell, 
d221 1
a221 1
    {"noauth",	0, arg_flag,    &noauth, 
d223 1
a223 1
    {"localauth",	0, arg_flag,    &localauth, 
d225 1
a225 1
    {"verbose",	0, arg_flag,    &verbose, 
d227 1
a227 1
    {"help",	0, arg_flag,    &helpflag,
d229 1
a229 1
    {NULL,      0, arg_end, NULL}
d239 1
a239 1
    arg_printusage (args, "vos create", "", ARG_AFSSTYLE);
d256 1
a256 1
    if (getarg (args, argc, argv, &optind, ARG_AFSSTYLE)) {
@


1.1.1.1
log
@Import of arla-0.35.7
@
text
@d17 6
a22 1
 * 3. Neither the name of the Institute nor the names of its contributors
d42 1
a42 1
RCSID("$KTH: vos_createvolume.c,v 1.5 2000/10/03 00:08:35 lha Exp $");
d217 8
a224 8
static struct agetargs args[] = {
    {"server",	0, aarg_string,  &server,  
     "server", NULL, aarg_mandatory},
    {"part",	0, aarg_string,  &part,  
     "part", NULL, aarg_mandatory},
    {"volume",	0, aarg_string,  &volume,  
     "volume", NULL, aarg_mandatory},
    {"cell",	0, aarg_string,  &cell, 
d226 1
a226 1
    {"noauth",	0, aarg_flag,    &noauth, 
d228 1
a228 1
    {"localauth",	0, aarg_flag,    &localauth, 
d230 1
a230 1
    {"verbose",	0, aarg_flag,    &verbose, 
d232 1
a232 1
    {"help",	0, aarg_flag,    &helpflag,
d234 1
a234 1
    {NULL,      0, aarg_end, NULL}
d244 1
a244 1
    aarg_printusage (args, "vos create", "", AARG_AFSSTYLE);
d261 1
a261 1
    if (agetarg (args, argc, argv, &optind, AARG_AFSSTYLE)) {
@


1.1.1.2
log
@Import of arla -current as of Aug 5 2003

ok todd@@ deraadt@@
@
text
@d37 1
a37 1
RCSID("$arla: vos_createvolume.c,v 1.7 2002/04/10 15:35:51 joda Exp $");
d44 1
a44 1
static int
d47 1
a47 1
		  char *name, int quota, int verbose)
d123 1
a123 1
	fprintf (stderr, "vos_createvolume: VOLSER_AFSVolCreateVolume: %s\n", 
a131 15
     * Set quota
     */
    if(quota != 0) {
	struct volintInfo volinfo;
	memset(&volinfo, 0, sizeof(volinfo));
	volinfo.dayUse = -1;
	volinfo.maxquota = quota;
	error = VOLSER_AFSVolSetInfo (volser, trans, &volinfo);
	if (error) {
	    fprintf (stderr, "vos_createvolume: VOLSER_AFSVolSetInfo: %s (continuing)\n", 
		     koerr_gettext (error));
	}
    }

    /*
a205 1
static int maxquota;
a218 2
    {"maxquota",0, aarg_integer,  &maxquota,  
     "initial quota", NULL, aarg_optional_swless },
d278 1
a278 1
			      volume, maxquota, verbose);
@


