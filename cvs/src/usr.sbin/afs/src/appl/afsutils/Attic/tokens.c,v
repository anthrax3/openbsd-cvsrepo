head	1.4;
access;
symbols
	OPENBSD_5_2:1.3.0.38
	OPENBSD_5_2_BASE:1.3
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.36
	OPENBSD_5_0:1.3.0.34
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.32
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.3.0.30
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.3.0.26
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.28
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.3.0.24
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.3.0.22
	OPENBSD_4_4_BASE:1.3
	OPENBSD_4_3:1.3.0.20
	OPENBSD_4_3_BASE:1.3
	OPENBSD_4_2:1.3.0.18
	OPENBSD_4_2_BASE:1.3
	OPENBSD_4_1:1.3.0.16
	OPENBSD_4_1_BASE:1.3
	OPENBSD_4_0:1.3.0.14
	OPENBSD_4_0_BASE:1.3
	OPENBSD_3_9:1.3.0.12
	OPENBSD_3_9_BASE:1.3
	OPENBSD_3_8:1.3.0.10
	OPENBSD_3_8_BASE:1.3
	OPENBSD_3_7:1.3.0.8
	OPENBSD_3_7_BASE:1.3
	OPENBSD_3_6:1.3.0.6
	OPENBSD_3_6_BASE:1.3
	OPENBSD_3_5:1.3.0.4
	OPENBSD_3_5_BASE:1.3
	OPENBSD_3_4:1.3.0.2
	OPENBSD_3_4_BASE:1.3
	arla-20030805:1.1.1.2
	OPENBSD_3_3:1.2.0.4
	OPENBSD_3_3_BASE:1.2
	OPENBSD_3_2:1.2.0.2
	OPENBSD_3_2_BASE:1.2
	arla-0-35-7:1.1.1.1
	arla:1.1.1
	OPENBSD_3_1:1.1.0.8
	OPENBSD_3_1_BASE:1.1
	OPENBSD_3_0:1.1.0.6
	OPENBSD_3_0_BASE:1.1
	OPENBSD_2_9_BASE:1.1
	OPENBSD_2_9:1.1.0.4
	OPENBSD_2_8:1.1.0.2
	OPENBSD_2_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.4
date	2012.08.23.06.21.47;	author deraadt;	state dead;
branches;
next	1.3;

1.3
date	2003.08.05.09.05.48;	author hin;	state Exp;
branches;
next	1.2;

1.2
date	2002.06.07.04.28.42;	author hin;	state Exp;
branches;
next	1.1;

1.1
date	2000.09.11.14.40.34;	author art;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.06.07.04.14.19;	author hin;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.08.05.08.20.58;	author hin;	state Exp;
branches;
next	;


desc
@@


1.4
log
@the afs src tree can go away
@
text
@/* 
   tokens.c - a version of 'tokens' for Arla

   Written by Chris Wing - wingc@@engin.umich.edu
   based on examples of AFS code: klist.c and libkafs (KTH-KRB)

   This is a reimplementation of tokens from AFS. The following new
   features have been added:
	-athena		Output format similar to the 'klist' program
			in Kerberos 4

	-v, -verbose	Slightly more verbose output
*/

/*
 * Copyright 1987, 1988 by the Massachusetts Institute of Technology. 
 *
 * For copying and distribution information, please see the file
 * <mit-copyright.h>. 
 *
 * Lists your current Kerberos tickets.
 * Written by Bill Sommerfeld, MIT Project Athena.
 */

#include "appl_locl.h"

RCSID("$arla: tokens.c,v 1.10 2001/01/21 15:33:36 lha Exp $");

#include "tokens.h"


/*
 * State variables
 */

/* produce verbose output? */
static int arg_verbose = 0;

/* produce kerberos4 style output? */
static int arg_athena = 0;

/* print out help message */
static int arg_help = 0;

/* print out version number */
static int arg_version = 0;

/* do we actually have any valid AFS tokens? */
static int got_tokens = 0;

/* do we have any AFS tokens, valid or not? */
static int got_anything = 0;


/* arguments for agetarg() */

struct agetargs args[] = {
    { "athena", 0, aarg_flag, &arg_athena,
      "generate 'klist' style output instead of AFS style",
      NULL, aarg_optional},
    { "verbose", 'v', aarg_flag, &arg_verbose,
      "generate verbose output",
      NULL, aarg_optional},
    { "help", 0, aarg_flag, &arg_help,
      "display this message",
      NULL, aarg_optional},
    { "version", 0, aarg_flag, &arg_version,
      "print version",
      NULL, aarg_optional},
    { NULL, 0, aarg_end, NULL, NULL }
};

/*
 * Helper functions
 */


/* Print out a help message and exit */

static void
do_help(int exitval)
{
    aarg_printusage(args, NULL, NULL, AARG_AFSSTYLE);
    exit(exitval);
}

/* ASCII time formatting function from klist.c (Kerberos 4) */

static char *short_date(int32_t dp)
{
    char *cp;
    time_t t = (time_t)dp;

    if (t == (time_t)(-1L)) return "***  Never  *** ";
    cp = ctime(&t) + 4;

    /* Only display seconds in 'athena' mode */
    if(arg_athena)
	cp[15] = '\0';
    else
	cp[12] = '\0';

    return (cp);
}


/*
 *
 */

static int
print_token (const char *secret, size_t secret_sz, 
	     const struct ClearToken *ct, 
	     const char *cell, void *arg)
{
    static int did_banner = 0;
    struct timeval tv;
    char start_time[20];
    char end_time[20];

    got_anything = 1;
    
    if ( (did_banner == 0) && (arg_athena) ) {
	printf("\nTokens held by Arla:\n\n");
	printf("  Issued           Expires          Principal\n");
	
	did_banner = 1;
    }
    
#ifdef HAVE_KRB_KDCTIMEOFDAY	
    krb_kdctimeofday (&tv);
#else
    gettimeofday (&tv, NULL);
#endif
    strlcpy (start_time, short_date(ct->BeginTimestamp), sizeof(start_time));
    if (arg_verbose || tv.tv_sec < ct->EndTimestamp)
	strlcpy (end_time, short_date(ct->EndTimestamp), sizeof(end_time));
    else
	strlcpy (end_time, ">>> Expired <<<", sizeof(end_time));
    
    /* only return success if we have non-expired tokens */
    if (tv.tv_sec < ct->EndTimestamp)
	got_tokens = 1;
    
    if(arg_athena) {
	/* Athena klist style output */
	
	printf("%s  %s  ", start_time, end_time);
	
	if ((ct->EndTimestamp - ct->BeginTimestamp) & 1)
	    printf("User's (AFS ID %d) tokens for %s", ct->ViceId, cell);
	else
	    printf("Tokens for %s", cell);
	
	    if (arg_verbose)
		printf(" (%d)", ct->AuthHandle);
	    
	    putchar('\n');
    } else {
	/* Traditional AFS output format */
	
	if ((ct->EndTimestamp - ct->BeginTimestamp) & 1)
	    printf("User's (AFS ID %d) tokens for afs@@%s", ct->ViceId, cell);
	else
	    printf("Tokens for afs@@%s", cell);
	
	if (arg_verbose || tv.tv_sec < ct->EndTimestamp)
	    printf(" [Expires %s]\n", end_time);
	else
	    printf(" [%s]\n", end_time);
    }
    return 0;
}
    

/* Display list of tokens */

void
display_tokens(void)
{
    /* AFS-style always displays the banner */
    if(!arg_athena)
	printf("\nTokens held by Arla:\n\n");

    arlalib_token_iter (NULL, print_token, NULL);

    /* Ick. Deal with AFS-style output and athena style output */

    if (got_anything) {
	if (!arg_athena)
	    printf("   --End of list--\n");
    } else {
	if (arg_athena)
	    printf("You have no AFS tokens.\n");
    }
}


int
main(int argc, char **argv)
{
    int optind = 0;

#ifndef KERBEROS
    errx (1, "kerberos support isn't compiled in");
#endif

     if (agetarg (args, argc, argv, &optind, AARG_AFSSTYLE)) {
	 warnx ("Bad argument: %s", argv[optind]);
	 do_help(1);
     }

     if (arg_help)
	 do_help(0);
     
     if (arg_version)
	 errx (0, "part of %s-%s", PACKAGE, VERSION);
     
     if (k_hasafs())
	 display_tokens();
     else
	 errx (1, "You don't seem to have AFS running");
     
     if (!got_tokens)
         return 1;
     
     return 0;
}
@


1.3
log
@Merge
@
text
@@


1.2
log
@merge
@
text
@d27 1
a27 1
RCSID("$KTH: tokens.c,v 1.9 2000/09/02 12:55:56 lha Exp $");
d107 3
a109 1
/* Display list of tokens */
d111 4
a114 1
void display_tokens(void)
d116 8
a123 13
    u_int32_t i;
    unsigned char t[128];
    struct ViceIoctl parms;

    int did_banner = 0;

    parms.in = (void *)&i;
    parms.in_size = sizeof(i);
    parms.out = (void *)t;
    parms.out_size = sizeof(t); 

    /* AFS-style always displays the banner */
    if(!(arg_athena))
d125 5
a129 32

    for (i = 0; k_pioctl(NULL, VIOCGETTOK, &parms, 0) == 0; i++) {
	int32_t size_secret_tok, size_public_tok;
	const char *cell;
	struct ClearToken ct;
	const unsigned char *r = t;
	struct timeval tv;
	char buf1[20], buf2[20];

	got_anything = 1;

	if ( (did_banner == 0) && (arg_athena) ) {
	    printf("\nTokens held by Arla:\n\n");
	    printf("  Issued           Expires          Principal\n");

	    did_banner = 1;
	}

	memcpy(&size_secret_tok, r, sizeof(size_secret_tok));
	/* dont bother about the secret token */
	r += size_secret_tok + sizeof(size_secret_tok);
	memcpy(&size_public_tok, r, sizeof(size_public_tok));
	r += sizeof(size_public_tok);
	memcpy(&ct, r, size_public_tok);
	r += size_public_tok;
	/* there is a int32_t with length of cellname, but we dont read it */
	r += sizeof(int32_t);
	cell = (const char *)r;

	/* make sure cell name is null-terminated */
	t[127] = '\0';

d131 1
a131 1
	krb_kdctimeofday (&tv);
d133 1
a133 1
	gettimeofday (&tv, NULL);
d135 17
a151 3
	strlcpy (buf1, short_date(ct.BeginTimestamp), sizeof(buf1));
	if (arg_verbose || tv.tv_sec < ct.EndTimestamp)
	    strlcpy (buf2, short_date(ct.EndTimestamp), sizeof(buf2));
d153 22
a174 1
	    strlcpy (buf2, ">>> Expired <<<", sizeof(buf2));
d176 1
a176 3
	/* only return success if we have non-expired tokens */
	if (tv.tv_sec < ct.EndTimestamp)
	    got_tokens = 1;
d178 6
a183 3
	/* make sure strings are null-terminated */
	buf1[19] = '\0';
	buf2[19] = '\0';
d185 1
a185 2
	if(arg_athena) {
	    /* Athena klist style output */
d187 1
a187 1
	    printf("%s  %s  ", buf1, buf2);
d189 6
a194 22
	    if ((ct.EndTimestamp - ct.BeginTimestamp) & 1)
		printf("User's (AFS ID %d) tokens for %s", ct.ViceId, cell);
	    else
		printf("Tokens for %s", cell);

	    if (arg_verbose)
		printf(" (%d)", ct.AuthHandle);

	    putchar('\n');
	} else {
	    /* Traditional AFS output format */

	    if ((ct.EndTimestamp - ct.BeginTimestamp) & 1)
		printf("User's (AFS ID %d) tokens for afs@@%s", ct.ViceId, cell);
	    else
		printf("Tokens for afs@@%s", cell);

	    if (arg_verbose || tv.tv_sec < ct.EndTimestamp)
		printf(" [Expires %s]\n", buf2);
	    else
		printf(" [%s]\n", buf2);
	}
a195 13

    /* Ick. Deal with AFS-style output and athena style output */

    /* Skip printing this only if athena style output and have no tokens */
    if(got_anything || !(arg_athena))
	printf("   --End of list--\n");

    /* Print this if athena style output and have no tokens */
    if( !(got_anything) && (arg_athena) )
	printf("You have no AFS tokens.\n");

    /* erase the copy of the token in memory */
    memset(t, 0, sizeof(t));
d199 2
a200 1
int main(int argc, char **argv)
@


1.1
log
@New Arla userland from Arla between 0.34.2 and current in arla cvs.
Too many new features and fixes to mention here.
@
text
@d27 1
a27 1
RCSID("$Id: tokens.c,v 1.6 2000/08/16 02:31:05 lha Exp $");
d55 1
a55 1
/* arguments for getarg() */
d57 2
a58 2
struct getargs args[] = {
    { "athena", 0, arg_flag, &arg_athena,
d60 2
a61 2
      NULL, arg_optional},
    { "verbose", 'v', arg_flag, &arg_verbose,
d63 2
a64 2
      NULL, arg_optional},
    { "help", 0, arg_flag, &arg_help,
d66 2
a67 2
      NULL, arg_optional},
    { "version", 0, arg_flag, &arg_version,
d69 2
a70 2
      NULL, arg_optional},
    { NULL, 0, arg_end, NULL, NULL }
d83 1
a83 1
    arg_printusage(args, NULL, NULL, ARG_AFSSTYLE);
d228 1
a228 1
     if (getarg (args, argc, argv, &optind, ARG_AFSSTYLE)) {
@


1.1.1.1
log
@Import of arla-0.35.7
@
text
@d27 1
a27 1
RCSID("$KTH: tokens.c,v 1.9 2000/09/02 12:55:56 lha Exp $");
d55 1
a55 1
/* arguments for agetarg() */
d57 2
a58 2
struct agetargs args[] = {
    { "athena", 0, aarg_flag, &arg_athena,
d60 2
a61 2
      NULL, aarg_optional},
    { "verbose", 'v', aarg_flag, &arg_verbose,
d63 2
a64 2
      NULL, aarg_optional},
    { "help", 0, aarg_flag, &arg_help,
d66 2
a67 2
      NULL, aarg_optional},
    { "version", 0, aarg_flag, &arg_version,
d69 2
a70 2
      NULL, aarg_optional},
    { NULL, 0, aarg_end, NULL, NULL }
d83 1
a83 1
    aarg_printusage(args, NULL, NULL, AARG_AFSSTYLE);
d228 1
a228 1
     if (agetarg (args, argc, argv, &optind, AARG_AFSSTYLE)) {
@


1.1.1.2
log
@Import of arla -current as of Aug 5 2003

ok todd@@ deraadt@@
@
text
@d27 1
a27 1
RCSID("$arla: tokens.c,v 1.10 2001/01/21 15:33:36 lha Exp $");
d107 1
a107 3
/*
 *
 */
d109 1
a109 4
static int
print_token (const char *secret, size_t secret_sz, 
	     const struct ClearToken *ct, 
	     const char *cell, void *arg)
d111 13
a123 8
    static int did_banner = 0;
    struct timeval tv;
    char start_time[20];
    char end_time[20];

    got_anything = 1;
    
    if ( (did_banner == 0) && (arg_athena) ) {
d125 32
a156 5
	printf("  Issued           Expires          Principal\n");
	
	did_banner = 1;
    }
    
d158 1
a158 1
    krb_kdctimeofday (&tv);
d160 1
a160 1
    gettimeofday (&tv, NULL);
d162 3
a164 17
    strlcpy (start_time, short_date(ct->BeginTimestamp), sizeof(start_time));
    if (arg_verbose || tv.tv_sec < ct->EndTimestamp)
	strlcpy (end_time, short_date(ct->EndTimestamp), sizeof(end_time));
    else
	strlcpy (end_time, ">>> Expired <<<", sizeof(end_time));
    
    /* only return success if we have non-expired tokens */
    if (tv.tv_sec < ct->EndTimestamp)
	got_tokens = 1;
    
    if(arg_athena) {
	/* Athena klist style output */
	
	printf("%s  %s  ", start_time, end_time);
	
	if ((ct->EndTimestamp - ct->BeginTimestamp) & 1)
	    printf("User's (AFS ID %d) tokens for %s", ct->ViceId, cell);
d166 20
a185 2
	    printf("Tokens for %s", cell);
	
d187 2
a188 2
		printf(" (%d)", ct->AuthHandle);
	    
d190 13
a202 12
    } else {
	/* Traditional AFS output format */
	
	if ((ct->EndTimestamp - ct->BeginTimestamp) & 1)
	    printf("User's (AFS ID %d) tokens for afs@@%s", ct->ViceId, cell);
	else
	    printf("Tokens for afs@@%s", cell);
	
	if (arg_verbose || tv.tv_sec < ct->EndTimestamp)
	    printf(" [Expires %s]\n", end_time);
	else
	    printf(" [%s]\n", end_time);
a203 3
    return 0;
}
    
d205 1
a205 1
/* Display list of tokens */
d207 7
a213 8
void
display_tokens(void)
{
    /* AFS-style always displays the banner */
    if(!arg_athena)
	printf("\nTokens held by Arla:\n\n");

    arlalib_token_iter (NULL, print_token, NULL);
d215 2
a216 9
    /* Ick. Deal with AFS-style output and athena style output */

    if (got_anything) {
	if (!arg_athena)
	    printf("   --End of list--\n");
    } else {
	if (arg_athena)
	    printf("You have no AFS tokens.\n");
    }
d220 1
a220 2
int
main(int argc, char **argv)
@


