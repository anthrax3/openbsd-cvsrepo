head	1.11;
access;
symbols
	OPENBSD_5_2:1.10.0.22
	OPENBSD_5_2_BASE:1.10
	OPENBSD_5_1_BASE:1.10
	OPENBSD_5_1:1.10.0.20
	OPENBSD_5_0:1.10.0.18
	OPENBSD_5_0_BASE:1.10
	OPENBSD_4_9:1.10.0.16
	OPENBSD_4_9_BASE:1.10
	OPENBSD_4_8:1.10.0.14
	OPENBSD_4_8_BASE:1.10
	OPENBSD_4_7:1.10.0.10
	OPENBSD_4_7_BASE:1.10
	OPENBSD_4_6:1.10.0.12
	OPENBSD_4_6_BASE:1.10
	OPENBSD_4_5:1.10.0.8
	OPENBSD_4_5_BASE:1.10
	OPENBSD_4_4:1.10.0.6
	OPENBSD_4_4_BASE:1.10
	OPENBSD_4_3:1.10.0.4
	OPENBSD_4_3_BASE:1.10
	OPENBSD_4_2:1.10.0.2
	OPENBSD_4_2_BASE:1.10
	OPENBSD_4_1:1.7.0.14
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.12
	OPENBSD_4_0_BASE:1.7
	OPENBSD_3_9:1.7.0.10
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.7.0.8
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.6
	OPENBSD_3_7_BASE:1.7
	OPENBSD_3_6:1.7.0.4
	OPENBSD_3_6_BASE:1.7
	OPENBSD_3_5:1.7.0.2
	OPENBSD_3_5_BASE:1.7
	OPENBSD_3_4:1.6.0.2
	OPENBSD_3_4_BASE:1.6
	arla-20030805:1.1.1.3
	OPENBSD_3_3:1.5.0.4
	OPENBSD_3_3_BASE:1.5
	OPENBSD_3_2:1.5.0.2
	OPENBSD_3_2_BASE:1.5
	arla-0-35-7:1.1.1.2
	OPENBSD_3_1:1.3.0.8
	OPENBSD_3_1_BASE:1.3
	OPENBSD_3_0:1.3.0.6
	OPENBSD_3_0_BASE:1.3
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_9:1.3.0.4
	OPENBSD_2_8:1.3.0.2
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.2.0.4
	OPENBSD_2_7_BASE:1.2
	OPENBSD_2_6:1.2.0.2
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.1.1.1.0.4
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.2
	OPENBSD_2_4_BASE:1.1.1.1
	arla-0_9:1.1.1.1
	arla:1.1.1;
locks; strict;
comment	@ * @;


1.11
date	2012.08.23.06.21.51;	author deraadt;	state dead;
branches;
next	1.10;

1.10
date	2007.04.05.01.31.05;	author tedu;	state Exp;
branches;
next	1.9;

1.9
date	2007.03.22.12.30.53;	author otto;	state Exp;
branches;
next	1.8;

1.8
date	2007.03.20.03.31.22;	author tedu;	state Exp;
branches;
next	1.7;

1.7
date	2003.12.16.20.13.55;	author beck;	state Exp;
branches;
next	1.6;

1.6
date	2003.08.05.08.47.46;	author hin;	state Exp;
branches;
next	1.5;

1.5
date	2002.06.07.05.05.15;	author hin;	state Exp;
branches;
next	1.4;

1.4
date	2002.06.07.04.38.03;	author hin;	state Exp;
branches;
next	1.3;

1.3
date	2000.09.11.14.40.57;	author art;	state Exp;
branches;
next	1.2;

1.2
date	99.04.30.01.59.11;	author art;	state Exp;
branches;
next	1.1;

1.1
date	98.09.14.21.53.00;	author art;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.09.14.21.53.00;	author art;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.06.07.04.14.28;	author hin;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2003.08.05.08.21.03;	author hin;	state Exp;
branches;
next	;


desc
@@


1.11
log
@the afs src tree can go away
@
text
@/*
 * Copyright (c) 1995 - 2002 Kungliga Tekniska Högskolan
 * (Royal Institute of Technology, Stockholm, Sweden).
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * Cell information
 */

#include "ko_locl.h"

#ifdef HAVE_KRB4
#include <krb.h>
#endif

RCSID("$arla: kocell.c,v 1.75 2003/06/10 16:52:06 lha Exp $");

#define TRANSARCSYSCONFDIR "/usr/vice/etc"
#define CELLFILENAME "CellServDB"
#define THISCELLFILENAME "ThisCell"
#define SUIDCELLSFILENAME "SuidCells"
#define THESECELLFILENAME "TheseCells"
#define DYNROOTDBFILENAME "DynRootDB"
#define ALIASDBFILENAME "AliasDB"
#define DEFCELLCACHESIZE 499

/*
 * hash tables by name and by number
 */

static Hashtab *cellnamehtab, *cellnumhtab;

/*
 * name of the current cell
 */

static char *thiscell = NULL;
static char **thesecells = NULL;
static int numthesecells = 1;
static int dynrootdb_in_use;

/*
 * Logging
 */

#define CDEBERR		0x800
#define CDEBWARN	0x400
#define CDEBDNS		0x200

#define CDEBDEFAULT	(CDEBWARN|CDEBERR)
#define cdeball		(CDEBWARN|CDEBERR)

static struct units celldebug_units[]  = {
    { "all", 		cdeball },
    { "almost-all",	cdeball },
    { "warn",		CDEBWARN },
    { "error", 		CDEBERR },
    { "dns",		CDEBDNS },
    { NULL, 0 },
};

#undef cdeball

static Log_unit *cell_log = NULL;

/*
 *
 */

static unsigned long celldb_version = 0;

static int add_special_dynroot_cell (void);

/*
 * Cell alias
 */

struct cellalias {
    char *name;
    char *alias;
    int type;
    Listitem *li;
};

static List *cellaliaslist;

/*
 * Functions for handling cell entries.
 */

static int
cellnamecmp (void *a, void *b)
{
     cell_entry *c1 = (cell_entry *)a;
     cell_entry *c2 = (cell_entry *)b;

     return strcasecmp (c1->name, c2->name);
}

static unsigned
cellnamehash (void *a)
{
     cell_entry *c = (cell_entry *)a;

     return hashcaseadd (c->name);
}

static int
cellnumcmp (void *a, void *b)
{
     cell_entry *c1 = (cell_entry *)a;
     cell_entry *c2 = (cell_entry *)b;

     return c1->id != c2->id;
}

static unsigned
cellnumhash (void *a)
{
     cell_entry *c = (cell_entry *)a;

     return c->id;
}

/*
 * New cell from cellserver-database file
 */

static cell_entry *
newcell (char *line)
{
     char *hash;
     cell_entry *c;
     int len;

     len = strcspn (line, " \t#");
     line[len] = '\0';
     c = cell_new (line);
     if (c == NULL)
	 err (1, "malloc failed");

     line += len + 1;
     hash = strchr (line, '#');
     if (hash != NULL) {
	  c->expl = strdup (hash+1);
	  if (c->expl == NULL)
	      err (1, "strdup");
     }
     return c;
}

/*
 * Verify that that host is valid (dns wise)
 */

static void
fetch_host (cell_entry *c, cell_db_entry *host)
{
    struct timeval tv;
    int ret;

    gettimeofday (&tv, NULL);
    
    ret = _ko_resolve_host(host->name, host);
    if (ret) {
	log_log (cell_log, CDEBDNS, 
		 "fetch_host: failed to resolve host %s in cell %s",
		 host->name, c->name);
	host->timeout = CELL_INVALID_HOST;
	return;
    }

    host->timeout += tv.tv_sec;
}


/*
 * Help function for updatehosts
 */

static int 
host_sort (const void *p1, const void *p2)
{
    const cell_db_entry *a = (const cell_db_entry *)p1;
    const cell_db_entry *b = (const cell_db_entry *)p2;
    if (a->timeout == CELL_INVALID_HOST)
	return -1;
    if (b->timeout == CELL_INVALID_HOST)
	return 1;
    return a->addr.s_addr - b->addr.s_addr;
}

/*
 * Update the hosts for this cell
 */

static void
updatehosts (cell_entry *c, int dbnum, cell_db_entry *dbservers)
{
    cell_db_entry *old_servers = c->dbservers;
    struct timeval tv;
    int i;

    gettimeofday(&tv, NULL);

    for (i = 0; i < dbnum; i++) {
	if (dbservers[i].timeout == CELL_INVALID_HOST
	    || (dbservers[i].timeout && dbservers[i].timeout < tv.tv_sec)) {
	    fetch_host (c, &dbservers[i]);
	}
    }

    if (c->dbservers != dbservers) {
	c->ndbservers = dbnum;
	c->dbservers  = malloc (dbnum * sizeof(cell_db_entry));
	if (c->dbservers == NULL && dbnum != 0)
	    err (1, "malloc %lu", 
		 (unsigned long)dbnum * sizeof(cell_db_entry));
	memcpy (c->dbservers, dbservers, dbnum * sizeof (cell_db_entry));
	free (old_servers);
    } else {
	assert(c->ndbservers == dbnum);
    }

    if (c->ndbservers)
	qsort (c->dbservers, c->ndbservers, sizeof(c->dbservers[0]),
	       host_sort);

    c->active_hosts = 0;
    for (i = 0; i < c->ndbservers; i++) {
	if (c->dbservers[i].timeout != CELL_INVALID_HOST)
	    c->active_hosts++;
    }
}

/*
 * try to lookup `cell' in DNS
 * if c == NULL, a new cell will be allocated
 */

static int
dns_lookup_cell (const char *cell, cell_entry *c)
{
    int i, ret, dbnum = 0;
    cell_db_entry dbservers[256];
    int lowest_ttl = INT_MAX;
    struct timeval tv;

    memset (dbservers, 0, sizeof(dbservers));
    gettimeofday(&tv, NULL);

    ret = _ko_resolve_cell(cell, dbservers, 
			   sizeof(dbservers)/sizeof(dbservers[0]),
			   &dbnum, &lowest_ttl);
    if (ret) {
	log_log (cell_log, CDEBDNS, 
		 "dns_lookup_cell: failed to resolve cell %s", cell);
	return ret;
    }

    for (i = 0; i < dbnum; i++)
	if (dbservers[i].timeout != CELL_INVALID_HOST)
	    dbservers[i].timeout += tv.tv_sec;

    if (lowest_ttl == INT_MAX)
	lowest_ttl = 5 * 60;

    if (c == NULL)
	c = cell_new_dynamic (cell);
    c->timeout = lowest_ttl + tv.tv_sec;
    /* catch the hosts that didn't fit in additional rr */
    updatehosts (c, dbnum, dbservers);
    return 0;
}

/*
 * If the cell-information comes from a source that have a time-limit,
 * make sure the data is uptodate.
 */

static void
update_cell (cell_entry *c)
{
    struct timeval tv;

    gettimeofday(&tv, NULL);

    if (c->id == DYNROOT_CELLID)
	return;

    if ((c->timeout && c->timeout < tv.tv_sec)
	|| c->ndbservers == 0) {
	dns_lookup_cell (c->name, c);
    }
    updatehosts (c, c->ndbservers, c->dbservers);
}

/*
 * cell name -> cell_entry *
 */

cell_entry *
cell_get_by_name (const char *cellname)
{
    cell_entry key, *data;

    key.name = cellname;
    data = (cell_entry *)hashtabsearch (cellnamehtab, &key);
    if (data == NULL) {
	dns_lookup_cell (cellname, NULL);
	data = (cell_entry *)hashtabsearch (cellnamehtab, &key);
    }
    if (data)
	update_cell (data);
    return data;
}

/*
 * cell id -> cell_entry *
 */

cell_entry *
cell_get_by_id (int32_t cell)
{
    cell_entry key, *data;

    key.id = cell;
    data = (cell_entry *)hashtabsearch (cellnumhtab, &key);
    if (data)
	update_cell (data);
    return data;
}

/*
 * cells are assigned monotonically increasing numbers
 * that dont use 0.
 */

static int32_t cellno = 1;

/*
 * Add the cell `name' to the cell cache.
 */

cell_entry *
cell_new (const char *name)
{
    cell_entry *c;

    c = (cell_entry *)malloc (sizeof (*c));
    if (c == NULL)
	return NULL;
    c->name = strdup (name);
    if (c->name == NULL) {
	free (c);
	return NULL;
    }
    c->id           = cellno++;
    assert(c->id != DYNROOT_CELLID);
    c->expl         = NULL;
    c->ndbservers   = 0;
    c->active_hosts = 0;
    c->dbservers    = NULL;
    c->flags	    = 0;
    hashtabadd (cellnamehtab, c);
    hashtabadd (cellnumhtab, c);
    c->timeout      = 0;
    c->poller_timeout = 0;
    celldb_version++;
    return c;
}

/*
 * add a new `dynamic' cell
 */

cell_entry *
cell_new_dynamic (const char *name)
{
    cell_entry *c;

    c = cell_new (name);
    if (c == NULL)
	return NULL;
    c->expl = "dynamically added cell";
    return c;
}

/*
 * Read one line of database information.
 */

static int
readdb (char *line, cell_entry* c, int *dbnum, int maxdbs,
	cell_db_entry *dbservs, int lineno)
{
     struct in_addr numaddr;
     char *hostname, *eh;

     if (*dbnum >= maxdbs) {
	  return -1;
     }
     
     while (isspace((unsigned char)*line))
	    ++line;

     if (inet_aton (line, &numaddr) == 0) {
	  return -1;
     }

     while (*line && !isspace((unsigned char)*line) && *line != '#')
	 ++line;

     hostname = line;

     while (isspace ((unsigned char)*hostname) || *hostname == '#')
	 ++hostname;

     eh = hostname;

     while (*eh && !isspace((unsigned char)*eh) && *eh != '#')
	 ++eh;

     *eh = '\0';

     if (*hostname == '\0')
	 hostname = inet_ntoa (numaddr);
     
     dbservs[*dbnum].name = strdup (hostname);
     if (dbservs[*dbnum].name == NULL)
	 err (1, "strdup");
     dbservs[*dbnum].addr = numaddr;
     dbservs[*dbnum].timeout = 0;
     ++(*dbnum);
     return 0;
}

/*
 * Read the information from the cell-server db.
 */

static int
readcellservdb (const char *filename)
{
     FILE *f;
     char line[256];
     cell_entry *c = NULL;
     int lineno = 0;
     int dbnum;
     cell_db_entry dbservs[256];
     int i;

     f = fopen (filename, "r");
     if (f == NULL) {
	  return 1;
     }

     while (fgets (line, sizeof (line), f)) {
	  ++lineno;
	  i = 0;
	  line[strcspn(line, "\n")] = '\0';
	  while (isspace((unsigned char)line[i]))
		 i++;
	  if (line[i] == '#' || line[i] == '\0')
	       continue;
	  if (line[i] == '>') {
	       if (c != NULL)
		    updatehosts (c, dbnum, dbservs);
	       c = newcell (&line[i] + 1);
	       memset (dbservs, 0, sizeof(dbservs));
	       dbnum = 0;
	  } else {
	      if (readdb(&line[i], c, &dbnum, sizeof (dbservs) /
			 sizeof(*dbservs),
			 dbservs, lineno))
		  continue;
	  }
     }
     if (c != NULL)
	  updatehosts (c, dbnum, dbservs);
     fclose (f);
     return 0;
}

/*
 * Read single line confilefiles in `filename' and send the 
 * to `func'.
 */

static int
parse_simple_file (const char *filename, void (*func)(char *))
{
    FILE *f;
    char line[256];
    
    f = fopen (filename, "r");
    if (f == NULL)
	return 1;
    
    while ((fgets (line, sizeof(line), f) != NULL)) {
	line[strcspn(line, "\n")] = '\0';
	(*func) (line);
    }
    fclose (f);
    return 0;
}

/*
 * Add expanded `cellname' to Thesecells list, filter out duplicates
 */

static void
addthesecell (char *cellname)
{
    const char *cell;
    char **ntc;
    int i;

    cell = cell_expand_cell (cellname);
    for (i = 0; thesecells && thesecells[i]; i++)
	if (strcasecmp (thesecells[i], cell) == 0)
	    return;

    ntc = realloc (thesecells, (numthesecells + 1) * sizeof (char *));
    if (ntc == NULL)
	errx(1, "realloc");
    thesecells = ntc;

    thesecells[numthesecells - 1] = strdup (cell);
    if (thesecells[numthesecells - 1] == NULL)
	errx(1, "strdup");
    thesecells[numthesecells] = NULL;
    ++numthesecells;
}

/*
 * Read cells in TheseCells
 */

static int
readthesecells (const char *filename)
{
     parse_simple_file (filename, addthesecell);
     if (numthesecells == 1)
	 return 1;
     return 0;
}

/*
 * Read name of this cell.
 */

static int
readthiscell (const char *filename)
{
     FILE *f;
     char cell[256];

     f = fopen (filename, "r");
     if (f == NULL)
	 return 1;

     if (fgets (cell, sizeof cell, f) == NULL) {
	 log_log (cell_log, CDEBERR, "Cannot read cellname from %s",
		  filename);
	 return 1;
     }
     cell[strcspn(cell, "\n")] = '\0';
     thiscell = strdup (cell);
     if (thiscell == NULL)
	 err (1, "strdup");
     fclose (f);
     return 0;
}

/*
 * Read suidcells file and set suidcell flag
 */

static void
addsuidcell (char *cellname)
{
    cell_entry *e;

    e = cell_get_by_name (cellname);
    if (e == NULL) {
	log_log (cell_log, CDEBWARN,
		 "suidcell: cell %s doesn't exist in the db", cellname);
    } else {
	e->flags |= SUID_CELL;
    }
}

static int
readsuidcell (const char *filename)
{
    return parse_simple_file (filename, addsuidcell);
}

/*
 *
 */

static void
add_dynroot(char *cellname)
{
    cell_entry *e; 

    e = cell_get_by_name (cellname);
    if (e == NULL) {
	log_log (cell_log, CDEBWARN,
		 "dynroot: cell %s doesn't exist in the db", cellname);
    } else {
	e->flags |= DYNROOT_CELL;
	dynrootdb_in_use = 1;
    }
}

static int
readdynrootdb (const char *filename)
{
    return parse_simple_file (filename, add_dynroot);
}

static void
add_alias(char *alias_line)
{
    const char *delim = " \t";
    char *cellname, *aliasname, *type, *al;
    size_t sz;

    al = alias_line;

#define ENDSTR(str)	((str) == NULL || *(str) == '\0' || *(str) == '#')

    sz = strspn(alias_line, delim);
    al = al + sz;
    if (ENDSTR(al))
	return;
    cellname = strsep(&al, delim);
    if (ENDSTR(cellname) || al == NULL)
	goto out;
    sz = strspn(al, delim);
    al = al + sz;
    if (ENDSTR(al))
	goto out;
    aliasname = strsep(&al, delim);
    if (ENDSTR(aliasname))
	goto out;

    type = "readonly";
    if (al != NULL) {
	sz = strspn(al, delim);
	al = al + sz;
	if (!ENDSTR(al)) {
	    al = strsep(&al, delim);
	    if (!ENDSTR(al))
		type = al;
	}
    }

#undef ENDSTR
    cell_addalias(cellname, aliasname, type);
    return;

 out:
    log_log (cell_log, CDEBWARN,
	     "alias: failed to parse line `%s'", alias_line);
}

static int
readaliasdb (const char *filename)
{
    return parse_simple_file (filename, add_alias);
}

/*
 * Initialize the cache of cell information.
 */

static int cell_inited = 0;

void
cell_init (int cellcachesize, Log_method *logm)
{
    char *env = NULL;
    uid_t uid,euid;
    int ret;

    assert (logm);

    if (cell_inited) {
	log_log (cell_log, CDEBWARN, "cell_init: Already initlized");
	return;
    }
    cell_inited = 1;

    _ko_resolve_init();

    cell_log = log_unit_init (logm, "cell", celldebug_units, CDEBDEFAULT);
    if (cell_log == NULL)
	errx (1, "cell_init: log_unit_init failed");

    if (cellcachesize == 0)
	cellcachesize = DEFCELLCACHESIZE;

    cellnamehtab = hashtabnew (cellcachesize, cellnamecmp, cellnamehash);
    if (cellnamehash == NULL)
	errx (1, "cell_init: hashtabnew failed");
    cellnumhtab  = hashtabnew (cellcachesize, cellnumcmp,  cellnumhash);
    if (cellnumhtab == NULL)
	errx (1, "cell_init: hashtabnew failed");

    uid = getuid();
    euid = geteuid();

    if(uid == euid)
	env = getenv ("AFSCELL");

    if (env != NULL) {
	thiscell = strdup (env);
	if (thiscell == NULL)
	    errx(1, "strdup");
    } else if (readthiscell (SYSCONFDIR "/" THISCELLFILENAME)) {
	if (readthiscell(TRANSARCSYSCONFDIR "/" THISCELLFILENAME))
	    errx (1, "could not open "
		  SYSCONFDIR "/" THISCELLFILENAME
		  " nor "
		  TRANSARCSYSCONFDIR "/" THISCELLFILENAME);
    }

    env = NULL;

    if(uid == euid) 
	env = getenv("CELLSERVDBFILE");

    if(env != NULL) {
	if(readcellservdb (env)) {
	    log_log (cell_log, CDEBWARN,
		     "Can't read the CellServDB file, "
		     "will use DNS AFSDB entries");
	}
    } else if (readcellservdb (SYSCONFDIR "/" CELLFILENAME)) {
	if (readcellservdb(TRANSARCSYSCONFDIR "/" CELLFILENAME)) {
	    log_log (cell_log, CDEBWARN,
		     "Can't read the CellServDB file, "
		     "will use DNS AFSDB entries");
	}
    }
    ret = add_special_dynroot_cell();
    if (ret)
	log_log (cell_log, CDEBWARN, "adding dynroot cell failed with %d", ret);
    
    if (readthesecells (SYSCONFDIR "/" THESECELLFILENAME))
	readthesecells (TRANSARCSYSCONFDIR "/" THESECELLFILENAME);
    if (getenv("HOME") != NULL) {
	char homedir[MAXPATHLEN];
	snprintf (homedir, sizeof(homedir), 
		  "%s/." THESECELLFILENAME,
		  getenv("HOME"));
	readthesecells (homedir);
    }
    addthesecell (thiscell);
    if (readsuidcell (SYSCONFDIR "/" SUIDCELLSFILENAME))
	readsuidcell (TRANSARCSYSCONFDIR "/" SUIDCELLSFILENAME);
    if (readdynrootdb (SYSCONFDIR "/" DYNROOTDBFILENAME))
	readdynrootdb (TRANSARCSYSCONFDIR "/" DYNROOTDBFILENAME);

    cellaliaslist = listnew();
    if (readaliasdb (SYSCONFDIR "/" ALIASDBFILENAME))
	readaliasdb (TRANSARCSYSCONFDIR "/" ALIASDBFILENAME);
}

/*
 *
 */

const char **
cell_thesecells (void)
{
    return (const char **)thesecells;
}

/*
 * Return all db servers for `cell' with the count in `num'.
 * NULL on error.
 */

const cell_db_entry *
cell_dbservers_by_id (int32_t id, int *num)
{
    cell_entry *data = cell_get_by_id (id);

    if (data == NULL)
	return NULL;

    if (data->ndbservers == 0)
	dns_lookup_cell (data->name, data);
     if (data->ndbservers == 0 || data->active_hosts == 0)
	 return NULL;

    *num = data->active_hosts;
    return data->dbservers;
}

/*
 * Return the name of the first database server in `cell' or NULL (if
 * the cell does not exist or it has no db servers).
 */

const char *
cell_findnamedbbyname (const char *cell)
{
     cell_entry *data = cell_get_by_name (cell);

     if (data == NULL)
	  return NULL;
     if (data->ndbservers == 0)
	 dns_lookup_cell (cell, data);
     if (data->ndbservers == 0 || data->active_hosts == 0)
	 return NULL;

     return data->dbservers[0].name ;
}

/*
 * Get the cell of the host
 */

const char *   
cell_getcellbyhost(const char *host)
{
    const char *ptr = NULL;
    assert(host);
    
#ifdef HAVE_KRB4
    ptr = krb_realmofhost(host);
#endif
    if (ptr)
	return ptr;

    ptr = strchr (host, '.');
    if (ptr == NULL)
	return NULL;
    return ptr + 1;
}

/*
 * Return the ID given the name for a cell.
 * -1 if the cell does not exist.
 */

int32_t
cell_name2num (const char *cell)
{
     cell_entry *data = cell_get_by_name (cell);

     if (data != NULL)
	 return data->id;
     else
	 return -1;
}

/*
 * Return the name given the ID or NULL if the cell doesn't exist.
 */

const char *
cell_num2name (int32_t cell)
{
    cell_entry *data = cell_get_by_id (cell);

    if (data != NULL)
	return data->name;
    else
	return NULL;
}

/*
 * Return name of the cell of the cache manager.
 */

const char *
cell_getthiscell (void)
{
    if (thiscell == NULL)
	return "unknown-cell-missing-configuration";
    return thiscell;
}

/*
 *
 */

int
cell_setthiscell (const char *cell)
{
    cell_entry *data;
    char * cp;

    data = cell_get_by_name(cell);
    if (data == NULL) {
	log_log (cell_log, CDEBWARN, "this cell doesn't exist: %s", cell);
	return 1;
    }

    cp = strdup (cell);
    if (cp == NULL) {
	log_log (cell_log, CDEBWARN, "setthiscell: malloc failed");
	return 1;
    }
    free (thiscell);
    thiscell = cp;

    return 0;
}

/*
 * Return if this should be in dynroot
 */

Bool
cell_dynroot (const cell_entry *c)
{
    assert (c);
    if (!dynrootdb_in_use)
	return TRUE;
    return (c->flags & DYNROOT_CELL) != 0;
}

/*
 * Return if this is a suid cell
 */

Bool
cell_issuid (const cell_entry *c)
{
    assert (c);
    return (c->flags & SUID_CELL) != 0;
}

Bool
cell_issuid_by_num (int32_t cell)
{
    cell_entry *c;

    c = cell_get_by_id (cell);
    if (c == NULL)
	return FALSE;
    
    return cell_issuid (c);
}

Bool
cell_issuid_by_name (const char *cell)
{
    cell_entry *c;

    c = cell_get_by_name (cell);
    if (c == NULL)
	return FALSE;
    
    return cell_issuid (c);
}

Bool
cell_setsuid_by_num (int32_t cell)
{
    cell_entry *c;

    c = cell_get_by_id (cell);
    if (c == NULL)
	return FALSE;
    
    c->flags |= SUID_CELL;

    return 0;
}

/*
 *
 */

void
cell_print_cell (const cell_entry *c, FILE *out)
{
    int i;
    char timestr[128];
    struct tm tm;
    time_t t;

    fprintf (out, "name: %s id: %d type: %s\n",
	     c->name, c->id, c->timeout ? "dynamic" : "static");
    fprintf (out, "comment: %s\n", c->expl);
    if (c->timeout) {
	t = c->timeout;
	if (strftime(timestr, sizeof(timestr),
		     "%Y-%m-%d %H:%M:%S", localtime_r(&t, &tm)) > 0)
	    fprintf (out, "timeout: %s\n", timestr);
    }
    fprintf (out, "num hosts: %d active hosts: %d\n",
	     c->ndbservers, c->active_hosts);
    for (i = 0; i < c->ndbservers; i++) {
	char *buf;
	if (c->dbservers[i].timeout == CELL_INVALID_HOST)
	    buf = "invalid";
	else if (c->dbservers[i].timeout == 0)
	    buf = "no timeout";
	else {
	    t = c->timeout;
	    if (strftime(timestr, sizeof(timestr),
			 "%Y-%m-%d %H:%M:%S", localtime_r(&t, &tm)) > 0)
		buf = timestr;
	    else
		buf = "time-error";
	}
	fprintf (out, " host: %s %s - %s\n", c->dbservers[i].name,
		 inet_ntoa (c->dbservers[i].addr), buf);
    }
}

static int
cell_info_print (const cell_entry *e, void *ptr)
{
    FILE *f = (FILE *)ptr;
    cell_print_cell(e, f);
    return 0;
}

/*
 * Print all cell info on `f'
 */

void
cell_status (FILE *f)
{
    cell_foreach(cell_info_print, f);
}


/*
 * Iterate over all entries in the cell-db with `func'
 * (that takes the cellname and `arg' as arguments)
 */

struct cell_iterate_arg {
    void *arg;
    int ret;
    int (*func) (const cell_entry *, void *);
};

static int
cell_iterate_func (void *ptr, void *arg)
{
    struct cell_iterate_arg *cia = (struct cell_iterate_arg *) arg;
    cell_entry *cell = (cell_entry *) ptr;
    int ret;

    if (cell->id == DYNROOT_CELLID)
	return 0;

    ret = (cia->func) (cell, cia->arg);
    if (ret)
	cia->ret = ret;
    return ret;
}

int
cell_foreach (int (*func) (const cell_entry *, void *), void *arg)
{
    struct cell_iterate_arg cia;

    cia.arg = arg;
    cia.ret = 0;
    cia.func = func;

    hashtabforeach (cellnamehtab, cell_iterate_func, &cia);

    return cia.ret;
}

/*
 *
 */

struct cell_expand_arg {
    const char *cell;
    const char *fullcell;
    int32_t last_found;
};

static int
cell_expand_cell_name (const cell_entry *cell, void *data)
{
    struct cell_expand_arg *cea = (struct cell_expand_arg *) data;
    if (strcasecmp (cell->name, cea->cell) == 0) {
	cea->fullcell = cell->name;
	return 1;
    }
    if (strstr (cell->name, cea->cell) && cea->last_found > cell->id) {
	cea->last_found = cell->id;
	cea->fullcell = cell->name;
    }
    return 0;
}

const char *
cell_expand_cell (const char *cell)
{
    struct cell_expand_arg cea;
    cea.cell = cell;
    cea.fullcell = NULL;
    cea.last_found = cellno + 1;

    cell_foreach (cell_expand_cell_name, &cea);
    if (cea.fullcell)
	return cea.fullcell;
    return cell;
}

/*
 *
 */

unsigned long
cell_get_version(void)
{
    return celldb_version;
}

/*
 *
 */

static int
add_special_dynroot_cell (void)
{
    cell_entry * c;

    c = cell_get_by_id (0);
    if (c != NULL)
	errx(-1, "add_special_dynroot_cell: cell id 0 already present\n");

    c = (cell_entry *)malloc (sizeof (*c));
    if (c == NULL)
	return errno;
    c->name = strdup ("#dynrootcell#");
    if (c->name == NULL) {
	free (c);
	return errno;
    }
    c->id         = DYNROOT_CELLID;
    c->expl       = "The special dynroot cell";
    c->ndbservers = 0;
    c->dbservers  = NULL;
    c->flags	  = 0;
    hashtabadd (cellnamehtab, c);
    hashtabadd (cellnumhtab, c);
    return 0;
}

/*
 * Return TRUE if ``cell'' has a sane cellnumber.
 */

Bool
cell_is_sanep (int cell)
{
    return cell < cellno;
} 

/*
 * Get the poller delta time for `cell'. Default is zero, that means
 * that the caller should use the default poller timeout.
 */

time_t
cell_get_poller_time(const cell_entry *cell)
{
    return cell->poller_timeout;
}

/*
 * Set the poller delta `time' for `cell'.
 */

void
cell_set_poller_time(cell_entry *cell, time_t time)
{
    cell->poller_timeout = time;
}

/*
 *
 */

static int
find_alias (const char *cellname, const char *alias, int type, void *arg)
{
    const char *newcell = arg;
    if (strcmp(alias, newcell) == 0)
	return EEXIST;
    return 0;
}

int
cell_addalias(const char *cellname, const char *alias, const char *stype)
{
    struct cellalias *ca;
    int type;
    int ret;

    if (strcasecmp("readonly", stype) == 0 ||
        strcasecmp("ro", stype) == 0)
	type = DYNROOT_ALIAS_READONLY;
    else if (strcasecmp("readwrite", stype) == 0 ||
	     strcasecmp("rw", stype) == 0)
	type = DYNROOT_ALIAS_READWRITE;
    else
	return EINVAL;

    ret = cell_alias_foreach(find_alias, (void *)alias);
    if (ret)
	return ret;

    ca = malloc(sizeof(*ca));
    if (ca == NULL)
	return ENOMEM;
    memset(ca, 0, sizeof(*ca));
    
    ca->type = type;
    ca->name = strdup(cellname);
    if (ca->name == NULL)
	goto out;
    ca->alias = strdup(alias);
    if (ca->alias == NULL)
	goto out;
    ca->li = listaddtail(cellaliaslist, ca);
    if (ca->li == NULL)
	goto out;

    celldb_version++;

    return 0;
 out:
    if (ca->name)
	free(ca->name);
    if (ca->alias)
	free(ca->alias);
    free(ca);
    return ENOMEM;
}


/*
 *
 */

struct listalias_ctx {
    cell_alias_fn func;
    void *ptr;
    int error;
};

static Bool
listalias_f(List *list, Listitem *li, void *arg)
{
    struct cellalias *ca = listdata(li);
    struct listalias_ctx *ctx = arg;
    
    ctx->error = (*ctx->func)(ca->name, ca->alias, ca->type, ctx->ptr);
    if (ctx->error)
	return TRUE;
    return FALSE;
}

int
cell_alias_foreach (cell_alias_fn func, void *ptr)
{
    struct listalias_ctx c;
    c.func = func;
    c.ptr = ptr;
    c.error = 0;

    listiter(cellaliaslist, listalias_f, &c);

    return c.error;
}
@


1.10
log
@remove extra test, but do it correctly this time
@
text
@@


1.9
log
@backout
*c && !isspace(*c) is not equivalent to !isspace(*c)
ok millert@@
@
text
@d432 1
a432 1
     while (*line && isspace((unsigned char)*line))
d490 1
a490 1
	  while (line[0] && isspace((unsigned char)line[i]))
@


1.8
log
@remove some bogus *p tests from charles longeau
ok deraadt millert
@
text
@d432 1
a432 1
     while (isspace((unsigned char)*line))
d439 1
a439 1
     while (!isspace((unsigned char)*line) && *line != '#')
d449 1
a449 1
     while (!isspace((unsigned char)*eh) && *eh != '#')
d490 1
a490 1
	  while (isspace((unsigned char)line[i]))
@


1.7
log
@afs cleanup, realloc strings, abort, etc.
testing by beck, hin, jose, fries. ok deraadt@@
@
text
@d432 1
a432 1
     while (*line && isspace((unsigned char)*line))
d439 1
a439 1
     while (*line && !isspace((unsigned char)*line) && *line != '#')
d449 1
a449 1
     while (*eh && !isspace((unsigned char)*eh) && *eh != '#')
d490 1
a490 1
	  while (line[0] && isspace((unsigned char)line[i]))
@


1.6
log
@Merge
@
text
@d927 1
d935 5
d941 2
a942 4
    thiscell = strdup (cell);
    if (thiscell == NULL)
	abort();
    
d1170 1
a1170 1
	abort();
@


1.5
log
@Merge in some progname changes, and a couple of bugfixes from arla.
@
text
@d2 1
a2 1
 * Copyright (c) 1995 - 2000 Kungliga Tekniska Högskolan
d40 1
a40 8
#ifdef HAVE_ARPA_NAMESER_H
#include <arpa/nameser.h>
#endif
#ifdef HAVE_RESOLV_H
#include <resolv.h>
#endif

#ifdef KERBEROS
d44 1
a44 3
#include "resolve.h"

RCSID("$KTH: kocell.c,v 1.47.2.3 2001/07/09 03:27:48 lha Exp $");
d52 1
a69 2
enum { CELL_INVALID_HOST = 1 };

d103 13
d181 1
a181 1
 *
a186 2
    struct dns_reply *r;
    struct resource_record *rr;
d188 1
d192 2
a193 2
    r = dns_lookup(host->name, "A");
    if (r == NULL) {
d200 2
a201 10
    for(rr = r->head; rr;rr=rr->next){
	if (rr->type == T_A) {
	    if (strcmp(host->name,rr->domain) == 0) {
		host->addr = *(rr->u.a);
		host->timeout = tv.tv_sec + rr->ttl;
		break;
	    }
	}
    }
    dns_free_data(r);
d241 11
a251 6
    c->ndbservers = dbnum;
    c->dbservers  = malloc (dbnum * sizeof(cell_db_entry));
    if (c->dbservers == NULL && dbnum != 0)
	err (1, "malloc %lu", (unsigned long)dbnum * sizeof(cell_db_entry));
    memcpy (c->dbservers, dbservers, dbnum * sizeof (cell_db_entry));
    free (old_servers);
d272 1
a272 3
    struct dns_reply *r;
    struct resource_record *rr;
    int dbnum = 0;
a274 1
    int i;
d280 4
a283 2
    r = dns_lookup(cell, "AFSDB");
    if (r == NULL) {
d286 1
a286 1
	return 1;
a287 2
    if (c == NULL)
	c = cell_new_dynamic (cell);
d289 3
a291 31
    for(rr = r->head; rr;rr=rr->next){
	if(rr->type == T_AFSDB) {
	    struct mx_record *mx = (struct mx_record*)rr->u.data;

	    if (mx->preference != 1) {
		break;
	    }
	    if (dbnum >= sizeof (dbservers) / sizeof(*dbservers)) {
	        break;
	    }
	    if (lowest_ttl > rr->ttl)
		lowest_ttl = rr->ttl;
	    dbservers[dbnum].name = strdup (mx->domain);
	    if (dbservers[dbnum].name == NULL)
		err (1, "strdup");
	    dbservers[dbnum].timeout = CELL_INVALID_HOST;
	    dbnum++;
	}
    }
    for(rr = r->head; rr;rr=rr->next){
	if (rr->type == T_A) {
	    for (i = 0; i < dbnum; i++) {
		if (strcmp(dbservers[i].name,rr->domain) == 0) {
		    dbservers[i].addr = *(rr->u.a);
		    dbservers[i].timeout = tv.tv_sec + rr->ttl;
		    break;
		}
	    }
	}
    }
    dns_free_data(r);
d294 5
a298 2
	lowest_ttl = 0;
    
a299 1
    c->timeout = lowest_ttl + tv.tv_sec;
d316 3
a385 1
    assert (cellno != 0);
d387 1
d396 1
a408 1
    FILE *f;
a413 9
    f = fopen (SYSCONFDIR "/" CELLFILENAME, "a");
    if (f == NULL)
	f = fopen (TRANSARCSYSCONFDIR "/" CELLFILENAME, "a");
    if (f == NULL) {
	log_log (cell_log, CDEBWARN,"Cannot open CellServDB for writing");
	return c;
    }
    fprintf (f, ">%s	#dynamically added cell\n", name);
    fclose (f);
d489 1
a489 1
	  line[strlen(line) - 1] = '\0';
d519 1
a519 1
parse_simple_file (const char *filename, void (*func)(const char *))
d529 1
a529 1
	line[strlen(line) - 1] = '\0';
d541 1
a541 1
addthesecell (const char *cellname)
d543 2
d546 2
a547 1
    cellname = cell_expand_cell (cellname);
d549 1
a549 1
	if (strcasecmp (thesecells[i], cellname) == 0)
d551 9
a559 3
    thesecells = erealloc (thesecells, 
			   (numthesecells + 1) * sizeof (char *));
    thesecells[numthesecells - 1] = estrdup (cellname);
d592 1
a592 1
	 log_log (cell_log, CDEBERR, "Cannot read cellname from %s\n",
d596 1
a596 2
     if (cell[strlen(cell) - 1] == '\n')
	 cell[strlen(cell) - 1] = '\0';
d609 1
a609 1
addsuidcell (const char *cellname)
d616 1
a616 1
		 "suidcell: cell %s doesn't exist in the db\n", cellname);
d633 1
a633 1
add_dynroot(const char *cellname)
d640 1
a640 1
		 "dynroot: cell %s doesn't exist in the db\n", cellname);
d653 52
d712 1
a712 1
cell_init (int cellcachesize, Log_method *log)
d714 2
a715 1
    char *env;
d718 1
a718 1
    assert (log);
d726 1
a726 3
#ifdef HAVE_RES_INIT
    res_init();
#endif
d728 1
a728 1
    cell_log = log_unit_init (log, "cell", celldebug_units, CDEBDEFAULT);
d742 6
a747 1
    env = getenv ("AFSCELL");
d749 3
a751 1
	thiscell = estrdup (env);
d760 12
a771 1
    if (readcellservdb (SYSCONFDIR "/" CELLFILENAME)) {
d797 3
d864 1
a864 1
#ifdef KERBEROS
d914 2
a915 2
    assert (thiscell != NULL);

d1009 1
a1009 1
cell_print_cell (cell_entry *c, FILE *out)
d1012 1
a1012 1
    char timestr[30];
d1021 3
a1023 3
	strftime(timestr, sizeof(timestr),
		 "%Y-%m-%d %H:%M:%S", localtime_r(&t, &tm));
	fprintf (out, "timeout: %s\n", timestr);
d1035 5
a1039 3
	    strftime(timestr, sizeof(timestr),
		     "%Y-%m-%d %H:%M:%S", localtime_r(&t, &tm));
	    buf = timestr;
d1046 19
d1083 3
d1176 1
a1176 1
    c->id         = 0; /* XXX */
d1195 118
@


1.4
log
@merge
@
text
@d277 1
a277 1
    int lowest_ttl;
d303 1
a303 1
	    if (lowest_ttl > rr->ttl || lowest_ttl == 0)
d325 3
@


1.3
log
@New Arla userland from Arla between 0.34.2 and current in arla cvs.
Too many new features and fixes to mention here.
@
text
@d17 1
a17 6
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by the Kungliga Tekniska
 *      Högskolan and its contributors.
 * 
 * 4. Neither the name of the Institute nor the names of its contributors
d53 1
a53 1
RCSID("$Id: kocell.c,v 1.37 2000/08/06 16:05:30 lha Exp $");
d60 1
d76 25
d102 1
a109 2
static int suid_read = 0;

d178 51
a228 1
 * Record this cell in the hashtable
d232 1
a232 1
recordcell (cell_entry *c, int dbnum, cell_db_entry *dbservers)
d234 29
a262 5
     c->ndbservers = dbnum;
     c->dbservers  = malloc (dbnum * sizeof(cell_db_entry));
     if (c->dbservers == NULL)
	 err (1, "malloc %lu", (unsigned long)dbnum * sizeof(cell_db_entry));
     memcpy (c->dbservers, dbservers, dbnum * sizeof (cell_db_entry));
d270 2
a271 2
static void
try_to_find_cell(const char *cell, cell_entry *c)
d277 6
d285 8
a292 2
    if (r == NULL)
	return;
a299 2
	    if (c == NULL)
		c = cell_new_dynamic (cell);
d303 2
d308 2
a309 3
	    dbservers[dbnum].addr.s_addr = inet_addr ("0.0.0.0");
	    ++dbnum;
	    break;
a313 2
	    int i;

d317 1
a322 2
    if (c)
	recordcell (c, dbnum, dbservers);
d324 24
d362 1
a362 1
	try_to_find_cell (cellname, NULL);
d365 2
d377 1
a377 1
    cell_entry key;
d380 4
a383 1
    return (cell_entry *)hashtabsearch (cellnumhtab, &key);
d411 6
a416 5
    c->id         = cellno++;
    c->expl       = NULL;
    c->ndbservers = 0;
    c->dbservers  = NULL;
    c->suid_cell  = NOSUID_CELL;
d419 1
d437 1
d442 1
a442 1
	fprintf (stderr, "Cannot open CellServDB for writing\n");
d464 4
d472 1
a472 1
     while (*line && !isspace(*line) && *line != '#')
d477 1
a477 1
     while (isspace (*hostname) || *hostname == '#')
d482 1
a482 1
     while (*eh && !isspace(*eh) && *eh != '#')
d494 1
d512 1
d521 1
d523 3
a525 1
	  if (*line == '#' || *line == '\0')
d527 1
a527 1
	  if (*line == '>') {
d529 3
a531 2
		    recordcell (c, dbnum, dbservs);
	       c = newcell (line + 1);
d534 4
a537 4
	       if (readdb(line, c, &dbnum, sizeof (dbservs) /
			  sizeof(*dbservs),
			  dbservs, lineno))
		    continue;
d541 1
a541 1
	  recordcell (c, dbnum, dbservs);
d547 23
d589 1
a589 1
 * Read cells in these cell's
d595 1
a595 12
     FILE *f;
     char cell[256];

     f = fopen (filename, "r");
     if (f == NULL)
	 return 1;

     while ((fgets (cell, sizeof cell, f) != NULL)) {
	 cell[strlen(cell) - 1] = '\0';
	 addthesecell (cell);
     }
     fclose (f);
d616 1
a616 1
	  fprintf(stderr, "Cannot read cellname from %s\n",
d618 1
a618 1
	  return 1;
d633 14
d650 1
a650 24
     FILE *f;
     char cell[256];

     f = fopen (filename, "r");
     if (f == NULL)
	 return 1;

     while (fgets (cell, sizeof(cell), f) != NULL) {
	 int i;
	 cell_entry *e;

	 i = strlen (cell);
	 if (cell[i - 1] == '\n')
	     cell[i - 1] = '\0';

	 e = cell_get_by_name (cell);
	 if (e == NULL) {
	     fprintf (stderr, "cell %s doesn't exist in the db\n", cell);
	 } else {
	     e->suid_cell = SUID_CELL;
	 }
     }
     fclose (f);
     return 0;
d654 1
a654 1
 * initialize suid information, if hasn't already been done
d658 1
a658 1
cond_readsuidcell (void)
d660 11
a670 2
    if (suid_read)
	return;
d672 4
a675 3
    if (readsuidcell (SYSCONFDIR "/" SUIDCELLSFILENAME))
	readsuidcell (TRANSARCSYSCONFDIR "/" SUIDCELLSFILENAME);
    suid_read = 1;
d685 1
a685 1
cell_init (int cellcachesize)
d690 2
d693 1
a693 1
	fprintf(stderr, "cell_init: Already initlized\n");
d698 8
d729 3
a731 2
	    fprintf(stderr, "Can't read the CellServDB file," \
		    "will use DNS AFSDB entries\n");
d736 2
a737 2
	fprintf (stderr, "adding dynroot cell failed with %d", ret);

d748 5
d779 3
a781 1
	try_to_find_cell (data->name, data);
d783 1
a783 1
    *num = data->ndbservers;
d800 2
a801 2
	 try_to_find_cell (cell, data);
     if (data->ndbservers == 0)
d826 1
a826 1
    return strdup (ptr + 1);
a880 3
    if (!cell_inited)
	cell_init (0);

d883 1
a883 1
	fprintf (stderr, "this cell doesn't exist: %s", cell);
d896 13
d913 1
a913 1
cell_issuid (cell_entry *c)
d916 1
a916 3

    cond_readsuidcell ();
    return c->suid_cell == SUID_CELL;
a923 1
    cond_readsuidcell ();
a935 1
    cond_readsuidcell ();
a947 1
    cond_readsuidcell ();
d952 1
a952 1
    c->suid_cell = SUID_CELL;
d958 40
d1109 1
a1109 1
    c->suid_cell  = NOSUID_CELL;
@


1.2
log
@upgrade Arla to fresher code. Too many new features and bugfixes.
@
text
@a0 1
/*	$OpenBSD$	*/
d2 1
a2 1
 * Copyright (c) 1995, 1996, 1997, 1998, 1999 Kungliga Tekniska Högskolan
d58 1
a58 1
RCSID("$KTH: kocell.c,v 1.19 1999/01/04 23:11:00 assar Exp $");
d64 1
d78 13
d102 1
a102 1
     return strcmp (c1->name, c2->name);
d110 1
a110 1
     return hashadd (c->name);
d164 2
a165 5
     if(dbnum == 0)
	  KODEB (KODEBMISC, ("No db-servers for cell %s\n", c->name));

     c->ndbservers  = dbnum;
     c->dbservers = (cell_db_entry *)malloc (dbnum * sizeof(cell_db_entry));
d167 1
a167 1
	 err (1, "malloc %u", dbnum * sizeof(cell_db_entry));
d173 1
d177 1
a177 1
try_to_find_cell(const char *cell)
a180 1
    cell_entry *c = NULL;
d188 1
a188 2
	switch(rr->type){
	case T_AFSDB: {
a191 3
		KODEB (KODEBMISC,
		       ("Ignoring host with cell type %d in cell %s",
			mx->preference, c->name));
d195 1
a195 1
		c = cell_new (cell);
a196 2
		KODEB (KODEBMISC, ("Too many database servers for "
				   "cell %s. Ignoring\n", c->name));
a205 1
	}
d208 2
a209 1
	int i;
a210 2
	switch(rr->type){
	case T_A: {
a217 1
	}
d225 1
a225 1
 *
d236 1
a236 1
	try_to_find_cell (cellname);
d243 1
a243 1
 *
d257 1
d260 1
a260 1
static long cellno = 0;
d263 1
a263 1
 *
d279 2
a280 4
    if (strcmp (c->name, cell_getthiscell ()) == 0)
	c->id = 0;
    else
	c->id = ++cellno;
d284 1
a284 1
    c->suid_cell = NOSUID_CELL;
d287 26
d325 1
a325 1
     char *hostname;
a327 2
	  KODEB (KODEBMISC, ("Too many database servers for "
		   "cell %s. Ignoring\n", c->name));
d330 1
a330 4
     if ( (hostname = strchr (line, '#')) == NULL
	 || (numaddr.s_addr = inet_addr (line)) == -1 ) {
	  KODEB (KODEBMISC, ("Syntax error at line %d in %s\n",
		   lineno, CELLFILENAME));
a331 7
     } else {
	  ++hostname;
	  dbservs[*dbnum].name = strdup (hostname);
	  if (dbservs[*dbnum].name == NULL)
	      err (1, "strdup");
	  dbservs[*dbnum].addr = numaddr;
	  ++(*dbnum);
d333 24
a375 2
	  KODEB (KODEBMISC, ("Cannot read cell information from %s\n", 
		   filename));
d381 1
a381 5
	  if (line[strlen(line) - 1 ] != '\n')
	       KODEB (KODEBMISC, ("Too long line at line %d in %s\n",
			lineno, filename));
	  else
	       line[strlen(line) - 1] = '\0';
d403 43
d456 1
a456 2
     if (f == NULL) {
	 fprintf(stderr, "Can't open file %s.\n", filename);
a457 1
     }
a463 1
     cell[sizeof(cell)-1] = '\0';
d484 1
a484 2
     if (f == NULL) {
	 fprintf(stderr, "Can't open file %s.\n", filename);
a485 1
     }
a490 1
	 cell[sizeof(cell)-1] = '\0';
d507 15
d525 2
d531 1
d533 1
a533 1
    if (thiscell != NULL) {
d537 1
d551 1
a551 3
	thiscell = strdup (env);
	if (thiscell == NULL)
	    err (1, "strdup");
d553 5
a557 5
	fprintf(stderr, "Falling back on: " TRANSARCSYSCONFDIR "\n"); 
	if (readthiscell(TRANSARCSYSCONFDIR "/" THISCELLFILENAME)) {
	    fprintf(stderr, "Don't know where I am\n");
	    exit(1);
	}
a560 1
	fprintf(stderr, "Falling back on: " TRANSARCSYSCONFDIR "\n");
d566 12
a577 4
    if (readsuidcell (SYSCONFDIR "/" SUIDCELLSFILENAME)) {
	fprintf (stderr, "Falling back on: " TRANSARCSYSCONFDIR "\n");
	if (readsuidcell (TRANSARCSYSCONFDIR "/" SUIDCELLSFILENAME))
	    fprintf (stderr, "Cant read suid cells, ignoring\n");
d579 11
d598 1
a598 1
cell_dbservers (int32_t cell, int *num)
d600 1
a600 1
    cell_entry *data = cell_get_by_id (cell);
d602 1
a602 2
    if (data == NULL) {
	KODEB (KODEBMISC, ("Cannot find cell %d\n", cell));
d604 4
a607 1
    }
d613 2
a614 4
 * Find the name of DB server to talk to for a given cell.
 *
 *   Warning: This is not really good since name could be something
 *     like NULL.
d622 1
a622 2
     if (data == NULL) {
	  KODEB (KODEBMISC, ("Cannot find cell %d\n", cell));
d624 5
a628 5
     }
     if (data->ndbservers == 0) {
	  KODEB (KODEBMISC, ("No DB servers for cell %d\n", cell));
	  return NULL;
     }
d648 2
a649 4
    ptr = host;
    while(*ptr && *ptr != '.') ptr++;
    
    if (*ptr == '\0')
d651 1
a651 2

    return strdup(ptr); 
d692 29
a720 1
     return thiscell;
d732 1
d739 4
a742 1
    cell_entry *c = cell_get_by_id (cell);
d752 4
a755 1
    cell_entry *c = cell_get_by_name (cell);
d765 4
a768 1
    cell_entry *c = cell_get_by_id (cell);
d776 128
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
 * Copyright (c) 1995, 1996, 1997, 1998 Kungliga Tekniska Högskolan
d44 2
a45 10
#ifdef HAVE_CONFIG_H
#include <config.h>
#endif
#include <stdio.h>
#ifdef HAVE_SYS_TYPES_H
#include <sys/types.h>
#endif
#ifdef HAVE_NETINET_IN_H
#include <netinet/in.h>
#endif
d54 1
a54 1
#include <kerberosIV/krb.h>
a56 1
#include "ko_locl.h"
d59 1
a59 1
RCSID("$KTH: kocell.c,v 1.13 1998/07/28 14:54:08 assar Exp $");
d64 1
a64 1

a66 13
typedef struct {
     const char *name;
     struct in_addr addr;
} DbServerEntry;

typedef struct {
     int32_t id;		/* Cell-ID */
     const char *name;		/* Domain-style name */
     const char *expl;		/* Longer name */
     unsigned ndbservs;		/* # of database servers */
     DbServerEntry *dbservs;	/* Database servers */
} CellEntry;

d86 2
a87 2
     CellEntry *c1 = (CellEntry *)a;
     CellEntry *c2 = (CellEntry *)b;
d95 1
a95 1
     CellEntry *c = (CellEntry *)a;
d103 2
a104 2
     CellEntry *c1 = (CellEntry *)a;
     CellEntry *c2 = (CellEntry *)b;
d112 1
a112 1
     CellEntry *c = (CellEntry *)a;
d118 27
d149 1
a149 1
recordcell (CellEntry *c, int dbnum, DbServerEntry *dbservs)
d154 5
a158 8
     c->ndbservs = dbnum;
     c->dbservs  = (DbServerEntry*)malloc (dbnum * sizeof(DbServerEntry));
     if (c->dbservs == NULL)
	 err (1, "malloc %u", dbnum * sizeof(DbServerEntry));
     memcpy (c->dbservs, dbservs, dbnum * sizeof (DbServerEntry));
							 
     hashtabadd (cellnamehtab, c);
     hashtabadd (cellnumhtab, c);
d162 100
a261 1
 * New cell from cellserver-database file
d264 2
a265 2
static CellEntry *
newcell (const char *line, int *dbnum)
d267 1
a267 5
     static long cellno = 0;
     char *hash;
     CellEntry *c;
     int len;
     char *tmp;
d269 19
a287 24
     c = (CellEntry *)malloc (sizeof (*c));
     if (c == NULL)
	 err (1, "malloc %u", sizeof(*c));
     len = strcspn (line, " \t#");
     tmp = malloc (len + 1);
     if (tmp == NULL)
	 err (1, "strdup");
     strncpy (tmp, line, len);
     tmp[len] = '\0';
     c->name = tmp;
     if (strcmp (c->name, cell_getthiscell ()) == 0)
	  c->id = 0;
     else
	  c->id = ++cellno;
     line += len + 1;
     hash = strchr (line, '#');
     if (hash != NULL) {
	  c->expl = strdup (hash+1);
	  if (c->expl == NULL)
	      err (1, "strdup");
     } else
	  c->expl = NULL;
     *dbnum = 0;
     return c;
d295 2
a296 2
readdb (char *line, CellEntry* c, int *dbnum, int maxdbs,
	DbServerEntry *dbservs, int lineno)
d331 1
a331 1
     CellEntry *c = NULL;
d334 1
a334 1
     DbServerEntry dbservs[256];
d355 2
a356 1
	       c = newcell (line + 1, &dbnum);
d391 1
d402 36
d481 5
d489 2
a490 1
 * Find a DB server to talk to for a given cell.
d493 2
a494 2
struct in_addr
cell_finddbserver (int32_t cell)
d496 1
a496 23
     CellEntry key;
     CellEntry *data;
     struct in_addr addr;

     key.id = cell;
     data = hashtabsearch (cellnumhtab, &key);
     if (data == NULL) {
	  KODEB (KODEBMISC, ("Cannot find cell %d\n", cell));
	  return addr;
     }
     if (data->ndbservs == 0) {
	  KODEB (KODEBMISC, ("No DB servers for cell %d\n", cell));
	  return addr;
     }
     if (ipgetaddr (data->dbservs[0].name, &addr))
	  return addr;
     else
	  return data->dbservs[0].addr;
}

/*
 * Return DB server number "index" for a given cell.
 */
a497 9
u_long
cell_listdbserver (int32_t cell, int index)
{
    CellEntry key;
    CellEntry *data;
    struct in_addr addr;
    
    key.id = cell;
    data = hashtabsearch (cellnumhtab, &key);
d500 1
a500 1
	return 0;
d502 2
a503 7
    if (data->ndbservs <= index) {
	return 0;
    }
    if (ipgetaddr (data->dbservs[index].name, &addr))
	return addr.s_addr;
    else
	return data->dbservs[index].addr.s_addr;
a505 1

d516 1
a516 2
     CellEntry key;
     CellEntry *data;
a517 2
     key.name = cell;
     data = hashtabsearch (cellnamehtab, &key);
d522 1
a522 1
     if (data->ndbservs == 0) {
d526 1
a526 1
     return data->dbservs[0].name ;
a528 59
static void
try_to_find_cell(const char *cell)
{
    struct dns_reply *r;
    struct resource_record *rr;
    CellEntry *c = NULL;
    int dbnum;
    DbServerEntry dbservs[256];

    r = dns_lookup(cell, "AFSDB");
    if (r == NULL)
	return;
    for(rr = r->head; rr;rr=rr->next){
	switch(rr->type){
	case T_AFSDB: {
	    struct mx_record *mx = (struct mx_record*)rr->u.data;

	    if (mx->preference != 1) {
		KODEB (KODEBMISC,
		       ("Ignoring host with cell type %d in cell %s",
			mx->preference, c->name));
		break;
	    }
	    if (c == NULL)
		c = newcell (cell, &dbnum);
	    if (dbnum >= sizeof (dbservs) / sizeof(*dbservs)) {
		KODEB (KODEBMISC, ("Too many database servers for "
				   "cell %s. Ignoring\n", c->name));
	        break;
	    }
	    dbservs[dbnum].name = strdup (mx->domain);
	    if (dbservs[dbnum].name == NULL)
		err (1, "strdup");
	    dbservs[dbnum].addr.s_addr = inet_addr ("0.0.0.0");
	    ++dbnum;
	    break;
	}
	}
    }
    for(rr = r->head; rr;rr=rr->next){
	int i;

	switch(rr->type){
	case T_A: {
	    for (i = 0; i < dbnum; i++) {
		if (strcmp(dbservs[i].name,rr->domain) == 0) {
		    dbservs[i].addr = *(rr->u.a);
		    break;
		}
	    }
	}
	}
    }
    if (c)
	recordcell (c, dbnum, dbservs);
    dns_free_data(r);
}


d562 1
a562 1
     CellEntry key, *data;
d564 4
a567 12
     key.name = cell;
     data = hashtabsearch (cellnamehtab, (void *)&key);
     if (data)
	  return data->id;
     else {
	 try_to_find_cell(cell);
	 data = hashtabsearch (cellnamehtab, (void *)&key);
	 if (data)
	     return data->id;
	 else
	     return -1;
     }
d577 1
a577 1
    CellEntry key, *data;
d579 1
a579 3
    key.id = cell;
    data = hashtabsearch (cellnumhtab, (void *)&key);
    if (data)
d593 44
@


1.1.1.1
log
@Initial version of Arla, a free implementation of an AFS cache-manager.
(second try, hopefully into the correct repository this time)
@
text
@@


1.1.1.2
log
@Import of arla-0.35.7
@
text
@d1 1
d3 1
a3 1
 * Copyright (c) 1995 - 2000 Kungliga Tekniska Högskolan
d18 6
a23 1
 * 3. Neither the name of the Institute nor the names of its contributors
d44 10
a53 2
#include "ko_locl.h"

d62 1
a62 1
#include <krb.h>
d65 1
d68 1
a68 1
RCSID("$KTH: kocell.c,v 1.47.2.3 2001/07/09 03:27:48 lha Exp $");
d73 1
a73 3
#define SUIDCELLSFILENAME "SuidCells"
#define THESECELLFILENAME "TheseCells"
#define DYNROOTDBFILENAME "DynRootDB"
d76 13
a99 37
static char **thesecells = NULL;
static int numthesecells = 1;
static int dynrootdb_in_use;

enum { CELL_INVALID_HOST = 1 };

/*
 * Logging
 */

#define CDEBERR		0x800
#define CDEBWARN	0x400
#define CDEBDNS		0x200

#define CDEBDEFAULT	(CDEBWARN|CDEBERR)
#define cdeball		(CDEBWARN|CDEBERR)

static struct units celldebug_units[]  = {
    { "all", 		cdeball },
    { "almost-all",	cdeball },
    { "warn",		CDEBWARN },
    { "error", 		CDEBERR },
    { "dns",		CDEBDNS },
    { NULL, 0 },
};

#undef cdeball

static Log_unit *cell_log = NULL;

/*
 *
 */

static unsigned long celldb_version = 0;

static int add_special_dynroot_cell (void);
d108 2
a109 2
     cell_entry *c1 = (cell_entry *)a;
     cell_entry *c2 = (cell_entry *)b;
d111 1
a111 1
     return strcasecmp (c1->name, c2->name);
d117 1
a117 1
     cell_entry *c = (cell_entry *)a;
d119 1
a119 1
     return hashcaseadd (c->name);
d125 2
a126 2
     cell_entry *c1 = (cell_entry *)a;
     cell_entry *c2 = (cell_entry *)b;
d134 1
a134 1
     cell_entry *c = (cell_entry *)a;
d140 20
d163 2
a164 2
static cell_entry *
newcell (char *line)
d166 1
d168 1
a168 1
     cell_entry *c;
d170 1
d172 3
d176 10
a185 5
     line[len] = '\0';
     c = cell_new (line);
     if (c == NULL)
	 err (1, "malloc failed");

d192 3
a194 1
     }
a198 273
 *
 */

static void
fetch_host (cell_entry *c, cell_db_entry *host)
{
    struct dns_reply *r;
    struct resource_record *rr;
    struct timeval tv;

    gettimeofday (&tv, NULL);
    
    r = dns_lookup(host->name, "A");
    if (r == NULL) {
	log_log (cell_log, CDEBDNS, 
		 "fetch_host: failed to resolve host %s in cell %s",
		 host->name, c->name);
	host->timeout = CELL_INVALID_HOST;
	return;
    }
    for(rr = r->head; rr;rr=rr->next){
	if (rr->type == T_A) {
	    if (strcmp(host->name,rr->domain) == 0) {
		host->addr = *(rr->u.a);
		host->timeout = tv.tv_sec + rr->ttl;
		break;
	    }
	}
    }
    dns_free_data(r);
}


/*
 * Help function for updatehosts
 */

static int 
host_sort (const void *p1, const void *p2)
{
    const cell_db_entry *a = (const cell_db_entry *)p1;
    const cell_db_entry *b = (const cell_db_entry *)p2;
    if (a->timeout == CELL_INVALID_HOST)
	return -1;
    if (b->timeout == CELL_INVALID_HOST)
	return 1;
    return a->addr.s_addr - b->addr.s_addr;
}

/*
 * Update the hosts for this cell
 */

static void
updatehosts (cell_entry *c, int dbnum, cell_db_entry *dbservers)
{
    cell_db_entry *old_servers = c->dbservers;
    struct timeval tv;
    int i;

    gettimeofday(&tv, NULL);

    for (i = 0; i < dbnum; i++) {
	if (dbservers[i].timeout == CELL_INVALID_HOST
	    || (dbservers[i].timeout && dbservers[i].timeout < tv.tv_sec)) {
	    fetch_host (c, &dbservers[i]);
	}
    }

    c->ndbservers = dbnum;
    c->dbservers  = malloc (dbnum * sizeof(cell_db_entry));
    if (c->dbservers == NULL && dbnum != 0)
	err (1, "malloc %lu", (unsigned long)dbnum * sizeof(cell_db_entry));
    memcpy (c->dbservers, dbservers, dbnum * sizeof (cell_db_entry));
    free (old_servers);

    if (c->ndbservers)
	qsort (c->dbservers, c->ndbservers, sizeof(c->dbservers[0]),
	       host_sort);

    c->active_hosts = 0;
    for (i = 0; i < c->ndbservers; i++) {
	if (c->dbservers[i].timeout != CELL_INVALID_HOST)
	    c->active_hosts++;
    }
}

/*
 * try to lookup `cell' in DNS
 * if c == NULL, a new cell will be allocated
 */

static int
dns_lookup_cell (const char *cell, cell_entry *c)
{
    struct dns_reply *r;
    struct resource_record *rr;
    int dbnum = 0;
    cell_db_entry dbservers[256];
    int lowest_ttl;
    int i;
    struct timeval tv;

    memset (dbservers, 0, sizeof(dbservers));
    gettimeofday(&tv, NULL);

    r = dns_lookup(cell, "AFSDB");
    if (r == NULL) {
	log_log (cell_log, CDEBDNS, 
		 "dns_lookup_cell: failed to resolve cell %s", cell);
	return 1;
    }
    if (c == NULL)
	c = cell_new_dynamic (cell);

    for(rr = r->head; rr;rr=rr->next){
	if(rr->type == T_AFSDB) {
	    struct mx_record *mx = (struct mx_record*)rr->u.data;

	    if (mx->preference != 1) {
		break;
	    }
	    if (dbnum >= sizeof (dbservers) / sizeof(*dbservers)) {
	        break;
	    }
	    if (lowest_ttl > rr->ttl || lowest_ttl == 0)
		lowest_ttl = rr->ttl;
	    dbservers[dbnum].name = strdup (mx->domain);
	    if (dbservers[dbnum].name == NULL)
		err (1, "strdup");
	    dbservers[dbnum].timeout = CELL_INVALID_HOST;
	    dbnum++;
	}
    }
    for(rr = r->head; rr;rr=rr->next){
	if (rr->type == T_A) {
	    for (i = 0; i < dbnum; i++) {
		if (strcmp(dbservers[i].name,rr->domain) == 0) {
		    dbservers[i].addr = *(rr->u.a);
		    dbservers[i].timeout = tv.tv_sec + rr->ttl;
		    break;
		}
	    }
	}
    }
    dns_free_data(r);

    /* catch the hosts that didn't fit in additional rr */
    c->timeout = lowest_ttl + tv.tv_sec;
    updatehosts (c, dbnum, dbservers);
    return 0;
}

/*
 * If the cell-information comes from a source that have a time-limit,
 * make sure the data is uptodate.
 */

static void
update_cell (cell_entry *c)
{
    struct timeval tv;

    gettimeofday(&tv, NULL);

    if ((c->timeout && c->timeout < tv.tv_sec)
	|| c->ndbservers == 0) {
	dns_lookup_cell (c->name, c);
    }
    updatehosts (c, c->ndbservers, c->dbservers);
}

/*
 * cell name -> cell_entry *
 */

cell_entry *
cell_get_by_name (const char *cellname)
{
    cell_entry key, *data;

    key.name = cellname;
    data = (cell_entry *)hashtabsearch (cellnamehtab, &key);
    if (data == NULL) {
	dns_lookup_cell (cellname, NULL);
	data = (cell_entry *)hashtabsearch (cellnamehtab, &key);
    }
    if (data)
	update_cell (data);
    return data;
}

/*
 * cell id -> cell_entry *
 */

cell_entry *
cell_get_by_id (int32_t cell)
{
    cell_entry key, *data;

    key.id = cell;
    data = (cell_entry *)hashtabsearch (cellnumhtab, &key);
    if (data)
	update_cell (data);
    return data;
}

/*
 * cells are assigned monotonically increasing numbers
 * that dont use 0.
 */

static int32_t cellno = 1;

/*
 * Add the cell `name' to the cell cache.
 */

cell_entry *
cell_new (const char *name)
{
    cell_entry *c;

    c = (cell_entry *)malloc (sizeof (*c));
    if (c == NULL)
	return NULL;
    c->name = strdup (name);
    if (c->name == NULL) {
	free (c);
	return NULL;
    }
    assert (cellno != 0);
    c->id           = cellno++;
    c->expl         = NULL;
    c->ndbservers   = 0;
    c->active_hosts = 0;
    c->dbservers    = NULL;
    c->flags	    = 0;
    hashtabadd (cellnamehtab, c);
    hashtabadd (cellnumhtab, c);
    c->timeout      = 0;
    celldb_version++;
    return c;
}

/*
 * add a new `dynamic' cell
 */

cell_entry *
cell_new_dynamic (const char *name)
{
    cell_entry *c;
    FILE *f;

    c = cell_new (name);
    if (c == NULL)
	return NULL;
    c->expl = "dynamically added cell";
    f = fopen (SYSCONFDIR "/" CELLFILENAME, "a");
    if (f == NULL)
	f = fopen (TRANSARCSYSCONFDIR "/" CELLFILENAME, "a");
    if (f == NULL) {
	log_log (cell_log, CDEBWARN,"Cannot open CellServDB for writing");
	return c;
    }
    fprintf (f, ">%s	#dynamically added cell\n", name);
    fclose (f);
    return c;
}

/*
d203 2
a204 2
readdb (char *line, cell_entry* c, int *dbnum, int maxdbs,
	cell_db_entry *dbservs, int lineno)
d207 1
a207 1
     char *hostname, *eh;
d210 2
d214 4
a217 5
     
     while (*line && isspace((unsigned char)*line))
	    ++line;

     if (inet_aton (line, &numaddr) == 0) {
d219 7
a226 25

     while (*line && !isspace((unsigned char)*line) && *line != '#')
	 ++line;

     hostname = line;

     while (isspace ((unsigned char)*hostname) || *hostname == '#')
	 ++hostname;

     eh = hostname;

     while (*eh && !isspace((unsigned char)*eh) && *eh != '#')
	 ++eh;

     *eh = '\0';

     if (*hostname == '\0')
	 hostname = inet_ntoa (numaddr);
     
     dbservs[*dbnum].name = strdup (hostname);
     if (dbservs[*dbnum].name == NULL)
	 err (1, "strdup");
     dbservs[*dbnum].addr = numaddr;
     dbservs[*dbnum].timeout = 0;
     ++(*dbnum);
d239 1
a239 1
     cell_entry *c = NULL;
d242 1
a242 2
     cell_db_entry dbservs[256];
     int i;
d246 2
d253 6
a258 5
	  i = 0;
	  line[strlen(line) - 1] = '\0';
	  while (line[0] && isspace((unsigned char)line[i]))
		 i++;
	  if (line[i] == '#' || line[i] == '\0')
d260 1
a260 1
	  if (line[i] == '>') {
d262 2
a263 4
		    updatehosts (c, dbnum, dbservs);
	       c = newcell (&line[i] + 1);
	       memset (dbservs, 0, sizeof(dbservs));
	       dbnum = 0;
d265 4
a268 4
	      if (readdb(&line[i], c, &dbnum, sizeof (dbservs) /
			 sizeof(*dbservs),
			 dbservs, lineno))
		  continue;
d272 1
a272 1
	  updatehosts (c, dbnum, dbservs);
a277 55
 * Read single line confilefiles in `filename' and send the 
 * to `func'.
 */

static int
parse_simple_file (const char *filename, void (*func)(const char *))
{
    FILE *f;
    char line[256];
    
    f = fopen (filename, "r");
    if (f == NULL)
	return 1;
    
    while ((fgets (line, sizeof(line), f) != NULL)) {
	line[strlen(line) - 1] = '\0';
	(*func) (line);
    }
    fclose (f);
    return 0;
}

/*
 * Add expanded `cellname' to Thesecells list, filter out duplicates
 */

static void
addthesecell (const char *cellname)
{
    int i;
    cellname = cell_expand_cell (cellname);
    for (i = 0; thesecells && thesecells[i]; i++)
	if (strcasecmp (thesecells[i], cellname) == 0)
	    return;
    thesecells = erealloc (thesecells, 
			   (numthesecells + 1) * sizeof (char *));
    thesecells[numthesecells - 1] = estrdup (cellname);
    thesecells[numthesecells] = NULL;
    ++numthesecells;
}

/*
 * Read cells in TheseCells
 */

static int
readthesecells (const char *filename)
{
     parse_simple_file (filename, addthesecell);
     if (numthesecells == 1)
	 return 1;
     return 0;
}

/*
d288 2
a289 1
     if (f == NULL)
d291 1
d294 1
a294 1
	 log_log (cell_log, CDEBERR, "Cannot read cellname from %s\n",
d296 1
a296 1
	 return 1;
a307 49
 * Read suidcells file and set suidcell flag
 */

static void
addsuidcell (const char *cellname)
{
    cell_entry *e;

    e = cell_get_by_name (cellname);
    if (e == NULL) {
	log_log (cell_log, CDEBWARN,
		 "suidcell: cell %s doesn't exist in the db\n", cellname);
    } else {
	e->flags |= SUID_CELL;
    }
}

static int
readsuidcell (const char *filename)
{
    return parse_simple_file (filename, addsuidcell);
}

/*
 *
 */

static void
add_dynroot(const char *cellname)
{
    cell_entry *e; 

    e = cell_get_by_name (cellname);
    if (e == NULL) {
	log_log (cell_log, CDEBWARN,
		 "dynroot: cell %s doesn't exist in the db\n", cellname);
    } else {
	e->flags |= DYNROOT_CELL;
	dynrootdb_in_use = 1;
    }
}

static int
readdynrootdb (const char *filename)
{
    return parse_simple_file (filename, add_dynroot);
}

/*
a310 2
static int cell_inited = 0;

d312 1
a312 1
cell_init (int cellcachesize, Log_method *log)
a314 3
    int ret;

    assert (log);
d316 2
a317 2
    if (cell_inited) {
	log_log (cell_log, CDEBWARN, "cell_init: Already initlized");
a319 9
    cell_inited = 1;

#ifdef HAVE_RES_INIT
    res_init();
#endif

    cell_log = log_unit_init (log, "cell", celldebug_units, CDEBDEFAULT);
    if (cell_log == NULL)
	errx (1, "cell_init: log_unit_init failed");
d333 3
a335 1
	thiscell = estrdup (env);
d337 5
a341 5
	if (readthiscell(TRANSARCSYSCONFDIR "/" THISCELLFILENAME))
	    errx (1, "could not open "
		  SYSCONFDIR "/" THISCELLFILENAME
		  " nor "
		  TRANSARCSYSCONFDIR "/" THISCELLFILENAME);
d345 1
d347 2
a348 3
	    log_log (cell_log, CDEBWARN,
		     "Can't read the CellServDB file, "
		     "will use DNS AFSDB entries");
a350 19
    ret = add_special_dynroot_cell();
    if (ret)
	log_log (cell_log, CDEBWARN, "adding dynroot cell failed with %d", ret);
    
    if (readthesecells (SYSCONFDIR "/" THESECELLFILENAME))
	readthesecells (TRANSARCSYSCONFDIR "/" THESECELLFILENAME);
    if (getenv("HOME") != NULL) {
	char homedir[MAXPATHLEN];
	snprintf (homedir, sizeof(homedir), 
		  "%s/." THESECELLFILENAME,
		  getenv("HOME"));
	readthesecells (homedir);
    }
    addthesecell (thiscell);
    if (readsuidcell (SYSCONFDIR "/" SUIDCELLSFILENAME))
	readsuidcell (TRANSARCSYSCONFDIR "/" SUIDCELLSFILENAME);
    if (readdynrootdb (SYSCONFDIR "/" DYNROOTDBFILENAME))
	readdynrootdb (TRANSARCSYSCONFDIR "/" DYNROOTDBFILENAME);

d354 1
a354 1
 *
d357 2
a358 2
const char **
cell_thesecells (void)
d360 18
a377 1
    return (const char **)thesecells;
d381 1
a381 2
 * Return all db servers for `cell' with the count in `num'.
 * NULL on error.
d384 2
a385 2
const cell_db_entry *
cell_dbservers_by_id (int32_t id, int *num)
d387 18
a404 1
    cell_entry *data = cell_get_by_id (id);
a405 11
    if (data == NULL)
	return NULL;

    if (data->ndbservers == 0)
	dns_lookup_cell (data->name, data);
     if (data->ndbservers == 0 || data->active_hosts == 0)
	 return NULL;

    *num = data->active_hosts;
    return data->dbservers;
}
d408 4
a411 2
 * Return the name of the first database server in `cell' or NULL (if
 * the cell does not exist or it has no db servers).
d417 2
a418 1
     cell_entry *data = cell_get_by_name (cell);
d420 8
a427 1
     if (data == NULL)
d429 3
a431 4
     if (data->ndbservers == 0)
	 dns_lookup_cell (cell, data);
     if (data->ndbservers == 0 || data->active_hosts == 0)
	 return NULL;
d433 56
a488 1
     return data->dbservers[0].name ;
d491 1
d508 4
a511 2
    ptr = strchr (host, '.');
    if (ptr == NULL)
d513 2
a514 1
    return ptr + 1;
d525 1
a525 1
     cell_entry *data = cell_get_by_name (cell);
d527 12
a538 4
     if (data != NULL)
	 return data->id;
     else
	 return -1;
d548 1
a548 1
    cell_entry *data = cell_get_by_id (cell);
d550 3
a552 1
    if (data != NULL)
d565 1
a565 74
    assert (thiscell != NULL);

    return thiscell;
}

/*
 *
 */

int
cell_setthiscell (const char *cell)
{
    cell_entry *data;

    data = cell_get_by_name(cell);
    if (data == NULL) {
	log_log (cell_log, CDEBWARN, "this cell doesn't exist: %s", cell);
	return 1;
    }

    free (thiscell);
    thiscell = strdup (cell);
    if (thiscell == NULL)
	abort();
    
    return 0;
}

/*
 * Return if this should be in dynroot
 */

Bool
cell_dynroot (const cell_entry *c)
{
    assert (c);
    if (!dynrootdb_in_use)
	return TRUE;
    return (c->flags & DYNROOT_CELL) != 0;
}

/*
 * Return if this is a suid cell
 */

Bool
cell_issuid (const cell_entry *c)
{
    assert (c);
    return (c->flags & SUID_CELL) != 0;
}

Bool
cell_issuid_by_num (int32_t cell)
{
    cell_entry *c;

    c = cell_get_by_id (cell);
    if (c == NULL)
	return FALSE;
    
    return cell_issuid (c);
}

Bool
cell_issuid_by_name (const char *cell)
{
    cell_entry *c;

    c = cell_get_by_name (cell);
    if (c == NULL)
	return FALSE;
    
    return cell_issuid (c);
a566 182

Bool
cell_setsuid_by_num (int32_t cell)
{
    cell_entry *c;

    c = cell_get_by_id (cell);
    if (c == NULL)
	return FALSE;
    
    c->flags |= SUID_CELL;

    return 0;
}

/*
 *
 */

void
cell_print_cell (cell_entry *c, FILE *out)
{
    int i;
    char timestr[30];
    struct tm tm;
    time_t t;

    fprintf (out, "name: %s id: %d type: %s\n",
	     c->name, c->id, c->timeout ? "dynamic" : "static");
    fprintf (out, "comment: %s\n", c->expl);
    if (c->timeout) {
	t = c->timeout;
	strftime(timestr, sizeof(timestr),
		 "%Y-%m-%d %H:%M:%S", localtime_r(&t, &tm));
	fprintf (out, "timeout: %s\n", timestr);
    }
    fprintf (out, "num hosts: %d active hosts: %d\n",
	     c->ndbservers, c->active_hosts);
    for (i = 0; i < c->ndbservers; i++) {
	char *buf;
	if (c->dbservers[i].timeout == CELL_INVALID_HOST)
	    buf = "invalid";
	else if (c->dbservers[i].timeout == 0)
	    buf = "no timeout";
	else {
	    t = c->timeout;
	    strftime(timestr, sizeof(timestr),
		     "%Y-%m-%d %H:%M:%S", localtime_r(&t, &tm));
	    buf = timestr;
	}
	fprintf (out, " host: %s %s - %s\n", c->dbservers[i].name,
		 inet_ntoa (c->dbservers[i].addr), buf);
    }
}

/*
 * Iterate over all entries in the cell-db with `func'
 * (that takes the cellname and `arg' as arguments)
 */

struct cell_iterate_arg {
    void *arg;
    int ret;
    int (*func) (const cell_entry *, void *);
};

static int
cell_iterate_func (void *ptr, void *arg)
{
    struct cell_iterate_arg *cia = (struct cell_iterate_arg *) arg;
    cell_entry *cell = (cell_entry *) ptr;
    int ret;

    ret = (cia->func) (cell, cia->arg);
    if (ret)
	cia->ret = ret;
    return ret;
}

int
cell_foreach (int (*func) (const cell_entry *, void *), void *arg)
{
    struct cell_iterate_arg cia;

    cia.arg = arg;
    cia.ret = 0;
    cia.func = func;

    hashtabforeach (cellnamehtab, cell_iterate_func, &cia);

    return cia.ret;
}

/*
 *
 */

struct cell_expand_arg {
    const char *cell;
    const char *fullcell;
    int32_t last_found;
};

static int
cell_expand_cell_name (const cell_entry *cell, void *data)
{
    struct cell_expand_arg *cea = (struct cell_expand_arg *) data;
    if (strcasecmp (cell->name, cea->cell) == 0) {
	cea->fullcell = cell->name;
	return 1;
    }
    if (strstr (cell->name, cea->cell) && cea->last_found > cell->id) {
	cea->last_found = cell->id;
	cea->fullcell = cell->name;
    }
    return 0;
}

const char *
cell_expand_cell (const char *cell)
{
    struct cell_expand_arg cea;
    cea.cell = cell;
    cea.fullcell = NULL;
    cea.last_found = cellno + 1;

    cell_foreach (cell_expand_cell_name, &cea);
    if (cea.fullcell)
	return cea.fullcell;
    return cell;
}

/*
 *
 */

unsigned long
cell_get_version(void)
{
    return celldb_version;
}

/*
 *
 */

static int
add_special_dynroot_cell (void)
{
    cell_entry * c;

    c = cell_get_by_id (0);
    if (c != NULL)
	abort();

    c = (cell_entry *)malloc (sizeof (*c));
    if (c == NULL)
	return errno;
    c->name = strdup ("#dynrootcell#");
    if (c->name == NULL) {
	free (c);
	return errno;
    }
    c->id         = 0; /* XXX */
    c->expl       = "The special dynroot cell";
    c->ndbservers = 0;
    c->dbservers  = NULL;
    c->flags	  = 0;
    hashtabadd (cellnamehtab, c);
    hashtabadd (cellnumhtab, c);
    return 0;
}

/*
 * Return TRUE if ``cell'' has a sane cellnumber.
 */

Bool
cell_is_sanep (int cell)
{
    return cell < cellno;
} 
@


1.1.1.3
log
@Import of arla -current as of Aug 5 2003

ok todd@@ deraadt@@
@
text
@d2 1
a2 1
 * Copyright (c) 1995 - 2002 Kungliga Tekniska Högskolan
d40 8
a47 1
#ifdef HAVE_KRB4
d51 3
a53 1
RCSID("$arla: kocell.c,v 1.75 2003/06/10 16:52:06 lha Exp $");
a60 1
#define ALIASDBFILENAME "AliasDB"
d78 2
a112 13
 * Cell alias
 */

struct cellalias {
    char *name;
    char *alias;
    int type;
    Listitem *li;
};

static List *cellaliaslist;

/*
d178 1
a178 1
 * Verify that that host is valid (dns wise)
d184 2
a186 1
    int ret;
d190 2
a191 2
    ret = _ko_resolve_host(host->name, host);
    if (ret) {
d198 10
a207 2

    host->timeout += tv.tv_sec;
d247 6
a252 11
    if (c->dbservers != dbservers) {
	c->ndbservers = dbnum;
	c->dbservers  = malloc (dbnum * sizeof(cell_db_entry));
	if (c->dbservers == NULL && dbnum != 0)
	    err (1, "malloc %lu", 
		 (unsigned long)dbnum * sizeof(cell_db_entry));
	memcpy (c->dbservers, dbservers, dbnum * sizeof (cell_db_entry));
	free (old_servers);
    } else {
	assert(c->ndbservers == dbnum);
    }
d273 3
a275 1
    int i, ret, dbnum = 0;
d277 2
a278 1
    int lowest_ttl = INT_MAX;
d284 2
a285 4
    ret = _ko_resolve_cell(cell, dbservers, 
			   sizeof(dbservers)/sizeof(dbservers[0]),
			   &dbnum, &lowest_ttl);
    if (ret) {
d288 1
a288 1
	return ret;
d290 2
d293 31
a323 3
    for (i = 0; i < dbnum; i++)
	if (dbservers[i].timeout != CELL_INVALID_HOST)
	    dbservers[i].timeout += tv.tv_sec;
d325 1
a325 5
    if (lowest_ttl == INT_MAX)
	lowest_ttl = 5 * 60;

    if (c == NULL)
	c = cell_new_dynamic (cell);
a326 1
    /* catch the hosts that didn't fit in additional rr */
a342 3
    if (c->id == DYNROOT_CELLID)
	return;

d410 1
a411 1
    assert(c->id != DYNROOT_CELLID);
a419 1
    c->poller_timeout = 0;
d432 1
d438 9
d522 1
a522 1
	  line[strcspn(line, "\n")] = '\0';
d552 1
a552 1
parse_simple_file (const char *filename, void (*func)(char *))
d562 1
a562 1
	line[strcspn(line, "\n")] = '\0';
d574 1
a574 1
addthesecell (char *cellname)
a575 2
    const char *cell;
    char **ntc;
d577 1
a577 2

    cell = cell_expand_cell (cellname);
d579 1
a579 1
	if (strcasecmp (thesecells[i], cell) == 0)
d581 3
a583 9

    ntc = realloc (thesecells, (numthesecells + 1) * sizeof (char *));
    if (ntc == NULL)
	errx(1, "realloc");
    thesecells = ntc;

    thesecells[numthesecells - 1] = strdup (cell);
    if (thesecells[numthesecells - 1] == NULL)
	errx(1, "strdup");
d616 1
a616 1
	 log_log (cell_log, CDEBERR, "Cannot read cellname from %s",
d620 2
a621 1
     cell[strcspn(cell, "\n")] = '\0';
d634 1
a634 1
addsuidcell (char *cellname)
d641 1
a641 1
		 "suidcell: cell %s doesn't exist in the db", cellname);
d658 1
a658 1
add_dynroot(char *cellname)
d665 1
a665 1
		 "dynroot: cell %s doesn't exist in the db", cellname);
a677 52
static void
add_alias(char *alias_line)
{
    const char *delim = " \t";
    char *cellname, *aliasname, *type, *al;
    size_t sz;

    al = alias_line;

#define ENDSTR(str)	((str) == NULL || *(str) == '\0' || *(str) == '#')

    sz = strspn(alias_line, delim);
    al = al + sz;
    if (ENDSTR(al))
	return;
    cellname = strsep(&al, delim);
    if (ENDSTR(cellname) || al == NULL)
	goto out;
    sz = strspn(al, delim);
    al = al + sz;
    if (ENDSTR(al))
	goto out;
    aliasname = strsep(&al, delim);
    if (ENDSTR(aliasname))
	goto out;

    type = "readonly";
    if (al != NULL) {
	sz = strspn(al, delim);
	al = al + sz;
	if (!ENDSTR(al)) {
	    al = strsep(&al, delim);
	    if (!ENDSTR(al))
		type = al;
	}
    }

#undef ENDSTR
    cell_addalias(cellname, aliasname, type);
    return;

 out:
    log_log (cell_log, CDEBWARN,
	     "alias: failed to parse line `%s'", alias_line);
}

static int
readaliasdb (const char *filename)
{
    return parse_simple_file (filename, add_alias);
}

d685 1
a685 1
cell_init (int cellcachesize, Log_method *logm)
d687 1
a687 2
    char *env = NULL;
    uid_t uid,euid;
d690 1
a690 1
    assert (logm);
d698 3
a700 1
    _ko_resolve_init();
d702 1
a702 1
    cell_log = log_unit_init (logm, "cell", celldebug_units, CDEBDEFAULT);
d716 1
a716 6
    uid = getuid();
    euid = geteuid();

    if(uid == euid)
	env = getenv ("AFSCELL");

d718 1
a718 3
	thiscell = strdup (env);
	if (thiscell == NULL)
	    errx(1, "strdup");
d727 1
a727 12
    env = NULL;

    if(uid == euid) 
	env = getenv("CELLSERVDBFILE");

    if(env != NULL) {
	if(readcellservdb (env)) {
	    log_log (cell_log, CDEBWARN,
		     "Can't read the CellServDB file, "
		     "will use DNS AFSDB entries");
	}
    } else if (readcellservdb (SYSCONFDIR "/" CELLFILENAME)) {
a752 3
    cellaliaslist = listnew();
    if (readaliasdb (SYSCONFDIR "/" ALIASDBFILENAME))
	readaliasdb (TRANSARCSYSCONFDIR "/" ALIASDBFILENAME);
d817 1
a817 1
#ifdef HAVE_KRB4
d867 2
a868 2
    if (thiscell == NULL)
	return "unknown-cell-missing-configuration";
d962 1
a962 1
cell_print_cell (const cell_entry *c, FILE *out)
d965 1
a965 1
    char timestr[128];
d974 3
a976 3
	if (strftime(timestr, sizeof(timestr),
		     "%Y-%m-%d %H:%M:%S", localtime_r(&t, &tm)) > 0)
	    fprintf (out, "timeout: %s\n", timestr);
d988 3
a990 5
	    if (strftime(timestr, sizeof(timestr),
			 "%Y-%m-%d %H:%M:%S", localtime_r(&t, &tm)) > 0)
		buf = timestr;
	    else
		buf = "time-error";
a996 19
static int
cell_info_print (const cell_entry *e, void *ptr)
{
    FILE *f = (FILE *)ptr;
    cell_print_cell(e, f);
    return 0;
}

/*
 * Print all cell info on `f'
 */

void
cell_status (FILE *f)
{
    cell_foreach(cell_info_print, f);
}


a1014 3
    if (cell->id == DYNROOT_CELLID)
	return 0;

d1105 1
a1105 1
    c->id         = DYNROOT_CELLID;
a1123 118

/*
 * Get the poller delta time for `cell'. Default is zero, that means
 * that the caller should use the default poller timeout.
 */

time_t
cell_get_poller_time(const cell_entry *cell)
{
    return cell->poller_timeout;
}

/*
 * Set the poller delta `time' for `cell'.
 */

void
cell_set_poller_time(cell_entry *cell, time_t time)
{
    cell->poller_timeout = time;
}

/*
 *
 */

static int
find_alias (const char *cellname, const char *alias, int type, void *arg)
{
    const char *newcell = arg;
    if (strcmp(alias, newcell) == 0)
	return EEXIST;
    return 0;
}

int
cell_addalias(const char *cellname, const char *alias, const char *stype)
{
    struct cellalias *ca;
    int type;
    int ret;

    if (strcasecmp("readonly", stype) == 0 ||
        strcasecmp("ro", stype) == 0)
	type = DYNROOT_ALIAS_READONLY;
    else if (strcasecmp("readwrite", stype) == 0 ||
	     strcasecmp("rw", stype) == 0)
	type = DYNROOT_ALIAS_READWRITE;
    else
	return EINVAL;

    ret = cell_alias_foreach(find_alias, (void *)alias);
    if (ret)
	return ret;

    ca = malloc(sizeof(*ca));
    if (ca == NULL)
	return ENOMEM;
    memset(ca, 0, sizeof(*ca));
    
    ca->type = type;
    ca->name = strdup(cellname);
    if (ca->name == NULL)
	goto out;
    ca->alias = strdup(alias);
    if (ca->alias == NULL)
	goto out;
    ca->li = listaddtail(cellaliaslist, ca);
    if (ca->li == NULL)
	goto out;

    celldb_version++;

    return 0;
 out:
    if (ca->name)
	free(ca->name);
    if (ca->alias)
	free(ca->alias);
    free(ca);
    return ENOMEM;
}


/*
 *
 */

struct listalias_ctx {
    cell_alias_fn func;
    void *ptr;
    int error;
};

static Bool
listalias_f(List *list, Listitem *li, void *arg)
{
    struct cellalias *ca = listdata(li);
    struct listalias_ctx *ctx = arg;
    
    ctx->error = (*ctx->func)(ca->name, ca->alias, ca->type, ctx->ptr);
    if (ctx->error)
	return TRUE;
    return FALSE;
}

int
cell_alias_foreach (cell_alias_fn func, void *ptr)
{
    struct listalias_ctx c;
    c.func = func;
    c.ptr = ptr;
    c.error = 0;

    listiter(cellaliaslist, listalias_f, &c);

    return c.error;
}
@


