head	1.4;
access;
symbols
	OPENBSD_5_2:1.3.0.38
	OPENBSD_5_2_BASE:1.3
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.36
	OPENBSD_5_0:1.3.0.34
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.32
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.3.0.30
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.3.0.26
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.28
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.3.0.24
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.3.0.22
	OPENBSD_4_4_BASE:1.3
	OPENBSD_4_3:1.3.0.20
	OPENBSD_4_3_BASE:1.3
	OPENBSD_4_2:1.3.0.18
	OPENBSD_4_2_BASE:1.3
	OPENBSD_4_1:1.3.0.16
	OPENBSD_4_1_BASE:1.3
	OPENBSD_4_0:1.3.0.14
	OPENBSD_4_0_BASE:1.3
	OPENBSD_3_9:1.3.0.12
	OPENBSD_3_9_BASE:1.3
	OPENBSD_3_8:1.3.0.10
	OPENBSD_3_8_BASE:1.3
	OPENBSD_3_7:1.3.0.8
	OPENBSD_3_7_BASE:1.3
	OPENBSD_3_6:1.3.0.6
	OPENBSD_3_6_BASE:1.3
	OPENBSD_3_5:1.3.0.4
	OPENBSD_3_5_BASE:1.3
	OPENBSD_3_4:1.3.0.2
	OPENBSD_3_4_BASE:1.3
	arla-20030805:1.1.1.2
	OPENBSD_3_3:1.2.0.4
	OPENBSD_3_3_BASE:1.2
	OPENBSD_3_2:1.2.0.2
	OPENBSD_3_2_BASE:1.2
	arla-0-35-7:1.1.1.1
	arla:1.1.1
	OPENBSD_3_1:1.1.0.8
	OPENBSD_3_1_BASE:1.1
	OPENBSD_3_0:1.1.0.6
	OPENBSD_3_0_BASE:1.1
	OPENBSD_2_9_BASE:1.1
	OPENBSD_2_9:1.1.0.4
	OPENBSD_2_8:1.1.0.2
	OPENBSD_2_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.4
date	2012.08.23.06.21.53;	author deraadt;	state dead;
branches;
next	1.3;

1.3
date	2003.08.05.09.16.15;	author hin;	state Exp;
branches;
next	1.2;

1.2
date	2002.06.07.04.42.38;	author hin;	state Exp;
branches;
next	1.1;

1.1
date	2000.09.11.14.41.19;	author art;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.06.07.04.14.33;	author hin;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.08.05.08.21.06;	author hin;	state Exp;
branches;
next	;


desc
@@


1.4
log
@the afs src tree can go away
@
text
@/*
 * Copyright (c) 1998, 1999, 2000 Kungliga Tekniska Högskolan
 * (Royal Institute of Technology, Stockholm, Sweden).
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

#include <sys/types.h>
#include <rx/rx.h>
#include <rx/rx_null.h>

#include <ports.h>
#include <ko.h>
#include <netinit.h>
#include <msecurity.h>

#ifdef KERBEROS
#ifdef HAVE_OPENSSL
#include <openssl/des.h>
#else
#include <des.h>
#endif
#include <krb.h>
#include <rxkad.h>
#endif

#include <err.h>
#include <assert.h>
#include <ctype.h>
#include <agetarg.h>

#ifndef HAVE_UNISTD_H
#include <unistd.h>
#endif

#include <service.h>

#include <mlog.h>
#include <mdebug.h>
#include <mdb.h>

#include "pts.h"
#include "pts.ss.h"
#include "ptserver.h"
#include "pts.ss.h"

RCSID("$arla: ptserver.c,v 1.46 2003/04/09 02:41:28 lha Exp $");

static struct rx_service *prservice;

prheader_disk pr_header;

#define HEADERID PR_BADID
#define ILLEGAL_ID 0x40000000
#define ILLEGAL_GROUP 0x40000000

#define PRENTRY_DISK_SIZE (sizeof(prentry_disk) + PR_MAXGROUPS * sizeof(int32_t) + 16)
#define PRHEADER_DISK_SIZE (sizeof(prheader_disk) + 4 * PR_MAXGROUPS * sizeof(int32_t) + 16)

static void open_db (char *databaseprefix, int flags);
void prserver_close(void);

MDB *nametoid, *idtodata;


/*
 *
 */

void
write_header(void)
{
    int length = PRHEADER_DISK_SIZE;
    struct mdb_datum key, value;
    char pr_header_ydr[PRHEADER_DISK_SIZE];
    int code;

    char headerid = htonl(HEADERID);

    if (ydr_encode_prheader_disk(&pr_header, pr_header_ydr, &length) == NULL)
        err(1, "write_header");

    key.data = &headerid;
    key.length = sizeof(headerid);

    value.data = pr_header_ydr;
    value.length = PRHEADER_DISK_SIZE - length;

    code = mdb_store(idtodata, &key, &value);
    assert(code == 0);
}

/*
 *
 */

void
read_header(void)
{
    int length = PRHEADER_DISK_SIZE;
    struct mdb_datum key, value;
    char headerid = htonl(HEADERID);
    int code;

    key.data = &headerid;
    key.length = sizeof(headerid);

    code = mdb_fetch(idtodata, &key, &value);
    assert(code == 0);
    
    if (ydr_decode_prheader_disk(&pr_header, value.data, &length) == NULL)
        err(1, "read_header");
}

/*
 *
 */

char *
localize_name(const char *name, Bool *localp)
{
    static prname localname;
    char *tmp;

    *localp = FALSE;

    strlcpy(localname, name, sizeof(localname));
    strlwr(localname);
    
    tmp = strchr(localname, '@@');
    if (tmp)
	if (!strcasecmp(tmp + 1, netinit_getrealm())) {
	    *tmp = '\0';
	    *localp = TRUE;
	}

    return localname;
}

/*
 *
 */

static void
create_database(void)
{
    pr_header.version = 0;
    pr_header.headerSize = PRHEADER_DISK_SIZE;
    pr_header.maxGroup = -210; /* XXX */
    pr_header.maxID = 0;
/*XXX    pr_header.orphan = 0;*/
    pr_header.usercount = 0;
    pr_header.groupcount = 0;
    write_header();
}

/*
 * read_prentry(): Fetch data from db, return a classic pr_entry
 */

int
read_prentry(int id, prentry *pr_entry)
{
    prentry_disk disk_entry;
    int status, i;

    status = get_disk_entry(id, &disk_entry);
    if (status)
	return status;

    memset(pr_entry, 0, sizeof(prentry));

    pr_entry->flags = disk_entry.flags;
    pr_entry->id = disk_entry.id;
    pr_entry->cellid = disk_entry.cellid;
    pr_entry->owner = disk_entry.owner;
    pr_entry->creator = disk_entry.creator;
    pr_entry->ngroups = disk_entry.ngroups;
    strlcpy(pr_entry->name, disk_entry.name, sizeof(pr_entry->name));

    if (disk_entry.owned.len > 0)
	pr_entry->owned = disk_entry.owned.val[0];
      
    for (i = 0; i < PRSIZE && i < disk_entry.entries.len; i++)
	pr_entry->entries[i] = disk_entry.entries.val[i];

    mlog_log (MDEBPRDB, "read_prentry id: %d owner: %d creator: %d name: %s",
	      pr_entry->id, pr_entry->owner, 
	      pr_entry->creator, pr_entry->name);

    return 0;
}

/* 
 * store_disk_entry(): marshal prentry_disk and store in db
 */

int
store_disk_entry(prentry_disk *entry)
{
    char pr_entry_disk_ydr[PRENTRY_DISK_SIZE];
    int length = PRENTRY_DISK_SIZE;
    struct mdb_datum key, value;
    int id;

    mlog_log (MDEBPRDB, "store_disk_entry id: %d owner: %d creator: %d name: %s",
	      entry->id, entry->owner, 
	      entry->creator, entry->name);

    if (ydr_encode_prentry_disk((prentry_disk *) entry, pr_entry_disk_ydr, &length) == NULL)
	err(1, "store_disk_entry");

    id = htonl(entry->id);
    key.data = &id;
    key.length = sizeof(id);

    value.data = pr_entry_disk_ydr;
    value.length = PRENTRY_DISK_SIZE - length;

    return mdb_store(idtodata, &key, &value);
}

/*
 * write_prentry(): update db with classic prentry
 */

int
write_prentry(prentry *pr_entry)
{
    prentry_disk disk_entry;
    int i;

    memset(&disk_entry, 0, sizeof(prentry_disk));
    
    disk_entry.flags = pr_entry->flags;
    disk_entry.id = pr_entry->id;
    disk_entry.cellid = pr_entry->cellid;
    disk_entry.owner = pr_entry->owner;
    disk_entry.creator = pr_entry->creator;
    disk_entry.ngroups = pr_entry->ngroups;
/*    disk_entry.owned = pr_entry->owned;   XXX */
    strlcpy(disk_entry.name, pr_entry->name, sizeof(disk_entry.name));
      
    for (i = 0; i < PRSIZE && i < pr_entry->count; i++)
	disk_entry.entries.val[i] = pr_entry->entries[i];
    
    disk_entry.entries.len = i;

    return store_disk_entry(&disk_entry);
}

/*
 *
 */

static int
write_name(prentry *pr_entry)
{
    struct mdb_datum key, value;
    int32_t id = htonl(pr_entry->id);

    key.data = pr_entry->name;
    key.length = strlen(pr_entry->name);

    value.data = &id;
    value.length = sizeof(id);

    return mdb_store(nametoid, &key, &value);
}

/*
 *
 */

static int
insert_entry(prentry *pr_entry)
{
    char *pr_entry_disk_ydr;
    int status;
    int id;

    char *name = pr_entry->name;

    status = get_ydr_disk_entry(pr_entry->id, &pr_entry_disk_ydr);
    if (status == 0)
	return PREXIST;
    if (status != PRNOENT)
	return status;

    status = conv_name_to_id(name, &id);
    if (status == 0)
	return PREXIST;
    if (status != PRNOENT)
	return status;

    status = write_name(pr_entry);
    if (status)
	return status;

    return write_prentry(pr_entry);

    /* XXX: update owned and nextOwned */
    /* XXX update header */
    /* write_header(); */
}

/*
 *
 */

int
create_group(const char *name,
	     int32_t id,
	     int32_t owner,
	     int32_t creator)
{
    int status;
    prentry pr_entry;
    
    memset(&pr_entry, 0, sizeof(pr_entry));
    pr_entry.flags = PRGRP;
    pr_entry.id = id;
    pr_entry.owner = owner;
    pr_entry.creator = creator;
    strlcpy(pr_entry.name, name, PR_MAXNAMELEN);

    status = insert_entry(&pr_entry);
    if (status)
	return status;

    return 0;
}

/*
 *
 */

int
create_user(const char *name,
	    int32_t id,
	    int32_t owner,
	    int32_t creator)
{
    int status;
    prentry pr_entry;
    
    memset(&pr_entry, 0, sizeof(pr_entry));
    pr_entry.flags = 0;
    pr_entry.id = id;
    pr_entry.owner = owner;
    pr_entry.creator = creator;
    strlcpy(pr_entry.name, name, PR_MAXNAMELEN);

    status = insert_entry(&pr_entry);
    if (status)
	return status;

    return 0;
}

/*
 *
 */

int
addtogroup (int32_t uid, int32_t gid)
{
    prentry_disk uid_entry;
    prentry_disk gid_entry;
    int error, i, tmp1, tmp2;

    mlog_log (MDEBPRDB, "addtogroup");

    error = get_disk_entry(uid, &uid_entry);
    if (error)
	return error;

    error = get_disk_entry(gid, &gid_entry);
    if (error)
	return error;

    if (uid_entry.entries.len >= (PR_MAXGROUPS - 1)
	|| gid_entry.entries.len >= (PR_MAXLIST - 1))
	return PRNOENT;

    i = 0;
    while (uid_entry.entries.val[i] < gid && i < uid_entry.entries.len)
	i++;

    tmp1 = gid;
    for (; i < uid_entry.entries.len; i++) {
	tmp2 = uid_entry.entries.val[i];
	uid_entry.entries.val[i] = tmp1;
	tmp1 = tmp2;
    }
    uid_entry.entries.val[uid_entry.entries.len] = tmp1;
    uid_entry.entries.len++;

    i = 0;
    while (gid_entry.entries.val[i] < uid && i < gid_entry.entries.len)
	i++;

    tmp1 = uid;
    for (; i < gid_entry.entries.len; i++) {
	tmp2 = gid_entry.entries.val[i];
	gid_entry.entries.val[i] = tmp1;
	tmp1 = tmp2;
    }
    gid_entry.entries.val[gid_entry.entries.len] = tmp1;
    gid_entry.entries.len++;

    if ((error = store_disk_entry(&uid_entry)) != 0)
	return error;

    if ((error = store_disk_entry(&gid_entry)) != 0)
	return error;

    return 0;
}

/*
 *
 */

int
removefromgroup (int32_t uid, int32_t gid)
{
    prentry_disk uid_entry;
    prentry_disk gid_entry;
    int error, i;

    mlog_log (MDEBPRDB, "removefromgroup");

    error = get_disk_entry(uid, &uid_entry);
    if (error)
	return error;

    error = get_disk_entry(gid, &gid_entry);
    if (error)
	return error;


    i = 0;
    while (uid_entry.entries.val[i] < gid && i < uid_entry.entries.len)
	i++;

    if (uid_entry.entries.val[i] != gid)
	return PRNOENT;

    for (i++; i < uid_entry.entries.len; i++)
	uid_entry.entries.val[i - 1]  = uid_entry.entries.val[i];

    uid_entry.entries.len--;

    i = 0;
    while (gid_entry.entries.val[i] < uid && i < gid_entry.entries.len)
	i++;

    if (gid_entry.entries.val[i] != uid)
	return PRNOENT;

    for (i++; i < gid_entry.entries.len; i++)
	gid_entry.entries.val[i - 1]  = gid_entry.entries.val[i];

    gid_entry.entries.len--;

    /* XXX may leave database inconsistent ?? */

    if ((error = store_disk_entry(&uid_entry)) != 0)
	return error;
    
    if ((error = store_disk_entry(&gid_entry)) != 0)
	return error;

    return 0;

}

/*
 *
 */

int
listelements (int32_t id, prlist *elist, Bool default_id_p)
{
    prentry_disk disk_entry;
    int i = 0, error;

    error = get_disk_entry(id, &disk_entry);
    if (error)
        return error;
    
    if (default_id_p)
	elist->len = disk_entry.entries.len + 3;
    else
	elist->len = disk_entry.entries.len;

    elist->val = malloc(sizeof(*elist->val) * elist->len);
    if (elist->val == NULL)
	return ENOMEM; /* XXX */
    

    /* XXX should be sorted */

    for (i = 0; i < disk_entry.entries.len; i++)
	    elist->val[i] = disk_entry.entries.val[i];

    if (default_id_p) {
	elist->val[i] = id;
	elist->val[++i] = PR_ANYUSERID;
	elist->val[++i] = PR_AUTHUSERID;
    }

    return 0;
}

/*
 *
 */

int
get_ydr_disk_entry(int id, char **buf)
{
    struct mdb_datum key, value;
    int status;
    
    id = htonl(id);

    key.data = &id;
    key.length = sizeof(id);

    status = mdb_fetch(idtodata, &key, &value);
    if (status == ENOENT)
	return PRNOENT;

    *buf = value.data;

    return status;
}

/*
 *
 */

int
get_disk_entry(int id, prentry_disk *entry)
{
    char *pr_entry_disk_ydr;
    int length = PRENTRY_DISK_SIZE; /* XXX maxsize in mdb??? */
    int status;

    status = get_ydr_disk_entry(id, &pr_entry_disk_ydr);
    if (status)
	return status;

    if (ydr_decode_prentry_disk(entry, pr_entry_disk_ydr, &length) == NULL)
	err(1, "get_disk_entry");

    return status;
}

/*
 *
 */

int
conv_name_to_id(const char *name, int *id)
{
    struct mdb_datum key, value;
    int status;

    key.data = strdup(name); /*XXX*/
    key.length = strlen(name);

    status = mdb_fetch(nametoid, &key, &value);
    if (status == ENOENT)
	status = PRNOENT;
    else
	*id = ntohl(*((int *)value.data));
    
    free(key.data);

    return status;
}

/*
 *
 */

int
conv_id_to_name(int id, char *name)
{
    prentry pr_entry;
    int status;

    status = read_prentry(id, &pr_entry);
    if (status)
	return status;
    strlcpy(name, pr_entry.name, PR_MAXNAMELEN);
    return 0;
}

/*
 *
 */

int
next_free_group_id(int *id)
{
    pr_header.maxGroup--; /* XXX */
    if (pr_header.maxGroup == ILLEGAL_GROUP) {
	pr_header.maxGroup++;
	return -1;
    }

    write_header();

    *id = pr_header.maxGroup;
    return 0;
}

/*
 *
 */

int
next_free_user_id(int *id)
{
    pr_header.maxID++; /* XXX */
    if (pr_header.maxID == ILLEGAL_ID) {
	pr_header.maxID--;
	return -1;
    }

    write_header();

    *id = pr_header.maxID;
    return 0;
}

/*
 *
 */

static void
open_db (char *databaseprefix, int flags)
{
    char database[MAXPATHLEN];

    if (databaseprefix == NULL)
	databaseprefix = MILKO_SYSCONFDIR;

    snprintf (database, sizeof(database), "%s/pr_idtodata", 
	      databaseprefix);

    mlog_log (MDEBPR, "Loading db from file %s\n", database);

    idtodata = mdb_open(database, flags, 0600);
    if (idtodata == NULL)
        err(1, "failed open (%s)", database);


    snprintf (database, sizeof(database), "%s/pr_nametoid", 
	      databaseprefix);

    mlog_log (MDEBPR, "Loading db from file %s\n", database);

    nametoid = mdb_open(database, flags, 0600);
    if (nametoid == NULL)
        err(1, "failed open (%s)", database);
}

void
prserver_close(void)
{
    mdb_close(idtodata);
    mdb_close(nametoid);
}

#ifndef O_BINARY
#define O_BINARY 0
#endif

/*
 *
 */

static int
prserver_create (char *databaseprefix)
{
    int status;

    open_db (databaseprefix, O_RDWR|O_CREAT|O_EXCL|O_BINARY);

    printf ("Creating a new pr-database.\n");
    create_database();

#define M(N,I,O,G) \
    do { \
	status = create_group((N), (I), (O), (G)); \
	if (status)  \
            errx (1, "failed when creating %s with error %d", \
	          (N), status); \
    } while (0)

    M("system:administrators", PR_SYSADMINID, PR_SYSADMINID, PR_SYSADMINID);
    M("system:anyuser", PR_ANYUSERID, PR_SYSADMINID, PR_SYSADMINID);
    M("system:authuser", PR_AUTHUSERID, PR_SYSADMINID, PR_SYSADMINID);
    M("anonymous", PR_ANONYMOUSID, PR_SYSADMINID, PR_SYSADMINID);

#undef M

    prserver_close();

    return 0;
}

/*
 *
 */

static int
prserver_init(char *databaseprefix)
{
    open_db(databaseprefix, O_RDWR|O_BINARY);
    read_header();

    return 0;
}

/*
 *
 */

static char *cell = NULL;
static char *realm = NULL;
static char *srvtab_file = NULL;
static char *log_file = "syslog";
static char *debug_levels = NULL;
static int no_auth = 0;
static int do_help = 0;
static char *databasedir = NULL;
static int do_create = 0;

static struct agetargs args[] = {
    {"cell",	0, aarg_string,    &cell, "what cell to use"},
    {"realm",	0, aarg_string,	  &realm, "what realm to use"},
    {"debug",  'd', aarg_string,  &debug_levels, "debug level"},
    {"log",	'l',	aarg_string,	&log_file,
     "where to write log (stderr, syslog (default), or path to file)"},
    {"srvtab", 0, aarg_string,    &srvtab_file, "what srvtab to use"},
    {"noauth", 0,  aarg_flag,	  &no_auth, "disable authentication checks"},
    {"help",  'h', aarg_flag,      &do_help, "help"},
    {"dbdir",  0, aarg_string,    &databasedir, "where to store the db"},
    {"create",  0, aarg_flag,      &do_create, "create new database"},
    { NULL, 0, aarg_end, NULL }
};

/*
 *
 */

static void
usage(int exit_code)
{
    aarg_printusage (args, NULL, "", AARG_GNUSTYLE);
    exit (exit_code);
}

/*
 *
 */

int
main(int argc, char **argv) 
{
    int optind = 0;
    int ret;
    Log_method *method;

    set_progname (argv[0]);

    if (agetarg (args, argc, argv, &optind, AARG_GNUSTYLE)) {
	usage (1);
    }

    argc -= optind;
    argv += optind;

    if (argc) {
	printf("unknown option %s", *argv);
	return 1;
    }

    if (do_help)
	usage(0);

    if (no_auth)
	sec_disable_superuser_check ();

    method = log_open (getprogname(), log_file);
    if (method == NULL)
	errx (1, "log_open failed");
    cell_init(0, method);
    ports_init();

    printf ("ptserver booting");

    mlog_loginit (method, milko_deb_units, MDEFAULT_LOG);

    if (debug_levels)
	mlog_log_set_level (debug_levels);

    if (cell)
	cell_setthiscell (cell);

    network_kerberos_init (srvtab_file);
    
    if (do_create) {
	prserver_create (databasedir);
	return 0;
    }

    ret = prserver_init(databasedir);
    if (ret)
	errx (1, "prserver_init: error %d", ret);

    ret = network_init(htons(afsprport), "pr", PR_SERVICE_ID, 
		       PR_ExecuteRequest, &prservice, realm);
    if (ret)
	errx (1, "network_init returned %d", ret);

    mlog_log (MDEBWARN, "started");

    rx_SetMaxProcs(prservice,5) ;
    rx_StartServer(1) ;

    abort();
    return 0;
}
@


1.3
log
@Merge
@
text
@@


1.2
log
@merge
@
text
@d48 3
d52 1
d68 4
d77 1
a77 1
RCSID("$KTH: ptserver.c,v 1.36 2000/12/29 19:55:21 tol Exp $");
d81 5
a85 20
static int pr_database = -1;
static off_t file_length;
prheader pr_header;

static Log_unit *pr_log_unit;
static Log_method *pr_method;

char pr_header_ydr[PRHEADER_SIZE];

#define all (PRDB_ERROR|PRDB_WARN|PRDB_RPC|PRDB_DB)

struct units pr_deb_units[] = {
    { "all",		all },
    { "errors",		PRDB_ERROR },
#undef all
    { "warnings",	PRDB_WARN },
    { "rpc",		PRDB_RPC },
    { "db",		PRDB_DB },
    { NULL}
};
d87 2
a88 5
void
pt_setdebug (char *debug_level)
{
    log_set_mask_str (pr_method, pr_log_unit, debug_level);
}
d90 2
a91 3
/*
 *
 */
d93 1
a93 4
void
pt_debug (unsigned int level, char *fmt, ...)
{
    va_list args;
a94 4
    va_start (args, fmt);
    log_vlog (pr_log_unit, level, fmt, args);
    va_end(args);
}
d100 1
a100 1
static void
d103 9
a111 2
    off_t pos;
    int length = PRHEADER_SIZE;
d113 2
a114 2
    if (ydr_encode_prheader(&pr_header, pr_header_ydr, &length) == NULL)
	err(1, "write_header");
d116 2
a117 2
    pos = lseek(pr_database, 0, SEEK_SET);
    assert(pos == 0);
d119 2
a120 2
    length = write(pr_database, pr_header_ydr, PRHEADER_SIZE);
    assert (length == PRHEADER_SIZE);
d127 1
a127 1
static void
d130 4
a133 2
    char pr_header_ydr[PRHEADER_SIZE];
    int length = PRHEADER_SIZE;
d135 2
a136 2
    if (lseek(pr_database, 0, SEEK_SET) == -1)
	err(1, "lseek");
d138 2
a139 5
    length = read(pr_database, pr_header_ydr, PRHEADER_SIZE);
    if (length == -1)
	err(1, "read");
    if (length != PRHEADER_SIZE)
	errx(1, "read_header read failed");
d141 2
a142 15
    if (ydr_decode_prheader(&pr_header, pr_header_ydr, &length) == NULL)
	err(1, "read_header");
}

/*
 *
 */

static void
get_file_length(void)
{
    file_length = lseek(pr_database, 0, SEEK_END);
    if (file_length == -1) {
	err(1, "lseek");
    }
d150 1
a150 1
localize_name(const char *name)
d155 2
d162 1
a162 1
	if (!strcasecmp(tmp + 1, netinit_getrealm()))
d164 2
d178 1
a178 3
    pr_header.headerSize = PRHEADER_SIZE;
    pr_header.freePtr = 0;
    pr_header.eofPtr = PRHEADER_SIZE;
d181 1
a181 3
    pr_header.maxForeign = 65536; /* XXX */
    pr_header.maxInst = 0;
    pr_header.orphan = 0;
a183 5
    pr_header.foreigncount = 0;
    pr_header.instcount = 0;
    memset(pr_header.reserved, 0, 5 * sizeof(int32_t));
    memset(pr_header.nameHash, 0, 8191 * sizeof(int32_t));
    memset(pr_header.idHash, 0, 8191 * sizeof(int32_t));
a184 1
    get_file_length();
d188 1
a188 1
 *
d191 2
a192 2
static int
read_entry(off_t offset, prentry *pr_entry)
d194 2
a195 3
    off_t pos;
    char pr_entry_disk_ydr[PRENTRY_DISK_SIZE];
    int length = PRENTRY_DISK_SIZE;
d197 3
a199 2
    pos = lseek(pr_database, offset, SEEK_SET);
    assert(pos == offset);
d201 1
a201 2
    length = read(pr_database, pr_entry_disk_ydr, PRENTRY_DISK_SIZE);
    assert (length == PRENTRY_DISK_SIZE);
d203 13
a215 2
    if (ydr_decode_prentry_disk((prentry_disk *) pr_entry, pr_entry_disk_ydr, &length) == NULL)
	err(1, "write_entry");
d217 3
a219 2
    return 0;
}
a220 25
/*
 *
 */

static off_t
find_first_free(void)
{
    prentry pr_entry;
    off_t pos;

    if (pr_header.freePtr == 0) { /* if there are no free entries */
	pos = lseek(pr_database, 0, SEEK_END);
	if (pos == -1)
	    err(1, "lseek");
	if (ftruncate(pr_database, pos + PRENTRY_DISK_SIZE) == -1)
	    err(1, "ftruncate");
	return pos;
    } else { /* there are free entries */
	/* XXX if the caller discards this entry it will become orphaned */
	pos = pr_header.freePtr;
	read_entry(pos, &pr_entry);
	pr_header.freePtr = pr_entry.next;
	write_header();
	return pos;
    }
d224 2
a225 2
/*
 *
d228 2
a229 2
static int
write_entry(off_t offset, prentry *pr_entry)
a230 1
    off_t pos;
d233 2
d236 3
a238 5
    if (ydr_encode_prentry_disk((prentry_disk *) pr_entry, pr_entry_disk_ydr, &length) == NULL)
	err(1, "write_entry");

    pos = lseek(pr_database, offset, SEEK_SET);
    assert(pos == offset);
d240 2
a241 2
    length = write(pr_database, pr_entry_disk_ydr, PRENTRY_DISK_SIZE);
    assert (length == PRENTRY_DISK_SIZE);
d243 3
a245 2
    return 0;
}
d247 2
a248 3
/*
 *
 */
d250 1
a250 4
static unsigned long
get_id_hash(long id)
{
    return ((unsigned long) id) % HASHSIZE;
d254 1
a254 1
 *
d257 2
a258 2
static unsigned long
get_name_hash(const char *name)
d260 1
a261 1
    unsigned long hash = 0x47114711;
d263 15
a277 2
    for (i = 0; name[i] && i < 32; i++)
	hash *= name[i];
d279 1
a279 1
    return hash % HASHSIZE;
d287 1
a287 1
get_first_id_entry(unsigned long hash_id, prentry *pr_entry)
d289 2
a290 2
    off_t offset = pr_header.idHash[hash_id];
    int status;
d292 2
a293 4
    pt_debug (PRDB_DB, "get_first_id_entry hash_id: %lu offset: %ld",
	      hash_id, (long)offset);
    if (offset == 0)
	return PRNOENT;
d295 2
a296 1
    status = read_entry(offset, pr_entry);
d298 1
a298 1
    return status;
d306 1
a306 1
get_first_name_entry(unsigned long hash_name, prentry *pr_entry)
d308 1
a308 1
    off_t offset = pr_header.nameHash[hash_name];
d310 1
d312 1
a312 4
    pt_debug (PRDB_DB, "get_first_name_entry hash_name: %lu offset: %ld",
	      hash_name, (long)offset);
    if (offset == 0)
	return PRNOENT;
d314 5
a318 1
    status = read_entry(offset, pr_entry);
d320 5
a324 6
    return status;
}

/*
 *
 */
d326 1
a326 15
static int
update_entry(prentry *pr_entry)
{
    off_t offset;
    int status;
    unsigned long hash_id;
    prentry old_pr_entry;

    pt_debug (PRDB_DB, "update_entry");

    hash_id = get_id_hash(pr_entry->id);

    offset = pr_header.idHash[hash_id];

    status = get_first_id_entry(hash_id, &old_pr_entry);
d328 1
a328 37
	return PRNOENT;

    while (old_pr_entry.id != pr_entry->id) {
	if (old_pr_entry.nextID == 0)
	    return PRNOENT;
	offset=old_pr_entry.nextID;
	status = read_entry(offset, &old_pr_entry);
    }

    return write_entry(offset, pr_entry);
}

/*
 *
 */

static int
insert_entry(prentry *pr_entry)
{
    off_t offset;
    int status;
    unsigned long hash_id, hash_name;
    prentry first_id_entry;
    prentry first_name_entry;
    
    /* Allokera plats i filen */
    offset = find_first_free();

    /* Hitta plats i hashtabell */
    hash_id = get_id_hash(pr_entry->id);
    hash_name = get_name_hash(pr_entry->name);

    status = get_first_id_entry(hash_id, &first_id_entry);
    pr_entry->nextID = status ? 0 : first_id_entry.nextID;

    status = get_first_name_entry(hash_name, &first_name_entry);
    pr_entry->nextName = status ? 0 : first_name_entry.nextName;
d330 1
a330 1
    /* XXX: uppdatera owned och nextOwned */
d332 3
a334 10
    /* Lägg in entryt i filen */
    status = write_entry(offset, pr_entry);
    if (status)
	return status;
    
    /* Uppdatera hashtabell */
    pr_header.idHash[hash_id] = offset;
    pr_header.nameHash[hash_name] = offset;
    write_header();
    return 0;
d398 3
a400 3
    prentry uid_entry;
    prentry gid_entry;
    int error, i;
d402 1
a402 1
    pt_debug (PRDB_DB, "addtogroup");
d404 1
a404 1
    error = get_pr_entry_by_id(uid, &uid_entry);
d408 1
a408 1
    error = get_pr_entry_by_id(gid, &gid_entry);
d412 2
a413 3
    /* XXX should allocate contentry block */
    
    if (uid_entry.count >= PRSIZE || gid_entry.count >= PRSIZE)
d416 22
a437 31
    assert (uid_entry.entries[uid_entry.count] == 0);

    for (i = 0; i < uid_entry.count; i++)
	if (uid_entry.entries[i] == gid)
	    break;

    if (i == uid_entry.count) { 
	if (uid_entry.count < PRSIZE - 1) {
	    uid_entry.entries[uid_entry.count] = gid;
	    uid_entry.count++;
	} else 
	    return PRNOENT;
    }

    assert (gid_entry.entries[gid_entry.count] == 0);

    for (i = 0; i < gid_entry.count; i++)
	if (gid_entry.entries[i] == uid)
	    break;

    if (i == gid_entry.count) {
	if (gid_entry.count < PRSIZE - 1) {
	    gid_entry.entries[gid_entry.count] = uid;
	    gid_entry.count++;
	} else {
	    if (uid_entry.entries[uid_entry.count - 1] == gid) {
		uid_entry.entries[uid_entry.count - 1] = 0;
		uid_entry.count--;
	    }
	    return PRNOENT;
	}
d439 2
d442 1
a442 1
    if ((error = update_entry(&uid_entry)) != 0)
d445 1
a445 1
    if ((error = update_entry(&gid_entry)) != 0)
a448 1

d458 2
a459 2
    prentry uid_entry;
    prentry gid_entry;
d462 1
a462 1
    pt_debug (PRDB_DB, "removefromgroup");
d464 1
a464 1
    error = get_pr_entry_by_id(uid, &uid_entry);
d468 1
a468 1
    error = get_pr_entry_by_id(gid, &gid_entry);
a471 1
    /* XXX No check for full list */
d473 3
a475 1
    /* XXX should the list be sorted? */
d477 7
a483 10
    error = PRNOENT;  /* XXX */
    for (i = 0; i < PRSIZE; i++)
	if (uid_entry.entries[i] == gid) {
	    uid_entry.count--;
	    uid_entry.entries[i] = uid_entry.entries[uid_entry.count];
	    uid_entry.entries[uid_entry.count] = 0;
	    error = 0;
	}
    if (error)
	return error;
d485 3
d489 5
a493 10
    error = PRNOENT;  /* XXX */
    for (i = 0; i < PRSIZE; i++)
	if (gid_entry.entries[i] == uid) {
	    gid_entry.count--;
	    gid_entry.entries[i] = gid_entry.entries[gid_entry.count];
	    gid_entry.entries[gid_entry.count] = 0;
	    error = 0;
	}
    if (error)
	return error;
d495 1
d499 1
a499 1
    if ((error = update_entry(&uid_entry)) != 0)
d502 1
a502 1
    if ((error = update_entry(&gid_entry)) != 0)
d516 1
a516 1
    prentry pr_entry;
d519 1
a519 1
    error = get_pr_entry_by_id (id, &pr_entry);
d523 2
a524 2
    if(default_id_p)
	elist->len = pr_entry.count + 3;
d526 1
a526 1
	elist->len = pr_entry.count;
d528 1
a528 2
    elist->val = malloc(sizeof(*elist->val)
			* (pr_entry.count + elist->len));
a532 1
    /* XXX contentry blocks... */
d535 2
a536 2
    for (i = 0; i < pr_entry.count; i++)
	    elist->val[i] = pr_entry.entries[i];
a541 1
	elist->len = pr_entry.count + 3;
d552 1
a552 1
get_pr_entry_by_id(int id, prentry *pr_entry)
d554 1
a554 1
    unsigned long hash_id = get_id_hash(id);
d556 2
d559 2
a560 2
    pt_debug (PRDB_DB, "get_pr_entry_by_id id:%d hash_id: %ld", 
	      id, hash_id);
d562 2
a563 3
    status = get_first_id_entry(hash_id, pr_entry);
    pt_debug (PRDB_DB, "get_pr_entry_by_id status:%d", status);
    if (status)
d566 1
a566 5
    while (pr_entry->id != id) {
	if (pr_entry->nextID == 0)
	    return PRNOENT;
	status = read_entry(pr_entry->nextID, pr_entry);
    }
d568 1
a568 5
    pt_debug (PRDB_DB, "entry_by_name id: %d owner: %d creator: %d name: %s",
	      pr_entry->id, pr_entry->owner, 
	      pr_entry->creator, pr_entry->name);

    return 0;
d576 1
a576 1
get_pr_entry_by_name(const char *name, prentry *pr_entry)
d578 2
a579 1
    int hash_name = get_name_hash(name);
d582 1
a582 1
    status = get_first_name_entry(hash_name, pr_entry);
d584 1
a584 1
	return PRNOENT;
d586 2
a587 5
    while (strcmp(pr_entry->name, name)) {
	if (pr_entry->nextName == 0)
	    return PRNOENT;
	status = read_entry(pr_entry->nextName, pr_entry);
    }
d589 1
a589 5
    pt_debug (PRDB_DB, "entry_by_name id: %d owner: %d creator: %d name: %s",
	      pr_entry->id, pr_entry->owner, 
	      pr_entry->creator, pr_entry->name);

    return 0;
d599 1
a599 1
    prentry pr_entry;
d602 12
a613 5
    status = get_pr_entry_by_name(name, &pr_entry);
    if (status)
	return status;
    *id = pr_entry.id;
    return 0;
d626 1
a626 1
    status = get_pr_entry_by_id(id, &pr_entry);
d638 1
a638 1
next_free_group_id(void)
d641 5
d647 3
a649 1
    return pr_header.maxGroup;
d657 1
a657 1
next_free_user_id()
d660 5
d666 3
a668 1
    return pr_header.maxID;
d672 1
a672 2
 * Open the pr database that lives in ``databaseprefix''
 * with open(2) ``flags''. Returns 0 or errno.
d675 2
a676 2
static int
open_db(char *databaseprefix, int flags)
a679 2
    assert (pr_database == -1);

d683 11
a693 1
    snprintf (database, sizeof(database), "%s/pr_database", 
d696 12
a707 4
    pr_database = open(database, flags, S_IRWXU);
    if (pr_database < 0)
	return errno;
    return 0;
d710 4
d719 1
a719 1
prserver_create(char *databaseprefix)
d723 2
a725 6

    status = open_db(databaseprefix, O_RDWR|O_CREAT|O_BINARY|O_EXCL);
    if (status)
	errx (1, "failed open_db with error: %s (%d)",
	      strerror(status), status);

d743 2
d755 1
a755 7
    int status;
    
    status = open_db(databaseprefix, O_RDWR|O_BINARY);
    if (status)
	errx (1, "failed open_db with error: %s (%d)",
	      strerror(status), status);

a756 1
    get_file_length();
a766 1
static char *databasedir = NULL;
d769 1
a769 1
static char *debug_level = NULL;
d772 1
a775 1
    {"create",  0, aarg_flag,      &do_create, "create new databas"},
d778 4
a781 1
    {"prefix",'p', aarg_string,    &databasedir, "what dir to store the db"},
a782 3
    {"srvtab",'s', aarg_string,    &srvtab_file, "what srvtab to use"},
    {"debug",  'd',aarg_string,    &debug_level, "enable debug messages"},
    {"log",    'l', aarg_string,   &log_file, "log file"},
d784 2
d796 1
a796 1
    aarg_printusage(args, NULL, "", AARG_AFSSTYLE);
d809 1
d813 1
a813 1
    if (agetarg (args, argc, argv, &optind, AARG_AFSSTYLE)) {
a827 17
    pr_method = log_open (get_progname(), log_file);
    if (pr_method == NULL)
	errx (1, "log_open failed");

    pr_log_unit = log_unit_init (pr_method, "arla", pr_deb_units,
				 PR_DEFAULT_LOG);
    if (pr_log_unit == NULL)
	errx (1, "log_unit_init failed");

    if (debug_level)
	pt_setdebug (debug_level);

    if (do_create) {
	prserver_create (databasedir);
	return 0;
    }

d831 4
a834 1
    cell_init(0, pr_method);
d839 5
d849 5
d863 1
a863 1
    pt_debug (PRDB_WARN, "started");
@


1.1
log
@New Arla userland from Arla between 0.34.2 and current in arla cvs.
Too many new features and fixes to mention here.
@
text
@d17 1
a17 6
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by the Kungliga Tekniska
 *      Högskolan and its contributors.
 * 
 * 4. Neither the name of the Institute nor the names of its contributors
d56 1
a56 1
#include <getarg.h>
d69 1
a69 1
RCSID("$Id: ptserver.c,v 1.24 2000/08/21 00:09:53 tol Exp $");
d77 3
d82 1
d84 9
a92 1
static int ptdebug = 0;
d94 2
a95 2
int
pt_setdebug (int debug)
d97 1
a97 3
    int odebug = ptdebug;
    ptdebug = debug;
    return odebug;
d100 4
d105 1
a105 1
pt_debug (char *fmt, ...)
a107 2
    if (!ptdebug)
	return ;
d110 1
a110 1
    vfprintf (stderr, fmt, args);
d114 3
d134 4
d157 4
d170 3
d183 2
a184 1
    if (tmp = strchr(localname, '@@'))
d191 4
d218 27
d248 1
d259 6
a264 2
	/* Not implemented yet */
	assert(0);
d269 4
d292 3
a294 18
static int
read_entry(off_t offset, prentry *pr_entry)
{
    off_t pos;
    char pr_entry_disk_ydr[PRENTRY_DISK_SIZE];
    int length = PRENTRY_DISK_SIZE;

    pos = lseek(pr_database, offset, SEEK_SET);
    assert(pos == offset);

    length = read(pr_database, pr_entry_disk_ydr, PRENTRY_DISK_SIZE);
    assert (length == PRENTRY_DISK_SIZE);

    if (ydr_decode_prentry_disk((prentry_disk *) pr_entry, pr_entry_disk_ydr, &length) == NULL)
	err(1, "write_entry");

    return 0;
}
d302 4
d318 4
d328 2
a329 2
    pt_debug ("get_first_id_entry hash_id: %lu offset: %ld\n",
	    hash_id, (long)offset);
d338 4
d348 2
a349 2
    pt_debug ("get_first_name_entry hash_name: %lu offset: %ld\n",
	    hash_name, (long)offset);
d358 4
d370 1
a370 1
    fprintf(stderr, "update_entry\n");
d390 4
d430 4
d457 4
d484 4
d489 2
a490 1
addtogroup (int32_t uid, int32_t gid) {
d493 1
a493 1
    int error,i;
d495 1
a495 1
    fprintf(stderr, "addtogroup\n");
d497 2
a498 1
    if (error = get_pr_entry_by_id(uid, &uid_entry))
d501 2
a502 1
    if (error = get_pr_entry_by_id(gid, &gid_entry))
d511 12
a522 2
    uid_entry.entries[uid_entry.count] = gid;
    uid_entry.count++;
d525 17
a541 2
    gid_entry.entries[gid_entry.count] = uid;
    gid_entry.count++;
d552 5
d558 2
a559 1
removefromgroup (int32_t uid, int32_t gid) {
d562 1
a562 1
    int error, i, offset;
d564 1
a564 1
    fprintf(stderr, "removefromgroup\n");
d566 2
a567 1
    if (error = get_pr_entry_by_id(uid, &uid_entry))
d570 2
a571 1
    if (error = get_pr_entry_by_id(gid, &gid_entry))
d614 4
d624 2
a625 1
    if (error = get_pr_entry_by_id (id, &pr_entry))
d628 5
d634 1
a634 1
			* (pr_entry.count + (default_id_p ? 3 : 1)));
d637 1
a638 1
    
a644 1
    elist->val[i] = id;
d646 1
d650 1
a650 2
    } else
	elist->len = pr_entry.count + 1;
d655 3
d665 2
a666 1
    pt_debug ("get_pr_entry_by_id id:%d hash_id: %ld\n", id, hash_id);
d669 1
a669 1
    pt_debug ("get_pr_entry_by_id status:%d\n", status);
d679 3
a681 4
    pt_debug ("pr_entry->id: %d\n", pr_entry->id);
    pt_debug ("pr_entry->owner: %d\n", pr_entry->owner);
    pt_debug ("pr_entry->creator: %d\n", pr_entry->creator);
    pt_debug ("pr_entry->name: %s\n", pr_entry->name);
d686 4
d706 3
a708 4
    fprintf(stderr, "  pr_entry->id: %d\n", pr_entry->id);
    fprintf(stderr, "  pr_entry->owner: %d\n", pr_entry->owner);
    fprintf(stderr, "  pr_entry->creator: %d\n", pr_entry->creator);
    fprintf(stderr, "  pr_entry->name: %s\n", pr_entry->name);
d713 4
d730 4
d747 4
d759 4
a770 1

d795 4
d831 4
d851 4
d859 2
a862 1
static int do_debug = 0;
d865 11
a875 10
static struct getargs args[] = {
    {"create",  0, arg_flag,      &do_create, "create new databas"},
    {"cell",	0, arg_string,    &cell, "what cell to use"},
    {"realm",	0, arg_string,	  &realm, "what realm to use"},
    {"prefix",'p', arg_string,    &databasedir, "what dir to store the db"},
    {"noauth", 0,  arg_flag,	  &no_auth, "disable authentication checks"},
    {"srvtab",'s', arg_string,    &srvtab_file, "what srvtab to use"},
    {"debug",  'd', arg_flag,     &do_debug, "enable debug messages"},
    {"help",  'h', arg_flag,      &do_help, "help"},
    { NULL, 0, arg_end, NULL }
d878 4
d885 1
a885 1
    arg_printusage(args, NULL, "", ARG_AFSSTYLE);
d896 1
a897 1
    int optind = 0;
d899 3
a901 1
    if (getarg (args, argc, argv, &optind, ARG_AFSSTYLE)) {
d909 1
a909 1
	printf("unknown option %s\n", *argv);
d916 11
a926 2
    if (do_debug)
	pt_setdebug (1);
d936 2
a937 1
    printf ("ptserver booting\n");
d939 1
a939 2
    ports_init();
    cell_init(0);
d948 1
a948 1
	errx (1, "prserver_init: error %d\n", ret);
d951 1
a951 1
		       PR_ExecuteRequest, &prservice, NULL);
d955 1
a955 1
    printf("started\n");
@


1.1.1.1
log
@Import of arla-0.35.7
@
text
@d17 6
a22 1
 * 3. Neither the name of the Institute nor the names of its contributors
d61 1
a61 1
#include <agetarg.h>
d74 1
a74 1
RCSID("$KTH: ptserver.c,v 1.36 2000/12/29 19:55:21 tol Exp $");
a81 3
static Log_unit *pr_log_unit;
static Log_method *pr_method;

a83 1
#define all (PRDB_ERROR|PRDB_WARN|PRDB_RPC|PRDB_DB)
d85 1
a85 9
struct units pr_deb_units[] = {
    { "all",		all },
    { "errors",		PRDB_ERROR },
#undef all
    { "warnings",	PRDB_WARN },
    { "rpc",		PRDB_RPC },
    { "db",		PRDB_DB },
    { NULL}
};
d87 2
a88 2
void
pt_setdebug (char *debug_level)
d90 3
a92 1
    log_set_mask_str (pr_method, pr_log_unit, debug_level);
a94 4
/*
 *
 */

d96 1
a96 1
pt_debug (unsigned int level, char *fmt, ...)
d99 2
d103 1
a103 1
    log_vlog (pr_log_unit, level, fmt, args);
a106 3
/*
 *
 */
a123 4
/*
 *
 */

a142 4
/*
 *
 */

a151 3
/*
 *
 */
d162 1
a162 2
    tmp = strchr(localname, '@@');
    if (tmp)
a168 4
/*
 *
 */

a191 27
/*
 *
 */

static int
read_entry(off_t offset, prentry *pr_entry)
{
    off_t pos;
    char pr_entry_disk_ydr[PRENTRY_DISK_SIZE];
    int length = PRENTRY_DISK_SIZE;

    pos = lseek(pr_database, offset, SEEK_SET);
    assert(pos == offset);

    length = read(pr_database, pr_entry_disk_ydr, PRENTRY_DISK_SIZE);
    assert (length == PRENTRY_DISK_SIZE);

    if (ydr_decode_prentry_disk((prentry_disk *) pr_entry, pr_entry_disk_ydr, &length) == NULL)
	err(1, "write_entry");

    return 0;
}

/*
 *
 */

a194 1
    prentry pr_entry;
d205 2
a206 6
	/* XXX if the caller discards this entry it will become orphaned */
	pos = pr_header.freePtr;
	read_entry(pos, &pr_entry);
	pr_header.freePtr = pr_entry.next;
	write_header();
	return pos;
a210 4
/*
 *
 */

d230 18
a247 3
/*
 *
 */
a254 4
/*
 *
 */

a266 4
/*
 *
 */

d273 2
a274 2
    pt_debug (PRDB_DB, "get_first_id_entry hash_id: %lu offset: %ld",
	      hash_id, (long)offset);
a282 4
/*
 *
 */

d289 2
a290 2
    pt_debug (PRDB_DB, "get_first_name_entry hash_name: %lu offset: %ld",
	      hash_name, (long)offset);
a298 4
/*
 *
 */

d307 1
a307 1
    pt_debug (PRDB_DB, "update_entry");
a326 4
/*
 *
 */

a362 4
/*
 *
 */

a385 4
/*
 *
 */

a408 4
/*
 *
 */

d410 1
a410 2
addtogroup (int32_t uid, int32_t gid)
{
d413 1
a413 1
    int error, i;
d415 1
a415 1
    pt_debug (PRDB_DB, "addtogroup");
d417 1
a417 2
    error = get_pr_entry_by_id(uid, &uid_entry);
    if (error)
d420 1
a420 2
    error = get_pr_entry_by_id(gid, &gid_entry);
    if (error)
d429 2
a430 12

    for (i = 0; i < uid_entry.count; i++)
	if (uid_entry.entries[i] == gid)
	    break;

    if (i == uid_entry.count) { 
	if (uid_entry.count < PRSIZE - 1) {
	    uid_entry.entries[uid_entry.count] = gid;
	    uid_entry.count++;
	} else 
	    return PRNOENT;
    }
d433 2
a434 17

    for (i = 0; i < gid_entry.count; i++)
	if (gid_entry.entries[i] == uid)
	    break;

    if (i == gid_entry.count) {
	if (gid_entry.count < PRSIZE - 1) {
	    gid_entry.entries[gid_entry.count] = uid;
	    gid_entry.count++;
	} else {
	    if (uid_entry.entries[uid_entry.count - 1] == gid) {
		uid_entry.entries[uid_entry.count - 1] = 0;
		uid_entry.count--;
	    }
	    return PRNOENT;
	}
    }
a444 5

/*
 *
 */

d446 1
a446 2
removefromgroup (int32_t uid, int32_t gid)
{
d449 1
a449 1
    int error, i;
d451 1
a451 1
    pt_debug (PRDB_DB, "removefromgroup");
d453 1
a453 2
    error = get_pr_entry_by_id(uid, &uid_entry);
    if (error)
d456 1
a456 2
    error = get_pr_entry_by_id(gid, &gid_entry);
    if (error)
a498 4
/*
 *
 */

d505 1
a505 2
    error = get_pr_entry_by_id (id, &pr_entry);
    if (error)
a507 5
    if(default_id_p)
	elist->len = pr_entry.count + 3;
    else
	elist->len = pr_entry.count;

d509 1
a509 1
			* (pr_entry.count + elist->len));
d512 1
a513 1

d520 1
a521 1
	elist->val[i] = id;
d525 2
a526 1
    }
a530 3
/*
 *
 */
d538 1
a538 2
    pt_debug (PRDB_DB, "get_pr_entry_by_id id:%d hash_id: %ld", 
	      id, hash_id);
d541 1
a541 1
    pt_debug (PRDB_DB, "get_pr_entry_by_id status:%d", status);
d551 4
a554 3
    pt_debug (PRDB_DB, "entry_by_name id: %d owner: %d creator: %d name: %s",
	      pr_entry->id, pr_entry->owner, 
	      pr_entry->creator, pr_entry->name);
a558 4
/*
 *
 */

d575 4
a578 3
    pt_debug (PRDB_DB, "entry_by_name id: %d owner: %d creator: %d name: %s",
	      pr_entry->id, pr_entry->owner, 
	      pr_entry->creator, pr_entry->name);
a582 4
/*
 *
 */

a595 4
/*
 *
 */

a608 4
/*
 *
 */

a616 4
/*
 *
 */

d625 1
a649 4
/*
 *
 */

a681 4
/*
 *
 */

a697 4
/*
 *
 */

a701 2
static char *log_file = "syslog";
static char *debug_level = NULL;
d704 1
d707 10
a716 11
static struct agetargs args[] = {
    {"create",  0, aarg_flag,      &do_create, "create new databas"},
    {"cell",	0, aarg_string,    &cell, "what cell to use"},
    {"realm",	0, aarg_string,	  &realm, "what realm to use"},
    {"prefix",'p', aarg_string,    &databasedir, "what dir to store the db"},
    {"noauth", 0,  aarg_flag,	  &no_auth, "disable authentication checks"},
    {"srvtab",'s', aarg_string,    &srvtab_file, "what srvtab to use"},
    {"debug",  'd',aarg_string,    &debug_level, "enable debug messages"},
    {"log",    'l', aarg_string,   &log_file, "log file"},
    {"help",  'h', aarg_flag,      &do_help, "help"},
    { NULL, 0, aarg_end, NULL }
a718 4
/*
 *
 */

d722 1
a722 1
    aarg_printusage(args, NULL, "", AARG_AFSSTYLE);
d733 1
a734 3
    int ret;

    set_progname (argv[0]);
d736 1
a736 1
    if (agetarg (args, argc, argv, &optind, AARG_AFSSTYLE)) {
d744 1
a744 1
	printf("unknown option %s", *argv);
d751 2
a752 11
    pr_method = log_open (get_progname(), log_file);
    if (pr_method == NULL)
	errx (1, "log_open failed");

    pr_log_unit = log_unit_init (pr_method, "arla", pr_deb_units,
				 PR_DEFAULT_LOG);
    if (pr_log_unit == NULL)
	errx (1, "log_unit_init failed");

    if (debug_level)
	pt_setdebug (debug_level);
d762 2
a763 1
    cell_init(0, pr_method);
d765 1
a765 2

    printf ("ptserver booting");
d774 1
a774 1
	errx (1, "prserver_init: error %d", ret);
d777 1
a777 1
		       PR_ExecuteRequest, &prservice, realm);
d781 1
a781 1
    pt_debug (PRDB_WARN, "started");
@


1.1.1.2
log
@Import of arla -current as of Aug 5 2003

ok todd@@ deraadt@@
@
text
@a47 3
#ifdef HAVE_OPENSSL
#include <openssl/des.h>
#else
a48 1
#endif
a63 4
#include <mlog.h>
#include <mdebug.h>
#include <mdb.h>

d69 1
a69 1
RCSID("$arla: ptserver.c,v 1.46 2003/04/09 02:41:28 lha Exp $");
d73 20
a92 1
prheader_disk pr_header;
d94 5
a98 3
#define HEADERID PR_BADID
#define ILLEGAL_ID 0x40000000
#define ILLEGAL_GROUP 0x40000000
d100 3
a102 2
#define PRENTRY_DISK_SIZE (sizeof(prentry_disk) + PR_MAXGROUPS * sizeof(int32_t) + 16)
#define PRHEADER_DISK_SIZE (sizeof(prheader_disk) + 4 * PR_MAXGROUPS * sizeof(int32_t) + 16)
d104 4
a107 4
static void open_db (char *databaseprefix, int flags);
void prserver_close(void);

MDB *nametoid, *idtodata;
d109 4
d118 1
a118 1
void
d121 2
a122 9
    int length = PRHEADER_DISK_SIZE;
    struct mdb_datum key, value;
    char pr_header_ydr[PRHEADER_DISK_SIZE];
    int code;

    char headerid = htonl(HEADERID);

    if (ydr_encode_prheader_disk(&pr_header, pr_header_ydr, &length) == NULL)
        err(1, "write_header");
d124 2
a125 2
    key.data = &headerid;
    key.length = sizeof(headerid);
d127 2
a128 2
    value.data = pr_header_ydr;
    value.length = PRHEADER_DISK_SIZE - length;
d130 2
a131 2
    code = mdb_store(idtodata, &key, &value);
    assert(code == 0);
d138 1
a138 1
void
d141 2
a142 4
    int length = PRHEADER_DISK_SIZE;
    struct mdb_datum key, value;
    char headerid = htonl(HEADERID);
    int code;
d144 2
a145 2
    key.data = &headerid;
    key.length = sizeof(headerid);
d147 5
a151 2
    code = mdb_fetch(idtodata, &key, &value);
    assert(code == 0);
d153 15
a167 2
    if (ydr_decode_prheader_disk(&pr_header, value.data, &length) == NULL)
        err(1, "read_header");
d175 1
a175 1
localize_name(const char *name, Bool *localp)
a179 2
    *localp = FALSE;

d185 1
a185 1
	if (!strcasecmp(tmp + 1, netinit_getrealm())) {
a186 2
	    *localp = TRUE;
	}
d199 3
a201 1
    pr_header.headerSize = PRHEADER_DISK_SIZE;
d204 3
a206 1
/*XXX    pr_header.orphan = 0;*/
d209 5
d215 1
d219 1
a219 1
 * read_prentry(): Fetch data from db, return a classic pr_entry
d222 2
a223 2
int
read_prentry(int id, prentry *pr_entry)
d225 6
a230 2
    prentry_disk disk_entry;
    int status, i;
d232 5
a236 3
    status = get_disk_entry(id, &disk_entry);
    if (status)
	return status;
d238 2
a239 1
    memset(pr_entry, 0, sizeof(prentry));
d241 3
a243 13
    pr_entry->flags = disk_entry.flags;
    pr_entry->id = disk_entry.id;
    pr_entry->cellid = disk_entry.cellid;
    pr_entry->owner = disk_entry.owner;
    pr_entry->creator = disk_entry.creator;
    pr_entry->ngroups = disk_entry.ngroups;
    strlcpy(pr_entry->name, disk_entry.name, sizeof(pr_entry->name));

    if (disk_entry.owned.len > 0)
	pr_entry->owned = disk_entry.owned.val[0];
      
    for (i = 0; i < PRSIZE && i < disk_entry.entries.len; i++)
	pr_entry->entries[i] = disk_entry.entries.val[i];
d245 5
a249 3
    mlog_log (MDEBPRDB, "read_prentry id: %d owner: %d creator: %d name: %s",
	      pr_entry->id, pr_entry->owner, 
	      pr_entry->creator, pr_entry->name);
d251 15
d269 2
a270 2
/* 
 * store_disk_entry(): marshal prentry_disk and store in db
d273 2
a274 2
int
store_disk_entry(prentry_disk *entry)
d276 1
a278 2
    struct mdb_datum key, value;
    int id;
d280 5
a284 3
    mlog_log (MDEBPRDB, "store_disk_entry id: %d owner: %d creator: %d name: %s",
	      entry->id, entry->owner, 
	      entry->creator, entry->name);
d286 2
a287 2
    if (ydr_encode_prentry_disk((prentry_disk *) entry, pr_entry_disk_ydr, &length) == NULL)
	err(1, "store_disk_entry");
d289 2
a290 3
    id = htonl(entry->id);
    key.data = &id;
    key.length = sizeof(id);
d292 3
a294 2
    value.data = pr_entry_disk_ydr;
    value.length = PRENTRY_DISK_SIZE - length;
d296 4
a299 1
    return mdb_store(idtodata, &key, &value);
d303 1
a303 1
 * write_prentry(): update db with classic prentry
d306 2
a307 2
int
write_prentry(prentry *pr_entry)
a308 1
    prentry_disk disk_entry;
d310 7
d318 36
a353 15
    memset(&disk_entry, 0, sizeof(prentry_disk));
    
    disk_entry.flags = pr_entry->flags;
    disk_entry.id = pr_entry->id;
    disk_entry.cellid = pr_entry->cellid;
    disk_entry.owner = pr_entry->owner;
    disk_entry.creator = pr_entry->creator;
    disk_entry.ngroups = pr_entry->ngroups;
/*    disk_entry.owned = pr_entry->owned;   XXX */
    strlcpy(disk_entry.name, pr_entry->name, sizeof(disk_entry.name));
      
    for (i = 0; i < PRSIZE && i < pr_entry->count; i++)
	disk_entry.entries.val[i] = pr_entry->entries[i];
    
    disk_entry.entries.len = i;
d355 1
a355 1
    return store_disk_entry(&disk_entry);
d363 1
a363 1
write_name(prentry *pr_entry)
d365 6
a370 2
    struct mdb_datum key, value;
    int32_t id = htonl(pr_entry->id);
d372 7
a378 2
    key.data = pr_entry->name;
    key.length = strlen(pr_entry->name);
d380 6
a385 2
    value.data = &id;
    value.length = sizeof(id);
d387 1
a387 1
    return mdb_store(nametoid, &key, &value);
d397 1
a397 1
    char *pr_entry_disk_ydr;
d399 6
a404 1
    int id;
d406 3
a408 1
    char *name = pr_entry->name;
d410 5
a414 5
    status = get_ydr_disk_entry(pr_entry->id, &pr_entry_disk_ydr);
    if (status == 0)
	return PREXIST;
    if (status != PRNOENT)
	return status;
d416 1
a416 5
    status = conv_name_to_id(name, &id);
    if (status == 0)
	return PREXIST;
    if (status != PRNOENT)
	return status;
d418 2
a419 1
    status = write_name(pr_entry);
d422 6
a427 6

    return write_prentry(pr_entry);

    /* XXX: update owned and nextOwned */
    /* XXX update header */
    /* write_header(); */
d491 3
a493 3
    prentry_disk uid_entry;
    prentry_disk gid_entry;
    int error, i, tmp1, tmp2;
d495 1
a495 1
    mlog_log (MDEBPRDB, "addtogroup");
d497 1
a497 1
    error = get_disk_entry(uid, &uid_entry);
d501 1
a501 1
    error = get_disk_entry(gid, &gid_entry);
d505 3
a507 2
    if (uid_entry.entries.len >= (PR_MAXGROUPS - 1)
	|| gid_entry.entries.len >= (PR_MAXLIST - 1))
d510 31
a540 22
    i = 0;
    while (uid_entry.entries.val[i] < gid && i < uid_entry.entries.len)
	i++;

    tmp1 = gid;
    for (; i < uid_entry.entries.len; i++) {
	tmp2 = uid_entry.entries.val[i];
	uid_entry.entries.val[i] = tmp1;
	tmp1 = tmp2;
    }
    uid_entry.entries.val[uid_entry.entries.len] = tmp1;
    uid_entry.entries.len++;

    i = 0;
    while (gid_entry.entries.val[i] < uid && i < gid_entry.entries.len)
	i++;

    tmp1 = uid;
    for (; i < gid_entry.entries.len; i++) {
	tmp2 = gid_entry.entries.val[i];
	gid_entry.entries.val[i] = tmp1;
	tmp1 = tmp2;
a541 2
    gid_entry.entries.val[gid_entry.entries.len] = tmp1;
    gid_entry.entries.len++;
d543 1
a543 1
    if ((error = store_disk_entry(&uid_entry)) != 0)
d546 1
a546 1
    if ((error = store_disk_entry(&gid_entry)) != 0)
d550 1
d560 2
a561 2
    prentry_disk uid_entry;
    prentry_disk gid_entry;
d564 1
a564 1
    mlog_log (MDEBPRDB, "removefromgroup");
d566 1
a566 1
    error = get_disk_entry(uid, &uid_entry);
d570 1
a570 1
    error = get_disk_entry(gid, &gid_entry);
d574 1
d576 1
a576 3
    i = 0;
    while (uid_entry.entries.val[i] < gid && i < uid_entry.entries.len)
	i++;
d578 10
a587 2
    if (uid_entry.entries.val[i] != gid)
	return PRNOENT;
a588 2
    for (i++; i < uid_entry.entries.len; i++)
	uid_entry.entries.val[i - 1]  = uid_entry.entries.val[i];
d590 10
a599 1
    uid_entry.entries.len--;
a600 11
    i = 0;
    while (gid_entry.entries.val[i] < uid && i < gid_entry.entries.len)
	i++;

    if (gid_entry.entries.val[i] != uid)
	return PRNOENT;

    for (i++; i < gid_entry.entries.len; i++)
	gid_entry.entries.val[i - 1]  = gid_entry.entries.val[i];

    gid_entry.entries.len--;
d604 1
a604 1
    if ((error = store_disk_entry(&uid_entry)) != 0)
d607 1
a607 1
    if ((error = store_disk_entry(&gid_entry)) != 0)
d621 1
a621 1
    prentry_disk disk_entry;
d624 1
a624 1
    error = get_disk_entry(id, &disk_entry);
d628 2
a629 2
    if (default_id_p)
	elist->len = disk_entry.entries.len + 3;
d631 1
a631 1
	elist->len = disk_entry.entries.len;
d633 2
a634 1
    elist->val = malloc(sizeof(*elist->val) * elist->len);
d639 1
d642 2
a643 2
    for (i = 0; i < disk_entry.entries.len; i++)
	    elist->val[i] = disk_entry.entries.val[i];
d649 1
d660 1
a660 1
get_ydr_disk_entry(int id, char **buf)
d662 1
a662 1
    struct mdb_datum key, value;
a663 2
    
    id = htonl(id);
d665 2
a666 2
    key.data = &id;
    key.length = sizeof(id);
d668 3
a670 2
    status = mdb_fetch(idtodata, &key, &value);
    if (status == ENOENT)
d673 5
a677 1
    *buf = value.data;
d679 5
a683 1
    return status;
d691 1
a691 1
get_disk_entry(int id, prentry_disk *entry)
d693 1
a693 2
    char *pr_entry_disk_ydr;
    int length = PRENTRY_DISK_SIZE; /* XXX maxsize in mdb??? */
d696 1
a696 1
    status = get_ydr_disk_entry(id, &pr_entry_disk_ydr);
d698 7
a704 1
	return status;
d706 3
a708 2
    if (ydr_decode_prentry_disk(entry, pr_entry_disk_ydr, &length) == NULL)
	err(1, "get_disk_entry");
d710 1
a710 1
    return status;
d720 1
a720 1
    struct mdb_datum key, value;
d723 5
a727 12
    key.data = strdup(name); /*XXX*/
    key.length = strlen(name);

    status = mdb_fetch(nametoid, &key, &value);
    if (status == ENOENT)
	status = PRNOENT;
    else
	*id = ntohl(*((int *)value.data));
    
    free(key.data);

    return status;
d740 1
a740 1
    status = read_prentry(id, &pr_entry);
d752 1
a752 1
next_free_group_id(int *id)
a754 5
    if (pr_header.maxGroup == ILLEGAL_GROUP) {
	pr_header.maxGroup++;
	return -1;
    }

d756 1
a756 3

    *id = pr_header.maxGroup;
    return 0;
d764 1
a764 1
next_free_user_id(int *id)
a766 5
    if (pr_header.maxID == ILLEGAL_ID) {
	pr_header.maxID--;
	return -1;
    }

d768 1
a768 3

    *id = pr_header.maxID;
    return 0;
d772 2
a773 1
 *
d776 2
a777 2
static void
open_db (char *databaseprefix, int flags)
d781 2
d786 1
a786 1
    snprintf (database, sizeof(database), "%s/pr_idtodata", 
d789 4
a792 15
    mlog_log (MDEBPR, "Loading db from file %s\n", database);

    idtodata = mdb_open(database, flags, 0600);
    if (idtodata == NULL)
        err(1, "failed open (%s)", database);


    snprintf (database, sizeof(database), "%s/pr_nametoid", 
	      databaseprefix);

    mlog_log (MDEBPR, "Loading db from file %s\n", database);

    nametoid = mdb_open(database, flags, 0600);
    if (nametoid == NULL)
        err(1, "failed open (%s)", database);
a794 11
void
prserver_close(void)
{
    mdb_close(idtodata);
    mdb_close(nametoid);
}

#ifndef O_BINARY
#define O_BINARY 0
#endif

d800 1
a800 1
prserver_create (char *databaseprefix)
d804 6
a809 1
    open_db (databaseprefix, O_RDWR|O_CREAT|O_EXCL|O_BINARY);
a810 1
    printf ("Creating a new pr-database.\n");
a827 2
    prserver_close();

d838 7
a844 1
    open_db(databaseprefix, O_RDWR|O_BINARY);
d846 1
d857 1
d860 1
a860 1
static char *debug_levels = NULL;
a862 1
static char *databasedir = NULL;
d866 1
d869 1
a869 4
    {"debug",  'd', aarg_string,  &debug_levels, "debug level"},
    {"log",	'l',	aarg_string,	&log_file,
     "where to write log (stderr, syslog (default), or path to file)"},
    {"srvtab", 0, aarg_string,    &srvtab_file, "what srvtab to use"},
d871 3
a874 2
    {"dbdir",  0, aarg_string,    &databasedir, "where to store the db"},
    {"create",  0, aarg_flag,      &do_create, "create new database"},
d885 1
a885 1
    aarg_printusage (args, NULL, "", AARG_GNUSTYLE);
a897 1
    Log_method *method;
d901 1
a901 1
    if (agetarg (args, argc, argv, &optind, AARG_GNUSTYLE)) {
d916 17
d936 1
a936 4
    method = log_open (getprogname(), log_file);
    if (method == NULL)
	errx (1, "log_open failed");
    cell_init(0, method);
a940 5
    mlog_loginit (method, milko_deb_units, MDEFAULT_LOG);

    if (debug_levels)
	mlog_log_set_level (debug_levels);

a945 5
    if (do_create) {
	prserver_create (databasedir);
	return 0;
    }

d955 1
a955 1
    mlog_log (MDEBWARN, "started");
@


