head	1.4;
access;
symbols
	OPENBSD_5_2:1.3.0.38
	OPENBSD_5_2_BASE:1.3
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.36
	OPENBSD_5_0:1.3.0.34
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.32
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.3.0.30
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.3.0.26
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.28
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.3.0.24
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.3.0.22
	OPENBSD_4_4_BASE:1.3
	OPENBSD_4_3:1.3.0.20
	OPENBSD_4_3_BASE:1.3
	OPENBSD_4_2:1.3.0.18
	OPENBSD_4_2_BASE:1.3
	OPENBSD_4_1:1.3.0.16
	OPENBSD_4_1_BASE:1.3
	OPENBSD_4_0:1.3.0.14
	OPENBSD_4_0_BASE:1.3
	OPENBSD_3_9:1.3.0.12
	OPENBSD_3_9_BASE:1.3
	OPENBSD_3_8:1.3.0.10
	OPENBSD_3_8_BASE:1.3
	OPENBSD_3_7:1.3.0.8
	OPENBSD_3_7_BASE:1.3
	OPENBSD_3_6:1.3.0.6
	OPENBSD_3_6_BASE:1.3
	OPENBSD_3_5:1.3.0.4
	OPENBSD_3_5_BASE:1.3
	OPENBSD_3_4:1.3.0.2
	OPENBSD_3_4_BASE:1.3
	arla-20030805:1.1.1.2
	OPENBSD_3_3:1.2.0.4
	OPENBSD_3_3_BASE:1.2
	OPENBSD_3_2:1.2.0.2
	OPENBSD_3_2_BASE:1.2
	arla-0-35-7:1.1.1.1
	arla:1.1.1
	OPENBSD_3_1:1.1.0.8
	OPENBSD_3_1_BASE:1.1
	OPENBSD_3_0:1.1.0.6
	OPENBSD_3_0_BASE:1.1
	OPENBSD_2_9_BASE:1.1
	OPENBSD_2_9:1.1.0.4
	OPENBSD_2_8:1.1.0.2
	OPENBSD_2_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.4
date	2012.08.23.06.21.53;	author deraadt;	state dead;
branches;
next	1.3;

1.3
date	2003.08.05.09.16.15;	author hin;	state Exp;
branches;
next	1.2;

1.2
date	2002.06.07.04.42.38;	author hin;	state Exp;
branches;
next	1.1;

1.1
date	2000.09.11.14.41.18;	author art;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.06.07.04.14.33;	author hin;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.08.05.08.21.06;	author hin;	state Exp;
branches;
next	;


desc
@@


1.4
log
@the afs src tree can go away
@
text
@/*
 * Copyright (c) 1999, 2000 Kungliga Tekniska Högskolan
 * (Royal Institute of Technology, Stockholm, Sweden).
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */


/*
 * simple flat db for the vnodes
 */

#include "voldb_locl.h"
#include "voldb_internal.h"

RCSID("$arla: voldb.c,v 1.24 2002/02/07 17:59:56 lha Exp $");

struct voldb_type *voltypes[] = {
    &vdb_flat,
};


/*
 * afs_dir_p: returns true if vno is for a dir
 */

int
afs_dir_p (int32_t vno) {
    return vno & 1;
}

/*
 * Conversion
 */

int32_t
dir_afs2local (int32_t vno)
{
    assert (vno);
    return (vno - 1) >> 1;
}
    
int32_t
dir_local2afs (int32_t vno)
{
    return (vno << 1 ) + 1;
}

int32_t
file_afs2local (int32_t vno)
{
    assert (vno);
    return (vno >> 1) - 1;
}
    
int32_t
file_local2afs (int32_t vno)
{
    return (vno + 1) << 1 ;
}

/*
 *
 */

int
voldb_parse_header (struct voldb *db, void *d, size_t sz)
{
    uint32_t i;
    unsigned char *data = d;
    
    assert (sz >= VOLDB_HEADER_HALF);
    
    memcpy (&i, data, sizeof (i));
    db->hdr.magic = ntohl (i);
    data += sizeof (uint32_t);
    
    memcpy (&i, data, sizeof (i));
    db->hdr.num = ntohl (i);
    data += sizeof (uint32_t);
    
    memcpy (&i, data, sizeof (i));
    db->hdr.flags = ntohl (i);
    data += sizeof (uint32_t);

    return 0;
}

/*
 * boot up the db
 * `fd' is a file descriptor to a db that is returned in `db'.
 * `fd' is saved if everythings works out ok, otherwise its
 * up to the caller to close it.
 */

int
voldb_init (int fd, int32_t type, int32_t volume, struct voldb **db)
{
    struct stat sb;
    int ret;

    assert (db);
    *db = NULL;

    if (type < 0 || 
	type >= sizeof (**voltypes)/ sizeof(*voltypes))
	return EINVAL;

    ret = fstat (fd, &sb);
    if (ret)
	return errno; /* XXX */
    
    if (!S_ISREG(sb.st_mode))
	return EINVAL; /* XXX */
    
    *db = calloc (1, sizeof (**db));
    if (*db == NULL)
	return ENOMEM; /* XXX */

    (*db)->size = sb.st_size;

    (*db)->fd = fd;
    (*db)->volume = volume;
    
    ret = VOLDB_FUNC((*db),init)(fd, *db, 0);
    if (ret) {
	free (*db);
	return ret;
    }

    return 0;
}    

/*
 * closes the db
 * The saved `fd' is also closed.
 */

int
voldb_close (struct voldb *db)
{
    int ret;

    assert (db);

    ret = VOLDB_FUNC(db,close)(db);

    free (db);
    return 0;
}


/*
 * store e as num'th acl entry (n is 0 based), convert it to
 * network order.
 *
 * This one is special, where is where we should add acl's on file.
 * Guess it's will be a configuration option.
 */

int
voldb_put_acl (struct voldb *db, uint32_t num, struct voldb_dir_entry *e)
{
    assert (db && e);
    assert ((db->hdr.flags & VOLDB_DIR) == VOLDB_DIR);

    return VOLDB_FUNC(db,put_acl)(db, num, e);
}

/*
 * store a entry `e' in aproproate database `db'
 */

int
voldb_put_entry (struct voldb *db, int32_t num, struct voldb_entry *e)
{
    assert (db && e);

    switch (e->type) {
    case TYPE_DIR:
	assert ((db->hdr.flags & VOLDB_DIR) == VOLDB_DIR);
	assert (e->u.dir.FileType == e->type);
	return voldb_put_dir (db, num, &e->u.dir);
    case TYPE_FILE:
    case TYPE_LINK:
	assert ((db->hdr.flags & VOLDB_FILE) == VOLDB_FILE);
	assert (e->u.file.FileType == e->type);
	return voldb_put_file (db, num, &e->u.file);
    default:
	abort();
    }
}

/*
 *
 */

int
voldb_get_size (struct voldb *db, int32_t *total_size, int32_t *num_entries)
{
    assert (db);

    *total_size	   = db->size;
    *num_entries   = db->hdr.num;
    
    return 0;
}

/*
 * Retrive a entry `e' from the database `db'
 *
 * We use the db to figure out what type e might have.  In the case of
 * a FILE/LINK we have to look at the content of `e' after the fetch. 
 */

int
voldb_get_entry (struct voldb *db, int32_t num, struct voldb_entry *e)
{
    assert (db && e);

    if ((db->hdr.flags & VOLDB_DIR) == VOLDB_DIR) {
	e->type = TYPE_DIR;
	return voldb_get_dir (db, num, &e->u.dir);
    }
    if ((db->hdr.flags & VOLDB_FILE) == VOLDB_FILE) {
	int ret;
	ret = voldb_get_file (db, num, &e->u.file);
	if (ret == 0)
	    e->type = e->u.file.FileType;
	return ret;
    } else
	abort();
}

/* Expand the table to num size */

int
voldb_expand (struct voldb *db, int32_t num)
{
    assert (db);

    return VOLDB_FUNC(db, expand)(db, num);
}

/* Rebuild the table */

int
voldb_rebuild (struct voldb *db)
{
    assert (db);

    return VOLDB_FUNC(db, rebuild)(db);
}

/*
 * Fill out the data we need to have stored and the
 * let the lower layer store it.
 */

int
voldb_write_hdr (int fd, struct voldb *db)
{
    int ret;
    uint32_t i;
    unsigned char data[VOLDB_HEADER_SIZE], *ptr;

    ptr = data;

    i = htonl (db->hdr.magic);
    memcpy (ptr, &i, sizeof (i));
    ptr += sizeof (uint32_t);

    i = htonl (db->hdr.num);
    memcpy (ptr, &i, sizeof (i));
    ptr += sizeof (uint32_t);

    i = htonl (db->hdr.flags);
    memcpy (ptr, &i, sizeof (i));
    ptr += sizeof (uint32_t);
    
    /* Here is space for yet other 2 int32_t */

    ret = VOLDB_FUNC(db,write_header)(db, data, VOLDB_HEADER_SIZE);

    return ret;
}


/*
 * create a db header in a empty existing file pointed by `fd'
 * with flags set to `flags'.
 */

int
voldb_create_header (int fd, int type, int flags)
{
    struct stat sb;
    struct voldb db;
    int ret;

    ret = fstat (fd, &sb);
    if (ret)
	return errno; /* XXX */

    if (sb.st_size != 0)
	return EINVAL; /* XXX */

    ret = ftruncate (fd, VOLDB_HEADER_SIZE);
    if (ret)
	return errno; /* XXX */

    db.type		= type;
    db.hdr.magic 	= VOLDB_MAGIC_HEADER;
    db.hdr.num 		= 0;
    db.hdr.flags 	= flags;
    db.ptr 		= NULL;
    db.size		= VOLDB_HEADER_SIZE;
    
    ret = VOLDB_FUNC(&db,init)(fd, &db, 1);
    if (ret) abort();

    ret = voldb_write_hdr (fd, &db);
    if (ret) abort();

    ret = VOLDB_FUNC(&db,close)(&db);
    if (ret) abort();
    return ret;
}

/*
 * Assure `db' is stored to disk.
 */

int
voldb_flush (struct voldb *db)
{
    int ret;
    assert (db);
    ret = voldb_write_hdr (db->fd, db);
    if (ret) return ret;
    return VOLDB_FUNC(db,flush)(db);
}


int
voldb_new_entry (struct voldb *db, uint32_t *num, uint32_t *unique)
{
    assert (db && unique);

    assert ((db->hdr.flags & (VOLDB_FILE|VOLDB_DIR)) != 
	    (VOLDB_FILE|VOLDB_DIR));
    assert ((db->hdr.flags & (VOLDB_FILE|VOLDB_DIR)) != 0);

    return VOLDB_FUNC(db,new_entry)(db, num, unique);
}

/*
 *
 */

int
voldb_del_entry (struct voldb *db, uint32_t num, onode_opaque *ino)
{
    assert (db);

    return VOLDB_FUNC(db,del_entry)(db, num, ino);
}


/*
 *
 */

int
voldb_header_info (struct voldb *db, 
		   uint32_t *num,
		   uint32_t *flags)
{
    if (num)
	*num = db->hdr.num;
    if (flags)
	*flags = db->hdr.flags;

    return 0;
}

/*
 *
 */

uint32_t
voldb_get_volume (struct voldb *db)
{
    return db->volume;
}

/*
 *
 */

int
voldb_pretty_print_file (struct voldb_file_entry *e)
{
    printf ("  nextptr		= %d\n", e->nextptr);
    printf ("  unique		= %d\n", e->unique);
    printf ("  ino		= ");
    vstatus_print_onode (stdout, &e->ino);
    printf ("  InterfaceVersion = %d\n", e->InterfaceVersion);
    printf ("  FileType		= %d\n", e->FileType);
    printf ("  LinkCount	= %d\n", e->LinkCount);
    printf ("  Length		= %d\n", e->Length);
    printf ("  DataVersion	= %d\n", e->DataVersion);
    printf ("  Author		= %d\n", e->Author);
    printf ("  Owner		= %d\n", e->Owner);
    printf ("  UnixModeBits	= 0%o\n", e->UnixModeBits);
    printf ("  ParentVnode	= %d\n", e->ParentVnode);
    printf ("  ParentUnique	= %d\n", e->ParentUnique);
    printf ("  SegSize		= %d\n", e->SegSize);
    printf ("  ServerModTime	= %d\n", e->ServerModTime);
    printf ("  Group		= %d\n", e->Group);

    return 0;
}

int
voldb_pretty_print_dir (struct voldb_dir_entry *e)
{
    int i;

    printf ("  nextptr		= %d\n", e->nextptr);
    printf ("  unique		= %d\n", e->unique);
    printf ("  ino		= ");
    vstatus_print_onode (stdout, &e->ino);
    printf ("  InterfaceVersion = %d\n", e->InterfaceVersion);
    printf ("  FileType		= %d\n", e->FileType);
    printf ("  LinkCount	= %d\n", e->LinkCount);
    printf ("  Length		= %d\n", e->Length);
    printf ("  DataVersion	= %d\n", e->DataVersion);
    printf ("  Author		= %d\n", e->Author);
    printf ("  Owner		= %d\n", e->Owner);
    printf ("  UnixModeBits	= 0%o\n", e->UnixModeBits);
    printf ("  ParentVnode	= %d\n", e->ParentVnode);
    printf ("  ParentUnique	= %d\n", e->ParentUnique);
    printf ("  SegSize		= %d\n", e->SegSize);
    printf ("  ServerModTime	= %d\n", e->ServerModTime);
    printf ("  Group		= %d\n", e->Group);

    printf ("  ACL:");
    printf ("  negative:\n");
    for (i = 0; i < FS_MAX_ACL; i++)
	printf ("    owner %d flags 0x%x\n", 
		e->negacl[i].owner, e->negacl[i].flags);
    printf ("  positive:\n");
    for (i = 0; i < FS_MAX_ACL; i++)
	printf ("    owner %d flags 0x%x\n", 
		e->acl[i].owner, e->acl[i].flags);

    return 0;
}

int
voldb_pretty_print_header (struct voldb *db)
{
    printf ("type:\t%d", db->type);
    printf ("size:\t%d", db->size);
    printf ("magic:\t0x%x (should be 0x%x)\n",
	    db->hdr.magic, VOLDB_MAGIC_HEADER);
    printf ("num:\t%d\n", db->hdr.num);
    printf ("flags:\t0x%x", db->hdr.flags);
    return 0;
}

/*
 * voldb_update_time
 *
 * Should be called upon creation and when data is modified.
 * Should be called before any call to vld_storestatus_to_ent().
 * Should _not_ be called when metadata is changed.
 */

void
voldb_update_time(struct voldb_entry *e, time_t t)
{
    switch (e->type) {
    case TYPE_DIR:
	e->u.dir.ServerModTime = t; /* XXX update ClientModTime also */
	break;
    case TYPE_FILE:
    case TYPE_LINK:
	e->u.file.ServerModTime = t; /* XXX update ClientModTime also */
	break;
    default:
	abort();
	break;
    }
}
@


1.3
log
@Merge
@
text
@@


1.2
log
@merge
@
text
@d42 1
a42 1
RCSID("$KTH: voldb.c,v 1.21 2000/10/03 00:20:13 lha Exp $");
d95 1
a95 1
    u_int32_t i;
d102 1
a102 1
    data += sizeof (u_int32_t);
d106 1
a106 1
    data += sizeof (u_int32_t);
d110 1
a110 1
    data += sizeof (u_int32_t);
d188 1
a188 1
voldb_put_acl (struct voldb *db, u_int32_t num, struct voldb_dir_entry *e)
d261 20
d290 1
a290 1
    u_int32_t i;
d297 1
a297 1
    ptr += sizeof (u_int32_t);
d301 1
a301 1
    ptr += sizeof (u_int32_t);
d305 1
a305 1
    ptr += sizeof (u_int32_t);
d372 1
a372 1
voldb_new_entry (struct voldb *db, u_int32_t *num, u_int32_t *unique)
d388 1
a388 1
voldb_del_entry (struct voldb *db, u_int32_t num, onode_opaque *ino)
d402 2
a403 2
		   u_int32_t *num,
		   u_int32_t *flags)
d417 1
a417 1
u_int32_t
@


1.1
log
@New Arla userland from Arla between 0.34.2 and current in arla cvs.
Too many new features and fixes to mention here.
@
text
@d17 1
a17 6
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by the Kungliga Tekniska
 *      Högskolan and its contributors.
 * 
 * 4. Neither the name of the Institute nor the names of its contributors
d42 1
a42 1
RCSID("$Id: voldb.c,v 1.20 2000/07/22 03:56:27 lha Exp $");
@


1.1.1.1
log
@Import of arla-0.35.7
@
text
@d17 6
a22 1
 * 3. Neither the name of the Institute nor the names of its contributors
d47 1
a47 1
RCSID("$KTH: voldb.c,v 1.21 2000/10/03 00:20:13 lha Exp $");
@


1.1.1.2
log
@Import of arla -current as of Aug 5 2003

ok todd@@ deraadt@@
@
text
@d42 1
a42 1
RCSID("$arla: voldb.c,v 1.24 2002/02/07 17:59:56 lha Exp $");
d95 1
a95 1
    uint32_t i;
d102 1
a102 1
    data += sizeof (uint32_t);
d106 1
a106 1
    data += sizeof (uint32_t);
d110 1
a110 1
    data += sizeof (uint32_t);
d188 1
a188 1
voldb_put_acl (struct voldb *db, uint32_t num, struct voldb_dir_entry *e)
a260 20
/* Expand the table to num size */

int
voldb_expand (struct voldb *db, int32_t num)
{
    assert (db);

    return VOLDB_FUNC(db, expand)(db, num);
}

/* Rebuild the table */

int
voldb_rebuild (struct voldb *db)
{
    assert (db);

    return VOLDB_FUNC(db, rebuild)(db);
}

d270 1
a270 1
    uint32_t i;
d277 1
a277 1
    ptr += sizeof (uint32_t);
d281 1
a281 1
    ptr += sizeof (uint32_t);
d285 1
a285 1
    ptr += sizeof (uint32_t);
d352 1
a352 1
voldb_new_entry (struct voldb *db, uint32_t *num, uint32_t *unique)
d368 1
a368 1
voldb_del_entry (struct voldb *db, uint32_t num, onode_opaque *ino)
d382 2
a383 2
		   uint32_t *num,
		   uint32_t *flags)
d397 1
a397 1
uint32_t
@


