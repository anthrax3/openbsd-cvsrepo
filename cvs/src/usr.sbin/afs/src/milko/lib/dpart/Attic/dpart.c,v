head	1.4;
access;
symbols
	OPENBSD_5_2:1.3.0.38
	OPENBSD_5_2_BASE:1.3
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.36
	OPENBSD_5_0:1.3.0.34
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.32
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.3.0.30
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.3.0.26
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.28
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.3.0.24
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.3.0.22
	OPENBSD_4_4_BASE:1.3
	OPENBSD_4_3:1.3.0.20
	OPENBSD_4_3_BASE:1.3
	OPENBSD_4_2:1.3.0.18
	OPENBSD_4_2_BASE:1.3
	OPENBSD_4_1:1.3.0.16
	OPENBSD_4_1_BASE:1.3
	OPENBSD_4_0:1.3.0.14
	OPENBSD_4_0_BASE:1.3
	OPENBSD_3_9:1.3.0.12
	OPENBSD_3_9_BASE:1.3
	OPENBSD_3_8:1.3.0.10
	OPENBSD_3_8_BASE:1.3
	OPENBSD_3_7:1.3.0.8
	OPENBSD_3_7_BASE:1.3
	OPENBSD_3_6:1.3.0.6
	OPENBSD_3_6_BASE:1.3
	OPENBSD_3_5:1.3.0.4
	OPENBSD_3_5_BASE:1.3
	OPENBSD_3_4:1.3.0.2
	OPENBSD_3_4_BASE:1.3
	arla-20030805:1.1.1.2
	OPENBSD_3_3:1.2.0.4
	OPENBSD_3_3_BASE:1.2
	OPENBSD_3_2:1.2.0.2
	OPENBSD_3_2_BASE:1.2
	arla-0-35-7:1.1.1.1
	arla:1.1.1
	OPENBSD_3_1:1.1.0.8
	OPENBSD_3_1_BASE:1.1
	OPENBSD_3_0:1.1.0.6
	OPENBSD_3_0_BASE:1.1
	OPENBSD_2_9_BASE:1.1
	OPENBSD_2_9:1.1.0.4
	OPENBSD_2_8:1.1.0.2
	OPENBSD_2_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.4
date	2012.08.23.06.21.52;	author deraadt;	state dead;
branches;
next	1.3;

1.3
date	2003.08.05.09.16.15;	author hin;	state Exp;
branches;
next	1.2;

1.2
date	2002.06.07.04.42.38;	author hin;	state Exp;
branches;
next	1.1;

1.1
date	2000.09.11.14.41.14;	author art;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.06.07.04.14.31;	author hin;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.08.05.08.21.05;	author hin;	state Exp;
branches;
next	;


desc
@@


1.4
log
@the afs src tree can go away
@
text
@/*
 * Copyright (c) 1999 Kungliga Tekniska Högskolan
 * (Royal Institute of Technology, Stockholm, Sweden).
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <config.h>

#include <roken.h>

#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/fcntl.h>
#ifdef HAVE_STATVFS
#include <sys/statvfs.h>
#endif
#ifdef HAVE_STATFS_H
#include <sys/statfs.h>
#endif
#include <sys/mount.h>
#include <dirent.h>
#include <stdlib.h>
#include <errno.h>
#include <assert.h>

#include <unistd.h>

#include <atypes.h>

#include <err.h>

#include <dpart.h>

RCSID("$arla: dpart.c,v 1.11 2002/06/02 21:12:16 lha Exp $");

#ifdef MILKO_ROOT
char *dpart_root = MILKO_ROOT;
#else
char *dpart_root = "";
#endif

/*
 * Allocate a dp_part structure for partition `num' and
 * return it in `dp'.
 */

int
dp_create (uint32_t num, struct dp_part **dp)
{
    struct dp_part *d;
    int ret;
    char str[3], *ptr = str;

    assert (dp);

    *dp = NULL;

    if (num > (('z' - 'a') * ('z' - 'a')))
	return EINVAL;

    d = malloc (sizeof (*d));
    if (d == NULL)
	return ENOMEM;
    memset (d, 0, sizeof(*d));

    if (num > 'z' - 'a') {
	ret = num / ('z' - 'a');
	num -= ret * ('z' - 'a');
	*ptr = ret + 'a';
	ptr++;
    }
    ptr[0] = num + 'a';
    ptr[1] = '\0';

    ret = asprintf (&d->part, "%s/vicep%s", dpart_root, str);
    if (ret < 0) {
	free (d);
	return EINVAL;
    }
    
    d->num = num;
    d->ref = 1;

    *dp = d;
    return 0;
}

void
dp_ref (struct dp_part *dp)
{
    if (dp)
	++dp->ref;
}

/*
 * free the dpart structure in `dp'.
 */

void
dp_free (struct dp_part *dp)
{
    if (dp) {
	if (--dp->ref)
	    return;
	if (dp->part)
	    free (dp->part);
	free (dp);
    }
}

/*
 * Iterate over all local partition and returns when one found.
 * `*dp' should one the first call be set to NULL. For each
 * call next dpart is returned. When last entry is found `*dp' is
 * set to NULL. On error != 0 is returned.
 */

int
dp_find (struct dp_part **dp)
{
    uint32_t num;
    int found = 0, ret;
    struct stat sb;
    
    assert (dp);

    if (*dp == NULL) {
	num = -1;
    } else {	
	num = (*dp)->num;
	dp_free (*dp);
	*dp = NULL;
    }
    do { 
	++num;
	
	if (*dp != NULL)
	    dp_free (*dp);

	ret = dp_create (num, dp);
	if (ret)
	    return ret;
	
	if (stat ((*dp)->part, &sb) == 0 && S_ISDIR(sb.st_mode))
	    found = 1;

    } while (!found);

    return 0;
}


/*
 *
 */

int
dp_findvol (struct dp_part *d, void (*cb)(void *, int), void *data)
{
    DIR *dir;
    struct dirent *e;
    int fd, ret;

    assert (d);

    ret = chdir (d->part);
    if (ret)
	return 0;

    dir = opendir (d->part);
    if (dir == NULL)
	return 0;

    while ((e = readdir (dir)) != NULL) {
	if (strncmp (e->d_name, "vol", 3))
	    continue;

	fd = open (e->d_name, O_RDWR, 0600);
	if (fd < 0)
	    errx (1, "can't open %s/%s", d->part, e->d_name);

	(cb) (data, fd);
	close (fd);
    }
    closedir (dir);
    return 0;
}

/*
 *
 */

int
dp_parse (const char *str, uint32_t *num)
{
    int len;
    uint32_t part = 0;

    assert (str && num);

    len = strlen (str);
    if (len == 0)
	return EINVAL;
    if (len > 6 && strncmp (str, "/vicep", 6) == 0) {
	str += 6;
	len -= 6;
    }
    if (len > 2)
	return EINVAL;
    if (len == 2) {
	if (*str < 'a' || *str > 'z')
	    return EINVAL;
	part += ('z' - 'a') * (*str - 'a' + 1);
	str++;
	len--;
    }
    if (*str < 'a' || *str > 'z')
	return EINVAL;
    part += *str - 'a';

    *num = part;
    return 0;
}

/*
 *
 */

struct dp_part *
dp_getpart (const char *str)
{
    int ret;
    struct dp_part *dp;
    uint32_t part;

    ret = dp_parse (str, &part);
    if (ret)
	return NULL;

    ret = dp_create (part, &dp);
    if (ret)
	return NULL;

    return dp;
}

/*
 * get available and total number of 1k blocks on partition
 */

int
dp_getstats (struct dp_part *dp, long *availblocks, long *totalblocks)
{
#ifdef HAVE_STATVFS
    struct statvfs sb;
#else
    struct statfs sb;
#endif
    int reservedblocks;
    int ret;

#ifdef HAVE_STATVFS
    ret = statvfs (dp->part, &sb);
#else
    ret = statfs (dp->part, &sb);
#endif
    if (ret)
	return errno;
    
    reservedblocks = sb.f_bfree - sb.f_bavail;
    if (sb.f_bsize <= 1024) {
	*availblocks = sb.f_bavail * (1024/sb.f_bsize);
	*totalblocks = (sb.f_blocks - reservedblocks) * (1024/sb.f_bsize);
    } else {
	*availblocks = sb.f_bavail / (sb.f_bsize/1024);
	*totalblocks = (sb.f_blocks - reservedblocks) / (sb.f_bsize/1024);
    }

    return 0;
}
@


1.3
log
@Merge
@
text
@@


1.2
log
@merge
@
text
@d36 2
d42 7
d62 1
a62 1
RCSID("$KTH: dpart.c,v 1.6 2000/12/29 20:12:35 tol Exp $");
d76 1
a76 1
dp_create (u_int32_t num, struct dp_part **dp)
d86 1
a86 1
    if (num > ('z' - 'a' * 'z' - 'a'))
d149 1
a149 1
    u_int32_t num;
d222 1
a222 1
dp_parse (const char *str, u_int32_t *num)
d225 1
a225 1
    u_int32_t part = 0;
d262 1
a262 1
    u_int32_t part;
d273 35
@


1.1
log
@New Arla userland from Arla between 0.34.2 and current in arla cvs.
Too many new features and fixes to mention here.
@
text
@d17 1
a17 6
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by the Kungliga Tekniska
 *      Högskolan and its contributors.
 * 
 * 4. Neither the name of the Institute nor the names of its contributors
d53 7
a59 1
RCSID("$Id: dpart.c,v 1.4 2000/07/21 13:20:22 lha Exp $");
d94 2
a95 2
    ret = asprintf (&d->part, "/vicep%s", str);
    if (ret != 7) {
@


1.1.1.1
log
@Import of arla-0.35.7
@
text
@d17 6
a22 1
 * 3. Neither the name of the Institute nor the names of its contributors
d58 1
a58 7
RCSID("$KTH: dpart.c,v 1.6 2000/12/29 20:12:35 tol Exp $");

#ifdef MILKO_ROOT
char *dpart_root = MILKO_ROOT;
#else
char *dpart_root = "";
#endif
d93 2
a94 2
    ret = asprintf (&d->part, "%s/vicep%s", dpart_root, str);
    if (ret < 0) {
@


1.1.1.2
log
@Import of arla -current as of Aug 5 2003

ok todd@@ deraadt@@
@
text
@a35 2
#include <roken.h>

a39 7
#ifdef HAVE_STATVFS
#include <sys/statvfs.h>
#endif
#ifdef HAVE_STATFS_H
#include <sys/statfs.h>
#endif
#include <sys/mount.h>
d53 1
a53 1
RCSID("$arla: dpart.c,v 1.11 2002/06/02 21:12:16 lha Exp $");
d67 1
a67 1
dp_create (uint32_t num, struct dp_part **dp)
d77 1
a77 1
    if (num > (('z' - 'a') * ('z' - 'a')))
d140 1
a140 1
    uint32_t num;
d213 1
a213 1
dp_parse (const char *str, uint32_t *num)
d216 1
a216 1
    uint32_t part = 0;
d253 1
a253 1
    uint32_t part;
a263 35
}

/*
 * get available and total number of 1k blocks on partition
 */

int
dp_getstats (struct dp_part *dp, long *availblocks, long *totalblocks)
{
#ifdef HAVE_STATVFS
    struct statvfs sb;
#else
    struct statfs sb;
#endif
    int reservedblocks;
    int ret;

#ifdef HAVE_STATVFS
    ret = statvfs (dp->part, &sb);
#else
    ret = statfs (dp->part, &sb);
#endif
    if (ret)
	return errno;
    
    reservedblocks = sb.f_bfree - sb.f_bavail;
    if (sb.f_bsize <= 1024) {
	*availblocks = sb.f_bavail * (1024/sb.f_bsize);
	*totalblocks = (sb.f_blocks - reservedblocks) * (1024/sb.f_bsize);
    } else {
	*availblocks = sb.f_bavail / (sb.f_bsize/1024);
	*totalblocks = (sb.f_blocks - reservedblocks) / (sb.f_bsize/1024);
    }

    return 0;
@


