head	1.5;
access;
symbols
	OPENBSD_5_2:1.4.0.38
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.36
	OPENBSD_5_0:1.4.0.34
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.32
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.30
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.4.0.26
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.4.0.28
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.4.0.24
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.4.0.22
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.4.0.20
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.4.0.18
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.4.0.16
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.4.0.14
	OPENBSD_4_0_BASE:1.4
	OPENBSD_3_9:1.4.0.12
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.10
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.8
	OPENBSD_3_7_BASE:1.4
	OPENBSD_3_6:1.4.0.6
	OPENBSD_3_6_BASE:1.4
	OPENBSD_3_5:1.4.0.4
	OPENBSD_3_5_BASE:1.4
	OPENBSD_3_4:1.4.0.2
	OPENBSD_3_4_BASE:1.4
	arla-20030805:1.1.1.2
	OPENBSD_3_3:1.3.0.4
	OPENBSD_3_3_BASE:1.3
	OPENBSD_3_2:1.3.0.2
	OPENBSD_3_2_BASE:1.3
	arla-0-35-7:1.1.1.1
	arla:1.1.1
	OPENBSD_3_1:1.2.0.2
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.1.0.6
	OPENBSD_3_0_BASE:1.1
	OPENBSD_2_9_BASE:1.1
	OPENBSD_2_9:1.1.0.4
	OPENBSD_2_8:1.1.0.2
	OPENBSD_2_8_BASE:1.1;
locks; strict;
comment	@# @;


1.5
date	2012.08.23.06.21.52;	author deraadt;	state dead;
branches;
next	1.4;

1.4
date	2003.08.05.09.16.15;	author hin;	state Exp;
branches;
next	1.3;

1.3
date	2002.06.07.04.42.38;	author hin;	state Exp;
branches;
next	1.2;

1.2
date	2001.10.24.10.23.53;	author dhartmei;	state Exp;
branches;
next	1.1;

1.1
date	2000.09.11.14.41.16;	author art;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.06.07.04.14.32;	author hin;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.08.05.08.21.05;	author hin;	state Exp;
branches;
next	;


desc
@@


1.5
log
@the afs src tree can go away
@
text
@Ropa - callbacks
================

Thoughts by Love <lha@@stacken.kth.se>

$arla: README,v 1.3 2002/05/16 22:09:45 hin Exp $

Design
======

Think before doing. This isn't that simple. Figure out a way to do
everything in O(1) but with minimum memory requirement.

What sizes should we optimize for ? Linked list might be used for
small datasets.  W/o knowing anything, it seams many fids will have
few clients, and few fids will have many clients.

We need to have statistics. Guess we need to do it the simple way to get
statistics, and then do it the right way. KISS!

Data-storage
============

name = { contain } [ index1, index2, ... ]

client = { uuid, port, interfaceAddr, callbacks[] }
					[ interfaceAddr, uuid ( & port) ]
callback = { fid, client[] (, times[], heapptr[])  }
					[ fid ]

LRU(clients);
HEAP(callbacks);

Resolve
=======

fid -> { RW -> time(#clients), RO -> time(history) }
							[1]

fid -> clients[] \ sender-client			[2]

{callback (* time) * client} (heap) --> clients		[3]

client -> fids[]					[4]

Comments
========

Use UUID for all clients ? Cook and mark cooked for pre 3.5 clients.

[1] From a given fid we need to figure out a suitable time.

    Without thinking:

    * Callbacks on WR volumes should give
    back callback-times based on number of clients using this fid.

    * Callbacks on RO volumes should be based on how often volumes
    are released (average - (timenow() - lasttime())) * rand(10).
    The rand is to avoid fetch-storms.

[2] When breaking callbacks we need to get all clients.
    This need to be storted on UUID so we can avoid sending cb
    to the client.

[3] Should callbacks be given all to the same time, or should different
    clients have different callbacks ? Will we get fetch-storms when
    callbacks expire for wellused files (or RO volumes).

[4] We need to query the client when i contacts us the first time
    There is also need to break fids when clients fall out of the lru.

Lock order and expiration
=========================

The easy way out might be to globallock the whole module except a
expirationthread. In this module all enterence function must enter
with complete data. There must also be a way to function to match
(addr,port) -> uuid.
@


1.4
log
@Merge
@
text
@@


1.3
log
@merge
@
text
@d6 1
a6 1
$KTH: README,v 1.1 1999/11/12 04:50:19 lha Exp $
d66 2
a67 2
[3] Should callbacks be given all to the same time, or should diffrent
    clients have diffrent callbacks ? Will we get fetch-storms when
@


1.2
log
@"minium" -> "minimum", ok deraadt@@
@
text
@d6 1
a6 1
$Id: README,v 1.1 2000/09/11 14:41:16 art Exp $
@


1.1
log
@New Arla userland from Arla between 0.34.2 and current in arla cvs.
Too many new features and fixes to mention here.
@
text
@d6 1
a6 1
$Id: README,v 1.1 1999/11/12 04:50:19 lha Exp $
d12 1
a12 1
everything in O(1) but with minium memory requirement.
@


1.1.1.1
log
@Import of arla-0.35.7
@
text
@d6 1
a6 1
$KTH: README,v 1.1 1999/11/12 04:50:19 lha Exp $
@


1.1.1.2
log
@Import of arla -current as of Aug 5 2003

ok todd@@ deraadt@@
@
text
@d6 1
a6 1
$arla: README,v 1.3 2002/05/16 22:09:45 hin Exp $
d12 1
a12 1
everything in O(1) but with minimum memory requirement.
d66 2
a67 2
[3] Should callbacks be given all to the same time, or should different
    clients have different callbacks ? Will we get fetch-storms when
@


