head	1.4;
access;
symbols
	OPENBSD_5_2:1.3.0.38
	OPENBSD_5_2_BASE:1.3
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.36
	OPENBSD_5_0:1.3.0.34
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.32
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.3.0.30
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.3.0.26
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.28
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.3.0.24
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.3.0.22
	OPENBSD_4_4_BASE:1.3
	OPENBSD_4_3:1.3.0.20
	OPENBSD_4_3_BASE:1.3
	OPENBSD_4_2:1.3.0.18
	OPENBSD_4_2_BASE:1.3
	OPENBSD_4_1:1.3.0.16
	OPENBSD_4_1_BASE:1.3
	OPENBSD_4_0:1.3.0.14
	OPENBSD_4_0_BASE:1.3
	OPENBSD_3_9:1.3.0.12
	OPENBSD_3_9_BASE:1.3
	OPENBSD_3_8:1.3.0.10
	OPENBSD_3_8_BASE:1.3
	OPENBSD_3_7:1.3.0.8
	OPENBSD_3_7_BASE:1.3
	OPENBSD_3_6:1.3.0.6
	OPENBSD_3_6_BASE:1.3
	OPENBSD_3_5:1.3.0.4
	OPENBSD_3_5_BASE:1.3
	OPENBSD_3_4:1.3.0.2
	OPENBSD_3_4_BASE:1.3
	arla-20030805:1.1.1.2
	OPENBSD_3_3:1.2.0.4
	OPENBSD_3_3_BASE:1.2
	OPENBSD_3_2:1.2.0.2
	OPENBSD_3_2_BASE:1.2
	arla-0-35-7:1.1.1.1
	arla:1.1.1
	OPENBSD_3_1:1.1.0.8
	OPENBSD_3_1_BASE:1.1
	OPENBSD_3_0:1.1.0.6
	OPENBSD_3_0_BASE:1.1
	OPENBSD_2_9_BASE:1.1
	OPENBSD_2_9:1.1.0.4
	OPENBSD_2_8:1.1.0.2
	OPENBSD_2_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.4
date	2012.08.23.06.21.53;	author deraadt;	state dead;
branches;
next	1.3;

1.3
date	2003.08.05.09.16.15;	author hin;	state Exp;
branches;
next	1.2;

1.2
date	2002.06.07.04.42.38;	author hin;	state Exp;
branches;
next	1.1;

1.1
date	2000.09.11.14.41.20;	author art;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.06.07.04.14.33;	author hin;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.08.05.08.21.06;	author hin;	state Exp;
branches;
next	;


desc
@@


1.4
log
@the afs src tree can go away
@
text
@/*
 * Copyright (c) 1995 - 2001 Kungliga Tekniska Högskolan
 * (Royal Institute of Technology, Stockholm, Sweden).
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include "vldb_locl.h"

RCSID("$arla: vldbserver.c,v 1.46 2003/02/15 16:03:35 map Exp $");

/*
 * The rpc - calls
 */

int
VL_CreateEntry(struct rx_call *call, 
	       const vldbentry *newentry) 
{
    char *name;
    disk_vlentry diskentry;
    disk_vlentry tempentry;

    mlog_log (MDEBVL, "VL_CreateEntry (name=%s, ids=%d,%d,%d flags=%d)\n",
	      newentry->name,
	      newentry->volumeId[RWVOL],
	      newentry->volumeId[ROVOL],
	      newentry->volumeId[BACKVOL],
	      newentry->flags);


    if (!sec_is_superuser(call))
	return VL_PERM;

    if ((vldb_id_to_name(newentry->volumeId[RWVOL], &name) == 0) ||
	(vldb_id_to_name(newentry->volumeId[ROVOL], &name) == 0) ||
	(vldb_id_to_name(newentry->volumeId[BACKVOL], &name) == 0)) {
	free(name);
	mlog_log (MDEBVL, "VL_CreateEntry: id exists\n");
	return VL_NAMEEXIST;
    }

    if (vldb_read_entry(newentry->name, &tempentry) == 0) {
	mlog_log (MDEBVL, "VL_CreateEntry: name exists\n");
	return VL_NAMEEXIST;
    }

    vldb_entry_to_disk(newentry, &diskentry);

    if (vldb_write_entry(&diskentry) != 0)
	return VL_IO;

    if (vldb_write_id(newentry->name,
		      newentry->volumeId[RWVOL]) != 0)
	return VL_IO; /* XXX rollback */

    if (vldb_write_id(newentry->name,
		      newentry->volumeId[ROVOL]) != 0)
	return VL_IO; /* XXX rollback */

    if (vldb_write_id(newentry->name,
		      newentry->volumeId[BACKVOL]) != 0)
	return VL_IO; /* XXX rollback */

    vldb_flush();

    vldb_free_diskentry(&diskentry);

    return 0;
}

int 
VL_DeleteEntry(struct rx_call *call, 
	       const int32_t Volid, 
	       const int32_t voltype)
{
    disk_vlentry entry;
    char *name;
    int ret;

    mlog_log (MDEBVL, "VL_DeleteEntry (Volid=%d,Voltype=%d)\n", 
		  Volid, voltype);

    if (!sec_is_superuser(call)) {
	ret =  VL_PERM;
	goto out;
    }
    
    if (voltype != RWVOL &&
	voltype != ROVOL &&
	voltype != BACKVOL) {
	ret =  VL_BADVOLTYPE;
	goto out;
    }
    
    if (vldb_id_to_name(Volid, &name)) {
	ret =  VL_NOENT;
	goto out;
    }
    
    if (vldb_read_entry(name, &entry) != 0) {
	ret =  VL_NOENT;
	goto out;
    }
    
    if (entry.volumeId[voltype] != Volid) {
	ret =  VL_NOENT;
	goto out;
    }
    
    if (vldb_delete_id(name, entry.volumeId[RWVOL])) {
	mlog_log (MDEBVL, "VL_DeleteEntry failed to remove RW id %d\n",
		  entry.volumeId[RWVOL]);
	ret =  VL_IO;
	goto out;
    }
    if (vldb_delete_id(name, entry.volumeId[ROVOL])) {
	mlog_log (MDEBVL, "VL_DeleteEntry failed to remove RO id %d\n",
		  entry.volumeId[ROVOL]);
	ret =  VL_IO;
	goto out;
    }
    if (vldb_delete_id(name, entry.volumeId[BACKVOL])) {
	mlog_log (MDEBVL, "VL_DeleteEntry failed to remove BK id %d\n",
		  entry.volumeId[BACKVOL]);
	ret =  VL_IO;
	goto out;
    }
    if (vldb_delete_entry(name)) {
	mlog_log (MDEBVL, "VL_DeleteEntry failed to remove data\n");
	ret =  VL_IO;
	goto out;
    }
    
    free(name);

    vldb_flush();

    ret = 0;
    
 out:
    mlog_log (MDEBVL, "VL_DeleteEntry returns %d\n", ret);

    return ret;
}

/*
 *
 */

int
VL_GetEntryByID(struct rx_call *call,
		const int32_t Volid, 
		const int32_t voltype, 
		vldbentry *entry) 
{
    disk_vlentry diskentry;
    char *name;
    mlog_log (MDEBVL, "VL_GetEntryByID (Volid=%d,Voltype=%d)\n", 
		  Volid, voltype);

    if (vldb_id_to_name(Volid, &name))
	return VL_NOENT;

    if (vldb_read_entry(name, &diskentry) != 0)
	return VL_NOENT;

    vldb_disk_to_entry(&diskentry, entry);

    free(name);

    return 0;
}

/*
 *
 */

int
VL_GetEntryByName(struct rx_call *call, 
		  const char *volumename, 
		  vldbentry *entry) 
{
    disk_vlentry diskentry;

    mlog_log (MDEBVL, "VL_GetEntryByName (volumename = %s)\n", 
		  volumename);

    if (isdigit(volumename[0])) {
	return VL_GetEntryByID(call, atol(volumename), 0 /* XXX */, entry);
    }

    if (vldb_read_entry(volumename, &diskentry) != 0)
	return VL_NOENT;

    vldb_disk_to_entry(&diskentry, entry);
    
    return 0;
}

/*
 *
 */

int 
VL_GetNewVolumeId (struct rx_call *call, 
		   const int32_t bumpcount,
		   int32_t *newvolumid)
{
    mlog_log (MDEBVL, "VL_GetNewVolumeId(bumpcount=%d)\n", bumpcount) ;
    
    if (!sec_is_superuser(call))
	return VL_PERM;

    *newvolumid = vl_header.MaxVolumeId;
    mlog_log (MDEBVL, "   returning low volume id = %d\n", *newvolumid);
    vl_header.MaxVolumeId += bumpcount;
    vldb_write_header();

    vldb_flush();

    return 0;
}

/*
 *
 */

int
VL_ReplaceEntry (struct rx_call *call, 
		 const int32_t Volid, 
		 const int32_t voltype,
		 const vldbentry *newentry,
		 const int32_t ReleaseType) 
{
    mlog_log (MDEBVL, "VL_ReplaceEntry\n") ;

    if (!sec_is_superuser(call))
	return VL_PERM;

    return VL_PERM ;
}

/*
 *
 */

int
VL_UpdateEntry (struct rx_call *call, 
		const int32_t Volid, 
		const int32_t voltype, 
		const VldbUpdateEntry *UpdateEntry,
		const int32_t ReleaseType)
{
    mlog_log (MDEBVL, "VL_UpdateEntry\n") ;

    if (!sec_is_superuser(call))
	return VL_PERM;

    return VL_PERM ;
}

/*
 *
 */

int 
VL_SetLock (struct rx_call *call, 
	    const int32_t Volid, 
	    const int32_t voltype,
	    const int32_t voloper) 
{
    mlog_log (MDEBVL, "VL_SetLock\n") ;

    if (!sec_is_superuser(call))
	return VL_PERM;

    return 0;
}

/*
 *
 */

int
VL_ReleaseLock (struct rx_call *call, 
		const int32_t volid,
		const int32_t voltype, 
		const int32_t ReleaseType) 
{
    mlog_log (MDEBVL, "VL_ReleaseLock\n") ;

    if (!sec_is_superuser(call))
	return VL_PERM;


    return 0;
}

/*
 *
 */

int
VL_ListEntry (struct rx_call *call, 
	      const int32_t previous_index, 
	      int32_t *count,
	      int32_t *next_index, 
	      vldbentry *entry) 
{
    mlog_log (MDEBVL, "VL_ListEntry\n") ;
    return VL_PERM ;
}

/*
 *
 */

int
VL_ListAttributes (struct rx_call *call, 
		   const VldbListByAttributes *attributes,
		   int32_t *nentries,
		   bulkentries *blkentries) 
{
    mlog_log (MDEBVL, "VL_ListAttributes\n") ;
    return VL_PERM ;
}

/*
 *
 */

int
VL_GetStats (struct rx_call *call, 
	     vldstats *stats,
	     vital_vlheader *vital_header) 
{
    mlog_log (MDEBVL, "VL_GetStats") ;
    return VL_PERM ;
}

/*
 *
 */

int 
VL_Probe(struct rx_call *call)
{
    mlog_log (MDEBVL, "VL_Probe\n") ;
    return 0;
}

/*
 *
 */

int
VL_CreateEntryN(struct rx_call *call,
		const nvldbentry *entry)
{
    char *name;
    disk_vlentry diskentry;
    disk_vlentry tempentry;

    mlog_log (MDEBVL, "VL_CreateEntryN (name=%s, ids=%d,%d,%d flags=%d)\n",
	      entry->name,
	      entry->volumeId[RWVOL],
	      entry->volumeId[ROVOL],
	      entry->volumeId[BACKVOL],
	      entry->flags);

    if (!sec_is_superuser(call))
	return VL_PERM;


    if ((vldb_id_to_name(entry->volumeId[RWVOL], &name) == 0) ||
	(vldb_id_to_name(entry->volumeId[ROVOL], &name) == 0) ||
	(vldb_id_to_name(entry->volumeId[BACKVOL], &name) == 0)) {
	free(name);
	mlog_log (MDEBVL, "VL_CreateEntryN: id exists\n");
	return VL_NAMEEXIST;
    }

    if (vldb_read_entry(entry->name, &tempentry) == 0) {
	mlog_log (MDEBVL, "VL_CreateEntryN: name exists\n");
	return VL_NAMEEXIST;
    }

    vldb_nentry_to_disk(entry, &diskentry);

    if (vldb_write_entry(&diskentry) != 0)
	return VL_IO;

    if (vldb_write_id(entry->name,
		      entry->volumeId[RWVOL]) != 0)
	return VL_IO; /* XXX rollback */

    if (vldb_write_id(entry->name,
		      entry->volumeId[ROVOL]) != 0)
	return VL_IO; /* XXX rollback */

    if (vldb_write_id(entry->name,
		      entry->volumeId[BACKVOL]) != 0)
	return VL_IO; /* XXX rollback */

    vldb_free_diskentry(&diskentry);

    vldb_flush();

    return 0;
}

/*
 *
 */

int
VL_GetEntryByIDN(struct rx_call *call,
		 const int32_t Volid,
		 const int32_t voltype,
		 nvldbentry *entry)
{
    disk_vlentry diskentry;
    char *name;
    mlog_log (MDEBVL, "VL_GetEntryByIDN (Volid=%d,Voltype=%d)\n", 
	      Volid, voltype);

    if (vldb_id_to_name(Volid, &name))
	return VL_NOENT;

    if (vldb_read_entry(name, &diskentry) != 0)
	return VL_NOENT;

    vldb_disk_to_nentry(&diskentry, entry);

    free(name);

    return 0;
}

/*
 *
 */

int
VL_GetEntryByNameN(struct rx_call *call, 
		   const char *volumename, 
		   nvldbentry *entry) 
{
    disk_vlentry diskentry;

    mlog_log (MDEBVL, "VL_GetEntryByNameN (volumename = %s)\n", 
	      volumename);

    if (isdigit(volumename[0])) {
	return VL_GetEntryByIDN(call, atol(volumename), 0 /* XXX */, entry);
    }

    if (vldb_read_entry(volumename, &diskentry) != 0)
	return VL_NOENT;

    vldb_disk_to_nentry(&diskentry, entry);
    
    return 0;
}

#ifdef notyet
/*
 *
 */

int
VL_GetEntryByNameU(struct rx_call *call, 
		   const char *volumename, 
		   uvldbentry *entry) 
{
    mlog_log (MDEBVL, "VL_GetEntryByNameU %s\n", volumename);
    memset(entry, 0, sizeof(*entry));
    
    return RXGEN_OPCODE;
}
#endif

/*
 *
 */

int
VL_ListAttributesN (struct rx_call *call, 
		   const VldbListByAttributes *attributes,
		   int32_t *nentries,
		   nbulkentries *blkentries) 
{
    mlog_log (MDEBVL, "VL_ListAttributesN\n");
    mlog_log (MDEBVL, "  attributes: Mask=(%d=", attributes->Mask);

    if (attributes->Mask & VLLIST_SERVER)
	mlog_log (MDEBVL, "SERVER ");
    if (attributes->Mask & VLLIST_PARTITION)
	mlog_log (MDEBVL, "PARTITION ");
    if (attributes->Mask & VLLIST_VOLUMEID)
	mlog_log (MDEBVL, "VOLUMEID ");
    if (attributes->Mask & VLLIST_FLAG)
	mlog_log (MDEBVL, "FLAG");

    mlog_log (MDEBVL, ") server=%d partition=%d volumetype=%d volumeid=%d flag=%d\n",
	   attributes->server,
	   attributes->partition,
	   attributes->volumetype,
	   attributes->volumeid,
	   attributes->flag);

    *nentries = 1;

    blkentries->len = 0;
    blkentries->val = NULL;

    return VL_PERM;
}

#ifdef notyet
/*
 *
 */

int
VL_ListAttributesU(struct rx_call *call, 
		   const VldbListByAttributes *attributes,
		   int32_t *nentries,
		   ubulkentries *blkentries) 
{
    mlog_log (MDEBVL, "VL_ListAttributesU\n") ;
    *nentries = 0;
    blkentries->len = 0;
    blkentries->val = NULL;
    return 0;
}
#endif

/*
 *
 */

int
VL_UpdateEntryByName(struct rx_call *call,
		     const char volname[65],
		     const struct VldbUpdateEntry *UpdateEntry,
		     const int32_t ReleaseType)
{
    mlog_log (MDEBVL, "VL_UpdateEntryByName (not implemented)\n");

    if (!sec_is_superuser(call))
	return VL_PERM;

    return VL_PERM;
}

/*
 *
 */

int
VL_GetAddrsU(struct rx_call *call,
	     const struct ListAddrByAttributes *inaddr,
	     struct afsUUID *uuid,
	     int32_t *uniq,
	     int32_t *nentries,
	     bulkaddrs *addrs)
{
    mlog_log (MDEBVL, "VL_GetAddrsU (not implemented)\n");
    return RXGEN_OPCODE;
}

/*
 *
 */

int
VL_RegisterAddrs(struct rx_call *call,
		 const struct afsUUID *uid,
		 const int32_t spare,
		 const bulkaddrs *addrs)
{
    mlog_log (MDEBVL, "VL_RegistersAddrs (not implemented)\n");

    if (!sec_is_superuser(call))
	return VL_PERM;

    return 0;
}

#ifdef notyet
/*
 *
 */

int
VL_CreateEntryU(struct rx_call *call,
		const struct uvldbentry *newentry)
{
    mlog_log (MDEBVL, "VL_CreateEntryU (not implemented)\n");

    if (!sec_is_superuser(call))
	return VL_PERM;

    return VL_PERM;
}
#endif

#ifdef notyet
/*
 *
 */

int
VL_ReplaceEntryU(struct rx_call *call)
{
    mlog_log (MDEBVL, "VL_ReplaceEntryU (not implemented)\n");

    if (!sec_is_superuser(call))
	return VL_PERM;

    return VL_PERM;
}
#endif

/*
 *
 */

int
VL_ReplaceEntryN(struct rx_call *call,
		 const int32_t Volid,
		 const int32_t voltype,
		 const struct nvldbentry *newentry,
		 const int32_t ReleaseType)
{
    mlog_log (MDEBVL, "VL_ReplaceEntryN (not implemented)\n");

    if (!sec_is_superuser(call))
	return VL_PERM;

    return VL_PERM;
}

/*
 *
 */

int
VL_ChangeAddrs(struct rx_call *call,
	       const int32_t old_ip,
	       const int32_t new_ip)
{
    mlog_log (MDEBVL, "VL_ChangeAddrs (not implemented)\n");

    if (!sec_is_superuser(call))
	return VL_PERM;

    return VL_PERM;
}

#ifdef notyet
/*
 *
 */

int
VL_GetEntryByIDU(struct rx_call *call)
{
    mlog_log (MDEBVL, "VL_GetEntryByIDU (not implemented)\n");
    return VL_PERM;
}
#endif

/*
 *
 */

int
VL_ListEntryN(struct rx_call *call,
	      int32_t previous_index,
	      int32_t *count,
	      int32_t *next_index,
	      nvldbentry *entry)
{
    mlog_log (MDEBVL, "VL_ListEntryN (not implemented)\n");
    return VL_PERM;
}

#ifdef notyet
/*
 *
 */

int
VL_ListEntryU(struct rx_call *call)
{
    mlog_log (MDEBVL, "VL_ListEntryU (not implemented)\n");
    return VL_PERM;
}
#endif

/*
 *
 */

int
VL_GetAddrs(struct rx_call *call,
	    const int32_t handle,
	    const int32_t spare,
	    struct VL_Callback *spare3,
	    int32_t *nentries,
	    bulkaddrs *blkaddr)
{
    mlog_log (MDEBVL, "VL_GetAddrs (not implemented)\n");
    return VL_PERM;
}

#ifdef notyet
/*
 *
 */

int
VL_LinkedListN(struct rx_call *call)
{
    mlog_log (MDEBVL, "VL_LinkedListN (not implemented)\n");
    return VL_PERM;
}

/*
 *
 */

int
VL_LinkedListU(struct rx_call *call)
{
    mlog_log (MDEBVL, "VL_LinkedListU (not implemented)\n");
    return VL_PERM;
}
#endif

int
VL_ListAttributesN2(struct rx_call *call,
		    const struct VldbListByAttributes *attributes,
		    const char *volumename,
		    const int32_t startindex,
		    int32_t *nentries,
		    nbulkentries *blkentries,
		    int32_t *nextstartindex)
{
    mlog_log (MDEBVL, "VL_ListAttributesN2 (not implemented)\n");
    return VL_PERM;
}
/*
 *
 */

static struct rx_service *vldbservice = NULL;
static struct rx_service *ubikservice = NULL;

static char *cell = NULL;
static char *realm = NULL;
static char *srvtab_file = NULL;
static char *log_file = "syslog";
static char *debug_levels = NULL;
static int no_auth = 0;
static int do_help = 0;
static char *databasedir = NULL;
static int do_create = 0;

static struct agetargs args[] = {
    {"cell",	0, aarg_string,    &cell, "what cell to use"},
    {"realm",	0, aarg_string,	  &realm, "what realm to use"},
    {"debug",  'd', aarg_string,  &debug_levels, "debug level"},
    {"log",	'l',	aarg_string,	&log_file,
     "where to write log (stderr, syslog (default), or path to file)"},
    {"srvtab", 0, aarg_string,    &srvtab_file, "what srvtab to use"},
    {"noauth", 0,  aarg_flag,	  &no_auth, "disable authentication checks"},
    {"help",  'h', aarg_flag,      &do_help, "help"},
    {"dbdir",  0, aarg_string,    &databasedir, "where to store the db"},
    {"create",  0, aarg_flag,      &do_create, "create new database"},
    { NULL, 0, aarg_end, NULL }
};

static void
usage(int exit_code)
{
    aarg_printusage (args, NULL, "", AARG_GNUSTYLE);
    exit (exit_code);
}

int
main(int argc, char **argv) 
{
    Log_method *method;
    int optind = 0;
    int ret;
    
    set_progname (argv[0]);

    if (agetarg (args, argc, argv, &optind, AARG_GNUSTYLE)) {
	usage (1);
    }

    argc -= optind;
    argv += optind;

    if (argc) {
	printf("unknown option %s\n", *argv);
	return 1;
    }

    if (do_help)
	usage(0);

    if (no_auth)
	sec_disable_superuser_check ();

    method = log_open (getprogname(), log_file);
    if (method == NULL)
	errx (1, "log_open failed");
    cell_init(0, method);
    ports_init();

    mlog_loginit (method, milko_deb_units, MDEFAULT_LOG);

    if (debug_levels)
	mlog_log_set_level (debug_levels);

    if (cell)
	cell_setthiscell (cell);

    network_kerberos_init (srvtab_file);
    
    if (do_create) {
	vldb_create (databasedir);
	vldb_close();
	return 0;
    }

    vldb_init(databasedir);

    ret = network_init(htons(afsvldbport), "vl", VLDB_SERVICE_ID, 
		       VL_ExecuteRequest, &vldbservice, realm);
    if (ret)
	errx (1, "network_init failed with %d", ret);
    
    ret = network_init(htons(afsvldbport), "ubik", VOTE_SERVICE_ID, 
		       Ubik_ExecuteRequest, &ubikservice, realm);
    if (ret)
	errx (1, "network_init failed with %d", ret);

    printf("Milko vldbserver %s-%s started\n", PACKAGE, VERSION);

    rx_SetMaxProcs(vldbservice,5) ;
    rx_SetMaxProcs(ubikservice,5) ;
    rx_StartServer(1) ;

    abort() ; /* should not get here */
    return 0;
}
@


1.3
log
@Merge
@
text
@@


1.2
log
@merge
@
text
@d2 1
a2 1
 * Copyright (c) 1995 - 2000 Kungliga Tekniska Högskolan
d36 1
a36 26
RCSID("$KTH: vldbserver.c,v 1.33 2001/01/01 20:42:58 lha Exp $");

static void make_vldb_from_vl(struct vldbentry *vldb_entry,
			      struct disk_vlentry *vl_entry);

static void
make_vldb_from_vl(struct vldbentry *vldb_entry, struct disk_vlentry *vl_entry)
{
    int i;

    strlcpy(vldb_entry->name, vl_entry->name, VLDB_MAXNAMELEN);
    vldb_entry->volumeType = vl_entry->volumeType;
    vldb_entry->nServers = 1; /* XXX What is this supposed to be? */

    for (i = 0; i < MAXNSERVERS; i++) {
	vldb_entry->serverNumber[i] = vl_entry->serverNumber[i];
	vldb_entry->serverPartition[i] = vl_entry->serverPartition[i];
	vldb_entry->serverFlags[i] = vl_entry->serverFlags[i];
    }

    for (i = 0; i < MAXTYPES; i++)
	vldb_entry->volumeId[i] = vl_entry->volumeId[i];

    vldb_entry->cloneId = vl_entry->cloneId;
    vldb_entry->flags = vl_entry->flags;
}
d46 11
a56 3
    struct disk_vlentry vl_entry;
    int32_t nServers;
    int i;
d61 7
a67 1
    memset (&vl_entry, 0, sizeof(vl_entry));
d69 9
a77 6
    vldb_debug ("VL_CreateEntry (name=%s, type=%d, ids=%d,%d,%d flags=%d)\n",
		newentry->name, newentry->volumeType,
		newentry->volumeId[RWVOL],
		newentry->volumeId[ROVOL],
		newentry->volumeId[BACKVOL],
		newentry->flags);
d79 3
a81 2
    strlcpy(vl_entry.name, newentry->name, VLDB_MAXNAMELEN);
    vl_entry.volumeType = newentry->volumeType;
d83 3
a85 9
    /* XXX All fields mustn't be set */
    nServers = newentry->nServers;
    if (nServers > MAXNSERVERS)
	nServers = MAXNSERVERS;
    for (i = nServers - 1 ; i >= 0 ; i--) {
	vl_entry.serverNumber[i] = newentry->serverNumber[i];
	vl_entry.serverPartition[i] = newentry->serverPartition[i];
	vl_entry.serverFlags[i] = newentry->serverFlags[i];
    }    
d87 3
a89 2
    for (i = 0; i < MAXTYPES; i++)
	vl_entry.volumeId[i] = newentry->volumeId[i];
d91 3
a93 2
    vl_entry.cloneId = newentry->cloneId;
    vl_entry.flags = newentry->flags;
a94 1
    vldb_insert_entry(&vl_entry);
d103 6
a108 1
    vldb_debug ("VL_DeleteEntry\n") ;
d110 59
a168 2
    if (!sec_is_superuser(call))
	return VL_PERM;
d170 1
a170 1
    return VL_PERM ;
d183 7
a189 1
    struct disk_vlentry vl_entry;
d191 1
a191 5
    vldb_debug ("VL_GetEntryByID (Volid=%d,Voltype=%d)\n", 
		  Volid, voltype);
    
    if (vldb_get_first_id_entry(vldb_get_id_hash(Volid),
				voltype, &vl_entry) != 0)
d194 5
a198 13
    while (1) {
	/* Return entry if match found */
	if (vl_entry.volumeId[voltype] == Volid) {
	    make_vldb_from_vl(entry, &vl_entry);
	    return 0;
	}
	
	if (vl_entry.nextIdHash[voltype] == 0)
	    break;
	
	vldb_read_entry(vl_entry.nextIdHash[voltype], &vl_entry);
    }
    return VL_NOENT;
d210 1
a210 1
    struct disk_vlentry vl_entry;
d212 2
a213 1
    vldb_debug ("VL_GetEntryByName %s\n", volumename) ;
d219 2
a220 15
    if (vldb_get_first_name_entry(vldb_get_name_hash(volumename),
				  &vl_entry) == 0) {
	while (1) {
	    /* Return entry if match found */
	    if (strcmp(vl_entry.name, volumename) == 0) {
		make_vldb_from_vl(entry, &vl_entry);
		return 0;
	    }
	    
	    if (vl_entry.nextNameHash == 0)
		break;
	    
	    vldb_read_entry(vl_entry.nextNameHash, &vl_entry);
	}
    } 
d222 3
a224 1
    return VL_NOENT;
d236 1
a236 1
    vldb_debug ("VL_GetNewVolumeId(bumpcount=%d)\n", bumpcount) ;
d241 3
a243 3
    *newvolumid = vl_header.vital_header.MaxVolumeId;
    vldb_debug ("   returning low volume id = %d\n", *newvolumid);
    vl_header.vital_header.MaxVolumeId += bumpcount;
d246 2
d262 1
a262 1
    vldb_debug ("VL_ReplaceEntry\n") ;
d281 1
a281 1
    vldb_debug ("VL_UpdateEntry\n") ;
d299 1
a299 1
    vldb_debug ("VL_SetLock\n") ;
d317 1
a317 1
    vldb_debug ("VL_ReleaseLock\n") ;
d337 1
a337 1
    vldb_debug ("VL_ListEntry\n") ;
d351 1
a351 1
    vldb_debug ("VL_ListAttributes\n") ;
d364 1
a364 1
    vldb_debug ("VL_GetStats") ;
d375 1
a375 1
    vldb_debug ("VL_Probe\n") ;
d387 3
a389 2
    int i;
    struct vldbentry vldb_entry;
d391 6
a396 1
    vldb_debug ("VL_CreateEntryN\n") ;
a400 1
    memset (&vldb_entry, 0, sizeof (vldb_entry));
d402 7
a408 3
    strncpy(vldb_entry.name, entry->name, VLDB_MAXNAMELEN);
    vldb_entry.volumeType = RWVOL;
    vldb_entry.nServers = entry->nServers;
d410 3
a412 4
    for (i = 0; i < MAXNSERVERS; i++) {
	vldb_entry.serverNumber[i] = entry->serverNumber[i];
	vldb_entry.serverPartition[i] = entry->serverPartition[i];
	vldb_entry.serverFlags[i] = entry->serverFlags[i];
d415 1
a415 2
    for (i = 0; i < MAXTYPES; i++)
	vldb_entry.volumeId[i] = entry->volumeId[i];
d417 2
a418 2
    vldb_entry.cloneId = entry->cloneId;
    vldb_entry.flags = entry->flags;
d420 17
a436 1
    return VL_CreateEntry(call, &vldb_entry);
d449 4
a452 3
    struct vldbentry vldb_entry;
    int status, i;
    int32_t type = voltype;
d454 2
a455 1
    vldb_debug ("VL_GetEntryByIDN (Volid=%d,Voltype=%d)\n", Volid, type);
d457 2
a458 17
    memset (&vldb_entry, 0, sizeof(vldb_entry));

    if (type == -1)
	type = RWVOL;

    status = VL_GetEntryByID(call, Volid, type, &vldb_entry);

    if (status)
	return status;

    strlcpy(entry->name, vldb_entry.name, VLDB_MAXNAMELEN);
    entry->nServers = vldb_entry.nServers;
    for (i = 0; i < MAXNSERVERS; i++) {
	entry->serverNumber[i] = vldb_entry.serverNumber[i];
	entry->serverPartition[i] = vldb_entry.serverPartition[i];
	entry->serverFlags[i] = vldb_entry.serverFlags[i];
    }
d460 1
a460 2
    for (i = 0; i < MAXTYPES; i++)
	entry->volumeId[i] = vldb_entry.volumeId[i];
d462 1
a462 2
    entry->cloneId = vldb_entry.cloneId;
    entry->flags = vldb_entry.flags;
d476 1
a476 2
    struct vldbentry vldb_entry;
    int status, i;
d478 2
a479 1
    memset (&vldb_entry, 0, sizeof(vldb_entry));
d481 2
a482 13
    vldb_debug ("VL_GetEntryByNameN(volumename=%s)\n", volumename) ;
    status = VL_GetEntryByName(call, volumename, &vldb_entry);

    if (status)
	return status;

    memset (entry, 0, sizeof(*entry));
    strlcpy(entry->name, vldb_entry.name, VLDB_MAXNAMELEN);
    entry->nServers = vldb_entry.nServers;
    for (i = 0; i < MAXNSERVERS; i++) {
	entry->serverNumber[i] = vldb_entry.serverNumber[i];
	entry->serverPartition[i] = vldb_entry.serverPartition[i];
	entry->serverFlags[i] = vldb_entry.serverFlags[i];
d485 2
a486 5
    for (i = 0; i < MAXTYPES; i++)
	entry->volumeId[i] = vldb_entry.volumeId[i];

    entry->cloneId = vldb_entry.cloneId;
    entry->flags = vldb_entry.flags;
d488 2
d493 1
d503 1
a503 1
    vldb_debug ("VL_GetEntryByNameU %s\n", volumename);
d508 1
d520 2
a521 2
    vldb_debug ("VL_ListAttributesN\n");
    vldb_debug ("  attributes: Mask=(%d=", attributes->Mask);
d524 1
a524 1
	vldb_debug  ("SERVER ");
d526 1
a526 3
	vldb_debug  ("PARTITION ");
    if (attributes->Mask & VLLIST_VOLUMETYPE)
	vldb_debug  ("VOLUMETYPE ");
d528 1
a528 1
	vldb_debug  ("VOLUMEID ");
d530 1
a530 1
	vldb_debug  ("FLAG");
d532 1
a532 1
    vldb_debug (") server=%d partition=%d volumetype=%d volumeid=%d flag=%d\n",
d547 1
d558 1
a558 1
    vldb_debug ("VL_ListAttributesU\n") ;
d564 1
d576 1
a576 1
    vldb_debug ("VL_UpdateEntryByName (not implemented)\n");
d596 2
a597 2
    vldb_debug ("VL_GetAddrsU (not implemented)\n");
    return VL_PERM;
d610 1
a610 1
    vldb_debug ("VL_RegistersAddrs (not implemented)\n");
d618 1
d627 1
a627 1
    vldb_debug ("VL_CreateEntryU (not implemented)\n");
d634 1
d636 1
d644 1
a644 1
    vldb_debug ("VL_ReplaceEntryU (not implemented)\n");
d651 1
d661 1
a661 1
		 const struct vldbentry *newentry,
d664 1
a664 1
    vldb_debug ("VL_ReplaceEntryN (not implemented)\n");
d681 1
a681 1
    vldb_debug ("VL_ChangeAddrs (not implemented)\n");
d689 1
d697 1
a697 1
    vldb_debug ("VL_GetEntryByIDU (not implemented)\n");
d700 1
d707 5
a711 1
VL_ListEntryN(struct rx_call *call)
d713 1
a713 1
    vldb_debug ("VL_ListEntryN (not implemented)\n");
d717 1
d725 1
a725 1
    vldb_debug ("VL_ListEntryU (not implemented)\n");
d728 1
d739 1
a739 1
	    const int32_t *nentries,
d742 1
a742 1
    vldb_debug ("VL_GetAddrs (not implemented)\n");
d746 1
d754 1
a754 1
    vldb_debug ("VL_LinkedListN (not implemented)\n");
d765 1
a765 1
    vldb_debug ("VL_LinkedListU (not implemented)\n");
d768 1
d770 12
a781 1

a790 1
static char *databasedir = NULL;
d793 1
d795 2
a797 1
static int vlsrv_debug = 0;
a799 1
    {"create",  0, aarg_flag,      &do_create, "create new database"},
d802 4
a805 1
    {"prefix",'p', aarg_string,    &databasedir, "what dir to store the db"},
d807 3
a809 3
    {"debug", 'd', aarg_flag,      &vlsrv_debug, "output debugging"},
    {"log",   'd', aarg_string,    &log_file, "log file"},
    {"srvtab",'s', aarg_string,    &srvtab_file, "what srvtab to use"},
d814 1
a814 1
usage(void)
d816 2
a817 1
    aarg_printusage(args, NULL, "", AARG_AFSSTYLE);
d829 2
a830 3
    if (agetarg (args, argc, argv, &optind, AARG_AFSSTYLE)) {
	usage ();
	return 1;
d841 2
a842 2
    if (vlsrv_debug)
	vldb_setdebug (vlsrv_debug);
d847 1
a847 6
    if (do_create) {
	vldb_create (databasedir);
	return 0;
    }
	
    method = log_open (get_progname(), log_file);
d853 4
d863 6
@


1.1
log
@New Arla userland from Arla between 0.34.2 and current in arla cvs.
Too many new features and fixes to mention here.
@
text
@d17 1
a17 6
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by the Kungliga Tekniska
 *      Högskolan and its contributors.
 * 
 * 4. Neither the name of the Institute nor the names of its contributors
d36 1
a36 1
RCSID("$Id: vldbserver.c,v 1.28 2000/08/16 23:18:48 tol Exp $");
d734 1
d739 10
a748 9
static struct getargs args[] = {
    {"create",  0, arg_flag,      &do_create, "create new database"},
    {"cell",	0, arg_string,    &cell, "what cell to use"},
    {"realm",	0, arg_string,	  &realm, "what realm to use"},
    {"prefix",'p', arg_string,    &databasedir, "what dir to store the db"},
    {"noauth", 0,  arg_flag,	  &no_auth, "disable authentication checks"},
    {"debug", 'd', arg_flag,      &vlsrv_debug, "output debugging"},
    {"srvtab",'s', arg_string,    &srvtab_file, "what srvtab to use"},
    { NULL, 0, arg_end, NULL }
d754 1
a754 1
    arg_printusage(args, NULL, "", ARG_AFSSTYLE);
d760 2
a762 1
    int optind = 0;
d766 1
a766 1
    if (getarg (args, argc, argv, &optind, ARG_AFSSTYLE)) {
d790 4
d795 1
a795 1
    cell_init(0);
d810 1
a810 1
		       Ubik_ExecuteRequest, &ubikservice, NULL);
@


1.1.1.1
log
@Import of arla-0.35.7
@
text
@d17 6
a22 1
 * 3. Neither the name of the Institute nor the names of its contributors
d41 1
a41 1
RCSID("$KTH: vldbserver.c,v 1.33 2001/01/01 20:42:58 lha Exp $");
a738 1
static char *log_file = "syslog";
d743 9
a751 10
static struct agetargs args[] = {
    {"create",  0, aarg_flag,      &do_create, "create new database"},
    {"cell",	0, aarg_string,    &cell, "what cell to use"},
    {"realm",	0, aarg_string,	  &realm, "what realm to use"},
    {"prefix",'p', aarg_string,    &databasedir, "what dir to store the db"},
    {"noauth", 0,  aarg_flag,	  &no_auth, "disable authentication checks"},
    {"debug", 'd', aarg_flag,      &vlsrv_debug, "output debugging"},
    {"log",   'd', aarg_string,    &log_file, "log file"},
    {"srvtab",'s', aarg_string,    &srvtab_file, "what srvtab to use"},
    { NULL, 0, aarg_end, NULL }
d757 1
a757 1
    aarg_printusage(args, NULL, "", AARG_AFSSTYLE);
d763 1
a763 1
    Log_method *method;
a764 1
    int ret;
d768 1
a768 1
    if (agetarg (args, argc, argv, &optind, AARG_AFSSTYLE)) {
a791 4
    method = log_open (get_progname(), log_file);
    if (method == NULL)
	errx (1, "log_open failed");
    cell_init(0, method);
d793 1
a793 1

d808 1
a808 1
		       Ubik_ExecuteRequest, &ubikservice, realm);
@


1.1.1.2
log
@Import of arla -current as of Aug 5 2003

ok todd@@ deraadt@@
@
text
@d2 1
a2 1
 * Copyright (c) 1995 - 2001 Kungliga Tekniska Högskolan
d36 26
a61 1
RCSID("$arla: vldbserver.c,v 1.46 2003/02/15 16:03:35 map Exp $");
d71 3
a73 11
    char *name;
    disk_vlentry diskentry;
    disk_vlentry tempentry;

    mlog_log (MDEBVL, "VL_CreateEntry (name=%s, ids=%d,%d,%d flags=%d)\n",
	      newentry->name,
	      newentry->volumeId[RWVOL],
	      newentry->volumeId[ROVOL],
	      newentry->volumeId[BACKVOL],
	      newentry->flags);

d78 1
a78 7
    if ((vldb_id_to_name(newentry->volumeId[RWVOL], &name) == 0) ||
	(vldb_id_to_name(newentry->volumeId[ROVOL], &name) == 0) ||
	(vldb_id_to_name(newentry->volumeId[BACKVOL], &name) == 0)) {
	free(name);
	mlog_log (MDEBVL, "VL_CreateEntry: id exists\n");
	return VL_NAMEEXIST;
    }
d80 6
a85 9
    if (vldb_read_entry(newentry->name, &tempentry) == 0) {
	mlog_log (MDEBVL, "VL_CreateEntry: name exists\n");
	return VL_NAMEEXIST;
    }

    vldb_entry_to_disk(newentry, &diskentry);

    if (vldb_write_entry(&diskentry) != 0)
	return VL_IO;
d87 2
a88 3
    if (vldb_write_id(newentry->name,
		      newentry->volumeId[RWVOL]) != 0)
	return VL_IO; /* XXX rollback */
d90 9
a98 3
    if (vldb_write_id(newentry->name,
		      newentry->volumeId[ROVOL]) != 0)
	return VL_IO; /* XXX rollback */
d100 2
a101 3
    if (vldb_write_id(newentry->name,
		      newentry->volumeId[BACKVOL]) != 0)
	return VL_IO; /* XXX rollback */
d103 2
a104 3
    vldb_flush();

    vldb_free_diskentry(&diskentry);
d106 1
d115 1
a115 3
    disk_vlentry entry;
    char *name;
    int ret;
d117 2
a118 2
    mlog_log (MDEBVL, "VL_DeleteEntry (Volid=%d,Voltype=%d)\n", 
		  Volid, voltype);
d120 1
a120 61
    if (!sec_is_superuser(call)) {
	ret =  VL_PERM;
	goto out;
    }
    
    if (voltype != RWVOL &&
	voltype != ROVOL &&
	voltype != BACKVOL) {
	ret =  VL_BADVOLTYPE;
	goto out;
    }
    
    if (vldb_id_to_name(Volid, &name)) {
	ret =  VL_NOENT;
	goto out;
    }
    
    if (vldb_read_entry(name, &entry) != 0) {
	ret =  VL_NOENT;
	goto out;
    }
    
    if (entry.volumeId[voltype] != Volid) {
	ret =  VL_NOENT;
	goto out;
    }
    
    if (vldb_delete_id(name, entry.volumeId[RWVOL])) {
	mlog_log (MDEBVL, "VL_DeleteEntry failed to remove RW id %d\n",
		  entry.volumeId[RWVOL]);
	ret =  VL_IO;
	goto out;
    }
    if (vldb_delete_id(name, entry.volumeId[ROVOL])) {
	mlog_log (MDEBVL, "VL_DeleteEntry failed to remove RO id %d\n",
		  entry.volumeId[ROVOL]);
	ret =  VL_IO;
	goto out;
    }
    if (vldb_delete_id(name, entry.volumeId[BACKVOL])) {
	mlog_log (MDEBVL, "VL_DeleteEntry failed to remove BK id %d\n",
		  entry.volumeId[BACKVOL]);
	ret =  VL_IO;
	goto out;
    }
    if (vldb_delete_entry(name)) {
	mlog_log (MDEBVL, "VL_DeleteEntry failed to remove data\n");
	ret =  VL_IO;
	goto out;
    }
    
    free(name);

    vldb_flush();

    ret = 0;
    
 out:
    mlog_log (MDEBVL, "VL_DeleteEntry returns %d\n", ret);

    return ret;
d133 3
a135 3
    disk_vlentry diskentry;
    char *name;
    mlog_log (MDEBVL, "VL_GetEntryByID (Volid=%d,Voltype=%d)\n", 
d137 3
a139 2

    if (vldb_id_to_name(Volid, &name))
d142 13
a154 8
    if (vldb_read_entry(name, &diskentry) != 0)
	return VL_NOENT;

    vldb_disk_to_entry(&diskentry, entry);

    free(name);

    return 0;
d166 1
a166 1
    disk_vlentry diskentry;
d168 1
a168 2
    mlog_log (MDEBVL, "VL_GetEntryByName (volumename = %s)\n", 
		  volumename);
d174 15
a188 2
    if (vldb_read_entry(volumename, &diskentry) != 0)
	return VL_NOENT;
d190 1
a190 3
    vldb_disk_to_entry(&diskentry, entry);
    
    return 0;
d202 1
a202 1
    mlog_log (MDEBVL, "VL_GetNewVolumeId(bumpcount=%d)\n", bumpcount) ;
d207 3
a209 3
    *newvolumid = vl_header.MaxVolumeId;
    mlog_log (MDEBVL, "   returning low volume id = %d\n", *newvolumid);
    vl_header.MaxVolumeId += bumpcount;
a211 2
    vldb_flush();

d226 1
a226 1
    mlog_log (MDEBVL, "VL_ReplaceEntry\n") ;
d245 1
a245 1
    mlog_log (MDEBVL, "VL_UpdateEntry\n") ;
d263 1
a263 1
    mlog_log (MDEBVL, "VL_SetLock\n") ;
d281 1
a281 1
    mlog_log (MDEBVL, "VL_ReleaseLock\n") ;
d301 1
a301 1
    mlog_log (MDEBVL, "VL_ListEntry\n") ;
d315 1
a315 1
    mlog_log (MDEBVL, "VL_ListAttributes\n") ;
d328 1
a328 1
    mlog_log (MDEBVL, "VL_GetStats") ;
d339 1
a339 1
    mlog_log (MDEBVL, "VL_Probe\n") ;
d351 2
a352 3
    char *name;
    disk_vlentry diskentry;
    disk_vlentry tempentry;
d354 1
a354 6
    mlog_log (MDEBVL, "VL_CreateEntryN (name=%s, ids=%d,%d,%d flags=%d)\n",
	      entry->name,
	      entry->volumeId[RWVOL],
	      entry->volumeId[ROVOL],
	      entry->volumeId[BACKVOL],
	      entry->flags);
d359 1
d361 3
a363 7
    if ((vldb_id_to_name(entry->volumeId[RWVOL], &name) == 0) ||
	(vldb_id_to_name(entry->volumeId[ROVOL], &name) == 0) ||
	(vldb_id_to_name(entry->volumeId[BACKVOL], &name) == 0)) {
	free(name);
	mlog_log (MDEBVL, "VL_CreateEntryN: id exists\n");
	return VL_NAMEEXIST;
    }
d365 4
a368 3
    if (vldb_read_entry(entry->name, &tempentry) == 0) {
	mlog_log (MDEBVL, "VL_CreateEntryN: name exists\n");
	return VL_NAMEEXIST;
d371 2
a372 1
    vldb_nentry_to_disk(entry, &diskentry);
d374 2
a375 2
    if (vldb_write_entry(&diskentry) != 0)
	return VL_IO;
d377 1
a377 17
    if (vldb_write_id(entry->name,
		      entry->volumeId[RWVOL]) != 0)
	return VL_IO; /* XXX rollback */

    if (vldb_write_id(entry->name,
		      entry->volumeId[ROVOL]) != 0)
	return VL_IO; /* XXX rollback */

    if (vldb_write_id(entry->name,
		      entry->volumeId[BACKVOL]) != 0)
	return VL_IO; /* XXX rollback */

    vldb_free_diskentry(&diskentry);

    vldb_flush();

    return 0;
d390 3
a392 4
    disk_vlentry diskentry;
    char *name;
    mlog_log (MDEBVL, "VL_GetEntryByIDN (Volid=%d,Voltype=%d)\n", 
	      Volid, voltype);
d394 11
a404 2
    if (vldb_id_to_name(Volid, &name))
	return VL_NOENT;
d406 7
a412 2
    if (vldb_read_entry(name, &diskentry) != 0)
	return VL_NOENT;
d414 2
a415 1
    vldb_disk_to_nentry(&diskentry, entry);
d417 2
a418 1
    free(name);
d432 7
a438 1
    disk_vlentry diskentry;
d440 2
a441 2
    mlog_log (MDEBVL, "VL_GetEntryByNameN (volumename = %s)\n", 
	      volumename);
d443 7
a449 2
    if (isdigit(volumename[0])) {
	return VL_GetEntryByIDN(call, atol(volumename), 0 /* XXX */, entry);
d452 5
a456 2
    if (vldb_read_entry(volumename, &diskentry) != 0)
	return VL_NOENT;
a457 2
    vldb_disk_to_nentry(&diskentry, entry);
    
a460 1
#ifdef notyet
d470 1
a470 1
    mlog_log (MDEBVL, "VL_GetEntryByNameU %s\n", volumename);
a474 1
#endif
d486 2
a487 2
    mlog_log (MDEBVL, "VL_ListAttributesN\n");
    mlog_log (MDEBVL, "  attributes: Mask=(%d=", attributes->Mask);
d490 1
a490 1
	mlog_log (MDEBVL, "SERVER ");
d492 3
a494 1
	mlog_log (MDEBVL, "PARTITION ");
d496 1
a496 1
	mlog_log (MDEBVL, "VOLUMEID ");
d498 1
a498 1
	mlog_log (MDEBVL, "FLAG");
d500 1
a500 1
    mlog_log (MDEBVL, ") server=%d partition=%d volumetype=%d volumeid=%d flag=%d\n",
a514 1
#ifdef notyet
d525 1
a525 1
    mlog_log (MDEBVL, "VL_ListAttributesU\n") ;
a530 1
#endif
d542 1
a542 1
    mlog_log (MDEBVL, "VL_UpdateEntryByName (not implemented)\n");
d562 2
a563 2
    mlog_log (MDEBVL, "VL_GetAddrsU (not implemented)\n");
    return RXGEN_OPCODE;
d576 1
a576 1
    mlog_log (MDEBVL, "VL_RegistersAddrs (not implemented)\n");
a583 1
#ifdef notyet
d592 1
a592 1
    mlog_log (MDEBVL, "VL_CreateEntryU (not implemented)\n");
a598 1
#endif
a599 1
#ifdef notyet
d607 1
a607 1
    mlog_log (MDEBVL, "VL_ReplaceEntryU (not implemented)\n");
a613 1
#endif
d623 1
a623 1
		 const struct nvldbentry *newentry,
d626 1
a626 1
    mlog_log (MDEBVL, "VL_ReplaceEntryN (not implemented)\n");
d643 1
a643 1
    mlog_log (MDEBVL, "VL_ChangeAddrs (not implemented)\n");
a650 1
#ifdef notyet
d658 1
a658 1
    mlog_log (MDEBVL, "VL_GetEntryByIDU (not implemented)\n");
a660 1
#endif
d667 1
a667 5
VL_ListEntryN(struct rx_call *call,
	      int32_t previous_index,
	      int32_t *count,
	      int32_t *next_index,
	      nvldbentry *entry)
d669 1
a669 1
    mlog_log (MDEBVL, "VL_ListEntryN (not implemented)\n");
a672 1
#ifdef notyet
d680 1
a680 1
    mlog_log (MDEBVL, "VL_ListEntryU (not implemented)\n");
a682 1
#endif
d693 1
a693 1
	    int32_t *nentries,
d696 1
a696 1
    mlog_log (MDEBVL, "VL_GetAddrs (not implemented)\n");
a699 1
#ifdef notyet
d707 1
a707 1
    mlog_log (MDEBVL, "VL_LinkedListN (not implemented)\n");
d718 1
a718 1
    mlog_log (MDEBVL, "VL_LinkedListU (not implemented)\n");
a720 1
#endif
d722 1
a722 12
int
VL_ListAttributesN2(struct rx_call *call,
		    const struct VldbListByAttributes *attributes,
		    const char *volumename,
		    const int32_t startindex,
		    int32_t *nentries,
		    nbulkentries *blkentries,
		    int32_t *nextstartindex)
{
    mlog_log (MDEBVL, "VL_ListAttributesN2 (not implemented)\n");
    return VL_PERM;
}
d732 1
a734 1
static char *debug_levels = NULL;
a735 2
static int do_help = 0;
static char *databasedir = NULL;
d737 1
d740 1
d743 1
a743 4
    {"debug",  'd', aarg_string,  &debug_levels, "debug level"},
    {"log",	'l',	aarg_string,	&log_file,
     "where to write log (stderr, syslog (default), or path to file)"},
    {"srvtab", 0, aarg_string,    &srvtab_file, "what srvtab to use"},
d745 3
a747 3
    {"help",  'h', aarg_flag,      &do_help, "help"},
    {"dbdir",  0, aarg_string,    &databasedir, "where to store the db"},
    {"create",  0, aarg_flag,      &do_create, "create new database"},
d752 1
a752 1
usage(int exit_code)
d754 1
a754 2
    aarg_printusage (args, NULL, "", AARG_GNUSTYLE);
    exit (exit_code);
d766 3
a768 2
    if (agetarg (args, argc, argv, &optind, AARG_GNUSTYLE)) {
	usage (1);
d779 2
a780 2
    if (do_help)
	usage(0);
d785 6
a790 1
    method = log_open (getprogname(), log_file);
a795 4
    mlog_loginit (method, milko_deb_units, MDEFAULT_LOG);

    if (debug_levels)
	mlog_log_set_level (debug_levels);
a801 6
    if (do_create) {
	vldb_create (databasedir);
	vldb_close();
	return 0;
    }

@


