head	1.4;
access;
symbols
	OPENBSD_5_2:1.3.0.38
	OPENBSD_5_2_BASE:1.3
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.36
	OPENBSD_5_0:1.3.0.34
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.32
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.3.0.30
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.3.0.26
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.28
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.3.0.24
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.3.0.22
	OPENBSD_4_4_BASE:1.3
	OPENBSD_4_3:1.3.0.20
	OPENBSD_4_3_BASE:1.3
	OPENBSD_4_2:1.3.0.18
	OPENBSD_4_2_BASE:1.3
	OPENBSD_4_1:1.3.0.16
	OPENBSD_4_1_BASE:1.3
	OPENBSD_4_0:1.3.0.14
	OPENBSD_4_0_BASE:1.3
	OPENBSD_3_9:1.3.0.12
	OPENBSD_3_9_BASE:1.3
	OPENBSD_3_8:1.3.0.10
	OPENBSD_3_8_BASE:1.3
	OPENBSD_3_7:1.3.0.8
	OPENBSD_3_7_BASE:1.3
	OPENBSD_3_6:1.3.0.6
	OPENBSD_3_6_BASE:1.3
	OPENBSD_3_5:1.3.0.4
	OPENBSD_3_5_BASE:1.3
	OPENBSD_3_4:1.3.0.2
	OPENBSD_3_4_BASE:1.3
	arla-20030805:1.1.1.2
	OPENBSD_3_3:1.2.0.4
	OPENBSD_3_3_BASE:1.2
	OPENBSD_3_2:1.2.0.2
	OPENBSD_3_2_BASE:1.2
	arla-0-35-7:1.1.1.1
	arla:1.1.1
	OPENBSD_3_1:1.1.0.8
	OPENBSD_3_1_BASE:1.1
	OPENBSD_3_0:1.1.0.6
	OPENBSD_3_0_BASE:1.1
	OPENBSD_2_9_BASE:1.1
	OPENBSD_2_9:1.1.0.4
	OPENBSD_2_8:1.1.0.2
	OPENBSD_2_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.4
date	2012.08.23.06.21.52;	author deraadt;	state dead;
branches;
next	1.3;

1.3
date	2003.08.05.09.16.15;	author hin;	state Exp;
branches;
next	1.2;

1.2
date	2002.06.07.04.42.38;	author hin;	state Exp;
branches;
next	1.1;

1.1
date	2000.09.11.14.41.13;	author art;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.06.07.04.14.31;	author hin;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.08.05.08.21.05;	author hin;	state Exp;
branches;
next	;


desc
@@


1.4
log
@the afs src tree can go away
@
text
@/*
 * Copyright (c) 1999 - 2002 Kungliga Tekniska Högskolan
 * (Royal Institute of Technology, Stockholm, Sweden).
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include "fsrv_locl.h"

RCSID("$arla: volprocs.c,v 1.19 2002/09/08 04:56:15 ahltorp Exp $");

/*
 * exit debug logging
 */

#define VOLSER_EXIT  mlog_log(MDEBVOLDB, __FUNCTION__ " error: %s(%d)", koerr_gettext(ret), ret)

/*
 * Helper function
 */

static int
volser_fetch_vh (int32_t partition, int32_t volid, 
		 struct dp_part **dp, volume_handle **vh)
{
    int ret;

    ret = dp_create (partition, dp);
    if (ret) {
	fprintf (stderr, "volser_fetch_vh: dp_create: %d\n", ret);
	return VOLSERILLEGAL_PARTITION;
    }

    ret = vld_open_volume_by_num (*dp, volid, vh);
    if (ret) {
	fprintf (stderr, "volser_fetch_vh: vld_open_volume_by_num: %d\n", ret);
	dp_free (*dp);
	if (ret == ENOENT)
	    return VNOVOL;
	return ret;
    }
    
    ret = vld_info_uptodatep (*vh);
    if (ret) {
	printf ("volser_fetch_vh: vld_info_uptodatep: %d\n", ret);
	vld_free (*vh);
	dp_free (*dp);
	return VOLSERFAILEDOP; /* XXX */
    }
    return 0;
}

/*
 *
 */

int
VOLSER_AFSVolCreateVolume(struct rx_call *call,
			  const int32_t partition,
			  const char *name,
			  const int32_t type,
			  const int32_t parent,
			  int32_t *volid,
			  int32_t *trans)
{
    int ret = 0;
    int32_t backstoretype = VLD_SVOL;
    struct dp_part *dp;

    mlog_log(MDEBVOLDB, "VOLSER_AFSVolCreateVolume"
	     " part %d name %s type %d parent %d volid %u",
	     partition, name, type, parent, *volid);

    if (!sec_is_superuser(call)) {
	ret = VOLSERBAD_ACCESS;
	goto out;
    }

    /* XXX parent should be used */

    ret = vld_create_trans (partition, *volid, trans);

    if (ret)
	goto out;

    ret = vld_trans_set_iflags (*trans, ITCreate);
    if (ret)
	goto out;

    ret = dp_create (partition, &dp);
    if (ret) {
	vld_end_trans (*trans, NULL);
	goto out;
    }

    ret = vld_create_volume (dp, *volid, name, backstoretype, type, 0);
    if (ret) {
	vld_end_trans (*trans, NULL);
	goto out;
    }

 out:
    VOLSER_EXIT;
    
    return ret;
}

/*
 *
 */

int
VOLSER_AFSVolDeleteVolume(struct rx_call *call,
			  const int32_t transid)
{
    int ret = 0;
    int32_t backstoretype = VLD_SVOL;
    struct trans *trans;
    struct dp_part *dp;

    mlog_log(MDEBVOLDB, "VOLSER_AFSVolDeleteVolume");

    if (!sec_is_superuser(call)) {
	ret = VOLSERBAD_ACCESS;
	goto out;
    }

    ret = vld_verify_trans(transid);
    if (ret)
	goto out;

    ret = vld_get_trans(transid, &trans);
    if (ret)
	goto out;

    ret = dp_create (trans->partition, &dp);
    if (ret) {
	vld_put_trans (trans);
	goto out;
    }

    ret = vld_delete_volume (dp, trans->volid, backstoretype, 0);

    vld_put_trans(trans);

 out:
    VOLSER_EXIT;
    
    return ret;
}

/*
 *
 */

int
VOLSER_AFSVolNukeVolume(struct rx_call *call,
			const int32_t partID,
			const int32_t volID)
{
    int ret = 0;

    mlog_log(MDEBVOLDB, "VOLSER_AFSVolNukeVolume");

    if (!sec_is_superuser(call)) {
	ret = VOLSERBAD_ACCESS;
	goto out;
    }

    ret = VOLSERFAILEDOP;

 out:
    VOLSER_EXIT;
    
    return ret;
}

/*
 *
 */

int
VOLSER_AFSVolDump(struct rx_call *call,
		  const int32_t fromTrans,
		  const int32_t fromDate)
{
    int ret = 0;
    struct trans *trans;
    struct dp_part *dp;
    volume_handle *vh;

    mlog_log (MDEBVOLDB, 
	      "VOLSER_AFSVolDump: trans %d fromdate %d", 
	      fromTrans, fromDate);
    
    if (!sec_is_superuser(call)) {
	ret = VOLSERBAD_ACCESS;
	goto out;
    }

    ret = vld_verify_trans (fromTrans);
    if (ret)
	goto out;

    ret = vld_get_trans (fromTrans, &trans);
    if (ret)
	goto out;
    
    ret = volser_fetch_vh (trans->partition, trans->volid, &dp, &vh);
    if (ret) {
	vld_put_trans(trans);
	goto out;
    }

    if (fromDate != 0) {
	vld_put_trans(trans);
	ret = VOLSERFAILEDOP;
	goto out;
    }

    ret = generate_dump(call, vh);

    vld_put_trans (trans);

 out:
    VOLSER_EXIT;
    
    return ret;
}

/*
 *
 */

int
VOLSER_AFSVolSignalRestore(struct rx_call *call,
			   const char *name,
			   const int32_t type,
			   const int32_t pid,
			   const int32_t cloneid)
{
    int ret = 0;

    mlog_log(MDEBVOLDB, "VOLSER_AFSVolSignalRestore");

    if (!sec_is_superuser(call)) {
	ret = VOLSERBAD_ACCESS;
	goto out;
    }

    ret = VOLSERFAILEDOP;

 out:
    VOLSER_EXIT;
    
    return ret;
}

/*
 *
 */

int
VOLSER_AFSVolRestore(struct rx_call *call,
		     const int32_t transid,
		     const int32_t flags,
		     const struct restoreCookie *cookie)
{
    int ret = 0;
    struct trans *trans;
    struct dp_part *dp;
    volume_handle *vh;

    mlog_log(MDEBVOLDB, "VOLSER_AFSVolRestore");

    if (!sec_is_superuser(call)) {
	ret = VOLSERBAD_ACCESS;
	goto out;
    }

    ret = vld_verify_trans(transid);
    if (ret)
	goto out;

    ret = vld_get_trans(transid, &trans);
    if (ret)
	goto out;
    
    ret = volser_fetch_vh (trans->partition, trans->volid, &dp, &vh);
    if (ret) {
	vld_put_trans(trans);
	goto out;
    }

    ret = parse_dump(call, vh);
    if (ret) {
	vld_free (vh);
	dp_free (dp);
	vld_put_trans(trans);
	goto out;
    }

    ret = vld_rebuild(vh);

    vld_info_write(vh);

    vld_free (vh);
    dp_free (dp);

    vld_put_trans(trans);

 out:
    VOLSER_EXIT;
    
    return ret;
}

/*
 *
 */

int
VOLSER_AFSVolForward(struct rx_call *call,
		     const int32_t fromTrans,
		     const int32_t fromData,
		     const struct destServer *destination,
		     const int32_t destTrans,
		     const struct restoreCookie *cookie)
{
    int ret = 0;

    mlog_log(MDEBVOLDB, "VOLSER_AFSVolForward");

    if (!sec_is_superuser(call)) {
	ret = VOLSERBAD_ACCESS;
	goto out;
    }

    ret = VOLSERFAILEDOP;

 out:
    VOLSER_EXIT;
    
    return ret;
}

/*
 *
 */

int
VOLSER_AFSVolClone(struct rx_call *call,
		   const int32_t trans,
		   const int32_t purgeVol,
		   const int32_t newType,
		   const char *newName,
		   int32_t *newVol)
{
    int ret = 0;

    mlog_log(MDEBVOLDB, "VOLSER_AFSVolClone"
	     " trans %d purgevol %d newtype %d newname %d",
	     trans, purgeVol, newType, newName);

    if (!sec_is_superuser(call)) {
	ret = VOLSERBAD_ACCESS;
	goto out;
    }

    ret = VOLSERFAILEDOP;

 out:
    VOLSER_EXIT;
    
    return ret;
}

/*
 *
 */

int
VOLSER_AFSVolReClone(struct rx_call *call,
		     const int32_t tid,
		     const int32_t cloneID)
{
    int ret = 0;

    mlog_log(MDEBVOLDB, "VOLSER_AFSVolReClone");

    if (!sec_is_superuser(call)) {
	ret = VOLSERBAD_ACCESS;
	goto out;
    }

    ret = VOLSERFAILEDOP;

 out:
    VOLSER_EXIT;
    
    return ret;
}

/*
 *
 */

int
VOLSER_AFSVolSetForwarding(struct rx_call *call,
			   const int32_t tid,
			   const int32_t newsite)
{
    int ret = 0;

    mlog_log(MDEBVOLDB, "VOLSER_AFSVolSetForwarding");

    if (!sec_is_superuser(call)) {
	ret = VOLSERBAD_ACCESS;
	goto out;
    }

    ret = VOLSERFAILEDOP;

 out:
    VOLSER_EXIT;
    
    return ret;
}

/*
 *
 */

int
VOLSER_AFSVolTransCreate(struct rx_call *call,
			 const int32_t volume,
			 const int32_t partition,
			 const int32_t flags,
			 int32_t *trans)
{
    int ret = 0;
    struct dp_part *dp;
    volume_handle *vh;

    mlog_log(MDEBVOLDB, "VOLSER_AFSVolTransCreate");

    if (!sec_is_superuser(call)) {
	ret = VOLSERBAD_ACCESS;
	goto out;
    }

    ret = volser_fetch_vh (partition, volume, &dp, &vh);
    if (ret)
	goto out;

    vld_free (vh);
    dp_free (dp);

    ret = vld_create_trans(partition, volume, trans);
    if (ret)
	goto out;

    ret = vld_trans_set_iflags(*trans, flags);
    if (ret) {
	vld_end_trans (*trans, NULL);
	goto out;
    }

 out:
    VOLSER_EXIT;
    
    return ret;
}

/*
 *
 */

int
VOLSER_AFSVolEndTrans(struct rx_call *call,
		      const int32_t transid,
		      int32_t *rcode)
{
    struct trans *trans;
    int ret = 0;

    mlog_log(MDEBVOLDB, "VOLSER_AFSVolEndTrans trans %d", transid);

    if (!sec_is_superuser(call)) {
	ret = VOLSERBAD_ACCESS;
	goto out;
    }

    ret = vld_verify_trans(transid);
    if (ret) 
	goto out;

    ret = vld_get_trans(transid, &trans);
    if (ret)
	goto out;

    ropa_break_volume_callback(trans->volid); /* XXX */

    vld_put_trans(trans);

    ret = vld_end_trans(transid, rcode);
    if (ret)
	goto out;

 out:
    mlog_log(MDEBVOLDB, "VOLSER_AFSVolEndTrans returns %d", ret);

    return ret;
}

/*
 *
 */

int
VOLSER_AFSVolGetFlags(struct rx_call *call,
		      const int32_t trans,
		      int32_t *flags)
{
    int ret = 0;

    mlog_log(MDEBVOLDB, "VOLSER_AFSVolGetFlags");

    if (!sec_is_superuser(call)) {
	ret = VOLSERBAD_ACCESS;
	goto out;
    }

    ret = vld_verify_trans(trans);
    if (ret)
	goto out;

    ret = vld_trans_get_vflags(trans, flags);
    if (ret)
	goto out;

 out:
    VOLSER_EXIT;
    
    return ret;
}

/*
 *
 */

int
VOLSER_AFSVolSetFlags(struct rx_call *call,
		      const int32_t transid,
		      const int32_t flags)
{
    int ret = 0;
    struct trans *trans;
    struct dp_part *dp;
    volume_handle *vh;

    mlog_log(MDEBVOLDB, "VOLSER_AFSVolSetFlags"
	     " trans %d flags %d", transid, flags);

    if (!sec_is_superuser(call)) {
	ret = VOLSERBAD_ACCESS;
	goto out;
    }

    ret = vld_verify_trans(transid);
    if (ret)
	goto out;

    ret = vld_get_trans(transid, &trans);
    if (ret)
	goto out;
    
    ret = volser_fetch_vh (trans->partition, trans->volid, &dp, &vh);
    if (ret) {
	vld_put_trans(trans);
	goto out;
    }

    if (flags & VTDeleteOnSalvage)
	vh->info.destroyMe = 's';
    else
	vh->info.destroyMe = 0;

#if 0
    assert ((flags & VTOutOfService) == 0); /* XXX */
#endif

    vld_info_write(vh);

    vld_free (vh);
    dp_free (dp);

    vld_put_trans(trans);

    ret = vld_trans_set_vflags(transid, flags);
    if (ret)
	goto out;

 out:
    VOLSER_EXIT;
    
    return ret;
}

/*
 *
 */

int
VOLSER_AFSVolGetName(struct rx_call *call,
		     const int32_t tid,
		     char tname[256])
{
    int ret = 0;

    mlog_log(MDEBVOLDB, "VOLSER_AFSVolGetName");

    if (!sec_is_superuser(call)) {
	ret = VOLSERBAD_ACCESS;
	goto out;
    }

    ret = VOLSERFAILEDOP;

 out:
    VOLSER_EXIT;
    
    return ret;
}

/*
 *
 */

int
VOLSER_AFSVolGetStatus(struct rx_call *call,
		       const int32_t transid,
		       struct volser_status *status)
{
    int ret = 0;
    struct trans *trans;
    struct dp_part *dp;
    volume_handle *vh;

    mlog_log(MDEBVOLDB, "VOLSER_AFSVolGetStatus");

    if (!sec_is_superuser(call)) {
	ret = VOLSERBAD_ACCESS;
	goto out;
    }

    ret = vld_verify_trans(transid);
    if (ret)
	goto out;

    ret = vld_get_trans(transid, &trans);
    if (ret)
	goto out;
    
    ret = volser_fetch_vh (trans->partition, trans->volid, &dp, &vh);
    if (ret) {
	vld_put_trans(trans);
	goto out;
    }

    status->volID = vh->info.volid;
    status->nextUnique = 0 /* XXX */;
    status->type = vh->info.type;
    status->parentID = vh->info.parentID;
    status->cloneID = vh->info.cloneID;
    status->backupID = vh->info.backupID;
    status->restoredFromID = 0 /* XXX */;
    status->maxQuota = vh->info.maxquota;
    status->minQuota = 0 /* XXX */;
    status->owner = 0 /* XXX */;
    status->creationDate = vh->info.creationDate;
    status->accessDate = vh->info.accessDate;
    status->updateDate = vh->info.updateDate;
    status->exprirationDate = 0 /* XXX */;
    status->backupDate = vh->info.backupDate;
    status->copyDate = 0 /* XXX */;

    vld_free (vh);
    dp_free (dp);

    vld_put_trans(trans);

 out:
    VOLSER_EXIT;
    
    return ret;
}

/*
 *
 */

int
VOLSER_AFSVolSetIdsTypes(struct rx_call *call,
			 const int32_t transid,
			 const char *name,
			 const int32_t type,
			 const int32_t parentID,
			 const int32_t cloneID,
			 const int32_t backupID)
{
    int ret = 0;
    struct trans *trans;
    struct dp_part *dp;
    volume_handle *vh;

    mlog_log(MDEBVOLDB, "VOLSER_AFSVolSetIdsTypes: type %d parentID %d "
	     "cloneID %d backupID %d", type, parentID, cloneID, backupID);

    if (!sec_is_superuser(call)) {
	ret = VOLSERBAD_ACCESS;
	goto out;
    }

    ret = vld_verify_trans(transid);
    if (ret)
	goto out;

    ret = vld_get_trans(transid, &trans);
    if (ret)
	goto out;
    
    ret = volser_fetch_vh (trans->partition, trans->volid, &dp, &vh);
    if (ret) {
	vld_put_trans(trans);
	goto out;
    }

    strlcpy(vh->info.name, name, VNAMESIZE);
    vh->info.type = type;
    vh->info.parentID = parentID;
    vh->info.cloneID = cloneID;
    vh->info.backupID = backupID;

    vld_info_write(vh);

    vld_free (vh);
    dp_free (dp);

    vld_put_trans(trans);

 out:
    VOLSER_EXIT;
    
    return ret;
}

/*
 *
 */

int
VOLSER_AFSVolSetDate(struct rx_call *call,
		     const int32_t transid,
		     const int32_t newDate)
{
    int ret = 0;
    struct trans *trans;
    struct dp_part *dp;
    volume_handle *vh;

    mlog_log(MDEBVOLDB, "VOLSER_AFSVolSetDate");

    if (!sec_is_superuser(call)) {
	ret = VOLSERBAD_ACCESS;
	goto out;
    }

    ret = vld_verify_trans(transid);
    if (ret)
	goto out;

    ret = vld_get_trans(transid, &trans);
    if (ret)
	goto out;
    
    ret = volser_fetch_vh (trans->partition, trans->volid, &dp, &vh);
    if (ret) {
	vld_put_trans(trans);
	goto out;
    }

    vh->info.creationDate = newDate;

    vld_info_write(vh);

    vld_free (vh);
    dp_free (dp);

    vld_put_trans(trans);

 out:
    VOLSER_EXIT;
    
    return ret;
}

/*
 *
 */

int
VOLSER_AFSVolListPartitions(struct rx_call *call,
			    struct pIDs *partIDs)
{
    int i;
    struct dp_part *dp = NULL;
    int ret = 0;

    mlog_log(MDEBVOLDB, "VOLSER_AFSVolListPartitions");

    i = 0;
    do {
	ret = dp_find(&dp);
	if (dp == NULL)
	    break;
	if (ret)
	    goto out;
	partIDs->partIds[i] = dp->num;
	i++;
    } while (i < 26);

    for (; i < 26; i++)
	partIDs->partIds[i] = -1;
    
    ret = 0;
 out:
    VOLSER_EXIT;
    
    return ret;
}

/*
 *
 */

int
VOLSER_AFSVolPartitionInfo(struct rx_call *call,
			   const char *name,
			   struct diskPartition *partition)
{
    int num;
    struct dp_part *dp;
    int ret = 0;

    mlog_log(MDEBVOLDB, "VOLSER_AFSVolPartitionInfo");

    num = partition_name2num (name);
    if (num == -1) {
	ret = VOLSERILLEGAL_PARTITION;
	goto out;
    }
    
    ret = dp_create (num, &dp);
    if (ret)
	goto out;

    memset(partition, 0, sizeof(*partition));
    strlcpy(partition->name, dp->part, 32);
    partition->free = 1000;
    
    dp_free(dp);

 out:
    VOLSER_EXIT;
    
    return ret;
}


static void
copy_volumeinfo(struct volintInfo *volinfo,
		volume_handle *vh,
		const int32_t partID)
{
    strlcpy(volinfo->name, vh->info.name, VNAMESIZE);
    volinfo->volid = vh->info.volid;
    volinfo->type = vh->info.type;
    volinfo->backupID = vh->info.backupID;
    volinfo->parentID = vh->info.parentID;
    volinfo->cloneID = vh->info.cloneID;
    if (vld_check_busy(volinfo->volid, partID))
	volinfo->status = VBUSY;
    else
	volinfo->status = VOK;
    volinfo->copyDate = vh->info.copyDate;
    volinfo->inUse = vh->info.inUse;
    volinfo->creationDate = vh->info.creationDate;
    volinfo->accessDate = vh->info.accessDate;
    volinfo->updateDate = vh->info.updateDate;
    volinfo->backupDate = vh->info.backupDate;
    volinfo->dayUse = vh->info.dayUse;
    volinfo->filecount = vh->info.filecount;
    volinfo->maxquota = vh->info.maxquota;
    volinfo->size = vh->info.size;
    volinfo->needsSalvaged = 0;
    volinfo->destroyMe = 0;
}

/*
 *
 */

int
VOLSER_AFSVolListVolumes(struct rx_call *call,
			 const int32_t partID,
			 const int32_t flags,
			 volEntries *resultEntries)
{
    int ret = 0;
    List *vollist;
    Listitem *item;
    volume_handle *vh;
    struct dp_part *dp;
    int numvol;
    int i;

    mlog_log(MDEBVOLDB, "VOLSER_AFSVolListVolumes");

    ret = dp_create (partID, &dp);
    if (ret)
	goto out;

    ret = vld_list_volumes(dp, &vollist);
    if (ret)
	goto free_part;

    numvol = 0;

    item = listhead(vollist);
    while (item) {
	numvol++;
	item = listnext(vollist, item);
    }

    resultEntries->len = numvol;
    
    resultEntries->val = calloc(sizeof(struct volintInfo) * resultEntries->len, 1);

    i = 0;
    while (!listemptyp(vollist)) {
	vh = (volume_handle *) listdelhead(vollist);
	assert(vh);
	ret = vld_info_uptodatep (vh);
	assert(ret == 0);
	copy_volumeinfo(&resultEntries->val[i], vh, partID);
	vld_free (vh);
	i++;
    }

    free(vollist);

 free_part:
    dp_free (dp);

 out:
    VOLSER_EXIT;
    
    return ret;
}

/*
 *
 */

int
VOLSER_AFSVolListOneVolume(struct rx_call *call,
			   const int32_t partID,
			   const int32_t volid,
			   volEntries *resultEntries)
{
    volume_handle *vh;
    int ret = 0;
    struct dp_part *dp;
    struct volintInfo *volinfo;

    mlog_log(MDEBVOLDB, "VOLSER_AFSVolListOneVolume partid: %d volid: %u\n",
	     partID, volid);

    ret = volser_fetch_vh (partID, volid, &dp, &vh);
    if (ret)
	goto out;

    resultEntries->len = 1;
    
    volinfo = calloc(sizeof(struct volintInfo) * resultEntries->len, 1);
    resultEntries->val = volinfo;
    copy_volumeinfo(volinfo, vh, partID);

    vld_free (vh);
    dp_free (dp);

 out:
    VOLSER_EXIT;
    
    return ret;
}

/*
 *
 */

int
VOLSER_AFSVolGetNthVolume(struct rx_call *call,
			  const int32_t index,
			  int32_t *volume,
			  int32_t *partition)
{
    int ret = 0;

    mlog_log(MDEBVOLDB, "VOLSER_AFSVolGetNthVolume");

    ret = VOLSERFAILEDOP;

 out:
    VOLSER_EXIT;
    
    return ret;
}

/*
 *
 */

int
VOLSER_AFSVolMonitor(struct rx_call *call,
		     transDebugEntries *result)
{
    int ret = 0;

    mlog_log(MDEBVOLDB, "VOLSER_AFSVolMonitor");

    ret = VOLSERFAILEDOP;

 out:
    VOLSER_EXIT;
    
    return ret;
}

/*
 *
 */

int
VOLSER_AFSVolXListVolumes(struct rx_call *call,
			  const int32_t partID,
			  const int32_t flags,
			  xvolEntries *resultEntries)
{
    int ret = 0;

    mlog_log(MDEBVOLDB, "VOLSER_AFSVolXListVolumes");

    ret = VOLSERFAILEDOP;

 out:
    VOLSER_EXIT;
    
    return ret;
}

/*
 *
 */

int
VOLSER_AFSVolXListOneVolume(struct rx_call *call,
			    const int32_t partID,
			    const int32_t volid,
			    xvolEntries *resultEntries)
{
    volume_handle *vh;
    struct dp_part *dp;
    struct xvolintInfo *volinfo;
    int ret = 0;

    mlog_log(MDEBVOLDB, "VOLSER_AFSVolXListOneVolume partid: %d volid: %u\n",
	     partID, volid);

    ret = volser_fetch_vh (partID, volid, &dp, &vh);
    if (ret)
	return ret;

    resultEntries->len = 1;
    
    volinfo = calloc(sizeof(struct xvolintInfo) * resultEntries->len, 1);
    resultEntries->val = volinfo;
    strlcpy(volinfo->name, vh->info.name, VNAMESIZE);
    volinfo->volid = vh->info.volid;
    volinfo->type = vh->info.type;
    volinfo->backupID = vh->info.backupID;
    volinfo->parentID = vh->info.parentID;
    volinfo->cloneID = vh->info.cloneID;
    if (vld_check_busy(volid, partID))
	volinfo->status = VBUSY;
    else
	volinfo->status = VOK;
    volinfo->copyDate = vh->info.copyDate;
    volinfo->inUse = vh->info.inUse;
    volinfo->creationDate = vh->info.creationDate;
    volinfo->accessDate = vh->info.accessDate;
    volinfo->updateDate = vh->info.updateDate;
    volinfo->backupDate = vh->info.backupDate;
    volinfo->dayUse = vh->info.dayUse;
    volinfo->filecount = vh->info.filecount;
    volinfo->maxquota = vh->info.maxquota;
    volinfo->size = vh->info.size;

    vld_free (vh);
    dp_free (dp);

 out:
    VOLSER_EXIT;
    
    return ret;
}

/*
 *
 */

int
VOLSER_AFSVolSetInfo(struct rx_call *call,
		     const int32_t transid,
		     const struct volintInfo *volinfo)
{
    volume_handle *vh;
    int ret = 0;
    struct dp_part *dp;
    struct trans *trans;

    mlog_log(MDEBVOLDB, "VOLSER_AFSVolSetInfo"
	     " trans %d name %s type %d parent %d volid %d backup %d",
	     transid, volinfo->name, volinfo->type, volinfo->parentID,
	     volinfo->volid, volinfo->backupID);

    if (!sec_is_superuser(call)) {
	ret = VOLSERBAD_ACCESS;
	goto out;
    }

    ret = vld_verify_trans(transid);
    if (ret)
	goto out;

    ret = vld_get_trans(transid, &trans);
    if (ret)
	goto out;
    
    ret = volser_fetch_vh (trans->partition, trans->volid, &dp, &vh);
    if (ret) {
	vld_put_trans(trans);
	goto out;
    }

    if (volinfo->name[0])
	strlcpy(vh->info.name, volinfo->name, VNAMESIZE);

    if (volinfo->volid)
	vh->info.volid = volinfo->volid;
    if (volinfo->type)
	vh->info.type = volinfo->type;
    if (volinfo->backupID)
	vh->info.backupID = volinfo->backupID;
    if (volinfo->parentID)
	vh->info.parentID = volinfo->parentID;
    if (volinfo->cloneID)
	vh->info.cloneID = volinfo->cloneID;
    if (volinfo->status)
	vh->info.status = volinfo->status;
    if (volinfo->copyDate)
	vh->info.copyDate = volinfo->copyDate;
    if (volinfo->inUse)
	vh->info.inUse = volinfo->inUse;
    if (volinfo->creationDate)
	vh->info.creationDate = volinfo->creationDate;
    if (volinfo->backupDate)
	vh->info.backupDate = volinfo->backupDate;
    if (volinfo->dayUse != -1)
	vh->info.dayUse = volinfo->dayUse;
    if (volinfo->filecount)
	vh->info.filecount = volinfo->filecount;
    if (volinfo->maxquota != -1)
	vh->info.maxquota = volinfo->maxquota;
    if (volinfo->size)
	vh->info.size = volinfo->size;

    vld_info_write(vh);

    vld_free (vh);
    dp_free (dp);
    vld_put_trans(trans);

 out:
    VOLSER_EXIT;
    
    return ret;
}

/*
 *
 */

int
VOLSER_AFSVolXListPartitions(struct rx_call *call,
			     part_entries *ent)
{
    int i;
    struct dp_part *dp = NULL;
    int ret = 0;
    int32_t partIDs[26]; /* XXX */

    mlog_log(MDEBVOLDB, "VOLSER_AFSVolXListPartitions");

    i = 0;
    do {
	ret = dp_find(&dp);
	if (dp == NULL)
	    break;
	if (ret)
	    goto out;
	partIDs[i] = dp->num;
	i++;
    } while (i < 26);
    
    ent->len = i;
    ent->val = malloc(sizeof(int32_t) * ent->len);
    memcpy(ent->val, partIDs, sizeof(int32_t) * ent->len);

    ret = 0;
 out:
    VOLSER_EXIT;
    
    return ret;
}

/*
 *
 */

int
VOLSER_AFSVolForwardMultiple(struct rx_call *call,
			     const int32_t fromTrans,
			     const int32_t fromData,
			     const manyDests *destinations,
			     const int32_t spare0,
			     const struct restoreCookie *cookie,
			     multi_results *results)
{
    int ret = 0;

    mlog_log(MDEBVOLDB, "VOLSER_AFSVolForwardMultiple");

    if (!sec_is_superuser(call)) {
	ret = VOLSERBAD_ACCESS;
	goto out;
    }
    
    ret = VOLSERFAILEDOP;

 out:
    VOLSER_EXIT;
    
    return ret;
}


@


1.3
log
@Merge
@
text
@@


1.2
log
@merge
@
text
@d2 1
a2 1
 * Copyright (c) 1999 - 2000 Kungliga Tekniska Högskolan
d36 7
a42 1
RCSID("$KTH: volprocs.c,v 1.9 2000/10/03 00:17:36 lha Exp $");
d57 1
a57 1
	return VOLSERFAILEDOP; /* XXX */
d64 3
a66 1
	return VOLSERFAILEDOP; /* XXX */
d92 1
a92 1
    int ret;
d96 2
a97 2
    mlog_log(MDEBVOLDB, "VOLSER_AFSVolCreateVolume "
	     "part %d name %s type %d parent %d volid %u",
d100 5
d110 1
a110 1
	return ret;
d112 1
a112 1
    ret = vld_trans_set_iflags (*trans, ITOffline);
d114 1
a114 1
	return ret;
d119 1
a119 1
	return ret;
d125 1
a125 1
	return ret;
d128 4
a131 1
    return 0;
d140 1
a140 1
			  const int32_t trans)
d142 15
a156 1
    int ret;
d158 1
a158 1
    ret = vld_verify_trans(trans);
d160 11
a170 1
	return ret;
d172 4
a175 1
    return VOLSERFAILEDOP;
d187 15
a201 1
    return VOLSERFAILEDOP;
d213 1
a213 1
    int ret;
d219 1
a219 1
	      "VOLSER_AFSVolDump trans %d fromdate %d", 
d222 5
d229 1
a229 1
	return ret;
d233 1
a233 1
	return ret;
d238 1
a238 1
	return ret;
d243 2
a244 1
	return VOLSERFAILEDOP;
d247 1
d249 1
d251 4
a254 2
    vld_put_trans (trans);
    return VOLSERFAILEDOP;
d268 15
a282 1
    return VOLSERFAILEDOP;
d291 1
a291 1
		     const int32_t toTrans,
d295 47
a341 1
    return VOLSERFAILEDOP;
d356 15
a370 1
    return VOLSERFAILEDOP;
d385 17
a401 1
    return VOLSERFAILEDOP;
d413 15
a427 1
    return VOLSERFAILEDOP;
d439 15
a453 1
    return VOLSERFAILEDOP;
d467 17
a483 1
    int ret;
d487 1
a487 1
	return ret;
d492 1
a492 1
	return ret;
d495 4
a498 1
    return 0;
d507 1
a507 1
		      const int32_t trans,
d510 13
a522 1
    int ret;
d524 1
a524 1
    ret = vld_verify_trans(trans);
d526 5
a530 1
	return ret;
d532 1
a532 1
    ret = vld_end_trans(trans, rcode);
d534 4
a537 1
	return ret;
d539 1
a539 1
    return 0;
d551 8
a558 1
    int ret;
d562 1
a562 1
	return ret;
d566 1
a566 1
	return ret;
d568 4
a571 1
    return 0;
d583 1
a583 1
    int ret;
d588 7
a594 2
    mlog_log(MDEBVOLDB, "VOLSER_AFSVolSetFlags "
	     "trans %d flags %d", transid, flags);
d598 1
a598 1
	return ret;
d602 1
a602 1
	return ret;
d607 1
a607 1
	return ret;
d615 1
d617 1
d628 1
a628 1
	return ret;
d630 4
a633 1
    return 0;
d645 15
a659 1
    return VOLSERFAILEDOP;
d668 1
a668 1
		       const int32_t tid,
d671 52
a722 1
    return VOLSERFAILEDOP;
d731 1
a731 1
			 const int32_t tId,
d734 3
a736 3
			 const int32_t pId,
			 const int32_t cloneId,
			 const int32_t backupId)
d738 44
a781 1
    return VOLSERFAILEDOP;
d790 1
a790 1
		     const int32_t tid,
d793 39
a831 1
    return VOLSERFAILEDOP;
d844 3
a846 1
    int ret;
d854 1
a854 1
	    return ret;
d862 5
a866 1
    return 0;
d880 3
a882 1
    int ret;
d885 4
a888 2
    if (num == -1)
	return 0; /* XXX */
d892 1
a892 1
	return ret;
d895 2
a896 1
    strlcpy(partition->name, dp->part, 32);    
d899 3
d903 31
a933 1
    return 0;
d946 50
a995 1
    return VOLSERFAILEDOP;
d1009 1
a1009 1
    int ret;
d1013 2
a1014 3
    fprintf(stderr, 
	    "VOLSER_AFSVolListOneVolume partid: %d volid: %u\n",
	    partID, volid);
d1018 1
a1018 1
	return ret;
d1024 1
a1024 22
    strlcpy(volinfo->name, vh->info.name, VNAMESIZE);
    volinfo->volid = vh->info.volid;
    volinfo->type = vh->info.type;
    volinfo->backupID = vh->info.backupID;
    volinfo->parentID = vh->info.parentID;
    volinfo->cloneID = vh->info.cloneID;
    if (vld_check_busy(volid, partID))
	volinfo->status = VBUSY;
    else
	volinfo->status = VOK;
    volinfo->copyDate = vh->info.copyDate;
    volinfo->inUse = vh->info.inUse;
    volinfo->creationDate = vh->info.creationDate;
    volinfo->accessDate = vh->info.accessDate;
    volinfo->updateDate = vh->info.updateDate;
    volinfo->backupDate = vh->info.backupDate;
    volinfo->dayUse = vh->info.dayUse;
    volinfo->filecount = vh->info.filecount;
    volinfo->maxquota = vh->info.maxquota;
    volinfo->size = vh->info.size;
    volinfo->needsSalvaged = 0;
    volinfo->destroyMe = 0;
d1029 4
a1032 2

    return 0;
d1045 10
a1054 1
    return VOLSERFAILEDOP;
d1065 10
a1074 1
    return VOLSERFAILEDOP;
d1087 10
a1096 1
    return VOLSERFAILEDOP;
a1109 1
    int ret;
d1112 1
d1114 2
a1115 3
    fprintf(stderr, 
	    "VOLSER_AFSVolXListOneVolume partid: %d volid: %u\n",
	    partID, volid);
d1149 4
a1152 2

    return 0;
d1165 1
a1165 1
    int ret;
d1169 2
a1170 2
    mlog_log(MDEBVOLDB, "VOLSER_AFSVolSetInfo "
	     "trans %d name %s type %d parent %d volid %d backup %d",
d1174 5
d1181 1
a1181 1
	return ret;
d1185 1
a1185 1
	return ret;
d1190 1
a1190 1
	return ret;
d1231 4
a1234 1
    return 0;
d1247 1
a1247 1
    int ret;
d1258 1
a1258 1
	    return ret;
d1267 5
a1271 1
    return 0;
d1282 1
a1282 1
			     const replicas *destinations,
d1285 1
a1285 1
			     const multi_results *results)
d1287 15
a1301 1
    return VOLSERFAILEDOP;
@


1.1
log
@New Arla userland from Arla between 0.34.2 and current in arla cvs.
Too many new features and fixes to mention here.
@
text
@d17 1
a17 6
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by the Kungliga Tekniska
 *      Högskolan and its contributors.
 * 
 * 4. Neither the name of the Institute nor the names of its contributors
d36 1
a36 1
RCSID("$Id: volprocs.c,v 1.8 2000/08/16 02:31:17 lha Exp $");
@


1.1.1.1
log
@Import of arla-0.35.7
@
text
@d17 6
a22 1
 * 3. Neither the name of the Institute nor the names of its contributors
d41 1
a41 1
RCSID("$KTH: volprocs.c,v 1.9 2000/10/03 00:17:36 lha Exp $");
@


1.1.1.2
log
@Import of arla -current as of Aug 5 2003

ok todd@@ deraadt@@
@
text
@d2 1
a2 1
 * Copyright (c) 1999 - 2002 Kungliga Tekniska Högskolan
d36 1
a36 7
RCSID("$arla: volprocs.c,v 1.19 2002/09/08 04:56:15 ahltorp Exp $");

/*
 * exit debug logging
 */

#define VOLSER_EXIT  mlog_log(MDEBVOLDB, __FUNCTION__ " error: %s(%d)", koerr_gettext(ret), ret)
d51 1
a51 1
	return VOLSERILLEGAL_PARTITION;
d58 1
a58 3
	if (ret == ENOENT)
	    return VNOVOL;
	return ret;
d84 1
a84 1
    int ret = 0;
d88 2
a89 2
    mlog_log(MDEBVOLDB, "VOLSER_AFSVolCreateVolume"
	     " part %d name %s type %d parent %d volid %u",
a91 5
    if (!sec_is_superuser(call)) {
	ret = VOLSERBAD_ACCESS;
	goto out;
    }

d97 1
a97 1
	goto out;
d99 1
a99 1
    ret = vld_trans_set_iflags (*trans, ITCreate);
d101 1
a101 1
	goto out;
d106 1
a106 1
	goto out;
d112 1
a112 1
	goto out;
d115 1
a115 4
 out:
    VOLSER_EXIT;
    
    return ret;
d124 1
a124 1
			  const int32_t transid)
d126 1
a126 4
    int ret = 0;
    int32_t backstoretype = VLD_SVOL;
    struct trans *trans;
    struct dp_part *dp;
d128 1
a128 8
    mlog_log(MDEBVOLDB, "VOLSER_AFSVolDeleteVolume");

    if (!sec_is_superuser(call)) {
	ret = VOLSERBAD_ACCESS;
	goto out;
    }

    ret = vld_verify_trans(transid);
d130 1
a130 15
	goto out;

    ret = vld_get_trans(transid, &trans);
    if (ret)
	goto out;

    ret = dp_create (trans->partition, &dp);
    if (ret) {
	vld_put_trans (trans);
	goto out;
    }

    ret = vld_delete_volume (dp, trans->volid, backstoretype, 0);

    vld_put_trans(trans);
d132 1
a132 4
 out:
    VOLSER_EXIT;
    
    return ret;
d144 1
a144 15
    int ret = 0;

    mlog_log(MDEBVOLDB, "VOLSER_AFSVolNukeVolume");

    if (!sec_is_superuser(call)) {
	ret = VOLSERBAD_ACCESS;
	goto out;
    }

    ret = VOLSERFAILEDOP;

 out:
    VOLSER_EXIT;
    
    return ret;
d156 1
a156 1
    int ret = 0;
d162 1
a162 1
	      "VOLSER_AFSVolDump: trans %d fromdate %d", 
a164 5
    if (!sec_is_superuser(call)) {
	ret = VOLSERBAD_ACCESS;
	goto out;
    }

d167 1
a167 1
	goto out;
d171 1
a171 1
	goto out;
d176 1
a176 1
	goto out;
d181 1
a181 2
	ret = VOLSERFAILEDOP;
	goto out;
d184 1
a184 1
    ret = generate_dump(call, vh);
d187 1
a187 5

 out:
    VOLSER_EXIT;
    
    return ret;
d201 1
a201 15
    int ret = 0;

    mlog_log(MDEBVOLDB, "VOLSER_AFSVolSignalRestore");

    if (!sec_is_superuser(call)) {
	ret = VOLSERBAD_ACCESS;
	goto out;
    }

    ret = VOLSERFAILEDOP;

 out:
    VOLSER_EXIT;
    
    return ret;
d210 1
a210 1
		     const int32_t transid,
d214 1
a214 47
    int ret = 0;
    struct trans *trans;
    struct dp_part *dp;
    volume_handle *vh;

    mlog_log(MDEBVOLDB, "VOLSER_AFSVolRestore");

    if (!sec_is_superuser(call)) {
	ret = VOLSERBAD_ACCESS;
	goto out;
    }

    ret = vld_verify_trans(transid);
    if (ret)
	goto out;

    ret = vld_get_trans(transid, &trans);
    if (ret)
	goto out;
    
    ret = volser_fetch_vh (trans->partition, trans->volid, &dp, &vh);
    if (ret) {
	vld_put_trans(trans);
	goto out;
    }

    ret = parse_dump(call, vh);
    if (ret) {
	vld_free (vh);
	dp_free (dp);
	vld_put_trans(trans);
	goto out;
    }

    ret = vld_rebuild(vh);

    vld_info_write(vh);

    vld_free (vh);
    dp_free (dp);

    vld_put_trans(trans);

 out:
    VOLSER_EXIT;
    
    return ret;
d229 1
a229 15
    int ret = 0;

    mlog_log(MDEBVOLDB, "VOLSER_AFSVolForward");

    if (!sec_is_superuser(call)) {
	ret = VOLSERBAD_ACCESS;
	goto out;
    }

    ret = VOLSERFAILEDOP;

 out:
    VOLSER_EXIT;
    
    return ret;
d244 1
a244 17
    int ret = 0;

    mlog_log(MDEBVOLDB, "VOLSER_AFSVolClone"
	     " trans %d purgevol %d newtype %d newname %d",
	     trans, purgeVol, newType, newName);

    if (!sec_is_superuser(call)) {
	ret = VOLSERBAD_ACCESS;
	goto out;
    }

    ret = VOLSERFAILEDOP;

 out:
    VOLSER_EXIT;
    
    return ret;
d256 1
a256 15
    int ret = 0;

    mlog_log(MDEBVOLDB, "VOLSER_AFSVolReClone");

    if (!sec_is_superuser(call)) {
	ret = VOLSERBAD_ACCESS;
	goto out;
    }

    ret = VOLSERFAILEDOP;

 out:
    VOLSER_EXIT;
    
    return ret;
d268 1
a268 15
    int ret = 0;

    mlog_log(MDEBVOLDB, "VOLSER_AFSVolSetForwarding");

    if (!sec_is_superuser(call)) {
	ret = VOLSERBAD_ACCESS;
	goto out;
    }

    ret = VOLSERFAILEDOP;

 out:
    VOLSER_EXIT;
    
    return ret;
d282 1
a282 17
    int ret = 0;
    struct dp_part *dp;
    volume_handle *vh;

    mlog_log(MDEBVOLDB, "VOLSER_AFSVolTransCreate");

    if (!sec_is_superuser(call)) {
	ret = VOLSERBAD_ACCESS;
	goto out;
    }

    ret = volser_fetch_vh (partition, volume, &dp, &vh);
    if (ret)
	goto out;

    vld_free (vh);
    dp_free (dp);
d286 1
a286 1
	goto out;
d291 1
a291 1
	goto out;
d294 1
a294 4
 out:
    VOLSER_EXIT;
    
    return ret;
d303 1
a303 1
		      const int32_t transid,
d306 1
a306 2
    struct trans *trans;
    int ret = 0;
d308 1
a308 12
    mlog_log(MDEBVOLDB, "VOLSER_AFSVolEndTrans trans %d", transid);

    if (!sec_is_superuser(call)) {
	ret = VOLSERBAD_ACCESS;
	goto out;
    }

    ret = vld_verify_trans(transid);
    if (ret) 
	goto out;

    ret = vld_get_trans(transid, &trans);
d310 1
a310 5
	goto out;

    ropa_break_volume_callback(trans->volid); /* XXX */

    vld_put_trans(trans);
d312 1
a312 1
    ret = vld_end_trans(transid, rcode);
d314 1
a314 1
	goto out;
d316 1
a316 4
 out:
    mlog_log(MDEBVOLDB, "VOLSER_AFSVolEndTrans returns %d", ret);

    return ret;
d328 1
a328 8
    int ret = 0;

    mlog_log(MDEBVOLDB, "VOLSER_AFSVolGetFlags");

    if (!sec_is_superuser(call)) {
	ret = VOLSERBAD_ACCESS;
	goto out;
    }
d332 1
a332 1
	goto out;
d336 1
a336 1
	goto out;
d338 1
a338 4
 out:
    VOLSER_EXIT;
    
    return ret;
d350 1
a350 1
    int ret = 0;
d355 2
a356 7
    mlog_log(MDEBVOLDB, "VOLSER_AFSVolSetFlags"
	     " trans %d flags %d", transid, flags);

    if (!sec_is_superuser(call)) {
	ret = VOLSERBAD_ACCESS;
	goto out;
    }
d360 1
a360 1
	goto out;
d364 1
a364 1
	goto out;
d369 1
a369 1
	goto out;
a376 1
#if 0
a377 1
#endif
d388 1
a388 1
	goto out;
d390 1
a390 4
 out:
    VOLSER_EXIT;
    
    return ret;
d402 1
a402 15
    int ret = 0;

    mlog_log(MDEBVOLDB, "VOLSER_AFSVolGetName");

    if (!sec_is_superuser(call)) {
	ret = VOLSERBAD_ACCESS;
	goto out;
    }

    ret = VOLSERFAILEDOP;

 out:
    VOLSER_EXIT;
    
    return ret;
d411 1
a411 1
		       const int32_t transid,
d414 1
a414 52
    int ret = 0;
    struct trans *trans;
    struct dp_part *dp;
    volume_handle *vh;

    mlog_log(MDEBVOLDB, "VOLSER_AFSVolGetStatus");

    if (!sec_is_superuser(call)) {
	ret = VOLSERBAD_ACCESS;
	goto out;
    }

    ret = vld_verify_trans(transid);
    if (ret)
	goto out;

    ret = vld_get_trans(transid, &trans);
    if (ret)
	goto out;
    
    ret = volser_fetch_vh (trans->partition, trans->volid, &dp, &vh);
    if (ret) {
	vld_put_trans(trans);
	goto out;
    }

    status->volID = vh->info.volid;
    status->nextUnique = 0 /* XXX */;
    status->type = vh->info.type;
    status->parentID = vh->info.parentID;
    status->cloneID = vh->info.cloneID;
    status->backupID = vh->info.backupID;
    status->restoredFromID = 0 /* XXX */;
    status->maxQuota = vh->info.maxquota;
    status->minQuota = 0 /* XXX */;
    status->owner = 0 /* XXX */;
    status->creationDate = vh->info.creationDate;
    status->accessDate = vh->info.accessDate;
    status->updateDate = vh->info.updateDate;
    status->exprirationDate = 0 /* XXX */;
    status->backupDate = vh->info.backupDate;
    status->copyDate = 0 /* XXX */;

    vld_free (vh);
    dp_free (dp);

    vld_put_trans(trans);

 out:
    VOLSER_EXIT;
    
    return ret;
d423 1
a423 1
			 const int32_t transid,
d426 3
a428 3
			 const int32_t parentID,
			 const int32_t cloneID,
			 const int32_t backupID)
d430 1
a430 44
    int ret = 0;
    struct trans *trans;
    struct dp_part *dp;
    volume_handle *vh;

    mlog_log(MDEBVOLDB, "VOLSER_AFSVolSetIdsTypes: type %d parentID %d "
	     "cloneID %d backupID %d", type, parentID, cloneID, backupID);

    if (!sec_is_superuser(call)) {
	ret = VOLSERBAD_ACCESS;
	goto out;
    }

    ret = vld_verify_trans(transid);
    if (ret)
	goto out;

    ret = vld_get_trans(transid, &trans);
    if (ret)
	goto out;
    
    ret = volser_fetch_vh (trans->partition, trans->volid, &dp, &vh);
    if (ret) {
	vld_put_trans(trans);
	goto out;
    }

    strlcpy(vh->info.name, name, VNAMESIZE);
    vh->info.type = type;
    vh->info.parentID = parentID;
    vh->info.cloneID = cloneID;
    vh->info.backupID = backupID;

    vld_info_write(vh);

    vld_free (vh);
    dp_free (dp);

    vld_put_trans(trans);

 out:
    VOLSER_EXIT;
    
    return ret;
d439 1
a439 1
		     const int32_t transid,
d442 1
a442 39
    int ret = 0;
    struct trans *trans;
    struct dp_part *dp;
    volume_handle *vh;

    mlog_log(MDEBVOLDB, "VOLSER_AFSVolSetDate");

    if (!sec_is_superuser(call)) {
	ret = VOLSERBAD_ACCESS;
	goto out;
    }

    ret = vld_verify_trans(transid);
    if (ret)
	goto out;

    ret = vld_get_trans(transid, &trans);
    if (ret)
	goto out;
    
    ret = volser_fetch_vh (trans->partition, trans->volid, &dp, &vh);
    if (ret) {
	vld_put_trans(trans);
	goto out;
    }

    vh->info.creationDate = newDate;

    vld_info_write(vh);

    vld_free (vh);
    dp_free (dp);

    vld_put_trans(trans);

 out:
    VOLSER_EXIT;
    
    return ret;
d455 1
a455 3
    int ret = 0;

    mlog_log(MDEBVOLDB, "VOLSER_AFSVolListPartitions");
d463 1
a463 1
	    goto out;
d471 1
a471 5
    ret = 0;
 out:
    VOLSER_EXIT;
    
    return ret;
d485 1
a485 3
    int ret = 0;

    mlog_log(MDEBVOLDB, "VOLSER_AFSVolPartitionInfo");
d488 2
a489 4
    if (num == -1) {
	ret = VOLSERILLEGAL_PARTITION;
	goto out;
    }
d493 1
a493 1
	goto out;
d496 1
a496 2
    strlcpy(partition->name, dp->part, 32);
    partition->free = 1000;
a498 3

 out:
    VOLSER_EXIT;
d500 1
a500 31
    return ret;
}


static void
copy_volumeinfo(struct volintInfo *volinfo,
		volume_handle *vh,
		const int32_t partID)
{
    strlcpy(volinfo->name, vh->info.name, VNAMESIZE);
    volinfo->volid = vh->info.volid;
    volinfo->type = vh->info.type;
    volinfo->backupID = vh->info.backupID;
    volinfo->parentID = vh->info.parentID;
    volinfo->cloneID = vh->info.cloneID;
    if (vld_check_busy(volinfo->volid, partID))
	volinfo->status = VBUSY;
    else
	volinfo->status = VOK;
    volinfo->copyDate = vh->info.copyDate;
    volinfo->inUse = vh->info.inUse;
    volinfo->creationDate = vh->info.creationDate;
    volinfo->accessDate = vh->info.accessDate;
    volinfo->updateDate = vh->info.updateDate;
    volinfo->backupDate = vh->info.backupDate;
    volinfo->dayUse = vh->info.dayUse;
    volinfo->filecount = vh->info.filecount;
    volinfo->maxquota = vh->info.maxquota;
    volinfo->size = vh->info.size;
    volinfo->needsSalvaged = 0;
    volinfo->destroyMe = 0;
d513 1
a513 50
    int ret = 0;
    List *vollist;
    Listitem *item;
    volume_handle *vh;
    struct dp_part *dp;
    int numvol;
    int i;

    mlog_log(MDEBVOLDB, "VOLSER_AFSVolListVolumes");

    ret = dp_create (partID, &dp);
    if (ret)
	goto out;

    ret = vld_list_volumes(dp, &vollist);
    if (ret)
	goto free_part;

    numvol = 0;

    item = listhead(vollist);
    while (item) {
	numvol++;
	item = listnext(vollist, item);
    }

    resultEntries->len = numvol;
    
    resultEntries->val = calloc(sizeof(struct volintInfo) * resultEntries->len, 1);

    i = 0;
    while (!listemptyp(vollist)) {
	vh = (volume_handle *) listdelhead(vollist);
	assert(vh);
	ret = vld_info_uptodatep (vh);
	assert(ret == 0);
	copy_volumeinfo(&resultEntries->val[i], vh, partID);
	vld_free (vh);
	i++;
    }

    free(vollist);

 free_part:
    dp_free (dp);

 out:
    VOLSER_EXIT;
    
    return ret;
d527 1
a527 1
    int ret = 0;
d531 3
a533 2
    mlog_log(MDEBVOLDB, "VOLSER_AFSVolListOneVolume partid: %d volid: %u\n",
	     partID, volid);
d537 1
a537 1
	goto out;
d543 22
a564 1
    copy_volumeinfo(volinfo, vh, partID);
d569 2
a570 4
 out:
    VOLSER_EXIT;
    
    return ret;
d583 1
a583 10
    int ret = 0;

    mlog_log(MDEBVOLDB, "VOLSER_AFSVolGetNthVolume");

    ret = VOLSERFAILEDOP;

 out:
    VOLSER_EXIT;
    
    return ret;
d594 1
a594 10
    int ret = 0;

    mlog_log(MDEBVOLDB, "VOLSER_AFSVolMonitor");

    ret = VOLSERFAILEDOP;

 out:
    VOLSER_EXIT;
    
    return ret;
d607 1
a607 10
    int ret = 0;

    mlog_log(MDEBVOLDB, "VOLSER_AFSVolXListVolumes");

    ret = VOLSERFAILEDOP;

 out:
    VOLSER_EXIT;
    
    return ret;
d621 1
a623 1
    int ret = 0;
d625 3
a627 2
    mlog_log(MDEBVOLDB, "VOLSER_AFSVolXListOneVolume partid: %d volid: %u\n",
	     partID, volid);
d661 2
a662 4
 out:
    VOLSER_EXIT;
    
    return ret;
d675 1
a675 1
    int ret = 0;
d679 2
a680 2
    mlog_log(MDEBVOLDB, "VOLSER_AFSVolSetInfo"
	     " trans %d name %s type %d parent %d volid %d backup %d",
a683 5
    if (!sec_is_superuser(call)) {
	ret = VOLSERBAD_ACCESS;
	goto out;
    }

d686 1
a686 1
	goto out;
d690 1
a690 1
	goto out;
d695 1
a695 1
	goto out;
d736 1
a736 4
 out:
    VOLSER_EXIT;
    
    return ret;
d749 1
a749 1
    int ret = 0;
d760 1
a760 1
	    goto out;
d769 1
a769 5
    ret = 0;
 out:
    VOLSER_EXIT;
    
    return ret;
d780 1
a780 1
			     const manyDests *destinations,
d783 1
a783 1
			     multi_results *results)
d785 1
a785 15
    int ret = 0;

    mlog_log(MDEBVOLDB, "VOLSER_AFSVolForwardMultiple");

    if (!sec_is_superuser(call)) {
	ret = VOLSERBAD_ACCESS;
	goto out;
    }
    
    ret = VOLSERFAILEDOP;

 out:
    VOLSER_EXIT;
    
    return ret;
@


