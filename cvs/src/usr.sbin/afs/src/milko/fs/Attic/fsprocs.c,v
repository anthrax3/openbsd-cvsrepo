head	1.4;
access;
symbols
	OPENBSD_5_2:1.3.0.38
	OPENBSD_5_2_BASE:1.3
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.36
	OPENBSD_5_0:1.3.0.34
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.32
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.3.0.30
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.3.0.26
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.28
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.3.0.24
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.3.0.22
	OPENBSD_4_4_BASE:1.3
	OPENBSD_4_3:1.3.0.20
	OPENBSD_4_3_BASE:1.3
	OPENBSD_4_2:1.3.0.18
	OPENBSD_4_2_BASE:1.3
	OPENBSD_4_1:1.3.0.16
	OPENBSD_4_1_BASE:1.3
	OPENBSD_4_0:1.3.0.14
	OPENBSD_4_0_BASE:1.3
	OPENBSD_3_9:1.3.0.12
	OPENBSD_3_9_BASE:1.3
	OPENBSD_3_8:1.3.0.10
	OPENBSD_3_8_BASE:1.3
	OPENBSD_3_7:1.3.0.8
	OPENBSD_3_7_BASE:1.3
	OPENBSD_3_6:1.3.0.6
	OPENBSD_3_6_BASE:1.3
	OPENBSD_3_5:1.3.0.4
	OPENBSD_3_5_BASE:1.3
	OPENBSD_3_4:1.3.0.2
	OPENBSD_3_4_BASE:1.3
	arla-20030805:1.1.1.2
	OPENBSD_3_3:1.2.0.4
	OPENBSD_3_3_BASE:1.2
	OPENBSD_3_2:1.2.0.2
	OPENBSD_3_2_BASE:1.2
	arla-0-35-7:1.1.1.1
	arla:1.1.1
	OPENBSD_3_1:1.1.0.8
	OPENBSD_3_1_BASE:1.1
	OPENBSD_3_0:1.1.0.6
	OPENBSD_3_0_BASE:1.1
	OPENBSD_2_9_BASE:1.1
	OPENBSD_2_9:1.1.0.4
	OPENBSD_2_8:1.1.0.2
	OPENBSD_2_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.4
date	2012.08.23.06.21.52;	author deraadt;	state dead;
branches;
next	1.3;

1.3
date	2003.08.05.09.16.15;	author hin;	state Exp;
branches;
next	1.2;

1.2
date	2002.06.07.04.42.38;	author hin;	state Exp;
branches;
next	1.1;

1.1
date	2000.09.11.14.41.13;	author art;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.06.07.04.14.31;	author hin;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.08.05.08.21.05;	author hin;	state Exp;
branches;
next	;


desc
@@


1.4
log
@the afs src tree can go away
@
text
@/*
 * Copyright (c) 1999 - 2003 Kungliga Tekniska Högskolan
 * (Royal Institute of Technology, Stockholm, Sweden).
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include "fsrv_locl.h"

RCSID("$arla: fsprocs.c,v 1.68 2003/04/08 00:13:35 lha Exp $");

#define GETHOST(call) rx_HostOf(rx_PeerOf(rx_ConnectionOf((call))))
#define GETPORT(call) rx_PortOf(rx_PeerOf(rx_ConnectionOf((call))))

int
createentry(struct rx_call *call,
	    const struct AFSFid *DirFid,
	    const char *Name,
	    const char *Contents,
	    const struct AFSStoreStatus *InStatus,
	    const struct AFSFid *ExistingFid,
	    struct AFSFid *EntryFid,
	    struct AFSFetchStatus *OutFidStatus,
	    struct AFSFetchStatus *OutDirStatus,
	    struct AFSCallBack *CallBack,
	    struct AFSVolSync *VolSync);

/*
 * Initlize all fields of `m' except `m->flags'.
 */

static int
fs_init_msec (struct rx_call *call, struct msec *m)
{
    volop_flags flags;
    assert (call && m);
    flags = m->flags;

    memset (m, 0, sizeof (*m));
    m->flags = flags;
    if (call) {
	m->sec = fs_connsec_context_get(call->conn);
    } else {
	m->sec = NULL; 
    }

    m->loop = 0;
    return 0;
}

/*
 * Update FetchStatus `fs' to reflect `n' and `m'.
 */

static void
fs_update_fs (const struct mnode *n, const struct msec *m,
	      AFSFetchStatus *fs)
{
    *fs 		= n->fs;
    fs->CallerAccess	= m->caller_access;
    fs->AnonymousAccess	= m->anonymous_access;
}

/*
 * return a non zero value if the user is the superuser.
 */

static int
super_user (const struct msec *m)
{
    return m->sec->superuser;
}

/*
 * If check if the user have the rights to change `status' the way the
 * user want to with the right `sec'. If the entry is about to be
 * created, set owner if that isn't set.
 */

static int
check_ss_bits (const struct msec *m, const AFSStoreStatus *status,
	       Bool createp)
{
    /* check if member of system:administrators
     */

    if ((status->Mask & SS_OWNER) != 0) {
	if (status->Owner != m->sec->uid && !super_user(m))
	    return EPERM;
    } else if (createp) {
	((AFSStoreStatus *)status)->Mask |= SS_OWNER; /* XXX */
	((AFSStoreStatus *)status)->Owner = m->sec->uid; /* XXX */
    }

    if ((status->Mask & SS_MODEBITS) != 0) {
	if ((07000 & status->UnixModeBits) != 0 && !super_user(m))
	    return EPERM;
    }
    return 0;
}

/*
 * Given `fid', `volh' and `m' open node `n', check rights.
 */

static int
fs_open_node (const AFSFid *fid, struct volume_handle *volh,
              struct msec *m, struct mnode **n)
{
    int ret;

    ret = mnode_find (fid, n);
    if (ret)
        return ret;

    ret = vld_open_vnode (volh, *n, m);
    if (ret == 0)
	ret = vld_check_rights (volh, *n, m);

    if (ret)
	mnode_free (*n, FALSE);

    return ret;
}

/*
 * Given `fid' and `call', init `m', `volh' and `n'.
 *
 * If function returns with 0, `volh' and `n' needs to be free:ed when
 * no longer needed.
 */


static int
fs_init_req (const AFSFid *fid, struct msec *m, struct volume_handle **volh,
	     struct rx_call *call, struct mnode **n)
{
    int ret;
	     
    ret = vld_check_busy(fid->Volume, -1);
    if (ret)
	return ret;

    ret = fs_init_msec (call, m);
    if (ret)
	return ret;

    ret = vld_find_vol (fid->Volume, volh);
    if (ret)
	return ret;

    if (n != NULL && (*volh)->flags.offlinep == TRUE) {
	int ret;
	if ((*volh)->flags.attacherr)
	    ret = VOFFLINE;
	else if ((*volh)->flags.salvaged)
	    ret = VSALVAGE;
	else
	    ret = VOFFLINE;
	vld_free (*volh);
	return ret;
    }

#define VOLOP_MODIFY (VOLOP_ADMIN|VOLOP_DELETE|VOLOP_WRITE|\
			VOLOP_INSERT|VOLOP_LOCK)

    ret = vld_info_uptodatep (*volh);
    if (ret) {
	vld_free (*volh);
	return ret;
    }
    
    if ((*volh)->info.type != RWVOL &&
	(m->flags & VOLOP_MODIFY))
    {
	vld_free (*volh);
	return MILKO_ROFS;
    }

    ret = vld_db_uptodate (*volh);
    if (ret) {
	vld_free (*volh);
	return ret;
    }
    
    if (n != NULL) {
	ret = fs_open_node (fid, *volh, m, n);
	if (ret) {
	    vld_free (*volh);
	    return ret;
	}
    }

    return ret;
}

/*
 *
 */

int
SRXAFS_FetchData(struct rx_call *call,
		 const struct AFSFid *a_fidToFetchP,
		 const int32_t a_offset,
		 const int32_t a_lenInBytes,
		 struct AFSFetchStatus *a_fidStatP,
		 struct AFSCallBack *a_callBackP,
		 struct AFSVolSync *a_volSyncP)
{
    struct volume_handle *volh;

    int32_t len, net_len;
    struct mnode *n;
    struct msec m;
    int ret;
    int haveData = 1;

    mlog_log (MDEBFS, "FetchData: fid: %d.%d.%d, len = %d, offset = %d", 
	      a_fidToFetchP->Volume, a_fidToFetchP->Vnode,
	      a_fidToFetchP->Unique, a_lenInBytes, a_offset);

    m.flags = VOLOP_GETSTATUS | VOLOP_READ;

    ret = fs_init_req (a_fidToFetchP, &m, &volh, call, &n);
    if (ret) {
	mlog_log (MDEBFS, "FetchData: fs_init_req returned %d", ret);
	return ret;
    }

    if (n->fs.Length < a_offset) {
/*	ret = EINVAL; */
	mlog_log (MDEBFS, "FetchData: invalid offset (%d < %d)", 
		  n->fs.Length, a_offset); 
	haveData = 0;
	len = 0;
/*	goto out; */
    } else
	len = min(a_lenInBytes, n->fs.Length - a_offset);

    net_len = ntohl(len);

    if (rx_Write (call, &net_len, sizeof(net_len)) != sizeof(net_len)) {
	ret = errno;
	mlog_log (MDEBFS, "FetchData: rx_Write returned %d", ret);
	goto out;
    }
    
    if (haveData) {
	ret = copyfd2rx (n->fd, call, a_offset, len);
	if (ret) {
	    mlog_log (MDEBFS, "FetchData: copyfd2rx returned %d", ret);
	    goto out;
	}
    }

    fs_update_fs (n, &m, a_fidStatP);

    ret = vld_info_uptodatep (volh);
    if (ret)
	goto out;

    ropa_getcallback (GETHOST(call), GETPORT(call),
		      a_fidToFetchP, a_callBackP, volh->info.type);
    vld_vld2volsync (volh, a_volSyncP);

 out:
    mnode_free (n, FALSE);
    vld_free (volh);

    mlog_log (MDEBFS, "FetchData: ret = %d (at end), calleraccess = %x\n",
	      ret, a_fidStatP->CallerAccess);

    return ret;
}

/*
 *
 */

static int
i2nlist (idlist *ilist, namelist *nlist)
{
    int i;
    /* XXX convert the number is the ilist to name-as-numbers */
    
    nlist->val = malloc(sizeof(nlist->val[0]) * ilist->len);
    if (nlist->val == NULL)
	return ENOMEM;

    for (i = 0; i < ilist->len; i++)
	snprintf(nlist->val[i], sizeof(nlist->val[i]), "%d", ilist->val[i]);
    
    nlist->len = ilist->len;

    return 0;
}


/*
 *
 */

int
SRXAFS_FetchACL(struct rx_call *call,
		const struct AFSFid *a_dirFidP,
		AFSOpaque *a_ACLP,
		struct AFSFetchStatus *a_dirNewStatP,
		struct AFSVolSync *a_volSyncP)
{
    struct volume_handle *volh;
    struct mnode *n;
    struct msec m;
    int ret;
    int i, j;
    char *tempacl, *tempacl_old;
    int num_negacl, num_posacl;
    namelist nlist;
    idlist ilist;

    mlog_log (MDEBFS, "FetchACL: fid: %d.%d.%d", 
	      a_dirFidP->Volume, a_dirFidP->Vnode,
	      a_dirFidP->Unique);

    m.flags = VOLOP_GETSTATUS;

    ret = fs_init_req (a_dirFidP, &m, &volh, call, &n);
    if (ret)
	return ret;

    fs_update_fs (n, &m, a_dirNewStatP);

    assert (n->flags.ep);
    assert (n->flags.fsp);

    if (n->fs.FileType != TYPE_DIR) {
	mnode_free (n, FALSE);
	return EPERM;
    }

    j = 0;
    num_negacl = 0;
    num_posacl = 0;
    nlist.len = 0;
    nlist.val = NULL;
    ilist.val = malloc(2*FS_MAX_ACL*sizeof(int32_t));

    for (i = 0; i < FS_MAX_ACL && n->e.u.dir.acl[i].owner != 0; i++, j++)
	ilist.val[j] = n->e.u.dir.acl[i].owner;
    num_posacl = j;

    for (i = 0; i < FS_MAX_ACL && n->e.u.dir.negacl[i].owner != 0; i++, j++)
	ilist.val[j] = n->e.u.dir.negacl[i].owner;
    num_negacl = j - num_posacl;

    ilist.len = j;

    ret = fs_connsec_idtoname(&ilist, &nlist);
    switch (ret) {
    case ENETDOWN :
    case RX_CALL_DEAD : 

	ret = i2nlist (&ilist, &nlist);
	if (ret)
	    goto err_out;
	
	break;
    case 0:
	break;
    default:
	goto err_out;
    }

    tempacl = NULL;
    tempacl_old = strdup("");

    /* Make string with all positive ACL:s */ 
    for (i = 0; i < num_posacl; i++) {
	if (asprintf(&tempacl, "%s%s %d\n",
		     tempacl_old,
		     nlist.val[i],
		     n->e.u.dir.acl[i].flags) == -1) {
	    ret = EINVAL /* XXX what is the error code? */;
	    free(tempacl_old);
	    goto err_out;
	}
	free(tempacl_old);
	tempacl_old = tempacl;
	tempacl = NULL;
    }

    /* Add negative ACL:s to string */ 
    for (i = 0; i < num_negacl; i++) {
	if (asprintf(&tempacl, "%s%s %d\n",
		     tempacl_old,
		     nlist.val[i+num_posacl],
		     n->e.u.dir.negacl[i].flags) == -1) {
	    ret = EINVAL /* XXX what is the error code? */;
	    free(tempacl_old);
	    goto err_out;
	}
	free(tempacl_old);
	tempacl_old = tempacl;
	tempacl = NULL;
    }

    asprintf(&tempacl, "%d\n%d\n%s",
	     num_posacl, num_negacl, tempacl_old);
    free(tempacl_old);
    tempacl_old = NULL;

    a_ACLP->len = max(strlen(tempacl), AFSOPAQUEMAX);
    a_ACLP->val = tempacl;
    tempacl[a_ACLP->len - 1] = '\0';

 err_out:
    free(ilist.val);
    free(nlist.val);

    vld_vld2volsync (volh, a_volSyncP);

    mnode_free (n, FALSE);
    vld_free (volh);

    return ret;
}

/*
 *
 */

int
SRXAFS_FetchStatus(struct rx_call *call,
		   const struct AFSFid *a_fidToStatP,
		   struct AFSFetchStatus *a_currStatP,
		   struct AFSCallBack *a_callBackP,
		   struct AFSVolSync *a_volSyncP)
{
    struct volume_handle *volh;
    struct mnode *n;
    struct msec m;
    int ret;

    mlog_log (MDEBFS, "FetchStatus: fid: %u.%u.%u", 
	      (uint32_t)a_fidToStatP->Volume, (uint32_t)a_fidToStatP->Vnode,
	      (uint32_t)a_fidToStatP->Unique);

    m.flags = VOLOP_GETSTATUS;

    ret = fs_init_req (a_fidToStatP, &m, &volh, call, &n);
    if (ret)
	goto out;

    fs_update_fs (n, &m, a_currStatP);

    ret = vld_info_uptodatep (volh);
    if (ret)
	goto out_free;

    ropa_getcallback (GETHOST(call), GETPORT(call),
		      a_fidToStatP, a_callBackP, volh->info.type);
    vld_vld2volsync (volh, a_volSyncP);


 out_free:
    mnode_free (n, FALSE);
    vld_free (volh);

 out:
    mlog_log (MDEBFS, "FetchStatus: ret = %d (at end), calleraccess = %x\n",
	      ret, a_currStatP->CallerAccess);

    return ret;
}

/*
 *
 */

int
SRXAFS_StoreData(struct rx_call *call,
		 const struct AFSFid *a_fidToStoreP,
		 const struct AFSStoreStatus *a_fidStatusP,
		 const int32_t a_offset,
		 const int32_t a_lenInBytes,
		 const int32_t a_fileLenInBytes,
		 struct AFSFetchStatus *a_fidStatP,
		 struct AFSVolSync *a_volSyncP)
{
    struct volume_handle *volh;
    struct mnode *n;
    struct msec m;
    int32_t len;
    int32_t *len_p;
    int ret;
    
    mlog_log (MDEBFS, "StoreData: fid: %d.%d.%d", 
	      a_fidToStoreP->Volume, a_fidToStoreP->Vnode,
	      a_fidToStoreP->Unique);
    mlog_log (MDEBFS, "StoreData: offset=%d, len=%d, total=%d",
	      a_offset, a_lenInBytes, a_fileLenInBytes);

#if 0
/* XXX what if offset > previous file length? */
    if(a_offset + a_lenInBytes > a_fileLenInBytes) {
	mlog_log (MDEBFS, "StoreData: ret = %d (wrong len)", EINVAL);
	mlog_log (MDEBFS, "StoreData: offset=%d, len=%d, total=%d",
		  a_offset, a_lenInBytes, a_fileLenInBytes);
	return EINVAL;
    }
#endif

    m.flags = VOLOP_WRITE | VOLOP_GETSTATUS;

    ret = fs_init_req (a_fidToStoreP, &m, &volh, call, &n);
    if (ret) {
	mlog_log (MDEBFS, "StoreData: ret = %d (fs_init_req)", ret);
	return ret;
    }
    
    if (n->fs.FileType == TYPE_DIR) {
	mnode_free (n, FALSE);
	mlog_log (MDEBFS, "StoreData: ret = %d", EPERM);
	return EPERM;
    }
    
    /*
     * newlen = max(offset+length, min(afilelength, oldlen))?
     */

    
    len = min(a_fileLenInBytes, n->fs.Length);

    if (a_offset + a_lenInBytes > len)
	len = a_offset + a_lenInBytes;

    if (len != n->fs.Length)
	len_p = &len;
    else
	len_p = NULL;

    ret = check_ss_bits (&m, a_fidStatusP, FALSE);
    if (ret)
	goto out;
    ret = vld_modify_vnode (volh, n, &m, a_fidStatusP, len_p);

    if (ret == 0 && a_lenInBytes != 0)
	ret = copyrx2fd (call, n->fd, a_offset, a_lenInBytes);

    if (ret == 0) {
	fs_update_fs (n, &m, a_fidStatP);
	vld_vld2volsync (volh, a_volSyncP);
    }

    ropa_break_callback (GETHOST(call), GETPORT(call), a_fidToStoreP, FALSE);
    
 out:
    mnode_free (n, FALSE);
    vld_free (volh);

    mlog_log (MDEBFS, "StoreData: ret = %d (at end), len = %d, calleraccess = %x",
	      ret, a_fidStatP->Length, a_fidStatP->CallerAccess);
    return ret;
}

static void
skipline(char **curptr)
{
    while(**curptr!='\n') (*curptr)++;
    (*curptr)++;
}

/*
 *
 */

int
SRXAFS_StoreACL(struct rx_call *call,
		const struct AFSFid *a_dirFidP,
		const AFSOpaque *a_ACLToStoreP,
		struct AFSFetchStatus *a_dirNewStatP,
		struct AFSVolSync *a_volSyncP)
{
    struct volume_handle *volh;
    struct mnode *n;
    struct msec m;
    int ret;
    namelist nlist;
    idlist ilist;
    char *curptr;
    struct acl_entry negacl[FS_MAX_ACL];
    struct acl_entry acl[FS_MAX_ACL];
    int num_posacl;
    int num_negacl;
    int i;
    
    mlog_log (MDEBFS, "StoreACL: fid: %d.%d.%d", 
	      a_dirFidP->Volume, a_dirFidP->Vnode,
	      a_dirFidP->Unique);

    m.flags = VOLOP_GETSTATUS | VOLOP_ADMIN;

    ret = fs_init_req (a_dirFidP, &m, &volh, call, &n);
    if (ret)
	return ret;

    assert (n->flags.ep);
    if (n->e.type != TYPE_DIR) {
	ret = EINVAL /* XXX */;
	goto err_out;
    }

#if 0
    fprintf(stderr, "%.*s",
	    a_ACLToStoreP->len,
	    a_ACLToStoreP->val);
#endif

    /* parse acl into nlist, acl */

    memset(acl, 0, sizeof(acl));
    memset(negacl, 0, sizeof(negacl));
    
    curptr = a_ACLToStoreP->val;
    curptr[a_ACLToStoreP->len - 1] = '\0';

    if (sscanf(curptr, "%d\n%d\n", &num_posacl, &num_negacl) != 2)
	goto err_out;
    skipline(&curptr);
    skipline(&curptr);
    ilist.len = 0;
    ilist.val = NULL;
    nlist.len = num_posacl + num_negacl;
    nlist.val = malloc(PR_MAXNAMELEN * nlist.len);
    for (i = 0; i < num_posacl; i++) {
	sscanf(curptr, "%63s %d", nlist.val[i], &acl[i].flags);
	skipline(&curptr);
    }
    for (i = 0; i < num_negacl; i++) {
	sscanf(curptr, "%63s %d", nlist.val[i+num_posacl], &negacl[i].flags);
	skipline(&curptr);
    }
    
    ret = fs_connsec_nametoid(&nlist, &ilist);
    if (ret)
	goto err_out;

    assert(nlist.len == ilist.len);

    for (i = 0; i < ilist.len; i++) {
	if (ilist.val[i] == PR_ANONYMOUSID) {
	    ret = ENOENT;
	    goto err_out;
	}
	fprintf(stderr, "%d\n", ilist.val[i]);
    }

    for (i = 0; i < num_posacl; i++)
	acl[i].owner = ilist.val[i];

    for (i = 0; i < num_negacl; i++)
	negacl[i].owner = ilist.val[i+num_posacl];

    memcpy(&n->e.u.dir.acl, acl, sizeof(acl));
    memcpy(&n->e.u.dir.negacl, negacl, sizeof(negacl));

    ret = vld_put_acl(volh, n, &m);
    if (ret)
	goto err_out;

    fs_update_fs (n, &m, a_dirNewStatP);
    ropa_break_callback (GETHOST(call), GETPORT(call), a_dirFidP, FALSE);

    vld_vld2volsync (volh, a_volSyncP);

 err_out:
    mnode_free (n, FALSE);
    vld_free (volh);
    return ret;
}

/*
 *
 */

int
SRXAFS_StoreStatus(struct rx_call *call,
		   const struct AFSFid *a_fidP,
		   const struct AFSStoreStatus *a_currStatusP,
		   struct AFSFetchStatus *a_srStatusP,
		   struct AFSVolSync *a_volSyncP)
{
    struct volume_handle *volh;
    struct mnode *n;
    struct msec m;
    int ret;
    
    mlog_log (MDEBFS, "StoreStatus: fid: %d.%d.%d", 
	      a_fidP->Volume, a_fidP->Vnode,
	      a_fidP->Unique);

    m.flags = VOLOP_GETSTATUS;

    ret = fs_init_req (a_fidP, &m, &volh, call, &n);
    if (ret)
	return ret;

    ret = check_ss_bits (&m, a_currStatusP, TRUE);
    if (ret)
	goto out;
    ret = vld_modify_vnode (volh, n, &m, a_currStatusP, NULL);

    if (ret == 0) {
	fs_update_fs (n, &m, a_srStatusP);
	vld_vld2volsync (volh, a_volSyncP);
    }
 
    ropa_break_callback (GETHOST(call), GETPORT(call), a_fidP, FALSE);
 out:    
    mnode_free (n, FALSE);
    vld_free (volh);

    return ret;
}


/*
 *
 */

static int
removenode (struct rx_call *call,
	    const struct AFSFid *a_dirFidP,
	    const char *a_name,
	    struct AFSFetchStatus *a_srvStatusP,
	    struct AFSVolSync *a_volSyncP,
	    int dirp)
{    
    struct volume_handle *volh;
    struct mnode *n;
    struct mnode *child_n;
    struct msec m, pm;
    AFSFid fid;
    int ret;
    int32_t new_len;
    unsigned long child_linkcount;

    m.flags = VOLOP_GETSTATUS|VOLOP_DELETE;

    ret = fs_init_req (a_dirFidP, &m, &volh, call, &n);
    if (ret)
	return ret;

    assert (n->flags.fdp);
    assert (n->flags.fsp);

    if (n->fs.FileType != TYPE_DIR) {
	mnode_free (n, FALSE);
	return ENOTDIR;
    }

    pm.flags		= VOLOP_GETSTATUS|VOLOP_READ|VOLOP_NOCHECK;
    fs_init_msec (call, &pm);
    pm.loop			= m.loop + 1;

    ret = mdir_lookup(n, a_name, &fid);
    if (ret) {
        mnode_free (n, FALSE);
        vld_free (volh);
        return ret;
    }

    if (afs_dir_p (fid.Vnode) != dirp) {
        mnode_free (n, FALSE);
        vld_free (volh);
        return dirp ? ENOTDIR : EISDIR;
    }

    ret = fs_open_node (&fid, volh, &pm, &child_n);
    if (ret) {
        mnode_free (n, FALSE);
        vld_free (volh);
        return ret;
    }

    if (dirp) {
	ret = mdir_emptyp (child_n);
	if (!ret) {
	    mnode_free (n, FALSE);
	    mnode_free (child_n, FALSE);
	    vld_free (volh);
	    return EEXIST;
	}
    }

    ret = mdir_remove(n, a_name);
    if (ret) {
	mnode_free (n, FALSE);
	mnode_free (child_n, FALSE);
	vld_free (volh);
	return ret;
    }

    /* removes node if necessary */
    ret = vld_adjust_linkcount (volh, child_n, dirp ? -2 : -1); 
    if (ret) {
	mnode_free (n, FALSE);
	mnode_free (child_n, FALSE);
	vld_free (volh);
	return ret;
    }

    child_linkcount = n->fs.LinkCount;

    mnode_free (child_n, FALSE);

    if (dirp) {
	ret = vld_adjust_linkcount (volh, n, -1);
	if (ret) {
	    mnode_free (n, FALSE);
	    vld_free (volh);
	    return ret;
	}
    }
    
    new_len = n->sb.st_size;
    ret = vld_modify_vnode (volh, n, &m, NULL, &new_len);

    fs_update_fs (n, &m, a_srvStatusP);

    fid.Volume = a_dirFidP->Volume;

    if (ret == 0) {
	if (child_linkcount)
	    ropa_break_callback (GETHOST(call), GETPORT(call), &fid, TRUE);
	else {
	    AFSCBFids cbfids;
	    AFSCBs cbs;
	    
	    cbfids.len = 1;
	    cbfids.val = &fid;
	    cbs.len = 0;

	    ropa_drop_callbacks(GETHOST(call), GETPORT(call), &cbfids, &cbs);
	}
	ropa_break_callback (GETHOST(call), GETPORT(call), a_dirFidP, FALSE);
    }

    mnode_free (n, FALSE);
    vld_vld2volsync (volh, a_volSyncP);
    vld_free (volh);

    return ret;
}

/*
 *
 */

int
SRXAFS_RemoveFile(struct rx_call *call,
		  const struct AFSFid *a_dirFidP,
		  const char *a_name,
		  struct AFSFetchStatus *a_srvStatusP,
		  struct AFSVolSync *a_volSyncP)
{
    mlog_log (MDEBFS, "RemoveFile: fid: %d.%d.%d name: %s", 
	      a_dirFidP->Volume, a_dirFidP->Vnode,
	      a_dirFidP->Unique, a_name);

    return removenode (call, a_dirFidP, a_name, a_srvStatusP, 
		       a_volSyncP, FALSE);
}

/*
 *
 */

int
createentry(struct rx_call *call,
	    const struct AFSFid *DirFid,
	    const char *Name,
	    const char *Contents,
	    const struct AFSStoreStatus *InStatus,
	    const struct AFSFid *ExistingFid,
	    struct AFSFid *EntryFid,
	    struct AFSFetchStatus *OutFidStatus,
	    struct AFSFetchStatus *OutDirStatus,
	    struct AFSCallBack *CallBack,
	    struct AFSVolSync *VolSync)
{
    struct volume_handle *volh;
    struct mnode *n;
    struct mnode *child_n;
    struct msec m;
    struct msec child_m;
    AFSFid child;
    int32_t len;
    int ret;

    m.flags = VOLOP_GETSTATUS|VOLOP_INSERT;

    ret = fs_init_req (DirFid, &m, &volh, call, &n);
    if (ret)
	return ret;

    assert (n->flags.fdp);
    assert (n->flags.fsp);
    
    if (n->fs.FileType != TYPE_DIR) {
	mnode_free (n, FALSE);
	vld_free (volh);
	return EPERM;
    }

    child.Volume = volh->vol;

    child_m.flags = VOLOP_GETSTATUS;
    fs_init_msec (call, &child_m);
    child_m.caller_access = m.caller_access;
    child_m.anonymous_access = m.anonymous_access;

    if (InStatus) {
	ret = check_ss_bits (&m, InStatus, TRUE);
	if (ret == 0) {
	    AFSFid existing;
	    ret = mdir_lookup (n, Name, &existing);
	    if (ret == 0)
		ret = EEXIST;
	    else if (ret == ENOENT)
		ret = 0;
	}
	
	if (ret == 0)
	    ret = vld_create_entry (volh, n, &child, 
				    Contents ? TYPE_LINK : TYPE_FILE,
				    InStatus, &child_n, &child_m);
	
	if (ret)
	    goto out_parent;
    } else {
	ret = fs_open_node (ExistingFid, volh, &child_m, &child_n);
	if (ret) {
	    mlog_log(MDEBFS, 
		     "createentry: Failed to open existing fid, ret = %d", ret);
	    goto out_parent;
	}
	
	if (child_n->fs.ParentVnode != DirFid->Vnode
	    || child_n->fs.ParentUnique != DirFid->Unique) {
	    ret = EXDEV;
	    mlog_log (MDEBFS, "createentry: ret = %d (EXDEV)", EXDEV);
	    goto out_child;
	}
	ret = vld_adjust_linkcount (volh, child_n, 1);
	if (ret)
	    goto out_child;

	child = *ExistingFid;
    }

    /* XXX check name ! */
    ret = mdir_creat (n, Name, child);

    if (ret == 0) {
	len = n->sb.st_size;
	ret = vld_modify_vnode (volh, n, &m, NULL, &len);
    }

    if (Contents && ret == 0) {
	assert (child_n->flags.fdp);
	
	len = strlen (Contents);
	ret = write (child_n->fd, Contents, len);
	if (ret != len) {
	    ret = errno;
	    mlog_log (MDEBFS, "createentry: ret = %d (write)", ret);
	} else {
	    ret = vld_modify_vnode (volh, child_n, &child_m, NULL, &len);
	}
    }

    if (ret) {
	mdir_remove (n, Name);
	vld_adjust_linkcount (volh, child_n, -1);
	mnode_free (n, TRUE);
	mnode_free (child_n, TRUE);
	vld_free (volh);
	return ret;
    }

    if (EntryFid)
	*EntryFid = child;

    fs_update_fs (child_n, &child_m, OutFidStatus);
    fs_update_fs (n, &m, OutDirStatus);

    ret = vld_info_uptodatep (volh);
    if (ret)
	goto out_child;

    if (CallBack)
	ropa_getcallback (GETHOST(call), GETPORT(call), EntryFid, CallBack,
			  volh->info.type);
    ropa_break_callback (GETHOST(call), GETPORT(call), DirFid, FALSE);

    vld_vld2volsync (volh, VolSync);
 out_child:
    mnode_free (child_n, FALSE);
 out_parent:
    mnode_free (n, FALSE);
    vld_free (volh);

    return ret;
}

/*
 *
 */

int
SRXAFS_CreateFile(struct rx_call *call,
		  const struct AFSFid *DirFid,
		  const char *Name,
		  const struct AFSStoreStatus *InStatus,
		  struct AFSFid *OutFid,
		  struct AFSFetchStatus *OutFidStatus,
		  struct AFSFetchStatus *OutDirStatus,
		  struct AFSCallBack *CallBack,
		  struct AFSVolSync *a_volSyncP)
{
    int ret;
    
    mlog_log (MDEBFS, "CreateFile: fid: %d.%d.%d name: %s", 
	      DirFid->Volume, DirFid->Vnode,
	      DirFid->Unique, Name);

    ret = createentry(call, DirFid, Name, NULL, InStatus, NULL, OutFid,
		      OutFidStatus, OutDirStatus, CallBack, a_volSyncP);

    if (ret)
	mlog_log (MDEBFS, "CreateFile: failed with ret = %d", ret);
    else
	mlog_log (MDEBFS, "CreateFile: created fid: %d.%d.%d calleraccess: %x", 
		  OutFid->Volume, OutFid->Vnode,
		  OutFid->Unique, OutFidStatus->CallerAccess);
    
    return ret;
}

/*
 *
 */

int
SRXAFS_Rename(struct rx_call *call,
	      const struct AFSFid *a_origDirFidP,
	      const char *a_origNameP,
	      const struct AFSFid *a_newDirFidP,
	      const char *a_newNameP,
	      struct AFSFetchStatus *a_origDirStatusP,
	      struct AFSFetchStatus *a_newDirStatusP,
	      struct AFSVolSync *a_volSyncP)
{
    struct volume_handle *volh;
    AFSFid victim, child;
    struct mnode *orig_n, *new_n = NULL;
    struct mnode *child_n = NULL, *victim_n = NULL;
    struct msec m1, m2;
    struct msec *orig_m = &m1, *new_m = &m2;
    int32_t len1, len2;
    int ret;
    int dirp;
    int same_dir = FALSE;
    int delete_dest = FALSE;
    int victim_deleted = FALSE;

    mlog_log (MDEBFS, "Rename: orig_fid: %d.%d.%d orig_name: %s "
	      "new_fid: %d.%d.%d new_name: %s", 
	      a_origDirFidP->Volume, a_origDirFidP->Vnode,
	      a_origDirFidP->Unique, a_origNameP,
	      a_newDirFidP->Volume, a_newDirFidP->Vnode,
	      a_newDirFidP->Unique, a_newNameP);

    if (a_origDirFidP->Volume != a_newDirFidP->Volume)
	return EXDEV;

    if (!(afs_dir_p(a_origDirFidP->Vnode)) 
	|| !(afs_dir_p(a_newDirFidP->Vnode)))
	return EPERM;

    if (a_origDirFidP->Vnode == a_newDirFidP->Vnode &&
	a_origDirFidP->Unique == a_newDirFidP->Unique) {
	same_dir = TRUE;
	orig_m->flags = VOLOP_GETSTATUS|VOLOP_INSERT|VOLOP_DELETE;
    } else {
	orig_m->flags = VOLOP_GETSTATUS|VOLOP_DELETE;
    }

    ret = fs_init_req (a_origDirFidP, orig_m, &volh, call, &orig_n);
    if (ret)
	return ret;

    assert (orig_n->flags.fdp);
    assert (orig_n->flags.fsp);

    ret = mdir_lookup(orig_n, a_origNameP, &child);
    if (ret == 0)
	ret = fs_open_node (&child, volh, orig_m, &child_n);
    if (ret) {
	mnode_free (orig_n, FALSE);
	return ret;
    }

    assert(child_n->flags.fsp);

    dirp = afs_dir_p(child.Vnode);
    if (same_dir == FALSE && child_n->fs.LinkCount != (dirp ? 2 : 1)) {
	ret = EXDEV;
	goto out1;
    }

    if (same_dir == TRUE) {
	new_n = orig_n;
	new_m = orig_m;
    } else {

	new_m->flags = VOLOP_GETSTATUS|VOLOP_INSERT|VOLOP_DELETE;
	
	/* XXX */
	ret = fs_init_msec(call, new_m);
	ret = fs_open_node (a_newDirFidP, volh, new_m, &new_n);
	if (ret) {
	    new_m->flags = VOLOP_GETSTATUS|VOLOP_INSERT;
	    
	    /* XXX */
	    ret = fs_open_node (a_newDirFidP, volh, new_m, &new_n);
	    if (ret) {
		mnode_free (orig_n, FALSE);
		vld_free (volh);
		return ret;
	    }
	}
    }
    
    ret = mdir_lookup(new_n, a_newNameP, &victim);
    if (!ret) {
	if (!(new_m->flags & VOLOP_DELETE)
	    || afs_dir_p(victim.Vnode) != dirp) {
	    ret = EPERM;
	    goto out1;
	}
	delete_dest = TRUE;
	ret = fs_open_node (&victim, volh, new_m, &victim_n);
	if (ret)
	    goto out1;
	
	assert(victim_n->flags.fsp);
	
	if (child_n->fs.LinkCount != (dirp ? 2 : 1)) {
	    ret = EPERM;
	    mnode_free(victim_n, FALSE);
	    goto out1;
	}
    }
    
    ret = mdir_rename(orig_n, a_origNameP, &len1,
		      new_n, a_newNameP, &len2);

    if (ret) {
	if (delete_dest == TRUE)
	    mnode_free(victim_n, FALSE);
	goto out1;
    }

    if (!ret && dirp) {
	ret = mdir_changefid(child_n, "..", *a_newDirFidP);
	if (ret) {
	    /* XXX recover */
	}
    }

    if (delete_dest == TRUE) {
	/* remove the node if necessary */
	ret = vld_adjust_linkcount (volh, victim_n, 
				    -(afs_dir_p(victim.Vnode) ? 2 : 1));
	if (victim_n->fs.LinkCount == 0)
	    victim_deleted = TRUE;

	mnode_free(victim_n, FALSE);
	if (ret) {
	    /* 
	     * XXX Remove failed, try to recover.
	     * Do not check for error, things are bad anyway.
	     * Maybe this should cause a shutdown + salvage?
	     */
	    goto out1;
	}
    }

    /* Update linkcount on parents if directory move */
    if (dirp && !same_dir) {
	ret = vld_adjust_linkcount (volh, orig_n, -1);
	ret = vld_adjust_linkcount (volh, new_n, 1);
    }

    /* XXX update st_ctime and st_mtime of both parents */

    vld_modify_vnode (volh, orig_n, orig_m, NULL, &len1);
    if (!same_dir)
        vld_modify_vnode (volh, new_n, new_m, NULL, &len2);

    fs_update_fs (orig_n, orig_m, a_origDirStatusP);
    fs_update_fs (new_n, new_m, a_newDirStatusP);

    ropa_break_callback (GETHOST(call), GETPORT(call), a_origDirFidP, FALSE);
    if (!same_dir) {
	ropa_break_callback (GETHOST(call),GETPORT(call), a_newDirFidP, FALSE);
	if (dirp)
	    ropa_break_callback (GETHOST(call), GETPORT(call), &child, FALSE);
    }

    if (victim_deleted == TRUE) {
	AFSCBFids cbfids;
	AFSCBs cbs;
	
	cbfids.len = 1;
	cbfids.val = &victim;
	cbs.len = 0;
	
	ropa_drop_callbacks(GETHOST(call), GETPORT(call), &cbfids, &cbs);
    } else
	ropa_break_callback(GETHOST(call), GETPORT(call), &victim, TRUE);
	    
 out1:
    mnode_free (orig_n, FALSE);
    if (child_n)
	mnode_free (child_n, FALSE);
    if (!same_dir && new_n)
	mnode_free (new_n, FALSE);

    if (ret == 0)
	vld_vld2volsync (volh, a_volSyncP);

    vld_free (volh);

    return ret;
}

/*
 *
 */

int
SRXAFS_Symlink(struct rx_call *call,
	       const struct AFSFid *a_dirFidP,
	       const char *a_nameP,
	       const char *a_linkContentsP,
	       const struct AFSStoreStatus *a_origDirStatP,
	       struct AFSFid *a_newFidP,
	       struct AFSFetchStatus *a_newFidStatP,
	       struct AFSFetchStatus *a_newDirStatP,
	       struct AFSVolSync *a_volSyncP)
{
    int ret;

    mlog_log (MDEBFS, "Symlink: fid: %d.%d.%d name: %s content: %s", 
	      a_dirFidP->Volume, a_dirFidP->Vnode,
	      a_dirFidP->Unique, a_nameP, a_linkContentsP);

    ret = createentry(call, a_dirFidP, a_nameP, a_linkContentsP,
		      a_origDirStatP, NULL, a_newFidP, a_newFidStatP, 
		      a_newDirStatP, NULL, a_volSyncP);

    if (ret)
	mlog_log (MDEBFS, "Symlink: failed with ret = %d", ret);
    else
	mlog_log (MDEBFS, "Symlink: created fid: %d.%d.%d calleraccess: %x", 
		  a_newFidP->Volume, a_newFidP->Vnode,
		  a_newFidP->Unique, a_newFidStatP->CallerAccess);

    return ret;
}

/*
 *
 */

int
SRXAFS_Link(struct rx_call *call,
	    const struct AFSFid *a_dirFidP,
	    const char *a_nameP,
	    const struct AFSFid *a_existingFidP,
	    struct AFSFetchStatus *a_newFidStatP,
	    struct AFSFetchStatus *a_newDirStatP,
	    struct AFSVolSync *a_volSyncP)
{
    int ret;

    mlog_log (MDEBFS, "Link: fid: %d.%d.%d name: %s existing", 
	      a_dirFidP->Volume, a_dirFidP->Vnode,
	      a_dirFidP->Unique, a_nameP);
    
    if (afs_dir_p(a_existingFidP->Vnode)) 
	return EISDIR;

    ret = createentry(call, a_dirFidP, a_nameP, NULL, NULL, a_existingFidP,
		      NULL, a_newFidStatP, a_newDirStatP, NULL, a_volSyncP);

    if (ret)
	mlog_log (MDEBFS, "Link: failed with ret = %d", ret);
    else
	mlog_log (MDEBFS, "Link: created name: %s calleraccess: %x", 
		  a_nameP, a_newFidStatP->CallerAccess);

    return ret;
}

/*
 *
 */

int
SRXAFS_MakeDir(struct rx_call *call,
	       const struct AFSFid *a_parentDirFidP,
	       const char *a_newDirNameP,
	       const struct AFSStoreStatus *a_currStatP,
	       struct AFSFid *a_newDirFidP,
	       struct AFSFetchStatus *a_dirFidStatP,
	       struct AFSFetchStatus *a_parentDirStatP,
	       struct AFSCallBack *a_newDirCallBackP,
	       struct AFSVolSync *a_volSyncP)
{
    struct volume_handle *volh;
    struct mnode *n;
    struct mnode *child_n;
    struct msec m;
    struct msec child_m;
    int ret;
    AFSFid child;
    
    mlog_log (MDEBFS, "MakeDir: fid: %d.%d.%d name: %s", 
	      a_parentDirFidP->Volume, a_parentDirFidP->Vnode,
	      a_parentDirFidP->Unique, a_newDirNameP);

    m.flags = VOLOP_WRITE | VOLOP_INSERT | VOLOP_GETSTATUS;

    ret = fs_init_req (a_parentDirFidP, &m, &volh, call, &n);
    if (ret)
	return ret;

    if (n->fs.FileType != TYPE_DIR) {
	mnode_free (n, FALSE);
	return EPERM;
    }

    child.Volume = volh->vol;
    
    ret = check_ss_bits (&m, a_currStatP, TRUE);
    if (ret)
	goto out_parent;

    child_m.flags = VOLOP_GETSTATUS;
    fs_init_msec(call, &child_m);
    ret = vld_create_entry (volh, n, &child, TYPE_DIR,
			    a_currStatP, &child_n, &child_m);
    if (ret)
	goto out_parent;

    ret = vld_adjust_linkcount (volh, n, 1);
    if (ret) {
	mnode_free (n, FALSE);
	mnode_free (child_n, FALSE);
	vld_free (volh);
	return ret;
    }

    /* XXX check name ! */
    ret = mdir_creat (n, a_newDirNameP, child);

    if (ret == 0) {
	int32_t len = n->sb.st_size;
	ret = vld_modify_vnode (volh, n, &m, NULL, &len);
    }

    if (ret) {
	/* XXX adjust directory size? */
	vld_adjust_linkcount (volh, n, -1);
	vld_adjust_linkcount (volh, child_n, -1); /* removes node if necessary */
	mnode_free (n, FALSE);
	mnode_free (child_n, TRUE);
	vld_free (volh);
	return ret;
    }

    *a_newDirFidP = child;
    fs_update_fs (n, &m, a_parentDirStatP);
    fs_update_fs (child_n, &m, a_dirFidStatP);
    vld_vld2volsync (volh, a_volSyncP);

    memcpy(&child_n->e.u.dir.acl, &n->e.u.dir.acl,
	   sizeof(n->e.u.dir.acl));
    memcpy(&child_n->e.u.dir.negacl, &n->e.u.dir.negacl,
	   sizeof(n->e.u.dir.negacl));

    ret = vld_put_acl(volh, child_n, &child_m);
    if (ret) {
	/* XXX adjust directory size? */
	vld_adjust_linkcount (volh, n, -1);
	vld_adjust_linkcount (volh, child_n, -1); /* removes node if necessary */
	mnode_free (n, FALSE);
	mnode_free (child_n, TRUE);
	vld_free (volh);
	return ret;
    }
    ropa_break_callback (GETHOST(call), GETPORT(call), a_parentDirFidP, FALSE);

    ret = vld_info_uptodatep (volh);
    if (ret)
	goto out_child;

    ropa_getcallback (GETHOST(call), GETPORT(call),
		      a_newDirFidP, a_newDirCallBackP,
		      volh->info.type);
    
    mlog_log (MDEBFS, "MakeDir: created child fid: %d.%d.%d", 
	      a_newDirFidP->Volume, a_newDirFidP->Vnode,
	      a_newDirFidP->Unique);

 out_child:
    mnode_free (child_n, FALSE);
 out_parent:
    mnode_free (n, FALSE);
    vld_free (volh);

    return ret;
}

/*
 *
 */

int
SRXAFS_RemoveDir(struct rx_call *call,
		 const struct AFSFid *a_parentDirP,
		 const char *a_dirNameP,
		 struct AFSFetchStatus *a_newParentDirStatP,
		 struct AFSVolSync *a_volSyncP)
{
    mlog_log (MDEBFS, "RemoveDir: fid: %d.%d.%d name: %s", 
	      a_parentDirP->Volume, a_parentDirP->Vnode,
	      a_parentDirP->Unique, a_dirNameP);

    return removenode (call, a_parentDirP, a_dirNameP, 
		       a_newParentDirStatP, a_volSyncP, TRUE);
}

/*
 *
 */

int
SRXAFS_GiveUpCallBacks(struct rx_call *call,
		       const AFSCBFids *a_fidArrayP,
		       const AFSCBs *a_callBackArrayP)
{
    int ret;

    mlog_log (MDEBFS, "GiveUpCallBacks");

    ret = ropa_drop_callbacks (GETHOST(call), GETPORT(call), 
			       a_fidArrayP, a_callBackArrayP);
    if (ret)
	mlog_log (MDEBFS, "GiveUpCallBacks: returning %d", ret);

    return ret;
}

/*
 *
 */

int
SRXAFS_GetVolumeStatus(struct rx_call *call,
		       const int32_t a_volIDP,
		       struct AFSFetchVolumeStatus *a_volFetchStatP,
		       char *a_volNameP,
		       char *a_offLineMsgP,
		       char *a_motdP)
{
    struct volume_handle *volh;
    AFSFid fid;
    struct msec m;
    int ret;

    mlog_log (MDEBFS, "GetVolumeStats: vol: %d", a_volIDP);

    m.flags = VOLOP_GETSTATUS;
    fid.Volume = a_volIDP;

    ret = fs_init_req (&fid, &m, &volh, call, NULL);
    if (ret) {
	mlog_log (MDEBFS, "GetVolumeStatus: fs_init_req returned %d", ret);
	return ret;
    }

    ret = vld_get_volstats (volh, a_volFetchStatP, a_volNameP,
			    a_offLineMsgP, a_motdP);
    return ret;
}

/*
 *
 */

int
SRXAFS_SetVolumeStatus(struct rx_call *call,
		       const int32_t a_volIDP,
		       const struct AFSStoreVolumeStatus *a_volStoreStatP,
		       const char *a_volNameP,
		       const char *a_offLineMsgP,
		       const char *a_motdP)
{
    struct volume_handle *volh;
    AFSFid fid;
    struct msec m;
    int ret;

    mlog_log (MDEBFS, "SRXAFS_SetVolumeStatus: vol: %d", a_volIDP);

    m.flags = 0;
    fid.Volume = a_volIDP;
    fid.Vnode = 1;
    fid.Unique = 1;

    ret = fs_init_req (&fid, &m, &volh, call, NULL);
    if (ret) {
	goto out;
    }

    if (!super_user(&m)) {
	ret = EPERM;
	goto out;
    }

    ret = vld_set_volstats (volh, a_volStoreStatP, a_volNameP,
			    a_offLineMsgP, a_motdP);

 out:
    vld_free (volh);
    mlog_log (MDEBFS, "SRXAFS_SetVolumeStatus: fs_init_req returned %d", ret);
    return ret;
}

/*
 *
 */

int
SRXAFS_GetRootVolume(struct rx_call *call,
		     char *a_rootVolNameP)
{
    mlog_log (MDEBFS, "GetRootVolume");

    strlcpy (a_rootVolNameP, "root.cell", AFSNAMEMAX);
    a_rootVolNameP[AFSNAMEMAX-1] = '\0';
    return 0;
}

/*
 * Get time, the poor mans ntp, used as probe by some clients
 */

int
SRXAFS_GetTime(struct rx_call *call,
	       uint32_t *a_secondsP,
	       uint32_t *a_uSecondsP)
{
    struct timeval tv;

    mlog_log (MDEBFS, "GetTime");

    gettimeofday (&tv, NULL);

    *a_secondsP = tv.tv_sec;
    *a_uSecondsP = tv.tv_usec;

    return 0;
}

/*
 *
 */

int
SRXAFS_NGetVolumeInfo(struct rx_call *call,
		      const char *VolumeName,
		      struct AFSVolumeInfo *stuff)
{
    return EPERM;
}

/*
 *
 */

int
SRXAFS_BulkStatus(struct rx_call *call,
		  const AFSCBFids *FidsArray,
		  AFSBulkStats *StatArray,
		  AFSCBs *CBArray,
		  struct AFSVolSync *Sync)
{
    struct volume_handle *volh = NULL;
    struct mnode *n;
    struct msec m;
    int ret, i = 0;
    int32_t oldvolume = -1;

    mlog_log (MDEBFS, "BulkStatus");

    CBArray->val = NULL;
    CBArray->len = 0;
    StatArray->val = NULL;
    StatArray->len = 0;

    if (FidsArray->len == 0)
	return 0;

    m.flags = VOLOP_GETSTATUS;

    ret = fs_init_msec (call, &m);
    if (ret)
	return ret;

    StatArray->len = FidsArray->len;
    StatArray->val = malloc(StatArray->len * sizeof(StatArray->val[0]));
    if (StatArray->val == NULL)
	return ENOMEM;

    CBArray->len   = FidsArray->len;
    CBArray->val   = malloc(CBArray->len * sizeof(CBArray->val[0]));
    if(CBArray->val == NULL) {
	free(StatArray->val);
	return ENOMEM;
    }

    for (i = 0; FidsArray->len > i ; i++) {
	
	if (FidsArray->val[i].Volume != oldvolume) {
	    if (volh)
		vld_free (volh);
	    
	    ret = vld_find_vol (FidsArray->val[i].Volume, &volh);
	    if (ret)
		return ret;

	    if (volh->flags.offlinep) {
		vld_free (volh);
		return VOFFLINE;
	    }
	    
	    ret = vld_db_uptodate (volh);
	    if (ret) {
		vld_free (volh);
		return ret;
	    }
	    oldvolume = FidsArray->val[i].Volume;
	}
	
	ret = fs_open_node (&FidsArray->val[i], volh, &m, &n);
	if (ret) {
	    vld_free (volh);
	    return ret;
	}
	
	fs_update_fs (n, &m, &StatArray->val[i]);
    
	mnode_free (n, FALSE);
	n = NULL;
	
	ret = vld_info_uptodatep (volh);
	if (ret)
	    goto out;

	ropa_getcallback (GETHOST(call), GETPORT(call), 
			  &FidsArray->val[i], &CBArray->val[i],
			  volh->info.type);
    }

 out:
    vld_free (volh);

    return 0;
}

/*
 *
 */

int
SRXAFS_SetLock(struct rx_call *call,
	       const struct AFSFid *Fid,
	       const ViceLockType Type,
	       struct AFSVolSync *Sync)
{
    return EPERM;
}

/*
 *
 */

int
SRXAFS_ExtendLock(struct rx_call *call,
		  const struct AFSFid *Fid,
		  struct AFSVolSync *Sync)
{
    return EPERM;
}


/*
 *
 */

int
SRXAFS_ReleaseLock(struct rx_call *call,
		   const struct AFSFid *Fid,
		   struct AFSVolSync *Sync)
{
    return EPERM;
}
@


1.3
log
@Merge
@
text
@@


1.2
log
@merge
@
text
@d2 1
a2 1
 * Copyright (c) 1999 - 2000 Kungliga Tekniska Högskolan
d36 1
a36 1
RCSID("$KTH: fsprocs.c,v 1.55 2001/01/01 20:50:23 lha Exp $");
d41 13
d91 10
d107 1
a107 1
check_ss_bits (const struct msec *sec, const AFSStoreStatus *status,
a110 1
     * set VOLOP_ADMIN (might do this a tad earlier too)
d114 1
a114 2
	if (status->Owner != sec->sec->uid
	    && (sec->flags & VOLOP_ADMIN) != 0)
d117 2
a118 2
	    ((AFSStoreStatus *)status)->Mask |= SS_OWNER; /* XXX */
	    ((AFSStoreStatus *)status)->Owner = sec->sec->uid; /* XXX */
d122 1
a122 2
	if ((07000 & status->UnixModeBits) != 0
	    && (sec->flags & VOLOP_ADMIN) != 0)
d129 1
a129 1
 * Given `fid', `volh' and `m' open node `n'.
d134 1
a134 1
	      struct msec *m, struct mnode **n)
d140 1
a140 1
	return ret;
d143 3
d148 1
a151 1

d178 1
a178 1
    if ((*volh)->flags.offlinep == TRUE) {
d190 4
a193 1
    ret = vld_db_uptodate (*volh);
d199 3
a201 2
    ret = fs_open_node (fid, *volh, m, n);
    if (ret) {
d203 1
a203 1
	return ret;
d206 1
a206 1
    ret = vld_check_rights (*volh, *n, m);
a207 1
	mnode_free (*n, FALSE);
d209 9
d228 7
a234 7
RXAFS_FetchData(struct rx_call *call,
		const struct AFSFid *a_fidToFetchP,
		const int32_t a_offset,
		const int32_t a_lenInBytes,
		struct AFSFetchStatus *a_fidStatP,
		struct AFSCallBack *a_callBackP,
		struct AFSVolSync *a_volSyncP)
d283 5
d289 1
a289 1
		      a_fidToFetchP, a_callBackP);
d292 1
a292 1
out:
d309 1
d311 11
a321 1
    return ENETDOWN;
d330 5
a334 5
RXAFS_FetchACL(struct rx_call *call,
	       const struct AFSFid *a_dirFidP,
	       AFSOpaque *a_ACLP,
	       struct AFSFetchStatus *a_dirNewStatP,
	       struct AFSVolSync *a_volSyncP)
d340 1
a340 1
    int i;
d366 3
a370 1
    ilist.len = 2*FS_MAX_ACL;
d373 9
a381 6
    for (i = 0; i < FS_MAX_ACL; i++) {
	ilist.val[i] = n->e.u.dir.acl[i].owner;
    }
    for (i = 0; i < FS_MAX_ACL; i++) {
	ilist.val[i+FS_MAX_ACL] = n->e.u.dir.negacl[i].owner;
    }
d393 2
a400 2
    num_negacl = 0;
    num_posacl = 0;
d403 5
a407 7
    for (i = 0; i < FS_MAX_ACL; i++) {
	if (n->e.u.dir.acl[i].owner == 0)
	    continue;
	if (asnprintf(&tempacl, AFSOPAQUEMAX, "%s%s %d\n",
		      tempacl_old,
		      nlist.val[i],
		      n->e.u.dir.acl[i].flags) == -1) {
a411 1
	num_posacl++;
d418 5
a422 7
    for (i = 0; i < FS_MAX_ACL; i++) {
	if (n->e.u.dir.negacl[i].owner == 0)
	    continue;
	if (asnprintf(&tempacl, AFSOPAQUEMAX, "%s%s %d\n",
		      tempacl_old,
		      nlist.val[i+FS_MAX_ACL],
		      n->e.u.dir.negacl[i].flags) == -1) {
a426 1
	num_negacl++;
d432 2
a433 2
    asnprintf(&tempacl, AFSOPAQUEMAX, "%d\n%d\n%s",
	      num_posacl, num_negacl, tempacl_old);
d437 1
a437 1
    a_ACLP->len = strlen(tempacl);
d439 1
d458 5
a462 5
RXAFS_FetchStatus(struct rx_call *call,
		  const struct AFSFid *a_fidToStatP,
		  struct AFSFetchStatus *a_currStatP,
		  struct AFSCallBack *a_callBackP,
		  struct AFSVolSync *a_volSyncP)
d470 2
a471 2
	      (u_int32_t)a_fidToStatP->Volume, (u_int32_t)a_fidToStatP->Vnode,
	      (u_int32_t)a_fidToStatP->Unique);
d477 1
a477 1
	return ret;
d480 5
d486 1
a486 1
		      a_fidToStatP, a_callBackP);
d489 2
d494 1
d506 8
a513 8
RXAFS_StoreData(struct rx_call *call,
		const struct AFSFid *a_fidToStoreP,
		const struct AFSStoreStatus *a_fidStatusP,
		const int32_t a_offset,
		const int32_t a_lenInBytes,
		const int32_t a_fileLenInBytes,
		struct AFSFetchStatus *a_fidStatP,
		struct AFSVolSync *a_volSyncP)
d603 5
a607 5
RXAFS_StoreACL(struct rx_call *call,
	       const struct AFSFid *a_dirFidP,
	       const AFSOpaque *a_ACLToStoreP,
	       struct AFSFetchStatus *a_dirNewStatP,
	       struct AFSVolSync *a_volSyncP)
d626 1
a626 4
    m.flags = VOLOP_WRITE | VOLOP_GETSTATUS | VOLOP_ADMIN;
#if 1
    m.flags |= VOLOP_NOCHECK; /* XXX */
#endif
d712 5
a716 5
RXAFS_StoreStatus(struct rx_call *call,
		  const struct AFSFid *a_fidP,
		  const struct AFSStoreStatus *a_currStatusP,
		  struct AFSFetchStatus *a_srStatusP,
		  struct AFSVolSync *a_volSyncP)
a763 1
    fbuf the_fbuf;
d766 3
a768 2
    struct msec m;
    VenusFid parentFid, fid;
d771 2
a772 1
    
d787 5
a791 2
    ret = fbuf_create (&the_fbuf, n->fd, n->fs.Length, 
		       FBUF_READ|FBUF_WRITE|FBUF_SHARED);
d793 9
a801 3
	mnode_free (n, FALSE);
	vld_free (volh);
	return ret;
d804 1
a804 4
    parentFid.Cell = 0;
    parentFid.fid = n->fid;
    
    ret = fdir_lookup (&the_fbuf, &parentFid, a_name, &fid);
d806 3
a808 11
	fbuf_end (&the_fbuf);
	mnode_free (n, FALSE);
	vld_free (volh);
	return ret;
    }
	
    if (afs_dir_p (fid.fid.Vnode) != dirp) {
	fbuf_end (&the_fbuf);
	mnode_free (n, FALSE);
	vld_free (volh);
	return dirp ? ENOTDIR : EISDIR;
d812 1
a812 32
	fbuf dirfbuf;
	struct msec pm;
	struct mnode *parent_n;

	pm.flags		= VOLOP_GETSTATUS|VOLOP_READ|VOLOP_NOCHECK;
	fs_init_msec (call, &pm);
	pm.loop			= m.loop + 1;
	
	ret = fs_open_node (&fid.fid, volh, &pm, &parent_n);
	if (ret) {
	    fbuf_end (&the_fbuf);
	    mnode_free (n, FALSE);
	    vld_free (volh);
	    return ret;
	}

	assert (parent_n->flags.fdp);
	assert (parent_n->flags.fsp);

	ret = fbuf_create (&dirfbuf, parent_n->fd, parent_n->fs.Length, 
			   FBUF_READ|FBUF_PRIVATE);
	if (ret) {
	    fbuf_end (&the_fbuf);
	    mnode_free (parent_n, FALSE);
	    mnode_free (n, FALSE);
	    vld_free (volh);
	    return ret;
	}

	ret = fdir_emptyp (&dirfbuf);
	fbuf_end (&dirfbuf);
	mnode_free (parent_n, TRUE);
a813 1
	    fbuf_end (&the_fbuf);
d815 1
d817 1
a817 1
	    return ENOTEMPTY;
d821 1
a821 5
    ret = fdir_remove (&the_fbuf, a_name, &fid.fid);

    new_len = fbuf_len (&the_fbuf);
    fbuf_end (&the_fbuf);

d824 1
d829 2
a830 2
    mnode_remove (&fid.fid);
    ret = vld_remove_node (volh, fid.fid.Vnode);
d833 1
d837 5
d850 2
a851 1

d856 1
a856 1
    fid.fid.Volume = a_dirFidP->Volume;
d859 12
a870 1
	ropa_break_callback (GETHOST(call), GETPORT(call), &fid.fid, TRUE);
d886 5
a890 5
RXAFS_RemoveFile(struct rx_call *call,
		 const struct AFSFid *a_dirFidP,
		 const char *a_name,
		 struct AFSFetchStatus *a_srvStatusP,
		 struct AFSVolSync *a_volSyncP)
d905 11
a915 9
RXAFS_CreateFile(struct rx_call *call,
		 const struct AFSFid *DirFid,
		 const char *Name,
		 const struct AFSStoreStatus *InStatus,
		 struct AFSFid *OutFid,
		 struct AFSFetchStatus *OutFidStatus,
		 struct AFSFetchStatus *OutDirStatus,
		 struct AFSCallBack *CallBack,
		 struct AFSVolSync *a_volSyncP)
d923 1
a924 4
    
    mlog_log (MDEBFS, "CreateFile: fid: %d.%d.%d name: %s", 
	      DirFid->Volume, DirFid->Vnode,
	      DirFid->Unique, Name);
d937 1
d948 35
a982 3
    ret = check_ss_bits (&m, InStatus, TRUE);
    if (ret)
	goto out_parent;
d984 2
a985 4
    ret = vld_create_entry (volh, n, &child, TYPE_FILE,
			    InStatus, &child_n, &child_m);
    if (ret)
	goto out_parent;
d991 1
a991 1
	int32_t len = n->sb.st_size;
d995 13
d1009 2
a1013 2
	mnode_remove (&child);
	vld_remove_node (volh, child.Vnode);
d1017 3
d1023 3
a1025 2
    if (ret == 0)
	*OutFid = child;
d1027 4
a1030 6
    if (ret == 0) {
	ropa_getcallback (GETHOST(call), GETPORT(call),
			  OutFid, CallBack);
	ropa_break_callback (GETHOST(call), GETPORT(call), DirFid, FALSE);
	
    }
d1032 2
a1036 1
    vld_vld2volsync (volh, a_volSyncP);
d1039 26
a1064 3
    mlog_log (MDEBFS, "CreateFile: created fid: %d.%d.%d calleraccess: %x", 
	      OutFid->Volume, OutFid->Vnode,
	      OutFid->Unique, OutFidStatus->CallerAccess);
d1066 7
d1081 8
a1088 8
RXAFS_Rename(struct rx_call *call,
	     const struct AFSFid *a_origDirFidP,
	     const char *a_origNameP,
	     const struct AFSFid *a_newDirFidP,
	     const char *a_newNameP,
	     struct AFSFetchStatus *a_origDirStatusP,
	     struct AFSFetchStatus *a_newDirStatusP,
	     struct AFSVolSync *a_volSyncP)
d1091 6
a1096 7
    fbuf origfbuf;
    fbuf newfbuf;
    fbuf *newfbufP = &newfbuf;
    VenusFid child, origVFid;
    struct mnode *orig_n, *new_n;
    struct msec orig_m;
    struct msec new_m;
d1098 1
d1100 3
a1102 1
    
d1113 3
a1115 4
    orig_m.flags = VOLOP_GETSTATUS|VOLOP_DELETE;
    if (a_origDirFidP->Vnode == a_newDirFidP->Vnode
	&& a_origDirFidP->Unique == a_newDirFidP->Unique)
	orig_m.flags |= VOLOP_INSERT;
d1117 9
a1125 1
    ret = fs_init_req (a_origDirFidP, &orig_m, &volh, call, &orig_n);
d1132 3
a1134 10
    if (orig_n->fs.FileType != TYPE_DIR) {
	mnode_free (orig_n, FALSE);
	return EPERM;
    }

    origVFid.Cell = 0;
    origVFid.fid = *a_origDirFidP;

    ret = fbuf_create (&origfbuf, orig_n->fd, orig_n->sb.st_size, 
		       FBUF_READ|FBUF_WRITE|FBUF_SHARED);
a1136 1
	vld_free (volh);
d1140 6
a1145 6
    ret = fdir_lookup(&origfbuf, &origVFid, a_origNameP, &child);
    if (ret) {
	fbuf_end (&origfbuf);
	mnode_free (orig_n, FALSE);
	vld_free (volh);
	return ret;
d1148 3
a1150 5
    if (a_origDirFidP->Vnode == a_newDirFidP->Vnode &&
	a_origDirFidP->Unique == a_newDirFidP->Unique) {

	newfbufP = &origfbuf;
	same_dir = TRUE;
d1153 2
a1154 2
	new_m.flags = VOLOP_GETSTATUS|VOLOP_INSERT;

d1156 2
a1157 1
	ret = fs_init_req (a_newDirFidP, &new_m, &volh, call, &new_n);
d1159 30
a1188 4
	    fbuf_end (&origfbuf);
	    mnode_free (orig_n, FALSE);
	    vld_free (volh);
	    return ret;
d1190 4
d1195 5
a1199 7
	if (new_n->fs.FileType != TYPE_DIR) {
	    mnode_free (new_n, FALSE);
	    fbuf_end (&origfbuf);
	    mnode_free (orig_n, FALSE);
	    vld_free (volh);
	    return EPERM;
	}
d1201 2
a1202 3
	ret = fbuf_create (&newfbuf, new_n->fd, 
			   new_n->sb.st_size, 
			   FBUF_READ|FBUF_WRITE|FBUF_SHARED);
d1204 1
a1204 5
	    mnode_free (new_n, FALSE);
	    fbuf_end (&origfbuf);
	    mnode_free (orig_n, FALSE);
	    vld_free (volh);
	    return ret;
d1208 6
a1213 3
    {
	VenusFid sentenced_file;
	VenusFid dir;
d1215 8
a1222 26
	dir.fid = *a_newDirFidP;
	dir.Cell = 0;

	if(fdir_lookup(newfbufP, &dir, a_newNameP, &sentenced_file)) {
	    ret = fdir_creat (newfbufP, a_newNameP, child.fid);
	    if (ret) 
		goto out1;
	} else {
	    if (afs_dir_p (sentenced_file.fid.Vnode)) { /* XXX check properly */
		ret = EISDIR;
		goto out1;
	    }
	    mnode_remove (&sentenced_file.fid);
	    ret = fdir_changefid(newfbufP, a_newNameP, &child);
	    if (ret)
		goto out1;
	    ret = vld_remove_node(volh, sentenced_file.fid.Vnode);
	    if (ret) {
		/* 
		 * Remove failed, try to recover.
		 * Do not check for error, things are bad anyway.
		 * Maybe this should cause a shutdown + salvage?
		 */
		fdir_changefid(newfbufP, a_newNameP, &sentenced_file);
		goto out1;
	    }
d1226 4
a1229 9
    ret = fdir_remove (&origfbuf, a_origNameP, NULL);
    if (ret == 0) {
	int32_t len;
	len = fbuf_len (&origfbuf);
	vld_modify_vnode (volh, orig_n, &orig_m, NULL, &len);
	if (!same_dir) {
	    len = fbuf_len (newfbufP);
	    vld_modify_vnode (volh, new_n, &new_m, NULL, &len);
	}
d1232 1
a1232 1
    /* XXX Update linkcount on parents if directory move */
d1234 1
a1234 1
    fs_update_fs (orig_n, &orig_m, a_origDirStatusP);
d1236 4
a1239 3
	fs_update_fs (new_n, &new_m, a_newDirStatusP);
    else
	fs_update_fs (orig_n, &orig_m, a_newDirStatusP);
d1242 1
a1242 1
    if (!same_dir)
d1244 3
a1246 2
    /* Don't break child since data hasn't changed */
    
d1248 12
a1260 1
    fbuf_end (&origfbuf);
d1262 3
a1264 2
    if (!same_dir) {
	fbuf_end (&newfbuf);
a1265 1
    }
d1280 9
a1288 9
RXAFS_Symlink(struct rx_call *call,
	      const struct AFSFid *a_dirFidP,
	      const char *a_nameP,
	      const char *a_linkContentsP,
	      const struct AFSStoreStatus *a_origDirStatP,
	      struct AFSFid *a_newFidP,
	      struct AFSFetchStatus *a_newFidStatP,
	      struct AFSFetchStatus *a_newDirStatP,
	      struct AFSVolSync *a_volSyncP)
a1289 8
    struct volume_handle *volh;
    VenusFid a_vchild, a_vdirFid;
    AFSFid child;
    fbuf the_fbuf;
    struct mnode *n;
    struct msec m;
    struct mnode *child_n;
    struct msec child_m;
a1290 1
    int len;
d1296 3
a1298 16
    m.flags = VOLOP_GETSTATUS|VOLOP_INSERT;

    ret = fs_init_req (a_dirFidP, &m, &volh, call, &n);
    if (ret) {
	mlog_log (MDEBFS, "Symlink: ret = %d (init_req)", ret);
	return ret;
    }

    assert (n->flags.fdp);
    assert (n->flags.fsp);

    if (n->fs.FileType != TYPE_DIR) {
	mnode_free (n, FALSE);
	mlog_log (MDEBFS, "Symlink: ret = %d (not DIR)", EPERM);
	return EPERM;
    }
a1299 1
    ret = check_ss_bits (&m, a_origDirStatP, TRUE);
d1301 1
a1301 67
	goto out_parent;

    a_vdirFid.Cell = 0;
    a_vdirFid.fid = *a_dirFidP;
    
    ret = fbuf_create (&the_fbuf, n->fd, n->sb.st_size, 
		       FBUF_READ|FBUF_WRITE|FBUF_SHARED);
    if (ret) {
	mlog_log (MDEBFS, "Symlink: ret = %d (fbuf_create)", ret);
	goto out_parent;
    }

    ret = fdir_lookup (&the_fbuf, &a_vdirFid, a_nameP, &a_vchild);
    if (ret != ENOENT) {
	fbuf_end (&the_fbuf);
	mnode_free (n, FALSE);
	vld_free (volh);
	if (ret == 0) {
	    mlog_log (MDEBFS, "Symlink: ret = %d (EEXIST)", EEXIST);
	    return EEXIST;
	} else {
	    mlog_log (MDEBFS, "Symlink: ret = %d (fdir_lookup)", ret);
	    return ret;
	}
    }

    child.Volume = volh->vol;
   
    child_m.flags = VOLOP_GETSTATUS;
    fs_init_msec (call, &child_m);
    
    ret = vld_create_entry (volh, n, &child, TYPE_LINK,
			    a_origDirStatP, &child_n, &child_m);
    if (ret) {
	fbuf_end (&the_fbuf); /* XXX error ? */
	mnode_free (n, FALSE);
	vld_free (volh);
	mlog_log (MDEBFS, "Symlink: ret = %d (vld_create_entry)", ret);
	return ret;
    }
    a_vchild.Cell = 0;
    a_vchild.fid = child;

    /* XXX check name ! */
    ret = fdir_creat (&the_fbuf, a_nameP, child);
    if (ret == 0) {
	int32_t len = fbuf_len (&the_fbuf);
	vld_modify_vnode (volh, n, &m, NULL, &len);
    }

    fbuf_end (&the_fbuf); /* XXX error ? */

    if (ret) {
	mnode_remove (&child);
	vld_remove_node (volh, child.Vnode);
	mnode_free (n, FALSE);
	vld_free (volh);
	mlog_log (MDEBFS, "Symlink: ret = %d (fdir_creat)", ret);
	return ret;
    }

    assert (child_n->flags.fdp);

    len = strlen (a_linkContentsP);
    ret = write (child_n->fd, a_linkContentsP, len);
    if (ret != len)
	ret = errno;
d1303 3
a1305 18
	ret = 0;
    
    if (ret == 0) {
	int32_t len32 = len;
	*a_newFidP = child;
	vld_modify_vnode (volh, child_n, &child_m, NULL, &len32);
	fs_update_fs (n, &m, a_newDirStatP);
	fs_update_fs (child_n, &child_m, a_newFidStatP);
	vld_vld2volsync (volh, a_volSyncP);
	ropa_break_callback (GETHOST(call), GETPORT(call), a_dirFidP, FALSE);
    } else {
	mlog_log (MDEBFS, "Symlink: ret = %d (write)", ret);
    }

    mnode_free (child_n, FALSE);
 out_parent:
    mnode_free (n, FALSE);
    vld_free (volh);
d1315 7
a1321 7
RXAFS_Link(struct rx_call *call,
	   const struct AFSFid *a_dirFidP,
	   const char *a_nameP,
	   const struct AFSFid *a_existingFidP,
	   struct AFSFetchStatus *a_newFidStatP,
	   struct AFSFetchStatus *a_newDirStatP,
	   struct AFSVolSync *a_volSyncP)
a1322 9
#if 0
    struct volume_handle *volh;
    VenusFid a_vchild, a_vdirFid;
    AFSFid child;
    fbuf the_fbuf;
    struct mnode *n;
    struct msec m;
    struct mnode *child_n;
    struct msec child_m;
a1327 21

    m.flags = VOLOP_GETSTATUS|VOLOP_INSERT;

    ret = fs_init_req (a_dirFidP, &m, &volh, call, &n);
    if (ret) {
	mlog_log (MDEBFS, "Link: ret = %d (init_req)", ret);
	return ret;
    }

    assert (n->flags.fdp);
    assert (n->flags.fsp);

    if (n->fs.FileType != TYPE_DIR) {
	mnode_free (n, FALSE);
	vld_free (volh);
	mlog_log (MDEBFS, "Link: ret = %d (not DIR)", EPERM);
	return EPERM;
    }

    child_m.flags = VOLOP_GETSTATUS;
    fs_init_msec (call, &child_m);
d1329 2
a1330 5
    ret = fs_open_node (a_dirFidP, volh, &child_m, &child_n);
    if (ret) {
	mlog_log(MDEBFS, "Link: Failed to open existing fid, ret = %d", ret);
	goto out_parent;
    }
d1332 2
a1333 5
    ret = vld_check_rights (volh, child_n, &child_m);
    if (ret) {
	mlog_log (MDEBFS, "Link: child right insufficient ret = %d", ret);
	goto out_parent;
    }
d1335 5
a1339 60
    ret = (child_n->fs.ParentVnode == a_dirFidP->Vnode
	   && child_n->fs.ParentUnique == a_dirFidP->Unique);
    if (ret != 0) {
	mnode_free (n, FALSE);
	mlog_log (MDEBFS, "Link: ret = %d (not same volume)", EPERM);
	ret = EPERM;
	goto out_child;
    }

    a_vdirFid.Cell = 0;
    a_vdirFid.fid = *a_dirFidP;
    
    ret = fbuf_create (&the_fbuf, n->fd, n->sb.st_size, 
		       FBUF_READ|FBUF_WRITE|FBUF_SHARED);
    if (ret) {
	mlog_log (MDEBFS, "Link: ret = %d (fbuf_create)", ret);
	goto out_child;
    }

    ret = fdir_lookup (&the_fbuf, &a_vdirFid, a_nameP, &a_vchild);
    if (ret != ENOENT) {
	fbuf_end (&the_fbuf);
	if (ret == 0) {
	    mlog_log (MDEBFS, "Link: ret = %d (EEXIST)", EEXIST);
	    ret = EEXIST;
	} else
	    mlog_log (MDEBFS, "Link: ret = %d (fdir_lookup)", ret);
	goto out_child;
    }

    child = *a_existingFidP;
    child.Volume = volh->vol;
   
    /* XXX check name ! */
    ret = fdir_creat (&the_fbuf, a_nameP, child);
    if (ret == 0) {
	int32_t len = fbuf_len (&the_fbuf);
	vld_modify_vnode (volh, n, &m, NULL, &len);
    }
    
    fbuf_end (&the_fbuf); /* XXX error ? */
    
    if (ret) {
	mnode_remove (&child);
	mlog_log (MDEBFS, "Link: ret = %d (fdir_creat)", ret);
	goto out_child;
    }

    assert (child_n->flags.fdp);

    fs_update_fs (n, &m, a_newDirStatP);
    fs_update_fs (child_n, &child_m, a_newFidStatP);
    vld_vld2volsync (volh, a_volSyncP);
    ropa_break_callback (GETHOST(call), GETPORT(call), a_dirFidP, FALSE);

 out_child:
    mnode_free (child_n, FALSE);
 out_parent:
    mnode_free (n, FALSE);
    vld_free (volh);
a1341 3
#else
    return EPERM;
#endif
d1349 9
a1357 9
RXAFS_MakeDir(struct rx_call *call,
	      const struct AFSFid *a_parentDirFidP,
	      const char *a_newDirNameP,
	      const struct AFSStoreStatus *a_currStatP,
	      struct AFSFid *a_newDirFidP,
	      struct AFSFetchStatus *a_dirFidStatP,
	      struct AFSFetchStatus *a_parentDirStatP,
	      struct AFSCallBack *a_newDirCallBackP,
	      struct AFSVolSync *a_volSyncP)
a1394 1

d1406 3
a1408 8
    if (ret) {
	vld_adjust_linkcount (volh, n, -1);
	mnode_remove (&child);
	vld_remove_node (volh, child.Vnode);
	mnode_free (n, FALSE);
	mnode_free (child_n, TRUE);
	vld_free (volh);
	return ret;
a1410 1
    ret = vld_modify_vnode (volh, n, &m, NULL, NULL);
d1414 1
a1414 2
	mnode_remove (&child);
	vld_remove_node (volh, child.Vnode);
d1435 1
a1435 2
	mnode_remove (&child);
	vld_remove_node (volh, child.Vnode);
d1442 5
d1448 3
a1450 2
		      a_newDirFidP, a_newDirCallBackP);

d1455 1
d1457 1
a1457 1
out_parent:
d1469 5
a1473 5
RXAFS_RemoveDir(struct rx_call *call,
		const struct AFSFid *a_parentDirP,
		const char *a_dirNameP,
		struct AFSFetchStatus *a_newParentDirStatP,
		struct AFSVolSync *a_volSyncP)
d1488 3
a1490 3
RXAFS_GiveUpCallBacks(struct rx_call *call,
		      const AFSCBFids *a_fidArrayP,
		      const AFSCBs *a_callBackArrayP)
d1497 1
a1497 1
			  a_fidArrayP, a_callBackArrayP);
d1509 6
a1514 6
RXAFS_GetVolumeStatus(struct rx_call *call,
		      const int32_t a_volIDP,
		      struct AFSFetchVolumeStatus *a_volFetchStatP,
		      char *a_volNameP,
		      char *a_offLineMsgP,
		      char *a_motdP)
d1516 19
a1534 1
    return EPERM;
d1542 6
a1547 6
RXAFS_SetVolumeStatus(struct rx_call *call,
		      const int32_t a_volIDP,
		      const struct AFSStoreVolumeStatus *a_volStoreStatP,
		      const char *a_volNameP,
		      const char *a_offLineMsgP,
		      const char *a_motdP)
d1549 29
a1577 1
    return EPERM;
d1585 2
a1586 2
RXAFS_GetRootVolume(struct rx_call *call,
		    char *a_rootVolNameP)
d1600 3
a1602 3
RXAFS_GetTime(struct rx_call *call,
	      u_int32_t *a_secondsP,
	      u_int32_t *a_uSecondsP)
d1621 3
a1623 3
RXAFS_NGetVolumeInfo(struct rx_call *call,
		     const char *VolumeName,
		     struct AFSVolumeInfo *stuff)
d1633 5
a1637 5
RXAFS_BulkStatus(struct rx_call *call,
		 const AFSCBFids *FidsArray,
		 AFSBulkStats *StatArray,
		 AFSCBs *CBArray,
		 struct AFSVolSync *Sync)
a1701 7
	ret = vld_check_rights (volh, n, &m);
	if (ret) {
	    mnode_free (n, FALSE);
	    vld_free (volh);
	    return ret;
	}
	
d1707 4
d1712 2
a1713 1
			  &FidsArray->val[i], &CBArray->val[i]);
d1715 2
d1727 4
a1730 4
RXAFS_SetLock(struct rx_call *call,
	      const struct AFSFid *Fid,
	      const ViceLockType Type,
	      struct AFSVolSync *Sync)
d1740 3
a1742 3
RXAFS_ExtendLock(struct rx_call *call,
		 const struct AFSFid *Fid,
		 struct AFSVolSync *Sync)
d1753 3
a1755 3
RXAFS_ReleaseLock(struct rx_call *call,
		      const struct AFSFid *Fid,
		      struct AFSVolSync *Sync)
@


1.1
log
@New Arla userland from Arla between 0.34.2 and current in arla cvs.
Too many new features and fixes to mention here.
@
text
@d17 1
a17 6
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by the Kungliga Tekniska
 *      Högskolan and its contributors.
 * 
 * 4. Neither the name of the Institute nor the names of its contributors
d36 1
a36 1
RCSID("$Id: fsprocs.c,v 1.48 2000/08/16 22:38:53 tol Exp $");
d256 3
d266 12
d328 10
a337 1
    if (ret)
d339 1
d436 3
d527 2
a528 2
    mlog_log (MDEBFS, "StoreData: ret = %d (at end), len = %d",
	      ret, a_fidStatP->Length);
d640 1
d648 1
a648 1
    return 0;
d712 1
a712 1
    VenusFid fid;
d716 1
a716 1
    m.flags = VOLOP_GETSTATUS|VOLOP_DELETE|VOLOP_PARENT;
d727 1
a727 1
	return EPERM;
d738 18
d758 1
a759 2
	struct msec pm;
	VenusFid parentFid, fid;
a760 11
	parentFid.Cell = 0;
	parentFid.fid = n->fid;

	ret = fdir_lookup (&the_fbuf, &parentFid, a_name, &fid);
	if (ret) {
	    fbuf_end (&the_fbuf);
	    mnode_free (n, FALSE);
	    vld_free (volh);
	    return ret;
	}
	
d824 1
a824 1
    ret = vld_modify_vnode (volh, n, NULL, NULL, &new_len);
d888 1
a888 1
    m.flags = VOLOP_GETSTATUS|VOLOP_INSERT|VOLOP_PARENT;
d923 1
a923 1
	ret = vld_modify_vnode (volh, n, NULL, NULL, &len);
d954 1
a954 1
    mlog_log (MDEBFS, "CreateFile: created fid: %d.%d.%d", 
d956 1
a956 1
	      OutFid->Unique);
d996 1
a996 1
    orig_m.flags = VOLOP_GETSTATUS|VOLOP_DELETE|VOLOP_PARENT;
d1039 1
a1039 1
	new_m.flags = VOLOP_GETSTATUS|VOLOP_INSERT|VOLOP_PARENT;
d1107 1
a1107 1
	vld_modify_vnode (volh, orig_n, NULL, NULL, &len);
d1110 1
a1110 1
	    vld_modify_vnode (volh, new_n, NULL, NULL, &len);
d1174 1
a1174 1
    m.flags = VOLOP_GETSTATUS|VOLOP_INSERT|VOLOP_PARENT;
d1240 1
a1240 1
	vld_modify_vnode (volh, n, NULL, NULL, &len);
d1266 1
a1266 1
	vld_modify_vnode (volh, child_n, NULL, NULL, &len32);
d1296 111
d1408 1
d1438 1
a1438 1
    m.flags = VOLOP_WRITE | VOLOP_INSERT | VOLOP_PARENT | VOLOP_GETSTATUS;
d1484 1
a1484 1
    ret = vld_modify_vnode (volh, n, NULL, NULL, NULL);
@


1.1.1.1
log
@Import of arla-0.35.7
@
text
@d17 6
a22 1
 * 3. Neither the name of the Institute nor the names of its contributors
d41 1
a41 1
RCSID("$KTH: fsprocs.c,v 1.55 2001/01/01 20:50:23 lha Exp $");
a260 3
    mlog_log (MDEBFS, "FetchData: ret = %d (at end), calleraccess = %x\n",
	      ret, a_fidStatP->CallerAccess);

a267 12
static int
i2nlist (idlist *ilist, namelist *nlist)
{
    /* XXX convert the number is the ilist to name-as-numbers */
    return ENETDOWN;
}


/*
 *
 */

d318 1
a318 10
    switch (ret) {
    case ENETDOWN :
    case RX_CALL_DEAD : 

	ret = i2nlist (&ilist, &nlist);
	if (ret)
	    goto err_out;
	
	break;
    default:
a319 1
    }
a415 3
    mlog_log (MDEBFS, "FetchStatus: ret = %d (at end), calleraccess = %x\n",
	      ret, a_currStatP->CallerAccess);

d504 2
a505 2
    mlog_log (MDEBFS, "StoreData: ret = %d (at end), len = %d, calleraccess = %x",
	      ret, a_fidStatP->Length, a_fidStatP->CallerAccess);
a616 1
    fs_update_fs (n, &m, a_dirNewStatP);
d624 1
a624 1
    return ret;
d688 1
a688 1
    VenusFid parentFid, fid;
d692 1
a692 1
    m.flags = VOLOP_GETSTATUS|VOLOP_DELETE;
d703 1
a703 1
	return ENOTDIR;
a713 18
    parentFid.Cell = 0;
    parentFid.fid = n->fid;
    
    ret = fdir_lookup (&the_fbuf, &parentFid, a_name, &fid);
    if (ret) {
	fbuf_end (&the_fbuf);
	mnode_free (n, FALSE);
	vld_free (volh);
	return ret;
    }
	
    if (afs_dir_p (fid.fid.Vnode) != dirp) {
	fbuf_end (&the_fbuf);
	mnode_free (n, FALSE);
	vld_free (volh);
	return dirp ? ENOTDIR : EISDIR;
    }

d716 1
d718 4
a721 1
	struct mnode *parent_n;
d723 8
d794 1
a794 1
    ret = vld_modify_vnode (volh, n, &m, NULL, &new_len);
d858 1
a858 1
    m.flags = VOLOP_GETSTATUS|VOLOP_INSERT;
d893 1
a893 1
	ret = vld_modify_vnode (volh, n, &m, NULL, &len);
d924 1
a924 1
    mlog_log (MDEBFS, "CreateFile: created fid: %d.%d.%d calleraccess: %x", 
d926 1
a926 1
	      OutFid->Unique, OutFidStatus->CallerAccess);
d966 1
a966 1
    orig_m.flags = VOLOP_GETSTATUS|VOLOP_DELETE;
d1009 1
a1009 1
	new_m.flags = VOLOP_GETSTATUS|VOLOP_INSERT;
d1077 1
a1077 1
	vld_modify_vnode (volh, orig_n, &orig_m, NULL, &len);
d1080 1
a1080 1
	    vld_modify_vnode (volh, new_n, &new_m, NULL, &len);
d1144 1
a1144 1
    m.flags = VOLOP_GETSTATUS|VOLOP_INSERT;
d1210 1
a1210 1
	vld_modify_vnode (volh, n, &m, NULL, &len);
d1236 1
a1236 1
	vld_modify_vnode (volh, child_n, &child_m, NULL, &len32);
a1265 111
#if 0
    struct volume_handle *volh;
    VenusFid a_vchild, a_vdirFid;
    AFSFid child;
    fbuf the_fbuf;
    struct mnode *n;
    struct msec m;
    struct mnode *child_n;
    struct msec child_m;
    int ret;

    mlog_log (MDEBFS, "Link: fid: %d.%d.%d name: %s existing", 
	      a_dirFidP->Volume, a_dirFidP->Vnode,
	      a_dirFidP->Unique, a_nameP);

    m.flags = VOLOP_GETSTATUS|VOLOP_INSERT;

    ret = fs_init_req (a_dirFidP, &m, &volh, call, &n);
    if (ret) {
	mlog_log (MDEBFS, "Link: ret = %d (init_req)", ret);
	return ret;
    }

    assert (n->flags.fdp);
    assert (n->flags.fsp);

    if (n->fs.FileType != TYPE_DIR) {
	mnode_free (n, FALSE);
	vld_free (volh);
	mlog_log (MDEBFS, "Link: ret = %d (not DIR)", EPERM);
	return EPERM;
    }

    child_m.flags = VOLOP_GETSTATUS;
    fs_init_msec (call, &child_m);
    
    ret = fs_open_node (a_dirFidP, volh, &child_m, &child_n);
    if (ret) {
	mlog_log(MDEBFS, "Link: Failed to open existing fid, ret = %d", ret);
	goto out_parent;
    }

    ret = vld_check_rights (volh, child_n, &child_m);
    if (ret) {
	mlog_log (MDEBFS, "Link: child right insufficient ret = %d", ret);
	goto out_parent;
    }

    ret = (child_n->fs.ParentVnode == a_dirFidP->Vnode
	   && child_n->fs.ParentUnique == a_dirFidP->Unique);
    if (ret != 0) {
	mnode_free (n, FALSE);
	mlog_log (MDEBFS, "Link: ret = %d (not same volume)", EPERM);
	ret = EPERM;
	goto out_child;
    }

    a_vdirFid.Cell = 0;
    a_vdirFid.fid = *a_dirFidP;
    
    ret = fbuf_create (&the_fbuf, n->fd, n->sb.st_size, 
		       FBUF_READ|FBUF_WRITE|FBUF_SHARED);
    if (ret) {
	mlog_log (MDEBFS, "Link: ret = %d (fbuf_create)", ret);
	goto out_child;
    }

    ret = fdir_lookup (&the_fbuf, &a_vdirFid, a_nameP, &a_vchild);
    if (ret != ENOENT) {
	fbuf_end (&the_fbuf);
	if (ret == 0) {
	    mlog_log (MDEBFS, "Link: ret = %d (EEXIST)", EEXIST);
	    ret = EEXIST;
	} else
	    mlog_log (MDEBFS, "Link: ret = %d (fdir_lookup)", ret);
	goto out_child;
    }

    child = *a_existingFidP;
    child.Volume = volh->vol;
   
    /* XXX check name ! */
    ret = fdir_creat (&the_fbuf, a_nameP, child);
    if (ret == 0) {
	int32_t len = fbuf_len (&the_fbuf);
	vld_modify_vnode (volh, n, &m, NULL, &len);
    }
    
    fbuf_end (&the_fbuf); /* XXX error ? */
    
    if (ret) {
	mnode_remove (&child);
	mlog_log (MDEBFS, "Link: ret = %d (fdir_creat)", ret);
	goto out_child;
    }

    assert (child_n->flags.fdp);

    fs_update_fs (n, &m, a_newDirStatP);
    fs_update_fs (child_n, &child_m, a_newFidStatP);
    vld_vld2volsync (volh, a_volSyncP);
    ropa_break_callback (GETHOST(call), GETPORT(call), a_dirFidP, FALSE);

 out_child:
    mnode_free (child_n, FALSE);
 out_parent:
    mnode_free (n, FALSE);
    vld_free (volh);

    return ret;
#else
a1266 1
#endif
d1296 1
a1296 1
    m.flags = VOLOP_WRITE | VOLOP_INSERT | VOLOP_GETSTATUS;
d1342 1
a1342 1
    ret = vld_modify_vnode (volh, n, &m, NULL, NULL);
@


1.1.1.2
log
@Import of arla -current as of Aug 5 2003

ok todd@@ deraadt@@
@
text
@d2 1
a2 1
 * Copyright (c) 1999 - 2003 Kungliga Tekniska Högskolan
d36 1
a36 1
RCSID("$arla: fsprocs.c,v 1.68 2003/04/08 00:13:35 lha Exp $");
a40 13
int
createentry(struct rx_call *call,
	    const struct AFSFid *DirFid,
	    const char *Name,
	    const char *Contents,
	    const struct AFSStoreStatus *InStatus,
	    const struct AFSFid *ExistingFid,
	    struct AFSFid *EntryFid,
	    struct AFSFetchStatus *OutFidStatus,
	    struct AFSFetchStatus *OutDirStatus,
	    struct AFSCallBack *CallBack,
	    struct AFSVolSync *VolSync);

a77 10
 * return a non zero value if the user is the superuser.
 */

static int
super_user (const struct msec *m)
{
    return m->sec->superuser;
}

/*
d84 1
a84 1
check_ss_bits (const struct msec *m, const AFSStoreStatus *status,
d88 1
d92 2
a93 1
	if (status->Owner != m->sec->uid && !super_user(m))
d96 2
a97 2
	((AFSStoreStatus *)status)->Mask |= SS_OWNER; /* XXX */
	((AFSStoreStatus *)status)->Owner = m->sec->uid; /* XXX */
d101 2
a102 1
	if ((07000 & status->UnixModeBits) != 0 && !super_user(m))
d109 1
a109 1
 * Given `fid', `volh' and `m' open node `n', check rights.
d114 1
a114 1
              struct msec *m, struct mnode **n)
d120 1
a120 1
        return ret;
a122 3
    if (ret == 0)
	ret = vld_check_rights (volh, *n, m);

a124 1

d128 1
d155 1
a155 1
    if (n != NULL && (*volh)->flags.offlinep == TRUE) {
d167 1
a167 4
#define VOLOP_MODIFY (VOLOP_ADMIN|VOLOP_DELETE|VOLOP_WRITE|\
			VOLOP_INSERT|VOLOP_LOCK)

    ret = vld_info_uptodatep (*volh);
d173 2
a174 3
    if ((*volh)->info.type != RWVOL &&
	(m->flags & VOLOP_MODIFY))
    {
d176 1
a176 1
	return MILKO_ROFS;
d179 1
a179 1
    ret = vld_db_uptodate (*volh);
d181 1
a182 9
	return ret;
    }
    
    if (n != NULL) {
	ret = fs_open_node (fid, *volh, m, n);
	if (ret) {
	    vld_free (*volh);
	    return ret;
	}
d193 7
a199 7
SRXAFS_FetchData(struct rx_call *call,
		 const struct AFSFid *a_fidToFetchP,
		 const int32_t a_offset,
		 const int32_t a_lenInBytes,
		 struct AFSFetchStatus *a_fidStatP,
		 struct AFSCallBack *a_callBackP,
		 struct AFSVolSync *a_volSyncP)
a247 5

    ret = vld_info_uptodatep (volh);
    if (ret)
	goto out;

d249 1
a249 1
		      a_fidToFetchP, a_callBackP, volh->info.type);
d252 1
a252 1
 out:
a268 1
    int i;
d270 1
a270 11
    
    nlist->val = malloc(sizeof(nlist->val[0]) * ilist->len);
    if (nlist->val == NULL)
	return ENOMEM;

    for (i = 0; i < ilist->len; i++)
	snprintf(nlist->val[i], sizeof(nlist->val[i]), "%d", ilist->val[i]);
    
    nlist->len = ilist->len;

    return 0;
d279 5
a283 5
SRXAFS_FetchACL(struct rx_call *call,
		const struct AFSFid *a_dirFidP,
		AFSOpaque *a_ACLP,
		struct AFSFetchStatus *a_dirNewStatP,
		struct AFSVolSync *a_volSyncP)
d289 1
a289 1
    int i, j;
a314 3
    j = 0;
    num_negacl = 0;
    num_posacl = 0;
d317 1
d320 6
a325 9
    for (i = 0; i < FS_MAX_ACL && n->e.u.dir.acl[i].owner != 0; i++, j++)
	ilist.val[j] = n->e.u.dir.acl[i].owner;
    num_posacl = j;

    for (i = 0; i < FS_MAX_ACL && n->e.u.dir.negacl[i].owner != 0; i++, j++)
	ilist.val[j] = n->e.u.dir.negacl[i].owner;
    num_negacl = j - num_posacl;

    ilist.len = j;
a336 2
    case 0:
	break;
d343 2
d347 7
a353 5
    for (i = 0; i < num_posacl; i++) {
	if (asprintf(&tempacl, "%s%s %d\n",
		     tempacl_old,
		     nlist.val[i],
		     n->e.u.dir.acl[i].flags) == -1) {
d358 1
d365 7
a371 5
    for (i = 0; i < num_negacl; i++) {
	if (asprintf(&tempacl, "%s%s %d\n",
		     tempacl_old,
		     nlist.val[i+num_posacl],
		     n->e.u.dir.negacl[i].flags) == -1) {
d376 1
d382 2
a383 2
    asprintf(&tempacl, "%d\n%d\n%s",
	     num_posacl, num_negacl, tempacl_old);
d387 1
a387 1
    a_ACLP->len = max(strlen(tempacl), AFSOPAQUEMAX);
a388 1
    tempacl[a_ACLP->len - 1] = '\0';
d407 5
a411 5
SRXAFS_FetchStatus(struct rx_call *call,
		   const struct AFSFid *a_fidToStatP,
		   struct AFSFetchStatus *a_currStatP,
		   struct AFSCallBack *a_callBackP,
		   struct AFSVolSync *a_volSyncP)
d419 2
a420 2
	      (uint32_t)a_fidToStatP->Volume, (uint32_t)a_fidToStatP->Vnode,
	      (uint32_t)a_fidToStatP->Unique);
d426 1
a426 1
	goto out;
a428 5

    ret = vld_info_uptodatep (volh);
    if (ret)
	goto out_free;

d430 1
a430 1
		      a_fidToStatP, a_callBackP, volh->info.type);
a432 2

 out_free:
a435 1
 out:
d447 8
a454 8
SRXAFS_StoreData(struct rx_call *call,
		 const struct AFSFid *a_fidToStoreP,
		 const struct AFSStoreStatus *a_fidStatusP,
		 const int32_t a_offset,
		 const int32_t a_lenInBytes,
		 const int32_t a_fileLenInBytes,
		 struct AFSFetchStatus *a_fidStatP,
		 struct AFSVolSync *a_volSyncP)
d544 5
a548 5
SRXAFS_StoreACL(struct rx_call *call,
		const struct AFSFid *a_dirFidP,
		const AFSOpaque *a_ACLToStoreP,
		struct AFSFetchStatus *a_dirNewStatP,
		struct AFSVolSync *a_volSyncP)
d567 4
a570 1
    m.flags = VOLOP_GETSTATUS | VOLOP_ADMIN;
d656 5
a660 5
SRXAFS_StoreStatus(struct rx_call *call,
		   const struct AFSFid *a_fidP,
		   const struct AFSStoreStatus *a_currStatusP,
		   struct AFSFetchStatus *a_srStatusP,
		   struct AFSVolSync *a_volSyncP)
d708 1
d711 2
a712 3
    struct mnode *child_n;
    struct msec m, pm;
    AFSFid fid;
d715 1
a715 2
    unsigned long child_linkcount;

d730 2
a731 5
    pm.flags		= VOLOP_GETSTATUS|VOLOP_READ|VOLOP_NOCHECK;
    fs_init_msec (call, &pm);
    pm.loop			= m.loop + 1;

    ret = mdir_lookup(n, a_name, &fid);
d733 3
a735 3
        mnode_free (n, FALSE);
        vld_free (volh);
        return ret;
d738 9
a746 4
    if (afs_dir_p (fid.Vnode) != dirp) {
        mnode_free (n, FALSE);
        vld_free (volh);
        return dirp ? ENOTDIR : EISDIR;
d748 6
a753 6

    ret = fs_open_node (&fid, volh, &pm, &child_n);
    if (ret) {
        mnode_free (n, FALSE);
        vld_free (volh);
        return ret;
d757 32
a788 1
	ret = mdir_emptyp (child_n);
d790 1
a791 1
	    mnode_free (child_n, FALSE);
d793 1
a793 1
	    return EEXIST;
d797 5
a801 1
    ret = mdir_remove(n, a_name);
a803 1
	mnode_free (child_n, FALSE);
d808 2
a809 2
    /* removes node if necessary */
    ret = vld_adjust_linkcount (volh, child_n, dirp ? -2 : -1); 
a811 1
	mnode_free (child_n, FALSE);
a814 5

    child_linkcount = n->fs.LinkCount;

    mnode_free (child_n, FALSE);

d823 1
a823 2
    
    new_len = n->sb.st_size;
d828 1
a828 1
    fid.Volume = a_dirFidP->Volume;
d831 1
a831 12
	if (child_linkcount)
	    ropa_break_callback (GETHOST(call), GETPORT(call), &fid, TRUE);
	else {
	    AFSCBFids cbfids;
	    AFSCBs cbs;
	    
	    cbfids.len = 1;
	    cbfids.val = &fid;
	    cbs.len = 0;

	    ropa_drop_callbacks(GETHOST(call), GETPORT(call), &cbfids, &cbs);
	}
d847 5
a851 5
SRXAFS_RemoveFile(struct rx_call *call,
		  const struct AFSFid *a_dirFidP,
		  const char *a_name,
		  struct AFSFetchStatus *a_srvStatusP,
		  struct AFSVolSync *a_volSyncP)
d866 9
a874 11
createentry(struct rx_call *call,
	    const struct AFSFid *DirFid,
	    const char *Name,
	    const char *Contents,
	    const struct AFSStoreStatus *InStatus,
	    const struct AFSFid *ExistingFid,
	    struct AFSFid *EntryFid,
	    struct AFSFetchStatus *OutFidStatus,
	    struct AFSFetchStatus *OutDirStatus,
	    struct AFSCallBack *CallBack,
	    struct AFSVolSync *VolSync)
a881 1
    int32_t len;
d883 4
a898 1
	vld_free (volh);
d909 3
a911 35
    if (InStatus) {
	ret = check_ss_bits (&m, InStatus, TRUE);
	if (ret == 0) {
	    AFSFid existing;
	    ret = mdir_lookup (n, Name, &existing);
	    if (ret == 0)
		ret = EEXIST;
	    else if (ret == ENOENT)
		ret = 0;
	}
	
	if (ret == 0)
	    ret = vld_create_entry (volh, n, &child, 
				    Contents ? TYPE_LINK : TYPE_FILE,
				    InStatus, &child_n, &child_m);
	
	if (ret)
	    goto out_parent;
    } else {
	ret = fs_open_node (ExistingFid, volh, &child_m, &child_n);
	if (ret) {
	    mlog_log(MDEBFS, 
		     "createentry: Failed to open existing fid, ret = %d", ret);
	    goto out_parent;
	}
	
	if (child_n->fs.ParentVnode != DirFid->Vnode
	    || child_n->fs.ParentUnique != DirFid->Unique) {
	    ret = EXDEV;
	    mlog_log (MDEBFS, "createentry: ret = %d (EXDEV)", EXDEV);
	    goto out_child;
	}
	ret = vld_adjust_linkcount (volh, child_n, 1);
	if (ret)
	    goto out_child;
d913 4
a916 2
	child = *ExistingFid;
    }
d922 1
a922 1
	len = n->sb.st_size;
a925 13
    if (Contents && ret == 0) {
	assert (child_n->flags.fdp);
	
	len = strlen (Contents);
	ret = write (child_n->fd, Contents, len);
	if (ret != len) {
	    ret = errno;
	    mlog_log (MDEBFS, "createentry: ret = %d (write)", ret);
	} else {
	    ret = vld_modify_vnode (volh, child_n, &child_m, NULL, &len);
	}
    }

a926 2
	mdir_remove (n, Name);
	vld_adjust_linkcount (volh, child_n, -1);
d930 2
a934 3
    if (EntryFid)
	*EntryFid = child;

d938 2
a939 3
    ret = vld_info_uptodatep (volh);
    if (ret)
	goto out_child;
d941 6
a946 4
    if (CallBack)
	ropa_getcallback (GETHOST(call), GETPORT(call), EntryFid, CallBack,
			  volh->info.type);
    ropa_break_callback (GETHOST(call), GETPORT(call), DirFid, FALSE);
a947 2
    vld_vld2volsync (volh, VolSync);
 out_child:
d951 1
d954 3
a956 26
    return ret;
}

/*
 *
 */

int
SRXAFS_CreateFile(struct rx_call *call,
		  const struct AFSFid *DirFid,
		  const char *Name,
		  const struct AFSStoreStatus *InStatus,
		  struct AFSFid *OutFid,
		  struct AFSFetchStatus *OutFidStatus,
		  struct AFSFetchStatus *OutDirStatus,
		  struct AFSCallBack *CallBack,
		  struct AFSVolSync *a_volSyncP)
{
    int ret;
    
    mlog_log (MDEBFS, "CreateFile: fid: %d.%d.%d name: %s", 
	      DirFid->Volume, DirFid->Vnode,
	      DirFid->Unique, Name);

    ret = createentry(call, DirFid, Name, NULL, InStatus, NULL, OutFid,
		      OutFidStatus, OutDirStatus, CallBack, a_volSyncP);
a957 7
    if (ret)
	mlog_log (MDEBFS, "CreateFile: failed with ret = %d", ret);
    else
	mlog_log (MDEBFS, "CreateFile: created fid: %d.%d.%d calleraccess: %x", 
		  OutFid->Volume, OutFid->Vnode,
		  OutFid->Unique, OutFidStatus->CallerAccess);
    
d966 8
a973 8
SRXAFS_Rename(struct rx_call *call,
	      const struct AFSFid *a_origDirFidP,
	      const char *a_origNameP,
	      const struct AFSFid *a_newDirFidP,
	      const char *a_newNameP,
	      struct AFSFetchStatus *a_origDirStatusP,
	      struct AFSFetchStatus *a_newDirStatusP,
	      struct AFSVolSync *a_volSyncP)
d976 7
a982 6
    AFSFid victim, child;
    struct mnode *orig_n, *new_n = NULL;
    struct mnode *child_n = NULL, *victim_n = NULL;
    struct msec m1, m2;
    struct msec *orig_m = &m1, *new_m = &m2;
    int32_t len1, len2;
a983 1
    int dirp;
d985 1
a985 3
    int delete_dest = FALSE;
    int victim_deleted = FALSE;

d996 4
a999 3
    if (!(afs_dir_p(a_origDirFidP->Vnode)) 
	|| !(afs_dir_p(a_newDirFidP->Vnode)))
	return EPERM;
d1001 1
a1001 9
    if (a_origDirFidP->Vnode == a_newDirFidP->Vnode &&
	a_origDirFidP->Unique == a_newDirFidP->Unique) {
	same_dir = TRUE;
	orig_m->flags = VOLOP_GETSTATUS|VOLOP_INSERT|VOLOP_DELETE;
    } else {
	orig_m->flags = VOLOP_GETSTATUS|VOLOP_DELETE;
    }

    ret = fs_init_req (a_origDirFidP, orig_m, &volh, call, &orig_n);
d1008 10
a1017 3
    ret = mdir_lookup(orig_n, a_origNameP, &child);
    if (ret == 0)
	ret = fs_open_node (&child, volh, orig_m, &child_n);
d1020 1
d1024 7
a1030 1
    assert(child_n->flags.fsp);
d1032 2
a1033 5
    dirp = afs_dir_p(child.Vnode);
    if (same_dir == FALSE && child_n->fs.LinkCount != (dirp ? 2 : 1)) {
	ret = EXDEV;
	goto out1;
    }
d1035 2
a1036 3
    if (same_dir == TRUE) {
	new_n = orig_n;
	new_m = orig_m;
d1039 2
a1040 2
	new_m->flags = VOLOP_GETSTATUS|VOLOP_INSERT|VOLOP_DELETE;
	
d1042 1
a1042 2
	ret = fs_init_msec(call, new_m);
	ret = fs_open_node (a_newDirFidP, volh, new_m, &new_n);
d1044 4
a1047 9
	    new_m->flags = VOLOP_GETSTATUS|VOLOP_INSERT;
	    
	    /* XXX */
	    ret = fs_open_node (a_newDirFidP, volh, new_m, &new_n);
	    if (ret) {
		mnode_free (orig_n, FALSE);
		vld_free (volh);
		return ret;
	    }
d1049 7
a1055 8
    }
    
    ret = mdir_lookup(new_n, a_newNameP, &victim);
    if (!ret) {
	if (!(new_m->flags & VOLOP_DELETE)
	    || afs_dir_p(victim.Vnode) != dirp) {
	    ret = EPERM;
	    goto out1;
a1056 22
	delete_dest = TRUE;
	ret = fs_open_node (&victim, volh, new_m, &victim_n);
	if (ret)
	    goto out1;
	
	assert(victim_n->flags.fsp);
	
	if (child_n->fs.LinkCount != (dirp ? 2 : 1)) {
	    ret = EPERM;
	    mnode_free(victim_n, FALSE);
	    goto out1;
	}
    }
    
    ret = mdir_rename(orig_n, a_origNameP, &len1,
		      new_n, a_newNameP, &len2);

    if (ret) {
	if (delete_dest == TRUE)
	    mnode_free(victim_n, FALSE);
	goto out1;
    }
d1058 3
a1060 2
    if (!ret && dirp) {
	ret = mdir_changefid(child_n, "..", *a_newDirFidP);
d1062 5
a1066 1
	    /* XXX recover */
d1070 6
a1075 6
    if (delete_dest == TRUE) {
	/* remove the node if necessary */
	ret = vld_adjust_linkcount (volh, victim_n, 
				    -(afs_dir_p(victim.Vnode) ? 2 : 1));
	if (victim_n->fs.LinkCount == 0)
	    victim_deleted = TRUE;
d1077 23
a1099 8
	mnode_free(victim_n, FALSE);
	if (ret) {
	    /* 
	     * XXX Remove failed, try to recover.
	     * Do not check for error, things are bad anyway.
	     * Maybe this should cause a shutdown + salvage?
	     */
	    goto out1;
d1103 9
a1111 4
    /* Update linkcount on parents if directory move */
    if (dirp && !same_dir) {
	ret = vld_adjust_linkcount (volh, orig_n, -1);
	ret = vld_adjust_linkcount (volh, new_n, 1);
d1114 1
a1114 1
    /* XXX update st_ctime and st_mtime of both parents */
d1116 1
a1116 1
    vld_modify_vnode (volh, orig_n, orig_m, NULL, &len1);
d1118 3
a1120 4
        vld_modify_vnode (volh, new_n, new_m, NULL, &len2);

    fs_update_fs (orig_n, orig_m, a_origDirStatusP);
    fs_update_fs (new_n, new_m, a_newDirStatusP);
d1123 1
a1123 1
    if (!same_dir) {
d1125 2
a1126 3
	if (dirp)
	    ropa_break_callback (GETHOST(call), GETPORT(call), &child, FALSE);
    }
a1127 12
    if (victim_deleted == TRUE) {
	AFSCBFids cbfids;
	AFSCBs cbs;
	
	cbfids.len = 1;
	cbfids.val = &victim;
	cbs.len = 0;
	
	ropa_drop_callbacks(GETHOST(call), GETPORT(call), &cbfids, &cbs);
    } else
	ropa_break_callback(GETHOST(call), GETPORT(call), &victim, TRUE);
	    
d1129 1
d1131 2
a1132 3
    if (child_n)
	mnode_free (child_n, FALSE);
    if (!same_dir && new_n)
d1134 1
d1149 9
a1157 9
SRXAFS_Symlink(struct rx_call *call,
	       const struct AFSFid *a_dirFidP,
	       const char *a_nameP,
	       const char *a_linkContentsP,
	       const struct AFSStoreStatus *a_origDirStatP,
	       struct AFSFid *a_newFidP,
	       struct AFSFetchStatus *a_newFidStatP,
	       struct AFSFetchStatus *a_newDirStatP,
	       struct AFSVolSync *a_volSyncP)
d1159 8
d1168 1
d1174 16
a1189 3
    ret = createentry(call, a_dirFidP, a_nameP, a_linkContentsP,
		      a_origDirStatP, NULL, a_newFidP, a_newFidStatP, 
		      a_newDirStatP, NULL, a_volSyncP);
d1191 1
d1193 67
a1259 1
	mlog_log (MDEBFS, "Symlink: failed with ret = %d", ret);
d1261 18
a1278 3
	mlog_log (MDEBFS, "Symlink: created fid: %d.%d.%d calleraccess: %x", 
		  a_newFidP->Volume, a_newFidP->Vnode,
		  a_newFidP->Unique, a_newFidStatP->CallerAccess);
d1288 7
a1294 7
SRXAFS_Link(struct rx_call *call,
	    const struct AFSFid *a_dirFidP,
	    const char *a_nameP,
	    const struct AFSFid *a_existingFidP,
	    struct AFSFetchStatus *a_newFidStatP,
	    struct AFSFetchStatus *a_newDirStatP,
	    struct AFSVolSync *a_volSyncP)
d1296 9
d1310 21
d1332 5
a1336 2
    if (afs_dir_p(a_existingFidP->Vnode)) 
	return EISDIR;
d1338 5
a1342 2
    ret = createentry(call, a_dirFidP, a_nameP, NULL, NULL, a_existingFidP,
		      NULL, a_newFidStatP, a_newDirStatP, NULL, a_volSyncP);
d1344 60
a1403 5
    if (ret)
	mlog_log (MDEBFS, "Link: failed with ret = %d", ret);
    else
	mlog_log (MDEBFS, "Link: created name: %s calleraccess: %x", 
		  a_nameP, a_newFidStatP->CallerAccess);
d1406 3
d1416 9
a1424 9
SRXAFS_MakeDir(struct rx_call *call,
	       const struct AFSFid *a_parentDirFidP,
	       const char *a_newDirNameP,
	       const struct AFSStoreStatus *a_currStatP,
	       struct AFSFid *a_newDirFidP,
	       struct AFSFetchStatus *a_dirFidStatP,
	       struct AFSFetchStatus *a_parentDirStatP,
	       struct AFSCallBack *a_newDirCallBackP,
	       struct AFSVolSync *a_volSyncP)
d1462 1
d1474 8
a1481 3
    if (ret == 0) {
	int32_t len = n->sb.st_size;
	ret = vld_modify_vnode (volh, n, &m, NULL, &len);
d1484 1
d1488 2
a1489 1
	vld_adjust_linkcount (volh, child_n, -1); /* removes node if necessary */
d1510 2
a1511 1
	vld_adjust_linkcount (volh, child_n, -1); /* removes node if necessary */
d1518 2
a1520 8
    ret = vld_info_uptodatep (volh);
    if (ret)
	goto out_child;

    ropa_getcallback (GETHOST(call), GETPORT(call),
		      a_newDirFidP, a_newDirCallBackP,
		      volh->info.type);
    
a1524 1
 out_child:
d1526 1
a1526 1
 out_parent:
d1538 5
a1542 5
SRXAFS_RemoveDir(struct rx_call *call,
		 const struct AFSFid *a_parentDirP,
		 const char *a_dirNameP,
		 struct AFSFetchStatus *a_newParentDirStatP,
		 struct AFSVolSync *a_volSyncP)
d1557 3
a1559 3
SRXAFS_GiveUpCallBacks(struct rx_call *call,
		       const AFSCBFids *a_fidArrayP,
		       const AFSCBs *a_callBackArrayP)
d1566 1
a1566 1
			       a_fidArrayP, a_callBackArrayP);
d1578 6
a1583 6
SRXAFS_GetVolumeStatus(struct rx_call *call,
		       const int32_t a_volIDP,
		       struct AFSFetchVolumeStatus *a_volFetchStatP,
		       char *a_volNameP,
		       char *a_offLineMsgP,
		       char *a_motdP)
d1585 1
a1585 19
    struct volume_handle *volh;
    AFSFid fid;
    struct msec m;
    int ret;

    mlog_log (MDEBFS, "GetVolumeStats: vol: %d", a_volIDP);

    m.flags = VOLOP_GETSTATUS;
    fid.Volume = a_volIDP;

    ret = fs_init_req (&fid, &m, &volh, call, NULL);
    if (ret) {
	mlog_log (MDEBFS, "GetVolumeStatus: fs_init_req returned %d", ret);
	return ret;
    }

    ret = vld_get_volstats (volh, a_volFetchStatP, a_volNameP,
			    a_offLineMsgP, a_motdP);
    return ret;
d1593 6
a1598 6
SRXAFS_SetVolumeStatus(struct rx_call *call,
		       const int32_t a_volIDP,
		       const struct AFSStoreVolumeStatus *a_volStoreStatP,
		       const char *a_volNameP,
		       const char *a_offLineMsgP,
		       const char *a_motdP)
d1600 1
a1600 29
    struct volume_handle *volh;
    AFSFid fid;
    struct msec m;
    int ret;

    mlog_log (MDEBFS, "SRXAFS_SetVolumeStatus: vol: %d", a_volIDP);

    m.flags = 0;
    fid.Volume = a_volIDP;
    fid.Vnode = 1;
    fid.Unique = 1;

    ret = fs_init_req (&fid, &m, &volh, call, NULL);
    if (ret) {
	goto out;
    }

    if (!super_user(&m)) {
	ret = EPERM;
	goto out;
    }

    ret = vld_set_volstats (volh, a_volStoreStatP, a_volNameP,
			    a_offLineMsgP, a_motdP);

 out:
    vld_free (volh);
    mlog_log (MDEBFS, "SRXAFS_SetVolumeStatus: fs_init_req returned %d", ret);
    return ret;
d1608 2
a1609 2
SRXAFS_GetRootVolume(struct rx_call *call,
		     char *a_rootVolNameP)
d1623 3
a1625 3
SRXAFS_GetTime(struct rx_call *call,
	       uint32_t *a_secondsP,
	       uint32_t *a_uSecondsP)
d1644 3
a1646 3
SRXAFS_NGetVolumeInfo(struct rx_call *call,
		      const char *VolumeName,
		      struct AFSVolumeInfo *stuff)
d1656 5
a1660 5
SRXAFS_BulkStatus(struct rx_call *call,
		  const AFSCBFids *FidsArray,
		  AFSBulkStats *StatArray,
		  AFSCBs *CBArray,
		  struct AFSVolSync *Sync)
d1725 7
a1736 4
	ret = vld_info_uptodatep (volh);
	if (ret)
	    goto out;

d1738 1
a1738 2
			  &FidsArray->val[i], &CBArray->val[i],
			  volh->info.type);
a1739 2

 out:
d1750 4
a1753 4
SRXAFS_SetLock(struct rx_call *call,
	       const struct AFSFid *Fid,
	       const ViceLockType Type,
	       struct AFSVolSync *Sync)
d1763 3
a1765 3
SRXAFS_ExtendLock(struct rx_call *call,
		  const struct AFSFid *Fid,
		  struct AFSVolSync *Sync)
d1776 3
a1778 3
SRXAFS_ReleaseLock(struct rx_call *call,
		   const struct AFSFid *Fid,
		   struct AFSVolSync *Sync)
@


