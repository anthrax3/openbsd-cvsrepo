head	1.5;
access;
symbols
	OPENBSD_5_2:1.4.0.38
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.36
	OPENBSD_5_0:1.4.0.34
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.32
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.30
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.4.0.26
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.4.0.28
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.4.0.24
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.4.0.22
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.4.0.20
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.4.0.18
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.4.0.16
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.4.0.14
	OPENBSD_4_0_BASE:1.4
	OPENBSD_3_9:1.4.0.12
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.10
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.8
	OPENBSD_3_7_BASE:1.4
	OPENBSD_3_6:1.4.0.6
	OPENBSD_3_6_BASE:1.4
	OPENBSD_3_5:1.4.0.4
	OPENBSD_3_5_BASE:1.4
	OPENBSD_3_4:1.4.0.2
	OPENBSD_3_4_BASE:1.4
	arla-20030805:1.1.1.3
	OPENBSD_3_3:1.3.0.4
	OPENBSD_3_3_BASE:1.3
	OPENBSD_3_2:1.3.0.2
	OPENBSD_3_2_BASE:1.3
	arla-0-35-7:1.1.1.2
	OPENBSD_3_1:1.2.0.8
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.6
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_9:1.2.0.4
	OPENBSD_2_8:1.2.0.2
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.1.1.1.0.8
	OPENBSD_2_7_BASE:1.1.1.1
	OPENBSD_2_6:1.1.1.1.0.6
	OPENBSD_2_6_BASE:1.1.1.1
	OPENBSD_2_5:1.1.1.1.0.4
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.2
	OPENBSD_2_4_BASE:1.1.1.1
	arla-0_9:1.1.1.1
	arla:1.1.1;
locks; strict;
comment	@ * @;


1.5
date	2012.08.23.06.21.55;	author deraadt;	state dead;
branches;
next	1.4;

1.4
date	2003.08.05.09.16.15;	author hin;	state Exp;
branches;
next	1.3;

1.3
date	2002.06.07.04.44.13;	author hin;	state Exp;
branches;
next	1.2;

1.2
date	2000.09.11.14.41.25;	author art;	state Exp;
branches;
next	1.1;

1.1
date	98.09.14.21.53.19;	author art;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.09.14.21.53.19;	author art;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.06.07.04.14.36;	author hin;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2003.08.05.08.21.07;	author hin;	state Exp;
branches;
next	;


desc
@@


1.5
log
@the afs src tree can go away
@
text
@/*
 * Copyright (c) 1995, 1996, 1997, 2003 Kungliga Tekniska Högskolan
 * (Royal Institute of Technology, Stockholm, Sweden).
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include "rxkad_locl.h"

RCSID("$arla: rxk_locl.c,v 1.9 2003/01/11 00:50:32 lha Exp $");

/* The header checksum is the last 16 bits of this struct after
 * encryption. Note that only the last 8 bytes change per packet. */
#if 0
struct header_data {
  struct const_header_data c;	/* 16 bytes */
  struct variable_header_data v; /* 8 bytes */
};
#endif

struct const_header_data {
  /* Data that is constant per connection */
  uint32_t epoch;
  uint32_t cid;
  uint32_t zero;
  uint32_t security_index;
};

struct variable_header_data {
  /* Data that changes per packet */
  uint32_t call_number;
  uint32_t channel_and_seq;
};

/* To create a 16 bit packet header checksum we first create an iv
 * dependent on the epoch, the connection ID and the security index.
 */
void
rxkad_calc_header_iv(const struct rx_connection *conn,
		     const int32_t *sched,
		     const des_cblock *in_iv,
		     uint32_t *out_iv)
{
  struct const_header_data h;
  uint32_t *t;

  h.epoch = htonl(conn->epoch);
  h.cid = htonl(conn->cid & RX_CIDMASK);
  h.zero = 0;
  h.security_index = htonl(conn->securityIndex);

  t = (uint32_t *)in_iv;		/* memcpy(out_iv, in_iv, 8); */
  out_iv[0] = t[0];
  out_iv[1] = t[1];
  fc_cbc_encrypt(&h, &h, sizeof(h), sched, out_iv, ENCRYPT);
  /* Extract last 8 bytes as iv */
  assert(out_iv[0] == h.zero);
  /* out_iv[0] = h.zero; */
  out_iv[1] = h.security_index;
}

/* Make a 16 bit header checksum dependent on call number, channel
 * number and packet sequence number. In addition, the checksum is
 * indirectly dependent (via the iv) on epoch, connection ID and
 * security index.
 */
static
int
rxkad_cksum_header(const struct rx_packet *packet,
		   const int32_t *sched,
		   const unsigned int *iv)
{
  struct variable_header_data h;
  uint32_t t;

  /* Collect selected packet fields */
  h.call_number = htonl(packet->header.callNumber);
  t = ((packet->header.cid & RX_CHANNELMASK) << (32 - RX_CIDSHIFT))
    | ((packet->header.seq & 0x3fffffff));
  h.channel_and_seq = htonl(t);

  /* Encrypt selected fields (this is hand rolled CBC mode) */
  h.call_number     ^= iv[0];
  h.channel_and_seq ^= iv[1];
  fc_ecb_encrypt(&h, &h, sched, ENCRYPT);

  /* Select 16 bits that are now dependent on all selected packet fields */
  t = (ntohl(h.channel_and_seq) >> 16) & 0xffff;
  if (t != 0)
    return t;
  else
    return 1;			/* No checksum is 0 */
}

/* Checksum a rxkad_response, this checksum is buried within the
 * encrypted part of the response but covers the entire response. */
uint32_t
rxkad_cksum_response(rxkad_response *r)
{
  u_char *t;
  uint32_t cksum = 1000003;
  
  for (t = (u_char *)r; t < (u_char*)(r + 1); t++)
    cksum = *t + cksum * 0x10204081;
  
  return htonl(cksum);
}

int
rxkad_prepare_packet(struct rx_packet *pkt,
		     struct rx_connection *con,
		     int level,
		     key_stuff *k,
		     end_stuff *e)
{
  u_int len = rx_GetDataSize(pkt);

  /* Checksum header */
  rx_SetPacketCksum(pkt, rxkad_cksum_header(pkt, k->keysched, e->header_iv));

  e->packetsSent++;
  e->bytesSent += len;
  
  if (level != rxkad_clear)
    {
      uint32_t *data = (uint32_t *) rx_DataOf(pkt);
      uint32_t t;
      int32_t code = 0;

      assert(pkt->wirevec[1].iov_len >= 4);

      /* First 4 bytes of security header, includes encrypted length */
      t = pkt->header.seq ^ pkt->header.callNumber;
      t <<= 16;
      t |= len;			/* Extracted on receiving side */
      data[0] = htonl(t);

      switch (level) {
      case rxkad_auth:
	len += rx_GetSecurityHeaderSize(con); /* Extended pkt len */
	/* Extend packet length so that we can encrypt the first 8 bytes */
 	if (pkt->wirevec[1].iov_len < 8)
 	  {
 	    int diff = 8 - pkt->wirevec[1].iov_len;
 	    pkt->wirevec[1].iov_len += diff;
 	    len += diff;
 	  }
 	rx_SetDataSize(pkt, len); /* Set extended packet length */
  	
	/* Encrypt security header (4 bytes) and the next 4 bytes */
 	assert(pkt->wirevec[1].iov_len >= 8);
	fc_ecb_encrypt(data, data, k->keysched, ENCRYPT);
	break;

      case rxkad_crypt:
 	len += rx_GetSecurityHeaderSize(con); /* Extended pkt len */
	 /* Round up to 8 byte boundary for encryption to work */
 	if (len % 8)
 	  {
 	    int diff = 8 - (len % 8);
 	    rxi_RoundUpPacket(pkt, diff);
 	    len += diff;
 	  }
 	rx_SetDataSize(pkt, len); /* Set extended packet length */
 
 	assert((len % 8) == 0);
 	code = rxkad_EncryptPacket(con, k->keysched,(uint32_t*)k->key, len,pkt);
	break;

      default:
	assert(0);
      }

      return code;
    }
  return 0;
}

int
rxkad_check_packet(struct rx_packet *pkt,
		   struct rx_connection *con,
		   int level,
		   key_stuff *k,
		   end_stuff *e)
{
  u_int xlen = rx_GetDataSize(pkt); /* Extended packet length */

  if (rx_GetPacketCksum(pkt)
      != rxkad_cksum_header(pkt, k->keysched, e->header_iv))
    return RXKADSEALEDINCON;
  
  e->packetsReceived++;

  if (level == rxkad_clear)
    {
      e->bytesReceived += xlen;	/* Same as real length */
    }
  else
    {
      u_int len;		/* Real packet length */
      uint32_t *data = (uint32_t *) rx_DataOf(pkt);
      uint32_t t;
      int32_t code;

      switch (level) {
      case rxkad_auth:
	assert(rx_Contiguous(pkt) >= 8);
	fc_ecb_encrypt(data, data, k->keysched, DECRYPT);
	break;

      case rxkad_crypt:
	code = rxkad_DecryptPacket(con, k->keysched,(uint32_t*)k->key, xlen, pkt);
	if (code)
	  return code;
	break;

      default:
	assert(0);
      }

      assert(rx_Contiguous(pkt) >= 4);

      t = ntohl(data[0]);
      len = t & 0xffff;		/* Extract real length */
      t >>= 16;
      if (t != ((pkt->header.seq ^ pkt->header.callNumber) & 0xffff))
	return RXKADSEALEDINCON;

#define TBYTES 15
      /* The packet is extended with 0 - 7 bytes to a chipher block
       * boundary. This is however not true with the Transarc
       * implementation, for unknown reasons it sometimes extendeds
       * the packet with anything up to TBYTES. */
      if (len > xlen)
	return RXKADSEALEDINCON;
      if (xlen > len + TBYTES)
	return RXKADSEALEDINCON;

      e->bytesReceived += len;
      rx_SetDataSize(pkt, len);	/* Set real packet length */
      return 0;
    }
  return 0;
}
@


1.4
log
@Merge
@
text
@@


1.3
log
@merge
@
text
@d2 1
a2 1
 * Copyright (c) 1995, 1996, 1997 Kungliga Tekniska Högskolan
d36 1
a36 1
RCSID("$KTH: rxk_locl.c,v 1.8 2000/10/03 00:38:38 lha Exp $");
d49 4
a52 4
  u_int32 epoch;
  u_int32 cid;
  u_int32 zero;
  u_int32 security_index;
d57 2
a58 2
  u_int32 call_number;
  u_int32 channel_and_seq;
d66 1
a66 1
		     const int32 *sched,
d68 1
a68 1
		     u_int32 *out_iv)
d71 1
a71 1
  u_int32 *t;
d78 1
a78 1
  t = (u_int32 *)in_iv;		/* memcpy(out_iv, in_iv, 8); */
d96 1
a96 1
		   const int32 *sched,
d100 1
a100 1
  u_int32 t;
d123 1
a123 1
u_int32
d127 1
a127 1
  u_int32 cksum = 1000003;
d152 3
a154 3
      u_int32 *data = (u_int32 *) rx_DataOf(pkt);
      u_int32 t;
      int32 code = 0;
d193 1
a193 1
 	code = rxkad_EncryptPacket(con, k->keysched,(u_int32*)k->key, len,pkt);
d227 3
a229 3
      u_int32 *data = (u_int32 *) rx_DataOf(pkt);
      u_int32 t;
      int32 code;
d238 1
a238 1
	code = rxkad_DecryptPacket(con, k->keysched,(u_int32*)k->key, xlen, pkt);
@


1.2
log
@New Arla userland from Arla between 0.34.2 and current in arla cvs.
Too many new features and fixes to mention here.
@
text
@d17 1
a17 6
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by the Kungliga Tekniska
 *      Högskolan and its contributors.
 * 
 * 4. Neither the name of the Institute nor the names of its contributors
d36 1
a36 1
RCSID("$Id: rxk_locl.c,v 1.7 1998/04/05 10:58:16 assar Exp $");
@


1.1
log
@Initial revision
@
text
@a0 1
/*	$OpenBSD$	*/
d41 1
a41 1
RCSID("$KTH: rxk_locl.c,v 1.7 1998/04/05 10:58:16 assar Exp $");
@


1.1.1.1
log
@Initial version of Arla, a free implementation of an AFS cache-manager.
(second try, hopefully into the correct repository this time)
@
text
@@


1.1.1.2
log
@Import of arla-0.35.7
@
text
@d1 1
d18 6
a23 1
 * 3. Neither the name of the Institute nor the names of its contributors
d42 1
a42 1
RCSID("$KTH: rxk_locl.c,v 1.8 2000/10/03 00:38:38 lha Exp $");
@


1.1.1.3
log
@Import of arla -current as of Aug 5 2003

ok todd@@ deraadt@@
@
text
@d2 1
a2 1
 * Copyright (c) 1995, 1996, 1997, 2003 Kungliga Tekniska Högskolan
d36 1
a36 1
RCSID("$arla: rxk_locl.c,v 1.9 2003/01/11 00:50:32 lha Exp $");
d49 4
a52 4
  uint32_t epoch;
  uint32_t cid;
  uint32_t zero;
  uint32_t security_index;
d57 2
a58 2
  uint32_t call_number;
  uint32_t channel_and_seq;
d66 1
a66 1
		     const int32_t *sched,
d68 1
a68 1
		     uint32_t *out_iv)
d71 1
a71 1
  uint32_t *t;
d78 1
a78 1
  t = (uint32_t *)in_iv;		/* memcpy(out_iv, in_iv, 8); */
d96 1
a96 1
		   const int32_t *sched,
d100 1
a100 1
  uint32_t t;
d123 1
a123 1
uint32_t
d127 1
a127 1
  uint32_t cksum = 1000003;
d152 3
a154 3
      uint32_t *data = (uint32_t *) rx_DataOf(pkt);
      uint32_t t;
      int32_t code = 0;
d193 1
a193 1
 	code = rxkad_EncryptPacket(con, k->keysched,(uint32_t*)k->key, len,pkt);
d227 3
a229 3
      uint32_t *data = (uint32_t *) rx_DataOf(pkt);
      uint32_t t;
      int32_t code;
d238 1
a238 1
	code = rxkad_DecryptPacket(con, k->keysched,(uint32_t*)k->key, xlen, pkt);
@


