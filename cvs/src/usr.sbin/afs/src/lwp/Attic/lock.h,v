head	1.6;
access;
symbols
	OPENBSD_5_2:1.5.0.36
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.34
	OPENBSD_5_0:1.5.0.32
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.30
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.28
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.24
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.5.0.26
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.5.0.22
	OPENBSD_4_5_BASE:1.5
	OPENBSD_4_4:1.5.0.20
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3:1.5.0.18
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.5.0.16
	OPENBSD_4_2_BASE:1.5
	OPENBSD_4_1:1.5.0.14
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.5.0.12
	OPENBSD_4_0_BASE:1.5
	OPENBSD_3_9:1.5.0.10
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.5.0.8
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.6
	OPENBSD_3_7_BASE:1.5
	OPENBSD_3_6:1.5.0.4
	OPENBSD_3_6_BASE:1.5
	OPENBSD_3_5:1.5.0.2
	OPENBSD_3_5_BASE:1.5
	OPENBSD_3_4:1.4.0.2
	OPENBSD_3_4_BASE:1.4
	arla-20030805:1.1.1.3
	OPENBSD_3_3:1.3.0.4
	OPENBSD_3_3_BASE:1.3
	OPENBSD_3_2:1.3.0.2
	OPENBSD_3_2_BASE:1.3
	arla-0-35-7:1.1.1.2
	OPENBSD_3_1:1.2.0.8
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.6
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_9:1.2.0.4
	OPENBSD_2_8:1.2.0.2
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.1.1.1.0.8
	OPENBSD_2_7_BASE:1.1.1.1
	OPENBSD_2_6:1.1.1.1.0.6
	OPENBSD_2_6_BASE:1.1.1.1
	OPENBSD_2_5:1.1.1.1.0.4
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.2
	OPENBSD_2_4_BASE:1.1.1.1
	arla-0_9:1.1.1.1
	arla:1.1.1;
locks; strict;
comment	@ * @;


1.6
date	2012.08.23.06.21.52;	author deraadt;	state dead;
branches;
next	1.5;

1.5
date	2003.12.16.20.13.55;	author beck;	state Exp;
branches;
next	1.4;

1.4
date	2003.08.05.09.07.34;	author hin;	state Exp;
branches;
next	1.3;

1.3
date	2002.06.07.04.41.27;	author hin;	state Exp;
branches;
next	1.2;

1.2
date	2000.09.11.14.41.08;	author art;	state Exp;
branches;
next	1.1;

1.1
date	98.09.14.21.53.12;	author art;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.09.14.21.53.12;	author art;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.06.07.04.14.29;	author hin;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2003.08.05.08.21.04;	author hin;	state Exp;
branches;
next	;


desc
@@


1.6
log
@the afs src tree can go away
@
text
@#ifndef LWP_LOCK_H
#define LWP_LOCK_H

/*
****************************************************************************
*        Copyright IBM Corporation 1988, 1989 - All Rights Reserved        *
*                                                                          *
* Permission to use, copy, modify, and distribute this software and its    *
* documentation for any purpose and without fee is hereby granted,         *
* provided that the above copyright notice appear in all copies and        *
* that both that copyright notice and this permission notice appear in     *
* supporting documentation, and that the name of IBM not be used in        *
* advertising or publicity pertaining to distribution of the software      *
* without specific, written prior permission.                              *
*                                                                          *
* IBM DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL *
* IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL IBM *
* BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY      *
* DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER  *
* IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING   *
* OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.    *
****************************************************************************
*/

/* $arla: lock.h,v 1.13 2002/06/01 17:47:48 lha Exp $ */

/*******************************************************************\
* 								    *
* 	Information Technology Center				    *
* 	Carnegie-Mellon University				    *
* 								    *
* 								    *
* 								    *
\*******************************************************************/

/*
	Include file for using Vice locking routines.
*/

/* The following macros allow multi statement macros to be defined safely, i.e.
   - the multi statement macro can be the object of an if statement;
   - the call to the multi statement macro may be legally followed by a semi-colon.
   BEGINMAC and ENDMAC have been tested with both the portable C compiler and
   Hi-C.  Both compilers were from the Palo Alto 4.2BSD software releases, and
   both optimized out the constant loop code.  For an example of the use
   of BEGINMAC and ENDMAC, see the definition for ReleaseWriteLock, below.
   An alternative to this, using "if(1)" for BEGINMAC is not used because it
   may generate worse code with pcc, and may generate warning messages with hi-C.
*/

#define BEGINMAC do {
#define ENDMAC   } while (0)

/* 
 * all locks wait on excl_locked except for READ_LOCK, which waits on
 * readers_reading
 */

struct Lock {
    unsigned char	wait_states;	/* type of lockers waiting */
    unsigned char	excl_locked;    /* anyone have boosted, shared or write lock? */
    unsigned char	readers_reading;/* # readers actually with read locks */
    unsigned char	num_waiting;	/* probably need this soon */
    int			thread_index;	/* thread that have a exclusive lock */
#ifdef LOCK_TRACE
    char *file;
    int line;
#endif /* LOCK_TRACE */
};

/* Prototypes */

void Lock_ReleaseR(struct Lock *);
void Lock_ReleaseW(struct Lock *);
void Lock_Obtain(struct Lock *, int);
void Lock_Init(struct Lock *);

#define READ_LOCK	1
#define WRITE_LOCK	2
#define SHARED_LOCK	4
/* this next is not a flag, but rather a parameter to Lock_Obtain */
#define BOOSTED_LOCK 6

/* next defines wait_states for which we wait on excl_locked */
#define EXCL_LOCKS (WRITE_LOCK|SHARED_LOCK)

#ifdef LOCK_DEBUG
#define DEBUGWRITE(message,lock) do { \
		fprintf(stderr,"th#%d ", LWP_Index()); \
		fprintf(stderr,message,lock,__FILE__,__LINE__); } while (0)
#define DEBUGWRITE_4(message,lock1,how1,lock2,how2) do { \
		fprintf(stderr,"th#%d ", LWP_Index()); \
		fprintf(stderr,message,lock1,how1,lock2,how2,__FILE__,__LINE__); } while (0)
#else
#define DEBUGWRITE(message,lock) do { ; } while (0)
#define DEBUGWRITE_4(message,lock1,how1,lock2,how2) do { ; } while (0)
#endif

#ifdef LOCK_TRACE
#define StoreFileLine(lock, f, l) \
	(lock)->file = f; \
	(lock)->line = l;
#define GetTraceFile(lock) (lock)->file
#define GetTraceLine(lock) (lock)->line
#else
#define StoreFileLine(lock, f, l)
#define GetTraceFile(lock) "no_lock_trace"
#define GetTraceLine(lock) 0
#endif

#ifdef NDEBUG
#define LOCK_CHECK_OWNER 0
#else
#define LOCK_CHECK_OWNER 1
#endif

#ifdef LOCK_CHECK_OWNER
#define AssertNotLockOwner(lock,owner) do {				    \
	if ((lock)->thread_index == (owner)) {				    \
		fprintf(stderr,						    \
			"AssertNotLockOwner failed on %s:%d with lock %p, " \
			"owned by %d, locked at (%s:%d)\n",		    \
			__FILE__, __LINE__,				    \
			(lock), (owner),				    \
			GetTraceFile(lock), GetTraceLine(lock));	    \
		abort();						    \
	}								    \
} while (0)

#define AssertLockOwner(lock,owner) do {				 \
	if ((lock)->thread_index != (owner)) {				 \
		fprintf(stderr,						 \
			"AssertLockOwner failed on %s:%d with lock %p, " \
			"should be owned by %d, "			 \
			"was owned by %d, locked at (%s:%d)\n",		 \
			__FILE__, __LINE__,				 \
			(lock), (owner), (lock)->thread_index,		 \
			GetTraceFile(lock), GetTraceLine(lock));	 \
		abort();						 \
	}								 \
} while (0)

#else /* !LOCK_CHECK_OWNER */

#define AssertNotLockOwner(lock,owner) do { ; } while (0)
#define AssertLockOwner(lock,owner) do { ; } while (0)

#endif /* LOCK_CHECK_OWNER */

#define AssertExclLocked(lock)			\
	BEGINMAC				\
	AssertLockOwner(lock,LWP_Index());	\
	ENDMAC					\

#define AssertNotExclLocked(lock)			\
	BEGINMAC					\
	AssertLockOwner(lock,LWP_INVALIDTHREADID);	\
	ENDMAC						\

#define ObtainReadLock(lock) \
	BEGINMAC \
	DEBUGWRITE("ObtainReadLock: %p at %s:%d starting\n",lock); \
	AssertNotLockOwner(lock,LWP_Index()); \
	RealObtainReadLock(lock) \
	AssertLockOwner(lock,LWP_INVALIDTHREADID); \
	StoreFileLine(lock, __FILE__, __LINE__) \
	DEBUGWRITE("ObtainReadLock: %p at %s:%d got it\n",lock);\
	ENDMAC

#define ObtainWriteLock(lock) \
	BEGINMAC \
	DEBUGWRITE("ObtainWriteLock: %p at %s:%d starting\n",lock); \
	AssertNotLockOwner(lock,LWP_Index()); \
	RealObtainWriteLock(lock) \
	AssertLockOwner(lock,LWP_Index()); \
	StoreFileLine(lock, __FILE__, __LINE__) \
	DEBUGWRITE("ObtainWriteLock: %p at %s:%d got it\n",lock);\
	ENDMAC

#define ObtainSharedLock(lock) \
	BEGINMAC \
	DEBUGWRITE("ObtainSharedLock: %p at %s:%d starting\n",lock); \
	AssertNotLockOwner(lock,LWP_Index()); \
	RealObtainSharedLock(lock) \
	StoreFileLine(lock, __FILE__, __LINE__) \
	DEBUGWRITE("ObtainSharedLock: %p at %s:%d got it\n",lock);\
	ENDMAC

#define BoostSharedLock(lock) \
	BEGINMAC \
	DEBUGWRITE("BoostSharedLock: %p at %s:%d starting\n",lock); \
	AssertNotLockOwner(lock,LWP_Index()); \
	RealBoostSharedLock(lock) \
	AssertLockOwner(lock,LWP_Index()); \
	StoreFileLine(lock, __FILE__, __LINE__) \
	DEBUGWRITE("BoostSharedLock: %p at %s:%d got it\n",lock);\
	ENDMAC

#define UnBoostSharedLock(lock) \
	BEGINMAC \
	DEBUGWRITE("UnBoostSharedLock: %p at %s:%d starting\n",lock); \
	AssertNotLockOwner(lock,LWP_Index()); \
	RealUnboostSharedLock(lock) \
	AssertLockOwner(lock,LWP_INVALIDTHREADID); \
	StoreFileLine(lock, __FILE__, __LINE__) \
	DEBUGWRITE("UnBoostSharedLock: %p at %s:%d got it\n",lock);\
	ENDMAC

#define ReleaseReadLock(lock) \
	BEGINMAC \
        DEBUGWRITE("ReleaseReadLock: %p at %s:%d\n",lock);\
	AssertNotLockOwner(lock,LWP_Index()); \
	RealReleaseReadLock(lock) \
	AssertLockOwner(lock,LWP_INVALIDTHREADID); \
	ENDMAC

#define ReleaseWriteLock(lock) \
	BEGINMAC \
        DEBUGWRITE("ReleaseWriteLock: %p at %s:%d\n",lock);\
	AssertLockOwner(lock,LWP_Index()); \
	RealReleaseWriteLock(lock) \
	AssertLockOwner(lock,LWP_INVALIDTHREADID); \
	ENDMAC

#define ReleaseSharedLock(lock) \
	BEGINMAC \
        DEBUGWRITE("ReleaseSharedLock: %p at %s:%d\n",lock);\
	RealReleaseSharedLock(lock) \
	AssertLockOwner(lock,LWP_INVALIDTHREADID); \
	ENDMAC

#define RealObtainReadLock(lock) \
	if (!((lock)->excl_locked & WRITE_LOCK) && !(lock)->wait_states)\
	    (lock) -> readers_reading++;\
	else\
	    Lock_Obtain(lock, READ_LOCK);

#define RealObtainWriteLock(lock)\
	if (!(lock)->excl_locked && !(lock)->readers_reading) \
	    (lock) -> excl_locked = WRITE_LOCK;\
	else\
	    Lock_Obtain(lock, WRITE_LOCK); \
	(lock) -> thread_index = LWP_Index();  


#define RealObtainSharedLock(lock)\
	if (!(lock)->excl_locked && !(lock)->wait_states)\
	    (lock) -> excl_locked = SHARED_LOCK;\
	else\
	    Lock_Obtain(lock, SHARED_LOCK);

#define RealBoostSharedLock(lock)\
	if (!(lock)->readers_reading)\
	    (lock)->excl_locked = WRITE_LOCK;\
	else\
	    Lock_Obtain(lock, BOOSTED_LOCK); \
	(lock) -> thread_index = LWP_Index();  

/* this must only be called with a WRITE or boosted SHARED lock! */
#define RealUnboostSharedLock(lock)\
	    (lock) -> excl_locked = SHARED_LOCK; \
	    (lock) -> thread_index = LWP_INVALIDTHREADID; \
	    if((lock)->wait_states) \
		Lock_ReleaseR(lock);

#define RealReleaseReadLock(lock)\
	    if (!--(lock)->readers_reading && (lock)->wait_states)\
		Lock_ReleaseW(lock) ;


#define RealReleaseWriteLock(lock)\
	    (lock) -> thread_index = LWP_INVALIDTHREADID; \
	    (lock)->excl_locked &= ~WRITE_LOCK;\
	    if ((lock)->wait_states) Lock_ReleaseR(lock);

/* can be used on shared or boosted (write) locks */
#define RealReleaseSharedLock(lock)\
	    (lock) -> thread_index = LWP_INVALIDTHREADID; \
	    (lock)->excl_locked &= ~(SHARED_LOCK | WRITE_LOCK);\
	    if ((lock)->wait_states) Lock_ReleaseR(lock);

/* I added this next macro to make sure it is safe to nuke a lock -- Mike K. */
#define LockWaiters(lock)\
	((int) ((lock)->num_waiting))

#define CheckLock(lock)\
	((lock)->excl_locked? (int) -1 : (int) (lock)->readers_reading)

#define WriteLocked(lock)\
	((lock)->excl_locked & WRITE_LOCK)

void LWP_WaitProcessR(char *addr, struct Lock *alock);
void LWP_WaitProcessW(char *addr, struct Lock *alock);
void LWP_WaitProcessS(char *addr, struct Lock *alock);

/* This attempts to obtain two locks in a secure fashion */

#define ObtainTwoLocks(lock1, how1, lock2, how2) \
    BEGINMAC\
        DEBUGWRITE_4("ObtainTwoLocks: %p(%d) %p(%d) at %s:%d\n",lock1,how1,lock2,how2);\
	_ObtainTwoLocks(lock1, how1, lock2, how2);\
    ENDMAC

void
_ObtainTwoLocks(struct Lock *lock1, int how1,
		struct Lock *lock2, int how2);

#endif /* LOCK_H */
@


1.5
log
@afs cleanup, realloc strings, abort, etc.
testing by beck, hin, jose, fries. ok deraadt@@
@
text
@@


1.4
log
@Merge
@
text
@d111 3
d115 1
@


1.3
log
@merge
@
text
@d25 1
a25 1
/* $KTH: lock.h,v 1.11 2000/10/20 16:18:35 assar Exp $ */
d73 4
a76 4
void Lock_ReleaseR(register struct Lock *);
void Lock_ReleaseW(register struct Lock *);
void Lock_Obtain(register struct Lock *, int);
void Lock_Init(register struct Lock *);
d89 1
d92 1
d288 3
a290 3
void LWP_WaitProcessR(register char *addr, register struct Lock *alock);
void LWP_WaitProcessW(register char *addr, register struct Lock *alock);
void LWP_WaitProcessS(register char *addr, register struct Lock *alock);
d301 2
a302 2
_ObtainTwoLocks(register struct Lock *lock1, int how1,
	       register struct Lock *lock2, int how2);
@


1.2
log
@New Arla userland from Arla between 0.34.2 and current in arla cvs.
Too many new features and fixes to mention here.
@
text
@d25 1
a25 1
/* $Id: lock.h,v 1.8 2000/04/20 15:45:34 lha Exp $ */
d54 5
a58 1
/* all locks wait on excl_locked except for READ_LOCK, which waits on readers_reading */
d61 2
a62 2
    unsigned char	excl_locked;	/* anyone have boosted, shared or write lock? */
    unsigned char	readers_reading;	/* # readers actually with read locks */
d64 1
d101 2
d105 2
d109 45
d157 3
a160 1
	RealObtainReadLock(lock) \
d167 3
a170 1
	RealObtainWriteLock(lock) \
d177 2
a179 1
	RealObtainSharedLock(lock) \
d186 3
a189 1
	RealBoostSharedLock(lock) \
d196 3
a199 1
	RealUnboostSharedLock(lock) \
d206 1
d208 1
d214 1
d216 1
d223 1
d233 1
a233 1
	if (!(lock)->excl_locked && !(lock)->readers_reading)\
d236 3
a238 1
	    Lock_Obtain(lock, WRITE_LOCK);
d250 2
a251 1
	    Lock_Obtain(lock, BOOSTED_LOCK);
d255 2
a256 1
	    (lock)->excl_locked = SHARED_LOCK; \
d266 1
d272 1
@


1.1
log
@Initial revision
@
text
@d1 2
a2 10
/*	$OpenBSD$	*/
/* $Header: /usr/local/cvsroot/arla/lwp/lock.h,v 1.5 1998/02/02 18:08:17 lha Exp $ */
/* $Source: /usr/local/cvsroot/arla/lwp/lock.h,v $ */

#ifndef LOCK_H
#define LOCK_H

#if !defined(lint) && !defined(LOCORE) && defined(RCS_HDRS)
static char *rcsidlock = "$Header: /usr/local/cvsroot/arla/lwp/lock.h,v 1.5 1998/02/02 18:08:17 lha Exp $";
#endif
d25 2
d60 4
d91 9
d101 58
a158 2
    BEGINMAC\
        DEBUGWRITE("ObtainReadLock: %p at %s:%d starting\n",lock);\
d162 1
a162 3
	    Lock_Obtain(lock, READ_LOCK);\
	DEBUGWRITE("ObtainReadLock: %p at %s:%d got it\n",lock);\
    ENDMAC
d164 1
a164 3
#define ObtainWriteLock(lock)\
    BEGINMAC\
        DEBUGWRITE("ObtainWriteLock: %p at %s:%d starting\n",lock);\
d168 1
a168 3
	    Lock_Obtain(lock, WRITE_LOCK);\
	DEBUGWRITE("ObtainReadLock: %p at %s:%d got it\n",lock);\
    ENDMAC
d170 1
a170 3
#define ObtainSharedLock(lock)\
    BEGINMAC\
        DEBUGWRITE("ObtainSharedLock: %p at %s:%d starting\n",lock);\
d174 1
a174 3
	    Lock_Obtain(lock, SHARED_LOCK);\
	DEBUGWRITE("ObtainSharedLock: %p at %s:%d got it\n",lock);\
    ENDMAC
d176 1
a176 3
#define BoostSharedLock(lock)\
    BEGINMAC\
        DEBUGWRITE("BoostSharedLock: %p at %s:%d starting\n",lock);\
d180 1
a180 3
	    Lock_Obtain(lock, BOOSTED_LOCK);\
	DEBUGWRITE("BoostSharedLock: %p at %s:%d got it\n",lock);\
    ENDMAC
d183 1
a183 3
#define UnboostSharedLock(lock)\
	BEGINMAC\
        DEBUGWRITE("UnboostSharedLock: %p at %s:%d\n",lock);\
d186 1
a186 11
		Lock_ReleaseR(lock); \
	ENDMAC

#ifdef notdef
/* this is what UnboostSharedLock looked like before the hi-C compiler */
/* this must only be called with a WRITE or boosted SHARED lock! */
#define UnboostSharedLock(lock)\
	((lock)->excl_locked = SHARED_LOCK,\
	((lock)->wait_states ?\
		Lock_ReleaseR(lock) : 0))
#endif /* notdef */
d188 1
a188 3
#define ReleaseReadLock(lock)\
	BEGINMAC\
        DEBUGWRITE("ReleaseReadLock: %p at %s:%d\n",lock);\
d190 1
a190 3
		Lock_ReleaseW(lock) ; \
	ENDMAC

a191 8
#ifdef notdef
/* This is what the previous definition should be, but the hi-C compiler generates
  a warning for each invocation */
#define ReleaseReadLock(lock)\
	(!--(lock)->readers_reading && (lock)->wait_states ?\
		Lock_ReleaseW(lock)    :\
		0)
#endif /* notdef */
d193 1
a193 3
#define ReleaseWriteLock(lock)\
        BEGINMAC\
        DEBUGWRITE("ReleaseWriteLock: %p at %s:%d\n",lock);\
d195 1
a195 11
	    if ((lock)->wait_states) Lock_ReleaseR(lock);\
        ENDMAC

#ifdef notdef
/* This is what the previous definition should be, but the hi-C compiler generates
   a warning for each invocation */
#define ReleaseWriteLock(lock)\
	((lock)->excl_locked &= ~WRITE_LOCK,\
	((lock)->wait_states ?\
		Lock_ReleaseR(lock) : 0))
#endif /* notdef */
d198 1
a198 3
#define ReleaseSharedLock(lock)\
        BEGINMAC\
        DEBUGWRITE("ReleaseLock: %p at %s:%d\n",lock);\
d200 1
a200 13
	    if ((lock)->wait_states) Lock_ReleaseR(lock);\
        ENDMAC

#ifdef notdef
/* This is what the previous definition should be, but the hi-C compiler generates
   a warning for each invocation */
/* can be used on shared or boosted (write) locks */
#define ReleaseSharedLock(lock)\
	((lock)->excl_locked &= ~(SHARED_LOCK | WRITE_LOCK),\
	((lock)->wait_states ?\
		Lock_ReleaseR(lock) : 0))
#endif /* notdef */
	
d211 4
@


1.1.1.1
log
@Initial version of Arla, a free implementation of an AFS cache-manager.
(second try, hopefully into the correct repository this time)
@
text
@@


1.1.1.2
log
@Import of arla-0.35.7
@
text
@d1 10
a10 2
#ifndef LWP_LOCK_H
#define LWP_LOCK_H
a32 2
/* $KTH: lock.h,v 1.11 2000/10/20 16:18:35 assar Exp $ */

d60 1
a60 5
/* 
 * all locks wait on excl_locked except for READ_LOCK, which waits on
 * readers_reading
 */

d63 2
a64 2
    unsigned char	excl_locked;    /* anyone have boosted, shared or write lock? */
    unsigned char	readers_reading;/* # readers actually with read locks */
a65 5
    int			thread_index;	/* thread that have a exclusive lock */
#ifdef LOCK_TRACE
    char *file;
    int line;
#endif /* LOCK_TRACE */
a92 58

#ifdef LOCK_TRACE
#define StoreFileLine(lock, f, l) \
	(lock)->file = f; \
	(lock)->line = l;
#define GetTraceFile(lock) (lock)->file
#define GetTraceLine(lock) (lock)->line
#else
#define StoreFileLine(lock, f, l)
#define GetTraceFile(lock) "no_lock_trace"
#define GetTraceLine(lock) 0
#endif

#define LOCK_CHECK_OWNER 1

#ifdef LOCK_CHECK_OWNER
#define AssertNotLockOwner(lock,owner) do {				    \
	if ((lock)->thread_index == (owner)) {				    \
		fprintf(stderr,						    \
			"AssertNotLockOwner failed on %s:%d with lock %p, " \
			"owned by %d, locked at (%s:%d)\n",		    \
			__FILE__, __LINE__,				    \
			(lock), (owner),				    \
			GetTraceFile(lock), GetTraceLine(lock));	    \
		abort();						    \
	}								    \
} while (0)

#define AssertLockOwner(lock,owner) do {				 \
	if ((lock)->thread_index != (owner)) {				 \
		fprintf(stderr,						 \
			"AssertLockOwner failed on %s:%d with lock %p, " \
			"should be owned by %d, "			 \
			"was owned by %d, locked at (%s:%d)\n",		 \
			__FILE__, __LINE__,				 \
			(lock), (owner), (lock)->thread_index,		 \
			GetTraceFile(lock), GetTraceLine(lock));	 \
		abort();						 \
	}								 \
} while (0)

#else /* !LOCK_CHECK_OWNER */

#define AssertNotLockOwner(lock,owner) do { ; } while (0)
#define AssertLockOwner(lock,owner) do { ; } while (0)

#endif /* LOCK_CHECK_OWNER */

#define AssertExclLocked(lock)			\
	BEGINMAC				\
	AssertLockOwner(lock,LWP_Index());	\
	ENDMAC					\

#define AssertNotExclLocked(lock)			\
	BEGINMAC					\
	AssertLockOwner(lock,LWP_INVALIDTHREADID);	\
	ENDMAC						\

d94 2
a95 72
	BEGINMAC \
	DEBUGWRITE("ObtainReadLock: %p at %s:%d starting\n",lock); \
	AssertNotLockOwner(lock,LWP_Index()); \
	RealObtainReadLock(lock) \
	AssertLockOwner(lock,LWP_INVALIDTHREADID); \
	StoreFileLine(lock, __FILE__, __LINE__) \
	DEBUGWRITE("ObtainReadLock: %p at %s:%d got it\n",lock);\
	ENDMAC

#define ObtainWriteLock(lock) \
	BEGINMAC \
	DEBUGWRITE("ObtainWriteLock: %p at %s:%d starting\n",lock); \
	AssertNotLockOwner(lock,LWP_Index()); \
	RealObtainWriteLock(lock) \
	AssertLockOwner(lock,LWP_Index()); \
	StoreFileLine(lock, __FILE__, __LINE__) \
	DEBUGWRITE("ObtainWriteLock: %p at %s:%d got it\n",lock);\
	ENDMAC

#define ObtainSharedLock(lock) \
	BEGINMAC \
	DEBUGWRITE("ObtainSharedLock: %p at %s:%d starting\n",lock); \
	AssertNotLockOwner(lock,LWP_Index()); \
	RealObtainSharedLock(lock) \
	StoreFileLine(lock, __FILE__, __LINE__) \
	DEBUGWRITE("ObtainSharedLock: %p at %s:%d got it\n",lock);\
	ENDMAC

#define BoostSharedLock(lock) \
	BEGINMAC \
	DEBUGWRITE("BoostSharedLock: %p at %s:%d starting\n",lock); \
	AssertNotLockOwner(lock,LWP_Index()); \
	RealBoostSharedLock(lock) \
	AssertLockOwner(lock,LWP_Index()); \
	StoreFileLine(lock, __FILE__, __LINE__) \
	DEBUGWRITE("BoostSharedLock: %p at %s:%d got it\n",lock);\
	ENDMAC

#define UnBoostSharedLock(lock) \
	BEGINMAC \
	DEBUGWRITE("UnBoostSharedLock: %p at %s:%d starting\n",lock); \
	AssertNotLockOwner(lock,LWP_Index()); \
	RealUnboostSharedLock(lock) \
	AssertLockOwner(lock,LWP_INVALIDTHREADID); \
	StoreFileLine(lock, __FILE__, __LINE__) \
	DEBUGWRITE("UnBoostSharedLock: %p at %s:%d got it\n",lock);\
	ENDMAC

#define ReleaseReadLock(lock) \
	BEGINMAC \
        DEBUGWRITE("ReleaseReadLock: %p at %s:%d\n",lock);\
	AssertNotLockOwner(lock,LWP_Index()); \
	RealReleaseReadLock(lock) \
	AssertLockOwner(lock,LWP_INVALIDTHREADID); \
	ENDMAC

#define ReleaseWriteLock(lock) \
	BEGINMAC \
        DEBUGWRITE("ReleaseWriteLock: %p at %s:%d\n",lock);\
	AssertLockOwner(lock,LWP_Index()); \
	RealReleaseWriteLock(lock) \
	AssertLockOwner(lock,LWP_INVALIDTHREADID); \
	ENDMAC

#define ReleaseSharedLock(lock) \
	BEGINMAC \
        DEBUGWRITE("ReleaseSharedLock: %p at %s:%d\n",lock);\
	RealReleaseSharedLock(lock) \
	AssertLockOwner(lock,LWP_INVALIDTHREADID); \
	ENDMAC

#define RealObtainReadLock(lock) \
d99 3
a101 1
	    Lock_Obtain(lock, READ_LOCK);
d103 4
a106 2
#define RealObtainWriteLock(lock)\
	if (!(lock)->excl_locked && !(lock)->readers_reading) \
d109 3
a111 3
	    Lock_Obtain(lock, WRITE_LOCK); \
	(lock) -> thread_index = LWP_Index();  

d113 3
a115 1
#define RealObtainSharedLock(lock)\
d119 3
a121 1
	    Lock_Obtain(lock, SHARED_LOCK);
d123 3
a125 1
#define RealBoostSharedLock(lock)\
d129 3
a131 2
	    Lock_Obtain(lock, BOOSTED_LOCK); \
	(lock) -> thread_index = LWP_Index();  
d134 4
a137 3
#define RealUnboostSharedLock(lock)\
	    (lock) -> excl_locked = SHARED_LOCK; \
	    (lock) -> thread_index = LWP_INVALIDTHREADID; \
d139 11
a149 1
		Lock_ReleaseR(lock);
d151 3
a153 1
#define RealReleaseReadLock(lock)\
d155 2
a156 1
		Lock_ReleaseW(lock) ;
d159 12
a170 2
#define RealReleaseWriteLock(lock)\
	    (lock) -> thread_index = LWP_INVALIDTHREADID; \
d172 11
a182 1
	    if ((lock)->wait_states) Lock_ReleaseR(lock);
d185 3
a187 2
#define RealReleaseSharedLock(lock)\
	    (lock) -> thread_index = LWP_INVALIDTHREADID; \
d189 13
a201 1
	    if ((lock)->wait_states) Lock_ReleaseR(lock);
a211 4

void LWP_WaitProcessR(register char *addr, register struct Lock *alock);
void LWP_WaitProcessW(register char *addr, register struct Lock *alock);
void LWP_WaitProcessS(register char *addr, register struct Lock *alock);
@


1.1.1.3
log
@Import of arla -current as of Aug 5 2003

ok todd@@ deraadt@@
@
text
@d25 1
a25 1
/* $arla: lock.h,v 1.13 2002/06/01 17:47:48 lha Exp $ */
d73 4
a76 4
void Lock_ReleaseR(struct Lock *);
void Lock_ReleaseW(struct Lock *);
void Lock_Obtain(struct Lock *, int);
void Lock_Init(struct Lock *);
a88 1
		fprintf(stderr,"th#%d ", LWP_Index()); \
a90 1
		fprintf(stderr,"th#%d ", LWP_Index()); \
d286 3
a288 3
void LWP_WaitProcessR(char *addr, struct Lock *alock);
void LWP_WaitProcessW(char *addr, struct Lock *alock);
void LWP_WaitProcessS(char *addr, struct Lock *alock);
d299 2
a300 2
_ObtainTwoLocks(struct Lock *lock1, int how1,
		struct Lock *lock2, int how2);
@


