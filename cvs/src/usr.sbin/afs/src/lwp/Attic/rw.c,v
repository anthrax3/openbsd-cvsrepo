head	1.6;
access;
symbols
	OPENBSD_5_2:1.5.0.36
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.34
	OPENBSD_5_0:1.5.0.32
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.30
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.28
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.24
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.5.0.26
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.5.0.22
	OPENBSD_4_5_BASE:1.5
	OPENBSD_4_4:1.5.0.20
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3:1.5.0.18
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.5.0.16
	OPENBSD_4_2_BASE:1.5
	OPENBSD_4_1:1.5.0.14
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.5.0.12
	OPENBSD_4_0_BASE:1.5
	OPENBSD_3_9:1.5.0.10
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.5.0.8
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.6
	OPENBSD_3_7_BASE:1.5
	OPENBSD_3_6:1.5.0.4
	OPENBSD_3_6_BASE:1.5
	OPENBSD_3_5:1.5.0.2
	OPENBSD_3_5_BASE:1.5
	OPENBSD_3_4:1.4.0.2
	OPENBSD_3_4_BASE:1.4
	arla-20030805:1.1.1.2
	OPENBSD_3_3:1.2.0.12
	OPENBSD_3_3_BASE:1.2
	OPENBSD_3_2:1.2.0.10
	OPENBSD_3_2_BASE:1.2
	arla-0-35-7:1.1.1.1
	arla:1.1.1
	OPENBSD_3_1:1.2.0.8
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.6
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_9:1.2.0.4
	OPENBSD_2_8:1.2.0.2
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.1.0.4
	OPENBSD_2_7_BASE:1.1
	OPENBSD_2_6:1.1.0.2
	OPENBSD_2_6_BASE:1.1;
locks; strict;
comment	@ * @;


1.6
date	2012.08.23.06.21.52;	author deraadt;	state dead;
branches;
next	1.5;

1.5
date	2003.12.16.20.13.55;	author beck;	state Exp;
branches;
next	1.4;

1.4
date	2003.08.05.09.07.34;	author hin;	state Exp;
branches;
next	1.3;

1.3
date	2003.04.06.19.09.04;	author pvalchev;	state Exp;
branches;
next	1.2;

1.2
date	2000.09.11.14.41.10;	author art;	state Exp;
branches;
next	1.1;

1.1
date	99.04.30.01.59.14;	author art;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.06.07.04.14.30;	author hin;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.08.05.08.21.04;	author hin;	state Exp;
branches;
next	;


desc
@@


1.6
log
@the afs src tree can go away
@
text
@/*
****************************************************************************
*        Copyright IBM Corporation 1988, 1989 - All Rights Reserved        *
*                                                                          *
* Permission to use, copy, modify, and distribute this software and its    *
* documentation for any purpose and without fee is hereby granted,         *
* provided that the above copyright notice appear in all copies and        *
* that both that copyright notice and this permission notice appear in     *
* supporting documentation, and that the name of IBM not be used in        *
* advertising or publicity pertaining to distribution of the software      *
* without specific, written prior permission.                              *
*                                                                          *
* IBM DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL *
* IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL IBM *
* BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY      *
* DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER  *
* IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING   *
* OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.    *
****************************************************************************
*/

/*
	(Multiple) readers & writers test of LWP stuff.

Created: 11/1/83, J. Rosenberg

*/

#include <sys/time.h>
#include <stdio.h>
#include <stdlib.h>

#include <lwp.h>
#include "lock.h"
#include "preempt.h"

#define DEFAULT_READERS	5

#define STACK_SIZE	(16*1024)

/* The shared queue */
typedef struct QUEUE {
    struct QUEUE	*prev, *next;
    char		*data;
    struct Lock		lock;
} queue;

static queue *init()
{
    queue *q;

    q = (queue *) malloc(sizeof(queue));
    q -> prev = q -> next = q;
    return(q);
}

static char empty(queue *q)
{
    return (q->prev == q && q->next == q);
}

static void insert(queue *q, char *s)
{
    queue *new;

    new = (queue *) malloc(sizeof(queue));
    new -> data = s;
    new -> prev = q -> prev;
    q -> prev -> next = new;
    q -> prev = new;
    new -> next = q;
}

static char *Remove(queue *q)
{
    queue *old;
    char *s;

    if (empty(q)) {
	errx(-1, "rw.c Remove: Remove from empty queue");
    }

    old = q -> next;
    q -> next = old -> next;
    q -> next -> prev = q;
    s = old -> data;
    free(old);
    return(s);
}

queue *q;

int asleep;	/* Number of processes sleeping -- used for
		   clean termination */

static void
read_process(char *id)
{
    printf("\t[Reader %d]\n", *(int *)id);
    LWP_NewRock(1, id);
    LWP_DispatchProcess();		/* Just relinquish control for now */

    PRE_PreemptMe();
    for (;;) {
        int i;
	char *tmp;

	/* Wait until there is something in the queue */
	asleep++;
	ObtainReadLock(&q->lock);
	while (empty(q)) {
	    ReleaseReadLock(&q->lock);
	    LWP_WaitProcess((void *)q);
	    ObtainReadLock(&q->lock);
	}
	asleep--;
	for (i=0; i<10000; i++) ;
	PRE_BeginCritical();
	LWP_GetRock(1, &tmp);
	printf("[%d: %s]\n", *(int *)tmp, Remove(q));
	PRE_EndCritical();
	ReleaseReadLock(&q->lock);
	LWP_DispatchProcess();
    }
}

static void write_process()
{
    static char *messages[] =
    {
	"Mary had a little lamb,",
	"Its fleece was white as snow,",
	"And everywhere that Mary went,",
	"The lamb was sure to go",
	"Mary had a little lamb,",
	"Its fleece was white as snow,",
	"And everywhere that Mary went,",
	"The lamb was sure to go",
	"Mary had a little lamb,",
	"Its fleece was white as snow,",
	"And everywhere that Mary went,",
	"The lamb was sure to go",
	"Mary had a little lamb,",
	"Its fleece was white as snow,",
	"And everywhere that Mary went,",
	"The lamb was sure to go",
	"Mary had a little lamb,",
	"Its fleece was white as snow,",
	"And everywhere that Mary went,",
	"The lamb was sure to go",
	"Mary had a little lamb,",
	"Its fleece was white as snow,",
	"And everywhere that Mary went,",
	"The lamb was sure to go",
	"Mary had a little lamb,",
	"Its fleece was white as snow,",
	"And everywhere that Mary went,",
	"The lamb was sure to go",
	"Mary had a little lamb,",
	"Its fleece was white as snow,",
	"And everywhere that Mary went,",
	"The lamb was sure to go",
	"Mary had a little lamb,",
	"Its fleece was white as snow,",
	"And everywhere that Mary went,",
	"The lamb was sure to go",
	"Mary had a little lamb,",
	"Its fleece was white as snow,",
	"And everywhere that Mary went,",
	"The lamb was sure to go",
	0
    };
    char **mesg;

    printf("\t[Writer]\n");
    PRE_PreemptMe();

    /* Now loop & write data */
    for (mesg=messages; *mesg!=0; mesg++) {
	ObtainWriteLock(&q->lock);
	insert(q, *mesg);
	ReleaseWriteLock(&q->lock);
	LWP_SignalProcess(q);
    }

    asleep++;
}

/*
	Arguments:
		0:	Unix junk, ignore
		1:	Number of readers to create (default is DEFAULT_READERS)
		2:	# msecs for interrupt (to satisfy Larry)
		3:	Present if lwp_debug to be set
*/


int
main(int argc, char **argv)
{
    int nreaders, i;
    long interval;	/* To satisfy Brad */
    PROCESS *readers;
    int *readersid;
    PROCESS writer, master;
    struct timeval tv;
    char rname[9];

    printf("\n*Readers & Writers*\n\n");
    setbuf(stdout, 0);

    /* Determine # readers */
    if (argc == 1)
	nreaders = DEFAULT_READERS;
    else
	sscanf(*++argv, "%d", &nreaders);
    printf("[There will be %d readers]\n", nreaders);

    interval = (argc >= 3 ? atoi(*++argv)*1000 : 50000);

    if (argc == 4) lwp_debug = 1;
    LWP_InitializeProcessSupport(0, &master);
    printf("[Support initialized]\n");
    tv.tv_sec = 0;
    tv.tv_usec = interval;
    PRE_InitPreempt(&tv);
    
    /* Initialize queue */
    q = init();

    /* Initialize lock */
    Lock_Init(&q->lock);

    asleep = 0;
    /* Now create readers */
    printf("[Creating Readers...\n");
    readers = (PROCESS *) calloc(nreaders, sizeof(PROCESS));
    readersid = (int *) calloc(nreaders, sizeof(int));
    for (i=0; i<nreaders; i++) {
        snprintf(rname, sizeof(rname), "Reader %d", i);
	readersid[i] = i;
	LWP_CreateProcess(read_process,
			  STACK_SIZE, 0, (char *)&readersid[i], 
			  rname, &readers[i]);
    }
    printf("done]\n");

    printf("\t[Creating Writer...\n");
    LWP_CreateProcess(write_process, STACK_SIZE, 1, 0, "Writer", &writer);
    printf("done]\n");

    /* Now loop until everyone's done */
    while (asleep != nreaders+1) LWP_DispatchProcess();
    /* Destroy the readers */
    for (i=nreaders-1; i>=0; i--) LWP_DestroyProcess(readers[i]);
    printf("\n*Exiting*\n");
    return 0;
}
@


1.5
log
@afs cleanup, realloc strings, abort, etc.
testing by beck, hin, jose, fries. ok deraadt@@
@
text
@@


1.4
log
@Merge
@
text
@d80 1
a80 2
	printf("Remove from empty queue");
	abort();
@


1.3
log
@strcpy/strcat/sprintf cleanups; ok krw deraadt
@
text
@d97 2
a98 1
static int read_process(int id)
d100 2
a101 2
    printf("\t[Reader %d]\n", id);
    LWP_NewRock(1, (char *)id);
a107 1
	int foo;
d121 1
a121 2
	foo = (int)tmp;
	printf("[%d: %s]\n", foo, Remove(q));
d205 1
d239 1
d242 4
a245 2
	LWP_CreateProcess((void (*)())(read_process),
			  STACK_SIZE, 0, (char *)i, rname, &readers[i]);
@


1.2
log
@New Arla userland from Arla between 0.34.2 and current in arla cvs.
Too many new features and fixes to mention here.
@
text
@d240 1
a240 1
        sprintf(rname, "Reader %d", i);
@


1.1
log
@upgrade Arla to fresher code. Too many new features and bugfixes.
@
text
@a0 1
/*	$OpenBSD$	*/
d48 1
a48 1
queue *init()
d57 1
a57 1
char empty(queue *q)
d62 1
a62 1
void insert(queue *q, char *s)
d74 1
a74 1
char *Remove(queue *q)
a98 1
    int foo;
d100 1
a100 1
    LWP_NewRock(1, id);
d105 3
a107 1
        register int i;
d120 2
a121 1
	LWP_GetRock(1, &foo);
d241 2
a242 2
	LWP_CreateProcess((void *)(read_process), STACK_SIZE, 0, (char *)i, 
			  rname, &readers[i]);
@


1.1.1.1
log
@Import of arla-0.35.7
@
text
@d1 1
d49 1
a49 1
static queue *init()
d58 1
a58 1
static char empty(queue *q)
d63 1
a63 1
static void insert(queue *q, char *s)
d75 1
a75 1
static char *Remove(queue *q)
d100 1
d102 1
a102 1
    LWP_NewRock(1, (char *)id);
d107 1
a107 3
        int i;
	char *tmp;
	int foo;
d120 1
a120 2
	LWP_GetRock(1, &tmp);
	foo = (int)tmp;
d240 2
a241 2
	LWP_CreateProcess((void (*)())(read_process),
			  STACK_SIZE, 0, (char *)i, rname, &readers[i]);
@


1.1.1.2
log
@Import of arla -current as of Aug 5 2003

ok todd@@ deraadt@@
@
text
@d97 1
a97 2
static void
read_process(char *id)
d99 2
a100 2
    printf("\t[Reader %d]\n", *(int *)id);
    LWP_NewRock(1, id);
d107 1
d121 2
a122 1
	printf("[%d: %s]\n", *(int *)tmp, Remove(q));
a205 1
    int *readersid;
a238 1
    readersid = (int *) calloc(nreaders, sizeof(int));
d240 3
a242 5
        snprintf(rname, sizeof(rname), "Reader %d", i);
	readersid[i] = i;
	LWP_CreateProcess(read_process,
			  STACK_SIZE, 0, (char *)&readersid[i], 
			  rname, &readers[i]);
@


