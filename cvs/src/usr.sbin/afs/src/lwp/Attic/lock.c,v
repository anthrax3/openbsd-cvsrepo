head	1.7;
access;
symbols
	OPENBSD_5_2:1.6.0.4
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.2
	OPENBSD_5_0:1.5.0.32
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.30
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.28
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.24
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.5.0.26
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.5.0.22
	OPENBSD_4_5_BASE:1.5
	OPENBSD_4_4:1.5.0.20
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3:1.5.0.18
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.5.0.16
	OPENBSD_4_2_BASE:1.5
	OPENBSD_4_1:1.5.0.14
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.5.0.12
	OPENBSD_4_0_BASE:1.5
	OPENBSD_3_9:1.5.0.10
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.5.0.8
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.6
	OPENBSD_3_7_BASE:1.5
	OPENBSD_3_6:1.5.0.4
	OPENBSD_3_6_BASE:1.5
	OPENBSD_3_5:1.5.0.2
	OPENBSD_3_5_BASE:1.5
	OPENBSD_3_4:1.4.0.2
	OPENBSD_3_4_BASE:1.4
	arla-20030805:1.1.1.3
	OPENBSD_3_3:1.3.0.4
	OPENBSD_3_3_BASE:1.3
	OPENBSD_3_2:1.3.0.2
	OPENBSD_3_2_BASE:1.3
	arla-0-35-7:1.1.1.2
	OPENBSD_3_1:1.2.0.8
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.6
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_9:1.2.0.4
	OPENBSD_2_8:1.2.0.2
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.1.1.1.0.8
	OPENBSD_2_7_BASE:1.1.1.1
	OPENBSD_2_6:1.1.1.1.0.6
	OPENBSD_2_6_BASE:1.1.1.1
	OPENBSD_2_5:1.1.1.1.0.4
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.2
	OPENBSD_2_4_BASE:1.1.1.1
	arla-0_9:1.1.1.1
	arla:1.1.1;
locks; strict;
comment	@ * @;


1.7
date	2012.08.23.06.21.52;	author deraadt;	state dead;
branches;
next	1.6;

1.6
date	2011.09.21.21.05.40;	author jsg;	state Exp;
branches;
next	1.5;

1.5
date	2003.12.16.20.13.55;	author beck;	state Exp;
branches;
next	1.4;

1.4
date	2003.08.05.09.07.34;	author hin;	state Exp;
branches;
next	1.3;

1.3
date	2002.06.07.04.41.27;	author hin;	state Exp;
branches;
next	1.2;

1.2
date	2000.09.11.14.41.08;	author art;	state Exp;
branches;
next	1.1;

1.1
date	98.09.14.21.53.11;	author art;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.09.14.21.53.11;	author art;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.06.07.04.14.29;	author hin;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2003.08.05.08.21.04;	author hin;	state Exp;
branches;
next	;


desc
@@


1.7
log
@the afs src tree can go away
@
text
@/*
****************************************************************************
*        Copyright IBM Corporation 1988, 1989 - All Rights Reserved        *
*                                                                          *
* Permission to use, copy, modify, and distribute this software and its    *
* documentation for any purpose and without fee is hereby granted,         *
* provided that the above copyright notice appear in all copies and        *
* that both that copyright notice and this permission notice appear in     *
* supporting documentation, and that the name of IBM not be used in        *
* advertising or publicity pertaining to distribution of the software      *
* without specific, written prior permission.                              *
*                                                                          *
* IBM DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL *
* IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL IBM *
* BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY      *
* DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER  *
* IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING   *
* OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.    *
****************************************************************************
*/

/*******************************************************************\
* 								    *
* 	Information Technology Center				    *
* 	Carnegie-Mellon University				    *
* 								    *
* 								    *
* 								    *
\*******************************************************************/

/*
 * Locking routines for Vice.
 */

#ifdef HAVE_CONFIG_H
#include "config.h"
RCSID("$arla: lock.c,v 1.11 2002/06/01 17:47:47 lha Exp $");
#endif
#include "lwp.h"
#include "lock.h"
#include <stdio.h>
#include <stdlib.h>
#include <sys/time.h>
#include <err.h>


#define FALSE	0
#define TRUE	1

void
Lock_Init(struct Lock *lock)
{
    lock -> readers_reading = 0;
    lock -> excl_locked = 0;
    lock -> wait_states = 0;
    lock -> num_waiting = 0;
    lock -> thread_index = LWP_INVALIDTHREADID;
}

void
Lock_Obtain(struct Lock *lock, int how)
{
    switch (how) {

	case READ_LOCK:		lock->num_waiting++;
				do {
				    lock -> wait_states |= READ_LOCK;
				    LWP_WaitProcess(&lock->readers_reading);
				} while (lock->excl_locked & WRITE_LOCK);
				lock->num_waiting--;
				lock->readers_reading++;
				break;

	case WRITE_LOCK:	lock->num_waiting++;
				do {
				    lock -> wait_states |= WRITE_LOCK;
				    LWP_WaitProcess(&lock->excl_locked);
				} while (lock->excl_locked || lock->readers_reading);
				lock->num_waiting--;
				lock->excl_locked = WRITE_LOCK;
				break;

	case SHARED_LOCK:	lock->num_waiting++;
				do {
				    lock->wait_states |= SHARED_LOCK;
				    LWP_WaitProcess(&lock->excl_locked);
				} while (lock->excl_locked);
				lock->num_waiting--;
				lock->excl_locked = SHARED_LOCK;
				break;

	case BOOSTED_LOCK:	lock->num_waiting++;
				do {
				    lock->wait_states |= WRITE_LOCK;
				    LWP_WaitProcess(&lock->excl_locked);
				} while (lock->readers_reading);
				lock->num_waiting--;
				lock->excl_locked = WRITE_LOCK;
				break;

	default:		
		errx(-1, "Can't happen, bad LOCK type: %d\n", how);
		/* NOTREACHED */
    }
}

/* release a lock, giving preference to new readers */
void
Lock_ReleaseR(struct Lock *lock)
{
    if (lock->wait_states & READ_LOCK) {
	lock->wait_states &= ~READ_LOCK;
	LWP_NoYieldSignal(&lock->readers_reading);
    }
    else {
	lock->wait_states &= ~EXCL_LOCKS;
	LWP_NoYieldSignal(&lock->excl_locked);
    }
}

/* release a lock, giving preference to new writers */
void
Lock_ReleaseW(struct Lock *lock)
{
    if (lock->wait_states & EXCL_LOCKS) {
	lock->wait_states &= ~EXCL_LOCKS;
	LWP_NoYieldSignal(&lock->excl_locked);
    }
    else {
	lock->wait_states &= ~READ_LOCK;
	LWP_NoYieldSignal(&lock->readers_reading);
    }
}

/* 
 * These next guys exist to provide an interface to drop a lock atomically with
 * blocking.  They're trivial to do in a non-preemptive LWP environment.
 */

/* release a write lock and sleep on an address, atomically */
void
LWP_WaitProcessR(char *addr, struct Lock *alock)
{
    ReleaseReadLock(alock);
    LWP_WaitProcess(addr);
}

/* release a write lock and sleep on an address, atomically */
void
LWP_WaitProcessW(char *addr, struct Lock *alock)
{
    ReleaseWriteLock(alock);
    LWP_WaitProcess(addr);
}

/* release a write lock and sleep on an address, atomically */
void
LWP_WaitProcessS(char *addr, struct Lock *alock)
{
    ReleaseSharedLock(alock);
    LWP_WaitProcess(addr);
}

#ifndef HAVE___FUNCTION__
#define __FUNCTION__ "unknown"
#endif

#define PANICPRINT(msg)	fprintf(stderr,"Panic in %s at %s:%d: %s\n", __FUNCTION__, __FILE__, __LINE__, msg)
    
static int
WillBlock (struct Lock *lock, int how) 
{
    switch (how) {
    case READ_LOCK:
	return ((lock)->excl_locked & WRITE_LOCK) || (lock)->wait_states;
    case WRITE_LOCK:
	return (lock)->excl_locked || (lock)->readers_reading;
    case SHARED_LOCK:
	return (lock)->excl_locked || (lock)->wait_states;
    default:
	PANICPRINT("unknown locking type");
	return 1; /* Block if unknown */
    }
}

static void
ObtainOneLock(struct Lock *lock, int how)
{
    switch (how) {
    case READ_LOCK: 
	if (!WillBlock(lock, how))
	    (lock) -> readers_reading++;
	else
	    Lock_Obtain(lock, how);
	break;
    case WRITE_LOCK:
    case SHARED_LOCK:
	if (!WillBlock(lock, how))
	    (lock) -> excl_locked = how;
	else
	    Lock_Obtain(lock, how);
	break;
    default:
	PANICPRINT("unknown locking type");
	fprintf(stderr,"%d\n",how);
    }
}

static void
ReleaseOneLock(struct Lock *lock, int how)
{
    switch(how) {
    case READ_LOCK:
	if (!--(lock)->readers_reading && (lock)->wait_states)
	    Lock_ReleaseW(lock);
	break;
    case WRITE_LOCK:
	(lock)->excl_locked &= ~WRITE_LOCK;
	if ((lock)->wait_states) Lock_ReleaseR(lock);
	break;
    case SHARED_LOCK:
	(lock)->excl_locked &= ~(SHARED_LOCK | WRITE_LOCK);
	if ((lock)->wait_states) Lock_ReleaseR(lock);
	break;
    default:
	PANICPRINT("unknown locking type");
    }
}

/*
 * Obtains two locks in a secure fashion (that's the idea)
 *
 * Takes two locks and two locking modes as parameters.
 */

void
_ObtainTwoLocks(struct Lock *lock1, int how1,
		struct Lock *lock2, int how2)
{
    struct timeval timeout;

    timeout.tv_sec = 0;
    timeout.tv_usec = 1000;
    
start:
    ObtainOneLock(lock1, how1);
    if (WillBlock(lock2, how2)) {
	ReleaseOneLock(lock1, how1);
	IOMGR_Select(0, 0, 0, 0, &timeout);
	goto start;
    } else {
	ObtainOneLock(lock2, how2);
    }
}
@


1.6
log
@fix missing err.h includes
@
text
@@


1.5
log
@afs cleanup, realloc strings, abort, etc.
testing by beck, hin, jose, fries. ok deraadt@@
@
text
@d44 1
@


1.4
log
@Merge
@
text
@d100 3
a102 2
	default:		printf("Can't happen, bad LOCK type: %d\n", how);
				abort();
@


1.3
log
@merge
@
text
@d37 1
a37 1
RCSID("$KTH: lock.c,v 1.10 2000/10/20 11:04:47 lha Exp $");
d50 1
a50 1
Lock_Init(register struct Lock *lock)
d60 1
a60 1
Lock_Obtain(register struct Lock *lock, int how)
d107 1
a107 1
Lock_ReleaseR(register struct Lock *lock)
d121 1
a121 1
Lock_ReleaseW(register struct Lock *lock)
d140 1
a140 1
LWP_WaitProcessR(register char *addr, register struct Lock *alock)
d148 1
a148 1
LWP_WaitProcessW(register char *addr, register struct Lock *alock)
d156 1
a156 1
LWP_WaitProcessS(register char *addr, register struct Lock *alock)
d169 1
a169 1
WillBlock (register struct Lock *lock, int how) 
d185 1
a185 1
ObtainOneLock(register struct Lock *lock, int how)
d208 1
a208 1
ReleaseOneLock(register struct Lock *lock, int how)
d235 2
a236 2
_ObtainTwoLocks(register struct Lock *lock1, int how1,
		register struct Lock *lock2, int how2)
@


1.2
log
@New Arla userland from Arla between 0.34.2 and current in arla cvs.
Too many new features and fixes to mention here.
@
text
@d37 1
a37 1
RCSID("$Id: lock.c,v 1.9 2000/08/19 16:31:12 assar Exp $");
d56 1
@


1.1
log
@Initial revision
@
text
@a0 1
/*	$OpenBSD$	*/
d37 1
a37 1
RCSID("$KTH: lock.c,v 1.7 1998/01/27 19:58:27 art Exp $");
d42 1
@


1.1.1.1
log
@Initial version of Arla, a free implementation of an AFS cache-manager.
(second try, hopefully into the correct repository this time)
@
text
@@


1.1.1.2
log
@Import of arla-0.35.7
@
text
@d1 1
d38 1
a38 1
RCSID("$KTH: lock.c,v 1.10 2000/10/20 11:04:47 lha Exp $");
a42 1
#include <stdlib.h>
a55 1
    lock -> thread_index = LWP_INVALIDTHREADID;
@


1.1.1.3
log
@Import of arla -current as of Aug 5 2003

ok todd@@ deraadt@@
@
text
@d37 1
a37 1
RCSID("$arla: lock.c,v 1.11 2002/06/01 17:47:47 lha Exp $");
d50 1
a50 1
Lock_Init(struct Lock *lock)
d60 1
a60 1
Lock_Obtain(struct Lock *lock, int how)
d107 1
a107 1
Lock_ReleaseR(struct Lock *lock)
d121 1
a121 1
Lock_ReleaseW(struct Lock *lock)
d140 1
a140 1
LWP_WaitProcessR(char *addr, struct Lock *alock)
d148 1
a148 1
LWP_WaitProcessW(char *addr, struct Lock *alock)
d156 1
a156 1
LWP_WaitProcessS(char *addr, struct Lock *alock)
d169 1
a169 1
WillBlock (struct Lock *lock, int how) 
d185 1
a185 1
ObtainOneLock(struct Lock *lock, int how)
d208 1
a208 1
ReleaseOneLock(struct Lock *lock, int how)
d235 2
a236 2
_ObtainTwoLocks(struct Lock *lock1, int how1,
		struct Lock *lock2, int how2)
@


