head	1.5;
access;
symbols
	OPENBSD_5_2:1.4.0.38
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.36
	OPENBSD_5_0:1.4.0.34
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.32
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.30
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.4.0.26
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.4.0.28
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.4.0.24
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.4.0.22
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.4.0.20
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.4.0.18
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.4.0.16
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.4.0.14
	OPENBSD_4_0_BASE:1.4
	OPENBSD_3_9:1.4.0.12
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.10
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.8
	OPENBSD_3_7_BASE:1.4
	OPENBSD_3_6:1.4.0.6
	OPENBSD_3_6_BASE:1.4
	OPENBSD_3_5:1.4.0.4
	OPENBSD_3_5_BASE:1.4
	OPENBSD_3_4:1.4.0.2
	OPENBSD_3_4_BASE:1.4
	arla-20030805:1.1.1.2
	OPENBSD_3_3:1.3.0.4
	OPENBSD_3_3_BASE:1.3
	OPENBSD_3_2:1.3.0.2
	OPENBSD_3_2_BASE:1.3
	arla-0-35-7:1.1.1.1
	arla:1.1.1
	OPENBSD_3_1:1.2.0.8
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.6
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_9:1.2.0.4
	OPENBSD_2_8:1.2.0.2
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.1.0.4
	OPENBSD_2_7_BASE:1.1
	OPENBSD_2_6:1.1.0.2
	OPENBSD_2_6_BASE:1.1;
locks; strict;
comment	@ * @;


1.5
date	2012.08.23.06.21.52;	author deraadt;	state dead;
branches;
next	1.4;

1.4
date	2003.08.05.09.07.34;	author hin;	state Exp;
branches;
next	1.3;

1.3
date	2002.06.07.04.41.27;	author hin;	state Exp;
branches;
next	1.2;

1.2
date	2000.09.11.14.41.09;	author art;	state Exp;
branches;
next	1.1;

1.1
date	99.04.30.01.59.13;	author art;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.06.07.04.14.30;	author hin;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.08.05.08.21.04;	author hin;	state Exp;
branches;
next	;


desc
@@


1.5
log
@the afs src tree can go away
@
text
@/*
 * $arla: plwp.h,v 1.9 2003/01/03 16:26:08 tol Exp $
 */

#ifndef LWP_INCLUDED
#define LWP_INCLUDED

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

#ifdef HAVE_SYS_TYPES_H
#include <sys/types.h>
#endif
#ifdef HAVE_SYS_SELECT_H
#include <sys/select.h>
#endif
#ifdef HAVE_UNISTD_H
#include <unistd.h>
#endif
#ifdef HAVE_POSIX_SIGNALS
#define AFS_POSIX_SIGNALS 1
#endif
#define AFS_LWP_MINSTACKSIZE    (100 * 1024)
#include <sys/time.h>
#include <signal.h>

#ifdef PTHREADS_LWP
#include <pthread.h>
#endif

#include <roken.h>

#ifdef WINDOWS_THREADS_LWP
#include <windows.h>
#endif

#ifndef LWP_KERNEL
extern
#endif
	int lwp_debug;          /* ON = show LWP debugging trace */

extern int lwp_stackUseEnabled;
extern int lwp_MaxStackSeen;
#define LWP_ActiveProcess       (lwp_cpptr+0)

#define LWP_VERSION  210888001

#define LWP_SUCCESS	0
#define LWP_EBADPID	-1
#define LWP_EBLOCKED	-2
#define LWP_EINIT	-3
#define LWP_EMAXPROC	-4
#define LWP_ENOBLOCK	-5
#define LWP_ENOMEM	-6
#define LWP_ENOPROCESS	-7
#define LWP_ENOWAIT	-8
#define LWP_EBADCOUNT	-9
#define LWP_EBADEVENT	-10
#define LWP_EBADPRI	-11
#define LWP_NO_STACK	-12
/* These two are for the signal mechanism. */
#define LWP_EBADSIG	-13		/* bad signal number */
#define LWP_ESYSTEM	-14		/* system call failed */
/* These are for the rock mechanism */
#define LWP_ENOROCKS	-15	/* all rocks are in use */
#define LWP_EBADROCK	-16	/* the specified rock does not exist */


/* Maximum priority permissible (minimum is always 0) */
#define LWP_MAX_PRIORITY 4

/* Usual priority used by user LWPs */
#define LWP_NORMAL_PRIORITY (LWP_MAX_PRIORITY-1)

#define LWP_SignalProcess(event)	LWP_INTERNALSIGNAL(event, 1)
#define LWP_NoYieldSignal(event)	LWP_INTERNALSIGNAL(event, 0)

/* Users aren't really supposed to know what a pcb is, but .....*/
typedef struct lwp_pcb *PROCESS;

/* Action to take on stack overflow. */
#define LWP_SOQUIET	1		/* do nothing */
#define LWP_SOABORT	2		/* abort the program */
#define LWP_SOMESSAGE	3		/* print a message and be quiet */
extern int lwp_overflowAction;

/* Invalid LWP Index */
#define LWP_INVALIDTHREADID		(-1)

/* Tells if stack size counting is enabled. */
extern int lwp_stackUseEnabled;

int LWP_QWait(void);
int LWP_QSignal(PROCESS);
int LWP_Init(int, int, PROCESS *);
int LWP_InitializeProcessSupport(int, PROCESS *);
int LWP_TerminateProcessSupport();
int LWP_CreateProcess(void (*)(), int, int, char *, char *, PROCESS *);
int LWP_CurrentProcess(PROCESS *);
int LWP_DestroyProcess(PROCESS);
int LWP_DispatchProcess();
int LWP_GetProcessPriority(PROCESS, int *);
int LWP_INTERNALSIGNAL(void *, int);
int LWP_WaitProcess(void *);
int LWP_MwaitProcess(int, char **);
int LWP_StackUsed(PROCESS, int *, int *); 
int LWP_NewRock(int, char *);
int LWP_GetRock(int,  char **);
char *LWP_Name();
int LWP_Index();
int LWP_HighestIndex();

int IOMGR_SoftSig(void (*)(), char *);
int IOMGR_Initialize(void);
int IOMGR_Finalize(void);
long IOMGR_Poll(void);
int IOMGR_Select(int, fd_set *, fd_set *, fd_set *, struct timeval *);
int IOMGR_Cancel(PROCESS);
int IOMGR_Signal(int, char *);
int IOMGR_CancelSignal(int);
void IOMGR_Sleep(unsigned int);

int FT_Init(int, int);
#if	__GNUC__ >= 2
struct timezone;
#endif
int FT_GetTimeOfDay(struct timeval *, struct timezone *);
int TM_GetTimeOfDay(struct timeval *, struct timezone *);
int FT_AGetTimeOfDay(struct timeval *, struct timezone *);
unsigned int FT_ApproxTime(void);

/* Initial size of eventlist in a PCB; grows dynamically  */ 
#define EVINITSIZE  5

struct rock 
 {/* to hide things associated with this LWP under */
   int  tag;		/* unique identifier for this rock */
   /* pointer to some arbitrary data structure */
#if defined(PTHREADS_LWP)
   pthread_key_t val;
#elif defined(WINDOWS_THREADS_LWP)
   LPVOID val;
#endif
 };

#define MAXROCKS	4	/* max no. of rocks per LWP */

struct lwp_pcb {			/* process control block */
  char name[32];
  int rc;
  char status;      
  char **eventlist; 
  char eventlistsize; 
  int eventcnt;	   
  int wakevent;
  int waitcnt;	
  char blockflag;
  int priority;		
  PROCESS misc;		
  char *stack;		
  int stacksize;
  long stackcheck;
  void (*ep)(char *);
  char *parm;		
  int rused;		
  struct rock rlist[MAXROCKS];
  PROCESS next, prev;	
  int level;          
  struct IoRequest *iomgrRequest;
  int index;        
  struct timeval lastReady;
#if defined(PTHREADS_LWP)
  pthread_mutex_t m;       
  pthread_cond_t c;        
  pthread_attr_t a;        
#elif defined(WINDOWS_THREADS_LWP)
  HANDLE m;
  HANDLE c;
  HANDLE t;
#endif
};

extern int lwp_nextindex;                      /* Next lwp index to assign */

extern PROCESS	lwp_cpptr;		/* pointer to current process pcb */
struct	 lwp_ctl {			/* LWP control structure */
    int		processcnt;		/* number of lightweight processes */
    char	*outersp;		/* outermost stack pointer */
    PROCESS	outerpid;		/* process carved by Initialize */
    PROCESS	first, last;		/* ptrs to first and last pcbs */
    char	dsptchstack[800];	/* stack for dispatcher use only */
};

/* Debugging macro */
#ifdef LWPDEBUG
#define lwpdebug(level, msg)\
	 if (lwp_debug > level) {\
	     printf("***LWP (0x%x): ", lwp_cpptr);\
	     printf msg;\
	     putchar('\n');\
	     fflush(stdout);\
	 }
#else /* LWPDEBUG */
#define lwpdebug(level, msg)
#endif /* LWPDEBUG */

#define MAXTHREADS	100

#endif /* LWP_INCLUDED */



@


1.4
log
@Merge
@
text
@@


1.3
log
@merge
@
text
@d2 1
a2 1
 * $KTH: plwp.h,v 1.5 2000/10/20 11:01:46 lha Exp $
a11 4
#ifdef WINDOWS_THREADS_LWP
#include <windows.h>
#endif

d34 4
d41 1
a41 1
char lwp_debug;          /* ON = show LWP debugging trace */
d119 1
a119 1
int IOMGR_Cancel(register PROCESS);
d128 1
a128 1
int FT_GetTimeOfDay(register struct timeval *, register struct timezone *);
a193 2

extern char PRE_Block;			/* used in preemption control (in preempt.c) */
@


1.2
log
@New Arla userland from Arla between 0.34.2 and current in arla cvs.
Too many new features and fixes to mention here.
@
text
@d2 1
a2 1
 * $Id: plwp.h,v 1.4 1999/11/17 22:45:40 assar Exp $
d87 3
@


1.1
log
@upgrade Arla to fresher code. Too many new features and bugfixes.
@
text
@d1 4
a4 1
/*	$OpenBSD$	*/
d12 4
d32 6
d102 1
a102 1
int LWP_WaitProcess(char *);
a129 2
#include <pthread.h>

d133 10
a142 6
struct rock
    {/* to hide things associated with this LWP under */
      int  tag;		/* unique identifier for this rock */
      pthread_key_t val;
      /*char *value;*/	/* pointer to some arbitrary data structure */
    };
d170 1
d174 5
@


1.1.1.1
log
@Import of arla-0.35.7
@
text
@d1 1
a1 4
/*
 * $KTH: plwp.h,v 1.5 2000/10/20 11:01:46 lha Exp $
 */

a8 4
#ifdef WINDOWS_THREADS_LWP
#include <windows.h>
#endif

a24 6
#ifdef PTHREADS_LWP
#include <pthread.h>
#endif

#include <roken.h>

a74 3
/* Invalid LWP Index */
#define LWP_INVALIDTHREADID		(-1)

d89 1
a89 1
int LWP_WaitProcess(void *);
d117 2
d122 6
a127 10
struct rock 
 {/* to hide things associated with this LWP under */
   int  tag;		/* unique identifier for this rock */
   /* pointer to some arbitrary data structure */
#if defined(PTHREADS_LWP)
   pthread_key_t val;
#elif defined(WINDOWS_THREADS_LWP)
   LPVOID val;
#endif
 };
a154 1
#if defined(PTHREADS_LWP)
a157 5
#elif defined(WINDOWS_THREADS_LWP)
  HANDLE m;
  HANDLE c;
  HANDLE t;
#endif
@


1.1.1.2
log
@Import of arla -current as of Aug 5 2003

ok todd@@ deraadt@@
@
text
@d2 1
a2 1
 * $arla: plwp.h,v 1.9 2003/01/03 16:26:08 tol Exp $
d12 4
a37 4
#ifdef WINDOWS_THREADS_LWP
#include <windows.h>
#endif

d41 1
a41 1
	int lwp_debug;          /* ON = show LWP debugging trace */
d119 1
a119 1
int IOMGR_Cancel(PROCESS);
d128 1
a128 1
int FT_GetTimeOfDay(struct timeval *, struct timezone *);
d194 2
@


