head	1.6;
access;
symbols
	OPENBSD_5_2:1.5.0.24
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.22
	OPENBSD_5_0:1.5.0.20
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.18
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.16
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.12
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.5.0.14
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.5.0.10
	OPENBSD_4_5_BASE:1.5
	OPENBSD_4_4:1.5.0.8
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3:1.5.0.6
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.5.0.4
	OPENBSD_4_2_BASE:1.5
	OPENBSD_4_1:1.5.0.2
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.2.0.16
	OPENBSD_4_0_BASE:1.2
	OPENBSD_3_9:1.2.0.14
	OPENBSD_3_9_BASE:1.2
	OPENBSD_3_8:1.2.0.12
	OPENBSD_3_8_BASE:1.2
	OPENBSD_3_7:1.2.0.10
	OPENBSD_3_7_BASE:1.2
	OPENBSD_3_6:1.2.0.8
	OPENBSD_3_6_BASE:1.2
	OPENBSD_3_5:1.2.0.6
	OPENBSD_3_5_BASE:1.2
	OPENBSD_3_4:1.2.0.4
	OPENBSD_3_4_BASE:1.2
	arla-20030805:1.1.1.1
	OPENBSD_3_3:1.2.0.2
	OPENBSD_3_3_BASE:1.2
	OPENBSD_3_2:1.1.0.10
	OPENBSD_3_2_BASE:1.1
	arla-0-35-7:1.1.1.1
	arla:1.1.1
	OPENBSD_3_1:1.1.0.8
	OPENBSD_3_1_BASE:1.1
	OPENBSD_3_0:1.1.0.6
	OPENBSD_3_0_BASE:1.1
	OPENBSD_2_9_BASE:1.1
	OPENBSD_2_9:1.1.0.4
	OPENBSD_2_8:1.1.0.2
	OPENBSD_2_8_BASE:1.1;
locks; strict;
comment	@# @;


1.6
date	2012.08.23.06.21.52;	author deraadt;	state dead;
branches;
next	1.5;

1.5
date	2006.11.22.02.56.26;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	2006.11.21.08.17.00;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	2006.11.17.20.54.47;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2002.10.25.23.52.59;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	2000.09.11.14.41.09;	author art;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.06.07.04.14.30;	author hin;	state Exp;
branches;
next	;


desc
@@


1.6
log
@the afs src tree can go away
@
text
@#ifdef AFS_HPUX_ENV
#ifdef hp9000s300
/*
#
#	Process assembly language assist for HP 9000 series 300s.
#
*/

	text

/*
#
# struct savearea {
#	char	*topstack;
# }
#
*/

	global	_PRE_Block

	set topstack,0

/* Stuff to allow saving/restoring registers */
	set NREGS,13
	set REGS,0x3ffe			# d1-d7 & a0-a5

/*
# savecontext(f, area1, newsp)
#     int (*f)(); struct savearea *area1; char *newsp;
*/

/* Stack offsets of arguments */
	set f,8
	set area1,12
	set newsp,16

	global	_savecontext
_savecontext:
	mov.l	&1,_PRE_Block		# Dont allow any interrupt finagling
	link	%a6,&-(NREGS*4)		# Save frame pointer & ...
					# ... allocate space for nregs registers
/* Save registers */
	movem.l	&REGS,(%sp)

	mov.l	area1(%a6),%a0		# a0 = base of savearea
	mov.l	%sp,topstack(%a0)	# area->topstack = sp
	mov.l	newsp(%a6),%d0		# Get new sp
	beq.b	l1			# If newsp == 0, no stack switch
	mov.l	%d0,%sp			# Switch to new stack
l1:
	mov.l	f(%a6),%a0		# a0 = f
	jsr	(%a0)			# f()

/* It is impossible to be here, so abort() */

	jsr	_abort

/*
# returnto(area2)
#     struct savearea *area2;
*/

/* Stack offset of argument */
set	area2,8

	global _returnto
_returnto:
	link	%a6,&0
	mov.l	area2(%a6),%a0		# Base of savearea
	mov.l	topstack(%a0),%sp	# Restore sp
/* Restore registers */
	movem.l	(%sp),&REGS

	add.l	&(NREGS*4),%sp
	mov.l	%sp,%a6			# Argghh...be careful here
	unlk	%a6
	clr.l	_PRE_Block
	rts				# Return to previous process
#else

/* start of S700 code */
#ifdef AFS_HPUX_PIC_ENV
/* this code is PIC */
	.CODE

	/*
	; savecontext(f, area1, newsp)
	;    int (*f)();
	;    struct savearea *area1;
	;    char *newsp;
	*/
savecontext
	.PROC
	/*
	; Callinfo sets up register saves using the ENTRY_GR
	; and ENTRY_FR parameters.  ENTRY_FR=21 is only valid
	; for PA 1.1.  (How to deal with this for 800?)
	*/
	.CALLINFO CALLER,FRAME=0,SAVE_RP,ENTRY_GR=18,ENTRY_FR=21
	/*
	; The ENTER statement generates register saves and
	; procedure setup.
	*/
	.ENTER

	LDI   1,%r1				/* Store a (char) 1 in */
	LDW   T%PRE_Block(0,%r19),%r31    	/* global variable */
	STW   %r1,0(0,%r31)			/* PRE_Block. */


	COPY  %arg0,%r22	/* Copy arg0 (f) to dyncall's input register */

	COMIB,= 0,%arg2,L$0001	/* Compare arg2 (newsp) to 0.  Execute the */
				/* next instruction regardless of value. */
	STW   %r30,0(0,%arg1)	/* Store the stack pointer in the first */
				/* element (0th offset) of arg1 (area1). */
	COPY  %arg2,%r30	/* Move arg2 (newsp) into the stack ptr. */

L$0001
	.CALL
	BL    $$dyncall,%r31	/* Dynamic call using pointer in r22. */
	COPY  %r31,%r2
	COPY  %r20, %r19        /* restore link table. */

	.CALL
	BL    exit,%r2		/* Can't get here, so abort. */
	NOP
	.LEAVE
	.PROCEND

	/* returnto(area2)
	 *    struct savearea *area2;
	 */
returnto
	.PROC
	.CALLINFO CALLER,FRAME=0,SAVE_RP,ENTRY_GR=18,ENTRY_FR=21
	/*  No ENTRY is used since this is a magic routine. */
	LDWS  0(0,%arg0),%r30	/* Load the stack pointer from area2 */

	LDW   T%PRE_Block(0,%r19),%r31   /* set PRE_Block = 0; */
	STW   %r0,0(0,%r31)
	.LEAVE
	.PROCEND

	.EXPORT savecontext,ENTRY
	.EXPORT returnto,ENTRY
	.IMPORT PRE_Block,DATA
	.IMPORT $$dyncall,MILLICODE
	.IMPORT exit,CODE

	.END
#else  /* AFS_HPUX_PIC_ENV */
/* non-pic'ified code */
	.CODE

	/*
	; savecontext(f, area1, newsp)
	;    int (*f)();
	;    struct savearea *area1;
	;    char *newsp;
	*/
savecontext
	.PROC
	/*
	; Callinfo sets up register saves using the ENTRY_GR
	; and ENTRY_FR parameters.  ENTRY_FR=21 is only valid
	; for PA 1.1.  (How to deal with this for 800?)
	*/
	.CALLINFO CALLER,FRAME=0,SAVE_RP,ENTRY_GR=18,ENTRY_FR=21
	/* The ENTER statement generates register saves and */
	/* procedure setup. */
	.ENTER

	LDI   1,%r31				/* Store a (char) 1 in */
	ADDIL L%PRE_Block-$global$,%r27		/* global variable */
	STW   %r31,R%PRE_Block-$global$(0,%r1)	/* PRE_Block. */

	COPY  %r26,%r22		/* Copy arg0 (f) to dyncall's input register. */

	COMIB,= 0,%r24,L$0001	/* Compare arg2 (newsp) to 0.  Execute the */
				/* next instruction regardless of value. */
	STWS  %r30,0(0,%r25)	/* Store the stack pointer in the first */
				/* element (0th offset) of arg1 (area1). */
	COPY  %r24,%r30		/* Move arg2 (newsp) into the stack ptr. */

L$0001
	.CALL
	BL    $$dyncall,%r31	/* Dynamic call using pointer in r22. */
	COPY  %r31,%r2

	.CALL
	BL    abort,%r2		/* Can't get here, so abort.
	NOP
	.LEAVE
	.PROCEND

	/*
	; returnto(area2)
	;    struct savearea *area2;
	*/
returnto
	.PROC
	.CALLINFO CALLER,FRAME=0,SAVE_RP,ENTRY_GR=18,ENTRY_FR=21
	/*  No ENTRY is used since this is a magic routine. */
	ADDIL L%PRE_Block-$global$,%r27		/* PRE_Block = 0 */
	STW   %r0,R%PRE_Block-$global$(0,%r1)

	LDWS  0(0,%r26),%r30	/* Load the stack pointer from area2 */
	.LEAVE
	.PROCEND

	.EXPORT savecontext,ENTRY
	.EXPORT returnto,ENTRY
	.IMPORT $global$,DATA
	.IMPORT PRE_Block,DATA
	.IMPORT $$dyncall,MILLICODE
	.IMPORT abort,CODE

	.END
#endif /* AFS_HPUX_PIC_ENV */
#endif /* hp9000s300 */
#endif /* AFS_HPUX_ENV */

#ifdef AFS_BSD_ENV
#ifdef AFS_BSD_PIC_ENV
/* this code is PIC */
	.CODE

	/*
	; savecontext(f, area1, newsp)
	;    int (*f)();
	;    struct savearea *area1;
	;    char *newsp;
	*/
savecontext
	.PROC
	/*
	; Callinfo sets up register saves using the ENTRY_GR
	; and ENTRY_FR parameters.  ENTRY_FR=21 is only valid
	; for PA 1.1.  (How to deal with this for 800?)
	*/
	.CALLINFO CALLER,FRAME=0,SAVE_RP,ENTRY_GR=18,ENTRY_FR=21
	.ENTRY
	STW   %r2, -20(%sr0,%r30)
	stwm  %r3, 0x80(%r30)
	stw   %r4, -0x40(%r30)
	stw   %r5, -0x3c(%r30)
	stw   %r6, -0x38(%r30)
	stw   %r7, -0x34(%r30)
	stw   %r8, -0x30(%r30)
	stw   %r9, -0x2c(%r30)
	stw   %r10, -0x28(%r30)
	stw   %r11, -0x24(%r30)
	stw   %r12, -0x20(%r30)
	stw   %r13, -0x1c(%r30)
	stw   %r14, -0x18(%r30)
	stw   %r15, -0x14(%r30)
	stw   %r16, -0x10(%r30)
	stw   %r17, -0x0c(%r30)
	stw   %r18, -0x08(%r30)
	stw   %r19, -0x04(%r30)

	LDI   1,%r1				/* Store a (char) 1 in */
	LDW   T%PRE_Block(%sr0,%r19),%r31    	/* global variable */
	STW   %r1,0(%sr0,%r31)			/* PRE_Block. */


	COPY  %arg0,%r22	/* Copy arg0 (f) to dyncall's input register */

	COMIB,= 0,%arg2,L$0001	/* Compare arg2 (newsp) to 0.  Execute the */
				/* next instruction regardless of value. */
	STW   %r30,0(%sr0,%arg1)/* Store the stack pointer in the first */
				/* element (0th offset) of arg1 (area1). */
	COPY  %arg2,%r30	/* Move arg2 (newsp) into the stack ptr. */

L$0001
	ldo   64(%r30), %r30
	.CALL
	BL    $$dyncall,%r31	/* Dynamic call using pointer in r22. */
	COPY  %r31,%r2
	COPY  %r20, %r19        /* restore link table. */

	.CALL
	BL    exit,%r2		/* Can't get here, so abort. */
	NOP
	.LEAVE
	.PROCEND

	/* returnto(area2)
	 *    struct savearea *area2;
	 */
returnto
	.PROC
	.CALLINFO CALLER,FRAME=0,SAVE_RP,ENTRY_GR=18,ENTRY_FR=21
	/*  No ENTRY is used since this is a magic routine. */
	LDWS  0(0,%arg0),%r30	/* Load the stack pointer from area2 */

	ldw   -0x04(%r30), %r19
	ldw   -0x08(%r30), %r18
	ldw   -0x0c(%r30), %r17
	ldw   -0x10(%r30), %r16
	ldw   -0x14(%r30), %r15
	ldw   -0x18(%r30), %r14
	ldw   -0x1c(%r30), %r13
	ldw   -0x20(%r30), %r12
	ldw   -0x24(%r30), %r11
	ldw   -0x28(%r30), %r10
	ldw   -0x2c(%r30), %r9
	ldw   -0x30(%r30), %r8
	ldw   -0x34(%r30), %r7
	ldw   -0x38(%r30), %r6
	ldw   -0x3c(%r30), %r5
	ldw   -0x40(%r30), %r4
	ldw,mb -0x80(%r30), %r3
	LDW   T%PRE_Block(0,%r19),%r31   /* set PRE_Block = 0; */
	LDW   -20(%sr0,%r30), %r2
	BV    %r0(%r2)
	STW   %r0,0(0,%r31)
	.LEAVE
	.PROCEND

	.EXPORT savecontext,ENTRY
	.EXPORT returnto,ENTRY
	.IMPORT PRE_Block,DATA
	.IMPORT $$dyncall,MILLICODE
	.IMPORT exit,CODE

	.END
#else  /* AFS_BSD_PIC_ENV */
/* non-pic'ified code */
	.IMPORT $global$,DATA
	.IMPORT PRE_Block,DATA
	.IMPORT $$dyncall,MILLICODE
	.IMPORT abort,CODE

	.text

	/*
	; savecontext(f, area1, newsp)
	;    int (*f)();
	;    struct savearea *area1;
	;    char *newsp;
	*/
	.EXPORT savecontext,ENTRY
savecontext
	.PROC
	/*
	; Callinfo sets up register saves using the ENTRY_GR
	; and ENTRY_FR parameters.  ENTRY_FR=21 is only valid
	; for PA 1.1.  (How to deal with this for 800?)
	*/
	.CALLINFO CALLER,FRAME=0,SAVE_RP,ENTRY_GR=18,ENTRY_FR=21
	.ENTRY
	STW   %r2, -20(%sr0,%r30)
	stwm  %r3, 0x80(%r30)
	stw   %r4, -0x40(%r30)
	stw   %r5, -0x3c(%r30)
	stw   %r6, -0x38(%r30)
	stw   %r7, -0x34(%r30)
	stw   %r8, -0x30(%r30)
	stw   %r9, -0x2c(%r30)
	stw   %r10, -0x28(%r30)
	stw   %r11, -0x24(%r30)
	stw   %r12, -0x20(%r30)
	stw   %r13, -0x1c(%r30)
	stw   %r14, -0x18(%r30)
	stw   %r15, -0x14(%r30)
	stw   %r16, -0x10(%r30)
	stw   %r17, -0x0c(%r30)
	stw   %r18, -0x08(%r30)
	stw   %r19, -0x04(%r30)

	LDI   1,%r31				/* Store a (char) 1 in */
	ADDIL L%PRE_Block-$global$,%r27		/* global variable */
	STW   %r31,R%PRE_Block-$global$(0,%r1)	/* PRE_Block. */

	COPY  %r26,%r22		/* Copy arg0 (f) to dyncall's input register. */

	COMIB,= 0,%r24,L$0001	/* Compare arg2 (newsp) to 0.  Execute the */
				/* next instruction regardless of value. */
	STWS  %r30,0(0,%r25)	/* Store the stack pointer in the first */
				/* element (0th offset) of arg1 (area1). */
	COPY  %r24,%r30		/* Move arg2 (newsp) into the stack ptr. */

L$0001
	ldo   64(%r30), %r30
	.CALL
	BL    $$dyncall,%r31	/* Dynamic call using pointer in r22. */
	COPY  %r31,%r2

	.CALL
	BL    abort,%r2		/* Can't get here, so abort. */
	NOP
	.EXIT
	.PROCEND

	.text

	/*
	; returnto(area2)
	;    struct savearea *area2;
	*/
	.EXPORT returnto,ENTRY
returnto
	.PROC
	.CALLINFO CALLER,FRAME=0,SAVE_RP,ENTRY_GR=18,ENTRY_FR=21
	.ENTRY
	LDWS  0(0,%r26),%r30	/* Load the stack pointer from area2 */
	ADDIL L%PRE_Block-$global$,%r27		/* PRE_Block = 0 */

	ldw   -0x04(%r30), %r19
	ldw   -0x08(%r30), %r18
	ldw   -0x0c(%r30), %r17
	ldw   -0x10(%r30), %r16
	ldw   -0x14(%r30), %r15
	ldw   -0x18(%r30), %r14
	ldw   -0x1c(%r30), %r13
	ldw   -0x20(%r30), %r12
	ldw   -0x24(%r30), %r11
	ldw   -0x28(%r30), %r10
	ldw   -0x2c(%r30), %r9
	ldw   -0x30(%r30), %r8
	ldw   -0x34(%r30), %r7
	ldw   -0x38(%r30), %r6
	ldw   -0x3c(%r30), %r5
	ldw   -0x40(%r30), %r4
	ldw,mb -0x80(%r30), %r3
	LDW   -20(%sr0,%r30), %r2
	BV    %r0(%r2)
	STW   %r0,R%PRE_Block-$global$(0,%r1)
	.EXIT
	.PROCEND

	.END
#endif /* AFS_BSD_PIC_ENV */
#endif /* AFS_BSD_ENV */
@


1.5
log
@also save gp for them dynamic executables; todd@@ ok
@
text
@@


1.4
log
@make this work; todd@@ deraadt@@ ok
@
text
@d261 1
d298 1
d371 1
d411 1
@


1.3
log
@change PRE_Block to an int, which architectures like alpha can access
atomically. Adapt all the others (except s390 which is not fixed yet).

mips and hppa still do not work for some other reason.

testing by beck, ckuethe, todd, asm proofreading by miod
@
text
@d243 18
a260 5
	/*
	; The ENTER statement generates register saves and
	; procedure setup.
	*/
	.ENTER
d263 2
a264 2
	LDW   T%PRE_Block(0,%r19),%r31    	/* global variable */
	STW   %r1,0(0,%r31)			/* PRE_Block. */
d271 1
a271 1
	STW   %r30,0(0,%arg1)	/* Store the stack pointer in the first */
d276 1
d297 16
d314 2
a350 2
	/* The ENTER statement generates register saves and */
	/* procedure setup. */
d352 17
d383 1
d405 1
d407 19
a426 2

	LDWS  0(0,%r26),%r30	/* Load the stack pointer from area2 */
@


1.2
log
@copy over the code for hpux to be used for a BSD case, not tested, but at least compiles, the name of the file is bogus now (; hin@@ ok and promissed to sync it w/ arla repo
@
text
@d39 1
a39 1
	mov.b	&1,_PRE_Block		# Dont allow any interrupt finagling
d77 1
a77 1
	clr.b	_PRE_Block
d108 1
a108 1
	STB   %r1,0(0,%r31)			/* PRE_Block. */
d141 1
a141 1
	STB   %r0,0(0,%r31)
d176 1
a176 1
	STB   %r31,R%PRE_Block-$global$(0,%r1)	/* PRE_Block. */
d206 1
a206 1
	STB   %r0,R%PRE_Block-$global$(0,%r1)
d251 1
a251 1
	STB   %r1,0(0,%r31)			/* PRE_Block. */
d284 1
a284 1
	STB   %r0,0(0,%r31)
d325 1
a325 1
	STB   %r31,R%PRE_Block-$global$(0,%r1)	/* PRE_Block. */
d358 1
a358 1
	STB   %r0,R%PRE_Block-$global$(0,%r1)
@


1.1
log
@New Arla userland from Arla between 0.34.2 and current in arla cvs.
Too many new features and fixes to mention here.
@
text
@d86 1
a86 1
	;
d91 1
a91 1
	;
d94 1
a94 1
	;
d98 1
a98 1
	;
d100 1
d103 1
d106 3
a108 3
	LDI   1,%r1				; Store a (char) 1 in
	LDW   T'PRE_Block(0,%r19),%r31    	; global variable
	STB   %r1,0(0,%r31)			; PRE_Block.
d111 7
a117 7
	COPY  %arg0,%r22	; Copy arg0 (f) to dyncall's input register.

	COMIB,= 0,%arg2,L$0001	; Compare arg2 (newsp) to 0.  Execute the
				; next instruction regardless of value.
	STW   %r30,0(0,%arg1)	; Store the stack pointer in the first
				; element (0th offset) of arg1 (area1).
	COPY  %arg2,%r30	; Move arg2 (newsp) into the stack ptr.
d121 1
a121 1
	BL    $$dyncall,%r31	; Dynamic call using pointer in r22.
d123 1
a123 1
	COPY  %r20, %r19        ; restore link table.
d126 1
a126 1
	BL    exit,%r2		; Can't get here, so abort.
d131 3
a133 3
	; returnto(area2)
	;    struct savearea *area2;
	;
d137 2
a138 2
	;  No ENTRY is used since this is a magic routine.
	LDWS  0(0,%arg0),%r30	; Load the stack pointer from area2
d140 1
a140 1
	LDW   T'PRE_Block(0,%r19),%r31   ; set PRE_Block = 0;
d156 1
a156 1
	;
d161 1
a161 1
	;
d164 1
a164 1
	;
d168 1
a168 1
	;
d170 2
a171 2
	; The ENTER statement generates register saves and
	; procedure setup.
d174 11
a184 11
	LDI   1,%r31				; Store a (char) 1 in
	ADDIL LR'PRE_Block-$global$,%r27	; global variable
	STB   %r31,RR'PRE_Block-$global$(0,%r1)	; PRE_Block.

	COPY  %r26,%r22		; Copy arg0 (f) to dyncall's input register.

	COMIB,= 0,%r24,L$0001	; Compare arg2 (newsp) to 0.  Execute the
				; next instruction regardless of value.
	STWS  %r30,0(0,%r25)	; Store the stack pointer in the first
				; element (0th offset) of arg1 (area1).
	COPY  %r24,%r30		; Move arg2 (newsp) into the stack ptr.
d188 1
a188 1
	BL    $$dyncall,%r31	; Dynamic call using pointer in r22.
d192 1
a192 1
	BL    abort,%r2		; Can't get here, so abort.
d197 1
d200 1
a200 1
	;
d204 3
a206 3
	;  No ENTRY is used since this is a magic routine.
	ADDIL LR'PRE_Block-$global$,%r27	; PRE_Block = 0
	STB   %r0,RR'PRE_Block-$global$(0,%r1)
d208 1
a208 1
	LDWS  0(0,%r26),%r30	; Load the stack pointer from area2
d223 144
@


1.1.1.1
log
@Import of arla-0.35.7
@
text
@@

