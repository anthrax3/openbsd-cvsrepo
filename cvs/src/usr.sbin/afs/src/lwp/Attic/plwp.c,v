head	1.6;
access;
symbols
	OPENBSD_5_2:1.5.0.36
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.34
	OPENBSD_5_0:1.5.0.32
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.30
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.28
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.24
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.5.0.26
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.5.0.22
	OPENBSD_4_5_BASE:1.5
	OPENBSD_4_4:1.5.0.20
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3:1.5.0.18
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.5.0.16
	OPENBSD_4_2_BASE:1.5
	OPENBSD_4_1:1.5.0.14
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.5.0.12
	OPENBSD_4_0_BASE:1.5
	OPENBSD_3_9:1.5.0.10
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.5.0.8
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.6
	OPENBSD_3_7_BASE:1.5
	OPENBSD_3_6:1.5.0.4
	OPENBSD_3_6_BASE:1.5
	OPENBSD_3_5:1.5.0.2
	OPENBSD_3_5_BASE:1.5
	OPENBSD_3_4:1.4.0.2
	OPENBSD_3_4_BASE:1.4
	arla-20030805:1.1.1.2
	OPENBSD_3_3:1.3.0.4
	OPENBSD_3_3_BASE:1.3
	OPENBSD_3_2:1.3.0.2
	OPENBSD_3_2_BASE:1.3
	arla-0-35-7:1.1.1.1
	arla:1.1.1
	OPENBSD_3_1:1.2.0.8
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.6
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_9:1.2.0.4
	OPENBSD_2_8:1.2.0.2
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.1.0.4
	OPENBSD_2_7_BASE:1.1
	OPENBSD_2_6:1.1.0.2
	OPENBSD_2_6_BASE:1.1;
locks; strict;
comment	@ * @;


1.6
date	2012.08.23.06.21.52;	author deraadt;	state dead;
branches;
next	1.5;

1.5
date	2003.12.16.20.13.55;	author beck;	state Exp;
branches;
next	1.4;

1.4
date	2003.08.05.09.07.34;	author hin;	state Exp;
branches;
next	1.3;

1.3
date	2002.06.07.04.41.27;	author hin;	state Exp;
branches;
next	1.2;

1.2
date	2000.09.11.14.41.08;	author art;	state Exp;
branches;
next	1.1;

1.1
date	99.04.30.01.59.13;	author art;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.06.07.04.14.30;	author hin;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.08.05.08.21.04;	author hin;	state Exp;
branches;
next	;


desc
@@


1.6
log
@the afs src tree can go away
@
text
@/* This version of the code is derived from the Coda version of the LWP
 * library, which can be compiled as a wrapper around Mach cthreads
 *
 * Windows Threads support was added by Love <lha@@stacken.kth.se>
 * and debugged by Magnus <map@@stacken.kth.se> and Robert <rb@@abc.se>.
 * It provides a glue layer around the windows primitives to make
 * it look like pthreads.
 */
/*
****************************************************************************
*        Copyright IBM Corporation 1988, 1989 - All Rights Reserved        *
*                                                                          *
* Permission to use, copy, modify, and distribute this software and its    *
* documentation for any purpose and without fee is hereby granted,         *
* provided that the above copyright notice appear in all copies and        *
* that both that copyright notice and this permission notice appear in     *
* supporting documentation, and that the name of IBM not be used in        *
* advertising or publicity pertaining to distribution of the software      *
* without specific, written prior permission.                              *
*                                                                          *
* IBM DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL *
* IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL IBM *
* BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY      *
* DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER  *
* IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING   *
* OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.    *
****************************************************************************
*/

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/* allocate externs here */
#define  LWP_KERNEL

#include <lwp.h>
#include "preempt.h"

RCSID("$arla: plwp.c,v 1.22 2003/01/24 19:38:35 tol Exp $");

#ifdef	AFS_AIX32_ENV
#include <ulimit.h>
#include <sys/errno.h>
#include <sys/user.h>
#include <sys/pseg.h>
#include <sys/core.h>
#pragma alloca
#endif

#ifndef MAX
#define MAX(a,b) (((a)>(b))?(a):(b))
#endif

#define  ON	    1
#define  OFF	    0
#define  TRUE	    1
#define  FALSE	    0
#define  READY		2
#define  WAITING		3
#define  DESTROYED	4
#define QWAITING		5
#define  MAXINT     (~(1<<((sizeof(int)*8)-1)))
#define  MINSTACK   44

/* Debugging macro */
#ifdef DEBUG
#define Debug(level, msg)					\
    do {							\
        if (lwp_debug && lwp_debug >= level) {			\
	    printf("***LWP(max=%d) (%p): ",			\
		   Highest_runnable_priority, lwp_cpptr);	\
	    printf msg;						\
	    putchar('\n');					\
	}							\
    } while(0)

#else
#define Debug(level, msg) do {} while (0)
#endif

#define lwp_timerclear(t) (t)->tv_sec = (t)->tv_usec = 0

/* Prototypes */
static void Abort_LWP(char *msg, ...) ;
static void Dispatcher(void);
static void Create_Process_Part2(PROCESS temp);
static void purge_dead_pcbs(void) ;
static void Dispose_of_Dead_PCB (PROCESS cur) ;
static void Free_PCB(PROCESS pid) ;
static void Exit_LWP();
static void Initialize_PCB(PROCESS temp, int priority, char *stack,
			   int stacksize, void (*ep)() , char *parm, 
			   char *name) ;
static int Internal_Signal(char *event) ;
char   (*RC_to_ASCII());

#define MAX_PRIORITIES	(LWP_MAX_PRIORITY+1)

struct QUEUE {
    PROCESS	head;
    int		count;
} runnable[MAX_PRIORITIES], blocked;
/* 
 * Invariant for runnable queues: The head of each queue points to the
 * currently running process if it is in that queue, or it points to the
 * next process in that queue that should run.
 */

/* special user-tweakable option for AIX */
int lwp_MaxStackSize = 32768;
int lwp_MaxStackSeen = 0;

int lwp_nextindex = 0;

/* Iterator macro */
#define for_all_elts(var, q, body)\
	{\
	    PROCESS var, _NEXT_;\
	    int _I_;\
	    for (_I_=q.count, var = q.head; _I_>0; _I_--, var=_NEXT_) {\
		_NEXT_ = var -> next;\
		body\
	    }\
	}

static struct lwp_ctl *lwp_init = NULL;

static void Dump_One_Process(PROCESS pid);
static void Dump_Processes();
static void Delete_PCB(PROCESS pid);
static void Free_PCB(PROCESS pid);
static void Cal_Highest_runnable_priority();
static int InitializeProcessSupport(int, PROCESS *);

PROCESS	lwp_cpptr;

/* The global Highest_runnable_priority is only needed in NEW lwp.
    But it gets set within a for_all_elts() instance in
    InternalSignal(). */
int Highest_runnable_priority;	/* global variable for max priority */

int Proc_Running; /* indicates forked proc got control */

/*
 * Glue for
 */

#if defined(PTHREADS_LWP)
pthread_mutex_t run_sem, ct_mutex;

#define LWP_INT_LOCK(sem)	pthread_mutex_lock(sem)
#define LWP_INT_UNLOCK(sem)	pthread_mutex_unlock(sem)

#define LWP_INT_WAIT(cond, mutex)	pthread_cond_wait(cond, mutex)
#define LWP_INT_SIGNAL(cond)	pthread_cond_signal(cond)

#define LWP_INT_EXIT(t)		pthread_exit(t)

#elif defined(WINDOWS_THREADS_LWP)

HANDLE run_sem, ct_mutex;

#if 0
#define LWP_INT_LOCK(sem)	WaitForSingleObject (sem, INFINITE)
#define LWP_INT_UNLOCK(sem)	ReleaseMutex (sem)
#endif

static
DWORD LWP_INT_LOCK(HANDLE *sem)
{
    DWORD ret;
    Debug(0, ("LWP_INT_LOCK: sem = %p", *sem));
    ret = WaitForSingleObject(*sem, INFINITE);
    if (ret == WAIT_FAILED) {
	DWORD err = GetLastError();
	Debug(0, ("LWP_INT_LOCK: h = %p, wait = %ld, %ld\n",
		  *sem, ret, err));
    }
    Debug(0, ("LWP_INT_LOCK: got %p", *sem));
    return ret;
}

static DWORD LWP_INT_UNLOCK(HANDLE *sem)
{
    DWORD ret;
    Debug(0, ("LWP_INT_UNLOCK: sem = %p", *sem));
    ret = ReleaseMutex(*sem);
    if (!ret) {
	DWORD err = GetLastError();
	Debug(0, ("LWP_INT_UNLOCK: h = %p, wait = %ld, %ld\n",
		  *sem, ret, err));
    }
    Debug(0, ("LWP_INT_UNLOCK: %p released", *sem));
    return ret;
}

static DWORD LWP_INT_WAIT(HANDLE *cond, HANDLE *mutex)
{
    DWORD ret;
    static int times = 0;
    int this_time = times++;

    Debug(0, ("LWP_INT_WAIT(%d): cond: %p mutex: %p",
	      this_time, *cond, *mutex));
    ret = ReleaseMutex (*mutex);
    if (!ret) {
	DWORD err = GetLastError();
	Debug(0, ("LWP_INT_WAIT(%d): ReleaseMutex failed: %ld error: "
		  "%ld mutex\n", this_time, err, *mutex));
	exit(-1);
    }      
    Debug(0, ("LWP_INT_WAIT(%d): mutex released, waiting", this_time));
    ret = WaitForSingleObject (*cond, INFINITE);
    if (ret != WAIT_OBJECT_0) {
	Debug(0, ("LWP_INT_WAIT(%d): WaitForSingleObject(cond) failed: "
		  "%ld mutex: %p\n", this_time, ret, *mutex));
	exit(-1);
    }
    Debug(0, ("LWP_INT_WAIT(%d): got sem, waiting for mutex", this_time));
    ret = WaitForSingleObject (*mutex, INFINITE);
    if (ret != WAIT_OBJECT_0) {
	Debug(0, ("LWP_INT_WAIT(%d): WaitForSingleObject(mutex) failed: "
		  "%ld mutex: %p\n",  this_time, ret, *mutex));
	exit(-1);
    }
    Debug(0, ("LWP_INT_WAIT(%d): got mutex: cond: %p mutex: %p",
	      this_time, *cond, *mutex));
    return 0;
}

#define LWP_INT_SIGNAL(cond)	do { \
Debug(0, ("LWP_INT_SIGNAL: cond: %p\n", *cond)); \
SetEvent (*cond); } while (0)


#define LWP_INT_EXIT(t)		ExitThread ((int)t); /* XXX */

#endif

static void
lwpremove(PROCESS p, struct QUEUE *q)
{
    /* Special test for only element on queue */
    if (q->count == 1)
	q -> head = NULL;
    else {
	/* Not only element, do normal remove */
	p -> next -> prev = p -> prev;
	p -> prev -> next = p -> next;
    }
    /* See if head pointing to this element */
    if (q->head == p) q -> head = p -> next;
    q->count--;
    Debug(0, ("removing, count now %d", q->count));
    p -> next = p -> prev = NULL;
}

static void
lwpinsert(PROCESS p, struct QUEUE *q)
{
    if (q->head == NULL) {	/* Queue is empty */
	q -> head = p;
	p -> next = p -> prev = p;
    } else {			/* Regular insert */
	p -> prev = q -> head -> prev;
	q -> head -> prev -> next = p;
	q -> head -> prev = p;
	p -> next = q -> head;
    }
    q->count++;
    Debug(0, ("inserting, count now %d", q->count));
}

static void
lwpmove(PROCESS p, struct QUEUE *from, struct QUEUE *to)
{
    lwpremove(p, from);
    lwpinsert(p, to);
}

int 
LWP_TerminateProcessSupport()       /* terminate all LWP support */
{
    int i;

    Debug(0, ("Entered Terminate_Process_Support"));
    if (lwp_init == NULL) 
	return LWP_EINIT;
    /* free all space allocated */
    for (i=0; i<MAX_PRIORITIES; i++)
        for_all_elts(cur, runnable[i], { Free_PCB(cur);});
    for_all_elts(cur, blocked, { Free_PCB(cur);});
    free((char *)lwp_init);
    lwp_init = NULL;
    return LWP_SUCCESS;
}

int 
LWP_GetRock(int Tag, char **Value)
{
    /* Obtains the pointer Value associated with the rock Tag of this LWP.
       Returns:
       LWP_SUCCESS    if specified rock exists and Value has been filled
       LWP_EBADROCK   rock specified does not exist
    */
    int i;
    struct rock *ra;

    ra = lwp_cpptr->rlist;

    for (i = 0; i < lwp_cpptr->rused; i++)
        if (ra[i].tag == Tag) {
#ifdef PTHREADS_LWP
#ifdef PTHREAD_GETSPECIFIC_TWOARG
	    pthread_getspecific(ra[i].val, Value);
#else
	    *Value = pthread_getspecific(ra[i].val);
#endif	  
#elif WINDOWS_THREADS_LWP
	    *Value = TlsGetValue((unsigned long) ra[i].val);
#endif
	    /**Value =  ra[i].value;*/
	    return(LWP_SUCCESS);
	}
    return(LWP_EBADROCK);
}


int 
LWP_NewRock(int Tag, char *Value)
{
    /* Finds a free rock and sets its value to Value.
       Return codes:
       LWP_SUCCESS     Rock did not exist and a new one was used
       LWP_EBADROCK    Rock already exists.
       LWP_ENOROCKS    All rocks are in use.

       From the above semantics, you can only set a rock value once.
       This is specifically to prevent multiple users of the LWP
       package from accidentally using the same Tag value and
       clobbering others.  You can always use one level of
       indirection to obtain a rock whose contents can change.  */
    
    int i;
    struct rock *ra;   /* rock array */

    ra = lwp_cpptr->rlist;

    /* check if rock has been used before */
    for (i = 0; i < lwp_cpptr->rused; i++)
        if (ra[i].tag == Tag) return(LWP_EBADROCK);

    /* insert new rock in rock list and increment count of rocks */
    if (lwp_cpptr->rused < MAXROCKS) {
        ra[lwp_cpptr->rused].tag = Tag;
#if defined(LWP_THREADS)
#ifdef HAVE_PTHREAD_KEYCREATE	
        if (pthread_keycreate(&ra[lwp_cpptr->rused].val, NULL))
#else
	    if (pthread_key_create(&ra[lwp_cpptr->rused].val, NULL))
#endif
		return(LWP_EBADROCK);
	if (pthread_setspecific(ra[lwp_cpptr->rused].val, Value))
	    return(LWP_EBADROCK);

#elif defined(WINDOWS_THREADS_LWP)
	ra[lwp_cpptr->rused].val = (LPVOID) TlsAlloc();
	if (ra[lwp_cpptr->rused].val == (LPVOID) 0xFFFFFFFF)
	    return(LWP_EBADROCK);
	if (!TlsSetValue((unsigned long) ra[lwp_cpptr->rused].val, Value))
	    return(LWP_EBADROCK);
#endif

        lwp_cpptr->rused++;
        return(LWP_SUCCESS);
    }
    else return(LWP_ENOROCKS);
}

static void 
Dispose_of_Dead_PCB(PROCESS cur)
{

    Debug(0, ("Entered Dispose_of_Dead_PCB"));
    Delete_PCB(cur);
    Free_PCB(cur);
}

int 
LWP_CurrentProcess(PROCESS *pid)
{
    Debug(0, ("Entered Current_Process"));
    if (lwp_init) {
	*pid = lwp_cpptr;
	return LWP_SUCCESS;
    } else
        return LWP_EINIT;
}


int 
LWP_GetProcessPriority(PROCESS pid, int *priority)
{
    Debug(0, ("Entered Get_Process_Priority"));
    if (lwp_init) {
	*priority = pid -> priority;
	return 0;
    } else
	return LWP_EINIT;
}

int 
LWP_WaitProcess(void *event)
{
    char *tempev[2];

    Debug(0, ("Entered Wait_Process"));
    if (event == NULL) return LWP_EBADEVENT;
    tempev[0] = event;
    tempev[1] = NULL;
    return LWP_MwaitProcess(1, tempev);
}

static void 
Delete_PCB(PROCESS pid)
{
    Debug(0, ("Entered Delete_PCB"));
    lwpremove(pid, (pid->blockflag || pid->status==WAITING || 
		    pid->status==DESTROYED ? &blocked
		    : &runnable[pid->priority]));
}

static void 
purge_dead_pcbs()
{
    for_all_elts(cur, blocked, { if (cur->status == DESTROYED) 
	Dispose_of_Dead_PCB(cur); });
}

static void 
Exit_LWP()
{
    exit (-1);
}

static void 
Dump_Processes()
{
    if (lwp_init) {
	int i;
	for (i=0; i<MAX_PRIORITIES; i++)
	    for_all_elts(x, runnable[i], {
		printf("[Priority %d]\n", i);
		Dump_One_Process(x);
	    });
	for_all_elts(x, blocked, { Dump_One_Process(x); });
    } else {
	printf("***LWP: LWP support not initialized\n");
    }
}

char *
LWP_Name()
{
    return(lwp_cpptr->name);    
}

int 
LWP_Index()
{
    return(lwp_cpptr->index);
}

int 
LWP_HighestIndex()
{
    return(lwp_nextindex-1);
}

/* A process calls this routine to wait until somebody signals it.
 * LWP_QWait removes the calling process from the runnable queue
 * and makes the process sleep until some other process signals via LWP_QSignal
 */
int 
LWP_QWait()
{
    PROCESS old_cpptr;

    Debug(0, ("LWP_QWait: %s is going to QWait", lwp_cpptr->name));
    lwp_cpptr->status = QWAITING;
    if (runnable[lwp_cpptr->priority].count == 0)
	Cal_Highest_runnable_priority();

    old_cpptr = lwp_cpptr;

    /* wake up next lwp */
    lwp_cpptr = runnable[Highest_runnable_priority].head;
    lwpremove(lwp_cpptr, &runnable[Highest_runnable_priority]);
    lwp_timerclear(&lwp_cpptr->lastReady);
    LWP_INT_LOCK(&ct_mutex);
    Debug(0, ("LWP_QWait:%s going to wake up %s", old_cpptr->name, 
	      lwp_cpptr->name));
    LWP_INT_SIGNAL(&lwp_cpptr->c);

    /* sleep on your own condition */
    Debug(0, ("LWP_QWait:%s going to wait on own condition", 
	      old_cpptr->name));
    LWP_INT_WAIT(&old_cpptr->c, &ct_mutex);
    LWP_INT_UNLOCK(&ct_mutex);
    Debug(0, ("LWP_QWait:%s woke up",
	      old_cpptr->name));

    lwp_cpptr = old_cpptr;

    /* return only if calling process' priority is the highest */
    if (lwp_cpptr->priority < Highest_runnable_priority)
	Dispatcher();
    return LWP_SUCCESS;
}


/* signal the PROCESS pid - by adding it to the runnable queue */
int 
LWP_QSignal(PROCESS pid)
{
    if (pid->status == QWAITING) {
	Debug(0, ("LWP_Qsignal: %s is going to QSignal %s\n", lwp_cpptr->name,
		  pid->name));
	pid->status = READY;
	lwpinsert(pid, &runnable[pid->priority]);
	Debug(0, ("LWP_QSignal: Just inserted %s into runnable queue\n", 
		  pid->name));
	gettimeofday(&pid->lastReady, 0);
	Highest_runnable_priority = 
	    MAX(Highest_runnable_priority, pid->priority);
	Debug(0, ("%s priority= %d; HRP = %d; Signalled process pri = %d", 
		  lwp_cpptr->name, lwp_cpptr->priority,
		  Highest_runnable_priority, pid->priority));
	return LWP_SUCCESS;	
    }
    else return LWP_ENOWAIT;
}


int
LWP_CreateProcess(void (*ep)(), int stacksize, int priority,
                  char *parm, char *name, PROCESS *pid)
{
    PROCESS temp;
#if defined(PTHREADS_LWP)
    pthread_t	ct;
    pthread_attr_t cta;
    int retval;
#elif defined(WINDOWS_THREADS_LWP)
    HANDLE ct;
#endif
    PROCESS old_cpptr;
    
    Debug(0, ("Entered LWP_CreateProcess to create %s at priority %d\n", 
	      name, priority));
    old_cpptr = lwp_cpptr;
    /* Throw away all dead process control blocks */
    purge_dead_pcbs();
    
    if (lwp_init == NULL)
	return LWP_EINIT;

    /* allocate the memory for the pcb - check for malloc errors */
    temp = (PROCESS)malloc (sizeof (struct lwp_pcb));
    if (temp == NULL) {
	Dispatcher();
	return LWP_ENOMEM;
    }
    
    /* check priorities */
    if (priority < 0 || priority >= MAX_PRIORITIES) {
	Dispatcher();
	return LWP_EBADPRI;
    }
    
    Initialize_PCB(temp, priority, NULL, 0, ep, parm, name);
    
    /* make the process runnable by placing it in the runnable q */
    lwpinsert(temp, &runnable[priority]);
    gettimeofday(&temp->lastReady, 0);
    
    if (PRE_Block != 0)
	Abort_LWP("PRE_Block not 0");
    
    PRE_Block = 1;
    Proc_Running = FALSE;	    /* sem set true by forked process */
    
#if defined(PTHREADS_LWP)
    pthread_attr_init(&cta);
#ifdef _POSIX_THREAD_ATTR_STACKSIZE
    pthread_attr_setstacksize(&cta, stacksize);
#endif
    retval = pthread_create(&ct, &cta, (void *)Create_Process_Part2, temp);
    if (retval != 0)
	Abort_LWP("pthread_create failed to create thread %d/%d", 
		  retval, errno);

    pthread_detach(ct);
    temp->a = cta;
#elif defined(WINDOWS_THREADS_LWP)
    Debug(0,("Before CreateThread Create_Process_Part2"));
    ct = CreateThread (NULL, 
		       stacksize, (LPTHREAD_START_ROUTINE)Create_Process_Part2,
		       temp,  0,  NULL);
    Debug(0,("After CreateThread Create_Process_Part2"));
    if (ct == NULL)
	Abort_LWP("CreateThread failed to create thread: %d", 
		  (int)GetLastError());
    temp->t = ct;
#endif

    /* check if max priority has changed */
    Highest_runnable_priority = MAX(Highest_runnable_priority, priority);
    
    LWP_INT_LOCK(&run_sem);
    Debug(0, ("Before creating process yields Proc_Running = %d\n", 
	      Proc_Running));
    while( !Proc_Running ){
	LWP_INT_UNLOCK(&run_sem);
#if defined(PTHREADS_LWP)
#if defined(HAVE_THR_YIELD)
	thr_yield();
#elif defined(_POSIX_THREAD_PRIORITY_SCHEDULING)
	sched_yield();
#else
	pthread_yield();
#endif
#elif defined(WINDOWS_THREADS_LWP)
	Sleep(0); /* XXX */
#endif
	LWP_INT_LOCK(&run_sem);
	Debug(0,("After creating proc yields and gets back control Proc_Running = %d\n", 
		 Proc_Running));
    }
    LWP_INT_UNLOCK(&run_sem);
    
    lwp_cpptr = old_cpptr;
    
    Dispatcher();
    *pid = temp;
    return LWP_SUCCESS;
}

int 
LWP_DestroyProcess(PROCESS pid)
{
    void *t;

    Debug(0, ("Entered Destroy_Process"));
    if (lwp_init) {
#if defined(PTHREADS_LWP)
	pthread_attr_destroy(&pid->a);
#elif defined(WINDOWS_THREADS_LWP)
	CloseHandle (pid->t);
#endif
	if (lwp_cpptr == pid){
	    /* kill myself */
	    pid->status = DESTROYED;
	    Free_PCB(pid);
	    Cal_Highest_runnable_priority();
      
	    /* Calculate next runnable lwp and signal it */
	    lwp_cpptr = runnable[Highest_runnable_priority].head;
	    lwpremove(lwp_cpptr, &runnable[Highest_runnable_priority]);
      
	    LWP_INT_LOCK(&ct_mutex);
	    LWP_INT_SIGNAL(&lwp_cpptr->c);
	    LWP_INT_UNLOCK(&ct_mutex);
	    LWP_INT_EXIT(t);
	} else {
	    /* kill some other process - mark status destroyed - 
	       if process is blocked, it will be purged on next create proc;
	       if it is runnable the dispatcher will kill it */
	    pid->status = DESTROYED ;
	    Dispatcher();
	}
	return LWP_SUCCESS ;
    } else
	return LWP_EINIT;
}

int 
LWP_DispatchProcess()		/* explicit voluntary preemption */
{
    Debug(0, ("Entered Dispatch_Process"));
    if (lwp_init) {
	Dispatcher();
	return LWP_SUCCESS;
    } else {
	return LWP_EINIT;
    }
}

int 
LWP_Init(int version, int priority, PROCESS *pid)
{
    lwp_debug = 0;
    if (version != LWP_VERSION)
    {
	fprintf(stderr, "**** FATAL ERROR: LWP VERSION MISMATCH ****\n");
	exit(-1);
    }
    else return(InitializeProcessSupport(priority, pid));    
}

int 
LWP_InitializeProcessSupport(int priority, PROCESS *pid)
{
    return(InitializeProcessSupport(priority, pid));    
}

static int 
InitializeProcessSupport(int priority, PROCESS *pid)
{
    PROCESS temp;
    int i;

    Debug(0, ("Entered InitializeProcessSupport"));
    if (lwp_init != NULL) 
	return LWP_SUCCESS;
  
    /* check priorities and set up running and blocked queues */
    if (priority >= MAX_PRIORITIES) return LWP_EBADPRI;
    for (i=0; i<MAX_PRIORITIES; i++) {
	runnable[i].head = NULL;
	runnable[i].count = 0;
    }
    blocked.head = NULL;
    blocked.count = 0;
    lwp_init = (struct lwp_ctl *) malloc(sizeof(struct lwp_ctl));
    temp = (PROCESS) malloc(sizeof(struct lwp_pcb));
    if (lwp_init == NULL || temp == NULL)
	Abort_LWP("Insufficient Storage to Initialize LWP Support");
  
    /* check parameters */
    Initialize_PCB(temp, priority, NULL, 0, NULL, NULL,"Main Process");
    gettimeofday(&temp->lastReady, 0);

#if 0
    Highest_runnable_priority = priority;
#endif

    /* initialize mutex and semaphore */
    Proc_Running = TRUE;
#if defined(PTHREADS_LWP)
    pthread_mutex_init(&run_sem, NULL);
    pthread_mutex_init(&ct_mutex, NULL);
#elif defined(WINDOWS_THREADS_LWP)
    run_sem = CreateMutex (NULL, FALSE, "run_sem");
    if (run_sem == NULL) exit(-1);
    ct_mutex = CreateMutex (NULL, FALSE, "ct_mutex");
    if (ct_mutex == NULL) exit(-1);
#endif
    lwp_cpptr = temp;
    Dispatcher();
    *pid = temp;
    return LWP_SUCCESS;
}

int 
LWP_INTERNALSIGNAL(void *event, int yield)
{
    Debug(0, ("Entered LWP_SignalProcess, yield=%d", yield));
    if (lwp_init) {
	int rc;
	rc = Internal_Signal(event);
	if (yield) {
	    Cal_Highest_runnable_priority();
	    Debug(0, ("hipri=%d", Highest_runnable_priority));
	    Dispatcher();
	}
	return rc;
    } else
	return LWP_EINIT;
}

int 
LWP_MwaitProcess(int wcount, char *evlist[]) /* wait on m of n events */
{
    int ecount, i;
    PROCESS  old_cpptr;

    Debug(0, ("Entered Mwait_Process [waitcnt = %d]", wcount));
    if (evlist == NULL) {	
	Dispatcher();
	return LWP_EBADCOUNT;
    }
	
    /* count # of events in eventlist */
    for (ecount = 0; evlist[ecount] != NULL; ecount++) ;
    if (ecount == 0) {
	Dispatcher();
        return LWP_EBADCOUNT;
    }

    if (lwp_init) {
        /* check for illegal counts */
        if (wcount>ecount || wcount<0) {
            Dispatcher();
            return LWP_EBADCOUNT;
	}

        /* reallocate eventlist if new list has more elements than before */
        if (ecount > lwp_cpptr->eventlistsize) {
            lwp_cpptr->eventlist = 
		(char **)realloc((char *)lwp_cpptr->eventlist, 
				 ecount*sizeof(char *));
            lwp_cpptr->eventlistsize = ecount;
	}

        /* place events in eventlist of the pcb */
        for (i=0; i<ecount; i++) lwp_cpptr -> eventlist[i] = evlist[i];

        /* if there are any events to wait on then set status to
           WAITING and place the pcb in blocked queue */
        if (wcount > 0) {
            lwp_cpptr -> status = WAITING;
            lwpinsert(lwp_cpptr, &blocked);
	}
        lwp_cpptr -> wakevent = 0;      /* index of eventid causing wakeup */
        lwp_cpptr -> waitcnt  = wcount;
        lwp_cpptr -> eventcnt = ecount;
	if (runnable[lwp_cpptr->priority].count == 0)
	    Cal_Highest_runnable_priority();
        old_cpptr = lwp_cpptr;

        /* wake up next lwp */
        lwp_cpptr = runnable[Highest_runnable_priority].head;
        lwpremove(lwp_cpptr, &runnable[Highest_runnable_priority]);
	lwp_timerclear(&lwp_cpptr->lastReady);
	Debug(0, ("WaitProcess: %s Going to signal %s \n", 
		  old_cpptr->name, lwp_cpptr->name));
        LWP_INT_LOCK(&ct_mutex);
        LWP_INT_SIGNAL(&lwp_cpptr->c);

	/* sleep on your own condition */
	Debug(0, ("WaitProcess:%s going to wait \n", old_cpptr->name));

	LWP_INT_WAIT(&old_cpptr->c, &ct_mutex);
	LWP_INT_UNLOCK(&ct_mutex);
	Debug(0, ("WaitProcess:%s woke up \n", old_cpptr->name));

	/* update the global pointer */
	lwp_cpptr = old_cpptr;

	if (lwp_cpptr->priority < Highest_runnable_priority)
	    Dispatcher();
	return LWP_SUCCESS ;
    }
    return LWP_EINIT ;

}

int 
LWP_StackUsed(PROCESS pid, int *max, int *used)
{
    /* just here for compatibility */
    *max = -1;
    *used = -1;
    return LWP_SUCCESS;
}

static void 
Abort_LWP(char *msg, ...)
{
    va_list ap;

    Debug(0, ("Entered Abort_LWP"));
    va_start(ap, msg);
    printf("***LWP Abort ");
    vprintf(msg, ap);
    va_end(ap);
    Dump_Processes();
    Exit_LWP();
}

static void 
Create_Process_Part2(PROCESS temp)
{
    /* set the global Proc_Running to signal the parent */
    LWP_INT_LOCK(&run_sem);
    Proc_Running = TRUE;
    LWP_INT_UNLOCK(&run_sem);

    LWP_INT_LOCK(&ct_mutex);
    LWP_INT_WAIT(&temp->c, &ct_mutex);
    LWP_INT_UNLOCK(&ct_mutex);

    lwp_cpptr = temp;

#if defined(PTHREADS_LWP)
#ifdef _POSIX_THREAD_ATTR_STACKSIZE
    pthread_attr_setstacksize(&temp->a, temp->stacksize);
#endif /* _POSIX_THREAD_ATTR_STACKSIZE */
#endif /* PTHREADS_LWP */
    
    (*temp->ep)(temp->parm);
    LWP_DestroyProcess(temp);
}

static void 
Dump_One_Process(PROCESS pid)
{
    int i;

    printf("***LWP: Process Control Block at 0x%x\n", (int)pid);
    printf("***LWP: Name: %s\n", pid->name);
    if (pid->ep != NULL)
	printf("***LWP: Initial entry point: 0x%x\n", (int)pid->ep);
    if (pid->blockflag) printf("BLOCKED and ");
    switch (pid->status) {
    case READY:	printf("READY");     break;
    case WAITING:	printf("WAITING");   break;
    case DESTROYED:	printf("DESTROYED"); break;
    default:	printf("unknown");
    }
    putchar('\n');
    printf("***LWP: Priority: %d \tInitial parameter: 0x%x\n",
	   pid->priority, (int)pid->parm);

    if (pid->eventcnt > 0) {
	printf("***LWP: Number of events outstanding: %d\n", pid->waitcnt);
	printf("***LWP: Event id list:");
	for (i=0;i<pid->eventcnt;i++)
	    printf(" 0x%x", (int)pid->eventlist[i]);
	putchar('\n');
    }
    if (pid->wakevent>0)
	printf("***LWP: Number of last wakeup event: %d\n", pid->wakevent);
}

static void 
Dispatcher()		/* Lightweight process dispatcher */
{
    void *t;
    int my_priority;
    PROCESS	old_cpptr;


#if 1
    int i = Highest_runnable_priority;
	    
    Cal_Highest_runnable_priority();
    if (Highest_runnable_priority != i) {
	printf("hipri was %d actually %d\n", i, Highest_runnable_priority);
#if 0
	Dump_Processes();
#endif
    }
    Highest_runnable_priority = i;
#endif
    my_priority = lwp_cpptr->priority;
    Debug(0, ("Dispatcher: %d runnable at pri %d hi %d blk %d", 
	      runnable[my_priority].count, my_priority, 
	      Highest_runnable_priority, PRE_Block));
    PRE_Block = 1;
    if ((my_priority < Highest_runnable_priority) || 
	(runnable[my_priority].count > 0))
    {
	Debug(0, ("Dispatcher: %s is now yielding", lwp_cpptr->name));
	/* I have to quit */
	old_cpptr = lwp_cpptr;
	lwpinsert(old_cpptr, &runnable[my_priority]);
	gettimeofday(&old_cpptr->lastReady, 0);
	lwp_cpptr = runnable[Highest_runnable_priority].head;

	/* remove next process from runnable queue and signal it */
	lwpremove(lwp_cpptr, &runnable[Highest_runnable_priority]);
	LWP_INT_LOCK(&ct_mutex);
	Debug(0, ("Dispatcher: %s going to signal %s condition", 
		  old_cpptr->name, lwp_cpptr->name));

	LWP_INT_SIGNAL(&lwp_cpptr->c);

	/* now sleep until somebody wakes me */
	Debug(0, ("Dispatcher: %s going to wait on own condition", 
		  old_cpptr->name));
	LWP_INT_WAIT(&old_cpptr->c, &ct_mutex);
	LWP_INT_UNLOCK(&ct_mutex);
	Debug(0, ("Dispatcher: %s woke up", 
		  old_cpptr->name));
	
	/* update global pointer */
	lwp_cpptr = old_cpptr;
    } else {
	Debug(0, ("Dispatcher: %s still running", lwp_cpptr->name));
    }
    /* make sure HRP is set correct */
    Highest_runnable_priority = lwp_cpptr->priority;
    if (lwp_cpptr->status == DESTROYED){
	/* the process was runnable but got destroyed by somebody */
	Free_PCB(lwp_cpptr);
	Cal_Highest_runnable_priority();
	lwp_cpptr = runnable[Highest_runnable_priority].head;
	lwpremove(lwp_cpptr, &runnable[Highest_runnable_priority]);

	LWP_INT_LOCK(&ct_mutex);
	LWP_INT_SIGNAL(&lwp_cpptr->c);
	LWP_INT_UNLOCK(&ct_mutex);
	LWP_INT_EXIT(t);
    }
#if 0
    if (PRE_Block != 1) Abort_LWP("PRE_Block not 1");
#endif
    PRE_Block = 0;
}


static void 
Free_PCB(PROCESS pid)
{
    Debug(0, ("Entered Free_PCB"));

    if (pid->eventlist != NULL)
	free((char *)pid->eventlist);
    free((char *)pid);
}	

static void
Initialize_PCB(PROCESS temp, int priority, char *stack, int stacksize, 
               void (*ep)(), char *parm, char *name)
{
    int i = 0;

    Debug(0, ("Entered Initialize_PCB"));
    if (name != NULL)
	while (((temp -> name[i] = name[i]) != '\0') && (i < 31))
	    i++;
    temp -> name[31] = '\0';
    temp -> status = READY;
    temp -> eventlist = (char **)malloc(EVINITSIZE*sizeof(char *));
    temp -> eventlistsize = EVINITSIZE;
    temp -> eventcnt = 0;
    temp -> wakevent = 0;
    temp -> waitcnt = 0;
    temp -> blockflag = 0;
    temp -> iomgrRequest = 0;
    temp -> priority = priority;
    temp -> index = lwp_nextindex++;
    temp -> ep = ep;
    temp -> parm = parm;
    temp -> misc = NULL;	/* currently unused */
    temp -> next = NULL;
    temp -> prev = NULL;
    temp -> rused = 0;
    temp -> level = 1;		/* non-preemptable */
    temp -> stacksize = stacksize;
    lwp_timerclear(&temp->lastReady);

    /* initialize the mutex and condition */
#if defined(PTHREADS_LWP)
    pthread_mutex_init(&temp->m, NULL);	
    pthread_cond_init(&temp->c, NULL);
#elif defined(WINDOWS_THREADS_LWP)
    temp->m = CreateMutex (NULL, FALSE, NULL);
    if (temp->m == NULL) exit(-1);
    temp->c = CreateEvent (NULL, FALSE, FALSE, NULL);
    if (temp->c == NULL) exit(-1);
    Debug(0, ("Init_PCB: event = %p\n", temp->c));
#endif

    Debug(0, ("Leaving Initialize_PCB\n"));
}

static int 
Internal_Signal(char *event)
{
    int rc = LWP_ENOWAIT;
    int i;

    Debug(0, ("Entered Internal_Signal [event id 0x%x]", (int)event));
    if (lwp_init == NULL)
	return LWP_EINIT;
    if (event == NULL) 
	return LWP_EBADEVENT;
  
    for_all_elts(temp, blocked, {     /* for all pcb's on the blocked q */
	if (temp->status == WAITING)
	    for (i=0; i < temp->eventcnt; i++) { /* check each event in list */
		if (temp -> eventlist[i] == event) {
		    temp -> eventlist[i] = NULL;
		    rc = LWP_SUCCESS;
		    Debug(0, ("decrementing %s to %d", temp->name,
			      (temp->waitcnt-1)));
		    /* reduce waitcnt by 1 for the signal */
		    /* if wcount reaches 0 then make the process runnable */
		    if (--temp->waitcnt == 0) {
			temp -> status = READY;
			temp -> wakevent = i+1;
			lwpmove(temp, &blocked, &runnable[temp->priority]);
			gettimeofday(&temp->lastReady, 0);
			Highest_runnable_priority = 
			    MAX(Highest_runnable_priority, temp->priority);
			Debug(0, ("marked runnable. hi_pri %d, %d at %d",
				  Highest_runnable_priority, 
				  runnable[temp->priority].count,
				  temp->priority));
			break;
		    }
		}
	    }
    });
    return rc;
}    

/* places the maximum of runnable task priorities in the global variable -
 * Highest_runnable_priority.  No runnable process is an error */
static void 
Cal_Highest_runnable_priority()
{
    int	i;

#if 0
    Dump_Processes();
#endif

    for (i = MAX_PRIORITIES - 1; i >= 0 ; i--)
	if (runnable[i].count != 0)
	    break;
#if 0
    if (i < 0)
	Abort_LWP("No ready processes");
#endif
    if (i >= 0)
	Highest_runnable_priority = i;
#if 0
    else
	exit(-1);
#endif
}
@


1.5
log
@afs cleanup, realloc strings, abort, etc.
testing by beck, hin, jose, fries. ok deraadt@@
@
text
@@


1.4
log
@Merge
@
text
@d216 1
a216 1
	abort();
d223 1
a223 1
	abort();
d230 1
a230 1
	abort();
d761 1
a761 1
    if (run_sem == NULL) abort();
d763 1
a763 1
    if (ct_mutex == NULL) abort();
d1067 1
a1067 1
    if (temp->m == NULL) abort();
d1069 1
a1069 1
    if (temp->c == NULL) abort();
d1139 1
a1139 1
	abort();
@


1.3
log
@merge
@
text
@d6 1
a6 1
 * It make have a glue layer around the windows primiptives to make
d34 1
d43 1
d45 1
a45 1
RCSID("$KTH: plwp.c,v 1.9 2000/05/12 08:41:32 lha Exp $");
a59 2
extern char PRE_Block;	/* from preempt.c */

a70 1

d73 9
a81 6
#define Debug(level, msg)\
	 if (lwp_debug && lwp_debug >= level) {\
	     printf("***LWP(max=%d) (%p): ", Highest_runnable_priority, lwp_cpptr);\
	     printf msg;\
	     putchar('\n');\
	 }
d84 1
a84 1
#define Debug(level, msg)
d90 1
a90 1
static void Abort_LWP(char *msg) ;
d100 1
a100 1
static int Internal_Signal(register char *event) ;
d124 2
a125 2
	    register PROCESS var, _NEXT_;\
	    register int _I_;\
d132 1
a132 1
static struct lwp_ctl *lwp_init = 0;
d136 1
a136 1
static void Delete_PCB(register PROCESS pid);
d174 2
a175 1
static DWORD LWP_INT_LOCK(HANDLE *sem)
d177 3
a179 1
    DWORD ret = WaitForSingleObject(*sem, INFINITE);
d181 3
a183 3
      DWORD err = GetLastError();
      Debug(0, ("LWP_INT_LOCK: h = %p, wait = %ld, %ld\n",
		*sem, ret, err));
d185 1
d191 3
a193 1
    DWORD ret = ReleaseMutex(*sem);
d195 3
a197 3
      DWORD err = GetLastError();
      Debug(0, ("LWP_INT_UNLOCK: h = %p, wait = %ld, %ld\n",
		*sem, ret, err));
d199 1
d205 30
a234 44
  DWORD ret;
  static int times = 0;
  int this_time = times++;

  Debug(0, ("LWP_INT_WAIT(%d): cond: %p mutex: %p\n",
	    this_time, *cond, *mutex));
  ret = ReleaseMutex (*mutex);
  if (!ret) {
      DWORD err = GetLastError();
      Debug(0, ("LWP_INT_WAIT(%d): ReleaseMutex failed: %ld error: %ld mutex\n", 
		this_time, ret, err, *mutex));
      abort();
  }      
  ret = WaitForSingleObject (*cond, INFINITE);
  if (ret != WAIT_OBJECT_0) {
      Debug(0, ("LWP_INT_WAIT(%d): WaitForSingleObject(cond) failed: %ld mutex: %p\n",
		this_time, ret, *mutex));
      abort();
  }
  ret = WaitForSingleObject (*mutex, INFINITE);
  if (ret != WAIT_OBJECT_0) {
      Debug(0, ("LWP_INT_WAIT(%d): WaitForSingleObject(mutex) failed: %ld mutex: %p\n",
		this_time, ret, *mutex));
      abort();
  }
#if 0
  ret = SignalObjectAndWait(*mutex, *cond, INFINITE, FALSE /* XXX */);
  if (ret != WAIT_OBJECT_0) {
    DWORD err = GetLastError();
    Debug(0, ("LWP_INT_WAIT(%d): SignalObjectAndWait failed: %ld error: %ld mutex: %p cond: %p\n", this_time, ret, err, *mutex, *cond));
    /* XXX */
    return ret;    
  }
  Debug(0, ("LWP_INT_WAIT(%d): woke up, waiting for mutex: cond: %p mutex: %p\n", this_time, *cond, *mutex));
  ret = WaitForSingleObject(*mutex, INFINITE);
  if (ret != WAIT_OBJECT_0) {
    Debug(0, ("LWP_INT_WAIT(%d): WaitForSingleObject(mutex) failed: %ld mutex: %p\n", this_time, ret, *mutex));
    /* XXX */
    return ret;
  }
#endif
  Debug(0, ("LWP_INT_WAIT(%d): got mutex: cond: %p mutex: %p\n",
	    this_time, *cond, *mutex));
  return 0;
d239 1
a239 1
PulseEvent (*cond); } while (0)
d247 1
a247 1
lwpremove(register PROCESS p, register struct QUEUE *q)
d265 1
a265 1
lwpinsert(register PROCESS p, register struct QUEUE *q)
d290 1
a290 1
    register int i;
d293 2
a294 1
    if (lwp_init == NULL) return LWP_EINIT;
d297 2
a298 2
        for_all_elts(cur, runnable[i], { Free_PCB(cur);})
    for_all_elts(cur, blocked, { Free_PCB(cur);})
d309 2
a310 2
            LWP_SUCCESS    if specified rock exists and Value has been filled
            LWP_EBADROCK   rock specified does not exist
d312 2
a313 2
    register int i;
    register struct rock *ra;
d321 1
a321 1
	  pthread_getspecific(ra[i].val, Value);
d323 1
a323 1
	  *Value = pthread_getspecific(ra[i].val);
d326 1
a326 1
	  *Value = TlsGetValue((unsigned long) ra[i].val);
d328 2
a329 2
	  /**Value =  ra[i].value;*/
	  return(LWP_SUCCESS);
d339 10
a348 10
        Return codes:
                LWP_SUCCESS     Rock did not exist and a new one was used
                LWP_EBADROCK    Rock already exists.
                LWP_ENOROCKS    All rocks are in use.

        From the above semantics, you can only set a rock value once.
        This is specifically to prevent multiple users of the LWP
        package from accidentally using the same Tag value and
        clobbering others.  You can always use one level of
        indirection to obtain a rock whose contents can change.  */
d350 2
a351 2
    register int i;
    register struct rock *ra;   /* rock array */
d366 1
a366 1
        if (pthread_key_create(&ra[lwp_cpptr->rused].val, NULL))
d368 2
a370 2
	if (pthread_setspecific(ra[lwp_cpptr->rused].val, Value))
	  return(LWP_EBADROCK);
d390 3
a392 3
  Debug(0, ("Entered Dispose_of_Dead_PCB"));
  Delete_PCB(cur);
  Free_PCB(cur);
d400 2
a401 2
            *pid = lwp_cpptr;
            return LWP_SUCCESS;
d431 1
a431 1
Delete_PCB(register PROCESS pid)
d443 1
a443 1
      Dispose_of_Dead_PCB(cur); })
d456 1
a456 1
	register int i;
d461 3
a463 3
	    })
	for_all_elts(x, blocked, { Dump_One_Process(x); })
    } else
d465 1
d495 1
a495 1
    Debug(0, ("LWP_QWait: %s is going to QWait\n", lwp_cpptr->name));
d507 1
a507 1
    Debug(0, ("LWP_QWait:%s going to wake up %s \n", old_cpptr->name, 
d512 1
a512 1
    Debug(0, ("LWP_QWait:%s going to wait on own condition \n", 
d516 1
a516 1
    Debug(0, ("LWP_QWait:%s woke up \n",
d523 1
a523 1
	    Dispatcher();
d533 13
a545 13
      Debug(0, ("LWP_Qsignal: %s is going to QSignal %s\n", lwp_cpptr->name,
		pid->name));
      pid->status = READY;
      lwpinsert(pid, &runnable[pid->priority]);
      Debug(0, ("LWP_QSignal: Just inserted %s into runnable queue\n", 
		pid->name));
      gettimeofday(&pid->lastReady, 0);
      Highest_runnable_priority = 
	MAX(Highest_runnable_priority, pid->priority);
      Debug(0, ("%s priority= %d; HRP = %d; Signalled process pri = %d", 
		lwp_cpptr->name, lwp_cpptr->priority,
		Highest_runnable_priority, pid->priority));
      return LWP_SUCCESS;	
d564 1
a564 1

d570 3
d574 3
a576 4
    if (lwp_init) {
      /* allocate the memory for the pcb - check for malloc errors */
      temp = (PROCESS)malloc (sizeof (struct lwp_pcb));
      if (temp == NULL) {
d579 4
a582 4
      }

      /* check priorities */
      if (priority < 0 || priority >= MAX_PRIORITIES) {
d585 14
a598 13
      }
      
      Initialize_PCB(temp, priority, NULL, 0, ep, parm, name);
      
      /* make the process runnable by placing it in the runnable q */
      lwpinsert(temp, &runnable[priority]);
      gettimeofday(&temp->lastReady, 0);

      if (PRE_Block != 0) Abort_LWP("PRE_Block not 0");
      
      PRE_Block = 1;
      Proc_Running = FALSE;	    /* sem set true by forked process */
      
d600 1
a600 1
      pthread_attr_init(&cta);
d602 1
a602 1
      pthread_attr_setstacksize(&cta, stacksize);
d604 7
a610 4
      retval = pthread_create(&ct, &cta, (void *)Create_Process_Part2, temp);
      if (!retval) {
	pthread_detach(ct);
	temp->a = cta;
d612 9
a620 7
	Debug(0,("Before CreateThread Create_Process_Part2"));
      ct = CreateThread (NULL, 
			 stacksize, (LPTHREAD_START_ROUTINE) Create_Process_Part2, 
			 temp,  0,  NULL);
	Debug(0,("After CreateThread Create_Process_Part2"));
      if (ct != NULL) {
	temp->t = ct;
d623 8
a630 8
	/* check if max priority has changed */
	Highest_runnable_priority = MAX(Highest_runnable_priority, priority);
	
	LWP_INT_LOCK(&run_sem);
	Debug(0, ("Before creating process yields Proc_Running = %d\n", 
		  Proc_Running));
	while( !Proc_Running ){
	  LWP_INT_UNLOCK(&run_sem);
d633 1
a633 1
	  thr_yield();
d635 1
a635 1
	  sched_yield();
d637 1
a637 1
	  pthread_yield();
d640 1
a640 17
	  Sleep(0); /* XXX */
#endif
	  LWP_INT_LOCK(&run_sem);
	  Debug(0,("After creating proc yields and gets back control Proc_Running = %d\n", 
		    Proc_Running));
	}
	LWP_INT_UNLOCK(&run_sem);
	
	lwp_cpptr = old_cpptr;
	  
	Dispatcher();
	*pid = temp;
	return LWP_SUCCESS;
      }
    } else {
#ifdef PTHREADS_LWP	
      pthread_attr_destroy(&cta);
d642 3
d646 7
a652 1
    return LWP_EINIT;
d658 1
a658 1
  void *t;
d660 2
a661 2
  Debug(0, ("Entered Destroy_Process"));
  if (lwp_init) {
d663 1
a663 1
    pthread_attr_destroy(&pid->a);
d665 1
a665 1
    CloseHandle (pid->t);
d667 5
a671 5
    if (lwp_cpptr == pid){
      /* kill myself */
      pid->status = DESTROYED;
      Free_PCB(pid);
      Cal_Highest_runnable_priority();
d673 3
a675 3
      /* Calculate next runnable lwp and signal it */
      lwp_cpptr = runnable[Highest_runnable_priority].head;
      lwpremove(lwp_cpptr, &runnable[Highest_runnable_priority]);
d677 14
a690 14
      LWP_INT_LOCK(&ct_mutex);
      LWP_INT_SIGNAL(&lwp_cpptr->c);
      LWP_INT_UNLOCK(&ct_mutex);
      LWP_INT_EXIT(t);
    } else {
      /* kill some other process - mark status destroyed - 
	 if process is blocked, it will be purged on next create proc;
	 if it is runnable the dispatcher will kill it */
      pid->status = DESTROYED ;
      Dispatcher();
    }
    return LWP_SUCCESS ;
  } else
    return LWP_EINIT;
d696 1
a696 1
    Debug(0, ("Entered Dispatch_Process"))
d700 1
a700 1
    } else
d702 1
d708 2
a709 2
  lwp_debug = 0;
  if (version != LWP_VERSION)
d711 2
a712 2
      fprintf(stderr, "**** FATAL ERROR: LWP VERSION MISMATCH ****\n");
      exit(-1);
d714 1
a714 1
  else return(InitializeProcessSupport(priority, pid));    
d720 1
a720 1
  return(InitializeProcessSupport(priority, pid));    
d726 2
a727 2
  PROCESS temp;
  register int i;
d729 3
a731 2
  Debug(0, ("Entered InitializeProcessSupport"));
  if (lwp_init != NULL) return LWP_SUCCESS;
d733 12
a744 12
  /* check priorities and set up running and blocked queues */
  if (priority >= MAX_PRIORITIES) return LWP_EBADPRI;
  for (i=0; i<MAX_PRIORITIES; i++) {
    runnable[i].head = NULL;
    runnable[i].count = 0;
  }
  blocked.head = NULL;
  blocked.count = 0;
  lwp_init = (struct lwp_ctl *) malloc(sizeof(struct lwp_ctl));
  temp = (PROCESS) malloc(sizeof(struct lwp_pcb));
  if (lwp_init == NULL || temp == NULL)
    Abort_LWP("Insufficient Storage to Initialize LWP Support");
d746 3
a748 3
  /* check parameters */
  Initialize_PCB(temp, priority, NULL, 0, NULL, NULL,"Main Process");
  gettimeofday(&temp->lastReady, 0);
d751 1
a751 1
  Highest_runnable_priority = priority;
d754 2
a755 2
  /* initialize mutex and semaphore */
  Proc_Running = TRUE;
d757 2
a758 2
  pthread_mutex_init(&run_sem, NULL);
  pthread_mutex_init(&ct_mutex, NULL);
d760 9
a768 9
  run_sem = CreateMutex (NULL, FALSE, "run_sem");
  if (run_sem == NULL) abort();
  ct_mutex = CreateMutex (NULL, FALSE, "ct_mutex");
  if (ct_mutex == NULL) abort();
#endif
  lwp_cpptr = temp;
  Dispatcher();
  *pid = temp;
  return LWP_SUCCESS;
d774 12
a785 12
  Debug(0, ("Entered LWP_SignalProcess, yield=%d", yield));
  if (lwp_init) {
    int rc;
    rc = Internal_Signal(event);
    if (yield) {
      Cal_Highest_runnable_priority();
      Debug(0, ("hipri=%d", Highest_runnable_priority));
      Dispatcher();
    }
    return rc;
  } else
    return LWP_EINIT;
d791 1
a791 1
    register int ecount, i;
d817 2
a818 2
	      (char **)realloc((char *)lwp_cpptr->eventlist, 
			       ecount*sizeof(char *));
d835 1
a835 1
	  Cal_Highest_runnable_priority();
d848 1
a848 1
	Debug(0, ("WaitProcess:%s going to wait \n", old_cpptr->name))
d852 1
a852 1
	Debug(0, ("WaitProcess:%s woke up \n", old_cpptr->name))
d875 1
a875 1
Abort_LWP(char *msg)
d877 2
d880 4
a883 1
    printf("***LWP Abort: %s\n", msg);
a893 1
    LWP_INT_WAIT(&temp->c, &run_sem);
d896 4
d923 5
a927 5
	case READY:	printf("READY");     break;
	case WAITING:	printf("WAITING");   break;
	case DESTROYED:	printf("DESTROYED"); break;
	default:	printf("unknown");
	}
d930 1
a930 1
	    pid->priority, (int)pid->parm);
d946 3
a948 3
	void *t;
	int my_priority;
	PROCESS	old_cpptr;
d952 1
a952 1
	int i = Highest_runnable_priority;
d954 3
a956 3
	Cal_Highest_runnable_priority();
	if (Highest_runnable_priority != i) {
	    printf("hipri was %d actually %d\n", i, Highest_runnable_priority);
d958 1
a958 1
	    Dump_Processes();
d960 2
a961 2
	}
	Highest_runnable_priority = i;
d963 20
a982 14
	my_priority = lwp_cpptr->priority;
	Debug(0, ("Dispatcher: %d runnable at pri %d hi %d blk %d", 
		  runnable[my_priority].count, my_priority, 
		  Highest_runnable_priority, PRE_Block));
	PRE_Block = 1;
	if ((my_priority < Highest_runnable_priority) || 
	    (runnable[my_priority].count > 0))
	  {
	    Debug(0, ("Dispatcher: %s is now yielding", lwp_cpptr->name));
	    /* I have to quit */
	    old_cpptr = lwp_cpptr;
	    lwpinsert(old_cpptr, &runnable[my_priority]);
	    gettimeofday(&old_cpptr->lastReady, 0);
	    lwp_cpptr = runnable[Highest_runnable_priority].head;
d984 1
a984 5
	    /* remove next process from runnable queue and signal it */
	    lwpremove(lwp_cpptr, &runnable[Highest_runnable_priority]);
	    LWP_INT_LOCK(&ct_mutex);
	    Debug(0, ("Dispatcher: %s going to signal %s condition\n", 
		      old_cpptr->name, lwp_cpptr->name))
d986 21
a1006 1
	    LWP_INT_SIGNAL(&lwp_cpptr->c);
d1008 5
a1012 27
	    /* now sleep until somebody wakes me */
	    Debug(0, ("Dispatcher: %s going to wait on own condition\n", 
		      old_cpptr->name))
	    LWP_INT_WAIT(&old_cpptr->c, &ct_mutex);
	    LWP_INT_UNLOCK(&ct_mutex);
	    Debug(0, ("Dispatcher: %s woke up\n", 
		      old_cpptr->name))

	    /* update global pointer */
	    lwp_cpptr = old_cpptr;
	} else {
	    Debug(0, ("Dispatcher: %s still running", lwp_cpptr->name))
	}
	/* make sure HRP is set correct */
	Highest_runnable_priority = lwp_cpptr->priority;
	if (lwp_cpptr->status == DESTROYED){
		/* the process was runnable but got destroyed by somebody */
		Free_PCB(lwp_cpptr);
		Cal_Highest_runnable_priority();
		lwp_cpptr = runnable[Highest_runnable_priority].head;
		lwpremove(lwp_cpptr, &runnable[Highest_runnable_priority]);

		LWP_INT_LOCK(&ct_mutex);
		LWP_INT_SIGNAL(&lwp_cpptr->c);
		LWP_INT_UNLOCK(&ct_mutex);
		LWP_INT_EXIT(t);
	}
d1014 1
a1014 1
	if (PRE_Block != 1) Abort_LWP("PRE_Block not 1");
d1016 1
a1016 1
	PRE_Block = 0;
d1023 1
a1023 1
    Debug(0, ("Entered Free_PCB"))
d1025 2
a1026 1
    if (pid->eventlist != NULL)  free((char *)pid->eventlist);
d1034 1
a1034 1
    register int i = 0;
d1036 1
a1036 1
    Debug(0, ("Entered Initialize_PCB"))
d1038 2
a1039 1
	while (((temp -> name[i] = name[i]) != '\0') && (i < 31)) i++;
d1058 1
d1073 1
a1073 2

    Debug(0, ("Leaving Initialize_PCB\n"))
d1077 1
a1077 1
Internal_Signal(register char *event)
d1079 2
a1080 2
  int rc = LWP_ENOWAIT;
  register int i;
d1082 5
a1086 3
  Debug(0, ("Entered Internal_Signal [event id 0x%x]", (int)event));
  if (!lwp_init) return LWP_EINIT;
  if (event == NULL) return LWP_EBADEVENT;
d1088 26
a1113 22
  for_all_elts(temp, blocked, {     /* for all pcb's on the blocked q */
    if (temp->status == WAITING)
      for (i=0; i < temp->eventcnt; i++) { /* check each event in list */
	if (temp -> eventlist[i] == event) {
	  temp -> eventlist[i] = NULL;
	  rc = LWP_SUCCESS;
	  Debug(0, ("decrementing %s to %d", temp->name, (temp->waitcnt-1)));
	  /* reduce waitcnt by 1 for the signal */
	  /* if wcount reaches 0 then make the process runnable */
	  if (--temp->waitcnt == 0) {
	    temp -> status = READY;
	    temp -> wakevent = i+1;
	    lwpmove(temp, &blocked, &runnable[temp->priority]);
	    gettimeofday(&temp->lastReady, 0);
	    Highest_runnable_priority = 
	      MAX(Highest_runnable_priority, temp->priority);
	    Debug(0, ("marked runnable. hi_pri %d, %d at %d", Highest_runnable_priority, runnable[temp->priority].count, temp->priority));
	    break;
	  }
	}
      }
  })
d1123 1
d1127 4
a1130 1
    for (i = LWP_MAX_PRIORITY; runnable[i].count == 0 && i >=0; i--);
d1133 5
a1137 1
	    Abort_LWP("No ready processes");
d1139 1
a1139 4
	    Highest_runnable_priority = i;
#else
    if (i >= 0)
	    Highest_runnable_priority = i;
@


1.2
log
@New Arla userland from Arla between 0.34.2 and current in arla cvs.
Too many new features and fixes to mention here.
@
text
@d43 1
a43 1
RCSID("$Id: plwp.c,v 1.9 2000/05/12 08:41:32 lha Exp $");
@


1.1
log
@upgrade Arla to fresher code. Too many new features and bugfixes.
@
text
@a0 1
/*	$OpenBSD$	*/
d3 5
d43 1
a43 1
RCSID("$KTH: plwp.c,v 1.2 1999/02/02 00:47:16 assar Exp $");
d76 1
a76 1
	     printf("***LWP (%p): ", lwp_cpptr);\
d85 2
d148 5
d155 96
d323 1
d329 3
d366 1
d372 1
a372 1
	  return(LWP_EBADROCK);
d375 9
a383 1
        /* ra[lwp_cpptr->rused].value = Value; */
d423 1
a423 1
LWP_WaitProcess(char *event)
d508 2
a509 2
    timerclear(&lwp_cpptr->lastReady);
    pthread_mutex_lock(&ct_mutex);
d512 1
a512 1
    pthread_cond_signal(&lwp_cpptr->c);
d517 4
a520 2
    pthread_cond_wait(&old_cpptr->c, &ct_mutex);
    pthread_mutex_unlock(&ct_mutex);
d559 1
d562 4
a566 1
    int retval;
d599 1
d606 1
d608 9
a616 1
	pthread_detach(ct);
d621 1
a621 1
	pthread_mutex_lock(&run_sem);
d625 2
a626 1
	  pthread_mutex_unlock(&run_sem);
d634 4
a637 1
	  pthread_mutex_lock(&run_sem);
d641 1
a641 1
	pthread_mutex_unlock(&run_sem);
d650 1
d652 1
d664 1
d666 3
d679 4
a682 4
      pthread_mutex_lock(&ct_mutex);
      pthread_cond_signal(&lwp_cpptr->c);
      pthread_mutex_unlock(&ct_mutex);
      pthread_exit(t);
d709 1
d750 1
d752 1
d756 1
d759 6
a764 1

d841 1
a841 1
	timerclear(&lwp_cpptr->lastReady);
d843 3
a845 3
		  old_cpptr->name, lwp_cpptr->name))
        pthread_mutex_lock(&ct_mutex);
        pthread_cond_signal(&lwp_cpptr->c);
d849 4
a852 2
	pthread_cond_wait(&old_cpptr->c, &ct_mutex);
	pthread_mutex_unlock(&ct_mutex);
d856 1
d877 1
a877 1
    Debug(0, ("Entered Abort_LWP"))
d887 1
a887 1
    pthread_mutex_lock(&run_sem);
d889 3
a891 2
    pthread_cond_wait(&temp->c, &run_sem);
    pthread_mutex_unlock(&run_sem);
d894 1
d897 2
a898 1
#endif
d941 2
d945 1
a945 1
	
d947 6
a952 2
	if (Highest_runnable_priority != i)
	  printf("hipri was %d actually %d\n", i, Highest_runnable_priority);
d972 1
a972 1
	    pthread_mutex_lock(&ct_mutex);
d976 1
a976 1
	    pthread_cond_signal(&lwp_cpptr->c);
d981 4
a984 2
	    pthread_cond_wait(&old_cpptr->c, &ct_mutex);
	    pthread_mutex_unlock(&ct_mutex);
d1000 4
a1003 4
		pthread_mutex_lock(&ct_mutex);
		pthread_cond_signal(&lwp_cpptr->c);
		pthread_mutex_unlock(&ct_mutex);
		pthread_exit(t);
d1048 1
a1048 1
    timerclear(&temp->lastReady);
d1051 1
d1054 8
d1107 3
@


1.1.1.1
log
@Import of arla-0.35.7
@
text
@d1 1
a3 5
 *
 * Windows Threads support was added by Love <lha@@stacken.kth.se>
 * and debugged by Magnus <map@@stacken.kth.se> and Robert <rb@@abc.se>.
 * It make have a glue layer around the windows primiptives to make
 * it look like pthreads.
d39 1
a39 1
RCSID("$KTH: plwp.c,v 1.9 2000/05/12 08:41:32 lha Exp $");
d72 1
a72 1
	     printf("***LWP(max=%d) (%p): ", Highest_runnable_priority, lwp_cpptr);\
a80 2
#define lwp_timerclear(t) (t)->tv_sec = (t)->tv_usec = 0

a141 5
/*
 * Glue for
 */

#if defined(PTHREADS_LWP)
a143 96
#define LWP_INT_LOCK(sem)	pthread_mutex_lock(sem)
#define LWP_INT_UNLOCK(sem)	pthread_mutex_unlock(sem)

#define LWP_INT_WAIT(cond, mutex)	pthread_cond_wait(cond, mutex)
#define LWP_INT_SIGNAL(cond)	pthread_cond_signal(cond)

#define LWP_INT_EXIT(t)		pthread_exit(t)

#elif defined(WINDOWS_THREADS_LWP)

HANDLE run_sem, ct_mutex;

#if 0
#define LWP_INT_LOCK(sem)	WaitForSingleObject (sem, INFINITE)
#define LWP_INT_UNLOCK(sem)	ReleaseMutex (sem)
#endif

static DWORD LWP_INT_LOCK(HANDLE *sem)
{
    DWORD ret = WaitForSingleObject(*sem, INFINITE);
    if (ret == WAIT_FAILED) {
      DWORD err = GetLastError();
      Debug(0, ("LWP_INT_LOCK: h = %p, wait = %ld, %ld\n",
		*sem, ret, err));
    }
    return ret;
}

static DWORD LWP_INT_UNLOCK(HANDLE *sem)
{
    DWORD ret = ReleaseMutex(*sem);
    if (!ret) {
      DWORD err = GetLastError();
      Debug(0, ("LWP_INT_UNLOCK: h = %p, wait = %ld, %ld\n",
		*sem, ret, err));
    }
    return ret;
}

static DWORD LWP_INT_WAIT(HANDLE *cond, HANDLE *mutex)
{
  DWORD ret;
  static int times = 0;
  int this_time = times++;

  Debug(0, ("LWP_INT_WAIT(%d): cond: %p mutex: %p\n",
	    this_time, *cond, *mutex));
  ret = ReleaseMutex (*mutex);
  if (!ret) {
      DWORD err = GetLastError();
      Debug(0, ("LWP_INT_WAIT(%d): ReleaseMutex failed: %ld error: %ld mutex\n", 
		this_time, ret, err, *mutex));
      abort();
  }      
  ret = WaitForSingleObject (*cond, INFINITE);
  if (ret != WAIT_OBJECT_0) {
      Debug(0, ("LWP_INT_WAIT(%d): WaitForSingleObject(cond) failed: %ld mutex: %p\n",
		this_time, ret, *mutex));
      abort();
  }
  ret = WaitForSingleObject (*mutex, INFINITE);
  if (ret != WAIT_OBJECT_0) {
      Debug(0, ("LWP_INT_WAIT(%d): WaitForSingleObject(mutex) failed: %ld mutex: %p\n",
		this_time, ret, *mutex));
      abort();
  }
#if 0
  ret = SignalObjectAndWait(*mutex, *cond, INFINITE, FALSE /* XXX */);
  if (ret != WAIT_OBJECT_0) {
    DWORD err = GetLastError();
    Debug(0, ("LWP_INT_WAIT(%d): SignalObjectAndWait failed: %ld error: %ld mutex: %p cond: %p\n", this_time, ret, err, *mutex, *cond));
    /* XXX */
    return ret;    
  }
  Debug(0, ("LWP_INT_WAIT(%d): woke up, waiting for mutex: cond: %p mutex: %p\n", this_time, *cond, *mutex));
  ret = WaitForSingleObject(*mutex, INFINITE);
  if (ret != WAIT_OBJECT_0) {
    Debug(0, ("LWP_INT_WAIT(%d): WaitForSingleObject(mutex) failed: %ld mutex: %p\n", this_time, ret, *mutex));
    /* XXX */
    return ret;
  }
#endif
  Debug(0, ("LWP_INT_WAIT(%d): got mutex: cond: %p mutex: %p\n",
	    this_time, *cond, *mutex));
  return 0;
}

#define LWP_INT_SIGNAL(cond)	do { \
Debug(0, ("LWP_INT_SIGNAL: cond: %p\n", *cond)); \
PulseEvent (*cond); } while (0)


#define LWP_INT_EXIT(t)		ExitThread ((int)t); /* XXX */

#endif

a215 1
#ifdef PTHREADS_LWP
a220 3
#elif WINDOWS_THREADS_LWP
	  *Value = TlsGetValue((unsigned long) ra[i].val);
#endif
a254 1
#if defined(LWP_THREADS)
d260 1
a260 1
	    return(LWP_EBADROCK);
d263 1
a263 9

#elif defined(WINDOWS_THREADS_LWP)
	ra[lwp_cpptr->rused].val = (LPVOID) TlsAlloc();
	if (ra[lwp_cpptr->rused].val == (LPVOID) 0xFFFFFFFF)
	    return(LWP_EBADROCK);
	if (!TlsSetValue((unsigned long) ra[lwp_cpptr->rused].val, Value))
	    return(LWP_EBADROCK);
#endif

d303 1
a303 1
LWP_WaitProcess(void *event)
d388 2
a389 2
    lwp_timerclear(&lwp_cpptr->lastReady);
    LWP_INT_LOCK(&ct_mutex);
d392 1
a392 1
    LWP_INT_SIGNAL(&lwp_cpptr->c);
d397 2
a398 4
    LWP_INT_WAIT(&old_cpptr->c, &ct_mutex);
    LWP_INT_UNLOCK(&ct_mutex);
    Debug(0, ("LWP_QWait:%s woke up \n",
	      old_cpptr->name));
a436 1
#if defined(PTHREADS_LWP)
d439 1
a440 4
#elif defined(WINDOWS_THREADS_LWP)
    HANDLE ct;
#endif
    PROCESS old_cpptr;
a472 1
#if defined(PTHREADS_LWP)
d479 1
a480 10
	temp->a = cta;
#elif defined(WINDOWS_THREADS_LWP)
	Debug(0,("Before CreateThread Create_Process_Part2"));
      ct = CreateThread (NULL, 
			 stacksize, (LPTHREAD_START_ROUTINE) Create_Process_Part2, 
			 temp,  0,  NULL);
	Debug(0,("After CreateThread Create_Process_Part2"));
      if (ct != NULL) {
	temp->t = ct;
#endif
d485 1
a485 1
	LWP_INT_LOCK(&run_sem);
d489 1
a489 2
	  LWP_INT_UNLOCK(&run_sem);
#if defined(PTHREADS_LWP)
d497 1
a497 4
#elif defined(WINDOWS_THREADS_LWP)
	  Sleep(0); /* XXX */
#endif
	  LWP_INT_LOCK(&run_sem);
d501 1
a501 1
	LWP_INT_UNLOCK(&run_sem);
a509 1
#ifdef PTHREADS_LWP	
a510 1
#endif
a521 1
#if defined(PTHREADS_LWP)
a522 3
#elif defined(WINDOWS_THREADS_LWP)
    CloseHandle (pid->t);
#endif
d533 4
a536 4
      LWP_INT_LOCK(&ct_mutex);
      LWP_INT_SIGNAL(&lwp_cpptr->c);
      LWP_INT_UNLOCK(&ct_mutex);
      LWP_INT_EXIT(t);
a562 1
  lwp_debug = 0;
a602 1
#if 0
a603 1
#endif
a606 1
#if defined(PTHREADS_LWP)
d609 1
a609 6
#elif defined(WINDOWS_THREADS_LWP)
  run_sem = CreateMutex (NULL, FALSE, "run_sem");
  if (run_sem == NULL) abort();
  ct_mutex = CreateMutex (NULL, FALSE, "ct_mutex");
  if (ct_mutex == NULL) abort();
#endif
d686 1
a686 1
	lwp_timerclear(&lwp_cpptr->lastReady);
d688 3
a690 3
		  old_cpptr->name, lwp_cpptr->name));
        LWP_INT_LOCK(&ct_mutex);
        LWP_INT_SIGNAL(&lwp_cpptr->c);
d694 2
a695 4

	LWP_INT_WAIT(&old_cpptr->c, &ct_mutex);
	LWP_INT_UNLOCK(&ct_mutex);
	Debug(0, ("WaitProcess:%s woke up \n", old_cpptr->name))
a698 1

d719 1
a719 1
    Debug(0, ("Entered Abort_LWP"));
d729 1
a729 1
    LWP_INT_LOCK(&run_sem);
d731 2
a732 3
    LWP_INT_WAIT(&temp->c, &run_sem);
    LWP_INT_UNLOCK(&run_sem);

a734 1
#if defined(PTHREADS_LWP)
d737 1
a737 2
#endif /* _POSIX_THREAD_ATTR_STACKSIZE */
#endif /* PTHREADS_LWP */
a779 2


d782 1
a782 1
	    
d784 2
a785 6
	if (Highest_runnable_priority != i) {
	    printf("hipri was %d actually %d\n", i, Highest_runnable_priority);
#if 0
	    Dump_Processes();
#endif
	}
d805 1
a805 1
	    LWP_INT_LOCK(&ct_mutex);
d809 1
a809 1
	    LWP_INT_SIGNAL(&lwp_cpptr->c);
d814 2
a815 4
	    LWP_INT_WAIT(&old_cpptr->c, &ct_mutex);
	    LWP_INT_UNLOCK(&ct_mutex);
	    Debug(0, ("Dispatcher: %s woke up\n", 
		      old_cpptr->name))
d831 4
a834 4
		LWP_INT_LOCK(&ct_mutex);
		LWP_INT_SIGNAL(&lwp_cpptr->c);
		LWP_INT_UNLOCK(&ct_mutex);
		LWP_INT_EXIT(t);
d879 1
a879 1
    lwp_timerclear(&temp->lastReady);
a881 1
#if defined(PTHREADS_LWP)
a883 8
#elif defined(WINDOWS_THREADS_LWP)
    temp->m = CreateMutex (NULL, FALSE, NULL);
    if (temp->m == NULL) abort();
    temp->c = CreateEvent (NULL, FALSE, FALSE, NULL);
    if (temp->c == NULL) abort();
    Debug(0, ("Init_PCB: event = %p\n", temp->c));
#endif

a928 3
#if 0
    Dump_Processes();
#endif
@


1.1.1.2
log
@Import of arla -current as of Aug 5 2003

ok todd@@ deraadt@@
@
text
@d6 1
a6 1
 * It provides a glue layer around the windows primitives to make
a33 1
#include <stdarg.h>
a41 1
#include "preempt.h"
d43 1
a43 1
RCSID("$arla: plwp.c,v 1.22 2003/01/24 19:38:35 tol Exp $");
d58 2
d71 1
d74 6
a79 9
#define Debug(level, msg)					\
    do {							\
        if (lwp_debug && lwp_debug >= level) {			\
	    printf("***LWP(max=%d) (%p): ",			\
		   Highest_runnable_priority, lwp_cpptr);	\
	    printf msg;						\
	    putchar('\n');					\
	}							\
    } while(0)
d82 1
a82 1
#define Debug(level, msg) do {} while (0)
d88 1
a88 1
static void Abort_LWP(char *msg, ...) ;
d98 1
a98 1
static int Internal_Signal(char *event) ;
d122 2
a123 2
	    PROCESS var, _NEXT_;\
	    int _I_;\
d130 1
a130 1
static struct lwp_ctl *lwp_init = NULL;
d134 1
a134 1
static void Delete_PCB(PROCESS pid);
d172 1
a172 2
static
DWORD LWP_INT_LOCK(HANDLE *sem)
d174 1
a174 3
    DWORD ret;
    Debug(0, ("LWP_INT_LOCK: sem = %p", *sem));
    ret = WaitForSingleObject(*sem, INFINITE);
d176 3
a178 3
	DWORD err = GetLastError();
	Debug(0, ("LWP_INT_LOCK: h = %p, wait = %ld, %ld\n",
		  *sem, ret, err));
a179 1
    Debug(0, ("LWP_INT_LOCK: got %p", *sem));
d185 1
a185 3
    DWORD ret;
    Debug(0, ("LWP_INT_UNLOCK: sem = %p", *sem));
    ret = ReleaseMutex(*sem);
d187 3
a189 3
	DWORD err = GetLastError();
	Debug(0, ("LWP_INT_UNLOCK: h = %p, wait = %ld, %ld\n",
		  *sem, ret, err));
a190 1
    Debug(0, ("LWP_INT_UNLOCK: %p released", *sem));
d196 44
a239 30
    DWORD ret;
    static int times = 0;
    int this_time = times++;

    Debug(0, ("LWP_INT_WAIT(%d): cond: %p mutex: %p",
	      this_time, *cond, *mutex));
    ret = ReleaseMutex (*mutex);
    if (!ret) {
	DWORD err = GetLastError();
	Debug(0, ("LWP_INT_WAIT(%d): ReleaseMutex failed: %ld error: "
		  "%ld mutex\n", this_time, err, *mutex));
	abort();
    }      
    Debug(0, ("LWP_INT_WAIT(%d): mutex released, waiting", this_time));
    ret = WaitForSingleObject (*cond, INFINITE);
    if (ret != WAIT_OBJECT_0) {
	Debug(0, ("LWP_INT_WAIT(%d): WaitForSingleObject(cond) failed: "
		  "%ld mutex: %p\n", this_time, ret, *mutex));
	abort();
    }
    Debug(0, ("LWP_INT_WAIT(%d): got sem, waiting for mutex", this_time));
    ret = WaitForSingleObject (*mutex, INFINITE);
    if (ret != WAIT_OBJECT_0) {
	Debug(0, ("LWP_INT_WAIT(%d): WaitForSingleObject(mutex) failed: "
		  "%ld mutex: %p\n",  this_time, ret, *mutex));
	abort();
    }
    Debug(0, ("LWP_INT_WAIT(%d): got mutex: cond: %p mutex: %p",
	      this_time, *cond, *mutex));
    return 0;
d244 1
a244 1
SetEvent (*cond); } while (0)
d252 1
a252 1
lwpremove(PROCESS p, struct QUEUE *q)
d270 1
a270 1
lwpinsert(PROCESS p, struct QUEUE *q)
d295 1
a295 1
    int i;
d298 1
a298 2
    if (lwp_init == NULL) 
	return LWP_EINIT;
d301 2
a302 2
        for_all_elts(cur, runnable[i], { Free_PCB(cur);});
    for_all_elts(cur, blocked, { Free_PCB(cur);});
d313 2
a314 2
       LWP_SUCCESS    if specified rock exists and Value has been filled
       LWP_EBADROCK   rock specified does not exist
d316 2
a317 2
    int i;
    struct rock *ra;
d325 1
a325 1
	    pthread_getspecific(ra[i].val, Value);
d327 1
a327 1
	    *Value = pthread_getspecific(ra[i].val);
d330 1
a330 1
	    *Value = TlsGetValue((unsigned long) ra[i].val);
d332 2
a333 2
	    /**Value =  ra[i].value;*/
	    return(LWP_SUCCESS);
d343 10
a352 10
       Return codes:
       LWP_SUCCESS     Rock did not exist and a new one was used
       LWP_EBADROCK    Rock already exists.
       LWP_ENOROCKS    All rocks are in use.

       From the above semantics, you can only set a rock value once.
       This is specifically to prevent multiple users of the LWP
       package from accidentally using the same Tag value and
       clobbering others.  You can always use one level of
       indirection to obtain a rock whose contents can change.  */
d354 2
a355 2
    int i;
    struct rock *ra;   /* rock array */
d370 1
a370 1
	    if (pthread_key_create(&ra[lwp_cpptr->rused].val, NULL))
d372 1
a372 1
		return(LWP_EBADROCK);
d374 1
a374 1
	    return(LWP_EBADROCK);
d394 3
a396 3
    Debug(0, ("Entered Dispose_of_Dead_PCB"));
    Delete_PCB(cur);
    Free_PCB(cur);
d404 2
a405 2
	*pid = lwp_cpptr;
	return LWP_SUCCESS;
d435 1
a435 1
Delete_PCB(PROCESS pid)
d447 1
a447 1
	Dispose_of_Dead_PCB(cur); });
d460 1
a460 1
	int i;
d465 3
a467 3
	    });
	for_all_elts(x, blocked, { Dump_One_Process(x); });
    } else {
a468 1
    }
d498 1
a498 1
    Debug(0, ("LWP_QWait: %s is going to QWait", lwp_cpptr->name));
d510 1
a510 1
    Debug(0, ("LWP_QWait:%s going to wake up %s", old_cpptr->name, 
d515 1
a515 1
    Debug(0, ("LWP_QWait:%s going to wait on own condition", 
d519 1
a519 1
    Debug(0, ("LWP_QWait:%s woke up",
d526 1
a526 1
	Dispatcher();
d536 13
a548 13
	Debug(0, ("LWP_Qsignal: %s is going to QSignal %s\n", lwp_cpptr->name,
		  pid->name));
	pid->status = READY;
	lwpinsert(pid, &runnable[pid->priority]);
	Debug(0, ("LWP_QSignal: Just inserted %s into runnable queue\n", 
		  pid->name));
	gettimeofday(&pid->lastReady, 0);
	Highest_runnable_priority = 
	    MAX(Highest_runnable_priority, pid->priority);
	Debug(0, ("%s priority= %d; HRP = %d; Signalled process pri = %d", 
		  lwp_cpptr->name, lwp_cpptr->priority,
		  Highest_runnable_priority, pid->priority));
	return LWP_SUCCESS;	
d567 1
a567 1
    
a572 3
    
    if (lwp_init == NULL)
	return LWP_EINIT;
d574 4
a577 3
    /* allocate the memory for the pcb - check for malloc errors */
    temp = (PROCESS)malloc (sizeof (struct lwp_pcb));
    if (temp == NULL) {
d580 4
a583 4
    }
    
    /* check priorities */
    if (priority < 0 || priority >= MAX_PRIORITIES) {
d586 13
a598 14
    }
    
    Initialize_PCB(temp, priority, NULL, 0, ep, parm, name);
    
    /* make the process runnable by placing it in the runnable q */
    lwpinsert(temp, &runnable[priority]);
    gettimeofday(&temp->lastReady, 0);
    
    if (PRE_Block != 0)
	Abort_LWP("PRE_Block not 0");
    
    PRE_Block = 1;
    Proc_Running = FALSE;	    /* sem set true by forked process */
    
d600 1
a600 1
    pthread_attr_init(&cta);
d602 1
a602 1
    pthread_attr_setstacksize(&cta, stacksize);
d604 4
a607 7
    retval = pthread_create(&ct, &cta, (void *)Create_Process_Part2, temp);
    if (retval != 0)
	Abort_LWP("pthread_create failed to create thread %d/%d", 
		  retval, errno);

    pthread_detach(ct);
    temp->a = cta;
d609 7
a615 9
    Debug(0,("Before CreateThread Create_Process_Part2"));
    ct = CreateThread (NULL, 
		       stacksize, (LPTHREAD_START_ROUTINE)Create_Process_Part2,
		       temp,  0,  NULL);
    Debug(0,("After CreateThread Create_Process_Part2"));
    if (ct == NULL)
	Abort_LWP("CreateThread failed to create thread: %d", 
		  (int)GetLastError());
    temp->t = ct;
d618 8
a625 8
    /* check if max priority has changed */
    Highest_runnable_priority = MAX(Highest_runnable_priority, priority);
    
    LWP_INT_LOCK(&run_sem);
    Debug(0, ("Before creating process yields Proc_Running = %d\n", 
	      Proc_Running));
    while( !Proc_Running ){
	LWP_INT_UNLOCK(&run_sem);
d628 1
a628 1
	thr_yield();
d630 1
a630 1
	sched_yield();
d632 1
a632 1
	pthread_yield();
d635 17
a651 1
	Sleep(0); /* XXX */
a652 3
	LWP_INT_LOCK(&run_sem);
	Debug(0,("After creating proc yields and gets back control Proc_Running = %d\n", 
		 Proc_Running));
d654 1
a654 7
    LWP_INT_UNLOCK(&run_sem);
    
    lwp_cpptr = old_cpptr;
    
    Dispatcher();
    *pid = temp;
    return LWP_SUCCESS;
d660 1
a660 1
    void *t;
d662 2
a663 2
    Debug(0, ("Entered Destroy_Process"));
    if (lwp_init) {
d665 1
a665 1
	pthread_attr_destroy(&pid->a);
d667 1
a667 1
	CloseHandle (pid->t);
d669 5
a673 5
	if (lwp_cpptr == pid){
	    /* kill myself */
	    pid->status = DESTROYED;
	    Free_PCB(pid);
	    Cal_Highest_runnable_priority();
d675 3
a677 3
	    /* Calculate next runnable lwp and signal it */
	    lwp_cpptr = runnable[Highest_runnable_priority].head;
	    lwpremove(lwp_cpptr, &runnable[Highest_runnable_priority]);
d679 14
a692 14
	    LWP_INT_LOCK(&ct_mutex);
	    LWP_INT_SIGNAL(&lwp_cpptr->c);
	    LWP_INT_UNLOCK(&ct_mutex);
	    LWP_INT_EXIT(t);
	} else {
	    /* kill some other process - mark status destroyed - 
	       if process is blocked, it will be purged on next create proc;
	       if it is runnable the dispatcher will kill it */
	    pid->status = DESTROYED ;
	    Dispatcher();
	}
	return LWP_SUCCESS ;
    } else
	return LWP_EINIT;
d698 1
a698 1
    Debug(0, ("Entered Dispatch_Process"));
d702 1
a702 1
    } else {
a703 1
    }
d709 2
a710 2
    lwp_debug = 0;
    if (version != LWP_VERSION)
d712 2
a713 2
	fprintf(stderr, "**** FATAL ERROR: LWP VERSION MISMATCH ****\n");
	exit(-1);
d715 1
a715 1
    else return(InitializeProcessSupport(priority, pid));    
d721 1
a721 1
    return(InitializeProcessSupport(priority, pid));    
d727 2
a728 2
    PROCESS temp;
    int i;
d730 2
a731 3
    Debug(0, ("Entered InitializeProcessSupport"));
    if (lwp_init != NULL) 
	return LWP_SUCCESS;
d733 12
a744 12
    /* check priorities and set up running and blocked queues */
    if (priority >= MAX_PRIORITIES) return LWP_EBADPRI;
    for (i=0; i<MAX_PRIORITIES; i++) {
	runnable[i].head = NULL;
	runnable[i].count = 0;
    }
    blocked.head = NULL;
    blocked.count = 0;
    lwp_init = (struct lwp_ctl *) malloc(sizeof(struct lwp_ctl));
    temp = (PROCESS) malloc(sizeof(struct lwp_pcb));
    if (lwp_init == NULL || temp == NULL)
	Abort_LWP("Insufficient Storage to Initialize LWP Support");
d746 3
a748 3
    /* check parameters */
    Initialize_PCB(temp, priority, NULL, 0, NULL, NULL,"Main Process");
    gettimeofday(&temp->lastReady, 0);
d751 1
a751 1
    Highest_runnable_priority = priority;
d754 2
a755 2
    /* initialize mutex and semaphore */
    Proc_Running = TRUE;
d757 2
a758 2
    pthread_mutex_init(&run_sem, NULL);
    pthread_mutex_init(&ct_mutex, NULL);
d760 9
a768 9
    run_sem = CreateMutex (NULL, FALSE, "run_sem");
    if (run_sem == NULL) abort();
    ct_mutex = CreateMutex (NULL, FALSE, "ct_mutex");
    if (ct_mutex == NULL) abort();
#endif
    lwp_cpptr = temp;
    Dispatcher();
    *pid = temp;
    return LWP_SUCCESS;
d774 12
a785 12
    Debug(0, ("Entered LWP_SignalProcess, yield=%d", yield));
    if (lwp_init) {
	int rc;
	rc = Internal_Signal(event);
	if (yield) {
	    Cal_Highest_runnable_priority();
	    Debug(0, ("hipri=%d", Highest_runnable_priority));
	    Dispatcher();
	}
	return rc;
    } else
	return LWP_EINIT;
d791 1
a791 1
    int ecount, i;
d817 2
a818 2
		(char **)realloc((char *)lwp_cpptr->eventlist, 
				 ecount*sizeof(char *));
d835 1
a835 1
	    Cal_Highest_runnable_priority();
d848 1
a848 1
	Debug(0, ("WaitProcess:%s going to wait \n", old_cpptr->name));
d852 1
a852 1
	Debug(0, ("WaitProcess:%s woke up \n", old_cpptr->name));
d875 1
a875 1
Abort_LWP(char *msg, ...)
a876 2
    va_list ap;

d878 1
a878 4
    va_start(ap, msg);
    printf("***LWP Abort ");
    vprintf(msg, ap);
    va_end(ap);
d889 1
a891 4
    LWP_INT_LOCK(&ct_mutex);
    LWP_INT_WAIT(&temp->c, &ct_mutex);
    LWP_INT_UNLOCK(&ct_mutex);

d915 5
a919 5
    case READY:	printf("READY");     break;
    case WAITING:	printf("WAITING");   break;
    case DESTROYED:	printf("DESTROYED"); break;
    default:	printf("unknown");
    }
d922 1
a922 1
	   pid->priority, (int)pid->parm);
d938 3
a940 3
    void *t;
    int my_priority;
    PROCESS	old_cpptr;
d944 1
a944 1
    int i = Highest_runnable_priority;
d946 3
a948 3
    Cal_Highest_runnable_priority();
    if (Highest_runnable_priority != i) {
	printf("hipri was %d actually %d\n", i, Highest_runnable_priority);
d950 1
a950 1
	Dump_Processes();
d952 2
a953 2
    }
    Highest_runnable_priority = i;
d955 14
a968 20
    my_priority = lwp_cpptr->priority;
    Debug(0, ("Dispatcher: %d runnable at pri %d hi %d blk %d", 
	      runnable[my_priority].count, my_priority, 
	      Highest_runnable_priority, PRE_Block));
    PRE_Block = 1;
    if ((my_priority < Highest_runnable_priority) || 
	(runnable[my_priority].count > 0))
    {
	Debug(0, ("Dispatcher: %s is now yielding", lwp_cpptr->name));
	/* I have to quit */
	old_cpptr = lwp_cpptr;
	lwpinsert(old_cpptr, &runnable[my_priority]);
	gettimeofday(&old_cpptr->lastReady, 0);
	lwp_cpptr = runnable[Highest_runnable_priority].head;

	/* remove next process from runnable queue and signal it */
	lwpremove(lwp_cpptr, &runnable[Highest_runnable_priority]);
	LWP_INT_LOCK(&ct_mutex);
	Debug(0, ("Dispatcher: %s going to signal %s condition", 
		  old_cpptr->name, lwp_cpptr->name));
d970 5
a974 1
	LWP_INT_SIGNAL(&lwp_cpptr->c);
d976 9
a984 21
	/* now sleep until somebody wakes me */
	Debug(0, ("Dispatcher: %s going to wait on own condition", 
		  old_cpptr->name));
	LWP_INT_WAIT(&old_cpptr->c, &ct_mutex);
	LWP_INT_UNLOCK(&ct_mutex);
	Debug(0, ("Dispatcher: %s woke up", 
		  old_cpptr->name));
	
	/* update global pointer */
	lwp_cpptr = old_cpptr;
    } else {
	Debug(0, ("Dispatcher: %s still running", lwp_cpptr->name));
    }
    /* make sure HRP is set correct */
    Highest_runnable_priority = lwp_cpptr->priority;
    if (lwp_cpptr->status == DESTROYED){
	/* the process was runnable but got destroyed by somebody */
	Free_PCB(lwp_cpptr);
	Cal_Highest_runnable_priority();
	lwp_cpptr = runnable[Highest_runnable_priority].head;
	lwpremove(lwp_cpptr, &runnable[Highest_runnable_priority]);
d986 19
a1004 5
	LWP_INT_LOCK(&ct_mutex);
	LWP_INT_SIGNAL(&lwp_cpptr->c);
	LWP_INT_UNLOCK(&ct_mutex);
	LWP_INT_EXIT(t);
    }
d1006 1
a1006 1
    if (PRE_Block != 1) Abort_LWP("PRE_Block not 1");
d1008 1
a1008 1
    PRE_Block = 0;
d1015 1
a1015 1
    Debug(0, ("Entered Free_PCB"));
d1017 1
a1017 2
    if (pid->eventlist != NULL)
	free((char *)pid->eventlist);
d1025 1
a1025 1
    int i = 0;
d1027 1
a1027 1
    Debug(0, ("Entered Initialize_PCB"));
d1029 1
a1029 2
	while (((temp -> name[i] = name[i]) != '\0') && (i < 31))
	    i++;
a1047 1
    temp -> stacksize = stacksize;
d1062 2
a1063 1
    Debug(0, ("Leaving Initialize_PCB\n"));
d1067 1
a1067 1
Internal_Signal(char *event)
d1069 2
a1070 2
    int rc = LWP_ENOWAIT;
    int i;
d1072 3
a1074 5
    Debug(0, ("Entered Internal_Signal [event id 0x%x]", (int)event));
    if (lwp_init == NULL)
	return LWP_EINIT;
    if (event == NULL) 
	return LWP_EBADEVENT;
d1076 22
a1097 26
    for_all_elts(temp, blocked, {     /* for all pcb's on the blocked q */
	if (temp->status == WAITING)
	    for (i=0; i < temp->eventcnt; i++) { /* check each event in list */
		if (temp -> eventlist[i] == event) {
		    temp -> eventlist[i] = NULL;
		    rc = LWP_SUCCESS;
		    Debug(0, ("decrementing %s to %d", temp->name,
			      (temp->waitcnt-1)));
		    /* reduce waitcnt by 1 for the signal */
		    /* if wcount reaches 0 then make the process runnable */
		    if (--temp->waitcnt == 0) {
			temp -> status = READY;
			temp -> wakevent = i+1;
			lwpmove(temp, &blocked, &runnable[temp->priority]);
			gettimeofday(&temp->lastReady, 0);
			Highest_runnable_priority = 
			    MAX(Highest_runnable_priority, temp->priority);
			Debug(0, ("marked runnable. hi_pri %d, %d at %d",
				  Highest_runnable_priority, 
				  runnable[temp->priority].count,
				  temp->priority));
			break;
		    }
		}
	    }
    });
a1106 1

d1110 1
a1110 4

    for (i = MAX_PRIORITIES - 1; i >= 0 ; i--)
	if (runnable[i].count != 0)
	    break;
d1113 4
a1116 2
	Abort_LWP("No ready processes");
#endif
d1118 1
a1118 4
	Highest_runnable_priority = i;
#if 0
    else
	abort();
@


