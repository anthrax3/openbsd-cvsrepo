head	1.8;
access;
symbols
	OPENBSD_5_2:1.7.0.24
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.22
	OPENBSD_5_0:1.7.0.20
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.7.0.18
	OPENBSD_4_9_BASE:1.7
	OPENBSD_4_8:1.7.0.16
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.7.0.12
	OPENBSD_4_7_BASE:1.7
	OPENBSD_4_6:1.7.0.14
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.7.0.10
	OPENBSD_4_5_BASE:1.7
	OPENBSD_4_4:1.7.0.8
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.7.0.6
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.7.0.4
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.2
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.6.0.14
	OPENBSD_4_0_BASE:1.6
	OPENBSD_3_9:1.6.0.12
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.6.0.10
	OPENBSD_3_8_BASE:1.6
	OPENBSD_3_7:1.6.0.8
	OPENBSD_3_7_BASE:1.6
	OPENBSD_3_6:1.6.0.6
	OPENBSD_3_6_BASE:1.6
	OPENBSD_3_5:1.6.0.4
	OPENBSD_3_5_BASE:1.6
	OPENBSD_3_4:1.6.0.2
	OPENBSD_3_4_BASE:1.6
	arla-20030805:1.1.1.3
	OPENBSD_3_3:1.4.0.4
	OPENBSD_3_3_BASE:1.4
	OPENBSD_3_2:1.4.0.2
	OPENBSD_3_2_BASE:1.4
	arla-0-35-7:1.1.1.2
	OPENBSD_3_1:1.3.0.8
	OPENBSD_3_1_BASE:1.3
	OPENBSD_3_0:1.3.0.6
	OPENBSD_3_0_BASE:1.3
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_9:1.3.0.4
	OPENBSD_2_8:1.3.0.2
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.2.0.4
	OPENBSD_2_7_BASE:1.2
	OPENBSD_2_6:1.2.0.2
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.1.1.1.0.4
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.2
	OPENBSD_2_4_BASE:1.1.1.1
	arla-0_9:1.1.1.1
	arla:1.1.1;
locks; strict;
comment	@ * @;


1.8
date	2012.08.23.06.21.52;	author deraadt;	state dead;
branches;
next	1.7;

1.7
date	2006.11.17.20.54.47;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2003.08.06.21.08.08;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2003.08.05.09.07.34;	author hin;	state Exp;
branches;
next	1.4;

1.4
date	2002.06.07.04.41.27;	author hin;	state Exp;
branches;
next	1.3;

1.3
date	2000.09.11.14.41.09;	author art;	state Exp;
branches;
next	1.2;

1.2
date	99.04.30.01.59.13;	author art;	state Exp;
branches;
next	1.1;

1.1
date	98.09.14.21.53.12;	author art;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.09.14.21.53.12;	author art;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.06.07.04.14.30;	author hin;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2003.08.05.08.21.04;	author hin;	state Exp;
branches;
next	;


desc
@@


1.8
log
@the afs src tree can go away
@
text
@/*
****************************************************************************
*        Copyright IBM Corporation 1988, 1989 - All Rights Reserved        *
*                                                                          *
* Permission to use, copy, modify, and distribute this software and its    *
* documentation for any purpose and without fee is hereby granted,         *
* provided that the above copyright notice appear in all copies and        *
* that both that copyright notice and this permission notice appear in     *
* supporting documentation, and that the name of IBM not be used in        *
* advertising or publicity pertaining to distribution of the software      *
* without specific, written prior permission.                              *
*                                                                          *
* IBM DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL *
* IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL IBM *
* BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY      *
* DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER  *
* IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING   *
* OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.    *
****************************************************************************
*/

/*******************************************************************\
* 								    *
* 	Information Technology Center				    *
* 	Carnegie-Mellon University				    *
* 								    *
* 	Bradley White and M. Satyanarayanan			    *
\*******************************************************************/

#include <sys/time.h>
#include <signal.h>
#include <lwp.h>
#include "preempt.h"

RCSID("$arla: preempt.c,v 1.9 2002/06/02 11:59:54 lha Exp $");

sig_atomic_t PRE_Block = 0;		/* used in lwp.c and process.s */

#ifdef HAVE_GETITIMER

static RETSIGTYPE
#if defined(AFS_POSIX_SIGNALS)
AlarmHandler(int sig)
#else
AlarmHandler(int sig, int code, struct sigcontext *scp)
#endif
{
#ifdef AFS_POSIX_SIGNALS
    sigset_t mask ;
#endif

    if (PRE_Block == 0 && lwp_cpptr->level == 0) {
	PRE_BeginCritical();
#if defined(AFS_POSIX_SIGNALS)
        sigemptyset(&mask);
        sigaddset(&mask, sig);
        sigprocmask(SIG_UNBLOCK, &mask, (sigset_t *)0);
#else
	sigsetmask(scp->sc_mask);
#endif
	LWP_DispatchProcess();
	PRE_EndCritical();
    }
    
}



int 
PRE_InitPreempt(struct timeval *slice)
{
    struct itimerval itv;
#ifdef AFS_POSIX_SIGNALS
    struct sigaction sa;
#else
    struct sigvec vec;
#endif

    if (lwp_cpptr == 0) return (LWP_EINIT);
    
    if (slice == 0) {
	itv.it_interval.tv_sec = itv.it_value.tv_sec = DEFAULTSLICE;
	itv.it_interval.tv_usec = itv.it_value.tv_usec = 0;
    } else {
	itv.it_interval = itv.it_value = *slice;
    }
    
#ifdef AFS_POSIX_SIGNALS
    sa.sa_handler = AlarmHandler;
#ifndef SA_NODEFER
#define SA_NODEFER 0
#endif
#ifdef SA_SIGINFO
    sa.sa_flags = SA_SIGINFO|SA_NODEFER;
#else
    sa.sa_flags = SA_NODEFER;
#endif

    if ((sigaction(SIGALRM, &sa, (struct sigaction *)0) == -1) ||
        (setitimer(ITIMER_REAL, &itv, (struct itimerval *) 0) == -1))
        return(LWP_ESYSTEM);
#else
    vec.sv_handler = AlarmHandler;
    vec.sv_mask = vec.sv_onstack = 0;

    if ((sigvec(SIGALRM, &vec, (struct sigvec *)0) == -1) ||
	(setitimer(ITIMER_REAL, &itv, (struct itimerval *) 0) == -1))
	return(LWP_ESYSTEM);
#endif

    return(LWP_SUCCESS);
}

int 
PRE_EndPreempt(void)
{
    struct itimerval itv;
#ifdef AFS_POSIX_SIGNALS
    struct sigaction sa;
#else
    struct sigvec vec;
#endif

    if (lwp_cpptr == 0) 
	return (LWP_EINIT);
    
    itv.it_value.tv_sec = itv.it_value.tv_usec = 0;

#ifdef AFS_POSIX_SIGNALS
    sa.sa_handler = SIG_DFL;
    sa.sa_flags=0;

    if ((setitimer(ITIMER_REAL, &itv, (struct itimerval *) 0) == -1) ||
        (sigaction(SIGALRM, &sa, (struct sigaction *)0) == -1))
        return(LWP_ESYSTEM);
#else
    vec.sv_handler = SIG_DFL;
    vec.sv_mask = vec.sv_onstack = 0;

    if ((setitimer(ITIMER_REAL, &itv, (struct itimerval *) 0) == -1) ||
	(sigvec(SIGALRM, &vec, (struct sigvec *)0) == -1))
	return(LWP_ESYSTEM);
#endif

    return(LWP_SUCCESS);
}

#else /* !HAVE_GETITIMER */

int 
PRE_InitPreempt(struct timeval *slice)
{
    return LWP_SUCCESS;
}

int 
PRE_EndPreempt(void)
{
    return LWP_SUCCESS;
}

#endif /* HAVE_GETITIMER */
@


1.7
log
@change PRE_Block to an int, which architectures like alpha can access
atomically. Adapt all the others (except s390 which is not fixed yet).

mips and hppa still do not work for some other reason.

testing by beck, ckuethe, todd, asm proofreading by miod
@
text
@@


1.6
log
@Remove some double semicolons (hmm, do two semis equal a maxi?).
I've skipped the GNU stuff for now.  From Patrick Latifi.
@
text
@d37 1
a37 1
char PRE_Block = 0;		/* used in lwp.c and process.s */
@


1.5
log
@Merge
@
text
@d137 1
a137 1
    vec.sv_handler = SIG_DFL;;
@


1.4
log
@merge
@
text
@d35 1
a35 1
RCSID("$KTH: preempt.c,v 1.7 2000/02/20 04:15:37 assar Exp $");
@


1.3
log
@New Arla userland from Arla between 0.34.2 and current in arla cvs.
Too many new features and fixes to mention here.
@
text
@d35 1
a35 1
RCSID("$Id: preempt.c,v 1.7 2000/02/20 04:15:37 assar Exp $");
@


1.2
log
@upgrade Arla to fresher code. Too many new features and bugfixes.
@
text
@a0 1
/*	$OpenBSD$	*/
d35 1
a35 1
RCSID("$KTH: preempt.c,v 1.6 1999/02/01 04:56:13 assar Exp $");
d39 1
d147 16
@


1.1
log
@Initial revision
@
text
@d33 1
a33 1
#include "lwp.h"
d36 1
a36 1
RCSID("$KTH: preempt.c,v 1.5 1998/02/06 03:18:30 art Exp $");
@


1.1.1.1
log
@Initial version of Arla, a free implementation of an AFS cache-manager.
(second try, hopefully into the correct repository this time)
@
text
@@


1.1.1.2
log
@Import of arla-0.35.7
@
text
@d1 1
d33 1
a33 1
#include <lwp.h>
d36 1
a36 1
RCSID("$KTH: preempt.c,v 1.7 2000/02/20 04:15:37 assar Exp $");
a39 1
#ifdef HAVE_GETITIMER
a146 16

#else /* !HAVE_GETITIMER */

int 
PRE_InitPreempt(struct timeval *slice)
{
    return LWP_SUCCESS;
}

int 
PRE_EndPreempt(void)
{
    return LWP_SUCCESS;
}

#endif /* HAVE_GETITIMER */
@


1.1.1.3
log
@Import of arla -current as of Aug 5 2003

ok todd@@ deraadt@@
@
text
@d35 1
a35 1
RCSID("$arla: preempt.c,v 1.9 2002/06/02 11:59:54 lha Exp $");
@


