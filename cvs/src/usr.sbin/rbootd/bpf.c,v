head	1.25;
access;
symbols
	OPENBSD_6_1:1.25.0.4
	OPENBSD_6_1_BASE:1.25
	OPENBSD_6_0:1.25.0.2
	OPENBSD_6_0_BASE:1.25
	OPENBSD_5_9:1.23.0.2
	OPENBSD_5_9_BASE:1.23
	OPENBSD_5_8:1.22.0.4
	OPENBSD_5_8_BASE:1.22
	OPENBSD_5_7:1.21.0.2
	OPENBSD_5_7_BASE:1.21
	OPENBSD_5_6:1.19.0.6
	OPENBSD_5_6_BASE:1.19
	OPENBSD_5_5:1.19.0.4
	OPENBSD_5_5_BASE:1.19
	OPENBSD_5_4:1.18.0.2
	OPENBSD_5_4_BASE:1.18
	OPENBSD_5_3:1.17.0.14
	OPENBSD_5_3_BASE:1.17
	OPENBSD_5_2:1.17.0.12
	OPENBSD_5_2_BASE:1.17
	OPENBSD_5_1_BASE:1.17
	OPENBSD_5_1:1.17.0.10
	OPENBSD_5_0:1.17.0.8
	OPENBSD_5_0_BASE:1.17
	OPENBSD_4_9:1.17.0.6
	OPENBSD_4_9_BASE:1.17
	OPENBSD_4_8:1.17.0.4
	OPENBSD_4_8_BASE:1.17
	OPENBSD_4_7:1.17.0.2
	OPENBSD_4_7_BASE:1.17
	OPENBSD_4_6:1.16.0.24
	OPENBSD_4_6_BASE:1.16
	OPENBSD_4_5:1.16.0.20
	OPENBSD_4_5_BASE:1.16
	OPENBSD_4_4:1.16.0.18
	OPENBSD_4_4_BASE:1.16
	OPENBSD_4_3:1.16.0.16
	OPENBSD_4_3_BASE:1.16
	OPENBSD_4_2:1.16.0.14
	OPENBSD_4_2_BASE:1.16
	OPENBSD_4_1:1.16.0.12
	OPENBSD_4_1_BASE:1.16
	OPENBSD_4_0:1.16.0.10
	OPENBSD_4_0_BASE:1.16
	OPENBSD_3_9:1.16.0.8
	OPENBSD_3_9_BASE:1.16
	OPENBSD_3_8:1.16.0.6
	OPENBSD_3_8_BASE:1.16
	OPENBSD_3_7:1.16.0.4
	OPENBSD_3_7_BASE:1.16
	OPENBSD_3_6:1.16.0.2
	OPENBSD_3_6_BASE:1.16
	OPENBSD_3_5:1.14.0.4
	OPENBSD_3_5_BASE:1.14
	OPENBSD_3_4:1.14.0.2
	OPENBSD_3_4_BASE:1.14
	OPENBSD_3_3:1.11.0.2
	OPENBSD_3_3_BASE:1.11
	OPENBSD_3_2:1.10.0.2
	OPENBSD_3_2_BASE:1.10
	OPENBSD_3_1:1.7.0.2
	OPENBSD_3_1_BASE:1.7
	OPENBSD_3_0:1.5.0.4
	OPENBSD_3_0_BASE:1.5
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_9:1.5.0.2
	OPENBSD_2_8:1.4.0.2
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.2.0.16
	OPENBSD_2_7_BASE:1.2
	OPENBSD_2_6:1.2.0.14
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.12
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.10
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.8
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.6
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.25
date	2016.05.28.07.00.18;	author natano;	state Exp;
branches;
next	1.24;
commitid	V3qpA476A18HvhDy;

1.24
date	2016.04.16.22.23.01;	author natano;	state Exp;
branches;
next	1.23;
commitid	qXZ1DSdBP7XtnShu;

1.23
date	2015.08.20.22.39.29;	author deraadt;	state Exp;
branches;
next	1.22;
commitid	z3HrihslRYb4HqW9;

1.22
date	2015.04.18.18.28.38;	author deraadt;	state Exp;
branches;
next	1.21;
commitid	6b2lLILbgCR1fvia;

1.21
date	2015.01.16.06.40.19;	author deraadt;	state Exp;
branches;
next	1.20;
commitid	Uu5nFG3wCl0LACBb;

1.20
date	2014.11.02.02.44.50;	author deraadt;	state Exp;
branches;
next	1.19;
commitid	tYaLFDvqFYrpULL4;

1.19
date	2013.11.28.18.26.46;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2013.04.20.20.12.10;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2009.10.27.23.59.54;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2004.05.10.20.50.21;	author canacar;	state Exp;
branches;
next	1.15;

1.15
date	2004.05.01.00.39.22;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2003.08.19.22.20.10;	author itojun;	state Exp;
branches;
next	1.13;

1.13
date	2003.08.19.22.19.07;	author itojun;	state Exp;
branches;
next	1.12;

1.12
date	2003.06.02.23.36.54;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2002.12.13.23.14.07;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2002.05.29.18.39.00;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2002.05.29.09.45.08;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2002.05.27.19.48.42;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2002.03.14.16.44.25;	author mpech;	state Exp;
branches;
next	1.6;

1.6
date	2002.02.19.21.04.09;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2001.01.17.00.33.03;	author pjanzen;	state Exp;
branches;
next	1.4;

1.4
date	2000.09.28.04.13.08;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	2000.06.28.23.55.47;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.11.16.14.23.28;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.48.02;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.48.02;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.25
log
@Replace the /dev/bpf* open loop with a plain open("/dev/bpf0", ...).
ok deraadt jca
@
text
@/*	$OpenBSD: bpf.c,v 1.24 2016/04/16 22:23:01 natano Exp $	*/
/*	$NetBSD: bpf.c,v 1.5.2.1 1995/11/14 08:45:42 thorpej Exp $	*/

/*
 * Copyright (c) 1988, 1992 The University of Utah and the Center
 *	for Software Science (CSS).
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * the Center for Software Science of the University of Utah Computer
 * Science Department.  CSS requests users of this software to return
 * to css-dist@@cs.utah.edu any improvements that they make and grant
 * CSS redistribution rights.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	from: @@(#)bpf.c	8.1 (Berkeley) 6/4/93
 *
 * From: Utah Hdr: bpf.c 3.1 92/07/06
 * Author: Jeff Forys, University of Utah CSS
 */

#include <sys/ioctl.h>
#include <sys/socket.h>

#include <net/if.h>
#include <net/bpf.h>

#include <ctype.h>
#include <errno.h>
#include <fcntl.h>
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <syslog.h>
#include <unistd.h>
#include <limits.h>
#include <ifaddrs.h>
#include "defs.h"

static int BpfFd = -1;
static unsigned int BpfLen = 0;
static u_int8_t *BpfPkt = NULL;

/*
**  BpfOpen -- Open and initialize a BPF device.
**
**	Parameters:
**		None.
**
**	Returns:
**		File descriptor of opened BPF device
**
**	Side Effects:
**		If an error is encountered, the program terminates here.
*/
int
BpfOpen(void)
{
	struct ifreq ifr;
	int n;

	if ((BpfFd = open("/dev/bpf0", O_RDWR)) == -1) {
		syslog(LOG_ERR, "bpf: can't open device: %m");
		DoExit();
	}

	/*
	 *  Set interface name for bpf device, get data link layer
	 *  type and make sure it's type Ethernet.
	 */
	(void) strncpy(ifr.ifr_name, IntfName, sizeof(ifr.ifr_name));
	if (ioctl(BpfFd, BIOCSETIF, (caddr_t)&ifr) < 0) {
		syslog(LOG_ERR, "bpf: ioctl(BIOCSETIF,%s): %m", IntfName);
		DoExit();
	}

	/*
	 *  Make sure we are dealing with an Ethernet device.
	 */
	if (ioctl(BpfFd, BIOCGDLT, (caddr_t)&n) < 0) {
		syslog(LOG_ERR, "bpf: ioctl(BIOCGDLT): %m");
		DoExit();
	}
	if (n != DLT_EN10MB) {
		syslog(LOG_ERR,"bpf: %s: data-link type %d unsupported",
		    IntfName, n);
		DoExit();
	}

	/*
	 *  On read(), return packets immediately (do not buffer them).
	 */
	n = 1;
	if (ioctl(BpfFd, BIOCIMMEDIATE, (caddr_t)&n) < 0) {
		syslog(LOG_ERR, "bpf: ioctl(BIOCIMMEDIATE): %m");
		DoExit();
	}

	/*
	 *  Try to enable the chip/driver's multicast address filter to
	 *  grab our RMP address.  If this fails, try promiscuous mode.
	 *  If this fails, there's no way we are going to get any RMP
	 *  packets so just exit here.
	 */
#ifdef MSG_EOR
	ifr.ifr_addr.sa_len = RMP_ADDRLEN + 2;
#endif
	ifr.ifr_addr.sa_family = AF_UNSPEC;
	bcopy(&RmpMcastAddr[0], (char *)&ifr.ifr_addr.sa_data[0], RMP_ADDRLEN);
	if (ioctl(BpfFd, SIOCADDMULTI, (caddr_t)&ifr) < 0) {
		syslog(LOG_WARNING,
		    "bpf: can't add mcast addr (%m), setting promiscuous mode");

		if (ioctl(BpfFd, BIOCPROMISC, (caddr_t)0) < 0) {
			syslog(LOG_ERR, "bpf: can't set promiscuous mode: %m");
			DoExit();
		}
	}

	/*
	 *  Ask BPF how much buffer space it requires and allocate one.
	 */
	if (ioctl(BpfFd, BIOCGBLEN, (caddr_t)&BpfLen) < 0) {
		syslog(LOG_ERR, "bpf: ioctl(BIOCGBLEN): %m");
		DoExit();
	}
	if (BpfPkt == NULL)
		BpfPkt = malloc(BpfLen);

	if (BpfPkt == NULL) {
		syslog(LOG_ERR, "bpf: out of memory (%u bytes for bpfpkt)",
		    BpfLen);
		DoExit();
	}

	/*
	 *  Write a little program to snarf RMP Boot packets and stuff
	 *  it down BPF's throat (i.e. set up the packet filter).
	 */
	{
#define	RMP(field)	offsetof(struct rmp_packet, field)
		static struct bpf_insn bpf_insn[] = {
		    /* make sure it is a 802.3 packet */
		    { BPF_LD|BPF_H|BPF_ABS,  0, 0, RMP(hp_hdr.len) },
		    { BPF_JMP|BPF_JGE|BPF_K, 7, 0, 0x600 },

		    { BPF_LD|BPF_B|BPF_ABS,  0, 0, RMP(hp_llc.dsap) },
		    { BPF_JMP|BPF_JEQ|BPF_K, 0, 5, IEEE_DSAP_HP },
		    { BPF_LD|BPF_H|BPF_ABS,  0, 0, RMP(hp_llc.cntrl) },
		    { BPF_JMP|BPF_JEQ|BPF_K, 0, 3, IEEE_CNTL_HP },
		    { BPF_LD|BPF_H|BPF_ABS,  0, 0, RMP(hp_llc.dxsap) },
		    { BPF_JMP|BPF_JEQ|BPF_K, 0, 1, HPEXT_DXSAP },
		    { BPF_RET|BPF_K,         0, 0, RMP_MAX_PACKET },
		    { BPF_RET|BPF_K,         0, 0, 0x0 }
		};

		static struct bpf_insn bpf_wf_insn[] = {
		    /* make sure it is a 802.3 packet */
		    { BPF_LD|BPF_H|BPF_ABS,  0, 0, RMP(hp_hdr.len) },
		    { BPF_JMP|BPF_JGE|BPF_K, 12, 0, 0x600 },

		    /* check the SNAP header */
		    { BPF_LD|BPF_B|BPF_ABS,  0, 0, RMP(hp_llc.dsap) },
		    { BPF_JMP|BPF_JEQ|BPF_K, 0, 10, IEEE_DSAP_HP },
		    { BPF_LD|BPF_H|BPF_ABS,  0, 0, RMP(hp_llc.cntrl) },
		    { BPF_JMP|BPF_JEQ|BPF_K, 0, 8, IEEE_CNTL_HP },

		    { BPF_LD|BPF_H|BPF_ABS,  0, 0, RMP(hp_llc.sxsap) },
		    { BPF_JMP|BPF_JEQ|BPF_K, 0, 6, HPEXT_DXSAP },
		    { BPF_LD|BPF_H|BPF_ABS,  0, 0, RMP(hp_llc.dxsap) },
		    { BPF_JMP|BPF_JEQ|BPF_K, 0, 4, HPEXT_SXSAP },

		    /* check return type code */
		    { BPF_LD|BPF_B|BPF_ABS,  0, 0,
		        RMP(rmp_proto.rmp_raw.rmp_type) },
		    { BPF_JMP|BPF_JEQ|BPF_K, 1, 0, RMP_BOOT_REPL },
		    { BPF_JMP|BPF_JEQ|BPF_K, 0, 1, RMP_READ_REPL },

		    { BPF_RET|BPF_K,         0, 0, RMP_MAX_PACKET },
		    { BPF_RET|BPF_K,         0, 0, 0x0 }
		};
#undef	RMP
		static struct bpf_program bpf_pgm = {
			sizeof(bpf_insn)/sizeof(bpf_insn[0]), bpf_insn
		};

		static struct bpf_program bpf_w_pgm = {
			sizeof(bpf_wf_insn)/sizeof(bpf_wf_insn[0]), bpf_wf_insn
		};

		if (ioctl(BpfFd, BIOCSETF, (caddr_t)&bpf_pgm) < 0) {
			syslog(LOG_ERR, "bpf: ioctl(BIOCSETF): %m");
			DoExit();
		}

		if (ioctl(BpfFd, BIOCSETWF, (caddr_t)&bpf_w_pgm) < 0) {
			syslog(LOG_ERR, "bpf: ioctl(BIOCSETWF): %m");
			DoExit();
		}

		if (ioctl(BpfFd, BIOCLOCK) < 0) {
			syslog(LOG_ERR, "bpf: ioctl(BIOCLOCK): %m");
			DoExit();
		}
	}

	return(BpfFd);
}

/*
**  BPF GetIntfName -- Return the name of a network interface attached to
**		the system, or 0 if none can be found.  The interface
**		must be configured up; the lowest unit number is
**		preferred; loopback is ignored.
**
**	Parameters:
**		errmsg - if no network interface found, *errmsg explains why.
**
**	Returns:
**		A (static) pointer to interface name, or NULL on error.
**
**	Side Effects:
**		None.
*/
char *
BpfGetIntfName(char **errmsg)
{
	int minunit = 999, n;
	char *cp;
	const char *errstr;
	static char device[IFNAMSIZ];
	static char errbuf[128] = "No Error!";
	struct ifaddrs *ifap, *ifa, *mp = NULL;

	if (errmsg != NULL)
		*errmsg = errbuf;

	if (getifaddrs(&ifap) != 0) {
		(void) strlcpy(errbuf, "bpf: getifaddrs: %m", sizeof(errbuf));
		return(NULL);
	}

	for (ifa = ifap; ifa; ifa = ifa->ifa_next) {
		/*
		 *  If interface is down or this is the loopback interface,
		 *  ignore it.
		 */
		if ((ifa->ifa_flags & IFF_UP) == 0 ||
#ifdef IFF_LOOPBACK
		    (ifa->ifa_flags & IFF_LOOPBACK))
#else
		    (strcmp(ifa->ifa_name, "lo0") == 0))
#endif
			continue;

		for (cp = ifa->ifa_name; !isdigit((unsigned char)*cp); ++cp)
			;
		n = strtonum(cp, 0, INT_MAX, &errstr);
		if (errstr == NULL && n < minunit) {
			minunit = n;
			mp = ifa;
		}
	}

	if (mp == 0) {
		(void) strlcpy(errbuf, "bpf: no interfaces found",
		    sizeof(errbuf));
		freeifaddrs(ifap);
		return(NULL);
	}

	(void) strlcpy(device, mp->ifa_name, sizeof device);
	freeifaddrs(ifap);
	return(device);
}

/*
**  BpfRead -- Read packets from a BPF device and fill in `rconn'.
**
**	Parameters:
**		rconn - filled in with next packet.
**		doread - is True if we can issue a read() syscall.
**
**	Returns:
**		True if `rconn' contains a new packet, False otherwise.
**
**	Side Effects:
**		None.
*/
int
BpfRead(RMPCONN *rconn, int doread)
{
	int datlen, caplen, hdrlen;
	static u_int8_t *bp = NULL, *ep = NULL;
	int cc;

	/*
	 *  The read() may block, or it may return one or more packets.
	 *  We let the caller decide whether or not we can issue a read().
	 */
	if (doread) {
		if ((cc = read(BpfFd, (char *)BpfPkt, (int)BpfLen)) < 0) {
			syslog(LOG_ERR, "bpf: read: %m");
			return(0);
		} else {
			bp = BpfPkt;
			ep = BpfPkt + cc;
		}
	}

#define bhp ((struct bpf_hdr *)bp)
	/*
	 *  If there is a new packet in the buffer, stuff it into `rconn'
	 *  and return a success indication.
	 */
	if (bp < ep) {
		datlen = bhp->bh_datalen;
		caplen = bhp->bh_caplen;
		hdrlen = bhp->bh_hdrlen;

		if (caplen != datlen)
			syslog(LOG_ERR,
			    "bpf: short packet dropped (%d of %d bytes)",
			    caplen, datlen);
		else if (caplen > sizeof(struct rmp_packet))
			syslog(LOG_ERR, "bpf: large packet dropped (%d bytes)",
			    caplen);
		else {
			rconn->rmplen = caplen;
			rconn->tstamp.tv_sec = bhp->bh_tstamp.tv_sec;
			rconn->tstamp.tv_usec = bhp->bh_tstamp.tv_usec;
			bcopy((char *)bp + hdrlen, (char *)&rconn->rmp, caplen);
		}
		bp += BPF_WORDALIGN(caplen + hdrlen);
		return(1);
	}
#undef bhp

	return(0);
}

/*
**  BpfWrite -- Write packet to BPF device.
**
**	Parameters:
**		rconn - packet to send.
**
**	Returns:
**		True if write succeeded, False otherwise.
**
**	Side Effects:
**		None.
*/
int
BpfWrite(RMPCONN *rconn)
{
	if (write(BpfFd, (char *)&rconn->rmp, rconn->rmplen) < 0) {
		syslog(LOG_ERR, "write: %s: %m", EnetStr(rconn));
		return(0);
	}

	return(1);
}
@


1.24
log
@Replace bcopy() from struct bpf_timeval to struct timeval; those
structures are not exchangeable. This should unbreak connection timeouts
in rbootd, although I can't verify due to lack of rboot-able hardware.
ok guenther millert
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf.c,v 1.23 2015/08/20 22:39:29 deraadt Exp $	*/
a63 1
#include "pathnames.h"
d85 1
a85 2
	char bpfdev[32];
	int n = 0;
d87 2
a88 10
	/*
	 *  Open the first available BPF device.
	 */
	do {
		(void) snprintf(bpfdev, sizeof bpfdev, _PATH_BPF, n++);
		BpfFd = open(bpfdev, O_RDWR);
	} while (BpfFd < 0 && (errno == EBUSY || errno == EPERM));

	if (BpfFd < 0) {
		syslog(LOG_ERR, "bpf: no available devices: %m");
@


1.23
log
@stdlib.h is in scope; do not cast malloc/calloc/realloc*
ok millert krw
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf.c,v 1.22 2015/04/18 18:28:38 deraadt Exp $	*/
d365 2
a366 2
			bcopy((char *)&bhp->bh_tstamp, (char *)&rconn->tstamp,
			    sizeof(struct timeval));
@


1.22
log
@Convert many atoi() calls to strtonum(), adding range checks and failure
handling along the way.
Reviews by Brendan MacDonell, Jeremy Devenport, florian, doug, millert
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf.c,v 1.21 2015/01/16 06:40:19 deraadt Exp $	*/
d163 1
a163 1
		BpfPkt = (u_int8_t *)malloc(BpfLen);
@


1.21
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf.c,v 1.20 2014/11/02 02:44:50 deraadt Exp $	*/
d61 1
d265 1
d293 2
a294 2
		n = atoi(cp);
		if (n < minunit) {
@


1.20
log
@remove bogus comment
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf.c,v 1.19 2013/11/28 18:26:46 deraadt Exp $	*/
a45 1
#include <sys/param.h>
@


1.19
log
@unsigned char for ctype
ok okan krw
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf.c,v 1.18 2013/04/20 20:12:10 miod Exp $	*/
d77 1
a77 1
**		File descriptor of opened BPF device (for select() etc).
@


1.18
log
@Use offsetof() instead of rolling our own; gets rid of truncation warnings
when building on 64-bit hosts.
"looks good" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf.c,v 1.17 2009/10/27 23:59:54 deraadt Exp $	*/
d290 1
a290 1
		for (cp = ifa->ifa_name; !isdigit(*cp); ++cp)
@


1.17
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf.c,v 1.16 2004/05/10 20:50:21 canacar Exp $	*/
d56 1
d176 1
a176 1
#define	RMP	((struct rmp_packet *)0)
d179 1
a179 1
		    { BPF_LD|BPF_H|BPF_ABS,  0, 0, (u_int32_t)&RMP->hp_hdr.len },
d182 1
a182 1
		    { BPF_LD|BPF_B|BPF_ABS,  0, 0, (u_int32_t)&RMP->hp_llc.dsap },
d184 1
a184 1
		    { BPF_LD|BPF_H|BPF_ABS,  0, 0, (u_int32_t)&RMP->hp_llc.cntrl },
d186 1
a186 1
		    { BPF_LD|BPF_H|BPF_ABS,  0, 0, (u_int32_t)&RMP->hp_llc.dxsap },
d194 1
a194 1
		    { BPF_LD|BPF_H|BPF_ABS,  0, 0, (u_int32_t)&RMP->hp_hdr.len },
d198 1
a198 1
		    { BPF_LD|BPF_B|BPF_ABS,  0, 0, (u_int32_t)&RMP->hp_llc.dsap },
d200 1
a200 1
		    { BPF_LD|BPF_H|BPF_ABS,  0, 0, (u_int32_t)&RMP->hp_llc.cntrl },
d203 1
a203 1
		    { BPF_LD|BPF_H|BPF_ABS,  0, 0, (u_int32_t)&RMP->hp_llc.sxsap },
d205 1
a205 1
		    { BPF_LD|BPF_H|BPF_ABS,  0, 0, (u_int32_t)&RMP->hp_llc.dxsap },
d210 1
a210 1
		        (u_int32_t)&RMP->rmp_proto.rmp_raw.rmp_type },
@


1.16
log
@write filter and lock bpf descriptor before dropping privileges,
with help from otto@@, tested by mickey@@ and jolan@@, ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf.c,v 1.15 2004/05/01 00:39:22 deraadt Exp $	*/
a44 5

#ifndef lint
/*static char sccsid[] = "@@(#)bpf.c	8.1 (Berkeley) 6/4/93";*/
static char rcsid[] = "$OpenBSD: bpf.c,v 1.15 2004/05/01 00:39:22 deraadt Exp $";
#endif /* not lint */
@


1.15
log
@priv revoking; tested by millert
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf.c,v 1.14 2003/08/19 22:20:10 itojun Exp $	*/
d48 1
a48 1
static char rcsid[] = "$OpenBSD: bpf.c,v 1.14 2003/08/19 22:20:10 itojun Exp $";
d182 5
a186 1
		    { BPF_LD|BPF_B|BPF_ABS,  0, 0, (long)&RMP->hp_llc.dsap },
d188 1
a188 1
		    { BPF_LD|BPF_H|BPF_ABS,  0, 0, (long)&RMP->hp_llc.cntrl },
d190 1
a190 1
		    { BPF_LD|BPF_H|BPF_ABS,  0, 0, (long)&RMP->hp_llc.dxsap },
d195 26
d226 4
d232 10
@


1.14
log
@one missing freeifaddrs
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf.c,v 1.13 2003/08/19 22:19:07 itojun Exp $	*/
d48 1
a48 1
static char rcsid[] = "$OpenBSD: bpf.c,v 1.13 2003/08/19 22:19:07 itojun Exp $";
d223 1
a223 1
	int minunit, n;
d227 1
a227 1
	struct ifaddrs *ifap, *ifa, *mp;
@


1.13
log
@rewrite SIOCGIFCONF into getifaddrs.  deraadt ok
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf.c,v 1.12 2003/06/02 23:36:54 millert Exp $	*/
d48 1
a48 1
static char rcsid[] = "$OpenBSD: bpf.c,v 1.12 2003/06/02 23:36:54 millert Exp $";
d262 1
@


1.12
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf.c,v 1.11 2002/12/13 23:14:07 deraadt Exp $	*/
d48 1
a48 1
static char rcsid[] = "$OpenBSD: bpf.c,v 1.11 2002/12/13 23:14:07 deraadt Exp $";
d66 1
a222 3
	struct ifreq ibuf[8], *ifrp, *ifend, *mp;
	struct ifconf ifc;
	int fd;
d225 1
a225 1
	static char device[sizeof(ifrp->ifr_name)];
d227 1
d232 2
a233 2
	if ((fd = socket(AF_INET, SOCK_DGRAM, 0)) < 0) {
		(void) strlcpy(errbuf, "bpf: socket: %m", sizeof(errbuf));
a235 29
	ifc.ifc_len = sizeof ibuf;
	ifc.ifc_buf = (caddr_t)ibuf;

#ifdef OSIOCGIFCONF
	if (ioctl(fd, OSIOCGIFCONF, (char *)&ifc) < 0 ||
	    ifc.ifc_len < sizeof(struct ifreq)) {
		(void) strlcpy(errbuf, "bpf: ioctl(OSIOCGIFCONF): %m",
		    sizeof (errbuf));
		return(NULL);
	}
#else
	if (ioctl(fd, SIOCGIFCONF, (char *)&ifc) < 0 ||
	    ifc.ifc_len < sizeof(struct ifreq)) {
		(void) strlcpy(errbuf, "bpf: ioctl(SIOCGIFCONF): %m",
		    sizeof(errbuf));
		return(NULL);
	}
#endif
	ifrp = ibuf;
	ifend = (struct ifreq *)((char *)ibuf + ifc.ifc_len);

	mp = 0;
	minunit = 666;
	for (; ifrp < ifend; ++ifrp) {
		if (ioctl(fd, SIOCGIFFLAGS, (char *)ifrp) < 0) {
			(void) strlcpy(errbuf, "bpf: ioctl(SIOCGIFFLAGS): %m",
			    sizeof(errbuf));
			return(NULL);
		}
d237 1
d242 1
a242 1
		if ((ifrp->ifr_flags & IFF_UP) == 0 ||
d244 1
a244 1
		    (ifrp->ifr_flags & IFF_LOOPBACK))
d246 1
a246 1
		    (strcmp(ifrp->ifr_name, "lo0") == 0))
d250 1
a250 1
		for (cp = ifrp->ifr_name; !isdigit(*cp); ++cp)
d255 1
a255 1
			mp = ifrp;
a258 1
	(void) close(fd);
d265 2
a266 1
	(void) strlcpy(device, mp->ifr_name, sizeof device);
@


1.11
log
@ansi & knf
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf.c,v 1.10 2002/05/29 18:39:00 deraadt Exp $	*/
d24 1
a24 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d48 1
a48 1
static char rcsid[] = "$OpenBSD: bpf.c,v 1.10 2002/05/29 18:39:00 deraadt Exp $";
@


1.10
log
@more strlcat and strlcpy
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf.c,v 1.9 2002/05/29 09:45:08 deraadt Exp $	*/
d52 1
a52 1
static char rcsid[] = "$OpenBSD: bpf.c,v 1.9 2002/05/29 09:45:08 deraadt Exp $";
d90 1
a90 1
BpfOpen()
d128 1
a128 1
		       IntfName, n);
d174 1
a174 1
		       BpfLen);
d196 1
a196 1
		    sizeof(bpf_insn)/sizeof(bpf_insn[0]), bpf_insn
d224 1
a224 2
BpfGetIntfName(errmsg)
	char **errmsg;
d261 1
a261 1
	
d317 1
a317 3
BpfRead(rconn, doread)
	RMPCONN *rconn;
	int doread;
d349 2
a350 2
			       "bpf: short packet dropped (%d of %d bytes)",
			       caplen, datlen);
d353 1
a353 1
			       caplen);
d357 1
a357 1
			      sizeof(struct timeval));
d381 1
a381 2
BpfWrite(rconn)
	RMPCONN *rconn;
@


1.9
log
@more sprintf
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf.c,v 1.8 2002/05/27 19:48:42 deraadt Exp $	*/
d52 1
a52 1
static char rcsid[] = "$OpenBSD: bpf.c,v 1.8 2002/05/27 19:48:42 deraadt Exp $";
d300 1
a300 1
	(void) strcpy(device, mp->ifr_name);
@


1.8
log
@unsigned to unsigned int
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf.c,v 1.7 2002/03/14 16:44:25 mpech Exp $	*/
d52 1
a52 1
static char rcsid[] = "$OpenBSD: bpf.c,v 1.7 2002/03/14 16:44:25 mpech Exp $";
d100 1
a100 1
		(void) sprintf(bpfdev, _PATH_BPF, n++);
@


1.7
log
@kill more registers.

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf.c,v 1.6 2002/02/19 21:04:09 miod Exp $	*/
d52 1
a52 1
static char rcsid[] = "$OpenBSD: bpf.c,v 1.6 2002/02/19 21:04:09 miod Exp $";
d74 1
a74 1
static unsigned BpfLen = 0;
@


1.6
log
@Fix the signal races in rbootd.
Credit to millert@@ and deraadt@@ for pointing out some of my braindamage.
@
text
@d1 1
a1 1
/*	$OpenBSD: bpf.c,v 1.5 2001/01/17 00:33:03 pjanzen Exp $	*/
d52 1
a52 1
static char rcsid[] = "$OpenBSD: bpf.c,v 1.5 2001/01/17 00:33:03 pjanzen Exp $";
d322 1
a322 1
	register int datlen, caplen, hdrlen;
@


1.5
log
@OpenBSD-ify.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d52 1
a52 1
static char rcsid[] = "$OpenBSD$";
d106 1
a106 1
		Exit(0);
d116 1
a116 1
		Exit(0);
d124 1
a124 1
		Exit(0);
d129 1
a129 1
		Exit(0);
d138 1
a138 1
		Exit(0);
d158 1
a158 1
			Exit(0);
d167 1
a167 1
		Exit(0);
d175 1
a175 1
		Exit(0);
d201 1
a201 1
			Exit(0);
a392 37
}

/*
**  BpfClose -- Close a BPF device.
**
**	Parameters:
**		None.
**
**	Returns:
**		Nothing.
**
**	Side Effects:
**		None.
*/
void
BpfClose()
{
	struct ifreq ifr;

	if (BpfPkt != NULL) {
		free((char *)BpfPkt);
		BpfPkt = NULL;
	}

	if (BpfFd == -1)
		return;

#ifdef MSG_EOR
	ifr.ifr_addr.sa_len = RMP_ADDRLEN + 2;
#endif
	ifr.ifr_addr.sa_family = AF_UNSPEC;
	bcopy(&RmpMcastAddr[0], (char *)&ifr.ifr_addr.sa_data[0], RMP_ADDRLEN);
	if (ioctl(BpfFd, SIOCDELMULTI, (caddr_t)&ifr) < 0)
		(void) ioctl(BpfFd, BIOCPROMISC, (caddr_t)0);

	(void) close(BpfFd);
	BpfFd = -1;
@


1.4
log
@according to the strlcpy man page the order of arguments
is: destination, source, size.
it seems in the commit of version 1.3 a couple of maxwell daemons
of the second kind exchanged second and third arguments in every
call to the stlcpy, thanks gcc.
at this late hour we hope they are up to their eternity-spanning
poker game for hot molecules and the diff will finally get in untampered.
@
text
@d1 1
d52 1
a52 1
static char rcsid[] = "$NetBSD: bpf.c,v 1.5.2.1 1995/11/14 08:45:42 thorpej Exp $";
@


1.3
log
@buf oflow safe
@
text
@d238 1
a238 1
		(void) strlcpy(errbuf, sizeof(errbuf), "bpf: socket: %m");
d247 2
a248 2
		(void) strlcpy(errbuf, sizeof (errbuf),
		    "bpf: ioctl(OSIOCGIFCONF): %m");
d254 2
a255 2
		(void) strlcpy(errbuf, sizeof(errbuf),
		    "bpf: ioctl(SIOCGIFCONF): %m");
d266 2
a267 2
			(void) strlcpy(errbuf, sizeof(errbuf),
			    "bpf: ioctl(SIOCGIFFLAGS): %m");
d294 2
a295 2
		(void) strlcpy(errbuf, sizeof(errbuf),
		    "bpf: no interfaces found");
@


1.2
log
@repair byte order botches; from scottr@@plexus.com via netbsd
@
text
@d238 1
a238 1
		(void) strcpy(errbuf, "bpf: socket: %m");
d247 2
a248 1
		(void) strcpy(errbuf, "bpf: ioctl(OSIOCGIFCONF): %m");
d254 2
a255 1
		(void) strcpy(errbuf, "bpf: ioctl(SIOCGIFCONF): %m");
d266 2
a267 1
			(void) strcpy(errbuf, "bpf: ioctl(SIOCGIFFLAGS): %m");
d294 2
a295 1
		(void) strcpy(errbuf, "bpf: no interfaces found");
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: bpf.c,v 1.5 1995/10/06 05:12:12 thorpej Exp $	*/
d51 1
a51 1
static char rcsid[] = "$NetBSD: bpf.c,v 1.5 1995/10/06 05:12:12 thorpej Exp $";
d353 1
a353 1
			rconn->rmplen = htons(caplen);
d382 1
a382 1
	if (write(BpfFd, (char *)&rconn->rmp, ntohs(rconn->rmplen)) < 0) {
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
