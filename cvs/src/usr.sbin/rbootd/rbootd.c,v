head	1.31;
access;
symbols
	OPENBSD_6_2_BASE:1.31
	OPENBSD_6_1:1.31.0.6
	OPENBSD_6_1_BASE:1.31
	OPENBSD_6_0:1.31.0.2
	OPENBSD_6_0_BASE:1.31
	OPENBSD_5_9:1.29.0.2
	OPENBSD_5_9_BASE:1.29
	OPENBSD_5_8:1.26.0.6
	OPENBSD_5_8_BASE:1.26
	OPENBSD_5_7:1.26.0.2
	OPENBSD_5_7_BASE:1.26
	OPENBSD_5_6:1.25.0.4
	OPENBSD_5_6_BASE:1.25
	OPENBSD_5_5:1.24.0.6
	OPENBSD_5_5_BASE:1.24
	OPENBSD_5_4:1.24.0.2
	OPENBSD_5_4_BASE:1.24
	OPENBSD_5_3:1.23.0.14
	OPENBSD_5_3_BASE:1.23
	OPENBSD_5_2:1.23.0.12
	OPENBSD_5_2_BASE:1.23
	OPENBSD_5_1_BASE:1.23
	OPENBSD_5_1:1.23.0.10
	OPENBSD_5_0:1.23.0.8
	OPENBSD_5_0_BASE:1.23
	OPENBSD_4_9:1.23.0.6
	OPENBSD_4_9_BASE:1.23
	OPENBSD_4_8:1.23.0.4
	OPENBSD_4_8_BASE:1.23
	OPENBSD_4_7:1.23.0.2
	OPENBSD_4_7_BASE:1.23
	OPENBSD_4_6:1.22.0.18
	OPENBSD_4_6_BASE:1.22
	OPENBSD_4_5:1.22.0.14
	OPENBSD_4_5_BASE:1.22
	OPENBSD_4_4:1.22.0.12
	OPENBSD_4_4_BASE:1.22
	OPENBSD_4_3:1.22.0.10
	OPENBSD_4_3_BASE:1.22
	OPENBSD_4_2:1.22.0.8
	OPENBSD_4_2_BASE:1.22
	OPENBSD_4_1:1.22.0.6
	OPENBSD_4_1_BASE:1.22
	OPENBSD_4_0:1.22.0.4
	OPENBSD_4_0_BASE:1.22
	OPENBSD_3_9:1.22.0.2
	OPENBSD_3_9_BASE:1.22
	OPENBSD_3_8:1.21.0.2
	OPENBSD_3_8_BASE:1.21
	OPENBSD_3_7:1.20.0.4
	OPENBSD_3_7_BASE:1.20
	OPENBSD_3_6:1.20.0.2
	OPENBSD_3_6_BASE:1.20
	OPENBSD_3_5:1.19.0.2
	OPENBSD_3_5_BASE:1.19
	OPENBSD_3_4:1.18.0.2
	OPENBSD_3_4_BASE:1.18
	OPENBSD_3_3:1.16.0.2
	OPENBSD_3_3_BASE:1.16
	OPENBSD_3_2:1.15.0.2
	OPENBSD_3_2_BASE:1.15
	OPENBSD_3_1:1.13.0.2
	OPENBSD_3_1_BASE:1.13
	OPENBSD_3_0:1.8.0.2
	OPENBSD_3_0_BASE:1.8
	OPENBSD_2_9_BASE:1.7
	OPENBSD_2_9:1.7.0.2
	OPENBSD_2_8:1.5.0.2
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.3.0.12
	OPENBSD_2_7_BASE:1.3
	OPENBSD_2_6:1.3.0.10
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.8
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.6
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.4
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.2
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.2.0.2
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.31
date	2016.05.29.02.19.02;	author guenther;	state Exp;
branches;
next	1.30;
commitid	pgcZb8G1dK0hLp5M;

1.30
date	2016.03.16.15.41.11;	author krw;	state Exp;
branches;
next	1.29;
commitid	JEVxsRygqcjPtWTf;

1.29
date	2016.01.25.21.31.38;	author gsoares;	state Exp;
branches;
next	1.28;
commitid	bCskmXx6v862u7Nn;

1.28
date	2015.10.26.10.08.14;	author jung;	state Exp;
branches;
next	1.27;
commitid	HllzbCvumEtKpBqi;

1.27
date	2015.10.26.09.57.55;	author deraadt;	state Exp;
branches;
next	1.26;
commitid	lT6pbS5V0UKyyVn8;

1.26
date	2015.01.16.06.40.19;	author deraadt;	state Exp;
branches;
next	1.25;
commitid	Uu5nFG3wCl0LACBb;

1.25
date	2014.05.17.21.37.51;	author chl;	state Exp;
branches;
next	1.24;

1.24
date	2013.04.20.20.11.41;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2009.10.27.23.59.54;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2005.09.22.14.24.51;	author jmc;	state Exp;
branches;
next	1.21;

1.21
date	2005.05.03.01.01.14;	author djm;	state Exp;
branches;
next	1.20;

1.20
date	2004.05.01.00.39.22;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2004.01.23.03.48.43;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2003.06.27.22.34.25;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2003.06.02.23.36.54;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2002.12.13.23.14.07;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2002.07.16.23.38.52;	author mickey;	state Exp;
branches;
next	1.14;

1.14
date	2002.06.11.18.49.18;	author hin;	state Exp;
branches;
next	1.13;

1.13
date	2002.03.14.16.44.25;	author mpech;	state Exp;
branches;
next	1.12;

1.12
date	2002.02.20.02.00.01;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2002.02.19.21.04.09;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2002.02.19.18.38.02;	author mpech;	state Exp;
branches;
next	1.9;

1.9
date	2001.12.01.23.27.23;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2001.09.04.23.35.59;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2001.01.19.17.53.18;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2001.01.17.00.33.03;	author pjanzen;	state Exp;
branches;
next	1.5;

1.5
date	2000.10.03.03.12.16;	author aaron;	state Exp;
branches;
next	1.4;

1.4
date	2000.06.28.23.56.18;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	97.09.12.04.07.21;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.01.15.23.44.16;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.48.03;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.48.03;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.31
log
@Delete blocking/unblocking of signals, as the handlers now just set flags
that are tested by the main loop.

ok jca@@ deraadt@@
@
text
@/*	$OpenBSD: rbootd.c,v 1.30 2016/03/16 15:41:11 krw Exp $	*/
/*	$NetBSD: rbootd.c,v 1.5 1995/10/06 05:12:17 thorpej Exp $	*/

/*
 * Copyright (c) 1988, 1992 The University of Utah and the Center
 *	for Software Science (CSS).
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * the Center for Software Science of the University of Utah Computer
 * Science Department.  CSS requests users of this software to return
 * to css-dist@@cs.utah.edu any improvements that they make and grant
 * CSS redistribution rights.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	from: @@(#)rbootd.c	8.1 (Berkeley) 6/4/93
 *
 * From: Utah Hdr: rbootd.c 3.1 92/07/06
 * Author: Jeff Forys, University of Utah CSS
 */

#include <sys/time.h>

#include <err.h>
#include <errno.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <syslog.h>
#include <unistd.h>
#include <limits.h>
#include <pwd.h>
#include <poll.h>

#include "defs.h"

extern	char *__progname;	/* from crt0.o */

volatile sig_atomic_t	dodebugoff;
volatile sig_atomic_t	dodebugon;
volatile sig_atomic_t	doreconfig;

void DebugOff(int);
void DebugOn(int);
void ReConfig(int);
void Exit(int);

void DoDebugOff(void);
void DoDebugOn(void);
void DoReConfig(void);

void DoTimeout(void);
CLIENT *FindClient(RMPCONN *);

int
main(int argc, char *argv[])
{
	int c, fd;
	struct passwd *pw;
	struct pollfd pfd[1];

	closefrom(STDERR_FILENO + 1);

	if ((pw = getpwnam("_rbootd")) == NULL)
		err(1, "getpwnam");

	while ((c = getopt(argc, argv, "adi:")) != -1)
		switch (c) {
		case 'a':
			BootAny++;
			break;
		case 'd':
			DebugFlg++;
			break;
		case 'i':
			IntfName = optarg;
			break;
		}
	for (; optind < argc; optind++) {
		if (ConfigFile == NULL)
			ConfigFile = argv[optind];
		else {
			warnx("too many config files (`%s' ignored)",
			    argv[optind]);
		}
	}

	if (ConfigFile == NULL)			/* use default config file */
		ConfigFile = DfltConfig;

	if (DebugFlg) {
		DbgFp = stdout;				/* output to stdout */

		(void) signal(SIGUSR1, SIG_IGN);	/* dont muck w/DbgFp */
		(void) signal(SIGUSR2, SIG_IGN);
		(void) fclose(stderr);			/* finished with it */
	} else {
		if (daemon(0, 0))
			err(1, "can't detach from terminal");

		(void) signal(SIGUSR1, DebugOn);
		(void) signal(SIGUSR2, DebugOff);
	}

	/*
	 *  If no interface was specified, get one now.
	 *
	 *  This is convoluted because we want to get the default interface
	 *  name for the syslog("restarted") message.  If BpfGetIntfName()
	 *  runs into an error, it will return a syslog-able error message
	 *  (in `errmsg') which will be displayed here.
	 */
	if (IntfName == NULL) {
		char *errmsg;

		if ((IntfName = BpfGetIntfName(&errmsg)) == NULL) {
			/* BpfGetIntfName() returns safe names, using %m */
			syslog(LOG_ERR, "%s", errmsg);
			DoExit();
		}
	}

	openlog(__progname, LOG_PID, LOG_DAEMON);
	fd = BpfOpen();
	syslog(LOG_NOTICE, "restarted (%s)", IntfName);

	(void) signal(SIGHUP, ReConfig);
	(void) signal(SIGINT, Exit);
	(void) signal(SIGTERM, Exit);

	gethostname(MyHost, HOST_NAME_MAX+1);

	/*
	 *  All boot files are relative to the boot directory, we might
	 *  as well chdir() there to make life easier.
	 */
	if (chdir(BootDir) < 0) {
		syslog(LOG_ERR, "chdir: %m (%s)", BootDir);
		DoExit();
	}

	/*
	 *  Initial configuration.
	 */
	if (GetBootFiles() == 0)		/* get list of boot files */
		DoExit();
	if (ParseConfig() == 0)			/* parse config file */
		DoExit();

	if (chroot(BootDir) == -1) {
		syslog(LOG_CRIT, "chroot %s: %m", BootDir);
		exit(1);
	}
	if (chdir("/") == -1) {
		syslog(LOG_CRIT, "chdir(\"/\"): %m");
		exit(1);
	}
	if (setgroups(1, &pw->pw_gid) ||
	    setresgid(pw->pw_gid, pw->pw_gid, pw->pw_gid) ||
	    setresuid(pw->pw_uid, pw->pw_uid, pw->pw_uid)) {
		syslog(LOG_CRIT, "can't drop privileges: %m");
		exit(1);
	}
	endpwent();

	/*
	 *  Main loop: receive a packet, determine where it came from,
	 *  and if we service this host, call routine to handle request.
	 */
	pfd[0].fd = fd;
	pfd[0].events = POLLIN;
	for (;;) {
		int nsel;

		/*
		 * Check pending actions
		 */
		if (dodebugoff) {
			DoDebugOff();
			dodebugoff = 0;
		}
		if (dodebugon) {
			DoDebugOn();
			dodebugon = 0;
		}
		if (doreconfig) {
			DoReConfig();
			doreconfig = 0;
		}

		nsel = poll(pfd, 1, RmpConns ? RMP_TIMEOUT * 100 : -1);

		if (nsel < 0) {
			if (errno == EINTR)
				continue;
			syslog(LOG_ERR, "poll: %m");
			DoExit();
		} else if (nsel == 0) {		/* timeout */
			DoTimeout();		/* clear stale conns */
			continue;
		}

		if (pfd[0].revents & POLLIN) {
			RMPCONN rconn;
			CLIENT *client;
			int doread = 1;

			while (BpfRead(&rconn, doread)) {
				doread = 0;

				if (DbgFp != NULL)	/* display packet */
					DispPkt(&rconn,DIR_RCVD);

				/*
				 *  If we do not restrict service, set the
				 *  client to NULL (ProcessPacket() handles
				 *  this).  Otherwise, check that we can
				 *  service this host; if not, log a message
				 *  and ignore the packet.
				 */
				if (BootAny) {
					client = NULL;
				} else if ((client=FindClient(&rconn))==NULL) {
					syslog(LOG_INFO,
					    "%s: boot packet ignored",
					    EnetStr(&rconn));
					continue;
				}

				ProcessPacket(&rconn,client);
			}
		}
	}
}

/*
**  DoTimeout -- Free any connections that have timed out.
**
**	Parameters:
**		None.
**
**	Returns:
**		Nothing.
**
**	Side Effects:
**		- Timed out connections in `RmpConns' will be freed.
*/
void
DoTimeout(void)
{
	RMPCONN *rtmp;
	struct timeval now;

	(void) gettimeofday(&now, NULL);

	/*
	 *  For each active connection, if RMP_TIMEOUT seconds have passed
	 *  since the last packet was sent, delete the connection.
	 */
	for (rtmp = RmpConns; rtmp != NULL; rtmp = rtmp->next)
		if ((rtmp->tstamp.tv_sec + RMP_TIMEOUT) < now.tv_sec) {
			syslog(LOG_WARNING, "%s: connection timed out (%u)",
			    EnetStr(rtmp), rtmp->rmp.r_type);
			RemoveConn(rtmp);
		}
}

/*
**  FindClient -- Find client associated with a packet.
**
**	Parameters:
**		rconn - the new packet.
**
**	Returns:
**		Pointer to client info if found, NULL otherwise.
**
**	Side Effects:
**		None.
**
**	Warnings:
**		- This routine must be called with SIGHUP blocked since
**		  a reconfigure can invalidate the information returned.
*/
CLIENT *
FindClient(RMPCONN *rconn)
{
	CLIENT *ctmp;

	for (ctmp = Clients; ctmp != NULL; ctmp = ctmp->next)
		if (bcmp((char *)&rconn->rmp.hp_hdr.saddr[0],
		    (char *)&ctmp->addr[0], RMP_ADDRLEN) == 0)
			break;

	return(ctmp);
}

/*
**  Exit -- Log an error message and exit.
**
**	Parameters:
**		sig - caught signal (or zero if not dying on a signal).
**
**	Returns:
**		Does not return.
**
**	Side Effects:
**		- This process ceases to exist.
*/
void
Exit(int sig)
{
	struct syslog_data sdata = SYSLOG_DATA_INIT;

	syslog_r(LOG_ERR, &sdata, "going down on signal %d", sig);
	_exit(1);
}

void
DoExit(void)
{
	syslog(LOG_ERR, "going down on fatal error");
	exit(1);
}

/*
**  ReConfig -- Get new list of boot files and reread config files.
**
**	Parameters:
**		None.
**
**	Returns:
**		Nothing.
**
**	Side Effects:
**		- All active connections are dropped.
**		- List of bootable files is changed.
**		- List of clients is changed.
**
**	Warnings:
**		- This routine must be called with SIGHUP blocked.
*/
void
ReConfig(int signo)
{
	doreconfig = 1;
}

void
DoReConfig(void)
{
	syslog(LOG_NOTICE, "reconfiguring boot server");

	FreeConns();

	if (GetBootFiles() == 0)
		DoExit();

	if (ParseConfig() == 0)
		DoExit();
}

/*
**  DebugOff -- Turn off debugging.
**
**	Parameters:
**		None.
**
**	Returns:
**		Nothing.
**
**	Side Effects:
**		- Debug file is closed.
*/
void
DebugOff(int signo)
{
	dodebugoff = 1;
}

void
DoDebugOff(void)
{
	if (DbgFp != NULL)
		(void) fclose(DbgFp);

	DbgFp = NULL;
}

/*
**  DebugOn -- Turn on debugging.
**
**	Parameters:
**		None.
**
**	Returns:
**		Nothing.
**
**	Side Effects:
**		- Debug file is opened/truncated if not already opened,
**		  otherwise do nothing.
*/
void
DebugOn(int signo)
{
	dodebugon = 1;
}

void
DoDebugOn(void)
{
	if (DbgFp == NULL) {
		if ((DbgFp = fopen(DbgFile, "w")) == NULL)
			syslog(LOG_ERR, "can't open debug file (%s)", DbgFile);
	}
}
@


1.30
log
@More "(<blah> *)0" -> NULL, avoiding any stdarg functions.

Feedback millert@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rbootd.c,v 1.29 2016/01/25 21:31:38 gsoares Exp $	*/
a47 1
#include <ctype.h>
a49 1
#include <fcntl.h>
a83 1
	sigset_t hmask, omask;
a169 3
	sigemptyset(&hmask);
	sigaddset(&hmask, SIGHUP);
	sigprocmask(SIG_BLOCK, &hmask, &omask);	/* prevent reconfig's */
a190 2
	sigprocmask(SIG_SETMASK, &omask, NULL);	/* allow reconfig's */

a238 2
				sigprocmask(SIG_BLOCK, &hmask, &omask);

a251 1
					sigprocmask(SIG_SETMASK, &omask, NULL);
a255 2

				sigprocmask(SIG_SETMASK, &omask, NULL);
@


1.29
log
@remove pointless log message; As a bonus avoid trigraph '??'

suggested by & OK claudio@@
OK daniel@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rbootd.c,v 1.28 2015/10/26 10:08:14 jung Exp $	*/
d292 1
a292 1
	(void) gettimeofday(&now, (struct timezone *)0);
@


1.28
log
@remove util.h include and -lutil after pidfile removal

ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: rbootd.c,v 1.27 2015/10/26 09:57:55 deraadt Exp $	*/
a144 1
			syslog(LOG_NOTICE, "restarted (??)");
@


1.27
log
@stop using pidfile()
ok benno jung jca
@
text
@d1 1
a1 1
/*	$OpenBSD: rbootd.c,v 1.26 2015/01/16 06:40:19 deraadt Exp $	*/
a58 1
#include <util.h>
@


1.26
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: rbootd.c,v 1.25 2014/05/17 21:37:51 chl Exp $	*/
a161 3

	if (pidfile(NULL) < 0)
		syslog(LOG_WARNING, "pidfile: failed");
@


1.25
log
@remove unused variables

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rbootd.c,v 1.24 2013/04/20 20:11:41 deraadt Exp $	*/
a45 1
#include <sys/param.h>
d58 1
d161 1
a161 1
	gethostname(MyHost, MAXHOSTNAMELEN);
@


1.24
log
@replace select with poll
ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: rbootd.c,v 1.23 2009/10/27 23:59:54 deraadt Exp $	*/
d86 1
a86 1
	int c, fd, maxfds;
a210 1
		struct timeval timeout;
@


1.23
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: rbootd.c,v 1.22 2005/09/22 14:24:51 jmc Exp $	*/
d61 1
d89 1
a89 1
	fd_set rset;
d208 2
a209 3
	maxfds = fd + 1;
	FD_ZERO(&rset);
	FD_SET(fd, &rset);
a211 1
		fd_set r;
d230 1
a230 9
		r = rset;

		if (RmpConns == NULL) {		/* timeout isnt necessary */
			nsel = select(maxfds, &r, NULL, NULL, NULL);
		} else {
			timeout.tv_sec = RMP_TIMEOUT;
			timeout.tv_usec = 0;
			nsel = select(maxfds, &r, NULL, NULL, &timeout);
		}
d235 1
a235 1
			syslog(LOG_ERR, "select: %m");
d242 1
a242 1
		if (FD_ISSET(fd, &r)) {
@


1.22
log
@boot-able -> bootable (typo fix in comments only)
from janne johansson (pr #4516)
@
text
@d1 1
a1 1
/*	$OpenBSD: rbootd.c,v 1.21 2005/05/03 01:01:14 djm Exp $	*/
a44 11

#ifndef lint
static char copyright[] =
"@@(#) Copyright (c) 1992, 1993\n\
	The Regents of the University of California.  All rights reserved.\n";
#endif /* not lint */

#ifndef lint
/*static char sccsid[] = "@@(#)rbootd.c	8.1 (Berkeley) 6/4/93";*/
static char rcsid[] = "$OpenBSD: rbootd.c,v 1.21 2005/05/03 01:01:14 djm Exp $";
#endif /* not lint */
@


1.21
log
@more setres[ug]id; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rbootd.c,v 1.20 2004/05/01 00:39:22 deraadt Exp $	*/
d54 1
a54 1
static char rcsid[] = "$OpenBSD: rbootd.c,v 1.20 2004/05/01 00:39:22 deraadt Exp $";
d400 1
a400 1
**		- List of boot-able files is changed.
@


1.20
log
@priv revoking; tested by millert
@
text
@d1 1
a1 1
/*	$OpenBSD: rbootd.c,v 1.19 2004/01/23 03:48:43 deraadt Exp $	*/
d54 1
a54 1
static char rcsid[] = "$OpenBSD: rbootd.c,v 1.19 2004/01/23 03:48:43 deraadt Exp $";
d205 2
a206 2
	    setegid(pw->pw_gid) || setgid(pw->pw_gid) ||
	    seteuid(pw->pw_uid) || setuid(pw->pw_uid)) {
@


1.19
log
@Use closefrom(); ok millert tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: rbootd.c,v 1.18 2003/06/27 22:34:25 deraadt Exp $	*/
d54 1
a54 1
static char rcsid[] = "$OpenBSD: rbootd.c,v 1.18 2003/06/27 22:34:25 deraadt Exp $";
d71 1
d97 2
a99 1
	sigset_t hmask, omask;
a100 5
	/*
	 *  Close any open file descriptors.
	 *  Temporarily leave stdin & stdout open for `-d',
	 *  and stderr open for any pre-syslog error messages.
	 */
d103 3
a105 3
	/*
	 *  Parse any arguments.
	 */
a143 2
	openlog(__progname, LOG_PID, LOG_DAEMON);

d163 2
d171 1
a171 7
	/*
	 *  Grab our host name and pid.
	 */
	if (gethostname(MyHost, MAXHOSTNAMELEN) < 0) {
		syslog(LOG_ERR, "gethostname: %m");
		DoExit();
	}
d173 1
a173 4
	/*
	 *  Write proc's pid to a file.
	 */
	if (pidfile(NULL) < 0) {
a174 1
	}
d196 15
a210 6
	/*
	 *  Open and initialize a BPF device for the appropriate interface.
	 *  If an error is encountered, a message is displayed and DoExit()
	 *  is called.
	 */
	fd = BpfOpen();
d258 1
a258 1
			DoTimeout();			/* clear stale conns */
@


1.18
log
@remove unneeded proto
@
text
@d1 1
a1 1
/*	$OpenBSD: rbootd.c,v 1.17 2003/06/02 23:36:54 millert Exp $	*/
d54 1
a54 1
static char rcsid[] = "$OpenBSD: rbootd.c,v 1.17 2003/06/02 23:36:54 millert Exp $";
d104 1
a104 8
	{
		int i, nfds = getdtablesize();

		for (i = 0; i < nfds; i++)
			if (i != fileno(stdin) && i != fileno(stdout) &&
			    i != fileno(stderr))
				(void) close(i);
	}
@


1.17
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: rbootd.c,v 1.16 2002/12/13 23:14:07 deraadt Exp $	*/
d54 1
a54 1
static char rcsid[] = "$OpenBSD: rbootd.c,v 1.16 2002/12/13 23:14:07 deraadt Exp $";
d275 1
a275 1
			CLIENT *client, *FindClient();
@


1.16
log
@ansi & knf
@
text
@d1 1
a1 1
/*	$OpenBSD: rbootd.c,v 1.15 2002/07/16 23:38:52 mickey Exp $	*/
d24 1
a24 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d54 1
a54 1
static char rcsid[] = "$OpenBSD: rbootd.c,v 1.15 2002/07/16 23:38:52 mickey Exp $";
@


1.15
log
@no need to terminate the buffer after gethostname, especially by overwriting unrelated memory; maybe test the changes next time
@
text
@d1 1
a1 1
/*	$OpenBSD: rbootd.c,v 1.14 2002/06/11 18:49:18 hin Exp $	*/
d58 1
a58 1
static char rcsid[] = "$OpenBSD: rbootd.c,v 1.14 2002/06/11 18:49:18 hin Exp $";
d97 1
a97 3
main(argc, argv)
	int argc;
	char *argv[];
d121 2
a122 2
		switch(c) {
		    case 'a':
d125 1
a125 1
		    case 'd':
d128 1
a128 1
		    case 'i':
d301 2
a302 2
					       "%s: boot packet ignored",
					       EnetStr(&rconn));
d328 1
a328 1
DoTimeout()
d342 1
a342 1
			       EnetStr(rtmp), rtmp->rmp.r_type);
a362 1

d364 1
a364 2
FindClient(rconn)
	RMPCONN *rconn;
d370 1
a370 1
		         (char *)&ctmp->addr[0], RMP_ADDRLEN) == 0)
d389 1
a389 2
Exit(sig)
	int sig;
d398 1
a398 1
DoExit()
d422 1
a422 2
ReConfig(signo)
	int signo;
d428 1
a428 1
DoReConfig()
d454 1
a454 2
DebugOff(signo)
	int signo;
d460 1
a460 1
DoDebugOff()
d482 1
a482 2
DebugOn(signo)
	int signo;
d488 1
a488 1
DoDebugOn()
@


1.14
log
@-Wall cleanup

ok millert@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rbootd.c,v 1.13 2002/03/14 16:44:25 mpech Exp $	*/
d58 1
a58 1
static char rcsid[] = "$OpenBSD: rbootd.c,v 1.13 2002/03/14 16:44:25 mpech Exp $";
a193 1
	MyHost[MAXHOSTNAMELEN] = '\0';
@


1.13
log
@kill more registers.

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: rbootd.c,v 1.12 2002/02/20 02:00:01 miod Exp $	*/
d58 1
a58 1
static char rcsid[] = "$OpenBSD: rbootd.c,v 1.12 2002/02/20 02:00:01 miod Exp $";
d63 1
d74 2
@


1.12
log
@Revert 1.10, bad mpech@@ didn't try to compile.
@
text
@d1 1
a1 1
/*	$OpenBSD: rbootd.c,v 1.11 2002/02/19 21:04:09 miod Exp $	*/
d58 1
a58 1
static char rcsid[] = "$OpenBSD: rbootd.c,v 1.11 2002/02/19 21:04:09 miod Exp $";
d330 1
a330 1
	register RMPCONN *rtmp;
d366 1
a366 1
	register RMPCONN *rconn;
d368 1
a368 1
	register CLIENT *ctmp;
@


1.11
log
@Fix the signal races in rbootd.
Credit to millert@@ and deraadt@@ for pointing out some of my braindamage.
@
text
@d1 1
a1 1
/*	$OpenBSD: rbootd.c,v 1.10 2002/02/19 18:38:02 mpech Exp $	*/
d58 1
a58 1
static char rcsid[] = "$OpenBSD: rbootd.c,v 1.10 2002/02/19 18:38:02 mpech Exp $";
d187 1
a187 1
	if (gethostname(MyHost, sizeof(MyHost)) < 0) {
@


1.10
log
@Fix gethostname() usage.

deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: rbootd.c,v 1.9 2001/12/01 23:27:23 miod Exp $	*/
d58 1
a58 1
static char rcsid[] = "$OpenBSD: rbootd.c,v 1.9 2001/12/01 23:27:23 miod Exp $";
d77 16
d174 1
a174 1
			Exit(0);
d189 1
a189 1
		Exit(0);
d206 1
a206 1
		Exit(0);
d216 1
a216 1
		Exit(0);
d218 1
a218 1
		Exit(0);
d222 1
a222 1
	 *  If an error is encountered, a message is displayed and Exit()
d241 16
d271 1
a271 1
			Exit(0);
d351 1
a351 1
**		rconn - the new packet. 
d394 10
a403 6
	/* XXX race */
	if (sig > 0)
		syslog(LOG_ERR, "going down on signal %d", sig);
	else
		syslog(LOG_ERR, "going down with fatal error");
	BpfClose();
d428 6
a433 1
	/* XXX race */
d439 1
a439 1
		Exit(0);
d442 1
a442 1
		Exit(0);
d461 2
a462 1
	/* XXX race */
d464 3
d490 6
a495 1
	/* XXX race */
@


1.9
log
@Use pidfile() instead of doing the equivalent thing by hand, and sometimes
forgetting to unlink the pid file at exit.
ok millert@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rbootd.c,v 1.8 2001/09/04 23:35:59 millert Exp $	*/
d58 1
a58 1
static char rcsid[] = "$OpenBSD: rbootd.c,v 1.8 2001/09/04 23:35:59 millert Exp $";
d171 1
a171 1
	if (gethostname(MyHost, MAXHOSTNAMELEN) < 0) {
@


1.8
log
@Replace the deprecated BSD sigsetmask/sigblock/sigpause functions with their POSIX counterparts.
@
text
@d1 1
a1 1
/*	$OpenBSD: rbootd.c,v 1.7 2001/01/19 17:53:18 deraadt Exp $	*/
d58 1
a58 1
static char rcsid[] = "$OpenBSD: rbootd.c,v 1.7 2001/01/19 17:53:18 deraadt Exp $";
a176 2
	MyPid = getpid();

d180 2
a181 9
	{
		FILE *fp;

		if ((fp = fopen(PidFile, "w")) != NULL) {
			(void) fprintf(fp, "%d\n", (int) MyPid);
			(void) fclose(fp);
		} else {
			syslog(LOG_WARNING, "fopen: failed (%s)", PidFile);
		}
@


1.7
log
@mark remaining signal races which are difficult to fix
@
text
@d1 1
a1 1
/*	$OpenBSD: rbootd.c,v 1.6 2001/01/17 00:33:03 pjanzen Exp $	*/
d58 1
a58 1
static char rcsid[] = "$OpenBSD: rbootd.c,v 1.6 2001/01/17 00:33:03 pjanzen Exp $";
d82 1
a82 1
	int c, fd, omask, maxfds;
d84 1
d205 3
a207 1
	omask = sigblock(sigmask(SIGHUP));	/* prevent reconfig's */
d220 1
a220 1
	(void) sigsetmask(omask);		/* allow reconfig's */
d265 1
a265 1
				omask = sigblock(sigmask(SIGHUP));
d280 1
a280 1
					(void) sigsetmask(omask);
d286 1
a286 1
				(void) sigsetmask(omask);
@


1.6
log
@OpenBSD-ify.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d58 1
a58 1
static char rcsid[] = "$OpenBSD$";
d368 1
d398 1
d426 2
d451 1
@


1.5
log
@More format string paranoia; deraadt@@ ok
@
text
@d1 1
d58 1
a58 1
static char rcsid[] = "$NetBSD: rbootd.c,v 1.5 1995/10/06 05:12:17 thorpej Exp $";
@


1.4
log
@BpfGetIntfName() returns syslog fmt args which are safe
@
text
@d155 1
a155 1
			syslog(LOG_ERR, errmsg);
@


1.3
log
@Kill extra newline in err()/warn().
@
text
@d154 1
@


1.2
log
@getopt(3) returns -1 when out of args, not EOF, whee!
@
text
@d117 1
a117 1
			warnx("too many config files (`%s' ignored)\n",
@


1.1
log
@Initial revision
@
text
@d101 1
a101 1
	while ((c = getopt(argc, argv, "adi:")) != EOF)
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
