head	1.15;
access;
symbols
	OPENBSD_6_2:1.15.0.2
	OPENBSD_6_2_BASE:1.15
	OPENBSD_6_1:1.12.0.4
	OPENBSD_6_1_BASE:1.12;
locks; strict;
comment	@ * @;


1.15
date	2017.07.09.00.51.40;	author pd;	state Exp;
branches;
next	1.14;
commitid	qGhsIrgsAzfqzJtv;

1.14
date	2017.05.08.09.08.40;	author reyk;	state Exp;
branches;
next	1.13;
commitid	oVx15xEUTrD3JWhh;

1.13
date	2017.05.02.09.51.19;	author mlarkin;	state Exp;
branches;
next	1.12;
commitid	VP44J2pYuXBwI9Df;

1.12
date	2017.03.27.00.28.04;	author deraadt;	state Exp;
branches;
next	1.11;
commitid	cbObO83mNT8jlhy1;

1.11
date	2017.03.26.17.04.03;	author kettenis;	state Exp;
branches;
next	1.10;
commitid	LNUb0ilRtjIRL3TU;

1.10
date	2017.03.25.22.36.53;	author mlarkin;	state Exp;
branches;
next	1.9;
commitid	8Fl7pGk8QzRFB3im;

1.9
date	2017.03.25.07.46.24;	author mlarkin;	state Exp;
branches;
next	1.8;
commitid	fC8LAknsckToIgCj;

1.8
date	2017.03.23.07.59.41;	author mlarkin;	state Exp;
branches;
next	1.7;
commitid	PBAr9t512xfhVkX6;

1.7
date	2017.03.23.06.59.31;	author mlarkin;	state Exp;
branches;
next	1.6;
commitid	aLOUtu2cFqleCMEy;

1.6
date	2017.03.19.23.10.23;	author mlarkin;	state Exp;
branches;
next	1.5;
commitid	80p2l61diaRP1fXv;

1.5
date	2017.01.17.21.51.01;	author krw;	state Exp;
branches;
next	1.4;
commitid	7aASaBYKS1WgBK9H;

1.4
date	2016.10.26.05.26.36;	author mlarkin;	state Exp;
branches;
next	1.3;
commitid	1sM4SQUlhgJwAn6Q;

1.3
date	2016.10.03.06.00.17;	author mlarkin;	state Exp;
branches;
next	1.2;
commitid	bs8XE32xihRjrrM4;

1.2
date	2016.09.01.17.28.34;	author mlarkin;	state Exp;
branches;
next	1.1;
commitid	zwGjKQBjYSuTmBRA;

1.1
date	2016.09.01.14.48.09;	author mlarkin;	state Exp;
branches;
next	;
commitid	FBqVpmx18MX292rY;


desc
@@


1.15
log
@vmd/vmctl: Add ability to pause / unpause vms

With help from Ashwin Agrawal

ok reyk@@ mlarkin@@
@
text
@/* $OpenBSD: mc146818.c,v 1.14 2017/05/08 09:08:40 reyk Exp $ */
/*
 * Copyright (c) 2016 Mike Larkin <mlarkin@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>

#include <dev/ic/mc146818reg.h>
#include <dev/isa/isareg.h>

#include <machine/vmmvar.h>

#include <event.h>
#include <stddef.h>
#include <string.h>
#include <time.h>
#include <unistd.h>

#include "vmd.h"
#include "mc146818.h"
#include "proc.h"
#include "virtio.h"
#include "vmm.h"
#include "atomicio.h"

#define MC_DIVIDER_MASK 0xe0
#define MC_RATE_MASK 0xf

#define NVRAM_CENTURY 0x32
#define NVRAM_MEMSIZE_LO 0x34
#define NVRAM_MEMSIZE_HI 0x35
#define NVRAM_HIMEMSIZE_LO 0x5B
#define NVRAM_HIMEMSIZE_MID 0x5C
#define NVRAM_HIMEMSIZE_HI 0x5D
#define NVRAM_SMP_COUNT 0x5F

#define NVRAM_SIZE 0x60

#define TOBCD(x)	(((x) / 10 * 16) + ((x) % 10))

struct mc146818 {
	time_t now;
	uint8_t idx;
	uint8_t regs[NVRAM_SIZE];
	uint32_t vm_id;
	struct event sec;
	struct timeval sec_tv;
	struct event per;
	struct timeval per_tv;
};

struct mc146818 rtc;

/*
 * rtc_updateregs
 *
 * Updates the RTC TOD bytes, reflecting 'now'.
 */
static void
rtc_updateregs(void)
{
	struct tm *gnow;

	rtc.regs[MC_REGD] &= ~MC_REGD_VRT;
	gnow = gmtime(&rtc.now);

	rtc.regs[MC_SEC] = TOBCD(gnow->tm_sec);
	rtc.regs[MC_MIN] = TOBCD(gnow->tm_min);
	rtc.regs[MC_HOUR] = TOBCD(gnow->tm_hour);
	rtc.regs[MC_DOW] = TOBCD(gnow->tm_wday + 1);
	rtc.regs[MC_DOM] = TOBCD(gnow->tm_mday);
	rtc.regs[MC_MONTH] = TOBCD(gnow->tm_mon + 1);
	rtc.regs[MC_YEAR] = TOBCD((gnow->tm_year + 1900) % 100);
	rtc.regs[NVRAM_CENTURY] = TOBCD((gnow->tm_year + 1900) / 100);
	rtc.regs[MC_REGD] |= MC_REGD_VRT;
}

/*
 * rtc_fire1
 *
 * Callback for the 1s periodic TOD refresh timer
 *
 * Parameters:
 *  fd: unused
 *  type: unused
 *  arg: unused
 */
static void
rtc_fire1(int fd, short type, void *arg)
{
	time_t old = rtc.now;

	time(&rtc.now);

	rtc_updateregs();
	if (rtc.now - old > 5) {
		log_debug("%s: RTC clock drift (%llds), requesting guest "
		    "resync", __func__, (rtc.now - old));
		vmmci_ctl(VMMCI_SYNCRTC);
	}
	evtimer_add(&rtc.sec, &rtc.sec_tv);
}

/*
 * rtc_fireper
 *
 * Callback for the periodic interrupt timer
 *
 * Parameters:
 *  fd: unused
 *  type: unused
 *  arg: (as uint32_t), VM ID to which this RTC belongs
 */
static void
rtc_fireper(int fd, short type, void *arg)
{
	rtc.regs[MC_REGC] |= MC_REGC_PF;

	vcpu_assert_pic_irq((ptrdiff_t)arg, 0, 8);

	evtimer_add(&rtc.per, &rtc.per_tv);
}

/*
 * mc146818_init
 *
 * Initializes the emulated RTC/NVRAM
 *
 * Parameters:
 *  vm_id: VM ID to which this RTC belongs
 *  memlo: size of memory in bytes between 16MB .. 4GB
 *  memhi: size of memory in bytes after 4GB
 */
void
mc146818_init(uint32_t vm_id, uint64_t memlo, uint64_t memhi)
{
	memset(&rtc, 0, sizeof(rtc));
	time(&rtc.now);

	rtc.regs[MC_REGB] = MC_REGB_24HR;

	memlo /= 65536;
	memhi /= 65536;

	rtc.regs[NVRAM_MEMSIZE_HI] = (memlo >> 8) & 0xFF;
	rtc.regs[NVRAM_MEMSIZE_LO] = memlo & 0xFF;
	rtc.regs[NVRAM_HIMEMSIZE_HI] = (memhi >> 16) & 0xFF;
	rtc.regs[NVRAM_HIMEMSIZE_MID] = (memhi >> 8) & 0xFF;
	rtc.regs[NVRAM_HIMEMSIZE_LO] = memhi & 0xFF;

	rtc.regs[NVRAM_SMP_COUNT] = 0;

	rtc_updateregs();
	rtc.vm_id = vm_id;

	timerclear(&rtc.sec_tv);
	rtc.sec_tv.tv_sec = 1;

	timerclear(&rtc.per_tv);

	evtimer_set(&rtc.sec, rtc_fire1, NULL);
	evtimer_add(&rtc.sec, &rtc.sec_tv);

	evtimer_set(&rtc.per, rtc_fireper, (void *)(intptr_t)rtc.vm_id);
}

/*
 * rtc_reschedule_per
 *
 * Reschedule the periodic interrupt firing rate, based on the currently
 * selected REGB values.
 */
static void
rtc_reschedule_per(void)
{
	uint16_t rate;
	uint64_t us;

	if (rtc.regs[MC_REGB] & MC_REGB_PIE) {
		rate = 32768 >> ((rtc.regs[MC_REGA] & MC_RATE_MASK) - 1);
		us = (1.0 / rate) * 1000000;
		rtc.per_tv.tv_usec = us;
		if (evtimer_pending(&rtc.per, NULL))
			evtimer_del(&rtc.per);

		evtimer_add(&rtc.per, &rtc.per_tv);
	}
}

/*
 * rtc_update_rega
 *
 * Updates the RTC's REGA register
 *
 * Parameters:
 *  data: REGA register data
 */
static void
rtc_update_rega(uint32_t data)
{
	if ((data & MC_DIVIDER_MASK) != MC_BASE_32_KHz)
		log_warnx("%s: set non-32KHz timebase not supported",
		    __func__);

	rtc.regs[MC_REGA] = data;
	if (rtc.regs[MC_REGB] & MC_REGB_PIE)
		rtc_reschedule_per();
}

/*
 * rtc_update_regb
 *
 * Updates the RTC's REGB register
 *
 * Parameters:
 *  data: REGB register data
 */
static void
rtc_update_regb(uint32_t data)
{
	if (data & MC_REGB_DSE)
		log_warnx("%s: DSE mode not supported", __func__);

	if (!(data & MC_REGB_24HR))
		log_warnx("%s: 12 hour mode not supported", __func__);

	rtc.regs[MC_REGB] = data;

	if (data & MC_REGB_PIE)
		rtc_reschedule_per();
}

/*
 * vcpu_exit_mc146818
 *
 * Handles emulated MC146818 RTC access (in/out instruction to RTC ports).
 *
 * Parameters:
 *  vrp: vm run parameters containing exit information for the I/O
 *      instruction being performed
 *
 * Return value:
 *  Interrupt to inject to the guest VM, or 0xFF if no interrupt should
 *      be injected.
 */
uint8_t
vcpu_exit_mc146818(struct vm_run_params *vrp)
{
	union vm_exit *vei = vrp->vrp_exit;
	uint16_t port = vei->vei.vei_port;
	uint8_t dir = vei->vei.vei_dir;
	uint32_t data = 0;

	get_input_data(vei, &data);

	if (port == IO_RTC) {
		/* Discard NMI bit */
		if (data & 0x80)
			data &= ~0x80;

		if (dir == 0) {
			if (data < (NVRAM_SIZE))
				rtc.idx = data;
			else
				rtc.idx = MC_REGD;
		} else
			set_return_data(vei, rtc.idx);
	} else if (port == IO_RTC + 1) {
		if (dir == 0) {
			switch (rtc.idx) {
			case MC_SEC ... MC_YEAR:
			case MC_NVRAM_START ... MC_NVRAM_START + MC_NVRAM_SIZE:
				rtc.regs[rtc.idx] = data;
				break;
			case MC_REGA:
				rtc_update_rega(data);
				break;
			case MC_REGB:
				rtc_update_regb(data);
				break;
			case MC_REGC:
			case MC_REGD:
				log_warnx("%s: mc146818 illegal write "
				    "of reg 0x%x", __func__, rtc.idx);
				break;
			default:
				log_warnx("%s: mc146818 illegal reg %x\n",
				    __func__, rtc.idx);
			}
		} else {
			data = rtc.regs[rtc.idx];
			set_return_data(vei, data);

			if (rtc.idx == MC_REGC) {
				/* Reset IRQ state */
				rtc.regs[MC_REGC] &= ~MC_REGC_PF;
			}
		}
	} else {
		log_warnx("%s: mc146818 unknown port 0x%x",
		    __func__, vei->vei.vei_port);
	}

	return 0xFF;
}

int
mc146818_dump(int fd)
{
	log_debug("%s: sending RTC", __func__);
	if (atomicio(vwrite, fd, &rtc, sizeof(rtc)) != sizeof(rtc)) {
		log_warnx("%s: error writing RTC to fd", __func__);
		return (-1);
	}
	return (0);
}

int
mc146818_restore(int fd, uint32_t vm_id)
{
	log_debug("%s: restoring RTC", __func__);
	if (atomicio(read, fd, &rtc, sizeof(rtc)) != sizeof(rtc)) {
		log_warnx("%s: error reading RTC from fd", __func__);
		return (-1);
	}
	rtc.vm_id = vm_id;

	memset(&rtc.sec, 0, sizeof(struct event));
	memset(&rtc.per, 0, sizeof(struct event));
	evtimer_set(&rtc.sec, rtc_fire1, NULL);
	evtimer_set(&rtc.per, rtc_fireper, (void *)(intptr_t)rtc.vm_id);
	return (0);
}

void
mc146818_stop()
{
	evtimer_del(&rtc.per);
	evtimer_del(&rtc.sec);
}

void
mc146818_start()
{
	evtimer_add(&rtc.per, &rtc.per_tv);
	evtimer_add(&rtc.sec, &rtc.sec_tv);
}
@


1.14
log
@Adds functions to read and write state of devices in vmd.

This is required for implementing vmctl send and vmctl receive.  vmctl
send / receive are two new options that will support snapshotting VMs
and migrating VMs from one host to another. The atomicio files are
copied from usr.bin/ssh.

Patch from Pratik Vyas; this project was undertaken at San Jose State
University along with his three teammates, Ashwin, Harshada and Siri
with mlarkin@@ as the advisor.

OK mlarkin@@
@
text
@d1 1
a1 1
/* $OpenBSD: mc146818.c,v 1.13 2017/05/02 09:51:19 mlarkin Exp $ */
a343 3

	evtimer_add(&rtc.per, &rtc.per_tv);
	evtimer_add(&rtc.sec, &rtc.sec_tv);
d352 7
@


1.13
log
@Resynchronize the guest RTC via vmmci(4) on host resume from zzz/ZZZ
(vmd part)

This feature is for OpenBSD guests only.

ok reyk, kettenis
@
text
@d1 1
a1 1
/* $OpenBSD: mc146818.c,v 1.12 2017/03/27 00:28:04 deraadt Exp $ */
d29 1
d36 1
d317 38
@


1.12
log
@die whitespace die die die
@
text
@d1 1
a1 1
/* $OpenBSD: mc146818.c,v 1.11 2017/03/26 17:04:03 kettenis Exp $ */
d30 1
d33 1
d101 4
a104 1
	rtc.now++;
d106 5
@


1.11
log
@With the updated get_input_data() interface, we need to zero-initialize
the stack variable that we use to store the data otherwise the bytes that
aren't touched by get_input_data() may contain garbage.

ok mlarkin@@
@
text
@d1 1
a1 1
/* $OpenBSD: mc146818.c,v 1.10 2017/03/25 22:36:53 mlarkin Exp $ */
d152 1
a152 1
	
@


1.10
log
@Last bits needed to get seabios + alpine linux working. This is enough
to get started and let more people help finding and fixing bugs.

ok kettenis, deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: mc146818.c,v 1.9 2017/03/25 07:46:24 mlarkin Exp $ */
d252 1
a252 1
	uint32_t data;
@


1.9
log
@Introduce a new function to obtain properly sized input data, and convert
i8253/i8259/mc146818 emulation to use this.
@
text
@d1 1
a1 1
/* $OpenBSD: mc146818.c,v 1.8 2017/03/23 07:59:41 mlarkin Exp $ */
d254 1
a254 1
	data = get_input_data(vei);
@


1.8
log
@Implement memory size and SMP CPU count NVRAM registers in the emulated
mc146818. This is needed for seabios to boot properly (and construct
a sensible e820 map to send to the guest OS).
@
text
@d1 1
a1 1
/* $OpenBSD: mc146818.c,v 1.7 2017/03/23 06:59:31 mlarkin Exp $ */
d252 3
a254 1
	uint32_t data = vei->vei.vei_data & 0xFF;
d264 1
a264 3
			else {
				log_warnx("%s: mc146818 bogus register 0x%x",
				    __func__, data);
d266 2
a267 6
			}
		} else {
			log_warnx("%s: mc146818 illegal read from port 0x%x",
			    __func__, port);
			set_return_data(vei, 0xFF);
		}
a289 1
			rtc.idx = MC_REGD;
a297 1
			rtc.idx = MC_REGD;
@


1.7
log
@Various mc146818 emulation fixes - don't block interrupts needlessly, and
set proper return data size (don't clobber high %eax bits). Also apply
a mask on incoming data (from OUT instruction in guest) to avoid
misinterpreting register index values. Found when implementing Linux and
seabios support.
@
text
@d1 1
a1 1
/* $OpenBSD: mc146818.c,v 1.6 2017/03/19 23:10:23 mlarkin Exp $ */
d38 8
d52 1
a52 1
	uint8_t regs[MC_NREGS + MC_NVRAM_SIZE];
d131 2
d135 1
a135 1
mc146818_init(uint32_t vm_id)
d141 12
d255 4
d260 1
a260 1
			if (data <= (MC_NREGS + MC_NVRAM_SIZE))
@


1.6
log
@Don't identify the MC146818 RTC as operating in binary mode when we are really
operating in BCD mode. Linux assumes the RTC will be in BCD mode by default
and if not, it does a WARN_ON warning about this, and misinterprets the RTC
TOD registers.

Tested with existing vmd/vmm guests with what's in tree.
@
text
@d1 1
a1 1
/* $OpenBSD: mc146818.c,v 1.5 2017/01/17 21:51:01 krw Exp $ */
a49 1
	uint8_t irq_blocked;
d111 1
a111 5
	if (!rtc.irq_blocked)
		vcpu_assert_pic_irq((ptrdiff_t)arg, 0, 8);

	/* Next irq is blocked until read of REGC */
	rtc.irq_blocked = 1;
d137 2
d230 1
a230 1
	uint32_t data = vei->vei.vei_data;
d244 1
a244 1
			vei->vei.vei_data = 0xFF;
d271 1
a271 1
			vei->vei.vei_data = data;
a274 1
				rtc.irq_blocked = 0;
@


1.5
log
@Nuke some whitespace that keeps poking me in the eye as I try to
steal code.
@
text
@d1 1
a1 1
/* $OpenBSD: mc146818.c,v 1.4 2016/10/26 05:26:36 mlarkin Exp $ */
d135 1
a135 1
	rtc.regs[MC_REGB] = MC_REGB_24HR | MC_REGB_BINARY;
@


1.4
log
@
vmd(8)/vmctl(8) for i386. Some ugliness in #ifdef __i386__ areas will be
fixed in tree, but the changes required were pretty minimal.

Note that i386 hosts are still presently limited to running i386 guests.

ok deraadt, stefan, jca
@
text
@d1 1
a1 1
/* $OpenBSD: mc146818.c,v 1.3 2016/10/03 06:00:17 mlarkin Exp $ */
d133 1
a133 1
	time(&rtc.now);	
d273 1
a273 1
			data = rtc.regs[rtc.idx]; 
@


1.3
log
@
add RCS tags
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d145 1
a145 1
	evtimer_set(&rtc.per, rtc_fireper, (void *)(uint64_t)rtc.vm_id);
@


1.2
log
@
normalize some function names
@
text
@d1 1
@


1.1
log
@
Add a set of emulated legacy devices (PIT, PIC, RTC)

discussed with stefan and deraadt
@
text
@d148 1
a148 1
 * reschedule_per
d154 1
a154 1
reschedule_per(void)
d171 1
a171 1
 * update_rega
d179 1
a179 1
update_rega(uint32_t data)
d187 1
a187 1
		reschedule_per();
d191 1
a191 1
 * update_regb
d199 1
a199 1
update_regb(uint32_t data)
d210 1
a210 1
		reschedule_per();
d256 1
a256 1
				update_rega(data);
d259 1
a259 1
				update_regb(data);
@

