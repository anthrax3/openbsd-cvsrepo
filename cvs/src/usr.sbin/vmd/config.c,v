head	1.29;
access;
symbols
	OPENBSD_6_1:1.29.0.2
	OPENBSD_6_1_BASE:1.29
	OPENBSD_6_0:1.9.0.4
	OPENBSD_6_0_BASE:1.9
	OPENBSD_5_9:1.9.0.2
	OPENBSD_5_9_BASE:1.9;
locks; strict;
comment	@ * @;


1.29
date	2017.03.26.18.32.39;	author reyk;	state Exp;
branches;
next	1.28;
commitid	bDo2VPUcxOqq00Rk;

1.28
date	2017.03.26.00.46.00;	author reyk;	state Exp;
branches;
next	1.27;
commitid	gxsCwavHd9HIuPQz;

1.27
date	2017.03.25.16.28.25;	author reyk;	state Exp;
branches;
next	1.26;
commitid	s82EA2LBuZtftmLN;

1.26
date	2017.03.02.07.33.37;	author reyk;	state Exp;
branches;
next	1.25;
commitid	0uvzhmQVR7Ehsjus;

1.25
date	2017.03.01.07.43.33;	author reyk;	state Exp;
branches;
next	1.24;
commitid	2hnfyuVZdSB2L5DB;

1.24
date	2017.02.27.14.37.58;	author reyk;	state Exp;
branches;
next	1.23;
commitid	VZNWondGbqn2F9Is;

1.23
date	2017.01.17.21.51.01;	author krw;	state Exp;
branches;
next	1.22;
commitid	7aASaBYKS1WgBK9H;

1.22
date	2016.12.14.06.59.12;	author reyk;	state Exp;
branches;
next	1.21;
commitid	InVlLp4UCIsZp75o;

1.21
date	2016.11.24.07.58.55;	author reyk;	state Exp;
branches;
next	1.20;
commitid	vTTzvT7jwtD1X8ZA;

1.20
date	2016.11.22.21.55.54;	author reyk;	state Exp;
branches;
next	1.19;
commitid	H4GVKiza5W94X5mq;

1.19
date	2016.11.04.15.16.44;	author reyk;	state Exp;
branches;
next	1.18;
commitid	SAdDSuqFvlzVuxeB;

1.18
date	2016.11.04.15.07.26;	author reyk;	state Exp;
branches;
next	1.17;
commitid	qfn7LnsEzfGhtk0c;

1.17
date	2016.10.29.14.56.05;	author edd;	state Exp;
branches;
next	1.16;
commitid	DOewrpkDk9kNopaK;

1.16
date	2016.10.15.14.02.11;	author reyk;	state Exp;
branches;
next	1.15;
commitid	17YGcUnMa3ic5LJQ;

1.15
date	2016.10.12.10.58.32;	author reyk;	state Exp;
branches;
next	1.14;
commitid	VoX5P7wvMVEFdj4H;

1.14
date	2016.10.05.17.30.13;	author reyk;	state Exp;
branches;
next	1.13;
commitid	c3mC9fNmRbfUPluH;

1.13
date	2016.10.04.17.17.30;	author reyk;	state Exp;
branches;
next	1.12;
commitid	yb7Y2lNmLG5i2hzO;

1.12
date	2016.09.29.22.42.04;	author reyk;	state Exp;
branches;
next	1.11;
commitid	OrqC5N55KjzTfX1Z;

1.11
date	2016.09.03.10.20.06;	author stefan;	state Exp;
branches;
next	1.10;
commitid	FDrFetd3QYJ99zuW;

1.10
date	2016.07.29.16.36.51;	author stefan;	state Exp;
branches;
next	1.9;
commitid	lYP7ykFkRsliCh0y;

1.9
date	2015.12.07.15.57.53;	author reyk;	state Exp;
branches;
next	1.8;
commitid	ofB8MY72NAdwQ7hq;

1.8
date	2015.12.07.14.43.24;	author reyk;	state Exp;
branches;
next	1.7;
commitid	RMd15UDHH5owCCwU;

1.7
date	2015.12.06.21.02.51;	author reyk;	state Exp;
branches;
next	1.6;
commitid	Zp1KJ8lrcRoKUs6F;

1.6
date	2015.12.06.01.14.08;	author reyk;	state Exp;
branches;
next	1.5;
commitid	xEdaPc1y9QZZ32Ml;

1.5
date	2015.12.04.10.54.21;	author reyk;	state Exp;
branches;
next	1.4;
commitid	ODIPgch2NC9MVTf9;

1.4
date	2015.12.03.23.32.32;	author reyk;	state Exp;
branches;
next	1.3;
commitid	ABlEnH3RsSBpSsyK;

1.3
date	2015.12.03.16.11.32;	author reyk;	state Exp;
branches;
next	1.2;
commitid	G1u4CGxMrb6r5d6R;

1.2
date	2015.12.03.13.27.14;	author reyk;	state Exp;
branches;
next	1.1;
commitid	pRSLgXNuoj9hRPQx;

1.1
date	2015.12.02.22.19.11;	author reyk;	state Exp;
branches;
next	;
commitid	7ra6VeOJoUb1NQ70;


desc
@@


1.29
log
@Don't compare kernel and root disk name if both strings are empty.

This avoids jumping into vmboot in some edge conditions.

OK mlarkin@@
@
text
@/*	$OpenBSD: config.c,v 1.28 2017/03/26 00:46:00 reyk Exp $	*/

/*
 * Copyright (c) 2015 Reyk Floeter <reyk@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/queue.h>
#include <sys/time.h>
#include <sys/uio.h>
#include <sys/socket.h>

#include <net/if.h>

#include <stdio.h>
#include <stdlib.h>
#include <termios.h>
#include <unistd.h>
#include <limits.h>
#include <string.h>
#include <fcntl.h>
#include <util.h>
#include <errno.h>
#include <imsg.h>

#include "proc.h"
#include "vmd.h"

/* Supported bridge types */
const char *vmd_descsw[] = { "switch", "bridge", NULL };

int
config_init(struct vmd *env)
{
	struct privsep	*ps = &env->vmd_ps;
	unsigned int	 what;

	/* Global configuration */
	ps->ps_what[PROC_PARENT] = CONFIG_ALL;
	ps->ps_what[PROC_VMM] = CONFIG_VMS;
	ps->ps_what[PROC_PRIV] = 0;

	/* Other configuration */
	what = ps->ps_what[privsep_process];
	if (what & CONFIG_VMS) {
		if ((env->vmd_vms = calloc(1, sizeof(*env->vmd_vms))) == NULL)
			return (-1);
		TAILQ_INIT(env->vmd_vms);
	}
	if (what & CONFIG_SWITCHES) {
		if ((env->vmd_switches = calloc(1,
		    sizeof(*env->vmd_switches))) == NULL)
			return (-1);
		TAILQ_INIT(env->vmd_switches);
	}

	return (0);
}

void
config_purge(struct vmd *env, unsigned int reset)
{
	struct privsep		*ps = &env->vmd_ps;
	struct vmd_vm		*vm;
	struct vmd_switch	*vsw;
	unsigned int		 what;

	what = ps->ps_what[privsep_process] & reset;
	if (what & CONFIG_VMS && env->vmd_vms != NULL) {
		while ((vm = TAILQ_FIRST(env->vmd_vms)) != NULL)
			vm_remove(vm);
		env->vmd_nvm = 0;
	}
	if (what & CONFIG_SWITCHES && env->vmd_switches != NULL) {
		while ((vsw = TAILQ_FIRST(env->vmd_switches)) != NULL)
			switch_remove(vsw);
		env->vmd_nswitches = 0;
	}
}

int
config_setreset(struct vmd *env, unsigned int reset)
{
	struct privsep	*ps = &env->vmd_ps;
	unsigned int	 id;

	for (id = 0; id < PROC_MAX; id++) {
		if ((reset & ps->ps_what[id]) == 0 ||
		    id == privsep_process)
			continue;
		proc_compose(ps, id, IMSG_CTL_RESET, &reset, sizeof(reset));
	}

	return (0);
}

int
config_getreset(struct vmd *env, struct imsg *imsg)
{
	unsigned int	 mode;

	IMSG_SIZE_CHECK(imsg, &mode);
	memcpy(&mode, imsg->data, sizeof(mode));

	config_purge(env, mode);

	return (0);
}

int
config_setvm(struct privsep *ps, struct vmd_vm *vm, uint32_t peerid, uid_t uid)
{
	struct vmd_if		*vif;
	struct vmop_create_params *vmc = &vm->vm_params;
	struct vm_create_params	*vcp = &vmc->vmc_params;
	unsigned int		 i;
	int			 fd = -1, vmboot = 0;
	int			 kernfd = -1, *diskfds = NULL, *tapfds = NULL;
	int			 saved_errno = 0;
	char			 ifname[IF_NAMESIZE], *s;
	char			 path[PATH_MAX];
	unsigned int		 unit;

	errno = 0;

	if (vm->vm_running) {
		log_warnx("%s: vm is already running", __func__);
		errno = EALREADY;
		goto fail;
	}

	diskfds = reallocarray(NULL, vcp->vcp_ndisks, sizeof(*diskfds));
	if (diskfds == NULL) {
		log_warn("%s: can't allocate disk fds", __func__);
		goto fail;
	}
	for (i = 0; i < vcp->vcp_ndisks; i++)
		diskfds[i] = -1;

	tapfds = reallocarray(NULL, vcp->vcp_nnics, sizeof(*tapfds));
	if (tapfds == NULL) {
		log_warn("%s: can't allocate tap fds", __func__);
		goto fail;
	}
	for (i = 0; i < vcp->vcp_nnics; i++)
		tapfds[i] = -1;

	vm->vm_peerid = peerid;
	vm->vm_uid = uid;

	if (strlen(vcp->vcp_kernel)) {
		/* Boot kernel from disk image if path matches the root disk */
		if (vcp->vcp_ndisks &&
		    strcmp(vcp->vcp_kernel, vcp->vcp_disks[0]) == 0)
			vmboot = 1;
		/* Open external kernel for child */
		else if ((kernfd = open(vcp->vcp_kernel, O_RDONLY)) == -1) {
			log_warn("%s: can't open kernel/BIOS boot image %s",
			    __func__, vcp->vcp_kernel);
			goto fail;
		}
	}

	/*
	 * Try to open the default BIOS image if no kernel/BIOS has
	 * been specified.  The BIOS is an external firmware file that is
	 * typically distributed separately due to an incompatible license.
	 */
	if (kernfd == -1 && !vmboot &&
	    (kernfd = open(VM_DEFAULT_BIOS, O_RDONLY)) == -1) {
		log_warn("%s: can't open %s", __func__, VM_DEFAULT_BIOS);
		goto fail;
	}

	/* Open disk images for child */
	for (i = 0 ; i < vcp->vcp_ndisks; i++) {
		if ((diskfds[i] =
		    open(vcp->vcp_disks[i], O_RDWR)) == -1) {
			log_warn("%s: can't open disk %s", __func__,
			    vcp->vcp_disks[i]);
			goto fail;
		}
	}

	/* Open network interfaces */
	for (i = 0 ; i < vcp->vcp_nnics; i++) {
		vif = &vm->vm_ifs[i];

		/* Check if the user has requested a specific tap(4) */
		s = vmc->vmc_ifnames[i];
		if (*s != '\0' && strcmp("tap", s) != 0) {
			if (priv_getiftype(s, ifname, &unit) == -1 ||
			    strcmp(ifname, "tap") != 0) {
				log_warnx("%s: invalid tap name %s",
				    __func__, s);
				errno = EINVAL;
				goto fail;
			}
		} else
			s = NULL;

		/*
		 * Either open the requested tap(4) device or get
		 * the next available one.
		 */
		if (s != NULL) {
			snprintf(path, PATH_MAX, "/dev/%s", s);
			tapfds[i] = open(path, O_RDWR | O_NONBLOCK);
		} else {
			tapfds[i] = opentap(ifname);
			s = ifname;
		}
		if (tapfds[i] == -1) {
			log_warn("%s: can't open tap %s", __func__, s);
			goto fail;
		}
		if ((vif->vif_name = strdup(s)) == NULL) {
			log_warn("%s: can't save tap %s", __func__, s);
			goto fail;
		}

		/* Check if the the interface is attached to a switch */
		s = vmc->vmc_ifswitch[i];
		if (*s != '\0') {
			if ((vif->vif_switch = strdup(s)) == NULL) {
				log_warn("%s: can't save switch %s",
				    __func__, s);
				goto fail;
			}
		}

		/* Check if the the interface is assigned to a group */
		s = vmc->vmc_ifgroup[i];
		if (*s != '\0') {
			if ((vif->vif_group = strdup(s)) == NULL) {
				log_warn("%s: can't save group %s",
				    __func__, s);
				goto fail;
			}
		}

		/* Set the interface status */
		vif->vif_flags =
		    vmc->vmc_ifflags[i] & (VMIFF_UP|VMIFF_OPTMASK);
	}

	/* Open TTY */
	if (vm->vm_ttyname == NULL) {
		if (vm_opentty(vm) == -1) {
			log_warn("%s: can't open tty %s", __func__,
			    vm->vm_ttyname == NULL ? "" : vm->vm_ttyname);
			goto fail;
		}
	}
	if ((fd = dup(vm->vm_tty)) == -1) {
		log_warn("%s: can't re-open tty %s", __func__, vm->vm_ttyname);
		goto fail;
	}

	/* Send VM information */
	proc_compose_imsg(ps, PROC_VMM, -1,
	    IMSG_VMDOP_START_VM_REQUEST, vm->vm_vmid, kernfd,
	    vmc, sizeof(*vmc));
	for (i = 0; i < vcp->vcp_ndisks; i++) {
		proc_compose_imsg(ps, PROC_VMM, -1,
		    IMSG_VMDOP_START_VM_DISK, vm->vm_vmid, diskfds[i],
		    &i, sizeof(i));
	}
	for (i = 0; i < vcp->vcp_nnics; i++) {
		proc_compose_imsg(ps, PROC_VMM, -1,
		    IMSG_VMDOP_START_VM_IF, vm->vm_vmid, tapfds[i],
		    &i, sizeof(i));
	}

	proc_compose_imsg(ps, PROC_VMM, -1,
	    IMSG_VMDOP_START_VM_END, vm->vm_vmid, fd,  NULL, 0);

	free(diskfds);
	free(tapfds);

	vm->vm_running = 1;
	return (0);

 fail:
	saved_errno = errno;
	log_warnx("%s: failed to start vm %s", __func__, vcp->vcp_name);

	if (kernfd != -1)
		close(kernfd);
	if (diskfds != NULL) {
		for (i = 0; i < vcp->vcp_ndisks; i++)
			close(diskfds[i]);
		free(diskfds);
	}
	if (tapfds != NULL) {
		for (i = 0; i < vcp->vcp_nnics; i++)
			close(tapfds[i]);
		free(tapfds);
	}

	vm_remove(vm);
	errno = saved_errno;
	if (errno == 0)
		errno = EINVAL;
	return (-1);
}

int
config_getvm(struct privsep *ps, struct imsg *imsg)
{
	struct vmop_create_params	 vmc;
	struct vmd_vm			*vm;

	IMSG_SIZE_CHECK(imsg, &vmc);
	memcpy(&vmc, imsg->data, sizeof(vmc));

	errno = 0;
	if (vm_register(ps, &vmc, &vm, imsg->hdr.peerid, 0) == -1)
		goto fail;

	/* If the fd is -1, the kernel will be searched on the disk */
	vm->vm_kernel = imsg->fd;
	vm->vm_running = 1;

	return (0);

 fail:
	if (imsg->fd != -1) {
		close(imsg->fd);
		imsg->fd = -1;
	}

	vm_remove(vm);
	if (errno == 0)
		errno = EINVAL;

	return (-1);
}

int
config_getdisk(struct privsep *ps, struct imsg *imsg)
{
	struct vmd_vm	*vm;
	unsigned int	 n;

	errno = 0;
	if ((vm = vm_getbyvmid(imsg->hdr.peerid)) == NULL) {
		errno = ENOENT;
		return (-1);
	}

	IMSG_SIZE_CHECK(imsg, &n);
	memcpy(&n, imsg->data, sizeof(n));

	if (n >= vm->vm_params.vmc_params.vcp_ndisks ||
	    vm->vm_disks[n] != -1 || imsg->fd == -1) {
		log_debug("invalid disk id");
		errno = EINVAL;
		return (-1);
	}
	vm->vm_disks[n] = imsg->fd;

	return (0);
}

int
config_getif(struct privsep *ps, struct imsg *imsg)
{
	struct vmd_vm	*vm;
	unsigned int	 n;

	errno = 0;
	if ((vm = vm_getbyvmid(imsg->hdr.peerid)) == NULL) {
		errno = ENOENT;
		return (-1);
	}

	IMSG_SIZE_CHECK(imsg, &n);
	memcpy(&n, imsg->data, sizeof(n));
	if (n >= vm->vm_params.vmc_params.vcp_nnics ||
	    vm->vm_ifs[n].vif_fd != -1 || imsg->fd == -1) {
		log_debug("invalid interface id");
		goto fail;
	}
	vm->vm_ifs[n].vif_fd = imsg->fd;

	return (0);
 fail:
	if (imsg->fd != -1)
		close(imsg->fd);
	errno = EINVAL;
	return (-1);
}
@


1.28
log
@Use the pseudo-bootloader if the boot image path matches the root disk path.

This allows to use the non-BIOS on-disk bootloader for testing.  It
might go away after release when we feel more confident about BIOS.

OK mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.27 2017/03/25 16:28:25 reyk Exp $	*/
d163 11
a173 11
	/* Boot ELF kernel from disk image if path matches the root disk */
	if (vcp->vcp_ndisks &&
	    strcmp(vcp->vcp_kernel, vcp->vcp_disks[0]) == 0)
		vmboot = 1;

	/* Open external kernel for child */
	if (strlen(vcp->vcp_kernel) && !vmboot &&
	    (kernfd = open(vcp->vcp_kernel, O_RDONLY)) == -1) {
		log_warn("%s: can't open kernel/BIOS boot image %s",
		    __func__, vcp->vcp_kernel);
		goto fail;
@


1.27
log
@Boot using BIOS from /etc/firmware/vmm-bios by default.

Instead of using the internal "vmboot", VMs will now be booted using
the external BIOS firmware in /etc/firmware/vmm-bios (which is subject
to a LGPLv3 license).  Direct booting of OpenBSD kernels or
non-default BIOS images is still supported for now using the -b/boot
option that is replacing the -k/kernel option.

As requested by Theo, vmd(8) fails if neither the default BIOS is
found nor a kernel has been specified in the VM configuration.  The
"vmm" BIOS has to be installed using fw_update(1), which will be done
automatically in most cases where the OpenBSD can fetch it after
install/upgrade.

OK mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.26 2017/03/02 07:33:37 reyk Exp $	*/
d129 1
a129 1
	int			 fd = -1;
d163 5
d169 1
a169 1
	if (strlen(vcp->vcp_kernel) &&
d181 1
a181 1
	if (kernfd == -1 &&
@


1.26
log
@Add "locked lladdr" option to prevent VMs from spoofing MAC addresses.

This is especially useful when multiple VMs share a switch, the
implementation is independent from the underlying switch or bridge.

no objections mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.25 2017/03/01 07:43:33 reyk Exp $	*/
d166 13
a178 2
		log_warn("%s: can't open kernel %s", __func__,
		    vcp->vcp_kernel);
@


1.25
log
@Add "owner" option to set a user/group ownership for pre-configured VMs

This allows matching users to start or stop VMs that they "own" and to
access the console accordingly.

OK mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.24 2017/02/27 14:37:58 reyk Exp $	*/
d239 2
a240 1
		vif->vif_flags = vmc->vmc_ifflags[i] & IFF_UP;
@


1.24
log
@Replace openpty(3) with local function that uses pre-opened /dev/ptm fd

This allows more flexibility for upcoming changes and better pledge.
We also didn't use half of the features of libutil's openpty function.
Additionally, make sure that the ttys are closed correctly on shutdown.

OK gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.23 2017/01/17 21:51:01 krw Exp $	*/
d123 1
a123 1
config_setvm(struct privsep *ps, struct vmd_vm *vm, uint32_t peerid)
d161 1
d313 1
a313 1
	if (vm_register(ps, &vmc, &vm, imsg->hdr.peerid) == -1)
@


1.23
log
@Nuke some whitespace that keeps poking me in the eye as I try to
steal code.
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.22 2016/12/14 06:59:12 reyk Exp $	*/
d129 1
a129 1
	int			 fd = -1, ttys_fd;
a131 1
	char			 ptyname[VM_TTYNAME_MAX];
d243 3
a245 3
		if (openpty(&vm->vm_tty, &ttys_fd, ptyname, NULL, NULL) == -1 ||
		    (vm->vm_ttyname = strdup(ptyname)) == NULL) {
			log_warn("%s: can't open tty %s", __func__, ptyname);
a247 1
		close(ttys_fd);
@


1.22
log
@If a VM terminates with the result EAGAIN, close all fds except the
pty and re-send it to the vmm monitor process.  With additional
changes in vmm.c, this will allow perform a cold reboot of VM.

With testing and feedback from Jon Bernard
OK mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.21 2016/11/24 07:58:55 reyk Exp $	*/
d341 1
a341 1
	
@


1.21
log
@Add support for booting the kernel from the disk image.

This make the kernel/-k argument optional and, if not specified, tries
to find the /bsd kernel in the primary hd0a partition of the first
disk image itself.  It doesn't support hd0a:/etc/boot.conf yet, and it
is no BIOS or full boot loader, but it makes booting and handling of
VMs a bit easier - booting an external kernel is still supported.

The UFS file system code ufs.c is directly from libsa which is also
used by the real boot loader.  The code compiles with a few signedness
warning which will be fixed separately.

OK mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.20 2016/11/22 21:55:54 reyk Exp $	*/
d129 1
a129 1
	int			 fd, ttys_fd;
d243 10
a252 3
	if (openpty(&fd, &ttys_fd, ptyname, NULL, NULL) == -1 ||
	    (vm->vm_ttyname = strdup(ptyname)) == NULL) {
		log_warn("%s: can't open tty %s", __func__, ptyname);
a254 1
	close(ttys_fd);
@


1.20
log
@Fix error path of config_setvm() and its callers.  This unbreaks
loading of invalid kernel files.

Reported by mlarkin@@
OK mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.19 2016/11/04 15:16:44 reyk Exp $	*/
d163 3
a165 2
	/* Open kernel for child */
	if ((kernfd = open(vcp->vcp_kernel, O_RDONLY)) == -1) {
d309 1
a309 1
		return (-1);
d311 1
a311 4
	if (imsg->fd == -1) {
		log_debug("invalid kernel fd");
		goto fail;
	}
@


1.19
log
@Pass the internal vmid or 0 to vm_register() instead of changing it
once again after setting the next available id.

Suggested by edd@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.18 2016/11/04 15:07:26 reyk Exp $	*/
d139 3
a141 1
	if (vm->vm_running)
d143 1
d147 1
a147 2
		saved_errno = errno;
		log_warn("%s: cannot allocate disk fds", __func__);
d155 1
a155 2
		saved_errno = errno;
		log_warn("%s: cannot allocate tap fds", __func__);
a164 1
		saved_errno = errno;
d174 1
a174 2
			saved_errno = errno;
			log_warn("%s: can't open %s", __func__,
d189 3
a191 3
				saved_errno = errno;
				log_warn("%s: invalid tap name",
				    __func__);
d209 1
a209 2
			saved_errno = errno;
			log_warn("%s: can't open %s", __func__, s);
d213 1
a213 2
			saved_errno = errno;
			log_warn("%s: can't save ifname", __func__);
d221 2
a222 3
				saved_errno = errno;
				log_warn("%s: can't save switch",
				    __func__);
d231 2
a232 3
				saved_errno = errno;
				log_warn("%s: can't save group",
				    __func__);
d244 1
a244 2
		saved_errno = errno;
		log_warn("%s: can't open tty", __func__);
d274 3
@


1.18
log
@Update the config/register/get VM methods to match the config_set/get
style that is used in other places.  Also keep the vmid from the parent.

OK edd@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.17 2016/10/29 14:56:05 edd Exp $	*/
d310 1
a310 1
	if (vm_register(ps, &vmc, &vm) == -1)
a318 1
	vm->vm_vmid = imsg->hdr.peerid;
@


1.17
log
@Separate parsing vms and switches from starting them in vmd(8).

Brings us one step closer to having disabled by default vms is vm.conf(5),
which can be started with vmctl(8).

Input, testing and OK reyk@@. Thanks.
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.16 2016/10/15 14:02:11 reyk Exp $	*/
d123 1
a123 59
config_registervm(struct privsep *ps, struct vmop_create_params *vmc,
    struct vmd_vm **ret_vm)
{
	struct vmd		*env = ps->ps_env;
	struct vmd_vm		*vm = NULL;
	struct vm_create_params	*vcp = &vmc->vmc_params;
	unsigned int		 i;

	errno = 0;
	*ret_vm = NULL;

	if ((vm = vm_getbyname(vcp->vcp_name)) != NULL) {
		*ret_vm = vm;
		errno = EALREADY;
		goto fail;
	}

	if (vcp->vcp_ncpus == 0)
		vcp->vcp_ncpus = 1;
	if (vcp->vcp_ncpus > VMM_MAX_VCPUS_PER_VM) {
		log_debug("invalid number of CPUs");
		goto fail;
	} else if (vcp->vcp_ndisks > VMM_MAX_DISKS_PER_VM) {
		log_debug("invalid number of disks");
		goto fail;
	} else if (vcp->vcp_nnics > VMM_MAX_NICS_PER_VM) {
		log_debug("invalid number of interfaces");
		goto fail;
	}

	if ((vm = calloc(1, sizeof(*vm))) == NULL)
		goto fail;

	memcpy(&vm->vm_params, vmc, sizeof(vm->vm_params));
	vm->vm_pid = -1;

	for (i = 0; i < vcp->vcp_ndisks; i++)
		vm->vm_disks[i] = -1;
	for (i = 0; i < vcp->vcp_nnics; i++)
		vm->vm_ifs[i].vif_fd = -1;
	vm->vm_kernel = -1;
	vm->vm_vmid = env->vmd_nvm + 1;

	if (vm_getbyvmid(vm->vm_vmid) != NULL)
		fatalx("too many vms");

	TAILQ_INSERT_TAIL(env->vmd_vms, vm, vm_entry);
	env->vmd_nvm++;
	*ret_vm = vm;
	return (0);
fail:
	if (errno == 0)
		errno = EINVAL;
	return (-1);
}

int
config_getvm(struct privsep *ps, struct vmd_vm *vm,
    int kernel_fd, uint32_t peerid)
d142 32
a173 11
	switch (privsep_process) {
	case PROC_VMM:
		if (kernel_fd == -1) {
			log_debug("invalid kernel fd");
			goto fail;
		}
		vm->vm_kernel = kernel_fd;
		break;
	case PROC_PARENT:
		diskfds = reallocarray(NULL, vcp->vcp_ndisks, sizeof(*diskfds));
		if (diskfds == NULL) {
d175 2
a176 1
			log_warn("%s: cannot allocate disk fds", __func__);
d179 18
a196 2
		for (i = 0; i < vcp->vcp_ndisks; i++)
			diskfds[i] = -1;
d198 12
a209 2
		tapfds = reallocarray(NULL, vcp->vcp_nnics, sizeof(*tapfds));
		if (tapfds == NULL) {
d211 1
a211 1
			log_warn("%s: cannot allocate tap fds", __func__);
d214 1
a214 7
		for (i = 0; i < vcp->vcp_nnics; i++)
			tapfds[i] = -1;

		vm->vm_peerid = peerid;

		/* Open kernel for child */
		if ((kernfd = open(vcp->vcp_kernel, O_RDONLY)) == -1) {
d216 1
a216 2
			log_warn("%s: can't open kernel %s", __func__,
			    vcp->vcp_kernel);
d220 4
a223 4
		/* Open disk images for child */
		for (i = 0 ; i < vcp->vcp_ndisks; i++) {
			if ((diskfds[i] =
			    open(vcp->vcp_disks[i], O_RDWR)) == -1) {
d225 2
a226 2
				log_warn("%s: can't open %s", __func__,
				    vcp->vcp_disks[i]);
d231 4
a234 29
		/* Open network interfaces */
		for (i = 0 ; i < vcp->vcp_nnics; i++) {
			vif = &vm->vm_ifs[i];

			/* Check if the user has requested a specific tap(4) */
			s = vmc->vmc_ifnames[i];
			if (*s != '\0' && strcmp("tap", s) != 0) {
				if (priv_getiftype(s, ifname, &unit) == -1 ||
				    strcmp(ifname, "tap") != 0) {
					saved_errno = errno;
					log_warn("%s: invalid tap name",
					    __func__);
					goto fail;
				}
			} else
				s = NULL;

			/*
			 * Either open the requested tap(4) device or get
			 * the next available one.
			 */
			if (s != NULL) {
				snprintf(path, PATH_MAX, "/dev/%s", s);
				tapfds[i] = open(path, O_RDWR | O_NONBLOCK);
			} else {
				tapfds[i] = opentap(ifname);
				s = ifname;
			}
			if (tapfds[i] == -1) {
d236 2
a237 6
				log_warn("%s: can't open %s", __func__, s);
				goto fail;
			}
			if ((vif->vif_name = strdup(s)) == NULL) {
				saved_errno = errno;
				log_warn("%s: can't save ifname", __func__);
d240 1
d242 3
a244 10
			/* Check if the the interface is attached to a switch */
			s = vmc->vmc_ifswitch[i];
			if (*s != '\0') {
				if ((vif->vif_switch = strdup(s)) == NULL) {
					saved_errno = errno;
					log_warn("%s: can't save switch",
					    __func__);
					goto fail;
				}
			}
d246 8
a253 14
			/* Check if the the interface is assigned to a group */
			s = vmc->vmc_ifgroup[i];
			if (*s != '\0') {
				if ((vif->vif_group = strdup(s)) == NULL) {
					saved_errno = errno;
					log_warn("%s: can't save group",
					    __func__);
					goto fail;
				}
			}

			/* Set the interface status */
			vif->vif_flags = vmc->vmc_ifflags[i] & IFF_UP;
		}
d255 5
a259 10
		/* Open TTY */
		if (openpty(&fd, &ttys_fd, ptyname, NULL, NULL) == -1 ||
		    (vm->vm_ttyname = strdup(ptyname)) == NULL) {
			saved_errno = errno;
			log_warn("%s: can't open tty", __func__);
			goto fail;
		}
		close(ttys_fd);

		/* Send VM information */
d261 4
a264 13
		    IMSG_VMDOP_START_VM_REQUEST, vm->vm_vmid, kernfd,
		    vmc, sizeof(*vmc));
		for (i = 0; i < vcp->vcp_ndisks; i++) {
			proc_compose_imsg(ps, PROC_VMM, -1,
			    IMSG_VMDOP_START_VM_DISK, vm->vm_vmid, diskfds[i],
			    &i, sizeof(i));
		}
		for (i = 0; i < vcp->vcp_nnics; i++) {
			proc_compose_imsg(ps, PROC_VMM, -1,
			    IMSG_VMDOP_START_VM_IF, vm->vm_vmid, tapfds[i],
			    &i, sizeof(i));
		}

d266 2
a267 4
		    IMSG_VMDOP_START_VM_END, vm->vm_vmid, fd,  NULL, 0);
		break;
	default:
		fatalx("vm received by invalid process");
d270 3
d297 36
@


1.16
log
@Allow to add an interface to an interface group; with the group keyword.

Requested and tested by martijn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.15 2016/10/12 10:58:32 reyk Exp $	*/
d123 2
a124 2
config_getvm(struct privsep *ps, struct vmop_create_params *vmc,
    int kernel_fd, uint32_t peerid)
a127 1
	struct vmd_if		*vif;
a129 7
	int			 fd, ttys_fd;
	int			 kernfd = -1, *diskfds = NULL, *tapfds = NULL;
	int			 saved_errno = 0;
	char			 ptyname[VM_TTYNAME_MAX];
	char			 ifname[IF_NAMESIZE], *s;
	char			 path[PATH_MAX];
	unsigned int		 unit;
d132 1
d134 3
a136 2
	if (vm_getbyname(vcp->vcp_name) != NULL) {
		saved_errno = errno = EALREADY;
d156 1
a156 1
	memcpy(&vm->vm_params, vcp, sizeof(vm->vm_params));
d170 29
d347 1
a347 1
	env->vmd_nvm++;
d386 1
a386 1
	if (n >= vm->vm_params.vcp_ndisks ||
d411 1
a411 1
	if (n >= vm->vm_params.vcp_nnics ||
@


1.15
log
@The error case checks for saved_errno, set it accordingly
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.14 2016/10/05 17:30:13 reyk Exp $	*/
d270 11
@


1.14
log
@Add support for enhanced networking configuration and virtual switches.
See vm.conf(5) for more details.

OK mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.13 2016/10/04 17:17:30 reyk Exp $	*/
d142 1
a142 1
		errno = EALREADY;
@


1.13
log
@Add a new "priv" process that is responsible for ioctls and restricted
operations that aren't allowed under pledge.  This is a companion to
the "vmd" process that runs as root but with pledge.

With the "priv" process, each new tap(4) interface now gets a
description to indicate the vm, eg. "vm1-if0-myvm".  For network
configuration will be done by vmd/priv later.

OK mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.12 2016/09/29 22:42:04 reyk Exp $	*/
d41 3
d62 6
d77 1
d84 6
a89 1
		env->vmd_vmcount = 0;
d123 1
a123 1
config_getvm(struct privsep *ps, struct vm_create_params *vcp,
d128 2
d135 3
a137 1
	char			 ifname[IF_NAMESIZE];
d168 1
a168 1
		vm->vm_ifs[i] = -1;
d225 1
a225 1
		/* Open disk network interfaces */
d227 27
a253 1
			if ((tapfds[i] = opentap(ifname)) == -1) {
d255 1
a255 1
				log_warn("%s: can't open tap", __func__);
d258 1
a258 2

			if ((vm->vm_ifnames[i] = strdup(ifname)) == NULL) {
d263 14
d291 1
a291 1
		    vcp, sizeof(*vcp));
d378 1
a378 1
	    vm->vm_ifs[n] != -1 || imsg->fd == -1) {
d382 1
a382 1
	vm->vm_ifs[n] = imsg->fd;
a389 1
	
@


1.12
log
@Implement fork+exec for vmd, using the same framework from httpd etc.

No objections from mlarkin@@ sunil@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.11 2016/09/03 10:20:06 stefan Exp $	*/
d23 3
d50 1
d117 2
d158 2
a159 1
	if (privsep_process != PROC_PARENT) {
d165 2
a166 1
	} else {
d208 1
a208 1
			if ((tapfds[i] = opentap()) == -1) {
d213 6
d222 2
a223 2
		if (openpty(&fd, &ttys_fd,
		    vm->vm_ttyname, NULL, NULL) == -1) {
d246 4
a249 2
		    IMSG_VMDOP_START_VM_END, vm->vm_vmid, fd,
		    vcp, sizeof(*vcp));
d322 1
a322 2
		errno = EINVAL;
		return (-1);
d327 6
@


1.11
log
@Make error handling in config_getvm() more robust

Open all fds first before sending messages to the vmm process.
This prevents some intermediate state from being generated that
will confuse vmm if it gets further messages.

Also make sure that vmctl gets the right error reason later by saving
errno upon a failure.

ok reyk@@ mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.10 2016/07/29 16:36:51 stefan Exp $	*/
d45 2
a46 4
	if (privsep_process == PROC_PARENT) {
		ps->ps_what[PROC_PARENT] = CONFIG_ALL;
		ps->ps_what[PROC_VMM] = CONFIG_VMS;
	}
@


1.10
log
@Allow starting a VM again after it was terminated

If a VM exits, terminate it and remove it from the list of
available VMs. That allows a VM with name `foo' to be restarted
after it has exited.

This changes structures shared between vmd and vmctl. You need to
rebuild vmctl also.

ok mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.9 2015/12/07 15:57:53 reyk Exp $	*/
d113 2
d161 18
d182 2
a183 1
		if ((fd = open(vcp->vcp_kernel, O_RDONLY)) == -1) {
a188 4
		proc_compose_imsg(ps, PROC_VMM, -1,
		    IMSG_VMDOP_START_VM_REQUEST, vm->vm_vmid, fd,
		    vcp, sizeof(*vcp));

d191 3
a193 1
			if ((fd = open(vcp->vcp_disks[i], O_RDWR)) == -1) {
a197 3
			proc_compose_imsg(ps, PROC_VMM, -1,
			    IMSG_VMDOP_START_VM_DISK, vm->vm_vmid, fd,
			    &i, sizeof(i));
d202 2
a203 1
			if ((fd = opentap()) == -1) {
a206 3
			proc_compose_imsg(ps, PROC_VMM, -1,
			    IMSG_VMDOP_START_VM_IF, vm->vm_vmid, fd,
			    &i, sizeof(i));
d212 1
d218 15
d238 3
d245 15
a261 1
	vm_remove(vm);
@


1.9
log
@Only increment the vm counter after successfully adding a new vm; the
counter has to be in sync in the parent and vmm processes.  This fixes
reload after a previous load error.
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.8 2015/12/07 14:43:24 reyk Exp $	*/
d138 1
@


1.8
log
@Fix error handling in a few cases: some function return (-1) on error,
while others return (errno) on error.  We probably have to agree on
something.
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.7 2015/12/06 21:02:51 reyk Exp $	*/
d144 1
a144 1
	vm->vm_vmid = ++env->vmd_nvm;
d207 1
@


1.7
log
@Prevent running a VM with the same name multiple times - multiple
instances of the same configuration will be handled in a different way
later.  It is also not a good idea to use the same writeable disk
with multiple VMs at the same time.

As discussed with mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.6 2015/12/06 01:14:08 reyk Exp $	*/
d221 4
a224 2

	if ((vm = vm_getbyvmid(imsg->hdr.peerid)) == NULL)
d226 1
d234 1
d248 3
a250 1
	if ((vm = vm_getbyvmid(imsg->hdr.peerid)) == NULL)
d252 1
d259 1
@


1.6
log
@Report errno from config_getvm() correctly
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.5 2015/12/04 10:54:21 reyk Exp $	*/
d115 5
@


1.5
log
@A VM has to run with at least 1 CPU.
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.4 2015/12/03 23:32:32 reyk Exp $	*/
d32 1
d110 1
a110 1
	struct vmd_vm		*vm;
d114 2
d120 1
a120 1
		return (-1);
d123 1
a123 1
		return (-1);
d126 1
a126 1
		return (-1);
d130 1
a130 1
		return (-1);
d205 2
@


1.4
log
@Re-add the "load" and "reload" commands to vmctl: Instead of parsing
the configuration in vmctl directly, it now sends a (re)load request
to vmd.  The reload also resets the existing configuration status -
this doesn't do much difference yet but a future change will compare
if a specified VM is already running.  "load" will allow to add
configuration, while "reload" resets the state before loading.
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.3 2015/12/03 16:11:32 reyk Exp $	*/
d113 2
@


1.3
log
@Add support for an optional vm.conf(5) file in vmd.  This will replace
vmm.conf(5) in vmmctl.  For a short time, both vmd and vmmctl will
support a configuration file, but vmmctl will be changed to send
"load" requests to vmd instead of loading and parsing the file
directly.
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.2 2015/12/03 13:27:14 reyk Exp $	*/
d41 1
a41 1
	u_int		 what;
d61 1
a61 1
config_purge(struct vmd *env, u_int reset)
d65 1
a65 1
	u_int			 what;
a67 1

d76 1
a76 1
config_setreset(struct vmd *env, u_int reset)
@


1.2
log
@prepare config_getvm() for parse.y
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.1 2015/12/02 22:19:11 reyk Exp $	*/
a191 2

		log_info("%s console: %s", vcp->vcp_name, vm->vm_ttyname);
@


1.1
log
@Split the fully privileged parent into two processes "parent" and
"vmm" with reduced privileges:
- the "parent" opens fds (disks, ifs, etc.) but runs as root but pledged as
  "stdio rpath wpath proc tty sendfd".
- the "vmm" process handles the creation and supervision of vm processes,
  and the primary communication with the vmm(4) subsystem.  It runs as _vmd
  in the chroot but does not use pledge, as the vmm ioctls are not allowed
  by any pledge model yet.
With this change, vmd starts to track the configuration state of VMs
in vmd and will allow other things later (like terminating a vm by
name, moving the configuration parser to vmd, ...).  More incremental
changes will follow.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d106 2
a107 1
config_getvm(struct privsep *ps, struct imsg *imsg)
a110 1
	struct vm_create_params	 vcp;
d114 1
a114 4
	IMSG_SIZE_CHECK(imsg, &vcp);
	memcpy(&vcp, imsg->data, sizeof(vcp));

	if (vcp.vcp_ncpus > VMM_MAX_VCPUS_PER_VM) {
d117 1
a117 1
	} else if (vcp.vcp_ndisks > VMM_MAX_DISKS_PER_VM) {
d120 1
a120 1
	} else if (vcp.vcp_nnics > VMM_MAX_NICS_PER_VM) {
d128 1
a128 1
	memcpy(&vm->vm_params, &vcp, sizeof(vm->vm_params));
d130 1
a130 1
	for (i = 0; i < vcp.vcp_ndisks; i++)
d132 1
a132 1
	for (i = 0; i < vcp.vcp_nnics; i++)
d143 1
a143 1
		if (imsg->fd == -1) {
d147 1
a147 1
		vm->vm_kernel = imsg->fd;
d149 1
a149 1
		vm->vm_peerid = imsg->hdr.peerid;
d152 1
a152 1
		if ((fd = open(vcp.vcp_kernel, O_RDONLY)) == -1) {
d154 1
a154 1
			    vcp.vcp_kernel);
d160 1
a160 1
		    &vcp, sizeof(vcp));
d163 2
a164 2
		for (i = 0 ; i < vcp.vcp_ndisks; i++) {
			if ((fd = open(vcp.vcp_disks[i], O_RDWR)) == -1) {
d166 1
a166 1
				    vcp.vcp_disks[i]);
d175 1
a175 1
		for (i = 0 ; i < vcp.vcp_nnics; i++) {
d193 1
a193 1
		log_info("%s console: %s", vcp.vcp_name, vm->vm_ttyname);
d197 1
a197 1
		    &vcp, sizeof(vcp));
@

