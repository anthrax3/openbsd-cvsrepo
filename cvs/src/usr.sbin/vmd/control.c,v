head	1.22;
access;
symbols
	OPENBSD_6_2_BASE:1.22
	OPENBSD_6_1:1.16.0.4
	OPENBSD_6_1_BASE:1.16
	OPENBSD_6_0:1.6.0.4
	OPENBSD_6_0_BASE:1.6
	OPENBSD_5_9:1.6.0.2
	OPENBSD_5_9_BASE:1.6;
locks; strict;
comment	@ * @;


1.22
date	2017.09.08.06.24.31;	author mlarkin;	state Exp;
branches;
next	1.21;
commitid	37UN1o4XIuz3jrZc;

1.21
date	2017.07.15.05.05.36;	author pd;	state Exp;
branches;
next	1.20;
commitid	l7Kfh3b63PsFu8PF;

1.20
date	2017.07.09.00.51.40;	author pd;	state Exp;
branches;
next	1.19;
commitid	qGhsIrgsAzfqzJtv;

1.19
date	2017.05.04.19.41.58;	author reyk;	state Exp;
branches;
next	1.18;
commitid	ygf0Wmp9XnmAli8A;

1.18
date	2017.05.04.16.54.41;	author reyk;	state Exp;
branches;
next	1.17;
commitid	w2yDm1gwVPaym65O;

1.17
date	2017.04.21.07.03.26;	author reyk;	state Exp;
branches;
next	1.16;
commitid	B4wb6zF2A8q3ls4h;

1.16
date	2017.03.15.12.42.12;	author reyk;	state Exp;
branches;
next	1.15;
commitid	I98gUJzc28x1li6L;

1.15
date	2017.03.01.07.43.33;	author reyk;	state Exp;
branches;
next	1.14;
commitid	2hnfyuVZdSB2L5DB;

1.14
date	2017.02.27.12.07.58;	author reyk;	state Exp;
branches;
next	1.13;
commitid	2rEBXWSA0PUrByVw;

1.13
date	2017.01.17.21.51.01;	author krw;	state Exp;
branches;
next	1.12;
commitid	7aASaBYKS1WgBK9H;

1.12
date	2017.01.09.22.06.25;	author reyk;	state Exp;
branches;
next	1.11;
commitid	Hfa6cFmfDJEVYVKU;

1.11
date	2017.01.09.14.49.22;	author reyk;	state Exp;
branches;
next	1.10;
commitid	eA8b246voAapPTkX;

1.10
date	2017.01.09.14.04.31;	author krw;	state Exp;
branches;
next	1.9;
commitid	KJkQGNLsnMxWc9MG;

1.9
date	2016.10.12.19.10.03;	author reyk;	state Exp;
branches;
next	1.8;
commitid	ghkPP3DbrIiwazmp;

1.8
date	2016.09.29.22.42.04;	author reyk;	state Exp;
branches;
next	1.7;
commitid	OrqC5N55KjzTfX1Z;

1.7
date	2016.08.17.05.07.13;	author deraadt;	state Exp;
branches;
next	1.6;
commitid	qqWoBqCGCbsKOAqY;

1.6
date	2016.01.10.10.01.07;	author jsg;	state Exp;
branches;
next	1.5;
commitid	8X9p2TtKVlbZFJ4I;

1.5
date	2015.12.05.17.30.34;	author claudio;	state Exp;
branches;
next	1.4;
commitid	HZtr1GvWPr0Bg8in;

1.4
date	2015.12.03.23.32.32;	author reyk;	state Exp;
branches;
next	1.3;
commitid	ABlEnH3RsSBpSsyK;

1.3
date	2015.12.03.13.08.44;	author reyk;	state Exp;
branches;
next	1.2;
commitid	x0i6sqLF0crQTgU8;

1.2
date	2015.12.02.22.19.11;	author reyk;	state Exp;
branches;
next	1.1;
commitid	7ra6VeOJoUb1NQ70;

1.1
date	2015.12.02.09.14.25;	author reyk;	state Exp;
branches;
next	;
commitid	vOctzllSJTLtnazM;


desc
@@


1.22
log
@vmd: add more explanatory log_debug messages

From Carlos Cardenas, many thanks!
@
text
@/*	$OpenBSD: control.c,v 1.21 2017/07/15 05:05:36 pd Exp $	*/

/*
 * Copyright (c) 2010-2015 Reyk Floeter <reyk@@openbsd.org>
 * Copyright (c) 2003, 2004 Henning Brauer <henning@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/param.h>	/* nitems */
#include <sys/queue.h>
#include <sys/stat.h>
#include <sys/socket.h>
#include <sys/un.h>
#include <sys/tree.h>

#include <net/if.h>

#include <errno.h>
#include <event.h>
#include <fcntl.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <signal.h>

#include "proc.h"
#include "vmd.h"

#define	CONTROL_BACKLOG	5

struct ctl_connlist ctl_conns;

void
	 control_accept(int, short, void *);
struct ctl_conn
	*control_connbyfd(int);
void	 control_close(int, struct control_sock *);
void	 control_dispatch_imsg(int, short, void *);
int	 control_dispatch_vmd(int, struct privsep_proc *, struct imsg *);
void	 control_imsg_forward(struct imsg *);
void	 control_run(struct privsep *, struct privsep_proc *, void *);

static struct privsep_proc procs[] = {
	{ "parent",	PROC_PARENT,	control_dispatch_vmd }
};

void
control(struct privsep *ps, struct privsep_proc *p)
{
	proc_run(ps, p, procs, nitems(procs), control_run, NULL);
}

void
control_run(struct privsep *ps, struct privsep_proc *p, void *arg)
{
	/*
	 * pledge in the control process:
	 * stdio - for malloc and basic I/O including events.
	 * cpath - for managing the control socket.
	 * unix - for the control socket.
	 * recvfd - for the proc fd exchange.
	 * sendfd - for send and receive.
	 */
	if (pledge("stdio cpath unix recvfd sendfd", NULL) == -1)
		fatal("pledge");
}

int
control_dispatch_vmd(int fd, struct privsep_proc *p, struct imsg *imsg)
{
	struct ctl_conn		*c;
	struct privsep		*ps = p->p_ps;

	switch (imsg->hdr.type) {
	case IMSG_VMDOP_START_VM_RESPONSE:
	case IMSG_VMDOP_PAUSE_VM_RESPONSE:
	case IMSG_VMDOP_SEND_VM_RESPONSE:
	case IMSG_VMDOP_RECEIVE_VM_RESPONSE:
	case IMSG_VMDOP_UNPAUSE_VM_RESPONSE:
	case IMSG_VMDOP_TERMINATE_VM_RESPONSE:
	case IMSG_VMDOP_GET_INFO_VM_DATA:
	case IMSG_VMDOP_GET_INFO_VM_END_DATA:
	case IMSG_CTL_FAIL:
	case IMSG_CTL_OK:
		if ((c = control_connbyfd(imsg->hdr.peerid)) == NULL) {
			log_warnx("%s: lost control connection: fd %d",
			    __func__, imsg->hdr.peerid);
			return (0);
		}
		imsg_compose_event(&c->iev, imsg->hdr.type,
		    0, 0, imsg->fd, imsg->data, IMSG_DATA_SIZE(imsg));
		break;
	case IMSG_VMDOP_CONFIG:
		config_getconfig(ps->ps_env, imsg);
		break;
	case IMSG_CTL_RESET:
		config_getreset(ps->ps_env, imsg);
		break;
	default:
		return (-1);
	}

	return (0);
}

int
control_init(struct privsep *ps, struct control_sock *cs)
{
	struct sockaddr_un	 sun;
	int			 fd;
	mode_t			 old_umask, mode;

	if (cs->cs_name == NULL)
		return (0);

	if ((fd = socket(AF_UNIX, SOCK_STREAM | SOCK_NONBLOCK, 0)) == -1) {
		log_warn("%s: socket", __func__);
		return (-1);
	}

	sun.sun_family = AF_UNIX;
	if (strlcpy(sun.sun_path, cs->cs_name,
	    sizeof(sun.sun_path)) >= sizeof(sun.sun_path)) {
		log_warn("%s: %s name too long", __func__, cs->cs_name);
		close(fd);
		return (-1);
	}

	if (unlink(cs->cs_name) == -1)
		if (errno != ENOENT) {
			log_warn("%s: unlink %s", __func__, cs->cs_name);
			close(fd);
			return (-1);
		}

	if (cs->cs_restricted) {
		old_umask = umask(S_IXUSR|S_IXGRP|S_IXOTH);
		mode = S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH;
	} else {
		old_umask = umask(S_IXUSR|S_IXGRP|S_IWOTH|S_IROTH|S_IXOTH);
		mode = S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP;
	}

	if (bind(fd, (struct sockaddr *)&sun, sizeof(sun)) == -1) {
		log_warn("%s: bind: %s", __func__, cs->cs_name);
		close(fd);
		(void)umask(old_umask);
		return (-1);
	}
	(void)umask(old_umask);

	if (chmod(cs->cs_name, mode) == -1) {
		log_warn("%s: chmod", __func__);
		close(fd);
		(void)unlink(cs->cs_name);
		return (-1);
	}

	cs->cs_fd = fd;
	cs->cs_env = ps;

	return (0);
}

int
control_listen(struct control_sock *cs)
{
	if (cs->cs_name == NULL)
		return (0);

	if (listen(cs->cs_fd, CONTROL_BACKLOG) == -1) {
		log_warn("%s: listen", __func__);
		return (-1);
	}

	event_set(&cs->cs_ev, cs->cs_fd, EV_READ,
	    control_accept, cs);
	event_add(&cs->cs_ev, NULL);
	evtimer_set(&cs->cs_evt, control_accept, cs);

	return (0);
}

void
control_cleanup(struct control_sock *cs)
{
	if (cs->cs_name == NULL)
		return;
	event_del(&cs->cs_ev);
	event_del(&cs->cs_evt);
}

/* ARGSUSED */
void
control_accept(int listenfd, short event, void *arg)
{
	struct control_sock	*cs = arg;
	int			 connfd;
	socklen_t		 len;
	struct sockaddr_un	 sun;
	struct ctl_conn		*c;

	event_add(&cs->cs_ev, NULL);
	if ((event & EV_TIMEOUT))
		return;

	len = sizeof(sun);
	if ((connfd = accept4(listenfd,
	    (struct sockaddr *)&sun, &len, SOCK_NONBLOCK)) == -1) {
		/*
		 * Pause accept if we are out of file descriptors, or
		 * libevent will haunt us here too.
		 */
		if (errno == ENFILE || errno == EMFILE) {
			struct timeval evtpause = { 1, 0 };

			event_del(&cs->cs_ev);
			evtimer_add(&cs->cs_evt, &evtpause);
		} else if (errno != EWOULDBLOCK && errno != EINTR &&
		    errno != ECONNABORTED)
			log_warn("%s: accept", __func__);
		return;
	}

	if ((c = calloc(1, sizeof(struct ctl_conn))) == NULL) {
		log_warn("%s", __func__);
		close(connfd);
		return;
	}

	if (getsockopt(connfd, SOL_SOCKET, SO_PEERCRED,
	    &c->peercred, &len) != 0) {
		log_warn("%s: failed to get peer credentials", __func__);
		close(connfd);
		free(c);
		return;
	}

	imsg_init(&c->iev.ibuf, connfd);
	c->iev.handler = control_dispatch_imsg;
	c->iev.events = EV_READ;
	c->iev.data = cs;
	event_set(&c->iev.ev, c->iev.ibuf.fd, c->iev.events,
	    c->iev.handler, c->iev.data);
	event_add(&c->iev.ev, NULL);

	TAILQ_INSERT_TAIL(&ctl_conns, c, entry);
}

struct ctl_conn *
control_connbyfd(int fd)
{
	struct ctl_conn	*c;

	TAILQ_FOREACH(c, &ctl_conns, entry) {
		if (c->iev.ibuf.fd == fd)
			break;
	}

	return (c);
}

void
control_close(int fd, struct control_sock *cs)
{
	struct ctl_conn	*c;

	if ((c = control_connbyfd(fd)) == NULL) {
		log_warn("%s: fd %d: not found", __func__, fd);
		return;
	}

	msgbuf_clear(&c->iev.ibuf.w);
	TAILQ_REMOVE(&ctl_conns, c, entry);

	event_del(&c->iev.ev);
	close(c->iev.ibuf.fd);

	/* Some file descriptors are available again. */
	if (evtimer_pending(&cs->cs_evt, NULL)) {
		evtimer_del(&cs->cs_evt);
		event_add(&cs->cs_ev, NULL);
	}

	free(c);
}

/* ARGSUSED */
void
control_dispatch_imsg(int fd, short event, void *arg)
{
	struct control_sock		*cs = arg;
	struct privsep			*ps = cs->cs_env;
	struct ctl_conn			*c;
	struct imsg			 imsg;
	struct vmop_create_params	 vmc;
	struct vmop_id			 vid;
	int				 n, v, ret = 0;

	if ((c = control_connbyfd(fd)) == NULL) {
		log_warn("%s: fd %d: not found", __func__, fd);
		return;
	}

	if (event & EV_READ) {
		if (((n = imsg_read(&c->iev.ibuf)) == -1 && errno != EAGAIN) ||
		    n == 0) {
			control_close(fd, cs);
			return;
		}
	}
	if (event & EV_WRITE) {
		if (msgbuf_write(&c->iev.ibuf.w) <= 0 && errno != EAGAIN) {
			control_close(fd, cs);
			return;
		}
	}

	for (;;) {
		if ((n = imsg_get(&c->iev.ibuf, &imsg)) == -1) {
			control_close(fd, cs);
			return;
		}

		if (n == 0)
			break;

		switch (imsg.hdr.type) {
		case IMSG_VMDOP_GET_INFO_VM_REQUEST:
		case IMSG_VMDOP_TERMINATE_VM_REQUEST:
		case IMSG_VMDOP_START_VM_REQUEST:
			break;
		default:
			if (c->peercred.uid != 0) {
				log_warnx("denied request %d from uid %d",
				    imsg.hdr.type, c->peercred.uid);
				ret = EPERM;
				goto fail;
			}
			break;
		}

		control_imsg_forward(&imsg);

		switch (imsg.hdr.type) {
		case IMSG_CTL_NOTIFY:
			if (c->flags & CTL_CONN_NOTIFY) {
				log_debug("%s: "
				    "client requested notify more than once",
				    __func__);
				ret = EINVAL;
				goto fail;
			}
			c->flags |= CTL_CONN_NOTIFY;
			break;
		case IMSG_CTL_VERBOSE:
			if (IMSG_DATA_SIZE(&imsg) < sizeof(v))
				goto fail;
			memcpy(&v, imsg.data, sizeof(v));
			log_setverbose(v);

			/* FALLTHROUGH */
		case IMSG_VMDOP_RECEIVE_VM_REQUEST:
		case IMSG_VMDOP_SEND_VM_REQUEST:
		case IMSG_VMDOP_PAUSE_VM:
		case IMSG_VMDOP_UNPAUSE_VM:
		case IMSG_VMDOP_LOAD:
		case IMSG_VMDOP_RELOAD:
		case IMSG_CTL_RESET:
			if (proc_compose_imsg(ps, PROC_PARENT, -1,
			    imsg.hdr.type, fd, imsg.fd,
			    imsg.data, IMSG_DATA_SIZE(&imsg)) == -1)
				goto fail;
			break;
		case IMSG_VMDOP_START_VM_REQUEST:
			if (IMSG_DATA_SIZE(&imsg) < sizeof(vmc))
				goto fail;
			memcpy(&vmc, imsg.data, sizeof(vmc));
			vmc.vmc_uid = c->peercred.uid;
			vmc.vmc_gid = -1;

			if (proc_compose_imsg(ps, PROC_PARENT, -1,
			    imsg.hdr.type, fd, -1, &vmc, sizeof(vmc)) == -1) {
				control_close(fd, cs);
				return;
			}
			break;
		case IMSG_VMDOP_TERMINATE_VM_REQUEST:
			if (IMSG_DATA_SIZE(&imsg) < sizeof(vid))
				goto fail;
			memcpy(&vid, imsg.data, sizeof(vid));
			vid.vid_uid = c->peercred.uid;
			log_debug("%s id: %d, name: %s, uid: %d",
			    __func__, vid.vid_id, vid.vid_name,
			    vid.vid_uid);

			if (proc_compose_imsg(ps, PROC_PARENT, -1,
			    imsg.hdr.type, fd, -1, &vid, sizeof(vid)) == -1) {
				log_debug("%s: proc_compose_imsg failed",
				    __func__);
				control_close(fd, cs);
				return;
			}
			break;
		case IMSG_VMDOP_GET_INFO_VM_REQUEST:
			if (IMSG_DATA_SIZE(&imsg) != 0)
				goto fail;
			if (proc_compose_imsg(ps, PROC_PARENT, -1,
			    imsg.hdr.type, fd, -1, NULL, 0) == -1) {
				control_close(fd, cs);
				return;
			}
			break;
		default:
			log_debug("%s: error handling imsg %d",
			    __func__, imsg.hdr.type);
			control_close(fd, cs);
			break;
		}
		imsg_free(&imsg);
	}

	imsg_event_add(&c->iev);
	return;

 fail:
	if (ret == 0)
		ret = EINVAL;
	imsg_compose_event(&c->iev, IMSG_CTL_FAIL,
	    0, 0, -1, &ret, sizeof(ret));
	imsg_flush(&c->iev.ibuf);
	control_close(fd, cs);
}

void
control_imsg_forward(struct imsg *imsg)
{
	struct ctl_conn *c;

	TAILQ_FOREACH(c, &ctl_conns, entry)
		if (c->flags & CTL_CONN_NOTIFY)
			imsg_compose_event(&c->iev, imsg->hdr.type,
			    imsg->hdr.peerid, imsg->hdr.pid, -1, imsg->data,
			    imsg->hdr.len - IMSG_HEADER_SIZE);
}
@


1.21
log
@Add vmctl send and vmctl receive

ok reyk@@ and mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.20 2017/07/09 00:51:40 pd Exp $	*/
d404 3
d410 2
@


1.20
log
@vmd/vmctl: Add ability to pause / unpause vms

With help from Ashwin Agrawal

ok reyk@@ mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.19 2017/05/04 19:41:58 reyk Exp $	*/
d73 1
d75 1
a75 1
	if (pledge("stdio cpath unix recvfd", NULL) == -1)
d88 2
d102 1
a102 1
		    0, 0, -1, imsg->data, IMSG_DATA_SIZE(imsg));
d374 2
d382 1
a382 1
			    imsg.hdr.type, fd, -1,
@


1.19
log
@Report command failure back to vmctl reload, reset, load, log verbose.

OK mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.18 2017/05/04 16:54:41 reyk Exp $	*/
d86 2
d371 2
@


1.18
log
@Report error for vmctl commands that need root privileges.

specifically: vmctl (load|reload|reset|log)

Reported by Christian Barthel
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.17 2017/04/21 07:03:26 reyk Exp $	*/
d89 2
d372 4
a375 5
			proc_forward_imsg(ps, &imsg, PROC_PARENT, -1);

			/* Report success to the control client */
			imsg_compose_event(&c->iev, IMSG_CTL_OK,
			    0, 0, -1, NULL, 0);
@


1.17
log
@Add global configuration option "local prefix" to change prefix for -L.

The default prefix is 100.64.0.0/10 from RFC6598.

Requested by sthen@@ chris@@
OK mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.16 2017/03/15 12:42:12 reyk Exp $	*/
d366 4
d371 4
a408 5
			break;
		case IMSG_VMDOP_LOAD:
		case IMSG_VMDOP_RELOAD:
		case IMSG_CTL_RESET:
			proc_forward_imsg(ps, &imsg, PROC_PARENT, -1);
@


1.16
log
@Don't terminate vmd(8) when we lost the control connection.

When a start vm request is received from vmctl via the control socket,
vmd's control process forwards it to the parent to trigger the action.
A response is received later, in an async way, and send back to vmctl
that is supposed to wait for it.  But now, if vmctl got terminated
before receiving the response, vmd fails to find the control
connection.  In this case it should not abort, print and warning, and
ignore the error.  The fix is a simple as changing a return (-1) to a
return (0).

This fixes an issue that was reported by mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.15 2017/03/01 07:43:33 reyk Exp $	*/
d82 1
d96 6
@


1.15
log
@Add "owner" option to set a user/group ownership for pre-configured VMs

This allows matching users to start or stop VMs that they "own" and to
access the console accordingly.

OK mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.14 2017/02/27 12:07:58 reyk Exp $	*/
d89 1
a89 1
			log_warnx("%s: fd %d: not found",
d91 1
a91 1
			return (-1);
@


1.14
log
@Add size checks for imsg received over the control socket.

Additionally, make sure that vmd never fatal()s when receiving an
invalid imsg from an arbitrary user over the control socket.

OK gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.13 2017/01/17 21:51:01 krw Exp $	*/
d327 2
a355 1

d364 4
d369 1
a369 2
			    imsg.hdr.type, fd, -1,
			    imsg.data, IMSG_DATA_SIZE(&imsg)) == -1) {
d377 3
d381 1
a381 2
			    imsg.hdr.type, fd, -1,
			    imsg.data, IMSG_DATA_SIZE(&imsg)) == -1) {
@


1.13
log
@Nuke some whitespace that keeps poking me in the eye as I try to
steal code.
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.12 2017/01/09 22:06:25 reyk Exp $	*/
d289 7
a295 5
	struct control_sock	*cs = arg;
	struct privsep		*ps = cs->cs_env;
	struct ctl_conn		*c;
	struct imsg		 imsg;
	int			 n, v, ret = 0;
d352 2
a353 1
			IMSG_SIZE_CHECK(&imsg, &v);
d361 9
d371 9
d381 2
a382 2
			imsg.hdr.peerid = fd;

d384 1
a384 2
			    imsg.hdr.type, imsg.hdr.peerid, -1,
			    imsg.data, IMSG_DATA_SIZE(&imsg)) == -1) {
d407 2
@


1.12
log
@Rename control_dispatch_vmm to control_dispatch_vmd to reflect reality.
No function change.
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.11 2017/01/09 14:49:22 reyk Exp $	*/
d69 1
a69 1
 	 * stdio - for malloc and basic I/O including events.
@


1.11
log
@Stop accessing verbose and debug variables from log.c directly.

This replaces log_verbose() and "extern int verbose" with the two functions
log_setverbose() and log_getverbose().

Pointed out by benno@@
OK krw@@ eric@@ gilles@@ (OK gilles@@ for the snmpd bits as well)
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.10 2017/01/09 14:04:31 krw Exp $	*/
d50 1
a50 1
int	 control_dispatch_vmm(int, struct privsep_proc *, struct imsg *);
d55 1
a55 1
	{ "parent",	PROC_PARENT,	control_dispatch_vmm }
d79 1
a79 1
control_dispatch_vmm(int fd, struct privsep_proc *p, struct imsg *imsg)
@


1.10
log
@Replace hand-rolled for(;;) traversal of ctl_conns TAILQ with
TAILQ_FOREACH().

No intentional functional change.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.9 2016/10/12 19:10:03 reyk Exp $	*/
d353 1
a353 1
			log_verbose(v);
@


1.9
log
@Fix functionality and semantics of vmctl load/reload/reset.

OK rzalamena@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.8 2016/09/29 22:42:04 reyk Exp $	*/
d252 4
a255 3
	for (c = TAILQ_FIRST(&ctl_conns); c != NULL && c->iev.ibuf.fd != fd;
	    c = TAILQ_NEXT(c, entry))
		;	/* nothing */
@


1.8
log
@Implement fork+exec for vmd, using the same framework from httpd etc.

No objections from mlarkin@@ sunil@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.7 2016/08/17 05:07:13 deraadt Exp $	*/
d370 1
@


1.7
log
@small bits of header cleanup; ok mlarkin
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.6 2016/01/10 10:01:07 jsg Exp $	*/
d58 1
a58 1
pid_t
d61 1
a61 1
	return (proc_run(ps, p, procs, nitems(procs), control_run, NULL));
d70 1
d72 1
d74 1
a74 1
	if (pledge("stdio unix", NULL) == -1)
a82 5
	if ((c = control_connbyfd(imsg->hdr.peerid)) == NULL) {
		log_warnx("%s: fd %d: not found", __func__, imsg->hdr.peerid);
		return (-1);
	}

d88 5
@


1.6
log
@remove a duplicate break statement
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.5 2015/12/05 17:30:34 claudio Exp $	*/
d20 1
a20 1
#include <sys/param.h>
@


1.5
log
@Another imsg_read user I did miss in my EAGAIN rampage.
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.4 2015/12/03 23:32:32 reyk Exp $	*/
a329 1
			break;
@


1.4
log
@Re-add the "load" and "reload" commands to vmctl: Instead of parsing
the configuration in vmctl directly, it now sends a (re)load request
to vmd.  The reload also resets the existing configuration status -
this doesn't do much difference yet but a future change will compare
if a specified VM is already running.  "load" will allow to add
configuration, while "reload" resets the state before loading.
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.3 2015/12/03 13:08:44 reyk Exp $	*/
d298 2
a299 1
		if ((n = imsg_read(&c->iev.ibuf)) == -1 || n == 0) {
@


1.3
log
@Use PEERCRED to obtain the user id of the vmmctl user.  This is used to
restrict write operations (start/stop/terminate/load) to root for now,
but allow others to obtain the status.  A more sophisticated model will
follow later, but this change prevents non-root users, even if in the wheel
group, to start vms and thus to open any files read-writable as disks.
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.2 2015/12/02 22:19:11 reyk Exp $	*/
d320 3
a322 4
		case IMSG_CTL_NOTIFY:
		case IMSG_CTL_VERBOSE:
		case IMSG_VMDOP_START_VM_REQUEST:
		case IMSG_VMDOP_TERMINATE_VM_REQUEST:
a329 2
		case IMSG_VMDOP_GET_INFO_VM_REQUEST:
		default:
d365 4
@


1.2
log
@Split the fully privileged parent into two processes "parent" and
"vmm" with reduced privileges:
- the "parent" opens fds (disks, ifs, etc.) but runs as root but pledged as
  "stdio rpath wpath proc tty sendfd".
- the "vmm" process handles the creation and supervision of vm processes,
  and the primary communication with the vmm(4) subsystem.  It runs as _vmd
  in the chroot but does not use pledge, as the vmm ioctls are not allowed
  by any pledge model yet.
With this change, vmd starts to track the configuration state of VMs
in vmd and will allow other things later (like terminating a vm by
name, moving the configuration parser to vmd, ...).  More incremental
changes will follow.
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.1 2015/12/02 09:14:25 reyk Exp $	*/
d226 8
d290 1
a290 1
	int			 n, v;
d319 17
d344 2
a345 3
				imsg_compose_event(&c->iev, IMSG_CTL_FAIL,
				    0, 0, -1, NULL, 0);
				break;
d379 7
@


1.1
log
@Start tweaking vmd's privsep and daemon model by splitting the main
process into multiple parts and adopting the "proc.c"-style from other
daemons.  This allows to further reduce the privileges, to give better
pledge(2), and to add some upcoming changes.

"please do" mlarkin@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.20 2015/11/23 19:28:33 reyk Exp $	*/
d338 2
a339 2
			if (imsg_compose_event(&ps->ps_ievs[PROC_PARENT][0],
			    imsg.hdr.type, imsg.hdr.peerid, 0, -1,
@

