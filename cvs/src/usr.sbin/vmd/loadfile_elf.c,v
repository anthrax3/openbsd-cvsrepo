head	1.26;
access;
symbols
	OPENBSD_6_1:1.26.0.4
	OPENBSD_6_1_BASE:1.26
	OPENBSD_6_0:1.15.0.2
	OPENBSD_6_0_BASE:1.15
	OPENBSD_5_9:1.9.0.2
	OPENBSD_5_9_BASE:1.9;
locks; strict;
comment	@ * @;


1.26
date	2017.03.27.00.28.04;	author deraadt;	state Exp;
branches;
next	1.25;
commitid	cbObO83mNT8jlhy1;

1.25
date	2017.03.25.16.28.25;	author reyk;	state Exp;
branches;
next	1.24;
commitid	s82EA2LBuZtftmLN;

1.24
date	2017.02.04.07.23.25;	author mlarkin;	state Exp;
branches;
next	1.23;
commitid	DeXNkua0y1qMggIs;

1.23
date	2017.01.17.21.51.01;	author krw;	state Exp;
branches;
next	1.22;
commitid	7aASaBYKS1WgBK9H;

1.22
date	2016.11.26.20.03.42;	author reyk;	state Exp;
branches;
next	1.21;
commitid	GrCSblbcTEkTQcOY;

1.21
date	2016.11.24.07.58.55;	author reyk;	state Exp;
branches;
next	1.20;
commitid	vTTzvT7jwtD1X8ZA;

1.20
date	2016.10.26.05.26.36;	author mlarkin;	state Exp;
branches;
next	1.19;
commitid	1sM4SQUlhgJwAn6Q;

1.19
date	2016.09.17.17.39.34;	author jasper;	state Exp;
branches;
next	1.18;
commitid	yiSnvoseCUtTmo9S;

1.18
date	2016.09.13.19.07.47;	author jasper;	state Exp;
branches;
next	1.17;
commitid	6VaFRmyYk7ijJJsC;

1.17
date	2016.09.01.16.04.47;	author stefan;	state Exp;
branches;
next	1.16;
commitid	xgCRvP7hLEqkM3Qf;

1.16
date	2016.08.17.05.07.13;	author deraadt;	state Exp;
branches;
next	1.15;
commitid	qqWoBqCGCbsKOAqY;

1.15
date	2016.05.26.17.10.15;	author stefan;	state Exp;
branches;
next	1.14;
commitid	Wbj5JOooQmmu6W39;

1.14
date	2016.04.07.07.02.57;	author mlarkin;	state Exp;
branches;
next	1.13;
commitid	Y1kznLHp8VUx9sS5;

1.13
date	2016.04.05.09.33.05;	author mlarkin;	state Exp;
branches;
next	1.12;
commitid	klY9sBeThwZpzkLp;

1.12
date	2016.04.04.17.13.54;	author stefan;	state Exp;
branches;
next	1.11;
commitid	Y1YC68R7VkcaKZ1f;

1.11
date	2016.03.13.13.11.47;	author stefan;	state Exp;
branches;
next	1.10;
commitid	tNFHzbetplEWT4Tg;

1.10
date	2016.03.04.15.34.14;	author stefan;	state Exp;
branches;
next	1.9;
commitid	6WSHXT0Nb6aq3wH6;

1.9
date	2016.01.16.08.55.40;	author stefan;	state Exp;
branches;
next	1.8;
commitid	AJ7cyewTvXIt6nft;

1.8
date	2016.01.05.06.55.28;	author mlarkin;	state Exp;
branches;
next	1.7;
commitid	vxnk1RoUc8bZc4VY;

1.7
date	2016.01.05.06.54.03;	author mlarkin;	state Exp;
branches;
next	1.6;
commitid	pK2shIDgKjLxYujy;

1.6
date	2016.01.05.06.51.54;	author mlarkin;	state Exp;
branches;
next	1.5;
commitid	6ov4uR7fHOerDopg;

1.5
date	2015.12.17.09.29.28;	author mlarkin;	state Exp;
branches;
next	1.4;
commitid	8J3NuBrhKPtN9MxY;

1.4
date	2015.12.06.17.42.15;	author mlarkin;	state Exp;
branches;
next	1.3;
commitid	1MAb2Wc3r4DDitvV;

1.3
date	2015.12.03.08.42.11;	author reyk;	state Exp;
branches;
next	1.2;
commitid	deOxsg54am7A6Za6;

1.2
date	2015.11.23.13.04.49;	author reyk;	state Exp;
branches;
next	1.1;
commitid	8LSTqui1EesFdS0T;

1.1
date	2015.11.22.20.20.32;	author mlarkin;	state Exp;
branches;
next	;
commitid	O5Ay1ZamHQn9lamK;


desc
@@


1.26
log
@die whitespace die die die
@
text
@/* $NetBSD: loadfile.c,v 1.10 2000/12/03 02:53:04 tsutsui Exp $ */
/* $OpenBSD: loadfile_elf.c,v 1.25 2017/03/25 16:28:25 reyk Exp $ */

/*-
 * Copyright (c) 1997 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Jason R. Thorpe of the Numerical Aerospace Simulation Facility,
 * NASA Ames Research Center and by Christos Zoulas.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Ralph Campbell.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)boot.c	8.1 (Berkeley) 6/10/93
 */

/*
 * Copyright (c) 2015 Mike Larkin <mlarkin@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/param.h>	/* PAGE_SIZE PAGE_MASK roundup */
#include <sys/ioctl.h>
#include <sys/reboot.h>
#include <sys/exec.h>
#include <sys/exec_elf.h>

#include <stdio.h>
#include <string.h>
#include <errno.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>
#include <err.h>
#include <errno.h>
#include <stddef.h>

#include <machine/vmmvar.h>
#include <machine/biosvar.h>
#include <machine/segments.h>
#include <machine/pte.h>

#include "loadfile.h"
#include "vmd.h"

union {
	Elf32_Ehdr elf32;
	Elf64_Ehdr elf64;
} hdr;

#ifdef __i386__
typedef uint32_t pt_entry_t;
static void setsegment(struct segment_descriptor *, uint32_t,
    size_t, int, int, int, int);
#else
static void setsegment(struct mem_segment_descriptor *, uint32_t,
    size_t, int, int, int, int);
#endif
static int elf32_exec(FILE *, Elf32_Ehdr *, u_long *, int);
static int elf64_exec(FILE *, Elf64_Ehdr *, u_long *, int);
static size_t create_bios_memmap(struct vm_create_params *, bios_memmap_t *);
static uint32_t push_bootargs(bios_memmap_t *, size_t);
static size_t push_stack(uint32_t, uint32_t, uint32_t, uint32_t);
static void push_gdt(void);
static void push_pt(void);
static void marc4random_buf(paddr_t, int);
static void mbzero(paddr_t, int);
static void mbcopy(void *, paddr_t, int);

extern char *__progname;
extern int vm_id;

/*
 * setsegment
 *
 * Initializes a segment selector entry with the provided descriptor.
 * For the purposes of the bootloader mimiced by vmd(8), we only need
 * memory-type segment descriptor support.
 *
 * This function was copied from machdep.c
 *
 * Parameters:
 *  sd: Address of the entry to initialize
 *  base: base of the segment
 *  limit: limit of the segment
 *  type: type of the segment
 *  dpl: privilege level of the egment
 *  def32: default 16/32 bit size of the segment
 *  gran: granularity of the segment (byte/page)
 */
#ifdef __i386__
static void
setsegment(struct segment_descriptor *sd, uint32_t base, size_t limit,
    int type, int dpl, int def32, int gran)
#else
static void
setsegment(struct mem_segment_descriptor *sd, uint32_t base, size_t limit,
    int type, int dpl, int def32, int gran)
#endif
{
	sd->sd_lolimit = (int)limit;
	sd->sd_lobase = (int)base;
	sd->sd_type = type;
	sd->sd_dpl = dpl;
	sd->sd_p = 1;
	sd->sd_hilimit = (int)limit >> 16;
#ifdef __i386__
	sd->sd_xx = 0;
#else
	sd->sd_avl = 0;
	sd->sd_long = 0;
#endif
	sd->sd_def32 = def32;
	sd->sd_gran = gran;
	sd->sd_hibase = (int)base >> 24;
}

/*
 * push_gdt
 *
 * Allocates and populates a page in the guest phys memory space to hold
 * the boot-time GDT. Since vmd(8) is acting as the bootloader, we need to
 * create the same GDT that a real bootloader would have created.
 * This is loaded into the guest phys RAM space at address GDT_PAGE.
 */
static void
push_gdt(void)
{
	uint8_t gdtpage[PAGE_SIZE];
#ifdef __i386__
	struct segment_descriptor *sd;
#else
	struct mem_segment_descriptor *sd;
#endif

	memset(&gdtpage, 0, sizeof(gdtpage));

#ifdef __i386__
	sd = (struct segment_descriptor *)&gdtpage;
#else
	sd = (struct mem_segment_descriptor *)&gdtpage;
#endif

	/*
	 * Create three segment descriptors:
	 *
	 * GDT[0] : null desriptor. "Created" via memset above.
	 * GDT[1] (selector @@ 0x8): Executable segment, for CS
	 * GDT[2] (selector @@ 0x10): RW Data segment, for DS/ES/SS
	 */
	setsegment(&sd[1], 0, 0xffffffff, SDT_MEMERA, SEL_KPL, 1, 1);
	setsegment(&sd[2], 0, 0xffffffff, SDT_MEMRWA, SEL_KPL, 1, 1);

	write_mem(GDT_PAGE, gdtpage, PAGE_SIZE);
}

/*
 * push_pt
 *
 * Create an identity-mapped page directory hierarchy mapping the first
 * 1GB of physical memory. This is used during bootstrapping VMs on
 * CPUs without unrestricted guest capability.
 */
static void
push_pt(void)
{
	pt_entry_t ptes[NPTE_PG];
	uint64_t i;

#ifdef __i386__
	memset(ptes, 0, sizeof(ptes));
	for (i = 0 ; i < NPTE_PG; i++) {
		ptes[i] = PG_V | PG_PS | (NBPD * i);
	}
	write_mem(PML4_PAGE, ptes, PAGE_SIZE);
#else
	/* PML3 [0] - first 1GB */
	memset(ptes, 0, sizeof(ptes));
	ptes[0] = PG_V | PML3_PAGE;
	write_mem(PML4_PAGE, ptes, PAGE_SIZE);

	/* PML3 [0] - first 1GB */
	memset(ptes, 0, sizeof(ptes));
	ptes[0] = PG_V | PG_RW | PG_u | PML2_PAGE;
	write_mem(PML3_PAGE, ptes, PAGE_SIZE);

	/* PML2 [0..511] - first 1GB (in 2MB pages) */
	memset(ptes, 0, sizeof(ptes));
	for (i = 0 ; i < NPTE_PG; i++) {
		ptes[i] = PG_V | PG_RW | PG_u | PG_PS | (NBPD_L2 * i);
	}
	write_mem(PML2_PAGE, ptes, PAGE_SIZE);
#endif
}

/*
 * loadfile_elf
 *
 * Loads an ELF kernel to it's defined load address in the guest VM.
 * The kernel is loaded to its defined start point as set in the ELF header.
 *
 * Parameters:
 *  fp: file of a kernel file to load
 *  vcp: the VM create parameters, holding the exact memory map
 *  (out) vrs: register state to set on init for this kernel
 *  bootdev: the optional non-default boot device
 *  howto: optionel boot flags for the kernel
 *
 * Return values:
 *  0 if successful
 *  various error codes returned from read(2) or loadelf functions
 */
int
loadfile_elf(FILE *fp, struct vm_create_params *vcp,
    struct vcpu_reg_state *vrs, uint32_t bootdev, uint32_t howto)
{
	int r;
	uint32_t bootargsz;
	size_t n, stacksize;
	u_long marks[MARK_MAX];
	bios_memmap_t memmap[VMM_MAX_MEM_RANGES + 1];

	if ((r = fread(&hdr, 1, sizeof(hdr), fp)) != sizeof(hdr))
		return 1;

	memset(&marks, 0, sizeof(marks));
	if (memcmp(hdr.elf32.e_ident, ELFMAG, SELFMAG) == 0 &&
	    hdr.elf32.e_ident[EI_CLASS] == ELFCLASS32) {
		r = elf32_exec(fp, &hdr.elf32, marks, LOAD_ALL);
	} else if (memcmp(hdr.elf64.e_ident, ELFMAG, SELFMAG) == 0 &&
	    hdr.elf64.e_ident[EI_CLASS] == ELFCLASS64) {
		r = elf64_exec(fp, &hdr.elf64, marks, LOAD_ALL);
	} else
		errno = ENOEXEC;

	if (r)
		return (r);

	push_gdt();
	push_pt();
	n = create_bios_memmap(vcp, memmap);
	bootargsz = push_bootargs(memmap, n);
	stacksize = push_stack(bootargsz, marks[MARK_END], bootdev, howto);

#ifdef __i386__
	vrs->vrs_gprs[VCPU_REGS_EIP] = (uint32_t)marks[MARK_ENTRY];
	vrs->vrs_gprs[VCPU_REGS_ESP] = (uint32_t)(STACK_PAGE + PAGE_SIZE) - stacksize;
#else
	vrs->vrs_gprs[VCPU_REGS_RIP] = (uint64_t)marks[MARK_ENTRY];
	vrs->vrs_gprs[VCPU_REGS_RSP] = (uint64_t)(STACK_PAGE + PAGE_SIZE) - stacksize;
#endif
	vrs->vrs_gdtr.vsi_base = GDT_PAGE;

	log_debug("%s: loaded ELF kernel", __func__);

	return (0);
}

/*
 * create_bios_memmap
 *
 * Construct a memory map as returned by the BIOS INT 0x15, e820 routine.
 *
 * Parameters:
 *  vcp: the VM create parameters, containing the memory map passed to vmm(4)
 *   memmap (out): the BIOS memory map
 *
 * Return values:
 * Number of bios_memmap_t entries, including the terminating nul-entry.
 */
static size_t
create_bios_memmap(struct vm_create_params *vcp, bios_memmap_t *memmap)
{
	size_t i, n = 0, sz;
	paddr_t gpa;
	struct vm_mem_range *vmr;

	for (i = 0; i < vcp->vcp_nmemranges; i++) {
		vmr = &vcp->vcp_memranges[i];
		gpa = vmr->vmr_gpa;
		sz = vmr->vmr_size;

		/*
		 * Make sure that we do not mark the ROM/video RAM area in the
		 * low memory as physcal memory available to the kernel.
		 */
		if (gpa < 0x100000 && gpa + sz > LOWMEM_KB * 1024) {
			if (gpa >= LOWMEM_KB * 1024)
				sz = 0;
			else
				sz = LOWMEM_KB * 1024 - gpa;
		}

		if (sz != 0) {
			memmap[n].addr = gpa;
			memmap[n].size = sz;
			memmap[n].type = 0x1;	/* Type 1 : Normal memory */
			n++;
		}
	}

	/* Null mem map entry to denote the end of the ranges */
	memmap[n].addr = 0x0;
	memmap[n].size = 0x0;
	memmap[n].type = 0x0;
	n++;

	return (n);
}

/*
 * push_bootargs
 *
 * Creates the boot arguments page in the guest address space.
 * Since vmd(8) is acting as the bootloader, we need to create the same boot
 * arguments page that a real bootloader would have created. This is loaded
 * into the guest phys RAM space at address BOOTARGS_PAGE.
 *
 * Parameters:
 *  memmap: the BIOS memory map
 *  n: number of entries in memmap
 *
 * Return values:
 *  The size of the bootargs
 */
static uint32_t
push_bootargs(bios_memmap_t *memmap, size_t n)
{
	uint32_t memmap_sz, consdev_sz, i;
	bios_consdev_t consdev;
	uint32_t ba[1024];

	memmap_sz = 3 * sizeof(int) + n * sizeof(bios_memmap_t);
	ba[0] = 0x0;    /* memory map */
	ba[1] = memmap_sz;
	ba[2] = memmap_sz;	/* next */
	memcpy(&ba[3], memmap, n * sizeof(bios_memmap_t));
	i = memmap_sz / sizeof(int);

	/* Serial console device, COM1 @@ 0x3f8 */
	consdev.consdev = makedev(8, 0);	/* com1 @@ 0x3f8 */
	consdev.conspeed = 9600;
	consdev.consaddr = 0x3f8;
	consdev.consfreq = 0;

	consdev_sz = 3 * sizeof(int) + sizeof(bios_consdev_t);
	ba[i] = 0x5;   /* consdev */
	ba[i + 1] = consdev_sz;
	ba[i + 2] = consdev_sz;
	memcpy(&ba[i + 3], &consdev, sizeof(bios_consdev_t));
	i = i + 3 + (sizeof(bios_consdev_t) / 4);

	ba[i] = 0xFFFFFFFF; /* BOOTARG_END */

	write_mem(BOOTARGS_PAGE, ba, PAGE_SIZE);

	return (memmap_sz + consdev_sz);
}

/*
 * push_stack
 *
 * Creates the boot stack page in the guest address space. When using a real
 * bootloader, the stack will be prepared using the following format before
 * transitioning to kernel start, so vmd(8) needs to mimic the same stack
 * layout. The stack content is pushed to the guest phys RAM at address
 * STACK_PAGE. The bootloader operates in 32 bit mode; each stack entry is
 * 4 bytes.
 *
 * Stack Layout: (TOS == Top Of Stack)
 *  TOS		location of boot arguments page
 *  TOS - 0x4	size of the content in the boot arguments page
 *  TOS - 0x8	size of low memory (biosbasemem: kernel uses BIOS map only if 0)
 *  TOS - 0xc	size of high memory (biosextmem, not used by kernel at all)
 *  TOS - 0x10	kernel 'end' symbol value
 *  TOS - 0x14	version of bootarg API
 *
 * Parameters:
 *  bootargsz: size of boot arguments
 *  end: kernel 'end' symbol value
 *  bootdev: the optional non-default boot device
 *  howto: optionel boot flags for the kernel
 *
 * Return values:
 *  size of the stack
 */
static size_t
push_stack(uint32_t bootargsz, uint32_t end, uint32_t bootdev, uint32_t howto)
{
	uint32_t stack[1024];
	uint16_t loc;

	memset(&stack, 0, sizeof(stack));
	loc = 1024;

	if (bootdev == 0)
		bootdev = MAKEBOOTDEV(0x4, 0, 0, 0, 0); /* bootdev: sd0a */

	stack[--loc] = BOOTARGS_PAGE;
	stack[--loc] = bootargsz;
	stack[--loc] = 0; /* biosbasemem */
	stack[--loc] = 0; /* biosextmem */
	stack[--loc] = end;
	stack[--loc] = 0x0e;
	stack[--loc] = bootdev;
	stack[--loc] = howto;

	write_mem(STACK_PAGE, &stack, PAGE_SIZE);

	return (1024 - (loc - 1)) * sizeof(uint32_t);
}

/*
 * mread
 *
 * Reads 'sz' bytes from the file whose descriptor is provided in 'fd'
 * into the guest address space at paddr 'addr'.
 *
 * Parameters:
 *  fd: file descriptor of the kernel image file to read from.
 *  addr: guest paddr_t to load to
 *  sz: number of bytes to load
 *
 * Return values:
 *  returns 'sz' if successful, or 0 otherwise.
 */
size_t
mread(FILE *fp, paddr_t addr, size_t sz)
{
	size_t ct;
	size_t i, rd, osz;
	char buf[PAGE_SIZE];

	/*
	 * break up the 'sz' bytes into PAGE_SIZE chunks for use with
	 * write_mem
	 */
	ct = 0;
	rd = 0;
	osz = sz;
	if ((addr & PAGE_MASK) != 0) {
		memset(buf, 0, sizeof(buf));
		if (sz > PAGE_SIZE)
			ct = PAGE_SIZE - (addr & PAGE_MASK);
		else
			ct = sz;

		if (fread(buf, 1, ct, fp) != ct) {
			log_warn("%s: error %d in mread", __progname, errno);
			return (0);
		}
		rd += ct;

		if (write_mem(addr, buf, ct))
			return (0);

		addr += ct;
	}

	sz = sz - ct;

	if (sz == 0)
		return (osz);

	for (i = 0; i < sz; i += PAGE_SIZE, addr += PAGE_SIZE) {
		memset(buf, 0, sizeof(buf));
		if (i + PAGE_SIZE > sz)
			ct = sz - i;
		else
			ct = PAGE_SIZE;

		if (fread(buf, 1, ct, fp) != ct) {
			log_warn("%s: error %d in mread", __progname, errno);
			return (0);
		}
		rd += ct;

		if (write_mem(addr, buf, ct))
			return (0);
	}

	return (osz);
}

/*
 * marc4random_buf
 *
 * load 'sz' bytes of random data into the guest address space at paddr
 * 'addr'.
 *
 * Parameters:
 *  addr: guest paddr_t to load random bytes into
 *  sz: number of random bytes to load
 *
 * Return values:
 *  nothing
 */
static void
marc4random_buf(paddr_t addr, int sz)
{
	int i, ct;
	char buf[PAGE_SIZE];

	/*
	 * break up the 'sz' bytes into PAGE_SIZE chunks for use with
	 * write_mem
	 */
	ct = 0;
	if (addr % PAGE_SIZE != 0) {
		memset(buf, 0, sizeof(buf));
		ct = PAGE_SIZE - (addr % PAGE_SIZE);

		arc4random_buf(buf, ct);

		if (write_mem(addr, buf, ct))
			return;

		addr += ct;
	}

	for (i = 0; i < sz; i+= PAGE_SIZE, addr += PAGE_SIZE) {
		memset(buf, 0, sizeof(buf));
		if (i + PAGE_SIZE > sz)
			ct = sz - i;
		else
			ct = PAGE_SIZE;

		arc4random_buf(buf, ct);

		if (write_mem(addr, buf, ct))
			return;
	}
}

/*
 * mbzero
 *
 * load 'sz' bytes of zeros into the guest address space at paddr
 * 'addr'.
 *
 * Parameters:
 *  addr: guest paddr_t to zero
 *  sz: number of zero bytes to store
 *
 * Return values:
 *  nothing
 */
static void
mbzero(paddr_t addr, int sz)
{
	int i, ct;
	char buf[PAGE_SIZE];

	/*
	 * break up the 'sz' bytes into PAGE_SIZE chunks for use with
	 * write_mem
	 */
	ct = 0;
	memset(buf, 0, sizeof(buf));
	if (addr % PAGE_SIZE != 0) {
		ct = PAGE_SIZE - (addr % PAGE_SIZE);

		if (write_mem(addr, buf, ct))
			return;

		addr += ct;
	}

	for (i = 0; i < sz; i+= PAGE_SIZE, addr += PAGE_SIZE) {
		if (i + PAGE_SIZE > sz)
			ct = sz - i;
		else
			ct = PAGE_SIZE;

		if (write_mem(addr, buf, ct))
			return;
	}
}

/*
 * mbcopy
 *
 * copies 'sz' bytes from buffer 'src' to guest paddr 'dst'.
 *
 * Parameters:
 *  src: source buffer to copy from
 *  dst: destination guest paddr_t to copy to
 *  sz: number of bytes to copy
 *
 * Return values:
 *  nothing
 */
static void
mbcopy(void *src, paddr_t dst, int sz)
{
	write_mem(dst, src, sz);
}

/*
 * elf64_exec
 *
 * Load the kernel indicated by 'fd' into the guest physical memory
 * space, at the addresses defined in the ELF header.
 *
 * This function is used for 64 bit kernels.
 *
 * Parameters:
 *  fd: file descriptor of the kernel to load
 *  elf: ELF header of the kernel
 *  marks: array to store the offsets of various kernel structures
 *      (start, bss, etc)
 *  flags: flag value to indicate which section(s) to load (usually
 *      LOAD_ALL)
 *
 * Return values:
 *  0 if successful
 *  1 if unsuccessful
 */
static int
elf64_exec(FILE *fp, Elf64_Ehdr *elf, u_long *marks, int flags)
{
	Elf64_Shdr *shp;
	Elf64_Phdr *phdr;
	Elf64_Off off;
	int i;
	size_t sz;
	int first;
	int havesyms, havelines;
	paddr_t minp = ~0, maxp = 0, pos = 0;
	paddr_t offset = marks[MARK_START], shpp, elfp;

	sz = elf->e_phnum * sizeof(Elf64_Phdr);
	phdr = malloc(sz);

	if (fseeko(fp, (off_t)elf->e_phoff, SEEK_SET) == -1)  {
		free(phdr);
		return 1;
	}

	if (fread(phdr, 1, sz, fp) != sz) {
		free(phdr);
		return 1;
	}

	for (first = 1, i = 0; i < elf->e_phnum; i++) {
		if (phdr[i].p_type == PT_OPENBSD_RANDOMIZE) {
			int m;

			/* Fill segment if asked for. */
			if (flags & LOAD_RANDOM) {
				for (pos = 0; pos < phdr[i].p_filesz;
				    pos += m) {
					m = phdr[i].p_filesz - pos;
					marc4random_buf(phdr[i].p_paddr + pos,
					    m);
				}
			}
			if (flags & (LOAD_RANDOM | COUNT_RANDOM)) {
				marks[MARK_RANDOM] = LOADADDR(phdr[i].p_paddr);
				marks[MARK_ERANDOM] =
				    marks[MARK_RANDOM] + phdr[i].p_filesz;
			}
			continue;
		}

		if (phdr[i].p_type != PT_LOAD ||
		    (phdr[i].p_flags & (PF_W|PF_R|PF_X)) == 0)
			continue;

#define IS_TEXT(p)	(p.p_flags & PF_X)
#define IS_DATA(p)	((p.p_flags & PF_X) == 0)
#define IS_BSS(p)	(p.p_filesz < p.p_memsz)
		/*
		 * XXX: Assume first address is lowest
		 */
		if ((IS_TEXT(phdr[i]) && (flags & LOAD_TEXT)) ||
		    (IS_DATA(phdr[i]) && (flags & LOAD_DATA))) {

			/* Read in segment. */
			if (fseeko(fp, (off_t)phdr[i].p_offset,
			    SEEK_SET) == -1) {
				free(phdr);
				return 1;
			}
			if (mread(fp, phdr[i].p_paddr, phdr[i].p_filesz) !=
			    phdr[i].p_filesz) {
				free(phdr);
				return 1;
			}

			first = 0;
		}

		if ((IS_TEXT(phdr[i]) && (flags & (LOAD_TEXT | COUNT_TEXT))) ||
		    (IS_DATA(phdr[i]) && (flags & (LOAD_DATA | COUNT_TEXT)))) {
			pos = phdr[i].p_paddr;
			if (minp > pos)
				minp = pos;
			pos += phdr[i].p_filesz;
			if (maxp < pos)
				maxp = pos;
		}

		/* Zero out BSS. */
		if (IS_BSS(phdr[i]) && (flags & LOAD_BSS)) {
			mbzero((phdr[i].p_paddr + phdr[i].p_filesz),
			    phdr[i].p_memsz - phdr[i].p_filesz);
		}
		if (IS_BSS(phdr[i]) && (flags & (LOAD_BSS|COUNT_BSS))) {
			pos += phdr[i].p_memsz - phdr[i].p_filesz;
			if (maxp < pos)
				maxp = pos;
		}
	}
	free(phdr);

	/*
	 * Copy the ELF and section headers.
	 */
	elfp = maxp = roundup(maxp, sizeof(Elf64_Addr));
	if (flags & (LOAD_HDR | COUNT_HDR))
		maxp += sizeof(Elf64_Ehdr);

	if (flags & (LOAD_SYM | COUNT_SYM)) {
		if (fseeko(fp, (off_t)elf->e_shoff, SEEK_SET) == -1)  {
			WARN(("lseek section headers"));
			return 1;
		}
		sz = elf->e_shnum * sizeof(Elf64_Shdr);
		shp = malloc(sz);

		if (fread(shp, 1, sz, fp) != sz) {
			free(shp);
			return 1;
		}

		shpp = maxp;
		maxp += roundup(sz, sizeof(Elf64_Addr));

		size_t shstrsz = shp[elf->e_shstrndx].sh_size;
		char *shstr = malloc(shstrsz);
		if (fseeko(fp, (off_t)shp[elf->e_shstrndx].sh_offset,
		    SEEK_SET) == -1) {
			free(shstr);
			free(shp);
			return 1;
		}
		if (fread(shstr, 1, shstrsz, fp) != shstrsz) {
			free(shstr);
			free(shp);
			return 1;
		}

		/*
		 * Now load the symbol sections themselves. Make sure the
		 * sections are aligned. Don't bother with string tables if
		 * there are no symbol sections.
		 */
		off = roundup((sizeof(Elf64_Ehdr) + sz), sizeof(Elf64_Addr));

		for (havesyms = havelines = i = 0; i < elf->e_shnum; i++)
			if (shp[i].sh_type == SHT_SYMTAB)
				havesyms = 1;

		for (first = 1, i = 0; i < elf->e_shnum; i++) {
			if (shp[i].sh_type == SHT_SYMTAB ||
			    shp[i].sh_type == SHT_STRTAB ||
			    !strcmp(shstr + shp[i].sh_name, ".debug_line") ||
			    !strcmp(shstr + shp[i].sh_name, ELF_CTF)) {
				if (havesyms && (flags & LOAD_SYM)) {
					if (fseeko(fp, (off_t)shp[i].sh_offset,
					    SEEK_SET) == -1) {
						free(shstr);
						free(shp);
						return 1;
					}
					if (mread(fp, maxp,
					    shp[i].sh_size) != shp[i].sh_size) {
						free(shstr);
						free(shp);
						return 1;
					}
				}
				maxp += roundup(shp[i].sh_size,
				    sizeof(Elf64_Addr));
				shp[i].sh_offset = off;
				shp[i].sh_flags |= SHF_ALLOC;
				off += roundup(shp[i].sh_size,
				    sizeof(Elf64_Addr));
				first = 0;
			}
		}
		if (flags & LOAD_SYM) {
			mbcopy(shp, shpp, sz);
		}
		free(shstr);
		free(shp);
	}

	/*
	 * Frob the copied ELF header to give information relative
	 * to elfp.
	 */
	if (flags & LOAD_HDR) {
		elf->e_phoff = 0;
		elf->e_shoff = sizeof(Elf64_Ehdr);
		elf->e_phentsize = 0;
		elf->e_phnum = 0;
		mbcopy(elf, elfp, sizeof(*elf));
	}

	marks[MARK_START] = LOADADDR(minp);
	marks[MARK_ENTRY] = LOADADDR(elf->e_entry);
	marks[MARK_NSYM] = 1;	/* XXX: Kernel needs >= 0 */
	marks[MARK_SYM] = LOADADDR(elfp);
	marks[MARK_END] = LOADADDR(maxp);

	return 0;
}

/*
 * elf32_exec
 *
 * Load the kernel indicated by 'fd' into the guest physical memory
 * space, at the addresses defined in the ELF header.
 *
 * This function is used for 32 bit kernels.
 *
 * Parameters:
 *  fd: file descriptor of the kernel to load
 *  elf: ELF header of the kernel
 *  marks: array to store the offsets of various kernel structures
 *      (start, bss, etc)
 *  flags: flag value to indicate which section(s) to load (usually
 *      LOAD_ALL)
 *
 * Return values:
 *  0 if successful
 *  1 if unsuccessful
 */
static int
elf32_exec(FILE *fp, Elf32_Ehdr *elf, u_long *marks, int flags)
{
	Elf32_Shdr *shp;
	Elf32_Phdr *phdr;
	Elf32_Off off;
	int i;
	size_t sz;
	int first;
	int havesyms, havelines;
	paddr_t minp = ~0, maxp = 0, pos = 0;
	paddr_t offset = marks[MARK_START], shpp, elfp;

	sz = elf->e_phnum * sizeof(Elf32_Phdr);
	phdr = malloc(sz);

	if (fseeko(fp, (off_t)elf->e_phoff, SEEK_SET) == -1)  {
		free(phdr);
		return 1;
	}

	if (fread(phdr, 1, sz, fp) != sz) {
		free(phdr);
		return 1;
	}

	for (first = 1, i = 0; i < elf->e_phnum; i++) {
		if (phdr[i].p_type == PT_OPENBSD_RANDOMIZE) {
			int m;

			/* Fill segment if asked for. */
			if (flags & LOAD_RANDOM) {
				for (pos = 0; pos < phdr[i].p_filesz;
				    pos += m) {
					m = phdr[i].p_filesz - pos;
					marc4random_buf(phdr[i].p_paddr + pos,
					    m);
				}
			}
			if (flags & (LOAD_RANDOM | COUNT_RANDOM)) {
				marks[MARK_RANDOM] = LOADADDR(phdr[i].p_paddr);
				marks[MARK_ERANDOM] =
				    marks[MARK_RANDOM] + phdr[i].p_filesz;
			}
			continue;
		}

		if (phdr[i].p_type != PT_LOAD ||
		    (phdr[i].p_flags & (PF_W|PF_R|PF_X)) == 0)
			continue;

#define IS_TEXT(p)	(p.p_flags & PF_X)
#define IS_DATA(p)	((p.p_flags & PF_X) == 0)
#define IS_BSS(p)	(p.p_filesz < p.p_memsz)
		/*
		 * XXX: Assume first address is lowest
		 */
		if ((IS_TEXT(phdr[i]) && (flags & LOAD_TEXT)) ||
		    (IS_DATA(phdr[i]) && (flags & LOAD_DATA))) {

			/* Read in segment. */
			if (fseeko(fp, (off_t)phdr[i].p_offset,
			    SEEK_SET) == -1) {
				free(phdr);
				return 1;
			}
			if (mread(fp, phdr[i].p_paddr, phdr[i].p_filesz) !=
			    phdr[i].p_filesz) {
				free(phdr);
				return 1;
			}

			first = 0;
		}

		if ((IS_TEXT(phdr[i]) && (flags & (LOAD_TEXT | COUNT_TEXT))) ||
		    (IS_DATA(phdr[i]) && (flags & (LOAD_DATA | COUNT_TEXT)))) {
			pos = phdr[i].p_paddr;
			if (minp > pos)
				minp = pos;
			pos += phdr[i].p_filesz;
			if (maxp < pos)
				maxp = pos;
		}

		/* Zero out BSS. */
		if (IS_BSS(phdr[i]) && (flags & LOAD_BSS)) {
			mbzero((phdr[i].p_paddr + phdr[i].p_filesz),
			    phdr[i].p_memsz - phdr[i].p_filesz);
		}
		if (IS_BSS(phdr[i]) && (flags & (LOAD_BSS|COUNT_BSS))) {
			pos += phdr[i].p_memsz - phdr[i].p_filesz;
			if (maxp < pos)
				maxp = pos;
		}
	}
	free(phdr);

	/*
	 * Copy the ELF and section headers.
	 */
	elfp = maxp = roundup(maxp, sizeof(Elf32_Addr));
	if (flags & (LOAD_HDR | COUNT_HDR))
		maxp += sizeof(Elf32_Ehdr);

	if (flags & (LOAD_SYM | COUNT_SYM)) {
		if (fseeko(fp, (off_t)elf->e_shoff, SEEK_SET) == -1)  {
			WARN(("lseek section headers"));
			return 1;
		}
		sz = elf->e_shnum * sizeof(Elf32_Shdr);
		shp = malloc(sz);

		if (fread(shp, 1, sz, fp) != sz) {
			free(shp);
			return 1;
		}

		shpp = maxp;
		maxp += roundup(sz, sizeof(Elf32_Addr));

		size_t shstrsz = shp[elf->e_shstrndx].sh_size;
		char *shstr = malloc(shstrsz);
		if (fseeko(fp, (off_t)shp[elf->e_shstrndx].sh_offset,
		    SEEK_SET) == -1) {
			free(shstr);
			free(shp);
			return 1;
		}
		if (fread(shstr, 1, shstrsz, fp) != shstrsz) {
			free(shstr);
			free(shp);
			return 1;
		}

		/*
		 * Now load the symbol sections themselves. Make sure the
		 * sections are aligned. Don't bother with string tables if
		 * there are no symbol sections.
		 */
		off = roundup((sizeof(Elf32_Ehdr) + sz), sizeof(Elf32_Addr));

		for (havesyms = havelines = i = 0; i < elf->e_shnum; i++)
			if (shp[i].sh_type == SHT_SYMTAB)
				havesyms = 1;

		for (first = 1, i = 0; i < elf->e_shnum; i++) {
			if (shp[i].sh_type == SHT_SYMTAB ||
			    shp[i].sh_type == SHT_STRTAB ||
			    !strcmp(shstr + shp[i].sh_name, ".debug_line")) {
				if (havesyms && (flags & LOAD_SYM)) {
					if (fseeko(fp, (off_t)shp[i].sh_offset,
					    SEEK_SET) == -1) {
						free(shstr);
						free(shp);
						return 1;
					}
					if (mread(fp, maxp,
					    shp[i].sh_size) != shp[i].sh_size) {
						free(shstr);
						free(shp);
						return 1;
					}
				}
				maxp += roundup(shp[i].sh_size,
				    sizeof(Elf32_Addr));
				shp[i].sh_offset = off;
				shp[i].sh_flags |= SHF_ALLOC;
				off += roundup(shp[i].sh_size,
				    sizeof(Elf32_Addr));
				first = 0;
			}
		}
		if (flags & LOAD_SYM) {
			mbcopy(shp, shpp, sz);
		}
		free(shstr);
		free(shp);
	}

	/*
	 * Frob the copied ELF header to give information relative
	 * to elfp.
	 */
	if (flags & LOAD_HDR) {
		elf->e_phoff = 0;
		elf->e_shoff = sizeof(Elf32_Ehdr);
		elf->e_phentsize = 0;
		elf->e_phnum = 0;
		mbcopy(elf, elfp, sizeof(*elf));
	}

	marks[MARK_START] = LOADADDR(minp);
	marks[MARK_ENTRY] = LOADADDR(elf->e_entry);
	marks[MARK_NSYM] = 1;	/* XXX: Kernel needs >= 0 */
	marks[MARK_SYM] = LOADADDR(elfp);
	marks[MARK_END] = LOADADDR(maxp);

	return 0;
}
@


1.25
log
@Boot using BIOS from /etc/firmware/vmm-bios by default.

Instead of using the internal "vmboot", VMs will now be booted using
the external BIOS firmware in /etc/firmware/vmm-bios (which is subject
to a LGPLv3 license).  Direct booting of OpenBSD kernels or
non-default BIOS images is still supported for now using the -b/boot
option that is replacing the -k/kernel option.

As requested by Theo, vmd(8) fails if neither the default BIOS is
found nor a kernel has been specified in the VM configuration.  The
"vmm" BIOS has to be installed using fw_update(1), which will be done
automatically in most cases where the OpenBSD can fetch it after
install/upgrade.

OK mlarkin@@
@
text
@d2 1
a2 1
/* $OpenBSD: loadfile_elf.c,v 1.24 2017/02/04 07:23:25 mlarkin Exp $ */
d398 1
a398 1
	ba[2] = memmap_sz;     /* next */
d403 1
a403 1
	consdev.consdev = makedev(8, 0);        /* com1 @@ 0x3f8 */
@


1.24
log
@missing function prototype
@
text
@d2 1
a2 1
/* $OpenBSD: loadfile_elf.c,v 1.23 2017/01/17 21:51:01 krw Exp $ */
a127 1
static size_t mread(FILE *, paddr_t, size_t);
d259 1
a259 1
 * loadelf_main
d265 1
a265 1
 *  fd: file descriptor of a kernel file to load
d276 1
a276 1
loadelf_main(FILE *fp, struct vm_create_params *vcp,
d295 2
a296 1
	}
d316 2
d489 1
a489 1
static size_t
@


1.23
log
@Nuke some whitespace that keeps poking me in the eye as I try to
steal code.
@
text
@d2 1
a2 1
/* $OpenBSD: loadfile_elf.c,v 1.22 2016/11/26 20:03:42 reyk Exp $ */
d127 1
@


1.22
log
@Implement basic support for boot.conf(8) on the disk image.

Like the real boot loader, load and parse hd0a:/etc/boot.conf from the
first disk and fall back to /bsd.  Not all boot loader options are
supported, but it at least does set device, set image, and boot -acds
(eg. for booting single-user).

For example, it can now boot install60.fs that includes a boot.conf
with "set image /6.0/amd64/bsd.rd":
	vmctl start install -c -d install60.fs -d OpenBSD.img

This pseudo-bootloader is only needed without BIOS and could
potentially be replaced in the future.

OK mlarkin@@
@
text
@d2 1
a2 1
/* $OpenBSD: loadfile_elf.c,v 1.21 2016/11/24 07:58:55 reyk Exp $ */
d236 1
a236 1
	}	
@


1.21
log
@Add support for booting the kernel from the disk image.

This make the kernel/-k argument optional and, if not specified, tries
to find the /bsd kernel in the primary hd0a partition of the first
disk image itself.  It doesn't support hd0a:/etc/boot.conf yet, and it
is no BIOS or full boot loader, but it makes booting and handling of
VMs a bit easier - booting an external kernel is still supported.

The UFS file system code ufs.c is directly from libsa which is also
used by the real boot loader.  The code compiles with a few signedness
warning which will be fixed separately.

OK mlarkin@@
@
text
@d2 1
a2 1
/* $OpenBSD: loadfile_elf.c,v 1.20 2016/10/26 05:26:36 mlarkin Exp $ */
d125 1
a125 1
static size_t push_stack(uint32_t, uint32_t);
d268 2
d276 2
a277 1
loadelf_main(FILE *fp, struct vm_create_params *vcp, struct vcpu_reg_state *vrs)
d304 1
a304 1
	stacksize = push_stack(bootargsz, marks[MARK_END]);
d440 2
d447 1
a447 1
push_stack(uint32_t bootargsz, uint32_t end)
d455 3
d464 2
a465 2
	stack[--loc] = MAKEBOOTDEV(0x4, 0, 0, 0, 0); /* bootdev: sd0a */
	stack[--loc] = 0x0;
@


1.20
log
@
vmd(8)/vmctl(8) for i386. Some ugliness in #ifdef __i386__ areas will be
fixed in tree, but the changes required were pretty minimal.

Note that i386 hosts are still presently limited to running i386 guests.

ok deraadt, stefan, jca
@
text
@d2 1
a2 1
/* $OpenBSD: loadfile_elf.c,v 1.19 2016/09/17 17:39:34 jasper Exp $ */
d121 2
a122 2
static int elf32_exec(int, Elf32_Ehdr *, u_long *, int);
static int elf64_exec(int, Elf64_Ehdr *, u_long *, int);
d127 1
a127 1
static size_t mread(int, paddr_t, size_t);
d274 1
a274 1
loadelf_main(int fd, struct vm_create_params *vcp, struct vcpu_reg_state *vrs)
d282 1
a282 1
	if ((r = read(fd, &hdr, sizeof(hdr))) != sizeof(hdr))
d288 1
a288 1
		r = elf32_exec(fd, &hdr.elf32, marks, LOAD_ALL);
d291 1
a291 1
		r = elf64_exec(fd, &hdr.elf64, marks, LOAD_ALL);
d479 1
a479 1
mread(int fd, paddr_t addr, size_t sz)
d481 1
a481 1
	int ct;
d499 1
a499 1
		if (read(fd, buf, ct) != ct) {
d523 1
a523 1
		if (read(fd, buf, ct) != ct) {
d671 1
a671 1
elf64_exec(int fd, Elf64_Ehdr *elf, u_long *marks, int flags)
d677 1
a677 1
	ssize_t sz;
d686 1
a686 1
	if (lseek(fd, (off_t)elf->e_phoff, SEEK_SET) == -1)  {
d691 1
a691 1
	if (read(fd, phdr, sz) != sz) {
d731 1
a731 1
			if (lseek(fd, (off_t)phdr[i].p_offset,
d736 1
a736 1
			if (mread(fd, phdr[i].p_paddr, phdr[i].p_filesz) !=
d776 1
a776 1
		if (lseek(fd, (off_t)elf->e_shoff, SEEK_SET) == -1)  {
d783 1
a783 1
		if (read(fd, shp, sz) != sz) {
d791 1
a791 1
		ssize_t shstrsz = shp[elf->e_shstrndx].sh_size;
d793 1
a793 1
		if (lseek(fd, (off_t)shp[elf->e_shstrndx].sh_offset,
d799 1
a799 1
		if (read(fd, shstr, shstrsz) != shstrsz) {
d822 1
a822 1
					if (lseek(fd, (off_t)shp[i].sh_offset,
d828 1
a828 1
					if (mread(fd, maxp,
d893 1
a893 1
elf32_exec(int fd, Elf32_Ehdr *elf, u_long *marks, int flags)
d899 1
a899 1
	ssize_t sz;
d908 1
a908 1
	if (lseek(fd, (off_t)elf->e_phoff, SEEK_SET) == -1)  {
d913 1
a913 1
	if (read(fd, phdr, sz) != sz) {
d953 1
a953 1
			if (lseek(fd, (off_t)phdr[i].p_offset,
d958 1
a958 1
			if (mread(fd, phdr[i].p_paddr, phdr[i].p_filesz) !=
d998 1
a998 1
		if (lseek(fd, (off_t)elf->e_shoff, SEEK_SET) == -1)  {
d1005 1
a1005 1
		if (read(fd, shp, sz) != sz) {
d1013 1
a1013 1
		ssize_t shstrsz = shp[elf->e_shstrndx].sh_size;
d1015 1
a1015 1
		if (lseek(fd, (off_t)shp[elf->e_shstrndx].sh_offset,
d1021 1
a1021 1
		if (read(fd, shstr, shstrsz) != shstrsz) {
d1043 1
a1043 1
					if (lseek(fd, (off_t)shp[i].sh_offset,
d1049 1
a1049 1
					if (mread(fd, maxp,
@


1.19
log
@move the .SUNW_ctf section name definition to exec_elf.h and document it in elf(5)

feedback from guenther@@
ok guenther@@ kettenis@@
@
text
@d2 1
a2 1
/* $OpenBSD: loadfile_elf.c,v 1.18 2016/09/13 19:07:47 jasper Exp $ */
d113 5
d120 1
d153 5
d161 1
d169 3
d174 1
d192 3
d196 1
d199 4
d204 1
d232 7
d255 1
d303 4
d309 1
@


1.18
log
@sync with sys/lib/libsa/loadfile_elf.c -r1.12 and load the .SUNW_ctf section

pointed out by mlarkin@@
@
text
@d2 1
a2 1
/* $OpenBSD: loadfile_elf.c,v 1.17 2016/09/01 16:04:47 stefan Exp $ */
d782 1
a782 1
			    !strcmp(shstr + shp[i].sh_name, ".SUNW_ctf")) {
@


1.17
log
@Make vcpu_reset_regs use new writeregs code

Makes reset code a little simpler. ok mlarkin@@
@
text
@d2 1
a2 1
/* $OpenBSD: loadfile_elf.c,v 1.16 2016/08/17 05:07:13 deraadt Exp $ */
d781 2
a782 1
			    !strcmp(shstr + shp[i].sh_name, ".debug_line")) {
@


1.16
log
@small bits of header cleanup; ok mlarkin
@
text
@d2 1
a2 1
/* $OpenBSD: loadfile_elf.c,v 1.15 2016/05/26 17:10:15 stefan Exp $ */
d234 1
a234 1
 *  (out) vis: register state to set on init for this kernel
d241 1
a241 1
loadelf_main(int fd, struct vm_create_params *vcp, struct vcpu_init_state *vis)
d270 3
a272 3
	vis->vis_rip = (uint64_t)marks[MARK_ENTRY];
	vis->vis_rsp = (uint64_t)(STACK_PAGE + PAGE_SIZE) - stacksize;
	vis->vis_gdtr.vsi_base = GDT_PAGE;
@


1.15
log
@Copy ELF headers into guest VM memory

This gives ddb access to the symbols of the kernel running inside the VM.
ok mlarkin@@
@
text
@d2 1
a2 1
/* $OpenBSD: loadfile_elf.c,v 1.14 2016/04/07 07:02:57 mlarkin Exp $ */
d84 6
a97 1
#include <sys/ioctl.h>
a99 5
#include <sys/param.h>
#include <sys/reboot.h>
#include <sys/exec.h>

#include <sys/exec_elf.h>
@


1.14
log
@
Place a BOOTARG_END section at the end of the boot arguments list pushed
to the VM during boot. i386 guest kernels need this marker to boot, and
with this diff, it is possible to install and run an OpenBSD i386 guest
VM using vmm(4). Note that i386 guests require a host CPU that supports
unrestricted guest mode (eg, post-Nehalem) for the time being, hopefully
this can be addressed later.
@
text
@d2 1
a2 1
/* $OpenBSD: loadfile_elf.c,v 1.13 2016/04/05 09:33:05 mlarkin Exp $ */
d124 1
a124 1
static void mbcopy(char *, char *, int);
d596 1
a596 1
 * copies 'sz' bytes from guest paddr 'src' to guest paddr 'dst'.
d599 1
a599 1
 *  src: source guest paddr_t to copy from
a604 2
 *
 * XXX - unimplemented. this is used when loading symbols.
d607 1
a607 1
mbcopy(char *src, char *dst, int sz)
d609 1
a609 1
	log_warnx("warning: bcopy during ELF kernel load not supported");
d806 1
a806 1
			mbcopy((char *)shp, (char *)shpp, sz);
d821 1
a821 1
		mbcopy((char *)elf, (char *)elfp, sizeof(*elf));
d1027 1
a1027 1
			mbcopy((void *)shp, (void *)shpp, sz);
d1042 1
a1042 1
		mbcopy((void *)elf, (void *)elfp, sizeof(*elf));
@


1.13
log
@
Support processors without unrestricted guest capability.

ok stefan
@
text
@d2 1
a2 1
/* $OpenBSD: loadfile_elf.c,v 1.12 2016/04/04 17:13:54 stefan Exp $ */
d369 3
@


1.12
log
@Directly use physical addresses from ELF header for kernel loading.

This allows us to remove the 'do_mask' parameters in read_mem and
write_mem as well as the address mask operaton itself.

ok mlarkin@@
@
text
@d2 1
a2 1
/* $OpenBSD: loadfile_elf.c,v 1.11 2016/03/13 13:11:47 stefan Exp $ */
d103 1
a107 4
#define BOOTARGS_PAGE 0x2000
#define GDT_PAGE 0x10000
#define STACK_PAGE 0xF000

d195 31
d265 1
@


1.11
log
@Introduce memory ranges to support VMs with >= 4G RAM

Kernel bits:
- When creating a VM, a list of memory ranges has to be specified,
  similar to the BIOS memory map. This is necessary for VMs with
  RAM sizes approaching 4G because we'll need PCI MMIO space in
  the higher parts of the 32 bit address space.

vmctl and vmd bits:
- Construct appropriate memory ranges to create a VM with a given
  RAM size
- Construct a corresponding BIOS memory map from the memory ranges
  and update the boot params page accordingly.
- Make sure that all variables that represent guest physical addresses
  match the address width of the target CPU instead of using uint32_t.
- Fix some integer promotion glitches that actually restricted VM
  RAM size to 2G.

This changes the VM create ioctl interface, so update your kernel,
vmd, and vmctl.

ok mlarkin@@
@
text
@d2 1
a2 1
/* $OpenBSD: loadfile_elf.c,v 1.10 2016/03/04 15:34:14 stefan Exp $ */
d194 1
a194 1
	write_mem(GDT_PAGE, gdtpage, PAGE_SIZE, 1);
d341 1
a341 1
	write_mem(BOOTARGS_PAGE, ba, PAGE_SIZE, 1);
d389 1
a389 1
	write_mem(STACK_PAGE, &stack, PAGE_SIZE, 1);
d435 1
a435 1
		if (write_mem(addr, buf, ct, 1))
d459 1
a459 1
		if (write_mem(addr, buf, ct, 1))
d496 1
a496 1
		if (write_mem(addr, buf, ct, 1))
d511 1
a511 1
		if (write_mem(addr, buf, ct, 1))
d544 1
a544 1
		if (write_mem(addr, buf, ct, 1))
d556 1
a556 1
		if (write_mem(addr, buf, ct, 1))
d668 1
a668 2
			if (mread(fd, (phdr[i].p_paddr -
			    0xffffffff80000000ULL), phdr[i].p_filesz) !=
d689 1
a689 2
			mbzero((phdr[i].p_paddr -
			    0xffffffff80000000 + phdr[i].p_filesz),
@


1.10
log
@Set root device to sd0a, instead of wd0a. Virtio devices show up
as sd. Original diff from Patrick Wildt.

In addition, using the MAKEBOOTDEV macro no longer makes bsd
ask for the root disk on VM boot.

ok mlarkin@@
@
text
@d2 1
a2 1
/* $OpenBSD: loadfile_elf.c,v 1.9 2016/01/16 08:55:40 stefan Exp $ */
a110 2
#define LOWMEM_KB 636

d120 3
a122 2
static void push_bootargs(int);
static size_t push_stack(int, uint32_t);
d124 3
a126 3
static size_t mread(int, uint32_t, size_t);
static void marc4random_buf(uint32_t, int);
static void mbzero(uint32_t, int);
d200 2
a201 3
 * Loads an ELF kernel to it's defined load address in the guest VM whose
 * ID is provided in 'vm_id_in'. The kernel is loaded to its defined start
 * point as set in the ELF header.
d205 1
a205 3
 *  vm_id_in: ID of the VM to load the kernel into
 *  mem_sz: memory size in MB assigned to the guest (passed through to
 *      push_bootargs)
d213 1
a213 1
loadelf_main(int fd, int vm_id_in, int mem_sz, struct vcpu_init_state *vis)
d216 2
a217 1
	size_t stacksize;
d219 1
a219 2

	vm_id = vm_id_in;
a235 1
	push_bootargs(mem_sz);
d237 3
a239 1
	stacksize = push_stack(mem_sz, marks[MARK_END]);
d249 52
d309 2
a310 1
 *  mem_sz: guest memory size in MB
d313 1
a313 1
 *  nothing
d315 2
a316 2
static void
push_bootargs(int mem_sz)
d318 1
a318 2
	size_t sz;
	bios_memmap_t memmap[3];
d322 1
a322 16
	/* First memory region: 0 - LOWMEM_KB (DOS low mem) */
	memmap[0].addr = 0x0;
	memmap[0].size = LOWMEM_KB * 1024;
	memmap[0].type = 0x1;	/* Type 1 : Normal memory */

	/* Second memory region: 1MB - n, reserve top 1MB */
	memmap[1].addr = 0x100000;
	memmap[1].size = (mem_sz - 1) * 1024 * 1024;
	memmap[1].type = 0x1;	/* Type 1 : Normal memory */

	/* Null mem map entry to denote the end of the ranges */
	memmap[2].addr = 0x0;
	memmap[2].size = 0x0;
	memmap[2].type = 0x0;

	sz = 3 * sizeof(int) + 3 * sizeof(bios_memmap_t);
d324 4
a327 4
	ba[1] = sz;
	ba[2] = sz;     /* next */
	memcpy(&ba[3], &memmap, 3 * sizeof(bios_memmap_t));
	sz = sz / sizeof(int);
d335 5
a339 4
	ba[sz] = 0x5;   /* consdev */
	ba[sz + 1] = (int)sizeof(bios_consdev_t) + 3 * sizeof(int);
	ba[sz + 2] = (int)sizeof(bios_consdev_t) + 3 * sizeof(int);
	memcpy(&ba[sz + 3], &consdev, sizeof(bios_consdev_t));
d342 2
d359 2
a360 2
 *  TOS - 0x8	size of low memory in KB
 *  TOS - 0xc	size of high memory in KB
d365 1
a365 1
 *  mem_sz: size of guest VM memory, in MB
d372 1
a372 1
push_stack(int mem_sz, uint32_t end)
d381 3
a383 5
	stack[--loc] = 3 * sizeof(bios_memmap_t) +
	    sizeof(bios_consdev_t) +
	    6 * sizeof(int);
	stack[--loc] = LOWMEM_KB;
	stack[--loc] = mem_sz * 1024 - LOWMEM_KB;
d398 1
a398 2
 * into the guest address space at paddr 'addr'. Note that the guest
 * paddr is limited to 32 bit (4GB).
d409 1
a409 1
mread(int fd, uint32_t addr, size_t sz)
d470 1
a470 1
 * 'addr'. Note that the guest paddr is limited to 32 bit (4GB).
d480 1
a480 1
marc4random_buf(uint32_t addr, int sz)
d520 1
a520 1
 * 'addr'. Note that the guest paddr is limited to 32 bit (4GB)
d530 1
a530 1
mbzero(uint32_t addr, int sz)
a564 1
 * Both 'src' and 'dst' are limited to 32 bit (4GB)
d668 1
a668 1
			if (mread(fd, (uint32_t)(phdr[i].p_paddr -
d690 1
a690 1
			mbzero((uint32_t)(phdr[i].p_paddr -
d761 1
a761 1
					if (mread(fd, (uint32_t)maxp,
d982 1
a982 1
					if (mread(fd, (uint32_t)maxp,
@


1.9
log
@vmd(8) sometimes attempts page-crossing data copies between the host
and guest. The readpage/writepage ioctls of vmm(4) do not support this
and they return EINVAL on such attempts since recently.

Avoid page-crossing guest memory accesses by changing read_page() and
write_page() into read_mem() and write_mem() that can copy arbitrary
lengths of data between host<->guest without page-crossing accesses.

This also allows us to remove page-wise copy-loops in a few places.

ok mlarkin@@
@
text
@d2 1
a2 1
/* $OpenBSD: loadfile_elf.c,v 1.8 2016/01/05 06:55:28 mlarkin Exp $ */
d96 1
d351 1
a351 1
	stack[--loc] = 0x0;
@


1.8
log
@
Make some things static that are only used in loadfile_elf.c

diff from Michal Mazurek, thanks!
@
text
@d2 1
a2 1
/* $OpenBSD: loadfile_elf.c,v 1.7 2016/01/05 06:54:03 mlarkin Exp $ */
d194 1
a194 1
	write_page(GDT_PAGE, gdtpage, PAGE_SIZE, 1);
d305 1
a305 1
	write_page(BOOTARGS_PAGE, ba, PAGE_SIZE, 1);
d353 1
a353 1
	write_page(STACK_PAGE, &stack, PAGE_SIZE, 1);
d382 1
a382 1
	 * write_page
d400 1
a400 1
		if (write_page(addr, buf, ct, 1))
d424 1
a424 1
		if (write_page(addr, buf, ct, 1))
d452 1
a452 1
	 * write_page
d461 1
a461 1
		if (write_page(addr, buf, ct, 1))
d476 1
a476 1
		if (write_page(addr, buf, ct, 1))
d502 1
a502 1
	 * write_page
d509 1
a509 1
		if (write_page(addr, buf, ct, 1))
d521 1
a521 1
		if (write_page(addr, buf, ct, 1))
@


1.7
log
@
Fail fast if elf64_exec fails. No need to populate the bootargs/stack
and gdt pages if we couldn't load the kernel.

diff from Michal Mazurek, thanks!
@
text
@d2 1
a2 1
/* $OpenBSD: loadfile_elf.c,v 1.6 2016/01/05 06:51:54 mlarkin Exp $ */
d119 2
a120 2
int elf32_exec(int, Elf32_Ehdr *, u_long *, int);
int elf64_exec(int, Elf64_Ehdr *, u_long *, int);
d568 1
a568 1
int
d791 1
a791 1
int
@


1.6
log
@
more bzero -> memset conversions

from Michal Mazurek, thanks!
@
text
@d2 1
a2 1
/* $OpenBSD: loadfile_elf.c,v 1.5 2015/12/17 09:29:28 mlarkin Exp $ */
d236 3
d247 1
a247 1
	return r;
@


1.5
log
@
Move vcpu register state init to vmd. Allows vmd bootloader to make the
decision as to how the vcpu should be set up for initial start and
reset. Also removes some hardcoded register constants from vmm(4).

ok jsing@@, mpi@@
@
text
@d2 1
a2 1
/* $OpenBSD: loadfile_elf.c,v 1.4 2015/12/06 17:42:15 mlarkin Exp $ */
d181 1
a181 1
	bzero(&gdtpage, sizeof(gdtpage));
d187 1
a187 1
	 * GDT[0] : null desriptor. "Created" via bzero above.
d227 1
a227 1
	bzero(&marks, sizeof(marks));
d336 1
a336 1
	bzero(&stack, sizeof(stack));
d385 1
a385 1
		bzero(buf, sizeof(buf));
d409 1
a409 1
		bzero(buf, sizeof(buf));
d453 1
a453 1
		bzero(buf, sizeof(buf));
d465 1
a465 1
		bzero(buf, sizeof(buf));
d502 1
a502 1
	bzero(buf, sizeof(buf));
@


1.4
log
@
un-needed extern which was removed a while back
@
text
@d2 1
a2 1
/* $OpenBSD: loadfile_elf.c,v 1.3 2015/12/03 08:42:11 reyk Exp $ */
a97 2
#include "loadfile.h"
#include "vmd.h"
d103 3
a118 1
int loadelf_main(int fd, int, int);
d122 1
a122 1
static void push_stack(int, uint32_t);
d209 1
d216 1
a216 1
loadelf_main(int fd, int vm_id_in, int mem_sz)
d219 1
d238 5
a242 1
	push_stack(mem_sz, marks[MARK_END]);
d328 1
a328 1
 *  nothing
d330 1
a330 1
static void
d351 2
@


1.3
log
@spacing
@
text
@d2 1
a2 1
/* $OpenBSD: loadfile_elf.c,v 1.2 2015/11/23 13:04:49 reyk Exp $ */
a129 1
extern int vmm_fd;
@


1.2
log
@Add support for logging to stderr or syslog, and to run vmd in
foreground with -d.

OK mlarkin@@ jung@@
@
text
@d2 1
a2 1
/* $OpenBSD: loadfile_elf.c,v 1.1 2015/11/22 20:20:32 mlarkin Exp $ */
d223 1
a223 1
        if ((r = read(fd, &hdr, sizeof(hdr))) != sizeof(hdr))
d379 1
a379 1
		if (sz > PAGE_SIZE)  
d593 2
a594 1
					marc4random_buf(phdr[i].p_paddr + pos, m);
d619 2
a620 1
			if (lseek(fd, (off_t)phdr[i].p_offset, SEEK_SET) == -1) {
d816 2
a817 1
					marc4random_buf(phdr[i].p_paddr + pos, m);
d842 2
a843 1
			if (lseek(fd, (off_t)phdr[i].p_offset, SEEK_SET) == -1) {
@


1.1
log
@
vmd(8) - virtual machine daemon.

There is still a lot to be done, and fixed, in these userland components
but I have received enough "it works, commit it" emails that it's time
to finish those things in tree.

discussed with many, tested by many.
@
text
@d2 1
a2 1
/* $OpenBSD: loadfile_elf.c,v 1.11 2015/05/19 20:39:12 miod Exp $ */
d385 1
a385 2
			fprintf(stderr, "%s: error %d in mread (%s)\n\r",
			    __progname, errno, strerror(errno));
d409 1
a409 2
			fprintf(stderr, "%s: error %d in mread (%s)\n\r",
			    __progname, errno, strerror(errno));
d535 1
a535 2
	fprintf(stderr, "warning: bcopy during ELF kernel load not "
	    "supported\n\r");
@

