head	1.27;
access;
symbols
	OPENBSD_6_1:1.23.0.4
	OPENBSD_6_1_BASE:1.23
	OPENBSD_6_0:1.7.0.2
	OPENBSD_6_0_BASE:1.7
	OPENBSD_5_9:1.5.0.2
	OPENBSD_5_9_BASE:1.5;
locks; strict;
comment	@ * @;


1.27
date	2017.04.21.11.02.10;	author reyk;	state Exp;
branches;
next	1.26;
commitid	yOEgIC4dRGccH6LI;

1.26
date	2017.04.21.07.03.26;	author reyk;	state Exp;
branches;
next	1.25;
commitid	B4wb6zF2A8q3ls4h;

1.25
date	2017.04.19.15.38.32;	author reyk;	state Exp;
branches;
next	1.24;
commitid	Wp87uvjcKIIYK6nL;

1.24
date	2017.04.06.21.35.22;	author reyk;	state Exp;
branches;
next	1.23;
commitid	3OpsdjovgnUZUY1n;

1.23
date	2017.03.27.00.28.04;	author deraadt;	state Exp;
branches;
next	1.22;
commitid	cbObO83mNT8jlhy1;

1.22
date	2017.03.02.07.33.37;	author reyk;	state Exp;
branches;
next	1.21;
commitid	0uvzhmQVR7Ehsjus;

1.21
date	2017.03.01.07.43.33;	author reyk;	state Exp;
branches;
next	1.20;
commitid	2hnfyuVZdSB2L5DB;

1.20
date	2017.01.13.19.21.16;	author edd;	state Exp;
branches;
next	1.19;
commitid	G03UUOsXsvVsTKN2;

1.19
date	2017.01.05.13.53.10;	author krw;	state Exp;
branches;
next	1.18;
commitid	3AKCl24jEn0sIt6p;

1.18
date	2017.01.05.12.42.19;	author krw;	state Exp;
branches;
next	1.17;
commitid	uzjOUwLRoN7KbcZI;

1.17
date	2016.12.14.21.17.25;	author reyk;	state Exp;
branches;
next	1.16;
commitid	yUESeopyz7N219vi;

1.16
date	2016.11.22.11.31.38;	author edd;	state Exp;
branches;
next	1.15;
commitid	vSgc5Dc31FPMjVfo;

1.15
date	2016.11.04.15.16.44;	author reyk;	state Exp;
branches;
next	1.14;
commitid	SAdDSuqFvlzVuxeB;

1.14
date	2016.11.04.15.07.26;	author reyk;	state Exp;
branches;
next	1.13;
commitid	qfn7LnsEzfGhtk0c;

1.13
date	2016.10.29.14.58.54;	author reyk;	state Exp;
branches;
next	1.12;
commitid	QIYzlpe5Bso6WshE;

1.12
date	2016.10.29.14.56.05;	author edd;	state Exp;
branches;
next	1.11;
commitid	DOewrpkDk9kNopaK;

1.11
date	2016.10.17.16.26.20;	author reyk;	state Exp;
branches;
next	1.10;
commitid	QbpP9IWB9tkvRriq;

1.10
date	2016.10.15.14.02.11;	author reyk;	state Exp;
branches;
next	1.9;
commitid	17YGcUnMa3ic5LJQ;

1.9
date	2016.10.05.17.31.22;	author reyk;	state Exp;
branches;
next	1.8;
commitid	ytodVxVkdtyqt1Ju;

1.8
date	2016.10.05.17.30.13;	author reyk;	state Exp;
branches;
next	1.7;
commitid	c3mC9fNmRbfUPluH;

1.7
date	2016.06.21.21.35.25;	author benno;	state Exp;
branches;
next	1.6;
commitid	AL6SnrmnHkmPOpjv;

1.6
date	2016.03.13.13.11.47;	author stefan;	state Exp;
branches;
next	1.5;
commitid	tNFHzbetplEWT4Tg;

1.5
date	2015.12.07.13.30.06;	author reyk;	state Exp;
branches;
next	1.4;
commitid	mBBAtLD4JRCkZZ93;

1.4
date	2015.12.07.12.52.00;	author reyk;	state Exp;
branches;
next	1.3;
commitid	vtOi4oysH69IOu0c;

1.3
date	2015.12.06.21.02.51;	author reyk;	state Exp;
branches;
next	1.2;
commitid	Zp1KJ8lrcRoKUs6F;

1.2
date	2015.12.06.01.16.22;	author reyk;	state Exp;
branches;
next	1.1;
commitid	5ndAmp7Zc65BMaks;

1.1
date	2015.12.03.16.11.32;	author reyk;	state Exp;
branches;
next	;
commitid	G1u4CGxMrb6r5d6R;


desc
@@


1.27
log
@Fail if vm.conf exists but cannot be opened, ignore if it doesn't exist.

This fixes 'vmd -nf /etv/vm.conf' if the file is not readable.
@
text
@/*	$OpenBSD: parse.y,v 1.26 2017/04/21 07:03:26 reyk Exp $	*/

/*
 * Copyright (c) 2007-2016 Reyk Floeter <reyk@@openbsd.org>
 * Copyright (c) 2004, 2005 Esben Norby <norby@@openbsd.org>
 * Copyright (c) 2004 Ryan McBride <mcbride@@openbsd.org>
 * Copyright (c) 2002, 2003, 2004 Henning Brauer <henning@@openbsd.org>
 * Copyright (c) 2001 Markus Friedl.  All rights reserved.
 * Copyright (c) 2001 Daniel Hartmeier.  All rights reserved.
 * Copyright (c) 2001 Theo de Raadt.  All rights reserved.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

%{
#include <sys/types.h>
#include <sys/queue.h>
#include <sys/socket.h>
#include <sys/uio.h>

#include <machine/vmmvar.h>

#include <net/if.h>
#include <netinet/in.h>
#include <netinet/if_ether.h>

#include <stdio.h>
#include <stdlib.h>
#include <limits.h>
#include <stdarg.h>
#include <string.h>
#include <ctype.h>
#include <netdb.h>
#include <util.h>
#include <errno.h>
#include <err.h>
#include <pwd.h>
#include <grp.h>

#include "proc.h"
#include "vmd.h"

TAILQ_HEAD(files, file)		 files = TAILQ_HEAD_INITIALIZER(files);
static struct file {
	TAILQ_ENTRY(file)	 entry;
	FILE			*stream;
	char			*name;
	int			 lineno;
	int			 errors;
} *file, *topfile;
struct file	*pushfile(const char *, int);
int		 popfile(void);
int		 yyparse(void);
int		 yylex(void);
int		 yyerror(const char *, ...)
    __attribute__((__format__ (printf, 1, 2)))
    __attribute__((__nonnull__ (1)));
int		 kw_cmp(const void *, const void *);
int		 lookup(char *);
int		 lgetc(int);
int		 lungetc(int);
int		 findeol(void);

TAILQ_HEAD(symhead, sym)	 symhead = TAILQ_HEAD_INITIALIZER(symhead);
struct sym {
	TAILQ_ENTRY(sym)	 entry;
	int			 used;
	int			 persist;
	char			*nam;
	char			*val;
};
int		 symset(const char *, const char *, int);
char		*symget(const char *);

ssize_t		 parse_size(char *, int64_t);
int		 parse_disk(char *);

static struct vmop_create_params vmc;
static struct vm_create_params	*vcp;
static struct vmd_switch	*vsw;
static struct vmd_if		*vif;
static struct vmd_vm		*vm;
static unsigned int		 vsw_unit;
static char			 vsw_type[IF_NAMESIZE];
static int			 vcp_disable;
static size_t			 vcp_nnics;
static int			 errors;
extern struct vmd		*env;
extern const char		*vmd_descsw[];

typedef struct {
	union {
		uint8_t		 lladdr[ETHER_ADDR_LEN];
		int64_t		 number;
		char		*string;
		struct {
			uid_t	 uid;
			int64_t	 gid;
		}		 owner;
	} v;
	int lineno;
} YYSTYPE;

%}


%token	INCLUDE ERROR
%token	ADD DISK DOWN GROUP INTERFACE NIFS PATH SIZE SWITCH UP VMID
%token	ENABLE DISABLE VM BOOT LLADDR MEMORY OWNER LOCKED LOCAL PREFIX
%token	<v.string>	STRING
%token  <v.number>	NUMBER
%type	<v.number>	disable
%type	<v.number>	local
%type	<v.number>	locked
%type	<v.number>	updown
%type	<v.lladdr>	lladdr
%type	<v.string>	string
%type	<v.string>	optstring
%type	<v.owner>	owner_id

%%

grammar		: /* empty */
		| grammar include '\n'
		| grammar '\n'
		| grammar varset '\n'
		| grammar main '\n'
		| grammar switch '\n'
		| grammar vm '\n'
		| grammar error '\n'		{ file->errors++; }
		;

include		: INCLUDE string		{
			struct file	*nfile;

			if ((nfile = pushfile($2, 0)) == NULL) {
				yyerror("failed to include file %s", $2);
				free($2);
				YYERROR;
			}
			free($2);

			file = nfile;
			lungetc('\n');
		}
		;

varset		: STRING '=' STRING		{
			char *s = $1;
			while (*s++) {
				if (isspace((unsigned char)*s)) {
					yyerror("macro name cannot contain "
					    "whitespace");
					YYERROR;
				}
			}
			if (symset($1, $3, 0) == -1)
				fatalx("cannot store variable");
			free($1);
			free($3);
		}
		;

main		: LOCAL PREFIX STRING {
			struct address	 h;

			/* The local prefix is IPv4-only */
			if (host($3, &h) == -1 ||
			    h.ss.ss_family != AF_INET ||
			    h.prefixlen > 32 || h.prefixlen < 0) {
				yyerror("invalid local prefix: %s", $3);
				free($3);
				YYERROR;
			}

			memcpy(&env->vmd_cfg.cfg_localprefix, &h, sizeof(h));
		}
		;

switch		: SWITCH string			{
			if ((vsw = calloc(1, sizeof(*vsw))) == NULL)
				fatal("could not allocate switch");

			vsw->sw_id = env->vmd_nswitches + 1;
			vsw->sw_name = $2;
			vsw->sw_flags = VMIFF_UP;
			snprintf(vsw->sw_ifname, sizeof(vsw->sw_ifname),
			    "%s%u", vsw_type, vsw_unit++);
			TAILQ_INIT(&vsw->sw_ifs);

			vcp_disable = 0;
		} '{' optnl switch_opts_l '}'	{
			if (vcp_disable) {
				log_debug("%s:%d: switch \"%s\""
				    " skipped (disabled)",
				    file->name, yylval.lineno, vsw->sw_name);
			} else if (!env->vmd_noaction) {
				TAILQ_INSERT_TAIL(env->vmd_switches, vsw, sw_entry);
				env->vmd_nswitches++;
				log_debug("%s:%d: switch \"%s\" registered",
				    file->name, yylval.lineno, vsw->sw_name);
			}
		}
		;

switch_opts_l	: switch_opts_l switch_opts nl
		| switch_opts optnl
		;

switch_opts	: disable			{
			vcp_disable = $1;
		}
		| ADD string			{
			char		type[IF_NAMESIZE];

			if ((vif = calloc(1, sizeof(*vif))) == NULL)
				fatal("could not allocate interface");

			if (priv_getiftype($2, type, NULL) == -1) {
				yyerror("invalid interface: %s", $2);
				free($2);
				YYERROR;
			}
			vif->vif_name = $2;

			TAILQ_INSERT_TAIL(&vsw->sw_ifs, vif, vif_entry);
		}
		| GROUP string			{
			if (priv_validgroup($2) == -1) {
				yyerror("invalid group name: %s", $2);
				free($2);
				YYERROR;
			}
			vsw->sw_group = $2;
		}
		| INTERFACE string		{
			if (priv_getiftype($2, vsw_type, &vsw_unit) == -1 ||
			    priv_findname(vsw_type, vmd_descsw) == -1) {
				yyerror("invalid switch interface: %s", $2);
				free($2);
				YYERROR;
			}
			vsw_unit++;

			if (strlcpy(vsw->sw_ifname, $2,
			    sizeof(vsw->sw_ifname)) >= sizeof(vsw->sw_ifname)) {
				yyerror("switch interface too long: %s", $2);
				free($2);
				YYERROR;
			}
			free($2);
		}
		| LOCKED LLADDR			{
			vsw->sw_flags |= VMIFF_LOCKED;
		}
		| updown			{
			if ($1)
				vsw->sw_flags |= VMIFF_UP;
			else
				vsw->sw_flags &= ~VMIFF_UP;
		}
		;

vm		: VM string			{
			unsigned int	 i;

			memset(&vmc, 0, sizeof(vmc));
			vcp = &vmc.vmc_params;
			vcp_disable = 0;
			vcp_nnics = 0;

			for (i = 0; i < VMM_MAX_NICS_PER_VM; i++) {
				/* Set the interface to UP by default */
				vmc.vmc_ifflags[i] |= IFF_UP;
			}

			if (strlcpy(vcp->vcp_name, $2, sizeof(vcp->vcp_name)) >=
			    sizeof(vcp->vcp_name)) {
				yyerror("vm name too long");
				YYERROR;
			}

			/* set default user/group permissions */
			vmc.vmc_uid = 0;
			vmc.vmc_gid = -1;
		} '{' optnl vm_opts_l '}'	{
			int ret;

			/* configured interfaces vs. number of interfaces */
			if (vcp_nnics > vcp->vcp_nnics)
				vcp->vcp_nnics = vcp_nnics;

			if (!env->vmd_noaction) {
				ret = vm_register(&env->vmd_ps, &vmc,
				    &vm, 0, 0);
				if (ret == -1 && errno == EALREADY) {
					log_debug("%s:%d: vm \"%s\""
					    " skipped (%s)",
					    file->name, yylval.lineno,
					    vcp->vcp_name, vm->vm_running ?
					    "running" : "already exists");
				} else if (ret == -1) {
					log_warn("%s:%d: vm \"%s\" failed",
					    file->name, yylval.lineno,
					    vcp->vcp_name);
					YYERROR;
				} else {
					if (vcp_disable)
						vm->vm_disabled = 1;
					log_debug("%s:%d: vm \"%s\" registered (%s)",
					    file->name, yylval.lineno,
					    vcp->vcp_name,
					    vcp_disable ? "disabled" : "enabled");
				}
				vm->vm_from_config = 1;
			}
		}
		;

vm_opts_l	: vm_opts_l vm_opts nl
		| vm_opts optnl
		;

vm_opts		: disable			{
			vcp_disable = $1;
		}
		| DISK string			{
			if (parse_disk($2) != 0) {
				yyerror("failed to parse disks: %s", $2);
				free($2);
				YYERROR;
			}
			free($2);
			vmc.vmc_flags |= VMOP_CREATE_DISK;
		}
		| local INTERFACE optstring iface_opts_o {
			unsigned int	i;
			char		type[IF_NAMESIZE];

			i = vcp_nnics;
			if (++vcp_nnics > VMM_MAX_NICS_PER_VM) {
				yyerror("too many interfaces: %zu", vcp_nnics);
				free($3);
				YYERROR;
			}

			if ($1)
				vmc.vmc_ifflags[i] |= VMIFF_LOCAL;
			if ($3 != NULL) {
				if (strcmp($3, "tap") != 0 &&
				    (priv_getiftype($3, type, NULL) == -1 ||
				    strcmp(type, "tap") != 0)) {
					yyerror("invalid interface: %s", $3);
					free($3);
					YYERROR;
				}

				if (strlcpy(vmc.vmc_ifnames[i], $3,
				    sizeof(vmc.vmc_ifnames[i])) >=
				    sizeof(vmc.vmc_ifnames[i])) {
					yyerror("interface name too long: %s",
					    $3);
					free($3);
					YYERROR;
				}
			}
			free($3);
			vmc.vmc_flags |= VMOP_CREATE_NETWORK;
		}
		| BOOT string			{
			if (vcp->vcp_kernel[0] != '\0') {
				yyerror("kernel specified more than once");
				free($2);
				YYERROR;

			}
			if (strlcpy(vcp->vcp_kernel, $2,
			    sizeof(vcp->vcp_kernel)) >=
			    sizeof(vcp->vcp_kernel)) {
				yyerror("kernel name too long");
				free($2);
				YYERROR;
			}
			free($2);
			vmc.vmc_flags |= VMOP_CREATE_KERNEL;
		}
		| NIFS NUMBER			{
			if (vcp->vcp_nnics != 0) {
				yyerror("interfaces specified more than once");
				YYERROR;
			}
			if ($2 < 0 || $2 > VMM_MAX_NICS_PER_VM) {
				yyerror("too many interfaces: %lld", $2);
				YYERROR;
			}
			vcp->vcp_nnics = (size_t)$2;
			vmc.vmc_flags |= VMOP_CREATE_NETWORK;
		}
		| MEMORY NUMBER			{
			ssize_t	 res;
			if (vcp->vcp_memranges[0].vmr_size != 0) {
				yyerror("memory specified more than once");
				YYERROR;
			}
			if ((res = parse_size(NULL, $2)) == -1) {
				yyerror("failed to parse size: %lld", $2);
				YYERROR;
			}
			vcp->vcp_memranges[0].vmr_size = (size_t)res;
			vmc.vmc_flags |= VMOP_CREATE_MEMORY;
		}
		| MEMORY STRING			{
			ssize_t	 res;
			if (vcp->vcp_memranges[0].vmr_size != 0) {
				yyerror("argument specified more than once");
				free($2);
				YYERROR;
			}
			if ((res = parse_size($2, 0)) == -1) {
				yyerror("failed to parse size: %s", $2);
				free($2);
				YYERROR;
			}
			vcp->vcp_memranges[0].vmr_size = (size_t)res;
			vmc.vmc_flags |= VMOP_CREATE_MEMORY;
		}
		| OWNER owner_id		{
			vmc.vmc_uid = $2.uid;
			vmc.vmc_gid = $2.gid;
		}
		;

owner_id	: /* none */		{
			$$.uid = 0;
			$$.gid = -1;
		}
		| NUMBER		{
			$$.uid = $1;
			$$.gid = -1;
		}
		| STRING		{
			char		*user, *group;
			struct passwd	*pw;
			struct group	*gr;

			$$.uid = 0;
			$$.gid = -1;

			user = $1;
			if ((group = strchr(user, ':')) != NULL) {
				if (group == user)
					user = NULL;
				*group++ = '\0';
			}

			if (user != NULL && *user) {
				if ((pw = getpwnam(user)) == NULL) {
					yyerror("failed to get user: %s",
					    user);
					free($1);
					YYERROR;
				}
				$$.uid = pw->pw_uid;
			}

			if (group != NULL && *group) {
				if ((gr = getgrnam(group)) == NULL) {
					yyerror("failed to get group: %s",
					    group);
					free($1);
					YYERROR;
				}
				$$.gid = gr->gr_gid;
			}

			free($1);
		}
		;

iface_opts_o	: '{' optnl iface_opts_l '}'
		| iface_opts_c
		| /* empty */
		;

iface_opts_l	: iface_opts_l iface_opts optnl
		| iface_opts optnl
		;

iface_opts_c	: iface_opts_c iface_opts optcomma
		| iface_opts
		;

iface_opts	: SWITCH string			{
			unsigned int	i = vcp_nnics;

			/* No need to check if the switch exists */
			if (strlcpy(vmc.vmc_ifswitch[i], $2,
			    sizeof(vmc.vmc_ifswitch[i])) >=
			    sizeof(vmc.vmc_ifswitch[i])) {
				yyerror("switch name too long: %s", $2);
				free($2);
				YYERROR;
			}
			free($2);
		}
		| GROUP string			{
			unsigned int	i = vcp_nnics;

			if (priv_validgroup($2) == -1) {
				yyerror("invalid group name: %s", $2);
				free($2);
				YYERROR;
			}

			/* No need to check if the group exists */
			(void)strlcpy(vmc.vmc_ifgroup[i], $2,
			    sizeof(vmc.vmc_ifgroup[i]));
			free($2);
		}
		| locked LLADDR lladdr		{
			if ($1)
				vmc.vmc_ifflags[vcp_nnics] |= VMIFF_LOCKED;
			memcpy(vcp->vcp_macs[vcp_nnics], $3, ETHER_ADDR_LEN);
		}
		| updown			{
			if ($1)
				vmc.vmc_ifflags[vcp_nnics] |= VMIFF_UP;
			else
				vmc.vmc_ifflags[vcp_nnics] &= ~VMIFF_UP;
		}
		;

optstring	: STRING			{ $$ = $1; }
		| /* empty */			{ $$ = NULL; }
		;

string		: STRING string			{
			if (asprintf(&$$, "%s%s", $1, $2) == -1)
				fatal("asprintf string");
			free($1);
			free($2);
		}
		| STRING
		;

lladdr		: STRING			{
			struct ether_addr *ea;

			if ((ea = ether_aton($1)) == NULL) {
				yyerror("invalid address: %s\n", $1);
				free($1);
				YYERROR;
			}
			free($1);

			memcpy($$, ea, ETHER_ADDR_LEN);
		}
		;

local		: /* empty */			{ $$ = 0; }
		| LOCAL				{ $$ = 1; }
		;

locked		: /* empty */			{ $$ = 0; }
		| LOCKED			{ $$ = 1; }
		;

updown		: UP				{ $$ = 1; }
		| DOWN				{ $$ = 0; }
		;

disable		: ENABLE			{ $$ = 0; }
		| DISABLE			{ $$ = 1; }
		;

optcomma	: ','
		|
		;

optnl		: '\n' optnl
		|
		;

nl		: '\n' optnl
		;

%%

struct keywords {
	const char	*k_name;
	int		 k_val;
};

int
yyerror(const char *fmt, ...)
{
	va_list		 ap;
	char		*msg;

	file->errors++;
	va_start(ap, fmt);
	if (vasprintf(&msg, fmt, ap) == -1)
		fatal("yyerror vasprintf");
	va_end(ap);
	log_warnx("%s:%d: %s", file->name, yylval.lineno, msg);
	free(msg);
	return (0);
}

int
kw_cmp(const void *k, const void *e)
{
	return (strcmp(k, ((const struct keywords *)e)->k_name));
}

int
lookup(char *s)
{
	/* this has to be sorted always */
	static const struct keywords keywords[] = {
		{ "add",		ADD },
		{ "boot",		BOOT },
		{ "disable",		DISABLE },
		{ "disk",		DISK },
		{ "down",		DOWN },
		{ "enable",		ENABLE },
		{ "group",		GROUP },
		{ "id",			VMID },
		{ "include",		INCLUDE },
		{ "interface",		INTERFACE },
		{ "interfaces",		NIFS },
		{ "lladdr",		LLADDR },
		{ "local",		LOCAL },
		{ "locked",		LOCKED },
		{ "memory",		MEMORY },
		{ "owner",		OWNER },
		{ "prefix",		PREFIX },
		{ "size",		SIZE },
		{ "switch",		SWITCH },
		{ "up",			UP },
		{ "vm",			VM }
	};
	const struct keywords	*p;

	p = bsearch(s, keywords, sizeof(keywords)/sizeof(keywords[0]),
	    sizeof(keywords[0]), kw_cmp);

	if (p)
		return (p->k_val);
	else
		return (STRING);
}

#define MAXPUSHBACK	128

u_char	*parsebuf;
int	 parseindex;
u_char	 pushback_buffer[MAXPUSHBACK];
int	 pushback_index = 0;

int
lgetc(int quotec)
{
	int		c, next;

	if (parsebuf) {
		/* Read character from the parsebuffer instead of input. */
		if (parseindex >= 0) {
			c = parsebuf[parseindex++];
			if (c != '\0')
				return (c);
			parsebuf = NULL;
		} else
			parseindex++;
	}

	if (pushback_index)
		return (pushback_buffer[--pushback_index]);

	if (quotec) {
		if ((c = getc(file->stream)) == EOF) {
			yyerror("reached end of file while parsing "
			    "quoted string");
			if (file == topfile || popfile() == EOF)
				return (EOF);
			return (quotec);
		}
		return (c);
	}

	while ((c = getc(file->stream)) == '\\') {
		next = getc(file->stream);
		if (next != '\n') {
			c = next;
			break;
		}
		yylval.lineno = file->lineno;
		file->lineno++;
	}
	if (c == '\t' || c == ' ') {
		/* Compress blanks to a single space. */
		do {
			c = getc(file->stream);
		} while (c == '\t' || c == ' ');
		ungetc(c, file->stream);
		c = ' ';
	}

	while (c == EOF) {
		if (file == topfile || popfile() == EOF)
			return (EOF);
		c = getc(file->stream);
	}
	return (c);
}

int
lungetc(int c)
{
	if (c == EOF)
		return (EOF);
	if (parsebuf) {
		parseindex--;
		if (parseindex >= 0)
			return (c);
	}
	if (pushback_index < MAXPUSHBACK-1)
		return (pushback_buffer[pushback_index++] = c);
	else
		return (EOF);
}

int
findeol(void)
{
	int	c;

	parsebuf = NULL;

	/* skip to either EOF or the first real EOL */
	while (1) {
		if (pushback_index)
			c = pushback_buffer[--pushback_index];
		else
			c = lgetc(0);
		if (c == '\n') {
			file->lineno++;
			break;
		}
		if (c == EOF)
			break;
	}
	return (ERROR);
}

int
yylex(void)
{
	u_char	 buf[8096];
	u_char	*p, *val;
	int	 quotec, next, c;
	int	 token;

top:
	p = buf;
	while ((c = lgetc(0)) == ' ' || c == '\t')
		; /* nothing */

	yylval.lineno = file->lineno;
	if (c == '#')
		while ((c = lgetc(0)) != '\n' && c != EOF)
			; /* nothing */
	if (c == '$' && parsebuf == NULL) {
		while (1) {
			if ((c = lgetc(0)) == EOF)
				return (0);

			if (p + 1 >= buf + sizeof(buf) - 1) {
				yyerror("string too long");
				return (findeol());
			}
			if (isalnum(c) || c == '_') {
				*p++ = c;
				continue;
			}
			*p = '\0';
			lungetc(c);
			break;
		}
		val = symget(buf);
		if (val == NULL) {
			yyerror("macro '%s' not defined", buf);
			return (findeol());
		}
		parsebuf = val;
		parseindex = 0;
		goto top;
	}

	switch (c) {
	case '\'':
	case '"':
		quotec = c;
		while (1) {
			if ((c = lgetc(quotec)) == EOF)
				return (0);
			if (c == '\n') {
				file->lineno++;
				continue;
			} else if (c == '\\') {
				if ((next = lgetc(quotec)) == EOF)
					return (0);
				if (next == quotec || c == ' ' || c == '\t')
					c = next;
				else if (next == '\n') {
					file->lineno++;
					continue;
				} else
					lungetc(next);
			} else if (c == quotec) {
				*p = '\0';
				break;
			} else if (c == '\0') {
				yyerror("syntax error");
				return (findeol());
			}
			if (p + 1 >= buf + sizeof(buf) - 1) {
				yyerror("string too long");
				return (findeol());
			}
			*p++ = c;
		}
		yylval.v.string = strdup(buf);
		if (yylval.v.string == NULL)
			fatal("yylex: strdup");
		return (STRING);
	}

#define allowed_to_end_number(x) \
	(isspace(x) || x == ')' || x ==',' || x == '/' || x == '}' || x == '=')

	if (c == '-' || isdigit(c)) {
		do {
			*p++ = c;
			if ((unsigned)(p-buf) >= sizeof(buf)) {
				yyerror("string too long");
				return (findeol());
			}
		} while ((c = lgetc(0)) != EOF && isdigit(c));
		lungetc(c);
		if (p == buf + 1 && buf[0] == '-')
			goto nodigits;
		if (c == EOF || allowed_to_end_number(c)) {
			const char *errstr = NULL;

			*p = '\0';
			yylval.v.number = strtonum(buf, LLONG_MIN,
			    LLONG_MAX, &errstr);
			if (errstr) {
				yyerror("\"%s\" invalid number: %s",
				    buf, errstr);
				return (findeol());
			}
			return (NUMBER);
		} else {
nodigits:
			while (p > buf + 1)
				lungetc(*--p);
			c = *--p;
			if (c == '-')
				return (c);
		}
	}

#define allowed_in_string(x) \
	(isalnum(x) || (ispunct(x) && x != '(' && x != ')' && \
	x != '{' && x != '}' && \
	x != '!' && x != '=' && x != '#' && \
	x != ','))

	if (isalnum(c) || c == ':' || c == '_' || c == '/') {
		do {
			*p++ = c;
			if ((unsigned)(p-buf) >= sizeof(buf)) {
				yyerror("string too long");
				return (findeol());
			}
		} while ((c = lgetc(0)) != EOF && (allowed_in_string(c)));
		lungetc(c);
		*p = '\0';
		if ((token = lookup(buf)) == STRING)
			if ((yylval.v.string = strdup(buf)) == NULL)
				fatal("yylex: strdup");
		return (token);
	}
	if (c == '\n') {
		yylval.lineno = file->lineno;
		file->lineno++;
	}
	if (c == EOF)
		return (0);
	return (c);
}

struct file *
pushfile(const char *name, int secret)
{
	struct file	*nfile;

	if ((nfile = calloc(1, sizeof(struct file))) == NULL) {
		log_warn("malloc");
		return (NULL);
	}
	if ((nfile->name = strdup(name)) == NULL) {
		log_warn("malloc");
		free(nfile);
		return (NULL);
	}
	if ((nfile->stream = fopen(nfile->name, "r")) == NULL) {
		free(nfile->name);
		free(nfile);
		return (NULL);
	}
	nfile->lineno = 1;
	TAILQ_INSERT_TAIL(&files, nfile, entry);
	return (nfile);
}

int
popfile(void)
{
	struct file	*prev;

	if ((prev = TAILQ_PREV(file, files, entry)) != NULL)
		prev->errors += file->errors;

	TAILQ_REMOVE(&files, file, entry);
	fclose(file->stream);
	free(file->name);
	free(file);
	file = prev;
	return (file ? 0 : EOF);
}

int
parse_config(const char *filename)
{
	struct sym	*sym, *next;

	if ((file = pushfile(filename, 0)) == NULL) {
		log_warn("failed to open %s", filename);
		if (errno == ENOENT)
			return (0);
		return (-1);
	}
	topfile = file;
	setservent(1);

	/* Set the default switch type */
	(void)strlcpy(vsw_type, VMD_SWITCH_TYPE, sizeof(vsw_type));

	yyparse();
	errors = file->errors;
	popfile();

	endservent();

	/* Free macros and check which have not been used. */
	TAILQ_FOREACH_SAFE(sym, &symhead, entry, next) {
		if (!sym->used)
			fprintf(stderr, "warning: macro '%s' not "
			    "used\n", sym->nam);
		if (!sym->persist) {
			free(sym->nam);
			free(sym->val);
			TAILQ_REMOVE(&symhead, sym, entry);
			free(sym);
		}
	}

	if (errors)
		return (-1);

	return (0);
}

int
symset(const char *nam, const char *val, int persist)
{
	struct sym	*sym;

	TAILQ_FOREACH(sym, &symhead, entry) {
		if (strcmp(nam, sym->nam) == 0)
			break;
	}

	if (sym != NULL) {
		if (sym->persist == 1)
			return (0);
		else {
			free(sym->nam);
			free(sym->val);
			TAILQ_REMOVE(&symhead, sym, entry);
			free(sym);
		}
	}
	if ((sym = calloc(1, sizeof(*sym))) == NULL)
		return (-1);

	sym->nam = strdup(nam);
	if (sym->nam == NULL) {
		free(sym);
		return (-1);
	}
	sym->val = strdup(val);
	if (sym->val == NULL) {
		free(sym->nam);
		free(sym);
		return (-1);
	}
	sym->used = 0;
	sym->persist = persist;
	TAILQ_INSERT_TAIL(&symhead, sym, entry);
	return (0);
}

int
cmdline_symset(char *s)
{
	char	*sym, *val;
	int	ret;
	size_t	len;

	if ((val = strrchr(s, '=')) == NULL)
		return (-1);

	len = (val - s) + 1;
	if ((sym = malloc(len)) == NULL)
		fatal("cmdline_symset: malloc");

	(void)strlcpy(sym, s, len);

	ret = symset(sym, val + 1, 1);
	free(sym);

	return (ret);
}

char *
symget(const char *nam)
{
	struct sym	*sym;

	TAILQ_FOREACH(sym, &symhead, entry) {
		if (strcmp(nam, sym->nam) == 0) {
			sym->used = 1;
			return (sym->val);
		}
	}
	return (NULL);
}

ssize_t
parse_size(char *word, int64_t val)
{
	ssize_t		 size;
	long long	 res;

	if (word != NULL) {
		if (scan_scaled(word, &res) != 0) {
			log_warn("invalid size: %s", word);
			return (-1);
		}
		val = (int64_t)res;
	}

	if (val < (1024 * 1024)) {
		log_warnx("size must be at least one megabyte");
		return (-1);
	} else
		size = val / 1024 / 1024;

	if ((size * 1024 * 1024) != val)
		log_warnx("size rounded to %zd megabytes", size);

	return ((ssize_t)size);
}

int
parse_disk(char *word)
{
	if (vcp->vcp_ndisks >= VMM_MAX_DISKS_PER_VM) {
		log_warnx("too many disks");
		return (-1);
	}

	if (strlcpy(vcp->vcp_disks[vcp->vcp_ndisks], word,
	    VMM_MAX_PATH_DISK) >= VMM_MAX_PATH_DISK) {
		log_warnx("disk path too long");
		return (-1);
	}

	vcp->vcp_ndisks++;

	return (0);
}

int
host(const char *str, struct address *h)
{
	struct addrinfo		 hints, *res;
	int			 prefixlen;
	char			*s, *p;
	const char		*errstr;

	if ((s = strdup(str)) == NULL) {
		log_warn("strdup");
		goto fail;
	}

	if ((p = strrchr(s, '/')) != NULL) {
		*p++ = '\0';
		prefixlen = strtonum(p, 0, 128, &errstr);
		if (errstr) {
			log_warnx("prefixlen is %s: %s", errstr, p);
			goto fail;
		}
	} else
		prefixlen = 128;

	memset(&hints, 0, sizeof(hints));
	hints.ai_family = AF_UNSPEC;
	hints.ai_flags = AI_NUMERICHOST;
	if (getaddrinfo(s, NULL, &hints, &res) == 0) {
		memset(h, 0, sizeof(*h));
		memcpy(&h->ss, res->ai_addr, res->ai_addrlen);
		h->prefixlen = prefixlen;
		freeaddrinfo(res);
		free(s);
		return (0);
	}

 fail:
	free(s);
	return (-1);
}
@


1.26
log
@Add global configuration option "local prefix" to change prefix for -L.

The default prefix is 100.64.0.0/10 from RFC6598.

Requested by sthen@@ chris@@
OK mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.25 2017/04/19 15:38:32 reyk Exp $	*/
d962 3
a964 1
		return (0);
@


1.25
log
@Add support for dynamic "NAT" interfaces (-L/local interface).

When a local interface is configured, vmd configures a /31 address on
the tap(4) interface of the host and provides another IP in the same
subnet via DHCP (BOOTP) to the VM.  vmd runs an internal BOOTP server
that replies with IP, gateway, and DNS addresses to the VM.  The
built-in server only ever responds to the VM on the inside and cannot
leak its DHCP responses to the outside.

Thanks to Uwe Werler, Josh Grosse, and some others for testing!

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.24 2017/04/06 21:35:22 reyk Exp $	*/
d119 1
a119 1
%token	ENABLE DISABLE VM BOOT LLADDR MEMORY OWNER LOCKED LOCAL
d137 1
d174 16
d647 1
d1114 40
@


1.24
log
@"kernel" got renamed to "boot" in vm.conf but I didn't commit the parse.y bits.

Found by Pontus Lundkvist

OK deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.23 2017/03/27 00:28:04 deraadt Exp $	*/
d119 1
a119 1
%token	ENABLE DISABLE VM BOOT LLADDR MEMORY OWNER LOCKED
d123 1
d329 1
a329 1
		| INTERFACE optstring iface_opts_o {
d336 1
a336 1
				free($2);
d340 5
a344 3
			if ($2 != NULL) {
				if (strcmp($2, "tap") != 0 &&
				    (priv_getiftype($2, type, NULL) == -1 ||
d346 2
a347 2
					yyerror("invalid interface: %s", $2);
					free($2);
d351 1
a351 1
				if (strlcpy(vmc.vmc_ifnames[i], $2,
d355 2
a356 2
					    $2);
					free($2);
d360 1
a360 1
			free($2);
d553 4
d626 1
@


1.23
log
@die whitespace die die die
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.22 2017/03/02 07:33:37 reyk Exp $	*/
d119 1
a119 1
%token	ENABLE DISABLE VM KERNEL LLADDR MEMORY OWNER LOCKED
d360 1
a360 1
		| KERNEL string			{
d608 1
a617 1
		{ "kernel",		KERNEL },
@


1.22
log
@Add "locked lladdr" option to prevent VMs from spoofing MAC addresses.

This is especially useful when multiple VMs share a switch, the
implementation is independent from the underlying switch or bridge.

no objections mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.21 2017/03/01 07:43:33 reyk Exp $	*/
d92 1
a92 1
static struct vmd_vm        *vm;
d427 1
a427 1
		| NUMBER 		{
@


1.21
log
@Add "owner" option to set a user/group ownership for pre-configured VMs

This allows matching users to start or stop VMs that they "own" and to
access the console accordingly.

OK mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.20 2017/01/13 19:21:16 edd Exp $	*/
d119 1
a119 1
%token	ENABLE DISABLE VM KERNEL LLADDR MEMORY OWNER
d123 1
d178 1
a178 1
			vsw->sw_flags = IFF_UP;
d245 3
d250 1
a250 1
				vsw->sw_flags |= IFF_UP;
d252 1
a252 1
				vsw->sw_flags &= ~IFF_UP;
d510 4
a513 2
		| LLADDR lladdr			{
			memcpy(vcp->vcp_macs[vcp_nnics], $2, ETHER_ADDR_LEN);
d517 1
a517 1
				vmc.vmc_ifflags[vcp_nnics] |= IFF_UP;
d519 1
a519 1
				vmc.vmc_ifflags[vcp_nnics] &= ~IFF_UP;
d550 4
d619 1
@


1.20
log
@Make it possible to remove VMs from vmd(8)'s internal queue.

The semantics agreed with reyk@@ are:

 * ad-hoc created vms, created  with `vmctl start`, are removed once stopped.
 * Stopped VMs defined in a config file are flushed before a `vmctl reload`.

OK reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.19 2017/01/05 13:53:10 krw Exp $	*/
d47 2
d106 4
d119 1
a119 1
%token	ENABLE DISABLE VM KERNEL LLADDR MEMORY
d127 1
d270 4
d282 2
a283 1
				ret = vm_register(&env->vmd_ps, &vmc, &vm, 0);
d413 51
d610 1
@


1.19
log
@Replace hand-rolled for(;;) emptying of 'symhead' TAILQ with more
modern TAILQ_FOREACH_SAFE().

No intentional functional change.

ok millert@@ bluhm@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.18 2017/01/05 12:42:19 krw Exp $	*/
d291 1
@


1.18
log
@Replace symset()'s hand-rolled for(;;) traversal of 'symhead' TAILQ
with more modern TAILQ_FOREACH(). This what symget() was already
doing.

Add paranoia '{}' around body of symget()'s TAILQ_FOREACH().

No intentional functional change.

ok bluhm@@ otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.17 2016/12/14 21:17:25 reyk Exp $	*/
d875 1
a875 2
	for (sym = TAILQ_FIRST(&symhead); sym != NULL; sym = next) {
		next = TAILQ_NEXT(sym, entry);
@


1.17
log
@Allow to start disabled and pre-configured VMs by name, "vmctl start foo".

With testing from Jon Bernard

OK mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.16 2016/11/22 11:31:38 edd Exp $	*/
d899 4
a902 3
	for (sym = TAILQ_FIRST(&symhead); sym && strcmp(nam, sym->nam);
	    sym = TAILQ_NEXT(sym, entry))
		;	/* nothing */
d961 1
a961 1
	TAILQ_FOREACH(sym, &symhead, entry)
d966 1
@


1.16
log
@Insert disabled VMs into vmd(8)'s queues and allow vmctl(8) to display them.

Tested by Jon Bernard and reyk@@.

OK reyk@@, no objections mlarkin@@.

Thanks
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.15 2016/11/04 15:16:44 reyk Exp $	*/
d309 1
d341 1
d358 1
d370 1
d383 1
d398 1
@


1.15
log
@Pass the internal vmid or 0 to vm_register() instead of changing it
once again after setting the next available id.

Suggested by edd@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.14 2016/11/04 15:07:26 reyk Exp $	*/
d270 1
a270 4
			if (vcp_disable) {
				log_debug("%s:%d: vm \"%s\" skipped (disabled)",
				    file->name, yylval.lineno, vcp->vcp_name);
			} else if (!env->vmd_noaction) {
d284 3
a286 1
					log_debug("%s:%d: vm \"%s\" registered",
d288 2
a289 1
					    vcp->vcp_name);
@


1.14
log
@Update the config/register/get VM methods to match the config_set/get
style that is used in other places.  Also keep the vmid from the parent.

OK edd@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.13 2016/10/29 14:58:54 reyk Exp $	*/
d274 1
a274 1
				ret = vm_register(&env->vmd_ps, &vmc, &vm);
@


1.13
log
@Simple grammar tweak: allow to specify interface options in a single line.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.12 2016/10/29 14:56:05 edd Exp $	*/
d274 1
a274 1
				ret = config_registervm(&env->vmd_ps, &vmc, &vm);
@


1.12
log
@Separate parsing vms and switches from starting them in vmd(8).

Brings us one step closer to having disabled by default vms is vm.conf(5),
which can be started with vmctl(8).

Input, testing and OK reyk@@. Thanks.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.11 2016/10/17 16:26:20 reyk Exp $	*/
d397 1
d405 4
d480 4
@


1.11
log
@Add the option to specify an interface group per virtual switch as well;
this group will be added to all VM tap(4) interfaces in the switch.

Tested by martijn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.10 2016/10/15 14:02:11 reyk Exp $	*/
d90 1
a176 3
			TAILQ_INSERT_TAIL(env->vmd_switches, vsw, sw_entry);
			env->vmd_nswitches++;

d182 4
a185 16
				/*
				 * XXX Configure the switch right away -
				 * XXX this should be done after parsing
				 * XXX the configuration.
				 */
				if (vm_priv_brconfig(&env->vmd_ps, vsw) == -1) {
					log_warn("%s:%d: switch \"%s\" failed",
					    file->name, yylval.lineno,
					    vsw->sw_name);
					YYERROR;
				} else {
					log_debug("%s:%d: switch \"%s\""
					    " configured",
					    file->name, yylval.lineno,
					    vsw->sw_name);
				}
d274 1
a274 6
				/*
				 * XXX Start the vm right away -
				 * XXX this should be done after parsing
				 * XXX the configuration.
				 */
				ret = config_getvm(&env->vmd_ps, &vmc, -1, -1);
d277 1
a277 1
					    " skipped (running)",
d279 2
a280 1
					    vcp->vcp_name);
d287 1
a287 1
					log_debug("%s:%d: vm \"%s\" enabled",
@


1.10
log
@Allow to add an interface to an interface group; with the group keyword.

Requested and tested by martijn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.9 2016/10/05 17:31:22 reyk Exp $	*/
d225 8
@


1.9
log
@Replace one u_int8_t with uint8_t (finger memory)
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.8 2016/10/05 17:30:13 reyk Exp $	*/
d111 1
a111 1
%token	ADD DISK DOWN INTERFACE NIFS PATH SIZE SWITCH UP VMID
d427 14
d533 1
@


1.8
log
@Add support for enhanced networking configuration and virtual switches.
See vm.conf(5) for more details.

OK mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.7 2016/06/21 21:35:25 benno Exp $	*/
d100 1
a100 1
		u_int8_t	 lladdr[ETHER_ADDR_LEN];
@


1.7
log
@do not allow whitespace in macro names, i.e. "this is" = "a variable".
change this in all config parsers in our tree that support macros.
problem reported by sven falempin.

feedback from henning@@, stsp@@, deraadt@@
ok florian@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.6 2016/03/13 13:11:47 stefan Exp $	*/
d4 1
a4 1
 * Copyright (c) 2007-2015 Reyk Floeter <reyk@@openbsd.org>
d28 1
d33 4
d86 9
a94 4
static struct vm_create_params	 vcp;
static int			 vcp_disable = 0;
static int			 errors = 0;

d96 1
d100 1
d111 2
a112 2
%token	DISK NIFS PATH SIZE VMID
%token	ENABLE DISABLE VM KERNEL MEMORY
d116 2
d119 1
d127 2
a128 1
		| grammar main '\n'
d163 93
a255 2
main		: VM string			{
			memset(&vcp, 0, sizeof(vcp));
d257 9
a265 2
			if (strlcpy(vcp.vcp_name, $2, sizeof(vcp.vcp_name)) >=
			    sizeof(vcp.vcp_name)) {
d272 4
d278 1
a278 1
				    file->name, yylval.lineno, vcp.vcp_name);
d285 1
a285 1
				ret = config_getvm(&env->vmd_ps, &vcp, -1, -1);
d290 1
a290 1
					    vcp.vcp_name);
d294 1
a294 1
					    vcp.vcp_name);
d299 1
a299 1
					    vcp.vcp_name);
d320 31
d352 1
a352 1
			if (vcp.vcp_kernel[0] != '\0') {
d356 1
d358 3
a360 2
			if (strlcpy(vcp.vcp_kernel, $2,
			    sizeof(vcp.vcp_kernel)) >= sizeof(vcp.vcp_kernel)) {
d368 1
a368 1
			if (vcp.vcp_nnics != 0) {
d376 1
a376 1
			vcp.vcp_nnics = (size_t)$2;
d380 1
a380 1
			if (vcp.vcp_memranges[0].vmr_size != 0) {
d388 1
a388 1
			vcp.vcp_memranges[0].vmr_size = (size_t)res;
d392 1
a392 1
			if (vcp.vcp_memranges[0].vmr_size != 0) {
d402 33
a434 1
			vcp.vcp_memranges[0].vmr_size = (size_t)res;
d438 5
a442 1
string		: STRING string				{
d451 18
d514 1
d517 1
d521 1
d524 1
d527 2
d845 3
d977 1
a977 1
	if (vcp.vcp_ndisks >= VMM_MAX_DISKS_PER_VM) {
d982 1
a982 1
	if (strlcpy(vcp.vcp_disks[vcp.vcp_ndisks], word,
d988 1
a988 1
	vcp.vcp_ndisks++;
@


1.6
log
@Introduce memory ranges to support VMs with >= 4G RAM

Kernel bits:
- When creating a VM, a list of memory ranges has to be specified,
  similar to the BIOS memory map. This is necessary for VMs with
  RAM sizes approaching 4G because we'll need PCI MMIO space in
  the higher parts of the 32 bit address space.

vmctl and vmd bits:
- Construct appropriate memory ranges to create a VM with a given
  RAM size
- Construct a corresponding BIOS memory map from the memory ranges
  and update the boot params page accordingly.
- Make sure that all variables that represent guest physical addresses
  match the address width of the target CPU instead of using uint32_t.
- Fix some integer promotion glitches that actually restricted VM
  RAM size to 2G.

This changes the VM create ioctl interface, so update your kernel,
vmd, and vmctl.

ok mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.5 2015/12/07 13:30:06 reyk Exp $	*/
d132 8
@


1.5
log
@Most common strings in vm.conf are pathnames, so allow unquoted
slashes in strings.  Slashes were excluded because the parser came
from pfctl and bgpd were IP prefixes are parsed this way but we can
handle such cases differently if vmd ever has to parse IPs with prefix
length.  This change also allows to concatenate pathnames with macros.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.4 2015/12/07 12:52:00 reyk Exp $	*/
d221 1
a221 1
			if (vcp.vcp_memory_size != 0) {
d229 1
a229 1
			vcp.vcp_memory_size = (size_t)res;
d233 1
a233 1
			if (vcp.vcp_memory_size != 0) {
d243 1
a243 1
			vcp.vcp_memory_size = (size_t)res;
@


1.4
log
@tweak initial error logging
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.3 2015/12/06 21:02:51 reyk Exp $	*/
d104 1
d116 1
a116 1
include		: INCLUDE STRING		{
d139 1
a139 1
main		: VM STRING			{
d186 1
a186 1
		| DISK STRING			{
d194 1
a194 1
		| KERNEL STRING			{
d247 9
d550 1
a550 1
	if (isalnum(c) || c == ':' || c == '_') {
@


1.3
log
@Prevent running a VM with the same name multiple times - multiple
instances of the same configuration will be handled in a different way
later.  It is also not a good idea to use the same writeable disk
with multiple VMs at the same time.

As discussed with mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.2 2015/12/06 01:16:22 reyk Exp $	*/
d275 1
a275 1
	warnx("%s:%d: %s", file->name, yylval.lineno, msg);
@


1.2
log
@Check errno from config_getvm() correctly
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.1 2015/12/03 16:11:32 reyk Exp $	*/
d40 1
d150 1
a150 1
				log_debug("%s:%d: vm \"%s\" disabled (skipped)",
d159 6
a164 1
				if (ret == -1) {
@


1.1
log
@Add support for an optional vm.conf(5) file in vmd.  This will replace
vmm.conf(5) in vmmctl.  For a short time, both vmd and vmmctl will
support a configuration file, but vmmctl will be changed to send
"load" requests to vmd instead of loading and parsing the file
directly.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.7 2015/12/03 08:52:29 reyk Exp $	*/
d146 2
d157 3
a159 3
				if (config_getvm(&env->vmd_ps, &vcp,
				    -1, -1) == -1) {
					log_warnx("%s:%d: vm \"%s\" failed",
d163 4
a167 2
				log_debug("%s:%d: vm \"%s\" enabled",
				    file->name, yylval.lineno, vcp.vcp_name);
@

