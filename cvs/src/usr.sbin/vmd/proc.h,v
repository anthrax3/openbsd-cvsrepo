head	1.12;
access;
symbols
	OPENBSD_6_0:1.6.0.4
	OPENBSD_6_0_BASE:1.6
	OPENBSD_5_9:1.6.0.2
	OPENBSD_5_9_BASE:1.6;
locks; strict;
comment	@ * @;


1.12
date	2017.03.27.00.28.04;	author deraadt;	state Exp;
branches;
next	1.11;
commitid	cbObO83mNT8jlhy1;

1.11
date	2017.01.09.14.49.22;	author reyk;	state Exp;
branches;
next	1.10;
commitid	eA8b246voAapPTkX;

1.10
date	2016.11.16.15.32.42;	author rzalamena;	state Exp;
branches;
next	1.9;
commitid	v9MsNGEdZm5uTnia;

1.9
date	2016.10.05.17.30.13;	author reyk;	state Exp;
branches;
next	1.8;
commitid	c3mC9fNmRbfUPluH;

1.8
date	2016.10.04.17.17.30;	author reyk;	state Exp;
branches;
next	1.7;
commitid	yb7Y2lNmLG5i2hzO;

1.7
date	2016.09.29.22.42.04;	author reyk;	state Exp;
branches;
next	1.6;
commitid	OrqC5N55KjzTfX1Z;

1.6
date	2015.12.03.13.08.44;	author reyk;	state Exp;
branches;
next	1.5;
commitid	x0i6sqLF0crQTgU8;

1.5
date	2015.12.03.08.42.11;	author reyk;	state Exp;
branches;
next	1.4;
commitid	deOxsg54am7A6Za6;

1.4
date	2015.12.02.22.19.11;	author reyk;	state Exp;
branches;
next	1.3;
commitid	7ra6VeOJoUb1NQ70;

1.3
date	2015.12.02.13.43.36;	author reyk;	state Exp;
branches;
next	1.2;
commitid	qcJMjGAHILmCub0o;

1.2
date	2015.12.02.09.39.41;	author reyk;	state Exp;
branches;
next	1.1;
commitid	rhcKtIJ7zvu5z3CH;

1.1
date	2015.12.02.09.14.25;	author reyk;	state Exp;
branches;
next	;
commitid	vOctzllSJTLtnazM;


desc
@@


1.12
log
@die whitespace die die die
@
text
@/*	$OpenBSD: proc.h,v 1.11 2017/01/09 14:49:22 reyk Exp $	*/

/*
 * Copyright (c) 2010-2015 Reyk Floeter <reyk@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/socket.h>
#include <sys/queue.h>
#include <sys/uio.h>

#include <imsg.h>
#include <event.h>

#ifndef _PROC_H
#define _PROC_H

enum {
	IMSG_NONE,
	IMSG_CTL_OK,
	IMSG_CTL_FAIL,
	IMSG_CTL_VERBOSE,
	IMSG_CTL_END,
	IMSG_CTL_NOTIFY,
	IMSG_CTL_RESET,
	IMSG_CTL_PROCFD,
	IMSG_PROC_MAX
};

/* imsg */
struct imsgev {
	struct imsgbuf		 ibuf;
	void			(*handler)(int, short, void *);
	struct event		 ev;
	struct privsep_proc	*proc;
	void			*data;
	short			 events;
};

#define IMSG_SIZE_CHECK(imsg, p) do {					\
	if (IMSG_DATA_SIZE(imsg) < sizeof(*p))				\
		fatalx("bad length imsg received (%s)",	#p);		\
} while (0)
#define IMSG_DATA_SIZE(imsg)	((imsg)->hdr.len - IMSG_HEADER_SIZE)

/* control socket */
struct control_sock {
	const char	*cs_name;
	struct event	 cs_ev;
	struct event	 cs_evt;
	int		 cs_fd;
	int		 cs_restricted;
	void		*cs_env;

	TAILQ_ENTRY(control_sock) cs_entry;
};
TAILQ_HEAD(control_socks, control_sock);

struct {
	struct event	 ev;
	int		 fd;
} control_state;

struct ctl_conn {
	TAILQ_ENTRY(ctl_conn)	 entry;
	uint8_t			 flags;
	unsigned int		 waiting;
#define CTL_CONN_NOTIFY		 0x01
	struct imsgev		 iev;
	struct sockpeercred	 peercred;

};
TAILQ_HEAD(ctl_connlist, ctl_conn);
extern  struct ctl_connlist ctl_conns;

/* privsep */
enum privsep_procid {
	PROC_PARENT	= 0,
	PROC_CONTROL,
	PROC_VMM,
	PROC_PRIV,
	PROC_MAX,
} privsep_process;

#define CONFIG_RELOAD		0x00
#define CONFIG_VMS		0x01
#define CONFIG_SWITCHES		0x02
#define CONFIG_ALL		0xff

struct privsep_pipes {
	int				*pp_pipes[PROC_MAX];
};

struct privsep {
	struct privsep_pipes		*ps_pipes[PROC_MAX];
	struct privsep_pipes		*ps_pp;

	struct imsgev			*ps_ievs[PROC_MAX];
	const char			*ps_title[PROC_MAX];
	uint8_t				 ps_what[PROC_MAX];

	struct passwd			*ps_pw;
	int				 ps_noaction;

	struct control_sock		 ps_csock;
	struct control_socks		 ps_rcsocks;

	unsigned int			 ps_instances[PROC_MAX];
	unsigned int			 ps_instance;

	/* Event and signal handlers */
	struct event			 ps_evsigint;
	struct event			 ps_evsigterm;
	struct event			 ps_evsigchld;
	struct event			 ps_evsighup;
	struct event			 ps_evsigpipe;
	struct event			 ps_evsigusr1;

	void				*ps_env;
};

struct privsep_proc {
	const char		*p_title;
	enum privsep_procid	 p_id;
	int			(*p_cb)(int, struct privsep_proc *,
				    struct imsg *);
	void			(*p_init)(struct privsep *,
				    struct privsep_proc *);
	void			(*p_shutdown)(void);
	const char		*p_chroot;
	struct passwd		*p_pw;
	struct privsep		*p_ps;
};

struct privsep_fd {
	enum privsep_procid		 pf_procid;
	unsigned int			 pf_instance;
};

#if DEBUG
#define DPRINTF		log_debug
#else
#define DPRINTF(x...)	do {} while(0)
#endif

#define PROC_PARENT_SOCK_FILENO	3
#define PROC_MAX_INSTANCES	32

/* proc.c */
void	 proc_init(struct privsep *, struct privsep_proc *, unsigned int,
	    int, char **, enum privsep_procid);
void	 proc_kill(struct privsep *);
void	 proc_connect(struct privsep *ps);
void	 proc_dispatch(int, short event, void *);
void	 proc_run(struct privsep *, struct privsep_proc *,
	    struct privsep_proc *, unsigned int,
	    void (*)(struct privsep *, struct privsep_proc *, void *), void *);
void	 imsg_event_add(struct imsgev *);
int	 imsg_compose_event(struct imsgev *, uint16_t, uint32_t,
	    pid_t, int, void *, uint16_t);
int	 imsg_composev_event(struct imsgev *, uint16_t, uint32_t,
	    pid_t, int, const struct iovec *, int);
int	 proc_compose_imsg(struct privsep *, enum privsep_procid, int,
	    uint16_t, uint32_t, int, void *, uint16_t);
int	 proc_compose(struct privsep *, enum privsep_procid,
	    uint16_t, void *data, uint16_t);
int	 proc_composev_imsg(struct privsep *, enum privsep_procid, int,
	    uint16_t, uint32_t, int, const struct iovec *, int);
int	 proc_composev(struct privsep *, enum privsep_procid,
	    uint16_t, const struct iovec *, int);
int	 proc_forward_imsg(struct privsep *, struct imsg *,
	    enum privsep_procid, int);
struct imsgbuf *
	 proc_ibuf(struct privsep *, enum privsep_procid, int);
struct imsgev *
	 proc_iev(struct privsep *, enum privsep_procid, int);
enum privsep_procid
	 proc_getid(struct privsep_proc *, unsigned int, const char *);
int	 proc_flush_imsg(struct privsep *, enum privsep_procid, int);

/* control.c */
void	 control(struct privsep *, struct privsep_proc *);
int	 control_init(struct privsep *, struct control_sock *);
int	 control_listen(struct control_sock *);
void	 control_cleanup(struct control_sock *);

/* log.c */
void	log_init(int, int);
void	log_procinit(const char *);
void	log_setverbose(int);
int	log_getverbose(void);
void	log_warn(const char *, ...)
	    __attribute__((__format__ (printf, 1, 2)));
void	log_warnx(const char *, ...)
	    __attribute__((__format__ (printf, 1, 2)));
void	log_info(const char *, ...)
	    __attribute__((__format__ (printf, 1, 2)));
void	log_debug(const char *, ...)
	    __attribute__((__format__ (printf, 1, 2)));
void	logit(int, const char *, ...)
	    __attribute__((__format__ (printf, 2, 3)));
void	vlog(int, const char *, va_list)
	    __attribute__((__format__ (printf, 2, 0)));
__dead void fatal(const char *, ...)
	    __attribute__((__format__ (printf, 1, 2)));
__dead void fatalx(const char *, ...)
	    __attribute__((__format__ (printf, 1, 2)));

#endif /* _PROC_H */
@


1.11
log
@Stop accessing verbose and debug variables from log.c directly.

This replaces log_verbose() and "extern int verbose" with the two functions
log_setverbose() and log_getverbose().

Pointed out by benno@@
OK krw@@ eric@@ gilles@@ (OK gilles@@ for the snmpd bits as well)
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.10 2016/11/16 15:32:42 rzalamena Exp $	*/
d157 2
a158 2
#define PROC_PARENT_SOCK_FILENO 3
#define PROC_MAX_INSTANCES      32
@


1.10
log
@Sync switchd(8) and vmd(8) with the latest proc.c changes. This sync
basically imports the imsg_flush() fix from reyk@@ in httpd(8).

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.9 2016/10/05 17:30:13 reyk Exp $	*/
d201 2
a202 1
void	log_verbose(int);
@


1.9
log
@Add support for enhanced networking configuration and virtual switches.
See vm.conf(5) for more details.

OK mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.8 2016/10/04 17:17:30 reyk Exp $	*/
d190 1
@


1.8
log
@Add a new "priv" process that is responsible for ioctls and restricted
operations that aren't allowed under pledge.  This is a companion to
the "vmd" process that runs as root but with pledge.

With the "priv" process, each new tap(4) interface now gets a
description to indicate the vm, eg. "vm1-if0-myvm".  For network
configuration will be done by vmd/priv later.

OK mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.7 2016/09/29 22:42:04 reyk Exp $	*/
d51 3
a53 3
#define IMSG_SIZE_CHECK(imsg, p) do {				\
	if (IMSG_DATA_SIZE(imsg) < sizeof(*p))			\
		fatalx("bad length imsg received");		\
d98 1
@


1.7
log
@Implement fork+exec for vmd, using the same framework from httpd etc.

No objections from mlarkin@@ sunil@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.6 2015/12/03 13:08:44 reyk Exp $	*/
d92 1
d139 1
d141 1
a142 1
	void			(*p_shutdown)(void);
@


1.6
log
@Use PEERCRED to obtain the user id of the vmmctl user.  This is used to
restrict write operations (start/stop/terminate/load) to root for now,
but allow others to obtain the status.  A more sophisticated model will
follow later, but this change prevents non-root users, even if in the wheel
group, to start vms and thus to open any files read-writable as disks.
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.5 2015/12/03 08:42:11 reyk Exp $	*/
d37 1
a108 1
	pid_t				 ps_pid[PROC_MAX];
a117 1
	unsigned int			 ps_ninstances;
d136 1
a136 1
	pid_t			(*p_init)(struct privsep *,
a139 1
	void			*p_env;
a140 1
	unsigned int		 p_instance;
d143 14
d158 2
a159 1
void	 proc_init(struct privsep *, struct privsep_proc *, unsigned int);
d161 1
a161 1
void	 proc_listen(struct privsep *, struct privsep_proc *, size_t);
d163 1
a163 1
pid_t	 proc_run(struct privsep *, struct privsep_proc *,
d185 2
d189 1
a189 1
pid_t	 control(struct privsep *, struct privsep_proc *);
@


1.5
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.4 2015/12/02 22:19:11 reyk Exp $	*/
d19 1
d80 1
@


1.4
log
@Split the fully privileged parent into two processes "parent" and
"vmm" with reduced privileges:
- the "parent" opens fds (disks, ifs, etc.) but runs as root but pledged as
  "stdio rpath wpath proc tty sendfd".
- the "vmm" process handles the creation and supervision of vm processes,
  and the primary communication with the vmm(4) subsystem.  It runs as _vmd
  in the chroot but does not use pledge, as the vmm ioctls are not allowed
  by any pledge model yet.
With this change, vmd starts to track the configuration state of VMs
in vmd and will allow other things later (like terminating a vm by
name, moving the configuration parser to vmd, ...).  More incremental
changes will follow.
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.3 2015/12/02 13:43:36 reyk Exp $	*/
d29 1
a29 1
        IMSG_NONE,
d75 2
a76 2
	u_int8_t		 flags;
	u_int			 waiting;
d107 1
a107 1
	u_int8_t			 ps_what[PROC_MAX];
d115 3
a117 3
	u_int				 ps_instances[PROC_MAX];
	u_int				 ps_ninstances;
	u_int				 ps_instance;
d141 1
a141 1
	u_int			 p_instance;
@


1.3
log
@Sync with relayd, fix previous use of proc_compose*_imsg()
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.2 2015/12/02 09:39:41 reyk Exp $	*/
d35 1
d88 1
d92 4
d107 2
@


1.2
log
@Add back the "peerid" to the proc_compose*() functions: in relayd, I
initially left it out because I didn't have a need for it.  But it is
actually quite useful to carry a reference to the imsg data context
across processes.
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.1 2015/12/02 09:14:25 reyk Exp $	*/
d151 2
d155 2
@


1.1
log
@Start tweaking vmd's privsep and daemon model by splitting the main
process into multiple parts and adopting the "proc.c"-style from other
daemons.  This allows to further reduce the privileges, to give better
pledge(2), and to add some upcoming changes.

"please do" mlarkin@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d150 1
a150 1
	    uint16_t, int, void *, uint16_t);
d152 1
a152 1
	    uint16_t, int, const struct iovec *, int);
@

