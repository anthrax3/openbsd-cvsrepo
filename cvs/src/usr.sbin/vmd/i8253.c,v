head	1.17;
access;
symbols
	OPENBSD_6_1:1.12.0.4
	OPENBSD_6_1_BASE:1.12;
locks; strict;
comment	@ * @;


1.17
date	2017.08.14.19.46.44;	author jasper;	state Exp;
branches;
next	1.16;
commitid	sC2xvioGCHNA55Vu;

1.16
date	2017.07.09.00.51.40;	author pd;	state Exp;
branches;
next	1.15;
commitid	qGhsIrgsAzfqzJtv;

1.15
date	2017.05.08.09.08.40;	author reyk;	state Exp;
branches;
next	1.14;
commitid	oVx15xEUTrD3JWhh;

1.14
date	2017.04.28.08.14.48;	author mlarkin;	state Exp;
branches;
next	1.13;
commitid	HSum1ePZ294k4WiS;

1.13
date	2017.04.08.19.06.04;	author mlarkin;	state Exp;
branches;
next	1.12;
commitid	rvuDxfMtOnTwty3t;

1.12
date	2017.03.27.00.28.04;	author deraadt;	state Exp;
branches;
next	1.11;
commitid	cbObO83mNT8jlhy1;

1.11
date	2017.03.25.22.36.53;	author mlarkin;	state Exp;
branches;
next	1.10;
commitid	8Fl7pGk8QzRFB3im;

1.10
date	2017.03.25.07.46.24;	author mlarkin;	state Exp;
branches;
next	1.9;
commitid	fC8LAknsckToIgCj;

1.9
date	2017.03.24.11.08.43;	author reyk;	state Exp;
branches;
next	1.8;
commitid	W2oEl7DZuO2sbiO4;

1.8
date	2017.03.24.09.11.49;	author mlarkin;	state Exp;
branches;
next	1.7;
commitid	R3DEwCy00JAyOQ3X;

1.7
date	2017.03.23.07.02.47;	author mlarkin;	state Exp;
branches;
next	1.6;
commitid	Do5fwQxKpFGH5VFX;

1.6
date	2017.03.19.23.03.44;	author mlarkin;	state Exp;
branches;
next	1.5;
commitid	6D7AhX8yWVg2PAY4;

1.5
date	2017.01.17.21.51.01;	author krw;	state Exp;
branches;
next	1.4;
commitid	7aASaBYKS1WgBK9H;

1.4
date	2016.10.26.05.26.36;	author mlarkin;	state Exp;
branches;
next	1.3;
commitid	1sM4SQUlhgJwAn6Q;

1.3
date	2016.10.03.06.00.17;	author mlarkin;	state Exp;
branches;
next	1.2;
commitid	bs8XE32xihRjrrM4;

1.2
date	2016.09.01.16.40.06;	author mlarkin;	state Exp;
branches;
next	1.1;
commitid	7V0oCQPFjx6K1mXz;

1.1
date	2016.09.01.14.48.09;	author mlarkin;	state Exp;
branches;
next	;
commitid	FBqVpmx18MX292rY;


desc
@@


1.17
log
@whitespace and fix a comment typo
@
text
@/* $OpenBSD: i8253.c,v 1.16 2017/07/09 00:51:40 pd Exp $ */
/*
 * Copyright (c) 2016 Mike Larkin <mlarkin@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/time.h>
#include <sys/types.h>

#include <dev/ic/i8253reg.h>

#include <machine/vmmvar.h>

#include <event.h>
#include <string.h>
#include <stddef.h>
#include <unistd.h>

#include "i8253.h"
#include "proc.h"
#include "vmm.h"
#include "atomicio.h"

extern char *__progname;

/*
 * Channel 0 is used to generate the legacy hardclock interrupt (HZ).
 * Channels 1 and 2 are not connected to any output (although someone
 * could hook channel 2 up to an emulated pcppi(4) at some point).
 */
struct i8253_channel i8253_channel[3];

/*
 * i8253_init
 *
 * Initialize the emulated i8253 PIT.
 *
 * Parameters:
 *  vm_id: vmm(4)-assigned ID of the VM
 */
void
i8253_init(uint32_t vm_id)
{
	memset(&i8253_channel, 0, sizeof(struct i8253_channel));
	gettimeofday(&i8253_channel[0].tv, NULL);
	i8253_channel[0].start = 0xFFFF;
	i8253_channel[0].mode = TIMER_INTTC;
	i8253_channel[0].last_r = 1;
	i8253_channel[0].vm_id = vm_id;

	i8253_channel[1].start = 0xFFFF;
	i8253_channel[1].mode = TIMER_INTTC;
	i8253_channel[1].last_r = 1;
	i8253_channel[1].vm_id = vm_id;

	i8253_channel[2].start = 0xFFFF;
	i8253_channel[2].mode = TIMER_INTTC;
	i8253_channel[2].last_r = 1;
	i8253_channel[2].vm_id = vm_id;

	evtimer_set(&i8253_channel[0].timer, i8253_fire, &i8253_channel[0]);
	evtimer_set(&i8253_channel[1].timer, i8253_fire, &i8253_channel[1]);
	evtimer_set(&i8253_channel[2].timer, i8253_fire, &i8253_channel[2]);
}

/*
 * i8253_do_readback
 *
 * Handles the readback status command. The readback status command latches
 * the current counter value plus various status bits.
 *
 * Parameters:
 *  data: The command word written by the guest VM
 */
void
i8253_do_readback(uint32_t data)
{
	struct timeval now, delta;
	uint64_t ns, ticks;

	/* bits are inverted here - !TIMER_RB_STATUS == enable chan readback */
	if (data & ~TIMER_RB_STATUS) {
		i8253_channel[0].rbs = (data & TIMER_RB_C0) ? 1 : 0;
		i8253_channel[1].rbs = (data & TIMER_RB_C1) ? 1 : 0;
		i8253_channel[2].rbs = (data & TIMER_RB_C2) ? 1 : 0;
	}

	/* !TIMER_RB_COUNT == enable counter readback */
	if (data & ~TIMER_RB_COUNT) {
		if (data & TIMER_RB_C0) {
			gettimeofday(&now, NULL);
			delta.tv_sec = now.tv_sec - i8253_channel[0].tv.tv_sec;
			delta.tv_usec = now.tv_usec -
			    i8253_channel[0].tv.tv_usec;
			if (delta.tv_usec < 0) {
				delta.tv_sec--;
				delta.tv_usec += 1000000;
			}
			if (delta.tv_usec > 1000000) {
				delta.tv_sec++;
				delta.tv_usec -= 1000000;
			}
			ns = delta.tv_usec * 1000 + delta.tv_sec * 1000000000;
			ticks = ns / NS_PER_TICK;
			if (i8253_channel[0].start)
				i8253_channel[0].olatch =
				    i8253_channel[0].start -
				    ticks % i8253_channel[0].start;
			else
				i8253_channel[0].olatch = 0;
		}

		if (data & TIMER_RB_C1) {
			gettimeofday(&now, NULL);
			delta.tv_sec = now.tv_sec - i8253_channel[1].tv.tv_sec;
			delta.tv_usec = now.tv_usec -
			    i8253_channel[1].tv.tv_usec;
			if (delta.tv_usec < 0) {
				delta.tv_sec--;
				delta.tv_usec += 1000000;
			}
			if (delta.tv_usec > 1000000) {
				delta.tv_sec++;
				delta.tv_usec -= 1000000;
			}
			ns = delta.tv_usec * 1000 + delta.tv_sec * 1000000000;
			ticks = ns / NS_PER_TICK;
			if (i8253_channel[1].start)
				i8253_channel[1].olatch =
				    i8253_channel[1].start -
				    ticks % i8253_channel[1].start;
			else
				i8253_channel[1].olatch = 0;
		}

		if (data & TIMER_RB_C2) {
			gettimeofday(&now, NULL);
			delta.tv_sec = now.tv_sec - i8253_channel[2].tv.tv_sec;
			delta.tv_usec = now.tv_usec -
			    i8253_channel[2].tv.tv_usec;
			if (delta.tv_usec < 0) {
				delta.tv_sec--;
				delta.tv_usec += 1000000;
			}
			if (delta.tv_usec > 1000000) {
				delta.tv_sec++;
				delta.tv_usec -= 1000000;
			}
			ns = delta.tv_usec * 1000 + delta.tv_sec * 1000000000;
			ticks = ns / NS_PER_TICK;
			if (i8253_channel[2].start)
				i8253_channel[2].olatch =
				    i8253_channel[2].start -
				    ticks % i8253_channel[2].start;
			else
				i8253_channel[2].olatch = 0;
		}
	}
}

/*
 * vcpu_exit_i8253
 *
 * Handles emulated i8253 PIT access (in/out instruction to PIT ports).
 *
 * Parameters:
 *  vrp: vm run parameters containing exit information for the I/O
 *      instruction being performed
 *
 * Return value:
 *  Interrupt to inject to the guest VM, or 0xFF if no interrupt should
 *      be injected.
 */
uint8_t
vcpu_exit_i8253(struct vm_run_params *vrp)
{
	uint32_t out_data;
	uint8_t sel, rw, data, mode;
	uint64_t ns, ticks;
	struct timeval now, delta;
	union vm_exit *vei = vrp->vrp_exit;

	get_input_data(vei, &out_data);

	if (vei->vei.vei_port == TIMER_CTRL) {
		if (vei->vei.vei_dir == VEI_DIR_OUT) { /* OUT instruction */
			sel = out_data &
			    (TIMER_SEL0 | TIMER_SEL1 | TIMER_SEL2);
			sel = sel >> 6;

			if (sel == 3) {
				i8253_do_readback(out_data);
				return (0xFF);
			}

			rw = out_data & (TIMER_LATCH | TIMER_16BIT);

			/*
			 * Since we don't truly emulate each tick of the PIT
			 * counter, when the guest asks for the timer to be
			 * latched, simulate what the counter would have been
			 * had we performed full emulation. We do this by
			 * calculating when the counter was reset vs how much
			 * time has elapsed, then bias by the counter tick
			 * rate.
			 */
			if (rw == TIMER_LATCH) {
				gettimeofday(&now, NULL);
				delta.tv_sec = now.tv_sec -
				    i8253_channel[sel].tv.tv_sec;
				delta.tv_usec = now.tv_usec -
				    i8253_channel[sel].tv.tv_usec;
				if (delta.tv_usec < 0) {
					delta.tv_sec--;
					delta.tv_usec += 1000000;
				}
				if (delta.tv_usec > 1000000) {
					delta.tv_sec++;
					delta.tv_usec -= 1000000;
				}
				ns = delta.tv_usec * 1000 +
				    delta.tv_sec * 1000000000;
				ticks = ns / NS_PER_TICK;
				if (i8253_channel[sel].start) {
					i8253_channel[sel].olatch =
					    i8253_channel[sel].start -
					    ticks % i8253_channel[sel].start;
				} else
					i8253_channel[sel].olatch = 0;
				goto ret;
			} else if (rw != TIMER_16BIT) {
				log_warnx("%s: i8253 PIT: unsupported counter "
				    "%d rw mode 0x%x selected", __func__,
				    sel, (rw & TIMER_16BIT));
			}

			goto ret;
		} else {
			log_warnx("%s: i8253 PIT: read from control port "
			    "unsupported", __progname);
			set_return_data(vei, 0);
		}
	} else {
		sel = vei->vei.vei_port - (TIMER_CNTR0 + TIMER_BASE);

		if (vei->vei.vei_dir == VEI_DIR_OUT) { /* OUT instruction */
			if (i8253_channel[sel].last_w == 0) {
				i8253_channel[sel].ilatch |= (out_data & 0xff);
				i8253_channel[sel].last_w = 1;
			} else {
				i8253_channel[sel].ilatch |= ((out_data & 0xff) << 8);
				i8253_channel[sel].start =
				    i8253_channel[sel].ilatch;
				i8253_channel[sel].last_w = 0;
				mode = (out_data & 0xe) >> 1;

				if (i8253_channel[sel].start == 0)
					i8253_channel[sel].start = 0xffff;

				log_debug("%s: channel %d reset, mode=%d, start=%d", __func__,
				    sel, mode, i8253_channel[sel].start);
				i8253_channel[sel].mode = mode;
				i8253_reset(sel);
			}
		} else {
			if (i8253_channel[sel].rbs) {
				i8253_channel[sel].rbs = 0;
				data = i8253_channel[sel].mode << 1;
				data |= TIMER_16BIT;
				set_return_data(vei, data);
				goto ret;
			}

			if (i8253_channel[sel].last_r == 0) {
				data = i8253_channel[sel].olatch >> 8;
				set_return_data(vei, data);
				i8253_channel[sel].last_r = 1;
			} else {
				data = i8253_channel[sel].olatch & 0xFF;
				set_return_data(vei, data);
				i8253_channel[sel].last_r = 0;
			}
		}
	}

ret:
	return (0xFF);
}

/*
 * i8253_reset
 *
 * Resets the i8253's counter timer
 *
 * Parameters:
 *  chn: counter ID. Only channel ID 0 is presently emulated.
 */
void
i8253_reset(uint8_t chn)
{
	struct timeval tv;

	evtimer_del(&i8253_channel[chn].timer);
	timerclear(&tv);

	i8253_channel[chn].in_use = 1;
	tv.tv_usec = (i8253_channel[chn].start * NS_PER_TICK) / 1000;
	evtimer_add(&i8253_channel[chn].timer, &tv);
}

/*
 * i8253_fire
 *
 * Callback invoked when the 8253 PIT timer fires. This will assert
 * IRQ0 on the legacy PIC attached to VCPU0.
 *
 * Parameters:
 *  fd: unused
 *  type: unused
 *  arg: VM ID
 */
void
i8253_fire(int fd, short type, void *arg)
{
	struct timeval tv;
	struct i8253_channel *ctr = (struct i8253_channel *)arg;

	timerclear(&tv);
	tv.tv_usec = (ctr->start * NS_PER_TICK) / 1000;

	vcpu_assert_pic_irq(ctr->vm_id, 0, 0);

	if (ctr->mode != TIMER_INTTC)
		evtimer_add(&ctr->timer, &tv);
}

int
i8253_dump(int fd)
{
	log_debug("%s: sending PIT", __func__);
	if (atomicio(vwrite, fd, &i8253_channel, sizeof(i8253_channel)) !=
	    sizeof(i8253_channel)) {
		log_warnx("%s: error writing PIT to fd", __func__);
		return (-1);
	}
	return (0);
}

int
i8253_restore(int fd, uint32_t vm_id)
{
	int i;
	log_debug("%s: restoring PIT", __func__);
	if (atomicio(read, fd, &i8253_channel, sizeof(i8253_channel)) !=
	    sizeof(i8253_channel)) {
		log_warnx("%s: error reading PIT from fd", __func__);
		return (-1);
	}

	for (i = 0; i < 3; i++) {
		memset(&i8253_channel[i].timer, 0, sizeof(struct event));
		i8253_channel[i].vm_id = vm_id;
		evtimer_set(&i8253_channel[i].timer, i8253_fire,
		    &i8253_channel[i]);
		i8253_reset(i);
	}
	return (0);
}

void
i8253_stop()
{
	int i;
	for (i = 0; i < 3; i++)
		evtimer_del(&i8253_channel[i].timer);
}

void
i8253_start()
{
	int i;
	for (i = 0; i < 3; i++)
		if(i8253_channel[i].in_use)
			i8253_reset(i);
}
@


1.16
log
@vmd/vmctl: Add ability to pause / unpause vms

With help from Ashwin Agrawal

ok reyk@@ mlarkin@@
@
text
@d1 1
a1 1
/* $OpenBSD: i8253.c,v 1.15 2017/05/08 09:08:40 reyk Exp $ */
d270 1
a270 1
				
@


1.15
log
@Adds functions to read and write state of devices in vmd.

This is required for implementing vmctl send and vmctl receive.  vmctl
send / receive are two new options that will support snapshotting VMs
and migrating VMs from one host to another. The atomicio files are
copied from usr.bin/ssh.

Patch from Pratik Vyas; this project was undertaken at San Jose State
University along with his three teammates, Ashwin, Harshada and Siri
with mlarkin@@ as the advisor.

OK mlarkin@@
@
text
@d1 1
a1 1
/* $OpenBSD: i8253.c,v 1.14 2017/04/28 08:14:48 mlarkin Exp $ */
d317 1
d363 1
a369 6
	memset(&i8253_channel[0].timer, 0, sizeof(struct event));
	memset(&i8253_channel[1].timer, 0, sizeof(struct event));
	memset(&i8253_channel[2].timer, 0, sizeof(struct event));
	i8253_channel[0].vm_id = vm_id;
	i8253_channel[1].vm_id = vm_id;
	i8253_channel[2].vm_id = vm_id;
d371 7
a377 4
	evtimer_set(&i8253_channel[0].timer, i8253_fire, &i8253_channel[0]);
	evtimer_set(&i8253_channel[1].timer, i8253_fire, &i8253_channel[1]);
	evtimer_set(&i8253_channel[2].timer, i8253_fire, &i8253_channel[2]);
	i8253_reset(0);
d384 12
a395 3
	evtimer_del(&i8253_channel[0].timer);
	evtimer_del(&i8253_channel[1].timer);
	evtimer_del(&i8253_channel[2].timer);
@


1.14
log
@rename i8253 "counter" to "channel", a better name for what we are
emulating
@
text
@d1 1
a1 1
/* $OpenBSD: i8253.c,v 1.13 2017/04/08 19:06:04 mlarkin Exp $ */
d28 1
d33 1
d345 43
@


1.13
log
@implement channels 1 and 2 of the legacy PIT.

ok otto, deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: i8253.c,v 1.12 2017/03/27 00:28:04 deraadt Exp $ */
d36 3
a38 3
 * Counter 0 is used to generate the legacy hardclock interrupt (HZ).
 * Counters 1 and 2 are not connected to any output (although someone
 * could hook counter 2 up to an emulated pcppi(4) at some point).
d40 1
a40 1
struct i8253_counter i8253_counter[3];
d53 20
a72 20
	memset(&i8253_counter, 0, sizeof(struct i8253_counter));
	gettimeofday(&i8253_counter[0].tv, NULL);
	i8253_counter[0].start = 0xFFFF;
	i8253_counter[0].mode = TIMER_INTTC;
	i8253_counter[0].last_r = 1;
	i8253_counter[0].vm_id = vm_id;

	i8253_counter[1].start = 0xFFFF;
	i8253_counter[1].mode = TIMER_INTTC;
	i8253_counter[1].last_r = 1;
	i8253_counter[1].vm_id = vm_id;

	i8253_counter[2].start = 0xFFFF;
	i8253_counter[2].mode = TIMER_INTTC;
	i8253_counter[2].last_r = 1;
	i8253_counter[2].vm_id = vm_id;

	evtimer_set(&i8253_counter[0].timer, i8253_fire, &i8253_counter[0]);
	evtimer_set(&i8253_counter[1].timer, i8253_fire, &i8253_counter[1]);
	evtimer_set(&i8253_counter[2].timer, i8253_fire, &i8253_counter[2]);
d92 3
a94 3
		i8253_counter[0].rbs = (data & TIMER_RB_C0) ? 1 : 0;
		i8253_counter[1].rbs = (data & TIMER_RB_C1) ? 1 : 0;
		i8253_counter[2].rbs = (data & TIMER_RB_C2) ? 1 : 0;
d101 1
a101 1
			delta.tv_sec = now.tv_sec - i8253_counter[0].tv.tv_sec;
d103 1
a103 1
			    i8253_counter[0].tv.tv_usec;
d114 4
a117 4
			if (i8253_counter[0].start)
				i8253_counter[0].olatch =
				    i8253_counter[0].start -
				    ticks % i8253_counter[0].start;
d119 1
a119 1
				i8253_counter[0].olatch = 0;
d124 1
a124 1
			delta.tv_sec = now.tv_sec - i8253_counter[1].tv.tv_sec;
d126 1
a126 1
			    i8253_counter[1].tv.tv_usec;
d137 4
a140 4
			if (i8253_counter[1].start)
				i8253_counter[1].olatch =
				    i8253_counter[1].start -
				    ticks % i8253_counter[1].start;
d142 1
a142 1
				i8253_counter[1].olatch = 0;
d147 1
a147 1
			delta.tv_sec = now.tv_sec - i8253_counter[2].tv.tv_sec;
d149 1
a149 1
			    i8253_counter[2].tv.tv_usec;
d160 4
a163 4
			if (i8253_counter[2].start)
				i8253_counter[2].olatch =
				    i8253_counter[2].start -
				    ticks % i8253_counter[2].start;
d165 1
a165 1
				i8253_counter[2].olatch = 0;
a173 2
 * We don't emulate all the modes of the i8253, just the basic squarewave
 * "rategen" clock.
d219 1
a219 1
				    i8253_counter[sel].tv.tv_sec;
d221 1
a221 1
				    i8253_counter[sel].tv.tv_usec;
d233 4
a236 4
				if (i8253_counter[sel].start) {
					i8253_counter[sel].olatch =
					    i8253_counter[sel].start -
					    ticks % i8253_counter[sel].start;
d238 1
a238 1
					i8253_counter[sel].olatch = 0;
d256 3
a258 3
			if (i8253_counter[sel].last_w == 0) {
				i8253_counter[sel].ilatch |= (out_data & 0xff);
				i8253_counter[sel].last_w = 1;
d260 4
a263 4
				i8253_counter[sel].ilatch |= ((out_data & 0xff) << 8);
				i8253_counter[sel].start =
				    i8253_counter[sel].ilatch;
				i8253_counter[sel].last_w = 0;
d266 2
a267 2
				if (i8253_counter[sel].start == 0)
					i8253_counter[sel].start = 0xffff;
d270 2
a271 2
				    sel, mode, i8253_counter[sel].start);
				i8253_counter[sel].mode = mode;
d275 3
a277 3
			if (i8253_counter[sel].rbs) {
				i8253_counter[sel].rbs = 0;
				data = i8253_counter[sel].mode << 1;
d283 2
a284 2
			if (i8253_counter[sel].last_r == 0) {
				data = i8253_counter[sel].olatch >> 8;
d286 1
a286 1
				i8253_counter[sel].last_r = 1;
d288 1
a288 1
				data = i8253_counter[sel].olatch & 0xFF;
d290 1
a290 1
				i8253_counter[sel].last_r = 0;
d312 1
a312 1
	evtimer_del(&i8253_counter[chn].timer);
d315 2
a316 2
	tv.tv_usec = (i8253_counter[chn].start * NS_PER_TICK) / 1000;
	evtimer_add(&i8253_counter[chn].timer, &tv);
d334 1
a334 1
	struct i8253_counter *ctr = (struct i8253_counter *)arg;
@


1.12
log
@die whitespace die die die
@
text
@d1 1
a1 1
/* $OpenBSD: i8253.c,v 1.11 2017/03/25 22:36:53 mlarkin Exp $ */
d58 15
a72 2
	evtimer_set(&i8253_counter[0].timer, i8253_fire,
	    (void *)(intptr_t)vm_id);
a89 4
	if ((data & TIMER_RB_C1) || (data & TIMER_RB_C2))
		log_warnx("%s: readback of unsupported channel(s) "
		    "requested", __func__);

d91 1
a91 1
	if (data & ~TIMER_RB_STATUS)
d93 3
d121 46
a256 5
		if (sel != 0) {
			log_warnx("%s: i8253 PIT: nonzero channel %d "
			    "selected", __func__, sel);
		}

d268 5
a313 12
	if (chn != 0) {
		/*
		 * Channels other than 0 are not likely to be programmed
		 * by the guest. Long ago, channel 1 was used to refresh
		 * RAM, and channel 2 is sometimes routed to the PC
		 * speaker.
		 */
		log_debug("%s: unsupported channel %d start request",
		    __func__, chn);
		return;
	}

d336 1
d339 1
a339 1
	tv.tv_usec = (i8253_counter[0].start * NS_PER_TICK) / 1000;
d341 1
a341 1
	vcpu_assert_pic_irq((ptrdiff_t)arg, 0, 0);
d343 2
a344 2
	if (i8253_counter[0].mode != TIMER_INTTC)
		evtimer_add(&i8253_counter[0].timer, &tv);
@


1.11
log
@Last bits needed to get seabios + alpine linux working. This is enough
to get started and let more people help finding and fixing bugs.

ok kettenis, deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: i8253.c,v 1.10 2017/03/25 07:46:24 mlarkin Exp $ */
a182 1
				
@


1.10
log
@Introduce a new function to obtain properly sized input data, and convert
i8253/i8259/mc146818 emulation to use this.
@
text
@d1 1
a1 1
/* $OpenBSD: i8253.c,v 1.9 2017/03/24 11:08:43 reyk Exp $ */
d136 1
a136 1
	out_data = get_input_data(vei);
@


1.9
log
@Backout mlarkin's previous commit while he is away:
The newly-used function get_input_data() is missing and broke the tree.
@
text
@d1 1
a1 1
/* $OpenBSD: i8253.c,v 1.7 2017/03/23 07:02:47 mlarkin Exp $ */
d136 1
a136 1
	out_data = vei->vei.vei_data & 0xFF;
@


1.8
log
@Last bits of cleanup for linux/seabios support in i8253/i8259 emulation
code.
@
text
@d136 1
a136 1
	out_data = get_input_data(vei);
@


1.7
log
@Various i8253/i8254 implementation improvements - Fix an error that used
the wrong i/o latch index on reads (resulting in erratic counter values
possibly being read). Also do proper return size setting (don't clobber
%eax high bits).

This diff also implements counter readback mode, which is used in seabios.
@
text
@d1 1
a1 1
/* $OpenBSD: i8253.c,v 1.6 2017/03/19 23:03:44 mlarkin Exp $ */
d136 1
a136 1
	out_data = vei->vei.vei_data & 0xFF;
@


1.6
log
@Emulated i8253 should not start out in TIMER_RATEGEN mode on boot
automatically. This worked for OpenBSD guests but breaks seabios as soon
as the first interrupt fires since it has not programmed the PIT to do
anything yet. And OpenBSD reprograms the clock to rategen mode as soon
as it boots anyway, so this still works with vmctl(8)'s -k option, as
well as the faux-bootloader implemented in vmd(8)
@
text
@d1 1
a1 1
/* $OpenBSD: i8253.c,v 1.5 2017/01/17 21:51:01 krw Exp $ */
d57 1
d63 50
d136 2
a139 1
			out_data = vei->vei.vei_data;
d143 4
a146 5
			if (sel > 2) {
				log_warnx("%s: i8253 PIT: unuspported "
				    "counter selected (%d)",
				    __progname, sel);
				goto ret;
d149 1
a149 1
			rw = vei->vei.vei_data & (TIMER_LATCH | TIMER_16BIT);
d177 7
a183 3
				i8253_counter[sel].olatch =
				    i8253_counter[sel].start -
				    ticks % i8253_counter[sel].start;
d195 1
a195 1
			vei->vei.vei_data = 0;
a206 1
				out_data = vei->vei.vei_data;
a209 1
				out_data = vei->vei.vei_data;
a216 1

d220 8
d230 2
a231 2
				vei->vei.vei_data = data;
				i8253_counter[sel].last_w = 1;
d234 2
a235 2
				vei->vei.vei_data = data;
				i8253_counter[sel].last_w = 0;
@


1.5
log
@Nuke some whitespace that keeps poking me in the eye as I try to
steal code.
@
text
@d1 1
a1 1
/* $OpenBSD: i8253.c,v 1.4 2016/10/26 05:26:36 mlarkin Exp $ */
d56 1
a56 1
	i8253_counter[0].mode = TIMER_RATEGEN;
a58 1
	i8253_reset(0);
d161 1
a161 1
				mode = out_data & 0xe;
a208 7
	if (i8253_counter[chn].mode != TIMER_RATEGEN &&
	    i8253_counter[chn].mode != (TIMER_RATEGEN | 0x8)) {
		log_warnx("%s: unsupported counter mode 0x%x",
		    __func__, i8253_counter[chn].mode);
		return;
	}

d237 2
a238 1
	evtimer_add(&i8253_counter[0].timer, &tv);
@


1.4
log
@
vmd(8)/vmctl(8) for i386. Some ugliness in #ifdef __i386__ areas will be
fixed in tree, but the changes required were pretty minimal.

Note that i386 hosts are still presently limited to running i386 guests.

ok deraadt, stefan, jca
@
text
@d1 1
a1 1
/* $OpenBSD: i8253.c,v 1.3 2016/10/03 06:00:17 mlarkin Exp $ */
d244 1
a244 1
	
@


1.3
log
@
add RCS tags
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d58 1
a58 1
	    (void *)(uint64_t)vm_id);
@


1.2
log
@
change some log_warn to log_warnx and convert some integer literals to
enumerand values
@
text
@d1 1
@


1.1
log
@
Add a set of emulated legacy devices (PIT, PIC, RTC)

discussed with stefan and deraadt
@
text
@d86 1
a86 1
		if (vei->vei.vei_dir == 0) { /* OUT instruction */
d150 1
a150 1
		if (vei->vei.vei_dir == 0) { /* OUT instruction */
@

