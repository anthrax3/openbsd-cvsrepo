head	1.68;
access;
symbols
	OPENBSD_6_1:1.55.0.4
	OPENBSD_6_1_BASE:1.55
	OPENBSD_6_0:1.27.0.4
	OPENBSD_6_0_BASE:1.27
	OPENBSD_5_9:1.27.0.2
	OPENBSD_5_9_BASE:1.27;
locks; strict;
comment	@ * @;


1.68
date	2017.08.20.21.15.32;	author pd;	state Exp;
branches;
next	1.67;
commitid	xPNUMDuMFeDPC7PQ;

1.67
date	2017.08.15.15.10.35;	author pd;	state Exp;
branches;
next	1.66;
commitid	emWs71NQDm4m5qJt;

1.66
date	2017.08.14.17.20.59;	author jasper;	state Exp;
branches;
next	1.65;
commitid	gMM0klG0Rlf5OD7Q;

1.65
date	2017.08.13.16.45.07;	author jasper;	state Exp;
branches;
next	1.64;
commitid	b61IeZew13XHpdiP;

1.64
date	2017.07.15.05.05.36;	author pd;	state Exp;
branches;
next	1.63;
commitid	l7Kfh3b63PsFu8PF;

1.63
date	2017.07.09.00.51.40;	author pd;	state Exp;
branches;
next	1.62;
commitid	qGhsIrgsAzfqzJtv;

1.62
date	2017.05.29.07.15.22;	author mlarkin;	state Exp;
branches;
next	1.61;
commitid	oPLknhkI0ccva3a1;

1.61
date	2017.05.04.19.41.58;	author reyk;	state Exp;
branches;
next	1.60;
commitid	ygf0Wmp9XnmAli8A;

1.60
date	2017.05.04.08.26.06;	author reyk;	state Exp;
branches;
next	1.59;
commitid	yAlsQTtUT6FmUiOt;

1.59
date	2017.04.25.16.38.23;	author reyk;	state Exp;
branches;
next	1.58;
commitid	12tOdtj6HIkTqHck;

1.58
date	2017.04.21.07.03.26;	author reyk;	state Exp;
branches;
next	1.57;
commitid	B4wb6zF2A8q3ls4h;

1.57
date	2017.04.19.15.38.32;	author reyk;	state Exp;
branches;
next	1.56;
commitid	Wp87uvjcKIIYK6nL;

1.56
date	2017.04.06.18.07.13;	author reyk;	state Exp;
branches;
next	1.55;
commitid	EDN0yyFCjEEFLBXp;

1.55
date	2017.03.15.19.54.52;	author reyk;	state Exp;
branches;
next	1.54;
commitid	hI6HER6ogR9devo1;

1.54
date	2017.03.15.17.53.10;	author reyk;	state Exp;
branches;
next	1.53;
commitid	og2X5TmEO3Vnf4dU;

1.53
date	2017.03.02.07.33.37;	author reyk;	state Exp;
branches;
next	1.52;
commitid	0uvzhmQVR7Ehsjus;

1.52
date	2017.03.01.07.43.33;	author reyk;	state Exp;
branches;
next	1.51;
commitid	2hnfyuVZdSB2L5DB;

1.51
date	2017.02.27.14.37.58;	author reyk;	state Exp;
branches;
next	1.50;
commitid	VZNWondGbqn2F9Is;

1.50
date	2017.01.13.19.21.16;	author edd;	state Exp;
branches;
next	1.49;
commitid	G03UUOsXsvVsTKN2;

1.49
date	2017.01.11.22.38.10;	author reyk;	state Exp;
branches;
next	1.48;
commitid	36vA2wHEJBH4Kmuc;

1.48
date	2017.01.09.14.49.22;	author reyk;	state Exp;
branches;
next	1.47;
commitid	eA8b246voAapPTkX;

1.47
date	2016.12.14.21.17.25;	author reyk;	state Exp;
branches;
next	1.46;
commitid	yUESeopyz7N219vi;

1.46
date	2016.12.14.06.59.12;	author reyk;	state Exp;
branches;
next	1.45;
commitid	InVlLp4UCIsZp75o;

1.45
date	2016.11.26.20.03.42;	author reyk;	state Exp;
branches;
next	1.44;
commitid	GrCSblbcTEkTQcOY;

1.44
date	2016.11.26.19.49.11;	author reyk;	state Exp;
branches;
next	1.43;
commitid	ad2wVCUrs7CBTqdu;

1.43
date	2016.11.24.07.58.55;	author reyk;	state Exp;
branches;
next	1.42;
commitid	vTTzvT7jwtD1X8ZA;

1.42
date	2016.11.22.21.55.54;	author reyk;	state Exp;
branches;
next	1.41;
commitid	H4GVKiza5W94X5mq;

1.41
date	2016.11.22.12.55.33;	author reyk;	state Exp;
branches;
next	1.40;
commitid	fQC64xP966Wt1A6F;

1.40
date	2016.11.22.11.31.38;	author edd;	state Exp;
branches;
next	1.39;
commitid	vSgc5Dc31FPMjVfo;

1.39
date	2016.11.04.15.16.44;	author reyk;	state Exp;
branches;
next	1.38;
commitid	SAdDSuqFvlzVuxeB;

1.38
date	2016.11.04.15.07.26;	author reyk;	state Exp;
branches;
next	1.37;
commitid	qfn7LnsEzfGhtk0c;

1.37
date	2016.10.29.14.56.05;	author edd;	state Exp;
branches;
next	1.36;
commitid	DOewrpkDk9kNopaK;

1.36
date	2016.10.17.16.26.20;	author reyk;	state Exp;
branches;
next	1.35;
commitid	QbpP9IWB9tkvRriq;

1.35
date	2016.10.15.14.02.11;	author reyk;	state Exp;
branches;
next	1.34;
commitid	17YGcUnMa3ic5LJQ;

1.34
date	2016.10.12.19.10.03;	author reyk;	state Exp;
branches;
next	1.33;
commitid	ghkPP3DbrIiwazmp;

1.33
date	2016.10.06.18.48.41;	author reyk;	state Exp;
branches;
next	1.32;
commitid	PTFbBM1dh72QP2DS;

1.32
date	2016.10.05.17.30.13;	author reyk;	state Exp;
branches;
next	1.31;
commitid	c3mC9fNmRbfUPluH;

1.31
date	2016.10.04.17.17.30;	author reyk;	state Exp;
branches;
next	1.30;
commitid	yb7Y2lNmLG5i2hzO;

1.30
date	2016.09.29.22.42.04;	author reyk;	state Exp;
branches;
next	1.29;
commitid	OrqC5N55KjzTfX1Z;

1.29
date	2016.08.17.05.07.13;	author deraadt;	state Exp;
branches;
next	1.28;
commitid	qqWoBqCGCbsKOAqY;

1.28
date	2016.07.29.16.36.51;	author stefan;	state Exp;
branches;
next	1.27;
commitid	lYP7ykFkRsliCh0y;

1.27
date	2016.02.05.11.40.15;	author reyk;	state Exp;
branches;
next	1.26;
commitid	qNU5HuuJes7hxOho;

1.26
date	2016.02.02.17.51.11;	author sthen;	state Exp;
branches;
next	1.25;
commitid	LQHdRRMF0nq0fugE;

1.25
date	2015.12.11.10.16.53;	author reyk;	state Exp;
branches;
next	1.24;
commitid	czO28zk1ubQjkjYC;

1.24
date	2015.12.08.23.59.39;	author jsg;	state Exp;
branches;
next	1.23;
commitid	xcyDM5zGqoBDMbVN;

1.23
date	2015.12.08.23.47.59;	author jsg;	state Exp;
branches;
next	1.22;
commitid	4qn1R0dbCvo1xoSg;

1.22
date	2015.12.07.12.52.00;	author reyk;	state Exp;
branches;
next	1.21;
commitid	vtOi4oysH69IOu0c;

1.21
date	2015.12.06.21.02.51;	author reyk;	state Exp;
branches;
next	1.20;
commitid	Zp1KJ8lrcRoKUs6F;

1.20
date	2015.12.06.02.26.14;	author reyk;	state Exp;
branches;
next	1.19;
commitid	DA7pwA53qcaD5xYQ;

1.19
date	2015.12.06.01.58.21;	author reyk;	state Exp;
branches;
next	1.18;
commitid	mJFYjYlVhI5frPwA;

1.18
date	2015.12.06.01.16.22;	author reyk;	state Exp;
branches;
next	1.17;
commitid	5ndAmp7Zc65BMaks;

1.17
date	2015.12.05.20.33.51;	author reyk;	state Exp;
branches;
next	1.16;
commitid	7iqWzkIZ1vNvAYsG;

1.16
date	2015.12.03.23.32.32;	author reyk;	state Exp;
branches;
next	1.15;
commitid	ABlEnH3RsSBpSsyK;

1.15
date	2015.12.03.16.18.13;	author reyk;	state Exp;
branches;
next	1.14;
commitid	32vG2ozzEdZ6a46n;

1.14
date	2015.12.03.16.13.04;	author reyk;	state Exp;
branches;
next	1.13;
commitid	lWQAx9cC1iJR7uBY;

1.13
date	2015.12.03.16.11.32;	author reyk;	state Exp;
branches;
next	1.12;
commitid	G1u4CGxMrb6r5d6R;

1.12
date	2015.12.03.13.27.14;	author reyk;	state Exp;
branches;
next	1.11;
commitid	pRSLgXNuoj9hRPQx;

1.11
date	2015.12.02.23.33.43;	author reyk;	state Exp;
branches;
next	1.10;
commitid	w96GQ2Dz9TsvO0tu;

1.10
date	2015.12.02.22.19.11;	author reyk;	state Exp;
branches;
next	1.9;
commitid	7ra6VeOJoUb1NQ70;

1.9
date	2015.12.02.09.14.25;	author reyk;	state Exp;
branches;
next	1.8;
commitid	vOctzllSJTLtnazM;

1.8
date	2015.11.26.08.26.48;	author reyk;	state Exp;
branches;
next	1.7;
commitid	GRMyPzYJL6q2Nvq3;

1.7
date	2015.11.25.22.44.21;	author tedu;	state Exp;
branches;
next	1.6;
commitid	vhy77aiGXmqDgj2W;

1.6
date	2015.11.23.21.07.29;	author reyk;	state Exp;
branches;
next	1.5;
commitid	o0fBytYM2Ro1xbeT;

1.5
date	2015.11.23.20.18.33;	author reyk;	state Exp;
branches;
next	1.4;
commitid	sQGCiSE68hBU4XBf;

1.4
date	2015.11.23.13.04.49;	author reyk;	state Exp;
branches;
next	1.3;
commitid	8LSTqui1EesFdS0T;

1.3
date	2015.11.22.22.29.48;	author deraadt;	state Exp;
branches;
next	1.2;
commitid	ecUDCp0AdT9arDIw;

1.2
date	2015.11.22.21.51.32;	author reyk;	state Exp;
branches;
next	1.1;
commitid	nvO8KnrtEKRaTvXw;

1.1
date	2015.11.22.20.20.32;	author mlarkin;	state Exp;
branches;
next	;
commitid	O5Ay1ZamHQn9lamK;


desc
@@


1.68
log
@vmd: Allow only upward migration

This restricts receiving vms from hosts with more cpu features.

Tested on
broadwell -> skylake (works)
skylake -> broadwell (don't work)

ok mlarkin@@
@
text
@/*	$OpenBSD: vmd.c,v 1.67 2017/08/15 15:10:35 pd Exp $	*/

/*
 * Copyright (c) 2015 Reyk Floeter <reyk@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/param.h>	/* nitems */
#include <sys/queue.h>
#include <sys/wait.h>
#include <sys/cdefs.h>
#include <sys/stat.h>
#include <sys/tty.h>
#include <sys/ioctl.h>

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <termios.h>
#include <errno.h>
#include <event.h>
#include <fcntl.h>
#include <pwd.h>
#include <signal.h>
#include <syslog.h>
#include <unistd.h>
#include <ctype.h>
#include <pwd.h>
#include <grp.h>

#include <machine/specialreg.h>
#include <machine/vmmvar.h>

#include "proc.h"
#include "atomicio.h"
#include "vmd.h"

__dead void usage(void);

int	 main(int, char **);
int	 vmd_configure(void);
void	 vmd_sighdlr(int sig, short event, void *arg);
void	 vmd_shutdown(void);
int	 vmd_control_run(void);
int	 vmd_dispatch_control(int, struct privsep_proc *, struct imsg *);
int	 vmd_dispatch_vmm(int, struct privsep_proc *, struct imsg *);
int	 check_vmh(struct vm_dump_header *);

struct vmd	*env;

static struct privsep_proc procs[] = {
	/* Keep "priv" on top as procs[0] */
	{ "priv",	PROC_PRIV,	NULL, priv },
	{ "control",	PROC_CONTROL,	vmd_dispatch_control, control },
	{ "vmm",	PROC_VMM,	vmd_dispatch_vmm, vmm, vmm_shutdown },
};

/* For the privileged process */
static struct privsep_proc *proc_priv = &procs[0];
static struct passwd proc_privpw;

int
vmd_dispatch_control(int fd, struct privsep_proc *p, struct imsg *imsg)
{
	struct privsep			*ps = p->p_ps;
	int				 res = 0, ret = 0, cmd = 0, verbose;
	unsigned int			 v = 0;
	struct vmop_create_params	 vmc;
	struct vmop_id			 vid;
	struct vm_terminate_params	 vtp;
	struct vmop_result		 vmr;
	struct vm_dump_header		 vmh;
	struct vmd_vm			*vm = NULL;
	char				*str = NULL;
	uint32_t			 id = 0;

	switch (imsg->hdr.type) {
	case IMSG_VMDOP_START_VM_REQUEST:
		IMSG_SIZE_CHECK(imsg, &vmc);
		memcpy(&vmc, imsg->data, sizeof(vmc));
		ret = vm_register(ps, &vmc, &vm, 0, vmc.vmc_uid);
		if (vmc.vmc_flags == 0) {
			/* start an existing VM with pre-configured options */
			if (!(ret == -1 && errno == EALREADY &&
			    vm->vm_running == 0)) {
				res = errno;
				cmd = IMSG_VMDOP_START_VM_RESPONSE;
			}
		} else if (ret != 0) {
			res = errno;
			cmd = IMSG_VMDOP_START_VM_RESPONSE;
		}
		if (res == 0 &&
		    config_setvm(ps, vm, imsg->hdr.peerid, vmc.vmc_uid) == -1) {
			res = errno;
			cmd = IMSG_VMDOP_START_VM_RESPONSE;
		}
		break;
	case IMSG_VMDOP_TERMINATE_VM_REQUEST:
		IMSG_SIZE_CHECK(imsg, &vid);
		memcpy(&vid, imsg->data, sizeof(vid));
		if ((id = vid.vid_id) == 0) {
			/* Lookup vm (id) by name */
			if ((vm = vm_getbyname(vid.vid_name)) == NULL) {
				res = ENOENT;
				cmd = IMSG_VMDOP_TERMINATE_VM_RESPONSE;
				break;
			} else if (vm->vm_shutdown) {
				res = EALREADY;
				cmd = IMSG_VMDOP_TERMINATE_VM_RESPONSE;
				break;
			} else if (vm->vm_running == 0) {
				res = EINVAL;
				cmd = IMSG_VMDOP_TERMINATE_VM_RESPONSE;
				break;
			}
			id = vm->vm_vmid;
		} else if ((vm = vm_getbyvmid(id)) == NULL) {
			res = ENOENT;
			cmd = IMSG_VMDOP_TERMINATE_VM_RESPONSE;
			break;
		}
		if (vm_checkperm(vm, vid.vid_uid) != 0) {
			res = EPERM;
			cmd = IMSG_VMDOP_TERMINATE_VM_RESPONSE;
			break;
		}
		memset(&vtp, 0, sizeof(vtp));
		vtp.vtp_vm_id = id;
		if (proc_compose_imsg(ps, PROC_VMM, -1, imsg->hdr.type,
		    imsg->hdr.peerid, -1, &vtp, sizeof(vtp)) == -1)
			return (-1);
		break;
	case IMSG_VMDOP_GET_INFO_VM_REQUEST:
		proc_forward_imsg(ps, imsg, PROC_VMM, -1);
		break;
	case IMSG_VMDOP_LOAD:
		IMSG_SIZE_CHECK(imsg, str); /* at least one byte for path */
		str = get_string((uint8_t *)imsg->data,
		    IMSG_DATA_SIZE(imsg));
	case IMSG_VMDOP_RELOAD:
		if (vmd_reload(0, str) == -1)
			cmd = IMSG_CTL_FAIL;
		else
			cmd = IMSG_CTL_OK;
		free(str);
		break;
	case IMSG_CTL_RESET:
		IMSG_SIZE_CHECK(imsg, &v);
		memcpy(&v, imsg->data, sizeof(v));
		if (vmd_reload(v, NULL) == -1)
			cmd = IMSG_CTL_FAIL;
		else
			cmd = IMSG_CTL_OK;
		break;
	case IMSG_CTL_VERBOSE:
		IMSG_SIZE_CHECK(imsg, &verbose);
		memcpy(&verbose, imsg->data, sizeof(verbose));
		log_setverbose(verbose);

		proc_forward_imsg(ps, imsg, PROC_VMM, -1);
		proc_forward_imsg(ps, imsg, PROC_PRIV, -1);
		cmd = IMSG_CTL_OK;
		break;
	case IMSG_VMDOP_PAUSE_VM:
	case IMSG_VMDOP_UNPAUSE_VM:
		IMSG_SIZE_CHECK(imsg, &vid);
		memcpy(&vid, imsg->data, sizeof(vid));
		if (vid.vid_id == 0) {
			if ((vm = vm_getbyname(vid.vid_name)) == NULL) {
				res = ENOENT;
				cmd = IMSG_VMDOP_PAUSE_VM_RESPONSE;
				break;
			} else {
				vid.vid_id = vm->vm_vmid;
			}
		}
		proc_compose_imsg(ps, PROC_VMM, -1, imsg->hdr.type,
		    imsg->hdr.peerid, -1, &vid, sizeof(vid));
		break;
	case IMSG_VMDOP_SEND_VM_REQUEST:
		IMSG_SIZE_CHECK(imsg, &vid);
		memcpy(&vid, imsg->data, sizeof(vid));
		id = vid.vid_id;
		if (vid.vid_id == 0) {
			if ((vm = vm_getbyname(vid.vid_name)) == NULL) {
				res = ENOENT;
				cmd = IMSG_VMDOP_SEND_VM_RESPONSE;
				close(imsg->fd);
				break;
			} else {
				vid.vid_id = vm->vm_vmid;
			}
		} else if ((vm = vm_getbyvmid(vid.vid_id)) == NULL) {
			res = ENOENT;
			cmd = IMSG_VMDOP_SEND_VM_RESPONSE;
			close(imsg->fd);
			break;
		} else {
		}
		vmr.vmr_id = vid.vid_id;
		log_debug("%s: sending fd to vmm", __func__);
		proc_compose_imsg(ps, PROC_VMM, -1, imsg->hdr.type,
		    imsg->hdr.peerid, imsg->fd, &vid, sizeof(vid));
		break;
	case IMSG_VMDOP_RECEIVE_VM_REQUEST:
		IMSG_SIZE_CHECK(imsg, &vid);
		memcpy(&vid, imsg->data, sizeof(vid));
		if (imsg->fd == -1) {
			log_warnx("%s: invalid fd", __func__);
			return (-1);
		}
		if (atomicio(read, imsg->fd, &vmh, sizeof(vmh)) !=
		    sizeof(vmh)) {
			log_warnx("%s: error reading vmh from recevied vm",
			    __func__);
			res = EIO;
			close(imsg->fd);
			cmd = IMSG_VMDOP_START_VM_RESPONSE;
			break;
		}
		if(check_vmh(&vmh)) {
			res = ENOENT;
			close(imsg->fd);
			cmd = IMSG_VMDOP_START_VM_RESPONSE;
			break;
		}
		if (atomicio(read, imsg->fd, &vmc, sizeof(vmc)) !=
		    sizeof(vmc)) {
			log_warnx("%s: error reading vmc from recevied vm",
			    __func__);
			res = EIO;
			close(imsg->fd);
			cmd = IMSG_VMDOP_START_VM_RESPONSE;
			break;
		}
		strlcpy(vmc.vmc_params.vcp_name, vid.vid_name,
		    sizeof(vmc.vmc_params.vcp_name));
		vmc.vmc_params.vcp_id = 0;

		ret = vm_register(ps, &vmc, &vm, 0, vmc.vmc_uid);
		if (ret != 0) {
			res = errno;
			cmd = IMSG_VMDOP_START_VM_RESPONSE;
			close(imsg->fd);
		} else {
			vm->vm_received = 1;
			config_setvm(ps, vm, imsg->hdr.peerid, vmc.vmc_uid);
			log_debug("%s: sending fd to vmm", __func__);
			proc_compose_imsg(ps, PROC_VMM, -1,
			    IMSG_VMDOP_RECEIVE_VM_END, vm->vm_vmid, imsg->fd,
			    NULL, 0);
		}
		break;
	default:
		return (-1);
	}

	switch (cmd) {
	case 0:
		break;
	case IMSG_VMDOP_START_VM_RESPONSE:
	case IMSG_VMDOP_TERMINATE_VM_RESPONSE:
		memset(&vmr, 0, sizeof(vmr));
		vmr.vmr_result = res;
		vmr.vmr_id = id;
		if (proc_compose_imsg(ps, PROC_CONTROL, -1, cmd,
		    imsg->hdr.peerid, -1, &vmr, sizeof(vmr)) == -1)
			return (-1);
		break;
	default:
		if (proc_compose_imsg(ps, PROC_CONTROL, -1, cmd,
		    imsg->hdr.peerid, -1, &res, sizeof(res)) == -1)
			return (-1);
		break;
	}

	return (0);
}

int
vmd_dispatch_vmm(int fd, struct privsep_proc *p, struct imsg *imsg)
{
	struct vmop_result	 vmr;
	struct privsep		*ps = p->p_ps;
	int			 res = 0;
	struct vmd_vm		*vm;
	struct vm_create_params	*vcp;
	struct vmop_info_result	 vir;

	switch (imsg->hdr.type) {
	case IMSG_VMDOP_PAUSE_VM_RESPONSE:
		IMSG_SIZE_CHECK(imsg, &vmr);
		memcpy(&vmr, imsg->data, sizeof(vmr));
		if ((vm = vm_getbyvmid(vmr.vmr_id)) == NULL)
			break;
		proc_compose_imsg(ps, PROC_CONTROL, -1,
		    imsg->hdr.type, imsg->hdr.peerid, -1,
		    imsg->data, sizeof(imsg->data));
		log_info("%s: paused vm %d successfully",
		    vm->vm_params.vmc_params.vcp_name,
		    vm->vm_vmid);
		break;
	case IMSG_VMDOP_UNPAUSE_VM_RESPONSE:
		IMSG_SIZE_CHECK(imsg, &vmr);
		memcpy(&vmr, imsg->data, sizeof(vmr));
		if ((vm = vm_getbyvmid(vmr.vmr_id)) == NULL)
			break;
		proc_compose_imsg(ps, PROC_CONTROL, -1,
		    imsg->hdr.type, imsg->hdr.peerid, -1,
		    imsg->data, sizeof(imsg->data));
		log_info("%s: unpaused vm %d successfully.",
		    vm->vm_params.vmc_params.vcp_name,
		    vm->vm_vmid);
		break;
	case IMSG_VMDOP_START_VM_RESPONSE:
		IMSG_SIZE_CHECK(imsg, &vmr);
		memcpy(&vmr, imsg->data, sizeof(vmr));
		if ((vm = vm_getbyvmid(imsg->hdr.peerid)) == NULL)
			break;
		vm->vm_pid = vmr.vmr_pid;
		vcp = &vm->vm_params.vmc_params;
		vcp->vcp_id = vmr.vmr_id;

		/*
		 * If the peerid is not -1, forward the response back to the
		 * the control socket.  If it is -1, the request originated
		 * from the parent, not the control socket.
		 */
		if (vm->vm_peerid != (uint32_t)-1) {
			(void)strlcpy(vmr.vmr_ttyname, vm->vm_ttyname,
			    sizeof(vmr.vmr_ttyname));
			if (proc_compose_imsg(ps, PROC_CONTROL, -1,
			    imsg->hdr.type, vm->vm_peerid, -1,
			    &vmr, sizeof(vmr)) == -1) {
				errno = vmr.vmr_result;
				log_warn("%s: failed to foward vm result",
				    vcp->vcp_name);
				vm_remove(vm);
				return (-1);
			}
		}

		if (vmr.vmr_result) {
			errno = vmr.vmr_result;
			log_warn("%s: failed to start vm", vcp->vcp_name);
			vm_remove(vm);
			break;
		}

		/* Now configure all the interfaces */
		if (vm_priv_ifconfig(ps, vm) == -1) {
			log_warn("%s: failed to configure vm", vcp->vcp_name);
			vm_remove(vm);
			break;
		}

		log_info("%s: started vm %d successfully, tty %s",
		    vcp->vcp_name, vm->vm_vmid, vm->vm_ttyname);
		break;
	case IMSG_VMDOP_TERMINATE_VM_RESPONSE:
		IMSG_SIZE_CHECK(imsg, &vmr);
		memcpy(&vmr, imsg->data, sizeof(vmr));
		proc_forward_imsg(ps, imsg, PROC_CONTROL, -1);
		if ((vm = vm_getbyvmid(vmr.vmr_id)) == NULL)
			break;
		if (vmr.vmr_result == 0) {
			/* Mark VM as shutting down */
			vm->vm_shutdown = 1;
		}
		break;
	case IMSG_VMDOP_SEND_VM_RESPONSE:
		IMSG_SIZE_CHECK(imsg, &vmr);
		memcpy(&vmr, imsg->data, sizeof(vmr));
		if ((vm = vm_getbyvmid(vmr.vmr_id)) == NULL)
			break;
		if (!vmr.vmr_result)
			log_info("%s: sent vm %d successfully.",
			    vm->vm_params.vmc_params.vcp_name,
			    vm->vm_vmid);
	case IMSG_VMDOP_TERMINATE_VM_EVENT:
		IMSG_SIZE_CHECK(imsg, &vmr);
		memcpy(&vmr, imsg->data, sizeof(vmr));
		if ((vm = vm_getbyvmid(vmr.vmr_id)) == NULL)
			break;
		if (vmr.vmr_result == 0) {
			if (vm->vm_from_config)
				vm_stop(vm, 0);
			else
				vm_remove(vm);
		} else if (vmr.vmr_result == EAGAIN) {
			/* Stop VM instance but keep the tty open */
			vm_stop(vm, 1);
			config_setvm(ps, vm, (uint32_t)-1, 0);
		}
		break;
	case IMSG_VMDOP_GET_INFO_VM_DATA:
		IMSG_SIZE_CHECK(imsg, &vir);
		memcpy(&vir, imsg->data, sizeof(vir));
		if ((vm = vm_getbyvmid(vir.vir_info.vir_id)) != NULL) {
			memset(vir.vir_ttyname, 0, sizeof(vir.vir_ttyname));
			if (vm->vm_ttyname != NULL)
				strlcpy(vir.vir_ttyname, vm->vm_ttyname,
				    sizeof(vir.vir_ttyname));
			if (vm->vm_shutdown) {
				/* XXX there might be a nicer way */
				(void)strlcat(vir.vir_info.vir_name,
				    " - stopping",
				    sizeof(vir.vir_info.vir_name));
			}
			/* get the user id who started the vm */
			vir.vir_uid = vm->vm_uid;
			vir.vir_gid = vm->vm_params.vmc_gid;
		}
		if (proc_compose_imsg(ps, PROC_CONTROL, -1, imsg->hdr.type,
		    imsg->hdr.peerid, -1, &vir, sizeof(vir)) == -1) {
			vm_remove(vm);
			return (-1);
		}
		break;
	case IMSG_VMDOP_GET_INFO_VM_END_DATA:
		/*
		 * PROC_VMM has responded with the *running* VMs, now we
		 * append the others. These use the special value 0 for their
		 * kernel id to indicate that they are not running.
		 */
		TAILQ_FOREACH(vm, env->vmd_vms, vm_entry) {
			if (!vm->vm_running) {
				memset(&vir, 0, sizeof(vir));
				vir.vir_info.vir_id = vm->vm_vmid;
				strlcpy(vir.vir_info.vir_name,
				    vm->vm_params.vmc_params.vcp_name,
				    VMM_MAX_NAME_LEN);
				vir.vir_info.vir_memory_size =
				    vm->vm_params.vmc_params.vcp_memranges[0].vmr_size;
				vir.vir_info.vir_ncpus =
				    vm->vm_params.vmc_params.vcp_ncpus;
				/* get the configured user id for this vm */
				vir.vir_uid = vm->vm_params.vmc_uid;
				vir.vir_gid = vm->vm_params.vmc_gid;
				if (proc_compose_imsg(ps, PROC_CONTROL, -1,
				    IMSG_VMDOP_GET_INFO_VM_DATA,
				    imsg->hdr.peerid, -1, &vir,
				    sizeof(vir)) == -1) {
					vm_remove(vm);
					return (-1);
				}
			}
		}
		IMSG_SIZE_CHECK(imsg, &res);
		proc_forward_imsg(ps, imsg, PROC_CONTROL, -1);
		break;
	default:
		return (-1);
	}

	return (0);
}

int
check_vmh(struct vm_dump_header *vmh) {
	int i;
	unsigned int code, leaf;
	unsigned int a, b, c, d;


	if (vmh->vmh_version != VM_DUMP_VERSION) {
		log_warnx("%s: incompatible dump version", __func__);
		return (-1);
	}

	for (i = 0; i < VM_DUMP_HEADER_CPUID_COUNT; i++) {
		code = vmh->vmh_cpuids[i].code;
		leaf = vmh->vmh_cpuids[i].leaf;
		if (leaf != 0x00) {
			log_debug("%s: invalid leaf 0x%x for code 0x%x",
			    __func__, leaf, code);
			return (-1);
		}

		switch(code) {
		case 0x00:
		CPUID_LEAF(code, leaf, a, b, c, d);
		if (vmh->vmh_cpuids[i].a > a) {
			log_debug("%s: incompatible cpuid level", __func__);
			return (-1);
		}
		if (!(vmh->vmh_cpuids[i].b == b &&
		    vmh->vmh_cpuids[i].c == c &&
		    vmh->vmh_cpuids[i].d == d)) {
			log_debug("%s: incompatible cpu brand", __func__);
			return (-1);
		}
		break;

		case 0x01:
		CPUID_LEAF(code, leaf, a, b, c, d);
		if ((vmh->vmh_cpuids[i].c & c & VMM_CPUIDECX_MASK) !=
		    (vmh->vmh_cpuids[i].c & VMM_CPUIDECX_MASK)) {
			log_debug("%s: incompatible cpu features "
			    "code: 0x%x leaf: 0x%x  reg: c", __func__,
			    code, leaf);
			return (-1);
		}
		if ((vmh->vmh_cpuids[i].d & d & VMM_CPUIDEDX_MASK) !=
		    (vmh->vmh_cpuids[i].d & VMM_CPUIDEDX_MASK)) {
			log_debug("%s: incompatible cpu features "
			    "code: 0x%x leaf: 0x%x  reg: d", __func__,
			    code, leaf);
			return (-1);
		}
		break;

		case 0x07:
		CPUID_LEAF(code, leaf, a, b, c, d);
		if ((vmh->vmh_cpuids[i].b & b & VMM_SEFF0EBX_MASK) !=
		    (vmh->vmh_cpuids[i].b & VMM_SEFF0EBX_MASK)) {
			log_debug("%s: incompatible cpu features "
			    "code: 0x%x leaf: 0x%x  reg: c", __func__,
			    code, leaf);
			return (-1);
		}
		if ((vmh->vmh_cpuids[i].c & c & VMM_SEFF0ECX_MASK) !=
		    (vmh->vmh_cpuids[i].c & VMM_SEFF0ECX_MASK)) {
			log_debug("%s: incompatible cpu features "
			    "code: 0x%x leaf: 0x%x  reg: d", __func__,
			    code, leaf);
			return (-1);
		}
		break;

		case 0x0d:
		CPUID_LEAF(code, leaf, a, b, c, d);
		if (vmh->vmh_cpuids[i].b > b) {
			log_debug("%s: incompatible cpu: insufficient "
			    "max save area for enabled XCR0 features",
			    __func__);
			return (-1);
		}
		if (vmh->vmh_cpuids[i].c > c) {
			log_debug("%s: incompatible cpu: insufficient "
			    "max save area for supported XCR0 features",
			    __func__);
			return (-1);
		}
		break;

		case 0x80000001:
		CPUID_LEAF(code, leaf, a, b, c, d);
		if ((vmh->vmh_cpuids[i].a & a) != vmh->vmh_cpuids[i].a) {
			log_debug("%s: incompatible cpu features "
			    "code: 0x%x leaf: 0x%x  reg: a", __func__,
			    code, leaf);
			return (-1);
		}
		if ((vmh->vmh_cpuids[i].c & c) != vmh->vmh_cpuids[i].c) {
			log_debug("%s: incompatible cpu features "
			    "code: 0x%x leaf: 0x%x  reg: c", __func__,
			    code, leaf);
			return (-1);
		}
		if ((vmh->vmh_cpuids[i].d & d) != vmh->vmh_cpuids[i].d) {
			log_debug("%s: incompatible cpu features "
			    "code: 0x%x leaf: 0x%x  reg: d", __func__,
			    code, leaf);
			return (-1);
		}
		break;

		default:
		log_debug("%s: unknown code 0x%x", __func__, code);
		return (-1);
		}
	}

	return (0);
}

void
vmd_sighdlr(int sig, short event, void *arg)
{
	if (privsep_process != PROC_PARENT)
		return;

	switch (sig) {
	case SIGHUP:
		log_info("%s: reload requested with SIGHUP", __func__);

		/*
		 * This is safe because libevent uses async signal handlers
		 * that run in the event loop and not in signal context.
		 */
		(void)vmd_reload(0, NULL);
		break;
	case SIGPIPE:
		log_info("%s: ignoring SIGPIPE", __func__);
		break;
	case SIGUSR1:
		log_info("%s: ignoring SIGUSR1", __func__);
		break;
	case SIGTERM:
	case SIGINT:
		vmd_shutdown();
		break;
	default:
		fatalx("unexpected signal");
	}
}

__dead void
usage(void)
{
	extern char *__progname;
	fprintf(stderr, "usage: %s [-dnv] [-D macro=value] [-f file]\n",
	    __progname);
	exit(1);
}

int
main(int argc, char **argv)
{
	struct privsep		*ps;
	int			 ch;
	const char		*conffile = VMD_CONF;
	enum privsep_procid	 proc_id = PROC_PARENT;
	int			 proc_instance = 0;
	const char		*errp, *title = NULL;
	int			 argc0 = argc;

	/* log to stderr until daemonized */
	log_init(1, LOG_DAEMON);

	if ((env = calloc(1, sizeof(*env))) == NULL)
		fatal("calloc: env");

	while ((ch = getopt(argc, argv, "D:P:I:df:vn")) != -1) {
		switch (ch) {
		case 'D':
			if (cmdline_symset(optarg) < 0)
				log_warnx("could not parse macro definition %s",
				    optarg);
			break;
		case 'd':
			env->vmd_debug = 2;
			break;
		case 'f':
			conffile = optarg;
			break;
		case 'v':
			env->vmd_verbose++;
			break;
		case 'n':
			env->vmd_noaction = 1;
			break;
		case 'P':
			title = optarg;
			proc_id = proc_getid(procs, nitems(procs), title);
			if (proc_id == PROC_MAX)
				fatalx("invalid process name");
			break;
		case 'I':
			proc_instance = strtonum(optarg, 0,
			    PROC_MAX_INSTANCES, &errp);
			if (errp)
				fatalx("invalid process instance");
			break;
		default:
			usage();
		}
	}

	argc -= optind;
	if (argc > 0)
		usage();

	if (env->vmd_noaction && !env->vmd_debug)
		env->vmd_debug = 1;

	/* check for root privileges */
	if (env->vmd_noaction == 0) {
		if (geteuid())
			fatalx("need root privileges");
	}

	ps = &env->vmd_ps;
	ps->ps_env = env;
	env->vmd_fd = -1;

	if (config_init(env) == -1)
		fatal("failed to initialize configuration");

	if ((ps->ps_pw = getpwnam(VMD_USER)) == NULL)
		fatal("unknown user %s", VMD_USER);

	/* First proc runs as root without pledge but in default chroot */
	proc_priv->p_pw = &proc_privpw; /* initialized to all 0 */
	proc_priv->p_chroot = ps->ps_pw->pw_dir; /* from VMD_USER */

	/* Open /dev/vmm */
	if (env->vmd_noaction == 0) {
		env->vmd_fd = open(VMM_NODE, O_RDWR);
		if (env->vmd_fd == -1)
			fatal("%s", VMM_NODE);
	}

	/* Configure the control socket */
	ps->ps_csock.cs_name = SOCKET_NAME;
	TAILQ_INIT(&ps->ps_rcsocks);

	/* Configuration will be parsed after forking the children */
	env->vmd_conffile = conffile;

	log_init(env->vmd_debug, LOG_DAEMON);
	log_setverbose(env->vmd_verbose);

	if (env->vmd_noaction)
		ps->ps_noaction = 1;
	ps->ps_instance = proc_instance;
	if (title != NULL)
		ps->ps_title[proc_id] = title;

	/* only the parent returns */
	proc_init(ps, procs, nitems(procs), argc0, argv, proc_id);

	log_procinit("parent");
	if (!env->vmd_debug && daemon(0, 0) == -1)
		fatal("can't daemonize");

	if (ps->ps_noaction == 0)
		log_info("startup");

	event_init();

	signal_set(&ps->ps_evsigint, SIGINT, vmd_sighdlr, ps);
	signal_set(&ps->ps_evsigterm, SIGTERM, vmd_sighdlr, ps);
	signal_set(&ps->ps_evsighup, SIGHUP, vmd_sighdlr, ps);
	signal_set(&ps->ps_evsigpipe, SIGPIPE, vmd_sighdlr, ps);
	signal_set(&ps->ps_evsigusr1, SIGUSR1, vmd_sighdlr, ps);

	signal_add(&ps->ps_evsigint, NULL);
	signal_add(&ps->ps_evsigterm, NULL);
	signal_add(&ps->ps_evsighup, NULL);
	signal_add(&ps->ps_evsigpipe, NULL);
	signal_add(&ps->ps_evsigusr1, NULL);

	if (!env->vmd_noaction)
		proc_connect(ps);

	if (vmd_configure() == -1)
		fatalx("configuration failed");

	event_dispatch();

	log_debug("parent exiting");

	return (0);
}

int
vmd_configure(void)
{
	struct vmd_vm		*vm;
	struct vmd_switch	*vsw;

	if ((env->vmd_ptmfd = open(PATH_PTMDEV, O_RDWR|O_CLOEXEC)) == -1)
		fatal("open %s", PATH_PTMDEV);

	/*
	 * pledge in the parent process:
	 * stdio - for malloc and basic I/O including events.
	 * rpath - for reload to open and read the configuration files.
	 * wpath - for opening disk images and tap devices.
	 * tty - for openpty.
	 * proc - run kill to terminate its children safely.
	 * sendfd - for disks, interfaces and other fds.
	 * recvfd - for send and receive.
	 * getpw - lookup user or group id by name.
	 * chown, fattr - change tty ownership
	 */
	if (pledge("stdio rpath wpath proc tty recvfd sendfd getpw"
	    " chown fattr", NULL) == -1)
		fatal("pledge");

	if (parse_config(env->vmd_conffile) == -1) {
		proc_kill(&env->vmd_ps);
		exit(1);
	}

	if (env->vmd_noaction) {
		fprintf(stderr, "configuration OK\n");
		proc_kill(&env->vmd_ps);
		exit(0);
	}

	TAILQ_FOREACH(vsw, env->vmd_switches, sw_entry) {
		if (vsw->sw_running)
			continue;
		if (vm_priv_brconfig(&env->vmd_ps, vsw) == -1) {
			log_warn("%s: failed to create switch %s",
			    __func__, vsw->sw_name);
			switch_remove(vsw);
			return (-1);
		}
	}

	TAILQ_FOREACH(vm, env->vmd_vms, vm_entry) {
		if (vm->vm_disabled) {
			log_debug("%s: not creating vm %s (disabled)",
			    __func__,
			    vm->vm_params.vmc_params.vcp_name);
			continue;
		}
		if (config_setvm(&env->vmd_ps, vm, -1, 0) == -1)
			return (-1);
	}

	/* Send shared global configuration to all children */
	if (config_setconfig(env) == -1)
		return (-1);

	return (0);
}

int
vmd_reload(unsigned int reset, const char *filename)
{
	struct vmd_vm		*vm, *next_vm;
	struct vmd_switch	*vsw;
	int			 reload = 0;

	/* Switch back to the default config file */
	if (filename == NULL || *filename == '\0') {
		filename = env->vmd_conffile;
		reload = 1;
	}

	log_debug("%s: level %d config file %s", __func__, reset, filename);

	if (reset) {
		/* Purge the configuration */
		config_purge(env, reset);
		config_setreset(env, reset);
	} else {
		/*
		 * Load or reload the configuration.
		 *
		 * Reloading removes all non-running VMs before processing the
		 * config file, whereas loading only adds to the existing list
		 * of VMs.
		 */

		if (reload) {
			TAILQ_FOREACH_SAFE(vm, env->vmd_vms, vm_entry, next_vm) {
				if (vm->vm_running == 0)
					vm_remove(vm);
			}

			/* Update shared global configuration in all children */
			if (config_setconfig(env) == -1)
				return (-1);
		}

		if (parse_config(filename) == -1) {
			log_debug("%s: failed to load config file %s",
			    __func__, filename);
			return (-1);
		}

		TAILQ_FOREACH(vsw, env->vmd_switches, sw_entry) {
			if (vsw->sw_running)
				continue;
			if (vm_priv_brconfig(&env->vmd_ps, vsw) == -1) {
				log_warn("%s: failed to create switch %s",
				    __func__, vsw->sw_name);
				switch_remove(vsw);
				return (-1);
			}
		}

		TAILQ_FOREACH(vm, env->vmd_vms, vm_entry) {
			if (vm->vm_running == 0) {
				if (vm->vm_disabled) {
					log_debug("%s: not creating vm %s"
					    " (disabled)", __func__,
					    vm->vm_params.vmc_params.vcp_name);
					continue;
				}
				if (config_setvm(&env->vmd_ps, vm, -1, 0) == -1)
					return (-1);
			} else {
				log_debug("%s: not creating vm \"%s\": "
				    "(running)", __func__,
				    vm->vm_params.vmc_params.vcp_name);
			}
		}
	}

	return (0);
}

void
vmd_shutdown(void)
{
	struct vmd_vm *vm, *vm_next;

	TAILQ_FOREACH_SAFE(vm, env->vmd_vms, vm_entry, vm_next) {
		vm_remove(vm);
	}

	proc_kill(&env->vmd_ps);
	free(env);

	log_warnx("parent terminating");
	exit(0);
}

struct vmd_vm *
vm_getbyvmid(uint32_t vmid)
{
	struct vmd_vm	*vm;

	if (vmid == 0)
		return (NULL);
	TAILQ_FOREACH(vm, env->vmd_vms, vm_entry) {
		if (vm->vm_vmid == vmid)
			return (vm);
	}

	return (NULL);
}

struct vmd_vm *
vm_getbyid(uint32_t id)
{
	struct vmd_vm	*vm;

	if (id == 0)
		return (NULL);
	TAILQ_FOREACH(vm, env->vmd_vms, vm_entry) {
		if (vm->vm_params.vmc_params.vcp_id == id)
			return (vm);
	}

	return (NULL);
}

uint32_t
vm_id2vmid(uint32_t id, struct vmd_vm *vm)
{
	if (vm == NULL && (vm = vm_getbyid(id)) == NULL)
		return (0);
	dprintf("%s: vmm id %u is vmid %u", __func__,
	    id, vm->vm_vmid);
	return (vm->vm_vmid);
}

uint32_t
vm_vmid2id(uint32_t vmid, struct vmd_vm *vm)
{
	if (vm == NULL && (vm = vm_getbyvmid(vmid)) == NULL)
		return (0);
	dprintf("%s: vmid %u is vmm id %u", __func__,
	    vmid, vm->vm_params.vmc_params.vcp_id);
	return (vm->vm_params.vmc_params.vcp_id);
}

struct vmd_vm *
vm_getbyname(const char *name)
{
	struct vmd_vm	*vm;

	if (name == NULL)
		return (NULL);
	TAILQ_FOREACH(vm, env->vmd_vms, vm_entry) {
		if (strcmp(vm->vm_params.vmc_params.vcp_name, name) == 0)
			return (vm);
	}

	return (NULL);
}

struct vmd_vm *
vm_getbypid(pid_t pid)
{
	struct vmd_vm	*vm;

	TAILQ_FOREACH(vm, env->vmd_vms, vm_entry) {
		if (vm->vm_pid == pid)
			return (vm);
	}

	return (NULL);
}

void
vm_stop(struct vmd_vm *vm, int keeptty)
{
	unsigned int	 i;

	if (vm == NULL)
		return;

	vm->vm_running = 0;
	vm->vm_shutdown = 0;

	if (vm->vm_iev.ibuf.fd != -1) {
		event_del(&vm->vm_iev.ev);
		close(vm->vm_iev.ibuf.fd);
	}
	for (i = 0; i < VMM_MAX_DISKS_PER_VM; i++) {
		if (vm->vm_disks[i] != -1) {
			close(vm->vm_disks[i]);
			vm->vm_disks[i] = -1;
		}
	}
	for (i = 0; i < VMM_MAX_NICS_PER_VM; i++) {
		if (vm->vm_ifs[i].vif_fd != -1) {
			close(vm->vm_ifs[i].vif_fd);
			vm->vm_ifs[i].vif_fd = -1;
		}
		free(vm->vm_ifs[i].vif_name);
		free(vm->vm_ifs[i].vif_switch);
		free(vm->vm_ifs[i].vif_group);
		vm->vm_ifs[i].vif_name = NULL;
		vm->vm_ifs[i].vif_switch = NULL;
		vm->vm_ifs[i].vif_group = NULL;
	}
	if (vm->vm_kernel != -1) {
		close(vm->vm_kernel);
		vm->vm_kernel = -1;
	}
	vm->vm_uid = 0;
	if (!keeptty)
		vm_closetty(vm);
}

void
vm_remove(struct vmd_vm *vm)
{
	if (vm == NULL)
		return;

	TAILQ_REMOVE(env->vmd_vms, vm, vm_entry);
	vm_stop(vm, 0);
	free(vm);
}

int
vm_register(struct privsep *ps, struct vmop_create_params *vmc,
    struct vmd_vm **ret_vm, uint32_t id, uid_t uid)
{
	struct vmd_vm		*vm = NULL;
	struct vm_create_params	*vcp = &vmc->vmc_params;
	static const uint8_t	 zero_mac[ETHER_ADDR_LEN];
	uint32_t		 rng;
	unsigned int		 i;
	struct vmd_switch	*sw;
	char			*s;

	errno = 0;
	*ret_vm = NULL;

	if ((vm = vm_getbyname(vcp->vcp_name)) != NULL ||
	    (vm = vm_getbyvmid(vcp->vcp_id)) != NULL) {
		if (vm_checkperm(vm, uid) != 0 || vmc->vmc_flags != 0) {
			errno = EPERM;
			goto fail;
		}
		*ret_vm = vm;
		errno = EALREADY;
		goto fail;
	}

	/*
	 * non-root users can only start existing VMs
	 * XXX there could be a mechanism to allow overriding some options
	 */
	if (vm_checkperm(NULL, uid) != 0) {
		errno = EPERM;
		goto fail;
	}
	if (vmc->vmc_flags == 0) {
		errno = ENOENT;
		goto fail;
	}
	if (vcp->vcp_ncpus == 0)
		vcp->vcp_ncpus = 1;
	if (vcp->vcp_memranges[0].vmr_size == 0)
		vcp->vcp_memranges[0].vmr_size = VM_DEFAULT_MEMORY;
	if (vcp->vcp_ncpus > VMM_MAX_VCPUS_PER_VM) {
		log_warnx("invalid number of CPUs");
		goto fail;
	} else if (vcp->vcp_ndisks > VMM_MAX_DISKS_PER_VM) {
		log_warnx("invalid number of disks");
		goto fail;
	} else if (vcp->vcp_nnics > VMM_MAX_NICS_PER_VM) {
		log_warnx("invalid number of interfaces");
		goto fail;
	} else if (strlen(vcp->vcp_kernel) == 0 && vcp->vcp_ndisks == 0) {
		log_warnx("no kernel or disk specified");
		goto fail;
	} else if (strlen(vcp->vcp_name) == 0) {
		log_warnx("invalid VM name");
		goto fail;
	} else if (*vcp->vcp_name == '-' || *vcp->vcp_name == '.' ||
		   *vcp->vcp_name == '_') {
		log_warnx("Invalid VM name");
		goto fail;
	} else {
		for (s = vcp->vcp_name; *s != '\0'; ++s) {
			if (!(isalnum(*s) || *s == '.' || *s == '-' ||
			      *s == '_')) {
				log_warnx("Invalid VM name");
				goto fail;
			}
		}
	}

	if ((vm = calloc(1, sizeof(*vm))) == NULL)
		goto fail;

	memcpy(&vm->vm_params, vmc, sizeof(vm->vm_params));
	vmc = &vm->vm_params;
	vcp = &vmc->vmc_params;
	vm->vm_pid = -1;
	vm->vm_tty = -1;
	vm->vm_receive_fd = -1;
	vm->vm_paused = 0;

	for (i = 0; i < vcp->vcp_ndisks; i++)
		vm->vm_disks[i] = -1;
	for (i = 0; i < vcp->vcp_nnics; i++) {
		vm->vm_ifs[i].vif_fd = -1;

		if ((sw = switch_getbyname(vmc->vmc_ifswitch[i])) != NULL) {
			/* overwrite the rdomain, if configured on the switch */
			if (sw->sw_flags & VMIFF_RDOMAIN)
				vmc->vmc_ifrdomain[i] = sw->sw_rdomain;

			/* inherit per-interface flags from the switch */
			vmc->vmc_ifflags[i] |= (sw->sw_flags & VMIFF_OPTMASK);
		}

		/*
		 * If the MAC address is zero, always randomize it in vmd(8)
		 * because we cannot rely on the guest OS to do the right
		 * thing like OpenBSD does.  Based on ether_fakeaddr()
		 * from the kernel, incremented by one to differentiate
		 * the source.
		 */
		if (memcmp(zero_mac, &vcp->vcp_macs[i], ETHER_ADDR_LEN) == 0) {
			rng = arc4random();
			vcp->vcp_macs[i][0] = 0xfe;
			vcp->vcp_macs[i][1] = 0xe1;
			vcp->vcp_macs[i][2] = 0xba + 1;
			vcp->vcp_macs[i][3] = 0xd0 | ((i + 1) & 0xf);
			vcp->vcp_macs[i][4] = rng;
			vcp->vcp_macs[i][5] = rng >> 8;
		}
	}
	vm->vm_kernel = -1;
	vm->vm_iev.ibuf.fd = -1;

	if (++env->vmd_nvm == 0)
		fatalx("too many vms");

	/* Assign a new internal Id if not specified */
	vm->vm_vmid = id == 0 ? env->vmd_nvm : id;

	TAILQ_INSERT_TAIL(env->vmd_vms, vm, vm_entry);

	*ret_vm = vm;
	return (0);
 fail:
	if (errno == 0)
		errno = EINVAL;
	return (-1);
}

int
vm_checkperm(struct vmd_vm *vm, uid_t uid)
{
	struct group	*gr;
	struct passwd	*pw;
	char		**grmem;

	/* root has no restrictions */
	if (uid == 0)
		return (0);

	if (vm == NULL)
		return (-1);

	/* check supplementary groups */
	if (vm->vm_params.vmc_gid != -1 &&
	    (pw = getpwuid(uid)) != NULL &&
	    (gr = getgrgid(vm->vm_params.vmc_gid)) != NULL) {
		for (grmem = gr->gr_mem; *grmem; grmem++)
			if (strcmp(*grmem, pw->pw_name) == 0)
				return (0);
	}

	/* check user */
	if ((vm->vm_running && vm->vm_uid == uid) ||
	    (!vm->vm_running && vm->vm_params.vmc_uid == uid))
		return (0);

	return (-1);
}

int
vm_opentty(struct vmd_vm *vm)
{
	struct ptmget		 ptm;
	struct stat		 st;
	struct group		*gr;
	uid_t			 uid;
	gid_t			 gid;
	mode_t			 mode;

	/*
	 * Open tty with pre-opened PTM fd
	 */
	if ((ioctl(env->vmd_ptmfd, PTMGET, &ptm) == -1))
		return (-1);

	vm->vm_tty = ptm.cfd;
	close(ptm.sfd);
	if ((vm->vm_ttyname = strdup(ptm.sn)) == NULL)
		goto fail;

	uid = vm->vm_uid;
	gid = vm->vm_params.vmc_gid;

	if (vm->vm_params.vmc_gid != -1) {
		mode = 0660;
	} else if ((gr = getgrnam("tty")) != NULL) {
		gid = gr->gr_gid;
		mode = 0620;
	} else {
		mode = 0600;
		gid = 0;
	}

	log_debug("%s: vm %s tty %s uid %d gid %d mode %o",
	    __func__, vm->vm_params.vmc_params.vcp_name,
	    vm->vm_ttyname, uid, gid, mode);

	/*
	 * Change ownership and mode of the tty as required.
	 * Loosely based on the implementation of sshpty.c
	 */
	if (stat(vm->vm_ttyname, &st) == -1)
		goto fail;

	if (st.st_uid != uid || st.st_gid != gid) {
		if (chown(vm->vm_ttyname, uid, gid) == -1) {
			log_warn("chown %s %d %d failed, uid %d",
			    vm->vm_ttyname, uid, gid, getuid());

			/* Ignore failure on read-only filesystems */
			if (!((errno == EROFS) &&
			    (st.st_uid == uid || st.st_uid == 0)))
				goto fail;
		}
	}

	if ((st.st_mode & (S_IRWXU|S_IRWXG|S_IRWXO)) != mode) {
		if (chmod(vm->vm_ttyname, mode) == -1) {
			log_warn("chmod %s %o failed, uid %d",
			    vm->vm_ttyname, mode, getuid());

			/* Ignore failure on read-only filesystems */
			if (!((errno == EROFS) &&
			    (st.st_uid == uid || st.st_uid == 0)))
				goto fail;
		}
	}

	return (0);
 fail:
	vm_closetty(vm);
	return (-1);
}

void
vm_closetty(struct vmd_vm *vm)
{
	if (vm->vm_tty != -1) {
		/* Release and close the tty */
		if (fchown(vm->vm_tty, 0, 0) == -1)
			log_warn("chown %s 0 0 failed", vm->vm_ttyname);
		if (fchmod(vm->vm_tty, 0666) == -1)
			log_warn("chmod %s 0666 failed", vm->vm_ttyname);
		close(vm->vm_tty);
		vm->vm_tty = -1;
	}
	free(vm->vm_ttyname);
	vm->vm_ttyname = NULL;
}

void
switch_remove(struct vmd_switch *vsw)
{
	struct vmd_if	*vif;

	if (vsw == NULL)
		return;

	TAILQ_REMOVE(env->vmd_switches, vsw, sw_entry);

	while ((vif = TAILQ_FIRST(&vsw->sw_ifs)) != NULL) {
		free(vif->vif_name);
		free(vif->vif_switch);
		TAILQ_REMOVE(&vsw->sw_ifs, vif, vif_entry);
		free(vif);
	}

	free(vsw->sw_group);
	free(vsw->sw_name);
	free(vsw);
}

struct vmd_switch *
switch_getbyname(const char *name)
{
	struct vmd_switch	*vsw;

	if (name == NULL)
		return (NULL);
	TAILQ_FOREACH(vsw, env->vmd_switches, sw_entry) {
		if (strcmp(vsw->sw_name, name) == 0)
			return (vsw);
	}

	return (NULL);
}

char *
get_string(uint8_t *ptr, size_t len)
{
	size_t	 i;

	for (i = 0; i < len; i++)
		if (!isprint(ptr[i]))
			break;

	return strndup(ptr, i);
}

uint32_t
prefixlen2mask(uint8_t prefixlen)
{
	if (prefixlen == 0)
		return (0);

	if (prefixlen > 32)
		prefixlen = 32;

	return (htonl(0xffffffff << (32 - prefixlen)));
}
@


1.67
log
@vmd: fix vm id displayed by vmctl when receiving a vm

Also fix two debug messages and an IMSG type.
@
text
@d1 1
a1 1
/*	$OpenBSD: vmd.c,v 1.66 2017/08/14 17:20:59 jasper Exp $	*/
d42 3
d58 1
d233 1
a233 3
		if (vmh.vmh_version != VM_DUMP_VERSION) {
			log_warnx("%s: incompatible dump version",
			    __func__);
d466 119
@


1.66
log
@validate vm names before creating them; a valid name contains alphanumeric
characters, including '.', '_' and '-'. but does not start with the latter
three.

ok mlarkin@@ pd@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmd.c,v 1.65 2017/08/13 16:45:07 jasper Exp $	*/
d209 1
a209 1
		log_debug("%s: sending fd to vmctl", __func__);
d234 1
a234 1
			cmd = IMSG_VMDOP_SEND_VM_RESPONSE;
d258 1
a258 1
			log_debug("%s: sending fd to vmctl", __func__);
@


1.65
log
@don't issue a termination command to an already stopped vm

ok mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmd.c,v 1.64 2017/07/15 05:05:36 pd Exp $	*/
d948 1
d995 12
@


1.64
log
@Add vmctl send and vmctl receive

ok reyk@@ and mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmd.c,v 1.63 2017/07/09 00:51:40 pd Exp $	*/
d117 4
@


1.63
log
@vmd/vmctl: Add ability to pause / unpause vms

With help from Ashwin Agrawal

ok reyk@@ mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmd.c,v 1.62 2017/05/29 07:15:22 mlarkin Exp $	*/
d43 1
d79 1
d184 76
d377 9
d662 1
d666 1
a666 1
	if (pledge("stdio rpath wpath proc tty sendfd getpw"
d1000 1
@


1.62
log
@vmd(8): prevent crashing when presented with a vm name argument to
"vmctl stop" that doesn't exist.

Diff from Pratik Vyas, thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: vmd.c,v 1.61 2017/05/04 19:41:58 reyk Exp $	*/
d166 16
d219 24
d912 1
@


1.61
log
@Report command failure back to vmctl reload, reset, load, log verbose.

OK mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmd.c,v 1.60 2017/05/04 08:26:06 reyk Exp $	*/
d119 5
a123 2
		} else
			vm = vm_getbyvmid(id);
@


1.60
log
@Add support for rdomains.

This allows to configure VM interfaces and switches in individual rdomains.

OK mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmd.c,v 1.59 2017/04/25 16:38:23 reyk Exp $	*/
d140 4
a143 1
		vmd_reload(0, str);
d149 4
a152 1
		vmd_reload(v, str);
d161 1
d349 1
a349 1
		vmd_reload(0, NULL);
d579 1
a579 1
void
d615 1
a615 1
				return;
d621 1
d631 1
a631 1
				return;
d644 1
a644 1
					return;
d652 2
@


1.59
log
@Generate randomized MAC addresses earlier to keep them across reboots.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmd.c,v 1.58 2017/04/21 07:03:26 reyk Exp $	*/
d866 4
@


1.58
log
@Add global configuration option "local prefix" to change prefix for -L.

The default prefix is 100.64.0.0/10 from RFC6598.

Requested by sthen@@ chris@@
OK mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmd.c,v 1.57 2017/04/19 15:38:32 reyk Exp $	*/
d799 2
d856 1
d868 17
@


1.57
log
@Add support for dynamic "NAT" interfaces (-L/local interface).

When a local interface is configured, vmd configures a /31 address on
the tap(4) interface of the host and provides another IP in the same
subnet via DHCP (BOOTP) to the VM.  vmd runs an internal BOOTP server
that replies with IP, gateway, and DNS addresses to the VM.  The
built-in server only ever responds to the VM on the inside and cannot
leak its DHCP responses to the outside.

Thanks to Uwe Werler, Josh Grosse, and some others for testing!

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmd.c,v 1.56 2017/04/06 18:07:13 reyk Exp $	*/
d565 4
d605 4
@


1.56
log
@Do not expose vmm(4) VM IDs to the user, use vmd(8)'s IDs instead.

Each VM has two IDs: one from the kernel (vmm) and a different one
from userland (vmd).  The vmm ID is not consistent and incremented on
every boot during runtimg of the host system.  The vmd ID remains the
same during the lifetime of a configured VM, even after reboots.
Configured VMs will even get and keep their IDs when the configuration
is loaded.  This is more what users expect.

Pointed out and tested by otto@@

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmd.c,v 1.55 2017/03/15 19:54:52 reyk Exp $	*/
d1047 12
@


1.55
log
@More fixes for starting and stopping VMs, fixing fallout from vm_running.

- Don't start a VM that is already running
- Keep the VM as running until it is powered off (and not stopping)
- Don't fatal in the parent if the vmm process referenced an unknown VM
- Don't stop a VM that is already stopping
- Indicate that a VM is stopping in "vmctl status"

The previous "vmctl stop; vmctl stop" to force-shutdown is not
supported anymore - the shutdown timeout should make sure that the VM
is really terminated.  To force-shutdown, reference the VM by ID.
We might add a flag to vmctl stop to just turn the VM off.
@
text
@d1 1
a1 1
/*	$OpenBSD: vmd.c,v 1.54 2017/03/15 17:53:10 reyk Exp $	*/
d118 1
a118 1
			id = vm->vm_params.vmc_params.vcp_id;
d120 1
a120 1
			vm = vm_getbyid(id);
d236 1
a236 1
		    vcp->vcp_name, vcp->vcp_id, vm->vm_ttyname);
d242 1
a242 1
		if ((vm = vm_getbyid(vmr.vmr_id)) == NULL)
d252 1
a252 1
		if ((vm = vm_getbyid(vmr.vmr_id)) == NULL)
d268 1
a268 1
		if ((vm = vm_getbyid(vir.vir_info.vir_id)) != NULL) {
d298 1
a298 1
				vir.vir_info.vir_id = 0;
d659 2
d674 2
d684 20
d797 2
a798 1
	if ((vm = vm_getbyname(vcp->vcp_name)) != NULL) {
d835 3
@


1.54
log
@Close the tty if the VM was powered down.

The parent keeps a copy of each VM's tty fd to reuse it on reboot.
Close this tty if the VM was stopped, and not rebooted, by calling
vm_stop(vm, 0) instead of just setting vm_running to 0.  Also make
sure that vm_ttyname is not used after free'ing it.
@
text
@d1 1
a1 1
/*	$OpenBSD: vmd.c,v 1.53 2017/03/02 07:33:37 reyk Exp $	*/
d89 2
a90 1
			if (!(ret == -1 && errno == EALREADY)) {
d113 4
d197 1
a197 1
			fatalx("%s: invalid vm response", __func__);
a207 1
			vmr.vmr_result = res;
d245 2
a246 4
			if (vm->vm_from_config)
				vm_stop(vm, 0);
			else
				vm_remove(vm);
d273 6
d717 1
@


1.53
log
@Add "locked lladdr" option to prevent VMs from spoofing MAC addresses.

This is especially useful when multiple VMs share a switch, the
implementation is independent from the underlying switch or bridge.

no objections mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmd.c,v 1.52 2017/03/01 07:43:33 reyk Exp $	*/
d238 2
a240 1
			vm = vm_getbyid(vmr.vmr_id);
d242 1
a242 1
				vm->vm_running = 0;
d254 1
a254 1
				vm->vm_running = 0;
d267 4
a270 2
			(void)strlcpy(vir.vir_ttyname, vm->vm_ttyname,
			    sizeof(vir.vir_ttyname));
@


1.52
log
@Add "owner" option to set a user/group ownership for pre-configured VMs

This allows matching users to start or stop VMs that they "own" and to
access the console accordingly.

OK mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmd.c,v 1.51 2017/02/27 14:37:58 reyk Exp $	*/
d756 1
d805 1
d811 1
a811 1
	for (i = 0; i < vcp->vcp_nnics; i++)
d813 6
@


1.51
log
@Replace openpty(3) with local function that uses pre-opened /dev/ptm fd

This allows more flexibility for upcoming changes and better pledge.
We also didn't use half of the features of libutil's openpty function.
Additionally, make sure that the ttys are closed correctly on shutdown.

OK gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmd.c,v 1.50 2017/01/13 19:21:16 edd Exp $	*/
d23 1
d39 2
d86 1
a86 1
		ret = vm_register(ps, &vmc, &vm, 0);
d98 1
a98 1
		    config_setvm(ps, vm, imsg->hdr.peerid) == -1) {
d114 6
d259 1
a259 1
			config_setvm(ps, vm, (uint32_t)-1);
d268 3
d295 3
d514 2
d517 2
a518 1
	if (pledge("stdio rpath wpath proc tty sendfd", NULL) == -1)
d550 1
a550 1
		if (config_setvm(&env->vmd_ps, vm, -1) == -1)
d616 1
a616 1
				if (config_setvm(&env->vmd_ps, vm, -1) == -1)
d733 1
d751 1
a751 1
    struct vmd_vm **ret_vm, uint32_t id)
d761 4
d770 8
d831 31
d865 5
d882 48
d940 5
@


1.50
log
@Make it possible to remove VMs from vmd(8)'s internal queue.

The semantics agreed with reyk@@ are:

 * ad-hoc created vms, created  with `vmctl start`, are removed once stopped.
 * Stopped VMs defined in a config file are flushed before a `vmctl reload`.

OK reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmd.c,v 1.49 2017/01/11 22:38:10 reyk Exp $	*/
d23 2
a37 1
#include <util.h>
d488 3
d612 6
d715 2
a716 10

	if (keeptty)
		return;

	if (vm->vm_tty != -1) {
		close(vm->vm_tty);
		vm->vm_tty = -1;
	}
	free(vm->vm_ttyname);
	vm->vm_ttyname = NULL;
d774 1
d793 1
a793 1
fail:
d797 33
@


1.49
log
@Add imsg communication channel between vmd and invividual VMs.
For now, this is only used to forward "log verbose|brief" requests,
but it will be used for better things later.

OK mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmd.c,v 1.48 2017/01/09 14:49:22 reyk Exp $	*/
a228 1
			/* Remove local reference */
d230 4
a233 1
			vm_remove(vm);
d242 4
a245 2
			/* Remove local reference */
			vm_remove(vm);
d538 1
a538 1
	struct vmd_vm		*vm;
d540 1
d543 1
a543 1
	if (filename == NULL || *filename == '\0')
d545 2
d555 15
a569 1
		/* Reload the configuration */
@


1.48
log
@Stop accessing verbose and debug variables from log.c directly.

This replaces log_verbose() and "extern int verbose" with the two functions
log_setverbose() and log_getverbose().

Pointed out by benno@@
OK krw@@ eric@@ gilles@@ (OK gilles@@ for the snmpd bits as well)
@
text
@d1 1
a1 1
/*	$OpenBSD: vmd.c,v 1.47 2016/12/14 21:17:25 reyk Exp $	*/
d68 1
a68 1
	int				 res = 0, ret = 0, cmd = 0;
d133 8
d658 4
d757 1
@


1.47
log
@Allow to start disabled and pre-configured VMs by name, "vmctl start foo".

With testing from Jon Bernard

OK mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmd.c,v 1.46 2016/12/14 06:59:12 reyk Exp $	*/
d424 1
a424 1
	log_verbose(env->vmd_verbose);
@


1.46
log
@If a VM terminates with the result EAGAIN, close all fds except the
pty and re-send it to the vmm monitor process.  With additional
changes in vmm.c, this will allow perform a cold reboot of VM.

With testing and feedback from Jon Bernard
OK mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmd.c,v 1.45 2016/11/26 20:03:42 reyk Exp $	*/
d68 1
a68 1
	int				 res = 0, cmd = 0;
d82 12
a93 1
		if (vm_register(ps, &vmc, &vm, 0) == -1 ||
d712 4
@


1.45
log
@Implement basic support for boot.conf(8) on the disk image.

Like the real boot loader, load and parse hd0a:/etc/boot.conf from the
first disk and fall back to /bsd.  Not all boot loader options are
supported, but it at least does set device, set image, and boot -acds
(eg. for booting single-user).

For example, it can now boot install60.fs that includes a boot.conf
with "set image /6.0/amd64/bsd.rd":
	vmctl start install -c -d install60.fs -d OpenBSD.img

This pseudo-bootloader is only needed without BIOS and could
potentially be replaced in the future.

OK mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmd.c,v 1.44 2016/11/26 19:49:11 reyk Exp $	*/
d206 9
d218 2
a219 2
		if (imsg->hdr.type == IMSG_VMDOP_TERMINATE_VM_RESPONSE)
			proc_forward_imsg(ps, imsg, PROC_CONTROL, -1);
a221 1
			vm = vm_getbyid(vmr.vmr_id);
d223 4
d630 1
a630 1
vm_remove(struct vmd_vm *vm)
d637 1
a637 1
	TAILQ_REMOVE(env->vmd_vms, vm, vm_entry);
d640 1
a640 1
		if (vm->vm_disks[i] != -1)
d642 2
d646 1
a646 1
		if (vm->vm_ifs[i].vif_fd != -1)
d648 2
d653 3
d657 1
a657 1
	if (vm->vm_kernel != -1)
d659 7
a665 1
	if (vm->vm_tty != -1)
d667 5
d673 8
a680 1
	free(vm->vm_ttyname);
@


1.44
log
@If -m/memory is not specified, use 512M by default.

Default value picked with mlarkin - not too small and not too large.

OK mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmd.c,v 1.43 2016/11/24 07:58:55 reyk Exp $	*/
d202 2
a203 5
		log_info("%s: started vm %d successfully, "
		    "kernel %s, tty %s", vcp->vcp_name, vcp->vcp_id,
		    strlen(vcp->vcp_kernel) ?
		    vcp->vcp_kernel : "hd0a:" VM_DEFAULT_KERNEL,
		    vm->vm_ttyname);
@


1.43
log
@Add support for booting the kernel from the disk image.

This make the kernel/-k argument optional and, if not specified, tries
to find the /bsd kernel in the primary hd0a partition of the first
disk image itself.  It doesn't support hd0a:/etc/boot.conf yet, and it
is no BIOS or full boot loader, but it makes booting and handling of
VMs a bit easier - booting an external kernel is still supported.

The UFS file system code ufs.c is directly from libsa which is also
used by the real boot loader.  The code compiles with a few signedness
warning which will be fixed separately.

OK mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmd.c,v 1.42 2016/11/22 21:55:54 reyk Exp $	*/
d669 2
@


1.42
log
@Fix error path of config_setvm() and its callers.  This unbreaks
loading of invalid kernel files.

Reported by mlarkin@@
OK mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmd.c,v 1.41 2016/11/22 12:55:33 reyk Exp $	*/
d202 5
a206 2
		log_info("%s: started vm %d successfully, tty %s",
		    vcp->vcp_name, vcp->vcp_id, vm->vm_ttyname);
d670 1
a670 1
		log_debug("invalid number of CPUs");
d673 1
a673 1
		log_debug("invalid number of disks");
d676 4
a679 1
		log_debug("invalid number of interfaces");
@


1.41
log
@There is no need for res when there is already ret.
@
text
@d1 1
a1 1
/*	$OpenBSD: vmd.c,v 1.40 2016/11/22 11:31:38 edd Exp $	*/
d82 2
a83 2
		res = vm_register(ps, &vmc, &vm, 0);
		if (res == -1) {
a85 7
		} else {
			res = config_setvm(ps, vm, imsg->hdr.peerid);
			if (res == -1) {
				res = errno;
				cmd = IMSG_VMDOP_START_VM_RESPONSE;
				vm_remove(vm);
			}
a450 1
	int			 ret = 0;
d482 1
d493 2
a494 7
		if ((ret = config_setvm(&env->vmd_ps, vm, -1)) == -1) {
			log_warn("%s: failed to create vm %s",
			    __func__,
			    vm->vm_params.vmc_params.vcp_name);
			vm_remove(vm);
			goto fail;
		}
d497 1
a497 2
 fail:
	return (ret);
a504 1
	int		 	 res;
d530 1
d542 2
a543 7
				res = config_setvm(&env->vmd_ps, vm, -1);
				if (res == -1) {
					log_warn("%s: failed to create vm %s",
					    __func__,
					    vm->vm_params.vmc_params.vcp_name);
					vm_remove(vm);
				}
@


1.40
log
@Insert disabled VMs into vmd(8)'s queues and allow vmctl(8) to display them.

Tested by Jon Bernard and reyk@@.

OK reyk@@, no objections mlarkin@@.

Thanks
@
text
@d1 1
a1 1
/*	$OpenBSD: vmd.c,v 1.39 2016/11/04 15:16:44 reyk Exp $	*/
d458 1
a458 1
	int		 	 res, ret = 0;
d500 1
a500 2
		res = config_setvm(&env->vmd_ps, vm, -1);
		if (res == -1) {
a503 1
			ret = -1;
d508 1
@


1.39
log
@Pass the internal vmid or 0 to vm_register() instead of changing it
once again after setting the next available id.

Suggested by edd@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmd.c,v 1.38 2016/11/04 15:07:26 reyk Exp $	*/
d238 25
d494 6
d550 6
@


1.38
log
@Update the config/register/get VM methods to match the config_set/get
style that is used in other places.  Also keep the vmid from the parent.

OK edd@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmd.c,v 1.37 2016/10/29 14:56:05 edd Exp $	*/
d82 1
a82 1
		res = vm_register(ps, &vmc, &vm);
d631 1
a631 1
    struct vmd_vm **ret_vm)
d671 1
a671 1
	if ((vm->vm_vmid = ++env->vmd_nvm) == 0)
d673 3
@


1.37
log
@Separate parsing vms and switches from starting them in vmd(8).

Brings us one step closer to having disabled by default vms is vm.conf(5),
which can be started with vmctl(8).

Input, testing and OK reyk@@. Thanks.
@
text
@d1 1
a1 1
/*	$OpenBSD: vmd.c,v 1.36 2016/10/17 16:26:20 reyk Exp $	*/
d27 1
d36 1
d82 1
a82 1
		res = config_registervm(ps, &vmc, &vm);
d87 1
a87 1
			res = config_getvm(ps, vm, -1, imsg->hdr.peerid);
d469 1
a469 1
		res = config_getvm(&env->vmd_ps, vm, -1, -1);
d519 1
a519 1
				res = config_getvm(&env->vmd_ps, vm, -1, -1);
d627 55
@


1.36
log
@Add the option to specify an interface group per virtual switch as well;
this group will be added to all VM tap(4) interfaces in the switch.

Tested by martijn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmd.c,v 1.35 2016/10/15 14:02:11 reyk Exp $	*/
d80 1
a80 1
		res = config_getvm(ps, &vmc, -1, imsg->hdr.peerid);
d84 7
d103 1
a103 1
			id = vm->vm_params.vcp_id;
d170 1
a170 1
		vcp = &vm->vm_params;
d429 4
d456 23
a478 1
	return (0);
d484 4
d504 26
d562 1
a562 1
		if (vm->vm_params.vcp_id == id)
d577 1
a577 1
		if (strcmp(vm->vm_params.vcp_name, name) == 0)
@


1.35
log
@Allow to add an interface to an interface group; with the group keyword.

Requested and tested by martijn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmd.c,v 1.34 2016/10/12 19:10:03 reyk Exp $	*/
d581 1
@


1.34
log
@Fix functionality and semantics of vmctl load/reload/reset.

OK rzalamena@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmd.c,v 1.33 2016/10/06 18:48:41 reyk Exp $	*/
d553 1
@


1.33
log
@Terminate VMs on shutdown of vmd instead of leaving them running as
undead VM processes.

OK mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmd.c,v 1.32 2016/10/05 17:30:13 reyk Exp $	*/
d66 2
a67 1
	int				 res = 0, cmd = 0, v = 0;
d107 4
d112 6
a117 5
		v = 1;
	case IMSG_VMDOP_LOAD:
		if (IMSG_DATA_SIZE(imsg) > 0)
			str = get_string((uint8_t *)imsg->data,
			    IMSG_DATA_SIZE(imsg));
a118 1
		free(str);
d253 1
a253 1
		vmd_reload(1, NULL);
d449 1
a449 1
vmd_reload(int reset, const char *filename)
d457 10
a466 6
	if (reset)
		config_setreset(env, CONFIG_ALL);

	if (parse_config(filename) == -1) {
		log_debug("%s: failed to load config file %s",
		    __func__, filename);
@


1.32
log
@Add support for enhanced networking configuration and virtual switches.
See vm.conf(5) for more details.

OK mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmd.c,v 1.31 2016/10/04 17:17:30 reyk Exp $	*/
d55 1
a55 2
	{ "vmm",	PROC_VMM,	vmd_dispatch_vmm, vmm },

@


1.31
log
@Add a new "priv" process that is responsible for ioctls and restricted
operations that aren't allowed under pledge.  This is a companion to
the "vmd" process that runs as root but with pledge.

With the "priv" process, each new tap(4) interface now gets a
description to indicate the vm, eg. "vm1-if0-myvm".  For network
configuration will be done by vmd/priv later.

OK mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmd.c,v 1.30 2016/09/29 22:42:04 reyk Exp $	*/
d68 1
a68 1
	struct vm_create_params		 vcp;
d78 3
a80 3
		IMSG_SIZE_CHECK(imsg, &vcp);
		memcpy(&vcp, imsg->data, sizeof(vcp));
		res = config_getvm(ps, &vcp, -1, imsg->hdr.peerid);
d503 2
d541 4
a544 3
		if (vm->vm_ifs[i] != -1)
			close(vm->vm_ifs[i]);
		free(vm->vm_ifnames[i]);
d553 36
@


1.30
log
@Implement fork+exec for vmd, using the same framework from httpd etc.

No objections from mlarkin@@ sunil@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmd.c,v 1.29 2016/08/17 05:07:13 deraadt Exp $	*/
d52 2
d56 1
d59 4
d186 8
a193 3
		} else {
			log_info("%s: started vm %d successfully, tty %s",
			    vcp->vcp_name, vcp->vcp_id, vm->vm_ttyname);
d195 3
d214 1
a214 1
		if ((vm = vm_getbyid(vir.vir_info.vir_id)) != NULL)
d217 1
d343 1
d351 3
a353 3
	/* Configure the control socket */
	ps->ps_csock.cs_name = SOCKET_NAME;
	TAILQ_INIT(&ps->ps_rcsocks);
d362 4
d541 1
d548 1
@


1.29
log
@small bits of header cleanup; ok mlarkin
@
text
@d1 1
a1 1
/*	$OpenBSD: vmd.c,v 1.28 2016/07/29 16:36:51 stefan Exp $	*/
a221 6
	struct privsep	*ps = arg;
	int		 die = 0, status, fail, id;
	pid_t		 pid;
	char		*cause;
	const char	*title = "vm";

d243 1
a243 43
		die = 1;
		/* FALLTHROUGH */
	case SIGCHLD:
		do {
			int len;

			pid = waitpid(-1, &status, WNOHANG);
			if (pid <= 0)
				continue;

			fail = 0;
			if (WIFSIGNALED(status)) {
				fail = 1;
				len = asprintf(&cause, "terminated; signal %d",
				    WTERMSIG(status));
			} else if (WIFEXITED(status)) {
				if (WEXITSTATUS(status) != 0) {
					fail = 1;
					len = asprintf(&cause,
					    "exited abnormally");
				} else
					len = asprintf(&cause, "exited okay");
			} else
				fatalx("unexpected cause of SIGCHLD");

			if (len == -1)
				fatal("asprintf");

			for (id = 0; id < PROC_MAX; id++) {
				if (pid == ps->ps_pid[id]) {
					die = 1;
					title = ps->ps_title[id];
					break;
				}
			}
			if (fail)
				log_warnx("lost child: %s %s", title, cause);

			free(cause);
		} while (pid > 0 || (pid == -1 && errno == EINTR));

		if (die)
			vmd_shutdown();
d262 7
a268 3
	struct privsep	*ps;
	int		 ch;
	const char	*conffile = VMD_CONF;
d276 1
a276 1
	while ((ch = getopt(argc, argv, "D:df:vn")) != -1) {
d295 12
d312 4
d351 10
d364 2
a365 6
	log_procinit("parent");

	ps->ps_ninstances = 1;

	if (!env->vmd_noaction)
		proc_init(ps, procs, nitems(procs));
a370 1
	signal_set(&ps->ps_evsigchld, SIGCHLD, vmd_sighdlr, ps);
a376 1
	signal_add(&ps->ps_evsigchld, NULL);
d382 1
a382 1
		proc_listen(ps, procs, nitems(procs));
@


1.28
log
@Allow starting a VM again after it was terminated

If a VM exits, terminate it and remove it from the list of
available VMs. That allows a VM with name `foo' to be restarted
after it has exited.

This changes structures shared between vmd and vmctl. You need to
rebuild vmctl also.

ok mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmd.c,v 1.27 2016/02/05 11:40:15 reyk Exp $	*/
d19 1
a19 1
#include <sys/param.h>
@


1.27
log
@Fix a possible use-after-free in vmd, forward the result to the
control socket before free'ing the vm.

Found by and OK jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmd.c,v 1.26 2016/02/02 17:51:11 sthen Exp $	*/
d151 1
d185 1
d188 2
a189 1
		proc_forward_imsg(ps, imsg, PROC_CONTROL, -1);
d508 13
@


1.26
log
@Remove setproctitle() for the parent process. Because rc.d(8) uses process
titles (including flags) to distinguish between daemons, this makes it
possible to manage multiple copies of a daemon using the normal infrastructure
by symlinking rc.d scripts to a new name. ok jung@@ ajacoutot@@, smtpd ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmd.c,v 1.25 2015/12/11 10:16:53 reyk Exp $	*/
d152 22
a178 1
			vcp->vcp_id = vmr.vmr_id;
a180 14
		}
		/*
		 * If the peerid is -1, the request originated from
		 * the parent, not the control socket.
		 */
		if (vm->vm_peerid == (uint32_t)-1)
			break;
		vmr.vmr_result = res;
		(void)strlcpy(vmr.vmr_ttyname, vm->vm_ttyname,
		    sizeof(vmr.vmr_ttyname));
		if (proc_compose_imsg(ps, PROC_CONTROL, -1, imsg->hdr.type,
		    vm->vm_peerid, -1, &vmr, sizeof(vmr)) == -1) {
			vm_remove(vm);
			return (-1);
@


1.25
log
@The vmctl "id" argument can now be a number of or a vm name, eg.
vmctl stop 3
vmctl stop "openbsd.vm"
@
text
@d1 1
a1 1
/*	$OpenBSD: vmd.c,v 1.24 2015/12/08 23:59:39 jsg Exp $	*/
a371 1
	setproctitle("parent");
@


1.24
log
@when checking the config file with -n don't open /dev/vmm or require root
ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmd.c,v 1.23 2015/12/08 23:47:59 jsg Exp $	*/
d59 9
a67 4
	struct privsep		*ps = p->p_ps;
	int			 res = 0, cmd = 0, v = 0;
	struct vm_create_params	 vcp;
	char			*str = NULL;
d80 17
d113 18
a130 4
	if (cmd &&
	    proc_compose_imsg(ps, PROC_CONTROL, -1, cmd, imsg->hdr.peerid, -1,
	    &res, sizeof(res)) == -1)
		return (-1);
@


1.23
log
@make the -f option work as intended
ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmd.c,v 1.22 2015/12/07 12:52:00 reyk Exp $	*/
d302 4
a305 2
	if (geteuid())
		fatalx("need root privileges");
d321 5
a325 3
	env->vmd_fd = open(VMM_NODE, O_RDWR);
	if (env->vmd_fd == -1)
		fatal("%s", VMM_NODE);
@


1.22
log
@tweak initial error logging
@
text
@d1 1
a1 1
/*	$OpenBSD: vmd.c,v 1.21 2015/12/06 21:02:51 reyk Exp $	*/
d324 1
a324 1
	env->vmd_conffile = VMD_CONF;
@


1.21
log
@Prevent running a VM with the same name multiple times - multiple
instances of the same configuration will be handled in a different way
later.  It is also not a good idea to use the same writeable disk
with multiple VMs at the same time.

As discussed with mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmd.c,v 1.20 2015/12/06 02:26:14 reyk Exp $	*/
d268 3
a299 3

	/* log to stderr until daemonized */
	log_init(env->vmd_debug ? env->vmd_debug : 1, LOG_DAEMON);
@


1.20
log
@Print the TTY in the vmctl status output.
@
text
@d1 1
a1 1
/*	$OpenBSD: vmd.c,v 1.19 2015/12/06 01:58:21 reyk Exp $	*/
d446 13
@


1.19
log
@When a new vm is created with VMM_IOC_CREATE, the kernel assigns a
unique id to it.  This happens in the vm child process and has to be
communicated to the parent processes to track the vm.  Knowing the vm
id in the parent and vmm processes also allows to remove vm from the
daemons list on terminate requests later.
@
text
@d1 1
a1 1
/*	$OpenBSD: vmd.c,v 1.18 2015/12/06 01:16:22 reyk Exp $	*/
d107 1
d132 1
a132 1
		strlcpy(vmr.vmr_ttyname, vm->vm_ttyname,
d134 1
a134 2
		if (proc_compose_imsg(ps, PROC_CONTROL, -1,
		    IMSG_VMDOP_START_VM_RESPONSE,
d142 1
d151 11
@


1.18
log
@Check errno from config_getvm() correctly
@
text
@d1 1
a1 1
/*	$OpenBSD: vmd.c,v 1.17 2015/12/05 20:33:51 reyk Exp $	*/
d102 1
a102 1
	struct vmop_start_result vmr;
d106 1
d110 2
a111 2
		IMSG_SIZE_CHECK(imsg, &res);
		memcpy(&res, imsg->data, sizeof(res));
d114 5
a118 4
		if (res) {
			errno = res;
			log_warn("%s: failed to start vm",
			    vm->vm_params.vcp_name);
d120 3
a122 2
			log_info("%s: started vm successfully, tty %s",
			    vm->vm_params.vcp_name, vm->vm_ttyname);
d135 2
a136 1
		    vm->vm_peerid, -1, &vmr, sizeof(vmr)) == -1)
d138 1
d141 1
a141 1
		IMSG_SIZE_CHECK(imsg, &res);
d143 5
a147 1
		break;
d421 13
@


1.17
log
@Print shorter error message if opening /dev/vmm failed.

Pointed out by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmd.c,v 1.16 2015/12/03 23:32:32 reyk Exp $	*/
d70 1
a70 1
			res = EINVAL;
@


1.16
log
@Re-add the "load" and "reload" commands to vmctl: Instead of parsing
the configuration in vmctl directly, it now sends a (re)load request
to vmd.  The reload also resets the existing configuration status -
this doesn't do much difference yet but a future change will compare
if a specified VM is already running.  "load" will allow to add
configuration, while "reload" resets the state before loading.
@
text
@d1 1
a1 1
/*	$OpenBSD: vmd.c,v 1.15 2015/12/03 16:18:13 reyk Exp $	*/
d300 1
a300 1
		fatal("can't open vmm device node %s", VMM_NODE);
@


1.15
log
@Add and document -D and -f flags to vmd.
@
text
@d1 1
a1 1
/*	$OpenBSD: vmd.c,v 1.14 2015/12/03 16:13:04 reyk Exp $	*/
d34 1
d60 1
a60 1
	int			 res = 0, cmd = 0;
d62 1
d78 9
d166 7
a172 1
		log_info("%s: ignoring SIGHUP", __func__);
d378 18
d442 12
@


1.14
log
@mlarkin's code has been moved to vmm.c, so it is ok to claim the copyright.
@
text
@d1 1
a1 1
/*	$OpenBSD: vmd.c,v 1.13 2015/12/03 16:11:32 reyk Exp $	*/
d218 2
a219 1
	fprintf(stderr, "usage: %s [-dv]\n", __progname);
d233 1
a233 1
	while ((ch = getopt(argc, argv, "df:vn")) != -1) {
d235 5
@


1.13
log
@Add support for an optional vm.conf(5) file in vmd.  This will replace
vmm.conf(5) in vmmctl.  For a short time, both vmd and vmmctl will
support a configuration file, but vmmctl will be changed to send
"load" requests to vmd instead of loading and parsing the file
directly.
@
text
@d1 1
a1 1
/*	$OpenBSD: vmd.c,v 1.12 2015/12/03 13:27:14 reyk Exp $	*/
d4 1
a4 1
 * Copyright (c) 2015 Mike Larkin <mlarkin@@openbsd.org>
@


1.12
log
@prepare config_getvm() for parse.y
@
text
@d1 1
a1 1
/*	$OpenBSD: vmd.c,v 1.11 2015/12/02 23:33:43 reyk Exp $	*/
d102 14
d227 1
d232 1
a232 1
	while ((ch = getopt(argc, argv, "dvn")) != -1) {
d237 3
d251 6
d279 5
a283 2
	/* log to stderr until daemonized */
	log_init(env->vmd_debug ? env->vmd_debug : 1, LOG_DAEMON);
d292 3
a294 1
	proc_init(ps, procs, nitems(procs));
d312 2
a313 1
	proc_listen(ps, procs, nitems(procs));
a327 13
#if 0
	if (parse_config(env->sc_conffile, env) == -1) {
		proc_kill(&env->sc_ps);
		exit(1);
	}
#endif

	if (env->vmd_noaction) {
		fprintf(stderr, "configuration OK\n");
		proc_kill(&env->vmd_ps);
		exit(0);
	}

d339 11
@


1.11
log
@send the tty name to vmmctl and print it as a result.
@
text
@d1 1
a1 1
/*	$OpenBSD: vmd.c,v 1.10 2015/12/02 22:19:11 reyk Exp $	*/
d58 3
a60 2
	struct privsep	*ps = p->p_ps;
	int		 res = 0, cmd = 0;
d64 3
a66 1
		res = config_getvm(ps, imsg);
@


1.10
log
@Split the fully privileged parent into two processes "parent" and
"vmm" with reduced privileges:
- the "parent" opens fds (disks, ifs, etc.) but runs as root but pledged as
  "stdio rpath wpath proc tty sendfd".
- the "vmm" process handles the creation and supervision of vm processes,
  and the primary communication with the vmm(4) subsystem.  It runs as _vmd
  in the chroot but does not use pledge, as the vmm ioctls are not allowed
  by any pledge model yet.
With this change, vmd starts to track the configuration state of VMs
in vmd and will allow other things later (like terminating a vm by
name, moving the configuration parser to vmd, ...).  More incremental
changes will follow.
@
text
@d1 1
a1 1
/*	$OpenBSD: vmd.c,v 1.9 2015/12/02 09:14:25 reyk Exp $	*/
d26 1
d88 4
a91 3
	struct privsep	*ps = p->p_ps;
	int		 res = 0;
	struct vmd_vm	*vm;
d96 1
d99 7
a105 2
		imsg->hdr.peerid = vm->vm_peerid;
		proc_forward_imsg(ps, imsg, PROC_CONTROL, -1);
@


1.9
log
@Start tweaking vmd's privsep and daemon model by splitting the main
process into multiple parts and adopting the "proc.c"-style from other
daemons.  This allows to further reduce the privileges, to give better
pledge(2), and to add some upcoming changes.

"please do" mlarkin@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmd.c,v 1.8 2015/11/26 08:26:48 reyk Exp $	*/
d44 2
d50 2
a51 1
	{ "control",	PROC_CONTROL,	vmm_dispatch_control, control },
d54 62
d125 3
a225 2
	SLIST_INIT(&env->vmd_vmstate);

a227 1
	TAILQ_INIT(&ps->ps_rcsocks);
d229 4
a232 1
	if ((ps->ps_pw =  getpwnam(VMD_USER)) == NULL)
d237 1
d250 3
a255 3
	setproctitle("parent");
	log_procinit("parent");

d300 12
d323 39
@


1.8
log
@Automatically start vmm(4) when the first VM is created and after the
last VM is terminated.  This allows to remove the explicit "vmm
enable" / "vmm disable" (VMM_IOC_START / VMM_IOC_STOP) ioctls.  You'll
have to update kernel and userland for this change, as the kernel ABI
changes.

OK mpi@@ mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmd.c,v 1.7 2015/11/25 22:44:21 tedu Exp $	*/
d19 1
a19 6
/*
 * vmd(8) - virtual machine daemon
 */

#include <sys/types.h>
#include <sys/ioctl.h>
a20 4
#include <sys/uio.h>
#include <sys/socket.h>
#include <sys/stat.h>
#include <sys/un.h>
d22 1
a22 10
#include <sys/mman.h>
#include <sys/time.h>

#include <dev/ic/comreg.h>
#include <dev/ic/i8253reg.h>
#include <dev/isa/isareg.h>
#include <dev/pci/pcireg.h>

#include <machine/param.h>
#include <machine/vmmvar.h>
d24 2
d27 1
a28 3
#include <imsg.h>
#include <limits.h>
#include <pthread.h>
a30 4
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
a31 1
#include <termios.h>
a32 2
#include <poll.h>
#include <util.h>
d34 1
a35 3
#include "loadfile.h"
#include "pci.h"
#include "virtio.h"
d37 1
a37 1
#define NR_BACKLOG 5
d39 5
a43 14
#define MAX_TAP 256

/*
 * Emulated 8250 UART
 *
 */
#define COM1_DATA	0x3f8
#define COM1_IER	0x3f9
#define COM1_IIR	0x3fa
#define COM1_LCR	0x3fb
#define COM1_MCR	0x3fc
#define COM1_LSR	0x3fd
#define COM1_MSR	0x3fe
#define COM1_SCR	0x3ff
d45 1
a45 16
/*
 * Emulated i8253 PIT (counter)
 */
#define TIMER_BASE	0x40
#define TIMER_CTRL	0x43	/* 8253 Timer #1 */
#define NS_PER_TICK (1000000000 / TIMER_FREQ)

/* i8253 registers */
struct i8253_counter {
	struct timeval tv;	/* timer start time */
	uint16_t start;		/* starting value */
	uint16_t olatch;	/* output latch */
	uint16_t ilatch;	/* input latch */
	uint8_t last_r;		/* last read byte (MSB/LSB) */
	uint8_t last_w;		/* last written byte (MSB/LSB) */
};
d47 2
a48 13
/* ns8250 UART registers */
struct ns8250_regs {
	uint8_t lcr;		/* Line Control Register */
	uint8_t fcr;		/* FIFO Control Register */
	uint8_t iir;		/* Interrupt ID Register */
	uint8_t ier;		/* Interrupt Enable Register */
	uint8_t divlo;		/* Baud rate divisor low byte */
	uint8_t divhi;		/* Baud rate divisor high byte */
	uint8_t msr;		/* Modem Status Register */
	uint8_t lsr;		/* Line Status Register */
	uint8_t mcr;		/* Modem Control Register */
	uint8_t scr;		/* Scratch Register */
	uint8_t data;		/* Unread input data */
a50 47
struct i8253_counter i8253_counter[3];
struct ns8250_regs com1_regs;

__dead void usage(void);

void sighdlr(int);
int main(int, char **);
int control_run(void);
int start_vm(struct imsg *);
int terminate_vm(struct imsg *);
int get_info_vm(struct imsgbuf *);
int start_client_vmd(void);
int opentap(void);
int run_vm(int *, int *, struct vm_create_params *);
void *vcpu_run_loop(void *);
int vcpu_exit(struct vm_run_params *);
int vmm_create_vm(struct vm_create_params *);
void init_emulated_hw(struct vm_create_params *, int *, int *);
void vcpu_exit_inout(struct vm_run_params *);
uint8_t vcpu_exit_pci(struct vm_run_params *);
void vcpu_exit_i8253(union vm_exit *);
void vcpu_exit_com(struct vm_run_params *);
void vcpu_process_com_data(union vm_exit *);
void vcpu_process_com_lcr(union vm_exit *);
void vcpu_process_com_lsr(union vm_exit *);
void vcpu_process_com_ier(union vm_exit *);
void vcpu_process_com_mcr(union vm_exit *);
void vcpu_process_com_iir(union vm_exit *);
void vcpu_process_com_msr(union vm_exit *);
void vcpu_process_com_scr(union vm_exit *);

int vmm_fd, con_fd, vm_id;
volatile sig_atomic_t quit;

SLIST_HEAD(vmstate_head, vmstate);
struct vmstate_head vmstate;

extern char *__progname;

/*
 * sighdlr
 *
 * Signal handler for TERM/INT/CHLD signals used during daemon shutdown
 *
 * Parameters:
 *  sig: signal caught
 */
d52 1
a52 1
sighdlr(int sig)
d54 5
a58 1
	pid_t pid;
d61 9
d72 2
a73 3
		/* Tell main imsg loop to exit */
		quit = 1;
		break;
d76 39
a114 2
			pid = waitpid(WAIT_ANY, NULL, WNOHANG);
		} while (pid != -1 || (pid == -1 && errno == EINTR));
d116 2
d132 5
a136 1
	int debug = 0, verbose = 0, c, res;
d138 2
a139 2
	while ((c = getopt(argc, argv, "dv")) != -1) {
		switch (c) {
d141 1
a141 1
			debug = 2;
d144 4
a147 1
			verbose++;
d154 5
a158 2
	/* log to stderr until daemonized */
	log_init(debug ? debug : 1, LOG_DAEMON);
d160 3
a162 4
	/* Open /dev/vmm */
	vmm_fd = open(VMM_NODE, O_RDONLY);
	if (vmm_fd == -1)
		fatal("can't open vmm device node %s", VMM_NODE);
d164 2
a165 1
	setproctitle("control");
d167 2
a168 1
	SLIST_INIT(&vmstate);
d170 4
a173 3
	signal(SIGTERM, sighdlr);
	signal(SIGINT, sighdlr);
	signal(SIGCHLD, sighdlr);
d175 2
a176 3
	log_init(debug, LOG_DAEMON);
	log_verbose(verbose);
	log_procinit("control");
d178 1
a178 1
	if (!debug && daemon(1, 0) == -1)
d181 2
a182 219
	res = control_run();

	if (res == -1)
		fatalx("control socket error");

	return (0);
}

/*
 * control_run
 *
 * Main control loop - establishes listening socket for incoming vmmctl(8)
 * requests and dispatches appropriate calls to vmm(4). Replies to
 * vmmctl(8) using imsg.
 *
 * Return values:
 *  0: normal exit (signal to quit received)
 *  -1: abnormal exit (various causes)
 */
int
control_run(void)
{
	struct sockaddr_un sun, c_sun;
	socklen_t len;
	int fd, connfd, n, res, nfd;
	mode_t mode, old_umask;
	char *socketpath;
	struct imsgbuf *ibuf;
	struct imsg imsg;
	struct pollfd pfd[1];

	/* Establish and start listening on control socket */
	socketpath = SOCKET_NAME;
	if ((fd = socket(AF_UNIX, SOCK_STREAM | SOCK_CLOEXEC, 0)) == -1) {
		log_warn("%s: socket error", __progname);
		return (-1);
	}

	bzero(&sun, sizeof(sun));
	sun.sun_family = AF_UNIX;
	if (strlcpy(sun.sun_path, socketpath, sizeof(sun.sun_path)) >=
	    sizeof(sun.sun_path)) {
		log_warnx("%s: socket name too long", __progname);
		close(fd);
		return (-1);
	}

	if (unlink(socketpath) == -1)
		if (errno != ENOENT) {
			log_warn("%s: unlink of %s failed",
			    __progname, socketpath);
			close(fd);
			return (-1);
		}

	old_umask = umask(S_IXUSR|S_IXGRP|S_IWOTH|S_IROTH|S_IXOTH);
	mode = S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP;

	if (bind(fd, (struct sockaddr *)&sun, sizeof(sun)) == -1) {
		log_warn("%s: control_init: bind of %s failed",
		    __progname, socketpath);
		close(fd);
		umask(old_umask);
		return (-1);
	}

	umask(old_umask);

	if (chmod(socketpath, mode) == -1) {
		log_warn("%s: control_init: chmod of %s failed",
		    __progname, socketpath);
		close(fd);
		unlink(socketpath);
		return (-1);
	}

	if ((ibuf = malloc(sizeof(struct imsgbuf))) == NULL) {
		log_warn("%s: out of memory", __progname);
		close(fd);
		unlink(socketpath);
		return (-1);
	}

	if (listen(fd, NR_BACKLOG) == -1) {
		log_warn("%s: listen failed", __progname);
		close(fd);
		unlink(socketpath);
		return (-1);
	}

	while (!quit) {
		pfd[0].fd = fd;
		pfd[0].events = POLLIN;

		nfd = poll(pfd, 1, INFTIM);
		if (nfd == -1) {
			if (errno == EINTR)
				continue;
			fatal("poll");
		}
		if (nfd == 0)
			continue;
		if ((pfd[0].revents & (POLLERR|POLLNVAL)))
			fatalx("bad fd %d", fd);
		if ((pfd[0].revents & (POLLIN|POLLHUP)) == 0)
			fatalx("bad fd %d events", fd);

		if ((connfd = accept4(fd, (struct sockaddr *)&c_sun, &len,
		    SOCK_CLOEXEC)) == -1) {
			log_warn("%s: accept4 error", __progname);
			close(fd);
			unlink(socketpath);
			return (-1);
		}
			
		imsg_init(ibuf, connfd);
		if ((n = imsg_read(ibuf)) == -1 || n == 0) {
			log_warnx("%s: imsg_read error, n=%d",
			    __progname, n);
			continue;
		}

		for (;;) {
			if ((n = imsg_get(ibuf, &imsg)) == -1)
				return (-1);

			if (n == 0)
				break;

			/* Process incoming message (from vmmctl(8)) */
			switch (imsg.hdr.type) {
			case IMSG_VMDOP_START_VM_REQUEST:
				res = start_vm(&imsg);
				imsg_compose(ibuf,
				    IMSG_VMDOP_START_VM_RESPONSE, 0, 0, -1,
				    &res, sizeof(res));
				break;
			case IMSG_VMDOP_TERMINATE_VM_REQUEST:
				res = terminate_vm(&imsg);
				imsg_compose(ibuf,
				    IMSG_VMDOP_TERMINATE_VM_RESPONSE, 0, 0, -1,
				    &res, sizeof(res));
				break;
			case IMSG_VMDOP_GET_INFO_VM_REQUEST:
				res = get_info_vm(ibuf);
				imsg_compose(ibuf,
				    IMSG_VMDOP_GET_INFO_VM_END_DATA, 0, 0, -1,
				    &res, sizeof(res));
				break;
			}

			while (ibuf->w.queued)
				if (msgbuf_write(&ibuf->w) <= 0 && errno !=
				    EAGAIN) {
					log_warn("%s: msgbuf_write error",
					    __progname);
					close(fd);
					close(connfd);
					unlink(socketpath);
					return (-1);
				}
			imsg_free(&imsg);
		}
		close(connfd);
	}

	signal(SIGCHLD, SIG_IGN);

	return (0);
}

/*
 * terminate_vm
 *
 * Requests vmm(4) to terminate the VM whose ID is provided in the
 * supplied vm_terminate_params structure (vtp->vtp_vm_id)
 *
 * Parameters
 *  imsg: The incoming imsg body whose 'data' field contains the 
 *      vm_terminate_params struct
 *
 * Return values:
 *  0: success
 *  !0 : ioctl to vmm(4) failed (eg, ENOENT if the supplied VM is not
 *      valid)
 */
int
terminate_vm(struct imsg *imsg)
{
	struct vm_terminate_params *vtp;

	vtp = (struct vm_terminate_params *)imsg->data;

	if (ioctl(vmm_fd, VMM_IOC_TERM, vtp) < 0)
                return (errno);

	return (0);
}

/*
 * opentap
 *
 * Opens the next available tap device, up to MAX_TAP.
 *
 * Returns a file descriptor to the tap node opened, or -1 if no tap
 * devices were available.
 */
int
opentap(void)
{
	int i, fd;
	char path[PATH_MAX];
	
	for (i = 0; i < MAX_TAP; i++) {
		snprintf(path, PATH_MAX, "/dev/tap%d", i);
		fd = open(path, O_RDWR | O_NONBLOCK);
		if (fd != -1)
			return (fd);
	}
d184 2
a185 2
	return (-1);
}
d187 1
a187 63
/*
 * start_vm
 *
 * Starts a new VM with the creation parameters supplied (in the incoming
 * imsg->data field). This function performs a basic sanity check on the
 * incoming parameters and then performs the following steps to complete
 * the creation of the VM:
 *
 * 1. opens the VM disk image files specified in the VM creation parameters
 * 2. opens the specified VM kernel
 * 3. creates a VM console tty pair using openpty
 * 4. forks, passing the file descriptors opened in steps 1-3 to the child
 *     vmd responsible for dropping privilege and running the VM's VCPU
 *     loops.
 *
 * Parameters:
 *  imsg: The incoming imsg body whose 'data' field is a vm_create_params
 *      struct containing the VM creation parameters.
 *
 * Return values:
 *  0: success
 *  !0 : failure - typically an errno indicating the source of the failure
 */
int
start_vm(struct imsg *imsg)
{
	struct vm_create_params *vcp;
	size_t i;
	off_t kernel_size;
	struct stat sb;
	int child_disks[VMM_MAX_DISKS_PER_VM], kernel_fd, ret, ttym_fd;
	int child_taps[VMM_MAX_NICS_PER_VM];
	int ttys_fd;
	char ptyn[32];

	vcp = (struct vm_create_params *)imsg->data;

	for (i = 0 ; i < VMM_MAX_DISKS_PER_VM; i++)
		child_disks[i] = -1;
	for (i = 0 ; i < VMM_MAX_NICS_PER_VM; i++)
		child_taps[i] = -1;

	/*
	 * XXX kernel_fd can't be global (possible race if multiple VMs
	 * being created at the same time). Probably need to move this
	 * into the child before dropping privs, or just make it local
	 * to this function?
	 */
	kernel_fd = -1;

	ttym_fd = -1;
	ttys_fd = -1;

	/* Open disk images for child */
	for (i = 0 ; i < vcp->vcp_ndisks; i++) {
		child_disks[i] = open(vcp->vcp_disks[i], O_RDWR);
		if (child_disks[i] == -1) {
			ret = errno;
			log_warn("%s: can't open %s", __progname,
			    vcp->vcp_disks[i]);
			goto err;
		}
	}
d189 6
a194 7
	bzero(&sb, sizeof(sb));
	if (stat(vcp->vcp_kernel, &sb) == -1) {
		ret = errno;
		log_warn("%s: can't stat kernel image %s",
		    __progname, vcp->vcp_kernel);
		goto err;
	}
d196 6
a201 1
	kernel_size = sb.st_size;
d203 1
a203 8
	/* Open kernel image */
	kernel_fd = open(vcp->vcp_kernel, O_RDONLY);
	if (kernel_fd == -1) {
		ret = errno;
		log_warn("%s: can't open kernel image %s",
		    __progname, vcp->vcp_kernel);
		goto err;	
	}
d205 2
a206 5
	if (openpty(&ttym_fd, &ttys_fd, ptyn, NULL, NULL) == -1) {
		ret = errno;
		log_warn("%s: openpty failed", __progname);
		goto err;
	}
d208 1
a208 5
	if (close(ttys_fd)) {
		ret = errno;
		log_warn("%s: close tty failed", __progname);
		goto err;
	}
d210 1
a210 139
	/* Open tap devices for child */
	for (i = 0 ; i < vcp->vcp_nnics; i++) {
		child_taps[i] = opentap();
		if (child_taps[i] == -1) {
			ret = errno;
			log_warn("%s: can't open tap for nic %zd",
			    __progname, i);
			goto err;
		}
	}

	/* Start child vmd for this VM (fork, chroot, drop privs) */
	ret = start_client_vmd();

	/* Start child failed? - cleanup and leave */
	if (ret == -1) {
		ret = EIO;
		goto err;
	}

	if (ret > 0) {
		/* Parent */
		for (i = 0 ; i < vcp->vcp_ndisks; i++)
			close(child_disks[i]);

		for (i = 0 ; i < vcp->vcp_nnics; i++)
			close(child_taps[i]);

		close(kernel_fd);
		close(ttym_fd);

		return (0);
	}	
	else {
		/* Child */
		setproctitle(vcp->vcp_name);
		log_procinit(vcp->vcp_name);

		log_info("%s: vm console: %s", __progname, ptyn);
		ret = vmm_create_vm(vcp);
		if (ret) {
			errno = ret;
			fatal("create vmm ioctl failed - exiting");
		}

		/* Load kernel image */
		ret = loadelf_main(kernel_fd, vcp->vcp_id, vcp->vcp_memory_size);
		if (ret) {
			errno = ret;
			fatal("failed to load kernel - exiting");
		}

		close(kernel_fd);

		con_fd = ttym_fd;
		if (fcntl(con_fd, F_SETFL, O_NONBLOCK) == -1)		
			fatal("failed to set nonblocking mode on console");

		/* Execute the vcpu run loop(s) for this VM */
		ret = run_vm(child_disks, child_taps, vcp);
		_exit(ret != 0);
	}
	
	return (ret);

err:
	for (i = 0 ; i < vcp->vcp_ndisks; i++)
		if (child_disks[i] != -1) 
			close(child_disks[i]);

	for (i = 0 ; i < vcp->vcp_nnics; i++)
		if (child_taps[i] != -1)
			close(child_taps[i]);

	if (kernel_fd != -1)
		close(kernel_fd);

	if (ttym_fd != -1)
		close(ttym_fd);

	return (ret);
}

/*
 * get_info_vm
 *
 * Returns a list of VMs known to vmm(4).
 *
 * Parameters:
 *  ibuf: the imsg ibuf in which to place the results. A new imsg will
 *      be created using this ibuf.
 *
 * Return values:
 *  0: success
 *  !0 : failure (eg, ENOMEM, EIO or another error code from vmm(4) ioctl)
 */
int
get_info_vm(struct imsgbuf *ibuf)
{
	int ret;
	size_t ct, i;
	struct ibuf *obuf;
	struct vm_info_params vip;
	struct vm_info_result *info;

	/*
	 * We issue the VMM_IOC_INFO ioctl twice, once with an input
	 * buffer size of 0, which results in vmm(4) returning the
	 * number of bytes required back to us in vip.vip_size,
	 * and then we call it again after malloc'ing the required
	 * number of bytes.
	 *
	 * It is possible that we could fail a second time (eg, if
	 * another VM was created in the instant between the two
	 * ioctls, but in that case the caller can just try again
	 * as vmm(4) will return a zero-sized list in that case.
	 */
	vip.vip_size = 0;
	info = NULL;
	ret = 0;

	/* First ioctl to see how many bytes needed (vip.vip_size) */
	if (ioctl(vmm_fd, VMM_IOC_INFO, &vip) < 0)
		return (errno);

	if (vip.vip_info_ct != 0)
		return (EIO);

	info = malloc(vip.vip_size);
	if (info == NULL)
		return (ENOMEM);

	/* Second ioctl to get the actual list */
	vip.vip_info = info;
	if (ioctl(vmm_fd, VMM_IOC_INFO, &vip) < 0) {
		ret = errno;
		free(info);
		return (ret);
	}
a211 9
	/* Return info to vmmctl(4) */
	ct = vip.vip_size / sizeof(struct vm_info_result);
	for (i = 0; i < ct; i++) {
		obuf = imsg_create(ibuf, IMSG_VMDOP_GET_INFO_VM_DATA, 0, 0,
		    sizeof(struct vm_info_result));
		imsg_add(obuf, &info[i], sizeof(struct vm_info_result));
		imsg_close(ibuf, obuf);
	}
	free(info);
a214 14

/*
 * start_client_vmd
 *
 * forks a copy of the parent vmd, chroots to VMD_USER's home, drops
 * privileges (changes to user VMD_USER), and returns.
 * Should the fork operation succeed, but later chroot/privsep
 * fail, the child exits.
 *
 * Return values (returns to both child and parent on success):
 *  -1 : failure
 *  0: return to child vmd returns 0
 *  !0 : return to parent vmd returns the child's pid
 */
d216 1
a216 1
start_client_vmd(void)
d218 4
a221 7
	int child_pid;
	struct passwd *pw;

	pw = getpwnam(VMD_USER);
	if (pw == NULL) {
		log_warnx("%s: no such user %s", __progname, VMD_USER);
		return (-1);
d223 1
d225 4
a228 19
	child_pid = fork();
	if (child_pid < 0)
		return (-1);

	if (!child_pid) {
		/* Child */
		if (chroot(pw->pw_dir) != 0)
			fatal("unable to chroot");
		if (chdir("/") != 0)
			fatal("unable to chdir");

		if (setgroups(1, &pw->pw_gid) == -1)
			fatal("setgroups() failed");
		if (setresgid(pw->pw_gid, pw->pw_gid, pw->pw_gid) == -1)
			fatal("setresgid() failed");
		if (setresuid(pw->pw_uid, pw->pw_uid, pw->pw_uid) == -1)
			fatal("setresuid() failed");

		return (0);
a230 35
	/* Parent */
	return (child_pid);
}

/*
 * vmm_create_vm
 *
 * Requests vmm(4) to create a new VM using the supplied creation
 * parameters. This operation results in the creation of the in-kernel
 * structures for the VM, but does not start the VM's vcpu(s).
 *
 * Parameters:
 *  vcp: vm_create_params struct containing the VM's desired creation
 *      configuration
 *
 * Return values:
 *  0: success
 *  !0 : ioctl to vmm(4) failed
 */
int
vmm_create_vm(struct vm_create_params *vcp)
{
	/* Sanity check arguments */
	if (vcp->vcp_ncpus > VMM_MAX_VCPUS_PER_VM)
		return (EINVAL);

	if (vcp->vcp_memory_size > VMM_MAX_VM_MEM_SIZE)
		return (EINVAL);

	if (vcp->vcp_ndisks > VMM_MAX_DISKS_PER_VM)
		return (EINVAL);

	if (ioctl(vmm_fd, VMM_IOC_CREATE, vcp) < 0)
		return (errno);

a233 5
/*
 * init_emulated_hw
 *
 * Initializes the userspace hardware emulation
 */
d235 1
a235 2
init_emulated_hw(struct vm_create_params *vcp, int *child_disks,
    int *child_taps)
d237 2
a238 109
	/* Init the i8253 PIT's 3 counters */
	bzero(&i8253_counter, sizeof(struct i8253_counter) * 3);
	gettimeofday(&i8253_counter[0].tv, NULL);
	gettimeofday(&i8253_counter[1].tv, NULL);
	gettimeofday(&i8253_counter[2].tv, NULL);
	i8253_counter[0].start = TIMER_DIV(100);
	i8253_counter[1].start = TIMER_DIV(100);
	i8253_counter[2].start = TIMER_DIV(100);

	/* Init ns8250 UART */
	bzero(&com1_regs, sizeof(struct ns8250_regs));

	/* Initialize PCI */
	pci_init();

	/* Initialize virtio devices */
	virtio_init(vcp, child_disks, child_taps);
}

/*
 * run_vm
 *
 * Runs the VM whose creation parameters are specified in vcp
 *
 * Parameters:
 *  vcp: vm_create_params struct containing the VM's desired creation
 *      configuration
 *  child_disks: previously-opened child VM disk file file descriptors
 *  child_taps: previously-opened child tap file descriptors
 *
 * Return values:
 *  0: the VM exited normally
 *  !0 : the VM exited abnormally or failed to start
 */
int
run_vm(int *child_disks, int *child_taps, struct vm_create_params *vcp)
{
	size_t i;
	int ret;
	pthread_t *tid;
	void *exit_status;
	struct vm_run_params **vrp;

	ret = 0;

	/* XXX cap vcp_ncpus to avoid overflow here */
	/*
	 * XXX ensure nvcpus in vcp is same as vm, or fix vmm to return einval
	 * on bad vcpu id
	 */
	tid = malloc(sizeof(pthread_t) * vcp->vcp_ncpus);
	vrp = malloc(sizeof(struct vm_run_params *) * vcp->vcp_ncpus);
	if (tid == NULL || vrp == NULL) {
		log_warn("%s: memory allocation error - exiting.",
		    __progname);
		return (ENOMEM);
	}

	init_emulated_hw(vcp, child_disks, child_taps);

	/*
	 * Create and launch one thread for each VCPU. These threads may
	 * migrate between PCPUs over time; the need to reload CPU state
	 * in such situations is detected and performed by vmm(4) in the
	 * kernel.
	 */
	for (i = 0 ; i < vcp->vcp_ncpus; i++) {
		vrp[i] = malloc(sizeof(struct vm_run_params));
		if (vrp[i] == NULL) {
			log_warn("%s: memory allocation error - "
			    "exiting.", __progname);
			/* caller will exit, so skip free'ing */
			return (ENOMEM);
		}
		vrp[i]->vrp_exit = malloc(sizeof(union vm_exit));
		if (vrp[i]->vrp_exit == NULL) {
			log_warn("%s: memory allocation error - "
			    "exiting.", __progname);
			/* caller will exit, so skip free'ing */
			return (ENOMEM);
		}
		vrp[i]->vrp_vm_id = vcp->vcp_id;
		vrp[i]->vrp_vcpu_id = i;

		/* Start each VCPU run thread at vcpu_run_loop */
		ret = pthread_create(&tid[i], NULL, vcpu_run_loop, vrp[i]);
		if (ret) {
			/* caller will _exit after this return */
			return (ret);
		}
	}

	/* Wait for all the threads to exit */
	for (i = 0; i < vcp->vcp_ncpus; i++) {
		if (pthread_join(tid[i], &exit_status)) {
			log_warn("%s: failed to join thread %zd - "
			    "exiting", __progname, i);
			return (EIO);
		}

		if (exit_status != NULL) {
			log_warnx("%s: vm %d vcpu run thread %zd exited "
			    "abnormally", __progname, vcp->vcp_id, i);
			ret = EIO;
		}
	}

	return (ret);
}
d240 2
a241 737
/*
 * vcpu_run_loop
 *
 * Runs a single VCPU until vmm(4) requires help handling an exit,
 * or the VM terminates.
 *
 * Parameters:
 *  arg: vcpu_run_params for the VCPU being run by this thread
 *
 * Return values:
 *  NULL: the VCPU shutdown properly
 *  !NULL: error processing VCPU run, or the VCPU shutdown abnormally
 */
void *
vcpu_run_loop(void *arg)
{
	struct vm_run_params *vrp = (struct vm_run_params *)arg;
	intptr_t ret;

	vrp->vrp_continue = 0;
	vrp->vrp_injint = -1;

	for (;;) {
		if (ioctl(vmm_fd, VMM_IOC_RUN, vrp) < 0) {
			/* If run ioctl failed, exit */
			ret = errno;
			return ((void *)ret);
		}

		/* If the VM is terminating, exit normally */
		if (vrp->vrp_exit_reason == VM_EXIT_TERMINATED)
			return (NULL);

		if (vrp->vrp_exit_reason != VM_EXIT_NONE) {
			/*
			 * vmm(4) needs help handling an exit, handle in
			 * vcpu_exit.
			 */
			if (vcpu_exit(vrp))
				return ((void *)EIO);
		}
	}

	return (NULL);
}

/*
 * vcpu_exit_i8253
 *
 * Handles emulated i8253 PIT access (in/out instruction to PIT ports).
 * We don't emulate all the modes of the i8253, just the basic squarewave
 * clock.
 *
 * Parameters:
 *  vei: VM exit information from vmm(4) containing information on the in/out
 *      instruction being performed
 */
void
vcpu_exit_i8253(union vm_exit *vei)
{
	uint32_t out_data;
	uint8_t sel, rw, data;
	uint64_t ns, ticks;
	struct timeval now, delta;

	if (vei->vei.vei_port == TIMER_CTRL) {
		if (vei->vei.vei_dir == 0) { /* OUT instruction */
			out_data = vei->vei.vei_data;
			sel = out_data &
			    (TIMER_SEL0 | TIMER_SEL1 | TIMER_SEL2);
			sel = sel >> 6;
			if (sel > 2) {
				log_warnx("%s: i8253 PIT: invalid "
				    "timer selected (%d)",
				    __progname, sel);
				return;
			}
			
			rw = vei->vei.vei_data &
			    (TIMER_LATCH | TIMER_LSB |
			    TIMER_MSB | TIMER_16BIT);

			if (rw == TIMER_16BIT) {
				/*
				 * XXX this seems to be used on occasion, needs
				 * to be implemented
				 */
				log_warnx("%s: i8253 PIT: 16 bit "
				    "counter I/O not supported",
				    __progname);
				    return;
			}

			/*
			 * Since we don't truly emulate each tick of the PIT
			 * clock, when the guest asks for the timer to be
			 * latched, simulate what the counter would have been
			 * had we performed full emulation. We do this by
			 * calculating when the counter was reset vs how much
			 * time has elapsed, then bias by the counter tick
			 * rate.
			 */
			if (rw == TIMER_LATCH) {
				gettimeofday(&now, NULL);
				delta.tv_sec = now.tv_sec -
				    i8253_counter[sel].tv.tv_sec;
				delta.tv_usec = now.tv_usec -
				    i8253_counter[sel].tv.tv_usec;
				if (delta.tv_usec < 0) { 
					delta.tv_sec--;
					delta.tv_usec += 1000000;
				}
				if (delta.tv_usec > 1000000) {
					delta.tv_sec++;
					delta.tv_usec -= 1000000;
				}
				ns = delta.tv_usec * 1000 +
				    delta.tv_sec * 1000000000;
				ticks = ns / NS_PER_TICK;
				i8253_counter[sel].olatch =
				    i8253_counter[sel].start -
				    ticks % i8253_counter[sel].start;
				return;
			}

			log_warnx("%s: i8253 PIT: unsupported rw mode "
			    "%d", __progname, rw);
			return;
		} else {
			/* XXX should this return 0xff? */
			log_warnx("%s: i8253 PIT: read from control "
			    "port unsupported", __progname);
		}
	} else {
		sel = vei->vei.vei_port - (TIMER_CNTR0 + TIMER_BASE);
		if (vei->vei.vei_dir == 0) { /* OUT instruction */
			if (i8253_counter[sel].last_w == 0) {
				out_data = vei->vei.vei_data;
				i8253_counter[sel].ilatch |= (out_data << 8);
				i8253_counter[sel].last_w = 1;
			} else {
				out_data = vei->vei.vei_data;
				i8253_counter[sel].ilatch |= out_data;
				i8253_counter[sel].start =
				    i8253_counter[sel].ilatch;
				i8253_counter[sel].last_w = 0;
			}
		} else {
			if (i8253_counter[sel].last_r == 0) {
				data = i8253_counter[sel].olatch >> 8;
				vei->vei.vei_data = data;
				i8253_counter[sel].last_w = 1;
			} else {
				data = i8253_counter[sel].olatch & 0xFF;
				vei->vei.vei_data = data;
				i8253_counter[sel].last_w = 0;
			}				
		}
	}
}

/*
 * vcpu_process_com_data
 *
 * Emulate in/out instructions to the com1 (ns8250) UART data register
 *
 * Parameters:
 *  vei: vm exit information from vmm(4) containing information on the in/out
 *      instruction being performed
 */
void
vcpu_process_com_data(union vm_exit *vei)
{
	/*
	 * vei_dir == 0 : out instruction
	 *
	 * The guest wrote to the data register. Since we are emulating a
	 * no-fifo chip, write the character immediately to the pty and
	 * assert TXRDY in IIR (if the guest has requested TXRDY interrupt
	 * reporting)
	 */
	if (vei->vei.vei_dir == 0) {
		write(con_fd, &vei->vei.vei_data, 1);
		if (com1_regs.ier & 0x2) {
			/* Set TXRDY */
			com1_regs.iir |= IIR_TXRDY;
			/* Set "interrupt pending" (IIR low bit cleared) */
			com1_regs.iir &= ~0x1;
		}
	} else {
		/*
		 * vei_dir == 1 : in instruction
		 *
		 * The guest read from the data register. Check to see if
		 * there is data available (RXRDY) and if so, consume the
		 * input data and return to the guest. Also clear the
		 * interrupt info register regardless.
		 */
		if (com1_regs.lsr & LSR_RXRDY) {
			vei->vei.vei_data = com1_regs.data;
			com1_regs.data = 0x0;
			com1_regs.lsr &= ~LSR_RXRDY;
		} else {
			/* XXX should this be com1_regs.data or 0xff? */
			vei->vei.vei_data = com1_regs.data;
			log_warnx("guest reading com1 when not ready");
		}

		/* Reading the data register always clears RXRDY from IIR */
		com1_regs.iir &= ~IIR_RXRDY;

		/*
		 * Clear "interrupt pending" by setting IIR low bit to 1
		 * if no interrupt are pending
		 */
		if (com1_regs.iir == 0x0)
			com1_regs.iir = 0x1;
	}
}

/*
 * vcpu_process_com_lcr
 *
 * Emulate in/out instructions to the com1 (ns8250) UART line control register
 *
 * Paramters:
 *  vei: vm exit information from vmm(4) containing information on the in/out
 *      instruction being performed
 */
void
vcpu_process_com_lcr(union vm_exit *vei)
{
	/*
	 * vei_dir == 0 : out instruction
	 *
	 * Write content to line control register
	 */
	if (vei->vei.vei_dir == 0) {
		com1_regs.lcr = (uint8_t)vei->vei.vei_data;
	} else {
		/*
		 * vei_dir == 1 : in instruction
		 *
		 * Read line control register
		 */
		vei->vei.vei_data = com1_regs.lcr;
	}
}

/*
 * vcpu_process_com_iir
 *
 * Emulate in/out instructions to the com1 (ns8250) UART interrupt information
 * register. Note that writes to this register actually are to a different
 * register, the FCR (FIFO control register) that we don't emulate but still
 * consume the data provided.
 *
 * Parameters:
 *  vei: vm exit information from vmm(4) containing information on the in/out
 *      instruction being performed
 */
void
vcpu_process_com_iir(union vm_exit *vei)
{
	/*
	 * vei_dir == 0 : out instruction
	 *
	 * Write to FCR
	 */
	if (vei->vei.vei_dir == 0) {
		com1_regs.fcr = vei->vei.vei_data;
	} else {
		/*
		 * vei_dir == 1 : in instruction
		 *
		 * Read IIR. Reading the IIR resets the TXRDY bit in the IIR
		 * after the data is read.
		 */
		vei->vei.vei_data = com1_regs.iir;
		com1_regs.iir &= ~IIR_TXRDY;

		/*
		 * Clear "interrupt pending" by setting IIR low bit to 1
		 * if no interrupts are pending
		 */
		if (com1_regs.iir == 0x0)
			com1_regs.iir = 0x1;
	}
}

/*
 * vcpu_process_com_mcr
 *
 * Emulate in/out instructions to the com1 (ns8250) UART modem control
 * register.
 *
 * Parameters:
 *  vei: vm exit information from vmm(4) containing information on the in/out
 *      instruction being performed
 */
void
vcpu_process_com_mcr(union vm_exit *vei)
{
	/*
	 * vei_dir == 0 : out instruction
	 *
	 * Write to MCR
	 */
	if (vei->vei.vei_dir == 0) {
		com1_regs.mcr = vei->vei.vei_data;
	} else {
		/*
		 * vei_dir == 1 : in instruction
		 *
		 * Read from MCR
		 */
		vei->vei.vei_data = com1_regs.mcr;
	}
}

/*
 * vcpu_process_com_lsr
 *
 * Emulate in/out instructions to the com1 (ns8250) UART line status register.
 *
 * Parameters:
 *  vei: vm exit information from vmm(4) containing information on the in/out
 *      instruction being performed
 */
void
vcpu_process_com_lsr(union vm_exit *vei)
{
	/*
	 * vei_dir == 0 : out instruction
	 *
	 * Write to LSR. This is an illegal operation, so we just log it and
	 * continue.
	 */
	if (vei->vei.vei_dir == 0) {
		log_warnx("%s: LSR UART write 0x%x unsupported",
		    __progname, vei->vei.vei_data);
	} else {
		/*
		 * vei_dir == 1 : in instruction
		 *
		 * Read from LSR. We always report TXRDY and TSRE since we
		 * can process output characters immediately (at any time).
		 */
		vei->vei.vei_data = com1_regs.lsr | LSR_TSRE | LSR_TXRDY;
	}
}

/*
 * vcpu_process_com_msr
 *
 * Emulate in/out instructions to the com1 (ns8250) UART modem status register.
 *
 * Parameters:
 *  vei: vm exit information from vmm(4) containing information on the in/out
 *      instruction being performed
 */
void
vcpu_process_com_msr(union vm_exit *vei)
{
	/*
	 * vei_dir == 0 : out instruction
	 *
	 * Write to MSR. This is an illegal operation, so we just log it and
	 * continue.
	 */
	if (vei->vei.vei_dir == 0) {
		log_warnx("%s: MSR UART write 0x%x unsupported",
		    __progname, vei->vei.vei_data);
	} else {
		/*
		 * vei_dir == 1 : in instruction
		 *
		 * Read from MSR. We always report DCD, DSR, and CTS.
		 */
		vei->vei.vei_data = com1_regs.lsr | MSR_DCD | MSR_DSR | MSR_CTS;
	}
}

/*
 * vcpu_process_com_scr
 *
 * Emulate in/out instructions to the com1 (ns8250) UART scratch register. The
 * scratch register is sometimes used to distinguish an 8250 from a 16450,
 * and/or used to distinguish submodels of the 8250 (eg 8250A, 8250B). We
 * simulate an "original" 8250 by forcing the scratch register to return data
 * on read that is different from what was written.
 *
 * Parameters:
 *  vei: vm exit information from vmm(4) containing information on the in/out
 *      instruction being performed
 */
void
vcpu_process_com_scr(union vm_exit *vei)
{
	/*
	 * vei_dir == 0 : out instruction
	 *
	 * Write to SCR
	 */
	if (vei->vei.vei_dir == 0) {
		com1_regs.scr = vei->vei.vei_data;
	} else {
		/*
		 * vei_dir == 1 : in instruction
		 *
		 * Read from SCR. To make sure we don't accidentally simulate
		 * a real scratch register, we negate what was written on
		 * subsequent readback.
		 */
		vei->vei.vei_data = ~com1_regs.scr;
	}
}

/*
 * vcpu_process_com_ier
 *
 * Emulate in/out instructions to the com1 (ns8250) UART interrupt enable
 * register.
 *
 * Parameters:
 *  vei: vm exit information from vmm(4) containing information on the in/out
 *      instruction being performed
 */
void
vcpu_process_com_ier(union vm_exit *vei)
{
	/*
	 * vei_dir == 0 : out instruction
	 *
	 * Write to IER
	 */
	if (vei->vei.vei_dir == 0) {
		com1_regs.ier = vei->vei.vei_data;
	} else {
		/*
		 * vei_dir == 1 : in instruction
		 *
		 * Read from IER
		 */
		vei->vei.vei_data = com1_regs.ier;
	}
}

/*
 * vcpu_exit_com
 *
 * Process com1 (ns8250) UART exits. vmd handles most basic 8250
 * features with the exception of the divisor latch (eg, no baud
 * rate support)
 *
 * Parameters:
 *  vrp: vcpu run parameters containing guest state for this exit
 */
void
vcpu_exit_com(struct vm_run_params *vrp)
{
	union vm_exit *vei = vrp->vrp_exit;

	switch(vei->vei.vei_port) {
	case COM1_LCR:
		vcpu_process_com_lcr(vei);
		break;
	case COM1_IER:
		vcpu_process_com_ier(vei);
		break;
	case COM1_IIR:
		vcpu_process_com_iir(vei);
		break;
	case COM1_MCR:
		vcpu_process_com_mcr(vei);
		break;
	case COM1_LSR:
		vcpu_process_com_lsr(vei);
		break;
	case COM1_MSR:
		vcpu_process_com_msr(vei);
		break;
	case COM1_SCR:
		vcpu_process_com_scr(vei);
		break;	
	case COM1_DATA:
		vcpu_process_com_data(vei);
		break;
	}
}

/*
 * vcpu_exit_pci
 *
 * Handle all I/O to the emulated PCI subsystem.
 *
 * Parameters:
 *  vrp: vcpu run paramters containing guest state for this exit
 *
 * Return values:
 *  0xff if no interrupt is required after this pci exit,
 *      or an interrupt vector otherwise
 */
uint8_t
vcpu_exit_pci(struct vm_run_params *vrp)
{
	union vm_exit *vei = vrp->vrp_exit;
	uint8_t intr;

	intr = 0xFF;

	switch(vei->vei.vei_port) {
	case PCI_MODE1_ADDRESS_REG:
		pci_handle_address_reg(vrp);
		break;
	case PCI_MODE1_DATA_REG:
		pci_handle_data_reg(vrp);
		break;
	case VMM_PCI_IO_BAR_BASE ... VMM_PCI_IO_BAR_END:
		intr = pci_handle_io(vrp);
		break;		
	default:
		log_warnx("%s: unknown PCI register 0x%llx",
		    __progname, (uint64_t)vei->vei.vei_port);
		break;
	}

	return (intr);
}

/*
 * vcpu_exit_inout
 *
 * Handle all I/O exits that need to be emulated in vmd. This includes the
 * i8253 PIT and the com1 ns8250 UART.
 *
 * Parameters:
 *  vrp: vcpu run parameters containing guest state for this exit
 */
void
vcpu_exit_inout(struct vm_run_params *vrp)
{
	union vm_exit *vei = vrp->vrp_exit;
	uint8_t intr;

	switch(vei->vei.vei_port) {
	case TIMER_CTRL:
	case (TIMER_CNTR0 + TIMER_BASE):
	case (TIMER_CNTR1 + TIMER_BASE):
	case (TIMER_CNTR2 + TIMER_BASE):
		vcpu_exit_i8253(vei);
		break;
	case COM1_DATA ... COM1_SCR:
		vcpu_exit_com(vrp);
		break;
	case PCI_MODE1_ADDRESS_REG:
	case PCI_MODE1_DATA_REG:
	case VMM_PCI_IO_BAR_BASE ... VMM_PCI_IO_BAR_END:
		intr = vcpu_exit_pci(vrp);
		if (intr != 0xFF)
			vrp->vrp_injint = intr;
		else
			vrp->vrp_injint = -1;
		break;
	default:
		/* IN from unsupported port gives FFs */
		if (vei->vei.vei_dir == 1)
			vei->vei.vei_data = 0xFFFFFFFF;
		break;
	}
}

/*
 * vcpu_exit
 *
 * Handle a vcpu exit. This function is called when it is determined that
 * vmm(4) requires the assistance of vmd to support a particular guest
 * exit type (eg, accessing an I/O port or device). Guest state is contained
 * in 'vrp', and will be resent to vmm(4) on exit completion.
 *
 * Upon conclusion of handling the exit, the function determines if any
 * interrupts should be injected into the guest, and sets vrp->vrp_injint
 * to the IRQ line whose interrupt should be vectored (or -1 if no interrupt
 * is to be injected).
 *
 * Parameters:
 *  vrp: vcpu run parameters containing guest state for this exit
 *
 * Return values:
 *  0: the exit was handled successfully
 *  1: an error occurred (exit not handled)
 */
int
vcpu_exit(struct vm_run_params *vrp)
{
	ssize_t sz;
	char ch;

	switch (vrp->vrp_exit_reason) {
	case VMX_EXIT_IO:
		vcpu_exit_inout(vrp);
		break;
	case VMX_EXIT_HLT:
		/*
		 * XXX handle halted state, no reason to run this vcpu again
		 * until a vm interrupt is to be injected
		 */
		break;
	default:
		log_warnx("%s: unknown exit reason %d",
		    __progname, vrp->vrp_exit_reason);
		return (1);
	}

	/* XXX interrupt priority */
	if (vionet_process_rx()) 
		vrp->vrp_injint = 9;

	/*
	 * Is there a new character available on com1?
	 * If so, consume the character, buffer it into the com1 data register
	 * assert IRQ4, and set the line status register RXRDY bit.
	 *
	 * XXX - move all this com intr checking to another function
	 */
	sz = read(con_fd, &ch, sizeof(char));
	if (sz == 1) {
		com1_regs.lsr |= LSR_RXRDY;
		com1_regs.data = ch;
		/* XXX these ier and iir bits should be IER_x and IIR_x */
		if (com1_regs.ier & 0x1) {
			com1_regs.iir |= (2 << 1);
			com1_regs.iir &= ~0x1;
		}
	}

	/*
	 * Clear "interrupt pending" by setting IIR low bit to 1 if no
	 * interrupts are pending
	 */
	/* XXX these iir magic numbers should be IIR_x */
	if ((com1_regs.iir & ~0x1) == 0x0)
		com1_regs.iir = 0x1;

	/* If pending interrupt and nothing waiting to be injected, inject */
	if ((com1_regs.iir & 0x1) == 0)
		if (vrp->vrp_injint == -1)
			vrp->vrp_injint = 0x4;
	vrp->vrp_continue = 1;

	return (0);
}

/*
 * write_page
 *
 * Pushes a page of data from 'buf' into the guest VM's memory
 * at paddr 'dst'.
 *
 * Parameters:
 *  dst: the destination paddr_t in the guest VM to push into.
 *      If there is no guest paddr mapping at 'dst', a new page will be
 *      faulted in by the VMM (provided 'dst' represents a valid paddr
 *      in the guest's address space)
 *  buf: page of data to push
 *  len: size of 'buf'
 *  do_mask: 1 to mask the destination address (for kernel load), 0 to
 *      leave 'dst' unmasked
 *
 * Return values:
 *  various return values from ioctl(VMM_IOC_WRITEPAGE), or 0 if no error
 *      occurred.
 *
 * Note - this function only handles GPAs < 4GB. 
 */
int
write_page(uint32_t dst, void *buf, uint32_t len, int do_mask)
{
	struct vm_writepage_params vwp;

	/*
	 * Mask kernel load addresses to avoid uint32_t -> uint64_t cast
	 * errors
	 */
	if (do_mask)
		dst &= 0xFFFFFFF;
	
	vwp.vwp_paddr = (paddr_t)dst;
	vwp.vwp_data = buf;
	vwp.vwp_vm_id = vm_id;
	vwp.vwp_len = len;
	if (ioctl(vmm_fd, VMM_IOC_WRITEPAGE, &vwp) < 0) {
		log_warn("writepage ioctl failed");
		return (errno);
	}
	return (0);
}

/*
 * read_page
 *
 * Reads a page of memory at guest paddr 'src' into 'buf'.
 *
 * Parameters:
 *  src: the source paddr_t in the guest VM to read from.
 *  buf: destination (local) buffer
 *  len: size of 'buf'
 *  do_mask: 1 to mask the source address (for kernel load), 0 to
 *      leave 'src' unmasked
 *
 * Return values:
 *  various return values from ioctl(VMM_IOC_READPAGE), or 0 if no error
 *      occurred.
 *
 * Note - this function only handles GPAs < 4GB.
 */
int
read_page(uint32_t src, void *buf, uint32_t len, int do_mask)
{
	struct vm_readpage_params vrp;

	/*
	 * Mask kernel load addresses to avoid uint32_t -> uint64_t cast
	 * errors
	 */
	if (do_mask)
		src &= 0xFFFFFFF;
	
	vrp.vrp_paddr = (paddr_t)src;
	vrp.vrp_data = buf;
	vrp.vrp_vm_id = vm_id;
	vrp.vrp_len = len;
	if (ioctl(vmm_fd, VMM_IOC_READPAGE, &vrp) < 0) {
		log_warn("readpage ioctl failed");
		return (errno);
	}
	return (0);
@


1.7
log
@typo: should be looking pid == -1
@
text
@d1 1
a1 1
/*	$OpenBSD: vmd.c,v 1.6 2015/11/23 21:07:29 reyk Exp $	*/
a120 2
int disable_vmm(void);
int enable_vmm(void);
a358 12
			case IMSG_VMDOP_DISABLE_VMM_REQUEST:
				res = disable_vmm();
				imsg_compose(ibuf,
				    IMSG_VMDOP_DISABLE_VMM_RESPONSE, 0, 0, -1,
				    &res, sizeof(res));
				break;
			case IMSG_VMDOP_ENABLE_VMM_REQUEST:
				res = enable_vmm();
				imsg_compose(ibuf,
				    IMSG_VMDOP_ENABLE_VMM_RESPONSE, 0, 0, -1,
				    &res, sizeof(res));
				break;
a394 36

	return (0);
}

/*
 * disable_vmm
 *
 * Disables VMM mode on all CPUs
 *
 * Return values:
 *  0: success
 *  !0 : ioctl to vmm(4) failed
 */
int
disable_vmm(void)
{
	if (ioctl(vmm_fd, VMM_IOC_STOP, NULL) < 0)
		return (errno);

	return (0);
}

/*
 * enable_vmm
 *
 * Enables VMM mode on all CPUs
 *
 * Return values:
 *  0: success
 *  !0 : ioctl to vmm(4) failed
 */
int
enable_vmm(void)
{
	if (ioctl(vmm_fd, VMM_IOC_START, NULL) < 0)
		return (errno);
@


1.6
log
@accept4() is restarted after signals which prevents vmd from exiting
in the current control socket loop.  Add a poll before the accept that
is not restarted and allows to escape the loop.  This code is kind of
temporary, as we're planning to replace the event handling, but it
allows to kill (or Ctrl+c) vmd for now.

OK tedu@@, discussed with many
@
text
@d1 1
a1 1
/*	$OpenBSD: vmd.c,v 1.5 2015/11/23 20:18:33 reyk Exp $	*/
d176 1
a176 1
		} while(pid != -1 || (pid != -1 && errno == EINTR));
@


1.5
log
@I accidentally removed a newline in usage() when converting the log
messages to log_*.

From Cesare Gargano
@
text
@d1 1
a1 1
/*	$OpenBSD: vmd.c,v 1.4 2015/11/23 13:04:49 reyk Exp $	*/
d56 1
d165 2
d174 3
a176 1
		while (waitpid(WAIT_ANY, 0, WNOHANG) > 0) {}
d254 1
a254 1
	int fd, connfd, n, res;
d259 1
d321 16
@


1.4
log
@Add support for logging to stderr or syslog, and to run vmd in
foreground with -d.

OK mlarkin@@ jung@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmd.c,v 1.3 2015/11/22 22:29:48 deraadt Exp $	*/
d180 1
a180 1
	fprintf(stderr, "usage: %s [-dv]", __progname);
@


1.3
log
@use PATH_MAX where needed
@
text
@d1 1
a1 1
/*	$OpenBSD: vmd.c,v 1.2 2015/11/22 21:51:32 reyk Exp $	*/
a41 1
#include <err.h>
d53 1
d115 2
d176 8
d187 17
a203 1
	int res;
d208 1
a208 1
		errx(1, "can't open vmm device node %s", VMM_NODE);
d218 6
a223 2
	if (daemon(0, 1) == -1)
		errx(1, "can't daemonize\n");
d228 1
a228 1
		errx(1, "control socket error\n");
d258 1
a258 1
		fprintf(stderr, "%s: socket error\n", __progname);
d266 1
a266 1
		fprintf(stderr, "%s: socket name too long\n", __progname);
d273 1
a273 1
			fprintf(stderr, "%s: unlink of %s failed\n",
d283 1
a283 1
		fprintf(stderr, "%s: control_init: bind of %s failed\n",
d293 1
a293 1
		fprintf(stderr, "%s: control_init: chmod of %s failed\n",
d301 1
a301 1
		fprintf(stderr, "%s: out of memory\n", __progname);
d308 1
a308 1
		fprintf(stderr, "%s: listen failed\n", __progname);
d317 1
a317 1
			fprintf(stderr, "%s: accept4 error\n", __progname);
d325 1
a325 1
			fprintf(stderr, "%s: imsg_read error, n=%d\n",
d374 2
a375 3
					fprintf(stderr, "%s: msgbuf_write "
					    "error %d\n", __progname,
					    errno);
d537 2
a538 2
			fprintf(stderr, "%s: can't open %s (%d)\n", __progname,
			    vcp->vcp_disks[i], errno);
d546 2
a547 2
		fprintf(stderr, "%s: can't stat kernel image %s (%d)\n",
		    __progname, vcp->vcp_kernel, errno);
d557 2
a558 2
		fprintf(stderr, "%s: can't open kernel image %s (%d)\n",
		    __progname, vcp->vcp_kernel, errno);
d564 1
a564 2
		fprintf(stderr, "%s: openpty failed: %d\n",
		    __progname, errno);
d570 1
a570 2
		fprintf(stderr, "%s: close tty failed: %d\n",
		    __progname, errno);
d579 2
a580 2
			fprintf(stderr, "%s: can't open tap for nic %zd (%d)\n",
			    __progname, i, errno);
d609 4
a612 1
		fprintf(stderr, "%s: vm console: %s\n", __progname, ptyn);
a613 1
		setproctitle(vcp->vcp_name);
d615 2
a616 3
			fprintf(stderr, "%s: create vmm ioctl failed - "
			    "exiting (%d)\n", __progname, ret);
			_exit(1);
d622 2
a623 3
			fprintf(stderr, "%s: failed to load kernel - "
			    "exiting (%d)\n", __progname, ret);
			_exit(1);
d629 2
a630 5
		if (fcntl(con_fd, F_SETFL, O_NONBLOCK) == -1) {
			fprintf(stderr, "%s: failed to set nonblocking mode "
			    "on console\n", __progname);
			_exit(1);
		}
d748 1
a748 1
		fprintf(stderr, "%s: no such user %s\n", __progname, VMD_USER);
d759 1
a759 1
			err(1, "unable to chroot");
d761 1
a761 1
			err(1, "unable to chdir");
d764 1
a764 1
			err(1, "setgroups() failed");
d766 1
a766 1
			err(1, "setresgid() failed");
d768 1
a768 1
			err(1, "setresuid() failed");
d873 1
a873 1
		fprintf(stderr, "%s: memory allocation error - exiting.\n",
d889 2
a890 2
			fprintf(stderr, "%s: memory allocation error - "
			    "exiting.\n", __progname);
d896 2
a897 2
			fprintf(stderr, "%s: memory allocation error - "
			    "exiting.\n", __progname);
d915 2
a916 2
			fprintf(stderr, "%s: failed to join thread %zd - "
			    "exiting\n", __progname, i);
d921 2
a922 2
			fprintf(stderr, "%s: vm %d vcpu run thread %zd exited "
			    "abnormally\n", __progname, vcp->vcp_id, i);
d1002 2
a1003 2
				fprintf(stderr, "%s: i8253 PIT: invalid "
				    "timer selected (%d)\n",
d1017 2
a1018 2
				fprintf(stderr, "%s: i8253 PIT: 16 bit "
				    "counter I/O not supported\n",
d1055 2
a1056 2
			fprintf(stderr, "%s: i8253 PIT: unsupported rw mode "
			    "%d\n", __progname, rw);
d1060 2
a1061 2
			fprintf(stderr, "%s: i8253 PIT: read from control "
			    "port unsupported\n", __progname);
d1135 1
a1135 1
			fprintf(stderr, "guest reading com1 when not ready\n");
d1269 1
a1269 1
		fprintf(stderr, "%s: LSR UART write 0x%x unsupported\n",
d1301 1
a1301 1
		fprintf(stderr, "%s: MSR UART write 0x%x unsupported\n",
d1452 1
a1452 1
		fprintf(stderr, "%s: unknown PCI register 0x%llx\n",
d1539 1
a1539 1
		fprintf(stderr, "%s: unknown exit reason %d\n",
a1607 1
	int ret;
d1622 2
a1623 3
		ret = errno;
		fprintf(stderr, "writepage ioctl failed: %d\n", ret);
		return (ret);
a1648 1
	int ret;
d1663 2
a1664 3
		ret = errno;
		fprintf(stderr, "readpage ioctl failed: %d\n", ret);
		return (ret);
@


1.2
log
@Add $ Ids
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a66 3
/* "/dev/tapXXX" */
#define MAX_TAPLEN 12

d438 1
a438 1
	char path[MAX_TAPLEN];
d441 1
a441 1
		snprintf(path, MAX_TAPLEN - 1, "/dev/tap%d", i);
@


1.1
log
@
vmd(8) - virtual machine daemon.

There is still a lot to be done, and fixed, in these userland components
but I have received enough "it works, commit it" emails that it's time
to finish those things in tree.

discussed with many, tested by many.
@
text
@d1 2
@

