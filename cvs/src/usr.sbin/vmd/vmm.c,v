head	1.69;
access;
symbols
	OPENBSD_6_1:1.67.0.4
	OPENBSD_6_1_BASE:1.67
	OPENBSD_6_0:1.33.0.2
	OPENBSD_6_0_BASE:1.33
	OPENBSD_5_9:1.21.0.2
	OPENBSD_5_9_BASE:1.21;
locks; strict;
comment	@ * @;


1.69
date	2017.04.21.07.03.26;	author reyk;	state Exp;
branches;
next	1.68;
commitid	B4wb6zF2A8q3ls4h;

1.68
date	2017.04.06.18.07.13;	author reyk;	state Exp;
branches;
next	1.67;
commitid	EDN0yyFCjEEFLBXp;

1.67
date	2017.03.15.18.06.18;	author reyk;	state Exp;
branches;
next	1.66;
commitid	olrxKy4ehROyBXsm;

1.66
date	2017.03.01.18.00.50;	author reyk;	state Exp;
branches;
next	1.65;
commitid	cyTuz5D4aJNa7GE5;

1.65
date	2017.01.24.09.58.00;	author mlarkin;	state Exp;
branches;
next	1.64;
commitid	qZaSMpMQ6nRraSYX;

1.64
date	2017.01.17.21.51.01;	author krw;	state Exp;
branches;
next	1.63;
commitid	7aASaBYKS1WgBK9H;

1.63
date	2017.01.13.14.50.56;	author reyk;	state Exp;
branches;
next	1.62;
commitid	O6Az38HSBXh6vWTC;

1.62
date	2017.01.11.22.38.10;	author reyk;	state Exp;
branches;
next	1.61;
commitid	36vA2wHEJBH4Kmuc;

1.61
date	2017.01.08.21.23.32;	author mlarkin;	state Exp;
branches;
next	1.60;
commitid	0xqRIahZZY5BlevU;

1.60
date	2016.12.14.17.56.19;	author reyk;	state Exp;
branches;
next	1.59;
commitid	LpQ8wqrEmSPd53cP;

1.59
date	2016.11.30.19.27.21;	author reyk;	state Exp;
branches;
next	1.58;
commitid	VOluQqMF2bnwPdBK;

1.58
date	2016.11.26.20.03.42;	author reyk;	state Exp;
branches;
next	1.57;
commitid	GrCSblbcTEkTQcOY;

1.57
date	2016.11.26.15.29.33;	author martijn;	state Exp;
branches;
next	1.56;
commitid	Gdci3TPc2XUnB1Rz;

1.56
date	2016.11.24.07.58.55;	author reyk;	state Exp;
branches;
next	1.55;
commitid	vTTzvT7jwtD1X8ZA;

1.55
date	2016.11.22.22.51.45;	author reyk;	state Exp;
branches;
next	1.54;
commitid	UJmvc2NrQrjrsSn3;

1.54
date	2016.11.04.15.07.26;	author reyk;	state Exp;
branches;
next	1.53;
commitid	qfn7LnsEzfGhtk0c;

1.53
date	2016.10.29.14.56.05;	author edd;	state Exp;
branches;
next	1.52;
commitid	DOewrpkDk9kNopaK;

1.52
date	2016.10.26.05.26.36;	author mlarkin;	state Exp;
branches;
next	1.51;
commitid	1sM4SQUlhgJwAn6Q;

1.51
date	2016.10.12.19.10.03;	author reyk;	state Exp;
branches;
next	1.50;
commitid	ghkPP3DbrIiwazmp;

1.50
date	2016.10.12.06.56.54;	author mlarkin;	state Exp;
branches;
next	1.49;
commitid	d9eAYZoqV2dTESpL;

1.49
date	2016.10.06.20.41.28;	author reyk;	state Exp;
branches;
next	1.48;
commitid	wCYYaHYJRJcNXaIt;

1.48
date	2016.10.06.18.48.41;	author reyk;	state Exp;
branches;
next	1.47;
commitid	PTFbBM1dh72QP2DS;

1.47
date	2016.10.05.17.30.13;	author reyk;	state Exp;
branches;
next	1.46;
commitid	c3mC9fNmRbfUPluH;

1.46
date	2016.10.04.17.17.30;	author reyk;	state Exp;
branches;
next	1.45;
commitid	yb7Y2lNmLG5i2hzO;

1.45
date	2016.09.29.22.42.04;	author reyk;	state Exp;
branches;
next	1.44;
commitid	OrqC5N55KjzTfX1Z;

1.44
date	2016.09.03.11.38.08;	author mlarkin;	state Exp;
branches;
next	1.43;
commitid	vDEEnyISXHYUWa3J;

1.43
date	2016.09.02.17.10.08;	author stefan;	state Exp;
branches;
next	1.42;
commitid	zTahXFskufJQvYES;

1.42
date	2016.09.02.16.23.40;	author stefan;	state Exp;
branches;
next	1.41;
commitid	5HafKfGZWjgaFI0t;

1.41
date	2016.09.01.17.09.33;	author mlarkin;	state Exp;
branches;
next	1.40;
commitid	mXO5lgoyRvpBkwio;

1.40
date	2016.09.01.16.40.06;	author mlarkin;	state Exp;
branches;
next	1.39;
commitid	7V0oCQPFjx6K1mXz;

1.39
date	2016.09.01.16.04.47;	author stefan;	state Exp;
branches;
next	1.38;
commitid	xgCRvP7hLEqkM3Qf;

1.38
date	2016.09.01.14.48.09;	author mlarkin;	state Exp;
branches;
next	1.37;
commitid	FBqVpmx18MX292rY;

1.37
date	2016.08.31.06.55.39;	author mlarkin;	state Exp;
branches;
next	1.36;
commitid	ymrldrjGd3v60twJ;

1.36
date	2016.08.17.05.07.13;	author deraadt;	state Exp;
branches;
next	1.35;
commitid	qqWoBqCGCbsKOAqY;

1.35
date	2016.08.01.16.32.10;	author stefan;	state Exp;
branches;
next	1.34;
commitid	nHVneiApuM739Qk7;

1.34
date	2016.07.29.16.36.51;	author stefan;	state Exp;
branches;
next	1.33;
commitid	lYP7ykFkRsliCh0y;

1.33
date	2016.07.19.09.52.34;	author natano;	state Exp;
branches;
next	1.32;
commitid	n1xINDCiMqjfky3a;

1.32
date	2016.07.09.09.06.22;	author stefan;	state Exp;
branches;
next	1.31;
commitid	yIWxq4qxCQhfbPDu;

1.31
date	2016.07.08.06.35.12;	author mlarkin;	state Exp;
branches;
next	1.30;
commitid	jjIahV0esQXKjl5o;

1.30
date	2016.07.07.00.58.31;	author mlarkin;	state Exp;
branches;
next	1.29;
commitid	2sGq29g3ZwzSaLsn;

1.29
date	2016.07.06.07.09.15;	author mlarkin;	state Exp;
branches;
next	1.28;
commitid	KNacf7hxYuIDdK4d;

1.28
date	2016.06.10.16.33.15;	author stefan;	state Exp;
branches;
next	1.27;
commitid	L7gJu1b5qM709alu;

1.27
date	2016.06.07.16.19.06;	author stefan;	state Exp;
branches;
next	1.26;
commitid	N4IUFQQXbAPAUf9e;

1.26
date	2016.04.07.05.51.26;	author guenther;	state Exp;
branches;
next	1.25;
commitid	GWC6G8EOQPmH8A9W;

1.25
date	2016.04.05.09.33.05;	author mlarkin;	state Exp;
branches;
next	1.24;
commitid	klY9sBeThwZpzkLp;

1.24
date	2016.04.04.17.13.54;	author stefan;	state Exp;
branches;
next	1.23;
commitid	Y1YC68R7VkcaKZ1f;

1.23
date	2016.03.13.13.11.47;	author stefan;	state Exp;
branches;
next	1.22;
commitid	tNFHzbetplEWT4Tg;

1.22
date	2016.03.13.02.37.29;	author mlarkin;	state Exp;
branches;
next	1.21;
commitid	lxMcMMeLHMI2mGrZ;

1.21
date	2016.02.16.19.00.16;	author stefan;	state Exp;
branches;
next	1.20;
commitid	mYtXNndCKbD9XRYJ;

1.20
date	2016.01.16.08.55.40;	author stefan;	state Exp;
branches;
next	1.19;
commitid	AJ7cyewTvXIt6nft;

1.19
date	2016.01.13.12.55.18;	author reyk;	state Exp;
branches;
next	1.18;
commitid	sO86Fr97dd4TXRon;

1.18
date	2016.01.08.11.28.05;	author reyk;	state Exp;
branches;
next	1.17;
commitid	Ubeio7GqQgyX5Mbm;

1.17
date	2016.01.08.08.12.21;	author stefan;	state Exp;
branches;
next	1.16;
commitid	epFByIkO0dvSJptr;

1.16
date	2016.01.04.07.27.24;	author mlarkin;	state Exp;
branches;
next	1.15;
commitid	w0Nv6JTPGqT6v1EL;

1.15
date	2016.01.04.02.07.28;	author mlarkin;	state Exp;
branches;
next	1.14;
commitid	jWhixnwknFs5C2Jx;

1.14
date	2015.12.17.09.29.28;	author mlarkin;	state Exp;
branches;
next	1.13;
commitid	8J3NuBrhKPtN9MxY;

1.13
date	2015.12.15.02.18.34;	author mlarkin;	state Exp;
branches;
next	1.12;
commitid	ByWyMc3OwYPifaJf;

1.12
date	2015.12.07.16.02.09;	author reyk;	state Exp;
branches;
next	1.11;
commitid	7wXpY4PD61RX2wuB;

1.11
date	2015.12.07.14.43.24;	author reyk;	state Exp;
branches;
next	1.10;
commitid	RMd15UDHH5owCCwU;

1.10
date	2015.12.06.02.26.14;	author reyk;	state Exp;
branches;
next	1.9;
commitid	DA7pwA53qcaD5xYQ;

1.9
date	2015.12.06.01.58.21;	author reyk;	state Exp;
branches;
next	1.8;
commitid	mJFYjYlVhI5frPwA;

1.8
date	2015.12.06.00.32.57;	author reyk;	state Exp;
branches;
next	1.7;
commitid	2jdqMpOkj8mCdYPb;

1.7
date	2015.12.03.23.32.32;	author reyk;	state Exp;
branches;
next	1.6;
commitid	ABlEnH3RsSBpSsyK;

1.6
date	2015.12.03.13.27.14;	author reyk;	state Exp;
branches;
next	1.5;
commitid	pRSLgXNuoj9hRPQx;

1.5
date	2015.12.03.08.42.11;	author reyk;	state Exp;
branches;
next	1.4;
commitid	deOxsg54am7A6Za6;

1.4
date	2015.12.02.22.19.11;	author reyk;	state Exp;
branches;
next	1.3;
commitid	7ra6VeOJoUb1NQ70;

1.3
date	2015.12.02.13.43.36;	author reyk;	state Exp;
branches;
next	1.2;
commitid	qcJMjGAHILmCub0o;

1.2
date	2015.12.02.09.39.41;	author reyk;	state Exp;
branches;
next	1.1;
commitid	rhcKtIJ7zvu5z3CH;

1.1
date	2015.12.02.09.14.25;	author reyk;	state Exp;
branches;
next	;
commitid	vOctzllSJTLtnazM;


desc
@@


1.69
log
@Add global configuration option "local prefix" to change prefix for -L.

The default prefix is 100.64.0.0/10 from RFC6598.

Requested by sthen@@ chris@@
OK mlarkin@@
@
text
@/*	$OpenBSD: vmm.c,v 1.68 2017/04/06 18:07:13 reyk Exp $	*/

/*
 * Copyright (c) 2015 Mike Larkin <mlarkin@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/param.h>	/* nitems */
#include <sys/ioctl.h>
#include <sys/queue.h>
#include <sys/wait.h>
#include <sys/uio.h>
#include <sys/socket.h>
#include <sys/time.h>
#include <sys/mman.h>

#include <dev/ic/i8253reg.h>
#include <dev/isa/isareg.h>
#include <dev/pci/pcireg.h>

#include <machine/param.h>
#include <machine/psl.h>
#include <machine/specialreg.h>
#include <machine/vmmvar.h>

#include <net/if.h>

#include <errno.h>
#include <event.h>
#include <fcntl.h>
#include <imsg.h>
#include <limits.h>
#include <poll.h>
#include <pthread.h>
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <util.h>

#include "vmd.h"
#include "vmm.h"

void vmm_sighdlr(int, short, void *);
int vmm_start_vm(struct imsg *, uint32_t *);
int vmm_dispatch_parent(int, struct privsep_proc *, struct imsg *);
void vmm_run(struct privsep *, struct privsep_proc *, void *);
void vmm_dispatch_vm(int, short, void *);
int terminate_vm(struct vm_terminate_params *);
int get_info_vm(struct privsep *, struct imsg *, int);
int opentap(char *);

extern struct vmd *env;

static struct privsep_proc procs[] = {
	{ "parent",	PROC_PARENT,	vmm_dispatch_parent  },
};

void
vmm(struct privsep *ps, struct privsep_proc *p)
{
	proc_run(ps, p, procs, nitems(procs), vmm_run, NULL);
}

void
vmm_run(struct privsep *ps, struct privsep_proc *p, void *arg)
{
	if (config_init(ps->ps_env) == -1)
		fatal("failed to initialize configuration");

	signal_del(&ps->ps_evsigchld);
	signal_set(&ps->ps_evsigchld, SIGCHLD, vmm_sighdlr, ps);
	signal_add(&ps->ps_evsigchld, NULL);

	/*
	 * pledge in the vmm process:
	 * stdio - for malloc and basic I/O including events.
	 * vmm - for the vmm ioctls and operations.
	 * proc - for forking and maitaining vms.
	 * recvfd - for disks, interfaces and other fds.
	 */
	if (pledge("stdio vmm recvfd proc", NULL) == -1)
		fatal("pledge");

	/* Get and terminate all running VMs */
	get_info_vm(ps, NULL, 1);
}

int
vmm_dispatch_parent(int fd, struct privsep_proc *p, struct imsg *imsg)
{
	struct privsep		*ps = p->p_ps;
	int			 res = 0, cmd = 0, verbose;
	struct vmd_vm		*vm = NULL;
	struct vm_terminate_params vtp;
	struct vmop_result	 vmr;
	uint32_t		 id = 0;
	unsigned int		 mode;

	switch (imsg->hdr.type) {
	case IMSG_VMDOP_START_VM_REQUEST:
		res = config_getvm(ps, imsg);
		if (res == -1) {
			res = errno;
			cmd = IMSG_VMDOP_START_VM_RESPONSE;
		}
		break;
	case IMSG_VMDOP_START_VM_DISK:
		res = config_getdisk(ps, imsg);
		if (res == -1) {
			res = errno;
			cmd = IMSG_VMDOP_START_VM_RESPONSE;
		}
		break;
	case IMSG_VMDOP_START_VM_IF:
		res = config_getif(ps, imsg);
		if (res == -1) {
			res = errno;
			cmd = IMSG_VMDOP_START_VM_RESPONSE;
		}
		break;
	case IMSG_VMDOP_START_VM_END:
		res = vmm_start_vm(imsg, &id);
		/* Check if the ID can be mapped correctly */
		if ((id = vm_id2vmid(id, NULL)) == 0)
			res = ENOENT;
		cmd = IMSG_VMDOP_START_VM_RESPONSE;
		break;
	case IMSG_VMDOP_TERMINATE_VM_REQUEST:
		IMSG_SIZE_CHECK(imsg, &vtp);
		memcpy(&vtp, imsg->data, sizeof(vtp));
		id = vtp.vtp_vm_id;

		if (id == 0) {
			res = ENOENT;
		} else if ((vm = vm_getbyvmid(id)) != NULL &&
		    vm->vm_shutdown == 0) {
			log_debug("%s: sending shutdown request to vm %d",
			    __func__, id);

			/*
			 * Request reboot but mark the VM as shutting down.
			 * This way we can terminate the VM after the triple
			 * fault instead of reboot and avoid being stuck in
			 * the ACPI-less powerdown ("press any key to reboot")
			 * of the VM.
			 */
			vm->vm_shutdown = 1;
			if (imsg_compose_event(&vm->vm_iev,
			    IMSG_VMDOP_VM_REBOOT, 0, 0, -1, NULL, 0) == -1)
				res = errno;
			else
				res = 0;
		} else {
			/* Terminate VMs that are unknown or shutting down */
			vtp.vtp_vm_id = vm_vmid2id(vm->vm_vmid, vm);
			res = terminate_vm(&vtp);
			vm_remove(vm);
		}
		cmd = IMSG_VMDOP_TERMINATE_VM_RESPONSE;
		break;
	case IMSG_VMDOP_GET_INFO_VM_REQUEST:
		res = get_info_vm(ps, imsg, 0);
		cmd = IMSG_VMDOP_GET_INFO_VM_END_DATA;
		break;
	case IMSG_VMDOP_CONFIG:
		config_getconfig(env, imsg);
		break;
	case IMSG_CTL_RESET:
		IMSG_SIZE_CHECK(imsg, &mode);
		memcpy(&mode, imsg->data, sizeof(mode));

		if (mode & CONFIG_VMS) {
			/* Terminate and remove all VMs */
			vmm_shutdown();
			mode &= ~CONFIG_VMS;
		}

		config_getreset(env, imsg);
		break;
	case IMSG_CTL_VERBOSE:
		IMSG_SIZE_CHECK(imsg, &verbose);
		memcpy(&verbose, imsg->data, sizeof(verbose));
		log_setverbose(verbose);

		/* Forward message to each VM process */
		TAILQ_FOREACH(vm, env->vmd_vms, vm_entry) {
			imsg_compose_event(&vm->vm_iev,
			    imsg->hdr.type, imsg->hdr.peerid, imsg->hdr.pid,
			    -1, &verbose, sizeof(verbose));
		}
		break;
	default:
		return (-1);
	}

	switch (cmd) {
	case 0:
		break;
	case IMSG_VMDOP_START_VM_RESPONSE:
		if (res != 0) {
			/* Remove local reference if it exists */
			if ((vm = vm_getbyvmid(imsg->hdr.peerid)) != NULL)
				vm_remove(vm);
		}
		if (id == 0)
			id = imsg->hdr.peerid;
	case IMSG_VMDOP_TERMINATE_VM_RESPONSE:
		memset(&vmr, 0, sizeof(vmr));
		vmr.vmr_result = res;
		vmr.vmr_id = id;
		if (proc_compose_imsg(ps, PROC_PARENT, -1, cmd,
		    imsg->hdr.peerid, -1, &vmr, sizeof(vmr)) == -1)
			return (-1);
		break;
	default:
		if (proc_compose_imsg(ps, PROC_PARENT, -1, cmd,
		    imsg->hdr.peerid, -1, &res, sizeof(res)) == -1)
			return (-1);
		break;
	}

	return (0);
}

void
vmm_sighdlr(int sig, short event, void *arg)
{
	struct privsep *ps = arg;
	int status, ret = 0;
	uint32_t vmid;
	pid_t pid;
	struct vmop_result vmr;
	struct vmd_vm *vm;
	struct vm_terminate_params vtp;

	switch (sig) {
	case SIGCHLD:
		do {
			pid = waitpid(-1, &status, WNOHANG);
			if (pid <= 0)
				continue;

			if (WIFEXITED(status) || WIFSIGNALED(status)) {
				vm = vm_getbypid(pid);
				if (vm == NULL) {
					/*
					 * If the VM is gone already, it
					 * got terminated via a
					 * IMSG_VMDOP_TERMINATE_VM_REQUEST.
					 */
					continue;
				}

				if (WIFEXITED(status))
					ret = WEXITSTATUS(status);

				/* don't reboot on pending shutdown */
				if (ret == EAGAIN && vm->vm_shutdown)
					ret = 0;

				vmid = vm->vm_params.vmc_params.vcp_id;
				vtp.vtp_vm_id = vmid;
				if (terminate_vm(&vtp) == 0) {
					memset(&vmr, 0, sizeof(vmr));
					vmr.vmr_result = ret;
					vmr.vmr_id = vm_id2vmid(vmid, vm);
					if (proc_compose_imsg(ps, PROC_PARENT,
					    -1, IMSG_VMDOP_TERMINATE_VM_EVENT,
					    0, -1, &vmr, sizeof(vmr)) == -1)
						log_warnx("could not signal "
						    "termination of VM %u to "
						    "parent", vm->vm_vmid);
				} else
					log_warnx("could not terminate VM %u",
					    vm->vm_vmid);

				vm_remove(vm);
			} else
				fatalx("unexpected cause of SIGCHLD");
		} while (pid > 0 || (pid == -1 && errno == EINTR));
		break;
	default:
		fatalx("unexpected signal");
	}
}

/*
 * vmm_shutdown
 *
 * Terminate VMs on shutdown to avoid "zombie VM" processes.
 */
void
vmm_shutdown(void)
{
	struct vm_terminate_params vtp;
	struct vmd_vm *vm, *vm_next;

	TAILQ_FOREACH_SAFE(vm, env->vmd_vms, vm_entry, vm_next) {
		vtp.vtp_vm_id = vm_vmid2id(vm->vm_vmid, vm);

		/* XXX suspend or request graceful shutdown */
		(void)terminate_vm(&vtp);
		vm_remove(vm);
	}
}

/*
 * vmm_pipe
 *
 * Create a new imsg control channel between vmm parent and a VM
 * (can be called on both sides).
 */
int
vmm_pipe(struct vmd_vm *vm, int fd, void (*cb)(int, short, void *))
{
	struct imsgev	*iev = &vm->vm_iev;

	if (fcntl(fd, F_SETFL, O_NONBLOCK) == -1) {
		log_warn("failed to set nonblocking mode on vm pipe");
		return (-1);
	}

	imsg_init(&iev->ibuf, fd);
	iev->handler = cb;
	iev->data = vm;
	imsg_event_add(iev);

	return (0);
}

/*
 * vmm_dispatch_vm
 *
 * imsg callback for messages that are received from a VM child process.
 */
void
vmm_dispatch_vm(int fd, short event, void *arg)
{
	struct vmd_vm		*vm = arg;
	struct imsgev		*iev = &vm->vm_iev;
	struct imsgbuf		*ibuf = &iev->ibuf;
	struct imsg		 imsg;
	ssize_t			 n;

	if (event & EV_READ) {
		if ((n = imsg_read(ibuf)) == -1 && errno != EAGAIN)
			fatal("%s: imsg_read", __func__);
		if (n == 0) {
			/* this pipe is dead, so remove the event handler */
			event_del(&iev->ev);
			return;
		}
	}

	if (event & EV_WRITE) {
		if ((n = msgbuf_write(&ibuf->w)) == -1 && errno != EAGAIN)
			fatal("%s: msgbuf_write fd %d", __func__, ibuf->fd);
		if (n == 0) {
			/* this pipe is dead, so remove the event handler */
			event_del(&iev->ev);
			return;
		}
	}

	for (;;) {
		if ((n = imsg_get(ibuf, &imsg)) == -1)
			fatal("%s: imsg_get", __func__);
		if (n == 0)
			break;

		dprintf("%s: got imsg %d from %s",
		    __func__, imsg.hdr.type,
		    vm->vm_params.vmc_params.vcp_name);

		switch (imsg.hdr.type) {
		case IMSG_VMDOP_VM_SHUTDOWN:
			vm->vm_shutdown = 1;
			break;
		case IMSG_VMDOP_VM_REBOOT:
			vm->vm_shutdown = 0;
			break;
		default:
			fatalx("%s: got invalid imsg %d from %s",
			    __func__, imsg.hdr.type,
			    vm->vm_params.vmc_params.vcp_name);
		}
		imsg_free(&imsg);
	}
	imsg_event_add(iev);
}

/*
 * terminate_vm
 *
 * Requests vmm(4) to terminate the VM whose ID is provided in the
 * supplied vm_terminate_params structure (vtp->vtp_vm_id)
 *
 * Parameters
 *  vtp: vm_create_params struct containing the ID of the VM to terminate
 *
 * Return values:
 *  0: success
 *  !0 : ioctl to vmm(4) failed (eg, ENOENT if the supplied VM is not
 *      valid)
 */
int
terminate_vm(struct vm_terminate_params *vtp)
{
	if (ioctl(env->vmd_fd, VMM_IOC_TERM, vtp) < 0)
		return (errno);

	return (0);
}

/*
 * opentap
 *
 * Opens the next available tap device, up to MAX_TAP.
 *
 * Parameters
 *  ifname: an optional buffer of at least IF_NAMESIZE bytes.
 *
 * Returns a file descriptor to the tap node opened, or -1 if no tap
 * devices were available.
 */
int
opentap(char *ifname)
{
	int i, fd;
	char path[PATH_MAX];

	strlcpy(ifname, "tap", IF_NAMESIZE);
	for (i = 0; i < MAX_TAP; i++) {
		snprintf(path, PATH_MAX, "/dev/tap%d", i);
		fd = open(path, O_RDWR | O_NONBLOCK);
		if (fd != -1) {
			if (ifname != NULL)
				snprintf(ifname, IF_NAMESIZE, "tap%d", i);
			return (fd);
		}
	}

	return (-1);
}

/*
 * vmm_start_vm
 *
 * Prepares and forks a new VM process.
 *
 * Parameters:
 *  imsg: The VM data structure that is including the VM create parameters.
 *  id: Returns the VM id as reported by the kernel and obtained from the VM.
 *
 * Return values:
 *  0: success
 *  !0 : failure - typically an errno indicating the source of the failure
 */
int
vmm_start_vm(struct imsg *imsg, uint32_t *id)
{
	struct vm_create_params	*vcp;
	struct vmd_vm		*vm;
	int			 ret = EINVAL;
	int			 fds[2];
	size_t			 i;

	if ((vm = vm_getbyvmid(imsg->hdr.peerid)) == NULL) {
		log_warnx("%s: can't find vm", __func__);
		ret = ENOENT;
		goto err;
	}
	vcp = &vm->vm_params.vmc_params;

	if ((vm->vm_tty = imsg->fd) == -1) {
		log_warnx("%s: can't get tty", __func__);
		goto err;
	}

	if (socketpair(AF_UNIX, SOCK_STREAM, PF_UNSPEC, fds) == -1)
		fatal("socketpair");

	/* Start child vmd for this VM (fork, chroot, drop privs) */
	ret = fork();

	/* Start child failed? - cleanup and leave */
	if (ret == -1) {
		log_warnx("%s: start child failed", __func__);
		ret = EIO;
		goto err;
	}

	if (ret > 0) {
		/* Parent */
		vm->vm_pid = ret;
		close(fds[1]);

		for (i = 0 ; i < vcp->vcp_ndisks; i++) {
			close(vm->vm_disks[i]);
			vm->vm_disks[i] = -1;
		}

		for (i = 0 ; i < vcp->vcp_nnics; i++) {
			close(vm->vm_ifs[i].vif_fd);
			vm->vm_ifs[i].vif_fd = -1;
		}

		close(vm->vm_kernel);
		vm->vm_kernel = -1;

		close(vm->vm_tty);
		vm->vm_tty = -1;

		/* read back the kernel-generated vm id from the child */
		if (read(fds[0], &vcp->vcp_id, sizeof(vcp->vcp_id)) !=
		    sizeof(vcp->vcp_id))
			fatal("read vcp id");

		if (vcp->vcp_id == 0)
			goto err;

		*id = vcp->vcp_id;

		if (vmm_pipe(vm, fds[0], vmm_dispatch_vm) == -1)
			fatal("setup vm pipe");

		return (0);
	} else {
		/* Child */
		close(fds[0]);

		ret = start_vm(vm, fds[1]);

		_exit(ret);
	}

	return (0);

 err:
	vm_remove(vm);

	return (ret);
}

/*
 * get_info_vm
 *
 * Returns a list of VMs known to vmm(4).
 *
 * Parameters:
 *  ps: the privsep context.
 *  imsg: the received imsg including the peer id.
 *  terminate: terminate the listed vm.
 *
 * Return values:
 *  0: success
 *  !0 : failure (eg, ENOMEM, EIO or another error code from vmm(4) ioctl)
 */
int
get_info_vm(struct privsep *ps, struct imsg *imsg, int terminate)
{
	int ret;
	size_t ct, i;
	struct vm_info_params vip;
	struct vm_info_result *info;
	struct vm_terminate_params vtp;
	struct vmop_info_result vir;

	/*
	 * We issue the VMM_IOC_INFO ioctl twice, once with an input
	 * buffer size of 0, which results in vmm(4) returning the
	 * number of bytes required back to us in vip.vip_size,
	 * and then we call it again after malloc'ing the required
	 * number of bytes.
	 *
	 * It is possible that we could fail a second time (eg, if
	 * another VM was created in the instant between the two
	 * ioctls, but in that case the caller can just try again
	 * as vmm(4) will return a zero-sized list in that case.
	 */
	vip.vip_size = 0;
	info = NULL;
	ret = 0;
	memset(&vir, 0, sizeof(vir));

	/* First ioctl to see how many bytes needed (vip.vip_size) */
	if (ioctl(env->vmd_fd, VMM_IOC_INFO, &vip) < 0)
		return (errno);

	if (vip.vip_info_ct != 0)
		return (EIO);

	info = malloc(vip.vip_size);
	if (info == NULL)
		return (ENOMEM);

	/* Second ioctl to get the actual list */
	vip.vip_info = info;
	if (ioctl(env->vmd_fd, VMM_IOC_INFO, &vip) < 0) {
		ret = errno;
		free(info);
		return (ret);
	}

	/* Return info */
	ct = vip.vip_size / sizeof(struct vm_info_result);
	for (i = 0; i < ct; i++) {
		if (terminate) {
			vtp.vtp_vm_id = info[i].vir_id;
			if ((ret = terminate_vm(&vtp)) != 0)
				return (ret);
			log_debug("%s: terminated VM %s (id %d)", __func__,
			    info[i].vir_name, info[i].vir_id);
			continue;
		}
		memcpy(&vir.vir_info, &info[i], sizeof(vir.vir_info));
		vir.vir_info.vir_id = vm_id2vmid(info[i].vir_id, NULL);
		if (proc_compose_imsg(ps, PROC_PARENT, -1,
		    IMSG_VMDOP_GET_INFO_VM_DATA, imsg->hdr.peerid, -1,
		    &vir, sizeof(vir)) == -1)
			return (EIO);
	}
	free(info);
	return (0);
}
@


1.68
log
@Do not expose vmm(4) VM IDs to the user, use vmd(8)'s IDs instead.

Each VM has two IDs: one from the kernel (vmm) and a different one
from userland (vmd).  The vmm ID is not consistent and incremented on
every boot during runtimg of the host system.  The vmd ID remains the
same during the lifetime of a configured VM, even after reboots.
Configured VMs will even get and keep their IDs when the configuration
is loaded.  This is more what users expect.

Pointed out and tested by otto@@

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmm.c,v 1.67 2017/03/15 18:06:18 reyk Exp $	*/
d177 3
@


1.67
log
@Improve vmmci(4) shutdown and reboot.

This change handles various cases to power off the VM, even if it is
unresponsive, stuck in ddb, or when the shutdown was initiated from
the VM guest side.  Usage of timeout and VM ACKs make sure that the VM
is really turned off at some point.

OK mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmm.c,v 1.66 2017/03/01 18:00:50 reyk Exp $	*/
d106 1
a106 1
	struct vmd_vm		*vm;
d136 3
d146 3
a148 1
		if ((vm = vm_getbyid(id)) != NULL &&
d168 1
d215 2
d276 1
a276 1
					vmr.vmr_id = vmid;
d282 1
a282 1
						    "parent", vmid);
d285 1
a285 1
					    vmid);
d309 1
a309 1
		vtp.vtp_vm_id = vm->vm_params.vmc_params.vcp_id;
d381 1
a381 2
#if DEBUG > 1
		log_debug("%s: got imsg %d from %s",
a383 1
#endif
d627 1
@


1.66
log
@Split vmm.c into two files: vm.c for the VM child, vmm.c for the parent

As discussed with mlarkin@@, it makes it easier to maintain the file.

OK mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmm.c,v 1.65 2017/01/24 09:58:00 mlarkin Exp $	*/
d380 6
@


1.65
log
@SVM: vmd(8) support for SVM
@
text
@d1 1
a1 1
/*	$OpenBSD: vmm.c,v 1.64 2017/01/17 21:51:01 krw Exp $	*/
a54 10
#include "loadfile.h"
#include "pci.h"
#include "virtio.h"
#include "proc.h"
#include "i8253.h"
#include "i8259.h"
#include "ns8250.h"
#include "mc146818.h"

io_fn_t ioports_map[MAX_PORTS];
d57 1
a57 15
int opentap(char *);
int start_vm(struct imsg *, uint32_t *);
int terminate_vm(struct vm_terminate_params *);
int get_info_vm(struct privsep *, struct imsg *, int);
int run_vm(int *, int *, struct vm_create_params *, struct vcpu_reg_state *);
void *event_thread(void *);
void *vcpu_run_loop(void *);
int vcpu_exit(struct vm_run_params *);
int vcpu_reset(uint32_t, uint32_t, struct vcpu_reg_state *);
void create_memory_map(struct vm_create_params *);
int alloc_guest_mem(struct vm_create_params *);
int vmm_create_vm(struct vm_create_params *);
void init_emulated_hw(struct vm_create_params *, int *, int *);
void vcpu_exit_inout(struct vm_run_params *);
uint8_t vcpu_exit_pci(struct vm_run_params *);
a59 3
int vcpu_pic_intr(uint32_t, uint32_t, uint8_t);

int vmm_pipe(struct vmd_vm *, int, void (*)(int, short, void *));
d61 3
a63 7
void vm_dispatch_vmm(int, short, void *);

static struct vm_mem_range *find_gpa_range(struct vm_create_params *, paddr_t,
    size_t);

int con_fd;
struct vmd_vm *current_vm;
a66 10
extern char *__progname;

pthread_mutex_t threadmutex;
pthread_cond_t threadcond;

pthread_cond_t vcpu_run_cond[VMM_MAX_VCPUS_PER_VM];
pthread_mutex_t vcpu_run_mtx[VMM_MAX_VCPUS_PER_VM];
uint8_t vcpu_hlt[VMM_MAX_VCPUS_PER_VM];
uint8_t vcpu_done[VMM_MAX_VCPUS_PER_VM];

a70 39
/*
 * Represents a standard register set for an OS to be booted
 * as a flat 32 bit address space, before paging is enabled.
 *
 * NOT set here are:
 *  RIP
 *  RSP
 *  GDTR BASE
 *
 * Specific bootloaders should clone this structure and override
 * those fields as needed.
 *
 * Note - CR3 and various bits in CR0 may be overridden by vmm(4) based on
 *        features of the CPU in use.
 */
static const struct vcpu_reg_state vcpu_init_flat32 = {
#ifdef __i386__
	.vrs_gprs[VCPU_REGS_EFLAGS] = 0x2,
	.vrs_gprs[VCPU_REGS_EIP] = 0x0,
	.vrs_gprs[VCPU_REGS_ESP] = 0x0,
#else
	.vrs_gprs[VCPU_REGS_RFLAGS] = 0x2,
	.vrs_gprs[VCPU_REGS_RIP] = 0x0,
	.vrs_gprs[VCPU_REGS_RSP] = 0x0,
#endif
	.vrs_crs[VCPU_REGS_CR0] = CR0_CD | CR0_NW | CR0_ET | CR0_PE | CR0_PG,
	.vrs_crs[VCPU_REGS_CR3] = PML4_PAGE,
	.vrs_sregs[VCPU_REGS_CS] = { 0x8, 0xFFFFFFFF, 0xC09F, 0x0},
	.vrs_sregs[VCPU_REGS_DS] = { 0x10, 0xFFFFFFFF, 0xC093, 0x0},
	.vrs_sregs[VCPU_REGS_ES] = { 0x10, 0xFFFFFFFF, 0xC093, 0x0},
	.vrs_sregs[VCPU_REGS_FS] = { 0x10, 0xFFFFFFFF, 0xC093, 0x0},
	.vrs_sregs[VCPU_REGS_GS] = { 0x10, 0xFFFFFFFF, 0xC093, 0x0},
	.vrs_sregs[VCPU_REGS_SS] = { 0x10, 0xFFFFFFFF, 0xC093, 0x0},
	.vrs_gdtr = { 0x0, 0xFFFF, 0x0, 0x0},
	.vrs_idtr = { 0x0, 0xFFFF, 0x0, 0x0},
	.vrs_sregs[VCPU_REGS_LDTR] = { 0x0, 0xFFFF, 0x0082, 0x0},
	.vrs_sregs[VCPU_REGS_TR] = { 0x0, 0xFFFF, 0x008B, 0x0},
};

d135 1
a135 1
		res = start_vm(imsg, &id);
d309 6
d333 5
a389 94
void
vm_dispatch_vmm(int fd, short event, void *arg)
{
	struct vmd_vm		*vm = arg;
	struct imsgev		*iev = &vm->vm_iev;
	struct imsgbuf		*ibuf = &iev->ibuf;
	struct imsg		 imsg;
	ssize_t			 n;
	int			 verbose;

	if (event & EV_READ) {
		if ((n = imsg_read(ibuf)) == -1 && errno != EAGAIN)
			fatal("%s: imsg_read", __func__);
		if (n == 0)
			_exit(0);
	}

	if (event & EV_WRITE) {
		if ((n = msgbuf_write(&ibuf->w)) == -1 && errno != EAGAIN)
			fatal("%s: msgbuf_write fd %d", __func__, ibuf->fd);
		if (n == 0)
			_exit(0);
	}

	for (;;) {
		if ((n = imsg_get(ibuf, &imsg)) == -1)
			fatal("%s: imsg_get", __func__);
		if (n == 0)
			break;

#if DEBUG > 1
		log_debug("%s: got imsg %d from %s",
		    __func__, imsg.hdr.type,
		    vm->vm_params.vmc_params.vcp_name);
#endif

		switch (imsg.hdr.type) {
		case IMSG_CTL_VERBOSE:
			IMSG_SIZE_CHECK(&imsg, &verbose);
			memcpy(&verbose, imsg.data, sizeof(verbose));
			log_setverbose(verbose);
			break;
		case IMSG_VMDOP_VM_SHUTDOWN:
			if (vmmci_ctl(VMMCI_SHUTDOWN) == -1)
				_exit(0);
			break;
		case IMSG_VMDOP_VM_REBOOT:
			if (vmmci_ctl(VMMCI_REBOOT) == -1)
				_exit(0);
			break;
		default:
			fatalx("%s: got invalid imsg %d from %s",
			    __func__, imsg.hdr.type,
			    vm->vm_params.vmc_params.vcp_name);
		}
		imsg_free(&imsg);
	}
	imsg_event_add(iev);
}

/*
 * vcpu_reset
 *
 * Requests vmm(4) to reset the VCPUs in the indicated VM to
 * the register state provided
 *
 * Parameters
 *  vmid: VM ID to reset
 *  vcpu_id: VCPU ID to reset
 *  vrs: the register state to initialize
 *
 * Return values:
 *  0: success
 *  !0 : ioctl to vmm(4) failed (eg, ENOENT if the supplied VM ID is not
 *      valid)
 */
int
vcpu_reset(uint32_t vmid, uint32_t vcpu_id, struct vcpu_reg_state *vrs)
{
	struct vm_resetcpu_params vrp;

	memset(&vrp, 0, sizeof(vrp));
	vrp.vrp_vm_id = vmid;
	vrp.vrp_vcpu_id = vcpu_id;
	memcpy(&vrp.vrp_init_state, vrs, sizeof(struct vcpu_reg_state));

	log_debug("%s: resetting vcpu %d for vm %d", __func__, vcpu_id, vmid);

	if (ioctl(env->vmd_fd, VMM_IOC_RESETCPU, &vrp) < 0)
		return (errno);

	return (0);
}

d445 1
a445 6
 * start_vm
 *
 * Starts a new VM with the creation parameters supplied (in the incoming
 * imsg->data field). This function performs a basic sanity check on the
 * incoming parameters and then performs the following steps to complete
 * the creation of the VM:
d447 1
a447 6
 * 1. opens the VM disk image files specified in the VM creation parameters
 * 2. opens the specified VM kernel
 * 3. creates a VM console tty pair using openpty
 * 4. forks, passing the file descriptors opened in steps 1-3 to the child
 *     vmd responsible for dropping privilege and running the VM's VCPU
 *     loops.
d450 2
a451 3
 *  imsg: The incoming imsg body whose 'data' field is a vm_create_params
 *      struct containing the VM creation parameters.
 *  id: Returns the VM id as reported by the kernel.
d458 1
a458 1
start_vm(struct imsg *imsg, uint32_t *id)
a460 1
	struct vmboot_params	 vmboot;
d462 2
a464 4
	int			 ret = EINVAL;
	int			 fds[2], nicfds[VMM_MAX_NICS_PER_VM];
	struct vcpu_reg_state	 vrs;
	FILE			*kernfp;
d494 1
a512 1
		close(fds[1]);
a527 14
		setproctitle("%s", vcp->vcp_name);
		log_procinit(vcp->vcp_name);

		create_memory_map(vcp);
		ret = alloc_guest_mem(vcp);
		if (ret) {
			errno = ret;
			fatal("could not allocate guest memory - exiting");
		}

		ret = vmm_create_vm(vcp);
		current_vm = vm;

		/* send back the kernel-generated vm id (0 on error) */
a528 52
		if (write(fds[1], &vcp->vcp_id, sizeof(vcp->vcp_id)) !=
		    sizeof(vcp->vcp_id))
			fatal("write vcp id");

		if (ret) {
			errno = ret;
			fatal("create vmm ioctl failed - exiting");
		}

		/*
		 * pledge in the vm processes:
		 * stdio - for malloc and basic I/O including events.
		 * vmm - for the vmm ioctls and operations.
		 */
		if (pledge("stdio vmm", NULL) == -1)
			fatal("pledge");

		/*
		 * Set up default "flat 32 bit" register state - RIP,
		 * RSP, and GDT info will be set in bootloader
		 */
		memcpy(&vrs, &vcpu_init_flat32, sizeof(struct vcpu_reg_state));

		/* Find and open kernel image */
		if ((kernfp = vmboot_open(vm->vm_kernel,
		    vm->vm_disks[0], &vmboot)) == NULL)
			fatalx("failed to open kernel - exiting");

		/* Load kernel image */
		ret = loadelf_main(kernfp, vcp, &vrs,
		    vmboot.vbp_bootdev, vmboot.vbp_howto);
		if (ret) {
			errno = ret;
			fatal("failed to load kernel - exiting");
		}

		vmboot_close(kernfp, &vmboot);

		if (vm->vm_kernel != -1)
			close(vm->vm_kernel);

		con_fd = vm->vm_tty;
		if (fcntl(con_fd, F_SETFL, O_NONBLOCK) == -1)
			fatal("failed to set nonblocking mode on console");

		for (i = 0; i < VMM_MAX_NICS_PER_VM; i++)
			nicfds[i] = vm->vm_ifs[i].vif_fd;

		event_init();

		if (vmm_pipe(vm, fds[1], vm_dispatch_vmm) == -1)
			fatal("setup vm pipe");
d530 1
a530 2
		/* Execute the vcpu run loop(s) for this VM */
		ret = run_vm(vm->vm_disks, nicfds, vcp, &vrs);
a621 921
}

/*
 * create_memory_map
 *
 * Sets up the guest physical memory ranges that the VM can access.
 *
 * Return values:
 *  nothing
 */
void
create_memory_map(struct vm_create_params *vcp)
{
	size_t len, mem_bytes, mem_mb;

	mem_mb = vcp->vcp_memranges[0].vmr_size;
	vcp->vcp_nmemranges = 0;
	if (mem_mb < 1 || mem_mb > VMM_MAX_VM_MEM_SIZE)
		return;

	mem_bytes = mem_mb * 1024 * 1024;

	/* First memory region: 0 - LOWMEM_KB (DOS low mem) */
	len = LOWMEM_KB * 1024;
	vcp->vcp_memranges[0].vmr_gpa = 0x0;
	vcp->vcp_memranges[0].vmr_size = len;
	mem_bytes -= len;

	/*
	 * Second memory region: LOWMEM_KB - 1MB.
	 *
	 * N.B. - Normally ROMs or parts of video RAM are mapped here.
	 * We have to add this region, because some systems
	 * unconditionally write to 0xb8000 (VGA RAM), and
	 * we need to make sure that vmm(4) permits accesses
	 * to it. So allocate guest memory for it.
	 */
	len = 0x100000 - LOWMEM_KB * 1024;
	vcp->vcp_memranges[1].vmr_gpa = LOWMEM_KB * 1024;
	vcp->vcp_memranges[1].vmr_size = len;
	mem_bytes -= len;

	/* Make sure that we do not place physical memory into MMIO ranges. */
	if (mem_bytes > VMM_PCI_MMIO_BAR_BASE - 0x100000)
		len = VMM_PCI_MMIO_BAR_BASE - 0x100000;
	else
		len = mem_bytes;

	/* Third memory region: 1MB - (1MB + len) */
	vcp->vcp_memranges[2].vmr_gpa = 0x100000;
	vcp->vcp_memranges[2].vmr_size = len;
	mem_bytes -= len;

	if (mem_bytes > 0) {
		/* Fourth memory region for the remaining memory (if any) */
		vcp->vcp_memranges[3].vmr_gpa = VMM_PCI_MMIO_BAR_END + 1;
		vcp->vcp_memranges[3].vmr_size = mem_bytes;
		vcp->vcp_nmemranges = 4;
	} else
		vcp->vcp_nmemranges = 3;
}

/*
 * alloc_guest_mem
 *
 * Allocates memory for the guest.
 * Instead of doing a single allocation with one mmap(), we allocate memory
 * separately for every range for the following reasons:
 * - ASLR for the individual ranges
 * - to reduce memory consumption in the UVM subsystem: if vmm(4) had to
 *   map the single mmap'd userspace memory to the individual guest physical
 *   memory ranges, the underlying amap of the single mmap'd range would have
 *   to allocate per-page reference counters. The reason is that the
 *   individual guest physical ranges would reference the single mmap'd region
 *   only partially. However, if every guest physical range has its own
 *   corresponding mmap'd userspace allocation, there are no partial
 *   references: every guest physical range fully references an mmap'd
 *   range => no per-page reference counters have to be allocated.
 *
 * Return values:
 *  0: success
 *  !0: failure - errno indicating the source of the failure
 */
int
alloc_guest_mem(struct vm_create_params *vcp)
{
	void *p;
	int ret;
	size_t i, j;
	struct vm_mem_range *vmr;

	for (i = 0; i < vcp->vcp_nmemranges; i++) {
		vmr = &vcp->vcp_memranges[i];
		p = mmap(NULL, vmr->vmr_size, PROT_READ | PROT_WRITE,
		    MAP_PRIVATE | MAP_ANON, -1, 0);
		if (p == MAP_FAILED) {
			ret = errno;
			for (j = 0; j < i; j++) {
				vmr = &vcp->vcp_memranges[j];
				munmap((void *)vmr->vmr_va, vmr->vmr_size);
			}

			return (ret);
		}

		vmr->vmr_va = (vaddr_t)p;
	}

	return (0);
}

/*
 * vmm_create_vm
 *
 * Requests vmm(4) to create a new VM using the supplied creation
 * parameters. This operation results in the creation of the in-kernel
 * structures for the VM, but does not start the VM's vcpu(s).
 *
 * Parameters:
 *  vcp: vm_create_params struct containing the VM's desired creation
 *      configuration
 *
 * Return values:
 *  0: success
 *  !0 : ioctl to vmm(4) failed
 */
int
vmm_create_vm(struct vm_create_params *vcp)
{
	/* Sanity check arguments */
	if (vcp->vcp_ncpus > VMM_MAX_VCPUS_PER_VM)
		return (EINVAL);

	if (vcp->vcp_nmemranges == 0 ||
	    vcp->vcp_nmemranges > VMM_MAX_MEM_RANGES)
		return (EINVAL);

	if (vcp->vcp_ndisks > VMM_MAX_DISKS_PER_VM)
		return (EINVAL);

	if (vcp->vcp_nnics > VMM_MAX_NICS_PER_VM)
		return (EINVAL);

	if (ioctl(env->vmd_fd, VMM_IOC_CREATE, vcp) < 0)
		return (errno);

	return (0);
}

/*
 * init_emulated_hw
 *
 * Initializes the userspace hardware emulation
 */
void
init_emulated_hw(struct vm_create_params *vcp, int *child_disks,
    int *child_taps)
{
	int i;

	/* Reset the IO port map */
	memset(&ioports_map, 0, sizeof(io_fn_t) * MAX_PORTS);

	/* Init i8253 PIT */
	i8253_init(vcp->vcp_id);
	ioports_map[TIMER_CTRL] = vcpu_exit_i8253;
	ioports_map[TIMER_BASE + TIMER_CNTR0] = vcpu_exit_i8253;
	ioports_map[TIMER_BASE + TIMER_CNTR1] = vcpu_exit_i8253;
	ioports_map[TIMER_BASE + TIMER_CNTR2] = vcpu_exit_i8253;

	/* Init mc146818 RTC */
	mc146818_init(vcp->vcp_id);
	ioports_map[IO_RTC] = vcpu_exit_mc146818;
	ioports_map[IO_RTC + 1] = vcpu_exit_mc146818;

	/* Init master and slave PICs */
	i8259_init();
	ioports_map[IO_ICU1] = vcpu_exit_i8259;
	ioports_map[IO_ICU1 + 1] = vcpu_exit_i8259;
	ioports_map[IO_ICU2] = vcpu_exit_i8259;
	ioports_map[IO_ICU2 + 1] = vcpu_exit_i8259;

	/* Init ns8250 UART */
	ns8250_init(con_fd, vcp->vcp_id);
	for (i = COM1_DATA; i <= COM1_SCR; i++)
		ioports_map[i] = vcpu_exit_com;

	/* Initialize PCI */
	for (i = VMM_PCI_IO_BAR_BASE; i <= VMM_PCI_IO_BAR_END; i++)
		ioports_map[i] = vcpu_exit_pci;

	ioports_map[PCI_MODE1_ADDRESS_REG] = vcpu_exit_pci;
	ioports_map[PCI_MODE1_DATA_REG] = vcpu_exit_pci;
	pci_init();

	/* Initialize virtio devices */
	virtio_init(vcp, child_disks, child_taps);
}

/*
 * run_vm
 *
 * Runs the VM whose creation parameters are specified in vcp
 *
 * Parameters:
 *  child_disks: previously-opened child VM disk file file descriptors
 *  child_taps: previously-opened child tap file descriptors
 *  vcp: vm_create_params struct containing the VM's desired creation
 *      configuration
 *  vrs: VCPU register state to initialize
 *
 * Return values:
 *  0: the VM exited normally
 *  !0 : the VM exited abnormally or failed to start
 */
int
run_vm(int *child_disks, int *child_taps, struct vm_create_params *vcp,
    struct vcpu_reg_state *vrs)
{
	uint8_t evdone = 0;
	size_t i;
	int ret;
	pthread_t *tid, evtid;
	struct vm_run_params **vrp;
	void *exit_status;

	if (vcp == NULL)
		return (EINVAL);

	if (child_disks == NULL && vcp->vcp_ndisks != 0)
		return (EINVAL);

	if (child_taps == NULL && vcp->vcp_nnics != 0)
		return (EINVAL);

	if (vcp->vcp_ncpus > VMM_MAX_VCPUS_PER_VM)
		return (EINVAL);

	if (vcp->vcp_ndisks > VMM_MAX_DISKS_PER_VM)
		return (EINVAL);

	if (vcp->vcp_nnics > VMM_MAX_NICS_PER_VM)
		return (EINVAL);

	if (vcp->vcp_nmemranges == 0 ||
	    vcp->vcp_nmemranges > VMM_MAX_MEM_RANGES)
		return (EINVAL);

	tid = calloc(vcp->vcp_ncpus, sizeof(pthread_t));
	vrp = calloc(vcp->vcp_ncpus, sizeof(struct vm_run_params *));
	if (tid == NULL || vrp == NULL) {
		log_warn("%s: memory allocation error - exiting.",
		    __progname);
		return (ENOMEM);
	}

	log_debug("%s: initializing hardware for vm %s", __func__,
	    vcp->vcp_name);

	init_emulated_hw(vcp, child_disks, child_taps);

	ret = pthread_mutex_init(&threadmutex, NULL);
	if (ret) {
		log_warn("%s: could not initialize thread state mutex",
		    __func__);
		return (ret);
	}
	ret = pthread_cond_init(&threadcond, NULL);
	if (ret) {
		log_warn("%s: could not initialize thread state "
		    "condition variable", __func__);
		return (ret);
	}

	mutex_lock(&threadmutex);

	log_debug("%s: starting vcpu threads for vm %s", __func__,
	    vcp->vcp_name);

	/*
	 * Create and launch one thread for each VCPU. These threads may
	 * migrate between PCPUs over time; the need to reload CPU state
	 * in such situations is detected and performed by vmm(4) in the
	 * kernel.
	 */
	for (i = 0 ; i < vcp->vcp_ncpus; i++) {
		vrp[i] = malloc(sizeof(struct vm_run_params));
		if (vrp[i] == NULL) {
			log_warn("%s: memory allocation error - "
			    "exiting.", __progname);
			/* caller will exit, so skip free'ing */
			return (ENOMEM);
		}
		vrp[i]->vrp_exit = malloc(sizeof(union vm_exit));
		if (vrp[i]->vrp_exit == NULL) {
			log_warn("%s: memory allocation error - "
			    "exiting.", __progname);
			/* caller will exit, so skip free'ing */
			return (ENOMEM);
		}
		vrp[i]->vrp_vm_id = vcp->vcp_id;
		vrp[i]->vrp_vcpu_id = i;

		if (vcpu_reset(vcp->vcp_id, i, vrs)) {
			log_warnx("%s: cannot reset VCPU %zu - exiting.",
			    __progname, i);
			return (EIO);
		}

		ret = pthread_cond_init(&vcpu_run_cond[i], NULL);
		if (ret) {
			log_warnx("%s: cannot initialize cond var (%d)",
			    __progname, ret);
			return (ret);
		}

		ret = pthread_mutex_init(&vcpu_run_mtx[i], NULL);
		if (ret) {
			log_warnx("%s: cannot initialize mtx (%d)",
			    __progname, ret);
			return (ret);
		}

		vcpu_hlt[i] = 0;

		/* Start each VCPU run thread at vcpu_run_loop */
		ret = pthread_create(&tid[i], NULL, vcpu_run_loop, vrp[i]);
		if (ret) {
			/* caller will _exit after this return */
			ret = errno;
			log_warn("%s: could not create vcpu thread %zu",
			    __func__, i);
			return (ret);
		}
	}

	log_debug("%s: waiting on events for VM %s", __func__, vcp->vcp_name);
	ret = pthread_create(&evtid, NULL, event_thread, &evdone);
	if (ret) {
		errno = ret;
		log_warn("%s: could not create event thread", __func__);
		return (ret);
	}

	for (;;) {
		ret = pthread_cond_wait(&threadcond, &threadmutex);
		if (ret) {
			log_warn("%s: waiting on thread state condition "
			    "variable failed", __func__);
			return (ret);
		}

		/*
		 * Did a VCPU thread exit with an error? => return the first one
		 */
		for (i = 0; i < vcp->vcp_ncpus; i++) {
			if (vcpu_done[i] == 0)
				continue;

			if (pthread_join(tid[i], &exit_status)) {
				log_warn("%s: failed to join thread %zd - "
				    "exiting", __progname, i);
				return (EIO);
			}

			ret = (long long)exit_status;
		}

		/* Did the event thread exit? => return with an error */
		if (evdone) {
			if (pthread_join(evtid, &exit_status)) {
				log_warn("%s: failed to join event thread - "
				    "exiting", __progname);
				return (EIO);
			}

			log_warnx("%s: vm %d event thread exited "
			    "unexpectedly", __progname, vcp->vcp_id);
			return (EIO);
		}

		/* Did all VCPU threads exit successfully? => return */
		for (i = 0; i < vcp->vcp_ncpus; i++) {
			if (vcpu_done[i] == 0)
				break;
		}
		if (i == vcp->vcp_ncpus)
			return (ret);

		/* Some more threads to wait for, start over */
	}

	return (ret);
}

void *
event_thread(void *arg)
{
	uint8_t *donep = arg;
	intptr_t ret;

	ret = event_dispatch();

	mutex_lock(&threadmutex);
	*donep = 1;
	pthread_cond_signal(&threadcond);
	mutex_unlock(&threadmutex);

	return (void *)ret;
 }

/*
 * vcpu_run_loop
 *
 * Runs a single VCPU until vmm(4) requires help handling an exit,
 * or the VM terminates.
 *
 * Parameters:
 *  arg: vcpu_run_params for the VCPU being run by this thread
 *
 * Return values:
 *  NULL: the VCPU shutdown properly
 *  !NULL: error processing VCPU run, or the VCPU shutdown abnormally
 */
void *
vcpu_run_loop(void *arg)
{
	struct vm_run_params *vrp = (struct vm_run_params *)arg;
	intptr_t ret = 0;
	int irq;
	uint32_t n;

	vrp->vrp_continue = 0;
	n = vrp->vrp_vcpu_id;

	for (;;) {
		ret = pthread_mutex_lock(&vcpu_run_mtx[n]);

		if (ret) {
			log_warnx("%s: can't lock vcpu run mtx (%d)",
			    __func__, (int)ret);
			return ((void *)ret);
		}

		/* If we are halted, wait */
		if (vcpu_hlt[n]) {
			ret = pthread_cond_wait(&vcpu_run_cond[n],
			    &vcpu_run_mtx[n]);

			if (ret) {
				log_warnx("%s: can't wait on cond (%d)",
				    __func__, (int)ret);
				(void)pthread_mutex_unlock(&vcpu_run_mtx[n]);
				break;
			}
		}

		ret = pthread_mutex_unlock(&vcpu_run_mtx[n]);
		if (ret) {
			log_warnx("%s: can't unlock mutex on cond (%d)",
			    __func__, (int)ret);
			break;
		}

		if (vrp->vrp_irqready && i8259_is_pending()) {
			irq = i8259_ack();
			vrp->vrp_irq = irq;
		} else
			vrp->vrp_irq = 0xFFFF;

		/* Still more pending? */
		if (i8259_is_pending()) {
			/* XXX can probably avoid ioctls here by providing intr in vrp */
			if (vcpu_pic_intr(vrp->vrp_vm_id, vrp->vrp_vcpu_id, 1)) {
				fatal("can't set INTR");
			}
		} else {
			if (vcpu_pic_intr(vrp->vrp_vm_id, vrp->vrp_vcpu_id, 0)) {
				fatal("can't clear INTR");
			}
		}

		if (ioctl(env->vmd_fd, VMM_IOC_RUN, vrp) < 0) {
			/* If run ioctl failed, exit */
			ret = errno;
			log_warn("%s: vm %d / vcpu %d run ioctl failed",
			    __func__, vrp->vrp_vm_id, n);
			break;
		}

		/* If the VM is terminating, exit normally */
		if (vrp->vrp_exit_reason == VM_EXIT_TERMINATED) {
			ret = (intptr_t)NULL;
			break;
		}

		if (vrp->vrp_exit_reason != VM_EXIT_NONE) {
			/*
			 * vmm(4) needs help handling an exit, handle in
			 * vcpu_exit.
			 */
			ret = vcpu_exit(vrp);
			if (ret)
				break;
		}
	}

	mutex_lock(&threadmutex);
	vcpu_done[n] = 1;
	pthread_cond_signal(&threadcond);
	mutex_unlock(&threadmutex);

	return ((void *)ret);
}

int
vcpu_pic_intr(uint32_t vm_id, uint32_t vcpu_id, uint8_t intr)
{
	struct vm_intr_params vip;

	memset(&vip, 0, sizeof(vip));

	vip.vip_vm_id = vm_id;
	vip.vip_vcpu_id = vcpu_id; /* XXX always 0? */
	vip.vip_intr = intr;

	if (ioctl(env->vmd_fd, VMM_IOC_INTR, &vip) < 0)
		return (errno);

	return (0);
}

/*
 * vcpu_exit_pci
 *
 * Handle all I/O to the emulated PCI subsystem.
 *
 * Parameters:
 *  vrp: vcpu run paramters containing guest state for this exit
 *
 * Return value:
 *  Interrupt to inject to the guest VM, or 0xFF if no interrupt should
 *      be injected.
 */
uint8_t
vcpu_exit_pci(struct vm_run_params *vrp)
{
	union vm_exit *vei = vrp->vrp_exit;
	uint8_t intr;

	intr = 0xFF;

	switch (vei->vei.vei_port) {
	case PCI_MODE1_ADDRESS_REG:
		pci_handle_address_reg(vrp);
		break;
	case PCI_MODE1_DATA_REG:
		pci_handle_data_reg(vrp);
		break;
	case VMM_PCI_IO_BAR_BASE ... VMM_PCI_IO_BAR_END:
		intr = pci_handle_io(vrp);
		break;
	default:
		log_warnx("%s: unknown PCI register 0x%llx",
		    __progname, (uint64_t)vei->vei.vei_port);
		break;
	}

	return (intr);
}

/*
 * vcpu_exit_inout
 *
 * Handle all I/O exits that need to be emulated in vmd. This includes the
 * i8253 PIT, the com1 ns8250 UART, and the MC146818 RTC/NVRAM device.
 *
 * Parameters:
 *  vrp: vcpu run parameters containing guest state for this exit
 */
void
vcpu_exit_inout(struct vm_run_params *vrp)
{
	union vm_exit *vei = vrp->vrp_exit;
	uint8_t intr = 0xFF;

	if (ioports_map[vei->vei.vei_port] != NULL)
		intr = ioports_map[vei->vei.vei_port](vrp);
	else if (vei->vei.vei_dir == VEI_DIR_IN)
			vei->vei.vei_data = 0xFFFFFFFF;

	if (intr != 0xFF)
		vcpu_assert_pic_irq(vrp->vrp_vm_id, vrp->vrp_vcpu_id, intr);
}

/*
 * vcpu_exit
 *
 * Handle a vcpu exit. This function is called when it is determined that
 * vmm(4) requires the assistance of vmd to support a particular guest
 * exit type (eg, accessing an I/O port or device). Guest state is contained
 * in 'vrp', and will be resent to vmm(4) on exit completion.
 *
 * Upon conclusion of handling the exit, the function determines if any
 * interrupts should be injected into the guest, and asserts the proper
 * IRQ line whose interrupt should be vectored.
 *
 * Parameters:
 *  vrp: vcpu run parameters containing guest state for this exit
 *
 * Return values:
 *  0: the exit was handled successfully
 *  1: an error occurred (eg, unknown exit reason passed in 'vrp')
 */
int
vcpu_exit(struct vm_run_params *vrp)
{
	int ret;

	switch (vrp->vrp_exit_reason) {
	case VMX_EXIT_INT_WINDOW:
	case VMX_EXIT_EXTINT:
	case VMX_EXIT_EPT_VIOLATION:
	case SVM_VMEXIT_NPF:
		/*
		 * We may be exiting to vmd to handle a pending interrupt but
		 * at the same time the last exit type may have been one of
		 * these. In this case, there's nothing extra to be done
		 * here (and falling through to the default case below results
		 * in more vmd log spam).
		 */
		break;
	case VMX_EXIT_IO:
	case SVM_VMEXIT_IOIO:
		vcpu_exit_inout(vrp);
		break;
	case VMX_EXIT_HLT:
	case SVM_VMEXIT_HLT:
		ret = pthread_mutex_lock(&vcpu_run_mtx[vrp->vrp_vcpu_id]);
		if (ret) {
			log_warnx("%s: can't lock vcpu mutex (%d)",
			    __func__, ret);
			return (ret);
		}
		vcpu_hlt[vrp->vrp_vcpu_id] = 1;
		ret = pthread_mutex_unlock(&vcpu_run_mtx[vrp->vrp_vcpu_id]);
		if (ret) {
			log_warnx("%s: can't unlock vcpu mutex (%d)",
			    __func__, ret);
			return (ret);
		}
		break;
	case VMX_EXIT_TRIPLE_FAULT:
	case SVM_VMEXIT_SHUTDOWN:
		/* XXX reset VM since we do not support reboot yet */
		return (EAGAIN);
	default:
		log_debug("%s: unknown exit reason %d",
		    __progname, vrp->vrp_exit_reason);
	}

	/* Process any pending traffic */
	vionet_process_rx(vrp->vrp_vm_id);

	vrp->vrp_continue = 1;

	return (0);
}

/*
 * find_gpa_range
 *
 * Search for a contiguous guest physical mem range.
 *
 * Parameters:
 *  vcp: VM create parameters that contain the memory map to search in
 *  gpa: the starting guest physical address
 *  len: the length of the memory range
 *
 * Return values:
 *  NULL: on failure if there is no memory range as described by the parameters
 *  Pointer to vm_mem_range that contains the start of the range otherwise.
 */
static struct vm_mem_range *
find_gpa_range(struct vm_create_params *vcp, paddr_t gpa, size_t len)
{
	size_t i, n;
	struct vm_mem_range *vmr;

	/* Find the first vm_mem_range that contains gpa */
	for (i = 0; i < vcp->vcp_nmemranges; i++) {
		vmr = &vcp->vcp_memranges[i];
		if (vmr->vmr_gpa + vmr->vmr_size >= gpa)
			break;
	}

	/* No range found. */
	if (i == vcp->vcp_nmemranges)
		return (NULL);

	/*
	 * vmr may cover the range [gpa, gpa + len) only partly. Make
	 * sure that the following vm_mem_ranges are contiguous and
	 * cover the rest.
	 */
	n = vmr->vmr_size - (gpa - vmr->vmr_gpa);
	if (len < n)
		len = 0;
	else
		len -= n;
	gpa = vmr->vmr_gpa + vmr->vmr_size;
	for (i = i + 1; len != 0 && i < vcp->vcp_nmemranges; i++) {
		vmr = &vcp->vcp_memranges[i];
		if (gpa != vmr->vmr_gpa)
			return (NULL);
		if (len <= vmr->vmr_size)
			len = 0;
		else
			len -= vmr->vmr_size;

		gpa = vmr->vmr_gpa + vmr->vmr_size;
	}

	if (len != 0)
		return (NULL);

	return (vmr);
}

/*
 * write_mem
 *
 * Copies data from 'buf' into the guest VM's memory at paddr 'dst'.
 *
 * Parameters:
 *  dst: the destination paddr_t in the guest VM
 *  buf: data to copy
 *  len: number of bytes to copy
 *
 * Return values:
 *  0: success
 *  EINVAL: if the guest physical memory range [dst, dst + len) does not
 *      exist in the guest.
 */
int
write_mem(paddr_t dst, void *buf, size_t len)
{
	char *from = buf, *to;
	size_t n, off;
	struct vm_mem_range *vmr;

	vmr = find_gpa_range(&current_vm->vm_params.vmc_params, dst, len);
	if (vmr == NULL) {
		errno = EINVAL;
		log_warn("%s: failed - invalid memory range dst = 0x%lx, "
		    "len = 0x%zx", __func__, dst, len);
		return (EINVAL);
	}

	off = dst - vmr->vmr_gpa;
	while (len != 0) {
		n = vmr->vmr_size - off;
		if (len < n)
			n = len;

		to = (char *)vmr->vmr_va + off;
		memcpy(to, from, n);

		from += n;
		len -= n;
		off = 0;
		vmr++;
	}

	return (0);
}

/*
 * read_mem
 *
 * Reads memory at guest paddr 'src' into 'buf'.
 *
 * Parameters:
 *  src: the source paddr_t in the guest VM to read from.
 *  buf: destination (local) buffer
 *  len: number of bytes to read
 *
 * Return values:
 *  0: success
 *  EINVAL: if the guest physical memory range [dst, dst + len) does not
 *      exist in the guest.
 */
int
read_mem(paddr_t src, void *buf, size_t len)
{
	char *from, *to = buf;
	size_t n, off;
	struct vm_mem_range *vmr;

	vmr = find_gpa_range(&current_vm->vm_params.vmc_params, src, len);
	if (vmr == NULL) {
		errno = EINVAL;
		log_warn("%s: failed - invalid memory range src = 0x%lx, "
		    "len = 0x%zx", __func__, src, len);
		return (EINVAL);
	}

	off = src - vmr->vmr_gpa;
	while (len != 0) {
		n = vmr->vmr_size - off;
		if (len < n)
			n = len;

		from = (char *)vmr->vmr_va + off;
		memcpy(to, from, n);

		to += n;
		len -= n;
		off = 0;
		vmr++;
	}

	return (0);
}

/*
 * vcpu_assert_pic_irq
 *
 * Injects the specified IRQ on the supplied vcpu/vm
 *
 * Parameters:
 *  vm_id: VM ID to inject to
 *  vcpu_id: VCPU ID to inject to
 *  irq: IRQ to inject
 */
void
vcpu_assert_pic_irq(uint32_t vm_id, uint32_t vcpu_id, int irq)
{
	int ret;

	i8259_assert_irq(irq);

	if (i8259_is_pending()) {
		if (vcpu_pic_intr(vm_id, vcpu_id, 1))
			fatalx("%s: can't assert INTR", __func__);

		ret = pthread_mutex_lock(&vcpu_run_mtx[vcpu_id]);
		if (ret)
			fatalx("%s: can't lock vcpu mtx (%d)", __func__, ret);

		vcpu_hlt[vcpu_id] = 0;
		ret = pthread_cond_signal(&vcpu_run_cond[vcpu_id]);
		if (ret)
			fatalx("%s: can't signal (%d)", __func__, ret);
		ret = pthread_mutex_unlock(&vcpu_run_mtx[vcpu_id]);
		if (ret)
			fatalx("%s: can't unlock vcpu mtx (%d)", __func__, ret);
	}
}

/*
 * fd_hasdata
 *
 * Determines if data can be read from a file descriptor.
 *
 * Parameters:
 *  fd: the fd to check
 *
 * Return values:
 *  1 if data can be read from an fd, or 0 otherwise.
 */
int
fd_hasdata(int fd)
{
	struct pollfd pfd[1];
	int nready, hasdata = 0;

	pfd[0].fd = fd;
	pfd[0].events = POLLIN;
	nready = poll(pfd, 1, 0);
	if (nready == -1)
		log_warn("checking file descriptor for data failed");
	else if (nready == 1 && pfd[0].revents & POLLIN)
		hasdata = 1;
	return (hasdata);
}

/*
 * mutex_lock
 *
 * Wrapper function for pthread_mutex_lock that does error checking and that
 * exits on failure
 */
void
mutex_lock(pthread_mutex_t *m)
{
	int ret;

	ret = pthread_mutex_lock(m);
	if (ret) {
		errno = ret;
		fatal("could not acquire mutex");
	}
}

/*
 * mutex_unlock
 *
 * Wrapper function for pthread_mutex_unlock that does error checking and that
 * exits on failure
 */
void
mutex_unlock(pthread_mutex_t *m)
{
	int ret;

	ret = pthread_mutex_unlock(m);
	if (ret) {
		errno = ret;
		fatal("could not release mutex");
	}
@


1.64
log
@Nuke some whitespace that keeps poking me in the eye as I try to
steal code.
@
text
@d1 1
a1 1
/*	$OpenBSD: vmm.c,v 1.63 2017/01/13 14:50:56 reyk Exp $	*/
d1489 1
d1499 1
d1503 1
d1519 1
@


1.63
log
@Add host side of vmmci(4) to vmd(8).

It currently uses the device to request graceful shutdown of a VM on
"vmctl stop myvm" but will be extended for reboot and a other edge cases.

OK mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmm.c,v 1.62 2017/01/11 22:38:10 reyk Exp $	*/
d169 1
a169 1
 	 * stdio - for malloc and basic I/O including events.
d371 1
a371 1
 * 
d731 1
a731 1
	 	 * stdio - for malloc and basic I/O including events.
d740 1
a740 1
	 	 */
d1028 1
a1028 1
	
d1056 1
a1056 1
	
d1456 1
a1456 1
	
@


1.62
log
@Add imsg communication channel between vmd and invividual VMs.
For now, this is only used to forward "log verbose|brief" requests,
but it will be used for better things later.

OK mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmm.c,v 1.61 2017/01/08 21:23:32 mlarkin Exp $	*/
d222 24
a245 1
		res = terminate_vm(&vtp);
a246 3
		/* Remove local reference if it exists */
		if ((vm = vm_getbyid(id)) != NULL)
			vm_remove(vm);
d339 4
d500 8
@


1.61
log
@Reduce "vmd -v" spam a bit by not printing useless exit information. These
were being printed because vmm(4) was in the middle of processing an exit
that vmd(8) didn't care about, but still exited to vmd(8) because of
a pending interrupt.
@
text
@d1 1
a1 1
/*	$OpenBSD: vmm.c,v 1.60 2016/12/14 17:56:19 reyk Exp $	*/
d86 4
d185 1
a185 1
	int			 res = 0, cmd = 0;
d244 12
d365 122
a660 1
		close(fds[0]);
d667 3
a690 1
		close(fds[1]);
d736 5
a1080 2

	event_init();
@


1.60
log
@Allow a guest to reboot by reinitializing its state and booting again.
This is technically a reset since memory is cleared and the dmesg
buffer is lost.

Patch from Jon Bernard (jbernard at jbernard.io) - Thanks

OK reyk@@ mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmm.c,v 1.59 2016/11/30 19:27:21 reyk Exp $	*/
d1312 11
a1339 2
		break;
	case VMX_EXIT_INT_WINDOW:
@


1.59
log
@Always remove the local vm after calling terminate_vm().
@
text
@d1 1
a1 1
/*	$OpenBSD: vmm.c,v 1.58 2016/11/26 20:03:42 reyk Exp $	*/
d275 1
a275 1
	int status;
d300 3
d307 1
a307 1
					vmr.vmr_result = 0;
d600 1
a600 1
		_exit(ret != 0);
d1057 1
a1057 6
			if (exit_status != NULL) {
				log_warnx("%s: vm %d vcpu run thread %zd "
				    "exited abnormally", __progname,
				    vcp->vcp_id, i);
				return (EIO);
			}
d1073 1
a1073 1
		/* Did all VCPU threads exit successfully? => return 0 */
d1079 1
a1079 1
			return (0);
a1081 1

d1084 1
a1084 1
	return (0);
d1193 2
a1194 2
			if (vcpu_exit(vrp)) {
				ret = EIO;
a1195 1
			}
d1320 1
a1320 1
			return (1);
d1327 1
a1327 1
			return (1);
d1333 2
a1334 2
		log_warnx("%s: triple fault", __progname);
		return (1);
@


1.58
log
@Implement basic support for boot.conf(8) on the disk image.

Like the real boot loader, load and parse hd0a:/etc/boot.conf from the
first disk and fall back to /bsd.  Not all boot loader options are
supported, but it at least does set device, set image, and boot -acds
(eg. for booting single-user).

For example, it can now boot install60.fs that includes a boot.conf
with "set image /6.0/amd64/bsd.rd":
	vmctl start install -c -d install60.fs -d OpenBSD.img

This pseudo-bootloader is only needed without BIOS and could
potentially be replaced in the future.

OK mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmm.c,v 1.57 2016/11/26 15:29:33 martijn Exp $	*/
d220 3
a222 5
		if (res == 0) {
			/* Remove local reference if it exists */
			if ((vm = vm_getbyid(id)) != NULL)
				vm_remove(vm);
		}
a305 1
					vm_remove(vm);
d315 2
d341 2
a342 2
		if (terminate_vm(&vtp) == ENOENT)
			vm_remove(vm);
@


1.57
log
@Remove start_client_vmd.
It was nothing more than a wrapper around fork(2).

OK edd@@ and mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmm.c,v 1.56 2016/11/24 07:58:55 reyk Exp $	*/
d463 1
a469 1
	void			*boot;
d572 1
a572 1
		    vm->vm_disks[0], &boot)) == NULL)
d576 2
a577 1
		ret = loadelf_main(kernfp, vcp, &vrs);
d583 1
a583 1
		vmboot_close(kernfp, boot);
@


1.56
log
@Add support for booting the kernel from the disk image.

This make the kernel/-k argument optional and, if not specified, tries
to find the /bsd kernel in the primary hd0a partition of the first
disk image itself.  It doesn't support hd0a:/etc/boot.conf yet, and it
is no BIOS or full boot loader, but it makes booting and handling of
VMs a bit easier - booting an external kernel is still supported.

The UFS file system code ufs.c is directly from libsa which is also
used by the real boot loader.  The code compiles with a few signedness
warning which will be fixed separately.

OK mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmm.c,v 1.55 2016/11/22 22:51:45 reyk Exp $	*/
a66 1
int start_client_vmd(void);
d487 1
a487 1
	ret = start_client_vmd();
a686 32
}


/*
 * start_client_vmd
 *
 * forks a copy of the parent vmd, chroots to VMD_USER's home, drops
 * privileges (changes to user VMD_USER), and returns.
 * Should the fork operation succeed, but later chroot/privsep
 * fail, the child exits.
 *
 * Return values (returns to both child and parent on success):
 *  -1 : failure
 *  0: return to child vmd returns 0
 *  !0 : return to parent vmd returns the child's pid
 */
int
start_client_vmd(void)
{
	int child_pid;

	child_pid = fork();
	if (child_pid < 0)
		return (-1);

	if (!child_pid) {
		/* child, already running without privileges */
		return (0);
	}

	/* Parent */
	return (child_pid);
@


1.55
log
@Don't attempt to call vm_remove() with a NULL vm: some functions like
config_getvm() already removed the vm on failure!

Found by mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmm.c,v 1.54 2016/11/04 15:07:26 reyk Exp $	*/
d468 3
a470 1
	struct vcpu_reg_state vrs;
d571 5
d577 1
a577 1
		ret = loadelf_main(vm->vm_kernel, vcp, &vrs);
d583 4
a586 1
		close(vm->vm_kernel);
@


1.54
log
@Update the config/register/get VM methods to match the config_set/get
style that is used in other places.  Also keep the vmid from the parent.

OK edd@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmm.c,v 1.53 2016/10/29 14:56:05 edd Exp $	*/
d222 3
a224 3
			/* Remove local reference */
			vm = vm_getbyid(id);
			vm_remove(vm);
d252 3
a254 2
			vm = vm_getbyvmid(imsg->hdr.peerid);
			vm_remove(vm);
@


1.53
log
@Separate parsing vms and switches from starting them in vmd(8).

Brings us one step closer to having disabled by default vms is vm.conf(5),
which can be started with vmctl(8).

Input, testing and OK reyk@@. Thanks.
@
text
@d1 1
a1 1
/*	$OpenBSD: vmm.c,v 1.52 2016/10/26 05:26:36 mlarkin Exp $	*/
d183 1
a183 1
	struct vmop_create_params vmc;
a186 1
	struct vmd_vm		*vm;
d191 1
a191 3
		IMSG_SIZE_CHECK(imsg, &vmc);
		memcpy(&vmc, imsg->data, sizeof(vmc));
		res = config_registervm(ps, &vmc, &vm);
a194 7
		} else {
			res = config_getvm(ps, vm, imsg->fd, imsg->hdr.peerid);
			if (res == -1) {
				res = errno;
				cmd = IMSG_VMDOP_START_VM_RESPONSE;
				vm_remove(vm);
			}
@


1.52
log
@
vmd(8)/vmctl(8) for i386. Some ugliness in #ifdef __i386__ areas will be
fixed in tree, but the changes required were pretty minimal.

Note that i386 hosts are still presently limited to running i386 guests.

ok deraadt, stefan, jca
@
text
@d1 1
a1 1
/*	$OpenBSD: vmm.c,v 1.51 2016/10/12 19:10:03 reyk Exp $	*/
d194 1
a194 1
		res = config_getvm(ps, &vmc, imsg->fd, imsg->hdr.peerid);
d198 7
d312 1
a312 1
				vmid = vm->vm_params.vcp_id;
d349 1
a349 1
		vtp.vtp_vm_id = vm->vm_params.vcp_id;
d484 1
a484 1
	vcp = &vm->vm_params;
d1466 1
a1466 1
	vmr = find_gpa_range(&current_vm->vm_params, dst, len);
d1514 1
a1514 1
	vmr = find_gpa_range(&current_vm->vm_params, src, len);
@


1.51
log
@Fix functionality and semantics of vmctl load/reload/reset.

OK rzalamena@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmm.c,v 1.50 2016/10/12 06:56:54 mlarkin Exp $	*/
d125 5
d133 1
@


1.50
log
@
Allow 4 vio(4) interfaces in each VM. Also fix a bad interrupt assignment that
caused IRQ9 to be shared between the second disk device and the vio(4)s,
which caused poor network performance.

ok reyk, stefan
@
text
@d1 1
a1 1
/*	$OpenBSD: vmm.c,v 1.49 2016/10/06 20:41:28 reyk Exp $	*/
d182 1
d229 9
d339 2
a340 1
		terminate_vm(&vtp);
@


1.49
log
@Enable pledge(2) in vmm and the VM processes: This way the VMs and
their monitor run in a very restricted environment.  VMs only pledge
"stdio vmm" which allows them to do most basic functions and a subset
of vmm ioctls (the other part of vmm ioctls are only permitted in the
parent).

This requires the previous change in the vmm kernel part.

OK mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmm.c,v 1.48 2016/10/06 18:48:41 reyk Exp $	*/
d1352 2
a1353 3
	/* XXX this may not be irq 9 all the time */
	if (vionet_process_rx())
		vcpu_assert_pic_irq(vrp->vrp_vm_id, vrp->vrp_vcpu_id, 9);
@


1.48
log
@Terminate VMs on shutdown of vmd instead of leaving them running as
undead VM processes.

OK mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmm.c,v 1.47 2016/10/05 17:30:13 reyk Exp $	*/
a157 1
#if 0
d165 1
a165 2
	/* XXX'ed pledge to hide it from grep as long as it's disabled */
	if (XXX("stdio vmm recvfd proc", NULL) == -1)
a166 1
#endif
a539 1
#if 0
d545 1
a545 1
		if (XXX("stdio vmm", NULL) == -1)
a546 1
#endif
@


1.47
log
@Add support for enhanced networking configuration and virtual switches.
See vm.conf(5) for more details.

OK mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmm.c,v 1.46 2016/10/04 17:17:30 reyk Exp $	*/
d314 19
@


1.46
log
@Add a new "priv" process that is responsible for ioctls and restricted
operations that aren't allowed under pledge.  This is a companion to
the "vmd" process that runs as root but with pledge.

With the "priv" process, each new tap(4) interface now gets a
description to indicate the vm, eg. "vm1-if0-myvm".  For network
configuration will be done by vmd/priv later.

OK mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmm.c,v 1.45 2016/09/29 22:42:04 reyk Exp $	*/
d180 1
a180 1
	struct vm_create_params	 vcp;
d188 3
a190 3
		IMSG_SIZE_CHECK(imsg, &vcp);
		memcpy(&vcp, imsg->data, sizeof(vcp));
		res = config_getvm(ps, &vcp, imsg->fd, imsg->hdr.peerid);
d391 1
d436 1
a436 1
	int			 fds[2];
d474 2
a475 2
			close(vm->vm_ifs[i]);
			vm->vm_ifs[i] = -1;
d553 3
d557 1
a557 1
		ret = run_vm(vm->vm_disks, vm->vm_ifs, vcp, &vrs);
@


1.45
log
@Implement fork+exec for vmd, using the same framework from httpd etc.

No objections from mlarkin@@ sunil@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmm.c,v 1.44 2016/09/03 11:38:08 mlarkin Exp $	*/
d37 2
d68 1
a68 1
int opentap(void);
d379 3
d386 1
a386 1
opentap(void)
d394 3
a396 1
		if (fd != -1)
d398 1
@


1.44
log
@
As vmm(4) can now exit to vmd at any time to process pending interrupts,
don't kill the VM if we are presented with an exit type that is not
something we directly need to handle. Instead, simply re-enter the guest,
possibly injecting an interrupt along the way. Still exit the process
if presented with a triple fault, until we implement reboot support.

ok stefan@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmm.c,v 1.43 2016/09/02 17:10:08 stefan Exp $	*/
d140 1
a140 1
pid_t
d143 1
a143 1
	return (proc_run(ps, p, procs, nitems(procs), vmm_run, NULL));
@


1.43
log
@Process incoming com data asynchronously to running VCPU

This registers a handler with libevent that is triggered on incoming
data on the com port.

ok mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmm.c,v 1.42 2016/09/02 16:23:40 stefan Exp $	*/
d1318 3
d1322 1
a1322 1
		log_warnx("%s: unknown exit reason %d",
a1323 1
		return (1);
@


1.42
log
@Move event handling to separate thread

That allows the main thread to handle the termination
of a VM on reboot/shutdown or normal exit. The way it works
is that VCPUs that terminate for some reason communicate this
to a main thread that takes care of shutdown.

ok mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmm.c,v 1.41 2016/09/01 17:09:33 mlarkin Exp $	*/
d852 1
a852 1
	ns8250_init(con_fd);
a1324 1
	/* XXX change this to poll on the tap interface */
a1326 4

	/* XXX temporary until this is polled */
	if (vcpu_com1_needs_intr())
		vcpu_assert_pic_irq(vrp->vrp_vm_id, vrp->vrp_vcpu_id, 4);
@


1.41
log
@
fix a merge collision, and add some retval checking on various pthread_*
functions
@
text
@d1 1
a1 1
/*	$OpenBSD: vmm.c,v 1.40 2016/09/01 16:40:06 mlarkin Exp $	*/
d71 1
d95 3
d101 1
d888 1
d891 1
a891 1
	pthread_t *tid;
a892 1
#if 0
a893 1
#endif
a916 2
	ret = 0;

d932 15
d1000 3
d1008 35
a1042 1
	ret = event_dispatch();
d1044 7
a1050 2
#if 0
	/* XXX need to handle clean exits now */
d1052 2
a1053 5
	/* Wait for all the threads to exit */
	for (i = 0; i < vcp->vcp_ncpus; i++) {
		if (pthread_join(tid[i], &exit_status)) {
			log_warnx("%s: failed to join thread %zd - "
			    "exiting", __progname, i);
d1057 4
a1060 4
		if (exit_status != NULL) {
			log_warnx("%s: vm %d vcpu run thread %zd exited "
			    "abnormally", __progname, vcp->vcp_id, i);
			ret = EIO;
d1062 5
a1067 1
#endif
d1069 1
a1069 1
	return (ret);
d1072 16
d1105 1
a1105 1
	intptr_t ret;
d1130 1
a1130 1
				return ((void *)ret);
d1138 1
a1138 1
			return ((void *)ret);
d1164 1
a1164 1
			return ((void *)ret);
d1168 4
a1171 2
		if (vrp->vrp_exit_reason == VM_EXIT_TERMINATED)
			return (NULL);
d1178 4
a1181 2
			if (vcpu_exit(vrp))
				return ((void *)EIO);
d1185 6
a1190 1
	return (NULL);
d1554 36
@


1.40
log
@
change some log_warn to log_warnx and convert some integer literals to
enumerand values
@
text
@d1 1
a1 1
/*	$OpenBSD: vmm.c,v 1.39 2016/09/01 16:04:47 stefan Exp $	*/
d957 1
a957 1
		if (vcpu_reset(vcp->vcp_id, i, vis)) {
d1053 1
a1053 1
				pthread_mutex_unlock(&vcpu_run_mtx[n]);
d1058 6
a1063 2
		/* XXX check retval for pthread_mutex_unlock */
		pthread_mutex_unlock(&vcpu_run_mtx[n]);
d1210 2
d1217 6
a1222 2
		/* XXX check retvals in these fns */
		pthread_mutex_lock(&vcpu_run_mtx[vrp->vrp_vcpu_id]);
d1224 6
a1229 1
		pthread_mutex_unlock(&vcpu_run_mtx[vrp->vrp_vcpu_id]);
d1422 2
d1427 1
a1427 1
		if (vcpu_pic_intr(vm_id, vcpu_id, 1)) {
a1428 1
		}
d1430 4
a1433 1
		pthread_mutex_lock(&vcpu_run_mtx[vcpu_id]);
d1435 6
a1440 2
		pthread_cond_signal(&vcpu_run_cond[vcpu_id]);
		pthread_mutex_unlock(&vcpu_run_mtx[vcpu_id]);
@


1.39
log
@Make vcpu_reset_regs use new writeregs code

Makes reset code a little simpler. ok mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmm.c,v 1.38 2016/09/01 14:48:09 mlarkin Exp $	*/
d426 1
a426 1
		log_warn("%s: can't find vm", __func__);
d433 1
a433 1
		log_warn("%s: can't get tty", __func__);
d445 1
a445 1
		log_warn("%s: start child failed", __func__);
d957 2
a958 2
		if (vcpu_reset(vcp->vcp_id, i, vrs)) {
			log_warn("%s: cannot reset VCPU %zu - exiting.",
d965 1
a965 1
			log_warn("%s: cannot initialize cond var (%d)",
d972 1
a972 1
			log_warn("%s: cannot initialize mtx (%d)",
d996 1
a996 1
			log_warn("%s: failed to join thread %zd - "
d1040 1
a1040 1
			log_warn("%s: can't lock vcpu run mtx (%d)",
d1051 1
a1051 1
				log_warn("%s: can't wait on cond (%d)",
d1082 2
a1083 2
			log_warn("%s: vm %d / vcpu %d run ioctl failed (%d)",
			    __func__, vrp->vrp_vm_id, n, errno);
d1177 1
a1177 1
	else if (vei->vei.vei_dir == 1)
@


1.38
log
@
Add a set of emulated legacy devices (PIT, PIC, RTC)

discussed with stefan and deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: vmm.c,v 1.37 2016/08/31 06:55:39 mlarkin Exp $	*/
d70 1
a70 1
int run_vm(int *, int *, struct vm_create_params *, struct vcpu_init_state *);
d73 1
a73 1
int vcpu_reset(uint32_t, uint32_t, struct vcpu_init_state *);
d117 16
a132 16
static const struct vcpu_init_state vcpu_init_flat32 = {
	0x2,					/* RFLAGS */
	0x0,					/* RIP */
	0x0,					/* RSP */
	CR0_CD | CR0_NW | CR0_ET | CR0_PE | CR0_PG, /* CR0 */
	PML4_PAGE,				/* CR3 */
	{ 0x8, 0xFFFFFFFF, 0xC09F, 0x0},	/* CS */
	{ 0x10, 0xFFFFFFFF, 0xC093, 0x0},	/* DS */
	{ 0x10, 0xFFFFFFFF, 0xC093, 0x0},	/* ES */
	{ 0x10, 0xFFFFFFFF, 0xC093, 0x0},	/* FS */
	{ 0x10, 0xFFFFFFFF, 0xC093, 0x0},	/* GS */
	{ 0x10, 0xFFFFFFFF, 0xC093, 0x0},	/* SS */
	{ 0x0, 0xFFFF, 0x0, 0x0},		/* GDTR */
	{ 0x0, 0xFFFF, 0x0, 0x0},		/* IDTR */
	{ 0x0, 0xFFFF, 0x0082, 0x0},		/* LDTR */
	{ 0x0, 0xFFFF, 0x008B, 0x0},		/* TR */
d319 1
a319 1
 *  vis: the register state to initialize 
d327 1
a327 1
vcpu_reset(uint32_t vmid, uint32_t vcpu_id, struct vcpu_init_state *vis)
d334 1
a334 1
	memcpy(&vrp.vrp_init_state, vis, sizeof(struct vcpu_init_state));
d423 1
a423 1
	struct vcpu_init_state vis;
d524 1
a524 1
		memcpy(&vis, &vcpu_init_flat32, sizeof(struct vcpu_init_state));
d527 1
a527 1
		ret = loadelf_main(vm->vm_kernel, vcp, &vis);
d540 1
a540 1
		ret = run_vm(vm->vm_disks, vm->vm_ifs, vcp, &vis);
d873 1
a873 1
 *  vis: VCPU register state to initialize
d881 1
a881 1
    struct vcpu_init_state *vis)
d957 1
a957 1
		if (vcpu_reset(vcp->vcp_id, i, vis)) {
@


1.37
log
@
Style, and clarify some out of date comments
@
text
@d1 1
a1 1
/*	$OpenBSD: vmm.c,v 1.36 2016/08/17 05:07:13 deraadt Exp $	*/
a27 1
#include <dev/ic/comreg.h>
d32 2
d38 1
d44 1
d52 1
d57 4
a61 50
#define MAX_PORTS 65536

/*
 * Emulated 8250 UART
 */
#define COM1_DATA	0x3f8
#define COM1_IER	0x3f9
#define COM1_IIR	0x3fa
#define COM1_LCR	0x3fb
#define COM1_MCR	0x3fc
#define COM1_LSR	0x3fd
#define COM1_MSR	0x3fe
#define COM1_SCR	0x3ff

/*
 * Emulated i8253 PIT (counter)
 */
#define TIMER_BASE	0x40
#define TIMER_CTRL	0x43	/* 8253 Timer #1 */
#define NS_PER_TICK	(1000000000 / TIMER_FREQ)

/* i8253 registers */
struct i8253_counter {
	struct timeval tv;	/* timer start time */
	uint16_t start;		/* starting value */
	uint16_t olatch;	/* output latch */
	uint16_t ilatch;	/* input latch */
	uint8_t last_r;		/* last read byte (MSB/LSB) */
	uint8_t last_w;		/* last written byte (MSB/LSB) */
};

/* ns8250 UART registers */
struct ns8250_regs {
	uint8_t lcr;		/* Line Control Register */
	uint8_t fcr;		/* FIFO Control Register */
	uint8_t iir;		/* Interrupt ID Register */
	uint8_t ier;		/* Interrupt Enable Register */
	uint8_t divlo;		/* Baud rate divisor low byte */
	uint8_t divhi;		/* Baud rate divisor high byte */
	uint8_t msr;		/* Modem Status Register */
	uint8_t lsr;		/* Line Status Register */
	uint8_t mcr;		/* Modem Control Register */
	uint8_t scr;		/* Scratch Register */
	uint8_t data;		/* Unread input data */
};

typedef uint8_t (*io_fn_t)(struct vm_run_params *);

struct i8253_counter i8253_counter[3];
struct ns8250_regs com1_regs;
a79 11
uint8_t vcpu_exit_i8253(struct vm_run_params *);
uint8_t vcpu_exit_com(struct vm_run_params *);
void vcpu_process_com_data(union vm_exit *);
void vcpu_process_com_lcr(union vm_exit *);
void vcpu_process_com_lsr(union vm_exit *);
void vcpu_process_com_ier(union vm_exit *);
void vcpu_process_com_mcr(union vm_exit *);
void vcpu_process_com_iir(union vm_exit *);
void vcpu_process_com_msr(union vm_exit *);
void vcpu_process_com_scr(union vm_exit *);

d82 1
d94 4
d336 2
d620 1
a620 1
			log_debug("%s: terminated id %d",
d827 2
a828 8
	/* Init the i8253 PIT's 3 counters */
	memset(&i8253_counter, 0, sizeof(struct i8253_counter) * 3);
	gettimeofday(&i8253_counter[0].tv, NULL);
	gettimeofday(&i8253_counter[1].tv, NULL);
	gettimeofday(&i8253_counter[2].tv, NULL);
	i8253_counter[0].start = TIMER_DIV(100);
	i8253_counter[1].start = TIMER_DIV(100);
	i8253_counter[2].start = TIMER_DIV(100);
d834 12
d847 1
a847 1
	memset(&com1_regs, 0, sizeof(struct ns8250_regs));
d886 2
d889 1
a889 1
	struct vm_run_params **vrp;
d915 2
d925 3
d930 3
d963 16
d987 6
d1007 1
d1030 2
d1034 1
a1034 1
	vrp->vrp_injint = -1;
d1037 42
d1082 2
d1104 2
a1105 17
/*
 * vcpu_exit_i8253
 *
 * Handles emulated i8253 PIT access (in/out instruction to PIT ports).
 * We don't emulate all the modes of the i8253, just the basic squarewave
 * clock.
 *
 * Parameters:
 *  vrp: vm run parameters containing exit information for the I/O
 *      instruction being performed
 *
 * Return value:
 *  Interrupt to inject to the guest VM, or 0xFF if no interrupt should
 *      be injected.
 */
uint8_t
vcpu_exit_i8253(struct vm_run_params *vrp)
d1107 1
a1107 5
	uint32_t out_data;
	uint8_t sel, rw, data;
	uint64_t ns, ticks;
	struct timeval now, delta;
	union vm_exit *vei = vrp->vrp_exit;
d1109 1
a1109 12
	if (vei->vei.vei_port == TIMER_CTRL) {
		if (vei->vei.vei_dir == 0) { /* OUT instruction */
			out_data = vei->vei.vei_data;
			sel = out_data &
			    (TIMER_SEL0 | TIMER_SEL1 | TIMER_SEL2);
			sel = sel >> 6;
			if (sel > 2) {
				log_warnx("%s: i8253 PIT: invalid "
				    "timer selected (%d)",
				    __progname, sel);
				goto ret;
			}
d1111 3
a1113 1
			rw = vei->vei.vei_data & (TIMER_LATCH | TIMER_16BIT);
d1115 2
a1116 6
			if ((rw & TIMER_16BIT) == TIMER_LSB ||
			    (rw & TIMER_16BIT) == TIMER_MSB) {
				log_warnx("%s: i8253 PIT: invalid timer mode "
				    "0x%x selected", __func__,
				    (rw & TIMER_16BIT));
			}
d1118 1
a1118 404
			/*
			 * Since we don't truly emulate each tick of the PIT
			 * clock, when the guest asks for the timer to be
			 * latched, simulate what the counter would have been
			 * had we performed full emulation. We do this by
			 * calculating when the counter was reset vs how much
			 * time has elapsed, then bias by the counter tick
			 * rate.
			 */
			if (rw == TIMER_LATCH) {
				gettimeofday(&now, NULL);
				delta.tv_sec = now.tv_sec -
				    i8253_counter[sel].tv.tv_sec;
				delta.tv_usec = now.tv_usec -
				    i8253_counter[sel].tv.tv_usec;
				if (delta.tv_usec < 0) {
					delta.tv_sec--;
					delta.tv_usec += 1000000;
				}
				if (delta.tv_usec > 1000000) {
					delta.tv_sec++;
					delta.tv_usec -= 1000000;
				}
				ns = delta.tv_usec * 1000 +
				    delta.tv_sec * 1000000000;
				ticks = ns / NS_PER_TICK;
				i8253_counter[sel].olatch =
				    i8253_counter[sel].start -
				    ticks % i8253_counter[sel].start;
				goto ret;
			}

			goto ret;
		} else {
			log_warnx("%s: i8253 PIT: read from control "
			    "port unsupported - returning 0", __progname);
			vei->vei.vei_data = 0;
		}
	} else {
		sel = vei->vei.vei_port - (TIMER_CNTR0 + TIMER_BASE);
		if (vei->vei.vei_dir == 0) { /* OUT instruction */
			if (i8253_counter[sel].last_w == 0) {
				out_data = vei->vei.vei_data;
				i8253_counter[sel].ilatch |= (out_data << 8);
				i8253_counter[sel].last_w = 1;
			} else {
				out_data = vei->vei.vei_data;
				i8253_counter[sel].ilatch |= out_data;
				i8253_counter[sel].start =
				    i8253_counter[sel].ilatch;
				i8253_counter[sel].last_w = 0;
			}
		} else {
			if (i8253_counter[sel].last_r == 0) {
				data = i8253_counter[sel].olatch >> 8;
				vei->vei.vei_data = data;
				i8253_counter[sel].last_w = 1;
			} else {
				data = i8253_counter[sel].olatch & 0xFF;
				vei->vei.vei_data = data;
				i8253_counter[sel].last_w = 0;
			}
		}
	}

ret:
	/* XXX don't yet support interrupts generated from the 8253 */
	return (0xFF);
}

/*
 * vcpu_process_com_data
 *
 * Emulate in/out instructions to the com1 (ns8250) UART data register
 *
 * Parameters:
 *  vei: vm exit information from vmm(4) containing information on the in/out
 *      instruction being performed
 */
void
vcpu_process_com_data(union vm_exit *vei)
{
	/*
	 * vei_dir == 0 : out instruction
	 *
	 * The guest wrote to the data register. Since we are emulating a
	 * no-fifo chip, write the character immediately to the pty and
	 * assert TXRDY in IIR (if the guest has requested TXRDY interrupt
	 * reporting)
	 */
	if (vei->vei.vei_dir == 0) {
		write(con_fd, &vei->vei.vei_data, 1);
		if (com1_regs.ier & 0x2) {
			/* Set TXRDY */
			com1_regs.iir |= IIR_TXRDY;
			/* Set "interrupt pending" (IIR low bit cleared) */
			com1_regs.iir &= ~0x1;
		}
	} else {
		/*
		 * vei_dir == 1 : in instruction
		 *
		 * The guest read from the data register. Check to see if
		 * there is data available (RXRDY) and if so, consume the
		 * input data and return to the guest. Also clear the
		 * interrupt info register regardless.
		 */
		if (com1_regs.lsr & LSR_RXRDY) {
			vei->vei.vei_data = com1_regs.data;
			com1_regs.data = 0x0;
			com1_regs.lsr &= ~LSR_RXRDY;
		} else {
			/* XXX should this be com1_regs.data or 0xff? */
			vei->vei.vei_data = com1_regs.data;
			log_warnx("guest reading com1 when not ready");
		}

		/* Reading the data register always clears RXRDY from IIR */
		com1_regs.iir &= ~IIR_RXRDY;

		/*
		 * Clear "interrupt pending" by setting IIR low bit to 1
		 * if no interrupt are pending
		 */
		if (com1_regs.iir == 0x0)
			com1_regs.iir = 0x1;
	}
}

/*
 * vcpu_process_com_lcr
 *
 * Emulate in/out instructions to the com1 (ns8250) UART line control register
 *
 * Paramters:
 *  vei: vm exit information from vmm(4) containing information on the in/out
 *      instruction being performed
 */
void
vcpu_process_com_lcr(union vm_exit *vei)
{
	/*
	 * vei_dir == 0 : out instruction
	 *
	 * Write content to line control register
	 */
	if (vei->vei.vei_dir == 0) {
		com1_regs.lcr = (uint8_t)vei->vei.vei_data;
	} else {
		/*
		 * vei_dir == 1 : in instruction
		 *
		 * Read line control register
		 */
		vei->vei.vei_data = com1_regs.lcr;
	}
}

/*
 * vcpu_process_com_iir
 *
 * Emulate in/out instructions to the com1 (ns8250) UART interrupt information
 * register. Note that writes to this register actually are to a different
 * register, the FCR (FIFO control register) that we don't emulate but still
 * consume the data provided.
 *
 * Parameters:
 *  vei: vm exit information from vmm(4) containing information on the in/out
 *      instruction being performed
 */
void
vcpu_process_com_iir(union vm_exit *vei)
{
	/*
	 * vei_dir == 0 : out instruction
	 *
	 * Write to FCR
	 */
	if (vei->vei.vei_dir == 0) {
		com1_regs.fcr = vei->vei.vei_data;
	} else {
		/*
		 * vei_dir == 1 : in instruction
		 *
		 * Read IIR. Reading the IIR resets the TXRDY bit in the IIR
		 * after the data is read.
		 */
		vei->vei.vei_data = com1_regs.iir;
		com1_regs.iir &= ~IIR_TXRDY;

		/*
		 * Clear "interrupt pending" by setting IIR low bit to 1
		 * if no interrupts are pending
		 */
		if (com1_regs.iir == 0x0)
			com1_regs.iir = 0x1;
	}
}

/*
 * vcpu_process_com_mcr
 *
 * Emulate in/out instructions to the com1 (ns8250) UART modem control
 * register.
 *
 * Parameters:
 *  vei: vm exit information from vmm(4) containing information on the in/out
 *      instruction being performed
 */
void
vcpu_process_com_mcr(union vm_exit *vei)
{
	/*
	 * vei_dir == 0 : out instruction
	 *
	 * Write to MCR
	 */
	if (vei->vei.vei_dir == 0) {
		com1_regs.mcr = vei->vei.vei_data;
	} else {
		/*
		 * vei_dir == 1 : in instruction
		 *
		 * Read from MCR
		 */
		vei->vei.vei_data = com1_regs.mcr;
	}
}

/*
 * vcpu_process_com_lsr
 *
 * Emulate in/out instructions to the com1 (ns8250) UART line status register.
 *
 * Parameters:
 *  vei: vm exit information from vmm(4) containing information on the in/out
 *      instruction being performed
 */
void
vcpu_process_com_lsr(union vm_exit *vei)
{
	/*
	 * vei_dir == 0 : out instruction
	 *
	 * Write to LSR. This is an illegal operation, so we just log it and
	 * continue.
	 */
	if (vei->vei.vei_dir == 0) {
		log_warnx("%s: LSR UART write 0x%x unsupported",
		    __progname, vei->vei.vei_data);
	} else {
		/*
		 * vei_dir == 1 : in instruction
		 *
		 * Read from LSR. We always report TXRDY and TSRE since we
		 * can process output characters immediately (at any time).
		 */
		vei->vei.vei_data = com1_regs.lsr | LSR_TSRE | LSR_TXRDY;
	}
}

/*
 * vcpu_process_com_msr
 *
 * Emulate in/out instructions to the com1 (ns8250) UART modem status register.
 *
 * Parameters:
 *  vei: vm exit information from vmm(4) containing information on the in/out
 *      instruction being performed
 */
void
vcpu_process_com_msr(union vm_exit *vei)
{
	/*
	 * vei_dir == 0 : out instruction
	 *
	 * Write to MSR. This is an illegal operation, so we just log it and
	 * continue.
	 */
	if (vei->vei.vei_dir == 0) {
		log_warnx("%s: MSR UART write 0x%x unsupported",
		    __progname, vei->vei.vei_data);
	} else {
		/*
		 * vei_dir == 1 : in instruction
		 *
		 * Read from MSR. We always report DCD, DSR, and CTS.
		 */
		vei->vei.vei_data = com1_regs.lsr | MSR_DCD | MSR_DSR | MSR_CTS;
	}
}

/*
 * vcpu_process_com_scr
 *
 * Emulate in/out instructions to the com1 (ns8250) UART scratch register. The
 * scratch register is sometimes used to distinguish an 8250 from a 16450,
 * and/or used to distinguish submodels of the 8250 (eg 8250A, 8250B). We
 * simulate an "original" 8250 by forcing the scratch register to return data
 * on read that is different from what was written.
 *
 * Parameters:
 *  vei: vm exit information from vmm(4) containing information on the in/out
 *      instruction being performed
 */
void
vcpu_process_com_scr(union vm_exit *vei)
{
	/*
	 * vei_dir == 0 : out instruction
	 *
	 * Write to SCR
	 */
	if (vei->vei.vei_dir == 0) {
		com1_regs.scr = vei->vei.vei_data;
	} else {
		/*
		 * vei_dir == 1 : in instruction
		 *
		 * Read from SCR. To make sure we don't accidentally simulate
		 * a real scratch register, we negate what was written on
		 * subsequent readback.
		 */
		vei->vei.vei_data = ~com1_regs.scr;
	}
}

/*
 * vcpu_process_com_ier
 *
 * Emulate in/out instructions to the com1 (ns8250) UART interrupt enable
 * register.
 *
 * Parameters:
 *  vei: vm exit information from vmm(4) containing information on the in/out
 *      instruction being performed
 */
void
vcpu_process_com_ier(union vm_exit *vei)
{
	/*
	 * vei_dir == 0 : out instruction
	 *
	 * Write to IER
	 */
	if (vei->vei.vei_dir == 0) {
		com1_regs.ier = vei->vei.vei_data;
	} else {
		/*
		 * vei_dir == 1 : in instruction
		 *
		 * Read from IER
		 */
		vei->vei.vei_data = com1_regs.ier;
	}
}

/*
 * vcpu_exit_com
 *
 * Process com1 (ns8250) UART exits. vmd handles most basic 8250
 * features with the exception of the divisor latch (eg, no baud
 * rate support)
 *
 * Parameters:
 *  vrp: vcpu run parameters containing guest state for this exit
 *
 * Return value:
 *  Interrupt to inject to the guest VM, or 0xFF if no interrupt should
 *      be injected.
 */
uint8_t
vcpu_exit_com(struct vm_run_params *vrp)
{
	union vm_exit *vei = vrp->vrp_exit;

	switch (vei->vei.vei_port) {
	case COM1_LCR:
		vcpu_process_com_lcr(vei);
		break;
	case COM1_IER:
		vcpu_process_com_ier(vei);
		break;
	case COM1_IIR:
		vcpu_process_com_iir(vei);
		break;
	case COM1_MCR:
		vcpu_process_com_mcr(vei);
		break;
	case COM1_LSR:
		vcpu_process_com_lsr(vei);
		break;
	case COM1_MSR:
		vcpu_process_com_msr(vei);
		break;
	case COM1_SCR:
		vcpu_process_com_scr(vei);
		break;
	case COM1_DATA:
		vcpu_process_com_data(vei);
		break;
	}

	return (0xFF);
d1181 1
a1181 3
		vrp->vrp_injint = intr;
	else
		vrp->vrp_injint = -1;
d1193 2
a1194 3
 * interrupts should be injected into the guest, and sets vrp->vrp_injint
 * to the IRQ line whose interrupt should be vectored (or -1 if no interrupt
 * is to be injected).
a1205 3
	ssize_t sz;
	char ch;

d1211 6
a1216 4
		/*
		 * XXX handle halted state, no reason to run this vcpu again
		 * until a vm interrupt is to be injected
		 */
d1224 2
a1225 1
	/* XXX interrupt priority */
d1227 1
a1227 1
		vrp->vrp_injint = 9;
d1229 3
a1231 17
	/*
	 * Is there a new character available on com1?
	 * If so, consume the character, buffer it into the com1 data register
	 * assert IRQ4, and set the line status register RXRDY bit.
	 *
	 * XXX - move all this com intr checking to another function
	 */
	sz = read(con_fd, &ch, sizeof(char));
	if (sz == 1) {
		com1_regs.lsr |= LSR_RXRDY;
		com1_regs.data = ch;
		/* XXX these ier and iir bits should be IER_x and IIR_x */
		if (com1_regs.ier & 0x1) {
			com1_regs.iir |= (2 << 1);
			com1_regs.iir &= ~0x1;
		}
	}
a1232 12
	/*
	 * Clear "interrupt pending" by setting IIR low bit to 1 if no
	 * interrupts are pending
	 */
	/* XXX these iir magic numbers should be IIR_x */
	if ((com1_regs.iir & ~0x1) == 0x0)
		com1_regs.iir = 0x1;

	/* If pending interrupt and nothing waiting to be injected, inject */
	if ((com1_regs.iir & 0x1) == 0)
		if (vrp->vrp_injint == -1)
			vrp->vrp_injint = 0x4;
d1392 27
@


1.36
log
@small bits of header cleanup; ok mlarkin
@
text
@d1 1
a1 1
/*	$OpenBSD: vmm.c,v 1.35 2016/08/01 16:32:10 stefan Exp $	*/
d1560 1
a1560 1
 * i8253 PIT and the com1 ns8250 UART.
d1600 1
a1600 1
 *  1: an error occurred (exit not handled)
d1726 1
a1726 1
 * Pushes data from 'buf' into the guest VM's memory at paddr 'dst'.
d1729 3
a1731 3
 *  dst: the destination paddr_t in the guest VM to push into.
 *  buf: data to push
 *  len: size of 'buf'
d1748 2
a1749 2
		log_warn("writepage ioctl failed: "
		    "invalid memory range dst = 0x%lx, len = 0x%zx", dst, len);
d1779 1
a1779 1
 *  len: size of 'buf'
d1796 2
a1797 2
		log_warn("readpage ioctl failed: "
		    "invalid memory range src = 0x%lx, len = 0x%zx", src, len);
d1822 7
a1828 1
 * Returns 1 if data can be read from an fd, or 0 otherwise.
@


1.35
log
@Do not pass VM name directly to setproctitle format string.

Use a secure idiom instead.
ok mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmm.c,v 1.34 2016/07/29 16:36:51 stefan Exp $	*/
d19 1
a19 1
#include <sys/param.h>
a32 1
#include <machine/param.h>
@


1.34
log
@Allow starting a VM again after it was terminated

If a VM exits, terminate it and remove it from the list of
available VMs. That allows a VM with name `foo' to be restarted
after it has exited.

This changes structures shared between vmd and vmctl. You need to
rebuild vmctl also.

ok mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmm.c,v 1.33 2016/07/19 09:52:34 natano Exp $	*/
d532 1
a532 1
		setproctitle(vcp->vcp_name);
@


1.33
log
@Replace malloc() + memset() with calloc().
ok mlarkin
@
text
@d1 1
a1 1
/*	$OpenBSD: vmm.c,v 1.32 2016/07/09 09:06:22 stefan Exp $	*/
d22 1
d107 1
d196 4
d305 54
d499 2
a928 1
	struct vm_terminate_params vtp;
a1012 7
			/* Terminate the VM if we can */
			memset(&vtp, 0, sizeof(vtp));
			vtp.vtp_vm_id = vcp->vcp_id;
			if (terminate_vm(&vtp)) {
				log_warnx("%s: could not terminate vm %d",
				    __progname, vcp->vcp_id);
			}
@


1.32
log
@Prepare vionet to be handled asynchronously to the VCPU thread

This splits the handling of received data into a separate function
that can later be called in parallel to the VCPU thread instead of
handling received packets on VCPU exits only.

It also makes virtq accesses in the rx path safe to run in parallel
to the VCPU thread: the last index into the 'avail' ring the driver
has notified to the host is kept track of. It also makes sure that
the host only writes back to the 'avail' ring instead of modifying
the whole receive virtq.

While there, describe what virtio_vq_info and virtio_io_cfg are used
for, as suggested by mlarkin@@

ok mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmm.c,v 1.31 2016/07/08 06:35:12 mlarkin Exp $	*/
d893 2
a894 2
	tid = malloc(sizeof(pthread_t) * vcp->vcp_ncpus);
	vrp = malloc(sizeof(struct vm_run_params *) * vcp->vcp_ncpus);
@


1.31
log
@
Return 0 on read from PIT control port. Intel explicitly says this is not
supported, and it looks like other emulators/hypervisors do a variety of
different things here. Most return 0, but at least one might return random
garbage. Returning 0 seems safest here, but leave a warning in place for
the logs in case a guest VM does this.
@
text
@d1 1
a1 1
/*	$OpenBSD: vmm.c,v 1.30 2016/07/07 00:58:31 mlarkin Exp $	*/
d40 1
d1764 21
@


1.30
log
@
sanity check vm create and run args earlier
@
text
@d1 1
a1 1
/*	$OpenBSD: vmm.c,v 1.29 2016/07/06 07:09:15 mlarkin Exp $	*/
a1090 1
			/* XXX should this return 0xff as the data read? */
d1092 2
a1093 1
			    "port unsupported", __progname);
@


1.29
log
@
clarify a comment about memory regions
@
text
@d1 1
a1 1
/*	$OpenBSD: vmm.c,v 1.28 2016/06/10 16:33:15 stefan Exp $	*/
d788 3
d868 22
a891 5
	/* XXX cap vcp_ncpus to avoid overflow here */
	/*
	 * XXX ensure nvcpus in vcp is same as vm, or fix vmm to return einval
	 * on bad vcpu id
	 */
@


1.28
log
@Access guest memory with normal loads and stores in vmd(8)

read_mem() and write_mem() in vmd(8) now use memcpy() instead of the
vm_readpage() and vm_writepage() ioctls to read/write guest memory.

ok mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmm.c,v 1.27 2016/06/07 16:19:06 stefan Exp $	*/
d678 2
a679 1
	 * XXX Normally ROMs or parts of video RAM are mapped here.
d681 1
a681 1
	 * unconditionally write to 0xb8000 (video RAM), and
@


1.27
log
@Allocate RAM for guest VM in vmd(8) and pass it to vmm(4)

vmm(4) then maps the pages allocated by the vmd(8) user process into the
address space of the guest. This gives vmm(4) and vmd(8) a shared view of
the guest RAM. This will allow us to have faster guest<->host data
exchange by ordinary memory loads/stores later, as well as remove the
vm_readpage and vm_writepage ioctls next.

ok mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmm.c,v 1.26 2016/04/07 05:51:26 guenther Exp $	*/
d134 3
d1589 60
a1654 3
 *      If there is no guest paddr mapping at 'dst', a new page will be
 *      faulted in by the VMM (provided 'dst' represents a valid paddr
 *      in the guest's address space)
d1659 3
a1661 2
 *  various return values from ioctl(VMM_IOC_WRITEPAGE), or 0 if no error
 *      occurred.
d1666 11
a1676 23
	char *p = buf;
	size_t n, left;
	paddr_t gpa;
	struct vm_writepage_params vwp;

	left = len;
	for (gpa = dst; gpa < dst + len;
	    gpa = (gpa & ~PAGE_MASK) + PAGE_SIZE) {
		n = left;
		if (n > PAGE_SIZE)
			n = PAGE_SIZE;
		if (n > (PAGE_SIZE - (gpa & PAGE_MASK)))
			n = PAGE_SIZE - (gpa & PAGE_MASK);

		vwp.vwp_paddr = (paddr_t)gpa;
		vwp.vwp_data = p;
		vwp.vwp_vm_id = current_vm->vm_params.vcp_id;
		vwp.vwp_len = n;
		if (ioctl(env->vmd_fd, VMM_IOC_WRITEPAGE, &vwp) < 0) {
			log_warn("writepage ioctl failed @@ 0x%lx: "
			    "dst = 0x%lx, len = 0x%zx", gpa, dst, len);
			return (errno);
		}
d1678 13
a1690 2
		left -= n;
		p += n;
d1707 3
a1709 2
 *  various return values from ioctl(VMM_IOC_READPAGE), or 0 if no error
 *      occurred.
d1714 11
a1724 23
	char *p = buf;
	size_t n, left;
	paddr_t gpa;
	struct vm_readpage_params vrp;

	left = len;
	for (gpa = src; gpa < src + len;
	    gpa = (gpa & ~PAGE_MASK) + PAGE_SIZE) {
		n = left;
		if (n > PAGE_SIZE)
			n = PAGE_SIZE;
		if (n > (PAGE_SIZE - (gpa & PAGE_MASK)))
			n = PAGE_SIZE - (gpa & PAGE_MASK);

		vrp.vrp_paddr = (paddr_t)gpa;
		vrp.vrp_data = p;
		vrp.vrp_vm_id = current_vm->vm_params.vcp_id;
		vrp.vrp_len = n;
		if (ioctl(env->vmd_fd, VMM_IOC_READPAGE, &vrp) < 0) {
			log_warn("readpage ioctl failed @@ 0x%lx: "
			    "src = 0x%lx, len = 0x%zx", gpa, src, len);
			return (errno);
		}
d1726 13
a1738 2
		left -= n;
		p += n;
@


1.26
log
@Remove headers associated with code that's been moved to other .c files

ok mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmm.c,v 1.25 2016/04/05 09:33:05 mlarkin Exp $	*/
d25 1
d115 1
d470 6
d658 1
a658 2
	size_t mem_mb;
	uint64_t mem_bytes, len;
d665 1
a665 1
	mem_bytes = (uint64_t)mem_mb * 1024 * 1024;
d668 1
d670 2
a671 2
	vcp->vcp_memranges[0].vmr_size = LOWMEM_KB * 1024;
	mem_bytes -= LOWMEM_KB * 1024;
d704 49
@


1.25
log
@
Support processors without unrestricted guest capability.

ok stefan
@
text
@d1 1
a1 1
/*	$OpenBSD: vmm.c,v 1.24 2016/04/04 17:13:54 stefan Exp $	*/
a23 4
#include <sys/stat.h>
#include <sys/un.h>
#include <sys/wait.h>
#include <sys/mman.h>
a39 3
#include <pwd.h>
#include <signal.h>
#include <stddef.h>
a42 2
#include <syslog.h>
#include <termios.h>
a43 1
#include <poll.h>
@


1.24
log
@Directly use physical addresses from ELF header for kernel loading.

This allows us to remove the 'do_mask' parameters in read_mem and
write_mem as well as the address mask operaton itself.

ok mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmm.c,v 1.23 2016/03/13 13:11:47 stefan Exp $	*/
d164 3
d172 2
a173 2
	CR0_CD | CR0_NW | CR0_ET | CR0_PE,	/* CR0 */
	0x0,					/* CR3 */
@


1.23
log
@Introduce memory ranges to support VMs with >= 4G RAM

Kernel bits:
- When creating a VM, a list of memory ranges has to be specified,
  similar to the BIOS memory map. This is necessary for VMs with
  RAM sizes approaching 4G because we'll need PCI MMIO space in
  the higher parts of the 32 bit address space.

vmctl and vmd bits:
- Construct appropriate memory ranges to create a VM with a given
  RAM size
- Construct a corresponding BIOS memory map from the memory ranges
  and update the boot params page accordingly.
- Make sure that all variables that represent guest physical addresses
  match the address width of the target CPU instead of using uint32_t.
- Fix some integer promotion glitches that actually restricted VM
  RAM size to 2G.

This changes the VM create ioctl interface, so update your kernel,
vmd, and vmctl.

ok mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmm.c,v 1.22 2016/03/13 02:37:29 mlarkin Exp $	*/
a1546 2
 *  do_mask: 1 to mask the destination address (for kernel load), 0 to
 *      leave 'dst' unmasked
a1550 2
 *
 * Note - this function only handles GPAs < 4GB. 
d1553 1
a1553 1
write_mem(paddr_t dst, void *buf, size_t len, int do_mask)
a1559 7
	/*
	 * Mask kernel load addresses to avoid uint32_t -> uint64_t cast
	 * errors
	 */
	if (do_mask)
		dst &= 0xFFFFFFF;

a1594 2
 *  do_mask: 1 to mask the source address (for kernel load), 0 to
 *      leave 'src' unmasked
a1598 2
 *
 * Note - this function only handles GPAs < 4GB.
d1601 1
a1601 1
read_mem(paddr_t src, void *buf, size_t len, int do_mask)
a1606 7

	/*
	 * Mask kernel load addresses to avoid uint32_t -> uint64_t cast
	 * errors
	 */
	if (do_mask)
		src &= 0xFFFFFFF;
@


1.22
log
@
Rework an erroneous warning message about 16 bit i8253 PIT counter I/O.
The unimplemented mode is MSB/LSB (8 bit), not 16 bit mode.
@
text
@d1 1
a1 1
/*	$OpenBSD: vmm.c,v 1.21 2016/02/16 19:00:16 stefan Exp $	*/
a65 1
 *
d123 1
d142 2
a143 1
int con_fd, vm_id;
d474 1
d476 1
d507 1
a507 2
		ret = loadelf_main(vm->vm_kernel, vcp->vcp_id,
		    vcp->vcp_memory_size, &vis);
d647 59
d727 2
a728 1
	if (vcp->vcp_memory_size > VMM_MAX_VM_MEM_SIZE)
d1557 1
a1557 1
write_mem(uint32_t dst, void *buf, uint32_t len, int do_mask)
d1560 2
a1561 1
	uint32_t gpa, n, left;
d1582 1
a1582 1
		vwp.vwp_vm_id = vm_id;
d1585 2
a1586 2
			log_warn("writepage ioctl failed @@ 0x%x: "
			    "dst = 0x%x, len = 0x%x", gpa, dst, len);
d1616 1
a1616 1
read_mem(uint32_t src, void *buf, uint32_t len, int do_mask)
d1619 2
a1620 1
	uint32_t gpa, n, left;
a1622 1

d1641 1
a1641 1
		vrp.vrp_vm_id = vm_id;
d1644 2
a1645 2
			log_warn("readpage ioctl failed @@ 0x%x: "
			    "src = 0x%x, len = 0x%x", gpa, src, len);
@


1.21
log
@Pass down the initial value of CR0 down to the RESETCPU ioctl() as well.
This gives us the opportunity later to start VCPUs in real-mode, etc.
(for those CPUs that support unrestricted guest).

You need to build an updated kernel for this first, the ioctl interface
has changed.

ok mlarkin@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmm.c,v 1.20 2016/01/16 08:55:40 stefan Exp $	*/
d82 1
a82 1
#define NS_PER_TICK (1000000000 / TIMER_FREQ)
d912 7
a918 13
			rw = vei->vei.vei_data &
			    (TIMER_LATCH | TIMER_LSB |
			    TIMER_MSB | TIMER_16BIT);

			if (rw == TIMER_16BIT) {
				/*
				 * XXX this seems to be used on occasion, needs
				 * to be implemented
				 */
				log_warnx("%s: i8253 PIT: 16 bit "
				    "counter I/O not supported",
				    __progname);
				    goto ret;
a952 2
			log_warnx("%s: i8253 PIT: unsupported rw mode "
			    "%d", __progname, rw);
@


1.20
log
@vmd(8) sometimes attempts page-crossing data copies between the host
and guest. The readpage/writepage ioctls of vmm(4) do not support this
and they return EINVAL on such attempts since recently.

Avoid page-crossing guest memory accesses by changing read_page() and
write_page() into read_mem() and write_mem() that can copy arbitrary
lengths of data between host<->guest without page-crossing accesses.

This also allows us to remove page-wise copy-loops in a few places.

ok mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmm.c,v 1.19 2016/01/13 12:55:18 reyk Exp $	*/
d36 1
d168 1
@


1.19
log
@Update the comment that is decribing terminate_vm()'s arguments,
sort the description of arguments for init_emulated_hw().

Pointed out my mlarkin
@
text
@d1 1
a1 1
/*	$OpenBSD: vmm.c,v 1.18 2016/01/08 11:28:05 reyk Exp $	*/
d1480 1
a1480 1
 * write_page
d1482 1
a1482 2
 * Pushes a page of data from 'buf' into the guest VM's memory
 * at paddr 'dst'.
d1489 1
a1489 1
 *  buf: page of data to push
d1501 1
a1501 1
write_page(uint32_t dst, void *buf, uint32_t len, int do_mask)
d1503 2
d1514 21
a1534 7
	vwp.vwp_paddr = (paddr_t)dst;
	vwp.vwp_data = buf;
	vwp.vwp_vm_id = vm_id;
	vwp.vwp_len = len;
	if (ioctl(env->vmd_fd, VMM_IOC_WRITEPAGE, &vwp) < 0) {
		log_warn("writepage ioctl failed");
		return (errno);
d1536 1
d1541 1
a1541 1
 * read_page
d1543 1
a1543 1
 * Reads a page of memory at guest paddr 'src' into 'buf'.
d1559 1
a1559 1
read_page(uint32_t src, void *buf, uint32_t len, int do_mask)
d1561 2
d1565 1
d1573 21
a1593 7
	vrp.vrp_paddr = (paddr_t)src;
	vrp.vrp_data = buf;
	vrp.vrp_vm_id = vm_id;
	vrp.vrp_len = len;
	if (ioctl(env->vmd_fd, VMM_IOC_READPAGE, &vrp) < 0) {
		log_warn("readpage ioctl failed");
		return (errno);
d1595 1
@


1.18
log
@Keep the pledge of the vmm and vm processes disabled for now as long
as there is some more expected progress in the kernel interface.  It
can be tested, and should work, with the previous kernel commit of the
"vmm" pledge, but is not called.
@
text
@d1 1
a1 1
/*	$OpenBSD: vmm.c,v 1.17 2016/01/08 08:12:21 stefan Exp $	*/
d336 1
a336 2
 *  imsg: The incoming imsg body whose 'data' field contains the 
 *      vm_terminate_params struct
d726 2
a729 2
 *  child_disks: previously-opened child VM disk file file descriptors
 *  child_taps: previously-opened child tap file descriptors
@


1.17
log
@Must set MAX_PORTS to 65536, since we assign to
ioports_map[VMM_PCI_IO_BAR_END (= 65535)]. Fixes an off-by-one.

ok mlarkin@@, reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmm.c,v 1.16 2016/01/04 07:27:24 mlarkin Exp $	*/
d196 3
a198 1
	 * XXX vmm - for the vmm ioctls and operations
d200 2
a201 1
	if (pledge("stdio vmm", NULL) == -1)
d485 10
@


1.16
log
@
Use an bitmap of handler function pointers to track I/O device to handler
function mappings. First step in reworking device support in vmd to better
handle interrupts.
@
text
@d1 1
a1 1
/*	$OpenBSD: vmm.c,v 1.15 2016/01/04 02:07:28 mlarkin Exp $	*/
d61 1
a61 1
#define MAX_PORTS 65535
@


1.15
log
@
bzero -> memset for consistency
@
text
@d1 1
a1 1
/*	$OpenBSD: vmm.c,v 1.14 2015/12/17 09:29:28 mlarkin Exp $	*/
d61 2
d108 2
d112 1
d127 2
a128 2
void vcpu_exit_i8253(union vm_exit *);
void vcpu_exit_com(struct vm_run_params *);
d673 5
d686 4
d693 2
d697 5
d869 1
a869 1
 *  vei: VM exit information from vmm(4) containing information on the in/out
d871 4
d876 2
a877 2
void
vcpu_exit_i8253(union vm_exit *vei)
d883 1
d895 1
a895 1
				return;
d910 1
a910 1
				    return;
d942 1
a942 1
				return;
d947 1
a947 1
			return;
d949 1
a949 1
			/* XXX should this return 0xff? */
d979 4
d1281 4
d1286 1
a1286 1
void
d1317 2
d1329 3
a1331 3
 * Return values:
 *  0xff if no interrupt is required after this pci exit,
 *      or an interrupt vector otherwise
d1373 1
a1373 1
	uint8_t intr;
d1375 3
a1377 22
	switch (vei->vei.vei_port) {
	case TIMER_CTRL:
	case (TIMER_CNTR0 + TIMER_BASE):
	case (TIMER_CNTR1 + TIMER_BASE):
	case (TIMER_CNTR2 + TIMER_BASE):
		vcpu_exit_i8253(vei);
		break;
	case COM1_DATA ... COM1_SCR:
		vcpu_exit_com(vrp);
		break;
	case PCI_MODE1_ADDRESS_REG:
	case PCI_MODE1_DATA_REG:
	case VMM_PCI_IO_BAR_BASE ... VMM_PCI_IO_BAR_END:
		intr = vcpu_exit_pci(vrp);
		if (intr != 0xFF)
			vrp->vrp_injint = intr;
		else
			vrp->vrp_injint = -1;
		break;
	default:
		/* IN from unsupported port gives FFs */
		if (vei->vei.vei_dir == 1)
d1379 5
a1383 2
		break;
	}
@


1.14
log
@
Move vcpu register state init to vmd. Allows vmd bootloader to make the
decision as to how the vcpu should be set up for initial start and
reset. Also removes some hardcoded register constants from vmm(4).

ok jsing@@, mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmm.c,v 1.13 2015/12/15 02:18:34 mlarkin Exp $	*/
d669 1
a669 1
	bzero(&i8253_counter, sizeof(struct i8253_counter) * 3);
d678 1
a678 1
	bzero(&com1_regs, sizeof(struct ns8250_regs));
d781 1
a781 1
			bzero(&vtp, sizeof(vtp));
@


1.13
log
@
if a vcpu run thread in vmd exits unexpectedly, teardown the VM's kernel
components as well.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmm.c,v 1.12 2015/12/07 16:02:09 reyk Exp $	*/
d114 1
a114 1
int run_vm(int *, int *, struct vm_create_params *);
d117 1
d146 29
d290 32
d401 1
d478 6
d485 2
a486 2
		ret = loadelf_main(vm->vm_kernel,
		    vcp->vcp_id, vcp->vcp_memory_size);
d499 1
a499 1
		ret = run_vm(vm->vm_disks, vm->vm_ifs, vcp);
d697 1
d704 2
a705 1
run_vm(int *child_disks, int *child_taps, struct vm_create_params *vcp)
d754 6
@


1.12
log
@Forcibly remove the local vm reference on error.
@
text
@d1 1
a1 1
/*	$OpenBSD: vmm.c,v 1.11 2015/12/07 14:43:24 reyk Exp $	*/
d641 1
d703 7
@


1.11
log
@Fix error handling in a few cases: some function return (-1) on error,
while others return (errno) on error.  We probably have to agree on
something.
@
text
@d1 1
a1 1
/*	$OpenBSD: vmm.c,v 1.10 2015/12/06 02:26:14 reyk Exp $	*/
d237 4
@


1.10
log
@Print the TTY in the vmctl status output.
@
text
@d1 1
a1 1
/*	$OpenBSD: vmm.c,v 1.9 2015/12/06 01:58:21 reyk Exp $	*/
d194 2
a195 1
		if (res != 0)
d197 1
d201 2
a202 1
		if (res != 0)
d204 1
d338 2
a339 1
		return (-1);
@


1.9
log
@When a new vm is created with VMM_IOC_CREATE, the kernel assigns a
unique id to it.  This happens in the vm child process and has to be
communicated to the parent processes to track the vm.  Knowing the vm
id in the parent and vmm processes also allows to remove vm from the
daemons list on terminate requests later.
@
text
@d1 1
a1 1
/*	$OpenBSD: vmm.c,v 1.8 2015/12/06 00:32:57 reyk Exp $	*/
d456 1
d473 1
d503 4
a506 1
		} else if (proc_compose_imsg(ps, PROC_PARENT, -1,
d508 1
a508 1
		    &info[i], sizeof(struct vm_info_result)) == -1)
@


1.8
log
@Terminate all running VMs on startup: we're not able to pick up state
of "zombie" VMs yet, they are not useful without the device layer, so
terminate them on vmd startup.

As discussed with mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmm.c,v 1.7 2015/12/03 23:32:32 reyk Exp $	*/
d111 1
a111 1
int start_vm(struct imsg *);
d178 3
d187 2
a188 1
		if (res != 0)
d190 1
d203 1
a203 1
		res = start_vm(imsg);
d209 1
d212 5
d229 18
a246 4
	if (cmd &&
	    proc_compose_imsg(ps, PROC_PARENT, -1, cmd, imsg->hdr.peerid, -1,
	    &res, sizeof(res)) == -1)
		return (-1);
d317 1
d324 1
a324 1
start_vm(struct imsg *imsg)
d330 1
d343 3
d374 12
d393 8
@


1.7
log
@Re-add the "load" and "reload" commands to vmctl: Instead of parsing
the configuration in vmctl directly, it now sends a (re)load request
to vmd.  The reload also resets the existing configuration status -
this doesn't do much difference yet but a future change will compare
if a specified VM is already running.  "load" will allow to add
configuration, while "reload" resets the state before loading.
@
text
@d1 1
a1 1
/*	$OpenBSD: vmm.c,v 1.6 2015/12/03 13:27:14 reyk Exp $	*/
d112 2
a113 2
int terminate_vm(struct imsg *);
int get_info_vm(struct privsep *, struct imsg *);
d166 3
d177 1
d202 3
a204 1
		res = terminate_vm(imsg);
d208 1
a208 1
		res = get_info_vm(ps, imsg);
d242 1
a242 1
terminate_vm(struct imsg *imsg)
a243 4
	struct vm_terminate_params *vtp;

	vtp = (struct vm_terminate_params *)imsg->data;

d390 3
a392 2
 *  ibuf: the imsg ibuf in which to place the results. A new imsg will
 *      be created using this ibuf.
d399 1
a399 1
get_info_vm(struct privsep *ps, struct imsg *imsg)
d405 1
d445 7
a451 1
		if (proc_compose_imsg(ps, PROC_PARENT, -1,
@


1.6
log
@prepare config_getvm() for parse.y
@
text
@d1 1
a1 1
/*	$OpenBSD: vmm.c,v 1.5 2015/12/03 08:42:11 reyk Exp $	*/
d204 3
@


1.5
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: vmm.c,v 1.4 2015/12/02 22:19:11 reyk Exp $	*/
d171 3
a173 2
	struct privsep	*ps = p->p_ps;
	int		 res = 0, cmd = 0;
d177 3
a179 1
		res = config_getvm(ps, imsg);
@


1.4
log
@Split the fully privileged parent into two processes "parent" and
"vmm" with reduced privileges:
- the "parent" opens fds (disks, ifs, etc.) but runs as root but pledged as
  "stdio rpath wpath proc tty sendfd".
- the "vmm" process handles the creation and supervision of vm processes,
  and the primary communication with the vmm(4) subsystem.  It runs as _vmd
  in the chroot but does not use pledge, as the vmm ioctls are not allowed
  by any pledge model yet.
With this change, vmd starts to track the configuration state of VMs
in vmd and will allow other things later (like terminating a vm by
name, moving the configuration parser to vmd, ...).  More incremental
changes will follow.
@
text
@d1 1
a1 1
/*	$OpenBSD: vmm.c,v 1.3 2015/12/02 13:43:36 reyk Exp $	*/
d237 1
a237 1
                return (errno);
d255 1
a255 1
	
d359 1
a359 1
		if (fcntl(con_fd, F_SETFL, O_NONBLOCK) == -1)		
d367 1
a367 1
	
d706 1
a706 1
			
d737 1
a737 1
				if (delta.tv_usec < 0) { 
d785 1
a785 1
			}				
d1092 1
a1092 1
	switch(vei->vei.vei_port) {
d1113 1
a1113 1
		break;	
d1140 1
a1140 1
	switch(vei->vei.vei_port) {
d1149 1
a1149 1
		break;		
d1174 1
a1174 1
	switch(vei->vei.vei_port) {
d1244 1
a1244 1
	if (vionet_process_rx()) 
d1315 1
a1315 1
	
d1356 1
a1356 1
	
@


1.3
log
@Sync with relayd, fix previous use of proc_compose*_imsg()
@
text
@d1 1
a1 1
/*	$OpenBSD: vmm.c,v 1.2 2015/12/02 09:39:41 reyk Exp $	*/
d132 3
d141 27
d169 1
a169 1
vmm_dispatch_control(int fd, struct privsep_proc *p, struct imsg *imsg)
d176 15
d207 1
a207 1
	    proc_compose_imsg(ps, PROC_CONTROL, -1, cmd, imsg->hdr.peerid, -1,
d292 4
a295 15
	struct vm_create_params *vcp;
	size_t i;
	off_t kernel_size;
	struct stat sb;
	int child_disks[VMM_MAX_DISKS_PER_VM], kernel_fd, ret, ttym_fd;
	int child_taps[VMM_MAX_NICS_PER_VM];
	int ttys_fd;
	char ptyn[32];

	vcp = (struct vm_create_params *)imsg->data;

	for (i = 0 ; i < VMM_MAX_DISKS_PER_VM; i++)
		child_disks[i] = -1;
	for (i = 0 ; i < VMM_MAX_NICS_PER_VM; i++)
		child_taps[i] = -1;
d297 3
a299 28
	/*
	 * XXX kernel_fd can't be global (possible race if multiple VMs
	 * being created at the same time). Probably need to move this
	 * into the child before dropping privs, or just make it local
	 * to this function?
	 */
	kernel_fd = -1;

	ttym_fd = -1;
	ttys_fd = -1;

	/* Open disk images for child */
	for (i = 0 ; i < vcp->vcp_ndisks; i++) {
		child_disks[i] = open(vcp->vcp_disks[i], O_RDWR);
		if (child_disks[i] == -1) {
			ret = errno;
			log_warn("%s: can't open %s", __progname,
			    vcp->vcp_disks[i]);
			goto err;
		}
	}

	bzero(&sb, sizeof(sb));
	if (stat(vcp->vcp_kernel, &sb) == -1) {
		ret = errno;
		log_warn("%s: can't stat kernel image %s",
		    __progname, vcp->vcp_kernel);
		goto err;
d301 1
d303 2
a304 14
	kernel_size = sb.st_size;

	/* Open kernel image */
	kernel_fd = open(vcp->vcp_kernel, O_RDONLY);
	if (kernel_fd == -1) {
		ret = errno;
		log_warn("%s: can't open kernel image %s",
		    __progname, vcp->vcp_kernel);
		goto err;	
	}

	if (openpty(&ttym_fd, &ttys_fd, ptyn, NULL, NULL) == -1) {
		ret = errno;
		log_warn("%s: openpty failed", __progname);
a307 17
	if (close(ttys_fd)) {
		ret = errno;
		log_warn("%s: close tty failed", __progname);
		goto err;
	}

	/* Open tap devices for child */
	for (i = 0 ; i < vcp->vcp_nnics; i++) {
		child_taps[i] = opentap();
		if (child_taps[i] == -1) {
			ret = errno;
			log_warn("%s: can't open tap for nic %zd",
			    __progname, i);
			goto err;
		}
	}

d313 1
d320 4
a323 2
		for (i = 0 ; i < vcp->vcp_ndisks; i++)
			close(child_disks[i]);
d325 7
a331 2
		for (i = 0 ; i < vcp->vcp_nnics; i++)
			close(child_taps[i]);
d333 2
a334 2
		close(kernel_fd);
		close(ttym_fd);
d337 1
a337 2
	}	
	else {
a341 1
		log_info("%s: vm console: %s", __progname, ptyn);
d349 2
a350 1
		ret = loadelf_main(kernel_fd, vcp->vcp_id, vcp->vcp_memory_size);
d356 1
a356 1
		close(kernel_fd);
d358 1
a358 1
		con_fd = ttym_fd;
d363 2
a364 1
		ret = run_vm(child_disks, child_taps, vcp);
d368 1
a368 10
	return (ret);

err:
	for (i = 0 ; i < vcp->vcp_ndisks; i++)
		if (child_disks[i] != -1) 
			close(child_disks[i]);

	for (i = 0 ; i < vcp->vcp_nnics; i++)
		if (child_taps[i] != -1)
			close(child_taps[i]);
d370 2
a371 5
	if (kernel_fd != -1)
		close(kernel_fd);

	if (ttym_fd != -1)
		close(ttym_fd);
d432 1
a432 1
	/* Return info to vmmctl(4) */
d435 1
a435 1
		if (proc_compose_imsg(ps, PROC_CONTROL, -1,
a461 7
	struct passwd *pw;

	pw = getpwnam(VMD_USER);
	if (pw == NULL) {
		log_warnx("%s: no such user %s", __progname, VMD_USER);
		return (-1);
	}
d468 1
a468 13
		/* Child */
		if (chroot(pw->pw_dir) != 0)
			fatal("unable to chroot");
		if (chdir("/") != 0)
			fatal("unable to chdir");

		if (setgroups(1, &pw->pw_gid) == -1)
			fatal("setgroups() failed");
		if (setresgid(pw->pw_gid, pw->pw_gid, pw->pw_gid) == -1)
			fatal("setresgid() failed");
		if (setresuid(pw->pw_uid, pw->pw_uid, pw->pw_uid) == -1)
			fatal("setresuid() failed");

@


1.2
log
@Add back the "peerid" to the proc_compose*() functions: in relayd, I
initially left it out because I didn't have a need for it.  But it is
actually quite useful to carry a reference to the imsg data context
across processes.
@
text
@d1 1
a1 1
/*	$OpenBSD: vmm.c,v 1.1 2015/12/02 09:14:25 reyk Exp $	*/
d162 2
a163 2
	    proc_compose_imsg(ps, PROC_CONTROL, cmd, imsg->hdr.peerid,
	    0, -1, &res, sizeof(res)) == -1)
d458 3
a460 3
		if (proc_compose_imsg(ps, PROC_CONTROL,
		    IMSG_VMDOP_GET_INFO_VM_DATA, imsg->hdr.peerid, 0,
		    -1, &info[i], sizeof(struct vm_info_result)) == -1)
@


1.1
log
@Start tweaking vmd's privsep and daemon model by splitting the main
process into multiple parts and adopting the "proc.c"-style from other
daemons.  This allows to further reduce the privileges, to give better
pledge(2), and to add some upcoming changes.

"please do" mlarkin@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmd.c,v 1.8 2015/11/26 08:26:48 reyk Exp $	*/
d162 2
a163 2
	    imsg_compose_event(&ps->ps_ievs[PROC_CONTROL][0],
	    cmd, imsg->hdr.peerid, 0, -1, &res, sizeof(res)) == -1)
d458 1
a458 1
		if (imsg_compose_event(&ps->ps_ievs[PROC_CONTROL][0],
@

