head	1.7;
access;
symbols
	OPENBSD_6_1:1.7.0.2
	OPENBSD_6_1_BASE:1.7;
locks; strict;
comment	@ * @;


1.7
date	2017.03.21.03.29.57;	author mlarkin;	state Exp;
branches;
next	1.6;
commitid	1tUL2DtRhfdcxJSU;

1.6
date	2016.10.26.05.26.36;	author mlarkin;	state Exp;
branches;
next	1.5;
commitid	1sM4SQUlhgJwAn6Q;

1.5
date	2016.10.03.06.00.17;	author mlarkin;	state Exp;
branches;
next	1.4;
commitid	bs8XE32xihRjrrM4;

1.4
date	2016.09.03.11.36.08;	author mlarkin;	state Exp;
branches;
next	1.3;
commitid	vDMZSLSM2HskxnB7;

1.3
date	2016.09.02.17.10.08;	author stefan;	state Exp;
branches;
next	1.2;
commitid	zTahXFskufJQvYES;

1.2
date	2016.09.01.16.40.06;	author mlarkin;	state Exp;
branches;
next	1.1;
commitid	7V0oCQPFjx6K1mXz;

1.1
date	2016.09.01.14.48.09;	author mlarkin;	state Exp;
branches;
next	;
commitid	FBqVpmx18MX292rY;


desc
@@


1.7
log
@Fix two errors in NS8250 (UART) emulation. The first error zeroed out the
high bits of %eax on reading register data from the emulated UART ports.
The second error didn't properly assert the TXRDY bit during init -
this bit was only set after the first character was sent. Both these
bugs caused seabios to not be able to output any data. Found during the
recent effort to get Linux guests booting.
@
text
@/* $OpenBSD: ns8250.c,v 1.6 2016/10/26 05:26:36 mlarkin Exp $ */
/*
 * Copyright (c) 2016 Mike Larkin <mlarkin@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>

#include <dev/ic/comreg.h>

#include <machine/vmmvar.h>

#include <errno.h>
#include <event.h>
#include <pthread.h>
#include <string.h>
#include <unistd.h>

#include "ns8250.h"
#include "proc.h"
#include "vmd.h"
#include "vmm.h"

extern char *__progname;
struct ns8250_dev com1_dev;

static void com_rcv_event(int, short, void *);
static void com_rcv(struct ns8250_dev *, uint32_t, uint32_t);

void
ns8250_init(int fd, uint32_t vmid)
{
	int ret;

	memset(&com1_dev, 0, sizeof(com1_dev));
	ret = pthread_mutex_init(&com1_dev.mutex, NULL);
	if (ret) {
		errno = ret;
		fatal("could not initialize com1 mutex");
	}
	com1_dev.fd = fd;
	com1_dev.irq = 4;
	com1_dev.rcv_pending = 0;

	event_set(&com1_dev.event, com1_dev.fd, EV_READ | EV_PERSIST,
	    com_rcv_event, (void *)(intptr_t)vmid);
	event_add(&com1_dev.event, NULL);
}

static void
com_rcv_event(int fd, short kind, void *arg)
{
	mutex_lock(&com1_dev.mutex);

	/*
	 * We already have other data pending to be received. The data that
	 * has become available now will be moved to the com port later.
	 */
	if (com1_dev.rcv_pending) {
		mutex_unlock(&com1_dev.mutex);
		return;
	}

	if (com1_dev.regs.lsr & LSR_RXRDY)
		com1_dev.rcv_pending = 1;
	else {
		com_rcv(&com1_dev, (uintptr_t)arg, 0);

		/* If pending interrupt, inject */
		if ((com1_dev.regs.iir & 0x1) == 0) {
			/* XXX: vcpu_id */
			vcpu_assert_pic_irq((uintptr_t)arg, 0, com1_dev.irq);
		}
	}

	mutex_unlock(&com1_dev.mutex);
}

/*
 * com_rcv
 *
 * Move received byte into com data register.
 * Must be called with the mutex of the com device acquired
 */
static void
com_rcv(struct ns8250_dev *com, uint32_t vm_id, uint32_t vcpu_id)
{
	char ch;
	ssize_t sz;

	/*
	 * Is there a new character available on com1?
	 * If so, consume the character, buffer it into the com1 data register
	 * assert IRQ4, and set the line status register RXRDY bit.
	 */
	sz = read(com->fd, &ch, sizeof(char));
	if (sz == -1) {
		/*
		 * If we get EAGAIN, we'll retry and get the character later.
		 * This error can happen when typing two characters at once
		 * at the keyboard, for example.
		 */
		if (errno != EAGAIN)
			log_warn("unexpected read error on com device");
	} else if (sz != 1)
		log_warnx("unexpected read return value on com device");
	else {
		com->regs.lsr |= LSR_RXRDY;
		com->regs.data = ch;
		/* XXX these ier and iir bits should be IER_x and IIR_x */
		if (com->regs.ier & 0x1) {
			com->regs.iir |= (2 << 1);
			com->regs.iir &= ~0x1;
		}
	}

	com->rcv_pending = fd_hasdata(com->fd);
}


/*
 * vcpu_process_com_data
 *
 * Emulate in/out instructions to the com1 (ns8250) UART data register
 *
 * Parameters:
 *  vei: vm exit information from vmm(4) containing information on the in/out
 *      instruction being performed
 *
 * Return value:
 *  interrupt to inject, or 0xFF if nothing to inject
 */
uint8_t
vcpu_process_com_data(union vm_exit *vei, uint32_t vm_id, uint32_t vcpu_id)
{
	/*
	 * vei_dir == VEI_DIR_OUT : out instruction
	 *
	 * The guest wrote to the data register. Since we are emulating a
	 * no-fifo chip, write the character immediately to the pty and
	 * assert TXRDY in IIR (if the guest has requested TXRDY interrupt
	 * reporting)
	 */
	if (vei->vei.vei_dir == VEI_DIR_OUT) {
		write(com1_dev.fd, &vei->vei.vei_data, 1);
		if (com1_dev.regs.ier & IER_ETXRDY) {
			/* Set TXRDY */
			com1_dev.regs.iir |= IIR_TXRDY;
			/* Set "interrupt pending" (IIR low bit cleared) */
			com1_dev.regs.iir &= ~0x1;
		}
	} else {
		/*
		 * vei_dir == VEI_DIR_IN : in instruction
		 *
		 * The guest read from the data register. Check to see if
		 * there is data available (RXRDY) and if so, consume the
		 * input data and return to the guest. Also clear the
		 * interrupt info register regardless.
		 */
		if (com1_dev.regs.lsr & LSR_RXRDY) {
			set_return_data(vei, com1_dev.regs.data);
			com1_dev.regs.data = 0x0;
			com1_dev.regs.lsr &= ~LSR_RXRDY;
		} else {
			/* XXX should this be com1_dev.data or 0xff? */
			set_return_data(vei, com1_dev.regs.data);
			log_warnx("%s: guest reading com1 when not ready", __func__);
		}

		/* Reading the data register always clears RXRDY from IIR */
		com1_dev.regs.iir &= ~IIR_RXRDY;

		/*
		 * Clear "interrupt pending" by setting IIR low bit to 1
		 * if no interrupt are pending
		 */
		if (com1_dev.regs.iir == 0x0)
			com1_dev.regs.iir = 0x1;

		if (com1_dev.rcv_pending)
			com_rcv(&com1_dev, vm_id, vcpu_id);
	}

	/* If pending interrupt, make sure it gets injected */
	if ((com1_dev.regs.iir & 0x1) == 0)
		return (com1_dev.irq);

	return (0xFF);
}

/*
 * vcpu_process_com_lcr
 *
 * Emulate in/out instructions to the com1 (ns8250) UART line control register
 *
 * Paramters:
 *  vei: vm exit information from vmm(4) containing information on the in/out
 *      instruction being performed
 */
void
vcpu_process_com_lcr(union vm_exit *vei)
{
	/*
	 * vei_dir == VEI_DIR_OUT : out instruction
	 *
	 * Write content to line control register
	 */
	if (vei->vei.vei_dir == VEI_DIR_OUT) {
		com1_dev.regs.lcr = (uint8_t)vei->vei.vei_data;
	} else {
		/*
		 * vei_dir == VEI_DIR_IN : in instruction
		 *
		 * Read line control register
		 */
		set_return_data(vei, com1_dev.regs.lcr);
	}
}

/*
 * vcpu_process_com_iir
 *
 * Emulate in/out instructions to the com1 (ns8250) UART interrupt information
 * register. Note that writes to this register actually are to a different
 * register, the FCR (FIFO control register) that we don't emulate but still
 * consume the data provided.
 *
 * Parameters:
 *  vei: vm exit information from vmm(4) containing information on the in/out
 *      instruction being performed
 */
void
vcpu_process_com_iir(union vm_exit *vei)
{
	/*
	 * vei_dir == VEI_DIR_OUT : out instruction
	 *
	 * Write to FCR
	 */
	if (vei->vei.vei_dir == VEI_DIR_OUT) {
		com1_dev.regs.fcr = vei->vei.vei_data;
	} else {
		/*
		 * vei_dir == VEI_DIR_IN : in instruction
		 *
		 * Read IIR. Reading the IIR resets the TXRDY bit in the IIR
		 * after the data is read.
		 */
		set_return_data(vei, com1_dev.regs.iir);
		com1_dev.regs.iir &= ~IIR_TXRDY;

		/*
		 * Clear "interrupt pending" by setting IIR low bit to 1
		 * if no interrupts are pending
		 */
		if (com1_dev.regs.iir == 0x0)
			com1_dev.regs.iir = 0x1;
	}
}

/*
 * vcpu_process_com_mcr
 *
 * Emulate in/out instructions to the com1 (ns8250) UART modem control
 * register.
 *
 * Parameters:
 *  vei: vm exit information from vmm(4) containing information on the in/out
 *      instruction being performed
 */
void
vcpu_process_com_mcr(union vm_exit *vei)
{
	/*
	 * vei_dir == VEI_DIR_OUT : out instruction
	 *
	 * Write to MCR
	 */
	if (vei->vei.vei_dir == VEI_DIR_OUT) {
		com1_dev.regs.mcr = vei->vei.vei_data;
	} else {
		/*
		 * vei_dir == VEI_DIR_IN : in instruction
		 *
		 * Read from MCR
		 */
		set_return_data(vei, com1_dev.regs.mcr);
	}
}

/*
 * vcpu_process_com_lsr
 *
 * Emulate in/out instructions to the com1 (ns8250) UART line status register.
 *
 * Parameters:
 *  vei: vm exit information from vmm(4) containing information on the in/out
 *      instruction being performed
 */
void
vcpu_process_com_lsr(union vm_exit *vei)
{
	/*
	 * vei_dir == VEI_DIR_OUT : out instruction
	 *
	 * Write to LSR. This is an illegal operation, so we just log it and
	 * continue.
	 */
	if (vei->vei.vei_dir == VEI_DIR_OUT) {
		log_warnx("%s: LSR UART write 0x%x unsupported",
		    __progname, vei->vei.vei_data);
	} else {
		/*
		 * vei_dir == VEI_DIR_IN : in instruction
		 *
		 * Read from LSR. We always report TXRDY and TSRE since we
		 * can process output characters immediately (at any time).
		 */
		set_return_data(vei, com1_dev.regs.lsr | LSR_TSRE | LSR_TXRDY);
	}
}

/*
 * vcpu_process_com_msr
 *
 * Emulate in/out instructions to the com1 (ns8250) UART modem status register.
 *
 * Parameters:
 *  vei: vm exit information from vmm(4) containing information on the in/out
 *      instruction being performed
 */
void
vcpu_process_com_msr(union vm_exit *vei)
{
	/*
	 * vei_dir == VEI_DIR_OUT : out instruction
	 *
	 * Write to MSR. This is an illegal operation, so we just log it and
	 * continue.
	 */
	if (vei->vei.vei_dir == VEI_DIR_OUT) {
		log_warnx("%s: MSR UART write 0x%x unsupported",
		    __progname, vei->vei.vei_data);
	} else {
		/*
		 * vei_dir == VEI_DIR_IN : in instruction
		 *
		 * Read from MSR. We always report DCD, DSR, and CTS.
		 */
		set_return_data(vei, com1_dev.regs.lsr | MSR_DCD | MSR_DSR |
		    MSR_CTS);
	}
}

/*
 * vcpu_process_com_scr
 *
 * Emulate in/out instructions to the com1 (ns8250) UART scratch register. The
 * scratch register is sometimes used to distinguish an 8250 from a 16450,
 * and/or used to distinguish submodels of the 8250 (eg 8250A, 8250B). We
 * simulate an "original" 8250 by forcing the scratch register to return data
 * on read that is different from what was written.
 *
 * Parameters:
 *  vei: vm exit information from vmm(4) containing information on the in/out
 *      instruction being performed
 */
void
vcpu_process_com_scr(union vm_exit *vei)
{
	/*
	 * vei_dir == VEI_DIR_OUT : out instruction
	 *
	 * Write to SCR
	 */
	if (vei->vei.vei_dir == VEI_DIR_OUT) {
		com1_dev.regs.scr = vei->vei.vei_data;
	} else {
		/*
		 * vei_dir == VEI_DIR_IN : in instruction
		 *
		 * Read from SCR. To make sure we don't accidentally simulate
		 * a real scratch register, we negate what was written on
		 * subsequent readback.
		 */
		set_return_data(vei, ~com1_dev.regs.scr);
	}
}

/*
 * vcpu_process_com_ier
 *
 * Emulate in/out instructions to the com1 (ns8250) UART interrupt enable
 * register.
 *
 * Parameters:
 *  vei: vm exit information from vmm(4) containing information on the in/out
 *      instruction being performed
 */
void
vcpu_process_com_ier(union vm_exit *vei)
{
	/*
	 * vei_dir == VEI_DIR_OUT : out instruction
	 *
	 * Write to IER
	 */
	if (vei->vei.vei_dir == VEI_DIR_OUT) {
		com1_dev.regs.ier = vei->vei.vei_data;
		if (com1_dev.regs.ier & IER_ETXRDY)
			com1_dev.regs.iir |= IIR_TXRDY;
	} else {
		/*
		 * vei_dir == VEI_DIR_IN : in instruction
		 *
		 * Read from IER
		 */
		set_return_data(vei, com1_dev.regs.ier);
	}
}

/*
 * vcpu_exit_com
 *
 * Process com1 (ns8250) UART exits. vmd handles most basic 8250
 * features with the exception of the divisor latch (eg, no baud
 * rate support)
 *
 * Parameters:
 *  vrp: vcpu run parameters containing guest state for this exit
 *
 * Return value:
 *  Interrupt to inject to the guest VM, or 0xFF if no interrupt should
 *      be injected.
 */
uint8_t
vcpu_exit_com(struct vm_run_params *vrp)
{
	uint8_t intr = 0xFF;
	union vm_exit *vei = vrp->vrp_exit;

	mutex_lock(&com1_dev.mutex);

	switch (vei->vei.vei_port) {
	case COM1_LCR:
		vcpu_process_com_lcr(vei);
		break;
	case COM1_IER:
		vcpu_process_com_ier(vei);
		break;
	case COM1_IIR:
		vcpu_process_com_iir(vei);
		break;
	case COM1_MCR:
		vcpu_process_com_mcr(vei);
		break;
	case COM1_LSR:
		vcpu_process_com_lsr(vei);
		break;
	case COM1_MSR:
		vcpu_process_com_msr(vei);
		break;
	case COM1_SCR:
		vcpu_process_com_scr(vei);
		break;
	case COM1_DATA:
		intr = vcpu_process_com_data(vei, vrp->vrp_vm_id,
		    vrp->vrp_vcpu_id);
		break;
	}

	mutex_unlock(&com1_dev.mutex);
	return (intr);
}
@


1.6
log
@
vmd(8)/vmctl(8) for i386. Some ugliness in #ifdef __i386__ areas will be
fixed in tree, but the changes required were pretty minimal.

Note that i386 hosts are still presently limited to running i386 guests.

ok deraadt, stefan, jca
@
text
@d1 1
a1 1
/* $OpenBSD: ns8250.c,v 1.5 2016/10/03 06:00:17 mlarkin Exp $ */
d157 1
a157 1
		if (com1_dev.regs.ier & 0x2) {
d173 1
a173 1
			vei->vei.vei_data = com1_dev.regs.data;
d178 2
a179 2
			vei->vei.vei_data = com1_dev.regs.data;
			log_warnx("guest reading com1 when not ready");
d199 1
d228 1
a228 1
		vei->vei.vei_data = com1_dev.regs.lcr;
d261 1
a261 1
		vei->vei.vei_data = com1_dev.regs.iir;
d299 1
a299 1
		vei->vei.vei_data = com1_dev.regs.mcr;
d331 1
a331 1
		vei->vei.vei_data = com1_dev.regs.lsr | LSR_TSRE | LSR_TXRDY;
d362 2
a363 2
		vei->vei.vei_data =
		    com1_dev.regs.lsr | MSR_DCD | MSR_DSR | MSR_CTS;
d398 1
a398 1
		vei->vei.vei_data = ~com1_dev.regs.scr;
d422 2
d430 1
a430 1
		vei->vei.vei_data = com1_dev.regs.ier;
@


1.5
log
@
add RCS tags
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d57 1
a57 1
	    com_rcv_event, (void *)(uint64_t)vmid);
@


1.4
log
@
fix some wrong interrupt code that doesn't fit with the new model

ok stefan@@
@
text
@d1 1
@


1.3
log
@Process incoming com data asynchronously to running VCPU

This registers a handler with libevent that is triggered on incoming
data on the com port.

ok mlarkin@@
@
text
@a126 8
	/*
	 * Clear "interrupt pending" by setting IIR low bit to 1 if no
	 * interrupts are pending
	 */
	/* XXX these iir magic numbers should be IIR_x */
	if ((com->regs.iir & ~0x1) == 0x0)
		com->regs.iir = 0x1;

@


1.2
log
@
change some log_warn to log_warnx and convert some integer literals to
enumerand values
@
text
@d23 3
d31 2
d35 4
a38 1
struct ns8250_regs com1_regs;
d41 1
a41 1
ns8250_init(int fd)
d43 44
a86 2
	memset(&com1_regs, 0, sizeof(struct ns8250_regs));
	com1_regs.fd = fd;
d90 50
d147 3
d151 2
a152 2
void
vcpu_process_com_data(union vm_exit *vei)
d163 2
a164 2
		write(com1_regs.fd, &vei->vei.vei_data, 1);
		if (com1_regs.ier & 0x2) {
d166 1
a166 1
			com1_regs.iir |= IIR_TXRDY;
d168 1
a168 1
			com1_regs.iir &= ~0x1;
d179 4
a182 4
		if (com1_regs.lsr & LSR_RXRDY) {
			vei->vei.vei_data = com1_regs.data;
			com1_regs.data = 0x0;
			com1_regs.lsr &= ~LSR_RXRDY;
d184 2
a185 2
			/* XXX should this be com1_regs.data or 0xff? */
			vei->vei.vei_data = com1_regs.data;
d190 1
a190 1
		com1_regs.iir &= ~IIR_RXRDY;
d196 5
a200 2
		if (com1_regs.iir == 0x0)
			com1_regs.iir = 0x1;
d202 5
d227 1
a227 1
		com1_regs.lcr = (uint8_t)vei->vei.vei_data;
d234 1
a234 1
		vei->vei.vei_data = com1_regs.lcr;
d259 1
a259 1
		com1_regs.fcr = vei->vei.vei_data;
d267 2
a268 2
		vei->vei.vei_data = com1_regs.iir;
		com1_regs.iir &= ~IIR_TXRDY;
d274 2
a275 2
		if (com1_regs.iir == 0x0)
			com1_regs.iir = 0x1;
d298 1
a298 1
		com1_regs.mcr = vei->vei.vei_data;
d305 1
a305 1
		vei->vei.vei_data = com1_regs.mcr;
d337 1
a337 1
		vei->vei.vei_data = com1_regs.lsr | LSR_TSRE | LSR_TXRDY;
d368 2
a369 1
		vei->vei.vei_data = com1_regs.lsr | MSR_DCD | MSR_DSR | MSR_CTS;
d395 1
a395 1
		com1_regs.scr = vei->vei.vei_data;
d404 1
a404 1
		vei->vei.vei_data = ~com1_regs.scr;
d427 1
a427 1
		com1_regs.ier = vei->vei.vei_data;
d434 1
a434 1
		vei->vei.vei_data = com1_regs.ier;
d455 1
d458 2
d483 2
a484 1
		vcpu_process_com_data(vei);
d488 2
a489 42
	return (0xFF);
}

/* XXX temporary until this is polled */
int
vcpu_com1_needs_intr(void)
{
	int need_irq = 0;
	ssize_t sz;
	char ch;

	/*
	 * Is there a new character available on com1?
	 * If so, consume the character, buffer it into the com1 data register
	 * assert IRQ4, and set the line status register RXRDY bit.
	 *
	 * XXX - move all this com intr checking to another function using poll
	 */
	sz = read(com1_regs.fd, &ch, sizeof(char));
	if (sz == 1) {
		com1_regs.lsr |= LSR_RXRDY;
		com1_regs.data = ch;
		/* XXX these ier and iir bits should be IER_x and IIR_x */
		if (com1_regs.ier & 0x1) {
			com1_regs.iir |= (2 << 1);
			com1_regs.iir &= ~0x1;
		}
	}

	/*
	 * Clear "interrupt pending" by setting IIR low bit to 1 if no
	 * interrupts are pending
	 */
	/* XXX these iir magic numbers should be IIR_x */
	if ((com1_regs.iir & ~0x1) == 0x0)
		com1_regs.iir = 0x1;

	/* If pending interrupt, inject */
	if ((com1_regs.iir & 0x1) == 0)
		need_irq = 1;

	return need_irq;
@


1.1
log
@
Add a set of emulated legacy devices (PIT, PIC, RTC)

discussed with stefan and deraadt
@
text
@d52 1
a52 1
	 * vei_dir == 0 : out instruction
d59 1
a59 1
	if (vei->vei.vei_dir == 0) {
d69 1
a69 1
		 * vei_dir == 1 : in instruction
d111 1
a111 1
	 * vei_dir == 0 : out instruction
d115 1
a115 1
	if (vei->vei.vei_dir == 0) {
d119 1
a119 1
		 * vei_dir == 1 : in instruction
d143 1
a143 1
	 * vei_dir == 0 : out instruction
d147 1
a147 1
	if (vei->vei.vei_dir == 0) {
d151 1
a151 1
		 * vei_dir == 1 : in instruction
d182 1
a182 1
	 * vei_dir == 0 : out instruction
d186 1
a186 1
	if (vei->vei.vei_dir == 0) {
d190 1
a190 1
		 * vei_dir == 1 : in instruction
d211 1
a211 1
	 * vei_dir == 0 : out instruction
d216 1
a216 1
	if (vei->vei.vei_dir == 0) {
d221 1
a221 1
		 * vei_dir == 1 : in instruction
d243 1
a243 1
	 * vei_dir == 0 : out instruction
d248 1
a248 1
	if (vei->vei.vei_dir == 0) {
d253 1
a253 1
		 * vei_dir == 1 : in instruction
d278 1
a278 1
	 * vei_dir == 0 : out instruction
d282 1
a282 1
	if (vei->vei.vei_dir == 0) {
d286 1
a286 1
		 * vei_dir == 1 : in instruction
d310 1
a310 1
	 * vei_dir == 0 : out instruction
d314 1
a314 1
	if (vei->vei.vei_dir == 0) {
d318 1
a318 1
		 * vei_dir == 1 : in instruction
@

