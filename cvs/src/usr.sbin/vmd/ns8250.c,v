head	1.12;
access;
symbols
	OPENBSD_6_1:1.7.0.4
	OPENBSD_6_1_BASE:1.7;
locks; strict;
comment	@ * @;


1.12
date	2017.09.15.02.35.39;	author mlarkin;	state Exp;
branches;
next	1.11;
commitid	B4h27X6iaeioLfHM;

1.11
date	2017.08.14.19.46.44;	author jasper;	state Exp;
branches;
next	1.10;
commitid	sC2xvioGCHNA55Vu;

1.10
date	2017.07.15.05.05.36;	author pd;	state Exp;
branches;
next	1.9;
commitid	l7Kfh3b63PsFu8PF;

1.9
date	2017.06.07.14.53.28;	author mlarkin;	state Exp;
branches;
next	1.8;
commitid	1kYg7CU2HCt6nyWY;

1.8
date	2017.05.08.09.08.40;	author reyk;	state Exp;
branches;
next	1.7;
commitid	oVx15xEUTrD3JWhh;

1.7
date	2017.03.21.03.29.57;	author mlarkin;	state Exp;
branches;
next	1.6;
commitid	1tUL2DtRhfdcxJSU;

1.6
date	2016.10.26.05.26.36;	author mlarkin;	state Exp;
branches;
next	1.5;
commitid	1sM4SQUlhgJwAn6Q;

1.5
date	2016.10.03.06.00.17;	author mlarkin;	state Exp;
branches;
next	1.4;
commitid	bs8XE32xihRjrrM4;

1.4
date	2016.09.03.11.36.08;	author mlarkin;	state Exp;
branches;
next	1.3;
commitid	vDMZSLSM2HskxnB7;

1.3
date	2016.09.02.17.10.08;	author stefan;	state Exp;
branches;
next	1.2;
commitid	zTahXFskufJQvYES;

1.2
date	2016.09.01.16.40.06;	author mlarkin;	state Exp;
branches;
next	1.1;
commitid	7V0oCQPFjx6K1mXz;

1.1
date	2016.09.01.14.48.09;	author mlarkin;	state Exp;
branches;
next	;
commitid	FBqVpmx18MX292rY;


desc
@@


1.12
log
@vmd: emulate UART scratch register, seems to be required by GRUB and
doesn't seem to cause any side effects with other guest types.
@
text
@/* $OpenBSD: ns8250.c,v 1.11 2017/08/14 19:46:44 jasper Exp $ */
/*
 * Copyright (c) 2016 Mike Larkin <mlarkin@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>

#include <dev/ic/comreg.h>

#include <machine/vmmvar.h>

#include <errno.h>
#include <event.h>
#include <pthread.h>
#include <string.h>
#include <unistd.h>

#include "ns8250.h"
#include "proc.h"
#include "vmd.h"
#include "vmm.h"
#include "atomicio.h"

extern char *__progname;
struct ns8250_dev com1_dev;

static void com_rcv_event(int, short, void *);
static void com_rcv(struct ns8250_dev *, uint32_t, uint32_t);

/*
 * ratelimit
 *
 * Timeout callback function used when we have to slow down the output rate
 * from the emulated serial port.
 *
 * Parameters:
 *  fd: unused
 *  type: unused
 *  arg: unused
 */
static void
ratelimit(int fd, short type, void *arg)
{
	/* Set TXRDY and clear "no pending interrupt" */
	com1_dev.regs.iir |= IIR_TXRDY;
	com1_dev.regs.iir &= ~IIR_NOPEND;
	vcpu_assert_pic_irq(com1_dev.vmid, 0, com1_dev.irq);
}

void
ns8250_init(int fd, uint32_t vmid)
{
	int ret;

	memset(&com1_dev, 0, sizeof(com1_dev));
	ret = pthread_mutex_init(&com1_dev.mutex, NULL);
	if (ret) {
		errno = ret;
		fatal("could not initialize com1 mutex");
	}
	com1_dev.fd = fd;
	com1_dev.irq = 4;
	com1_dev.rcv_pending = 0;
	com1_dev.vmid = vmid;
	com1_dev.byte_out = 0;
	com1_dev.regs.divlo = 1;
	com1_dev.baudrate = 115200;

	/*
	 * Our serial port is essentially instantaneous, with infinite
	 * baudrate capability. To adjust for the selected baudrate,
	 * we calculate how many characters could be transmitted in a 10ms
	 * period (pause_ct) and then delay 10ms after each pause_ct sized
	 * group of characters have been transmitted. Since it takes nearly
	 * zero time to send the actual characters, the total amount of time
	 * spent is roughly equal to what it would be on real hardware.
	 *
	 * To make things simple, we don't adjust for different sized bytes
	 * (and parity, stop bits, etc) and simply assume each character
	 * output is 8 bits.
	 */
	com1_dev.pause_ct = (com1_dev.baudrate / 8) / 1000 * 10;

	event_set(&com1_dev.event, com1_dev.fd, EV_READ | EV_PERSIST,
	    com_rcv_event, (void *)(intptr_t)vmid);
	event_add(&com1_dev.event, NULL);

	/* Rate limiter for simulating baud rate */
	timerclear(&com1_dev.rate_tv);
	com1_dev.rate_tv.tv_usec = 10000;
	evtimer_set(&com1_dev.rate, ratelimit, NULL);
}

static void
com_rcv_event(int fd, short kind, void *arg)
{
	mutex_lock(&com1_dev.mutex);

	/*
	 * We already have other data pending to be received. The data that
	 * has become available now will be moved to the com port later.
	 */
	if (com1_dev.rcv_pending) {
		mutex_unlock(&com1_dev.mutex);
		return;
	}

	if (com1_dev.regs.lsr & LSR_RXRDY)
		com1_dev.rcv_pending = 1;
	else {
		com_rcv(&com1_dev, (uintptr_t)arg, 0);

		/* If pending interrupt, inject */
		if ((com1_dev.regs.iir & IIR_NOPEND) == 0) {
			/* XXX: vcpu_id */
			vcpu_assert_pic_irq((uintptr_t)arg, 0, com1_dev.irq);
		}
	}

	mutex_unlock(&com1_dev.mutex);
}

/*
 * com_rcv
 *
 * Move received byte into com data register.
 * Must be called with the mutex of the com device acquired
 */
static void
com_rcv(struct ns8250_dev *com, uint32_t vm_id, uint32_t vcpu_id)
{
	char ch;
	ssize_t sz;

	/*
	 * Is there a new character available on com1?
	 * If so, consume the character, buffer it into the com1 data register
	 * assert IRQ4, and set the line status register RXRDY bit.
	 */
	sz = read(com->fd, &ch, sizeof(char));
	if (sz == -1) {
		/*
		 * If we get EAGAIN, we'll retry and get the character later.
		 * This error can happen when typing two characters at once
		 * at the keyboard, for example.
		 */
		if (errno != EAGAIN)
			log_warn("unexpected read error on com device");
	} else if (sz != 1)
		log_warnx("unexpected read return value on com device");
	else {
		com->regs.lsr |= LSR_RXRDY;
		com->regs.data = ch;

		if (com->regs.ier & IER_ERXRDY) {
			com->regs.iir |= IIR_RXRDY;
			com->regs.iir &= ~IIR_NOPEND;
		}
	}

	com->rcv_pending = fd_hasdata(com->fd);
}

/*
 * vcpu_process_com_data
 *
 * Emulate in/out instructions to the com1 (ns8250) UART data register
 *
 * Parameters:
 *  vei: vm exit information from vmm(4) containing information on the in/out
 *      instruction being performed
 *
 * Return value:
 *  interrupt to inject, or 0xFF if nothing to inject
 */
uint8_t
vcpu_process_com_data(union vm_exit *vei, uint32_t vm_id, uint32_t vcpu_id)
{
	/*
	 * vei_dir == VEI_DIR_OUT : out instruction
	 *
	 * The guest wrote to the data register. Since we are emulating a
	 * no-fifo chip, write the character immediately to the pty and
	 * assert TXRDY in IIR (if the guest has requested TXRDY interrupt
	 * reporting)
	 */
	if (vei->vei.vei_dir == VEI_DIR_OUT) {
		if (com1_dev.regs.lcr & LCR_DLAB) {
			com1_dev.regs.divlo = vei->vei.vei_data;
			return 0xFF;
		}

		write(com1_dev.fd, &vei->vei.vei_data, 1);
		com1_dev.byte_out++;

		if (com1_dev.regs.ier & IER_ETXRDY) {
			/* Limit output rate if needed */
			if (com1_dev.byte_out % com1_dev.pause_ct == 0) {
				evtimer_add(&com1_dev.rate, &com1_dev.rate_tv);
			} else {
				/* Set TXRDY and clear "no pending interrupt" */
				com1_dev.regs.iir |= IIR_TXRDY;
				com1_dev.regs.iir &= ~IIR_NOPEND;
			}
		}
	} else {
		if (com1_dev.regs.lcr & LCR_DLAB) {
			set_return_data(vei, com1_dev.regs.divlo);
			return 0xFF;
		}
		/*
		 * vei_dir == VEI_DIR_IN : in instruction
		 *
		 * The guest read from the data register. Check to see if
		 * there is data available (RXRDY) and if so, consume the
		 * input data and return to the guest. Also clear the
		 * interrupt info register regardless.
		 */
		if (com1_dev.regs.lsr & LSR_RXRDY) {
			set_return_data(vei, com1_dev.regs.data);
			com1_dev.regs.data = 0x0;
			com1_dev.regs.lsr &= ~LSR_RXRDY;
		} else {
			set_return_data(vei, com1_dev.regs.data);
			log_warnx("%s: guest reading com1 when not ready", __func__);
		}

		/* Reading the data register always clears RXRDY from IIR */
		com1_dev.regs.iir &= ~IIR_RXRDY;

		/*
		 * Clear "interrupt pending" by setting IIR low bit to 1
		 * if no interrupt are pending
		 */
		if (com1_dev.regs.iir == 0x0)
			com1_dev.regs.iir = 0x1;

		if (com1_dev.rcv_pending)
			com_rcv(&com1_dev, vm_id, vcpu_id);
	}

	/* If pending interrupt, make sure it gets injected */
	if ((com1_dev.regs.iir & IIR_NOPEND) == 0)
		return (com1_dev.irq);

	return (0xFF);
}

/*
 * vcpu_process_com_lcr
 *
 * Emulate in/out instructions to the com1 (ns8250) UART line control register
 *
 * Paramters:
 *  vei: vm exit information from vmm(4) containing information on the in/out
 *      instruction being performed
 */
void
vcpu_process_com_lcr(union vm_exit *vei)
{
	uint8_t data = (uint8_t)vei->vei.vei_data;
	uint16_t divisor;

	/*
	 * vei_dir == VEI_DIR_OUT : out instruction
	 *
	 * Write content to line control register
	 */
	if (vei->vei.vei_dir == VEI_DIR_OUT) {
		if (com1_dev.regs.lcr & LCR_DLAB) {
			if (!(data & LCR_DLAB)) {
				if (com1_dev.regs.divlo == 0 &&
				    com1_dev.regs.divhi == 0) {
					log_warnx("%s: ignoring invalid "
					    "baudrate", __func__);
				} else {
					divisor = com1_dev.regs.divlo |
					     com1_dev.regs.divhi << 8;
					com1_dev.baudrate = 115200 / divisor;
					com1_dev.pause_ct =
					    (com1_dev.baudrate / 8) / 1000 * 10;
				}

				log_debug("%s: set baudrate = %d", __func__,
				    com1_dev.baudrate);
			}
		}
		com1_dev.regs.lcr = (uint8_t)vei->vei.vei_data;
	} else {
		/*
		 * vei_dir == VEI_DIR_IN : in instruction
		 *
		 * Read line control register
		 */
		set_return_data(vei, com1_dev.regs.lcr);
	}
}

/*
 * vcpu_process_com_iir
 *
 * Emulate in/out instructions to the com1 (ns8250) UART interrupt information
 * register. Note that writes to this register actually are to a different
 * register, the FCR (FIFO control register) that we don't emulate but still
 * consume the data provided.
 *
 * Parameters:
 *  vei: vm exit information from vmm(4) containing information on the in/out
 *      instruction being performed
 */
void
vcpu_process_com_iir(union vm_exit *vei)
{
	/*
	 * vei_dir == VEI_DIR_OUT : out instruction
	 *
	 * Write to FCR
	 */
	if (vei->vei.vei_dir == VEI_DIR_OUT) {
		com1_dev.regs.fcr = vei->vei.vei_data;
	} else {
		/*
		 * vei_dir == VEI_DIR_IN : in instruction
		 *
		 * Read IIR. Reading the IIR resets the TXRDY bit in the IIR
		 * after the data is read.
		 */
		set_return_data(vei, com1_dev.regs.iir);
		com1_dev.regs.iir &= ~IIR_TXRDY;

		/*
		 * Clear "interrupt pending" by setting IIR low bit to 1
		 * if no interrupts are pending
		 */
		if (com1_dev.regs.iir == 0x0)
			com1_dev.regs.iir = 0x1;
	}
}

/*
 * vcpu_process_com_mcr
 *
 * Emulate in/out instructions to the com1 (ns8250) UART modem control
 * register.
 *
 * Parameters:
 *  vei: vm exit information from vmm(4) containing information on the in/out
 *      instruction being performed
 */
void
vcpu_process_com_mcr(union vm_exit *vei)
{
	/*
	 * vei_dir == VEI_DIR_OUT : out instruction
	 *
	 * Write to MCR
	 */
	if (vei->vei.vei_dir == VEI_DIR_OUT) {
		com1_dev.regs.mcr = vei->vei.vei_data;
	} else {
		/*
		 * vei_dir == VEI_DIR_IN : in instruction
		 *
		 * Read from MCR
		 */
		set_return_data(vei, com1_dev.regs.mcr);
	}
}

/*
 * vcpu_process_com_lsr
 *
 * Emulate in/out instructions to the com1 (ns8250) UART line status register.
 *
 * Parameters:
 *  vei: vm exit information from vmm(4) containing information on the in/out
 *      instruction being performed
 */
void
vcpu_process_com_lsr(union vm_exit *vei)
{
	/*
	 * vei_dir == VEI_DIR_OUT : out instruction
	 *
	 * Write to LSR. This is an illegal operation, so we just log it and
	 * continue.
	 */
	if (vei->vei.vei_dir == VEI_DIR_OUT) {
		log_warnx("%s: LSR UART write 0x%x unsupported",
		    __progname, vei->vei.vei_data);
	} else {
		/*
		 * vei_dir == VEI_DIR_IN : in instruction
		 *
		 * Read from LSR. We always report TXRDY and TSRE since we
		 * can process output characters immediately (at any time).
		 */
		set_return_data(vei, com1_dev.regs.lsr | LSR_TSRE | LSR_TXRDY);
	}
}

/*
 * vcpu_process_com_msr
 *
 * Emulate in/out instructions to the com1 (ns8250) UART modem status register.
 *
 * Parameters:
 *  vei: vm exit information from vmm(4) containing information on the in/out
 *      instruction being performed
 */
void
vcpu_process_com_msr(union vm_exit *vei)
{
	/*
	 * vei_dir == VEI_DIR_OUT : out instruction
	 *
	 * Write to MSR. This is an illegal operation, so we just log it and
	 * continue.
	 */
	if (vei->vei.vei_dir == VEI_DIR_OUT) {
		log_warnx("%s: MSR UART write 0x%x unsupported",
		    __progname, vei->vei.vei_data);
	} else {
		/*
		 * vei_dir == VEI_DIR_IN : in instruction
		 *
		 * Read from MSR. We always report DCD, DSR, and CTS.
		 */
		set_return_data(vei, com1_dev.regs.lsr | MSR_DCD | MSR_DSR |
		    MSR_CTS);
	}
}

/*
 * vcpu_process_com_scr
 *
 * Emulate in/out instructions to the com1 (ns8250) UART scratch register.
 *
 * Parameters:
 *  vei: vm exit information from vmm(4) containing information on the in/out
 *      instruction being performed
 */
void
vcpu_process_com_scr(union vm_exit *vei)
{
	/*
	 * vei_dir == VEI_DIR_OUT : out instruction
	 *
	 * Write to SCR
	 */
	if (vei->vei.vei_dir == VEI_DIR_OUT) {
		com1_dev.regs.scr = vei->vei.vei_data;
	} else {
		/*
		 * vei_dir == VEI_DIR_IN : in instruction
		 *
		 * Read from SCR
		 */
		set_return_data(vei, com1_dev.regs.scr);
	}
}

/*
 * vcpu_process_com_ier
 *
 * Emulate in/out instructions to the com1 (ns8250) UART interrupt enable
 * register.
 *
 * Parameters:
 *  vei: vm exit information from vmm(4) containing information on the in/out
 *      instruction being performed
 */
void
vcpu_process_com_ier(union vm_exit *vei)
{
	/*
	 * vei_dir == VEI_DIR_OUT : out instruction
	 *
	 * Write to IER
	 */
	if (vei->vei.vei_dir == VEI_DIR_OUT) {
		if (com1_dev.regs.lcr & LCR_DLAB) {
			com1_dev.regs.divhi = vei->vei.vei_data;
			return;
		}
		com1_dev.regs.ier = vei->vei.vei_data;
		if (com1_dev.regs.ier & IER_ETXRDY)
			com1_dev.regs.iir |= IIR_TXRDY;
	} else {
		if (com1_dev.regs.lcr & LCR_DLAB) {
			set_return_data(vei, com1_dev.regs.divhi);
			return;
		}
		/*
		 * vei_dir == VEI_DIR_IN : in instruction
		 *
		 * Read from IER
		 */
		set_return_data(vei, com1_dev.regs.ier);
	}
}

/*
 * vcpu_exit_com
 *
 * Process com1 (ns8250) UART exits. vmd handles most basic 8250
 * features
 *
 * Parameters:
 *  vrp: vcpu run parameters containing guest state for this exit
 *
 * Return value:
 *  Interrupt to inject to the guest VM, or 0xFF if no interrupt should
 *      be injected.
 */
uint8_t
vcpu_exit_com(struct vm_run_params *vrp)
{
	uint8_t intr = 0xFF;
	union vm_exit *vei = vrp->vrp_exit;

	mutex_lock(&com1_dev.mutex);

	switch (vei->vei.vei_port) {
	case COM1_LCR:
		vcpu_process_com_lcr(vei);
		break;
	case COM1_IER:
		vcpu_process_com_ier(vei);
		break;
	case COM1_IIR:
		vcpu_process_com_iir(vei);
		break;
	case COM1_MCR:
		vcpu_process_com_mcr(vei);
		break;
	case COM1_LSR:
		vcpu_process_com_lsr(vei);
		break;
	case COM1_MSR:
		vcpu_process_com_msr(vei);
		break;
	case COM1_SCR:
		vcpu_process_com_scr(vei);
		break;
	case COM1_DATA:
		intr = vcpu_process_com_data(vei, vrp->vrp_vm_id,
		    vrp->vrp_vcpu_id);
		break;
	}

	mutex_unlock(&com1_dev.mutex);

	if ((com1_dev.regs.iir & IIR_NOPEND)) {
		/* XXX: vcpu_id */
		vcpu_deassert_pic_irq(com1_dev.vmid, 0, com1_dev.irq);
	}

	return (intr);
}

int
ns8250_dump(int fd)
{
	log_debug("%s: sending UART", __func__);
	if (atomicio(vwrite, fd, &com1_dev.regs,
	    sizeof(com1_dev.regs)) != sizeof(com1_dev.regs)) {
		log_warnx("%s: error writing UART to fd", __func__);
		return (-1);
	}
	return (0);
}

int
ns8250_restore(int fd, int con_fd, uint32_t vmid)
{
	int ret;
	log_debug("%s: receiving UART", __func__);
	if (atomicio(read, fd, &com1_dev.regs,
	    sizeof(com1_dev.regs)) != sizeof(com1_dev.regs)) {
		log_warnx("%s: error reading UART from fd", __func__);
		return (-1);
	}

	ret = pthread_mutex_init(&com1_dev.mutex, NULL);
	if (ret) {
		errno = ret;
		fatal("could not initialize com1 mutex");
	}
	com1_dev.fd = con_fd;
	com1_dev.irq = 4;
	com1_dev.rcv_pending = 0;
	com1_dev.vmid = vmid;
	com1_dev.byte_out = 0;
	com1_dev.regs.divlo = 1;
	com1_dev.baudrate = 115200;
	com1_dev.rate_tv.tv_usec = 10000;
	com1_dev.pause_ct = (com1_dev.baudrate / 8) / 1000 * 10;
	evtimer_set(&com1_dev.rate, ratelimit, NULL);

	event_set(&com1_dev.event, com1_dev.fd, EV_READ | EV_PERSIST,
	    com_rcv_event, (void *)(intptr_t)vmid);
	event_add(&com1_dev.event, NULL);
	return (0);
}
@


1.11
log
@whitespace and fix a comment typo
@
text
@d1 1
a1 1
/* $OpenBSD: ns8250.c,v 1.10 2017/07/15 05:05:36 pd Exp $ */
d449 1
a449 5
 * Emulate in/out instructions to the com1 (ns8250) UART scratch register. The
 * scratch register is sometimes used to distinguish an 8250 from a 16450,
 * and/or used to distinguish submodels of the 8250 (eg 8250A, 8250B). We
 * simulate an "original" 8250 by forcing the scratch register to return data
 * on read that is different from what was written.
d469 1
a469 3
		 * Read from SCR. To make sure we don't accidentally simulate
		 * a real scratch register, we negate what was written on
		 * subsequent readback.
d471 1
a471 1
		set_return_data(vei, ~com1_dev.regs.scr);
@


1.10
log
@Add vmctl send and vmctl receive

ok reyk@@ and mlarkin@@
@
text
@d1 1
a1 1
/* $OpenBSD: ns8250.c,v 1.9 2017/06/07 14:53:28 mlarkin Exp $ */
d89 1
a89 1
	 * 
@


1.9
log
@vmd: Implement simulated baudrate support in the ns8250 module. The
previous version was allowing an output rate that is "too fast", and linux
guests would give up after 512 characters TXed ("too much work for irq4").

This diff calculates the approximate rate we can sustain at the current
programmed baud rate and limits the output to that rate by inserting a
HZ delay after a specified number of characters have been transmitted.
This fixes the linux guest console issue.

Note that the console now outputs at more or less the selected baud rate,
instead of nearly instantaneously as before - if you selected 9600 in
your guest VMs before, you might want to change that to 115200 now for a
better console experience.

krw@@ "seems like a good idea to me"
@
text
@d1 1
a1 1
/* $OpenBSD: ns8250.c,v 1.8 2017/05/08 09:08:40 reyk Exp $ */
d611 7
@


1.8
log
@Adds functions to read and write state of devices in vmd.

This is required for implementing vmctl send and vmctl receive.  vmctl
send / receive are two new options that will support snapshotting VMs
and migrating VMs from one host to another. The atomicio files are
copied from usr.bin/ssh.

Patch from Pratik Vyas; this project was undertaken at San Jose State
University along with his three teammates, Ashwin, Harshada and Siri
with mlarkin@@ as the advisor.

OK mlarkin@@
@
text
@d1 1
a1 1
/* $OpenBSD: ns8250.c,v 1.7 2017/03/21 03:29:57 mlarkin Exp $ */
d42 20
d76 19
d99 5
d126 1
a126 1
		if ((com1_dev.regs.iir & 0x1) == 0) {
d166 4
a169 4
		/* XXX these ier and iir bits should be IER_x and IIR_x */
		if (com->regs.ier & 0x1) {
			com->regs.iir |= (2 << 1);
			com->regs.iir &= ~0x1;
a175 1

d200 5
d206 2
d209 8
a216 4
			/* Set TXRDY */
			com1_dev.regs.iir |= IIR_TXRDY;
			/* Set "interrupt pending" (IIR low bit cleared) */
			com1_dev.regs.iir &= ~0x1;
d219 4
a235 1
			/* XXX should this be com1_dev.data or 0xff? */
d255 1
a255 1
	if ((com1_dev.regs.iir & 0x1) == 0)
d273 3
d282 18
d500 4
d508 4
d525 1
a525 2
 * features with the exception of the divisor latch (eg, no baud
 * rate support)
d571 6
@


1.7
log
@Fix two errors in NS8250 (UART) emulation. The first error zeroed out the
high bits of %eax on reading register data from the emulated UART ports.
The second error didn't properly assert the TXRDY bit during init -
this bit was only set after the first character was sent. Both these
bugs caused seabios to not be able to output any data. Found during the
recent effort to get Linux guests booting.
@
text
@d1 1
a1 1
/* $OpenBSD: ns8250.c,v 1.6 2016/10/26 05:26:36 mlarkin Exp $ */
d34 1
d487 38
@


1.6
log
@
vmd(8)/vmctl(8) for i386. Some ugliness in #ifdef __i386__ areas will be
fixed in tree, but the changes required were pretty minimal.

Note that i386 hosts are still presently limited to running i386 guests.

ok deraadt, stefan, jca
@
text
@d1 1
a1 1
/* $OpenBSD: ns8250.c,v 1.5 2016/10/03 06:00:17 mlarkin Exp $ */
d157 1
a157 1
		if (com1_dev.regs.ier & 0x2) {
d173 1
a173 1
			vei->vei.vei_data = com1_dev.regs.data;
d178 2
a179 2
			vei->vei.vei_data = com1_dev.regs.data;
			log_warnx("guest reading com1 when not ready");
d199 1
d228 1
a228 1
		vei->vei.vei_data = com1_dev.regs.lcr;
d261 1
a261 1
		vei->vei.vei_data = com1_dev.regs.iir;
d299 1
a299 1
		vei->vei.vei_data = com1_dev.regs.mcr;
d331 1
a331 1
		vei->vei.vei_data = com1_dev.regs.lsr | LSR_TSRE | LSR_TXRDY;
d362 2
a363 2
		vei->vei.vei_data =
		    com1_dev.regs.lsr | MSR_DCD | MSR_DSR | MSR_CTS;
d398 1
a398 1
		vei->vei.vei_data = ~com1_dev.regs.scr;
d422 2
d430 1
a430 1
		vei->vei.vei_data = com1_dev.regs.ier;
@


1.5
log
@
add RCS tags
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d57 1
a57 1
	    com_rcv_event, (void *)(uint64_t)vmid);
@


1.4
log
@
fix some wrong interrupt code that doesn't fit with the new model

ok stefan@@
@
text
@d1 1
@


1.3
log
@Process incoming com data asynchronously to running VCPU

This registers a handler with libevent that is triggered on incoming
data on the com port.

ok mlarkin@@
@
text
@a126 8
	/*
	 * Clear "interrupt pending" by setting IIR low bit to 1 if no
	 * interrupts are pending
	 */
	/* XXX these iir magic numbers should be IIR_x */
	if ((com->regs.iir & ~0x1) == 0x0)
		com->regs.iir = 0x1;

@


1.2
log
@
change some log_warn to log_warnx and convert some integer literals to
enumerand values
@
text
@d23 3
d31 2
d35 4
a38 1
struct ns8250_regs com1_regs;
d41 1
a41 1
ns8250_init(int fd)
d43 44
a86 2
	memset(&com1_regs, 0, sizeof(struct ns8250_regs));
	com1_regs.fd = fd;
d90 50
d147 3
d151 2
a152 2
void
vcpu_process_com_data(union vm_exit *vei)
d163 2
a164 2
		write(com1_regs.fd, &vei->vei.vei_data, 1);
		if (com1_regs.ier & 0x2) {
d166 1
a166 1
			com1_regs.iir |= IIR_TXRDY;
d168 1
a168 1
			com1_regs.iir &= ~0x1;
d179 4
a182 4
		if (com1_regs.lsr & LSR_RXRDY) {
			vei->vei.vei_data = com1_regs.data;
			com1_regs.data = 0x0;
			com1_regs.lsr &= ~LSR_RXRDY;
d184 2
a185 2
			/* XXX should this be com1_regs.data or 0xff? */
			vei->vei.vei_data = com1_regs.data;
d190 1
a190 1
		com1_regs.iir &= ~IIR_RXRDY;
d196 5
a200 2
		if (com1_regs.iir == 0x0)
			com1_regs.iir = 0x1;
d202 5
d227 1
a227 1
		com1_regs.lcr = (uint8_t)vei->vei.vei_data;
d234 1
a234 1
		vei->vei.vei_data = com1_regs.lcr;
d259 1
a259 1
		com1_regs.fcr = vei->vei.vei_data;
d267 2
a268 2
		vei->vei.vei_data = com1_regs.iir;
		com1_regs.iir &= ~IIR_TXRDY;
d274 2
a275 2
		if (com1_regs.iir == 0x0)
			com1_regs.iir = 0x1;
d298 1
a298 1
		com1_regs.mcr = vei->vei.vei_data;
d305 1
a305 1
		vei->vei.vei_data = com1_regs.mcr;
d337 1
a337 1
		vei->vei.vei_data = com1_regs.lsr | LSR_TSRE | LSR_TXRDY;
d368 2
a369 1
		vei->vei.vei_data = com1_regs.lsr | MSR_DCD | MSR_DSR | MSR_CTS;
d395 1
a395 1
		com1_regs.scr = vei->vei.vei_data;
d404 1
a404 1
		vei->vei.vei_data = ~com1_regs.scr;
d427 1
a427 1
		com1_regs.ier = vei->vei.vei_data;
d434 1
a434 1
		vei->vei.vei_data = com1_regs.ier;
d455 1
d458 2
d483 2
a484 1
		vcpu_process_com_data(vei);
d488 2
a489 42
	return (0xFF);
}

/* XXX temporary until this is polled */
int
vcpu_com1_needs_intr(void)
{
	int need_irq = 0;
	ssize_t sz;
	char ch;

	/*
	 * Is there a new character available on com1?
	 * If so, consume the character, buffer it into the com1 data register
	 * assert IRQ4, and set the line status register RXRDY bit.
	 *
	 * XXX - move all this com intr checking to another function using poll
	 */
	sz = read(com1_regs.fd, &ch, sizeof(char));
	if (sz == 1) {
		com1_regs.lsr |= LSR_RXRDY;
		com1_regs.data = ch;
		/* XXX these ier and iir bits should be IER_x and IIR_x */
		if (com1_regs.ier & 0x1) {
			com1_regs.iir |= (2 << 1);
			com1_regs.iir &= ~0x1;
		}
	}

	/*
	 * Clear "interrupt pending" by setting IIR low bit to 1 if no
	 * interrupts are pending
	 */
	/* XXX these iir magic numbers should be IIR_x */
	if ((com1_regs.iir & ~0x1) == 0x0)
		com1_regs.iir = 0x1;

	/* If pending interrupt, inject */
	if ((com1_regs.iir & 0x1) == 0)
		need_irq = 1;

	return need_irq;
@


1.1
log
@
Add a set of emulated legacy devices (PIT, PIC, RTC)

discussed with stefan and deraadt
@
text
@d52 1
a52 1
	 * vei_dir == 0 : out instruction
d59 1
a59 1
	if (vei->vei.vei_dir == 0) {
d69 1
a69 1
		 * vei_dir == 1 : in instruction
d111 1
a111 1
	 * vei_dir == 0 : out instruction
d115 1
a115 1
	if (vei->vei.vei_dir == 0) {
d119 1
a119 1
		 * vei_dir == 1 : in instruction
d143 1
a143 1
	 * vei_dir == 0 : out instruction
d147 1
a147 1
	if (vei->vei.vei_dir == 0) {
d151 1
a151 1
		 * vei_dir == 1 : in instruction
d182 1
a182 1
	 * vei_dir == 0 : out instruction
d186 1
a186 1
	if (vei->vei.vei_dir == 0) {
d190 1
a190 1
		 * vei_dir == 1 : in instruction
d211 1
a211 1
	 * vei_dir == 0 : out instruction
d216 1
a216 1
	if (vei->vei.vei_dir == 0) {
d221 1
a221 1
		 * vei_dir == 1 : in instruction
d243 1
a243 1
	 * vei_dir == 0 : out instruction
d248 1
a248 1
	if (vei->vei.vei_dir == 0) {
d253 1
a253 1
		 * vei_dir == 1 : in instruction
d278 1
a278 1
	 * vei_dir == 0 : out instruction
d282 1
a282 1
	if (vei->vei.vei_dir == 0) {
d286 1
a286 1
		 * vei_dir == 1 : in instruction
d310 1
a310 1
	 * vei_dir == 0 : out instruction
d314 1
a314 1
	if (vei->vei.vei_dir == 0) {
d318 1
a318 1
		 * vei_dir == 1 : in instruction
@

