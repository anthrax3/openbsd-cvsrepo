head	1.49;
access;
symbols
	OPENBSD_6_1_BASE:1.49
	OPENBSD_6_0:1.21.0.2
	OPENBSD_6_0_BASE:1.21
	OPENBSD_5_9:1.18.0.2
	OPENBSD_5_9_BASE:1.18;
locks; strict;
comment	@ * @;


1.49
date	2017.03.25.16.28.25;	author reyk;	state Exp;
branches;
next	1.48;
commitid	s82EA2LBuZtftmLN;

1.48
date	2017.03.15.18.06.18;	author reyk;	state Exp;
branches;
next	1.47;
commitid	olrxKy4ehROyBXsm;

1.47
date	2017.03.02.07.33.37;	author reyk;	state Exp;
branches;
next	1.46;
commitid	0uvzhmQVR7Ehsjus;

1.46
date	2017.03.01.18.00.50;	author reyk;	state Exp;
branches;
next	1.45;
commitid	cyTuz5D4aJNa7GE5;

1.45
date	2017.03.01.07.43.33;	author reyk;	state Exp;
branches;
next	1.44;
commitid	2hnfyuVZdSB2L5DB;

1.44
date	2017.02.27.14.37.58;	author reyk;	state Exp;
branches;
next	1.43;
commitid	VZNWondGbqn2F9Is;

1.43
date	2017.01.13.19.21.16;	author edd;	state Exp;
branches;
next	1.42;
commitid	G03UUOsXsvVsTKN2;

1.42
date	2017.01.13.14.50.56;	author reyk;	state Exp;
branches;
next	1.41;
commitid	O6Az38HSBXh6vWTC;

1.41
date	2017.01.11.22.38.10;	author reyk;	state Exp;
branches;
next	1.40;
commitid	36vA2wHEJBH4Kmuc;

1.40
date	2016.12.14.21.17.25;	author reyk;	state Exp;
branches;
next	1.39;
commitid	yUESeopyz7N219vi;

1.39
date	2016.12.14.06.59.12;	author reyk;	state Exp;
branches;
next	1.38;
commitid	InVlLp4UCIsZp75o;

1.38
date	2016.11.26.20.03.42;	author reyk;	state Exp;
branches;
next	1.37;
commitid	GrCSblbcTEkTQcOY;

1.37
date	2016.11.26.19.49.11;	author reyk;	state Exp;
branches;
next	1.36;
commitid	ad2wVCUrs7CBTqdu;

1.36
date	2016.11.24.07.58.55;	author reyk;	state Exp;
branches;
next	1.35;
commitid	vTTzvT7jwtD1X8ZA;

1.35
date	2016.11.22.11.31.38;	author edd;	state Exp;
branches;
next	1.34;
commitid	vSgc5Dc31FPMjVfo;

1.34
date	2016.11.04.15.16.44;	author reyk;	state Exp;
branches;
next	1.33;
commitid	SAdDSuqFvlzVuxeB;

1.33
date	2016.11.04.15.07.26;	author reyk;	state Exp;
branches;
next	1.32;
commitid	qfn7LnsEzfGhtk0c;

1.32
date	2016.10.29.14.56.05;	author edd;	state Exp;
branches;
next	1.31;
commitid	DOewrpkDk9kNopaK;

1.31
date	2016.10.17.16.26.20;	author reyk;	state Exp;
branches;
next	1.30;
commitid	QbpP9IWB9tkvRriq;

1.30
date	2016.10.15.14.02.11;	author reyk;	state Exp;
branches;
next	1.29;
commitid	17YGcUnMa3ic5LJQ;

1.29
date	2016.10.12.19.10.03;	author reyk;	state Exp;
branches;
next	1.28;
commitid	ghkPP3DbrIiwazmp;

1.28
date	2016.10.06.18.48.41;	author reyk;	state Exp;
branches;
next	1.27;
commitid	PTFbBM1dh72QP2DS;

1.27
date	2016.10.05.17.30.13;	author reyk;	state Exp;
branches;
next	1.26;
commitid	c3mC9fNmRbfUPluH;

1.26
date	2016.10.04.17.17.30;	author reyk;	state Exp;
branches;
next	1.25;
commitid	yb7Y2lNmLG5i2hzO;

1.25
date	2016.09.29.22.42.04;	author reyk;	state Exp;
branches;
next	1.24;
commitid	OrqC5N55KjzTfX1Z;

1.24
date	2016.09.02.16.23.40;	author stefan;	state Exp;
branches;
next	1.23;
commitid	5HafKfGZWjgaFI0t;

1.23
date	2016.09.01.14.48.09;	author mlarkin;	state Exp;
branches;
next	1.22;
commitid	FBqVpmx18MX292rY;

1.22
date	2016.07.29.16.36.51;	author stefan;	state Exp;
branches;
next	1.21;
commitid	lYP7ykFkRsliCh0y;

1.21
date	2016.07.09.09.06.22;	author stefan;	state Exp;
branches;
next	1.20;
commitid	yIWxq4qxCQhfbPDu;

1.20
date	2016.04.04.17.13.54;	author stefan;	state Exp;
branches;
next	1.19;
commitid	Y1YC68R7VkcaKZ1f;

1.19
date	2016.03.13.13.11.47;	author stefan;	state Exp;
branches;
next	1.18;
commitid	tNFHzbetplEWT4Tg;

1.18
date	2016.01.16.08.55.40;	author stefan;	state Exp;
branches;
next	1.17;
commitid	AJ7cyewTvXIt6nft;

1.17
date	2016.01.02.15.05.21;	author benno;	state Exp;
branches;
next	1.16;
commitid	mIea27doBpRWKvpo;

1.16
date	2015.12.11.10.16.53;	author reyk;	state Exp;
branches;
next	1.15;
commitid	czO28zk1ubQjkjYC;

1.15
date	2015.12.06.21.02.51;	author reyk;	state Exp;
branches;
next	1.14;
commitid	Zp1KJ8lrcRoKUs6F;

1.14
date	2015.12.06.19.37.15;	author mlarkin;	state Exp;
branches;
next	1.13;
commitid	9ehS4FoWNALLyJ8r;

1.13
date	2015.12.06.10.30.41;	author reyk;	state Exp;
branches;
next	1.12;
commitid	3MIl7t8V6z3UeRk5;

1.12
date	2015.12.06.02.26.14;	author reyk;	state Exp;
branches;
next	1.11;
commitid	DA7pwA53qcaD5xYQ;

1.11
date	2015.12.06.01.58.21;	author reyk;	state Exp;
branches;
next	1.10;
commitid	mJFYjYlVhI5frPwA;

1.10
date	2015.12.03.23.32.32;	author reyk;	state Exp;
branches;
next	1.9;
commitid	ABlEnH3RsSBpSsyK;

1.9
date	2015.12.03.16.11.32;	author reyk;	state Exp;
branches;
next	1.8;
commitid	G1u4CGxMrb6r5d6R;

1.8
date	2015.12.03.13.27.14;	author reyk;	state Exp;
branches;
next	1.7;
commitid	pRSLgXNuoj9hRPQx;

1.7
date	2015.12.03.08.42.11;	author reyk;	state Exp;
branches;
next	1.6;
commitid	deOxsg54am7A6Za6;

1.6
date	2015.12.02.23.33.43;	author reyk;	state Exp;
branches;
next	1.5;
commitid	w96GQ2Dz9TsvO0tu;

1.5
date	2015.12.02.22.19.11;	author reyk;	state Exp;
branches;
next	1.4;
commitid	7ra6VeOJoUb1NQ70;

1.4
date	2015.12.02.09.14.25;	author reyk;	state Exp;
branches;
next	1.3;
commitid	vOctzllSJTLtnazM;

1.3
date	2015.11.23.13.04.49;	author reyk;	state Exp;
branches;
next	1.2;
commitid	8LSTqui1EesFdS0T;

1.2
date	2015.11.22.21.51.32;	author reyk;	state Exp;
branches;
next	1.1;
commitid	nvO8KnrtEKRaTvXw;

1.1
date	2015.11.22.20.20.32;	author mlarkin;	state Exp;
branches;
next	;
commitid	O5Ay1ZamHQn9lamK;


desc
@@


1.49
log
@Boot using BIOS from /etc/firmware/vmm-bios by default.

Instead of using the internal "vmboot", VMs will now be booted using
the external BIOS firmware in /etc/firmware/vmm-bios (which is subject
to a LGPLv3 license).  Direct booting of OpenBSD kernels or
non-default BIOS images is still supported for now using the -b/boot
option that is replacing the -k/kernel option.

As requested by Theo, vmd(8) fails if neither the default BIOS is
found nor a kernel has been specified in the VM configuration.  The
"vmm" BIOS has to be installed using fw_update(1), which will be done
automatically in most cases where the OpenBSD can fetch it after
install/upgrade.

OK mlarkin@@
@
text
@/*	$OpenBSD: vmd.h,v 1.48 2017/03/15 18:06:18 reyk Exp $	*/

/*
 * Copyright (c) 2015 Mike Larkin <mlarkin@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/queue.h>
#include <sys/socket.h>

#include <machine/vmmvar.h>

#include <net/if.h>

#include <limits.h>
#include <stdio.h>
#include <pthread.h>

#include "proc.h"

#ifndef VMD_H
#define VMD_H

#define VMD_USER		"_vmd"
#define VMD_CONF		"/etc/vm.conf"
#define SOCKET_NAME		"/var/run/vmd.sock"
#define VMM_NODE		"/dev/vmm"
#define VM_DEFAULT_BIOS		"/etc/firmware/vmm-bios"
#define VM_DEFAULT_KERNEL	"/bsd"
#define VM_DEFAULT_DEVICE	"hd0a"
#define VM_BOOT_CONF		"/etc/boot.conf"
#define VM_NAME_MAX		64
#define VM_TTYNAME_MAX		16
#define MAX_TAP			256
#define NR_BACKLOG		5
#define VMD_SWITCH_TYPE		"bridge"
#define VM_DEFAULT_MEMORY	512

#ifdef VMD_DEBUG
#define dprintf(x...)   do { log_debug(x); } while(0)
#else
#define dprintf(x...)
#endif /* VMD_DEBUG */

enum imsg_type {
	IMSG_VMDOP_START_VM_REQUEST = IMSG_PROC_MAX,
	IMSG_VMDOP_START_VM_DISK,
	IMSG_VMDOP_START_VM_IF,
	IMSG_VMDOP_START_VM_END,
	IMSG_VMDOP_START_VM_RESPONSE,
	IMSG_VMDOP_TERMINATE_VM_REQUEST,
	IMSG_VMDOP_TERMINATE_VM_RESPONSE,
	IMSG_VMDOP_TERMINATE_VM_EVENT,
	IMSG_VMDOP_GET_INFO_VM_REQUEST,
	IMSG_VMDOP_GET_INFO_VM_DATA,
	IMSG_VMDOP_GET_INFO_VM_END_DATA,
	IMSG_VMDOP_LOAD,
	IMSG_VMDOP_RELOAD,
	IMSG_VMDOP_PRIV_IFDESCR,
	IMSG_VMDOP_PRIV_IFADD,
	IMSG_VMDOP_PRIV_IFCREATE,
	IMSG_VMDOP_PRIV_IFUP,
	IMSG_VMDOP_PRIV_IFDOWN,
	IMSG_VMDOP_PRIV_IFGROUP,
	IMSG_VMDOP_VM_SHUTDOWN,
	IMSG_VMDOP_VM_REBOOT
};

struct vmop_result {
	int			 vmr_result;
	uint32_t		 vmr_id;
	pid_t			 vmr_pid;
	char			 vmr_ttyname[VM_TTYNAME_MAX];
};

struct vmop_info_result {
	struct vm_info_result	 vir_info;
	char			 vir_ttyname[VM_TTYNAME_MAX];
	uid_t			 vir_uid;
	int64_t			 vir_gid;
};

struct vmop_id {
	uint32_t		 vid_id;
	char			 vid_name[VMM_MAX_NAME_LEN];
	uid_t			 vid_uid;
};

struct vmop_ifreq {
	uint32_t		 vfr_id;
	char			 vfr_name[IF_NAMESIZE];
	char			 vfr_value[VM_NAME_MAX];
};

struct vmop_create_params {
	struct vm_create_params	 vmc_params;
	unsigned int		 vmc_flags;
#define VMOP_CREATE_KERNEL	0x01
#define VMOP_CREATE_MEMORY	0x02
#define VMOP_CREATE_NETWORK	0x04
#define VMOP_CREATE_DISK	0x08

	/* userland-only part of the create params */
	unsigned int		 vmc_ifflags[VMM_MAX_NICS_PER_VM];
#define VMIFF_UP		0x01
#define VMIFF_LOCKED		0x02
#define VMIFF_OPTMASK		VMIFF_LOCKED
	char			 vmc_ifnames[VMM_MAX_NICS_PER_VM][IF_NAMESIZE];
	char			 vmc_ifswitch[VMM_MAX_NICS_PER_VM][VM_NAME_MAX];
	char			 vmc_ifgroup[VMM_MAX_NICS_PER_VM][IF_NAMESIZE];
	uid_t			 vmc_uid;
	int64_t			 vmc_gid;
};

struct vmboot_params {
	int			 vbp_fd;
	off_t			 vbp_partoff;
	char			 vbp_device[NAME_MAX];
	char			 vbp_image[PATH_MAX];
	uint32_t		 vbp_bootdev;
	uint32_t		 vbp_howto;
	char			*vbp_arg;
};

struct vmd_if {
	char			*vif_name;
	char			*vif_switch;
	char			*vif_group;
	int			 vif_fd;
	unsigned int		 vif_flags;
	TAILQ_ENTRY(vmd_if)	 vif_entry;
};
TAILQ_HEAD(viflist, vmd_if);

struct vmd_switch {
	uint32_t		 sw_id;
	char			*sw_name;
	char			 sw_ifname[IF_NAMESIZE];
	char			*sw_group;
	unsigned int		 sw_flags;
	struct viflist		 sw_ifs;
	int			 sw_running;
	TAILQ_ENTRY(vmd_switch)	 sw_entry;
};
TAILQ_HEAD(switchlist, vmd_switch);

struct vmd_vm {
	struct vmop_create_params vm_params;
	pid_t			 vm_pid;
	/* Userspace ID of VM. The user never sees this */
	uint32_t		 vm_vmid;
	int			 vm_kernel;
	int			 vm_disks[VMM_MAX_DISKS_PER_VM];
	struct vmd_if		 vm_ifs[VMM_MAX_NICS_PER_VM];
	char			*vm_ttyname;
	int			 vm_tty;
	uint32_t		 vm_peerid;
	/* When set, VM is running now (PROC_PARENT only) */
	int			 vm_running;
	/* When set, VM is not started by default (PROC_PARENT only) */
	int			 vm_disabled;
	/* When set, VM was defined in a config file */
	int			 vm_from_config;
	struct imsgev		 vm_iev;
	int			 vm_shutdown;
	uid_t			 vm_uid;

	TAILQ_ENTRY(vmd_vm)	 vm_entry;
};
TAILQ_HEAD(vmlist, vmd_vm);

struct vmd {
	struct privsep		 vmd_ps;
	const char		*vmd_conffile;

	int			 vmd_debug;
	int			 vmd_verbose;
	int			 vmd_noaction;

	uint32_t		 vmd_nvm;
	struct vmlist		*vmd_vms;

	uint32_t		 vmd_nswitches;
	struct switchlist	*vmd_switches;

	int			 vmd_fd;
	int			 vmd_ptmfd;
};

/* vmd.c */
void	 vmd_reload(unsigned int, const char *);
struct vmd_vm *vm_getbyvmid(uint32_t);
struct vmd_vm *vm_getbyid(uint32_t);
struct vmd_vm *vm_getbyname(const char *);
struct vmd_vm *vm_getbypid(pid_t);
void	 vm_stop(struct vmd_vm *, int);
void	 vm_remove(struct vmd_vm *);
int	 vm_register(struct privsep *, struct vmop_create_params *,
	    struct vmd_vm **, uint32_t, uid_t);
int	 vm_checkperm(struct vmd_vm *, uid_t);
int	 vm_opentty(struct vmd_vm *);
void	 vm_closetty(struct vmd_vm *);
void	 switch_remove(struct vmd_switch *);
struct vmd_switch *switch_getbyname(const char *);
char	*get_string(uint8_t *, size_t);

/* priv.c */
void	 priv(struct privsep *, struct privsep_proc *);
int	 priv_getiftype(char *, char *, unsigned int *);
int	 priv_findname(const char *, const char **);
int	 priv_validgroup(const char *);
int	 vm_priv_ifconfig(struct privsep *, struct vmd_vm *);
int	 vm_priv_brconfig(struct privsep *, struct vmd_switch *);

/* vmm.c */
void	 vmm(struct privsep *, struct privsep_proc *);
void	 vmm_shutdown(void);
int	 write_mem(paddr_t, void *buf, size_t);
int	 read_mem(paddr_t, void *buf, size_t);
int	 opentap(char *);
int	 fd_hasdata(int);
void	 mutex_lock(pthread_mutex_t *);
void	 mutex_unlock(pthread_mutex_t *);
int	 vmm_pipe(struct vmd_vm *, int, void (*)(int, short, void *));

/* vm.c */
int	 start_vm(struct vmd_vm *, int);
__dead void vm_shutdown(unsigned int);

/* control.c */
int	 config_init(struct vmd *);
void	 config_purge(struct vmd *, unsigned int);
int	 config_setreset(struct vmd *, unsigned int);
int	 config_getreset(struct vmd *, struct imsg *);
int	 config_setvm(struct privsep *, struct vmd_vm *, uint32_t, uid_t);
int	 config_getvm(struct privsep *, struct imsg *);
int	 config_getdisk(struct privsep *, struct imsg *);
int	 config_getif(struct privsep *, struct imsg *);

/* vmboot.c */
FILE	*vmboot_open(int, int, struct vmboot_params *);
void	 vmboot_close(FILE *, struct vmboot_params *);

/* parse.y */
int	 parse_config(const char *);
int	 cmdline_symset(char *);

#endif /* VMD_H */
@


1.48
log
@Improve vmmci(4) shutdown and reboot.

This change handles various cases to power off the VM, even if it is
unresponsive, stuck in ddb, or when the shutdown was initiated from
the VM guest side.  Usage of timeout and VM ACKs make sure that the VM
is really turned off at some point.

OK mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmd.h,v 1.47 2017/03/02 07:33:37 reyk Exp $	*/
d40 1
@


1.47
log
@Add "locked lladdr" option to prevent VMs from spoofing MAC addresses.

This is especially useful when multiple VMs share a switch, the
implementation is independent from the underlying switch or bridge.

no objections mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmd.h,v 1.46 2017/03/01 18:00:50 reyk Exp $	*/
d239 1
@


1.46
log
@Split vmm.c into two files: vm.c for the VM child, vmm.c for the parent

As discussed with mlarkin@@, it makes it easier to maintain the file.

OK mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmd.h,v 1.45 2017/03/01 07:43:33 reyk Exp $	*/
d116 3
@


1.45
log
@Add "owner" option to set a user/group ownership for pre-configured VMs

This allows matching users to start or stop VMs that they "own" and to
access the console accordingly.

OK mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmd.h,v 1.44 2017/02/27 14:37:58 reyk Exp $	*/
d232 4
@


1.44
log
@Replace openpty(3) with local function that uses pre-opened /dev/ptm fd

This allows more flexibility for upcoming changes and better pledge.
We also didn't use half of the features of libutil's openpty function.
Additionally, make sure that the ttys are closed correctly on shutdown.

OK gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmd.h,v 1.43 2017/01/13 19:21:16 edd Exp $	*/
d90 2
d97 1
d119 2
d174 2
d207 2
a208 1
	    struct vmd_vm **, uint32_t);
d238 1
a238 1
int	 config_setvm(struct privsep *, struct vmd_vm *, uint32_t);
@


1.43
log
@Make it possible to remove VMs from vmd(8)'s internal queue.

The semantics agreed with reyk@@ are:

 * ad-hoc created vms, created  with `vmctl start`, are removed once stopped.
 * Stopped VMs defined in a config file are flushed before a `vmctl reload`.

OK reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmd.h,v 1.42 2017/01/13 14:50:56 reyk Exp $	*/
d188 1
d201 2
@


1.42
log
@Add host side of vmmci(4) to vmd(8).

It currently uses the device to request graceful shutdown of a VM on
"vmctl stop myvm" but will be extended for reboot and a other edge cases.

OK mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmd.h,v 1.41 2017/01/11 22:38:10 reyk Exp $	*/
d165 2
@


1.41
log
@Add imsg communication channel between vmd and invividual VMs.
For now, this is only used to forward "log verbose|brief" requests,
but it will be used for better things later.

OK mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmd.h,v 1.40 2016/12/14 21:17:25 reyk Exp $	*/
d75 3
a77 1
	IMSG_VMDOP_PRIV_IFGROUP
d166 1
@


1.40
log
@Allow to start disabled and pre-configured VMs by name, "vmctl start foo".

With testing from Jon Bernard

OK mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmd.h,v 1.39 2016/12/14 06:59:12 reyk Exp $	*/
d163 1
@


1.39
log
@If a VM terminates with the result EAGAIN, close all fds except the
pty and re-send it to the vmm monitor process.  With additional
changes in vmm.c, this will allow perform a cold reboot of VM.

With testing and feedback from Jon Bernard
OK mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmd.h,v 1.38 2016/11/26 20:03:42 reyk Exp $	*/
d103 5
@


1.38
log
@Implement basic support for boot.conf(8) on the disk image.

Like the real boot loader, load and parse hd0a:/etc/boot.conf from the
first disk and fall back to /bsd.  Not all boot loader options are
supported, but it at least does set device, set image, and boot -acds
(eg. for booting single-user).

For example, it can now boot install60.fs that includes a boot.conf
with "set image /6.0/amd64/bsd.rd":
	vmctl start install -c -d install60.fs -d OpenBSD.img

This pseudo-bootloader is only needed without BIOS and could
potentially be replaced in the future.

OK mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmd.h,v 1.37 2016/11/26 19:49:11 reyk Exp $	*/
d185 1
@


1.37
log
@If -m/memory is not specified, use 512M by default.

Default value picked with mlarkin - not too small and not too large.

OK mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmd.h,v 1.36 2016/11/24 07:58:55 reyk Exp $	*/
d41 2
d111 10
d221 2
a222 2
FILE	*vmboot_open(int, int, void **);
void	 vmboot_close(FILE *, void *);
@


1.36
log
@Add support for booting the kernel from the disk image.

This make the kernel/-k argument optional and, if not specified, tries
to find the /bsd kernel in the primary hd0a partition of the first
disk image itself.  It doesn't support hd0a:/etc/boot.conf yet, and it
is no BIOS or full boot loader, but it makes booting and handling of
VMs a bit easier - booting an external kernel is still supported.

The UFS file system code ufs.c is directly from libsa which is also
used by the real boot loader.  The code compiles with a few signedness
warning which will be fixed separately.

OK mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmd.h,v 1.35 2016/11/22 11:31:38 edd Exp $	*/
d46 1
@


1.35
log
@Insert disabled VMs into vmd(8)'s queues and allow vmctl(8) to display them.

Tested by Jon Bernard and reyk@@.

OK reyk@@, no objections mlarkin@@.

Thanks
@
text
@d1 1
a1 1
/*	$OpenBSD: vmd.h,v 1.34 2016/11/04 15:16:44 reyk Exp $	*/
d28 1
d40 1
d206 4
@


1.34
log
@Pass the internal vmid or 0 to vm_register() instead of changing it
once again after setting the next available id.

Suggested by edd@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmd.h,v 1.33 2016/11/04 15:07:26 reyk Exp $	*/
d131 1
d139 1
d141 2
@


1.33
log
@Update the config/register/get VM methods to match the config_set/get
style that is used in other places.  Also keep the vmid from the parent.

OK edd@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmd.h,v 1.32 2016/10/29 14:56:05 edd Exp $	*/
d168 1
a168 1
	    struct vmd_vm **);
@


1.32
log
@Separate parsing vms and switches from starting them in vmd(8).

Brings us one step closer to having disabled by default vms is vm.conf(5),
which can be started with vmctl(8).

Input, testing and OK reyk@@. Thanks.
@
text
@d1 1
a1 1
/*	$OpenBSD: vmd.h,v 1.31 2016/10/17 16:26:20 reyk Exp $	*/
d167 2
d196 2
a197 3
int	 config_registervm(struct privsep *, struct vmop_create_params *,
	    struct vmd_vm **);
int	 config_getvm(struct privsep *, struct vmd_vm *, int, uint32_t);
@


1.31
log
@Add the option to specify an interface group per virtual switch as well;
this group will be added to all VM tap(4) interfaces in the switch.

Tested by martijn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmd.h,v 1.30 2016/10/15 14:02:11 reyk Exp $	*/
d123 1
d129 1
a129 1
	struct vm_create_params	 vm_params;
d138 1
d194 3
a196 2
int	 config_getvm(struct privsep *, struct vmop_create_params *,
	    int, uint32_t);
@


1.30
log
@Allow to add an interface to an interface group; with the group keyword.

Requested and tested by martijn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmd.h,v 1.29 2016/10/12 19:10:03 reyk Exp $	*/
d120 1
@


1.29
log
@Fix functionality and semantics of vmctl load/reload/reset.

OK rzalamena@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmd.h,v 1.28 2016/10/06 18:48:41 reyk Exp $	*/
d69 2
a70 1
	IMSG_VMDOP_PRIV_IFDOWN
d103 1
d109 1
d172 1
@


1.28
log
@Terminate VMs on shutdown of vmd instead of leaving them running as
undead VM processes.

OK mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmd.h,v 1.27 2016/10/05 17:30:13 reyk Exp $	*/
d155 1
a155 1
void	 vmd_reload(int, const char *);
@


1.27
log
@Add support for enhanced networking configuration and virtual switches.
See vm.conf(5) for more details.

OK mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmd.h,v 1.26 2016/10/04 17:17:30 reyk Exp $	*/
d174 1
@


1.26
log
@Add a new "priv" process that is responsible for ioctls and restricted
operations that aren't allowed under pledge.  This is a companion to
the "vmd" process that runs as root but with pledge.

With the "priv" process, each new tap(4) interface now gets a
description to indicate the vm, eg. "vm1-if0-myvm".  For network
configuration will be done by vmd/priv later.

OK mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmd.h,v 1.25 2016/09/29 22:42:04 reyk Exp $	*/
d43 1
d65 5
a69 1
	IMSG_VMDOP_PRIV_IFDESCR
d95 28
d129 1
a129 2
	int			 vm_ifs[VMM_MAX_NICS_PER_VM];
	char			*vm_ifnames[VMM_MAX_NICS_PER_VM];
a143 1
	int			 vmd_vmcount;
d148 3
d161 2
d167 2
d170 1
d186 1
a186 1
int	 config_getvm(struct privsep *, struct vm_create_params *,
@


1.25
log
@Implement fork+exec for vmd, using the same framework from httpd etc.

No objections from mlarkin@@ sunil@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmd.h,v 1.24 2016/09/02 16:23:40 stefan Exp $	*/
d21 1
d25 2
d40 1
a40 1
#define VM_TTYNAME_MAX		12
d58 1
d64 1
a64 1
	IMSG_VMDOP_TERMINATE_VM_EVENT
d84 6
d97 2
a98 1
	char			 vm_ttyname[VM_TTYNAME_MAX];
d129 4
d137 1
a137 1
int	 opentap(void);
@


1.24
log
@Move event handling to separate thread

That allows the main thread to handle the termination
of a VM on reboot/shutdown or normal exit. The way it works
is that VCPUs that terminate for some reason communicate this
to a main thread that takes care of shutdown.

ok mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmd.h,v 1.23 2016/09/01 14:48:09 mlarkin Exp $	*/
d119 1
a119 1
pid_t	 vmm(struct privsep *, struct privsep_proc *);
@


1.23
log
@
Add a set of emulated legacy devices (PIT, PIC, RTC)

discussed with stefan and deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: vmd.h,v 1.22 2016/07/29 16:36:51 stefan Exp $	*/
d25 1
d124 2
@


1.22
log
@Allow starting a VM again after it was terminated

If a VM exits, terminate it and remove it from the list of
available VMs. That allows a VM with name `foo' to be restarted
after it has exited.

This changes structures shared between vmd and vmctl. You need to
rebuild vmctl also.

ok mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmd.h,v 1.21 2016/07/09 09:06:22 stefan Exp $	*/
a38 2

/* #define VMD_DEBUG */
@


1.21
log
@Prepare vionet to be handled asynchronously to the VCPU thread

This splits the handling of received data into a separate function
that can later be called in parallel to the VCPU thread instead of
handling received packets on VCPU exits only.

It also makes virtq accesses in the rx path safe to run in parallel
to the VCPU thread: the last index into the 'avail' ring the driver
has notified to the host is kept track of. It also makes sure that
the host only writes back to the 'avail' ring instead of modifying
the whole receive virtq.

While there, describe what virtio_vq_info and virtio_io_cfg are used
for, as suggested by mlarkin@@

ok mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmd.h,v 1.20 2016/04/04 17:13:54 stefan Exp $	*/
d60 2
a61 1
	IMSG_VMDOP_RELOAD
d67 1
d83 1
d115 1
@


1.20
log
@Directly use physical addresses from ELF header for kernel loading.

This allows us to remove the 'do_mask' parameters in read_mem and
write_mem as well as the address mask operaton itself.

ok mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmd.h,v 1.19 2016/03/13 13:11:47 stefan Exp $	*/
d120 1
@


1.19
log
@Introduce memory ranges to support VMs with >= 4G RAM

Kernel bits:
- When creating a VM, a list of memory ranges has to be specified,
  similar to the BIOS memory map. This is necessary for VMs with
  RAM sizes approaching 4G because we'll need PCI MMIO space in
  the higher parts of the 32 bit address space.

vmctl and vmd bits:
- Construct appropriate memory ranges to create a VM with a given
  RAM size
- Construct a corresponding BIOS memory map from the memory ranges
  and update the boot params page accordingly.
- Make sure that all variables that represent guest physical addresses
  match the address width of the target CPU instead of using uint32_t.
- Fix some integer promotion glitches that actually restricted VM
  RAM size to 2G.

This changes the VM create ioctl interface, so update your kernel,
vmd, and vmctl.

ok mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmd.h,v 1.18 2016/01/16 08:55:40 stefan Exp $	*/
d117 2
a118 2
int	 write_mem(paddr_t, void *buf, size_t, int);
int	 read_mem(paddr_t, void *buf, size_t, int);
@


1.18
log
@vmd(8) sometimes attempts page-crossing data copies between the host
and guest. The readpage/writepage ioctls of vmm(4) do not support this
and they return EINVAL on such attempts since recently.

Avoid page-crossing guest memory accesses by changing read_page() and
write_page() into read_mem() and write_mem() that can copy arbitrary
lengths of data between host<->guest without page-crossing accesses.

This also allows us to remove page-wise copy-loops in a few places.

ok mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmd.h,v 1.17 2016/01/02 15:05:21 benno Exp $	*/
d117 2
a118 2
int	 write_mem(uint32_t dst, void *buf, uint32_t, int);
int	 read_mem(uint32_t dst, void *buf, uint32_t, int);
@


1.17
log
@fix typo in comment, found by Michal Mazurek, thanks
@
text
@d1 1
a1 1
/*	$OpenBSD: vmd.h,v 1.16 2015/12/11 10:16:53 reyk Exp $	*/
d117 2
a118 2
int	 write_page(uint32_t dst, void *buf, uint32_t, int);
int	 read_page(uint32_t dst, void *buf, uint32_t, int);
@


1.16
log
@The vmctl "id" argument can now be a number of or a vm name, eg.
vmctl stop 3
vmctl stop "openbsd.vm"
@
text
@d1 1
a1 1
/*	$OpenBSD: vmd.h,v 1.15 2015/12/06 21:02:51 reyk Exp $	*/
d46 1
a46 1
#endif /* VMM_DEBUG */
@


1.15
log
@Prevent running a VM with the same name multiple times - multiple
instances of the same configuration will be handled in a different way
later.  It is also not a good idea to use the same writeable disk
with multiple VMs at the same time.

As discussed with mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmd.h,v 1.14 2015/12/06 19:37:15 mlarkin Exp $	*/
d72 5
@


1.14
log
@
remove some now-unused enums

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmd.h,v 1.13 2015/12/06 10:30:41 reyk Exp $	*/
d106 1
@


1.13
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: vmd.h,v 1.12 2015/12/06 02:26:14 reyk Exp $	*/
d49 1
a49 5
	IMSG_VMDOP_DISABLE_VMM_REQUEST = IMSG_PROC_MAX,
	IMSG_VMDOP_DISABLE_VMM_RESPONSE,
	IMSG_VMDOP_ENABLE_VMM_REQUEST,
	IMSG_VMDOP_ENABLE_VMM_RESPONSE,
	IMSG_VMDOP_START_VM_REQUEST,
@


1.12
log
@Print the TTY in the vmctl status output.
@
text
@d1 1
a1 1
/*	$OpenBSD: vmd.h,v 1.11 2015/12/06 01:58:21 reyk Exp $	*/
d68 3
a70 3
	int		 vmr_result;
	uint32_t	 vmr_id;
	char		 vmr_ttyname[VM_TTYNAME_MAX];
d79 9
a87 9
	struct vm_create_params	vm_params;
	uint32_t		vm_vmid;
	int			vm_kernel;
	int			vm_disks[VMM_MAX_DISKS_PER_VM];
	int			vm_ifs[VMM_MAX_NICS_PER_VM];
	char			vm_ttyname[VM_TTYNAME_MAX];
	int			vm_tty;
	uint32_t		vm_peerid;
	TAILQ_ENTRY(vmd_vm)	vm_entry;
@


1.11
log
@When a new vm is created with VMM_IOC_CREATE, the kernel assigns a
unique id to it.  This happens in the vm child process and has to be
communicated to the parent processes to track the vm.  Knowing the vm
id in the parent and vmm processes also allows to remove vm from the
daemons list on terminate requests later.
@
text
@d1 1
a1 1
/*	$OpenBSD: vmd.h,v 1.10 2015/12/03 23:32:32 reyk Exp $	*/
d36 1
a36 1
#define VM_TTYNAME_MAX		32
d71 5
@


1.10
log
@Re-add the "load" and "reload" commands to vmctl: Instead of parsing
the configuration in vmctl directly, it now sends a (re)load request
to vmd.  The reload also resets the existing configuration status -
this doesn't do much difference yet but a future change will compare
if a specified VM is already running.  "load" will allow to add
configuration, while "reload" resets the state before loading.
@
text
@d1 1
a1 1
/*	$OpenBSD: vmd.h,v 1.9 2015/12/03 16:11:32 reyk Exp $	*/
d67 4
a70 3
struct vmop_start_result {
	int	 vmr_result;
	char	 vmr_ttyname[VM_TTYNAME_MAX];
d104 1
@


1.9
log
@Add support for an optional vm.conf(5) file in vmd.  This will replace
vmm.conf(5) in vmmctl.  For a short time, both vmd and vmmctl will
support a configuration file, but vmmctl will be changed to send
"load" requests to vmd instead of loading and parsing the file
directly.
@
text
@d1 1
a1 1
/*	$OpenBSD: vmd.h,v 1.8 2015/12/03 13:27:14 reyk Exp $	*/
d62 3
a64 1
	IMSG_VMDOP_GET_INFO_VM_END_DATA
d101 1
d104 1
@


1.8
log
@prepare config_getvm() for parse.y
@
text
@d1 1
a1 1
/*	$OpenBSD: vmd.h,v 1.7 2015/12/03 08:42:11 reyk Exp $	*/
d32 1
d85 1
a85 1
	int			 vmd_fd;
d94 2
d117 4
@


1.7
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: vmd.h,v 1.6 2015/12/02 23:33:43 reyk Exp $	*/
d110 2
a111 1
int	 config_getvm(struct privsep *, struct imsg *);
@


1.6
log
@send the tty name to vmmctl and print it as a result.
@
text
@d1 1
a1 1
/*	$OpenBSD: vmd.h,v 1.5 2015/12/02 22:19:11 reyk Exp $	*/
d52 4
a55 4
        IMSG_VMDOP_START_VM_REQUEST,
        IMSG_VMDOP_START_VM_DISK,
        IMSG_VMDOP_START_VM_IF,
        IMSG_VMDOP_START_VM_END,
d57 1
a57 1
        IMSG_VMDOP_TERMINATE_VM_REQUEST,
d107 1
a107 1
void	 config_purge(struct vmd *, u_int);
@


1.5
log
@Split the fully privileged parent into two processes "parent" and
"vmm" with reduced privileges:
- the "parent" opens fds (disks, ifs, etc.) but runs as root but pledged as
  "stdio rpath wpath proc tty sendfd".
- the "vmm" process handles the creation and supervision of vm processes,
  and the primary communication with the vmm(4) subsystem.  It runs as _vmd
  in the chroot but does not use pledge, as the vmm ioctls are not allowed
  by any pledge model yet.
With this change, vmd starts to track the configuration state of VMs
in vmd and will allow other things later (like terminating a vm by
name, moving the configuration parser to vmd, ...).  More incremental
changes will follow.
@
text
@d1 1
a1 1
/*	$OpenBSD: vmd.h,v 1.4 2015/12/02 09:14:25 reyk Exp $	*/
d35 1
d64 5
d75 1
a75 1
	char			vm_ttyname[32];
@


1.4
log
@Start tweaking vmd's privsep and daemon model by splitting the main
process into multiple parts and adopting the "proc.c"-style from other
daemons.  This allows to further reduce the privileges, to give better
pledge(2), and to add some upcoming changes.

"please do" mlarkin@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmd.h,v 1.3 2015/11/23 13:04:49 reyk Exp $	*/
d22 4
d28 2
a29 2
#ifndef __VMD_H__
#define __VMD_H__
d34 1
a34 1
#define VM_NAME_MAX		256
a37 1

d52 3
d63 12
a74 1
SLIST_HEAD(vmstate_head, vmstate);
d83 1
d85 2
a86 1
	struct vmstate_head	 vmd_vmstate;
d89 4
d94 13
a106 3
int vmm_dispatch_control(int, struct privsep_proc *, struct imsg *);
int write_page(uint32_t dst, void *buf, uint32_t, int);
int read_page(uint32_t dst, void *buf, uint32_t, int);
d108 1
a108 1
#endif /* __VMD_H__ */
@


1.3
log
@Add support for logging to stderr or syslog, and to run vmd in
foreground with -d.

OK mlarkin@@ jung@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmd.h,v 1.2 2015/11/22 21:51:32 reyk Exp $	*/
d19 4
a22 1
#include <stdarg.h>
d31 3
a42 1

d44 1
a44 2
        IMSG_NONE,
	IMSG_VMDOP_DISABLE_VMM_REQUEST,
d57 15
a73 21

/* log.c */
void	log_init(int, int);
void	log_procinit(const char *);
void	log_verbose(int);
void	log_warn(const char *, ...)
	    __attribute__((__format__ (printf, 1, 2)));
void	log_warnx(const char *, ...)
	    __attribute__((__format__ (printf, 1, 2)));
void	log_info(const char *, ...)
	    __attribute__((__format__ (printf, 1, 2)));
void	log_debug(const char *, ...)
	    __attribute__((__format__ (printf, 1, 2)));
void	logit(int, const char *, ...)
	    __attribute__((__format__ (printf, 2, 3)));
void	vlog(int, const char *, va_list)
	    __attribute__((__format__ (printf, 2, 0)));
__dead void fatal(const char *, ...)
	    __attribute__((__format__ (printf, 1, 2)));
__dead void fatalx(const char *, ...)
	    __attribute__((__format__ (printf, 1, 2)));
@


1.2
log
@Add $ Ids
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d19 2
d32 1
a32 1
#define dprintf(x...)   do { fprintf(stderr, x); } while(0)
d55 21
@


1.1
log
@
vmd(8) - virtual machine daemon.

There is still a lot to be done, and fixed, in these userland components
but I have received enough "it works, commit it" emails that it's time
to finish those things in tree.

discussed with many, tested by many.
@
text
@d1 1
@

