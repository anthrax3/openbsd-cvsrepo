head	1.13;
access;
symbols
	OPENBSD_6_0:1.13.0.4
	OPENBSD_6_0_BASE:1.13
	OPENBSD_5_9:1.13.0.2
	OPENBSD_5_9_BASE:1.13
	OPENBSD_5_8:1.12.0.6
	OPENBSD_5_8_BASE:1.12
	OPENBSD_5_7:1.12.0.2
	OPENBSD_5_7_BASE:1.12
	OPENBSD_5_6:1.11.0.40
	OPENBSD_5_6_BASE:1.11
	OPENBSD_5_5:1.11.0.38
	OPENBSD_5_5_BASE:1.11
	OPENBSD_5_4:1.11.0.34
	OPENBSD_5_4_BASE:1.11
	OPENBSD_5_3:1.11.0.32
	OPENBSD_5_3_BASE:1.11
	OPENBSD_5_2:1.11.0.30
	OPENBSD_5_2_BASE:1.11
	OPENBSD_5_1_BASE:1.11
	OPENBSD_5_1:1.11.0.28
	OPENBSD_5_0:1.11.0.26
	OPENBSD_5_0_BASE:1.11
	OPENBSD_4_9:1.11.0.24
	OPENBSD_4_9_BASE:1.11
	OPENBSD_4_8:1.11.0.22
	OPENBSD_4_8_BASE:1.11
	OPENBSD_4_7:1.11.0.18
	OPENBSD_4_7_BASE:1.11
	OPENBSD_4_6:1.11.0.20
	OPENBSD_4_6_BASE:1.11
	OPENBSD_4_5:1.11.0.16
	OPENBSD_4_5_BASE:1.11
	OPENBSD_4_4:1.11.0.14
	OPENBSD_4_4_BASE:1.11
	OPENBSD_4_3:1.11.0.12
	OPENBSD_4_3_BASE:1.11
	OPENBSD_4_2:1.11.0.10
	OPENBSD_4_2_BASE:1.11
	OPENBSD_4_1:1.11.0.8
	OPENBSD_4_1_BASE:1.11
	OPENBSD_4_0:1.11.0.6
	OPENBSD_4_0_BASE:1.11
	OPENBSD_3_9:1.11.0.4
	OPENBSD_3_9_BASE:1.11
	OPENBSD_3_8:1.11.0.2
	OPENBSD_3_8_BASE:1.11
	OPENBSD_3_7:1.10.0.6
	OPENBSD_3_7_BASE:1.10
	OPENBSD_3_6:1.10.0.4
	OPENBSD_3_6_BASE:1.10
	OPENBSD_3_5:1.10.0.2
	OPENBSD_3_5_BASE:1.10
	OPENBSD_3_4:1.9.0.2
	OPENBSD_3_4_BASE:1.9
	OPENBSD_3_3:1.7.0.2
	OPENBSD_3_3_BASE:1.7
	OPENBSD_3_2:1.6.0.2
	OPENBSD_3_2_BASE:1.6
	OPENBSD_3_1:1.5.0.2
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.3.0.2
	OPENBSD_3_0_BASE:1.3
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_9:1.2.0.20
	OPENBSD_2_8:1.2.0.18
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.16
	OPENBSD_2_7_BASE:1.2
	OPENBSD_2_6:1.2.0.14
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.12
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.10
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.8
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.6
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.13
date	2015.08.21.02.07.32;	author deraadt;	state Exp;
branches;
next	1.12;
commitid	Zx2k82IzYwwZaEz9;

1.12
date	2014.11.03.03.42.12;	author doug;	state Exp;
branches;
next	1.11;
commitid	uiZmdZeIp1Ogo5tH;

1.11
date	2005.06.15.14.30.56;	author robert;	state Exp;
branches;
next	1.10;

1.10
date	2003.11.26.01.17.12;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2003.08.19.22.19.08;	author itojun;	state Exp;
branches;
next	1.8;

1.8
date	2003.04.02.20.43.19;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2003.03.03.15.14.27;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2002.05.30.07.36.44;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2002.02.19.19.39.40;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2002.02.16.21.28.05;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2001.08.01.21.54.45;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.12.14.01.45.20;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.47.45;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.47.45;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.13
log
@since stdlib.h is in scope, don't cast.... you know the drill.
no sneakiness detected by krw
@
text
@%{
/*	$NetBSD: cfparse.y,v 1.4 1995/12/10 10:06:57 mycroft Exp $	*/

/*
 * Configuration file parser for mrouted.
 *
 * Written by Bill Fenner, NRL, 1994
 * Copyright (c) 1994
 * Naval Research Laboratory (NRL/CCS)
 *                    and the
 * Defense Advanced Research Projects Agency (DARPA)
 *
 * All Rights Reserved.
 *
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright notice and
 * this permission notice appear in all copies of the software, derivative
 * works or modified versions, and any portions thereof, and that both notices
 * appear in supporting documentation.
 *
 * NRL AND DARPA ALLOW FREE USE OF THIS SOFTWARE IN ITS "AS IS" CONDITION AND
 * DISCLAIM ANY LIABILITY OF ANY KIND FOR ANY DAMAGES WHATSOEVER RESULTING FROM
 * THE USE OF THIS SOFTWARE.
 */
#include <stdio.h>
#include <string.h>
#include <stdarg.h>
#include "defs.h"
#include <netdb.h>
#include <ifaddrs.h>

/*
 * Local function declarations
 */
static void		fatal(const char *fmt, ...)
    __attribute__((__format__ (printf, 1, 2)))
    __attribute__((__nonnull__ (1)));
static void		warn(const char *fmt, ...)
    __attribute__((__format__ (printf, 1, 2)))
    __attribute__((__nonnull__ (1)));
static void		yyerror(char *s);
static char *		next_word(void);
static int		yylex(void);
static u_int32_t	valid_if(char *s);
static const char *	ifconfaddr(u_int32_t a);
int			yyparse(void);

static FILE *f;

extern int udp_socket;
char *configfilename = _PATH_MROUTED_CONF;

extern int cache_lifetime;
extern int max_prune_lifetime;

static int lineno;

static struct uvif *v;

static int order;

struct addrmask {
	u_int32_t	addr;
	int	mask;
};

struct boundnam {
	char		*name;
	struct addrmask	 bound;
};

#define MAXBOUNDS 20

struct boundnam boundlist[MAXBOUNDS];	/* Max. of 20 named boundaries */
int numbounds = 0;			/* Number of named boundaries */

%}

%union
{
	int num;
	char *ptr;
	struct addrmask addrmask;
	u_int32_t addr;
};

%token CACHE_LIFETIME PRUNING
%token PHYINT TUNNEL NAME
%token DISABLE IGMPV1 SRCRT
%token METRIC THRESHOLD RATE_LIMIT BOUNDARY NETMASK ALTNET
%token <num> BOOLEAN
%token <num> NUMBER
%token <ptr> STRING
%token <addrmask> ADDRMASK
%token <addr> ADDR

%type <addr> interface addrname
%type <addrmask> bound boundary addrmask

%start conf

%%

conf	: stmts
	;

stmts	: /* Empty */
	| stmts stmt
	;

stmt	: error
	| PHYINT interface		{

			vifi_t vifi;

			if (order)
			    fatal("phyints must appear before tunnels");

			for (vifi = 0, v = uvifs;
			     vifi < numvifs;
			     ++vifi, ++v)
			    if (!(v->uv_flags & VIFF_TUNNEL) &&
				$2 == v->uv_lcl_addr)
				break;

			if (vifi == numvifs)
			    fatal("%s is not a configured interface",
				inet_fmt($2,s1));

					}
		ifmods
	| TUNNEL interface addrname	{
			const char *ifname;
			struct ifreq ffr;
			vifi_t vifi;

			order++;

			ifname = ifconfaddr($2);
			if (ifname == 0)
			    fatal("Tunnel local address %s is not mine",
				inet_fmt($2, s1));

			strlcpy(ffr.ifr_name, ifname, sizeof(ffr.ifr_name));
			if (ioctl(udp_socket, SIOCGIFFLAGS, (char *)&ffr)<0)
			    fatal("ioctl SIOCGIFFLAGS on %s",ffr.ifr_name);
			if (ffr.ifr_flags & IFF_LOOPBACK)
			    fatal("Tunnel local address %s is a loopback interface",
				inet_fmt($2, s1));

			if (ifconfaddr($3) != 0)
			    fatal("Tunnel remote address %s is one of mine",
				inet_fmt($3, s1));

			for (vifi = 0, v = uvifs;
			     vifi < numvifs;
			     ++vifi, ++v)
			    if (v->uv_flags & VIFF_TUNNEL) {
				if ($3 == v->uv_rmt_addr)
				    fatal("Duplicate tunnel to %s",
					inet_fmt($3, s1));
			    } else if (!(v->uv_flags & VIFF_DISABLED)) {
				if (($3 & v->uv_subnetmask) == v->uv_subnet)
				    fatal("Unnecessary tunnel to %s",
					inet_fmt($3,s1));
			    }

			if (numvifs == MAXVIFS)
			    fatal("too many vifs");

			v = &uvifs[numvifs];
			v->uv_flags	= VIFF_TUNNEL;
			v->uv_metric	= DEFAULT_METRIC;
			v->uv_rate_limit= DEFAULT_TUN_RATE_LIMIT;
			v->uv_threshold	= DEFAULT_THRESHOLD;
			v->uv_lcl_addr	= $2;
			v->uv_rmt_addr	= $3;
			v->uv_subnet	= 0;
			v->uv_subnetmask= 0;
			v->uv_subnetbcast= 0;
			strncpy(v->uv_name, ffr.ifr_name, IFNAMSIZ);
			v->uv_groups	= NULL;
			v->uv_neighbors	= NULL;
			v->uv_acl	= NULL;
			v->uv_addrs	= NULL;

			if (!(ffr.ifr_flags & IFF_UP)) {
			    v->uv_flags |= VIFF_DOWN;
			    vifs_down = TRUE;
			}
					}
		tunnelmods
					{
			logit(LOG_INFO, 0,
			    "installing tunnel from %s to %s as vif #%u - rate=%d",
			    inet_fmt($2, s1), inet_fmt($3, s2),
			    numvifs, v->uv_rate_limit);

			++numvifs;
					}
	| PRUNING BOOLEAN	    { pruning = $2; }
	| CACHE_LIFETIME NUMBER     { cache_lifetime = $2;
				      max_prune_lifetime = cache_lifetime * 2;
				    }
	| NAME STRING boundary	    { if (numbounds >= MAXBOUNDS) {
					fatal("Too many named boundaries (max %d)", MAXBOUNDS);
				      }

				      boundlist[numbounds].name = strdup($2);
				      boundlist[numbounds++].bound = $3;
				    }
	;

tunnelmods	: /* empty */
	| tunnelmods tunnelmod
	;

tunnelmod	: mod
	| SRCRT			{ fatal("Source-route tunnels not supported"); }
	;

ifmods	: /* empty */
	| ifmods ifmod
	;

ifmod	: mod
	| DISABLE		{ v->uv_flags |= VIFF_DISABLED; }
	| IGMPV1		{ v->uv_flags |= VIFF_IGMPV1; }
	| NETMASK addrname	{
				  u_int32_t subnet, mask;

				  mask = $2;
				  subnet = v->uv_lcl_addr & mask;
				  if (!inet_valid_subnet(subnet, mask))
					fatal("Invalid netmask");
				  v->uv_subnet = subnet;
				  v->uv_subnetmask = mask;
				  v->uv_subnetbcast = subnet | ~mask;
				}
	| NETMASK		{

		    warn("Expected address after netmask keyword, ignored");

				}
	| ALTNET addrmask	{

		    struct phaddr *ph;

		    ph = malloc(sizeof(struct phaddr));
		    if (ph == NULL)
			fatal("out of memory");
		    if ($2.mask) {
			VAL_TO_MASK(ph->pa_subnetmask, $2.mask);
		    } else
			ph->pa_subnetmask = v->uv_subnetmask;
		    ph->pa_subnet = $2.addr & ph->pa_subnetmask;
		    ph->pa_subnetbcast = ph->pa_subnet | ~ph->pa_subnetmask;
		    if ($2.addr & ~ph->pa_subnetmask)
			warn("Extra subnet %s/%d has host bits set",
				inet_fmt($2.addr,s1), $2.mask);
		    ph->pa_next = v->uv_addrs;
		    v->uv_addrs = ph;

				}
	| ALTNET		{

		    warn("Expected address after altnet keyword, ignored");

				}
	;

mod	: THRESHOLD NUMBER	{ if ($2 < 1 || $2 > 255)
				    fatal("Invalid threshold %d",$2);
				  v->uv_threshold = $2;
				}
	| THRESHOLD		{

		    warn("Expected number after threshold keyword, ignored");

				}
	| METRIC NUMBER		{ if ($2 < 1 || $2 > UNREACHABLE)
				    fatal("Invalid metric %d",$2);
				  v->uv_metric = $2;
				}
	| METRIC		{

		    warn("Expected number after metric keyword, ignored");

				}
	| RATE_LIMIT NUMBER	{ if ($2 > MAX_RATE_LIMIT)
				    fatal("Invalid rate_limit %d",$2);
				  v->uv_rate_limit = $2;
				}
	| RATE_LIMIT		{

		    warn("Expected number after rate_limit keyword, ignored");

				}
	| BOUNDARY bound	{

		    struct vif_acl *v_acl;

		    v_acl = malloc(sizeof(struct vif_acl));
		    if (v_acl == NULL)
			fatal("out of memory");
		    VAL_TO_MASK(v_acl->acl_mask, $2.mask);
		    v_acl->acl_addr = $2.addr & v_acl->acl_mask;
		    if ($2.addr & ~v_acl->acl_mask)
			warn("Boundary spec %s/%d has host bits set",
				inet_fmt($2.addr,s1),$2.mask);
		    v_acl->acl_next = v->uv_acl;
		    v->uv_acl = v_acl;

				}
	| BOUNDARY		{

		warn("Expected boundary spec after boundary keyword, ignored");

				}
	;

interface	: ADDR		{ $$ = $1; }
	| STRING		{
				  $$ = valid_if($1);
				  if ($$ == 0)
					fatal("Invalid interface name %s",$1);
				}
	;

addrname	: ADDR		{ $$ = $1; }
	| STRING		{ struct hostent *hp;

				  if ((hp = gethostbyname($1)) == NULL)
				    fatal("No such host %s", $1);

				  if (hp->h_addr_list[1])
				    fatal("Hostname %s does not %s",
					$1, "map to a unique address");

				  bcopy(hp->h_addr_list[0], &$$,
					    hp->h_length);
				}

bound	: boundary		{ $$ = $1; }
	| STRING		{ int i;

				  for (i=0; i < numbounds; i++) {
				    if (!strcmp(boundlist[i].name, $1)) {
					$$ = boundlist[i].bound;
					break;
				    }
				  }
				  if (i == numbounds) {
				    fatal("Invalid boundary name %s",$1);
				  }
				}
	;

boundary	: ADDRMASK	{

			if ((ntohl($1.addr) & 0xff000000) != 0xef000000) {
			    fatal("Boundaries must be 239.x.x.x, not %s/%d",
				inet_fmt($1.addr, s1), $1.mask);
			}
			$$ = $1;

				}
	;

addrmask	: ADDRMASK	{ $$ = $1; }
	| ADDR			{ $$.addr = $1; $$.mask = 0; }
	;
%%
static void
fatal(const char *fmt, ...)
{
	va_list ap;
	char buf[200];

	va_start(ap, fmt);
	vsnprintf(buf, sizeof buf, fmt, ap);
	va_end(ap);

	logit(LOG_ERR,0,"%s: %s near line %d", configfilename, buf, lineno);
}

static void
warn(const char *fmt, ...)
{
	va_list ap;
	char buf[200];

	va_start(ap, fmt);
	vsnprintf(buf, sizeof buf, fmt, ap);
	va_end(ap);

	logit(LOG_WARNING,0,"%s: %s near line %d", configfilename, buf, lineno);
}

static void
yyerror(s)
char *s;
{
	logit(LOG_ERR, 0, "%s: %s near line %d", configfilename, s, lineno);
}

static char *
next_word()
{
	static char buf[1024];
	static char *p=NULL;
	extern FILE *f;
	char *q;

	while (1) {
	    if (!p || !*p) {
		lineno++;
		if (fgets(buf, sizeof(buf), f) == NULL)
		    return NULL;
		p = buf;
	    }
	    while (*p && (*p == ' ' || *p == '\t'))	/* skip whitespace */
		p++;
	    if (*p == '#') {
		p = NULL;		/* skip comments */
		continue;
	    }
	    q = p;
	    while (*p && *p != ' ' && *p != '\t' && *p != '\n')
		p++;		/* find next whitespace */
	    *p++ = '\0';	/* null-terminate string */

	    if (!*q) {
		p = NULL;
		continue;	/* if 0-length string, read another line */
	    }

	    return q;
	}
}

static int
yylex()
{
	int n;
	u_int32_t addr;
	char *q;

	if ((q = next_word()) == NULL) {
		return 0;
	}

	if (!strcmp(q,"cache_lifetime"))
		return CACHE_LIFETIME;
	if (!strcmp(q,"pruning"))
		return PRUNING;
	if (!strcmp(q,"phyint"))
		return PHYINT;
	if (!strcmp(q,"tunnel"))
		return TUNNEL;
	if (!strcmp(q,"disable"))
		return DISABLE;
	if (!strcmp(q,"metric"))
		return METRIC;
	if (!strcmp(q,"threshold"))
		return THRESHOLD;
	if (!strcmp(q,"rate_limit"))
		return RATE_LIMIT;
	if (!strcmp(q,"srcrt") || !strcmp(q,"sourceroute"))
		return SRCRT;
	if (!strcmp(q,"boundary"))
		return BOUNDARY;
	if (!strcmp(q,"netmask"))
		return NETMASK;
	if (!strcmp(q,"igmpv1"))
		return IGMPV1;
	if (!strcmp(q,"altnet"))
		return ALTNET;
	if (!strcmp(q,"name"))
		return NAME;
	if (!strcmp(q,"on") || !strcmp(q,"yes")) {
		yylval.num = 1;
		return BOOLEAN;
	}
	if (!strcmp(q,"off") || !strcmp(q,"no")) {
		yylval.num = 0;
		return BOOLEAN;
	}
	if (sscanf(q,"%[.0-9]/%d%c",s1,&n,s2) == 2) {
		if ((addr = inet_parse(s1)) != 0xffffffff) {
			yylval.addrmask.mask = n;
			yylval.addrmask.addr = addr;
			return ADDRMASK;
		}
		/* fall through to returning STRING */
	}
	if (sscanf(q,"%[.0-9]%c",s1,s2) == 1) {
		if ((addr = inet_parse(s1)) != 0xffffffff &&
		    inet_valid_host(addr)) {
			yylval.addr = addr;
			return ADDR;
		}
	}
	if (sscanf(q,"0x%8x%c",&n,s1) == 1) {
		yylval.addr = n;
		return ADDR;
	}
	if (sscanf(q,"%d%c",&n,s1) == 1) {
		yylval.num = n;
		return NUMBER;
	}
	yylval.ptr = q;
	return STRING;
}

void
config_vifs_from_file()
{
	extern FILE *f;

	order = 0;
	numbounds = 0;
	lineno = 0;

	if ((f = fopen(configfilename, "r")) == NULL) {
	    if (errno != ENOENT)
		logit(LOG_ERR, errno, "can't open %s", configfilename);
	    return;
	}

	yyparse();

	fclose(f);
}

static u_int32_t
valid_if(s)
char *s;
{
	register vifi_t vifi;
	register struct uvif *v;

	for (vifi=0, v=uvifs; vifi<numvifs; vifi++, v++)
	    if (!strcmp(v->uv_name, s))
		return v->uv_lcl_addr;

	return 0;
}

static const char *
ifconfaddr(a)
    u_int32_t a;
{
    static char ifname[IFNAMSIZ];
    struct ifaddrs *ifap, *ifa;

    if (getifaddrs(&ifap) != 0)
	return (NULL);

    for (ifa = ifap; ifa; ifa = ifa->ifa_next) {
	    if (ifa->ifa_addr->sa_family == AF_INET &&
		((struct sockaddr_in *)ifa->ifa_addr)->sin_addr.s_addr == a) {
		strlcpy(ifname, ifa->ifa_name, sizeof(ifname));
		freeifaddrs(ifap);
		return (ifname);
	    }
    }
    freeifaddrs(ifap);
    return (0);
}
@


1.12
log
@Add gcc format attributes to more warn/error functions in parse.y files.

Fix a few missing or incorrect format characters.
ok claudio@@
@
text
@d249 1
a249 1
		    ph = (struct phaddr *)malloc(sizeof(struct phaddr));
d303 1
a303 1
		    v_acl = (struct vif_acl *)malloc(sizeof(struct vif_acl));
@


1.11
log
@remove SNMP code from mrouted(8) because it is broken and it is
higly unlike that anyone will use this.

ok otto@@ millert@@ henning@@
@
text
@d35 6
a40 2
static void		fatal(char *fmt, ...);
static void		warn(char *fmt, ...);
d375 1
a375 1
fatal(char *fmt, ...)
d388 1
a388 1
warn(char *fmt, ...)
@


1.10
log
@Replace log() with logit() since ISO C reserves log() for the math
library and gcc 3.x will complain.  Replacement name taken from NetBSD.
espie@@ OK.
@
text
@a86 1
%token SYSNAM SYSCONTACT SYSVERSION SYSLOCATION
a207 20
	| SYSNAM STRING    {
#ifdef SNMP
			    set_sysName($2);
#endif /* SNMP */
			    }
	| SYSCONTACT STRING {
#ifdef SNMP
			    set_sysContact($2);
#endif /* SNMP */
			    }
        | SYSVERSION STRING {
#ifdef SNMP
			    set_sysVersion($2);
#endif /* SNMP */
			    }
	| SYSLOCATION STRING {
#ifdef SNMP
			    set_sysLocation($2);
#endif /* SNMP */
			    }
a424 9
#ifdef SNMP
       if (*p == '"') {
          p++;
	       while (*p && *p != '"' && *p != '\n')
		      p++;		/* find next whitespace */
          if (*p == '"')
             p++;
       } else
#endif
a507 16
#ifdef SNMP
	if (!strcmp(q,"sysName"))
		return SYSNAM;
	if (!strcmp(q,"sysContact"))
		return SYSCONTACT;
	if (!strcmp(q,"sysVersion"))
		return SYSVERSION;
	if (!strcmp(q,"sysLocation"))
		return SYSLOCATION;
   if (*q=='"') {
      if (q[ strlen(q)-1 ]=='"')
         q[ strlen(q)-1 ]='\0'; /* trash trailing quote */
      yylval.ptr = q+1;
      return STRING;
   }
#endif
@


1.9
log
@rewrite SIOCGIFCONF into getifaddrs.  deraadt ok
@
text
@d191 1
a191 1
			log(LOG_INFO, 0,
d401 1
a401 1
	log(LOG_ERR,0,"%s: %s near line %d", configfilename, buf, lineno);
d414 1
a414 1
	log(LOG_WARNING,0,"%s: %s near line %d", configfilename, buf, lineno);
d421 1
a421 1
	log(LOG_ERR, 0, "%s: %s near line %d", configfilename, s, lineno);
d569 1
a569 1
		log(LOG_ERR, errno, "can't open %s", configfilename);
@


1.8
log
@sprintf killing; millert ok
@
text
@d30 1
d41 1
a41 1
static struct ifreq *	ifconfaddr(struct ifconf *ifcp, u_int32_t a);
a52 2
static struct ifreq ifbuf[32];
static struct ifconf ifc;
d130 1
a130 2

			struct ifreq *ifr;
d136 2
a137 2
			ifr = ifconfaddr(&ifc, $2);
			if (ifr == 0)
d141 1
a141 1
			strncpy(ffr.ifr_name, ifr->ifr_name, IFNAMSIZ);
d148 1
a148 1
			if (ifconfaddr(&ifc, $3) != 0)
a572 5
	ifc.ifc_buf = (char *)ifbuf;
	ifc.ifc_len = sizeof(ifbuf);
	if (ioctl(udp_socket, SIOCGIFCONF, (char *)&ifc) < 0)
	    log(LOG_ERR, errno, "ioctl SIOCGIFCONF");

d592 2
a593 3
static struct ifreq *
ifconfaddr(ifcp, a)
    struct ifconf *ifcp;
d596 13
a608 17
    int n;
    struct ifreq *ifrp = (struct ifreq *)ifcp->ifc_buf;
    struct ifreq *ifend = (struct ifreq *)((char *)ifrp + ifcp->ifc_len);

    while (ifrp < ifend) {
	    if (ifrp->ifr_addr.sa_family == AF_INET &&
		((struct sockaddr_in *)&ifrp->ifr_addr)->sin_addr.s_addr == a)
		    return (ifrp);
#if (defined(BSD) && (BSD >= 199006))
		n = ifrp->ifr_addr.sa_len + sizeof(ifrp->ifr_name);
		if (n < sizeof(*ifrp))
			++ifrp;
		else
			ifrp = (struct ifreq *)((char *)ifrp + n);
#else
		++ifrp;
#endif
d610 1
@


1.7
log
@spaces
@
text
@d208 1
a208 2
				      boundlist[numbounds].name = malloc(strlen($2) + 1);
				      strcpy(boundlist[numbounds].name, $2);
@


1.6
log
@snprintf in .y files
@
text
@d110 1
a110 1
	| PHYINT interface 		{
d123 1
a123 1
			
d528 1
a528 1
		    inet_valid_host(addr)) { 
@


1.5
log
@We live in an ANSI C world.  Remove lots of gratuitous #ifdef __STDC__ cruft.
@
text
@d401 1
a401 1
	vsprintf(buf, fmt, ap);
d414 1
a414 1
	vsprintf(buf, fmt, ap);
@


1.4
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d26 1
a26 1
#ifdef __STDC__
a27 4
#else
#include <string.h>
#include <varargs.h>
#endif
a393 1
#ifdef __STDC__
a400 12
#else
/*VARARGS1*/
static void
fatal(fmt, va_alist)
char *fmt;
va_dcl
{
	va_list ap;
	char buf[200];

	va_start(ap);
#endif
a406 1
#ifdef __STDC__
a413 12
#else
/*VARARGS1*/
static void
warn(fmt, va_alist)
char *fmt;
va_dcl
{
	va_list ap;
	char buf[200];

	va_start(ap);
#endif
@


1.3
log
@another bad licence goes foom!
@
text
@d38 8
a45 8
static void		fatal __P((char *fmt, ...));
static void		warn __P((char *fmt, ...));
static void		yyerror __P((char *s));
static char *		next_word __P((void));
static int		yylex __P((void));
static u_int32_t	valid_if __P((char *s));
static struct ifreq *	ifconfaddr __P((struct ifconf *ifcp, u_int32_t a));
int			yyparse __P((void));
@


1.2
log
@from netbsd; update to mrouted 3.8
@
text
@d8 16
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
/*	$NetBSD: cfparse.y,v 1.3 1995/10/09 03:51:35 thorpej Exp $	*/
d10 3
d15 1
d17 13
d74 3
a76 1
%token DISABLE METRIC THRESHOLD RATE_LIMIT SRCRT BOUNDARY NETMASK ALTNET
d83 1
a83 1
%type <addr> interface
a115 1
			/*log(LOG_INFO, 0, "phyint: %x\n", v);*/
d118 1
a118 1
	| TUNNEL interface ADDR		{
a177 1
			/*log(LOG_INFO, 0, "tunnel: %x\n", v);*/
d200 20
d223 1
a223 1
	| tunnelmods /*{ log(LOG_INFO, 0, "tunnelmod: %x", v); }*/ tunnelmod
d231 1
a231 1
	| ifmods /*{ log(LOG_INFO, 0, "ifmod: %x", v); }*/ ifmod
d236 17
a252 1
	| NETMASK ADDR		{ v->uv_subnetmask = $2; }
d261 1
a261 1
			VAL_TO_MASK(ph->pa_mask, $2.mask);
d263 5
a267 4
			ph->pa_mask = v->uv_subnetmask;
		    ph->pa_addr = $2.addr & ph->pa_mask;
		    if ($2.addr & ~ph->pa_mask)
			warn("Extra addr %s/%d has host bits set",
d273 5
d286 1
a286 1
		    warn("Expected number after threshold keyword");
d295 1
a295 1
		    warn("Expected number after metric keyword");
d304 1
a304 1
		    warn("Expected number after rate_limit keyword");
d325 1
a325 1
		    warn("Expected boundary spec after boundary keyword");
d338 14
d382 9
d392 2
a393 1
static void fatal(fmt, va_alist)
d401 1
d408 9
d418 2
a419 1
static void warn(fmt, va_alist)
d427 1
d434 2
a435 1
void yyerror(s)
d441 2
a442 1
char *next_word()
d463 9
d485 2
a486 1
int yylex()
d518 4
a523 2
	if (!strcmp(q,"altnet"))
		return ALTNET;
d555 16
d575 2
a576 1
void config_vifs_from_file()
d597 1
a597 1
	close(f);
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
