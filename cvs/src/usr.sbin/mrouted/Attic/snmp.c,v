head	1.9;
access;
symbols
	OPENBSD_3_7:1.8.0.4
	OPENBSD_3_7_BASE:1.8
	OPENBSD_3_6:1.8.0.2
	OPENBSD_3_6_BASE:1.8
	OPENBSD_3_5:1.7.0.6
	OPENBSD_3_5_BASE:1.7
	OPENBSD_3_4:1.7.0.4
	OPENBSD_3_4_BASE:1.7
	OPENBSD_3_3:1.7.0.2
	OPENBSD_3_3_BASE:1.7
	OPENBSD_3_2:1.4.0.2
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.2.0.24
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.22
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_9:1.2.0.20
	OPENBSD_2_8:1.2.0.18
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.16
	OPENBSD_2_7_BASE:1.2
	OPENBSD_2_6:1.2.0.14
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.12
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.10
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.8
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.6
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.9
date	2005.06.15.14.30.56;	author robert;	state dead;
branches;
next	1.8;

1.8
date	2004.08.01.18.32.19;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2003.03.12.22.55.01;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2003.03.03.15.14.28;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2003.03.01.00.32.57;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2002.08.01.03.45.53;	author itojun;	state Exp;
branches;
next	1.3;

1.3
date	2002.06.02.19.06.39;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.12.14.01.45.34;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.47.47;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.47.47;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.9
log
@remove SNMP code from mrouted(8) because it is broken and it is
higly unlike that anyone will use this.

ok otto@@ millert@@ henning@@
@
text
@/*	$NetBSD: snmp.c,v 1.3 1995/12/10 10:07:16 mycroft Exp $	*/

/*
 * Copyright (c) 1992, 2001 Xerox Corporation.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *
 * Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the following disclaimer.
 *
 * Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 *
 * Neither name of the Xerox, PARC, nor the names of its contributors may be used
 * to endorse or promote products derived from this software
 * without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ``AS IS''
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE XEROX CORPORATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include "defs.h"
#include <netinet/in_var.h>
#include "snmp.h"
#include "snmplib/asn1.h"
#include "snmplib/party.h"
#include "snmplib/snmp_impl.h"
#define MROUTED
#include "snmpd/snmp_vars.h"

    in_port_t dest_port = 0;
    int sdlen = 0;

struct addrCache {
    u_long addr;
    int status;
#define UNUSED 0
#define USED   1
#define OLD 2
};

static struct addrCache addrCache[10];

/*
 * Initialize the SNMP part of mrouted
 */
int /* returns: 0 on success, true on error */
snmp_init(in_port_t dest_port)
{
   u_long myaddr;
   int ret;
   struct partyEntry *pp;
   struct sockaddr_in  me;
   int index, sd, portlist[32];

   init_snmp();
   /* init_mib(); why was this here? */
    if (read_party_database("/etc/party.conf") > 0){
   fprintf(stderr, "Couldn't read party database from /etc/party.conf\n");
   exit(0);
    }
    if (read_context_database("/etc/context.conf") > 0){
   fprintf(stderr, "Couldn't read context database from /etc/context.conf\n");
   exit(0);
    }
    if (read_acl_database("/etc/acl.conf") > 0){
   fprintf(stderr, "Couldn't read acl database from /etc/acl.conf\n");
   exit(0);
    }
    if (read_view_database("/etc/view.conf") > 0){
   fprintf(stderr, "Couldn't read view database from /etc/view.conf\n");
   exit(0);
    }

    myaddr = get_myaddr();
    if (ret = agent_party_init(myaddr, ".1.3.6.1")){
   if (ret == 1){
       fprintf(stderr, "Conflict found with initial noAuth/noPriv parties... continuing\n");
   } else if (ret == -1){
       fprintf(stderr, "Error installing initial noAuth/noPriv parties, exiting\n");
       exit(1);
   } else {
       fprintf(stderr, "Unknown error, exiting\n");
       exit(2);
   }
    }

    printf("Opening port(s): ");
    fflush(stdout);
    party_scanInit();
    for(pp = party_scanNext(); pp; pp = party_scanNext()){
   if ((pp->partyTDomain != DOMAINSNMPUDP)
       || bcmp((char *)&myaddr, pp->partyTAddress, 4))
       continue;  /* don't listen for non-local parties */

   dest_port = 0;
   bcopy(pp->partyTAddress + 4, &dest_port, 2);
   for(index = 0; index < sdlen; index++)
       if (dest_port == portlist[index])
      break;
   if (index < sdlen)  /* found a hit before the end of the list */
       continue;
   printf("%u ", dest_port);
   fflush(stdout);
   /* Set up connections */
   sd = socket(AF_INET, SOCK_DGRAM, 0);
   if (sd < 0){
       perror("socket");
       return 1;
   }
   memset(&me, 0, sizeof me);
   me.sin_family = AF_INET;
   me.sin_addr.s_addr = INADDR_ANY;
   /* already in network byte order (I think) */
   me.sin_port = dest_port;
   if (bind(sd, (struct sockaddr *)&me, sizeof(me)) != 0){
       perror("bind");
       return 2;
   }
   register_input_handler(sd, snmp_read_packet);
   portlist[sdlen] = dest_port;
   if (++sdlen == 32){
       printf("No more sockets... ignoring rest of file\n");
       break;
   }
    }
    printf("\n");
    bzero((char *)addrCache, sizeof(addrCache));
}

/*
 * Place an IP address into an OID starting at element n
 */
void
put_address(oid *name, u_long addr, int n)
{
   int i;

   for (i=n+3; i>=n+0; i--) {
      name[i] = addr & 0xFF;
      addr >>= 8;
   }
}

/* Get an IP address from an OID starting at element n */
int
get_address(oid *name, int length, u_long *addr, int n)
{
   int i;
   int ok = 1;

   (*addr) = 0;

   if (length < n+4)
      return 0;

   for (i=n; i<n+4; i++) {
      (*addr) <<= 8;
      if (i >= length)
          ok = 0;
      else
         (*addr) |= name[i];
   }
   return ok;
}

/*
 * Implements scalar objects from DVMRP and Multicast MIBs
 * vp          : IN - pointer to variable entry that points here
 * name        : IN/OUT - input name requested, output name found
 * length      : IN/OUT - length of input and output oid's
 * exact       : IN - TRUE if an exact match was requested.
 * var_len     : OUT - length of variable or 0 if function returned.
 * write_method:  OUT - pointer to function to set variable, otherwise 0
 */
u_char *
o_scalar(register struct variable *vp, register oid *name, register int *length,
    int exact, int *var_len, int (**write_method)() )
{
    int result;

    *write_method = 0;
    result = compare(name, *length, vp->name, (int)vp->namelen);
    if ((exact && (result != 0)) || (!exact && (result >= 0)))
   return NULL;

	bcopy((char *)vp->name, (char *)name,
     (int)vp->namelen * sizeof(oid));
	*length = vp->namelen;
	*var_len = sizeof(long);

    switch (vp->magic) {

    case ipMRouteEnable:
       long_return = 1;
       return (u_char *) &long_return;

    case dvmrpVersion: {
       static char buff[15];

       snprintf(buff, sizeof buff, "mrouted%d.%d",
	    PROTOCOL_VERSION, MROUTED_VERSION);
       *var_len = strlen(buff);
       return (u_char *)buff;
    }

    case dvmrpGenerationId:
       long_return = dvmrp_genid;
       return (u_char *) &long_return;

    default:
       ERROR("");
    }
    return NULL;
}

/*
 * Find if a specific scoped boundary exists on a Vif
 */
struct vif_acl *
find_boundary(vifi_t vifi, u_long addr, u_long mask)
{
   struct vif_acl *n;

   for (n = uvifs[vifi].uv_acl; n != NULL; n = n->acl_next) {
      if (addr == n->acl_addr && mask==n->acl_mask)
         return n;
   }
   return NULL;
}

/*
 * Find the lowest boundary >= (V,A,M) spec
 */
struct vif_acl *
next_boundary(vifi_t *vifi, u_long addr, u_long mask)
{
   struct vif_acl *bestn, *n;
   int  i;

   for (i = *vifi; i < numvifs; i++) {
      bestn = NULL;
      for (n = uvifs[i].uv_acl; n; n=n->acl_next) {
         if ((i > *vifi || n->acl_addr > addr
           || (n->acl_addr == addr && n->acl_mask >= mask))
          && (!bestn || n->acl_addr < bestn->acl_addr
           || (n->acl_addr==bestn->acl_addr && n->acl_mask<bestn->acl_mask)))
            bestn = n;
      }
      if (bestn) {
         *vifi = i;
         return bestn;
      }
   }
   return NULL;
}

/*
 * Implements the Boundary Table portion of the DVMRP MIB
 * vp          : IN - pointer to variable entry that points here
 * name        : IN/OUT - input name requested, output name found
 * length      : IN/OUT - length of input and output oid's
 * exact       : IN - TRUE if an exact match was requested.
 * var_len     : OUT - length of variable or 0 if function returned.
 * write_method: OUT - pointer to function to set variable, otherwise 0
 */
u_char *
o_dvmrpBoundaryTable(register struct variable *vp, register oid *name,
    register int *length, int exact, int *var_len, int (**write_method)())
{
    vifi_t     vifi;
    u_long	   addr, mask;
    struct vif_acl *bound;
    oid        newname[MAX_NAME_LEN];
    int        len;

    /* Copy name OID to new OID */
    bcopy((char *)vp->name, (char *)newname, (int)vp->namelen * sizeof(oid));

    if (exact) {
	    if (*length != vp->namelen + 9)
		return NULL;

      if ((vifi = name[vp->namelen]) >= numvifs)
      return NULL;

      if (!get_address(name, *length, &addr, vp->namelen+1)
       || !get_address(name, *length, &mask, vp->namelen+5))
		return NULL;

      if (!(bound = find_boundary(vifi, addr, mask)))
		return NULL;

       bcopy((char *)name, (char *)newname, ((int)*length) * sizeof(oid));
	 } else {
       len = *length;
       if (compare(name, *length, vp->name, vp->namelen) < 0)
          len = vp->namelen;

	    if (len < vp->namelen + 9) { /* get first entry */

	         if (len == vp->namelen) {
	            vifi = addr = mask = 0;
	         } else {
	            vifi = name[vp->namelen];
	            get_address(name, len, &addr, vp->namelen+1);
	            get_address(name, len, &mask, vp->namelen+5);
	         }

	           bound = next_boundary(&vifi,addr,mask);
	           if (!bound)
	              return NULL;

		   newname[vp->namelen] = vifi;
	           put_address(newname, bound->acl_addr, vp->namelen+1);
	           put_address(newname, bound->acl_mask, vp->namelen+5);
	    } else {  /* get next entry given previous */
		   vifi = name[vp->namelen];
		   get_address(name, *length, &addr, vp->namelen+1);
		   get_address(name, *length, &mask, vp->namelen+5);

		   if (!(bound = next_boundary(&vifi,addr,mask+1)))
	             return NULL;

		   newname[vp->namelen] = vifi;
		   put_address(newname, bound->acl_addr, vp->namelen+1);
		   put_address(newname, bound->acl_mask, vp->namelen+5);
	    }
    }

    /* Save new OID */
    *length = vp->namelen + 9;
    bcopy((char *)newname, (char *)name, ((int)*length) * sizeof(oid));
    *write_method = 0;
    *var_len = sizeof(long);

    switch (vp->magic) {

   case dvmrpBoundaryVifIndex:
       long_return = vifi;
       return (u_char *) &long_return;

    default:
       ERROR("");
    }
    return NULL;
}

/*
 * Find the lowest neighbor >= (V,A) spec
 */
struct listaddr *
next_neighbor(vifi_t *vifi, u_long addr)
{
   struct listaddr *bestn, *n;
   int  i;

   for (i = *vifi; i < numvifs; i++) {
      bestn = NULL;
      for (n = uvifs[i].uv_neighbors; n; n=n->al_next) {
         if ((i > *vifi || n->al_addr >= addr)
          && (!bestn || n->al_addr < bestn->al_addr))
            bestn = n;
      }
      if (bestn) {
         *vifi = i;
         return bestn;
      }
   }
   return NULL;
}

/*
 * Find a neighbor, if it exists off a given Vif
 */
struct listaddr *
find_neighbor(vifi_t vifi, u_long addr)
{
   struct listaddr *n;

   for (n = uvifs[vifi].uv_neighbors; n != NULL; n = n->al_next) {
      if (addr == n->al_addr)
         return n;
   }
   return NULL;
}

/*
 * vp          : IN - pointer to variable entry that points here
 * name        : IN/OUT - input name requested, output name found
 * length      : IN/OUT - length of input and output oid's
 * exact       : IN - TRUE if an exact match was requested.
 * var_len     : OUT - length of variable or 0 if function returned.
 * write_method: OUT - pointer to function to set variable, otherwise 0
 */
u_char *
o_dvmrpNeighborTable(register struct variable *vp, register oid *name,
    register int *length, int exact, int *var_len, int (**write_method)())
{
    vifi_t     vifi;
    u_long     addr, mask;
    struct listaddr *neighbor;
    oid        newname[MAX_NAME_LEN];
    int        len;

    /* Copy name OID to new OID */
    bcopy((char *)vp->name, (char *)newname, (int)vp->namelen * sizeof(oid));

    if (exact) {
	    if (*length != vp->namelen + 5)
		return NULL;

      if ((vifi = name[vp->namelen]) >= numvifs)
      return NULL;

      if (!get_address(name, *length, &addr, vp->namelen+1))
		return NULL;

      if (!(neighbor = find_neighbor(vifi, addr)))
		return NULL;

       bcopy((char *)name, (char *)newname, ((int)*length) * sizeof(oid));
	 } else {
       len = *length;
       if (compare(name, *length, vp->name, vp->namelen) < 0)
          len = vp->namelen;

	    if (len < vp->namelen + 5) { /* get first entry */

         if (len == vp->namelen) {
            vifi = addr = 0;
         } else {
            vifi = name[vp->namelen];
            get_address(name, len, &addr, vp->namelen+1);
         }

         neighbor = next_neighbor(&vifi,addr);
         if (!neighbor)
            return NULL;

	    newname[vp->namelen] = vifi;
            put_address(newname, neighbor->al_addr, vp->namelen+1);
	    } else {  /* get next entry given previous */
		   vifi = name[vp->namelen];
         get_address(name, *length, &addr, vp->namelen+1);

         if (!(neighbor = next_neighbor(&vifi,addr+1)))
            return NULL;

		   newname[vp->namelen] = vifi;
         put_address(newname, neighbor->al_addr, vp->namelen+1);
	    }
    }

    /* Save new OID */
    *length = vp->namelen + 5;
    bcopy((char *)newname, (char *)name, ((int)*length) * sizeof(oid));
    *write_method = 0;
    *var_len = sizeof(long);

    switch (vp->magic) {

   case dvmrpNeighborUpTime: {
       time_t currtime;
       time(&currtime);
       long_return = (currtime - neighbor->al_ctime)*100;
       return (u_char *) &long_return;
   }

   case dvmrpNeighborExpiryTime:
       long_return = (NEIGHBOR_EXPIRE_TIME - neighbor->al_timer
        + secs_remaining_offset()) * 100;
       return (u_char *) &long_return;

   case dvmrpNeighborVersion: {
       static char buff[15];

       snprintf(buff, sizeof buff, "%d.%d", neighbor->al_pv, neighbor->al_mv);
       *var_len = strlen(buff);
       return (u_char *)buff;
   }

   case dvmrpNeighborGenerationId:
       long_return = neighbor->al_genid;
       return (u_char *) &long_return;

    default:
       ERROR("");
    }
    return NULL;
}

/* Look up ifIndex given uvifs[ifnum].uv_lcl_addr */
struct in_ifaddr *        /* returns: in_ifaddr structure, or null on error */
ipaddr_to_ifindex(u_long ipaddr, int *ifIndex)
{
    int interface;
static struct in_ifaddr in_ifaddr;

    Interface_Scan_Init();
    for (;;) {
       if (Interface_Scan_Next(&interface, (char *)0, NULL, &in_ifaddr) == 0)
          return NULL;

       if (((struct sockaddr_in *) &(in_ifaddr.ia_addr))->sin_addr.s_addr
        == ipaddr) {
          *ifIndex = interface;
          return &in_ifaddr;
       }
    }
}

/*
 * Find if a specific scoped boundary exists on a Vif
 */
struct listaddr *
find_cache(u_long grp, vifi_t vifi)
{
   struct listaddr *n;

   for (n = uvifs[vifi].uv_groups; n != NULL; n = n->al_next) {
      if (grp == n->al_addr)
         return n;
   }
   return NULL;
}

/*
 * Find the next group cache entry >= (A,V) spec
 */
struct listaddr *
next_cache(u_long addr, vifi_t *vifi)
{
   struct listaddr *bestn=NULL, *n;
   int  i, besti;

   /* Step through all entries looking for the next one */
   for (i = 0; i < numvifs; i++) {
      for (n = uvifs[i].uv_groups; n; n=n->al_next) {
         if ((n->al_addr > addr || (n->al_addr == addr && i >= *vifi))
          && (!bestn || n->al_addr < bestn->al_addr
           || (n->al_addr == bestn->al_addr && i < besti))) {
            bestn = n;
            besti = i;
         }
      }
   }

   if (bestn) {
      *vifi = besti;
      return bestn;
   }
   return NULL;
}

/*
 * Implements the IGMP Cache Table portion of the IGMP MIB
 * vp          : IN - pointer to variable entry that points here
 * name        : IN/OUT - input name requested, output name found
 * length      : IN/OUT - length of input and output oid's
 * exact       : IN - TRUE if an exact match was requested.
 * var_len     : OUT - length of variable or 0 if function returned.
 * write_method: OUT - pointer to function to set variable, otherwise 0
 */
u_char *
o_igmpCacheTable(register struct variable *vp, register oid *name,
    register int *length, int exact, int *var_len, int (**write_method)())
{
    vifi_t     vifi;
    u_long     grp;
    int	      ifIndex;
    struct listaddr *cache;
    oid        newname[MAX_NAME_LEN];
    int        len;
    struct in_ifaddr *in_ifaddr;
    struct in_multi   in_multi, *inm;

    /* Copy name OID to new OID */
    bcopy((char *)vp->name, (char *)newname, (int)vp->namelen * sizeof(oid));

    if (exact) {
	    if (*length != vp->namelen + 5)
		return NULL;

      if ((vifi = name[vp->namelen+4]) >= numvifs)
      return NULL;

      if (!get_address(name, *length, &grp, vp->namelen))
		return NULL;

      if (!(cache = find_cache(grp, vifi)))
		return NULL;

       bcopy((char *)name, (char *)newname, ((int)*length) * sizeof(oid));
	 } else {
       len = *length;
       if (compare(name, *length, vp->name, vp->namelen) < 0)
          len = vp->namelen;

	  if (len < vp->namelen + 5) { /* get first entry */

	     if (len == vp->namelen) {
		vifi = grp = 0;
             } else {
                get_address(name, len, &grp, vp->namelen);
                vifi = name[vp->namelen+4];
             }

             cache = next_cache(grp,&vifi);
             if (!cache)
                return NULL;

             put_address(newname, cache->al_addr, vp->namelen);
	     newname[vp->namelen+4] = vifi;
	  } else {  /* get next entry given previous */
             get_address(name, *length, &grp, vp->namelen);
	     vifi = name[vp->namelen+4]+1;

             if (!(cache = next_cache(grp,&vifi)))
                return NULL;

             put_address(newname, cache->al_addr, vp->namelen);
	     newname[vp->namelen+4] = vifi;
	  }
    }

    /* Save new OID */
    *length = vp->namelen + 5;
    bcopy((char *)newname, (char *)name, ((int)*length) * sizeof(oid));
    *write_method = 0;
    *var_len = sizeof(long);

    /* Look up ifIndex given uvifs[vifi].uv_lcl_addr */
    in_ifaddr = ipaddr_to_ifindex(uvifs[vifi].uv_lcl_addr, &ifIndex);

    switch (vp->magic) {

   case igmpCacheSelf:
       inm = in_ifaddr->ia_multiaddrs;
       while (inm) {
          klookup( (int)inm, (char *)&in_multi, sizeof(in_multi));

          if (in_multi.inm_addr.s_addr == cache->al_addr) {
             long_return = 1; /* true */
             return (u_char *) &long_return;
          }

          inm = in_multi.inm_next;
       }
       long_return = 2; /* false */
       return (u_char *) &long_return;

   case igmpCacheLastReporter:
       return (u_char *) &cache->al_genid;

   case igmpCacheUpTime: {
      time_t currtime;
      time(&currtime);
      long_return = (currtime - cache->al_ctime)*100;
      return (u_char *) &long_return;
   }

   case igmpCacheExpiryTime:
       long_return = secs_remaining(cache->al_timerid)*100;
       return (u_char *) &long_return;

   case igmpCacheStatus:
       long_return = 1;
       return (u_char *) &long_return;

    default:
       ERROR("");
    }
    return NULL;
}

/*
 * Implements the IGMP Interface Table portion of the IGMP MIB
 * vp          : IN - pointer to variable entry that points here
 * name        : IN/OUT - input name requested, output name found
 * length      : IN/OUT - length of input and output oid's
 * exact       : IN - TRUE if an exact match was requested.
 * var_len     : OUT - length of variable or 0 if function returned.
 * write_method: OUT - pointer to function to set variable, otherwise 0
 */
u_char *
o_igmpInterfaceTable(register struct variable *vp, register oid	*name,
    register int *length, int exact, int *var_len, int (**write_method)())
{
    oid			newname[MAX_NAME_LEN];
    register int	ifnum;
    int result;
static struct sioc_vif_req v_req;

    /* Copy name OID to new OID */
    bcopy((char *)vp->name, (char *)newname, (int)vp->namelen * sizeof(oid));

    /* find "next" interface */
    for(ifnum = 0; ifnum < numvifs; ifnum++){
       if (!(uvifs[ifnum].uv_flags & VIFF_QUERIER))
           continue;
       newname[vp->namelen] = (oid)ifnum;
       result = compare(name, *length, newname, (int)vp->namelen + 1);
       if ((exact && (result == 0)) || (!exact && (result < 0)))
          break;
    }
    if (ifnum >= numvifs)
       return NULL;

    /* Save new OID */
    bcopy((char *)newname, (char *)name, ((int)vp->namelen + 1) * sizeof(oid));
    *length = vp->namelen + 1;
    *write_method = 0;
    *var_len = sizeof(long);

    switch (vp->magic){

	case igmpInterfaceQueryInterval:
		long_return = GROUP_QUERY_INTERVAL;
      return (u_char *) &long_return;

	case igmpInterfaceStatus:
		long_return = 1; /* active */
      return (u_char *) &long_return;

	default:
	    ERROR("");
    }
    return NULL;
}

/*
 * Given a virtual interface number, make sure we have the current
 * kernel information for that Vif.
 */
refresh_vif(struct sioc_vif_req *v_req, int ifnum)
{
   static   int lastq = -1;

   if (quantum!=lastq || v_req->vifi != ifnum) {
       lastq = quantum;
       v_req->vifi = ifnum;
       if (ioctl(udp_socket, SIOCGETVIFCNT, (char *)v_req) < 0)
          v_req->icount = v_req->ocount = v_req->ibytes = v_req->obytes = 0;
   }
}

/*
 * Implements the Multicast Routing Interface Table portion of the Multicast MIB
 * vp          : IN - pointer to variable entry that points here
 * name        : IN/OUT - input name requested, output name found
 * length      : IN/OUT - length of input and output oid's
 * exact       : IN - TRUE if an exact match was requested.
 * var_len     : OUT - length of variable or 0 if function returned.
 * write_method: OUT - pointer to function to set variable, otherwise 0
 */
u_char *
o_ipMRouteInterfaceTable(register struct variable *vp, register oid *name,
    register int *length, int exact, int *var_len, int (**write_method)())
{
    oid			newname[MAX_NAME_LEN];
    register int	ifnum;
    int result;
static struct sioc_vif_req v_req;

    /* Copy name OID to new OID */
    bcopy((char *)vp->name, (char *)newname, (int)vp->namelen * sizeof(oid));

    /* find "next" interface */
    for(ifnum = 0; ifnum < numvifs; ifnum++){
	newname[vp->namelen] = (oid)ifnum;
	result = compare(name, *length, newname, (int)vp->namelen + 1);
	if ((exact && (result == 0)) || (!exact && (result < 0)))
	    break;
    }
    if (ifnum >= numvifs)
	return NULL;

    /* Save new OID */
    bcopy((char *)newname, (char *)name, ((int)vp->namelen + 1) * sizeof(oid));
    *length = vp->namelen + 1;
    *write_method = 0;
    *var_len = sizeof(long);

    switch (vp->magic){

   case ipMRouteInterfaceTtl:
       long_return = uvifs[ifnum].uv_threshold;
       return (u_char *) &long_return;

   case dvmrpVInterfaceType:
      if (uvifs[ifnum].uv_flags & VIFF_SRCRT)
         long_return = 2;
      else if (uvifs[ifnum].uv_flags & VIFF_TUNNEL)
         long_return = 1;
      else if (uvifs[ifnum].uv_flags & VIFF_QUERIER)
         long_return = 3;
      else                               /* SUBNET */
         long_return = 4;
      return (u_char *) &long_return;

   case dvmrpVInterfaceState:
      if (uvifs[ifnum].uv_flags & VIFF_DISABLED)
         long_return = 3;
      else if ((uvifs[ifnum].uv_flags & VIFF_DOWN)
       || ((uvifs[ifnum].uv_flags & VIFF_TUNNEL) && (uvifs[ifnum].uv_neighbors==NULL)))
         long_return = 2;
      else /* UP */
         long_return = 1;
      return (u_char *) &long_return;

   case dvmrpVInterfaceLocalAddress:
      return (u_char *) &uvifs[ifnum].uv_lcl_addr;

   case dvmrpVInterfaceRemoteAddress:
      return (u_char *) ((uvifs[ifnum].uv_flags & VIFF_TUNNEL) ?
         &uvifs[ifnum].uv_rmt_addr :
         &uvifs[ifnum].uv_subnet);

   case dvmrpVInterfaceRemoteSubnetMask:
      return (u_char *) &uvifs[ifnum].uv_subnetmask;

   case dvmrpVInterfaceMetric:
       long_return = uvifs[ifnum].uv_metric;
       return (u_char *) &long_return;

   case dvmrpVInterfaceRateLimit:
       long_return = uvifs[ifnum].uv_rate_limit;
       return (u_char *) &long_return;

   case dvmrpVInterfaceInPkts:
       refresh_vif(&v_req, ifnum);
       long_return = v_req.icount;
       return (u_char *) &long_return;

   case dvmrpVInterfaceOutPkts:
       refresh_vif(&v_req, ifnum);
       long_return = v_req.ocount;
       return (u_char *) &long_return;

   case dvmrpVInterfaceInOctets:
       refresh_vif(&v_req, ifnum);
       long_return = v_req.ibytes;
       return (u_char *) &long_return;

   case dvmrpVInterfaceOutOctets:
       refresh_vif(&v_req, ifnum);
       long_return = v_req.obytes;
       return (u_char *) &long_return;

	default:
	    ERROR("");
    }
    return NULL;
}

/*
 * Implements the DVMRP Route Table portion of the DVMRP MIB
 * vp          : IN - pointer to variable entry that points here
 * name        : IN/OUT - input name requested, output name found
 * length      : IN/OUT - length of input and output oid's
 * exact       : IN - TRUE if an exact match was requested.
 * var_len     : OUT - length of variable or 0 if function returned.
 * write_method: OUT - pointer to function to set variable, otherwise 0
 */
u_char *
o_dvmrpRouteTable(register struct variable *vp, register oid *name,
    register int *length, int exact, int *var_len, int (**write_method)())
{
    u_long src, mask;
    oid        newname[MAX_NAME_LEN];
    int        len;
    struct rtentry *rt = NULL;

    /* Copy name OID to new OID */
    bcopy((char *)vp->name, (char *)newname, (int)vp->namelen * sizeof(oid));

    if (exact) {
	    if (*length != vp->namelen + 8)
		return NULL;

      if (!get_address(name, *length, &src, vp->namelen)
       || !get_address(name, *length, &mask, vp->namelen+4))
		return NULL;

      if (!(rt = snmp_find_route(src, mask)))
		return NULL;

       bcopy((char *)name, (char *)newname, ((int)*length) * sizeof(oid));
	 } else {
       len = *length;
       if (compare(name, *length, vp->name, vp->namelen) < 0)
          len = vp->namelen;

	    if (len < vp->namelen + 8) { /* get first entry */

         if (len == vp->namelen) {
            src = mask = 0;
         } else {
            get_address(name, len, &src, vp->namelen);
            get_address(name, len, &mask, vp->namelen+4);
         }

         if (!next_route(&rt,src,mask)) /* Get first entry */
            return NULL;

         put_address(newname, rt->rt_origin    , vp->namelen);
         put_address(newname, rt->rt_originmask, vp->namelen+4);
	    } else {  /* get next entry given previous */
         get_address(name, *length, &src,  vp->namelen);
         get_address(name, *length, &mask, vp->namelen+4);

         if (!next_route(&rt, src,mask))
            return NULL;

         put_address(newname, rt->rt_origin,     vp->namelen);
         put_address(newname, rt->rt_originmask, vp->namelen+4);
	    }
    }

    /* Save new OID */
    *length = vp->namelen + 8;
    bcopy((char *)newname, (char *)name, ((int)*length) * sizeof(oid));
    *write_method = 0;
    *var_len = sizeof(long);

    switch (vp->magic) {

      case dvmrpRouteUpstreamNeighbor:
         return (u_char *) &rt->rt_gateway;

      case dvmrpRouteInVifIndex:
         long_return = rt->rt_parent;
         return (u_char *) &long_return;

      case dvmrpRouteMetric:
         long_return = rt->rt_metric;
         return (u_char *) &long_return;

      case dvmrpRouteExpiryTime:
         long_return = (ROUTE_EXPIRE_TIME - rt->rt_timer
          + secs_remaining_offset()) * 100;
         return (u_char *) &long_return;

    default:
       ERROR("");
    }
    return NULL;
}

/*
 * Implements the DVMRP Routing Next Hop Table portion of the DVMRP MIB
 * vp          : IN - pointer to variable entry that points here
 * name        : IN/OUT - input name requested, output name found
 * length      : IN/OUT - length of input and output oid's
 * exact       : IN - TRUE if an exact match was requested.
 * var_len     : OUT - length of variable or 0 if function returned.
 * write_method: OUT - pointer to function to set variable, otherwise 0
 */
u_char *
o_dvmrpRouteNextHopTable(register struct variable *vp, register oid *name,
    register int *length, int exact, int *var_len, int (**write_method)())
{
    u_long     src, mask;
    vifi_t     vifi;
    struct rtentry *rt = NULL;
    oid        newname[MAX_NAME_LEN];
    int        len;

    /* Copy name OID to new OID */
    bcopy((char *)vp->name, (char *)newname, (int)vp->namelen * sizeof(oid));

    if (exact) {
	    if (*length != vp->namelen + 9)
		return NULL;

      if (!get_address(name, *length, &src, vp->namelen)
       || !get_address(name, *length, &mask, vp->namelen+4)
       || (!(rt=snmp_find_route(src,mask))))
		return NULL;

      vifi = name[vp->namelen+8];
      if (!(VIFM_ISSET(vifi, rt->rt_children)))
      return NULL;

       bcopy((char *)name, (char *)newname, ((int)*length) * sizeof(oid));
	 } else {
       len = *length;
       if (compare(name, *length, vp->name, vp->namelen) < 0)
          len = vp->namelen;

	    if (len < vp->namelen + 9) { /* get first entry */

         get_address(name, len, &src,  vp->namelen);
         get_address(name, len, &mask, vp->namelen+4);

         /* Find first child vif */
         vifi=0;
         if (!next_route_child(&rt, src, mask, &vifi))
            return NULL;

         put_address(newname, rt->rt_origin,     vp->namelen);
         put_address(newname, rt->rt_originmask, vp->namelen+4);
	 newname[vp->namelen+8] = vifi;
	    } else {  /* get next entry given previous */
		   vifi = name[vp->namelen+8] + 1;
         if (!get_address(name, *length, &src,  vp->namelen)
          || !get_address(name, *length, &mask, vp->namelen+4)
          || !next_route_child(&rt, src, mask, &vifi))
            return NULL;

         put_address(newname, rt->rt_origin,     vp->namelen);
         put_address(newname, rt->rt_originmask, vp->namelen+4);
		   newname[vp->namelen+8] = vifi;
	    }
    }

    /* Save new OID */
    *length = vp->namelen + 9;
    bcopy((char *)newname, (char *)name, ((int)*length) * sizeof(oid));
    *write_method = 0;
    *var_len = sizeof(long);

    switch (vp->magic) {

    case dvmrpRouteNextHopType:
       long_return = (VIFM_ISSET(vifi, rt->rt_leaves))? 1 : 2;
       return (u_char *) &long_return;

    default:
       ERROR("");
    }
    return NULL;
}

/*
 * Implements the IP Multicast Route Table portion of the Multicast MIB
 * vp          : IN - pointer to variable entry that points here
 * name        : IN/OUT - input name requested, output name found
 * length      : IN/OUT - length of input and output oid's
 * exact       : IN - TRUE if an exact match was requested.
 * var_len     : OUT - length of variable or 0 if function returned.
 * write_method: OUT - pointer to function to set variable, otherwise 0
 */
u_char *
o_ipMRouteTable(register struct variable *vp, register oid *name,
    register int *length, int exact, int *var_len, int (**write_method)())
{
    u_long src, grp, mask;
    struct gtable *gt = NULL;
    struct stable *st = NULL;
static struct sioc_sg_req sg_req;
    oid        newname[MAX_NAME_LEN];
    int        len;

    /* Copy name OID to new OID */
    bcopy((char *)vp->name, (char *)newname, (int)vp->namelen * sizeof(oid));

    if (exact) {
	    if (*length != vp->namelen + 12)
		return NULL;

      if (!get_address(name, *length, &grp,  vp->namelen)
       || !get_address(name, *length, &src,  vp->namelen+4)
       || !get_address(name, *length, &mask, vp->namelen+8)
       || (mask != 0xFFFFFFFF) /* we keep sources now, not subnets */
       || !(gt = find_grp(grp))
       || !(st = find_grp_src(gt,src)))
		return NULL;

       bcopy((char *)name, (char *)newname, ((int)*length) * sizeof(oid));
	 } else {
       len = *length;
       if (compare(name, *length, vp->name, vp->namelen) < 0)
          len = vp->namelen;

	    if (len < vp->namelen + 12) { /* get first entry */

         get_address(name, len, &grp,  vp->namelen);
         get_address(name, len, &src,  vp->namelen+4);
         get_address(name, len, &mask, vp->namelen+8);

         if (!next_grp_src_mask(&gt,&st,grp,src,mask)) /* Get first entry */
            return NULL;

         put_address(newname, gt->gt_mcastgrp, vp->namelen);
         put_address(newname, st->st_origin,   vp->namelen+4);
         put_address(newname, 0xFFFFFFFF,      vp->namelen+8);
	    } else {  /* get next entry given previous */
         get_address(name, *length, &grp , vp->namelen);
         get_address(name, *length, &src , vp->namelen+4);
         get_address(name, *length, &mask, vp->namelen+8);

         if (!next_grp_src_mask(&gt, &st, grp,src,mask))
            return NULL;

         put_address(newname, gt->gt_mcastgrp, vp->namelen);
         put_address(newname, st->st_origin,   vp->namelen+4);
         put_address(newname, 0xFFFFFFFF,      vp->namelen+8);
	    }
    }

    /* Save new OID */
    *length = vp->namelen + 12;
    bcopy((char *)newname, (char *)name, ((int)*length) * sizeof(oid));
    *write_method = 0;
    *var_len = sizeof(long);

    switch (vp->magic) {

      case ipMRouteUpstreamNeighbor:
         return (u_char *) &gt->gt_route->rt_gateway;

      case ipMRouteInIfIndex:
         long_return = gt->gt_route->rt_parent;
         return (u_char *) &long_return;

      case ipMRouteUpTime: {
         time_t currtime;
         time(&currtime);
         long_return = (currtime - gt->gt_ctime)*100;
         return (u_char *) &long_return;
      }

      case ipMRouteExpiryTime:
         long_return = 5*((gt->gt_timer+4)/5); /* round up to nearest 5 */
         long_return = (long_return + secs_remaining_offset()) * 100;
         return (u_char *) &long_return;

      case ipMRoutePkts:
         refresh_sg(&sg_req, gt, st);
         long_return = sg_req.pktcnt;
         return (u_char *) &long_return;

      case ipMRouteOctets:
         refresh_sg(&sg_req, gt, st);
         long_return = sg_req.bytecnt;
         return (u_char *) &long_return;

      case ipMRouteDifferentInIfIndexes:
         refresh_sg(&sg_req, gt, st);
         long_return = sg_req.wrong_if;
         return (u_char *) &long_return;

      case ipMRouteProtocol:
         long_return = 4;
         return (u_char *) &long_return;

    default:
       ERROR("");
    }
    return NULL;
}

/*
 * Implements the IP Multicast Routing Next Hop Table portion of the Multicast
 * MIB
 * vp          : IN - pointer to variable entry that points here
 * name	       : IN/OUT - input name requested, output name found
 * length      : IN/OUT - length of input and output oid's
 * exact       : IN - TRUE if an exact match was requested.
 * var_len     : OUT - length of variable or 0 if function returned.
 * write_method: OUT - pointer to function to set variable, otherwise 0
 */
u_char *
o_ipMRouteNextHopTable(register struct variable *vp, register oid *name,
    register int *length, int exact, int *var_len, int (**write_method)())
{
    u_long src, grp, mask, addr;
    vifi_t   vifi;
    struct gtable *gt;
    struct stable *st;
    oid        newname[MAX_NAME_LEN];
    int        len;

    /* Copy name OID to new OID */
    bcopy((char *)vp->name, (char *)newname, (int)vp->namelen * sizeof(oid));

    if (exact) {
	    if (*length != vp->namelen + 17)
		return NULL;

      if (!get_address(name, *length, &grp, vp->namelen)
       || !get_address(name, *length, &src, vp->namelen+4)
       || !get_address(name, *length, &mask, vp->namelen+8)
       || !get_address(name, *length, &addr, vp->namelen+13)
       || grp!=addr
       || mask!=0xFFFFFFFF
       || (!(gt=find_grp(grp)))
       || (!(st=find_grp_src(gt,src))))
		return NULL;

      vifi = name[vp->namelen+12];
      if (!(VIFM_ISSET(vifi, gt->gt_route->rt_children)))
      return NULL;

       bcopy((char *)name, (char *)newname, ((int)*length) * sizeof(oid));
	 } else {
       len = *length;
       if (compare(name, *length, vp->name, vp->namelen) < 0)
          len = vp->namelen;

	    if (len < vp->namelen + 17) { /* get first entry */

         get_address(name, len, &grp, vp->namelen);
         get_address(name, len, &src, vp->namelen+4);
         get_address(name, len, &mask, vp->namelen+8);

         /* Find first child vif */
         vifi=0;
         if (!next_child(&gt, &st, grp, src, mask, &vifi))
            return NULL;

         put_address(newname, gt->gt_mcastgrp, vp->namelen);
         put_address(newname, st->st_origin,   vp->namelen+4);
         put_address(newname, 0xFFFFFFFF,      vp->namelen+8);
	 newname[vp->namelen+12] = vifi;
         put_address(newname, gt->gt_mcastgrp, vp->namelen+13);

	    } else {  /* get next entry given previous */
		   vifi = name[vp->namelen+12]+1;
         if (!get_address(name, *length, &grp,  vp->namelen)
          || !get_address(name, *length, &src,  vp->namelen+4)
          || !get_address(name, *length, &mask, vp->namelen+8)
          || !next_child(&gt, &st, grp, src, mask, &vifi))
            return NULL;

         put_address(newname, gt->gt_mcastgrp, vp->namelen);
         put_address(newname, st->st_origin,   vp->namelen+4);
         put_address(newname, 0xFFFFFFFF,      vp->namelen+8);
		   newname[vp->namelen+12] = vifi;
         put_address(newname, gt->gt_mcastgrp, vp->namelen+13);
	    }
    }

    /* Save new OID */
    *length = vp->namelen + 17;
    bcopy((char *)newname, (char *)name, ((int)*length) * sizeof(oid));
    *write_method = 0;
    *var_len = sizeof(long);

    switch (vp->magic) {

      case ipMRouteNextHopState:
         long_return = (VIFM_ISSET(vifi, gt->gt_grpmems))? 2 : 1;
         return (u_char *) &long_return;

      /* Currently equal to ipMRouteUpTime */
      case ipMRouteNextHopUpTime: {
         time_t currtime;
         time(&currtime);
         long_return = (currtime - gt->gt_ctime)*100;
         return (u_char *) &long_return;
      }

      case ipMRouteNextHopExpiryTime:
         long_return = 5*((gt->gt_prsent_timer+4)/5); /* round up to nearest 5*/
         long_return = (long_return + secs_remaining_offset()) * 100;
         return (u_char *) &long_return;

      case ipMRouteNextHopClosestMemberHops:
         long_return = 0;
         return (u_char *) &long_return;

      case ipMRouteNextHopProtocol:
         long_return = 4;
         return (u_char *) &long_return;

    default:
       ERROR("");
    }
    return NULL;
}

/* sync_timer is called by timer() every TIMER_INTERVAL seconds.
 * Its job is to record this time so that we can compute on demand
 * the approx # seconds remaining until the next timer() call
 */
static time_t lasttimer;

void
sync_timer(void)
{
    time(&lasttimer);
}

int /* in range [-TIMER_INTERVAL..0] */
secs_remaining_offset(void)
{
   time_t tm;

   time(&tm);
   return lasttimer-tm;
}
@


1.8
log
@ansi cleanup; khalek@@linuxgamers.net
@
text
@@


1.7
log
@less sprintf
@
text
@d59 1
a59 2
snmp_init(dest_port)
    in_port_t dest_port;
d146 1
a146 4
put_address(name, addr, n)
   oid	 *name;
   u_long addr;
   int n;
d158 1
a158 5
get_address(name, length, addr, n)
   oid	 *name;
   int	  length;
   u_long *addr;
   int n;
d180 6
d188 2
a189 7
o_scalar(vp, name, length, exact, var_len, write_method)
    register struct variable *vp;   /* IN - pointer to variable entry that points here */
    register oid	*name;	    /* IN/OUT - input name requested, output name found */
    register int	*length;    /* IN/OUT - length of input and output oid's */
    int			exact;	    /* IN - TRUE if an exact match was requested. */
    int			*var_len;   /* OUT - length of variable or 0 if function returned. */
    int			(**write_method)(); /* OUT - pointer to function to set variable, otherwise 0 */
d232 1
a232 4
find_boundary(vifi, addr, mask)
   vifi_t vifi;
   u_long addr;
   u_long mask;
d247 1
a247 4
next_boundary(vifi, addr, mask)
   vifi_t *vifi;
   u_long  addr;
   u_long  mask;
d271 6
d279 2
a280 7
o_dvmrpBoundaryTable(vp, name, length, exact, var_len, write_method)
    register struct variable *vp;   /* IN - pointer to variable entry that points here */
    register oid	*name;	    /* IN/OUT - input name requested, output name found */
    register int	*length;    /* IN/OUT - length of input and output oid's */
    int			exact;	    /* IN - TRUE if an exact match was requested. */
    int			*var_len;   /* OUT - length of variable or 0 if function returned. */
    int			(**write_method)(); /* OUT - pointer to function to set variable, otherwise 0 */
d364 1
a364 3
next_neighbor(vifi, addr)
   vifi_t *vifi;
   u_long  addr;
d388 1
a388 3
find_neighbor(vifi, addr)
   vifi_t vifi;
   u_long addr;
d399 8
d408 2
a409 7
o_dvmrpNeighborTable(vp, name, length, exact, var_len, write_method)
    register struct variable *vp;   /* IN - pointer to variable entry that points here */
    register oid	*name;	    /* IN/OUT - input name requested, output name found */
    register int	*length;    /* IN/OUT - length of input and output oid's */
    int			exact;	    /* IN - TRUE if an exact match was requested. */
    int			*var_len;   /* OUT - length of variable or 0 if function returned. */
    int			(**write_method)(); /* OUT - pointer to function to set variable, otherwise 0 */
d506 1
a506 3
ipaddr_to_ifindex(ipaddr, ifIndex)
   u_long ipaddr;
   int   *ifIndex;
d528 1
a528 3
find_cache(grp, vifi)
   u_long grp;
   vifi_t vifi;
d543 1
a543 3
next_cache(addr, vifi)
   u_long  addr;
   vifi_t *vifi;
d569 6
d577 2
a578 7
o_igmpCacheTable(vp, name, length, exact, var_len, write_method)
    register struct variable *vp;   /* IN - pointer to variable entry that points here */
    register oid	*name;	    /* IN/OUT - input name requested, output name found */
    register int	*length;    /* IN/OUT - length of input and output oid's */
    int			exact;	    /* IN - TRUE if an exact match was requested. */
    int			*var_len;   /* OUT - length of variable or 0 if function returned. */
    int			(**write_method)(); /* OUT - pointer to function to set variable, otherwise 0 */
d690 6
d698 2
a699 7
o_igmpInterfaceTable(vp, name, length, exact, var_len, write_method)
    register struct variable *vp;   /* IN - pointer to variable entry that points here */
    register oid	*name;	    /* IN/OUT - input name requested, output name found */
    register int	*length;    /* IN/OUT - length of input and output oid's */
    int			exact;	    /* IN - TRUE if an exact match was requested. */
    int			*var_len;   /* OUT - length of variable or 0 if function returned. */
    int			(**write_method)(); /* OUT - pointer to function to set variable, otherwise 0 */
d747 1
a747 3
refresh_vif(v_req, ifnum)
   struct sioc_vif_req *v_req;
   int ifnum;
d761 6
d769 2
a770 7
o_ipMRouteInterfaceTable(vp, name, length, exact, var_len, write_method)
    register struct variable *vp;   /* IN - pointer to variable entry that points here */
    register oid	*name;	    /* IN/OUT - input name requested, output name found */
    register int	*length;    /* IN/OUT - length of input and output oid's */
    int			exact;	    /* IN - TRUE if an exact match was requested. */
    int			*var_len;   /* OUT - length of variable or 0 if function returned. */
    int			(**write_method)(); /* OUT - pointer to function to set variable, otherwise 0 */
d870 6
d878 2
a879 7
o_dvmrpRouteTable(vp, name, length, exact, var_len, write_method)
    register struct variable *vp;   /* IN - pointer to variable entry that points here */
    register oid	*name;	    /* IN/OUT - input name requested, output name found */
    register int	*length;    /* IN/OUT - length of input and output oid's */
    int			exact;	    /* IN - TRUE if an exact match was requested. */
    int			*var_len;   /* OUT - length of variable or 0 if function returned. */
    int			(**write_method)(); /* OUT - pointer to function to set variable, otherwise 0 */
d964 6
d972 2
a973 7
o_dvmrpRouteNextHopTable(vp, name, length, exact, var_len, write_method)
    register struct variable *vp;   /* IN - pointer to variable entry that points here */
    register oid	*name;	    /* IN/OUT - input name requested, output name found */
    register int	*length;    /* IN/OUT - length of input and output oid's */
    int			exact;	    /* IN - TRUE if an exact match was requested. */
    int			*var_len;   /* OUT - length of variable or 0 if function returned. */
    int			(**write_method)(); /* OUT - pointer to function to set variable, otherwise 0 */
d1049 6
d1057 2
a1058 7
o_ipMRouteTable(vp, name, length, exact, var_len, write_method)
    register struct variable *vp;   /* IN - pointer to variable entry that points here */
    register oid	*name;	    /* IN/OUT - input name requested, output name found */
    register int	*length;    /* IN/OUT - length of input and output oid's */
    int			exact;	    /* IN - TRUE if an exact match was requested. */
    int			*var_len;   /* OUT - length of variable or 0 if function returned. */
    int			(**write_method)(); /* OUT - pointer to function to set variable, otherwise 0 */
d1169 6
d1177 2
a1178 7
o_ipMRouteNextHopTable(vp, name, length, exact, var_len, write_method)
    register struct variable *vp;   /* IN - pointer to variable entry that points here */
    register oid	*name;	    /* IN/OUT - input name requested, output name found */
    register int	*length;    /* IN/OUT - length of input and output oid's */
    int			exact;	    /* IN - TRUE if an exact match was requested. */
    int			*var_len;   /* OUT - length of variable or 0 if function returned. */
    int			(**write_method)(); /* OUT - pointer to function to set variable, otherwise 0 */
d1293 1
a1293 1
sync_timer()
d1299 1
a1299 1
secs_remaining_offset()
@


1.6
log
@spaces
@
text
@d219 2
a220 1
       sprintf(buff, "mrouted%d.%d", PROTOCOL_VERSION, MROUTED_VERSION);
d502 1
a502 1
       sprintf(buff, "%d.%d", neighbor->al_pv, neighbor->al_mv);
@


1.5
log
@apparently xerox wrote this snmp stuff
@
text
@d6 1
a6 1
 * Redistribution and use in source and binary forms, with or without modification, 
d17 2
a18 2
 * to endorse or promote products derived from this software 
 * without specific prior written permission. 
d20 2
a21 2
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ``AS IS'' 
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
d30 1
a30 1
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
d163 1
a163 1
   oid	 *name;	
d324 11
a334 7
         if (len == vp->namelen) {
            vifi = addr = mask = 0;
         } else {
            vifi = name[vp->namelen];
            get_address(name, len, &addr, vp->namelen+1);
            get_address(name, len, &mask, vp->namelen+5);
         }
d336 3
a338 7
         bound = next_boundary(&vifi,addr,mask);
         if (!bound)
            return NULL;

   		newname[vp->namelen] = vifi;
         put_address(newname, bound->acl_addr, vp->namelen+1);
         put_address(newname, bound->acl_mask, vp->namelen+5);
d341 2
a342 2
         get_address(name, *length, &addr, vp->namelen+1);
         get_address(name, *length, &mask, vp->namelen+5);
d344 2
a345 2
         if (!(bound = next_boundary(&vifi,addr,mask+1)))
            return NULL;
d348 2
a349 2
         put_address(newname, bound->acl_addr, vp->namelen+1);
         put_address(newname, bound->acl_mask, vp->namelen+5);
d464 2
a465 2
   		newname[vp->namelen] = vifi;
         put_address(newname, neighbor->al_addr, vp->namelen+1);
d493 2
a494 2
   case dvmrpNeighborExpiryTime: 
       long_return = (NEIGHBOR_EXPIRE_TIME - neighbor->al_timer 
d527 1
a527 1
       if (Interface_Scan_Next(&interface, (char *)0, NULL, &in_ifaddr) == 0) 
d529 2
a530 2
    
       if (((struct sockaddr_in *) &(in_ifaddr.ia_addr))->sin_addr.s_addr 
d570 1
a570 1
          && (!bestn || n->al_addr < bestn->al_addr 
d628 1
a628 18
	    if (len < vp->namelen + 5) { /* get first entry */

         if (len == vp->namelen) {
            vifi = grp = 0;
         } else {
            get_address(name, len, &grp, vp->namelen);
            vifi = name[vp->namelen+4];
         }

         cache = next_cache(grp,&vifi);
         if (!cache)
            return NULL;

         put_address(newname, cache->al_addr, vp->namelen);
   		newname[vp->namelen+4] = vifi;
	    } else {  /* get next entry given previous */
         get_address(name, *length, &grp, vp->namelen);
		   vifi = name[vp->namelen+4]+1;
d630 23
a652 6
         if (!(cache = next_cache(grp,&vifi)))
            return NULL;

         put_address(newname, cache->al_addr, vp->namelen);
		   newname[vp->namelen+4] = vifi;
	    }
d666 1
a666 1
   case igmpCacheSelf: 
d691 1
a691 1
   case igmpCacheExpiryTime: 
d695 1
a695 1
   case igmpCacheStatus: 
d840 1
a840 1
   case dvmrpVInterfaceLocalAddress: 
d843 1
a843 1
   case dvmrpVInterfaceRemoteAddress: 
d956 1
a956 1
      case dvmrpRouteUpstreamNeighbor: 
d968 1
a968 1
         long_return = (ROUTE_EXPIRE_TIME - rt->rt_timer 
d1030 1
a1030 1
   		newname[vp->namelen+8] = vifi;
d1136 1
a1136 1
      case ipMRouteUpstreamNeighbor: 
d1241 1
a1241 1
   		newname[vp->namelen+12] = vifi;
@


1.4
log
@u_short cleansing
@
text
@d3 30
@


1.3
log
@missing sockaddr inits; ok itojun
@
text
@d12 1
a12 1
    u_short dest_port = 0;
d30 1
a30 1
    u_short dest_port;
@


1.2
log
@from netbsd; update to mrouted 3.8
@
text
@d93 1
@


1.1
log
@Initial revision
@
text
@d1 1
a1 9
/*	$NetBSD: snmp.c,v 1.2 1995/10/09 03:51:58 thorpej Exp $	*/

/*
 * snmp.c
 *
 * Code written by David Thaler <thalerd@@eecs.umich.edu>
 * Moved to a seperate file by Bill Fenner <fenner@@parc.xerox.com>
 */

d4 1
a4 1
#include <string.h>
d6 16
d23 1
a23 2
#define NUMMIBS 2
#define SNMPD_RETRY_INTERVAL 300 /* periodic snmpd probe interval */
d25 44
a68 1
char *mibs[]={ "ipMRouteMIB", "dvmrpMIB" };
d70 41
a110 13
extern int o_ipMRouteTable();
extern int o_ipMRouteNextHopTable();
extern int o_dvmrpRouteTable();
extern int o_dvmrpRouteNextHopTable();

       int smux_fd = NOTOK;
       int rock_and_roll = 0;
       int dont_bother_anymore = 0;
       int quantum = 0;
static OID   subtree[NUMMIBS] = NULLOID;
static struct smuxEntry *se = NULL;
extern int smux_errno;
extern char smux_info[BUFSIZ];
d113 1
a113 1
 * Place an IP address into an OID starting at element n 
d116 2
a117 2
put_address(oid, addr, n)
   OID oid;
d124 1
a124 1
      oid->oid_elements[i] = addr & 0xFF;
d131 3
a133 2
get_address(oid, addr, n)
   OID oid;
d142 1
a142 1
   if (oid -> oid_nelem < n+4)
d147 1
a147 1
      if (i >= oid->oid_nelem)
d150 1
a150 1
         (*addr) |= oid->oid_elements[i];
a151 1

d156 1
a156 1
 *  Attempt to start up SMUX protocol
d158 34
a191 11
void
try_smux_init()
{
    if (smux_fd != NOTOK || dont_bother_anymore) 
       return;
    if ((smux_fd = smux_init(debug)) == NOTOK) {
       log(LOG_WARNING, 0,"smux_init: %s [%s]", smux_error(smux_errno), 
        smux_info);
    } else 
       rock_and_roll = 0;
}
d193 3
a195 57
/* 
 * Implements scalar objects from both MIBs 
 */
static int 
o_scalar(oi, v, offset)
   OI oi;
   register struct type_SNMP_VarBind *v;
   int offset;
{
    int     ifvar;
    register OID    oid = oi -> oi_name;
    register OT     ot = oi -> oi_type;

    ifvar = (int) ot -> ot_info;
    switch (offset) {
        case type_SNMP_SMUX__PDUs_get__request:
            if (oid -> oid_nelem !=
                        ot -> ot_name -> oid_nelem + 1
                    || oid -> oid_elements[oid -> oid_nelem - 1]
                            != 0)
                return int_SNMP_error__status_noSuchName;
            break;

        case type_SNMP_SMUX__PDUs_get__next__request:
            if (oid -> oid_nelem
                    == ot -> ot_name -> oid_nelem) {
                OID     new;

                if ((new = oid_extend (oid, 1)) == NULLOID)
                    return int_SNMP_error__status_genErr;
                new -> oid_elements[new -> oid_nelem - 1] = 0;

                if (v -> name)
                    free_SNMP_ObjectName (v -> name);
                v -> name = new;
            }
            else
                return NOTOK;
            break;

        default:
            return int_SNMP_error__status_genErr;
    }

    switch (ifvar) {
        case ipMRouteEnable:
            return o_integer (oi, v, 1);

        case dvmrpVersion: {
            static char buff[15];

            sprintf(buff, "mrouted%d.%d", PROTOCOL_VERSION, MROUTED_VERSION);
            return o_string (oi, v, buff, strlen (buff));
        }

        case dvmrpGenerationId:
            return o_integer (oi, v, dvmrp_genid);
d197 2
a198 2
        default:
            return int_SNMP_error__status_noSuchName;
d200 1
d203 1
a203 1
/* 
d208 3
a210 3
   int vifi;
   int addr;
   int mask;
d222 1
a222 1
 * Find the next scoped boundary in order after a given spec
d226 3
a228 3
   int *vifi;
   int  addr;
   int  mask;
d236 3
a238 3
         if ((i > *vifi || n->acl_addr > addr 
           || (n->acl_addr==addr && n->acl_mask>mask)) 
          && (!bestn || n->acl_addr < bestn->acl_addr 
d253 11
a263 9
static int  
o_dvmrpBoundaryTable (oi, v, offset)
OI	oi;
register struct type_SNMP_VarBind *v;
{
    int	    ifvar, vifi,
	    addr, mask;
    register OID    oid = oi -> oi_name;
    register OT	   ot = oi -> oi_type;
d265 2
d268 13
a280 12
    ifvar = (int) ot -> ot_info;
    switch (offset) {
	case type_SNMP_SMUX__PDUs_get__request:
	    if (oid->oid_nelem != ot->ot_name->oid_nelem + 9)
		return int_SNMP_error__status_noSuchName;

      if ((vifi = oid -> oid_elements[ot-> ot_name->oid_nelem]) >= numvifs)
      return int_SNMP_error__status_noSuchName;

      if (!get_address(oid, &addr, ot->ot_name->oid_nelem+1)
       || !get_address(oid, &mask, ot->ot_name->oid_nelem+5))
		return int_SNMP_error__status_noSuchName;
d283 1
a283 2
		return int_SNMP_error__status_noSuchName;
	    break;
d285 15
a299 11
	case type_SNMP_SMUX__PDUs_get__next__request:
	    if (oid->oid_nelem < ot->ot_name->oid_nelem + 9) {
		OID	new;

      if (oid->oid_nelem == ot->ot_name->oid_nelem) {
         vifi = addr = mask = 0;
      } else {
         vifi = oid->oid_elements[ot->ot_name->oid_nelem];
         get_address(oid, &addr, ot->ot_name->oid_nelem+1);
         get_address(oid, &mask, ot->ot_name->oid_nelem+5);
      }
d301 7
a307 14
      bound = next_boundary(&vifi,addr,mask);
      if (!bound)
         return NOTOK;

		new = oid_extend (oid, ot->ot_name->oid_nelem+9-oid->oid_nelem);
		if (new == NULLOID)
		    return NOTOK;
		new -> oid_elements[ot->ot_name->oid_nelem] = vifi;
      put_address(new, bound->acl_addr, ot->ot_name->oid_nelem+1);
      put_address(new, bound->acl_mask, ot->ot_name->oid_nelem+5);

		if (v -> name)
		    free_SNMP_ObjectName (v -> name);
		v -> name = new;
d309 3
a311 1
		int	i = ot -> ot_name -> oid_nelem;
a312 3
		   vifi = oid->oid_elements[i];
         get_address(oid, &addr, ot->ot_name->oid_nelem+1);
         get_address(oid, &mask, ot->ot_name->oid_nelem+5);
d314 1
a314 1
            return NOTOK;
d316 3
a318 4
         put_address(oid, bound->acl_addr, ot->ot_name->oid_nelem+1);
         put_address(oid, bound->acl_mask, ot->ot_name->oid_nelem+5);
		   oid->oid_elements[i] = vifi;
		   oid->oid_nelem = i + 9;
d320 1
a320 1
	    break;
d322 5
a326 3
	default:
	    return int_SNMP_error__status_genErr;
    }
d328 1
a328 1
    switch (ifvar) {
d331 2
a332 1
       return o_integer (oi, v, vifi);
d334 2
a335 2
	default:
	    return int_SNMP_error__status_noSuchName;
d337 1
d340 2
a341 2
/* 
 * Given a vif index and address, return the next greater neighbor entry 
d345 2
a346 2
   int *vifi;
   int  addr;
d354 1
a354 1
         if ((i > *vifi || n->al_addr > addr) 
d371 2
a372 2
   int vifi;
   int addr;
d383 11
a393 12
/*
 * Implements the Neighbor Table portion of the DVMRP MIB
 */
static int  
o_dvmrpNeighborTable (oi, v, offset)
OI	oi;
register struct type_SNMP_VarBind *v;
{
    int	    ifvar, vifi,
	    addr;
    register OID    oid = oi -> oi_name;
    register OT	   ot = oi -> oi_type;
d395 2
d398 2
a399 5
    ifvar = (int) ot -> ot_info;
    switch (offset) {
	case type_SNMP_SMUX__PDUs_get__request:
	    if (oid->oid_nelem != ot->ot_name->oid_nelem + 5)
		return int_SNMP_error__status_noSuchName;
d401 3
a403 2
      if ((vifi = oid -> oid_elements[ot-> ot_name->oid_nelem]) >= numvifs)
      return int_SNMP_error__status_noSuchName;
d405 5
a409 2
      if (!get_address(oid, &addr, ot->ot_name->oid_nelem+1))
		return int_SNMP_error__status_noSuchName;
d412 1
a412 2
		return int_SNMP_error__status_noSuchName;
	    break;
d414 14
a427 10
	case type_SNMP_SMUX__PDUs_get__next__request:
	    if (oid->oid_nelem < ot->ot_name->oid_nelem + 5) { 
		OID	new;

      if (oid->oid_nelem == ot->ot_name->oid_nelem) {
         vifi = addr = 0;
      } else {
         vifi = oid->oid_elements[ot->ot_name->oid_nelem];
         get_address(oid, &addr, ot->ot_name->oid_nelem+1);
      }
d429 3
a431 13
      neighbor = next_neighbor(&vifi,addr); /* Get first entry */
      if (!neighbor)
         return NOTOK;

		new = oid_extend (oid, ot->ot_name->oid_nelem+5-oid->oid_nelem);
		if (new == NULLOID)
		    return NOTOK;
		new -> oid_elements[ot->ot_name->oid_nelem] = vifi;
      put_address(new, neighbor->al_addr, ot->ot_name->oid_nelem+1);

		if (v -> name)
		    free_SNMP_ObjectName (v -> name);
		v -> name = new;
d433 2
d436 2
a437 1
		int	i = ot -> ot_name -> oid_nelem;
a438 2
		   vifi = oid->oid_elements[i];
         get_address(oid, &addr, ot->ot_name->oid_nelem+1);
d440 1
a440 1
            return NOTOK;
d442 2
a443 3
         put_address(oid, neighbor->al_addr, ot->ot_name->oid_nelem+1);
		   oid->oid_elements[i] = vifi;
		   oid->oid_nelem = i + 5;
d445 1
a445 1
	    break;
d447 5
a451 3
	default:
	    return int_SNMP_error__status_genErr;
    }
d453 1
a453 1
    switch (ifvar) {
d458 2
a459 1
       return o_integer (oi, v, (currtime - neighbor->al_ctime)*100);
d462 4
a465 2
   case dvmrpNeighborExpiryTime:
       return o_integer (oi, v, (NEIGHBOR_EXPIRE_TIME-neighbor->al_timer) * 100);
d471 2
a472 1
       return o_string (oi, v, buff, strlen (buff));
d475 246
a720 2
   case dvmrpNeighborGenerationId: 
       return o_integer (oi, v, neighbor->al_genid);
d723 1
a723 1
	    return int_SNMP_error__status_noSuchName;
d725 1
d749 12
a760 10
static int  
o_ipMRouteInterfaceTable (oi, v, offset)
OI	oi;
register struct type_SNMP_VarBind *v;
int	offset;
{
    int	    ifnum,
	    ifvar;
    register OID    oid = oi -> oi_name;
    register OT	   ot = oi -> oi_type;
d763 2
a764 18
    ifvar = (int) ot -> ot_info;
    switch (offset) {
	case type_SNMP_SMUX__PDUs_get__request:
	    if (oid -> oid_nelem != ot -> ot_name -> oid_nelem + 1)
		return int_SNMP_error__status_noSuchName;
	    if ((ifnum = oid -> oid_elements[oid -> oid_nelem - 1]) >= numvifs)
		return int_SNMP_error__status_noSuchName;
	    break;

	case type_SNMP_SMUX__PDUs_get__next__request:
	    if (oid -> oid_nelem == ot -> ot_name -> oid_nelem) {
		OID	new;

		ifnum = 0;

		if ((new = oid_extend (oid, 1)) == NULLOID)
		    return NOTOK;
		new -> oid_elements[new -> oid_nelem - 1] = ifnum;
d766 5
a770 13
		if (v -> name)
		    free_SNMP_ObjectName (v -> name);
		v -> name = new;

	    } else {
		int	i = ot -> ot_name -> oid_nelem;

		if ((ifnum = oid -> oid_elements[i] + 1) >= numvifs)
		    return NOTOK;

		oid -> oid_elements[i] = ifnum;
		oid -> oid_nelem = i + 1;
	    }
a771 3

	default:
	    return int_SNMP_error__status_genErr;
d773 2
d776 11
a786 3
    switch (ifvar) {
	case ipMRouteInterfaceTtl:
	    return o_integer (oi, v, uvifs[ifnum].uv_threshold);
d788 1
a788 1
	case dvmrpVInterfaceType:
d790 1
a790 1
         return o_integer (oi, v, 2); 
d792 1
a792 1
         return o_integer (oi, v, 1); 
d794 1
a794 1
         return o_integer (oi, v, 3); 
d796 2
a797 1
         return o_integer (oi, v, 4); 
d799 1
a799 1
	case dvmrpVInterfaceState: 
d801 4
a804 3
         return o_integer (oi, v, 3);
      else if (uvifs[ifnum].uv_flags & VIFF_DOWN)
         return o_integer (oi, v, 2);
d806 2
a807 1
         return o_integer (oi, v, 1); 
d809 2
a810 5
   case dvmrpVInterfaceLocalAddress: {
      struct sockaddr_in tmp;
      tmp.sin_addr.s_addr = uvifs[ifnum].uv_lcl_addr;
      return o_ipaddr (oi, v, &tmp);
   }
d812 4
a815 7
   case dvmrpVInterfaceRemoteAddress: {
      struct sockaddr_in tmp;
      tmp.sin_addr.s_addr = (uvifs[ifnum].uv_flags & VIFF_TUNNEL) ?
         uvifs[ifnum].uv_rmt_addr :
         uvifs[ifnum].uv_subnet;
      return o_ipaddr (oi, v, &tmp);
   }
d817 2
a818 5
   case dvmrpVInterfaceRemoteSubnetMask: {
      struct sockaddr_in tmp;
      tmp.sin_addr.s_addr = uvifs[ifnum].uv_subnetmask;
      return o_ipaddr (oi, v, &tmp);
   }
d820 3
a822 2
	case dvmrpVInterfaceMetric:
	    return o_integer (oi, v, uvifs[ifnum].uv_metric);
d824 3
a826 2
	case dvmrpVInterfaceRateLimit:
	    return o_integer (oi, v, uvifs[ifnum].uv_rate_limit);
d828 1
a828 1
	case dvmrpVInterfaceInPkts:
d830 2
a831 1
	    return o_integer(oi, v, v_req.icount);
d833 1
a833 1
	case dvmrpVInterfaceOutPkts:
d835 2
a836 1
	    return o_integer(oi, v, v_req.ocount);
d838 1
a838 1
	case dvmrpVInterfaceInOctets:
d840 2
a841 1
	    return o_integer(oi, v, v_req.ibytes);
d843 1
a843 1
	case dvmrpVInterfaceOutOctets:
d845 2
a846 1
	    return o_integer(oi, v, v_req.obytes);
d849 1
a849 1
	    return int_SNMP_error__status_noSuchName;
d851 1
a853 46
struct mib_variable {
   char     *name;        /* MIB variable name */
   int     (*function)(); /* Function to call */
   int       info;        /* Which variable */
} mib_vars[] = {
 "ipMRouteEnable",               o_scalar, ipMRouteEnable,
 "ipMRouteUpstreamNeighbor",     o_ipMRouteTable,  ipMRouteUpstreamNeighbor,
 "ipMRouteInIfIndex",            o_ipMRouteTable,  ipMRouteInIfIndex,
 "ipMRouteUpTime",               o_ipMRouteTable,  ipMRouteUpTime, 
 "ipMRouteExpiryTime",           o_ipMRouteTable,  ipMRouteExpiryTime,
 "ipMRoutePkts",                 o_ipMRouteTable,  ipMRoutePkts, 
 "ipMRouteDifferentInIfIndexes", o_ipMRouteTable,  ipMRouteDifferentInIfIndexes,
 "ipMRouteOctets",               o_ipMRouteTable,  ipMRouteOctets,
 "ipMRouteProtocol",             o_ipMRouteTable,  ipMRouteProtocol,
 "ipMRouteNextHopState",      o_ipMRouteNextHopTable, ipMRouteNextHopState,
 "ipMRouteNextHopUpTime",     o_ipMRouteNextHopTable, ipMRouteNextHopUpTime,
 "ipMRouteNextHopExpiryTime", o_ipMRouteNextHopTable, ipMRouteNextHopExpiryTime,
 "ipMRouteNextHopClosestMemberHops", o_ipMRouteNextHopTable, ipMRouteNextHopClosestMemberHops,
 "ipMRouteNextHopProtocol",   o_ipMRouteNextHopTable, ipMRouteNextHopProtocol,
 "ipMRouteInterfaceTtl",  o_ipMRouteInterfaceTable, ipMRouteInterfaceTtl,
 "dvmrpVersion",               o_scalar, dvmrpVersion,
 "dvmrpGenerationId",          o_scalar, dvmrpGenerationId,
 "dvmrpVInterfaceType",     o_ipMRouteInterfaceTable, dvmrpVInterfaceType,
 "dvmrpVInterfaceState",    o_ipMRouteInterfaceTable, dvmrpVInterfaceState,
 "dvmrpVInterfaceLocalAddress", o_ipMRouteInterfaceTable, dvmrpVInterfaceLocalAddress,
 "dvmrpVInterfaceRemoteAddress", o_ipMRouteInterfaceTable, dvmrpVInterfaceRemoteAddress,
 "dvmrpVInterfaceRemoteSubnetMask", o_ipMRouteInterfaceTable, dvmrpVInterfaceRemoteSubnetMask,
 "dvmrpVInterfaceMetric",    o_ipMRouteInterfaceTable, dvmrpVInterfaceMetric,
 "dvmrpVInterfaceRateLimit", o_ipMRouteInterfaceTable, dvmrpVInterfaceRateLimit,
 "dvmrpVInterfaceInPkts",    o_ipMRouteInterfaceTable, dvmrpVInterfaceInPkts,
 "dvmrpVInterfaceOutPkts",   o_ipMRouteInterfaceTable, dvmrpVInterfaceOutPkts,
 "dvmrpVInterfaceInOctets",  o_ipMRouteInterfaceTable, dvmrpVInterfaceInOctets,
 "dvmrpVInterfaceOutOctets", o_ipMRouteInterfaceTable, dvmrpVInterfaceOutOctets,
 "dvmrpNeighborUpTime",      o_dvmrpNeighborTable, dvmrpNeighborUpTime,
 "dvmrpNeighborExpiryTime",  o_dvmrpNeighborTable, dvmrpNeighborExpiryTime,
 "dvmrpNeighborVersion",     o_dvmrpNeighborTable, dvmrpNeighborVersion,
 "dvmrpNeighborGenerationId",o_dvmrpNeighborTable, dvmrpNeighborGenerationId,
 "dvmrpRouteUpstreamNeighbor", o_dvmrpRouteTable, dvmrpRouteUpstreamNeighbor,
 "dvmrpRouteInVifIndex",       o_dvmrpRouteTable, dvmrpRouteInVifIndex,
 "dvmrpRouteMetric",           o_dvmrpRouteTable, dvmrpRouteMetric,
 "dvmrpRouteExpiryTime",       o_dvmrpRouteTable, dvmrpRouteExpiryTime,
 "dvmrpRouteNextHopType",    o_dvmrpRouteNextHopTable, dvmrpRouteNextHopType,
 "dvmrpBoundaryVifIndex",    o_dvmrpBoundaryTable, dvmrpBoundaryVifIndex,
 0, 0, 0
};

d855 1
a855 1
 * Register variables as part of the MIBs
d857 13
a869 5
void
init_mib()
{
   register OT ot;
   int i;
d871 2
a872 6
   for (i=0; mib_vars[i].name; i++)
      if (ot=text2obj(mib_vars[i].name)) {
         ot->ot_getfnx = mib_vars[i].function;
         ot->ot_info = (caddr_t)mib_vars[i].info;
      }
}
d874 25
a898 8
/*
 * Initialize the SNMP part of mrouted
 */
void
snmp_init()
{
    OT ot;
    int i;
d900 2
a901 11
    if (readobjects("mrouted.defs") == NOTOK)
       log(LOG_ERR, 0, "readobjects: %s", PY_pepy);
    for (i=0; i < NUMMIBS; i++) {
       if ((ot = text2obj(mibs[i])) == NULL)
          log(LOG_ERR, 0, "object \"%s\" not in \"%s\"",
		  mibs[i], "mrouted.defs");
       subtree[i] = ot -> ot_name;
    }
    init_mib();
    try_smux_init();
}
d903 5
a907 47
/*
 * Process an SNMP "get" or "get-next" request
 */
static  
get_smux (pdu, offset)
   register struct type_SNMP_GetRequest__PDU *pdu;
   int     offset;
{
    int     idx,
            status;
    object_instance ois;
    register struct type_SNMP_VarBindList *vp;
    IFP method;

    quantum = pdu -> request__id;
    idx = 0;
    for (vp = pdu -> variable__bindings; vp; vp = vp -> next) {
        register OI     oi;
        register OT     ot;
        register struct type_SNMP_VarBind *v = vp -> VarBind;

        idx++;

        if (offset == type_SNMP_SMUX__PDUs_get__next__request) {
            if ((oi = name2inst (v -> name)) == NULLOI
                    && (oi = next2inst (v -> name)) == NULLOI)
                goto no_name;

            if ((ot = oi -> oi_type) -> ot_getfnx == NULLIFP)
                goto get_next;
        }
        else
            if ((oi = name2inst (v -> name)) == NULLOI
                    || (ot = oi -> oi_type) -> ot_getfnx
                            == NULLIFP) {
no_name: ;
                pdu -> error__status =
                        int_SNMP_error__status_noSuchName;
                goto out;
            }

try_again: ;
   switch (offset) {
       case type_SNMP_SMUX__PDUs_get__request:
      if (!(method = ot -> ot_getfnx))
          goto no_name;
      break;
d909 2
a910 4
       case type_SNMP_SMUX__PDUs_get__next__request:
    if (!(method = ot -> ot_getfnx))
          goto get_next;
      break;
d912 3
a914 83
       case type_SNMP_SMUX__PDUs_set__request:
      if (!(method = ot -> ot_setfnx))
          goto no_name;
      break;

       default:
      goto no_name;
   }

        switch (status = (*ot -> ot_getfnx) (oi, v, offset)) {
            case NOTOK:     /* get-next wants a bump */
get_next: ;
                oi = &ois;
                for (;;) {
                    if ((ot = ot -> ot_next) == NULLOT) {
                        pdu -> error__status =
                              int_SNMP_error__status_noSuchName;
                        goto out;
                    }
                    oi -> oi_name =
                                (oi -> oi_type = ot) -> ot_name;
                    if (ot -> ot_getfnx)
                        goto try_again;
                }

            case int_SNMP_error__status_noError:
                break;

            default:
                pdu -> error__status = status;
                goto out;
        }
    }
    idx = 0;

out: ;
    pdu -> error__index = idx;

    if (smux_response (pdu) == NOTOK) {
        log(LOG_WARNING,0,"smux_response: %s [%s]",
               smux_error (smux_errno), smux_info);
        smux_fd = NOTOK;
    }
}

/*
 * Handle SNMP "set" request by replying that it is illegal
 */
static  
set_smux(event)
   struct type_SNMP_SMUX__PDUs *event;
{
    switch (event -> offset) {
        case type_SNMP_SMUX__PDUs_set__request:
            {
                register struct type_SNMP_GetResponse__PDU *pdu =
                                    event -> un.get__response;

                pdu -> error__status = int_SNMP_error__status_noSuchName;
                pdu -> error__index = pdu -> variable__bindings ? 1 : 0;

                if (smux_response (pdu) == NOTOK) {
                    log(LOG_WARNING, 0,
                            "smux_response: %s [%s]",
                            smux_error (smux_errno),
                            smux_info);
                    smux_fd = NOTOK;
                }
            }
            break;

        case type_SNMP_SMUX__PDUs_commitOrRollback:
            {
                struct type_SNMP_SOutPDU *cor =
                                event -> un.commitOrRollback;

                if (cor -> parm == int_SNMP_SOutPDU_commit) {
                                    /* "should not happen" */
                    (void) smux_close (protocolError);
                    smux_fd = NOTOK;
                }
            }
            break;
a915 54
}

/* 
 *  Handle an incoming SNMP message
 */
void
doit_smux()
{
   struct type_SNMP_SMUX__PDUs *event;
 
   if (smux_wait(&event, NOTOK)==NOTOK) {
      if (smux_errno==inProgress)
         return;
      log(LOG_WARNING, 0, "smux_wait: %s [%s]", smux_error(smux_errno), 
       smux_info);
      smux_fd = NOTOK;
      return;
   }

   switch (event -> offset) {
    case type_SNMP_SMUX__PDUs_registerResponse:
        {
            struct type_SNMP_RRspPDU *rsp =
                        event -> un.registerResponse;

            if (rsp -> parm == int_SNMP_RRspPDU_failure) {
                log(LOG_WARNING,0,"SMUX registration of subtree failed");
                dont_bother_anymore = 1;
                (void) smux_close (goingDown);
                break;
            }
        }
        if (smux_trap(NULLOID, int_SNMP_generic__trap_coldStart, 0,
                       (struct type_SNMP_VarBindList *)0) == NOTOK) {
            log(LOG_WARNING,0,"smux_trap: %s [%s]", smux_error (smux_errno), 
             smux_info);
            break;
        }
        return;

    case type_SNMP_SMUX__PDUs_get__request:
    case type_SNMP_SMUX__PDUs_get__next__request:
        get_smux (event -> un.get__request, event -> offset);
        return;

    case type_SNMP_SMUX__PDUs_close:
        log(LOG_WARNING, 0, "SMUX close: %s", 
         smux_error (event -> un.close -> parm));
        break;

    case type_SNMP_SMUX__PDUs_set__request:
    case type_SNMP_SMUX__PDUs_commitOrRollback:
        set_smux (event);
        return;
d917 5
a921 7
    default:
        log(LOG_WARNING,0,"bad SMUX operation: %d", event -> offset);
        (void) smux_close (protocolError);
        break;
   }
   smux_fd = NOTOK;
}
d923 1
a923 108
/* 
 * Inform snmpd that we are here and handling our MIBs
 */
void
start_smux()
{
   int i;

   for (i=0; i<NUMMIBS; i++) {
      if ((se = getsmuxEntrybyname (mibs[i])) == NULL) {
         log(LOG_WARNING,0,"no SMUX entry for \"%s\"", mibs[i]);
         return;
      }
 
      /* Only open a new connection the first time through */
      if (!i) {
         if (smux_simple_open(&se->se_identity, mibs[i], 
          se->se_password, strlen(se->se_password))==NOTOK) {
            if (smux_errno == inProgress)
               return;

            log(LOG_WARNING, 0,"smux_simple_open: %s [%s]", 
             smux_error(smux_errno), smux_info);
            smux_fd = NOTOK;
            return;
         }
         log(LOG_NOTICE,0, "SMUX open: %s \"%s\"",
          oid2ode (&se->se_identity), se->se_name);
         rock_and_roll = 1;
      }

      if (smux_register(subtree[i], -1, readWrite)==NOTOK) {
         log(LOG_WARNING, 0,"smux_register: %s [%s]", smux_error(smux_errno), 
          smux_info);
         smux_fd = NOTOK;
         return;
      }
   }
   log(LOG_NOTICE, 0, "SMUX registered");
}

/*
 * Implements the DVMRP Route Table portion of the DVMRP MIB 
 */
int
o_dvmrpRouteTable (oi, v, offset)
OI oi;
register struct type_SNMP_VarBind *v;
int	offset;
{
    u_long   src, mask;
    int	    ifvar;
    register OID    oid = oi -> oi_name;
    register OT	    ot = oi -> oi_type;
    struct rtentry *rt = NULL;

    ifvar = (int) ot -> ot_info;
    switch (offset) {
	case type_SNMP_SMUX__PDUs_get__request:
      if (!get_address(oid, &src, ot->ot_name->oid_nelem)
       || !get_address(oid, &mask, ot->ot_name->oid_nelem+4)
       || !(rt = snmp_find_route(src,mask)))
         return int_SNMP_error__status_noSuchName;
      break;

	case type_SNMP_SMUX__PDUs_get__next__request:

       /* Check if we're requesting the first row */
      if (oid->oid_nelem < ot->ot_name->oid_nelem+8) {
         OID	new;

         /* Get partial specification (if any) */
         get_address(oid, &src, ot->ot_name->oid_nelem);
         get_address(oid, &mask, ot->ot_name->oid_nelem+4);

         if (!next_route(&rt,src,mask)) /* Get first entry */
            return NOTOK;

         /* Extend by 8 more ints to hold index columns */
         new = oid_extend (oid, ot->ot_name->oid_nelem+8-oid->oid_nelem);
         if (new == NULLOID)
            return NOTOK;

         put_address(new, rt->rt_origin,     ot->ot_name->oid_nelem);
         put_address(new, rt->rt_originmask, ot->ot_name->oid_nelem+4); 

         if (v -> name)
            free_SNMP_ObjectName (v -> name);
         v -> name = new;

      /* Else we start from a previous row */
      } else {
         int	i = ot -> ot_name -> oid_nelem;

         /* Get the lowest entry in the table > the given grp/src/mask */
         get_address(oid, &src, ot->ot_name->oid_nelem);
         get_address(oid, &mask, ot->ot_name->oid_nelem+4);
         if (!next_route(&rt, src,mask))
            return NOTOK; 

         put_address(oid, rt->rt_origin, ot->ot_name->oid_nelem);
         put_address(oid, rt->rt_originmask, ot->ot_name->oid_nelem+4);
      }
      break;

	default:
	   return int_SNMP_error__status_genErr;
   }
d925 2
a926 6
   switch (ifvar) {
      case dvmrpRouteUpstreamNeighbor: {
         struct sockaddr_in tmp;
         tmp.sin_addr.s_addr = rt->rt_gateway;
         return o_ipaddr (oi, v, &tmp);
      }
d929 2
a930 1
         return o_integer (oi, v, rt->rt_parent);
d933 2
a934 1
         return o_integer (oi, v, rt->rt_metric);
d937 3
a939 1
         return o_integer (oi, v, rt->rt_timer*100);
d941 4
a944 3
      default:
         return int_SNMP_error__status_noSuchName;
   }
d947 2
a948 2
/* 
 * Implements the DVMRP Routing Next Hop Table portion of the DVMRP MIB 
d950 8
a957 5
int
o_dvmrpRouteNextHopTable (oi, v, offset)
OI oi;
register struct type_SNMP_VarBind *v;
int   offset;
d959 2
a960 5
    u_long   src, mask;
    vifi_t   vifi;
    int	    ifvar;
    register OID    oid = oi -> oi_name;
    register OT	    ot = oi -> oi_type;
d962 5
d968 3
a970 5
    ifvar = (int) ot -> ot_info;
    switch (offset) {
	case type_SNMP_SMUX__PDUs_get__request:
      if (oid->oid_nelem != ot->ot_name->oid_nelem+9)
         return int_SNMP_error__status_noSuchName;
d972 2
a973 2
      if (!get_address(oid, &src, ot->ot_name->oid_nelem)
       || !get_address(oid, &mask, ot->ot_name->oid_nelem+4)
d975 1
a975 1
         return int_SNMP_error__status_noSuchName;
d977 1
a977 1
      vifi = oid->oid_elements[ot->ot_name->oid_nelem+8];
d979 1
a979 2
         return int_SNMP_error__status_noSuchName;
      break;
d981 5
a985 1
	case type_SNMP_SMUX__PDUs_get__next__request:
d987 1
a987 3
      /* Check if we're requesting the first row */
      if (oid->oid_nelem < ot->ot_name->oid_nelem+9) {
         OID	new;
d989 2
a990 2
         get_address(oid, &src, ot->ot_name->oid_nelem);
         get_address(oid, &mask, ot->ot_name->oid_nelem+4);
d995 1
a995 1
            return NOTOK;
d997 7
a1003 21
         /* Extend by 9 more ints to hold index columns */
         new = oid_extend (oid, ot->ot_name->oid_nelem+9-oid->oid_nelem);
         if (new == NULLOID)
            return NOTOK;

         put_address(new, rt->rt_origin, ot->ot_name->oid_nelem);
         put_address(new, rt->rt_originmask, ot->ot_name->oid_nelem+4);
         new->oid_elements[ot->ot_name->oid_nelem+8] = vifi;

         if (v -> name)
            free_SNMP_ObjectName (v -> name);
         v -> name = new;

      /* Else we start from a previous row */
      } else {
         int	i = ot -> ot_name -> oid_nelem;

         /* Get the lowest entry in the table > the given grp/src/mask */
         vifi = oid->oid_elements[oid->oid_nelem-1] + 1;
         if (!get_address(oid, &src, ot->ot_name->oid_nelem)
          || !get_address(oid, &mask, ot->ot_name->oid_nelem+4)
d1005 1
a1005 1
            return NOTOK;
d1007 5
a1011 5
         put_address(oid, rt->rt_origin, ot->ot_name->oid_nelem);
         put_address(oid, rt->rt_originmask, ot->ot_name->oid_nelem+4);
         oid->oid_elements[ot->ot_name->oid_nelem+8] = vifi;
      }
      break;
d1013 11
a1023 3
	default:
	   return int_SNMP_error__status_genErr;
   }
d1025 4
a1028 8
   switch (ifvar) {

      case dvmrpRouteNextHopType:
         return o_integer (oi, v, (VIFM_ISSET(vifi, rt->rt_leaves))? 1 : 2);

      default:
         return int_SNMP_error__status_noSuchName;
   }
d1031 2
a1032 2
/* 
 * Implements the IP Multicast Route Table portion of the Multicast MIB 
d1034 8
a1041 5
int  
o_ipMRouteTable (oi, v, offset)
OI	oi;
register struct type_SNMP_VarBind *v;
int	offset;
a1043 3
    int	    ifvar;
    register OID    oid = oi -> oi_name;
    register OT	    ot = oi -> oi_type;
d1047 2
d1050 10
a1059 6
    ifvar = (int) ot -> ot_info;
    switch (offset) {
	case type_SNMP_SMUX__PDUs_get__request:
      if (!get_address(oid, &grp, ot->ot_name->oid_nelem)
       || !get_address(oid, &src, ot->ot_name->oid_nelem+4)
       || !get_address(oid, &mask, ot->ot_name->oid_nelem+8)
d1063 1
a1063 2
         return int_SNMP_error__status_noSuchName;
      break;
d1065 11
a1075 1
	case type_SNMP_SMUX__PDUs_get__next__request:
d1077 2
a1078 8
       /* Check if we're requesting the first row */
      if (oid->oid_nelem < ot->ot_name->oid_nelem+12) {
         OID	new;

         /* Get partial specification (if any) */
         get_address(oid, &grp, ot->ot_name->oid_nelem);
         get_address(oid, &src, ot->ot_name->oid_nelem+4);
         get_address(oid, &mask, ot->ot_name->oid_nelem+8);
d1080 7
a1086 2
         if (!next_grp_src_mask(&gt,&st,grp,src,mask)) /* Get first entry */
            return NOTOK;
a1087 21
         /* Extend by 12 more ints to hold index columns */
         new = oid_extend (oid, ot->ot_name->oid_nelem+12-oid->oid_nelem);
         if (new == NULLOID)
            return NOTOK;

         put_address(new, gt->gt_mcastgrp, ot->ot_name->oid_nelem);
         put_address(new, st->st_origin, ot->ot_name->oid_nelem+4);
         put_address(new, 0xFFFFFFFF, ot->ot_name->oid_nelem+8); 

         if (v -> name)
            free_SNMP_ObjectName (v -> name);
         v -> name = new;

      /* Else we start from a previous row */
      } else {
         int	i = ot -> ot_name -> oid_nelem;

         /* Get the lowest entry in the table > the given grp/src/mask */
         get_address(oid, &grp, ot->ot_name->oid_nelem);
         get_address(oid, &src, ot->ot_name->oid_nelem+4);
         get_address(oid, &mask, ot->ot_name->oid_nelem+8);
d1089 7
a1095 1
            return NOTOK; 
d1097 5
a1101 5
         put_address(oid, gt->gt_mcastgrp, ot->ot_name->oid_nelem);
         put_address(oid, st->st_origin, ot->ot_name->oid_nelem+4);
         put_address(oid, 0xFFFFFFFF, ot->ot_name->oid_nelem+8);
      }
      break;
d1103 1
a1103 3
	default:
	   return int_SNMP_error__status_genErr;
   }
d1105 2
a1106 6
   switch (ifvar) {
      case ipMRouteUpstreamNeighbor: {
         struct sockaddr_in tmp;
         tmp.sin_addr.s_addr = gt->gt_route->rt_gateway;
         return o_ipaddr (oi, v, &tmp);
      }
d1109 2
a1110 1
         return o_integer (oi, v, gt->gt_route->rt_parent);
d1115 2
a1116 1
         return o_integer (oi, v, (currtime - gt->gt_ctime)*100);
d1120 3
a1122 1
         return o_integer (oi, v, gt->gt_timer*100);
d1126 3
a1128 2
         return o_integer (oi, v, sg_req.pktcnt);
    
d1131 2
a1132 1
         return o_integer (oi, v, sg_req.bytecnt);
d1136 2
a1137 1
         return o_integer (oi, v, sg_req.wrong_if);
d1140 2
a1141 1
         return o_integer (oi, v, 4);
d1143 4
a1146 3
      default:
         return int_SNMP_error__status_noSuchName;
   }
d1149 1
a1149 1
/* 
d1151 1
a1151 1
 * MIB 
d1153 8
a1160 5
int  
o_ipMRouteNextHopTable (oi, v, offset)
OI	oi;
register struct type_SNMP_VarBind *v;
int	offset;
a1163 3
    int	    ifvar;
    register OID    oid = oi -> oi_name;
    register OT	    ot = oi -> oi_type;
d1166 2
d1169 11
a1179 10
    ifvar = (int) ot -> ot_info;
    switch (offset) {
	case type_SNMP_SMUX__PDUs_get__request:
      if (oid->oid_nelem != ot->ot_name->oid_nelem+17)
         return int_SNMP_error__status_noSuchName;

      if (!get_address(oid, &grp, ot->ot_name->oid_nelem)
       || !get_address(oid, &src, ot->ot_name->oid_nelem+4)
       || !get_address(oid, &mask, ot->ot_name->oid_nelem+8)
       || !get_address(oid, &addr, ot->ot_name->oid_nelem+13)
d1184 1
a1184 1
         return int_SNMP_error__status_noSuchName;
d1186 1
a1186 1
      vifi = oid->oid_elements[ot->ot_name->oid_nelem+12];
d1188 1
a1188 2
         return int_SNMP_error__status_noSuchName;
      break;
d1190 11
a1200 9
	case type_SNMP_SMUX__PDUs_get__next__request:

      /* Check if we're requesting the first row */
      if (oid->oid_nelem < ot->ot_name->oid_nelem+17) {
         OID	new;

         get_address(oid, &grp, ot->ot_name->oid_nelem);
         get_address(oid, &src, ot->ot_name->oid_nelem+4);
         get_address(oid, &mask, ot->ot_name->oid_nelem+8);
d1205 7
a1211 1
            return NOTOK;
d1213 5
a1217 24
         /* Extend by 17 more ints to hold index columns */
         new = oid_extend (oid, ot->ot_name->oid_nelem+17-oid->oid_nelem);
         if (new == NULLOID)
            return NOTOK;

         put_address(new, gt->gt_mcastgrp, ot->ot_name->oid_nelem);
         put_address(new, st->st_origin, ot->ot_name->oid_nelem+4);
         put_address(new, 0xFFFFFFFF, ot->ot_name->oid_nelem+8);
         new->oid_elements[ot->ot_name->oid_nelem+12] = vifi;
         put_address(new, gt->gt_mcastgrp, ot->ot_name->oid_nelem+13);

         if (v -> name)
            free_SNMP_ObjectName (v -> name);
         v -> name = new;

      /* Else we start from a previous row */
      } else {
         int	i = ot -> ot_name -> oid_nelem;

         /* Get the lowest entry in the table > the given grp/src/mask */
         vifi = oid->oid_elements[oid->oid_nelem-1] + 1;
         if (!get_address(oid, &grp, ot->ot_name->oid_nelem)
          || !get_address(oid, &src, ot->ot_name->oid_nelem+4)
          || !get_address(oid, &mask, ot->ot_name->oid_nelem+8)
d1219 1
a1219 1
            return NOTOK;
d1221 7
a1227 7
         put_address(oid, gt->gt_mcastgrp, ot->ot_name->oid_nelem);
         put_address(oid, st->st_origin, ot->ot_name->oid_nelem+4);
         put_address(oid, 0xFFFFFFFF, ot->ot_name->oid_nelem+8);
         oid->oid_elements[ot->ot_name->oid_nelem+12] = vifi;
         put_address(oid, gt->gt_mcastgrp, ot->ot_name->oid_nelem+13);
      }
      break;
d1229 5
a1233 3
	default:
	   return int_SNMP_error__status_genErr;
   }
d1235 1
a1235 1
   switch (ifvar) {
d1238 2
a1239 1
         return o_integer (oi, v, (VIFM_ISSET(vifi, gt->gt_grpmems))? 2 : 1);
d1245 2
a1246 1
         return o_integer (oi, v, (currtime - gt->gt_ctime)*100);
d1250 3
a1252 1
         return o_integer (oi, v, gt->gt_prsent_timer);
d1255 2
a1256 1
         return o_integer (oi, v, 0);
d1259 25
a1283 1
         return o_integer (oi, v, 4);
d1285 2
a1286 3
      default:
         return int_SNMP_error__status_noSuchName;
   }
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
