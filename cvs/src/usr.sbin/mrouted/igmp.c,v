head	1.13;
access;
symbols
	OPENBSD_6_1_BASE:1.13
	OPENBSD_6_0:1.13.0.8
	OPENBSD_6_0_BASE:1.13
	OPENBSD_5_9:1.13.0.4
	OPENBSD_5_9_BASE:1.13
	OPENBSD_5_8:1.13.0.6
	OPENBSD_5_8_BASE:1.13
	OPENBSD_5_7:1.13.0.2
	OPENBSD_5_7_BASE:1.13
	OPENBSD_5_6:1.12.0.8
	OPENBSD_5_6_BASE:1.12
	OPENBSD_5_5:1.12.0.6
	OPENBSD_5_5_BASE:1.12
	OPENBSD_5_4:1.12.0.2
	OPENBSD_5_4_BASE:1.12
	OPENBSD_5_3:1.11.0.10
	OPENBSD_5_3_BASE:1.11
	OPENBSD_5_2:1.11.0.8
	OPENBSD_5_2_BASE:1.11
	OPENBSD_5_1_BASE:1.11
	OPENBSD_5_1:1.11.0.6
	OPENBSD_5_0:1.11.0.4
	OPENBSD_5_0_BASE:1.11
	OPENBSD_4_9:1.11.0.2
	OPENBSD_4_9_BASE:1.11
	OPENBSD_4_8:1.10.0.28
	OPENBSD_4_8_BASE:1.10
	OPENBSD_4_7:1.10.0.24
	OPENBSD_4_7_BASE:1.10
	OPENBSD_4_6:1.10.0.26
	OPENBSD_4_6_BASE:1.10
	OPENBSD_4_5:1.10.0.22
	OPENBSD_4_5_BASE:1.10
	OPENBSD_4_4:1.10.0.20
	OPENBSD_4_4_BASE:1.10
	OPENBSD_4_3:1.10.0.18
	OPENBSD_4_3_BASE:1.10
	OPENBSD_4_2:1.10.0.16
	OPENBSD_4_2_BASE:1.10
	OPENBSD_4_1:1.10.0.14
	OPENBSD_4_1_BASE:1.10
	OPENBSD_4_0:1.10.0.12
	OPENBSD_4_0_BASE:1.10
	OPENBSD_3_9:1.10.0.10
	OPENBSD_3_9_BASE:1.10
	OPENBSD_3_8:1.10.0.8
	OPENBSD_3_8_BASE:1.10
	OPENBSD_3_7:1.10.0.6
	OPENBSD_3_7_BASE:1.10
	OPENBSD_3_6:1.10.0.4
	OPENBSD_3_6_BASE:1.10
	OPENBSD_3_5:1.10.0.2
	OPENBSD_3_5_BASE:1.10
	OPENBSD_3_4:1.8.0.4
	OPENBSD_3_4_BASE:1.8
	OPENBSD_3_3:1.8.0.2
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.6.0.2
	OPENBSD_3_2_BASE:1.6
	OPENBSD_3_1:1.5.0.2
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.3.0.20
	OPENBSD_3_0_BASE:1.3
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_9:1.3.0.18
	OPENBSD_2_8:1.3.0.16
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.14
	OPENBSD_2_7_BASE:1.3
	OPENBSD_2_6:1.3.0.12
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.10
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.8
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.6
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.4
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.3.0.2
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.13
date	2015.01.16.06.40.18;	author deraadt;	state Exp;
branches;
next	1.12;
commitid	Uu5nFG3wCl0LACBb;

1.12
date	2013.04.21.06.42.43;	author tedu;	state Exp;
branches;
next	1.11;

1.11
date	2010.11.05.10.30.33;	author jasper;	state Exp;
branches;
next	1.10;

1.10
date	2004.01.16.03.57.28;	author itojun;	state Exp;
branches;
next	1.9;

1.9
date	2003.11.26.01.17.12;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2003.03.03.15.14.28;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2003.03.03.14.58.23;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2002.08.01.03.45.53;	author itojun;	state Exp;
branches;
next	1.5;

1.5
date	2002.02.16.21.28.05;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2001.12.10.20.30.46;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	97.01.30.22.43.17;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.12.14.01.45.23;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.47.46;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.47.46;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.13
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@/*	$NetBSD: igmp.c,v 1.5 1995/12/10 10:07:01 mycroft Exp $	*/

/*
 * The mrouted program is covered by the license in the accompanying file
 * named "LICENSE".  Use of the mrouted program represents acceptance of
 * the terms and conditions listed in that file.
 *
 * The mrouted program is COPYRIGHT 1989 by The Board of Trustees of
 * Leland Stanford Junior University.
 */


#include "defs.h"


/*
 * Exported variables.
 */
char		*recv_buf;		     /* input packet buffer         */
char		*send_buf;		     /* output packet buffer        */
int		igmp_socket;		     /* socket for all network I/O  */
u_int32_t	allhosts_group;		     /* All hosts addr in net order */
u_int32_t	allrtrs_group;		     /* All-Routers "  in net order */
u_int32_t	dvmrp_group;		     /* DVMRP grp addr in net order */
u_int32_t	dvmrp_genid;		     /* IGMP generation id          */

/*
 * Local function definitions.
 */
/* u_char promoted to u_int */
static char *	packet_kind(u_int type, u_int code);
static int	igmp_log_level(u_int type, u_int code);

/*
 * Open and initialize the igmp socket, and fill in the non-changing
 * IP header fields in the output packet buffer.
 */
void
init_igmp(void)
{
    struct ip *ip;

    recv_buf = malloc(RECV_BUF_SIZE);
    send_buf = malloc(RECV_BUF_SIZE);

    if ((igmp_socket = socket(AF_INET, SOCK_RAW, IPPROTO_IGMP)) < 0)
	logit(LOG_ERR, errno, "IGMP socket");

    k_hdr_include(TRUE);	/* include IP header when sending */
    k_set_rcvbuf(48*1024);	/* lots of input buffering        */
    k_set_ttl(1);		/* restrict multicasts to one hop */
    k_set_loop(FALSE);		/* disable multicast loopback     */

    ip         = (struct ip *)send_buf;
    ip->ip_hl  = sizeof(struct ip) >> 2;
    ip->ip_v   = IPVERSION;
    ip->ip_tos = 0;
    ip->ip_off = htons(0);
    ip->ip_p   = IPPROTO_IGMP;
    ip->ip_ttl = MAXTTL;	/* applies to unicasts only */

    allhosts_group = htonl(INADDR_ALLHOSTS_GROUP);
    dvmrp_group    = htonl(INADDR_DVMRP_GROUP);
    allrtrs_group  = htonl(INADDR_ALLRTRS_GROUP);
}

#define PIM_QUERY        0
#define PIM_REGISTER     1
#define PIM_REGISTER_STOP	2
#define PIM_JOIN_PRUNE   3
#define PIM_RP_REACHABLE 4
#define PIM_ASSERT       5
#define PIM_GRAFT        6
#define PIM_GRAFT_ACK    7

static char *
packet_kind(u_int type, u_int code)
{
    switch (type) {
	case IGMP_HOST_MEMBERSHIP_QUERY:	return "membership query  ";
	case IGMP_v1_HOST_MEMBERSHIP_REPORT:	return "v1 member report  ";
	case IGMP_v2_HOST_MEMBERSHIP_REPORT:	return "v2 member report  ";
	case IGMP_HOST_LEAVE_MESSAGE:           return "leave message     ";
	case IGMP_DVMRP:
	  switch (code) {
	    case DVMRP_PROBE:			return "neighbor probe    ";
	    case DVMRP_REPORT:			return "route report      ";
	    case DVMRP_ASK_NEIGHBORS:		return "neighbor request  ";
	    case DVMRP_NEIGHBORS:		return "neighbor list     ";
	    case DVMRP_ASK_NEIGHBORS2:		return "neighbor request 2";
	    case DVMRP_NEIGHBORS2:		return "neighbor list 2   ";
	    case DVMRP_PRUNE:			return "prune message     ";
	    case DVMRP_GRAFT:			return "graft message     ";
	    case DVMRP_GRAFT_ACK:		return "graft message ack ";
	    case DVMRP_INFO_REQUEST:		return "info request      ";
	    case DVMRP_INFO_REPLY:		return "info reply        ";
	    default:				return "unknown DVMRP msg ";
	  }
	case IGMP_PIM:
	  switch (code) {
	    case PIM_QUERY:			return "PIM Router-Query  ";
	    case PIM_REGISTER:			return "PIM Register      ";
	    case PIM_REGISTER_STOP:		return "PIM Register-Stop ";
	    case PIM_JOIN_PRUNE:		return "PIM Join/Prune    ";
	    case PIM_RP_REACHABLE:		return "PIM RP-Reachable  ";
	    case PIM_ASSERT:			return "PIM Assert        ";
	    case PIM_GRAFT:			return "PIM Graft         ";
	    case PIM_GRAFT_ACK:			return "PIM Graft-Ack     ";
	    default:				return "unknown PIM msg   ";
	  }
	case IGMP_MTRACE_QUERY:			return "IGMP trace query  ";
	case IGMP_MTRACE_REPLY:			return "IGMP trace reply  ";
	default:				return "unknown IGMP msg  ";
    }
}

/*
 * Process a newly received IGMP packet that is sitting in the input
 * packet buffer.
 */
void
accept_igmp(int recvlen)
{
    u_int32_t src, dst, group;
    struct ip *ip;
    struct igmp *igmp;
    int ipdatalen, iphdrlen, igmpdatalen;

    if (recvlen < sizeof(struct ip)) {
	logit(LOG_WARNING, 0,
	    "received packet too short (%u bytes) for IP header", recvlen);
	return;
    }

    ip        = (struct ip *)recv_buf;
    src       = ip->ip_src.s_addr;
    dst       = ip->ip_dst.s_addr;

    /*
     * this is most likely a message from the kernel indicating that
     * a new src grp pair message has arrived and so, it would be
     * necessary to install a route into the kernel for this.
     */
    if (ip->ip_p == 0) {
	if (src == 0 || dst == 0)
	    logit(LOG_WARNING, 0, "kernel request not accurate");
	else
	    add_table_entry(src, dst);
	return;
    }

    iphdrlen  = ip->ip_hl << 2;
    ipdatalen = ntohs(ip->ip_len) - iphdrlen;
    if (iphdrlen + ipdatalen != recvlen) {
	logit(LOG_WARNING, 0,
	    "received packet from %s shorter (%u bytes) than hdr+data length (%u+%u)",
	    inet_fmt(src, s1), recvlen, iphdrlen, ipdatalen);
	return;
    }

    igmp        = (struct igmp *)(recv_buf + iphdrlen);
    group       = igmp->igmp_group.s_addr;
    igmpdatalen = ipdatalen - IGMP_MINLEN;
    if (igmpdatalen < 0) {
	logit(LOG_WARNING, 0,
	    "received IP data field too short (%u bytes) for IGMP, from %s",
	    ipdatalen, inet_fmt(src, s1));
	return;
    }

    logit(LOG_DEBUG, 0, "RECV %s from %-15s to %s",
	packet_kind(igmp->igmp_type, igmp->igmp_code),
	inet_fmt(src, s1), inet_fmt(dst, s2));

    switch (igmp->igmp_type) {

	case IGMP_HOST_MEMBERSHIP_QUERY:
	    accept_membership_query(src, dst, group, igmp->igmp_code);
	    return;

	case IGMP_v1_HOST_MEMBERSHIP_REPORT:
	case IGMP_v2_HOST_MEMBERSHIP_REPORT:
	    accept_group_report(src, dst, group, igmp->igmp_type);
	    return;

	case IGMP_HOST_LEAVE_MESSAGE:
	    accept_leave_message(src, dst, group);
	    return;

	case IGMP_DVMRP:
	    group = ntohl(group);

	    switch (igmp->igmp_code) {
		case DVMRP_PROBE:
		    accept_probe(src, dst,
				 (char *)(igmp+1), igmpdatalen, group);
		    return;

		case DVMRP_REPORT:
		    accept_report(src, dst,
				  (char *)(igmp+1), igmpdatalen, group);
		    return;

		case DVMRP_ASK_NEIGHBORS:
		    accept_neighbor_request(src, dst);
		    return;

		case DVMRP_ASK_NEIGHBORS2:
		    accept_neighbor_request2(src, dst);
		    return;

		case DVMRP_NEIGHBORS:
		    accept_neighbors(src, dst, (u_char *)(igmp+1), igmpdatalen,
					     group);
		    return;

		case DVMRP_NEIGHBORS2:
		    accept_neighbors2(src, dst, (u_char *)(igmp+1), igmpdatalen,
					     group);
		    return;

		case DVMRP_PRUNE:
		    accept_prune(src, dst, (char *)(igmp+1), igmpdatalen);
		    return;

		case DVMRP_GRAFT:
		    accept_graft(src, dst, (char *)(igmp+1), igmpdatalen);
		    return;

		case DVMRP_GRAFT_ACK:
		    accept_g_ack(src, dst, (char *)(igmp+1), igmpdatalen);
		    return;

		case DVMRP_INFO_REQUEST:
		    accept_info_request(src, dst, (char *)(igmp+1),
				igmpdatalen);
		    return;

		case DVMRP_INFO_REPLY:
		    accept_info_reply(src, dst, (char *)(igmp+1), igmpdatalen);
		    return;

		default:
		    logit(LOG_INFO, 0,
		     "ignoring unknown DVMRP message code %u from %s to %s",
		     igmp->igmp_code, inet_fmt(src, s1),
		     inet_fmt(dst, s2));
		    return;
	    }

	case IGMP_PIM:
	    return;

	case IGMP_MTRACE_REPLY:
	    return;

	case IGMP_MTRACE_QUERY:
	    accept_mtrace(src, dst, group, (char *)(igmp+1),
		   igmp->igmp_code, igmpdatalen);
	    return;

	default:
	    logit(LOG_INFO, 0,
		"ignoring unknown IGMP message type %x from %s to %s",
		igmp->igmp_type, inet_fmt(src, s1),
		inet_fmt(dst, s2));
	    return;
    }
}

/*
 * Some IGMP messages are more important than others.  This routine
 * determines the logging level at which to log a send error (often
 * "No route to host").  This is important when there is asymmetric
 * reachability and someone is trying to, i.e., mrinfo me periodically.
 */
static int
igmp_log_level(u_int type, u_int code)
{
    switch (type) {
	case IGMP_MTRACE_REPLY:
	    return LOG_INFO;

	case IGMP_DVMRP:
	  switch (code) {
	    case DVMRP_NEIGHBORS:
	    case DVMRP_NEIGHBORS2:
		return LOG_INFO;
	  }
    }
    return LOG_WARNING;
}

/*
 * Construct an IGMP message in the output packet buffer.  The caller may
 * have already placed data in that buffer, of length 'datalen'.  Then send
 * the message from the interface with IP address 'src' to destination 'dst'.
 */
void
send_igmp(u_int32_t src, u_int32_t dst, int type, int code,
    u_int32_t group, int datalen)
{
    struct sockaddr_in sdst;
    struct ip *ip;
    struct igmp *igmp;
    int setloop = 0;

    ip                      = (struct ip *)send_buf;
    ip->ip_src.s_addr       = src;
    ip->ip_dst.s_addr       = dst;
    ip->ip_len              = htons(MIN_IP_HEADER_LEN + IGMP_MINLEN + datalen);

    igmp                    = (struct igmp *)(send_buf + MIN_IP_HEADER_LEN);
    igmp->igmp_type         = type;
    igmp->igmp_code         = code;
    igmp->igmp_group.s_addr = group;
    igmp->igmp_cksum        = 0;
    igmp->igmp_cksum        = inet_cksum((u_int16_t *)igmp,
					 IGMP_MINLEN + datalen);

    if (IN_MULTICAST(ntohl(dst))) {
	k_set_if(src);
	if (type != IGMP_DVMRP) {
	    setloop = 1;
	    k_set_loop(TRUE);
	}
    }

    bzero(&sdst, sizeof(sdst));
    sdst.sin_family = AF_INET;
    sdst.sin_len = sizeof(sdst);
    sdst.sin_addr.s_addr = dst;
    if (sendto(igmp_socket, send_buf, ntohs(ip->ip_len), 0,
			(struct sockaddr *)&sdst, sizeof(sdst)) < 0) {
	if (errno == ENETDOWN)
	    check_vif_state();
	else
	    logit(igmp_log_level(type, code), errno,
		"sendto to %s on %s",
		inet_fmt(dst, s1), inet_fmt(src, s2));
    }

    if (setloop)
	    k_set_loop(FALSE);

    logit(LOG_DEBUG, 0, "SENT %s from %-15s to %s",
	packet_kind(type, code), inet_fmt(src, s1), inet_fmt(dst, s2));
}
@


1.12
log
@deregister. no binary change.
@
text
@a330 1
#if (defined(BSD) && (BSD >= 199103))
a331 1
#endif
@


1.11
log
@- fix possible use of uninitialized variable.

ok claudio@@
@
text
@d124 1
a124 1
    register u_int32_t src, dst, group;
@


1.10
log
@sync with raw socket API change.  reported by Esben Norby, tested by tedu
@
text
@d306 1
a306 1
    int setloop;
@


1.9
log
@Replace log() with logit() since ISO C reserves log() for the math
library and gcc 3.x will complain.  Replacement name taken from NetBSD.
espie@@ OK.
@
text
@d153 1
a153 1
    ipdatalen = ntohs(ip->ip_len);
@


1.8
log
@spaces
@
text
@d47 1
a47 1
	log(LOG_ERR, errno, "IGMP socket");
d130 1
a130 1
	log(LOG_WARNING, 0,
d146 1
a146 1
	    log(LOG_WARNING, 0, "kernel request not accurate");
d155 1
a155 1
	log(LOG_WARNING, 0,
d165 1
a165 1
	log(LOG_WARNING, 0,
d171 1
a171 1
    log(LOG_DEBUG, 0, "RECV %s from %-15s to %s",
d244 1
a244 1
		    log(LOG_INFO, 0,
d263 1
a263 1
	    log(LOG_INFO, 0,
d340 1
a340 1
	    log(igmp_log_level(type, code), errno,
d348 1
a348 1
    log(LOG_DEBUG, 0, "SENT %s from %-15s to %s",
@


1.7
log
@ansi, from cloder
@
text
@d19 2
a20 2
char		*recv_buf; 		     /* input packet buffer         */
char		*send_buf; 		     /* output packet buffer        */
d46 1
a46 1
    if ((igmp_socket = socket(AF_INET, SOCK_RAW, IPPROTO_IGMP)) < 0) 
d69 1
a69 1
#define PIM_REGISTER_STOP 	2
d86 6
a91 6
	    case DVMRP_PROBE:	    		return "neighbor probe    ";
	    case DVMRP_REPORT:	    		return "route report      ";
	    case DVMRP_ASK_NEIGHBORS:   	return "neighbor request  ";
	    case DVMRP_NEIGHBORS:	    	return "neighbor list     ";
	    case DVMRP_ASK_NEIGHBORS2:   	return "neighbor request 2";
	    case DVMRP_NEIGHBORS2:	    	return "neighbor list 2   ";
d97 13
a109 1
	    default:	    			return "unknown DVMRP msg ";
a110 12
 	case IGMP_PIM:
 	  switch (code) {
 	    case PIM_QUERY:			return "PIM Router-Query  ";
 	    case PIM_REGISTER:			return "PIM Register      ";
 	    case PIM_REGISTER_STOP:		return "PIM Register-Stop ";
 	    case PIM_JOIN_PRUNE:		return "PIM Join/Prune    ";
 	    case PIM_RP_REACHABLE:		return "PIM RP-Reachable  ";
 	    case PIM_ASSERT:			return "PIM Assert        ";
 	    case PIM_GRAFT:			return "PIM Graft         ";
 	    case PIM_GRAFT_ACK:			return "PIM Graft-Ack     ";
 	    default:		    		return "unknown PIM msg   ";
 	  }
d113 1
a113 1
	default:			    	return "unknown IGMP msg  ";
d139 1
a139 1
    /* 
d141 1
a141 1
     * a new src grp pair message has arrived and so, it would be 
d185 1
a185 1
	    
d200 1
a200 1
 		    accept_report(src, dst,
d251 2
a252 2
 	case IGMP_PIM:
 	    return;
@


1.6
log
@u_short cleansing
@
text
@d39 1
a39 1
init_igmp()
d77 1
a77 2
packet_kind(type, code)
     u_int type, code;
d122 1
a122 2
accept_igmp(recvlen)
    int recvlen;
d278 1
a278 2
igmp_log_level(type, code)
    u_int type, code;
d300 2
a301 5
send_igmp(src, dst, type, code, group, datalen)
    u_int32_t src, dst;
    int type, code;
    u_int32_t group;
    int datalen;
@


1.5
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d324 1
a324 1
    igmp->igmp_cksum        = inet_cksum((u_short *)igmp,
@


1.4
log
@follow post-2.1 ip_off & ip_len byte orders
@
text
@d31 2
a32 2
static char *	packet_kind __P((u_int type, u_int code));
static int	igmp_log_level __P((u_int type, u_int code));
@


1.3
log
@deal with IP_HDRINCL option network byte order change; lidl@@va.pubnix.com
@
text
@d155 1
a155 1
    ipdatalen = ip->ip_len;
@


1.2
log
@from netbsd; update to mrouted 3.8
@
text
@d58 1
a58 1
    ip->ip_off = 0;
d317 1
a317 1
    ip->ip_len              = MIN_IP_HEADER_LEN + IGMP_MINLEN + datalen;
d341 1
a341 1
    if (sendto(igmp_socket, send_buf, ip->ip_len, 0,
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: igmp.c,v 1.4 1995/10/09 03:51:40 thorpej Exp $	*/
d28 7
d38 2
a39 1
void init_igmp()
d76 3
a78 2
static char *packet_kind(type, code)
     u_char type, code;
d82 2
a83 2
	case IGMP_v1_HOST_MEMBERSHIP_REPORT:	return "membership report ";
	case IGMP_v2_HOST_MEMBERSHIP_REPORT:	return "new member report ";
d96 2
d122 2
a123 1
void accept_igmp(recvlen)
d158 2
a159 2
	    "received packet shorter (%u bytes) than hdr+data length (%u+%u)",
	    recvlen, iphdrlen, ipdatalen);
d215 1
a215 1
		    accept_neighbors(src, dst, (char *)(igmp+1), igmpdatalen,
d220 1
a220 1
		    accept_neighbors2(src, dst, (char *)(igmp+1), igmpdatalen,
d236 9
d273 23
d309 1
a309 1
    static struct sockaddr_in sdst;
d312 1
d327 7
a333 2
    if (IN_MULTICAST(ntohl(dst))) k_set_if(src);
    if (dst == allhosts_group) k_set_loop(TRUE);
d346 1
a346 1
	    log(LOG_WARNING, errno,
d351 2
a352 1
    if (dst == allhosts_group) k_set_loop(FALSE);
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
