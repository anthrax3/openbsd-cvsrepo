head	1.15;
access;
symbols
	OPENBSD_6_1:1.15.0.2
	OPENBSD_6_1_BASE:1.15
	OPENBSD_6_0:1.14.0.4
	OPENBSD_6_0_BASE:1.14
	OPENBSD_5_9:1.14.0.2
	OPENBSD_5_9_BASE:1.14
	OPENBSD_5_8:1.13.0.6
	OPENBSD_5_8_BASE:1.13
	OPENBSD_5_7:1.13.0.2
	OPENBSD_5_7_BASE:1.13
	OPENBSD_5_6:1.12.0.8
	OPENBSD_5_6_BASE:1.12
	OPENBSD_5_5:1.12.0.6
	OPENBSD_5_5_BASE:1.12
	OPENBSD_5_4:1.12.0.2
	OPENBSD_5_4_BASE:1.12
	OPENBSD_5_3:1.10.0.36
	OPENBSD_5_3_BASE:1.10
	OPENBSD_5_2:1.10.0.34
	OPENBSD_5_2_BASE:1.10
	OPENBSD_5_1_BASE:1.10
	OPENBSD_5_1:1.10.0.32
	OPENBSD_5_0:1.10.0.30
	OPENBSD_5_0_BASE:1.10
	OPENBSD_4_9:1.10.0.28
	OPENBSD_4_9_BASE:1.10
	OPENBSD_4_8:1.10.0.26
	OPENBSD_4_8_BASE:1.10
	OPENBSD_4_7:1.10.0.22
	OPENBSD_4_7_BASE:1.10
	OPENBSD_4_6:1.10.0.24
	OPENBSD_4_6_BASE:1.10
	OPENBSD_4_5:1.10.0.20
	OPENBSD_4_5_BASE:1.10
	OPENBSD_4_4:1.10.0.18
	OPENBSD_4_4_BASE:1.10
	OPENBSD_4_3:1.10.0.16
	OPENBSD_4_3_BASE:1.10
	OPENBSD_4_2:1.10.0.14
	OPENBSD_4_2_BASE:1.10
	OPENBSD_4_1:1.10.0.12
	OPENBSD_4_1_BASE:1.10
	OPENBSD_4_0:1.10.0.10
	OPENBSD_4_0_BASE:1.10
	OPENBSD_3_9:1.10.0.8
	OPENBSD_3_9_BASE:1.10
	OPENBSD_3_8:1.10.0.6
	OPENBSD_3_8_BASE:1.10
	OPENBSD_3_7:1.10.0.4
	OPENBSD_3_7_BASE:1.10
	OPENBSD_3_6:1.10.0.2
	OPENBSD_3_6_BASE:1.10
	OPENBSD_3_5:1.9.0.2
	OPENBSD_3_5_BASE:1.9
	OPENBSD_3_4:1.8.0.4
	OPENBSD_3_4_BASE:1.8
	OPENBSD_3_3:1.8.0.2
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.6.0.4
	OPENBSD_3_2_BASE:1.6
	OPENBSD_3_1:1.6.0.2
	OPENBSD_3_1_BASE:1.6
	OPENBSD_3_0:1.4.0.2
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_9:1.2.0.20
	OPENBSD_2_8:1.2.0.18
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.16
	OPENBSD_2_7_BASE:1.2
	OPENBSD_2_6:1.2.0.14
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.12
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.10
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.8
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.6
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.15
date	2017.01.21.11.32.04;	author guenther;	state Exp;
branches;
next	1.14;
commitid	DpBZlpar7mq0CJFq;

1.14
date	2015.08.21.02.07.32;	author deraadt;	state Exp;
branches;
next	1.13;
commitid	Zx2k82IzYwwZaEz9;

1.13
date	2015.01.16.06.40.18;	author deraadt;	state Exp;
branches;
next	1.12;
commitid	Uu5nFG3wCl0LACBb;

1.12
date	2013.04.21.06.42.43;	author tedu;	state Exp;
branches;
next	1.11;

1.11
date	2013.04.21.00.24.42;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2004.08.01.18.32.19;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2003.11.26.01.17.12;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2003.03.13.09.09.49;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2003.03.03.15.14.28;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2002.02.17.19.42.37;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2002.02.16.21.28.05;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2001.09.04.23.35.59;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2001.06.25.08.42.45;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.12.14.01.45.32;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.47.47;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.47.47;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.15
log
@The POSIX APIs that that sockaddrs all ignore the s*_len field in the
incoming socket, so userspace doesn't need to set it unless it has its
own reasons for tracking the size along with the sockaddr.

ok phessler@@ deraadt@@ florian@@
@
text
@/*	$OpenBSD: rsrr.c,v 1.14 2015/08/21 02:07:32 deraadt Exp $	*/
/*	$NetBSD: rsrr.c,v 1.3 1995/12/10 10:07:14 mycroft Exp $	*/

/*
 * Copyright (c) 1993, 1998-2001.
 * The University of Southern California/Information Sciences Institute.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the project nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/* RSRR code written by Daniel Zappala, USC Information Sciences Institute,
 * April 1995.
 */

/* May 1995 -- Added support for Route Change Notification */

#ifdef RSRR

#include "defs.h"
#include <stddef.h>

/* Taken from prune.c */
/*
 * checks for scoped multicast addresses
 */
#define GET_SCOPE(gt) { \
	int _i; \
	if (((gt)->gt_mcastgrp & 0xff000000) == 0xef000000) \
	    for (_i = 0; _i < numvifs; _i++) \
		if (scoped_addr(_i, (gt)->gt_mcastgrp)) \
		    VIFM_SET(_i, (gt)->gt_scope); \
	}

/*
 * Exported variables.
 */
int rsrr_socket;			/* interface to reservation protocol */

/*
 * Global RSRR variables.
 */
char rsrr_recv_buf[RSRR_MAX_LEN];	/* RSRR receive buffer */
char rsrr_send_buf[RSRR_MAX_LEN];	/* RSRR send buffer */

struct sockaddr_un client_addr;
int client_length = sizeof(client_addr);


/*
 * Procedure definitions needed internally.
 */
static void	rsrr_accept(int recvlen);
static void	rsrr_accept_iq(void);
static int	rsrr_accept_rq(struct rsrr_rq *route_query, int flags,
		    struct gtable *gt_notify);
static int	rsrr_send(int sendlen);
static void	rsrr_cache(struct gtable *gt, struct rsrr_rq *route_query);

/* Initialize RSRR socket */
void
rsrr_init(void)
{
    struct sockaddr_un serv_addr;

    if ((rsrr_socket = socket(AF_UNIX, SOCK_DGRAM, 0)) < 0)
	logit(LOG_ERR, errno, "Can't create RSRR socket");

    unlink(RSRR_SERV_PATH);
    bzero((char *) &serv_addr, sizeof(serv_addr));
    serv_addr.sun_family = AF_UNIX;
    strlcpy(serv_addr.sun_path, RSRR_SERV_PATH, sizeof serv_addr.sun_path);

    if (bind(rsrr_socket, (struct sockaddr *)&serv_addr, sizeof serv_addr) < 0)
	logit(LOG_ERR, errno, "Can't bind RSRR socket");

    if (register_input_handler(rsrr_socket,rsrr_read) < 0)
	logit(LOG_WARNING, 0, "Couldn't register RSRR as an input handler");
}

/* Read a message from the RSRR socket */
void
rsrr_read(int f)
{
    int rsrr_recvlen;
    sigset_t mask, omask;

    bzero((char *) &client_addr, sizeof(client_addr));
    rsrr_recvlen = recvfrom(rsrr_socket, rsrr_recv_buf, sizeof(rsrr_recv_buf),
			    0, (struct sockaddr *)&client_addr, &client_length);
    if (rsrr_recvlen < 0) {
	if (errno != EINTR)
	    logit(LOG_ERR, errno, "RSRR recvfrom");
	return;
    }
    /* Use of omask taken from main() */
    sigemptyset(&mask);
    sigaddset(&mask, SIGALRM);
    sigprocmask(SIG_BLOCK, &mask, &omask);
    rsrr_accept(rsrr_recvlen);
    sigprocmask(SIG_SETMASK, &omask, NULL);
}

/* Accept a message from the reservation protocol and take
 * appropriate action.
 */
static void
rsrr_accept(int recvlen)
{
    struct rsrr_header *rsrr;
    struct rsrr_rq *route_query;

    if (recvlen < RSRR_HEADER_LEN) {
	logit(LOG_WARNING, 0,
	    "Received RSRR packet of %d bytes, which is less than min size",
	    recvlen);
	return;
    }

    rsrr = (struct rsrr_header *) rsrr_recv_buf;

    if (rsrr->version > RSRR_MAX_VERSION) {
	logit(LOG_WARNING, 0,
	    "Received RSRR packet version %d, which I don't understand",
	    rsrr->version);
	return;
    }

    switch (rsrr->version) {
      case 1:
	switch (rsrr->type) {
	  case RSRR_INITIAL_QUERY:
	    /* Send Initial Reply to client */
	    logit(LOG_INFO, 0, "Received Initial Query\n");
	    rsrr_accept_iq();
	    break;
	  case RSRR_ROUTE_QUERY:
	    /* Check size */
	    if (recvlen < RSRR_RQ_LEN) {
		logit(LOG_WARNING, 0,
		    "Received Route Query of %d bytes, which is too small",
		    recvlen);
		break;
	    }
	    /* Get the query */
	    route_query = (struct rsrr_rq *) (rsrr_recv_buf + RSRR_HEADER_LEN);
	    logit(LOG_INFO, 0,
		"Received Route Query for src %s grp %s notification %d",
		inet_fmt(route_query->source_addr.s_addr, s1),
		inet_fmt(route_query->dest_addr.s_addr,s2),
		BIT_TST(rsrr->flags,RSRR_NOTIFICATION_BIT));
	    /* Send Route Reply to client */
	    rsrr_accept_rq(route_query,rsrr->flags,NULL);
	    break;
	  default:
	    logit(LOG_WARNING, 0,
		"Received RSRR packet type %d, which I don't handle",
		rsrr->type);
	    break;
	}
	break;

      default:
	logit(LOG_WARNING, 0,
	    "Received RSRR packet version %d, which I don't understand",
	    rsrr->version);
	break;
    }
}

/* Send an Initial Reply to the reservation protocol. */
static void
rsrr_accept_iq(void)
{
    struct rsrr_header *rsrr;
    struct rsrr_vif *vif_list;
    struct uvif *v;
    int vifi, sendlen;

    /* Check for space.  There should be room for plenty of vifs,
     * but we should check anyway.
     */
    if (numvifs > RSRR_MAX_VIFS) {
	logit(LOG_WARNING, 0,
	    "Can't send RSRR Route Reply because %d is too many vifs %d",
	    numvifs);
	return;
    }

    /* Set up message */
    rsrr = (struct rsrr_header *) rsrr_send_buf;
    rsrr->version = 1;
    rsrr->type = RSRR_INITIAL_REPLY;
    rsrr->flags = 0;
    rsrr->num = numvifs;

    vif_list = (struct rsrr_vif *) (rsrr_send_buf + RSRR_HEADER_LEN);

    /* Include the vif list. */
    for (vifi=0, v = uvifs; vifi < numvifs; vifi++, v++) {
	vif_list[vifi].id = vifi;
	vif_list[vifi].status = 0;
	if (v->uv_flags & VIFF_DISABLED)
	    BIT_SET(vif_list[vifi].status,RSRR_DISABLED_BIT);
	vif_list[vifi].threshold = v->uv_threshold;
	vif_list[vifi].local_addr.s_addr = v->uv_lcl_addr;
    }

    /* Get the size. */
    sendlen = RSRR_HEADER_LEN + numvifs*RSRR_VIF_LEN;

    /* Send it. */
    logit(LOG_INFO, 0, "Send RSRR Initial Reply");
    rsrr_send(sendlen);
}

/* Send a Route Reply to the reservation protocol.  The Route Query
 * contains the query to which we are responding.  The flags contain
 * the incoming flags from the query or, for route change
 * notification, the flags that should be set for the reply.  The
 * kernel table entry contains the routing info to use for a route
 * change notification.
 */
static int
rsrr_accept_rq(struct rsrr_rq *route_query, int flags, struct gtable *gt_notify)
{
    struct rsrr_header *rsrr;
    struct rsrr_rr *route_reply;
    struct gtable *gt,local_g;
    struct rtentry *r;
    int sendlen,i;
    u_long mcastgrp;

    /* Set up message */
    rsrr = (struct rsrr_header *) rsrr_send_buf;
    rsrr->version = 1;
    rsrr->type = RSRR_ROUTE_REPLY;
    rsrr->flags = 0;
    rsrr->num = 0;

    route_reply = (struct rsrr_rr *) (rsrr_send_buf + RSRR_HEADER_LEN);
    route_reply->dest_addr.s_addr = route_query->dest_addr.s_addr;
    route_reply->source_addr.s_addr = route_query->source_addr.s_addr;
    route_reply->query_id = route_query->query_id;

    /* Blank routing entry for error. */
    route_reply->in_vif = 0;
    route_reply->reserved = 0;
    route_reply->out_vif_bm = 0;

    /* Get the size. */
    sendlen = RSRR_RR_LEN;

    /* If kernel table entry is defined, then we are sending a Route Reply
     * due to a Route Change Notification event.  Use the kernel table entry
     * to supply the routing info.
     */
    if (gt_notify) {
	/* Set flags */
	rsrr->flags = flags;
	/* Include the routing entry. */
	route_reply->in_vif = gt_notify->gt_route->rt_parent;
	route_reply->out_vif_bm = gt_notify->gt_grpmems;

    } else if (find_src_grp(route_query->source_addr.s_addr, 0,
			    route_query->dest_addr.s_addr)) {

	/* Found kernel entry. Code taken from add_table_entry() */
	gt = gtp ? gtp->gt_gnext : kernel_table;

	/* Include the routing entry. */
	route_reply->in_vif = gt->gt_route->rt_parent;
	route_reply->out_vif_bm = gt->gt_grpmems;

	/* Cache reply if using route change notification. */
	if BIT_TST(flags,RSRR_NOTIFICATION_BIT) {
	    rsrr_cache(gt,route_query);
	    BIT_SET(rsrr->flags,RSRR_NOTIFICATION_BIT);
	}

    } else {
	/* No kernel entry; use routing table. */
	r = determine_route(route_query->source_addr.s_addr);

	if (r != NULL) {
	    /* We need to mimic what will happen if a data packet
	     * is forwarded by multicast routing -- the kernel will
	     * make an upcall and mrouted will install a route in the kernel.
	     * Our outgoing vif bitmap should reflect what that table
	     * will look like.  Grab code from add_table_entry().
	     * This is gross, but it's probably better to be accurate.
	     */

	    gt = &local_g;
	    mcastgrp = route_query->dest_addr.s_addr;

	    gt->gt_mcastgrp	= mcastgrp;
	    gt->gt_grpmems	= 0;
	    gt->gt_scope	= 0;
	    gt->gt_route        = r;

	    /* obtain the multicast group membership list */
	    for (i = 0; i < numvifs; i++) {
		if (VIFM_ISSET(i, r->rt_children) &&
		    !(VIFM_ISSET(i, r->rt_leaves)))
		    VIFM_SET(i, gt->gt_grpmems);

		if (VIFM_ISSET(i, r->rt_leaves) && grplst_mem(i, mcastgrp))
		    VIFM_SET(i, gt->gt_grpmems);
	    }

	    GET_SCOPE(gt);
	    gt->gt_grpmems &= ~gt->gt_scope;

	    /* Include the routing entry. */
	    route_reply->in_vif = gt->gt_route->rt_parent;
	    route_reply->out_vif_bm = gt->gt_grpmems;

	} else {
	    /* Set error bit. */
	    BIT_SET(rsrr->flags,RSRR_ERROR_BIT);
	}
    }

    if (gt_notify)
	logit(LOG_INFO, 0, "Route Change: Send RSRR Route Reply");

    else
	logit(LOG_INFO, 0, "Send RSRR Route Reply");

    logit(LOG_INFO, 0, "for src %s dst %s in vif %d out vif %d\n",
	inet_fmt(route_reply->source_addr.s_addr,s1),
	inet_fmt(route_reply->dest_addr.s_addr,s2),
	route_reply->in_vif,route_reply->out_vif_bm);

    /* Send it. */
    return rsrr_send(sendlen);
}

/* Send an RSRR message. */
static int
rsrr_send(int sendlen)
{
    int error;

    /* Send it. */
    error = sendto(rsrr_socket, rsrr_send_buf, sendlen, 0,
		   (struct sockaddr *)&client_addr, client_length);

    /* Check for errors. */
    if (error < 0) {
	logit(LOG_WARNING, errno, "Failed send on RSRR socket");
    } else if (error != sendlen) {
	logit(LOG_WARNING, 0,
	    "Sent only %d out of %d bytes on RSRR socket\n", error, sendlen);
    }
    return error;
}

/* Cache a message being sent to a client.  Currently only used for
 * caching Route Reply messages for route change notification.
 */
static void
rsrr_cache(struct gtable *gt, struct rsrr_rq *route_query)
{
    struct rsrr_cache *rc, **rcnp;
    struct rsrr_header *rsrr;

    rsrr = (struct rsrr_header *) rsrr_send_buf;

    rcnp = &gt->gt_rsrr_cache;
    while ((rc = *rcnp) != NULL) {
	if ((rc->route_query.source_addr.s_addr ==
	     route_query->source_addr.s_addr) &&
	    (rc->route_query.dest_addr.s_addr ==
	     route_query->dest_addr.s_addr) &&
	    (!strcmp(rc->client_addr.sun_path,client_addr.sun_path))) {
	    /* Cache entry already exists.
	     * Check if route notification bit has been cleared.
	     */
	    if (!BIT_TST(rsrr->flags,RSRR_NOTIFICATION_BIT)) {
		/* Delete cache entry. */
		*rcnp = rc->next;
		free(rc);
	    } else {
		/* Update */
		rc->route_query.query_id = route_query->query_id;
		logit(LOG_DEBUG, 0,
			"Update cached query id %ld from client %s\n",
			rc->route_query.query_id, rc->client_addr.sun_path);
	    }
	    return;
	}
	rcnp = &rc->next;
    }

    /* Cache entry doesn't already exist.  Create one and insert at
     * front of list.
     */
    rc = malloc(sizeof(struct rsrr_cache));
    if (rc == NULL)
	logit(LOG_ERR, 0, "ran out of memory");
    rc->route_query.source_addr.s_addr = route_query->source_addr.s_addr;
    rc->route_query.dest_addr.s_addr = route_query->dest_addr.s_addr;
    rc->route_query.query_id = route_query->query_id;
    strlcpy(rc->client_addr.sun_path, client_addr.sun_path,
	sizeof rc->client_addr.sun_path);
    rc->client_length = client_length;
    rc->next = gt->gt_rsrr_cache;
    gt->gt_rsrr_cache = rc;
    logit(LOG_DEBUG, 0, "Cached query id %ld from client %s\n",
	   rc->route_query.query_id,rc->client_addr.sun_path);
}

/* Send all the messages in the cache.  Currently this is used to send
 * all the cached Route Reply messages for route change notification.
 */
void
rsrr_cache_send(struct gtable *gt, int notify)
{
    struct rsrr_cache *rc, **rcnp;
    int flags = 0;

    if (notify)
	BIT_SET(flags,RSRR_NOTIFICATION_BIT);

    rcnp = &gt->gt_rsrr_cache;
    while ((rc = *rcnp) != NULL) {
	if (rsrr_accept_rq(&rc->route_query,flags,gt) < 0) {
	    logit(LOG_DEBUG, 0, "Deleting cached query id %ld from client %s\n",
		   rc->route_query.query_id,rc->client_addr.sun_path);
	    /* Delete cache entry. */
	    *rcnp = rc->next;
	    free(rc);
	} else {
	    rcnp = &rc->next;
	}
    }
}

/* Clean the cache by deleting all entries. */
void
rsrr_cache_clean(struct gtable *gt)
{
    struct rsrr_cache *rc,*rc_next;

    printf("cleaning cache for group %s\n",inet_fmt(gt->gt_mcastgrp, s1));
    rc = gt->gt_rsrr_cache;
    while (rc) {
	rc_next = rc->next;
	free(rc);
	rc = rc_next;
    }
    gt->gt_rsrr_cache = NULL;
}

void
rsrr_clean(void)
{
    unlink(RSRR_SERV_PATH);
}

#endif /* RSRR */
@


1.14
log
@since stdlib.h is in scope, don't cast.... you know the drill.
no sneakiness detected by krw
@
text
@d1 1
a1 1
/*	$OpenBSD: rsrr.c,v 1.13 2015/01/16 06:40:18 deraadt Exp $	*/
a85 1
    int servlen;
a94 3
    servlen = offsetof(struct sockaddr_un, sun_path) +
		strlen(serv_addr.sun_path);
    serv_addr.sun_len = servlen;
d96 1
a96 1
    if (bind(rsrr_socket, (struct sockaddr *) &serv_addr, servlen) < 0)
@


1.13
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: rsrr.c,v 1.12 2013/04/21 06:42:43 tedu Exp $	*/
d426 1
a426 1
    rc = (struct rsrr_cache *) malloc(sizeof(struct rsrr_cache));
@


1.12
log
@deregister. no binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: rsrr.c,v 1.11 2013/04/21 00:24:42 deraadt Exp $	*/
a42 2
#include <sys/param.h>
#if (defined(BSD) && (BSD >= 199103))
a43 1
#endif
a95 1
#if (defined(BSD) && (BSD >= 199103))
a98 3
#else
    servlen = sizeof(serv_addr.sun_family) + strlen(serv_addr.sun_path);
#endif
@


1.11
log
@convert select to poll, since the select code had descriptor limits
ok tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: rsrr.c,v 1.10 2004/08/01 18:32:19 deraadt Exp $	*/
d53 1
a53 1
	register int _i; \
@


1.10
log
@ansi cleanup; khalek@@linuxgamers.net
@
text
@d1 1
a1 1
/*	$OpenBSD: $	*/
d116 1
a116 1
rsrr_read(int f, fd_set *rfd)
@


1.9
log
@Replace log() with logit() since ISO C reserves log() for the math
library and gcc 3.x will complain.  Replacement name taken from NetBSD.
espie@@ OK.
@
text
@d1 1
d87 1
a87 1
rsrr_init()
d116 1
a116 3
rsrr_read(f, rfd)
	int f;
	fd_set *rfd;
d141 1
a141 2
rsrr_accept(recvlen)
    int recvlen;
d206 1
a206 1
rsrr_accept_iq()
d258 1
a258 4
rsrr_accept_rq(route_query,flags,gt_notify)
    struct rsrr_rq *route_query;
    int flags;
    struct gtable *gt_notify;
d375 1
a375 2
rsrr_send(sendlen)
    int sendlen;
d397 1
a397 3
rsrr_cache(gt,route_query)
    struct gtable *gt;
    struct rsrr_rq *route_query;
d452 1
a452 3
rsrr_cache_send(gt,notify)
    struct gtable *gt;
    int notify;
d476 1
a476 2
rsrr_cache_clean(gt)
    struct gtable *gt;
d491 1
a491 1
rsrr_clean()
@


1.8
log
@lots of sprintf -> snprintf and strcpy -> strlcpy; checked by tedu
@
text
@d92 1
a92 1
	log(LOG_ERR, errno, "Can't create RSRR socket");
d107 1
a107 1
	log(LOG_ERR, errno, "Can't bind RSRR socket");
d110 1
a110 1
	log(LOG_WARNING, 0, "Couldn't register RSRR as an input handler");
d127 1
a127 1
	    log(LOG_ERR, errno, "RSRR recvfrom");
d149 1
a149 1
	log(LOG_WARNING, 0,
d158 1
a158 1
	log(LOG_WARNING, 0,
d169 1
a169 1
	    log(LOG_INFO, 0, "Received Initial Query\n");
d175 1
a175 1
		log(LOG_WARNING, 0,
d182 1
a182 1
	    log(LOG_INFO, 0,
d191 1
a191 1
	    log(LOG_WARNING, 0,
d199 1
a199 1
	log(LOG_WARNING, 0,
d219 1
a219 1
	log(LOG_WARNING, 0,
d248 1
a248 1
    log(LOG_INFO, 0, "Send RSRR Initial Reply");
d364 1
a364 1
	log(LOG_INFO, 0, "Route Change: Send RSRR Route Reply");
d367 1
a367 1
	log(LOG_INFO, 0, "Send RSRR Route Reply");
d369 1
a369 1
    log(LOG_INFO, 0, "for src %s dst %s in vif %d out vif %d\n",
d391 1
a391 1
	log(LOG_WARNING, errno, "Failed send on RSRR socket");
d393 1
a393 1
	log(LOG_WARNING, 0,
d429 1
a429 1
		log(LOG_DEBUG, 0,
d443 1
a443 1
	log(LOG_ERR, 0, "ran out of memory");
d452 1
a452 1
    log(LOG_DEBUG, 0, "Cached query id %ld from client %s\n",
d473 1
a473 1
	    log(LOG_DEBUG, 0, "Deleting cached query id %ld from client %s\n",
@


1.7
log
@spaces
@
text
@d97 1
a97 1
    strcpy(serv_addr.sun_path, RSRR_SERV_PATH);
d447 2
a448 1
    strcpy(rc->client_addr.sun_path, client_addr.sun_path);
@


1.6
log
@Manual cleanup of remaining userland __P use (excluding packages maintained outside the tree)
@
text
@d64 1
a64 1
/* 
d105 1
a105 1
 
d121 1
a121 1
    
d125 1
a125 1
    if (rsrr_recvlen < 0) {	
d147 1
a147 1
    
d154 1
a154 1
    
d156 1
a156 1
    
d163 1
a163 1
    
d197 1
a197 1
	
d214 1
a214 1
    
d224 1
a224 1
    
d231 1
a231 1
    
d233 1
a233 1
    
d243 1
a243 1
    
d246 1
a246 1
    
d271 1
a271 1
    
d278 1
a278 1
    
d283 1
a283 1
    
d288 1
a288 1
    
d308 1
a308 1
	
d318 1
a318 1
	
d322 1
a322 1
	
d331 1
a331 1
	    
d334 2
a335 2
	    
	    gt->gt_mcastgrp    	= mcastgrp;
d339 1
a339 1
	    
d342 1
a342 1
		if (VIFM_ISSET(i, r->rt_children) && 
d345 1
a345 1
		
d349 1
a349 1
	    
d352 1
a352 1
	    
d362 1
a362 1
    
d373 1
a373 1
    
d384 1
a384 1
    
d388 1
a388 1
    
d414 1
a414 1
	if ((rc->route_query.source_addr.s_addr == 
d416 1
a416 1
	    (rc->route_query.dest_addr.s_addr == 
@


1.5
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d79 2
a80 2
static int	rsrr_accept_rq __P((struct rsrr_rq *route_query, int flags,
					struct gtable *gt_notify));
d82 1
a82 2
static void	rsrr_cache __P((struct gtable *gt,
					struct rsrr_rq *route_query));
@


1.4
log
@Replace the deprecated BSD sigsetmask/sigblock/sigpause functions with their POSIX counterparts.
@
text
@d77 2
a78 2
static void	rsrr_accept __P((int recvlen));
static void	rsrr_accept_iq __P((void));
d81 1
a81 1
static int	rsrr_send __P((int sendlen));
@


1.3
log
@Pavlin Ivanov Radoslavov <pavlin@@catarina.usc.edu> writes:
> I received an email that the USC's General Counsel's Office
> has approved that the software license to pimd can be changed to the
> 3-clause BSD-like license!
> [...]
This is various other bits of software that is also covered by this.
@
text
@d120 2
a121 2
    register int rsrr_recvlen;
    register int omask;
d132 3
a134 1
    omask = sigblock(sigmask(SIGALRM));
d136 1
a136 1
    (void)sigsetmask(omask);
@


1.2
log
@from netbsd; update to mrouted 3.8
@
text
@d4 2
a5 1
 * Copyright (c) 1993 by the University of Southern California
d8 11
a18 11
 * Permission to use, copy, modify, and distribute this software and its
 * documentation in source and binary forms for non-commercial purposes
 * and without fee is hereby granted, provided that the above copyright
 * notice appear in all copies and that both the copyright notice and
 * this permission notice appear in supporting documentation. and that
 * any documentation, advertising materials, and other materials related
 * to such distribution and use acknowledge that the software was
 * developed by the University of Southern California, Information
 * Sciences Institute.  The name of the University may not be used to
 * endorse or promote products derived from this software without
 * specific prior written permission.
d20 11
a30 8
 * THE UNIVERSITY OF SOUTHERN CALIFORNIA makes no representations about
 * the suitability of this software for any purpose.  THIS SOFTWARE IS
 * PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *
 * Other copyrights might apply to parts of this software and are so
 * noted when applicable.
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: rsrr.c,v 1.2 1995/10/09 03:51:56 thorpej Exp $	*/
d33 2
d38 4
d66 4
d73 7
a79 4
void rsrr_accept();
void rsrr_send();
void rsrr_accept_iq();
void rsrr_accept_rq();
d95 5
d101 1
d112 3
a114 1
rsrr_read()
a116 2
    struct sockaddr_un client_addr;
    int client_length = sizeof(client_addr);
d121 1
a121 1
			    0, &client_addr, &client_length);
d129 1
a129 1
    rsrr_accept(rsrr_recvlen,&client_addr,client_length);
d136 2
a137 2
void
rsrr_accept(recvlen,client_addr,client_length)
a138 2
    struct sockaddr_un *client_addr;
    int client_length;
d165 1
a165 1
	    rsrr_accept_iq(client_addr,client_length);
d183 1
a183 1
	    rsrr_accept_rq(rsrr,route_query,client_addr,client_length);
d202 2
a203 4
void
rsrr_accept_iq(client_addr,client_length)
    struct sockaddr_un *client_addr;
    int client_length;    
d244 1
a244 1
    rsrr_send(sendlen,client_addr,client_length);
d247 12
a258 7
/* Send a Route Reply to the reservation protocol. */
void
rsrr_accept_rq(rsrr_in,route_query,client_addr,client_length)
    struct rsrr_header *rsrr_in;
    struct rsrr_rq *route_query;    
    struct sockaddr_un *client_addr;
    int client_length;    
d271 1
a271 1
    rsrr->flags = rsrr_in->flags;
d284 18
a301 8
    /* Clear error bit. */
    BIT_CLR(rsrr->flags,RSRR_ERROR_BIT);
    /* Turn notification off.  We don't do it yet. */
    BIT_CLR(rsrr->flags,RSRR_NOTIFICATION_BIT);
    
    /* First check kernel. Code taken from add_table_entry() */
    if (find_src_grp(route_query->source_addr.s_addr, 0,
		     route_query->dest_addr.s_addr)) {
d307 6
d358 7
a364 4
    /* Get the size. */
    sendlen = RSRR_RR_LEN;
    
    log(LOG_INFO, 0, "Send RSRR Route Reply for src %s grp %s ",
d366 1
a366 2
	inet_fmt(route_reply->dest_addr.s_addr,s2));
    log(LOG_INFO, 0, "in vif %d out vif %d\n",
d370 1
a370 1
    rsrr_send(sendlen,client_addr,client_length);
d374 2
a375 2
void
rsrr_send(sendlen,client_addr,client_length)
a376 2
    struct sockaddr_un *client_addr;
    int client_length;
d382 1
a382 1
		   *client_addr, client_length);
d387 1
a387 3
	return;
    }
    if (error != sendlen) {
a389 1
	return;
d391 102
d501 1
a501 1
#endif RSRR
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
