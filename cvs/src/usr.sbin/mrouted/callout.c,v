head	1.7;
access;
symbols
	OPENBSD_6_0:1.7.0.4
	OPENBSD_6_0_BASE:1.7
	OPENBSD_5_9:1.7.0.2
	OPENBSD_5_9_BASE:1.7
	OPENBSD_5_8:1.6.0.50
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.42
	OPENBSD_5_7_BASE:1.6
	OPENBSD_5_6:1.6.0.46
	OPENBSD_5_6_BASE:1.6
	OPENBSD_5_5:1.6.0.44
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.40
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.38
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.36
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.34
	OPENBSD_5_0:1.6.0.32
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.30
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.6.0.28
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.6.0.24
	OPENBSD_4_7_BASE:1.6
	OPENBSD_4_6:1.6.0.26
	OPENBSD_4_6_BASE:1.6
	OPENBSD_4_5:1.6.0.22
	OPENBSD_4_5_BASE:1.6
	OPENBSD_4_4:1.6.0.20
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3:1.6.0.18
	OPENBSD_4_3_BASE:1.6
	OPENBSD_4_2:1.6.0.16
	OPENBSD_4_2_BASE:1.6
	OPENBSD_4_1:1.6.0.14
	OPENBSD_4_1_BASE:1.6
	OPENBSD_4_0:1.6.0.12
	OPENBSD_4_0_BASE:1.6
	OPENBSD_3_9:1.6.0.10
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.6.0.8
	OPENBSD_3_8_BASE:1.6
	OPENBSD_3_7:1.6.0.6
	OPENBSD_3_7_BASE:1.6
	OPENBSD_3_6:1.6.0.4
	OPENBSD_3_6_BASE:1.6
	OPENBSD_3_5:1.6.0.2
	OPENBSD_3_5_BASE:1.6
	OPENBSD_3_4:1.5.0.4
	OPENBSD_3_4_BASE:1.5
	OPENBSD_3_3:1.5.0.2
	OPENBSD_3_3_BASE:1.5
	OPENBSD_3_2:1.3.0.4
	OPENBSD_3_2_BASE:1.3
	OPENBSD_3_1:1.3.0.2
	OPENBSD_3_1_BASE:1.3
	OPENBSD_3_0:1.2.0.22
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_9:1.2.0.20
	OPENBSD_2_8:1.2.0.18
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.16
	OPENBSD_2_7_BASE:1.2
	OPENBSD_2_6:1.2.0.14
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.12
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.10
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.8
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.6
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.7
date	2015.08.21.02.07.32;	author deraadt;	state Exp;
branches;
next	1.6;
commitid	Zx2k82IzYwwZaEz9;

1.6
date	2003.11.26.01.17.12;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2003.03.03.15.14.27;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2003.03.03.14.58.23;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2002.02.16.21.28.05;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	95.12.14.01.45.19;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.47.45;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.47.45;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.7
log
@since stdlib.h is in scope, don't cast.... you know the drill.
no sneakiness detected by krw
@
text
@/*	$NetBSD: callout.c,v 1.3 1995/12/10 10:06:56 mycroft Exp $	*/

/*
 * The mrouted program is covered by the license in the accompanying file
 * named "LICENSE".  Use of the mrouted program represents acceptance of
 * the terms and conditions listed in that file.
 *
 * The mrouted program is COPYRIGHT 1989 by The Board of Trustees of
 * Leland Stanford Junior University.
 */

#include "defs.h"

/* the code below implements a callout queue */
static int id = 0;
static struct timeout_q  *Q = 0; /* pointer to the beginning of timeout queue */

static int in_callout = 0;

struct timeout_q {
	struct timeout_q *next;		/* next event */
	int		 id;
	cfunc_t          func;		/* function to call */
	char		 *data;		/* func's data */
	int		 time;		/* time offset to next event*/
};

#ifdef IGMP_DEBUG
static void print_Q(void);
#else
#define	print_Q()
#endif

void
callout_init(void)
{
    Q = (struct timeout_q *) 0;
}


/*
 * signal handler for SIGALARM that is called once every second
 */
void
age_callout_queue(void)
{
    struct timeout_q *ptr;

    if (in_callout)
	return;

    in_callout = 1;
    ptr = Q;

    while (ptr) {
	if (!ptr->time) {
	    /* timeout has happened */
	    Q = Q->next;

	    in_callout = 0;
	    if (ptr->func)
		ptr->func(ptr->data);
	    in_callout = 1;

	    free(ptr);
	    ptr = Q;
	}
	else {
	    ptr->time --;
#ifdef IGMP_DEBUG
	    logit(LOG_DEBUG,0,"[callout, age_callout_queue] -- time (%d)", ptr->time);
#endif /* IGMP_DEBUG */
	    in_callout = 0; return;
	}
    }
    in_callout = 0;
    return;
}


/*
 * sets the timer
 * delay	number of units for timeout
 * action	function to be called on timeout
 * data		what to call the timeout function with
 */
int
timer_setTimer(int delay, cfunc_t action, char *data)
{
    struct     timeout_q  *ptr, *node, *prev;

    if (in_callout)
	return -1;

    in_callout = 1;

    /* create a node */
    node = malloc(sizeof(struct timeout_q));
    if (node == 0) {
	logit(LOG_WARNING, 0, "Malloc Failed in timer_settimer\n");
	in_callout = 0;
	return -1;
    }
    node->func = action;
    node->data = data;
    node->time = delay;
    node->next = 0;
    node->id   = ++id;

    prev = ptr = Q;

    /* insert node in the queue */

    /* if the queue is empty, insert the node and return */
    if (!Q)
	Q = node;
    else {
	/* chase the pointer looking for the right place */
	while (ptr) {

	    if (delay < ptr->time) {
		/* right place */

		node->next = ptr;
		if (ptr == Q)
		    Q = node;
		else
		    prev->next = node;
		ptr->time -= node->time;
		print_Q();
		in_callout = 0;
		return node->id;
	    } else  {
		/* keep moving */

		delay -= ptr->time; node->time = delay;
		prev = ptr;
		ptr = ptr->next;
	    }
	}
	prev->next = node;
    }
    print_Q();
    in_callout = 0;
    return node->id;
}


/* clears the associated timer */
void
timer_clearTimer(int timer_id)
{
    struct timeout_q  *ptr, *prev;

    if (in_callout)
        return;
    if (!timer_id)
	return;

    in_callout = 1;

    prev = ptr = Q;

    /*
     * find the right node, delete it. the subsequent node's time
     * gets bumped up
     */

    print_Q();
    while (ptr) {
	if (ptr->id == timer_id) {
	    /* got the right node */

	    /* unlink it from the queue */
	    if (ptr == Q)
		Q = Q->next;
	    else
		prev->next = ptr->next;

	    /* increment next node if any */
	    if (ptr->next != 0)
		(ptr->next)->time += ptr->time;

	    free(ptr->data);
	    free(ptr);
	    print_Q();
	    in_callout = 0;
	    return;
	}
	prev = ptr;
	ptr = ptr->next;
    }
    print_Q();
    in_callout = 0;
}

#ifdef IGMP_DEBUG
/*
 * debugging utility
 */
static void
print_Q(void)
{
    struct timeout_q  *ptr;

    for(ptr = Q; ptr; ptr = ptr->next)
	logit(LOG_DEBUG,0,"(%d,%d) ", ptr->id, ptr->time);
}
#endif /* IGMP_DEBUG */

int
secs_remaining(int timer_id)
{
    struct timeout_q  *ptr;
    int left=0;

    for (ptr = Q; ptr && ptr->id != timer_id; ptr = ptr->next)
       left += ptr->time;

    if (!ptr) /* not found */
       return 0;

    return left + ptr->time;
}
@


1.6
log
@Replace log() with logit() since ISO C reserves log() for the math
library and gcc 3.x will complain.  Replacement name taken from NetBSD.
espie@@ OK.
@
text
@d98 1
a98 1
    node = (struct timeout_q *)malloc(sizeof(struct timeout_q));
@


1.5
log
@spaces
@
text
@d71 1
a71 1
	    log(LOG_DEBUG,0,"[callout, age_callout_queue] -- time (%d)", ptr->time);
d100 1
a100 1
	log(LOG_WARNING, 0, "Malloc Failed in timer_settimer\n");
d207 1
a207 1
	log(LOG_DEBUG,0,"(%d,%d) ", ptr->id, ptr->time);
@


1.4
log
@ansi, from cloder
@
text
@d22 4
a25 4
	int        	 id;  
	cfunc_t          func;    	/* function to call */
	char	   	 *data;		/* func's data */
	int            	 time;		/* time offset to next event*/
d31 1
a31 1
#define	print_Q()	
d48 1
a48 1
    
d54 1
a54 1
    
d64 1
a64 1
	    
d81 1
a81 1
/* 
d85 1
a85 1
 * data 	what to call the timeout function with
d91 1
a91 1
    
d96 2
a97 2
    
    /* create a node */	
d104 1
a104 1
    node->func = action; 
d106 2
a107 2
    node->time = delay; 
    node->next = 0;	
d109 1
a109 1
    
d111 1
a111 1
    
d113 1
a113 1
    
d120 1
a120 1
	    
d123 1
a123 1
		
d135 1
a135 1
		
d154 1
a154 1
    
d161 1
a161 1
    
d163 1
a163 1
    
d168 1
a168 1
    
d173 1
a173 1
	    
d179 1
a179 1
	    
d183 1
a183 1
	    
d205 1
a205 1
    
@


1.3
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d35 1
a35 1
callout_init()
d45 1
a45 1
age_callout_queue()
d83 3
d88 1
a88 4
timer_setTimer(delay, action, data)
    int 	delay;  	/* number of units for timeout */
    cfunc_t	action; 	/* function to be called on timeout */
    char  	*data;  	/* what to call the timeout function with */
d151 1
a151 2
timer_clearTimer(timer_id)
    int  timer_id;
d202 1
a202 1
print_Q()
d210 1
d212 1
a212 2
secs_remaining( timer_id)
    int  timer_id;
@


1.2
log
@from netbsd; update to mrouted 3.8
@
text
@d29 1
a29 1
static void print_Q __P((void));
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: callout.c,v 1.2 1995/10/09 03:51:34 thorpej Exp $	*/
d18 1
a18 3
static int in_callout= 0;

typedef void (* cfunc_t)();
d23 1
a23 1
	cfunc_t          func ;    	/* function to call */
d28 5
a32 1
static void print_Q();
d34 2
a35 1
void callout_init()
d44 2
a45 1
void age_callout_queue()
d55 2
a56 2
    while (ptr){
	if (!ptr->time ) {
d58 4
a61 1
	    if(ptr->func)
d63 1
a63 1
	    Q = Q->next;
d72 1
a72 1
#endif IGMP_DEBUG
d84 2
a85 1
int timer_setTimer(delay, action, data)
d98 1
a98 1
    node   = (struct timeout_q *)malloc(sizeof(struct timeout_q));
d119 1
a119 1
	while (ptr){
d121 1
a121 1
	    if (delay < ptr->time){
d133 1
a133 2
	    }
	    else  {
d150 2
a151 1
void timer_clearTimer( timer_id)
d156 5
a160 1
    if (in_callout)  return;
a162 3
    
    if ( !timer_id ) {in_callout = 0; return;}
    
d171 2
a172 2
    while (ptr){
	if (ptr->id == timer_id){
d176 1
a176 1
	    if ( ptr == Q)
d198 1
d202 2
a203 1
static void print_Q()
a204 1
#ifdef IGMP_DEBUG
a208 1
#endif IGMP_DEBUG
d210 10
d221 5
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
