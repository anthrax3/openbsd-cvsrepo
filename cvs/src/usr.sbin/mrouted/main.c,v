head	1.30;
access;
symbols
	OPENBSD_6_1:1.30.0.4
	OPENBSD_6_1_BASE:1.30
	OPENBSD_6_0:1.29.0.4
	OPENBSD_6_0_BASE:1.29
	OPENBSD_5_9:1.29.0.2
	OPENBSD_5_9_BASE:1.29
	OPENBSD_5_8:1.25.0.6
	OPENBSD_5_8_BASE:1.25
	OPENBSD_5_7:1.25.0.2
	OPENBSD_5_7_BASE:1.25
	OPENBSD_5_6:1.23.0.8
	OPENBSD_5_6_BASE:1.23
	OPENBSD_5_5:1.23.0.6
	OPENBSD_5_5_BASE:1.23
	OPENBSD_5_4:1.23.0.2
	OPENBSD_5_4_BASE:1.23
	OPENBSD_5_3:1.19.0.6
	OPENBSD_5_3_BASE:1.19
	OPENBSD_5_2:1.19.0.4
	OPENBSD_5_2_BASE:1.19
	OPENBSD_5_1_BASE:1.19
	OPENBSD_5_1:1.19.0.2
	OPENBSD_5_0:1.18.0.8
	OPENBSD_5_0_BASE:1.18
	OPENBSD_4_9:1.18.0.6
	OPENBSD_4_9_BASE:1.18
	OPENBSD_4_8:1.18.0.4
	OPENBSD_4_8_BASE:1.18
	OPENBSD_4_7:1.18.0.2
	OPENBSD_4_7_BASE:1.18
	OPENBSD_4_6:1.17.0.14
	OPENBSD_4_6_BASE:1.17
	OPENBSD_4_5:1.17.0.10
	OPENBSD_4_5_BASE:1.17
	OPENBSD_4_4:1.17.0.8
	OPENBSD_4_4_BASE:1.17
	OPENBSD_4_3:1.17.0.6
	OPENBSD_4_3_BASE:1.17
	OPENBSD_4_2:1.17.0.4
	OPENBSD_4_2_BASE:1.17
	OPENBSD_4_1:1.17.0.2
	OPENBSD_4_1_BASE:1.17
	OPENBSD_4_0:1.16.0.6
	OPENBSD_4_0_BASE:1.16
	OPENBSD_3_9:1.16.0.4
	OPENBSD_3_9_BASE:1.16
	OPENBSD_3_8:1.16.0.2
	OPENBSD_3_8_BASE:1.16
	OPENBSD_3_7:1.14.0.6
	OPENBSD_3_7_BASE:1.14
	OPENBSD_3_6:1.14.0.4
	OPENBSD_3_6_BASE:1.14
	OPENBSD_3_5:1.14.0.2
	OPENBSD_3_5_BASE:1.14
	OPENBSD_3_4:1.13.0.4
	OPENBSD_3_4_BASE:1.13
	OPENBSD_3_3:1.13.0.2
	OPENBSD_3_3_BASE:1.13
	OPENBSD_3_2:1.10.0.2
	OPENBSD_3_2_BASE:1.10
	OPENBSD_3_1:1.9.0.2
	OPENBSD_3_1_BASE:1.9
	OPENBSD_3_0:1.6.0.2
	OPENBSD_3_0_BASE:1.6
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_9:1.5.0.2
	OPENBSD_2_8:1.4.0.18
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.16
	OPENBSD_2_7_BASE:1.4
	OPENBSD_2_6:1.4.0.14
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.4.0.12
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.4.0.10
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.4.0.8
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.4.0.6
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.4.0.4
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.30
date	2017.01.21.08.33.51;	author krw;	state Exp;
branches;
next	1.29;
commitid	xpTSTOgSQRGS1RiF;

1.29
date	2015.11.12.22.33.07;	author deraadt;	state Exp;
branches;
next	1.28;
commitid	yL2gco0cO8wLO0qe;

1.28
date	2015.11.12.21.40.42;	author deraadt;	state Exp;
branches;
next	1.27;
commitid	vpTu8wVfDIlsSqJy;

1.27
date	2015.10.26.10.08.15;	author jung;	state Exp;
branches;
next	1.26;
commitid	HllzbCvumEtKpBqi;

1.26
date	2015.10.26.09.57.55;	author deraadt;	state Exp;
branches;
next	1.25;
commitid	lT6pbS5V0UKyyVn8;

1.25
date	2014.11.26.18.34.52;	author millert;	state Exp;
branches;
next	1.24;
commitid	9QOFSShUOtA0kQLF;

1.24
date	2014.08.27.10.36.55;	author daniel;	state Exp;
branches;
next	1.23;
commitid	Eb4J9oPCgpWNEVUm;

1.23
date	2013.04.21.22.38.51;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2013.04.21.06.42.43;	author tedu;	state Exp;
branches;
next	1.21;

1.21
date	2013.04.21.04.37.29;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2013.04.21.00.24.42;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2011.09.21.21.05.40;	author jsg;	state Exp;
branches;
next	1.18;

1.18
date	2009.10.27.23.59.53;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2007.02.18.21.04.14;	author jmc;	state Exp;
branches;
next	1.16;

1.16
date	2005.06.16.19.41.23;	author robert;	state Exp;
branches;
next	1.15;

1.15
date	2005.06.15.14.30.56;	author robert;	state Exp;
branches;
next	1.14;

1.14
date	2003.11.26.01.17.12;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2003.03.12.22.55.01;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2003.03.03.15.14.28;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2003.03.03.14.58.23;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2002.08.09.02.27.16;	author itojun;	state Exp;
branches;
next	1.9;

1.9
date	2002.02.19.19.39.40;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2002.02.16.21.28.05;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2001.12.01.23.27.23;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2001.09.04.23.35.59;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.03.09.03.24.07;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.09.11.19.15.33;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	95.12.19.17.48.04;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.12.14.01.45.26;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.47.46;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.47.46;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.30
log
@Nuke whitespace foolish enough to expose itself during the great
"warning:" rectification.
@
text
@/*	$NetBSD: main.c,v 1.6 1995/12/10 10:07:05 mycroft Exp $	*/

/*
 * The mrouted program is covered by the license in the accompanying file
 * named "LICENSE".  Use of the mrouted program represents acceptance of
 * the terms and conditions listed in that file.
 *
 * The mrouted program is COPYRIGHT 1989 by The Board of Trustees of
 * Leland Stanford Junior University.
 */

/*
 * Written by Steve Deering, Stanford University, February 1989.
 *
 * (An earlier version of DVMRP was implemented by David Waitzman of
 *  BBN STC by extending Berkeley's routed program.  Some of Waitzman's
 *  extensions have been incorporated into mrouted, but none of the
 *  original routed code has been adopted.)
 */


#include "defs.h"
#include <stdarg.h>
#include <fcntl.h>
#include <poll.h>
#include <err.h>

extern char *configfilename;
char versionstring[100];

static char dumpfilename[] = _PATH_MROUTED_DUMP;
static char cachefilename[] = _PATH_MROUTED_CACHE;
static char genidfilename[] = _PATH_MROUTED_GENID;

int cache_lifetime	= DEFAULT_CACHE_LIFETIME;
int max_prune_lifetime	= DEFAULT_CACHE_LIFETIME * 2;

int debug = 0;
u_char pruning = 1;	/* Enable pruning by default */

#define NHANDLERS	2

static struct ihandler {
    int fd;			/* File descriptor		*/
    ihfunc_t func;		/* Function to call		*/
} ihandlers[NHANDLERS];
static int nhandlers = 0;

/*
 * Forward declarations.
 */
static void fasttimer(int);
static void done(int);
static void dump(int);
static void fdump(int);
static void cdump(int);
static void restart(int);
static void timer(void);
static void cleanup(void);
static void resetlogging(void *);

int
register_input_handler(int fd, ihfunc_t func)
{
    if (nhandlers >= NHANDLERS)
	return -1;

    ihandlers[nhandlers].fd = fd;
    ihandlers[nhandlers++].func = func;

    return 0;
}

int
main(int argc, char *argv[])
{
    int recvlen;
    int dummy;
    FILE *fp;
    struct timeval now;
    u_int32_t prev_genid;
    struct pollfd *pfd;
    int vers, n, i, ch;
    sigset_t mask, omask;
    const char *errstr;

    if (geteuid() != 0) {
	fprintf(stderr, "must be root\n");
	exit(1);
    }
    setvbuf(stderr, NULL, _IOLBF, 0);

    while ((ch = getopt(argc, argv, "c:d::p")) != -1) {
	    switch (ch) {
	    case 'c':
		    configfilename = optarg;
		    break;
	    case 'd':
		    if (!optarg)
			    debug = DEFAULT_DEBUG;
		    else {
			    debug = strtonum(optarg, 0, 3, &errstr);
			    if (errstr) {
				    warnx("debug level %s", errstr);
				    debug = DEFAULT_DEBUG;
			    }
		    }
		    break;
	    case 'p':
		    pruning = 0;
		    break;
	    default:
		    goto usage;
	    }
    }
    argc -= optind;
    argv += optind;

    if (argc > 0) {
usage:	fprintf(stderr,
		"usage: mrouted [-p] [-c config_file] [-d [debug_level]]\n");
	exit(1);
    }

    if (debug == 0) {
	/*
	 * Detach from the terminal
	 */
	int t;

	if (fork()) exit(0);
	(void)close(0);
	(void)close(1);
	(void)close(2);
	(void)open("/dev/null", O_RDONLY);
	(void)dup2(0, 1);
	(void)dup2(0, 2);
#ifdef SYSV
	(void)setpgrp();
#else
#ifdef TIOCNOTTY
	t = open("/dev/tty", O_RDWR);
	if (t >= 0) {
	    (void)ioctl(t, TIOCNOTTY, (char *)0);
	    (void)close(t);
	}
#else
	if (setsid() < 0)
	    perror("setsid");
#endif
#endif
    }
    else
	fprintf(stderr, "debug level %u\n", debug);

#ifdef LOG_DAEMON
    (void)openlog("mrouted", LOG_PID, LOG_DAEMON);
    (void)setlogmask(LOG_UPTO(LOG_NOTICE));
#else
    (void)openlog("mrouted", LOG_PID);
#endif
    snprintf(versionstring, sizeof versionstring, "mrouted version %d.%d",
			PROTOCOL_VERSION, MROUTED_VERSION);

    logit(LOG_NOTICE, 0, "%s", versionstring);

    /*
     * Get generation id
     */
    gettimeofday(&now, NULL);
    dvmrp_genid = (u_int32_t)now.tv_sec;	/* for a while after 2038 */

    fp = fopen(genidfilename, "r");
    if (fp != NULL) {
	fscanf(fp, "%d", &prev_genid);
	if (prev_genid == dvmrp_genid)
	    dvmrp_genid++;
	(void) fclose(fp);
    }

    fp = fopen(genidfilename, "w");
    if (fp != NULL) {
	fprintf(fp, "%d", dvmrp_genid);
	(void) fclose(fp);
    }

    callout_init();
    init_igmp();
    init_routes();
    init_ktable();
    k_init_dvmrp();		/* enable DVMRP routing in kernel */

#ifndef OLD_KERNEL
    vers = k_get_version();
    /*XXX
     * This function must change whenever the kernel version changes
     */
    if ((((vers >> 8) & 0xff) != 3) ||
	 ((vers & 0xff) != 5))
	logit(LOG_ERR, 0, "kernel (v%d.%d)/mrouted (v%d.%d) version mismatch",
		(vers >> 8) & 0xff, vers & 0xff,
		PROTOCOL_VERSION, MROUTED_VERSION);
#endif

    init_vifs();

#ifdef RSRR
    rsrr_init();
#endif /* RSRR */

    /*
     * Allow cleanup if unexpected exit.  Apparently some architectures
     * have a kernel bug where closing the socket doesn't do an
     * ip_mrouter_done(), so we attempt to do it on exit.
     */
    atexit(cleanup);

    if (debug)
	fprintf(stderr, "pruning %s\n", pruning ? "on" : "off");

    (void)signal(SIGALRM, fasttimer);

    (void)signal(SIGHUP,  restart);
    (void)signal(SIGTERM, done);
    (void)signal(SIGINT,  done);
    (void)signal(SIGUSR1, fdump);
    (void)signal(SIGUSR2, cdump);
    if (debug != 0)
	(void)signal(SIGQUIT, dump);

    pfd = calloc(sizeof(struct pollfd), 1 + nhandlers);
    pfd[0].fd = igmp_socket;
    pfd[0].events = POLLIN;
    for (i = 0; i < nhandlers; i++) {
	pfd[i + 1].fd = ihandlers[i].fd;
	pfd[i + 1].events = POLLIN;
    }

    /*
     * Install the vifs in the kernel as late as possible in the
     * initialization sequence.
     */
    init_installvifs();

    if (debug >= 2) dump(0);

    /* Start up the log rate-limiter */
    resetlogging(NULL);

    (void)alarm(1);	 /* schedule first timer interrupt */

    /*
     * Main receive loop.
     */
    dummy = 0;
    for(;;) {
	if ((n = poll(pfd, nhandlers + 1, -1)) < 0) {
            if (errno != EINTR) /* SIGALRM is expected */
                logit(LOG_WARNING, errno, "poll failed");
            continue;
        }

	if (pfd[0].revents & POLLIN) {
	    recvlen = recvfrom(igmp_socket, recv_buf, RECV_BUF_SIZE,
			       0, NULL, &dummy);
	    if (recvlen < 0) {
		if (errno != EINTR) logit(LOG_ERR, errno, "recvfrom");
		continue;
	    }
	    (void)sigemptyset(&mask);
	    (void)sigaddset(&mask, SIGALRM);
	    if (sigprocmask(SIG_BLOCK, &mask, &omask) < 0)
		    logit(LOG_ERR, errno, "sigprocmask");
	    accept_igmp(recvlen);
	    (void)sigprocmask(SIG_SETMASK, &omask, NULL);
        }

	for (i = 0; i < nhandlers; i++) {
	    if (pfd[i + 1].revents & POLLIN) {
		(*ihandlers[i].func)(ihandlers[i].fd);
	    }
	}
    }
}


/*
 * routine invoked every second.  Its main goal is to cycle through
 * the routing table and send partial updates to all neighbors at a
 * rate that will cause the entire table to be sent in ROUTE_REPORT_INTERVAL
 * seconds.  Also, every TIMER_INTERVAL seconds it calls timer() to
 * do all the other time-based processing.
 */
/* XXX signal race */
static void
fasttimer(int i)
{
    static unsigned int tlast;
    static unsigned int nsent;
    unsigned int t = tlast + 1;
    int n;

    /*
     * if we're in the last second, send everything that's left.
     * otherwise send at least the fraction we should have sent by now.
     */
    if (t >= ROUTE_REPORT_INTERVAL) {
	int nleft = nroutes - nsent;
	while (nleft > 0) {
	    if ((n = report_next_chunk()) <= 0)
		break;
	    nleft -= n;
	}
	tlast = 0;
	nsent = 0;
    } else {
	unsigned int ncum = nroutes * t / ROUTE_REPORT_INTERVAL;
	while (nsent < ncum) {
	    if ((n = report_next_chunk()) <= 0)
		break;
	    nsent += n;
	}
	tlast = t;
    }
    if ((t % TIMER_INTERVAL) == 0)
	timer();

    age_callout_queue();/* Advance the timer for the callout queue
				for groups */
    alarm(1);
}

/*
 * The 'virtual_time' variable is initialized to a value that will cause the
 * first invocation of timer() to send a probe or route report to all vifs
 * and send group membership queries to all subnets for which this router is
 * querier.  This first invocation occurs approximately TIMER_INTERVAL seconds
 * after the router starts up.   Note that probes for neighbors and queries
 * for group memberships are also sent at start-up time, as part of initial-
 * ization.  This repetition after a short interval is desirable for quickly
 * building up topology and membership information in the presence of possible
 * packet loss.
 *
 * 'virtual_time' advances at a rate that is only a crude approximation of
 * real time, because it does not take into account any time spent processing,
 * and because the timer intervals are sometimes shrunk by a random amount to
 * avoid unwanted synchronization with other routers.
 */

static u_long virtual_time = 0;


/*
 * Timer routine.  Performs periodic neighbor probing, route reporting, and
 * group querying duties, and drives various timers in routing entries and
 * virtual interface data structures.
 */
static void
timer(void)
{
    age_routes();	/* Advance the timers in the route entries     */
    age_vifs();		/* Advance the timers for neighbors */
    age_table_entry();	/* Advance the timers for the cache entries */

    if (virtual_time % GROUP_QUERY_INTERVAL == 0) {
	/*
	 * Time to query the local group memberships on all subnets
	 * for which this router is the elected querier.
	 */
	query_groups();
    }

    if (virtual_time % NEIGHBOR_PROBE_INTERVAL == 0) {
	/*
	 * Time to send a probe on all vifs from which no neighbors have
	 * been heard.  Also, check if any inoperative interfaces have now
	 * come up.  (If they have, they will also be probed as part of
	 * their initialization.)
	 */
	probe_for_neighbors();

	if (vifs_down)
	    check_vif_state();
    }

    delay_change_reports = FALSE;
    if (routes_changed) {
	/*
	 * Some routes have changed since the last timer interrupt, but
	 * have not been reported yet.  Report the changed routes to all
	 * neighbors.
	 */
	report_to_all_neighbors(CHANGED_ROUTES);
    }

    /*
     * Advance virtual time
     */
    virtual_time += TIMER_INTERVAL;
}


/*
 * On termination, let everyone know we're going away.
 */
/* XXX signal race */
static void
done(int i)
{
    logit(LOG_NOTICE, 0, "%s exiting", versionstring);
    cleanup();
    _exit(1);
}

/* XXX signal race, atexit race */
static void
cleanup(void)
{
    static int in_cleanup = 0;

    if (!in_cleanup) {
	in_cleanup++;
#ifdef RSRR
	rsrr_clean();
#endif /* RSRR */
	expire_all_routes();
	report_to_all_neighbors(ALL_ROUTES);
	k_stop_dvmrp();
    }
}


/*
 * Dump internal data structures to stderr.
 */
/* XXX signal race */
static void
dump(int i)
{
    dump_vifs(stderr);
    dump_routes(stderr);
}


/*
 * Dump internal data structures to a file.
 */
static void
fdump(int i)
{
    FILE *fp;

    fp = fopen(dumpfilename, "w");
    if (fp != NULL) {
	dump_vifs(fp);
	dump_routes(fp);
	(void) fclose(fp);
    }
}


/*
 * Dump local cache contents to a file.
 */
/* XXX signal race */
static void
cdump(int i)
{
    FILE *fp;

    fp = fopen(cachefilename, "w");
    if (fp != NULL) {
	dump_cache(fp);
	(void) fclose(fp);
    }
}


/*
 * Restart mrouted
 */
/* XXX signal race */
static void
restart(int i)
{
    sigset_t mask, omask;

    logit(LOG_NOTICE, 0, "%s restart", versionstring);

    /*
     * reset all the entries
     */
    (void)sigemptyset(&mask);
    (void)sigaddset(&mask, SIGALRM);
    if (sigprocmask(SIG_BLOCK, &mask, &omask) < 0)
	logit(LOG_ERR, errno, "sigprocmask");
    free_all_prunes();
    free_all_routes();
    stop_all_vifs();
    k_stop_dvmrp();
    close(igmp_socket);
    close(udp_socket);

    /*
     * start processing again
     */
    dvmrp_genid++;
    pruning = 1;

    init_igmp();
    init_routes();
    init_ktable();
    init_vifs();
    k_init_dvmrp();		/* enable DVMRP routing in kernel */
    init_installvifs();

    (void)sigprocmask(SIG_SETMASK, &omask, NULL);
}

#define LOG_MAX_MSGS	20	/* if > 20/minute then shut up for a while */
#define LOG_SHUT_UP	600	/* shut up for 10 minutes */
static int log_nmsgs = 0;

static void
resetlogging(void *arg)
{
    int nxttime = 60;
    void *narg = NULL;

    if (arg == NULL && log_nmsgs > LOG_MAX_MSGS) {
	nxttime = LOG_SHUT_UP;
	narg = (void *)&log_nmsgs;	/* just need some valid void * */
	syslog(LOG_WARNING, "logging too fast, shutting up for %d minutes",
			LOG_SHUT_UP / 60);
    } else {
	log_nmsgs = 0;
    }

    timer_setTimer(nxttime, resetlogging, narg);
}

/*
 * Log errors and other messages to the system log daemon and to stderr,
 * according to the severity of the message and the current debug level.
 * For errors of severity LOG_ERR or worse, terminate the program.
 */
void
logit(int severity, int syserr, char *format, ...)
{
    va_list ap;
    static char fmt[211] = "warning - ";
    char *msg;
    char tbuf[20];
    struct timeval now;
    struct tm *thyme;
    time_t t;

    va_start(ap, format);
    vsnprintf(&fmt[10], sizeof fmt - 10, format, ap);
    va_end(ap);
    msg = (severity == LOG_WARNING) ? fmt : &fmt[10];

    switch (debug) {
	case 0: break;
	case 1: if (severity > LOG_NOTICE) break;
	case 2: if (severity > LOG_INFO  ) break;
	default:
	    gettimeofday(&now,NULL);
	    t = now.tv_sec;
	    thyme = localtime(&t);
	    strftime(tbuf, sizeof(tbuf), "%X.%%03d ", thyme);
	    fprintf(stderr, tbuf, now.tv_usec / 1000);
	    fprintf(stderr, "%s", msg);
	    if (syserr == 0)
		fprintf(stderr, "\n");
	    else if (syserr < sys_nerr)
		fprintf(stderr, ": %s\n", sys_errlist[syserr]);
	    else
		fprintf(stderr, ": errno %d\n", syserr);
    }

    if (severity <= LOG_NOTICE) {
	if (log_nmsgs++ < LOG_MAX_MSGS) {
	    if (syserr != 0) {
		errno = syserr;
		syslog(severity, "%s: %m", msg);
	    } else
		syslog(severity, "%s", msg);
	}

	if (severity <= LOG_ERR) exit(1);
    }
}

#ifdef DEBUG_MFC
void
md_logit(int what, u_int32_t origin, u_int32_t mcastgrp)
{
    static FILE *f = NULL;
    struct timeval tv;
    u_int32_t buf[4];

    if (!f) {
	if ((f = fopen("/tmp/mrouted.clog", "w")) == NULL) {
	    logit(LOG_ERR, errno, "open /tmp/mrouted.clog");
	}
    }

    gettimeofday(&tv, NULL);
    buf[0] = tv.tv_sec;
    buf[1] = what;
    buf[2] = origin;
    buf[3] = mcastgrp;

    fwrite(buf, sizeof(u_int32_t), 4, f);
}
#endif
@


1.29
log
@use symbolics for flags to open
from Ricardo Mestre
@
text
@d118 1
a118 1
    
@


1.28
log
@daemon() equivelant should open /dev/null; ok millert
@
text
@d142 1
a142 1
	t = open("/dev/tty", 2);
@


1.27
log
@remove util.h include and -lutil after pidfile removal

ok deraadt
@
text
@d135 1
a135 1
	(void)open("/", 0);
@


1.26
log
@stop using pidfile()
ok benno jung jca
@
text
@a25 1
#include <util.h>
@


1.25
log
@Prefer setvbuf() to setlinebuf() for portability; ok deraadt@@
@
text
@a221 2
    pidfile(NULL);

@


1.24
log
@c99 no longer allows implicit ints. make the declaration explicit.

ok henning@@
@
text
@d92 1
a92 1
    setlinebuf(stderr);
@


1.23
log
@use arc4random_uniform(); ok djm
plus some other markings about signal races...
@
text
@d422 1
a422 1
    static in_cleanup = 0;
@


1.22
log
@deregister. no binary change.
@
text
@a167 6
#ifdef SYSV
    srand48(time(NULL));
#else
    srandom(gethostid());
#endif

d297 1
d409 1
d418 1
d439 1
d468 1
d485 1
@


1.21
log
@as in dvmrpd:
the DVMRP protocol generation number can work beyond 2038 because it
is unsigned.  Cast it specifically, with a comment, to make this more
clear.
@
text
@d78 1
a78 1
    register int recvlen;
d308 2
a309 2
    register unsigned int t = tlast + 1;
    register int n;
d316 1
a316 1
	register int nleft = nroutes - nsent;
d325 1
a325 1
	register unsigned int ncum = nroutes * t / ROUTE_REPORT_INTERVAL;
@


1.20
log
@convert select to poll, since the select code had descriptor limits
ok tedu
@
text
@d81 1
a81 1
    struct timeval tv;
d177 2
a178 2
    gettimeofday(&tv, 0);
    dvmrp_genid = tv.tv_sec;
@


1.19
log
@fix missing err.h includes
@
text
@d25 1
d45 2
a46 2
    int fd;			/* File descriptor		 */
    ihfunc_t func;		/* Function to call with &fd_set */
d83 2
a84 3
    int vers;
    fd_set rfds, readers;
    int nfds, n, i, ch;
d240 3
a242 5
    FD_ZERO(&readers);
    if (igmp_socket >= FD_SETSIZE)
	logit(LOG_ERR, 0, "descriptor too big");
    FD_SET(igmp_socket, &readers);
    nfds = igmp_socket + 1;
d244 2
a245 5
	if (ihandlers[i].fd >= FD_SETSIZE)
	    logit(LOG_ERR, 0, "descriptor too big");
	FD_SET(ihandlers[i].fd, &readers);
	if (ihandlers[i].fd >= nfds)
	    nfds = ihandlers[i].fd + 1;
d266 1
a266 2
	bcopy((char *)&readers, (char *)&rfds, sizeof(rfds));
	if ((n = select(nfds, &rfds, NULL, NULL, NULL)) < 0) {
d268 1
a268 1
                logit(LOG_WARNING, errno, "select failed");
d272 1
a272 1
	if (FD_ISSET(igmp_socket, &rfds)) {
d288 2
a289 2
	    if (FD_ISSET(ihandlers[i].fd, &rfds)) {
		(*ihandlers[i].func)(ihandlers[i].fd, &rfds);
@


1.18
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d26 1
@


1.17
log
@tidy up synopsis and usage; from Igor Sobrado
@
text
@a26 5
#ifndef lint
static char rcsid[] =
	"@@(#) $Id: main.c,v 1.16 2005/06/16 19:41:23 robert Exp $";
#endif

@


1.16
log
@use getopt() for argument list parsing

ok millert@@ otto@@
@
text
@d29 1
a29 1
	"@@(#) $Id: main.c,v 1.15 2005/06/15 14:30:56 robert Exp $";
d126 1
a126 1
		"usage: mrouted [-p] [-c configfile] [-d [debug_level]]\n");
@


1.15
log
@remove SNMP code from mrouted(8) because it is broken and it is
higly unlike that anyone will use this.

ok otto@@ millert@@ henning@@
@
text
@d29 1
a29 1
	"@@(#) $Id: main.c,v 1.14 2003/11/26 01:17:12 millert Exp $";
d88 1
a88 1
    int nfds, n, i;
d90 1
d98 22
a119 19
    argv++, argc--;
    while (argc > 0 && *argv[0] == '-') {
	if (strcmp(*argv, "-d") == 0) {
	    if (argc > 1 && isdigit(*(argv + 1)[0])) {
		argv++, argc--;
		debug = atoi(*argv);
	    } else
		debug = DEFAULT_DEBUG;
	} else if (strcmp(*argv, "-c") == 0) {
	    if (argc > 1) {
		argv++, argc--;
		configfilename = *argv;
	    } else
		goto usage;
	} else if (strcmp(*argv, "-p") == 0) {
	    pruning = 0;
	} else
	    goto usage;
	argv++, argc--;
d121 3
a123 1

@


1.14
log
@Replace log() with logit() since ISO C reserves log() for the math
library and gcc 3.x will complain.  Replacement name taken from NetBSD.
espie@@ OK.
@
text
@a26 4
#ifdef SNMP
#include "snmp.h"
#endif

d29 1
a29 1
	"@@(#) $Id: main.c,v 1.13 2003/03/12 22:55:01 deraadt Exp $";
a44 3
#ifdef SNMP
#define NHANDLERS	34
#else
a45 1
#endif
a89 5
#ifdef SNMP
    struct timeval  timeout, *tvp = &timeout;
    struct timeval  sched, *svp = &sched, now, *nvp = &now;
    int index, block;
#endif
a112 8
#ifdef SNMP
   } else if (strcmp(*argv, "-P") == 0) {
	    if (argc > 1 && isdigit(*(argv + 1)[0])) {
		argv++, argc--;
		dest_port = atoi(*argv);
	    } else
		dest_port = DEFAULT_PORT;
#endif
a209 14
#ifdef SNMP
    if (i = snmp_init())
       return i;

    gettimeofday(nvp, 0);
    if (nvp->tv_usec < 500000L){
   svp->tv_usec = nvp->tv_usec + 500000L;
   svp->tv_sec = nvp->tv_sec;
    } else {
   svp->tv_usec = nvp->tv_usec - 500000L;
   svp->tv_sec = nvp->tv_sec + 1;
    }
#endif /* SNMP */

d270 1
a270 28
#ifdef SNMP
   gettimeofday(nvp, 0);
   if (nvp->tv_sec > svp->tv_sec
       || (nvp->tv_sec == svp->tv_sec && nvp->tv_usec > svp->tv_usec)){
       alarmTimer(nvp);
       eventTimer(nvp);
       if (nvp->tv_usec < 500000L){
      svp->tv_usec = nvp->tv_usec + 500000L;
      svp->tv_sec = nvp->tv_sec;
       } else {
      svp->tv_usec = nvp->tv_usec - 500000L;
      svp->tv_sec = nvp->tv_sec + 1;
       }
   }

	tvp =  &timeout;
	tvp->tv_sec = 0;
	tvp->tv_usec = 500000L;

	block = 0;
	snmp_select_info(&nfds, &rfds, tvp, &block);
	if (block == 1)
		tvp = NULL; /* block without timeout */
	if ((n = select(nfds, &rfds, NULL, NULL, tvp)) < 0)
#else
	if ((n = select(nfds, &rfds, NULL, NULL, NULL)) < 0)
#endif
   {
a295 5

#ifdef SNMP
	snmp_read(&rfds);
	snmp_timeout(); /* poll */
#endif
a406 4

#ifdef SNMP
    sync_timer();
#endif
@


1.13
log
@less sprintf
@
text
@d33 1
a33 1
	"@@(#) $Id: main.c,v 1.12 2003/03/03 15:14:28 deraadt Exp $";
d185 1
a185 1
    log(LOG_NOTICE, 0, "%s", versionstring);
d226 1
a226 1
	log(LOG_ERR, 0, "kernel (v%d.%d)/mrouted (v%d.%d) version mismatch",
d275 1
a275 1
	log(LOG_ERR, 0, "descriptor too big");
d280 1
a280 1
	    log(LOG_ERR, 0, "descriptor too big");
d334 1
a334 1
                log(LOG_WARNING, errno, "select failed");
d342 1
a342 1
		if (errno != EINTR) log(LOG_ERR, errno, "recvfrom");
d348 1
a348 1
		    log(LOG_ERR, errno, "sigprocmask");
d492 1
a492 1
    log(LOG_NOTICE, 0, "%s exiting", versionstring);
d566 1
a566 1
    log(LOG_NOTICE, 0, "%s restart", versionstring);
d574 1
a574 1
	log(LOG_ERR, errno, "sigprocmask");
d626 1
a626 1
log(int severity, int syserr, char *format, ...)
d675 1
a675 1
md_log(int what, u_int32_t origin, u_int32_t mcastgrp)
d683 1
a683 1
	    log(LOG_ERR, errno, "open /tmp/mrouted.clog");
@


1.12
log
@spaces
@
text
@d33 1
a33 1
	"@@(#) $Id: main.c,v 1.11 2003/03/03 14:58:23 deraadt Exp $";
d182 1
a182 1
    sprintf(versionstring, "mrouted version %d.%d",
d637 1
a637 1
    vsprintf(&fmt[10], format, ap);
@


1.11
log
@ansi, from cloder
@
text
@d33 1
a33 1
	"@@(#) $Id: main.c,v 1.10 2002/08/09 02:27:16 itojun Exp $";
d43 2
a44 2
int cache_lifetime 	= DEFAULT_CACHE_LIFETIME;
int max_prune_lifetime 	= DEFAULT_CACHE_LIFETIME * 2;
d140 1
a140 1
usage:	fprintf(stderr, 
d194 1
a194 1
     * Get generation id 
d328 1
a328 1
	if ((n = select(nfds, &rfds, NULL, NULL, tvp)) < 0) 
d330 1
a330 1
	if ((n = select(nfds, &rfds, NULL, NULL, NULL)) < 0) 
d360 1
a360 1
	snmp_read(&rfds); 
d408 1
a408 1
				for groups */	
d552 1
a552 1
	dump_cache(fp); 
@


1.10
log
@die if fd_set overruns.
@
text
@d33 1
a33 1
	"@@(#) $Id: main.c,v 1.9 2002/02/19 19:39:40 millert Exp $";
a73 3
/* To shut up gcc -Wstrict-prototypes */
int main(int argc, char **argv);

d75 1
a75 3
register_input_handler(fd, func)
    int fd;
    ihfunc_t func;
d87 1
a87 3
main(argc, argv)
    int argc;
    char *argv[];
d375 1
a375 2
fasttimer(i)
    int i;
d438 1
a438 1
timer()
d490 1
a490 2
done(i)
    int i;
d498 1
a498 1
cleanup()
d518 1
a518 2
dump(i)
    int i;
d529 1
a529 2
fdump(i)
    int i;
d546 1
a546 2
cdump(i)
    int i;
d562 1
a562 2
restart(i)
    int i;
d603 1
a603 2
resetlogging(arg)
    void *arg;
d675 1
a675 3
md_log(what, origin, mcastgrp)
    int what;
    u_int32_t origin, mcastgrp;
@


1.9
log
@We live in an ANSI C world.  Remove lots of gratuitous #ifdef __STDC__ cruft.
@
text
@d33 1
a33 1
	"@@(#) $Id: main.c,v 1.8 2002/02/16 21:28:05 millert Exp $";
d281 2
d286 2
@


1.8
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@a22 1
#ifdef __STDC__
a23 3
#else
#include <varargs.h>
#endif
d33 1
a33 1
	"@@(#) $Id: main.c,v 1.7 2001/12/01 23:27:23 miod Exp $";
a257 1
#if defined(__STDC__) || defined(__GNUC__)
a263 1
#endif
a634 1
#ifdef __STDC__
a646 18
#else
/*VARARGS3*/
void
log(severity, syserr, format, va_alist)
    int severity, syserr;
    char *format;
    va_dcl
{
    va_list ap;
    static char fmt[211] = "warning - ";
    char *msg;
    char tbuf[20];
    struct timeval now;
    struct tm *thyme;
    time_t t;

    va_start(ap);
#endif
@


1.7
log
@Use pidfile() instead of doing the equivalent thing by hand, and sometimes
forgetting to unlink the pid file at exit.
ok millert@@ deraadt@@
@
text
@d37 1
a37 1
	"@@(#) $Id: main.c,v 1.6 2001/09/04 23:35:59 millert Exp $";
d68 9
a76 9
static void fasttimer __P((int));
static void done __P((int));
static void dump __P((int));
static void fdump __P((int));
static void cdump __P((int));
static void restart __P((int));
static void timer __P((void));
static void cleanup __P((void));
static void resetlogging __P((void *));
d79 1
a79 1
int main __P((int argc, char **argv));
@


1.6
log
@Replace the deprecated BSD sigsetmask/sigblock/sigpause functions with their POSIX counterparts.
@
text
@d29 1
d37 1
a37 1
	"@@(#) $Id: main.c,v 1.5 2001/03/09 03:24:07 deraadt Exp $";
a42 1
static char pidfilename[]  = _PATH_MROUTED_PID;
d274 1
a274 5
    fp = fopen(pidfilename, "w");		
    if (fp != NULL) {
	fprintf(fp, "%d\n", (int)getpid());
	(void) fclose(fp);
    }
@


1.5
log
@exit(-#) is wrong
@
text
@d36 1
a36 1
	"@@(#) $Id: main.c,v 1.4 1996/09/11 19:15:33 deraadt Exp $";
a100 1
    register int omask;
d108 1
a316 3
#ifdef SYSV
	sigset_t block, oblock;
#endif
d358 3
a360 4
#ifdef SYSV
	    (void)sigemptyset(&block);
	    (void)sigaddset(&block, SIGALRM);
	    if (sigprocmask(SIG_BLOCK, &block, &oblock) < 0)
a361 3
#else
	    omask = sigblock(sigmask(SIGALRM));
#endif
d363 1
a363 5
#ifdef SYSV
	    (void)sigprocmask(SIG_SETMASK, &oblock, (sigset_t *)NULL);
#else
	    (void)sigsetmask(omask);
#endif
d583 1
a583 4
    register int omask;
#ifdef SYSV
    sigset_t block, oblock;
#endif
d590 3
a592 4
#ifdef SYSV
    (void)sigemptyset(&block);
    (void)sigaddset(&block, SIGALRM);
    if (sigprocmask(SIG_BLOCK, &block, &oblock) < 0)
a593 3
#else
    omask = sigblock(sigmask(SIGALRM));
#endif
d614 1
a614 5
#ifdef SYSV
    (void)sigprocmask(SIG_SETMASK, &oblock, (sigset_t *)NULL);
#else
    (void)sigsetmask(omask);
#endif
@


1.4
log
@revoke privs at start; tested by fenner@@parc.xerox.com
@
text
@d36 1
a36 1
	"@@(#) $Id: main.c,v 1.3 1995/12/19 17:48:04 deraadt Exp $";
d730 1
a730 1
	if (severity <= LOG_ERR) exit(-1);
@


1.3
log
@from netbsd: tv_sec isn't a time_t, but a long. this causes some problems..
@
text
@d36 1
a36 1
	"@@(#) $Id: main.c,v 1.2 1995/12/14 01:45:26 deraadt Exp $";
a114 2
    setlinebuf(stderr);

d119 1
@


1.2
log
@from netbsd; update to mrouted 3.8
@
text
@d36 1
a36 1
	"@@(#) $Id: main.c,v 1.6 1995/12/10 10:07:05 mycroft Exp $";
d678 1
d695 1
d709 2
a710 1
	    thyme = localtime(&now.tv_sec);
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: main.c,v 1.5 1995/10/09 03:51:44 thorpej Exp $	*/
d23 3
a25 1
#include <string.h>
d27 2
d34 5
d40 1
d53 3
d57 1
d61 1
a61 1
    void (*func)();		/* Function to call with &fd_set */
d68 12
a79 8
static void fasttimer();
static void timer();
static void cleanup();
static void done();
static void dump();
static void fdump();
static void cdump();
static void restart();
d84 1
a84 1
    void (*func)();
d95 2
a96 1
int main(argc, argv)
a103 1
    extern uid_t geteuid();
d105 1
a105 1
    u_long prev_genid;
d110 3
a112 9
    char *myname;
    fd_set wfds;
  

    if (myname = strrchr(argv[0], '/'))
        myname++;
    if (myname == NULL || *myname == 0)
        myname = argv[0];
    isodetailor (myname, 0);
a114 3
#ifdef SYSV
    setvbuf(stderr, NULL, _IOLBF, 0);
#else
a115 1
#endif
d138 8
d170 3
d183 1
d194 1
a194 1
    log(LOG_NOTICE, 0, "mrouted version %d.%d",
d197 2
a225 5

#ifdef SNMP
    snmp_init();
#endif

d227 2
d233 5
a237 2
    if ((((vers >> 8) & 0xff) != PROTOCOL_VERSION) ||
	 ((vers & 0xff) != MROUTED_VERSION))
d243 14
a256 2
    init_routes();
    init_ktable();
d258 1
d264 2
a265 1
    /* Allow cleanup if unexpected exit.  Apparently some architectures
d277 1
a277 1
	fprintf(fp, "%d\n", getpid());
a280 2
    if (debug >= 2) dump();

d300 11
d318 3
d323 23
a345 12
        FD_ZERO(&wfds);
  
        if (smux_fd != NOTOK) {
           if (rock_and_roll)
              FD_SET(smux_fd, &rfds);
           else
              FD_SET(smux_fd, &wfds);
           if (smux_fd >= nfds)
              nfds = smux_fd + 1;
        }
  
        if ((n = xselect(nfds, &rfds, &wfds, NULLFD, NOTOK))==NOTOK) {
d347 1
a347 1
	if ((n = select(nfds, &rfds, NULL, NULL, NULL)) < 0) {
d349 1
d362 6
d369 1
d371 3
d375 1
d380 1
a380 1
		(*ihandlers[i].func)(&rfds);
d385 2
a386 7
        if (smux_fd != NOTOK) {
            if (rock_and_roll) {
		if (FD_ISSET(smux_fd, &rfds))
		    doit_smux();
	    } else if (FD_ISSET(smux_fd, &wfds)) 
                start_smux();
        }
d400 2
a401 1
fasttimer()
d502 1
a502 7
    if (smux_fd == NOTOK && !dont_bother_anymore
		 && virtual_time % SNMPD_RETRY_INTERVAL == 0) {
	/*
	 * Time to check for snmpd running.
	 */
        try_smux_init();
    }
d516 2
a517 1
done()
d519 1
a519 2
    log(LOG_NOTICE, 0, "mrouted version %d.%d exiting",
			PROTOCOL_VERSION, MROUTED_VERSION);
d545 2
a546 1
dump()
d557 2
a558 1
fdump()
d575 2
a576 1
cdump()
d592 2
a593 1
restart()
d596 3
d600 1
a600 2
    log(LOG_NOTICE, 0, "mrouted version %d.%d restart",
			PROTOCOL_VERSION, MROUTED_VERSION);
d605 6
d612 1
a626 1
    k_init_dvmrp();		/* enable DVMRP routing in kernel */
d630 2
d633 3
d637 1
d640 22
d668 13
d696 1
d707 1
a707 1
	    thyme = localtime((time_t *)&now.tv_sec);
d713 2
d716 1
a716 1
		fprintf(stderr, ": %s\n", strerror(syserr));
d720 7
a726 5
	if (syserr != 0) {
	    errno = syserr;
	    syslog(severity, "%s: %m", msg);
	} else
	    syslog(severity, "%s", msg);
d731 26
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
