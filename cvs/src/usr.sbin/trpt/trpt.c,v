head	1.34;
access;
symbols
	OPENBSD_6_1_BASE:1.34
	OPENBSD_6_0:1.32.0.4
	OPENBSD_6_0_BASE:1.32
	OPENBSD_5_9:1.32.0.2
	OPENBSD_5_9_BASE:1.32
	OPENBSD_5_8:1.31.0.6
	OPENBSD_5_8_BASE:1.31
	OPENBSD_5_7:1.31.0.2
	OPENBSD_5_7_BASE:1.31
	OPENBSD_5_6:1.28.0.16
	OPENBSD_5_6_BASE:1.28
	OPENBSD_5_5:1.28.0.14
	OPENBSD_5_5_BASE:1.28
	OPENBSD_5_4:1.28.0.10
	OPENBSD_5_4_BASE:1.28
	OPENBSD_5_3:1.28.0.8
	OPENBSD_5_3_BASE:1.28
	OPENBSD_5_2:1.28.0.6
	OPENBSD_5_2_BASE:1.28
	OPENBSD_5_1_BASE:1.28
	OPENBSD_5_1:1.28.0.4
	OPENBSD_5_0:1.28.0.2
	OPENBSD_5_0_BASE:1.28
	OPENBSD_4_9:1.26.0.4
	OPENBSD_4_9_BASE:1.26
	OPENBSD_4_8:1.26.0.2
	OPENBSD_4_8_BASE:1.26
	OPENBSD_4_7:1.25.0.2
	OPENBSD_4_7_BASE:1.25
	OPENBSD_4_6:1.24.0.8
	OPENBSD_4_6_BASE:1.24
	OPENBSD_4_5:1.24.0.4
	OPENBSD_4_5_BASE:1.24
	OPENBSD_4_4:1.24.0.2
	OPENBSD_4_4_BASE:1.24
	OPENBSD_4_3:1.23.0.6
	OPENBSD_4_3_BASE:1.23
	OPENBSD_4_2:1.23.0.4
	OPENBSD_4_2_BASE:1.23
	OPENBSD_4_1:1.23.0.2
	OPENBSD_4_1_BASE:1.23
	OPENBSD_4_0:1.22.0.2
	OPENBSD_4_0_BASE:1.22
	OPENBSD_3_9:1.21.0.4
	OPENBSD_3_9_BASE:1.21
	OPENBSD_3_8:1.21.0.2
	OPENBSD_3_8_BASE:1.21
	OPENBSD_3_7:1.20.0.2
	OPENBSD_3_7_BASE:1.20
	OPENBSD_3_6:1.19.0.4
	OPENBSD_3_6_BASE:1.19
	OPENBSD_3_5:1.19.0.2
	OPENBSD_3_5_BASE:1.19
	OPENBSD_3_4:1.18.0.2
	OPENBSD_3_4_BASE:1.18
	OPENBSD_3_3:1.15.0.2
	OPENBSD_3_3_BASE:1.15
	OPENBSD_3_2:1.13.0.2
	OPENBSD_3_2_BASE:1.13
	OPENBSD_3_1:1.12.0.2
	OPENBSD_3_1_BASE:1.12
	OPENBSD_3_0:1.8.0.8
	OPENBSD_3_0_BASE:1.8
	OPENBSD_2_9_BASE:1.8
	OPENBSD_2_9:1.8.0.6
	OPENBSD_2_8:1.8.0.4
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.8.0.2
	OPENBSD_2_7_BASE:1.8
	OPENBSD_2_6:1.7.0.6
	OPENBSD_2_6_BASE:1.7
	OPENBSD_2_5:1.7.0.4
	OPENBSD_2_5_BASE:1.7
	OPENBSD_2_4:1.7.0.2
	OPENBSD_2_4_BASE:1.7
	OPENBSD_2_3:1.6.0.4
	OPENBSD_2_3_BASE:1.6
	OPENBSD_2_2:1.6.0.2
	OPENBSD_2_2_BASE:1.6
	OPENBSD_2_1:1.5.0.2
	OPENBSD_2_1_BASE:1.5
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.34
date	2016.12.23.03.08.32;	author lteo;	state Exp;
branches;
next	1.33;
commitid	cyXVNrHkzrgjK6AD;

1.33
date	2016.08.27.01.50.07;	author guenther;	state Exp;
branches;
next	1.32;
commitid	ikVlcUgcgDzn9GW3;

1.32
date	2015.11.20.15.52.57;	author deraadt;	state Exp;
branches;
next	1.31;
commitid	MqU46AisRsDdv7xs;

1.31
date	2015.02.09.23.00.15;	author deraadt;	state Exp;
branches;
next	1.30;
commitid	822YD61EeG0Xl9Na;

1.30
date	2015.01.16.06.40.22;	author deraadt;	state Exp;
branches;
next	1.29;
commitid	Uu5nFG3wCl0LACBb;

1.29
date	2014.11.26.18.34.52;	author millert;	state Exp;
branches;
next	1.28;
commitid	9QOFSShUOtA0kQLF;

1.28
date	2011.07.04.07.06.49;	author guenther;	state Exp;
branches;
next	1.27;

1.27
date	2011.07.04.02.31.35;	author halex;	state Exp;
branches;
next	1.26;

1.26
date	2010.05.26.17.49.57;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2009.10.27.23.59.57;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2008.06.26.05.42.21;	author ray;	state Exp;
branches;
next	1.23;

1.23
date	2007.02.18.23.22.33;	author jmc;	state Exp;
branches;
next	1.22;

1.22
date	2006.03.13.16.30.18;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2005.05.03.03.41.11;	author djm;	state Exp;
branches;
next	1.20;

1.20
date	2004.09.24.15.02.43;	author markus;	state Exp;
branches;
next	1.19;

1.19
date	2003.09.19.08.15.56;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2003.06.02.23.36.55;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2003.05.26.05.33.43;	author itojun;	state Exp;
branches;
next	1.16;

1.16
date	2003.05.14.01.12.27;	author jason;	state Exp;
branches;
next	1.15;

1.15
date	2002.12.09.09.53.34;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2002.11.18.05.15.39;	author itojun;	state Exp;
branches;
next	1.13;

1.13
date	2002.06.19.08.45.52;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2002.03.14.16.44.25;	author mpech;	state Exp;
branches;
next	1.11;

1.11
date	2002.03.08.17.22.24;	author mickey;	state Exp;
branches;
next	1.10;

1.10
date	2002.02.17.19.42.40;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2002.02.16.21.28.10;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2000.02.25.23.32.55;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	98.07.08.22.13.32;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	97.09.08.09.23.15;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	97.01.15.23.44.26;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	96.12.22.03.29.10;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.06.03.18.06.18;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.05.30.09.11.11;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.48.29;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.48.29;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.34
log
@Replace the archaic n_time data type with u_int32_t.  This also allows the
removal of the <netinet/in_systm.h> include.

ok mpi@@ stsp@@
@
text
@/*	$OpenBSD: trpt.c,v 1.33 2016/08/27 01:50:07 guenther Exp $	*/

/*-
 * Copyright (c) 1997 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Jason R. Thorpe of the Numerical Aerospace Simulation Facility,
 * NASA Ames Research Center.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Copyright (c) 1983, 1988, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/queue.h>
#include <sys/time.h>
#include <sys/socket.h>
#define PRUREQUESTS
#include <sys/protosw.h>
#define _KERNEL
#include <sys/timeout.h>		/* to get timeout_pending() and such */
#undef _KERNEL
#include <sys/file.h>

#include <net/route.h>
#include <net/if.h>

#include <netinet/in.h>
#include <netinet/ip.h>
#include <netinet/in_pcb.h>
#include <netinet/ip_var.h>
#include <netinet/tcp.h>
#define TCPSTATES
#include <netinet/tcp_fsm.h>
#include <netinet/tcp_seq.h>
#define	TCPTIMERS
#include <netinet/tcp_timer.h>
#include <netinet/tcp_var.h>
#include <netinet/tcpip.h>
#define	TANAMES
#include <netinet/tcp_debug.h>

#include <arpa/inet.h>

#include <err.h>
#include <stdio.h>
#include <errno.h>
#include <kvm.h>
#include <nlist.h>
#include <paths.h>
#include <limits.h>
#include <stdlib.h>
#include <unistd.h>

struct nlist nl[] = {
#define	N_TCP_DEBUG	0		/* no sysctl */
	{ "_tcp_debug" },
#define	N_TCP_DEBX	1		/* no sysctl */
	{ "_tcp_debx" },
	{ NULL },
};

int	tcp_debx;
struct	tcp_debug tcp_debug[TCP_NDEBUG];

static caddr_t tcp_pcbs[TCP_NDEBUG];
static u_int32_t ntime;
static int aflag, follow, sflag, tflag;

extern	char *__progname;

void	dotrace(caddr_t);
void	tcp_trace(short, short, struct tcpcb *, struct tcpiphdr *,
	    struct tcpipv6hdr *, int);
int	numeric(const void *, const void *);
void	usage(void);

kvm_t	*kd;

int
main(int argc, char *argv[])
{
	char *sys = NULL, *core = NULL, *cp, errbuf[_POSIX2_LINE_MAX];
	int ch, i, jflag = 0, npcbs = 0;
	unsigned long l;
	gid_t gid;

	while ((ch = getopt(argc, argv, "afjM:N:p:st")) != -1) {
		switch (ch) {
		case 'a':
			aflag = 1;
			break;
		case 'f':
			follow = 1;
			setvbuf(stdout, NULL, _IOLBF, 0);
			break;
		case 'j':
			jflag = 1;
			break;
		case 'p':
			if (npcbs >= TCP_NDEBUG)
				errx(1, "too many pcbs specified");
			errno = 0;
			l = strtoul(optarg, &cp, 16);
			tcp_pcbs[npcbs] = (caddr_t)l;
			if (*optarg == '\0' || *cp != '\0' || errno ||
			    (unsigned long)tcp_pcbs[npcbs] != l)
				errx(1, "invalid address: %s", optarg);
			npcbs++;
			break;
		case 's':
			sflag = 1;
			break;
		case 't':
			tflag = 1;
			break;
		case 'N':
			sys = optarg;
			break;
		case 'M':
			core = optarg;
			break;
		default:
			usage();
			/* NOTREACHED */
		}
	}
	argc -= optind;
	argv += optind;

	if (argc)
		usage();

	/*
	 * Discard setgid privileged if not the running kernel so that bad
	 * guys can't print interesting stuff from kernel memory.
	 */
	gid = getgid();
	if (core != NULL || sys != NULL)
		if (setresgid(gid, gid, gid) == -1)
			err(1, "setresgid");

	kd = kvm_openfiles(sys, core, NULL, O_RDONLY, errbuf);
	if (kd == NULL)
		errx(1, "can't open kmem: %s", errbuf);

	if (core == NULL && sys == NULL)
		if (setresgid(gid, gid, gid) == -1)
			err(1, "setresgid");

	if (kvm_nlist(kd, nl))
		errx(2, "%s: no namelist", sys ? sys : _PATH_UNIX);

	if (pledge("stdio", NULL) == -1)
		err(1, "pledge");

	if (kvm_read(kd, nl[N_TCP_DEBX].n_value, (char *)&tcp_debx,
	    sizeof(tcp_debx)) != sizeof(tcp_debx))
		errx(3, "tcp_debx: %s", kvm_geterr(kd));

	if (kvm_read(kd, nl[N_TCP_DEBUG].n_value, (char *)tcp_debug,
	    sizeof(tcp_debug)) != sizeof(tcp_debug))
		errx(3, "tcp_debug: %s", kvm_geterr(kd));

	/*
	 * If no control blocks have been specified, figure
	 * out how many distinct one we have and summarize
	 * them in tcp_pcbs for sorting the trace records
	 * below.
	 */
	if (npcbs == 0) {
		for (i = 0; i < TCP_NDEBUG; i++) {
			struct tcp_debug *td = &tcp_debug[i];
			int j;

			if (td->td_tcb == 0)
				continue;
			for (j = 0; j < npcbs; j++)
				if (tcp_pcbs[j] == td->td_tcb)
					break;
			if (j >= npcbs)
				tcp_pcbs[npcbs++] = td->td_tcb;
		}
		if (npcbs == 0)
			exit(0);
	}
	qsort(tcp_pcbs, npcbs, sizeof(caddr_t), numeric);
	if (jflag) {
		for (i = 0;;) {
			printf("%lx", (long)tcp_pcbs[i]);
			if (++i == npcbs)
				break;
			fputs(", ", stdout);
		}
		putchar('\n');
	} else {
		for (i = 0; i < npcbs; i++) {
			printf("\n%lx:\n", (long)tcp_pcbs[i]);
			dotrace(tcp_pcbs[i]);
		}
	}
	exit(0);
}

void
dotrace(caddr_t tcpcb)
{
	struct tcp_debug *td;
	int prev_debx = tcp_debx;
	int i;

 again:
	if (--tcp_debx < 0)
		tcp_debx = TCP_NDEBUG - 1;
	for (i = prev_debx % TCP_NDEBUG; i < TCP_NDEBUG; i++) {
		td = &tcp_debug[i];
		if (tcpcb && td->td_tcb != tcpcb)
			continue;
		ntime = ntohl(td->td_time);
		tcp_trace(td->td_act, td->td_ostate,
		    &td->td_cb, &td->td_ti,
		    &td->td_ti6, td->td_req);
		if (i == tcp_debx)
			goto done;
	}
	for (i = 0; i <= tcp_debx % TCP_NDEBUG; i++) {
		td = &tcp_debug[i];
		if (tcpcb && td->td_tcb != tcpcb)
			continue;
		ntime = ntohl(td->td_time);
		tcp_trace(td->td_act, td->td_ostate,
		    &td->td_cb, &td->td_ti,
		    &td->td_ti6, td->td_req);
	}
 done:
	if (follow) {
		prev_debx = tcp_debx + 1;
		if (prev_debx >= TCP_NDEBUG)
			prev_debx = 0;
		do {
			sleep(1);
			if (kvm_read(kd, nl[N_TCP_DEBX].n_value,
			    (char *)&tcp_debx, sizeof(tcp_debx)) !=
			    sizeof(tcp_debx))
				errx(3, "tcp_debx: %s", kvm_geterr(kd));
		} while (tcp_debx == prev_debx);

		if (kvm_read(kd, nl[N_TCP_DEBUG].n_value, (char *)tcp_debug,
		    sizeof(tcp_debug)) != sizeof(tcp_debug))
			errx(3, "tcp_debug: %s", kvm_geterr(kd));

		goto again;
	}
}

/*
 * Tcp debug routines
 */
/*ARGSUSED*/
void
tcp_trace(short act, short ostate, struct tcpcb *tp,
    struct tcpiphdr *ti, struct tcpipv6hdr *ti6, int req)
{
	tcp_seq seq, ack;
	int flags, len, win, timer;
	struct tcphdr *th;
	char hbuf[INET6_ADDRSTRLEN];

	if (ti->ti_src.s_addr)
		th = &ti->ti_t;
	else
		th = &ti6->ti6_t;

	printf("%03d %s:%s ", (ntime/10) % 1000, tcpstates[ostate],
	    tanames[act]);
	switch (act) {
	case TA_INPUT:
	case TA_OUTPUT:
	case TA_DROP:
		if (aflag) {
			if (ti->ti_src.s_addr) {
				printf("(src=%s,%u, ",
				    inet_ntoa(ti->ti_src), ntohs(ti->ti_sport));
				printf("dst=%s,%u)",
				    inet_ntoa(ti->ti_dst), ntohs(ti->ti_dport));
			} else {
				printf("(src=%s,%u, ",
				    inet_ntop(AF_INET6, &ti6->ti6_src,
				    hbuf, sizeof(hbuf)), ntohs(ti->ti_sport));
				printf("dst=%s,%u)",
				    inet_ntop(AF_INET6, &ti6->ti6_dst,
				    hbuf, sizeof(hbuf)), ntohs(ti->ti_dport));
			}
		}
		seq = th->th_seq;
		ack = th->th_ack;
		if (ti->ti_src.s_addr)
			len = ti->ti_len;
		else
			len = ti6->ti6_plen;	/*XXX intermediate header*/
		win = th->th_win;
		if (act == TA_OUTPUT) {
			NTOHL(seq);
			NTOHL(ack);
			NTOHS(win);
		}
		if (len)
			printf("[%x..%x)", seq, seq + len);
		else
			printf("%x", seq);
		printf("@@%x", ack);
		if (win)
			printf("(win=%x)", win);
		flags = th->th_flags;
		if (flags) {
			char *cp = "<";
#define	pf(flag, string) { \
	if (th->th_flags & flag) { \
		(void)printf("%s%s", cp, string); \
		cp = ","; \
	} \
}
			pf(TH_SYN, "SYN");
			pf(TH_ACK, "ACK");
			pf(TH_FIN, "FIN");
			pf(TH_RST, "RST");
			pf(TH_PUSH, "PUSH");
			pf(TH_URG, "URG");
			printf(">");
		}
		break;
	case TA_USER:
		timer = req >> 8;
		req &= 0xff;
		printf("%s", prurequests[req]);
		if (req == PRU_SLOWTIMO || req == PRU_FASTTIMO)
			printf("<%s>", tcptimers[timer]);
		break;
	}
	printf(" -> %s", tcpstates[tp->t_state]);
	/* print out internal state of tp !?! */
	printf("\n");
	if (sflag) {
		printf("\trcv_nxt %x rcv_wnd %lx snd_una %x snd_nxt %x snd_max %x\n",
		    tp->rcv_nxt, tp->rcv_wnd, tp->snd_una, tp->snd_nxt,
		    tp->snd_max);
		printf("\tsnd_wl1 %x snd_wl2 %x snd_wnd %lx\n", tp->snd_wl1,
		    tp->snd_wl2, tp->snd_wnd);
	}
	/* print out timers? */
	if (tflag) {
		char *cp = "\t";
		int i;

		for (i = 0; i < TCPT_NTIMERS; i++) {
			if (timeout_pending(&tp->t_timer[i]))
				continue;
			printf("%s%s=%d", cp, tcptimers[i],
			    tp->t_timer[i].to_time);
			if (i == TCPT_REXMT)
				printf(" (t_rxtshft=%d)", tp->t_rxtshift);
			cp = ", ";
		}
		if (*cp != '\t')
			putchar('\n');
	}
}

int
numeric(const void *v1, const void *v2)
{
	const caddr_t *c1 = v1;
	const caddr_t *c2 = v2;
	int rv;

	if (*c1 < *c2)
		rv = -1;
	else if (*c1 > *c2)
		rv = 1;
	else
		rv = 0;

	return (rv);
}

void
usage(void)
{

	(void) fprintf(stderr, "usage: %s [-afjst] [-M core]"
	    " [-N system] [-p hex-address]\n", __progname);
	exit(1);
}
@


1.33
log
@Pull in <sys/time.h> for struct timespec, timeval, or clockrate

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trpt.c,v 1.32 2015/11/20 15:52:57 deraadt Exp $	*/
a75 1
#include <netinet/in_systm.h>
d114 1
a114 1
static n_time ntime;
@


1.32
log
@Appears to only need pledge "stdio" against open kvm
@
text
@d1 1
a1 1
/*	$OpenBSD: trpt.c,v 1.31 2015/02/09 23:00:15 deraadt Exp $	*/
d63 1
@


1.31
log
@clean up flags++ instances around getopt()
ok florian
@
text
@d1 1
a1 1
/*	$OpenBSD: trpt.c,v 1.30 2015/01/16 06:40:22 deraadt Exp $	*/
d200 3
@


1.30
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: trpt.c,v 1.29 2014/11/26 18:34:52 millert Exp $	*/
d138 1
a138 1
			++aflag;
d141 1
a141 1
			++follow;
d145 1
a145 1
			++jflag;
d159 1
a159 1
			++sflag;
d162 1
a162 1
			++tflag;
@


1.29
log
@Prefer setvbuf() to setlinebuf() for portability; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trpt.c,v 1.28 2011/07/04 07:06:49 guenther Exp $	*/
a61 1
#include <sys/param.h>
@


1.28
log
@<sys/socketvar.h> isn't actually needed here, so revert previous and drop
that #include

ok mikeb@@ halex@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trpt.c,v 1.26 2010/05/26 17:49:57 deraadt Exp $	*/
d143 1
a143 1
			setlinebuf(stdout);
@


1.27
log
@include sys/timeout.h with it's define/undef _KERNEL dance before
we include sys/socket.h since the latter also includes the same
but without _KERNEL defined

ok tedu@@
@
text
@d64 3
a69 4
#include <sys/socket.h>
#include <sys/socketvar.h>
#define PRUREQUESTS
#include <sys/protosw.h>
@


1.26
log
@libevent has named two of it's new macros by the same name as our kernel
macros, which are visible, and get pulled into some source code...  Hide
the kernel ones inside _KERNEL, and make trpt (the only userland viewer of
them) define _KERNEL temporarily.  This is really gross.  libevent is doing
a poor job of choosing function names!
ok tedu guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: trpt.c,v 1.25 2009/10/27 23:59:57 deraadt Exp $	*/
d64 3
a70 3
#define _KERNEL
#include <sys/timeout.h>		/* to get timeout_pending() and such */
#undef _KERNEL
@


1.25
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: trpt.c,v 1.24 2008/06/26 05:42:21 ray Exp $	*/
d68 3
@


1.24
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trpt.c,v 1.23 2007/02/18 23:22:33 jmc Exp $	*/
a60 10

#ifndef lint
char copyright[] =
"@@(#) Copyright (c) 1983, 1988, 1993\n\
	The Regents of the University of California.  All rights reserved.\n";
#endif /* not lint */

#ifndef lint
static char sccsid[] = "@@(#)trpt.c	8.1 (Berkeley) 6/6/93";
#endif /* not lint */
@


1.23
log
@tidy up synopsis and usage(); from Igor Sobrado
@
text
@d1 1
a1 1
/*	$OpenBSD: trpt.c,v 1.22 2006/03/13 16:30:18 deraadt Exp $	*/
a18 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the NetBSD
 *	Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.22
log
@cleanup from dhill
@
text
@d1 1
a1 1
/*	$OpenBSD: trpt.c,v 1.21 2005/05/03 03:41:11 djm Exp $	*/
d450 2
a451 2
	(void) fprintf(stderr, "usage: %s [-afjst] [-p hex-address]"
	    " [-N system] [-M core]\n", __progname);
@


1.21
log
@setresgid; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trpt.c,v 1.20 2004/09/24 15:02:43 markus Exp $	*/
d136 2
a137 2
void	tcp_trace(short, short, struct tcpcb *, struct tcpcb *,
	    struct tcpiphdr *, struct tcpipv6hdr *, int);
d146 1
a146 1
	char *system = NULL, *core = NULL, *cp, errbuf[_POSIX2_LINE_MAX];
d181 1
a181 1
			system = optarg;
d202 1
a202 1
	if (core != NULL || system != NULL)
d206 1
a206 1
	kd = kvm_openfiles(system, core, NULL, O_RDONLY, errbuf);
d210 1
a210 1
	if (core == NULL && system == NULL)
d215 1
a215 1
		errx(2, "%s: no namelist", system ? system : _PATH_UNIX);
d281 1
a281 1
		    (struct tcpcb *)td->td_tcb, &td->td_cb, &td->td_ti,
d292 1
a292 1
		    (struct tcpcb *)td->td_tcb, &td->td_cb, &td->td_ti,
d321 2
a322 2
tcp_trace(short act, short ostate, struct tcpcb *atp,
    struct tcpcb *tp, struct tcpiphdr *ti, struct tcpipv6hdr *ti6, int req)
@


1.20
log
@pass segment size to userland; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: trpt.c,v 1.19 2003/09/19 08:15:56 deraadt Exp $	*/
d149 1
d201 4
a204 4
	if (core != NULL || system != NULL) {
		setegid(getgid());
		setgid(getgid());
	}
d210 3
a212 2
	setegid(getgid());
	setgid(getgid());
@


1.19
log
@whack getopt ? matching; jeffi@@rcn.com
@
text
@d1 1
a1 1
/*	$OpenBSD: trpt.c,v 1.18 2003/06/02 23:36:55 millert Exp $	*/
a362 1
			NTOHS(len);
a364 2
		if (act == TA_OUTPUT)
			len -= sizeof(struct tcphdr);
@


1.18
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: trpt.c,v 1.17 2003/05/26 05:33:43 itojun Exp $	*/
a184 1
		case '?':
@


1.17
log
@IPv6 support.
@
text
@d1 1
a1 1
/*	$OpenBSD: trpt.c,v 1.16 2003/05/14 01:12:27 jason Exp $	*/
d52 1
a52 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.16
log
@remove the last of the MI commons
@
text
@d1 1
a1 1
/*	$OpenBSD: trpt.c,v 1.15 2002/12/09 09:53:34 deraadt Exp $	*/
d141 1
a141 1
	    struct tcpiphdr *, int);
d285 1
a285 1
		    td->td_req);
d296 1
a296 1
		    td->td_req);
d325 1
a325 1
    struct tcpcb *tp, struct tcpiphdr *ti, int req)
d329 7
d344 13
a356 4
			printf("(src=%s,%u, ",
			    inet_ntoa(ti->ti_src), ntohs(ti->ti_sport));
			printf("dst=%s,%u)",
			    inet_ntoa(ti->ti_dst), ntohs(ti->ti_dport));
d358 7
a364 4
		seq = ti->ti_seq;
		ack = ti->ti_ack;
		len = ti->ti_len;
		win = ti->ti_win;
d380 1
a380 1
		flags = ti->ti_flags;
d384 1
a384 1
	if (ti->ti_flags&flag) { \
@


1.15
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: trpt.c,v 1.14 2002/11/18 05:15:39 itojun Exp $	*/
d129 3
@


1.14
log
@strto* usage audit.  deraadt ok
@
text
@d1 1
a1 1
/*	$OpenBSD: trpt.c,v 1.13 2002/06/19 08:45:52 deraadt Exp $	*/
a135 1
int	main(int, char *[]);
d145 1
a145 3
main(argc, argv)
	int argc;
	char *argv[];
d147 2
a148 2
	int ch, i, jflag, npcbs;
	char *system, *core, *cp, errbuf[_POSIX2_LINE_MAX];
a150 3
	system = core = NULL;

	jflag = npcbs = 0;
d266 1
a266 2
dotrace(tcpcb)
	caddr_t tcpcb;
d321 2
a322 5
tcp_trace(act, ostate, atp, tp, ti, req)
	short act, ostate;
	struct tcpcb *atp, *tp;
	struct tcpiphdr *ti;
	int req;
d414 1
a414 2
numeric(v1, v2)
	const void *v1, *v2;
d431 1
a431 1
usage()
@


1.13
log
@mark which nlist[] kmem entries are not needed in the sysctl case, and which are
@
text
@d1 1
a1 1
/*	$OpenBSD: trpt.c,v 1.12 2002/03/14 16:44:25 mpech Exp $	*/
d152 1
d173 4
a176 2
			tcp_pcbs[npcbs++] = (caddr_t)strtoul(optarg, &cp, 16);
			if (*cp != '\0' || errno == ERANGE)
d178 1
@


1.12
log
@kill more registers.

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: trpt.c,v 1.11 2002/03/08 17:22:24 mickey Exp $	*/
d123 1
a123 1
#define	N_TCP_DEBUG	0
d125 1
a125 1
#define	N_TCP_DEBX	1
@


1.11
log
@fix a fallout from tcp timer conversion
@
text
@d1 1
a1 1
/*	$OpenBSD: trpt.c,v 1.10 2002/02/17 19:42:40 millert Exp $	*/
d366 1
a366 1
			register char *cp = "<";
d402 2
a403 2
		register char *cp = "\t";
		register int i;
@


1.10
log
@Manual cleanup of remaining userland __P use (excluding packages maintained outside the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: trpt.c,v 1.9 2002/02/16 21:28:10 millert Exp $	*/
d406 1
a406 1
			if (tp->t_timer[i] == 0)
d408 2
a409 1
			printf("%s%s=%d", cp, tcptimers[i], tp->t_timer[i]);
@


1.9
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: trpt.c,v 1.8 2000/02/25 23:32:55 deraadt Exp $	*/
d138 2
a139 2
void	tcp_trace __P((short, short, struct tcpcb *, struct tcpcb *,
	    struct tcpiphdr *, int));
@


1.8
log
@support -M and -N; jeff@@cepheid.org
@
text
@d1 1
a1 1
/*	$OpenBSD: trpt.c,v 1.7 1998/07/08 22:13:32 deraadt Exp $	*/
d136 2
a137 2
int	main __P((int, char *[]));
void	dotrace __P((caddr_t));
d140 2
a141 2
int	numeric __P((const void *, const void *));
void	usage __P((void));
@


1.7
log
@whack kmem gid after kvm_openfiles()
@
text
@d1 1
a1 1
/*	$OpenBSD: trpt.c,v 1.6 1997/09/08 09:23:15 deraadt Exp $	*/
d156 1
a156 1
	while ((ch = getopt(argc, argv, "afjp:st")) != -1) {
@


1.6
log
@use -lkvm, various other fixes; thorpej
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d212 3
@


1.5
log
@getopt(3) returns -1 when out of args, not EOF, whee!
@
text
@d1 39
d41 2
a42 2
 * Copyright (c) 1983, 1988 Regents of the University of California.
 * All rights reserved.
d75 2
a76 2
"@@(#) Copyright (c) 1983, 1988 Regents of the University of California.\n\
 All rights reserved.\n";
d80 1
a80 2
/*static char sccsid[] = "from: @@(#)trpt.c	5.14 (Berkeley) 7/1/91";*/
static char rcsid[] = "$Id: trpt.c,v 1.4 1996/12/22 03:29:10 deraadt Exp $";
a84 7
#if BSD >= 199103
#define NEWVM
#endif
#ifndef NEWVM
#include <machine/pte.h>
#include <sys/vmmac.h>
#endif
d112 1
d115 1
d118 3
d127 1
a127 7
#ifndef NEWVM
#define	N_SYSMAP	2
	{ "_Sysmap" },
#define	N_SYSSIZE	3
	{ "_Syssize" },
#endif
	{ "" },
a129 3
#ifndef NEWVM
static struct pte *Sysmap;
#endif
d132 10
a141 1
static int aflag, kflag, memf, follow, sflag, tflag;
d143 3
d148 1
a148 1
	char **argv;
d150 4
a153 5
	extern char *optarg;
	extern int optind;
	int ch, i, jflag, npcbs, numeric();
	char *system, *core, *malloc();
	off_t lseek();
d156 1
a156 1
	while ((ch = getopt(argc, argv, "afjp:st")) != -1)
d169 6
a174 6
			if (npcbs >= TCP_NDEBUG) {
				fputs("trpt: too many pcb's specified\n",
				    stderr);
				exit(1);
			}
			(void)sscanf(optarg, "%x", (int *)&tcp_pcbs[npcbs++]);
d182 6
d190 2
a191 3
			(void)fprintf(stderr,
"usage: trpt [-afjst] [-p hex-address] [system [core]]\n");
			exit(1);
d193 1
d197 2
a198 12
	core = _PATH_KMEM;
	if (argc > 0) {
		system = *argv;
		argc--, argv++;
		if (argc > 0) {
			core = *argv;
			argc--, argv++;
			++kflag;
		}
	}
	else
		system = _PATH_UNIX;
d201 1
a201 1
	 * Discard setgid priviledges if not the running kernel so that bad
d204 1
a204 1
	if (!strcmp(core, _PATH_KMEM) || !strcmp(system, _PATH_UNIX)) {
d209 15
a223 39
	if (nlist(system, nl) < 0 || !nl[0].n_value) {
		fprintf(stderr, "trpt: %s: no namelist\n", system);
		exit(1);
	}
	if ((memf = open(core, O_RDONLY)) < 0) {
		perror(core);
		exit(2);
	}
	if (kflag) {
#ifdef NEWVM
		fputs("trpt: can't do core files yet\n", stderr);
		exit(1);
#else
		off_t off;

		Sysmap = (struct pte *)
		   malloc((u_int)(nl[N_SYSSIZE].n_value * sizeof(struct pte)));
		if (!Sysmap) {
			fputs("trpt: can't get memory for Sysmap.\n", stderr);
			exit(1);
		}
		off = nl[N_SYSMAP].n_value & ~KERNBASE;
		(void)lseek(memf, off, L_SET);
		(void)read(memf, (char *)Sysmap,
		    (int)(nl[N_SYSSIZE].n_value * sizeof(struct pte)));
#endif
	}
	(void)klseek(memf, (off_t)nl[N_TCP_DEBX].n_value, L_SET);
	if (read(memf, (char *)&tcp_debx, sizeof(tcp_debx)) !=
	    sizeof(tcp_debx)) {
		perror("trpt: tcp_debx");
		exit(3);
	}
	(void)klseek(memf, (off_t)nl[N_TCP_DEBUG].n_value, L_SET);
	if (read(memf, (char *)tcp_debug, sizeof(tcp_debug)) !=
	    sizeof(tcp_debug)) {
		perror("trpt: tcp_debug");
		exit(3);
	}
d230 1
a230 1
	if (!npcbs) {
d232 2
a233 2
			register struct tcp_debug *td = &tcp_debug[i];
			register int j;
d243 1
a243 1
		if (!npcbs)
d255 5
a259 4
	}
	else for (i = 0; i < npcbs; i++) {
		printf("\n%lx:\n", (long)tcp_pcbs[i]);
		dotrace(tcp_pcbs[i]);
d264 1
d266 1
a266 1
	register caddr_t tcpcb;
d268 1
a268 2
	register struct tcp_debug *td;
	register int i;
d270 1
d272 2
a273 1
again:	if (--tcp_debx < 0)
d280 3
a282 2
		tcp_trace(td->td_act, td->td_ostate, td->td_tcb, &td->td_cb,
		    &td->td_ti, td->td_req);
d291 3
a293 2
		tcp_trace(td->td_act, td->td_ostate, td->td_tcb, &td->td_cb,
		    &td->td_ti, td->td_req);
d295 2
a296 1
done:	if (follow) {
d302 4
a305 6
			(void)klseek(memf, (off_t)nl[N_TCP_DEBX].n_value, L_SET);
			if (read(memf, (char *)&tcp_debx, sizeof(tcp_debx)) !=
			    sizeof(tcp_debx)) {
				perror("trpt: tcp_debx");
				exit(3);
			}
d307 5
a311 6
		(void)klseek(memf, (off_t)nl[N_TCP_DEBUG].n_value, L_SET);
		if (read(memf, (char *)tcp_debug, sizeof(tcp_debug)) !=
		    sizeof(tcp_debug)) {
			perror("trpt: tcp_debug");
			exit(3);
		}
d320 1
d330 1
a330 1
	printf("%03ld %s:%s ",(ntime/10) % 1000, tcpstates[ostate],
d347 4
a350 4
			seq = ntohl(seq);
			ack = ntohl(ack);
			len = ntohs(len);
			win = ntohs(win);
d355 1
a355 1
			printf("[%lx..%lx)", seq, seq + len);
d357 2
a358 2
			printf("%lx", seq);
		printf("@@%lx", ack);
d391 1
a391 1
		printf("\trcv_nxt %lx rcv_wnd %x snd_una %lx snd_nxt %lx snd_max %lx\n",
d394 1
a394 1
		printf("\tsnd_wl1 %lx snd_wl2 %lx snd_wnd %x\n", tp->snd_wl1,
d415 3
a417 2
numeric(c1, c2)
	caddr_t *c1, *c2;
d419 12
a430 1
	return(*c1 - *c2);
d433 2
a434 3
klseek(fd, base, off)
	int fd, off;
	off_t base;
a435 1
	off_t lseek();
d437 3
a439 7
#ifndef NEWVM
	if (kflag) {	/* get kernel pte */
		base &= ~KERNBASE;
		base = ctob(Sysmap[btop(base)].pg_pfnum) + (base & PGOFSET);
	}
#endif
	(void)lseek(fd, base, off);
@


1.4
log
@Deal with _POSIX_SAVED_IDS when relinquishing privileges
@
text
@d42 1
a42 1
static char rcsid[] = "$Id: trpt.c,v 1.3 1996/06/03 18:06:18 deraadt Exp $";
d118 1
a118 1
	while ((ch = getopt(argc, argv, "afjp:st")) != EOF)
@


1.3
log
@do not rely on constant folding equivelance
@
text
@d42 1
a42 1
static char rcsid[] = "$Id: trpt.c,v 1.2 1996/05/30 09:11:11 deraadt Exp $";
d170 2
a171 1
	if (!strcmp(core, _PATH_KMEM) || !strcmp(system, _PATH_UNIX))
d173 1
@


1.2
log
@revoke privs before opening kvm if user has specified mem/kernel paths
@
text
@d42 1
a42 1
static char rcsid[] = "$Id: trpt.c,v 1.1.1.1 1995/10/18 08:48:29 deraadt Exp $";
d170 1
a170 1
	if (core != _PATH_KMEM || system != _PATH_UNIX)
@


1.1
log
@Initial revision
@
text
@d42 1
a42 1
static char rcsid[] = "$Id: trpt.c,v 1.3 1994/12/23 16:35:50 cgd Exp $";
d165 7
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
