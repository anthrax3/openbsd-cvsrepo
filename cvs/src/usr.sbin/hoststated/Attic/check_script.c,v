head	1.5;
access;
symbols
	OPENBSD_4_2:1.2.0.2
	OPENBSD_4_2_BASE:1.2;
locks; strict;
comment	@ * @;


1.5
date	2007.12.07.17.27.07;	author deraadt;	state dead;
branches;
next	1.4;

1.4
date	2007.11.24.17.07.28;	author reyk;	state Exp;
branches;
next	1.3;

1.3
date	2007.10.13.17.50.05;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2007.06.12.15.16.10;	author msf;	state Exp;
branches;
next	1.1;

1.1
date	2007.05.29.17.12.04;	author reyk;	state Exp;
branches;
next	;


desc
@@


1.5
log
@hoststated/hoststatectl get repository copied (and de-tagged) into
relayd/relayctl.  This is a more suitable place for a daemon that has
grown out of it's initial roots of "monitoring and redirecting services
at various layers", into one that is "a full featured proxy, which
happens to know what is up/down"
@
text
@/*	$OpenBSD: check_script.c,v 1.4 2007/11/24 17:07:28 reyk Exp $	*/

/*
 * Copyright (c) 2007 Reyk Floeter <reyk@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/param.h>
#include <sys/queue.h>
#include <sys/socket.h>
#include <sys/wait.h>

#include <net/if.h>

#include <limits.h>
#include <event.h>
#include <errno.h>
#include <unistd.h>
#include <string.h>
#include <stdlib.h>
#include <signal.h>
#include <pwd.h>
#include <err.h>

#include <openssl/ssl.h>

#include "hoststated.h"

void	 script_sig_alarm(int);

extern struct imsgbuf		*ibuf_main;
pid_t				 child = -1;

void
check_script(struct host *host)
{
	struct ctl_script	 scr;

	host->last_up = host->up;
	host->flags &= ~(F_CHECK_SENT|F_CHECK_DONE);

	scr.host = host->conf.id;
	imsg_compose(ibuf_main, IMSG_SCRIPT, 0, 0, -1, &scr, sizeof(scr));
}

void
script_done(struct hoststated *env, struct ctl_script *scr)
{
	struct host		*host;

	if ((host = host_find(env, scr->host)) == NULL)
		fatalx("hce_dispatch_parent: invalid host id");

	if (scr->retval < 0)
		host->up = HOST_UNKNOWN;
	else if (scr->retval == 0)
		host->up = HOST_DOWN;
	else
		host->up = HOST_UP;
	host->flags |= F_CHECK_DONE;

	hce_notify_done(host, host->up == HOST_UP ?
	    "script: done" : "script: failed");
}

void
script_sig_alarm(int sig)
{
	int save_errno = errno;

	if (child != -1)
		kill(child, SIGKILL);
	errno = save_errno;
}

int
script_exec(struct hoststated *env, struct ctl_script *scr)
{
	int			 status = 0, ret = 0;
	sig_t			 save_quit, save_int, save_chld;
	struct itimerval	 it;
	struct timeval		*tv;
	const char		*file, *arg;
	struct host		*host;
	struct table		*table;
	struct passwd		*pw;

	if ((host = host_find(env, scr->host)) == NULL)
		fatalx("script_exec: invalid host id");
	if ((table = table_find(env, host->conf.tableid)) == NULL)
		fatalx("script_exec: invalid table id");

	arg = host->conf.name;
	file = table->conf.path;
	tv = &table->conf.timeout;

	save_quit = signal(SIGQUIT, SIG_IGN);
	save_int = signal(SIGINT, SIG_IGN);
	save_chld = signal(SIGCHLD, SIG_DFL);

	switch (child = fork()) {
	case -1:
		ret = -1;
		goto done;
	case 0:
		signal(SIGQUIT, SIG_DFL);
		signal(SIGINT, SIG_DFL);
		signal(SIGCHLD, SIG_DFL);

		if ((pw = getpwnam(HOSTSTATED_USER)) == NULL)
			fatal("script_exec: getpwnam");
		if (chdir("/") == -1)
			fatal("script_exec: chdir(\"/\")");
		if (setgroups(1, &pw->pw_gid) ||
		    setresgid(pw->pw_gid, pw->pw_gid, pw->pw_gid) ||
		    setresuid(pw->pw_uid, pw->pw_uid, pw->pw_uid))
			fatal("script_exec: can't drop privileges");

		execlp(file, file, arg, (char *)NULL);
		_exit(0);
		break;
	default:
		/* Kill the process after a timeout */
		signal(SIGALRM, script_sig_alarm);
		bzero(&it, sizeof(it));
		bcopy(tv, &it.it_value, sizeof(it.it_value));
		setitimer(ITIMER_REAL, &it, NULL);

		waitpid(child, &status, 0);
		break;
	}

	switch (ret) {
	case -1:
		ret = -1;
		break;
	default:
		if (WIFEXITED(status))
			ret = WEXITSTATUS(status);
		else
			ret = -1;
	}

 done:
	/* Disable the process timeout timer */
	bzero(&it, sizeof(it));
	setitimer(ITIMER_REAL, &it, NULL);
	child = -1;

	signal(SIGQUIT, save_quit);
	signal(SIGINT, save_int);
	signal(SIGCHLD, save_chld);
	signal(SIGALRM, SIG_DFL);

	return (ret);
}
@


1.4
log
@sort includes, adjust to style(9)
@
text
@d1 1
a1 1
/*	$OpenBSD: check_script.c,v 1.3 2007/10/13 17:50:05 deraadt Exp $	*/
@


1.3
log
@avoid errno trashing in signal handler
@
text
@d1 1
a1 1
/*	$OpenBSD: check_script.c,v 1.2 2007/06/12 15:16:10 msf Exp $	*/
d19 1
a19 1
#include <sys/types.h>
a21 2
#include <sys/param.h>
#include <sys/types.h>
@


1.2
log
@put the fd passing from bgpd back in to hoststated's version of imsg,
needed for layer 7 reload support.

ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: check_script.c,v 1.1 2007/05/29 17:12:04 reyk Exp $	*/
d82 2
d86 1
@


1.1
log
@add a new check method which allows to run external scripts/programs
for custom evaluations.

pyr agrees to put it in now but to do some improvements of the timeout
handling later.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d56 1
a56 1
	imsg_compose(ibuf_main, IMSG_SCRIPT, 0, 0, &scr, sizeof(scr));
@

