head	1.97;
access;
symbols
	OPENBSD_4_2:1.50.0.2
	OPENBSD_4_2_BASE:1.50
	OPENBSD_4_1:1.35.0.2
	OPENBSD_4_1_BASE:1.35;
locks; strict;
comment	@ * @;


1.97
date	2007.12.07.17.27.07;	author deraadt;	state dead;
branches;
next	1.96;

1.96
date	2007.11.26.09.38.25;	author reyk;	state Exp;
branches;
next	1.95;

1.95
date	2007.11.24.17.07.28;	author reyk;	state Exp;
branches;
next	1.94;

1.94
date	2007.11.23.09.39.42;	author reyk;	state Exp;
branches;
next	1.93;

1.93
date	2007.11.22.10.09.53;	author reyk;	state Exp;
branches;
next	1.92;

1.92
date	2007.11.21.20.31.03;	author reyk;	state Exp;
branches;
next	1.91;

1.91
date	2007.11.21.20.24.28;	author reyk;	state Exp;
branches;
next	1.90;

1.90
date	2007.11.21.20.13.20;	author reyk;	state Exp;
branches;
next	1.89;

1.89
date	2007.11.21.14.12.04;	author reyk;	state Exp;
branches;
next	1.88;

1.88
date	2007.11.21.13.04.42;	author reyk;	state Exp;
branches;
next	1.87;

1.87
date	2007.11.20.17.08.44;	author reyk;	state Exp;
branches;
next	1.86;

1.86
date	2007.11.20.15.54.55;	author reyk;	state Exp;
branches;
next	1.85;

1.85
date	2007.11.20.15.44.21;	author pyr;	state Exp;
branches;
next	1.84;

1.84
date	2007.11.19.15.31.36;	author reyk;	state Exp;
branches;
next	1.83;

1.83
date	2007.11.19.15.20.18;	author reyk;	state Exp;
branches;
next	1.82;

1.82
date	2007.11.19.14.48.19;	author reyk;	state Exp;
branches;
next	1.81;

1.81
date	2007.11.19.14.41.05;	author reyk;	state Exp;
branches;
next	1.80;

1.80
date	2007.11.15.17.02.01;	author pyr;	state Exp;
branches;
next	1.79;

1.79
date	2007.11.14.15.58.04;	author pyr;	state Exp;
branches;
next	1.78;

1.78
date	2007.11.14.10.59.01;	author pyr;	state Exp;
branches;
next	1.77;

1.77
date	2007.11.12.23.59.41;	author mpf;	state Exp;
branches;
next	1.76;

1.76
date	2007.11.04.18.47.17;	author claudio;	state Exp;
branches;
next	1.75;

1.75
date	2007.10.22.16.53.30;	author pyr;	state Exp;
branches;
next	1.74;

1.74
date	2007.10.22.12.18.15;	author reyk;	state Exp;
branches;
next	1.73;

1.73
date	2007.10.22.08.52.19;	author reyk;	state Exp;
branches;
next	1.72;

1.72
date	2007.10.19.17.33.35;	author pyr;	state Exp;
branches;
next	1.71;

1.71
date	2007.10.19.14.40.51;	author pyr;	state Exp;
branches;
next	1.70;

1.70
date	2007.10.19.14.15.14;	author pyr;	state Exp;
branches;
next	1.69;

1.69
date	2007.10.19.09.08.05;	author pyr;	state Exp;
branches;
next	1.68;

1.68
date	2007.10.18.20.52.12;	author deraadt;	state Exp;
branches;
next	1.67;

1.67
date	2007.10.18.20.49.06;	author pyr;	state Exp;
branches;
next	1.66;

1.66
date	2007.10.18.20.32.38;	author deraadt;	state Exp;
branches;
next	1.65;

1.65
date	2007.10.16.20.01.23;	author mpf;	state Exp;
branches;
next	1.64;

1.64
date	2007.10.16.06.06.49;	author deraadt;	state Exp;
branches;
next	1.63;

1.63
date	2007.10.13.16.35.21;	author deraadt;	state Exp;
branches;
next	1.62;

1.62
date	2007.10.11.14.39.17;	author deraadt;	state Exp;
branches;
next	1.61;

1.61
date	2007.10.09.22.32.52;	author deraadt;	state Exp;
branches;
next	1.60;

1.60
date	2007.10.05.15.50.56;	author reyk;	state Exp;
branches;
next	1.59;

1.59
date	2007.10.02.21.04.13;	author pyr;	state Exp;
branches;
next	1.58;

1.58
date	2007.10.02.07.21.04;	author pyr;	state Exp;
branches;
next	1.57;

1.57
date	2007.10.01.19.12.33;	author pyr;	state Exp;
branches;
next	1.56;

1.56
date	2007.10.01.12.34.02;	author pyr;	state Exp;
branches;
next	1.55;

1.55
date	2007.09.28.13.29.56;	author pyr;	state Exp;
branches;
next	1.54;

1.54
date	2007.09.10.11.59.22;	author reyk;	state Exp;
branches;
next	1.53;

1.53
date	2007.09.07.07.54.58;	author reyk;	state Exp;
branches;
next	1.52;

1.52
date	2007.09.05.08.48.42;	author reyk;	state Exp;
branches;
next	1.51;

1.51
date	2007.09.04.14.15.05;	author pyr;	state Exp;
branches;
next	1.50;

1.50
date	2007.07.05.09.42.26;	author thib;	state Exp;
branches;
next	1.49;

1.49
date	2007.05.31.18.58.09;	author pyr;	state Exp;
branches;
next	1.48;

1.48
date	2007.05.31.18.20.03;	author pyr;	state Exp;
branches;
next	1.47;

1.47
date	2007.05.31.03.24.05;	author pyr;	state Exp;
branches;
next	1.46;

1.46
date	2007.05.29.18.59.54;	author pyr;	state Exp;
branches;
next	1.45;

1.45
date	2007.05.29.17.12.04;	author reyk;	state Exp;
branches;
next	1.44;

1.44
date	2007.05.29.00.48.04;	author pyr;	state Exp;
branches;
next	1.43;

1.43
date	2007.05.29.00.21.10;	author pyr;	state Exp;
branches;
next	1.42;

1.42
date	2007.05.28.17.37.16;	author pyr;	state Exp;
branches;
next	1.41;

1.41
date	2007.05.27.20.53.10;	author pyr;	state Exp;
branches;
next	1.40;

1.40
date	2007.05.27.19.21.15;	author reyk;	state Exp;
branches;
next	1.39;

1.39
date	2007.05.26.19.58.49;	author pyr;	state Exp;
branches;
next	1.38;

1.38
date	2007.04.12.14.45.45;	author reyk;	state Exp;
branches;
next	1.37;

1.37
date	2007.03.21.00.08.08;	author reyk;	state Exp;
branches;
next	1.36;

1.36
date	2007.03.13.12.04.52;	author reyk;	state Exp;
branches;
next	1.35;

1.35
date	2007.03.07.17.40.32;	author reyk;	state Exp;
branches;
next	1.34;

1.34
date	2007.03.06.19.26.46;	author reyk;	state Exp;
branches;
next	1.33;

1.33
date	2007.02.27.13.38.58;	author reyk;	state Exp;
branches;
next	1.32;

1.32
date	2007.02.26.20.48.48;	author pyr;	state Exp;
branches;
next	1.31;

1.31
date	2007.02.26.19.58.04;	author pyr;	state Exp;
branches;
next	1.30;

1.30
date	2007.02.26.19.25.05;	author pyr;	state Exp;
branches;
next	1.29;

1.29
date	2007.02.26.13.31.21;	author pyr;	state Exp;
branches;
next	1.28;

1.28
date	2007.02.26.13.03.30;	author pyr;	state Exp;
branches;
next	1.27;

1.27
date	2007.02.24.00.22.32;	author reyk;	state Exp;
branches;
next	1.26;

1.26
date	2007.02.22.03.32.39;	author reyk;	state Exp;
branches;
next	1.25;

1.25
date	2007.02.09.17.55.49;	author reyk;	state Exp;
branches;
next	1.24;

1.24
date	2007.02.08.13.32.24;	author reyk;	state Exp;
branches;
next	1.23;

1.23
date	2007.02.07.15.17.46;	author reyk;	state Exp;
branches;
next	1.22;

1.22
date	2007.02.07.13.39.58;	author reyk;	state Exp;
branches;
next	1.21;

1.21
date	2007.02.07.13.30.17;	author reyk;	state Exp;
branches;
next	1.20;

1.20
date	2007.01.30.10.12.06;	author pyr;	state Exp;
branches;
next	1.19;

1.19
date	2007.01.29.14.23.31;	author pyr;	state Exp;
branches;
next	1.18;

1.18
date	2007.01.25.19.40.08;	author niallo;	state Exp;
branches;
next	1.17;

1.17
date	2007.01.24.06.31.09;	author pyr;	state Exp;
branches;
next	1.16;

1.16
date	2007.01.12.16.43.01;	author pyr;	state Exp;
branches;
next	1.15;

1.15
date	2007.01.09.13.50.11;	author pyr;	state Exp;
branches;
next	1.14;

1.14
date	2007.01.09.00.45.32;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2007.01.08.20.46.18;	author reyk;	state Exp;
branches;
next	1.12;

1.12
date	2007.01.08.17.10.23;	author reyk;	state Exp;
branches;
next	1.11;

1.11
date	2007.01.08.16.50.04;	author reyk;	state Exp;
branches;
next	1.10;

1.10
date	2007.01.08.14.30.31;	author reyk;	state Exp;
branches;
next	1.9;

1.9
date	2007.01.08.13.37.26;	author reyk;	state Exp;
branches;
next	1.8;

1.8
date	2007.01.03.09.45.29;	author reyk;	state Exp;
branches;
next	1.7;

1.7
date	2007.01.03.09.42.30;	author reyk;	state Exp;
branches;
next	1.6;

1.6
date	2006.12.25.19.05.41;	author reyk;	state Exp;
branches;
next	1.5;

1.5
date	2006.12.25.18.12.14;	author reyk;	state Exp;
branches;
next	1.4;

1.4
date	2006.12.16.18.05.35;	author martin;	state Exp;
branches;
next	1.3;

1.3
date	2006.12.16.17.48.27;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2006.12.16.12.42.14;	author reyk;	state Exp;
branches;
next	1.1;

1.1
date	2006.12.16.11.45.07;	author reyk;	state Exp;
branches;
next	;


desc
@@


1.97
log
@hoststated/hoststatectl get repository copied (and de-tagged) into
relayd/relayctl.  This is a more suitable place for a daemon that has
grown out of it's initial roots of "monitoring and redirecting services
at various layers", into one that is "a full featured proxy, which
happens to know what is up/down"
@
text
@/*	$OpenBSD: parse.y,v 1.96 2007/11/26 09:38:25 reyk Exp $	*/

/*
 * Copyright (c) 2006 Pierre-Yves Ritschard <pyr@@openbsd.org>
 * Copyright (c) 2004, 2005 Esben Norby <norby@@openbsd.org>
 * Copyright (c) 2004 Ryan McBride <mcbride@@openbsd.org>
 * Copyright (c) 2002, 2003, 2004 Henning Brauer <henning@@openbsd.org>
 * Copyright (c) 2001 Markus Friedl.  All rights reserved.
 * Copyright (c) 2001 Daniel Hartmeier.  All rights reserved.
 * Copyright (c) 2001 Theo de Raadt.  All rights reserved.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

%{
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/stat.h>
#include <sys/queue.h>

#include <net/if.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <arpa/nameser.h>

#include <ctype.h>
#include <unistd.h>
#include <err.h>
#include <errno.h>
#include <event.h>
#include <limits.h>
#include <stdint.h>
#include <stdarg.h>
#include <stdio.h>
#include <netdb.h>
#include <string.h>

#include <openssl/ssl.h>

#include "hoststated.h"

TAILQ_HEAD(files, file)		 files = TAILQ_HEAD_INITIALIZER(files);
static struct file {
	TAILQ_ENTRY(file)	 entry;
	FILE			*stream;
	char			*name;
	int			 lineno;
	int			 errors;
} *file;
struct file	*pushfile(const char *, int);
int		 popfile(void);
int		 check_file_secrecy(int, const char *);
int		 yyparse(void);
int		 yylex(void);
int		 yyerror(const char *, ...);
int		 kw_cmp(const void *, const void *);
int		 lookup(char *);
int		 lgetc(int);
int		 lungetc(int);
int		 findeol(void);

TAILQ_HEAD(symhead, sym)	 symhead = TAILQ_HEAD_INITIALIZER(symhead);
struct sym {
	TAILQ_ENTRY(sym)	 entry;
	int			 used;
	int			 persist;
	char			*nam;
	char			*val;
};
int		 symset(const char *, const char *, int);
char		*symget(const char *);

struct hoststated	*conf = NULL;
static int		 errors = 0;
objid_t			 last_service_id = 0;
objid_t			 last_table_id = 0;
objid_t			 last_host_id = 0;
objid_t			 last_relay_id = 0;
objid_t			 last_proto_id = 0;

static struct service	*service = NULL;
static struct table	*table = NULL;
static struct relay	*rlay = NULL;
static struct protocol	*proto = NULL;
static struct protonode	 node;
static u_int16_t	 label = 0;

struct address	*host_v4(const char *);
struct address	*host_v6(const char *);
int		 host_dns(const char *, struct addresslist *,
		    int, in_port_t, const char *);
int		 host(const char *, struct addresslist *,
		    int, in_port_t, const char *);

struct table	*table_inherit(const char *, in_port_t);

typedef struct {
	union {
		int64_t		 number;
		char		*string;
		struct host	*host;
		struct timeval	 tv;
		struct {
			enum digest_type	 type;
			char			*digest;
		}		 digest;
	} v;
	int lineno;
} YYSTYPE;

%}

%token	SERVICE TABLE BACKUP HOST REAL INCLUDE
%token  CHECK TCP ICMP EXTERNAL REQUEST RESPONSE
%token  TIMEOUT CODE DIGEST PORT TAG INTERFACE STYLE RETURN LABEL
%token	VIRTUAL INTERVAL DISABLE STICKYADDR BACKLOG PATH SCRIPT WITH
%token	SEND EXPECT NOTHING SSL LOADBALANCE ROUNDROBIN CIPHERS COOKIE
%token	RELAY LISTEN ON FORWARD TO NAT LOOKUP PREFORK NO MARK MARKED URL
%token	PROTO SESSION CACHE APPEND CHANGE REMOVE FROM FILTER HASH HEADER
%token	LOG UPDATES ALL DEMOTE NODELAY SACK SOCKET BUFFER QUERYSTR RETRY IP
%token	ERROR
%token	<v.string>	STRING
%token  <v.number>	NUMBER
%type	<v.string>	interface hostname
%type	<v.number>	port http_type loglevel sslcache optssl dstport mark
%type	<v.number>	proto_type dstmode docheck retry log flag direction
%type	<v.host>	host
%type	<v.tv>		timeout
%type	<v.digest>	digest

%%

grammar		: /* empty */
		| grammar include '\n'
		| grammar '\n'
		| grammar varset '\n'
		| grammar main '\n'
		| grammar service '\n'
		| grammar table '\n'
		| grammar relay '\n'
		| grammar proto '\n'
		| grammar error '\n'		{ file->errors++; }
		;

include		: INCLUDE STRING		{
			struct file	*nfile;

			if ((nfile = pushfile($2, 0)) == NULL) {
				yyerror("failed to include file %s", $2);
				free($2);
				YYERROR;
			}
			free($2);

			file = nfile;
			lungetc('\n');
		}

optssl		: /*empty*/	{ $$ = 0; }
		| SSL		{ $$ = 1; }
		;

http_type	: STRING	{
			if (strcmp("https", $1) == 0) {
				$$ = 1;
			} else if (strcmp("http", $1) == 0) {
				$$ = 0;
			} else {
				yyerror("invalid check type: %s", $1);
				free($1);
				YYERROR;
			}
			free($1);
		}
		;

hostname	: /* empty */		{
			$$ = strdup("");
			if ($$ == NULL)
				fatal("calloc");
		}
		| HOST STRING	{
			if (asprintf(&$$, "Host: %s\r\n", $2) == -1)
				fatal("asprintf");
		}
		;

proto_type	: TCP				{ $$ = RELAY_PROTO_TCP; }
		| STRING			{
			if (strcmp("http", $1) == 0) {
				$$ = RELAY_PROTO_HTTP;
			} else if (strcmp("dns", $1) == 0) {
				$$ = RELAY_PROTO_DNS;
			} else {
				yyerror("invalid protocol type: %s", $1);
				free($1);
				YYERROR;
			}
			free($1);
		}
		;

eflags_l	: eflags comma eflags_l
		| eflags
		;

opteflags	: /* nothing */
		| eflags
		;

eflags		: STYLE STRING
		{
			if ((proto->style = strdup($2)) == NULL)
				fatal("out of memory");
			free($2);
		}
		;

port		: PORT STRING {
			struct servent	*servent;

			servent = getservbyname($2, "tcp");
			if (servent == NULL) {
				yyerror("port %s is invalid", $2);
				free($2);
				YYERROR;
			}
			$$ = servent->s_port;
			free($2);
		}
		| PORT NUMBER {
			if ($2 <= 0 || $2 >= (int)USHRT_MAX) {
				yyerror("invalid port: %d", $2);
				YYERROR;
			}
			$$ = htons($2);
		}
		;

varset		: STRING '=' STRING	{
			if (symset($1, $3, 0) == -1)
				fatal("cannot store variable");
			free($1);
			free($3);
		}
		;

sendbuf		: NOTHING		{
			table->sendbuf = NULL;
			table->sendbuf_len = 0;
		}
		| STRING		{
			table->sendbuf = strdup($1);
			if (table->sendbuf == NULL)
				fatal("out of memory");
			table->sendbuf_len = strlen(table->sendbuf);
			free($1);
		}
		;

main		: INTERVAL NUMBER	{
			if ((conf->interval.tv_sec = $2) < 0) {
				yyerror("invalid interval: %d", $2);
				YYERROR;
			}
		}
		| LOG loglevel		{ conf->opts |= $2; }
		| TIMEOUT timeout	{
			bcopy(&$2, &conf->timeout, sizeof(struct timeval));
		}
		| PREFORK NUMBER	{
			if ($2 <= 0 || $2 > RELAY_MAXPROC) {
				yyerror("invalid number of preforked "
				    "relays: %d", $2);
				YYERROR;
			}
			conf->prefork_relay = $2;
		}
		| DEMOTE STRING		{
			conf->flags |= F_DEMOTE;
			if (strlcpy(conf->demote_group, $2,
			    sizeof(conf->demote_group))
			    >= sizeof(conf->demote_group)) {
				yyerror("yyparse: demote group name too long");
				free($2);
				YYERROR;
			}
			free($2);
			if (carp_demote_init(conf->demote_group, 1) == -1) {
				yyerror("yyparse: error initializing group %s",
				    conf->demote_group);
				YYERROR;
			}
		}
		;

loglevel	: UPDATES		{ $$ = HOSTSTATED_OPT_LOGUPDATE; }
		| ALL			{ $$ = HOSTSTATED_OPT_LOGALL; }
		;

service		: SERVICE STRING	{
			struct service *srv;

			TAILQ_FOREACH(srv, conf->services, entry)
				if (!strcmp(srv->conf.name, $2))
					break;
			if (srv != NULL) {
				yyerror("service %s defined twice", $2);
				free($2);
				YYERROR;
			}
			if ((srv = calloc(1, sizeof (*srv))) == NULL)
				fatal("out of memory");

			if (strlcpy(srv->conf.name, $2,
			    sizeof(srv->conf.name)) >=
			    sizeof(srv->conf.name)) {
				yyerror("service name truncated");
				YYERROR;
			}
			free($2);
			srv->conf.id = last_service_id++;
			if (last_service_id == INT_MAX) {
				yyerror("too many services defined");
				YYERROR;
			}
			service = srv;
		} '{' optnl serviceopts_l '}'	{
			if (service->table == NULL) {
				yyerror("service %s has no table",
				    service->conf.name);
				YYERROR;
			}
			if (TAILQ_EMPTY(&service->virts)) {
				yyerror("service %s has no virtual ip",
				    service->conf.name);
				YYERROR;
			}
			conf->servicecount++;
			if (service->backup == NULL) {
				service->conf.backup_id =
				    conf->empty_table.conf.id;
				service->backup = &conf->empty_table;
			} else if (service->backup->conf.port !=
			    service->table->conf.port) {
				yyerror("service %s uses two different ports "
				    "for its table and backup table",
				    service->conf.name);
				YYERROR;
			}

			if (!(service->conf.flags & F_DISABLE))
				service->conf.flags |= F_ADD;
			TAILQ_INSERT_HEAD(conf->services, service, entry);
		}
		;

serviceopts_l	: serviceopts_l serviceoptsl nl
		| serviceoptsl optnl
		;

serviceoptsl	: TABLE STRING dstport	{
			struct table	*tb;
			in_port_t	 port;

			port = $3;
			if (port == 0)
				port = service->conf.port;
			if ((tb = table_inherit($2, port)) == NULL) {
				free($2);
				YYERROR;
			}
			free($2);

			service->table = tb;
			service->conf.table_id = tb->conf.id;
			service->table->conf.serviceid = service->conf.id;
			service->table->conf.flags |= F_USED;
		}
		| BACKUP TABLE STRING dstport	{
			struct table	*tb;
			in_port_t	 port;

			if (service->backup) {
				yyerror("backup already specified");
				free($3);
				YYERROR;
			}

			port = $4;
			if (port == 0)
				port = service->conf.port;
			if ((tb = table_inherit($3, port)) == NULL) {
				free($3);
				YYERROR;
			}
			free($3);

			service->backup = tb;
			service->conf.backup_id = tb->conf.id;
			service->backup->conf.serviceid = service->conf.id;
			service->backup->conf.flags |= (F_USED|F_BACKUP);
		}
		| VIRTUAL HOST STRING port interface {
			if (host($3, &service->virts,
				 SRV_MAX_VIRTS, $4, $5) <= 0) {
				yyerror("invalid virtual ip: %s", $3);
				free($3);
				free($5);
				YYERROR;
			}
			free($3);
			free($5);
			if (service->conf.port == 0)
				service->conf.port = $4;
		}
		| DISABLE		{ service->conf.flags |= F_DISABLE; }
		| STICKYADDR		{ service->conf.flags |= F_STICKY; }
		| TAG STRING {
			if (strlcpy(service->conf.tag, $2,
			    sizeof(service->conf.tag)) >=
			    sizeof(service->conf.tag)) {
				yyerror("service tag name truncated");
				free($2);
				YYERROR;
			}
			free($2);
		}
		| include
		;

table		: TABLE STRING	{
			struct table *tb;

			TAILQ_FOREACH(tb, conf->tables, entry)
				if (!strcmp(tb->conf.name, $2))
					break;
			if (tb != NULL) {
				yyerror("table %s defined twice", $2);
				free($2);
				YYERROR;
			}

			if ((tb = calloc(1, sizeof (*tb))) == NULL)
				fatal("out of memory");

			if (strlcpy(tb->conf.name, $2, sizeof(tb->conf.name)) >=
			    sizeof(tb->conf.name)) {
				yyerror("table name truncated");
				YYERROR;
			}
			tb->conf.id = last_table_id++;
			bcopy(&conf->timeout, &tb->conf.timeout,
			    sizeof(struct timeval));
			if (last_table_id == INT_MAX) {
				yyerror("too many tables defined");
				YYERROR;
			}
			free($2);
			table = tb;
		} '{' optnl tableopts_l '}'	{
			if (TAILQ_EMPTY(&table->hosts)) {
				yyerror("table %s has no hosts",
				    table->conf.name);
				YYERROR;
			}
			if (table->conf.check == CHECK_NOCHECK) {
				yyerror("table %s has no check",
				    table->conf.name);
				YYERROR;
			}
			conf->tablecount++;
			TAILQ_INSERT_HEAD(conf->tables, table, entry);
		}
		;

tableopts_l	: tableopts_l tableoptsl nl
		| tableoptsl optnl
		;

tableoptsl	: host			{
			$1->conf.tableid = table->conf.id;
			$1->tablename = table->conf.name;
			TAILQ_INSERT_HEAD(&table->hosts, $1, entry);
		}
		| TIMEOUT timeout	{
			bcopy(&$2, &table->conf.timeout,
			    sizeof(struct timeval));
		}
		| CHECK ICMP		{
			table->conf.check = CHECK_ICMP;
		}
		| CHECK TCP		{
			table->conf.check = CHECK_TCP;
		}
		| CHECK SSL		{
			table->conf.check = CHECK_TCP;
			conf->flags |= F_SSL;
			table->conf.flags |= F_SSL;
		}
		| CHECK http_type STRING hostname CODE NUMBER {
			if ($2) {
				conf->flags |= F_SSL;
				table->conf.flags |= F_SSL;
			}
			table->conf.check = CHECK_HTTP_CODE;
			if ((table->conf.retcode = $6) <= 0) {
				yyerror("invalid HTTP code: %d", $6);
				free($3);
				free($4);
				YYERROR;
			}
			if (asprintf(&table->sendbuf,
			    "HEAD %s HTTP/1.0\r\n%s\r\n", $3, $4) == -1)
				fatal("asprintf");
			free($3);
			free($4);
			if (table->sendbuf == NULL)
				fatal("out of memory");
			table->sendbuf_len = strlen(table->sendbuf);
		}
		| CHECK http_type STRING hostname digest {
			if ($2) {
				conf->flags |= F_SSL;
				table->conf.flags |= F_SSL;
			}
			table->conf.check = CHECK_HTTP_DIGEST;
			if (asprintf(&table->sendbuf,
			    "GET %s HTTP/1.0\r\n%s\r\n", $3, $4) == -1)
				fatal("asprintf");
			free($3);
			free($4);
			if (table->sendbuf == NULL)
				fatal("out of memory");
			table->sendbuf_len = strlen(table->sendbuf);
			(void)strlcpy(table->conf.digest, $5.digest,
			    sizeof(table->conf.digest));
			table->conf.digest_type = $5.type;
			free($5.digest);
		}
		| CHECK SEND sendbuf EXPECT STRING optssl {
			table->conf.check = CHECK_SEND_EXPECT;
			if ($6) {
				conf->flags |= F_SSL;
				table->conf.flags |= F_SSL;
			}
			if (strlcpy(table->conf.exbuf, $5,
			    sizeof(table->conf.exbuf))
			    >= sizeof(table->conf.exbuf)) {
				yyerror("yyparse: expect buffer truncated");
				free($5);
				YYERROR;
			}
			translate_string(table->conf.exbuf);
			free($5);
		}
		| CHECK SCRIPT STRING {
			table->conf.check = CHECK_SCRIPT;
			if (strlcpy(table->conf.path, $3,
			    sizeof(table->conf.path)) >=
			    sizeof(table->conf.path)) {
				yyerror("script path truncated");
				free($3);
				YYERROR;
			}
			free($3);
		}
		| REAL port {
			table->conf.port = $2;
		}
		| DEMOTE STRING	{
			table->conf.flags |= F_DEMOTE;
			if (strlcpy(table->conf.demote_group, $2,
			    sizeof(table->conf.demote_group))
			    >= sizeof(table->conf.demote_group)) {
				yyerror("yyparse: demote group name too long");
				free($2);
				YYERROR;
			}
			free($2);
			if (carp_demote_init(table->conf.demote_group, 1)
			    == -1) {
				yyerror("yyparse: error initializing group "
				    "'%s'", table->conf.demote_group);
				YYERROR;
			}
		}
		| DISABLE			{
			table->conf.flags |= F_DISABLE;
		}
		| INTERVAL NUMBER		{
			if ($2 < conf->interval.tv_sec ||
			    $2 % conf->interval.tv_sec) {
				yyerror("table interval must be "
				    "divisible by global interval");
				YYERROR;
			}
			table->conf.skip_cnt = ($2 / conf->interval.tv_sec) - 1;
		}
		| include
		;

digest		: DIGEST STRING
		{
			switch (strlen($2)) {
			case 40:
				$$.type = DIGEST_SHA1;
				break;
			case 32:
				$$.type = DIGEST_MD5;
				break;
			default:
				yyerror("invalid http digest");
				free($2);
				YYERROR;
			}
			$$.digest = $2;
		}
		;

proto		: PROTO STRING	{
			struct protocol *p;

			if (strcmp($2, "default") == 0) {
				p = &conf->proto_default;
			} else {
				TAILQ_FOREACH(p, conf->protos, entry)
					if (!strcmp(p->name, $2))
						break;
			}
			if (p != NULL) {
				yyerror("protocol %s defined twice", $2);
				free($2);
				YYERROR;
			}
			if ((p = calloc(1, sizeof (*p))) == NULL)
				fatal("out of memory");

			if (strlcpy(p->name, $2, sizeof(p->name)) >=
			    sizeof(p->name)) {
				yyerror("protocol name truncated");
				YYERROR;
			}
			free($2);
			p->id = last_proto_id++;
			p->cache = RELAY_CACHESIZE;
			p->type = RELAY_PROTO_TCP;
			p->tcpflags = TCPFLAG_DEFAULT;
			p->sslflags = SSLFLAG_DEFAULT;
			p->tcpbacklog = RELAY_BACKLOG;
			(void)strlcpy(p->sslciphers, SSLCIPHERS_DEFAULT,
			    sizeof(p->sslciphers));
			if (last_proto_id == INT_MAX) {
				yyerror("too many protocols defined");
				YYERROR;
			}
			RB_INIT(&p->request_tree);
			RB_INIT(&p->response_tree);
			proto = p;
		} '{' optnl protopts_l '}'	{
			conf->protocount++;

			if ((proto->sslflags & SSLFLAG_VERSION) == 0) {
				yyerror("invalid SSL protocol");
				YYERROR;
			}

			TAILQ_INSERT_HEAD(conf->protos, proto, entry);
		}
		;

protopts_l	: protopts_l protoptsl nl
		| protoptsl optnl
		;

protoptsl	: SSL sslflags
		| SSL '{' sslflags_l '}'
		| TCP tcpflags
		| TCP '{' tcpflags_l '}'
		| PROTO proto_type		{ proto->type = $2; }
		| RETURN ERROR opteflags	{ proto->flags |= F_RETURN; }
		| RETURN ERROR '{' eflags_l '}'	{ proto->flags |= F_RETURN; }
		| LABEL STRING			{
			label = pn_name2id($2);
			free($2);
			if (label == 0) {
				yyerror("invalid protocol action label");
				YYERROR;
			}
		}
		| NO LABEL			{
			label = 0;
		}
		| direction protonode log	{
			struct protonode	*pn, *proot, pk;
			struct proto_tree	*tree;

			if ($1 == RELAY_DIR_RESPONSE)
				tree = &proto->response_tree;
			else
				tree = &proto->request_tree;
			if ((pn = calloc(1, sizeof (*pn))) == NULL)
				fatal("out of memory");

			bcopy(&node, pn, sizeof(*pn));
			pn->key = node.key;
			pn->value = node.value;
			pn->type = node.type;
			pn->label = label;
			SIMPLEQ_INIT(&pn->head);
			if ($1 == RELAY_DIR_RESPONSE)
				pn->id = proto->response_nodes++;
			else
				pn->id = proto->request_nodes++;
			if ($3)
				pn->flags |= PNFLAG_LOG;
			if (pn->id == INT_MAX) {
				yyerror("too many protocol nodes defined");
				YYERROR;
			}
			if ((proot =
			    RB_INSERT(proto_tree, tree, pn)) != NULL) {
				/*
				 * A protocol node with the same key already
				 * exists, append it to a queue behind the
				 * existing node.
				 */
				if (SIMPLEQ_EMPTY(&proot->head))
					SIMPLEQ_NEXT(proot, entry) = pn;
				SIMPLEQ_INSERT_TAIL(&proot->head, pn, entry);
			}

			if (node.type == NODE_TYPE_COOKIE)
				pk.key = "Cookie";
			else if (node.type == NODE_TYPE_URL)
				pk.key = "Host";
			else
				pk.key = "GET";
			if (node.type != NODE_TYPE_HEADER) {
				pk.type = NODE_TYPE_HEADER;
				pn = RB_FIND(proto_tree, tree, &pk);
				if (pn == NULL) {
					if ((pn = (struct protonode *)
					    calloc(1, sizeof(*pn))) == NULL)
						fatal("out of memory");
					pn->key = strdup(pk.key);
					if (pn->key == NULL)
						fatal("out of memory");
					pn->value = NULL;
					pn->action = NODE_ACTION_NONE;
					pn->type = pk.type;
					SIMPLEQ_INIT(&pn->head);
					if ($1 == RELAY_DIR_RESPONSE)
						pn->id =
						    proto->response_nodes++;
					else
						pn->id = proto->request_nodes++;
					if (pn->id == INT_MAX) {
						yyerror("too many protocol "
						    "nodes defined");
						YYERROR;
					}
					RB_INSERT(proto_tree, tree, pn);
				}
				switch (node.type) {
				case NODE_TYPE_QUERY:
					pn->flags |= PNFLAG_LOOKUP_QUERY;
					break;
				case NODE_TYPE_COOKIE:
					pn->flags |= PNFLAG_LOOKUP_COOKIE;
					break;
				case NODE_TYPE_URL:
					if (node.flags &
					    PNFLAG_LOOKUP_URL_DIGEST)
						pn->flags |= node.flags &
						    PNFLAG_LOOKUP_URL_DIGEST;
					else
						pn->flags |=
						    PNFLAG_LOOKUP_DIGEST(0);
					break;
				default:
					break;
				}
			}

			bzero(&node, sizeof(node));
		}
		| include
		;

direction	: /* empty */		{ $$ = RELAY_DIR_REQUEST; }
		| REQUEST		{ $$ = RELAY_DIR_REQUEST; }
		| RESPONSE		{ $$ = RELAY_DIR_RESPONSE; }
		;

tcpflags_l	: tcpflags comma tcpflags_l
		| tcpflags
		;

tcpflags	: SACK			{ proto->tcpflags |= TCPFLAG_SACK; }
		| NO SACK		{ proto->tcpflags |= TCPFLAG_NSACK; }
		| NODELAY		{ proto->tcpflags |= TCPFLAG_NODELAY; }
		| NO NODELAY		{ proto->tcpflags |= TCPFLAG_NNODELAY; }
		| BACKLOG NUMBER	{
			if ($2 < 0 || $2 > RELAY_MAX_SESSIONS) {
				yyerror("invalid backlog: %d", $2);
				YYERROR;
			}
			proto->tcpbacklog = $2;
		}
		| SOCKET BUFFER NUMBER	{
			proto->tcpflags |= TCPFLAG_BUFSIZ;
			if ((proto->tcpbufsiz = $3) < 0) {
				yyerror("invalid socket buffer size: %d", $3);
				YYERROR;
			}
		}
		| IP STRING NUMBER	{
			if ($3 < 0) {
				yyerror("invalid ttl: %d", $3);
				free($2);
				YYERROR;
			}
			if (strcasecmp("ttl", $2) == 0) {
				proto->tcpflags |= TCPFLAG_IPTTL;
				proto->tcpipttl = $3;
			} else if (strcasecmp("minttl", $2) == 0) {
				proto->tcpflags |= TCPFLAG_IPMINTTL;
				proto->tcpipminttl = $3;
			} else {
				yyerror("invalid TCP/IP flag: %s", $2);
				free($2);
				YYERROR;
			}
			free($2);
		}
		;

sslflags_l	: sslflags comma sslflags_l
		| sslflags
		;

sslflags	: SESSION CACHE sslcache	{ proto->cache = $3; }
		| CIPHERS STRING		{
			if (strlcpy(proto->sslciphers, $2,
			    sizeof(proto->sslciphers)) >=
			    sizeof(proto->sslciphers)) {
				yyerror("sslciphers truncated");
				free($2);
				YYERROR;
			}
			free($2);
		}
		| NO flag			{ proto->sslflags &= ~($2); }
		| flag				{ proto->sslflags |= $1; }
		;

flag		: STRING			{
			if (strcmp("sslv2", $1) == 0)
				$$ = SSLFLAG_SSLV2;
			else if (strcmp("sslv3", $1) == 0)
				$$ = SSLFLAG_SSLV3;
			else if (strcmp("tlsv1", $1) == 0)
				$$ = SSLFLAG_TLSV1;
			else {
				yyerror("invalid SSL flag: %s", $1);
				free($1);
				YYERROR;
			}
			free($1);
		}
		;

protonode	: nodetype APPEND STRING TO STRING marked	{
			node.action = NODE_ACTION_APPEND;
			node.key = strdup($5);
			node.value = strdup($3);
			if (node.key == NULL || node.value == NULL)
				fatal("out of memory");
			if (strchr(node.value, '$') != NULL)
				node.flags |= PNFLAG_MACRO;
			free($5);
			free($3);
		}
		| nodetype CHANGE STRING TO STRING marked {
			node.action = NODE_ACTION_CHANGE;
			node.key = strdup($3);
			node.value = strdup($5);
			if (node.key == NULL || node.value == NULL)
				fatal("out of memory");
			if (strchr(node.value, '$') != NULL)
				node.flags |= PNFLAG_MACRO;
			free($5);
			free($3);
		}
		| nodetype REMOVE STRING marked			{
			node.action = NODE_ACTION_REMOVE;
			node.key = strdup($3);
			node.value = NULL;
			if (node.key == NULL)
				fatal("out of memory");
			free($3);
		}
		| nodetype EXPECT STRING FROM STRING marked	{
			node.action = NODE_ACTION_EXPECT;
			node.key = strdup($5);
			node.value = strdup($3);
			if (node.key == NULL || node.value == NULL)
				fatal("out of memory");
			free($5);
			free($3);
			proto->lateconnect++;
		}
		| nodetype EXPECT STRING marked			{
			node.action = NODE_ACTION_EXPECT;
			node.key = strdup($3);
			node.value = strdup("*");
			if (node.key == NULL || node.value == NULL)
				fatal("out of memory");
			free($3);
			proto->lateconnect++;
		}
		| nodetype EXPECT digest marked			{
			if (node.type != NODE_TYPE_URL) {
				yyerror("digest not supported for this type");
				free($3.digest);
				YYERROR;
			}
			node.action = NODE_ACTION_EXPECT;
			node.key = strdup($3.digest);
			node.flags |= PNFLAG_LOOKUP_DIGEST($3.type);
			node.value = strdup("*");
			if (node.key == NULL || node.value == NULL)
				fatal("out of memory");
			free($3.digest);
			proto->lateconnect++;
		}
		| nodetype FILTER STRING FROM STRING marked	{
			node.action = NODE_ACTION_FILTER;
			node.key = strdup($5);
			node.value = strdup($3);
			if (node.key == NULL || node.value == NULL)
				fatal("out of memory");
			free($5);
			free($3);
			proto->lateconnect++;
		}
		| nodetype FILTER STRING marked			{
			node.action = NODE_ACTION_FILTER;
			node.key = strdup($3);
			node.value = strdup("*");
			if (node.key == NULL || node.value == NULL)
				fatal("out of memory");
			free($3);
			proto->lateconnect++;
		}
		| nodetype FILTER digest marked			{
			if (node.type != NODE_TYPE_URL) {
				yyerror("digest not supported for this type");
				free($3.digest);
				YYERROR;
			}
			node.action = NODE_ACTION_FILTER;
			node.key = strdup($3.digest);
			node.flags |= PNFLAG_LOOKUP_DIGEST($3.type);
			node.value = strdup("*");
			if (node.key == NULL || node.value == NULL)
				fatal("out of memory");
			free($3.digest);
			proto->lateconnect++;
		}
		| nodetype HASH STRING marked			{
			node.action = NODE_ACTION_HASH;
			node.key = strdup($3);
			node.value = NULL;
			if (node.key == NULL)
				fatal("out of memory");
			free($3);
			proto->lateconnect++;
		}
		| nodetype LOG STRING marked			{
			node.action = NODE_ACTION_LOG;
			node.key = strdup($3);
			node.value = NULL;
			node.flags |= PNFLAG_LOG;
			if (node.key == NULL)
				fatal("out of memory");
			free($3);
		}
		| nodetype MARK STRING FROM STRING WITH mark	{
			node.action = NODE_ACTION_MARK;
			node.key = strdup($5);
			node.value = strdup($3);
			node.mark = $7;
			if (node.key == NULL || node.value == NULL)
				fatal("out of memory");
			free($3);
			free($5);
		}
		| nodetype MARK STRING WITH mark		{
			node.action = NODE_ACTION_MARK;
			node.key = strdup($3);
			node.value = strdup("*");
			node.mark = $5;
			if (node.key == NULL || node.value == NULL)
				fatal("out of memory");
			free($3);
		}
		;

marked		: /* empty */
		| MARKED mark			{ node.mark = $2; }
		;

mark		: NUMBER					{
			if ($1 <= 0 || $1 >= (int)USHRT_MAX) {
				yyerror("invalid mark: %d", $1);
				YYERROR;
			}
			$$ = $1;
		}
		;

nodetype	: HEADER			{
			node.type = NODE_TYPE_HEADER;
		}
		| QUERYSTR			{ node.type = NODE_TYPE_QUERY; }
		| COOKIE			{
			node.type = NODE_TYPE_COOKIE;
		}
		| PATH				{
			proto->flags |= F_LOOKUP_PATH;
			node.type = NODE_TYPE_PATH;
		}
		| URL				{ node.type = NODE_TYPE_URL; }
		;

sslcache	: NUMBER			{
			if ($1 < 0) {
				yyerror("invalid sslcache value: %d", $1);
				YYERROR;
			}
			$$ = $1;
		}
		| DISABLE			{ $$ = -2; }
		;

relay		: RELAY STRING	{
			struct relay *r;

			TAILQ_FOREACH(r, conf->relays, entry)
				if (!strcmp(r->conf.name, $2))
					break;
			if (r != NULL) {
				yyerror("relay %s defined twice", $2);
				free($2);
				YYERROR;
			}
			if ((r = calloc(1, sizeof (*r))) == NULL)
				fatal("out of memory");

			if (strlcpy(r->conf.name, $2, sizeof(r->conf.name)) >=
			    sizeof(r->conf.name)) {
				yyerror("relay name truncated");
				YYERROR;
			}
			free($2);
			r->conf.id = last_relay_id++;
			r->conf.timeout.tv_sec = RELAY_TIMEOUT;
			r->proto = NULL;
			r->conf.proto = EMPTY_ID;
			r->conf.dsttable = EMPTY_ID;
			r->conf.dstretry = 0;
			if (last_relay_id == INT_MAX) {
				yyerror("too many relays defined");
				YYERROR;
			}
			rlay = r;
		} '{' optnl relayopts_l '}'	{
			if (rlay->conf.ss.ss_family == AF_UNSPEC) {
				yyerror("relay %s has no listener",
				    rlay->conf.name);
				YYERROR;
			}
			if ((rlay->conf.flags & F_NATLOOK) == 0 &&
			    rlay->conf.dstss.ss_family == AF_UNSPEC &&
			    rlay->conf.dsttable == EMPTY_ID) {
				yyerror("relay %s has no target, service, "
				    "or table", rlay->conf.name);
				YYERROR;
			}
			if (rlay->conf.proto == EMPTY_ID) {
				rlay->proto = &conf->proto_default;
				rlay->conf.proto = conf->proto_default.id;
			}
			if (relay_load_certfiles(rlay) == -1) {
				yyerror("cannot load certificates for relay %s",
				    rlay->conf.name);
				YYERROR;
			}
			conf->relaycount++;
			SPLAY_INIT(&rlay->sessions);
			TAILQ_INSERT_HEAD(conf->relays, rlay, entry);
		}
		;

relayopts_l	: relayopts_l relayoptsl nl
		| relayoptsl optnl
		;

relayoptsl	: LISTEN ON STRING port optssl {
			struct addresslist	 al;
			struct address		*h;

			if (rlay->conf.ss.ss_family != AF_UNSPEC) {
				yyerror("relay %s listener already specified",
				    rlay->conf.name);
				YYERROR;
			}

			TAILQ_INIT(&al);
			if (host($3, &al, 1, $4, NULL) <= 0) {
				yyerror("invalid listen ip: %s", $3);
				free($3);
				YYERROR;
			}
			free($3);
			h = TAILQ_FIRST(&al);
			bcopy(&h->ss, &rlay->conf.ss, sizeof(rlay->conf.ss));
			rlay->conf.port = h->port;
			if ($5) {
				rlay->conf.flags |= F_SSL;
				conf->flags |= F_SSL;
			}
		}
		| FORWARD TO STRING port retry {
			struct addresslist	 al;
			struct address		*h;

			if (rlay->conf.dstss.ss_family != AF_UNSPEC) {
				yyerror("relay %s target or service already "
				    "specified", rlay->conf.name);
				free($3);
				YYERROR;
			}

			TAILQ_INIT(&al);
			if (host($3, &al, 1, $4, NULL) <= 0) {
				yyerror("invalid listen ip: %s", $3);
				free($3);
				YYERROR;
			}
			free($3);
			h = TAILQ_FIRST(&al);
			bcopy(&h->ss, &rlay->conf.dstss,
			    sizeof(rlay->conf.dstss));
			rlay->conf.dstport = h->port;
			rlay->conf.dstretry = $5;
		}
		| SERVICE STRING retry {
			struct service	*svc;
			struct address	*h;

			if (rlay->conf.dstss.ss_family != AF_UNSPEC) {
				yyerror("relay %s target or service already "
				    "specified", rlay->conf.name);
				free($2);
				YYERROR;
			}

			if ((svc = service_findbyname(conf, $2)) == NULL) {
				yyerror("relay %s for unknown service %s",
				    rlay->conf.name, $2);
				free($2);
				YYERROR;
			}
			free($2);
			h = TAILQ_FIRST(&svc->virts);
			bcopy(&h->ss, &rlay->conf.dstss,
			    sizeof(rlay->conf.dstss));
			rlay->conf.dstport = h->port;
			rlay->conf.dstretry = $3;
		}
		| TABLE STRING dstport dstmode docheck {
			struct table	*tb;

			rlay->conf.dstport = $3;
			if (rlay->conf.dstport == 0)
				rlay->conf.dstport = rlay->conf.port;

			if ((tb = table_inherit($2, rlay->conf.dstport)) ==
			    NULL) {
				free($2);
				YYERROR;
			}
			free($2);
			rlay->conf.dsttable = tb->conf.id;
			rlay->dsttable = tb;
			rlay->conf.dstport = tb->conf.port;
			rlay->conf.dstmode = $4;
			rlay->conf.dstcheck = $5;
			rlay->dsttable->conf.flags |= F_USED;
		}
		| PROTO STRING {
			struct protocol *p;

			TAILQ_FOREACH(p, conf->protos, entry)
				if (!strcmp(p->name, $2))
					break;
			if (p == NULL) {
				yyerror("no such protocol: %s", $2);
				free($2);
				YYERROR;
			}
			p->flags |= F_USED;
			rlay->conf.proto = p->id;
			rlay->proto = p;
			free($2);
		}
		| NAT LOOKUP retry	{
			rlay->conf.flags |= F_NATLOOK;
			rlay->conf.dstretry = $3;
		}
		| TIMEOUT NUMBER	{
			if ((rlay->conf.timeout.tv_sec = $2) < 0) {
				yyerror("invalid timeout: %d", $2);
				YYERROR;
			}
		}
		| DISABLE		{ rlay->conf.flags |= F_DISABLE; }
		| include
		;

dstmode		: /* empty */		{ $$ = RELAY_DSTMODE_DEFAULT; }
		| LOADBALANCE		{ $$ = RELAY_DSTMODE_LOADBALANCE; }
		| ROUNDROBIN		{ $$ = RELAY_DSTMODE_ROUNDROBIN; }
		| HASH			{ $$ = RELAY_DSTMODE_HASH; }
		;

docheck		: /* empty */		{ $$ = 1; }
		| NO CHECK		{ $$ = 0; }
		;

interface	: /*empty*/		{ $$ = NULL; }
		| INTERFACE STRING	{ $$ = $2; }
		;

dstport		: /* empty */		{ $$ = 0; }
		| port			{ $$ = $1; }
		;

host		: HOST STRING retry {
			struct address *a;
			struct addresslist al;

			if (($$ = calloc(1, sizeof(*($$)))) == NULL)
				fatal("out of memory");

			TAILQ_INIT(&al);
			if (host($2, &al, 1, 0, NULL) <= 0) {
				yyerror("invalid host %s", $2);
				free($2);
				free($$);
				YYERROR;
			}
			a = TAILQ_FIRST(&al);
			memcpy(&$$->conf.ss, &a->ss, sizeof($$->conf.ss));
			free(a);

			if (strlcpy($$->conf.name, $2, sizeof($$->conf.name)) >=
			    sizeof($$->conf.name)) {
				yyerror("host name truncated");
				free($2);
				free($$);
				YYERROR;
			}
			free($2);
			$$->conf.id = last_host_id++;
			$$->conf.retry = $3;
			if (last_host_id == INT_MAX) {
				yyerror("too many hosts defined");
				free($$);
				YYERROR;
			}
		}
		;

retry		: /* nothing */		{ $$ = 0; }
		| RETRY NUMBER		{
			if (($$ = $2) < 0) {
				yyerror("invalid retry value: %d\n", $2);
				YYERROR;
			}
		}
		;

timeout		: NUMBER
		{
			if ($1 < 0) {
				yyerror("invalid timeout: %d\n", $1);
				YYERROR;
			}
			$$.tv_sec = $1 / 1000;
			$$.tv_usec = ($1 % 1000) * 1000;
		}
		;

log		: /* empty */		{ $$ = 0; }
		| LOG			{ $$ = 1; }
		;

comma		: ','
		| /* empty */
		;

optnl		: '\n' optnl
		|
		;

nl		: '\n' optnl
		;

%%

struct keywords {
	const char	*k_name;
	int		 k_val;
};

int
yyerror(const char *fmt, ...)
{
	va_list		 ap;

	file->errors++;
	va_start(ap, fmt);
	fprintf(stderr, "%s:%d: ", file->name, yylval.lineno);
	vfprintf(stderr, fmt, ap);
	fprintf(stderr, "\n");
	va_end(ap);
	return (0);
}

int
kw_cmp(const void *k, const void *e)
{
	return (strcmp(k, ((const struct keywords *)e)->k_name));
}

int
lookup(char *s)
{
	/* this has to be sorted always */
	static const struct keywords keywords[] = {
		{ "all",		ALL },
		{ "append",		APPEND },
		{ "backlog",		BACKLOG },
		{ "backup",		BACKUP },
		{ "buffer",		BUFFER },
		{ "cache",		CACHE },
		{ "change",		CHANGE },
		{ "check",		CHECK },
		{ "ciphers",		CIPHERS },
		{ "code",		CODE },
		{ "cookie",		COOKIE },
		{ "demote",		DEMOTE },
		{ "digest",		DIGEST },
		{ "disable",		DISABLE },
		{ "error",		ERROR },
		{ "expect",		EXPECT },
		{ "external",		EXTERNAL },
		{ "filter",		FILTER },
		{ "forward",		FORWARD },
		{ "from",		FROM },
		{ "hash",		HASH },
		{ "header",		HEADER },
		{ "host",		HOST },
		{ "icmp",		ICMP },
		{ "include",		INCLUDE },
		{ "interface",		INTERFACE },
		{ "interval",		INTERVAL },
		{ "ip",			IP },
		{ "label",		LABEL },
		{ "listen",		LISTEN },
		{ "loadbalance",	LOADBALANCE },
		{ "log",		LOG },
		{ "lookup",		LOOKUP },
		{ "mark",		MARK },
		{ "marked",		MARKED },
		{ "nat",		NAT },
		{ "no",			NO },
		{ "nodelay",		NODELAY },
		{ "nothing",		NOTHING },
		{ "on",			ON },
		{ "path",		PATH },
		{ "port",		PORT },
		{ "prefork",		PREFORK },
		{ "protocol",		PROTO },
		{ "query",		QUERYSTR },
		{ "real",		REAL },
		{ "relay",		RELAY },
		{ "remove",		REMOVE },
		{ "request",		REQUEST },
		{ "response",		RESPONSE },
		{ "retry",		RETRY },
		{ "return",		RETURN },
		{ "roundrobin",		ROUNDROBIN },
		{ "sack",		SACK },
		{ "script",		SCRIPT },
		{ "send",		SEND },
		{ "service",		SERVICE },
		{ "session",		SESSION },
		{ "socket",		SOCKET },
		{ "ssl",		SSL },
		{ "sticky-address",	STICKYADDR },
		{ "style",		STYLE },
		{ "table",		TABLE },
		{ "tag",		TAG },
		{ "tcp",		TCP },
		{ "timeout",		TIMEOUT },
		{ "to",			TO },
		{ "updates",		UPDATES },
		{ "url",		URL },
		{ "virtual",		VIRTUAL },
		{ "with",		WITH }
	};
	const struct keywords	*p;

	p = bsearch(s, keywords, sizeof(keywords)/sizeof(keywords[0]),
	    sizeof(keywords[0]), kw_cmp);

	if (p)
		return (p->k_val);
	else
		return (STRING);
}

#define MAXPUSHBACK	128

char	*parsebuf;
int	 parseindex;
char	 pushback_buffer[MAXPUSHBACK];
int	 pushback_index = 0;

int
lgetc(int quotec)
{
	int		c, next;

	if (parsebuf) {
		/* Read character from the parsebuffer instead of input. */
		if (parseindex >= 0) {
			c = parsebuf[parseindex++];
			if (c != '\0')
				return (c);
			parsebuf = NULL;
		} else
			parseindex++;
	}

	if (pushback_index)
		return (pushback_buffer[--pushback_index]);

	if (quotec) {
		if ((c = getc(file->stream)) == EOF) {
			yyerror("reached end of file while parsing "
			    "quoted string");
			if (popfile() == EOF)
				return (EOF);
			return (quotec);
		}
		return (c);
	}

	while ((c = getc(file->stream)) == '\\') {
		next = getc(file->stream);
		if (next != '\n') {
			c = next;
			break;
		}
		yylval.lineno = file->lineno;
		file->lineno++;
	}

	while (c == EOF) {
		if (popfile() == EOF)
			return (EOF);
		c = getc(file->stream);
	}
	return (c);
}

int
lungetc(int c)
{
	if (c == EOF)
		return (EOF);
	if (parsebuf) {
		parseindex--;
		if (parseindex >= 0)
			return (c);
	}
	if (pushback_index < MAXPUSHBACK-1)
		return (pushback_buffer[pushback_index++] = c);
	else
		return (EOF);
}

int
findeol(void)
{
	int	c;

	parsebuf = NULL;
	pushback_index = 0;

	/* skip to either EOF or the first real EOL */
	while (1) {
		c = lgetc(0);
		if (c == '\n') {
			file->lineno++;
			break;
		}
		if (c == EOF)
			break;
	}
	return (ERROR);
}

int
yylex(void)
{
	char	 buf[8096];
	char	*p, *val;
	int	 quotec, next, c;
	int	 token;

top:
	p = buf;
	while ((c = lgetc(0)) == ' ' || c == '\t')
		; /* nothing */

	yylval.lineno = file->lineno;
	if (c == '#')
		while ((c = lgetc(0)) != '\n' && c != EOF)
			; /* nothing */
	if (c == '$' && parsebuf == NULL) {
		while (1) {
			if ((c = lgetc(0)) == EOF)
				return (0);

			if (p + 1 >= buf + sizeof(buf) - 1) {
				yyerror("string too long");
				return (findeol());
			}
			if (isalnum(c) || c == '_') {
				*p++ = (char)c;
				continue;
			}
			*p = '\0';
			lungetc(c);
			break;
		}
		val = symget(buf);
		if (val == NULL) {
			yyerror("macro '%s' not defined", buf);
			return (findeol());
		}
		parsebuf = val;
		parseindex = 0;
		goto top;
	}

	switch (c) {
	case '\'':
	case '"':
		quotec = c;
		while (1) {
			if ((c = lgetc(quotec)) == EOF)
				return (0);
			if (c == '\n') {
				file->lineno++;
				continue;
			} else if (c == '\\') {
				if ((next = lgetc(quotec)) == EOF)
					return (0);
				if (next == quotec || c == ' ' || c == '\t')
					c = next;
				else if (next == '\n')
					continue;
				else
					lungetc(next);
			} else if (c == quotec) {
				*p = '\0';
				break;
			}
			if (p + 1 >= buf + sizeof(buf) - 1) {
				yyerror("string too long");
				return (findeol());
			}
			*p++ = (char)c;
		}
		yylval.v.string = strdup(buf);
		if (yylval.v.string == NULL)
			err(1, "yylex: strdup");
		return (STRING);
	}

#define allowed_to_end_number(x) \
	(isspace(x) || x == ')' || x ==',' || x == '/' || x == '}' || x == '=')

	if (c == '-' || isdigit(c)) {
		do {
			*p++ = c;
			if ((unsigned)(p-buf) >= sizeof(buf)) {
				yyerror("string too long");
				return (findeol());
			}
		} while ((c = lgetc(0)) != EOF && isdigit(c));
		lungetc(c);
		if (p == buf + 1 && buf[0] == '-')
			goto nodigits;
		if (c == EOF || allowed_to_end_number(c)) {
			const char *errstr = NULL;

			*p = '\0';
			yylval.v.number = strtonum(buf, LLONG_MIN,
			    LLONG_MAX, &errstr);
			if (errstr) {
				yyerror("\"%s\" invalid number: %s",
				    buf, errstr);
				return (findeol());
			}
			return (NUMBER);
		} else {
nodigits:
			while (p > buf + 1)
				lungetc(*--p);
			c = *--p;
			if (c == '-')
				return (c);
		}
	}

#define allowed_in_string(x) \
	(isalnum(x) || (ispunct(x) && x != '(' && x != ')' && \
	x != '{' && x != '}' && \
	x != '!' && x != '=' && x != '#' && \
	x != ','))

	if (isalnum(c) || c == ':' || c == '_') {
		do {
			*p++ = c;
			if ((unsigned)(p-buf) >= sizeof(buf)) {
				yyerror("string too long");
				return (findeol());
			}
		} while ((c = lgetc(0)) != EOF && (allowed_in_string(c)));
		lungetc(c);
		*p = '\0';
		if ((token = lookup(buf)) == STRING)
			if ((yylval.v.string = strdup(buf)) == NULL)
				err(1, "yylex: strdup");
		return (token);
	}
	if (c == '\n') {
		yylval.lineno = file->lineno;
		file->lineno++;
	}
	if (c == EOF)
		return (0);
	return (c);
}

int
check_file_secrecy(int fd, const char *fname)
{
	struct stat	st;

	if (fstat(fd, &st)) {
		log_warn("cannot stat %s", fname);
		return (-1);
	}
	if (st.st_uid != 0 && st.st_uid != getuid()) {
		log_warnx("%s: owner not root or current user", fname);
		return (-1);
	}
	if (st.st_mode & (S_IRWXG | S_IRWXO)) {
		log_warnx("%s: group/world readable/writeable", fname);
		return (-1);
	}
	return (0);
}

struct file *
pushfile(const char *name, int secret)
{
	struct file	*nfile;

	if ((nfile = calloc(1, sizeof(struct file))) == NULL ||
	    (nfile->name = strdup(name)) == NULL) {
		log_warn("malloc");
		return (NULL);
	}
	if ((nfile->stream = fopen(nfile->name, "r")) == NULL) {
		log_warn("%s", nfile->name);
		free(nfile->name);
		free(nfile);
		return (NULL);
	} else if (secret &&
	    check_file_secrecy(fileno(nfile->stream), nfile->name)) {
		fclose(nfile->stream);
		free(nfile->name);
		free(nfile);
		return (NULL);
	}
	nfile->lineno = 1;
	TAILQ_INSERT_TAIL(&files, nfile, entry);
	return (nfile);
}

int
popfile(void)
{
	struct file	*prev;

	if ((prev = TAILQ_PREV(file, files, entry)) != NULL) {
		prev->errors += file->errors;
		TAILQ_REMOVE(&files, file, entry);
		fclose(file->stream);
		free(file->name);
		free(file);
		file = prev;
		return (0);
	}
	return (EOF);
}

struct hoststated *
parse_config(const char *filename, int opts)
{
	struct sym	*sym, *next;
	struct table	*nexttb;
	struct host	*h;

	if ((conf = calloc(1, sizeof(*conf))) == NULL ||
	    (conf->tables = calloc(1, sizeof(*conf->tables))) == NULL ||
	    (conf->relays = calloc(1, sizeof(*conf->relays))) == NULL ||
	    (conf->protos = calloc(1, sizeof(*conf->protos))) == NULL ||
	    (conf->services = calloc(1, sizeof(*conf->services))) == NULL) {
		log_warn("cannot allocate memory");
		return (NULL);
	}

	errors = 0;
	last_host_id = last_table_id = last_service_id = last_proto_id =
	    last_relay_id = 0;

	service = NULL;
	table = NULL;
	rlay = NULL;
	proto = NULL;

	TAILQ_INIT(conf->services);
	TAILQ_INIT(conf->tables);
	TAILQ_INIT(conf->protos);
	TAILQ_INIT(conf->relays);

	memset(&conf->empty_table, 0, sizeof(conf->empty_table));
	conf->empty_table.conf.id = EMPTY_TABLE;
	conf->empty_table.conf.flags |= F_DISABLE;
	(void)strlcpy(conf->empty_table.conf.name, "empty",
	    sizeof(conf->empty_table.conf.name));

	bzero(&conf->proto_default, sizeof(conf->proto_default));
	conf->proto_default.flags = F_USED;
	conf->proto_default.cache = RELAY_CACHESIZE;
	conf->proto_default.type = RELAY_PROTO_TCP;
	(void)strlcpy(conf->proto_default.name, "default",
	    sizeof(conf->proto_default.name));
	RB_INIT(&conf->proto_default.request_tree);
	RB_INIT(&conf->proto_default.response_tree);

	conf->timeout.tv_sec = CHECK_TIMEOUT / 1000;
	conf->timeout.tv_usec = (CHECK_TIMEOUT % 1000) * 1000;
	conf->interval.tv_sec = CHECK_INTERVAL;
	conf->interval.tv_usec = 0;
	conf->prefork_relay = RELAY_NUMPROC;
	conf->statinterval.tv_sec = RELAY_STATINTERVAL;
	conf->opts = opts;
	conf->confpath = filename;

	if ((file = pushfile(filename, 0)) == NULL) {
		free(conf);
		return (NULL);
	}
	setservent(1);

	yyparse();
	errors = file->errors;
	popfile();

	endservent();

	/* Free macros and check which have not been used. */
	for (sym = TAILQ_FIRST(&symhead); sym != NULL; sym = next) {
		next = TAILQ_NEXT(sym, entry);
		if ((conf->opts & HOSTSTATED_OPT_VERBOSE) && !sym->used)
			fprintf(stderr, "warning: macro '%s' not "
			    "used\n", sym->nam);
		if (!sym->persist) {
			free(sym->nam);
			free(sym->val);
			TAILQ_REMOVE(&symhead, sym, entry);
			free(sym);
		}
	}

	if (TAILQ_EMPTY(conf->services) && TAILQ_EMPTY(conf->relays)) {
		log_warnx("no services, nothing to do");
		errors++;
	}

	if (TAILQ_EMPTY(conf->relays))
		conf->prefork_relay = 0;

	if (timercmp(&conf->timeout, &conf->interval, >=)) {
		log_warnx("global timeout exceeds interval");
		errors++;
	}

	/* Verify that every table is used */
	for (table = TAILQ_FIRST(conf->tables); table != NULL;
	     table = nexttb) {
		nexttb = TAILQ_NEXT(table, entry);
		if (table->conf.port == 0) {
			TAILQ_REMOVE(conf->tables, table, entry);
			while ((h = TAILQ_FIRST(&table->hosts)) != NULL) {
				TAILQ_REMOVE(&table->hosts, h, entry);
				free(h);
			}
			if (table->sendbuf != NULL)
				free(table->sendbuf);
			free(table);
			continue;
		}
		if (!(table->conf.flags & F_USED)) {
			log_warnx("unused table: %s", table->conf.name);
			errors++;
		}
		if (timercmp(&table->conf.timeout, &conf->interval, >=)) {
			log_warnx("table timeout exceeds interval: %s",
			    table->conf.name);
			errors++;
		}
	}

	/* Verify that every non-default protocol is used */
	TAILQ_FOREACH(proto, conf->protos, entry) {
		if (!(proto->flags & F_USED)) {
			log_warnx("unused protocol: %s", proto->name);
		}
	}

	if (errors) {
		free(conf);
		return (NULL);
	}

	return (conf);
}

int
symset(const char *nam, const char *val, int persist)
{
	struct sym	*sym;

	for (sym = TAILQ_FIRST(&symhead); sym && strcmp(nam, sym->nam);
	    sym = TAILQ_NEXT(sym, entry))
		;	/* nothing */

	if (sym != NULL) {
		if (sym->persist == 1)
			return (0);
		else {
			free(sym->nam);
			free(sym->val);
			TAILQ_REMOVE(&symhead, sym, entry);
			free(sym);
		}
	}
	if ((sym = calloc(1, sizeof(*sym))) == NULL)
		return (-1);

	sym->nam = strdup(nam);
	if (sym->nam == NULL) {
		free(sym);
		return (-1);
	}
	sym->val = strdup(val);
	if (sym->val == NULL) {
		free(sym->nam);
		free(sym);
		return (-1);
	}
	sym->used = 0;
	sym->persist = persist;
	TAILQ_INSERT_TAIL(&symhead, sym, entry);
	return (0);
}

int
cmdline_symset(char *s)
{
	char	*sym, *val;
	int	ret;
	size_t	len;

	if ((val = strrchr(s, '=')) == NULL)
		return (-1);

	len = strlen(s) - strlen(val) + 1;
	if ((sym = malloc(len)) == NULL)
		errx(1, "cmdline_symset: malloc");

	(void)strlcpy(sym, s, len);

	ret = symset(sym, val + 1, 1);
	free(sym);

	return (ret);
}

char *
symget(const char *nam)
{
	struct sym	*sym;

	TAILQ_FOREACH(sym, &symhead, entry)
		if (strcmp(nam, sym->nam) == 0) {
			sym->used = 1;
			return (sym->val);
		}
	return (NULL);
}

struct address *
host_v4(const char *s)
{
	struct in_addr		 ina;
	struct sockaddr_in	*sain;
	struct address		*h;

	bzero(&ina, sizeof(ina));
	if (inet_pton(AF_INET, s, &ina) != 1)
		return (NULL);

	if ((h = calloc(1, sizeof(*h))) == NULL)
		fatal(NULL);
	sain = (struct sockaddr_in *)&h->ss;
	sain->sin_len = sizeof(struct sockaddr_in);
	sain->sin_family = AF_INET;
	sain->sin_addr.s_addr = ina.s_addr;

	return (h);
}

struct address *
host_v6(const char *s)
{
	struct in6_addr		 ina6;
	struct sockaddr_in6	*sin6;
	struct address		*h;

	bzero(&ina6, sizeof(ina6));
	if (inet_pton(AF_INET6, s, &ina6) != 1)
		return (NULL);

	if ((h = calloc(1, sizeof(*h))) == NULL)
		fatal(NULL);
	sin6 = (struct sockaddr_in6 *)&h->ss;
	sin6->sin6_len = sizeof(struct sockaddr_in6);
	sin6->sin6_family = AF_INET6;
	memcpy(&sin6->sin6_addr, &ina6, sizeof(ina6));

	return (h);
}

int
host_dns(const char *s, struct addresslist *al, int max,
	 in_port_t port, const char *ifname)
{
	struct addrinfo		 hints, *res0, *res;
	int			 error, cnt = 0;
	struct sockaddr_in	*sain;
	struct sockaddr_in6	*sin6;
	struct address		*h;

	bzero(&hints, sizeof(hints));
	hints.ai_family = PF_UNSPEC;
	hints.ai_socktype = SOCK_DGRAM; /* DUMMY */
	error = getaddrinfo(s, NULL, &hints, &res0);
	if (error == EAI_AGAIN || error == EAI_NODATA || error == EAI_NONAME)
		return (0);
	if (error) {
		log_warnx("host_dns: could not parse \"%s\": %s", s,
		    gai_strerror(error));
		return (-1);
	}

	for (res = res0; res && cnt < max; res = res->ai_next) {
		if (res->ai_family != AF_INET &&
		    res->ai_family != AF_INET6)
			continue;
		if ((h = calloc(1, sizeof(*h))) == NULL)
			fatal(NULL);

		h->port = port;
		if (ifname != NULL) {
			if (strlcpy(h->ifname, ifname, sizeof(h->ifname)) >=
			    sizeof(h->ifname))
				log_warnx("host_dns: interface name truncated");
			return (-1);
		}
		h->ss.ss_family = res->ai_family;
		if (res->ai_family == AF_INET) {
			sain = (struct sockaddr_in *)&h->ss;
			sain->sin_len = sizeof(struct sockaddr_in);
			sain->sin_addr.s_addr = ((struct sockaddr_in *)
			    res->ai_addr)->sin_addr.s_addr;
		} else {
			sin6 = (struct sockaddr_in6 *)&h->ss;
			sin6->sin6_len = sizeof(struct sockaddr_in6);
			memcpy(&sin6->sin6_addr, &((struct sockaddr_in6 *)
			    res->ai_addr)->sin6_addr, sizeof(struct in6_addr));
		}

		TAILQ_INSERT_HEAD(al, h, entry);
		cnt++;
	}
	if (cnt == max && res) {
		log_warnx("host_dns: %s resolves to more than %d hosts",
		    s, max);
	}
	freeaddrinfo(res0);
	return (cnt);
}

int
host(const char *s, struct addresslist *al, int max,
    in_port_t port, const char *ifname)
{
	struct address *h;

	h = host_v4(s);

	/* IPv6 address? */
	if (h == NULL)
		h = host_v6(s);

	if (h != NULL) {
		h->port = port;
		if (ifname != NULL) {
			if (strlcpy(h->ifname, ifname, sizeof(h->ifname)) >=
			    sizeof(h->ifname)) {
				log_warnx("host: interface name truncated");
				return (-1);
			}
		}

		TAILQ_INSERT_HEAD(al, h, entry);
		return (1);
	}

	return (host_dns(s, al, max, port, ifname));
}

struct table *
table_inherit(const char *name, in_port_t port)
{
	char		pname[TABLE_NAME_SIZE + 6];
	struct host	*h, *dsth;
	struct table	*dsttb, *tb;

	/* Get the table or table template */
	if ((dsttb = table_findbyname(conf, name)) == NULL) {
		yyerror("unknown table or template %s", name);
		return (NULL);
	}
	if (dsttb->conf.port != 0)
		return (dsttb);

	if (port == 0) {
		yyerror("invalid port");
		return (NULL);
	}

	/* Check if a matching table already exists */
	snprintf(pname, sizeof(pname), "%s:%u", name, ntohs(port));
	if ((tb = table_findbyname(conf, pname)) != NULL) {
		if (tb->conf.port == 0) {
			yyerror("invalid table");
			return (NULL);
		}
		return (tb);
	}

	/* Create a new table */
	if ((tb = calloc(1, sizeof (*tb))) == NULL)
		fatal("out of memory");
	bcopy(dsttb, tb, sizeof(*tb));
	if (strlcpy(tb->conf.name, pname, sizeof(tb->conf.name))
	    >= sizeof(tb->conf.name)) {
		yyerror("table name truncated");
		return (NULL);
	}
	if (dsttb->sendbuf != NULL &&
	    (tb->sendbuf = strdup(dsttb->sendbuf)) == NULL)
		fatal("out of memory");
	tb->conf.port = port;
	tb->conf.id = last_table_id++;
	if (last_table_id == INT_MAX) {
		yyerror("too many tables defined");
		return (NULL);
	}

	/* Copy the associated hosts */
	bzero(&tb->hosts, sizeof(tb->hosts));
	TAILQ_FOREACH(dsth, &dsttb->hosts, entry) {
		if ((h = (struct host *)
		    calloc(1, sizeof (*h))) == NULL)
			fatal("out of memory");
		bcopy(dsth, h, sizeof(*h));
		h->conf.id = last_host_id++;
		if (last_host_id == INT_MAX) {
			yyerror("too many hosts defined");
			return (NULL);
		}
		h->conf.tableid = tb->conf.id;
		h->tablename = tb->conf.name;
		TAILQ_INSERT_HEAD(&tb->hosts, h, entry);
	}

	conf->tablecount++;
	TAILQ_INSERT_HEAD(conf->tables, tb, entry);

	return (tb);
}
@


1.96
log
@allow to add labels to protocol actions, they will be printed in http
error pages and can be used to refer to additional information.

ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.95 2007/11/24 17:07:28 reyk Exp $	*/
@


1.95
log
@sort includes, adjust to style(9)
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.94 2007/11/23 09:39:42 reyk Exp $	*/
d96 1
d125 1
a125 1
%token  TIMEOUT CODE DIGEST PORT TAG INTERFACE STYLE RETURN
d693 11
d719 1
d1393 1
@


1.94
log
@re-implement the "mark" action and document it in the manpage:
it is possible to attach a mark to a session based on matching an
entity (header, url, cookie, ...) and add conditional action for this
mark. it works a bit like the tag/tagged keywords in pf, but i decided
to pick a different name to avoid confusion.

ok pyr@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.93 2007/11/22 10:09:53 reyk Exp $	*/
d30 2
a32 1
#include <net/if.h>
@


1.93
log
@add (new) "url" protocol action, this can be used to match/filter URL
suffix/prefix expressions like "example.com/index.html?args". a digest
mode allows to match against anonymized SHA1/MD5 digests of
suffix/prefix expressions.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.92 2007/11/21 20:31:03 reyk Exp $	*/
d124 1
a124 1
%token	VIRTUAL INTERVAL DISABLE STICKYADDR BACKLOG PATH SCRIPT
d133 1
a133 1
%type	<v.number>	port http_type loglevel sslcache optssl dstport
d900 1
a900 1
		| nodetype EXPECT STRING FROM STRING mark	{
d910 1
a910 1
		| nodetype EXPECT STRING mark {
d919 1
a919 1
		| nodetype EXPECT digest mark {
d934 1
a934 1
		| nodetype FILTER STRING FROM STRING mark	{
d944 1
a944 1
		| nodetype FILTER STRING mark {
d953 1
a953 1
		| nodetype FILTER digest mark {
d986 19
d1007 2
a1008 2
mark		: /* empty */
		| MARK				{ node.flags |= PNFLAG_MARK; }
d1011 7
a1017 2
marked		: /* empty */
		| MARKED			{ node.flags |= PNFLAG_MARK; }
d1419 2
a1420 1
		{ "virtual",		VIRTUAL }
@


1.92
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.91 2007/11/21 20:24:28 reyk Exp $	*/
d126 1
a126 1
%token	RELAY LISTEN ON FORWARD TO NAT LOOKUP PREFORK NO MARK MARKED
d731 2
d768 9
d919 15
d953 15
d1007 1
d1394 1
@


1.91
log
@extend action grammar with "filter value" and "expect value" as a
short form for "filter * from value" or "expect * from value".
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.90 2007/11/21 20:13:20 reyk Exp $	*/
d963 2
a964 2
				proto->flags |= F_LOOKUP_PATH;
				node.type = NODE_TYPE_PATH;
@


1.90
log
@move digest string handling into an extra function.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.89 2007/11/21 14:12:04 reyk Exp $	*/
d899 9
d915 9
@


1.89
log
@rename the "url" filter action to "query" to use the correct term.
please update your hoststated.conf configurations. also add more
examples to the manpage.

alright pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.88 2007/11/21 13:04:42 reyk Exp $	*/
d111 4
d137 1
d530 1
a530 3
		| CHECK http_type STRING hostname DIGEST STRING {
			size_t	 digest_len;

d544 1
a544 2

			digest_len = strlcpy(table->conf.digest, $6,
d546 2
a547 13
			switch (digest_len) {
			case 40:
				table->conf.digest_type = DIGEST_SHA1;
				break;
			case 32:
				table->conf.digest_type = DIGEST_MD5;
				break;
			default:
				yyerror("invalid http digest");
				free($6);
				YYERROR;
			}
			free($6);
d611 18
d746 1
d881 1
a881 1
		| nodetype REMOVE STRING marked	{
@


1.88
log
@allow the http digest type to be either SHA1 or MD5 determined by the
digest string length; it is compatible to any existing SHA1-only
configurations.

ok pyr@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.87 2007/11/20 17:08:44 reyk Exp $	*/
d124 1
a124 1
%token	LOG UPDATES ALL DEMOTE NODELAY SACK SOCKET BUFFER URL RETRY IP
d750 2
a751 2
				case NODE_TYPE_URL:
					pn->flags |= PNFLAG_LOOKUP_URL;
d930 1
a930 1
		| URL				{ node.type = NODE_TYPE_URL; }
d1300 1
a1323 1
		{ "url",		URL },
@


1.87
log
@allow to use the "include" directive in tables, services, relays, and
protocols.

ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.86 2007/11/20 15:54:55 reyk Exp $	*/
d526 2
d541 12
a552 4
			if (strlcpy(table->conf.digest, $6,
			    sizeof(table->conf.digest)) >=
			    sizeof(table->conf.digest)) {
				yyerror("http digest truncated");
@


1.86
log
@it may be desirable to send a HTTP error page with error code and a
meaningful message if a HTTP/HTTPS relay closes the connection for
some reason. for example, a "403 Forbidden" if the request was
rejected by a filter. this will be enabled with the "return error"
option and is disabled by default, the standard behaviour is to
silently drop the connection; the browser may display an empty page in
this case. the look+feel of the HTTP error page can be customized with
a CSS style sheet, but we do not intend to allow customization of the
error page contents (hoststated is not a webserver!).

ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.85 2007/11/20 15:44:21 pyr Exp $	*/
d432 1
d607 1
d753 1
d1123 1
@


1.85
log
@Allow overriding the global interval in a table.
Table specific intervals must be multiples of the global interval.
help and ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.84 2007/11/19 15:31:36 reyk Exp $	*/
d119 1
a119 1
%token  TIMEOUT CODE DIGEST PORT TAG INTERFACE
d206 16
d668 2
d1257 1
d1292 1
d1302 1
@


1.84
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.83 2007/11/19 15:20:18 reyk Exp $	*/
d580 9
@


1.83
log
@knf (replace some ';;' with a single ';')
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.82 2007/11/19 14:48:19 reyk Exp $	*/
d189 1
a189 1
		;		
d328 1
a328 1
				service->conf.backup_id = 
d644 1
a644 1
			struct protonode 	*pn, *proot, pk;
d681 1
a681 1
			if (node.type == NODE_TYPE_COOKIE)	
d735 1
a735 1
tcpflags	: SACK 			{ proto->tcpflags |= TCPFLAG_SACK; }
d974 1
a974 1
			struct addresslist 	 al;
d999 1
a999 1
			struct addresslist 	 al;
d1321 2
a1322 1
			yyerror("reached end of file while parsing quoted string");
@


1.82
log
@rework the internal handling of protocol actions a little bit:

- allow to use a key for multiple times by appending a queue of
additional matches to the tree node. for example, this allows to
specify multiple "expect" or "filter" actions to white-/black-list
a list of HTTP-headers, URLs, ..

- prevent specifing an HTTP header for multiple times when using the
expect action.

- minor code shuffling
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.80 2007/11/15 17:02:01 pyr Exp $	*/
d842 1
a842 1
			node.value = strdup($3);;
d852 1
a852 1
			node.value = strdup($3);;
@


1.81
log
@always enable "late connect" relay mode if an "expect" or "filter"
action has been specified for the protocol. late connect mode first
reads the complete request (HTTP header) before opening the inbound
connection instead of relaying it line-by-line.
@
text
@d644 1
a644 1
			struct protonode 	*pn, pk;
a650 6
			pn = RB_FIND(proto_tree, tree, &node);
			if (pn != NULL) {
				yyerror("protocol node %s defined twice",
				    node.key);
				YYERROR;
			}
d658 1
d669 11
a679 1
			RB_INSERT(proto_tree, tree, pn);
@


1.80
log
@Do not insert proto_default inside the dynamically alloced protocol queue.
Handle it as a special case in the one place where it actually matters
instead.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.79 2007/11/14 15:58:04 pyr Exp $	*/
d842 1
d852 1
@


1.79
log
@reset global variables everytime we enter parse_config.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.78 2007/11/14 10:59:01 pyr Exp $	*/
d586 7
a592 3
			TAILQ_FOREACH(p, conf->protos, entry)
				if (!strcmp(p->name, $2))
					break;
a1629 1
	TAILQ_INSERT_TAIL(conf->protos, &conf->proto_default, entry);
@


1.78
log
@make protos dynamic too
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.77 2007/11/12 23:59:41 mpf Exp $	*/
d1598 1
d1601 5
@


1.77
log
@Remove space/tab compression function from lgetc() and replace
it with a simple filter in the yylex() loop.
The compression in lgetc() didn't happen for quoted strings,
thus creating a regression when tabs were used in variables.
Some testing by todd@@ and pyr@@
OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.76 2007/11/04 18:47:17 claudio Exp $	*/
d586 1
a586 1
			TAILQ_FOREACH(p, &conf->protos, entry)
d626 1
a626 1
			TAILQ_INSERT_HEAD(&conf->protos, proto, entry);
d1058 1
a1058 1
			TAILQ_FOREACH(p, &conf->protos, entry)
d1592 1
d1603 1
a1603 1
	TAILQ_INIT(&conf->protos);
d1620 1
a1620 1
	TAILQ_INSERT_TAIL(&conf->protos, &conf->proto_default, entry);
d1697 1
a1697 1
	TAILQ_FOREACH(proto, &conf->protos, entry) {
@


1.76
log
@Not using all defined protocols is not a hard error. Just print a warning
but start anyway. OK reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.75 2007/10/22 16:53:30 pyr Exp $	*/
a1326 8
	if (c == '\t' || c == ' ') {
		/* Compress blanks to a single space. */
		do {
			c = getc(file->stream);
		} while (c == '\t' || c == ' ');
		ungetc(c, file->stream);
		c = ' ';
	}
d1383 1
a1383 1
	while ((c = lgetc(0)) == ' ')
@


1.75
log
@load certificates text at parse time. then load them in relay processes.
this separation will ease reload a bit more.

ok reyk@@ who spotted a stupid mistake again...
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.74 2007/10/22 12:18:15 reyk Exp $	*/
a1706 1
			errors++;
@


1.74
log
@add support for the include directive to the configuration file parser,
based on the existing hostapd/pfctl code.

ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.73 2007/10/22 08:52:19 reyk Exp $	*/
d946 5
@


1.73
log
@do not check the file secrecy of hoststated.conf, there is no need to
enforce the file ownership and permissions to root:wheel 0400 because
we have nothing to hide.

ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.72 2007/10/19 17:33:35 pyr Exp $	*/
d117 1
a117 1
%token	SERVICE TABLE BACKUP HOST REAL
d137 1
d148 14
d1223 1
@


1.72
log
@print system error when fopen fails.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.71 2007/10/19 14:40:51 pyr Exp $	*/
d1617 1
a1617 1
	if ((file = pushfile(filename, 1)) == NULL) {
@


1.71
log
@Do log initialisation correctly, like bgpd does.
This removes the double warn/log_warn madness i introduced yesterday.
This also keeps messages on stderr at startup and when running with -n.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.70 2007/10/19 14:15:14 pyr Exp $	*/
d1536 1
a1536 1
		log_warnx("%s", nfile->name);
@


1.70
log
@Move relays from static TAILQs to allocated ones.
This syncs it with other hoststated entities and will make reload easier.
This is step 1 out of 7 for reload.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.69 2007/10/19 09:08:05 pyr Exp $	*/
a1511 1
		warn("cannot stat %s", fname);
a1515 1
		warnx("%s: owner not root or current user", fname);
a1519 1
		warnx("%s: group/world readable/writeable", fname);
a1532 1
		warn("malloc");
a1536 1
		warnx("%s", nfile->name);
a1580 1
		warn("cannot allocate memory");
@


1.69
log
@keep log_warn messages to be informed when a failure occurs during a reload.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.68 2007/10/18 20:52:12 deraadt Exp $	*/
d887 1
a887 1
			TAILQ_FOREACH(r, &conf->relays, entry)
d934 1
a934 1
			TAILQ_INSERT_HEAD(&conf->relays, rlay, entry);
d1583 1
d1596 1
a1596 1
	TAILQ_INIT(&conf->relays);
d1649 1
a1649 1
	if (TAILQ_EMPTY(conf->services) && TAILQ_EMPTY(&conf->relays)) {
d1654 1
a1654 1
	if (TAILQ_EMPTY(&conf->relays))
@


1.68
log
@unbreak tree
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.66 2007/10/18 20:32:38 deraadt Exp $	*/
d1511 1
d1516 1
d1521 1
d1535 1
d1540 1
d1584 1
@


1.67
log
@extra arg to warn slipped through.
@
text
@d887 1
a887 1
			TAILQ_FOREACH(r, conf->relays, entry)
a931 2
			if (relay_load_certfile(rlay) == -1)
				YYERROR;
d934 1
a934 1
			TAILQ_INSERT_HEAD(conf->relays, rlay, entry);
d1578 1
a1578 2
	    (conf->services = calloc(1, sizeof(*conf->services))) == NULL ||
	    (conf->relays = calloc(1, sizeof(*conf->relays))) == NULL) {
a1587 1
	TAILQ_INIT(conf->relays);
d1589 1
d1642 1
a1642 1
	if (TAILQ_EMPTY(conf->services) && TAILQ_EMPTY(conf->relays)) {
d1647 1
a1647 1
	if (TAILQ_EMPTY(conf->relays))
@


1.66
log
@repair file security warnings; ok pyr
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.65 2007/10/16 20:01:23 mpf Exp $	*/
d887 1
a887 1
			TAILQ_FOREACH(r, &conf->relays, entry)
d932 2
d936 1
a936 1
			TAILQ_INSERT_HEAD(&conf->relays, rlay, entry);
d1534 1
a1534 1
		warn("malloc", nfile->name);
d1580 2
a1581 1
	    (conf->services = calloc(1, sizeof(*conf->services))) == NULL) {
d1591 1
a1592 1
	TAILQ_INIT(&conf->relays);
d1645 1
a1645 1
	if (TAILQ_EMPTY(conf->services) && TAILQ_EMPTY(&conf->relays)) {
d1650 1
a1650 1
	if (TAILQ_EMPTY(&conf->relays))
@


1.65
log
@Allow '=' to end a number in all lexers.
Requested and OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.64 2007/10/16 06:06:49 deraadt Exp $	*/
d1511 1
a1511 1
		log_warn("cannot stat %s", fname);
d1515 1
a1515 1
		log_warnx("%s: owner not root or current user", fname);
d1519 1
a1519 1
		log_warnx("%s: group/world readable/writeable", fname);
d1531 2
a1532 1
	    (nfile->name = strdup(name)) == NULL)
d1534 1
d1536 1
a1616 1
		warn("%s", filename);
@


1.64
log
@in the lex... even inside quotes, a \ followed by space or tab should
expand to space or tab, and a \ followed by newline should be ignored
(as a line continuation).  compatible with the needs of hoststated
(which has the most strict quoted string requirements), and ifstated
(where one commonly does line continuations in strings).
pointed out by mpf, discussed with pyr
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.63 2007/10/13 16:35:21 deraadt Exp $	*/
d1440 1
a1440 1
	(isspace(x) || x == ')' || x ==',' || x == '/' || x == '}')
@


1.63
log
@in all these programs using the same pfctl-derived parse.y, re-unify the
yylex implementation and the code which interacts with yylex.  this also
brings the future potential for include support to all of the parsers.
in the future please do not silly modifications to one of these files
without checking if you are de-unifying the code.
checked by developers in all these areas.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.62 2007/10/11 14:39:17 deraadt Exp $	*/
d1417 1
a1417 1
				if (next == quotec)
d1419 2
@


1.62
log
@next step in the yylex unification: handle quoted strings in a nicer fashion
as found in hoststated, and make all the code diff as clean as possible. a
few issues remain mostly surrounding include support, which will likely be
added to more of the grammers soon.
ok norby pyr, others
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.61 2007/10/09 22:32:52 deraadt Exp $	*/
d28 1
d36 1
d51 19
a69 25
struct hoststated		*conf = NULL;
static FILE			*fin = NULL;
static int			 lineno = 1;
static int			 errors = 0;
const char			*infile;
objid_t				 last_service_id = 0;
objid_t				 last_table_id = 0;
objid_t				 last_host_id = 0;
objid_t				 last_relay_id = 0;
objid_t				 last_proto_id = 0;

static struct service		*service = NULL;
static struct table		*table = NULL;
static struct relay		*rlay = NULL;
static struct protocol		*proto = NULL;
static struct protonode		 node;

int	 yyerror(const char *, ...);
int	 yyparse(void);
int	 kw_cmp(const void *, const void *);
int	 lookup(char *);
int	 lgetc(int);
int	 lungetc(int);
int	 findeol(void);
int	 yylex(void);
d73 1
a73 1
	TAILQ_ENTRY(sym)	 entries;
a78 1

d82 14
d144 1
a144 1
		| grammar error '\n'		{ errors++; }
d1163 1
a1163 1
	va_list	ap;
d1165 1
a1165 1
	errors = 1;
d1167 1
a1167 1
	fprintf(stderr, "%s:%d: ", infile, yylval.lineno);
a1176 1

d1269 1
a1269 1
lgetc(int inquot)
d1271 1
a1271 2
	int	c, next;
	FILE *f = fin;
d1287 7
a1293 2
	if (inquot) {
		c = getc(f);
d1297 2
a1298 2
	while ((c = getc(f)) == '\\') {
		next = getc(f);
d1303 2
a1304 2
		yylval.lineno = lineno;
		lineno++;
d1309 1
a1309 1
			c = getc(f);
d1311 1
a1311 1
		ungetc(c, f);
d1315 5
d1351 1
a1351 1
			lineno++;
d1365 1
a1365 1
	int	 endc, next, c;
d1373 1
a1373 1
	yylval.lineno = lineno;
d1407 1
a1407 1
		endc = c;
d1409 1
a1409 1
			if ((c = lgetc(1)) == EOF)
d1412 1
a1412 1
				lineno++;
d1415 1
a1415 1
				if ((next = lgetc(1)) == EOF)
d1417 1
a1417 1
				if (next == endc)
d1421 1
a1421 1
			} else if (c == endc) {
d1495 2
a1496 2
		yylval.lineno = lineno;
		lineno++;
d1503 61
d1611 1
a1611 1
	if ((fin = fopen(filename, "r")) == NULL) {
a1615 1
	infile = filename;
d1617 1
d1619 3
a1622 1
	fclose(fin);
d1626 1
a1626 1
		next = TAILQ_NEXT(sym, entries);
d1633 1
a1633 1
			TAILQ_REMOVE(&symhead, sym, entries);
d1699 1
a1699 1
	    sym = TAILQ_NEXT(sym, entries))
d1708 1
a1708 1
			TAILQ_REMOVE(&symhead, sym, entries);
d1728 1
a1728 1
	TAILQ_INSERT_TAIL(&symhead, sym, entries);
d1759 1
a1759 1
	TAILQ_FOREACH(sym, &symhead, entries)
@


1.61
log
@use macro argument
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.60 2007/10/05 15:50:56 reyk Exp $	*/
d70 1
a70 1
int	 lgetc(FILE *, int);
d98 1
a98 1
		int32_t		 number;
d1261 1
a1261 1
lgetc(FILE *f, int inquot)
d1264 1
d1332 1
a1332 1
		c = lgetc(fin, 0);
d1353 1
a1353 1
	while ((c = lgetc(fin, 0)) == ' ')
d1358 1
a1358 1
		while ((c = lgetc(fin, 0)) != '\n' && c != EOF)
d1362 1
a1362 1
			if ((c = lgetc(fin, 0)) == EOF)
d1392 1
a1392 1
			if ((c = lgetc(fin, 1)) == EOF)
d1394 6
a1399 2
			if (c == '\\') {
				next = lgetc(fin, 1);
a1407 4
			if (c == '\n') {
				lineno++;
				continue;
			}
d1416 1
a1416 1
			errx(1, "yylex: strdup");
d1430 1
a1430 1
		} while ((c = lgetc(fin, 0)) != EOF && isdigit(c));
d1438 2
a1439 2
			yylval.v.number = (int)strtonum(buf, -INT_MAX,
			    INT_MAX, &errstr);
d1469 1
a1469 2
		} while ((c = lgetc(fin, 0)) != EOF &&
		    (allowed_in_string(c)));
@


1.60
log
@cast to an int
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.59 2007/10/02 21:04:13 pyr Exp $	*/
d1420 1
a1420 1
	(isspace(x) || c == ')' || c ==',' || c == '/' || c == '}')
@


1.59
log
@stop messing with lgetc to please hoststated's check/expect.
instead move some of the logic in yylex and do hoststated specific
translations into hoststated.c
ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.58 2007/10/02 07:21:04 pyr Exp $	*/
d195 1
a195 1
			if ($2 <= 0 || $2 >= USHRT_MAX) {
@


1.58
log
@clean up merged code.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.57 2007/10/01 19:12:33 pyr Exp $	*/
d70 1
a70 1
int	 lgetc(FILE *, int *);
d520 1
d1261 1
a1261 1
lgetc(FILE *f, int *keep)
a1264 1
	*keep = 0;
d1279 5
d1286 1
a1286 9
		if (next == 'n') {
			*keep = 1;
			c = '\n';
			break;
		} else if (next == 'r') {
			*keep = 1;
			c = '\r';
			break;
		} else if (next != '\n') {
a1324 1
	int	k;
d1331 2
a1332 2
		c = lgetc(fin, &k);
		if (c == '\n' && k == 0) {
d1347 1
a1347 1
	int	 endc, c;
a1348 1
	int	 keep;
d1352 1
a1352 1
	while ((c = lgetc(fin, &keep)) == ' ')
d1357 2
a1358 4
		do {
			while ((c = lgetc(fin, &keep)) != '\n' && c != EOF)
				; /* nothing */
		} while (keep == 1);
d1361 1
a1361 1
			if ((c = lgetc(fin, &keep)) == EOF)
d1391 1
a1391 1
			if ((c = lgetc(fin, &keep)) == EOF)
d1393 7
a1399 1
			if (c == endc) {
d1403 1
a1403 1
			if (c == '\n' && keep == 0) {
d1429 1
a1429 1
		} while ((c = lgetc(fin, &keep)) != EOF && isdigit(c));
d1468 1
a1468 1
		} while ((c = lgetc(fin, &keep)) != EOF &&
@


1.57
log
@Add NUMBER to hoststated's lexer, very similar to what has gone in
in the other daemons recently. Prompted and based on work by deraadt@@
proofread and ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.56 2007/10/01 12:34:02 pyr Exp $	*/
d851 3
a853 1
nodetype	: HEADER			{ node.type = NODE_TYPE_HEADER; }
d855 3
a857 1
		| COOKIE			{ node.type = NODE_TYPE_COOKIE; }
d1438 2
a1439 1
			yylval.v.number = (int)strtonum(buf, -INT_MAX, INT_MAX, &errstr);
d1441 2
a1442 1
				yyerror("\"%s\" invalid number: %s", buf, errstr);
@


1.56
log
@keep lines < 80.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.55 2007/09/28 13:29:56 pyr Exp $	*/
d98 1
a98 1
		u_int32_t	 number;
d118 1
d120 1
a120 1
%type	<v.number>	number port http_type loglevel sslcache optssl dstport
a137 14
number		: STRING	{
			const char	*estr;

			$$ = strtonum($1, 0, UINT_MAX, &estr);
			if (estr) {
				yyerror("cannot parse number %s : %s",
				    $1, estr);
				free($1);
				YYERROR;
			}
			free($1);
		}
		;

a182 1
			const char	*estr;
d185 7
a191 16
			$$ = strtonum($2, 1, USHRT_MAX, &estr);
                        if (estr) {
				if (errno == ERANGE) {
					yyerror("port %s is out of range", $2);
					free($2);
					YYERROR;
				}
				servent = getservbyname($2, "tcp");
				if (servent == NULL) {
					yyerror("port %s is invalid", $2);
					free($2);
					YYERROR;
				}
				$$ = servent->s_port;
			} else
				$$ = htons($$);
d194 7
d224 6
a229 1
main		: INTERVAL number	{ conf->interval.tv_sec = $2; }
d234 1
a234 1
		| PREFORK number	{
d463 1
a463 1
		| CHECK http_type STRING hostname CODE number {
d469 6
a474 1
			table->conf.retcode = $6;
d705 2
a706 2
		| BACKLOG number	{
			if ($2 > RELAY_MAX_SESSIONS) {
d712 1
a712 1
		| SOCKET BUFFER number	{
d714 4
a717 1
			proto->tcpbufsiz = $3;
d719 6
a724 1
		| IP STRING number	{
d860 7
a866 1
sslcache	: number			{ $$ = $1; }
d1041 6
a1046 1
		| TIMEOUT number	{ rlay->conf.timeout.tv_sec = $2; }
d1105 6
a1110 1
		| RETRY number		{ $$ = $2; }
d1113 1
a1113 1
timeout		: number
d1115 4
d1414 34
@


1.55
log
@Correct my mail address.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.54 2007/09/10 11:59:22 reyk Exp $	*/
d264 1
a264 1
				yyerror("yyparse: error initializing group '%s'",
@


1.54
log
@add support for relaying DNS traffic (with a little bit of packet
header randomization). this adds an infrastructure to support
UDP-based protocols.

ok gilles@@, tested by some
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.53 2007/09/07 07:54:58 reyk Exp $	*/
d4 1
a4 1
 * Copyright (c) 2006 Pierre-Yves Ritschard <pyr@@spootnik.org>
@


1.53
log
@store the table's port as the relay's dstport
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.52 2007/09/05 08:48:42 reyk Exp $	*/
d184 2
@


1.52
log
@store relay sessions in SPLAY trees instead of TAILQ lists. this will
be used for faster lookups of sessions based on different criteria.

ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.51 2007/09/04 14:15:05 pyr Exp $	*/
d1006 1
@


1.51
log
@Add the ability to specify a host header when using http(s) check methods.
Prodded by me, done by Gille Chehade <veins@@evilkittens.org>

ok reyk, jmc for the manpage bits.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.50 2007/07/05 09:42:26 thib Exp $	*/
d909 1
a909 1
			TAILQ_INIT(&rlay->sessions);
@


1.50
log
@use a more traditional while() instead of for() for getopt().
sync usage() to the man page.
format string fixes.
complain about failed calloc()'s instead of exiting silently.

ok pry@@,reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.49 2007/05/31 18:58:09 pyr Exp $	*/
d118 1
a118 1
%type	<v.string>	interface
d169 11
d472 1
a472 1
		| CHECK http_type STRING CODE number {
d478 1
a478 1
			table->conf.retcode = $5;
d480 1
a480 1
			    "HEAD %s HTTP/1.0\r\n\r\n", $3) == -1)
d483 1
d488 1
a488 1
		| CHECK http_type STRING DIGEST STRING {
d495 1
a495 1
			    "GET %s HTTP/1.0\r\n\r\n", $3) == -1)
d498 1
d502 1
a502 1
			if (strlcpy(table->conf.digest, $5,
d506 1
a506 1
				free($5);
d509 1
a509 1
			free($5);
@


1.49
log
@do not forget to store table and backup table ids in the service
configuration struct.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.48 2007/05/31 18:20:03 pyr Exp $	*/
d161 1
a161 1
				yyerror("invalid check type: $1", $1);
d174 1
a174 1
				yyerror("invalid protocol type: $1", $1);
d399 1
a399 1
				yyerror("table %s defined twice");
d1418 2
a1419 1
	    (conf->services = calloc(1, sizeof(*conf->services))) == NULL)
d1421 1
@


1.48
log
@make sure object ids are reset before parsing the configuration file
again.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.47 2007/05/31 03:24:05 pyr Exp $	*/
d337 1
d361 1
@


1.47
log
@allocate table lists and service lists instead of using static structs.
split the code to start the event loop in two functions.
introduce merge_config which will be used later on.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.46 2007/05/29 18:59:54 pyr Exp $	*/
d1418 3
@


1.46
log
@do not start relay processes when no L7 load balancing is needed.
ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.45 2007/05/29 17:12:04 reyk Exp $	*/
d265 1
a265 1
			TAILQ_FOREACH(srv, &conf->services, entry)
d315 1
a315 1
			TAILQ_INSERT_HEAD(&conf->services, service, entry);
d393 1
a393 1
			TAILQ_FOREACH(tb, &conf->tables, entry)
d431 1
a431 1
			TAILQ_INSERT_HEAD(&conf->tables, table, entry);
d1414 3
a1416 1
	if ((conf = calloc(1, sizeof(*conf))) == NULL)
d1419 2
a1420 2
	TAILQ_INIT(&conf->services);
	TAILQ_INIT(&conf->tables);
d1474 1
a1474 1
	if (TAILQ_EMPTY(&conf->services) && TAILQ_EMPTY(&conf->relays)) {
d1488 1
a1488 1
	for (table = TAILQ_FIRST(&conf->tables); table != NULL;
d1492 1
a1492 1
			TAILQ_REMOVE(&conf->tables, table, entry);
d1801 1
a1801 1
	TAILQ_INSERT_HEAD(&conf->tables, tb, entry);
@


1.45
log
@add a new check method which allows to run external scripts/programs
for custom evaluations.

pyr agrees to put it in now but to do some improvements of the timeout
handling later.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.44 2007/05/29 00:48:04 pyr Exp $	*/
d1476 3
@


1.44
log
@move the ssl cipher suite string to a (small) static charbuf,
this will make it easier to send the struct over the socket.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.43 2007/05/29 00:21:10 pyr Exp $	*/
d111 1
a111 1
%token	VIRTUAL INTERVAL DISABLE STICKYADDR BACKLOG PATH
d511 11
d1181 1
@


1.43
log
@move struct relay to the runtime + config scheme.
this time around, include hoststatectl changes too.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.42 2007/05/28 17:37:16 pyr Exp $	*/
a560 1
			p->sslciphers = NULL;
d562 2
d716 7
a722 3
			proto->sslciphers = strdup($2);
			if (proto->sslciphers == NULL)
				fatal("out of memory");
@


1.42
log
@store the configuration file's path, this will be useful when reloading.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.41 2007/05/27 20:53:10 pyr Exp $	*/
d833 1
a833 1
				if (!strcmp(r->name, $2))
d843 2
a844 2
			if (strlcpy(r->name, $2, sizeof(r->name)) >=
			    sizeof(r->name)) {
d849 2
a850 2
			r->id = last_relay_id++;
			r->timeout.tv_sec = RELAY_TIMEOUT;
d852 3
a854 2
			r->dsttable = NULL;
			r->dstretry = 0;
d861 1
a861 1
			if (rlay->ss.ss_family == AF_UNSPEC) {
d863 1
a863 1
				    rlay->name);
d866 3
a868 3
			if ((rlay->flags & F_NATLOOK) == 0 &&
			    rlay->dstss.ss_family == AF_UNSPEC &&
			    rlay->dsttable == NULL) {
d870 1
a870 1
				    "or table", rlay->name);
d873 1
a873 1
			if (rlay->proto == NULL)
d875 2
d891 1
a891 1
			if (rlay->ss.ss_family != AF_UNSPEC) {
d893 1
a893 1
				    rlay->name);
d905 2
a906 2
			bcopy(&h->ss, &rlay->ss, sizeof(rlay->ss));
			rlay->port = h->port;
d908 1
a908 1
				rlay->flags |= F_SSL;
d916 1
a916 1
			if (rlay->dstss.ss_family != AF_UNSPEC) {
d918 1
a918 1
				    "specified", rlay->name);
d931 4
a934 3
			bcopy(&h->ss, &rlay->dstss, sizeof(rlay->dstss));
			rlay->dstport = h->port;
			rlay->dstretry = $5;
d940 1
a940 1
			if (rlay->dstss.ss_family != AF_UNSPEC) {
d942 1
a942 1
				    "specified", rlay->name);
d949 1
a949 1
				    rlay->name, $2);
d955 4
a958 3
			bcopy(&h->ss, &rlay->dstss, sizeof(rlay->dstss));
			rlay->dstport = h->port;
			rlay->dstretry = $3;
d963 3
a965 3
			rlay->dstport = $3;
			if (rlay->dstport == 0)
				rlay->dstport = rlay->port;
d967 2
a968 1
			if ((tb = table_inherit($2, rlay->dstport)) == NULL) {
d973 1
d975 2
a976 2
			rlay->dstmode = $4;
			rlay->dstcheck = $5;
d991 1
d996 2
a997 2
			rlay->flags |= F_NATLOOK;
			rlay->dstretry = $3;
d999 2
a1000 2
		| TIMEOUT number		{ rlay->timeout.tv_sec = $2; }
		| DISABLE			{ rlay->flags |= F_DISABLE; }
@


1.41
log
@Second step towards hoststated reload:
First split out hosts, tables and services into to structs, one that
contains the runtime fields and one (inside the runtime) that contains
mostly static fields that will be sent over the socket during reload.

Also move the demoted field of tables inside the flags field as its
just a boolean.
ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.40 2007/05/27 19:21:15 reyk Exp $	*/
d1420 1
@


1.40
log
@allow to specify table templates in the configuration file and to
inherit them from multiple services or relays. this is useful if you
want to use a table with the same list of hosts but different ports as
specified in the relay or service section.

this makes mcbride more happy
ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.39 2007/05/26 19:58:49 pyr Exp $	*/
d216 1
d222 1
d266 1
a266 1
				if (!strcmp(srv->name, $2))
d276 3
a278 2
			if (strlcpy(srv->name, $2, sizeof(srv->name)) >=
			    sizeof(srv->name)) {
d283 1
a283 1
			srv->id = last_service_id++;
d292 1
a292 1
				    service->name);
d297 1
a297 1
				    service->name);
d301 3
a303 1
			if (service->backup == NULL)
d305 2
a306 2
			else if (service->backup->port !=
			    service->table->port) {
d309 1
a309 1
				    service->name);
d313 2
a314 2
			if (!(service->flags & F_DISABLE))
				service->flags |= F_ADD;
d329 1
a329 1
				port = service->port;
d337 2
a338 2
			service->table->serviceid = service->id;
			service->table->flags |= F_USED;
d352 1
a352 1
				port = service->port;
d360 2
a361 2
			service->backup->serviceid = service->id;
			service->backup->flags |= (F_USED|F_BACKUP);
d373 2
a374 2
			if (service->port == 0)
				service->port = $4;
d376 2
a377 2
		| DISABLE			{ service->flags |= F_DISABLE; }
		| STICKYADDR			{ service->flags |= F_STICKY; }
d379 3
a381 2
			if (strlcpy(service->tag, $2, sizeof(service->tag)) >=
			    sizeof(service->tag)) {
d394 1
a394 1
				if (!strcmp(tb->name, $2))
d405 2
a406 2
			if (strlcpy(tb->name, $2, sizeof(tb->name)) >=
			    sizeof(tb->name)) {
d410 2
a411 2
			tb->id = last_table_id++;
			bcopy(&conf->timeout, &tb->timeout,
d421 2
a422 1
				yyerror("table %s has no hosts", table->name);
d425 3
a427 2
			if (table->check == CHECK_NOCHECK) {
				yyerror("table %s has no check", table->name);
d440 2
a441 2
			$1->tableid = table->id;
			$1->tablename = table->name;
d445 2
a446 1
			bcopy(&$2, &table->timeout, sizeof(struct timeval));
d449 1
a449 1
			table->check = CHECK_ICMP;
d452 1
a452 1
			table->check = CHECK_TCP;
d455 1
a455 1
			table->check = CHECK_TCP;
d457 1
a457 1
			table->flags |= F_SSL;
d462 1
a462 1
				table->flags |= F_SSL;
d464 2
a465 2
			table->check = CHECK_HTTP_CODE;
			table->retcode = $5;
d472 1
d477 1
a477 1
				table->flags |= F_SSL;
d479 1
a479 1
			table->check = CHECK_HTTP_DIGEST;
d486 4
a489 2
			if (strlcpy(table->digest, $5,
			    sizeof(table->digest)) >= sizeof(table->digest)) {
d497 1
a497 1
			table->check = CHECK_SEND_EXPECT;
d500 1
a500 1
				table->flags |= F_SSL;
d502 3
a504 2
			if (strlcpy(table->exbuf, $5, sizeof(table->exbuf))
			    >= sizeof(table->exbuf)) {
d512 1
a512 1
			table->port = $2;
d515 4
a518 4
			table->flags |= F_DEMOTE;
			if (strlcpy(table->demote_group, $2,
			    sizeof(table->demote_group))
			    >= sizeof(table->demote_group)) {
d524 2
a525 1
			if (carp_demote_init(table->demote_group, 1) == -1) {
d527 1
a527 1
				    "'%s'", table->demote_group);
d531 3
a533 1
		| DISABLE			{ table->flags |= F_DISABLE; }
d970 1
a970 1
			rlay->dsttable->flags |= F_USED;
d1028 1
a1028 1
			memcpy(&$$->ss, &a->ss, sizeof($$->ss));
d1031 2
a1032 2
			if (strlcpy($$->name, $2, sizeof($$->name)) >=
			    sizeof($$->name)) {
d1039 2
a1040 2
			$$->id = last_host_id++;
			$$->retry = $3;
d1398 4
a1401 4
	conf->empty_table.id = EMPTY_TABLE;
	conf->empty_table.flags |= F_DISABLE;
	(void)strlcpy(conf->empty_table.name, "empty",
	    sizeof(conf->empty_table.name));
d1460 1
a1460 1
		if (table->port == 0) {
d1471 2
a1472 2
		if (!(table->flags & F_USED)) {
			log_warnx("unused table: %s", table->name);
d1475 1
a1475 1
		if (timercmp(&table->timeout, &conf->interval, >=)) {
d1477 1
a1477 1
			    table->name);
d1715 1
a1715 1
	if (dsttb->port != 0)
d1726 1
a1726 1
		if (tb->port == 0) {
d1737 2
a1738 1
	if (strlcpy(tb->name, pname, sizeof(tb->name)) >= sizeof(tb->name)) {
d1745 2
a1746 2
	tb->port = port;
	tb->id = last_table_id++;
d1759 1
a1759 1
		h->id = last_host_id++;
d1764 2
a1765 2
		h->tableid = tb->id;
		h->tablename = tb->name;
@


1.39
log
@first steps for implementing reload:
	* make parse_config allocate the hoststated function by itself
	* make as many sockets as necessary to talk to the relay children
	* add send_all for talking to all children
with advise and ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.38 2007/04/12 14:45:45 reyk Exp $	*/
d94 2
d119 1
a119 1
%type	<v.number>	number port http_type loglevel sslcache optssl
d318 8
a325 8
serviceoptsl	: TABLE STRING	{
			struct table *tb;

			TAILQ_FOREACH(tb, &conf->tables, entry)
				if (!strcmp(tb->name, $2))
					break;
			if (tb == NULL) {
				yyerror("no such table: %s", $2);
a327 5
			} else {
				service->table = tb;
				service->table->serviceid = service->id;
				service->table->flags |= F_USED;
				free($2);
d329 9
a337 3
		}
		| BACKUP TABLE STRING	{
			struct table *tb;
d345 4
a348 6
			TAILQ_FOREACH(tb, &conf->tables, entry)
				if (!strcmp(tb->name, $3))
					break;

			if (tb == NULL) {
				yyerror("no such table: %s", $3);
a350 5
			} else {
				service->backup = tb;
				service->backup->serviceid = service->id;
				service->backup->flags |= (F_USED|F_BACKUP);
				free($3);
d352 5
d368 2
a413 4
			if (table->port == 0) {
				yyerror("table %s has no port", table->name);
				YYERROR;
			}
d939 6
a944 2
		| TABLE STRING dstmode docheck {
			struct table	*dsttable;
d946 1
a946 3
			if ((dsttable = table_findbyname(conf, $2)) == NULL) {
				yyerror("relay %d for unknown table %s",
				    rlay->name, $2);
d951 3
a953 3
			rlay->dsttable = dsttable;
			rlay->dstmode = $3;
			rlay->dstcheck = $4;
d993 4
d1370 2
d1441 14
a1454 1
	TAILQ_FOREACH(table, &conf->tables, entry) {
d1685 71
@


1.38
log
@add a new relay 'path' action to filter the URL path and arguments.

ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.37 2007/03/21 00:08:08 reyk Exp $	*/
d1361 2
a1362 2
int
parse_config(struct hoststated *x_conf, const char *filename, int opts)
d1366 2
a1367 1
	conf = x_conf;
d1400 2
a1401 1
		return (0);
d1455 2
a1456 2
		bzero(&conf, sizeof (*conf));
		return (-1);
d1459 1
a1459 1
	return (0);
@


1.37
log
@in addition to the host retry option in tables, add support for the
optional connection "retry" to the forward to, service, and nat lookup
options. for example, "nat lookup retry 3" is useful when running
hoststated as a transparent proxy when connecting to unreliable
frontend/backend servers.

ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.36 2007/03/13 12:04:52 reyk Exp $	*/
d109 1
a109 1
%token	VIRTUAL INTERVAL DISABLE STICKYADDR BACKLOG
d804 4
d1124 1
@


1.36
log
@allow to specify the IP_TTL and IP_MINTTL options for the relays to
support the Generalized TTL Security Mechanism (GTSM) according to RFC
3682. this is especially useful with inbound connections and a fixed
distance to the backend servers.

ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.35 2007/03/07 17:40:32 reyk Exp $	*/
d834 1
d890 1
a890 1
		| FORWARD TO STRING port {
d911 1
d913 1
a913 1
		| SERVICE STRING {
d934 1
d966 4
a969 1
		| NAT LOOKUP			{ rlay->flags |= F_NATLOOK; }
@


1.35
log
@- fix the hoststatectl host disable/enable commands to work with relay
layer 7 loadbalancing.
- allow to run relays with tables without depending on services
- show hosts and tables assigned to relays in hoststatectl show commands

ok pyr@@ deraadt@@ with some input from mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.34 2007/03/06 19:26:46 reyk Exp $	*/
d113 1
a113 1
%token	LOG UPDATES ALL DEMOTE NODELAY SACK SOCKET BUFFER URL RETRY
d678 14
d1102 1
@


1.34
log
@add support for handling simple HTTP cookies (no per-path/domain
cookies yet), for example: cookie hash "JSESSIONID"

tested by some people
ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.33 2007/02/27 13:38:58 reyk Exp $	*/
d932 1
@


1.33
log
@in addition to actions on request headers, allow to define relay
actions on response headers (the reply sent by backend HTTP servers).
the default and slightly faster relay streaming mode will be used if
no actions are defined.

for example:
response change "Server" to "OpenBSD-hoststated/4.1"

ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.32 2007/02/26 20:48:48 pyr Exp $	*/
d110 1
a110 1
%token	SEND EXPECT NOTHING SSL LOADBALANCE ROUNDROBIN CIPHERS
d609 4
a613 1
				pk.key = "GET";
d620 1
a620 1
					pn->key = strdup("GET");
d789 1
d1072 1
@


1.32
log
@kill the ``use ssl'' directive for consistency across parser directives.
another heads up for testers: you need to change configuration files.
ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.31 2007/02/26 19:58:04 pyr Exp $	*/
d107 1
a107 1
%token  CHECK TCP ICMP EXTERNAL
d118 1
a118 1
%type	<v.number>	proto_type dstmode docheck retry log flag
d552 2
a553 1
			RB_INIT(&p->tree);
d576 9
a584 4
		| protonode log			{
			struct protonode *pn, pk;

			pn = RB_FIND(proto_tree, &proto->tree, &node);
d597 5
a601 3
			pn->id = proto->nodecount++;
			if ($2) {
				proto->lateconnect++;
a602 1
			}
d607 1
a607 1
			RB_INSERT(proto_tree, &proto->tree, pn);
d612 1
a612 1
				pn = RB_FIND(proto_tree, &proto->tree, &pk);
d623 5
a627 1
					pn->id = proto->nodecount++;
d633 1
a633 1
					RB_INSERT(proto_tree, &proto->tree, pn);
d651 5
a772 1
			proto->lateconnect++;
d1099 2
d1353 2
a1354 1
	RB_INIT(&conf->proto_default.tree);
@


1.31
log
@remove HTTP and HTTPS tokens, makes for cleaner parser.
reorder other rules as well.
ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.30 2007/02/26 19:25:05 pyr Exp $	*/
d110 1
a110 1
%token	SEND EXPECT NOTHING USE SSL LOADBALANCE ROUNDROBIN CIPHERS
d117 1
a117 1
%type	<v.number>	number port http_type loglevel sslcache
d149 4
d485 1
a485 1
		| CHECK SEND sendbuf EXPECT STRING {
d487 4
a518 4
		| USE SSL			{
			table->flags |= F_SSL;
			conf->flags |= F_SSL;
		}
d831 1
a831 1
relayoptsl	: LISTEN ON STRING port sslserv {
d851 4
a943 7
sslserv		: /* empty */
		| SSL	{
			rlay->flags |= F_SSL;
			conf->flags |= F_SSL;
		}
		;

a1099 1
		{ "use",		USE },
@


1.30
log
@solve some conflicts in the configuration parser.
configuration will need to be updated as some directives have changed.
manpage and examples bits coming up.
ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.29 2007/02/26 13:31:21 pyr Exp $	*/
d107 1
a107 1
%token  CHECK HTTP HTTPS TCP ICMP EXTERNAL
d118 1
a118 1
%type	<v.number>	prototype dstmode docheck retry log flag
d149 25
a173 2
http_type	: HTTP		{ $$ = 0; }
		| HTTPS		{ $$ = 1; }
d176 1
a176 1
port		: PORT STRING	{
d179 1
a179 1
			
d181 1
a181 1
			if (estr) {
a197 19
		| PORT http_type {
			struct servent	*servent;
			int		 port;
			const char	*sport;

			if ($2) {
				port = 443;
				sport = "https";
			} else {
				port = 80;
				sport = "http";
			}

			servent = getservbyname(sport, "tcp");
			if (servent == NULL)
				$$ = htons(port);
			else
				$$ = servent->s_port;
		}
d570 1
a570 1
		| PROTO prototype		{ proto->type = $2; }
a772 4
prototype	: TCP				{ $$ = RELAY_PROTO_TCP; }
		| HTTP				{ $$ = RELAY_PROTO_HTTP; }
		;

a1062 2
		{ "http",		HTTP },
		{ "https",		HTTPS },
@


1.29
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.28 2007/02/26 13:03:30 pyr Exp $	*/
d112 1
a112 1
%token	PROTO SESSION CACHE APPEND CHANGE REMOVE FROM FILTER HASH
d118 1
a118 1
%type	<v.number>	prototype dstmode docheck retry no log
d664 17
a680 13
		| no STRING			{
			u_int flags = 0;
			if (strcmp("sslv2", $2) == 0)
				flags = SSLFLAG_SSLV2;
			else if (strcmp("sslv3", $2) == 0)
				flags = SSLFLAG_SSLV3;
			else if (strcmp("tlsv1", $2) == 0)
				flags = SSLFLAG_TLSV1;
			if ($1)
				proto->sslflags &= ~flags;
			else
				proto->sslflags |= flags;
			free($2);
d684 1
a684 1
protonode	: APPEND STRING TO STRING marked	{
d686 2
a687 2
			node.key = strdup($4);
			node.value = strdup($2);
d692 2
a693 2
			free($4);
			free($2);
d695 1
a695 1
		| CHANGE STRING TO STRING marked	{
d697 2
a698 2
			node.key = strdup($2);
			node.value = strdup($4);
d703 2
a704 2
			free($4);
			free($2);
d706 1
a706 1
		| REMOVE STRING	marked	{
d708 1
a708 1
			node.key = strdup($2);
d712 1
a712 1
			free($2);
d714 1
a714 1
		| getvars EXPECT STRING FROM STRING mark	{
d723 1
a723 1
		| getvars FILTER STRING FROM STRING mark	{
d732 1
a732 1
		| getvars HASH STRING marked			{
d741 1
a741 1
		| getvars LOG STRING marked			{
d753 1
a753 1
mark		: /* nothing */
d757 1
a757 1
marked		: /* nothing */
d761 1
a761 1
getvars		: /* nothing */
d765 1
a765 2
sslcache	: /* empty */			{ $$ = RELAY_CACHESIZE; }
		| number			{ $$ = $1; }
a993 4
no		: /* empty */		{ $$ = 0; }
		| NO			{ $$ = 1; }
		;

d1061 1
@


1.28
log
@Change the ``virtual ip'' directive to ``virtual host''.
You will need to update your configuration files accordingly.
"just do it", reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.27 2007/02/24 00:22:32 reyk Exp $	*/
d501 2
a502 2
				yyerror("yyparse: error initializing group '%s'",
				    table->demote_group);
d850 2
a851 2
				yyerror("relay %s target or service already specified",
				    rlay->name);
d872 2
a873 2
				yyerror("relay %s target or service already specified",
				    rlay->name);
@


1.27
log
@- allow to specify the SSL cipher suite and the SSL protocols
  (as required by the PCI DSS)
- increase the default listen backlog to 10, allow to modify the
  backlog as a per-protocol tcp option to improve the performance
  on busy systems (to get less connection failures on heavy load)
- close the connection if SSL_accept returned an error
- instead of logging _new_ relay sessions to syslog, log the
  sessions in relay_close() after they have been _finished_.
  this will allow to collect some additional information
- add a new log keyword to log specified header/url entities (useful
  to track "bad guys" using many session ids or multiple user agents)
- some minor fixes, manpage bits, and bump the copyright (by some
  reason, i didn't realize that we already have 2007...).
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.26 2007/02/22 03:32:39 reyk Exp $	*/
d109 1
a109 1
%token	VIRTUAL IP INTERVAL DISABLE STICKYADDR BACKLOG
d349 1
a349 1
		| VIRTUAL IP STRING port interface {
a1067 1
		{ "ip",			IP },
@


1.26
log
@Add layer 7 functionality to hoststated used for layer 7
loadbalancing, SSL acceleration, general-purpose TCP relaying, and
transparent proxying.

see hoststated.conf(5) and my upcoming article on undeadly.org for
details.

ok to commit deraadt@@ pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.25 2007/02/09 17:55:49 reyk Exp $	*/
d109 2
a110 2
%token	VIRTUAL IP INTERVAL DISABLE STICKYADDR
%token	SEND EXPECT NOTHING USE SSL LOADBALANCE ROUNDROBIN
d118 1
a118 1
%type	<v.number>	prototype dstmode docheck retry
d536 4
d548 6
d562 2
a563 2
protoptsl	: SSL SESSION CACHE sslcache	{ proto->cache = $4; }
		| PROTO prototype		{ proto->type = $2; }
d566 2
a567 1
		| protonode			{
d582 1
a582 1
			pn->header = node.getvars ? 0 : 1;
d584 4
d594 1
a594 1
			if (node.getvars) {
d596 1
d598 1
a598 3
				if (pn != NULL) {
					pn->getvars++;
				} else if (pn == NULL) {
d607 1
a607 1
					pn->getvars = 1;
d616 10
d640 7
d653 26
d687 1
a687 1
				node.macro = 1;
d698 1
a698 1
				node.macro = 1;
d737 10
d750 1
a750 1
		| MARK				{ node.mark++; }
d754 1
a754 1
		| MARKED			{ node.mark++; }
d758 1
a758 1
		| URL				{ node.getvars++; }
d991 8
d1045 1
d1051 1
@


1.25
log
@unbreak the symset function
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.24 2007/02/08 13:32:24 reyk Exp $	*/
d39 1
d57 2
d62 3
d110 4
a113 2
%token	SEND EXPECT NOTHING USE SSL
%token	LOG UPDATES ALL
d117 2
a118 1
%type	<v.number>	number port http_type loglevel
d130 2
d220 24
d271 1
a271 1
			if (last_service_id == UINT_MAX) {
d396 1
a396 1
			if (last_table_id == UINT_MAX) {
d490 16
d513 360
d877 1
a877 1
host		: HOST STRING {
d904 2
a905 1
			if (last_host_id == UINT_MAX) {
d913 4
d924 4
d969 1
d971 3
d976 1
d981 4
d992 2
d995 6
d1002 1
d1004 2
d1007 5
d1014 2
d1022 1
d1024 1
d1247 3
d1256 9
d1269 2
d1297 1
a1297 1
	if (TAILQ_EMPTY(&conf->services)) {
d1316 8
@


1.24
log
@carefully check some return values and make lint happier.  never pass
any truncated strings (table names/anchors/tags/...) to pf and the
kernel.

ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.23 2007/02/07 15:17:46 reyk Exp $	*/
d918 1
a918 2
	if (strlcpy(sym, s, len) >= len)
		errx(1, "cmdline_symset: macro too long");
@


1.23
log
@add new "log (updates|all)" configuration option to log state
notifications after completed host checks.  either only log the
"updates" to new states or log "all" state notifications, even if the
state didn't change. the log messages will be reported to syslog or to
stderr if the daemon is running in foreground mode.

ok claudio@@ pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.22 2007/02/07 13:39:58 reyk Exp $	*/
d415 3
a417 2
			asprintf(&table->sendbuf, "HEAD %s HTTP/1.0\r\n\r\n",
			    $3);
d428 3
a430 2
			asprintf(&table->sendbuf, "GET %s HTTP/1.0\r\n\r\n",
			    $3);
d918 2
a919 1
	strlcpy(sym, s, len);
@


1.22
log
@remove unused functions and variables which have been copied from
ospfd(8) (can be re-imported later if required).
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.21 2007/02/07 13:30:17 reyk Exp $	*/
d105 1
d109 1
a109 1
%type	<v.number>	number port http_type
d205 1
d211 4
d546 1
d561 1
d573 1
@


1.21
log
@add the -D option to define macros on the command line (as found in
bgpd(8), hostapd(8), ipsecctl(8), pfctl(8), ...).
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.20 2007/01/30 10:12:06 pyr Exp $	*/
a52 1
char				*start_state;
@


1.20
log
@small memleak plugged and style changes.
ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.19 2007/01/29 14:23:31 pyr Exp $	*/
a80 1
int		 cmdline_symset(char *);
@


1.19
log
@Add SSL support to hoststated.
with help and OK reyk@@
with help and advice by claudio@@ and Srebrenko Sehic
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.18 2007/01/25 19:40:08 niallo Exp $	*/
d48 1
a48 1
struct hoststated			*conf = NULL;
a460 1
			struct host *r;
d464 1
a464 1
			if ((r = calloc(1, sizeof(*r))) == NULL)
d471 1
d475 1
a475 1
			memcpy(&r->ss, &a->ss, sizeof(r->ss));
d478 2
a479 2
			if (strlcpy(r->name, $2, sizeof(r->name)) >=
			    sizeof(r->name)) {
d482 8
a490 8
			} else {
				r->id = last_host_id++;
				if (last_host_id == UINT_MAX) {
					yyerror("too many hosts defined");
					YYERROR;
				}
				free($2);
				$$ = r;
@


1.18
log
@return 0, not NULL in a function returning int.

ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.17 2007/01/24 06:31:09 pyr Exp $	*/
d44 2
d103 1
a103 1
%token  CHECK HTTP TCP ICMP EXTERNAL
d106 1
a106 1
%token	SEND EXPECT NOTHING
d110 1
a110 1
%type	<v.number>	number port
d139 4
d165 1
a165 1
		| PORT HTTP {
d167 10
d178 1
a178 1
			servent = getservbyname("http", "tcp");
d180 1
a180 1
				$$ = htons(80);
d399 10
a408 1
		| CHECK HTTP STRING CODE number {
d417 5
a421 1
		| CHECK HTTP STRING DIGEST STRING {
d450 4
d551 1
d561 1
d567 1
@


1.17
log
@Better handling of escaped CR-LF in the configuration file, commenting
them out was previously broken.  This is needed for send/expect scripts.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.16 2007/01/12 16:43:01 pyr Exp $	*/
d767 1
a767 1
		return (NULL);
@


1.16
log
@eliminate duplicate tcp read/write code.
ok claudio@@, reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.15 2007/01/09 13:50:11 pyr Exp $	*/
d63 1
a63 1
int	 lgetc(FILE *);
d553 1
a553 1
lgetc(FILE *f)
d557 1
d575 1
d579 1
d621 1
d628 2
a629 2
		c = lgetc(fin);
		if (c == '\n') {
d646 1
d650 1
a650 1
	while ((c = lgetc(fin)) == ' ')
d655 4
a658 2
		while ((c = lgetc(fin)) != '\n' && c != EOF)
			; /* nothing */
d661 1
a661 1
			if ((c = lgetc(fin)) == EOF)
d691 1
a691 1
			if ((c = lgetc(fin)) == EOF)
d697 1
a697 1
			if (c == '\n') {
d726 2
a727 1
		} while ((c = lgetc(fin)) != EOF && (allowed_in_string(c)));
@


1.15
log
@Finish renaming hostated to hoststated.
Note to testers: the user the daemon changes its id to is now _hoststated,
don't forget to update master.passwd.
ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.14 2007/01/09 00:45:32 deraadt Exp $	*/
d179 1
a179 1
			bzero(table->sendbuf, sizeof(table->sendbuf));
d182 3
a184 6
			if (strlcpy(table->sendbuf, $1, sizeof(table->sendbuf))
			    >= sizeof(table->sendbuf)) {
				yyerror("yyparse: send buffer truncated");
				free($1);
				YYERROR;
			}
d386 5
a390 6
			if (strlcpy(table->path, $3, sizeof(table->path)) >=
			    sizeof(table->path)) {
				yyerror("http path truncated");
				free($3);
				YYERROR;
			}
d394 5
a398 7
			if (strlcpy(table->path, $3, sizeof(table->path)) >=
			    sizeof(table->path)) {
				yyerror("http path truncated");
				free($3);
				free($5);
				YYERROR;
			}
a401 1
				free($3);
a404 1
			free($3);
@


1.14
log
@adapt to rename
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.13 2007/01/08 20:46:18 reyk Exp $	*/
d46 1
a46 1
struct hostated			*conf = NULL;
d745 1
a745 1
parse_config(struct hostated *x_conf, const char *filename, int opts)
d778 1
a778 1
		if ((conf->opts & HOSTATED_OPT_VERBOSE) && !sym->used)
@


1.13
log
@do NOT use the regexp interface. it is way to complicated, error-prone
and we don't know about all the possible security problems.

change the check send/expect code to use the fnmatch(3) interface
using shell globbing rules instead. this allows simple patterns like
"220 * ESMTP*" or "SSH-[12].??-*".

suggested by deraadt@@ and otto@@
ok Pierre-Yves Ritschard (pyr at spootnik dot org)
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.12 2007/01/08 17:10:23 reyk Exp $	*/
d44 1
a44 1
#include "hostated.h"
@


1.12
log
@allow to use service names in addition to numerical port numbers in
the configuration file, eg. "real port http".

> From Pierre-Yves Ritschard (pyr at spootnik dot org)

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.11 2007/01/08 16:50:04 reyk Exp $	*/
a42 1
#include <regex.h>
a415 3
			int	ret;
			char	ebuf[32];

d417 3
a419 5
			ret = regcomp(&table->regx, $5, REG_EXTENDED|REG_NOSUB);
			if (ret != 0) {
				regerror(ret, &table->regx, ebuf, sizeof(ebuf));
				yyerror("cannot compile expect regexp: %s",
				    ebuf);
@


1.11
log
@the timeout values are not allowed to exceed the global interval (i
figured this out while testing hostated against a stottering spamd
where the send/expect timeout needs be > 10 seconds). also use another
struct timeval to store the interval for easier handling in the code.

ok Pierre-Yves Ritschard (pyr at spootnik dot org)
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.10 2007/01/08 14:30:31 reyk Exp $	*/
d109 1
a109 1
%type	<v.number>	number
d138 33
d298 1
a298 7
		| VIRTUAL IP STRING PORT number	interface {
			if ($5 < 1 || $5 > USHRT_MAX) {
				yyerror("invalid port number: %d", $5);
				free($3);
				free($6);
				YYERROR;
			}
d300 1
a300 1
				 SRV_MAX_VIRTS, htons($5), $6) <= 0) {
d303 1
a303 1
				free($6);
d307 1
a307 1
			free($6);
d431 2
a432 6
		| REAL PORT number {
			if ($3 < 1 || $3 >= USHRT_MAX) {
				yyerror("invalid port number: %d", $3);
				YYERROR;
			}
			table->port = $3;
d776 1
d778 1
@


1.10
log
@remove unused token.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.9 2007/01/08 13:37:26 reyk Exp $	*/
d160 1
a160 1
main		: INTERVAL number	{ conf->interval = $2; }
d744 2
a745 1
	conf->interval = CHECK_INTERVAL;
d775 5
d781 1
a781 1
	TAILQ_FOREACH(table, &conf->tables, entry)
d786 6
@


1.9
log
@add a generic send/expect check using regular expression (see
regex(3)).  this allows to define additional checks for other TCP
protocols.

From Pierre-Yves Ritschard (pyr at spootnik dot org)
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.8 2007/01/03 09:45:29 reyk Exp $	*/
d102 1
a102 1
%token  CHECK HTTP HTTPS TCP ICMP EXTERNAL
a508 1
		{ "https",		HTTPS },
@


1.8
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.7 2007/01/03 09:42:30 reyk Exp $	*/
d43 1
d105 1
d146 14
d380 1
a380 1
			    sizeof(table->digest)) >= sizeof (table->digest)) {
d389 15
d505 1
d514 1
d517 1
d565 7
a571 1
		if (next != '\n') {
@


1.7
log
@allow the sticky-address option for round-robin pools.

From Pierre-Yves Ritschard (pyr at spootnik dot org)
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.6 2006/12/25 19:05:41 reyk Exp $	*/
d300 2
a301 1
			bcopy(&conf->timeout, &tb->timeout, sizeof(struct timeval));
d364 1
a364 1
			    sizeof (table->digest)) >= sizeof (table->digest)) {
@


1.6
log
@fix the conversion from milliseconds to struct timeval, which uses
seconds (tv_sec) and microseconds (tv_usec), but the code assumed
seconds and milliseconds...
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.5 2006/12/25 18:12:14 reyk Exp $	*/
d103 1
a103 1
%token	VIRTUAL IP INTERVAL DISABLE
d267 1
d484 1
@


1.5
log
@partial rewrite of the check_* routines to use libevent everywhere
instead of nested select() calls and to handle the non-blocking
sockets properly.

From Pierre-Yves Ritschard (pyr at spootnik dot org)
(with a little help by me)
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.4 2006/12/16 18:05:35 martin Exp $	*/
d93 1
d109 1
d145 3
a147 1
		| TIMEOUT number	{ conf->timeout = $2; }
d299 1
a299 1
			tb->timeout = conf->timeout;
d333 2
a334 2
		| TIMEOUT number	{
			table->timeout = $2;
d420 7
d700 2
a701 1
	conf->timeout = CHECK_TIMEOUT;
@


1.4
log
@typo
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.3 2006/12/16 17:48:27 deraadt Exp $	*/
d143 1
d295 1
a295 1
			tb->timeout = CONNECT_TIMEOUT;
d689 1
@


1.3
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.2 2006/12/16 12:42:14 reyk Exp $	*/
d475 1
a475 1
		{ "virtual",		VIRTUA L}
@


1.2
log
@knf, spacing

please note that some editors will replace tabs with multiple spaces
if you cut & paste code from other sections.  please try to keep the
tabs ;).
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.1 2006/12/16 11:45:07 reyk Exp $	*/
d126 1
a126 1
					$1, estr);
d174 1
a174 1
					service->name);
d179 1
a179 1
					service->name);
d356 2
a357 2
			if (strlcpy(table->digest, $5, sizeof (table->digest))
					>= sizeof (table->digest)) {
d376 1
a376 1
interface	: /*empty*/ 		{ $$ = NULL; }
d455 21
a475 21
		{"backup",		BACKUP},
		{"check",		CHECK},
		{"code",		CODE},
		{"digest",		DIGEST},
		{"disable",		DISABLE},
		{"external",		EXTERNAL},
		{"host",		HOST},
		{"http",		HTTP},
		{"https",		HTTPS},
		{"icmp",		ICMP},
		{"interface",		INTERFACE},
		{"interval",		INTERVAL},
		{"ip",			IP},
		{"port",		PORT},
		{"real",		REAL},
		{"service",		SERVICE},
		{"table",		TABLE},
		{"tag",			TAG},
		{"tcp",			TCP},
		{"timeout",		TIMEOUT},
		{"virtual",		VIRTUAL}
d864 1
a864 1
			return (0);
d903 1
a903 1
			s, max);
a905 1

d911 1
a911 1
     in_port_t port, const char *ifname)
@


1.1
log
@Import hostated, the host status daemon.  This daemon will monitor
remote hosts and dynamically alter pf(4) tables and redirection rules
for active server load balancing.  The daemon has been written by
Pierre-Yves Ritschard (pyr at spootnik.org) and was formerly known as
"slbd".

The daemon is fully functional but it still needs some work and
cleanup so we don't link it to the build yet.  Some TODOs are a
partial rewrite of the check_* routines (use libevent whenever we
can), improvement of the manpages, and general knf and cleanup.

ok deraadt@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d77 3
a79 3
int			 symset(const char *, const char *, int);
char			*symget(const char *);
int			 cmdline_symset(char *);
d84 1
a84 1
			  int, in_port_t, const char *);
d86 1
a86 1
		      int, in_port_t, const char *);
d120 1
a120 1
number		: STRING 		{
d145 1
a145 1
service		: SERVICE STRING 	{
d159 2
a160 2
			if (strlcpy(srv->name, $2, sizeof (srv->name)) >=
					sizeof (srv->name)) {
d164 1
a164 1
			free ($2);
d186 1
a186 1
			         service->table->port) {
d188 2
a189 2
					"for its table and backup table",
					service->name);
d192 1
a192 1
			
d203 1
a203 1
serviceoptsl	: TABLE STRING 			{
d220 1
a220 1
		| BACKUP TABLE STRING 		{
d273 1
a273 1
table		: TABLE STRING 			{
d284 1
a284 1
			
d287 3
a289 3
			
			if (strlcpy(tb->name, $2, sizeof (tb->name)) >=
					sizeof (tb->name)) {
d299 1
a299 1
			free ($2);
d301 1
a301 1
		} '{' optnl tableopts_l '}' 	{
d323 1
a323 1
tableoptsl	: host 				{
d328 1
a328 1
		| TIMEOUT number 		{
d331 1
a331 1
		| CHECK ICMP 			{
d334 1
a334 1
		| CHECK TCP 			{
d340 2
a341 2
			if (strlcpy(table->path, $3, sizeof (table->path)) >=
					sizeof (table->path)) {
d349 2
a350 2
			if (strlcpy(table->path, $3, sizeof (table->path)) >=
					sizeof (table->path)) {
d381 1
a381 1
                        struct host *r;
d385 2
a386 2
                        if ((r = calloc(1, sizeof (*r))) == NULL)
                                fatal("out of memory");
d398 2
a399 2
                        if (strlcpy(r->name, $2, sizeof (r->name)) >=
					sizeof (r->name)) {
d686 1
a686 1
		      sizeof(conf->empty_table.name)); 
d838 1
a838 1
	
d915 1
a915 1
		
d931 1
a931 1
		
@

