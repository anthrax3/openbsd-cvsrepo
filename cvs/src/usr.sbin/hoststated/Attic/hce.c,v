head	1.37;
access;
symbols
	OPENBSD_4_2:1.29.0.2
	OPENBSD_4_2_BASE:1.29
	OPENBSD_4_1:1.18.0.2
	OPENBSD_4_1_BASE:1.18;
locks; strict;
comment	@ * @;


1.37
date	2007.12.07.17.27.07;	author deraadt;	state dead;
branches;
next	1.36;

1.36
date	2007.11.24.17.07.28;	author reyk;	state Exp;
branches;
next	1.35;

1.35
date	2007.11.21.09.54.39;	author pyr;	state Exp;
branches;
next	1.34;

1.34
date	2007.11.20.15.44.21;	author pyr;	state Exp;
branches;
next	1.33;

1.33
date	2007.11.19.15.31.36;	author reyk;	state Exp;
branches;
next	1.32;

1.32
date	2007.10.19.12.08.55;	author pyr;	state Exp;
branches;
next	1.31;

1.31
date	2007.10.12.12.50.59;	author blambert;	state Exp;
branches;
next	1.30;

1.30
date	2007.09.28.13.29.56;	author pyr;	state Exp;
branches;
next	1.29;

1.29
date	2007.06.19.13.06.00;	author pyr;	state Exp;
branches;
next	1.28;

1.28
date	2007.06.19.06.29.20;	author pyr;	state Exp;
branches;
next	1.27;

1.27
date	2007.06.12.15.16.10;	author msf;	state Exp;
branches;
next	1.26;

1.26
date	2007.06.07.07.19.50;	author pyr;	state Exp;
branches;
next	1.25;

1.25
date	2007.05.31.05.07.08;	author pyr;	state Exp;
branches;
next	1.24;

1.24
date	2007.05.31.03.26.36;	author pyr;	state Exp;
branches;
next	1.23;

1.23
date	2007.05.31.03.24.05;	author pyr;	state Exp;
branches;
next	1.22;

1.22
date	2007.05.29.17.12.04;	author reyk;	state Exp;
branches;
next	1.21;

1.21
date	2007.05.28.22.11.33;	author pyr;	state Exp;
branches;
next	1.20;

1.20
date	2007.05.27.20.53.10;	author pyr;	state Exp;
branches;
next	1.19;

1.19
date	2007.05.26.19.58.48;	author pyr;	state Exp;
branches;
next	1.18;

1.18
date	2007.03.07.17.40.32;	author reyk;	state Exp;
branches;
next	1.17;

1.17
date	2007.03.06.19.37.31;	author reyk;	state Exp;
branches;
next	1.16;

1.16
date	2007.02.22.03.32.39;	author reyk;	state Exp;
branches;
next	1.15;

1.15
date	2007.02.07.15.17.46;	author reyk;	state Exp;
branches;
next	1.14;

1.14
date	2007.02.07.14.39.45;	author reyk;	state Exp;
branches;
next	1.13;

1.13
date	2007.02.07.13.39.58;	author reyk;	state Exp;
branches;
next	1.12;

1.12
date	2007.01.29.14.23.31;	author pyr;	state Exp;
branches;
next	1.11;

1.11
date	2007.01.24.10.26.00;	author claudio;	state Exp;
branches;
next	1.10;

1.10
date	2007.01.11.18.05.08;	author reyk;	state Exp;
branches;
next	1.9;

1.9
date	2007.01.09.13.50.11;	author pyr;	state Exp;
branches;
next	1.8;

1.8
date	2007.01.09.00.45.32;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2007.01.08.20.46.18;	author reyk;	state Exp;
branches;
next	1.6;

1.6
date	2007.01.08.16.52.58;	author reyk;	state Exp;
branches;
next	1.5;

1.5
date	2007.01.08.13.37.26;	author reyk;	state Exp;
branches;
next	1.4;

1.4
date	2006.12.25.18.12.14;	author reyk;	state Exp;
branches;
next	1.3;

1.3
date	2006.12.16.17.48.27;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2006.12.16.12.42.14;	author reyk;	state Exp;
branches;
next	1.1;

1.1
date	2006.12.16.11.45.07;	author reyk;	state Exp;
branches;
next	;


desc
@@


1.37
log
@hoststated/hoststatectl get repository copied (and de-tagged) into
relayd/relayctl.  This is a more suitable place for a daemon that has
grown out of it's initial roots of "monitoring and redirecting services
at various layers", into one that is "a full featured proxy, which
happens to know what is up/down"
@
text
@/*	$OpenBSD: hce.c,v 1.36 2007/11/24 17:07:28 reyk Exp $	*/

/*
 * Copyright (c) 2006 Pierre-Yves Ritschard <pyr@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/param.h>
#include <sys/queue.h>
#include <sys/time.h>
#include <sys/stat.h>
#include <sys/socket.h>
#include <sys/un.h>

#include <net/if.h>
#include <netinet/in_systm.h>
#include <netinet/in.h>
#include <netinet/ip.h>

#include <errno.h>
#include <event.h>
#include <fcntl.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <err.h>
#include <pwd.h>

#include <openssl/ssl.h>

#include "hoststated.h"

__dead void hce_shutdown(void);
void	hce_sig_handler(int sig, short, void *);
void	hce_dispatch_imsg(int, short, void *);
void	hce_dispatch_parent(int, short, void *);
void	hce_launch_checks(int, short, void *);
void	hce_setup_events(void);
void	hce_disable_events(void);

static struct hoststated *env = NULL;
struct imsgbuf		*ibuf_pfe;
struct imsgbuf		*ibuf_main;
int			 pipe_pfe;
int			 pipe_parent;
int			 running = 0;

void
hce_sig_handler(int sig, short event, void *arg)
{
	switch (sig) {
	case SIGINT:
	case SIGTERM:
		hce_shutdown();
		break;
	default:
		fatalx("hce_sig_handler: unexpected signal");
	}
}

pid_t
hce(struct hoststated *x_env, int pipe_parent2pfe[2], int pipe_parent2hce[2],
    int pipe_parent2relay[RELAY_MAXPROC][2], int pipe_pfe2hce[2],
    int pipe_pfe2relay[RELAY_MAXPROC][2])
{
	pid_t		 pid;
	struct passwd	*pw;
	int		 i;
	struct event	 ev_sigint;
	struct event	 ev_sigterm;

	switch (pid = fork()) {
	case -1:
		fatal("hce: cannot fork");
	case 0:
		break;
	default:
		return (pid);
	}

	env = x_env;
	purge_config(env, PURGE_SERVICES|PURGE_RELAYS|PURGE_PROTOS);

	if ((pw = getpwnam(HOSTSTATED_USER)) == NULL)
		fatal("hce: getpwnam");

#ifndef DEBUG
	if (chroot(pw->pw_dir) == -1)
		fatal("hce: chroot");
	if (chdir("/") == -1)
		fatal("hce: chdir(\"/\")");
#else
#warning disabling privilege revocation and chroot in DEBUG mode
#endif

	setproctitle("host check engine");
	hoststated_process = PROC_HCE;

	/* this is needed for icmp tests */
	icmp_init(env);

#ifndef DEBUG
	if (setgroups(1, &pw->pw_gid) ||
	    setresgid(pw->pw_gid, pw->pw_gid, pw->pw_gid) ||
	    setresuid(pw->pw_uid, pw->pw_uid, pw->pw_uid))
		fatal("hce: can't drop privileges");
#endif

	event_init();

	if ((ibuf_pfe = calloc(1, sizeof(struct imsgbuf))) == NULL ||
	    (ibuf_main = calloc(1, sizeof(struct imsgbuf))) == NULL)
		fatal("hce");
	imsg_init(ibuf_pfe, pipe_pfe2hce[0], hce_dispatch_imsg);
	imsg_init(ibuf_main, pipe_parent2hce[1], hce_dispatch_parent);

	ibuf_pfe->events = EV_READ;
	event_set(&ibuf_pfe->ev, ibuf_pfe->fd, ibuf_pfe->events,
	    ibuf_pfe->handler, ibuf_pfe);
	event_add(&ibuf_pfe->ev, NULL);

	ibuf_main->events = EV_READ;
	event_set(&ibuf_main->ev, ibuf_main->fd, ibuf_main->events,
	    ibuf_main->handler, ibuf_main);
	event_add(&ibuf_main->ev, NULL);

	signal_set(&ev_sigint, SIGINT, hce_sig_handler, NULL);
	signal_set(&ev_sigterm, SIGTERM, hce_sig_handler, NULL);
	signal_add(&ev_sigint, NULL);
	signal_add(&ev_sigterm, NULL);
	signal(SIGPIPE, SIG_IGN);
	signal(SIGHUP, SIG_IGN);

	/* setup pipes */
	close(pipe_pfe2hce[1]);
	close(pipe_parent2hce[0]);
	close(pipe_parent2pfe[0]);
	close(pipe_parent2pfe[1]);
	for (i = 0; i < env->prefork_relay; i++) {
		close(pipe_parent2relay[i][0]);
		close(pipe_parent2relay[i][1]);
		close(pipe_pfe2relay[i][0]);
		close(pipe_pfe2relay[i][1]);
	}

	hce_setup_events();
	event_dispatch();
	hce_shutdown();

	return (0);
}

void
hce_setup_events(void)
{
	struct timeval	 tv;
	struct table	*table;

	if (!TAILQ_EMPTY(env->tables)) {
		evtimer_set(&env->ev, hce_launch_checks, env);
		bzero(&tv, sizeof(tv));
		evtimer_add(&env->ev, &tv);
	}

	if (env->flags & F_SSL) {
		ssl_init(env);
		TAILQ_FOREACH(table, env->tables, entry) {
			if (!(table->conf.flags & F_SSL))
				continue;
			table->ssl_ctx = ssl_ctx_create(env);
		}
	}
}

void
hce_disable_events(void)
{
	struct table	*table;
	struct host	*host;

	evtimer_del(&env->ev);
	TAILQ_FOREACH(table, env->tables, entry) {
		TAILQ_FOREACH(host, &table->hosts, entry) {
			event_del(&host->cte.ev);
			close(host->cte.s);
		}
	}
	if (env->has_icmp) {
		event_del(&env->icmp_send.ev);
		event_del(&env->icmp_recv.ev);
	}
	if (env->has_icmp6) {
		event_del(&env->icmp6_send.ev);
		event_del(&env->icmp6_recv.ev);
	}
}

void
hce_launch_checks(int fd, short event, void *arg)
{
	struct host		*host;
	struct table		*table;
	struct timeval		 tv;

	/*
	 * notify pfe checks are done and schedule next check
	 */
	imsg_compose(ibuf_pfe, IMSG_SYNC, 0, 0, -1, NULL, 0);
	TAILQ_FOREACH(table, env->tables, entry) {
		TAILQ_FOREACH(host, &table->hosts, entry) {
			host->flags &= ~(F_CHECK_SENT|F_CHECK_DONE);
			event_del(&host->cte.ev);
		}
	}

	if (gettimeofday(&tv, NULL))
		fatal("hce_launch_checks: gettimeofday");

	TAILQ_FOREACH(table, env->tables, entry) {
		if (table->conf.flags & F_DISABLE)
			continue;
		if (table->conf.skip_cnt) {
			if (table->skipped++ > table->conf.skip_cnt)
				table->skipped = 0;
			if (table->skipped != 1)
				continue;
		}
		if (table->conf.check == CHECK_NOCHECK)
			fatalx("hce_launch_checks: unknown check type");

		TAILQ_FOREACH(host, &table->hosts, entry) {
			if (host->flags & F_DISABLE)
				continue;
			switch (table->conf.check) {
			case CHECK_ICMP:
				schedule_icmp(env, host);
				break;
			case CHECK_SCRIPT:
				check_script(host);
				break;
			default:
				/* Any other TCP-style checks */
				bzero(&host->cte, sizeof(host->cte));
				host->last_up = host->up;
				host->cte.host = host;
				host->cte.table = table;
				bcopy(&tv, &host->cte.tv_start,
				    sizeof(host->cte.tv_start));
				check_tcp(&host->cte);
				break;
			}
		}
	}
	check_icmp(env, &tv);

	bcopy(&env->interval, &tv, sizeof(tv));
	evtimer_add(&env->ev, &tv);
}

void
hce_notify_done(struct host *host, const char *msg)
{
	struct table		*table;
	struct ctl_status	 st;
	struct timeval		 tv_now, tv_dur;
	u_long			 duration;
	u_int			 logopt;

	if (host->up == HOST_DOWN && host->retry_cnt) {
		log_debug("hce_notify_done: host %s retry %d",
		    host->conf.name, host->retry_cnt);
		host->up = host->last_up;
		host->retry_cnt--;
	} else
		host->retry_cnt = host->conf.retry;
	if (host->up != HOST_UNKNOWN) {
		host->check_cnt++;
		if (host->up == HOST_UP)
			host->up_cnt++;
	}
	st.id = host->conf.id;
	st.up = host->up;
	st.check_cnt = host->check_cnt;
	st.retry_cnt = host->retry_cnt;
	host->flags |= (F_CHECK_SENT|F_CHECK_DONE);
	if (msg)
		log_debug("hce_notify_done: %s (%s)", host->conf.name, msg);

	imsg_compose(ibuf_pfe, IMSG_HOST_STATUS, 0, 0, -1, &st, sizeof(st));
	if (host->up != host->last_up)
		logopt = HOSTSTATED_OPT_LOGUPDATE;
	else
		logopt = HOSTSTATED_OPT_LOGNOTIFY;

	if (gettimeofday(&tv_now, NULL))
		fatal("hce_notify_done: gettimeofday");
	timersub(&tv_now, &host->cte.tv_start, &tv_dur);
	if (timercmp(&host->cte.tv_start, &tv_dur, >))
		duration = (tv_dur.tv_sec * 1000) + (tv_dur.tv_usec / 1000.0);
	else
		duration = 0;

	if ((table = table_find(env, host->conf.tableid)) == NULL)
		fatalx("hce_notify_done: invalid table id");

	if (env->opts & logopt) {
		log_info("host %s, check %s%s (%lums), state %s -> %s, "
		    "availability %s",
		    host->conf.name, table_check(table->conf.check),
		    (table->conf.flags & F_SSL) ? " use ssl" : "", duration,
		    host_status(host->last_up), host_status(host->up),
		    print_availability(host->check_cnt, host->up_cnt));
	}
	host->last_up = host->up;
}

void
hce_shutdown(void)
{
	log_info("host check engine exiting");
	_exit(0);
}

void
hce_dispatch_imsg(int fd, short event, void *ptr)
{
	struct imsgbuf		*ibuf;
	struct imsg		 imsg;
	ssize_t			 n;
	objid_t			 id;
	struct host		*host;
	struct table		*table;

	ibuf = ptr;
	switch (event) {
	case EV_READ:
		if ((n = imsg_read(ibuf)) == -1)
			fatal("hce_dispatch_imsg: imsg_read_error");
		if (n == 0) {
			/* this pipe is dead, so remove the event handler */
			event_del(&ibuf->ev);
			event_loopexit(NULL);
			return;
		}
		break;
	case EV_WRITE:
		if (msgbuf_write(&ibuf->w) == -1)
			fatal("hce_dispatch_imsg: msgbuf_write");
		imsg_event_add(ibuf);
		return;
	default:
		fatalx("hce_dispatch_imsg: unknown event");
	}

	for (;;) {
		if ((n = imsg_get(ibuf, &imsg)) == -1)
			fatal("hce_dispatch_imsg: imsg_read error");
		if (n == 0)
			break;

		switch (imsg.hdr.type) {
		case IMSG_HOST_DISABLE:
			memcpy(&id, imsg.data, sizeof(id));
			if ((host = host_find(env, id)) == NULL)
				fatalx("hce_dispatch_imsg: desynchronized");
			host->flags |= F_DISABLE;
			host->up = HOST_UNKNOWN;
			host->check_cnt = 0;
			host->up_cnt = 0;
			break;
		case IMSG_HOST_ENABLE:
			memcpy(&id, imsg.data, sizeof(id));
			if ((host = host_find(env, id)) == NULL)
				fatalx("hce_dispatch_imsg: desynchronized");
			host->flags &= ~(F_DISABLE);
			host->up = HOST_UNKNOWN;
			break;
		case IMSG_TABLE_DISABLE:
			memcpy(&id, imsg.data, sizeof(id));
			if ((table = table_find(env, id)) == NULL)
				fatalx("hce_dispatch_imsg: desynchronized");
			table->conf.flags |= F_DISABLE;
			TAILQ_FOREACH(host, &table->hosts, entry)
				host->up = HOST_UNKNOWN;
			break;
		case IMSG_TABLE_ENABLE:
			memcpy(&id, imsg.data, sizeof(id));
			if ((table = table_find(env, id)) == NULL)
				fatalx("hce_dispatch_imsg: desynchronized");
			table->conf.flags &= ~(F_DISABLE);
			TAILQ_FOREACH(host, &table->hosts, entry)
				host->up = HOST_UNKNOWN;
			break;
		case IMSG_CTL_POLL:
			evtimer_del(&env->ev);
			TAILQ_FOREACH(table, env->tables, entry)
				table->skipped = 0;
			hce_launch_checks(-1, EV_TIMEOUT, env);
			break;
		default:
			log_debug("hce_dispatch_msg: unexpected imsg %d",
			    imsg.hdr.type);
			break;
		}
		imsg_free(&imsg);
	}
	imsg_event_add(ibuf);
}

void
hce_dispatch_parent(int fd, short event, void * ptr)
{
	struct imsgbuf		*ibuf;
	struct imsg		 imsg;
	struct ctl_script	 scr;
	ssize_t			 n;
	size_t			 len;

	static struct table	*table = NULL;
	struct host		*host;

	ibuf = ptr;
	switch (event) {
	case EV_READ:
		if ((n = imsg_read(ibuf)) == -1)
			fatal("hce_dispatch_parent: imsg_read error");
		if (n == 0) {
			/* this pipe is dead, so remove the event handler */
			event_del(&ibuf->ev);
			event_loopexit(NULL);
			return;
		}
		break;
	case EV_WRITE:
		if (msgbuf_write(&ibuf->w) == -1)
			fatal("hce_dispatch_parent: msgbuf_write");
		imsg_event_add(ibuf);
		return;
	default:
		fatalx("hce_dispatch_parent: unknown event");
	}

	for (;;) {
		if ((n = imsg_get(ibuf, &imsg)) == -1)
			fatal("hce_dispatch_parent: imsg_read error");
		if (n == 0)
			break;

		switch (imsg.hdr.type) {
		case IMSG_SCRIPT:
			if (imsg.hdr.len - IMSG_HEADER_SIZE !=
			    sizeof(scr))
				fatalx("hce_dispatch_parent: "
				    "invalid size of script request");
			bcopy(imsg.data, &scr, sizeof(scr));
			script_done(env, &scr);
			break;
		case IMSG_RECONF:
			log_debug("hce: reloading configuration");
			if (imsg.hdr.len !=
			    sizeof(struct hoststated) + IMSG_HEADER_SIZE)
				fatalx("corrupted reload data");
			hce_disable_events();
			purge_config(env, PURGE_TABLES);
			merge_config(env, (struct hoststated *)imsg.data);

			env->tables = calloc(1, sizeof(*env->tables));
			if (env->tables == NULL)
				fatal(NULL);

			TAILQ_INIT(env->tables);
			break;
		case IMSG_RECONF_TABLE:
			if ((table = calloc(1, sizeof(*table))) == NULL)
				fatal(NULL);
			memcpy(&table->conf, imsg.data, sizeof(table->conf));
			TAILQ_INIT(&table->hosts);
			TAILQ_INSERT_TAIL(env->tables, table, entry);
			break;
		case IMSG_RECONF_SENDBUF:
			len = imsg.hdr.len - IMSG_HEADER_SIZE;
			table->sendbuf = calloc(1, len);
			(void)strlcpy(table->sendbuf, (char *)imsg.data, len);
			break;
		case IMSG_RECONF_HOST:
			if ((host = calloc(1, sizeof(*host))) == NULL)
				fatal(NULL);
			memcpy(&host->conf, imsg.data, sizeof(host->conf));
			host->tablename = table->conf.name;
			TAILQ_INSERT_TAIL(&table->hosts, host, entry);
			break;
		case IMSG_RECONF_END:
			log_warnx("hce: configuration reloaded");
			hce_setup_events();
			break;
		default:
			log_debug("hce_dispatch_parent: unexpected imsg %d",
			    imsg.hdr.type);
			break;
		}
		imsg_free(&imsg);
	}
	imsg_event_add(ibuf);
}
@


1.36
log
@sort includes, adjust to style(9)
@
text
@d1 1
a1 1
/*	$OpenBSD: hce.c,v 1.35 2007/11/21 09:54:39 pyr Exp $	*/
@


1.35
log
@make sure all hosts are checked when hoststatectl poll is issued, now
that check interval can differ from table to table.
ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hce.c,v 1.34 2007/11/20 15:44:21 pyr Exp $	*/
d19 1
a20 2
#include <sys/param.h>
#include <sys/types.h>
d25 2
d30 1
a30 1
#include <net/if.h>
@


1.34
log
@Allow overriding the global interval in a table.
Table specific intervals must be multiples of the global interval.
help and ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hce.c,v 1.33 2007/11/19 15:31:36 reyk Exp $	*/
d406 2
@


1.33
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: hce.c,v 1.32 2007/10/19 12:08:55 pyr Exp $	*/
d232 6
@


1.32
log
@Add the ability to schedule an immediate check through hoststatectl.
Especially useful when interval is rather long.
I was supposed to commit this before 4.2.
@
text
@d1 1
a1 1
/*	$OpenBSD: hce.c,v 1.31 2007/10/12 12:50:59 blambert Exp $	*/
d418 1
a418 1
	ssize_t		 	 n;
@


1.31
log
@Silence some lint(1) warnings

ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hce.c,v 1.30 2007/09/28 13:29:56 pyr Exp $	*/
d397 4
@


1.30
log
@Correct my mail address.
@
text
@d1 1
a1 1
/*	$OpenBSD: hce.c,v 1.29 2007/06/19 13:06:00 pyr Exp $	*/
d43 1
a44 1
void	hce_shutdown(void);
@


1.29
log
@don't go through the effort of creating a SIGHUP handler through
libevent just to ignore it, use SIG_IGN instead.
this syncs hoststated with bgpd and (soon) ospfd.
@
text
@d1 1
a1 1
/*	$OpenBSD: hce.c,v 1.28 2007/06/19 06:29:20 pyr Exp $	*/
d4 1
a4 1
 * Copyright (c) 2006 Pierre-Yves Ritschard <pyr@@spootnik.org>
@


1.28
log
@Do not fatal out with ``pipe closed'' when a short read occurs on one
of our socket pairs. Instead disable listening on the pipe, terminate the
event loop, and let the parent process's SIGCHLD handler do a clean
shutdown.

from an ospfd diff by claudio, ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hce.c,v 1.27 2007/06/12 15:16:10 msf Exp $	*/
a65 3
	case SIGHUP:
		/* nothing */
		break;
a80 1
	struct event	 ev_sighup;
a138 1
	signal_set(&ev_sighup, SIGHUP, hce_sig_handler, NULL);
a140 1
	signal_add(&ev_sighup, NULL);
d142 1
@


1.27
log
@put the fd passing from bgpd back in to hoststated's version of imsg,
needed for layer 7 reload support.

ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hce.c,v 1.26 2007/06/07 07:19:50 pyr Exp $	*/
d348 6
a353 2
		if (n == 0)
			fatalx("hce_dispatch_imsg: pipe closed");
d430 6
a435 2
		if (n == 0)
			fatalx("hce_dispatch_parent: pipe closed");
@


1.26
log
@(finally) Enable reload support for layer 3 configurations.
Hoststated can be reloaded either by sending SIGHUP to the parent process
or by using ``hoststatectl reload''
discussed and ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hce.c,v 1.25 2007/05/31 05:07:08 pyr Exp $	*/
d223 1
a223 1
	imsg_compose(ibuf_pfe, IMSG_SYNC, 0, 0, NULL, 0);
d298 1
a298 1
	imsg_compose(ibuf_pfe, IMSG_HOST_STATUS, 0, 0, &st, sizeof(st));
@


1.25
log
@split event registration between the ones that will be kept intact
at reconfiguration time.
@
text
@d1 1
a1 1
/*	$OpenBSD: hce.c,v 1.25 2007/05/31 05:04:27 pyr Exp $	*/
d67 1
d84 1
d101 1
d106 3
d116 1
d121 1
d143 1
d146 1
d416 4
d452 38
@


1.24
log
@some silly debug code snuck in.
@
text
@d1 1
a1 1
/*	$OpenBSD: hce.c,v 1.23 2007/05/31 03:24:05 pyr Exp $	*/
d48 2
a49 2
void	hce_setup_events(int);
void	hce_start(void);
d81 2
d115 17
a131 2
	pipe_pfe = pipe_pfe2hce[0];
	pipe_parent = pipe_parent2hce[1];
d133 5
a137 1
	hce_setup_events(0);
d151 2
a152 2
	hce_start();

d159 1
a159 43
hce_setup_events(int diefirst)
{
	struct event	 ev_sigint;
	struct event	 ev_sigterm;
	struct timeval	 tv;

	if (diefirst) {

		if (!TAILQ_EMPTY(env->tables)) {
			evtimer_set(&env->ev, hce_launch_checks, env);
			bzero(&tv, sizeof(tv));
			evtimer_add(&env->ev, &tv);
		}

		bzero(&tv, sizeof(tv));
		event_loopexit(&tv);
	}
	event_init();

	signal_set(&ev_sigint, SIGINT, hce_sig_handler, NULL);
	signal_set(&ev_sigterm, SIGTERM, hce_sig_handler, NULL);
	signal_add(&ev_sigint, NULL);
	signal_add(&ev_sigterm, NULL);
	signal(SIGPIPE, SIG_IGN);

	if ((ibuf_pfe = calloc(1, sizeof(struct imsgbuf))) == NULL ||
	    (ibuf_main = calloc(1, sizeof(struct imsgbuf))) == NULL)
		fatal("hce");
	imsg_init(ibuf_pfe, pipe_pfe, hce_dispatch_imsg);
	imsg_init(ibuf_main, pipe_parent, hce_dispatch_parent);
	ibuf_pfe->events = EV_READ;
	event_set(&ibuf_pfe->ev, ibuf_pfe->fd, ibuf_pfe->events,
	    ibuf_pfe->handler, ibuf_pfe);
	event_add(&ibuf_pfe->ev, NULL);

	ibuf_main->events = EV_READ;
	event_set(&ibuf_main->ev, ibuf_main->fd, ibuf_main->events,
	    ibuf_main->handler, ibuf_main);
	event_add(&ibuf_main->ev, NULL);
}

void
hce_start(void)
d178 23
a200 1
	event_dispatch();
@


1.23
log
@allocate table lists and service lists instead of using static structs.
split the code to start the event loop in two functions.
introduce merge_config which will be used later on.
@
text
@d1 1
a1 1
/*	$OpenBSD: hce.c,v 1.22 2007/05/29 17:12:04 reyk Exp $	*/
a208 1
	log_warnx("new check suite");
a222 2
	log_warnx("setting up checks");

a223 1
		log_warnx("setting up %s", table->conf.name);
a229 2
			log_warnx("setting up %s.%s", table->conf.name,
			    host->conf.name);
@


1.22
log
@add a new check method which allows to run external scripts/programs
for custom evaluations.

pyr agrees to put it in now but to do some improvements of the timeout
handling later.
@
text
@d1 1
a1 1
/*	$OpenBSD: hce.c,v 1.21 2007/05/28 22:11:33 pyr Exp $	*/
d48 2
d54 3
d65 3
a79 4
	struct timeval	 tv;
	struct event	 ev_sigint;
	struct event	 ev_sigterm;
	struct table	*table;
d113 2
a114 1
	event_init();
d116 1
a116 5
	signal_set(&ev_sigint, SIGINT, hce_sig_handler, NULL);
	signal_set(&ev_sigterm, SIGTERM, hce_sig_handler, NULL);
	signal_add(&ev_sigint, NULL);
	signal_add(&ev_sigterm, NULL);
	signal(SIGPIPE, SIG_IGN);
d130 33
d166 2
a167 3
	imsg_init(ibuf_pfe, pipe_pfe2hce[0], hce_dispatch_imsg);
	imsg_init(ibuf_main, pipe_parent2hce[1], hce_dispatch_parent);

d177 1
d179 7
a185 1
	if (!TAILQ_EMPTY(&env->tables)) {
d193 1
a193 1
		TAILQ_FOREACH(table, &env->tables, entry) {
a198 1

a199 4

	hce_shutdown();

	return (0);
d209 1
d214 1
a214 1
	TAILQ_FOREACH(table, &env->tables, entry) {
d224 4
a227 1
	TAILQ_FOREACH(table, &env->tables, entry) {
d234 2
a317 1

@


1.21
log
@another small step towards hoststated reloading.
allow purging of parts of the hoststated environment structure.
start using this function now to only keep vital information in
hoststated children processes.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hce.c,v 1.20 2007/05/27 20:53:10 pyr Exp $	*/
d49 1
a49 1
static struct hoststated	*env = NULL;
d197 2
a198 1
			if (table->conf.check == CHECK_ICMP) {
d200 14
a213 1
				continue;
a214 9

			/* Any other TCP-style checks */
			bzero(&host->cte, sizeof(host->cte));
			host->last_up = host->up;
			host->cte.host = host;
			host->cte.table = table;
			bcopy(&tv, &host->cte.tv_start,
			    sizeof(host->cte.tv_start));
			check_tcp(&host->cte);
d367 4
a370 3
	struct imsgbuf	*ibuf;
	struct imsg	 imsg;
	ssize_t		 n;
d396 8
d411 1
@


1.20
log
@Second step towards hoststated reload:
First split out hosts, tables and services into to structs, one that
contains the runtime fields and one (inside the runtime) that contains
mostly static fields that will be sent over the socket during reload.

Also move the demoted field of tables inside the flags field as its
just a boolean.
ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hce.c,v 1.19 2007/05/26 19:58:48 pyr Exp $	*/
d88 1
@


1.19
log
@first steps for implementing reload:
	* make parse_config allocate the hoststated function by itself
	* make as many sockets as necessary to talk to the relay children
	* add send_all for talking to all children
with advise and ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hce.c,v 1.18 2007/03/07 17:40:32 reyk Exp $	*/
d153 1
a153 1
			if (!(table->flags & F_SSL))
d188 1
a188 1
		if (table->flags & F_DISABLE)
d190 1
a190 1
		if (table->check == CHECK_NOCHECK)
d196 1
a196 1
			if (table->check == CHECK_ICMP) {
d228 1
a228 1
		    host->name, host->retry_cnt);
d232 1
a232 1
		host->retry_cnt = host->retry;
d238 1
a238 1
	st.id = host->id;
d244 1
a244 1
		log_debug("hce_notify_done: %s (%s)", host->name, msg);
d260 1
a260 1
	if ((table = table_find(env, host->tableid)) == NULL)
d266 2
a267 2
		    host->name, table_check(table->check),
		    (table->flags & F_SSL) ? " use ssl" : "", duration,
d336 1
a336 1
			table->flags |= F_DISABLE;
d344 1
a344 1
			table->flags &= ~(F_DISABLE);
@


1.18
log
@- fix the hoststatectl host disable/enable commands to work with relay
layer 7 loadbalancing.
- allow to run relays with tables without depending on services
- show hosts and tables assigned to relays in hoststatectl show commands

ok pyr@@ deraadt@@ with some input from mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hce.c,v 1.17 2007/03/06 19:37:31 reyk Exp $	*/
d67 1
a67 1
    int pipe_parent2relay[2], int pipe_pfe2hce[2],
a120 2
	close(pipe_parent2relay[0]);
	close(pipe_parent2relay[1]);
d122 2
@


1.17
log
@fix the health checks when using the retry option
@
text
@d1 1
a1 1
/*	$OpenBSD: hce.c,v 1.16 2007/02/22 03:32:39 reyk Exp $	*/
d144 1
a144 1
	if (!TAILQ_EMPTY(&env->services)) {
@


1.16
log
@Add layer 7 functionality to hoststated used for layer 7
loadbalancing, SSL acceleration, general-purpose TCP relaying, and
transparent proxying.

see hoststated.conf(5) and my upcoming article on undeadly.org for
details.

ok to commit deraadt@@ pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hce.c,v 1.15 2007/02/07 15:17:46 reyk Exp $	*/
a225 1

d229 1
a229 1
		host->up = HOST_UP;
@


1.15
log
@add new "log (updates|all)" configuration option to log state
notifications after completed host checks.  either only log the
"updates" to new states or log "all" state notifications, even if the
state didn't change. the log messages will be reported to syslog or to
stderr if the daemon is running in foreground mode.

ok claudio@@ pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hce.c,v 1.14 2007/02/07 14:39:45 reyk Exp $	*/
d67 2
a68 1
	int pipe_pfe2hce[2])
d76 1
d121 6
d144 5
a148 3
	evtimer_set(&env->ev, hce_launch_checks, env);
	bzero(&tv, sizeof(tv));
	evtimer_add(&env->ev, &tv);
d226 13
d241 2
d247 2
a248 1
	if (host->up != host->last_up) {
d250 1
a250 2
		imsg_compose(ibuf_pfe, IMSG_HOST_STATUS, 0, 0, &st, sizeof(st));
	} else
a252 3
	if ((table = table_find(env, host->tableid)) == NULL)
		fatalx("hce_notify_done: invalid table id");

d261 3
d265 2
a266 1
		log_info("host %s, check %s%s (%lums), state %s -> %s",
d269 2
a270 1
		    host_status(host->last_up), host_status(host->up));
d323 2
d371 1
a371 1
		if (n == 0)	/* connection closed */
@


1.14
log
@remove superfluos log_debug() messages

ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hce.c,v 1.13 2007/02/07 13:39:58 reyk Exp $	*/
d210 1
d212 3
d221 1
d223 1
d225 19
a243 1
		host->last_up = host->up;
d245 2
@


1.13
log
@remove unused functions and variables which have been copied from
ospfd(8) (can be re-imported later if required).
@
text
@d1 1
a1 1
/*	$OpenBSD: hce.c,v 1.12 2007/01/29 14:23:31 pyr Exp $	*/
a161 2

	log_debug("hce_launch_checks: scheduled");
@


1.12
log
@Add SSL support to hoststated.
with help and OK reyk@@
with help and advice by claudio@@ and Srebrenko Sehic
@
text
@d1 1
a1 1
/*	$OpenBSD: hce.c,v 1.11 2007/01/24 10:26:00 claudio Exp $	*/
a47 1
int	hce_checks_done(void);
a206 19
}

int
hce_checks_done()
{
	struct table		*table;
	struct host		*host;

	TAILQ_FOREACH(table, &env->tables, entry) {
		if (table->flags & F_DISABLE)
			continue;
		TAILQ_FOREACH(host, &table->hosts, entry) {
			if (host->flags & F_DISABLE)
				continue;
			if (!(host->flags & F_CHECK_DONE))
				return (0);
		}
	}
	return (1);
@


1.11
log
@Similar to ospfd and ripd ignore SIGPIPE in all processes to be able to do
a nice exit in case one of the processes dies. OK pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hce.c,v 1.10 2007/01/11 18:05:08 reyk Exp $	*/
d39 2
d75 1
d140 9
@


1.10
log
@use real async events for checks and improve the non-blocking socket
usage. also modify the check_icmp code to use non-blocking raw sockets
and merge the icmp4 and icmp6 functions. some other minor changes
while i'm here.

as discussed with pyr@@ claudio@@ deraadt@@
ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hce.c,v 1.9 2007/01/09 13:50:11 pyr Exp $	*/
d110 1
@


1.9
log
@Finish renaming hostated to hoststated.
Note to testers: the user the daemon changes its id to is now _hoststated,
don't forget to update master.passwd.
ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hce.c,v 1.8 2007/01/09 00:45:32 deraadt Exp $	*/
a84 6
	/* this is needed for icmp tests */
	if ((env->icmp_sock = socket(AF_INET, SOCK_RAW, IPPROTO_ICMP)) < 0)
		err(1, "socket");
	if ((env->icmp6_sock = socket(AF_INET6, SOCK_RAW, IPPROTO_ICMPV6)) < 0)
		err(1, "socket");

d96 3
a103 4
	env->cie.icmp_sock = env->icmp_sock;
	env->cie.icmp6_sock = env->icmp6_sock;
	env->cie.env = env;

d133 2
a134 2
	evtimer_set(&env->ev, hce_launch_checks, NULL);
	bcopy(&env->interval, &tv, sizeof(tv));
a136 1
	hce_launch_checks(0, 0, NULL);
d149 17
d172 1
a172 7
		if (table->check == CHECK_ICMP) {
			schedule_icmp(&env->cie, table);
			continue;
		}
		/*
		 * tcp type checks follow
		 */
d176 6
d186 2
a187 2
			if (gettimeofday(&host->cte.tv_start, NULL))
				fatal("hce_launch_checks: gettimeofday");
d191 4
a194 1
	check_icmp(&env->cie);
a219 2
	struct timeval		 tv;
	struct table		*table;
d223 1
a223 1
	host->flags |= F_CHECK_DONE;
d225 1
a225 1
		log_debug("hce_notify_done: %s", msg);
a228 17
	}
	/*
	 * check if everything is done, I see no other way than going
	 * through the tree for every host that calls this function.
	 */
	if (hce_checks_done()) {
		/*
		 * notify pfe checks are done and schedule next check
		 */
		imsg_compose(ibuf_pfe, IMSG_SYNC, 0, 0, NULL, 0);
		TAILQ_FOREACH(table, &env->tables, entry) {
			TAILQ_FOREACH(host, &table->hosts, entry)
				host->flags &= ~F_CHECK_DONE;
		}
		bcopy(&env->interval, &tv, sizeof(tv));
		evtimer_add(&env->ev, &tv);
		bzero(&st, sizeof(st));
@


1.8
log
@adapt to rename
@
text
@d1 1
a1 1
/*	$OpenBSD: hce.c,v 1.7 2007/01/08 20:46:18 reyk Exp $	*/
d48 1
a48 1
static struct hostated	*env = NULL;
d65 1
a65 1
hce(struct hostated *x_env, int pipe_parent2pfe[2], int pipe_parent2hce[2],
d91 1
a91 1
	if ((pw = getpwnam(HOSTATED_USER)) == NULL)
d100 1
a100 1
	hostated_process = PROC_HCE;
@


1.7
log
@do NOT use the regexp interface. it is way to complicated, error-prone
and we don't know about all the possible security problems.

change the check send/expect code to use the fnmatch(3) interface
using shell globbing rules instead. this allows simple patterns like
"220 * ESMTP*" or "SSH-[12].??-*".

suggested by deraadt@@ and otto@@
ok Pierre-Yves Ritschard (pyr at spootnik dot org)
@
text
@d1 1
a1 1
/*	$OpenBSD: hce.c,v 1.6 2007/01/08 16:52:58 reyk Exp $	*/
d39 1
a39 1
#include "hostated.h"
@


1.6
log
@the timeout values are not allowed to exceed the global interval (i
figured this out while testing hostated against a stottering spamd
where the send/expect timeout needs be > 10 seconds). also use another
struct timeval to store the interval for easier handling in the code.

ok Pierre-Yves Ritschard (pyr at spootnik dot org)
@
text
@d1 1
a1 1
/*	$OpenBSD: hce.c,v 1.5 2007/01/08 13:37:26 reyk Exp $	*/
a37 1
#include <regex.h>
@


1.5
log
@add a generic send/expect check using regular expression (see
regex(3)).  this allows to define additional checks for other TCP
protocols.

From Pierre-Yves Ritschard (pyr at spootnik dot org)
@
text
@d1 1
a1 1
/*	$OpenBSD: hce.c,v 1.4 2006/12/25 18:12:14 reyk Exp $	*/
d142 1
a142 2
	tv.tv_sec = env->interval;
	tv.tv_usec = 0;
d234 1
a234 2
		tv.tv_sec = env->interval;
		tv.tv_usec = 0;
@


1.4
log
@partial rewrite of the check_* routines to use libevent everywhere
instead of nested select() calls and to handle the non-blocking
sockets properly.

From Pierre-Yves Ritschard (pyr at spootnik dot org)
(with a little help by me)
@
text
@d1 1
a1 1
/*	$OpenBSD: hce.c,v 1.3 2006/12/16 17:48:27 deraadt Exp $	*/
d38 1
@


1.3
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: hce.c,v 1.2 2006/12/16 12:42:14 reyk Exp $	*/
d46 1
d48 1
a48 1
static struct hostated		*env = NULL;
d107 4
a155 1
	int			 previous_up;
a157 2
	struct ctl_status	 st;
	struct timeval		 tv;
d159 33
a191 4
	tv.tv_sec = env->interval;
	tv.tv_usec = 0;
	evtimer_add(&env->ev, &tv);
	bzero(&st, sizeof(st));
d198 35
a232 25
			previous_up = host->up;
			switch (table->check) {
			case CHECK_ICMP:
				host->up = check_icmp(host, env->icmp_sock,
				    env->icmp6_sock, table->timeout);
				break;
			case CHECK_TCP:
				host->up = check_tcp(host, table);
				break;
			case CHECK_HTTP_CODE:
				host->up = check_http_code(host, table);
				break;
			case CHECK_HTTP_DIGEST:
				host->up = check_http_digest(host, table);
				break;
			default:
				fatalx("hce_launch_checks: unknown check type");
				break;
			}
			if (host->up != previous_up) {
				st.id = host->id;
				st.up = host->up;
				imsg_compose(ibuf_pfe, IMSG_HOST_STATUS, 0, 0,
				    &st, sizeof(st));
			}
d234 4
a238 2
	/* tell pfe we're finished */
	imsg_compose(ibuf_pfe, IMSG_SYNC, 0, 0, NULL, 0);
@


1.2
log
@knf, spacing

please note that some editors will replace tabs with multiple spaces
if you cut & paste code from other sections.  please try to keep the
tabs ;).
@
text
@d1 1
a1 1
/*	$OpenBSD: hce.c,v 1.1 2006/12/16 11:45:07 reyk Exp $	*/
d271 1
a271 1
				imsg.hdr.type);
d291 1
a291 1
		if (n == 0)     /* connection closed */
@


1.1
log
@Import hostated, the host status daemon.  This daemon will monitor
remote hosts and dynamically alter pf(4) tables and redirection rules
for active server load balancing.  The daemon has been written by
Pierre-Yves Ritschard (pyr at spootnik.org) and was formerly known as
"slbd".

The daemon is fully functional but it still needs some work and
cleanup so we don't link it to the build yet.  Some TODOs are a
partial rewrite of the check_* routines (use libevent whenever we
can), improvement of the manpages, and general knf and cleanup.

ok deraadt@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d101 4
a104 4
        if (setgroups(1, &pw->pw_gid) ||
            setresgid(pw->pw_gid, pw->pw_gid, pw->pw_gid) ||
            setresuid(pw->pw_uid, pw->pw_uid, pw->pw_uid))
                fatal("hce: can't drop privileges");
d108 26
a133 26
        signal_set(&ev_sigint, SIGINT, hce_sig_handler, NULL);
        signal_set(&ev_sigterm, SIGTERM, hce_sig_handler, NULL);
        signal_add(&ev_sigint, NULL);                           
        signal_add(&ev_sigterm, NULL);

        /* setup pipes */
        close(pipe_pfe2hce[1]);
        close(pipe_parent2hce[0]);    
        close(pipe_parent2pfe[0]);
        close(pipe_parent2pfe[1]);

        if ((ibuf_pfe = calloc(1, sizeof(struct imsgbuf))) == NULL ||
            (ibuf_main = calloc(1, sizeof(struct imsgbuf))) == NULL)
                fatal("hce");
        imsg_init(ibuf_pfe, pipe_pfe2hce[0], hce_dispatch_imsg); 
        imsg_init(ibuf_main, pipe_parent2hce[1], hce_dispatch_parent);          
                                                                     
        ibuf_pfe->events = EV_READ;                                  
        event_set(&ibuf_pfe->ev, ibuf_pfe->fd, ibuf_pfe->events,
                ibuf_pfe->handler, ibuf_pfe);
        event_add(&ibuf_pfe->ev, NULL);

        ibuf_main->events = EV_READ;
        event_set(&ibuf_main->ev, ibuf_main->fd, ibuf_main->events,
                ibuf_main->handler, ibuf_main);
        event_add(&ibuf_main->ev, NULL);
d135 1
a135 1
        evtimer_set(&env->ev, hce_launch_checks, NULL);
d139 1
a139 1
                                                 
d152 2
a153 2
	struct host 		*host;
	struct table 		*table;
d171 1
a171 2
						      env->icmp6_sock,
						      table->timeout);
d190 1
a190 1
					     &st, sizeof(st));
d282 3
a284 3
	struct imsgbuf          *ibuf;
        struct imsg              imsg;
        ssize_t                  n;
d288 13
a300 13
        case EV_READ:
                if ((n = imsg_read(ibuf)) == -1)
                        fatal("hce_dispatch_parent: imsg_read error");
                if (n == 0)     /* connection closed */
                        fatalx("hce_dispatch_parent: pipe closed");
                break;
        case EV_WRITE:
                if (msgbuf_write(&ibuf->w) == -1)
                        fatal("hce_dispatch_parent: msgbuf_write");
                imsg_event_add(ibuf);
                return;
        default:
                fatalx("hce_dispatch_parent: unknown event");
d303 14
a316 14
        for (;;) {
                if ((n = imsg_get(ibuf, &imsg)) == -1)
                        fatal("hce_dispatch_parent: imsg_read error");
                if (n == 0)
                        break;

                switch (imsg.hdr.type) {
                default:
                        log_debug("hce_dispatch_parent: unexpected imsg %d", 
                                imsg.hdr.type);
                        break;
                }
                imsg_free(&imsg);
        }
@

