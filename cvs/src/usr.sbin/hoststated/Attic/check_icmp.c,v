head	1.22;
access;
symbols
	OPENBSD_4_2:1.18.0.2
	OPENBSD_4_2_BASE:1.18
	OPENBSD_4_1:1.14.0.2
	OPENBSD_4_1_BASE:1.14;
locks; strict;
comment	@ * @;


1.22
date	2007.12.07.17.27.07;	author deraadt;	state dead;
branches;
next	1.21;

1.21
date	2007.11.24.17.07.28;	author reyk;	state Exp;
branches;
next	1.20;

1.20
date	2007.10.09.05.38.58;	author pyr;	state Exp;
branches;
next	1.19;

1.19
date	2007.09.28.13.29.56;	author pyr;	state Exp;
branches;
next	1.18;

1.18
date	2007.07.16.21.15.36;	author pyr;	state Exp;
branches;
next	1.17;

1.17
date	2007.07.16.21.14.58;	author pyr;	state Exp;
branches;
next	1.16;

1.16
date	2007.05.31.03.24.05;	author pyr;	state Exp;
branches;
next	1.15;

1.15
date	2007.05.27.20.53.10;	author pyr;	state Exp;
branches;
next	1.14;

1.14
date	2007.02.23.00.28.06;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2007.02.12.10.39.48;	author pyr;	state Exp;
branches;
next	1.12;

1.12
date	2007.01.29.14.23.31;	author pyr;	state Exp;
branches;
next	1.11;

1.11
date	2007.01.12.17.12.58;	author pyr;	state Exp;
branches;
next	1.10;

1.10
date	2007.01.11.18.05.08;	author reyk;	state Exp;
branches;
next	1.9;

1.9
date	2007.01.09.03.32.56;	author reyk;	state Exp;
branches;
next	1.8;

1.8
date	2007.01.09.00.45.32;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2007.01.08.20.46.18;	author reyk;	state Exp;
branches;
next	1.6;

1.6
date	2007.01.08.13.37.26;	author reyk;	state Exp;
branches;
next	1.5;

1.5
date	2007.01.03.09.45.29;	author reyk;	state Exp;
branches;
next	1.4;

1.4
date	2006.12.25.19.05.41;	author reyk;	state Exp;
branches;
next	1.3;

1.3
date	2006.12.25.18.12.14;	author reyk;	state Exp;
branches;
next	1.2;

1.2
date	2006.12.16.11.59.12;	author reyk;	state Exp;
branches;
next	1.1;

1.1
date	2006.12.16.11.45.07;	author reyk;	state Exp;
branches;
next	;


desc
@@


1.22
log
@hoststated/hoststatectl get repository copied (and de-tagged) into
relayd/relayctl.  This is a more suitable place for a daemon that has
grown out of it's initial roots of "monitoring and redirecting services
at various layers", into one that is "a full featured proxy, which
happens to know what is up/down"
@
text
@/*	$OpenBSD: check_icmp.c,v 1.21 2007/11/24 17:07:28 reyk Exp $	*/

/*
 * Copyright (c) 2006 Pierre-Yves Ritschard <pyr@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/queue.h>
#include <sys/socket.h>

#include <net/if.h>
#include <netinet/in_systm.h>
#include <netinet/in.h>
#include <netinet/ip.h>
#include <netinet/ip_icmp.h>
#include <netinet/icmp6.h>
#include <arpa/inet.h>

#include <limits.h>
#include <event.h>
#include <errno.h>
#include <unistd.h>
#include <string.h>
#include <stdlib.h>

#include <openssl/ssl.h>

#include "hoststated.h"

void	icmp_setup(struct hoststated *, struct ctl_icmp_event *, int);
void	check_icmp_add(struct ctl_icmp_event *, int, struct timeval *,
	    void (*)(int, short, void *));
int	icmp_checks_done(struct ctl_icmp_event *);
void	icmp_checks_timeout(struct ctl_icmp_event *, const char *);
void	send_icmp(int, short, void *);
void	recv_icmp(int, short, void *);
int	in_cksum(u_short *, int);

void
icmp_setup(struct hoststated *env, struct ctl_icmp_event *cie, int af)
{
	int proto = IPPROTO_ICMP;

	if (af == AF_INET6)
		proto = IPPROTO_ICMPV6;
	if ((cie->s = socket(af, SOCK_RAW, proto)) < 0)
		fatal("icmp_init: socket");
	session_socket_blockmode(cie->s, BM_NONBLOCK);
	cie->env = env;
	cie->af = af;
}

void
icmp_init(struct hoststated *env)
{
	icmp_setup(env, &env->icmp_send, AF_INET);
	icmp_setup(env, &env->icmp_recv, AF_INET);
	icmp_setup(env, &env->icmp6_send, AF_INET6);
	icmp_setup(env, &env->icmp6_recv, AF_INET6);
	env->id = getpid() & 0xffff;
}

void
schedule_icmp(struct hoststated *env, struct host *host)
{
	host->last_up = host->up;
	host->flags &= ~(F_CHECK_SENT|F_CHECK_DONE);

	if (((struct sockaddr *)&host->conf.ss)->sa_family == AF_INET)
		env->has_icmp = 1;
	else
		env->has_icmp6 = 1;
}

void
check_icmp_add(struct ctl_icmp_event *cie, int flags, struct timeval *start,
    void (*fn)(int, short, void *))
{
	struct timeval	 tv;

	if (start != NULL)
		bcopy(start, &cie->tv_start, sizeof(cie->tv_start));
	bcopy(&cie->env->timeout, &tv, sizeof(tv));
	if (gettimeofday(&cie->tv_start, NULL))
		fatal("check_icmp_add: gettimeofday");
	event_del(&cie->ev);
	event_set(&cie->ev, cie->s, EV_TIMEOUT|flags, fn, cie);
	event_add(&cie->ev, &tv);
}

void
check_icmp(struct hoststated *env, struct timeval *tv)
{
	if (env->has_icmp) {
		check_icmp_add(&env->icmp_recv, EV_READ, tv, recv_icmp);
		check_icmp_add(&env->icmp_send, EV_WRITE, tv, send_icmp);
	}
	if (env->has_icmp6) {
		check_icmp_add(&env->icmp6_recv, EV_READ, tv, recv_icmp);
		check_icmp_add(&env->icmp6_send, EV_WRITE, tv, send_icmp);
	}
}

int
icmp_checks_done(struct ctl_icmp_event *cie)
{
	struct table	*table;
	struct host	*host;

	TAILQ_FOREACH(table, cie->env->tables, entry) {
		if (table->conf.flags & F_DISABLE ||
		    table->conf.check != CHECK_ICMP)
			continue;
		TAILQ_FOREACH(host, &table->hosts, entry) {
			if (((struct sockaddr *)&host->conf.ss)->sa_family !=
			    cie->af)
				continue;
			if (!(host->flags & F_CHECK_DONE))
				return (0);
		}
	}
	return (1);
}

void
icmp_checks_timeout(struct ctl_icmp_event *cie, const char *msg)
{
	struct table	*table;
	struct host	*host;

	TAILQ_FOREACH(table, cie->env->tables, entry) {
		if (table->conf.flags & F_DISABLE ||
		    table->conf.check != CHECK_ICMP)
			continue;
		TAILQ_FOREACH(host, &table->hosts, entry) {
			if (((struct sockaddr *)&host->conf.ss)->sa_family !=
			    cie->af)
				continue;
			if (!(host->flags & F_CHECK_DONE)) {
				host->up = HOST_DOWN;
				hce_notify_done(host, msg);
			}
		}
	}
}

void
send_icmp(int s, short event, void *arg)
{
	struct ctl_icmp_event	*cie = (struct ctl_icmp_event *)arg;
	struct table		*table;
	struct host		*host;
	struct sockaddr		*to;
	struct icmp		*icp;
	struct icmp6_hdr	*icp6;
	ssize_t			 r;
	u_char			 packet[ICMP_BUF_SIZE];
	socklen_t		 slen;
	int			 i = 0;

	if (event == EV_TIMEOUT) {
		icmp_checks_timeout(cie, "send_icmp: timeout");
		return;
	}

	bzero(&packet, sizeof(packet));
	icp = (struct icmp *)packet;
	icp6 = (struct icmp6_hdr *)packet;
	if (cie->af == AF_INET) {
		icp->icmp_type = ICMP_ECHO;
		icp->icmp_code = 0;
		icp->icmp_id = htons(cie->env->id);
		icp->icmp_cksum = 0;
		slen = sizeof(struct sockaddr_in);
	} else {
		icp6->icmp6_type = ICMP6_ECHO_REQUEST;
		icp6->icmp6_code = 0;
		icp6->icmp6_cksum = 0;
		icp6->icmp6_id = htons(cie->env->id);
		slen = sizeof(struct sockaddr_in6);
	}

	TAILQ_FOREACH(table, cie->env->tables, entry) {
		if (table->conf.check != CHECK_ICMP ||
		    table->conf.flags & F_DISABLE)
			continue;
		TAILQ_FOREACH(host, &table->hosts, entry) {
			if (host->flags & (F_DISABLE | F_CHECK_SENT))
				continue;
			if (((struct sockaddr *)&host->conf.ss)->sa_family !=
			    cie->af)
				continue;
			i++;
			to = (struct sockaddr *)&host->conf.ss;
			if (cie->af == AF_INET) {
				icp->icmp_seq = htons(i);
				icp->icmp_cksum = 0;
				memcpy(icp->icmp_data, &host->conf.id,
				    sizeof(host->conf.id));
				icp->icmp_cksum = in_cksum((u_short *)icp,
				    sizeof(packet));
			} else {
				icp6->icmp6_seq = htons(i);
				icp6->icmp6_cksum = 0;
				memcpy(packet + sizeof(*icp6), &host->conf.id,
				    sizeof(host->conf.id));
				icp6->icmp6_cksum = in_cksum((u_short *)icp6,
				    sizeof(packet));
			}

			r = sendto(s, packet, sizeof(packet), 0, to, slen);
			if (r == -1) {
				if (errno == EAGAIN || errno == EINTR)
					goto retry;
				host->flags |= F_CHECK_SENT|F_CHECK_DONE;
				host->up = HOST_DOWN;
			} else if (r != sizeof(packet))
				goto retry;
			host->flags |= F_CHECK_SENT;
		}
	}

	return;

 retry:
	event_again(&cie->ev, s, EV_TIMEOUT|EV_WRITE, send_icmp,
	    &cie->tv_start, &cie->env->timeout, cie);
}

void
recv_icmp(int s, short event, void *arg)
{
	struct ctl_icmp_event	*cie = (struct ctl_icmp_event *)arg;
	u_char			 packet[ICMP_BUF_SIZE];
	socklen_t		 slen;
	struct sockaddr_storage	 ss;
	struct icmp		*icp;
	struct icmp6_hdr	*icp6;
	u_int16_t		 icpid;
	struct host		*host;
	ssize_t			 r;
	objid_t			 id;

	if (event == EV_TIMEOUT) {
		icmp_checks_timeout(cie, NULL);
		return;
	}

	bzero(&packet, sizeof(packet));
	bzero(&ss, sizeof(ss));

	r = recvfrom(s, packet, sizeof(packet), 0,
	    (struct sockaddr *)&ss, &slen);
	if (r == -1 || r != ICMP_BUF_SIZE) {
		if (r == -1 && errno != EAGAIN && errno != EINTR)
			log_debug("recv_icmp: receive error");
		goto retry;
	}

	if (cie->af == AF_INET) {
		icp = (struct icmp *)(packet + sizeof(struct ip));
		icpid = ntohs(icp->icmp_id);
		memcpy(&id, icp->icmp_data, sizeof(id));
	} else {
		icp6 = (struct icmp6_hdr *)packet;
		icpid = ntohs(icp6->icmp6_id);
		memcpy(&id, packet + sizeof(*icp6), sizeof(id));
	}
	if (icpid != cie->env->id)
		goto retry;
	host = host_find(cie->env, id);
	if (host == NULL) {
		log_warn("recv_icmp: ping for unknown host received");
		goto retry;
	}
	if (bcmp(&ss, &host->conf.ss, slen)) {
		log_warnx("recv_icmp: forged icmp packet?");
		goto retry;
	}

	host->up = HOST_UP;
	host->flags |= F_CHECK_DONE;
	hce_notify_done(host, "recv_icmp: done");

	if (icmp_checks_done(cie))
		return;

 retry:
	event_again(&cie->ev, s, EV_TIMEOUT|EV_READ, recv_icmp,
	    &cie->tv_start, &cie->env->timeout, cie);
}

/* in_cksum from ping.c --
 *	Checksum routine for Internet Protocol family headers (C Version)
 *
 * Copyright (c) 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Mike Muuss.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
int
in_cksum(u_short *addr, int len)
{
	int nleft = len;
	u_short *w = addr;
	int sum = 0;
	u_short answer = 0;

	/*
	 * Our algorithm is simple, using a 32 bit accumulator (sum), we add
	 * sequential 16 bit words to it, and at the end, fold back all the
	 * carry bits from the top 16 bits into the lower 16 bits.
	 */
	while (nleft > 1)  {
		sum += *w++;
		nleft -= 2;
	}

	/* mop up an odd byte, if necessary */
	if (nleft == 1) {
		*(u_char *)(&answer) = *(u_char *)w ;
		sum += answer;
	}

	/* add back carry outs from top 16 bits to low 16 bits */
	sum = (sum >> 16) + (sum & 0xffff);	/* add hi 16 to low 16 */
	sum += (sum >> 16);			/* add carry */
	answer = ~sum;				/* truncate to 16 bits */

	return (answer);
}
@


1.21
log
@sort includes, adjust to style(9)
@
text
@d1 1
a1 1
/*	$OpenBSD: check_icmp.c,v 1.20 2007/10/09 05:38:58 pyr Exp $	*/
@


1.20
log
@Do not notify twice about the same timeout in check_icmp, this previously
corrupted statistics.
Found out by Piotr Sikora < piotr@@sikora.nu >.
@
text
@d1 1
a1 1
/*	$OpenBSD: check_icmp.c,v 1.19 2007/09/28 13:29:56 pyr Exp $	*/
d22 2
a23 1
#include <sys/param.h>
a28 1
#include <net/if.h>
d30 1
@


1.19
log
@Correct my mail address.
@
text
@d1 1
a1 1
/*	$OpenBSD: check_icmp.c,v 1.18 2007/07/16 21:15:36 pyr Exp $	*/
d150 1
a150 1
			if (!(host->flags & F_CHECK_DONE))
d152 2
a153 1
			hce_notify_done(host, msg);
@


1.18
log
@typo
also found by Kevin Steves
@
text
@d1 1
a1 1
/*	$OpenBSD: check_icmp.c,v 1.17 2007/07/16 21:14:58 pyr Exp $	*/
d4 1
a4 1
 * Copyright (c) 2006 Pierre-Yves Ritschard <pyr@@spootnik.org>
@


1.17
log
@use fatal and not err, the message would get lost.
found by Kevin Steves <stevesk (at) pobox dot com>
@
text
@d1 1
a1 1
/*	$OpenBSD: check_icmp.c,v 1.16 2007/05/31 03:24:05 pyr Exp $	*/
d223 1
a223 1
				if (errno == EAGAIN && errno == EINTR)
@


1.16
log
@allocate table lists and service lists instead of using static structs.
split the code to start the event loop in two functions.
introduce merge_config which will be used later on.
@
text
@d1 1
a1 1
/*	$OpenBSD: check_icmp.c,v 1.15 2007/05/27 20:53:10 pyr Exp $	*/
a35 1
#include <err.h>
d58 1
a58 1
		err(1, "icmp_init: socket");
@


1.15
log
@Second step towards hoststated reload:
First split out hosts, tables and services into to structs, one that
contains the runtime fields and one (inside the runtime) that contains
mostly static fields that will be sent over the socket during reload.

Also move the demoted field of tables inside the flags field as its
just a boolean.
ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: check_icmp.c,v 1.14 2007/02/23 00:28:06 deraadt Exp $	*/
d122 1
a122 1
	TAILQ_FOREACH(table, &cie->env->tables, entry) {
d143 1
a143 1
	TAILQ_FOREACH(table, &cie->env->tables, entry) {
d194 1
a194 1
	TAILQ_FOREACH(table, &cie->env->tables, entry) {
@


1.14
log
@knf
@
text
@d1 1
a1 1
/*	$OpenBSD: check_icmp.c,v 1.13 2007/02/12 10:39:48 pyr Exp $	*/
d81 1
a81 1
	if (((struct sockaddr *)&host->ss)->sa_family == AF_INET)
d123 2
a124 1
		if (table->flags & F_DISABLE || table->check != CHECK_ICMP)
d127 1
a127 1
			if (((struct sockaddr *)&host->ss)->sa_family !=
d144 2
a145 1
		if (table->flags & F_DISABLE || table->check != CHECK_ICMP)
d148 1
a148 1
			if (((struct sockaddr *)&host->ss)->sa_family !=
d195 2
a196 1
		if (table->check != CHECK_ICMP || table->flags & F_DISABLE)
d201 1
a201 1
			if (((struct sockaddr *)&host->ss)->sa_family !=
d205 1
a205 1
			to = (struct sockaddr *)&host->ss;
d209 2
a210 2
				memcpy(icp->icmp_data, &host->id,
				    sizeof(host->id));
d216 2
a217 2
				memcpy(packet + sizeof(*icp6), &host->id,
				    sizeof(host->id));
d287 1
a287 1
	if (bcmp(&ss, &host->ss, slen)) {
@


1.13
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: check_icmp.c,v 1.12 2007/01/29 14:23:31 pyr Exp $	*/
d359 1
a359 1
	sum = (sum >> 16) + (sum & 0xffff);     /* add hi 16 to low 16 */
@


1.12
log
@Add SSL support to hoststated.
with help and OK reyk@@
with help and advice by claudio@@ and Srebrenko Sehic
@
text
@d1 1
a1 1
/*	$OpenBSD: check_icmp.c,v 1.11 2007/01/12 17:12:58 pyr Exp $	*/
d126 2
a127 1
			if (((struct sockaddr *)&host->ss)->sa_family != cie->af)
d146 2
a147 1
			if (((struct sockaddr *)&host->ss)->sa_family != cie->af)
@


1.11
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: check_icmp.c,v 1.10 2007/01/11 18:05:08 reyk Exp $	*/
d37 2
@


1.10
log
@use real async events for checks and improve the non-blocking socket
usage. also modify the check_icmp code to use non-blocking raw sockets
and merge the icmp4 and icmp6 functions. some other minor changes
while i'm here.

as discussed with pyr@@ claudio@@ deraadt@@
ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: check_icmp.c,v 1.9 2007/01/09 03:32:56 reyk Exp $	*/
d194 2
a195 1
			if (((struct sockaddr *)&host->ss)->sa_family != cie->af)
d256 2
a257 1
	r = recvfrom(s, packet, sizeof(packet), 0, (struct sockaddr *)&ss, &slen);
@


1.9
log
@use the correct buffer sizes.

(this code needs some more work to implement a better icmp handling,
but this will fix a serious bug for now)
@
text
@d1 1
a1 1
/*	$OpenBSD: check_icmp.c,v 1.8 2007/01/09 00:45:32 deraadt Exp $	*/
d36 1
d40 7
a46 6
int	icmp6_checks_done(struct ctl_icmp_event *);
int	icmp4_checks_done(struct ctl_icmp_event *);
void	send_icmp6(struct ctl_icmp_event *, struct host *);
void	send_icmp4(struct ctl_icmp_event *, struct host *);
void	recv_icmp6(int, short, void *);
void	recv_icmp4(int, short, void *);
d50 1
a50 1
schedule_icmp(struct ctl_icmp_event *cie, struct table *table)
d52 26
a77 1
	struct host	*host;
d79 4
a82 11
	TAILQ_FOREACH(host, &table->hosts, entry) {
		if (host->flags & F_DISABLE)
			continue;
		host->last_up = host->up;
		host->flags &= ~F_CHECK_DONE;
		if (((struct sockaddr *)&host->ss)->sa_family == AF_INET) {
			send_icmp4(cie, host);
		} else {
			send_icmp6(cie, host);
		}
	}
d86 2
a87 1
check_icmp(struct ctl_icmp_event *cie)
d89 1
a89 1
	struct timeval	tv;
d91 3
d95 17
a111 8
		fatal("check_icmp: gettimeofday");
	bcopy(&cie->env->timeout, &tv, sizeof(tv));
	if (cie->has_icmp4)
		event_once(cie->icmp_sock, EV_READ|EV_TIMEOUT,
		    recv_icmp4, cie, &tv);
	if (cie->has_icmp6)
		event_once(cie->icmp6_sock, EV_READ|EV_TIMEOUT,
		    recv_icmp6, cie, &tv);
d115 1
a115 1
icmp6_checks_done(struct ctl_icmp_event *cie)
d124 1
a124 2
			if (((struct sockaddr *)&host->ss)->sa_family !=
			    AF_INET6)
d133 2
a134 2
int
icmp4_checks_done(struct ctl_icmp_event *cie)
d143 1
a143 2
			if (((struct sockaddr *)&host->ss)->sa_family !=
			    AF_INET)
d145 3
a147 3
			if (!(host->flags & F_CHECK_DONE)) {
				return (0);
			}
a149 1
	return (1);
d153 1
a153 1
send_icmp6(struct ctl_icmp_event *cie, struct host *host)
d155 3
d159 3
a161 2
	struct icmp6_hdr	*icp;
	ssize_t			 i;
d163 2
d166 2
a167 16
	cie->has_icmp6 = 1;
	to = (struct sockaddr *)&host->ss;
	bzero(&packet, sizeof(packet));
	icp = (struct icmp6_hdr *)packet;
	icp->icmp6_type = ICMP6_ECHO_REQUEST;
	icp->icmp6_code = 0;
	icp->icmp6_seq = 1;
	icp->icmp6_id = getpid() & 0xffff;

	memcpy((packet + sizeof(*icp)), &host->id, sizeof(host->id));

	i = sendto(cie->icmp6_sock, packet, sizeof(packet), 0, to,
	    sizeof(struct sockaddr_in6));
	if (i < 0 || i != sizeof(packet)) {
		host->up = HOST_DOWN;
		hce_notify_done(host, "send_icmp6: cannot send");
a169 9
}

void
send_icmp4(struct ctl_icmp_event *cie, struct host *host)
{
	struct sockaddr	*to;
	struct icmp	*icp;
	ssize_t		 i;
	u_char		 packet[ICMP_BUF_SIZE];
a170 2
	cie->has_icmp4 = 1;
	to = (struct sockaddr *)&host->ss;
d173 13
a185 14
	icp->icmp_type = ICMP_ECHO;
	icp->icmp_code = 0;
	icp->icmp_seq = htons(1);
	icp->icmp_id = htons(getpid() & 0xffff);
	icp->icmp_cksum = 0;

	memcpy(icp->icmp_data, &host->id, sizeof(host->id));
	icp->icmp_cksum = in_cksum((u_short *)icp, sizeof(packet));

	i = sendto(cie->icmp_sock, packet, sizeof(packet), 0, to,
	    sizeof(struct sockaddr_in));
	if (i < 0 || i != sizeof(packet)) {
		host->up = HOST_DOWN;
		hce_notify_done(host, "send_icmp4: cannot send");
a186 1
}
d188 7
a194 22
void
recv_icmp6(int s, short event, void *arg)
{
	struct ctl_icmp_event	*cie = arg;
	u_char			 packet[ICMP_BUF_SIZE];
	socklen_t		 len;
	struct sockaddr_storage	 ss;
	struct icmp6_hdr	*icp;
	struct host		*host;
	struct table		*table;
	ssize_t			 i;
	objid_t			 id;
	struct timeval		 tv;
	struct timeval		 tv_now;

	if (event == EV_TIMEOUT) {
		/*
		 * mark all hosts which have not responded yet as down.
		 */
		TAILQ_FOREACH(table, &cie->env->tables, entry) {
			if (table->check != CHECK_ICMP ||
			    table->flags & F_DISABLE)
d196 16
a211 9
			TAILQ_FOREACH(host, &table->hosts, entry) {
				if (host->flags & F_DISABLE)
					continue;
				if (((struct sockaddr *)&host->ss)->sa_family
				    != AF_INET6)
					continue;
				if (!(host->flags & F_CHECK_DONE)) {
					host->up = HOST_DOWN;
				}
d213 10
a223 1
		return;
d225 6
a230 31
	bzero(&packet, sizeof(packet));
	bzero(&ss, sizeof(ss));
	len = sizeof(struct sockaddr_in6);
	i = recvfrom(s, packet, sizeof(packet), 0, (struct sockaddr *)&ss, &len);
	if (i < 0 || i != sizeof(packet)) {
		log_warn("recv_icmp6: did not receive valid ping");
		return;
	}
	icp = (struct icmp6_hdr *)(packet);
	memcpy(&id, (packet + sizeof(*icp)), sizeof(id));
	host = host_find(cie->env, id);
	if (host == NULL)
		log_warn("recv_icmp6: ping for unknown host received");
	if (bcmp(&ss, &host->ss, len)) {
		log_warnx("recv_icmp6: forged icmp packet ?");
		return;
	}
	if (icp->icmp6_id != (getpid() & 0xffff)) {
		log_warnx("recv_icmp6: did not receive valid ident");
		host->up = HOST_DOWN;
	} else
		host->up = HOST_UP;
	hce_notify_done(host, "recv_icmp6: final");
	if (icmp6_checks_done(cie))
		return;
	if (gettimeofday(&tv_now, NULL))
		fatal("recv_icmp6: gettimeofday");
	bcopy(&cie->env->timeout, &tv, sizeof(tv));
	timersub(&tv_now, &cie->tv_start, &tv_now);
	timersub(&tv, &tv_now, &tv);
	event_once(cie->icmp6_sock, EV_READ|EV_TIMEOUT, recv_icmp6, cie, &tv);
d234 1
a234 1
recv_icmp4(int s, short event, void *arg)
d236 4
a239 1
	socklen_t		 len;
d241 2
a242 2
	struct ctl_icmp_event	*cie = arg;
	u_char			 packet[ICMP_BUF_SIZE];
d244 1
a244 2
	struct table		*table;
	ssize_t			 i;
a245 3
	struct timeval		 tv;
	struct timeval		 tv_now;
	struct sockaddr_storage	 ss;
d248 1
a248 18
		/*
		 * mark all hosts which have not responded yet as down.
		 */
		TAILQ_FOREACH(table, &cie->env->tables, entry) {
			if (table->check != CHECK_ICMP ||
			    table->flags & F_DISABLE)
				continue;
			TAILQ_FOREACH(host, &table->hosts, entry) {
				if (host->flags & F_DISABLE)
					continue;
				if (((struct sockaddr *)&host->ss)->sa_family
				    != AF_INET)
					continue;
				if (!(host->flags & F_CHECK_DONE)) {
					host->up = HOST_DOWN;
				}
			}
		}
a251 1
	len = sizeof(struct sockaddr_in);
d254 16
a269 4
	i = recvfrom(s, packet, sizeof(packet), 0, (struct sockaddr *)&ss, &len);
	if (i < 0 || i != sizeof(packet)) {
		log_warn("recv_icmp4: did not receive valid ping");
		return;
d271 2
a272 3

	icp = (struct icmp *)(packet + sizeof(struct ip));
	memcpy(&id, icp->icmp_data, sizeof(id));
d275 2
a276 2
		log_warnx("recv_icmp4: received ping for unknown host");
		return;
d278 3
a280 3
	if (bcmp(&ss, &host->ss, len)) {
		log_warnx("recv_icmp4: forged icmp packet ?");
		return;
a281 5
	if (ntohs(icp->icmp_id) != (getpid() & 0xffff)) {
		log_warnx("recv_icmp4: did not receive valid ident");
		host->up = HOST_DOWN;
	} else
		host->up = HOST_UP;
d283 1
d285 3
a287 2
	if (icmp4_checks_done(cie)) {
		hce_notify_done(host, "recv_icmp4: all done");
a288 2
	}
	hce_notify_done(host, "recv_icmp4: host");
d290 3
a292 7
	if (gettimeofday(&tv_now, NULL))
		fatal("recv_icmp4: gettimeofday");

	bcopy(&cie->env->timeout, &tv, sizeof(tv));
	timersub(&tv_now, &cie->tv_start, &tv_now);
	timersub(&tv, &tv_now, &tv);
	event_once(cie->icmp_sock, EV_READ|EV_TIMEOUT, recv_icmp4, cie, &tv);
@


1.8
log
@adapt to rename
@
text
@d1 1
a1 1
/*	$OpenBSD: check_icmp.c,v 1.7 2007/01/08 20:46:18 reyk Exp $	*/
d128 1
a128 2
	int			 datalen = (64 - 8);
	u_char			 packet[datalen];
d141 1
a141 1
	i = sendto(cie->icmp6_sock, packet, datalen + 8, 0, to,
d143 1
a143 1
	if (i < 0 || i != datalen + 8) {
d156 1
a156 2
	int		 datalen = (64 - 8);
	u_char		 packet[datalen];
d169 1
a169 1
	icp->icmp_cksum = in_cksum((u_short *)icp, datalen + 8);
d171 1
a171 1
	i = sendto(cie->icmp_sock, packet, datalen + 8, 0, to,
d173 1
a173 1
	if (i < 0 || i != datalen + 8) {
d183 1
a183 2
	int			 datalen = (64 - 8);
	u_char			 packet[datalen];
d218 2
a219 2
	i = recvfrom(s, packet, datalen + 8, 0, (struct sockaddr *)&ss, &len);
	if (i < 0 || i != datalen + 8) {
a250 1
	int			 datalen = (64 - 8);
d254 1
a254 1
	u_char			 packet[datalen];
d288 2
a289 2
	i = recvfrom(s, packet, datalen + 8, 0, (struct sockaddr *)&ss, &len);
	if (i < 0 || i != (datalen + 8)) {
@


1.7
log
@do NOT use the regexp interface. it is way to complicated, error-prone
and we don't know about all the possible security problems.

change the check send/expect code to use the fnmatch(3) interface
using shell globbing rules instead. this allows simple patterns like
"220 * ESMTP*" or "SSH-[12].??-*".

suggested by deraadt@@ and otto@@
ok Pierre-Yves Ritschard (pyr at spootnik dot org)
@
text
@d1 1
a1 1
/*	$OpenBSD: check_icmp.c,v 1.6 2007/01/08 13:37:26 reyk Exp $	*/
d37 1
a37 1
#include "hostated.h"
@


1.6
log
@add a generic send/expect check using regular expression (see
regex(3)).  this allows to define additional checks for other TCP
protocols.

From Pierre-Yves Ritschard (pyr at spootnik dot org)
@
text
@d1 1
a1 1
/*	$OpenBSD: check_icmp.c,v 1.5 2007/01/03 09:45:29 reyk Exp $	*/
a35 1
#include <regex.h>
@


1.5
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: check_icmp.c,v 1.4 2006/12/25 19:05:41 reyk Exp $	*/
d36 1
@


1.4
log
@fix the conversion from milliseconds to struct timeval, which uses
seconds (tv_sec) and microseconds (tv_usec), but the code assumed
seconds and milliseconds...
@
text
@d1 1
a1 1
/*	$OpenBSD: check_icmp.c,v 1.3 2006/12/25 18:12:14 reyk Exp $	*/
d258 1
a258 1
	u_char		 	 packet[datalen];
d288 1
a288 1
	
d318 1
a318 1
		return;	
d321 1
a321 1
	
@


1.3
log
@partial rewrite of the check_* routines to use libevent everywhere
instead of nested select() calls and to handle the non-blocking
sockets properly.

From Pierre-Yves Ritschard (pyr at spootnik dot org)
(with a little help by me)
@
text
@d1 1
a1 1
/*	$OpenBSD: check_icmp.c,v 1.2 2006/12/16 11:59:12 reyk Exp $	*/
d72 2
a73 3
	if (cie->has_icmp4) {
		tv.tv_sec = cie->env->timeout / 1000;
		tv.tv_usec = cie->env->timeout % 1000;
d76 1
a76 4
	}
	if (cie->has_icmp6) {
		tv.tv_sec = cie->env->timeout / 1000;
		tv.tv_usec = cie->env->timeout % 1000;
a78 1
	}
d245 1
a245 2
	tv.tv_sec = cie->env->timeout / 1000;
	tv.tv_usec = cie->env->timeout % 1000;
d324 2
a325 2
	tv.tv_sec = cie->env->timeout / 1000;
	tv.tv_usec = cie->env->timeout % 1000;
@


1.2
log
@knf, add copyright and license for in_cksum() from ping.c
@
text
@d1 1
a1 1
/*	$OpenBSD: check_icmp.c,v 1.1 2006/12/16 11:45:07 reyk Exp $	*/
d35 1
d39 7
a45 3
int check_icmp6(struct host *, int, int);
int check_icmp4(struct host *, int, int);
int in_cksum(u_short *, int);
d47 2
a48 1
int check_icmp(struct host *host, int s, int s6, int timeout)
d50 34
a83 4
	if (host->ss.ss_family == AF_INET)
		return (check_icmp4(host, s, timeout));
	else
		return (check_icmp6(host, s6, timeout));
d86 43
a128 1
int check_icmp6(struct host *host, int s, int timeout)
a131 1
	int			 ident;
a132 1
	int			 cc;
a134 3
	fd_set			 fdset;
	socklen_t		 len;
	struct timeval		 tv;
d136 1
a137 3
	ident = getpid() & 0xFFFF;
	len = sizeof(struct sockaddr_in6);

d143 1
a143 1
	icp->icmp6_id = ident;
d145 1
a145 2
	memset((packet + sizeof(*icp)), 'X', datalen);
	cc = datalen + 8;
d147 6
a152 34
	i = sendto(s, packet, cc, 0, to, len);

	if (i < 0 || i != cc) {
		log_warn("check_icmp6: cannot send ping");
		return (HOST_UNKNOWN);
	}

	tv.tv_sec = timeout / 1000;
	tv.tv_usec = timeout % 1000;
	FD_ZERO(&fdset);
	FD_SET(s, &fdset);
	switch (select(s + 1, &fdset, NULL, NULL, &tv)) {
	case -1:
		if (errno == EINTR) {
			log_warnx("check_icmp6: interrupted");
			return (HOST_UNKNOWN);
		} else
			fatal("check_icmp6: select");
	case 0:
		log_debug("check_icmp6: timeout");
		return (HOST_DOWN);
	default:
		bzero(&packet, sizeof(packet));
		i = recvfrom(s, packet, cc, 0, to, &len);
		if (i < 0 || i != cc) {
			log_warn("check_icmp6: did not receive valid ping");
			return (HOST_DOWN);
		}
		icp = (struct icmp6_hdr *)(packet);
		if (icp->icmp6_id != ident) {
			log_warnx("check_icmp6: did not receive valid ident");
			return (HOST_DOWN);
		}
		break;
a153 1
	return (HOST_UP);
d156 2
a157 1
int check_icmp4(struct host *host, int s, int timeout)
d159 5
a163 10
	struct sockaddr		*to;
	struct icmp		*icp;
	int			 ident;
	ssize_t			 i;
	int			 cc;
	int			 datalen = (64 - 8);
	u_char			 packet[datalen];
	fd_set			 fdset;
	socklen_t		 len;
	struct timeval		 tv;
d165 1
a166 3
	ident = getpid() & 0xFFFF;
	len = sizeof(struct sockaddr_in);

d169 1
a169 1
	icp->icmp_type = htons(ICMP_ECHO);
d172 1
a172 1
	icp->icmp_id = htons(ident);
d175 45
a219 31
	memset(icp->icmp_data, 'X', datalen);
	cc = datalen + 8;
	icp->icmp_cksum = in_cksum((u_short *)icp, cc);

	i = sendto(s, packet, cc, 0, to, len);

	if (i < 0 || i != cc) {
		log_warn("check_icmp4: cannot send ping");
		return (HOST_UNKNOWN);
	}

	tv.tv_sec = timeout / 1000;
	tv.tv_usec = timeout % 1000;
	FD_ZERO(&fdset);
	FD_SET(s, &fdset);
	switch (select(s + 1, &fdset, NULL, NULL, &tv)) {
	case -1:
		if (errno == EINTR) {
			log_warnx("check_icmp4: ping interrupted");
			return (HOST_UNKNOWN);
		} else
			fatal("check_icmp4: select");
	case 0:
		log_debug("check_icmp4: timeout");
		return (HOST_DOWN);
	default:
		bzero(&packet, sizeof(packet));
		i = recvfrom(s, packet, cc, 0, to, &len);
		if (i < 0 || i != cc) {
			log_warn("check_icmp4: did not receive valid ping");
			return (HOST_DOWN);
d221 70
a290 4
		icp = (struct icmp *)(packet + sizeof(struct ip));
		if (ntohs(icp->icmp_id) != ident) {
			log_warnx("check_icmp4: did not receive valid ident");
			return (HOST_DOWN);
d292 33
a324 1
		break;
d326 9
a334 1
	return (HOST_UP);
@


1.1
log
@Import hostated, the host status daemon.  This daemon will monitor
remote hosts and dynamically alter pf(4) tables and redirection rules
for active server load balancing.  The daemon has been written by
Pierre-Yves Ritschard (pyr at spootnik.org) and was formerly known as
"slbd".

The daemon is fully functional but it still needs some work and
cleanup so we don't link it to the build yet.  Some TODOs are a
partial rewrite of the check_* routines (use libevent whenever we
can), improvement of the manpages, and general knf and cleanup.

ok deraadt@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d52 10
a61 10
        struct sockaddr 	*to;
        struct icmp6_hdr	*icp;
        int            		 ident; 
        ssize_t         	 i;
        int             	 cc;
        int             	 datalen = (64 - 8);
        u_char          	 packet[datalen];
        fd_set          	 fdset;
        socklen_t       	 len;
        struct timeval  	 tv;
d84 7
a90 7
        tv.tv_sec = timeout / 1000;
        tv.tv_usec = timeout % 1000;
        FD_ZERO(&fdset);
        FD_SET(s, &fdset);
        switch (select(s + 1, &fdset, NULL, NULL, &tv)) {
        case -1:
                if (errno == EINTR) {
d95 18
a112 18
        case 0:
                log_debug("check_icmp6: timeout");
                return (HOST_DOWN);
        default:
                bzero(&packet, sizeof(packet));
                i = recvfrom(s, packet, cc, 0, to, &len);
                if (i < 0 || i != cc) {
                        log_warn("check_icmp6: did not receive valid ping");
                        return (HOST_DOWN);
                }
                icp = (struct icmp6_hdr *)(packet);
                if (icp->icmp6_id != ident) {
                        log_warnx("check_icmp6: did not receive valid ident");
                        return (HOST_DOWN);
                }
                break;
        }
        return (HOST_UP);
d182 33
a214 1
/* from ping.c */
d218 27
a244 26
        int nleft = len;
        u_short *w = addr;
        int sum = 0;
        u_short answer = 0;

        /*
         * Our algorithm is simple, using a 32 bit accumulator (sum), we add
         * sequential 16 bit words to it, and at the end, fold back all the
         * carry bits from the top 16 bits into the lower 16 bits.
         */
        while (nleft > 1)  {
                sum += *w++;
                nleft -= 2;
        }

        /* mop up an odd byte, if necessary */
        if (nleft == 1) {
                *(u_char *)(&answer) = *(u_char *)w ;
                sum += answer;
        }

        /* add back carry outs from top 16 bits to low 16 bits */
        sum = (sum >> 16) + (sum & 0xffff);     /* add hi 16 to low 16 */
        sum += (sum >> 16);                     /* add carry */
        answer = ~sum;                          /* truncate to 16 bits */
        return(answer);
@

