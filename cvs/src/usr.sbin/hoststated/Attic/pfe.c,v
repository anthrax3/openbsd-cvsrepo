head	1.44;
access;
symbols
	OPENBSD_4_2:1.33.0.2
	OPENBSD_4_2_BASE:1.33
	OPENBSD_4_1:1.19.0.2
	OPENBSD_4_1_BASE:1.19;
locks; strict;
comment	@ * @;


1.44
date	2007.12.07.17.27.07;	author deraadt;	state dead;
branches;
next	1.43;

1.43
date	2007.11.24.17.07.28;	author reyk;	state Exp;
branches;
next	1.42;

1.42
date	2007.11.19.15.31.36;	author reyk;	state Exp;
branches;
next	1.41;

1.41
date	2007.11.15.17.02.01;	author pyr;	state Exp;
branches;
next	1.40;

1.40
date	2007.11.14.15.25.26;	author pyr;	state Exp;
branches;
next	1.39;

1.39
date	2007.10.30.21.04.45;	author reyk;	state Exp;
branches;
next	1.38;

1.38
date	2007.10.19.14.15.14;	author pyr;	state Exp;
branches;
next	1.37;

1.37
date	2007.10.19.12.08.55;	author pyr;	state Exp;
branches;
next	1.36;

1.36
date	2007.09.28.13.29.56;	author pyr;	state Exp;
branches;
next	1.35;

1.35
date	2007.09.27.07.32.50;	author pyr;	state Exp;
branches;
next	1.34;

1.34
date	2007.09.07.08.20.24;	author reyk;	state Exp;
branches;
next	1.33;

1.33
date	2007.06.19.13.06.00;	author pyr;	state Exp;
branches;
next	1.32;

1.32
date	2007.06.19.06.29.20;	author pyr;	state Exp;
branches;
next	1.31;

1.31
date	2007.06.12.15.16.10;	author msf;	state Exp;
branches;
next	1.30;

1.30
date	2007.06.07.07.19.50;	author pyr;	state Exp;
branches;
next	1.29;

1.29
date	2007.05.31.18.24.02;	author pyr;	state Exp;
branches;
next	1.28;

1.28
date	2007.05.31.15.49.26;	author pyr;	state Exp;
branches;
next	1.27;

1.27
date	2007.05.31.03.24.05;	author pyr;	state Exp;
branches;
next	1.26;

1.26
date	2007.05.29.23.42.15;	author pyr;	state Exp;
branches;
next	1.25;

1.25
date	2007.05.29.23.19.18;	author pyr;	state Exp;
branches;
next	1.24;

1.24
date	2007.05.28.22.11.33;	author pyr;	state Exp;
branches;
next	1.23;

1.23
date	2007.05.27.20.53.10;	author pyr;	state Exp;
branches;
next	1.22;

1.22
date	2007.05.26.19.58.49;	author pyr;	state Exp;
branches;
next	1.21;

1.21
date	2007.05.09.13.05.42;	author pyr;	state Exp;
branches;
next	1.20;

1.20
date	2007.03.17.22.46.41;	author reyk;	state Exp;
branches;
next	1.19;

1.19
date	2007.03.07.17.40.32;	author reyk;	state Exp;
branches;
next	1.18;

1.18
date	2007.02.26.16.10.24;	author reyk;	state Exp;
branches;
next	1.17;

1.17
date	2007.02.23.00.28.06;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2007.02.22.05.58.06;	author reyk;	state Exp;
branches;
next	1.15;

1.15
date	2007.02.22.03.32.39;	author reyk;	state Exp;
branches;
next	1.14;

1.14
date	2007.02.08.13.32.24;	author reyk;	state Exp;
branches;
next	1.13;

1.13
date	2007.02.06.11.21.35;	author pyr;	state Exp;
branches;
next	1.12;

1.12
date	2007.02.06.08.46.31;	author pyr;	state Exp;
branches;
next	1.11;

1.11
date	2007.02.06.08.45.46;	author pyr;	state Exp;
branches;
next	1.10;

1.10
date	2007.02.01.20.03.39;	author pyr;	state Exp;
branches;
next	1.9;

1.9
date	2007.01.29.14.23.31;	author pyr;	state Exp;
branches;
next	1.8;

1.8
date	2007.01.24.10.26.00;	author claudio;	state Exp;
branches;
next	1.7;

1.7
date	2007.01.09.13.50.11;	author pyr;	state Exp;
branches;
next	1.6;

1.6
date	2007.01.09.00.45.32;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2007.01.08.20.46.18;	author reyk;	state Exp;
branches;
next	1.4;

1.4
date	2007.01.08.13.37.26;	author reyk;	state Exp;
branches;
next	1.3;

1.3
date	2006.12.16.18.50.33;	author reyk;	state Exp;
branches;
next	1.2;

1.2
date	2006.12.16.12.42.14;	author reyk;	state Exp;
branches;
next	1.1;

1.1
date	2006.12.16.11.45.07;	author reyk;	state Exp;
branches;
next	;


desc
@@


1.44
log
@hoststated/hoststatectl get repository copied (and de-tagged) into
relayd/relayctl.  This is a more suitable place for a daemon that has
grown out of it's initial roots of "monitoring and redirecting services
at various layers", into one that is "a full featured proxy, which
happens to know what is up/down"
@
text
@/*	$OpenBSD: pfe.c,v 1.43 2007/11/24 17:07:28 reyk Exp $	*/

/*
 * Copyright (c) 2006 Pierre-Yves Ritschard <pyr@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/param.h>
#include <sys/stat.h>
#include <sys/socket.h>
#include <sys/un.h>

#include <net/if.h>

#include <errno.h>
#include <event.h>
#include <fcntl.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <pwd.h>

#include <openssl/ssl.h>

#include "hoststated.h"

void	pfe_sig_handler(int sig, short, void *);
void	pfe_shutdown(void);
void	pfe_setup_events(void);
void	pfe_disable_events(void);
void	pfe_dispatch_imsg(int, short, void *);
void	pfe_dispatch_parent(int, short, void *);
void	pfe_dispatch_relay(int, short, void *);

void	pfe_sync(void);

static struct hoststated	*env = NULL;

struct imsgbuf	*ibuf_main;
struct imsgbuf	*ibuf_hce;
struct imsgbuf	*ibuf_relay;

void
pfe_sig_handler(int sig, short event, void *arg)
{
	switch (sig) {
	case SIGINT:
	case SIGTERM:
		pfe_shutdown();
	default:
		fatalx("pfe_sig_handler: unexpected signal");
	}
}

pid_t
pfe(struct hoststated *x_env, int pipe_parent2pfe[2], int pipe_parent2hce[2],
    int pipe_parent2relay[RELAY_MAXPROC][2], int pipe_pfe2hce[2],
    int pipe_pfe2relay[RELAY_MAXPROC][2])
{
	pid_t		 pid;
	struct passwd	*pw;
	struct event	 ev_sigint;
	struct event	 ev_sigterm;
	int		 i;
	size_t		 size;

	switch (pid = fork()) {
	case -1:
		fatal("pfe: cannot fork");
	case 0:
		break;
	default:
		return (pid);
	}

	env = x_env;
	purge_config(env, PURGE_PROTOS);

	if (control_init() == -1)
		fatalx("pfe: control socket setup failed");

	init_filter(env);
	init_tables(env);

	if ((pw = getpwnam(HOSTSTATED_USER)) == NULL)
		fatal("pfe: getpwnam");

#ifndef DEBUG
	if (chroot(pw->pw_dir) == -1)
		fatal("pfe: chroot");
	if (chdir("/") == -1)
		fatal("pfe: chdir(\"/\")");
#else
#warning disabling privilege revocation and chroot in DEBUG mode
#endif

	setproctitle("pf update engine");
	hoststated_process = PROC_PFE;

#ifndef DEBUG
	if (setgroups(1, &pw->pw_gid) ||
	    setresgid(pw->pw_gid, pw->pw_gid, pw->pw_gid) ||
	    setresuid(pw->pw_uid, pw->pw_uid, pw->pw_uid))
		fatal("pfe: cannot drop privileges");
#endif

	event_init();

	signal_set(&ev_sigint, SIGINT, pfe_sig_handler, NULL);
	signal_set(&ev_sigterm, SIGTERM, pfe_sig_handler, NULL);
	signal_add(&ev_sigint, NULL);
	signal_add(&ev_sigterm, NULL);
	signal(SIGPIPE, SIG_IGN);
	signal(SIGHUP, SIG_IGN);

	/* setup pipes */
	close(pipe_pfe2hce[0]);
	close(pipe_parent2pfe[0]);
	close(pipe_parent2hce[0]);
	close(pipe_parent2hce[1]);
	for (i = 0; i < env->prefork_relay; i++) {
		close(pipe_parent2relay[i][0]);
		close(pipe_parent2relay[i][1]);
		close(pipe_pfe2relay[i][0]);
	}

	size = sizeof(struct imsgbuf);
	if ((ibuf_hce = calloc(1, size)) == NULL ||
	    (ibuf_relay = calloc(env->prefork_relay, size)) == NULL ||
	    (ibuf_main = calloc(1, size)) == NULL)
		fatal("pfe");

	imsg_init(ibuf_hce, pipe_pfe2hce[1], pfe_dispatch_imsg);
	imsg_init(ibuf_main, pipe_parent2pfe[1], pfe_dispatch_parent);
	for (i = 0; i < env->prefork_relay; i++)
		imsg_init(&ibuf_relay[i], pipe_pfe2relay[i][1],
		    pfe_dispatch_relay);

	ibuf_main->events = EV_READ;
	event_set(&ibuf_main->ev, ibuf_main->fd, ibuf_main->events,
	    ibuf_main->handler, ibuf_main);
	event_add(&ibuf_main->ev, NULL);

	pfe_setup_events();

	TAILQ_INIT(&ctl_conns);

	if (control_listen(env, ibuf_main, ibuf_hce) == -1)
		fatalx("pfe: control socket listen failed");

	/* Initial sync */
	pfe_sync();

	event_dispatch();
	pfe_shutdown();

	return (0);
}

void
pfe_shutdown(void)
{
	flush_rulesets(env);
	log_info("pf update engine exiting");
	_exit(0);
}

void
pfe_setup_events(void)
{
	int		 i;
	struct imsgbuf	*ibuf;

	ibuf_hce->events = EV_READ;
	event_set(&ibuf_hce->ev, ibuf_hce->fd, ibuf_hce->events,
	    ibuf_hce->handler, ibuf_hce);
	event_add(&ibuf_hce->ev, NULL);

	for (i = 0; i < env->prefork_relay; i++) {
		ibuf = &ibuf_relay[i];

		ibuf->events = EV_READ;
		event_set(&ibuf->ev, ibuf->fd, ibuf->events,
		    ibuf->handler, ibuf);
		event_add(&ibuf->ev, NULL);
	}
}

void
pfe_disable_events(void)
{
	int	i;

	event_del(&ibuf_hce->ev);

	for (i = 0; i < env->prefork_relay; i++)
		event_del(&ibuf_relay[i].ev);
}

void
pfe_dispatch_imsg(int fd, short event, void *ptr)
{
	struct imsgbuf		*ibuf;
	struct imsg		 imsg;
	ssize_t			 n;

	struct host		*host;
	struct table		*table;
	struct ctl_status	 st;

	ibuf = ptr;
	switch (event) {
	case EV_READ:
		if ((n = imsg_read(ibuf)) == -1)
			fatal("pfe_dispatch_imsg: imsg_read_error");
		if (n == 0) {
			/* this pipe is dead, so remove the event handler */
			event_del(&ibuf->ev);
			event_loopexit(NULL);
			return;
		}
		break;
	case EV_WRITE:
		if (msgbuf_write(&ibuf->w) == -1)
			fatal("pfe_dispatch_imsg: msgbuf_write");
		imsg_event_add(ibuf);
		return;
	default:
		fatalx("pfe_dispatch_imsg: unknown event");
	}

	for (;;) {
		if ((n = imsg_get(ibuf, &imsg)) == -1)
			fatal("pfe_dispatch_imsg: imsg_read error");
		if (n == 0)
			break;

		control_imsg_forward(&imsg);
		switch (imsg.hdr.type) {
		case IMSG_HOST_STATUS:
			if (imsg.hdr.len - IMSG_HEADER_SIZE != sizeof(st))
				fatalx("pfe_dispatch_imsg: invalid request");
			memcpy(&st, imsg.data, sizeof(st));
			if ((host = host_find(env, st.id)) == NULL)
				fatalx("pfe_dispatch_imsg: invalid host id");
			if (host->flags & F_DISABLE)
				break;
			host->retry_cnt = st.retry_cnt;
			if (st.up != HOST_UNKNOWN) {
				host->check_cnt++;
				if (st.up == HOST_UP)
					host->up_cnt++;
			}
			if (host->check_cnt != st.check_cnt) {
				log_debug("pfe_dispatch_imsg: host %d => %d",
				    host->conf.id, host->up);
				fatalx("pfe_dispatch_imsg: desynchronized");
			}

			if (host->up == st.up)
				break;

			/* Forward to relay engine(s) */
			for (n = 0; n < env->prefork_relay; n++)
				imsg_compose(&ibuf_relay[n],
				    IMSG_HOST_STATUS, 0, 0, -1, &st,
				    sizeof(st));

			if ((table = table_find(env, host->conf.tableid))
			    == NULL)
				fatalx("pfe_dispatch_imsg: invalid table id");

			log_debug("pfe_dispatch_imsg: state %d for host %u %s",
			    st.up, host->conf.id, host->conf.name);

			/*
			 * Do not change the table state when the host
			 * state switches between UNKNOWN and DOWN.
			 */
			if (HOST_ISUP(st.up)) {
				table->conf.flags |= F_CHANGED;
				table->up++;
				host->flags |= F_ADD;
				host->flags &= ~(F_DEL);
			} else if (HOST_ISUP(host->up)) {
				table->up--;
				table->conf.flags |= F_CHANGED;
				host->flags |= F_DEL;
				host->flags &= ~(F_ADD);
			}

			host->up = st.up;
			break;
		case IMSG_SYNC:
			pfe_sync();
			break;
		default:
			log_debug("pfe_dispatch_imsg: unexpected imsg %d",
			    imsg.hdr.type);
			break;
		}
		imsg_free(&imsg);
	}
	imsg_event_add(ibuf);
}

void
pfe_dispatch_parent(int fd, short event, void * ptr)
{
	struct imsgbuf	*ibuf;
	struct imsg	 imsg;
	ssize_t		 n;

	static struct service	*service = NULL;
	static struct table	*table = NULL;
	struct host		*host;
	struct address		*virt;

	ibuf = ptr;
	switch (event) {
	case EV_READ:
		if ((n = imsg_read(ibuf)) == -1)
			fatal("imsg_read error");
		if (n == 0) {
			/* this pipe is dead, so remove the event handler */
			event_del(&ibuf->ev);
			event_loopexit(NULL);
			return;
		}
		break;
	case EV_WRITE:
		if (msgbuf_write(&ibuf->w) == -1)
			fatal("msgbuf_write");
		imsg_event_add(ibuf);
		return;
	default:
		fatalx("pfe_dispatch_parent: unknown event");
	}

	for (;;) {
		if ((n = imsg_get(ibuf, &imsg)) == -1)
			fatal("pfe_dispatch_parent: imsg_read error");
		if (n == 0)
			break;

		switch (imsg.hdr.type) {
		case IMSG_RECONF:
			log_debug("pfe: reloading configuration");
			if (imsg.hdr.len !=
			    sizeof(struct hoststated) + IMSG_HEADER_SIZE)
				fatalx("corrupted reload data");
			pfe_disable_events();
			purge_config(env, PURGE_SERVICES|PURGE_TABLES);
			merge_config(env, (struct hoststated *)imsg.data);
			/*
			 * no relays when reconfiguring yet.
			 */
			env->relays = NULL;
			env->protos = NULL;

			env->tables = calloc(1, sizeof(*env->tables));
			env->services = calloc(1, sizeof(*env->services));
			if (env->tables == NULL || env->services == NULL)
				fatal(NULL);

			TAILQ_INIT(env->tables);
			TAILQ_INIT(env->services);
			break;
		case IMSG_RECONF_TABLE:
			if ((table = calloc(1, sizeof(*table))) == NULL)
				fatal(NULL);
			memcpy(&table->conf, imsg.data, sizeof(table->conf));
			TAILQ_INIT(&table->hosts);
			TAILQ_INSERT_TAIL(env->tables, table, entry);
			break;
		case IMSG_RECONF_HOST:
			if ((host = calloc(1, sizeof(*host))) == NULL)
				fatal(NULL);
			memcpy(&host->conf, imsg.data, sizeof(host->conf));
			host->tablename = table->conf.name;
			TAILQ_INSERT_TAIL(&table->hosts, host, entry);
			break;
		case IMSG_RECONF_SERVICE:
			if ((service = calloc(1, sizeof(*service))) == NULL)
				fatal(NULL);
			memcpy(&service->conf, imsg.data,
			    sizeof(service->conf));
			service->table = table_find(env,
			     service->conf.table_id);
			if (service->conf.backup_id == EMPTY_TABLE)
				service->backup = &env->empty_table;
			else
				service->backup = table_find(env,
				    service->conf.backup_id);
			if (service->table == NULL || service->backup == NULL)
				fatal("pfe_dispatch_parent:"
				    " corrupted configuration");
			log_debug("pfe_dispatch_parent: service->table: %s",
			    service->table->conf.name);
			log_debug("pfe_dispatch_parent: service->backup: %s",
			    service->backup->conf.name);
			TAILQ_INIT(&service->virts);
			TAILQ_INSERT_TAIL(env->services, service, entry);
			break;
		case IMSG_RECONF_VIRT:
			if ((virt = calloc(1, sizeof(*virt))) == NULL)
				fatal(NULL);
			memcpy(virt, imsg.data, sizeof(*virt));
			TAILQ_INSERT_TAIL(&service->virts, virt, entry);
			break;
		case IMSG_RECONF_END:
			log_warnx("pfe: configuration reloaded");
			pfe_setup_events();
			pfe_sync();
			break;
		default:
			log_debug("pfe_dispatch_parent: unexpected imsg %d",
			    imsg.hdr.type);
			break;
		}
		imsg_free(&imsg);
	}
	imsg_event_add(ibuf);
}

void
pfe_dispatch_relay(int fd, short event, void * ptr)
{
	struct imsgbuf		*ibuf;
	struct imsg		 imsg;
	ssize_t			 n;
	struct ctl_natlook	 cnl;
	struct ctl_stats	 crs;
	struct relay		*rlay;

	ibuf = ptr;
	switch (event) {
	case EV_READ:
		if ((n = imsg_read(ibuf)) == -1)
			fatal("imsg_read error");
		if (n == 0) {
			/* this pipe is dead, so remove the event handler */
			event_del(&ibuf->ev);
			event_loopexit(NULL);
			return;
		}
		break;
	case EV_WRITE:
		if (msgbuf_write(&ibuf->w) == -1)
			fatal("msgbuf_write");
		imsg_event_add(ibuf);
		return;
	default:
		fatalx("unknown event");
	}

	for (;;) {
		if ((n = imsg_get(ibuf, &imsg)) == -1)
			fatal("pfe_dispatch_relay: imsg_read error");
		if (n == 0)
			break;

		switch (imsg.hdr.type) {
		case IMSG_NATLOOK:
			if (imsg.hdr.len != IMSG_HEADER_SIZE + sizeof(cnl))
				fatalx("invalid imsg header len");
			bcopy(imsg.data, &cnl, sizeof(cnl));
			if (cnl.proc > env->prefork_relay)
				fatalx("pfe_dispatch_relay: "
				    "invalid relay proc");
			if (natlook(env, &cnl) != 0)
				cnl.in = -1;
			imsg_compose(&ibuf_relay[cnl.proc], IMSG_NATLOOK, 0, 0,
			    -1, &cnl, sizeof(cnl));
			break;
		case IMSG_STATISTICS:
			if (imsg.hdr.len != IMSG_HEADER_SIZE + sizeof(crs))
				fatalx("invalid imsg header len");
			bcopy(imsg.data, &crs, sizeof(crs));
			if (crs.proc > env->prefork_relay)
				fatalx("pfe_dispatch_relay: "
				    "invalid relay proc");
			if ((rlay = relay_find(env, crs.id)) == NULL)
				fatalx("pfe_dispatch_relay: invalid relay id");
			bcopy(&crs, &rlay->stats[crs.proc], sizeof(crs));
			rlay->stats[crs.proc].interval =
			    env->statinterval.tv_sec;
			break;
		default:
			log_debug("pfe_dispatch_relay: unexpected imsg %d",
			    imsg.hdr.type);
			break;
		}
		imsg_free(&imsg);
	}
	imsg_event_add(ibuf);
}

void
show(struct ctl_conn *c)
{
	struct service	*service;
	struct host	*host;
	struct relay	*rlay;

	if (env->services == NULL)
		goto relays;
	TAILQ_FOREACH(service, env->services, entry) {
		imsg_compose(&c->ibuf, IMSG_CTL_SERVICE, 0, 0, -1,
		    service, sizeof(*service));
		if (service->conf.flags & F_DISABLE)
			continue;

		imsg_compose(&c->ibuf, IMSG_CTL_TABLE, 0, 0, -1,
		    service->table, sizeof(*service->table));
		if (!(service->table->conf.flags & F_DISABLE))
			TAILQ_FOREACH(host, &service->table->hosts, entry)
				imsg_compose(&c->ibuf, IMSG_CTL_HOST, 0, 0, -1,
				    host, sizeof(*host));

		if (service->backup->conf.id == EMPTY_TABLE)
			continue;
		imsg_compose(&c->ibuf, IMSG_CTL_TABLE, 0, 0, -1,
		    service->backup, sizeof(*service->backup));
		if (!(service->backup->conf.flags & F_DISABLE))
			TAILQ_FOREACH(host, &service->backup->hosts, entry)
				imsg_compose(&c->ibuf, IMSG_CTL_HOST, 0, 0, -1,
				    host, sizeof(*host));
	}
relays:
	if (env->relays == NULL)
		goto end;
	TAILQ_FOREACH(rlay, env->relays, entry) {
		rlay->stats[env->prefork_relay].id = EMPTY_ID;
		imsg_compose(&c->ibuf, IMSG_CTL_RELAY, 0, 0, -1,
		    rlay, sizeof(*rlay));
		imsg_compose(&c->ibuf, IMSG_CTL_STATISTICS, 0, 0, -1,
		    &rlay->stats, sizeof(rlay->stats));

		if (rlay->dsttable == NULL)
			continue;
		imsg_compose(&c->ibuf, IMSG_CTL_TABLE, 0, 0, -1,
		    rlay->dsttable, sizeof(*rlay->dsttable));
		if (!(rlay->dsttable->conf.flags & F_DISABLE))
			TAILQ_FOREACH(host, &rlay->dsttable->hosts, entry)
				imsg_compose(&c->ibuf, IMSG_CTL_HOST, 0, 0, -1,
				    host, sizeof(*host));
	}
end:
	imsg_compose(&c->ibuf, IMSG_CTL_END, 0, 0, -1, NULL, 0);
}

void
show_sessions(struct ctl_conn *c)
{
	int		 n, proc, done;
	struct imsg	 imsg;

	for (proc = 0; proc < env->prefork_relay; proc++) {
		/*
		 * Request all the running sessions from the process
		 */
		imsg_compose(&ibuf_relay[proc],
		    IMSG_CTL_SESSION, 0, 0, -1, NULL, 0);
		while (ibuf_relay[proc].w.queued)
			if (msgbuf_write(&ibuf_relay[proc].w) < 0)
				fatalx("write error");

		/*
		 * Wait for the reply and forward the messages to the
		 * control connection.
		 */
		done = 0;
		while (!done) {
			do {
				if ((n = imsg_read(&ibuf_relay[proc])) == -1)
					fatalx("imsg_read error");
			} while (n == -2); /* handle non-blocking I/O */
			while (!done) {
				if ((n = imsg_get(&ibuf_relay[proc],
				    &imsg)) == -1)
					fatalx("imsg_get error");
				if (n == 0)
					break;
				switch (imsg.hdr.type) {
				case IMSG_CTL_SESSION:
					imsg_compose(&c->ibuf,
					    IMSG_CTL_SESSION, proc, 0, -1,
					    imsg.data, sizeof(struct session));
					break;
				case IMSG_CTL_END:
					done = 1;
					break;
				default:
					fatalx("wrong message for session");
					break;
				}
				imsg_free(&imsg);
			}
		}
	}

	imsg_compose(&c->ibuf, IMSG_CTL_END, 0, 0, -1, NULL, 0);
}

int
disable_service(struct ctl_conn *c, struct ctl_id *id)
{
	struct service	*service;

	if (id->id == EMPTY_ID)
		service = service_findbyname(env, id->name);
	else
		service = service_find(env, id->id);
	if (service == NULL)
		return (-1);
	id->id = service->conf.id;

	if (service->conf.flags & F_DISABLE)
		return (0);

	service->conf.flags |= F_DISABLE;
	service->conf.flags &= ~(F_ADD);
	service->conf.flags |= F_DEL;
	service->table->conf.flags |= F_DISABLE;
	log_debug("disable_service: disabled service %d", service->conf.id);
	pfe_sync();
	return (0);
}

int
enable_service(struct ctl_conn *c, struct ctl_id *id)
{
	struct service	*service;
	struct ctl_id	 eid;

	if (id->id == EMPTY_ID)
		service = service_findbyname(env, id->name);
	else
		service = service_find(env, id->id);
	if (service == NULL)
		return (-1);
	id->id = service->conf.id;

	if (!(service->conf.flags & F_DISABLE))
		return (0);

	service->conf.flags &= ~(F_DISABLE);
	service->conf.flags &= ~(F_DEL);
	service->conf.flags |= F_ADD;
	log_debug("enable_service: enabled service %d", service->conf.id);

	bzero(&eid, sizeof(eid));

	/* XXX: we're syncing twice */
	eid.id = service->table->conf.id;
	if (enable_table(c, &eid) == -1)
		return (-1);
	if (service->backup->conf.id == EMPTY_ID)
		return (0);
	eid.id = service->backup->conf.id;
	if (enable_table(c, &eid) == -1)
		return (-1);
	return (0);
}

int
disable_table(struct ctl_conn *c, struct ctl_id *id)
{
	struct table	*table;
	struct service	*service;
	struct host	*host;

	if (id->id == EMPTY_ID)
		table = table_findbyname(env, id->name);
	else
		table = table_find(env, id->id);
	if (table == NULL)
		return (-1);
	id->id = table->conf.id;
	if ((service = service_find(env, table->conf.serviceid)) == NULL)
		fatalx("disable_table: desynchronised");

	if (table->conf.flags & F_DISABLE)
		return (0);
	table->conf.flags |= (F_DISABLE|F_CHANGED);
	table->up = 0;
	TAILQ_FOREACH(host, &table->hosts, entry)
		host->up = HOST_UNKNOWN;
	imsg_compose(ibuf_hce, IMSG_TABLE_DISABLE, 0, 0, -1,
	    &table->conf.id, sizeof(table->conf.id));
	log_debug("disable_table: disabled table %d", table->conf.id);
	pfe_sync();
	return (0);
}

int
enable_table(struct ctl_conn *c, struct ctl_id *id)
{
	struct service	*service;
	struct table	*table;
	struct host	*host;

	if (id->id == EMPTY_ID)
		table = table_findbyname(env, id->name);
	else
		table = table_find(env, id->id);
	if (table == NULL)
		return (-1);
	id->id = table->conf.id;

	if ((service = service_find(env, table->conf.serviceid)) == NULL)
		fatalx("enable_table: desynchronised");

	if (!(table->conf.flags & F_DISABLE))
		return (0);
	table->conf.flags &= ~(F_DISABLE);
	table->conf.flags |= F_CHANGED;
	table->up = 0;
	TAILQ_FOREACH(host, &table->hosts, entry)
		host->up = HOST_UNKNOWN;
	imsg_compose(ibuf_hce, IMSG_TABLE_ENABLE, 0, 0, -1,
	    &table->conf.id, sizeof(table->conf.id));
	log_debug("enable_table: enabled table %d", table->conf.id);
	pfe_sync();
	return (0);
}

int
disable_host(struct ctl_conn *c, struct ctl_id *id)
{
	struct host	*host;
	struct table	*table;
	int		 n;

	if (id->id == EMPTY_ID)
		host = host_findbyname(env, id->name);
	else
		host = host_find(env, id->id);
	if (host == NULL)
		return (-1);
	id->id = host->conf.id;

	if (host->flags & F_DISABLE)
		return (0);

	if (host->up == HOST_UP) {
		if ((table = table_find(env, host->conf.tableid)) == NULL)
			fatalx("disable_host: invalid table id");
		table->up--;
		table->conf.flags |= F_CHANGED;
	}

	host->up = HOST_UNKNOWN;
	host->flags |= F_DISABLE;
	host->flags |= F_DEL;
	host->flags &= ~(F_ADD);
	host->check_cnt = 0;
	host->up_cnt = 0;

	imsg_compose(ibuf_hce, IMSG_HOST_DISABLE, 0, 0, -1,
	    &host->conf.id, sizeof(host->conf.id));
	/* Forward to relay engine(s) */
	for (n = 0; n < env->prefork_relay; n++)
		imsg_compose(&ibuf_relay[n],
		    IMSG_HOST_DISABLE, 0, 0, -1,
		    &host->conf.id, sizeof(host->conf.id));
	log_debug("disable_host: disabled host %d", host->conf.id);
	pfe_sync();
	return (0);
}

int
enable_host(struct ctl_conn *c, struct ctl_id *id)
{
	struct host	*host;
	int		 n;

	if (id->id == EMPTY_ID)
		host = host_findbyname(env, id->name);
	else
		host = host_find(env, id->id);
	if (host == NULL)
		return (-1);
	id->id = host->conf.id;

	if (!(host->flags & F_DISABLE))
		return (0);

	host->up = HOST_UNKNOWN;
	host->flags &= ~(F_DISABLE);
	host->flags &= ~(F_DEL);
	host->flags &= ~(F_ADD);

	imsg_compose(ibuf_hce, IMSG_HOST_ENABLE, 0, 0, -1,
	    &host->conf.id, sizeof (host->conf.id));
	/* Forward to relay engine(s) */
	for (n = 0; n < env->prefork_relay; n++)
		imsg_compose(&ibuf_relay[n],
		    IMSG_HOST_ENABLE, 0, 0, -1,
		    &host->conf.id, sizeof(host->conf.id));
	log_debug("enable_host: enabled host %d", host->conf.id);
	pfe_sync();
	return (0);
}

void
pfe_sync(void)
{
	struct service		*service;
	struct table		*active;
	struct table		*table;
	struct ctl_id		 id;
	struct imsg		 imsg;
	struct ctl_demote	 demote;

	bzero(&id, sizeof(id));
	bzero(&imsg, sizeof(imsg));
	TAILQ_FOREACH(service, env->services, entry) {
		service->conf.flags &= ~(F_BACKUP);
		service->conf.flags &= ~(F_DOWN);

		if (service->conf.flags & F_DISABLE ||
		    (service->table->up == 0 && service->backup->up == 0)) {
			service->conf.flags |= F_DOWN;
			active = NULL;
		} else if (service->table->up == 0 && service->backup->up > 0) {
			service->conf.flags |= F_BACKUP;
			active = service->backup;
			active->conf.flags |=
			    service->table->conf.flags & F_CHANGED;
			active->conf.flags |=
			    service->backup->conf.flags & F_CHANGED;
		} else
			active = service->table;

		if (active != NULL && active->conf.flags & F_CHANGED) {
			id.id = active->conf.id;
			imsg.hdr.type = IMSG_CTL_TABLE_CHANGED;
			imsg.hdr.len = sizeof(id) + IMSG_HEADER_SIZE;
			imsg.data = &id;
			sync_table(env, service, active);
			control_imsg_forward(&imsg);
		}

		if (service->conf.flags & F_DOWN) {
			if (service->conf.flags & F_ACTIVE_RULESET) {
				flush_table(env, service);
				log_debug("pfe_sync: disabling ruleset");
				service->conf.flags &= ~(F_ACTIVE_RULESET);
				id.id = service->conf.id;
				imsg.hdr.type = IMSG_CTL_PULL_RULESET;
				imsg.hdr.len = sizeof(id) + IMSG_HEADER_SIZE;
				imsg.data = &id;
				sync_ruleset(env, service, 0);
				control_imsg_forward(&imsg);
			}
		} else if (!(service->conf.flags & F_ACTIVE_RULESET)) {
			log_debug("pfe_sync: enabling ruleset");
			service->conf.flags |= F_ACTIVE_RULESET;
			id.id = service->conf.id;
			imsg.hdr.type = IMSG_CTL_PUSH_RULESET;
			imsg.hdr.len = sizeof(id) + IMSG_HEADER_SIZE;
			imsg.data = &id;
			sync_ruleset(env, service, 1);
			control_imsg_forward(&imsg);
		}
	}

	TAILQ_FOREACH(table, env->tables, entry) {
		/*
		 * clean up change flag.
		 */
		table->conf.flags &= ~(F_CHANGED);

		/*
		 * handle demotion.
		 */
		if ((table->conf.flags & F_DEMOTE) == 0)
			continue;
		demote.level = 0;
		if (table->up && table->conf.flags & F_DEMOTED) {
			demote.level = -1;
			table->conf.flags &= ~F_DEMOTED;
		}
		else if (!table->up && !(table->conf.flags & F_DEMOTED)) {
			demote.level = 1;
			table->conf.flags |= F_DEMOTED;
		}
		if (demote.level == 0)
			continue;
		log_debug("pfe_sync: demote %d table '%s' group '%s'",
		    demote.level, table->conf.name, table->conf.demote_group);
		(void)strlcpy(demote.group, table->conf.demote_group,
		    sizeof(demote.group));
		imsg_compose(ibuf_main, IMSG_DEMOTE, 0, 0, -1,
		    &demote, sizeof(demote));
	}
}
@


1.43
log
@sort includes, adjust to style(9)
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe.c,v 1.42 2007/11/19 15:31:36 reyk Exp $	*/
@


1.42
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe.c,v 1.41 2007/11/15 17:02:01 pyr Exp $	*/
a18 1
#include <sys/queue.h>
a19 1
#include <sys/types.h>
d23 1
d25 1
@


1.41
log
@Do not insert proto_default inside the dynamically alloced protocol queue.
Handle it as a special case in the one place where it actually matters
instead.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe.c,v 1.40 2007/11/14 15:25:26 pyr Exp $	*/
d278 1
a278 1
				        sizeof(st));
d806 1
a806 1
	imsg_compose(ibuf_hce, IMSG_HOST_ENABLE, 0, 0, -1, 
d886 1
a886 1
		
@


1.40
log
@do go through relays when none exist.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe.c,v 1.39 2007/10/30 21:04:45 reyk Exp $	*/
d364 1
a364 1
			purge_config(env, PURGE_EVERYTHING);
d366 5
@


1.39
log
@untangle a mess in the state update logic
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe.c,v 1.38 2007/10/19 14:15:14 pyr Exp $	*/
d512 2
d536 3
d555 1
a555 1

@


1.38
log
@Move relays from static TAILQs to allocated ones.
This syncs it with other hoststated entities and will make reload easier.
This is step 1 out of 7 for reload.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe.c,v 1.37 2007/10/19 12:08:55 pyr Exp $	*/
d287 5
a291 7
			if ((st.up == HOST_UNKNOWN && !HOST_ISUP(host->up)) ||
			    (!HOST_ISUP(st.up) && host->up == HOST_UNKNOWN)) {
				host->up = st.up;
				break;
			}

			if (st.up == HOST_UP) {
d296 1
a296 2
				host->up = HOST_UP;
			} else {
d302 1
@


1.37
log
@Add the ability to schedule an immediate check through hoststatectl.
Especially useful when interval is rather long.
I was supposed to commit this before 4.2.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe.c,v 1.36 2007/09/28 13:29:56 pyr Exp $	*/
d536 1
a536 1
	TAILQ_FOREACH(rlay, &env->relays, entry) {
@


1.36
log
@Correct my mail address.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe.c,v 1.35 2007/09/27 07:32:50 pyr Exp $	*/
d159 1
a159 1
	if (control_listen(env, ibuf_main) == -1)
@


1.35
log
@Do not clear the changed flag to early, which prevented a table
from being used by several services.
``looks fine'' reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe.c,v 1.34 2007/09/07 08:20:24 reyk Exp $	*/
d4 1
a4 1
 * Copyright (c) 2006 Pierre-Yves Ritschard <pyr@@spootnik.org>
@


1.34
log
@add an interface to dump running relay sessions to the control socket
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe.c,v 1.33 2007/06/19 13:06:00 pyr Exp $	*/
a848 3
		service->table->conf.flags &= ~(F_CHANGED);
		service->backup->conf.flags &= ~(F_CHANGED);

d874 8
@


1.33
log
@don't go through the effort of creating a SIGHUP handler through
libevent just to ignore it, use SIG_IGN instead.
this syncs hoststated with bgpd and (soon) ospfd.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe.c,v 1.32 2007/06/19 06:29:20 pyr Exp $	*/
d556 52
@


1.32
log
@Do not fatal out with ``pipe closed'' when a short read occurs on one
of our socket pairs. Instead disable listening on the pipe, terminate the
event loop, and let the parent process's SIGCHLD handler do a clean
shutdown.

from an ospfd diff by claudio, ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe.c,v 1.31 2007/06/12 15:16:10 msf Exp $	*/
a60 3
	case SIGHUP:
		/* nothing */
		break;
a74 1
	struct event	 ev_sighup;
a121 1
	signal_set(&ev_sighup, SIGHUP, pfe_sig_handler, NULL);
a123 1
	signal_add(&ev_sighup, NULL);
d125 1
@


1.31
log
@put the fd passing from bgpd back in to hoststated's version of imsg,
needed for layer 7 reload support.

ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe.c,v 1.30 2007/06/07 07:19:50 pyr Exp $	*/
d232 6
a237 2
		if (n == 0)
			fatalx("pfe_dispatch_imsg: pipe closed");
d342 6
a347 2
		if (n == 0)
			fatalx("pfe_dispatch_parent: pipe closed");
d454 6
a459 2
		if (n == 0)
			fatalx("pfe_dispatch_relay: pipe closed");
@


1.30
log
@(finally) Enable reload support for layer 3 configurations.
Hoststated can be reloaded either by sending SIGHUP to the parent process
or by using ``hoststatectl reload''
discussed and ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe.c,v 1.29 2007/05/31 18:24:02 pyr Exp $	*/
d278 2
a279 1
				    IMSG_HOST_STATUS, 0, 0, &st, sizeof(st));
d475 1
a475 1
			    &cnl, sizeof(cnl));
d508 1
a508 1
		imsg_compose(&c->ibuf, IMSG_CTL_SERVICE, 0, 0,
d513 1
a513 1
		imsg_compose(&c->ibuf, IMSG_CTL_TABLE, 0, 0,
d517 1
a517 1
				imsg_compose(&c->ibuf, IMSG_CTL_HOST, 0, 0,
d522 1
a522 1
		imsg_compose(&c->ibuf, IMSG_CTL_TABLE, 0, 0,
d526 1
a526 1
				imsg_compose(&c->ibuf, IMSG_CTL_HOST, 0, 0,
d531 1
a531 1
		imsg_compose(&c->ibuf, IMSG_CTL_RELAY, 0, 0,
d533 1
a533 1
		imsg_compose(&c->ibuf, IMSG_CTL_STATISTICS, 0, 0,
d538 1
a538 1
		imsg_compose(&c->ibuf, IMSG_CTL_TABLE, 0, 0,
d542 1
a542 1
				imsg_compose(&c->ibuf, IMSG_CTL_HOST, 0, 0,
d546 1
a546 1
	imsg_compose(&c->ibuf, IMSG_CTL_END, 0, 0, NULL, 0);
d634 1
a634 1
	imsg_compose(ibuf_hce, IMSG_TABLE_DISABLE, 0, 0,
d666 1
a666 1
	imsg_compose(ibuf_hce, IMSG_TABLE_ENABLE, 0, 0,
d705 1
a705 1
	imsg_compose(ibuf_hce, IMSG_HOST_DISABLE, 0, 0,
d710 1
a710 1
		    IMSG_HOST_DISABLE, 0, 0,
d739 1
a739 1
	imsg_compose(ibuf_hce, IMSG_HOST_ENABLE, 0, 0,
d744 1
a744 1
		    IMSG_HOST_ENABLE, 0, 0,
d835 1
a835 1
		imsg_compose(ibuf_main, IMSG_DEMOTE, 0, 0,
@


1.29
log
@simplify pfe_disable_events
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe.c,v 1.28 2007/05/31 15:49:26 pyr Exp $	*/
d61 3
d78 1
d108 2
d126 1
d129 1
d327 5
d356 64
@


1.28
log
@split pfe's event registration in separate functions (like for hce)
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe.c,v 1.27 2007/05/31 03:24:05 pyr Exp $	*/
d200 1
a200 2
	int		 i;
	struct imsgbuf	*ibuf;
d204 2
a205 4
	for (i = 0; i < env->prefork_relay; i++) {
		ibuf = &ibuf_relay[i];
		event_del(&ibuf->ev);
	}
@


1.27
log
@allocate table lists and service lists instead of using static structs.
split the code to start the event loop in two functions.
introduce merge_config which will be used later on.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe.c,v 1.26 2007/05/29 23:42:15 pyr Exp $	*/
d40 2
a75 1
	struct imsgbuf	*ibuf;
d99 1
d104 1
d109 1
d114 1
d140 1
d143 3
a145 5

	ibuf_hce->events = EV_READ;
	event_set(&ibuf_hce->ev, ibuf_hce->fd, ibuf_hce->events,
	    ibuf_hce->handler, ibuf_hce);
	event_add(&ibuf_hce->ev, NULL);
d152 1
a152 9
	for (i = 0; i < env->prefork_relay; i++) {
		ibuf = &ibuf_relay[i];
		imsg_init(ibuf, pipe_pfe2relay[i][1], pfe_dispatch_relay);

		ibuf->events = EV_READ;
		event_set(&ibuf->ev, ibuf->fd, ibuf->events,
		    ibuf->handler, ibuf);
		event_add(&ibuf->ev, NULL);
	}
d174 35
@


1.26
log
@when the time comes, let pfe_dispatch_parent be able to service more
than one message.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe.c,v 1.25 2007/05/29 23:19:18 pyr Exp $	*/
d401 1
a401 1
	TAILQ_FOREACH(service, &env->services, entry) {
d657 1
a657 1
	TAILQ_FOREACH(service, &env->services, entry) {
d711 1
a711 1
	TAILQ_FOREACH(table, &env->tables, entry) {
@


1.25
log
@allow the control handling code to send messages back to the parent.
forward IMSG_CTL_RELOAD which ends up not doing anything for now.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe.c,v 1.24 2007/05/28 22:11:33 pyr Exp $	*/
d322 1
@


1.24
log
@another small step towards hoststated reloading.
allow purging of parts of the hoststated environment structure.
start using this function now to only keep vital information in
hoststated children processes.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe.c,v 1.23 2007/05/27 20:53:10 pyr Exp $	*/
d160 1
a160 1
	if (control_listen() == -1)
@


1.23
log
@Second step towards hoststated reload:
First split out hosts, tables and services into to structs, one that
contains the runtime fields and one (inside the runtime) that contains
mostly static fields that will be sent over the socket during reload.

Also move the demoted field of tables inside the flags field as its
just a boolean.
ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe.c,v 1.22 2007/05/26 19:58:49 pyr Exp $	*/
d87 1
@


1.22
log
@first steps for implementing reload:
	* make parse_config allocate the hoststated function by itself
	* make as many sockets as necessary to talk to the relay children
	* add send_all for talking to all children
with advise and ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe.c,v 1.21 2007/05/09 13:05:42 pyr Exp $	*/
d231 1
a231 1
				    host->id, host->up);
d243 2
a244 1
			if ((table = table_find(env, host->tableid)) == NULL)
d248 1
a248 1
			    st.up, host->id, host->name);
d257 1
a257 1
				table->flags |= F_CHANGED;
d264 1
a264 1
				table->flags |= F_CHANGED;
d402 1
a402 1
		if (service->flags & F_DISABLE)
d407 1
a407 1
		if (!(service->table->flags & F_DISABLE))
d412 1
a412 1
		if (service->backup->id == EMPTY_TABLE)
d416 1
a416 1
		if (!(service->backup->flags & F_DISABLE))
d432 1
a432 1
		if (!(rlay->dsttable->flags & F_DISABLE))
d453 1
a453 1
	id->id = service->id;
d455 1
a455 1
	if (service->flags & F_DISABLE)
d458 5
a462 5
	service->flags |= F_DISABLE;
	service->flags &= ~(F_ADD);
	service->flags |= F_DEL;
	service->table->flags |= F_DISABLE;
	log_debug("disable_service: disabled service %d", service->id);
d479 1
a479 1
	id->id = service->id;
d481 1
a481 1
	if (!(service->flags & F_DISABLE))
d484 4
a487 4
	service->flags &= ~(F_DISABLE);
	service->flags &= ~(F_DEL);
	service->flags |= F_ADD;
	log_debug("enable_service: enabled service %d", service->id);
d492 1
a492 1
	eid.id = service->table->id;
d495 1
a495 1
	if (service->backup->id == EMPTY_ID)
d497 1
a497 1
	eid.id = service->backup->id;
d516 2
a517 2
	id->id = table->id;
	if ((service = service_find(env, table->serviceid)) == NULL)
d520 1
a520 1
	if (table->flags & F_DISABLE)
d522 1
a522 1
	table->flags |= (F_DISABLE|F_CHANGED);
d527 2
a528 2
	    &table->id, sizeof(table->id));
	log_debug("disable_table: disabled table %d", table->id);
d546 1
a546 1
	id->id = table->id;
d548 1
a548 1
	if ((service = service_find(env, table->serviceid)) == NULL)
d551 1
a551 1
	if (!(table->flags & F_DISABLE))
d553 2
a554 2
	table->flags &= ~(F_DISABLE);
	table->flags |= F_CHANGED;
d559 2
a560 2
	    &table->id, sizeof(table->id));
	log_debug("enable_table: enabled table %d", table->id);
d578 1
a578 1
	id->id = host->id;
d584 1
a584 1
		if ((table = table_find(env, host->tableid)) == NULL)
d587 1
a587 1
		table->flags |= F_CHANGED;
d598 1
a598 1
	    &host->id, sizeof(host->id));
d602 3
a604 2
		    IMSG_HOST_DISABLE, 0, 0, &host->id, sizeof(host->id));
	log_debug("disable_host: disabled host %d", host->id);
d621 1
a621 1
	id->id = host->id;
d632 1
a632 1
	    &host->id, sizeof (host->id));
d636 3
a638 2
		    IMSG_HOST_ENABLE, 0, 0, &host->id, sizeof(host->id));
	log_debug("enable_host: enabled host %d", host->id);
d656 2
a657 2
		service->flags &= ~(F_BACKUP);
		service->flags &= ~(F_DOWN);
d659 1
a659 1
		if (service->flags & F_DISABLE ||
d661 1
a661 1
			service->flags |= F_DOWN;
d664 1
a664 1
			service->flags |= F_BACKUP;
d666 4
a669 2
			active->flags |= service->table->flags & F_CHANGED;
			active->flags |= service->backup->flags & F_CHANGED;
d673 2
a674 2
		if (active != NULL && active->flags & F_CHANGED) {
			id.id = active->id;
d682 2
a683 2
		service->table->flags &= ~(F_CHANGED);
		service->backup->flags &= ~(F_CHANGED);
d685 2
a686 2
		if (service->flags & F_DOWN) {
			if (service->flags & F_ACTIVE_RULESET) {
d689 2
a690 2
				service->flags &= ~(F_ACTIVE_RULESET);
				id.id = service->id;
d697 1
a697 1
		} else if (!(service->flags & F_ACTIVE_RULESET)) {
d699 2
a700 2
			service->flags |= F_ACTIVE_RULESET;
			id.id = service->id;
d710 1
a710 1
		if ((table->flags & F_DEMOTE) == 0)
d713 1
a713 1
		if (table->up && table->demoted) {
d715 1
a715 1
			table->demoted = 0;
d717 1
a717 1
		else if (!table->up && !table->demoted) {
d719 1
a719 1
			table->demoted = 1;
d724 2
a725 2
		    demote.level, table->name, table->demote_group);
		(void)strlcpy(demote.group, table->demote_group,
@


1.21
log
@fix potential NULL deref.
spotted by Ching-Feng Wang <cfw at telepaq.com>.
ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe.c,v 1.20 2007/03/17 22:46:41 reyk Exp $	*/
d66 1
a66 1
    int pipe_parent2relay[2], int pipe_pfe2hce[2],
d123 3
a125 3
	close(pipe_parent2relay[0]);
	close(pipe_parent2relay[1]);
	for (i = 0; i < env->prefork_relay; i++)
d127 1
@


1.20
log
@fix a bug in the initial setup of the pfe2relay communication sockets
which prevented the pfe to accept statistics updates and natlookups
from any other process then the first one. in other words, this will
show you the total relay statistics off _all_ preforked processes
(hoststatectl show relays) and it will unbreak the natlookup mode with
more than one running relay process.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe.c,v 1.19 2007/03/07 17:40:32 reyk Exp $	*/
a448 1
	id->id = service->id;
d451 1
a474 1
	id->id = service->id;
d477 1
a511 1
	id->id = table->id;
d514 1
a541 1
	id->id = table->id;
d544 1
a573 1
	id->id = host->id;
d576 1
a615 1
	id->id = host->id;
d618 1
@


1.19
log
@- fix the hoststatectl host disable/enable commands to work with relay
layer 7 loadbalancing.
- allow to run relays with tables without depending on services
- show hosts and tables assigned to relays in hoststatectl show commands

ok pyr@@ deraadt@@ with some input from mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe.c,v 1.18 2007/02/26 16:10:24 reyk Exp $	*/
d75 1
d128 4
a131 3
	if ((ibuf_hce = calloc(1, sizeof(struct imsgbuf))) == NULL ||
	    (ibuf_relay = calloc(i, sizeof(struct imsgbuf))) == NULL ||
	    (ibuf_main = calloc(1, sizeof(struct imsgbuf))) == NULL)
d150 1
a150 1
		ibuf_relay->events = EV_READ;
d359 3
@


1.18
log
@handle strlcpy return values, make lint happy
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe.c,v 1.17 2007/02/23 00:28:06 deraadt Exp $	*/
d218 2
a219 1

d420 9
d563 1
d592 4
d605 1
d625 4
@


1.17
log
@knf
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe.c,v 1.16 2007/02/22 05:58:06 reyk Exp $	*/
d694 1
a694 1
		strlcpy(demote.group, table->demote_group,
@


1.16
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe.c,v 1.15 2007/02/22 03:32:39 reyk Exp $	*/
d321 1
a321 1
	struct imsgbuf          *ibuf;
@


1.15
log
@Add layer 7 functionality to hoststated used for layer 7
loadbalancing, SSL acceleration, general-purpose TCP relaying, and
transparent proxying.

see hoststated.conf(5) and my upcoming article on undeadly.org for
details.

ok to commit deraadt@@ pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe.c,v 1.14 2007/02/08 13:32:24 reyk Exp $	*/
d236 2
a237 2
				imsg_compose(&ibuf_relay[n], IMSG_HOST_STATUS, 0, 0,
				    &st, sizeof(st));
d366 2
a367 1
				fatalx("pfe_dispatch_relay: invalid relay proc");
d620 2
a621 2
	struct ctl_id	 	 id;
	struct imsg	 	 imsg;
@


1.14
log
@carefully check some return values and make lint happier.  never pass
any truncated strings (table names/anchors/tags/...) to pf and the
kernel.

ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe.c,v 1.13 2007/02/06 11:21:35 pyr Exp $	*/
d42 1
d50 1
d66 2
a67 1
	int pipe_pfe2hce[2])
d73 2
d122 4
d128 1
d144 10
d159 3
d218 8
a225 1
			if (host->up == st.up) {
d231 8
d245 2
a246 2
			if ((st.up == HOST_UNKNOWN && host->up == HOST_DOWN) ||
			    (st.up == HOST_DOWN && host->up == HOST_UNKNOWN)) {
d256 1
d290 1
a290 1
		if (n == 0)     /* connection closed */
d319 65
d388 1
d412 8
d575 2
d616 6
a621 4
	struct service	*service;
	struct table	*active;
	struct ctl_id	 id;
	struct imsg	 imsg;
d675 22
@


1.13
log
@fix a bug when enabling a service that has no backup table.
ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe.c,v 1.12 2007/02/06 08:46:31 pyr Exp $	*/
d135 3
a137 1
	control_listen();
@


1.12
log
@remove an unused variable.
ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe.c,v 1.11 2007/02/06 08:45:46 pyr Exp $	*/
d362 2
@


1.11
log
@inform hoststatectl monitor of ruleset changes and table syncs.
ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe.c,v 1.10 2007/02/01 20:03:39 pyr Exp $	*/
a498 1
	int		 backup;
a504 1
		backup = (service->flags & F_BACKUP);
@


1.10
log
@add a monitor mode to hoststatectl to continuously report changes in
hoststated.
ok reyk@@, "looks nice and clean" niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe.c,v 1.9 2007/01/29 14:23:31 pyr Exp $	*/
d500 2
d503 2
d522 5
a526 1
		if (active != NULL && active->flags & F_CHANGED)
d528 2
d539 4
d544 1
d549 4
d554 1
@


1.9
log
@Add SSL support to hoststated.
with help and OK reyk@@
with help and advice by claudio@@ and Srebrenko Sehic
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe.c,v 1.8 2007/01/24 10:26:00 claudio Exp $	*/
d185 1
d318 1
d344 1
d379 1
d409 1
d440 1
d475 1
@


1.8
log
@Similar to ospfd and ripd ignore SIGPIPE in all processes to be able to do
a nice exit in case one of the processes dies. OK pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe.c,v 1.7 2007/01/09 13:50:11 pyr Exp $	*/
d33 2
@


1.7
log
@Finish renaming hostated to hoststated.
Note to testers: the user the daemon changes its id to is now _hoststated,
don't forget to update master.passwd.
ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe.c,v 1.6 2007/01/09 00:45:32 deraadt Exp $	*/
d108 1
@


1.6
log
@adapt to rename
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe.c,v 1.5 2007/01/08 20:46:18 reyk Exp $	*/
d43 1
a43 1
static struct hostated	*env = NULL;
d61 1
a61 1
pfe(struct hostated *x_env, int pipe_parent2pfe[2], int pipe_parent2hce[2],
d86 1
a86 1
	if ((pw = getpwnam(HOSTATED_USER)) == NULL)
d95 1
a95 1
	hostated_process = PROC_PFE;
@


1.5
log
@do NOT use the regexp interface. it is way to complicated, error-prone
and we don't know about all the possible security problems.

change the check send/expect code to use the fnmatch(3) interface
using shell globbing rules instead. this allows simple patterns like
"220 * ESMTP*" or "SSH-[12].??-*".

suggested by deraadt@@ and otto@@
ok Pierre-Yves Ritschard (pyr at spootnik dot org)
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe.c,v 1.4 2007/01/08 13:37:26 reyk Exp $	*/
d34 1
a34 1
#include "hostated.h"
@


1.4
log
@add a generic send/expect check using regular expression (see
regex(3)).  this allows to define additional checks for other TCP
protocols.

From Pierre-Yves Ritschard (pyr at spootnik dot org)
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe.c,v 1.3 2006/12/16 18:50:33 reyk Exp $	*/
a32 1
#include <regex.h>
@


1.3
log
@- allow to use host/service/table names instead of Ids in hostatectl.
- minor change of the "hostatectl show" command output
- increase the max service and tag names (max pf tag name size is 64 now!)

thanks to pyr who found a bug in my initial diff
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe.c,v 1.2 2006/12/16 12:42:14 reyk Exp $	*/
d33 1
@


1.2
log
@knf, spacing

please note that some editors will replace tabs with multiple spaces
if you cut & paste code from other sections.  please try to keep the
tabs ;).
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe.c,v 1.1 2006/12/16 11:45:07 reyk Exp $	*/
d306 1
a306 1
disable_service(struct ctl_conn *c, objid_t id)
d310 5
a314 1
	if ((service = service_find(env, id)) == NULL)
d330 1
a330 1
enable_service(struct ctl_conn *c, objid_t id)
d333 1
d335 5
a339 1
	if ((service = service_find(env, id)) == NULL)
d350 2
d353 2
a354 1
	if (enable_table(c, service->table->id))
d356 2
a357 1
	if (enable_table(c, service->backup->id))
d363 1
a363 1
disable_table(struct ctl_conn *c, objid_t id)
d369 5
a373 3
	if (id == EMPTY_TABLE)
		return (-1);
	if ((table = table_find(env, id)) == NULL)
d384 2
a385 1
	imsg_compose(ibuf_hce, IMSG_TABLE_DISABLE, 0, 0, &id, sizeof(id));
d392 1
a392 1
enable_table(struct ctl_conn *c, objid_t id)
d398 5
a402 3
	if (id == EMPTY_TABLE)
		return (-1);
	if ((table = table_find(env, id)) == NULL)
d404 1
d415 2
a416 1
	imsg_compose(ibuf_hce, IMSG_TABLE_ENABLE, 0, 0, &id, sizeof(id));
d423 1
a423 1
disable_host(struct ctl_conn *c, objid_t id)
d428 5
a432 1
	if ((host = host_find(env, id)) == NULL)
d450 2
a451 1
	imsg_compose(ibuf_hce, IMSG_HOST_DISABLE, 0, 0, &id, sizeof (id));
d458 1
a458 1
enable_host(struct ctl_conn *c, objid_t id)
d462 5
a466 1
	if ((host = host_find(env, id)) == NULL)
d477 2
a478 1
	imsg_compose(ibuf_hce, IMSG_HOST_ENABLE, 0, 0, &id, sizeof (id));
@


1.1
log
@Import hostated, the host status daemon.  This daemon will monitor
remote hosts and dynamically alter pf(4) tables and redirection rules
for active server load balancing.  The daemon has been written by
Pierre-Yves Ritschard (pyr at spootnik.org) and was formerly known as
"slbd".

The daemon is fully functional but it still needs some work and
cleanup so we don't link it to the build yet.  Some TODOs are a
partial rewrite of the check_* routines (use libevent whenever we
can), improvement of the manpages, and general knf and cleanup.

ok deraadt@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d97 4
a100 4
        if (setgroups(1, &pw->pw_gid) ||
            setresgid(pw->pw_gid, pw->pw_gid, pw->pw_gid) ||
            setresuid(pw->pw_uid, pw->pw_uid, pw->pw_uid))
                fatal("pfe: cannot drop privileges");
d118 2
a119 2
	imsg_init(ibuf_hce, pipe_pfe2hce[1], pfe_dispatch_imsg); 
	imsg_init(ibuf_main, pipe_parent2pfe[1], pfe_dispatch_parent); 
d123 1
a123 1
		ibuf_hce->handler, ibuf_hce);
d128 1
a128 1
		ibuf_main->handler, ibuf_main);
d191 1
a191 1
					  host->id, host->up);
d199 1
a199 1
				  st.up, host->id, host->name);
d225 1
a225 1
				  imsg.hdr.type);
d237 2
a238 2
        struct imsg	 imsg;
        ssize_t		 n;
d242 13
a254 13
        case EV_READ:
                if ((n = imsg_read(ibuf)) == -1)
                        fatal("imsg_read error");
                if (n == 0)     /* connection closed */
                        fatalx("pfe_dispatch_parent: pipe closed");
                break;
        case EV_WRITE:
                if (msgbuf_write(&ibuf->w) == -1)
                        fatal("msgbuf_write");
                imsg_event_add(ibuf);
                return;
        default:
                fatalx("pfe_dispatch_parent: unknown event");
d257 14
a270 14
        for (;;) {
                if ((n = imsg_get(ibuf, &imsg)) == -1)
                        fatal("pfe_dispatch_parent: imsg_read error");
                if (n == 0)
                        break;

                switch (imsg.hdr.type) {
                default:
                        log_debug("pfe_dispatch_parent: unexpected imsg %d", 
                                imsg.hdr.type);
                        break;
                }
                imsg_free(&imsg);
        }
d281 1
a281 1
				service, sizeof(*service));
d286 1
a286 1
			     service->table, sizeof(*service->table)); 
d290 1
a290 1
					     host, sizeof(*host));
d295 1
a295 1
			     service->backup, sizeof(*service->backup)); 
d299 1
a299 1
					     host, sizeof(*host));
d483 1
a483 1
		
@

