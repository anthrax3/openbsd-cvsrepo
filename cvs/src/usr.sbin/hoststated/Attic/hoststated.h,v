head	1.87;
access;
symbols
	OPENBSD_4_2:1.53.0.2
	OPENBSD_4_2_BASE:1.53
	OPENBSD_4_1:1.36.0.2
	OPENBSD_4_1_BASE:1.36;
locks; strict;
comment	@ * @;


1.87
date	2007.12.07.17.27.07;	author deraadt;	state dead;
branches;
next	1.86;

1.86
date	2007.11.26.09.38.25;	author reyk;	state Exp;
branches;
next	1.85;

1.85
date	2007.11.24.16.13.50;	author reyk;	state Exp;
branches;
next	1.84;

1.84
date	2007.11.23.09.39.42;	author reyk;	state Exp;
branches;
next	1.83;

1.83
date	2007.11.22.16.38.25;	author reyk;	state Exp;
branches;
next	1.82;

1.82
date	2007.11.22.16.07.03;	author reyk;	state Exp;
branches;
next	1.81;

1.81
date	2007.11.22.10.09.53;	author reyk;	state Exp;
branches;
next	1.80;

1.80
date	2007.11.21.20.28.38;	author reyk;	state Exp;
branches;
next	1.79;

1.79
date	2007.11.21.20.13.20;	author reyk;	state Exp;
branches;
next	1.78;

1.78
date	2007.11.21.14.12.04;	author reyk;	state Exp;
branches;
next	1.77;

1.77
date	2007.11.21.13.04.42;	author reyk;	state Exp;
branches;
next	1.76;

1.76
date	2007.11.20.15.54.55;	author reyk;	state Exp;
branches;
next	1.75;

1.75
date	2007.11.20.15.44.21;	author pyr;	state Exp;
branches;
next	1.74;

1.74
date	2007.11.20.13.01.13;	author pyr;	state Exp;
branches;
next	1.73;

1.73
date	2007.11.19.14.48.19;	author reyk;	state Exp;
branches;
next	1.72;

1.72
date	2007.11.14.10.59.01;	author pyr;	state Exp;
branches;
next	1.71;

1.71
date	2007.10.22.16.53.30;	author pyr;	state Exp;
branches;
next	1.70;

1.70
date	2007.10.19.14.15.14;	author pyr;	state Exp;
branches;
next	1.69;

1.69
date	2007.10.19.12.08.55;	author pyr;	state Exp;
branches;
next	1.68;

1.68
date	2007.10.12.12.50.59;	author blambert;	state Exp;
branches;
next	1.67;

1.67
date	2007.10.05.17.32.13;	author reyk;	state Exp;
branches;
next	1.66;

1.66
date	2007.10.05.15.50.12;	author reyk;	state Exp;
branches;
next	1.65;

1.65
date	2007.10.02.21.04.13;	author pyr;	state Exp;
branches;
next	1.64;

1.64
date	2007.09.28.13.29.56;	author pyr;	state Exp;
branches;
next	1.63;

1.63
date	2007.09.28.13.05.28;	author pyr;	state Exp;
branches;
next	1.62;

1.62
date	2007.09.27.13.34.21;	author pyr;	state Exp;
branches;
next	1.61;

1.61
date	2007.09.25.08.24.26;	author pyr;	state Exp;
branches;
next	1.60;

1.60
date	2007.09.10.11.59.22;	author reyk;	state Exp;
branches;
next	1.59;

1.59
date	2007.09.07.08.20.24;	author reyk;	state Exp;
branches;
next	1.58;

1.58
date	2007.09.07.07.59.18;	author reyk;	state Exp;
branches;
next	1.57;

1.57
date	2007.09.07.07.52.14;	author reyk;	state Exp;
branches;
next	1.56;

1.56
date	2007.09.06.19.55.45;	author reyk;	state Exp;
branches;
next	1.55;

1.55
date	2007.09.05.08.48.42;	author reyk;	state Exp;
branches;
next	1.54;

1.54
date	2007.09.05.07.32.33;	author reyk;	state Exp;
branches;
next	1.53;

1.53
date	2007.06.18.17.29.38;	author pyr;	state Exp;
branches;
next	1.52;

1.52
date	2007.06.12.15.16.10;	author msf;	state Exp;
branches;
next	1.51;

1.51
date	2007.05.31.03.24.05;	author pyr;	state Exp;
branches;
next	1.50;

1.50
date	2007.05.29.23.19.18;	author pyr;	state Exp;
branches;
next	1.49;

1.49
date	2007.05.29.19.05.13;	author pyr;	state Exp;
branches;
next	1.48;

1.48
date	2007.05.29.17.12.04;	author reyk;	state Exp;
branches;
next	1.47;

1.47
date	2007.05.29.00.48.04;	author pyr;	state Exp;
branches;
next	1.46;

1.46
date	2007.05.29.00.21.10;	author pyr;	state Exp;
branches;
next	1.45;

1.45
date	2007.05.28.22.11.33;	author pyr;	state Exp;
branches;
next	1.44;

1.44
date	2007.05.28.17.37.16;	author pyr;	state Exp;
branches;
next	1.43;

1.43
date	2007.05.27.20.53.10;	author pyr;	state Exp;
branches;
next	1.42;

1.42
date	2007.05.26.19.58.49;	author pyr;	state Exp;
branches;
next	1.41;

1.41
date	2007.04.12.14.45.45;	author reyk;	state Exp;
branches;
next	1.40;

1.40
date	2007.04.10.21.33.52;	author reyk;	state Exp;
branches;
next	1.39;

1.39
date	2007.03.21.00.08.08;	author reyk;	state Exp;
branches;
next	1.38;

1.38
date	2007.03.17.22.28.42;	author reyk;	state Exp;
branches;
next	1.37;

1.37
date	2007.03.13.12.04.52;	author reyk;	state Exp;
branches;
next	1.36;

1.36
date	2007.03.05.11.44.50;	author reyk;	state Exp;
branches;
next	1.35;

1.35
date	2007.02.27.13.38.58;	author reyk;	state Exp;
branches;
next	1.34;

1.34
date	2007.02.26.12.35.43;	author reyk;	state Exp;
branches;
next	1.33;

1.33
date	2007.02.26.12.09.21;	author reyk;	state Exp;
branches;
next	1.32;

1.32
date	2007.02.26.11.59.48;	author reyk;	state Exp;
branches;
next	1.31;

1.31
date	2007.02.25.14.57.09;	author reyk;	state Exp;
branches;
next	1.30;

1.30
date	2007.02.24.16.14.02;	author reyk;	state Exp;
branches;
next	1.29;

1.29
date	2007.02.24.15.48.54;	author reyk;	state Exp;
branches;
next	1.28;

1.28
date	2007.02.24.00.22.32;	author reyk;	state Exp;
branches;
next	1.27;

1.27
date	2007.02.23.00.28.06;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2007.02.22.05.58.06;	author reyk;	state Exp;
branches;
next	1.25;

1.25
date	2007.02.22.03.32.39;	author reyk;	state Exp;
branches;
next	1.24;

1.24
date	2007.02.07.15.17.46;	author reyk;	state Exp;
branches;
next	1.23;

1.23
date	2007.02.07.13.39.58;	author reyk;	state Exp;
branches;
next	1.22;

1.22
date	2007.02.07.13.30.17;	author reyk;	state Exp;
branches;
next	1.21;

1.21
date	2007.02.06.10.26.13;	author pyr;	state Exp;
branches;
next	1.20;

1.20
date	2007.02.06.10.06.55;	author reyk;	state Exp;
branches;
next	1.19;

1.19
date	2007.02.06.08.45.46;	author pyr;	state Exp;
branches;
next	1.18;

1.18
date	2007.02.01.20.03.39;	author pyr;	state Exp;
branches;
next	1.17;

1.17
date	2007.01.29.14.23.31;	author pyr;	state Exp;
branches;
next	1.16;

1.16
date	2007.01.12.17.05.18;	author pyr;	state Exp;
branches;
next	1.15;

1.15
date	2007.01.12.16.43.01;	author pyr;	state Exp;
branches;
next	1.14;

1.14
date	2007.01.11.18.05.08;	author reyk;	state Exp;
branches;
next	1.13;

1.13
date	2007.01.09.13.50.11;	author pyr;	state Exp;
branches;
next	1.12;

1.12
date	2007.01.09.03.32.56;	author reyk;	state Exp;
branches;
next	1.11;

1.11
date	2007.01.08.20.46.18;	author reyk;	state Exp;
branches;
next	1.10;

1.10
date	2007.01.08.16.52.58;	author reyk;	state Exp;
branches;
next	1.9;

1.9
date	2007.01.08.13.37.26;	author reyk;	state Exp;
branches;
next	1.8;

1.8
date	2007.01.03.09.45.29;	author reyk;	state Exp;
branches;
next	1.7;

1.7
date	2007.01.03.09.42.30;	author reyk;	state Exp;
branches;
next	1.6;

1.6
date	2006.12.26.02.51.00;	author jsg;	state Exp;
branches;
next	1.5;

1.5
date	2006.12.25.19.05.41;	author reyk;	state Exp;
branches;
next	1.4;

1.4
date	2006.12.25.18.12.14;	author reyk;	state Exp;
branches;
next	1.3;

1.3
date	2006.12.16.18.50.33;	author reyk;	state Exp;
branches;
next	1.2;

1.2
date	2006.12.16.12.42.14;	author reyk;	state Exp;
branches;
next	1.1;

1.1
date	2006.12.16.11.45.07;	author reyk;	state Exp;
branches;
next	;


desc
@@


1.87
log
@hoststated/hoststatectl get repository copied (and de-tagged) into
relayd/relayctl.  This is a more suitable place for a daemon that has
grown out of it's initial roots of "monitoring and redirecting services
at various layers", into one that is "a full featured proxy, which
happens to know what is up/down"
@
text
@/*	$OpenBSD: hoststated.h,v 1.86 2007/11/26 09:38:25 reyk Exp $	*/

/*
 * Copyright (c) 2006, 2007 Pierre-Yves Ritschard <pyr@@openbsd.org>
 * Copyright (c) 2006, 2007 Reyk Floeter <reyk@@openbsd.org>
 * Copyright (c) 2003, 2004 Henning Brauer <henning@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/tree.h>

#define CONF_FILE		"/etc/hoststated.conf"
#define HOSTSTATED_SOCKET	"/var/run/hoststated.sock"
#define PF_SOCKET		"/dev/pf"
#define HOSTSTATED_USER		"_hoststated"
#define HOSTSTATED_ANCHOR	"hoststated"
#define HOSTSTATED_SERVERNAME	"OpenBSD hoststated"
#define CHECK_TIMEOUT		200
#define CHECK_INTERVAL		10
#define EMPTY_TABLE		UINT_MAX
#define EMPTY_ID		UINT_MAX
#define TABLE_NAME_SIZE		64
#define	TAG_NAME_SIZE		64
#define SRV_NAME_SIZE		64
#define MAX_NAME_SIZE		64
#define SRV_MAX_VIRTS		16

#define RELAY_MAX_SESSIONS	1024
#define RELAY_TIMEOUT		600
#define RELAY_CACHESIZE		-1	/* use default size */
#define RELAY_NUMPROC		5
#define RELAY_MAXPROC		32
#define RELAY_MAXHOSTS		32
#define RELAY_STATINTERVAL	60
#define RELAY_BACKLOG		10
#define RELAY_MAXLOOKUPLEVELS	5

#define SMALL_READ_BUF_SIZE	1024
#define READ_BUF_SIZE		65535
#define ICMP_BUF_SIZE		64

#define PURGE_TABLES		0x01
#define PURGE_SERVICES		0x02
#define PURGE_RELAYS		0x04
#define PURGE_PROTOS		0x08
#define PURGE_EVERYTHING	0xff

/* buffer */
struct buf {
	TAILQ_ENTRY(buf)	 entry;
	u_char			*buf;
	size_t			 size;
	size_t			 max;
	size_t			 wpos;
	size_t			 rpos;
	int			 fd;
};

struct msgbuf {
	TAILQ_HEAD(, buf)	 bufs;
	u_int32_t		 queued;
	int			 fd;
};

#define IMSG_HEADER_SIZE	sizeof(struct imsg_hdr)
#define MAX_IMSGSIZE		8192

struct buf_read {
	u_char			 buf[READ_BUF_SIZE];
	u_char			*rptr;
	size_t			 wpos;
};

struct imsg_fd {
	TAILQ_ENTRY(imsg_fd)	entry;
	int			fd;
};

struct imsgbuf {
	TAILQ_HEAD(, imsg_fd)	 fds;
	struct buf_read		 r;
	struct msgbuf		 w;
	struct event		 ev;
	void			(*handler)(int, short, void *);
	int			 fd;
	pid_t			 pid;
	short			 events;
};

enum imsg_type {
	IMSG_NONE,
	IMSG_CTL_OK,		/* answer to hoststatectl requests */
	IMSG_CTL_FAIL,
	IMSG_CTL_END,
	IMSG_CTL_SERVICE,
	IMSG_CTL_TABLE,
	IMSG_CTL_HOST,
	IMSG_CTL_RELAY,
	IMSG_CTL_SESSION,
	IMSG_CTL_TABLE_CHANGED,
	IMSG_CTL_PULL_RULESET,
	IMSG_CTL_PUSH_RULESET,
	IMSG_CTL_SHOW_SUM,	/* hoststatectl requests */
	IMSG_CTL_SERVICE_ENABLE,
	IMSG_CTL_SERVICE_DISABLE,
	IMSG_CTL_TABLE_ENABLE,
	IMSG_CTL_TABLE_DISABLE,
	IMSG_CTL_HOST_ENABLE,
	IMSG_CTL_HOST_DISABLE,
	IMSG_CTL_SHUTDOWN,
	IMSG_CTL_RELOAD,
	IMSG_CTL_POLL,
	IMSG_CTL_NOTIFY,
	IMSG_CTL_STATISTICS,
	IMSG_SERVICE_ENABLE,	/* notifies from pfe to hce */
	IMSG_SERVICE_DISABLE,
	IMSG_TABLE_ENABLE,
	IMSG_TABLE_DISABLE,
	IMSG_HOST_ENABLE,
	IMSG_HOST_DISABLE,
	IMSG_HOST_STATUS,	/* notifies from hce to pfe */
	IMSG_SYNC,
	IMSG_NATLOOK,
	IMSG_DEMOTE,
	IMSG_STATISTICS,
	IMSG_RECONF,		/* reconfiguration notifies */
	IMSG_RECONF_TABLE,
	IMSG_RECONF_SENDBUF,
	IMSG_RECONF_HOST,
	IMSG_RECONF_SERVICE,
	IMSG_RECONF_VIRT,
	IMSG_RECONF_PROTO,
	IMSG_RECONF_REQUEST_TREE,
	IMSG_RECONF_RESPONSE_TREE,
	IMSG_RECONF_PNODE_KEY,
	IMSG_RECONF_PNODE_VAL,
	IMSG_RECONF_RELAY,
	IMSG_RECONF_END,
	IMSG_SCRIPT
};

struct imsg_hdr {
	u_int16_t	 type;
	u_int16_t	 len;
	u_int32_t	 peerid;
	pid_t		 pid;
};

struct imsg {
	struct imsg_hdr	 hdr;
	void		*data;
};

typedef u_int32_t objid_t;

struct ctl_status {
	objid_t		 id;
	int		 up;
	int		 retry_cnt;
	u_long		 check_cnt;
};

struct ctl_id {
	objid_t		 id;
	char		 name[MAX_NAME_SIZE];
};

struct ctl_script {
	objid_t		 host;
	int		 retval;
};

struct ctl_demote {
	char		 group[IFNAMSIZ];
	int		 level;
};

struct ctl_icmp_event {
	struct hoststated	*env;
	int			 s;
	int			 af;
	int			 last_up;
	struct event		 ev;
	struct timeval		 tv_start;
};

struct ctl_tcp_event {
	int			 s;
	char			*req;
	struct buf		*buf;
	struct host		*host;
	struct table		*table;
	struct timeval		 tv_start;
	struct event		 ev;
	int			(*validate_read)(struct ctl_tcp_event *);
	int			(*validate_close)(struct ctl_tcp_event *);
	SSL			*ssl;
	char			 rbuf[SMALL_READ_BUF_SIZE];
};

enum httpmethod {
	HTTP_METHOD_GET		= 0,
	HTTP_METHOD_HEAD	= 1,
	HTTP_METHOD_POST	= 2,
	HTTP_METHOD_PUT		= 3,
	HTTP_METHOD_DELETE	= 4,
	HTTP_METHOD_OPTIONS	= 5,
	HTTP_METHOD_TRACE	= 6,
	HTTP_METHOD_CONNECT	= 7,
	HTTP_METHOD_RESPONSE	= 8	/* Server response */
};

enum direction {
	RELAY_DIR_REQUEST	= 0,
	RELAY_DIR_RESPONSE	= 1
};

struct ctl_relay_event {
	int			 s;
	in_port_t		 port;
	struct sockaddr_storage	 ss;
	struct bufferevent	*bev;
	struct evbuffer		*output;
	struct ctl_relay_event	*dst;
	void			*con;
	SSL			*ssl;
	u_int8_t		*nodes;
	struct proto_tree	*tree;

	char			*path;
	char			*args;
	char			*version;

	int			 line;
	size_t			 toread;
	int			 chunked;
	int			 done;
	enum httpmethod		 method;
	enum direction		 dir;

	u_int8_t		*buf;
	int			 buflen;
};

struct ctl_natlook {
	objid_t			 id;
	int			 proc;

	struct sockaddr_storage	 src;
	struct sockaddr_storage	 dst;
	struct sockaddr_storage	 rsrc;
	struct sockaddr_storage	 rdst;
	in_port_t		 rsport;
	in_port_t		 rdport;
	int			 in;
};

struct ctl_stats {
	objid_t			 id;
	int			 proc;

	u_int			 interval;
	u_long			 cnt;
	u_long			 tick;
	u_long			 avg;
	u_long			 last;
	u_long			 avg_hour;
	u_long			 last_hour;
	u_long			 avg_day;
	u_long			 last_day;
};

struct address {
	struct sockaddr_storage	 ss;
	in_port_t		 port;
	char			 ifname[IFNAMSIZ];
	TAILQ_ENTRY(address)	 entry;
};
TAILQ_HEAD(addresslist, address);

#define F_DISABLE		0x00000001
#define F_BACKUP		0x00000002
#define F_USED			0x00000004
#define F_DOWN			0x00000008
#define F_ADD			0x00000010
#define F_DEL			0x00000020
#define F_CHANGED		0x00000040
#define F_STICKY		0x00000080
#define F_CHECK_DONE		0x00000100
#define F_ACTIVE_RULESET	0x00000200
#define F_CHECK_SENT		0x00000400
#define F_SSL			0x00000800
#define F_NATLOOK		0x00001000
#define F_DEMOTE		0x00002000
#define F_LOOKUP_PATH		0x00004000
#define F_DEMOTED		0x00008000
#define F_UDP			0x00010000
#define F_RETURN		0x00020000

struct host_config {
	objid_t			 id;
	objid_t			 tableid;
	int			 retry;
	char			 name[MAXHOSTNAMELEN];
	struct sockaddr_storage	 ss;
};

struct host {
	TAILQ_ENTRY(host)	 entry;
	struct host_config	 conf;
	u_int32_t		 flags;
	char			*tablename;
	int			 up;
	int			 last_up;
	u_long			 check_cnt;
	u_long			 up_cnt;
	int			 retry_cnt;
	int			 idx;
	struct ctl_tcp_event	 cte;
};
TAILQ_HEAD(hostlist, host);

enum host_status {
	HOST_DOWN	= -1,
	HOST_UNKNOWN	= 0,
	HOST_UP		= 1
};
#define HOST_ISUP(x)	(x == HOST_UP)

enum digest_type {
	DIGEST_NONE		= 0,
	DIGEST_SHA1		= 1,
	DIGEST_MD5		= 2
};

struct table_config {
	objid_t			 id;
	objid_t			 serviceid;
	u_int32_t		 flags;
	int			 check;
	char			 demote_group[IFNAMSIZ];
	struct timeval		 timeout;
	in_port_t		 port;
	int			 retcode;
	int			 skip_cnt;
	char			 name[TABLE_NAME_SIZE];
	char			 path[MAXPATHLEN];
	char			 exbuf[64];
	char			 digest[41]; /* length of sha1 digest * 2 */
	u_int8_t		 digest_type;
};

struct table {
	TAILQ_ENTRY(table)	 entry;
	struct table_config	 conf;
	int			 up;
	int			 skipped;
	struct hostlist		 hosts;
	SSL_CTX			*ssl_ctx;
	int			 sendbuf_len;
	char			*sendbuf;
};
TAILQ_HEAD(tablelist, table);

enum table_check {
	CHECK_NOCHECK		= 0,
	CHECK_ICMP		= 1,
	CHECK_TCP		= 2,
	CHECK_HTTP_CODE		= 3,
	CHECK_HTTP_DIGEST	= 4,
	CHECK_SEND_EXPECT	= 5,
	CHECK_SCRIPT		= 6
};

struct service_config {
	objid_t			 id;
	u_int32_t		 flags;
	in_port_t		 port;
	objid_t			 table_id;
	objid_t			 backup_id;
	char			 name[SRV_NAME_SIZE];
	char			 tag[TAG_NAME_SIZE];
};

struct service {
	TAILQ_ENTRY(service)	 entry;
	struct service_config	 conf;
	struct addresslist	 virts;
	struct table		*table;
	struct table		*backup; /* use this if no host up */
};
TAILQ_HEAD(servicelist, service);

struct session {
	objid_t				 id;
	u_int32_t			 key;
	objid_t				 relayid;
	struct ctl_relay_event		 in;
	struct ctl_relay_event		 out;
	u_int32_t			 outkey;
	struct event			 ev;
	struct timeval			 timeout;
	struct timeval			 tv_start;
	struct timeval			 tv_last;
	int				 done;
	int				 retry;
	u_int16_t			 mark;
	struct evbuffer			*log;
	void				*relay;
	struct ctl_natlook		*cnl;

	SPLAY_ENTRY(session)		 nodes;
};
SPLAY_HEAD(session_tree, session);

enum nodeaction {
	NODE_ACTION_NONE	= 0,
	NODE_ACTION_APPEND	= 1,
	NODE_ACTION_CHANGE	= 2,
	NODE_ACTION_REMOVE	= 3,
	NODE_ACTION_EXPECT	= 4,
	NODE_ACTION_FILTER	= 5,
	NODE_ACTION_HASH	= 6,
	NODE_ACTION_LOG		= 7,
	NODE_ACTION_MARK	= 8
};

enum nodetype {
	NODE_TYPE_HEADER	= 0,
	NODE_TYPE_QUERY		= 1,
	NODE_TYPE_COOKIE	= 2,
	NODE_TYPE_PATH		= 3,
	NODE_TYPE_URL		= 4
};

#define PNFLAG_MACRO			0x01
#define PNFLAG_MARK			0x02
#define PNFLAG_LOG			0x04
#define PNFLAG_LOOKUP_QUERY		0x08
#define PNFLAG_LOOKUP_COOKIE		0x10
#define PNFLAG_LOOKUP_URL		0xe0
#define PNFLAG_LOOKUP_URL_DIGEST	0xc0
#define PNFLAG_LOOKUP_DIGEST(x)		(0x20 << x)

enum noderesult {
	PN_DROP			= 0,
	PN_PASS			= 1,
	PN_FAIL			= -1
};

struct protonode {
	objid_t				 id;
	char				*key;
	enum nodeaction			 action;
	char				*value;
	u_int8_t			 flags;
	enum nodetype			 type;
	u_int16_t			 mark;
	u_int16_t			 label;

	SIMPLEQ_HEAD(, protonode)	 head;
	SIMPLEQ_ENTRY(protonode)	 entry;

	RB_ENTRY(protonode)		 nodes;
};
RB_HEAD(proto_tree, protonode);

#define PROTONODE_FOREACH(elm, root, field)				\
	for (elm = root; elm != NULL; elm = SIMPLEQ_NEXT(elm, entry))	\

enum prototype {
	RELAY_PROTO_TCP		= 0,
	RELAY_PROTO_HTTP	= 1,
	RELAY_PROTO_DNS		= 2
};

#define TCPFLAG_NODELAY		0x01
#define TCPFLAG_NNODELAY	0x02
#define TCPFLAG_SACK		0x04
#define TCPFLAG_NSACK		0x08
#define TCPFLAG_BUFSIZ		0x10
#define TCPFLAG_IPTTL		0x20
#define TCPFLAG_IPMINTTL	0x40
#define TCPFLAG_DEFAULT		0x00

#define SSLFLAG_SSLV2		0x01
#define SSLFLAG_SSLV3		0x02
#define SSLFLAG_TLSV1		0x04
#define SSLFLAG_VERSION		0x07
#define SSLFLAG_DEFAULT		(SSLFLAG_SSLV3|SSLFLAG_TLSV1)

#define SSLCIPHERS_DEFAULT	"HIGH:!ADH"

struct relay;
struct protocol {
	objid_t			 id;
	u_int32_t		 flags;
	u_int8_t		 tcpflags;
	int			 tcpbufsiz;
	int			 tcpbacklog;
	u_int8_t		 tcpipttl;
	u_int8_t		 tcpipminttl;
	u_int8_t		 sslflags;
	char			 sslciphers[768];
	char			 name[MAX_NAME_SIZE];
	int			 cache;
	enum prototype		 type;
	int			 lateconnect;
	char			*style;

	int			 request_nodes;
	struct proto_tree	 request_tree;
	int			 response_nodes;
	struct proto_tree	 response_tree;

	int			(*cmp)(struct session *, struct session *);
	int			(*validate)(struct relay *,
				    struct sockaddr_storage *,
				    u_int8_t *, size_t, u_int32_t *);
	int			(*request)(struct session *);

	TAILQ_ENTRY(protocol)	 entry;
};
TAILQ_HEAD(protolist, protocol);

struct relay_config {
	objid_t			 id;
	u_int32_t		 flags;
	objid_t			 proto;
	char			 name[MAXHOSTNAMELEN];
	in_port_t		 port;
	in_port_t		 dstport;
	int			 dstmode;
	int			 dstcheck;
	int			 dstretry;
	objid_t			 dsttable;
	struct sockaddr_storage	 ss;
	struct sockaddr_storage	 dstss;
	struct timeval		 timeout;
};

struct relay {
	TAILQ_ENTRY(relay)	 entry;
	struct relay_config	 conf;

	int			 up;
	struct protocol		*proto;
	int			 s;
	struct bufferevent	*bev;

	int			 dsts;
	struct bufferevent	*dstbev;

	struct table		*dsttable;
	u_int32_t		 dstkey;
	struct host		*dsthost[RELAY_MAXHOSTS];
	int			 dstnhosts;

	struct event		 ev;

	SSL_CTX			*ssl_ctx;
	char			*ssl_cert;
	off_t			 ssl_cert_len;
	char			*ssl_key;
	off_t			 ssl_key_len;

	struct ctl_stats	 stats[RELAY_MAXPROC + 1];

	struct session_tree	 sessions;
};
TAILQ_HEAD(relaylist, relay);

enum dstmode {
	RELAY_DSTMODE_LOADBALANCE	= 0,
	RELAY_DSTMODE_ROUNDROBIN	= 1,
	RELAY_DSTMODE_HASH		= 2
};
#define RELAY_DSTMODE_DEFAULT		RELAY_DSTMODE_LOADBALANCE

enum {
	PROC_MAIN,
	PROC_PFE,
	PROC_HCE,
	PROC_RELAY
} hoststated_process;

struct hoststated {
	u_int8_t		 opts;
	u_int32_t		 flags;
	const char		*confpath;
	struct pfdata		*pf;
	int			 tablecount;
	int			 servicecount;
	int			 protocount;
	int			 relaycount;
	struct timeval		 interval;
	struct timeval		 timeout;
	struct table		 empty_table;
	struct protocol		 proto_default;
	struct event		 ev;
	struct tablelist	*tables;
	struct servicelist	*services;
	struct protolist	*protos;
	struct relaylist	*relays;
	u_int16_t		 prefork_relay;
	char			 demote_group[IFNAMSIZ];
	u_int16_t		 id;

	struct event		 statev;
	struct timeval		 statinterval;

	int			 has_icmp;
	int			 has_icmp6;
	struct ctl_icmp_event	 icmp_send;
	struct ctl_icmp_event	 icmp_recv;
	struct ctl_icmp_event	 icmp6_send;
	struct ctl_icmp_event	 icmp6_recv;
};

#define HOSTSTATED_OPT_VERBOSE		0x01
#define HOSTSTATED_OPT_NOACTION		0x04
#define HOSTSTATED_OPT_LOGUPDATE	0x08
#define HOSTSTATED_OPT_LOGNOTIFY	0x10
#define HOSTSTATED_OPT_LOGALL		0x18

/* initially control.h */
struct {
	struct event	 ev;
	int		 fd;
} control_state;

enum blockmodes {
	BM_NORMAL,
	BM_NONBLOCK
};

struct ctl_conn {
	TAILQ_ENTRY(ctl_conn)	 entry;
	u_int8_t		 flags;
#define CTL_CONN_NOTIFY		 0x01
	struct imsgbuf		 ibuf;

};
TAILQ_HEAD(ctl_connlist, ctl_conn);

/* control.c */
int	control_init(void);
int	control_listen(struct hoststated *, struct imsgbuf *, struct imsgbuf *);
void    control_accept(int, short, void *);
void    control_dispatch_imsg(int, short, void *);
void	control_imsg_forward(struct imsg *);
void    control_cleanup(void);

void    session_socket_blockmode(int, enum blockmodes);

extern  struct ctl_connlist ctl_conns;

/* parse.y */
struct hoststated	*parse_config(const char *, int);
int			 cmdline_symset(char *);

/* log.c */
void	log_init(int);
void	log_warn(const char *, ...);
void	log_warnx(const char *, ...);
void	log_info(const char *, ...);
void	log_debug(const char *, ...);
__dead void fatal(const char *);
__dead void fatalx(const char *);
const char *host_status(enum host_status);
const char *table_check(enum table_check);
const char *print_availability(u_long, u_long);
const char *print_host(struct sockaddr_storage *, char *, size_t);
const char *print_time(struct timeval *, struct timeval *, char *, size_t);
const char *print_httperror(u_int);

/* buffer.c */
struct buf	*buf_open(size_t);
struct buf	*buf_dynamic(size_t, size_t);
int		 buf_add(struct buf *, void *, size_t);
void		*buf_reserve(struct buf *, size_t);
int		 buf_close(struct msgbuf *, struct buf *);
void		 buf_free(struct buf *);
void		 msgbuf_init(struct msgbuf *);
void		 msgbuf_clear(struct msgbuf *);
int		 msgbuf_write(struct msgbuf *);

/* imsg.c */
void	 imsg_init(struct imsgbuf *, int, void (*)(int, short, void *));
ssize_t	 imsg_read(struct imsgbuf *);
ssize_t	 imsg_get(struct imsgbuf *, struct imsg *);
int	 imsg_compose(struct imsgbuf *, enum imsg_type, u_int32_t, pid_t,
	    int, void *, u_int16_t);
struct buf *imsg_create(struct imsgbuf *, enum imsg_type, u_int32_t, pid_t,
	    u_int16_t);
int	 imsg_add(struct buf *, void *, u_int16_t);
int	 imsg_close(struct imsgbuf *, struct buf *);
void	 imsg_free(struct imsg *);
void	 imsg_event_add(struct imsgbuf *); /* needs to be provided externally */
int	 imsg_get_fd(struct imsgbuf *);

/* pfe.c */
pid_t	 pfe(struct hoststated *, int [2], int [2], int [RELAY_MAXPROC][2],
	    int [2], int [RELAY_MAXPROC][2]);
void	 show(struct ctl_conn *);
void	 show_sessions(struct ctl_conn *);
int	 enable_service(struct ctl_conn *, struct ctl_id *);
int	 enable_table(struct ctl_conn *, struct ctl_id *);
int	 enable_host(struct ctl_conn *, struct ctl_id *);
int	 disable_service(struct ctl_conn *, struct ctl_id *);
int	 disable_table(struct ctl_conn *, struct ctl_id *);
int	 disable_host(struct ctl_conn *, struct ctl_id *);

/* pfe_filter.c */
void	 init_filter(struct hoststated *);
void	 init_tables(struct hoststated *);
void	 flush_table(struct hoststated *, struct service *);
void	 sync_table(struct hoststated *, struct service *, struct table *);
void	 sync_ruleset(struct hoststated *, struct service *, int);
void	 flush_rulesets(struct hoststated *);
int	 natlook(struct hoststated *, struct ctl_natlook *);

/* hce.c */
pid_t	 hce(struct hoststated *, int [2], int [2], int [RELAY_MAXPROC][2],
	    int [2], int [RELAY_MAXPROC][2]);
void	 hce_notify_done(struct host *, const char *);

/* relay.c */
pid_t	 relay(struct hoststated *, int [2], int [2], int [RELAY_MAXPROC][2],
	    int [2], int [RELAY_MAXPROC][2]);
void	 relay_notify_done(struct host *, const char *);
int	 relay_session_cmp(struct session *, struct session *);
int	 relay_load_certfiles(struct relay *);

RB_PROTOTYPE(proto_tree, protonode, nodes, relay_proto_cmp);
SPLAY_PROTOTYPE(session_tree, session, nodes, relay_session_cmp);

/* relay_udp.c */
void	 relay_udp_privinit(struct hoststated *, struct relay *);
int	 relay_udp_bind(struct sockaddr_storage *, in_port_t,
	    struct protocol *);
void	 relay_udp_server(int, short, void *);

/* check_icmp.c */
void	 icmp_init(struct hoststated *);
void	 schedule_icmp(struct hoststated *, struct host *);
void	 check_icmp(struct hoststated *, struct timeval *);

/* check_tcp.c */
void	 check_tcp(struct ctl_tcp_event *);

/* check_script.c */
void	 check_script(struct host *);
void	 script_done(struct hoststated *, struct ctl_script *);
int	 script_exec(struct hoststated *, struct ctl_script *);

/* ssl.c */
void	 ssl_init(struct hoststated *);
void	 ssl_transaction(struct ctl_tcp_event *);
SSL_CTX	*ssl_ctx_create(struct hoststated *);
void	 ssl_error(const char *, const char *);

/* ssl_privsep.c */
int	 ssl_ctx_use_private_key(SSL_CTX *, char *, off_t);
int	 ssl_ctx_use_certificate_chain(SSL_CTX *, char *, off_t);

/* hoststated.c */
struct host	*host_find(struct hoststated *, objid_t);
struct table	*table_find(struct hoststated *, objid_t);
struct service	*service_find(struct hoststated *, objid_t);
struct host	*host_findbyname(struct hoststated *, const char *);
struct table	*table_findbyname(struct hoststated *, const char *);
struct service	*service_findbyname(struct hoststated *, const char *);
void		 event_again(struct event *, int, short,
		    void (*)(int, short, void *),
		    struct timeval *, struct timeval *, void *);
struct relay	*relay_find(struct hoststated *, objid_t);
struct session	*session_find(struct hoststated *, objid_t);
struct relay	*relay_findbyname(struct hoststated *, const char *);
int		 expand_string(char *, size_t, const char *, const char *);
void		 translate_string(char *);
void		 purge_config(struct hoststated *, u_int8_t);
void		 merge_config(struct hoststated *, struct hoststated *);
char		*digeststr(enum digest_type, const u_int8_t *, size_t, char *);
const char	*canonicalize_host(const char *, char *, size_t);

/* carp.c */
int	 carp_demote_init(char *, int);
void	 carp_demote_shutdown(void);
int	 carp_demote_get(char *);
int	 carp_demote_set(char *, int);
int	 carp_demote_reset(char *, int);

/* name2id.c */
u_int16_t	 pn_name2id(const char *);
const char	*pn_id2name(u_int16_t);
void		 pn_unref(u_int16_t);
void		 pn_ref(u_int16_t);

@


1.86
log
@allow to add labels to protocol actions, they will be printed in http
error pages and can be used to refer to additional information.

ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.h,v 1.85 2007/11/24 16:13:50 reyk Exp $	*/
@


1.85
log
@extend the url lookup algorithm to match the full URL and different
possible suffix/prefix combinations by stripping subdomains, path
components, and the query args.

ok and tested by gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.h,v 1.84 2007/11/23 09:39:42 reyk Exp $	*/
d470 1
d804 7
@


1.84
log
@re-implement the "mark" action and document it in the manpage:
it is possible to attach a mark to a session based on matching an
entity (header, url, cookie, ...) and add conditional action for this
mark. it works a bit like the tag/tagged keywords in pf, but i decided
to pick a different name to avoid confusion.

ok pyr@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.h,v 1.83 2007/11/22 16:38:25 reyk Exp $	*/
d47 1
d795 1
@


1.83
log
@shuffle some structure elements; avoid using enums in *_config structs.
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.h,v 1.82 2007/11/22 16:07:03 reyk Exp $	*/
a243 1
	int			 marked;
d417 1
d434 2
a435 1
	NODE_ACTION_LOG		= 7
d468 1
@


1.82
log
@Fix relay roundrobin mode to work correctly when multiple hosts in a
table are down.

Thanks to Preston Norvell at serialssolutions dot com for reporting
the problem.
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.h,v 1.81 2007/11/22 10:09:53 reyk Exp $	*/
d329 1
a330 1
	int			 idx;
d361 1
a361 1
	enum digest_type	 digest_type;
@


1.81
log
@add (new) "url" protocol action, this can be used to match/filter URL
suffix/prefix expressions like "example.com/index.html?args". a digest
mode allows to match against anonymized SHA1/MD5 digests of
suffix/prefix expressions.
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.h,v 1.80 2007/11/21 20:28:38 reyk Exp $	*/
d330 1
@


1.80
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.h,v 1.79 2007/11/21 20:13:20 reyk Exp $	*/
d440 2
a441 1
	NODE_TYPE_PATH		= 3
d449 3
@


1.79
log
@move digest string handling into an extra function.
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.h,v 1.78 2007/11/21 14:12:04 reyk Exp $	*/
d443 5
a447 5
#define PNFLAG_MACRO		0x01
#define PNFLAG_MARK		0x02
#define PNFLAG_LOG		0x04
#define PNFLAG_LOOKUP_QUERY	0x08
#define PNFLAG_LOOKUP_COOKIE	0x10
@


1.78
log
@rename the "url" filter action to "query" to use the correct term.
please update your hoststated.conf configurations. also add more
examples to the manpage.

alright pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.h,v 1.77 2007/11/21 13:04:42 reyk Exp $	*/
d341 3
a343 2
	DIGEST_SHA1		= 0,
	DIGEST_MD5		= 1
d786 1
@


1.77
log
@allow the http digest type to be either SHA1 or MD5 determined by the
digest string length; it is compatible to any existing SHA1-only
configurations.

ok pyr@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.h,v 1.76 2007/11/20 15:54:55 reyk Exp $	*/
d437 1
a437 1
	NODE_TYPE_URL		= 1,
d445 1
a445 1
#define PNFLAG_LOOKUP_URL	0x08
@


1.76
log
@it may be desirable to send a HTTP error page with error code and a
meaningful message if a HTTP/HTTPS relay closes the connection for
some reason. for example, a "403 Forbidden" if the request was
rejected by a filter. this will be enabled with the "return error"
option and is disabled by default, the standard behaviour is to
silently drop the connection; the browser may display an empty page in
this case. the look+feel of the HTTP error page can be customized with
a CSS style sheet, but we do not intend to allow customization of the
error page contents (hoststated is not a webserver!).

ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.h,v 1.75 2007/11/20 15:44:21 pyr Exp $	*/
d340 5
d359 1
@


1.75
log
@Allow overriding the global interval in a table.
Table specific intervals must be multiples of the global interval.
help and ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.h,v 1.74 2007/11/20 13:01:13 pyr Exp $	*/
d28 1
d309 1
d504 1
d670 1
@


1.74
log
@bump table name size.
ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.h,v 1.73 2007/11/19 14:48:19 reyk Exp $	*/
d347 1
d358 1
@


1.73
log
@rework the internal handling of protocol actions a little bit:

- allow to use a key for multiple times by appending a queue of
additional matches to the tree node. for example, this allows to
specify multiple "expect" or "filter" actions to white-/black-list
a list of HTTP-headers, URLs, ..

- prevent specifing an HTTP header for multiple times when using the
expect action.

- minor code shuffling
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.h,v 1.72 2007/11/14 10:59:01 pyr Exp $	*/
d32 1
a32 1
#define TABLE_NAME_SIZE		32
@


1.72
log
@make protos dynamic too
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.h,v 1.71 2007/10/22 16:53:30 pyr Exp $	*/
d445 9
a453 6
	objid_t			 id;
	char			*key;
	enum nodeaction		 action;
	char			*value;
	u_int8_t		 flags;
	enum nodetype		 type;
d455 1
a455 1
	RB_ENTRY(protonode)	 nodes;
d458 3
@


1.71
log
@load certificates text at parse time. then load them in relay processes.
this separation will ease reload a bit more.

ok reyk@@ who spotted a stupid mistake again...
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.h,v 1.70 2007/10/19 14:15:14 pyr Exp $	*/
d587 1
a587 1
	struct protolist	 protos;
@


1.70
log
@Move relays from static TAILQs to allocated ones.
This syncs it with other hoststated entities and will make reload easier.
This is step 1 out of 7 for reload.
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.h,v 1.69 2007/10/19 12:08:55 pyr Exp $	*/
d716 1
@


1.69
log
@Add the ability to schedule an immediate check through hoststatectl.
Especially useful when interval is rather long.
I was supposed to commit this before 4.2.
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.h,v 1.68 2007/10/12 12:50:59 blambert Exp $	*/
d588 1
a588 1
	struct relaylist	 relays;
@


1.68
log
@Silence some lint(1) warnings

ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.h,v 1.67 2007/10/05 17:32:13 reyk Exp $	*/
d121 1
d632 1
a632 1
int	control_listen(struct hoststated *, struct imsgbuf *);
@


1.67
log
@stylistic changes in the relay/relay_config structure.
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.h,v 1.66 2007/10/05 15:50:12 reyk Exp $	*/
d651 2
a652 2
void	fatal(const char *);
void	fatalx(const char *);
@


1.66
log
@using an enum in the imsg_hdr is gross, use a fixed u_int16_t instead
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.h,v 1.65 2007/10/02 21:04:13 pyr Exp $	*/
d527 1
a527 4
	char			*ssl_cert;
	off_t			 ssl_cert_len;
	char			*ssl_key;
	off_t			 ssl_key_len;
a528 1
	struct relay_config	 conf;
d543 6
a548 1
	SSL_CTX			*ctx;
@


1.65
log
@stop messing with lgetc to please hoststated's check/expect.
instead move some of the logic in yylex and do hoststated specific
translations into hoststated.c
ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.h,v 1.64 2007/09/28 13:29:56 pyr Exp $	*/
d151 1
a151 1
	enum imsg_type	 type;
@


1.64
log
@Correct my mail address.
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.h,v 1.63 2007/09/28 13:05:28 pyr Exp $	*/
d761 1
@


1.63
log
@Change the ssl_privsep code to work on char buffers.
The fd based code introduced weirdness since all children were accessing
the same fd at once. This will also greatly facilitate reloading, no
fd-passing will be involved between the parent and relay children.

While there, cleanup the code diverting from the original ssl_rsa.c code
a bit more.

Weird behavior discovery by pascoe@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.h,v 1.62 2007/09/27 13:34:21 pyr Exp $	*/
d4 1
a4 1
 * Copyright (c) 2006, 2007 Pierre-Yves Ritschard <pyr@@spootnik.org>
@


1.62
log
@Simplify ssl_privsep.c, since it won't need to remain synced with the
equivalent openssl functions.
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.h,v 1.61 2007/09/25 08:24:26 pyr Exp $	*/
d527 4
a530 2
	int			 cert_fd;
	int			 key_fd;
d744 2
a745 2
int	 ssl_ctx_use_private_key(SSL_CTX *, int);
int	 ssl_ctx_use_certificate_chain(SSL_CTX *, int);
@


1.61
log
@Introduce two new functions to be able to load certificates while
already chrooted and with privileges dropped.
This is the very first step in being able to reload a
layer 7 configuration.

not ok reyk who's away but should be glad to see this in.
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.h,v 1.60 2007/09/10 11:59:22 reyk Exp $	*/
d527 3
d742 1
a742 1
int	 ssl_ctx_use_private_key(SSL_CTX *, int, int);
@


1.60
log
@add support for relaying DNS traffic (with a little bit of packet
header randomization). this adds an infrastructure to support
UDP-based protocols.

ok gilles@@, tested by some
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.h,v 1.59 2007/09/07 08:20:24 reyk Exp $	*/
d737 4
@


1.59
log
@add an interface to dump running relay sessions to the control socket
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.h,v 1.58 2007/09/07 07:59:18 reyk Exp $	*/
d306 1
d394 1
d457 2
a458 1
	RELAY_PROTO_HTTP	= 1
d478 1
d500 4
d712 6
@


1.58
log
@remove unused flags field from the structure
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.h,v 1.57 2007/09/07 07:52:14 reyk Exp $	*/
d108 1
d393 1
d674 1
@


1.57
log
@add a function to print delays in hours, minutes, and seconds
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.h,v 1.56 2007/09/06 19:55:45 reyk Exp $	*/
a250 1
	u_int8_t		 flags;
@


1.56
log
@rename relay_host to print_host in log.c
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.h,v 1.55 2007/09/05 08:48:42 reyk Exp $	*/
d642 1
@


1.55
log
@store relay sessions in SPLAY trees instead of TAILQ lists. this will
be used for faster lookups of sessions based on different criteria.

ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.h,v 1.54 2007/09/05 07:32:33 reyk Exp $	*/
d641 1
@


1.54
log
@increase th maximum string size for the sslciphers from 32 to 768.
this unbreaks some configurations that worked when sslciphers was a
dynamic charbuf.

ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.h,v 1.53 2007/06/18 17:29:38 pyr Exp $	*/
d405 2
a406 1
	TAILQ_ENTRY(session)		 entry;
d408 1
a408 1
TAILQ_HEAD(sessionlist, session);
d493 3
d537 1
a537 1
	struct sessionlist	 sessions;
d696 1
d699 1
@


1.53
log
@we're going to need more room for flags (again).
promote the field to u_int32_t.
no impact on hoststatectl.
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.h,v 1.52 2007/06/12 15:16:10 msf Exp $	*/
d482 1
a482 1
	char			 sslciphers[32];
@


1.52
log
@put the fd passing from bgpd back in to hoststated's version of imsg,
needed for layer 7 reload support.

ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.h,v 1.51 2007/05/31 03:24:05 pyr Exp $	*/
d290 16
a305 16
#define F_DISABLE		0x0001
#define F_BACKUP		0x0002
#define F_USED			0x0004
#define F_DOWN			0x0008
#define F_ADD			0x0010
#define F_DEL			0x0020
#define F_CHANGED		0x0040
#define F_STICKY		0x0080
#define F_CHECK_DONE		0x0100
#define F_ACTIVE_RULESET	0x0200
#define F_CHECK_SENT		0x0400
#define F_SSL			0x0800
#define F_NATLOOK		0x1000
#define F_DEMOTE		0x2000
#define F_LOOKUP_PATH		0x4000
#define F_DEMOTED		0x8000
d318 1
a318 1
	u_int16_t		 flags;
d339 1
a339 1
	u_int16_t		 flags;
d374 1
a374 1
	u_int16_t		 flags;
d475 1
a475 1
	u_int16_t		 flags;
d498 1
a498 1
	u_int16_t		 flags;
d553 1
a553 1
	u_int16_t		 flags;
@


1.51
log
@allocate table lists and service lists instead of using static structs.
split the code to start the event loop in two functions.
introduce merge_config which will be used later on.
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.h,v 1.50 2007/05/29 23:19:18 pyr Exp $	*/
d65 1
d83 5
d654 1
a654 1
	    void *, u_int16_t);
d661 1
@


1.50
log
@allow the control handling code to send messages back to the parent.
forward IMSG_CTL_RELOAD which ends up not doing anything for now.
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.h,v 1.49 2007/05/29 19:05:13 pyr Exp $	*/
d559 2
a560 2
	struct tablelist	 tables;
	struct servicelist	 services;
d722 1
@


1.49
log
@put the reload imsg types in right now. it makes my life easier.
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.h,v 1.48 2007/05/29 17:12:04 reyk Exp $	*/
d606 1
a606 1
int	control_listen(void);
@


1.48
log
@add a new check method which allows to run external scripts/programs
for custom evaluations.

pyr agrees to put it in now but to do some improvements of the timeout
handling later.
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.h,v 1.47 2007/05/29 00:48:04 pyr Exp $	*/
d128 11
@


1.47
log
@move the ssl cipher suite string to a (small) static charbuf,
this will make it easier to send the struct over the socket.
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.h,v 1.46 2007/05/29 00:21:10 pyr Exp $	*/
d128 2
a129 1
	IMSG_RECONF_END
d158 5
d351 2
a352 1
	CHECK_SEND_EXPECT	= 5
d684 5
@


1.46
log
@move struct relay to the runtime + config scheme.
this time around, include hoststatectl changes too.
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.h,v 1.45 2007/05/28 22:11:33 pyr Exp $	*/
d458 1
a458 1
	char			*sslciphers;
@


1.45
log
@another small step towards hoststated reloading.
allow purging of parts of the hoststated environment structure.
start using this function now to only keep vital information in
hoststated children processes.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.h,v 1.44 2007/05/28 17:37:16 pyr Exp $	*/
d472 1
a472 1
struct relay {
d475 16
a492 1
	char			 name[MAXHOSTNAMELEN];
a493 2
	in_port_t		 port;
	struct sockaddr_storage	 ss;
a496 2
	in_port_t		 dstport;
	struct sockaddr_storage	 dstss;
a502 3
	int			 dstmode;
	int			 dstcheck;
	int			 dstretry;
a504 1
	struct timeval		 timeout;
a509 1
	TAILQ_ENTRY(relay)	 entry;
@


1.44
log
@store the configuration file's path, this will be useful when reloading.
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.h,v 1.43 2007/05/27 20:53:10 pyr Exp $	*/
d51 6
d692 1
@


1.43
log
@Second step towards hoststated reload:
First split out hosts, tables and services into to structs, one that
contains the runtime fields and one (inside the runtime) that contains
mostly static fields that will be sent over the socket during reload.

Also move the demoted field of tables inside the flags field as its
just a boolean.
ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.h,v 1.42 2007/05/26 19:58:49 pyr Exp $	*/
d518 1
@


1.42
log
@first steps for implementing reload:
	* make parse_config allocate the hoststated function by itself
	* make as many sockets as necessary to talk to the relay children
	* add send_all for talking to all children
with advise and ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.h,v 1.41 2007/04/12 14:45:45 reyk Exp $	*/
d276 9
d287 2
a289 2
	objid_t			 id;
	objid_t			 tableid;
a290 1
	char			 name[MAXHOSTNAMELEN];
a295 3
	int			 retry;

	struct sockaddr_storage	 ss;
a296 1
	TAILQ_ENTRY(host)	 entry;
d307 1
a307 1
struct table {
a311 2
	int			 up;
	int			 demoted;
d313 1
a315 1
	struct timeval		 timeout;
a317 1
	char			*sendbuf;
d320 7
d328 2
a329 2
	struct hostlist		 hosts;
	TAILQ_ENTRY(table)	 entry;
d342 1
a342 1
struct service {
d346 2
d350 5
a357 1
	TAILQ_ENTRY(service)	 entry;
@


1.41
log
@add a new relay 'path' action to filter the URL path and arguments.

ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.h,v 1.40 2007/04/10 21:33:52 reyk Exp $	*/
d120 3
a122 1
	IMSG_STATISTICS
d572 2
a573 2
int	parse_config(struct hoststated *, const char *, int);
int	cmdline_symset(char *);
d612 2
a613 2
pid_t	 pfe(struct hoststated *, int [2], int [2], int [2], int [2],
	    int [RELAY_MAXPROC][2]);
d632 2
a633 2
pid_t	 hce(struct hoststated *, int [2], int [2], int [2], int [2],
	    int [RELAY_MAXPROC][2]);
d637 2
a638 2
pid_t	 relay(struct hoststated *, int [2], int [2], int [2], int [2],
	    int [RELAY_MAXPROC][2]);
@


1.40
log
@move the decoding of the URL, independent from the node lookups, we
will need it later.
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.h,v 1.39 2007/03/21 00:08:08 reyk Exp $	*/
d273 1
d377 2
a378 1
	NODE_TYPE_COOKIE	= 2
@


1.39
log
@in addition to the host retry option in tables, add support for the
optional connection "retry" to the forward to, service, and nat lookup
options. for example, "nat lookup retry 3" is useful when running
hoststated as a transparent proxy when connecting to unreliable
frontend/backend servers.

ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.h,v 1.38 2007/03/17 22:28:42 reyk Exp $	*/
d205 4
@


1.38
log
@move some elements in the relay imsg ctl structures (just for the style)
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.h,v 1.37 2007/03/13 12:04:52 reyk Exp $	*/
d466 1
@


1.37
log
@allow to specify the IP_TTL and IP_MINTTL options for the relays to
support the Generalized TTL Security Mechanism (GTSM) according to RFC
3682. this is especially useful with inbound connections and a fixed
distance to the backend servers.

ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.h,v 1.36 2007/03/05 11:44:50 reyk Exp $	*/
d221 2
a229 1
	int			 proc;
d235 1
a238 1

a240 1

@


1.36
log
@do not strip the header for expect, hash, and log actions.

since we have a tristate in relay_handle_http(), use nicer return
codes defined to make it better readble (no function change).
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.h,v 1.35 2007/02/27 13:38:58 reyk Exp $	*/
d409 2
d427 2
@


1.35
log
@in addition to actions on request headers, allow to define relay
actions on response headers (the reply sent by backend HTTP servers).
the default and slightly faster relay streaming mode will be used if
no actions are defined.

for example:
response change "Server" to "OpenBSD-hoststated/4.1"

ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.h,v 1.34 2007/02/26 12:35:43 reyk Exp $	*/
d380 6
@


1.34
log
@handle requests with chunked transfer-encoding.
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.h,v 1.33 2007/02/26 12:09:21 reyk Exp $	*/
d185 7
a191 1
	HTTP_METHOD_CONNECT	= 7
d204 1
d212 1
d426 4
a429 2
	int			 nodecount;
	struct proto_tree	 tree;
@


1.33
log
@improve the relay bufferevent handler if one side closed the connection
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.h,v 1.32 2007/02/26 11:59:48 reyk Exp $	*/
d202 1
@


1.32
log
@re-use the retry value from table host entries for inbound relay
connections. the relay will retry to connect to the hosts for the
specified number of times. this sounds bad, but is a useful
"workaround" for unreliable backend servers...
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.h,v 1.31 2007/02/25 14:57:09 reyk Exp $	*/
d202 1
@


1.31
log
@remove unused variable
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.h,v 1.30 2007/02/24 16:14:02 reyk Exp $	*/
d340 1
@


1.30
log
@disable anonymous DH by default (cipher suite HIGH:!ADH instead of HIGH).
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.h,v 1.29 2007/02/24 15:48:54 reyk Exp $	*/
a295 1
	int			 retry;
@


1.29
log
@disable SSLv2 and use "HIGH" crypto cipher suites by default.

suggested by dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.h,v 1.28 2007/02/24 00:22:32 reyk Exp $	*/
d401 1
a401 1
#define SSLCIPHERS_DEFAULT	"HIGH"
@


1.28
log
@- allow to specify the SSL cipher suite and the SSL protocols
  (as required by the PCI DSS)
- increase the default listen backlog to 10, allow to modify the
  backlog as a per-protocol tcp option to improve the performance
  on busy systems (to get less connection failures on heavy load)
- close the connection if SSL_accept returned an error
- instead of logging _new_ relay sessions to syslog, log the
  sessions in relay_close() after they have been _finished_.
  this will allow to collect some additional information
- add a new log keyword to log specified header/url entities (useful
  to track "bad guys" using many session ids or multiple user agents)
- some minor fixes, manpage bits, and bump the copyright (by some
  reason, i didn't realize that we already have 2007...).
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.h,v 1.27 2007/02/23 00:28:06 deraadt Exp $	*/
d399 3
a401 1
#define SSLFLAG_DEFAULT		(SSLFLAG_SSLV2|SSLFLAG_SSLV3|SSLFLAG_TLSV1)
@


1.27
log
@knf
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.h,v 1.26 2007/02/22 05:58:06 reyk Exp $	*/
d4 2
a5 2
 * Copyright (c) 2006 Pierre-Yves Ritschard <pyr@@spootnik.org>
 * Copyright (c) 2006 Reyk Floeter <reyk@@openbsd.org>
d45 1
d341 1
d355 2
a356 1
	NODE_ACTION_HASH	= 6
d359 12
d376 2
a377 4
	int			 macro;
	int			 getvars;
	int			 header;
	int			 mark;
d393 7
d404 1
a404 1
	u_int16_t		 tcpflags;
d406 3
@


1.26
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.h,v 1.25 2007/02/22 03:32:39 reyk Exp $	*/
d504 2
a505 2
int     control_init(void);
int     control_listen(void);
@


1.25
log
@Add layer 7 functionality to hoststated used for layer 7
loadbalancing, SSL acceleration, general-purpose TCP relaying, and
transparent proxying.

see hoststated.conf(5) and my upcoming article on undeadly.org for
details.

ok to commit deraadt@@ pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.h,v 1.24 2007/02/07 15:17:46 reyk Exp $	*/
d163 1
a163 1
	int		 	 s;
d168 2
a169 2
	struct timeval	 	 tv_start;
	struct event	 	 ev;
d201 1
a201 1
	enum httpmethod		 method;	
d331 3
a333 3
	objid_t			 	 id;
	struct ctl_relay_event	 	 in;
	struct ctl_relay_event	 	 out;
d336 1
a336 1
	struct timeval		 	 timeout;
d339 1
a339 1
	int			 	 done;
d342 1
a342 1
	TAILQ_ENTRY(session)	 	 entry;
@


1.24
log
@add new "log (updates|all)" configuration option to log state
notifications after completed host checks.  either only log the
"updates" to new states or log "all" state notifications, even if the
state didn't change. the log messages will be reported to syslog or to
stderr if the daemon is running in foreground mode.

ok claudio@@ pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.h,v 1.23 2007/02/07 13:39:58 reyk Exp $	*/
d5 1
d21 2
d38 8
d94 1
d108 1
d116 4
a119 1
	IMSG_SYNC
d139 2
d148 5
d176 60
d256 2
d267 5
d283 1
d291 2
d295 1
d330 108
d441 2
a442 1
	PROC_HCE
d451 2
d456 1
d460 4
d466 3
d529 1
d556 2
a557 1
pid_t	 pfe(struct hoststated *, int [2], int [2], int [2]);
d573 1
d576 2
a577 1
pid_t	 hce(struct hoststated *, int [2], int [2], int [2]);
d580 7
d611 11
@


1.23
log
@remove unused functions and variables which have been copied from
ospfd(8) (can be re-imported later if required).
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.h,v 1.22 2007/02/07 13:30:17 reyk Exp $	*/
d188 5
a192 3
#define HOST_DOWN		-1
#define HOST_UNKNOWN		0
#define HOST_UP			1
d214 8
a221 6
#define CHECK_NOCHECK		0
#define CHECK_ICMP		1
#define CHECK_TCP		2
#define CHECK_HTTP_CODE		3
#define CHECK_HTTP_DIGEST	4
#define CHECK_SEND_EXPECT	5
d264 5
a268 2
#define HOSTSTATED_OPT_VERBOSE	 0x01
#define HOSTSTATED_OPT_NOACTION	 0x04
d314 2
@


1.22
log
@add the -D option to define macros on the command line (as found in
bgpd(8), hostapd(8), ipsecctl(8), pfctl(8), ...).
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.h,v 1.21 2007/02/06 10:26:13 pyr Exp $	*/
a287 1
int     control_imsg_relay(struct imsg *);
a312 1
void		*buf_seek(struct buf *, size_t, size_t);
@


1.21
log
@now that check_http_code, check_http_digest and check_send_expect are
in check_tcp.c, prototype them in check_tcp.c
ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.h,v 1.20 2007/02/06 10:06:55 reyk Exp $	*/
d298 1
@


1.20
log
@declare the function ssl_error() globally
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.h,v 1.19 2007/02/06 08:45:46 pyr Exp $	*/
a361 7

/* check_http.c */
int	check_http_code(struct ctl_tcp_event *);
int	check_http_digest(struct ctl_tcp_event *);

/* check_send_expect.c */
int	check_send_expect(struct ctl_tcp_event *);
@


1.19
log
@inform hoststatectl monitor of ruleset changes and table syncs.
ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.h,v 1.18 2007/02/01 20:03:39 pyr Exp $	*/
d374 1
@


1.18
log
@add a monitor mode to hoststatectl to continuously report changes in
hoststated.
ok reyk@@, "looks nice and clean" niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.h,v 1.17 2007/01/29 14:23:31 pyr Exp $	*/
d83 3
@


1.17
log
@Add SSL support to hoststated.
with help and OK reyk@@
with help and advice by claudio@@ and Srebrenko Sehic
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.h,v 1.16 2007/01/12 17:05:18 pyr Exp $	*/
d92 1
d99 1
a99 2
	IMSG_TABLE_STATUS,	/* notifies from hce to pfe */
	IMSG_HOST_STATUS,
d273 2
d286 1
@


1.16
log
@use an u_int16_t for flags, the u_int8_t was getting too small.
ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.h,v 1.15 2007/01/12 16:43:01 pyr Exp $	*/
d146 2
d169 1
d203 1
d237 1
d363 5
@


1.15
log
@eliminate duplicate tcp read/write code.
ok claudio@@, reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.h,v 1.14 2007/01/11 18:05:08 reyk Exp $	*/
d156 11
a166 11
#define F_DISABLE		0x01
#define F_BACKUP		0x02
#define F_CHECK_DONE		0x02 /* reused for host */
#define F_USED			0x04
#define F_ACTIVE_RULESET	0x04 /* reused for service */
#define F_CHECK_SENT		0x04 /* reused for host */
#define F_DOWN			0x08
#define F_ADD			0x10
#define F_DEL			0x20
#define F_CHANGED		0x40
#define F_STICKY		0x80
d169 1
a169 1
	u_int8_t		 flags;
d189 1
a189 1
	u_int8_t		 flags;
d214 1
a214 1
	u_int8_t		 flags;
@


1.14
log
@use real async events for checks and improve the non-blocking socket
usage. also modify the check_icmp code to use non-blocking raw sockets
and merge the icmp4 and icmp6 functions. some other minor changes
while i'm here.

as discussed with pyr@@ claudio@@ deraadt@@
ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.h,v 1.13 2007/01/09 13:50:11 pyr Exp $	*/
d138 1
d144 2
d197 1
a197 1
	char			 sendbuf[64];
d353 2
a354 1
void	 send_http_request(int, short, void *);
d357 1
a357 1
void	 start_send_expect(int, short, void *);
@


1.13
log
@Finish renaming hostated to hoststated.
Note to testers: the user the daemon changes its id to is now _hoststated,
don't forget to update master.passwd.
ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.h,v 1.12 2007/01/09 03:32:56 reyk Exp $	*/
d129 2
a130 4
	int			 icmp_sock;
	int			 icmp6_sock;
	int			 has_icmp4;
	int			 has_icmp6;
d137 6
a142 5
	int		 s;
	struct buf	*buf;
	struct host	*host;
	struct table	*table;
	struct timeval	 tv_start;
d158 1
a230 2
	int			 icmp_sock;
	int			 icmp6_sock;
d239 8
a246 1
	struct ctl_icmp_event	 cie;
d342 3
a344 2
void	 schedule_icmp(struct ctl_icmp_event *, struct table *);
void	 check_icmp(struct ctl_icmp_event *);
d350 1
a350 1
void	 send_http_request(struct ctl_tcp_event *);
d353 1
a353 1
void	 start_send_expect(struct ctl_tcp_event *);
d362 3
@


1.12
log
@use the correct buffer sizes.

(this code needs some more work to implement a better icmp handling,
but this will fix a serious bug for now)
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.h,v 1.11 2007/01/08 20:46:18 reyk Exp $	*/
d20 14
a33 14
#define CONF_FILE	"/etc/hostated.conf"
#define HOSTATED_SOCKET	"/var/run/hostated.sock"
#define PF_SOCKET	"/dev/pf"
#define HOSTATED_USER	"_hostated"
#define HOSTATED_ANCHOR	"hostated"
#define CHECK_TIMEOUT	200
#define CHECK_INTERVAL	10
#define EMPTY_TABLE	UINT_MAX
#define EMPTY_ID	UINT_MAX
#define TABLE_NAME_SIZE	32
#define	TAG_NAME_SIZE	64
#define SRV_NAME_SIZE	64
#define MAX_NAME_SIZE	64
#define SRV_MAX_VIRTS	16
d77 1
a77 1
	IMSG_CTL_OK,		/* answer to hostatectl requests */
d83 1
a83 1
	IMSG_CTL_SHOW_SUM,	/* hostatectl requests */
d128 8
a135 8
	struct hostated	*env;
	int		 icmp_sock;
	int		 icmp6_sock;
	int		 has_icmp4;
	int		 has_icmp6;
	int		 last_up;
	struct event	 ev;
	struct timeval	 tv_start;
d226 1
a226 1
} hostated_process;
d228 1
a228 1
struct hostated {
d244 2
a245 2
#define HOSTATED_OPT_VERBOSE	 0x01
#define HOSTATED_OPT_NOACTION	 0x04
d278 1
a278 1
int	parse_config(struct hostated *, const char *, int);
d315 1
a315 1
pid_t	 pfe(struct hostated *, int [2], int [2], int [2]);
d325 6
a330 6
void	 init_filter(struct hostated *);
void	 init_tables(struct hostated *);
void	 flush_table(struct hostated *, struct service *);
void	 sync_table(struct hostated *, struct service *, struct table *);
void	 sync_ruleset(struct hostated *, struct service *, int);
void	 flush_rulesets(struct hostated *);
d333 1
a333 1
pid_t	 hce(struct hostated *, int [2], int [2], int [2]);
d349 7
a355 7
/* hostated.c */
struct host	*host_find(struct hostated *, objid_t);
struct table	*table_find(struct hostated *, objid_t);
struct service	*service_find(struct hostated *, objid_t);
struct host	*host_findbyname(struct hostated *, const char *);
struct table	*table_findbyname(struct hostated *, const char *);
struct service	*service_findbyname(struct hostated *, const char *);
@


1.11
log
@do NOT use the regexp interface. it is way to complicated, error-prone
and we don't know about all the possible security problems.

change the check send/expect code to use the fnmatch(3) interface
using shell globbing rules instead. this allows simple patterns like
"220 * ESMTP*" or "SSH-[12].??-*".

suggested by deraadt@@ and otto@@
ok Pierre-Yves Ritschard (pyr at spootnik dot org)
@
text
@d1 1
a1 1
/*	$OpenBSD: hostated.h,v 1.10 2007/01/08 16:52:58 reyk Exp $	*/
d37 1
@


1.10
log
@the timeout values are not allowed to exceed the global interval (i
figured this out while testing hostated against a stottering spamd
where the send/expect timeout needs be > 10 seconds). also use another
struct timeval to store the interval for easier handling in the code.

ok Pierre-Yves Ritschard (pyr at spootnik dot org)
@
text
@d1 1
a1 1
/*	$OpenBSD: hostated.h,v 1.9 2007/01/08 13:37:26 reyk Exp $	*/
a196 1
	regex_t			 regx;
@


1.9
log
@add a generic send/expect check using regular expression (see
regex(3)).  this allows to define additional checks for other TCP
protocols.

From Pierre-Yves Ritschard (pyr at spootnik dot org)
@
text
@d1 1
a1 1
/*	$OpenBSD: hostated.h,v 1.8 2007/01/03 09:45:29 reyk Exp $	*/
a230 1
	int			 interval;
d235 1
@


1.8
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: hostated.h,v 1.7 2007/01/03 09:42:30 reyk Exp $	*/
d193 2
d197 1
d207 1
d345 3
@


1.7
log
@allow the sticky-address option for round-robin pools.

From Pierre-Yves Ritschard (pyr at spootnik dot org)
@
text
@d1 1
a1 1
/*	$OpenBSD: hostated.h,v 1.6 2006/12/26 02:51:00 jsg Exp $	*/
d140 1
a140 1
	struct host 	*host;
@


1.6
log
@Add missing $OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d162 1
@


1.5
log
@fix the conversion from milliseconds to struct timeval, which uses
seconds (tv_sec) and microseconds (tv_usec), but the code assumed
seconds and milliseconds...
@
text
@d1 2
@


1.4
log
@partial rewrite of the check_* routines to use libevent everywhere
instead of nested select() calls and to handle the non-blocking
sockets properly.

From Pierre-Yves Ritschard (pyr at spootnik dot org)
(with a little help by me)
@
text
@d187 1
a187 1
	int			 timeout;
d229 1
a229 1
	int			 timeout;
@


1.3
log
@- allow to use host/service/table names instead of Ids in hostatectl.
- minor change of the "hostatectl show" command output
- increase the max service and tag names (max pf tag name size is 64 now!)

thanks to pyr who found a bug in my initial diff
@
text
@d23 1
a23 1
#define CONNECT_TIMEOUT 200
d33 2
a34 1
#define READ_BUF_SIZE	65535
d124 19
d153 1
d155 1
a155 1
#define F_ACTIVE_RULESET	0x04
d168 1
d170 1
d229 1
d234 1
d327 1
d330 2
a331 1
int	 check_icmp(struct host *, int, int, int);
d334 1
a334 2
int	 check_tcp(struct host *, struct table *);
int	 tcp_connect(struct host *, struct table *);
d336 2
a337 3
/* check_tcp.c */
int	 check_http_code(struct host *, struct table *);
int	 check_http_digest(struct host *, struct table *);
@


1.2
log
@knf, spacing

please note that some editors will replace tabs with multiple spaces
if you cut & paste code from other sections.  please try to keep the
tabs ;).
@
text
@d26 5
a30 3
#define TABLE_NAME_SIZE	16
#define	TAG_NAME_SIZE	16
#define SRV_NAME_SIZE	16
d118 5
d285 6
a290 6
int	 enable_service(struct ctl_conn *, objid_t);
int	 enable_table(struct ctl_conn *, objid_t);
int	 enable_host(struct ctl_conn *, objid_t);
int	 disable_service(struct ctl_conn *, objid_t);
int	 disable_table(struct ctl_conn *, objid_t);
int	 disable_host(struct ctl_conn *, objid_t);
d318 3
@


1.1
log
@Import hostated, the host status daemon.  This daemon will monitor
remote hosts and dynamically alter pf(4) tables and redirection rules
for active server load balancing.  The daemon has been written by
Pierre-Yves Ritschard (pyr at spootnik.org) and was formerly known as
"slbd".

The daemon is fully functional but it still needs some work and
cleanup so we don't link it to the build yet.  Some TODOs are a
partial rewrite of the check_* routines (use libevent whenever we
can), improvement of the manpages, and general knf and cleanup.

ok deraadt@@ claudio@@
@
text
@d35 6
a40 6
        TAILQ_ENTRY(buf)         entry;
        u_char                  *buf;
        size_t                   size;
        size_t                   max;
        size_t                   wpos;
        size_t                   rpos;
d44 3
a46 3
        TAILQ_HEAD(, buf)        bufs;
        u_int32_t                queued;
        int                      fd;
d49 7
a55 7
#define IMSG_HEADER_SIZE        sizeof(struct imsg_hdr)
#define MAX_IMSGSIZE            8192

struct buf_read {  
        u_char                   buf[READ_BUF_SIZE];
        u_char                  *rptr;              
        size_t                   wpos;
d59 8
a66 8
        TAILQ_HEAD(, imsg_fd)   fds;
        struct buf_read         r;
        struct msgbuf           w;
        struct event            ev;
        void                    (*handler)(int, short, void *);
        int                     fd;
        pid_t                   pid;
        short                   events;
d98 4
a101 4
        enum imsg_type  type;
        u_int16_t       len;
        u_int32_t       peerid;
        pid_t           pid;
d105 2
a106 2
        struct imsg_hdr  hdr;
        void            *data;
d109 1
a109 1
typedef u_int32_t	 objid_t;
d124 8
a131 8
#define F_DISABLE		 0x01
#define F_BACKUP		 0x02
#define F_USED			 0x04
#define F_ACTIVE_RULESET	 0x04
#define F_DOWN			 0x08
#define F_ADD			 0x10
#define F_DEL		 	 0x20
#define F_CHANGED	 	 0x40
a139 3
#define HOST_DOWN		 -1
#define HOST_UNKNOWN		 0
#define HOST_UP			 1
d145 4
a153 5
#define CHECK_NOCHECK		 0
#define CHECK_ICMP		 1
#define CHECK_TCP		 2
#define CHECK_HTTP_CODE		 3
#define CHECK_HTTP_DIGEST	 4
d156 1
a156 1
	int			 retcode;	
d166 6
d192 1
a192 3
        u_int8_t                 opts;
#define HOSTATED_OPT_VERBOSE	 0x01
#define HOSTATED_OPT_NOACTION	 0x04
d205 3
d210 2
a211 2
        struct event    ev;
        int             fd;
d215 2
a216 2
        BM_NORMAL,
        BM_NONBLOCK
d220 2
a221 2
        TAILQ_ENTRY(ctl_conn)   entry;
        struct imsgbuf          ibuf;
d239 1
a239 1
int		 parse_config(struct hostated *, const char *, int);
d242 7
a248 7
void             log_init(int);
void             log_warn(const char *, ...);
void             log_warnx(const char *, ...);
void             log_info(const char *, ...);
void             log_debug(const char *, ...);
void             fatal(const char *);
void             fatalx(const char *);
d251 10
a260 10
struct buf      *buf_open(size_t);
struct buf      *buf_dynamic(size_t, size_t);
int              buf_add(struct buf *, void *, size_t);
void            *buf_reserve(struct buf *, size_t);
void            *buf_seek(struct buf *, size_t, size_t);
int              buf_close(struct msgbuf *, struct buf *);
void             buf_free(struct buf *);
void             msgbuf_init(struct msgbuf *);
void             msgbuf_clear(struct msgbuf *);
int              msgbuf_write(struct msgbuf *);
d263 11
a273 11
void     imsg_init(struct imsgbuf *, int, void (*)(int, short, void *));
ssize_t  imsg_read(struct imsgbuf *);
ssize_t  imsg_get(struct imsgbuf *, struct imsg *);
int      imsg_compose(struct imsgbuf *, enum imsg_type, u_int32_t, pid_t,
            void *, u_int16_t);
struct buf      *imsg_create(struct imsgbuf *, enum imsg_type, u_int32_t, pid_t,
                    u_int16_t);
int      imsg_add(struct buf *, void *, u_int16_t);
int      imsg_close(struct imsgbuf *, struct buf *);
void     imsg_free(struct imsg *);
void     imsg_event_add(struct imsgbuf *); /* needs to be provided externally */
@

