head	1.20;
access;
symbols
	OPENBSD_4_2:1.17.0.2
	OPENBSD_4_2_BASE:1.17
	OPENBSD_4_1:1.15.0.2
	OPENBSD_4_1_BASE:1.15;
locks; strict;
comment	@ * @;


1.20
date	2007.12.07.17.27.07;	author deraadt;	state dead;
branches;
next	1.19;

1.19
date	2007.11.24.17.07.28;	author reyk;	state Exp;
branches;
next	1.18;

1.18
date	2007.09.28.13.29.56;	author pyr;	state Exp;
branches;
next	1.17;

1.17
date	2007.05.31.03.24.05;	author pyr;	state Exp;
branches;
next	1.16;

1.16
date	2007.05.27.20.53.10;	author pyr;	state Exp;
branches;
next	1.15;

1.15
date	2007.02.22.05.58.06;	author reyk;	state Exp;
branches;
next	1.14;

1.14
date	2007.02.22.03.32.40;	author reyk;	state Exp;
branches;
next	1.13;

1.13
date	2007.02.20.04.06.17;	author reyk;	state Exp;
branches;
next	1.12;

1.12
date	2007.02.08.13.32.24;	author reyk;	state Exp;
branches;
next	1.11;

1.11
date	2007.02.07.14.45.12;	author reyk;	state Exp;
branches;
next	1.10;

1.10
date	2007.01.29.14.23.31;	author pyr;	state Exp;
branches;
next	1.9;

1.9
date	2007.01.09.13.50.11;	author pyr;	state Exp;
branches;
next	1.8;

1.8
date	2007.01.09.00.45.32;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2007.01.08.20.46.18;	author reyk;	state Exp;
branches;
next	1.6;

1.6
date	2007.01.08.17.10.23;	author reyk;	state Exp;
branches;
next	1.5;

1.5
date	2007.01.08.13.37.26;	author reyk;	state Exp;
branches;
next	1.4;

1.4
date	2007.01.05.16.39.23;	author reyk;	state Exp;
branches;
next	1.3;

1.3
date	2007.01.03.09.42.30;	author reyk;	state Exp;
branches;
next	1.2;

1.2
date	2006.12.16.12.42.14;	author reyk;	state Exp;
branches;
next	1.1;

1.1
date	2006.12.16.11.45.07;	author reyk;	state Exp;
branches;
next	;


desc
@@


1.20
log
@hoststated/hoststatectl get repository copied (and de-tagged) into
relayd/relayctl.  This is a more suitable place for a daemon that has
grown out of it's initial roots of "monitoring and redirecting services
at various layers", into one that is "a full featured proxy, which
happens to know what is up/down"
@
text
@/*	$OpenBSD: pfe_filter.c,v 1.19 2007/11/24 17:07:28 reyk Exp $	*/

/*
 * Copyright (c) 2006 Pierre-Yves Ritschard <pyr@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/queue.h>
#include <sys/socket.h>
#include <sys/ioctl.h>

#include <net/if.h>
#include <net/pfvar.h>
#include <netinet/in.h>
#include <arpa/inet.h>

#include <limits.h>
#include <fcntl.h>
#include <event.h>
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <errno.h>

#include <openssl/ssl.h>

#include "hoststated.h"

struct pfdata {
	int			 dev;
	struct pf_anchor	*anchor;
	struct pfioc_trans	 pft;
	struct pfioc_trans_e	 pfte;
};

int	 transaction_init(struct hoststated *, const char *);
int	 transaction_commit(struct hoststated *);
void	 kill_tables(struct hoststated *);

void
init_filter(struct hoststated *env)
{
	struct pf_status	status;

	if ((env->pf = calloc(1, sizeof(*(env->pf)))) == NULL)
		fatal("calloc");
	if ((env->pf->dev = open(PF_SOCKET, O_RDWR)) == -1)
		fatal("init_filter: cannot open pf socket");
	if (ioctl(env->pf->dev, DIOCGETSTATUS, &status) == -1)
		fatal("init_filter: DIOCGETSTATUS");
	if (!status.running)
		fatalx("init_filter: pf is disabled");
	log_debug("init_filter: filter init done");
}

void
init_tables(struct hoststated *env)
{
	int			 i;
	struct service		*service;
	struct pfr_table	*tables;
	struct pfioc_table	 io;

	if ((tables = calloc(env->servicecount, sizeof(*tables))) == NULL)
		fatal("calloc");
	i = 0;

	TAILQ_FOREACH(service, env->services, entry) {
		if (strlcpy(tables[i].pfrt_anchor, HOSTSTATED_ANCHOR "/",
		    sizeof(tables[i].pfrt_anchor)) >= PF_ANCHOR_NAME_SIZE)
			goto toolong;
		if (strlcat(tables[i].pfrt_anchor, service->conf.name,
		    sizeof(tables[i].pfrt_anchor)) >= PF_ANCHOR_NAME_SIZE)
			goto toolong;
		if (strlcpy(tables[i].pfrt_name, service->conf.name,
		    sizeof(tables[i].pfrt_name)) >=
		    sizeof(tables[i].pfrt_name))
			goto toolong;
		tables[i].pfrt_flags |= PFR_TFLAG_PERSIST;
		i++;
	}
	if (i != env->servicecount)
		fatalx("init_tables: table count modified");

	memset(&io, 0, sizeof(io));
	io.pfrio_size = env->servicecount;
	io.pfrio_esize = sizeof(*tables);
	io.pfrio_buffer = tables;

	if (ioctl(env->pf->dev, DIOCRADDTABLES, &io) == -1)
		fatal("init_tables: cannot create tables");
	log_debug("init_tables: created %d tables", io.pfrio_nadd);

	free(tables);

	if (io.pfrio_nadd == env->servicecount)
		return;

	/*
	 * clear all tables, since some already existed
	 */
	TAILQ_FOREACH(service, env->services, entry)
		flush_table(env, service);

	return;

 toolong:
	fatal("init_tables: name too long");
}

void
kill_tables(struct hoststated *env) {
	struct pfioc_table	 io;
	struct service		*service;

	memset(&io, 0, sizeof(io));
	TAILQ_FOREACH(service, env->services, entry) {
		if (strlcpy(io.pfrio_table.pfrt_anchor, HOSTSTATED_ANCHOR "/",
		    sizeof(io.pfrio_table.pfrt_anchor)) >= PF_ANCHOR_NAME_SIZE)
			goto toolong;
		if (strlcat(io.pfrio_table.pfrt_anchor, service->conf.name,
		    sizeof(io.pfrio_table.pfrt_anchor)) >= PF_ANCHOR_NAME_SIZE)
			goto toolong;
		if (ioctl(env->pf->dev, DIOCRCLRTABLES, &io) == -1)
			fatal("kill_tables: ioctl faile: ioctl failed");
	}
	log_debug("kill_tables: deleted %d tables", io.pfrio_ndel);
	return;

 toolong:
	fatal("kill_tables: name too long");
}

void
sync_table(struct hoststated *env, struct service *service, struct table *table)
{
	int			 i;
	struct pfioc_table	 io;
	struct pfr_addr		*addlist;
	struct sockaddr_in	*sain;
	struct sockaddr_in6	*sain6;
	struct host		*host;

	if (table == NULL)
		return;

	if (table->up == 0) {
		flush_table(env, service);
		return;
	}

	if ((addlist = calloc(table->up, sizeof(*addlist))) == NULL)
		fatal("calloc");

	memset(&io, 0, sizeof(io));
	io.pfrio_esize = sizeof(struct pfr_addr);
	io.pfrio_size = table->up;
	io.pfrio_size2 = 0;
	io.pfrio_buffer = addlist;
	if (strlcpy(io.pfrio_table.pfrt_anchor, HOSTSTATED_ANCHOR "/",
	    sizeof(io.pfrio_table.pfrt_anchor)) >= PF_ANCHOR_NAME_SIZE)
		goto toolong;
	if (strlcat(io.pfrio_table.pfrt_anchor, service->conf.name,
	    sizeof(io.pfrio_table.pfrt_anchor)) >= PF_ANCHOR_NAME_SIZE)
		goto toolong;
	if (strlcpy(io.pfrio_table.pfrt_name, service->conf.name,
	    sizeof(io.pfrio_table.pfrt_name)) >=
	    sizeof(io.pfrio_table.pfrt_name))
		goto toolong;

	i = 0;
	TAILQ_FOREACH(host, &table->hosts, entry) {
		if (host->up != HOST_UP)
			continue;
		memset(&(addlist[i]), 0, sizeof(addlist[i]));
		switch (host->conf.ss.ss_family) {
		case AF_INET:
			sain = (struct sockaddr_in *)&host->conf.ss;
			addlist[i].pfra_af = AF_INET;
			memcpy(&(addlist[i].pfra_ip4addr), &sain->sin_addr,
			    sizeof(sain->sin_addr));
			addlist[i].pfra_net = 32;
			break;
		case AF_INET6:
			sain6 = (struct sockaddr_in6 *)&host->conf.ss;
			addlist[i].pfra_af = AF_INET6;
			memcpy(&(addlist[i].pfra_ip6addr), &sain6->sin6_addr,
			    sizeof(sain6->sin6_addr));
			addlist[i].pfra_net = 128;
			break;
		default:
			fatalx("sync_table: unknown address family");
			break;
		}
		i++;
	}
	if (i != table->up)
		fatalx("sync_table: desynchronized");

	if (ioctl(env->pf->dev, DIOCRSETADDRS, &io) == -1)
		fatal("sync_table: cannot set address list");

	free(addlist);

	log_debug("sync_table: table %s: %d added, %d deleted, %d changed",
	    io.pfrio_table.pfrt_name,
	    io.pfrio_nadd, io.pfrio_ndel, io.pfrio_nchange);
	return;

 toolong:
	fatal("sync_table: name too long");
}

void
flush_table(struct hoststated *env, struct service *service)
{
	struct pfioc_table	io;

	memset(&io, 0, sizeof(io));
	if (strlcpy(io.pfrio_table.pfrt_anchor, HOSTSTATED_ANCHOR "/",
	    sizeof(io.pfrio_table.pfrt_anchor)) >= PF_ANCHOR_NAME_SIZE)
		goto toolong;
	if (strlcat(io.pfrio_table.pfrt_anchor, service->conf.name,
	    sizeof(io.pfrio_table.pfrt_anchor)) >= PF_ANCHOR_NAME_SIZE)
		goto toolong;
	if (strlcpy(io.pfrio_table.pfrt_name, service->conf.name,
	    sizeof(io.pfrio_table.pfrt_name)) >=
	    sizeof(io.pfrio_table.pfrt_name))
		goto toolong;
	if (ioctl(env->pf->dev, DIOCRCLRADDRS, &io) == -1)
		fatal("flush_table: cannot flush table");
	log_debug("flush_table: flushed table %s", service->conf.name);
	return;

 toolong:
	fatal("flush_table: name too long");
}

int
transaction_init(struct hoststated *env, const char *anchor)
{
	env->pf->pft.size = 1;
	env->pf->pft.esize = sizeof env->pf->pfte;
	env->pf->pft.array = &env->pf->pfte;

	memset(&env->pf->pfte, 0, sizeof env->pf->pfte);
	(void)strlcpy(env->pf->pfte.anchor, anchor, PF_ANCHOR_NAME_SIZE);
	env->pf->pfte.rs_num = PF_RULESET_RDR;

	if (ioctl(env->pf->dev, DIOCXBEGIN, &env->pf->pft) == -1)
		return (-1);
	return (0);
}

int
transaction_commit(struct hoststated *env)
{
	if (ioctl(env->pf->dev, DIOCXCOMMIT, &env->pf->pft) == -1)
		return (-1);
	return (0);
}

void
sync_ruleset(struct hoststated *env, struct service *service, int enable)
{
	struct pfioc_rule	 rio;
	struct pfioc_pooladdr	 pio;
	struct sockaddr_in	*sain;
	struct sockaddr_in6	*sain6;
	struct address		*address;
	char			 anchor[PF_ANCHOR_NAME_SIZE];

	bzero(anchor, sizeof(anchor));
	if (strlcpy(anchor, HOSTSTATED_ANCHOR "/", sizeof(anchor)) >=
	    PF_ANCHOR_NAME_SIZE)
		goto toolong;
	if (strlcat(anchor, service->conf.name, sizeof(anchor)) >=
	    PF_ANCHOR_NAME_SIZE)
		goto toolong;
	if (transaction_init(env, anchor) == -1) {
		log_warn("sync_ruleset: transaction init failed");
		return;
	}

	if (!enable) {
		if (transaction_commit(env) == -1)
			log_warn("sync_ruleset: "
			    "remove rules transaction failed");
		else
			log_debug("sync_ruleset: rules removed");
		return;
	}

	TAILQ_FOREACH(address, &service->virts, entry) {
		memset(&rio, 0, sizeof(rio));
		memset(&pio, 0, sizeof(pio));
		(void)strlcpy(rio.anchor, anchor, sizeof(rio.anchor));

		rio.ticket = env->pf->pfte.ticket;
		if (ioctl(env->pf->dev, DIOCBEGINADDRS, &pio) == -1)
			fatal("sync_ruleset: cannot initialise address pool");

		rio.pool_ticket = pio.ticket;
		rio.rule.af = address->ss.ss_family;
		rio.rule.proto = IPPROTO_TCP;
		rio.rule.src.addr.type = PF_ADDR_ADDRMASK;
		rio.rule.dst.addr.type = PF_ADDR_ADDRMASK;
		rio.rule.dst.port_op = PF_OP_EQ;
		rio.rule.dst.port[0] = address->port;
		rio.rule.rtableid = -1; /* stay in the main routing table */
		rio.rule.action = PF_RDR;
		if (strlen(service->conf.tag))
			(void)strlcpy(rio.rule.tagname, service->conf.tag,
			    sizeof(rio.rule.tagname));
		if (strlen(address->ifname))
			(void)strlcpy(rio.rule.ifname, address->ifname,
			    sizeof(rio.rule.ifname));

		if (address->ss.ss_family == AF_INET) {
			sain = (struct sockaddr_in *)&address->ss;

			rio.rule.dst.addr.v.a.addr.addr32[0] =
			    sain->sin_addr.s_addr;
			rio.rule.dst.addr.v.a.mask.addr32[0] = 0xffffffff;

		} else {
			sain6 = (struct sockaddr_in6 *)&address->ss;

			memcpy(&rio.rule.dst.addr.v.a.addr.v6,
			    &sain6->sin6_addr.s6_addr,
			    sizeof(sain6->sin6_addr.s6_addr));
			memset(&rio.rule.dst.addr.v.a.mask.addr8, 0xff, 16);
		}

		pio.addr.addr.type = PF_ADDR_TABLE;
		if (strlcpy(pio.addr.addr.v.tblname, service->conf.name,
		    sizeof(pio.addr.addr.v.tblname)) >=
		    sizeof(pio.addr.addr.v.tblname))
			fatal("sync_ruleset: table name too long");
		if (ioctl(env->pf->dev, DIOCADDADDR, &pio) == -1)
			fatal("sync_ruleset: cannot add address to pool");

		rio.rule.rpool.proxy_port[0] = ntohs(service->table->conf.port);
		rio.rule.rpool.port_op = PF_OP_EQ;
		rio.rule.rpool.opts = PF_POOL_ROUNDROBIN;
		if (service->conf.flags & F_STICKY)
			rio.rule.rpool.opts |= PF_POOL_STICKYADDR;

		if (ioctl(env->pf->dev, DIOCADDRULE, &rio) == -1)
			fatal("cannot add rule");
		log_debug("sync_ruleset: rule added");
	}
	if (transaction_commit(env) == -1)
		log_warn("sync_ruleset: add rules transaction failed");
	return;

 toolong:
	fatal("sync_ruleset: name too long");
}

void
flush_rulesets(struct hoststated *env)
{
	struct service	*service;
	char		 anchor[PF_ANCHOR_NAME_SIZE];

	kill_tables(env);
	TAILQ_FOREACH(service, env->services, entry) {
		if (strlcpy(anchor, HOSTSTATED_ANCHOR "/", sizeof(anchor)) >=
		    PF_ANCHOR_NAME_SIZE)
			goto toolong;
		if (strlcat(anchor, service->conf.name, sizeof(anchor)) >=
		    PF_ANCHOR_NAME_SIZE)
			goto toolong;
		if (transaction_init(env, anchor) == -1 ||
		    transaction_commit(env) == -1)
			log_warn("flush_rulesets: transaction for %s/ failed",
			    HOSTSTATED_ANCHOR);
	}
	if (strlcpy(anchor, HOSTSTATED_ANCHOR, sizeof(anchor)) >=
	    PF_ANCHOR_NAME_SIZE)
		goto toolong;
	if (transaction_init(env, anchor) == -1 ||
	    transaction_commit(env) == -1)
		log_warn("flush_rulesets: transaction for %s failed",
		    HOSTSTATED_ANCHOR);
	log_debug("flush_rulesets: flushed rules");
	return;

 toolong:
	fatal("flush_rulesets: name too long");
}

int
natlook(struct hoststated *env, struct ctl_natlook *cnl)
{
	struct pfioc_natlook	 pnl;
	struct sockaddr_in	*in, *out;
	struct sockaddr_in6	*in6, *out6;
	char			 ibuf[BUFSIZ], obuf[BUFSIZ];

	bzero(&pnl, sizeof(pnl));

	if ((pnl.af = cnl->src.ss_family) != cnl->dst.ss_family)
		fatalx("natlook: illegal address families");
	switch (pnl.af) {
	case AF_INET:
		in = (struct sockaddr_in *)&cnl->src;
		out = (struct sockaddr_in *)&cnl->dst;
		bcopy(&in->sin_addr, &pnl.saddr.addr8, in->sin_len);
		pnl.sport = in->sin_port;
		bcopy(&out->sin_addr, &pnl.daddr.addr8, out->sin_len);
		pnl.dport = out->sin_port;
		break;
	case AF_INET6:
		in6 = (struct sockaddr_in6 *)&cnl->src;
		out6 = (struct sockaddr_in6 *)&cnl->dst;
		bcopy(&in6->sin6_addr, &pnl.saddr.addr8, in6->sin6_len);
		pnl.sport = in6->sin6_port;
		bcopy(&out6->sin6_addr, &pnl.daddr.addr8, out6->sin6_len);
		pnl.dport = out6->sin6_port;
	}
	pnl.proto = IPPROTO_TCP;
	pnl.direction = PF_IN;
	cnl->in = 1;

	if (ioctl(env->pf->dev, DIOCNATLOOK, &pnl) == -1) {
		pnl.direction = PF_OUT;
		cnl->in = 0;
		if (ioctl(env->pf->dev, DIOCNATLOOK, &pnl) == -1) {
			log_debug("natlook: error");
			return (-1);
		}
	}

	inet_ntop(pnl.af, &pnl.rsaddr, ibuf, sizeof(ibuf));
	inet_ntop(pnl.af, &pnl.rdaddr, obuf, sizeof(obuf));
	log_debug("natlook: %s %s:%d -> %s:%d",
	    pnl.direction == PF_IN ? "in" : "out",
	    ibuf, ntohs(pnl.rsport), obuf, ntohs(pnl.rdport));

	switch (pnl.af) {
	case AF_INET:
		in = (struct sockaddr_in *)&cnl->rsrc;
		out = (struct sockaddr_in *)&cnl->rdst;
		bcopy(&pnl.rsaddr.addr8, &in->sin_addr, sizeof(in->sin_addr));
		in->sin_port = pnl.rsport;
		bcopy(&pnl.rdaddr.addr8, &out->sin_addr, sizeof(out->sin_addr));
		out->sin_port = pnl.rdport;
		break;
	case AF_INET6:
		in6 = (struct sockaddr_in6 *)&cnl->rsrc;
		out6 = (struct sockaddr_in6 *)&cnl->rdst;
		bcopy(&pnl.rsaddr.addr8, &in6->sin6_addr,
		    sizeof(in6->sin6_addr));
		bcopy(&pnl.rdaddr.addr8, &out6->sin6_addr,
		    sizeof(out6->sin6_addr));
		break;
	}
	cnl->rsrc.ss_family = pnl.af;
	cnl->rdst.ss_family = pnl.af;
	cnl->rsport = pnl.rsport;
	cnl->rdport = pnl.rdport;

	return (0);
}
@


1.19
log
@sort includes, adjust to style(9)
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe_filter.c,v 1.18 2007/09/28 13:29:56 pyr Exp $	*/
@


1.18
log
@Correct my mail address.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe_filter.c,v 1.17 2007/05/31 03:24:05 pyr Exp $	*/
a22 1
#include <sys/param.h>
@


1.17
log
@allocate table lists and service lists instead of using static structs.
split the code to start the event loop in two functions.
introduce merge_config which will be used later on.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe_filter.c,v 1.16 2007/05/27 20:53:10 pyr Exp $	*/
d4 1
a4 1
 * Copyright (c) 2006 Pierre-Yves Ritschard <pyr@@spootnik.org>
@


1.16
log
@Second step towards hoststated reload:
First split out hosts, tables and services into to structs, one that
contains the runtime fields and one (inside the runtime) that contains
mostly static fields that will be sent over the socket during reload.

Also move the demoted field of tables inside the flags field as its
just a boolean.
ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe_filter.c,v 1.15 2007/02/22 05:58:06 reyk Exp $	*/
d81 1
a81 1
	TAILQ_FOREACH(service, &env->services, entry) {
d115 1
a115 1
	TAILQ_FOREACH(service, &env->services, entry)
d130 1
a130 1
	TAILQ_FOREACH(service, &env->services, entry) {
d381 1
a381 1
	TAILQ_FOREACH(service, &env->services, entry) {
@


1.15
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe_filter.c,v 1.14 2007/02/22 03:32:40 reyk Exp $	*/
d85 1
a85 1
		if (strlcat(tables[i].pfrt_anchor, service->name,
d88 1
a88 1
		if (strlcpy(tables[i].pfrt_name, service->name,
d134 1
a134 1
		if (strlcat(io.pfrio_table.pfrt_anchor, service->name,
d176 1
a176 1
	if (strlcat(io.pfrio_table.pfrt_anchor, service->name,
d179 1
a179 1
	if (strlcpy(io.pfrio_table.pfrt_name, service->name,
d189 1
a189 1
		switch (host->ss.ss_family) {
d191 1
a191 1
			sain = (struct sockaddr_in *)&host->ss;
d198 1
a198 1
			sain6 = (struct sockaddr_in6 *)&host->ss;
d236 1
a236 1
	if (strlcat(io.pfrio_table.pfrt_anchor, service->name,
d239 1
a239 1
	if (strlcpy(io.pfrio_table.pfrt_name, service->name,
d245 1
a245 1
	log_debug("flush_table: flushed table %s", service->name);
d290 1
a290 1
	if (strlcat(anchor, service->name, sizeof(anchor)) >=
d325 2
a326 2
		if (strlen(service->tag))
			(void)strlcpy(rio.rule.tagname, service->tag,
d349 1
a349 1
		if (strlcpy(pio.addr.addr.v.tblname, service->name,
d356 1
a356 1
		rio.rule.rpool.proxy_port[0] = ntohs(service->table->port);
d359 1
a359 1
		if (service->flags & F_STICKY)
d385 1
a385 1
		if (strlcat(anchor, service->name, sizeof(anchor)) >=
@


1.14
log
@Add layer 7 functionality to hoststated used for layer 7
loadbalancing, SSL acceleration, general-purpose TCP relaying, and
transparent proxying.

see hoststated.conf(5) and my upcoming article on undeadly.org for
details.

ok to commit deraadt@@ pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe_filter.c,v 1.13 2007/02/20 04:06:17 reyk Exp $	*/
d241 1
a241 1
    	    sizeof(io.pfrio_table.pfrt_name))
d350 2
a351 1
		    sizeof(pio.addr.addr.v.tblname)) >= sizeof(pio.addr.addr.v.tblname))
d401 1
a401 1
 	return;
d467 4
a470 2
		bcopy(&pnl.rsaddr.addr8, &in6->sin6_addr, sizeof(in6->sin6_addr));
		bcopy(&pnl.rdaddr.addr8, &out6->sin6_addr, sizeof(out6->sin6_addr));
@


1.13
log
@use HOST_UP instead of an hard coded integer
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe_filter.c,v 1.12 2007/02/08 13:32:24 reyk Exp $	*/
d404 72
@


1.12
log
@carefully check some return values and make lint happier.  never pass
any truncated strings (table names/anchors/tags/...) to pf and the
kernel.

ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe_filter.c,v 1.11 2007/02/07 14:45:12 reyk Exp $	*/
d186 1
a186 1
		if (host->up != 1)
@


1.11
log
@more log_debug() cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe_filter.c,v 1.10 2007/01/29 14:23:31 pyr Exp $	*/
d82 10
a91 6
		(void)strlcpy(tables[i].pfrt_anchor, HOSTSTATED_ANCHOR "/",
		    sizeof(tables[i].pfrt_anchor));
		(void)strlcat(tables[i].pfrt_anchor, service->name,
		    sizeof(tables[i].pfrt_anchor));
		(void)strlcpy(tables[i].pfrt_name, service->name,
		    sizeof(tables[i].pfrt_name));
d117 5
d131 6
a136 4
		(void)strlcpy(io.pfrio_table.pfrt_anchor, HOSTSTATED_ANCHOR "/",
		    sizeof(io.pfrio_table.pfrt_anchor));
		(void)strlcat(io.pfrio_table.pfrt_anchor, service->name,
		    sizeof(io.pfrio_table.pfrt_anchor));
d141 4
d173 10
a182 6
	(void)strlcpy(io.pfrio_table.pfrt_anchor, HOSTSTATED_ANCHOR "/",
	    sizeof(io.pfrio_table.pfrt_anchor));
	(void)strlcat(io.pfrio_table.pfrt_anchor, service->name,
	    sizeof(io.pfrio_table.pfrt_anchor));
	(void)strlcpy(io.pfrio_table.pfrt_name, service->name,
	    sizeof(io.pfrio_table.pfrt_name));
d221 4
d233 10
a242 6
	(void)strlcpy(io.pfrio_table.pfrt_anchor, HOSTSTATED_ANCHOR "/",
	    sizeof(io.pfrio_table.pfrt_anchor));
	(void)strlcat(io.pfrio_table.pfrt_anchor, service->name,
	    sizeof(io.pfrio_table.pfrt_anchor));
	(void)strlcpy(io.pfrio_table.pfrt_name, service->name,
	    sizeof(io.pfrio_table.pfrt_name));
d247 3
d260 1
a260 1
	strlcpy(env->pf->pfte.anchor, anchor, PF_ANCHOR_NAME_SIZE);
d287 10
a296 3
	(void)strlcpy(anchor, HOSTSTATED_ANCHOR "/", sizeof(anchor));
	(void)strlcat(anchor, service->name, sizeof(anchor));
	transaction_init(env, anchor);
d299 5
a303 2
		transaction_commit(env);
		log_debug("sync_ruleset: rules removed");
d349 3
a351 2
		(void)strlcpy(pio.addr.addr.v.tblname, service->name,
		    sizeof(pio.addr.addr.v.tblname));
d365 6
a370 1
	transaction_commit(env);
d381 10
a390 4
		strlcpy(anchor, HOSTSTATED_ANCHOR "/", sizeof(anchor));
		strlcat(anchor, service->name, sizeof(anchor));
		transaction_init(env, anchor);
		transaction_commit(env);
d392 7
a398 3
	strlcpy(anchor, HOSTSTATED_ANCHOR, sizeof(anchor));
	transaction_init(env, anchor);
	transaction_commit(env);
d400 4
@


1.10
log
@Add SSL support to hoststated.
with help and OK reyk@@
with help and advice by claudio@@ and Srebrenko Sehic
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe_filter.c,v 1.9 2007/01/09 13:50:11 pyr Exp $	*/
d101 1
a101 1
	log_debug("created %d tables", io.pfrio_nadd);
@


1.9
log
@Finish renaming hostated to hoststated.
Note to testers: the user the daemon changes its id to is now _hoststated,
don't forget to update master.passwd.
ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe_filter.c,v 1.8 2007/01/09 00:45:32 deraadt Exp $	*/
d37 2
@


1.8
log
@adapt to rename
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe_filter.c,v 1.7 2007/01/08 20:46:18 reyk Exp $	*/
d47 3
a49 3
int	 transaction_init(struct hostated *, const char *);
int	 transaction_commit(struct hostated *);
void	 kill_tables(struct hostated *);
d52 1
a52 1
init_filter(struct hostated *env)
d68 1
a68 1
init_tables(struct hostated *env)
d80 1
a80 1
		(void)strlcpy(tables[i].pfrt_anchor, HOSTATED_ANCHOR "/",
d114 1
a114 1
kill_tables(struct hostated *env) {
d120 1
a120 1
		(void)strlcpy(io.pfrio_table.pfrt_anchor, HOSTATED_ANCHOR "/",
d131 1
a131 1
sync_table(struct hostated *env, struct service *service, struct table *table)
d156 1
a156 1
	(void)strlcpy(io.pfrio_table.pfrt_anchor, HOSTATED_ANCHOR "/",
d203 1
a203 1
flush_table(struct hostated *env, struct service *service)
d208 1
a208 1
	(void)strlcpy(io.pfrio_table.pfrt_anchor, HOSTATED_ANCHOR "/",
d221 1
a221 1
transaction_init(struct hostated *env, const char *anchor)
d237 1
a237 1
transaction_commit(struct hostated *env)
d245 1
a245 1
sync_ruleset(struct hostated *env, struct service *service, int enable)
d255 1
a255 1
	(void)strlcpy(anchor, HOSTATED_ANCHOR "/", sizeof(anchor));
d326 1
a326 1
flush_rulesets(struct hostated *env)
d333 1
a333 1
		strlcpy(anchor, HOSTATED_ANCHOR "/", sizeof(anchor));
d338 1
a338 1
	strlcpy(anchor, HOSTATED_ANCHOR, sizeof(anchor));
@


1.7
log
@do NOT use the regexp interface. it is way to complicated, error-prone
and we don't know about all the possible security problems.

change the check send/expect code to use the fnmatch(3) interface
using shell globbing rules instead. this allows simple patterns like
"220 * ESMTP*" or "SSH-[12].??-*".

suggested by deraadt@@ and otto@@
ok Pierre-Yves Ritschard (pyr at spootnik dot org)
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe_filter.c,v 1.6 2007/01/08 17:10:23 reyk Exp $	*/
d38 1
a38 1
#include "hostated.h"
@


1.6
log
@allow to use service names in addition to numerical port numbers in
the configuration file, eg. "real port http".

> From Pierre-Yves Ritschard (pyr at spootnik dot org)

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe_filter.c,v 1.5 2007/01/08 13:37:26 reyk Exp $	*/
a36 1
#include <regex.h>
@


1.5
log
@add a generic send/expect check using regular expression (see
regex(3)).  this allows to define additional checks for other TCP
protocols.

From Pierre-Yves Ritschard (pyr at spootnik dot org)
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe_filter.c,v 1.4 2007/01/05 16:39:23 reyk Exp $	*/
d313 1
a313 1
		rio.rule.rpool.proxy_port[0] = service->table->port;
@


1.4
log
@Fix two small memleaks

From Pierre-Yves Ritschard (pyr at spootnik dot org)
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe_filter.c,v 1.3 2007/01/03 09:42:30 reyk Exp $	*/
d37 1
@


1.3
log
@allow the sticky-address option for round-robin pools.

From Pierre-Yves Ritschard (pyr at spootnik dot org)
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe_filter.c,v 1.2 2006/12/16 12:42:14 reyk Exp $	*/
d101 2
d194 2
@


1.2
log
@knf, spacing

please note that some editors will replace tabs with multiple spaces
if you cut & paste code from other sections.  please try to keep the
tabs ;).
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe_filter.c,v 1.1 2006/12/16 11:45:07 reyk Exp $	*/
d311 2
@


1.1
log
@Import hostated, the host status daemon.  This daemon will monitor
remote hosts and dynamically alter pf(4) tables and redirection rules
for active server load balancing.  The daemon has been written by
Pierre-Yves Ritschard (pyr at spootnik.org) and was formerly known as
"slbd".

The daemon is fully functional but it still needs some work and
cleanup so we don't link it to the build yet.  Some TODOs are a
partial rewrite of the check_* routines (use libevent whenever we
can), improvement of the manpages, and general knf and cleanup.

ok deraadt@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d55 1
a55 1
	
d78 1
a78 1
	
d81 1
a81 1
			      sizeof(tables[i].pfrt_anchor)); 
d83 1
a83 1
			      sizeof(tables[i].pfrt_anchor)); 
d85 1
a85 1
			      sizeof(tables[i].pfrt_name)); 
d119 1
a119 1
			      sizeof(io.pfrio_table.pfrt_anchor));
d121 1
a121 1
			      sizeof(io.pfrio_table.pfrt_anchor));
d155 1
a155 1
		      sizeof(io.pfrio_table.pfrt_anchor));
d157 1
a157 1
		      sizeof(io.pfrio_table.pfrt_anchor));
d159 1
a159 1
		      sizeof(io.pfrio_table.pfrt_name));
d171 1
a171 1
			       sizeof(sain->sin_addr));
d178 1
a178 1
			       sizeof(sain6->sin6_addr));
d194 2
a195 2
		  io.pfrio_table.pfrt_name,
		  io.pfrio_nadd, io.pfrio_ndel, io.pfrio_nchange);
d205 1
a205 1
		      sizeof(io.pfrio_table.pfrt_anchor));
d207 1
a207 1
		      sizeof(io.pfrio_table.pfrt_anchor));
d209 1
a209 1
		      sizeof(io.pfrio_table.pfrt_name));
d219 3
a221 3
        env->pf->pft.size = 1;      
        env->pf->pft.esize = sizeof env->pf->pfte;
        env->pf->pft.array = &env->pf->pfte;
d227 3
a229 3
        if (ioctl(env->pf->dev, DIOCXBEGIN, &env->pf->pft) == -1)
                return (-1);
        return (0);
d281 1
a281 1
				      sizeof(rio.rule.tagname));
d284 1
a284 1
				      sizeof(rio.rule.ifname));
d288 3
a290 3
			
			rio.rule.dst.addr.v.a.addr.addr32[0] = 
				sain->sin_addr.s_addr; 
d295 1
a295 1
			
d297 2
a298 2
			       &sain6->sin6_addr.s6_addr,
			       sizeof(sain6->sin6_addr.s6_addr));
d304 1
a304 1
			      sizeof(pio.addr.addr.v.tblname));
d331 1
a331 1
	}	
@

