head	1.22;
access;
symbols
	OPENBSD_4_2:1.17.0.2
	OPENBSD_4_2_BASE:1.17
	OPENBSD_4_1:1.13.0.2
	OPENBSD_4_1_BASE:1.13;
locks; strict;
comment	@ * @;


1.22
date	2007.12.07.17.27.07;	author deraadt;	state dead;
branches;
next	1.21;

1.21
date	2007.11.24.17.07.28;	author reyk;	state Exp;
branches;
next	1.20;

1.20
date	2007.11.19.15.31.36;	author reyk;	state Exp;
branches;
next	1.19;

1.19
date	2007.10.19.12.08.55;	author pyr;	state Exp;
branches;
next	1.18;

1.18
date	2007.09.07.08.20.24;	author reyk;	state Exp;
branches;
next	1.17;

1.17
date	2007.06.12.15.16.10;	author msf;	state Exp;
branches;
next	1.16;

1.16
date	2007.06.07.07.19.50;	author pyr;	state Exp;
branches;
next	1.15;

1.15
date	2007.05.29.23.19.18;	author pyr;	state Exp;
branches;
next	1.14;

1.14
date	2007.03.19.10.11.59;	author henning;	state Exp;
branches;
next	1.13;

1.13
date	2007.02.08.13.32.24;	author reyk;	state Exp;
branches;
next	1.12;

1.12
date	2007.02.07.13.39.58;	author reyk;	state Exp;
branches;
next	1.11;

1.11
date	2007.02.01.20.03.39;	author pyr;	state Exp;
branches;
next	1.10;

1.10
date	2007.01.29.14.23.31;	author pyr;	state Exp;
branches;
next	1.9;

1.9
date	2007.01.23.17.43.36;	author claudio;	state Exp;
branches;
next	1.8;

1.8
date	2007.01.09.13.50.11;	author pyr;	state Exp;
branches;
next	1.7;

1.7
date	2007.01.09.00.45.32;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2007.01.08.20.46.18;	author reyk;	state Exp;
branches;
next	1.5;

1.5
date	2007.01.08.13.37.26;	author reyk;	state Exp;
branches;
next	1.4;

1.4
date	2006.12.16.18.50.33;	author reyk;	state Exp;
branches;
next	1.3;

1.3
date	2006.12.16.15.25.40;	author reyk;	state Exp;
branches;
next	1.2;

1.2
date	2006.12.16.12.42.14;	author reyk;	state Exp;
branches;
next	1.1;

1.1
date	2006.12.16.11.45.07;	author reyk;	state Exp;
branches;
next	;


desc
@@


1.22
log
@hoststated/hoststatectl get repository copied (and de-tagged) into
relayd/relayctl.  This is a more suitable place for a daemon that has
grown out of it's initial roots of "monitoring and redirecting services
at various layers", into one that is "a full featured proxy, which
happens to know what is up/down"
@
text
@/*	$OpenBSD: control.c,v 1.21 2007/11/24 17:07:28 reyk Exp $	*/

/*
 * Copyright (c) 2003, 2004 Henning Brauer <henning@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/queue.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/socket.h>
#include <sys/un.h>

#include <net/if.h>

#include <errno.h>
#include <event.h>
#include <fcntl.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <signal.h>

#include <openssl/ssl.h>

#include "hoststated.h"

#define	CONTROL_BACKLOG	5

struct ctl_connlist ctl_conns;

struct ctl_conn	*control_connbyfd(int);
void		 control_close(int);

struct imsgbuf	*ibuf_main = NULL;
struct imsgbuf	*ibuf_hce = NULL;

int
control_init(void)
{
	struct sockaddr_un	 sun;
	int			 fd;
	mode_t			 old_umask;

	if ((fd = socket(AF_UNIX, SOCK_STREAM, 0)) == -1) {
		log_warn("control_init: socket");
		return (-1);
	}

	sun.sun_family = AF_UNIX;
	if (strlcpy(sun.sun_path, HOSTSTATED_SOCKET,
	    sizeof(sun.sun_path)) >= sizeof(sun.sun_path)) {
		log_warn("control_init: %s name too long", HOSTSTATED_SOCKET);
		close(fd);
		return (-1);
	}

	if (unlink(HOSTSTATED_SOCKET) == -1)
		if (errno != ENOENT) {
			log_warn("control_init: unlink %s", HOSTSTATED_SOCKET);
			close(fd);
			return (-1);
		}

	old_umask = umask(S_IXUSR|S_IXGRP|S_IWOTH|S_IROTH|S_IXOTH);
	if (bind(fd, (struct sockaddr *)&sun, sizeof(sun)) == -1) {
		log_warn("control_init: bind: %s", HOSTSTATED_SOCKET);
		close(fd);
		(void)umask(old_umask);
		return (-1);
	}
	(void)umask(old_umask);

	if (chmod(HOSTSTATED_SOCKET, S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP) == -1) {
		log_warn("control_init: chmod");
		close(fd);
		(void)unlink(HOSTSTATED_SOCKET);
		return (-1);
	}

	session_socket_blockmode(fd, BM_NONBLOCK);
	control_state.fd = fd;

	return (0);
}

int
control_listen(struct hoststated *env, struct imsgbuf *i_main,
    struct imsgbuf *i_hce)
{

	ibuf_main = i_main;
	ibuf_hce = i_hce;

	if (listen(control_state.fd, CONTROL_BACKLOG) == -1) {
		log_warn("control_listen: listen");
		return (-1);
	}

	event_set(&control_state.ev, control_state.fd, EV_READ | EV_PERSIST,
	    control_accept, env);
	event_add(&control_state.ev, NULL);

	return (0);
}

void
control_cleanup(void)
{
	(void)unlink(HOSTSTATED_SOCKET);
}

/* ARGSUSED */
void
control_accept(int listenfd, short event, void *arg)
{
	int			 connfd;
	socklen_t		 len;
	struct sockaddr_un	 sun;
	struct ctl_conn		*c;
	struct hoststated	*env = arg;

	len = sizeof(sun);
	if ((connfd = accept(listenfd,
	    (struct sockaddr *)&sun, &len)) == -1) {
		if (errno != EWOULDBLOCK && errno != EINTR)
			log_warn("control_accept");
		return;
	}

	session_socket_blockmode(connfd, BM_NONBLOCK);

	if ((c = malloc(sizeof(struct ctl_conn))) == NULL) {
		log_warn("control_accept");
		return;
	}

	imsg_init(&c->ibuf, connfd, control_dispatch_imsg);
	c->ibuf.events = EV_READ;
	event_set(&c->ibuf.ev, c->ibuf.fd, c->ibuf.events,
	    c->ibuf.handler, env);
	event_add(&c->ibuf.ev, NULL);

	TAILQ_INSERT_TAIL(&ctl_conns, c, entry);
}

struct ctl_conn *
control_connbyfd(int fd)
{
	struct ctl_conn	*c;

	for (c = TAILQ_FIRST(&ctl_conns); c != NULL && c->ibuf.fd != fd;
	    c = TAILQ_NEXT(c, entry))
		;	/* nothing */

	return (c);
}

void
control_close(int fd)
{
	struct ctl_conn	*c;

	if ((c = control_connbyfd(fd)) == NULL)
		log_warn("control_close: fd %d: not found", fd);

	msgbuf_clear(&c->ibuf.w);
	TAILQ_REMOVE(&ctl_conns, c, entry);

	event_del(&c->ibuf.ev);
	close(c->ibuf.fd);
	free(c);
}

/* ARGSUSED */
void
control_dispatch_imsg(int fd, short event, void *arg)
{
	struct ctl_conn		*c;
	struct imsg		 imsg;
	struct ctl_id		 id;
	int			 n;
	struct hoststated	*env = arg;

	if ((c = control_connbyfd(fd)) == NULL) {
		log_warn("control_dispatch_imsg: fd %d: not found", fd);
		return;
	}

	switch (event) {
	case EV_READ:
		if ((n = imsg_read(&c->ibuf)) == -1 || n == 0) {
			control_close(fd);
			return;
		}
		break;
	case EV_WRITE:
		if (msgbuf_write(&c->ibuf.w) < 0) {
			control_close(fd);
			return;
		}
		imsg_event_add(&c->ibuf);
		return;
	default:
		fatalx("unknown event");
	}

	for (;;) {
		if ((n = imsg_get(&c->ibuf, &imsg)) == -1) {
			control_close(fd);
			return;
		}

		if (n == 0)
			break;

		switch (imsg.hdr.type) {
		case IMSG_CTL_SHOW_SUM:
			show(c);
			break;
		case IMSG_CTL_SESSION:
			show_sessions(c);
			break;
		case IMSG_CTL_SERVICE_DISABLE:
			if (imsg.hdr.len != IMSG_HEADER_SIZE + sizeof(id))
				fatalx("invalid imsg header len");
			memcpy(&id, imsg.data, sizeof(id));
			if (disable_service(c, &id))
				imsg_compose(&c->ibuf, IMSG_CTL_FAIL, 0, 0, -1,
				    NULL, 0);
			else {
				memcpy(imsg.data, &id, sizeof(id));
				control_imsg_forward(&imsg);
				imsg_compose(&c->ibuf, IMSG_CTL_OK, 0, 0, -1,
				    NULL, 0);
			}
			break;
		case IMSG_CTL_SERVICE_ENABLE:
			if (imsg.hdr.len != IMSG_HEADER_SIZE + sizeof(id))
				fatalx("invalid imsg header len");
			memcpy(&id, imsg.data, sizeof(id));
			if (enable_service(c, &id))
				imsg_compose(&c->ibuf, IMSG_CTL_FAIL, 0, 0, -1,
				    NULL, 0);
			else {
				memcpy(imsg.data, &id, sizeof(id));
				control_imsg_forward(&imsg);
				imsg_compose(&c->ibuf, IMSG_CTL_OK, 0, 0, -1,
				    NULL, 0);
			}
			break;
		case IMSG_CTL_TABLE_DISABLE:
			if (imsg.hdr.len != IMSG_HEADER_SIZE + sizeof(id))
				fatalx("invalid imsg header len");
			memcpy(&id, imsg.data, sizeof(id));
			if (disable_table(c, &id))
				imsg_compose(&c->ibuf, IMSG_CTL_FAIL, 0, 0, -1,
				    NULL, 0);
			else {
				memcpy(imsg.data, &id, sizeof(id));
				control_imsg_forward(&imsg);
				imsg_compose(&c->ibuf, IMSG_CTL_OK, 0, 0, -1,
				    NULL, 0);
			}
			break;
		case IMSG_CTL_TABLE_ENABLE:
			if (imsg.hdr.len != IMSG_HEADER_SIZE + sizeof(id))
				fatalx("invalid imsg header len");
			memcpy(&id, imsg.data, sizeof(id));
			if (enable_table(c, &id))
				imsg_compose(&c->ibuf, IMSG_CTL_FAIL, 0, 0, -1,
				    NULL, 0);
			else {
				memcpy(imsg.data, &id, sizeof(id));
				control_imsg_forward(&imsg);
				imsg_compose(&c->ibuf, IMSG_CTL_OK, 0, 0, -1,
				    NULL, 0);
			}
			break;
		case IMSG_CTL_HOST_DISABLE:
			if (imsg.hdr.len != IMSG_HEADER_SIZE + sizeof(id))
				fatalx("invalid imsg header len");
			memcpy(&id, imsg.data, sizeof(id));
			if (disable_host(c, &id))
				imsg_compose(&c->ibuf, IMSG_CTL_FAIL, 0, 0, -1,
				    NULL, 0);
			else {
				memcpy(imsg.data, &id, sizeof(id));
				control_imsg_forward(&imsg);
				imsg_compose(&c->ibuf, IMSG_CTL_OK, 0, 0, -1,
				    NULL, 0);
			}
			break;
		case IMSG_CTL_HOST_ENABLE:
			if (imsg.hdr.len != IMSG_HEADER_SIZE + sizeof(id))
				fatalx("invalid imsg header len");
			memcpy(&id, imsg.data, sizeof(id));
			if (enable_host(c, &id))
				imsg_compose(&c->ibuf, IMSG_CTL_FAIL, 0, 0, -1,
				    NULL, 0);
			else {
				memcpy(imsg.data, &id, sizeof(id));
				control_imsg_forward(&imsg);
				imsg_compose(&c->ibuf, IMSG_CTL_OK, 0, 0, -1,
				    NULL, 0);
			}
			break;
		case IMSG_CTL_SHUTDOWN:
			imsg_compose(&c->ibuf, IMSG_CTL_FAIL, 0, 0, -1, NULL,
			    0);
			break;
		case IMSG_CTL_POLL:
			imsg_compose(ibuf_hce, IMSG_CTL_POLL, 0, 0,-1, NULL, 0);
			imsg_compose(&c->ibuf, IMSG_CTL_OK, 0, 0, -1, NULL, 0);
			break;
		case IMSG_CTL_RELOAD:
			if (env->prefork_relay > 0) {
				imsg_compose(&c->ibuf, IMSG_CTL_FAIL, 0, 0, -1,
				    NULL, 0);
				break;
			}
			imsg_compose(ibuf_main, IMSG_CTL_RELOAD, 0, 0, -1, NULL,
			    0);
			/*
			 * we unconditionnaly return a CTL_OK imsg because
			 * we have no choice.
			 *
			 * so in this case, the reply hoststatectl gets means
			 * that the reload command has been set,
			 * it doesn't say wether the command succeeded or not.
			 */
			imsg_compose(&c->ibuf, IMSG_CTL_OK, 0, 0, -1, NULL, 0);
			break;
		case IMSG_CTL_NOTIFY:
			if (c->flags & CTL_CONN_NOTIFY) {
				log_debug("control_dispatch_imsg: "
				    "client requested notify more than once");
				imsg_compose(&c->ibuf, IMSG_CTL_FAIL, 0, 0, -1,
				    NULL, 0);
				break;
			}
			c->flags |= CTL_CONN_NOTIFY;
			break;
		default:
			log_debug("control_dispatch_imsg: "
			    "error handling imsg %d", imsg.hdr.type);
			break;
		}
		imsg_free(&imsg);
	}

	imsg_event_add(&c->ibuf);
}

void
control_imsg_forward(struct imsg *imsg)
{
	struct ctl_conn *c;

	TAILQ_FOREACH(c, &ctl_conns, entry)
		if (c->flags & CTL_CONN_NOTIFY)
			imsg_compose(&c->ibuf, imsg->hdr.type, 0, imsg->hdr.pid,
			    -1, imsg->data, imsg->hdr.len - IMSG_HEADER_SIZE);
}

void
session_socket_blockmode(int fd, enum blockmodes bm)
{
	int	flags;

	if ((flags = fcntl(fd, F_GETFL, 0)) == -1)
		fatal("fcntl F_GETFL");

	if (bm == BM_NONBLOCK)
		flags |= O_NONBLOCK;
	else
		flags &= ~O_NONBLOCK;

	if ((flags = fcntl(fd, F_SETFL, flags)) == -1)
		fatal("fcntl F_SETFL");
}
@


1.21
log
@sort includes, adjust to style(9)
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.20 2007/11/19 15:31:36 reyk Exp $	*/
@


1.20
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.19 2007/10/19 12:08:55 pyr Exp $	*/
a20 1
#include <sys/types.h>
d24 1
d26 1
@


1.19
log
@Add the ability to schedule an immediate check through hoststatectl.
Especially useful when interval is rather long.
I was supposed to commit this before 4.2.
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.18 2007/09/07 08:20:24 reyk Exp $	*/
d319 1
a319 1
			imsg_compose(&c->ibuf, IMSG_CTL_FAIL, 0, 0, -1, NULL, 
@


1.18
log
@add an interface to dump running relay sessions to the control socket
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.17 2007/06/12 15:16:10 msf Exp $	*/
d46 1
d98 2
a99 1
control_listen(struct hoststated *env, struct imsgbuf *ibuf)
d102 2
a103 1
	ibuf_main = ibuf;
d321 4
@


1.17
log
@put the fd passing from bgpd back in to hoststated's version of imsg,
needed for layer 7 reload support.

ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.16 2007/06/07 07:19:50 pyr Exp $	*/
d227 3
@


1.16
log
@(finally) Enable reload support for layer 3 configurations.
Hoststated can be reloaded either by sending SIGHUP to the parent process
or by using ``hoststatectl reload''
discussed and ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.15 2007/05/29 23:19:18 pyr Exp $	*/
d233 1
a233 1
				imsg_compose(&c->ibuf, IMSG_CTL_FAIL, 0, 0,
d238 1
a238 1
				imsg_compose(&c->ibuf, IMSG_CTL_OK, 0, 0,
d247 1
a247 1
				imsg_compose(&c->ibuf, IMSG_CTL_FAIL, 0, 0,
d252 1
a252 1
				imsg_compose(&c->ibuf, IMSG_CTL_OK, 0, 0,
d261 1
a261 1
				imsg_compose(&c->ibuf, IMSG_CTL_FAIL, 0, 0,
d266 1
a266 1
				imsg_compose(&c->ibuf, IMSG_CTL_OK, 0, 0,
d275 1
a275 1
				imsg_compose(&c->ibuf, IMSG_CTL_FAIL, 0, 0,
d280 1
a280 1
				imsg_compose(&c->ibuf, IMSG_CTL_OK, 0, 0,
d289 1
a289 1
				imsg_compose(&c->ibuf, IMSG_CTL_FAIL, 0, 0,
d294 1
a294 1
				imsg_compose(&c->ibuf, IMSG_CTL_OK, 0, 0,
d303 1
a303 1
				imsg_compose(&c->ibuf, IMSG_CTL_FAIL, 0, 0,
d308 1
a308 1
				imsg_compose(&c->ibuf, IMSG_CTL_OK, 0, 0,
d313 2
a314 1
			imsg_compose(&c->ibuf, IMSG_CTL_FAIL, 0, 0, NULL, 0);
d318 1
a318 1
				imsg_compose(&c->ibuf, IMSG_CTL_FAIL, 0, 0,
d322 2
a323 1
			imsg_compose(ibuf_main, IMSG_CTL_RELOAD, 0, 0, NULL, 0);
d332 1
a332 1
			imsg_compose(&c->ibuf, IMSG_CTL_OK, 0, 0, NULL, 0);
d338 1
a338 1
				imsg_compose(&c->ibuf, IMSG_CTL_FAIL, 0, 0,
d363 1
a363 1
			    imsg->data, imsg->hdr.len - IMSG_HEADER_SIZE);
@


1.15
log
@allow the control handling code to send messages back to the parent.
forward IMSG_CTL_RELOAD which ends up not doing anything for now.
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.14 2007/03/19 10:11:59 henning Exp $	*/
a320 1
			imsg_compose(&c->ibuf, IMSG_CTL_FAIL, 0, 0, NULL, 0);
d322 9
@


1.14
log
@do not signal "connection closed" upstream on EINTR/EAGAIN, from bgpd et al
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.13 2007/02/08 13:32:24 reyk Exp $	*/
d45 2
a58 1
	bzero(&sun, sizeof(sun));
d97 1
a97 1
control_listen(void)
d100 2
d108 1
a108 1
	    control_accept, NULL);
d128 1
d148 1
a148 1
	    c->ibuf.handler, &c->ibuf);
d190 1
d313 2
d316 5
d322 1
@


1.13
log
@carefully check some return values and make lint happier.  never pass
any truncated strings (table names/anchors/tags/...) to pf and the
kernel.

ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.12 2007/02/07 13:39:58 reyk Exp $	*/
d194 1
a194 1
		if ((n = imsg_read(&c->ibuf)) <= 0) {
@


1.12
log
@remove unused functions and variables which have been copied from
ospfd(8) (can be re-imported later if required).
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.11 2007/02/01 20:03:39 pyr Exp $	*/
d59 6
a64 1
	strlcpy(sun.sun_path, HOSTSTATED_SOCKET, sizeof(sun.sun_path));
d77 1
a77 1
		umask(old_umask);
d80 1
a80 1
	umask(old_umask);
d114 1
a114 2

	unlink(HOSTSTATED_SOCKET);
@


1.11
log
@add a monitor mode to hoststatectl to continuously report changes in
hoststated.
ok reyk@@, "looks nice and clean" niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.10 2007/01/29 14:23:31 pyr Exp $	*/
a42 1
struct ctl_conn	*control_connbypid(pid_t);
a157 12
struct ctl_conn *
control_connbypid(pid_t pid)
{
	struct ctl_conn	*c;

	for (c = TAILQ_FIRST(&ctl_conns); c != NULL && c->ibuf.pid != pid;
	    c = TAILQ_NEXT(c, entry))
		;	/* nothing */

	return (c);
}

a325 12
}

int
control_imsg_relay(struct imsg *imsg)
{
	struct ctl_conn	*c;

	if ((c = control_connbypid(imsg->hdr.pid)) == NULL)
		return (0);

	return (imsg_compose(&c->ibuf, imsg->hdr.type, 0, imsg->hdr.pid,
	    imsg->data, imsg->hdr.len - IMSG_HEADER_SIZE));
@


1.10
log
@Add SSL support to hoststated.
with help and OK reyk@@
with help and advice by claudio@@ and Srebrenko Sehic
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.9 2007/01/23 17:43:36 claudio Exp $	*/
a41 2
int control_imsg_relay(struct imsg *imsg);

d239 3
a241 1
			else
d244 1
d253 3
a255 1
			else
d258 1
d267 3
a269 1
			else
d272 1
d281 3
a283 1
			else
d286 1
d295 3
a297 1
			else
d300 1
d309 3
a311 1
			else
d314 1
d320 10
d351 11
@


1.9
log
@Typo in fatal() message found by dunceor @@ gmail dot com
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.8 2007/01/09 13:50:11 pyr Exp $	*/
d33 2
@


1.8
log
@Finish renaming hostated to hoststated.
Note to testers: the user the daemon changes its id to is now _hoststated,
don't forget to update master.passwd.
ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.7 2007/01/09 00:45:32 deraadt Exp $	*/
d331 1
a331 1
		fatal("fnctl F_GETFL");
d339 1
a339 1
		fatal("fnctl F_SETFL");
@


1.7
log
@adapt to rename
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.6 2007/01/08 20:46:18 reyk Exp $	*/
d60 1
a60 1
	strlcpy(sun.sun_path, HOSTATED_SOCKET, sizeof(sun.sun_path));
d62 1
a62 1
	if (unlink(HOSTATED_SOCKET) == -1)
d64 1
a64 1
			log_warn("control_init: unlink %s", HOSTATED_SOCKET);
d71 1
a71 1
		log_warn("control_init: bind: %s", HOSTATED_SOCKET);
d78 1
a78 1
	if (chmod(HOSTATED_SOCKET, S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP) == -1) {
d81 1
a81 1
		(void)unlink(HOSTATED_SOCKET);
d111 1
a111 1
	unlink(HOSTATED_SOCKET);
@


1.6
log
@do NOT use the regexp interface. it is way to complicated, error-prone
and we don't know about all the possible security problems.

change the check send/expect code to use the fnmatch(3) interface
using shell globbing rules instead. this allows simple patterns like
"220 * ESMTP*" or "SSH-[12].??-*".

suggested by deraadt@@ and otto@@
ok Pierre-Yves Ritschard (pyr at spootnik dot org)
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.5 2007/01/08 13:37:26 reyk Exp $	*/
d34 1
a34 1
#include "hostated.h"
@


1.5
log
@add a generic send/expect check using regular expression (see
regex(3)).  this allows to define additional checks for other TCP
protocols.

From Pierre-Yves Ritschard (pyr at spootnik dot org)
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.4 2006/12/16 18:50:33 reyk Exp $	*/
a32 1
#include <regex.h>
@


1.4
log
@- allow to use host/service/table names instead of Ids in hostatectl.
- minor change of the "hostatectl show" command output
- increase the max service and tag names (max pf tag name size is 64 now!)

thanks to pyr who found a bug in my initial diff
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.2 2006/12/16 12:42:14 reyk Exp $	*/
d33 1
@


1.3
log
@spacing
@
text
@d193 1
a193 1
	objid_t			 id;
d236 1
a236 1
			if (disable_service(c, id))
d247 1
a247 1
			if (enable_service(c, id))
d258 1
a258 1
			if (disable_table(c, id))
d269 1
a269 1
			if (enable_table(c, id))
d280 1
a280 1
			if (disable_host(c, id))
d291 1
a291 1
			if (enable_host(c, id))
@


1.2
log
@knf, spacing

please note that some editors will replace tabs with multiple spaces
if you cut & paste code from other sections.  please try to keep the
tabs ;).
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.1 2006/12/16 11:45:07 reyk Exp $	*/
d238 1
a238 1
					     NULL, 0);
d241 1
a241 1
					     NULL, 0);
d249 1
a249 1
					     NULL, 0);
d252 1
a252 1
					     NULL, 0);
d260 1
a260 1
					     NULL, 0);
d263 1
a263 1
					     NULL, 0);
d271 1
a271 1
					     NULL, 0);
d274 1
a274 1
					     NULL, 0);
d282 1
a282 1
					     NULL, 0);
d285 1
a285 1
					     NULL, 0);
d293 1
a293 1
					     NULL, 0);
d296 1
a296 1
					     NULL, 0);
@


1.1
log
@Import hostated, the host status daemon.  This daemon will monitor
remote hosts and dynamically alter pf(4) tables and redirection rules
for active server load balancing.  The daemon has been written by
Pierre-Yves Ritschard (pyr at spootnik.org) and was formerly known as
"slbd".

The daemon is fully functional but it still needs some work and
cleanup so we don't link it to the build yet.  Some TODOs are a
partial rewrite of the check_* routines (use libevent whenever we
can), improvement of the manpages, and general knf and cleanup.

ok deraadt@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d192 1
a192 1
	struct imsg	 	 imsg;
d194 1
a194 1
	int		 	 n;
@

