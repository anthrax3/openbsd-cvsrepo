head	1.62;
access;
symbols
	OPENBSD_4_2:1.38.0.2
	OPENBSD_4_2_BASE:1.38
	OPENBSD_4_1:1.20.0.2
	OPENBSD_4_1_BASE:1.20;
locks; strict;
comment	@ * @;


1.62
date	2007.12.07.17.27.07;	author deraadt;	state dead;
branches;
next	1.61;

1.61
date	2007.11.28.11.37.59;	author reyk;	state Exp;
branches;
next	1.60;

1.60
date	2007.11.25.20.01.10;	author reyk;	state Exp;
branches;
next	1.59;

1.59
date	2007.11.24.17.07.28;	author reyk;	state Exp;
branches;
next	1.58;

1.58
date	2007.11.24.16.13.50;	author reyk;	state Exp;
branches;
next	1.57;

1.57
date	2007.11.23.09.22.18;	author sthen;	state Exp;
branches;
next	1.56;

1.56
date	2007.11.21.20.13.20;	author reyk;	state Exp;
branches;
next	1.55;

1.55
date	2007.11.20.15.54.55;	author reyk;	state Exp;
branches;
next	1.54;

1.54
date	2007.11.19.15.31.36;	author reyk;	state Exp;
branches;
next	1.53;

1.53
date	2007.11.19.14.48.19;	author reyk;	state Exp;
branches;
next	1.52;

1.52
date	2007.11.19.11.39.49;	author reyk;	state Exp;
branches;
next	1.51;

1.51
date	2007.11.15.17.02.01;	author pyr;	state Exp;
branches;
next	1.50;

1.50
date	2007.11.14.11.01.52;	author pyr;	state Exp;
branches;
next	1.49;

1.49
date	2007.11.14.10.59.01;	author pyr;	state Exp;
branches;
next	1.48;

1.48
date	2007.11.13.10.35.21;	author pyr;	state Exp;
branches;
next	1.47;

1.47
date	2007.11.04.22.09.02;	author reyk;	state Exp;
branches;
next	1.46;

1.46
date	2007.10.19.14.40.51;	author pyr;	state Exp;
branches;
next	1.45;

1.45
date	2007.10.19.14.15.14;	author pyr;	state Exp;
branches;
next	1.44;

1.44
date	2007.10.12.12.50.59;	author blambert;	state Exp;
branches;
next	1.43;

1.43
date	2007.10.05.17.32.13;	author reyk;	state Exp;
branches;
next	1.42;

1.42
date	2007.10.02.21.04.13;	author pyr;	state Exp;
branches;
next	1.41;

1.41
date	2007.09.28.20.23.38;	author pyr;	state Exp;
branches;
next	1.40;

1.40
date	2007.09.28.13.29.56;	author pyr;	state Exp;
branches;
next	1.39;

1.39
date	2007.09.05.08.48.42;	author reyk;	state Exp;
branches;
next	1.38;

1.38
date	2007.07.05.09.42.26;	author thib;	state Exp;
branches;
next	1.37;

1.37
date	2007.06.19.06.29.20;	author pyr;	state Exp;
branches;
next	1.36;

1.36
date	2007.06.12.15.16.10;	author msf;	state Exp;
branches;
next	1.35;

1.35
date	2007.06.07.07.19.50;	author pyr;	state Exp;
branches;
next	1.34;

1.34
date	2007.05.31.03.24.05;	author pyr;	state Exp;
branches;
next	1.33;

1.33
date	2007.05.30.00.51.21;	author pyr;	state Exp;
branches;
next	1.32;

1.32
date	2007.05.30.00.19.25;	author pyr;	state Exp;
branches;
next	1.31;

1.31
date	2007.05.30.00.12.21;	author pyr;	state Exp;
branches;
next	1.30;

1.30
date	2007.05.29.23.58.30;	author pyr;	state Exp;
branches;
next	1.29;

1.29
date	2007.05.29.23.19.18;	author pyr;	state Exp;
branches;
next	1.28;

1.28
date	2007.05.29.18.59.53;	author pyr;	state Exp;
branches;
next	1.27;

1.27
date	2007.05.29.17.12.04;	author reyk;	state Exp;
branches;
next	1.26;

1.26
date	2007.05.29.00.58.06;	author pyr;	state Exp;
branches;
next	1.25;

1.25
date	2007.05.29.00.21.10;	author pyr;	state Exp;
branches;
next	1.24;

1.24
date	2007.05.28.22.11.33;	author pyr;	state Exp;
branches;
next	1.23;

1.23
date	2007.05.27.20.53.10;	author pyr;	state Exp;
branches;
next	1.22;

1.22
date	2007.05.26.19.58.49;	author pyr;	state Exp;
branches;
next	1.21;

1.21
date	2007.03.17.22.54.49;	author reyk;	state Exp;
branches;
next	1.20;

1.20
date	2007.02.26.16.10.24;	author reyk;	state Exp;
branches;
next	1.19;

1.19
date	2007.02.23.00.28.06;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2007.02.22.05.58.06;	author reyk;	state Exp;
branches;
next	1.17;

1.17
date	2007.02.22.03.32.39;	author reyk;	state Exp;
branches;
next	1.16;

1.16
date	2007.02.08.13.32.24;	author reyk;	state Exp;
branches;
next	1.15;

1.15
date	2007.02.07.13.30.17;	author reyk;	state Exp;
branches;
next	1.14;

1.14
date	2007.02.06.10.03.08;	author reyk;	state Exp;
branches;
next	1.13;

1.13
date	2007.01.29.14.23.31;	author pyr;	state Exp;
branches;
next	1.12;

1.12
date	2007.01.24.10.26.00;	author claudio;	state Exp;
branches;
next	1.11;

1.11
date	2007.01.11.18.28.28;	author pyr;	state Exp;
branches;
next	1.10;

1.10
date	2007.01.11.18.05.08;	author reyk;	state Exp;
branches;
next	1.9;

1.9
date	2007.01.09.13.50.11;	author pyr;	state Exp;
branches;
next	1.8;

1.8
date	2007.01.09.02.32.58;	author reyk;	state Exp;
branches;
next	1.7;

1.7
date	2007.01.08.20.46.18;	author reyk;	state Exp;
branches;
next	1.6;

1.6
date	2007.01.08.13.37.26;	author reyk;	state Exp;
branches;
next	1.5;

1.5
date	2006.12.25.18.40.38;	author reyk;	state Exp;
branches;
next	1.4;

1.4
date	2006.12.16.18.50.33;	author reyk;	state Exp;
branches;
next	1.3;

1.3
date	2006.12.16.14.07.29;	author reyk;	state Exp;
branches;
next	1.2;

1.2
date	2006.12.16.12.42.14;	author reyk;	state Exp;
branches;
next	1.1;

1.1
date	2006.12.16.11.45.07;	author reyk;	state Exp;
branches;
next	;


desc
@@


1.62
log
@hoststated/hoststatectl get repository copied (and de-tagged) into
relayd/relayctl.  This is a more suitable place for a daemon that has
grown out of it's initial roots of "monitoring and redirecting services
at various layers", into one that is "a full featured proxy, which
happens to know what is up/down"
@
text
@/*	$OpenBSD: hoststated.c,v 1.61 2007/11/28 11:37:59 reyk Exp $	*/

/*
 * Copyright (c) 2006 Pierre-Yves Ritschard <pyr@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/queue.h>
#include <sys/socket.h>
#include <sys/wait.h>

#include <net/if.h>
#include <netinet/in.h>
#include <arpa/inet.h>

#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <getopt.h>
#include <err.h>
#include <errno.h>
#include <event.h>
#include <signal.h>
#include <unistd.h>
#include <ctype.h>
#include <pwd.h>
#include <sha1.h>
#include <md5.h>

#include <openssl/ssl.h>

#include "hoststated.h"

__dead void	 usage(void);

void		 main_sig_handler(int, short, void *);
void		 main_shutdown(struct hoststated *);
void		 main_dispatch_pfe(int, short, void *);
void		 main_dispatch_hce(int, short, void *);
void		 main_dispatch_relay(int, short, void *);
int		 check_child(pid_t, const char *);
int		 send_all(struct hoststated *, enum imsg_type,
		    void *, u_int16_t);
void		 reconfigure(void);
void		 purge_tree(struct proto_tree *);

int		 pipe_parent2pfe[2];
int		 pipe_parent2hce[2];
int		 pipe_pfe2hce[2];
int		 pipe_parent2relay[RELAY_MAXPROC][2];
int		 pipe_pfe2relay[RELAY_MAXPROC][2];

struct hoststated	*hoststated_env;

struct imsgbuf	*ibuf_pfe;
struct imsgbuf	*ibuf_hce;
struct imsgbuf	*ibuf_relay;

pid_t		 pfe_pid = 0;
pid_t		 hce_pid = 0;
pid_t		 relay_pid = 0;

void
main_sig_handler(int sig, short event, void *arg)
{
	struct hoststated	*env = arg;
	int			 die = 0;

	switch (sig) {
	case SIGTERM:
	case SIGINT:
		die = 1;
		/* FALLTHROUGH */
	case SIGCHLD:
		if (check_child(pfe_pid, "pf update engine")) {
			pfe_pid = 0;
			die  = 1;
		}
		if (check_child(hce_pid, "host check engine")) {
			hce_pid = 0;
			die  = 1;
		}
		if (check_child(relay_pid, "socket relay engine")) {
			relay_pid = 0;
			die  = 1;
		}
		if (die)
			main_shutdown(env);
		break;
	case SIGHUP:
		reconfigure();
		break;
	default:
		fatalx("unexpected signal");
	}
}

/* __dead is for lint */
__dead void
usage(void)
{
	extern char	*__progname;

	fprintf(stderr, "%s [-dnv] [-D macro=value] [-f file]\n", __progname);
	exit(1);
}

int
main(int argc, char *argv[])
{
	int			 c;
	int			 debug;
	u_int32_t		 opts;
	struct hoststated	*env;
	const char		*conffile;
	struct event		 ev_sigint;
	struct event		 ev_sigterm;
	struct event		 ev_sigchld;
	struct event		 ev_sighup;
	struct imsgbuf		*ibuf;

	opts = 0;
	debug = 0;
	conffile = CONF_FILE;

	log_init(1);	/* log to stderr until daemonized */

	while ((c = getopt(argc, argv, "dD:nf:v")) != -1) {
		switch (c) {
		case 'd':
			debug = 2;
			break;
		case 'D':
			if (cmdline_symset(optarg) < 0)
				log_warnx("could not parse macro definition %s",
				    optarg);
			break;
		case 'n':
			debug = 2;
			opts |= HOSTSTATED_OPT_NOACTION;
			break;
		case 'f':
			conffile = optarg;
			break;
		case 'v':
			opts |= HOSTSTATED_OPT_VERBOSE;
			break;
		default:
			usage();
		}
	}

	if ((env = parse_config(conffile, opts)) == NULL)
		exit(1);
	hoststated_env = env;

	if (env->opts & HOSTSTATED_OPT_NOACTION) {
		fprintf(stderr, "configuration OK\n");
		exit(0);
	}
	if (debug)
		env->opts |= HOSTSTATED_OPT_LOGUPDATE;

	if (geteuid())
		errx(1, "need root privileges");

	if (getpwnam(HOSTSTATED_USER) == NULL)
		errx(1, "unknown user %s", HOSTSTATED_USER);

	log_init(debug);

	if (!debug) {
		if (daemon(1, 0) == -1)
			err(1, "failed to daemonize");
	}

	log_info("startup");

	if (socketpair(AF_UNIX, SOCK_STREAM, PF_UNSPEC,
	    pipe_parent2pfe) == -1)
		fatal("socketpair");
	if (socketpair(AF_UNIX, SOCK_STREAM, PF_UNSPEC,
	    pipe_parent2hce) == -1)
		fatal("socketpair");
	if (socketpair(AF_UNIX, SOCK_STREAM, PF_UNSPEC,
	    pipe_pfe2hce) == -1)
		fatal("socketpair");
	for (c = 0; c < env->prefork_relay; c++) {
		if (socketpair(AF_UNIX, SOCK_STREAM, PF_UNSPEC,
		    pipe_parent2relay[c]) == -1)
			fatal("socketpair");
		if (socketpair(AF_UNIX, SOCK_STREAM, PF_UNSPEC,
		    pipe_pfe2relay[c]) == -1)
			fatal("socketpair");
		session_socket_blockmode(pipe_pfe2relay[c][0], BM_NONBLOCK);
		session_socket_blockmode(pipe_pfe2relay[c][1], BM_NONBLOCK);
		session_socket_blockmode(pipe_parent2relay[c][0], BM_NONBLOCK);
		session_socket_blockmode(pipe_parent2relay[c][1], BM_NONBLOCK);
	}

	session_socket_blockmode(pipe_parent2pfe[0], BM_NONBLOCK);
	session_socket_blockmode(pipe_parent2pfe[1], BM_NONBLOCK);
	session_socket_blockmode(pipe_parent2hce[0], BM_NONBLOCK);
	session_socket_blockmode(pipe_parent2hce[1], BM_NONBLOCK);
	session_socket_blockmode(pipe_pfe2hce[0], BM_NONBLOCK);
	session_socket_blockmode(pipe_pfe2hce[1], BM_NONBLOCK);

	pfe_pid = pfe(env, pipe_parent2pfe, pipe_parent2hce,
	    pipe_parent2relay, pipe_pfe2hce, pipe_pfe2relay);
	hce_pid = hce(env, pipe_parent2pfe, pipe_parent2hce,
	    pipe_parent2relay, pipe_pfe2hce, pipe_pfe2relay);
	if (env->prefork_relay > 0)
		relay_pid = relay(env, pipe_parent2pfe, pipe_parent2hce,
		    pipe_parent2relay, pipe_pfe2hce, pipe_pfe2relay);

	setproctitle("parent");

	event_init();

	signal_set(&ev_sigint, SIGINT, main_sig_handler, env);
	signal_set(&ev_sigterm, SIGTERM, main_sig_handler, env);
	signal_set(&ev_sigchld, SIGCHLD, main_sig_handler, env);
	signal_set(&ev_sighup, SIGHUP, main_sig_handler, env);
	signal_add(&ev_sigint, NULL);
	signal_add(&ev_sigterm, NULL);
	signal_add(&ev_sigchld, NULL);
	signal_add(&ev_sighup, NULL);
	signal(SIGPIPE, SIG_IGN);

	close(pipe_parent2pfe[1]);
	close(pipe_parent2hce[1]);
	close(pipe_pfe2hce[0]);
	close(pipe_pfe2hce[1]);
	for (c = 0; c < env->prefork_relay; c++) {
		close(pipe_pfe2relay[c][0]);
		close(pipe_pfe2relay[c][1]);
		close(pipe_parent2relay[c][0]);
	}

	if ((ibuf_pfe = calloc(1, sizeof(struct imsgbuf))) == NULL ||
	    (ibuf_hce = calloc(1, sizeof(struct imsgbuf))) == NULL)
		fatal(NULL);

	if (env->prefork_relay > 0) {
		if ((ibuf_relay = calloc(env->prefork_relay,
		    sizeof(struct imsgbuf))) == NULL)
			fatal(NULL);
	}

	imsg_init(ibuf_pfe, pipe_parent2pfe[0], main_dispatch_pfe);
	imsg_init(ibuf_hce, pipe_parent2hce[0], main_dispatch_hce);
	for (c = 0; c < env->prefork_relay; c++) {
		ibuf = &ibuf_relay[c];
		imsg_init(ibuf, pipe_parent2relay[c][1], main_dispatch_relay);
		ibuf->events = EV_READ;
		event_set(&ibuf->ev, ibuf->fd, ibuf->events,
		    ibuf->handler, ibuf);
		event_add(&ibuf->ev, NULL);
	}

	ibuf_pfe->events = EV_READ;
	event_set(&ibuf_pfe->ev, ibuf_pfe->fd, ibuf_pfe->events,
	    ibuf_pfe->handler, ibuf_pfe);
	event_add(&ibuf_pfe->ev, NULL);

	ibuf_hce->events = EV_READ;
	event_set(&ibuf_hce->ev, ibuf_hce->fd, ibuf_hce->events,
	    ibuf_hce->handler, ibuf_hce);
	event_add(&ibuf_hce->ev, NULL);

	if (env->flags & F_DEMOTE)
		carp_demote_reset(env->demote_group, 0);

	event_dispatch();

	return (0);
}

void
main_shutdown(struct hoststated *env)
{
	pid_t	pid;

	if (pfe_pid)
		kill(pfe_pid, SIGTERM);
	if (hce_pid)
		kill(hce_pid, SIGTERM);
	if (relay_pid)
		kill(relay_pid, SIGTERM);

	do {
		if ((pid = wait(NULL)) == -1 &&
		    errno != EINTR && errno != ECHILD)
			fatal("wait");
	} while (pid != -1 || (pid == -1 && errno == EINTR));

	control_cleanup();
	carp_demote_shutdown();
	if (env->flags & F_DEMOTE)
		carp_demote_reset(env->demote_group, 128);
	log_info("terminating");
	exit(0);
}

int
check_child(pid_t pid, const char *pname)
{
	int	status;

	if (waitpid(pid, &status, WNOHANG) > 0) {
		if (WIFEXITED(status)) {
			log_warnx("check_child: lost child: %s exited", pname);
			return (1);
		}
		if (WIFSIGNALED(status)) {
			log_warnx("check_child: lost child: %s terminated; "
			    "signal %d", pname, WTERMSIG(status));
			return (1);
		}
	}

	return (0);
}

int
send_all(struct hoststated *env, enum imsg_type type, void *buf, u_int16_t len)
{
	int		 i;

	if (imsg_compose(ibuf_pfe, type, 0, 0, -1, buf, len) == -1)
		return (-1);
	if (imsg_compose(ibuf_hce, type, 0, 0, -1, buf, len) == -1)
		return (-1);
	for (i = 0; i < env->prefork_relay; i++) {
		if (imsg_compose(&ibuf_relay[i], type, 0, 0, -1, buf, len)
		    == -1)
			return (-1);
	}
	return (0);
}

void
merge_config(struct hoststated *env, struct hoststated *new_env)
{
	env->opts = new_env->opts;
	env->flags = new_env->flags;
	env->confpath = new_env->confpath;
	env->tablecount = new_env->tablecount;
	env->servicecount = new_env->servicecount;
	env->protocount = new_env->protocount;
	env->relaycount = new_env->relaycount;

	memcpy(&env->interval, &new_env->interval, sizeof(env->interval));
	memcpy(&env->timeout, &new_env->timeout, sizeof(env->timeout));
	memcpy(&env->empty_table, &new_env->empty_table,
	    sizeof(env->empty_table));
	memcpy(&env->proto_default, &new_env->proto_default,
	    sizeof(env->proto_default));
	env->prefork_relay = new_env->prefork_relay;
	(void)strlcpy(env->demote_group, new_env->demote_group,
	    sizeof(env->demote_group));

	env->tables = new_env->tables;
	env->services = new_env->services;
	env->relays = new_env->relays;
	env->protos = new_env->protos;
}


void
reconfigure(void)
{
	struct hoststated	*env = hoststated_env;
	struct hoststated	*new_env;
	struct service		*service;
	struct address		*virt;
	struct table            *table;
	struct host             *host;

	log_info("reloading configuration");
	if ((new_env = parse_config(env->confpath, env->opts)) == NULL)
		exit(1);

	purge_config(env, PURGE_EVERYTHING);
	merge_config(env, new_env);
	free(new_env);
	log_info("configuration merge done");

	/*
	 * first reconfigure pfe
	 */
	imsg_compose(ibuf_pfe, IMSG_RECONF, 0, 0, -1, env, sizeof(*env));
	TAILQ_FOREACH(table, env->tables, entry) {
		imsg_compose(ibuf_pfe, IMSG_RECONF_TABLE, 0, 0, -1,
		    &table->conf, sizeof(table->conf));
		TAILQ_FOREACH(host, &table->hosts, entry) {
			imsg_compose(ibuf_pfe, IMSG_RECONF_HOST, 0, 0, -1,
			    &host->conf, sizeof(host->conf));
		}
	}
	TAILQ_FOREACH(service, env->services, entry) {
		imsg_compose(ibuf_pfe, IMSG_RECONF_SERVICE, 0, 0, -1,
		    &service->conf, sizeof(service->conf));
		TAILQ_FOREACH(virt, &service->virts, entry)
			imsg_compose(ibuf_pfe, IMSG_RECONF_VIRT, 0, 0, -1,
				virt, sizeof(*virt));
	}
	imsg_compose(ibuf_pfe, IMSG_RECONF_END, 0, 0, -1, NULL, 0);

	/*
	 * then reconfigure hce
	 */
	imsg_compose(ibuf_hce, IMSG_RECONF, 0, 0, -1, env, sizeof(*env));
	TAILQ_FOREACH(table, env->tables, entry) {
		imsg_compose(ibuf_hce, IMSG_RECONF_TABLE, 0, 0, -1,
		    &table->conf, sizeof(table->conf));
		if (table->sendbuf != NULL)
			imsg_compose(ibuf_hce, IMSG_RECONF_SENDBUF, 0, 0, -1,
			    table->sendbuf, strlen(table->sendbuf) + 1);
		TAILQ_FOREACH(host, &table->hosts, entry) {
			imsg_compose(ibuf_hce, IMSG_RECONF_HOST, 0, 0, -1,
			    &host->conf, sizeof(host->conf));
		}
	}
	imsg_compose(ibuf_hce, IMSG_RECONF_END, 0, 0, -1, NULL, 0);
}

void
purge_config(struct hoststated *env, u_int8_t what)
{
	struct table		*table;
	struct host		*host;
	struct service		*service;
	struct address		*virt;
	struct protocol		*proto;
	struct relay		*rly;
	struct session		*sess;

	if (what & PURGE_TABLES && env->tables != NULL) {
		while ((table = TAILQ_FIRST(env->tables)) != NULL) {

			while ((host = TAILQ_FIRST(&table->hosts)) != NULL) {
				TAILQ_REMOVE(&table->hosts, host, entry);
				free(host);
			}
			if (table->sendbuf != NULL)
				free(table->sendbuf);
			if (table->conf.flags & F_SSL)
				SSL_CTX_free(table->ssl_ctx);

			TAILQ_REMOVE(env->tables, table, entry);

			free(table);
		}
		free(env->tables);
		env->tables = NULL;
	}

	if (what & PURGE_SERVICES && env->services != NULL) {
		while ((service = TAILQ_FIRST(env->services)) != NULL) {
			TAILQ_REMOVE(env->services, service, entry);
			while ((virt = TAILQ_FIRST(&service->virts)) != NULL) {
				TAILQ_REMOVE(&service->virts, virt, entry);
				free(virt);
			}
			free(service);
		}
		free(env->services);
		env->services = NULL;
	}

	if (what & PURGE_RELAYS && env->relays != NULL) {
		while ((rly = TAILQ_FIRST(env->relays)) != NULL) {
			TAILQ_REMOVE(env->relays, rly, entry);
			while ((sess = SPLAY_ROOT(&rly->sessions)) != NULL) {
				SPLAY_REMOVE(session_tree,
				    &rly->sessions, sess);
				free(sess);
			}
			if (rly->bev != NULL)
				bufferevent_free(rly->bev);
			if (rly->dstbev != NULL)
				bufferevent_free(rly->dstbev);
			if (rly->ssl_ctx != NULL)
				SSL_CTX_free(rly->ssl_ctx);
			free(rly);
		}
		free(env->relays);
		env->relays = NULL;
	}

	if (what & PURGE_PROTOS && env->protos != NULL) {
		while ((proto = TAILQ_FIRST(env->protos)) != NULL) {
			TAILQ_REMOVE(env->protos, proto, entry);
			purge_tree(&proto->request_tree);
			purge_tree(&proto->response_tree);
			if (proto->style != NULL)
				free(proto->style);
			free(proto);
		}
		free(env->protos);
		env->protos = NULL;
	}
}

void
purge_tree(struct proto_tree *tree)
{
	struct protonode	*proot, *pn;

	while ((proot = RB_ROOT(tree)) != NULL) {
		RB_REMOVE(proto_tree, tree, proot);
		if (proot->key != NULL)
			free(proot->key);
		if (proot->value != NULL)
			free(proot->value);
		while ((pn = SIMPLEQ_FIRST(&proot->head)) != NULL) {
			SIMPLEQ_REMOVE_HEAD(&proot->head, entry);
			if (pn->key != NULL)
				free(pn->key);
			if (pn->value != NULL)
				free(pn->value);
			if (pn->label != 0)
				pn_unref(pn->label);
			free(pn);
		}
		free(proot);
	}
}

void
imsg_event_add(struct imsgbuf *ibuf)
{
	ibuf->events = EV_READ;
	if (ibuf->w.queued)
		ibuf->events |= EV_WRITE;

	event_del(&ibuf->ev);
	event_set(&ibuf->ev, ibuf->fd, ibuf->events, ibuf->handler, ibuf);
	event_add(&ibuf->ev, NULL);
}

void
main_dispatch_pfe(int fd, short event, void *ptr)
{
	struct imsgbuf		*ibuf;
	struct imsg		 imsg;
	ssize_t			 n;
	struct ctl_demote	 demote;

	ibuf = ptr;
	switch (event) {
	case EV_READ:
		if ((n = imsg_read(ibuf)) == -1)
			fatal("imsg_read_error");
		if (n == 0) {
			/* this pipe is dead, so remove the event handler */
			event_del(&ibuf->ev);
			event_loopexit(NULL);
			return;
		}
		break;
	case EV_WRITE:
		if (msgbuf_write(&ibuf->w) == -1)
			fatal("msgbuf_write");
		imsg_event_add(ibuf);
		return;
	default:
		fatalx("unknown event");
	}

	for (;;) {
		if ((n = imsg_get(ibuf, &imsg)) == -1)
			fatal("main_dispatch_pfe: imsg_read error");
		if (n == 0)
			break;

		switch (imsg.hdr.type) {
		case IMSG_DEMOTE:
			if (imsg.hdr.len - IMSG_HEADER_SIZE !=
			    sizeof(demote))
				fatalx("main_dispatch_pfe: "
				    "invalid size of demote request");
			memcpy(&demote, imsg.data, sizeof(demote));
			carp_demote_set(demote.group, demote.level);
			break;
		case IMSG_CTL_RELOAD:
			/*
			 * so far we only get here if no L7 (relay) is done.
			 */
			reconfigure();
			break;
		default:
			log_debug("main_dispatch_pfe: unexpected imsg %d",
			    imsg.hdr.type);
			break;
		}
		imsg_free(&imsg);
	}
	imsg_event_add(ibuf);
}

void
main_dispatch_hce(int fd, short event, void * ptr)
{
	struct imsgbuf		*ibuf;
	struct imsg		 imsg;
	ssize_t			 n;
	struct ctl_script	 scr;
	struct hoststated	*env;

	env = hoststated_env;
	ibuf = ptr;
	switch (event) {
	case EV_READ:
		if ((n = imsg_read(ibuf)) == -1)
			fatal("imsg_read error");
		if (n == 0) {
			/* this pipe is dead, so remove the event handler */
			event_del(&ibuf->ev);
			event_loopexit(NULL);
			return;
		}
		break;
	case EV_WRITE:
		if (msgbuf_write(&ibuf->w) == -1)
			fatal("msgbuf_write");
		imsg_event_add(ibuf);
		return;
	default:
		fatalx("unknown event");
	}

	for (;;) {
		if ((n = imsg_get(ibuf, &imsg)) == -1)
			fatal("main_dispatch_hce: imsg_read error");
		if (n == 0)
			break;

		switch (imsg.hdr.type) {
		case IMSG_SCRIPT:
			if (imsg.hdr.len - IMSG_HEADER_SIZE !=
			    sizeof(scr))
				fatalx("main_dispatch_hce: "
				    "invalid size of script request");
			bcopy(imsg.data, &scr, sizeof(scr));
			scr.retval = script_exec(env, &scr);
			imsg_compose(ibuf_hce, IMSG_SCRIPT,
			    0, 0, -1, &scr, sizeof(scr));
			break;
		default:
			log_debug("main_dispatch_hce: unexpected imsg %d",
			    imsg.hdr.type);
			break;
		}
		imsg_free(&imsg);
	}
	imsg_event_add(ibuf);
}

void
main_dispatch_relay(int fd, short event, void * ptr)
{
	struct imsgbuf		*ibuf;
	struct imsg		 imsg;
	ssize_t			 n;

	ibuf = ptr;
	switch (event) {
	case EV_READ:
		if ((n = imsg_read(ibuf)) == -1)
			fatal("imsg_read error");
		if (n == 0) {
			/* this pipe is dead, so remove the event handler */
			event_del(&ibuf->ev);
			event_loopexit(NULL);
			return;
		}
		break;
	case EV_WRITE:
		if (msgbuf_write(&ibuf->w) == -1)
			fatal("msgbuf_write");
		imsg_event_add(ibuf);
		return;
	default:
		fatalx("unknown event");
	}

	for (;;) {
		if ((n = imsg_get(ibuf, &imsg)) == -1)
			fatal("main_dispatch_relay: imsg_read error");
		if (n == 0)
			break;

		switch (imsg.hdr.type) {
		default:
			log_debug("main_dispatch_relay: unexpected imsg %d",
			    imsg.hdr.type);
			break;
		}
		imsg_free(&imsg);
	}
	imsg_event_add(ibuf);
}

struct host *
host_find(struct hoststated *env, objid_t id)
{
	struct table	*table;
	struct host	*host;

	TAILQ_FOREACH(table, env->tables, entry)
		TAILQ_FOREACH(host, &table->hosts, entry)
			if (host->conf.id == id)
				return (host);
	return (NULL);
}

struct table *
table_find(struct hoststated *env, objid_t id)
{
	struct table	*table;

	TAILQ_FOREACH(table, env->tables, entry)
		if (table->conf.id == id)
			return (table);
	return (NULL);
}

struct service *
service_find(struct hoststated *env, objid_t id)
{
	struct service	*service;

	TAILQ_FOREACH(service, env->services, entry)
		if (service->conf.id == id)
			return (service);
	return (NULL);
}

struct relay *
relay_find(struct hoststated *env, objid_t id)
{
	struct relay	*rlay;

	TAILQ_FOREACH(rlay, env->relays, entry)
		if (rlay->conf.id == id)
			return (rlay);
	return (NULL);
}

struct session *
session_find(struct hoststated *env, objid_t id)
{
	struct relay		*rlay;
	struct session		*con;

	TAILQ_FOREACH(rlay, env->relays, entry)
		SPLAY_FOREACH(con, session_tree, &rlay->sessions)
			if (con->id == id)
				return (con);
	return (NULL);
}

struct host *
host_findbyname(struct hoststated *env, const char *name)
{
	struct table	*table;
	struct host	*host;

	TAILQ_FOREACH(table, env->tables, entry)
		TAILQ_FOREACH(host, &table->hosts, entry)
			if (strcmp(host->conf.name, name) == 0)
				return (host);
	return (NULL);
}

struct table *
table_findbyname(struct hoststated *env, const char *name)
{
	struct table	*table;

	TAILQ_FOREACH(table, env->tables, entry)
		if (strcmp(table->conf.name, name) == 0)
			return (table);
	return (NULL);
}

struct service *
service_findbyname(struct hoststated *env, const char *name)
{
	struct service	*service;

	TAILQ_FOREACH(service, env->services, entry)
		if (strcmp(service->conf.name, name) == 0)
			return (service);
	return (NULL);
}

struct relay *
relay_findbyname(struct hoststated *env, const char *name)
{
	struct relay	*rlay;

	TAILQ_FOREACH(rlay, env->relays, entry)
		if (strcmp(rlay->conf.name, name) == 0)
			return (rlay);
	return (NULL);
}

void
event_again(struct event *ev, int fd, short event,
    void (*fn)(int, short, void *),
    struct timeval *start, struct timeval *end, void *arg)
{
	struct timeval tv_next, tv_now, tv;

	if (gettimeofday(&tv_now, NULL))
		fatal("event_again: gettimeofday");

	bcopy(end, &tv_next, sizeof(tv_next));
	timersub(&tv_now, start, &tv_now);
	timersub(&tv_next, &tv_now, &tv_next);

	bzero(&tv, sizeof(tv));
	if (timercmp(&tv_next, &tv, >))
		bcopy(&tv_next, &tv, sizeof(tv));

	event_set(ev, fd, event, fn, arg);
	event_add(ev, &tv);
}

int
expand_string(char *label, size_t len, const char *srch, const char *repl)
{
	char *tmp;
	char *p, *q;

	if ((tmp = calloc(1, len)) == NULL) {
		log_debug("expand_string: calloc");
		return (-1);
	}
	p = q = label;
	while ((q = strstr(p, srch)) != NULL) {
		*q = '\0';
		if ((strlcat(tmp, p, len) >= len) ||
		    (strlcat(tmp, repl, len) >= len)) {
			log_debug("expand_string: string too long");
			return (-1);
		}
		q += strlen(srch);
		p = q;
	}
	if (strlcat(tmp, p, len) >= len) {
		log_debug("expand_string: string too long");
		return (-1);
	}
	(void)strlcpy(label, tmp, len);	/* always fits */
	free(tmp);

	return (0);
}

void
translate_string(char *str)
{
	char	*reader;
	char	*writer;

	reader = writer = str;

	while (*reader) {
		if (*reader == '\\') {
			reader++;
			switch (*reader) {
			case 'n':
				*writer++ = '\n';
				break;
			case 'r':
				*writer++ = '\r';
				break;
			default:
				*writer++ = *reader;
			}
		} else
			*writer++ = *reader;
		reader++;
	}
	*writer = '\0';
}

char *
digeststr(enum digest_type type, const u_int8_t *data, size_t len, char *buf)
{
	switch (type) {
	case DIGEST_SHA1:
		return (SHA1Data(data, len, buf));
		break;
	case DIGEST_MD5:
		return (MD5Data(data, len, buf));
		break;
	default:
		break;
	}
	return (NULL);
}

const char *
canonicalize_host(const char *host, char *name, size_t len)
{
	struct sockaddr_in	 sin4;
	struct sockaddr_in6	 sin6;
	u_int			 i, j;
	size_t			 plen;
	char			 c;

	if (len < 2)
		goto fail;

	/*
	 * Canonicalize an IPv4/6 address
	 */
	if (inet_pton(AF_INET, host, &sin4) == 1)
		return (inet_ntop(AF_INET, &sin4, name, len));
	if (inet_pton(AF_INET6, host, &sin6) == 1)
		return (inet_ntop(AF_INET6, &sin6, name, len));

	/*
	 * Canonicalize a hostname
	 */

	/* 1. remove repeated dots and convert upper case to lower case */	
	plen = strlen(host);
	bzero(name, len);
	for (i = j = 0; i < plen; i++) {
		if (j >= (len - 1))
			goto fail;
		c = tolower(host[i]);
		if ((c == '.') && (j == 0 || name[j - 1] == '.'))
			continue;
		name[j++] = c;
	}

	/* 2. remove trailing dots */
	for (i = j; i > 0; i--) {
		if (name[i - 1] != '.')
			break;
		name[i - 1] = '\0';
		j--;
	}
	if (j <= 0)
		goto fail;

	return (name);

 fail:
	errno = EINVAL;
	return (NULL);
}
@


1.61
log
@unref the label when free'ing a protocol node
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.c,v 1.60 2007/11/25 20:01:10 reyk Exp $	*/
@


1.60
log
@in addition to IPv4/6 addresses, canonicalize the hostname for "url",
for example
".www...Example.com." will be translated to "www.example.com".

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.c,v 1.59 2007/11/24 17:07:28 reyk Exp $	*/
d535 2
@


1.59
log
@sort includes, adjust to style(9)
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.c,v 1.58 2007/11/24 16:13:50 reyk Exp $	*/
d37 1
d923 3
d927 6
d938 22
a959 4
	/* XXX canonicalize a FQDN... */
	if (strlcpy(name, host, len) >= len) {
		errno = EINVAL;
		return (NULL);
d961 2
d965 4
@


1.58
log
@extend the url lookup algorithm to match the full URL and different
possible suffix/prefix combinations by stripping subdomains, path
components, and the query args.

ok and tested by gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.c,v 1.57 2007/11/23 09:22:18 sthen Exp $	*/
a21 1
#include <sys/param.h>
d23 1
d27 1
@


1.57
log
@fix typo

ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.c,v 1.56 2007/11/21 20:13:20 reyk Exp $	*/
d25 2
d914 20
@


1.56
log
@move digest string handling into an extra function.
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.c,v 1.55 2007/11/20 15:54:55 reyk Exp $	*/
d83 1
a83 1
		if (check_child(pfe_pid, "pf udpate engine")) {
@


1.55
log
@it may be desirable to send a HTTP error page with error code and a
meaningful message if a HTTP/HTTPS relay closes the connection for
some reason. for example, a "403 Forbidden" if the request was
rejected by a filter. this will be enabled with the "return error"
option and is disabled by default, the standard behaviour is to
silently drop the connection; the browser may display an empty page in
this case. the look+feel of the HTTP error page can be customized with
a CSS style sheet, but we do not intend to allow customization of the
error page contents (hoststated is not a webserver!).

ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.c,v 1.54 2007/11/19 15:31:36 reyk Exp $	*/
d35 2
d896 16
@


1.54
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.c,v 1.53 2007/11/19 14:48:19 reyk Exp $	*/
d503 2
@


1.53
log
@rework the internal handling of protocol actions a little bit:

- allow to use a key for multiple times by appending a queue of
additional matches to the tree node. for example, this allows to
specify multiple "expect" or "filter" actions to white-/black-list
a list of HTTP-headers, URLs, ..

- prevent specifing an HTTP header for multiple times when using the
expect action.

- minor code shuffling
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.c,v 1.51 2007/11/15 17:02:01 pyr Exp $	*/
d247 1
a247 1
	    (ibuf_hce = calloc(1, sizeof(struct imsgbuf))) == NULL) 
d252 1
a252 1
		    sizeof(struct imsgbuf))) == NULL) 
d341 1
a341 1
		if (imsg_compose(&ibuf_relay[i], type, 0, 0, -1, buf, len) 
d427 1
a427 1
			imsg_compose(ibuf_hce, IMSG_RECONF_HOST, 0, 0, -1, 
@


1.52
log
@move repeated code to cleanup a protocol tree into a function.
@
text
@d513 1
a513 1
	struct protonode	*proot;
d521 8
@


1.51
log
@Do not insert proto_default inside the dynamically alloced protocol queue.
Handle it as a special case in the one place where it actually matters
instead.
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.c,v 1.50 2007/11/14 11:01:52 pyr Exp $	*/
d51 1
a441 1
	struct protonode	*pnode;
d501 2
a502 20
			while ((pnode = RB_ROOT(&proto->request_tree))
			    != NULL) {
				RB_REMOVE(proto_tree, &proto->request_tree,
				    pnode);
				if (pnode->key != NULL)
					free(pnode->key);
				if (pnode->value != NULL)
					free(pnode->value);
				free(pnode);
			}
			while ((pnode = RB_ROOT(&proto->response_tree))
			    != NULL) {
				RB_REMOVE(proto_tree, &proto->response_tree,
				    pnode);
				if (pnode->key != NULL)
					free(pnode->key);
				if (pnode->value != NULL)
					free(pnode->value);
				free(pnode);
			}
d507 15
@


1.50
log
@add some sanity, that will be useful later on.
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.c,v 1.49 2007/11/14 10:59:01 pyr Exp $	*/
a500 2
			if (strcmp(proto->name, "default") == 0)
				continue;
@


1.49
log
@make protos dynamic too
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.c,v 1.48 2007/11/13 10:35:21 pyr Exp $	*/
d370 2
d495 1
d501 1
a501 1
			if (proto == &env->proto_default)
d526 1
@


1.48
log
@relays are dynamic now.
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.c,v 1.47 2007/11/04 22:09:02 reyk Exp $	*/
d495 3
a497 3
	if (what & PURGE_PROTOS) {
		while ((proto = TAILQ_FIRST(&env->protos)) != NULL) {
			TAILQ_REMOVE(&env->protos, proto, entry);
d522 1
@


1.47
log
@the last change to enable logging to stderr on startup also enabled
annoying debugging messages on the console by default.  since we do
not want to see debugging messages unless specified by the "-d" flag,
add an extra debugging level "debug > 1" to be checked in log_debug().
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.c,v 1.46 2007/10/19 14:40:51 pyr Exp $	*/
d476 1
a476 1
	if (what & PURGE_RELAYS) {
@


1.46
log
@Do log initialisation correctly, like bgpd does.
This removes the double warn/log_warn madness i introduced yesterday.
This also keeps messages on stderr at startup and when running with -n.
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.c,v 1.45 2007/10/19 14:15:14 pyr Exp $	*/
d136 1
a136 1
			debug = 1;
d144 1
a144 1
			debug = 1;
@


1.45
log
@Move relays from static TAILQs to allocated ones.
This syncs it with other hoststated entities and will make reload easier.
This is step 1 out of 7 for reload.
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.c,v 1.44 2007/10/12 12:50:59 blambert Exp $	*/
d131 2
d144 1
a157 2
	log_init(debug);

d174 2
@


1.44
log
@Silence some lint(1) warnings

ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.c,v 1.43 2007/10/05 17:32:13 reyk Exp $	*/
d474 2
a475 2
		while ((rly = TAILQ_FIRST(&env->relays)) != NULL) {
			TAILQ_REMOVE(&env->relays, rly, entry);
d489 1
d737 1
a737 1
	TAILQ_FOREACH(rlay, &env->relays, entry)
d749 1
a749 1
	TAILQ_FOREACH(rlay, &env->relays, entry)
d796 1
a796 1
	TAILQ_FOREACH(rlay, &env->relays, entry)
@


1.43
log
@stylistic changes in the relay/relay_config structure.
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.c,v 1.42 2007/10/02 21:04:13 pyr Exp $	*/
d78 1
@


1.42
log
@stop messing with lgetc to please hoststated's check/expect.
instead move some of the logic in yylex and do hoststated specific
translations into hoststated.c
ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.c,v 1.41 2007/09/28 20:23:38 pyr Exp $	*/
d484 2
a485 2
			if (rly->ctx != NULL)
				SSL_CTX_free(rly->ctx);
@


1.41
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.c,v 1.40 2007/09/28 13:29:56 pyr Exp $	*/
d851 28
@


1.40
log
@Correct my mail address.
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.c,v 1.39 2007/09/05 08:48:42 reyk Exp $	*/
d476 2
a477 1
				SPLAY_REMOVE(session_tree, &rly->sessions, sess);
@


1.39
log
@store relay sessions in SPLAY trees instead of TAILQ lists. this will
be used for faster lookups of sessions based on different criteria.

ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.c,v 1.38 2007/07/05 09:42:26 thib Exp $	*/
d4 1
a4 1
 * Copyright (c) 2006 Pierre-Yves Ritschard <pyr@@spootnik.org>
@


1.38
log
@use a more traditional while() instead of for() for getopt().
sync usage() to the man page.
format string fixes.
complain about failed calloc()'s instead of exiting silently.

ok pry@@,reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.c,v 1.37 2007/06/19 06:29:20 pyr Exp $	*/
d475 2
a476 2
			while ((sess = TAILQ_FIRST(&rly->sessions)) != NULL) {
				TAILQ_REMOVE(&rly->sessions, sess, entry);
d747 1
a747 1
		TAILQ_FOREACH(con, &rlay->sessions, entry)
@


1.37
log
@Do not fatal out with ``pipe closed'' when a short read occurs on one
of our socket pairs. Instead disable listening on the pipe, terminate the
event loop, and let the parent process's SIGCHLD handler do a clean
shutdown.

from an ospfd diff by claudio, ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.c,v 1.36 2007/06/12 15:16:10 msf Exp $	*/
d108 1
a108 1
	fprintf(stderr, "%s [-dnv] [-f file]\n", __progname);
d130 1
a130 1
	for (;(c = getopt(argc, argv, "dD:nf:v")) != -1;) {
@


1.36
log
@put the fd passing from bgpd back in to hoststated's version of imsg,
needed for layer 7 reload support.

ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.c,v 1.35 2007/06/07 07:19:50 pyr Exp $	*/
d544 6
a549 2
		if (n == 0)
			fatalx("main_dispatch_pfe: pipe closed");
d606 6
a611 2
		if (n == 0)
			fatalx("main_dispatch_hce: pipe closed");
d661 6
a666 2
		if (n == 0)
			fatalx("main_dispatch_relay: pipe closed");
@


1.35
log
@(finally) Enable reload support for layer 3 configurations.
Hoststated can be reloaded either by sending SIGHUP to the parent process
or by using ``hoststatectl reload''
discussed and ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.c,v 1.34 2007/05/31 03:24:05 pyr Exp $	*/
d331 1
a331 1
	if (imsg_compose(ibuf_pfe, type, 0, 0, buf, len) == -1)
d333 1
a333 1
	if (imsg_compose(ibuf_hce, type, 0, 0, buf, len) == -1)
d336 2
a337 1
		if (imsg_compose(&ibuf_relay[i], type, 0, 0, buf, len) == -1)
d391 1
a391 1
	imsg_compose(ibuf_pfe, IMSG_RECONF, 0, 0, env, sizeof(*env));
d393 1
a393 1
		imsg_compose(ibuf_pfe, IMSG_RECONF_TABLE, 0, 0,
d396 1
a396 1
			imsg_compose(ibuf_pfe, IMSG_RECONF_HOST, 0, 0,
d401 1
a401 1
		imsg_compose(ibuf_pfe, IMSG_RECONF_SERVICE, 0, 0,
d404 1
a404 1
			imsg_compose(ibuf_pfe, IMSG_RECONF_VIRT, 0, 0,
d407 1
a407 1
	imsg_compose(ibuf_pfe, IMSG_RECONF_END, 0, 0, NULL, 0);
d412 1
a412 1
	imsg_compose(ibuf_hce, IMSG_RECONF, 0, 0, env, sizeof(*env));
d414 1
a414 1
		imsg_compose(ibuf_hce, IMSG_RECONF_TABLE, 0, 0,
d417 1
a417 1
			imsg_compose(ibuf_hce, IMSG_RECONF_SENDBUF, 0, 0,
d420 1
a420 1
			imsg_compose(ibuf_hce, IMSG_RECONF_HOST, 0, 0,
d424 1
a424 1
	imsg_compose(ibuf_hce, IMSG_RECONF_END, 0, 0, NULL, 0);
d629 1
a629 1
			    0, 0, &scr, sizeof(scr));
@


1.34
log
@allocate table lists and service lists instead of using static structs.
split the code to start the event loop in two functions.
introduce merge_config which will be used later on.
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.c,v 1.33 2007/05/30 00:51:21 pyr Exp $	*/
d50 1
d95 1
a95 1
		/* reconfigure */
d367 59
d438 1
a438 1
	if (what & PURGE_TABLES) {
d455 1
d458 1
a458 1
	if (what & PURGE_SERVICES) {
d468 1
a515 1

d574 1
@


1.33
log
@give ibuf to event_set
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.c,v 1.32 2007/05/30 00:19:25 pyr Exp $	*/
d342 25
d378 19
d398 2
a399 2
		while ((service = TAILQ_FIRST(&env->services)) != NULL) {
			TAILQ_REMOVE(&env->services, service, entry);
d406 1
a454 14
	if (what & PURGE_TABLES) {
		while ((table = TAILQ_FIRST(&env->tables)) != NULL) {
			TAILQ_REMOVE(&env->tables, table, entry);
			while ((host = TAILQ_FIRST(&table->hosts)) != NULL) {
				TAILQ_REMOVE(&table->hosts, host, entry);
				free(host);
			}
			if (table->sendbuf != NULL)
				free(table->sendbuf);
			if (table->ssl_ctx != NULL)
				SSL_CTX_free(table->ssl_ctx);
			free(table);
		}
	}
d625 1
a625 1
	TAILQ_FOREACH(table, &env->tables, entry)
d637 1
a637 1
	TAILQ_FOREACH(table, &env->tables, entry)
d648 1
a648 1
	TAILQ_FOREACH(service, &env->services, entry)
d684 1
a684 1
	TAILQ_FOREACH(table, &env->tables, entry)
d696 1
a696 1
	TAILQ_FOREACH(table, &env->tables, entry)
d707 1
a707 1
	TAILQ_FOREACH(service, &env->services, entry)
@


1.32
log
@backout more code that shouldn't have gone in.
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.c,v 1.31 2007/05/30 00:12:21 pyr Exp $	*/
d257 1
a257 1
		    ibuf->handler, env);
d263 1
a263 1
	    ibuf_pfe->handler, env);
d268 1
a268 1
	    ibuf_hce->handler, env);
@


1.31
log
@backout last diff which introduces problems and use the global
environment instead.
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.c,v 1.30 2007/05/29 23:58:30 pyr Exp $	*/
a49 1
void		 reconfigure(struct hoststated *);
a341 38
reconfigure(struct hoststated *env)
{
	struct hoststated	*new_env;
	struct table            *table;
	struct host             *host;
	struct service          *service;
	struct address          *virt;

	if ((new_env = parse_config(env->confpath, env->opts)) == NULL)
		fatalx("reconfigure: could not parse configuration");
	log_warnx("PURGING CONF");
	purge_config(env, PURGE_EVERYTHING);
	log_warnx("MEMCPY ENV");
	memcpy(env, new_env, sizeof(*env));
	/*
	 * XXX free(new_env)
	 */
	TAILQ_FOREACH(table, &env->tables, entry) {
		send_all(env, IMSG_RECONF_TABLE,
		    &table->conf, sizeof(table->conf));
		imsg_compose(ibuf_hce, IMSG_RECONF_SENDBUF, 0, 0,
		    table->sendbuf, strlen(table->sendbuf)); 
		TAILQ_FOREACH(host, &table->hosts, entry)
			send_all(env, IMSG_RECONF_HOST,
			    &host->conf, sizeof(host->conf));
	}
	TAILQ_FOREACH(service, &env->services, entry) {
		imsg_compose(ibuf_pfe, IMSG_RECONF_SERVICE, 0, 0,
		    &service->conf, sizeof(service->conf));
		TAILQ_FOREACH(virt, &service->virts, entry)
			imsg_compose(ibuf_pfe, IMSG_RECONF_VIRT, 0, 0,
			    virt, sizeof(*virt));
	}

	send_all(env, IMSG_RECONF_END, NULL, 0);
}

void
a481 1
			reconfigure(env);
@


1.30
log
@make sure every dispatch function is fed the environment structure.
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.c,v 1.29 2007/05/29 23:19:18 pyr Exp $	*/
d50 1
d343 38
a483 1
	struct hoststated	*env = ptr;
d521 1
d540 1
a540 1
	struct hoststated	*env = ptr;
a592 1
	struct hoststated	*env = ptr;
@


1.29
log
@allow the control handling code to send messages back to the parent.
forward IMSG_CTL_RELOAD which ends up not doing anything for now.
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.c,v 1.28 2007/05/29 18:59:53 pyr Exp $	*/
d257 1
a257 1
		    ibuf->handler, ibuf);
d263 1
a263 1
	    ibuf_pfe->handler, ibuf_pfe);
d268 1
a268 1
	    ibuf_hce->handler, ibuf_hce);
d445 1
d501 1
a501 1
	struct hoststated	*env;
d554 1
@


1.28
log
@do not start relay processes when no L7 load balancing is needed.
ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.c,v 1.27 2007/05/29 17:12:04 reyk Exp $	*/
d244 5
a248 4
	if (env->prefork_relay > 0 &&
	    (ibuf_relay = calloc(env->prefork_relay,
	    sizeof(struct imsgbuf)) == NULL))
		fatal(NULL);
d477 5
@


1.27
log
@add a new check method which allows to run external scripts/programs
for custom evaluations.

pyr agrees to put it in now but to do some improvements of the timeout
handling later.
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.c,v 1.26 2007/05/29 00:58:06 pyr Exp $	*/
d212 3
a214 2
	relay_pid = relay(env, pipe_parent2pfe, pipe_parent2hce,
	    pipe_parent2relay, pipe_pfe2hce, pipe_pfe2relay);
d241 4
a244 1
	    (ibuf_hce = calloc(1, sizeof(struct imsgbuf))) == NULL ||
d246 1
a246 1
	    sizeof(struct imsgbuf))) == NULL)
@


1.26
log
@when purging relays, purge sessions as well.
not needed for the initial purge since no sessions exist but will
be necessary when reloading the relay process.
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.c,v 1.25 2007/05/29 00:21:10 pyr Exp $	*/
d57 2
a72 2
	log_debug("signal %d", sig);

d157 1
d489 2
d492 1
d517 10
d534 1
@


1.25
log
@move struct relay to the runtime + config scheme.
this time around, include hoststatectl changes too.
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.c,v 1.24 2007/05/28 22:11:33 pyr Exp $	*/
d345 1
d361 4
@


1.24
log
@another small step towards hoststated reloading.
allow purging of parts of the hoststated environment structure.
start using this function now to only keep vital information in
hoststated children processes.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.c,v 1.23 2007/05/27 20:53:10 pyr Exp $	*/
d599 1
a599 1
		if (rlay->id == id)
d658 1
a658 1
		if (strcmp(rlay->name, name) == 0)
@


1.23
log
@Second step towards hoststated reload:
First split out hosts, tables and services into to structs, one that
contains the runtime fields and one (inside the runtime) that contains
mostly static fields that will be sent over the socket during reload.

Also move the demoted field of tables inside the flags field as its
just a boolean.
ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.c,v 1.22 2007/05/26 19:58:49 pyr Exp $	*/
d333 80
@


1.22
log
@first steps for implementing reload:
	* make parse_config allocate the hoststated function by itself
	* make as many sockets as necessary to talk to the relay children
	* add send_all for talking to all children
with advise and ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.c,v 1.21 2007/03/17 22:54:49 reyk Exp $	*/
d486 1
a486 1
			if (host->id == id)
d497 1
a497 1
		if (table->id == id)
d508 1
a508 1
		if (service->id == id)
d545 1
a545 1
			if (strcmp(host->name, name) == 0)
d556 1
a556 1
		if (strcmp(table->name, name) == 0)
d567 1
a567 1
		if (strcmp(service->name, name) == 0)
@


1.21
log
@remove a debug message
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.c,v 1.20 2007/02/26 16:10:24 reyk Exp $	*/
d48 2
a52 1
int		 pipe_parent2relay[2];
d54 1
d114 10
a123 9
	int		 c;
	int		 debug;
	u_int32_t	 opts;
	struct hoststated	 env;
	const char	*conffile;
	struct event	 ev_sigint;
	struct event	 ev_sigterm;
	struct event	 ev_sigchld;
	struct event	 ev_sighup;
a127 1
	bzero(&env, sizeof (env));
d155 1
a155 1
	if (parse_config(&env, conffile, opts))
d158 1
a158 1
	if (env.opts & HOSTSTATED_OPT_NOACTION) {
d163 1
a163 1
		env.opts |= HOSTSTATED_OPT_LOGUPDATE;
a184 3
	    pipe_parent2relay) == -1)
		fatal("socketpair");
	if (socketpair(AF_UNIX, SOCK_STREAM, PF_UNSPEC,
d187 4
a190 1
	for (c = 0; c < env.prefork_relay; c++) {
d196 2
a203 2
	session_socket_blockmode(pipe_parent2relay[0], BM_NONBLOCK);
	session_socket_blockmode(pipe_parent2relay[1], BM_NONBLOCK);
d207 1
a207 1
	pfe_pid = pfe(&env, pipe_parent2pfe, pipe_parent2hce,
d209 1
a209 1
	hce_pid = hce(&env, pipe_parent2pfe, pipe_parent2hce,
d211 1
a211 1
	relay_pid = relay(&env, pipe_parent2pfe, pipe_parent2hce,
d218 4
a221 4
	signal_set(&ev_sigint, SIGINT, main_sig_handler, &env);
	signal_set(&ev_sigterm, SIGTERM, main_sig_handler, &env);
	signal_set(&ev_sigchld, SIGCHLD, main_sig_handler, &env);
	signal_set(&ev_sighup, SIGHUP, main_sig_handler, &env);
a229 1
	close(pipe_parent2relay[1]);
d232 1
a232 1
	for (c = 0; c < env.prefork_relay; c++) {
d235 1
d240 2
a241 1
	    (ibuf_relay = calloc(1, sizeof(struct imsgbuf))) == NULL)
d246 8
a253 1
	imsg_init(ibuf_relay, pipe_parent2relay[0], main_dispatch_relay);
d265 2
a266 7
	ibuf_relay->events = EV_READ;
	event_set(&ibuf_relay->ev, ibuf_relay->fd, ibuf_relay->events,
	    ibuf_relay->handler, ibuf_relay);
	event_add(&ibuf_relay->ev, NULL);

	if (env.flags & F_DEMOTE)
		carp_demote_reset(env.demote_group, 0);
d319 16
d475 1
@


1.20
log
@handle strlcpy return values, make lint happy
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.c,v 1.19 2007/02/23 00:28:06 deraadt Exp $	*/
d509 1
a509 2
		TAILQ_FOREACH(con, &rlay->sessions, entry) {
			log_debug("session_find: %d : %d", id, con->id);
a511 1
		}
@


1.19
log
@knf
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.c,v 1.18 2007/02/22 05:58:06 reyk Exp $	*/
d610 1
a610 1
	strlcpy(label, tmp, len);	/* always fits */
@


1.18
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.c,v 1.17 2007/02/22 03:32:39 reyk Exp $	*/
d379 1
a379 1
	struct imsgbuf          *ibuf;
d419 1
a419 1
	struct imsgbuf          *ibuf;
d610 1
a610 1
	strlcpy(label, tmp, len);       /* always fits */
@


1.17
log
@Add layer 7 functionality to hoststated used for layer 7
loadbalancing, SSL acceleration, general-purpose TCP relaying, and
transparent proxying.

see hoststated.conf(5) and my upcoming article on undeadly.org for
details.

ok to commit deraadt@@ pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.c,v 1.16 2007/02/08 13:32:24 reyk Exp $	*/
d67 1
a67 1
	int		 	 die = 0;
d176 2
a177 1
	if (socketpair(AF_UNIX, SOCK_STREAM, PF_UNSPEC, pipe_parent2pfe) == -1)
d179 2
a180 1
	if (socketpair(AF_UNIX, SOCK_STREAM, PF_UNSPEC, pipe_parent2hce) == -1)
d182 2
a183 1
	if (socketpair(AF_UNIX, SOCK_STREAM, PF_UNSPEC, pipe_parent2relay) == -1)
d185 2
a186 1
	if (socketpair(AF_UNIX, SOCK_STREAM, PF_UNSPEC, pipe_pfe2hce) == -1)
d596 1
a596 1
	while ((q = strstr(p, srch)) != NULL) {   
@


1.16
log
@carefully check some return values and make lint happier.  never pass
any truncated strings (table names/anchors/tags/...) to pf and the
kernel.

ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.c,v 1.15 2007/02/07 13:30:17 reyk Exp $	*/
d43 1
a43 1
void		 main_shutdown(void);
d46 1
d51 1
d53 1
d57 1
d61 1
d66 4
a69 1
	int		 die = 0;
d84 4
d89 1
a89 1
			main_shutdown();
d160 2
d180 2
d184 7
d196 2
d201 6
a206 2
	pfe_pid = pfe(&env, pipe_parent2pfe, pipe_parent2hce, pipe_pfe2hce);
	hce_pid = hce(&env, pipe_parent2pfe, pipe_parent2hce, pipe_pfe2hce);
d212 4
a215 4
	signal_set(&ev_sigint, SIGINT, main_sig_handler, NULL);
	signal_set(&ev_sigterm, SIGTERM, main_sig_handler, NULL);
	signal_set(&ev_sigchld, SIGCHLD, main_sig_handler, NULL);
	signal_set(&ev_sighup, SIGHUP, main_sig_handler, NULL);
d224 1
d227 4
d233 2
a234 1
	    (ibuf_hce = calloc(1, sizeof(struct imsgbuf))) == NULL)
d239 1
d251 8
d265 1
a265 1
main_shutdown(void)
d273 2
d283 3
d328 1
d354 8
d412 40
d487 26
d548 11
d579 31
@


1.15
log
@add the -D option to define macros on the command line (as found in
bgpd(8), hostapd(8), ipsecctl(8), pfctl(8), ...).
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.c,v 1.14 2007/02/06 10:03:08 reyk Exp $	*/
d155 4
a158 2
	if (!debug)
		daemon(1, 0);
@


1.14
log
@change fatal message to know where it happened
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.c,v 1.13 2007/01/29 14:23:31 pyr Exp $	*/
d115 1
a115 1
	for (;(c = getopt(argc, argv, "dnf:v")) != -1;) {
d119 5
@


1.13
log
@Add SSL support to hoststated.
with help and OK reyk@@
with help and advice by claudio@@ and Srebrenko Sehic
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.c,v 1.12 2007/01/24 10:26:00 claudio Exp $	*/
d279 1
a279 1
			fatalx("parent: pipe closed");
d319 2
a320 2
		if (n == 0)     /* connection closed */
			fatalx("parent: pipe closed");
@


1.12
log
@Similar to ospfd and ripd ignore SIGPIPE in all processes to be able to do
a nice exit in case one of the processes dies. OK pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.c,v 1.11 2007/01/11 18:28:28 pyr Exp $	*/
d35 2
@


1.11
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.c,v 1.10 2007/01/11 18:05:08 reyk Exp $	*/
d182 1
@


1.10
log
@use real async events for checks and improve the non-blocking socket
usage. also modify the check_icmp code to use non-blocking raw sockets
and merge the icmp4 and icmp6 functions. some other minor changes
while i'm here.

as discussed with pyr@@ claudio@@ deraadt@@
ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.c,v 1.9 2007/01/09 13:50:11 pyr Exp $	*/
d415 2
a416 1
event_again(struct event *ev, int fd, short event, void (*fn)(int, short, void *),
@


1.9
log
@Finish renaming hostated to hoststated.
Note to testers: the user the daemon changes its id to is now _hoststated,
don't forget to update master.passwd.
ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.c,v 1.8 2007/01/09 02:32:58 reyk Exp $	*/
d412 21
@


1.8
log
@unbreak
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.c,v 1.7 2007/01/08 20:46:18 reyk Exp $	*/
d101 1
a101 1
	struct hostated	 env;
d119 1
a119 1
			opts |= HOSTATED_OPT_NOACTION;
d125 1
a125 1
			opts |= HOSTATED_OPT_VERBOSE;
d137 1
a137 1
	if (env.opts & HOSTATED_OPT_NOACTION) {
d145 2
a146 2
	if (getpwnam(HOSTATED_USER) == NULL)
		errx(1, "unknown user %s", HOSTATED_USER);
d345 1
a345 1
host_find(struct hostated *env, objid_t id)
d358 1
a358 1
table_find(struct hostated *env, objid_t id)
d369 1
a369 1
service_find(struct hostated *env, objid_t id)
d380 1
a380 1
host_findbyname(struct hostated *env, const char *name)
d393 1
a393 1
table_findbyname(struct hostated *env, const char *name)
d404 1
a404 1
service_findbyname(struct hostated *env, const char *name)
@


1.7
log
@do NOT use the regexp interface. it is way to complicated, error-prone
and we don't know about all the possible security problems.

change the check send/expect code to use the fnmatch(3) interface
using shell globbing rules instead. this allows simple patterns like
"220 * ESMTP*" or "SSH-[12].??-*".

suggested by deraadt@@ and otto@@
ok Pierre-Yves Ritschard (pyr at spootnik dot org)
@
text
@d1 1
a1 1
/*	$OpenBSD: hostated.c,v 1.6 2007/01/08 13:37:26 reyk Exp $	*/
d36 1
a36 1
#include "hostated.h"
@


1.6
log
@add a generic send/expect check using regular expression (see
regex(3)).  this allows to define additional checks for other TCP
protocols.

From Pierre-Yves Ritschard (pyr at spootnik dot org)
@
text
@d1 1
a1 1
/*	$OpenBSD: hostated.c,v 1.5 2006/12/25 18:40:38 reyk Exp $	*/
a34 1
#include <regex.h>
@


1.5
log
@knf
@
text
@d1 1
a1 1
/*	$OpenBSD: hostated.c,v 1.4 2006/12/16 18:50:33 reyk Exp $	*/
d35 1
@


1.4
log
@- allow to use host/service/table names instead of Ids in hostatectl.
- minor change of the "hostatectl show" command output
- increase the max service and tag names (max pf tag name size is 64 now!)

thanks to pyr who found a bug in my initial diff
@
text
@d1 1
a1 1
/*	$OpenBSD: hostated.c,v 1.3 2006/12/16 14:07:29 reyk Exp $	*/
d95 2
a96 1
int main(int argc, char *argv[])
@


1.3
log
@knf (second level indents are four spaces)
@
text
@d1 1
a1 1
/*	$OpenBSD: hostated.c,v 1.2 2006/12/16 12:42:14 reyk Exp $	*/
d374 35
@


1.2
log
@knf, spacing

please note that some editors will replace tabs with multiple spaces
if you cut & paste code from other sections.  please try to keep the
tabs ;).
@
text
@d1 1
a1 1
/*	$OpenBSD: hostated.c,v 1.1 2006/12/16 11:45:07 reyk Exp $	*/
d295 1
a295 1
				imsg.hdr.type);
d336 1
a336 1
				imsg.hdr.type);
@


1.1
log
@Import hostated, the host status daemon.  This daemon will monitor
remote hosts and dynamically alter pf(4) tables and redirection rules
for active server load balancing.  The daemon has been written by
Pierre-Yves Ritschard (pyr at spootnik.org) and was formerly known as
"slbd".

The daemon is fully functional but it still needs some work and
cleanup so we don't link it to the build yet.  Some TODOs are a
partial rewrite of the check_* routines (use libevent whenever we
can), improvement of the manpages, and general knf and cleanup.

ok deraadt@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d92 1
a92 1
	exit (1);
d101 1
a101 1
	const char	*conffile; 
a128 1
			
d168 1
a168 1
	
d181 1
a181 1
	
d194 9
a202 9
        ibuf_pfe->events = EV_READ;
        event_set(&ibuf_pfe->ev, ibuf_pfe->fd, ibuf_pfe->events,
            ibuf_pfe->handler, ibuf_pfe);
        event_add(&ibuf_pfe->ev, NULL);

        ibuf_hce->events = EV_READ;
        event_set(&ibuf_hce->ev, ibuf_hce->fd, ibuf_hce->events,
            ibuf_hce->handler, ibuf_hce);
        event_add(&ibuf_hce->ev, NULL);
d219 5
a223 5
        do {
                if ((pid = wait(NULL)) == -1 &&
                    errno != EINTR && errno != ECHILD)
                        fatal("wait");
        } while (pid != -1 || (pid == -1 && errno == EINTR));
d233 1
a233 1
        int     status;
d235 11
a245 11
        if (waitpid(pid, &status, WNOHANG) > 0) {
                if (WIFEXITED(status)) {
                        log_warnx("check_child: lost child: %s exited", pname);
                        return (1);
                }
                if (WIFSIGNALED(status)) {
                        log_warnx("check_child: lost child: %s terminated; signal %d",
                            pname, WTERMSIG(status));
                        return (1);
                }
        }
d247 1
a247 1
        return (0);
d258 2
a259 2
        event_set(&ibuf->ev, ibuf->fd, ibuf->events, ibuf->handler, ibuf);
        event_add(&ibuf->ev, NULL);
d307 2
a308 2
        struct imsg              imsg;
        ssize_t                  n;
d312 13
a324 13
        case EV_READ:
                if ((n = imsg_read(ibuf)) == -1)
                        fatal("imsg_read error");
                if (n == 0)     /* connection closed */
                        fatalx("parent: pipe closed");
                break;
        case EV_WRITE:
                if (msgbuf_write(&ibuf->w) == -1)
                        fatal("msgbuf_write");
                imsg_event_add(ibuf);
                return;
        default:
                fatalx("unknown event");
d327 14
a340 14
        for (;;) {
                if ((n = imsg_get(ibuf, &imsg)) == -1)
                        fatal("main_dispatch_hce: imsg_read error");
                if (n == 0)
                        break;

                switch (imsg.hdr.type) {
                default:
                        log_debug("main_dispatch_hce: unexpected imsg %d", 
                                imsg.hdr.type);
                        break;
                }
                imsg_free(&imsg);
        }
@

