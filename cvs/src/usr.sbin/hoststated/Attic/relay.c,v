head	1.75;
access;
symbols
	OPENBSD_4_2:1.36.0.2
	OPENBSD_4_2_BASE:1.36
	OPENBSD_4_1:1.18.0.2
	OPENBSD_4_1_BASE:1.18;
locks; strict;
comment	@ * @;


1.75
date	2007.12.07.17.27.07;	author deraadt;	state dead;
branches;
next	1.74;

1.74
date	2007.11.28.16.25.12;	author reyk;	state Exp;
branches;
next	1.73;

1.73
date	2007.11.28.14.41.36;	author reyk;	state Exp;
branches;
next	1.72;

1.72
date	2007.11.26.09.38.25;	author reyk;	state Exp;
branches;
next	1.71;

1.71
date	2007.11.24.17.43.47;	author reyk;	state Exp;
branches;
next	1.70;

1.70
date	2007.11.24.17.07.28;	author reyk;	state Exp;
branches;
next	1.69;

1.69
date	2007.11.24.16.13.50;	author reyk;	state Exp;
branches;
next	1.68;

1.68
date	2007.11.24.13.39.24;	author reyk;	state Exp;
branches;
next	1.67;

1.67
date	2007.11.23.09.39.42;	author reyk;	state Exp;
branches;
next	1.66;

1.66
date	2007.11.22.16.07.03;	author reyk;	state Exp;
branches;
next	1.65;

1.65
date	2007.11.22.10.09.53;	author reyk;	state Exp;
branches;
next	1.64;

1.64
date	2007.11.21.20.41.40;	author reyk;	state Exp;
branches;
next	1.63;

1.63
date	2007.11.21.20.01.45;	author reyk;	state Exp;
branches;
next	1.62;

1.62
date	2007.11.21.14.12.04;	author reyk;	state Exp;
branches;
next	1.61;

1.61
date	2007.11.21.11.06.21;	author reyk;	state Exp;
branches;
next	1.60;

1.60
date	2007.11.20.17.11.50;	author reyk;	state Exp;
branches;
next	1.59;

1.59
date	2007.11.20.15.54.55;	author reyk;	state Exp;
branches;
next	1.58;

1.58
date	2007.11.20.15.10.46;	author reyk;	state Exp;
branches;
next	1.57;

1.57
date	2007.11.20.09.59.09;	author reyk;	state Exp;
branches;
next	1.56;

1.56
date	2007.11.20.09.57.49;	author reyk;	state Exp;
branches;
next	1.55;

1.55
date	2007.11.19.15.31.36;	author reyk;	state Exp;
branches;
next	1.54;

1.54
date	2007.11.19.14.48.19;	author reyk;	state Exp;
branches;
next	1.53;

1.53
date	2007.10.22.17.14.10;	author reyk;	state Exp;
branches;
next	1.52;

1.52
date	2007.10.22.16.53.30;	author pyr;	state Exp;
branches;
next	1.51;

1.51
date	2007.10.19.14.15.14;	author pyr;	state Exp;
branches;
next	1.50;

1.50
date	2007.10.05.17.32.13;	author reyk;	state Exp;
branches;
next	1.49;

1.49
date	2007.10.05.15.46.49;	author reyk;	state Exp;
branches;
next	1.48;

1.48
date	2007.10.01.13.57.29;	author pyr;	state Exp;
branches;
next	1.47;

1.47
date	2007.09.28.13.05.28;	author pyr;	state Exp;
branches;
next	1.46;

1.46
date	2007.09.27.13.50.40;	author pyr;	state Exp;
branches;
next	1.45;

1.45
date	2007.09.27.13.34.22;	author pyr;	state Exp;
branches;
next	1.44;

1.44
date	2007.09.25.08.24.26;	author pyr;	state Exp;
branches;
next	1.43;

1.43
date	2007.09.10.11.59.22;	author reyk;	state Exp;
branches;
next	1.42;

1.42
date	2007.09.07.08.20.24;	author reyk;	state Exp;
branches;
next	1.41;

1.41
date	2007.09.06.19.55.45;	author reyk;	state Exp;
branches;
next	1.40;

1.40
date	2007.09.05.10.25.13;	author reyk;	state Exp;
branches;
next	1.39;

1.39
date	2007.09.05.08.48.42;	author reyk;	state Exp;
branches;
next	1.38;

1.38
date	2007.09.04.10.58.08;	author reyk;	state Exp;
branches;
next	1.37;

1.37
date	2007.09.04.10.32.54;	author reyk;	state Exp;
branches;
next	1.36;

1.36
date	2007.07.26.23.29.40;	author jsg;	state Exp;
branches;
next	1.35;

1.35
date	2007.06.19.06.29.20;	author pyr;	state Exp;
branches;
next	1.34;

1.34
date	2007.06.12.15.16.10;	author msf;	state Exp;
branches;
next	1.33;

1.33
date	2007.06.07.07.19.50;	author pyr;	state Exp;
branches;
next	1.32;

1.32
date	2007.05.29.00.48.04;	author pyr;	state Exp;
branches;
next	1.31;

1.31
date	2007.05.29.00.21.10;	author pyr;	state Exp;
branches;
next	1.30;

1.30
date	2007.05.28.22.11.33;	author pyr;	state Exp;
branches;
next	1.29;

1.29
date	2007.05.27.20.53.10;	author pyr;	state Exp;
branches;
next	1.28;

1.28
date	2007.05.26.19.58.49;	author pyr;	state Exp;
branches;
next	1.27;

1.27
date	2007.05.02.09.07.28;	author claudio;	state Exp;
branches;
next	1.26;

1.26
date	2007.04.12.14.45.45;	author reyk;	state Exp;
branches;
next	1.25;

1.25
date	2007.04.10.21.33.52;	author reyk;	state Exp;
branches;
next	1.24;

1.24
date	2007.04.10.18.18.26;	author reyk;	state Exp;
branches;
next	1.23;

1.23
date	2007.04.10.18.14.17;	author reyk;	state Exp;
branches;
next	1.22;

1.22
date	2007.03.21.00.08.08;	author reyk;	state Exp;
branches;
next	1.21;

1.21
date	2007.03.17.22.25.08;	author reyk;	state Exp;
branches;
next	1.20;

1.20
date	2007.03.17.22.22.23;	author reyk;	state Exp;
branches;
next	1.19;

1.19
date	2007.03.13.12.04.52;	author reyk;	state Exp;
branches;
next	1.18;

1.18
date	2007.03.07.17.40.32;	author reyk;	state Exp;
branches;
next	1.17;

1.17
date	2007.03.06.19.26.46;	author reyk;	state Exp;
branches;
next	1.16;

1.16
date	2007.03.05.11.44.50;	author reyk;	state Exp;
branches;
next	1.15;

1.15
date	2007.03.02.11.32.40;	author reyk;	state Exp;
branches;
next	1.14;

1.14
date	2007.02.27.13.38.58;	author reyk;	state Exp;
branches;
next	1.13;

1.13
date	2007.02.26.16.10.24;	author reyk;	state Exp;
branches;
next	1.12;

1.12
date	2007.02.26.15.41.44;	author reyk;	state Exp;
branches;
next	1.11;

1.11
date	2007.02.26.12.35.43;	author reyk;	state Exp;
branches;
next	1.10;

1.10
date	2007.02.26.12.16.12;	author reyk;	state Exp;
branches;
next	1.9;

1.9
date	2007.02.26.12.11.19;	author reyk;	state Exp;
branches;
next	1.8;

1.8
date	2007.02.26.12.09.21;	author reyk;	state Exp;
branches;
next	1.7;

1.7
date	2007.02.26.11.59.48;	author reyk;	state Exp;
branches;
next	1.6;

1.6
date	2007.02.26.11.24.26;	author reyk;	state Exp;
branches;
next	1.5;

1.5
date	2007.02.25.18.16.16;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2007.02.24.15.48.54;	author reyk;	state Exp;
branches;
next	1.3;

1.3
date	2007.02.24.00.22.32;	author reyk;	state Exp;
branches;
next	1.2;

1.2
date	2007.02.22.23.07.38;	author reyk;	state Exp;
branches;
next	1.1;

1.1
date	2007.02.22.03.32.40;	author reyk;	state Exp;
branches;
next	;


desc
@@


1.75
log
@hoststated/hoststatectl get repository copied (and de-tagged) into
relayd/relayctl.  This is a more suitable place for a daemon that has
grown out of it's initial roots of "monitoring and redirecting services
at various layers", into one that is "a full featured proxy, which
happens to know what is up/down"
@
text
@/*	$OpenBSD: relay.c,v 1.74 2007/11/28 16:25:12 reyk Exp $	*/

/*
 * Copyright (c) 2006, 2007 Reyk Floeter <reyk@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/queue.h>
#include <sys/time.h>
#include <sys/stat.h>
#include <sys/socket.h>
#include <sys/un.h>
#include <sys/tree.h>
#include <sys/hash.h>
#include <sys/resource.h>

#include <net/if.h>
#include <netinet/in_systm.h>
#include <netinet/in.h>
#include <netinet/ip.h>
#include <netinet/tcp.h>
#include <arpa/inet.h>

#include <errno.h>
#include <fcntl.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <stdio.h>
#include <err.h>
#include <pwd.h>
#include <event.h>
#include <fnmatch.h>

#include <openssl/ssl.h>

#include "hoststated.h"

void		 relay_sig_handler(int sig, short, void *);
void		 relay_statistics(int, short, void *);
void		 relay_dispatch_pfe(int, short, void *);
void		 relay_dispatch_parent(int, short, void *);
void		 relay_shutdown(void);

void		 relay_privinit(void);
void		 relay_nodedebug(const char *, struct protonode *);
void		 relay_protodebug(struct relay *);
void		 relay_init(void);
void		 relay_launch(void);
int		 relay_socket_af(struct sockaddr_storage *, in_port_t);
int		 relay_socket(struct sockaddr_storage *, in_port_t,
		    struct protocol *);
int		 relay_socket_listen(struct sockaddr_storage *, in_port_t,
		    struct protocol *);
int		 relay_socket_connect(struct sockaddr_storage *, in_port_t,
		    struct protocol *);

void		 relay_accept(int, short, void *);
void		 relay_input(struct session *);
void		 relay_close(struct session *, const char *);
void		 relay_session(struct session *);
void		 relay_natlook(int, short, void *);

int		 relay_connect(struct session *);
void		 relay_connected(int, short, void *);

u_int32_t	 relay_hash_addr(struct sockaddr_storage *, u_int32_t);
int		 relay_from_table(struct session *);

void		 relay_write(struct bufferevent *, void *);
void		 relay_read(struct bufferevent *, void *);
void		 relay_error(struct bufferevent *, short, void *);
void		 relay_dump(struct ctl_relay_event *, const void *, size_t);

int		 relay_resolve(struct ctl_relay_event *,
		    struct protonode *, struct protonode *);
int		 relay_handle_http(struct ctl_relay_event *,
		    struct protonode *, struct protonode *,
		    struct protonode *, int);
void		 relay_read_http(struct bufferevent *, void *);
static int	_relay_lookup_url(struct ctl_relay_event *, char *, char *,
		    char *, enum digest_type);
int		 relay_lookup_url(struct ctl_relay_event *,
		    const char *, enum digest_type);
int		 relay_lookup_query(struct ctl_relay_event *);
int		 relay_lookup_cookie(struct ctl_relay_event *, const char *);
void		 relay_read_httpcontent(struct bufferevent *, void *);
void		 relay_read_httpchunks(struct bufferevent *, void *);
char		*relay_expand_http(struct ctl_relay_event *, char *,
		    char *, size_t);
void		 relay_close_http(struct session *, u_int, const char *,
		    u_int16_t);

SSL_CTX		*relay_ssl_ctx_create(struct relay *);
void		 relay_ssl_transaction(struct session *);
void		 relay_ssl_accept(int, short, void *);
void		 relay_ssl_connected(struct ctl_relay_event *);
void		 relay_ssl_readcb(int, short, void *);
void		 relay_ssl_writecb(int, short, void *);

int		 relay_bufferevent_add(struct event *, int);
#ifdef notyet
int		 relay_bufferevent_printf(struct ctl_relay_event *,
		    const char *, ...);
#endif
int		 relay_bufferevent_print(struct ctl_relay_event *, char *);
int		 relay_bufferevent_write_buffer(struct ctl_relay_event *,
		    struct evbuffer *);
int		 relay_bufferevent_write_chunk(struct ctl_relay_event *,
		    struct evbuffer *, size_t);
int		 relay_bufferevent_write(struct ctl_relay_event *,
		    void *, size_t);
int		 relay_cmp_af(struct sockaddr_storage *,
		    struct sockaddr_storage *);
char		*relay_load_file(const char *, off_t *);
static __inline int
		 relay_proto_cmp(struct protonode *, struct protonode *);
extern void	 bufferevent_read_pressure_cb(struct evbuffer *, size_t,
		    size_t, void *);

volatile sig_atomic_t relay_sessions;
objid_t relay_conid;

static struct hoststated	*env = NULL;
struct imsgbuf			*ibuf_pfe;
struct imsgbuf			*ibuf_main;
int				 proc_id;

#if DEBUG > 1
#define DPRINTF		log_debug
#else
#define DPRINTF(x...)	do { } while(0)
#endif

void
relay_sig_handler(int sig, short event, void *arg)
{
	switch (sig) {
	case SIGTERM:
	case SIGINT:
		(void)event_loopexit(NULL);
	}
}

pid_t
relay(struct hoststated *x_env, int pipe_parent2pfe[2], int pipe_parent2hce[2],
    int pipe_parent2relay[RELAY_MAXPROC][2], int pipe_pfe2hce[2],
    int pipe_pfe2relay[RELAY_MAXPROC][2])
{
	pid_t		 pid;
	struct passwd	*pw;
	struct event	 ev_sigint;
	struct event	 ev_sigterm;
	int		 i;

	switch (pid = fork()) {
	case -1:
		fatal("relay: cannot fork");
	case 0:
		break;
	default:
		return (pid);
	}

	env = x_env;
	purge_config(env, PURGE_SERVICES);

	/* Need root privileges for relay initialization */
	relay_privinit();

	if ((pw = getpwnam(HOSTSTATED_USER)) == NULL)
		fatal("relay: getpwnam");

#ifndef DEBUG
	if (chroot(pw->pw_dir) == -1)
		fatal("relay: chroot");
	if (chdir("/") == -1)
		fatal("relay: chdir(\"/\")");

#else
#warning disabling privilege revocation and chroot in DEBUG mode
#endif

	setproctitle("socket relay engine");
	hoststated_process = PROC_RELAY;

#ifndef DEBUG
	if (setgroups(1, &pw->pw_gid) ||
	    setresgid(pw->pw_gid, pw->pw_gid, pw->pw_gid) ||
	    setresuid(pw->pw_uid, pw->pw_uid, pw->pw_uid))
		fatal("relay: can't drop privileges");
#endif

	/* Fork child handlers */
	for (i = 1; i < env->prefork_relay; i++) {
		if (fork() == 0) {
			proc_id = i;
			break;
		}
	}

	event_init();

	/* Per-child initialization */
	relay_init();

	signal_set(&ev_sigint, SIGINT, relay_sig_handler, NULL);
	signal_set(&ev_sigterm, SIGTERM, relay_sig_handler, NULL);
	signal_add(&ev_sigint, NULL);
	signal_add(&ev_sigterm, NULL);
	signal(SIGHUP, SIG_IGN);
	signal(SIGPIPE, SIG_IGN);

	/* setup pipes */
	close(pipe_pfe2hce[0]);
	close(pipe_pfe2hce[1]);
	close(pipe_parent2hce[0]);
	close(pipe_parent2hce[1]);
	close(pipe_parent2pfe[0]);
	close(pipe_parent2pfe[1]);
	for (i = 0; i < env->prefork_relay; i++) {
		if (i == proc_id)
			continue;
		close(pipe_parent2relay[i][0]);
		close(pipe_parent2relay[i][1]);
		close(pipe_pfe2relay[i][0]);
		close(pipe_pfe2relay[i][1]);
	}
	close(pipe_parent2relay[proc_id][1]);
	close(pipe_pfe2relay[proc_id][1]);

	if ((ibuf_pfe = calloc(1, sizeof(struct imsgbuf))) == NULL ||
	    (ibuf_main = calloc(1, sizeof(struct imsgbuf))) == NULL)
		fatal("relay");
	imsg_init(ibuf_main, pipe_parent2relay[proc_id][0],
	    relay_dispatch_parent);
	imsg_init(ibuf_pfe, pipe_pfe2relay[proc_id][0], relay_dispatch_pfe);

	ibuf_pfe->events = EV_READ;
	event_set(&ibuf_pfe->ev, ibuf_pfe->fd, ibuf_pfe->events,
	    ibuf_pfe->handler, ibuf_pfe);
	event_add(&ibuf_pfe->ev, NULL);

	ibuf_main->events = EV_READ;
	event_set(&ibuf_main->ev, ibuf_main->fd, ibuf_main->events,
	    ibuf_main->handler, ibuf_main);
	event_add(&ibuf_main->ev, NULL);

	relay_launch();

	event_dispatch();
	relay_shutdown();

	return (0);
}

void
relay_shutdown(void)
{
	struct session	*con;

	struct relay	*rlay;
	TAILQ_FOREACH(rlay, env->relays, entry) {
		if (rlay->conf.flags & F_DISABLE)
			continue;
		close(rlay->s);
		while ((con = SPLAY_ROOT(&rlay->sessions)) != NULL)
			relay_close(con, "shutdown");
	}
	usleep(200);	/* XXX relay needs to shutdown last */
	log_info("socket relay engine exiting");
	_exit(0);
}

void
relay_nodedebug(const char *name, struct protonode *pn)
{
	const char	*s;
	int		 digest;

	if (pn->action == NODE_ACTION_NONE)
		return;

	fprintf(stderr, "\t\t");
	fprintf(stderr, "%s ", name);

	switch (pn->type) {
	case NODE_TYPE_HEADER:
		break;
	case NODE_TYPE_QUERY:
		fprintf(stderr, "query ");
		break;
	case NODE_TYPE_COOKIE:
		fprintf(stderr, "cookie ");
		break;
	case NODE_TYPE_PATH:
		fprintf(stderr, "path ");
		break;
	case NODE_TYPE_URL:
		fprintf(stderr, "url ");
		break;
	}

	switch (pn->action) {
	case NODE_ACTION_APPEND:
		fprintf(stderr, "append \"%s\" to \"%s\"",
		    pn->value, pn->key);
		break;
	case NODE_ACTION_CHANGE:
		fprintf(stderr, "change \"%s\" to \"%s\"",
		    pn->key, pn->value);
		break;
	case NODE_ACTION_REMOVE:
		fprintf(stderr, "remove \"%s\"",
		    pn->key);
		break;
	case NODE_ACTION_EXPECT:
	case NODE_ACTION_FILTER:
		s = pn->action == NODE_ACTION_EXPECT ? "expect" : "filter";
		digest = pn->flags & PNFLAG_LOOKUP_URL_DIGEST;
		if (strcmp(pn->value, "*") == 0)
			fprintf(stderr, "%s %s\"%s\"", s,
			    digest ? "digest " : "", pn->key);
		else
			fprintf(stderr, "%s \"%s\" from \"%s\"", s,
			    pn->value, pn->key);
		break;
	case NODE_ACTION_HASH:
		fprintf(stderr, "hash \"%s\"", pn->key);
		break;
	case NODE_ACTION_LOG:
		fprintf(stderr, "log \"%s\"", pn->key);
		break;
	case NODE_ACTION_MARK:
		if (strcmp(pn->value, "*") == 0)
			fprintf(stderr, "mark \"%s\"", pn->key);
		else
			fprintf(stderr, "mark \"%s\" from \"%s\"",
			    pn->value, pn->key);
		break;
	case NODE_ACTION_NONE:
		break;
	}
	fprintf(stderr, "\n");
}

void
relay_protodebug(struct relay *rlay)
{
	struct protocol		*proto = rlay->proto;
	struct protonode	*proot, *pn;
	struct proto_tree	*tree;
	const char		*name;
	int			 i;

	fprintf(stderr, "protocol %d: name %s\n", proto->id, proto->name);
	fprintf(stderr, "\tflags: 0x%04x\n", proto->flags);
	if (proto->cache != -1)
		fprintf(stderr, "\tssl session cache: %d\n", proto->cache);
	fprintf(stderr, "\ttype: ");
	switch (proto->type) {
	case RELAY_PROTO_TCP:
		fprintf(stderr, "tcp\n");
		break;
	case RELAY_PROTO_HTTP:
		fprintf(stderr, "http\n");
		break;
	case RELAY_PROTO_DNS:
		fprintf(stderr, "dns\n");
		break;
	}

	name = "request";
	tree = &proto->request_tree;
 show:
	i = 0;
	RB_FOREACH(proot, proto_tree, tree) {
		PROTONODE_FOREACH(pn, proot, entry) {
#ifndef DEBUG
			if (++i > 100)
				break;
#endif
			relay_nodedebug(name, pn);
		}
#ifndef DEBUG
		/* Limit the number of displayed lines */
		if (++i > 100) {
			fprintf(stderr, "\t\t...\n");
			break;
		}
#endif
	}
	if (tree == &proto->request_tree) {
		name = "response";
		tree = &proto->response_tree;
		goto show;
	}
}

void
relay_privinit(void)
{
	struct relay	*rlay;
	extern int	 debug;

	if (env->flags & F_SSL)
		ssl_init(env);

	TAILQ_FOREACH(rlay, env->relays, entry) {
		log_debug("relay_privinit: adding relay %s", rlay->conf.name);

		if (debug)
			relay_protodebug(rlay);

		switch (rlay->proto->type) {
		case RELAY_PROTO_DNS:
			relay_udp_privinit(env, rlay);
			break;
		case RELAY_PROTO_TCP:
		case RELAY_PROTO_HTTP:
			/* Use defaults */
			break;
		}

		if (rlay->conf.flags & F_UDP)
			rlay->s = relay_udp_bind(&rlay->conf.ss,
			    rlay->conf.port, rlay->proto);
		else
			rlay->s = relay_socket_listen(&rlay->conf.ss,
			    rlay->conf.port, rlay->proto);
		if (rlay->s == -1)
			fatal("relay_privinit: failed to listen");
	}
}

void
relay_init(void)
{
	struct relay	*rlay;
	struct host	*host;
	struct timeval	 tv;
	struct rlimit	 rl;

	if (getrlimit(RLIMIT_NOFILE, &rl) == -1)
		fatal("relay_init: failed to get resource limit");
	log_debug("relay_init: max open files %d", rl.rlim_max);

	/*
	 * Allow the maximum number of open file descriptors for this
	 * login class (which should be the class "daemon" by default).
	 */
	rl.rlim_cur = rl.rlim_max;
	if (setrlimit(RLIMIT_NOFILE, &rl) == -1)
		fatal("relay_init: failed to set resource limit");

	TAILQ_FOREACH(rlay, env->relays, entry) {
		if ((rlay->conf.flags & F_SSL) &&
		    (rlay->ssl_ctx = relay_ssl_ctx_create(rlay)) == NULL)
			fatal("relay_init: failed to create SSL context");

		if (rlay->dsttable != NULL) {
			switch (rlay->conf.dstmode) {
			case RELAY_DSTMODE_ROUNDROBIN:
				rlay->dstkey = 0;
				break;
			case RELAY_DSTMODE_LOADBALANCE:
			case RELAY_DSTMODE_HASH:
				rlay->dstkey =
				    hash32_str(rlay->conf.name, HASHINIT);
				rlay->dstkey =
				    hash32_str(rlay->dsttable->conf.name,
				    rlay->dstkey);
				break;
			}
			rlay->dstnhosts = 0;
			TAILQ_FOREACH(host, &rlay->dsttable->hosts, entry) {
				if (rlay->dstnhosts >= RELAY_MAXHOSTS)
					fatal("relay_init: "
					    "too many hosts in table");
				host->idx = rlay->dstnhosts;
				rlay->dsthost[rlay->dstnhosts++] = host;
			}
			log_info("adding %d hosts from table %s%s",
			    rlay->dstnhosts, rlay->dsttable->conf.name,
			    rlay->conf.dstcheck ? "" : " (no check)");
		}
	}

	/* Schedule statistics timer */
	evtimer_set(&env->statev, relay_statistics, NULL);
	bcopy(&env->statinterval, &tv, sizeof(tv));
	evtimer_add(&env->statev, &tv);
}

void
relay_statistics(int fd, short events, void *arg)
{
	struct relay		*rlay;
	struct ctl_stats	 crs, *cur;
	struct timeval		 tv, tv_now;
	int			 resethour = 0, resetday = 0;
	struct session		*con, *next_con;

	/*
	 * This is a hack to calculate some average statistics.
	 * It doesn't try to be very accurate, but could be improved...
	 */

	timerclear(&tv);
	if (gettimeofday(&tv_now, NULL))
		fatal("relay_init: gettimeofday");

	TAILQ_FOREACH(rlay, env->relays, entry) {
		bzero(&crs, sizeof(crs));
		resethour = resetday = 0;

		cur = &rlay->stats[proc_id];
		cur->cnt += cur->last;
		cur->tick++;
		cur->avg = (cur->last + cur->avg) / 2;
		cur->last_hour += cur->last;
		if ((cur->tick % (3600 / env->statinterval.tv_sec)) == 0) {
			cur->avg_hour = (cur->last_hour + cur->avg_hour) / 2;
			resethour++;
		}
		cur->last_day += cur->last;
		if ((cur->tick % (86400 / env->statinterval.tv_sec)) == 0) {
			cur->avg_day = (cur->last_day + cur->avg_day) / 2;
			resethour++;
		}
		bcopy(cur, &crs, sizeof(crs));

		cur->last = 0;
		if (resethour)
			cur->last_hour = 0;
		if (resetday)
			cur->last_day = 0;

		crs.id = rlay->conf.id;
		crs.proc = proc_id;
		imsg_compose(ibuf_pfe, IMSG_STATISTICS, 0, 0, -1,
		    &crs, sizeof(crs));

		for (con = SPLAY_ROOT(&rlay->sessions);
		    con != NULL; con = next_con) {
			next_con = SPLAY_NEXT(session_tree,
			    &rlay->sessions, con);
			timersub(&tv_now, &con->tv_last, &tv);
			if (timercmp(&tv, &rlay->conf.timeout, >=))
				relay_close(con, "hard timeout");
		}
	}

	/* Schedule statistics timer */
	evtimer_set(&env->statev, relay_statistics, NULL);
	bcopy(&env->statinterval, &tv, sizeof(tv));
	evtimer_add(&env->statev, &tv);
}

void
relay_launch(void)
{
	struct relay	*rlay;
	void		(*callback)(int, short, void *);

	TAILQ_FOREACH(rlay, env->relays, entry) {
		log_debug("relay_launch: running relay %s", rlay->conf.name);

		rlay->up = HOST_UP;

		if (rlay->conf.flags & F_UDP)
			callback = relay_udp_server;
		else
			callback = relay_accept;

		event_set(&rlay->ev, rlay->s, EV_READ|EV_PERSIST,
		    callback, rlay);
		event_add(&rlay->ev, NULL);
	}
}

int
relay_socket_af(struct sockaddr_storage *ss, in_port_t port)
{
	switch (ss->ss_family) {
	case AF_INET:
		((struct sockaddr_in *)ss)->sin_port = port;
		((struct sockaddr_in *)ss)->sin_len =
		    sizeof(struct sockaddr_in);
		break;
	case AF_INET6:
		((struct sockaddr_in6 *)ss)->sin6_port = port;
		((struct sockaddr_in6 *)ss)->sin6_len =
		    sizeof(struct sockaddr_in6);
		break;
	default:
		return (-1);
	}

	return (0);
}

int
relay_socket(struct sockaddr_storage *ss, in_port_t port,
    struct protocol *proto)
{
	int s = -1, val;
	struct linger lng;

	if (relay_socket_af(ss, port) == -1)
		goto bad;

	if ((s = socket(ss->ss_family, SOCK_STREAM, IPPROTO_TCP)) == -1)
		goto bad;

	/*
	 * Socket options
	 */
	bzero(&lng, sizeof(lng));
	if (setsockopt(s, SOL_SOCKET, SO_LINGER, &lng, sizeof(lng)) == -1)
		goto bad;
	val = 1;
	if (setsockopt(s, SOL_SOCKET, SO_REUSEPORT, &val, sizeof(int)) == -1)
		goto bad;
	if (fcntl(s, F_SETFL, O_NONBLOCK) == -1)
		goto bad;
	if (proto->tcpflags & TCPFLAG_BUFSIZ) {
		val = proto->tcpbufsiz;
		if (setsockopt(s, SOL_SOCKET, SO_RCVBUF,
		    &val, sizeof(val)) == -1)
			goto bad;
		val = proto->tcpbufsiz;
		if (setsockopt(s, SOL_SOCKET, SO_SNDBUF,
		    &val, sizeof(val)) == -1)
			goto bad;
	}

	/*
	 * IP options
	 */
	if (proto->tcpflags & TCPFLAG_IPTTL) {
		val = (int)proto->tcpipttl;
		if (setsockopt(s, IPPROTO_IP, IP_TTL,
		    &val, sizeof(val)) == -1)
			goto bad;
	}
	if (proto->tcpflags & TCPFLAG_IPMINTTL) {
		val = (int)proto->tcpipminttl;
		if (setsockopt(s, IPPROTO_IP, IP_MINTTL,
		    &val, sizeof(val)) == -1)
			goto bad;
	}

	/*
	 * TCP options
	 */
	if (proto->tcpflags & (TCPFLAG_NODELAY|TCPFLAG_NNODELAY)) {
		if (proto->tcpflags & TCPFLAG_NNODELAY)
			val = 0;
		else
			val = 1;
		if (setsockopt(s, IPPROTO_TCP, TCP_NODELAY,
		    &val, sizeof(val)) == -1)
			goto bad;
	}
	if (proto->tcpflags & (TCPFLAG_SACK|TCPFLAG_NSACK)) {
		if (proto->tcpflags & TCPFLAG_NSACK)
			val = 0;
		else
			val = 1;
		if (setsockopt(s, IPPROTO_TCP, TCP_SACK_ENABLE,
		    &val, sizeof(val)) == -1)
			goto bad;
	}

	return (s);

 bad:
	if (s != -1)
		close(s);
	return (-1);
}

int
relay_socket_connect(struct sockaddr_storage *ss, in_port_t port,
    struct protocol *proto)
{
	int s;

	if ((s = relay_socket(ss, port, proto)) == -1)
		return (-1);

	if (connect(s, (struct sockaddr *)ss, ss->ss_len) == -1) {
		if (errno != EINPROGRESS)
			goto bad;
	}

	return (s);

 bad:
	close(s);
	return (-1);
}

int
relay_socket_listen(struct sockaddr_storage *ss, in_port_t port,
    struct protocol *proto)
{
	int s;

	if ((s = relay_socket(ss, port, proto)) == -1)
		return (-1);

	if (bind(s, (struct sockaddr *)ss, ss->ss_len) == -1)
		goto bad;
	if (listen(s, proto->tcpbacklog) == -1)
		goto bad;

	return (s);

 bad:
	close(s);
	return (-1);
}

void
relay_connected(int fd, short sig, void *arg)
{
	struct session		*con = (struct session *)arg;
	struct relay		*rlay = (struct relay *)con->relay;
	struct protocol		*proto = rlay->proto;
	evbuffercb		 outrd = relay_read;
	evbuffercb		 outwr = relay_write;
	struct bufferevent	*bev;

	if (sig == EV_TIMEOUT) {
		relay_close_http(con, 504, "connect timeout", 0);
		return;
	}

	DPRINTF("relay_connected: session %d: %ssuccessful",
	    con->id, rlay->proto->lateconnect ? "late connect " : "");

	switch (rlay->proto->type) {
	case RELAY_PROTO_HTTP:
		/* Check the servers's HTTP response */
		if (!RB_EMPTY(&rlay->proto->response_tree)) {
			outrd = relay_read_http;
			if ((con->out.nodes = calloc(proto->response_nodes,
			    sizeof(u_int8_t))) == NULL) {
				relay_close_http(con, 500,
				    "failed to allocate nodes", 0);
				return;
			}
		}
		break;
	case RELAY_PROTO_TCP:
		/* Use defaults */
		break;
	default:
		fatalx("relay_input: unknown protocol");
	}

	/*
	 * Relay <-> Server
	 */
	bev = bufferevent_new(fd, outrd, outwr, relay_error, &con->out);
	if (bev == NULL) {
		relay_close_http(con, 500,
		    "failed to allocate output buffer event", 0);
		return;
	}
	evbuffer_free(bev->output);
	bev->output = con->out.output;
	if (bev->output == NULL)
		fatal("relay_connected: invalid output buffer");

	con->out.bev = bev;
	bufferevent_settimeout(bev,
	    rlay->conf.timeout.tv_sec, rlay->conf.timeout.tv_sec);
	bufferevent_enable(bev, EV_READ|EV_WRITE);
}

void
relay_input(struct session *con)
{
	struct relay	*rlay = (struct relay *)con->relay;
	struct protocol *proto = rlay->proto;
	evbuffercb	 inrd = relay_read;
	evbuffercb	 inwr = relay_write;

	switch (rlay->proto->type) {
	case RELAY_PROTO_HTTP:
		/* Check the client's HTTP request */
		if (!RB_EMPTY(&rlay->proto->request_tree) ||
		    proto->lateconnect) {
			inrd = relay_read_http;
			if ((con->in.nodes = calloc(proto->request_nodes,
			    sizeof(u_int8_t))) == NULL) {
				relay_close(con, "failed to allocate nodes");
				return;
			}
		}
		break;
	case RELAY_PROTO_TCP:
		/* Use defaults */
		break;
	default:
		fatalx("relay_input: unknown protocol");
	}

	/*
	 * Client <-> Relay
	 */
	con->in.bev = bufferevent_new(con->in.s, inrd, inwr,
	    relay_error, &con->in);
	if (con->in.bev == NULL) {
		relay_close(con, "failed to allocate input buffer event");
		return;
	}

	/* Initialize the SSL wrapper */
	if ((rlay->conf.flags & F_SSL) && con->in.ssl != NULL)
		relay_ssl_connected(&con->in);

	bufferevent_settimeout(con->in.bev,
	    rlay->conf.timeout.tv_sec, rlay->conf.timeout.tv_sec);
	bufferevent_enable(con->in.bev, EV_READ|EV_WRITE);
}

void
relay_write(struct bufferevent *bev, void *arg)
{
	struct ctl_relay_event	*cre = (struct ctl_relay_event *)arg;
	struct session		*con = (struct session *)cre->con;
	if (gettimeofday(&con->tv_last, NULL))
		con->done = 1;
	if (con->done)
		relay_close(con, "last write (done)");
}

void
relay_dump(struct ctl_relay_event *cre, const void *buf, size_t len)
{
	/*
	 * This function will dump the specified message directly
	 * to the underlying session, without waiting for success
	 * of non-blocking events etc. This is useful to print an
	 * error message before gracefully closing the session.
	 */
	if (cre->ssl != NULL)
		(void)SSL_write(cre->ssl, buf, len);
	else
		(void)write(cre->s, buf, len);
}

void
relay_read(struct bufferevent *bev, void *arg)
{
	struct ctl_relay_event	*cre = (struct ctl_relay_event *)arg;
	struct session		*con = (struct session *)cre->con;
	struct evbuffer		*src = EVBUFFER_INPUT(bev);

	if (gettimeofday(&con->tv_last, NULL))
		goto done;
	if (!EVBUFFER_LENGTH(src))
		return;
	if (relay_bufferevent_write_buffer(cre->dst, src) == -1)
		goto fail;
	if (con->done)
		goto done;
	bufferevent_enable(con->in.bev, EV_READ);
	return;
 done:
	relay_close(con, "last read (done)");
	return;
 fail:
	relay_close(con, strerror(errno));
}

int
relay_resolve(struct ctl_relay_event *cre,
    struct protonode *proot, struct protonode *pn)
{
	struct session		*con = (struct session *)cre->con;
	char			 buf[READ_BUF_SIZE], *ptr;
	int			 id;

	if (pn->mark && (pn->mark != con->mark))
		return (0);

	switch (pn->action) {
	case NODE_ACTION_FILTER:
		id = cre->nodes[proot->id];
		if (SIMPLEQ_NEXT(pn, entry) == NULL)
			cre->nodes[proot->id] = 0;
		if (id <= 1)
			return (0);
		break;
	case NODE_ACTION_EXPECT:
		id = cre->nodes[proot->id];
		if (SIMPLEQ_NEXT(pn, entry) == NULL)
			cre->nodes[proot->id] = 0;
		if (id > 1)
			return (0);
		break;
	default:
		if (cre->nodes[pn->id]) {
			cre->nodes[pn->id] = 0;
			return (0);
		}
		break;
	}
	switch (pn->action) {
	case NODE_ACTION_APPEND:
	case NODE_ACTION_CHANGE:
		ptr = pn->value;
		if ((pn->flags & PNFLAG_MACRO) &&
		    (ptr = relay_expand_http(cre, pn->value,
		    buf, sizeof(buf))) == NULL)
			break;
		if (relay_bufferevent_print(cre->dst, pn->key) == -1 ||
		    relay_bufferevent_print(cre->dst, ": ") == -1 ||
		    relay_bufferevent_print(cre->dst, ptr) == -1 ||
		    relay_bufferevent_print(cre->dst, "\r\n") == -1) {
			relay_close_http(con, 500,
			    "failed to modify header", 0);
			return (-1);
		}
		DPRINTF("relay_resolve: add '%s: %s'",
		    pn->key, ptr);
		break;
	case NODE_ACTION_EXPECT:
		DPRINTF("relay_resolve: missing '%s: %s'",
		    pn->key, pn->value);
		relay_close_http(con, 403, "incomplete request", pn->label);
		return (-1);
	case NODE_ACTION_FILTER:
		DPRINTF("relay_resolve: filtered '%s: %s'",
		    pn->key, pn->value);
		relay_close_http(con, 403, "rejecting request", pn->label);
		return (-1);
	default:
		break;
	}
	return (0);
}

char *
relay_expand_http(struct ctl_relay_event *cre, char *val, char *buf, size_t len)
{
	struct session	*con = (struct session *)cre->con;
	struct relay	*rlay = (struct relay *)con->relay;
	char		 ibuf[128];

	(void)strlcpy(buf, val, len);

	if (strstr(val, "$REMOTE_") != NULL) {
		if (strstr(val, "$REMOTE_ADDR") != NULL) {
			if (print_host(&cre->ss, ibuf, sizeof(ibuf)) == NULL)
				return (NULL);
			if (expand_string(buf, len,
			    "$REMOTE_ADDR", ibuf) != 0)
				return (NULL);
		}
		if (strstr(val, "$REMOTE_PORT") != NULL) {
			snprintf(ibuf, sizeof(ibuf), "%u", ntohs(cre->port));
			if (expand_string(buf, len,
			    "$REMOTE_PORT", ibuf) != 0)
				return (NULL);
		}
	}
	if (strstr(val, "$SERVER_") != NULL) {
		if (strstr(val, "$SERVER_ADDR") != NULL) {
			if (print_host(&rlay->conf.ss,
			    ibuf, sizeof(ibuf)) == NULL)
				return (NULL);
			if (expand_string(buf, len,
			    "$SERVER_ADDR", ibuf) != 0)
				return (NULL);
		}
		if (strstr(val, "$SERVER_PORT") != NULL) {
			snprintf(ibuf, sizeof(ibuf), "%u",
			    ntohs(rlay->conf.port));
			if (expand_string(buf, len,
			    "$SERVER_PORT", ibuf) != 0)
				return (NULL);
		}
	}
	if (strstr(val, "$TIMEOUT") != NULL) {
		snprintf(ibuf, sizeof(ibuf), "%lu", rlay->conf.timeout.tv_sec);
		if (expand_string(buf, len, "$TIMEOUT", ibuf) != 0)
			return (NULL);
	}

	return (buf);
}

int
relay_handle_http(struct ctl_relay_event *cre, struct protonode *proot,
    struct protonode *pn, struct protonode *pk, int header)
{
	struct session		*con = (struct session *)cre->con;
	char			 buf[READ_BUF_SIZE], *ptr;
	int			 ret = PN_DROP, mark = 0;
	struct protonode	*next;

	/* Check if this action depends on a marked session */
	if (pn->mark != 0)
		mark = pn->mark == con->mark ? 1 : -1;

	switch (pn->action) {
	case NODE_ACTION_EXPECT:
	case NODE_ACTION_FILTER:
	case NODE_ACTION_MARK:
		break;
	default:
		if (mark == -1)
			return (PN_PASS);
		break;
	}

	switch (pn->action) {
	case NODE_ACTION_APPEND:
		if (!header)
			return (PN_PASS);
		ptr = pn->value;
		if ((pn->flags & PNFLAG_MACRO) &&
		    (ptr = relay_expand_http(cre, pn->value,
		    buf, sizeof(buf))) == NULL)
			break;
		if (relay_bufferevent_print(cre->dst, pn->key) == -1 ||
		    relay_bufferevent_print(cre->dst, ": ") == -1 ||
		    relay_bufferevent_print(cre->dst, pk->value) == -1 ||
		    relay_bufferevent_print(cre->dst, ", ") == -1 ||
		    relay_bufferevent_print(cre->dst, ptr) == -1 ||
		    relay_bufferevent_print(cre->dst, "\r\n") == -1)
			goto fail;
		cre->nodes[pn->id] = 1;
		DPRINTF("relay_handle_http: append '%s: %s, %s'",
		    pk->key, pk->value, ptr);
		break;
	case NODE_ACTION_CHANGE:
	case NODE_ACTION_REMOVE:
		if (!header)
			return (PN_PASS);
		DPRINTF("relay_handle_http: change/remove '%s: %s'",
		    pk->key, pk->value);
		break;
	case NODE_ACTION_EXPECT:
		/*
		 * A client may specify the header line for multiple times
		 * trying to circumvent the filter.
		 */
		if (cre->nodes[proot->id] > 1) {
			relay_close_http(con, 400, "repeated header line", 0);
			return (PN_FAIL);
		}
		/* FALLTHROUGH */
	case NODE_ACTION_FILTER:
		DPRINTF("relay_handle_http: %s '%s: %s'",
		    (pn->action == NODE_ACTION_EXPECT) ? "expect" : "filter",
		    pn->key, pn->value);

		/* Do not drop the entity */
		ret = PN_PASS;

		if (mark != -1 &&
		    fnmatch(pn->value, pk->value, FNM_CASEFOLD) == 0) {
			cre->nodes[proot->id] = 1;

			/* Fail instantly */
			if (pn->action == NODE_ACTION_FILTER) {
				relay_close_http(con, 403,
				    "rejecting request", pn->label);
				return (PN_FAIL);
			}
		}
		next = SIMPLEQ_NEXT(pn, entry);
		if (next == NULL || next->action != pn->action)
			cre->nodes[proot->id]++;
		break;
	case NODE_ACTION_HASH:
		DPRINTF("relay_handle_http: hash '%s: %s'",
		    pn->key, pk->value);
		con->outkey = hash32_str(pk->value, con->outkey);
		ret = PN_PASS;
		break;
	case NODE_ACTION_LOG:
		DPRINTF("relay_handle_http: log '%s: %s'",
		    pn->key, pk->value);
		ret = PN_PASS;
		break;
	case NODE_ACTION_MARK:
		DPRINTF("relay_handle_http: mark '%s: %s'",
		    pn->key, pk->value);
		if (fnmatch(pn->value, pk->value, FNM_CASEFOLD) == 0)
			con->mark = pn->mark;
		ret = PN_PASS;
		break;
	case NODE_ACTION_NONE:
		return (PN_PASS);
	}
	if (mark != -1 && pn->flags & PNFLAG_LOG) {
		bzero(buf, sizeof(buf));
		if (snprintf(buf, sizeof(buf), " [%s: %s]",
		    pk->key, pk->value) == -1 ||
		    evbuffer_add(con->log, buf, strlen(buf)) == -1)
			goto fail;
	}

	return (ret);
 fail:
	relay_close_http(con, 500, strerror(errno), 0);
	return (PN_FAIL);
}

void
relay_read_httpcontent(struct bufferevent *bev, void *arg)
{
	struct ctl_relay_event	*cre = (struct ctl_relay_event *)arg;
	struct session		*con = (struct session *)cre->con;
	struct evbuffer		*src = EVBUFFER_INPUT(bev);
	size_t			 size;

	if (gettimeofday(&con->tv_last, NULL))
		goto done;
	size = EVBUFFER_LENGTH(src);
	DPRINTF("relay_read_httpcontent: size %d, to read %d",
	    size, cre->toread);
	if (!size)
		return;
	if (relay_bufferevent_write_buffer(cre->dst, src) == -1)
		goto fail;
	if (size >= cre->toread)
		bev->readcb = relay_read_http;
	cre->toread -= size;
	DPRINTF("relay_read_httpcontent: done, size %d, to read %d",
	    size, cre->toread);
	if (con->done)
		goto done;
	if (EVBUFFER_LENGTH(src) && bev->readcb != relay_read_httpcontent)
		bev->readcb(bev, arg);
	bufferevent_enable(bev, EV_READ);
	return;
 done:
	relay_close(con, "last http content read");
	return;
 fail:
	relay_close(con, strerror(errno));
}

void
relay_read_httpchunks(struct bufferevent *bev, void *arg)
{
	struct ctl_relay_event	*cre = (struct ctl_relay_event *)arg;
	struct session		*con = (struct session *)cre->con;
	struct evbuffer		*src = EVBUFFER_INPUT(bev);
	char			*line, *ep;
	long			 lval;
	size_t			 size;

	if (gettimeofday(&con->tv_last, NULL))
		goto done;
	size = EVBUFFER_LENGTH(src);
	DPRINTF("relay_read_httpchunks: size %d, to read %d",
	    size, cre->toread);
	if (!size)
		return;

	if (!cre->toread) {
		line = evbuffer_readline(src);
		if (line == NULL) {
			relay_close(con, "invalid chunk");
			return;
		}

		/* Read prepended chunk size in hex */
		errno = 0;
		lval = strtol(line, &ep, 16);
		if (line[0] == '\0' || *ep != '\0') {
			free(line);
			relay_close(con, "invalid chunk size");
			return;
		}
		if (errno == ERANGE &&
		    (lval == LONG_MAX || lval == LONG_MIN)) {
			free(line);
			relay_close(con, "chunk size out of range");
			return;
		}
		if (relay_bufferevent_print(cre->dst, line) == -1 ||
		    relay_bufferevent_print(cre->dst, "\r\n") == -1)
			goto fail;
		free(line);

		/* Last chunk is 0 bytes followed by an empty newline */
		if ((cre->toread = lval) == 0) {
			line = evbuffer_readline(src);
			if (line == NULL) {
				relay_close(con, "invalid chunk");
				return;
			}
			free(line);
			if (relay_bufferevent_print(cre->dst, "\r\n") == -1)
				goto fail;

			/* Switch to HTTP header mode */
			bev->readcb = relay_read_http;
		}
	} else {
		/* Read chunk data */
		if (size > cre->toread)
			size = cre->toread;
		if (relay_bufferevent_write_chunk(cre->dst, src, size) == -1)
			goto fail;
		cre->toread -= size;
		DPRINTF("relay_read_httpchunks: done, size %d, to read %d",
		    size, cre->toread);

		if (cre->toread == 0) {
			/* Chunk is terminated by an empty newline */
			line = evbuffer_readline(src);
			if (line == NULL || strlen(line)) {
				if (line != NULL)
					free(line);
				relay_close(con, "invalid chunk");
				return;
			}
			free(line);
			if (relay_bufferevent_print(cre->dst, "\r\n\r\n") == -1)
				goto fail;
		}
	}

	if (con->done)
		goto done;
	if (EVBUFFER_LENGTH(src) && bev->readcb != relay_read_httpchunks)
		bev->readcb(bev, arg);
	bufferevent_enable(bev, EV_READ);
	return;

 done:
	relay_close(con, "last http chunk read (done)");
	return;
 fail:
	relay_close(con, strerror(errno));
}

void
relay_read_http(struct bufferevent *bev, void *arg)
{
	struct ctl_relay_event	*cre = (struct ctl_relay_event *)arg;
	struct session		*con = (struct session *)cre->con;
	struct relay		*rlay = (struct relay *)con->relay;
	struct protocol		*proto = rlay->proto;
	struct evbuffer		*src = EVBUFFER_INPUT(bev);
	struct protonode	*pn, pk, *proot, *pnv = NULL, pkv;
	char			*line;
	int			 header = 0, ret, pass = 0;
	const char		*errstr;
	size_t			 size;

	if (gettimeofday(&con->tv_last, NULL))
		goto done;
	size = EVBUFFER_LENGTH(src);
	DPRINTF("relay_read_http: size %d, to read %d", size, cre->toread);
	if (!size)
		return;

	pk.type = NODE_TYPE_HEADER;

	while (!cre->done && (line = evbuffer_readline(src)) != NULL) {
		/*
		 * An empty line indicates the end of the request.
		 * libevent already stripped the \r\n for us.
		 */
		if (!strlen(line)) {
			cre->done = 1;
			free(line);
			break;
		}
		pk.key = line;

		/*
		 * The first line is the GET/POST/PUT/... request,
		 * subsequent lines are HTTP headers.
		 */
		if (++cre->line == 1) {
			pk.value = strchr(pk.key, ' ');
		} else
			pk.value = strchr(pk.key, ':');
		if (pk.value == NULL || strlen(pk.value) < 3) {
			if (cre->line == 1) {
				free(line);
				relay_close_http(con, 400, "malformed", 0);
				return;
			}

			DPRINTF("relay_read_http: request '%s'", line);
			/* Append line to the output buffer */
			if (relay_bufferevent_print(cre->dst, line) == -1 ||
			    relay_bufferevent_print(cre->dst, "\r\n") == -1) {
				free(line);
				goto fail;
			}
			free(line);
			continue;
		}
		if (*pk.value == ':') {
			*pk.value++ = '\0';
			pk.value++;
			header = 1;
		} else {
			*pk.value++ = '\0';
			header = 0;
		}

		DPRINTF("relay_read_http: header '%s: %s'", pk.key, pk.value);

		/*
		 * Identify and handle specific HTTP request methods
		 */
		if (cre->line == 1) {
			if (cre->dir == RELAY_DIR_RESPONSE) {
				cre->method = HTTP_METHOD_RESPONSE;
				goto lookup;
			} else if (strcmp("GET", pk.key) == 0)
				cre->method = HTTP_METHOD_GET;
			else if (strcmp("HEAD", pk.key) == 0)
				cre->method = HTTP_METHOD_HEAD;
			else if (strcmp("POST", pk.key) == 0)
				cre->method = HTTP_METHOD_POST;
			else if (strcmp("PUT", pk.key) == 0)
				cre->method = HTTP_METHOD_PUT;
			else if (strcmp("DELETE", pk.key) == 0)
				cre->method = HTTP_METHOD_DELETE;
			else if (strcmp("OPTIONS", pk.key) == 0)
				cre->method = HTTP_METHOD_OPTIONS;
			else if (strcmp("TRACE", pk.key) == 0)
				cre->method = HTTP_METHOD_TRACE;
			else if (strcmp("CONNECT", pk.key) == 0)
				cre->method = HTTP_METHOD_CONNECT;

			/*
			 * Decode the path and query
			 */
			cre->path = strdup(pk.value);
			if (cre->path == NULL) {
				free(line);
				goto fail;
			}
			cre->version = strchr(cre->path, ' ');
			if (cre->version != NULL)
				*cre->version++ = '\0';
			cre->args = strchr(cre->path, '?');
			if (cre->args != NULL)
				*cre->args++ = '\0';
#ifdef DEBUG
			char	 buf[BUFSIZ];
			if (snprintf(buf, sizeof(buf), " \"%s\"",
			    cre->path) == -1 ||
			    evbuffer_add(con->log, buf, strlen(buf)) == -1) {
				free(line);
				goto fail;
			}
#endif

			/*
			 * Lookup protocol handlers in the URL path
			 */
			if ((proto->flags & F_LOOKUP_PATH) == 0)
				goto lookup;

			pkv.key = cre->path;
			pkv.type = NODE_TYPE_PATH;
			pkv.value = cre->args == NULL ? "" : cre->args;

			DPRINTF("relay_read_http: "
			    "lookup path '%s: %s'", pkv.key, pkv.value);

			if ((proot = RB_FIND(proto_tree,
			    cre->tree, &pkv)) == NULL)
				goto lookup;

			PROTONODE_FOREACH(pnv, proot, entry) {
				ret = relay_handle_http(cre, proot,
				    pnv, &pkv, 0);
				if (ret == PN_FAIL)
					goto abort;
			}
		} else if ((cre->method == HTTP_METHOD_POST ||
		    cre->method == HTTP_METHOD_PUT ||
		    cre->method == HTTP_METHOD_RESPONSE) &&
		    strcasecmp("Content-Length", pk.key) == 0) {
			/*
			 * Need to read data from the client after the
			 * HTTP header.
			 * XXX What about non-standard clients not using
			 * the carriage return? And some browsers seem to
			 * include the line length in the content-length.
			 */
			cre->toread = strtonum(pk.value, 1, INT_MAX, &errstr);
			if (errstr) {
				relay_close_http(con, 500, errstr, 0);
				goto abort;
			}
		}
 lookup:
		if (strcasecmp("Transfer-Encoding", pk.key) == 0 &&
		    strcasecmp("chunked", pk.value) == 0)
			cre->chunked = 1;

		/* Match the HTTP header */
		if ((pn = RB_FIND(proto_tree, cre->tree, &pk)) == NULL)
			goto next;

		if (cre->dir == RELAY_DIR_RESPONSE)
			goto handle;

		if (pn->flags & PNFLAG_LOOKUP_URL) {
			/*
			 * Lookup the URL of type example.com/path?args.
			 * Either as a plain string or SHA1/MD5 digest.
			 */
			if ((pn->flags & PNFLAG_LOOKUP_DIGEST(0)) &&
			    relay_lookup_url(cre, pk.value,
			    DIGEST_NONE) == PN_FAIL)
				goto abort;
			if ((pn->flags & PNFLAG_LOOKUP_DIGEST(DIGEST_SHA1)) &&
			    relay_lookup_url(cre, pk.value,
			    DIGEST_SHA1) == PN_FAIL)
				goto abort;
			if ((pn->flags & PNFLAG_LOOKUP_DIGEST(DIGEST_MD5)) &&
			    relay_lookup_url(cre, pk.value,
			    DIGEST_MD5) == PN_FAIL)
				goto abort;
		} else if (pn->flags & PNFLAG_LOOKUP_QUERY) {
			/* Lookup the HTTP query arguments */
			if (relay_lookup_query(cre) == PN_FAIL)
				goto abort;
		} else if (pn->flags & PNFLAG_LOOKUP_COOKIE) {
			/* Lookup the HTTP cookie */
			if (relay_lookup_cookie(cre, pk.value) == PN_FAIL)
				goto abort;
		}

 handle:
		pass = 0;
		PROTONODE_FOREACH(pnv, pn, entry) {
			ret = relay_handle_http(cre, pn, pnv, &pk, header);
			if (ret == PN_PASS)
				pass = 1;
			else if (ret == PN_FAIL)
				goto abort;
		}

		if (pass) {
 next:
			if (relay_bufferevent_print(cre->dst, pk.key) == -1 ||
			    relay_bufferevent_print(cre->dst,
			    header ? ": " : " ") == -1 ||
			    relay_bufferevent_print(cre->dst, pk.value) == -1 ||
			    relay_bufferevent_print(cre->dst, "\r\n") == -1) {
				free(line);
				goto fail;
			}
		}
		free(line);
	}
	if (cre->done) {
		RB_FOREACH(proot, proto_tree, cre->tree) {
			PROTONODE_FOREACH(pn, proot, entry)
				if (relay_resolve(cre, proot, pn) != 0)
					return;
		}

		switch (cre->method) {
		case HTTP_METHOD_CONNECT:
			/* Data stream */
			bev->readcb = relay_read;
			break;
		case HTTP_METHOD_POST:
		case HTTP_METHOD_PUT:
		case HTTP_METHOD_RESPONSE:
			/* HTTP request payload */
			if (cre->toread) {
				bev->readcb = relay_read_httpcontent;
				break;
			}
			/* FALLTHROUGH */
		default:
			/* HTTP handler */
			bev->readcb = relay_read_http;
			break;
		}
		if (cre->chunked) {
			/* Chunked transfer encoding */
			cre->toread = 0;
			bev->readcb = relay_read_httpchunks;
		}

		/* Write empty newline and switch to relay mode */
		if (relay_bufferevent_print(cre->dst, "\r\n") == -1)
			goto fail;
		cre->line = 0;
		cre->method = 0;
		cre->done = 0;
		cre->chunked = 0;

		if (cre->dir == RELAY_DIR_REQUEST &&
		    proto->lateconnect && cre->dst->bev == NULL &&
		    relay_connect(con) == -1) {
			relay_close_http(con, 502, "session failed", 0);
			return;
		}
	}
	if (con->done)
		goto done;
	if (EVBUFFER_LENGTH(src) && bev->readcb != relay_read_http)
		bev->readcb(bev, arg);
	bufferevent_enable(bev, EV_READ);
	return;
 done:
	relay_close(con, "last http read (done)");
	return;
 fail:
	relay_close_http(con, 500, strerror(errno), 0);
	return;
 abort:
	free(line);
}

static int
_relay_lookup_url(struct ctl_relay_event *cre, char *host, char *path,
    char *query, enum digest_type type)
{
	struct session		*con = (struct session *)cre->con;
	struct protonode	*proot, *pnv, pkv;
	char			*val, *md = NULL;
	int			 ret = PN_FAIL;

	if (asprintf(&val, "%s%s%s%s",
	    host, path,
	    query == NULL ? "" : "?",
	    query == NULL ? "" : query) == -1) {
		relay_close_http(con, 500, "failed to allocate URL", 0);
		return (PN_FAIL);
	}

	DPRINTF("_relay_lookup_url: %s", val);

	switch (type) {
	case DIGEST_SHA1:
	case DIGEST_MD5:
		if ((md = digeststr(type, val, strlen(val), NULL)) == NULL) {
			relay_close_http(con, 500,
			    "failed to allocate digest", 0);
			goto fail;
		}
		pkv.key = md;
		break;
	case DIGEST_NONE:
		pkv.key = val;
		break;
	}
	pkv.type = NODE_TYPE_URL;
	pkv.value = "";

	if ((proot = RB_FIND(proto_tree, cre->tree, &pkv)) == NULL)
		goto done;

	PROTONODE_FOREACH(pnv, proot, entry) {
		ret = relay_handle_http(cre, proot, pnv, &pkv, 0);
		if (ret == PN_FAIL)
			goto fail;
	}

 done:
	ret = PN_PASS;
 fail:
	if (md != NULL)
		free(md);
	free(val);
	return (ret);
}

int
relay_lookup_url(struct ctl_relay_event *cre, const char *str,
    enum digest_type type)
{
	struct session	*con = (struct session *)cre->con;
	int		 i, j, dots;
	char		*hi[RELAY_MAXLOOKUPLEVELS], *p, *pp, *c, ch;
	char		 ph[MAXHOSTNAMELEN];
	int		 ret;

	if (cre->path == NULL)
		return (PN_PASS);

	/*
	 * This is an URL lookup algorithm inspired by
	 * http://code.google.com/apis/safebrowsing/
	 *     developers_guide.html#PerformingLookups
	 */

	DPRINTF("relay_lookup_url: host: '%s', path: '%s', query: '%s'",
	    str, cre->path, cre->args == NULL ? "" : cre->args);

	if (canonicalize_host(str, ph, sizeof(ph)) == NULL) {
		relay_close_http(con, 400, "invalid host name", 0);
		return (PN_FAIL);
	}

	bzero(hi, sizeof(hi));
	for (dots = -1, i = strlen(ph) - 1; i > 0; i--) {
		if (ph[i] == '.' && ++dots)
			hi[dots - 1] = &ph[i + 1];
		if (dots > (RELAY_MAXLOOKUPLEVELS - 2))
			break;
	}
	if (dots == -1)
		dots = 0;
	hi[dots] = ph;

	if ((pp = strdup(cre->path)) == NULL) {
		relay_close_http(con, 500, "failed to allocate path", 0);
		return (PN_FAIL);
	}
	for (i = (RELAY_MAXLOOKUPLEVELS - 1); i >= 0; i--) {
		if (hi[i] == NULL)
			continue;

		/* 1. complete path with query */
		if (cre->args != NULL)
			if ((ret = _relay_lookup_url(cre, hi[i],
			    pp, cre->args, type)) != PN_PASS)
				goto done;

		/* 2. complete path without query */
		if ((ret = _relay_lookup_url(cre, hi[i],
		    pp, NULL, type)) != PN_PASS)
			goto done;

		/* 3. traverse path */
		for (j = 0, p = strchr(pp, '/');
		    p != NULL; p = strchr(p, '/'), j++) {
			if (j > (RELAY_MAXLOOKUPLEVELS - 2) || ++p == '\0')
				break;
			c = &pp[p - pp];
			ch = *c;
			*c = '\0';
			if ((ret = _relay_lookup_url(cre, hi[i],
			    pp, NULL, type)) != PN_PASS)
				goto done;
			*c = ch;
		}
	}

	ret = PN_PASS;
 done:
	free(pp);
	return (ret);
}

int
relay_lookup_query(struct ctl_relay_event *cre)
{
	struct session		*con = (struct session *)cre->con;
	struct protonode	*proot, *pnv, pkv;
	char			*val, *ptr;
	int			 ret;

	if (cre->path == NULL || cre->args == NULL || strlen(cre->args) < 2)
		return (PN_PASS);
	if ((val = strdup(cre->args)) == NULL) {
		relay_close_http(con, 500, "failed to allocate query", 0);
		return (PN_FAIL);
	}

	ptr = val;
	while (ptr != NULL && strlen(ptr)) {
		pkv.key = ptr;
		pkv.type = NODE_TYPE_QUERY;
		if ((ptr = strchr(ptr, '&')) != NULL)
			*ptr++ = '\0';
		if ((pkv.value =
		    strchr(pkv.key, '=')) == NULL ||
		    strlen(pkv.value) < 1)
			continue;
		*pkv.value++ = '\0';

		if ((proot = RB_FIND(proto_tree, cre->tree, &pkv)) == NULL)
			continue;
		PROTONODE_FOREACH(pnv, proot, entry) {
			ret = relay_handle_http(cre, proot,
			    pnv, &pkv, 0);
			if (ret == PN_FAIL)
				goto done;
		}
	}

	ret = PN_PASS;
 done:
	free(val);
	return (ret);
}

int
relay_lookup_cookie(struct ctl_relay_event *cre, const char *str)
{
	struct session		*con = (struct session *)cre->con;
	struct protonode	*proot, *pnv, pkv;
	char			*val, *ptr;
	int			 ret;

	if ((val = strdup(str)) == NULL) {
		relay_close_http(con, 500, "failed to allocate cookie", 0);
		return (PN_FAIL);
	}

	for (ptr = val; ptr != NULL && strlen(ptr);) {
		if (*ptr == ' ')
			*ptr++ = '\0';
		pkv.key = ptr;
		pkv.type = NODE_TYPE_COOKIE;
		if ((ptr = strchr(ptr, ';')) != NULL)
			*ptr++ = '\0';
		/*
		 * XXX We do not handle attributes
		 * ($Path, $Domain, or $Port)
		 */
		if (*pkv.key == '$')
			continue;

		if ((pkv.value =
		    strchr(pkv.key, '=')) == NULL ||
		    strlen(pkv.value) < 1)
			continue;
		*pkv.value++ = '\0';
		if (*pkv.value == '"')
			*pkv.value++ = '\0';
		if (pkv.value[strlen(pkv.value) - 1] == '"')
			pkv.value[strlen(pkv.value) - 1] = '\0';
		if ((proot = RB_FIND(proto_tree, cre->tree, &pkv)) == NULL)
			continue;
		PROTONODE_FOREACH(pnv, proot, entry) {
			ret = relay_handle_http(cre, proot, pnv, &pkv, 0);
			if (ret == PN_FAIL)
				goto done;
		}
	}

	ret = PN_PASS;
 done:
	free(val);
	return (ret);
}

void
relay_close_http(struct session *con, u_int code, const char *msg,
    u_int16_t labelid)
{
	struct relay		*rlay = (struct relay *)con->relay;
	struct bufferevent	*bev = con->in.bev;
	const char		*httperr = print_httperror(code), *text = "";
	char			*httpmsg;
	time_t			 t;
	struct tm		*lt;
	char			 tmbuf[32], hbuf[128];
	const char		*style, *label = NULL;

	/* In some cases this function may be called from generic places */
	if (rlay->proto->type != RELAY_PROTO_HTTP ||
	    (rlay->proto->flags & F_RETURN) == 0) {
		relay_close(con, msg);
		return;
	}

	if (bev == NULL)
		goto done;

	/* Some system information */
	if (print_host(&rlay->conf.ss, hbuf, sizeof(hbuf)) == NULL)
		goto done;

	/* RFC 2616 "tolerates" asctime() */
	time(&t);
	lt = localtime(&t);
	tmbuf[0] = '\0';
	if (asctime_r(lt, tmbuf) != NULL)
		tmbuf[strlen(tmbuf) - 1] = '\0';	/* skip final '\n' */

	/* Do not send details of the Internal Server Error */
	if (code != 500)
		text = msg;
	if (labelid != 0)
		label = pn_id2name(labelid);

	/* A CSS stylesheet allows minimal customization by the user */
	if ((style = rlay->proto->style) == NULL)
		style = "body { background-color: #a00000; color: white; }";

	/* Generate simple HTTP+HTML error document */
	if (asprintf(&httpmsg,
	    "HTTP/1.x %03d %s\r\n"
	    "Date: %s\r\n"
	    "Server: %s\r\n"
	    "Connection: close\r\n"
	    "Content-Type: text/html\r\n"
	    "\r\n"
	    "<!DOCTYPE HTML PUBLIC "
	    "\"-//W3C//DTD HTML 4.01 Transitional//EN\">\n"
	    "<html>\n"
	    "<head>\n"
	    "<title>%03d %s</title>\n"
	    "<style type=\"text/css\"><!--\n%s\n--></style>\n"
	    "</head>\n"
	    "<body>\n"
	    "<h1>%s</h1>\n"
	    "<div id='m'>%s</div>\n"
	    "<div id='l'>%s</div>\n"
	    "<hr><address>%s at %s port %d</address>\n"
	    "</body>\n"
	    "</html>\n",
	    code, httperr, tmbuf, HOSTSTATED_SERVERNAME,
	    code, httperr, style, httperr, text,
	    label == NULL ? "" : label,
	    HOSTSTATED_SERVERNAME, hbuf, ntohs(rlay->conf.port)) == -1)
		goto done;

	/* Dump the message without checking for success */
	relay_dump(&con->in, httpmsg, strlen(httpmsg));
	free(httpmsg);

 done:
	if (asprintf(&httpmsg, "%s (%03d %s)", msg, code, httperr) == -1)
		relay_close(con, msg);
	else {
		relay_close(con, httpmsg);
		free(httpmsg);
	}
}

void
relay_error(struct bufferevent *bev, short error, void *arg)
{
	struct ctl_relay_event *cre = (struct ctl_relay_event *)arg;
	struct session *con = (struct session *)cre->con;
	struct evbuffer *dst;

	if (error & EVBUFFER_TIMEOUT) {
		relay_close(con, "buffer event timeout");
		return;
	}
	if (error & (EVBUFFER_READ|EVBUFFER_WRITE|EVBUFFER_EOF)) {
		bufferevent_disable(bev, EV_READ|EV_WRITE);

		con->done = 1;
		if (cre->dst->bev != NULL) {
			dst = EVBUFFER_OUTPUT(cre->dst->bev);
			if (EVBUFFER_LENGTH(dst))
				return;
		}

		relay_close(con, "done");
		return;
	}
	relay_close(con, "buffer event error");
}

void
relay_accept(int fd, short sig, void *arg)
{
	struct relay *rlay = (struct relay *)arg;
	struct protocol *proto = rlay->proto;
	struct session *con = NULL;
	struct ctl_natlook *cnl = NULL;
	socklen_t slen;
	struct timeval tv;
	struct sockaddr_storage ss;
	int s = -1;

	slen = sizeof(ss);
	if ((s = accept(fd, (struct sockaddr *)&ss, (socklen_t *)&slen)) == -1)
		return;

	if (relay_sessions >= RELAY_MAX_SESSIONS ||
	    rlay->conf.flags & F_DISABLE)
		goto err;

	if ((con = (struct session *)
	    calloc(1, sizeof(struct session))) == NULL)
		goto err;

	con->in.s = s;
	con->in.ssl = NULL;
	con->out.s = -1;
	con->out.ssl = NULL;
	con->in.dst = &con->out;
	con->out.dst = &con->in;
	con->in.con = con;
	con->out.con = con;
	con->relay = rlay;
	con->id = ++relay_conid;
	con->relayid = rlay->conf.id;
	con->outkey = rlay->dstkey;
	con->in.tree = &proto->request_tree;
	con->out.tree = &proto->response_tree;
	con->in.dir = RELAY_DIR_REQUEST;
	con->out.dir = RELAY_DIR_RESPONSE;
	con->retry = rlay->conf.dstretry;
	if (gettimeofday(&con->tv_start, NULL))
		goto err;
	bcopy(&con->tv_start, &con->tv_last, sizeof(con->tv_last));
	bcopy(&ss, &con->in.ss, sizeof(con->in.ss));
	con->out.port = rlay->conf.dstport;
	switch (ss.ss_family) {
	case AF_INET:
		con->in.port = ((struct sockaddr_in *)&ss)->sin_port;
		break;
	case AF_INET6:
		con->in.port = ((struct sockaddr_in6 *)&ss)->sin6_port;
		break;
	}

	relay_sessions++;
	SPLAY_INSERT(session_tree, &rlay->sessions, con);

	/* Increment the per-relay session counter */
	rlay->stats[proc_id].last++;

	/* Pre-allocate output buffer */
	con->out.output = evbuffer_new();
	if (con->out.output == NULL) {
		relay_close(con, "failed to allocate output buffer");
		return;
	}

	/* Pre-allocate log buffer */
	con->log = evbuffer_new();
	if (con->log == NULL) {
		relay_close(con, "failed to allocate log buffer");
		return;
	}

	if (rlay->conf.flags & F_NATLOOK) {
		if ((cnl = (struct ctl_natlook *)
		    calloc(1, sizeof(struct ctl_natlook))) == NULL) {
			relay_close(con, "failed to allocate nat lookup");
			return;
		}
	}

	if (rlay->conf.flags & F_NATLOOK && cnl != NULL) {
		con->cnl = cnl;;
		bzero(cnl, sizeof(*cnl));
		cnl->in = -1;
		cnl->id = con->id;
		cnl->proc = proc_id;
		bcopy(&con->in.ss, &cnl->src, sizeof(cnl->src));
		bcopy(&rlay->conf.ss, &cnl->dst, sizeof(cnl->dst));
		imsg_compose(ibuf_pfe, IMSG_NATLOOK, 0, 0, -1, cnl,
		    sizeof(*cnl));

		/* Schedule timeout */
		evtimer_set(&con->ev, relay_natlook, con);
		bcopy(&rlay->conf.timeout, &tv, sizeof(tv));
		evtimer_add(&con->ev, &tv);
		return;
	}

	relay_session(con);
	return;
 err:
	if (s != -1) {
		close(s);
		if (con != NULL)
			free(con);
	}
}

u_int32_t
relay_hash_addr(struct sockaddr_storage *ss, u_int32_t p)
{
	struct sockaddr_in	*sin4;
	struct sockaddr_in6	*sin6;

	if (ss->ss_family == AF_INET) {
		sin4 = (struct sockaddr_in *)ss;
		p = hash32_buf(&sin4->sin_addr,
		    sizeof(struct in_addr), p);
	} else {
		sin6 = (struct sockaddr_in6 *)ss;
		p = hash32_buf(&sin6->sin6_addr,
		    sizeof(struct in6_addr), p);
	}

	return (p);
}

int
relay_from_table(struct session *con)
{
	struct relay		*rlay = (struct relay *)con->relay;
	struct host		*host;
	struct table		*table = rlay->dsttable;
	u_int32_t		 p = con->outkey;
	int			 idx = 0;

	if (rlay->conf.dstcheck && !table->up) {
		log_debug("relay_from_table: no active hosts");
		return (-1);
	}

	switch (rlay->conf.dstmode) {
	case RELAY_DSTMODE_ROUNDROBIN:
		if ((int)rlay->dstkey >= rlay->dstnhosts)
			rlay->dstkey = 0;
		idx = (int)rlay->dstkey;
		break;
	case RELAY_DSTMODE_LOADBALANCE:
		p = relay_hash_addr(&con->in.ss, p);
		/* FALLTHROUGH */
	case RELAY_DSTMODE_HASH:
		p = relay_hash_addr(&rlay->conf.ss, p);
		p = hash32_buf(&rlay->conf.port, sizeof(rlay->conf.port), p);
		if ((idx = p % rlay->dstnhosts) >= RELAY_MAXHOSTS)
			return (-1);
	}
	host = rlay->dsthost[idx];
	DPRINTF("relay_from_table: host %s, p 0x%08x, idx %d",
	    host->conf.name, p, idx);
	while (host != NULL) {
		DPRINTF("relay_from_table: host %s", host->conf.name);
		if (!rlay->conf.dstcheck || host->up == HOST_UP)
			goto found;
		host = TAILQ_NEXT(host, entry);
	}
	TAILQ_FOREACH(host, &rlay->dsttable->hosts, entry) {
		DPRINTF("relay_from_table: next host %s", host->conf.name);
		if (!rlay->conf.dstcheck || host->up == HOST_UP)
			goto found;
	}

	/* Should not happen */
	fatalx("relay_from_table: no active hosts, desynchronized");

 found:
	if (rlay->conf.dstmode == RELAY_DSTMODE_ROUNDROBIN)
		rlay->dstkey = host->idx + 1;
	con->retry = host->conf.retry;
	con->out.port = table->conf.port;
	bcopy(&host->conf.ss, &con->out.ss, sizeof(con->out.ss));

	return (0);
}

void
relay_natlook(int fd, short event, void *arg)
{
	struct session		*con = (struct session *)arg;
	struct relay		*rlay = (struct relay *)con->relay;
	struct ctl_natlook	*cnl = con->cnl;

	if (cnl == NULL)
		fatalx("invalid NAT lookup");

	if (con->out.ss.ss_family == AF_UNSPEC && cnl->in == -1 &&
	    rlay->conf.dstss.ss_family == AF_UNSPEC && rlay->dsttable == NULL) {
		relay_close(con, "session NAT lookup failed");
		return;
	}
	if (cnl->in != -1) {
		bcopy(&cnl->rdst, &con->out.ss, sizeof(con->out.ss));
		con->out.port = cnl->rdport;
	}
	free(con->cnl);
	con->cnl = NULL;

	relay_session(con);
}

void
relay_session(struct session *con)
{
	struct relay		*rlay = (struct relay *)con->relay;
	struct ctl_relay_event	*in = &con->in, *out = &con->out;

	if (bcmp(&rlay->conf.ss, &out->ss, sizeof(out->ss)) == 0 &&
	    out->port == rlay->conf.port) {
		log_debug("relay_session: session %d: looping",
		    con->id);
		relay_close(con, "session aborted");
		return;
	}

	if (rlay->conf.flags & F_UDP) {
		/*
		 * Call the UDP protocol-specific handler
		 */
		if (rlay->proto->request == NULL)
			fatalx("invalide UDP session");
		if ((*rlay->proto->request)(con) == -1)
			relay_close(con, "session failed");
		return;
	}

	if ((rlay->conf.flags & F_SSL) && (in->ssl == NULL)) {
		relay_ssl_transaction(con);
		return;
	}

	if (!rlay->proto->lateconnect && relay_connect(con) == -1) {
		relay_close(con, "session failed");
		return;
	}

	relay_input(con);
}

int
relay_connect(struct session *con)
{
	struct relay	*rlay = (struct relay *)con->relay;

	if (gettimeofday(&con->tv_start, NULL))
		return (-1);

	if (rlay->dsttable != NULL) {
		if (relay_from_table(con) != 0)
			return (-1);
	} else if (con->out.ss.ss_family == AF_UNSPEC) {
		bcopy(&rlay->conf.dstss, &con->out.ss, sizeof(con->out.ss));
		con->out.port = rlay->conf.dstport;
	}

 retry:
	if ((con->out.s = relay_socket_connect(&con->out.ss, con->out.port,
	    rlay->proto)) == -1) {
		if (con->retry) {
			con->retry--;
			log_debug("relay_connect: session %d: "
			    "forward failed: %s, %s",
			    con->id, strerror(errno),
			    con->retry ? "next retry" : "last retry");
			goto retry;
		}
		log_debug("relay_connect: session %d: forward failed: %s",
		    con->id, strerror(errno));
		return (-1);
	}

	if (errno == EINPROGRESS)
		event_again(&con->ev, con->out.s, EV_WRITE|EV_TIMEOUT,
		    relay_connected, &con->tv_start, &env->timeout, con);
	else
		relay_connected(con->out.s, EV_WRITE, con);

	return (0);
}

void
relay_close(struct session *con, const char *msg)
{
	struct relay	*rlay = (struct relay *)con->relay;
	char		 ibuf[128], obuf[128], *ptr = NULL;

	SPLAY_REMOVE(session_tree, &rlay->sessions, con);

	event_del(&con->ev);
	if (con->in.bev != NULL)
		bufferevent_disable(con->in.bev, EV_READ|EV_WRITE);
	if (con->out.bev != NULL)
		bufferevent_disable(con->out.bev, EV_READ|EV_WRITE);

	if (env->opts & HOSTSTATED_OPT_LOGUPDATE) {
		bzero(&ibuf, sizeof(ibuf));
		bzero(&obuf, sizeof(obuf));
		(void)print_host(&con->in.ss, ibuf, sizeof(ibuf));
		(void)print_host(&con->out.ss, obuf, sizeof(obuf));
		if (EVBUFFER_LENGTH(con->log) &&
		    evbuffer_add_printf(con->log, "\r\n") != -1)
			ptr = evbuffer_readline(con->log);
		log_info("relay %s, session %d (%d active), %d, %s -> %s:%d, "
		    "%s%s%s", rlay->conf.name, con->id, relay_sessions,
		    con->mark, ibuf, obuf, ntohs(con->out.port), msg,
		    ptr == NULL ? "" : ",", ptr == NULL ? "" : ptr);
		if (ptr != NULL)
			free(ptr);
	}

	if (con->in.bev != NULL)
		bufferevent_free(con->in.bev);
	else if (con->in.output != NULL)
		evbuffer_free(con->in.output);
	if (con->in.ssl != NULL) {
		/* XXX handle non-blocking shutdown */
		if (SSL_shutdown(con->in.ssl) == 0)
			SSL_shutdown(con->in.ssl);
		SSL_free(con->in.ssl);
	}
	if (con->in.s != -1)
		close(con->in.s);
	if (con->in.path != NULL)
		free(con->in.path);
	if (con->in.buf != NULL)
		free(con->in.buf);
	if (con->in.nodes != NULL)
		free(con->in.nodes);

	if (con->out.bev != NULL)
		bufferevent_free(con->out.bev);
	else if (con->out.output != NULL)
		evbuffer_free(con->out.output);
	if (con->out.s != -1)
		close(con->out.s);
	if (con->out.path != NULL)
		free(con->out.path);
	if (con->out.buf != NULL)
		free(con->out.buf);
	if (con->out.nodes != NULL)
		free(con->out.nodes);

	if (con->log != NULL)
		evbuffer_free(con->log);

	if (con->cnl != NULL) {
#if 0
		imsg_compose(ibuf_pfe, IMSG_KILLSTATES, 0, 0, -1,
		    cnl, sizeof(*cnl));
#endif
		free(con->cnl);
	}

	free(con);
	relay_sessions--;
}

void
relay_dispatch_pfe(int fd, short event, void *ptr)
{
	struct imsgbuf		*ibuf;
	struct imsg		 imsg;
	ssize_t			 n;
	struct relay		*rlay;
	struct session		*con;
	struct ctl_natlook	 cnl;
	struct timeval		 tv;
	struct host		*host;
	struct table		*table;
	struct ctl_status	 st;
	objid_t			 id;

	ibuf = ptr;
	switch (event) {
	case EV_READ:
		if ((n = imsg_read(ibuf)) == -1)
			fatal("relay_dispatch_pfe: imsg_read_error");
		if (n == 0) {
			/* this pipe is dead, so remove the event handler */
			event_del(&ibuf->ev);
			event_loopexit(NULL);
			return;
		}
		break;
	case EV_WRITE:
		if (msgbuf_write(&ibuf->w) == -1)
			fatal("relay_dispatch_pfe: msgbuf_write");
		imsg_event_add(ibuf);
		return;
	default:
		fatalx("relay_dispatch_pfe: unknown event");
	}

	for (;;) {
		if ((n = imsg_get(ibuf, &imsg)) == -1)
			fatal("relay_dispatch_pfe: imsg_read error");
		if (n == 0)
			break;

		switch (imsg.hdr.type) {
		case IMSG_HOST_DISABLE:
			memcpy(&id, imsg.data, sizeof(id));
			if ((host = host_find(env, id)) == NULL)
				fatalx("relay_dispatch_pfe: desynchronized");
			if ((table = table_find(env, host->conf.tableid)) ==
			    NULL)
				fatalx("relay_dispatch_pfe: invalid table id");
			if (host->up == HOST_UP)
				table->up--;
			host->flags |= F_DISABLE;
			host->up = HOST_UNKNOWN;
			break;
		case IMSG_HOST_ENABLE:
			memcpy(&id, imsg.data, sizeof(id));
			if ((host = host_find(env, id)) == NULL)
				fatalx("relay_dispatch_pfe: desynchronized");
			host->flags &= ~(F_DISABLE);
			host->up = HOST_UNKNOWN;
			break;
		case IMSG_HOST_STATUS:
			if (imsg.hdr.len - IMSG_HEADER_SIZE != sizeof(st))
				fatalx("relay_dispatch_pfe: invalid request");
			memcpy(&st, imsg.data, sizeof(st));
			if ((host = host_find(env, st.id)) == NULL)
				fatalx("relay_dispatch_pfe: invalid host id");
			if (host->flags & F_DISABLE)
				break;
			if (host->up == st.up) {
				log_debug("relay_dispatch_pfe: host %d => %d",
				    host->conf.id, host->up);
				fatalx("relay_dispatch_pfe: desynchronized");
			}

			if ((table = table_find(env, host->conf.tableid))
			    == NULL)
				fatalx("relay_dispatch_pfe: invalid table id");

			DPRINTF("relay_dispatch_pfe: [%d] state %d for "
			    "host %u %s", proc_id, st.up,
			    host->conf.id, host->conf.name);

			if ((st.up == HOST_UNKNOWN && host->up == HOST_DOWN) ||
			    (st.up == HOST_DOWN && host->up == HOST_UNKNOWN)) {
				host->up = st.up;
				break;
			}
			if (st.up == HOST_UP)
				table->up++;
			else
				table->up--;
			host->up = st.up;
			break;
		case IMSG_NATLOOK:
			bcopy(imsg.data, &cnl, sizeof(cnl));
			if ((con = session_find(env, cnl.id)) == NULL ||
			    con->cnl == NULL) {
				log_debug("relay_dispatch_pfe: "
				    "session expired");
				break;
			}
			bcopy(&cnl, con->cnl, sizeof(*con->cnl));
			evtimer_del(&con->ev);
			evtimer_set(&con->ev, relay_natlook, con);
			bzero(&tv, sizeof(tv));
			evtimer_add(&con->ev, &tv);
			break;
		case IMSG_CTL_SESSION:
			TAILQ_FOREACH(rlay, env->relays, entry)
				SPLAY_FOREACH(con, session_tree,
				    &rlay->sessions)
					imsg_compose(ibuf, IMSG_CTL_SESSION,
					    0, 0, -1, con, sizeof(*con));
			imsg_compose(ibuf, IMSG_CTL_END, 0, 0, -1, NULL, 0);
			break;
		default:
			log_debug("relay_dispatch_msg: unexpected imsg %d",
			    imsg.hdr.type);
			break;
		}
		imsg_free(&imsg);
	}
	imsg_event_add(ibuf);
}

void
relay_dispatch_parent(int fd, short event, void * ptr)
{
	struct imsgbuf	*ibuf;
	struct imsg	 imsg;
	ssize_t		 n;

	ibuf = ptr;
	switch (event) {
	case EV_READ:
		if ((n = imsg_read(ibuf)) == -1)
			fatal("relay_dispatch_parent: imsg_read error");
		if (n == 0) {
			/* this pipe is dead, so remove the event handler */
			event_del(&ibuf->ev);
			event_loopexit(NULL);
			return;
		}
		break;
	case EV_WRITE:
		if (msgbuf_write(&ibuf->w) == -1)
			fatal("relay_dispatch_parent: msgbuf_write");
		imsg_event_add(ibuf);
		return;
	default:
		fatalx("relay_dispatch_parent: unknown event");
	}

	for (;;) {
		if ((n = imsg_get(ibuf, &imsg)) == -1)
			fatal("relay_dispatch_parent: imsg_read error");
		if (n == 0)
			break;

		switch (imsg.hdr.type) {
		default:
			log_debug("relay_dispatch_parent: unexpected imsg %d",
			    imsg.hdr.type);
			break;
		}
		imsg_free(&imsg);
	}
	imsg_event_add(ibuf);
}

SSL_CTX *
relay_ssl_ctx_create(struct relay *rlay)
{
	struct protocol *proto = rlay->proto;
	SSL_CTX *ctx;

	ctx = SSL_CTX_new(SSLv23_method());
	if (ctx == NULL)
		goto err;

	/* Modify session timeout and cache size*/
	SSL_CTX_set_timeout(ctx, rlay->conf.timeout.tv_sec);
	if (proto->cache < -1) {
		SSL_CTX_set_session_cache_mode(ctx, SSL_SESS_CACHE_OFF);
	} else if (proto->cache >= -1) {
		SSL_CTX_set_session_cache_mode(ctx, SSL_SESS_CACHE_SERVER);
		if (proto->cache >= 0)
			SSL_CTX_sess_set_cache_size(ctx, proto->cache);
	}

	/* Enable all workarounds and set SSL options */
	SSL_CTX_set_options(ctx, SSL_OP_ALL);
	SSL_CTX_set_options(ctx,
	    SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION);

	/* Set the allowed SSL protocols */
	if ((proto->sslflags & SSLFLAG_SSLV2) == 0)
		SSL_CTX_set_options(ctx, SSL_OP_NO_SSLv2);
	if ((proto->sslflags & SSLFLAG_SSLV3) == 0)
		SSL_CTX_set_options(ctx, SSL_OP_NO_SSLv3);
	if ((proto->sslflags & SSLFLAG_TLSV1) == 0)
		SSL_CTX_set_options(ctx, SSL_OP_NO_TLSv1);

	if (!SSL_CTX_set_cipher_list(ctx, proto->sslciphers))
		goto err;

	log_debug("relay_ssl_ctx_create: loading certificate");
	if (!ssl_ctx_use_certificate_chain(ctx,
	    rlay->ssl_cert, rlay->ssl_cert_len))
		goto err;

	log_debug("relay_ssl_ctx_create: loading private key");
	if (!ssl_ctx_use_private_key(ctx, rlay->ssl_key, rlay->ssl_key_len))
		goto err;
	if (!SSL_CTX_check_private_key(ctx))
		goto err;

	/* Set session context to the local relay name */
	if (!SSL_CTX_set_session_id_context(ctx, rlay->conf.name,
	    strlen(rlay->conf.name)))
		goto err;

	return (ctx);

 err:
	if (ctx != NULL)
		SSL_CTX_free(ctx);
	ssl_error(rlay->conf.name, "relay_ssl_ctx_create");
	return (NULL);
}

void
relay_ssl_transaction(struct session *con)
{
	struct relay	*rlay = (struct relay *)con->relay;
	SSL		*ssl;

	ssl = SSL_new(rlay->ssl_ctx);
	if (ssl == NULL)
		goto err;

	if (!SSL_set_ssl_method(ssl, SSLv23_server_method()))
		goto err;
	if (!SSL_set_fd(ssl, con->in.s))
		goto err;
	SSL_set_accept_state(ssl);

	con->in.ssl = ssl;

	event_again(&con->ev, con->in.s, EV_TIMEOUT|EV_READ,
	    relay_ssl_accept, &con->tv_start, &env->timeout, con);
	return;

 err:
	if (ssl != NULL)
		SSL_free(ssl);
	ssl_error(rlay->conf.name, "relay_ssl_transaction");
}

void
relay_ssl_accept(int fd, short event, void *arg)
{
	struct session	*con = (struct session *)arg;
	struct relay	*rlay = (struct relay *)con->relay;
	int		 ret;
	int		 ssl_err;
	int		 retry_flag;

	if (event == EV_TIMEOUT) {
		relay_close(con, "SSL accept timeout");
		return;
	}

	retry_flag = ssl_err = 0;

	ret = SSL_accept(con->in.ssl);
	if (ret <= 0) {
		ssl_err = SSL_get_error(con->in.ssl, ret);

		switch (ssl_err) {
		case SSL_ERROR_WANT_READ:
			retry_flag = EV_READ;
			goto retry;
		case SSL_ERROR_WANT_WRITE:
			retry_flag = EV_WRITE;
			goto retry;
		case SSL_ERROR_ZERO_RETURN:
		case SSL_ERROR_SYSCALL:
			if (ret == 0) {
				relay_close(con, "closed");
				return;
			}
			/* FALLTHROUGH */
		default:
			ssl_error(rlay->conf.name, "relay_ssl_accept");
			relay_close(con, "SSL accept error");
			return;
		}
	}


#ifdef DEBUG
	log_info("relay %s, session %d established (%d active)",
	    rlay->conf.name, con->id, relay_sessions);
#else
	log_debug("relay %s, session %d established (%d active)",
	    rlay->conf.name, con->id, relay_sessions);
#endif
	relay_session(con);
	return;

retry:
	DPRINTF("relay_ssl_accept: session %d: scheduling on %s", con->id,
	    (retry_flag == EV_READ) ? "EV_READ" : "EV_WRITE");
	event_again(&con->ev, fd, EV_TIMEOUT|retry_flag, relay_ssl_accept,
	    &con->tv_start, &env->timeout, con);
}

void
relay_ssl_connected(struct ctl_relay_event *cre)
{
	/*
	 * Hack libevent - we overwrite the internal bufferevent I/O
	 * functions to handle the SSL abstraction.
	 */
	event_set(&cre->bev->ev_read, cre->s, EV_READ,
	    relay_ssl_readcb, cre->bev);
	event_set(&cre->bev->ev_write, cre->s, EV_WRITE,
	    relay_ssl_writecb, cre->bev);
}

void
relay_ssl_readcb(int fd, short event, void *arg)
{
	struct bufferevent *bufev = arg;
	struct ctl_relay_event *cre = (struct ctl_relay_event *)bufev->cbarg;
	struct session *con = (struct session *)cre->con;
	struct relay *rlay = (struct relay *)con->relay;
	int ret = 0, ssl_err = 0;
	short what = EVBUFFER_READ;
	size_t len;
	char rbuf[READ_BUF_SIZE];
	int howmuch = READ_BUF_SIZE;

	if (event == EV_TIMEOUT) {
		what |= EVBUFFER_TIMEOUT;
		goto err;
	}

	if (bufev->wm_read.high != 0)
		howmuch = MIN(sizeof(rbuf), bufev->wm_read.high);

	ret = SSL_read(cre->ssl, rbuf, howmuch);
	if (ret <= 0) {
		ssl_err = SSL_get_error(cre->ssl, ret);

		switch (ssl_err) {
		case SSL_ERROR_WANT_READ:
			DPRINTF("relay_ssl_readcb: session %d: "
			    "want read", con->id);
			goto retry;
		case SSL_ERROR_WANT_WRITE:
			DPRINTF("relay_ssl_readcb: session %d: "
			    "want write", con->id);
			goto retry;
		default:
			if (ret == 0)
				what |= EVBUFFER_EOF;
			else {
				ssl_error(rlay->conf.name, "relay_ssl_readcb");
				what |= EVBUFFER_ERROR;
			}
			goto err;
		}
	}

	if (evbuffer_add(bufev->input, rbuf, ret) == -1) {
		what |= EVBUFFER_ERROR;
		goto err;
	}

	relay_bufferevent_add(&bufev->ev_read, bufev->timeout_read);

	len = EVBUFFER_LENGTH(bufev->input);
	if (bufev->wm_read.low != 0 && len < bufev->wm_read.low)
		return;
	if (bufev->wm_read.high != 0 && len > bufev->wm_read.high) {
		struct evbuffer *buf = bufev->input;
		event_del(&bufev->ev_read);
		evbuffer_setcb(buf, bufferevent_read_pressure_cb, bufev);
		return;
	}

	if (bufev->readcb != NULL)
		(*bufev->readcb)(bufev, bufev->cbarg);
	return;

 retry:
	relay_bufferevent_add(&bufev->ev_read, bufev->timeout_read);
	return;

 err:
	(*bufev->errorcb)(bufev, what, bufev->cbarg);
}

void
relay_ssl_writecb(int fd, short event, void *arg)
{
	struct bufferevent *bufev = arg;
	struct ctl_relay_event *cre = (struct ctl_relay_event *)bufev->cbarg;
	struct session *con = (struct session *)cre->con;
	struct relay *rlay = (struct relay *)con->relay;
	int ret = 0, ssl_err;
	short what = EVBUFFER_WRITE;

	if (event == EV_TIMEOUT) {
		what |= EVBUFFER_TIMEOUT;
		goto err;
	}

	if (EVBUFFER_LENGTH(bufev->output)) {
		if (cre->buf == NULL) {
			cre->buflen = EVBUFFER_LENGTH(bufev->output);
			if ((cre->buf = malloc(cre->buflen)) == NULL) {
				what |= EVBUFFER_ERROR;
				goto err;
			}
			bcopy(EVBUFFER_DATA(bufev->output),
			    cre->buf, cre->buflen);
		}

		ret = SSL_write(cre->ssl, cre->buf, cre->buflen);
		if (ret <= 0) {
			ssl_err = SSL_get_error(cre->ssl, ret);

			switch (ssl_err) {
			case SSL_ERROR_WANT_READ:
				DPRINTF("relay_ssl_writecb: session %d: "
				    "want read", con->id);
				goto retry;
			case SSL_ERROR_WANT_WRITE:
				DPRINTF("relay_ssl_writecb: session %d: "
				    "want write", con->id);
				goto retry;
			default:
				if (ret == 0)
					what |= EVBUFFER_EOF;
				else {
					ssl_error(rlay->conf.name,
					    "relay_ssl_writecb");
					what |= EVBUFFER_ERROR;
				}
				goto err;
			}
		}
		evbuffer_drain(bufev->output, ret);
	}
	if (cre->buf != NULL) {
		free(cre->buf);
		cre->buf = NULL;
		cre->buflen = 0;
	}

	if (EVBUFFER_LENGTH(bufev->output) != 0)
		relay_bufferevent_add(&bufev->ev_write, bufev->timeout_write);

	if (bufev->writecb != NULL &&
	    EVBUFFER_LENGTH(bufev->output) <= bufev->wm_write.low)
		(*bufev->writecb)(bufev, bufev->cbarg);
	return;

 retry:
	if (cre->buflen != 0)
		relay_bufferevent_add(&bufev->ev_write, bufev->timeout_write);
	return;

 err:
	if (cre->buf != NULL) {
		free(cre->buf);
		cre->buf = NULL;
		cre->buflen = 0;
	}
	(*bufev->errorcb)(bufev, what, bufev->cbarg);
}

int
relay_bufferevent_add(struct event *ev, int timeout)
{
	struct timeval tv, *ptv = NULL;

	if (timeout) {
		timerclear(&tv);
		tv.tv_sec = timeout;
		ptv = &tv;
	}

	return (event_add(ev, ptv));
}

#ifdef notyet
int
relay_bufferevent_printf(struct ctl_relay_event *cre, const char *fmt, ...)
{
	int ret;
	va_list ap;

	va_start(ap, fmt);
	ret = evbuffer_add_vprintf(cre->output, fmt, ap);
	va_end(ap);

	if (cre->bev != NULL &&
	    ret != -1 && EVBUFFER_LENGTH(cre->output) > 0 &&
	    (cre->bev->enabled & EV_WRITE))
		bufferevent_enable(cre->bev, EV_WRITE);

	return (ret);
}
#endif

int
relay_bufferevent_print(struct ctl_relay_event *cre, char *str)
{
	if (cre->bev == NULL)
		return (evbuffer_add(cre->output, str, strlen(str)));
	return (bufferevent_write(cre->bev, str, strlen(str)));
}

int
relay_bufferevent_write_buffer(struct ctl_relay_event *cre,
    struct evbuffer *buf)
{
	if (cre->bev == NULL)
		return (evbuffer_add_buffer(cre->output, buf));
	return (bufferevent_write_buffer(cre->bev, buf));
}

int
relay_bufferevent_write_chunk(struct ctl_relay_event *cre,
    struct evbuffer *buf, size_t size)
{
	int ret;
	ret = relay_bufferevent_write(cre, buf->buffer, size);
	if (ret != -1)
		evbuffer_drain(buf, size);
	return (ret);
}

int
relay_bufferevent_write(struct ctl_relay_event *cre, void *data, size_t size)
{
	if (cre->bev == NULL)
		return (evbuffer_add(cre->output, data, size));
	return (bufferevent_write(cre->bev, data, size));
}

int
relay_cmp_af(struct sockaddr_storage *a, struct sockaddr_storage *b)
{
	struct sockaddr_in ia, ib;
	struct sockaddr_in6 ia6, ib6;

	switch (a->ss_family) {
	case AF_INET:
		bcopy(a, &ia, sizeof(struct sockaddr_in));
		bcopy(b, &ib, sizeof(struct sockaddr_in));

		return (memcmp(&ia.sin_addr, &ib.sin_addr,
		    sizeof(ia.sin_addr)) +
		    memcmp(&ia.sin_port, &ib.sin_port,
		    sizeof(ia.sin_port)));
		break;
	case AF_INET6:
		bcopy(a, &ia6, sizeof(struct sockaddr_in6));
		bcopy(b, &ib6, sizeof(struct sockaddr_in6));

		return (memcmp(&ia6.sin6_addr, &ib6.sin6_addr,
		    sizeof(ia6.sin6_addr)) +
		    memcmp(&ia6.sin6_port, &ib6.sin6_port,
		    sizeof(ia6.sin6_port)));
		break;
	default:
		return (-1);
	}
}

char *
relay_load_file(const char *name, off_t *len)
{
	struct stat	 st;
	off_t		 size;
	u_int8_t	*buf = NULL;
	int		 fd;

	if ((fd = open(name, O_RDONLY)) == -1)
		return (NULL);
	if (fstat(fd, &st) != 0)
		goto fail;
	size = st.st_size;
	if ((buf = (char *)calloc(1, size + 1)) == NULL)
		goto fail;
	if (read(fd, buf, size) != size)
		goto fail;

	close(fd);

	*len = size + 1;
	return (buf);

 fail:
	if (buf != NULL)
		free(buf);
	close(fd);
	return (NULL);
}

int
relay_load_certfiles(struct relay *rlay)
{
	char	 certfile[PATH_MAX];
	char	 hbuf[sizeof("ffff:ffff:ffff:ffff:ffff:ffff:255.255.255.255")];

	if ((rlay->conf.flags & F_SSL) == 0)
		return (0);

	if (print_host(&rlay->conf.ss, hbuf, sizeof(hbuf)) == NULL)
		return (-1);

	if (snprintf(certfile, sizeof(certfile),
	    "/etc/ssl/%s.crt", hbuf) == -1)
		return (-1);
	if ((rlay->ssl_cert = relay_load_file(certfile,
	    &rlay->ssl_cert_len)) == NULL)
		return (-1);
	log_debug("relay_load_certfile: using certificate %s", certfile);

	if (snprintf(certfile, sizeof(certfile),
	    "/etc/ssl/private/%s.key", hbuf) == -1)
		return -1;
	if ((rlay->ssl_key = relay_load_file(certfile,
	    &rlay->ssl_key_len)) == NULL)
		return (-1);
	log_debug("relay_load_certfile: using private key %s", certfile);

	return (0);
}

static __inline int
relay_proto_cmp(struct protonode *a, struct protonode *b)
{
	int ret;
	ret = strcasecmp(a->key, b->key);
	if (ret == 0)
		ret = (int)a->type - b->type;
	return (ret);
}

RB_GENERATE(proto_tree, protonode, nodes, relay_proto_cmp);

int
relay_session_cmp(struct session *a, struct session *b)
{
	struct relay	*rlay = (struct relay *)b->relay;
	struct protocol	*proto = rlay->proto;

	if (proto != NULL && proto->cmp != NULL)
		return ((*proto->cmp)(a, b));

	return ((int)a->id - b->id);
}

SPLAY_GENERATE(session_tree, session, nodes, relay_session_cmp);
@


1.74
log
@bump the current file descriptor resource limit (openfiles-cur) to the
maximum number of file descriptors for this login class
(openfiles-max) of the relay child processes. this will allow 1024
instead of just 128 open file descriptors in the default configuration
(class daemon), use the openfiles-max capability and the sysctl
kern.maxfiles to adjust the value.

ok gilles@@ pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.73 2007/11/28 14:41:36 reyk Exp $	*/
@


1.73
log
@typos
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.72 2007/11/26 09:38:25 reyk Exp $	*/
d27 1
d454 13
@


1.72
log
@allow to add labels to protocol actions, they will be printed in http
error pages and can be used to refer to additional information.

ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.71 2007/11/24 17:43:47 reyk Exp $	*/
d421 1
a421 1
		log_debug("relay_init: adding relay %s", rlay->conf.name);
d443 1
a443 1
			fatal("relay_launch: failed to listen");
@


1.71
log
@tweak for hostnames without dots (like "localhost")
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.70 2007/11/24 17:07:28 reyk Exp $	*/
d102 2
a103 1
void		 relay_close_http(struct session *, u_int, const char *);
d735 1
a735 1
		relay_close_http(con, 504, "connect timeout");
d750 1
a750 1
				    "failed to allocate nodes");
d768 1
a768 1
		    "failed to allocate output buffer event");
d924 2
a925 1
			relay_close_http(con, 500, "failed to modify header");
d934 1
a934 1
		relay_close_http(con, 403, "incomplete request");
d939 1
a939 1
		relay_close_http(con, 403, "rejecting request");
d1054 1
a1054 1
			relay_close_http(con, 400, "repeated header line");
d1072 2
a1073 1
				relay_close_http(con, 403, "rejecting request");
d1112 1
a1112 1
	relay_close_http(con, 500, strerror(errno));
d1294 1
a1294 1
				relay_close_http(con, 400, "malformed");
d1403 1
a1403 1
				relay_close_http(con, 500, errstr);
d1512 1
a1512 1
			relay_close_http(con, 502, "session failed");
d1526 1
a1526 1
	relay_close_http(con, 500, strerror(errno));
d1545 1
a1545 1
		relay_close_http(con, 500, "failed to allocate URL");
d1555 2
a1556 1
			relay_close_http(con, 500, "failed to allocate digest");
d1609 1
a1609 1
		relay_close_http(con, 400, "invalid host name");
d1625 1
a1625 1
		relay_close_http(con, 500, "failed to allocate path");
d1675 1
a1675 1
		relay_close_http(con, 500, "failed to allocate query");
d1716 1
a1716 1
		relay_close_http(con, 500, "failed to allocate cookie");
d1759 2
a1760 1
relay_close_http(struct session *con, u_int code, const char *msg)
d1769 1
a1769 1
	const char		*style;
d1795 2
d1819 2
a1820 1
	    "<p>%s</p>\n"
d1826 1
@


1.70
log
@sort includes, adjust to style(9)
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.69 2007/11/24 16:13:50 reyk Exp $	*/
d1616 2
@


1.69
log
@extend the url lookup algorithm to match the full URL and different
possible suffix/prefix combinations by stripping subdomains, path
components, and the query args.

ok and tested by gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.68 2007/11/24 13:39:24 reyk Exp $	*/
d19 1
a20 3
#include <sys/param.h>
#include <sys/types.h>
#include <sys/mman.h>
d28 1
a32 1
#include <net/if.h>
@


1.68
log
@fix goto to jump to the right place
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.67 2007/11/23 09:39:42 reyk Exp $	*/
d94 2
d388 1
a389 1
		i = 0;
d392 1
a392 3
			/* Limit the number of displayed lines */
			if (++i > 100) {
				fprintf(stderr, "\t\t...\n");
a393 1
			}
d397 7
d1531 3
a1533 3
int
relay_lookup_url(struct ctl_relay_event *cre, const char *str,
    enum digest_type type)
a1539 3
	if (cre->path == NULL)
		return (PN_PASS);

d1541 3
a1543 3
	    str, cre->path,
	    cre->args == NULL ? "" : "?",
	    cre->args == NULL ? "" : cre->args) == -1) {
d1548 2
d1581 76
@


1.67
log
@re-implement the "mark" action and document it in the manpage:
it is possible to attach a mark to a session based on matching an
entity (header, url, cookie, ...) and add conditional action for this
mark. it works a bit like the tag/tagged keywords in pf, but i decided
to pick a different name to avoid confusion.

ok pyr@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.66 2007/11/22 16:07:03 reyk Exp $	*/
d1567 1
a1567 1
			goto done;
@


1.66
log
@Fix relay roundrobin mode to work correctly when multiple hosts in a
table are down.

Thanks to Preston Norvell at serialssolutions dot com for reporting
the problem.
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.65 2007/11/22 10:09:53 reyk Exp $	*/
d344 7
d882 3
a910 3
		if ((pn->flags & PNFLAG_MARK) &&
		    cre->marked == 0)
			break;
a925 2
		if (pn->flags & PNFLAG_MARK)
			break;
a930 2
		if (pn->flags & PNFLAG_MARK)
			break;
d997 17
a1013 1
	int			 ret = PN_DROP;
d1017 1
a1017 1
		if (!header || ((pn->flags & PNFLAG_MARK) && cre->marked == 0))
d1037 1
a1037 1
		if (!header || ((pn->flags & PNFLAG_MARK) && cre->marked == 0))
d1060 2
a1061 3
		if (fnmatch(pn->value, pk->value, FNM_CASEFOLD) == 0) {
			if (pn->flags & PNFLAG_MARK)
				cre->marked++;
d1070 2
a1071 1
		if (SIMPLEQ_NEXT(pn, entry) == NULL)
a1074 2
		if ((pn->flags & PNFLAG_MARK) && cre->marked == 0)
			return (PN_PASS);
a1080 2
		if ((pn->flags & PNFLAG_MARK) && cre->marked == 0)
			return (PN_PASS);
d1085 7
d1095 1
a1095 1
	if (pn->flags & PNFLAG_LOG) {
a1498 1
		cre->marked = 0;
d2093 1
a2093 1
		log_info("relay %s, session %d (%d active), %s -> %s:%d, "
d2095 1
a2095 1
		    ibuf, obuf, ntohs(con->out.port), msg,
@


1.65
log
@add (new) "url" protocol action, this can be used to match/filter URL
suffix/prefix expressions like "example.com/index.html?args". a digest
mode allows to match against anonymized SHA1/MD5 digests of
suffix/prefix expressions.
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.64 2007/11/21 20:41:40 reyk Exp $	*/
d466 1
d1907 1
a1907 1
		idx = (int)rlay->dstkey++;
d1937 2
@


1.64
log
@move HTTP cookie and query lookup code from the into separate functions
(the if () else if () block was getting very big).
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.63 2007/11/21 20:01:45 reyk Exp $	*/
d94 2
d289 1
d309 3
d330 1
d332 2
a333 1
			fprintf(stderr, "%s \"%s\"", s, pn->key);
d1389 18
a1406 1
		if (pn->flags & PNFLAG_LOOKUP_QUERY) {
d1501 54
@


1.63
log
@fix the tree comparison function. it turned out that it could fail
with large trees of protocol actions.
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.62 2007/11/21 14:12:04 reyk Exp $	*/
d94 2
d286 2
a321 3
		fprintf(stderr, "expect \"%s\" from \"%s\"",
		    pn->value, pn->key);
		break;
d323 6
a328 2
		fprintf(stderr, "filter \"%s\" from \"%s\"",
		    pn->value, pn->key);
d1219 1
a1219 1
	char			*line, *ptr, *val;
d1349 2
a1350 4
				if (ret == PN_FAIL) {
					free(line);
					return;
				}
d1366 1
a1366 2
				free(line);
				return;
d1382 3
a1384 30
			if (cre->path == NULL || cre->args == NULL ||
			    strlen(cre->args) < 2 ||
			    (val = strdup(cre->args)) == NULL)
				goto next;
			ptr = val;
			while (ptr != NULL && strlen(ptr)) {
				pkv.key = ptr;
				pkv.type = NODE_TYPE_QUERY;
				if ((ptr = strchr(ptr, '&')) != NULL)
					*ptr++ = '\0';
				if ((pkv.value =
				    strchr(pkv.key, '=')) == NULL ||
				    strlen(pkv.value) < 1)
					continue;
				*pkv.value++ = '\0';

				if ((proot = RB_FIND(proto_tree,
				    cre->tree, &pkv)) == NULL)
					continue;
				PROTONODE_FOREACH(pnv, proot, entry) {
					ret = relay_handle_http(cre, proot,
					    pnv, &pkv, 0);
					if (ret == PN_FAIL) {
						free(val);
						free(line);
						return;
					}
				}
			}
			free(val);
d1386 3
a1388 45
			/*
			 * Decode the HTTP cookies
			 */
			val = strdup(pk.value);
			if (val == NULL)
				goto next;

			for (ptr = val; ptr != NULL && strlen(ptr);) {
				if (*ptr == ' ')
					*ptr++ = '\0';
				pkv.key = ptr;
				pkv.type = NODE_TYPE_COOKIE;
				if ((ptr = strchr(ptr, ';')) != NULL)
					*ptr++ = '\0';
				/*
				 * XXX We do not handle attributes
				 * ($Path, $Domain, or $Port)
				 */
				if (*pkv.key == '$')
					continue;

				if ((pkv.value =
				    strchr(pkv.key, '=')) == NULL ||
				    strlen(pkv.value) < 1)
					continue;
				*pkv.value++ = '\0';
				if (*pkv.value == '"')
					*pkv.value++ = '\0';
				if (pkv.value[strlen(pkv.value) - 1] == '"')
					pkv.value[strlen(pkv.value) - 1] = '\0';

				if ((proot = RB_FIND(proto_tree,
				    cre->tree, &pkv)) == NULL)
					continue;
				PROTONODE_FOREACH(pnv, proot, entry) {
					ret = relay_handle_http(cre, proot,
					    pnv, &pkv, 0);
					if (ret == PN_FAIL) {
						free(val);
						free(line);
						return;
					}
				}
			}
			free(val);
d1397 2
a1398 4
			else if (ret == PN_FAIL) {
				free(line);
				return;
			}
a1412 1
		continue;
d1473 97
@


1.62
log
@rename the "url" filter action to "query" to use the correct term.
please update your hoststated.conf configurations. also add more
examples to the manpage.

alright pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.61 2007/11/21 11:06:21 reyk Exp $	*/
d2669 5
a2673 2
	return (strcasecmp(a->key, b->key) +
	    a->type == b->type ? 0 : (a->type > b->type ? 1 : -1));
@


1.61
log
@more work on the "filter" action: close the connection instantly when
receiving a filtered entity, fix some remaining issues.
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.60 2007/11/20 17:11:50 reyk Exp $	*/
d284 3
d293 2
a294 2
	case NODE_TYPE_URL:
		fprintf(stderr, "url ");
a331 1
		fprintf(stderr, "none \"%s\"", pn->key);
d1301 1
a1301 1
			 * Decode the URL
d1379 1
a1379 1
		if (pn->flags & PNFLAG_LOOKUP_URL) {
d1387 1
a1387 1
				pkv.type = NODE_TYPE_URL;
@


1.60
log
@limit the number of displayed lines per node in relay_protodebug().
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.59 2007/11/20 15:54:55 reyk Exp $	*/
d861 4
a864 1
		if (cre->nodes[proot->id] <= 1)
a865 1
		cre->nodes[pn->id] = 0;
a1015 1
		ret = PN_PASS;
d1021 4
d1029 6
@


1.59
log
@it may be desirable to send a HTTP error page with error code and a
meaningful message if a HTTP/HTTPS relay closes the connection for
some reason. for example, a "403 Forbidden" if the request was
rejected by a filter. this will be enabled with the "return error"
option and is disabled by default, the standard behaviour is to
silently drop the connection; the browser may display an empty page in
this case. the look+feel of the HTTP error page can be customized with
a CSS style sheet, but we do not intend to allow customization of the
error page contents (hoststated is not a webserver!).

ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.58 2007/11/20 15:10:46 reyk Exp $	*/
d342 1
d365 9
a373 1
		PROTONODE_FOREACH(pn, proot, entry)
d375 1
@


1.58
log
@another fix to handle "expect" and "filter" actions in the new style
correctly.

ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.57 2007/11/20 09:59:09 reyk Exp $	*/
d86 1
d98 1
d697 1
a697 1
		relay_close(con, "connect timeout");
d711 2
a712 1
				relay_close(con, "failed to allocate nodes");
d729 2
a730 1
		relay_close(con, "failed to allocate output buffer event");
d803 15
d884 1
a884 1
			relay_close(con, "failed to modify header");
d895 1
a895 1
		relay_close(con, "incomplete header");
d902 1
a902 1
		relay_close(con, "rejecting header");
d1001 1
a1001 1
			relay_close(con, "repeated header line");
d1046 1
a1046 1
	relay_close(con, strerror(errno));
d1228 2
a1229 1
				goto fail;
a1337 1

d1339 1
a1339 1
				relay_close(con, errstr);
d1505 1
a1505 1
			relay_close(con, "session failed");
d1519 81
a1599 1
	relay_close(con, strerror(errno));
@


1.57
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.56 2007/11/20 09:57:49 reyk Exp $	*/
d828 1
d832 1
a832 1
		if (!cre->nodes[pn->id])
d837 4
a840 5
		if (proot == pn)
			cre->nodes[proot->id]--;
		if (cre->nodes[proot->id]) {
			if (SIMPLEQ_NEXT(pn, entry) == NULL)
				cre->nodes[proot->id] = 0;
a841 1
		}
d981 1
a981 1
		if (cre->nodes[proot->id]) {
@


1.56
log
@minor change to some relay log messages
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.55 2007/11/19 15:31:36 reyk Exp $	*/
a86 1

a940 1

@


1.55
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.54 2007/11/19 14:48:19 reyk Exp $	*/
d867 1
a867 1
			relay_close(con, "failed to modify header (done)");
d878 1
a878 1
		relay_close(con, "incomplete header (done)");
d885 1
a885 1
		relay_close(con, "rejecting header (done)");
d985 1
a985 1
			relay_close(con, "repeated header line (done)");
d1063 1
a1063 1
	relay_close(con, "last http content read (done)");
@


1.54
log
@rework the internal handling of protocol actions a little bit:

- allow to use a key for multiple times by appending a queue of
additional matches to the tree node. for example, this allows to
specify multiple "expect" or "filter" actions to white-/black-list
a list of HTTP-headers, URLs, ..

- prevent specifing an HTTP header for multiple times when using the
expect action.

- minor code shuffling
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.53 2007/10/22 17:14:10 reyk Exp $	*/
d1214 1
a1214 1
				
d1624 1
a1624 1
		imsg_compose(ibuf_pfe, IMSG_NATLOOK, 0, 0, -1, cnl, 
d2492 1
a2492 1
	int	 	 fd;
@


1.53
log
@we don't need mmap/munmap in relay_load_certificates anymore...
just use read() and make the function a little bit nicer.

ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.52 2007/10/22 16:53:30 pyr Exp $	*/
d59 1
d87 3
d91 2
a92 1
		    struct protonode *, struct protonode *, int);
d281 54
d337 4
a340 4
	struct protocol *proto = rlay->proto;
	struct protonode *pn;
	struct proto_tree *tree;
	const char *name;
d362 3
a364 51
	RB_FOREACH(pn, proto_tree, tree) {
		fprintf(stderr, "\t\t");

		fprintf(stderr, "%s ", name);

		switch (pn->type) {
		case NODE_TYPE_HEADER:
			break;
		case NODE_TYPE_URL:
			fprintf(stderr, "url ");
			break;
		case NODE_TYPE_COOKIE:
			fprintf(stderr, "cookie ");
			break;
		case NODE_TYPE_PATH:
			fprintf(stderr, "path ");
			break;
		}

		switch (pn->action) {
		case NODE_ACTION_APPEND:
			fprintf(stderr, "append \"%s\" to \"%s\"",
			    pn->value, pn->key);
			break;
		case NODE_ACTION_CHANGE:
			fprintf(stderr, "change \"%s\" to \"%s\"",
			    pn->key, pn->value);
			break;
		case NODE_ACTION_REMOVE:
			fprintf(stderr, "remove \"%s\"",
			    pn->key);
			break;
		case NODE_ACTION_EXPECT:
			fprintf(stderr, "expect \"%s\" from \"%s\"",
			    pn->value, pn->key);
			break;
		case NODE_ACTION_FILTER:
			fprintf(stderr, "filter \"%s\" from \"%s\"",
			    pn->value, pn->key);
			break;
		case NODE_ACTION_HASH:
			fprintf(stderr, "hash \"%s\"", pn->key);
			break;
		case NODE_ACTION_LOG:
			fprintf(stderr, "log \"%s\"", pn->key);
			break;
		case NODE_ACTION_NONE:
			fprintf(stderr, "none \"%s\"", pn->key);
			break;
		}
		fprintf(stderr, "\n");
d823 70
d945 2
a946 2
relay_handle_http(struct ctl_relay_event *cre, struct protonode *pn,
    struct protonode *pk, int header)
d980 8
d997 1
a997 1
			cre->nodes[pn->id] = 1;
d999 2
d1174 3
a1176 3
	struct protonode	*pn, pk, *pnv, pkv;
	char			*line, buf[READ_BUF_SIZE], *ptr, *val;
	int			 header = 0, ret;
d1210 5
d1275 1
d1297 1
a1297 1
			if ((pnv = RB_FIND(proto_tree,
d1301 7
a1307 4
			ret = relay_handle_http(cre, pnv, &pkv, 0);
			if (ret == PN_FAIL) {
				free(line);
				goto fail;
d1357 1
a1357 1
				if ((pnv = RB_FIND(proto_tree,
d1360 8
a1367 7
				ret = relay_handle_http(cre, pnv, &pkv, 0);
				if (ret == PN_PASS)
					continue;
				else if (ret == PN_FAIL) {
					free(val);
					free(line);
					return;
d1403 1
a1403 1
				if ((pnv = RB_FIND(proto_tree,
d1406 8
a1413 7
				ret = relay_handle_http(cre, pnv, &pkv, 0);
				if (ret == PN_PASS)
					continue;
				else if (ret == PN_FAIL) {
					free(val);
					free(line);
					return;
d1420 10
a1429 7
		ret = relay_handle_http(cre, pn, &pk, header);
		if (ret == PN_PASS)
			goto next;
		free(line);
		if (ret == PN_FAIL)
			return;
		continue;
d1431 1
d1433 8
a1440 7
		if (relay_bufferevent_print(cre->dst, pk.key) == -1 ||
		    relay_bufferevent_print(cre->dst,
		    header ? ": " : " ") == -1 ||
		    relay_bufferevent_print(cre->dst, pk.value) == -1 ||
		    relay_bufferevent_print(cre->dst, "\r\n") == -1) {
			free(line);
			goto fail;
d1446 4
a1449 54
		RB_FOREACH(pn, proto_tree, cre->tree) {
			switch (pn->action) {
			case NODE_ACTION_FILTER:
				if (!cre->nodes[pn->id])
					continue;
				cre->nodes[pn->id] = 0;
				break;
			default:
				if (cre->nodes[pn->id]) {
					cre->nodes[pn->id] = 0;
					continue;
				}
				break;
			}
			switch (pn->action) {
			case NODE_ACTION_APPEND:
			case NODE_ACTION_CHANGE:
				ptr = pn->value;
				if ((pn->flags & PNFLAG_MARK) &&
				    cre->marked == 0)
					break;
				if ((pn->flags & PNFLAG_MACRO) &&
				    (ptr = relay_expand_http(cre, pn->value,
				    buf, sizeof(buf))) == NULL)
					break;
				if (relay_bufferevent_print(cre->dst,
				    pn->key) == -1 ||
				    relay_bufferevent_print(cre->dst,
				    ": ") == -1 ||
				    relay_bufferevent_print(cre->dst,
				    ptr) == -1 ||
				    relay_bufferevent_print(cre->dst,
				    "\r\n") == -1)
					goto fail;
				DPRINTF("relay_read_http: add '%s: %s'",
				    pn->key, ptr);
				break;
			case NODE_ACTION_EXPECT:
				if (pn->flags & PNFLAG_MARK)
					break;
				DPRINTF("relay_read_http: missing '%s: %s'",
				    pn->key, pn->value);
				relay_close(con, "incomplete header (done)");
				return;
			case NODE_ACTION_FILTER:
				if (pn->flags & PNFLAG_MARK)
					break;
				DPRINTF("relay_read_http: filtered '%s: %s'",
				    pn->key, pn->value);
				relay_close(con, "rejecting header (done)");
				return;
			default:
				break;
			}
@


1.52
log
@load certificates text at parse time. then load them in relay processes.
this separation will ease reload a bit more.

ok reyk@@ who spotted a stupid mistake again...
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.51 2007/10/19 14:15:14 pyr Exp $	*/
d115 1
d2429 30
a2461 2
	int	 fd;
	off_t	 len;
a2463 1
	char	*str;
d2465 2
a2466 2
	if (!(rlay->conf.flags & F_SSL))
		return 0;
d2469 1
a2469 1
		return -1;
d2473 4
a2476 21
		return -1;
	if ((fd = open(certfile, O_RDONLY|O_NONBLOCK)) == -1)
		return -1;
	if ((len = lseek(fd, 0, SEEK_END)) == -1) {
		close(fd);
		return -1;
	}
	rlay->ssl_cert_len = len + 1;
	if ((rlay->ssl_cert = calloc(1, rlay->ssl_cert_len)) == NULL) {
		close(fd);
		return -1;
	}
	if ((str = mmap(NULL, len, PROT_READ, MAP_FILE|MAP_PRIVATE,
	    fd, 0)) == MAP_FAILED)  {
		close(fd);
		return -1;
	}
	close(fd);
	rlay->ssl_cert_len = len;
	(void)strlcpy(rlay->ssl_cert, str, rlay->ssl_cert_len);
	munmap(str, rlay->ssl_cert_len);
d2482 3
a2484 19
	if ((fd = open(certfile, O_RDONLY|O_NONBLOCK)) == -1)
		return -1;
	if ((len = lseek(fd, 0, SEEK_END)) == -1) {
		close(fd);
		return -1;
	}
	rlay->ssl_key_len = len + 1;
	if ((rlay->ssl_key = calloc(1, rlay->ssl_key_len)) == NULL) {
		close(fd);
		return -1;
	}
	if ((str = mmap(NULL, len, PROT_READ, MAP_FILE|MAP_PRIVATE,
	    fd, 0)) == MAP_FAILED) {
		close(fd);
		return -1;
	}
	close(fd);
	(void)strlcpy(rlay->ssl_key, str, rlay->ssl_key_len);
	munmap(str, rlay->ssl_key_len);
@


1.51
log
@Move relays from static TAILQs to allocated ones.
This syncs it with other hoststated entities and will make reload easier.
This is step 1 out of 7 for reload.
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.50 2007/10/05 17:32:13 reyk Exp $	*/
a93 1
int		 relay_ssl_ctx_init(struct relay *);
a385 4
		if ((rlay->conf.flags & F_SSL) &&
		    relay_ssl_ctx_init(rlay) == -1)
			fatal("relay_launch: could not open certificates");

a2012 42
int
relay_ssl_ctx_init(struct relay *rlay)
{
	int	fd;
	off_t	len;
	char	certfile[PATH_MAX];
	char	hbuf[sizeof("ffff:ffff:ffff:ffff:ffff:ffff:255.255.255.255")];

	if (print_host(&rlay->conf.ss, hbuf, sizeof(hbuf)) == NULL)
		return -1;

	if (snprintf(certfile, sizeof(certfile),
	    "/etc/ssl/%s.crt", hbuf) == -1)
		return -1;
	if ((fd = open(certfile, O_RDONLY|O_NONBLOCK)) == -1)
		return -1;
	if ((len = lseek(fd, 0, SEEK_END)) == -1)
		return -1;
	if ((rlay->ssl_cert = mmap(NULL, len, PROT_READ, MAP_FILE|MAP_PRIVATE,
	    fd, 0)) == MAP_FAILED)
		return -1;
	rlay->ssl_cert_len = len;
	close(fd);
	log_debug("relay_ssl_ctx_init: using certificate %s", certfile);

	if (snprintf(certfile, sizeof(certfile),
	    "/etc/ssl/private/%s.key", hbuf) == -1)
		return -1;
	if ((fd = open(certfile, O_RDONLY|O_NONBLOCK)) == -1)
		return -1;
	if ((len = lseek(fd, 0, SEEK_END)) == -1)
		return -1;
	if ((rlay->ssl_key = mmap(NULL, len, PROT_READ, MAP_FILE|MAP_PRIVATE,
	    fd, 0)) == MAP_FAILED)
		return -1;
	rlay->ssl_key_len = len;
	close(fd);
	log_debug("relay_ssl_ctx_init: using private key %s", certfile);

	return (0);
}

a2052 1
	munmap(rlay->ssl_cert, rlay->ssl_cert_len);
a2056 1
	munmap(rlay->ssl_key, rlay->ssl_key_len);
d2426 67
@


1.50
log
@stylistic changes in the relay/relay_config structure.
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.49 2007/10/05 15:46:49 reyk Exp $	*/
d263 1
a263 1
	TAILQ_FOREACH(rlay, &env->relays, entry) {
d371 1
a371 1
	TAILQ_FOREACH(rlay, &env->relays, entry) {
d409 1
a409 1
	TAILQ_FOREACH(rlay, &env->relays, entry) {
d465 1
a465 1
	TAILQ_FOREACH(rlay, &env->relays, entry) {
d518 1
a518 1
	TAILQ_FOREACH(rlay, &env->relays, entry) {
d1956 1
a1956 1
			TAILQ_FOREACH(rlay, &env->relays, entry)
@


1.49
log
@unbreak non-SSL relays by calling the ssl context init only if the SSL
flag is present...
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.48 2007/10/01 13:57:29 pyr Exp $	*/
d411 1
a411 1
		    (rlay->ctx = relay_ssl_ctx_create(rlay)) == NULL)
d2129 1
a2129 1
	ssl = SSL_new(rlay->ctx);
@


1.48
log
@kill some remaining debug that snuk in.
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.47 2007/09/28 13:05:28 pyr Exp $	*/
d410 2
a411 1
		if ((rlay->ctx = relay_ssl_ctx_create(rlay)) == NULL)
@


1.47
log
@Change the ssl_privsep code to work on char buffers.
The fd based code introduced weirdness since all children were accessing
the same fd at once. This will also greatly facilitate reloading, no
fd-passing will be involved between the parent and relay children.

While there, cleanup the code diverting from the original ssl_rsa.c code
a bit more.

Weird behavior discovery by pascoe@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.46 2007/09/27 13:50:40 pyr Exp $	*/
a2063 1
	const char *ssl_action = "NO ACTION";
a2117 1
	log_debug("last SSL action: %s", ssl_action);
@


1.46
log
@Move SSL context creation after privileges are dropped.
This puts the ssl_privsep code to use.
One more step towards graceful L7 reload.
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.45 2007/09/27 13:34:22 pyr Exp $	*/
d22 1
d2020 2
d2031 1
a2031 1
	if ((rlay->cert_fd = open(certfile, O_RDONLY|O_NONBLOCK)) == -1)
d2033 7
d2045 6
a2050 1
	if ((rlay->key_fd = open(certfile, O_RDONLY|O_NONBLOCK)) == -1)
d2052 2
d2097 2
a2098 1
	if (!ssl_ctx_use_certificate_chain(ctx, rlay->cert_fd))
d2100 1
d2103 1
a2103 1
	if (!ssl_ctx_use_private_key(ctx, rlay->key_fd))
d2105 1
@


1.45
log
@Simplify ssl_privsep.c, since it won't need to remain synced with the
equivalent openssl functions.
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.44 2007/09/25 08:24:26 pyr Exp $	*/
d93 1
d387 2
a388 2
		    (rlay->ctx = relay_ssl_ctx_create(rlay)) == NULL)
			fatal("relay_launch: failed to create SSL context");
d409 3
d2016 26
a2044 1
	int fd;
d2047 1
a2047 1
	char certfile[PATH_MAX], hbuf[128];
d2079 2
a2080 11
	if (print_host(&rlay->conf.ss, hbuf, sizeof(hbuf)) == NULL)
		goto err;

	/* Load the certificate */
	if (snprintf(certfile, sizeof(certfile),
	    "/etc/ssl/%s.crt", hbuf) == -1)
		goto err;
	if ((fd = open(certfile, O_RDONLY|O_NONBLOCK)) == -1)
		goto err;
	log_debug("relay_ssl_ctx_create: using certificate %s", certfile);
	if (!ssl_ctx_use_certificate_chain(ctx, fd))
d2083 2
a2084 9
	/* Load the private key */
	if (snprintf(certfile, sizeof(certfile),
	    "/etc/ssl/private/%s.key", hbuf) == -1) {
		goto err;
	}
	if ((fd = open(certfile, O_RDONLY|O_NONBLOCK)) == -1)
		goto err;
	log_debug("relay_ssl_ctx_create: using private key %s", certfile);
	if (!ssl_ctx_use_private_key(ctx, fd))
d2099 1
@


1.44
log
@Introduce two new functions to be able to load certificates while
already chrooted and with privileges dropped.
This is the very first step in being able to reload a
layer 7 configuration.

not ok reyk who's away but should be glad to see this in.
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.43 2007/09/10 11:59:22 reyk Exp $	*/
d2071 1
a2071 1
	if (!ssl_ctx_use_private_key(ctx, fd,  SSL_FILETYPE_PEM))
@


1.43
log
@add support for relaying DNS traffic (with a little bit of packet
header randomization). this adds an infrastructure to support
UDP-based protocols.

ok gilles@@, tested by some
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.42 2007/09/07 08:20:24 reyk Exp $	*/
d2015 1
d2057 2
d2060 1
a2060 1
	if (!SSL_CTX_use_certificate_chain_file(ctx, certfile))
d2068 2
d2071 1
a2071 1
	if (!SSL_CTX_use_PrivateKey_file(ctx, certfile,  SSL_FILETYPE_PEM))
@


1.42
log
@add an interface to dump running relay sessions to the control socket
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.41 2007/09/06 19:55:45 reyk Exp $	*/
d61 1
d112 2
d293 3
d375 10
d389 7
a395 2
		if ((rlay->s = relay_socket_listen(&rlay->conf.ss,
		    rlay->conf.port, rlay->proto)) == -1)
d510 1
d517 5
d523 1
a523 1
		    relay_accept, rlay);
d529 1
a529 2
relay_socket(struct sockaddr_storage *ss, in_port_t port,
    struct protocol *proto)
a530 3
	int s = -1, val;
	struct linger lng;

d542 2
d546 13
d1687 2
a1688 1
	struct relay	*rlay = (struct relay *)con->relay;
d1690 2
a1691 2
	if (bcmp(&rlay->conf.ss, &con->out.ss, sizeof(con->out.ss)) == 0 &&
	    con->out.port == rlay->conf.port) {
d1698 12
a1709 1
	if ((rlay->conf.flags & F_SSL) && (con->in.ssl == NULL)) {
d2407 30
@


1.41
log
@rename relay_host to print_host in log.c
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.40 2007/09/05 10:25:13 reyk Exp $	*/
d1470 1
d1481 9
d1796 1
d1898 8
@


1.40
log
@be extra careful with pointers in session_cmp
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.39 2007/09/05 08:48:42 reyk Exp $	*/
a76 1
const char	*relay_host(struct sockaddr_storage *, char *, size_t);
d783 1
a783 1
			if (relay_host(&cre->ss, ibuf, sizeof(ibuf)) == NULL)
d798 1
a798 1
			if (relay_host(&rlay->conf.ss,
a1435 14
const char *
relay_host(struct sockaddr_storage *ss, char *buf, size_t len)
{
	int af = ss->ss_family;
	void *ptr;

	bzero(buf, len);
	if (af == AF_INET)
		ptr = &((struct sockaddr_in *)ss)->sin_addr;
	else
		ptr = &((struct sockaddr_in6 *)ss)->sin6_addr;
	return (inet_ntop(af, ptr, buf, len));
}

d1720 2
a1721 2
		(void)relay_host(&con->in.ss, ibuf, sizeof(ibuf));
		(void)relay_host(&con->out.ss, obuf, sizeof(obuf));
d1980 1
a1980 1
	if (relay_host(&rlay->conf.ss, hbuf, sizeof(hbuf)) == NULL)
@


1.39
log
@store relay sessions in SPLAY trees instead of TAILQ lists. this will
be used for faster lookups of sessions based on different criteria.

ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.38 2007/09/04 10:58:08 reyk Exp $	*/
d2367 1
a2367 1
	struct relay	*rlay = (struct relay *)a->relay;
d2370 1
a2370 1
	if (proto->cmp != NULL)
@


1.38
log
@small fix in the error path when accepting new relay sessions
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.37 2007/09/04 10:32:54 reyk Exp $	*/
d263 1
a263 1
		while ((con = TAILQ_FIRST(&rlay->sessions)) != NULL)
d470 1
a470 1
		for (con = TAILQ_FIRST(&rlay->sessions);
d472 2
a473 1
			next_con = TAILQ_NEXT(con, entry);
d1497 1
a1497 1
	TAILQ_INSERT_HEAD(&rlay->sessions, con, entry);
d1724 1
a1724 1
	TAILQ_REMOVE(&rlay->sessions, con, entry);
d2363 14
@


1.37
log
@support chained ssl certificates; a chain can be added to the
PEM-encoded server cert file (no CA support yet).

makes a chained ssl certificate from Comodo work with hoststated, also
tested with other certs (self-signed, Thawte Premium)

thanks to ben (pr0ncracker at gmail dot com)
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.36 2007/07/26 23:29:40 jsg Exp $	*/
d1495 6
d1517 4
a1520 2
		    calloc(1, sizeof(struct ctl_natlook))) == NULL)
			goto err;
a1521 6

	relay_sessions++;
	TAILQ_INSERT_HEAD(&rlay->sessions, con, entry);

	/* Increment the per-relay session counter */
	rlay->stats[proc_id].last++;
@


1.36
log
@Combine http filter/expect cases to simplify code.
ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.35 2007/06/19 06:29:20 pyr Exp $	*/
d2000 1
a2000 1
	if (!SSL_CTX_use_certificate_file(ctx, certfile, SSL_FILETYPE_PEM))
@


1.35
log
@Do not fatal out with ``pipe closed'' when a short read occurs on one
of our socket pairs. Instead disable listening on the pipe, terminate the
event loop, and let the parent process's SIGCHLD handler do a clean
shutdown.

from an ospfd diff by claudio, ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.34 2007/06/12 15:16:10 msf Exp $	*/
a858 7
		DPRINTF("relay_handle_http: expect '%s: %s'",
		    pn->key, pn->value);
		if (fnmatch(pn->value, pk->value, FNM_CASEFOLD) == 0) {
			if (pn->flags & PNFLAG_MARK)
				cre->marked++;
			cre->nodes[pn->id] = 1;
		}
d860 1
a860 1
		break;
d862 2
a863 1
		DPRINTF("relay_handle_http: filter '%s: %s'",
@


1.34
log
@put the fd passing from bgpd back in to hoststated's version of imsg,
needed for layer 7 reload support.

ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.33 2007/06/07 07:19:50 pyr Exp $	*/
d1817 6
a1822 2
		if (n == 0)
			fatalx("relay_dispatch_pfe: pipe closed");
d1928 6
a1933 2
		if (n == 0)
			fatalx("relay_dispatch_parent: pipe closed");
@


1.33
log
@(finally) Enable reload support for layer 3 configurations.
Hoststated can be reloaded either by sending SIGHUP to the parent process
or by using ``hoststatectl reload''
discussed and ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.32 2007/05/29 00:48:04 pyr Exp $	*/
d467 1
a467 1
		imsg_compose(ibuf_pfe, IMSG_STATISTICS, 0, 0,
d1535 2
a1536 1
		imsg_compose(ibuf_pfe, IMSG_NATLOOK, 0, 0, cnl, sizeof(*cnl));
d1788 1
a1788 1
		imsg_compose(ibuf_pfe, IMSG_KILLSTATES, 0, 0,
@


1.32
log
@move the ssl cipher suite string to a (small) static charbuf,
this will make it easier to send the struct over the socket.
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.31 2007/05/29 00:21:10 pyr Exp $	*/
d175 3
@


1.31
log
@move struct relay to the runtime + config scheme.
this time around, include hoststatectl changes too.
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.30 2007/05/28 22:11:33 pyr Exp $	*/
d1954 1
a1954 1
	char certfile[PATH_MAX], hbuf[128], *ciphers = NULL;
d1983 1
a1983 4
	/* Change the default SSL cipher suite, if specified */
	if ((ciphers = proto->sslciphers) == NULL)
		ciphers = SSLCIPHERS_DEFAULT;
	if (!SSL_CTX_set_cipher_list(ctx, ciphers))
@


1.30
log
@another small step towards hoststated reloading.
allow purging of parts of the hoststated environment structure.
start using this function now to only keep vital information in
hoststated children processes.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.29 2007/05/27 20:53:10 pyr Exp $	*/
d257 1
a257 1
		if (rlay->flags & F_DISABLE)
d362 1
a362 1
		log_debug("relay_init: adding relay %s", rlay->name);
d367 1
a367 1
		if ((rlay->flags & F_SSL) &&
d371 2
a372 2
		if ((rlay->s = relay_socket_listen(&rlay->ss, rlay->port,
		    rlay->proto)) == -1)
d386 1
a386 1
			switch (rlay->dstmode) {
d393 1
a393 1
				    hash32_str(rlay->name, HASHINIT);
d408 1
a408 1
			    rlay->dstcheck ? "" : " (no check)");
d462 1
a462 1
		crs.id = rlay->id;
d471 1
a471 1
			if (timercmp(&tv, &rlay->timeout, >=))
d488 1
a488 1
		log_debug("relay_launch: running relay %s", rlay->name);
d683 1
a683 1
	    rlay->timeout.tv_sec, rlay->timeout.tv_sec);
d726 1
a726 1
	if ((rlay->flags & F_SSL) && con->in.ssl != NULL)
d730 1
a730 1
	    rlay->timeout.tv_sec, rlay->timeout.tv_sec);
d795 2
a796 1
			if (relay_host(&rlay->ss, ibuf, sizeof(ibuf)) == NULL)
d803 2
a804 1
			snprintf(ibuf, sizeof(ibuf), "%u", ntohs(rlay->port));
d811 1
a811 1
		snprintf(ibuf, sizeof(ibuf), "%lu", rlay->timeout.tv_sec);
d1469 2
a1470 1
	if (relay_sessions >= RELAY_MAX_SESSIONS || rlay->flags & F_DISABLE)
d1492 1
a1492 1
	con->retry = rlay->dstretry;
d1512 1
a1512 1
	if (rlay->flags & F_NATLOOK) {
d1524 1
a1524 1
	if (rlay->flags & F_NATLOOK && cnl != NULL) {
d1531 1
a1531 1
		bcopy(&rlay->ss, &cnl->dst, sizeof(cnl->dst));
d1536 1
a1536 1
		bcopy(&rlay->timeout, &tv, sizeof(tv));
d1579 1
a1579 1
	if (rlay->dstcheck && !table->up) {
d1584 1
a1584 1
	switch (rlay->dstmode) {
d1594 2
a1595 2
		p = relay_hash_addr(&rlay->ss, p);
		p = hash32_buf(&rlay->port, sizeof(rlay->port), p);
d1604 1
a1604 1
		if (!rlay->dstcheck || host->up == HOST_UP)
d1610 1
a1610 1
		if (!rlay->dstcheck || host->up == HOST_UP)
d1636 1
a1636 1
	    rlay->dstss.ss_family == AF_UNSPEC && rlay->dsttable == NULL) {
d1655 2
a1656 2
	if (bcmp(&rlay->ss, &con->out.ss, sizeof(con->out.ss)) == 0 &&
	    con->out.port == rlay->port) {
d1663 1
a1663 1
	if ((rlay->flags & F_SSL) && (con->in.ssl == NULL)) {
d1688 2
a1689 2
		bcopy(&rlay->dstss, &con->out.ss, sizeof(con->out.ss));
		con->out.port = rlay->dstport;
d1740 1
a1740 1
		    "%s%s%s", rlay->name, con->id, relay_sessions,
d1961 1
a1961 1
	SSL_CTX_set_timeout(ctx, rlay->timeout.tv_sec);
d1989 1
a1989 1
	if (relay_host(&rlay->ss, hbuf, sizeof(hbuf)) == NULL)
d2012 2
a2013 2
	if (!SSL_CTX_set_session_id_context(ctx, rlay->name,
	    strlen(rlay->name)))
d2021 1
a2021 1
	ssl_error(rlay->name, "relay_ssl_ctx_create");
d2050 1
a2050 1
	ssl_error(rlay->name, "relay_ssl_transaction");
d2088 1
a2088 1
			ssl_error(rlay->name, "relay_ssl_accept");
d2097 1
a2097 1
	    rlay->name, con->id, relay_sessions);
d2100 1
a2100 1
	    rlay->name, con->id, relay_sessions);
d2163 1
a2163 1
				ssl_error(rlay->name, "relay_ssl_readcb");
d2242 1
a2242 1
					ssl_error(rlay->name,
@


1.29
log
@Second step towards hoststated reload:
First split out hosts, tables and services into to structs, one that
contains the runtime fields and one (inside the runtime) that contains
mostly static fields that will be sent over the socket during reload.

Also move the demoted field of tables inside the flags field as its
just a boolean.
ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.28 2007/05/26 19:58:49 pyr Exp $	*/
d162 1
@


1.28
log
@first steps for implementing reload:
	* make parse_config allocate the hoststated function by itself
	* make as many sockets as necessary to talk to the relay children
	* add send_all for talking to all children
with advise and ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.27 2007/05/02 09:07:28 claudio Exp $	*/
d394 1
a394 1
				    hash32_str(rlay->dsttable->name,
d406 1
a406 1
			    rlay->dstnhosts, rlay->dsttable->name,
d1597 1
a1597 1
	    host->name, p, idx);
d1599 1
a1599 1
		DPRINTF("relay_from_table: host %s", host->name);
d1605 1
a1605 1
		DPRINTF("relay_from_table: next host %s", host->name);
d1614 3
a1616 3
	con->retry = host->retry;
	con->out.port = table->port;
	bcopy(&host->ss, &con->out.ss, sizeof(con->out.ss));
d1832 2
a1833 1
			if ((table = table_find(env, host->tableid)) == NULL)
d1857 1
a1857 1
				    host->id, host->up);
d1861 2
a1862 1
			if ((table = table_find(env, host->tableid)) == NULL)
d1866 2
a1867 1
			    "host %u %s", proc_id, st.up, host->id, host->name);
@


1.27
log
@It is no longer needed to pass a cleared timeval to event_loopexit() NULL
does the job just fine. OK reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.26 2007/04/12 14:45:45 reyk Exp $	*/
d143 1
a143 1
    int pipe_parent2relay[2], int pipe_pfe2hce[2],
a212 1
	close(pipe_parent2relay[0]);
d216 2
d221 1
d227 2
a229 1
	imsg_init(ibuf_main, pipe_parent2relay[1], relay_dispatch_parent);
d1939 1
@


1.26
log
@add a new relay 'path' action to filter the URL path and arguments.

ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.25 2007/04/10 21:33:52 reyk Exp $	*/
a133 5
	struct timeval tv;

	tv.tv_sec = 0;
	tv.tv_usec = 0;

a134 1
	case SIGALRM:
a135 1
	case SIGQUIT:
d137 1
a137 1
		event_loopexit(&tv);
@


1.25
log
@move the decoding of the URL, independent from the node lookups, we
will need it later.
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.24 2007/04/10 18:18:26 reyk Exp $	*/
d310 3
d1150 23
d1759 2
d1772 2
@


1.24
log
@it is a better idea to handle all enum values in the switch statement
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.23 2007/04/10 18:14:17 reyk Exp $	*/
d1045 1
a1045 1
	char			*line, buf[READ_BUF_SIZE], *ptr, *val, *method;
d1105 1
a1105 1
			if (cre->dir == RELAY_DIR_RESPONSE)
d1107 2
a1108 1
			else if (strcmp("GET", pk.key) == 0)
d1124 23
d1166 1
d1179 3
a1181 5
			/*
			 * Decode the URL
			 */
			val = strdup(pk.value);
			if (val == NULL)
d1183 1
a1183 9
			if ((ptr = strchr(val, '?')) == NULL ||
			    strlen(ptr) < 2) {
				free(val);
				goto next;
			}
			*ptr++ = '\0';
			method = strchr(ptr, ' ');
			if (method != NULL)
				*method++ = '\0';
@


1.23
log
@the relay filter action needs special handling to work correctly
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.22 2007/03/21 00:08:08 reyk Exp $	*/
d1269 1
a1269 3
			case NODE_ACTION_APPEND:
			case NODE_ACTION_CHANGE:
			case NODE_ACTION_EXPECT:
@


1.22
log
@in addition to the host retry option in tables, add support for the
optional connection "retry" to the forward to, service, and nat lookup
options. for example, "nat lookup retry 3" is useful when running
hoststated as a transparent proxy when connecting to unreliable
frontend/backend servers.

ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.21 2007/03/17 22:25:08 reyk Exp $	*/
d866 1
a866 2
		if (fnmatch(pn->value, pk->value, FNM_CASEFOLD) ==
		    FNM_NOMATCH) {
d1263 4
a1266 1
			if (cre->nodes[pn->id]) {
d1268 9
a1276 1
				continue;
@


1.21
log
@close unused relay2pfe privsep sockets correctly
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.20 2007/03/17 22:22:23 reyk Exp $	*/
d1443 1
@


1.20
log
@fix the natlook mode.
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.19 2007/03/13 12:04:52 reyk Exp $	*/
d224 1
a224 1
		close(pipe_pfe2relay[i][1]);
@


1.19
log
@allow to specify the IP_TTL and IP_MINTTL options for the relays to
support the Generalized TTL Security Mechanism (GTSM) according to RFC
3682. this is especially useful with inbound connections and a fixed
distance to the backend servers.

ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.18 2007/03/07 17:40:32 reyk Exp $	*/
d1479 1
d1579 1
d1585 2
a1586 1
	if (con->out.ss.ss_family == AF_UNSPEC && cnl->in == -1) {
d1637 1
a1637 1
	} else {
@


1.18
log
@- fix the hoststatectl host disable/enable commands to work with relay
layer 7 loadbalancing.
- allow to run relays with tables without depending on services
- show hosts and tables assigned to relays in hoststatectl show commands

ok pyr@@ deraadt@@ with some input from mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.17 2007/03/06 19:26:46 reyk Exp $	*/
d520 4
d532 26
d559 3
a576 10
		    &val, sizeof(val)) == -1)
			goto bad;
	}
	if (proto->tcpflags & TCPFLAG_BUFSIZ) {
		val = proto->tcpbufsiz;
		if (setsockopt(s, SOL_SOCKET, SO_RCVBUF,
		    &val, sizeof(val)) == -1)
			goto bad;
		val = proto->tcpbufsiz;
		if (setsockopt(s, SOL_SOCKET, SO_SNDBUF,
@


1.17
log
@add support for handling simple HTTP cookies (no per-path/domain
cookies yet), for example: cookie hash "JSESSIONID"

tested by some people
ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.16 2007/03/05 11:44:50 reyk Exp $	*/
d1726 1
d1752 18
d1776 2
a1777 1

@


1.16
log
@do not strip the header for expect, hash, and log actions.

since we have a tristate in relay_handle_http(), use nicer return
codes defined to make it better readble (no function change).
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.15 2007/03/02 11:32:40 reyk Exp $	*/
d1023 1
a1023 1
	char			*line, buf[READ_BUF_SIZE], *ptr, *url, *method;
d1128 9
a1136 5
		/* Decode the URL */
		if (pn->flags & PNFLAG_LOOKUP_URL &&
		    cre->dir == RELAY_DIR_REQUEST) {
			url = strdup(pk.value);
			if (url == NULL)
d1138 1
a1138 1
			if ((ptr = strchr(url, '?')) == NULL ||
d1140 1
a1140 1
				free(url);
d1157 46
d1210 1
a1210 1
					free(url);
d1215 1
a1215 1
			free(url);
d1218 1
d1227 1
a1227 1
next:
@


1.15
log
@when the http read callback changes and some data is still left in the
input buffer, we call the new callback to handle the remaining data.
this change makes sure that we only do this after the read callback
was actually changed (read header -> read content, read content ->
read header, read chunks...) to avoid a possible loop which could
happen in some rare cases.
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.14 2007/02/27 13:38:58 reyk Exp $	*/
d801 1
d806 1
a806 1
			return (1);
d826 1
a826 1
			return (1);
d838 1
d852 1
a852 1
			return (1);
d856 1
d860 1
a860 1
			return (1);
d863 1
d866 1
a866 1
		return (1);
d876 1
a876 1
	return (0);
d879 1
a879 1
	return (-1);
d1157 1
a1157 1
				if (ret == 1)
d1159 1
a1159 1
				else if (ret == -1) {
d1169 1
a1169 1
		if (ret == 1)
d1172 1
a1172 1
		if (ret == -1)
@


1.14
log
@in addition to actions on request headers, allow to define relay
actions on response headers (the reply sent by backend HTTP servers).
the default and slightly faster relay streaming mode will be used if
no actions are defined.

for example:
response change "Server" to "OpenBSD-hoststated/4.1"

ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.13 2007/02/26 16:10:24 reyk Exp $	*/
d902 2
d998 1
a998 1
	if (EVBUFFER_LENGTH(src))
d1275 1
a1275 1
	if (EVBUFFER_LENGTH(src))
@


1.13
log
@handle strlcpy return values, make lint happy
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.12 2007/02/26 15:41:44 reyk Exp $	*/
d276 2
d292 5
a296 1
	RB_FOREACH(pn, proto_tree, &proto->tree) {
d299 2
d345 5
d613 1
d626 19
d675 8
a682 5
		inrd = relay_read_http;
		if ((con->in.nodes = calloc(proto->nodecount,
		    sizeof(u_int8_t))) == NULL) {
			relay_close(con, "failed to allocate node buffer");
			return;
d1077 3
a1079 1
			if (strcmp("GET", pk.key) == 0)
d1096 2
a1097 1
		    cre->method == HTTP_METHOD_PUT) &&
d1119 1
a1119 1
		if ((pn = RB_FIND(proto_tree, &proto->tree, &pk)) == NULL)
d1123 2
a1124 1
		if (pn->flags & PNFLAG_LOOKUP_URL) {
d1148 1
a1148 1
				    &proto->tree, &pkv)) == NULL)
d1183 1
a1183 1
		RB_FOREACH(pn, proto_tree, &proto->tree) {
d1237 1
d1264 2
a1265 1
		if (proto->lateconnect && cre->dst->bev == NULL &&
d1329 1
d1359 4
@


1.12
log
@better error handling for buffer I/O, fix the log action
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.11 2007/02/26 12:35:43 reyk Exp $	*/
d717 1
a717 1
	strlcpy(buf, val, len);
@


1.11
log
@handle requests with chunked transfer-encoding.
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.10 2007/02/26 12:16:12 reyk Exp $	*/
d697 2
a698 1
	relay_bufferevent_write_buffer(cre->dst, src);
d705 3
d721 2
a722 1
			relay_host(&cre->ss, ibuf, sizeof(ibuf));
d736 2
a737 1
			relay_host(&rlay->ss, ibuf, sizeof(ibuf));
d769 1
a769 1
			return (-1);
d775 7
a781 6
		relay_bufferevent_print(cre->dst, pn->key);
		relay_bufferevent_print(cre->dst, ": ");
		relay_bufferevent_print(cre->dst, pk->value);
		relay_bufferevent_print(cre->dst, ", ");
		relay_bufferevent_print(cre->dst, ptr);
		relay_bufferevent_print(cre->dst, "\r\n");
d789 1
a789 1
			return (-1);
d814 1
a814 1
			return (-1);
d821 1
a821 1
			return (-1);
d826 8
a833 1
		return (-1);
d835 1
a835 3
	if (pn->flags & PNFLAG_LOG)
		evbuffer_add_printf(con->log, " [%s: %s]",
		    pn->key, pk->value);
d837 3
d857 2
a858 1
	relay_bufferevent_write_buffer(cre->dst, src);
d870 3
d914 3
a916 2
		relay_bufferevent_print(cre->dst, line);
		relay_bufferevent_print(cre->dst, "\r\n");
d927 2
a928 1
			relay_bufferevent_print(cre->dst, "\r\n");
d937 2
a938 1
		relay_bufferevent_write_chunk(cre->dst, src, size);
d953 2
a954 1
			relay_bufferevent_print(cre->dst, "\r\n\r\n");
d967 3
d982 1
a982 1
	int			 header = 0;
d1018 5
a1022 2
			relay_bufferevent_print(cre->dst, line);
			relay_bufferevent_print(cre->dst, "\r\n");
d1110 2
a1111 1
				if (relay_handle_http(cre, pnv, &pkv, 0) == -1)
d1113 5
d1122 2
a1123 1
		if (relay_handle_http(cre, pn, &pk, header) == -1)
a1124 1

d1126 2
d1131 8
a1138 7
		relay_bufferevent_print(cre->dst, pk.key);
		if (header)
			relay_bufferevent_print(cre->dst, ": ");
		else
			relay_bufferevent_print(cre->dst, " ");
		relay_bufferevent_print(cre->dst, pk.value);
		relay_bufferevent_print(cre->dst, "\r\n");
d1159 9
a1167 4
				relay_bufferevent_print(cre->dst, pn->key);
				relay_bufferevent_print(cre->dst, ": ");
				relay_bufferevent_print(cre->dst, ptr);
				relay_bufferevent_print(cre->dst, "\r\n");
d1215 2
a1216 1
		relay_bufferevent_print(cre->dst, "\r\n");
d1237 3
d1552 6
a1557 4
		relay_host(&con->in.ss, ibuf, sizeof(ibuf));
		relay_host(&con->out.ss, obuf, sizeof(obuf));
		if (EVBUFFER_LENGTH(con->log)) {
			evbuffer_add_printf(con->log, "\r\n");
a1558 1
		}
@


1.10
log
@tweak flushing of unwritten bytes on http mode changes
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.9 2007/02/26 12:11:19 reyk Exp $	*/
d89 1
d108 2
d857 90
d1046 3
d1165 5
d1177 1
d2072 11
@


1.9
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.8 2007/02/26 12:09:21 reyk Exp $	*/
d1086 1
a1086 1
		relay_bufferevent_write_buffer(cre->dst, src);
@


1.8
log
@improve the relay bufferevent handler if one side closed the connection
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.7 2007/02/26 11:59:48 reyk Exp $	*/
d1964 2
a1965 2
relay_bufferevent_write_buffer(struct ctl_relay_event *cre, struct
    evbuffer *buf)
@


1.7
log
@re-use the retry value from table host entries for inbound relay
connections. the relay will retry to connect to the hosts for the
specified number of times. this sounds bad, but is a useful
"workaround" for unreliable backend servers...
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.6 2007/02/26 11:24:26 reyk Exp $	*/
d863 1
a863 1
	int			 done = 0, header = 0;
d876 1
a876 1
	while (!done && (line = evbuffer_readline(src)) != NULL) {
d882 1
a882 1
			done = 1;
d1008 1
a1008 1
	if (done) {
d1075 1
a1097 1
	struct evbuffer *src = EVBUFFER_OUTPUT(bev);
a1103 7
#if 0
	if (error & EVBUFFER_EOF) {
		bufferevent_disable(bev, EV_READ|EV_WRITE);
		relay_close(con, "done");
		return;
	}
#endif
d1110 1
a1110 2
			if (EVBUFFER_LENGTH(dst)) {
				bufferevent_write_buffer(cre->dst->bev, src);
a1111 1
			}
@


1.6
log
@fix small memleaks
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.5 2007/02/25 18:16:16 deraadt Exp $	*/
d1300 1
d1372 1
d1375 8
@


1.5
log
@one example (of two) of tree breaking the "other gcc"
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.4 2007/02/24 15:48:54 reyk Exp $	*/
d949 1
d1412 2
@


1.4
log
@disable SSLv2 and use "HIGH" crypto cipher suites by default.

suggested by dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.3 2007/02/24 00:22:32 reyk Exp $	*/
d906 1
a906 1
			*pk.value++;
@


1.3
log
@- allow to specify the SSL cipher suite and the SSL protocols
  (as required by the PCI DSS)
- increase the default listen backlog to 10, allow to modify the
  backlog as a per-protocol tcp option to improve the performance
  on busy systems (to get less connection failures on heavy load)
- close the connection if SSL_accept returned an error
- instead of logging _new_ relay sessions to syslog, log the
  sessions in relay_close() after they have been _finished_.
  this will allow to collect some additional information
- add a new log keyword to log specified header/url entities (useful
  to track "bad guys" using many session ids or multiple user agents)
- some minor fixes, manpage bits, and bump the copyright (by some
  reason, i didn't realize that we already have 2007...).
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.2 2007/02/22 23:07:38 reyk Exp $	*/
d1592 1
a1592 1
	char certfile[PATH_MAX], hbuf[128];
d1622 4
a1625 6
	if (proto->sslciphers != NULL) {
		log_debug("relay_ssl_ctx_create: ciphers '%s'",
		    proto->sslciphers);
		if (!SSL_CTX_set_cipher_list(ctx, proto->sslciphers))
			goto err;
	}
@


1.2
log
@read the exact length for POST requests as specified by the
content-length header.
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.1 2007/02/22 03:32:40 reyk Exp $	*/
d4 1
a4 1
 * Copyright (c) 2006 Reyk Floeter <reyk@@openbsd.org>
d289 12
d315 1
a315 2
			fprintf(stderr, "%sexpect \"%s\" from \"%s\"",
			    pn->header ? "" : "url ",
d319 1
a319 2
			fprintf(stderr, "%sfilter \"%s\" from \"%s\"",
			    pn->header ? "" : "url ",
d323 4
a326 3
			fprintf(stderr, "%shash \"%s\"",
			    pn->header ? "" : "url ",
			    pn->key);
d329 1
a329 3
			fprintf(stderr, "%snone \"%s\"",
			    pn->header ? "" : "url ",
			    pn->key);
d582 1
a582 1
	if (listen(s, 5) == -1)
a599 1
	char			 ibuf[128], obuf[128];
a608 8
	if (env->opts & HOSTSTATED_OPT_LOGUPDATE) {
		relay_host(&con->in.ss, ibuf, sizeof(ibuf));
		relay_host(&con->out.ss, obuf, sizeof(obuf));
		log_info("relay %s, session %d (%d active), %s -> %s:%d",
		    rlay->name, con->id, relay_sessions,
		    ibuf, obuf, ntohs(con->out.port));
	}

d680 1
a680 1
		relay_close(con, "last write, done");
d700 1
a700 1
	relay_close(con, "last read, done");
a756 3
	if (pn->header != header)
		return (0);

d759 1
a759 1
		if (!header || (pn->mark && cre->marked == 0))
d762 3
a764 2
		if (pn->macro && (ptr = relay_expand_http(cre,
		    pn->value, buf, sizeof(buf))) == NULL)
d778 1
a778 1
		if (!header || (pn->mark && cre->marked == 0))
d787 1
a787 1
			if (pn->mark)
d797 1
a797 1
			if (pn->mark)
d803 1
a803 1
		if (pn->mark && !cre->marked)
d809 6
d818 3
a820 1

d850 1
a850 1
	relay_close(con, "last http content read, done");
d874 2
d958 1
a958 1
		if (pn->getvars) {
d973 1
d978 1
a978 1
				    strlen(pkv.value) < 1) {
a979 1
				}
d1017 2
a1018 1
				if (pn->mark && cre->marked == 0)
d1020 3
a1022 2
				if (pn->macro && (ptr = relay_expand_http(cre,
				    pn->value, buf, sizeof(buf))) == NULL)
d1032 1
a1032 1
				if (pn->mark)
d1036 1
a1036 1
				relay_close(con, "incomplete header, done");
d1039 1
a1039 1
				if (pn->mark)
d1043 1
a1043 1
				relay_close(con, "rejecting header, done");
d1075 1
a1075 1
		if (proto->lateconnect && cre->bev == NULL &&
d1088 1
a1088 1
	relay_close(con, "last http read, done");
d1187 7
d1376 1
d1390 1
d1400 13
d1441 3
a1451 6
#ifdef DEBUG
	log_info("relay %s, session %d closed: %s", rlay->name, con->id, msg);
#else
	log_debug("relay %s, session %d closed: %s", rlay->name, con->id, msg);
#endif

d1590 1
d1600 1
a1600 1
	if (rlay->proto->cache < -1) {
d1602 1
a1602 1
	} else if (rlay->proto->cache >= -1) {
d1604 2
a1605 2
		if (rlay->proto->cache >= 0)
			SSL_CTX_sess_set_cache_size(ctx, rlay->proto->cache);
d1608 1
a1608 1
	/* Enable all workarounds */
d1610 18
d1720 7
d1729 1
d1734 8
a1741 2
	DPRINTF("relay_ssl_accept: session %d: connection established",
	    con->id);
d1981 2
a1982 1
	return (strcasecmp(a->key, b->key));
@


1.1
log
@Add layer 7 functionality to hoststated used for layer 7
loadbalancing, SSL acceleration, general-purpose TCP relaying, and
transparent proxying.

see hoststated.conf(5) and my upcoming article on undeadly.org for
details.

ok to commit deraadt@@ pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a932 5
			 */
			cre->toread = strtonum(pk.value, 1, INT_MAX, &errstr);

			/*
			 * \r\n between header and body.
d937 1
a937 1
			cre->toread += 2;
@

