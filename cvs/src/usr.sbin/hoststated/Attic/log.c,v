head	1.11;
access;
symbols
	OPENBSD_4_2:1.5.0.2
	OPENBSD_4_2_BASE:1.5
	OPENBSD_4_1:1.4.0.2
	OPENBSD_4_1_BASE:1.4;
locks; strict;
comment	@ * @;


1.11
date	2007.12.07.17.27.07;	author deraadt;	state dead;
branches;
next	1.10;

1.10
date	2007.11.24.17.07.28;	author reyk;	state Exp;
branches;
next	1.9;

1.9
date	2007.11.20.15.54.55;	author reyk;	state Exp;
branches;
next	1.8;

1.8
date	2007.11.04.22.09.02;	author reyk;	state Exp;
branches;
next	1.7;

1.7
date	2007.09.07.07.52.14;	author reyk;	state Exp;
branches;
next	1.6;

1.6
date	2007.09.06.19.55.45;	author reyk;	state Exp;
branches;
next	1.5;

1.5
date	2007.05.29.17.12.04;	author reyk;	state Exp;
branches;
next	1.4;

1.4
date	2007.02.22.03.32.39;	author reyk;	state Exp;
branches;
next	1.3;

1.3
date	2007.02.07.15.17.46;	author reyk;	state Exp;
branches;
next	1.2;

1.2
date	2006.12.16.17.48.27;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	2006.12.16.11.45.07;	author reyk;	state Exp;
branches;
next	;


desc
@@


1.11
log
@hoststated/hoststatectl get repository copied (and de-tagged) into
relayd/relayctl.  This is a more suitable place for a daemon that has
grown out of it's initial roots of "monitoring and redirecting services
at various layers", into one that is "a full featured proxy, which
happens to know what is up/down"
@
text
@/*	$OpenBSD: log.c,v 1.10 2007/11/24 17:07:28 reyk Exp $	*/

/*
 * Copyright (c) 2003, 2004 Henning Brauer <henning@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER
 * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
 * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/queue.h>
#include <sys/socket.h>
#include <sys/tree.h>

#include <net/if.h>
#include <netinet/in_systm.h>
#include <netinet/in.h>
#include <netinet/ip.h>
#include <arpa/inet.h>

#include <errno.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <syslog.h>
#include <event.h>

#include <openssl/ssl.h>

#include "hoststated.h"

int	 debug;

void	 vlog(int, const char *, va_list);
void	 logit(int, const char *, ...);

void
log_init(int n_debug)
{
	extern char	*__progname;

	debug = n_debug;

	if (!debug)
		openlog(__progname, LOG_PID | LOG_NDELAY, LOG_DAEMON);

	tzset();
}

void
logit(int pri, const char *fmt, ...)
{
	va_list	ap;

	va_start(ap, fmt);
	vlog(pri, fmt, ap);
	va_end(ap);
}

void
vlog(int pri, const char *fmt, va_list ap)
{
	char	*nfmt;

	if (debug) {
		/* best effort in out of mem situations */
		if (asprintf(&nfmt, "%s\n", fmt) == -1) {
			vfprintf(stderr, fmt, ap);
			fprintf(stderr, "\n");
		} else {
			vfprintf(stderr, nfmt, ap);
			free(nfmt);
		}
		fflush(stderr);
	} else
		vsyslog(pri, fmt, ap);
}


void
log_warn(const char *emsg, ...)
{
	char	*nfmt;
	va_list	 ap;

	/* best effort to even work in out of memory situations */
	if (emsg == NULL)
		logit(LOG_CRIT, "%s", strerror(errno));
	else {
		va_start(ap, emsg);

		if (asprintf(&nfmt, "%s: %s", emsg, strerror(errno)) == -1) {
			/* we tried it... */
			vlog(LOG_CRIT, emsg, ap);
			logit(LOG_CRIT, "%s", strerror(errno));
		} else {
			vlog(LOG_CRIT, nfmt, ap);
			free(nfmt);
		}
		va_end(ap);
	}
}

void
log_warnx(const char *emsg, ...)
{
	va_list	 ap;

	va_start(ap, emsg);
	vlog(LOG_CRIT, emsg, ap);
	va_end(ap);
}

void
log_info(const char *emsg, ...)
{
	va_list	 ap;

	va_start(ap, emsg);
	vlog(LOG_INFO, emsg, ap);
	va_end(ap);
}

void
log_debug(const char *emsg, ...)
{
	va_list	 ap;

	if (debug > 1) {
		va_start(ap, emsg);
		vlog(LOG_DEBUG, emsg, ap);
		va_end(ap);
	}
}

void
fatal(const char *emsg)
{
	if (emsg == NULL)
		logit(LOG_CRIT, "fatal: %s", strerror(errno));
	else
		if (errno)
			logit(LOG_CRIT, "fatal: %s: %s",
			    emsg, strerror(errno));
		else
			logit(LOG_CRIT, "fatal: %s", emsg);

	exit(1);
}

void
fatalx(const char *emsg)
{
	errno = 0;
	fatal(emsg);
}

const char *
host_status(enum host_status status)
{
	switch (status) {
	case HOST_DOWN:
		return ("down");
	case HOST_UNKNOWN:
		return ("unknown");
	case HOST_UP:
		return ("up");
	};
	/* NOTREACHED */
	return ("invalid");
}

const char *
table_check(enum table_check check)
{
	switch (check) {
	case CHECK_NOCHECK:
		return ("none");
	case CHECK_ICMP:
		return ("icmp");
	case CHECK_TCP:
		return ("tcp");
	case CHECK_HTTP_CODE:
		return ("http code");
	case CHECK_HTTP_DIGEST:
		return ("http digest");
	case CHECK_SEND_EXPECT:
		return ("send expect");
	case CHECK_SCRIPT:
		return ("script");
	};
	/* NOTREACHED */
	return ("invalid");
}

const char *
print_availability(u_long cnt, u_long up)
{
	static char buf[BUFSIZ];

	if (cnt == 0)
		return ("");
	bzero(buf, sizeof(buf));
	snprintf(buf, sizeof(buf), "%.2f%%", (double)up / cnt * 100);
	return (buf);
}

const char *
print_host(struct sockaddr_storage *ss, char *buf, size_t len)
{
	int af = ss->ss_family;
	void *ptr;

	bzero(buf, len);
	if (af == AF_INET)
		ptr = &((struct sockaddr_in *)ss)->sin_addr;
	else
		ptr = &((struct sockaddr_in6 *)ss)->sin6_addr;
	return (inet_ntop(af, ptr, buf, len));
}

const char *
print_time(struct timeval *a, struct timeval *b, char *buf, size_t len)
{
	struct timeval		tv;
	u_long			h, sec, min;

	timerclear(&tv);
	timersub(a, b, &tv);
	sec = tv.tv_sec % 60;
	min = tv.tv_sec / 60 % 60;
	h = tv.tv_sec / 60 / 60;

	snprintf(buf, len, "%.2lu:%.2lu:%.2lu", h, min, sec);
	return (buf);
}

const char *
print_httperror(u_int code)
{
	u_int			 i;
	struct {
		u_int		 ht_code;
		const char	*ht_err;
	}			 httperr[] = {
		{ 100, "Continue" },
		{ 101, "Switching Protocols" },
		{ 200, "OK" },
		{ 201, "Created" },
		{ 202, "Accepted" },
		{ 203, "Non-Authorative Information" },
		{ 204, "No Content" },
		{ 205, "Reset Content" },
		{ 206, "Partial Content" },
		{ 300, "Multiple Choices" },
		{ 301, "Moved Permanently" },
		{ 302, "Moved Temporarily" },
		{ 303, "See Other" },
		{ 304, "Not Modified" },
		{ 307, "Temporary Redirect" },
		{ 400, "Bad Request" },
		{ 401, "Unauthorized" },
		{ 402, "Payment Required" },
		{ 403, "Forbidden" },
		{ 404, "Not Found" },
		{ 405, "Method Not Allowed" },
		{ 406, "Not Acceptable" },
		{ 407, "Proxy Authentication Required" },
		{ 408, "Request Timeout" },
		{ 409, "Conflict" },
		{ 410, "Gone" },
		{ 411, "Length Required" },
		{ 412, "Precondition Failed" },
		{ 413, "Request Entity Too Large" },
		{ 414, "Request-URL Too Long" },
		{ 415, "Unsupported Media Type" },
		{ 416, "Requested Range Not Satisfiable" },
		{ 417, "Expectation Failed" },
		{ 500, "Internal Server Error" },
		{ 501, "Not Implemented" },
		{ 502, "Bad Gateway" },
		{ 503, "Service Unavailable" },
		{ 504, "Gateway Timeout" },
		{ 505, "HTTP Version Not Supported" },
		{ 0 }
	};

	for (i = 0; httperr[i].ht_code != 0; i++)
		if (httperr[i].ht_code == code)
			return (httperr[i].ht_err);
	return ("Unknown Error");
}
@


1.10
log
@sort includes, adjust to style(9)
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.9 2007/11/20 15:54:55 reyk Exp $	*/
@


1.9
log
@it may be desirable to send a HTTP error page with error code and a
meaningful message if a HTTP/HTTPS relay closes the connection for
some reason. for example, a "403 Forbidden" if the request was
rejected by a filter. this will be enabled with the "return error"
option and is disabled by default, the standard behaviour is to
silently drop the connection; the browser may display an empty page in
this case. the look+feel of the HTTP error page can be customized with
a CSS style sheet, but we do not intend to allow customization of the
error page contents (hoststated is not a webserver!).

ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.8 2007/11/04 22:09:02 reyk Exp $	*/
a19 1
#include <sys/param.h>
d24 1
a27 2
#include <net/if.h>

@


1.8
log
@the last change to enable logging to stderr on startup also enabled
annoying debugging messages on the console by default.  since we do
not want to see debugging messages unless specified by the "-d" flag,
add an extra debugging level "debug > 1" to be checked in log_debug().
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.7 2007/09/07 07:52:14 reyk Exp $	*/
d248 56
@


1.7
log
@add a function to print delays in hours, minutes, and seconds
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.6 2007/09/06 19:55:45 reyk Exp $	*/
d141 1
a141 1
	if (debug) {
@


1.6
log
@rename relay_host to print_host in log.c
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.5 2007/05/29 17:12:04 reyk Exp $	*/
d232 16
@


1.5
log
@add a new check method which allows to run external scripts/programs
for custom evaluations.

pyr agrees to put it in now but to do some improvements of the timeout
handling later.
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.4 2007/02/22 03:32:39 reyk Exp $	*/
d30 2
d218 14
@


1.4
log
@Add layer 7 functionality to hoststated used for layer 7
loadbalancing, SSL acceleration, general-purpose TCP relaying, and
transparent proxying.

see hoststated.conf(5) and my upcoming article on undeadly.org for
details.

ok to commit deraadt@@ pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.3 2007/02/07 15:17:46 reyk Exp $	*/
d199 2
@


1.3
log
@add new "log (updates|all)" configuration option to log state
notifications after completed host checks.  either only log the
"updates" to new states or log "all" state notifications, even if the
state didn't change. the log messages will be reported to syslog or to
stderr if the daemon is running in foreground mode.

ok claudio@@ pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.2 2006/12/16 17:48:27 deraadt Exp $	*/
d23 1
d202 12
@


1.2
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.1 2006/12/16 11:45:07 reyk Exp $	*/
d19 10
d35 3
d39 1
a39 9
/* prototypes */
void		 log_init(int);
void		 vlog(int, const char *, va_list);
void		 log_warn(const char *, ...);
void		 log_warnx(const char *, ...);
void		 log_info(const char *, ...);
void		 log_debug(const char *, ...);
void		 fatal(const char *);
void		 fatalx(const char *);
d43 1
d165 36
@


1.1
log
@Import hostated, the host status daemon.  This daemon will monitor
remote hosts and dynamically alter pf(4) tables and redirection rules
for active server load balancing.  The daemon has been written by
Pierre-Yves Ritschard (pyr at spootnik.org) and was formerly known as
"slbd".

The daemon is fully functional but it still needs some work and
cleanup so we don't link it to the build yet.  Some TODOs are a
partial rewrite of the check_* routines (use libevent whenever we
can), improvement of the manpages, and general knf and cleanup.

ok deraadt@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d27 8
a34 8
void             log_init(int);
void             vlog(int, const char *, va_list);
void             log_warn(const char *, ...);
void             log_warnx(const char *, ...);
void             log_info(const char *, ...);
void             log_debug(const char *, ...);
void             fatal(const char *);
void             fatalx(const char *);
@

