head	1.15;
access;
symbols
	OPENBSD_6_2_BASE:1.15
	OPENBSD_6_1:1.15.0.12
	OPENBSD_6_1_BASE:1.15
	OPENBSD_6_0:1.15.0.8
	OPENBSD_6_0_BASE:1.15
	OPENBSD_5_9:1.15.0.4
	OPENBSD_5_9_BASE:1.15
	OPENBSD_5_8:1.15.0.6
	OPENBSD_5_8_BASE:1.15
	OPENBSD_5_7:1.15.0.2
	OPENBSD_5_7_BASE:1.15
	OPENBSD_5_6:1.13.0.4
	OPENBSD_5_6_BASE:1.13
	OPENBSD_5_5:1.9.0.14
	OPENBSD_5_5_BASE:1.9
	OPENBSD_5_4:1.9.0.10
	OPENBSD_5_4_BASE:1.9
	OPENBSD_5_3:1.9.0.8
	OPENBSD_5_3_BASE:1.9
	OPENBSD_5_2:1.9.0.6
	OPENBSD_5_2_BASE:1.9
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.4
	OPENBSD_5_0:1.9.0.2
	OPENBSD_5_0_BASE:1.9
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4;
locks; strict;
comment	@ * @;


1.15
date	2015.01.16.15.57.06;	author deraadt;	state Exp;
branches;
next	1.14;
commitid	smcy37dFZU9pEOE0;

1.14
date	2014.11.23.13.08.21;	author claudio;	state Exp;
branches;
next	1.13;
commitid	DdOWVLunEwMgizLh;

1.13
date	2014.05.10.11.30.47;	author claudio;	state Exp;
branches;
next	1.12;

1.12
date	2014.04.20.16.49.56;	author claudio;	state Exp;
branches;
next	1.11;

1.11
date	2014.04.19.18.31.33;	author claudio;	state Exp;
branches;
next	1.10;

1.10
date	2014.04.19.18.19.57;	author claudio;	state Exp;
branches;
next	1.9;

1.9
date	2011.05.04.21.00.04;	author claudio;	state Exp;
branches;
next	1.8;

1.8
date	2011.05.02.06.32.56;	author claudio;	state Exp;
branches;
next	1.7;

1.7
date	2011.04.27.19.02.07;	author claudio;	state Exp;
branches;
next	1.6;

1.6
date	2011.04.27.07.25.26;	author claudio;	state Exp;
branches;
next	1.5;

1.5
date	2011.04.05.18.26.19;	author claudio;	state Exp;
branches;
next	1.4;

1.4
date	2011.01.04.13.19.55;	author claudio;	state Exp;
branches;
next	1.3;

1.3
date	2010.09.25.16.20.06;	author sobrado;	state Exp;
branches;
next	1.2;

1.2
date	2010.09.25.14.40.28;	author sobrado;	state Exp;
branches;
next	1.1;

1.1
date	2010.09.24.09.43.19;	author claudio;	state Exp;
branches;
next	;


desc
@@


1.15
log
@move to <limits.h> where possible, annotate <sys/param.h> otherwise
@
text
@/*	$OpenBSD: initiator.c,v 1.14 2014/11/23 13:08:21 claudio Exp $ */

/*
 * Copyright (c) 2009 Claudio Jeker <claudio@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/queue.h>
#include <sys/socket.h>
#include <sys/uio.h>

#include <scsi/iscsi.h>

#include <event.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <limits.h>

#include "iscsid.h"
#include "log.h"

struct initiator *initiator;

struct task_login {
	struct task		 task;
	struct connection	*c;
	u_int16_t		 tsih;
	u_int8_t		 stage;
};

struct task_logout {
	struct task		 task;
	struct connection	*c;
	u_int8_t		 reason;
};

struct kvp	*initiator_login_kvp(struct connection *, u_int8_t);
struct pdu	*initiator_login_build(struct connection *,
		    struct task_login *);
struct pdu	*initiator_text_build(struct task *, struct session *,
		    struct kvp *);

void	initiator_login_cb(struct connection *, void *, struct pdu *);
void	initiator_discovery_cb(struct connection *, void *, struct pdu *);
void	initiator_logout_cb(struct connection *, void *, struct pdu *);


struct session_params		initiator_sess_defaults;
struct connection_params	initiator_conn_defaults;

struct initiator *
initiator_init(void)
{
	if (!(initiator = calloc(1, sizeof(*initiator))))
		fatal("initiator_init");

	initiator->config.isid_base =
	    arc4random_uniform(0xffffff) | ISCSI_ISID_RAND;
	initiator->config.isid_qual = arc4random_uniform(0xffff);
	TAILQ_INIT(&initiator->sessions);

	/* initialize initiator defaults */
	initiator_sess_defaults = iscsi_sess_defaults;
	initiator_conn_defaults = iscsi_conn_defaults;
	initiator_sess_defaults.MaxConnections = ISCSID_DEF_CONNS;
	initiator_conn_defaults.MaxRecvDataSegmentLength = 65536;

	return initiator;
}

void
initiator_cleanup(struct initiator *i)
{
	struct session *s;

	while ((s = TAILQ_FIRST(&i->sessions)) != NULL) {
		TAILQ_REMOVE(&i->sessions, s, entry);
		session_cleanup(s);
	}
	free(initiator);
}

void
initiator_shutdown(struct initiator *i)
{
	struct session *s;

	log_debug("initiator_shutdown: going down");

	TAILQ_FOREACH(s, &initiator->sessions, entry)
		session_shutdown(s);	
}

int
initiator_isdown(struct initiator *i)
{
	struct session *s;
	int inprogres = 0;

	TAILQ_FOREACH(s, &initiator->sessions, entry) {
		if ((s->state & SESS_RUNNING) && !(s->state & SESS_FREE))
			inprogres = 1;
	}
	return !inprogres;
}

struct session *
initiator_t2s(u_int target)
{
	struct session *s;

	TAILQ_FOREACH(s, &initiator->sessions, entry) {
		if (s->target == target)
			return s;
	}
	return NULL;
}

void
initiator_login(struct connection *c)
{
	struct task_login *tl;
	struct pdu *p;

	if (!(tl = calloc(1, sizeof(*tl)))) {
		log_warn("initiator_login");
		conn_fail(c);
		return;
	}
	tl->c = c;
	tl->stage = ISCSI_LOGIN_STG_SECNEG;

	if (!(p = initiator_login_build(c, tl))) {
		log_warn("initiator_login_build failed");
		free(tl);
		conn_fail(c);
		return;
	}

	task_init(&tl->task, c->session, 1, tl, initiator_login_cb, NULL);
	task_pdu_add(&tl->task, p);
	conn_task_issue(c, &tl->task);
}

void
initiator_discovery(struct session *s)
{
	struct task *t;
	struct pdu *p;
	struct kvp kvp[] = {
		{ "SendTargets", "All" },
		{ NULL, NULL }
	};

	if (!(t = calloc(1, sizeof(*t)))) {
		log_warn("initiator_discovery");
		/* XXX sess_fail(c); */
		return;
	}

	if (!(p = initiator_text_build(t, s, kvp))) {
		log_warnx("initiator_text_build failed");
		free(t);
		/* XXX sess_fail(c); */
		return;
	}

	task_init(t, s, 0, t, initiator_discovery_cb, NULL);
	task_pdu_add(t, p);
	session_task_issue(s, t);
}

void
initiator_logout(struct session *s, struct connection *c, u_int8_t reason)
{
	struct task_logout *tl;
	struct pdu *p;
	struct iscsi_pdu_logout_request *loreq;

	if (!(tl = calloc(1, sizeof(*tl)))) {
		log_warn("initiator_logout");
		/* XXX sess_fail */
		return;
	}
	tl->c = c;
	tl->reason = reason;

	if (!(p = pdu_new())) {
		log_warn("initiator_logout");
		/* XXX sess_fail */
		free(tl);
		return;
	}
	if (!(loreq = pdu_gethdr(p))) {
		log_warn("initiator_logout");
		/* XXX sess_fail */
		pdu_free(p);
		free(tl);
		return;
	}

	loreq->opcode = ISCSI_OP_LOGOUT_REQUEST;
	loreq->flags = ISCSI_LOGOUT_F | reason;
	if (reason != ISCSI_LOGOUT_CLOSE_SESS)
		loreq->cid = c->cid;

	task_init(&tl->task, s, 0, tl, initiator_logout_cb, NULL);
	task_pdu_add(&tl->task, p);
	if (c && (c->state & CONN_RUNNING))
		conn_task_issue(c, &tl->task);
	else
		session_logout_issue(s, &tl->task);
}

void
initiator_nop_in_imm(struct connection *c, struct pdu *p)
{
	struct iscsi_pdu_nop_in *nopin;
	struct task *t;

	/* fixup NOP-IN to make it a NOP-OUT */
	nopin = pdu_getbuf(p, NULL, PDU_HEADER);
	nopin->maxcmdsn = 0;
	nopin->opcode = ISCSI_OP_I_NOP | ISCSI_OP_F_IMMEDIATE;

	/* and schedule an immediate task */
	if (!(t = calloc(1, sizeof(*t)))) {
		log_warn("initiator_nop_in_imm");
		pdu_free(p);
		return;
	}

	task_init(t, c->session, 1, NULL, NULL, NULL);
	t->itt = 0xffffffff; /* change ITT because it is just a ping reply */
	task_pdu_add(t, p);
	conn_task_issue(c, t);
}

struct kvp *
initiator_login_kvp(struct connection *c, u_int8_t stage)
{
	struct kvp *kvp;
	size_t nkvp;

	switch (stage) {
	case ISCSI_LOGIN_STG_SECNEG:
		if (!(kvp = calloc(4, sizeof(*kvp))))
			return NULL;
		kvp[0].key = "AuthMethod";
		kvp[0].value = "None";
		kvp[1].key = "InitiatorName";
		kvp[1].value = c->session->config.InitiatorName;

		if (c->session->config.SessionType == SESSION_TYPE_DISCOVERY) {
			kvp[2].key = "SessionType";
			kvp[2].value = "Discovery";
		} else {
			kvp[2].key = "TargetName";
			kvp[2].value = c->session->config.TargetName;
		}
		break;
	case ISCSI_LOGIN_STG_OPNEG:
		if (conn_gen_kvp(c, NULL, &nkvp) == -1)
			return NULL;
		nkvp += 1; /* add slot for terminator */
		if (!(kvp = calloc(nkvp, sizeof(*kvp))))
			return NULL;
		if (conn_gen_kvp(c, kvp, &nkvp) == -1) {
			free(kvp);
			return NULL;
		}
		break;
	default:
		log_warnx("initiator_login_kvp: exit stage left");
		return NULL;
	} 
	return kvp;
}

struct pdu *
initiator_login_build(struct connection *c, struct task_login *tl)
{
	struct pdu *p;
	struct kvp *kvp;
	struct iscsi_pdu_login_request *lreq;
	int n;

	if (!(p = pdu_new()))
		return NULL;
	if (!(lreq = pdu_gethdr(p))) {
		pdu_free(p);
		return NULL;
	}

	lreq->opcode = ISCSI_OP_LOGIN_REQUEST | ISCSI_OP_F_IMMEDIATE;
	if (tl->stage == ISCSI_LOGIN_STG_SECNEG)
		lreq->flags = ISCSI_LOGIN_F_T |
		    ISCSI_LOGIN_F_CSG(ISCSI_LOGIN_STG_SECNEG) |
		    ISCSI_LOGIN_F_NSG(ISCSI_LOGIN_STG_OPNEG);
	else if (tl->stage == ISCSI_LOGIN_STG_OPNEG)
		lreq->flags = ISCSI_LOGIN_F_T |
		    ISCSI_LOGIN_F_CSG(ISCSI_LOGIN_STG_OPNEG) |
		    ISCSI_LOGIN_F_NSG(ISCSI_LOGIN_STG_FULL);

	lreq->isid_base = htonl(tl->c->session->isid_base);
	lreq->isid_qual = htons(tl->c->session->isid_qual);
	lreq->tsih = tl->tsih;
	lreq->cid = htons(tl->c->cid);
	lreq->expstatsn = htonl(tl->c->expstatsn);

	if (!(kvp = initiator_login_kvp(c, tl->stage))) {
		log_warn("initiator_login_kvp failed");
		return NULL;
	}
	if ((n = text_to_pdu(kvp, p)) == -1) {
		free(kvp);
		return NULL;
	}
	free(kvp);

	if (n > 8192) {
		log_warn("initiator_login_build: help, I'm too verbose");
		pdu_free(p);
		return NULL;
	}
	n = htonl(n);
	/* copy 32bit value over ahslen and datalen */
	memcpy(&lreq->ahslen, &n, sizeof(n));

	return p;
}

struct pdu *
initiator_text_build(struct task *t, struct session *s, struct kvp *kvp)
{
	struct pdu *p;
	struct iscsi_pdu_text_request *lreq;
	int n;

	if (!(p = pdu_new()))
		return NULL;
	if (!(lreq = pdu_gethdr(p)))
		return NULL;

	lreq->opcode = ISCSI_OP_TEXT_REQUEST;
	lreq->flags = ISCSI_TEXT_F_F;
	lreq->ttt = 0xffffffff;

	if ((n = text_to_pdu(kvp, p)) == -1)
		return NULL;
	n = htonl(n);
	memcpy(&lreq->ahslen, &n, sizeof(n));

	return p;
}

void
initiator_login_cb(struct connection *c, void *arg, struct pdu *p)
{
	struct task_login *tl = arg;
	struct iscsi_pdu_login_response *lresp;
	u_char *buf = NULL;
	struct kvp *kvp;
	size_t n, size;

	lresp = pdu_getbuf(p, NULL, PDU_HEADER);

	if (ISCSI_PDU_OPCODE(lresp->opcode) != ISCSI_OP_LOGIN_RESPONSE) {
		log_warnx("Unexpected login response type %x",
		    ISCSI_PDU_OPCODE(lresp->opcode));
		conn_fail(c);
		goto done;
	}

	if (lresp->flags & ISCSI_LOGIN_F_C) {
		log_warnx("Incomplete login responses are unsupported");
		conn_fail(c);
		goto done;
	}

	size = lresp->datalen[0] << 16 | lresp->datalen[1] << 8 |
	    lresp->datalen[2];
	buf = pdu_getbuf(p, &n, PDU_DATA);
	if (size > n) {
		log_warnx("Bad login response");
		conn_fail(c);
		goto done;
	}

	if (buf) {
		kvp = pdu_to_text(buf, size);
		if (kvp == NULL) {
			conn_fail(c);
			goto done;
		}

		if (conn_parse_kvp(c, kvp) == -1) {
			free(kvp);
			conn_fail(c);
			goto done;
		}
		free(kvp);
	}

	/* advance FSM if possible */
	if (lresp->flags & ISCSI_LOGIN_F_T)
		tl->stage = ISCSI_LOGIN_F_NSG(lresp->flags);

	switch (tl->stage) {
	case ISCSI_LOGIN_STG_SECNEG:
	case ISCSI_LOGIN_STG_OPNEG:
		/* free no longer used pdu */
		pdu_free(p);
		p = initiator_login_build(c, tl);
		if (p == NULL) {
			conn_fail(c);
			goto done;
		}
		break;
	case ISCSI_LOGIN_STG_FULL:
		conn_fsm(c, CONN_EV_LOGGED_IN);
		conn_task_cleanup(c, &tl->task);
		free(tl);
		goto done;
	default:
		log_warnx("initiator_login_cb: exit stage left");
		conn_fail(c);
		goto done;
	}
	conn_task_cleanup(c, &tl->task);
	/* add new pdu and re-issue the task */
	task_pdu_add(&tl->task, p);
	conn_task_issue(c, &tl->task);
	return;
done:
	if (p)
		pdu_free(p);
}

void
initiator_discovery_cb(struct connection *c, void *arg, struct pdu *p)
{
	struct task *t = arg;
	struct iscsi_pdu_text_response *lresp;
	u_char *buf = NULL;
	struct kvp *kvp, *k;
	size_t n, size;

	lresp = pdu_getbuf(p, NULL, PDU_HEADER);
	switch (ISCSI_PDU_OPCODE(lresp->opcode)) {
	case ISCSI_OP_TEXT_RESPONSE:
		size = lresp->datalen[0] << 16 | lresp->datalen[1] << 8 |
		    lresp->datalen[2];
		if (size == 0) {
			/* empty response */
			session_shutdown(c->session);
			break;
		}
		buf = pdu_getbuf(p, &n, PDU_DATA);
		if (size > n || buf == NULL)
			goto fail;
		kvp = pdu_to_text(buf, size);
		if (kvp == NULL)
			goto fail;
		log_debug("ISCSI_OP_TEXT_RESPONSE");
		for (k = kvp; k->key; k++) {
			log_debug("%s\t=>\t%s", k->key, k->value);
		}
		free(kvp);
		session_shutdown(c->session);
		break;
	default:
		log_debug("initiator_discovery_cb: unexpected message type %x",
		    ISCSI_PDU_OPCODE(lresp->opcode));
fail:
		conn_fail(c);
		pdu_free(p);
		return;
	}
	conn_task_cleanup(c, t);
	free(t);
	pdu_free(p);
}

void
initiator_logout_cb(struct connection *c, void *arg, struct pdu *p)
{
	struct task_logout *tl = arg;
	struct iscsi_pdu_logout_response *loresp;

	loresp = pdu_getbuf(p, NULL, PDU_HEADER);
	log_debug("initiator_logout_cb: "
	    "response %d, Time2Wait %d, Time2Retain %d",
	    loresp->response, ntohs(loresp->time2wait),
	    ntohs(loresp->time2retain));

	switch (loresp->response) {
	case ISCSI_LOGOUT_RESP_SUCCESS:
		if (tl->reason == ISCSI_LOGOUT_CLOSE_SESS) {
			conn_fsm(c, CONN_EV_LOGGED_OUT);
			session_fsm(c->session, SESS_EV_CLOSED, NULL, 0);
		} else {
			conn_fsm(tl->c, CONN_EV_LOGGED_OUT);
			session_fsm(c->session, SESS_EV_CONN_CLOSED, tl->c, 0);
		}
		break;
	case ISCSI_LOGOUT_RESP_UNKN_CID:
		/* connection ID not found, retry will not help */
		log_warnx("%s: logout failed, cid %d unknown, giving up\n",
		    tl->c->session->config.SessionName,
		    tl->c->cid);
		conn_fsm(tl->c, CONN_EV_FREE);
		break;
	case ISCSI_LOGOUT_RESP_NO_SUPPORT:
	case ISCSI_LOGOUT_RESP_ERROR:
	default:
		/* need to retry logout after loresp->time2wait secs */
		conn_fail(tl->c);
		pdu_free(p);
		return;
	}

	conn_task_cleanup(c, &tl->task);
	free(tl);
	pdu_free(p);
}

char *
default_initiator_name(void)
{
	char *s, hostname[HOST_NAME_MAX+1];

	if (gethostname(hostname, sizeof(hostname)))
		strlcpy(hostname, "initiator", sizeof(hostname));
	if ((s = strchr(hostname, '.')))
		*s = '\0';
	if (asprintf(&s, "%s:%s", ISCSID_BASE_NAME, hostname) == -1)
		return ISCSID_BASE_NAME ":initiator";
	return s;
}
@


1.14
log
@Change the error handling a bit to ensure we do not double free the task
by calling conn_task_cleanup() twice (once direct and once via conn_fail()).
The error handling needs some more work but at least this fixes the crash
found by jasper@@
@
text
@d1 1
a1 1
/*	$OpenBSD: initiator.c,v 1.13 2014/05/10 11:30:47 claudio Exp $ */
a18 1
#include <sys/param.h>
d31 1
d545 1
a545 1
	char *s, hostname[MAXHOSTNAMELEN];
@


1.13
log
@Extend the connection and session FSMs so that connection failure is
handled more gracefully. Losing the TCP connection no longer results
in an unrecoverable stop requiring a restart of iscsid.
@
text
@d1 1
a1 1
/*	$OpenBSD: initiator.c,v 1.12 2014/04/20 16:49:56 claudio Exp $ */
d436 2
a449 2
	conn_task_cleanup(c, &tl->task);
	free(tl);
d491 2
d533 2
a534 1
		break;
@


1.12
log
@Fix conn_gen_kvp and its caller to fill the kvp array properly (including
the NULL terminator at the end). Now iscsid does proper LoginOperational
negotiation (which will bump the MaxRecvDataSegmentLength to 64k)
@
text
@d1 1
a1 1
/*	$OpenBSD: initiator.c,v 1.11 2014/04/19 18:31:33 claudio Exp $ */
d506 2
a507 1
	    loresp->response, loresp->time2wait, loresp->time2retain);
d513 1
a513 1
			session_fsm(c->session, SESS_EV_CLOSED, NULL);
d516 1
a516 1
			session_fsm(c->session, SESS_EV_CONN_CLOSED, tl->c);
@


1.11
log
@COnveret the bcopy() to memcpy()
@
text
@d1 1
a1 1
/*	$OpenBSD: initiator.c,v 1.10 2014/04/19 18:19:57 claudio Exp $ */
d279 1
@


1.10
log
@Replace a magic number.
@
text
@d1 1
a1 1
/*	$OpenBSD: initiator.c,v 1.9 2011/05/04 21:00:04 claudio Exp $ */
d341 1
a341 1
	bcopy(&n, &lreq->ahslen, sizeof(n));
d365 1
a365 1
	bcopy(&n, &lreq->ahslen, sizeof(n));
@


1.9
log
@Massive diff to handle logins more correctly. iscsid will now do
better operational parameter negotiation but more is needed.
Tested by todd@@ and myself.
@
text
@d1 1
a1 1
/*	$OpenBSD: initiator.c,v 1.8 2011/05/02 06:32:56 claudio Exp $ */
d79 1
a79 1
	initiator_sess_defaults.MaxConnections = 8;
@


1.8
log
@Rework the logout code and use this to do a proper logout when
exiting.  This works well for idle sessions but still has some
issues on busy session. It seems more task scheduler changes are
needed to make this work.  This also includes some mem-leak fixes
in error pathes found by Igor Zinovik.
go for it dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: initiator.c,v 1.7 2011/04/27 19:02:07 claudio Exp $ */
d38 26
a63 1
struct kvp	*initiator_login_kvp(struct session *);
d75 7
d133 5
a137 6
struct task_login {
	struct task		 task;
	struct connection	*c;
	u_int16_t		 tsih;
	u_int8_t		 stage;
};
d139 7
a145 5
struct task_logout {
	struct task		 task;
	struct connection	*c;
	u_int8_t		 reason;
};
d147 6
a152 2
struct pdu *initiator_login_build(struct task_login *, struct kvp *);
void	initiator_login_cb(struct connection *, void *, struct pdu *);
d154 4
a157 2
void	initiator_discovery_cb(struct connection *, void *, struct pdu *);
struct pdu *initiator_text_build(struct task *, struct session *, struct kvp *);
d159 9
a167 1
void	initiator_logout_cb(struct connection *, void *, struct pdu *);
d169 5
a173 4
struct kvp *
initiator_login_kvp(struct session *s)
{
	struct kvp *kvp;
d175 5
a179 13
	if (!(kvp = calloc(4, sizeof(*kvp))))
		return NULL;
	kvp[0].key = "AuthMethod";
	kvp[0].value = "None";
	kvp[1].key = "InitiatorName";
	kvp[1].value = s->config.InitiatorName;

	if (s->config.SessionType == SESSION_TYPE_DISCOVERY) {
		kvp[2].key = "SessionType";
		kvp[2].value = "Discovery";
	} else {
		kvp[2].key = "TargetName";
		kvp[2].value = s->config.TargetName;
d182 3
a184 1
	return kvp;
d188 1
a188 1
initiator_login(struct connection *c)
d190 1
a190 1
	struct task_login *tl;
d192 1
a192 1
	struct kvp *kvp;
d195 2
a196 2
		log_warn("initiator_login");
		conn_fail(c);
d200 1
a200 1
	tl->stage = ISCSI_LOGIN_STG_SECNEG;
d202 3
a204 2
	if (!(kvp = initiator_login_kvp(c->session))) {
		log_warn("initiator_login_kvp failed");
a205 1
		conn_fail(c);
d208 4
a211 3

	if (!(p = initiator_login_build(tl, kvp))) {
		log_warn("initiator_login_build failed");
a212 2
		free(kvp);
		conn_fail(c);
d216 4
a219 1
	free(kvp);
d221 1
a221 1
	task_init(&tl->task, c->session, 1, tl, initiator_login_cb, NULL);
d223 68
a290 1
	conn_task_issue(c, &tl->task);
d294 1
a294 1
initiator_login_build(struct task_login *tl, struct kvp *kvp)
d297 1
d303 2
a304 1
	if (!(lreq = pdu_gethdr(p)))
d306 1
d311 2
a312 2
		    ISCSI_LOGIN_F_CSG(ISCSI_LOGIN_STG_OPNEG) |
		    ISCSI_LOGIN_F_NSG(ISCSI_LOGIN_STG_FULL);
d324 38
d375 3
d380 1
a380 2
	/* XXX handle packet would be great */
	log_pdu(p, 1);
d382 4
a385 1
		log_debug("Unknown crap");
d388 14
a401 5
	conn_task_cleanup(c, &tl->task);
	conn_fsm(c, CONN_EV_LOGGED_IN);
	free(tl);
	pdu_free(p);
}
d403 6
a408 9
void
initiator_discovery(struct session *s)
{
	struct task *t;
	struct pdu *p;
	struct kvp kvp[] = {
		{ "SendTargets", "All" },
		{ NULL, NULL }
	};
d410 6
a415 4
	if (!(t = calloc(1, sizeof(*t)))) {
		log_warn("initiator_discovery");
		/* XXX conn_fail(c); */
		return;
d418 22
a439 5
	if (!(p = initiator_text_build(t, s, kvp))) {
		log_warnx("initiator_text_build failed");
		free(t);
		/* conn_fail(c); */
		return;
d441 10
a450 4

	task_init(t, s, 0, t, initiator_discovery_cb, NULL);
	task_pdu_add(t, p);
	session_task_issue(s, t);
a496 42
initiator_logout(struct session *s, struct connection *c, u_int8_t reason)
{
	struct task_logout *tl;
	struct pdu *p;
	struct iscsi_pdu_logout_request *loreq;

	if (!(tl = calloc(1, sizeof(*tl)))) {
		log_warn("initiator_logout");
		/* XXX sess_fail */
		return;
	}
	tl->c = c;
	tl->reason = reason;

	if (!(p = pdu_new())) {
		log_warn("initiator_logout");
		/* XXX sess_fail */
		free(tl);
		return;
	}
	if (!(loreq = pdu_gethdr(p))) {
		log_warn("initiator_logout");
		/* XXX sess_fail */
		pdu_free(p);
		free(tl);
		return;
	}

	loreq->opcode = ISCSI_OP_LOGOUT_REQUEST;
	loreq->flags = ISCSI_LOGOUT_F | reason;
	if (reason != ISCSI_LOGOUT_CLOSE_SESS)
		loreq->cid = c->cid;

	task_init(&tl->task, s, 0, tl, initiator_logout_cb, NULL);
	task_pdu_add(&tl->task, p);
	if (c && (c->state & CONN_RUNNING))
		conn_task_issue(c, &tl->task);
	else
		session_logout_issue(s, &tl->task);
}

void
a534 48
}

void
initiator_nop_in_imm(struct connection *c, struct pdu *p)
{
	struct iscsi_pdu_nop_in *nopin;
	struct task *t;

	/* fixup NOP-IN to make it a NOP-OUT */
	nopin = pdu_getbuf(p, NULL, PDU_HEADER);
	nopin->maxcmdsn = 0;
	nopin->opcode = ISCSI_OP_I_NOP | ISCSI_OP_F_IMMEDIATE;

	/* and schedule an immediate task */
	if (!(t = calloc(1, sizeof(*t)))) {
		log_warn("initiator_nop_in_imm");
		pdu_free(p);
		return;
	}

	task_init(t, c->session, 1, NULL, NULL, NULL);
	t->itt = 0xffffffff; /* change ITT because it is just a ping reply */
	task_pdu_add(t, p);
	conn_task_issue(c, t);
}

struct pdu *
initiator_text_build(struct task *t, struct session *s, struct kvp *kvp)
{
	struct pdu *p;
	struct iscsi_pdu_text_request *lreq;
	int n;

	if (!(p = pdu_new()))
		return NULL;
	if (!(lreq = pdu_gethdr(p)))
		return NULL;

	lreq->opcode = ISCSI_OP_TEXT_REQUEST;
	lreq->flags = ISCSI_TEXT_F_F;
	lreq->ttt = 0xffffffff;

	if ((n = text_to_pdu(kvp, p)) == -1)
		return NULL;
	n = htonl(n);
	bcopy(&n, &lreq->ahslen, sizeof(n));

	return p;
@


1.7
log
@Rename task_cleanup() to conn_task_cleanup() seems a better place for
this function since it does connections scheduling.
@
text
@d1 1
a1 1
/*	$OpenBSD: initiator.c,v 1.6 2011/04/27 07:25:26 claudio Exp $ */
d50 1
a50 1
	return (initiator);
d65 24
d232 1
a232 1
	conn_loggedin(c);
d281 1
a281 1
			conn_logout(c);
d295 1
a295 1
		conn_logout(c);
d309 1
a309 1
initiator_logout(struct connection *c, u_int8_t reason, int onconn)
d317 1
a317 1
		conn_fail(c);
d325 2
a326 1
		conn_fail(c);
d331 3
a333 1
		conn_fail(c);
d339 1
a339 1
	if (reason != 0)
d342 1
a342 1
	task_init(&tl->task, c->session, 0, tl, initiator_logout_cb, NULL);
d344 1
a344 1
	if (onconn)
d347 1
a347 1
		session_task_issue(c->session, &tl->task);
a355 1
	c = tl->c;
d358 1
a358 1
	    "reason %d, Time2Wait %d, Time2Retain %d",
d363 7
a369 1
		conn_fsm(tl->c, CONN_EV_LOGGED_OUT);
d376 1
@


1.6
log
@Start implementing the FSM. Introduce a session FSM that is run via a
callback and implement some of the connection FSM actions. Implement
logouts so that discovery sessions do a nice login -> query -> logout.
Fix the task scheduling especially for immediate and connection specific
tasks. The session will now only schedule tasks to a session that is
in LOGGED_IN state.
looks good dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: initiator.c,v 1.5 2011/04/05 18:26:19 claudio Exp $ */
d207 1
a207 1
	task_cleanup(&tl->task, c);
d279 1
a279 1
	task_cleanup(t, c);
d353 1
a353 1
	task_cleanup(&tl->task, c);
@


1.5
log
@Move session related code into session.c.
@
text
@d1 1
a1 1
/*	$OpenBSD: initiator.c,v 1.4 2011/01/04 13:19:55 claudio Exp $ */
d60 1
a60 1
		session_close(s);
d84 6
d96 2
d137 1
a137 1
		log_warnx("initiator_login_kvp failed");
d144 1
a144 1
		log_warnx("initiator_login_build failed");
d146 1
d153 1
a153 1
	task_init(&tl->task, c->session, 1, tl, initiator_login_cb);
d155 1
a155 2
	/* XXX this is wrong, login needs to run on a specific connection */
	session_task_issue(c->session, &tl->task);
d225 1
d232 1
d236 1
a236 1
	task_init(t, s, 0, t, initiator_discovery_cb);
a240 24
struct pdu *
initiator_text_build(struct task *t, struct session *s, struct kvp *kvp)
{
	struct pdu *p;
	struct iscsi_pdu_text_request *lreq;
	int n;

	if (!(p = pdu_new()))
		return NULL;
	if (!(lreq = pdu_gethdr(p)))
		return NULL;

	lreq->opcode = ISCSI_OP_TEXT_REQUEST;
	lreq->flags = ISCSI_TEXT_F_F;
	lreq->ttt = 0xffffffff;

	if ((n = text_to_pdu(kvp, p)) == -1)
		return NULL;
	n = htonl(n);
	bcopy(&n, &lreq->ahslen, sizeof(n));

	return p;
}

d244 1
a252 3
		buf = pdu_getbuf(p, &n, PDU_DATA);
		if (buf == NULL)
			goto fail;
d255 7
a261 1
		if (size > n)
d271 1
a271 2
		free(arg);
		conn_close(c);
d274 2
d279 76
d376 1
a376 1
	task_init(t, c->session, 1, NULL, NULL);
d380 24
@


1.4
log
@Implememnt NOP-IN -> NOP-OUT handling. If the NOP-In was issued by the
target (itt = 0xffffffff) send back an immediate NOP-Out reusing the
NOP-In PDU. This makes my iscsi target happy.
Also plug a mem leak on error path which was found by Igor Zinovik.
@
text
@d1 1
a1 1
/*	$OpenBSD: initiator.c,v 1.3 2010/09/25 16:20:06 sobrado Exp $ */
a38 1
char		*default_initiator_name(void);
a74 106
}

struct session *
session_find(struct initiator *i, char *name)
{
	struct session *s;

	TAILQ_FOREACH(s, &initiator->sessions, entry) {
		if (strcmp(s->config.SessionName, name) == 0)
			return s;
	}
	return NULL;
}

struct session *
session_new(struct initiator *i, u_int8_t st)
{
	struct session *s;

	if (!(s = calloc(1, sizeof(*s))))
		return NULL;

	/* use the same qualifier unless there is a conflict */
	s->isid_base = i->config.isid_base;
	s->isid_qual = i->config.isid_qual;
	s->cmdseqnum = arc4random();
	s->itt = arc4random();
	s->initiator = i;
	s->state = SESS_FREE;

	if (st == SESSION_TYPE_DISCOVERY)
		s->target = 0;
	else
		s->target = s->initiator->target++;

	TAILQ_INSERT_HEAD(&i->sessions, s, entry);
	TAILQ_INIT(&s->connections);
	TAILQ_INIT(&s->tasks);

	return s;
}

void
session_close(struct session *s)
{
	struct connection *c;

	while ((c = TAILQ_FIRST(&s->connections)) != NULL)
		conn_free(c);

	free(s->config.TargetName);
	free(s->config.InitiatorName);
	free(s);
}

void
session_config(struct session *s, struct session_config *sc)
{
	if (s->config.TargetName)
		free(s->config.TargetName);
	s->config.TargetName = NULL;
	if (s->config.InitiatorName)
		free(s->config.InitiatorName);
	s->config.InitiatorName = NULL;

	s->config = *sc;

	if (sc->TargetName) {
		s->config.TargetName = strdup(sc->TargetName);
		if (s->config.TargetName == NULL)
			fatal("strdup");
	}
	if (sc->InitiatorName) {
		s->config.InitiatorName = strdup(sc->InitiatorName);
		if (s->config.InitiatorName == NULL)
			fatal("strdup");
	} else
		s->config.InitiatorName = default_initiator_name();
}

void
session_task_issue(struct session *s, struct task *t)
{
	TAILQ_INSERT_TAIL(&s->tasks, t, entry);
	session_schedule(s);
}

void
session_schedule(struct session *s)
{
	struct task *t = TAILQ_FIRST(&s->tasks);
	struct connection *c;

	if (!t)
		return;

	/* XXX IMMEDIATE TASK NEED SPECIAL HANDLING !!!! */

	/* wake up a idle connection or a not busy one */
	/* XXX this needs more work as it makes the daemon go wrooOOOMM */
	TAILQ_REMOVE(&s->tasks, t, entry);
	TAILQ_FOREACH(c, &s->connections, entry)
		if (conn_task_issue(c, t))
			return;
	/* all connections are busy readd task to the head */
	TAILQ_INSERT_HEAD(&s->tasks, t, entry);
@


1.3
log
@spacing, no binary changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: initiator.c,v 1.2 2010/09/25 14:40:28 sobrado Exp $ */
d329 1
d396 24
@


1.2
log
@fix typos in documentation and log_debug() function.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: initiator.c,v 1.1 2010/09/24 09:43:19 claudio Exp $ */
d9 1
a9 1
 * 
d97 1
a97 1
	
@


1.1
log
@iSCSI Initiatior daemon using vscsi(4).
Currently implements the absolute minimum of the protocol to make
it work against targets. Many things still in flux but we're annoyed
to work outside of the tree.  Commited from a source tree on an iSCSI
disk served via iscsid but it is not yet production ready.
OK dlg@@, matthew@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d303 1
a303 1
		log_debug("Unkown crap");
@

