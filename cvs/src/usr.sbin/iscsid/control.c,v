head	1.10;
access;
symbols
	OPENBSD_6_0:1.9.0.2
	OPENBSD_6_0_BASE:1.9
	OPENBSD_5_9:1.8.0.6
	OPENBSD_5_9_BASE:1.8
	OPENBSD_5_8:1.8.0.8
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.8.0.2
	OPENBSD_5_7_BASE:1.8
	OPENBSD_5_6:1.8.0.4
	OPENBSD_5_6_BASE:1.8
	OPENBSD_5_5:1.4.0.6
	OPENBSD_5_5_BASE:1.4
	OPENBSD_5_4:1.4.0.2
	OPENBSD_5_4_BASE:1.4
	OPENBSD_5_3:1.3.0.4
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.3.0.2
	OPENBSD_5_2_BASE:1.3
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.6
	OPENBSD_5_0:1.2.0.4
	OPENBSD_5_0_BASE:1.2
	OPENBSD_4_9:1.2.0.2
	OPENBSD_4_9_BASE:1.2;
locks; strict;
comment	@ * @;


1.10
date	2016.09.10.05.42.12;	author jsg;	state Exp;
branches;
next	1.9;
commitid	VrQHE4VnwlBrv5Hk;

1.9
date	2016.04.05.00.52.35;	author yasuoka;	state Exp;
branches;
next	1.8;
commitid	fLh7zjaVNAfVCqBD;

1.8
date	2014.04.21.17.41.52;	author claudio;	state Exp;
branches;
next	1.7;

1.7
date	2014.04.20.18.17.12;	author claudio;	state Exp;
branches;
next	1.6;

1.6
date	2014.04.19.18.31.33;	author claudio;	state Exp;
branches;
next	1.5;

1.5
date	2014.04.07.19.55.46;	author claudio;	state Exp;
branches;
next	1.4;

1.4
date	2013.03.11.17.40.11;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2012.04.11.08.16.37;	author claudio;	state Exp;
branches;
next	1.2;

1.2
date	2010.09.24.10.32.57;	author claudio;	state Exp;
branches;
next	1.1;

1.1
date	2010.09.24.09.43.19;	author claudio;	state Exp;
branches;
next	;


desc
@@


1.10
log
@fix an fd leak in an error path
@
text
@/*	$OpenBSD: control.c,v 1.9 2016/04/05 00:52:35 yasuoka Exp $ */

/*
 * Copyright (c) 2010 Claudio Jeker <claudio@@openbsd.org>
 * Copyright (c) 2003, 2004 Henning Brauer <henning@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/queue.h>
#include <sys/stat.h>
#include <sys/socket.h>
#include <sys/uio.h>
#include <sys/un.h>
#include <errno.h>
#include <event.h>
#include <fcntl.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "iscsid.h"
#include "log.h"

struct control {
	struct event		ev;
	struct pduq		channel;
	int			fd;
};

struct control_state {
	struct event		ev;
	struct event		evt;
	int			fd;
} *control_state;

#define	CONTROL_BACKLOG	5

void	control_accept(int, short, void *);
void	control_close(struct control *);
void	control_dispatch(int, short, void *);
struct pdu *control_getpdu(char *, size_t);

int
control_init(char *path)
{
	struct sockaddr_un	 sun;
	int			 fd;
	mode_t			 old_umask;

	if ((control_state = calloc(1, sizeof(*control_state))) == NULL) {
		log_warn("control_init: calloc");
		return -1;
	}

	if ((fd = socket(AF_UNIX, SOCK_SEQPACKET, 0)) == -1) {
		log_warn("control_init: socket");
		return -1;
	}

	bzero(&sun, sizeof(sun));
	sun.sun_family = AF_UNIX;
	if (strlcpy(sun.sun_path, path, sizeof(sun.sun_path)) >=
	    sizeof(sun.sun_path)) {
		log_warnx("control_init: path %s too long", path);
		close(fd);
		return -1;
	}

	if (unlink(path) == -1)
		if (errno != ENOENT) {
			log_warn("control_init: unlink %s", path);
			close(fd);
			return -1;
		}

	old_umask = umask(S_IXUSR|S_IXGRP|S_IWOTH|S_IROTH|S_IXOTH);
	if (bind(fd, (struct sockaddr *)&sun, sizeof(sun)) == -1) {
		log_warn("control_init: bind: %s", path);
		close(fd);
		umask(old_umask);
		return -1;
	}
	umask(old_umask);

	if (chmod(path, S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP) == -1) {
		log_warn("control_init: chmod");
		close(fd);
		(void)unlink(path);
		return -1;
	}

	if (listen(fd, CONTROL_BACKLOG) == -1) {
		log_warn("control_init: listen");
		close(fd);
		(void)unlink(path);
		return -1;
	}

	socket_setblockmode(fd, 1);
	control_state->fd = fd;

	return 0;
}

void
control_cleanup(char *path)
{
	if (path)
		unlink(path);

	event_del(&control_state->ev);
	event_del(&control_state->evt);
	close(control_state->fd);
	free(control_state);
}

void
control_event_init(void)
{
	event_set(&control_state->ev, control_state->fd, EV_READ,
	    control_accept, NULL);
	event_add(&control_state->ev, NULL);
	evtimer_set(&control_state->evt, control_accept, NULL);
}

/* ARGSUSED */
void
control_accept(int listenfd, short event, void *bula)
{
	int			 connfd;
	socklen_t		 len;
	struct sockaddr_un	 sun;
	struct control		*c;

	event_add(&control_state->ev, NULL);
	if ((event & EV_TIMEOUT))
		return;

	len = sizeof(sun);
	if ((connfd = accept(listenfd,
	    (struct sockaddr *)&sun, &len)) == -1) {
		/*
		 * Pause accept if we are out of file descriptors, or
		 * libevent will haunt us here too.
		 */
		if (errno == ENFILE || errno == EMFILE) {
			struct timeval evtpause = { 1, 0 };

			event_del(&control_state->ev);
			evtimer_add(&control_state->evt, &evtpause);
		} else if (errno != EWOULDBLOCK && errno != EINTR &&
		    errno != ECONNABORTED)
			log_warn("control_accept");
		return;
	}

	if ((c = malloc(sizeof(struct control))) == NULL) {
		log_warn("control_accept");
		close(connfd);
		return;
	}

	TAILQ_INIT(&c->channel);
	c->fd = connfd;
	event_set(&c->ev, connfd, EV_READ, control_dispatch, c);
	event_add(&c->ev, NULL);
}

void
control_close(struct control *c)
{
	event_del(&c->ev);
	close(c->fd);

	/* Some file descriptors are available again. */
	if (evtimer_pending(&control_state->evt, NULL)) {
		evtimer_del(&control_state->evt);
		event_add(&control_state->ev, NULL);
	}

	pdu_free_queue(&c->channel);
	free(c);
}

static char	cbuf[CONTROL_READ_SIZE];

/* ARGSUSED */
void
control_dispatch(int fd, short event, void *bula)
{
	struct iovec iov[PDU_MAXIOV];
	struct msghdr msg;
	struct control *c = bula;
	struct pdu *pdu;
	ssize_t	 n;
	unsigned int niov = 0;
	short flags = EV_READ;

	if (event & EV_TIMEOUT) {
		log_debug("control connection (fd %d) timed out.", fd);
		control_close(c);
		return;
	}
	if (event & EV_READ) {
		if ((n = recv(fd, cbuf, sizeof(cbuf), 0)) == -1 &&
		    !(errno == EAGAIN || errno == EINTR)) {
			control_close(c);
			return;
		}
		if (n == 0) {
			control_close(c);
			return;
		}
		pdu = control_getpdu(cbuf, n);
		if (!pdu) {
			log_debug("control connection (fd %d) bad msg.", fd);
			control_close(c);
			return;
		}
		iscsid_ctrl_dispatch(c, pdu);
	}
	if (event & EV_WRITE) {
		if ((pdu = TAILQ_FIRST(&c->channel)) != NULL) {
			for (niov = 0; niov < PDU_MAXIOV; niov++) {
				iov[niov].iov_base = pdu->iov[niov].iov_base;
				iov[niov].iov_len = pdu->iov[niov].iov_len;
			}
			bzero(&msg, sizeof(msg));
			msg.msg_iov = iov;
			msg.msg_iovlen = niov;
			if (sendmsg(fd, &msg, 0) == -1) {
				if (errno == EAGAIN || errno == ENOBUFS)
					goto requeue;
				control_close(c);
				return;
			}
			TAILQ_REMOVE(&c->channel, pdu, entry);
		}
	}
requeue:
	if (!TAILQ_EMPTY(&c->channel))
		flags |= EV_WRITE;

	event_del(&c->ev);
	event_set(&c->ev, fd, flags, control_dispatch, c);
	event_add(&c->ev, NULL);
}

struct pdu *
control_getpdu(char *buf, size_t len)
{
	struct pdu *p;
	struct ctrlmsghdr *cmh;
	void *data;
	size_t n;
	int i;

	if (len < sizeof(*cmh))
		return NULL;

	if (!(p = pdu_new()))
		return NULL;

	n = sizeof(*cmh);
	cmh = pdu_alloc(n);
	memcpy(cmh, buf, n);
	buf += n;
	len -= n;

	if (pdu_addbuf(p, cmh, n, 0)) {
		free(cmh);
fail:
		pdu_free(p);
		return NULL;
	}

	for (i = 0; i < 3; i++) {
		n = cmh->len[i];
		if (n == 0)
			continue;
		if (PDU_LEN(n) > len)
			goto fail;
		if (!(data = pdu_alloc(n)))
			goto fail;
		memcpy(data, buf, n);
		if (pdu_addbuf(p, data, n, i + 1)) {
			free(data);
			goto fail;
		}
		buf += PDU_LEN(n);
		len -= PDU_LEN(n);
	}

	return p;
}

void
control_queue(void *ch, struct pdu *pdu)
{
	struct control *c = ch;

	TAILQ_INSERT_TAIL(&c->channel, pdu, entry);

	event_del(&c->ev);
	event_set(&c->ev, c->fd, EV_READ|EV_WRITE, control_dispatch, c);
	event_add(&c->ev, NULL);
}
@


1.9
log
@Remove the iterator for control connections unfinished and unused.

ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.8 2014/04/21 17:41:52 claudio Exp $ */
d77 1
@


1.8
log
@Redo most of the control message handling. Switch it back to use
SOCK_SEQPACKET and provide functions to build the control messages that
can also be used by iscsictl.
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.7 2014/04/20 18:17:12 claudio Exp $ */
a36 1
	TAILQ_ENTRY(control)	entry;
a47 2
TAILQ_HEAD(, control)	controls;

a111 1
	TAILQ_INIT(&controls);
a118 2
	struct control	*c;

a121 4
	while ((c = TAILQ_FIRST(&controls)) != NULL) {
		TAILQ_REMOVE(&controls, c, entry);
		control_close(c);
	}
@


1.7
log
@Use only one style for "return foo;"
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.6 2014/04/19 18:31:33 claudio Exp $ */
d70 1
a70 1
	if ((fd = socket(AF_UNIX, SOCK_STREAM, 0)) == -1) {
a244 2
			TAILQ_REMOVE(&c->channel, pdu, entry);

d252 3
a254 2
			if (sendmsg(fd, &msg, 0) == -1 &&
			    !(errno == EAGAIN || errno == ENOBUFS)) {
d258 1
d261 1
d318 1
a318 1
int
a327 32

	return 0;
}

int
control_compose(void *ch, u_int16_t type, void *buf, size_t len)
{
	struct pdu *pdu;
	struct ctrlmsghdr *cmh;
	void *ptr;

	if (PDU_LEN(len) > CONTROL_READ_SIZE - PDU_LEN(sizeof(*cmh)))
		return -1;
	if ((pdu = pdu_new()) == NULL)
		return -1;
	if ((cmh = pdu_alloc(sizeof(*cmh))) == NULL)
		goto fail;
	bzero(cmh, sizeof(*cmh));
	cmh->type = type;
	cmh->len[0] = len;
	pdu_addbuf(pdu, cmh, sizeof(*cmh), 0);
	if (len > 0) {
		if ((ptr = pdu_alloc(len)) == NULL)
			goto fail;
		memcpy(ptr, buf, len);
		pdu_addbuf(pdu, ptr, len, 1);
	}

	return control_queue(ch, pdu);
fail:
	pdu_free(pdu);
	return -1;
@


1.6
log
@COnveret the bcopy() to memcpy()
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.5 2014/04/07 19:55:46 claudio Exp $ */
d67 1
a67 1
		return (-1);
d72 1
a72 1
		return (-1);
d77 5
a81 1
	strlcpy(sun.sun_path, path, sizeof(sun.sun_path));
d87 1
a87 1
			return (-1);
d95 1
a95 1
		return (-1);
d103 1
a103 1
		return (-1);
d110 1
a110 1
		return (-1);
d117 1
a117 1
	return (0);
@


1.5
log
@To win the startup race on the control socket we need to listen to it as
well only then the connect() call from iscsictl will not fail. Move listen()
into the init function and rename control_listen() to control_event_init()
since it is now only doing that.
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.4 2013/03/11 17:40:11 deraadt Exp $ */
d282 1
a282 1
	bcopy(buf, cmh, n);
d301 1
a301 1
		bcopy(buf, data, n);
d347 1
a347 1
		bcopy(buf, ptr, len);
@


1.4
log
@handle ECONNABORTED errors from accept().  In many code blocks they can be
ignored silently and without aborting, much like EINTR and EWOULDBLOCK are.
ok's from various maintainers of these directories...
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.3 2012/04/11 08:16:37 claudio Exp $ */
d102 7
d134 2
a135 2
int
control_listen(void)
a136 5
	if (listen(control_state->fd, CONTROL_BACKLOG) == -1) {
		log_warn("control_listen: listen");
		return (-1);
	}

a140 2

	return (0);
@


1.3
log
@accept() pacing on the control socket if E*FILE errors are returned.
Based on work by Theo for ospfd and friends. OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.2 2010/09/24 10:32:57 claudio Exp $ */
d168 2
a169 1
		} else if (errno != EWOULDBLOCK && errno != EINTR)
@


1.2
log
@Remvoe some debug messages that are not needed.
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.1 2010/09/24 09:43:19 claudio Exp $ */
d41 6
a103 1
	TAILQ_INIT(&control_state->channel);
d121 4
a124 1
	control_close(control_state);
d135 1
a135 1
	event_set(&control_state->ev, control_state->fd, EV_READ | EV_PERSIST,
d138 1
d152 4
d159 10
a168 1
		if (errno != EWOULDBLOCK && errno != EINTR)
d188 1
d190 7
a196 1
	event_del(&c->ev);
@


1.1
log
@iSCSI Initiatior daemon using vscsi(4).
Currently implements the absolute minimum of the protocol to make
it work against targets. Many things still in flux but we're annoyed
to work outside of the tree.  Commited from a source tree on an iSCSI
disk served via iscsid but it is not yet production ready.
OK dlg@@, matthew@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
a200 1
log_debug("control_dispatch: recv %zd bytes", n);
a219 1
log_debug("control_dispatch: send %d iov", niov);
@

