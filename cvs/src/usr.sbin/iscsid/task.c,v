head	1.10;
access;
symbols
	OPENBSD_6_2_BASE:1.10
	OPENBSD_6_1:1.10.0.14
	OPENBSD_6_1_BASE:1.10
	OPENBSD_6_0:1.10.0.10
	OPENBSD_6_0_BASE:1.10
	OPENBSD_5_9:1.10.0.6
	OPENBSD_5_9_BASE:1.10
	OPENBSD_5_8:1.10.0.8
	OPENBSD_5_8_BASE:1.10
	OPENBSD_5_7:1.10.0.2
	OPENBSD_5_7_BASE:1.10
	OPENBSD_5_6:1.10.0.4
	OPENBSD_5_6_BASE:1.10
	OPENBSD_5_5:1.9.0.14
	OPENBSD_5_5_BASE:1.9
	OPENBSD_5_4:1.9.0.10
	OPENBSD_5_4_BASE:1.9
	OPENBSD_5_3:1.9.0.8
	OPENBSD_5_3_BASE:1.9
	OPENBSD_5_2:1.9.0.6
	OPENBSD_5_2_BASE:1.9
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.4
	OPENBSD_5_0:1.9.0.2
	OPENBSD_5_0_BASE:1.9
	OPENBSD_4_9:1.6.0.2
	OPENBSD_4_9_BASE:1.6;
locks; strict;
comment	@ * @;


1.10
date	2014.05.10.11.28.02;	author claudio;	state Exp;
branches;
next	1.9;

1.9
date	2011.04.28.18.32.01;	author claudio;	state Exp;
branches;
next	1.8;

1.8
date	2011.04.27.19.02.07;	author claudio;	state Exp;
branches;
next	1.7;

1.7
date	2011.04.27.07.25.26;	author claudio;	state Exp;
branches;
next	1.6;

1.6
date	2011.01.06.15.40.04;	author claudio;	state Exp;
branches;
next	1.5;

1.5
date	2011.01.04.13.19.55;	author claudio;	state Exp;
branches;
next	1.4;

1.4
date	2011.01.04.09.53.17;	author claudio;	state Exp;
branches;
next	1.3;

1.3
date	2010.09.25.16.20.06;	author sobrado;	state Exp;
branches;
next	1.2;

1.2
date	2010.09.25.14.40.28;	author sobrado;	state Exp;
branches;
next	1.1;

1.1
date	2010.09.24.09.43.19;	author claudio;	state Exp;
branches;
next	;


desc
@@


1.10
log
@Move the task cleanup from the task fail callback to taskq_cleanup.
This makes the one failure callback a lot simpler.
@
text
@/*	$OpenBSD: task.c,v 1.9 2011/04/28 18:32:01 claudio Exp $ */

/*
 * Copyright (c) 2009 Claudio Jeker <claudio@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
#include <sys/types.h>
#include <sys/queue.h>
#include <sys/socket.h>
#include <sys/uio.h>

#include <scsi/iscsi.h>

#include <errno.h>
#include <event.h>
#include <stdio.h>
#include <stdlib.h>
#include <strings.h>
#include <unistd.h>

#include "iscsid.h"
#include "log.h"

/*
 * Task handling, PDU are attached to tasks and task are scheduled across
 * all connections of a session.
 */

void
task_init(struct task *t, struct session *s, int immediate, void *carg,
    void (*c)(struct connection *, void *, struct pdu *),
    void (*f)(void *))
{
	TAILQ_INIT(&t->sendq);
	TAILQ_INIT(&t->recvq);
	t->callback = c;
	t->failback = f;
	t->callarg = carg;
	/* skip reserved and maybe bad ITT values */
	if (s->itt == 0xffffffff || s->itt == 0)
		s->itt = 1;
	t->itt = s->itt++; /* XXX we could do better here */
	t->cmdseqnum = s->cmdseqnum;
	if (!immediate)
		s->cmdseqnum++;
}

void
taskq_cleanup(struct taskq *tq)
{
	struct task *t;

	while ((t = TAILQ_FIRST(tq))) {
		TAILQ_REMOVE(tq, t, entry);
		if (t->failback)
			t->failback(t->callarg);
		conn_task_cleanup(NULL, t);
		free(t);
	}
}

void
task_pdu_add(struct task *t, struct pdu *p)
{
	struct iscsi_pdu *ipdu;

	/* fixup the pdu by setting the itt and seqnum if needed */
	ipdu = pdu_getbuf(p, NULL, PDU_HEADER);
	ipdu->itt = ntohl(t->itt);
	switch (ISCSI_PDU_OPCODE(ipdu->opcode)) {
	case ISCSI_OP_I_NOP:
	case ISCSI_OP_SCSI_REQUEST:
	case ISCSI_OP_TASK_REQUEST:
	case ISCSI_OP_LOGIN_REQUEST:
	case ISCSI_OP_TEXT_REQUEST:
	case ISCSI_OP_LOGOUT_REQUEST:
		ipdu->cmdsn = ntohl(t->cmdseqnum);
		break;
	}

	TAILQ_INSERT_TAIL(&t->sendq, p, entry);
}

void
task_pdu_cb(struct connection *c, struct pdu *p)
{
	struct task *t;
	struct iscsi_pdu *ipdu;
	u_int32_t itt;

	ipdu = pdu_getbuf(p, NULL, PDU_HEADER);
	switch (ISCSI_PDU_OPCODE(ipdu->opcode)) {
	case ISCSI_OP_T_NOP:
		itt = ntohl(ipdu->itt);
		if (itt == 0xffffffff) {
			/* target issued a ping, must answer back immediately */
			c->expstatsn = ntohl(ipdu->cmdsn) + 1;
			initiator_nop_in_imm(c, p);
			break;
		}
		/* FALLTHROUGH */
	case ISCSI_OP_LOGIN_RESPONSE:
	case ISCSI_OP_TEXT_RESPONSE:
	case ISCSI_OP_LOGOUT_RESPONSE:
	case ISCSI_OP_SCSI_RESPONSE:
	case ISCSI_OP_R2T:
	case ISCSI_OP_DATA_IN:
		itt = ntohl(ipdu->itt);
		c->expstatsn = ntohl(ipdu->cmdsn) + 1;

		/* XXX for now search the task on the connection queue
		   later on this should be moved to a per session RB tree but
		   now I do the quick ugly thing. */
		TAILQ_FOREACH(t, &c->tasks, entry) {
			if (itt == t->itt)
				break;
		}
		if (t)
			t->callback(c, t->callarg, p);
		else {
			log_debug("no task for PDU found");
			log_pdu(p, 1);
			pdu_free(p);
		}
		break;
	default:
		log_warnx("not handled yet. fix me");
		log_pdu(p, 1);
		pdu_free(p);
	}
}
@


1.9
log
@Try to schedule a new task for the connection in conn_task_cleanup()
this removes the session_schedule() in the task_pdu_cb().
@
text
@d1 1
a1 1
/*	$OpenBSD: task.c,v 1.8 2011/04/27 19:02:07 claudio Exp $ */
d68 2
a69 4
		else {
			conn_task_cleanup(NULL, t);
			free(t);
		}
@


1.8
log
@Rename task_cleanup() to conn_task_cleanup() seems a better place for
this function since it does connections scheduling.
@
text
@d1 1
a1 1
/*	$OpenBSD: task.c,v 1.7 2011/04/27 07:25:26 claudio Exp $ */
a143 1
	session_schedule(c->session);
@


1.7
log
@Start implementing the FSM. Introduce a session FSM that is run via a
callback and implement some of the connection FSM actions. Implement
logouts so that discovery sessions do a nice login -> query -> logout.
Fix the task scheduling especially for immediate and connection specific
tasks. The session will now only schedule tasks to a session that is
in LOGGED_IN state.
looks good dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: task.c,v 1.6 2011/01/06 15:40:04 claudio Exp $ */
d69 1
a69 1
			task_cleanup(t, NULL);
a71 14
	}
}

void
task_cleanup(struct task *t, struct connection *c)
{
/* XXX THIS FEELS WRONG FOR NOW */
	pdu_free_queue(&t->sendq);
	pdu_free_queue(&t->recvq);
	/* XXX need some state to know if queued or not */
	if (c) {
		TAILQ_REMOVE(&c->tasks, t, entry);
		if (!TAILQ_EMPTY(&c->tasks))
			conn_task_schedule(c);
@


1.6
log
@Ugly hack, call session_schedule in the task pdu callback handler.
Without this accessing both LU on my iscsi target will lock up
because tasks a queued but no longer scheduled.
We need a better task scheduler but this allows me to run iogen on both
partitions without locking up.
@
text
@d1 1
a1 1
/*	$OpenBSD: task.c,v 1.5 2011/01/04 13:19:55 claudio Exp $ */
d42 2
a43 1
    void (*c)(struct connection *, void *, struct pdu *))
d48 1
d50 3
d60 16
d82 5
a86 1
	TAILQ_REMOVE(&c->tasks, t, entry);
@


1.5
log
@Implememnt NOP-IN -> NOP-OUT handling. If the NOP-In was issued by the
target (itt = 0xffffffff) send back an immediate NOP-Out reusing the
NOP-In PDU. This makes my iscsi target happy.
Also plug a mem leak on error path which was found by Igor Zinovik.
@
text
@d1 1
a1 1
/*	$OpenBSD: task.c,v 1.4 2011/01/04 09:53:17 claudio Exp $ */
d133 1
@


1.4
log
@Log the PDU which failed because no task was found.
Should help identify the messages that are issued by the target (e.g. NOP).
@
text
@d1 1
a1 1
/*	$OpenBSD: task.c,v 1.3 2010/09/25 16:20:06 sobrado Exp $ */
d96 8
@


1.3
log
@spacing, no binary changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: task.c,v 1.2 2010/09/25 14:40:28 sobrado Exp $ */
d116 1
a120 1
log_pdu(p, 1);
d122 1
@


1.2
log
@fix typos in documentation and log_debug() function.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: task.c,v 1.1 2010/09/24 09:43:19 claudio Exp $ */
d9 1
a9 1
 * 
@


1.1
log
@iSCSI Initiatior daemon using vscsi(4).
Currently implements the absolute minimum of the protocol to make
it work against targets. Many things still in flux but we're annoyed
to work outside of the tree.  Commited from a source tree on an iSCSI
disk served via iscsid but it is not yet production ready.
OK dlg@@, matthew@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d36 1
a36 1
 * Task handling, PDU are attached to tasks and task are scheduled accross
@

