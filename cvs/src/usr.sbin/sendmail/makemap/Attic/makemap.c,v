head	1.10;
access;
symbols
	OPENBSD_2_6:1.9.0.4
	OPENBSD_2_6_BASE:1.9
	OPENBSD_2_5:1.9.0.2
	OPENBSD_2_5_BASE:1.9
	OPENBSD_2_4:1.8.0.2
	OPENBSD_2_4_BASE:1.8
	sendmail_8_9_1:1.1.1.2
	UCB:1.1.1
	OPENBSD_2_3:1.7.0.2
	OPENBSD_2_3_BASE:1.7
	OPENBSD_2_2:1.6.0.2
	OPENBSD_2_2_BASE:1.6
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.10
date	2000.04.18.04.57.13;	author millert;	state dead;
branches;
next	1.9;

1.9
date	99.01.01.20.33.31;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	98.07.12.19.44.05;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	97.11.09.04.05.32;	author gene;	state Exp;
branches;
next	1.6;

1.6
date	97.08.04.02.17.44;	author downsj;	state Exp;
branches;
next	1.5;

1.5
date	97.07.15.07.23.54;	author downsj;	state Exp;
branches;
next	1.4;

1.4
date	97.01.15.23.44.19;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	96.12.14.21.16.50;	author downsj;	state Exp;
branches;
next	1.2;

1.2
date	96.01.29.01.43.10;	author dm;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.48.16;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.48.16;	author deraadt;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	98.07.12.17.09.37;	author millert;	state Exp;
branches;
next	;


desc
@@


1.10
log
@remove sendmail 8.9.3
@
text
@/*
 * Copyright (c) 1998 Sendmail, Inc.  All rights reserved.
 * Copyright (c) 1992 Eric P. Allman.  All rights reserved.
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * By using this file, you agree to the terms and conditions set
 * forth in the LICENSE file which can be found at the top level of
 * the sendmail distribution.
 *
 */

#ifndef lint
static char sccsid[] = "@@(#)makemap.c	8.71 (Berkeley) 11/29/1998";
#endif /* not lint */

#include <sys/types.h>
#include <sys/errno.h>
#ifndef ISC_UNIX
# include <sys/file.h>
#endif
#include "sendmail.h"
#include "pathnames.h"

#ifdef NDBM
# include <ndbm.h>
#endif

#ifdef NEWDB
# include <db.h>
# ifndef DB_VERSION_MAJOR
#  define DB_VERSION_MAJOR 1
# endif
#endif

enum type { T_DBM, T_BTREE, T_HASH, T_ERR, T_UNKNOWN };

union dbent
{
#ifdef NDBM
	datum	dbm;
#endif
#ifdef NEWDB
	DBT	db;
#endif
	struct
	{
		char	*data;
		size_t	size;
	} xx;
};

uid_t	RealUid;
gid_t	RealGid;
char	*RealUserName;
uid_t	RunAsUid;
uid_t	RunAsGid;
char	*RunAsUserName;
int	Verbose = 2;
bool	DontInitGroups = FALSE;
long	DontBlameSendmail = DBS_SAFE;
u_char	tTdvect[100];
uid_t	TrustedUid = 0;

#define BUFSIZE		1024

int
main(argc, argv)
	int argc;
	char **argv;
{
	char *progname;
	char *cfile;
	bool inclnull = FALSE;
	bool notrunc = FALSE;
	bool allowreplace = FALSE;
	bool allowdups = FALSE;
	bool verbose = FALSE;
	bool foldcase = TRUE;
	int exitstat;
	int opt;
	char *typename = NULL;
	char *mapname = NULL;
	char *ext = NULL;
	int lineno;
	int st;
	int mode;
	int putflags = 0;
#ifdef NEWDB
	long dbcachesize = 1024 * 1024;
#endif
	enum type type;
#if !O_EXLOCK
	int fd;
#endif
	int sff = SFF_ROOTOK|SFF_REGONLY;
	struct passwd *pw;
	union
	{
#ifdef NDBM
		DBM	*dbm;
#endif
#ifdef NEWDB
		DB	*db;
#endif
		void	*dbx;
	} dbp;
	union dbent key, val;
#ifdef NEWDB
# if DB_VERSION_MAJOR < 2
	BTREEINFO bti;
	HASHINFO hinfo;
# else
	DB_INFO dbinfo;
# endif
#endif
	char ibuf[BUFSIZE];
	char fbuf[MAXNAME];
	char dbuf[MAXNAME];
#ifdef NDBM
	char pbuf[MAXNAME];
#endif
#if _FFR_TRUSTED_USER
	FILE *cfp;
	char buf[MAXLINE];
#endif
	static char rnamebuf[MAXNAME];	/* holds RealUserName */
	struct stat std;
#ifdef NDBM
	struct stat stp;
#endif
	extern char *optarg;
	extern int optind;

	progname = argv[0];
	cfile = _PATH_SENDMAILCF;

	RunAsUid = RealUid = getuid();
	RunAsGid = RealGid = getgid();
	pw = getpwuid(RealUid);
	if (pw != NULL)
	{
		if (strlen(pw->pw_name) > MAXNAME - 1)
			pw->pw_name[MAXNAME] = 0;
		sprintf(rnamebuf, "%s", pw->pw_name);
	}
	else
		sprintf(rnamebuf, "Unknown UID %d", (int) RealUid);
	RunAsUserName = RealUserName = rnamebuf;

#if _FFR_NEW_MAKEMAP_FLAGS
#define OPTIONS		"C:Nc:dflorsv"
#else
#define OPTIONS		"C:Ndforsv"
#endif
	while ((opt = getopt(argc, argv, OPTIONS)) != EOF)
	{
		switch (opt)
		{
		  case 'C':
			cfile = optarg;
			break;

		  case 'N':
			inclnull = TRUE;
			break;

#if _FFR_NEW_MAKEMAP_FLAGS
		  case 'c':
# ifdef NEWDB
			dbcachesize = atol(optarg);
# endif
			break;
#endif

		  case 'd':
			allowdups = TRUE;
			break;

		  case 'f':
			foldcase = FALSE;
			break;

#if _FFR_NEW_MAKEMAP_FLAGS
		  case 'l':
# ifdef NDBM
			printf("dbm\n");
# endif
# ifdef NEWDB
			printf("hash\n");
			printf("btree\n");
# endif
			exit(EX_OK);
			break;
#endif

		  case 'o':
			notrunc = TRUE;
			break;

		  case 'r':
			allowreplace = TRUE;
			break;

		  case 's':
			DontBlameSendmail |= DBS_MAPINUNSAFEDIRPATH|DBS_WRITEMAPTOHARDLINK|DBS_WRITEMAPTOSYMLINK|DBS_LINKEDMAPINWRITABLEDIR;
			break;

		  case 'v':
			verbose = TRUE;
			break;

		  default:
			type = T_ERR;
			break;
		}
	}

	if (!bitset(DBS_WRITEMAPTOSYMLINK, DontBlameSendmail))
		sff |= SFF_NOSLINK;
        if (!bitset(DBS_WRITEMAPTOHARDLINK, DontBlameSendmail))
		sff |= SFF_NOHLINK;
	if (!bitset(DBS_LINKEDMAPINWRITABLEDIR, DontBlameSendmail))
		sff |= SFF_NOWLINK;

	argc -= optind;
	argv += optind;
	if (argc != 2)
		type = T_ERR;
	else
	{
		typename = argv[0];
		mapname = argv[1];
		ext = NULL;

		if (strcmp(typename, "dbm") == 0)
		{
			type = T_DBM;
		}
		else if (strcmp(typename, "btree") == 0)
		{
			type = T_BTREE;
			ext = ".db";
		}
		else if (strcmp(typename, "hash") == 0)
		{
			type = T_HASH;
			ext = ".db";
		}
		else
			type = T_UNKNOWN;
	}

#if _FFR_TRUSTED_USER
	if ((cfp = fopen(cfile, "r")) == NULL)
	{
		fprintf(stderr, "mailstats: ");
		perror(cfile);
		exit(EX_NOINPUT);
	}
	while (fgets(buf, sizeof(buf), cfp) != NULL)
	{
		register char *b;

		if ((b = strchr(buf, '\n')) != NULL)
			*b = '\0';

		b = buf;
		switch (*b++)
		{
		  case 'O':		/* option */
			if (strncasecmp(b, " TrustedUser", 12) == 0 &&
			    !(isascii(b[12]) && isalnum(b[12])))
			{
				b = strchr(b, '=');
				if (b == NULL)
					continue;
				while (isascii(*++b) && isspace(*b))
					continue;
				if (isascii(*b) && isdigit(*b))
					TrustedUid = atoi(b);
				else
				{
					register struct passwd *pw;
					
					TrustedUid = 0;
					pw = getpwnam(b);
					if (pw == NULL)
						fprintf(stderr,
							"TrustedUser: unknown user %s\n", b);
					else
						TrustedUid = pw->pw_uid;
				}
				
# ifdef UID_MAX
				if (TrustedUid > UID_MAX)
				{
					syserr("TrustedUser: uid value (%ld) > UID_MAX (%ld)",
					       TrustedUid, UID_MAX);
					TrustedUid = 0;
				}
# endif
				break;
			}


		  default:
			continue;
		}
	}
	(void) fclose(cfp);
#endif
	switch (type)
	{
	  case T_ERR:
#if _FFR_NEW_MAKEMAP_FLAGS
		fprintf(stderr,
			"Usage: %s [-N] [-c cachesize] [-d] [-f] [-l] [-o] [-r] [-s] [-v] type mapname\n",
			progname);
#else
		fprintf(stderr, "Usage: %s [-N] [-d] [-f] [-o] [-r] [-s] [-v] type mapname\n", progname);
#endif
		exit(EX_USAGE);

	  case T_UNKNOWN:
		fprintf(stderr, "%s: Unknown database type %s\n",
			progname, typename);
		exit(EX_USAGE);

#ifndef NDBM
	  case T_DBM:
#endif
#ifndef NEWDB
	  case T_BTREE:
	  case T_HASH:
#endif
		fprintf(stderr, "%s: Type %s not supported in this version\n",
			progname, typename);
		exit(EX_UNAVAILABLE);

#ifdef NEWDB
	  case T_BTREE:
# if DB_VERSION_MAJOR < 2
		bzero(&bti, sizeof bti);
# else
		bzero(&dbinfo, sizeof dbinfo);
# endif
		if (allowdups)
		{
# if DB_VERSION_MAJOR < 2
			bti.flags |= R_DUP;
# else
			dbinfo.flags |= DB_DUP;
# endif
		}
		if (allowdups || allowreplace)
			putflags = 0;
		else
		{
# if DB_VERSION_MAJOR < 2
			putflags = R_NOOVERWRITE;
# else
			putflags = DB_NOOVERWRITE;
# endif
		}
		break;

	  case T_HASH:
# if DB_VERSION_MAJOR < 2
		bzero(&hinfo, sizeof hinfo);
# else
		bzero(&dbinfo, sizeof dbinfo);
# endif
		if (allowreplace)
			putflags = 0;
		else
		{
# if DB_VERSION_MAJOR < 2
			putflags = R_NOOVERWRITE;
# else
			putflags = DB_NOOVERWRITE;
# endif
		}
		break;
#endif
#ifdef NDBM
	  case T_DBM:
		if (allowdups)
		{
			fprintf(stderr, "%s: Type %s does not support -d (allow dups)\n",
				progname, typename);
			exit(EX_UNAVAILABLE);
		}
		if (allowreplace)
			putflags = DBM_REPLACE;
		else
			putflags = DBM_INSERT;
		break;
#endif
	}

	/*
	**  Adjust file names.
	*/

	if (ext != NULL)
	{
		int el, fl;

		el = strlen(ext);
		fl = strlen(mapname);
		if (el + fl + 1 >= sizeof fbuf)
		{
			fprintf(stderr, "%s: file name too long", mapname);
			exit(EX_USAGE);
		}
		if (fl < el || strcmp(&mapname[fl - el], ext) != 0)
		{
			strcpy(fbuf, mapname);
			strcat(fbuf, ext);
			mapname = fbuf;
		}
	}

	if (!notrunc)
		sff |= SFF_CREAT;
	switch (type)
	{
#ifdef NEWDB
	  case T_BTREE:
	  case T_HASH:
		if (strlen(mapname) >= sizeof dbuf)
		{
			fprintf(stderr,
				"%s: map name too long\n", mapname);
			exit(EX_USAGE);
		}
		strcpy(dbuf, mapname);
		if ((st = safefile(dbuf, RealUid, RealGid, RealUserName,
				   sff, S_IWUSR, &std)) != 0)
		{
			fprintf(stderr,
				"%s: could not create: %s\n",
				dbuf, errstring(st));
			exit(EX_CANTCREAT);
		}
		break;
#endif
#ifdef NDBM
	  case T_DBM:
		if (strlen(mapname) + 5 > sizeof dbuf)
		{
			fprintf(stderr,
				"%s: map name too long\n", mapname);
			exit(EX_USAGE);
		}
		sprintf(dbuf, "%s.dir", mapname);
		if ((st = safefile(dbuf, RealUid, RealGid, RealUserName,
			   sff, S_IWUSR, &std)) != 0)
		{
			fprintf(stderr,
				"%s: could not create: %s\n",
				dbuf, errstring(st));
			exit(EX_CANTCREAT);
		}
		sprintf(pbuf, "%s.pag", mapname);
		if ((st = safefile(pbuf, RealUid, RealGid, RealUserName,
			   sff, S_IWUSR, &stp)) != 0)
		{
			fprintf(stderr,
				"%s: could not create: %s\n",
				pbuf, errstring(st));
			exit(EX_CANTCREAT);
		}
		break;
#endif
	  default:
		fprintf(stderr,
			"%s: internal error: type %d\n",
			progname,
			type);
		exit(EX_SOFTWARE);
	}

	/*
	**  Create the database.
	*/

	mode = O_RDWR;
	if (!notrunc)
		mode |= O_CREAT|O_TRUNC;
#if O_EXLOCK
	mode |= O_EXLOCK;
#else
	/* pre-lock the database */
	fd = safeopen(dbuf, mode & ~O_TRUNC, 0644, sff);
	if (fd < 0)
	{
		fprintf(stderr, "%s: cannot create type %s map %s\n",
			progname, typename, mapname);
		exit(EX_CANTCREAT);
	}
#endif
	switch (type)
	{
#ifdef NDBM
	  case T_DBM:
		dbp.dbm = dbm_open(mapname, mode, 0644);
		if (dbp.dbm != NULL &&
		    dbm_dirfno(dbp.dbm) == dbm_pagfno(dbp.dbm))
		{
			fprintf(stderr, "dbm map %s: cannot run with GDBM\n",
				mapname);
			dbm_close(dbp.dbm);
			exit(EX_CONFIG);
		}
		if (dbp.dbm != NULL &&
		    (filechanged(dbuf, dbm_dirfno(dbp.dbm), &std) ||
		     filechanged(pbuf, dbm_pagfno(dbp.dbm), &stp)))
		{
			fprintf(stderr,
				"dbm map %s: file changed after open\n",
				mapname);
			dbm_close(dbp.dbm);
			exit(EX_CANTCREAT);
		}
#if _FFR_TRUSTED_USER
		if (geteuid() == 0 && TrustedUid != 0)
		{
			if (fchown(dbm_dirfno(dbp.dbm), TrustedUid, -1) < 0 ||
			    fchown(dbm_pagfno(dbp.dbm), TrustedUid, -1) < 0)
			{
				fprintf(stderr,
					"WARNING: ownership change on %s failed: %s",
					mapname, errstring(errno));
			}
		}
#endif

		break;
#endif

#ifdef NEWDB
	  case T_HASH:
		/* tweak some parameters for performance */
# if DB_VERSION_MAJOR < 2
		hinfo.nelem = 4096;
		hinfo.cachesize = dbcachesize;
# else
		dbinfo.h_nelem = 4096;
		dbinfo.db_cachesize = dbcachesize;
# endif
		
# if DB_VERSION_MAJOR < 2
		dbp.db = dbopen(mapname, mode, 0644, DB_HASH, &hinfo);
# else
		{
			int flags = 0;
			
			if (bitset(O_CREAT, mode))
				flags |= DB_CREATE;
			if (bitset(O_TRUNC, mode))
				flags |= DB_TRUNCATE;
			
			dbp.db = NULL;
			errno = db_open(mapname, DB_HASH, flags, 0644,
					NULL, &dbinfo, &dbp.db);
		}
# endif
		if (dbp.db != NULL)
		{
			int fd;
			
# if DB_VERSION_MAJOR < 2
			fd = dbp.db->fd(dbp.db);
# else
			fd = -1;
			errno = dbp.db->fd(dbp.db, &fd);
# endif
			if (filechanged(dbuf, fd, &std))
			{
				fprintf(stderr,
					"db map %s: file changed after open\n",
					mapname);
# if DB_VERSION_MAJOR < 2
				dbp.db->close(dbp.db);
# else
				errno = dbp.db->close(dbp.db, 0);
# endif
				exit(EX_CANTCREAT);
			}
			(void) (*dbp.db->sync)(dbp.db, 0);
#if _FFR_TRUSTED_USER
			if (geteuid() == 0 && TrustedUid != 0)
			{
				if (fchown(fd, TrustedUid, -1) < 0)
				{
					fprintf(stderr,
						"WARNING: ownership change on %s failed: %s",
						mapname, errstring(errno));
				}
			}
#endif
		}
		break;

	  case T_BTREE:
		/* tweak some parameters for performance */
# if DB_VERSION_MAJOR < 2
		bti.cachesize = dbcachesize;
# else
		dbinfo.db_cachesize = dbcachesize;
# endif

# if DB_VERSION_MAJOR < 2
		dbp.db = dbopen(mapname, mode, 0644, DB_BTREE, &bti);
# else
		{
			int flags = 0;
			
			if (bitset(O_CREAT, mode))
				flags |= DB_CREATE;
			if (bitset(O_TRUNC, mode))
				flags |= DB_TRUNCATE;
			
			dbp.db = NULL;
			errno = db_open(mapname, DB_BTREE, flags, 0644,
					NULL, &dbinfo, &dbp.db);
		}
# endif
		if (dbp.db != NULL)
		{
			int fd;
			
# if DB_VERSION_MAJOR < 2
			fd = dbp.db->fd(dbp.db);
# else
			fd = -1;
			errno = dbp.db->fd(dbp.db, &fd);
# endif
			if (filechanged(dbuf, fd, &std))
			{
				fprintf(stderr,
					"db map %s: file changed after open\n",
					mapname);
# if DB_VERSION_MAJOR < 2
				dbp.db->close(dbp.db);
# else
				errno = dbp.db->close(dbp.db, 0);
# endif
				exit(EX_CANTCREAT);
			}
			(void) (*dbp.db->sync)(dbp.db, 0);
#if _FFR_TRUSTED_USER
			if (geteuid() == 0 && TrustedUid != 0)
			{
				if (fchown(fd, TrustedUid, -1) < 0)
				{
					fprintf(stderr,
						"WARNING: ownership change on %s failed: %s",
						mapname, errstring(errno));
				}
			}
#endif
		}
		break;
#endif

	  default:
		fprintf(stderr, "%s: internal error: type %d\n",
			progname, type);
		exit(EX_SOFTWARE);
	}

	if (dbp.dbx == NULL)
	{
		fprintf(stderr, "%s: cannot open type %s map %s\n",
			progname, typename, mapname);
		exit(EX_CANTCREAT);
	}

	/*
	**  Copy the data
	*/

	lineno = 0;
	exitstat = EX_OK;
	while (fgets(ibuf, sizeof ibuf, stdin) != NULL)
	{
		register char *p;

		lineno++;

		/*
		**  Parse the line.
		*/

		p = strchr(ibuf, '\n');
		if (p != NULL)
			*p = '\0';
		else if (!feof(stdin))
		{
			fprintf(stderr, "%s: %s: line %d: line too long (%ld bytes max)\n",
				progname, mapname, lineno, (long) sizeof ibuf);
			continue;
		}
			
		if (ibuf[0] == '\0' || ibuf[0] == '#')
			continue;
		if (isascii(ibuf[0]) && isspace(ibuf[0]))
		{
			fprintf(stderr, "%s: %s: line %d: syntax error (leading space)\n",
				progname, mapname, lineno);
			continue;
		}
#ifdef NEWDB
		if (type == T_HASH || type == T_BTREE)
		{
			bzero(&key.db, sizeof key.db);
			bzero(&val.db, sizeof val.db);
		}
#endif

		key.xx.data = ibuf;
		for (p = ibuf; *p != '\0' && !(isascii(*p) && isspace(*p)); p++)
		{
			if (foldcase && isascii(*p) && isupper(*p))
				*p = tolower(*p);
		}
		key.xx.size = p - key.xx.data;
		if (inclnull)
			key.xx.size++;
		if (*p != '\0')
			*p++ = '\0';
		while (isascii(*p) && isspace(*p))
			p++;
		if (*p == '\0')
		{
			fprintf(stderr, "%s: %s: line %d: no RHS for LHS %s\n",
				progname, mapname, lineno, key.xx.data);
			continue;
		}
		val.xx.data = p;
		val.xx.size = strlen(p);
		if (inclnull)
			val.xx.size++;

		/*
		**  Do the database insert.
		*/

		if (verbose)
		{
			printf("key=`%s', val=`%s'\n", key.xx.data, val.xx.data);
		}

		switch (type)
		{
#ifdef NDBM
		  case T_DBM:
			st = dbm_store(dbp.dbm, key.dbm, val.dbm, putflags);
			break;
#endif

#ifdef NEWDB
		  case T_BTREE:
		  case T_HASH:
# if DB_VERSION_MAJOR < 2
			st = (*dbp.db->put)(dbp.db, &key.db, &val.db, putflags);
# else
			errno = (*dbp.db->put)(dbp.db, NULL, &key.db,
					       &val.db, putflags);
			switch (errno)
			{
			  case DB_KEYEXIST:
				st = 1;
				break;

			  case 0:
				st = 0;
				break;

			  default:
				st = -1;
				break;
			}
# endif
			break;
#endif
		  default:
			break;
		}

		if (st < 0)
		{
			fprintf(stderr, "%s: %s: line %d: key %s: put error\n",
				progname, mapname, lineno, key.xx.data);
			perror(mapname);
			exitstat = EX_IOERR;
		}
		else if (st > 0)
		{
			fprintf(stderr,
				"%s: %s: line %d: key %s: duplicate key\n",
				progname, mapname, lineno, key.xx.data);
		}
	}

	/*
	**  Now close the database.
	*/

	switch (type)
	{
#ifdef NDBM
	  case T_DBM:
		dbm_close(dbp.dbm);
		break;
#endif

#ifdef NEWDB
	  case T_HASH:
	  case T_BTREE:
# if DB_VERSION_MAJOR < 2
		if ((*dbp.db->close)(dbp.db) < 0)
# else
		if ((errno = (*dbp.db->close)(dbp.db, 0)) != 0)
# endif
		{
			fprintf(stderr, "%s: %s: error on close\n",
				progname, mapname);
			perror(mapname);
			exitstat = EX_IOERR;
		}
#endif
	  default:
		break;
	}

#if !O_EXLOCK
	/* release locks */
	close(fd);
#endif

	exit (exitstat);
}
/*
**  LOCKFILE -- lock a file using flock or (shudder) fcntl locking
**
**	Parameters:
**		fd -- the file descriptor of the file.
**		filename -- the file name (for error messages).
**		ext -- the filename extension.
**		type -- type of the lock.  Bits can be:
**			LOCK_EX -- exclusive lock.
**			LOCK_NB -- non-blocking.
**
**	Returns:
**		TRUE if the lock was acquired.
**		FALSE otherwise.
*/

bool
lockfile(fd, filename, ext, type)
	int fd;
	char *filename;
	char *ext;
	int type;
{
# if !HASFLOCK
	int action;
	struct flock lfd;
	extern int errno;

	bzero(&lfd, sizeof lfd);
	if (bitset(LOCK_UN, type))
		lfd.l_type = F_UNLCK;
	else if (bitset(LOCK_EX, type))
		lfd.l_type = F_WRLCK;
	else
		lfd.l_type = F_RDLCK;
	if (bitset(LOCK_NB, type))
		action = F_SETLK;
	else
		action = F_SETLKW;

	if (fcntl(fd, action, &lfd) >= 0)
		return TRUE;

	/*
	**  On SunOS, if you are testing using -oQ/tmp/mqueue or
	**  -oA/tmp/aliases or anything like that, and /tmp is mounted
	**  as type "tmp" (that is, served from swap space), the
	**  previous fcntl will fail with "Invalid argument" errors.
	**  Since this is fairly common during testing, we will assume
	**  that this indicates that the lock is successfully grabbed.
	*/

	if (errno == EINVAL)
		return TRUE;

# else	/* HASFLOCK */

	if (flock(fd, type) >= 0)
		return TRUE;

# endif

	return FALSE;
}

/*VARARGS1*/
void
#ifdef __STDC__
message(const char *msg, ...)
#else
message(msg, va_alist)
	const char *msg;
	va_dcl
#endif
{
	const char *m;
	VA_LOCAL_DECL

	m = msg;
	if (isascii(m[0]) && isdigit(m[0]) &&
	    isascii(m[1]) && isdigit(m[1]) &&
	    isascii(m[2]) && isdigit(m[2]) && m[3] == ' ')
		m += 4;
	VA_START(msg);
	vfprintf(stderr, m, ap);
	VA_END;
	fprintf(stderr, "\n");
}

/*VARARGS1*/
void
#ifdef __STDC__
syserr(const char *msg, ...)
#else
syserr(msg, va_alist)
	const char *msg;
	va_dcl
#endif
{
	const char *m;
	VA_LOCAL_DECL

	m = msg;
	if (isascii(m[0]) && isdigit(m[0]) &&
	    isascii(m[1]) && isdigit(m[1]) &&
	    isascii(m[2]) && isdigit(m[2]) && m[3] == ' ')
		m += 4;
	VA_START(msg);
	vfprintf(stderr, m, ap);
	VA_END;
	fprintf(stderr, "\n");
}

const char *
errstring(err)
	int err;
{
#if !HASSTRERROR
	static char errstr[64];
# if !defined(ERRLIST_PREDEFINED)
	extern char *sys_errlist[];
	extern int sys_nerr;
# endif
#endif

	/* handle pseudo-errors internal to sendmail */
	switch (err)
	{
	  case E_SM_OPENTIMEOUT:
		return "Timeout on file open";

	  case E_SM_NOSLINK:
		return "Symbolic links not allowed";

	  case E_SM_NOHLINK:
		return "Hard links not allowed";

	  case E_SM_REGONLY:
		return "Regular files only";

	  case E_SM_ISEXEC:
		return "Executable files not allowed";

	  case E_SM_WWDIR:
		return "World writable directory";

	  case E_SM_GWDIR:
		return "Group writable directory";

	  case E_SM_FILECHANGE:
		return "File changed after open";

	  case E_SM_WWFILE:
		return "World writable file";

	  case E_SM_GWFILE:
		return "Group writable file";
	}

#if HASSTRERROR
	return strerror(err);
#else
	if (err < 0 || err >= sys_nerr)
	{
		sprintf(errstr, "Error %d", err);
		return errstr;
	}
	return sys_errlist[err];
#endif
}
@


1.9
log
@sendmail 8.9.2
@
text
@@


1.8
log
@something hosed the sendmail import; fix up by hand
@
text
@d14 1
a14 1
static char sccsid[] = "@@(#)makemap.c	8.62 (Berkeley) 6/24/98";
d60 1
a60 1
bool	DontInitGroups = TRUE;
d63 1
a63 1
uid_t	TrustedFileUid = 0;
d82 3
a84 3
	char *typename;
	char *mapname;
	char *ext;
d88 2
a89 1
	int putflags;
d91 1
d93 1
d95 1
d123 1
a123 1
#if _FFR_TRUSTED_FILE_OWNER
d152 1
a152 1
#define OPTIONS		"C:Nc:dforsv"
d170 1
d172 1
d184 13
d254 1
a254 1
#if _FFR_TRUSTED_FILE_OWNER
d272 2
a273 2
			if (strncasecmp(b, " TrustedFileOwner", 17) == 0 &&
			    !(isascii(b[17]) && isalnum(b[17])))
d281 1
a281 1
					TrustedFileUid = atoi(b);
d286 1
a286 1
					TrustedFileUid = 0;
d290 1
a290 1
							"TrustedFileOwner: unknown user %s", b);
d292 1
a292 1
						TrustedFileUid = pw->pw_uid;
d296 1
a296 1
				if (TrustedFileUid > UID_MAX)
d298 3
a300 3
					syserr("TrustedFileOwner: uid value (%ld) > UID_MAX (%ld)",
					       TrustedFileUid, UID_MAX);
					TrustedFileUid = 0;
d318 1
a318 1
			"Usage: %s [-N] [-c cachesize] [-d] [-f] [-o] [-r] [-s] [-v] type mapname\n",
d527 2
a528 1
		if (geteuid() == 0 && TrustedFileUid != 0)
d530 2
a531 2
			if (fchown(dbm_dirfno(dbp.dbm), TrustedFileUid, -1) < 0 ||
			    fchown(dbm_pagfno(dbp.dbm), TrustedFileUid, -1) < 0)
d538 1
d593 2
a594 1
			if (geteuid() == 0 && TrustedFileUid != 0)
d596 1
a596 1
				if (fchown(fd, TrustedFileUid, -1) < 0)
d603 1
d654 2
a655 1
			if (geteuid() == 0 && TrustedFileUid != 0)
d657 1
a657 1
				if (fchown(fd, TrustedFileUid, -1) < 0)
d664 1
d964 1
d966 1
a966 1
#if !HASSTRERROR && !defined(ERRLIST_PREDEFINED)
d969 1
@


1.7
log
@Upgrade to sendmail 8.8.8
@
text
@d2 2
a3 1
 * Copyright (c) 1992 Eric P. Allman.
d7 3
a9 15
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
a10 11
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
d14 1
a14 1
static char sccsid[] = "@@(#)makemap.c	8.38 (Berkeley) 9/23/97";
d23 1
d26 1
a26 1
#include <ndbm.h>
d30 4
a33 1
#include <db.h>
d61 1
a61 1
bool	UnsafeGroupWrites = FALSE;
d63 1
d67 1
d73 1
a79 1
	bool ignoresafeties = FALSE;
d92 2
d106 1
d109 3
d116 1
d118 5
d124 4
a127 3
	struct passwd *pw;
	int sff = SFF_ROOTOK|SFF_REGONLY|SFF_NOLINK|SFF_NOWLINK;
	struct stat std, stp;
a129 1
	extern bool lockfile();
d132 1
d144 1
a144 1
		sprintf(rnamebuf, "Unknown UID %d", RealUid);
d148 1
a148 1
#define OPTIONS		"Nc:dforsv"
d150 1
a150 1
#define OPTIONS		"Ndforv"
d152 1
a152 1
	while ((opt = getopt(argc, argv, OPTIONS)) != -1)
d156 4
a185 1
#if _FFR_NEW_MAKEMAP_FLAGS
d187 1
a187 1
			ignoresafeties = TRUE;
a188 1
#endif
d200 7
d235 59
d302 1
a302 1
		fprintf(stderr, "Usage: %s [-N] [-d] [-f] [-o] [-r] [-v] type mapname\n", progname);
d324 1
d326 3
d330 2
d333 4
d340 2
d343 4
d350 1
d352 3
d358 2
d361 4
d420 1
a420 2
		if (!ignoresafeties &&
		    (st = safefile(dbuf, RealUid, RealGid, RealUserName,
d440 1
a440 1
			   sff, S_IWUSR, &std)) != 0 && !ignoresafeties)
d449 1
a449 1
			   sff, S_IWUSR, &stp)) != 0 && !ignoresafeties)
d477 1
a477 4
	if (ignoresafeties)
		fd = dfopen(dbuf, mode & ~O_TRUNC, 0644, sff);
	else
		fd = safeopen(dbuf, mode & ~O_TRUNC, 0644, sff);
d498 3
a500 3
		if (!ignoresafeties && dbp.dbm != NULL &&
		    (filechanged(dbuf, dbm_dirfno(dbp.dbm), &std, sff) ||
		     filechanged(pbuf, dbm_pagfno(dbp.dbm), &stp, sff)))
d508 11
d525 1
d528 4
d533 1
d535 14
d551 9
a559 2
			if (!ignoresafeties &&
			    filechanged(dbuf, dbp.db->fd(dbp.db), &std, sff))
d564 1
d566 3
a570 3
# if OLD_NEWDB
			(void) (*dbp.db->sync)(dbp.db);
# else
d572 9
a580 1
# endif
d586 1
d588 3
d592 1
d594 14
d610 9
a618 2
			if (!ignoresafeties &&
			    filechanged(dbuf, dbp.db->fd(dbp.db), &std, sff))
d623 1
d625 3
a629 3
# if OLD_NEWDB
			(void) (*dbp.db->sync)(dbp.db);
# else
d631 9
a639 1
# endif
d678 2
a679 2
			fprintf(stderr, "%s: %s: line %d: line too long (%d bytes max)\n",
				progname, mapname, lineno, sizeof ibuf);
d685 1
a685 1
		if (isspace(ibuf[0]))
d691 8
d700 1
a700 1
		for (p = ibuf; *p != '\0' && !isspace(*p); p++)
d702 1
a702 1
			if (foldcase && isupper(*p))
d710 1
a710 1
		while (isspace(*p))
d743 1
d745 18
d765 2
d799 1
d801 3
d811 2
d887 1
a887 1
/*VARARGS2*/
d901 3
a903 1
	if (isdigit(m[0]) && isdigit(m[1]) && isdigit(m[2]) && m[3] == ' ')
d911 1
a911 1
/*VARARGS2*/
d925 3
a927 1
	if (isdigit(m[0]) && isdigit(m[1]) && isdigit(m[2]) && m[3] == ' ')
d982 1
a982 1
	if (err < 0 || err > sys_nerr)
@


1.6
log
@sendmail 8.8.7.
@
text
@d36 1
a36 1
static char sccsid[] = "@@(#)makemap.c	8.37 (Berkeley) 7/10/97";
a365 7
		if (std.st_dev == stp.st_dev && std.st_ino == stp.st_ino)
		{
			fprintf(stderr,
				"%s: cannot run with GDBM\n",
				mapname);
			exit(EX_CONFIG);
		}
d403 8
@


1.5
log
@Sendmail 8.8.6.
@
text
@d36 1
a36 1
static char sccsid[] = "@@(#)makemap.c	8.35 (Berkeley) 6/10/97";
d140 1
a140 1
	if (pw != NULL) 
d317 1
a317 1
	switch (type) 
d331 1
a331 1
				   sff, S_IWUSR, &std)) != 0) 
d349 2
a350 3
		if (!ignoresafeties &&
		    (st = safefile(dbuf, RealUid, RealGid, RealUserName,
				   sff, S_IWUSR, &std)) != 0) 
d358 2
a359 3
		if (!ignoresafeties &&
		    (st = safefile(pbuf, RealUid, RealGid, RealUserName,
				   sff, S_IWUSR, &stp)) != 0) 
d366 7
d773 1
a773 1
	if (err < 0 || err > sys_nerr) 
@


1.4
log
@getopt(3) returns -1 when out of args, not EOF, whee!
@
text
@d36 1
a36 1
static char sccsid[] = "@@(#)makemap.c	8.19 (Berkeley) 11/18/96";
a38 2
#include <stdio.h>
#include <sysexits.h>
a39 2
#include <ctype.h>
#include <string.h>
d44 1
a44 3
#define NOT_SENDMAIL
#include "useful.h"
#include "conf.h"
d71 11
d95 1
a100 1
	char *lext;
d125 6
a130 1
	char lbuf[MAXNAME];
d137 15
a151 2
#ifdef FFR_CFLAG
#define OPTIONS		"Nc:dforv"
d163 1
a163 1
#ifdef FFR_CFLAG
d185 6
a209 1
		lext = NULL;
a213 1
			lext = ".dir";
d232 4
a235 2
#ifdef FFR_CFLAG
		fprintf(stderr, "Usage: %s [-N] [-c cachesize] [-d] [-f] [-o] [-r] [-v] type mapname\n", progname);
d302 5
d315 62
a376 3
	strcpy(lbuf, mapname);
	if (lext != NULL)
		strcat(lbuf, lext);
d385 1
a385 1
#ifdef O_EXLOCK
d389 4
a392 1
	fd = open(lbuf, mode & ~O_TRUNC, 0644);
a398 1
	(void) lockfile(fd);
d405 10
d423 1
a423 1

d427 9
d451 9
d470 2
a471 1
		fprintf(stderr, "%s: internal error: type %d\n", progname, type);
d574 2
a575 1
			fprintf(stderr, "%s: %s: line %d: key %s: duplicate key\n",
d605 1
a605 1
#ifndef O_EXLOCK
d617 5
d629 1
a629 1
lockfile(fd)
d631 3
d641 10
a650 2
	lfd.l_type = F_WRLCK;
	action = F_SETLKW;
d669 1
a669 1
	if (flock(fd, LOCK_EX) >= 0)
d675 100
@


1.3
log
@Update to Sendmail 8.8.4, plus recent patches, plus OpenBSD support.
Also include entire example configuration subset.
Includes smrsh (using /usr/libexec/sm.bin).

Of the top of my head, the only things I removed from the distribution were
contrib/mail.local.linux, src/Makefiles, all the *.0 and *.ps files.
Our praliases man page replaces the distributed one, ours is better.
@
text
@d132 1
a132 1
	while ((opt = getopt(argc, argv, OPTIONS)) != EOF)
@


1.2
log
@Sendmail 8.7.3 from NetBSD
@
text
@d36 1
a36 1
static char sccsid[] = "@@(#)makemap.c	8.14 (Berkeley) 11/5/95";
d48 1
d99 2
d116 1
d127 6
a132 1
	while ((opt = getopt(argc, argv, "Ndforv")) != EOF)
d140 6
d205 3
d209 1
d233 4
d240 6
a248 1
#endif
d255 4
d260 1
d315 5
a319 1
		dbp.db = dbopen(mapname, mode, 0644, DB_HASH, NULL);
d331 3
d429 1
a429 2
			st = dbm_store(dbp.dbm, key.dbm, val.dbm,
					allowreplace ? DBM_REPLACE : DBM_INSERT);
d436 1
a436 2
			st = (*dbp.db->put)(dbp.db, &key.db, &val.db,
					allowreplace ? 0 : R_NOOVERWRITE);
@


1.1
log
@Initial revision
@
text
@d36 1
a36 1
static char sccsid[] = "@@(#)makemap.c	8.6.1.1 (Berkeley) 3/6/95";
a41 1
#include <sys/file.h>
d44 4
d86 1
d94 1
d99 1
d111 3
d116 1
d119 1
d123 1
a123 1
	while ((opt = getopt(argc, argv, "Nforv")) != EOF)
d131 4
d166 1
d171 1
d190 1
a190 1
		fprintf(stderr, "Usage: %s [-N] [-o] [-v] type mapname\n", progname);
d208 20
d248 4
d259 13
d284 4
d289 2
d294 1
a294 1
		dbp.db = dbopen(mapname, mode, 0644, DB_BTREE, NULL);
d296 4
d301 2
d313 1
a313 1
		fprintf(stderr, "%s: cannot create type %s map %s\n",
d442 5
d448 48
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@


1.1.1.2
log
@sendmail 8.9.1
@
text
@d2 1
a2 2
 * Copyright (c) 1998 Sendmail, Inc.  All rights reserved.
 * Copyright (c) 1992 Eric P. Allman.  All rights reserved.
d6 15
a20 3
 * By using this file, you agree to the terms and conditions set
 * forth in the LICENSE file which can be found at the top level of
 * the sendmail distribution.
d22 11
d36 1
a36 1
static char sccsid[] = "@@(#)makemap.c	8.62 (Berkeley) 6/24/98";
d39 2
d42 5
a46 6
#include <sys/errno.h>
#ifndef ISC_UNIX
# include <sys/file.h>
#endif
#include "sendmail.h"
#include "pathnames.h"
d49 1
a49 1
# include <ndbm.h>
d53 1
a53 4
# include <db.h>
# ifndef DB_VERSION_MAJOR
#  define DB_VERSION_MAJOR 1
# endif
a72 12
uid_t	RealUid;
gid_t	RealGid;
char	*RealUserName;
uid_t	RunAsUid;
uid_t	RunAsGid;
char	*RunAsUserName;
int	Verbose = 2;
bool	DontInitGroups = TRUE;
long	DontBlameSendmail = DBS_SAFE;
u_char	tTdvect[100];
uid_t	TrustedFileUid = 0;

a74 1
int
a79 1
	char *cfile;
a82 1
	bool allowdups = FALSE;
a92 2
	int putflags;
	long dbcachesize = 1024 * 1024;
a93 3
	int fd;
	int sff = SFF_ROOTOK|SFF_REGONLY;
	struct passwd *pw;
a104 8
#ifdef NEWDB
# if DB_VERSION_MAJOR < 2
	BTREEINFO bti;
	HASHINFO hinfo;
# else
	DB_INFO dbinfo;
# endif
#endif
a106 13
	char dbuf[MAXNAME];
#ifdef NDBM
	char pbuf[MAXNAME];
#endif
#if _FFR_TRUSTED_FILE_OWNER
	FILE *cfp;
	char buf[MAXLINE];
#endif
	static char rnamebuf[MAXNAME];	/* holds RealUserName */
	struct stat std;
#ifdef NDBM
	struct stat stp;
#endif
a110 14
	cfile = _PATH_SENDMAILCF;

	RunAsUid = RealUid = getuid();
	RunAsGid = RealGid = getgid();
	pw = getpwuid(RealUid);
	if (pw != NULL)
	{
		if (strlen(pw->pw_name) > MAXNAME - 1)
			pw->pw_name[MAXNAME] = 0;
		sprintf(rnamebuf, "%s", pw->pw_name);
	}
	else
		sprintf(rnamebuf, "Unknown UID %d", (int) RealUid);
	RunAsUserName = RealUserName = rnamebuf;
d112 1
a112 6
#if _FFR_NEW_MAKEMAP_FLAGS
#define OPTIONS		"C:Nc:dforsv"
#else
#define OPTIONS		"C:Ndforsv"
#endif
	while ((opt = getopt(argc, argv, OPTIONS)) != EOF)
a115 4
		  case 'C':
			cfile = optarg;
			break;

a119 10
#if _FFR_NEW_MAKEMAP_FLAGS
		  case 'c':
			dbcachesize = atol(optarg);
			break;
#endif

		  case 'd':
			allowdups = TRUE;
			break;

a131 4
		  case 's':
			DontBlameSendmail |= DBS_MAPINUNSAFEDIRPATH|DBS_WRITEMAPTOHARDLINK|DBS_WRITEMAPTOSYMLINK|DBS_LINKEDMAPINWRITABLEDIR;
			break;

a141 7
	if (!bitset(DBS_WRITEMAPTOSYMLINK, DontBlameSendmail))
		sff |= SFF_NOSLINK;
        if (!bitset(DBS_WRITEMAPTOHARDLINK, DontBlameSendmail))
		sff |= SFF_NOHLINK;
	if (!bitset(DBS_LINKEDMAPINWRITABLEDIR, DontBlameSendmail))
		sff |= SFF_NOWLINK;

a169 59
#if _FFR_TRUSTED_FILE_OWNER
	if ((cfp = fopen(cfile, "r")) == NULL)
	{
		fprintf(stderr, "mailstats: ");
		perror(cfile);
		exit(EX_NOINPUT);
	}
	while (fgets(buf, sizeof(buf), cfp) != NULL)
	{
		register char *b;

		if ((b = strchr(buf, '\n')) != NULL)
			*b = '\0';

		b = buf;
		switch (*b++)
		{
		  case 'O':		/* option */
			if (strncasecmp(b, " TrustedFileOwner", 17) == 0 &&
			    !(isascii(b[17]) && isalnum(b[17])))
			{
				b = strchr(b, '=');
				if (b == NULL)
					continue;
				while (isascii(*++b) && isspace(*b))
					continue;
				if (isascii(*b) && isdigit(*b))
					TrustedFileUid = atoi(b);
				else
				{
					register struct passwd *pw;
					
					TrustedFileUid = 0;
					pw = getpwnam(b);
					if (pw == NULL)
						fprintf(stderr,
							"TrustedFileOwner: unknown user %s", b);
					else
						TrustedFileUid = pw->pw_uid;
				}
				
# ifdef UID_MAX
				if (TrustedFileUid > UID_MAX)
				{
					syserr("TrustedFileOwner: uid value (%ld) > UID_MAX (%ld)",
					       TrustedFileUid, UID_MAX);
					TrustedFileUid = 0;
				}
# endif
				break;
			}


		  default:
			continue;
		}
	}
	(void) fclose(cfp);
#endif
d173 1
a173 7
#if _FFR_NEW_MAKEMAP_FLAGS
		fprintf(stderr,
			"Usage: %s [-N] [-c cachesize] [-d] [-f] [-o] [-r] [-s] [-v] type mapname\n",
			progname);
#else
		fprintf(stderr, "Usage: %s [-N] [-d] [-f] [-o] [-r] [-s] [-v] type mapname\n", progname);
#endif
a190 60

#ifdef NEWDB
	  case T_BTREE:
# if DB_VERSION_MAJOR < 2
		bzero(&bti, sizeof bti);
# else
		bzero(&dbinfo, sizeof dbinfo);
# endif
		if (allowdups)
		{
# if DB_VERSION_MAJOR < 2
			bti.flags |= R_DUP;
# else
			dbinfo.flags |= DB_DUP;
# endif
		}
		if (allowdups || allowreplace)
			putflags = 0;
		else
		{
# if DB_VERSION_MAJOR < 2
			putflags = R_NOOVERWRITE;
# else
			putflags = DB_NOOVERWRITE;
# endif
		}
		break;

	  case T_HASH:
# if DB_VERSION_MAJOR < 2
		bzero(&hinfo, sizeof hinfo);
# else
		bzero(&dbinfo, sizeof dbinfo);
# endif
		if (allowreplace)
			putflags = 0;
		else
		{
# if DB_VERSION_MAJOR < 2
			putflags = R_NOOVERWRITE;
# else
			putflags = DB_NOOVERWRITE;
# endif
		}
		break;
#endif
#ifdef NDBM
	  case T_DBM:
		if (allowdups)
		{
			fprintf(stderr, "%s: Type %s does not support -d (allow dups)\n",
				progname, typename);
			exit(EX_UNAVAILABLE);
		}
		if (allowreplace)
			putflags = DBM_REPLACE;
		else
			putflags = DBM_INSERT;
		break;
#endif
a202 5
		if (el + fl + 1 >= sizeof fbuf)
		{
			fprintf(stderr, "%s: file name too long", mapname);
			exit(EX_USAGE);
		}
a210 60
	if (!notrunc)
		sff |= SFF_CREAT;
	switch (type)
	{
#ifdef NEWDB
	  case T_BTREE:
	  case T_HASH:
		if (strlen(mapname) >= sizeof dbuf)
		{
			fprintf(stderr,
				"%s: map name too long\n", mapname);
			exit(EX_USAGE);
		}
		strcpy(dbuf, mapname);
		if ((st = safefile(dbuf, RealUid, RealGid, RealUserName,
				   sff, S_IWUSR, &std)) != 0)
		{
			fprintf(stderr,
				"%s: could not create: %s\n",
				dbuf, errstring(st));
			exit(EX_CANTCREAT);
		}
		break;
#endif
#ifdef NDBM
	  case T_DBM:
		if (strlen(mapname) + 5 > sizeof dbuf)
		{
			fprintf(stderr,
				"%s: map name too long\n", mapname);
			exit(EX_USAGE);
		}
		sprintf(dbuf, "%s.dir", mapname);
		if ((st = safefile(dbuf, RealUid, RealGid, RealUserName,
			   sff, S_IWUSR, &std)) != 0)
		{
			fprintf(stderr,
				"%s: could not create: %s\n",
				dbuf, errstring(st));
			exit(EX_CANTCREAT);
		}
		sprintf(pbuf, "%s.pag", mapname);
		if ((st = safefile(pbuf, RealUid, RealGid, RealUserName,
			   sff, S_IWUSR, &stp)) != 0)
		{
			fprintf(stderr,
				"%s: could not create: %s\n",
				pbuf, errstring(st));
			exit(EX_CANTCREAT);
		}
		break;
#endif
	  default:
		fprintf(stderr,
			"%s: internal error: type %d\n",
			progname,
			type);
		exit(EX_SOFTWARE);
	}

a217 12
#if O_EXLOCK
	mode |= O_EXLOCK;
#else
	/* pre-lock the database */
	fd = safeopen(dbuf, mode & ~O_TRUNC, 0644, sff);
	if (fd < 0)
	{
		fprintf(stderr, "%s: cannot create type %s map %s\n",
			progname, typename, mapname);
		exit(EX_CANTCREAT);
	}
#endif
a222 29
		if (dbp.dbm != NULL &&
		    dbm_dirfno(dbp.dbm) == dbm_pagfno(dbp.dbm))
		{
			fprintf(stderr, "dbm map %s: cannot run with GDBM\n",
				mapname);
			dbm_close(dbp.dbm);
			exit(EX_CONFIG);
		}
		if (dbp.dbm != NULL &&
		    (filechanged(dbuf, dbm_dirfno(dbp.dbm), &std) ||
		     filechanged(pbuf, dbm_pagfno(dbp.dbm), &stp)))
		{
			fprintf(stderr,
				"dbm map %s: file changed after open\n",
				mapname);
			dbm_close(dbp.dbm);
			exit(EX_CANTCREAT);
		}
		if (geteuid() == 0 && TrustedFileUid != 0)
		{
			if (fchown(dbm_dirfno(dbp.dbm), TrustedFileUid, -1) < 0 ||
			    fchown(dbm_pagfno(dbp.dbm), TrustedFileUid, -1) < 0)
			{
				fprintf(stderr,
					"WARNING: ownership change on %s failed: %s",
					mapname, errstring(errno));
			}
		}

d228 1
a228 25
		/* tweak some parameters for performance */
# if DB_VERSION_MAJOR < 2
		hinfo.nelem = 4096;
		hinfo.cachesize = dbcachesize;
# else
		dbinfo.h_nelem = 4096;
		dbinfo.db_cachesize = dbcachesize;
# endif
		
# if DB_VERSION_MAJOR < 2
		dbp.db = dbopen(mapname, mode, 0644, DB_HASH, &hinfo);
# else
		{
			int flags = 0;
			
			if (bitset(O_CREAT, mode))
				flags |= DB_CREATE;
			if (bitset(O_TRUNC, mode))
				flags |= DB_TRUNCATE;
			
			dbp.db = NULL;
			errno = db_open(mapname, DB_HASH, flags, 0644,
					NULL, &dbinfo, &dbp.db);
		}
# endif
a229 21
		{
			int fd;
			
# if DB_VERSION_MAJOR < 2
			fd = dbp.db->fd(dbp.db);
# else
			fd = -1;
			errno = dbp.db->fd(dbp.db, &fd);
# endif
			if (filechanged(dbuf, fd, &std))
			{
				fprintf(stderr,
					"db map %s: file changed after open\n",
					mapname);
# if DB_VERSION_MAJOR < 2
				dbp.db->close(dbp.db);
# else
				errno = dbp.db->close(dbp.db, 0);
# endif
				exit(EX_CANTCREAT);
			}
a230 10
			if (geteuid() == 0 && TrustedFileUid != 0)
			{
				if (fchown(fd, TrustedFileUid, -1) < 0)
				{
					fprintf(stderr,
						"WARNING: ownership change on %s failed: %s",
						mapname, errstring(errno));
				}
			}
		}
d234 1
a234 23
		/* tweak some parameters for performance */
# if DB_VERSION_MAJOR < 2
		bti.cachesize = dbcachesize;
# else
		dbinfo.db_cachesize = dbcachesize;
# endif

# if DB_VERSION_MAJOR < 2
		dbp.db = dbopen(mapname, mode, 0644, DB_BTREE, &bti);
# else
		{
			int flags = 0;
			
			if (bitset(O_CREAT, mode))
				flags |= DB_CREATE;
			if (bitset(O_TRUNC, mode))
				flags |= DB_TRUNCATE;
			
			dbp.db = NULL;
			errno = db_open(mapname, DB_BTREE, flags, 0644,
					NULL, &dbinfo, &dbp.db);
		}
# endif
a235 21
		{
			int fd;
			
# if DB_VERSION_MAJOR < 2
			fd = dbp.db->fd(dbp.db);
# else
			fd = -1;
			errno = dbp.db->fd(dbp.db, &fd);
# endif
			if (filechanged(dbuf, fd, &std))
			{
				fprintf(stderr,
					"db map %s: file changed after open\n",
					mapname);
# if DB_VERSION_MAJOR < 2
				dbp.db->close(dbp.db);
# else
				errno = dbp.db->close(dbp.db, 0);
# endif
				exit(EX_CANTCREAT);
			}
a236 10
			if (geteuid() == 0 && TrustedFileUid != 0)
			{
				if (fchown(fd, TrustedFileUid, -1) < 0)
				{
					fprintf(stderr,
						"WARNING: ownership change on %s failed: %s",
						mapname, errstring(errno));
				}
			}
		}
d241 1
a241 2
		fprintf(stderr, "%s: internal error: type %d\n",
			progname, type);
d247 1
a247 1
		fprintf(stderr, "%s: cannot open type %s map %s\n",
d273 2
a274 2
			fprintf(stderr, "%s: %s: line %d: line too long (%ld bytes max)\n",
				progname, mapname, lineno, (long) sizeof ibuf);
d280 1
a280 1
		if (isascii(ibuf[0]) && isspace(ibuf[0]))
a285 8
#ifdef NEWDB
		if (type == T_HASH || type == T_BTREE)
		{
			bzero(&key.db, sizeof key.db);
			bzero(&val.db, sizeof val.db);
		}
#endif

d287 1
a287 1
		for (p = ibuf; *p != '\0' && !(isascii(*p) && isspace(*p)); p++)
d289 1
a289 1
			if (foldcase && isascii(*p) && isupper(*p))
d297 1
a297 1
		while (isascii(*p) && isspace(*p))
d323 2
a324 1
			st = dbm_store(dbp.dbm, key.dbm, val.dbm, putflags);
d331 2
a332 20
# if DB_VERSION_MAJOR < 2
			st = (*dbp.db->put)(dbp.db, &key.db, &val.db, putflags);
# else
			errno = (*dbp.db->put)(dbp.db, NULL, &key.db,
					       &val.db, putflags);
			switch (errno)
			{
			  case DB_KEYEXIST:
				st = 1;
				break;

			  case 0:
				st = 0;
				break;

			  default:
				st = -1;
				break;
			}
# endif
a334 2
		  default:
			break;
d346 1
a346 2
			fprintf(stderr,
				"%s: %s: line %d: key %s: duplicate key\n",
a365 1
# if DB_VERSION_MAJOR < 2
a366 3
# else
		if ((errno = (*dbp.db->close)(dbp.db, 0)) != 0)
# endif
a373 2
	  default:
		break;
a375 5
#if !O_EXLOCK
	/* release locks */
	close(fd);
#endif

a376 168
}
/*
**  LOCKFILE -- lock a file using flock or (shudder) fcntl locking
**
**	Parameters:
**		fd -- the file descriptor of the file.
**		filename -- the file name (for error messages).
**		ext -- the filename extension.
**		type -- type of the lock.  Bits can be:
**			LOCK_EX -- exclusive lock.
**			LOCK_NB -- non-blocking.
**
**	Returns:
**		TRUE if the lock was acquired.
**		FALSE otherwise.
*/

bool
lockfile(fd, filename, ext, type)
	int fd;
	char *filename;
	char *ext;
	int type;
{
# if !HASFLOCK
	int action;
	struct flock lfd;
	extern int errno;

	bzero(&lfd, sizeof lfd);
	if (bitset(LOCK_UN, type))
		lfd.l_type = F_UNLCK;
	else if (bitset(LOCK_EX, type))
		lfd.l_type = F_WRLCK;
	else
		lfd.l_type = F_RDLCK;
	if (bitset(LOCK_NB, type))
		action = F_SETLK;
	else
		action = F_SETLKW;

	if (fcntl(fd, action, &lfd) >= 0)
		return TRUE;

	/*
	**  On SunOS, if you are testing using -oQ/tmp/mqueue or
	**  -oA/tmp/aliases or anything like that, and /tmp is mounted
	**  as type "tmp" (that is, served from swap space), the
	**  previous fcntl will fail with "Invalid argument" errors.
	**  Since this is fairly common during testing, we will assume
	**  that this indicates that the lock is successfully grabbed.
	*/

	if (errno == EINVAL)
		return TRUE;

# else	/* HASFLOCK */

	if (flock(fd, type) >= 0)
		return TRUE;

# endif

	return FALSE;
}

/*VARARGS1*/
void
#ifdef __STDC__
message(const char *msg, ...)
#else
message(msg, va_alist)
	const char *msg;
	va_dcl
#endif
{
	const char *m;
	VA_LOCAL_DECL

	m = msg;
	if (isascii(m[0]) && isdigit(m[0]) &&
	    isascii(m[1]) && isdigit(m[1]) &&
	    isascii(m[2]) && isdigit(m[2]) && m[3] == ' ')
		m += 4;
	VA_START(msg);
	vfprintf(stderr, m, ap);
	VA_END;
	fprintf(stderr, "\n");
}

/*VARARGS1*/
void
#ifdef __STDC__
syserr(const char *msg, ...)
#else
syserr(msg, va_alist)
	const char *msg;
	va_dcl
#endif
{
	const char *m;
	VA_LOCAL_DECL

	m = msg;
	if (isascii(m[0]) && isdigit(m[0]) &&
	    isascii(m[1]) && isdigit(m[1]) &&
	    isascii(m[2]) && isdigit(m[2]) && m[3] == ' ')
		m += 4;
	VA_START(msg);
	vfprintf(stderr, m, ap);
	VA_END;
	fprintf(stderr, "\n");
}

const char *
errstring(err)
	int err;
{
	static char errstr[64];
#if !HASSTRERROR && !defined(ERRLIST_PREDEFINED)
	extern char *sys_errlist[];
	extern int sys_nerr;
#endif

	/* handle pseudo-errors internal to sendmail */
	switch (err)
	{
	  case E_SM_OPENTIMEOUT:
		return "Timeout on file open";

	  case E_SM_NOSLINK:
		return "Symbolic links not allowed";

	  case E_SM_NOHLINK:
		return "Hard links not allowed";

	  case E_SM_REGONLY:
		return "Regular files only";

	  case E_SM_ISEXEC:
		return "Executable files not allowed";

	  case E_SM_WWDIR:
		return "World writable directory";

	  case E_SM_GWDIR:
		return "Group writable directory";

	  case E_SM_FILECHANGE:
		return "File changed after open";

	  case E_SM_WWFILE:
		return "World writable file";

	  case E_SM_GWFILE:
		return "Group writable file";
	}

#if HASSTRERROR
	return strerror(err);
#else
	if (err < 0 || err >= sys_nerr)
	{
		sprintf(errstr, "Error %d", err);
		return errstr;
	}
	return sys_errlist[err];
#endif
@

