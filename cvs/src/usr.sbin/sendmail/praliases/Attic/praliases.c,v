head	1.7;
access;
symbols
	OPENBSD_2_6:1.6.0.4
	OPENBSD_2_6_BASE:1.6
	OPENBSD_2_5:1.6.0.2
	OPENBSD_2_5_BASE:1.6
	OPENBSD_2_4:1.5.0.2
	OPENBSD_2_4_BASE:1.5
	sendmail_8_9_1:1.1.1.2
	UCB:1.1.1
	OPENBSD_2_3:1.4.0.4
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.4.0.2
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.3.0.2
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.7
date	2000.04.18.04.57.14;	author millert;	state dead;
branches;
next	1.6;

1.6
date	99.01.01.20.33.33;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	98.07.12.19.44.08;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	97.07.15.07.23.54;	author downsj;	state Exp;
branches;
next	1.3;

1.3
date	97.01.15.23.44.19;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	96.12.14.21.16.53;	author downsj;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.48.16;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.48.16;	author deraadt;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	98.07.12.17.13.54;	author millert;	state Exp;
branches;
next	;


desc
@@


1.7
log
@remove sendmail 8.9.3
@
text
@/*
 * Copyright (c) 1998 Sendmail, Inc.  All rights reserved.
 * Copyright (c) 1983 Eric P. Allman.  All rights reserved.
 * Copyright (c) 1988, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * By using this file, you agree to the terms and conditions set
 * forth in the LICENSE file which can be found at the top level of
 * the sendmail distribution.
 *
 */

#ifndef lint
static char copyright[] =
"@@(#) Copyright (c) 1988, 1993\n\
	The Regents of the University of California.  All rights reserved.\n";
#endif /* not lint */

#ifndef lint
static char sccsid[] = "@@(#)praliases.c	8.21 (Berkeley) 12/27/1998";
#endif /* not lint */

#if !defined(NDBM) && !defined(NEWDB)
  ERROR README:	You must define one of NDBM or NEWDB in order to compile
  ERROR README:	praliases.
#endif

#ifdef NDBM
# include <ndbm.h>
#endif
#ifndef NOT_SENDMAIL
# define NOT_SENDMAIL
#endif
#include <sendmail.h>
#include <pathnames.h>
#ifdef NEWDB
# include <db.h>
# ifndef DB_VERSION_MAJOR
#  define DB_VERSION_MAJOR 1
# endif
#endif

#if defined(IRIX64) || defined(IRIX5) || defined(IRIX6) || \
    defined(BSD4_4) || defined(__osf__) || defined(__GNU_LIBRARY__)
# ifndef HASSTRERROR
#  define HASSTRERROR	1	/* has strerror(3) */
# endif
#endif

#if !HASSTRERROR
extern char	*strerror __P((int));
#endif

static void praliases __P((char *, int, char **));
#ifdef NDBM
static void praliases_dbm __P((char *, int, char **));
#endif

int
main(argc, argv)
	int argc;
	char **argv;
{
	extern char *optarg;
	extern int optind;
	char *cfile;
#if _FFR_GRAB_ALIASFILE_OPTION
	char *filename = NULL;
#else
	char *filename = "/etc/aliases";
#endif
	FILE *cfp;
	int ch;
	char afilebuf[MAXLINE];
	char buf[MAXLINE];

	cfile = _PATH_SENDMAILCF;
#if _FFR_GRAB_ALIASFILE_OPTION
	while ((ch = getopt(argc, argv, "C:f:")) != EOF)
#else
	while ((ch = getopt(argc, argv, "f:")) != EOF)
#endif
	{
		switch ((char)ch) {
		case 'C':
			cfile = optarg;
			break;
		case 'f':
			filename = optarg;
			break;
		case '?':
		default:
			(void)fprintf(stderr,
#if _FFR_GRAB_ALIASFILE_OPTION
				"usage: praliases [-C cffile] [-f aliasfile]\n");
#else
				"usage: praliases [-f aliasfile]\n");
#endif
			exit(EX_USAGE);
		}
	}
	argc -= optind;
	argv += optind;

	if (filename != NULL)
	{
		praliases(filename, argc, argv);
		exit(EX_OK);
	}

	if ((cfp = fopen(cfile, "r")) == NULL)
	{
		fprintf(stderr, "praliases: ");
		perror(cfile);
		exit(EX_NOINPUT);
	}

	while (fgets(buf, sizeof(buf), cfp) != NULL)
	{
		register char *b, *p;

		b = buf;
		switch (*b++)
		{
		  case 'O':		/* option -- see if alias file */
			if (strncasecmp(b, " AliasFile", 10) == 0 &&
			    !(isascii(b[10]) && isalnum(b[10])))
			{
				/* new form -- find value */
				b = strchr(b, '=');
				if (b == NULL)
					continue;
				while (isascii(*++b) && isspace(*b))
					continue;
			}
			else if (*b++ != 'A')
			{
				/* something else boring */
				continue;
			}

			/* this is the A or AliasFile option -- save it */
			if (strlen(b) >= sizeof afilebuf)
			{
				fprintf(stderr,
					"AliasFile filename too long: %.30s...\n",
					b);
				(void) fclose(cfp);
				exit(EX_CONFIG);
			}
			strcpy(afilebuf, b);
			b = afilebuf;

			for (p = b; p != NULL; )
			{
				while (isascii(*p) && isspace(*p))
					p++;
				if (*p == '\0')
					break;
				b = p;

				p = strpbrk(p, " ,/");
				/* find end of spec */
				if (p != NULL)
					p = strpbrk(p, ",\n");
				if (p != NULL)
					*p++ = '\0';

				praliases(b, argc, argv);
			}

		  default:
			continue;
		}
	}
	(void) fclose(cfp);
	exit(EX_OK);
}

static void
praliases(filename, argc, argv)
	char *filename;
	int  argc;
	char **argv;
{
#ifdef NEWDB
	DB *db;
	DBT newdbkey, newdbcontent;
	char buf[MAXNAME];
#endif
	char *class;

	class = strchr(filename, ':');
	if (class != NULL)
	{
		if (strncasecmp(filename, "dbm:", 4) == 0)
		{
#ifdef NDBM
			praliases_dbm(class + 1, argc, argv);
			return;
#else
			fprintf(stderr, "class dbm not available\n");
			exit(EX_DATAERR);
#endif
		}
		filename = class + 1;
	}
#ifdef NEWDB
	if (strlen(filename) + 4 >= sizeof buf)
	{
		fprintf(stderr, "Alias filename too long: %.30s...\n", filename);
		exit(EX_USAGE);
	}
	(void) strcpy(buf, filename);
	(void) strcat(buf, ".db");
# if DB_VERSION_MAJOR < 2
	db = dbopen(buf, O_RDONLY, 0444, DB_HASH, NULL);
# else
	db = NULL;
	errno = db_open(buf, DB_HASH, DB_RDONLY, 0444, NULL, NULL, &db);
# endif
	if (db != NULL)
	{
		if (!argc)
		{
# if DB_VERSION_MAJOR > 1
			DBC *dbc;
# endif
			bzero(&newdbkey, sizeof newdbkey);
			bzero(&newdbcontent, sizeof newdbcontent);

# if DB_VERSION_MAJOR < 2
			while(!db->seq(db, &newdbkey, &newdbcontent, R_NEXT))
# else
#  if DB_VERSION_MAJOR > 2 || DB_VERSION_MINOR >=6
			if ((errno = db->cursor(db, NULL, &dbc, 0)) == 0)
#  else
			if ((errno = db->cursor(db, NULL, &dbc)) == 0)
#  endif
			{
				while ((errno = dbc->c_get(dbc, &newdbkey,
							   &newdbcontent,
							   DB_NEXT)) == 0)
# endif
				printf("%.*s:%.*s\n",
					(int) newdbkey.size,
					(char *) newdbkey.data,
					(int) newdbcontent.size,
					(char *) newdbcontent.data);
# if DB_VERSION_MAJOR > 1
				(void) dbc->c_close(dbc);
			}
			else
			{
				fprintf(stderr,
					"praliases: %s: Could not set cursor: %s\n",
					buf, strerror(errno));
				errno = db->close(db, 0);
				exit(EX_DATAERR);
			}
# endif
		}
		else for (; *argv; ++argv)
		{
			bzero(&newdbkey, sizeof newdbkey);
			bzero(&newdbcontent, sizeof newdbcontent);
			newdbkey.data = *argv;
			newdbkey.size = strlen(*argv) + 1;
# if DB_VERSION_MAJOR < 2
			if (!db->get(db, &newdbkey, &newdbcontent, 0))
# else
			if ((errno = db->get(db, NULL, &newdbkey,
					     &newdbcontent, 0)) == 0)
# endif
				printf("%s:%.*s\n", (char *) newdbkey.data,
					(int) newdbcontent.size,
					(char *) newdbcontent.data);
			else
				printf("%s: No such key\n",
					(char *) newdbkey.data);
		}
# if DB_VERSION_MAJOR < 2
		(void)db->close(db);
# else
		errno = db->close(db, 0);
# endif
	}
	else
	{
#endif
#ifdef NDBM
		praliases_dbm(filename, argc, argv);
#endif
#ifdef NEWDB
	}
#endif
}

#ifdef NDBM
static void
praliases_dbm(filename, argc, argv)
	char *filename;
	int  argc;
	char **argv;
{
	DBM *dbp;
	datum content, key;

	if ((dbp = dbm_open(filename, O_RDONLY, 0)) == NULL)
	{
		(void)fprintf(stderr,
		    "praliases: %s: %s\n", filename, strerror(errno));
		exit(EX_OSFILE);
	}
	if (!argc)
	{
		for (key = dbm_firstkey(dbp);
		    key.dptr != NULL; key = dbm_nextkey(dbp))
		{
			content = dbm_fetch(dbp, key);
			(void)printf("%.*s:%.*s\n",
				(int) key.dsize, key.dptr,
				(int) content.dsize, content.dptr);
		}
	}
	else
	{
		for (; *argv; ++argv)
		{
			/*
			**  Use the sendmail adaptive algorithm of trying
			**  the key first without, then if needed with,
			**  the terminating NULL byte.
			*/
			key.dptr = *argv;
			key.dsize = strlen(*argv);
			content = dbm_fetch(dbp, key);
			if (content.dptr == NULL)
			{
				key.dsize++;
				content = dbm_fetch(dbp, key);
			}
			if (content.dptr != NULL)
				(void)printf("%s:%.*s\n", key.dptr,
					(int) content.dsize, content.dptr);
			else
				(void)printf("%s: No such key\n", key.dptr);
		}
	}
	dbm_close(dbp);
}
#endif

#if !HASSTRERROR

char *
strerror(eno)
	int eno;
{
	extern int sys_nerr;
	extern char *sys_errlist[];
	static char ebuf[60];

	if (eno >= 0 && eno < sys_nerr)
		return sys_errlist[eno];
	(void) sprintf(ebuf, "Error %d", eno);
	return ebuf;
}

#endif /* !HASSTRERROR */
@


1.6
log
@sendmail 8.9.2
@
text
@@


1.5
log
@something hosed the sendmail import; fix up by hand
@
text
@d20 1
a20 1
static char sccsid[] = "@@(#)praliases.c	8.17 (Berkeley) 6/25/98";
d35 1
d54 5
d66 5
a70 3
#ifdef NDBM
	DBM *dbp;
	datum content, key;
d72 1
a72 1
	char *filename;
d74 2
a75 5
#ifdef NEWDB
	DB *db;
	DBT newdbkey, newdbcontent;
	char buf[MAXNAME];
#endif
d77 4
a80 1
	filename = "/etc/aliases";
d82 6
a87 1
		switch((char)ch) {
d93 6
a98 1
			(void)fprintf(stderr, "usage: praliases [-f file]\n");
d101 1
d105 103
d224 2
a225 1
		if (!argc) {
d235 3
d239 1
d258 1
d263 2
a264 1
		else for (; *argv; ++argv) {
d288 8
a295 1
	else {
d297 2
d300 24
a323 4
		if ((dbp = dbm_open(filename, O_RDONLY, 0)) == NULL) {
			(void)fprintf(stderr,
			    "praliases: %s: %s\n", filename, strerror(errno));
			exit(EX_OSFILE);
d325 16
a340 3
		if (!argc)
			for (key = dbm_firstkey(dbp);
			    key.dptr != NULL; key = dbm_nextkey(dbp)) {
a341 3
				(void)printf("%.*s:%.*s\n",
					(int) key.dsize, key.dptr,
					(int) content.dsize, content.dptr);
d343 1
a343 7
		else for (; *argv; ++argv) {
			key.dptr = *argv;
			key.dsize = strlen(*argv) + 1;
			content = dbm_fetch(dbp, key);
			if (!content.dptr)
				(void)printf("%s: No such key\n", key.dptr);
			else
d346 2
a348 3
		dbm_close(dbp);
#endif
#ifdef NEWDB
d350 2
a352 2
	exit(EX_OK);
}
@


1.4
log
@Sendmail 8.8.6.
@
text
@d2 2
a3 1
 * Copyright (c) 1983 Eric P. Allman
d7 3
a9 15
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
a10 11
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
d20 1
a20 1
static char sccsid[] = "@@(#)praliases.c	8.5 (Berkeley) 5/28/97";
d23 11
a33 2
#include <ndbm.h>
#define NOT_SENDMAIL
d36 15
a50 1
#include <db.h>
d60 1
d63 1
d67 1
a67 1
	const DB *db;
d73 1
a73 1
	while ((ch = getopt(argc, argv, "f:")) != -1)
d94 8
a101 1
	if (db = dbopen(buf, O_RDONLY, 0444 , DB_HASH, NULL)) {
d103 7
d111 7
d119 15
a133 2
					newdbkey.size, newdbkey.data,
					newdbcontent.size, newdbcontent.data);
d136 2
d140 1
d142 7
a148 2
				printf("%s:%.*s\n", newdbkey.data,
					newdbcontent.size, newdbcontent.data);
d151 1
a151 1
					newdbkey.data);
d153 5
d161 1
d172 2
a173 2
					key.dsize, key.dptr,
					content.dsize, content.dptr);
d183 1
a183 1
					content.dsize, content.dptr);
d185 2
d192 18
@


1.3
log
@getopt(3) returns -1 when out of args, not EOF, whee!
@
text
@d42 1
a42 1
static char sccsid[] = "@@(#)praliases.c	8.4 (Berkeley) 9/25/96";
d84 5
@


1.2
log
@Update to Sendmail 8.8.4, plus recent patches, plus OpenBSD support.
Also include entire example configuration subset.
Includes smrsh (using /usr/libexec/sm.bin).

Of the top of my head, the only things I removed from the distribution were
contrib/mail.local.linux, src/Makefiles, all the *.0 and *.ps files.
Our praliases man page replaces the distributed one, ours is better.
@
text
@d70 1
a70 1
	while ((ch = getopt(argc, argv, "f:")) != EOF)
@


1.1
log
@Initial revision
@
text
@d42 1
a42 1
static char sccsid[] = "@@(#)praliases.c	8.3 (Berkeley) 3/6/94";
d46 1
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@


1.1.1.2
log
@sendmail 8.9.1
@
text
@d2 1
a2 2
 * Copyright (c) 1998 Sendmail, Inc.  All rights reserved.
 * Copyright (c) 1983 Eric P. Allman.  All rights reserved.
d6 15
a20 3
 * By using this file, you agree to the terms and conditions set
 * forth in the LICENSE file which can be found at the top level of
 * the sendmail distribution.
d22 11
d42 1
a42 1
static char sccsid[] = "@@(#)praliases.c	8.17 (Berkeley) 6/25/98";
d45 1
a45 11
#if !defined(NDBM) && !defined(NEWDB)
  ERROR README:	You must define one of NDBM or NEWDB in order to compile
  ERROR README:	praliases.
#endif

#ifdef NDBM
# include <ndbm.h>
#endif
#ifndef NOT_SENDMAIL
# define NOT_SENDMAIL
#endif
d48 1
a48 15
# include <db.h>
# ifndef DB_VERSION_MAJOR
#  define DB_VERSION_MAJOR 1
# endif
#endif

#if defined(IRIX64) || defined(IRIX5) || defined(IRIX6) || \
    defined(BSD4_4) || defined(__osf__) || defined(__GNU_LIBRARY__)
# ifndef HASSTRERROR
#  define HASSTRERROR	1	/* has strerror(3) */
# endif
#endif

#if !HASSTRERROR
extern char	*strerror __P((int));
a57 1
#ifdef NDBM
a59 1
#endif
d63 1
a63 1
	DB *db;
a82 5
	if (strlen(filename) + 4 >= sizeof buf)
	{
		fprintf(stderr, "Alias filename too long: %.30s...\n", filename);
		exit(EX_USAGE);
	}
d85 1
a85 8
# if DB_VERSION_MAJOR < 2
	db = dbopen(buf, O_RDONLY, 0444, DB_HASH, NULL);
# else
	db = NULL;
	errno = db_open(buf, DB_HASH, DB_RDONLY, 0444, NULL, NULL, &db);
# endif
	if (db != NULL)
	{
a86 7
# if DB_VERSION_MAJOR > 1
			DBC *dbc;
# endif
			bzero(&newdbkey, sizeof newdbkey);
			bzero(&newdbcontent, sizeof newdbcontent);

# if DB_VERSION_MAJOR < 2
a87 7
# else
			if ((errno = db->cursor(db, NULL, &dbc)) == 0)
			{
				while ((errno = dbc->c_get(dbc, &newdbkey,
							   &newdbcontent,
							   DB_NEXT)) == 0)
# endif
d89 2
a90 15
					(int) newdbkey.size,
					(char *) newdbkey.data,
					(int) newdbcontent.size,
					(char *) newdbcontent.data);
# if DB_VERSION_MAJOR > 1
				(void) dbc->c_close(dbc);
			}
			else
			{
				fprintf(stderr,
					"praliases: %s: Could not set cursor: %s\n",
					buf, strerror(errno));
				exit(EX_DATAERR);
			}
# endif
a92 2
			bzero(&newdbkey, sizeof newdbkey);
			bzero(&newdbcontent, sizeof newdbcontent);
a94 1
# if DB_VERSION_MAJOR < 2
d96 2
a97 7
# else
			if ((errno = db->get(db, NULL, &newdbkey,
					     &newdbcontent, 0)) == 0)
# endif
				printf("%s:%.*s\n", (char *) newdbkey.data,
					(int) newdbcontent.size,
					(char *) newdbcontent.data);
d100 1
a100 1
					(char *) newdbkey.data);
a101 5
# if DB_VERSION_MAJOR < 2
		(void)db->close(db);
# else
		errno = db->close(db, 0);
# endif
a104 1
#ifdef NDBM
d115 2
a116 2
					(int) key.dsize, key.dptr,
					(int) content.dsize, content.dptr);
d126 1
a126 1
					(int) content.dsize, content.dptr);
a127 2
		dbm_close(dbp);
#endif
a132 18

#if !HASSTRERROR

char *
strerror(eno)
	int eno;
{
	extern int sys_nerr;
	extern char *sys_errlist[];
	static char ebuf[60];

	if (eno >= 0 && eno < sys_nerr)
		return sys_errlist[eno];
	(void) sprintf(ebuf, "Error %d", eno);
	return ebuf;
}

#endif /* !HASSTRERROR */
@

