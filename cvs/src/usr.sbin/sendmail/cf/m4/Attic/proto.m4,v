head	1.11;
access;
symbols
	OPENBSD_2_6:1.10.0.4
	OPENBSD_2_6_BASE:1.10
	OPENBSD_2_5:1.10.0.2
	OPENBSD_2_5_BASE:1.10
	OPENBSD_2_4:1.7.0.2
	OPENBSD_2_4_BASE:1.7
	sendmail_8_9_1:1.1.1.2
	UCB:1.1.1
	OPENBSD_2_3:1.6.0.4
	OPENBSD_2_3_BASE:1.6
	OPENBSD_2_2:1.6.0.2
	OPENBSD_2_2_BASE:1.6
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@# @;


1.11
date	2000.04.18.04.56.59;	author millert;	state dead;
branches;
next	1.10;

1.10
date	99.02.05.05.59.14;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	99.01.21.19.37.21;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	99.01.01.20.33.01;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	98.07.12.19.42.28;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	97.08.04.02.17.38;	author downsj;	state Exp;
branches;
next	1.5;

1.5
date	97.07.15.07.23.46;	author downsj;	state Exp;
branches;
next	1.4;

1.4
date	97.01.22.01.06.52;	author downsj;	state Exp;
branches;
next	1.3;

1.3
date	96.12.14.21.15.56;	author downsj;	state Exp;
branches;
next	1.2;

1.2
date	96.01.29.01.41.49;	author dm;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.48.11;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.48.11;	author deraadt;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	98.07.12.17.12.44;	author millert;	state Exp;
branches;
next	;


desc
@@


1.11
log
@remove sendmail 8.9.3
@
text
@divert(-1)
#
# Copyright (c) 1998 Sendmail, Inc.  All rights reserved.
# Copyright (c) 1983, 1995 Eric P. Allman.  All rights reserved.
# Copyright (c) 1988, 1993
#	The Regents of the University of California.  All rights reserved.
#
# By using this file, you agree to the terms and conditions set
# forth in the LICENSE file which can be found at the top level of
# the sendmail distribution.
#
#
divert(0)

VERSIONID(`@@(#)proto.m4	8.243 (Berkeley) 2/2/1999')

MAILER(local)dnl

# level 8 config file format
V8/ifdef(`VENDOR_NAME', `VENDOR_NAME', `Berkeley')
divert(-1)

# do some sanity checking
ifdef(`__OSTYPE__',,
	`errprint(`*** ERROR: No system type defined (use OSTYPE macro)')')

# pick our default mailers
ifdef(`confSMTP_MAILER',, `define(`confSMTP_MAILER', `esmtp')')
ifdef(`confLOCAL_MAILER',, `define(`confLOCAL_MAILER', `local')')
ifdef(`confRELAY_MAILER',,
	`define(`confRELAY_MAILER',
		`ifdef(`_MAILER_smtp_', `relay',
			`ifdef(`_MAILER_uucp', `uucp-new', `unknown')')')')
ifdef(`confUUCP_MAILER',, `define(`confUUCP_MAILER', `uucp-old')')
define(`_SMTP_', `confSMTP_MAILER')dnl		for readability only
define(`_LOCAL_', `confLOCAL_MAILER')dnl	for readability only
define(`_RELAY_', `confRELAY_MAILER')dnl	for readability only
define(`_UUCP_', `confUUCP_MAILER')dnl		for readability only

# set our default hashed database type
ifdef(`DATABASE_MAP_TYPE',, `define(`DATABASE_MAP_TYPE', `hash')')

# back compatibility with old config files
ifdef(`confDEF_GROUP_ID',
	`errprint(`*** confDEF_GROUP_ID is obsolete.')
	 errprint(`    Use confDEF_USER_ID with a colon in the value instead.')')
ifdef(`confREAD_TIMEOUT',
	`errprint(`*** confREAD_TIMEOUT is obsolete.')
	 errprint(`    Use individual confTO_<timeout> parameters instead.')')
ifdef(`confMESSAGE_TIMEOUT',
	`define(`_ARG_', index(confMESSAGE_TIMEOUT, /))
	 ifelse(_ARG_, -1,
		`define(`confTO_QUEUERETURN', confMESSAGE_TIMEOUT)',
		`define(`confTO_QUEUERETURN',
			substr(confMESSAGE_TIMEOUT, 0, _ARG_))
		 define(`confTO_QUEUEWARN',
			substr(confMESSAGE_TIMEOUT, eval(_ARG_+1)))')')
ifdef(`confMIN_FREE_BLOCKS', `ifelse(index(confMIN_FREE_BLOCKS, /), -1,,
	`errprint(`*** compound confMIN_FREE_BLOCKS is obsolete.')
	 errprint(`    Use confMAX_MESSAGE_SIZE for the second part of the value.')')')

# clean option definitions below....
define(`_OPTION', `ifdef(`$2', `O $1=$2', `#O $1`'ifelse($3, `',, `=$3')')')dnl

divert(0)dnl

# override file safeties - setting this option compromises system security
# need to set this now for the sake of class files
_OPTION(DontBlameSendmail, `confDONT_BLAME_SENDMAIL', safe)

##################
#   local info   #
##################

Cwlocalhost
ifdef(`USE_CW_FILE',
`# file containing names of hosts for which we receive email
Fw`'confCW_FILE',
	`dnl')

# my official domain name
# ... `define' this only if sendmail cannot automatically determine your domain
ifdef(`confDOMAIN_NAME', `Dj`'confDOMAIN_NAME', `#Dj$w.Foo.COM')

ifdef(`_NULL_CLIENT_ONLY_', `divert(-1)')dnl

CP.

ifdef(`UUCP_RELAY',
`# UUCP relay host
DY`'UUCP_RELAY
CPUUCP

')dnl
ifdef(`BITNET_RELAY',
`#  BITNET relay host
DB`'BITNET_RELAY
CPBITNET

')dnl
ifdef(`DECNET_RELAY',
`define(`_USE_DECNET_SYNTAX_', 1)dnl
# DECnet relay host
DC`'DECNET_RELAY
CPDECNET

')dnl
ifdef(`FAX_RELAY',
`# FAX relay host
DF`'FAX_RELAY
CPFAX

')dnl
# "Smart" relay host (may be null)
DS`'ifdef(`SMART_HOST', SMART_HOST)

ifdef(`LUSER_RELAY', `dnl
# place to which unknown users should be forwarded
Kuser user -m -a<>
DL`'LUSER_RELAY',
`dnl')

# operators that cannot be in local usernames (i.e., network indicators)
CO @@ % ifdef(`_NO_UUCP_', `', `!')

# a class with just dot (for identifying canonical names)
C..

# a class with just a left bracket (for identifying domain literals)
C[[

ifdef(`MAILER_TABLE', `dnl
# Mailer table (overriding domains)
Kmailertable MAILER_TABLE',
`dnl')

ifdef(`DOMAIN_TABLE', `dnl
# Domain table (adding domains)
Kdomaintable DOMAIN_TABLE',
`dnl')

ifdef(`GENERICS_TABLE', `dnl
# Generics table (mapping outgoing addresses)
Kgenerics GENERICS_TABLE',
`dnl')

ifdef(`UUDOMAIN_TABLE', `dnl
# UUCP domain table
Kuudomain UUDOMAIN_TABLE',
`dnl')

ifdef(`BITDOMAIN_TABLE', `dnl
# BITNET mapping table
Kbitdomain BITDOMAIN_TABLE',
`dnl')

ifdef(`VIRTUSER_TABLE', `dnl
# Virtual user table (maps incoming users)
Kvirtuser VIRTUSER_TABLE',
`dnl')

ifdef(`ACCESS_TABLE', `dnl
# Access list database (for spam stomping)
Kaccess ACCESS_TABLE',
`dnl')

ifdef(`_RELAY_MX_SERVED_', `dnl
# MX map (to allow relaying to hosts that we MX for)
Kmxserved bestmx -z: -T<TEMP>',
`dnl')

ifdef(`_ACCEPT_UNRESOLVABLE_DOMAINS_',`dnl',`dnl
# Resolve map (to check if a host exists in check_mail)
Kresolve host -a<OK> -T<TEMP>')

ifdef(`confCR_FILE', `dnl
# Hosts that will permit relaying ($=R)
FR`'confCR_FILE',
`dnl')

# who I send unqualified names to (null means deliver locally)
DR`'ifdef(`LOCAL_RELAY', LOCAL_RELAY)

# who gets all local email traffic ($R has precedence for unqualified names)
DH`'ifdef(`MAIL_HUB', MAIL_HUB)

# dequoting map
Kdequote dequote

divert(0)dnl	# end of nullclient diversion
# class E: names that should be exposed as from this host, even if we masquerade
ifdef(`_NULL_CLIENT_ONLY_', `#',
`# class L: names that should be delivered locally, even if we have a relay
# class M: domains that should be converted to $M
#CL root
')CE root
undivert(5)dnl

# who I masquerade as (null for no masquerading) (see also $=M)
DM`'ifdef(`MASQUERADE_NAME', MASQUERADE_NAME)

# my name for error messages
ifdef(`confMAILER_NAME', `Dn`'confMAILER_NAME', `#DnMAILER-DAEMON')

undivert(6)dnl
include(_CF_DIR_`m4/version.m4')

###############
#   Options   #
###############

# strip message body to 7 bits on input?
_OPTION(SevenBitInput, `confSEVEN_BIT_INPUT')

# 8-bit data handling
_OPTION(EightBitMode, `confEIGHT_BIT_HANDLING', adaptive)

ifdef(`_NULL_CLIENT_ONLY_', `dnl', `
# wait for alias file rebuild (default units: minutes)
_OPTION(AliasWait, `confALIAS_WAIT', 5m)

# location of alias file
_OPTION(AliasFile, `ALIAS_FILE', ifdef(`_USE_ETC_MAIL_', /etc/mail/aliases, /etc/aliases))
')
# minimum number of free blocks on filesystem
_OPTION(MinFreeBlocks, `confMIN_FREE_BLOCKS', 100)

# maximum message size
_OPTION(MaxMessageSize, `confMAX_MESSAGE_SIZE', 1000000)

# substitution for space (blank) characters
_OPTION(BlankSub, `confBLANK_SUB', _)

# avoid connecting to "expensive" mailers on initial submission?
_OPTION(HoldExpensive, `confCON_EXPENSIVE')

# checkpoint queue runs after every N successful deliveries
_OPTION(CheckpointInterval, `confCHECKPOINT_INTERVAL', 10)

# default delivery mode
_OPTION(DeliveryMode, `confDELIVERY_MODE', background)

# automatically rebuild the alias database?
_OPTION(AutoRebuildAliases, `confAUTO_REBUILD')

# error message header/file
_OPTION(ErrorHeader, `confERROR_MESSAGE', ifdef(`_USE_ETC_MAIL_', /etc/mail/error-header, /etc/sendmail.oE))

# error mode
_OPTION(ErrorMode, `confERROR_MODE', print)

# save Unix-style "From_" lines at top of header?
_OPTION(SaveFromLine, `confSAVE_FROM_LINES')

# temporary file mode
_OPTION(TempFileMode, `confTEMP_FILE_MODE', 0600)

# match recipients against GECOS field?
_OPTION(MatchGECOS, `confMATCH_GECOS')

# maximum hop count
_OPTION(MaxHopCount, `confMAX_HOP', 17)

# location of help file
O HelpFile=ifdef(`HELP_FILE', HELP_FILE, ifdef(`_USE_ETC_MAIL_', /etc/mail/helpfile, /usr/lib/sendmail.hf))

# ignore dots as terminators in incoming messages?
_OPTION(IgnoreDots, `confIGNORE_DOTS')

# name resolver options
_OPTION(ResolverOptions, `confBIND_OPTS', +AAONLY)

# deliver MIME-encapsulated error messages?
_OPTION(SendMimeErrors, `confMIME_FORMAT_ERRORS')

# Forward file search path
_OPTION(ForwardPath, `confFORWARD_PATH', /var/forward/$u:$z/.forward.$w:$z/.forward)

# open connection cache size
_OPTION(ConnectionCacheSize, `confMCI_CACHE_SIZE', 2)

# open connection cache timeout
_OPTION(ConnectionCacheTimeout, `confMCI_CACHE_TIMEOUT', 5m)

# persistent host status directory
_OPTION(HostStatusDirectory, `confHOST_STATUS_DIRECTORY', .hoststat)

# single thread deliveries (requires HostStatusDirectory)?
_OPTION(SingleThreadDelivery, `confSINGLE_THREAD_DELIVERY')

# use Errors-To: header?
_OPTION(UseErrorsTo, `confUSE_ERRORS_TO')

# log level
_OPTION(LogLevel, `confLOG_LEVEL', 10)

# send to me too, even in an alias expansion?
_OPTION(MeToo, `confME_TOO')

# verify RHS in newaliases?
_OPTION(CheckAliases, `confCHECK_ALIASES')

# default messages to old style headers if no special punctuation?
_OPTION(OldStyleHeaders, `confOLD_STYLE_HEADERS')

# SMTP daemon options
_OPTION(DaemonPortOptions, `confDAEMON_OPTIONS', Port=esmtp)

# privacy flags
_OPTION(PrivacyOptions, `confPRIVACY_FLAGS', authwarnings)

# who (if anyone) should get extra copies of error messages
_OPTION(PostMasterCopy, `confCOPY_ERRORS_TO', Postmaster)

# slope of queue-only function
_OPTION(QueueFactor, `confQUEUE_FACTOR', 600000)

# queue directory
O QueueDirectory=ifdef(`QUEUE_DIR', QUEUE_DIR, /var/spool/mqueue)

# timeouts (many of these)
_OPTION(Timeout.initial, `confTO_INITIAL', 5m)
_OPTION(Timeout.connect, `confTO_CONNECT', 5m)
_OPTION(Timeout.iconnect, `confTO_ICONNECT', 5m)
_OPTION(Timeout.helo, `confTO_HELO', 5m)
_OPTION(Timeout.mail, `confTO_MAIL', 10m)
_OPTION(Timeout.rcpt, `confTO_RCPT', 1h)
_OPTION(Timeout.datainit, `confTO_DATAINIT', 5m)
_OPTION(Timeout.datablock, `confTO_DATABLOCK', 1h)
_OPTION(Timeout.datafinal, `confTO_DATAFINAL', 1h)
_OPTION(Timeout.rset, `confTO_RSET', 5m)
_OPTION(Timeout.quit, `confTO_QUIT', 2m)
_OPTION(Timeout.misc, `confTO_MISC', 2m)
_OPTION(Timeout.command, `confTO_COMMAND', 1h)
_OPTION(Timeout.ident, `confTO_IDENT', 30s)
_OPTION(Timeout.fileopen, `confTO_FILEOPEN', 60s)
_OPTION(Timeout.queuereturn, `confTO_QUEUERETURN', 5d)
_OPTION(Timeout.queuereturn.normal, `confTO_QUEUERETURN_NORMAL', 5d)
_OPTION(Timeout.queuereturn.urgent, `confTO_QUEUERETURN_URGENT', 2d)
_OPTION(Timeout.queuereturn.non-urgent, `confTO_QUEUERETURN_NONURGENT', 7d)
_OPTION(Timeout.queuewarn, `confTO_QUEUEWARN', 4h)
_OPTION(Timeout.queuewarn.normal, `confTO_QUEUEWARN_NORMAL', 4h)
_OPTION(Timeout.queuewarn.urgent, `confTO_QUEUEWARN_URGENT', 1h)
_OPTION(Timeout.queuewarn.non-urgent, `confTO_QUEUEWARN_NONURGENT', 12h)
_OPTION(Timeout.hoststatus, `confTO_HOSTSTATUS', 30m)

# should we not prune routes in route-addr syntax addresses?
_OPTION(DontPruneRoutes, `confDONT_PRUNE_ROUTES')

# queue up everything before forking?
_OPTION(SuperSafe, `confSAFE_QUEUE')

# status file
O StatusFile=ifdef(`STATUS_FILE', `STATUS_FILE', ifdef(`_USE_ETC_MAIL_', /etc/mail/statistics, /etc/sendmail.st))

# time zone handling:
#  if undefined, use system default
#  if defined but null, use TZ envariable passed in
#  if defined and non-null, use that info
ifelse(confTIME_ZONE, `USE_SYSTEM', `#O TimeZoneSpec=',
	confTIME_ZONE, `USE_TZ', `O TimeZoneSpec=',
	`O TimeZoneSpec=confTIME_ZONE')

# default UID (can be username or userid:groupid)
_OPTION(DefaultUser, `confDEF_USER_ID', mailnull)

# list of locations of user database file (null means no lookup)
_OPTION(UserDatabaseSpec, `confUSERDB_SPEC', ifdef(`_USE_ETC_MAIL_', /etc/mail/userdb, /etc/userdb))

# fallback MX host
_OPTION(FallbackMXhost, `confFALLBACK_MX', fall.back.host.net)

# if we are the best MX host for a site, try it directly instead of config err
_OPTION(TryNullMXList, `confTRY_NULL_MX_LIST')

# load average at which we just queue messages
_OPTION(QueueLA, `confQUEUE_LA', 8)

# load average at which we refuse connections
_OPTION(RefuseLA, `confREFUSE_LA', 12)

# maximum number of children we allow at one time
_OPTION(MaxDaemonChildren, `confMAX_DAEMON_CHILDREN', 12)

# maximum number of new connections per second
_OPTION(ConnectionRateThrottle, `confCONNECTION_RATE_THROTTLE', 3)

# work recipient factor
_OPTION(RecipientFactor, `confWORK_RECIPIENT_FACTOR', 30000)

# deliver each queued job in a separate process?
_OPTION(ForkEachJob, `confSEPARATE_PROC')

# work class factor
_OPTION(ClassFactor, `confWORK_CLASS_FACTOR', 1800)

# work time factor
_OPTION(RetryFactor, `confWORK_TIME_FACTOR', 90000)

# shall we sort the queue by hostname first?
_OPTION(QueueSortOrder, `confQUEUE_SORT_ORDER', priority)

# minimum time in queue before retry
_OPTION(MinQueueAge, `confMIN_QUEUE_AGE', 30m)

# default character set
_OPTION(DefaultCharSet, `confDEF_CHAR_SET', iso-8859-1)

# service switch file (ignored on Solaris, Ultrix, OSF/1, others)
_OPTION(ServiceSwitchFile, `confSERVICE_SWITCH_FILE', ifdef(`_USE_ETC_MAIL_', /etc/mail/service.switch, /etc/service.switch))

# hosts file (normally /etc/hosts)
_OPTION(HostsFile, `confHOSTS_FILE', /etc/hosts)

# dialup line delay on connection failure
_OPTION(DialDelay, `confDIAL_DELAY', 10s)

# action to take if there are no recipients in the message
_OPTION(NoRecipientAction, `confNO_RCPT_ACTION', add-to-undisclosed)

# chrooted environment for writing to files
_OPTION(SafeFileEnvironment, `confSAFE_FILE_ENV', /arch)

# are colons OK in addresses?
_OPTION(ColonOkInAddr, `confCOLON_OK_IN_ADDR')

# how many jobs can you process in the queue?
_OPTION(MaxQueueRunSize, `confMAX_QUEUE_RUN_SIZE', 10000)

# shall I avoid expanding CNAMEs (violates protocols)?
_OPTION(DontExpandCnames, `confDONT_EXPAND_CNAMES')

# SMTP initial login message (old $e macro)
_OPTION(SmtpGreetingMessage, `confSMTP_LOGIN_MSG')

# UNIX initial From header format (old $l macro)
_OPTION(UnixFromLine, `confFROM_LINE')

# From: lines that have embedded newlines are unwrapped onto one line
_OPTION(SingleLineFromHeader, `confSINGLE_LINE_FROM_HEADER', False)

# Allow HELO SMTP command that does not `include' a host name
_OPTION(AllowBogusHELO, `confALLOW_BOGUS_HELO', False)

# Characters to be quoted in a full name phrase (@@,;:\()[] are automatic)
_OPTION(MustQuoteChars, `confMUST_QUOTE_CHARS', .)

# delimiter (operator) characters (old $o macro)
_OPTION(OperatorChars, `confOPERATORS')

# shall I avoid calling initgroups(3) because of high NIS costs?
_OPTION(DontInitGroups, `confDONT_INIT_GROUPS')

# are group-writable `:include:' and .forward files (un)trustworthy?
_OPTION(UnsafeGroupWrites, `confUNSAFE_GROUP_WRITES')

# where do errors that occur when sending errors get sent?
_OPTION(DoubleBounceAddress, `confDOUBLE_BOUNCE_ADDRESS', postmaster)

# what user id do we assume for the majority of the processing?
_OPTION(RunAsUser, `confRUN_AS_USER', sendmail)

# maximum number of recipients per SMTP envelope
_OPTION(MaxRecipientsPerMessage, `confMAX_RCPTS_PER_MESSAGE', 100)

# shall we get local names from our installed interfaces?
_OPTION(DontProbeInterfaces, `confDONT_PROBE_INTERFACES')

ifdef(`confTRUSTED_USER',
`# Trusted user for file ownership and starting the daemon
O TrustedUser=confTRUSTED_USER
')
ifdef(`confCONTROL_SOCKET_NAME',
`# Control socket for daemon management
O ControlSocketName=confCONTROL_SOCKET_NAME
')
ifdef(`confMAX_MIME_HEADER_LENGTH',
`# Maximum MIME header length to protect MUAs
O MaxMimeHeaderLength=confMAX_MIME_HEADER_LENGTH
')
ifdef(`confMAX_HEADERS_LENGTH',
`# Maximum length of the sum of all headers
O MaxHeadersLength=confMAX_HEADERS_LENGTH
')

###########################
#   Message precedences   #
###########################

Pfirst-class=0
Pspecial-delivery=100
Plist=-30
Pbulk=-60
Pjunk=-100

#####################
#   Trusted users   #
#####################

# this is equivalent to setting class "t"
ifdef(`_USE_CT_FILE_', `', `#')Ft`'ifdef(`confCT_FILE', confCT_FILE, ifdef(`_USE_ETC_MAIL_', `/etc/mail/trusted-users', `/etc/sendmail.ct'))
Troot
Tdaemon
ifdef(`_NO_UUCP_', `dnl', `Tuucp')
ifdef(`confTRUSTED_USERS', `T`'confTRUSTED_USERS', `dnl')

#########################
#   Format of headers   #
#########################

ifdef(`confFROM_HEADER',, `define(`confFROM_HEADER', `$?x$x <$g>$|$g$.')')dnl
H?P?Return-Path: <$g>
HReceived: confRECEIVED_HEADER
H?D?Resent-Date: $a
H?D?Date: $a
H?F?Resent-From: confFROM_HEADER
H?F?From: confFROM_HEADER
H?x?Full-Name: $x
# HPosted-Date: $a
# H?l?Received-Date: $b
H?M?Resent-Message-Id: <$t.$i@@$j>
H?M?Message-Id: <$t.$i@@$j>
ifdef(`_NULL_CLIENT_ONLY_',
	`include(_CF_DIR_`'m4/nullrelay.m4)m4exit',
	`dnl')
#
######################################################################
######################################################################
#####
#####			REWRITING RULES
#####
######################################################################
######################################################################

############################################
###  Ruleset 3 -- Name Canonicalization  ###
############################################
S3

# handle null input (translate to <@@> special case)
R$@@			$@@ <@@>

# strip group: syntax (not inside angle brackets!) and trailing semicolon
R$*			$: $1 <@@>			mark addresses
R$* < $* > $* <@@>	$: $1 < $2 > $3			unmark <addr>
R@@ $* <@@>		$: @@ $1				unmark @@host:...
R$* :: $* <@@>		$: $1 :: $2			unmark node::addr
R:`include': $* <@@>	$: :`include': $1			unmark :`include':...
R$* [ $* : $* ] <@@>	$: $1 [ $2 : $3 ]		unmark IPv6 addrs
R$* : $* [ $* ]		$: $1 : $2 [ $3 ] <@@>		remark if leading colon
R$* : $* <@@>		$: $2				strip colon if marked
R$* <@@>			$: $1				unmark
R$* ;			   $1				strip trailing semi
R$* < $* ; >		   $1 < $2 >			bogus bracketed semi

# null input now results from list:; syntax
R$@@			$@@ :; <@@>

# strip angle brackets -- note RFC733 heuristic to get innermost item
R$*			$: < $1 >			housekeeping <>
R$+ < $* >		   < $2 >			strip excess on left
R< $* > $+		   < $1 >			strip excess on right
R<>			$@@ < @@ >			MAIL FROM:<> case
R< $+ >			$: $1				remove housekeeping <>

# make sure <@@a,@@b,@@c:user@@d> syntax is easy to parse -- undone later
R@@ $+ , $+		@@ $1 : $2			change all "," to ":"

# localize and dispose of route-based addresses
R@@ $+ : $+		$@@ $>96 < @@$1 > : $2		handle <route-addr>

# find focus for list syntax
R $+ : $* ; @@ $+	$@@ $>96 $1 : $2 ; < @@ $3 >	list syntax
R $+ : $* ;		$@@ $1 : $2;			list syntax

# find focus for @@ syntax addresses
R$+ @@ $+		$: $1 < @@ $2 >			focus on domain
R$+ < $+ @@ $+ >		$1 $2 < @@ $3 >			move gaze right
R$+ < @@ $+ >		$@@ $>96 $1 < @@ $2 >		already canonical

# do some sanity checking
R$* < @@ $* : $* > $*	$1 < @@ $2 $3 > $4		nix colons in addrs

ifdef(`_NO_UUCP_', `dnl',
`# convert old-style addresses to a domain-based address
R$- ! $+		$@@ $>96 $2 < @@ $1 .UUCP >	resolve uucp names
R$+ . $- ! $+		$@@ $>96 $3 < @@ $1 . $2 >		domain uucps
R$+ ! $+		$@@ $>96 $2 < @@ $1 .UUCP >	uucp subdomains
')
ifdef(`_USE_DECNET_SYNTAX_',
`# convert node::user addresses into a domain-based address
R$- :: $+		$@@ $>96 $2 < @@ $1 .DECNET >	resolve DECnet names
R$- . $- :: $+		$@@ $>96 $3 < @@ $1.$2 .DECNET >	numeric DECnet addr
',
	`dnl')
# if we have % signs, take the rightmost one
R$* % $*		$1 @@ $2				First make them all @@s.
R$* @@ $* @@ $*		$1 % $2 @@ $3			Undo all but the last.
R$* @@ $*		$@@ $>96 $1 < @@ $2 >		Insert < > and finish

# else we must be a local name
R$*			$@@ $>96 $1


################################################
###  Ruleset 96 -- bottom half of ruleset 3  ###
################################################

S96

# handle special cases for local names
R$* < @@ localhost > $*		$: $1 < @@ $j . > $2		no domain at all
R$* < @@ localhost . $m > $*	$: $1 < @@ $j . > $2		local domain
ifdef(`_NO_UUCP_', `dnl',
`R$* < @@ localhost . UUCP > $*	$: $1 < @@ $j . > $2		.UUCP domain')
R$* < @@ [ $+ ] > $*		$: $1 < @@@@ [ $2 ] > $3		mark [a.b.c.d]
R$* < @@@@ $=w > $*		$: $1 < @@ $j . > $3		self-literal
R$* < @@@@ $+ > $*		$@@ $1 < @@ $2 > $3		canon IP addr

ifdef(`DOMAIN_TABLE', `dnl
# look up domains in the domain table
R$* < @@ $+ > $* 		$: $1 < @@ $(domaintable $2 $) > $3', `dnl')

undivert(2)dnl

ifdef(`BITDOMAIN_TABLE', `dnl
# handle BITNET mapping
R$* < @@ $+ .BITNET > $*		$: $1 < @@ $(bitdomain $2 $: $2.BITNET $) > $3', `dnl')

ifdef(`UUDOMAIN_TABLE', `dnl
# handle UUCP mapping
R$* < @@ $+ .UUCP > $*		$: $1 < @@ $(uudomain $2 $: $2.UUCP $) > $3', `dnl')

ifdef(`_NO_UUCP_', `dnl',
`ifdef(`UUCP_RELAY',
`# pass UUCP addresses straight through
R$* < @@ $+ . UUCP > $*		$@@ $1 < @@ $2 . UUCP . > $3',
`# if really UUCP, handle it immediately
ifdef(`_CLASS_U_',
`R$* < @@ $=U . UUCP > $*	$@@ $1 < @@ $2 . UUCP . > $3', `dnl')
ifdef(`_CLASS_V_',
`R$* < @@ $=V . UUCP > $*	$@@ $1 < @@ $2 . UUCP . > $3', `dnl')
ifdef(`_CLASS_W_',
`R$* < @@ $=W . UUCP > $*	$@@ $1 < @@ $2 . UUCP . > $3', `dnl')
ifdef(`_CLASS_X_',
`R$* < @@ $=X . UUCP > $*	$@@ $1 < @@ $2 . UUCP . > $3', `dnl')
ifdef(`_CLASS_Y_',
`R$* < @@ $=Y . UUCP > $*	$@@ $1 < @@ $2 . UUCP . > $3', `dnl')

ifdef(`_NO_CANONIFY_', `dnl', `dnl
# try UUCP traffic as a local address
R$* < @@ $+ . UUCP > $*		$: $1 < @@ $[ $2 $] . UUCP . > $3
R$* < @@ $+ . . UUCP . > $*	$@@ $1 < @@ $2 . > $3')
')')
ifdef(`_NO_CANONIFY_', `dnl', `dnl
# pass to name server to make hostname canonical
R$* < @@ $* $~P > $*		$: $1 < @@ $[ $2 $3 $] > $4')

# local host aliases and pseudo-domains are always canonical
R$* < @@ $=w > $*		$: $1 < @@ $2 . > $3
R$* < @@ $j > $*			$: $1 < @@ $j . > $2
ifdef(`_MASQUERADE_ENTIRE_DOMAIN_',
`R$* < @@ $* $=M > $*		$: $1 < @@ $2 $3 . > $4',
`R$* < @@ $=M > $*		$: $1 < @@ $2 . > $3')
R$* < @@ $* $=P > $*		$: $1 < @@ $2 $3 . > $4
R$* < @@ $* . . > $*		$1 < @@ $2 . > $3


##################################################
###  Ruleset 4 -- Final Output Post-rewriting  ###
##################################################
S4

R$* <@@>			$@@				handle <> and list:;

# strip trailing dot off possibly canonical name
R$* < @@ $+ . > $*	$1 < @@ $2 > $3

# eliminate internal code -- should never get this far!
R$* < @@ *LOCAL* > $*	$1 < @@ $j > $2

# externalize local domain info
R$* < $+ > $*		$1 $2 $3			defocus
R@@ $+ : @@ $+ : $+	@@ $1 , @@ $2 : $3		<route-addr> canonical
R@@ $*			$@@ @@ $1				... and exit

ifdef(`_NO_UUCP_', `dnl',
`# UUCP must always be presented in old form
R$+ @@ $- . UUCP		$2!$1				u@@h.UUCP => h!u')

ifdef(`_USE_DECNET_SYNTAX_',
`# put DECnet back in :: form
R$+ @@ $+ . DECNET	$2 :: $1			u@@h.DECNET => h::u',
	`dnl')
# delete duplicate local names
R$+ % $=w @@ $=w		$1 @@ $2				u%host@@host => u@@host



##############################################################
###   Ruleset 97 -- recanonicalize and call ruleset zero   ###
###		   (used for recursive calls)		   ###
##############################################################

S`'97
R$*			$: $>3 $1
R$*			$@@ $>0 $1


######################################
###   Ruleset 0 -- Parse Address   ###
######################################

S0

R$*			$: $>Parse0 $1		initial parsing
R<@@>			$#_LOCAL_ $: <@@>		special case error msgs
R$*			$: $>98 $1		handle local hacks
R$*			$: $>Parse1 $1		final parsing

#
#  Parse0 -- do initial syntax checking and eliminate local addresses.
#	This should either return with the (possibly modified) input
#	or return with a #error mailer.  It should not return with a
#	#mailer other than the #error mailer.
#

SParse0
R<@@>			$@@ <@@>			special case error msgs
R$* : $* ; <@@>		$#error $@@ 5.1.3 $: "List:; syntax illegal for recipient addresses"
#R@@ <@@ $* >		< @@ $1 >		catch "@@@@host" bogosity
R<@@ $+>			$#error $@@ 5.1.3 $: "User address required"
R$*			$: <> $1
R<> $* < @@ [ $+ ] > $*	$1 < @@ [ $2 ] > $3
R<> $* <$* : $* > $*	$#error $@@ 5.1.3 $: "Colon illegal in host name part"
R<> $*			$1
R$* < @@ . $* > $*	$#error $@@ 5.1.2 $: "Invalid host name"
R$* < @@ $* .. $* > $*	$#error $@@ 5.1.2 $: "Invalid host name"

# now delete the local info -- note $=O to find characters that cause forwarding
R$* < @@ > $*		$@@ $>Parse0 $>3 $1		user@@ => user
R< @@ $=w . > : $*	$@@ $>Parse0 $>3 $2		@@here:... -> ...
R$- < @@ $=w . >		$: $(dequote $1 $) < @@ $2 . >	dequote "foo"@@here
R< @@ $+ >		$#error $@@ 5.1.3 $: "User address required"
R$* $=O $* < @@ $=w . >	$@@ $>Parse0 $>3 $1 $2 $3	...@@here -> ...
R$- 			$: $(dequote $1 $) < @@ *LOCAL* >	dequote "foo"
R< @@ *LOCAL* >		$#error $@@ 5.1.3 $: "User address required"
R$* $=O $* < @@ *LOCAL* >
			$@@ $>Parse0 $>3 $1 $2 $3	...@@*LOCAL* -> ...
R$* < @@ *LOCAL* >	$: $1

#
#  Parse1 -- the bottom half of ruleset 0.
#

SParse1
ifdef(`_MAILER_smtp_',
`# handle numeric address spec
R$* < @@ [ $+ ] > $*	$: $>98 $1 < @@ [ $2 ] > $3	numeric internet spec
R$* < @@ [ $+ ] > $*	$#_SMTP_ $@@ [$2] $: $1 < @@ [$2] > $3	still numeric: send',
	`dnl')

ifdef(`VIRTUSER_TABLE', `dnl
# handle virtual users
R$+ < @@ $=w . > 	$: < $(virtuser $1 @@ $2 $@@ $1 $: @@ $) > $1 < @@ $2 . >
R<@@> $+ + $* < @@ $* . >
			$: < $(virtuser $1 + * @@ $3 $@@ $1 $: @@ $) > $1 + $2 < @@ $3 . >
R<@@> $+ + $* < @@ $* . >
			$: < $(virtuser $1 @@ $3 $@@ $1 $: @@ $) > $1 + $2 < @@ $3 . >
R<@@> $+ < @@ $+ . >	$: < $(virtuser @@ $2 $@@ $1 $: @@ $) > $1 < @@ $2 . >
R<@@> $+			$: $1
R< error : $- $+ > $* 	$#error $@@ $(dequote $1 $) $: $2
R< $+ > $+ < @@ $+ >	$: $>97 $1',
`dnl')

# short circuit local delivery so forwarded email works
ifdef(`_MAILER_usenet_', `dnl
R$+ . USENET < @@ $=w . >	$#usenet $: $1		handle usenet specially', `dnl')
ifdef(`_STICKY_LOCAL_DOMAIN_',
`R$+ < @@ $=w . >		$: < $H > $1 < @@ $2 . >		first try hub
R< $+ > $+ < $+ >	$>95 < $1 > $2 < $3 >		yep ....
R< > $+ + $* < $+ >	$#_LOCAL_ $: $1 + $2		plussed name?
R< > $+ < $+ >		$#_LOCAL_ $: @@ $1			nope, local address',
`R$=L < @@ $=w . >	$#_LOCAL_ $: @@ $1		special local names
R$+ < @@ $=w . >		$#_LOCAL_ $: $1			regular local name')

ifdef(`MAILER_TABLE', `dnl
# not local -- try mailer table lookup
R$* <@@ $+ > $*		$: < $2 > $1 < @@ $2 > $3	extract host name
R< $+ . > $*		$: < $1 > $2			strip trailing dot
R< $+ > $*		$: < $(mailertable $1 $) > $2	lookup
R< $~[ : $* > $* 	$>95 < $1 : $2 > $3		check -- resolved?
R< $+ > $*		$: $>90 <$1> $2			try domain',
`dnl')
undivert(4)dnl

ifdef(`_NO_UUCP_', `dnl',
`# resolve remotely connected UUCP links (if any)
ifdef(`_CLASS_V_',
`R$* < @@ $=V . UUCP . > $*		$: $>95 < $V > $1 <@@$2.UUCP.> $3',
	`dnl')
ifdef(`_CLASS_W_',
`R$* < @@ $=W . UUCP . > $*		$: $>95 < $W > $1 <@@$2.UUCP.> $3',
	`dnl')
ifdef(`_CLASS_X_',
`R$* < @@ $=X . UUCP . > $*		$: $>95 < $X > $1 <@@$2.UUCP.> $3',
	`dnl')')

# resolve fake top level domains by forwarding to other hosts
ifdef(`BITNET_RELAY',
`R$*<@@$+.BITNET.>$*	$: $>95 < $B > $1 <@@$2.BITNET.> $3	user@@host.BITNET',
	`dnl')
ifdef(`DECNET_RELAY',
`R$*<@@$+.DECNET.>$*	$: $>95 < $C > $1 <@@$2.DECNET.> $3	user@@host.DECNET',
	`dnl')
ifdef(`_MAILER_pop_',
`R$+ < @@ POP. >		$#pop $: $1			user@@POP',
	`dnl')
ifdef(`_MAILER_fax_',
`R$+ < @@ $+ .FAX. >	$#fax $@@ $2 $: $1		user@@host.FAX',
`ifdef(`FAX_RELAY',
`R$*<@@$+.FAX.>$*		$: $>95 < $F > $1 <@@$2.FAX.> $3	user@@host.FAX',
	`dnl')')

ifdef(`UUCP_RELAY',
`# forward non-local UUCP traffic to our UUCP relay
R$*<@@$*.UUCP.>$*		$: $>95 < $Y > $1 <@@$2.UUCP.> $3	uucp mail',
`ifdef(`_MAILER_uucp_',
`# forward other UUCP traffic straight to UUCP
R$* < @@ $+ .UUCP. > $*		$#_UUCP_ $@@ $2 $: $1 < @@ $2 .UUCP. > $3	user@@host.UUCP',
	`dnl')')
ifdef(`_MAILER_usenet_', `
# addresses sent to net.group.USENET will get forwarded to a newsgroup
R$+ . USENET		$#usenet $: $1',
	`dnl')

ifdef(`_LOCAL_RULES_',
`# figure out what should stay in our local mail system
undivert(1)', `dnl')

# pass names that still have a host to a smarthost (if defined)
R$* < @@ $* > $*		$: $>95 < $S > $1 < @@ $2 > $3	glue on smarthost name

# deal with other remote names
ifdef(`_MAILER_smtp_',
`R$* < @@$* > $*		$#_SMTP_ $@@ $2 $: $1 < @@ $2 > $3		user@@host.domain',
`R$* < @@$* > $*		$#error $@@ 5.1.2 $: "Unrecognized host name " $2')

# handle locally delivered names
R$=L			$#_LOCAL_ $: @@ $1			special local names
R$+			$#_LOCAL_ $: $1			regular local names

###########################################################################
###   Ruleset 5 -- special rewriting after aliases have been expanded   ###
###########################################################################

S5

# deal with plussed users so aliases work nicely
R$+ + *			$#_LOCAL_ $@@ $&h $: $1
R$+ + $*		$#_LOCAL_ $@@ + $2 $: $1 + *

# prepend an empty "forward host" on the front
R$+			$: <> $1

ifdef(`LUSER_RELAY', `dnl
# send unrecognized local users to a relay host
R< > $+ 		$: < $L . > $(user $1 $)	look up user
R< $* > $+ <> $*	$: < > $2 $3			found; strip $L
R< $* . > $+		$: < $1 > $2			strip extra dot',
`dnl')

# see if we have a relay or a hub
R< > $+			$: < $H > $1			try hub
R< > $+			$: < $R > $1			try relay
R< > $+			$: < > < $1 $&h >		nope, restore +detail
R< > < $+ + $* > $*	   < > < $1 > + $2 $3		find the user part
R< > < $+ > + $*	$#_LOCAL_ $@@ $2 $: @@ $1		strip the extra +
R< > < $+ >		$@@ $1				no +detail
R$+			$: $1 <> $&h			add +detail back in
R$+ <> + $*		$: $1 + $2			check whether +detail
R$+ <> $*		$: $1				else discard
R< local : $* > $*	$: $>95 < local : $1 > $2	no host extension
R< error : $* > $*	$: $>95 < error : $1 > $2	no host extension
R< $- : $+ > $+		$: $>95 < $1 : $2 > $3 < @@ $2 >
R< $+ > $+		$@@ $>95 < $1 > $2 < @@ $1 >

ifdef(`MAILER_TABLE', `dnl
###################################################################
###  Ruleset 90 -- try domain part of mailertable entry 	###
###################################################################

S90
R$* <$- . $+ > $*	$: $1$2 < $(mailertable .$3 $@@ $1$2 $@@ $2 $) > $4
R$* <$~[ : $* > $*	$>95 < $2 : $3 > $4		check -- resolved?
R$* < . $+ > $* 	$@@ $>90 $1 . <$2> $3		no -- strip & try again
R$* < $* > $*		$: < $(mailertable . $@@ $1$2 $) > $3	try "."
R< $~[ : $* > $*	$>95 < $1 : $2 > $3		"." found?
R< $* > $*		$@@ $2				no mailertable match',
`dnl')

###################################################################
###  Ruleset 95 -- canonify mailer:[user@@]host syntax to triple	###
###################################################################

S95
R< > $*				$@@ $1			strip off null relay
R< error : $- $+ > $*		$#error $@@ $(dequote $1 $) $: $2
R< local : $* > $*		$>CanonLocal < $1 > $2
R< $- : $+ @@ $+ > $*<$*>$*	$# $1 $@@ $3 $: $2<@@$3>	use literal user
R< $- : $+ > $*			$# $1 $@@ $2 $: $3	try qualified mailer
R< $=w > $*			$@@ $2			delete local host
R< $+ > $*			$#_RELAY_ $@@ $1 $: $2	use unqualified mailer

###################################################################
###  Ruleset CanonLocal -- canonify local: syntax		###
###################################################################

SCanonLocal
# strip local host from routed addresses
R< $* > < @@ $+ > : $+		$@@ $>97 $3
R< $* > $+ $=O $+ < @@ $+ >	$@@ $>97 $2 $3 $4

# strip trailing dot from any host name that may appear
R< $* > $* < @@ $* . >		$: < $1 > $2 < @@ $3 >

# handle local: syntax -- use old user, either with or without host
R< > $* < @@ $* > $*		$#_LOCAL_ $@@ $1@@$2 $: $1
R< > $+				$#_LOCAL_ $@@ $1    $: $1

# handle local:user@@host syntax -- ignore host part
R< $+ @@ $+ > $* < @@ $* >	$: < $1 > $3 < @@ $4 >

# handle local:user syntax
R< $+ > $* <@@ $* > $*		$#_LOCAL_ $@@ $2@@$3 $: $1
R< $+ > $* 			$#_LOCAL_ $@@ $2    $: $1

###################################################################
###  Ruleset 93 -- convert header names to masqueraded form	###
###################################################################

S93

ifdef(`GENERICS_TABLE', `dnl
# handle generics database
ifdef(`_GENERICS_ENTIRE_DOMAIN_',
`R$+ < @@ $* $=G . >	$: < $1@@$2$3 > $1 < @@ $2$3 . > @@	mark',
`R$+ < @@ $=G . >	$: < $1@@$2 > $1 < @@ $2 . > @@	mark')
R$+ < @@ *LOCAL* >	$: < $1@@$j > $1 < @@ *LOCAL* > @@	mark
R< $+ > $+ < $* > @@	$: < $(generics $1 $: $) > $2 < $3 >
R< > $+ < @@ $+ > 	$: < $(generics $1 $: $) > $1 < @@ $2 >
R< $* @@ $* > $* < $* >	$@@ $>3 $1 @@ $2			found qualified
R< $+ > $* < $* >	$: $>3 $1 @@ *LOCAL*		found unqualified
R< > $*			$: $1				not found',
`dnl')

# special case the users that should be exposed
R$=E < @@ *LOCAL* >	$@@ $1 < @@ $j . >		leave exposed
ifdef(`_MASQUERADE_ENTIRE_DOMAIN_',
`R$=E < @@ $* $=M . >	$@@ $1 < @@ $2 $3 . >',
`R$=E < @@ $=M . >	$@@ $1 < @@ $2 . >')
ifdef(`_LIMITED_MASQUERADE_', `dnl',
`R$=E < @@ $=w . >	$@@ $1 < @@ $2 . >')

# handle domain-specific masquerading
ifdef(`_MASQUERADE_ENTIRE_DOMAIN_',
`R$* < @@ $* $=M . > $*	$: $1 < @@ $2 $3 . @@ $M > $4	convert masqueraded doms',
`R$* < @@ $=M . > $*	$: $1 < @@ $2 . @@ $M > $3	convert masqueraded doms')
ifdef(`_LIMITED_MASQUERADE_', `dnl',
`R$* < @@ $=w . > $*	$: $1 < @@ $2 . @@ $M > $3')
R$* < @@ *LOCAL* > $*	$: $1 < @@ $j . @@ $M > $2
R$* < @@ $+ @@ > $*	$: $1 < @@ $2 > $3		$M is null
R$* < @@ $+ @@ $+ > $*	$: $1 < @@ $3 . > $4		$M is not null

###################################################################
###  Ruleset 94 -- convert envelope names to masqueraded form	###
###################################################################

S94
ifdef(`_MASQUERADE_ENVELOPE_',
`R$+			$@@ $>93 $1',
`R$* < @@ *LOCAL* > $*	$: $1 < @@ $j . > $2')

###################################################################
###  Ruleset 98 -- local part of ruleset zero (can be null)	###
###################################################################

S98
undivert(3)dnl

ifelse(substr(confDELIVERY_MODE,0,1), `d', `errprint(`WARNING: Antispam rules not available in deferred delivery mode.')')
ifdef(`ACCESS_TABLE', `dnl
######################################################################
###  LookUpDomain -- search for domain in access database
###
###	Parameters:
###		<$1> -- key (domain name)
###		<$2> -- default (what to return if not found in db)
###		<$3> -- passthru (additional data passed unchanged through)
######################################################################

SLookUpDomain
R<$+> <$+> <$*>		$: < $(access $1 $: ? $) > <$1> <$2> <$3>
R<?> <$+.$+> <$+> <$*>	$@@ $>LookUpDomain <$2> <$3> <$4>
R<?> <$+> <$+> <$*>	$@@ <$2> <$3>
R<$*> <$+> <$+> <$*>	$@@ <$1> <$4>

######################################################################
###  LookUpAddress -- search for host address in access database
###
###	Parameters:
###		<$1> -- key (dot quadded host address)
###		<$2> -- default (what to return if not found in db)
###		<$3> -- passthru (additional data passed through)
######################################################################

SLookUpAddress
R<$+> <$+> <$*>		$: < $(access $1 $: ? $) > <$1> <$2> <$3>
R<?> <$+.$-> <$+> <$*>	$@@ $>LookUpAddress <$1> <$3> <$4>
R<?> <$+> <$+> <$*>	$@@ <$2> <$3>
R<$*> <$+> <$+> <$*>	$@@ <$1> <$4>',
`dnl')

######################################################################
###  CanonAddr --	Convert an address into a standard form for
###			relay checking.  Route address syntax is
###			crudely converted into a %-hack address.
###
###	Parameters:
###		$1 -- full recipient address
###
###	Returns:
###		parsed address, not in source route form
######################################################################

SCanonAddr
R$*			$: $>Parse0 $>3 $1	make domain canonical
R< @@ $+ > : $* @@ $*	< @@ $1 > : $2 % $3	change @@ to % in src route
R$* < @@ $+ > : $* : $*	$3 $1 < @@ $2 > : $4	change to % hack.
R$* < @@ $+ > : $*	$3 $1 < @@ $2 >

######################################################################
###  ParseRecipient --	Strip off hosts in $=R as well as possibly
###			$* $=m or the access database.
###			Check user portion for host separators.
###
###	Parameters:
###		$1 -- full recipient address
###
###	Returns:
###		parsed, non-local-relaying address
######################################################################

SParseRecipient
R$*				$: <?> $>CanonAddr $1
R<?> $* < @@ $* . >		<?> $1 < @@ $2 >			strip trailing dots
R<?> $- < @@ $* >		$: <?> $(dequote $1 $) < @@ $2 >	dequote local part

# if no $=O character, no host in the user portion, we are done
R<?> $* $=O $* < @@ $* >		$: <NO> $1 $2 $3 < @@ $4>
R<?> $*				$@@ $1

ifdef(`_RELAY_ENTIRE_DOMAIN_', `dnl
# if we relay, check username portion for user%host so host can be checked also
R<NO> $* < @@ $* $=m >		$: <RELAY> $1 < @@ $2 $3 >', `dnl')

ifdef(`_RELAY_MX_SERVED_', `dnl
R<NO> $* < @@ $+ >		$: <MX> < : $(mxserved $2 $) : > < $1 < @@$2 > >
R<MX> < : $* <TEMP> : > $*	$#error $@@ 4.7.1 $: "450 Can not check MX records for recipient host " $1
R<MX> < $* : $=w. : $* > < $+ >	$: <RELAY> $4
R<MX> < : $* : > < $+ >		$: <NO> $2', `dnl')

ifdef(`_RELAY_HOSTS_ONLY_',
`R<NO> $* < @@ $=R >		$: <RELAY> $1 < @@ $2 >
ifdef(`ACCESS_TABLE', `dnl
R<NO> $* < @@ $+ >		$: <$(access $2 $: NO $)> $1 < @@ $2 >',`dnl')',
`R<NO> $* < @@ $* $=R >		$: <RELAY> $1 < @@ $2 $3 >
ifdef(`ACCESS_TABLE', `dnl
R<NO> $* < @@ $+ >		$: $>LookUpDomain <$2> <NO> <$1 < @@ $2 >>
R<$+> <$+>			$: <$1> $2',`dnl')')

R<RELAY> $* < @@ $* >		$@@ $>ParseRecipient $1
R<$-> $*			$@@ $2

######################################################################
###  check_relay -- check hostname/address on SMTP startup
######################################################################

SLocal_check_relay
Scheck_relay
R$*			$: $1 $| $>"Local_check_relay" $1
R$* $| $* $| $#$*	$#$3
R$* $| $* $| $*		$@@ $>"Basic_check_relay" $1 $| $2

SBasic_check_relay
# check for deferred delivery mode
R$*			$: < ${deliveryMode} > $1
R< d > $*		$@@ deferred
R< $* > $*		$: $2

ifdef(`ACCESS_TABLE', `dnl
R$+ $| $+		$: $>LookUpDomain < $1 > <?> < $2 >
R<?> < $+ >		$: $>LookUpAddress < $1 > <?> < $1 >
R<?> < $+ >		$: $1
R<OK> < $* >		$@@ OK
R<RELAY> < $* >		$@@ RELAY
R<REJECT> $*		$#error $@@ 5.7.1 $: "ifdef(`confREJECT_MSG', `confREJECT_MSG', `550 Access denied')"
R<DISCARD> $*		$#discard $: discard
R<$+> $*		$#error $@@ 5.7.1 $: $1', `dnl')

ifdef(`_RBL_', `dnl
# DNS based IP address spam lists
R$*			$: $&{client_addr}
R$-.$-.$-.$-		$: $(host $4.$3.$2.$1._RBL_. $: OK $)
ROK			$@@ OK
R$+			$#error $@@ 5.7.1 $: "Mail from " $&{client_addr} " refused by blackhole site _RBL_"',
`dnl')

######################################################################
###  check_mail -- check SMTP ``MAIL FROM:'' command argument
######################################################################

SLocal_check_mail
Scheck_mail
R$*			$: $1 $| $>"Local_check_mail" $1
R$* $| $#$*		$#$2
R$* $| $*		$@@ $>"Basic_check_mail" $1

SBasic_check_mail
# check for deferred delivery mode
R$*			$: < ${deliveryMode} > $1
R< d > $*		$@@ deferred
R< $* > $*		$: $2

R<>			$@@ <OK>
R$*			$: <?> $>CanonAddr $1
R<?> $* < @@ $+ . >	<?> $1 < @@ $2 >			strip trailing dots
# handle non-DNS hostnames (*.bitnet, *.decnet, *.uucp, etc)
R<?> $* < $* $=P > $*	$: <OK> $1 < @@ $2 $3 > $4
ifdef(`_ACCEPT_UNRESOLVABLE_DOMAINS_',
`R<?> $* < @@ $+ > $*	$: <OK> $1 < @@ $2 > $3		... unresolvable OK',
`R<?> $* < @@ $+ > $*	$: <? $(resolve $2 $: $2 <PERM> $) > $1 < @@ $2 > $3
R<? $* <$->> $* < @@ $+ > $*
			$: <$2> $3 < @@ $4 > $5')

ifdef(`_ACCEPT_UNQUALIFIED_SENDERS_',`dnl',`dnl
# handle case of @@localhost on address
R<$+> $* < @@localhost >	$: < ? $&{client_name} > <$1> $2 < @@localhost >
R<$+> $* < @@localhost.$m >
			$: < ? $&{client_name} > <$1> $2 < @@localhost.$m >
ifdef(`_NO_UUCP_', `dnl',
`R<$+> $* < @@localhost.UUCP >
			$: < ? $&{client_name} > <$1> $2 < @@localhost.UUCP >')
R<? $=w> <$+> $*	<?> <$2> $3
R<? $+> <$+> $*		$#error $@@ 5.5.4 $: "553 Real domain name required"
R<?> <$+> $*		$: <$1> $2')

ifdef(`ACCESS_TABLE', `dnl
# lookup localpart (user@@)
R<$+> $* < @@ $+ > $*	$: <USER $(access $2@@ $: ? $) > <$1> $2 < @@ $3 > $4
# no match, try full address (user@@domain rest)
R<USER ?> <$+> $* < @@ $* > $*
			$: <USER $(access $2@@$3$4 $: ? $) > <$1> $2 < @@ $3 > $4
# no match, try address (user@@domain)
R<USER ?> <$+> $+ < @@ $+ > $*
			$: <USER $(access $2@@$3 $: ? $) > <$1> $2 < @@ $3 > $4
# no match, try (sub)domain (domain)
R<USER ?> <$+> $* < @@ $+ > $*
			$: $>LookUpDomain <$3> <$1> <>
# check unqualified user in access database
R<?> $*			$: <USER $(access $1@@ $: ? $) > <?> $1
# retransform for further use
R<USER $+> <$+> $*	$: <$1> $3',
`dnl')

ifdef(`_ACCEPT_UNQUALIFIED_SENDERS_',`dnl',`dnl
# handle case of no @@domain on address
R<?> $*			$: < ? $&{client_name} > $1
R<?> $*			$@@ <OK>				...local unqualed ok
R<? $+> $*		$#error $@@ 5.5.4 $: "553 Domain name required"
							...remote is not')
# check results
R<?> $*			$@@ <OK>
R<OK> $*		$@@ <OK>
R<TEMP> $*		$#error $@@ 4.1.8 $: "451 Sender domain must resolve"
R<PERM> $*		$#error $@@ 5.1.8 $: "501 Sender domain must exist"
ifdef(`ACCESS_TABLE', `dnl
R<RELAY> $*		$@@ <RELAY>
R<DISCARD> $*		$#discard $: discard
R<REJECT> $*		$#error $@@ 5.7.1 $: "ifdef(`confREJECT_MSG', `confREJECT_MSG', `550 Access denied')"
R<$+> $*		$#error $@@ 5.7.1 $: $1		error from access db',
`dnl')

######################################################################
###  check_rcpt -- check SMTP ``RCPT TO:'' command argument
######################################################################

SLocal_check_rcpt
Scheck_rcpt
R$*			$: $1 $| $>"Local_check_rcpt" $1
R$* $| $#$*		$#$2
R$* $| $*		$@@ $>"Basic_check_rcpt" $1

SBasic_check_rcpt
# check for deferred delivery mode
R$*			$: < ${deliveryMode} > $1
R< d > $*		$@@ deferred
R< $* > $*		$: $2

ifdef(`_LOOSE_RELAY_CHECK_',`dnl
R$*			$: $>CanonAddr $1
R$* < @@ $* . >		$1 < @@ $2 >			strip trailing dots',
`R$*			$: $>ParseRecipient $1		strip relayable hosts')

ifdef(`_BESTMX_IS_LOCAL_',`dnl
ifelse(_BESTMX_IS_LOCAL_, `', `dnl
# unlimited bestmx
R$* < @@ $* > $*			$: $1 < @@ $2 @@@@ $(bestmx $2 $) > $3',
`dnl
# limit bestmx to $=B
R$* < @@ $* $=B > $*		$: $1 < @@ $2 $3 @@@@ $(bestmx $2 $3 $) > $4')
R$* $=O $* < @@ $* @@@@ $=w . > $*	$@@ $>Basic_check_rcpt $1 $2 $3
R$* < @@ $* @@@@ $=w . > $*	$: $1 < @@ $3 > $4
R$* < @@ $* @@@@ $* > $*		$: $1 < @@ $2 > $4')

ifdef(`_BLACKLIST_RCPT_',`dnl
ifdef(`ACCESS_TABLE', `dnl
# blacklist local users or any host from receiving mail
R$*			$: <?> $1
R<?> $+ < @@ $=w >	$: <> <USER $1> <FULL $1@@$2> <HOST $2> <$1 < @@ $2 >>
R<?> $+ < @@ $* >	$: <> <FULL $1@@$2> <HOST $2> <$1 < @@ $2 >>
R<?> $+			$: <> <USER $1> <$1>
R<> <USER $+> $*	$: <$(access $1 $: $)> $2
R<> <FULL $+> $*	$: <$(access $1 $: $)> $2
R<OK> <FULL $+> $*	$: <$(access $1 $: $)> $2
R<> <HOST $+> $*	$: <$(access $1 $: $)> $2
R<OK> <HOST $+> $*	$: <$(access $1 $: $)> $2
R<> <$*>		$: $1
R<OK> <$*>		$: $1
R<RELAY> <$*>		$: $1
R<REJECT> $*		$#error $@@ 5.2.1 $: "550 Mailbox disabled for this recipient"
R<$+> $*		$#error $@@ 5.2.1 $: $1			error from access db', `dnl')', `dnl')

ifdef(`_PROMISCUOUS_RELAY_', `dnl', `dnl
# anything terminating locally is ok
ifdef(`_RELAY_ENTIRE_DOMAIN_', `dnl
R$+ < @@ $* $=m >	$@@ OK', `dnl')
R$+ < @@ $=w >		$@@ OK
ifdef(`_RELAY_HOSTS_ONLY_',
`R$+ < @@ $=R >		$@@ OK
ifdef(`ACCESS_TABLE', `dnl
R$+ < @@ $* >		$: <$(access $2 $: ? $)> <$1 < @@ $2 >>',`dnl')',
`R$+ < @@ $* $=R >	$@@ OK
ifdef(`ACCESS_TABLE', `dnl
R$+ < @@ $* >		$: $>LookUpDomain <$2> <?> <$1 < @@ $2 >>',`dnl')')
ifdef(`ACCESS_TABLE', `dnl
R<RELAY> $*		$@@ RELAY
R<$*> <$*>		$: $2',`dnl')

ifdef(`_RELAY_MX_SERVED_', `dnl
# allow relaying for hosts which we MX serve
R$+ < @@ $* >		$: < : $(mxserved $2 $) : > $1 < @@ $2 >
R< : $* <TEMP> : > $*	$#error $@@ 4.7.1 $: "450 Can not check MX records for recipient host " $1
R<$* : $=w . : $*> $*	$@@ OK
R< : $* : > $*		$: $2',
`dnl')

# check for local user (i.e. unqualified address)
R$*			$: <?> $1
R<?> $* < @@ $+ >	$: <REMOTE> $1 < @@ $2 >
# local user is ok
R<?> $+			$@@ OK
R<$+> $*		$: $2

# anything originating locally is ok
R$*			$: <?> $&{client_name}
# check if bracketed IP address (forward lookup != reverse lookup)
R<?> [$+]		$: <BAD> [$1]
# pass to name server to make hostname canonical
R<?> $* $~P 		$: <?> $[ $1 $2 $]
R<$-> $*		$: $2
R$* .			$1				strip trailing dots
R$@@			$@@ OK
ifdef(`_RELAY_ENTIRE_DOMAIN_', `dnl
R$* $=m			$@@ OK', `dnl')
R$=w			$@@ OK
ifdef(`_RELAY_HOSTS_ONLY_',
`R$=R			$@@ OK
ifdef(`ACCESS_TABLE', `dnl
R$*			$: <$(access $1 $: ? $)> <$1>',`dnl')',
`R$* $=R			$@@ OK
ifdef(`ACCESS_TABLE', `dnl
R$*			$: $>LookUpDomain <$1> <?> <$1>',`dnl')')
ifdef(`ACCESS_TABLE', `dnl
R<RELAY> $*		$@@ RELAY
R<$*> <$*>		$: $2',`dnl')

# check IP address
R$*			$: $&{client_addr}
R$@@			$@@ OK			originated locally
R0			$@@ OK			originated locally
R$=R $*			$@@ OK			relayable IP address
ifdef(`ACCESS_TABLE', `dnl
R$*			$: $>LookUpAddress <$1> <?> <$1>
R<RELAY> $* 		$@@ RELAY		relayable IP address
R<$*> <$*>		$: $2', `dnl')
R$*			$: [ $1 ]		put brackets around it...
R$=w			$@@ OK			... and see if it is local

ifdef(`_RELAY_LOCAL_FROM_', `dnl
# anything with a local FROM is ok
R$*			$: $1 $| $>CanonAddr $&f
R$* $| $+ < @@ $=w . >	$@@ OK			FROM local
R$* $| $*		$: $1
', `dnl')

# anything else is bogus
R$*			$#error $@@ 5.7.1 $: "550 Relaying denied"')

undivert(9)dnl
#
######################################################################
######################################################################
#####
`#####			MAILER DEFINITIONS'
#####
######################################################################
######################################################################
undivert(7)dnl
@


1.10
log
@sendmail 8.9.3
@
text
@@


1.9
log
@official fix for sendmail header length DoS
@
text
@d15 1
a15 1
VERSIONID(`@@(#)proto.m4	8.237 (Berkeley) 12/17/1998')
d481 3
a483 3
ifdef(`confMAX_HEADER_LINES',
`# Maximum number of header lines and header line length limit
O MaxHeaderLines=confMAX_HEADER_LINES
d792 1
a792 1
R< $~[ : $+ > $* 	$>95 < $1 : $2 > $3		check -- resolved?
d880 3
a882 1
R$+			$: $1 $&h			add +detail back in
d895 1
a895 1
R$* <$~[ : $+ > $*	$>95 < $2 : $3 > $4		check -- resolved?
d898 1
a898 1
R< $~[ : $+ > $*	$>95 < $1 : $2 > $3		"." found?
d920 4
d1221 1
a1221 1
R$* < @@ $* $=B > $*		$: $1 < @@ $2 $3 . @@@@ $(bestmx $2 $3 $) > $4')
@


1.8
log
@sendmail 8.9.2
@
text
@d481 4
@


1.7
log
@something hosed the sendmail import; fix up by hand
@
text
@d15 1
a15 1
VERSIONID(`@@(#)proto.m4	8.223 (Berkeley) 6/30/98')
d20 1
a20 1
V8/Berkeley
d223 1
a223 1
_OPTION(AliasFile, `ALIAS_FILE', /etc/aliases)
d247 1
a247 1
_OPTION(ErrorHeader, `confERROR_MESSAGE', /etc/sendmail.oE)
d265 1
a265 1
O HelpFile=ifdef(`HELP_FILE', HELP_FILE, /usr/lib/sendmail.hf)
d354 1
a354 1
O StatusFile=ifdef(`STATUS_FILE', `STATUS_FILE', /etc/sendmail.st)
d368 1
a368 1
_OPTION(UserDatabaseSpec, `confUSERDB_SPEC', /etc/userdb)
d410 1
a410 1
_OPTION(ServiceSwitchFile, `confSERVICE_SWITCH_FILE', /etc/service.switch)
d469 13
d497 1
a497 1
ifdef(`_USE_CT_FILE_', `', `#')Ft`'ifdef(`confCT_FILE', confCT_FILE, `/etc/sendmail.ct')
d843 1
a843 1
`R$* < @@$* > $*		$#error $@@ 5.1.2 $: "Unrecognized host name" $2')
d981 1
a981 1
ifelse(confDELIVERY_MODE, defer, `errprint(`WARNING: Antispam rules not available in deferred delivery mode.')')
d1015 18
d1045 3
a1047 3
R$*			$: <?> $>Parse0 $>3 $1
R<?> $* < @@ $* . >	<?> $1 < @@ $2 >		strip trailing dots
R<?> $- < @@ $* >	$: <?> $(dequote $1 $) < @@ $2 >		dequote local part
d1050 2
a1051 2
R<?> $* $=O $* < @@ $* >	$: <NO> $1 $2 $3 < @@ $4>
R<?> $*			$@@ $1
d1055 8
a1062 1
R<NO> $* < @@ $* $=m >	$: <RELAY> $1 < @@ $2 $3 >', `dnl')
d1064 1
a1064 1
`R<NO> $* < @@ $=R >	$: <RELAY> $1 < @@ $2 >
d1066 2
a1067 2
R<NO> $* < @@ $* >	$: <$(access $2 $: NO $)> $1 < @@ $2 >',`dnl')',
`R<NO> $* < @@ $* $=R >	$: <RELAY> $1 < @@ $2 $3 >
d1069 5
a1073 4
R<NO> $* < @@ $* >	$: $>LookUpDomain <$2> <NO> <$1 < @@ $2 >>
R<$+> <$+>		$: <$1> $2',`dnl')')
R<RELAY> $* < @@ $* >	$@@ $>ParseRecipient $1
R<$-> $*		$@@ $2
d1093 4
a1096 3
R<?> < $+ >		$: $>LookUpAddress < $1 > <OK> < $1 >
R<OK> < $* >		$: $1
R<RELAY> < $* >		$: $1
d1102 1
a1102 1
# MAPS project checks -- http://maps.vix.com/
d1106 1
a1106 1
R$+			$#error $@@ 5.7.1 $: "Mail from " $&{client_addr} " refused; see http://maps.vix.com/rbl/"',
d1126 2
a1127 2
R$*			$: <?> $>Parse0 $>3 $1		make domain canonical
R<?> $* < @@ $+ . > $*	<?> $1 < @@ $2 > $3		strip trailing dots
d1201 1
a1201 1
R$*			$: $>Parse0 $>3 $1
d1205 11
d1255 1
a1255 1
R<$*> $*			$: $2',
d1260 1
a1260 1
R<?> $+ < @@ $+ >	$: <REMOTE> $1 < @@ $2 >
d1302 1
a1302 1
R$*			$: $1 $| $>Parse0 $>3 $&f
@


1.6
log
@sendmail 8.8.7.
@
text
@d3 2
a4 1
# Copyright (c) 1983, 1995 Eric P. Allman
d8 3
a10 15
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
# 3. All advertising materials mentioning features or use of this software
#    must display the following acknowledgement:
#	This product includes software developed by the University of
#	California, Berkeley and its contributors.
# 4. Neither the name of the University nor the names of its contributors
#    may be used to endorse or promote products derived from this software
#    without specific prior written permission.
a11 11
# THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
# OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
# OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
d15 1
a15 1
VERSIONID(`@@(#)proto.m4	8.151 (Berkeley) 7/31/97')
d19 2
a20 2
# level 7 config file format
V7/Berkeley
d40 3
d67 4
d117 1
a118 1
ifdef(`LUSER_RELAY', `', `#')dnl
d120 2
a121 3
ifdef(`LUSER_RELAY',
	`DL`'LUSER_RELAY',
	`#DLname_of_luser_relay')
d132 1
d134 2
a135 3
ifdef(`MAILER_TABLE',
	`Kmailertable MAILER_TABLE',
	`#Kmailertable dbm /etc/mailertable')
d137 1
d139 2
a140 3
ifdef(`DOMAIN_TABLE',
	`Kdomaintable DOMAIN_TABLE',
	`#Kdomaintable dbm /etc/domaintable')
d142 1
d144 2
a145 3
ifdef(`GENERICS_TABLE',
	`Kgenerics GENERICS_TABLE',
	`#Kgenerics dbm /etc/genericstable')
d147 11
d159 21
a179 3
ifdef(`VIRTUSER_TABLE',
	`Kvirtuser VIRTUSER_TABLE',
	`#Kvirtuser dbm /etc/virtusertable')
d365 1
a365 1
_OPTION(DefaultUser, `confDEF_USER_ID', nobody)
d439 9
d458 1
a458 1
_OPTION(DoubleBounceAddress, `confDOUBLE_BOUNCE_ADDRESS')
d463 6
d603 1
d605 1
a605 2
ifdef(`DOMAIN_TABLE', `', `#')dnl
R$* < @@ $+ > $* 		$: $1 < @@ $(domaintable $2 $) > $3
d609 8
d633 1
a633 1
define(`X', ifdef(`_NO_CANONIFY_', `#', `'))dnl
d635 4
a638 4
X`'R$* < @@ $+ . UUCP > $*		$: $1 < @@ $[ $2 $] . UUCP . > $3
X`'R$* < @@ $+ . . UUCP . > $*		$@@ $1 < @@ $2 . > $3')
undefine(`X')dnl
')
d640 1
a640 2
ifdef(`_NO_CANONIFY_', `#')dnl
R$* < @@ $* $~P > $*		$: $1 < @@ $[ $2 $3 $] > $4
d700 1
d704 7
d712 4
a715 3
R<@@>			$#_LOCAL_ $: <@@>		special case error msgs
R$* : $* ; <@@>		$#error $@@ 5.1.3 $: "list:; syntax illegal for recipient addresses"
R<@@ $+>			$#error $@@ 5.1.1 $: "user address required"
d718 1
a718 1
R<> $* <$* : $* > $*	$#error $@@ 5.1.1 $: "colon illegal in host name part"
d720 2
a721 8
R$* < @@ . $* > $*	$#error $@@ 5.1.2 $: "invalid host name"
R$* < @@ $* .. $* > $*	$#error $@@ 5.1.2 $: "invalid host name"

ifdef(`_MAILER_smtp_',
`# handle numeric address spec
R$* < @@ [ $+ ] > $*	$: $>98 $1 < @@ [ $2 ] > $3	numeric internet spec
R$* < @@ [ $+ ] > $*	$#_SMTP_ $@@ [$2] $: $1 < @@ [$2] > $3	still numeric: send',
	`dnl')
d727 1
a727 1
R< @@ $+ >		$#error $@@ 5.1.1 $: "user address required"
d729 9
d740 7
d748 2
a749 3
define(`X', ifdef(`VIRTUSER_TABLE', `', `#'))dnl
X`'R$+ < @@ $=w . > 	$: < $(virtuser $1 @@ $2 $@@ $1 $: @@ $) > $1 < @@ $2 . >
X`'R<@@> $+ + $* < @@ $* . >
d751 1
a751 1
X`'R<@@> $+ + $* < @@ $* . >
d753 5
a757 5
X`'R<@@> $+ < @@ $+ . >	$: < $(virtuser @@ $2 $@@ $1 $: @@ $) > $1 < @@ $2 . >
X`'R<@@> $+			$: $1
X`'R< error : $- $+ > $* 	$#error $@@ $( dequote $1 $) $: $2
X`'R< $+ > $+ < @@ $+ >	$: $>97 $1
undefine(`X')dnl
d760 2
a761 2
ifdef(`_MAILER_usenet_', `', `#')dnl
R$+ . USENET < @@ $=w . >	$#usenet $: $1		handle usenet specially
d770 1
a770 1
define(`X', ifdef(`MAILER_TABLE', `', `#'))dnl
d772 6
a777 6
X`'R$* <@@ $+ > $*		$: < $2 > $1 < @@ $2 > $3	extract host name
X`'R< $+ . > $*		$: < $1 > $2			strip trailing dot
X`'R< $+ > $*		$: < $(mailertable $1 $) > $2	lookup
X`'R< $~[ : $+ > $* 	$>95 < $1 : $2 > $3		check -- resolved?
X`'R< $+ > $*		$: $>90 <$1> $2			try domain
undefine(`X')dnl
d830 1
a830 5
`R$* < @@$* > $*		$#error $@@ 5.1.2 $: Unrecognized host name $2')

# if this is quoted, strip the quotes and try again
R$+			$: $(dequote $1 $)		strip quotes
R$+ $=O $+		$@@ $>97 $1 $2 $3			try again
d849 1
a849 1
define(`X', ifdef(`LUSER_RELAY', `', `#'))dnl
d851 4
a854 4
X`'R< > $+ 		$: < $L . > $( user $1 $)	look up user
X`'R< $* > $+ <> $*	$: < > $2 $3			found; strip $L
X`'R< $* . > $+		$: < $1 > $2			strip extra dot
undefine(`X')dnl
d859 1
a859 1
R< > $+			$: < > < $1 $(dequote "" $&h $) >	nope, restore +detail
d863 1
a863 1
R$+			$: $1 $(dequote "" $&h $)	add +detail back in
d869 1
a873 1
define(`X', ifdef(`MAILER_TABLE', `', `#'))dnl
d875 7
a881 7
X`'R$* <$- . $+ > $*	$: $1$2 < $(mailertable .$3 $@@ $1$2 $@@ $2 $) > $4
X`'R$* <$~[ : $+ > $*		$>95 < $2 : $3 > $4	check -- resolved?
X`'R$* < . $+ > $* 		$@@ $>90 $1 . <$2> $3	no -- strip & try again
X`'R$* < $* > $*		$: < $(mailertable . $@@ $1$2 $) > $3	try "."
X`'R< $~[ : $+ > $*		$>95 < $1 : $2 > $3	"." found?
X`'R< $* > $*			$@@ $2			no mailertable match
undefine(`X')dnl
d889 1
a889 1
R< error : $- $+ > $*		$#error $@@ $( dequote $1 $) $: $2
d921 1
a922 1
define(`X', ifdef(`GENERICS_TABLE', `', `#'))dnl
d924 9
a932 9
`X`'R$+ < @@ $* $=G . >	$: < $1@@$2$3 > $1 < @@ $2$3 . > @@	mark',
`X`'R$+ < @@ $=G . >	$: < $1@@$2 > $1 < @@ $2 . > @@	mark')
X`'R$+ < @@ *LOCAL* >	$: < $1@@$j > $1 < @@ *LOCAL* > @@	mark
X`'R< $+ > $+ < $* > @@	$: < $(generics $1 $: $) > $2 < $3 >
X`'R< > $+ < @@ $+ > 	$: < $(generics $1 $: $) > $1 < @@ $2 >
X`'R< $* @@ $* > $* < $* >	$@@ $>3 $1 @@ $2			found qualified
X`'R< $+ > $* < $* >	$: $>3 $1 @@ *LOCAL*		found unqualified
X`'R< > $*			$: $1				not found
undefine(`X')dnl
d939 2
a940 2
ifdef(`_LIMITED_MASQUERADE_', `#')dnl
R$=E < @@ $=w . >	$@@ $1 < @@ $2 . >
d946 2
a947 2
ifdef(`_LIMITED_MASQUERADE_', `#')dnl
R$* < @@ $=w . > $*	$: $1 < @@ $2 . @@ $M > $3
d957 3
a959 4
ifdef(`_MASQUERADE_ENVELOPE_', `', `#')dnl
R$+			$@@ $>93 $1
ifdef(`_MASQUERADE_ENVELOPE_', `#', `')dnl
R$* < @@ *LOCAL* > $*	$: $1 < @@ $j . > $2
d967 292
@


1.5
log
@Sendmail 8.8.6.
@
text
@d37 1
a37 1
VERSIONID(`@@(#)proto.m4	8.149 (Berkeley) 4/30/97')
d874 3
a876 1
X`'R$+ < @@ $=G . > 	$: < $1@@$2 > $1 < @@ $2 . > @@	mark
@


1.4
log
@Sendmail 8.8.5.
@
text
@d37 1
a37 1
VERSIONID(`@@(#)proto.m4	8.139 (Berkeley) 12/31/96')
d508 2
a509 1
R$* ;			$: $1				strip trailing semi
d597 1
d599 3
a601 2
R$* < @@ $+ . UUCP > $*		$: $1 < @@ $[ $2 $] . UUCP . > $3
R$* < @@ $+ . . UUCP . > $*		$@@ $1 < @@ $2 . > $3')
d610 3
a612 1
R$* < @@ $* $=M > $*		$: $1 < @@ $2 $3 . > $4
d664 5
d677 1
d686 2
a687 2
R$* < @@ > $*		$@@ $>97 $1		user@@ => user
R< @@ $=w . > : $*	$@@ $>97 $2		@@here:... -> ...
d690 1
a690 4
R$* $=O $* < @@ $=w . >	$@@ $>97 $1 $2 $3		...@@here -> ...

# handle local hacks
R$*			$: $>98 $1
d692 1
d696 6
a701 2
X`'R< @@ > $+ < @@ $+ . >	$: < $(virtuser @@ $2 $@@ $1 $: @@ $) > $1 < @@ $2 . >
X`'R< @@ > $+		$: $1
d795 1
a795 1
R$+ + $*		$#_LOCAL_ $@@ $2 $: $1 + *
a801 1
X`'R< > $+ + $*		$: < $L . > $( user $1 $) + $2
a806 3
# handle plussed local names
R< > $+ + $*		$#_LOCAL_ $@@ $2 $: $1

d810 5
a814 1
R< > $+			$@@ $1				nope, give up
d856 2
a857 2
R< > $* < @@ $* > $*		$#local $@@ $1@@$2 $: $1
R< > $+				$#local $@@ $1    $: $1
d860 1
a860 1
R< $+ @@ $+ > $*			$: < $1 > $3
d863 2
a864 2
R< $+ > $* <@@ $* > $*		$#local $@@ $2@@$3 $: $1
R< $+ > $* 			$#local $@@ $2    $: $1
@


1.3
log
@Update to Sendmail 8.8.4, plus recent patches, plus OpenBSD support.
Also include entire example configuration subset.
Includes smrsh (using /usr/libexec/sm.bin).

Of the top of my head, the only things I removed from the distribution were
contrib/mail.local.linux, src/Makefiles, all the *.0 and *.ps files.
Our praliases man page replaces the distributed one, ours is better.
@
text
@d37 1
a37 1
VERSIONID(`@@(#)proto.m4	8.136 (Berkeley) 11/24/96')
d174 4
a177 1
# class L: names that should be delivered locally, even if we have a relay
d179 2
d183 1
a183 1
CE root
a185 4
# dequoting map
Kdequote dequote

divert(0)dnl	# end of nullclient diversion
d689 1
a689 1
X`'R< error : $- $+ > $* 	$#error $@@ $1 $: $2
d802 2
d827 2
a828 3
R< error : $- $+ > $*		$#error $@@ $1 $: $2	special case errors
R< local : > $* < @@ $* >	$#local $@@ $1@@$2 $: $1	no host: use old user
R< local : $+ > $* <@@ $* . > $*	$#local $@@ $2@@$3 $: $1	special case local
d833 19
@


1.2
log
@Sendmail 8.7.3 from NetBSD
@
text
@d37 1
a37 1
VERSIONID(`@@(#)proto.m4	8.100 (Berkeley) 12/3/95')
d41 2
a42 2
# level 6 config file format
V6/Berkeley
d50 1
a50 1
ifdef(`confSMTP_MAILER',, `define(`confSMTP_MAILER', `smtp')')
d97 1
a97 1
# ... define this only if sendmail cannot automatically determine your domain
d145 3
d158 10
d209 1
a209 1
O AliasFile=ifdef(`ALIAS_FILE', `ALIAS_FILE', /etc/aliases)
d271 6
d309 2
d331 1
d368 6
d431 9
d458 1
a458 1
Tuucp
d466 1
a466 1
H?P?Return-Path: $g
a472 1
HSubject:
d489 3
a491 5
undivert(9)dnl

###########################################
###  Rulset 3 -- Name Canonicalization  ###
###########################################
d500 1
d503 2
d599 3
a601 3
ifdef(`_NO_CANONIFY_', `dnl',
`# pass to name server to make hostname canonical
R$* < @@ $* $~P > $*		$: $1 < @@ $[ $2 $3 $] > $4')
d605 2
a609 3
# if this is the local hostname, make sure we treat is as canonical
R$* < @@ $j > $*			$: $1 < @@ $j . > $2

d638 1
a638 1
R$+ % $=w @@ $=w		$1 @@ $j				u%host@@host => u@@host
d661 5
a665 2
R$* <$* : $* > $*	$#error $@@ 5.1.1 $: "colon illegal in host name part"
R$* < @@ . > $*		$#error $@@ 5.1.2 $: "invalid host name"
d677 1
d683 9
d693 2
a694 3
ifdef(`_MAILER_usenet_',
`R$+ . USENET < @@ $=w . >	$#usenet $: $1		handle usenet specially',
	`dnl')
d708 1
a708 2
X`'R< error : $- $+ > $*	$#error $@@ $1 $: $2		check -- error?
X`'R< $- : $+ > $* 	$# $1 $@@ $2 $: $3		check -- resolved?
d809 1
a809 1
X`'S90
d811 2
a812 2
X`'R$* <$- : $+ > $*	$# $2 $@@ $3 $: $4		check -- resolved?
X`'R$* < . $+ > $* 	$@@ $>90 $1 . <$2> $3		no -- strip & try again
d814 2
a815 2
X`'R<$- : $+ > $*		$# $1 $@@ $2 $: $3		"." found?
X`'R< $* > $*		$@@ $2				no mailertable match
d819 1
a819 1
###  Ruleset 95 -- canonify mailer:host syntax to triple	###
d823 8
a830 4
R< > $*			$@@ $1				strip off null relay
R< $- : $+ > $*		$# $1 $@@ $2 $: $3		try qualified mailer
R< $=w > $*		$@@ $2				delete local host
R< $+ > $*		$#_RELAY_ $@@ $1 $: $2		use unqualified mailer
d837 13
d851 3
a853 1
R$=E < @@ $=M . >	$@@ $1 < @@ $2 . >
d856 5
a860 1
R$* < @@ $=M . > $*	$: $1 < @@ $2 . @@ $M > $3	convert masqueraded doms
d864 2
a865 2
R$* < @@ $+ @@ > $*	$@@ $1 < @@ $2 > $3		$M is null
R$* < @@ $+ @@ $+ > $*	$@@ $1 < @@ $3 . > $4		$M is not null
d883 1
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
# Copyright (c) 1983 Eric P. Allman
d37 1
a37 1
VERSIONID(`@@(#)proto.m4	8.45 (Berkeley) 3/4/94')
d41 11
a51 15
ifdef(`_OLD_SENDMAIL_',
`define(`_SET_95_', 5)dnl
define(`_SET_96_', 6)dnl
define(`_SET_97_', 7)dnl
define(`_SET_98_', 8)dnl
define(`confDOMAIN_NAME',
	`ifdef(`NEED_DOMAIN', `$w.$d', `$w')')dnl',
`# level 5 config file format
V5
define(`_SET_95_', 95)dnl
define(`_SET_96_', 96)dnl
define(`_SET_97_', 97)dnl
define(`_SET_98_', 98)dnl')
ifdef(`confSMTP_MAILER',, `define(`confSMTP_MAILER', `smtp')')dnl
ifdef(`confLOCAL_MAILER',, `define(`confLOCAL_MAILER', `local')')dnl
d55 2
a56 1
			`ifdef(`_MAILER_uucp', `suucp', `unknown')')')')dnl
d60 25
d95 1
a95 1
ifdef(`confDOMAIN_NAME', `
d97 2
a98 2
Dj`'confDOMAIN_NAME',
	`dnl')
d100 1
a100 3
ifdef(`_NULL_CLIENT_ONLY_',
`include(../m4/nullrelay.m4)m4exit',
	`dnl')
d116 7
d132 14
d147 2
a148 2
`# Mailer table (overriding domains)
Kmailertable MAILER_TABLE
d150 1
a150 1
')dnl
d152 2
a153 2
`# Domain table (adding domains)
Kdomaintable DOMAIN_TABLE
a154 1
')dnl
a160 3
# who I masquerade as (null for no masquerading)
DM`'ifdef(`MASQUERADE_NAME', MASQUERADE_NAME)

d163 3
a165 2
#CLroot
CEroot
d168 2
a169 2
# operators that cannot be in local usernames (i.e., network indicators)
CO @@ % ifdef(`_NO_UUCP_', `', `!')
d171 3
a173 2
# a class with just dot (for identifying canonical names)
C..
d175 2
a176 3
ifdef(`_OLD_SENDMAIL_', `dnl',
`# dequoting map
Kdequote dequote')
d179 1
a179 21

######################
#   Special macros   #
######################

# SMTP initial login message
De`'confSMTP_LOGIN_MSG

# UNIX initial From header format
Dl`'confFROM_LINE

# my name for error messages
Dn`'confMAILER_NAME

# delimiter (operator) characters
Do`'confOPERATORS

# format of a total name
Dq`'ifdef(`confFROM_HEADER', confFROM_HEADER,
	ifdef(`_OLD_SENDMAIL_', `$g$?x ($x)$.', `$?x$x <$g>$|$g$.'))
include(`../m4/version.m4')
d186 4
a189 1
O7`'confSEVEN_BIT_INPUT
d191 3
a193 2
# wait (in minutes) for alias file rebuild
Oa`'confALIAS_WAIT
d196 4
a199 1
OA`'ifdef(`ALIAS_FILE', `ALIAS_FILE', /etc/aliases)
d201 2
a202 2
# minimum number of free blocks on filesystem
Ob`'confMIN_FREE_BLOCKS
d205 1
a205 1
OB`'confBLANK_SUB
d208 1
a208 1
Oc`'confCON_EXPENSIVE
d211 1
a211 1
OC`'confCHECKPOINT_INTERVAL
d214 1
a214 1
Od`'confDELIVERY_MODE
d217 1
a217 1
OD`'confAUTO_REBUILD
d220 1
a220 3
ifdef(`confERROR_MESSAGE',
	OE`'confERROR_MESSAGE,
	#OE/etc/sendmail.oE)
d223 1
a223 3
ifdef(`confERROR_MODE',
	Oe`'confERROR_MODE,
	#Oep)
d226 1
a226 1
Of`'confSAVE_FROM_LINES
d229 1
a229 1
OF`'confTEMP_FILE_MODE
d232 1
a232 4
OG`'confMATCH_GECOS

# default GID
Og`'confDEF_GROUP_ID
d235 1
a235 1
Oh`'confMAX_HOP
d238 1
a238 1
OH`'ifdef(`HELP_FILE', HELP_FILE, /usr/lib/sendmail.hf)
d241 1
a241 1
Oi`'confIGNORE_DOTS
d243 2
a244 4
# Insist that the BIND name server be running to resolve names
ifdef(`confBIND_OPTS',
	OI`'confBIND_OPTS,
	#OI)
d247 1
a247 1
Oj`'confMIME_FORMAT_ERRORS
d250 1
a250 3
ifdef(`confFORWARD_PATH',
	OJ`'confFORWARD_PATH,
	#OJ/var/forward/$u:$z/.forward.$w:$z/.forward)
d253 1
a253 1
Ok`'confMCI_CACHE_SIZE
d256 1
a256 1
OK`'confMCI_CACHE_TIMEOUT
d259 1
a259 1
Ol`'confUSE_ERRORS_TO
d262 1
a262 1
OL`'confLOG_LEVEL
d265 1
a265 1
Om`'confME_TOO
d268 1
a268 1
On`'confCHECK_ALIASES
d271 1
a271 1
Oo`'confOLD_STYLE_HEADERS
d274 1
a274 3
ifdef(`confDAEMON_OPTIONS',
	OO`'confDAEMON_OPTIONS,
	#OOPort=esmtp)
d277 1
a277 1
Op`'confPRIVACY_FLAGS
d280 1
a280 3
ifdef(`confCOPY_ERRORS_TO',
	OP`'confCOPY_ERRORS_TO,
	#OPPostmaster)
d283 1
a283 3
ifdef(`confQUEUE_FACTOR',
	Oq`'confQUEUE_FACTOR,
	#Oq600000)
d286 24
a309 1
OQ`'ifdef(`QUEUE_DIR', QUEUE_DIR, /var/spool/mqueue)
d311 2
a312 4
# read timeout -- now OK per RFC 1123 section 5.3.2
ifdef(`confREAD_TIMEOUT',
	Or`'confREAD_TIMEOUT,
	#Ordatablock=10m)
d315 1
a315 1
Os`'confSAFE_QUEUE
d318 1
a318 4
OS`'ifdef(`STATUS_FILE', STATUS_FILE, /etc/sendmail.st)

# default message timeout interval
OT`'confMESSAGE_TIMEOUT
d324 3
a326 3
ifelse(confTIME_ZONE, `USE_SYSTEM', `#Ot',
	confTIME_ZONE, `USE_TZ', `Ot',
	`Ot`'confTIME_ZONE')
d328 2
a329 2
# default UID
Ou`'confDEF_USER_ID
d332 1
a332 1
OU`'ifdef(`confUSERDB_SPEC', `confUSERDB_SPEC')
d335 1
a335 3
ifdef(`confFALLBACK_MX',
	OV`'confFALLBACK_MX,
	#OVfall.back.host.net)
d338 1
a338 1
Ow`'confTRY_NULL_MX_LIST
d341 1
a341 1
Ox`'confQUEUE_LA
d344 1
a344 1
OX`'confREFUSE_LA
d347 1
a347 3
ifdef(`confWORK_RECIPIENT_FACTOR',
	Oy`'confWORK_RECIPIENT_FACTOR,
	#Oy30000)
d350 1
a350 1
OY`'confSEPARATE_PROC
d353 1
a353 3
ifdef(`confWORK_CLASS_FACTOR',
	Oz`'confWORK_CLASS_FACTOR,
	#Oz1800)
d356 46
a401 3
ifdef(`confWORK_TIME_FACTOR',
	OZ`'confWORK_TIME_FACTOR,
	#OZ90000)
d417 2
d422 1
d428 1
d430 1
a430 1
HReceived: $?sfrom $s $.$?_($?s$|from $.$_) $.by $j ($v/$Z)$?r with $r$. id $i$?u for $u$.; $b
d433 2
a434 2
H?F?Resent-From: $q
H?F?From: $q
d441 3
d463 18
a480 8
# basic textual canonicalization -- note RFC733 heuristic here
R$*<$*>$*<$*>$*		$2$3<$4>$5			strip multiple <> <>
R$*<$*<$+>$*>$*		<$3>$5				2-level <> nesting
R$*<>$*			$@@ <@@>				MAIL FROM:<> case
R$*<$+>$*		$2				basic RFC821/822 parsing

# handle list:; syntax as special case
R$*:;$*			$@@ $1 :; <@@>
d486 1
a486 1
R@@ $+ : $+		$@@ $>_SET_96_ < @@$1 > : $2		handle <route-addr>
d489 1
a489 1
R $+ : $* ; @@ $+	$@@ $>_SET_96_ $1 : $2 ; < @@ $3 >	list syntax
d495 1
a495 1
R$+ < @@ $+ >		$@@ $>_SET_96_ $1 < @@ $2 >		already canonical
d502 10
a511 4
R$- ! $+		$@@ $>_SET_96_ $2 < @@ $1 .UUCP >	resolve uucp names
R$+ . $- ! $+		$@@ $>_SET_96_ $3 < @@ $1 . $2 >		domain uucps
R$+ ! $+		$@@ $>_SET_96_ $2 < @@ $1 .UUCP >	uucp subdomains')

d515 1
a515 1
R$* @@ $*		$@@ $>_SET_96_ $1 < @@ $2 >		Insert < > and finish
d518 1
d522 1
a522 1
###  Ruleset _SET_96_ -- bottom half of ruleset 3  ###
d525 1
a525 2
#  At this point, everything should be in a "local_part<@@domain>extra" format.
S`'_SET_96_
d535 5
a539 4
ifdef(`DOMAIN_TABLE', `
# look up unqualified domains in the domain table
R$* < @@ $- > $*			$: $1 < @@ $(domaintable $2 $) > $3',
`dnl')
d560 1
a560 3
ifdef(`_OLD_SENDMAIL_',
`R$* < @@ $+ . $+ . UUCP . > $*		$@@ $1 < @@ $2 . $3 . > $4',
`R$* < @@ $+ . . UUCP . > $*		$@@ $1 < @@ $2 . > $3')')
d580 1
a580 1
R$*<@@>			$@@ $1				handle <> and list:;
d585 3
d597 4
d607 1
a607 1
###   Ruleset _SET_97_ -- recanonicalize and call ruleset zero   ###
d611 1
a611 1
S`'_SET_97_
d622 5
a626 4
R<@@>			$#_LOCAL_ $: <>			special case error msgs
R$* : $* ;		$#error $@@ USAGE $: "list:; syntax illegal for recipient addresses"
R<@@ $+>			$#error $@@ USAGE $: "user address required"
R<$* : $* >		$#error $@@ USAGE $: "colon illegal in host name part"
d630 1
a630 1
R$* < @@ [ $+ ] > $*	$: $>_SET_98_ $1 < @@ [ $2 ] > $3	numeric internet spec
d635 4
a638 3
R$* < @@ > $*		$@@ $>_SET_97_ $1		user@@ => user
R< @@ $=w . > : $*	$@@ $>_SET_97_ $2		@@here:... -> ...
R$* $=O $* < @@ $=w . >	$@@ $>_SET_97_ $1 $2 $3		...@@here -> ...
d641 1
a641 1
R$*			$: $>_SET_98_ $1
d644 12
a655 12
ifdef(`_LOCAL_NOT_STICKY_',
`R$=L < @@ $=w . >		$#_LOCAL_ $: @@ $1			special local names
R$+ < @@ $=w . >		$#_LOCAL_ $: $1			dispose directly',
`R$+ < @@ $=w . >		$: $1 < @@ $2 . @@ $H >		first try hub
ifdef(`_OLD_SENDMAIL_',
`R$+ < $+ @@ $-:$+ >	$# $3 $@@ $4 $: $1 < $2 >	yep ....
R$+ < $+ @@ $+ >		$#relay $@@ $3 $: $1 < $2 >	yep ....
R$+ < $+ @@ >		$#_LOCAL_ $: $1			nope, local address',
`R$+ < $+ @@ $+ >		$#_LOCAL_ $: $1			yep ....
R$+ < $+ @@ >		$#_LOCAL_ $: @@ $1			nope, local address')')
ifdef(`MAILER_TABLE',
`
d657 7
a663 6
R$* <@@ $+ > $*		$: < $2 > $1 < @@ $2 > $3	extract host name
R< $+ . > $*		$: < $1 > $2			strip trailing dot
R< $+ > $*		$: < $(mailertable $1 $) > $2	lookup
R< $- : $+ > $*		$# $1 $@@ $2 $: $3		check -- resolved?
R< $+ > $*		$: $>90 <$1> $2			try domain',
`dnl')
d669 1
a669 1
`R$* < @@ $=V . UUCP . > $*		$: $>_SET_95_ < $V > $1 <@@$2.UUCP.> $3',
d672 1
a672 1
`R$* < @@ $=W . UUCP . > $*		$: $>_SET_95_ < $W > $1 <@@$2.UUCP.> $3',
d675 1
a675 1
`R$* < @@ $=X . UUCP . > $*		$: $>_SET_95_ < $X > $1 <@@$2.UUCP.> $3',
d680 4
a683 1
`R$*<@@$+.BITNET.>$*	$: $>_SET_95_ < $B > $1 <@@$2.BITNET.> $3	user@@host.BITNET',
d691 1
a691 1
`R$*<@@$+.FAX.>$*		$: $>_SET_95_ < $F > $1 <@@$2.FAX.> $3	user@@host.FAX',
d696 1
a696 1
R$*<@@$*.UUCP.>$*		$: $>_SET_95_ < $Y > $1 <@@$2.UUCP.> $3	uucp mail',
d699 1
a699 1
R$* < @@ $+ .UUCP. > $*		$#uucp $@@ $2 $: $1 < @@ $2 .UUCP. > $3	user@@host.UUCP',
d711 1
a711 1
R$* < @@ $* > $*		$: $>_SET_95_ < $S > $1 < @@ $2 > $3	glue on smarthost name
d716 1
a716 1
`R$* < @@$* > $*		$#error $@@NOHOST $: Unrecognized host name $2')
d718 1
a718 8
ifdef(`_OLD_SENDMAIL_',
`# forward remaining names to local relay, if any
R$=L			$#_LOCAL_ $: $1			special local names
R$+			$: $>_SET_95_ < $R > $1			try relay
R$+			$: $>_SET_95_ < $H > $1			try hub
R$+			$#_LOCAL_ $: $1			no relay or hub: local',

`# if this is quoted, strip the quotes and try again
d720 1
a720 1
R$+ $=O $+		$@@ $>_SET_97_ $1 $2 $3			try again
a727 1
###		   (new sendmail only)					###
d732 18
a750 1
R$+			$: < $R > $1			try relay
d752 1
d754 2
a755 4
R< $- : $+ > $+		$: $>_SET_95_ < $1 : $2 > $3 < @@ $2 >
R< $+ > $+		$@@ $>_SET_95_ < $1 > $2 < @@ $1 >')
ifdef(`MAILER_TABLE',
`
a758 1
###		   (new sendmail only)				###
d761 9
a769 8
S90
R$* <$- . $+ > $*	$: $1$2 < $(mailertable .$3 $@@ $1$2 $@@ $2 $) > $4
R$* <$- : $+ > $*	$# $2 $@@ $3 $: $4		check -- resolved?
R$* < . $+ > $*		$@@ $>90 $1 . <$2> $3		no -- strip & try again
R$* < $* > $*		$: < $(mailertable . $@@ $1$2 $) > $3	try "."
R<$- : $+ > $*		$# $1 $@@ $2 $: $3		"." found?
R< $* > $*		$@@ $2				no mailertable match',
`dnl')
d772 1
a772 1
###  Ruleset _SET_95_ -- canonify mailer:host syntax to triple	###
d775 1
a775 1
S`'_SET_95_
d782 27
a808 1
###  Ruleset _SET_98_ -- local part of ruleset zero (can be null)	###
d811 1
a811 1
S`'_SET_98_
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@


1.1.1.2
log
@sendmail 8.9.1
@
text
@d3 1
a3 2
# Copyright (c) 1998 Sendmail, Inc.  All rights reserved.
# Copyright (c) 1983, 1995 Eric P. Allman.  All rights reserved.
d7 15
a21 3
# By using this file, you agree to the terms and conditions set
# forth in the LICENSE file which can be found at the top level of
# the sendmail distribution.
d23 11
d37 1
a37 1
VERSIONID(`@@(#)proto.m4	8.223 (Berkeley) 6/30/98')
d41 15
a55 11
# level 8 config file format
V8/Berkeley
divert(-1)

# do some sanity checking
ifdef(`__OSTYPE__',,
	`errprint(`*** ERROR: No system type defined (use OSTYPE macro)')')

# pick our default mailers
ifdef(`confSMTP_MAILER',, `define(`confSMTP_MAILER', `esmtp')')
ifdef(`confLOCAL_MAILER',, `define(`confLOCAL_MAILER', `local')')
d59 1
a59 2
			`ifdef(`_MAILER_uucp', `uucp-new', `unknown')')')')
ifdef(`confUUCP_MAILER',, `define(`confUUCP_MAILER', `uucp-old')')
a62 32
define(`_UUCP_', `confUUCP_MAILER')dnl		for readability only

# set our default hashed database type
ifdef(`DATABASE_MAP_TYPE',, `define(`DATABASE_MAP_TYPE', `hash')')

# back compatibility with old config files
ifdef(`confDEF_GROUP_ID',
	`errprint(`*** confDEF_GROUP_ID is obsolete.')
	 errprint(`    Use confDEF_USER_ID with a colon in the value instead.')')
ifdef(`confREAD_TIMEOUT',
	`errprint(`*** confREAD_TIMEOUT is obsolete.')
	 errprint(`    Use individual confTO_<timeout> parameters instead.')')
ifdef(`confMESSAGE_TIMEOUT',
	`define(`_ARG_', index(confMESSAGE_TIMEOUT, /))
	 ifelse(_ARG_, -1,
		`define(`confTO_QUEUERETURN', confMESSAGE_TIMEOUT)',
		`define(`confTO_QUEUERETURN',
			substr(confMESSAGE_TIMEOUT, 0, _ARG_))
		 define(`confTO_QUEUEWARN',
			substr(confMESSAGE_TIMEOUT, eval(_ARG_+1)))')')
ifdef(`confMIN_FREE_BLOCKS', `ifelse(index(confMIN_FREE_BLOCKS, /), -1,,
	`errprint(`*** compound confMIN_FREE_BLOCKS is obsolete.')
	 errprint(`    Use confMAX_MESSAGE_SIZE for the second part of the value.')')')

# clean option definitions below....
define(`_OPTION', `ifdef(`$2', `O $1=$2', `#O $1`'ifelse($3, `',, `=$3')')')dnl

divert(0)dnl

# override file safeties - setting this option compromises system security
# need to set this now for the sake of class files
_OPTION(DontBlameSendmail, `confDONT_BLAME_SENDMAIL', safe)
d73 1
a73 1

d75 2
a76 2
# ... `define' this only if sendmail cannot automatically determine your domain
ifdef(`confDOMAIN_NAME', `Dj`'confDOMAIN_NAME', `#Dj$w.Foo.COM')
d78 3
a80 1
ifdef(`_NULL_CLIENT_ONLY_', `divert(-1)')dnl
a95 7
ifdef(`DECNET_RELAY',
`define(`_USE_DECNET_SYNTAX_', 1)dnl
# DECnet relay host
DC`'DECNET_RELAY
CPDECNET

')dnl
d105 3
a107 5
ifdef(`LUSER_RELAY', `dnl
# place to which unknown users should be forwarded
Kuser user -m -a<>
DL`'LUSER_RELAY',
`dnl')
d109 4
a112 2
# operators that cannot be in local usernames (i.e., network indicators)
CO @@ % ifdef(`_NO_UUCP_', `', `!')
d114 3
a116 2
# a class with just dot (for identifying canonical names)
C..
d118 2
a119 2
# a class with just a left bracket (for identifying domain literals)
C[[
d121 2
a122 4
ifdef(`MAILER_TABLE', `dnl
# Mailer table (overriding domains)
Kmailertable MAILER_TABLE',
`dnl')
d124 5
a128 4
ifdef(`DOMAIN_TABLE', `dnl
# Domain table (adding domains)
Kdomaintable DOMAIN_TABLE',
`dnl')
d130 2
a131 4
ifdef(`GENERICS_TABLE', `dnl
# Generics table (mapping outgoing addresses)
Kgenerics GENERICS_TABLE',
`dnl')
d133 2
a134 4
ifdef(`UUDOMAIN_TABLE', `dnl
# UUCP domain table
Kuudomain UUDOMAIN_TABLE',
`dnl')
d136 3
a138 4
ifdef(`BITDOMAIN_TABLE', `dnl
# BITNET mapping table
Kbitdomain BITDOMAIN_TABLE',
`dnl')
d140 1
a140 4
ifdef(`VIRTUSER_TABLE', `dnl
# Virtual user table (maps incoming users)
Kvirtuser VIRTUSER_TABLE',
`dnl')
d142 3
a144 4
ifdef(`ACCESS_TABLE', `dnl
# Access list database (for spam stomping)
Kaccess ACCESS_TABLE',
`dnl')
d146 2
a147 4
ifdef(`_RELAY_MX_SERVED_', `dnl
# MX map (to allow relaying to hosts that we MX for)
Kmxserved bestmx -z: -T<TEMP>',
`dnl')
d149 2
a150 8
ifdef(`_ACCEPT_UNRESOLVABLE_DOMAINS_',`dnl',`dnl
# Resolve map (to check if a host exists in check_mail)
Kresolve host -a<OK> -T<TEMP>')

ifdef(`confCR_FILE', `dnl
# Hosts that will permit relaying ($=R)
FR`'confCR_FILE',
`dnl')
d152 2
a153 2
# who I send unqualified names to (null means deliver locally)
DR`'ifdef(`LOCAL_RELAY', LOCAL_RELAY)
d155 2
a156 14
# who gets all local email traffic ($R has precedence for unqualified names)
DH`'ifdef(`MAIL_HUB', MAIL_HUB)

# dequoting map
Kdequote dequote

divert(0)dnl	# end of nullclient diversion
# class E: names that should be exposed as from this host, even if we masquerade
ifdef(`_NULL_CLIENT_ONLY_', `#',
`# class L: names that should be delivered locally, even if we have a relay
# class M: domains that should be converted to $M
#CL root
')CE root
undivert(5)dnl
d158 4
a161 8
# who I masquerade as (null for no masquerading) (see also $=M)
DM`'ifdef(`MASQUERADE_NAME', MASQUERADE_NAME)

# my name for error messages
ifdef(`confMAILER_NAME', `Dn`'confMAILER_NAME', `#DnMAILER-DAEMON')

undivert(6)dnl
include(_CF_DIR_`m4/version.m4')
d168 1
a168 1
_OPTION(SevenBitInput, `confSEVEN_BIT_INPUT')
d170 2
a171 2
# 8-bit data handling
_OPTION(EightBitMode, `confEIGHT_BIT_HANDLING', adaptive)
d173 2
a174 3
ifdef(`_NULL_CLIENT_ONLY_', `dnl', `
# wait for alias file rebuild (default units: minutes)
_OPTION(AliasWait, `confALIAS_WAIT', 5m)
a175 3
# location of alias file
_OPTION(AliasFile, `ALIAS_FILE', /etc/aliases)
')
d177 1
a177 4
_OPTION(MinFreeBlocks, `confMIN_FREE_BLOCKS', 100)

# maximum message size
_OPTION(MaxMessageSize, `confMAX_MESSAGE_SIZE', 1000000)
d180 1
a180 1
_OPTION(BlankSub, `confBLANK_SUB', _)
d183 1
a183 1
_OPTION(HoldExpensive, `confCON_EXPENSIVE')
d186 1
a186 1
_OPTION(CheckpointInterval, `confCHECKPOINT_INTERVAL', 10)
d189 1
a189 1
_OPTION(DeliveryMode, `confDELIVERY_MODE', background)
d192 1
a192 1
_OPTION(AutoRebuildAliases, `confAUTO_REBUILD')
d195 3
a197 1
_OPTION(ErrorHeader, `confERROR_MESSAGE', /etc/sendmail.oE)
d200 3
a202 1
_OPTION(ErrorMode, `confERROR_MODE', print)
d205 1
a205 1
_OPTION(SaveFromLine, `confSAVE_FROM_LINES')
d208 1
a208 1
_OPTION(TempFileMode, `confTEMP_FILE_MODE', 0600)
d211 4
a214 1
_OPTION(MatchGECOS, `confMATCH_GECOS')
d217 1
a217 1
_OPTION(MaxHopCount, `confMAX_HOP', 17)
d220 1
a220 1
O HelpFile=ifdef(`HELP_FILE', HELP_FILE, /usr/lib/sendmail.hf)
d223 1
a223 1
_OPTION(IgnoreDots, `confIGNORE_DOTS')
d225 4
a228 2
# name resolver options
_OPTION(ResolverOptions, `confBIND_OPTS', +AAONLY)
d231 1
a231 1
_OPTION(SendMimeErrors, `confMIME_FORMAT_ERRORS')
d234 3
a236 1
_OPTION(ForwardPath, `confFORWARD_PATH', /var/forward/$u:$z/.forward.$w:$z/.forward)
d239 1
a239 1
_OPTION(ConnectionCacheSize, `confMCI_CACHE_SIZE', 2)
d242 1
a242 7
_OPTION(ConnectionCacheTimeout, `confMCI_CACHE_TIMEOUT', 5m)

# persistent host status directory
_OPTION(HostStatusDirectory, `confHOST_STATUS_DIRECTORY', .hoststat)

# single thread deliveries (requires HostStatusDirectory)?
_OPTION(SingleThreadDelivery, `confSINGLE_THREAD_DELIVERY')
d245 1
a245 1
_OPTION(UseErrorsTo, `confUSE_ERRORS_TO')
d248 1
a248 1
_OPTION(LogLevel, `confLOG_LEVEL', 10)
d251 1
a251 1
_OPTION(MeToo, `confME_TOO')
d254 1
a254 1
_OPTION(CheckAliases, `confCHECK_ALIASES')
d257 1
a257 1
_OPTION(OldStyleHeaders, `confOLD_STYLE_HEADERS')
d260 3
a262 1
_OPTION(DaemonPortOptions, `confDAEMON_OPTIONS', Port=esmtp)
d265 1
a265 1
_OPTION(PrivacyOptions, `confPRIVACY_FLAGS', authwarnings)
d268 3
a270 1
_OPTION(PostMasterCopy, `confCOPY_ERRORS_TO', Postmaster)
d273 3
a275 1
_OPTION(QueueFactor, `confQUEUE_FACTOR', 600000)
d278 1
a278 1
O QueueDirectory=ifdef(`QUEUE_DIR', QUEUE_DIR, /var/spool/mqueue)
d280 4
a283 28
# timeouts (many of these)
_OPTION(Timeout.initial, `confTO_INITIAL', 5m)
_OPTION(Timeout.connect, `confTO_CONNECT', 5m)
_OPTION(Timeout.iconnect, `confTO_ICONNECT', 5m)
_OPTION(Timeout.helo, `confTO_HELO', 5m)
_OPTION(Timeout.mail, `confTO_MAIL', 10m)
_OPTION(Timeout.rcpt, `confTO_RCPT', 1h)
_OPTION(Timeout.datainit, `confTO_DATAINIT', 5m)
_OPTION(Timeout.datablock, `confTO_DATABLOCK', 1h)
_OPTION(Timeout.datafinal, `confTO_DATAFINAL', 1h)
_OPTION(Timeout.rset, `confTO_RSET', 5m)
_OPTION(Timeout.quit, `confTO_QUIT', 2m)
_OPTION(Timeout.misc, `confTO_MISC', 2m)
_OPTION(Timeout.command, `confTO_COMMAND', 1h)
_OPTION(Timeout.ident, `confTO_IDENT', 30s)
_OPTION(Timeout.fileopen, `confTO_FILEOPEN', 60s)
_OPTION(Timeout.queuereturn, `confTO_QUEUERETURN', 5d)
_OPTION(Timeout.queuereturn.normal, `confTO_QUEUERETURN_NORMAL', 5d)
_OPTION(Timeout.queuereturn.urgent, `confTO_QUEUERETURN_URGENT', 2d)
_OPTION(Timeout.queuereturn.non-urgent, `confTO_QUEUERETURN_NONURGENT', 7d)
_OPTION(Timeout.queuewarn, `confTO_QUEUEWARN', 4h)
_OPTION(Timeout.queuewarn.normal, `confTO_QUEUEWARN_NORMAL', 4h)
_OPTION(Timeout.queuewarn.urgent, `confTO_QUEUEWARN_URGENT', 1h)
_OPTION(Timeout.queuewarn.non-urgent, `confTO_QUEUEWARN_NONURGENT', 12h)
_OPTION(Timeout.hoststatus, `confTO_HOSTSTATUS', 30m)

# should we not prune routes in route-addr syntax addresses?
_OPTION(DontPruneRoutes, `confDONT_PRUNE_ROUTES')
d286 1
a286 1
_OPTION(SuperSafe, `confSAFE_QUEUE')
d289 4
a292 1
O StatusFile=ifdef(`STATUS_FILE', `STATUS_FILE', /etc/sendmail.st)
d298 3
a300 3
ifelse(confTIME_ZONE, `USE_SYSTEM', `#O TimeZoneSpec=',
	confTIME_ZONE, `USE_TZ', `O TimeZoneSpec=',
	`O TimeZoneSpec=confTIME_ZONE')
d302 2
a303 2
# default UID (can be username or userid:groupid)
_OPTION(DefaultUser, `confDEF_USER_ID', mailnull)
d306 1
a306 1
_OPTION(UserDatabaseSpec, `confUSERDB_SPEC', /etc/userdb)
d309 3
a311 1
_OPTION(FallbackMXhost, `confFALLBACK_MX', fall.back.host.net)
d314 1
a314 1
_OPTION(TryNullMXList, `confTRY_NULL_MX_LIST')
d317 1
a317 1
_OPTION(QueueLA, `confQUEUE_LA', 8)
d320 1
a320 7
_OPTION(RefuseLA, `confREFUSE_LA', 12)

# maximum number of children we allow at one time
_OPTION(MaxDaemonChildren, `confMAX_DAEMON_CHILDREN', 12)

# maximum number of new connections per second
_OPTION(ConnectionRateThrottle, `confCONNECTION_RATE_THROTTLE', 3)
d323 3
a325 1
_OPTION(RecipientFactor, `confWORK_RECIPIENT_FACTOR', 30000)
d328 1
a328 1
_OPTION(ForkEachJob, `confSEPARATE_PROC')
d331 3
a333 1
_OPTION(ClassFactor, `confWORK_CLASS_FACTOR', 1800)
d336 3
a338 70
_OPTION(RetryFactor, `confWORK_TIME_FACTOR', 90000)

# shall we sort the queue by hostname first?
_OPTION(QueueSortOrder, `confQUEUE_SORT_ORDER', priority)

# minimum time in queue before retry
_OPTION(MinQueueAge, `confMIN_QUEUE_AGE', 30m)

# default character set
_OPTION(DefaultCharSet, `confDEF_CHAR_SET', iso-8859-1)

# service switch file (ignored on Solaris, Ultrix, OSF/1, others)
_OPTION(ServiceSwitchFile, `confSERVICE_SWITCH_FILE', /etc/service.switch)

# hosts file (normally /etc/hosts)
_OPTION(HostsFile, `confHOSTS_FILE', /etc/hosts)

# dialup line delay on connection failure
_OPTION(DialDelay, `confDIAL_DELAY', 10s)

# action to take if there are no recipients in the message
_OPTION(NoRecipientAction, `confNO_RCPT_ACTION', add-to-undisclosed)

# chrooted environment for writing to files
_OPTION(SafeFileEnvironment, `confSAFE_FILE_ENV', /arch)

# are colons OK in addresses?
_OPTION(ColonOkInAddr, `confCOLON_OK_IN_ADDR')

# how many jobs can you process in the queue?
_OPTION(MaxQueueRunSize, `confMAX_QUEUE_RUN_SIZE', 10000)

# shall I avoid expanding CNAMEs (violates protocols)?
_OPTION(DontExpandCnames, `confDONT_EXPAND_CNAMES')

# SMTP initial login message (old $e macro)
_OPTION(SmtpGreetingMessage, `confSMTP_LOGIN_MSG')

# UNIX initial From header format (old $l macro)
_OPTION(UnixFromLine, `confFROM_LINE')

# From: lines that have embedded newlines are unwrapped onto one line
_OPTION(SingleLineFromHeader, `confSINGLE_LINE_FROM_HEADER', False)

# Allow HELO SMTP command that does not `include' a host name
_OPTION(AllowBogusHELO, `confALLOW_BOGUS_HELO', False)

# Characters to be quoted in a full name phrase (@@,;:\()[] are automatic)
_OPTION(MustQuoteChars, `confMUST_QUOTE_CHARS', .)

# delimiter (operator) characters (old $o macro)
_OPTION(OperatorChars, `confOPERATORS')

# shall I avoid calling initgroups(3) because of high NIS costs?
_OPTION(DontInitGroups, `confDONT_INIT_GROUPS')

# are group-writable `:include:' and .forward files (un)trustworthy?
_OPTION(UnsafeGroupWrites, `confUNSAFE_GROUP_WRITES')

# where do errors that occur when sending errors get sent?
_OPTION(DoubleBounceAddress, `confDOUBLE_BOUNCE_ADDRESS', postmaster)

# what user id do we assume for the majority of the processing?
_OPTION(RunAsUser, `confRUN_AS_USER', sendmail)

# maximum number of recipients per SMTP envelope
_OPTION(MaxRecipientsPerMessage, `confMAX_RCPTS_PER_MESSAGE', 100)

# shall we get local names from our installed interfaces?
_OPTION(DontProbeInterfaces, `confDONT_PROBE_INTERFACES')
a353 2
# this is equivalent to setting class "t"
ifdef(`_USE_CT_FILE_', `', `#')Ft`'ifdef(`confCT_FILE', confCT_FILE, `/etc/sendmail.ct')
d356 1
a356 2
ifdef(`_NO_UUCP_', `dnl', `Tuucp')
ifdef(`confTRUSTED_USERS', `T`'confTRUSTED_USERS', `dnl')
d362 2
a363 3
ifdef(`confFROM_HEADER',, `define(`confFROM_HEADER', `$?x$x <$g>$|$g$.')')dnl
H?P?Return-Path: <$g>
HReceived: confRECEIVED_HEADER
d366 2
a367 2
H?F?Resent-From: confFROM_HEADER
H?F?From: confFROM_HEADER
d369 1
a373 3
ifdef(`_NULL_CLIENT_ONLY_',
	`include(_CF_DIR_`'m4/nullrelay.m4)m4exit',
	`dnl')
d383 5
a387 3
############################################
###  Ruleset 3 -- Name Canonicalization  ###
############################################
d393 8
a400 22
# strip group: syntax (not inside angle brackets!) and trailing semicolon
R$*			$: $1 <@@>			mark addresses
R$* < $* > $* <@@>	$: $1 < $2 > $3			unmark <addr>
R@@ $* <@@>		$: @@ $1				unmark @@host:...
R$* :: $* <@@>		$: $1 :: $2			unmark node::addr
R:`include': $* <@@>	$: :`include': $1			unmark :`include':...
R$* [ $* : $* ] <@@>	$: $1 [ $2 : $3 ]		unmark IPv6 addrs
R$* : $* [ $* ]		$: $1 : $2 [ $3 ] <@@>		remark if leading colon
R$* : $* <@@>		$: $2				strip colon if marked
R$* <@@>			$: $1				unmark
R$* ;			   $1				strip trailing semi
R$* < $* ; >		   $1 < $2 >			bogus bracketed semi

# null input now results from list:; syntax
R$@@			$@@ :; <@@>

# strip angle brackets -- note RFC733 heuristic to get innermost item
R$*			$: < $1 >			housekeeping <>
R$+ < $* >		   < $2 >			strip excess on left
R< $* > $+		   < $1 >			strip excess on right
R<>			$@@ < @@ >			MAIL FROM:<> case
R< $+ >			$: $1				remove housekeeping <>
d406 1
a406 1
R@@ $+ : $+		$@@ $>96 < @@$1 > : $2		handle <route-addr>
d409 1
a409 1
R $+ : $* ; @@ $+	$@@ $>96 $1 : $2 ; < @@ $3 >	list syntax
d415 1
a415 1
R$+ < @@ $+ >		$@@ $>96 $1 < @@ $2 >		already canonical
d422 4
a425 10
R$- ! $+		$@@ $>96 $2 < @@ $1 .UUCP >	resolve uucp names
R$+ . $- ! $+		$@@ $>96 $3 < @@ $1 . $2 >		domain uucps
R$+ ! $+		$@@ $>96 $2 < @@ $1 .UUCP >	uucp subdomains
')
ifdef(`_USE_DECNET_SYNTAX_',
`# convert node::user addresses into a domain-based address
R$- :: $+		$@@ $>96 $2 < @@ $1 .DECNET >	resolve DECnet names
R$- . $- :: $+		$@@ $>96 $3 < @@ $1.$2 .DECNET >	numeric DECnet addr
',
	`dnl')
d429 1
a429 1
R$* @@ $*		$@@ $>96 $1 < @@ $2 >		Insert < > and finish
a431 1
R$*			$@@ $>96 $1
d435 1
a435 1
###  Ruleset 96 -- bottom half of ruleset 3  ###
d438 2
a439 1
S96
d449 4
a452 5

ifdef(`DOMAIN_TABLE', `dnl
# look up domains in the domain table
R$* < @@ $+ > $* 		$: $1 < @@ $(domaintable $2 $) > $3', `dnl')

a454 8
ifdef(`BITDOMAIN_TABLE', `dnl
# handle BITNET mapping
R$* < @@ $+ .BITNET > $*		$: $1 < @@ $(bitdomain $2 $: $2.BITNET $) > $3', `dnl')

ifdef(`UUDOMAIN_TABLE', `dnl
# handle UUCP mapping
R$* < @@ $+ .UUCP > $*		$: $1 < @@ $(uudomain $2 $: $2.UUCP $) > $3', `dnl')

a470 1
ifdef(`_NO_CANONIFY_', `dnl', `dnl
d473 6
a478 4
R$* < @@ $+ . . UUCP . > $*	$@@ $1 < @@ $2 . > $3')
')')
ifdef(`_NO_CANONIFY_', `dnl', `dnl
# pass to name server to make hostname canonical
a482 4
R$* < @@ $j > $*			$: $1 < @@ $j . > $2
ifdef(`_MASQUERADE_ENTIRE_DOMAIN_',
`R$* < @@ $* $=M > $*		$: $1 < @@ $2 $3 . > $4',
`R$* < @@ $=M > $*		$: $1 < @@ $2 . > $3')
d486 3
d495 1
a495 1
R$* <@@>			$@@				handle <> and list:;
a499 3
# eliminate internal code -- should never get this far!
R$* < @@ *LOCAL* > $*	$1 < @@ $j > $2

a508 4
ifdef(`_USE_DECNET_SYNTAX_',
`# put DECnet back in :: form
R$+ @@ $+ . DECNET	$2 :: $1			u@@h.DECNET => h::u',
	`dnl')
d510 1
a510 1
R$+ % $=w @@ $=w		$1 @@ $2				u%host@@host => u@@host
d515 1
a515 1
###   Ruleset 97 -- recanonicalize and call ruleset zero   ###
d519 1
a519 1
S`'97
d530 4
a533 35
R$*			$: $>Parse0 $1		initial parsing
R<@@>			$#_LOCAL_ $: <@@>		special case error msgs
R$*			$: $>98 $1		handle local hacks
R$*			$: $>Parse1 $1		final parsing

#
#  Parse0 -- do initial syntax checking and eliminate local addresses.
#	This should either return with the (possibly modified) input
#	or return with a #error mailer.  It should not return with a
#	#mailer other than the #error mailer.
#

SParse0
R<@@>			$@@ <@@>			special case error msgs
R$* : $* ; <@@>		$#error $@@ 5.1.3 $: "List:; syntax illegal for recipient addresses"
#R@@ <@@ $* >		< @@ $1 >		catch "@@@@host" bogosity
R<@@ $+>			$#error $@@ 5.1.3 $: "User address required"
R$*			$: <> $1
R<> $* < @@ [ $+ ] > $*	$1 < @@ [ $2 ] > $3
R<> $* <$* : $* > $*	$#error $@@ 5.1.3 $: "Colon illegal in host name part"
R<> $*			$1
R$* < @@ . $* > $*	$#error $@@ 5.1.2 $: "Invalid host name"
R$* < @@ $* .. $* > $*	$#error $@@ 5.1.2 $: "Invalid host name"

# now delete the local info -- note $=O to find characters that cause forwarding
R$* < @@ > $*		$@@ $>Parse0 $>3 $1		user@@ => user
R< @@ $=w . > : $*	$@@ $>Parse0 $>3 $2		@@here:... -> ...
R$- < @@ $=w . >		$: $(dequote $1 $) < @@ $2 . >	dequote "foo"@@here
R< @@ $+ >		$#error $@@ 5.1.3 $: "User address required"
R$* $=O $* < @@ $=w . >	$@@ $>Parse0 $>3 $1 $2 $3	...@@here -> ...
R$- 			$: $(dequote $1 $) < @@ *LOCAL* >	dequote "foo"
R< @@ *LOCAL* >		$#error $@@ 5.1.3 $: "User address required"
R$* $=O $* < @@ *LOCAL* >
			$@@ $>Parse0 $>3 $1 $2 $3	...@@*LOCAL* -> ...
R$* < @@ *LOCAL* >	$: $1
a534 5
#
#  Parse1 -- the bottom half of ruleset 0.
#

SParse1
d537 1
a537 1
R$* < @@ [ $+ ] > $*	$: $>98 $1 < @@ [ $2 ] > $3	numeric internet spec
d541 7
a547 12
ifdef(`VIRTUSER_TABLE', `dnl
# handle virtual users
R$+ < @@ $=w . > 	$: < $(virtuser $1 @@ $2 $@@ $1 $: @@ $) > $1 < @@ $2 . >
R<@@> $+ + $* < @@ $* . >
			$: < $(virtuser $1 + * @@ $3 $@@ $1 $: @@ $) > $1 + $2 < @@ $3 . >
R<@@> $+ + $* < @@ $* . >
			$: < $(virtuser $1 @@ $3 $@@ $1 $: @@ $) > $1 + $2 < @@ $3 . >
R<@@> $+ < @@ $+ . >	$: < $(virtuser @@ $2 $@@ $1 $: @@ $) > $1 < @@ $2 . >
R<@@> $+			$: $1
R< error : $- $+ > $* 	$#error $@@ $(dequote $1 $) $: $2
R< $+ > $+ < @@ $+ >	$: $>97 $1',
`dnl')
d550 12
a561 11
ifdef(`_MAILER_usenet_', `dnl
R$+ . USENET < @@ $=w . >	$#usenet $: $1		handle usenet specially', `dnl')
ifdef(`_STICKY_LOCAL_DOMAIN_',
`R$+ < @@ $=w . >		$: < $H > $1 < @@ $2 . >		first try hub
R< $+ > $+ < $+ >	$>95 < $1 > $2 < $3 >		yep ....
R< > $+ + $* < $+ >	$#_LOCAL_ $: $1 + $2		plussed name?
R< > $+ < $+ >		$#_LOCAL_ $: @@ $1			nope, local address',
`R$=L < @@ $=w . >	$#_LOCAL_ $: @@ $1		special local names
R$+ < @@ $=w . >		$#_LOCAL_ $: $1			regular local name')

ifdef(`MAILER_TABLE', `dnl
d566 1
a566 1
R< $~[ : $+ > $* 	$>95 < $1 : $2 > $3		check -- resolved?
d574 1
a574 1
`R$* < @@ $=V . UUCP . > $*		$: $>95 < $V > $1 <@@$2.UUCP.> $3',
d577 1
a577 1
`R$* < @@ $=W . UUCP . > $*		$: $>95 < $W > $1 <@@$2.UUCP.> $3',
d580 1
a580 1
`R$* < @@ $=X . UUCP . > $*		$: $>95 < $X > $1 <@@$2.UUCP.> $3',
d585 1
a585 4
`R$*<@@$+.BITNET.>$*	$: $>95 < $B > $1 <@@$2.BITNET.> $3	user@@host.BITNET',
	`dnl')
ifdef(`DECNET_RELAY',
`R$*<@@$+.DECNET.>$*	$: $>95 < $C > $1 <@@$2.DECNET.> $3	user@@host.DECNET',
d593 1
a593 1
`R$*<@@$+.FAX.>$*		$: $>95 < $F > $1 <@@$2.FAX.> $3	user@@host.FAX',
d598 1
a598 1
R$*<@@$*.UUCP.>$*		$: $>95 < $Y > $1 <@@$2.UUCP.> $3	uucp mail',
d601 1
a601 1
R$* < @@ $+ .UUCP. > $*		$#_UUCP_ $@@ $2 $: $1 < @@ $2 .UUCP. > $3	user@@host.UUCP',
d613 1
a613 1
R$* < @@ $* > $*		$: $>95 < $S > $1 < @@ $2 > $3	glue on smarthost name
d618 12
a629 1
`R$* < @@$* > $*		$#error $@@ 5.1.2 $: "Unrecognized host name" $2')
d637 1
a641 14
# deal with plussed users so aliases work nicely
R$+ + *			$#_LOCAL_ $@@ $&h $: $1
R$+ + $*		$#_LOCAL_ $@@ + $2 $: $1 + *

# prepend an empty "forward host" on the front
R$+			$: <> $1

ifdef(`LUSER_RELAY', `dnl
# send unrecognized local users to a relay host
R< > $+ 		$: < $L . > $(user $1 $)	look up user
R< $* > $+ <> $*	$: < > $2 $3			found; strip $L
R< $* . > $+		$: < $1 > $2			strip extra dot',
`dnl')

d643 1
d645 5
a649 10
R< > $+			$: < $R > $1			try relay
R< > $+			$: < > < $1 $&h >		nope, restore +detail
R< > < $+ + $* > $*	   < > < $1 > + $2 $3		find the user part
R< > < $+ > + $*	$#_LOCAL_ $@@ $2 $: @@ $1		strip the extra +
R< > < $+ >		$@@ $1				no +detail
R$+			$: $1 $&h			add +detail back in
R< local : $* > $*	$: $>95 < local : $1 > $2	no host extension
R< error : $* > $*	$: $>95 < error : $1 > $2	no host extension
R< $- : $+ > $+		$: $>95 < $1 : $2 > $3 < @@ $2 >
R< $+ > $+		$@@ $>95 < $1 > $2 < @@ $1 >
a650 1
ifdef(`MAILER_TABLE', `dnl
d653 1
d658 2
a659 2
R$* <$~[ : $+ > $*	$>95 < $2 : $3 > $4		check -- resolved?
R$* < . $+ > $* 	$@@ $>90 $1 . <$2> $3		no -- strip & try again
d661 1
a661 1
R< $~[ : $+ > $*	$>95 < $1 : $2 > $3		"." found?
d666 1
a666 1
###  Ruleset 95 -- canonify mailer:[user@@]host syntax to triple	###
d669 5
a673 8
S95
R< > $*				$@@ $1			strip off null relay
R< error : $- $+ > $*		$#error $@@ $(dequote $1 $) $: $2
R< local : $* > $*		$>CanonLocal < $1 > $2
R< $- : $+ @@ $+ > $*<$*>$*	$# $1 $@@ $3 $: $2<@@$3>	use literal user
R< $- : $+ > $*			$# $1 $@@ $2 $: $3	try qualified mailer
R< $=w > $*			$@@ $2			delete local host
R< $+ > $*			$#_RELAY_ $@@ $1 $: $2	use unqualified mailer
d676 1
a676 1
###  Ruleset CanonLocal -- canonify local: syntax		###
d679 1
a679 66
SCanonLocal
# strip trailing dot from any host name that may appear
R< $* > $* < @@ $* . >		$: < $1 > $2 < @@ $3 >

# handle local: syntax -- use old user, either with or without host
R< > $* < @@ $* > $*		$#_LOCAL_ $@@ $1@@$2 $: $1
R< > $+				$#_LOCAL_ $@@ $1    $: $1

# handle local:user@@host syntax -- ignore host part
R< $+ @@ $+ > $* < @@ $* >	$: < $1 > $3 < @@ $4 >

# handle local:user syntax
R< $+ > $* <@@ $* > $*		$#_LOCAL_ $@@ $2@@$3 $: $1
R< $+ > $* 			$#_LOCAL_ $@@ $2    $: $1

###################################################################
###  Ruleset 93 -- convert header names to masqueraded form	###
###################################################################

S93

ifdef(`GENERICS_TABLE', `dnl
# handle generics database
ifdef(`_GENERICS_ENTIRE_DOMAIN_',
`R$+ < @@ $* $=G . >	$: < $1@@$2$3 > $1 < @@ $2$3 . > @@	mark',
`R$+ < @@ $=G . >	$: < $1@@$2 > $1 < @@ $2 . > @@	mark')
R$+ < @@ *LOCAL* >	$: < $1@@$j > $1 < @@ *LOCAL* > @@	mark
R< $+ > $+ < $* > @@	$: < $(generics $1 $: $) > $2 < $3 >
R< > $+ < @@ $+ > 	$: < $(generics $1 $: $) > $1 < @@ $2 >
R< $* @@ $* > $* < $* >	$@@ $>3 $1 @@ $2			found qualified
R< $+ > $* < $* >	$: $>3 $1 @@ *LOCAL*		found unqualified
R< > $*			$: $1				not found',
`dnl')

# special case the users that should be exposed
R$=E < @@ *LOCAL* >	$@@ $1 < @@ $j . >		leave exposed
ifdef(`_MASQUERADE_ENTIRE_DOMAIN_',
`R$=E < @@ $* $=M . >	$@@ $1 < @@ $2 $3 . >',
`R$=E < @@ $=M . >	$@@ $1 < @@ $2 . >')
ifdef(`_LIMITED_MASQUERADE_', `dnl',
`R$=E < @@ $=w . >	$@@ $1 < @@ $2 . >')

# handle domain-specific masquerading
ifdef(`_MASQUERADE_ENTIRE_DOMAIN_',
`R$* < @@ $* $=M . > $*	$: $1 < @@ $2 $3 . @@ $M > $4	convert masqueraded doms',
`R$* < @@ $=M . > $*	$: $1 < @@ $2 . @@ $M > $3	convert masqueraded doms')
ifdef(`_LIMITED_MASQUERADE_', `dnl',
`R$* < @@ $=w . > $*	$: $1 < @@ $2 . @@ $M > $3')
R$* < @@ *LOCAL* > $*	$: $1 < @@ $j . @@ $M > $2
R$* < @@ $+ @@ > $*	$: $1 < @@ $2 > $3		$M is null
R$* < @@ $+ @@ $+ > $*	$: $1 < @@ $3 . > $4		$M is not null

###################################################################
###  Ruleset 94 -- convert envelope names to masqueraded form	###
###################################################################

S94
ifdef(`_MASQUERADE_ENVELOPE_',
`R$+			$@@ $>93 $1',
`R$* < @@ *LOCAL* > $*	$: $1 < @@ $j . > $2')

###################################################################
###  Ruleset 98 -- local part of ruleset zero (can be null)	###
###################################################################

S98
a680 293

ifelse(confDELIVERY_MODE, defer, `errprint(`WARNING: Antispam rules not available in deferred delivery mode.')')
ifdef(`ACCESS_TABLE', `dnl
######################################################################
###  LookUpDomain -- search for domain in access database
###
###	Parameters:
###		<$1> -- key (domain name)
###		<$2> -- default (what to return if not found in db)
###		<$3> -- passthru (additional data passed unchanged through)
######################################################################

SLookUpDomain
R<$+> <$+> <$*>		$: < $(access $1 $: ? $) > <$1> <$2> <$3>
R<?> <$+.$+> <$+> <$*>	$@@ $>LookUpDomain <$2> <$3> <$4>
R<?> <$+> <$+> <$*>	$@@ <$2> <$3>
R<$*> <$+> <$+> <$*>	$@@ <$1> <$4>

######################################################################
###  LookUpAddress -- search for host address in access database
###
###	Parameters:
###		<$1> -- key (dot quadded host address)
###		<$2> -- default (what to return if not found in db)
###		<$3> -- passthru (additional data passed through)
######################################################################

SLookUpAddress
R<$+> <$+> <$*>		$: < $(access $1 $: ? $) > <$1> <$2> <$3>
R<?> <$+.$-> <$+> <$*>	$@@ $>LookUpAddress <$1> <$3> <$4>
R<?> <$+> <$+> <$*>	$@@ <$2> <$3>
R<$*> <$+> <$+> <$*>	$@@ <$1> <$4>',
`dnl')

######################################################################
###  ParseRecipient --	Strip off hosts in $=R as well as possibly
###			$* $=m or the access database.
###			Check user portion for host separators.
###
###	Parameters:
###		$1 -- full recipient address
###
###	Returns:
###		parsed, non-local-relaying address
######################################################################

SParseRecipient
R$*			$: <?> $>Parse0 $>3 $1
R<?> $* < @@ $* . >	<?> $1 < @@ $2 >		strip trailing dots
R<?> $- < @@ $* >	$: <?> $(dequote $1 $) < @@ $2 >		dequote local part

# if no $=O character, no host in the user portion, we are done
R<?> $* $=O $* < @@ $* >	$: <NO> $1 $2 $3 < @@ $4>
R<?> $*			$@@ $1

ifdef(`_RELAY_ENTIRE_DOMAIN_', `dnl
# if we relay, check username portion for user%host so host can be checked also
R<NO> $* < @@ $* $=m >	$: <RELAY> $1 < @@ $2 $3 >', `dnl')
ifdef(`_RELAY_HOSTS_ONLY_',
`R<NO> $* < @@ $=R >	$: <RELAY> $1 < @@ $2 >
ifdef(`ACCESS_TABLE', `dnl
R<NO> $* < @@ $* >	$: <$(access $2 $: NO $)> $1 < @@ $2 >',`dnl')',
`R<NO> $* < @@ $* $=R >	$: <RELAY> $1 < @@ $2 $3 >
ifdef(`ACCESS_TABLE', `dnl
R<NO> $* < @@ $* >	$: $>LookUpDomain <$2> <NO> <$1 < @@ $2 >>
R<$+> <$+>		$: <$1> $2',`dnl')')
R<RELAY> $* < @@ $* >	$@@ $>ParseRecipient $1
R<$-> $*		$@@ $2

######################################################################
###  check_relay -- check hostname/address on SMTP startup
######################################################################

SLocal_check_relay
Scheck_relay
R$*			$: $1 $| $>"Local_check_relay" $1
R$* $| $* $| $#$*	$#$3
R$* $| $* $| $*		$@@ $>"Basic_check_relay" $1 $| $2

SBasic_check_relay
# check for deferred delivery mode
R$*			$: < ${deliveryMode} > $1
R< d > $*		$@@ deferred
R< $* > $*		$: $2

ifdef(`ACCESS_TABLE', `dnl
R$+ $| $+		$: $>LookUpDomain < $1 > <?> < $2 >
R<?> < $+ >		$: $>LookUpAddress < $1 > <OK> < $1 >
R<OK> < $* >		$: $1
R<RELAY> < $* >		$: $1
R<REJECT> $*		$#error $@@ 5.7.1 $: "ifdef(`confREJECT_MSG', `confREJECT_MSG', `550 Access denied')"
R<DISCARD> $*		$#discard $: discard
R<$+> $*		$#error $@@ 5.7.1 $: $1', `dnl')

ifdef(`_RBL_', `dnl
# MAPS project checks -- http://maps.vix.com/
R$*			$: $&{client_addr}
R$-.$-.$-.$-		$: $(host $4.$3.$2.$1._RBL_. $: OK $)
ROK			$@@ OK
R$+			$#error $@@ 5.7.1 $: "Mail from " $&{client_addr} " refused; see http://maps.vix.com/rbl/"',
`dnl')

######################################################################
###  check_mail -- check SMTP ``MAIL FROM:'' command argument
######################################################################

SLocal_check_mail
Scheck_mail
R$*			$: $1 $| $>"Local_check_mail" $1
R$* $| $#$*		$#$2
R$* $| $*		$@@ $>"Basic_check_mail" $1

SBasic_check_mail
# check for deferred delivery mode
R$*			$: < ${deliveryMode} > $1
R< d > $*		$@@ deferred
R< $* > $*		$: $2

R<>			$@@ <OK>
R$*			$: <?> $>Parse0 $>3 $1		make domain canonical
R<?> $* < @@ $+ . > $*	<?> $1 < @@ $2 > $3		strip trailing dots
# handle non-DNS hostnames (*.bitnet, *.decnet, *.uucp, etc)
R<?> $* < $* $=P > $*	$: <OK> $1 < @@ $2 $3 > $4
ifdef(`_ACCEPT_UNRESOLVABLE_DOMAINS_',
`R<?> $* < @@ $+ > $*	$: <OK> $1 < @@ $2 > $3		... unresolvable OK',
`R<?> $* < @@ $+ > $*	$: <? $(resolve $2 $: $2 <PERM> $) > $1 < @@ $2 > $3
R<? $* <$->> $* < @@ $+ > $*
			$: <$2> $3 < @@ $4 > $5')

ifdef(`_ACCEPT_UNQUALIFIED_SENDERS_',`dnl',`dnl
# handle case of @@localhost on address
R<$+> $* < @@localhost >	$: < ? $&{client_name} > <$1> $2 < @@localhost >
R<$+> $* < @@localhost.$m >
			$: < ? $&{client_name} > <$1> $2 < @@localhost.$m >
ifdef(`_NO_UUCP_', `dnl',
`R<$+> $* < @@localhost.UUCP >
			$: < ? $&{client_name} > <$1> $2 < @@localhost.UUCP >')
R<? $=w> <$+> $*	<?> <$2> $3
R<? $+> <$+> $*		$#error $@@ 5.5.4 $: "553 Real domain name required"
R<?> <$+> $*		$: <$1> $2')

ifdef(`ACCESS_TABLE', `dnl
# lookup localpart (user@@)
R<$+> $* < @@ $+ > $*	$: <USER $(access $2@@ $: ? $) > <$1> $2 < @@ $3 > $4
# no match, try full address (user@@domain rest)
R<USER ?> <$+> $* < @@ $* > $*
			$: <USER $(access $2@@$3$4 $: ? $) > <$1> $2 < @@ $3 > $4
# no match, try address (user@@domain)
R<USER ?> <$+> $+ < @@ $+ > $*
			$: <USER $(access $2@@$3 $: ? $) > <$1> $2 < @@ $3 > $4
# no match, try (sub)domain (domain)
R<USER ?> <$+> $* < @@ $+ > $*
			$: $>LookUpDomain <$3> <$1> <>
# check unqualified user in access database
R<?> $*			$: <USER $(access $1@@ $: ? $) > <?> $1
# retransform for further use
R<USER $+> <$+> $*	$: <$1> $3',
`dnl')

ifdef(`_ACCEPT_UNQUALIFIED_SENDERS_',`dnl',`dnl
# handle case of no @@domain on address
R<?> $*			$: < ? $&{client_name} > $1
R<?> $*			$@@ <OK>				...local unqualed ok
R<? $+> $*		$#error $@@ 5.5.4 $: "553 Domain name required"
							...remote is not')
# check results
R<?> $*			$@@ <OK>
R<OK> $*		$@@ <OK>
R<TEMP> $*		$#error $@@ 4.1.8 $: "451 Sender domain must resolve"
R<PERM> $*		$#error $@@ 5.1.8 $: "501 Sender domain must exist"
ifdef(`ACCESS_TABLE', `dnl
R<RELAY> $*		$@@ <RELAY>
R<DISCARD> $*		$#discard $: discard
R<REJECT> $*		$#error $@@ 5.7.1 $: "ifdef(`confREJECT_MSG', `confREJECT_MSG', `550 Access denied')"
R<$+> $*		$#error $@@ 5.7.1 $: $1		error from access db',
`dnl')

######################################################################
###  check_rcpt -- check SMTP ``RCPT TO:'' command argument
######################################################################

SLocal_check_rcpt
Scheck_rcpt
R$*			$: $1 $| $>"Local_check_rcpt" $1
R$* $| $#$*		$#$2
R$* $| $*		$@@ $>"Basic_check_rcpt" $1

SBasic_check_rcpt
# check for deferred delivery mode
R$*			$: < ${deliveryMode} > $1
R< d > $*		$@@ deferred
R< $* > $*		$: $2

ifdef(`_LOOSE_RELAY_CHECK_',`dnl
R$*			$: $>Parse0 $>3 $1
R$* < @@ $* . >		$1 < @@ $2 >			strip trailing dots',
`R$*			$: $>ParseRecipient $1		strip relayable hosts')

ifdef(`_BLACKLIST_RCPT_',`dnl
ifdef(`ACCESS_TABLE', `dnl
# blacklist local users or any host from receiving mail
R$*			$: <?> $1
R<?> $+ < @@ $=w >	$: <> <USER $1> <FULL $1@@$2> <HOST $2> <$1 < @@ $2 >>
R<?> $+ < @@ $* >	$: <> <FULL $1@@$2> <HOST $2> <$1 < @@ $2 >>
R<?> $+			$: <> <USER $1> <$1>
R<> <USER $+> $*	$: <$(access $1 $: $)> $2
R<> <FULL $+> $*	$: <$(access $1 $: $)> $2
R<OK> <FULL $+> $*	$: <$(access $1 $: $)> $2
R<> <HOST $+> $*	$: <$(access $1 $: $)> $2
R<OK> <HOST $+> $*	$: <$(access $1 $: $)> $2
R<> <$*>		$: $1
R<OK> <$*>		$: $1
R<RELAY> <$*>		$: $1
R<REJECT> $*		$#error $@@ 5.2.1 $: "550 Mailbox disabled for this recipient"
R<$+> $*		$#error $@@ 5.2.1 $: $1			error from access db', `dnl')', `dnl')

ifdef(`_PROMISCUOUS_RELAY_', `dnl', `dnl
# anything terminating locally is ok
ifdef(`_RELAY_ENTIRE_DOMAIN_', `dnl
R$+ < @@ $* $=m >	$@@ OK', `dnl')
R$+ < @@ $=w >		$@@ OK
ifdef(`_RELAY_HOSTS_ONLY_',
`R$+ < @@ $=R >		$@@ OK
ifdef(`ACCESS_TABLE', `dnl
R$+ < @@ $* >		$: <$(access $2 $: ? $)> <$1 < @@ $2 >>',`dnl')',
`R$+ < @@ $* $=R >	$@@ OK
ifdef(`ACCESS_TABLE', `dnl
R$+ < @@ $* >		$: $>LookUpDomain <$2> <?> <$1 < @@ $2 >>',`dnl')')
ifdef(`ACCESS_TABLE', `dnl
R<RELAY> $*		$@@ RELAY
R<$*> <$*>		$: $2',`dnl')

ifdef(`_RELAY_MX_SERVED_', `dnl
# allow relaying for hosts which we MX serve
R$+ < @@ $* >		$: < : $(mxserved $2 $) : > $1 < @@ $2 >
R< : $* <TEMP> : > $*	$#error $@@ 4.7.1 $: "450 Can not check MX records for recipient host " $1
R<$* : $=w . : $*> $*	$@@ OK
R<$*> $*			$: $2',
`dnl')

# check for local user (i.e. unqualified address)
R$*			$: <?> $1
R<?> $+ < @@ $+ >	$: <REMOTE> $1 < @@ $2 >
# local user is ok
R<?> $+			$@@ OK
R<$+> $*		$: $2

# anything originating locally is ok
R$*			$: <?> $&{client_name}
# check if bracketed IP address (forward lookup != reverse lookup)
R<?> [$+]		$: <BAD> [$1]
# pass to name server to make hostname canonical
R<?> $* $~P 		$: <?> $[ $1 $2 $]
R<$-> $*		$: $2
R$* .			$1				strip trailing dots
R$@@			$@@ OK
ifdef(`_RELAY_ENTIRE_DOMAIN_', `dnl
R$* $=m			$@@ OK', `dnl')
R$=w			$@@ OK
ifdef(`_RELAY_HOSTS_ONLY_',
`R$=R			$@@ OK
ifdef(`ACCESS_TABLE', `dnl
R$*			$: <$(access $1 $: ? $)> <$1>',`dnl')',
`R$* $=R			$@@ OK
ifdef(`ACCESS_TABLE', `dnl
R$*			$: $>LookUpDomain <$1> <?> <$1>',`dnl')')
ifdef(`ACCESS_TABLE', `dnl
R<RELAY> $*		$@@ RELAY
R<$*> <$*>		$: $2',`dnl')

# check IP address
R$*			$: $&{client_addr}
R$@@			$@@ OK			originated locally
R0			$@@ OK			originated locally
R$=R $*			$@@ OK			relayable IP address
ifdef(`ACCESS_TABLE', `dnl
R$*			$: $>LookUpAddress <$1> <?> <$1>
R<RELAY> $* 		$@@ RELAY		relayable IP address
R<$*> <$*>		$: $2', `dnl')
R$*			$: [ $1 ]		put brackets around it...
R$=w			$@@ OK			... and see if it is local

ifdef(`_RELAY_LOCAL_FROM_', `dnl
# anything with a local FROM is ok
R$*			$: $1 $| $>Parse0 $>3 $&f
R$* $| $+ < @@ $=w . >	$@@ OK			FROM local
R$* $| $*		$: $1
', `dnl')

# anything else is bogus
R$*			$#error $@@ 5.7.1 $: "550 Relaying denied"')

undivert(9)dnl
@

