head	1.16;
access;
symbols
	OPENBSD_2_6:1.14.0.4
	OPENBSD_2_6_BASE:1.14
	OPENBSD_2_5:1.14.0.2
	OPENBSD_2_5_BASE:1.14
	OPENBSD_2_4:1.13.0.2
	OPENBSD_2_4_BASE:1.13
	sendmail_8_9_1:1.1.1.2
	UCB:1.1.1
	OPENBSD_2_3:1.11.0.2
	OPENBSD_2_3_BASE:1.11
	OPENBSD_2_2:1.10.0.2
	OPENBSD_2_2_BASE:1.10
	OPENBSD_2_1:1.8.0.2
	OPENBSD_2_1_BASE:1.8
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.16
date	2000.04.18.04.57.21;	author millert;	state dead;
branches;
next	1.15;

1.15
date	99.11.24.19.27.17;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	99.01.01.20.33.49;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	98.08.14.00.55.56;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	98.07.12.19.44.47;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	97.11.09.04.05.40;	author gene;	state Exp;
branches;
next	1.10;

1.10
date	97.08.04.02.17.53;	author downsj;	state Exp;
branches;
next	1.9;

1.9
date	97.07.15.07.24.07;	author downsj;	state Exp;
branches;
next	1.8;

1.8
date	97.01.22.01.07.11;	author downsj;	state Exp;
branches;
next	1.7;

1.7
date	97.01.16.05.27.46;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	97.01.15.23.44.21;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	96.12.14.21.17.22;	author downsj;	state Exp;
branches;
next	1.4;

1.4
date	96.11.16.08.49.58;	author downsj;	state Exp;
branches;
next	1.3;

1.3
date	96.09.19.06.44.59;	author fn;	state Exp;
branches;
next	1.2;

1.2
date	96.01.29.01.44.00;	author dm;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.48.18;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.48.18;	author deraadt;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	98.07.12.17.10.16;	author millert;	state Exp;
branches;
next	;


desc
@@


1.16
log
@remove sendmail 8.9.3
@
text
@/*
 * Copyright (c) 1998 Sendmail, Inc.  All rights reserved.
 * Copyright (c) 1983, 1995-1997 Eric P. Allman.  All rights reserved.
 * Copyright (c) 1988, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * By using this file, you agree to the terms and conditions set
 * forth in the LICENSE file which can be found at the top level of
 * the sendmail distribution.
 *
 */

#ifndef lint
static char copyright[] =
"@@(#) Copyright (c) 1998 Sendmail, Inc.  All rights reserved.\n\
     Copyright (c) 1983, 1995-1997 Eric P. Allman.  All rights reserved.\n\
     Copyright (c) 1988, 1993\n\
	The Regents of the University of California.  All rights reserved.\n";
#endif /* not lint */

#ifndef lint
static char sccsid[] = "@@(#)main.c	8.322 (Berkeley) 12/18/1998";
#endif /* not lint */

#define	_DEFINE

#include "sendmail.h"
#include <arpa/inet.h>
#include <grp.h>
#if NAMED_BIND
#include <resolv.h>
#endif

/*
**  SENDMAIL -- Post mail to a set of destinations.
**
**	This is the basic mail router.  All user mail programs should
**	call this routine to actually deliver mail.  Sendmail in
**	turn calls a bunch of mail servers that do the real work of
**	delivering the mail.
**
**	Sendmail is driven by settings read in from /etc/sendmail.cf
**	(read by readcf.c).
**
**	Usage:
**		/usr/lib/sendmail [flags] addr ...
**
**		See the associated documentation for details.
**
**	Author:
**		Eric Allman, UCB/INGRES (until 10/81).
**			     Britton-Lee, Inc., purveyors of fine
**				database computers (11/81 - 10/88).
**			     International Computer Science Institute
**				(11/88 - 9/89).
**			     UCB/Mammoth Project (10/89 - 7/95).
**			     InReference, Inc. (8/95 - 1/97).
**			     Sendmail, Inc. (1/98 - present).
**		The support of the my employers is gratefully acknowledged.
**			Few of them (Britton-Lee in particular) have had
**			anything to gain from my involvement in this project.
*/


int		NextMailer;	/* "free" index into Mailer struct */
char		*FullName;	/* sender's full name */
ENVELOPE	BlankEnvelope;	/* a "blank" envelope */
ENVELOPE	MainEnvelope;	/* the envelope around the basic letter */
ADDRESS		NullAddress =	/* a null address */
		{ "", "", NULL, "" };
char		*CommandLineArgs;	/* command line args for pid file */
bool		Warn_Q_option = FALSE;	/* warn about Q option use */
char		**SaveArgv;	/* argument vector for re-execing */
int		MissingFds = 0;	/* bit map of fds missing on startup */

#ifdef NGROUPS_MAX
GIDSET_T	InitialGidSet[NGROUPS_MAX];
#endif

static void	obsolete __P((char **));
extern void	printmailer __P((MAILER *));
extern void	tTflag __P((char *));

#if DAEMON && !SMTP
ERROR %%%%   Cannot have DAEMON mode without SMTP   %%%% ERROR
#endif /* DAEMON && !SMTP */
#if SMTP && !QUEUE
ERROR %%%%   Cannot have SMTP mode without QUEUE   %%%% ERROR
#endif /* DAEMON && !SMTP */

#define MAXCONFIGLEVEL	8	/* highest config version level known */

int
main(argc, argv, envp)
	int argc;
	char **argv;
	char **envp;
{
	register char *p;
	char **av;
	extern char Version[];
	char *ep, *from;
	STAB *st;
	register int i;
	int j;
	bool queuemode = FALSE;		/* process queue requests */
	bool safecf = TRUE;
	bool warn_C_flag = FALSE;
	char warn_f_flag = '\0';
	bool run_in_foreground = FALSE;	/* -bD mode */
	static bool reenter = FALSE;
	struct passwd *pw;
	struct hostent *hp;
	char *nullserver = NULL;
	bool forged;
	char jbuf[MAXHOSTNAMELEN];	/* holds MyHostName */
	static char rnamebuf[MAXNAME];	/* holds RealUserName */
	char *emptyenviron[1];
	QUEUE_CHAR *new;
	extern int DtableSize;
	extern int optind;
	extern int opterr;
	extern char *optarg;
	extern char **environ;
	extern time_t convtime __P((char *, char));
	extern SIGFUNC_DECL intsig __P((int));
	extern struct hostent *myhostname __P((char *, int));
	extern char *getauthinfo __P((int, bool *));
	extern char *getcfname __P((void));
	extern SIGFUNC_DECL sigusr1 __P((int));
	extern SIGFUNC_DECL sighup __P((int));
	extern SIGFUNC_DECL quiesce __P((int));
	extern void initmacros __P((ENVELOPE *));
	extern void init_md __P((int, char **));
	extern int getdtsize __P((void));
	extern void tTsetup __P((u_char *, int, char *));
	extern void setdefaults __P((ENVELOPE *));
	extern void initsetproctitle __P((int, char **, char **));
	extern void init_vendor_macros __P((ENVELOPE *));
	extern void load_if_names __P((void));
	extern void vendor_pre_defaults __P((ENVELOPE *));
	extern void vendor_post_defaults __P((ENVELOPE *));
	extern void readcf __P((char *, bool, ENVELOPE *));
	extern void printqueue __P((void));
	extern void sendtoargv __P((char **, ENVELOPE *));
	extern void resetlimits __P((void));
#ifndef HASUNSETENV
	extern void unsetenv __P((char *));
#endif  

	/*
	**  Check to see if we reentered.
	**	This would normally happen if e_putheader or e_putbody
	**	were NULL when invoked.
	*/

	if (reenter)
	{
		syserr("main: reentered!");
		abort();
	}
	reenter = TRUE;

	/* avoid null pointer dereferences */
	TermEscape.te_rv_on = TermEscape.te_rv_off = "";

	/* do machine-dependent initializations */
	init_md(argc, argv);

	/* in 4.4BSD, the table can be huge; impose a reasonable limit */
	DtableSize = getdtsize();
	if (DtableSize > 256)
		DtableSize = 256;

	/*
	**  Be sure we have enough file descriptors.
	**	But also be sure that 0, 1, & 2 are open.
	*/

	fill_fd(STDIN_FILENO, NULL);
	fill_fd(STDOUT_FILENO, NULL);
	fill_fd(STDERR_FILENO, NULL);

	i = DtableSize;
	while (--i > 0)
	{
		if (i != STDIN_FILENO && i != STDOUT_FILENO && i != STDERR_FILENO)
			(void) close(i);
	}
	errno = 0;

#if LOG
# ifdef LOG_MAIL
	openlog("sendmail", LOG_PID, LOG_MAIL);
# else 
	openlog("sendmail", LOG_PID);
# endif
#endif 

	if (MissingFds != 0)
	{
		char mbuf[MAXLINE];

		mbuf[0] = '\0';
		if (bitset(1 << STDIN_FILENO, MissingFds))
			strcat(mbuf, ", stdin");
		if (bitset(1 << STDOUT_FILENO, MissingFds))
			strcat(mbuf, ", stdout");
		if (bitset(1 << STDERR_FILENO, MissingFds))
			strcat(mbuf, ", stderr");
		syserr("File descriptors missing on startup: %s", &mbuf[2]);
	}

	/* reset status from syserr() calls for missing file descriptors */
	Errors = 0;
	ExitStat = EX_OK;

#if XDEBUG
	checkfd012("after openlog");
#endif

	tTsetup(tTdvect, sizeof tTdvect, "0-99.1");

#ifdef NGROUPS_MAX
	/* save initial group set for future checks */
	i = getgroups(NGROUPS_MAX, InitialGidSet);
	if (i == 0)
		InitialGidSet[0] = (GID_T) -1;
	while (i < NGROUPS_MAX)
		InitialGidSet[i++] = InitialGidSet[0];
#endif

	/* drop group id privileges (RunAsUser not yet set) */
	(void) drop_privileges(FALSE);

#ifdef SIGUSR1
	/* arrange to dump state on user-1 signal */
	setsignal(SIGUSR1, sigusr1);
#endif

	/* initialize for setproctitle */
	initsetproctitle(argc, argv, envp);

	/* Handle any non-getoptable constructions. */
	obsolete(argv);

	/*
	**  Do a quick prescan of the argument list.
	*/

#if defined(__osf__) || defined(_AIX3)
# define OPTIONS	"B:b:C:cd:e:F:f:h:IiM:mN:nO:o:p:q:R:r:sTtUV:vX:x"
#endif
#if defined(sony_news)
# define OPTIONS	"B:b:C:cd:E:e:F:f:h:IiJ:M:mN:nO:o:p:q:R:r:sTtUV:vX:"
#endif
#ifndef OPTIONS
# define OPTIONS	"B:b:C:cd:e:F:f:h:IiM:mN:nO:o:p:q:R:r:sTtUV:vX:"
#endif
	opterr = 0;
	while ((j = getopt(argc, argv, OPTIONS)) != -1)
	{
		switch (j)
		{
		  case 'd':
			/* hack attack -- see if should use ANSI mode */
			if (strcmp(optarg, "ANSI") == 0)
			{
				TermEscape.te_rv_on = "\033[7m";
				TermEscape.te_rv_off = "\033[0m";
				break;
			}
			tTflag(optarg);
			setbuf(stdout, (char *) NULL);
			break;
		}
	}
	opterr = 1;

	/* set up the blank envelope */
	BlankEnvelope.e_puthdr = putheader;
	BlankEnvelope.e_putbody = putbody;
	BlankEnvelope.e_xfp = NULL;
	STRUCTCOPY(NullAddress, BlankEnvelope.e_from);
	CurEnv = &BlankEnvelope;
	STRUCTCOPY(NullAddress, MainEnvelope.e_from);

	/*
	**  Set default values for variables.
	**	These cannot be in initialized data space.
	*/

	setdefaults(&BlankEnvelope);

	RealUid = getuid();
	RealGid = getgid();

	pw = sm_getpwuid(RealUid);
	if (pw != NULL)
		(void) snprintf(rnamebuf, sizeof rnamebuf, "%s", pw->pw_name);
	else
		(void) snprintf(rnamebuf, sizeof rnamebuf, "Unknown UID %d", RealUid);
	RealUserName = rnamebuf;

	if (tTd(0, 101))
	{
		printf("Version %s\n", Version);
		finis(FALSE, EX_OK);
	}

	/*
	**  if running non-setuid binary as non-root, pretend
	**  we are the RunAsUid
	*/
	if (RealUid != 0 && geteuid() == RealUid)
	{
		if (tTd(47, 1))
			printf("Non-setuid binary: RunAsUid = RealUid = %d\n",
				(int)RealUid);
		RunAsUid = RealUid;
	}
	else if (geteuid() != 0)
		RunAsUid = geteuid();

	if (RealUid != 0 && getegid() == RealGid)
		RunAsGid = RealGid;

	if (tTd(47, 5))
	{
		printf("main: e/ruid = %d/%d e/rgid = %d/%d\n",
			(int)geteuid(), (int)getuid(), (int)getegid(), (int)getgid());
		printf("main: RunAsUser = %d:%d\n", (int)RunAsUid, (int)RunAsGid);
	}

	/* save command line arguments */
	i = 0;
	for (av = argv; *av != NULL; )
		i += strlen(*av++) + 1;
	SaveArgv = (char **) xalloc(sizeof (char *) * (argc + 1));
	CommandLineArgs = xalloc(i);
	p = CommandLineArgs;
	for (av = argv, i = 0; *av != NULL; )
	{
		SaveArgv[i++] = newstr(*av);
		if (av != argv)
			*p++ = ' ';
		strcpy(p, *av++);
		p += strlen(p);
	}
	SaveArgv[i] = NULL;

	if (tTd(0, 1))
	{
		int ll;
		extern char *CompileOptions[];

		printf("Version %s\n Compiled with:", Version);
		av = CompileOptions;
		ll = 7;
		while (*av != NULL)
		{
			if (ll + strlen(*av) > 63)
			{
				putchar('\n');
				ll = 0;
			}
			if (ll == 0)
			{
				putchar('\t');
				putchar('\t');
			}
			else
				putchar(' ');
			printf("%s", *av);
			ll += strlen(*av++) + 1;
		}
		putchar('\n');
	}
	if (tTd(0, 10))
	{
		int ll;
		extern char *OsCompileOptions[];

		printf("    OS Defines:");
		av = OsCompileOptions;
		ll = 7;
		while (*av != NULL)
		{
			if (ll + strlen(*av) > 63)
			{
				putchar('\n');
				ll = 0;
			}
			if (ll == 0)
			{
				putchar('\t');
				putchar('\t');
			}
			else
				putchar(' ');
			printf("%s", *av);
			ll += strlen(*av++) + 1;
		}
		putchar('\n');
#ifdef _PATH_UNIX
		printf("Kernel symbols:\t%s\n", _PATH_UNIX);
#endif
		printf(" Def Conf file:\t%s\n", getcfname());
		printf("      Pid file:\t%s\n", PidFile);
	}

	InChannel = stdin;
	OutChannel = stdout;

	/* clear sendmail's environment */
	ExternalEnviron = environ;
	emptyenviron[0] = NULL;
	environ = emptyenviron;

	/*
	**  restore any original TZ setting until TimeZoneSpec has been
	**  determined - or early log messages may get bogus time stamps
	*/
	if ((p = getextenv("TZ")) != NULL)
	{
		char *tz;
		int tzlen;

		tzlen = strlen(p) + 4;
		tz = xalloc(tzlen);
		snprintf(tz, tzlen, "TZ=%s", p);
		putenv(tz);
	}

	/* prime the child environment */
	setuserenv("AGENT", "sendmail");

	if (setsignal(SIGINT, SIG_IGN) != SIG_IGN)
		(void) setsignal(SIGINT, intsig);
	(void) setsignal(SIGTERM, intsig);
	(void) setsignal(SIGPIPE, SIG_IGN);
	OldUmask = umask(022);
	OpMode = MD_DELIVER;
	FullName = getextenv("NAME");

	/*
	**  Initialize name server if it is going to be used.
	*/

#if NAMED_BIND
	if (!bitset(RES_INIT, _res.options))
		res_init();
	if (tTd(8, 8))
		_res.options |= RES_DEBUG;
	else
		_res.options &= ~RES_DEBUG;
# ifdef RES_NOALIASES
	_res.options |= RES_NOALIASES;
# endif
#endif

	errno = 0;
	from = NULL;

	/* initialize some macros, etc. */
	initmacros(CurEnv);
	init_vendor_macros(CurEnv);

	/* version */
	define('v', Version, CurEnv);

	/* hostname */
	hp = myhostname(jbuf, sizeof jbuf);
	if (jbuf[0] != '\0')
	{
		struct	utsname	utsname;

		if (tTd(0, 4))
			printf("canonical name: %s\n", jbuf);
		define('w', newstr(jbuf), CurEnv);	/* must be new string */
		define('j', newstr(jbuf), CurEnv);
		setclass('w', jbuf);

		p = strchr(jbuf, '.');
		if (p != NULL)
		{
			if (p[1] != '\0')
			{
				define('m', newstr(&p[1]), CurEnv);
			}
			while (p != NULL && strchr(&p[1], '.') != NULL)
			{
				*p = '\0';
				if (tTd(0, 4))
					printf("\ta.k.a.: %s\n", jbuf);
				setclass('w', jbuf);
				*p++ = '.';
				p = strchr(p, '.');
			}
		}

		if (uname(&utsname) >= 0)
			p = utsname.nodename;
		else
		{
			if (tTd(0, 22))
				printf("uname failed (%s)\n", errstring(errno));
			makelower(jbuf);
			p = jbuf;
		}
		if (tTd(0, 4))
			printf(" UUCP nodename: %s\n", p);
		p = newstr(p);
		define('k', p, CurEnv);
		setclass('k', p);
		setclass('w', p);
	}
	if (hp != NULL)
	{
		for (av = hp->h_aliases; av != NULL && *av != NULL; av++)
		{
			if (tTd(0, 4))
				printf("\ta.k.a.: %s\n", *av);
			setclass('w', *av);
		}
#if NETINET
		if (hp->h_addrtype == AF_INET && hp->h_length == INADDRSZ)
		{
			for (i = 0; hp->h_addr_list[i] != NULL; i++)
			{
				char ipbuf[103];

				snprintf(ipbuf, sizeof ipbuf, "[%.100s]",
					inet_ntoa(*((struct in_addr *) hp->h_addr_list[i])));
				if (tTd(0, 4))
					printf("\ta.k.a.: %s\n", ipbuf);
				setclass('w', ipbuf);
			}
		}
#endif
	}

	/* current time */
	define('b', arpadate((char *) NULL), CurEnv);

	QueueLimitRecipient = (QUEUE_CHAR *) NULL;
	QueueLimitSender = (QUEUE_CHAR *) NULL;
	QueueLimitId = (QUEUE_CHAR *) NULL;

	/*
	**  Crack argv.
	*/

	av = argv;
	p = strrchr(*av, '/');
	if (p++ == NULL)
		p = *av;
	if (strcmp(p, "newaliases") == 0)
		OpMode = MD_INITALIAS;
	else if (strcmp(p, "mailq") == 0)
		OpMode = MD_PRINT;
	else if (strcmp(p, "smtpd") == 0)
		OpMode = MD_DAEMON;
	else if (strcmp(p, "hoststat") == 0)
		OpMode = MD_HOSTSTAT;
	else if (strcmp(p, "purgestat") == 0)
		OpMode = MD_PURGESTAT;

	optind = 1;
	while ((j = getopt(argc, argv, OPTIONS)) != -1)
	{
		switch (j)
		{
		  case 'b':	/* operations mode */
			switch (j = *optarg)
			{
			  case MD_DAEMON:
			  case MD_FGDAEMON:
# if !DAEMON
				usrerr("Daemon mode not implemented");
				ExitStat = EX_USAGE;
				break;
# endif /* DAEMON */
			  case MD_SMTP:
# if !SMTP
				usrerr("I don't speak SMTP");
				ExitStat = EX_USAGE;
				break;
# endif /* SMTP */

			  case MD_INITALIAS:
			  case MD_DELIVER:
			  case MD_VERIFY:
			  case MD_TEST:
			  case MD_PRINT:
			  case MD_HOSTSTAT:
			  case MD_PURGESTAT:
			  case MD_ARPAFTP:
				OpMode = j;
				break;

			  case MD_FREEZE:
				usrerr("Frozen configurations unsupported");
				ExitStat = EX_USAGE;
				break;

			  default:
				usrerr("Invalid operation mode %c", j);
				ExitStat = EX_USAGE;
				break;
			}
			break;

		  case 'B':	/* body type */
			CurEnv->e_bodytype = optarg;
			break;

		  case 'C':	/* select configuration file (already done) */
			if (RealUid != 0)
				warn_C_flag = TRUE;
			ConfFile = optarg;
			(void) drop_privileges(TRUE);
			safecf = FALSE;
			break;

		  case 'd':	/* debugging -- already done */
			break;

		  case 'f':	/* from address */
		  case 'r':	/* obsolete -f flag */
			if (from != NULL)
			{
				usrerr("More than one \"from\" person");
				ExitStat = EX_USAGE;
				break;
			}
			from = newstr(denlstring(optarg, TRUE, TRUE));
			if (strcmp(RealUserName, from) != 0)
				warn_f_flag = j;
			break;

		  case 'F':	/* set full name */
			FullName = newstr(optarg);
			break;

		  case 'h':	/* hop count */
			CurEnv->e_hopcount = strtol(optarg, &ep, 10);
			if (*ep)
			{
				usrerr("Bad hop count (%s)", optarg);
				ExitStat = EX_USAGE;
			}
			break;
		
		  case 'n':	/* don't alias */
			NoAlias = TRUE;
			break;

		  case 'N':	/* delivery status notifications */
			DefaultNotify |= QHASNOTIFY;
			if (strcasecmp(optarg, "never") == 0)
				break;
			for (p = optarg; p != NULL; optarg = p)
			{
				p = strchr(p, ',');
				if (p != NULL)
					*p++ = '\0';
				if (strcasecmp(optarg, "success") == 0)
					DefaultNotify |= QPINGONSUCCESS;
				else if (strcasecmp(optarg, "failure") == 0)
					DefaultNotify |= QPINGONFAILURE;
				else if (strcasecmp(optarg, "delay") == 0)
					DefaultNotify |= QPINGONDELAY;
				else
				{
					usrerr("Invalid -N argument");
					ExitStat = EX_USAGE;
				}
			}
			break;

		  case 'o':	/* set option */
			setoption(*optarg, optarg + 1, FALSE, TRUE, CurEnv);
			break;

		  case 'O':	/* set option (long form) */
			setoption(' ', optarg, FALSE, TRUE, CurEnv);
			break;

		  case 'p':	/* set protocol */
			p = strchr(optarg, ':');
			if (p != NULL)
			{
				*p++ = '\0';
				if (*p != '\0')
				{
					ep = xalloc(strlen(p) + 1);
					cleanstrcpy(ep, p, MAXNAME);
					define('s', ep, CurEnv);
				}
			}
			if (*optarg != '\0')
			{
				ep = xalloc(strlen(optarg) + 1);
				cleanstrcpy(ep, optarg, MAXNAME);
				define('r', ep, CurEnv);
			}
			break;

		  case 'q':	/* run queue files at intervals */
# if QUEUE
			FullName = NULL;
			queuemode = TRUE;
			switch (optarg[0])
			{
			  case 'I':
				if ((new = (QUEUE_CHAR *)malloc(sizeof(QUEUE_CHAR))) == NULL)
					syserr("!Out of memory!!");
				new->queue_match = newstr(&optarg[1]);
				new->queue_next = QueueLimitId;
				QueueLimitId = new;
				break;

			  case 'R':
				if ((new = (QUEUE_CHAR *)malloc(sizeof(QUEUE_CHAR))) == NULL)
					syserr("!Out of memory!!");
				new->queue_match = newstr(&optarg[1]);
				new->queue_next = QueueLimitRecipient;
				QueueLimitRecipient = new;
				break;

			  case 'S':
				if ((new = (QUEUE_CHAR *)malloc(sizeof(QUEUE_CHAR))) == NULL)
					syserr("!Out of memory!!");
				new->queue_match = newstr(&optarg[1]);
				new->queue_next = QueueLimitSender;
				QueueLimitSender = new;
				break;

			  default:
				QueueIntvl = convtime(optarg, 'm');
				break;
			}
# else /* QUEUE */
			usrerr("I don't know about queues");
			ExitStat = EX_USAGE;
# endif /* QUEUE */
			break;

		  case 'R':	/* DSN RET: what to return */
			if (bitset(EF_RET_PARAM, CurEnv->e_flags))
			{
				usrerr("Duplicate -R flag");
				ExitStat = EX_USAGE;
				break;
			}
			CurEnv->e_flags |= EF_RET_PARAM;
			if (strcasecmp(optarg, "hdrs") == 0)
				CurEnv->e_flags |= EF_NO_BODY_RETN;
			else if (strcasecmp(optarg, "full") != 0)
			{
				usrerr("Invalid -R value");
				ExitStat = EX_USAGE;
			}
			break;

		  case 't':	/* read recipients from message */
			GrabTo = TRUE;
			break;

		  case 'U':	/* initial (user) submission */
			UserSubmission = TRUE;
			break;

		  case 'V':	/* DSN ENVID: set "original" envelope id */
			if (!xtextok(optarg))
			{
				usrerr("Invalid syntax in -V flag");
				ExitStat = EX_USAGE;
			}
			else
				CurEnv->e_envid = newstr(optarg);
			break;

		  case 'X':	/* traffic log file */
			(void) drop_privileges(TRUE);
			TrafficLogFile = fopen(optarg, "a");
			if (TrafficLogFile == NULL)
			{
				syserr("cannot open %s", optarg);
				ExitStat = EX_CANTCREAT;
				break;
			}
#ifdef HASSETVBUF
			setvbuf(TrafficLogFile, NULL, _IOLBF, 0);
#else
			setlinebuf(TrafficLogFile);
#endif
			break;

			/* compatibility flags */
		  case 'c':	/* connect to non-local mailers */
		  case 'i':	/* don't let dot stop me */
		  case 'm':	/* send to me too */
		  case 'T':	/* set timeout interval */
		  case 'v':	/* give blow-by-blow description */
			setoption(j, "T", FALSE, TRUE, CurEnv);
			break;

		  case 'e':	/* error message disposition */
		  case 'M':	/* define macro */
			setoption(j, optarg, FALSE, TRUE, CurEnv);
			break;

		  case 's':	/* save From lines in headers */
			setoption('f', "T", FALSE, TRUE, CurEnv);
			break;

# ifdef DBM
		  case 'I':	/* initialize alias DBM file */
			OpMode = MD_INITALIAS;
			break;
# endif /* DBM */

# if defined(__osf__) || defined(_AIX3)
		  case 'x':	/* random flag that OSF/1 & AIX mailx passes */
			break;
# endif
# if defined(sony_news)
		  case 'E':
		  case 'J':	/* ignore flags for Japanese code conversion
				   impremented on Sony NEWS */
			break;
# endif

		  default:
			finis(TRUE, EX_USAGE);
			break;
		}
	}
	av += optind;

	/*
	**  Do basic initialization.
	**	Read system control file.
	**	Extract special fields for local use.
	*/

	/* set up ${opMode} for use in config file */
	{
		char mbuf[2];

		mbuf[0] = OpMode;
		mbuf[1] = '\0';
		define(MID_OPMODE, newstr(mbuf), CurEnv);
	}

#if XDEBUG
	checkfd012("before readcf");
#endif
	vendor_pre_defaults(CurEnv);
	readcf(getcfname(), safecf, CurEnv);
	ConfigFileRead = TRUE;
	vendor_post_defaults(CurEnv);

	/* Enforce use of local time (null string overrides this) */
	if (TimeZoneSpec == NULL)
		unsetenv("TZ");
	else if (TimeZoneSpec[0] != '\0')
		setuserenv("TZ", TimeZoneSpec);
	else
		setuserenv("TZ", NULL);
	tzset();

	/* avoid denial-of-service attacks */
	resetlimits();

	if (OpMode != MD_DAEMON && OpMode != MD_FGDAEMON)
	{
		/* drop privileges -- daemon mode done after socket/bind */
		(void) drop_privileges(FALSE);
	}

	/*
	**  Find our real host name for future logging.
	*/

	p = getauthinfo(STDIN_FILENO, &forged);
	define('_', p, CurEnv);

	/* suppress error printing if errors mailed back or whatever */
	if (CurEnv->e_errormode != EM_PRINT)
		HoldErrs = TRUE;

	/* set up the $=m class now, after .cf has a chance to redefine $m */
	expand("\201m", jbuf, sizeof jbuf, CurEnv);
	setclass('m', jbuf);

	/* probe interfaces and locate any additional names */
	if (!DontProbeInterfaces)
		load_if_names();

	if (tTd(0, 1))
	{
		printf("\n============ SYSTEM IDENTITY (after readcf) ============");
		printf("\n      (short domain name) $w = ");
		xputs(macvalue('w', CurEnv));
		printf("\n  (canonical domain name) $j = ");
		xputs(macvalue('j', CurEnv));
		printf("\n         (subdomain name) $m = ");
		xputs(macvalue('m', CurEnv));
		printf("\n              (node name) $k = ");
		xputs(macvalue('k', CurEnv));
		printf("\n========================================================\n\n");
	}

	/*
	**  Do more command line checking -- these are things that
	**  have to modify the results of reading the config file.
	*/

	/* process authorization warnings from command line */
	if (warn_C_flag)
		auth_warning(CurEnv, "Processed by %s with -C %s",
			RealUserName, ConfFile);
	if (Warn_Q_option)
		auth_warning(CurEnv, "Processed from queue %s", QueueDir);

	/* check body type for legality */
	if (CurEnv->e_bodytype == NULL)
		/* nothing */ ;
	else if (strcasecmp(CurEnv->e_bodytype, "7BIT") == 0)
		SevenBitInput = TRUE;
	else if (strcasecmp(CurEnv->e_bodytype, "8BITMIME") == 0)
		SevenBitInput = FALSE;
	else
	{
		usrerr("Illegal body type %s", CurEnv->e_bodytype);
		CurEnv->e_bodytype = NULL;
	}

	/* tweak default DSN notifications */
	if (DefaultNotify == 0)
		DefaultNotify = QPINGONFAILURE|QPINGONDELAY;

	/* be sure we don't pick up bogus HOSTALIASES environment variable */
	if (queuemode && RealUid != 0)
		(void) unsetenv("HOSTALIASES");

	/* check for sane configuration level */
	if (ConfigLevel > MAXCONFIGLEVEL)
	{
		syserr("Warning: .cf version level (%d) exceeds sendmail version %s functionality (%d)",
			ConfigLevel, Version, MAXCONFIGLEVEL);
	}

	/* need MCI cache to have persistence */
	if (HostStatDir != NULL && MaxMciCache == 0)
	{
		HostStatDir = NULL;
		printf("Warning: HostStatusDirectory disabled with ConnectionCacheSize = 0\n");
	}

	/* need HostStatusDir in order to have SingleThreadDelivery */
	if (SingleThreadDelivery && HostStatDir == NULL)
	{
		SingleThreadDelivery = FALSE;
		printf("Warning: HostStatusDirectory required for SingleThreadDelivery\n");
	}

	/* check for permissions */
	if ((OpMode == MD_DAEMON ||
	     OpMode == MD_FGDAEMON ||
	     OpMode == MD_PURGESTAT) &&
	    RealUid != 0 &&
	    RealUid != TrustedUid)
	{
		if (LogLevel > 1)
			sm_syslog(LOG_ALERT, NOQID,
				"user %d attempted to %s",
				RealUid,
				OpMode != MD_PURGESTAT ? "run daemon"
						       : "purge host status");
		usrerr("Permission denied");
		finis(FALSE, EX_USAGE);
	}
	if (OpMode == MD_INITALIAS &&
	    RealUid != 0 &&
	    RealUid != TrustedUid &&
	    !wordinclass(RealUserName, 't'))
	{
		if (LogLevel > 1)
			sm_syslog(LOG_ALERT, NOQID,
				  "user %d attempted to rebuild the alias map",
				  RealUid);
 		usrerr("Permission denied");
 		finis(FALSE, EX_USAGE);
 	}

	if (MeToo)
		BlankEnvelope.e_flags |= EF_METOO;

	switch (OpMode)
	{
	  case MD_TEST:
		/* don't have persistent host status in test mode */
		HostStatDir = NULL;
		if (Verbose == 0)
			Verbose = 2;
		CurEnv->e_errormode = EM_PRINT;
		HoldErrs = FALSE;
		break;

	  case MD_VERIFY:
		CurEnv->e_errormode = EM_PRINT;
		HoldErrs = FALSE;
		/* arrange to exit cleanly on hangup signal */
		if (setsignal(SIGHUP, SIG_IGN) == (sigfunc_t) SIG_DFL)
			setsignal(SIGHUP, intsig);
		break;

	  case MD_FGDAEMON:
		run_in_foreground = TRUE;
		OpMode = MD_DAEMON;
		/* fall through ... */

	  case MD_DAEMON:
		vendor_daemon_setup(CurEnv);

		/* remove things that don't make sense in daemon mode */
		FullName = NULL;
		GrabTo = FALSE;

		/* arrange to restart on hangup signal */
		if (SaveArgv[0] == NULL || SaveArgv[0][0] != '/')
			sm_syslog(LOG_WARNING, NOQID,
				"daemon invoked without full pathname; kill -1 won't work");
		setsignal(SIGHUP, sighup);

		/* workaround: can't seem to release the signal in the parent */
		releasesignal(SIGHUP);
		break;

	  case MD_INITALIAS:
		Verbose = 2;
		CurEnv->e_errormode = EM_PRINT;
		HoldErrs = FALSE;
		/* fall through... */

	  case MD_PRINT:
		/* to handle sendmail -bp -qSfoobar properly */
		queuemode = FALSE;
		/* fall through... */

	  default:
		/* arrange to exit cleanly on hangup signal */
		if (setsignal(SIGHUP, SIG_IGN) == (sigfunc_t) SIG_DFL)
			setsignal(SIGHUP, intsig);
		break;
	}

	/* special considerations for FullName */
	if (FullName != NULL)
	{
		char *full = NULL;
		extern bool rfc822_string __P((char *));

		/* full names can't have newlines */
		if (strchr(FullName, '\n') != NULL) 
		{
			FullName = full = newstr(denlstring(FullName, TRUE, TRUE));
		}
		/* check for characters that may have to be quoted */
		if (!rfc822_string(FullName))
		{
			extern char *addquotes __P((char *));

			/*
			**  Quote a full name with special characters
			**  as a comment so crackaddr() doesn't destroy
			**  the name portion of the address.
			*/
			FullName = addquotes(FullName);
			if (full != NULL)
				free(full);
		}
	}

	/* do heuristic mode adjustment */
	if (Verbose)
	{
		/* turn off noconnect option */
		setoption('c', "F", TRUE, FALSE, CurEnv);

		/* turn on interactive delivery */
		setoption('d', "", TRUE, FALSE, CurEnv);
	}

#ifdef VENDOR_CODE
	/* check for vendor mismatch */
	if (VendorCode != VENDOR_CODE)
	{
		extern char *getvendor __P((int));

		message("Warning: .cf file vendor code mismatch: sendmail expects vendor %s, .cf file vendor is %s",
			getvendor(VENDOR_CODE), getvendor(VendorCode));
	}
#endif
	
	/* check for out of date configuration level */
	if (ConfigLevel < MAXCONFIGLEVEL)
	{
		message("Warning: .cf file is out of date: sendmail %s supports version %d, .cf file is version %d",
			Version, MAXCONFIGLEVEL, ConfigLevel);
	}

	if (ConfigLevel < 3)
	{
		UseErrorsTo = TRUE;
	}

	/* set options that were previous macros */
	if (SmtpGreeting == NULL)
	{
		if (ConfigLevel < 7 && (p = macvalue('e', CurEnv)) != NULL)
			SmtpGreeting = newstr(p);
		else
			SmtpGreeting = "\201j Sendmail \201v ready at \201b";
	}
	if (UnixFromLine == NULL)
	{
		if (ConfigLevel < 7 && (p = macvalue('l', CurEnv)) != NULL)
			UnixFromLine = newstr(p);
		else
			UnixFromLine = "From \201g  \201d";
	}

	/* our name for SMTP codes */
	expand("\201j", jbuf, sizeof jbuf, CurEnv);
	MyHostName = jbuf;
	if (strchr(jbuf, '.') == NULL)
		message("WARNING: local host name (%s) is not qualified; fix $j in config file",
			jbuf);

	/* make certain that this name is part of the $=w class */
	setclass('w', MyHostName);

	/* the indices of built-in mailers */
	st = stab("local", ST_MAILER, ST_FIND);
	if (st != NULL)
		LocalMailer = st->s_mailer;
	else if (OpMode != MD_TEST || !warn_C_flag)
		syserr("No local mailer defined");

	st = stab("prog", ST_MAILER, ST_FIND);
	if (st == NULL)
		syserr("No prog mailer defined");
	else
	{
		ProgMailer = st->s_mailer;
		clrbitn(M_MUSER, ProgMailer->m_flags);
	}

	st = stab("*file*", ST_MAILER, ST_FIND);
	if (st == NULL)
		syserr("No *file* mailer defined");
	else
	{
		FileMailer = st->s_mailer;
		clrbitn(M_MUSER, FileMailer->m_flags);
	}

	st = stab("*include*", ST_MAILER, ST_FIND);
	if (st == NULL)
		syserr("No *include* mailer defined");
	else
		InclMailer = st->s_mailer;

	if (ConfigLevel < 6)
	{
		/* heuristic tweaking of local mailer for back compat */
		if (LocalMailer != NULL)
		{
			setbitn(M_ALIASABLE, LocalMailer->m_flags);
			setbitn(M_HASPWENT, LocalMailer->m_flags);
			setbitn(M_TRYRULESET5, LocalMailer->m_flags);
			setbitn(M_CHECKINCLUDE, LocalMailer->m_flags);
			setbitn(M_CHECKPROG, LocalMailer->m_flags);
			setbitn(M_CHECKFILE, LocalMailer->m_flags);
			setbitn(M_CHECKUDB, LocalMailer->m_flags);
		}
		if (ProgMailer != NULL)
			setbitn(M_RUNASRCPT, ProgMailer->m_flags);
		if (FileMailer != NULL)
			setbitn(M_RUNASRCPT, FileMailer->m_flags);
	}
	if (ConfigLevel < 7)
	{
		if (LocalMailer != NULL)
			setbitn(M_VRFY250, LocalMailer->m_flags);
		if (ProgMailer != NULL)
			setbitn(M_VRFY250, ProgMailer->m_flags);
		if (FileMailer != NULL)
			setbitn(M_VRFY250, FileMailer->m_flags);
	}

	/* MIME Content-Types that cannot be transfer encoded */
	setclass('n', "multipart/signed");

	/* MIME message/xxx subtypes that can be treated as messages */
	setclass('s', "rfc822");

	/* MIME Content-Transfer-Encodings that can be encoded */
	setclass('e', "7bit");
	setclass('e', "8bit");
	setclass('e', "binary");

#ifdef USE_B_CLASS
	/* MIME Content-Types that should be treated as binary */
	setclass('b', "image");
	setclass('b', "audio");
	setclass('b', "video");
	setclass('b', "application/octet-stream");
#endif

#if _FFR_MAX_MIME_HEADER_LENGTH
	/* MIME headers which have fields to check for overflow */
	setclass(macid("{checkMIMEFieldHeaders}", NULL), "content-disposition");
	setclass(macid("{checkMIMEFieldHeaders}", NULL), "content-type");

	/* MIME headers to check for length overflow */
	setclass(macid("{checkMIMETextHeaders}", NULL), "content-description");

	/* MIME headers to check for overflow and rebalance */
	setclass(macid("{checkMIMEHeaders}", NULL), "content-disposition");
	setclass(macid("{checkMIMEHeaders}", NULL), "content-id");
	setclass(macid("{checkMIMEHeaders}", NULL), "content-transfer-encoding");
	setclass(macid("{checkMIMEHeaders}", NULL), "content-type");
	setclass(macid("{checkMIMEHeaders}", NULL), "mime-version");
#endif

	/* operate in queue directory */
	if (QueueDir == NULL)
	{
		if (OpMode != MD_TEST)
		{
			syserr("QueueDirectory (Q) option must be set");
			ExitStat = EX_CONFIG;
		}
	}
	else
	{
		/* test path to get warning messages */
		(void) safedirpath(QueueDir, (uid_t) 0, (gid_t) 0, NULL, SFF_ANYFILE);
		if (OpMode != MD_TEST && chdir(QueueDir) < 0)
		{
			syserr("cannot chdir(%s)", QueueDir);
			ExitStat = EX_CONFIG;
		}
	}

	/* check host status directory for validity */
	if (HostStatDir != NULL && !path_is_dir(HostStatDir, FALSE))
	{
		/* cannot use this value */
		if (tTd(0, 2))
			printf("Cannot use HostStatusDirectory = %s: %s\n",
				HostStatDir, errstring(errno));
		HostStatDir = NULL;
	}

# if QUEUE
	if (queuemode && RealUid != 0 && bitset(PRIV_RESTRICTQRUN, PrivacyFlags))
	{
		struct stat stbuf;

		/* check to see if we own the queue directory */
		if (stat(".", &stbuf) < 0)
			syserr("main: cannot stat %s", QueueDir);
		if (stbuf.st_uid != RealUid)
		{
			/* nope, really a botch */
			usrerr("You do not have permission to process the queue");
			finis(FALSE, EX_NOPERM);
		}
	}
# endif /* QUEUE */

	/* if we've had errors so far, exit now */
	if (ExitStat != EX_OK && OpMode != MD_TEST)
		finis(FALSE, ExitStat);

#if XDEBUG
	checkfd012("before main() initmaps");
#endif

	/*
	**  Do operation-mode-dependent initialization.
	*/

	switch (OpMode)
	{
	  case MD_PRINT:
		/* print the queue */
#if QUEUE
		dropenvelope(CurEnv, TRUE);
		signal(SIGPIPE, quiesce);
		printqueue();
		finis(FALSE, EX_OK);
#else /* QUEUE */
		usrerr("No queue to print");
		finis(FALSE, ExitStat);
#endif /* QUEUE */
		break;

	  case MD_HOSTSTAT:
		signal(SIGPIPE, quiesce);
		mci_traverse_persistent(mci_print_persistent, NULL);
		finis(FALSE, EX_OK);
	    	break;

	  case MD_PURGESTAT:
		mci_traverse_persistent(mci_purge_persistent, NULL);
		finis(FALSE, EX_OK);
	    	break;

	  case MD_INITALIAS:
		/* initialize maps */
		initmaps(TRUE, CurEnv);
		finis(FALSE, ExitStat);
		break;

	  case MD_SMTP:
	  case MD_DAEMON:
		/* reset DSN parameters */
		DefaultNotify = QPINGONFAILURE|QPINGONDELAY;
		CurEnv->e_envid = NULL;
		CurEnv->e_flags &= ~(EF_RET_PARAM|EF_NO_BODY_RETN);

		/* don't open maps for daemon -- done below in child */
		break;

	  default:
		/* open the maps */
		initmaps(FALSE, CurEnv);
		break;
	}

	if (tTd(0, 15))
	{
		extern void printrules __P((void));

		/* print configuration table (or at least part of it) */
		if (tTd(0, 90))
			printrules();
		for (i = 0; i < MAXMAILERS; i++)
		{
			if (Mailer[i] != NULL)
				printmailer(Mailer[i]);
		}
	}

	/*
	**  Switch to the main envelope.
	*/

	CurEnv = newenvelope(&MainEnvelope, CurEnv);
	MainEnvelope.e_flags = BlankEnvelope.e_flags;

	/*
	**  If test mode, read addresses from stdin and process.
	*/

	if (OpMode == MD_TEST)
	{
		char buf[MAXLINE];
		SIGFUNC_DECL intindebug __P((int));

		if (isatty(fileno(stdin)))
			Verbose = 2;

		if (Verbose)
		{
			printf("ADDRESS TEST MODE (ruleset 3 NOT automatically invoked)\n");
			printf("Enter <ruleset> <address>\n");
		}
		if (setjmp(TopFrame) > 0)
			printf("\n");
		(void) setsignal(SIGINT, intindebug);
		for (;;)
		{
			extern void testmodeline __P((char *, ENVELOPE *));

			if (Verbose == 2)
				printf("> ");
			(void) fflush(stdout);
			if (fgets(buf, sizeof buf, stdin) == NULL)
				finis(TRUE, ExitStat);
			p = strchr(buf, '\n');
			if (p != NULL)
				*p = '\0';
			if (Verbose < 2)
				printf("> %s\n", buf);
			testmodeline(buf, CurEnv);
		}
	}

# if QUEUE
	/*
	**  If collecting stuff from the queue, go start doing that.
	*/

	if (queuemode && OpMode != MD_DAEMON && QueueIntvl == 0)
	{
		(void) runqueue(FALSE, Verbose);
		finis(TRUE, ExitStat);
	}
# endif /* QUEUE */

	/*
	**  If a daemon, wait for a request.
	**	getrequests will always return in a child.
	**	If we should also be processing the queue, start
	**		doing it in background.
	**	We check for any errors that might have happened
	**		during startup.
	*/

	if (OpMode == MD_DAEMON || QueueIntvl != 0)
	{
		char dtype[200];
		extern void getrequests __P((ENVELOPE *));

		if (!run_in_foreground && !tTd(99, 100))
		{
			/* put us in background */
			i = fork();
			if (i < 0)
				syserr("daemon: cannot fork");
			if (i != 0)
				finis(FALSE, EX_OK);

			/* disconnect from our controlling tty */
			disconnect(2, CurEnv);
		}

		dtype[0] = '\0';
		if (OpMode == MD_DAEMON)
			strcat(dtype, "+SMTP");
		if (QueueIntvl != 0)
		{
			strcat(dtype, "+queueing@@");
			strcat(dtype, pintvl(QueueIntvl, TRUE));
		}
		if (tTd(0, 1))
			strcat(dtype, "+debugging");

		sm_syslog(LOG_INFO, NOQID,
			"starting daemon (%s): %s", Version, dtype + 1);
#ifdef XLA
		xla_create_file();
#endif

# if QUEUE
		if (queuemode)
		{
			(void) runqueue(TRUE, FALSE);
			if (OpMode != MD_DAEMON)
			{
				for (;;)
				{
					pause();
					if (DoQueueRun)
						(void) runqueue(TRUE, FALSE);
				}
			}
		}
# endif /* QUEUE */
		dropenvelope(CurEnv, TRUE);

#if DAEMON
		getrequests(CurEnv);

		/* drop privileges */
		(void) drop_privileges(FALSE);

		/* at this point we are in a child: reset state */
		(void) newenvelope(CurEnv, CurEnv);

		/*
		**  Get authentication data
		*/

		p = getauthinfo(fileno(InChannel), &forged);
		define('_', p, &BlankEnvelope);
#endif /* DAEMON */
	}

# if SMTP
	/*
	**  If running SMTP protocol, start collecting and executing
	**  commands.  This will never return.
	*/

	if (OpMode == MD_SMTP || OpMode == MD_DAEMON)
	{
		char pbuf[20];
		extern void smtp __P((char *, ENVELOPE *));

		/*
		**  Save some macros for check_* rulesets.
		*/

		if (forged)
		{
			char ipbuf[103];

			snprintf(ipbuf, sizeof ipbuf, "[%.100s]",
				 inet_ntoa(RealHostAddr.sin.sin_addr));

			define(macid("{client_name}", NULL),
			       newstr(ipbuf), &BlankEnvelope);
		}
		else
			define(macid("{client_name}", NULL), RealHostName, &BlankEnvelope);
		define(macid("{client_addr}", NULL),
		       newstr(anynet_ntoa(&RealHostAddr)), &BlankEnvelope);
		if (RealHostAddr.sa.sa_family == AF_INET)
			snprintf(pbuf, sizeof pbuf, "%d", RealHostAddr.sin.sin_port);
		else
			snprintf(pbuf, sizeof pbuf, "0");
		define(macid("{client_port}", NULL), newstr(pbuf), &BlankEnvelope);

		/* initialize maps now for check_relay ruleset */
		initmaps(FALSE, CurEnv);

		if (OpMode == MD_DAEMON)
		{
			/* validate the connection */
			HoldErrs = TRUE;
			nullserver = validate_connection(&RealHostAddr,
							 RealHostName, CurEnv);
			HoldErrs = FALSE;
		}
		smtp(nullserver, CurEnv);
	}
# endif /* SMTP */

	clearenvelope(CurEnv, FALSE);
	if (OpMode == MD_VERIFY)
	{
		CurEnv->e_sendmode = SM_VERIFY;
		PostMasterCopy = NULL;
	}
	else
	{
		/* interactive -- all errors are global */
		CurEnv->e_flags |= EF_GLOBALERRS|EF_LOGSENDER;
	}

	/*
	**  Do basic system initialization and set the sender
	*/

	initsys(CurEnv);
	if (warn_f_flag != '\0' && !wordinclass(RealUserName, 't'))
		auth_warning(CurEnv, "%s set sender to %s using -%c",
			RealUserName, from, warn_f_flag);
	setsender(from, CurEnv, NULL, '\0', FALSE);
	if (macvalue('s', CurEnv) == NULL)
		define('s', RealHostName, CurEnv);

	if (*av == NULL && !GrabTo)
	{
		CurEnv->e_flags |= EF_GLOBALERRS;
		usrerr("Recipient names must be specified");

		/* collect body for UUCP return */
		if (OpMode != MD_VERIFY)
			collect(InChannel, FALSE, NULL, CurEnv);
		finis(TRUE, ExitStat);
	}

	/*
	**  Scan argv and deliver the message to everyone.
	*/

	sendtoargv(av, CurEnv);

	/* if we have had errors sofar, arrange a meaningful exit stat */
	if (Errors > 0 && ExitStat == EX_OK)
		ExitStat = EX_USAGE;

#if _FFR_FIX_DASHT
	/*
	**  If using -t, force not sending to argv recipients, even
	**  if they are mentioned in the headers.
	*/

	if (GrabTo)
	{
		ADDRESS *q;
		
		for (q = CurEnv->e_sendqueue; q != NULL; q = q->q_next)
			q->q_flags |= QDONTSEND;
	}
#endif

	/*
	**  Read the input mail.
	*/

	CurEnv->e_to = NULL;
	if (OpMode != MD_VERIFY || GrabTo)
	{
		long savedflags = CurEnv->e_flags & EF_FATALERRS;

		CurEnv->e_flags |= EF_GLOBALERRS;
		CurEnv->e_flags &= ~EF_FATALERRS;
		collect(InChannel, FALSE, NULL, CurEnv);

		/* bail out if message too large */
		if (bitset(EF_CLRQUEUE, CurEnv->e_flags))
		{
			finis(TRUE, ExitStat);
			/*NOTREACHED*/
			return -1;
		}
		CurEnv->e_flags |= savedflags;
	}
	errno = 0;

	if (tTd(1, 1))
		printf("From person = \"%s\"\n", CurEnv->e_from.q_paddr);

	/*
	**  Actually send everything.
	**	If verifying, just ack.
	*/

	CurEnv->e_from.q_flags |= QDONTSEND;
	if (tTd(1, 5))
	{
		printf("main: QDONTSEND ");
		printaddr(&CurEnv->e_from, FALSE);
	}
	CurEnv->e_to = NULL;
	CurrentLA = getla();
	GrabTo = FALSE;
	sendall(CurEnv, SM_DEFAULT);

	/*
	**  All done.
	**	Don't send return error message if in VERIFY mode.
	*/

	finis(TRUE, ExitStat);
	/*NOTREACHED*/
	return -1;
}

/* ARGSUSED */
SIGFUNC_DECL
quiesce(sig)
	int sig;
{
	finis(FALSE, EX_OK);
}

/* ARGSUSED */
SIGFUNC_DECL
intindebug(sig)
	int sig;
{
	longjmp(TopFrame, 1);
	return SIGFUNC_RETURN;
}


/*
**  FINIS -- Clean up and exit.
**
**	Parameters:
**		drop -- whether or not to drop CurEnv envelope
**		exitstat -- exit status to use for exit() call
**
**	Returns:
**		never
**
**	Side Effects:
**		exits sendmail
*/

void
finis(drop, exitstat)
	bool drop;
	volatile int exitstat;
{
	extern void closemaps __P((void));
#ifdef USERDB
	extern void _udbx_close __P((void));
#endif

	if (tTd(2, 1))
	{
		extern void printenvflags __P((ENVELOPE *));

		printf("\n====finis: stat %d e_id=%s e_flags=",
			exitstat,
			CurEnv->e_id == NULL ? "NOQUEUE" : CurEnv->e_id);
		printenvflags(CurEnv);
	}
	if (tTd(2, 9))
		printopenfds(FALSE);

	/* if we fail in finis(), just exit */
	if (setjmp(TopFrame) != 0)
	{
		/* failed -- just give it up */
		goto forceexit;
	}

	/* clean up temp files */
	CurEnv->e_to = NULL;
	if (drop && CurEnv->e_id != NULL)
		dropenvelope(CurEnv, TRUE);

	/* flush any cached connections */
	mci_flush(TRUE, NULL);

	/* close maps belonging to this pid */
	closemaps();

#ifdef USERDB
	/* close UserDatabase */
	_udbx_close();
#endif

# ifdef XLA
	/* clean up extended load average stuff */
	xla_all_end();
# endif

	/* and exit */
  forceexit:
	if (LogLevel > 78)
		sm_syslog(LOG_DEBUG, CurEnv->e_id,
			"finis, pid=%d",
			getpid());
	if (exitstat == EX_TEMPFAIL || CurEnv->e_errormode == EM_BERKNET)
		exitstat = EX_OK;

	/* reset uid for process accounting */
	endpwent();
	setuid(RealUid);

	exit(exitstat);
}
/*
**  INTSIG -- clean up on interrupt
**
**	This just arranges to exit.  It pessimises in that it
**	may resend a message.
**
**	Parameters:
**		none.
**
**	Returns:
**		none.
**
**	Side Effects:
**		Unlocks the current job.
*/

/* ARGSUSED */
SIGFUNC_DECL
intsig(sig)
	int sig;
{
	if (LogLevel > 79)
		sm_syslog(LOG_DEBUG, CurEnv->e_id, "interrupt");
	FileName = NULL;
	unlockqueue(CurEnv);
	closecontrolsocket(TRUE);
#ifdef XLA
	xla_all_end();
#endif
	finis(FALSE, EX_OK);
}
/*
**  INITMACROS -- initialize the macro system
**
**	This just involves defining some macros that are actually
**	used internally as metasymbols to be themselves.
**
**	Parameters:
**		none.
**
**	Returns:
**		none.
**
**	Side Effects:
**		initializes several macros to be themselves.
*/

struct metamac	MetaMacros[] =
{
	/* LHS pattern matching characters */
	{ '*', MATCHZANY },	{ '+', MATCHANY },	{ '-', MATCHONE },
	{ '=', MATCHCLASS },	{ '~', MATCHNCLASS },

	/* these are RHS metasymbols */
	{ '#', CANONNET },	{ '@@', CANONHOST },	{ ':', CANONUSER },
	{ '>', CALLSUBR },

	/* the conditional operations */
	{ '?', CONDIF },	{ '|', CONDELSE },	{ '.', CONDFI },

	/* the hostname lookup characters */
	{ '[', HOSTBEGIN },	{ ']', HOSTEND },
	{ '(', LOOKUPBEGIN },	{ ')', LOOKUPEND },

	/* miscellaneous control characters */
	{ '&', MACRODEXPAND },

	{ '\0' }
};

#define MACBINDING(name, mid) \
		stab(name, ST_MACRO, ST_ENTER)->s_macro = mid; \
		MacroName[mid] = name;

void
initmacros(e)
	register ENVELOPE *e;
{
	register struct metamac *m;
	register int c;
	char buf[5];
	extern char *MacroName[256];

	for (m = MetaMacros; m->metaname != '\0'; m++)
	{
		buf[0] = m->metaval;
		buf[1] = '\0';
		define(m->metaname, newstr(buf), e);
	}
	buf[0] = MATCHREPL;
	buf[2] = '\0';
	for (c = '0'; c <= '9'; c++)
	{
		buf[1] = c;
		define(c, newstr(buf), e);
	}

	/* set defaults for some macros sendmail will use later */
	define('n', "MAILER-DAEMON", e);

	/* set up external names for some internal macros */
	MACBINDING("opMode", MID_OPMODE);
	/*XXX should probably add equivalents for all short macros here XXX*/
}
/*
**  DISCONNECT -- remove our connection with any foreground process
**
**	Parameters:
**		droplev -- how "deeply" we should drop the line.
**			0 -- ignore signals, mail back errors, make sure
**			     output goes to stdout.
**			1 -- also, make stdout go to transcript.
**			2 -- also, disconnect from controlling terminal
**			     (only for daemon mode).
**		e -- the current envelope.
**
**	Returns:
**		none
**
**	Side Effects:
**		Trys to insure that we are immune to vagaries of
**		the controlling tty.
*/

void
disconnect(droplev, e)
	int droplev;
	register ENVELOPE *e;
{
	int fd;

	if (tTd(52, 1))
		printf("disconnect: In %d Out %d, e=%lx\n",
			fileno(InChannel), fileno(OutChannel), (u_long) e);
	if (tTd(52, 100))
	{
		printf("don't\n");
		return;
	}
	if (LogLevel > 93)
		sm_syslog(LOG_DEBUG, e->e_id,
			"disconnect level %d",
			droplev);

	/* be sure we don't get nasty signals */
	(void) setsignal(SIGINT, SIG_IGN);
	(void) setsignal(SIGQUIT, SIG_IGN);

	/* we can't communicate with our caller, so.... */
	HoldErrs = TRUE;
	CurEnv->e_errormode = EM_MAIL;
	Verbose = 0;
	DisConnected = TRUE;

	/* all input from /dev/null */
	if (InChannel != stdin)
	{
		(void) fclose(InChannel);
		InChannel = stdin;
	}
	if (freopen("/dev/null", "r", stdin) == NULL)
		sm_syslog(LOG_ERR, e->e_id,
			  "disconnect: freopen(\"/dev/null\") failed: %s",
			  errstring(errno));

	/* output to the transcript */
	if (OutChannel != stdout)
	{
		(void) fclose(OutChannel);
		OutChannel = stdout;
	}
	if (droplev > 0)
	{
		if (e->e_xfp == NULL)
		{
			fd = open("/dev/null", O_WRONLY, 0666);
			if (fd == -1)
				sm_syslog(LOG_ERR, e->e_id,
					  "disconnect: open(\"/dev/null\") failed: %s",
					  errstring(errno));
		}
		else
		{
			fd = fileno(e->e_xfp);
			if (fd == -1)
				sm_syslog(LOG_ERR, e->e_id,
					  "disconnect: fileno(e->e_xfp) failed: %s",
					  errstring(errno));
		}
		(void) fflush(stdout);
		dup2(fd, STDOUT_FILENO);
		dup2(fd, STDERR_FILENO);
		if (e->e_xfp == NULL)
			close(fd);
	}

	/* drop our controlling TTY completely if possible */
	if (droplev > 1)
	{
		(void) setsid();
		errno = 0;
	}

#if XDEBUG
	checkfd012("disconnect");
#endif

	if (LogLevel > 71)
		sm_syslog(LOG_DEBUG, e->e_id,
			"in background, pid=%d",
			getpid());

	errno = 0;
}

static void
obsolete(argv)
	char *argv[];
{
	register char *ap;
	register char *op;

	while ((ap = *++argv) != NULL)
	{
		/* Return if "--" or not an option of any form. */
		if (ap[0] != '-' || ap[1] == '-')
			return;

		/* skip over options that do have a value */
		op = strchr(OPTIONS, ap[1]);
		if (op != NULL && *++op == ':' && ap[2] == '\0' &&
		    ap[1] != 'd' &&
#if defined(sony_news)
		    ap[1] != 'E' && ap[1] != 'J' &&
#endif
		    argv[1] != NULL && argv[1][0] != '-')
		{
			argv++;
			continue;
		}

		/* If -C doesn't have an argument, use sendmail.cf. */
#define	__DEFPATH	"sendmail.cf"
		if (ap[1] == 'C' && ap[2] == '\0')
		{
			*argv = xalloc(sizeof(__DEFPATH) + 2);
			argv[0][0] = '-';
			argv[0][1] = 'C';
			(void)strcpy(&argv[0][2], __DEFPATH);
		}

		/* If -q doesn't have an argument, run it once. */
		if (ap[1] == 'q' && ap[2] == '\0')
			*argv = "-q0";

		/* if -d doesn't have an argument, use 0-99.1 */
		if (ap[1] == 'd' && ap[2] == '\0')
			*argv = "-d0-99.1";

# if defined(sony_news)
		/* if -E doesn't have an argument, use -EC */
		if (ap[1] == 'E' && ap[2] == '\0')
			*argv = "-EC";

		/* if -J doesn't have an argument, use -JJ */
		if (ap[1] == 'J' && ap[2] == '\0')
			*argv = "-JJ";
# endif
	}
}
/*
**  AUTH_WARNING -- specify authorization warning
**
**	Parameters:
**		e -- the current envelope.
**		msg -- the text of the message.
**		args -- arguments to the message.
**
**	Returns:
**		none.
*/

void
#ifdef __STDC__
auth_warning(register ENVELOPE *e, const char *msg, ...)
#else
auth_warning(e, msg, va_alist)
	register ENVELOPE *e;
	const char *msg;
	va_dcl
#endif
{
	char buf[MAXLINE];
	VA_LOCAL_DECL

	if (bitset(PRIV_AUTHWARNINGS, PrivacyFlags))
	{
		register char *p;
		static char hostbuf[48];
		extern struct hostent *myhostname __P((char *, int));

		if (hostbuf[0] == '\0')
			(void) myhostname(hostbuf, sizeof hostbuf);

		(void) snprintf(buf, sizeof buf, "%s: ", hostbuf);
		p = &buf[strlen(buf)];
		VA_START(msg);
		vsnprintf(p, SPACELEFT(buf, p), msg, ap);
		VA_END;
		addheader("X-Authentication-Warning", buf, &e->e_header);
		if (LogLevel > 3)
			sm_syslog(LOG_INFO, e->e_id,
				"Authentication-Warning: %.400s",
				buf);
	}
}
/*
**  GETEXTENV -- get from external environment
**
**	Parameters:
**		envar -- the name of the variable to retrieve
**
**	Returns:
**		The value, if any.
*/

char *
getextenv(envar)
	const char *envar;
{
	char **envp;
	int l;

	l = strlen(envar);
	for (envp = ExternalEnviron; *envp != NULL; envp++)
	{
		if (strncmp(*envp, envar, l) == 0 && (*envp)[l] == '=')
			return &(*envp)[l + 1];
	}
	return NULL;
}
/*
**  SETUSERENV -- set an environment in the propogated environment
**
**	Parameters:
**		envar -- the name of the environment variable.
**		value -- the value to which it should be set.  If
**			null, this is extracted from the incoming
**			environment.  If that is not set, the call
**			to setuserenv is ignored.
**
**	Returns:
**		none.
*/

void
setuserenv(envar, value)
	const char *envar;
	const char *value;
{
	int i;
	char **evp = UserEnviron;
	char *p;

	if (value == NULL)
	{
		value = getextenv(envar);
		if (value == NULL)
			return;
	}

	i = strlen(envar);
	p = (char *) xalloc(strlen(value) + i + 2);
	strcpy(p, envar);
	p[i++] = '=';
	strcpy(&p[i], value);

	while (*evp != NULL && strncmp(*evp, p, i) != 0)
		evp++;
	if (*evp != NULL)
	{
		*evp++ = p;
	}
	else if (evp < &UserEnviron[MAXUSERENVIRON])
	{
		*evp++ = p;
		*evp = NULL;
	}

	/* make sure it is in our environment as well */
	if (putenv(p) < 0)
		syserr("setuserenv: putenv(%s) failed", p);
}
/*
**  DUMPSTATE -- dump state
**
**	For debugging.
*/

void
dumpstate(when)
	char *when;
{
	register char *j = macvalue('j', CurEnv);
	int rs;

	sm_syslog(LOG_DEBUG, CurEnv->e_id,
		"--- dumping state on %s: $j = %s ---",
		when,
		j == NULL ? "<NULL>" : j);
	if (j != NULL)
	{
		if (!wordinclass(j, 'w'))
			sm_syslog(LOG_DEBUG, CurEnv->e_id,
				"*** $j not in $=w ***");
	}
	sm_syslog(LOG_DEBUG, CurEnv->e_id, "CurChildren = %d", CurChildren);
	sm_syslog(LOG_DEBUG, CurEnv->e_id, "--- open file descriptors: ---");
	printopenfds(TRUE);
	sm_syslog(LOG_DEBUG, CurEnv->e_id, "--- connection cache: ---");
	mci_dump_all(TRUE);
	rs = strtorwset("debug_dumpstate", NULL, ST_FIND);
	if (rs > 0)
	{
		int stat;
		register char **pvp;
		char *pv[MAXATOM + 1];

		pv[0] = NULL;
		stat = rewrite(pv, rs, 0, CurEnv);
		sm_syslog(LOG_DEBUG, CurEnv->e_id,
		       "--- ruleset debug_dumpstate returns stat %d, pv: ---",
		       stat);
		for (pvp = pv; *pvp != NULL; pvp++)
			sm_syslog(LOG_DEBUG, CurEnv->e_id, "%s", *pvp);
	}
	sm_syslog(LOG_DEBUG, CurEnv->e_id, "--- end of state dump ---");
}


/* ARGSUSED */
SIGFUNC_DECL
sigusr1(sig)
	int sig;
{
	dumpstate("user signal");
	return SIGFUNC_RETURN;
}


/* ARGSUSED */
SIGFUNC_DECL
sighup(sig)
	int sig;
{
	if (SaveArgv[0][0] != '/')
	{
		if (LogLevel > 3)
			sm_syslog(LOG_INFO, NOQID, "could not restart: need full path");
		finis(FALSE, EX_OSFILE);
	}
	if (LogLevel > 3)
		sm_syslog(LOG_INFO, NOQID, "restarting %s on signal", SaveArgv[0]);
	alarm(0);
	releasesignal(SIGHUP);
	closecontrolsocket(TRUE);
	if (drop_privileges(TRUE) != EX_OK)
	{
		if (LogLevel > 0)
			sm_syslog(LOG_ALERT, NOQID, "could not set[ug]id(%d, %d): %m",
				RunAsUid, RunAsGid);
		finis(FALSE, EX_OSERR);
	}
	execve(SaveArgv[0], (ARGV_T) SaveArgv, (ARGV_T) ExternalEnviron);
	if (LogLevel > 0)
		sm_syslog(LOG_ALERT, NOQID, "could not exec %s: %m", SaveArgv[0]);
	finis(FALSE, EX_OSFILE);
}
/*
**  DROP_PRIVILEGES -- reduce privileges to those of the RunAsUser option
**
**	Parameters:
**		to_real_uid -- if set, drop to the real uid instead
**			of the RunAsUser.
**
**	Returns:
**		EX_OSERR if the setuid failed.
**		EX_OK otherwise.
*/

int
drop_privileges(to_real_uid)
	bool to_real_uid;
{
	int rval = EX_OK;
	GIDSET_T emptygidset[1];

	if (tTd(47, 1))
		printf("drop_privileges(%d): Real[UG]id=%d:%d, RunAs[UG]id=%d:%d\n",
			(int)to_real_uid, (int)RealUid, (int)RealGid, (int)RunAsUid, (int)RunAsGid);

	if (to_real_uid)
	{
		RunAsUserName = RealUserName;
		RunAsUid = RealUid;
		RunAsGid = RealGid;
	}

	/* make sure no one can grab open descriptors for secret files */
	endpwent();

	/* reset group permissions; these can be set later */
	emptygidset[0] = (to_real_uid || RunAsGid != 0) ? RunAsGid : getegid();
	if (setgroups(1, emptygidset) == -1 && geteuid() == 0)
		rval = EX_OSERR;

	/* reset primary group and user id */
	if ((to_real_uid || RunAsGid != 0) && setgid(RunAsGid) < 0)
		rval = EX_OSERR;
	if ((to_real_uid || RunAsUid != 0) && setuid(RunAsUid) < 0)
		rval = EX_OSERR;
	if (tTd(47, 5))
	{
		printf("drop_privileges: e/ruid = %d/%d e/rgid = %d/%d\n",
			(int)geteuid(), (int)getuid(), (int)getegid(), (int)getgid());
		printf("drop_privileges: RunAsUser = %d:%d\n", (int)RunAsUid, (int)RunAsGid);
	}
	return rval;
}
/*
**  FILL_FD -- make sure a file descriptor has been properly allocated
**
**	Used to make sure that stdin/out/err are allocated on startup
**
**	Parameters:
**		fd -- the file descriptor to be filled.
**		where -- a string used for logging.  If NULL, this is
**			being called on startup, and logging should
**			not be done.
**
**	Returns:
**		none
*/

void
fill_fd(fd, where)
	int fd;
	char *where;
{
	int i;
	struct stat stbuf;

	if (fstat(fd, &stbuf) >= 0 || errno != EBADF)
		return;

	if (where != NULL)
		syserr("fill_fd: %s: fd %d not open", where, fd);
	else
		MissingFds |= 1 << fd;
	i = open("/dev/null", fd == 0 ? O_RDONLY : O_WRONLY, 0666);
	if (i < 0)
	{
		syserr("!fill_fd: %s: cannot open /dev/null",
			where == NULL ? "startup" : where);
	}
	if (fd != i)
	{
		(void) dup2(i, fd);
		(void) close(i);
	}
}
/*
**  TESTMODELINE -- process a test mode input line
**
**	Parameters:
**		line -- the input line.
**		e -- the current environment.
**	Syntax:
**		#  a comment
**		.X process X as a configuration line
**		=X dump a configuration item (such as mailers)
**		$X dump a macro or class
**		/X try an activity
**		X  normal process through rule set X
*/

void
testmodeline(line, e)
	char *line;
	ENVELOPE *e;
{
	register char *p;
	char *q;
	auto char *delimptr;
	int mid;
	int i, rs;
	STAB *map;
	char **s;
	struct rewrite *rw;
	ADDRESS a;
	static int tryflags = RF_COPYNONE;
	char exbuf[MAXLINE];
	extern bool invalidaddr __P((char *, char *));
	extern char *crackaddr __P((char *));
	extern void dump_class __P((STAB *, int));
	extern void translate_dollars __P((char *));
	extern void help __P((char *));

	switch (line[0])
	{
	  case '#':
	  case 0:
		return;

	  case '?':
		help("-bt");
		return;

	  case '.':		/* config-style settings */
		switch (line[1])
		{
		  case 'D':
			mid = macid(&line[2], &delimptr);
			if (mid == '\0')
				return;
			translate_dollars(delimptr);
			define(mid, newstr(delimptr), e);
			break;

		  case 'C':
			if (line[2] == '\0')	/* not to call syserr() */
				return;

			mid = macid(&line[2], &delimptr);
			if (mid == '\0')
				return;
			translate_dollars(delimptr);
			expand(delimptr, exbuf, sizeof exbuf, e);
			p = exbuf;
			while (*p != '\0')
			{
				register char *wd;
				char delim;

				while (*p != '\0' && isascii(*p) && isspace(*p))
					p++;
				wd = p;
				while (*p != '\0' && !(isascii(*p) && isspace(*p)))
					p++;
				delim = *p;
				*p = '\0';
				if (wd[0] != '\0')
					setclass(mid, wd);
				*p = delim;
			}
			break;

		  case '\0':
			printf("Usage: .[DC]macro value(s)\n");
			break;

		  default:
			printf("Unknown \".\" command %s\n", line);
			break;
		}
		return;

	  case '=':		/* config-style settings */
		switch (line[1])
		{
		  case 'S':		/* dump rule set */
			rs = strtorwset(&line[2], NULL, ST_FIND);
			if (rs < 0)
			{
				printf("Undefined ruleset %s\n", &line[2]);
				return;
			}
			rw = RewriteRules[rs];
			if (rw == NULL)
				return;
			do
			{
				putchar('R');
				s = rw->r_lhs;
				while (*s != NULL)
				{
					xputs(*s++);
					putchar(' ');
				}
				putchar('\t');
				putchar('\t');
				s = rw->r_rhs;
				while (*s != NULL)
				{
					xputs(*s++);
					putchar(' ');
				}
				putchar('\n');
			} while ((rw = rw->r_next) != NULL);
			break;

		  case 'M':
			for (i = 0; i < MAXMAILERS; i++)
			{
				if (Mailer[i] != NULL)
					printmailer(Mailer[i]);
			}
			break;

		  case '\0':
			printf("Usage: =Sruleset or =M\n");
			break;

		  default:
			printf("Unknown \"=\" command %s\n", line);
			break;
		}
		return;

	  case '-':		/* set command-line-like opts */
		switch (line[1])
		{
		  case 'd':
			tTflag(&line[2]);
			break;

		  case '\0':
			printf("Usage: -d{debug arguments}\n");
			break;

		  default:
			printf("Unknown \"-\" command %s\n", line);
			break;
		}
		return;

	  case '$':
		if (line[1] == '=')
		{
			mid = macid(&line[2], NULL);
			if (mid != '\0')
				stabapply(dump_class, mid);
			return;
		}
		mid = macid(&line[1], NULL);
		if (mid == '\0')
			return;
		p = macvalue(mid, e);
		if (p == NULL)
			printf("Undefined\n");
		else
		{
			xputs(p);
			printf("\n");
		}
		return;

	  case '/':		/* miscellaneous commands */
		p = &line[strlen(line)];
		while (--p >= line && isascii(*p) && isspace(*p))
			*p = '\0';
		p = strpbrk(line, " \t");
		if (p != NULL)
		{
			while (isascii(*p) && isspace(*p))
				*p++ = '\0';
		}
		else
			p = "";
		if (line[1] == '\0')
		{
			printf("Usage: /[canon|map|mx|parse|try|tryflags]\n");
			return;
		}
		if (strcasecmp(&line[1], "mx") == 0)
		{
#if NAMED_BIND
			/* look up MX records */
			int nmx;
			auto int rcode;
			char *mxhosts[MAXMXHOSTS + 1];

			if (*p == '\0')
			{
				printf("Usage: /mx address\n");
				return;
			}
			nmx = getmxrr(p, mxhosts, FALSE, &rcode);
			printf("getmxrr(%s) returns %d value(s):\n", p, nmx);
			for (i = 0; i < nmx; i++)
				printf("\t%s\n", mxhosts[i]);
#else
			printf("No MX code compiled in\n");
#endif
		}
		else if (strcasecmp(&line[1], "canon") == 0)
		{
			char host[MAXHOSTNAMELEN];

			if (*p == '\0')
			{
				printf("Usage: /canon address\n");
				return;
			}
			else if (strlen(p) >= sizeof host)
			{
				printf("Name too long\n");
				return;
			}
			strcpy(host, p);
			(void) getcanonname(host, sizeof(host), HasWildcardMX);
			printf("getcanonname(%s) returns %s\n", p, host);
		}
		else if (strcasecmp(&line[1], "map") == 0)
		{
			auto int rcode = EX_OK;
			char *av[2];

			if (*p == '\0')
			{
				printf("Usage: /map mapname key\n");
				return;
			}
			for (q = p; *q != '\0' && !(isascii(*q) && isspace(*q)); q++)
				continue;
			if (*q == '\0')
			{
				printf("No key specified\n");
				return;
			}
			*q++ = '\0';
			map = stab(p, ST_MAP, ST_FIND);
			if (map == NULL)
			{
				printf("Map named \"%s\" not found\n", p);
				return;
			}
			if (!bitset(MF_OPEN, map->s_map.map_mflags))
			{
				printf("Map named \"%s\" not open\n", p);
				return;
			}
			printf("map_lookup: %s (%s) ", p, q);
			av[0] = q;
			av[1] = NULL;
			p = (*map->s_map.map_class->map_lookup)
					(&map->s_map, q, av, &rcode);
			if (p == NULL)
				printf("no match (%d)\n", rcode);
			else
				printf("returns %s (%d)\n", p, rcode);
		}
		else if (strcasecmp(&line[1], "try") == 0)
		{
			MAILER *m;
			STAB *s;
			auto int rcode = EX_OK;

			q = strpbrk(p, " \t");
			if (q != NULL)
			{
				while (isascii(*q) && isspace(*q))
					*q++ = '\0';
			}
			if (q == NULL || *q == '\0')
			{
				printf("Usage: /try mailer address\n");
				return;
			}
			s = stab(p, ST_MAILER, ST_FIND);
			if (s == NULL)
			{
				printf("Unknown mailer %s\n", p);
				return;
			}
			m = s->s_mailer;
			printf("Trying %s %s address %s for mailer %s\n",
				bitset(RF_HEADERADDR, tryflags) ? "header" : "envelope",
				bitset(RF_SENDERADDR, tryflags) ? "sender" : "recipient",
				q, p);
			p = remotename(q, m, tryflags, &rcode, CurEnv);
			printf("Rcode = %d, addr = %s\n",
				rcode, p == NULL ? "<NULL>" : p);
			e->e_to = NULL;
		}
		else if (strcasecmp(&line[1], "tryflags") == 0)
		{
			if (*p == '\0')
			{
				printf("Usage: /tryflags [Hh|Ee][Ss|Rr]\n");
				return;
			}
			for (; *p != '\0'; p++)
			{
				switch (*p)
				{
				  case 'H':
				  case 'h':
					tryflags |= RF_HEADERADDR;
					break;

				  case 'E':
				  case 'e':
					tryflags &= ~RF_HEADERADDR;
					break;

				  case 'S':
				  case 's':
					tryflags |= RF_SENDERADDR;
					break;

				  case 'R':
				  case 'r':
					tryflags &= ~RF_SENDERADDR;
					break;
				}
			}
		}
		else if (strcasecmp(&line[1], "parse") == 0)
		{
			if (*p == '\0')
			{
				printf("Usage: /parse address\n");
				return;
			}
			q = crackaddr(p);
			printf("Cracked address = ");
			xputs(q);
			printf("\nParsing %s %s address\n",
				bitset(RF_HEADERADDR, tryflags) ? "header" : "envelope",
				bitset(RF_SENDERADDR, tryflags) ? "sender" : "recipient");
			if (parseaddr(p, &a, tryflags, '\0', NULL, e) == NULL)
				printf("Cannot parse\n");
			else if (a.q_host != NULL && a.q_host[0] != '\0')
				printf("mailer %s, host %s, user %s\n",
					a.q_mailer->m_name, a.q_host, a.q_user);
			else
				printf("mailer %s, user %s\n",
					a.q_mailer->m_name, a.q_user);
			e->e_to = NULL;
		}
		else
		{
			printf("Unknown \"/\" command %s\n", line);
		}
		return;
	}

	for (p = line; isascii(*p) && isspace(*p); p++)
		continue;
	q = p;
	while (*p != '\0' && !(isascii(*p) && isspace(*p)))
		p++;
	if (*p == '\0')
	{
		printf("No address!\n");
		return;
	}
	*p = '\0';
	if (invalidaddr(p + 1, NULL))
		return;
	do
	{
		register char **pvp;
		char pvpbuf[PSBUFSIZE];

		pvp = prescan(++p, ',', pvpbuf, sizeof pvpbuf,
			      &delimptr, NULL);
		if (pvp == NULL)
			continue;
		p = q;
		while (*p != '\0')
		{
			int stat;

			rs = strtorwset(p, NULL, ST_FIND);
			if (rs < 0)
			{
				printf("Undefined ruleset %s\n", p);
				break;
			}
			stat = rewrite(pvp, rs, 0, e);
			if (stat != EX_OK)
				printf("== Ruleset %s (%d) status %d\n",
					p, rs, stat);
			while (*p != '\0' && *p++ != ',')
				continue;
		}
	} while (*(p = delimptr) != '\0');
}


void
dump_class(s, id)
	register STAB *s;
	int id;
{
	if (s->s_type != ST_CLASS)
		return;
	if (bitnset(id & 0xff, s->s_class))
		printf("%s\n", s->s_name);
}
@


1.15
log
@Limit newaliases to root and trusted users; sendmail+gshapiro@@sendmail.orG
@
text
@@


1.14
log
@sendmail 8.9.2
@
text
@d987 12
@


1.13
log
@Update to sendmail.8.9.1a which adds support for MaxMimeHeaderLength option, to help avoid buffer oflows in stupid clients (only if enabled in .cf file)
@
text
@d22 1
a22 1
static char sccsid[] = "@@(#)main.c	8.302 (Berkeley) 6/4/98";
d132 1
d308 1
a308 3
		endpwent();
		setuid(RealUid);
		exit(EX_OK);
d421 2
a422 2
	** restore any original TZ setting until TimeZoneSpec has been
	** determined - or early log messages may get bogus time stamps
d551 1
a551 1
	** Crack argv.
d837 1
a837 2
			ExitStat = EX_USAGE;
			finis();
d972 5
a976 2
	if ((OpMode == MD_DAEMON || OpMode == MD_FGDAEMON ||
	     OpMode == MD_PURGESTAT) && RealUid != 0)
d985 1
a985 1
		exit(EX_USAGE);
d1087 11
d1214 1
a1214 1

d1219 4
a1222 2
	/* MIME headers to check for overflow */
	setclass(macid("{checkMIMEHeaders}", NULL), "content-description");
d1228 1
d1272 1
a1272 1
			exit (EX_NOPERM);
d1279 1
a1279 5
	{
		endpwent();
		setuid(RealUid);
		exit(ExitStat);
	}
d1295 1
d1297 1
a1297 3
		endpwent();
		setuid(RealUid);
		exit(EX_OK);
d1300 1
a1300 1
		finis();
d1302 1
d1305 1
d1307 1
a1307 1
		exit(EX_OK);
d1312 1
a1312 1
		exit(EX_OK);
d1316 1
a1316 1
		/* initialize alias database */
d1318 2
a1319 3
		endpwent();
		setuid(RealUid);
		exit(ExitStat);
d1328 1
a1328 1
		/* don't open alias database -- done in srvrsmtp */
d1332 1
a1332 1
		/* open the alias database */
d1386 1
a1386 1
				finis();
d1404 1
a1404 1
		finis();
d1429 1
a1429 1
				exit(EX_OK);
d1522 3
d1569 1
a1569 1
		finis();
d1613 1
a1613 1
			finis();
d1645 1
a1645 1
	finis();
d1650 7
d1672 2
a1673 1
**		none
d1683 3
a1685 1
finis()
d1687 5
d1697 1
a1697 1
			ExitStat,
d1713 1
a1713 1
	if (CurEnv->e_id != NULL)
d1719 8
d1738 2
a1739 2
	if (ExitStat == EX_TEMPFAIL || CurEnv->e_errormode == EM_BERKNET)
		ExitStat = EX_OK;
d1745 1
a1745 1
	exit(ExitStat);
d1772 1
d1776 1
a1776 6

	/* reset uid for process accounting */
	endpwent();
	setuid(RealUid);

	exit(EX_OK);
d2206 1
a2206 1
		exit(EX_OSFILE);
d2212 1
d2218 1
a2218 1
		exit(EX_OSERR);
d2223 1
a2223 1
	exit(EX_OSFILE);
@


1.12
log
@something hosed the sendmail import; fix up by hand
@
text
@d1202 13
@


1.11
log
@Upgrade to sendmail 8.8.8
@
text
@d2 2
a3 1
 * Copyright (c) 1983, 1995-1997 Eric P. Allman
d7 3
a9 15
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
a10 11
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
d15 3
a17 1
"@@(#) Copyright (c) 1988, 1993\n\
d22 1
a22 1
static char sccsid[] = "@@(#)main.c	8.258 (Berkeley) 10/20/97";
d29 1
d58 1
d80 1
a80 1
static void	obsolete();
d91 1
a91 1
#define MAXCONFIGLEVEL	7	/* highest config version level known */
d114 2
a115 1
	bool nullserver = FALSE;
d119 1
d125 1
a125 1
	extern time_t convtime();
d127 3
a129 3
	extern struct hostent *myhostname();
	extern char *getauthinfo();
	extern char *getcfname();
d146 3
d240 3
d304 13
a316 2
	/* if running non-setuid binary, pretend we are the RunAsUid */
	if (geteuid() == RealUid)
d320 1
a320 1
				RealUid);
d323 4
a326 1
	if (getegid() == RealGid)
d329 7
a415 3
	/* initialize for setproctitle */
	initsetproctitle(argc, argv, envp);

d421 15
a529 2
			register int i;

d547 4
d718 5
a722 1
				QueueLimitId = newstr(&optarg[1]);
d726 5
a730 1
				QueueLimitRecipient = newstr(&optarg[1]);
d734 5
a738 1
				QueueLimitSender = newstr(&optarg[1]);
d890 1
a890 1
	p = getauthinfo(STDIN_FILENO);
d974 2
a975 1
	if ((OpMode == MD_DAEMON || OpMode == MD_PURGESTAT) && RealUid != 0)
d981 2
a982 2
				OpMode == MD_DAEMON ? "run daemon"
						    : "purge host status");
d995 7
a1001 1
		Verbose = 2;
d1003 4
d1034 1
d1049 26
a1074 3
	/* full names can't have newlines */
	if (FullName != NULL && strchr(FullName, '\n') != NULL)
		FullName = newstr(denlstring(FullName, TRUE, TRUE));
d1086 7
a1297 3
		nullserver = FALSE;
		/* fall through... */

d1358 1
a1358 1
			if (Verbose)
d1366 1
a1366 1
			if (!Verbose)
d1405 1
a1405 1
				exit(0);
d1458 1
a1458 1
		p = getauthinfo(fileno(InChannel));
a1459 5

		/* validate the connection */
		HoldErrs = TRUE;
		nullserver = !validate_connection(&RealHostAddr, RealHostName, CurEnv);
		HoldErrs = FALSE;
d1472 1
a1472 1
		extern void smtp __P((bool, ENVELOPE *));
d1478 12
a1489 1
		define(macid("{client_name}", NULL), RealHostName, &BlankEnvelope);
d1498 8
a1513 1
		CurEnv->e_errormode = EM_PRINT;
a1514 1
		HoldErrs = FALSE;
d1555 15
d1610 1
d1624 1
d1652 1
a1652 1
		extern void printenvflags();
d1713 1
d1861 4
a1864 1
	(void) freopen("/dev/null", "r", stdin);
d1875 1
d1877 5
d1883 1
d1885 5
d2000 1
a2000 1
		extern struct hostent *myhostname();
d2141 1
d2151 1
d2195 1
a2195 3
#ifdef NGROUPS_MAX
	GIDSET_T emptygidset[NGROUPS_MAX];
#endif
d2199 1
a2199 1
			to_real_uid, RealUid, RealGid, RunAsUid, RunAsGid);
a2210 1
#ifdef NGROUPS_MAX
d2213 2
a2214 2
	(void) setgroups(1, emptygidset);
#endif
d2221 6
d2516 1
d2523 1
a2523 1
			for (q = p; *q != '\0' && !isspace(*q); q++)
d2543 2
d2546 1
a2546 1
					(&map->s_map, q, NULL, &rcode);
a2673 1
			int rs = strtorwset(p, NULL, ST_FIND);
d2675 1
@


1.10
log
@sendmail 8.8.7.
@
text
@d42 1
a42 1
static char sccsid[] = "@@(#)main.c	8.249 (Berkeley) 7/25/97";
a52 4
# ifdef lint
char	edata, end;
# endif /* lint */

a120 1
	typedef int (*fnptr)();
a130 1
	struct stat stb;
d433 2
d831 9
a910 9
	/* Enforce use of local time (null string overrides this) */
	if (TimeZoneSpec == NULL)
		unsetenv("TZ");
	else if (TimeZoneSpec[0] != '\0')
		setuserenv("TZ", TimeZoneSpec);
	else
		setuserenv("TZ", NULL);
	tzset();

d1320 1
a1320 1
		extern bool getrequests __P((ENVELOPE *));
d1370 1
a1370 1
		nullserver = getrequests(CurEnv);
d1384 5
d1480 2
a1481 2
		/* bail out if there were fatal errors in collect */
		if (OpMode != MD_VERIFY && bitset(EF_FATALERRS, CurEnv->e_flags))
a1482 1
			CurEnv->e_flags |= EF_CLRQUEUE;
d2050 1
a2050 1
	execv(SaveArgv[0], (ARGV_T) SaveArgv);
d2092 1
a2092 1
	emptygidset[0] = RunAsGid == 0 ? getegid() : RunAsGid;
d2097 1
a2097 1
	if (RunAsGid != 0 && setgid(RunAsGid) < 0)
d2099 1
a2099 1
	if (RunAsUid != 0 && setuid(RunAsUid) < 0)
@


1.9
log
@Sendmail 8.8.6.
@
text
@d42 1
a42 1
static char sccsid[] = "@@(#)main.c	8.246 (Berkeley) 6/11/97";
d96 1
a167 1
	extern void drop_privileges __P((void));
a187 5
#ifdef SIGUSR1
	/* arrange to dump state on user-1 signal */
	setsignal(SIGUSR1, sigusr1);
#endif

d198 3
a200 9
	i = open("/dev/null", O_RDWR, 0);
	if (fstat(STDIN_FILENO, &stb) < 0 && errno != EOPNOTSUPP)
		(void) dup2(i, STDIN_FILENO);
	if (fstat(STDOUT_FILENO, &stb) < 0 && errno != EOPNOTSUPP)
		(void) dup2(i, STDOUT_FILENO);
	if (fstat(STDERR_FILENO, &stb) < 0 && errno != EOPNOTSUPP)
		(void) dup2(i, STDERR_FILENO);
	if (i != STDIN_FILENO && i != STDOUT_FILENO && i != STDERR_FILENO)
		(void) close(i);
d218 22
d252 1
a252 1
	drop_privileges();
d254 4
a257 2
	/* drop group id privileges (RunAsUser not yet set) */
	drop_privileges();
d320 11
d602 1
a602 3
			endpwent();
			(void) setgid(RealGid);
			(void) setuid(RealUid);
d754 1
a754 3
			endpwent();
			setgid(RealGid);
			setuid(RealUid);
d841 1
a841 1
		drop_privileges();
d1377 1
a1377 1
		drop_privileges();
d2043 1
a2043 1
	if (setgid(RealGid) < 0 || setuid(RealUid) < 0)
d2047 1
a2047 1
				RealUid, RealGid);
d2059 2
a2060 1
**		none.
d2063 2
a2064 1
**		none.
d2067 3
a2069 2
void
drop_privileges()
d2071 1
a2072 1
	/* reset group permissions; these can be set later */
d2074 15
d2090 2
d2095 49
a2143 4
	if (RunAsGid != 0)
		(void) setgid(RunAsGid);
	if (RunAsUid != 0)
		(void) setuid(RunAsUid);
@


1.8
log
@Sendmail 8.8.5.
@
text
@d2 1
a2 1
 * Copyright (c) 1983, 1995, 1996 Eric P. Allman
d42 1
a42 1
static char sccsid[] = "@@(#)main.c	8.230 (Berkeley) 1/17/97";
d65 2
a66 7
**	Sendmail is driven by tables read in from /usr/lib/sendmail.cf
**	(read by readcf.c).  Some more static configuration info,
**	including some code that you may want to tailor for your
**	installation, is in conf.c.  You may also want to touch
**	daemon.c (if you have some other IPC mechanism), acct.c
**	(to change your accounting), names.c (to adjust the name
**	server mechanism).
d80 1
a80 1
**			     InReference, Inc. (8/95 - present).
d97 4
d221 1
a221 1
#ifdef LOG
d231 9
a502 3
	/* probe interfaces and locate any additional names */
	load_if_names();

d839 4
d895 4
a922 1
#ifdef LOG
d924 2
a925 1
			syslog(LOG_ALERT, "user %d attempted to %s",
a928 1
#endif
d941 2
a957 1
#ifdef LOG
d959 2
a960 2
			syslog(LOG_WARNING, "daemon invoked without full pathname; kill -1 won't work");
#endif
d968 2
a969 1
		Verbose = TRUE;
d1108 1
a1108 3
	if (OpMode == MD_TEST)
		/* nothing -- just avoid further if clauses */ ;
	else if (QueueDir == NULL)
d1110 5
a1114 2
		syserr("QueueDirectory (Q) option must be set");
		ExitStat = EX_CONFIG;
d1116 1
a1116 1
	else if (chdir(QueueDir) < 0)
d1118 7
a1124 2
		syserr("cannot chdir(%s)", QueueDir);
		ExitStat = EX_CONFIG;
d1252 1
a1252 1
			Verbose = TRUE;
a1286 1
		(void) unsetenv("HOSTALIASES");
d1330 2
a1331 3
#ifdef LOG
		syslog(LOG_INFO, "starting daemon (%s): %s", Version, dtype + 1);
#endif
d1341 1
d1343 1
d1345 4
d1432 1
a1432 1
			collect(InChannel, FALSE, FALSE, NULL, CurEnv);
d1453 2
d1456 12
a1467 1
		collect(InChannel, FALSE, FALSE, NULL, CurEnv);
d1486 1
d1537 7
d1558 1
a1558 1
# ifdef LOG
d1560 3
a1562 2
		syslog(LOG_DEBUG, "finis, pid=%d", getpid());
# endif /* LOG */
a1591 1
#ifdef LOG
d1593 1
a1593 3
		syslog(LOG_DEBUG, "%s: interrupt",
			CurEnv->e_id == NULL ? "[NOQUEUE]" : CurEnv->e_id);
#endif
a1713 1
#ifdef LOG
d1715 3
a1717 3
		syslog(LOG_DEBUG, "%s: disconnect level %d",
			e->e_id == NULL ? "[NOQUEUE]" : e->e_id, droplev);
#endif
d1726 1
a1726 1
	Verbose = FALSE;
a1766 1
# ifdef LOG
d1768 3
a1770 2
		syslog(LOG_DEBUG, "in background, pid=%d", getpid());
# endif /* LOG */
a1869 1
#ifdef LOG
d1871 3
a1873 3
			syslog(LOG_INFO, "%s: Authentication-Warning: %.400s",
				e->e_id == NULL ? "[NOQUEUE]" : e->e_id, buf);
#endif
a1962 1
#ifdef LOG
d1966 2
a1967 1
	syslog(LOG_DEBUG, "--- dumping state on %s: $j = %s ---",
d1973 2
a1974 1
			syslog(LOG_DEBUG, "*** $j not in $=w ***");
d1976 2
a1977 2
	syslog(LOG_DEBUG, "CurChildren = %d", CurChildren);
	syslog(LOG_DEBUG, "--- open file descriptors: ---");
d1979 1
a1979 1
	syslog(LOG_DEBUG, "--- connection cache: ---");
d1990 1
a1990 1
		syslog(LOG_DEBUG,
d1994 1
a1994 1
			syslog(LOG_DEBUG, "%s", *pvp);
d1996 1
a1996 2
	syslog(LOG_DEBUG, "--- end of state dump ---");
#endif
a2014 1
#ifdef LOG
d2016 1
a2016 2
			syslog(LOG_INFO, "could not restart: need full path");
#endif
a2018 1
#ifdef LOG
d2020 2
a2021 2
		syslog(LOG_INFO, "restarting %s on signal", SaveArgv[0]);
#endif
a2024 1
#ifdef LOG
d2026 1
a2026 1
			syslog(LOG_ALERT, "could not set[ug]id(%d, %d): %m",
a2027 1
#endif
a2030 1
#ifdef LOG
d2032 1
a2032 2
		syslog(LOG_ALERT, "could not exec %s: %m", SaveArgv[0]);
#endif
d2323 5
@


1.7
log
@getopt(3) fix that I missed in the previous sweep.
@
text
@d42 1
a42 1
static char sccsid[] = "@@(#)main.c	8.223 (Berkeley) 12/1/96";
d148 1
a148 1
	extern void intsig();
d152 2
a153 2
	extern void sigusr1();
	extern void sighup();
d235 3
d907 14
a936 11
		/* check for permissions */
		if (RealUid != 0)
		{
#ifdef LOG
			if (LogLevel > 1)
				syslog(LOG_ALERT, "user %d attempted to run daemon",
					RealUid);
#endif
			usrerr("Permission denied");
			exit(EX_USAGE);
		}
d958 5
d1229 1
a1229 1
		void intindebug();
d1397 1
a1397 1
	setsender(from, CurEnv, NULL, FALSE);
d1462 3
a1464 2
void
intindebug()
d1467 1
d1542 3
a1544 2
void
intsig()
d1959 3
a1961 2
void
sigusr1()
d1964 1
d1968 3
a1970 2
void
sighup()
d2004 2
a2005 2
**    Parameters:
**            none.
d2007 2
a2008 2
**    Returns:
**            none.
d2018 1
a2018 1
	emptygidset[0] = RunAsGid == 0 ? geteuid() : RunAsGid;
@


1.6
log
@getopt(3) returns -1 when out of args, not EOF, whee!
@
text
@d518 1
a518 1
	while ((j = getopt(argc, argv, OPTIONS)) != EOF)
@


1.5
log
@Update to Sendmail 8.8.4, plus recent patches, plus OpenBSD support.
Also include entire example configuration subset.
Includes smrsh (using /usr/libexec/sm.bin).

Of the top of my head, the only things I removed from the distribution were
contrib/mail.local.linux, src/Makefiles, all the *.0 and *.ps files.
Our praliases man page replaces the distributed one, ours is better.
@
text
@d252 1
a252 1
	while ((j = getopt(argc, argv, OPTIONS)) != EOF)
@


1.4
log
@Revoke privilages before restarting, from leshka@@leshka.chuvashia.su
@
text
@d2 1
a2 1
 * Copyright (c) 1983, 1995 Eric P. Allman
d42 1
a42 1
static char sccsid[] = "@@(#)main.c	8.162.1.3 (Berkeley) 9/16/96";
d48 1
d79 1
a79 1
**		Eric Allman, UCB/INGRES (until 10/81)
d81 8
a88 6
**				database computers (from 11/81)
**			     Now back at UCB at the Mammoth project.
**		The support of the INGRES Project and Britton-Lee is
**			gratefully acknowledged.  Britton-Lee in
**			particular had absolutely nothing to gain from
**			my involvement in this project.
d103 2
d106 6
a111 5
#ifdef DAEMON
#ifndef SMTP
ERROR %%%%   Cannot have daemon mode without SMTP   %%%% ERROR
#endif /* SMTP */
#endif /* DAEMON */
d113 1
a113 1
#define MAXCONFIGLEVEL	6	/* highest config version level known */
d133 1
d138 1
d141 1
d145 2
a149 1
	extern char *arpadate();
a151 2
	extern char *optarg;
	extern char **environ;
d155 12
d168 1
d183 3
d232 39
a312 29
	/* Handle any non-getoptable constructions. */
	obsolete(argv);

	/*
	**  Do a quick prescan of the argument list.
	*/

#if defined(__osf__) || defined(_AIX3)
# define OPTIONS	"B:b:C:cd:e:F:f:h:IiM:mnO:o:p:q:r:sTtvX:x"
#endif
#if defined(sony_news)
# define OPTIONS	"B:b:C:cd:E:e:F:f:h:IiJ:M:mnO:o:p:q:r:sTtvX:"
#endif
#ifndef OPTIONS
# define OPTIONS	"B:b:C:cd:e:F:f:h:IiM:mnO:o:p:q:r:sTtvX:"
#endif
	opterr = 0;
	while ((j = getopt(argc, argv, OPTIONS)) != EOF)
	{
		switch (j)
		{
		  case 'd':
			tTflag(optarg);
			setbuf(stdout, (char *) NULL);
			break;
		}
	}
	opterr = 1;

d345 1
a345 1
		printf("    OS Defines:", Version);
d369 1
a369 1
		printf("   Config file:\t%s\n", getcfname());
d379 5
d393 5
a397 1
	FullName = getenv("NAME");
d400 2
a402 2
	{
		res_init();
d404 3
a406 1
	}
d441 2
a498 7
	**  Find our real host name for future logging.
	*/

	p = getauthinfo(STDIN_FILENO);
	define('_', p, CurEnv);

	/*
d512 4
d526 2
a527 7
# ifdef DAEMON
				if (RealUid != 0) {
					usrerr("Permission denied");
					exit (EX_USAGE);
				}
				(void) unsetenv("HOSTALIASES");
# else
d533 1
a533 1
# ifndef SMTP
d538 2
a542 1
			  case MD_INITALIAS:
d544 2
a601 1
				break;
d609 23
d661 1
a661 2
# ifdef QUEUE
			(void) unsetenv("HOSTALIASES");
d688 17
d709 14
d731 1
d804 1
d810 13
a845 12
	**  Initialize name server if it is going to be used.
	*/

#if NAMED_BIND
	if (UseNameServer && !bitset(RES_INIT, _res.options))
		res_init();
# ifdef RES_NOALIASES
	_res.options |= RES_NOALIASES;
# endif
#endif

	/*
d870 4
d886 16
a901 2
		syserr("Warning: .cf version level (%d) exceeds program functionality (%d)",
			ConfigLevel, MAXCONFIGLEVEL);
d909 10
d920 13
d938 4
d943 3
d954 2
a955 1
		setsignal(SIGHUP, intsig);
d1052 9
a1060 4

		/* propogate some envariables into children */
		setuserenv("ISP", NULL);
		setuserenv("SYSTYPE", NULL);
d1066 1
a1066 1
	/* MIME message/* subtypes that can be treated as messages */
d1074 8
d1083 8
a1090 1
	if (OpMode != MD_TEST && chdir(QueueDir) < 0)
d1093 11
a1103 1
		ExitStat = EX_SOFTWARE;
d1106 1
a1106 1
# ifdef QUEUE
d1143 2
a1144 2
#ifdef QUEUE
		dropenvelope(CurEnv);
d1154 10
d1169 5
a1173 1
		exit(EX_OK);
d1176 5
a1180 1
	  case MD_SMTP:
d1192 2
d1249 1
a1249 1
# ifdef QUEUE
d1257 1
a1257 1
		runqueue(FALSE);
d1274 1
d1276 1
a1276 1
		if (!tTd(99, 100))
d1307 1
a1307 1
# ifdef QUEUE
d1310 1
a1310 1
			runqueue(TRUE);
d1316 1
a1316 1
		dropenvelope(CurEnv);
d1318 5
a1322 2
#ifdef DAEMON
		getrequests();
d1332 1
a1332 2
		define('_', p, CurEnv);

d1335 2
a1336 2
	
# ifdef SMTP
d1343 19
a1361 1
		smtp(CurEnv);
d1364 1
d1368 1
a1368 1
		CurEnv->e_errormode = EM_QUIET;
d1370 1
d1446 2
d1488 2
a1489 1
	dropenvelope(CurEnv);
d1532 5
d1568 2
a1569 2
	'*', MATCHZANY,		'+', MATCHANY,		'-', MATCHONE,
	'=', MATCHCLASS,	'~', MATCHNCLASS,
d1572 2
a1573 2
	'#', CANONNET,		'@@', CANONHOST,		':', CANONUSER,
	'>', CALLSUBR,
d1576 1
a1576 1
	'?', CONDIF,		'|', CONDELSE,		'.', CONDFI,
d1579 2
a1580 2
	'[', HOSTBEGIN,		']', HOSTEND,
	'(', LOOKUPBEGIN,	')', LOOKUPEND,
d1583 1
a1583 1
	'&', MACRODEXPAND,
d1585 1
a1585 1
	'\0'
d1650 2
a1651 2
		printf("disconnect: In %d Out %d, e=%x\n",
			fileno(InChannel), fileno(OutChannel), e);
d1657 5
d1811 1
a1811 1
		vsnprintf(p, sizeof buf - (p - buf), msg, ap);
d1822 25
d1871 1
a1871 1
		value = getenv(envar);
d1910 1
d1925 2
a1926 1
	if (RewriteRules[89] != NULL)
d1933 4
a1936 3
		stat = rewrite(pv, 89, 0, CurEnv);
		syslog(LOG_DEBUG, "--- ruleset 89 returns stat %d, pv: ---",
			stat);
d1955 8
d1968 9
a1976 2
	(void) setgid(RealGid);
	(void) setuid(RealUid);
d1985 25
d2044 1
d2111 2
d2114 1
d2136 1
a2136 1
			} while (rw = rw->r_next);
a2234 1
			auto int rcode = EX_OK;
d2248 2
a2249 3
			getcanonname(host, sizeof(host), HasWildcardMX, &rcode);
			printf("getcanonname(%s) returns %s (%d)\n",
				p, host, rcode);
d2313 1
d2369 1
d2407 2
d2410 1
@


1.3
log
@bring up to 8.7.6
@
text
@d1700 2
@


1.2
log
@Sendmail 8.7.3 from NetBSD
@
text
@d42 1
a42 1
static char sccsid[] = "@@(#)main.c	8.162 (Berkeley) 11/18/95";
d147 1
d228 1
a228 1
		(void) strcpy(rnamebuf, pw->pw_name);
d230 1
a230 1
		(void) sprintf(rnamebuf, "Unknown UID %d", RealUid);
d435 1
a435 1
				sprintf(ipbuf, "[%.100s]",
d711 3
d1576 1
a1576 1
		(void) sprintf(buf, "%s: ", hostbuf);
d1935 5
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
 * Copyright (c) 1983 Eric P. Allman
d42 1
a42 1
static char sccsid[] = "@@(#)main.c	8.55.1.7 (Berkeley) 3/5/95";
a48 1
#include <arpa/nameser.h>
a50 1
#include <pwd.h>
a94 3
char		*UserEnviron[MAXUSERENVIRON + 2];
				/* saved user environment */
char		RealUserName[256];	/* the actual user id on this host */
d97 1
a97 10

/*
**  Pointers for setproctitle.
**	This allows "ps" listings to give more useful information.
*/

# ifdef SETPROCTITLE
char		**Argv = NULL;		/* pointer to argument vector */
char		*LastArgv = NULL;	/* end of argv */
# endif /* SETPROCTITLE */
d107 1
a107 1
#define MAXCONFIGLEVEL	5	/* highest config version level known */
d109 1
a116 1
	extern int finis();
a127 1
	char *argv0 = argv[0];
d130 1
d132 1
d135 1
a136 1
	extern putheader(), putbody();
d138 1
a138 1
	extern char **myhostname();
d145 2
a163 1
	/* arrange to dump state on signal */
d165 1
d205 2
d225 1
a225 1
	pw = getpwuid(RealUid);
d227 1
a227 1
		(void) strcpy(RealUserName, pw->pw_name);
d229 2
a230 1
		(void) sprintf(RealUserName, "Unknown UID %d", RealUid);
d236 1
d239 1
a239 1
	for (av = argv; *av != NULL; )
d241 1
d247 1
d257 1
a257 1
# define OPTIONS	"B:b:C:cd:e:F:f:h:Iimno:p:q:r:sTtvX:x"
d259 2
a260 5
#if defined(ultrix)
# define OPTIONS	"B:b:C:cd:e:F:f:h:IiM:mno:p:q:r:sTtvX:"
#endif
#if defined(NeXT)
# define OPTIONS	"B:b:C:cd:e:F:f:h:IimnOo:p:q:r:sTtvX:"
d263 1
a263 1
# define OPTIONS	"B:b:C:cd:e:F:f:h:Iimno:p:q:r:sTtvX:"
d265 1
a270 1
			tTsetup(tTdvect, sizeof tTdvect, "0-99.1");
a272 1
			printf("Version %s\n", Version);
d276 1
d278 4
a281 2
	InChannel = stdin;
	OutChannel = stdout;
d283 26
a308 4
	/*
	**  Move the environment so setproctitle can use the space at
	**  the top of memory.
	*/
d310 26
a335 5
	for (i = j = 0; j < MAXUSERENVIRON && (p = envp[i]) != NULL; i++)
	{
		if (strncmp(p, "IFS=", 4) == 0 || strncmp(p, "LD_", 3) == 0)
			continue;
		UserEnviron[j++] = newstr(p);
a336 2
	UserEnviron[j] = NULL;
	environ = UserEnviron;
d338 5
a342 4
# ifdef SETPROCTITLE
	/*
	**  Save start and extent of argv for setproctitle.
	*/
d344 2
a345 6
	Argv = argv;
	if (i > 0)
		LastArgv = envp[i - 1] + strlen(envp[i - 1]);
	else
		LastArgv = argv[argc - 1] + strlen(argv[argc - 1]);
# endif /* SETPROCTITLE */
a348 2
	if (setsignal(SIGHUP, SIG_IGN) != SIG_IGN)
		(void) setsignal(SIGHUP, intsig);
d368 1
d374 1
a374 1
	av = myhostname(jbuf, sizeof jbuf);
a390 1
				setclass('m', &p[1]);
d411 1
a411 1
			printf("UUCP nodename: %s\n", p);
d417 1
a417 1
	while (av != NULL && *av != NULL)
d419 23
a441 3
		if (tTd(0, 4))
			printf("\ta.k.a.: %s\n", *av);
		setclass('w', *av++);
d444 3
a502 1
#ifdef MAYBE_NEXT_RELEASE
a503 1
#endif
d520 1
a520 5
			if (strcasecmp(optarg, "7bit") == 0 ||
			    strcasecmp(optarg, "8bitmime") == 0)
				CurEnv->e_bodytype = newstr(optarg);
			else
				usrerr("Illegal body type %s", optarg);
d527 1
d571 4
d629 1
a654 1
# if defined(ultrix)
a655 1
# endif
d673 4
a676 2
# if defined(NeXT)
		  case 'O':	/* random flag that NeXT Mail.app passes */
d694 10
a703 1
#ifdef XDEBUG
d706 1
d708 9
d720 2
a721 2
		printf("SYSTEM IDENTITY (after readcf):");
		printf("\n\t    (short domain name) $w = ");
d723 1
a723 1
		printf("\n\t(canonical domain name) $j = ");
d725 1
a725 1
		printf("\n\t       (subdomain name) $m = ");
d727 1
a727 1
		printf("\n\t            (node name) $k = ");
d729 1
a729 1
		printf("\n");
d737 1
a737 1
	if (!bitset(RES_INIT, _res.options))
d739 3
d745 2
a746 1
	**  Process authorization warnings from command line.
d749 1
a752 5
/*
	if (warn_f_flag != '\0')
		auth_warning(CurEnv, "%s set sender to %s using -%c",
			RealUserName, from, warn_f_flag);
*/
d756 13
d773 4
a776 17
	{
		char **evp = UserEnviron;
		char tzbuf[100];

		strcpy(tzbuf, "TZ=");
		strcpy(&tzbuf[3], TimeZoneSpec);

		while (*evp != NULL && strncmp(*evp, "TZ=", 3) != 0)
			evp++;
		if (*evp == NULL)
		{
			*evp++ = newstr(tzbuf);
			*evp = NULL;
		}
		else
			*evp++ = newstr(tzbuf);
	}
d778 1
d788 1
a788 2
# ifdef QUEUE
	if (queuemode && RealUid != 0 && bitset(PRIV_RESTRICTQRUN, PrivacyFlags))
d790 4
a793 1
		struct stat stbuf;
d795 3
a797 11
		/* check to see if we own the queue directory */
		if (stat(QueueDir, &stbuf) < 0)
			syserr("main: cannot stat %s", QueueDir);
		if (stbuf.st_uid != RealUid)
		{
			/* nope, really a botch */
			usrerr("You do not have permission to process the queue");
			exit (EX_NOPERM);
		}
	}
# endif /* QUEUE */
a798 2
	switch (OpMode)
	{
d801 1
a801 1
		break;
d803 3
a805 3
	  case MD_DAEMON:
		/* remove things that don't make sense in daemon mode */
		FullName = NULL;
d828 16
d845 1
a845 1
	expand("\201j", jbuf, &jbuf[sizeof jbuf - 1], CurEnv);
d847 3
d856 3
a858 1
	if (st == NULL)
a859 2
	else
		LocalMailer = st->s_mailer;
d865 1
d867 2
d874 1
d876 2
d885 33
d926 17
d946 1
d951 1
a951 1
#ifdef XDEBUG
d966 1
d977 1
d982 1
d995 2
a996 1
		printrules();
d999 2
a1000 26
			register struct mailer *m = Mailer[i];
			int j;

			if (m == NULL)
				continue;
			printf("mailer %d (%s): P=%s S=%d/%d R=%d/%d M=%ld F=", i, m->m_name,
				m->m_mailer, m->m_se_rwset, m->m_sh_rwset,
				m->m_re_rwset, m->m_rh_rwset, m->m_maxsize);
			for (j = '\0'; j <= '\177'; j++)
				if (bitnset(j, m->m_flags))
					(void) putchar(j);
			printf(" E=");
			xputs(m->m_eol);
			if (m->m_argv != NULL)
			{
				char **a = m->m_argv;

				printf(" A=");
				while (*a != NULL)
				{
					if (a != m->m_argv)
						printf(" ");
					xputs(*a++);
				}
			}
			printf("\n");
d1018 1
d1028 3
d1033 1
a1033 5
			register char **pvp;
			char *q;
			auto char *delimptr;
			extern bool invalidaddr();
			extern char *crackaddr();
d1040 3
d1044 2
a1045 49
				printf("> %s", buf);
			switch (buf[0])
			{
			  case '#':
				continue;

#ifdef MAYBENEXTRELEASE
			  case 'C':		/* try crackaddr */
			  	q = crackaddr(&buf[1]);
			  	xputs(q);
			  	printf("\n");
			  	continue;
#endif
			}

			for (p = buf; isascii(*p) && isspace(*p); p++)
				continue;
			q = p;
			while (*p != '\0' && !(isascii(*p) && isspace(*p)))
				p++;
			if (*p == '\0')
			{
				printf("No address!\n");
				continue;
			}
			*p = '\0';
			if (invalidaddr(p + 1, NULL))
				continue;
			do
			{
				char pvpbuf[PSBUFSIZE];

				pvp = prescan(++p, ',', pvpbuf, sizeof pvpbuf,
					      &delimptr);
				if (pvp == NULL)
					continue;
				p = q;
				while (*p != '\0')
				{
					int stat;

					stat = rewrite(pvp, atoi(p), 0, CurEnv);
					if (stat != EX_OK)
						printf("== Ruleset %s status %d\n",
							p, stat);
					while (*p != '\0' && *p++ != ',')
						continue;
				}
			} while (*(p = delimptr) != '\0');
d1056 1
d1075 1
a1075 1
		if (!tTd(0, 1))
d1147 1
d1152 1
a1152 1
		CurEnv->e_flags |= EF_GLOBALERRS;
d1160 3
d1174 1
a1174 1
			collect(FALSE, FALSE, CurEnv);
d1196 1
a1196 1
		collect(FALSE, FALSE, CurEnv);
d1224 9
d1246 1
d1250 5
a1254 2
		printf("\n====finis: stat %d e_flags %o, e_id=%s\n",
			ExitStat, CurEnv->e_flags,
d1256 2
d1278 1
a1278 1
	if (ExitStat == EX_TEMPFAIL)
d1282 1
d1313 1
d1357 5
d1366 1
d1368 1
a1368 1
	register int c;
a1384 2
	define('e', "\201j Sendmail \201v ready at \201b", e);
	define('l', "From \201g  \201d", e);
d1386 4
a1389 2
	define('o', ".:@@[]", e);
	define('q', "<\201g>", e);
d1411 1
d1421 1
a1421 1
	if (tTd(52, 5))
a1427 1
	(void) setsignal(SIGHUP, SIG_IGN);
d1471 1
a1471 1
#ifdef XDEBUG
d1499 5
a1503 1
		    ap[1] != 'd' && argv[1] != NULL && argv[1][0] != '-')
d1526 10
d1567 1
a1567 1
		extern char **myhostname();
d1575 1
a1575 1
		vsprintf(p, msg, ap);
d1577 54
a1630 1
		addheader("X-Authentication-Warning", buf, e);
d1632 4
a1648 1
	register STAB *s;
d1655 1
a1655 2
		s = stab(j, ST_CLASS, ST_FIND);
		if (s == NULL || !bitnset('w', s->s_class))
d1658 1
d1685 428
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@


1.1.1.2
log
@sendmail 8.9.1
@
text
@d2 1
a2 2
 * Copyright (c) 1998 Sendmail, Inc.  All rights reserved.
 * Copyright (c) 1983, 1995-1997 Eric P. Allman.  All rights reserved.
d6 15
a20 3
 * By using this file, you agree to the terms and conditions set
 * forth in the LICENSE file which can be found at the top level of
 * the sendmail distribution.
d22 11
d37 1
a37 3
"@@(#) Copyright (c) 1998 Sendmail, Inc.  All rights reserved.\n\
     Copyright (c) 1983, 1995-1997 Eric P. Allman.  All rights reserved.\n\
     Copyright (c) 1988, 1993\n\
d42 1
a42 1
static char sccsid[] = "@@(#)main.c	8.302 (Berkeley) 6/4/98";
a47 2
#include <arpa/inet.h>
#include <grp.h>
d49 1
d52 5
d66 7
a72 2
**	Sendmail is driven by settings read in from /etc/sendmail.cf
**	(read by readcf.c).
d80 1
a80 1
**		Eric Allman, UCB/INGRES (until 10/81).
d82 6
a87 9
**				database computers (11/81 - 10/88).
**			     International Computer Science Institute
**				(11/88 - 9/89).
**			     UCB/Mammoth Project (10/89 - 7/95).
**			     InReference, Inc. (8/95 - 1/97).
**			     Sendmail, Inc. (1/98 - present).
**		The support of the my employers is gratefully acknowledged.
**			Few of them (Britton-Lee in particular) have had
**			anything to gain from my involvement in this project.
d97 3
a101 2
char		**SaveArgv;	/* argument vector for re-execing */
int		MissingFds = 0;	/* bit map of fds missing on startup */
d103 4
a106 3
#ifdef NGROUPS_MAX
GIDSET_T	InitialGidSet[NGROUPS_MAX];
#endif
d108 12
a119 10
static void	obsolete __P((char **));
extern void	printmailer __P((MAILER *));
extern void	tTflag __P((char *));

#if DAEMON && !SMTP
ERROR %%%%   Cannot have DAEMON mode without SMTP   %%%% ERROR
#endif /* DAEMON && !SMTP */
#if SMTP && !QUEUE
ERROR %%%%   Cannot have SMTP mode without QUEUE   %%%% ERROR
#endif /* DAEMON && !SMTP */
d121 1
a121 1
#define MAXCONFIGLEVEL	8	/* highest config version level known */
a122 1
int
d130 1
d133 1
a140 1
	bool run_in_foreground = FALSE;	/* -bD mode */
d142 1
d144 1
a144 3
	struct hostent *hp;
	char *nullserver = NULL;
	bool forged;
a145 3
	static char rnamebuf[MAXNAME];	/* holds RealUserName */
	char *emptyenviron[1];
	QUEUE_CHAR *new;
d148 7
a154 1
	extern int opterr;
d157 1
a157 24
	extern time_t convtime __P((char *, char));
	extern SIGFUNC_DECL intsig __P((int));
	extern struct hostent *myhostname __P((char *, int));
	extern char *getauthinfo __P((int, bool *));
	extern char *getcfname __P((void));
	extern SIGFUNC_DECL sigusr1 __P((int));
	extern SIGFUNC_DECL sighup __P((int));
	extern void initmacros __P((ENVELOPE *));
	extern void init_md __P((int, char **));
	extern int getdtsize __P((void));
	extern void tTsetup __P((u_char *, int, char *));
	extern void setdefaults __P((ENVELOPE *));
	extern void initsetproctitle __P((int, char **, char **));
	extern void init_vendor_macros __P((ENVELOPE *));
	extern void load_if_names __P((void));
	extern void vendor_pre_defaults __P((ENVELOPE *));
	extern void vendor_post_defaults __P((ENVELOPE *));
	extern void readcf __P((char *, bool, ENVELOPE *));
	extern void printqueue __P((void));
	extern void sendtoargv __P((char **, ENVELOPE *));
	extern void resetlimits __P((void));
#ifndef HASUNSETENV
	extern void unsetenv __P((char *));
#endif  
a171 3
	/* avoid null pointer dereferences */
	TermEscape.te_rv_on = TermEscape.te_rv_off = "";

d175 5
d190 9
a198 3
	fill_fd(STDIN_FILENO, NULL);
	fill_fd(STDOUT_FILENO, NULL);
	fill_fd(STDERR_FILENO, NULL);
d208 1
a208 1
#if LOG
a215 80
	if (MissingFds != 0)
	{
		char mbuf[MAXLINE];

		mbuf[0] = '\0';
		if (bitset(1 << STDIN_FILENO, MissingFds))
			strcat(mbuf, ", stdin");
		if (bitset(1 << STDOUT_FILENO, MissingFds))
			strcat(mbuf, ", stdout");
		if (bitset(1 << STDERR_FILENO, MissingFds))
			strcat(mbuf, ", stderr");
		syserr("File descriptors missing on startup: %s", &mbuf[2]);
	}

	/* reset status from syserr() calls for missing file descriptors */
	Errors = 0;
	ExitStat = EX_OK;

#if XDEBUG
	checkfd012("after openlog");
#endif

	tTsetup(tTdvect, sizeof tTdvect, "0-99.1");

#ifdef NGROUPS_MAX
	/* save initial group set for future checks */
	i = getgroups(NGROUPS_MAX, InitialGidSet);
	if (i == 0)
		InitialGidSet[0] = (GID_T) -1;
	while (i < NGROUPS_MAX)
		InitialGidSet[i++] = InitialGidSet[0];
#endif

	/* drop group id privileges (RunAsUser not yet set) */
	(void) drop_privileges(FALSE);

#ifdef SIGUSR1
	/* arrange to dump state on user-1 signal */
	setsignal(SIGUSR1, sigusr1);
#endif

	/* initialize for setproctitle */
	initsetproctitle(argc, argv, envp);

	/* Handle any non-getoptable constructions. */
	obsolete(argv);

	/*
	**  Do a quick prescan of the argument list.
	*/

#if defined(__osf__) || defined(_AIX3)
# define OPTIONS	"B:b:C:cd:e:F:f:h:IiM:mN:nO:o:p:q:R:r:sTtUV:vX:x"
#endif
#if defined(sony_news)
# define OPTIONS	"B:b:C:cd:E:e:F:f:h:IiJ:M:mN:nO:o:p:q:R:r:sTtUV:vX:"
#endif
#ifndef OPTIONS
# define OPTIONS	"B:b:C:cd:e:F:f:h:IiM:mN:nO:o:p:q:R:r:sTtUV:vX:"
#endif
	opterr = 0;
	while ((j = getopt(argc, argv, OPTIONS)) != -1)
	{
		switch (j)
		{
		  case 'd':
			/* hack attack -- see if should use ANSI mode */
			if (strcmp(optarg, "ANSI") == 0)
			{
				TermEscape.te_rv_on = "\033[7m";
				TermEscape.te_rv_off = "\033[0m";
				break;
			}
			tTflag(optarg);
			setbuf(stdout, (char *) NULL);
			break;
		}
	}
	opterr = 1;

d234 1
a234 1
	pw = sm_getpwuid(RealUid);
d236 1
a236 1
		(void) snprintf(rnamebuf, sizeof rnamebuf, "%s", pw->pw_name);
d238 1
a238 34
		(void) snprintf(rnamebuf, sizeof rnamebuf, "Unknown UID %d", RealUid);
	RealUserName = rnamebuf;

	if (tTd(0, 101))
	{
		printf("Version %s\n", Version);
		endpwent();
		setuid(RealUid);
		exit(EX_OK);
	}

	/*
	**  if running non-setuid binary as non-root, pretend
	**  we are the RunAsUid
	*/
	if (RealUid != 0 && geteuid() == RealUid)
	{
		if (tTd(47, 1))
			printf("Non-setuid binary: RunAsUid = RealUid = %d\n",
				(int)RealUid);
		RunAsUid = RealUid;
	}
	else if (geteuid() != 0)
		RunAsUid = geteuid();

	if (RealUid != 0 && getegid() == RealGid)
		RunAsGid = RealGid;

	if (tTd(47, 5))
	{
		printf("main: e/ruid = %d/%d e/rgid = %d/%d\n",
			(int)geteuid(), (int)getuid(), (int)getegid(), (int)getgid());
		printf("main: RunAsUser = %d:%d\n", (int)RunAsUid, (int)RunAsGid);
	}
a243 1
	SaveArgv = (char **) xalloc(sizeof (char *) * (argc + 1));
d246 1
a246 1
	for (av = argv, i = 0; *av != NULL; )
a247 1
		SaveArgv[i++] = newstr(*av);
a252 1
	SaveArgv[i] = NULL;
d254 6
a259 4
	if (tTd(0, 1))
	{
		int ll;
		extern char *CompileOptions[];
d261 13
a273 23
		printf("Version %s\n Compiled with:", Version);
		av = CompileOptions;
		ll = 7;
		while (*av != NULL)
		{
			if (ll + strlen(*av) > 63)
			{
				putchar('\n');
				ll = 0;
			}
			if (ll == 0)
			{
				putchar('\t');
				putchar('\t');
			}
			else
				putchar(' ');
			printf("%s", *av);
			ll += strlen(*av++) + 1;
		}
		putchar('\n');
	}
	if (tTd(0, 10))
d275 1
a275 7
		int ll;
		extern char *OsCompileOptions[];

		printf("    OS Defines:");
		av = OsCompileOptions;
		ll = 7;
		while (*av != NULL)
d277 6
a282 14
			if (ll + strlen(*av) > 63)
			{
				putchar('\n');
				ll = 0;
			}
			if (ll == 0)
			{
				putchar('\t');
				putchar('\t');
			}
			else
				putchar(' ');
			printf("%s", *av);
			ll += strlen(*av++) + 1;
a283 6
		putchar('\n');
#ifdef _PATH_UNIX
		printf("Kernel symbols:\t%s\n", _PATH_UNIX);
#endif
		printf(" Def Conf file:\t%s\n", getcfname());
		printf("      Pid file:\t%s\n", PidFile);
a288 5
	/* clear sendmail's environment */
	ExternalEnviron = environ;
	emptyenviron[0] = NULL;
	environ = emptyenviron;

d290 2
a291 2
	** restore any original TZ setting until TimeZoneSpec has been
	** determined - or early log messages may get bogus time stamps
d293 2
a294 1
	if ((p = getextenv("TZ")) != NULL)
d296 6
a301 2
		char *tz;
		int tzlen;
d303 4
a306 5
		tzlen = strlen(p) + 4;
		tz = xalloc(tzlen);
		snprintf(tz, tzlen, "TZ=%s", p);
		putenv(tz);
	}
d308 6
a313 2
	/* prime the child environment */
	setuserenv("AGENT", "sendmail");
d317 2
d323 1
a323 5
	FullName = getextenv("NAME");

	/*
	**  Initialize name server if it is going to be used.
	*/
d326 2
a327 1
	if (!bitset(RES_INIT, _res.options))
a328 1
	if (tTd(8, 8))
d330 1
a330 5
	else
		_res.options &= ~RES_DEBUG;
# ifdef RES_NOALIASES
	_res.options |= RES_NOALIASES;
# endif
a337 1
	init_vendor_macros(CurEnv);
d343 1
a343 1
	hp = myhostname(jbuf, sizeof jbuf);
d360 1
a364 2
				if (tTd(0, 4))
					printf("\ta.k.a.: %s\n", jbuf);
d381 1
a381 1
			printf(" UUCP nodename: %s\n", p);
d387 1
a387 1
	if (hp != NULL)
d389 3
a391 21
		for (av = hp->h_aliases; av != NULL && *av != NULL; av++)
		{
			if (tTd(0, 4))
				printf("\ta.k.a.: %s\n", *av);
			setclass('w', *av);
		}
#if NETINET
		if (hp->h_addrtype == AF_INET && hp->h_length == INADDRSZ)
		{
			for (i = 0; hp->h_addr_list[i] != NULL; i++)
			{
				char ipbuf[103];

				snprintf(ipbuf, sizeof ipbuf, "[%.100s]",
					inet_ntoa(*((struct in_addr *) hp->h_addr_list[i])));
				if (tTd(0, 4))
					printf("\ta.k.a.: %s\n", ipbuf);
				setclass('w', ipbuf);
			}
		}
#endif
d397 6
a402 3
	QueueLimitRecipient = (QUEUE_CHAR *) NULL;
	QueueLimitSender = (QUEUE_CHAR *) NULL;
	QueueLimitId = (QUEUE_CHAR *) NULL;
a417 4
	else if (strcmp(p, "hoststat") == 0)
		OpMode = MD_HOSTSTAT;
	else if (strcmp(p, "purgestat") == 0)
		OpMode = MD_PURGESTAT;
d420 1
a420 1
	while ((j = getopt(argc, argv, OPTIONS)) != -1)
d428 7
a434 2
			  case MD_FGDAEMON:
# if !DAEMON
d440 1
a440 1
# if !SMTP
a444 2

			  case MD_INITALIAS:
d448 1
d450 1
a450 2
			  case MD_HOSTSTAT:
			  case MD_PURGESTAT:
d452 1
d469 5
a473 1
			CurEnv->e_bodytype = optarg;
d480 2
a481 1
			(void) drop_privileges(TRUE);
d511 1
a518 23
		  case 'N':	/* delivery status notifications */
			DefaultNotify |= QHASNOTIFY;
			if (strcasecmp(optarg, "never") == 0)
				break;
			for (p = optarg; p != NULL; optarg = p)
			{
				p = strchr(p, ',');
				if (p != NULL)
					*p++ = '\0';
				if (strcasecmp(optarg, "success") == 0)
					DefaultNotify |= QPINGONSUCCESS;
				else if (strcasecmp(optarg, "failure") == 0)
					DefaultNotify |= QPINGONFAILURE;
				else if (strcasecmp(optarg, "delay") == 0)
					DefaultNotify |= QPINGONDELAY;
				else
				{
					usrerr("Invalid -N argument");
					ExitStat = EX_USAGE;
				}
			}
			break;

a522 4
		  case 'O':	/* set option (long form) */
			setoption(' ', optarg, FALSE, TRUE, CurEnv);
			break;

d544 2
a545 1
# if QUEUE
d551 1
a551 5
				if ((new = (QUEUE_CHAR *)malloc(sizeof(QUEUE_CHAR))) == NULL)
					syserr("!Out of memory!!");
				new->queue_match = newstr(&optarg[1]);
				new->queue_next = QueueLimitId;
				QueueLimitId = new;
d555 1
a555 5
				if ((new = (QUEUE_CHAR *)malloc(sizeof(QUEUE_CHAR))) == NULL)
					syserr("!Out of memory!!");
				new->queue_match = newstr(&optarg[1]);
				new->queue_next = QueueLimitRecipient;
				QueueLimitRecipient = new;
d559 1
a559 5
				if ((new = (QUEUE_CHAR *)malloc(sizeof(QUEUE_CHAR))) == NULL)
					syserr("!Out of memory!!");
				new->queue_match = newstr(&optarg[1]);
				new->queue_next = QueueLimitSender;
				QueueLimitSender = new;
a571 17
		  case 'R':	/* DSN RET: what to return */
			if (bitset(EF_RET_PARAM, CurEnv->e_flags))
			{
				usrerr("Duplicate -R flag");
				ExitStat = EX_USAGE;
				break;
			}
			CurEnv->e_flags |= EF_RET_PARAM;
			if (strcasecmp(optarg, "hdrs") == 0)
				CurEnv->e_flags |= EF_NO_BODY_RETN;
			else if (strcasecmp(optarg, "full") != 0)
			{
				usrerr("Invalid -R value");
				ExitStat = EX_USAGE;
			}
			break;

a575 14
		  case 'U':	/* initial (user) submission */
			UserSubmission = TRUE;
			break;

		  case 'V':	/* DSN ENVID: set "original" envelope id */
			if (!xtextok(optarg))
			{
				usrerr("Invalid syntax in -V flag");
				ExitStat = EX_USAGE;
			}
			else
				CurEnv->e_envid = newstr(optarg);
			break;

d577 2
a578 1
			(void) drop_privileges(TRUE);
a582 1
				ExitStat = EX_CANTCREAT;
d602 1
d604 1
d622 2
a623 4
# if defined(sony_news)
		  case 'E':
		  case 'J':	/* ignore flags for Japanese code conversion
				   impremented on Sony NEWS */
d641 1
a641 10
	/* set up ${opMode} for use in config file */
	{
		char mbuf[2];

		mbuf[0] = OpMode;
		mbuf[1] = '\0';
		define(MID_OPMODE, newstr(mbuf), CurEnv);
	}

#if XDEBUG
a643 1
	vendor_pre_defaults(CurEnv);
a644 39
	ConfigFileRead = TRUE;
	vendor_post_defaults(CurEnv);

	/* Enforce use of local time (null string overrides this) */
	if (TimeZoneSpec == NULL)
		unsetenv("TZ");
	else if (TimeZoneSpec[0] != '\0')
		setuserenv("TZ", TimeZoneSpec);
	else
		setuserenv("TZ", NULL);
	tzset();

	/* avoid denial-of-service attacks */
	resetlimits();

	if (OpMode != MD_DAEMON && OpMode != MD_FGDAEMON)
	{
		/* drop privileges -- daemon mode done after socket/bind */
		(void) drop_privileges(FALSE);
	}

	/*
	**  Find our real host name for future logging.
	*/

	p = getauthinfo(STDIN_FILENO, &forged);
	define('_', p, CurEnv);

	/* suppress error printing if errors mailed back or whatever */
	if (CurEnv->e_errormode != EM_PRINT)
		HoldErrs = TRUE;

	/* set up the $=m class now, after .cf has a chance to redefine $m */
	expand("\201m", jbuf, sizeof jbuf, CurEnv);
	setclass('m', jbuf);

	/* probe interfaces and locate any additional names */
	if (!DontProbeInterfaces)
		load_if_names();
d648 2
a649 2
		printf("\n============ SYSTEM IDENTITY (after readcf) ============");
		printf("\n      (short domain name) $w = ");
d651 1
a651 1
		printf("\n  (canonical domain name) $j = ");
d653 1
a653 1
		printf("\n         (subdomain name) $m = ");
d655 1
a655 1
		printf("\n              (node name) $k = ");
d657 1
a657 1
		printf("\n========================================================\n\n");
d661 10
a670 2
	**  Do more command line checking -- these are things that
	**  have to modify the results of reading the config file.
a672 1
	/* process authorization warnings from command line */
d676 5
d684 4
a687 8
	/* check body type for legality */
	if (CurEnv->e_bodytype == NULL)
		/* nothing */ ;
	else if (strcasecmp(CurEnv->e_bodytype, "7BIT") == 0)
		SevenBitInput = TRUE;
	else if (strcasecmp(CurEnv->e_bodytype, "8BITMIME") == 0)
		SevenBitInput = FALSE;
	else
d689 2
a690 3
		usrerr("Illegal body type %s", CurEnv->e_bodytype);
		CurEnv->e_bodytype = NULL;
	}
d692 2
a693 3
	/* tweak default DSN notifications */
	if (DefaultNotify == 0)
		DefaultNotify = QPINGONFAILURE|QPINGONDELAY;
d695 10
a704 3
	/* be sure we don't pick up bogus HOSTALIASES environment variable */
	if (queuemode && RealUid != 0)
		(void) unsetenv("HOSTALIASES");
a705 1
	/* check for sane configuration level */
d708 2
a709 2
		syserr("Warning: .cf version level (%d) exceeds sendmail version %s functionality (%d)",
			ConfigLevel, Version, MAXCONFIGLEVEL);
d712 2
a713 6
	/* need MCI cache to have persistence */
	if (HostStatDir != NULL && MaxMciCache == 0)
	{
		HostStatDir = NULL;
		printf("Warning: HostStatusDirectory disabled with ConnectionCacheSize = 0\n");
	}
d715 2
a716 2
	/* need HostStatusDir in order to have SingleThreadDelivery */
	if (SingleThreadDelivery && HostStatDir == NULL)
d718 1
a718 3
		SingleThreadDelivery = FALSE;
		printf("Warning: HostStatusDirectory required for SingleThreadDelivery\n");
	}
d720 9
a728 12
	/* check for permissions */
	if ((OpMode == MD_DAEMON || OpMode == MD_FGDAEMON ||
	     OpMode == MD_PURGESTAT) && RealUid != 0)
	{
		if (LogLevel > 1)
			sm_syslog(LOG_ALERT, NOQID,
				"user %d attempted to %s",
				RealUid,
				OpMode != MD_PURGESTAT ? "run daemon"
						       : "purge host status");
		usrerr("Permission denied");
		exit(EX_USAGE);
d730 1
a730 3

	if (MeToo)
		BlankEnvelope.e_flags |= EF_METOO;
d734 2
a735 15
	  case MD_TEST:
		/* don't have persistent host status in test mode */
		HostStatDir = NULL;
		if (Verbose == 0)
			Verbose = 2;
		CurEnv->e_errormode = EM_PRINT;
		HoldErrs = FALSE;
		break;

	  case MD_VERIFY:
		CurEnv->e_errormode = EM_PRINT;
		HoldErrs = FALSE;
		/* arrange to exit cleanly on hangup signal */
		if (setsignal(SIGHUP, SIG_IGN) == (sigfunc_t) SIG_DFL)
			setsignal(SIGHUP, intsig);
a737 5
	  case MD_FGDAEMON:
		run_in_foreground = TRUE;
		OpMode = MD_DAEMON;
		/* fall through ... */

a738 2
		vendor_daemon_setup(CurEnv);

a740 27
		GrabTo = FALSE;

		/* arrange to restart on hangup signal */
		if (SaveArgv[0] == NULL || SaveArgv[0][0] != '/')
			sm_syslog(LOG_WARNING, NOQID,
				"daemon invoked without full pathname; kill -1 won't work");
		setsignal(SIGHUP, sighup);

		/* workaround: can't seem to release the signal in the parent */
		releasesignal(SIGHUP);
		break;

	  case MD_INITALIAS:
		Verbose = 2;
		CurEnv->e_errormode = EM_PRINT;
		HoldErrs = FALSE;
		/* fall through... */

	  case MD_PRINT:
		/* to handle sendmail -bp -qSfoobar properly */
		queuemode = FALSE;
		/* fall through... */

	  default:
		/* arrange to exit cleanly on hangup signal */
		if (setsignal(SIGHUP, SIG_IGN) == (sigfunc_t) SIG_DFL)
			setsignal(SIGHUP, intsig);
d744 3
a746 26
	/* special considerations for FullName */
	if (FullName != NULL)
	{
		char *full = NULL;
		extern bool rfc822_string __P((char *));

		/* full names can't have newlines */
		if (strchr(FullName, '\n') != NULL) 
		{
			FullName = full = newstr(denlstring(FullName, TRUE, TRUE));
		}
		/* check for characters that may have to be quoted */
		if (!rfc822_string(FullName))
		{
			extern char *addquotes __P((char *));

			/*
			**  Quote a full name with special characters
			**  as a comment so crackaddr() doesn't destroy
			**  the name portion of the address.
			*/
			FullName = addquotes(FullName);
			if (full != NULL)
				free(full);
		}
	}
a757 7
	/* check for out of date configuration level */
	if (ConfigLevel < MAXCONFIGLEVEL)
	{
		message("Warning: .cf file is out of date: sendmail %s supports version %d, .cf file is version %d",
			Version, MAXCONFIGLEVEL, ConfigLevel);
	}

a762 16
	/* set options that were previous macros */
	if (SmtpGreeting == NULL)
	{
		if (ConfigLevel < 7 && (p = macvalue('e', CurEnv)) != NULL)
			SmtpGreeting = newstr(p);
		else
			SmtpGreeting = "\201j Sendmail \201v ready at \201b";
	}
	if (UnixFromLine == NULL)
	{
		if (ConfigLevel < 7 && (p = macvalue('l', CurEnv)) != NULL)
			UnixFromLine = newstr(p);
		else
			UnixFromLine = "From \201g  \201d";
	}

d764 1
a764 1
	expand("\201j", jbuf, sizeof jbuf, CurEnv);
a765 3
	if (strchr(jbuf, '.') == NULL)
		message("WARNING: local host name (%s) is not qualified; fix $j in config file",
			jbuf);
d772 3
a774 1
	if (st != NULL)
a775 2
	else if (OpMode != MD_TEST || !warn_C_flag)
		syserr("No local mailer defined");
a780 1
	{
a781 2
		clrbitn(M_MUSER, ProgMailer->m_flags);
	}
a786 1
	{
a787 2
		clrbitn(M_MUSER, FileMailer->m_flags);
	}
a794 46
	if (ConfigLevel < 6)
	{
		/* heuristic tweaking of local mailer for back compat */
		if (LocalMailer != NULL)
		{
			setbitn(M_ALIASABLE, LocalMailer->m_flags);
			setbitn(M_HASPWENT, LocalMailer->m_flags);
			setbitn(M_TRYRULESET5, LocalMailer->m_flags);
			setbitn(M_CHECKINCLUDE, LocalMailer->m_flags);
			setbitn(M_CHECKPROG, LocalMailer->m_flags);
			setbitn(M_CHECKFILE, LocalMailer->m_flags);
			setbitn(M_CHECKUDB, LocalMailer->m_flags);
		}
		if (ProgMailer != NULL)
			setbitn(M_RUNASRCPT, ProgMailer->m_flags);
		if (FileMailer != NULL)
			setbitn(M_RUNASRCPT, FileMailer->m_flags);
	}
	if (ConfigLevel < 7)
	{
		if (LocalMailer != NULL)
			setbitn(M_VRFY250, LocalMailer->m_flags);
		if (ProgMailer != NULL)
			setbitn(M_VRFY250, ProgMailer->m_flags);
		if (FileMailer != NULL)
			setbitn(M_VRFY250, FileMailer->m_flags);
	}

	/* MIME Content-Types that cannot be transfer encoded */
	setclass('n', "multipart/signed");

	/* MIME message/xxx subtypes that can be treated as messages */
	setclass('s', "rfc822");

	/* MIME Content-Transfer-Encodings that can be encoded */
	setclass('e', "7bit");
	setclass('e', "8bit");
	setclass('e', "binary");

#ifdef USE_B_CLASS
	/* MIME Content-Types that should be treated as binary */
	setclass('b', "image");
	setclass('b', "audio");
	setclass('b', "video");
	setclass('b', "application/octet-stream");
#endif
d797 1
a797 21
	if (QueueDir == NULL)
	{
		if (OpMode != MD_TEST)
		{
			syserr("QueueDirectory (Q) option must be set");
			ExitStat = EX_CONFIG;
		}
	}
	else
	{
		/* test path to get warning messages */
		(void) safedirpath(QueueDir, (uid_t) 0, (gid_t) 0, NULL, SFF_ANYFILE);
		if (OpMode != MD_TEST && chdir(QueueDir) < 0)
		{
			syserr("cannot chdir(%s)", QueueDir);
			ExitStat = EX_CONFIG;
		}
	}

	/* check host status directory for validity */
	if (HostStatDir != NULL && !path_is_dir(HostStatDir, FALSE))
d799 2
a800 5
		/* cannot use this value */
		if (tTd(0, 2))
			printf("Cannot use HostStatusDirectory = %s: %s\n",
				HostStatDir, errstring(errno));
		HostStatDir = NULL;
a802 17
# if QUEUE
	if (queuemode && RealUid != 0 && bitset(PRIV_RESTRICTQRUN, PrivacyFlags))
	{
		struct stat stbuf;

		/* check to see if we own the queue directory */
		if (stat(".", &stbuf) < 0)
			syserr("main: cannot stat %s", QueueDir);
		if (stbuf.st_uid != RealUid)
		{
			/* nope, really a botch */
			usrerr("You do not have permission to process the queue");
			exit (EX_NOPERM);
		}
	}
# endif /* QUEUE */

a805 1
		endpwent();
d810 1
a810 1
#if XDEBUG
d822 2
a823 2
#if QUEUE
		dropenvelope(CurEnv, TRUE);
a824 1
		endpwent();
a831 10
	  case MD_HOSTSTAT:
		mci_traverse_persistent(mci_print_persistent, NULL);
		exit(EX_OK);
	    	break;

	  case MD_PURGESTAT:
		mci_traverse_persistent(mci_purge_persistent, NULL);
		exit(EX_OK);
	    	break;

a834 1
		endpwent();
d836 1
a836 1
		exit(ExitStat);
a837 1
	  case MD_SMTP:
a838 5
		/* reset DSN parameters */
		DefaultNotify = QPINGONFAILURE|QPINGONDELAY;
		CurEnv->e_envid = NULL;
		CurEnv->e_flags &= ~(EF_RET_PARAM|EF_NO_BODY_RETN);

a849 2
		extern void printrules __P((void));

d851 1
a851 2
		if (tTd(0, 90))
			printrules();
d854 26
a879 2
			if (Mailer[i] != NULL)
				printmailer(Mailer[i]);
a896 1
		SIGFUNC_DECL intindebug __P((int));
d899 1
a899 1
			Verbose = 2;
a905 3
		if (setjmp(TopFrame) > 0)
			printf("\n");
		(void) setsignal(SIGINT, intindebug);
d908 5
a912 1
			extern void testmodeline __P((char *, ENVELOPE *));
d914 1
a914 1
			if (Verbose == 2)
d919 50
a968 6
			p = strchr(buf, '\n');
			if (p != NULL)
				*p = '\0';
			if (Verbose < 2)
				printf("> %s\n", buf);
			testmodeline(buf, CurEnv);
d972 1
a972 1
# if QUEUE
d979 1
a979 1
		(void) runqueue(FALSE, Verbose);
a995 1
		extern void getrequests __P((ENVELOPE *));
d997 1
a997 1
		if (!run_in_foreground && !tTd(99, 100))
d1004 1
a1004 1
				exit(EX_OK);
d1021 3
a1023 2
		sm_syslog(LOG_INFO, NOQID,
			"starting daemon (%s): %s", Version, dtype + 1);
d1028 1
a1028 1
# if QUEUE
d1031 1
a1031 1
			(void) runqueue(TRUE, FALSE);
a1032 1
			{
a1033 1
				{
a1034 4
					if (DoQueueRun)
						(void) runqueue(TRUE, FALSE);
				}
			}
d1037 1
a1037 1
		dropenvelope(CurEnv, TRUE);
d1039 2
a1040 5
#if DAEMON
		getrequests(CurEnv);

		/* drop privileges */
		(void) drop_privileges(FALSE);
d1049 3
a1051 2
		p = getauthinfo(fileno(InChannel), &forged);
		define('_', p, &BlankEnvelope);
d1054 2
a1055 2

# if SMTP
d1062 1
a1062 38
	{
		char pbuf[20];
		extern void smtp __P((char *, ENVELOPE *));

		/*
		**  Save some macros for check_* rulesets.
		*/

		if (forged)
		{
			char ipbuf[103];

			snprintf(ipbuf, sizeof ipbuf, "[%.100s]",
				 inet_ntoa(RealHostAddr.sin.sin_addr));

			define(macid("{client_name}", NULL),
			       newstr(ipbuf), &BlankEnvelope);
		}
		else
			define(macid("{client_name}", NULL), RealHostName, &BlankEnvelope);
		define(macid("{client_addr}", NULL),
		       newstr(anynet_ntoa(&RealHostAddr)), &BlankEnvelope);
		if (RealHostAddr.sa.sa_family == AF_INET)
			snprintf(pbuf, sizeof pbuf, "%d", RealHostAddr.sin.sin_port);
		else
			snprintf(pbuf, sizeof pbuf, "0");
		define(macid("{client_port}", NULL), newstr(pbuf), &BlankEnvelope);

		if (OpMode == MD_DAEMON)
		{
			/* validate the connection */
			HoldErrs = TRUE;
			nullserver = validate_connection(&RealHostAddr,
							 RealHostName, CurEnv);
			HoldErrs = FALSE;
		}
		smtp(nullserver, CurEnv);
	}
a1064 1
	clearenvelope(CurEnv, FALSE);
d1068 1
a1068 1
		PostMasterCopy = NULL;
d1073 1
a1073 1
		CurEnv->e_flags |= EF_GLOBALERRS|EF_LOGSENDER;
d1081 1
a1081 4
	if (warn_f_flag != '\0' && !wordinclass(RealUserName, 't'))
		auth_warning(CurEnv, "%s set sender to %s using -%c",
			RealUserName, from, warn_f_flag);
	setsender(from, CurEnv, NULL, '\0', FALSE);
d1092 1
a1092 1
			collect(InChannel, FALSE, NULL, CurEnv);
a1105 15
#if _FFR_FIX_DASHT
	/*
	**  If using -t, force not sending to argv recipients, even
	**  if they are mentioned in the headers.
	*/

	if (GrabTo)
	{
		ADDRESS *q;
		
		for (q = CurEnv->e_sendqueue; q != NULL; q = q->q_next)
			q->q_flags |= QDONTSEND;
	}
#endif

a1112 2
		long savedflags = CurEnv->e_flags & EF_FATALERRS;

d1114 1
a1114 11
		CurEnv->e_flags &= ~EF_FATALERRS;
		collect(InChannel, FALSE, NULL, CurEnv);

		/* bail out if message too large */
		if (bitset(EF_CLRQUEUE, CurEnv->e_flags))
		{
			finis();
			/*NOTREACHED*/
			return -1;
		}
		CurEnv->e_flags |= savedflags;
a1132 2
	CurrentLA = getla();
	GrabTo = FALSE;
a1140 2
	/*NOTREACHED*/
	return -1;
a1141 12


/* ARGSUSED */
SIGFUNC_DECL
intindebug(sig)
	int sig;
{
	longjmp(TopFrame, 1);
	return SIGFUNC_RETURN;
}


a1154 1
void
d1158 2
a1159 5
	{
		extern void printenvflags __P((ENVELOPE *));

		printf("\n====finis: stat %d e_id=%s e_flags=",
			ExitStat,
a1160 2
		printenvflags(CurEnv);
	}
a1163 7
	/* if we fail in finis(), just exit */
	if (setjmp(TopFrame) != 0)
	{
		/* failed -- just give it up */
		goto forceexit;
	}

d1166 1
a1166 2
	if (CurEnv->e_id != NULL)
		dropenvelope(CurEnv, TRUE);
d1177 1
a1177 1
  forceexit:
d1179 3
a1181 4
		sm_syslog(LOG_DEBUG, CurEnv->e_id,
			"finis, pid=%d",
			getpid());
	if (ExitStat == EX_TEMPFAIL || CurEnv->e_errormode == EM_BERKNET)
a1184 1
	endpwent();
d1205 2
a1206 4
/* ARGSUSED */
SIGFUNC_DECL
intsig(sig)
	int sig;
a1207 2
	if (LogLevel > 79)
		sm_syslog(LOG_DEBUG, CurEnv->e_id, "interrupt");
a1214 1
	endpwent();
d1238 2
a1239 2
	{ '*', MATCHZANY },	{ '+', MATCHANY },	{ '-', MATCHONE },
	{ '=', MATCHCLASS },	{ '~', MATCHNCLASS },
d1242 2
a1243 2
	{ '#', CANONNET },	{ '@@', CANONHOST },	{ ':', CANONUSER },
	{ '>', CALLSUBR },
d1246 1
a1246 1
	{ '?', CONDIF },	{ '|', CONDELSE },	{ '.', CONDFI },
d1249 2
a1250 2
	{ '[', HOSTBEGIN },	{ ']', HOSTEND },
	{ '(', LOOKUPBEGIN },	{ ')', LOOKUPEND },
d1253 1
a1253 1
	{ '&', MACRODEXPAND },
d1255 1
a1255 1
	{ '\0' }
a1257 5
#define MACBINDING(name, mid) \
		stab(name, ST_MACRO, ST_ENTER)->s_macro = mid; \
		MacroName[mid] = name;

void
d1262 1
a1263 2
	char buf[5];
	extern char *MacroName[256];
d1280 2
d1283 2
a1284 4

	/* set up external names for some internal macros */
	MACBINDING("opMode", MID_OPMODE);
	/*XXX should probably add equivalents for all short macros here XXX*/
a1305 1
void
d1313 3
a1315 3
		printf("disconnect: In %d Out %d, e=%lx\n",
			fileno(InChannel), fileno(OutChannel), (u_long) e);
	if (tTd(52, 100))
a1319 4
	if (LogLevel > 93)
		sm_syslog(LOG_DEBUG, e->e_id,
			"disconnect level %d",
			droplev);
d1322 1
d1329 1
a1329 1
	Verbose = 0;
d1338 1
a1338 4
	if (freopen("/dev/null", "r", stdin) == NULL)
		sm_syslog(LOG_ERR, e->e_id,
			  "disconnect: freopen(\"/dev/null\") failed: %s",
			  errstring(errno));
a1348 1
		{
a1349 5
			if (fd == -1)
				sm_syslog(LOG_ERR, e->e_id,
					  "disconnect: open(\"/dev/null\") failed: %s",
					  errstring(errno));
		}
a1350 1
		{
a1351 5
			if (fd == -1)
				sm_syslog(LOG_ERR, e->e_id,
					  "disconnect: fileno(e->e_xfp) failed: %s",
					  errstring(errno));
		}
d1366 1
a1366 1
#if XDEBUG
d1370 1
d1372 2
a1373 3
		sm_syslog(LOG_DEBUG, e->e_id,
			"in background, pid=%d",
			getpid());
d1394 1
a1394 5
		    ap[1] != 'd' &&
#if defined(sony_news)
		    ap[1] != 'E' && ap[1] != 'J' &&
#endif
		    argv[1] != NULL && argv[1][0] != '-')
a1416 10

# if defined(sony_news)
		/* if -E doesn't have an argument, use -EC */
		if (ap[1] == 'E' && ap[2] == '\0')
			*argv = "-EC";

		/* if -J doesn't have an argument, use -JJ */
		if (ap[1] == 'J' && ap[2] == '\0')
			*argv = "-JJ";
# endif
d1448 1
a1448 1
		extern struct hostent *myhostname __P((char *, int));
d1453 1
a1453 1
		(void) snprintf(buf, sizeof buf, "%s: ", hostbuf);
d1456 1
a1456 1
		vsnprintf(p, SPACELEFT(buf, p), msg, ap);
d1458 1
a1458 5
		addheader("X-Authentication-Warning", buf, &e->e_header);
		if (LogLevel > 3)
			sm_syslog(LOG_INFO, e->e_id,
				"Authentication-Warning: %.400s",
				buf);
a1461 77
**  GETEXTENV -- get from external environment
**
**	Parameters:
**		envar -- the name of the variable to retrieve
**
**	Returns:
**		The value, if any.
*/

char *
getextenv(envar)
	const char *envar;
{
	char **envp;
	int l;

	l = strlen(envar);
	for (envp = ExternalEnviron; *envp != NULL; envp++)
	{
		if (strncmp(*envp, envar, l) == 0 && (*envp)[l] == '=')
			return &(*envp)[l + 1];
	}
	return NULL;
}
/*
**  SETUSERENV -- set an environment in the propogated environment
**
**	Parameters:
**		envar -- the name of the environment variable.
**		value -- the value to which it should be set.  If
**			null, this is extracted from the incoming
**			environment.  If that is not set, the call
**			to setuserenv is ignored.
**
**	Returns:
**		none.
*/

void
setuserenv(envar, value)
	const char *envar;
	const char *value;
{
	int i;
	char **evp = UserEnviron;
	char *p;

	if (value == NULL)
	{
		value = getextenv(envar);
		if (value == NULL)
			return;
	}

	i = strlen(envar);
	p = (char *) xalloc(strlen(value) + i + 2);
	strcpy(p, envar);
	p[i++] = '=';
	strcpy(&p[i], value);

	while (*evp != NULL && strncmp(*evp, p, i) != 0)
		evp++;
	if (*evp != NULL)
	{
		*evp++ = p;
	}
	else if (evp < &UserEnviron[MAXUSERENVIRON])
	{
		*evp++ = p;
		*evp = NULL;
	}

	/* make sure it is in our environment as well */
	if (putenv(p) < 0)
		syserr("setuserenv: putenv(%s) failed", p);
}
/*
d1471 1
d1473 1
a1473 1
	int rs;
d1475 1
a1475 2
	sm_syslog(LOG_DEBUG, CurEnv->e_id,
		"--- dumping state on %s: $j = %s ---",
d1480 3
a1482 3
		if (!wordinclass(j, 'w'))
			sm_syslog(LOG_DEBUG, CurEnv->e_id,
				"*** $j not in $=w ***");
d1484 1
a1484 2
	sm_syslog(LOG_DEBUG, CurEnv->e_id, "CurChildren = %d", CurChildren);
	sm_syslog(LOG_DEBUG, CurEnv->e_id, "--- open file descriptors: ---");
d1486 1
a1486 1
	sm_syslog(LOG_DEBUG, CurEnv->e_id, "--- connection cache: ---");
d1488 1
a1488 2
	rs = strtorwset("debug_dumpstate", NULL, ST_FIND);
	if (rs > 0)
d1495 3
a1497 4
		stat = rewrite(pv, rs, 0, CurEnv);
		sm_syslog(LOG_DEBUG, CurEnv->e_id,
		       "--- ruleset debug_dumpstate returns stat %d, pv: ---",
		       stat);
d1499 1
a1499 134
			sm_syslog(LOG_DEBUG, CurEnv->e_id, "%s", *pvp);
	}
	sm_syslog(LOG_DEBUG, CurEnv->e_id, "--- end of state dump ---");
}


/* ARGSUSED */
SIGFUNC_DECL
sigusr1(sig)
	int sig;
{
	dumpstate("user signal");
	return SIGFUNC_RETURN;
}


/* ARGSUSED */
SIGFUNC_DECL
sighup(sig)
	int sig;
{
	if (SaveArgv[0][0] != '/')
	{
		if (LogLevel > 3)
			sm_syslog(LOG_INFO, NOQID, "could not restart: need full path");
		exit(EX_OSFILE);
	}
	if (LogLevel > 3)
		sm_syslog(LOG_INFO, NOQID, "restarting %s on signal", SaveArgv[0]);
	alarm(0);
	releasesignal(SIGHUP);
	if (drop_privileges(TRUE) != EX_OK)
	{
		if (LogLevel > 0)
			sm_syslog(LOG_ALERT, NOQID, "could not set[ug]id(%d, %d): %m",
				RunAsUid, RunAsGid);
		exit(EX_OSERR);
	}
	execve(SaveArgv[0], (ARGV_T) SaveArgv, (ARGV_T) ExternalEnviron);
	if (LogLevel > 0)
		sm_syslog(LOG_ALERT, NOQID, "could not exec %s: %m", SaveArgv[0]);
	exit(EX_OSFILE);
}
/*
**  DROP_PRIVILEGES -- reduce privileges to those of the RunAsUser option
**
**	Parameters:
**		to_real_uid -- if set, drop to the real uid instead
**			of the RunAsUser.
**
**	Returns:
**		EX_OSERR if the setuid failed.
**		EX_OK otherwise.
*/

int
drop_privileges(to_real_uid)
	bool to_real_uid;
{
	int rval = EX_OK;
	GIDSET_T emptygidset[1];

	if (tTd(47, 1))
		printf("drop_privileges(%d): Real[UG]id=%d:%d, RunAs[UG]id=%d:%d\n",
			(int)to_real_uid, (int)RealUid, (int)RealGid, (int)RunAsUid, (int)RunAsGid);

	if (to_real_uid)
	{
		RunAsUserName = RealUserName;
		RunAsUid = RealUid;
		RunAsGid = RealGid;
	}

	/* make sure no one can grab open descriptors for secret files */
	endpwent();

	/* reset group permissions; these can be set later */
	emptygidset[0] = (to_real_uid || RunAsGid != 0) ? RunAsGid : getegid();
	if (setgroups(1, emptygidset) == -1 && geteuid() == 0)
		rval = EX_OSERR;

	/* reset primary group and user id */
	if ((to_real_uid || RunAsGid != 0) && setgid(RunAsGid) < 0)
		rval = EX_OSERR;
	if ((to_real_uid || RunAsUid != 0) && setuid(RunAsUid) < 0)
		rval = EX_OSERR;
	if (tTd(47, 5))
	{
		printf("drop_privileges: e/ruid = %d/%d e/rgid = %d/%d\n",
			(int)geteuid(), (int)getuid(), (int)getegid(), (int)getgid());
		printf("drop_privileges: RunAsUser = %d:%d\n", (int)RunAsUid, (int)RunAsGid);
	}
	return rval;
}
/*
**  FILL_FD -- make sure a file descriptor has been properly allocated
**
**	Used to make sure that stdin/out/err are allocated on startup
**
**	Parameters:
**		fd -- the file descriptor to be filled.
**		where -- a string used for logging.  If NULL, this is
**			being called on startup, and logging should
**			not be done.
**
**	Returns:
**		none
*/

void
fill_fd(fd, where)
	int fd;
	char *where;
{
	int i;
	struct stat stbuf;

	if (fstat(fd, &stbuf) >= 0 || errno != EBADF)
		return;

	if (where != NULL)
		syserr("fill_fd: %s: fd %d not open", where, fd);
	else
		MissingFds |= 1 << fd;
	i = open("/dev/null", fd == 0 ? O_RDONLY : O_WRONLY, 0666);
	if (i < 0)
	{
		syserr("!fill_fd: %s: cannot open /dev/null",
			where == NULL ? "startup" : where);
	}
	if (fd != i)
	{
		(void) dup2(i, fd);
		(void) close(i);
d1501 1
a1501 223
}
/*
**  TESTMODELINE -- process a test mode input line
**
**	Parameters:
**		line -- the input line.
**		e -- the current environment.
**	Syntax:
**		#  a comment
**		.X process X as a configuration line
**		=X dump a configuration item (such as mailers)
**		$X dump a macro or class
**		/X try an activity
**		X  normal process through rule set X
*/

void
testmodeline(line, e)
	char *line;
	ENVELOPE *e;
{
	register char *p;
	char *q;
	auto char *delimptr;
	int mid;
	int i, rs;
	STAB *map;
	char **s;
	struct rewrite *rw;
	ADDRESS a;
	static int tryflags = RF_COPYNONE;
	char exbuf[MAXLINE];
	extern bool invalidaddr __P((char *, char *));
	extern char *crackaddr __P((char *));
	extern void dump_class __P((STAB *, int));
	extern void translate_dollars __P((char *));
	extern void help __P((char *));

	switch (line[0])
	{
	  case '#':
	  case 0:
		return;

	  case '?':
		help("-bt");
		return;

	  case '.':		/* config-style settings */
		switch (line[1])
		{
		  case 'D':
			mid = macid(&line[2], &delimptr);
			if (mid == '\0')
				return;
			translate_dollars(delimptr);
			define(mid, newstr(delimptr), e);
			break;

		  case 'C':
			if (line[2] == '\0')	/* not to call syserr() */
				return;

			mid = macid(&line[2], &delimptr);
			if (mid == '\0')
				return;
			translate_dollars(delimptr);
			expand(delimptr, exbuf, sizeof exbuf, e);
			p = exbuf;
			while (*p != '\0')
			{
				register char *wd;
				char delim;

				while (*p != '\0' && isascii(*p) && isspace(*p))
					p++;
				wd = p;
				while (*p != '\0' && !(isascii(*p) && isspace(*p)))
					p++;
				delim = *p;
				*p = '\0';
				if (wd[0] != '\0')
					setclass(mid, wd);
				*p = delim;
			}
			break;

		  case '\0':
			printf("Usage: .[DC]macro value(s)\n");
			break;

		  default:
			printf("Unknown \".\" command %s\n", line);
			break;
		}
		return;

	  case '=':		/* config-style settings */
		switch (line[1])
		{
		  case 'S':		/* dump rule set */
			rs = strtorwset(&line[2], NULL, ST_FIND);
			if (rs < 0)
			{
				printf("Undefined ruleset %s\n", &line[2]);
				return;
			}
			rw = RewriteRules[rs];
			if (rw == NULL)
				return;
			do
			{
				putchar('R');
				s = rw->r_lhs;
				while (*s != NULL)
				{
					xputs(*s++);
					putchar(' ');
				}
				putchar('\t');
				putchar('\t');
				s = rw->r_rhs;
				while (*s != NULL)
				{
					xputs(*s++);
					putchar(' ');
				}
				putchar('\n');
			} while ((rw = rw->r_next) != NULL);
			break;

		  case 'M':
			for (i = 0; i < MAXMAILERS; i++)
			{
				if (Mailer[i] != NULL)
					printmailer(Mailer[i]);
			}
			break;

		  case '\0':
			printf("Usage: =Sruleset or =M\n");
			break;

		  default:
			printf("Unknown \"=\" command %s\n", line);
			break;
		}
		return;

	  case '-':		/* set command-line-like opts */
		switch (line[1])
		{
		  case 'd':
			tTflag(&line[2]);
			break;

		  case '\0':
			printf("Usage: -d{debug arguments}\n");
			break;

		  default:
			printf("Unknown \"-\" command %s\n", line);
			break;
		}
		return;

	  case '$':
		if (line[1] == '=')
		{
			mid = macid(&line[2], NULL);
			if (mid != '\0')
				stabapply(dump_class, mid);
			return;
		}
		mid = macid(&line[1], NULL);
		if (mid == '\0')
			return;
		p = macvalue(mid, e);
		if (p == NULL)
			printf("Undefined\n");
		else
		{
			xputs(p);
			printf("\n");
		}
		return;

	  case '/':		/* miscellaneous commands */
		p = &line[strlen(line)];
		while (--p >= line && isascii(*p) && isspace(*p))
			*p = '\0';
		p = strpbrk(line, " \t");
		if (p != NULL)
		{
			while (isascii(*p) && isspace(*p))
				*p++ = '\0';
		}
		else
			p = "";
		if (line[1] == '\0')
		{
			printf("Usage: /[canon|map|mx|parse|try|tryflags]\n");
			return;
		}
		if (strcasecmp(&line[1], "mx") == 0)
		{
#if NAMED_BIND
			/* look up MX records */
			int nmx;
			auto int rcode;
			char *mxhosts[MAXMXHOSTS + 1];

			if (*p == '\0')
			{
				printf("Usage: /mx address\n");
				return;
			}
			nmx = getmxrr(p, mxhosts, FALSE, &rcode);
			printf("getmxrr(%s) returns %d value(s):\n", p, nmx);
			for (i = 0; i < nmx; i++)
				printf("\t%s\n", mxhosts[i]);
#else
			printf("No MX code compiled in\n");
a1502 195
		}
		else if (strcasecmp(&line[1], "canon") == 0)
		{
			char host[MAXHOSTNAMELEN];

			if (*p == '\0')
			{
				printf("Usage: /canon address\n");
				return;
			}
			else if (strlen(p) >= sizeof host)
			{
				printf("Name too long\n");
				return;
			}
			strcpy(host, p);
			(void) getcanonname(host, sizeof(host), HasWildcardMX);
			printf("getcanonname(%s) returns %s\n", p, host);
		}
		else if (strcasecmp(&line[1], "map") == 0)
		{
			auto int rcode = EX_OK;
			char *av[2];

			if (*p == '\0')
			{
				printf("Usage: /map mapname key\n");
				return;
			}
			for (q = p; *q != '\0' && !(isascii(*q) && isspace(*q)); q++)
				continue;
			if (*q == '\0')
			{
				printf("No key specified\n");
				return;
			}
			*q++ = '\0';
			map = stab(p, ST_MAP, ST_FIND);
			if (map == NULL)
			{
				printf("Map named \"%s\" not found\n", p);
				return;
			}
			if (!bitset(MF_OPEN, map->s_map.map_mflags))
			{
				printf("Map named \"%s\" not open\n", p);
				return;
			}
			printf("map_lookup: %s (%s) ", p, q);
			av[0] = q;
			av[1] = NULL;
			p = (*map->s_map.map_class->map_lookup)
					(&map->s_map, q, av, &rcode);
			if (p == NULL)
				printf("no match (%d)\n", rcode);
			else
				printf("returns %s (%d)\n", p, rcode);
		}
		else if (strcasecmp(&line[1], "try") == 0)
		{
			MAILER *m;
			STAB *s;
			auto int rcode = EX_OK;

			q = strpbrk(p, " \t");
			if (q != NULL)
			{
				while (isascii(*q) && isspace(*q))
					*q++ = '\0';
			}
			if (q == NULL || *q == '\0')
			{
				printf("Usage: /try mailer address\n");
				return;
			}
			s = stab(p, ST_MAILER, ST_FIND);
			if (s == NULL)
			{
				printf("Unknown mailer %s\n", p);
				return;
			}
			m = s->s_mailer;
			printf("Trying %s %s address %s for mailer %s\n",
				bitset(RF_HEADERADDR, tryflags) ? "header" : "envelope",
				bitset(RF_SENDERADDR, tryflags) ? "sender" : "recipient",
				q, p);
			p = remotename(q, m, tryflags, &rcode, CurEnv);
			printf("Rcode = %d, addr = %s\n",
				rcode, p == NULL ? "<NULL>" : p);
			e->e_to = NULL;
		}
		else if (strcasecmp(&line[1], "tryflags") == 0)
		{
			if (*p == '\0')
			{
				printf("Usage: /tryflags [Hh|Ee][Ss|Rr]\n");
				return;
			}
			for (; *p != '\0'; p++)
			{
				switch (*p)
				{
				  case 'H':
				  case 'h':
					tryflags |= RF_HEADERADDR;
					break;

				  case 'E':
				  case 'e':
					tryflags &= ~RF_HEADERADDR;
					break;

				  case 'S':
				  case 's':
					tryflags |= RF_SENDERADDR;
					break;

				  case 'R':
				  case 'r':
					tryflags &= ~RF_SENDERADDR;
					break;
				}
			}
		}
		else if (strcasecmp(&line[1], "parse") == 0)
		{
			if (*p == '\0')
			{
				printf("Usage: /parse address\n");
				return;
			}
			q = crackaddr(p);
			printf("Cracked address = ");
			xputs(q);
			printf("\nParsing %s %s address\n",
				bitset(RF_HEADERADDR, tryflags) ? "header" : "envelope",
				bitset(RF_SENDERADDR, tryflags) ? "sender" : "recipient");
			if (parseaddr(p, &a, tryflags, '\0', NULL, e) == NULL)
				printf("Cannot parse\n");
			else if (a.q_host != NULL && a.q_host[0] != '\0')
				printf("mailer %s, host %s, user %s\n",
					a.q_mailer->m_name, a.q_host, a.q_user);
			else
				printf("mailer %s, user %s\n",
					a.q_mailer->m_name, a.q_user);
			e->e_to = NULL;
		}
		else
		{
			printf("Unknown \"/\" command %s\n", line);
		}
		return;
	}

	for (p = line; isascii(*p) && isspace(*p); p++)
		continue;
	q = p;
	while (*p != '\0' && !(isascii(*p) && isspace(*p)))
		p++;
	if (*p == '\0')
	{
		printf("No address!\n");
		return;
	}
	*p = '\0';
	if (invalidaddr(p + 1, NULL))
		return;
	do
	{
		register char **pvp;
		char pvpbuf[PSBUFSIZE];

		pvp = prescan(++p, ',', pvpbuf, sizeof pvpbuf,
			      &delimptr, NULL);
		if (pvp == NULL)
			continue;
		p = q;
		while (*p != '\0')
		{
			int stat;

			rs = strtorwset(p, NULL, ST_FIND);
			if (rs < 0)
			{
				printf("Undefined ruleset %s\n", p);
				break;
			}
			stat = rewrite(pvp, rs, 0, e);
			if (stat != EX_OK)
				printf("== Ruleset %s (%d) status %d\n",
					p, rs, stat);
			while (*p != '\0' && *p++ != ',')
				continue;
		}
	} while (*(p = delimptr) != '\0');
d1507 1
a1507 3
dump_class(s, id)
	register STAB *s;
	int id;
d1509 1
a1509 4
	if (s->s_type != ST_CLASS)
		return;
	if (bitnset(id & 0xff, s->s_class))
		printf("%s\n", s->s_name);
@

