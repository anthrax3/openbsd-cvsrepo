head	1.14;
access;
symbols
	OPENBSD_2_6:1.13.0.4
	OPENBSD_2_6_BASE:1.13
	OPENBSD_2_5:1.13.0.2
	OPENBSD_2_5_BASE:1.13
	OPENBSD_2_4:1.10.0.2
	OPENBSD_2_4_BASE:1.10
	sendmail_8_9_1:1.1.1.2
	UCB:1.1.1
	OPENBSD_2_3:1.9.0.2
	OPENBSD_2_3_BASE:1.9
	OPENBSD_2_2:1.8.0.2
	OPENBSD_2_2_BASE:1.8
	OPENBSD_2_1:1.6.0.2
	OPENBSD_2_1_BASE:1.6
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.14
date	2000.04.18.04.57.18;	author millert;	state dead;
branches;
next	1.13;

1.13
date	99.02.05.05.59.23;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	99.01.21.19.37.24;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	99.01.01.20.33.39;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	98.07.12.19.44.26;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	97.11.09.04.05.36;	author gene;	state Exp;
branches;
next	1.8;

1.8
date	97.08.04.02.17.48;	author downsj;	state Exp;
branches;
next	1.7;

1.7
date	97.07.15.07.24.00;	author downsj;	state Exp;
branches;
next	1.6;

1.6
date	97.01.22.01.07.03;	author downsj;	state Exp;
branches;
next	1.5;

1.5
date	96.12.14.21.17.07;	author downsj;	state Exp;
branches;
next	1.4;

1.4
date	96.10.01.23.07.18;	author michaels;	state Exp;
branches;
next	1.3;

1.3
date	96.09.19.06.44.53;	author fn;	state Exp;
branches;
next	1.2;

1.2
date	96.01.29.01.43.33;	author dm;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.48.17;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.48.17;	author deraadt;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	98.07.12.17.09.54;	author millert;	state Exp;
branches;
next	;


desc
@@


1.14
log
@remove sendmail 8.9.3
@
text
@/*
 * Copyright (c) 1998 Sendmail, Inc.  All rights reserved.
 * Copyright (c) 1983, 1995-1997 Eric P. Allman.  All rights reserved.
 * Copyright (c) 1988, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * By using this file, you agree to the terms and conditions set
 * forth in the LICENSE file which can be found at the top level of
 * the sendmail distribution.
 *
 */

#ifndef lint
static char sccsid[] = "@@(#)conf.c	8.452 (Berkeley) 1/26/1999";
#endif /* not lint */

# include "sendmail.h"
# include "pathnames.h"
# include <sys/ioctl.h>
# include <sys/param.h>
# include <limits.h>

/*
**  CONF.C -- Sendmail Configuration Tables.
**
**	Defines the configuration of this installation.
**
**	Configuration Variables:
**		HdrInfo -- a table describing well-known header fields.
**			Each entry has the field name and some flags,
**			which are described in sendmail.h.
**
**	Notes:
**		I have tried to put almost all the reasonable
**		configuration information into the configuration
**		file read at runtime.  My intent is that anything
**		here is a function of the version of UNIX you
**		are running, or is really static -- for example
**		the headers are a superset of widely used
**		protocols.  If you find yourself playing with
**		this file too much, you may be making a mistake!
*/


/*
**  Header info table
**	Final (null) entry contains the flags used for any other field.
**
**	Not all of these are actually handled specially by sendmail
**	at this time.  They are included as placeholders, to let
**	you know that "someday" I intend to have sendmail do
**	something with them.
*/

struct hdrinfo	HdrInfo[] =
{
		/* originator fields, most to least significant  */
	{ "resent-sender",		H_FROM|H_RESENT			},
	{ "resent-from",		H_FROM|H_RESENT			},
	{ "resent-reply-to",		H_FROM|H_RESENT			},
	{ "sender",			H_FROM				},
	{ "from",			H_FROM				},
	{ "reply-to",			H_FROM				},
	{ "errors-to",			H_FROM|H_ERRORSTO		},
	{ "full-name",			H_ACHECK			},
	{ "return-receipt-to",		H_RECEIPTTO			},

		/* destination fields */
	{ "to",				H_RCPT				},
	{ "resent-to",			H_RCPT|H_RESENT			},
	{ "cc",				H_RCPT				},
	{ "resent-cc",			H_RCPT|H_RESENT			},
	{ "bcc",			H_RCPT|H_BCC			},
	{ "resent-bcc",			H_RCPT|H_BCC|H_RESENT		},
	{ "apparently-to",		H_RCPT				},

		/* message identification and control */
	{ "message-id",			0				},
	{ "resent-message-id",		H_RESENT			},
	{ "message",			H_EOH				},
	{ "text",			H_EOH				},

		/* date fields */
	{ "date",			0				},
	{ "resent-date",		H_RESENT			},

		/* trace fields */
	{ "received",			H_TRACE|H_FORCE			},
	{ "x400-received",		H_TRACE|H_FORCE			},
	{ "via",			H_TRACE|H_FORCE			},
	{ "mail-from",			H_TRACE|H_FORCE			},

		/* miscellaneous fields */
	{ "comments",			H_FORCE|H_ENCODABLE		},
	{ "return-path",		H_FORCE|H_ACHECK		},
	{ "content-transfer-encoding",	H_CTE				},
	{ "content-type",		H_CTYPE				},
	{ "content-length",		H_ACHECK			},
	{ "subject",			H_ENCODABLE			},

	{ NULL,				0				}
};



/*
**  Privacy values
*/

struct prival PrivacyValues[] =
{
	{ "public",		PRIV_PUBLIC		},
	{ "needmailhelo",	PRIV_NEEDMAILHELO	},
	{ "needexpnhelo",	PRIV_NEEDEXPNHELO	},
	{ "needvrfyhelo",	PRIV_NEEDVRFYHELO	},
	{ "noexpn",		PRIV_NOEXPN		},
	{ "novrfy",		PRIV_NOVRFY		},
	{ "restrictmailq",	PRIV_RESTRICTMAILQ	},
	{ "restrictqrun",	PRIV_RESTRICTQRUN	},
	{ "noetrn",		PRIV_NOETRN		},
	{ "noverb",		PRIV_NOVERB		},
	{ "authwarnings",	PRIV_AUTHWARNINGS	},
	{ "noreceipts",		PRIV_NORECEIPTS		},
	{ "goaway",		PRIV_GOAWAY		},
	{ NULL,			0			}
};

/*
**  DontBlameSendmail values
*/
struct dbsval DontBlameSendmailValues[] =
{
	{ "safe",			DBS_SAFE			},
	{ "assumesafechown",		DBS_ASSUMESAFECHOWN		},
	{ "groupwritabledirpathsafe",	DBS_GROUPWRITABLEDIRPATHSAFE	},
	{ "groupwritableforwardfilesafe",
					DBS_GROUPWRITABLEFORWARDFILESAFE },
	{ "groupwritableincludefilesafe",
					DBS_GROUPWRITABLEINCLUDEFILESAFE },
	{ "groupwritablealiasfile",	DBS_GROUPWRITABLEALIASFILE	},
	{ "worldwritablealiasfile",	DBS_WORLDWRITABLEALIASFILE	},
	{ "forwardfileinunsafedirpath",	DBS_FORWARDFILEINUNSAFEDIRPATH	},
	{ "includefileinunsafedirpath",	DBS_INCLUDEFILEINUNSAFEDIRPATH	},
	{ "mapinunsafedirpath",		DBS_MAPINUNSAFEDIRPATH	},
	{ "linkedaliasfileinwritabledir",
					DBS_LINKEDALIASFILEINWRITABLEDIR },
	{ "linkedclassfileinwritabledir",
					DBS_LINKEDCLASSFILEINWRITABLEDIR },
	{ "linkedforwardfileinwritabledir",
					DBS_LINKEDFORWARDFILEINWRITABLEDIR },
	{ "linkedincludefileinwritabledir",
					DBS_LINKEDINCLUDEFILEINWRITABLEDIR },
	{ "linkedmapinwritabledir",	DBS_LINKEDMAPINWRITABLEDIR	},
	{ "linkedserviceswitchfileinwritabledir",
					DBS_LINKEDSERVICESWITCHFILEINWRITABLEDIR },
	{ "filedeliverytohardlink",	DBS_FILEDELIVERYTOHARDLINK	},
	{ "filedeliverytosymlink",	DBS_FILEDELIVERYTOSYMLINK	},
	{ "writemaptohardlink",		DBS_WRITEMAPTOHARDLINK		},
	{ "writemaptosymlink",		DBS_WRITEMAPTOSYMLINK		},
	{ "writestatstohardlink",	DBS_WRITESTATSTOHARDLINK	},
	{ "writestatstosymlink",	DBS_WRITESTATSTOSYMLINK		},
	{ "forwardfileingroupwritabledirpath",
					DBS_FORWARDFILEINGROUPWRITABLEDIRPATH },
	{ "includefileingroupwritabledirpath",
					DBS_INCLUDEFILEINGROUPWRITABLEDIRPATH },
	{ "classfileinunsafedirpath",	DBS_CLASSFILEINUNSAFEDIRPATH	},
	{ "errorheaderinunsafedirpath",	DBS_ERRORHEADERINUNSAFEDIRPATH	},
	{ "helpfileinunsafedirpath",	DBS_HELPFILEINUNSAFEDIRPATH	},
	{ "forwardfileinunsafedirpathsafe",
					DBS_FORWARDFILEINUNSAFEDIRPATHSAFE },
	{ "includefileinunsafedirpathsafe",
					DBS_INCLUDEFILEINUNSAFEDIRPATHSAFE },
	{ "runprograminunsafedirpath",	DBS_RUNPROGRAMINUNSAFEDIRPATH	},
	{ "runwritableprogram",		DBS_RUNWRITABLEPROGRAM		},
	{ NULL,				0				}
};


/*
**  Miscellaneous stuff.
*/

int	DtableSize =	50;		/* max open files; reset in 4.2bsd */
/*
**  SETDEFAULTS -- set default values
**
**	Because of the way freezing is done, these must be initialized
**	using direct code.
**
**	Parameters:
**		e -- the default envelope.
**
**	Returns:
**		none.
**
**	Side Effects:
**		Initializes a bunch of global variables to their
**		default values.
*/

#define MINUTES		* 60
#define HOURS		* 60 MINUTES
#define DAYS		* 24 HOURS

#ifndef _PATH_VARTMP
# define _PATH_VARTMP	"/usr/tmp/"
#endif

#ifndef MAXRULERECURSION
# define MAXRULERECURSION	50	/* max ruleset recursion depth */
#endif

void
setdefaults(e)
	register ENVELOPE *e;
{
	int i;
	struct passwd *pw;
	char buf[MAXNAME];
	extern void setdefuser __P((void));
	extern void setupmaps __P((void));
	extern void setupmailers __P((void));
	extern void setupheaders __P((void));

	SpaceSub = ' ';				/* option B */
	QueueLA = 8;				/* option x */
	RefuseLA = 12;				/* option X */
	WkRecipFact = 30000L;			/* option y */
	WkClassFact = 1800L;			/* option z */
	WkTimeFact = 90000L;			/* option Z */
	QueueFactor = WkRecipFact * 20;		/* option q */
	FileMode = (RealUid != geteuid()) ? 0644 : 0600;
						/* option F */

	if (((pw = getpwnam("mailnull")) != NULL && pw->pw_uid != 0) ||
	    ((pw = getpwnam("sendmail")) != NULL && pw->pw_uid != 0) ||
	    ((pw = getpwnam("daemon")) != NULL && pw->pw_uid != 0))
	{
		DefUid = pw->pw_uid;		/* option u */
		DefGid = pw->pw_gid;		/* option g */
		DefUser = newstr(pw->pw_name);
	}
	else
	{
		DefUid = 1;			/* option u */
		DefGid = 1;			/* option g */
		setdefuser();
	}
	TrustedUid = 0;
	if (tTd(37, 4))
		printf("setdefaults: DefUser=%s, DefUid=%d, DefGid=%d\n",
		       DefUser != NULL ? DefUser : "<1:1>",
		       (int) DefUid, (int) DefGid);
	CheckpointInterval = 10;		/* option C */
	MaxHopCount = 25;			/* option h */
	e->e_sendmode = SM_FORK;		/* option d */
	e->e_errormode = EM_PRINT;		/* option e */
	SevenBitInput = FALSE;			/* option 7 */
	MaxMciCache = 1;			/* option k */
	MciCacheTimeout = 5 MINUTES;		/* option K */
	LogLevel = 9;				/* option L */
	inittimeouts(NULL);			/* option r */
	PrivacyFlags = PRIV_PUBLIC;		/* option p */
	DontBlameSendmail = DBS_SAFE;		/* DontBlameSendmail option */
#if MIME8TO7
	MimeMode = MM_CVTMIME|MM_PASS8BIT;	/* option 8 */
#else
	MimeMode = MM_PASS8BIT;
#endif
	for (i = 0; i < MAXTOCLASS; i++)
	{
		TimeOuts.to_q_return[i] = 5 DAYS;	/* option T */
		TimeOuts.to_q_warning[i] = 0;		/* option T */
	}
	ServiceSwitchFile = "/etc/service.switch";
	ServiceCacheMaxAge = (time_t) 10;
	HostsFile = _PATH_HOSTS;
	PidFile = newstr(_PATH_SENDMAILPID);
	MustQuoteChars = "@@,;:\\()[].'";
	MciInfoTimeout = 30 MINUTES;
	MaxRuleRecursion = MAXRULERECURSION;
	MaxAliasRecursion = 10;
	MaxMacroRecursion = 10;
	ColonOkInAddr = TRUE;
	DontLockReadFiles = TRUE;
	DoubleBounceAddr = "postmaster";
	MaxHeadersLength = MAXHDRSLEN;
	snprintf(buf, sizeof buf, "%s%sdead.letter",
		_PATH_VARTMP,
		_PATH_VARTMP[sizeof _PATH_VARTMP - 2] == '/' ? "" : "/");
	DeadLetterDrop = newstr(buf);
#ifdef HESIOD_INIT
	HesiodContext = NULL;
#endif
	ControlSocketName = NULL;
	setupmaps();
	setupmailers();
	setupheaders();
}


/*
**  SETDEFUSER -- set/reset DefUser using DefUid (for initgroups())
*/

void
setdefuser()
{
	struct passwd *defpwent;
	static char defuserbuf[40];

	DefUser = defuserbuf;
	defpwent = sm_getpwuid(DefUid);
	snprintf(defuserbuf, sizeof defuserbuf, "%s",
		defpwent == NULL ? "nobody" : defpwent->pw_name);
	if (tTd(37, 4))
		printf("setdefuser: DefUid=%d, DefUser=%s\n",
		       (int) DefUid, DefUser);
}
/*
**  SETUPMAILERS -- initialize default mailers
*/

void
setupmailers()
{
	char buf[100];

	strcpy(buf, "prog, P=/bin/sh, F=lsoDq9, T=DNS/RFC822/X-Unix, A=sh -c \201u");
	makemailer(buf);

	strcpy(buf, "*file*, P=[FILE], F=lsDFMPEouq9, T=DNS/RFC822/X-Unix, A=FILE \201u");
	makemailer(buf);

	strcpy(buf, "*include*, P=/dev/null, F=su, A=INCLUDE \201u");
	makemailer(buf);
}
/*
**  SETUPMAPS -- set up map classes
*/

#define MAPDEF(name, ext, flags, parse, open, close, lookup, store) \
	{ \
		extern bool parse __P((MAP *, char *)); \
		extern bool open __P((MAP *, int)); \
		extern void close __P((MAP *)); \
		extern char *lookup __P((MAP *, char *, char **, int *)); \
		extern void store __P((MAP *, char *, char *)); \
		s = stab(name, ST_MAPCLASS, ST_ENTER); \
		s->s_mapclass.map_cname = name; \
		s->s_mapclass.map_ext = ext; \
		s->s_mapclass.map_cflags = flags; \
		s->s_mapclass.map_parse = parse; \
		s->s_mapclass.map_open = open; \
		s->s_mapclass.map_close = close; \
		s->s_mapclass.map_lookup = lookup; \
		s->s_mapclass.map_store = store; \
	}

void
setupmaps()
{
	register STAB *s;

#ifdef NEWDB
	MAPDEF("hash", ".db", MCF_ALIASOK|MCF_REBUILDABLE,
		map_parseargs, hash_map_open, db_map_close,
		db_map_lookup, db_map_store);

	MAPDEF("btree", ".db", MCF_ALIASOK|MCF_REBUILDABLE,
		map_parseargs, bt_map_open, db_map_close,
		db_map_lookup, db_map_store);
#endif

#ifdef NDBM
	MAPDEF("dbm", ".dir", MCF_ALIASOK|MCF_REBUILDABLE,
		map_parseargs, ndbm_map_open, ndbm_map_close,
		ndbm_map_lookup, ndbm_map_store);
#endif

#ifdef NIS
	MAPDEF("nis", NULL, MCF_ALIASOK,
		map_parseargs, nis_map_open, null_map_close,
		nis_map_lookup, null_map_store);
#endif

#ifdef NISPLUS
	MAPDEF("nisplus", NULL, MCF_ALIASOK,
		map_parseargs, nisplus_map_open, null_map_close,
		nisplus_map_lookup, null_map_store);
#endif
#ifdef LDAPMAP
	MAPDEF("ldapx", NULL, 0,
		ldap_map_parseargs, ldap_map_open, ldap_map_close,
		ldap_map_lookup, null_map_store);
#endif

#ifdef HESIOD
	MAPDEF("hesiod", NULL, MCF_ALIASOK|MCF_ALIASONLY,
		map_parseargs, hes_map_open, null_map_close,
		hes_map_lookup, null_map_store);
#endif

#if NETINFO
	MAPDEF("netinfo", NULL, MCF_ALIASOK,
		map_parseargs, ni_map_open, null_map_close,
		ni_map_lookup, null_map_store);
#endif

#if 0
	MAPDEF("dns", NULL, 0,
		dns_map_init, null_map_open, null_map_close,
		dns_map_lookup, null_map_store);
#endif

#if NAMED_BIND
	/* best MX DNS lookup */
	MAPDEF("bestmx", NULL, MCF_OPTFILE,
		map_parseargs, null_map_open, null_map_close,
		bestmx_map_lookup, null_map_store);
#endif

	MAPDEF("host", NULL, 0,
		host_map_init, null_map_open, null_map_close,
		host_map_lookup, null_map_store);

	MAPDEF("text", NULL, MCF_ALIASOK,
		map_parseargs, text_map_open, null_map_close,
		text_map_lookup, null_map_store);

	MAPDEF("stab", NULL, MCF_ALIASOK|MCF_ALIASONLY,
		map_parseargs, stab_map_open, null_map_close,
		stab_map_lookup, stab_map_store);

	MAPDEF("implicit", NULL, MCF_ALIASOK|MCF_ALIASONLY|MCF_REBUILDABLE,
		map_parseargs, impl_map_open, impl_map_close,
		impl_map_lookup, impl_map_store);

	/* access to system passwd file */
	MAPDEF("user", NULL, MCF_OPTFILE,
		map_parseargs, user_map_open, null_map_close,
		user_map_lookup, null_map_store);

	/* dequote map */
	MAPDEF("dequote", NULL, 0,
		dequote_init, null_map_open, null_map_close,
		dequote_map, null_map_store);

#ifdef MAP_REGEX
	MAPDEF("regex", NULL, 0,
		regex_map_init, null_map_open, null_map_close,
		regex_map_lookup, null_map_store);
#endif

#if USERDB
	/* user database */
	MAPDEF("userdb", ".db", 0,
		map_parseargs, null_map_open, null_map_close,
		udb_map_lookup, null_map_store);
#endif

	/* arbitrary programs */
	MAPDEF("program", NULL, MCF_ALIASOK,
		map_parseargs, null_map_open, null_map_close,
		prog_map_lookup, null_map_store);

	/* sequenced maps */
	MAPDEF("sequence", NULL, MCF_ALIASOK,
		seq_map_parse, null_map_open, null_map_close,
		seq_map_lookup, seq_map_store);

	/* switched interface to sequenced maps */
	MAPDEF("switch", NULL, MCF_ALIASOK,
		map_parseargs, switch_map_open, null_map_close,
		seq_map_lookup, seq_map_store);

	/* null map lookup -- really for internal use only */
	MAPDEF("null", NULL, MCF_ALIASOK|MCF_OPTFILE,
		map_parseargs, null_map_open, null_map_close,
		null_map_lookup, null_map_store);

#if _FFR_MAP_SYSLOG
	/* syslog map -- logs information to syslog */
	MAPDEF("syslog", NULL, 0,
	       syslog_map_parseargs, null_map_open, null_map_close,
	       syslog_map_lookup, null_map_store);
#endif
}

#undef MAPDEF
/*
**  INITHOSTMAPS -- initial host-dependent maps
**
**	This should act as an interface to any local service switch
**	provided by the host operating system.
**
**	Parameters:
**		none
**
**	Returns:
**		none
**
**	Side Effects:
**		Should define maps "host" and "users" as necessary
**		for this OS.  If they are not defined, they will get
**		a default value later.  It should check to make sure
**		they are not defined first, since it's possible that
**		the config file has provided an override.
*/

void
inithostmaps()
{
	register int i;
	int nmaps;
	char *maptype[MAXMAPSTACK];
	short mapreturn[MAXMAPACTIONS];
	char buf[MAXLINE];

	/*
	**  Set up default hosts maps.
	*/

#if 0
	nmaps = switch_map_find("hosts", maptype, mapreturn);
	for (i = 0; i < nmaps; i++)
	{
		if (strcmp(maptype[i], "files") == 0 &&
		    stab("hosts.files", ST_MAP, ST_FIND) == NULL)
		{
			strcpy(buf, "hosts.files text -k 0 -v 1 /etc/hosts");
			(void) makemapentry(buf);
		}
#if NAMED_BIND
		else if (strcmp(maptype[i], "dns") == 0 &&
		    stab("hosts.dns", ST_MAP, ST_FIND) == NULL)
		{
			strcpy(buf, "hosts.dns dns A");
			(void) makemapentry(buf);
		}
#endif
#ifdef NISPLUS
		else if (strcmp(maptype[i], "nisplus") == 0 &&
		    stab("hosts.nisplus", ST_MAP, ST_FIND) == NULL)
		{
			strcpy(buf, "hosts.nisplus nisplus -k name -v address -d hosts.org_dir");
			(void) makemapentry(buf);
		}
#endif
#ifdef NIS
		else if (strcmp(maptype[i], "nis") == 0 &&
		    stab("hosts.nis", ST_MAP, ST_FIND) == NULL)
		{
			strcpy(buf, "hosts.nis nis -d -k 0 -v 1 hosts.byname");
			(void) makemapentry(buf);
		}
#endif
#if NETINFO
		else if (strcmp(maptype[i], "netinfo") == 0) &&
		    stab("hosts.netinfo", ST_MAP, ST_FIND) == NULL)
		{
			strcpy(buf, "hosts.netinfo netinfo -v name /machines");
			(void) makemapentry(buf);
		}
#endif
	}
#endif

	/*
	**  Make sure we have a host map.
	*/

	if (stab("host", ST_MAP, ST_FIND) == NULL)
	{
		/* user didn't initialize: set up host map */
		strcpy(buf, "host host");
#if NAMED_BIND
		if (ConfigLevel >= 2)
			strcat(buf, " -a.");
#endif
		(void) makemapentry(buf);
	}

	/*
	**  Set up default aliases maps
	*/

	nmaps = switch_map_find("aliases", maptype, mapreturn);
	for (i = 0; i < nmaps; i++)
	{
		if (strcmp(maptype[i], "files") == 0 &&
		    stab("aliases.files", ST_MAP, ST_FIND) == NULL)
		{
			strcpy(buf, "aliases.files null");
			(void) makemapentry(buf);
		}
#ifdef NISPLUS
		else if (strcmp(maptype[i], "nisplus") == 0 &&
		    stab("aliases.nisplus", ST_MAP, ST_FIND) == NULL)
		{
			strcpy(buf, "aliases.nisplus nisplus -kalias -vexpansion -d mail_aliases.org_dir");
			(void) makemapentry(buf);
		}
#endif
#ifdef NIS
		else if (strcmp(maptype[i], "nis") == 0 &&
		    stab("aliases.nis", ST_MAP, ST_FIND) == NULL)
		{
			strcpy(buf, "aliases.nis nis -d mail.aliases");
			(void) makemapentry(buf);
		}
#endif
#ifdef NETINFO
		else if (strcmp(maptype[i], "netinfo") == 0 &&
		    stab("aliases.netinfo", ST_MAP, ST_FIND) == NULL)
		{
			strcpy(buf, "aliases.netinfo netinfo -z, /aliases");
			(void) makemapentry(buf);
		}
#endif
#ifdef HESIOD
		else if (strcmp(maptype[i], "hesiod") == 0 &&
		    stab("aliases.hesiod", ST_MAP, ST_FIND) == NULL)
		{
			strcpy(buf, "aliases.hesiod hesiod aliases");
			(void) makemapentry(buf);
		}
#endif
	}
	if (stab("aliases", ST_MAP, ST_FIND) == NULL)
	{
		strcpy(buf, "aliases switch aliases");
		(void) makemapentry(buf);
	}

#if 0		/* "user" map class is a better choice */
	/*
	**  Set up default users maps.
	*/

	nmaps = switch_map_find("passwd", maptype, mapreturn);
	for (i = 0; i < nmaps; i++)
	{
		if (strcmp(maptype[i], "files") == 0 &&
		    stab("users.files", ST_MAP, ST_FIND) == NULL)
		{
			strcpy(buf, "users.files text -m -z: -k0 -v6 /etc/passwd");
			(void) makemapentry(buf);
		}
#ifdef NISPLUS
		else if (strcmp(maptype[i], "nisplus") == 0 &&
		    stab("users.nisplus", ST_MAP, ST_FIND) == NULL)
		{
			strcpy(buf, "users.nisplus nisplus -m -kname -vhome -d passwd.org_dir");
			(void) makemapentry(buf);
		}
#endif
#ifdef NIS
		else if (strcmp(maptype[i], "nis") == 0 &&
		    stab("users.nis", ST_MAP, ST_FIND) == NULL)
		{
			strcpy(buf, "users.nis nis -m -d passwd.byname");
			(void) makemapentry(buf);
		}
#endif
#ifdef HESIOD
		else if (strcmp(maptype[i], "hesiod") == 0) &&
		    stab("users.hesiod", ST_MAP, ST_FIND) == NULL)
		{
			strcpy(buf, "users.hesiod hesiod");
			(void) makemapentry(buf);
		}
#endif
	}
	if (stab("users", ST_MAP, ST_FIND) == NULL)
	{
		strcpy(buf, "users switch -m passwd");
		(void) makemapentry(buf);
	}
#endif
}
/*
**  SWITCH_MAP_FIND -- find the list of types associated with a map
**
**	This is the system-dependent interface to the service switch.
**
**	Parameters:
**		service -- the name of the service of interest.
**		maptype -- an out-array of strings containing the types
**			of access to use for this service.  There can
**			be at most MAXMAPSTACK types for a single service.
**		mapreturn -- an out-array of return information bitmaps
**			for the map.
**
**	Returns:
**		The number of map types filled in, or -1 for failure.
*/

#if defined(SOLARIS) || (defined(sony_news) && defined(__svr4))
# define _USE_SUN_NSSWITCH_
#endif

#ifdef _USE_SUN_NSSWITCH_
# include <nsswitch.h>
#endif

#if defined(ultrix) || (defined(__osf__) && defined(__alpha))
# define _USE_DEC_SVC_CONF_
#endif

#ifdef _USE_DEC_SVC_CONF_
# include <sys/svcinfo.h>
#endif

int
switch_map_find(service, maptype, mapreturn)
	char *service;
	char *maptype[MAXMAPSTACK];
	short mapreturn[MAXMAPACTIONS];
{
	int svcno;

#ifdef _USE_SUN_NSSWITCH_
	struct __nsw_switchconfig *nsw_conf;
	enum __nsw_parse_err pserr;
	struct __nsw_lookup *lk;
	static struct __nsw_lookup lkp0 =
		{ "files", {1, 0, 0, 0}, NULL, NULL };
	static struct __nsw_switchconfig lkp_default =
		{ 0, "sendmail", 3, &lkp0 };

	for (svcno = 0; svcno < MAXMAPACTIONS; svcno++)
		mapreturn[svcno] = 0;

	if ((nsw_conf = __nsw_getconfig(service, &pserr)) == NULL)
		lk = lkp_default.lookups;
	else
		lk = nsw_conf->lookups;
	svcno = 0;
	while (lk != NULL)
	{
		maptype[svcno] = lk->service_name;
		if (lk->actions[__NSW_NOTFOUND] == __NSW_RETURN)
			mapreturn[MA_NOTFOUND] |= 1 << svcno;
		if (lk->actions[__NSW_TRYAGAIN] == __NSW_RETURN)
			mapreturn[MA_TRYAGAIN] |= 1 << svcno;
		if (lk->actions[__NSW_UNAVAIL] == __NSW_RETURN)
			mapreturn[MA_TRYAGAIN] |= 1 << svcno;
		svcno++;
		lk = lk->next;
	}
	return svcno;
#endif

#ifdef _USE_DEC_SVC_CONF_
	struct svcinfo *svcinfo;
	int svc;

	for (svcno = 0; svcno < MAXMAPACTIONS; svcno++)
		mapreturn[svcno] = 0;

	svcinfo = getsvc();
	if (svcinfo == NULL)
		goto punt;
	if (strcmp(service, "hosts") == 0)
		svc = SVC_HOSTS;
	else if (strcmp(service, "aliases") == 0)
		svc = SVC_ALIASES;
	else if (strcmp(service, "passwd") == 0)
		svc = SVC_PASSWD;
	else
		return -1;
	for (svcno = 0; svcno < SVC_PATHSIZE; svcno++)
	{
		switch (svcinfo->svcpath[svc][svcno])
		{
		  case SVC_LOCAL:
			maptype[svcno] = "files";
			break;

		  case SVC_YP:
			maptype[svcno] = "nis";
			break;

		  case SVC_BIND:
			maptype[svcno] = "dns";
			break;

#ifdef SVC_HESIOD
		  case SVC_HESIOD:
			maptype[svcno] = "hesiod";
			break;
#endif

		  case SVC_LAST:
			return svcno;
		}
	}
	return svcno;
#endif

#if !defined(_USE_SUN_NSSWITCH_) && !defined(_USE_DEC_SVC_CONF_)
	/*
	**  Fall-back mechanism.
	*/

	STAB *st;
	time_t now = curtime();

	for (svcno = 0; svcno < MAXMAPACTIONS; svcno++)
		mapreturn[svcno] = 0;

	if ((now - ServiceCacheTime) > (time_t) ServiceCacheMaxAge)
	{
		/* (re)read service switch */
		register FILE *fp;
		int sff = SFF_REGONLY|SFF_OPENASROOT|SFF_NOLOCK;

		if (!bitset(DBS_LINKEDSERVICESWITCHFILEINWRITABLEDIR, DontBlameSendmail))
			sff |= SFF_NOWLINK;

		if (ConfigFileRead)
			ServiceCacheTime = now;
		fp = safefopen(ServiceSwitchFile, O_RDONLY, 0, sff);
		if (fp != NULL)
		{
			char buf[MAXLINE];

			while (fgets(buf, sizeof buf, fp) != NULL)
			{
				register char *p;

				p = strpbrk(buf, "#\n");
				if (p != NULL)
					*p = '\0';
				p = strpbrk(buf, " \t");
				if (p != NULL)
					*p++ = '\0';
				if (buf[0] == '\0')
					continue;
				if (p == NULL)
				{
					sm_syslog(LOG_ERR, NOQID,
						  "Bad line on %.100s: %.100s",
						  ServiceSwitchFile,
						  buf);
					continue;
				}
				while (isspace(*p))
					p++;
				if (*p == '\0')
					continue;

				/*
				**  Find/allocate space for this service entry.
				**	Space for all of the service strings
				**	are allocated at once.  This means
				**	that we only have to free the first
				**	one to free all of them.
				*/

				st = stab(buf, ST_SERVICE, ST_ENTER);
				if (st->s_service[0] != NULL)
					free((void *) st->s_service[0]);
				p = newstr(p);
				for (svcno = 0; svcno < MAXMAPSTACK; )
				{
					if (*p == '\0')
						break;
					st->s_service[svcno++] = p;
					p = strpbrk(p, " \t");
					if (p == NULL)
						break;
					*p++ = '\0';
					while (isspace(*p))
						p++;
				}
				if (svcno < MAXMAPSTACK)
					st->s_service[svcno] = NULL;
			}
			fclose(fp);
		}
	}

	/* look up entry in cache */
	st = stab(service, ST_SERVICE, ST_FIND);
	if (st != NULL && st->s_service[0] != NULL)
	{
		/* extract data */
		svcno = 0;
		while (svcno < MAXMAPSTACK)
		{
			maptype[svcno] = st->s_service[svcno];
			if (maptype[svcno++] == NULL)
				break;
		}
		return --svcno;
	}
#endif

#if !defined(_USE_SUN_NSSWITCH_)
	/* if the service file doesn't work, use an absolute fallback */
# ifdef _USE_DEC_SVC_CONF_
  punt:
# endif
	for (svcno = 0; svcno < MAXMAPACTIONS; svcno++)
		mapreturn[svcno] = 0;
	svcno = 0;
	if (strcmp(service, "aliases") == 0)
	{
		maptype[svcno++] = "files";
# ifdef AUTO_NIS_ALIASES
#  ifdef NISPLUS
		maptype[svcno++] = "nisplus";
#  endif
#  ifdef NIS
		maptype[svcno++] = "nis";
#  endif
# endif
		return svcno;
	}
	if (strcmp(service, "hosts") == 0)
	{
#  if NAMED_BIND
		maptype[svcno++] = "dns";
#  else
#   if defined(sun) && !defined(BSD)
		/* SunOS */
		maptype[svcno++] = "nis";
#   endif
#  endif
		maptype[svcno++] = "files";
		return svcno;
	}
	return -1;
#endif
}
/*
**  USERNAME -- return the user id of the logged in user.
**
**	Parameters:
**		none.
**
**	Returns:
**		The login name of the logged in user.
**
**	Side Effects:
**		none.
**
**	Notes:
**		The return value is statically allocated.
*/

char *
username()
{
	static char *myname = NULL;
	extern char *getlogin();
	register struct passwd *pw;

	/* cache the result */
	if (myname == NULL)
	{
		myname = getlogin();
		if (myname == NULL || myname[0] == '\0')
		{
			pw = sm_getpwuid(RealUid);
			if (pw != NULL)
				myname = newstr(pw->pw_name);
		}
		else
		{
			uid_t uid = RealUid;

			myname = newstr(myname);
			if ((pw = sm_getpwnam(myname)) == NULL ||
			      (uid != 0 && uid != pw->pw_uid))
			{
				pw = sm_getpwuid(uid);
				if (pw != NULL)
					myname = newstr(pw->pw_name);
			}
		}
		if (myname == NULL || myname[0] == '\0')
		{
			syserr("554 Who are you?");
			myname = "postmaster";
		}
	}

	return (myname);
}
/*
**  TTYPATH -- Get the path of the user's tty
**
**	Returns the pathname of the user's tty.  Returns NULL if
**	the user is not logged in or if s/he has write permission
**	denied.
**
**	Parameters:
**		none
**
**	Returns:
**		pathname of the user's tty.
**		NULL if not logged in or write permission denied.
**
**	Side Effects:
**		none.
**
**	WARNING:
**		Return value is in a local buffer.
**
**	Called By:
**		savemail
*/

char *
ttypath()
{
	struct stat stbuf;
	register char *pathn;
	extern char *ttyname();
	extern char *getlogin();

	/* compute the pathname of the controlling tty */
	if ((pathn = ttyname(2)) == NULL && (pathn = ttyname(1)) == NULL &&
	    (pathn = ttyname(0)) == NULL)
	{
		errno = 0;
		return (NULL);
	}

	/* see if we have write permission */
	if (stat(pathn, &stbuf) < 0 || !bitset(S_IWOTH, stbuf.st_mode))
	{
		errno = 0;
		return (NULL);
	}

	/* see if the user is logged in */
	if (getlogin() == NULL)
		return (NULL);

	/* looks good */
	return (pathn);
}
/*
**  CHECKCOMPAT -- check for From and To person compatible.
**
**	This routine can be supplied on a per-installation basis
**	to determine whether a person is allowed to send a message.
**	This allows restriction of certain types of internet
**	forwarding or registration of users.
**
**	If the hosts are found to be incompatible, an error
**	message should be given using "usrerr" and an EX_ code
**	should be returned.  You can also set to->q_status to
**	a DSN-style status code.
**
**	EF_NO_BODY_RETN can be set in e->e_flags to suppress the
**	body during the return-to-sender function; this should be done
**	on huge messages.  This bit may already be set by the ESMTP
**	protocol.
**
**	Parameters:
**		to -- the person being sent to.
**
**	Returns:
**		an exit status
**
**	Side Effects:
**		none (unless you include the usrerr stuff)
*/

int
checkcompat(to, e)
	register ADDRESS *to;
	register ENVELOPE *e;
{
# ifdef lint
	if (to == NULL)
		to++;
# endif /* lint */

	if (tTd(49, 1))
		printf("checkcompat(to=%s, from=%s)\n",
			to->q_paddr, e->e_from.q_paddr);

# ifdef EXAMPLE_CODE
	/* this code is intended as an example only */
	register STAB *s;

	s = stab("arpa", ST_MAILER, ST_FIND);
	if (s != NULL && strcmp(e->e_from.q_mailer->m_name, "local") != 0 &&
	    to->q_mailer == s->s_mailer)
	{
		usrerr("553 No ARPA mail through this machine: see your system administration");
		/* e->e_flags |= EF_NO_BODY_RETN; to supress body on return */
		to->q_status = "5.7.1";
		return (EX_UNAVAILABLE);
	}
# endif /* EXAMPLE_CODE */
	return (EX_OK);
}
/*
**  SETSIGNAL -- set a signal handler
**
**	This is essentially old BSD "signal(3)".
*/

sigfunc_t
setsignal(sig, handler)
	int sig;
	sigfunc_t handler;
{
#if defined(SYS5SIGNALS) || defined(BSD4_3)
# ifdef BSD4_3
	return signal(sig, handler);
# else
	return sigset(sig, handler);
# endif
#else
	struct sigaction n, o;

	bzero(&n, sizeof n);
# if USE_SA_SIGACTION
	n.sa_sigaction = (void(*)(int, siginfo_t *, void *)) handler;
	n.sa_flags = SA_RESTART|SA_SIGINFO;
# else
	n.sa_handler = handler;
#  ifdef SA_RESTART
	n.sa_flags = SA_RESTART;
#  endif
# endif
	if (sigaction(sig, &n, &o) < 0)
		return SIG_ERR;
	return o.sa_handler;
#endif
}
/*
**  BLOCKSIGNAL -- hold a signal to prevent delivery
**
**	Parameters:
**		sig -- the signal to block.
**
**	Returns:
**		1 signal was previously blocked
**		0 signal was not previously blocked
**		-1 on failure.
*/

int
blocksignal(sig)
	int sig;
{
#ifdef BSD4_3
# ifndef sigmask
#  define sigmask(s)	(1 << ((s) - 1))
# endif
	return (sigblock(sigmask(sig)) & sigmask(sig)) != 0;
#else
# ifdef ALTOS_SYSTEM_V
	sigfunc_t handler;

	handler = sigset(sig, SIG_HOLD);
	if (handler == SIG_ERR)
		return -1;
	else
		return handler == SIG_HOLD;
# else
	sigset_t sset, oset;

	sigemptyset(&sset);
	sigaddset(&sset, sig);
	if (sigprocmask(SIG_BLOCK, &sset, &oset) < 0)
		return -1;
	else
		return sigismember(&oset, sig);
# endif
#endif
}
/*
**  RELEASESIGNAL -- release a held signal
**
**	Parameters:
**		sig -- the signal to release.
**
**	Returns:
**		1 signal was previously blocked
**		0 signal was not previously blocked
**		-1 on failure.
*/

int
releasesignal(sig)
	int sig;
{
#ifdef BSD4_3
	return (sigsetmask(sigblock(0) & ~sigmask(sig)) & sigmask(sig)) != 0;
#else
# ifdef ALTOS_SYSTEM_V
	sigfunc_t handler;

	handler = sigset(sig, SIG_HOLD);
	if (sigrelse(sig) < 0)
		return -1;
	else
		return handler == SIG_HOLD;
# else
	sigset_t sset, oset;

	sigemptyset(&sset);
	sigaddset(&sset, sig);
	if (sigprocmask(SIG_UNBLOCK, &sset, &oset) < 0)
		return -1;
	else
		return sigismember(&oset, sig);
# endif
#endif
}
/*
**  HOLDSIGS -- arrange to hold all signals
**
**	Parameters:
**		none.
**
**	Returns:
**		none.
**
**	Side Effects:
**		Arranges that signals are held.
*/

void
holdsigs()
{
}
/*
**  RLSESIGS -- arrange to release all signals
**
**	This undoes the effect of holdsigs.
**
**	Parameters:
**		none.
**
**	Returns:
**		none.
**
**	Side Effects:
**		Arranges that signals are released.
*/

void
rlsesigs()
{
}
/*
**  INIT_MD -- do machine dependent initializations
**
**	Systems that have global modes that should be set should do
**	them here rather than in main.
*/

#ifdef _AUX_SOURCE
# include <compat.h>
#endif

#if SHARE_V1
# include <shares.h>
#endif

void
init_md(argc, argv)
	int argc;
	char **argv;
{
#ifdef _AUX_SOURCE
	setcompat(getcompat() | COMPAT_BSDPROT);
#endif

#ifdef SUN_EXTENSIONS
	init_md_sun();
#endif

#if _CONVEX_SOURCE
	/* keep gethostby*() from stripping the local domain name */
	set_domain_trim_off();
#endif
#ifdef __QNX__
	/*
	**  Due to QNX's network distributed nature, you can target a tcpip
	**  stack on a different node in the qnx network; this patch lets
	**  this feature work.  The __sock_locate() must be done before the
	**  environment is clear.
	*/
	__sock_locate();
#endif
#if SECUREWARE || defined(_SCO_unix_)
	set_auth_parameters(argc, argv);

# ifdef _SCO_unix_
	/*
	**  This is required for highest security levels (the kernel
	**  won't let it call set*uid() or run setuid binaries without
	**  it).  It may be necessary on other SECUREWARE systems.
	*/

	if (getluid() == -1)
		setluid(0);
# endif
#endif

#ifdef VENDOR_DEFAULT
	VendorCode = VENDOR_DEFAULT;
#else
	VendorCode = VENDOR_BERKELEY;
#endif
}
/*
**  INIT_VENDOR_MACROS -- vendor-dependent macro initializations
**
**	Called once, on startup.
**
**	Parameters:
**		e -- the global envelope.
**
**	Returns:
**		none.
**
**	Side Effects:
**		vendor-dependent.
*/

void
init_vendor_macros(e)
	register ENVELOPE *e;
{
}
/*
**  GETLA -- get the current load average
**
**	This code stolen from la.c.
**
**	Parameters:
**		none.
**
**	Returns:
**		The current load average as an integer.
**
**	Side Effects:
**		none.
*/

/* try to guess what style of load average we have */
#define LA_ZERO		1	/* always return load average as zero */
#define LA_INT		2	/* read kmem for avenrun; interpret as long */
#define LA_FLOAT	3	/* read kmem for avenrun; interpret as float */
#define LA_SUBR		4	/* call getloadavg */
#define LA_MACH		5	/* MACH load averages (as on NeXT boxes) */
#define LA_SHORT	6	/* read kmem for avenrun; interpret as short */
#define LA_PROCSTR	7	/* read string ("1.17") from /proc/loadavg */
#define LA_READKSYM	8	/* SVR4: use MIOC_READKSYM ioctl call */
#define LA_DGUX		9	/* special DGUX implementation */
#define LA_HPUX		10	/* special HPUX implementation */
#define LA_IRIX6	11	/* special IRIX 6.2 implementation */
#define LA_KSTAT	12	/* special Solaris kstat(3k) implementation */
#define LA_DEVSHORT	13	/* read short from a device */
#define LA_ALPHAOSF	14	/* Digital UNIX (OSF/1 on Alpha) table() call */

/* do guesses based on general OS type */
#ifndef LA_TYPE
# define LA_TYPE	LA_ZERO
#endif

#ifndef FSHIFT
# if defined(unixpc)
#  define FSHIFT	5
# endif

# if defined(__alpha) || defined(IRIX)
#  define FSHIFT	10
# endif

#endif

#ifndef FSHIFT
# define FSHIFT		8
#endif

#ifndef FSCALE
# define FSCALE		(1 << FSHIFT)
#endif

#ifndef LA_AVENRUN
# ifdef SYSTEM5
#  define LA_AVENRUN	"avenrun"
# else
#  define LA_AVENRUN	"_avenrun"
# endif
#endif

/* _PATH_KMEM should be defined in <paths.h> */
#ifndef _PATH_KMEM
# define _PATH_KMEM	"/dev/kmem"
#endif

#if (LA_TYPE == LA_INT) || (LA_TYPE == LA_FLOAT) || (LA_TYPE == LA_SHORT)

#include <nlist.h>

/* _PATH_UNIX should be defined in <paths.h> */
#ifndef _PATH_UNIX
# if defined(SYSTEM5)
#  define _PATH_UNIX	"/unix"
# else
#  define _PATH_UNIX	"/vmunix"
# endif
#endif

#ifdef _AUX_SOURCE
struct nlist	Nl[2];
#else
struct nlist	Nl[] =
{
	{ LA_AVENRUN },
	{ 0 },
};
#endif
#define	X_AVENRUN	0

int
getla()
{
	static int kmem = -1;
#if LA_TYPE == LA_INT
	long avenrun[3];
#else
# if LA_TYPE == LA_SHORT
	short avenrun[3];
# else
	double avenrun[3];
# endif
#endif
	extern int errno;
	extern off_t lseek();

	if (kmem < 0)
	{
#ifdef _AUX_SOURCE
		strcpy(Nl[X_AVENRUN].n_name, LA_AVENRUN);
		Nl[1].n_name[0] = '\0';
#endif

#if defined(_AIX3) || defined(_AIX4)
		if (knlist(Nl, 1, sizeof Nl[0]) < 0)
#else
		if (nlist(_PATH_UNIX, Nl) < 0)
#endif
		{
			if (tTd(3, 1))
				printf("getla: nlist(%s): %s\n", _PATH_UNIX,
					errstring(errno));
			return (-1);
		}
		if (Nl[X_AVENRUN].n_value == 0)
		{
			if (tTd(3, 1))
				printf("getla: nlist(%s, %s) ==> 0\n",
					_PATH_UNIX, LA_AVENRUN);
			return (-1);
		}
#ifdef NAMELISTMASK
		Nl[X_AVENRUN].n_value &= NAMELISTMASK;
#endif

		kmem = open(_PATH_KMEM, 0, 0);
		if (kmem < 0)
		{
			if (tTd(3, 1))
				printf("getla: open(/dev/kmem): %s\n",
					errstring(errno));
			return (-1);
		}
		(void) fcntl(kmem, F_SETFD, 1);
	}
	if (tTd(3, 20))
		printf("getla: symbol address = %#lx\n",
			(u_long) Nl[X_AVENRUN].n_value);
	if (lseek(kmem, (off_t) Nl[X_AVENRUN].n_value, SEEK_SET) == -1 ||
	    read(kmem, (char *) avenrun, sizeof(avenrun)) < sizeof(avenrun))
	{
		/* thank you Ian */
		if (tTd(3, 1))
			printf("getla: lseek or read: %s\n", errstring(errno));
		return (-1);
	}
# if (LA_TYPE == LA_INT) || (LA_TYPE == LA_SHORT)
	if (tTd(3, 5))
	{
#  if LA_TYPE == LA_SHORT
		printf("getla: avenrun = %d", avenrun[0]);
		if (tTd(3, 15))
			printf(", %d, %d", avenrun[1], avenrun[2]);
#  else
		printf("getla: avenrun = %ld", avenrun[0]);
		if (tTd(3, 15))
			printf(", %ld, %ld", avenrun[1], avenrun[2]);
#  endif
		printf("\n");
	}
	if (tTd(3, 1))
		printf("getla: %d\n", (int) (avenrun[0] + FSCALE/2) >> FSHIFT);
	return ((int) (avenrun[0] + FSCALE/2) >> FSHIFT);
# else /* LA_TYPE == LA_FLOAT */
	if (tTd(3, 5))
	{
		printf("getla: avenrun = %g", avenrun[0]);
		if (tTd(3, 15))
			printf(", %g, %g", avenrun[1], avenrun[2]);
		printf("\n");
	}
	if (tTd(3, 1))
		printf("getla: %d\n", (int) (avenrun[0] +0.5));
	return ((int) (avenrun[0] + 0.5));
# endif
}

#endif /* LA_TYPE == LA_INT or LA_SHORT or LA_FLOAT */

#if LA_TYPE == LA_READKSYM

# include <sys/ksym.h>

getla()
{
	static int kmem = -1;
	long avenrun[3];
	extern int errno;
	struct mioc_rksym mirk;

	if (kmem < 0)
	{
		kmem = open("/dev/kmem", 0, 0);
		if (kmem < 0)
		{
			if (tTd(3, 1))
				printf("getla: open(/dev/kmem): %s\n",
					errstring(errno));
			return (-1);
		}
		(void) fcntl(kmem, F_SETFD, 1);
	}
	mirk.mirk_symname = LA_AVENRUN;
	mirk.mirk_buf = avenrun;
	mirk.mirk_buflen = sizeof(avenrun);
	if (ioctl(kmem, MIOC_READKSYM, &mirk) < 0)
	{
		if (tTd(3, 1))
			printf("getla: ioctl(MIOC_READKSYM) failed: %s\n",
				errstring(errno));
		return -1;
	}
	if (tTd(3, 5))
	{
		printf("getla: avenrun = %d", avenrun[0]);
		if (tTd(3, 15))
			printf(", %d, %d", avenrun[1], avenrun[2]);
		printf("\n");
	}
	if (tTd(3, 1))
		printf("getla: %d\n", (int) (avenrun[0] + FSCALE/2) >> FSHIFT);
	return ((int) (avenrun[0] + FSCALE/2) >> FSHIFT);
}

#endif /* LA_TYPE == LA_READKSYM */

#if LA_TYPE == LA_DGUX

# include <sys/dg_sys_info.h>

int
getla()
{
	struct dg_sys_info_load_info load_info;

	dg_sys_info((long *)&load_info,
		DG_SYS_INFO_LOAD_INFO_TYPE, DG_SYS_INFO_LOAD_VERSION_0);

	if (tTd(3, 1))
		printf("getla: %d\n", (int) (load_info.one_minute + 0.5));

	return((int) (load_info.one_minute + 0.5));
}

#endif /* LA_TYPE == LA_DGUX */

#if LA_TYPE == LA_HPUX

/* forward declarations to keep gcc from complaining */
struct pst_dynamic;
struct pst_status;
struct pst_static;
struct pst_vminfo;
struct pst_diskinfo;
struct pst_processor;
struct pst_lv;
struct pst_swapinfo;

# include <sys/param.h>
# include <sys/pstat.h>

int
getla()
{
	struct pst_dynamic pstd;

	if (pstat_getdynamic(&pstd, sizeof(struct pst_dynamic),
			     (size_t) 1, 0) == -1)
		return 0;

	if (tTd(3, 1))
		printf("getla: %d\n", (int) (pstd.psd_avg_1_min + 0.5));

	return (int) (pstd.psd_avg_1_min + 0.5);
}

#endif /* LA_TYPE == LA_HPUX */

#if LA_TYPE == LA_SUBR

int
getla()
{
	double avenrun[3];

	if (getloadavg(avenrun, sizeof(avenrun) / sizeof(avenrun[0])) < 0)
	{
		if (tTd(3, 1))
			perror("getla: getloadavg failed:");
		return (-1);
	}
	if (tTd(3, 1))
		printf("getla: %d\n", (int) (avenrun[0] +0.5));
	return ((int) (avenrun[0] + 0.5));
}

#endif /* LA_TYPE == LA_SUBR */

#if LA_TYPE == LA_MACH

/*
**  This has been tested on NEXTSTEP release 2.1/3.X.
*/

#if defined(NX_CURRENT_COMPILER_RELEASE) && NX_CURRENT_COMPILER_RELEASE > NX_COMPILER_RELEASE_3_0
# include <mach/mach.h>
#else
# include <mach.h>
#endif

int
getla()
{
	processor_set_t default_set;
	kern_return_t error;
	unsigned int info_count;
	struct processor_set_basic_info info;
	host_t host;

	error = processor_set_default(host_self(), &default_set);
	if (error != KERN_SUCCESS)
	{
		if (tTd(3, 1))
			perror("getla: processor_set_default failed:");
		return -1;
	}
	info_count = PROCESSOR_SET_BASIC_INFO_COUNT;
	if (processor_set_info(default_set, PROCESSOR_SET_BASIC_INFO,
			       &host, (processor_set_info_t)&info,
			       &info_count) != KERN_SUCCESS)
	{
		if (tTd(3, 1))
			perror("getla: processor_set_info failed:");
		return -1;
	}
	if (tTd(3, 1))
		printf("getla: %d\n", (int) (info.load_average + (LOAD_SCALE / 2)) / LOAD_SCALE);
	return (int) (info.load_average + (LOAD_SCALE / 2)) / LOAD_SCALE;
}

#endif /* LA_TYPE == LA_MACH */

#if LA_TYPE == LA_PROCSTR

/*
**  Read /proc/loadavg for the load average.  This is assumed to be
**  in a format like "0.15 0.12 0.06".
**
**	Initially intended for Linux.  This has been in the kernel
**	since at least 0.99.15.
*/

# ifndef _PATH_LOADAVG
#  define _PATH_LOADAVG	"/proc/loadavg"
# endif

int
getla()
{
	double avenrun;
	register int result;
	FILE *fp;

	fp = fopen(_PATH_LOADAVG, "r");
	if (fp == NULL)
	{
		if (tTd(3, 1))
			printf("getla: fopen(%s): %s\n",
				_PATH_LOADAVG, errstring(errno));
		return -1;
	}
	result = fscanf(fp, "%lf", &avenrun);
	fclose(fp);
	if (result != 1)
	{
		if (tTd(3, 1))
			printf("getla: fscanf() = %d: %s\n",
				result, errstring(errno));
		return -1;
	}

	if (tTd(3, 1))
		printf("getla(): %.2f\n", avenrun);

	return ((int) (avenrun + 0.5));
}

#endif /* LA_TYPE == LA_PROCSTR */

#if LA_TYPE == LA_IRIX6
#include <sys/sysmp.h>

int getla(void)
{
	static int kmem = -1;
	int avenrun[3];

	if (kmem < 0)
	{
		kmem = open(_PATH_KMEM, 0, 0);
		if (kmem < 0)
		{
			if (tTd(3, 1))
				printf("getla: open(%s): %s\n", _PATH_KMEM,
					errstring(errno));
			return -1;
		}
		(void) fcntl(kmem, F_SETFD, 1);
	}

	if (lseek(kmem, (sysmp(MP_KERNADDR, MPKA_AVENRUN) & 0x7fffffff), SEEK_SET) == -1 || 
	    read(kmem, (char *)avenrun, sizeof(avenrun)) < sizeof(avenrun)) 
	{
		if (tTd(3, 1))
			printf("getla: lseek or read: %s\n",
			       errstring(errno));
		return -1;
	}
	if (tTd(3, 5))
	{
		printf("getla: avenrun = %ld", (long int) avenrun[0]);
		if (tTd(3, 15))
			printf(", %ld, %ld",
			       (long int) avenrun[1], (long int) avenrun[2]);
		printf("\n");
	}

	if (tTd(3, 1))
		printf("getla: %d\n", (int) (avenrun[0] + FSCALE/2) >> FSHIFT);
	return ((int) (avenrun[0] + FSCALE/2) >> FSHIFT);

}
#endif

#if LA_TYPE == LA_KSTAT

#include <kstat.h>

int
getla()
{
	static kstat_ctl_t *kc = NULL;
	static kstat_t *ksp = NULL;
	kstat_named_t *ksn;
	int la;

	if (kc == NULL)		/* if not initialized before */
		kc = kstat_open();
	if (kc == NULL)
	{
		if (tTd(3, 1))
			printf("getla: kstat_open(): %s\n",
				errstring(errno));
		return -1;
	}
	if (ksp == NULL)
		ksp = kstat_lookup(kc, "unix", 0, "system_misc");
	if (ksp == NULL)
	{
		if (tTd(3, 1))
			printf("getla: kstat_lookup(): %s\n",
				errstring(errno));
		return -1;
	}
	if (kstat_read(kc, ksp, NULL) < 0)
	{
		if (tTd(3, 1))
			printf("getla: kstat_read(): %s\n",
				errstring(errno));
		return -1;
	}
	ksn = (kstat_named_t *) kstat_data_lookup(ksp, "avenrun_1min");
	la = ((double)ksn->value.ul + FSCALE/2) / FSCALE;
	/* kstat_close(kc); /o do not close for fast access */
	return la;
}

#endif /* LA_TYPE == LA_KSTAT */

#if LA_TYPE == LA_DEVSHORT

/*
**  Read /dev/table/avenrun for the load average.  This should contain
**  three shorts for the 1, 5, and 15 minute loads.  We only read the
**  first, since that's all we care about.
**
**	Intended for SCO OpenServer 5.
*/

# ifndef _PATH_AVENRUN
#  define _PATH_AVENRUN	"/dev/table/avenrun"
# endif

int
getla()
{
	static int afd = -1;
	short avenrun;
	int loadav;
	int r;

	errno = EBADF;

	if (afd == -1 || lseek(afd, 0L, SEEK_SET) == -1)
	{
		if (errno != EBADF)
			return -1;
		afd = open(_PATH_AVENRUN, O_RDONLY|O_SYNC);
		if (afd < 0)
		{
			sm_syslog(LOG_ERR, NOQID,
				"can't open %s: %m",
				_PATH_AVENRUN);
			return -1;
		}
	}

	r = read(afd, &avenrun, sizeof avenrun);

	if (tTd(3, 5))
		printf("getla: avenrun = %d\n", avenrun);
	loadav = (int) (avenrun + FSCALE/2) >> FSHIFT;
	if (tTd(3, 1))
		printf("getla: %d\n", loadav);
	return loadav;
}

#endif /* LA_TYPE == LA_DEVSHORT */

#if LA_TYPE == LA_ALPHAOSF
struct rtentry;
struct mbuf;
# include <sys/table.h>

int getla()
{
	int ave = 0;
	struct tbl_loadavg tab;

	if (table(TBL_LOADAVG, 0, &tab, 1, sizeof(tab)) == -1)
	{
		if (tTd(3, 1))
			printf("getla: table %s\n", errstring(errno));
		return (-1);
	}

	if (tTd(3, 1))
		printf("getla: scale = %d\n", tab.tl_lscale);

	if (tab.tl_lscale)
		ave = (tab.tl_avenrun.l[0] + (tab.tl_lscale/2)) / tab.tl_lscale;
	else
		ave = (int) (tab.tl_avenrun.d[0] + 0.5);

	if (tTd(3, 1))
		printf("getla: %d\n", ave);

	return ave;
}

#endif

#if LA_TYPE == LA_ZERO

int
getla()
{
	if (tTd(3, 1))
		printf("getla: ZERO\n");
	return (0);
}

#endif /* LA_TYPE == LA_ZERO */

/*
 * Copyright 1989 Massachusetts Institute of Technology
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of M.I.T. not be used in advertising or
 * publicity pertaining to distribution of the software without specific,
 * written prior permission.  M.I.T. makes no representations about the
 * suitability of this software for any purpose.  It is provided "as is"
 * without express or implied warranty.
 *
 * M.I.T. DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL M.I.T.
 * BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
 * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
 * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 * Authors:  Many and varied...
 */

/* Non Apollo stuff removed by Don Lewis 11/15/93 */
#ifndef lint
static char  rcsid[] = "@@(#)$Id: conf.c,v 1.13 1999/02/05 05:59:23 millert Exp $";
#endif /* !lint */

#ifdef apollo
# undef volatile
#    include <apollo/base.h>

/* ARGSUSED */
int getloadavg( call_data )
     caddr_t	call_data;	/* pointer to (double) return value */
{
     double *avenrun = (double *) call_data;
     int i;
     status_$t      st;
     long loadav[3];
     proc1_$get_loadav(loadav, &st);
     *avenrun = loadav[0] / (double) (1 << 16);
     return(0);
}
#   endif /* apollo */
/*
**  SHOULDQUEUE -- should this message be queued or sent?
**
**	Compares the message cost to the load average to decide.
**
**	Parameters:
**		pri -- the priority of the message in question.
**		ctime -- the message creation time.
**
**	Returns:
**		TRUE -- if this message should be queued up for the
**			time being.
**		FALSE -- if the load is low enough to send this message.
**
**	Side Effects:
**		none.
*/

extern int	get_num_procs_online __P((void));

bool
shouldqueue(pri, ctime)
	long pri;
	time_t ctime;
{
	bool rval;
	int queuela = QueueLA * get_num_procs_online();

	if (tTd(3, 30))
		printf("shouldqueue: CurrentLA=%d, pri=%ld: ", CurrentLA, pri);
	if (CurrentLA < queuela)
	{
		if (tTd(3, 30))
			printf("FALSE (CurrentLA < QueueLA)\n");
		return (FALSE);
	}
#if 0	/* this code is reported to cause oscillation around RefuseLA */
	if (CurrentLA >= RefuseLA && QueueLA < RefuseLA)
	{
		if (tTd(3, 30))
			printf("TRUE (CurrentLA >= RefuseLA)\n");
		return (TRUE);
	}
#endif
	rval = pri > (QueueFactor / (CurrentLA - queuela + 1));
	if (tTd(3, 30))
		printf("%s (by calculation)\n", rval ? "TRUE" : "FALSE");
	return rval;
}
/*
**  REFUSECONNECTIONS -- decide if connections should be refused
**
**	Parameters:
**		port -- port number (for error messages only)
**
**	Returns:
**		TRUE if incoming SMTP connections should be refused
**			(for now).
**		FALSE if we should accept new work.
**
**	Side Effects:
**		Sets process title when it is rejecting connections.
*/

bool
refuseconnections(port)
	int port;
{
	int refusela = RefuseLA * get_num_procs_online();
	time_t now;
	static time_t lastconn = (time_t) 0;
	static int conncnt = 0;
	extern bool enoughdiskspace __P((long));

#ifdef XLA
	if (!xla_smtp_ok())
		return TRUE;
#endif

	now = curtime();
	if (now != lastconn)
	{
		lastconn = now;
		conncnt = 0;
	}
	else if (conncnt++ > ConnRateThrottle && ConnRateThrottle > 0)
	{
		/* sleep to flatten out connection load */
		sm_setproctitle(TRUE, "deferring connections on port %d: %d per second",
			port, ConnRateThrottle);
		if (LogLevel >= 14)
			sm_syslog(LOG_INFO, NOQID,
				"deferring connections on port %d: %d per second",
				port, ConnRateThrottle);
		sleep(1);
	}

	CurrentLA = getla();
	if (CurrentLA >= refusela)
	{
		sm_setproctitle(TRUE, "rejecting connections on port %d: load average: %d",
			port, CurrentLA);
		if (LogLevel >= 14)
			sm_syslog(LOG_INFO, NOQID,
				"rejecting connections on port %d: load average: %d",
				port, CurrentLA);
		return TRUE;
	}

	if (!enoughdiskspace(MinBlocksFree + 1))
	{
		sm_setproctitle(TRUE, "rejecting connections on port %d: min free: %d",
			port, MinBlocksFree);
		if (LogLevel >= 14)
			sm_syslog(LOG_INFO, NOQID,
				"rejecting connections on port %d: min free: %d",
				port, MinBlocksFree);
		return TRUE;
	}

	if (MaxChildren > 0 && CurChildren >= MaxChildren)
	{
		proc_list_probe();
		if (CurChildren >= MaxChildren)
		{
			sm_setproctitle(TRUE, "rejecting connections on port %d: %d children, max %d",
				port, CurChildren, MaxChildren);
			if (LogLevel >= 14)
				sm_syslog(LOG_INFO, NOQID,
					"rejecting connections on port %d: %d children, max %d",
					port, CurChildren, MaxChildren);
			return TRUE;
		}
	}

	return FALSE;
}
/*
**  SETPROCTITLE -- set process title for ps
**
**	Parameters:
**		fmt -- a printf style format string.
**		a, b, c -- possible parameters to fmt.
**
**	Returns:
**		none.
**
**	Side Effects:
**		Clobbers argv of our main procedure so ps(1) will
**		display the title.
*/

#define SPT_NONE	0	/* don't use it at all */
#define SPT_REUSEARGV	1	/* cover argv with title information */
#define SPT_BUILTIN	2	/* use libc builtin */
#define SPT_PSTAT	3	/* use pstat(PSTAT_SETCMD, ...) */
#define SPT_PSSTRINGS	4	/* use PS_STRINGS->... */
#define SPT_SYSMIPS	5	/* use sysmips() supported by NEWS-OS 6 */
#define SPT_SCO		6	/* write kernel u. area */
#define SPT_CHANGEARGV	7	/* write our own strings into argv[] */

#ifndef SPT_TYPE
# define SPT_TYPE	SPT_REUSEARGV
#endif

#if SPT_TYPE != SPT_NONE && SPT_TYPE != SPT_BUILTIN

# if SPT_TYPE == SPT_PSTAT
#  include <sys/pstat.h>
# endif
# if SPT_TYPE == SPT_PSSTRINGS
#  include <machine/vmparam.h>
#  include <sys/exec.h>
#  ifndef PS_STRINGS	/* hmmmm....  apparently not available after all */
#   undef SPT_TYPE
#   define SPT_TYPE	SPT_REUSEARGV
#  else
#   ifndef NKPDE			/* FreeBSD 2.0 */
#    define NKPDE 63
typedef unsigned int	*pt_entry_t;
#   endif
#  endif
# endif

# if SPT_TYPE == SPT_PSSTRINGS || SPT_TYPE == SPT_CHANGEARGV
#  define SETPROC_STATIC	static
# else
#  define SETPROC_STATIC
# endif

# if SPT_TYPE == SPT_SYSMIPS
#  include <sys/sysmips.h>
#  include <sys/sysnews.h>
# endif

# if SPT_TYPE == SPT_SCO
#  include <sys/immu.h>
#  include <sys/dir.h>
#  include <sys/user.h>
#  include <sys/fs/s5param.h>
#  if PSARGSZ > MAXLINE
#   define SPT_BUFSIZE	PSARGSZ
#  endif
# endif

# ifndef SPT_PADCHAR
#  define SPT_PADCHAR	' '
# endif

#endif /* SPT_TYPE != SPT_NONE && SPT_TYPE != SPT_BUILTIN */

# ifndef SPT_BUFSIZE
#  define SPT_BUFSIZE	MAXLINE
# endif

/*
**  Pointers for setproctitle.
**	This allows "ps" listings to give more useful information.
*/

char		**Argv = NULL;		/* pointer to argument vector */
char		*LastArgv = NULL;	/* end of argv */

void
initsetproctitle(argc, argv, envp)
	int argc;
	char **argv;
	char **envp;
{
	register int i, envpsize = 0;
	extern char **environ;

	/*
	**  Move the environment so setproctitle can use the space at
	**  the top of memory.
	*/

	for (i = 0; envp[i] != NULL; i++)
		envpsize += strlen(envp[i]) + 1;
	environ = (char **) xalloc(sizeof (char *) * (i + 1));
	for (i = 0; envp[i] != NULL; i++)
		environ[i] = newstr(envp[i]);
	environ[i] = NULL;

	/*
	**  Save start and extent of argv for setproctitle.
	*/

	Argv = argv;

	/*
	**  Determine how much space we can use for setproctitle.  
	**  Use all contiguous argv and envp pointers starting at argv[0]
 	*/
	for (i = 0; i < argc; i++)
	{
		if (i==0 || LastArgv + 1 == argv[i])
			LastArgv = argv[i] + strlen(argv[i]);
		else
			continue;
	}
	for (i=0; envp[i] != NULL; i++)
	{
		if (LastArgv + 1 == envp[i])
			LastArgv = envp[i] + strlen(envp[i]);
		else
			continue;
	}
}

#if SPT_TYPE != SPT_BUILTIN


/*VARARGS1*/
void
# ifdef __STDC__
setproctitle(const char *fmt, ...)
# else
setproctitle(fmt, va_alist)
	const char *fmt;
	va_dcl
# endif
{
# if SPT_TYPE != SPT_NONE
	register char *p;
	register int i;
	SETPROC_STATIC char buf[SPT_BUFSIZE];
	VA_LOCAL_DECL
#  if SPT_TYPE == SPT_PSTAT
	union pstun pst;
#  endif
#  if SPT_TYPE == SPT_SCO
	off_t seek_off;
	static int kmem = -1;
	static int kmempid = -1;
	struct user u;
#  endif

	p = buf;

	/* print sendmail: heading for grep */
	(void) strcpy(p, "sendmail: ");
	p += strlen(p);

	/* print the argument string */
	VA_START(fmt);
	(void) vsnprintf(p, SPACELEFT(buf, p), fmt, ap);
	VA_END;

	i = strlen(buf);

#  if SPT_TYPE == SPT_PSTAT
	pst.pst_command = buf;
	pstat(PSTAT_SETCMD, pst, i, 0, 0);
#  endif
#  if SPT_TYPE == SPT_PSSTRINGS
	PS_STRINGS->ps_nargvstr = 1;
	PS_STRINGS->ps_argvstr = buf;
#  endif
#  if SPT_TYPE == SPT_SYSMIPS
	sysmips(SONY_SYSNEWS, NEWS_SETPSARGS, buf);
#  endif
#  if SPT_TYPE == SPT_SCO
	if (kmem < 0 || kmempid != getpid())
	{
		if (kmem >= 0)
			close(kmem);
		kmem = open(_PATH_KMEM, O_RDWR, 0);
		if (kmem < 0)
			return;
		(void) fcntl(kmem, F_SETFD, 1);
		kmempid = getpid();
	}
	buf[PSARGSZ - 1] = '\0';
	seek_off = UVUBLK + (off_t) u.u_psargs - (off_t) &u;
	if (lseek(kmem, (off_t) seek_off, SEEK_SET) == seek_off)
		(void) write(kmem, buf, PSARGSZ);
#  endif
#  if SPT_TYPE == SPT_REUSEARGV
	if (i > LastArgv - Argv[0] - 2)
	{
		i = LastArgv - Argv[0] - 2;
		buf[i] = '\0';
	}
	(void) strcpy(Argv[0], buf);
	p = &Argv[0][i];
	while (p < LastArgv)
		*p++ = SPT_PADCHAR;
	Argv[1] = NULL;
#  endif
#  if SPT_TYPE == SPT_CHANGEARGV
	Argv[0] = buf;
	Argv[1] = 0;
#  endif
# endif /* SPT_TYPE != SPT_NONE */
}

#endif /* SPT_TYPE != SPT_BUILTIN */
/*
**  SM_SETPROCTITLE -- set process task and set process title for ps
**
**	Possibly set process status and call setproctitle() to
**	change the ps display.
**
**	Parameters:
**		status -- whether or not to store as process status
**		fmt -- a printf style format string.
**		a, b, c -- possible parameters to fmt.
**
**	Returns:
**		none.
*/

/*VARARGS2*/
void
# ifdef __STDC__
sm_setproctitle(bool status, const char *fmt, ...)
# else
sm_setproctitle(status, fmt, va_alist)
	bool status;
	const char *fmt;
	va_dcl
#endif
{
	char buf[SPT_BUFSIZE];

	VA_LOCAL_DECL
	/* print the argument string */
	VA_START(fmt);
	(void) vsnprintf(buf, SPT_BUFSIZE, fmt, ap);
	VA_END;

	if (status)
		proc_list_set(getpid(), buf);
	setproctitle("%s", buf);
}
/*
**  WAITFOR -- wait for a particular process id.
**
**	Parameters:
**		pid -- process id to wait for.
**
**	Returns:
**		status of pid.
**		-1 if pid never shows up.
**
**	Side Effects:
**		none.
*/

int
waitfor(pid)
	pid_t pid;
{
#ifdef WAITUNION
	union wait st;
#else
	auto int st;
#endif
	pid_t i;
#if defined(ISC_UNIX) || defined(_SCO_unix_)
	int savesig;
#endif

	do
	{
		errno = 0;
#if defined(ISC_UNIX) || defined(_SCO_unix_)
		savesig = releasesignal(SIGCHLD);
#endif
		i = wait(&st);
#if defined(ISC_UNIX) || defined(_SCO_unix_)
		if (savesig > 0)
			blocksignal(SIGCHLD);
#endif
		if (i > 0)
			proc_list_drop(i);
	} while ((i >= 0 || errno == EINTR) && i != pid);
	if (i < 0)
		return -1;
#ifdef WAITUNION
	return st.w_status;
#else
	return st;
#endif
}
/*
**  REAPCHILD -- pick up the body of my child, lest it become a zombie
**
**	Parameters:
**		sig -- the signal that got us here (unused).
**
**	Returns:
**		none.
**
**	Side Effects:
**		Picks up extant zombies.
*/

SIGFUNC_DECL
reapchild(sig)
	int sig;
{
	int olderrno = errno;
	pid_t pid;
# ifdef HASWAITPID
	auto int status;
	int count;

	count = 0;
	while ((pid = waitpid(-1, &status, WNOHANG)) > 0)
	{
		if (count++ > 1000)
		{
			if (LogLevel > 0)
				sm_syslog(LOG_ALERT, NOQID,
					"reapchild: waitpid loop: pid=%d, status=%x",
					pid, status);
			break;
		}
		proc_list_drop(pid);
	}
# else
# ifdef WNOHANG
	union wait status;

	while ((pid = wait3(&status, WNOHANG, (struct rusage *) NULL)) > 0)
		proc_list_drop(pid);
# else /* WNOHANG */
	auto int status;

	/*
	**  Catch one zombie -- we will be re-invoked (we hope) if there
	**  are more.  Unreliable signals probably break this, but this
	**  is the "old system" situation -- waitpid or wait3 are to be
	**  strongly preferred.
	*/

	if ((pid = wait(&status)) > 0)
		proc_list_drop(pid);
# endif /* WNOHANG */
# endif
# ifdef SYS5SIGNALS
	(void) setsignal(SIGCHLD, reapchild);
# endif
	errno = olderrno;
	return SIGFUNC_RETURN;
}
/*
**  PUTENV -- emulation of putenv() in terms of setenv()
**
**	Not needed on Posix-compliant systems.
**	This doesn't have full Posix semantics, but it's good enough
**		for sendmail.
**
**	Parameter:
**		env -- the environment to put.
**
**	Returns:
**		none.
*/

#ifdef NEEDPUTENV

# if NEEDPUTENV == 2		/* no setenv(3) call available */

int
putenv(str)
	char *str;
{
	char **current;
	int matchlen, envlen=0;
	char *tmp;
	char **newenv;
	static int first=1;
	extern char **environ;

	/*
	 * find out how much of str to match when searching
	 * for a string to replace.
	 */
	if ((tmp = strchr(str, '=')) == NULL || tmp == str)
		matchlen = strlen(str);
	else
		matchlen = (int) (tmp - str);
	++matchlen;

	/*
	 * Search for an existing string in the environment and find the
	 * length of environ.  If found, replace and exit.
	 */
	for (current=environ; *current; current++) {
		++envlen;

		if (strncmp(str, *current, matchlen) == 0) {
			/* found it, now insert the new version */
			*current = (char *)str;
			return(0);
		}
	}

	/*
	 * There wasn't already a slot so add space for a new slot.
	 * If this is our first time through, use malloc(), else realloc().
	 */
	if (first) {
		newenv = (char **) malloc(sizeof(char *) * (envlen + 2));
		if (newenv == NULL)
			return(-1);

		first=0;
		(void) memcpy(newenv, environ, sizeof(char *) * envlen);
	} else {
		newenv = (char **) realloc((char *)environ, sizeof(char *) * (envlen + 2));
		if (newenv == NULL)
			return(-1);
	}

	/* actually add in the new entry */
	environ = newenv;
	environ[envlen] = (char *)str;
	environ[envlen+1] = NULL;

	return(0);
}

#else			/* implement putenv() in terms of setenv() */

int
putenv(env)
	char *env;
{
	char *p;
	int l;
	char nbuf[100];

	p = strchr(env, '=');
	if (p == NULL)
		return 0;
	l = p - env;
	if (l > sizeof nbuf - 1)
		l = sizeof nbuf - 1;
	bcopy(env, nbuf, l);
	nbuf[l] = '\0';
	return setenv(nbuf, ++p, 1);
}

# endif
#endif
/*
**  UNSETENV -- remove a variable from the environment
**
**	Not needed on newer systems.
**
**	Parameters:
**		name -- the string name of the environment variable to be
**			deleted from the current environment.
**
**	Returns:
**		none.
**
**	Globals:
**		environ -- a pointer to the current environment.
**
**	Side Effects:
**		Modifies environ.
*/

#ifndef HASUNSETENV

void
unsetenv(name)
	char *name;
{
	extern char **environ;
	register char **pp;
	int len = strlen(name);

	for (pp = environ; *pp != NULL; pp++)
	{
		if (strncmp(name, *pp, len) == 0 &&
		    ((*pp)[len] == '=' || (*pp)[len] == '\0'))
			break;
	}

	for (; *pp != NULL; pp++)
		*pp = pp[1];
}

#endif
/*
**  GETDTABLESIZE -- return number of file descriptors
**
**	Only on non-BSD systems
**
**	Parameters:
**		none
**
**	Returns:
**		size of file descriptor table
**
**	Side Effects:
**		none
*/

#ifdef SOLARIS
# include <sys/resource.h>
#endif

int
getdtsize()
{
#ifdef RLIMIT_NOFILE
	struct rlimit rl;

	if (getrlimit(RLIMIT_NOFILE, &rl) >= 0)
		return rl.rlim_cur;
#endif

# ifdef HASGETDTABLESIZE
	return getdtablesize();
# else
#  ifdef _SC_OPEN_MAX
	return sysconf(_SC_OPEN_MAX);
#  else
	return NOFILE;
#  endif
# endif
}
/*
**  UNAME -- get the UUCP name of this system.
*/

#ifndef HASUNAME

int
uname(name)
	struct utsname *name;
{
	FILE *file;
	char *n;

	name->nodename[0] = '\0';

	/* try /etc/whoami -- one line with the node name */
	if ((file = fopen("/etc/whoami", "r")) != NULL)
	{
		(void) fgets(name->nodename, NODE_LENGTH + 1, file);
		(void) fclose(file);
		n = strchr(name->nodename, '\n');
		if (n != NULL)
			*n = '\0';
		if (name->nodename[0] != '\0')
			return (0);
	}

	/* try /usr/include/whoami.h -- has a #define somewhere */
	if ((file = fopen("/usr/include/whoami.h", "r")) != NULL)
	{
		char buf[MAXLINE];

		while (fgets(buf, MAXLINE, file) != NULL)
			if (sscanf(buf, "#define sysname \"%*[^\"]\"",
					NODE_LENGTH, name->nodename) > 0)
				break;
		(void) fclose(file);
		if (name->nodename[0] != '\0')
			return (0);
	}

#ifdef TRUST_POPEN
	/*
	**  Popen is known to have security holes.
	*/

	/* try uuname -l to return local name */
	if ((file = popen("uuname -l", "r")) != NULL)
	{
		(void) fgets(name, NODE_LENGTH + 1, file);
		(void) pclose(file);
		n = strchr(name, '\n');
		if (n != NULL)
			*n = '\0';
		if (name->nodename[0] != '\0')
			return (0);
	}
#endif

	return (-1);
}
#endif /* HASUNAME */
/*
**  INITGROUPS -- initialize groups
**
**	Stub implementation for System V style systems
*/

#ifndef HASINITGROUPS

initgroups(name, basegid)
	char *name;
	int basegid;
{
	return 0;
}

#endif
/*
**  SETGROUPS -- set group list
**
**	Stub implementation for systems that don't have group lists
*/

#ifndef NGROUPS_MAX

int
setgroups(ngroups, grouplist)
	int ngroups;
	GIDSET_T grouplist[];
{
	return 0;
}

#endif
/*
**  SETSID -- set session id (for non-POSIX systems)
*/

#ifndef HASSETSID

pid_t
setsid __P ((void))
{
#ifdef TIOCNOTTY
	int fd;

	fd = open("/dev/tty", O_RDWR, 0);
	if (fd >= 0)
	{
		(void) ioctl(fd, (int) TIOCNOTTY, (char *) 0);
		(void) close(fd);
	}
#endif /* TIOCNOTTY */
# ifdef SYS5SETPGRP
	return setpgrp();
# else
	return setpgid(0, getpid());
# endif
}

#endif
/*
**  FSYNC -- dummy fsync
*/

#ifdef NEEDFSYNC

fsync(fd)
	int fd;
{
# ifdef O_SYNC
	return fcntl(fd, F_SETFL, O_SYNC);
# else
	/* nothing we can do */
	return 0;
# endif
}

#endif
/*
**  DGUX_INET_ADDR -- inet_addr for DG/UX
**
**	Data General DG/UX version of inet_addr returns a struct in_addr
**	instead of a long.  This patches things.  Only needed on versions
**	prior to 5.4.3.
*/

#ifdef DGUX_5_4_2

#undef inet_addr

long
dgux_inet_addr(host)
	char *host;
{
	struct in_addr haddr;

	haddr = inet_addr(host);
	return haddr.s_addr;
}

#endif
/*
**  GETOPT -- for old systems or systems with bogus implementations
*/

#ifdef NEEDGETOPT

/*
 * Copyright (c) 1985 Regents of the University of California.
 * All rights reserved.  The Berkeley software License Agreement
 * specifies the terms and conditions for redistribution.
 */


/*
**  this version hacked to add `atend' flag to allow state machine
**  to reset if invoked by the program to scan args for a 2nd time
*/

#if defined(LIBC_SCCS) && !defined(lint)
static char sccsid[] = "@@(#)getopt.c	4.3 (Berkeley) 3/9/86";
#endif /* LIBC_SCCS and not lint */

#include <stdio.h>

/*
 * get option letter from argument vector
 */
#ifdef _CONVEX_SOURCE
extern int	optind, opterr, optopt;
extern char	*optarg;
#else
int	opterr = 1;		/* if error message should be printed */
int	optind = 1;		/* index into parent argv vector */
int	optopt = 0;		/* character checked for validity */
char	*optarg = NULL;		/* argument associated with option */
#endif

#define BADCH	(int)'?'
#define EMSG	""
#define tell(s)	if (opterr) {fputs(*nargv,stderr);fputs(s,stderr); \
		fputc(optopt,stderr);fputc('\n',stderr);return(BADCH);}

int
getopt(nargc,nargv,ostr)
	int		nargc;
	char *const	*nargv;
	const char	*ostr;
{
	static char	*place = EMSG;	/* option letter processing */
	static char	atend = 0;
	register char	*oli = NULL;	/* option letter list index */

	if (atend) {
		atend = 0;
		place = EMSG;
	}
	if(!*place) {			/* update scanning pointer */
		if (optind >= nargc || *(place = nargv[optind]) != '-' || !*++place) {
			atend++;
			return -1;
		}
		if (*place == '-') {	/* found "--" */
			++optind;
			atend++;
			return -1;
		}
	}				/* option letter okay? */
	if ((optopt = (int)*place++) == (int)':' || !(oli = strchr(ostr,optopt))) {
		if (!*place) ++optind;
		tell(": illegal option -- ");
	}
	if (oli && *++oli != ':') {		/* don't need argument */
		optarg = NULL;
		if (!*place) ++optind;
	}
	else {				/* need an argument */
		if (*place) optarg = place;	/* no white space */
		else if (nargc <= ++optind) {	/* no arg */
			place = EMSG;
			tell(": option requires an argument -- ");
		}
	 	else optarg = nargv[optind];	/* white space */
		place = EMSG;
		++optind;
	}
	return(optopt);			/* dump back option letter */
}

#endif
/*
**  VFPRINTF, VSPRINTF -- for old 4.3 BSD systems missing a real version
*/

#ifdef NEEDVPRINTF

#define MAXARG	16

vfprintf(fp, fmt, ap)
	FILE *fp;
	char *fmt;
	char **ap;
{
	char *bp[MAXARG];
	int i = 0;

	while (*ap && i < MAXARG)
		bp[i++] = *ap++;
	fprintf(fp, fmt, bp[0], bp[1], bp[2], bp[3],
			 bp[4], bp[5], bp[6], bp[7],
			 bp[8], bp[9], bp[10], bp[11],
			 bp[12], bp[13], bp[14], bp[15]);
}

vsprintf(s, fmt, ap)
	char *s;
	char *fmt;
	char **ap;
{
	char *bp[MAXARG];
	int i = 0;

	while (*ap && i < MAXARG)
		bp[i++] = *ap++;
	sprintf(s, fmt, bp[0], bp[1], bp[2], bp[3],
			bp[4], bp[5], bp[6], bp[7],
			bp[8], bp[9], bp[10], bp[11],
			bp[12], bp[13], bp[14], bp[15]);
}

#endif
/*
**  USERSHELLOK -- tell if a user's shell is ok for unrestricted use
**
**	Parameters:
**		user -- the name of the user we are checking.
**		shell -- the user's shell from /etc/passwd
**
**	Returns:
**		TRUE -- if it is ok to use this for unrestricted access.
**		FALSE -- if the shell is restricted.
*/

#if !HASGETUSERSHELL

# ifndef _PATH_SHELLS
#  define _PATH_SHELLS	"/etc/shells"
# endif

# if defined(_AIX3) || defined(_AIX4)
#  include <userconf.h>
#  if _AIX4 >= 40200
#   include <userpw.h>
#  endif
#  include <usersec.h>
# endif

char	*DefaultUserShells[] =
{
	"/bin/sh",		/* standard shell */
	"/usr/bin/sh",
	"/bin/csh",		/* C shell */
	"/usr/bin/csh",
#ifdef __hpux
# ifdef V4FS
	"/usr/bin/rsh",		/* restricted Bourne shell */
	"/usr/bin/ksh",		/* Korn shell */
	"/usr/bin/rksh",	/* restricted Korn shell */
	"/usr/bin/pam",
	"/usr/bin/keysh",	/* key shell (extended Korn shell) */
	"/usr/bin/posix/sh",
# else
	"/bin/rsh",		/* restricted Bourne shell */
	"/bin/ksh",		/* Korn shell */
	"/bin/rksh",		/* restricted Korn shell */
	"/bin/pam",
	"/usr/bin/keysh",	/* key shell (extended Korn shell) */
	"/bin/posix/sh",
# endif
#endif
#if defined(_AIX3) || defined(_AIX4)
	"/bin/ksh",		/* Korn shell */
	"/usr/bin/ksh",
	"/bin/tsh",		/* trusted shell */
	"/usr/bin/tsh",
	"/bin/bsh",		/* Bourne shell */
	"/usr/bin/bsh",
#endif
#if defined(__svr4__) || defined(__svr5__)
	"/bin/ksh",		/* Korn shell */
	"/usr/bin/ksh",
#endif
#ifdef sgi
	"/sbin/sh",		/* SGI's shells really live in /sbin */
	"/sbin/csh",
	"/bin/ksh",		/* Korn shell */
	"/sbin/ksh",
	"/usr/bin/ksh",
	"/bin/tcsh",		/* Extended csh */
	"/usr/bin/tcsh",
#endif
	NULL
};

#endif

#define WILDCARD_SHELL	"/SENDMAIL/ANY/SHELL/"

bool
usershellok(user, shell)
	char *user;
	char *shell;
{
#if HASGETUSERSHELL
	register char *p;
	extern char *getusershell();

	if (shell == NULL || shell[0] == '\0' || wordinclass(user, 't') ||
	    ConfigLevel <= 1)
		return TRUE;

	setusershell();
	while ((p = getusershell()) != NULL)
		if (strcmp(p, shell) == 0 || strcmp(p, WILDCARD_SHELL) == 0)
			break;
	endusershell();
	return p != NULL;
#else
# if USEGETCONFATTR
	auto char *v;
# endif
	register FILE *shellf;
	char buf[MAXLINE];

	if (shell == NULL || shell[0] == '\0' || wordinclass(user, 't') ||
	    ConfigLevel <= 1)
		return TRUE;

# if USEGETCONFATTR
	/*
	**  Naturally IBM has a "better" idea.....
	**
	**	What a crock.  This interface isn't documented, it is
	**	considered part of the security library (-ls), and it
	**	only works if you are running as root (since the list
	**	of valid shells is obviously a source of great concern).
	**	I recommend that you do NOT define USEGETCONFATTR,
	**	especially since you are going to have to set up an
	**	/etc/shells anyhow to handle the cases where getconfattr
	**	fails.
	*/

	if (getconfattr(SC_SYS_LOGIN, SC_SHELLS, &v, SEC_LIST) == 0 && v != NULL)
	{
		while (*v != '\0')
		{
			if (strcmp(v, shell) == 0 || strcmp(v, WILDCARD_SHELL) == 0)
				return TRUE;
			v += strlen(v) + 1;
		}
		return FALSE;
	}
# endif

	shellf = fopen(_PATH_SHELLS, "r");
	if (shellf == NULL)
	{
		/* no /etc/shells; see if it is one of the std shells */
		char **d;
		
		if (errno != ENOENT && LogLevel > 3)
			sm_syslog(LOG_ERR, NOQID,
				  "usershellok: cannot open %s: %s",
				  _PATH_SHELLS, errstring(errno));

		for (d = DefaultUserShells; *d != NULL; d++)
		{
			if (strcmp(shell, *d) == 0)
				return TRUE;
		}
		return FALSE;
	}

	while (fgets(buf, sizeof buf, shellf) != NULL)
	{
		register char *p, *q;

		p = buf;
		while (*p != '\0' && *p != '#' && *p != '/')
			p++;
		if (*p == '#' || *p == '\0')
			continue;
		q = p;
		while (*p != '\0' && *p != '#' && !(isascii(*p) && isspace(*p)))
			p++;
		*p = '\0';
		if (strcmp(shell, q) == 0 || strcmp(WILDCARD_SHELL, q) == 0)
		{
			fclose(shellf);
			return TRUE;
		}
	}
	fclose(shellf);
	return FALSE;
#endif
}
/*
**  FREEDISKSPACE -- see how much free space is on the queue filesystem
**
**	Only implemented if you have statfs.
**
**	Parameters:
**		dir -- the directory in question.
**		bsize -- a variable into which the filesystem
**			block size is stored.
**
**	Returns:
**		The number of bytes free on the queue filesystem.
**		-1 if the statfs call fails.
**
**	Side effects:
**		Puts the filesystem block size into bsize.
*/

/* statfs types */
#define SFS_NONE	0	/* no statfs implementation */
#define SFS_USTAT	1	/* use ustat */
#define SFS_4ARGS	2	/* use four-argument statfs call */
#define SFS_VFS		3	/* use <sys/vfs.h> implementation */
#define SFS_MOUNT	4	/* use <sys/mount.h> implementation */
#define SFS_STATFS	5	/* use <sys/statfs.h> implementation */
#define SFS_STATVFS	6	/* use <sys/statvfs.h> implementation */

#ifndef SFS_TYPE
# define SFS_TYPE	SFS_NONE
#endif

#if SFS_TYPE == SFS_USTAT
# include <ustat.h>
#endif
#if SFS_TYPE == SFS_4ARGS || SFS_TYPE == SFS_STATFS
# include <sys/statfs.h>
#endif
#if SFS_TYPE == SFS_VFS
# include <sys/vfs.h>
#endif
#if SFS_TYPE == SFS_MOUNT
# include <sys/mount.h>
#endif
#if SFS_TYPE == SFS_STATVFS
# include <sys/statvfs.h>
#endif

long
freediskspace(dir, bsize)
	char *dir;
	long *bsize;
{
#if SFS_TYPE != SFS_NONE
# if SFS_TYPE == SFS_USTAT
	struct ustat fs;
	struct stat statbuf;
#  define FSBLOCKSIZE	DEV_BSIZE
#  define SFS_BAVAIL	f_tfree
# else
#  if defined(ultrix)
	struct fs_data fs;
#   define SFS_BAVAIL	fd_bfreen
#   define FSBLOCKSIZE	1024L
#  else
#   if SFS_TYPE == SFS_STATVFS
	struct statvfs fs;
#    define FSBLOCKSIZE	fs.f_frsize
#   else
	struct statfs fs;
#    define FSBLOCKSIZE	fs.f_bsize
#   endif
#  endif
# endif
# ifndef SFS_BAVAIL
#  define SFS_BAVAIL f_bavail
# endif

# if SFS_TYPE == SFS_USTAT
	if (stat(dir, &statbuf) == 0 && ustat(statbuf.st_dev, &fs) == 0)
# else
#  if SFS_TYPE == SFS_4ARGS
	if (statfs(dir, &fs, sizeof fs, 0) == 0)
#  else
#   if SFS_TYPE == SFS_STATVFS
	if (statvfs(dir, &fs) == 0)
#   else
#    if defined(ultrix)
	if (statfs(dir, &fs) > 0)
#    else
	if (statfs(dir, &fs) == 0)
#    endif
#   endif
#  endif
# endif
	{
		if (bsize != NULL)
			*bsize = FSBLOCKSIZE;
		if (fs.SFS_BAVAIL <= 0)
			return 0;
		else if (fs.SFS_BAVAIL > LONG_MAX)
			return LONG_MAX;
		else
			return (long) fs.SFS_BAVAIL;
	}
#endif
	return (-1);
}
/*
**  ENOUGHDISKSPACE -- is there enough free space on the queue fs?
**
**	Only implemented if you have statfs.
**
**	Parameters:
**		msize -- the size to check against.  If zero, we don't yet
**		know how big the message will be, so just check for
**		a "reasonable" amount.
**
**	Returns:
**		TRUE if there is enough space.
**		FALSE otherwise.
*/

bool
enoughdiskspace(msize)
	long msize;
{
	long bfree, bsize;

	if (MinBlocksFree <= 0 && msize <= 0)
	{
		if (tTd(4, 80))
			printf("enoughdiskspace: no threshold\n");
		return TRUE;
	}

	if ((bfree = freediskspace(QueueDir, &bsize)) >= 0)
	{
		if (tTd(4, 80))
			printf("enoughdiskspace: bavail=%ld, need=%ld\n",
				bfree, msize);

		/* convert msize to block count */
		msize = msize / bsize + 1;
		if (MinBlocksFree >= 0)
			msize += MinBlocksFree;

		if (bfree < msize)
		{
			if (LogLevel > 0)
				sm_syslog(LOG_ALERT, CurEnv->e_id,
					"low on space (have %ld, %s needs %ld in %s)",
					bfree,
					CurHostName == NULL ? "SMTP-DAEMON" : CurHostName,
					msize, QueueDir);
			return FALSE;
		}
	}
	else if (tTd(4, 80))
		printf("enoughdiskspace failure: min=%ld, need=%ld: %s\n",
			MinBlocksFree, msize, errstring(errno));
	return TRUE;
}
/*
**  TRANSIENTERROR -- tell if an error code indicates a transient failure
**
**	This looks at an errno value and tells if this is likely to
**	go away if retried later.
**
**	Parameters:
**		err -- the errno code to classify.
**
**	Returns:
**		TRUE if this is probably transient.
**		FALSE otherwise.
*/

bool
transienterror(err)
	int err;
{
	switch (err)
	{
	  case EIO:			/* I/O error */
	  case ENXIO:			/* Device not configured */
	  case EAGAIN:			/* Resource temporarily unavailable */
	  case ENOMEM:			/* Cannot allocate memory */
	  case ENODEV:			/* Operation not supported by device */
	  case ENFILE:			/* Too many open files in system */
	  case EMFILE:			/* Too many open files */
	  case ENOSPC:			/* No space left on device */
#ifdef ETIMEDOUT
	  case ETIMEDOUT:		/* Connection timed out */
#endif
#ifdef ESTALE
	  case ESTALE:			/* Stale NFS file handle */
#endif
#ifdef ENETDOWN
	  case ENETDOWN:		/* Network is down */
#endif
#ifdef ENETUNREACH
	  case ENETUNREACH:		/* Network is unreachable */
#endif
#ifdef ENETRESET
	  case ENETRESET:		/* Network dropped connection on reset */
#endif
#ifdef ECONNABORTED
	  case ECONNABORTED:		/* Software caused connection abort */
#endif
#ifdef ECONNRESET
	  case ECONNRESET:		/* Connection reset by peer */
#endif
#ifdef ENOBUFS
	  case ENOBUFS:			/* No buffer space available */
#endif
#ifdef ESHUTDOWN
	  case ESHUTDOWN:		/* Can't send after socket shutdown */
#endif
#ifdef ECONNREFUSED
	  case ECONNREFUSED:		/* Connection refused */
#endif
#ifdef EHOSTDOWN
	  case EHOSTDOWN:		/* Host is down */
#endif
#ifdef EHOSTUNREACH
	  case EHOSTUNREACH:		/* No route to host */
#endif
#ifdef EDQUOT
	  case EDQUOT:			/* Disc quota exceeded */
#endif
#ifdef EPROCLIM
	  case EPROCLIM:		/* Too many processes */
#endif
#ifdef EUSERS
	  case EUSERS:			/* Too many users */
#endif
#ifdef EDEADLK
	  case EDEADLK:			/* Resource deadlock avoided */
#endif
#ifdef EISCONN
	  case EISCONN:			/* Socket already connected */
#endif
#ifdef EINPROGRESS
	  case EINPROGRESS:		/* Operation now in progress */
#endif
#ifdef EALREADY
	  case EALREADY:		/* Operation already in progress */
#endif
#ifdef EADDRINUSE
	  case EADDRINUSE:		/* Address already in use */
#endif
#ifdef EADDRNOTAVAIL
	  case EADDRNOTAVAIL:		/* Can't assign requested address */
#endif
#ifdef ETXTBSY
	  case ETXTBSY:			/* (Apollo) file locked */
#endif
#if defined(ENOSR) && (!defined(ENOBUFS) || (ENOBUFS != ENOSR))
	  case ENOSR:			/* Out of streams resources */
#endif
	  case E_SM_OPENTIMEOUT:	/* PSEUDO: open timed out */
		return TRUE;
	}

	/* nope, must be permanent */
	return FALSE;
}
/*
**  LOCKFILE -- lock a file using flock or (shudder) fcntl locking
**
**	Parameters:
**		fd -- the file descriptor of the file.
**		filename -- the file name (for error messages).
**		ext -- the filename extension.
**		type -- type of the lock.  Bits can be:
**			LOCK_EX -- exclusive lock.
**			LOCK_NB -- non-blocking.
**
**	Returns:
**		TRUE if the lock was acquired.
**		FALSE otherwise.
*/

bool
lockfile(fd, filename, ext, type)
	int fd;
	char *filename;
	char *ext;
	int type;
{
	int i;
	int save_errno;
# if !HASFLOCK
	int action;
	struct flock lfd;

	if (ext == NULL)
		ext = "";

	bzero(&lfd, sizeof lfd);
	if (bitset(LOCK_UN, type))
		lfd.l_type = F_UNLCK;
	else if (bitset(LOCK_EX, type))
		lfd.l_type = F_WRLCK;
	else
		lfd.l_type = F_RDLCK;

	if (bitset(LOCK_NB, type))
		action = F_SETLK;
	else
		action = F_SETLKW;

	if (tTd(55, 60))
		printf("lockfile(%s%s, action=%d, type=%d): ",
			filename, ext, action, lfd.l_type);

	while ((i = fcntl(fd, action, &lfd)) < 0 && errno == EINTR)
		continue;
	if (i >= 0)
	{
		if (tTd(55, 60))
			printf("SUCCESS\n");
		return TRUE;
	}
	save_errno = errno;

	if (tTd(55, 60))
		printf("(%s) ", errstring(save_errno));

	/*
	**  On SunOS, if you are testing using -oQ/tmp/mqueue or
	**  -oA/tmp/aliases or anything like that, and /tmp is mounted
	**  as type "tmp" (that is, served from swap space), the
	**  previous fcntl will fail with "Invalid argument" errors.
	**  Since this is fairly common during testing, we will assume
	**  that this indicates that the lock is successfully grabbed.
	*/

	if (save_errno == EINVAL)
	{
		if (tTd(55, 60))
			printf("SUCCESS\n");
		return TRUE;
	}

	if (!bitset(LOCK_NB, type) || (save_errno != EACCES && save_errno != EAGAIN))
	{
		int omode = -1;
#  ifdef F_GETFL
		(void) fcntl(fd, F_GETFL, &omode);
		errno = save_errno;
#  endif
		syserr("cannot lockf(%s%s, fd=%d, type=%o, omode=%o, euid=%d)",
			filename, ext, fd, type, omode, geteuid());
		dumpfd(fd, TRUE, TRUE);
	}
# else
	if (ext == NULL)
		ext = "";

	if (tTd(55, 60))
		printf("lockfile(%s%s, type=%o): ", filename, ext, type);

	while ((i = flock(fd, type)) < 0 && errno == EINTR)
		continue;
	if (i >= 0)
	{
		if (tTd(55, 60))
			printf("SUCCESS\n");
		return TRUE;
	}
	save_errno = errno;

	if (tTd(55, 60))
		printf("(%s) ", errstring(save_errno));

	if (!bitset(LOCK_NB, type) || save_errno != EWOULDBLOCK)
	{
		int omode = -1;
#  ifdef F_GETFL
		(void) fcntl(fd, F_GETFL, &omode);
		errno = save_errno;
#  endif
		syserr("cannot flock(%s%s, fd=%d, type=%o, omode=%o, euid=%d)",
			filename, ext, fd, type, omode, geteuid());
		dumpfd(fd, TRUE, TRUE);
	}
# endif
	if (tTd(55, 60))
		printf("FAIL\n");
	errno = save_errno;
	return FALSE;
}
/*
**  CHOWNSAFE -- tell if chown is "safe" (executable only by root)
**
**	Unfortunately, given that we can't predict other systems on which
**	a remote mounted (NFS) filesystem will be mounted, the answer is
**	almost always that this is unsafe.
**
**	Note also that many operating systems have non-compliant
**	implementations of the _POSIX_CHOWN_RESTRICTED variable and the
**	fpathconf() routine.  According to IEEE 1003.1-1990, if
**	_POSIX_CHOWN_RESTRICTED is defined and not equal to -1, then
**	no non-root process can give away the file.  However, vendors
**	don't take NFS into account, so a comfortable value of
**	_POSIX_CHOWN_RESTRICTED tells us nothing.
**
**	Also, some systems (e.g., IRIX 6.2) return 1 from fpathconf()
**	even on files where chown is not restricted.  Many systems get
**	this wrong on NFS-based filesystems (that is, they say that chown
**	is restricted [safe] on NFS filesystems where it may not be, since
**	other systems can access the same filesystem and do file giveaway;
**	only the NFS server knows for sure!)  Hence, it is important to
**	get the value of SAFENFSPATHCONF correct -- it should be defined
**	_only_ after testing (see test/t_pathconf.c) a system on an unsafe
**	NFS-based filesystem to ensure that you can get meaningful results.
**	If in doubt, assume unsafe!
**
**	You may also need to tweak IS_SAFE_CHOWN -- it should be a
**	condition indicating whether the return from pathconf indicates
**	that chown is safe (typically either > 0 or >= 0 -- there isn't
**	even any agreement about whether a zero return means that a file
**	is or is not safe).  It defaults to "> 0".
**
**	If the parent directory is safe (writable only by owner back
**	to the root) then we can relax slightly and trust fpathconf
**	in more circumstances.  This is really a crock -- if this is an
**	NFS mounted filesystem then we really know nothing about the
**	underlying implementation.  However, most systems pessimize and
**	return an error (EINVAL or EOPNOTSUPP) on NFS filesystems, which
**	we interpret as unsafe, as we should.  Thus, this heuristic gets
**	us into a possible problem only on systems that have a broken
**	pathconf implementation and which are also poorly configured
**	(have :include: files in group- or world-writable directories).
**
**	Parameters:
**		fd -- the file descriptor to check.
**		safedir -- set if the parent directory is safe.
**
**	Returns:
**		TRUE -- if the chown(2) operation is "safe" -- that is,
**			only root can chown the file to an arbitrary user.
**		FALSE -- if an arbitrary user can give away a file.
*/

#ifndef IS_SAFE_CHOWN
# define IS_SAFE_CHOWN	> 0
#endif

bool
chownsafe(fd, safedir)
	int fd;
	bool safedir;
{
#if (!defined(_POSIX_CHOWN_RESTRICTED) || _POSIX_CHOWN_RESTRICTED != -1) && \
    (defined(_PC_CHOWN_RESTRICTED) || defined(_GNU_TYPES_H))
	int rval;

	/* give the system administrator a chance to override */
	if (bitset(DBS_ASSUMESAFECHOWN, DontBlameSendmail))
		return TRUE;

	/*
	**  Some systems (e.g., SunOS) seem to have the call and the
	**  #define _PC_CHOWN_RESTRICTED, but don't actually implement
	**  the call.  This heuristic checks for that.
	*/

	errno = 0;
	rval = fpathconf(fd, _PC_CHOWN_RESTRICTED);
# if SAFENFSPATHCONF
	return errno == 0 && rval IS_SAFE_CHOWN;
# else
	return safedir && errno == 0 && rval IS_SAFE_CHOWN;
# endif
#else
	return bitset(DBS_ASSUMESAFECHOWN, DontBlameSendmail);
#endif
}
/*
**  RESETLIMITS -- reset system controlled resource limits
**
**	This is to avoid denial-of-service attacks
**
**	Parameters:
**		none
**
**	Returns:
**		none
*/

#if HASSETRLIMIT
# ifdef RLIMIT_NEEDS_SYS_TIME_H
#  include <sys/time.h>
# endif
# include <sys/resource.h>
#endif
#ifndef FD_SETSIZE
# define FD_SETSIZE	256
#endif

void
resetlimits()
{
#if HASSETRLIMIT
	struct rlimit lim;

	lim.rlim_cur = lim.rlim_max = RLIM_INFINITY;
	(void) setrlimit(RLIMIT_CPU, &lim);
	(void) setrlimit(RLIMIT_FSIZE, &lim);
# ifdef RLIMIT_NOFILE
	lim.rlim_cur = lim.rlim_max = FD_SETSIZE;
	(void) setrlimit(RLIMIT_NOFILE, &lim);
# endif
#else
# if HASULIMIT
	(void) ulimit(2, 0x3fffff);
	(void) ulimit(4, FD_SETSIZE);
# endif
#endif
	errno = 0;
}
/*
**  GETCFNAME -- return the name of the .cf file.
**
**	Some systems (e.g., NeXT) determine this dynamically.
*/

char *
getcfname()
{

	if (ConfFile != NULL)
		return ConfFile;
#if NETINFO
	{
		extern char *ni_propval __P((char *, char *, char *, char *, int));
		char *cflocation;

		cflocation = ni_propval("/locations", NULL, "sendmail",
					"sendmail.cf", '\0');
		if (cflocation != NULL)
			return cflocation;
	}
#endif

	return _PATH_SENDMAILCF;
}
/*
**  SETVENDOR -- process vendor code from V configuration line
**
**	Parameters:
**		vendor -- string representation of vendor.
**
**	Returns:
**		TRUE -- if ok.
**		FALSE -- if vendor code could not be processed.
**
**	Side Effects:
**		It is reasonable to set mode flags here to tweak
**		processing in other parts of the code if necessary.
**		For example, if you are a vendor that uses $%y to
**		indicate YP lookups, you could enable that here.
*/

bool
setvendor(vendor)
	char *vendor;
{
	if (strcasecmp(vendor, "Berkeley") == 0)
	{
		VendorCode = VENDOR_BERKELEY;
		return TRUE;
	}

	/* add vendor extensions here */

#ifdef SUN_EXTENSIONS
	if (strcasecmp(vendor, "Sun") == 0)
	{
		VendorCode = VENDOR_SUN;
		return TRUE;
	}
#endif

#if defined(VENDOR_NAME) && defined(VENDOR_CODE)
	if (strcasecmp(vendor, VENDOR_NAME) == 0)
	{
		VendorCode = VENDOR_CODE;
		return TRUE;
	}
#endif

	return FALSE;
}
/*
**  GETVENDOR -- return vendor name based on vendor code
**
**	Parameters:
**		vendorcode -- numeric representation of vendor.
**
**	Returns:
**		string containing vendor name.
*/

char *
getvendor(vendorcode)
	int vendorcode;
{
#if defined(VENDOR_NAME) && defined(VENDOR_CODE)
	/*
	**  Can't have the same switch case twice so need to 
	**  handle VENDOR_CODE outside of switch.  It might
	**  match one of the existing VENDOR_* codes.
	*/

	if (vendorcode == VENDOR_CODE)
		return VENDOR_NAME;
#endif

	switch (vendorcode)
	{
		case VENDOR_BERKELEY:
			return "Berkeley";
		
		case VENDOR_SUN:
			return "Sun";

		case VENDOR_HP:
			return "HP";

		case VENDOR_IBM:
			return "IBM";

		case VENDOR_SENDMAIL:
			return "Sendmail";

		default:
			return "Unknown";
	}
}
/*
**  VENDOR_PRE_DEFAULTS, VENDOR_POST_DEFAULTS -- set vendor-specific defaults
**
**	Vendor_pre_defaults is called before reading the configuration
**	file; vendor_post_defaults is called immediately after.
**
**	Parameters:
**		e -- the global environment to initialize.
**
**	Returns:
**		none.
*/

#if SHARE_V1
int	DefShareUid;	/* default share uid to run as -- unused??? */
#endif

void
vendor_pre_defaults(e)
	ENVELOPE *e;
{
#if SHARE_V1
	/* OTHERUID is defined in shares.h, do not be alarmed */
	DefShareUid = OTHERUID;
#endif
#if defined(SUN_EXTENSIONS) && defined(SUN_DEFAULT_VALUES)
	sun_pre_defaults(e);
#endif
#ifdef apollo
	/* stupid domain/os can't even open /etc/sendmail.cf without this */
	setuserenv("ISP", NULL);
	setuserenv("SYSTYPE", NULL);
#endif
}


void
vendor_post_defaults(e)
	ENVELOPE *e;
{
#ifdef __QNX__
	char *p;
	
	/* Makes sure the SOCK environment variable remains */
	if (p = getextenv("SOCK"))
		setuserenv("SOCK", p);
#endif
#if defined(SUN_EXTENSIONS) && defined(SUN_DEFAULT_VALUES)
	sun_post_defaults(e);
#endif
}
/*
**  VENDOR_DAEMON_SETUP -- special vendor setup needed for daemon mode
*/

void
vendor_daemon_setup(e)
	ENVELOPE *e;
{
#if SECUREWARE
	if (getluid() != -1)
	{
		usrerr("Daemon cannot have LUID");
		finis(FALSE, EX_USAGE);
	}
#endif /* SECUREWARE */
}
/*
**  VENDOR_SET_UID -- do setup for setting a user id
**
**	This is called when we are still root.
**
**	Parameters:
**		uid -- the uid we are about to become.
**
**	Returns:
**		none.
*/

void
vendor_set_uid(uid)
	UID_T uid;
{
	/* 
	**  We need to setup the share groups (lnodes)
	**  and and auditing inforation (luid's)
	**  before we loose our ``root''ness.
	*/
#if SHARE_V1
	if (setupshares(uid, syserr) != 0)
		syserr("Unable to set up shares");
#endif
#if SECUREWARE
	(void) setup_secure(uid);
#endif
}
/*
**  VALIDATE_CONNECTION -- check connection for rationality
**
**	If the connection is rejected, this routine should log an
**	appropriate message -- but should never issue any SMTP protocol.
**
**	Parameters:
**		sap -- a pointer to a SOCKADDR naming the peer.
**		hostname -- the name corresponding to sap.
**		e -- the current envelope.
**
**	Returns:
**		error message from rejection.
**		NULL if not rejected.
*/

#if TCPWRAPPERS
# include <tcpd.h>

/* tcpwrappers does no logging, but you still have to declare these -- ugh */
int	allow_severity	= LOG_INFO;
int	deny_severity	= LOG_NOTICE;
#endif

#if DAEMON
char *
validate_connection(sap, hostname, e)
	SOCKADDR *sap;
	char *hostname;
	ENVELOPE *e;
{
#if TCPWRAPPERS
	char *host;
#endif

	if (tTd(48, 3))
		printf("validate_connection(%s, %s)\n",
			hostname, anynet_ntoa(sap));

	if (rscheck("check_relay", hostname, anynet_ntoa(sap), e) != EX_OK)
	{
		static char reject[BUFSIZ*2];
		extern char MsgBuf[];

		if (tTd(48, 4))
			printf("  ... validate_connection: BAD (rscheck)\n");

		if (strlen(MsgBuf) > 5)
		{
			if (isascii(MsgBuf[0]) && isdigit(MsgBuf[0]) &&
			    isascii(MsgBuf[1]) && isdigit(MsgBuf[1]) &&
			    isascii(MsgBuf[2]) && isdigit(MsgBuf[2]))
				strcpy(reject, &MsgBuf[4]);
			else
				strcpy(reject, MsgBuf);
		}
		else
			strcpy(reject, "Access denied");

		return reject;
	}

#if TCPWRAPPERS
	if (hostname[0] == '[' && hostname[strlen(hostname) - 1] == ']')
		host = "unknown";
	else
		host = hostname;
	if (!hosts_ctl("sendmail", host, anynet_ntoa(sap), STRING_UNKNOWN))
	{
		if (tTd(48, 4))
			printf("  ... validate_connection: BAD (tcpwrappers)\n");
		if (LogLevel >= 4)
			sm_syslog(LOG_NOTICE, NOQID,
				"tcpwrappers (%s, %s) rejection",
				host, anynet_ntoa(sap));
		return "Access denied";
	}
#endif
	if (tTd(48, 4))
		printf("  ... validate_connection: OK\n");
	return NULL;
}

#endif
/*
**  STRTOL -- convert string to long integer
**
**	For systems that don't have it in the C library.
**
**	This is taken verbatim from the 4.4-Lite C library.
*/

#ifdef NEEDSTRTOL

#if defined(LIBC_SCCS) && !defined(lint)
static char sccsid[] = "@@(#)strtol.c	8.1 (Berkeley) 6/4/93";
#endif /* LIBC_SCCS and not lint */

/*
 * Convert a string to a long integer.
 *
 * Ignores `locale' stuff.  Assumes that the upper and lower case
 * alphabets and digits are each contiguous.
 */

long
strtol(nptr, endptr, base)
	const char *nptr;
	char **endptr;
	register int base;
{
	register const char *s = nptr;
	register unsigned long acc;
	register int c;
	register unsigned long cutoff;
	register int neg = 0, any, cutlim;

	/*
	 * Skip white space and pick up leading +/- sign if any.
	 * If base is 0, allow 0x for hex and 0 for octal, else
	 * assume decimal; if base is already 16, allow 0x.
	 */
	do {
		c = *s++;
	} while (isspace(c));
	if (c == '-') {
		neg = 1;
		c = *s++;
	} else if (c == '+')
		c = *s++;
	if ((base == 0 || base == 16) &&
	    c == '0' && (*s == 'x' || *s == 'X')) {
		c = s[1];
		s += 2;
		base = 16;
	}
	if (base == 0)
		base = c == '0' ? 8 : 10;

	/*
	 * Compute the cutoff value between legal numbers and illegal
	 * numbers.  That is the largest legal value, divided by the
	 * base.  An input number that is greater than this value, if
	 * followed by a legal input character, is too big.  One that
	 * is equal to this value may be valid or not; the limit
	 * between valid and invalid numbers is then based on the last
	 * digit.  For instance, if the range for longs is
	 * [-2147483648..2147483647] and the input base is 10,
	 * cutoff will be set to 214748364 and cutlim to either
	 * 7 (neg==0) or 8 (neg==1), meaning that if we have accumulated
	 * a value > 214748364, or equal but the next digit is > 7 (or 8),
	 * the number is too big, and we will return a range error.
	 *
	 * Set any if any `digits' consumed; make it negative to indicate
	 * overflow.
	 */
	cutoff = neg ? -(unsigned long)LONG_MIN : LONG_MAX;
	cutlim = cutoff % (unsigned long)base;
	cutoff /= (unsigned long)base;
	for (acc = 0, any = 0;; c = *s++) {
		if (isdigit(c))
			c -= '0';
		else if (isalpha(c))
			c -= isupper(c) ? 'A' - 10 : 'a' - 10;
		else
			break;
		if (c >= base)
			break;
		if (any < 0 || acc > cutoff || acc == cutoff && c > cutlim)
			any = -1;
		else {
			any = 1;
			acc *= base;
			acc += c;
		}
	}
	if (any < 0) {
		acc = neg ? LONG_MIN : LONG_MAX;
		errno = ERANGE;
	} else if (neg)
		acc = -acc;
	if (endptr != 0)
		*endptr = (char *)(any ? s - 1 : nptr);
	return (acc);
}

#endif
/*
**  STRSTR -- find first substring in string
**
**	Parameters:
**		big -- the big (full) string.
**		little -- the little (sub) string.
**
**	Returns:
**		A pointer to the first instance of little in big.
**		big if little is the null string.
**		NULL if little is not contained in big.
*/

#ifdef NEEDSTRSTR

char *
strstr(big, little)
	char *big;
	char *little;
{
	register char *p = big;
	int l;

	if (*little == '\0')
		return big;
	l = strlen(little);

	while ((p = strchr(p, *little)) != NULL)
	{
		if (strncmp(p, little, l) == 0)
			return p;
		p++;
	}
	return NULL;
}

#endif
/*
**  SM_GETHOSTBY{NAME,ADDR} -- compatibility routines for gethostbyXXX
**
**	Some operating systems have wierd problems with the gethostbyXXX
**	routines.  For example, Solaris versions at least through 2.3
**	don't properly deliver a canonical h_name field.  This tries to
**	work around these problems.
*/

struct hostent *
sm_gethostbyname(name)
	char *name;
{
	struct hostent *h;
#if (SOLARIS > 10000 && SOLARIS < 20400) || (defined(SOLARIS) && SOLARIS < 204) || (defined(sony_news) && defined(__svr4))
# if SOLARIS == 20300 || SOLARIS == 203
	static struct hostent hp;
	static char buf[1000];
	extern struct hostent *_switch_gethostbyname_r();

	if (tTd(61, 10))
		printf("_switch_gethostbyname_r(%s)... ", name);
	h = _switch_gethostbyname_r(name, &hp, buf, sizeof(buf), &h_errno);
# else
	extern struct hostent *__switch_gethostbyname();

	if (tTd(61, 10))
		printf("__switch_gethostbyname(%s)... ", name);
	h = __switch_gethostbyname(name);
# endif
#else
	int nmaps;
	char *maptype[MAXMAPSTACK];
	short mapreturn[MAXMAPACTIONS];
	char hbuf[MAXNAME];

	if (tTd(61, 10))
		printf("gethostbyname(%s)... ", name);
	h = gethostbyname(name);
	if (h == NULL)
	{
		if (tTd(61, 10))
			printf("failure\n");

		nmaps = switch_map_find("hosts", maptype, mapreturn);
		while (--nmaps >= 0)
			if (strcmp(maptype[nmaps], "nis") == 0 ||
			    strcmp(maptype[nmaps], "files") == 0)
				break;
		if (nmaps >= 0)
		{
			/* try short name */
			if (strlen(name) > (SIZE_T) sizeof hbuf - 1)
				return NULL;
			strcpy(hbuf, name);
			shorten_hostname(hbuf);

			/* if it hasn't been shortened, there's no point */
			if (strcmp(hbuf, name) != 0)
			{
				if (tTd(61, 10))
					printf("gethostbyname(%s)... ", hbuf);
				h = gethostbyname(hbuf);
			}
		}
	}
#endif
	if (tTd(61, 10))
	{
		if (h == NULL)
			printf("failure\n");
		else
			printf("%s\n", h->h_name);
	}
	return h;
}

struct hostent *
sm_gethostbyaddr(addr, len, type)
	char *addr;
	int len;
	int type;
{
#if (SOLARIS > 10000 && SOLARIS < 20400) || (defined(SOLARIS) && SOLARIS < 204)
# if SOLARIS == 20300 || SOLARIS == 203
	static struct hostent hp;
	static char buf[1000];
	extern struct hostent *_switch_gethostbyaddr_r();

	return _switch_gethostbyaddr_r(addr, len, type, &hp, buf, sizeof(buf), &h_errno);
# else
	extern struct hostent *__switch_gethostbyaddr();

	return __switch_gethostbyaddr(addr, len, type);
# endif
#else
	return gethostbyaddr(addr, len, type);
#endif
}
/*
**  SM_GETPW{NAM,UID} -- wrapper for getpwnam and getpwuid
*/

struct passwd *
sm_getpwnam(user)
	char *user;
{
#ifdef _AIX4
	extern struct passwd *_getpwnam_shadow(const char *, const int);

	return _getpwnam_shadow(user, 0);
#else
	return getpwnam(user);
#endif
}

struct passwd *
sm_getpwuid(uid)
	UID_T uid;
{
#if defined(_AIX4) && 0
	extern struct passwd *_getpwuid_shadow(const int, const int);

	return _getpwuid_shadow(uid,0);
#else
	return getpwuid(uid);
#endif
}
/*
**  SECUREWARE_SETUP_SECURE -- Convex SecureWare setup
**
**	Set up the trusted computing environment for C2 level security
**	under SecureWare.
**
**	Parameters:
**		uid -- uid of the user to initialize in the TCB
**
**	Returns:
**		none
**
**	Side Effects:
**		Initialized the user in the trusted computing base
*/

#if SECUREWARE

# include <sys/security.h>
# include <prot.h>

void
secureware_setup_secure(uid)
	UID_T uid;
{
	int rc;

	if (getluid() != -1)
		return;
	
	if ((rc = set_secure_info(uid)) != SSI_GOOD_RETURN)
	{
		switch (rc)
		{
		  case SSI_NO_PRPW_ENTRY:
			syserr("No protected passwd entry, uid = %d", uid);
			break;

		  case SSI_LOCKED:
			syserr("Account has been disabled, uid = %d", uid);
			break;

		  case SSI_RETIRED:
			syserr("Account has been retired, uid = %d", uid);
			break;

		  case SSI_BAD_SET_LUID:
			syserr("Could not set LUID, uid = %d", uid);
			break;

		  case SSI_BAD_SET_PRIVS:
			syserr("Could not set kernel privs, uid = %d", uid);

		  default:
			syserr("Unknown return code (%d) from set_secure_info(%d)", 
				rc, uid);
			break;
		}
		finis(FALSE, EX_NOPERM);
	}
}
#endif /* SECUREWARE */
/*
**  ADD_LOCAL_HOST_NAMES -- Add a hostname to class 'w' based on IP address
**
**	Add hostnames to class 'w' based on the IP address read from
**	the network interface.
**
**	Parameters:
**		sa -- a pointer to a SOCKADDR containing the address
**
**	Returns:
**		0 if successful, -1 if host lookup fails.
*/

int
add_hostnames(sa)
	SOCKADDR *sa;
{
	struct hostent *hp;

	/* lookup name with IP address */
	switch (sa->sa.sa_family)
	{
		case AF_INET:
			hp = sm_gethostbyaddr((char *) &sa->sin.sin_addr,
				sizeof(sa->sin.sin_addr), sa->sa.sa_family);
			break;

		default:
#if _FFR_LOG_UNSUPPORTED_FAMILIES
			/* XXX: Give warning about unsupported family */
			if (LogLevel > 3)
				sm_syslog(LOG_WARNING, NOQID,
					  "Unsupported address family %d: %.100s",
					  sa->sa.sa_family, anynet_ntoa(sa));
#endif
			return -1;
	}

	if (hp == NULL)
	{
		int save_errno = errno;

		if (LogLevel > 3)
			sm_syslog(LOG_WARNING, NOQID,
				"gethostbyaddr(%.100s) failed: %d\n",
				anynet_ntoa(sa),
#if NAMED_BIND
				h_errno
#else
				-1
#endif
				);
		errno = save_errno;
		return -1;
	}

	/* save its cname */
	if (!wordinclass((char *) hp->h_name, 'w'))
	{
		setclass('w', (char *) hp->h_name);
		if (tTd(0, 4))
			printf("\ta.k.a.: %s\n", hp->h_name);
	}

	/* save all it aliases name */
	while (*hp->h_aliases)
	{
		if (!wordinclass(*hp->h_aliases, 'w'))
		{
			setclass('w', *hp->h_aliases);
			if (tTd(0, 4))
				printf("\ta.k.a.: %s\n", *hp->h_aliases);
		}
		hp->h_aliases++;
	}
	return 0;
}
/*
**  LOAD_IF_NAMES -- load interface-specific names into $=w
**
**	Parameters:
**		none.
**
**	Returns:
**		none.
**
**	Side Effects:
**		Loads $=w with the names of all the interfaces.
*/

#if defined(SIOCGIFCONF) && !SIOCGIFCONF_IS_BROKEN
struct rtentry;
struct mbuf;
# include <arpa/inet.h>
# ifndef SUNOS403
#  include <sys/time.h>
# endif
# if _AIX4 >= 40300
#  undef __P
# endif
# include <net/if.h>
#endif

void
load_if_names()
{
#if defined(SIOCGIFCONF) && !SIOCGIFCONF_IS_BROKEN
	int s;
	int i;
	struct ifconf ifc;
	int numifs;

	s = socket(AF_INET, SOCK_DGRAM, 0);
	if (s == -1)
		return;

	/* get the list of known IP address from the kernel */
# if defined(SIOCGIFNUM) && !SIOCGIFNUM_IS_BROKEN
	if (ioctl(s, SIOCGIFNUM, (char *) &numifs) < 0)
	{
		/* can't get number of interfaces -- fall back */
		if (tTd(0, 4))
			printf("SIOCGIFNUM failed: %s\n", errstring(errno));
		numifs = -1;
	}
	else if (tTd(0, 42))
		printf("system has %d interfaces\n", numifs);
	if (numifs < 0)
# endif
		numifs = 512;

	if (numifs <= 0)
	{
		close(s);
		return;
	}
	ifc.ifc_len = numifs * sizeof (struct ifreq);
	ifc.ifc_buf = xalloc(ifc.ifc_len);
	if (ioctl(s, SIOCGIFCONF, (char *)&ifc) < 0)
	{
		if (tTd(0, 4))
			printf("SIOGIFCONF failed: %s\n", errstring(errno));
		close(s);
		return;
	}

	/* scan the list of IP address */
	if (tTd(0, 40))
		printf("scanning for interface specific names, ifc_len=%d\n",
			ifc.ifc_len);

	for (i = 0; i < ifc.ifc_len; )
	{
		struct ifreq *ifr = (struct ifreq *) &ifc.ifc_buf[i];
		SOCKADDR *sa = (SOCKADDR *) &ifr->ifr_addr;
		struct in_addr ia;
#ifdef SIOCGIFFLAGS
		struct ifreq ifrf;
#endif
		char ip_addr[256];
		extern char *inet_ntoa();

#ifdef BSD4_4_SOCKADDR
		if (sa->sa.sa_len > sizeof ifr->ifr_addr)
			i += sizeof ifr->ifr_name + sa->sa.sa_len;
		else
#endif
			i += sizeof *ifr;

		if (tTd(0, 20))
			printf("%s\n", anynet_ntoa(sa));

		if (ifr->ifr_addr.sa_family != AF_INET)
			continue;

#ifdef SIOCGIFFLAGS
		bzero(&ifrf, sizeof(struct ifreq));
		strncpy(ifrf.ifr_name, ifr->ifr_name, sizeof(ifrf.ifr_name));
		ioctl(s, SIOCGIFFLAGS, (char *) &ifrf);
		if (tTd(0, 41))
			printf("\tflags: %x\n", ifrf.ifr_flags);
# define IFRFREF ifrf
#else
# define IFRFREF (*ifr)
#endif
		if (!bitset(IFF_UP, IFRFREF.ifr_flags))
			continue;

		/* extract IP address from the list*/
		ia = sa->sin.sin_addr;
		if (ia.s_addr == INADDR_ANY || ia.s_addr == INADDR_NONE)
		{
			message("WARNING: interface %s is UP with %s address",
				ifr->ifr_name, inet_ntoa(ia));
			continue;
		}

		/* save IP address in text from */
		(void) snprintf(ip_addr, sizeof ip_addr, "[%.*s]",
			sizeof ip_addr - 3,
			inet_ntoa(ia));
		if (!wordinclass(ip_addr, 'w'))
		{
			setclass('w', ip_addr);
			if (tTd(0, 4))
				printf("\ta.k.a.: %s\n", ip_addr);
		}

		/* skip "loopback" interface "lo" */
		if (bitset(IFF_LOOPBACK, IFRFREF.ifr_flags))
			continue;

		(void) add_hostnames(sa);
	}
	free(ifc.ifc_buf);
	close(s);
# undef IFRFREF
#endif
}
/*
**  GET_NUM_PROCS_ONLINE -- return the number of processors currently online
**
**	Parameters:
**		none.
**
**	Returns:
**		The number of processors online.
*/

int
get_num_procs_online()
{
	int nproc = 0;

#if _FFR_SCALE_LA_BY_NUM_PROCS
#ifdef _SC_NPROCESSORS_ONLN
	nproc = (int) sysconf(_SC_NPROCESSORS_ONLN);
#endif
#endif
	if (nproc <= 0)
		nproc = 1;
	return nproc;
}
/*
**  SM_SYSLOG -- syslog wrapper to keep messages under SYSLOG_BUFSIZE
**
**	Parameters:
**		level -- syslog level
**		id -- envelope ID or NULL (NOQUEUE)
**		fmt -- format string
**		arg... -- arguments as implied by fmt.
**
**	Returns:
**		none
*/

/* VARARGS3 */
void
# ifdef __STDC__
sm_syslog(int level, const char *id, const char *fmt, ...)
# else
sm_syslog(level, id, fmt, va_alist)
	int level;
	const char *id;
	const char *fmt;
	va_dcl
#endif
{
	static char *buf = NULL;
	static size_t bufsize = MAXLINE;
	char *begin, *end;
	int seq = 1;
	int idlen;
	extern int SnprfOverflow;
	extern int SyslogErrno;
	extern char *DoprEnd;
	VA_LOCAL_DECL
	extern void sm_dopr __P((char *, const char *, va_list));
	
	SyslogErrno = errno;
	if (id == NULL)
	{
		id = "NOQUEUE";
		idlen = 9;
	}
	else if (strcmp(id, NOQID) == 0)
	{
		id = "";
		idlen = 0;
	}
	else
		idlen = strlen(id + 2);
bufalloc:
	if (buf == NULL)
		buf = (char *) xalloc(sizeof(char) * bufsize);

	/* do a virtual vsnprintf into buf */
	VA_START(fmt);
	buf[0] = 0;
	DoprEnd = buf + bufsize - 1;
	SnprfOverflow = 0;
	sm_dopr(buf, fmt, ap);
	*DoprEnd = '\0';
	VA_END;
	/* end of virtual vsnprintf */

	if (SnprfOverflow)
	{
		/* String too small, redo with correct size */
		bufsize += SnprfOverflow + 1;
		free(buf);
		buf = NULL;
		goto bufalloc;
	}
	if ((strlen(buf) + idlen + 1) < SYSLOG_BUFSIZE)
	{
#if LOG
		if (*id == '\0')
			syslog(level, "%s", buf);
		else
			syslog(level, "%s: %s", id, buf);
#else
		/*XXX should do something more sensible */
		if (*id == '\0')
			fprintf(stderr, "%s\n", buf);
		else
			fprintf(stderr, "%s: %s\n", id, buf);
#endif
		return;
	}

	begin = buf;
	while (*begin != '\0' &&
	       (strlen(begin) + idlen + 5) > SYSLOG_BUFSIZE) 
	{
		char save;
	
		if (seq == 999)
		{
			/* Too many messages */
			break;
		}
		end = begin + SYSLOG_BUFSIZE - idlen - 12;
		while (end > begin)
		{
			/* Break on comma or space */
			if (*end == ',' || *end == ' ')
			{
				end++;	  /* Include separator */
				break;
			}
			end--;
		}
		/* No separator, break midstring... */
		if (end == begin)
			end = begin + SYSLOG_BUFSIZE - idlen - 12;
		save = *end;
		*end = 0;
#if LOG
		syslog(level, "%s[%d]: %s ...", id, seq++, begin);
#else
		fprintf(stderr, "%s[%d]: %s ...\n", id, seq++, begin);
#endif
		*end = save;
		begin = end;
	}
	if (seq == 999)
#if LOG
		syslog(level, "%s[%d]: log terminated, too many parts", id, seq);
#else
		fprintf(stderr, "%s[%d]: log terminated, too many parts\n", id, seq);
#endif
	else if (*begin != '\0')
#if LOG
		syslog(level, "%s[%d]: %s", id, seq, begin);
#else
		fprintf(stderr, "%s[%d]: %s\n", id, seq, begin);
#endif
}
/*
**  HARD_SYSLOG -- call syslog repeatedly until it works
**
**	Needed on HP-UX, which apparently doesn't guarantee that
**	syslog succeeds during interrupt handlers.
*/

#if defined(__hpux) && !defined(HPUX11)

# define MAXSYSLOGTRIES	100
# undef syslog
# ifdef V4FS
#  define XCNST	const
#  define CAST	(const char *)
# else
#  define XCNST
#  define CAST
# endif

void
# ifdef __STDC__
hard_syslog(int pri, XCNST char *msg, ...)
# else
hard_syslog(pri, msg, va_alist)
	int pri;
	XCNST char *msg;
	va_dcl
# endif
{
	int i;
	char buf[SYSLOG_BUFSIZE];
	VA_LOCAL_DECL;

	VA_START(msg);
	vsnprintf(buf, sizeof buf, msg, ap);
	VA_END;

	for (i = MAXSYSLOGTRIES; --i >= 0 && syslog(pri, CAST "%s", buf) < 0; )
		continue;
}

# undef CAST
#endif
/*
**  LOCAL_HOSTNAME_LENGTH
**
**	This is required to get sendmail to compile against BIND 4.9.x
**	on Ultrix.
*/

#if defined(ultrix) && NAMED_BIND

# include <resolv.h>
# if __RES >= 19931104 && __RES < 19950621

int
local_hostname_length(hostname)
	char *hostname;
{
	int len_host, len_domain;

	if (!*_res.defdname)
		res_init();
	len_host = strlen(hostname);
	len_domain = strlen(_res.defdname);
	if (len_host > len_domain &&
	    (strcasecmp(hostname + len_host - len_domain,_res.defdname) == 0) &&
	    hostname[len_host - len_domain - 1] == '.')
		return len_host - len_domain - 1;
	else
		return 0;
}

# endif
#endif
/*
**  Compile-Time options
*/

char	*CompileOptions[] =
{
#ifdef HESIOD
	"HESIOD",
#endif
#if HES_GETMAILHOST
	"HES_GETMAILHOST",
#endif
#ifdef LDAPMAP
	"LDAPMAP",
#endif
#ifdef MAP_REGEX
	"MAP_REGEX",
#endif
#if LOG
	"LOG",
#endif
#if MATCHGECOS
	"MATCHGECOS",
#endif
#if MIME7TO8
	"MIME7TO8",
#endif
#if MIME8TO7
	"MIME8TO7",
#endif
#if NAMED_BIND
	"NAMED_BIND",
#endif
#ifdef NDBM
	"NDBM",
#endif
#if NETINET
	"NETINET",
#endif
#if NETINFO
	"NETINFO",
#endif
#if NETISO
	"NETISO",
#endif
#if NETNS
	"NETNS",
#endif
#if NETUNIX
	"NETUNIX",
#endif
#if NETX25
	"NETX25",
#endif
#ifdef NEWDB
	"NEWDB",
#endif
#ifdef NIS
	"NIS",
#endif
#ifdef NISPLUS
	"NISPLUS",
#endif
#if QUEUE
	"QUEUE",
#endif
#if SCANF
	"SCANF",
#endif
#if SMTP
	"SMTP",
#endif
#if SMTPDEBUG
	"SMTPDEBUG",
#endif
#ifdef SUID_ROOT_FILES_OK
	"SUID_ROOT_FILES_OK",
#endif
#if TCPWRAPPERS
	"TCPWRAPPERS",
#endif
#if USERDB
	"USERDB",
#endif
#if XDEBUG
	"XDEBUG",
#endif
#ifdef XLA
	"XLA",
#endif
	NULL
};


/*
**  OS compile options.
*/

char	*OsCompileOptions[] =
{
#if BOGUS_O_EXCL
	"BOGUS_O_EXCL",
#endif
#if HASFCHMOD
	"HASFCHMOD",
#endif
#if HASFLOCK
	"HASFLOCK",
#endif
#if HASGETDTABLESIZE
	"HASGETDTABLESIZE",
#endif
#if HASGETUSERSHELL
	"HASGETUSERSHELL",
#endif
#if HASINITGROUPS
	"HASINITGROUPS",
#endif
#if HASLSTAT
	"HASLSTAT",
#endif
#if HASSETREUID
	"HASSETREUID",
#endif
#if HASSETRLIMIT
	"HASSETRLIMIT",
#endif
#if HASSETSID
	"HASSETSID",
#endif
#if HASSETUSERCONTEXT
	"HASSETUSERCONTEXT",
#endif
#if HASSETVBUF
	"HASSETVBUF",
#endif
#if HASSNPRINTF
	"HASSNPRINTF",
#endif
#if HAS_ST_GEN
	"HAS_ST_GEN",
#endif
#if HASSTRERROR
	"HASSTRERROR",
#endif
#if HASULIMIT
	"HASULIMIT",
#endif
#if HASUNAME
	"HASUNAME",
#endif
#if HASUNSETENV
	"HASUNSETENV",
#endif
#if HASWAITPID
	"HASWAITPID",
#endif
#if IDENTPROTO
	"IDENTPROTO",
#endif
#if IP_SRCROUTE
	"IP_SRCROUTE",
#endif
#if O_EXLOCK && HASFLOCK && !BOGUS_O_EXCL
	"LOCK_ON_OPEN",
#endif
#if NEEDFSYNC
	"NEEDFSYNC",
#endif
#if NOFTRUNCATE
	"NOFTRUNCATE",
#endif
#if RLIMIT_NEEDS_SYS_TIME_H
	"RLIMIT_NEEDS_SYS_TIME_H",
#endif
#if SAFENFSPATHCONF
	"SAFENFSPATHCONF",
#endif
#if SECUREWARE
	"SECUREWARE",
#endif
#if SHARE_V1
	"SHARE_V1",
#endif
#if SIOCGIFCONF_IS_BROKEN
	"SIOCGIFCONF_IS_BROKEN",
#endif
#if SIOCGIFNUM_IS_BROKEN
	"SIOCGIFNUM_IS_BROKEN",
#endif
#if SYS5SETPGRP
	"SYS5SETPGRP",
#endif
#if SYSTEM5
	"SYSTEM5",
#endif
#if USE_SA_SIGACTION
	"USE_SA_SIGACTION",
#endif
#if USE_SIGLONGJMP
	"USE_SIGLONGJMP",
#endif
#if USESETEUID
	"USESETEUID",
#endif
	NULL
};
@


1.13
log
@sendmail 8.9.3
@
text
@d1950 1
a1950 1
static char  rcsid[] = "@@(#)$Id: conf.c,v 1.11 1999/01/01 20:33:39 millert Exp $";
@


1.12
log
@official fix for sendmail header length DoS
@
text
@d14 1
a14 1
static char sccsid[] = "@@(#)conf.c	8.450 (Berkeley) 12/17/1998";
d287 1
a287 2
      MaxHeaderLines = MAXHDRLINES;
      MaxHeaderLineLength = MAXHDRLINELEN;
@


1.11
log
@sendmail 8.9.2
@
text
@d287 2
d1951 1
a1951 1
static char  rcsid[] = "@@(#)$Id: conf.c,v 1.10 1998/07/12 19:44:26 millert Exp $";
@


1.10
log
@something hosed the sendmail import; fix up by hand
@
text
@d14 1
a14 1
static char sccsid[] = "@@(#)conf.c	8.431 (Berkeley) 6/25/98";
a219 1
	extern void inittimeouts __P((char *));
d249 1
a249 1
	TrustedFileUid = 0;
d294 1
a326 1
	extern void makemailer __P((char *));
d840 8
d1290 4
a1293 4
	** Due to QNX's network distributed nature, you can target a tcpip
	** stack on a different node in the qnx network; this patch lets
	** this feature work.  The __sock_locate() must be done before the
	** environment is clear.
d1949 1
a1949 1
static char  rcsid[] = "@@(#)$Id: getloadavg.c,v 1.16 1991/06/21 12:51:15 paul Exp $";
d2057 1
a2057 1
		setproctitle("deferring connections on port %d: %d per second",
d2069 1
a2069 1
		setproctitle("rejecting connections on port %d: load average: %d",
d2080 1
a2080 1
		setproctitle("rejecting connections on port %d: min free: %d",
a2090 2
		extern void proc_list_probe __P((void));

d2094 1
a2094 1
			setproctitle("rejecting connections on port %d: %d children, max %d",
d2178 2
a2183 2
#endif /* SPT_TYPE != SPT_NONE && SPT_TYPE != SPT_BUILTIN */

d2328 38
d2835 2
a2836 2
** this version hacked to add `atend' flag to allow state machine
** to reset if invoked by the program to scan args for a 2nd time
d3008 1
a3008 1
#ifdef __svr4__
d3711 8
d3722 46
d3830 1
a3830 1
		exit(EX_USAGE);
d4273 1
a4273 1
		exit(EX_NOPERM);
d4278 77
d4431 1
a4431 1
		struct sockaddr *sa = &ifr->ifr_addr;
a4432 1
		struct hostent *hp;
d4440 2
a4441 2
		if (sa->sa_len > sizeof ifr->ifr_addr)
			i += sizeof ifr->ifr_name + sa->sa_len;
d4447 1
a4447 1
			printf("%s\n", anynet_ntoa((SOCKADDR *) sa));
d4466 1
a4466 1
		ia = (((struct sockaddr_in *) sa)->sin_addr);
d4489 1
a4489 35
		/* lookup name with IP address */
		hp = sm_gethostbyaddr((char *) &ia, sizeof(ia), AF_INET);
		if (hp == NULL)
		{
			if (LogLevel > 3)
				sm_syslog(LOG_WARNING, NOQID,
					"gethostbyaddr(%.100s) failed: %d\n",
					inet_ntoa(ia),
#if NAMED_BIND
					h_errno);
#else
					-1);
#endif
			continue;
		}

		/* save its cname */
		if (!wordinclass((char *) hp->h_name, 'w'))
		{
			setclass('w', (char *) hp->h_name);
			if (tTd(0, 4))
				printf("\ta.k.a.: %s\n", hp->h_name);
		}

		/* save all it aliases name */
		while (*hp->h_aliases)
		{
			if (!wordinclass(*hp->h_aliases, 'w'))
			{
				setclass('w', *hp->h_aliases);
				if (tTd(0, 4))
				printf("\ta.k.a.: %s\n", *hp->h_aliases);
			}
			hp->h_aliases++;
		}
d4554 1
a4554 1
	extern void sm_dopr __P((char *, const char *, ...));
@


1.9
log
@Upgrade to sendmail 8.8.8
@
text
@d2 2
a3 1
 * Copyright (c) 1983, 1995-1997 Eric P. Allman
d7 3
a9 15
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
a10 11
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
d14 1
a14 1
static char sccsid[] = "@@(#)conf.c	8.379 (Berkeley) 10/20/97";
d21 1
a44 2


a119 1
#if _FFR_PRIVACY_NOETRN
d121 1
a121 1
#endif
d128 49
d218 1
d220 5
a224 5
	extern void inittimeouts();
	extern void setdefuser();
	extern void setupmaps();
	extern void setupmailers();
	extern void setupheaders();
d235 20
a254 2
	DefUid = 1;				/* option u */
	DefGid = 1;				/* option g */
d264 2
a265 1
	PrivacyFlags = 0;			/* option p */
d292 3
a294 1
	setdefuser();
d315 3
d327 1
a327 1
	extern void makemailer();
d449 6
d482 1
a482 1
#if _FFR_SYSLOG_MAP
d817 4
d824 1
a824 1
		fp = fopen(ServiceSwitchFile, "r");
d893 1
d895 1
d897 1
d904 2
a905 2
#ifdef AUTO_NIS_ALIASES
# ifdef NISPLUS
d907 2
a908 2
# endif
# ifdef NIS
d910 1
a911 1
#endif
d916 1
a916 1
# if NAMED_BIND
d918 2
a919 2
# else
#  if defined(sun) && !defined(BSD) && !defined(_USE_SUN_NSSWITCH_)
d922 1
a923 1
# endif
d928 1
d1026 1
a1026 1
	if (stat(pathn, &stbuf) < 0 || !bitset(02, stbuf.st_mode))
d1281 9
a1402 4
#ifdef IRIX64
# define nlist		nlist64
#endif

d1733 1
a1733 16

#include <nlist.h>
#include <sys/types.h>
#include <unistd.h>

#define	X_AVENRUN	0
struct nlist	Nl32[] =
{
	{ LA_AVENRUN },
	{ 0 },
};
struct nlist64	Nl64[] =
{
	{ LA_AVENRUN },
	{ 0 },
};
d1738 1
a1738 69
	static enum { getla_none, getla_32, getla_64 } kernel_type =
					getla_none;
	uint32_t avenrun[3];

	if (kernel_type == getla_none)
	{
		/* Try 32 bit kernel ... */
		errno = 0;
		if (nlist(_PATH_UNIX, Nl32) == 0)
		{
			if (tTd(3, 20))
				printf("getla: Kernel is 32bit\n");

			if (Nl32[X_AVENRUN].n_value == 0)
			{
				if (tTd(3, 1))
					printf("getla: nlist(%s, %s) ==> 0\n",
						_PATH_UNIX, LA_AVENRUN);
			}
			else
				kernel_type = getla_32;
		}
		else if (errno != 0)
		{
			if (tTd(3, 1))
				printf("getla: nlist(%s): %s\n",
					_PATH_UNIX, errstring(errno));
		}
		else
		{
			if (tTd(3, 20))
				printf("getla: Kernel is not 32bit\n");
		}

		/* Try 64 bit kernel ... */
		errno = 0;
		if (nlist64(_PATH_UNIX, Nl64) == 0)
		{
			if (tTd(3, 20))
			printf("getla: Kernel is 64bit\n");

			if (Nl64[X_AVENRUN].n_value == 0)
			{
				if (tTd(3, 1))
					printf("getla: nlist(%s, %s) ==> 0\n",
						_PATH_UNIX, LA_AVENRUN);
			}
			else
				kernel_type = getla_64;
		}
		else if (errno != 0)
		{
			if (tTd(3, 1))
				printf("getla: nlist64(%s): %s\n",
					_PATH_UNIX, errstring(errno));
		}
		else
		{
			if (tTd(3, 20))
				printf("getla: Kernel is not 64bit\n");
		}
	}

	if (kernel_type == getla_none)
	{
		if (tTd(3, 1))
			printf("getla: Failed to determine kernel type\n");
		return -1;
	}
d1746 1
a1746 1
				printf("getla: open(/dev/kmem): %s\n",
d1753 2
a1754 1
	switch (kernel_type)
d1756 3
a1758 1
	  case getla_none:
a1759 24

	  case getla_32:
		if (lseek(kmem, (off_t) Nl32[X_AVENRUN].n_value, SEEK_SET) == -1 ||
		    read(kmem, (char *) avenrun, sizeof(avenrun)) < sizeof(avenrun))
		{
			if (tTd(3, 1))
				printf("getla: lseek or read: %s\n",
					errstring(errno));
			return -1;
		}
		break;

	  case getla_64:
		/* Using of lseek64 is perhaps overkill ... */
		if (lseek64(kmem, (off64_t) Nl64[X_AVENRUN].n_value, SEEK_SET) == -1 ||
		    read(kmem, (char *) avenrun, sizeof(avenrun)) <
					sizeof(avenrun))
		{
			if (tTd(3, 1))
				printf("getla: lseek64 or read: %s\n",
					errstring(errno));
			return -1;
		}
		break;
d1763 1
a1763 2
		printf("getla: avenrun = %ld",
			(long int) avenrun[0]);
d1766 1
a1766 2
				(long int)avenrun[1],
				(long int)avenrun[2]);
d1769 1
d1771 1
a1771 2
		printf("getla: %d\n",
			(int) (avenrun[0] + FSCALE/2) >> FSHIFT);
d1773 1
d1873 2
d1942 1
a1942 1
static char  rcsid[] = "@@(#)$Id: conf.c,v 1.8 1997/08/04 02:17:48 downsj Exp $";
d2034 1
a2034 1
	extern bool enoughdiskspace();
d2215 17
a2231 12
	**  Find the last environment variable within sendmail's
	**  process memory area.
	*/
	while (i > 0 && (envp[i - 1] < argv[0] ||
			 envp[i - 1] > (argv[argc - 1] +
					strlen(argv[argc - 1]) + 1 + envpsize)))
		i--;

	if (i > 0)
		LastArgv = envp[i - 1] + strlen(envp[i - 1]);
	else
		LastArgv = argv[argc - 1] + strlen(argv[argc - 1]);
d2694 17
a2908 327
**  SNPRINTF, VSNPRINT -- counted versions of printf
**
**	These versions have been grabbed off the net.  They have been
**	cleaned up to compile properly and support for .precision and
**	%lx has been added.
*/

/**************************************************************
 * Original:
 * Patrick Powell Tue Apr 11 09:48:21 PDT 1995
 * A bombproof version of doprnt (sm_dopr) included.
 * Sigh.  This sort of thing is always nasty do deal with.  Note that
 * the version here does not include floating point...
 *
 * snprintf() is used instead of sprintf() as it does limit checks
 * for string length.  This covers a nasty loophole.
 *
 * The other functions are there to prevent NULL pointers from
 * causing nast effects.
 **************************************************************/

/*static char _id[] = "$Id: conf.c,v 1.8 1997/08/04 02:17:48 downsj Exp $";*/
static void	sm_dopr();
static char	*DoprEnd;
static int	SnprfOverflow;

#if !HASSNPRINTF

/* VARARGS3 */
int
# ifdef __STDC__
snprintf(char *str, size_t count, const char *fmt, ...)
# else
snprintf(str, count, fmt, va_alist)
	char *str;
	size_t count;
	const char *fmt;
	va_dcl
#endif
{
	int len;
	VA_LOCAL_DECL

	VA_START(fmt);
	len = vsnprintf(str, count, fmt, ap);
	VA_END;
	return len;
}


# ifndef luna2
int
vsnprintf(str, count, fmt, args)
	char *str;
	size_t count;
	const char *fmt;
	va_list args;
{
	str[0] = 0;
	DoprEnd = str + count - 1;
	SnprfOverflow = 0;
	sm_dopr( str, fmt, args );
	if (count > 0)
		DoprEnd[0] = 0;
	if (SnprfOverflow && tTd(57, 2))
		printf("\nvsnprintf overflow, len = %d, str = %s",
			count, shortenstring(str, 203));
	return strlen(str);
}

# endif /* !luna2 */
#endif /* !HASSNPRINTF */

/*
 * sm_dopr(): poor man's version of doprintf
 */

static void fmtstr __P((char *value, int ljust, int len, int zpad, int maxwidth));
static void fmtnum __P((long value, int base, int dosign, int ljust, int len, int zpad));
static void dostr __P(( char * , int ));
static char *output;
static void dopr_outch __P(( int c ));
static int	SyslogErrno;

static void
sm_dopr( buffer, format, args )
       char *buffer;
       const char *format;
       va_list args;
{
       int ch;
       long value;
       int longflag  = 0;
       int pointflag = 0;
       int maxwidth  = 0;
       char *strvalue;
       int ljust;
       int len;
       int zpad;
# if !HASSTRERROR && !defined(ERRLIST_PREDEFINED)
	extern char *sys_errlist[];
	extern int sys_nerr;
# endif


       output = buffer;
       while( (ch = *format++) ){
	       switch( ch ){
	       case '%':
		       ljust = len = zpad = maxwidth = 0;
		       longflag = pointflag = 0;
	       nextch:
		       ch = *format++;
		       switch( ch ){
		       case 0:
			       dostr( "**end of format**" , 0);
			       return;
		       case '-': ljust = 1; goto nextch;
		       case '0': /* set zero padding if len not set */
			       if(len==0 && !pointflag) zpad = '0';
		       case '1': case '2': case '3':
		       case '4': case '5': case '6':
		       case '7': case '8': case '9':
			       if (pointflag)
				 maxwidth = maxwidth*10 + ch - '0';
			       else
				 len = len*10 + ch - '0';
			       goto nextch;
		       case '*': 
			       if (pointflag)
				 maxwidth = va_arg( args, int );
			       else
				 len = va_arg( args, int );
			       goto nextch;
		       case '.': pointflag = 1; goto nextch;
		       case 'l': longflag = 1; goto nextch;
		       case 'u': case 'U':
			       /*fmtnum(value,base,dosign,ljust,len,zpad) */
			       if( longflag ){
				       value = va_arg( args, long );
			       } else {
				       value = va_arg( args, int );
			       }
			       fmtnum( value, 10,0, ljust, len, zpad ); break;
		       case 'o': case 'O':
			       /*fmtnum(value,base,dosign,ljust,len,zpad) */
			       if( longflag ){
				       value = va_arg( args, long );
			       } else {
				       value = va_arg( args, int );
			       }
			       fmtnum( value, 8,0, ljust, len, zpad ); break;
		       case 'd': case 'D':
			       if( longflag ){
				       value = va_arg( args, long );
			       } else {
				       value = va_arg( args, int );
			       }
			       fmtnum( value, 10,1, ljust, len, zpad ); break;
		       case 'x':
			       if( longflag ){
				       value = va_arg( args, long );
			       } else {
				       value = va_arg( args, int );
			       }
			       fmtnum( value, 16,0, ljust, len, zpad ); break;
		       case 'X':
			       if( longflag ){
				       value = va_arg( args, long );
			       } else {
				       value = va_arg( args, int );
			       }
			       fmtnum( value,-16,0, ljust, len, zpad ); break;
		       case 's':
			       strvalue = va_arg( args, char *);
			       if (maxwidth > 0 || !pointflag) {
				 if (pointflag && len > maxwidth)
				   len = maxwidth; /* Adjust padding */
				 fmtstr( strvalue,ljust,len,zpad, maxwidth);
			       }
			       break;
		       case 'c':
			       ch = va_arg( args, int );
			       dopr_outch( ch ); break;
                       case 'm':
#if HASSTRERROR
                               dostr(strerror(SyslogErrno), 0);
#else
                               if (SyslogErrno < 0 || SyslogErrno > sys_nerr) 
                               {
                                   dostr("Error ", 0);
                                   fmtnum(SyslogErrno, 10, 0, 0, 0, 0);
                               }
                               else 
                                   dostr(sys_errlist[SyslogErrno], 0);
#endif
			       break;

		       case '%': dopr_outch( ch ); continue;
		       default:
			       dostr(  "???????" , 0);
		       }
		       break;
	       default:
		       dopr_outch( ch );
		       break;
	       }
       }
       *output = 0;
}

static void
fmtstr(  value, ljust, len, zpad, maxwidth )
       char *value;
       int ljust, len, zpad, maxwidth;
{
       int padlen, strlen;     /* amount to pad */

       if( value == 0 ){
	       value = "<NULL>";
       }
       for( strlen = 0; value[strlen]; ++ strlen ); /* strlen */
       if (strlen > maxwidth && maxwidth)
	 strlen = maxwidth;
       padlen = len - strlen;
       if( padlen < 0 ) padlen = 0;
       if( ljust ) padlen = -padlen;
       while( padlen > 0 ) {
	       dopr_outch( ' ' );
	       --padlen;
       }
       dostr( value, maxwidth );
       while( padlen < 0 ) {
	       dopr_outch( ' ' );
	       ++padlen;
       }
}

static void
fmtnum(  value, base, dosign, ljust, len, zpad )
       long value;
       int base, dosign, ljust, len, zpad;
{
       int signvalue = 0;
       unsigned long uvalue;
       char convert[20];
       int place = 0;
       int padlen = 0; /* amount to pad */
       int caps = 0;

       /* DEBUGP(("value 0x%x, base %d, dosign %d, ljust %d, len %d, zpad %d\n",
	       value, base, dosign, ljust, len, zpad )); */
       uvalue = value;
       if( dosign ){
	       if( value < 0 ) {
		       signvalue = '-';
		       uvalue = -value;
	       }
       }
       if( base < 0 ){
	       caps = 1;
	       base = -base;
       }
       do{
	       convert[place++] =
		       (caps? "0123456789ABCDEF":"0123456789abcdef")
			[uvalue % (unsigned)base  ];
	       uvalue = (uvalue / (unsigned)base );
       }while(uvalue);
       convert[place] = 0;
       padlen = len - place;
       if( padlen < 0 ) padlen = 0;
       if( ljust ) padlen = -padlen;
       /* DEBUGP(( "str '%s', place %d, sign %c, padlen %d\n",
	       convert,place,signvalue,padlen)); */
       if( zpad && padlen > 0 ){
	       if( signvalue ){
		       dopr_outch( signvalue );
		       --padlen;
		       signvalue = 0;
	       }
	       while( padlen > 0 ){
		       dopr_outch( zpad );
		       --padlen;
	       }
       }
       while( padlen > 0 ) {
	       dopr_outch( ' ' );
	       --padlen;
       }
       if( signvalue ) dopr_outch( signvalue );
       while( place > 0 ) dopr_outch( convert[--place] );
       while( padlen < 0 ){
	       dopr_outch( ' ' );
	       ++padlen;
       }
}

static void
dostr( str , cut)
     char *str;
     int cut;
{
  if (cut) {
    while(*str && cut-- > 0) dopr_outch(*str++);
  } else {
    while(*str) dopr_outch(*str++);
  }
}

static void
dopr_outch( c )
       int c;
{
#if 0
       if( iscntrl(c) && c != '\n' && c != '\t' ){
	       c = '@@' + (c & 0x1F);
	       if( DoprEnd == 0 || output < DoprEnd )
		       *output++ = '^';
       }
#endif
       if( DoprEnd == 0 || output < DoprEnd )
	       *output++ = c;
       else
		SnprfOverflow++;
}
/*
d2928 3
d2969 9
d3011 2
a3012 1
	if (shell == NULL || shell[0] == '\0' || wordinclass(user, 't'))
d3046 5
d3070 1
a3070 1
		while (*p != '\0' && *p != '#' && !isspace(*p))
d3182 2
d3185 1
a3185 1
			return fs.SFS_BAVAIL;
d3373 1
d3406 1
d3409 1
a3409 1
		printf("(%s) ", errstring(errno));
d3420 1
a3420 1
	if (errno == EINVAL)
d3427 1
a3427 1
	if (!bitset(LOCK_NB, type) || (errno != EACCES && errno != EAGAIN))
a3430 2
		int oerrno = errno;

d3432 1
a3432 1
		errno = oerrno;
d3453 1
d3456 1
a3456 1
		printf("(%s) ", errstring(errno));
d3458 1
a3458 1
	if (!bitset(LOCK_NB, type) || errno != EWOULDBLOCK)
a3461 2
		int oerrno = errno;

d3463 1
a3463 1
		errno = oerrno;
d3472 1
d3542 1
a3542 1
	if (ChownAlwaysSafe)
d3559 1
a3559 1
	return ChownAlwaysSafe;
d3619 1
a3619 1
		extern char *ni_propval();
d3710 7
d3778 2
a3779 2
**		TRUE -- if the connection should be accepted.
**		FALSE -- if it should be rejected.
d3791 1
a3791 1
bool
d3797 4
d3807 3
d3812 14
a3825 1
		return FALSE;
d3829 5
a3833 1
	if (!hosts_ctl("sendmail", hostname, anynet_ntoa(sap), STRING_UNKNOWN))
d3840 2
a3841 2
				hostname, anynet_ntoa(sap));
		return FALSE;
d3846 1
a3846 1
	return TRUE;
a3863 2
#include <limits.h>

d4200 3
d4412 2
d4415 1
d4524 1
a4524 1
#ifdef __hpux
d4598 1
a4598 1
#if HESIOD
d4604 1
a4604 1
#if LDAPMAP
d4607 3
d4625 1
a4625 1
#if NDBM
d4646 1
a4646 1
#if NEWDB
d4649 1
a4649 1
#if NIS
d4652 1
a4652 1
#if NISPLUS
d4667 1
a4667 1
#if SUID_ROOT_FILES_OK
d4679 1
a4679 1
#if XLA
@


1.8
log
@sendmail 8.8.7.
@
text
@d36 1
a36 1
static char sccsid[] = "@@(#)conf.c	8.374 (Berkeley) 8/2/97";
d1976 1
a1976 1
static char  rcsid[] = "@@(#)$Id: conf.c,v 1.7 1997/07/15 07:24:00 downsj Exp $";
a2068 1
	extern void setproctitle __P((const char *, ...));
d2227 1
a2227 1
	register int i;
d2236 1
a2236 1
		continue;
d2247 10
d2832 1
d2840 1
a2840 1
	register char	*oli;		/* option letter list index */
d2942 1
a2942 1
/*static char _id[] = "$Id: conf.c,v 1.7 1997/07/15 07:24:00 downsj Exp $";*/
d3857 1
a3857 1
    defined(_PC_CHOWN_RESTRICTED)
@


1.7
log
@Sendmail 8.8.6.
@
text
@d36 1
a36 1
static char sccsid[] = "@@(#)conf.c	8.362 (Berkeley) 6/14/97";
d180 4
d193 1
d241 1
d243 4
d425 7
d1976 1
a1976 1
static char  rcsid[] = "@@(#)$Id: conf.c,v 1.6 1997/01/22 01:07:03 downsj Exp $";
d2932 1
a2932 1
/*static char _id[] = "$Id: conf.c,v 1.6 1997/01/22 01:07:03 downsj Exp $";*/
d3846 2
a3847 2
#if !defined(_POSIX_CHOWN_RESTRICTED) || _POSIX_CHOWN_RESTRICTED != -1
# if defined(_PC_CHOWN_RESTRICTED)
d3862 1
a3862 1
#  if SAFENFSPATHCONF
d3864 1
a3864 1
#  else
a3865 1
#  endif
d4004 1
a4004 1
#ifdef SUN_EXTENSIONS
d4019 1
a4019 1
#ifdef SUN_EXTENSIONS
d4099 4
d4104 3
d4108 1
d4113 2
d4122 2
d4497 1
a4497 1
# ifdef SIOCGIFNUM
d5002 3
d5026 3
d5049 3
@


1.6
log
@Sendmail 8.8.5.
@
text
@d2 1
a2 1
 * Copyright (c) 1983, 1995, 1996 Eric P. Allman
d36 1
a36 1
static char sccsid[] = "@@(#)conf.c	8.333 (Berkeley) 1/21/97";
d143 3
d193 1
d240 1
a259 42
**  HOST_MAP_INIT -- initialize host class structures
*/

bool	host_map_init __P((MAP *map, char *args));

bool
host_map_init(map, args)
	MAP *map;
	char *args;
{
	register char *p = args;

	for (;;)
	{
		while (isascii(*p) && isspace(*p))
			p++;
		if (*p != '-')
			break;
		switch (*++p)
		{
		  case 'a':
			map->map_app = ++p;
			break;

		  case 'm':
			map->map_mflags |= MF_MATCHONLY;
			break;

		  case 't':
			map->map_mflags |= MF_NODEFER;
			break;
		}
		while (*p != '\0' && !(isascii(*p) && isspace(*p)))
			p++;
		if (*p != '\0')
			*p++ = '\0';
	}
	if (map->map_app != NULL)
		map->map_app = newstr(map->map_app);
	return TRUE;
}
/*
d334 2
a335 2
	        ldap_map_parseargs, ldap_map_open, ldap_map_close,
	        ldap_map_lookup, null_map_store);
d1028 1
d1030 3
d1495 2
a1496 2
        if (tTd(3, 1))
                printf("getla: %d\n", (int) (load_info.one_minute + 0.5));
d1527 2
a1528 2
        if (tTd(3, 1))
                printf("getla: %d\n", (int) (pstd.psd_avg_1_min + 0.5));
d1669 1
a1669 2
	uint32_t avenrun32[3];
	uint64_t avenrun64[3];
d1752 3
d1757 1
a1757 1
		    read(kmem, (char *) avenrun32, sizeof(avenrun32)) < sizeof(avenrun32))
d1764 1
a1764 14
		if (tTd(3, 5))
		{
			printf("getla: avenrun{32} = %ld",
				(long int) avenrun32[0]);
			if (tTd(3, 15))
				printf(", %ld, %ld",
					(long int)avenrun32[1],
					(long int)avenrun32[2]);
			printf("\n");
		}
		if (tTd(3, 1))
			printf("getla: %d\n",
				(int) (avenrun32[0] + FSCALE/2) >> FSHIFT);
		return ((int) (avenrun32[0] + FSCALE/2) >> FSHIFT);
d1769 2
a1770 2
		    read(kmem, (char *) avenrun64, sizeof(avenrun64)) <
					sizeof(avenrun64))
d1777 11
a1787 14
		if (tTd(3, 5))
		{
			printf("getla: avenrun{64} = %lld",
				(long long int) avenrun64[0]);
			if (tTd(3, 15))
				printf(", %lld, %lld",
					(long long int) avenrun64[1],
					(long long int) avenrun64[2]);
			printf("\n");
		}
		if (tTd(3, 1))
			printf("getla: %d\n",
				(int) (avenrun64[0] + FSCALE/2) >> FSHIFT);
		return ((int) (avenrun64[0] + FSCALE/2) >> FSHIFT);
d1789 4
a1792 1
	return -1;
d1872 3
a1874 1
			syslog(LOG_ERR, "can't open %s: %m", _PATH_AVENRUN);
d1959 1
a1959 1
static char  rcsid[] = "@@(#)$Id: conf.c,v 1.5 1996/12/14 21:17:07 downsj Exp $";
d1997 2
d2005 1
d2009 1
a2009 1
	if (CurrentLA < QueueLA)
d2023 1
a2023 1
	rval = pri > (QueueFactor / (CurrentLA - QueueLA + 1));
d2047 1
a2069 1
#ifdef LOG
d2071 2
a2072 1
			syslog(LOG_INFO, "deferring connections on port %d: %d per second",
a2073 1
#endif
d2078 1
a2078 1
	if (CurrentLA >= RefuseLA)
a2081 1
#ifdef LOG
d2083 2
a2084 1
			syslog(LOG_INFO, "rejecting connections on port %d: load average: %d",
a2085 1
#endif
a2092 1
#ifdef LOG
d2094 2
a2095 1
			syslog(LOG_INFO, "rejecting connections on port %d: min free: %d",
a2096 1
#endif
a2108 1
#ifdef LOG
d2110 2
a2111 1
				syslog(LOG_INFO, "rejecting connections on port %d: %d children, max %d",
a2112 1
#endif
d2141 1
d2166 1
a2166 1
# if SPT_TYPE == SPT_PSSTRINGS
d2215 1
a2215 1
        **  Move the environment so setproctitle can use the space at
d2317 4
d2326 50
a2402 1
#ifdef LOG
d2404 1
a2404 1
				syslog(LOG_ALERT,
a2406 1
#endif
d2420 8
a2427 1
	while ((pid = wait(&status)) > 0)
a2900 2
#if !HASSNPRINTF

d2904 1
a2904 1
 * A bombproof version of doprnt (dopr) included.
d2915 3
a2917 3
/*static char _id[] = "$Id: conf.c,v 1.5 1996/12/14 21:17:07 downsj Exp $";*/
static void dopr();
static char *end;
d2920 2
d2953 1
a2953 1
	end = str + count - 1;
d2955 1
a2955 1
	dopr( str, fmt, args );
d2957 1
a2957 1
		end[0] = 0;
d2964 3
d2968 1
a2968 1
 * dopr(): poor man's version of doprintf
d2976 1
d2979 1
a2979 1
dopr( buffer, format, args )
d2993 5
d3001 16
a3016 16
               switch( ch ){
               case '%':
                       ljust = len = zpad = maxwidth = 0;
                       longflag = pointflag = 0;
               nextch:
                       ch = *format++;
                       switch( ch ){
                       case 0:
                               dostr( "**end of format**" , 0);
                               return;
                       case '-': ljust = 1; goto nextch;
                       case '0': /* set zero padding if len not set */
                               if(len==0 && !pointflag) zpad = '0';
                       case '1': case '2': case '3':
                       case '4': case '5': case '6':
                       case '7': case '8': case '9':
d3021 1
a3021 1
                               goto nextch;
d3029 40
a3068 40
                       case 'l': longflag = 1; goto nextch;
                       case 'u': case 'U':
                               /*fmtnum(value,base,dosign,ljust,len,zpad) */
                               if( longflag ){
                                       value = va_arg( args, long );
                               } else {
                                       value = va_arg( args, int );
                               }
                               fmtnum( value, 10,0, ljust, len, zpad ); break;
                       case 'o': case 'O':
                               /*fmtnum(value,base,dosign,ljust,len,zpad) */
                               if( longflag ){
                                       value = va_arg( args, long );
                               } else {
                                       value = va_arg( args, int );
                               }
                               fmtnum( value, 8,0, ljust, len, zpad ); break;
                       case 'd': case 'D':
                               if( longflag ){
                                       value = va_arg( args, long );
                               } else {
                                       value = va_arg( args, int );
                               }
                               fmtnum( value, 10,1, ljust, len, zpad ); break;
                       case 'x':
                               if( longflag ){
                                       value = va_arg( args, long );
                               } else {
                                       value = va_arg( args, int );
                               }
                               fmtnum( value, 16,0, ljust, len, zpad ); break;
                       case 'X':
                               if( longflag ){
                                       value = va_arg( args, long );
                               } else {
                                       value = va_arg( args, int );
                               }
                               fmtnum( value,-16,0, ljust, len, zpad ); break;
                       case 's':
                               strvalue = va_arg( args, char *);
d3075 26
a3100 12
                       case 'c':
                               ch = va_arg( args, int );
                               dopr_outch( ch ); break;
                       case '%': dopr_outch( ch ); continue;
                       default:
                               dostr(  "???????" , 0);
                       }
                       break;
               default:
                       dopr_outch( ch );
                       break;
               }
d3113 1
a3113 1
               value = "<NULL>";
d3122 2
a3123 2
               dopr_outch( ' ' );
               --padlen;
d3127 2
a3128 2
               dopr_outch( ' ' );
               ++padlen;
d3145 1
a3145 1
               value, base, dosign, ljust, len, zpad )); */
d3148 4
a3151 4
               if( value < 0 ) {
                       signvalue = '-';
                       uvalue = -value;
               }
d3154 2
a3155 2
               caps = 1;
               base = -base;
d3158 4
a3161 4
               convert[place++] =
                       (caps? "0123456789ABCDEF":"0123456789abcdef")
                        [uvalue % (unsigned)base  ];
               uvalue = (uvalue / (unsigned)base );
d3168 1
a3168 1
               convert,place,signvalue,padlen)); */
d3170 9
a3178 9
               if( signvalue ){
                       dopr_outch( signvalue );
                       --padlen;
                       signvalue = 0;
               }
               while( padlen > 0 ){
                       dopr_outch( zpad );
                       --padlen;
               }
d3181 2
a3182 2
               dopr_outch( ' ' );
               --padlen;
d3187 2
a3188 2
               dopr_outch( ' ' );
               ++padlen;
d3210 3
a3212 3
               c = '@@' + (c & 0x1F);
               if( end == 0 || output < end )
                       *output++ = '^';
d3215 2
a3216 2
       if( end == 0 || output < end )
               *output++ = c;
a3219 4

# endif /* !luna2 */

#endif /* !HASSNPRINTF */
d3474 1
a3474 1
		if (fs.SFS_BAVAIL < 0)
a3522 1
#ifdef LOG
d3524 2
a3525 3
				syslog(LOG_ALERT,
					"%s: low on space (have %ld, %s needs %ld in %s)",
					CurEnv->e_id == NULL ? "[NOQUEUE]" : CurEnv->e_id,
a3528 1
#endif
d3634 1
a3634 1
	  case EOPENTIMEOUT:		/* PSEUDO: open timed out */
d3664 1
d3689 3
a3691 1
	if (fcntl(fd, action, &lfd) >= 0)
d3737 3
a3739 1
	if (flock(fd, type) >= 0)
d3770 40
d3812 1
d3815 2
a3816 2
**		TRUE -- if only root can chown the file to an arbitrary
**			user.
d3820 4
d3825 1
a3825 1
chownsafe(fd)
d3827 1
d3829 3
a3831 7
#ifdef __hpux
	char *s;
	int tfd;
	uid_t o_uid, o_euid;
	gid_t o_gid, o_egid;
	bool rval;
	struct stat stbuf;
d3833 3
a3835 25
	o_uid = getuid();
	o_euid = geteuid();
	o_gid = getgid();
	o_egid = getegid();
	fstat(fd, &stbuf);
	setresuid(stbuf.st_uid, stbuf.st_uid, -1);
	setresgid(stbuf.st_gid, stbuf.st_gid, -1);
	s = tmpnam(NULL);
	tfd = open(s, O_RDONLY|O_CREAT, 0600);
	rval = fchown(tfd, DefUid, DefGid) != 0;
	close(tfd);
	setresuid(o_uid, o_euid, -1);
	setresgid(o_gid, o_egid, -1);
	unlink(s);
	return rval;
#else
# ifdef _POSIX_CHOWN_RESTRICTED
#  if _POSIX_CHOWN_RESTRICTED == -1
	return FALSE;
#  else
	return TRUE;
#  endif
# else
#  ifdef _PC_CHOWN_RESTRICTED
	int rval;
d3845 2
a3846 5
	if (errno == 0)
		return rval > 0;
#  endif
#  ifdef BSD
	return TRUE;
d3848 1
a3848 1
	return FALSE;
d3851 2
a4088 1
# ifdef LOG
d4090 2
a4091 1
			syslog(LOG_NOTICE, "tcpwrappers (%s, %s) rejection",
a4092 1
# endif
d4445 1
a4445 1
#ifdef SIOCGIFCONF
d4458 1
a4458 1
#ifdef SIOCGIFCONF
d4461 2
a4462 2
        struct ifconf ifc;
	char interfacebuf[10240];
d4469 21
a4489 2
        ifc.ifc_buf = interfacebuf;
        ifc.ifc_len = sizeof interfacebuf;
a4513 1
		extern struct hostent *gethostbyaddr();
d4534 1
a4534 2
		if (!bitset(IFF_UP, ifrf.ifr_flags))
			continue;
d4536 3
a4538 1
		if (!bitset(IFF_UP, ifr->ifr_flags))
a4539 1
#endif
d4562 1
a4562 1
		if (strcmp("lo0", ifr->ifr_name) == 0)
a4568 1
#ifdef LOG
d4570 7
a4576 3
				syslog(LOG_WARNING,
					"gethostbyaddr() failed for %.100s\n",
					inet_ntoa(ia));
d4601 1
d4603 158
d4793 1
a4793 1
	char buf[SYSLOG_BUFSIZE * 2];
d4853 1
a4853 1
#ifdef LOG
d4935 3
d4974 3
d5004 3
d5012 3
@


1.5
log
@Update to Sendmail 8.8.4, plus recent patches, plus OpenBSD support.
Also include entire example configuration subset.
Includes smrsh (using /usr/libexec/sm.bin).

Of the top of my head, the only things I removed from the distribution were
contrib/mail.local.linux, src/Makefiles, all the *.0 and *.ps files.
Our praliases man page replaces the distributed one, ours is better.
@
text
@d36 1
a36 1
static char sccsid[] = "@@(#)conf.c	8.325 (Berkeley) 12/1/96";
a129 8
**  Location of system files/databases/etc.
*/

char	*PidFile =	_PATH_SENDMAILPID;	/* stores daemon proc id */



/*
d225 1
d1847 2
a1848 2
	kstat_ctl_t *kc;
	kstat_t *ksp;
d1852 2
a1853 1
	kc = kstat_open();
d1861 2
a1862 1
	ksp = kstat_lookup(kc, "unix", 0, "system_misc"); /* NULL on error */
d1867 1
a1867 1
				errstring(errno);
d1874 1
a1874 1
				errstring(errno);
d1878 2
a1879 2
	la = (ksn->value.ul + FSCALE/2) >> FSHIFT;
	kstat_close(kc);
d2001 1
a2001 1
static char  rcsid[] = "@@(#)$Id: getloadavg.c,v 1.16 1991/06/21 12:51:15 paul Exp $";
d2375 1
a2375 1
void
d2417 1
d2804 1
a2804 1
			return(EOF);
d2809 1
a2809 1
			return(EOF);
d2899 1
a2899 1
/*static char _id[] = "$Id: snprintf.c,v 1.2 1995/10/09 11:19:47 roberto Exp $";*/
d3691 1
d3721 1
d4012 2
d4015 1
a4015 1
int	deny_severity	= LOG_WARNING;
d4030 6
d4037 1
d4405 1
a4405 1
	char interfacebuf[1024];
d4775 3
@


1.4
log
@comment out unused typedef, nameclash on Amiga.
@
text
@d2 1
a2 1
 * Copyright (c) 1983, 1995 Eric P. Allman
d36 1
a36 1
static char sccsid[] = "@@(#)conf.c	8.243.1.9 (Berkeley) 9/17/96";
d81 9
a89 9
	"resent-sender",		H_FROM|H_RESENT,
	"resent-from",			H_FROM|H_RESENT,
	"resent-reply-to",		H_FROM|H_RESENT,
	"sender",			H_FROM,
	"from",				H_FROM,
	"reply-to",			H_FROM,
	"full-name",			H_ACHECK,
	"return-receipt-to",		H_FROM|H_RECEIPTTO,
	"errors-to",			H_FROM|H_ERRORSTO,
d92 7
a98 7
	"to",				H_RCPT,
	"resent-to",			H_RCPT|H_RESENT,
	"cc",				H_RCPT,
	"resent-cc",			H_RCPT|H_RESENT,
	"bcc",				H_RCPT|H_BCC,
	"resent-bcc",			H_RCPT|H_BCC|H_RESENT,
	"apparently-to",		H_RCPT,
d101 4
a104 4
	"message-id",			0,
	"resent-message-id",		H_RESENT,
	"message",			H_EOH,
	"text",				H_EOH,
d107 2
a108 2
	"date",				0,
	"resent-date",			H_RESENT,
d111 4
a114 4
	"received",			H_TRACE|H_FORCE,
	"x400-received",		H_TRACE|H_FORCE,
	"via",				H_TRACE|H_FORCE,
	"mail-from",			H_TRACE|H_FORCE,
d117 6
a122 5
	"comments",			H_FORCE,
	"return-path",			H_FORCE|H_ACHECK,
	"content-transfer-encoding",	H_CTE,
	"content-type",			H_CTYPE,
	"content-length",		H_ACHECK,
d124 1
a124 1
	NULL,			0,
d143 12
a154 12
	"public",		PRIV_PUBLIC,
	"needmailhelo",		PRIV_NEEDMAILHELO,
	"needexpnhelo",		PRIV_NEEDEXPNHELO,
	"needvrfyhelo",		PRIV_NEEDVRFYHELO,
	"noexpn",		PRIV_NOEXPN,
	"novrfy",		PRIV_NOVRFY,
	"restrictmailq",	PRIV_RESTRICTMAILQ,
	"restrictqrun",		PRIV_RESTRICTQRUN,
	"authwarnings",		PRIV_AUTHWARNINGS,
	"noreceipts",		PRIV_NORECEIPTS,
	"goaway",		PRIV_GOAWAY,
	NULL,			0,
d231 1
d237 1
d239 1
d285 8
d313 1
a313 1
	strcpy(buf, "prog, P=/bin/sh, F=lsoD, T=DNS/RFC822/X-Unix, A=sh -c \201u");
d316 1
a316 1
	strcpy(buf, "*file*, P=[FILE], F=lsDFMPEou, T=DNS/RFC822/X-Unix, A=FILE");
d319 1
a319 1
	strcpy(buf, "*include*, P=/dev/null, F=su, A=INCLUDE");
d376 5
d588 1
a588 1
			strcpy(buf, "aliases.netinfo netinfo /aliases");
a691 1
	register FILE *fp;
a692 1
	static char buf[MAXLINE];
a697 1
	int nsw_rc;
d778 3
d784 1
a784 3
	svcno = 0;
	fp = fopen(ServiceSwitchFile, "r");
	if (fp != NULL)
d786 7
a792 1
		while (fgets(buf, sizeof buf, fp) != NULL)
d794 1
a794 1
			register char *p;
d796 3
a798 8
			p = strpbrk(buf, "#\n");
			if (p != NULL)
				*p = '\0';
			p = strpbrk(buf, " \t");
			if (p != NULL)
				*p++ = '\0';
			if (strcmp(buf, service) != 0)
				continue;
d800 8
a807 3
			/* got the right service -- extract data */
			do
			{
d811 22
a832 4
					break;
				maptype[svcno++] = p;
				p = strpbrk(p, " \t");
				if (p != NULL)
d834 6
a839 1
			} while (p != NULL);
a840 1
			return svcno;
d842 1
d844 13
a856 2
		/* service was not found -- use compiled in default */
		fclose(fp);
d1077 4
d1082 1
a1082 1
# ifdef SA_RESTART
d1084 1
d1092 42
d1140 2
a1141 1
**		0 on success.
d1150 1
a1150 1
	return sigsetmask(sigblock(0) & ~(1 << sig));
d1152 10
a1161 1
	sigset_t sset;
d1165 5
a1169 1
	return sigprocmask(SIG_UNBLOCK, &sset, NULL);
d1216 5
a1220 1
# include	<compat.h>
d1232 23
d1307 4
a1325 3
# if defined(_AIX3)
#  define FSHIFT	16
# endif
d1377 1
a1394 10
		kmem = open(_PATH_KMEM, 0, 0);
		if (kmem < 0)
		{
			if (tTd(3, 1))
				printf("getla: open(/dev/kmem): %s\n",
					errstring(errno));
			return (-1);
		}
		(void) fcntl(kmem, F_SETFD, 1);

d1400 1
a1400 1
#ifdef _AIX3
d1421 10
d1433 2
a1434 1
		printf("getla: symbol address = %#x\n", Nl[X_AVENRUN].n_value);
d1446 1
d1450 5
d1607 1
d1618 3
d1622 1
d1628 2
d1632 2
d1686 283
d1971 1
a1980 1

d2006 1
a2006 1
static char  rcsid[] = "@@(#)Id: getloadavg.c,v 1.16 1991/06/21 12:51:15 paul Exp ";
d2052 1
a2052 1
		printf("shouldqueue: CurrentLA=%d, pri=%d: ", CurrentLA, pri);
d2076 1
a2076 1
**		none.
d2088 2
a2089 1
refuseconnections()
d2091 3
d2102 20
d2124 8
a2131 2
		setproctitle("rejecting connections: load average: %d",
			CurrentLA);
d2133 2
a2134 1
	else if (!enoughdiskspace(MinBlocksFree + 1))
d2136 8
a2143 2
		setproctitle("rejecting connections: min free: %d",
			MinBlocksFree);
d2145 2
a2146 1
	else if (MaxChildren > 0 && CurChildren >= MaxChildren)
d2148 14
a2161 2
		setproctitle("rejecting connections: maximum children: %d",
			CurChildren);
d2163 2
a2164 3
	else
		return FALSE;
	return TRUE;
d2207 1
a2207 1
/*typedef unsigned int	*pt_entry_t; */
d2319 1
a2319 1
	(void) vsnprintf(p, sizeof buf - (p - buf), fmt, ap);
d2348 1
a2348 1
	if (lseek(kmem, (char *) seek_off, SEEK_SET) == seek_off)
d2385 1
a2388 1
	int pid;
d2396 4
a2399 2
			syslog(LOG_ALERT, "reapchild: waitpid loop: pid=%d, status=%x",
				pid, status);
d2403 1
a2403 1
		CurChildren--;
d2409 2
a2410 2
	while (wait3(&status, WNOHANG, (struct rusage *) NULL) > 0)
		CurChildren--;
d2414 2
a2415 2
	while (wait(&status) > 0)
		CurChildren--;
d2456 1
a2456 1
	if ((tmp = index(str, '=')) == NULL || tmp == str)
d2820 1
a2820 1
	if (*++oli != ':') {		/* don't need argument */
d2903 1
a2903 1
/*static char _id[] = "$Id: conf.c,v 1.3 1996/09/19 06:44:53 fn Exp $";*/
d2906 1
d2920 2
a2921 1
    VA_LOCAL_DECL
d2923 4
a2926 4
    VA_START (fmt);
    (void) vsnprintf ( str, count, fmt, ap);
    VA_END;
       return( strlen( str ) );
d2933 4
a2936 4
       char *str;
       size_t count;
       const char *fmt;
       va_list args;
d2938 10
a2947 7
       str[0] = 0;
       end = str+count-1;
       dopr( str, fmt, args );
       if( count>0 ){
               end[0] = 0;
       }
       return(strlen(str));
d2963 1
a2963 1
       char *format;
d3046 3
a3048 1
			       if (maxwidth > 0 || !pointflag)
d3050 1
d3174 1
a3174 1
               if( end == 0 || output < end ){
a3175 1
               }
d3178 1
a3178 1
       if( end == 0 || output < end ){
d3180 2
a3181 1
       }
d3205 1
a3205 1
# ifdef _AIX3
d3233 1
a3233 1
#ifdef _AIX3
a3764 1
	unlink(s);
d3767 1
d3812 1
a3812 1
# ifdef apollo
d3920 4
d3928 12
d3947 86
d4034 2
d4192 2
a4193 2
#if defined(SOLARIS) && SOLARIS < 204 || defined(sony_news) && defined(__svr4)
# if SOLARIS == 203
d4230 1
a4230 1
			if (strlen(name) > sizeof hbuf - 1)
d4261 2
a4262 2
#if defined(SOLARIS) && SOLARIS < 204
# if SOLARIS == 203
d4285 5
d4291 1
d4298 5
d4304 1
d4307 62
a4413 1
	close(s);
d4426 3
d4443 12
a4454 1
		/* for some reason gcc 2.3 pukes on || here */
d4457 1
a4457 2
		if (ifr->ifr_addr.sa_family != AF_INET)
			continue;
d4461 6
d4471 1
a4471 1
			inet_ntoa(((struct sockaddr_in *) sa)->sin_addr));
d4487 6
a4492 2
			syslog(LOG_CRIT, "gethostbyaddr() failed for %.100s\n",
				inet_ntoa(ia));
d4516 1
d4530 7
d4538 1
d4540 1
a4540 2
void
hard_syslog(int pri, char *msg, ...)
d4544 1
a4544 1
	char *msg;
d4556 1
a4556 1
	for (i = MAXSYSLOGTRIES; --i >= 0 && syslog(pri, "%s", buf) < 0; )
d4560 1
d4606 3
d4615 3
d4654 3
d4660 6
d4669 3
d4697 3
d4712 3
d4718 3
d4727 3
d4733 6
d4751 9
d4765 3
@


1.3
log
@bring up to 8.7.6
@
text
@d1714 1
a1714 1
typedef unsigned int	*pt_entry_t;
d2408 1
a2408 1
/*static char _id[] = "$Id: snprintf.c,v 1.2 1995/10/09 11:19:47 roberto Exp $";*/
@


1.2
log
@Sendmail 8.7.3 from NetBSD
@
text
@d36 1
a36 1
static char sccsid[] = "@@(#)conf.c	8.243 (Berkeley) 11/20/95";
d253 3
a255 4
	if ((defpwent = sm_getpwuid(DefUid)) != NULL)
		strcpy(defuserbuf, defpwent->pw_name);
	else
		strcpy(defuserbuf, "nobody");
d2387 3
a2389 1
**	These are at best crude emulations.
d2394 20
a2413 1
void
d2415 1
a2415 1
snprintf(char *buf, size_t bufsize, const char *fmt, ...)
d2417 3
a2419 3
snprintf(buf, bufsize, fmt, va_alist)
	char *buf;
	size_t bufsize;
d2422 1
a2422 1
# endif
d2424 8
a2431 1
	VA_LOCAL_DECL
d2433 15
a2447 8
	VA_START(fmt);
	vsprintf(buf, fmt, ap);
	VA_END;
# if defined(XDEBUG) && defined(LOG)
	if (strlen(buf) > bufsize)
		syslog(LOG_ALERT, "INTERNAL ERROR: snprintf overflow: %s",
			shortenstring(buf, 200));
# endif
d2450 3
d2454 213
a2666 7
#ifndef luna2
void
vsnprintf(buf, bufsize, fmt, ap)
	char *buf;
	size_t bufsize;
	const char *fmt;
	va_list ap;
d2668 11
a2678 6
	vsprintf(buf, fmt, ap);
# if defined(XDEBUG) && defined(LOG)
	if (strlen(buf) > bufsize)
		syslog(LOG_ALERT, "INTERNAL ERROR: vsnprintf overflow: %s",
			shortenstring(buf, 200));
# endif
a2679 1
#endif
d2681 3
a2683 1
#endif
d3314 3
d3327 4
d3334 1
d3337 1
d3770 1
a3770 1
		(void) sprintf(ip_addr, "[%.*s]",
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
 * Copyright (c) 1983 Eric P. Allman
d36 1
a36 1
static char sccsid[] = "@@(#)conf.c	8.89.1.3 (Berkeley) 3/7/95";
a42 2
# include <netdb.h>
# include <pwd.h>
d81 9
a89 9
	"resent-sender",	H_FROM|H_RESENT,
	"resent-from",		H_FROM|H_RESENT,
	"resent-reply-to",	H_FROM|H_RESENT,
	"sender",		H_FROM,
	"from",			H_FROM,
	"reply-to",		H_FROM,
	"full-name",		H_ACHECK,
	"return-receipt-to",	H_FROM|H_RECEIPTTO,
	"errors-to",		H_FROM|H_ERRORSTO,
d92 7
a98 7
	"to",			H_RCPT,
	"resent-to",		H_RCPT|H_RESENT,
	"cc",			H_RCPT,
	"resent-cc",		H_RCPT|H_RESENT,
	"bcc",			H_RCPT|H_ACHECK,
	"resent-bcc",		H_RCPT|H_ACHECK|H_RESENT,
	"apparently-to",	H_RCPT,
d101 4
a104 4
	"message-id",		0,
	"resent-message-id",	H_RESENT,
	"message",		H_EOH,
	"text",			H_EOH,
d107 2
a108 2
	"date",			0,
	"resent-date",		H_RESENT,
d111 4
a114 4
	"received",		H_TRACE|H_FORCE,
	"x400-received",	H_TRACE|H_FORCE,
	"via",			H_TRACE|H_FORCE,
	"mail-from",		H_TRACE|H_FORCE,
d117 5
a121 2
	"comments",		H_FORCE,
	"return-path",		H_FORCE|H_ACHECK,
a162 19


/*
**  Following should be config parameters (and probably will be in
**  future releases).  In the meantime, setting these is considered
**  unsupported, and is intentionally undocumented.
*/

#ifdef BROKENSMTPPEERS
bool	BrokenSmtpPeers = TRUE;		/* set if you have broken SMTP peers */
#else
bool	BrokenSmtpPeers = FALSE;	/* set if you have broken SMTP peers */
#endif
#ifdef NOLOOPBACKCHECK
bool	CheckLoopBack = FALSE;		/* set to check HELO loopback */
#else
bool	CheckLoopBack = TRUE;		/* set to check HELO loopback */
#endif

d180 7
a186 1
#define DAYS		* 24 * 60 * 60
d188 1
d192 6
d213 1
a213 1
	SevenBit = FALSE;			/* option 7 */
d215 1
a215 1
	MciCacheTimeout = 300;			/* option K */
d217 1
a217 3
	settimeouts(NULL);			/* option r */
	TimeOuts.to_q_return = 5 DAYS;		/* option T */
	TimeOuts.to_q_warning = 0;		/* option T */
d219 17
d246 1
d253 1
a253 1
	if ((defpwent = getpwuid(DefUid)) != NULL)
d262 1
a262 1
bool host_map_init __P((MAP *map, char *args));
d296 1
d300 1
d302 1
a302 1
	strcpy(buf, "prog, P=/bin/sh, F=lsD, A=sh -c $u");
d305 1
a305 1
	strcpy(buf, "*file*, P=/dev/null, F=lsDFMPEu, A=FILE");
d333 1
d342 1
d356 14
a369 2
		map_parseargs, nis_map_open, nis_map_close,
		nis_map_lookup, nis_map_store);
d372 27
d400 1
a400 1
		map_parseargs, stab_map_open, stab_map_close,
d407 4
a410 4
	/* host DNS lookup */
	MAPDEF("host", NULL, 0,
		host_map_init, null_map_open, null_map_close,
		host_map_lookup, null_map_store);
d417 1
a417 2
#if 0
# ifdef USERDB
d419 2
a420 2
	MAPDEF("udb", ".db", 0,
		udb_map_parse, null_map_open, null_map_close,
a421 1
# endif
d423 20
d447 393
d868 1
a868 1
			pw = getpwuid(RealUid);
d877 1
a877 1
			if ((pw = getpwnam(myname)) == NULL ||
d880 1
a880 1
				pw = getpwuid(uid);
d957 8
a964 5
**	message should be given using "usrerr" and 0 should
**	be returned.
**
**	'NoReturn' can be set to suppress the return-to-sender
**	function; this should be done on huge messages.
d976 1
d995 1
a995 1
	if (s != NULL && e->e_from.q_mailer != LocalMailer &&
d999 2
a1000 1
		/* NoReturn = TRUE; to supress return copy */
d1017 1
a1017 1
#if defined(SYS5SIGNALS) || defined(BSD4_3) || defined(_AUX_SOURCE)
d1024 3
d1033 25
d1070 1
d1089 1
d1104 1
d1112 26
d1162 3
d1171 17
a1187 1
#if (LA_TYPE == LA_INT) || (LA_TYPE == LA_FLOAT) || (LA_TYPE == LA_SHORT)
d1189 3
a1191 1
#include <nlist.h>
d1201 13
d1223 4
a1226 1
struct	nlist Nl[] =
a1228 1
#define	X_AVENRUN	0
a1230 17

#ifndef FSHIFT
# if defined(unixpc)
#  define FSHIFT	5
# endif

# if defined(__alpha) || defined(IRIX)
#  define FSHIFT	10
# endif
#endif

#ifndef FSHIFT
# define FSHIFT		8
#endif

#ifndef FSCALE
# define FSCALE		(1 << FSHIFT)
d1232 1
d1246 1
a1247 1
	extern int errno;
d1251 1
a1251 1
		kmem = open("/dev/kmem", 0, 0);
d1260 9
d1270 1
d1284 2
a1285 2
#ifdef IRIX
		Nl[X_AVENRUN].n_value &= 0x7fffffff;
d1290 1
a1290 1
	if (lseek(kmem, (off_t) Nl[X_AVENRUN].n_value, 0) == -1 ||
d1298 1
a1298 1
#if (LA_TYPE == LA_INT) || (LA_TYPE == LA_SHORT)
d1309 1
a1309 1
#else
d1320 48
a1367 1
#endif
d1370 1
a1370 2
#else
#if LA_TYPE == LA_SUBR
d1372 1
a1372 1
#ifdef DGUX
d1374 1
a1374 1
#include <sys/dg_sys_info.h>
d1376 2
a1377 1
int getla()
d1384 3
d1390 35
a1424 1
#else
d1426 1
d1442 2
a1443 2
#endif /* DGUX */
#else
d1477 1
a1478 1
#else
d1501 1
a1501 1
	if (fp == NULL) 
d1524 3
a1526 1
#else
d1535 1
a1535 4
#endif
#endif
#endif
#endif
d1606 4
d1611 3
d1615 6
a1620 1
	if (CurrentLA >= RefuseLA)
d1622 6
a1627 1
	return (pri > (QueueFactor / (CurrentLA - QueueLA + 1)));
d1641 1
a1641 1
**		none.
d1647 3
d1655 18
a1672 2
	/* this is probably too simplistic */
	return (CurrentLA >= RefuseLA);
d1689 15
a1703 5
#ifdef SETPROCTITLE
# ifdef HASSETPROCTITLE
   *** ERROR ***  Cannot have both SETPROCTITLE and HASSETPROCTITLE defined
# endif
# ifdef __hpux
d1706 1
a1706 1
# ifdef BSD4_4
d1709 8
a1716 3
#  ifdef __bsdi__
#   undef PS_STRINGS	/* BSDI 1.0 doesn't do PS_STRINGS as we expect */
#   define PROCTITLEPAD	'\0'
d1718 20
a1737 2
#  ifdef PS_STRINGS
#   define SETPROC_STATIC static
d1740 7
a1746 2
# ifndef SETPROC_STATIC
#  define SETPROC_STATIC
a1747 1
#endif
d1749 43
a1791 3
#ifndef PROCTITLEPAD
# define PROCTITLEPAD	' '
#endif
a1792 1
#ifndef HASSETPROCTITLE
d1795 4
a1798 3
#ifdef __STDC__
setproctitle(char *fmt, ...)
#else
d1800 1
a1800 1
	char *fmt;
d1802 1
a1802 1
#endif
d1804 1
a1804 1
# ifdef SETPROCTITLE
d1807 1
a1807 1
	SETPROC_STATIC char buf[MAXLINE];
d1809 1
a1809 1
#  ifdef __hpux
d1812 6
a1817 2
	extern char **Argv;
	extern char *LastArgv;
d1827 1
a1827 1
	(void) vsprintf(p, fmt, ap);
d1832 1
a1832 1
#  ifdef __hpux
d1835 2
a1836 2
#  else
#   ifdef PS_STRINGS
d1839 21
a1859 1
#   else
d1868 2
a1869 2
		*p++ = PROCTITLEPAD;
#   endif
d1871 1
a1871 1
# endif /* SETPROCTITLE */
d1874 1
a1874 1
#endif
d1879 1
a1879 1
**		none.
d1889 2
a1890 1
reapchild()
d1909 1
d1916 1
a1916 1
		continue;
d1921 1
a1921 1
		continue;
d1930 101
d2168 1
a2168 1
	
d2237 2
a2238 1
**	instead of a long.  This patches things.
d2241 1
a2241 1
#ifdef DGUX
d2284 2
a2285 1
extern int	optind, opterr;
a2288 1
#endif
d2291 1
d2351 52
a2402 5

vfprintf(fp, fmt, ap)
	FILE *	fp;
	char *	fmt;
	char **	ap;
d2404 1
a2404 2
	char *	bp[MAXARG];
	int	i = 0;
d2406 8
a2413 6
	while (*ap && i < MAXARG)
		bp[i++] = *ap++;
	fprintf(fp, fmt, bp[0], bp[1], bp[2], bp[3],
			 bp[4], bp[5], bp[6], bp[7],
			 bp[8], bp[9], bp[10], bp[11],
			 bp[12], bp[13], bp[14], bp[15]);
a2415 7
vsprintf(s, fmt, ap)
	char *	s;
	char *	fmt;
	char **	ap;
{
	char *	bp[MAXARG];
	int	i = 0;
d2417 14
a2430 6
	while (*ap && i < MAXARG)
		bp[i++] = *ap++;
	sprintf(s, fmt, bp[0], bp[1], bp[2], bp[3],
			bp[4], bp[5], bp[6], bp[7],
			bp[8], bp[9], bp[10], bp[11],
			bp[12], bp[13], bp[14], bp[15]);
d2432 1
d2439 1
d2453 5
d2460 1
a2460 1
	"/bin/sh",
d2462 1
a2462 1
	"/bin/csh",
d2465 11
a2475 3
	"/bin/rsh",
	"/bin/ksh",
	"/bin/rksh",
d2477 1
a2477 1
	"/usr/bin/keysh",
d2479 13
d2501 2
a2502 1
usershellok(shell)
d2509 2
a2510 1
	if (shell == NULL || shell[0] == '\0')
d2520 3
d2526 1
a2526 1
	if (shell == NULL || shell[0] == '\0')
d2529 26
d2593 1
a2593 1
**  FREESPACE -- see how much free space is on the queue filesystem
d2640 1
a2640 1
freespace(dir, bsize)
d2649 1
a2649 1
#  define f_bavail	f_tfree
d2653 2
a2654 2
#   define f_bavail	fd_bfreen
#   define FSBLOCKSIZE	fs.fd_bsize
d2658 1
a2658 1
#    define FSBLOCKSIZE	fs.f_bsize
a2661 3
#    if defined(_SCO_unix_) || defined(IRIX) || defined(apollo)
#     define f_bavail f_bfree
#    endif
d2665 3
a2667 1
	extern int errno;
d2675 4
a2678 1
#   if defined(ultrix)
d2680 1
a2680 1
#   else
d2682 1
d2689 4
a2692 1
		return (fs.f_bavail);
d2698 1
a2698 1
**  ENOUGHSPACE -- check to see if there is enough free space on the queue fs
d2713 1
a2713 1
enoughspace(msize)
d2721 1
a2721 1
			printf("enoughspace: no threshold\n");
d2725 1
a2725 1
	if ((bfree = freespace(QueueDir, &bsize)) >= 0)
d2728 1
a2728 1
			printf("enoughspace: bavail=%ld, need=%ld\n",
d2742 4
a2745 2
					CurEnv->e_id, bfree,
					CurHostName, msize, QueueDir);
d2751 1
a2751 1
		printf("enoughspace failure: min=%ld, need=%ld: %s\n",
d2852 1
d2888 1
a2888 1
		
d3014 1
a3014 1
	setreuid(o_uid, o_euid);
d3026 15
a3040 1
	return fpathconf(fd, _PC_CHOWN_RESTRICTED) > 0;
a3041 3
#   ifdef BSD
	return TRUE;
#   else
a3042 1
#   endif
d3048 34
d3090 1
d3093 1
a3093 1
#ifdef NETINFO
d3098 2
a3099 1
		cflocation = ni_propval("/locations/sendmail", "sendmail.cf");
d3104 1
d3129 2
d3132 1
d3136 8
d3147 25
d3277 5
a3281 1
**  SOLARIS_GETHOSTBY{NAME,ADDR} -- compatibility routines for gethostbyXXX
d3283 4
a3286 2
**	Solaris versions prior through 2.3 don't properly deliver a
**	canonical h_name field.  This tries to work around it.
d3289 22
a3310 1
#ifdef SOLARIS
d3312 9
a3320 1
extern int	h_errno;
d3323 2
a3324 2
solaris_gethostbyname(name)
	const char *name;
d3326 3
a3328 1
# ifdef SOLARIS_2_3
d3333 3
a3335 1
	return _switch_gethostbyname_r(name, &hp, buf, sizeof(buf), &h_errno);
d3339 3
a3341 1
	return __switch_gethostbyname(name);
d3343 45
d3391 2
a3392 2
solaris_gethostbyaddr(addr, len, type)
	const char *addr;
d3396 2
a3397 1
# ifdef SOLARIS_2_3
d3408 13
d3423 6
a3428 1
#endif
d3430 1
a3430 1
**  NI_PROPVAL -- netinfo property value lookup routine
d3433 1
a3433 2
**		directory -- the Netinfo directory name.
**		propname -- the Netinfo property name.
d3436 1
a3436 6
**		NULL -- if:
**			1. the directory is not found
**			2. the property name is not found
**			3. the property contains multiple values
**			4. some error occured
**		else -- the location of the config file.
d3438 2
a3439 2
**	Notes:
**      	Caller should free the return value of ni_proval
d3442 9
a3450 1
#ifdef NETINFO
d3452 2
a3453 10
# include <netinfo/ni.h>

# define LOCAL_NETINFO_DOMAIN    "."
# define PARENT_NETINFO_DOMAIN   ".."
# define MAX_NI_LEVELS           256

char *
ni_propval(directory, propname)
	char *directory;
	char *propname;
d3455 2
a3456 1
	char *propval = NULL;
d3458 2
a3459 5
	void *ni = NULL;
	void *lastni = NULL;
	ni_status nis;
	ni_id nid;
	ni_namelist ninl;
d3461 37
a3497 7
	/*
	**  If the passed directory and property name are found
	**  in one of netinfo domains we need to search (starting
	**  from the local domain moving all the way back to the
	**  root domain) set propval to the property's value
	**  and return it.
	*/
d3499 2
a3500 13
	for (i = 0; i < MAX_NI_LEVELS; ++i)
	{
		if (i == 0)
		{
			nis = ni_open(NULL, LOCAL_NETINFO_DOMAIN, &ni);
		}
		else
		{
			if (lastni != NULL)
				ni_free(lastni);
			lastni = ni;
			nis = ni_open(lastni, PARENT_NETINFO_DOMAIN, &ni);
		}
d3502 5
a3506 7
		/*
		**  Don't bother if we didn't get a handle on a
		**  proper domain.  This is not necessarily an error.
		**  We would get a positive ni_status if, for instance
		**  we never found the directory or property and tried
		**  to open the parent of the root domain!
		*/
d3508 2
a3509 2
		if (nis != 0)
			break;
d3511 10
a3520 3
		/*
		**  Find the path to the server information.
		*/
d3522 2
a3523 1
		if (ni_pathsearch(ni, &nid, directory) != 0)
d3526 6
a3531 5
		/*
		**  Find "host" information.
		*/

		if (ni_lookupprop(ni, &nid, propname, &ninl) != 0)
d3533 1
d3535 7
a3541 5
		/*
		**  If there's only one name in
		**  the list, assume we've got
		**  what we want.
		*/
d3543 2
a3544 1
		if (ninl.ni_namelist_len == 1)
d3546 7
a3552 2
			propval = ni_name_dup(ninl.ni_namelist_val[0]);
			break;
d3555 1
a3555 11

	/*
	**  Clean up.
	*/

	if (ni != NULL)
		ni_free(ni);
	if (lastni != NULL && ni != lastni)
		ni_free(lastni);

	return propval;
a3556 2

#endif /* NETINFO */
d3570 1
d3584 1
a3584 1
	vsprintf(buf, msg, ap);
d3592 164
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@


1.1.1.2
log
@sendmail 8.9.1
@
text
@d2 1
a2 2
 * Copyright (c) 1998 Sendmail, Inc.  All rights reserved.
 * Copyright (c) 1983, 1995-1997 Eric P. Allman.  All rights reserved.
d6 15
a20 3
 * By using this file, you agree to the terms and conditions set
 * forth in the LICENSE file which can be found at the top level of
 * the sendmail distribution.
d22 11
d36 1
a36 1
static char sccsid[] = "@@(#)conf.c	8.431 (Berkeley) 6/25/98";
d43 2
a44 1
# include <limits.h>
d68 2
d83 9
a91 9
	{ "resent-sender",		H_FROM|H_RESENT			},
	{ "resent-from",		H_FROM|H_RESENT			},
	{ "resent-reply-to",		H_FROM|H_RESENT			},
	{ "sender",			H_FROM				},
	{ "from",			H_FROM				},
	{ "reply-to",			H_FROM				},
	{ "errors-to",			H_FROM|H_ERRORSTO		},
	{ "full-name",			H_ACHECK			},
	{ "return-receipt-to",		H_RECEIPTTO			},
d94 7
a100 7
	{ "to",				H_RCPT				},
	{ "resent-to",			H_RCPT|H_RESENT			},
	{ "cc",				H_RCPT				},
	{ "resent-cc",			H_RCPT|H_RESENT			},
	{ "bcc",			H_RCPT|H_BCC			},
	{ "resent-bcc",			H_RCPT|H_BCC|H_RESENT		},
	{ "apparently-to",		H_RCPT				},
d103 4
a106 4
	{ "message-id",			0				},
	{ "resent-message-id",		H_RESENT			},
	{ "message",			H_EOH				},
	{ "text",			H_EOH				},
d109 2
a110 2
	{ "date",			0				},
	{ "resent-date",		H_RESENT			},
d113 4
a116 4
	{ "received",			H_TRACE|H_FORCE			},
	{ "x400-received",		H_TRACE|H_FORCE			},
	{ "via",			H_TRACE|H_FORCE			},
	{ "mail-from",			H_TRACE|H_FORCE			},
d119 2
a120 6
	{ "comments",			H_FORCE|H_ENCODABLE		},
	{ "return-path",		H_FORCE|H_ACHECK		},
	{ "content-transfer-encoding",	H_CTE				},
	{ "content-type",		H_CTYPE				},
	{ "content-length",		H_ACHECK			},
	{ "subject",			H_ENCODABLE			},
d122 1
a122 1
	{ NULL,				0				}
d128 8
d141 12
a152 14
	{ "public",		PRIV_PUBLIC		},
	{ "needmailhelo",	PRIV_NEEDMAILHELO	},
	{ "needexpnhelo",	PRIV_NEEDEXPNHELO	},
	{ "needvrfyhelo",	PRIV_NEEDVRFYHELO	},
	{ "noexpn",		PRIV_NOEXPN		},
	{ "novrfy",		PRIV_NOVRFY		},
	{ "restrictmailq",	PRIV_RESTRICTMAILQ	},
	{ "restrictqrun",	PRIV_RESTRICTQRUN	},
	{ "noetrn",		PRIV_NOETRN		},
	{ "noverb",		PRIV_NOVERB		},
	{ "authwarnings",	PRIV_AUTHWARNINGS	},
	{ "noreceipts",		PRIV_NORECEIPTS		},
	{ "goaway",		PRIV_GOAWAY		},
	{ NULL,			0			}
d155 2
d158 1
a158 1
**  DontBlameSendmail values
d160 2
a161 46
struct dbsval DontBlameSendmailValues[] =
{
	{ "safe",			DBS_SAFE			},
	{ "assumesafechown",		DBS_ASSUMESAFECHOWN		},
	{ "groupwritabledirpathsafe",	DBS_GROUPWRITABLEDIRPATHSAFE	},
	{ "groupwritableforwardfilesafe",
					DBS_GROUPWRITABLEFORWARDFILESAFE },
	{ "groupwritableincludefilesafe",
					DBS_GROUPWRITABLEINCLUDEFILESAFE },
	{ "groupwritablealiasfile",	DBS_GROUPWRITABLEALIASFILE	},
	{ "worldwritablealiasfile",	DBS_WORLDWRITABLEALIASFILE	},
	{ "forwardfileinunsafedirpath",	DBS_FORWARDFILEINUNSAFEDIRPATH	},
	{ "includefileinunsafedirpath",	DBS_INCLUDEFILEINUNSAFEDIRPATH	},
	{ "mapinunsafedirpath",		DBS_MAPINUNSAFEDIRPATH	},
	{ "linkedaliasfileinwritabledir",
					DBS_LINKEDALIASFILEINWRITABLEDIR },
	{ "linkedclassfileinwritabledir",
					DBS_LINKEDCLASSFILEINWRITABLEDIR },
	{ "linkedforwardfileinwritabledir",
					DBS_LINKEDFORWARDFILEINWRITABLEDIR },
	{ "linkedincludefileinwritabledir",
					DBS_LINKEDINCLUDEFILEINWRITABLEDIR },
	{ "linkedmapinwritabledir",	DBS_LINKEDMAPINWRITABLEDIR	},
	{ "linkedserviceswitchfileinwritabledir",
					DBS_LINKEDSERVICESWITCHFILEINWRITABLEDIR },
	{ "filedeliverytohardlink",	DBS_FILEDELIVERYTOHARDLINK	},
	{ "filedeliverytosymlink",	DBS_FILEDELIVERYTOSYMLINK	},
	{ "writemaptohardlink",		DBS_WRITEMAPTOHARDLINK		},
	{ "writemaptosymlink",		DBS_WRITEMAPTOSYMLINK		},
	{ "writestatstohardlink",	DBS_WRITESTATSTOHARDLINK	},
	{ "writestatstosymlink",	DBS_WRITESTATSTOSYMLINK		},
	{ "forwardfileingroupwritabledirpath",
					DBS_FORWARDFILEINGROUPWRITABLEDIRPATH },
	{ "includefileingroupwritabledirpath",
					DBS_INCLUDEFILEINGROUPWRITABLEDIRPATH },
	{ "classfileinunsafedirpath",	DBS_CLASSFILEINUNSAFEDIRPATH	},
	{ "errorheaderinunsafedirpath",	DBS_ERRORHEADERINUNSAFEDIRPATH	},
	{ "helpfileinunsafedirpath",	DBS_HELPFILEINUNSAFEDIRPATH	},
	{ "forwardfileinunsafedirpathsafe",
					DBS_FORWARDFILEINUNSAFEDIRPATHSAFE },
	{ "includefileinunsafedirpathsafe",
					DBS_INCLUDEFILEINUNSAFEDIRPATHSAFE },
	{ "runprograminunsafedirpath",	DBS_RUNPROGRAMINUNSAFEDIRPATH	},
	{ "runwritableprogram",		DBS_RUNWRITABLEPROGRAM		},
	{ NULL,				0				}
};
d165 3
a167 1
**  Miscellaneous stuff.
d170 11
a180 1
int	DtableSize =	50;		/* max open files; reset in 4.2bsd */
d198 1
a198 11
#define MINUTES		* 60
#define HOURS		* 60 MINUTES
#define DAYS		* 24 HOURS

#ifndef _PATH_VARTMP
# define _PATH_VARTMP	"/usr/tmp/"
#endif

#ifndef MAXRULERECURSION
# define MAXRULERECURSION	50	/* max ruleset recursion depth */
#endif
a199 1
void
a202 9
	int i;
	struct passwd *pw;
	char buf[MAXNAME];
	extern void inittimeouts __P((char *));
	extern void setdefuser __P((void));
	extern void setupmaps __P((void));
	extern void setupmailers __P((void));
	extern void setupheaders __P((void));

d212 2
a213 20

	if (((pw = getpwnam("mailnull")) != NULL && pw->pw_uid != 0) ||
	    ((pw = getpwnam("sendmail")) != NULL && pw->pw_uid != 0) ||
	    ((pw = getpwnam("daemon")) != NULL && pw->pw_uid != 0))
	{
		DefUid = pw->pw_uid;		/* option u */
		DefGid = pw->pw_gid;		/* option g */
		DefUser = newstr(pw->pw_name);
	}
	else
	{
		DefUid = 1;			/* option u */
		DefGid = 1;			/* option g */
		setdefuser();
	}
	TrustedFileUid = 0;
	if (tTd(37, 4))
		printf("setdefaults: DefUser=%s, DefUid=%d, DefGid=%d\n",
		       DefUser != NULL ? DefUser : "<1:1>",
		       (int) DefUid, (int) DefGid);
d218 1
a218 1
	SevenBitInput = FALSE;			/* option 7 */
d220 1
a220 1
	MciCacheTimeout = 5 MINUTES;		/* option K */
d222 5
a226 32
	inittimeouts(NULL);			/* option r */
	PrivacyFlags = PRIV_PUBLIC;		/* option p */
	DontBlameSendmail = DBS_SAFE;		/* DontBlameSendmail option */
#if MIME8TO7
	MimeMode = MM_CVTMIME|MM_PASS8BIT;	/* option 8 */
#else
	MimeMode = MM_PASS8BIT;
#endif
	for (i = 0; i < MAXTOCLASS; i++)
	{
		TimeOuts.to_q_return[i] = 5 DAYS;	/* option T */
		TimeOuts.to_q_warning[i] = 0;		/* option T */
	}
	ServiceSwitchFile = "/etc/service.switch";
	ServiceCacheMaxAge = (time_t) 10;
	HostsFile = _PATH_HOSTS;
	PidFile = newstr(_PATH_SENDMAILPID);
	MustQuoteChars = "@@,;:\\()[].'";
	MciInfoTimeout = 30 MINUTES;
	MaxRuleRecursion = MAXRULERECURSION;
	MaxAliasRecursion = 10;
	MaxMacroRecursion = 10;
	ColonOkInAddr = TRUE;
	DontLockReadFiles = TRUE;
	DoubleBounceAddr = "postmaster";
	snprintf(buf, sizeof buf, "%s%sdead.letter",
		_PATH_VARTMP,
		_PATH_VARTMP[sizeof _PATH_VARTMP - 2] == '/' ? "" : "/");
	DeadLetterDrop = newstr(buf);
#ifdef HESIOD_INIT
	HesiodContext = NULL;
#endif
a228 1
	setupheaders();
a235 1
void
d242 38
a279 6
	defpwent = sm_getpwuid(DefUid);
	snprintf(defuserbuf, sizeof defuserbuf, "%s",
		defpwent == NULL ? "nobody" : defpwent->pw_name);
	if (tTd(37, 4))
		printf("setdefuser: DefUid=%d, DefUser=%s\n",
		       (int) DefUid, DefUser);
a284 1
void
a287 1
	extern void makemailer __P((char *));
d289 1
a289 1
	strcpy(buf, "prog, P=/bin/sh, F=lsoDq9, T=DNS/RFC822/X-Unix, A=sh -c \201u");
d292 1
a292 1
	strcpy(buf, "*file*, P=[FILE], F=lsDFMPEouq9, T=DNS/RFC822/X-Unix, A=FILE \201u");
d295 1
a295 1
	strcpy(buf, "*include*, P=/dev/null, F=su, A=INCLUDE \201u");
a319 1
void
a327 1

d341 2
a342 31
		map_parseargs, nis_map_open, null_map_close,
		nis_map_lookup, null_map_store);
#endif

#ifdef NISPLUS
	MAPDEF("nisplus", NULL, MCF_ALIASOK,
		map_parseargs, nisplus_map_open, null_map_close,
		nisplus_map_lookup, null_map_store);
#endif
#ifdef LDAPMAP
	MAPDEF("ldapx", NULL, 0,
		ldap_map_parseargs, ldap_map_open, ldap_map_close,
		ldap_map_lookup, null_map_store);
#endif

#ifdef HESIOD
	MAPDEF("hesiod", NULL, MCF_ALIASOK|MCF_ALIASONLY,
		map_parseargs, hes_map_open, null_map_close,
		hes_map_lookup, null_map_store);
#endif

#if NETINFO
	MAPDEF("netinfo", NULL, MCF_ALIASOK,
		map_parseargs, ni_map_open, null_map_close,
		ni_map_lookup, null_map_store);
#endif

#if 0
	MAPDEF("dns", NULL, 0,
		dns_map_init, null_map_open, null_map_close,
		dns_map_lookup, null_map_store);
a344 15
#if NAMED_BIND
	/* best MX DNS lookup */
	MAPDEF("bestmx", NULL, MCF_OPTFILE,
		map_parseargs, null_map_open, null_map_close,
		bestmx_map_lookup, null_map_store);
#endif

	MAPDEF("host", NULL, 0,
		host_map_init, null_map_open, null_map_close,
		host_map_lookup, null_map_store);

	MAPDEF("text", NULL, MCF_ALIASOK,
		map_parseargs, text_map_open, null_map_close,
		text_map_lookup, null_map_store);

d346 1
a346 1
		map_parseargs, stab_map_open, null_map_close,
d353 4
a356 4
	/* access to system passwd file */
	MAPDEF("user", NULL, MCF_OPTFILE,
		map_parseargs, user_map_open, null_map_close,
		user_map_lookup, null_map_store);
d363 2
a364 7
#ifdef MAP_REGEX
	MAPDEF("regex", NULL, 0,
		regex_map_init, null_map_open, null_map_close,
		regex_map_lookup, null_map_store);
#endif

#if USERDB
d366 2
a367 2
	MAPDEF("userdb", ".db", 0,
		map_parseargs, null_map_open, null_map_close,
d369 1
a369 27
#endif

	/* arbitrary programs */
	MAPDEF("program", NULL, MCF_ALIASOK,
		map_parseargs, null_map_open, null_map_close,
		prog_map_lookup, null_map_store);

	/* sequenced maps */
	MAPDEF("sequence", NULL, MCF_ALIASOK,
		seq_map_parse, null_map_open, null_map_close,
		seq_map_lookup, seq_map_store);

	/* switched interface to sequenced maps */
	MAPDEF("switch", NULL, MCF_ALIASOK,
		map_parseargs, switch_map_open, null_map_close,
		seq_map_lookup, seq_map_store);

	/* null map lookup -- really for internal use only */
	MAPDEF("null", NULL, MCF_ALIASOK|MCF_OPTFILE,
		map_parseargs, null_map_open, null_map_close,
		null_map_lookup, null_map_store);

#if _FFR_MAP_SYSLOG
	/* syslog map -- logs information to syslog */
	MAPDEF("syslog", NULL, 0,
	       syslog_map_parseargs, null_map_open, null_map_close,
	       syslog_map_lookup, null_map_store);
a374 439
**  INITHOSTMAPS -- initial host-dependent maps
**
**	This should act as an interface to any local service switch
**	provided by the host operating system.
**
**	Parameters:
**		none
**
**	Returns:
**		none
**
**	Side Effects:
**		Should define maps "host" and "users" as necessary
**		for this OS.  If they are not defined, they will get
**		a default value later.  It should check to make sure
**		they are not defined first, since it's possible that
**		the config file has provided an override.
*/

void
inithostmaps()
{
	register int i;
	int nmaps;
	char *maptype[MAXMAPSTACK];
	short mapreturn[MAXMAPACTIONS];
	char buf[MAXLINE];

	/*
	**  Set up default hosts maps.
	*/

#if 0
	nmaps = switch_map_find("hosts", maptype, mapreturn);
	for (i = 0; i < nmaps; i++)
	{
		if (strcmp(maptype[i], "files") == 0 &&
		    stab("hosts.files", ST_MAP, ST_FIND) == NULL)
		{
			strcpy(buf, "hosts.files text -k 0 -v 1 /etc/hosts");
			(void) makemapentry(buf);
		}
#if NAMED_BIND
		else if (strcmp(maptype[i], "dns") == 0 &&
		    stab("hosts.dns", ST_MAP, ST_FIND) == NULL)
		{
			strcpy(buf, "hosts.dns dns A");
			(void) makemapentry(buf);
		}
#endif
#ifdef NISPLUS
		else if (strcmp(maptype[i], "nisplus") == 0 &&
		    stab("hosts.nisplus", ST_MAP, ST_FIND) == NULL)
		{
			strcpy(buf, "hosts.nisplus nisplus -k name -v address -d hosts.org_dir");
			(void) makemapentry(buf);
		}
#endif
#ifdef NIS
		else if (strcmp(maptype[i], "nis") == 0 &&
		    stab("hosts.nis", ST_MAP, ST_FIND) == NULL)
		{
			strcpy(buf, "hosts.nis nis -d -k 0 -v 1 hosts.byname");
			(void) makemapentry(buf);
		}
#endif
#if NETINFO
		else if (strcmp(maptype[i], "netinfo") == 0) &&
		    stab("hosts.netinfo", ST_MAP, ST_FIND) == NULL)
		{
			strcpy(buf, "hosts.netinfo netinfo -v name /machines");
			(void) makemapentry(buf);
		}
#endif
	}
#endif

	/*
	**  Make sure we have a host map.
	*/

	if (stab("host", ST_MAP, ST_FIND) == NULL)
	{
		/* user didn't initialize: set up host map */
		strcpy(buf, "host host");
#if NAMED_BIND
		if (ConfigLevel >= 2)
			strcat(buf, " -a.");
#endif
		(void) makemapentry(buf);
	}

	/*
	**  Set up default aliases maps
	*/

	nmaps = switch_map_find("aliases", maptype, mapreturn);
	for (i = 0; i < nmaps; i++)
	{
		if (strcmp(maptype[i], "files") == 0 &&
		    stab("aliases.files", ST_MAP, ST_FIND) == NULL)
		{
			strcpy(buf, "aliases.files null");
			(void) makemapentry(buf);
		}
#ifdef NISPLUS
		else if (strcmp(maptype[i], "nisplus") == 0 &&
		    stab("aliases.nisplus", ST_MAP, ST_FIND) == NULL)
		{
			strcpy(buf, "aliases.nisplus nisplus -kalias -vexpansion -d mail_aliases.org_dir");
			(void) makemapentry(buf);
		}
#endif
#ifdef NIS
		else if (strcmp(maptype[i], "nis") == 0 &&
		    stab("aliases.nis", ST_MAP, ST_FIND) == NULL)
		{
			strcpy(buf, "aliases.nis nis -d mail.aliases");
			(void) makemapentry(buf);
		}
#endif
#ifdef NETINFO
		else if (strcmp(maptype[i], "netinfo") == 0 &&
		    stab("aliases.netinfo", ST_MAP, ST_FIND) == NULL)
		{
			strcpy(buf, "aliases.netinfo netinfo -z, /aliases");
			(void) makemapentry(buf);
		}
#endif
#ifdef HESIOD
		else if (strcmp(maptype[i], "hesiod") == 0 &&
		    stab("aliases.hesiod", ST_MAP, ST_FIND) == NULL)
		{
			strcpy(buf, "aliases.hesiod hesiod aliases");
			(void) makemapentry(buf);
		}
#endif
	}
	if (stab("aliases", ST_MAP, ST_FIND) == NULL)
	{
		strcpy(buf, "aliases switch aliases");
		(void) makemapentry(buf);
	}

#if 0		/* "user" map class is a better choice */
	/*
	**  Set up default users maps.
	*/

	nmaps = switch_map_find("passwd", maptype, mapreturn);
	for (i = 0; i < nmaps; i++)
	{
		if (strcmp(maptype[i], "files") == 0 &&
		    stab("users.files", ST_MAP, ST_FIND) == NULL)
		{
			strcpy(buf, "users.files text -m -z: -k0 -v6 /etc/passwd");
			(void) makemapentry(buf);
		}
#ifdef NISPLUS
		else if (strcmp(maptype[i], "nisplus") == 0 &&
		    stab("users.nisplus", ST_MAP, ST_FIND) == NULL)
		{
			strcpy(buf, "users.nisplus nisplus -m -kname -vhome -d passwd.org_dir");
			(void) makemapentry(buf);
		}
#endif
#ifdef NIS
		else if (strcmp(maptype[i], "nis") == 0 &&
		    stab("users.nis", ST_MAP, ST_FIND) == NULL)
		{
			strcpy(buf, "users.nis nis -m -d passwd.byname");
			(void) makemapentry(buf);
		}
#endif
#ifdef HESIOD
		else if (strcmp(maptype[i], "hesiod") == 0) &&
		    stab("users.hesiod", ST_MAP, ST_FIND) == NULL)
		{
			strcpy(buf, "users.hesiod hesiod");
			(void) makemapentry(buf);
		}
#endif
	}
	if (stab("users", ST_MAP, ST_FIND) == NULL)
	{
		strcpy(buf, "users switch -m passwd");
		(void) makemapentry(buf);
	}
#endif
}
/*
**  SWITCH_MAP_FIND -- find the list of types associated with a map
**
**	This is the system-dependent interface to the service switch.
**
**	Parameters:
**		service -- the name of the service of interest.
**		maptype -- an out-array of strings containing the types
**			of access to use for this service.  There can
**			be at most MAXMAPSTACK types for a single service.
**		mapreturn -- an out-array of return information bitmaps
**			for the map.
**
**	Returns:
**		The number of map types filled in, or -1 for failure.
*/

#if defined(SOLARIS) || (defined(sony_news) && defined(__svr4))
# define _USE_SUN_NSSWITCH_
#endif

#ifdef _USE_SUN_NSSWITCH_
# include <nsswitch.h>
#endif

#if defined(ultrix) || (defined(__osf__) && defined(__alpha))
# define _USE_DEC_SVC_CONF_
#endif

#ifdef _USE_DEC_SVC_CONF_
# include <sys/svcinfo.h>
#endif

int
switch_map_find(service, maptype, mapreturn)
	char *service;
	char *maptype[MAXMAPSTACK];
	short mapreturn[MAXMAPACTIONS];
{
	int svcno;

#ifdef _USE_SUN_NSSWITCH_
	struct __nsw_switchconfig *nsw_conf;
	enum __nsw_parse_err pserr;
	struct __nsw_lookup *lk;
	static struct __nsw_lookup lkp0 =
		{ "files", {1, 0, 0, 0}, NULL, NULL };
	static struct __nsw_switchconfig lkp_default =
		{ 0, "sendmail", 3, &lkp0 };

	for (svcno = 0; svcno < MAXMAPACTIONS; svcno++)
		mapreturn[svcno] = 0;

	if ((nsw_conf = __nsw_getconfig(service, &pserr)) == NULL)
		lk = lkp_default.lookups;
	else
		lk = nsw_conf->lookups;
	svcno = 0;
	while (lk != NULL)
	{
		maptype[svcno] = lk->service_name;
		if (lk->actions[__NSW_NOTFOUND] == __NSW_RETURN)
			mapreturn[MA_NOTFOUND] |= 1 << svcno;
		if (lk->actions[__NSW_TRYAGAIN] == __NSW_RETURN)
			mapreturn[MA_TRYAGAIN] |= 1 << svcno;
		if (lk->actions[__NSW_UNAVAIL] == __NSW_RETURN)
			mapreturn[MA_TRYAGAIN] |= 1 << svcno;
		svcno++;
		lk = lk->next;
	}
	return svcno;
#endif

#ifdef _USE_DEC_SVC_CONF_
	struct svcinfo *svcinfo;
	int svc;

	for (svcno = 0; svcno < MAXMAPACTIONS; svcno++)
		mapreturn[svcno] = 0;

	svcinfo = getsvc();
	if (svcinfo == NULL)
		goto punt;
	if (strcmp(service, "hosts") == 0)
		svc = SVC_HOSTS;
	else if (strcmp(service, "aliases") == 0)
		svc = SVC_ALIASES;
	else if (strcmp(service, "passwd") == 0)
		svc = SVC_PASSWD;
	else
		return -1;
	for (svcno = 0; svcno < SVC_PATHSIZE; svcno++)
	{
		switch (svcinfo->svcpath[svc][svcno])
		{
		  case SVC_LOCAL:
			maptype[svcno] = "files";
			break;

		  case SVC_YP:
			maptype[svcno] = "nis";
			break;

		  case SVC_BIND:
			maptype[svcno] = "dns";
			break;

#ifdef SVC_HESIOD
		  case SVC_HESIOD:
			maptype[svcno] = "hesiod";
			break;
#endif

		  case SVC_LAST:
			return svcno;
		}
	}
	return svcno;
#endif

#if !defined(_USE_SUN_NSSWITCH_) && !defined(_USE_DEC_SVC_CONF_)
	/*
	**  Fall-back mechanism.
	*/

	STAB *st;
	time_t now = curtime();

	for (svcno = 0; svcno < MAXMAPACTIONS; svcno++)
		mapreturn[svcno] = 0;

	if ((now - ServiceCacheTime) > (time_t) ServiceCacheMaxAge)
	{
		/* (re)read service switch */
		register FILE *fp;
		int sff = SFF_REGONLY|SFF_OPENASROOT|SFF_NOLOCK;

		if (!bitset(DBS_LINKEDSERVICESWITCHFILEINWRITABLEDIR, DontBlameSendmail))
			sff |= SFF_NOWLINK;

		if (ConfigFileRead)
			ServiceCacheTime = now;
		fp = safefopen(ServiceSwitchFile, O_RDONLY, 0, sff);
		if (fp != NULL)
		{
			char buf[MAXLINE];

			while (fgets(buf, sizeof buf, fp) != NULL)
			{
				register char *p;

				p = strpbrk(buf, "#\n");
				if (p != NULL)
					*p = '\0';
				p = strpbrk(buf, " \t");
				if (p != NULL)
					*p++ = '\0';
				if (buf[0] == '\0')
					continue;
				while (isspace(*p))
					p++;
				if (*p == '\0')
					continue;

				/*
				**  Find/allocate space for this service entry.
				**	Space for all of the service strings
				**	are allocated at once.  This means
				**	that we only have to free the first
				**	one to free all of them.
				*/

				st = stab(buf, ST_SERVICE, ST_ENTER);
				if (st->s_service[0] != NULL)
					free((void *) st->s_service[0]);
				p = newstr(p);
				for (svcno = 0; svcno < MAXMAPSTACK; )
				{
					if (*p == '\0')
						break;
					st->s_service[svcno++] = p;
					p = strpbrk(p, " \t");
					if (p == NULL)
						break;
					*p++ = '\0';
					while (isspace(*p))
						p++;
				}
				if (svcno < MAXMAPSTACK)
					st->s_service[svcno] = NULL;
			}
			fclose(fp);
		}
	}

	/* look up entry in cache */
	st = stab(service, ST_SERVICE, ST_FIND);
	if (st != NULL && st->s_service[0] != NULL)
	{
		/* extract data */
		svcno = 0;
		while (svcno < MAXMAPSTACK)
		{
			maptype[svcno] = st->s_service[svcno];
			if (maptype[svcno++] == NULL)
				break;
		}
		return --svcno;
	}
#endif

#if !defined(_USE_SUN_NSSWITCH_)
	/* if the service file doesn't work, use an absolute fallback */
# ifdef _USE_DEC_SVC_CONF_
  punt:
# endif
	for (svcno = 0; svcno < MAXMAPACTIONS; svcno++)
		mapreturn[svcno] = 0;
	svcno = 0;
	if (strcmp(service, "aliases") == 0)
	{
		maptype[svcno++] = "files";
# ifdef AUTO_NIS_ALIASES
#  ifdef NISPLUS
		maptype[svcno++] = "nisplus";
#  endif
#  ifdef NIS
		maptype[svcno++] = "nis";
#  endif
# endif
		return svcno;
	}
	if (strcmp(service, "hosts") == 0)
	{
#  if NAMED_BIND
		maptype[svcno++] = "dns";
#  else
#   if defined(sun) && !defined(BSD)
		/* SunOS */
		maptype[svcno++] = "nis";
#   endif
#  endif
		maptype[svcno++] = "files";
		return svcno;
	}
	return -1;
#endif
}
/*
d403 1
a403 1
			pw = sm_getpwuid(RealUid);
d412 1
a412 1
			if ((pw = sm_getpwnam(myname)) == NULL ||
d415 1
a415 1
				pw = sm_getpwuid(uid);
d470 1
a470 1
	if (stat(pathn, &stbuf) < 0 || !bitset(S_IWOTH, stbuf.st_mode))
d492 5
a496 8
**	message should be given using "usrerr" and an EX_ code
**	should be returned.  You can also set to->q_status to
**	a DSN-style status code.
**
**	EF_NO_BODY_RETN can be set in e->e_flags to suppress the
**	body during the return-to-sender function; this should be done
**	on huge messages.  This bit may already be set by the ESMTP
**	protocol.
a507 1
int
d526 1
a526 1
	if (s != NULL && strcmp(e->e_from.q_mailer->m_name, "local") != 0 &&
d530 1
a530 2
		/* e->e_flags |= EF_NO_BODY_RETN; to supress body on return */
		to->q_status = "5.7.1";
d547 1
a547 2
#if defined(SYS5SIGNALS) || defined(BSD4_3)
# ifdef BSD4_3
a548 3
# else
	return sigset(sig, handler);
# endif
a552 4
# if USE_SA_SIGACTION
	n.sa_sigaction = (void(*)(int, siginfo_t *, void *)) handler;
	n.sa_flags = SA_RESTART|SA_SIGINFO;
# else
a553 4
#  ifdef SA_RESTART
	n.sa_flags = SA_RESTART;
#  endif
# endif
a559 81
**  BLOCKSIGNAL -- hold a signal to prevent delivery
**
**	Parameters:
**		sig -- the signal to block.
**
**	Returns:
**		1 signal was previously blocked
**		0 signal was not previously blocked
**		-1 on failure.
*/

int
blocksignal(sig)
	int sig;
{
#ifdef BSD4_3
# ifndef sigmask
#  define sigmask(s)	(1 << ((s) - 1))
# endif
	return (sigblock(sigmask(sig)) & sigmask(sig)) != 0;
#else
# ifdef ALTOS_SYSTEM_V
	sigfunc_t handler;

	handler = sigset(sig, SIG_HOLD);
	if (handler == SIG_ERR)
		return -1;
	else
		return handler == SIG_HOLD;
# else
	sigset_t sset, oset;

	sigemptyset(&sset);
	sigaddset(&sset, sig);
	if (sigprocmask(SIG_BLOCK, &sset, &oset) < 0)
		return -1;
	else
		return sigismember(&oset, sig);
# endif
#endif
}
/*
**  RELEASESIGNAL -- release a held signal
**
**	Parameters:
**		sig -- the signal to release.
**
**	Returns:
**		1 signal was previously blocked
**		0 signal was not previously blocked
**		-1 on failure.
*/

int
releasesignal(sig)
	int sig;
{
#ifdef BSD4_3
	return (sigsetmask(sigblock(0) & ~sigmask(sig)) & sigmask(sig)) != 0;
#else
# ifdef ALTOS_SYSTEM_V
	sigfunc_t handler;

	handler = sigset(sig, SIG_HOLD);
	if (sigrelse(sig) < 0)
		return -1;
	else
		return handler == SIG_HOLD;
# else
	sigset_t sset, oset;

	sigemptyset(&sset);
	sigaddset(&sset, sig);
	if (sigprocmask(SIG_UNBLOCK, &sset, &oset) < 0)
		return -1;
	else
		return sigismember(&oset, sig);
# endif
#endif
}
/*
a571 1
void
a589 1
void
d601 1
a601 5
# include <compat.h>
#endif

#if SHARE_V1
# include <shares.h>
a603 1
void
a610 58

#ifdef SUN_EXTENSIONS
	init_md_sun();
#endif

#if _CONVEX_SOURCE
	/* keep gethostby*() from stripping the local domain name */
	set_domain_trim_off();
#endif
#ifdef __QNX__
	/*
	** Due to QNX's network distributed nature, you can target a tcpip
	** stack on a different node in the qnx network; this patch lets
	** this feature work.  The __sock_locate() must be done before the
	** environment is clear.
	*/
	__sock_locate();
#endif
#if SECUREWARE || defined(_SCO_unix_)
	set_auth_parameters(argc, argv);

# ifdef _SCO_unix_
	/*
	**  This is required for highest security levels (the kernel
	**  won't let it call set*uid() or run setuid binaries without
	**  it).  It may be necessary on other SECUREWARE systems.
	*/

	if (getluid() == -1)
		setluid(0);
# endif
#endif

#ifdef VENDOR_DEFAULT
	VendorCode = VENDOR_DEFAULT;
#else
	VendorCode = VENDOR_BERKELEY;
#endif
}
/*
**  INIT_VENDOR_MACROS -- vendor-dependent macro initializations
**
**	Called once, on startup.
**
**	Parameters:
**		e -- the global envelope.
**
**	Returns:
**		none.
**
**	Side Effects:
**		vendor-dependent.
*/

void
init_vendor_macros(e)
	register ENVELOPE *e;
{
a634 7
#define LA_READKSYM	8	/* SVR4: use MIOC_READKSYM ioctl call */
#define LA_DGUX		9	/* special DGUX implementation */
#define LA_HPUX		10	/* special HPUX implementation */
#define LA_IRIX6	11	/* special IRIX 6.2 implementation */
#define LA_KSTAT	12	/* special Solaris kstat(3k) implementation */
#define LA_DEVSHORT	13	/* read short from a device */
#define LA_ALPHAOSF	14	/* Digital UNIX (OSF/1 on Alpha) table() call */
d641 1
a641 4
#ifndef FSHIFT
# if defined(unixpc)
#  define FSHIFT	5
# endif
d643 1
a643 13
# if defined(__alpha) || defined(IRIX)
#  define FSHIFT	10
# endif

#endif

#ifndef FSHIFT
# define FSHIFT		8
#endif

#ifndef FSCALE
# define FSCALE		(1 << FSHIFT)
#endif
a652 9
/* _PATH_KMEM should be defined in <paths.h> */
#ifndef _PATH_KMEM
# define _PATH_KMEM	"/dev/kmem"
#endif

#if (LA_TYPE == LA_INT) || (LA_TYPE == LA_FLOAT) || (LA_TYPE == LA_SHORT)

#include <nlist.h>

d662 1
a662 4
#ifdef _AUX_SOURCE
struct nlist	Nl[2];
#else
struct nlist	Nl[] =
d665 1
d668 17
a685 1
#define	X_AVENRUN	0
a686 1
int
d699 1
a700 1
	extern off_t lseek();
d704 9
a712 8
#ifdef _AUX_SOURCE
		strcpy(Nl[X_AVENRUN].n_name, LA_AVENRUN);
		Nl[1].n_name[0] = '\0';
#endif

#if defined(_AIX3) || defined(_AIX4)
		if (knlist(Nl, 1, sizeof Nl[0]) < 0)
#else
a713 1
#endif
d727 2
a728 2
#ifdef NAMELISTMASK
		Nl[X_AVENRUN].n_value &= NAMELISTMASK;
a729 10

		kmem = open(_PATH_KMEM, 0, 0);
		if (kmem < 0)
		{
			if (tTd(3, 1))
				printf("getla: open(/dev/kmem): %s\n",
					errstring(errno));
			return (-1);
		}
		(void) fcntl(kmem, F_SETFD, 1);
d732 2
a733 3
		printf("getla: symbol address = %#lx\n",
			(u_long) Nl[X_AVENRUN].n_value);
	if (lseek(kmem, (off_t) Nl[X_AVENRUN].n_value, SEEK_SET) == -1 ||
d741 1
a741 1
# if (LA_TYPE == LA_INT) || (LA_TYPE == LA_SHORT)
a743 1
#  if LA_TYPE == LA_SHORT
a746 5
#  else
		printf("getla: avenrun = %ld", avenrun[0]);
		if (tTd(3, 15))
			printf(", %ld, %ld", avenrun[1], avenrun[2]);
#  endif
d752 1
a752 1
# else /* LA_TYPE == LA_FLOAT */
d763 1
a763 1
# endif
d766 2
a767 1
#endif /* LA_TYPE == LA_INT or LA_SHORT or LA_FLOAT */
d769 1
a769 1
#if LA_TYPE == LA_READKSYM
d771 1
a771 1
# include <sys/ksym.h>
d773 1
a773 49
getla()
{
	static int kmem = -1;
	long avenrun[3];
	extern int errno;
	struct mioc_rksym mirk;

	if (kmem < 0)
	{
		kmem = open("/dev/kmem", 0, 0);
		if (kmem < 0)
		{
			if (tTd(3, 1))
				printf("getla: open(/dev/kmem): %s\n",
					errstring(errno));
			return (-1);
		}
		(void) fcntl(kmem, F_SETFD, 1);
	}
	mirk.mirk_symname = LA_AVENRUN;
	mirk.mirk_buf = avenrun;
	mirk.mirk_buflen = sizeof(avenrun);
	if (ioctl(kmem, MIOC_READKSYM, &mirk) < 0)
	{
		if (tTd(3, 1))
			printf("getla: ioctl(MIOC_READKSYM) failed: %s\n",
				errstring(errno));
		return -1;
	}
	if (tTd(3, 5))
	{
		printf("getla: avenrun = %d", avenrun[0]);
		if (tTd(3, 15))
			printf(", %d, %d", avenrun[1], avenrun[2]);
		printf("\n");
	}
	if (tTd(3, 1))
		printf("getla: %d\n", (int) (avenrun[0] + FSCALE/2) >> FSHIFT);
	return ((int) (avenrun[0] + FSCALE/2) >> FSHIFT);
}

#endif /* LA_TYPE == LA_READKSYM */

#if LA_TYPE == LA_DGUX

# include <sys/dg_sys_info.h>

int
getla()
a779 3
	if (tTd(3, 1))
		printf("getla: %d\n", (int) (load_info.one_minute + 0.5));

d783 1
a783 33
#endif /* LA_TYPE == LA_DGUX */

#if LA_TYPE == LA_HPUX

/* forward declarations to keep gcc from complaining */
struct pst_dynamic;
struct pst_status;
struct pst_static;
struct pst_vminfo;
struct pst_diskinfo;
struct pst_processor;
struct pst_lv;
struct pst_swapinfo;

# include <sys/param.h>
# include <sys/pstat.h>

int
getla()
{
	struct pst_dynamic pstd;

	if (pstat_getdynamic(&pstd, sizeof(struct pst_dynamic),
			     (size_t) 1, 0) == -1)
		return 0;

	if (tTd(3, 1))
		printf("getla: %d\n", (int) (pstd.psd_avg_1_min + 0.5));

	return (int) (pstd.psd_avg_1_min + 0.5);
}

#endif /* LA_TYPE == LA_HPUX */
a784 3
#if LA_TYPE == LA_SUBR

int
d800 2
a801 2
#endif /* LA_TYPE == LA_SUBR */

a813 1
int
a823 3
	{
		if (tTd(3, 1))
			perror("getla: processor_set_default failed:");
a824 1
	}
a829 2
		if (tTd(3, 1))
			perror("getla: processor_set_info failed:");
a831 2
	if (tTd(3, 1))
		printf("getla: %d\n", (int) (info.load_average + (LOAD_SCALE / 2)) / LOAD_SCALE);
a834 1
#endif /* LA_TYPE == LA_MACH */
d836 1
d859 1
a859 1
	if (fp == NULL)
d882 8
a889 1
#endif /* LA_TYPE == LA_PROCSTR */
d891 4
a894 2
#if LA_TYPE == LA_IRIX6
#include <sys/sysmp.h>
a895 4
int getla(void)
{
	static int kmem = -1;
	int avenrun[3];
d897 6
a902 183
	if (kmem < 0)
	{
		kmem = open(_PATH_KMEM, 0, 0);
		if (kmem < 0)
		{
			if (tTd(3, 1))
				printf("getla: open(%s): %s\n", _PATH_KMEM,
					errstring(errno));
			return -1;
		}
		(void) fcntl(kmem, F_SETFD, 1);
	}

	if (lseek(kmem, (sysmp(MP_KERNADDR, MPKA_AVENRUN) & 0x7fffffff), SEEK_SET) == -1 || 
	    read(kmem, (char *)avenrun, sizeof(avenrun)) < sizeof(avenrun)) 
	{
		if (tTd(3, 1))
			printf("getla: lseek or read: %s\n",
			       errstring(errno));
		return -1;
	}
	if (tTd(3, 5))
	{
		printf("getla: avenrun = %ld", (long int) avenrun[0]);
		if (tTd(3, 15))
			printf(", %ld, %ld",
			       (long int) avenrun[1], (long int) avenrun[2]);
		printf("\n");
	}

	if (tTd(3, 1))
		printf("getla: %d\n", (int) (avenrun[0] + FSCALE/2) >> FSHIFT);
	return ((int) (avenrun[0] + FSCALE/2) >> FSHIFT);

}
#endif

#if LA_TYPE == LA_KSTAT

#include <kstat.h>

int
getla()
{
	static kstat_ctl_t *kc = NULL;
	static kstat_t *ksp = NULL;
	kstat_named_t *ksn;
	int la;

	if (kc == NULL)		/* if not initialized before */
		kc = kstat_open();
	if (kc == NULL)
	{
		if (tTd(3, 1))
			printf("getla: kstat_open(): %s\n",
				errstring(errno));
		return -1;
	}
	if (ksp == NULL)
		ksp = kstat_lookup(kc, "unix", 0, "system_misc");
	if (ksp == NULL)
	{
		if (tTd(3, 1))
			printf("getla: kstat_lookup(): %s\n",
				errstring(errno));
		return -1;
	}
	if (kstat_read(kc, ksp, NULL) < 0)
	{
		if (tTd(3, 1))
			printf("getla: kstat_read(): %s\n",
				errstring(errno));
		return -1;
	}
	ksn = (kstat_named_t *) kstat_data_lookup(ksp, "avenrun_1min");
	la = ((double)ksn->value.ul + FSCALE/2) / FSCALE;
	/* kstat_close(kc); /o do not close for fast access */
	return la;
}

#endif /* LA_TYPE == LA_KSTAT */

#if LA_TYPE == LA_DEVSHORT

/*
**  Read /dev/table/avenrun for the load average.  This should contain
**  three shorts for the 1, 5, and 15 minute loads.  We only read the
**  first, since that's all we care about.
**
**	Intended for SCO OpenServer 5.
*/

# ifndef _PATH_AVENRUN
#  define _PATH_AVENRUN	"/dev/table/avenrun"
# endif

int
getla()
{
	static int afd = -1;
	short avenrun;
	int loadav;
	int r;

	errno = EBADF;

	if (afd == -1 || lseek(afd, 0L, SEEK_SET) == -1)
	{
		if (errno != EBADF)
			return -1;
		afd = open(_PATH_AVENRUN, O_RDONLY|O_SYNC);
		if (afd < 0)
		{
			sm_syslog(LOG_ERR, NOQID,
				"can't open %s: %m",
				_PATH_AVENRUN);
			return -1;
		}
	}

	r = read(afd, &avenrun, sizeof avenrun);

	if (tTd(3, 5))
		printf("getla: avenrun = %d\n", avenrun);
	loadav = (int) (avenrun + FSCALE/2) >> FSHIFT;
	if (tTd(3, 1))
		printf("getla: %d\n", loadav);
	return loadav;
}

#endif /* LA_TYPE == LA_DEVSHORT */

#if LA_TYPE == LA_ALPHAOSF
struct rtentry;
struct mbuf;
# include <sys/table.h>

int getla()
{
	int ave = 0;
	struct tbl_loadavg tab;

	if (table(TBL_LOADAVG, 0, &tab, 1, sizeof(tab)) == -1)
	{
		if (tTd(3, 1))
			printf("getla: table %s\n", errstring(errno));
		return (-1);
	}

	if (tTd(3, 1))
		printf("getla: scale = %d\n", tab.tl_lscale);

	if (tab.tl_lscale)
		ave = (tab.tl_avenrun.l[0] + (tab.tl_lscale/2)) / tab.tl_lscale;
	else
		ave = (int) (tab.tl_avenrun.d[0] + 0.5);

	if (tTd(3, 1))
		printf("getla: %d\n", ave);

	return ave;
}

#endif

#if LA_TYPE == LA_ZERO

int
getla()
{
	if (tTd(3, 1))
		printf("getla: ZERO\n");
	return (0);
}

#endif /* LA_TYPE == LA_ZERO */

/*
 * Copyright 1989 Massachusetts Institute of Technology
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
d922 1
a922 1
static char  rcsid[] = "@@(#)$Id: getloadavg.c,v 1.16 1991/06/21 12:51:15 paul Exp $";
a959 2
extern int	get_num_procs_online __P((void));

d965 1
a965 9
	bool rval;
	int queuela = QueueLA * get_num_procs_online();

	if (tTd(3, 30))
		printf("shouldqueue: CurrentLA=%d, pri=%ld: ", CurrentLA, pri);
	if (CurrentLA < queuela)
	{
		if (tTd(3, 30))
			printf("FALSE (CurrentLA < QueueLA)\n");
d967 1
a967 6
	}
#if 0	/* this code is reported to cause oscillation around RefuseLA */
	if (CurrentLA >= RefuseLA && QueueLA < RefuseLA)
	{
		if (tTd(3, 30))
			printf("TRUE (CurrentLA >= RefuseLA)\n");
d969 1
a969 6
	}
#endif
	rval = pri > (QueueFactor / (CurrentLA - queuela + 1));
	if (tTd(3, 30))
		printf("%s (by calculation)\n", rval ? "TRUE" : "FALSE");
	return rval;
d975 1
a975 1
**		port -- port number (for error messages only)
d983 1
a983 1
**		Sets process title when it is rejecting connections.
d987 1
a987 2
refuseconnections(port)
	int port;
a988 6
	int refusela = RefuseLA * get_num_procs_online();
	time_t now;
	static time_t lastconn = (time_t) 0;
	static int conncnt = 0;
	extern bool enoughdiskspace __P((long));

d994 2
a995 59
	now = curtime();
	if (now != lastconn)
	{
		lastconn = now;
		conncnt = 0;
	}
	else if (conncnt++ > ConnRateThrottle && ConnRateThrottle > 0)
	{
		/* sleep to flatten out connection load */
		setproctitle("deferring connections on port %d: %d per second",
			port, ConnRateThrottle);
		if (LogLevel >= 14)
			sm_syslog(LOG_INFO, NOQID,
				"deferring connections on port %d: %d per second",
				port, ConnRateThrottle);
		sleep(1);
	}

	CurrentLA = getla();
	if (CurrentLA >= refusela)
	{
		setproctitle("rejecting connections on port %d: load average: %d",
			port, CurrentLA);
		if (LogLevel >= 14)
			sm_syslog(LOG_INFO, NOQID,
				"rejecting connections on port %d: load average: %d",
				port, CurrentLA);
		return TRUE;
	}

	if (!enoughdiskspace(MinBlocksFree + 1))
	{
		setproctitle("rejecting connections on port %d: min free: %d",
			port, MinBlocksFree);
		if (LogLevel >= 14)
			sm_syslog(LOG_INFO, NOQID,
				"rejecting connections on port %d: min free: %d",
				port, MinBlocksFree);
		return TRUE;
	}

	if (MaxChildren > 0 && CurChildren >= MaxChildren)
	{
		extern void proc_list_probe __P((void));

		proc_list_probe();
		if (CurChildren >= MaxChildren)
		{
			setproctitle("rejecting connections on port %d: %d children, max %d",
				port, CurChildren, MaxChildren);
			if (LogLevel >= 14)
				sm_syslog(LOG_INFO, NOQID,
					"rejecting connections on port %d: %d children, max %d",
					port, CurChildren, MaxChildren);
			return TRUE;
		}
	}

	return FALSE;
d1012 5
a1016 16
#define SPT_NONE	0	/* don't use it at all */
#define SPT_REUSEARGV	1	/* cover argv with title information */
#define SPT_BUILTIN	2	/* use libc builtin */
#define SPT_PSTAT	3	/* use pstat(PSTAT_SETCMD, ...) */
#define SPT_PSSTRINGS	4	/* use PS_STRINGS->... */
#define SPT_SYSMIPS	5	/* use sysmips() supported by NEWS-OS 6 */
#define SPT_SCO		6	/* write kernel u. area */
#define SPT_CHANGEARGV	7	/* write our own strings into argv[] */

#ifndef SPT_TYPE
# define SPT_TYPE	SPT_REUSEARGV
#endif

#if SPT_TYPE != SPT_NONE && SPT_TYPE != SPT_BUILTIN

# if SPT_TYPE == SPT_PSTAT
d1019 1
a1019 1
# if SPT_TYPE == SPT_PSSTRINGS
d1022 6
a1027 8
#  ifndef PS_STRINGS	/* hmmmm....  apparently not available after all */
#   undef SPT_TYPE
#   define SPT_TYPE	SPT_REUSEARGV
#  else
#   ifndef NKPDE			/* FreeBSD 2.0 */
#    define NKPDE 63
typedef unsigned int	*pt_entry_t;
#   endif
d1030 1
a1030 4

# if SPT_TYPE == SPT_PSSTRINGS || SPT_TYPE == SPT_CHANGEARGV
#  define SETPROC_STATIC	static
# else
d1033 1
d1035 3
a1037 81
# if SPT_TYPE == SPT_SYSMIPS
#  include <sys/sysmips.h>
#  include <sys/sysnews.h>
# endif

# if SPT_TYPE == SPT_SCO
#  include <sys/immu.h>
#  include <sys/dir.h>
#  include <sys/user.h>
#  include <sys/fs/s5param.h>
#  if PSARGSZ > MAXLINE
#   define SPT_BUFSIZE	PSARGSZ
#  endif
# endif

# ifndef SPT_PADCHAR
#  define SPT_PADCHAR	' '
# endif

# ifndef SPT_BUFSIZE
#  define SPT_BUFSIZE	MAXLINE
# endif

#endif /* SPT_TYPE != SPT_NONE && SPT_TYPE != SPT_BUILTIN */

/*
**  Pointers for setproctitle.
**	This allows "ps" listings to give more useful information.
*/

char		**Argv = NULL;		/* pointer to argument vector */
char		*LastArgv = NULL;	/* end of argv */

void
initsetproctitle(argc, argv, envp)
	int argc;
	char **argv;
	char **envp;
{
	register int i, envpsize = 0;
	extern char **environ;

	/*
	**  Move the environment so setproctitle can use the space at
	**  the top of memory.
	*/

	for (i = 0; envp[i] != NULL; i++)
		envpsize += strlen(envp[i]) + 1;
	environ = (char **) xalloc(sizeof (char *) * (i + 1));
	for (i = 0; envp[i] != NULL; i++)
		environ[i] = newstr(envp[i]);
	environ[i] = NULL;

	/*
	**  Save start and extent of argv for setproctitle.
	*/

	Argv = argv;

	/*
	**  Determine how much space we can use for setproctitle.  
	**  Use all contiguous argv and envp pointers starting at argv[0]
 	*/
	for (i = 0; i < argc; i++)
	{
		if (i==0 || LastArgv + 1 == argv[i])
			LastArgv = argv[i] + strlen(argv[i]);
		else
			continue;
	}
	for (i=0; envp[i] != NULL; i++)
	{
		if (LastArgv + 1 == envp[i])
			LastArgv = envp[i] + strlen(envp[i]);
		else
			continue;
	}
}

#if SPT_TYPE != SPT_BUILTIN
d1039 1
d1042 3
a1044 4
void
# ifdef __STDC__
setproctitle(const char *fmt, ...)
# else
d1046 1
a1046 1
	const char *fmt;
d1048 1
a1048 1
# endif
d1050 1
a1050 1
# if SPT_TYPE != SPT_NONE
d1053 1
a1053 1
	SETPROC_STATIC char buf[SPT_BUFSIZE];
d1055 1
a1055 1
#  if SPT_TYPE == SPT_PSTAT
d1058 2
a1059 6
#  if SPT_TYPE == SPT_SCO
	off_t seek_off;
	static int kmem = -1;
	static int kmempid = -1;
	struct user u;
#  endif
d1069 1
a1069 1
	(void) vsnprintf(p, SPACELEFT(buf, p), fmt, ap);
d1074 1
a1074 1
#  if SPT_TYPE == SPT_PSTAT
d1077 2
a1078 2
#  endif
#  if SPT_TYPE == SPT_PSSTRINGS
d1081 1
a1081 21
#  endif
#  if SPT_TYPE == SPT_SYSMIPS
	sysmips(SONY_SYSNEWS, NEWS_SETPSARGS, buf);
#  endif
#  if SPT_TYPE == SPT_SCO
	if (kmem < 0 || kmempid != getpid())
	{
		if (kmem >= 0)
			close(kmem);
		kmem = open(_PATH_KMEM, O_RDWR, 0);
		if (kmem < 0)
			return;
		(void) fcntl(kmem, F_SETFD, 1);
		kmempid = getpid();
	}
	buf[PSARGSZ - 1] = '\0';
	seek_off = UVUBLK + (off_t) u.u_psargs - (off_t) &u;
	if (lseek(kmem, (off_t) seek_off, SEEK_SET) == seek_off)
		(void) write(kmem, buf, PSARGSZ);
#  endif
#  if SPT_TYPE == SPT_REUSEARGV
d1090 2
a1091 6
		*p++ = SPT_PADCHAR;
	Argv[1] = NULL;
#  endif
#  if SPT_TYPE == SPT_CHANGEARGV
	Argv[0] = buf;
	Argv[1] = 0;
d1093 1
a1093 1
# endif /* SPT_TYPE != SPT_NONE */
a1095 34
#endif /* SPT_TYPE != SPT_BUILTIN */
/*
**  WAITFOR -- wait for a particular process id.
**
**	Parameters:
**		pid -- process id to wait for.
**
**	Returns:
**		status of pid.
**		-1 if pid never shows up.
**
**	Side Effects:
**		none.
*/

int
waitfor(pid)
	pid_t pid;
{
#ifdef WAITUNION
	union wait st;
#else
	auto int st;
#endif
	pid_t i;
#if defined(ISC_UNIX) || defined(_SCO_unix_)
	int savesig;
#endif

	do
	{
		errno = 0;
#if defined(ISC_UNIX) || defined(_SCO_unix_)
		savesig = releasesignal(SIGCHLD);
a1096 16
		i = wait(&st);
#if defined(ISC_UNIX) || defined(_SCO_unix_)
		if (savesig > 0)
			blocksignal(SIGCHLD);
#endif
		if (i > 0)
			proc_list_drop(i);
	} while ((i >= 0 || errno == EINTR) && i != pid);
	if (i < 0)
		return -1;
#ifdef WAITUNION
	return st.w_status;
#else
	return st;
#endif
}
d1101 1
a1101 1
**		sig -- the signal that got us here (unused).
d1110 2
a1111 3
SIGFUNC_DECL
reapchild(sig)
	int sig;
a1113 1
	pid_t pid;
d1117 1
d1124 4
a1127 4
			if (LogLevel > 0)
				sm_syslog(LOG_ALERT, NOQID,
					"reapchild: waitpid loop: pid=%d, status=%x",
					pid, status);
a1129 1
		proc_list_drop(pid);
d1135 2
a1136 2
	while ((pid = wait3(&status, WNOHANG, (struct rusage *) NULL)) > 0)
		proc_list_drop(pid);
d1140 2
a1141 9
	/*
	**  Catch one zombie -- we will be re-invoked (we hope) if there
	**  are more.  Unreliable signals probably break this, but this
	**  is the "old system" situation -- waitpid or wait3 are to be
	**  strongly preferred.
	*/

	if ((pid = wait(&status)) > 0)
		proc_list_drop(pid);
a1147 1
	return SIGFUNC_RETURN;
d1150 1
a1150 1
**  PUTENV -- emulation of putenv() in terms of setenv()
d1152 1
a1152 3
**	Not needed on Posix-compliant systems.
**	This doesn't have full Posix semantics, but it's good enough
**		for sendmail.
d1154 3
a1156 2
**	Parameter:
**		env -- the environment to put.
d1160 6
d1168 1
a1168 1
#ifdef NEEDPUTENV
d1170 2
a1171 108
# if NEEDPUTENV == 2		/* no setenv(3) call available */

int
putenv(str)
	char *str;
{
	char **current;
	int matchlen, envlen=0;
	char *tmp;
	char **newenv;
	static int first=1;
	extern char **environ;

	/*
	 * find out how much of str to match when searching
	 * for a string to replace.
	 */
	if ((tmp = strchr(str, '=')) == NULL || tmp == str)
		matchlen = strlen(str);
	else
		matchlen = (int) (tmp - str);
	++matchlen;

	/*
	 * Search for an existing string in the environment and find the
	 * length of environ.  If found, replace and exit.
	 */
	for (current=environ; *current; current++) {
		++envlen;

		if (strncmp(str, *current, matchlen) == 0) {
			/* found it, now insert the new version */
			*current = (char *)str;
			return(0);
		}
	}

	/*
	 * There wasn't already a slot so add space for a new slot.
	 * If this is our first time through, use malloc(), else realloc().
	 */
	if (first) {
		newenv = (char **) malloc(sizeof(char *) * (envlen + 2));
		if (newenv == NULL)
			return(-1);

		first=0;
		(void) memcpy(newenv, environ, sizeof(char *) * envlen);
	} else {
		newenv = (char **) realloc((char *)environ, sizeof(char *) * (envlen + 2));
		if (newenv == NULL)
			return(-1);
	}

	/* actually add in the new entry */
	environ = newenv;
	environ[envlen] = (char *)str;
	environ[envlen+1] = NULL;

	return(0);
}

#else			/* implement putenv() in terms of setenv() */

int
putenv(env)
	char *env;
{
	char *p;
	int l;
	char nbuf[100];

	p = strchr(env, '=');
	if (p == NULL)
		return 0;
	l = p - env;
	if (l > sizeof nbuf - 1)
		l = sizeof nbuf - 1;
	bcopy(env, nbuf, l);
	nbuf[l] = '\0';
	return setenv(nbuf, ++p, 1);
}

# endif
#endif
/*
**  UNSETENV -- remove a variable from the environment
**
**	Not needed on newer systems.
**
**	Parameters:
**		name -- the string name of the environment variable to be
**			deleted from the current environment.
**
**	Returns:
**		none.
**
**	Globals:
**		environ -- a pointer to the current environment.
**
**	Side Effects:
**		Modifies environ.
*/

#ifndef HASUNSETENV

void
unsetenv(name)
d1287 1
a1287 1

a1307 17
**  SETGROUPS -- set group list
**
**	Stub implementation for systems that don't have group lists
*/

#ifndef NGROUPS_MAX

int
setgroups(ngroups, grouplist)
	int ngroups;
	GIDSET_T grouplist[];
{
	return 0;
}

#endif
/*
d1356 1
a1356 2
**	instead of a long.  This patches things.  Only needed on versions
**	prior to 5.4.3.
d1359 1
a1359 1
#ifdef DGUX_5_4_2
d1402 1
a1402 2
extern int	optind, opterr, optopt;
extern char	*optarg;
d1406 1
a1408 1
#endif
a1414 1
int
d1422 1
a1422 1
	register char	*oli = NULL;	/* option letter list index */
d1431 1
a1431 1
			return -1;
d1436 1
a1436 1
			return -1;
d1443 1
a1443 1
	if (oli && *++oli != ':') {		/* don't need argument */
d1470 3
a1472 3
	FILE *fp;
	char *fmt;
	char **ap;
d1474 2
a1475 2
	char *bp[MAXARG];
	int i = 0;
d1486 3
a1488 3
	char *s;
	char *fmt;
	char **ap;
d1490 2
a1491 2
	char *bp[MAXARG];
	int i = 0;
a1505 1
**		user -- the name of the user we are checking.
a1518 8
# if defined(_AIX3) || defined(_AIX4)
#  include <userconf.h>
#  if _AIX4 >= 40200
#   include <userpw.h>
#  endif
#  include <usersec.h>
# endif

d1521 1
a1521 1
	"/bin/sh",		/* standard shell */
d1523 1
a1523 1
	"/bin/csh",		/* C shell */
d1526 3
a1528 11
# ifdef V4FS
	"/usr/bin/rsh",		/* restricted Bourne shell */
	"/usr/bin/ksh",		/* Korn shell */
	"/usr/bin/rksh",	/* restricted Korn shell */
	"/usr/bin/pam",
	"/usr/bin/keysh",	/* key shell (extended Korn shell) */
	"/usr/bin/posix/sh",
# else
	"/bin/rsh",		/* restricted Bourne shell */
	"/bin/ksh",		/* Korn shell */
	"/bin/rksh",		/* restricted Korn shell */
d1530 1
a1530 1
	"/usr/bin/keysh",	/* key shell (extended Korn shell) */
a1531 22
# endif
#endif
#if defined(_AIX3) || defined(_AIX4)
	"/bin/ksh",		/* Korn shell */
	"/usr/bin/ksh",
	"/bin/tsh",		/* trusted shell */
	"/usr/bin/tsh",
	"/bin/bsh",		/* Bourne shell */
	"/usr/bin/bsh",
#endif
#ifdef __svr4__
	"/bin/ksh",		/* Korn shell */
	"/usr/bin/ksh",
#endif
#ifdef sgi
	"/sbin/sh",		/* SGI's shells really live in /sbin */
	"/sbin/csh",
	"/bin/ksh",		/* Korn shell */
	"/sbin/ksh",
	"/usr/bin/ksh",
	"/bin/tcsh",		/* Extended csh */
	"/usr/bin/tcsh",
d1541 1
a1541 2
usershellok(user, shell)
	char *user;
d1548 1
a1548 2
	if (shell == NULL || shell[0] == '\0' || wordinclass(user, 't') ||
	    ConfigLevel <= 1)
a1557 3
# if USEGETCONFATTR
	auto char *v;
# endif
d1561 1
a1561 2
	if (shell == NULL || shell[0] == '\0' || wordinclass(user, 't') ||
	    ConfigLevel <= 1)
a1563 26
# if USEGETCONFATTR
	/*
	**  Naturally IBM has a "better" idea.....
	**
	**	What a crock.  This interface isn't documented, it is
	**	considered part of the security library (-ls), and it
	**	only works if you are running as root (since the list
	**	of valid shells is obviously a source of great concern).
	**	I recommend that you do NOT define USEGETCONFATTR,
	**	especially since you are going to have to set up an
	**	/etc/shells anyhow to handle the cases where getconfattr
	**	fails.
	*/

	if (getconfattr(SC_SYS_LOGIN, SC_SHELLS, &v, SEC_LIST) == 0 && v != NULL)
	{
		while (*v != '\0')
		{
			if (strcmp(v, shell) == 0 || strcmp(v, WILDCARD_SHELL) == 0)
				return TRUE;
			v += strlen(v) + 1;
		}
		return FALSE;
	}
# endif

a1568 5
		
		if (errno != ENOENT && LogLevel > 3)
			sm_syslog(LOG_ERR, NOQID,
				  "usershellok: cannot open %s: %s",
				  _PATH_SHELLS, errstring(errno));
d1588 1
a1588 1
		while (*p != '\0' && *p != '#' && !(isascii(*p) && isspace(*p)))
d1602 1
a1602 1
**  FREEDISKSPACE -- see how much free space is on the queue filesystem
d1649 1
a1649 1
freediskspace(dir, bsize)
d1658 1
a1658 1
#  define SFS_BAVAIL	f_tfree
d1662 2
a1663 2
#   define SFS_BAVAIL	fd_bfreen
#   define FSBLOCKSIZE	1024L
d1667 1
a1667 1
#    define FSBLOCKSIZE	fs.f_frsize
d1671 3
d1677 1
a1677 3
# ifndef SFS_BAVAIL
#  define SFS_BAVAIL f_bavail
# endif
d1685 2
a1686 2
#   if SFS_TYPE == SFS_STATVFS
	if (statvfs(dir, &fs) == 0)
a1687 3
#    if defined(ultrix)
	if (statfs(dir, &fs) > 0)
#    else
a1688 1
#    endif
d1695 1
a1695 6
		if (fs.SFS_BAVAIL <= 0)
			return 0;
		else if (fs.SFS_BAVAIL > LONG_MAX)
			return LONG_MAX;
		else
			return (long) fs.SFS_BAVAIL;
d1701 1
a1701 1
**  ENOUGHDISKSPACE -- is there enough free space on the queue fs?
d1716 1
a1716 1
enoughdiskspace(msize)
d1724 1
a1724 1
			printf("enoughdiskspace: no threshold\n");
d1728 1
a1728 1
	if ((bfree = freediskspace(QueueDir, &bsize)) >= 0)
d1731 1
a1731 1
			printf("enoughdiskspace: bavail=%ld, need=%ld\n",
d1741 1
d1743 5
a1747 5
				sm_syslog(LOG_ALERT, CurEnv->e_id,
					"low on space (have %ld, %s needs %ld in %s)",
					bfree,
					CurHostName == NULL ? "SMTP-DAEMON" : CurHostName,
					msize, QueueDir);
d1752 1
a1752 1
		printf("enoughdiskspace failure: min=%ld, need=%ld: %s\n",
a1852 1
	  case E_SM_OPENTIMEOUT:	/* PSEUDO: open timed out */
a1881 2
	int i;
	int save_errno;
d1888 1
a1888 1

d1906 1
a1906 3
	while ((i = fcntl(fd, action, &lfd)) < 0 && errno == EINTR)
		continue;
	if (i >= 0)
a1911 1
	save_errno = errno;
d1914 1
a1914 1
		printf("(%s) ", errstring(save_errno));
d1925 1
a1925 1
	if (save_errno == EINVAL)
d1932 1
a1932 1
	if (!bitset(LOCK_NB, type) || (save_errno != EACCES && save_errno != EAGAIN))
d1936 2
d1939 1
a1939 1
		errno = save_errno;
a1942 1
		dumpfd(fd, TRUE, TRUE);
d1951 1
a1951 3
	while ((i = flock(fd, type)) < 0 && errno == EINTR)
		continue;
	if (i >= 0)
a1956 1
	save_errno = errno;
d1959 1
a1959 1
		printf("(%s) ", errstring(save_errno));
d1961 1
a1961 1
	if (!bitset(LOCK_NB, type) || save_errno != EWOULDBLOCK)
d1965 2
d1968 1
a1968 1
		errno = save_errno;
a1971 1
		dumpfd(fd, TRUE, TRUE);
a1975 1
	errno = save_errno;
a1980 40
**	Unfortunately, given that we can't predict other systems on which
**	a remote mounted (NFS) filesystem will be mounted, the answer is
**	almost always that this is unsafe.
**
**	Note also that many operating systems have non-compliant
**	implementations of the _POSIX_CHOWN_RESTRICTED variable and the
**	fpathconf() routine.  According to IEEE 1003.1-1990, if
**	_POSIX_CHOWN_RESTRICTED is defined and not equal to -1, then
**	no non-root process can give away the file.  However, vendors
**	don't take NFS into account, so a comfortable value of
**	_POSIX_CHOWN_RESTRICTED tells us nothing.
**
**	Also, some systems (e.g., IRIX 6.2) return 1 from fpathconf()
**	even on files where chown is not restricted.  Many systems get
**	this wrong on NFS-based filesystems (that is, they say that chown
**	is restricted [safe] on NFS filesystems where it may not be, since
**	other systems can access the same filesystem and do file giveaway;
**	only the NFS server knows for sure!)  Hence, it is important to
**	get the value of SAFENFSPATHCONF correct -- it should be defined
**	_only_ after testing (see test/t_pathconf.c) a system on an unsafe
**	NFS-based filesystem to ensure that you can get meaningful results.
**	If in doubt, assume unsafe!
**
**	You may also need to tweak IS_SAFE_CHOWN -- it should be a
**	condition indicating whether the return from pathconf indicates
**	that chown is safe (typically either > 0 or >= 0 -- there isn't
**	even any agreement about whether a zero return means that a file
**	is or is not safe).  It defaults to "> 0".
**
**	If the parent directory is safe (writable only by owner back
**	to the root) then we can relax slightly and trust fpathconf
**	in more circumstances.  This is really a crock -- if this is an
**	NFS mounted filesystem then we really know nothing about the
**	underlying implementation.  However, most systems pessimize and
**	return an error (EINVAL or EOPNOTSUPP) on NFS filesystems, which
**	we interpret as unsafe, as we should.  Thus, this heuristic gets
**	us into a possible problem only on systems that have a broken
**	pathconf implementation and which are also poorly configured
**	(have :include: files in group- or world-writable directories).
**
a1982 1
**		safedir -- set if the parent directory is safe.
d1985 2
a1986 2
**		TRUE -- if the chown(2) operation is "safe" -- that is,
**			only root can chown the file to an arbitrary user.
a1989 4
#ifndef IS_SAFE_CHOWN
# define IS_SAFE_CHOWN	> 0
#endif

d1991 1
a1991 1
chownsafe(fd, safedir)
a1992 1
	bool safedir;
d1994 7
a2000 3
#if (!defined(_POSIX_CHOWN_RESTRICTED) || _POSIX_CHOWN_RESTRICTED != -1) && \
    (defined(_PC_CHOWN_RESTRICTED) || defined(_GNU_TYPES_H))
	int rval;
d2002 22
a2023 14
	/* give the system administrator a chance to override */
	if (bitset(DBS_ASSUMESAFECHOWN, DontBlameSendmail))
		return TRUE;

	/*
	**  Some systems (e.g., SunOS) seem to have the call and the
	**  #define _PC_CHOWN_RESTRICTED, but don't actually implement
	**  the call.  This heuristic checks for that.
	*/

	errno = 0;
	rval = fpathconf(fd, _PC_CHOWN_RESTRICTED);
# if SAFENFSPATHCONF
	return errno == 0 && rval IS_SAFE_CHOWN;
d2025 9
a2033 45
	return safedir && errno == 0 && rval IS_SAFE_CHOWN;
# endif
#else
	return bitset(DBS_ASSUMESAFECHOWN, DontBlameSendmail);
#endif
}
/*
**  RESETLIMITS -- reset system controlled resource limits
**
**	This is to avoid denial-of-service attacks
**
**	Parameters:
**		none
**
**	Returns:
**		none
*/

#if HASSETRLIMIT
# ifdef RLIMIT_NEEDS_SYS_TIME_H
#  include <sys/time.h>
# endif
# include <sys/resource.h>
#endif
#ifndef FD_SETSIZE
# define FD_SETSIZE	256
#endif

void
resetlimits()
{
#if HASSETRLIMIT
	struct rlimit lim;

	lim.rlim_cur = lim.rlim_max = RLIM_INFINITY;
	(void) setrlimit(RLIMIT_CPU, &lim);
	(void) setrlimit(RLIMIT_FSIZE, &lim);
# ifdef RLIMIT_NOFILE
	lim.rlim_cur = lim.rlim_max = FD_SETSIZE;
	(void) setrlimit(RLIMIT_NOFILE, &lim);
# endif
#else
# if HASULIMIT
	(void) ulimit(2, 0x3fffff);
	(void) ulimit(4, FD_SETSIZE);
a2035 1
	errno = 0;
a2045 1

d2048 1
a2048 1
#if NETINFO
d2050 1
a2050 1
		extern char *ni_propval __P((char *, char *, char *, char *, int));
d2053 1
a2053 2
		cflocation = ni_propval("/locations", NULL, "sendmail",
					"sendmail.cf", '\0');
a2057 1

a2081 2
	{
		VendorCode = VENDOR_BERKELEY;
a2082 1
	}
a2085 8
#ifdef SUN_EXTENSIONS
	if (strcasecmp(vendor, "Sun") == 0)
	{
		VendorCode = VENDOR_SUN;
		return TRUE;
	}
#endif

a2088 180
**  VENDOR_PRE_DEFAULTS, VENDOR_POST_DEFAULTS -- set vendor-specific defaults
**
**	Vendor_pre_defaults is called before reading the configuration
**	file; vendor_post_defaults is called immediately after.
**
**	Parameters:
**		e -- the global environment to initialize.
**
**	Returns:
**		none.
*/

#if SHARE_V1
int	DefShareUid;	/* default share uid to run as -- unused??? */
#endif

void
vendor_pre_defaults(e)
	ENVELOPE *e;
{
#if SHARE_V1
	/* OTHERUID is defined in shares.h, do not be alarmed */
	DefShareUid = OTHERUID;
#endif
#if defined(SUN_EXTENSIONS) && defined(SUN_DEFAULT_VALUES)
	sun_pre_defaults(e);
#endif
#ifdef apollo
	/* stupid domain/os can't even open /etc/sendmail.cf without this */
	setuserenv("ISP", NULL);
	setuserenv("SYSTYPE", NULL);
#endif
}


void
vendor_post_defaults(e)
	ENVELOPE *e;
{
#ifdef __QNX__
	char *p;
	
	/* Makes sure the SOCK environment variable remains */
	if (p = getextenv("SOCK"))
		setuserenv("SOCK", p);
#endif
#if defined(SUN_EXTENSIONS) && defined(SUN_DEFAULT_VALUES)
	sun_post_defaults(e);
#endif
}
/*
**  VENDOR_DAEMON_SETUP -- special vendor setup needed for daemon mode
*/

void
vendor_daemon_setup(e)
	ENVELOPE *e;
{
#if SECUREWARE
	if (getluid() != -1)
	{
		usrerr("Daemon cannot have LUID");
		exit(EX_USAGE);
	}
#endif /* SECUREWARE */
}
/*
**  VENDOR_SET_UID -- do setup for setting a user id
**
**	This is called when we are still root.
**
**	Parameters:
**		uid -- the uid we are about to become.
**
**	Returns:
**		none.
*/

void
vendor_set_uid(uid)
	UID_T uid;
{
	/* 
	**  We need to setup the share groups (lnodes)
	**  and and auditing inforation (luid's)
	**  before we loose our ``root''ness.
	*/
#if SHARE_V1
	if (setupshares(uid, syserr) != 0)
		syserr("Unable to set up shares");
#endif
#if SECUREWARE
	(void) setup_secure(uid);
#endif
}
/*
**  VALIDATE_CONNECTION -- check connection for rationality
**
**	If the connection is rejected, this routine should log an
**	appropriate message -- but should never issue any SMTP protocol.
**
**	Parameters:
**		sap -- a pointer to a SOCKADDR naming the peer.
**		hostname -- the name corresponding to sap.
**		e -- the current envelope.
**
**	Returns:
**		error message from rejection.
**		NULL if not rejected.
*/

#if TCPWRAPPERS
# include <tcpd.h>

/* tcpwrappers does no logging, but you still have to declare these -- ugh */
int	allow_severity	= LOG_INFO;
int	deny_severity	= LOG_NOTICE;
#endif

#if DAEMON
char *
validate_connection(sap, hostname, e)
	SOCKADDR *sap;
	char *hostname;
	ENVELOPE *e;
{
#if TCPWRAPPERS
	char *host;
#endif

	if (tTd(48, 3))
		printf("validate_connection(%s, %s)\n",
			hostname, anynet_ntoa(sap));

	if (rscheck("check_relay", hostname, anynet_ntoa(sap), e) != EX_OK)
	{
		static char reject[BUFSIZ*2];
		extern char MsgBuf[];

		if (tTd(48, 4))
			printf("  ... validate_connection: BAD (rscheck)\n");

		if (strlen(MsgBuf) > 5)
		{
			if (isascii(MsgBuf[0]) && isdigit(MsgBuf[0]) &&
			    isascii(MsgBuf[1]) && isdigit(MsgBuf[1]) &&
			    isascii(MsgBuf[2]) && isdigit(MsgBuf[2]))
				strcpy(reject, &MsgBuf[4]);
			else
				strcpy(reject, MsgBuf);
		}
		else
			strcpy(reject, "Access denied");

		return reject;
	}

#if TCPWRAPPERS
	if (hostname[0] == '[' && hostname[strlen(hostname) - 1] == ']')
		host = "unknown";
	else
		host = hostname;
	if (!hosts_ctl("sendmail", host, anynet_ntoa(sap), STRING_UNKNOWN))
	{
		if (tTd(48, 4))
			printf("  ... validate_connection: BAD (tcpwrappers)\n");
		if (LogLevel >= 4)
			sm_syslog(LOG_NOTICE, NOQID,
				"tcpwrappers (%s, %s) rejection",
				host, anynet_ntoa(sap));
		return "Access denied";
	}
#endif
	if (tTd(48, 4))
		printf("  ... validate_connection: OK\n");
	return NULL;
}

#endif
/*
d2102 2
d2194 1
a2194 5
**  STRSTR -- find first substring in string
**
**	Parameters:
**		big -- the big (full) string.
**		little -- the little (sub) string.
d2196 2
a2197 4
**	Returns:
**		A pointer to the first instance of little in big.
**		big if little is the null string.
**		NULL if little is not contained in big.
d2200 1
a2200 1
#ifdef NEEDSTRSTR
d2202 1
a2202 11
char *
strstr(big, little)
	char *big;
	char *little;
{
	register char *p = big;
	int l;

	if (*little == '\0')
		return big;
	l = strlen(little);
d2204 5
a2208 26
	while ((p = strchr(p, *little)) != NULL)
	{
		if (strncmp(p, little, l) == 0)
			return p;
		p++;
	}
	return NULL;
}

#endif
/*
**  SM_GETHOSTBY{NAME,ADDR} -- compatibility routines for gethostbyXXX
**
**	Some operating systems have wierd problems with the gethostbyXXX
**	routines.  For example, Solaris versions at least through 2.3
**	don't properly deliver a canonical h_name field.  This tries to
**	work around these problems.
*/

struct hostent *
sm_gethostbyname(name)
	char *name;
{
	struct hostent *h;
#if (SOLARIS > 10000 && SOLARIS < 20400) || (defined(SOLARIS) && SOLARIS < 204) || (defined(sony_news) && defined(__svr4))
# if SOLARIS == 20300 || SOLARIS == 203
d2213 1
a2213 3
	if (tTd(61, 10))
		printf("_switch_gethostbyname_r(%s)... ", name);
	h = _switch_gethostbyname_r(name, &hp, buf, sizeof(buf), &h_errno);
d2217 1
a2217 3
	if (tTd(61, 10))
		printf("__switch_gethostbyname(%s)... ", name);
	h = __switch_gethostbyname(name);
a2218 45
#else
	int nmaps;
	char *maptype[MAXMAPSTACK];
	short mapreturn[MAXMAPACTIONS];
	char hbuf[MAXNAME];

	if (tTd(61, 10))
		printf("gethostbyname(%s)... ", name);
	h = gethostbyname(name);
	if (h == NULL)
	{
		if (tTd(61, 10))
			printf("failure\n");

		nmaps = switch_map_find("hosts", maptype, mapreturn);
		while (--nmaps >= 0)
			if (strcmp(maptype[nmaps], "nis") == 0 ||
			    strcmp(maptype[nmaps], "files") == 0)
				break;
		if (nmaps >= 0)
		{
			/* try short name */
			if (strlen(name) > (SIZE_T) sizeof hbuf - 1)
				return NULL;
			strcpy(hbuf, name);
			shorten_hostname(hbuf);

			/* if it hasn't been shortened, there's no point */
			if (strcmp(hbuf, name) != 0)
			{
				if (tTd(61, 10))
					printf("gethostbyname(%s)... ", hbuf);
				h = gethostbyname(hbuf);
			}
		}
	}
#endif
	if (tTd(61, 10))
	{
		if (h == NULL)
			printf("failure\n");
		else
			printf("%s\n", h->h_name);
	}
	return h;
d2222 2
a2223 2
sm_gethostbyaddr(addr, len, type)
	char *addr;
d2227 1
a2227 2
#if (SOLARIS > 10000 && SOLARIS < 20400) || (defined(SOLARIS) && SOLARIS < 204)
# if SOLARIS == 20300 || SOLARIS == 203
a2237 3
#else
	return gethostbyaddr(addr, len, type);
#endif
a2238 10
/*
**  SM_GETPW{NAM,UID} -- wrapper for getpwnam and getpwuid
*/

struct passwd *
sm_getpwnam(user)
	char *user;
{
#ifdef _AIX4
	extern struct passwd *_getpwnam_shadow(const char *, const int);
a2239 3
	return _getpwnam_shadow(user, 0);
#else
	return getpwnam(user);
a2240 14
}

struct passwd *
sm_getpwuid(uid)
	UID_T uid;
{
#if defined(_AIX4) && 0
	extern struct passwd *_getpwuid_shadow(const int, const int);

	return _getpwuid_shadow(uid,0);
#else
	return getpwuid(uid);
#endif
}
d2242 1
a2242 4
**  SECUREWARE_SETUP_SECURE -- Convex SecureWare setup
**
**	Set up the trusted computing environment for C2 level security
**	under SecureWare.
d2245 2
a2246 1
**		uid -- uid of the user to initialize in the TCB
d2249 6
a2254 1
**		none
d2256 2
a2257 2
**	Side Effects:
**		Initialized the user in the trusted computing base
d2260 1
a2260 1
#if SECUREWARE
d2262 1
a2262 2
# include <sys/security.h>
# include <prot.h>
d2264 3
a2266 5
void
secureware_setup_secure(uid)
	UID_T uid;
{
	int rc;
d2268 4
a2271 63
	if (getluid() != -1)
		return;
	
	if ((rc = set_secure_info(uid)) != SSI_GOOD_RETURN)
	{
		switch (rc)
		{
		  case SSI_NO_PRPW_ENTRY:
			syserr("No protected passwd entry, uid = %d", uid);
			break;

		  case SSI_LOCKED:
			syserr("Account has been disabled, uid = %d", uid);
			break;

		  case SSI_RETIRED:
			syserr("Account has been retired, uid = %d", uid);
			break;

		  case SSI_BAD_SET_LUID:
			syserr("Could not set LUID, uid = %d", uid);
			break;

		  case SSI_BAD_SET_PRIVS:
			syserr("Could not set kernel privs, uid = %d", uid);

		  default:
			syserr("Unknown return code (%d) from set_secure_info(%d)", 
				rc, uid);
			break;
		}
		exit(EX_NOPERM);
	}
}
#endif /* SECUREWARE */
/*
**  LOAD_IF_NAMES -- load interface-specific names into $=w
**
**	Parameters:
**		none.
**
**	Returns:
**		none.
**
**	Side Effects:
**		Loads $=w with the names of all the interfaces.
*/

#if defined(SIOCGIFCONF) && !SIOCGIFCONF_IS_BROKEN
struct rtentry;
struct mbuf;
# include <arpa/inet.h>
# ifndef SUNOS403
#  include <sys/time.h>
# endif
# if _AIX4 >= 40300
#  undef __P
# endif
# include <net/if.h>
#endif

void
load_if_names()
d2273 1
a2273 2
#if defined(SIOCGIFCONF) && !SIOCGIFCONF_IS_BROKEN
	int s;
d2275 5
a2279 2
	struct ifconf ifc;
	int numifs;
d2281 7
a2287 18
	s = socket(AF_INET, SOCK_DGRAM, 0);
	if (s == -1)
		return;

	/* get the list of known IP address from the kernel */
# if defined(SIOCGIFNUM) && !SIOCGIFNUM_IS_BROKEN
	if (ioctl(s, SIOCGIFNUM, (char *) &numifs) < 0)
	{
		/* can't get number of interfaces -- fall back */
		if (tTd(0, 4))
			printf("SIOCGIFNUM failed: %s\n", errstring(errno));
		numifs = -1;
	}
	else if (tTd(0, 42))
		printf("system has %d interfaces\n", numifs);
	if (numifs < 0)
# endif
		numifs = 512;
d2289 1
a2289 1
	if (numifs <= 0)
d2291 4
a2294 33
		close(s);
		return;
	}
	ifc.ifc_len = numifs * sizeof (struct ifreq);
	ifc.ifc_buf = xalloc(ifc.ifc_len);
	if (ioctl(s, SIOCGIFCONF, (char *)&ifc) < 0)
	{
		if (tTd(0, 4))
			printf("SIOGIFCONF failed: %s\n", errstring(errno));
		close(s);
		return;
	}

	/* scan the list of IP address */
	if (tTd(0, 40))
		printf("scanning for interface specific names, ifc_len=%d\n",
			ifc.ifc_len);

	for (i = 0; i < ifc.ifc_len; )
	{
		struct ifreq *ifr = (struct ifreq *) &ifc.ifc_buf[i];
		struct sockaddr *sa = &ifr->ifr_addr;
		struct in_addr ia;
		struct hostent *hp;
#ifdef SIOCGIFFLAGS
		struct ifreq ifrf;
#endif
		char ip_addr[256];
		extern char *inet_ntoa();

#ifdef BSD4_4_SOCKADDR
		if (sa->sa_len > sizeof ifr->ifr_addr)
			i += sizeof ifr->ifr_name + sa->sa_len;
d2296 6
a2301 2
#endif
			i += sizeof *ifr;
d2303 7
a2309 2
		if (tTd(0, 20))
			printf("%s\n", anynet_ntoa((SOCKADDR *) sa));
d2311 2
a2312 2
		if (ifr->ifr_addr.sa_family != AF_INET)
			continue;
d2314 3
a2316 12
#ifdef SIOCGIFFLAGS
		bzero(&ifrf, sizeof(struct ifreq));
		strncpy(ifrf.ifr_name, ifr->ifr_name, sizeof(ifrf.ifr_name));
		ioctl(s, SIOCGIFFLAGS, (char *) &ifrf);
		if (tTd(0, 41))
			printf("\tflags: %x\n", ifrf.ifr_flags);
# define IFRFREF ifrf
#else
# define IFRFREF (*ifr)
#endif
		if (!bitset(IFF_UP, IFRFREF.ifr_flags))
			continue;
d2318 1
a2318 6
		/* extract IP address from the list*/
		ia = (((struct sockaddr_in *) sa)->sin_addr);
		if (ia.s_addr == INADDR_ANY || ia.s_addr == INADDR_NONE)
		{
			message("WARNING: interface %s is UP with %s address",
				ifr->ifr_name, inet_ntoa(ia));
a2319 1
		}
d2321 3
a2323 10
		/* save IP address in text from */
		(void) snprintf(ip_addr, sizeof ip_addr, "[%.*s]",
			sizeof ip_addr - 3,
			inet_ntoa(ia));
		if (!wordinclass(ip_addr, 'w'))
		{
			setclass('w', ip_addr);
			if (tTd(0, 4))
				printf("\ta.k.a.: %s\n", ip_addr);
		}
d2325 1
a2325 2
		/* skip "loopback" interface "lo" */
		if (bitset(IFF_LOOPBACK, IFRFREF.ifr_flags))
d2328 5
a2332 15
		/* lookup name with IP address */
		hp = sm_gethostbyaddr((char *) &ia, sizeof(ia), AF_INET);
		if (hp == NULL)
		{
			if (LogLevel > 3)
				sm_syslog(LOG_WARNING, NOQID,
					"gethostbyaddr(%.100s) failed: %d\n",
					inet_ntoa(ia),
#if NAMED_BIND
					h_errno);
#else
					-1);
#endif
			continue;
		}
d2334 1
a2334 2
		/* save its cname */
		if (!wordinclass((char *) hp->h_name, 'w'))
d2336 2
a2337 3
			setclass('w', (char *) hp->h_name);
			if (tTd(0, 4))
				printf("\ta.k.a.: %s\n", hp->h_name);
d2339 1
d2341 3
a2343 26
		/* save all it aliases name */
		while (*hp->h_aliases)
		{
			if (!wordinclass(*hp->h_aliases, 'w'))
			{
				setclass('w', *hp->h_aliases);
				if (tTd(0, 4))
				printf("\ta.k.a.: %s\n", *hp->h_aliases);
			}
			hp->h_aliases++;
		}
	}
	free(ifc.ifc_buf);
	close(s);
# undef IFRFREF
#endif
}
/*
**  GET_NUM_PROCS_ONLINE -- return the number of processors currently online
**
**	Parameters:
**		none.
**
**	Returns:
**		The number of processors online.
*/
d2345 4
a2348 4
int
get_num_procs_online()
{
	int nproc = 0;
d2350 1
a2350 8
#if _FFR_SCALE_LA_BY_NUM_PROCS
#ifdef _SC_NPROCESSORS_ONLN
	nproc = (int) sysconf(_SC_NPROCESSORS_ONLN);
#endif
#endif
	if (nproc <= 0)
		nproc = 1;
	return nproc;
a2351 12
/*
**  SM_SYSLOG -- syslog wrapper to keep messages under SYSLOG_BUFSIZE
**
**	Parameters:
**		level -- syslog level
**		id -- envelope ID or NULL (NOQUEUE)
**		fmt -- format string
**		arg... -- arguments as implied by fmt.
**
**	Returns:
**		none
*/
d2353 1
a2353 123
/* VARARGS3 */
void
# ifdef __STDC__
sm_syslog(int level, const char *id, const char *fmt, ...)
# else
sm_syslog(level, id, fmt, va_alist)
	int level;
	const char *id;
	const char *fmt;
	va_dcl
#endif
{
	static char *buf = NULL;
	static size_t bufsize = MAXLINE;
	char *begin, *end;
	int seq = 1;
	int idlen;
	extern int SnprfOverflow;
	extern int SyslogErrno;
	extern char *DoprEnd;
	VA_LOCAL_DECL
	extern void sm_dopr __P((char *, const char *, ...));
	
	SyslogErrno = errno;
	if (id == NULL)
	{
		id = "NOQUEUE";
		idlen = 9;
	}
	else if (strcmp(id, NOQID) == 0)
	{
		id = "";
		idlen = 0;
	}
	else
		idlen = strlen(id + 2);
bufalloc:
	if (buf == NULL)
		buf = (char *) xalloc(sizeof(char) * bufsize);

	/* do a virtual vsnprintf into buf */
	VA_START(fmt);
	buf[0] = 0;
	DoprEnd = buf + bufsize - 1;
	SnprfOverflow = 0;
	sm_dopr(buf, fmt, ap);
	*DoprEnd = '\0';
	VA_END;
	/* end of virtual vsnprintf */

	if (SnprfOverflow)
	{
		/* String too small, redo with correct size */
		bufsize += SnprfOverflow + 1;
		free(buf);
		buf = NULL;
		goto bufalloc;
	}
	if ((strlen(buf) + idlen + 1) < SYSLOG_BUFSIZE)
	{
#if LOG
		if (*id == '\0')
			syslog(level, "%s", buf);
		else
			syslog(level, "%s: %s", id, buf);
#else
		/*XXX should do something more sensible */
		if (*id == '\0')
			fprintf(stderr, "%s\n", buf);
		else
			fprintf(stderr, "%s: %s\n", id, buf);
#endif
		return;
	}

	begin = buf;
	while (*begin != '\0' &&
	       (strlen(begin) + idlen + 5) > SYSLOG_BUFSIZE) 
	{
		char save;
	
		if (seq == 999)
		{
			/* Too many messages */
			break;
		}
		end = begin + SYSLOG_BUFSIZE - idlen - 12;
		while (end > begin)
		{
			/* Break on comma or space */
			if (*end == ',' || *end == ' ')
			{
				end++;	  /* Include separator */
				break;
			}
			end--;
		}
		/* No separator, break midstring... */
		if (end == begin)
			end = begin + SYSLOG_BUFSIZE - idlen - 12;
		save = *end;
		*end = 0;
#if LOG
		syslog(level, "%s[%d]: %s ...", id, seq++, begin);
#else
		fprintf(stderr, "%s[%d]: %s ...\n", id, seq++, begin);
#endif
		*end = save;
		begin = end;
	}
	if (seq == 999)
#if LOG
		syslog(level, "%s[%d]: log terminated, too many parts", id, seq);
#else
		fprintf(stderr, "%s[%d]: log terminated, too many parts\n", id, seq);
#endif
	else if (*begin != '\0')
#if LOG
		syslog(level, "%s[%d]: %s", id, seq, begin);
#else
		fprintf(stderr, "%s[%d]: %s\n", id, seq, begin);
#endif
}
d2361 1
a2361 1
#if defined(__hpux) && !defined(HPUX11)
a2364 7
# ifdef V4FS
#  define XCNST	const
#  define CAST	(const char *)
# else
#  define XCNST
#  define CAST
# endif
a2365 1
void
d2367 1
a2367 1
hard_syslog(int pri, XCNST char *msg, ...)
d2371 1
a2371 1
	XCNST char *msg;
d2376 1
a2376 1
	char buf[SYSLOG_BUFSIZE];
d2380 1
a2380 1
	vsnprintf(buf, sizeof buf, msg, ap);
d2383 1
a2383 1
	for (i = MAXSYSLOGTRIES; --i >= 0 && syslog(pri, CAST "%s", buf) < 0; )
a2386 63
# undef CAST
#endif
/*
**  LOCAL_HOSTNAME_LENGTH
**
**	This is required to get sendmail to compile against BIND 4.9.x
**	on Ultrix.
*/

#if defined(ultrix) && NAMED_BIND

# include <resolv.h>
# if __RES >= 19931104 && __RES < 19950621

int
local_hostname_length(hostname)
	char *hostname;
{
	int len_host, len_domain;

	if (!*_res.defdname)
		res_init();
	len_host = strlen(hostname);
	len_domain = strlen(_res.defdname);
	if (len_host > len_domain &&
	    (strcasecmp(hostname + len_host - len_domain,_res.defdname) == 0) &&
	    hostname[len_host - len_domain - 1] == '.')
		return len_host - len_domain - 1;
	else
		return 0;
}

# endif
#endif
/*
**  Compile-Time options
*/

char	*CompileOptions[] =
{
#ifdef HESIOD
	"HESIOD",
#endif
#if HES_GETMAILHOST
	"HES_GETMAILHOST",
#endif
#ifdef LDAPMAP
	"LDAPMAP",
#endif
#ifdef MAP_REGEX
	"MAP_REGEX",
#endif
#if LOG
	"LOG",
#endif
#if MATCHGECOS
	"MATCHGECOS",
#endif
#if MIME7TO8
	"MIME7TO8",
#endif
#if MIME8TO7
	"MIME8TO7",
a2387 177
#if NAMED_BIND
	"NAMED_BIND",
#endif
#ifdef NDBM
	"NDBM",
#endif
#if NETINET
	"NETINET",
#endif
#if NETINFO
	"NETINFO",
#endif
#if NETISO
	"NETISO",
#endif
#if NETNS
	"NETNS",
#endif
#if NETUNIX
	"NETUNIX",
#endif
#if NETX25
	"NETX25",
#endif
#ifdef NEWDB
	"NEWDB",
#endif
#ifdef NIS
	"NIS",
#endif
#ifdef NISPLUS
	"NISPLUS",
#endif
#if QUEUE
	"QUEUE",
#endif
#if SCANF
	"SCANF",
#endif
#if SMTP
	"SMTP",
#endif
#if SMTPDEBUG
	"SMTPDEBUG",
#endif
#ifdef SUID_ROOT_FILES_OK
	"SUID_ROOT_FILES_OK",
#endif
#if TCPWRAPPERS
	"TCPWRAPPERS",
#endif
#if USERDB
	"USERDB",
#endif
#if XDEBUG
	"XDEBUG",
#endif
#ifdef XLA
	"XLA",
#endif
	NULL
};


/*
**  OS compile options.
*/

char	*OsCompileOptions[] =
{
#if BOGUS_O_EXCL
	"BOGUS_O_EXCL",
#endif
#if HASFCHMOD
	"HASFCHMOD",
#endif
#if HASFLOCK
	"HASFLOCK",
#endif
#if HASGETDTABLESIZE
	"HASGETDTABLESIZE",
#endif
#if HASGETUSERSHELL
	"HASGETUSERSHELL",
#endif
#if HASINITGROUPS
	"HASINITGROUPS",
#endif
#if HASLSTAT
	"HASLSTAT",
#endif
#if HASSETREUID
	"HASSETREUID",
#endif
#if HASSETRLIMIT
	"HASSETRLIMIT",
#endif
#if HASSETSID
	"HASSETSID",
#endif
#if HASSETUSERCONTEXT
	"HASSETUSERCONTEXT",
#endif
#if HASSETVBUF
	"HASSETVBUF",
#endif
#if HASSNPRINTF
	"HASSNPRINTF",
#endif
#if HAS_ST_GEN
	"HAS_ST_GEN",
#endif
#if HASSTRERROR
	"HASSTRERROR",
#endif
#if HASULIMIT
	"HASULIMIT",
#endif
#if HASUNAME
	"HASUNAME",
#endif
#if HASUNSETENV
	"HASUNSETENV",
#endif
#if HASWAITPID
	"HASWAITPID",
#endif
#if IDENTPROTO
	"IDENTPROTO",
#endif
#if IP_SRCROUTE
	"IP_SRCROUTE",
#endif
#if O_EXLOCK && HASFLOCK && !BOGUS_O_EXCL
	"LOCK_ON_OPEN",
#endif
#if NEEDFSYNC
	"NEEDFSYNC",
#endif
#if NOFTRUNCATE
	"NOFTRUNCATE",
#endif
#if RLIMIT_NEEDS_SYS_TIME_H
	"RLIMIT_NEEDS_SYS_TIME_H",
#endif
#if SAFENFSPATHCONF
	"SAFENFSPATHCONF",
#endif
#if SECUREWARE
	"SECUREWARE",
#endif
#if SHARE_V1
	"SHARE_V1",
#endif
#if SIOCGIFCONF_IS_BROKEN
	"SIOCGIFCONF_IS_BROKEN",
#endif
#if SIOCGIFNUM_IS_BROKEN
	"SIOCGIFNUM_IS_BROKEN",
#endif
#if SYS5SETPGRP
	"SYS5SETPGRP",
#endif
#if SYSTEM5
	"SYSTEM5",
#endif
#if USE_SA_SIGACTION
	"USE_SA_SIGACTION",
#endif
#if USE_SIGLONGJMP
	"USE_SIGLONGJMP",
#endif
#if USESETEUID
	"USESETEUID",
#endif
	NULL
};
@

