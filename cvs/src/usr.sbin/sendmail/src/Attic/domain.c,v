head	1.10;
access;
symbols
	OPENBSD_2_6:1.9.0.4
	OPENBSD_2_6_BASE:1.9
	OPENBSD_2_5:1.9.0.2
	OPENBSD_2_5_BASE:1.9
	OPENBSD_2_4:1.7.0.2
	OPENBSD_2_4_BASE:1.7
	sendmail_8_9_1:1.1.1.2
	UCB:1.1.1
	OPENBSD_2_3:1.6.0.4
	OPENBSD_2_3_BASE:1.6
	OPENBSD_2_2:1.6.0.2
	OPENBSD_2_2_BASE:1.6
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.10
date	2000.04.18.04.57.20;	author millert;	state dead;
branches;
next	1.9;

1.9
date	99.02.05.05.59.27;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	99.01.01.20.33.45;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	98.07.12.19.44.36;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	97.08.04.02.17.51;	author downsj;	state Exp;
branches;
next	1.5;

1.5
date	97.07.15.07.24.04;	author downsj;	state Exp;
branches;
next	1.4;

1.4
date	96.12.14.21.17.16;	author downsj;	state Exp;
branches;
next	1.3;

1.3
date	96.09.19.06.44.56;	author fn;	state Exp;
branches;
next	1.2;

1.2
date	96.01.29.01.43.49;	author dm;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.48.18;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.48.18;	author deraadt;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	98.07.12.17.10.04;	author millert;	state Exp;
branches;
next	;


desc
@@


1.10
log
@remove sendmail 8.9.3
@
text
@/*
 * Copyright (c) 1998 Sendmail, Inc.  All rights reserved.
 * Copyright (c) 1986, 1995-1997 Eric P. Allman.  All rights reserved.
 * Copyright (c) 1988, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * By using this file, you agree to the terms and conditions set
 * forth in the LICENSE file which can be found at the top level of
 * the sendmail distribution.
 *
 */

#include "sendmail.h"

#ifndef lint
#if NAMED_BIND
static char sccsid[] = "@@(#)domain.c	8.81 (Berkeley) 1/21/1999 (with name server)";
#else
static char sccsid[] = "@@(#)domain.c	8.81 (Berkeley) 1/21/1999 (without name server)";
#endif
#endif /* not lint */

#if NAMED_BIND

#include <errno.h>
#include <resolv.h>
#include <arpa/inet.h>

/*
**  The standard udp packet size PACKETSZ (512) is not sufficient for some
**  nameserver answers containing very many resource records. The resolver
**  may switch to tcp and retry if it detects udp packet overflow.
**  Also note that the resolver routines res_query and res_search return
**  the size of the *un*truncated answer in case the supplied answer buffer
**  it not big enough to accommodate the entire answer.
*/

#ifndef MAXPACKET
# define MAXPACKET 8192		/* max packet size used internally by BIND */
#endif

typedef union
{
	HEADER	qb1;
	u_char	qb2[MAXPACKET];
} querybuf;

#ifndef MXHOSTBUFSIZE
# define MXHOSTBUFSIZE	(128 * MAXMXHOSTS)
#endif

static char	MXHostBuf[MXHOSTBUFSIZE];

#ifndef MAXDNSRCH
# define MAXDNSRCH	6	/* number of possible domains to search */
#endif

#ifndef MAX
# define MAX(a, b)	((a) > (b) ? (a) : (b))
#endif

#ifndef NO_DATA
# define NO_DATA	NO_ADDRESS
#endif

#ifndef HFIXEDSZ
# define HFIXEDSZ	12	/* sizeof(HEADER) */
#endif

#define MAXCNAMEDEPTH	10	/* maximum depth of CNAME recursion */

#if defined(__RES) && (__RES >= 19940415)
# define RES_UNC_T	char *
#else
# define RES_UNC_T	u_char *
#endif
/*
**  GETMXRR -- get MX resource records for a domain
**
**	Parameters:
**		host -- the name of the host to MX.
**		mxhosts -- a pointer to a return buffer of MX records.
**		droplocalhost -- If TRUE, all MX records less preferred
**			than the local host (as determined by $=w) will
**			be discarded.
**		rcode -- a pointer to an EX_ status code.
**
**	Returns:
**		The number of MX records found.
**		-1 if there is an internal failure.
**		If no MX records are found, mxhosts[0] is set to host
**			and 1 is returned.
*/

int
getmxrr(host, mxhosts, droplocalhost, rcode)
	char *host;
	char **mxhosts;
	bool droplocalhost;
	int *rcode;
{
	register u_char *eom, *cp;
	register int i, j, n;
	int nmx = 0;
	register char *bp;
	HEADER *hp;
	querybuf answer;
	int ancount, qdcount, buflen;
	bool seenlocal = FALSE;
	u_short pref, type;
	u_short localpref = 256;
	char *fallbackMX = FallBackMX;
	bool trycanon = FALSE;
	int (*resfunc)();
	extern int res_query(), res_search();
	u_short prefer[MAXMXHOSTS];
	int weight[MAXMXHOSTS];
	extern int mxrand __P((char *));

	if (tTd(8, 2))
		printf("getmxrr(%s, droplocalhost=%d)\n", host, droplocalhost);

	if (fallbackMX != NULL && droplocalhost &&
	    wordinclass(fallbackMX, 'w'))
	{
		/* don't use fallback for this pass */
		fallbackMX = NULL;
	}

	*rcode = EX_OK;

	/* efficiency hack -- numeric or non-MX lookups */
	if (host[0] == '[')
		goto punt;

	/*
	**  If we don't have MX records in our host switch, don't
	**  try for MX records.  Note that this really isn't "right",
	**  since we might be set up to try NIS first and then DNS;
	**  if the host is found in NIS we really shouldn't be doing
	**  MX lookups.  However, that should be a degenerate case.
	*/

	if (!UseNameServer)
		goto punt;
	if (HasWildcardMX && ConfigLevel >= 6)
		resfunc = res_query;
	else
		resfunc = res_search;

	errno = 0;
	n = (*resfunc)(host, C_IN, T_MX, (u_char *) &answer, sizeof(answer));
	if (n < 0)
	{
		if (tTd(8, 1))
			printf("getmxrr: res_search(%s) failed (errno=%d, h_errno=%d)\n",
			    (host == NULL) ? "<NULL>" : host, errno, h_errno);
		switch (h_errno)
		{
		  case NO_DATA:
			trycanon = TRUE;
			/* fall through */

		  case NO_RECOVERY:
			/* no MX data on this host */
			goto punt;

		  case HOST_NOT_FOUND:
#if BROKEN_RES_SEARCH
		  case 0:	/* Ultrix resolver retns failure w/ h_errno=0 */
#endif
			/* host doesn't exist in DNS; might be in /etc/hosts */
			trycanon = TRUE;
			*rcode = EX_NOHOST;
			goto punt;

		  case TRY_AGAIN:
		  case -1:
			/* couldn't connect to the name server */
			if (fallbackMX != NULL)
			{
				/* name server is hosed -- push to fallback */
				mxhosts[nmx++] = fallbackMX;
				return nmx;
			}
			/* it might come up later; better queue it up */
			*rcode = EX_TEMPFAIL;
			break;

		  default:
			syserr("getmxrr: res_search (%s) failed with impossible h_errno (%d)\n",
				host, h_errno);
			*rcode = EX_OSERR;
			break;
		}

		/* irreconcilable differences */
		return (-1);
	}

	/* avoid problems after truncation in tcp packets */
	if (n > sizeof(answer))
		n = sizeof(answer);

	/* find first satisfactory answer */
	hp = (HEADER *)&answer;
	cp = (u_char *)&answer + HFIXEDSZ;
	eom = (u_char *)&answer + n;
	for (qdcount = ntohs(hp->qdcount); qdcount--; cp += n + QFIXEDSZ)
		if ((n = dn_skipname(cp, eom)) < 0)
			goto punt;
	buflen = sizeof(MXHostBuf) - 1;
	bp = MXHostBuf;
	ancount = ntohs(hp->ancount);
	while (--ancount >= 0 && cp < eom && nmx < MAXMXHOSTS - 1)
	{
		if ((n = dn_expand((u_char *)&answer,
		    eom, cp, (RES_UNC_T) bp, buflen)) < 0)
			break;
		cp += n;
		GETSHORT(type, cp);
 		cp += INT16SZ + INT32SZ;
		GETSHORT(n, cp);
		if (type != T_MX)
		{
			if (tTd(8, 8) || _res.options & RES_DEBUG)
				printf("unexpected answer type %d, size %d\n",
				    type, n);
			cp += n;
			continue;
		}
		GETSHORT(pref, cp);
		if ((n = dn_expand((u_char *)&answer, eom, cp,
				   (RES_UNC_T) bp, buflen)) < 0)
			break;
		cp += n;
		if (wordinclass(bp, 'w'))
		{
			if (tTd(8, 3))
				printf("found localhost (%s) in MX list, pref=%d\n",
					bp, pref);
			if (droplocalhost)
			{
				if (!seenlocal || pref < localpref)
					localpref = pref;
				seenlocal = TRUE;
				continue;
			}
			weight[nmx] = 0;
		}
		else
			weight[nmx] = mxrand(bp);
		prefer[nmx] = pref;
		mxhosts[nmx++] = bp;
		n = strlen(bp);
		bp += n;
		if (bp[-1] != '.')
		{
			*bp++ = '.';
			n++;
		}
		*bp++ = '\0';
		buflen -= n + 1;
	}

	/* sort the records */
	for (i = 0; i < nmx; i++)
	{
		for (j = i + 1; j < nmx; j++)
		{
			if (prefer[i] > prefer[j] ||
			    (prefer[i] == prefer[j] && weight[i] > weight[j]))
			{
				register int temp;
				register char *temp1;

				temp = prefer[i];
				prefer[i] = prefer[j];
				prefer[j] = temp;
				temp1 = mxhosts[i];
				mxhosts[i] = mxhosts[j];
				mxhosts[j] = temp1;
				temp = weight[i];
				weight[i] = weight[j];
				weight[j] = temp;
			}
		}
		if (seenlocal && prefer[i] >= localpref)
		{
			/* truncate higher preference part of list */
			nmx = i;
		}
	}

	/* delete duplicates from list (yes, some bozos have duplicates) */
	for (i = 0; i < nmx - 1; )
	{
		if (strcasecmp(mxhosts[i], mxhosts[i + 1]) != 0)
			i++;
		else
		{
			/* compress out duplicate */
			for (j = i + 1; j < nmx; j++)
				mxhosts[j] = mxhosts[j + 1];
			nmx--;
		}
	}

	if (nmx == 0)
	{
punt:
		if (seenlocal &&
		    (!TryNullMXList || sm_gethostbyname(host) == NULL))
		{
			/*
			**  If we have deleted all MX entries, this is
			**  an error -- we should NEVER send to a host that
			**  has an MX, and this should have been caught
			**  earlier in the config file.
			**
			**  Some sites prefer to go ahead and try the
			**  A record anyway; that case is handled by
			**  setting TryNullMXList.  I believe this is a
			**  bad idea, but it's up to you....
			*/

			*rcode = EX_CONFIG;
			syserr("MX list for %s points back to %s",
				host, MyHostName);
			return -1;
		}
		if (strlen(host) >= (SIZE_T) sizeof MXHostBuf)
		{
			*rcode = EX_CONFIG;
			syserr("Host name %s too long",
			       shortenstring(host, MAXSHORTSTR));
			return -1;
		}
		snprintf(MXHostBuf, sizeof MXHostBuf, "%s", host);
		mxhosts[0] = MXHostBuf;
		if (host[0] == '[')
		{
			register char *p;

			/* this may be an MX suppression-style address */
			p = strchr(MXHostBuf, ']');
			if (p != NULL)
			{
				*p = '\0';
				if (inet_addr(&MXHostBuf[1]) != INADDR_NONE)
				{
					nmx++;
					*p = ']';
				}
				else
				{
					trycanon = TRUE;
					mxhosts[0]++;
				}
			}
		}
		if (trycanon &&
		    getcanonname(mxhosts[0], sizeof MXHostBuf - 2, FALSE))
		{
			bp = &MXHostBuf[strlen(MXHostBuf)];
			if (bp[-1] != '.')
			{
				*bp++ = '.';
				*bp = '\0';
			}
			nmx = 1;
		}
	}

	/* if we have a default lowest preference, include that */
	if (fallbackMX != NULL && !seenlocal)
		mxhosts[nmx++] = fallbackMX;

	return (nmx);
}
/*
**  MXRAND -- create a randomizer for equal MX preferences
**
**	If two MX hosts have equal preferences we want to randomize
**	the selection.  But in order for signatures to be the same,
**	we need to randomize the same way each time.  This function
**	computes a pseudo-random hash function from the host name.
**
**	Parameters:
**		host -- the name of the host.
**
**	Returns:
**		A random but repeatable value based on the host name.
**
**	Side Effects:
**		none.
*/

int
mxrand(host)
	register char *host;
{
	int hfunc;
	static unsigned int seed;

	if (seed == 0)
	{
		seed = (int) curtime() & 0xffff;
		if (seed == 0)
			seed++;
	}

	if (tTd(17, 9))
		printf("mxrand(%s)", host);

	hfunc = seed;
	while (*host != '\0')
	{
		int c = *host++;

		if (isascii(c) && isupper(c))
			c = tolower(c);
		hfunc = ((hfunc << 1) ^ c) % 2003;
	}

	hfunc &= 0xff;
	hfunc++;

	if (tTd(17, 9))
		printf(" = %d\n", hfunc);
	return hfunc;
}
/*
**  BESTMX -- find the best MX for a name
**
**	This is really a hack, but I don't see any obvious way
**	to generalize it at the moment.
*/

/* ARGSUSED3 */
char *
bestmx_map_lookup(map, name, av, statp)
	MAP *map;
	char *name;
	char **av;
	int *statp;
{
	int nmx;
	int saveopts = _res.options;
	int i, len = 0;
	char *p;
	char *mxhosts[MAXMXHOSTS + 1];
	char buf[PSBUFSIZE / 2];

	_res.options &= ~(RES_DNSRCH|RES_DEFNAMES);
	nmx = getmxrr(name, mxhosts, FALSE, statp);
	_res.options = saveopts;
	if (nmx <= 0)
		return NULL;
	if (bitset(MF_MATCHONLY, map->map_mflags))
		return map_rewrite(map, name, strlen(name), NULL);
	if ((map->map_coldelim == '\0') || (nmx == 1))
		return map_rewrite(map, mxhosts[0], strlen(mxhosts[0]), av);

	/*
	**  We were given a -z flag (return all MXs) and there are multiple
	**  ones.  We need to build them all into a list.
	*/
	p = buf;
	for (i = 0; i < nmx; i++)
	{
		int slen;
		
		if (strchr(mxhosts[i], map->map_coldelim) != NULL)
		{
			syserr("bestmx_map_lookup: MX host %.64s includes map delimiter character 0x%02X",
			       mxhosts[i], map->map_coldelim);
			return NULL;
		}
		slen = strlen(mxhosts[i]);
		if (len + slen + 2 > sizeof buf)
			break;
		if (i > 0)
		{
			*p++ = map->map_coldelim;
			len++;
		}
		strcpy(p, mxhosts[i]);
		p += slen;
		len += slen;
	}
	return map_rewrite(map, buf, len, av);
}
/*
**  DNS_GETCANONNAME -- get the canonical name for named host using DNS
**
**	This algorithm tries to be smart about wildcard MX records.
**	This is hard to do because DNS doesn't tell is if we matched
**	against a wildcard or a specific MX.
**	
**	We always prefer A & CNAME records, since these are presumed
**	to be specific.
**
**	If we match an MX in one pass and lose it in the next, we use
**	the old one.  For example, consider an MX matching *.FOO.BAR.COM.
**	A hostname bletch.foo.bar.com will match against this MX, but
**	will stop matching when we try bletch.bar.com -- so we know
**	that bletch.foo.bar.com must have been right.  This fails if
**	there was also an MX record matching *.BAR.COM, but there are
**	some things that just can't be fixed.
**
**	Parameters:
**		host -- a buffer containing the name of the host.
**			This is a value-result parameter.
**		hbsize -- the size of the host buffer.
**		trymx -- if set, try MX records as well as A and CNAME.
**		statp -- pointer to place to store status.
**
**	Returns:
**		TRUE -- if the host matched.
**		FALSE -- otherwise.
*/

bool
dns_getcanonname(host, hbsize, trymx, statp)
	char *host;
	int hbsize;
	bool trymx;
	int *statp;
{
	register u_char *eom, *ap;
	register char *cp;
	register int n; 
	HEADER *hp;
	querybuf answer;
	int ancount, qdcount;
	int ret;
	char **domain;
	int type;
	char **dp;
	char *mxmatch;
	bool amatch;
	bool gotmx = FALSE;
	int qtype;
	int loopcnt;
	char *xp;
	char nbuf[MAX(MAXPACKET, MAXDNAME*2+2)];
	char *searchlist[MAXDNSRCH+2];
	extern char *gethostalias __P((char *));

	if (tTd(8, 2))
		printf("dns_getcanonname(%s, trymx=%d)\n", host, trymx);

	if ((_res.options & RES_INIT) == 0 && res_init() == -1)
	{
		*statp = EX_UNAVAILABLE;
		return FALSE;
	}

	/*
	**  Initialize domain search list.  If there is at least one
	**  dot in the name, search the unmodified name first so we
	**  find "vse.CS" in Czechoslovakia instead of in the local
	**  domain (e.g., vse.CS.Berkeley.EDU).
	**
	**  Older versions of the resolver could create this
	**  list by tearing apart the host name.
	*/

	loopcnt = 0;
cnameloop:
	/* Check for dots in the name */
	for (cp = host, n = 0; *cp != '\0'; cp++)
		if (*cp == '.')
			n++;

	/*
	**  If this is a simple name, determine whether it matches an 
	**  alias in the file defined by the environment variable HOSTALIASES.
	*/
	if (n == 0 && (xp = gethostalias(host)) != NULL)
	{
		if (loopcnt++ > MAXCNAMEDEPTH)
		{
			syserr("loop in ${HOSTALIASES} file");
		}
		else
		{
			strncpy(host, xp, hbsize);
			host[hbsize - 1] = '\0';
			goto cnameloop;
		}
	}

	/*
	**  Build the search list.  
	**	If there is at least one dot in name, start with a null
	**	domain to search the unmodified name first.
	**	If name does not end with a dot and search up local domain
	**	tree desired, append each local domain component to the
	**	search list; if name contains no dots and default domain
	**	name is desired, append default domain name to search list;
	**	else if name ends in a dot, remove that dot.
	*/

	dp = searchlist;
	if (n > 0)
		*dp++ = "";
	if (n >= 0 && *--cp != '.' && bitset(RES_DNSRCH, _res.options))
	{
		for (domain = _res.dnsrch; *domain != NULL; )
			*dp++ = *domain++;
	}
	else if (n == 0 && bitset(RES_DEFNAMES, _res.options))
	{
		*dp++ = _res.defdname;
	}
	else if (*cp == '.')
	{
		*cp = '\0';
	}
	*dp = NULL;

	/*
	**  Now loop through the search list, appending each domain in turn
	**  name and searching for a match.
	*/

	mxmatch = NULL;
	qtype = T_ANY;

	for (dp = searchlist; *dp != NULL; )
	{
		if (qtype == T_ANY)
			gotmx = FALSE;
		if (tTd(8, 5))
			printf("dns_getcanonname: trying %s.%s (%s)\n",
				host, *dp,
				qtype == T_ANY ? "ANY" : qtype == T_A ? "A" :
				qtype == T_MX ? "MX" : "???");
		ret = res_querydomain(host, *dp, C_IN, qtype,
				      answer.qb2, sizeof(answer.qb2));
		if (ret <= 0)
		{
			if (tTd(8, 7))
				printf("\tNO: errno=%d, h_errno=%d\n",
					errno, h_errno);

			if (errno == ECONNREFUSED || h_errno == TRY_AGAIN)
			{
				/* the name server seems to be down */
				h_errno = TRY_AGAIN;
				*statp = EX_TEMPFAIL;
				return FALSE;
			}

			if (h_errno != HOST_NOT_FOUND)
			{
				/* might have another type of interest */
				if (qtype == T_ANY)
				{
					qtype = T_A;
					continue;
				}
				else if (qtype == T_A && !gotmx && (trymx || **dp == '\0'))
				{
					qtype = T_MX;
					continue;
				}
			}

			/* definite no -- try the next domain */
			dp++;
			qtype = T_ANY;
			continue;
		}
		else if (tTd(8, 7))
			printf("\tYES\n");

		/* avoid problems after truncation in tcp packets */
		if (ret > sizeof(answer))
			ret = sizeof(answer);

		/*
		**  Appear to have a match.  Confirm it by searching for A or
		**  CNAME records.  If we don't have a local domain
		**  wild card MX record, we will accept MX as well.
		*/

		hp = (HEADER *) &answer;
		ap = (u_char *) &answer + HFIXEDSZ;
		eom = (u_char *) &answer + ret;

		/* skip question part of response -- we know what we asked */
		for (qdcount = ntohs(hp->qdcount); qdcount--; ap += ret + QFIXEDSZ)
		{
			if ((ret = dn_skipname(ap, eom)) < 0)
			{
				if (tTd(8, 20))
					printf("qdcount failure (%d)\n",
						ntohs(hp->qdcount));
				*statp = EX_SOFTWARE;
				return FALSE;		/* ???XXX??? */
			}
		}

		amatch = FALSE;
		for (ancount = ntohs(hp->ancount); --ancount >= 0 && ap < eom;
									ap += n)
		{
			n = dn_expand((u_char *) &answer, eom, ap,
				      (RES_UNC_T) nbuf, sizeof nbuf);
			if (n < 0)
				break;
			ap += n;
			GETSHORT(type, ap);
			ap += INT16SZ + INT32SZ;
			GETSHORT(n, ap);
			switch (type)
			{
			  case T_MX:
				gotmx = TRUE;
				if (**dp != '\0' && HasWildcardMX)
				{
					/*
					**  If we are using MX matches and have
					**  not yet gotten one, save this one
					**  but keep searching for an A or 
					**  CNAME match.
					*/

					if (trymx && mxmatch == NULL)
						mxmatch = *dp;
					continue;
				}

				/*
				**  If we did not append a domain name, this
				**  must have been a canonical name to start
				**  with.  Even if we did append a domain name,
				**  in the absence of a wildcard MX this must
				**  still be a real MX match.
				**  Such MX matches are as good as an A match,
				**  fall through.
				*/

			  case T_A:
				/* Flag that a good match was found */
				amatch = TRUE;

				/* continue in case a CNAME also exists */
				continue;

			  case T_CNAME:
				if (DontExpandCnames)
				{
					/* got CNAME -- guaranteed canonical */
					amatch = TRUE;
					break;
				}

				if (loopcnt++ > MAXCNAMEDEPTH)
				{
					/*XXX should notify postmaster XXX*/
					message("DNS failure: CNAME loop for %s",
						host);
					if (CurEnv->e_message == NULL)
					{
						char ebuf[MAXLINE];

						snprintf(ebuf, sizeof ebuf,
							"Deferred: DNS failure: CNAME loop for %.100s",
							host);
						CurEnv->e_message = newstr(ebuf);
					}
					h_errno = NO_RECOVERY;
					*statp = EX_CONFIG;
					return FALSE;
				}

				/* value points at name */
				if ((ret = dn_expand((u_char *)&answer,
				    eom, ap, (RES_UNC_T) nbuf, sizeof(nbuf))) < 0)
					break;
				(void)strncpy(host, nbuf, hbsize); /* XXX */
				host[hbsize - 1] = '\0';

				/*
				**  RFC 1034 section 3.6 specifies that CNAME
				**  should point at the canonical name -- but
				**  urges software to try again anyway.
				*/

				goto cnameloop;

			  default:
				/* not a record of interest */
				continue;
			}
		}

		if (amatch)
		{
			/* 
			**  Got a good match -- either an A, CNAME, or an
			**  exact MX record.  Save it and get out of here.
			*/

			mxmatch = *dp;
			break;
		}

		/*
		**  Nothing definitive yet.
		**	If this was a T_ANY query, we don't really know what
		**		was returned -- it might have been a T_NS,
		**		for example.  Try T_A to be more specific
		**		during the next pass.
		**	If this was a T_A query and we haven't yet found a MX
		**		match, try T_MX if allowed to do so.
		**	Otherwise, try the next domain.
		*/

		if (qtype == T_ANY)
			qtype = T_A;
		else if (qtype == T_A && !gotmx && (trymx || **dp == '\0'))
			qtype = T_MX;
		else
		{
			qtype = T_ANY;
			dp++;
		}
	}

	/* if nothing was found, we are done */
	if (mxmatch == NULL)
	{
		*statp = EX_NOHOST;
		return FALSE;
	}

	/*
	**  Create canonical name and return.
	**  If saved domain name is null, name was already canonical.
	**  Otherwise append the saved domain name.
	*/

	(void) snprintf(nbuf, sizeof nbuf, "%.*s%s%.*s", MAXDNAME, host,
			*mxmatch == '\0' ? "" : ".",
			MAXDNAME, mxmatch);
	strncpy(host, nbuf, hbsize);
	host[hbsize - 1] = '\0';
	if (tTd(8, 5))
		printf("dns_getcanonname: %s\n", host);
	*statp = EX_OK;
	return TRUE;
}



char *
gethostalias(host)
	char *host;
{
	char *fname;
	FILE *fp;
	register char *p = NULL;
	int sff = SFF_REGONLY;
	char buf[MAXLINE];
	static char hbuf[MAXDNAME];

	if (DontLockReadFiles)
		sff |= SFF_NOLOCK;
	fname = getenv("HOSTALIASES");
	if (fname == NULL ||
	    (fp = safefopen(fname, O_RDONLY, 0, sff)) == NULL)
		return NULL;
	while (fgets(buf, sizeof buf, fp) != NULL)
	{
		for (p = buf; p != '\0' && !(isascii(*p) && isspace(*p)); p++)
			continue;
		if (*p == 0)
		{
			/* syntax error */
			continue;
		}
		*p++ = '\0';
		if (strcasecmp(buf, host) == 0)
			break;
	}

	if (feof(fp))
	{
		/* no match */
		fclose(fp);
		return NULL;
	}
	fclose(fp);

	/* got a match; extract the equivalent name */
	while (*p != '\0' && isascii(*p) && isspace(*p))
		p++;
	host = p;
	while (*p != '\0' && !(isascii(*p) && isspace(*p)))
		p++;
	*p = '\0';
	strncpy(hbuf, host, sizeof hbuf - 1);
	hbuf[sizeof hbuf - 1] = '\0';
	return hbuf;
}

#endif /* NAMED_BIND */
@


1.9
log
@sendmail 8.9.3
@
text
@@


1.8
log
@sendmail 8.9.2
@
text
@d17 1
a17 1
static char sccsid[] = "@@(#)domain.c	8.80 (Berkeley) 12/17/1998 (with name server)";
d19 1
a19 1
static char sccsid[] = "@@(#)domain.c	8.80 (Berkeley) 12/17/1998 (without name server)";
a448 1
	auto int rcode;
d456 1
a456 1
	nmx = getmxrr(name, mxhosts, FALSE, &rcode);
@


1.7
log
@something hosed the sendmail import; fix up by hand
@
text
@d17 1
a17 1
static char sccsid[] = "@@(#)domain.c	8.77 (Berkeley) 6/4/98 (with name server)";
d19 1
a19 1
static char sccsid[] = "@@(#)domain.c	8.77 (Berkeley) 6/4/98 (without name server)";
d454 1
a454 1
	char buf[MXHOSTBUFSIZE + 1];
d467 2
a468 2
	** We were given a -z flag (return all MXs) and there are multiple
	** ones.  We need to build them all into a list.
d666 1
a666 1
				else if (qtype == T_A && !gotmx && trymx)
d827 1
a827 1
		else if (qtype == T_A && !gotmx && trymx)
@


1.6
log
@sendmail 8.8.7.
@
text
@d2 2
a3 1
 * Copyright (c) 1986, 1995-1997 Eric P. Allman
d7 3
a9 15
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
a10 11
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
d17 1
a17 1
static char sccsid[] = "@@(#)domain.c	8.68 (Berkeley) 8/2/97 (with name server)";
d19 1
a19 1
static char sccsid[] = "@@(#)domain.c	8.68 (Berkeley) 8/2/97 (without name server)";
d335 2
a336 1
			syserr("Host name %s too long", shortenstring(host, 203));
d440 1
d451 2
d454 1
d463 1
a463 1
	else
d465 29
d550 1
a550 1
	extern char *gethostalias();
@


1.5
log
@Sendmail 8.8.6.
@
text
@d39 1
a39 1
static char sccsid[] = "@@(#)domain.c	8.67 (Berkeley) 4/9/97 (with name server)";
d41 1
a41 1
static char sccsid[] = "@@(#)domain.c	8.67 (Berkeley) 4/9/97 (without name server)";
d857 1
d861 2
d865 1
a865 1
	    (fp = safefopen(fname, O_RDONLY, 0, SFF_REGONLY)) == NULL)
@


1.4
log
@Update to Sendmail 8.8.4, plus recent patches, plus OpenBSD support.
Also include entire example configuration subset.
Includes smrsh (using /usr/libexec/sm.bin).

Of the top of my head, the only things I removed from the distribution were
contrib/mail.local.linux, src/Makefiles, all the *.0 and *.ps files.
Our praliases man page replaces the distributed one, ours is better.
@
text
@d2 1
a2 1
 * Copyright (c) 1986, 1995, 1996 Eric P. Allman
d39 1
a39 1
static char sccsid[] = "@@(#)domain.c	8.64 (Berkeley) 10/30/96 (with name server)";
d41 1
a41 1
static char sccsid[] = "@@(#)domain.c	8.64 (Berkeley) 10/30/96 (without name server)";
d200 1
d884 1
@


1.3
log
@bring up to 8.7.6
@
text
@d2 1
a2 1
 * Copyright (c) 1986, 1995 Eric P. Allman
d39 1
a39 1
static char sccsid[] = "@@(#)domain.c	8.54.1.2 (Berkeley) 9/16/96 (with name server)";
d41 1
a41 1
static char sccsid[] = "@@(#)domain.c	8.54.1.2 (Berkeley) 9/16/96 (without name server)";
d49 14
d67 1
a67 1
	u_char	qb2[PACKETSZ];
d70 5
a74 1
static char	MXHostBuf[MAXMXHOSTS*PACKETSZ];
d77 1
a77 1
#define MAXDNSRCH	6	/* number of possible domains to search */
d81 1
a81 1
#define MAX(a, b)	((a) > (b) ? (a) : (b))
a134 1
	static bool firsttime = TRUE;
d140 1
a140 1
	extern bool getcanonname();
d145 2
a146 1
	if (fallbackMX != NULL)
d148 2
a149 13
		if (firsttime &&
		    res_query(FallBackMX, C_IN, T_A,
			      (u_char *) &answer, sizeof answer) < 0)
		{
			/* this entry is bogus */
			fallbackMX = FallBackMX = NULL;
		}
		else if (droplocalhost && wordinclass(fallbackMX, 'w'))
		{
			/* don't use fallback for this pass */
			fallbackMX = NULL;
		}
		firsttime = FALSE;
d222 4
a363 1
			struct in_addr junk;
d370 3
a372 1
				if (inet_aton(&MXHostBuf[1], &junk) != 0)
d374 1
d535 1
a535 1
	char nbuf[MAX(PACKETSZ, MAXDNAME*2+2)];
d667 4
@


1.2
log
@Sendmail 8.7.3 from NetBSD
@
text
@d39 1
a39 1
static char sccsid[] = "@@(#)domain.c	8.54 (Berkeley) 9/28/95 (with name server)";
d41 1
a41 1
static char sccsid[] = "@@(#)domain.c	8.54 (Berkeley) 9/28/95 (without name server)";
d342 7
a348 1
		strcpy(MXHostBuf, host);
d742 2
a743 1
						sprintf(ebuf, "Deferred: DNS failure: CNAME loop for %.100s",
d819 1
a819 1
	(void) sprintf(nbuf, "%.*s%s%.*s", MAXDNAME, host,
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
 * Copyright (c) 1986 Eric P. Allman
d39 1
a39 1
static char sccsid[] = "@@(#)domain.c	8.19.1.1 (Berkeley) 3/6/95 (with name server)";
d41 1
a41 1
static char sccsid[] = "@@(#)domain.c	8.19.1.1 (Berkeley) 3/6/95 (without name server)";
a47 1
#include <arpa/nameser.h>
a48 1
#include <netdb.h>
d53 1
a53 1
	char	qb2[PACKETSZ];
d70 2
a71 2
#ifndef HEADERSZ
# define HEADERSZ	sizeof(HEADER)
d74 1
a74 3
/* don't use sizeof because sizeof(long) is different on 64-bit machines */
#define SHORTSIZE	2	/* size of a short (really, must be 2) */
#define LONGSIZE	4	/* size of a long (really, must be 4) */
d76 5
a80 1
#define MAXCNAMEDEPTH	10	/* maximum depth of CNAME recursion */
d99 1
a105 1
	extern int h_errno;
d114 2
a115 1
	u_short pref, localpref, type;
a117 1
	STAB *st;
d119 2
d130 3
a132 2
		if (firsttime && res_query(FallBackMX, C_IN, T_A,
					   (char *) &answer, sizeof answer) < 0)
d137 1
a137 3
		else if (droplocalhost &&
			 (st = stab(fallbackMX, ST_CLASS, ST_FIND)) != NULL &&
			 bitnset('w', st->s_class))
d145 2
d151 15
d167 1
a167 1
	n = res_search(host, C_IN, T_MX, (char *)&answer, sizeof(answer));
d184 2
a185 3
#ifdef BROKEN_RES_SEARCH
			/* Ultrix resolver returns failure w/ h_errno=0 */
		  case 0:
d187 2
a188 1
			/* the host just doesn't exist */
d190 1
d192 3
a194 1
			if (!UseNameServer)
d196 3
a198 2
				/* might exist in /etc/hosts */
				goto punt;
a199 7
			break;

		  case TRY_AGAIN:
			/* couldn't connect to the name server */
			if (!UseNameServer && errno == ECONNREFUSED)
				goto punt;

d217 1
a217 1
	cp = (u_char *)&answer + HEADERSZ;
d228 1
a228 1
		    eom, cp, (u_char *)bp, buflen)) < 0)
d232 1
a232 1
 		cp += SHORTSIZE + LONGSIZE;
d244 1
a244 1
				   (u_char *)bp, buflen)) < 0)
d247 1
a247 3
		if (droplocalhost &&
		    (st = stab(bp, ST_CLASS, ST_FIND)) != NULL &&
		    bitnset('w', st->s_class))
d252 8
a259 4
			if (!seenlocal || pref < localpref)
				localpref = pref;
			seenlocal = TRUE;
			continue;
d261 2
a262 1
		weight[nmx] = mxrand(bp);
d305 14
d323 1
a323 1
		    (!TryNullMXList || gethostbyname(host) == NULL))
d372 1
a373 1
		nmx = 1;
d400 1
d428 1
d435 30
a464 1
**  GETCANONNAME -- get the canonical name for named host
d486 1
d494 1
a494 1
getcanonname(host, hbsize, trymx)
d498 1
a499 1
	extern int h_errno;
d512 1
a512 1
	bool gotmx;
d521 1
a521 1
		printf("getcanonname(%s)\n", host);
d524 4
a527 1
		return (FALSE);
d541 2
a542 1
	for (cp = host, n = 0; *cp; cp++)
d546 4
d564 11
d594 2
a595 1
	**  Now run through the search list for the name in question.
d606 2
a607 1
			printf("getcanonname: trying %s.%s (%s)\n", host, *dp,
d611 1
a611 1
				      &answer, sizeof(answer));
d622 1
d641 1
a641 7
			if (mxmatch != NULL)
			{
				/* we matched before -- use that one */
				break;
			}

			/* otherwise, try the next name */
d650 2
a651 2
		**  This might be a bogus match.  Search for A or
		**  CNAME records.  If we don't have a matching
d656 1
a656 1
		ap = (u_char *) &answer + HEADERSZ;
d667 1
d673 2
a674 1
		for (ancount = ntohs(hp->ancount); --ancount >= 0 && ap < eom; ap += n)
d677 1
a677 1
				      (u_char *) nbuf, sizeof nbuf);
d682 1
a682 1
			ap += SHORTSIZE + LONGSIZE;
d688 1
a688 1
				if (**dp != '\0')
d690 7
a696 1
					/* got a match -- save that info */
d702 9
a710 2
				/* exact MX matches are as good as an A match */
				/* fall through */
d713 1
a713 1
				/* good show */
d720 7
d736 1
a736 1
						sprintf(ebuf, "Deferred: DNS failure: CNAME loop for %s",
d741 1
d747 1
a747 1
				    eom, ap, (u_char *)nbuf, sizeof(nbuf))) < 0)
d768 5
a772 1
			/* got an A record and no CNAME */
d778 8
a785 2
		**  If this was a T_ANY query, we may have the info but
		**  need an explicit query.  Try T_A, then T_MX.
a793 1
			/* really nothing in this domain; try the next */
d799 1
d801 2
d804 7
a811 1
	/* create matching name and return */
d817 3
d824 1
d831 1
a831 1
	register char *p;
d836 2
a837 1
	if (fname == NULL || (fp = fopen(fname, "r")) == NULL)
a838 1
	setbuf(fp, NULL);
d872 1
a872 25

#else /* not NAMED_BIND */

#include <netdb.h>

bool
getcanonname(host, hbsize, trymx)
	char *host;
	int hbsize;
	bool trymx;
{
	struct hostent *hp;

	hp = gethostbyname(host);
	if (hp == NULL)
		return (FALSE);

	if (strlen(hp->h_name) >= hbsize)
		return (FALSE);

	(void) strcpy(host, hp->h_name);
	return (TRUE);
}

#endif /* not NAMED_BIND */
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@


1.1.1.2
log
@sendmail 8.9.1
@
text
@d2 1
a2 2
 * Copyright (c) 1998 Sendmail, Inc.  All rights reserved.
 * Copyright (c) 1986, 1995-1997 Eric P. Allman.  All rights reserved.
d6 15
a20 3
 * By using this file, you agree to the terms and conditions set
 * forth in the LICENSE file which can be found at the top level of
 * the sendmail distribution.
d22 11
d39 1
a39 1
static char sccsid[] = "@@(#)domain.c	8.77 (Berkeley) 6/4/98 (with name server)";
d41 1
a41 1
static char sccsid[] = "@@(#)domain.c	8.77 (Berkeley) 6/4/98 (without name server)";
d48 1
d50 1
a50 14
#include <arpa/inet.h>

/*
**  The standard udp packet size PACKETSZ (512) is not sufficient for some
**  nameserver answers containing very many resource records. The resolver
**  may switch to tcp and retry if it detects udp packet overflow.
**  Also note that the resolver routines res_query and res_search return
**  the size of the *un*truncated answer in case the supplied answer buffer
**  it not big enough to accommodate the entire answer.
*/

#ifndef MAXPACKET
# define MAXPACKET 8192		/* max packet size used internally by BIND */
#endif
d55 1
a55 1
	u_char	qb2[MAXPACKET];
d58 1
a58 5
#ifndef MXHOSTBUFSIZE
# define MXHOSTBUFSIZE	(128 * MAXMXHOSTS)
#endif

static char	MXHostBuf[MXHOSTBUFSIZE];
d61 1
a61 1
# define MAXDNSRCH	6	/* number of possible domains to search */
d65 1
a65 1
# define MAX(a, b)	((a) > (b) ? (a) : (b))
d72 2
a73 2
#ifndef HFIXEDSZ
# define HFIXEDSZ	12	/* sizeof(HEADER) */
d76 4
a80 6

#if defined(__RES) && (__RES >= 19940415)
# define RES_UNC_T	char *
#else
# define RES_UNC_T	u_char *
#endif
a98 1
int
d105 1
d114 1
a114 2
	u_short pref, type;
	u_short localpref = 256;
d116 2
a118 2
	int (*resfunc)();
	extern int res_query(), res_search();
d121 1
a121 1
	extern int mxrand __P((char *));
d126 1
a126 2
	if (fallbackMX != NULL && droplocalhost &&
	    wordinclass(fallbackMX, 'w'))
d128 14
a141 2
		/* don't use fallback for this pass */
		fallbackMX = NULL;
a143 2
	*rcode = EX_OK;

a147 15
	/*
	**  If we don't have MX records in our host switch, don't
	**  try for MX records.  Note that this really isn't "right",
	**  since we might be set up to try NIS first and then DNS;
	**  if the host is found in NIS we really shouldn't be doing
	**  MX lookups.  However, that should be a degenerate case.
	*/

	if (!UseNameServer)
		goto punt;
	if (HasWildcardMX && ConfigLevel >= 6)
		resfunc = res_query;
	else
		resfunc = res_search;

d149 1
a149 1
	n = (*resfunc)(host, C_IN, T_MX, (u_char *) &answer, sizeof(answer));
d166 3
a168 2
#if BROKEN_RES_SEARCH
		  case 0:	/* Ultrix resolver retns failure w/ h_errno=0 */
d170 1
a170 2
			/* host doesn't exist in DNS; might be in /etc/hosts */
			trycanon = TRUE;
d172 7
a178 1
			goto punt;
a180 1
		  case -1:
d182 3
a184 6
			if (fallbackMX != NULL)
			{
				/* name server is hosed -- push to fallback */
				mxhosts[nmx++] = fallbackMX;
				return nmx;
			}
a199 4
	/* avoid problems after truncation in tcp packets */
	if (n > sizeof(answer))
		n = sizeof(answer);

d202 1
a202 1
	cp = (u_char *)&answer + HFIXEDSZ;
d213 1
a213 1
		    eom, cp, (RES_UNC_T) bp, buflen)) < 0)
d217 1
a217 1
 		cp += INT16SZ + INT32SZ;
d229 1
a229 1
				   (RES_UNC_T) bp, buflen)) < 0)
d232 3
a234 1
		if (wordinclass(bp, 'w'))
d239 4
a242 8
			if (droplocalhost)
			{
				if (!seenlocal || pref < localpref)
					localpref = pref;
				seenlocal = TRUE;
				continue;
			}
			weight[nmx] = 0;
d244 1
a244 2
		else
			weight[nmx] = mxrand(bp);
a286 14
	/* delete duplicates from list (yes, some bozos have duplicates) */
	for (i = 0; i < nmx - 1; )
	{
		if (strcasecmp(mxhosts[i], mxhosts[i + 1]) != 0)
			i++;
		else
		{
			/* compress out duplicate */
			for (j = i + 1; j < nmx; j++)
				mxhosts[j] = mxhosts[j + 1];
			nmx--;
		}
	}

d291 1
a291 1
		    (!TryNullMXList || sm_gethostbyname(host) == NULL))
d310 1
a310 8
		if (strlen(host) >= (SIZE_T) sizeof MXHostBuf)
		{
			*rcode = EX_CONFIG;
			syserr("Host name %s too long",
			       shortenstring(host, MAXSHORTSTR));
			return -1;
		}
		snprintf(MXHostBuf, sizeof MXHostBuf, "%s", host);
d315 1
d322 1
a322 3
				if (inet_addr(&MXHostBuf[1]) != INADDR_NONE)
				{
					nmx++;
a323 1
				}
a339 1
			nmx = 1;
d341 1
a367 1
int
a394 1
	hfunc++;
d401 1
a401 63
**  BESTMX -- find the best MX for a name
**
**	This is really a hack, but I don't see any obvious way
**	to generalize it at the moment.
*/

/* ARGSUSED3 */
char *
bestmx_map_lookup(map, name, av, statp)
	MAP *map;
	char *name;
	char **av;
	int *statp;
{
	int nmx;
	auto int rcode;
	int saveopts = _res.options;
	int i, len = 0;
	char *p;
	char *mxhosts[MAXMXHOSTS + 1];
	char buf[MXHOSTBUFSIZE + 1];

	_res.options &= ~(RES_DNSRCH|RES_DEFNAMES);
	nmx = getmxrr(name, mxhosts, FALSE, &rcode);
	_res.options = saveopts;
	if (nmx <= 0)
		return NULL;
	if (bitset(MF_MATCHONLY, map->map_mflags))
		return map_rewrite(map, name, strlen(name), NULL);
	if ((map->map_coldelim == '\0') || (nmx == 1))
		return map_rewrite(map, mxhosts[0], strlen(mxhosts[0]), av);

	/*
	** We were given a -z flag (return all MXs) and there are multiple
	** ones.  We need to build them all into a list.
	*/
	p = buf;
	for (i = 0; i < nmx; i++)
	{
		int slen;
		
		if (strchr(mxhosts[i], map->map_coldelim) != NULL)
		{
			syserr("bestmx_map_lookup: MX host %.64s includes map delimiter character 0x%02X",
			       mxhosts[i], map->map_coldelim);
			return NULL;
		}
		slen = strlen(mxhosts[i]);
		if (len + slen + 2 > sizeof buf)
			break;
		if (i > 0)
		{
			*p++ = map->map_coldelim;
			len++;
		}
		strcpy(p, mxhosts[i]);
		p += slen;
		len += slen;
	}
	return map_rewrite(map, buf, len, av);
}
/*
**  DNS_GETCANONNAME -- get the canonical name for named host using DNS
a422 1
**		statp -- pointer to place to store status.
d430 1
a430 1
dns_getcanonname(host, hbsize, trymx, statp)
a433 1
	int *statp;
d435 1
d448 1
a448 1
	bool gotmx = FALSE;
d452 1
a452 1
	char nbuf[MAX(MAXPACKET, MAXDNAME*2+2)];
d454 1
a454 1
	extern char *gethostalias __P((char *));
d457 1
a457 1
		printf("dns_getcanonname(%s, trymx=%d)\n", host, trymx);
d460 1
a460 4
	{
		*statp = EX_UNAVAILABLE;
		return FALSE;
	}
d474 1
a474 2
	/* Check for dots in the name */
	for (cp = host, n = 0; *cp != '\0'; cp++)
a477 4
	/*
	**  If this is a simple name, determine whether it matches an 
	**  alias in the file defined by the environment variable HOSTALIASES.
	*/
a491 11
	/*
	**  Build the search list.  
	**	If there is at least one dot in name, start with a null
	**	domain to search the unmodified name first.
	**	If name does not end with a dot and search up local domain
	**	tree desired, append each local domain component to the
	**	search list; if name contains no dots and default domain
	**	name is desired, append default domain name to search list;
	**	else if name ends in a dot, remove that dot.
	*/

d511 1
a511 2
	**  Now loop through the search list, appending each domain in turn
	**  name and searching for a match.
d522 1
a522 2
			printf("dns_getcanonname: trying %s.%s (%s)\n",
				host, *dp,
d526 1
a526 1
				      answer.qb2, sizeof(answer.qb2));
a536 1
				*statp = EX_TEMPFAIL;
d555 7
a561 1
			/* definite no -- try the next domain */
a568 4
		/* avoid problems after truncation in tcp packets */
		if (ret > sizeof(answer))
			ret = sizeof(answer);

d570 2
a571 2
		**  Appear to have a match.  Confirm it by searching for A or
		**  CNAME records.  If we don't have a local domain
d576 1
a576 1
		ap = (u_char *) &answer + HFIXEDSZ;
a586 1
				*statp = EX_SOFTWARE;
d592 1
a592 2
		for (ancount = ntohs(hp->ancount); --ancount >= 0 && ap < eom;
									ap += n)
d595 1
a595 1
				      (RES_UNC_T) nbuf, sizeof nbuf);
d600 1
a600 1
			ap += INT16SZ + INT32SZ;
d606 1
a606 1
				if (**dp != '\0' && HasWildcardMX)
d608 1
a608 7
					/*
					**  If we are using MX matches and have
					**  not yet gotten one, save this one
					**  but keep searching for an A or 
					**  CNAME match.
					*/

d614 2
a615 9
				/*
				**  If we did not append a domain name, this
				**  must have been a canonical name to start
				**  with.  Even if we did append a domain name,
				**  in the absence of a wildcard MX this must
				**  still be a real MX match.
				**  Such MX matches are as good as an A match,
				**  fall through.
				*/
d618 1
a618 1
				/* Flag that a good match was found */
a624 7
				if (DontExpandCnames)
				{
					/* got CNAME -- guaranteed canonical */
					amatch = TRUE;
					break;
				}

d634 1
a634 2
						snprintf(ebuf, sizeof ebuf,
							"Deferred: DNS failure: CNAME loop for %.100s",
a638 1
					*statp = EX_CONFIG;
d644 1
a644 1
				    eom, ap, (RES_UNC_T) nbuf, sizeof(nbuf))) < 0)
d665 1
a665 5
			/* 
			**  Got a good match -- either an A, CNAME, or an
			**  exact MX record.  Save it and get out of here.
			*/

d671 2
a672 8
		**  Nothing definitive yet.
		**	If this was a T_ANY query, we don't really know what
		**		was returned -- it might have been a T_NS,
		**		for example.  Try T_A to be more specific
		**		during the next pass.
		**	If this was a T_A query and we haven't yet found a MX
		**		match, try T_MX if allowed to do so.
		**	Otherwise, try the next domain.
d681 1
a686 1
	/* if nothing was found, we are done */
a687 2
	{
		*statp = EX_NOHOST;
a688 7
	}

	/*
	**  Create canonical name and return.
	**  If saved domain name is null, name was already canonical.
	**  Otherwise append the saved domain name.
	*/
d690 2
a691 1
	(void) snprintf(nbuf, sizeof nbuf, "%.*s%s%.*s", MAXDNAME, host,
a695 3
	if (tTd(8, 5))
		printf("dns_getcanonname: %s\n", host);
	*statp = EX_OK;
a699 1

d706 1
a706 2
	register char *p = NULL;
	int sff = SFF_REGONLY;
a709 2
	if (DontLockReadFiles)
		sff |= SFF_NOLOCK;
d711 1
a711 2
	if (fname == NULL ||
	    (fp = safefopen(fname, O_RDONLY, 0, sff)) == NULL)
d713 1
a733 1
	fclose(fp);
d747 25
a771 1
#endif /* NAMED_BIND */
@

