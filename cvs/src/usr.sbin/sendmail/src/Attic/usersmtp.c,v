head	1.11;
access;
symbols
	OPENBSD_2_6:1.10.0.4
	OPENBSD_2_6_BASE:1.10
	OPENBSD_2_5:1.10.0.2
	OPENBSD_2_5_BASE:1.10
	OPENBSD_2_4:1.8.0.2
	OPENBSD_2_4_BASE:1.8
	sendmail_8_9_1:1.1.1.2
	UCB:1.1.1
	OPENBSD_2_3:1.7.0.2
	OPENBSD_2_3_BASE:1.7
	OPENBSD_2_2:1.6.0.2
	OPENBSD_2_2_BASE:1.6
	OPENBSD_2_1:1.5.0.2
	OPENBSD_2_1_BASE:1.5
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.11
date	2000.04.18.04.57.28;	author millert;	state dead;
branches;
next	1.10;

1.10
date	99.02.05.05.59.36;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	99.01.01.20.34.05;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	98.07.12.19.45.27;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	97.11.09.04.05.46;	author gene;	state Exp;
branches;
next	1.6;

1.6
date	97.07.15.07.24.19;	author downsj;	state Exp;
branches;
next	1.5;

1.5
date	97.01.22.01.07.26;	author downsj;	state Exp;
branches;
next	1.4;

1.4
date	96.12.14.21.17.47;	author downsj;	state Exp;
branches;
next	1.3;

1.3
date	96.09.19.06.45.06;	author fn;	state Exp;
branches;
next	1.2;

1.2
date	96.01.29.01.44.51;	author dm;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.48.20;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.48.20;	author deraadt;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	98.07.12.17.10.51;	author millert;	state Exp;
branches;
next	;


desc
@@


1.11
log
@remove sendmail 8.9.3
@
text
@/*
 * Copyright (c) 1998 Sendmail, Inc.  All rights reserved.
 * Copyright (c) 1983, 1995-1997 Eric P. Allman.  All rights reserved.
 * Copyright (c) 1988, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * By using this file, you agree to the terms and conditions set
 * forth in the LICENSE file which can be found at the top level of
 * the sendmail distribution.
 *
 */

# include "sendmail.h"

#ifndef lint
#if SMTP
static char sccsid[] = "@@(#)usersmtp.c	8.111 (Berkeley) 2/3/1999 (with SMTP)";
#else
static char sccsid[] = "@@(#)usersmtp.c	8.111 (Berkeley) 2/3/1999 (without SMTP)";
#endif
#endif /* not lint */

# include <sysexits.h>
# include <errno.h>

# if SMTP

/*
**  USERSMTP -- run SMTP protocol from the user end.
**
**	This protocol is described in RFC821.
*/

#define REPLYTYPE(r)	((r) / 100)		/* first digit of reply code */
#define REPLYCLASS(r)	(((r) / 10) % 10)	/* second digit of reply code */
#define SMTPCLOSING	421			/* "Service Shutting Down" */

char	SmtpMsgBuffer[MAXLINE];		/* buffer for commands */
char	SmtpReplyBuffer[MAXLINE];	/* buffer for replies */
char	SmtpError[MAXLINE] = "";	/* save failure error messages */
bool	SmtpNeedIntro;			/* need "while talking" in transcript */

extern void	smtpmessage __P((char *f, MAILER *m, MCI *mci, ...));
extern int	reply __P((MAILER *, MCI *, ENVELOPE *, time_t, void (*)()));
/*
**  SMTPINIT -- initialize SMTP.
**
**	Opens the connection and sends the initial protocol.
**
**	Parameters:
**		m -- mailer to create connection to.
**		pvp -- pointer to parameter vector to pass to
**			the mailer.
**
**	Returns:
**		none.
**
**	Side Effects:
**		creates connection and sends initial protocol.
*/

void
smtpinit(m, mci, e)
	MAILER *m;
	register MCI *mci;
	ENVELOPE *e;
{
	register int r;
	register char *p;
	extern void esmtp_check __P((char *, bool, MAILER *, MCI *, ENVELOPE *));
	extern void helo_options __P((char *, bool, MAILER *, MCI *, ENVELOPE *));

	if (tTd(18, 1))
	{
		printf("smtpinit ");
		mci_dump(mci, FALSE);
	}

	/*
	**  Open the connection to the mailer.
	*/

	SmtpError[0] = '\0';
	CurHostName = mci->mci_host;		/* XXX UGLY XXX */
	if (CurHostName == NULL)
		CurHostName = MyHostName;
	SmtpNeedIntro = TRUE;
	switch (mci->mci_state)
	{
	  case MCIS_ACTIVE:
		/* need to clear old information */
		smtprset(m, mci, e);
		/* fall through */

	  case MCIS_OPEN:
		return;

	  case MCIS_ERROR:
	  case MCIS_SSD:
		/* shouldn't happen */
		smtpquit(m, mci, e);
		/* fall through */

	  case MCIS_CLOSED:
		syserr("451 smtpinit: state CLOSED");
		return;

	  case MCIS_OPENING:
		break;
	}

	mci->mci_state = MCIS_OPENING;

	/*
	**  Get the greeting message.
	**	This should appear spontaneously.  Give it five minutes to
	**	happen.
	*/

	SmtpPhase = mci->mci_phase = "client greeting";
	sm_setproctitle(TRUE, "%s %s: %s", e->e_id, CurHostName, mci->mci_phase);
	r = reply(m, mci, e, TimeOuts.to_initial, esmtp_check);
	if (r < 0)
		goto tempfail1;
	if (REPLYTYPE(r) == 4)
		goto tempfail2;
	if (REPLYTYPE(r) != 2)
		goto unavailable;

	/*
	**  Send the HELO command.
	**	My mother taught me to always introduce myself.
	*/

	if (bitnset(M_ESMTP, m->m_flags) || bitnset(M_LMTP, m->m_flags))
		mci->mci_flags |= MCIF_ESMTP;

tryhelo:
	if (bitnset(M_LMTP, m->m_flags))
	{
		smtpmessage("LHLO %s", m, mci, MyHostName);
		SmtpPhase = mci->mci_phase = "client LHLO";
	}
	else if (bitset(MCIF_ESMTP, mci->mci_flags))
	{
		smtpmessage("EHLO %s", m, mci, MyHostName);
		SmtpPhase = mci->mci_phase = "client EHLO";
	}
	else
	{
		smtpmessage("HELO %s", m, mci, MyHostName);
		SmtpPhase = mci->mci_phase = "client HELO";
	}
	sm_setproctitle(TRUE, "%s %s: %s", e->e_id, CurHostName, mci->mci_phase);
	r = reply(m, mci, e, TimeOuts.to_helo, helo_options);
	if (r < 0)
		goto tempfail1;
	else if (REPLYTYPE(r) == 5)
	{
		if (bitset(MCIF_ESMTP, mci->mci_flags) &&
		    !bitnset(M_LMTP, m->m_flags))
		{
			/* try old SMTP instead */
			mci->mci_flags &= ~MCIF_ESMTP;
			goto tryhelo;
		}
		goto unavailable;
	}
	else if (REPLYTYPE(r) != 2)
		goto tempfail2;

	/*
	**  Check to see if we actually ended up talking to ourself.
	**  This means we didn't know about an alias or MX, or we managed
	**  to connect to an echo server.
	*/

	p = strchr(&SmtpReplyBuffer[4], ' ');
	if (p != NULL)
		*p = '\0';
	if (!bitnset(M_NOLOOPCHECK, m->m_flags) &&
	    !bitnset(M_LMTP, m->m_flags) &&
	    strcasecmp(&SmtpReplyBuffer[4], MyHostName) == 0)
	{
		syserr("553 %s config error: mail loops back to me (MX problem?)",
			CurHostName);
		mci_setstat(mci, EX_CONFIG, NULL, NULL);
		mci->mci_errno = 0;
		smtpquit(m, mci, e);
		return;
	}

	/*
	**  If this is expected to be another sendmail, send some internal
	**  commands.
	*/

	if (bitnset(M_INTERNAL, m->m_flags))
	{
		/* tell it to be verbose */
		smtpmessage("VERB", m, mci);
		r = reply(m, mci, e, TimeOuts.to_miscshort, NULL);
		if (r < 0)
			goto tempfail1;
	}

	if (mci->mci_state != MCIS_CLOSED)
	{
		mci->mci_state = MCIS_OPEN;
		return;
	}

	/* got a 421 error code during startup */

  tempfail1:
	if (mci->mci_errno == 0)
		mci->mci_errno = errno;
	mci_setstat(mci, EX_TEMPFAIL, "4.4.2", NULL);
	if (mci->mci_state != MCIS_CLOSED)
		smtpquit(m, mci, e);
	return;

  tempfail2:
	if (mci->mci_errno == 0)
		mci->mci_errno = errno;
	/* XXX should use code from other end iff ENHANCEDSTATUSCODES */
	mci_setstat(mci, EX_TEMPFAIL, "4.5.0", SmtpReplyBuffer);
	if (mci->mci_state != MCIS_CLOSED)
		smtpquit(m, mci, e);
	return;

  unavailable:
	mci->mci_errno = errno;
	mci_setstat(mci, EX_UNAVAILABLE, "5.5.0", SmtpReplyBuffer);
	smtpquit(m, mci, e);
	return;
}
/*
**  ESMTP_CHECK -- check to see if this implementation likes ESMTP protocol
**
**	Parameters:
**		line -- the response line.
**		firstline -- set if this is the first line of the reply.
**		m -- the mailer.
**		mci -- the mailer connection info.
**		e -- the envelope.
**
**	Returns:
**		none.
*/

void
esmtp_check(line, firstline, m, mci, e)
	char *line;
	bool firstline;
	MAILER *m;
	register MCI *mci;
	ENVELOPE *e;
{
	if (strstr(line, "ESMTP") != NULL)
		mci->mci_flags |= MCIF_ESMTP;
	if (strstr(line, "8BIT-OK") != NULL)
		mci->mci_flags |= MCIF_8BITOK;
}
/*
**  HELO_OPTIONS -- process the options on a HELO line.
**
**	Parameters:
**		line -- the response line.
**		firstline -- set if this is the first line of the reply.
**		m -- the mailer.
**		mci -- the mailer connection info.
**		e -- the envelope.
**
**	Returns:
**		none.
*/

void
helo_options(line, firstline, m, mci, e)
	char *line;
	bool firstline;
	MAILER *m;
	register MCI *mci;
	ENVELOPE *e;
{
	register char *p;

	if (firstline)
		return;

	if (strlen(line) < (SIZE_T) 5)
		return;
	line += 4;
	p = strchr(line, ' ');
	if (p != NULL)
		*p++ = '\0';
	if (strcasecmp(line, "size") == 0)
	{
		mci->mci_flags |= MCIF_SIZE;
		if (p != NULL)
			mci->mci_maxsize = atol(p);
	}
	else if (strcasecmp(line, "8bitmime") == 0)
	{
		mci->mci_flags |= MCIF_8BITMIME;
		mci->mci_flags &= ~MCIF_7BIT;
	}
	else if (strcasecmp(line, "expn") == 0)
		mci->mci_flags |= MCIF_EXPN;
	else if (strcasecmp(line, "dsn") == 0)
		mci->mci_flags |= MCIF_DSN;
}
/*
**  SMTPMAILFROM -- send MAIL command
**
**	Parameters:
**		m -- the mailer.
**		mci -- the mailer connection structure.
**		e -- the envelope (including the sender to specify).
*/

int
smtpmailfrom(m, mci, e)
	MAILER *m;
	MCI *mci;
	ENVELOPE *e;
{
	int r;
	char *bufp;
	char *bodytype;
	char buf[MAXNAME + 1];
	char optbuf[MAXLINE];

	if (tTd(18, 2))
		printf("smtpmailfrom: CurHost=%s\n", CurHostName);

	/* set up appropriate options to include */
	bufp = optbuf;
	if (bitset(MCIF_SIZE, mci->mci_flags) && e->e_msgsize > 0)
		snprintf(optbuf, sizeof optbuf, " SIZE=%ld", e->e_msgsize);
	else
		strcpy(optbuf, "");
	bufp = &optbuf[strlen(optbuf)];

	bodytype = e->e_bodytype;
	if (bitset(MCIF_8BITMIME, mci->mci_flags))
	{
		if (bodytype == NULL &&
		    bitset(MM_MIME8BIT, MimeMode) &&
		    bitset(EF_HAS8BIT, e->e_flags) &&
		    !bitset(EF_DONT_MIME, e->e_flags) &&
		    !bitnset(M_8BITS, m->m_flags))
			bodytype = "8BITMIME";
		if (bodytype != NULL &&
		    SPACELEFT(optbuf, bufp) > strlen(bodytype) + 7)
		{
			snprintf(bufp, SPACELEFT(optbuf, bufp),
				 " BODY=%s", bodytype);
			bufp += strlen(bufp);
		}
	}
	else if (bitnset(M_8BITS, m->m_flags) ||
		 !bitset(EF_HAS8BIT, e->e_flags) ||
		 bitset(MCIF_8BITOK, mci->mci_flags))
	{
		/* just pass it through */
	}
#if MIME8TO7
	else if (bitset(MM_CVTMIME, MimeMode) &&
		 !bitset(EF_DONT_MIME, e->e_flags) &&
		 (!bitset(MM_PASS8BIT, MimeMode) ||
		  bitset(EF_IS_MIME, e->e_flags)))
	{
		/* must convert from 8bit MIME format to 7bit encoded */
		mci->mci_flags |= MCIF_CVT8TO7;
	}
#endif
	else if (!bitset(MM_PASS8BIT, MimeMode))
	{
		/* cannot just send a 8-bit version */
		extern char MsgBuf[];

		usrerr("%s does not support 8BITMIME", CurHostName);
		mci_setstat(mci, EX_NOTSTICKY, "5.6.3", MsgBuf);
		return EX_DATAERR;
	}

	if (bitset(MCIF_DSN, mci->mci_flags))
	{
		if (e->e_envid != NULL &&
		    SPACELEFT(optbuf, bufp) > strlen(e->e_envid) + 7)
		{
			snprintf(bufp, SPACELEFT(optbuf, bufp),
				 " ENVID=%s", e->e_envid);
			bufp += strlen(bufp);
		}

		/* RET= parameter */
		if (bitset(EF_RET_PARAM, e->e_flags) &&
		    SPACELEFT(optbuf, bufp) > 9)
		{
			snprintf(bufp, SPACELEFT(optbuf, bufp),
				 " RET=%s",
				 bitset(EF_NO_BODY_RETN, e->e_flags) ?
					"HDRS" : "FULL");
			bufp += strlen(bufp);
		}
	}

	/*
	**  Send the MAIL command.
	**	Designates the sender.
	*/

	mci->mci_state = MCIS_ACTIVE;

	if (bitset(EF_RESPONSE, e->e_flags) &&
	    !bitnset(M_NO_NULL_FROM, m->m_flags))
		(void) strcpy(buf, "");
	else
		expand("\201g", buf, sizeof buf, e);
	if (buf[0] == '<')
	{
		/* strip off <angle brackets> (put back on below) */
		bufp = &buf[strlen(buf) - 1];
		if (*bufp == '>')
			*bufp = '\0';
		bufp = &buf[1];
	}
	else
		bufp = buf;
	if (bitnset(M_LOCALMAILER, e->e_from.q_mailer->m_flags) ||
	    !bitnset(M_FROMPATH, m->m_flags))
	{
		smtpmessage("MAIL From:<%s>%s", m, mci, bufp, optbuf);
	}
	else
	{
		smtpmessage("MAIL From:<@@%s%c%s>%s", m, mci, MyHostName,
			*bufp == '@@' ? ',' : ':', bufp, optbuf);
	}
	SmtpPhase = mci->mci_phase = "client MAIL";
	sm_setproctitle(TRUE, "%s %s: %s", e->e_id, CurHostName, mci->mci_phase);
	r = reply(m, mci, e, TimeOuts.to_mail, NULL);
	if (r < 0)
	{
		/* communications failure */
		mci->mci_errno = errno;
		mci_setstat(mci, EX_TEMPFAIL, "4.4.2", NULL);
		smtpquit(m, mci, e);
		return EX_TEMPFAIL;
	}
	else if (r == 421)
	{
		/* service shutting down */
		mci_setstat(mci, EX_TEMPFAIL, "4.5.0", SmtpReplyBuffer);
		smtpquit(m, mci, e);
		return EX_TEMPFAIL;
	}
	else if (REPLYTYPE(r) == 4)
	{
		mci_setstat(mci, EX_NOTSTICKY, smtptodsn(r), SmtpReplyBuffer);
		return EX_TEMPFAIL;
	}
	else if (REPLYTYPE(r) == 2)
	{
		return EX_OK;
	}
	else if (r == 501)
	{
		/* syntax error in arguments */
		mci_setstat(mci, EX_NOTSTICKY, "5.5.2", SmtpReplyBuffer);
		return EX_DATAERR;
	}
	else if (r == 553)
	{
		/* mailbox name not allowed */
		mci_setstat(mci, EX_NOTSTICKY, "5.1.3", SmtpReplyBuffer);
		return EX_DATAERR;
	}
	else if (r == 552)
	{
		/* exceeded storage allocation */
		mci_setstat(mci, EX_NOTSTICKY, "5.3.4", SmtpReplyBuffer);
		if (bitset(MCIF_SIZE, mci->mci_flags))
			e->e_flags |= EF_NO_BODY_RETN;
		return EX_UNAVAILABLE;
	}
	else if (REPLYTYPE(r) == 5)
	{
		/* unknown error */
		mci_setstat(mci, EX_NOTSTICKY, "5.0.0", SmtpReplyBuffer);
		return EX_UNAVAILABLE;
	}

	if (LogLevel > 1)
	{
		sm_syslog(LOG_CRIT, e->e_id,
			"%.100s: SMTP MAIL protocol error: %s",
			CurHostName,
			shortenstring(SmtpReplyBuffer, 403));
	}

	/* protocol error -- close up */
	mci_setstat(mci, EX_PROTOCOL, "5.5.1", SmtpReplyBuffer);
	smtpquit(m, mci, e);
	return EX_PROTOCOL;
}
/*
**  SMTPRCPT -- designate recipient.
**
**	Parameters:
**		to -- address of recipient.
**		m -- the mailer we are sending to.
**		mci -- the connection info for this transaction.
**		e -- the envelope for this transaction.
**
**	Returns:
**		exit status corresponding to recipient status.
**
**	Side Effects:
**		Sends the mail via SMTP.
*/

int
smtprcpt(to, m, mci, e)
	ADDRESS *to;
	register MAILER *m;
	MCI *mci;
	ENVELOPE *e;
{
	register int r;
	char *bufp;
	char optbuf[MAXLINE];

	strcpy(optbuf, "");
	bufp = &optbuf[strlen(optbuf)];
	if (bitset(MCIF_DSN, mci->mci_flags))
	{
		/* NOTIFY= parameter */
		if (bitset(QHASNOTIFY, to->q_flags) &&
		    bitset(QPRIMARY, to->q_flags) &&
		    !bitnset(M_LOCALMAILER, m->m_flags))
		{
			bool firstone = TRUE;

			strcat(bufp, " NOTIFY=");
			if (bitset(QPINGONSUCCESS, to->q_flags))
			{
				strcat(bufp, "SUCCESS");
				firstone = FALSE;
			}
			if (bitset(QPINGONFAILURE, to->q_flags))
			{
				if (!firstone)
					strcat(bufp, ",");
				strcat(bufp, "FAILURE");
				firstone = FALSE;
			}
			if (bitset(QPINGONDELAY, to->q_flags))
			{
				if (!firstone)
					strcat(bufp, ",");
				strcat(bufp, "DELAY");
				firstone = FALSE;
			}
			if (firstone)
				strcat(bufp, "NEVER");
			bufp += strlen(bufp);
		}

		/* ORCPT= parameter */
		if (to->q_orcpt != NULL &&
		    SPACELEFT(optbuf, bufp) > strlen(to->q_orcpt) + 7)
		{
			snprintf(bufp, SPACELEFT(optbuf, bufp),
				 " ORCPT=%s", to->q_orcpt);
			bufp += strlen(bufp);
		}
	}

	smtpmessage("RCPT To:<%s>%s", m, mci, to->q_user, optbuf);

	SmtpPhase = mci->mci_phase = "client RCPT";
	sm_setproctitle(TRUE, "%s %s: %s", e->e_id, CurHostName, mci->mci_phase);
	r = reply(m, mci, e, TimeOuts.to_rcpt, NULL);
	to->q_rstatus = newstr(SmtpReplyBuffer);
	to->q_status = smtptodsn(r);
	to->q_statmta = mci->mci_host;
	if (r < 0 || REPLYTYPE(r) == 4)
		return EX_TEMPFAIL;
	else if (REPLYTYPE(r) == 2)
		return EX_OK;
	else if (r == 550)
	{
		to->q_status = "5.1.1";
		return EX_NOUSER;
	}
	else if (r == 551)
	{
		to->q_status = "5.1.6";
		return EX_NOUSER;
	}
	else if (r == 553)
	{
		to->q_status = "5.1.3";
		return EX_NOUSER;
	}
	else if (REPLYTYPE(r) == 5)
	{
		return EX_UNAVAILABLE;
	}

	if (LogLevel > 1)
	{
		sm_syslog(LOG_CRIT, e->e_id,
			"%.100s: SMTP RCPT protocol error: %s",
			CurHostName,
			shortenstring(SmtpReplyBuffer, 403));
	}

	mci_setstat(mci, EX_PROTOCOL, "5.5.1", SmtpReplyBuffer);
	return EX_PROTOCOL;
}
/*
**  SMTPDATA -- send the data and clean up the transaction.
**
**	Parameters:
**		m -- mailer being sent to.
**		mci -- the mailer connection information.
**		e -- the envelope for this message.
**
**	Returns:
**		exit status corresponding to DATA command.
**
**	Side Effects:
**		none.
*/

static jmp_buf	CtxDataTimeout;
static void	datatimeout __P((void));

int
smtpdata(m, mci, e)
	MAILER *m;
	register MCI *mci;
	register ENVELOPE *e;
{
	register int r;
	register EVENT *ev;
	int rstat;
	int xstat;
	time_t timeout;

	/*
	**  Send the data.
	**	First send the command and check that it is ok.
	**	Then send the data.
	**	Follow it up with a dot to terminate.
	**	Finally get the results of the transaction.
	*/

	/* send the command and check ok to proceed */
	smtpmessage("DATA", m, mci);
	SmtpPhase = mci->mci_phase = "client DATA 354";
	sm_setproctitle(TRUE, "%s %s: %s", e->e_id, CurHostName, mci->mci_phase);
	r = reply(m, mci, e, TimeOuts.to_datainit, NULL);
	if (r < 0 || REPLYTYPE(r) == 4)
	{
		smtpquit(m, mci, e);
		return EX_TEMPFAIL;
	}
	else if (REPLYTYPE(r) == 5)
	{
		smtprset(m, mci, e);
		return EX_UNAVAILABLE;
	}
	else if (REPLYTYPE(r) != 3)
	{
		if (LogLevel > 1)
		{
			sm_syslog(LOG_CRIT, e->e_id,
				"%.100s: SMTP DATA-1 protocol error: %s",
				CurHostName,
				shortenstring(SmtpReplyBuffer, 403));
		}
		smtprset(m, mci, e);
		mci_setstat(mci, EX_PROTOCOL, "5.5.1", SmtpReplyBuffer);
		return (EX_PROTOCOL);
	}

	/*
	**  Set timeout around data writes.  Make it at least large
	**  enough for DNS timeouts on all recipients plus some fudge
	**  factor.  The main thing is that it should not be infinite.
	*/

	if (setjmp(CtxDataTimeout) != 0)
	{
		mci->mci_errno = errno;
		mci->mci_state = MCIS_ERROR;
		mci_setstat(mci, EX_TEMPFAIL, "4.4.2", NULL);
		syserr("451 timeout writing message to %s", CurHostName);
		smtpquit(m, mci, e);
		return EX_TEMPFAIL;
	}

	timeout = e->e_msgsize / 16;
	if (timeout < (time_t) 600)
		timeout = (time_t) 600;
	timeout += e->e_nrcpts * 300;
	ev = setevent(timeout, datatimeout, 0);

	/*
	**  Output the actual message.
	*/

	(*e->e_puthdr)(mci, e->e_header, e, M87F_OUTER);
	(*e->e_putbody)(mci, e, NULL);

	/*
	**  Cleanup after sending message.
	*/

	clrevent(ev);

	if (ferror(mci->mci_out))
	{
		/* error during processing -- don't send the dot */
		mci->mci_errno = EIO;
		mci->mci_state = MCIS_ERROR;
		mci_setstat(mci, EX_IOERR, "4.4.2", NULL);
		smtpquit(m, mci, e);
		return EX_IOERR;
	}

	/* terminate the message */
	fprintf(mci->mci_out, ".%s", m->m_eol);
	if (TrafficLogFile != NULL)
		fprintf(TrafficLogFile, "%05d >>> .\n", (int) getpid());
	if (Verbose)
		nmessage(">>> .");

	/* check for the results of the transaction */
	SmtpPhase = mci->mci_phase = "client DATA status";
	sm_setproctitle(TRUE, "%s %s: %s", e->e_id, CurHostName, mci->mci_phase);
	if (bitnset(M_LMTP, m->m_flags))
		return EX_OK;
	r = reply(m, mci, e, TimeOuts.to_datafinal, NULL);
	if (r < 0)
	{
		smtpquit(m, mci, e);
		return EX_TEMPFAIL;
	}
	mci->mci_state = MCIS_OPEN;
	xstat = EX_NOTSTICKY;
	if (r == 452)
		rstat = EX_TEMPFAIL;
	else if (REPLYTYPE(r) == 4)
		rstat = xstat = EX_TEMPFAIL;
	else if (REPLYCLASS(r) != 5)
		rstat = xstat = EX_PROTOCOL;
	else if (REPLYTYPE(r) == 2)
		rstat = xstat = EX_OK;
	else if (REPLYTYPE(r) == 5)
		rstat = EX_UNAVAILABLE;
	else
		rstat = EX_PROTOCOL;
	mci_setstat(mci, xstat, smtptodsn(r), SmtpReplyBuffer);
	if (e->e_statmsg != NULL)
		free(e->e_statmsg);
	e->e_statmsg = newstr(&SmtpReplyBuffer[4]);
	if (rstat != EX_PROTOCOL)
		return rstat;
	if (LogLevel > 1)
	{
		sm_syslog(LOG_CRIT, e->e_id,
			"%.100s: SMTP DATA-2 protocol error: %s",
			CurHostName,
			shortenstring(SmtpReplyBuffer, 403));
	}
	return rstat;
}


static void
datatimeout()
{
	longjmp(CtxDataTimeout, 1);
}
/*
**  SMTPGETSTAT -- get status code from DATA in LMTP
**
**	Parameters:
**		m -- the mailer to which we are sending the message.
**		mci -- the mailer connection structure.
**		e -- the current envelope.
**
**	Returns:
**		The exit status corresponding to the reply code.
*/

int
smtpgetstat(m, mci, e)
	MAILER *m;
	MCI *mci;
	ENVELOPE *e;
{
	int r;
	int stat;

	/* check for the results of the transaction */
	r = reply(m, mci, e, TimeOuts.to_datafinal, NULL);
	if (r < 0)
	{
		smtpquit(m, mci, e);
		return EX_TEMPFAIL;
	}
	if (e->e_statmsg != NULL)
		free(e->e_statmsg);
	e->e_statmsg = newstr(&SmtpReplyBuffer[4]);
	if (REPLYTYPE(r) == 4)
		stat = EX_TEMPFAIL;
	else if (REPLYCLASS(r) != 5)
		stat = EX_PROTOCOL;
	else if (REPLYTYPE(r) == 2)
		stat = EX_OK;
	else if (REPLYTYPE(r) == 5)
		stat = EX_UNAVAILABLE;
	else
		stat = EX_PROTOCOL;
	mci_setstat(mci, stat, smtptodsn(r), SmtpReplyBuffer);
	if (LogLevel > 1 && stat == EX_PROTOCOL)
	{
		sm_syslog(LOG_CRIT, e->e_id,
			"%.100s: SMTP DATA-3 protocol error: %s",
			CurHostName,
			shortenstring(SmtpReplyBuffer, 403));
	}
	return stat;
}
/*
**  SMTPQUIT -- close the SMTP connection.
**
**	Parameters:
**		m -- a pointer to the mailer.
**		mci -- the mailer connection information.
**		e -- the current envelope.
**
**	Returns:
**		none.
**
**	Side Effects:
**		sends the final protocol and closes the connection.
*/

void
smtpquit(m, mci, e)
	register MAILER *m;
	register MCI *mci;
	ENVELOPE *e;
{
	bool oldSuprErrs = SuprErrs;

	/*
	**	Suppress errors here -- we may be processing a different
	**	job when we do the quit connection, and we don't want the 
	**	new job to be penalized for something that isn't it's
	**	problem.
	*/

	SuprErrs = TRUE;

	/* send the quit message if we haven't gotten I/O error */
	if (mci->mci_state != MCIS_ERROR)
	{
		SmtpPhase = "client QUIT";
		smtpmessage("QUIT", m, mci);
		(void) reply(m, mci, e, TimeOuts.to_quit, NULL);
		SuprErrs = oldSuprErrs;
		if (mci->mci_state == MCIS_CLOSED)
			return;
	}

	/* now actually close the connection and pick up the zombie */
	(void) endmailer(mci, e, NULL);

	SuprErrs = oldSuprErrs;
}
/*
**  SMTPRSET -- send a RSET (reset) command
*/

void
smtprset(m, mci, e)
	register MAILER *m;
	register MCI *mci;
	ENVELOPE *e;
{
	int r;

	SmtpPhase = "client RSET";
	smtpmessage("RSET", m, mci);
	r = reply(m, mci, e, TimeOuts.to_rset, NULL);
	if (r < 0)
		mci->mci_state = MCIS_ERROR;
	else if (REPLYTYPE(r) == 2)
	{
		mci->mci_state = MCIS_OPEN;
		return;
	}
	smtpquit(m, mci, e);
}
/*
**  SMTPPROBE -- check the connection state
*/

int
smtpprobe(mci)
	register MCI *mci;
{
	int r;
	MAILER *m = mci->mci_mailer;
	extern ENVELOPE BlankEnvelope;
	ENVELOPE *e = &BlankEnvelope;

	SmtpPhase = "client probe";
	smtpmessage("RSET", m, mci);
	r = reply(m, mci, e, TimeOuts.to_miscshort, NULL);
	if (r < 0 || REPLYTYPE(r) != 2)
		smtpquit(m, mci, e);
	return r;
}
/*
**  REPLY -- read arpanet reply
**
**	Parameters:
**		m -- the mailer we are reading the reply from.
**		mci -- the mailer connection info structure.
**		e -- the current envelope.
**		timeout -- the timeout for reads.
**		pfunc -- processing function called on each line of response.
**			If null, no special processing is done.
**
**	Returns:
**		reply code it reads.
**
**	Side Effects:
**		flushes the mail file.
*/

int
reply(m, mci, e, timeout, pfunc)
	MAILER *m;
	MCI *mci;
	ENVELOPE *e;
	time_t timeout;
	void (*pfunc)();
{
	register char *bufp;
	register int r;
	bool firstline = TRUE;
	char junkbuf[MAXLINE];

	if (mci->mci_out != NULL)
		(void) fflush(mci->mci_out);

	if (tTd(18, 1))
		printf("reply\n");

	/*
	**  Read the input line, being careful not to hang.
	*/

	bufp = SmtpReplyBuffer;
	for (;;)
	{
		register char *p;

		/* actually do the read */
		if (e->e_xfp != NULL)
			(void) fflush(e->e_xfp);	/* for debugging */

		/* if we are in the process of closing just give the code */
		if (mci->mci_state == MCIS_CLOSED)
			return (SMTPCLOSING);

		if (mci->mci_out != NULL)
			fflush(mci->mci_out);

		/* get the line from the other side */
		p = sfgets(bufp, MAXLINE, mci->mci_in, timeout, SmtpPhase);
		mci->mci_lastuse = curtime();

		if (p == NULL)
		{
			bool oldholderrs;
			extern char MsgBuf[];

			/* if the remote end closed early, fake an error */
			if (errno == 0)
# ifdef ECONNRESET
				errno = ECONNRESET;
# else /* ECONNRESET */
				errno = EPIPE;
# endif /* ECONNRESET */

			mci->mci_errno = errno;
			oldholderrs = HoldErrs;
			HoldErrs = TRUE;
			usrerr("451 reply: read error from %s", CurHostName);

			/* errors on QUIT should not be persistent */
			if (strncmp(SmtpMsgBuffer, "QUIT", 4) != 0)
				mci_setstat(mci, EX_TEMPFAIL, "4.4.2", MsgBuf);

			/* if debugging, pause so we can see state */
			if (tTd(18, 100))
				pause();
			mci->mci_state = MCIS_ERROR;
			smtpquit(m, mci, e);
#if XDEBUG
			{
				char wbuf[MAXLINE];
				char *p = wbuf;
				int wbufleft = sizeof wbuf;

				if (e->e_to != NULL)
				{
					int plen;

					snprintf(p, wbufleft, "%s... ",
						shortenstring(e->e_to, MAXSHORTSTR));
					plen = strlen(p);
					p += plen;
					wbufleft -= plen;
				}
				snprintf(p, wbufleft, "reply(%.100s) during %s",
					 CurHostName == NULL ? "NO_HOST" : CurHostName,
					 SmtpPhase);
				checkfd012(wbuf);
			}
#endif
			HoldErrs = oldholderrs;
			return (-1);
		}
		fixcrlf(bufp, TRUE);

		/* EHLO failure is not a real error */
		if (e->e_xfp != NULL && (bufp[0] == '4' ||
		    (bufp[0] == '5' && strncmp(SmtpMsgBuffer, "EHLO", 4) != 0)))
		{
			/* serious error -- log the previous command */
			if (SmtpNeedIntro)
			{
				/* inform user who we are chatting with */
				fprintf(CurEnv->e_xfp,
					"... while talking to %s:\n",
					CurHostName);
				SmtpNeedIntro = FALSE;
			}
			if (SmtpMsgBuffer[0] != '\0')
				fprintf(e->e_xfp, ">>> %s\n", SmtpMsgBuffer);
			SmtpMsgBuffer[0] = '\0';

			/* now log the message as from the other side */
			fprintf(e->e_xfp, "<<< %s\n", bufp);
		}

		/* display the input for verbose mode */
		if (Verbose)
			nmessage("050 %s", bufp);

		/* ignore improperly formated input */
		if (!(isascii(bufp[0]) && isdigit(bufp[0])) ||
		    !(isascii(bufp[1]) && isdigit(bufp[1])) ||
		    !(isascii(bufp[2]) && isdigit(bufp[2])) ||
		    !(bufp[3] == ' ' || bufp[3] == '-' || bufp[3] == '\0'))
			continue;

		/* process the line */
		if (pfunc != NULL)
			(*pfunc)(bufp, firstline, m, mci, e);

		firstline = FALSE;

		/* decode the reply code */
		r = atoi(bufp);

		/* extra semantics: 0xx codes are "informational" */
		if (r < 100)
			continue;

		/* if no continuation lines, return this line */
		if (bufp[3] != '-')
			break;

		/* first line of real reply -- ignore rest */
		bufp = junkbuf;
	}

	/*
	**  Now look at SmtpReplyBuffer -- only care about the first
	**  line of the response from here on out.
	*/

	/* save temporary failure messages for posterity */
	if (SmtpReplyBuffer[0] == '4' &&
	    (bitnset(M_LMTP, m->m_flags) || SmtpError[0] == '\0'))
		snprintf(SmtpError, sizeof SmtpError, "%s", SmtpReplyBuffer);

	/* reply code 421 is "Service Shutting Down" */
	if (r == SMTPCLOSING && mci->mci_state != MCIS_SSD)
	{
		/* send the quit protocol */
		mci->mci_state = MCIS_SSD;
		smtpquit(m, mci, e);
	}

	return (r);
}
/*
**  SMTPMESSAGE -- send message to server
**
**	Parameters:
**		f -- format
**		m -- the mailer to control formatting.
**		a, b, c -- parameters
**
**	Returns:
**		none.
**
**	Side Effects:
**		writes message to mci->mci_out.
*/

/*VARARGS1*/
void
#ifdef __STDC__
smtpmessage(char *f, MAILER *m, MCI *mci, ...)
#else
smtpmessage(f, m, mci, va_alist)
	char *f;
	MAILER *m;
	MCI *mci;
	va_dcl
#endif
{
	VA_LOCAL_DECL

	VA_START(mci);
	(void) vsnprintf(SmtpMsgBuffer, sizeof SmtpMsgBuffer, f, ap);
	VA_END;

	if (tTd(18, 1) || Verbose)
		nmessage(">>> %s", SmtpMsgBuffer);
	if (TrafficLogFile != NULL)
		fprintf(TrafficLogFile, "%05d >>> %s\n",
			(int) getpid(), SmtpMsgBuffer);
	if (mci->mci_out != NULL)
	{
		fprintf(mci->mci_out, "%s%s", SmtpMsgBuffer,
			m == NULL ? "\r\n" : m->m_eol);
	}
	else if (tTd(18, 1))
	{
		printf("smtpmessage: NULL mci_out\n");
	}
}

# endif /* SMTP */
@


1.10
log
@sendmail 8.9.3
@
text
@@


1.9
log
@sendmail 8.9.2
@
text
@d17 1
a17 1
static char sccsid[] = "@@(#)usersmtp.c	8.108 (Berkeley) 10/6/1998 (with SMTP)";
d19 1
a19 1
static char sccsid[] = "@@(#)usersmtp.c	8.108 (Berkeley) 10/6/1998 (without SMTP)";
a329 1
	int l;
d339 1
d344 1
a344 1
	l = sizeof optbuf - strlen(optbuf) - 1;
d355 2
a356 1
		if (bodytype != NULL && strlen(bodytype) + 7 < l)
d358 3
a360 3
			strcat(optbuf, " BODY=");
			strcat(optbuf, bodytype);
			l -= strlen(optbuf);
d391 2
a392 1
		if (e->e_envid != NULL && strlen(e->e_envid) < (SIZE_T) (l - 7))
d394 3
a396 3
			strcat(optbuf, " ENVID=");
			strcat(optbuf, e->e_envid);
			l -= strlen(optbuf);
d400 2
a401 1
		if (bitset(EF_RET_PARAM, e->e_flags) && l >= 9)
d403 5
a407 6
			strcat(optbuf, " RET=");
			if (bitset(EF_NO_BODY_RETN, e->e_flags))
				strcat(optbuf, "HDRS");
			else
				strcat(optbuf, "FULL");
			l -= 9;
d534 1
a534 1
	int l;
d538 1
a538 1
	l = sizeof optbuf - 1;
d548 1
a548 1
			strcat(optbuf, " NOTIFY=");
d551 1
a551 1
				strcat(optbuf, "SUCCESS");
d557 2
a558 2
					strcat(optbuf, ",");
				strcat(optbuf, "FAILURE");
d564 2
a565 2
					strcat(optbuf, ",");
				strcat(optbuf, "DELAY");
d569 2
a570 2
				strcat(optbuf, "NEVER");
			l -= strlen(optbuf);
d574 2
a575 1
		if (to->q_orcpt != NULL && strlen(to->q_orcpt) + 7 < l)
d577 3
a579 3
			strcat(optbuf, " ORCPT=");
			strcat(optbuf, to->q_orcpt);
			l -= strlen(optbuf);
d679 1
a679 1
	else if (r != 354)
d719 1
a719 1
	(*e->e_puthdr)(mci, e->e_header, e);
@


1.8
log
@something hosed the sendmail import; fix up by hand
@
text
@d17 1
a17 1
static char sccsid[] = "@@(#)usersmtp.c	8.104 (Berkeley) 6/30/98 (with SMTP)";
d19 1
a19 1
static char sccsid[] = "@@(#)usersmtp.c	8.104 (Berkeley) 6/30/98 (without SMTP)";
d121 1
a121 1
	setproctitle("%s %s: %s", e->e_id, CurHostName, mci->mci_phase);
d154 1
a154 1
	setproctitle("%s %s: %s", e->e_id, CurHostName, mci->mci_phase);
d442 1
a442 1
	setproctitle("%s %s: %s", e->e_id, CurHostName, mci->mci_phase);
d583 1
a583 1
	setproctitle("%s %s: %s", e->e_id, CurHostName, mci->mci_phase);
d664 1
a664 1
	setproctitle("%s %s: %s", e->e_id, CurHostName, mci->mci_phase);
d744 1
a744 1
	setproctitle("%s %s: %s", e->e_id, CurHostName, mci->mci_phase);
a976 1
		extern time_t curtime __P((void));
d1010 4
a1013 1
			mci_setstat(mci, EX_TEMPFAIL, "4.4.2", MsgBuf);
d1037 2
a1038 1
					CurHostName, SmtpPhase);
@


1.7
log
@Upgrade to sendmail 8.8.8
@
text
@d2 2
a3 1
 * Copyright (c) 1983, 1995-1997 Eric P. Allman
d7 3
a9 15
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
a10 11
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
d17 1
a17 1
static char sccsid[] = "@@(#)usersmtp.c	8.88 (Berkeley) 10/20/97 (with SMTP)";
d19 1
a19 1
static char sccsid[] = "@@(#)usersmtp.c	8.88 (Berkeley) 10/20/97 (without SMTP)";
d70 2
a71 2
	extern void esmtp_check();
	extern void helo_options();
a134 1
#if _FFR_LMTP
a135 3
#else
	if (bitnset(M_ESMTP, m->m_flags))
#endif
a138 1
#if _FFR_LMTP
a144 3
#else
	if (bitset(MCIF_ESMTP, mci->mci_flags))
#endif
a159 1
#if _FFR_LMTP
a161 3
#else
		if (bitset(MCIF_ESMTP, mci->mci_flags))
#endif
a181 1
#if _FFR_LMTP
a182 1
#endif
d186 1
a186 1
			mci->mci_host);
d383 1
a383 1
		usrerr("%s does not support 8BITMIME", mci->mci_host);
d459 1
a459 2
	else if (r == 452 && bitset(MCIF_SIZE, mci->mci_flags) &&
		 e->e_msgsize > 0)
a463 5
	else if (REPLYTYPE(r) == 4)
	{
		mci_setstat(mci, EX_TEMPFAIL, smtptodsn(r), SmtpReplyBuffer);
		return EX_TEMPFAIL;
	}
d483 1
a483 1
		mci_setstat(mci, EX_NOTSTICKY, "5.2.2", SmtpReplyBuffer);
d499 1
a499 1
			mci->mci_host,
d616 1
a616 1
			mci->mci_host,
d639 1
a639 1
static void	datatimeout();
d682 1
a682 1
				mci->mci_host,
d701 1
a701 1
		syserr("451 timeout writing message to %s", mci->mci_host);
a744 1
#if _FFR_LMTP
a746 1
#endif
d777 1
a777 1
			mci->mci_host,
a800 2
#if _FFR_LMTP

d828 2
d835 1
a835 1
			mci->mci_host,
a839 2

#endif
d977 1
a977 1
		extern time_t curtime();
d1010 1
a1010 1
			usrerr("451 reply: read error from %s", mci->mci_host);
d1029 1
a1029 1
						shortenstring(e->e_to, 203));
d1035 1
a1035 1
					mci->mci_host, SmtpPhase);
d1073 1
a1073 1
		    !(bufp[3] == ' ' || bufp[3] == '-'))
d1103 2
a1104 1
	if (SmtpReplyBuffer[0] == '4' && SmtpError[0] == '\0')
@


1.6
log
@Sendmail 8.8.6.
@
text
@d39 1
a39 1
static char sccsid[] = "@@(#)usersmtp.c	8.87 (Berkeley) 6/3/97 (with SMTP)";
d41 1
a41 1
static char sccsid[] = "@@(#)usersmtp.c	8.87 (Berkeley) 6/3/97 (without SMTP)";
a62 1
int	SmtpPid;			/* pid of mailer */
@


1.5
log
@Sendmail 8.8.5.
@
text
@d2 1
a2 1
 * Copyright (c) 1983, 1995, 1996 Eric P. Allman
d39 1
a39 1
static char sccsid[] = "@@(#)usersmtp.c	8.80 (Berkeley) 1/18/97 (with SMTP)";
d41 1
a41 1
static char sccsid[] = "@@(#)usersmtp.c	8.80 (Berkeley) 1/18/97 (without SMTP)";
d392 1
a392 1
		if (bodytype != NULL)
d527 2
a537 1
#ifdef LOG
d540 3
a542 2
		syslog(LOG_CRIT, "%s: %.100s: SMTP MAIL protocol error: %s",
			e->e_id, mci->mci_host,
a544 1
#endif
a654 1
#ifdef LOG
d657 3
a659 2
		syslog(LOG_CRIT, "%s: %.100s: SMTP RCPT protocol error: %s",
			e->e_id, mci->mci_host,
a661 1
#endif
a720 1
#ifdef LOG
d723 3
a725 2
			syslog(LOG_CRIT, "%s: %.100s: SMTP DATA-1 protocol error: %s",
				e->e_id, mci->mci_host,
a727 1
#endif
a801 2
	else if (r == 552)
		rstat = EX_UNAVAILABLE;
d809 1
a809 1
		rstat = xstat = EX_UNAVAILABLE;
a817 1
#ifdef LOG
d820 3
a822 2
		syslog(LOG_CRIT, "%s: %.100s: SMTP DATA-2 protocol error: %s",
			e->e_id, mci->mci_host,
a824 1
#endif
a875 1
#ifdef LOG
d878 3
a880 2
		syslog(LOG_CRIT, "%s: %.100s: SMTP DATA-3 protocol error: %s",
			e->e_id, mci->mci_host,
a882 1
#endif
a926 2
		{
			SuprErrs = oldSuprErrs;
a927 1
		}
d1020 2
a1021 1
	for (bufp = SmtpReplyBuffer;; bufp = junkbuf)
d1116 7
a1128 8
		/* if continuation is required, we can go on */
		if (bufp[3] == '-')
			continue;

		/* ignore improperly formated input */
		if (!(isascii(bufp[0]) && isdigit(bufp[0])))
			continue;

d1133 5
a1137 1
		if (r >= 100)
d1139 3
@


1.4
log
@Update to Sendmail 8.8.4, plus recent patches, plus OpenBSD support.
Also include entire example configuration subset.
Includes smrsh (using /usr/libexec/sm.bin).

Of the top of my head, the only things I removed from the distribution were
contrib/mail.local.linux, src/Makefiles, all the *.0 and *.ps files.
Our praliases man page replaces the distributed one, ours is better.
@
text
@d39 1
a39 1
static char sccsid[] = "@@(#)usersmtp.c	8.79 (Berkeley) 12/1/96 (with SMTP)";
d41 1
a41 1
static char sccsid[] = "@@(#)usersmtp.c	8.79 (Berkeley) 12/1/96 (without SMTP)";
d496 6
d693 1
d800 2
a801 1
	if (REPLYTYPE(r) == 4)
d803 4
d808 1
a808 1
		rstat = EX_PROTOCOL;
d810 1
a810 1
		rstat = EX_OK;
d812 1
a812 1
		rstat = EX_UNAVAILABLE;
d815 1
a815 1
	mci_setstat(mci, rstat, smtptodsn(r), SmtpReplyBuffer);
@


1.3
log
@bring up to 8.7.6
@
text
@d2 1
a2 1
 * Copyright (c) 1983, 1995 Eric P. Allman
d38 2
a39 2
#ifdef SMTP
static char sccsid[] = "@@(#)usersmtp.c	8.65.1.2 (Berkeley) 9/16/96 (with SMTP)";
d41 1
a41 1
static char sccsid[] = "@@(#)usersmtp.c	8.65.1.2 (Berkeley) 9/16/96 (without SMTP)";
d48 1
a48 1
# ifdef SMTP
d67 1
d87 1
a87 1
	struct mailer *m;
d146 1
a146 1
	if (r < 0 || REPLYTYPE(r) == 4)
d148 2
d158 3
d162 1
d166 8
d175 1
d191 4
d196 1
d205 1
a205 1
		goto tempfail1;
d217 3
d224 1
a224 1
		mci->mci_exitstat = EX_CONFIG;
d241 1
a241 1
			goto tempfail2;
d253 7
a260 1
	mci->mci_exitstat = EX_TEMPFAIL;
d263 2
a269 1
	mci->mci_exitstat = EX_UNAVAILABLE;
d271 1
d362 1
a362 1
	struct mailer *m;
d418 2
d421 1
a421 1
		mci->mci_status = "5.6.3";
d427 1
a427 1
		if (e->e_envid != NULL && strlen(e->e_envid) < (SIZE_T) l)
d481 1
a481 1
	if (r < 0 || r == 421)
d483 1
a483 2
		/* communications failure/service shutting down */
		mci->mci_exitstat = EX_TEMPFAIL;
d485 8
d498 1
d508 1
a508 1
		mci->mci_status = "5.5.2";
d514 1
a514 1
		mci->mci_status = "5.1.3";
d520 1
a520 1
		mci->mci_status = "5.2.2";
d526 1
d540 1
a569 1
	extern char *smtptodsn();
d577 2
a578 1
		    bitset(QPRIMARY, to->q_flags))
d628 13
a640 1
	else if (r == 550 || r == 551 || r == 553)
d642 1
d644 1
d646 1
d657 1
d665 1
d680 1
a680 1
	struct mailer *m;
d686 1
d723 1
a735 1
		mci->mci_exitstat = EX_TEMPFAIL;
d737 1
a765 1
		mci->mci_exitstat = EX_IOERR;
d767 1
d775 1
a775 1
		fprintf(TrafficLogFile, "%05d >>> .\n", getpid());
d780 1
a780 1
	SmtpPhase = mci->mci_phase = "client DATA 250";
d782 4
a792 1
	e->e_statmsg = newstr(&SmtpReplyBuffer[4]);
d794 1
a794 1
		return EX_TEMPFAIL;
d796 1
a796 1
		/* fall through */ ;
d798 1
a798 1
		return EX_OK;
d800 9
a808 1
		return EX_UNAVAILABLE;
d817 1
a817 1
	return EX_PROTOCOL;
d827 54
d885 2
d1039 1
a1049 1
			mci->mci_exitstat = EX_TEMPFAIL;
d1053 1
d1188 2
a1189 1
		fprintf(TrafficLogFile, "%05d >>> %s\n", getpid(), SmtpMsgBuffer);
@


1.2
log
@Sendmail 8.7.3 from NetBSD
@
text
@d39 1
a39 1
static char sccsid[] = "@@(#)usersmtp.c	8.65 (Berkeley) 9/28/95 (with SMTP)";
d41 1
a41 1
static char sccsid[] = "@@(#)usersmtp.c	8.65 (Berkeley) 9/28/95 (without SMTP)";
d335 1
d346 1
a346 1
		sprintf(optbuf, " SIZE=%ld", e->e_msgsize);
d349 1
d364 1
d393 1
a393 1
		if (e->e_envid != NULL)
d397 1
d401 1
a401 1
		if (bitset(EF_RET_PARAM, e->e_flags))
d408 1
d524 1
d529 1
d560 1
d564 1
a564 1
		if (to->q_orcpt != NULL)
d568 1
d933 1
d937 3
a939 1
					sprintf(p, "%s... ",
d941 3
a943 1
					p += strlen(p);
d945 1
a945 1
				sprintf(p, "reply(%.100s) during %s",
d1009 1
a1009 1
		(void) strcpy(SmtpError, SmtpReplyBuffer);
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
 * Copyright (c) 1983 Eric P. Allman
d39 1
a39 1
static char sccsid[] = "@@(#)usersmtp.c	8.18 (Berkeley) 1/24/94 (with SMTP)";
d41 1
a41 1
static char sccsid[] = "@@(#)usersmtp.c	8.18 (Berkeley) 1/24/94 (without SMTP)";
d66 1
a66 3
#ifdef __STDC__
extern	smtpmessage(char *f, MAILER *m, MCI *mci, ...);
#endif
d84 1
d107 2
a189 3
	**
	**	If this code remains at all, "CheckLoopBack" should be
	**	a mailer flag.  This is a MAYBENEXTRELEASE feature.
d195 2
a196 1
	if (CheckLoopBack && strcasecmp(&SmtpReplyBuffer[4], MyHostName) == 0)
d198 2
a199 2
		syserr("553 %s config error: mail loops back to myself",
			MyHostName);
a245 1
**
d248 1
d258 1
a258 1
esmtp_check(line, m, mci, e)
d260 1
d265 1
a265 4
	if (strlen(line) < 5)
		return;
	line += 4;
	if (strncmp(line, "ESMTP ", 6) == 0)
d267 2
d275 1
d285 1
a285 1
helo_options(line, m, mci, e)
d287 1
d294 4
a297 1
	if (strlen(line) < 5)
d316 2
d328 1
d336 2
a337 1
	char buf[MAXNAME];
d349 58
d418 1
a418 1
		expand("\201g", buf, &buf[sizeof buf - 1], e);
d429 1
a429 1
	if (e->e_from.q_mailer == LocalMailer ||
d442 1
a442 1
	if (r < 0 || REPLYTYPE(r) == 4)
d444 1
d450 5
a454 1
	else if (r == 250)
a455 1
		mci->mci_exitstat = EX_OK;
d458 12
d472 7
a478 3
		/* signal service unavailable */
		mci->mci_exitstat = EX_UNAVAILABLE;
		smtpquit(m, mci, e);
d485 3
a487 2
		syslog(LOG_CRIT, "%s: SMTP MAIL protocol error: %s",
			e->e_id, SmtpReplyBuffer);
a492 1
	mci->mci_exitstat = EX_PROTOCOL;
d511 1
d519 2
d522 42
a563 1
	smtpmessage("RCPT To:<%s>", m, mci, to->q_user);
d568 3
d572 1
a572 1
		return (EX_TEMPFAIL);
d574 1
a574 1
		return (EX_OK);
d576 3
a578 3
		return (EX_NOUSER);
	else if (r == 552 || r == 554)
		return (EX_UNAVAILABLE);
d583 3
a585 2
		syslog(LOG_CRIT, "%s: SMTP RCPT protocol error: %s",
			e->e_id, SmtpReplyBuffer);
d589 1
a589 1
	return (EX_PROTOCOL);
d606 1
a606 1
static int	datatimeout();
d608 1
d634 1
a634 1
		return (EX_TEMPFAIL);
d636 1
a636 1
	else if (r == 554)
d639 1
a639 1
		return (EX_UNAVAILABLE);
d646 3
a648 2
			syslog(LOG_CRIT, "%s: SMTP DATA-1 protocol error: %s",
				e->e_id, SmtpReplyBuffer);
d672 3
a674 3
	if (timeout < (time_t) 60)
		timeout = (time_t) 60;
	timeout += e->e_nrcpts * 90;
d677 5
a681 3
	/* now output the actual message */
	(*e->e_puthdr)(mci, e);
	putline("\n", mci);
d684 4
d714 1
a714 1
		return (EX_TEMPFAIL);
d719 7
a725 5
		return (EX_TEMPFAIL);
	else if (r == 250)
		return (EX_OK);
	else if (r == 552 || r == 554)
		return (EX_UNAVAILABLE);
d729 3
a731 2
		syslog(LOG_CRIT, "%s: SMTP DATA-2 protocol error: %s",
			e->e_id, SmtpReplyBuffer);
d734 1
a734 1
	return (EX_PROTOCOL);
d738 1
a738 1
static int
d756 1
d796 1
d820 1
d844 2
a845 3
**		pfunc -- processing function for second and subsequent
**			lines of response -- if null, no special
**			processing is done.
d854 1
a899 1
			extern char MsgBuf[];		/* err.c */
d920 1
a920 1
#ifdef XDEBUG
d924 1
d927 2
a928 1
					sprintf(p, "%s... ", e->e_to);
d931 1
a931 1
				sprintf(p, "reply(%s) during %s",
d967 2
a968 2
		if (pfunc != NULL && !firstline)
			(*pfunc)(bufp, m, mci, e);
d1023 1
d1037 1
a1037 1
	(void) vsprintf(SmtpMsgBuffer, f, ap);
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@


1.1.1.2
log
@sendmail 8.9.1
@
text
@d2 1
a2 2
 * Copyright (c) 1998 Sendmail, Inc.  All rights reserved.
 * Copyright (c) 1983, 1995-1997 Eric P. Allman.  All rights reserved.
d6 15
a20 3
 * By using this file, you agree to the terms and conditions set
 * forth in the LICENSE file which can be found at the top level of
 * the sendmail distribution.
d22 11
d38 2
a39 2
#if SMTP
static char sccsid[] = "@@(#)usersmtp.c	8.104 (Berkeley) 6/30/98 (with SMTP)";
d41 1
a41 1
static char sccsid[] = "@@(#)usersmtp.c	8.104 (Berkeley) 6/30/98 (without SMTP)";
d48 1
a48 1
# if SMTP
d63 1
d66 3
a68 2
extern void	smtpmessage __P((char *f, MAILER *m, MCI *mci, ...));
extern int	reply __P((MAILER *, MCI *, ENVELOPE *, time_t, void (*)()));
a85 1
void
d87 1
a87 1
	MAILER *m;
d93 2
a94 2
	extern void esmtp_check __P((char *, bool, MAILER *, MCI *, ENVELOPE *));
	extern void helo_options __P((char *, bool, MAILER *, MCI *, ENVELOPE *));
a107 2
	if (CurHostName == NULL)
		CurHostName = MyHostName;
d144 1
a144 1
	if (r < 0)
a145 2
	if (REPLYTYPE(r) == 4)
		goto tempfail2;
d154 1
a154 1
	if (bitnset(M_ESMTP, m->m_flags) || bitnset(M_LMTP, m->m_flags))
d158 1
a158 6
	if (bitnset(M_LMTP, m->m_flags))
	{
		smtpmessage("LHLO %s", m, mci, MyHostName);
		SmtpPhase = mci->mci_phase = "client LHLO";
	}
	else if (bitset(MCIF_ESMTP, mci->mci_flags))
d174 1
a174 2
		if (bitset(MCIF_ESMTP, mci->mci_flags) &&
		    !bitnset(M_LMTP, m->m_flags))
d183 1
a183 1
		goto tempfail2;
d189 3
d197 5
a201 7
	if (!bitnset(M_NOLOOPCHECK, m->m_flags) &&
	    !bitnset(M_LMTP, m->m_flags) &&
	    strcasecmp(&SmtpReplyBuffer[4], MyHostName) == 0)
	{
		syserr("553 %s config error: mail loops back to me (MX problem?)",
			CurHostName);
		mci_setstat(mci, EX_CONFIG, NULL, NULL);
d218 1
a218 1
			goto tempfail1;
a229 7
	if (mci->mci_errno == 0)
		mci->mci_errno = errno;
	mci_setstat(mci, EX_TEMPFAIL, "4.4.2", NULL);
	if (mci->mci_state != MCIS_CLOSED)
		smtpquit(m, mci, e);
	return;

d231 1
a233 2
	/* XXX should use code from other end iff ENHANCEDSTATUSCODES */
	mci_setstat(mci, EX_TEMPFAIL, "4.5.0", SmtpReplyBuffer);
d239 1
a240 1
	mci_setstat(mci, EX_UNAVAILABLE, "5.5.0", SmtpReplyBuffer);
d247 1
a249 1
**		firstline -- set if this is the first line of the reply.
d259 1
a259 1
esmtp_check(line, firstline, m, mci, e)
a260 1
	bool firstline;
d265 4
a268 1
	if (strstr(line, "ESMTP") != NULL)
a269 2
	if (strstr(line, "8BIT-OK") != NULL)
		mci->mci_flags |= MCIF_8BITOK;
a275 1
**		firstline -- set if this is the first line of the reply.
d285 1
a285 1
helo_options(line, firstline, m, mci, e)
a286 1
	bool firstline;
d293 1
a293 4
	if (firstline)
		return;

	if (strlen(line) < (SIZE_T) 5)
a311 2
	else if (strcasecmp(line, "dsn") == 0)
		mci->mci_flags |= MCIF_DSN;
a321 1
int
d323 1
a323 1
	MAILER *m;
a327 1
	int l;
d329 1
a329 2
	char *bodytype;
	char buf[MAXNAME + 1];
d337 1
a337 1
		snprintf(optbuf, sizeof optbuf, " SIZE=%ld", e->e_msgsize);
a339 64
	l = sizeof optbuf - strlen(optbuf) - 1;

	bodytype = e->e_bodytype;
	if (bitset(MCIF_8BITMIME, mci->mci_flags))
	{
		if (bodytype == NULL &&
		    bitset(MM_MIME8BIT, MimeMode) &&
		    bitset(EF_HAS8BIT, e->e_flags) &&
		    !bitset(EF_DONT_MIME, e->e_flags) &&
		    !bitnset(M_8BITS, m->m_flags))
			bodytype = "8BITMIME";
		if (bodytype != NULL && strlen(bodytype) + 7 < l)
		{
			strcat(optbuf, " BODY=");
			strcat(optbuf, bodytype);
			l -= strlen(optbuf);
		}
	}
	else if (bitnset(M_8BITS, m->m_flags) ||
		 !bitset(EF_HAS8BIT, e->e_flags) ||
		 bitset(MCIF_8BITOK, mci->mci_flags))
	{
		/* just pass it through */
	}
#if MIME8TO7
	else if (bitset(MM_CVTMIME, MimeMode) &&
		 !bitset(EF_DONT_MIME, e->e_flags) &&
		 (!bitset(MM_PASS8BIT, MimeMode) ||
		  bitset(EF_IS_MIME, e->e_flags)))
	{
		/* must convert from 8bit MIME format to 7bit encoded */
		mci->mci_flags |= MCIF_CVT8TO7;
	}
#endif
	else if (!bitset(MM_PASS8BIT, MimeMode))
	{
		/* cannot just send a 8-bit version */
		extern char MsgBuf[];

		usrerr("%s does not support 8BITMIME", CurHostName);
		mci_setstat(mci, EX_NOTSTICKY, "5.6.3", MsgBuf);
		return EX_DATAERR;
	}

	if (bitset(MCIF_DSN, mci->mci_flags))
	{
		if (e->e_envid != NULL && strlen(e->e_envid) < (SIZE_T) (l - 7))
		{
			strcat(optbuf, " ENVID=");
			strcat(optbuf, e->e_envid);
			l -= strlen(optbuf);
		}

		/* RET= parameter */
		if (bitset(EF_RET_PARAM, e->e_flags) && l >= 9)
		{
			strcat(optbuf, " RET=");
			if (bitset(EF_NO_BODY_RETN, e->e_flags))
				strcat(optbuf, "HDRS");
			else
				strcat(optbuf, "FULL");
			l -= 9;
		}
	}
d352 1
a352 1
		expand("\201g", buf, sizeof buf, e);
d363 1
a363 1
	if (bitnset(M_LOCALMAILER, e->e_from.q_mailer->m_flags) ||
d376 1
a376 1
	if (r < 0)
d378 1
a378 1
		/* communications failure */
a379 8
		mci_setstat(mci, EX_TEMPFAIL, "4.4.2", NULL);
		smtpquit(m, mci, e);
		return EX_TEMPFAIL;
	}
	else if (r == 421)
	{
		/* service shutting down */
		mci_setstat(mci, EX_TEMPFAIL, "4.5.0", SmtpReplyBuffer);
d383 1
a383 6
	else if (REPLYTYPE(r) == 4)
	{
		mci_setstat(mci, EX_NOTSTICKY, smtptodsn(r), SmtpReplyBuffer);
		return EX_TEMPFAIL;
	}
	else if (REPLYTYPE(r) == 2)
d385 1
a387 12
	else if (r == 501)
	{
		/* syntax error in arguments */
		mci_setstat(mci, EX_NOTSTICKY, "5.5.2", SmtpReplyBuffer);
		return EX_DATAERR;
	}
	else if (r == 553)
	{
		/* mailbox name not allowed */
		mci_setstat(mci, EX_NOTSTICKY, "5.1.3", SmtpReplyBuffer);
		return EX_DATAERR;
	}
d390 3
a392 10
		/* exceeded storage allocation */
		mci_setstat(mci, EX_NOTSTICKY, "5.3.4", SmtpReplyBuffer);
		if (bitset(MCIF_SIZE, mci->mci_flags))
			e->e_flags |= EF_NO_BODY_RETN;
		return EX_UNAVAILABLE;
	}
	else if (REPLYTYPE(r) == 5)
	{
		/* unknown error */
		mci_setstat(mci, EX_NOTSTICKY, "5.0.0", SmtpReplyBuffer);
d396 1
d399 2
a400 4
		sm_syslog(LOG_CRIT, e->e_id,
			"%.100s: SMTP MAIL protocol error: %s",
			CurHostName,
			shortenstring(SmtpReplyBuffer, 403));
d402 1
a404 1
	mci_setstat(mci, EX_PROTOCOL, "5.5.1", SmtpReplyBuffer);
d406 1
a424 1
int
a431 2
	int l;
	char optbuf[MAXLINE];
d433 1
a433 46
	strcpy(optbuf, "");
	l = sizeof optbuf - 1;
	if (bitset(MCIF_DSN, mci->mci_flags))
	{
		/* NOTIFY= parameter */
		if (bitset(QHASNOTIFY, to->q_flags) &&
		    bitset(QPRIMARY, to->q_flags) &&
		    !bitnset(M_LOCALMAILER, m->m_flags))
		{
			bool firstone = TRUE;

			strcat(optbuf, " NOTIFY=");
			if (bitset(QPINGONSUCCESS, to->q_flags))
			{
				strcat(optbuf, "SUCCESS");
				firstone = FALSE;
			}
			if (bitset(QPINGONFAILURE, to->q_flags))
			{
				if (!firstone)
					strcat(optbuf, ",");
				strcat(optbuf, "FAILURE");
				firstone = FALSE;
			}
			if (bitset(QPINGONDELAY, to->q_flags))
			{
				if (!firstone)
					strcat(optbuf, ",");
				strcat(optbuf, "DELAY");
				firstone = FALSE;
			}
			if (firstone)
				strcat(optbuf, "NEVER");
			l -= strlen(optbuf);
		}

		/* ORCPT= parameter */
		if (to->q_orcpt != NULL && strlen(to->q_orcpt) + 7 < l)
		{
			strcat(optbuf, " ORCPT=");
			strcat(optbuf, to->q_orcpt);
			l -= strlen(optbuf);
		}
	}

	smtpmessage("RCPT To:<%s>%s", m, mci, to->q_user, optbuf);
a437 3
	to->q_rstatus = newstr(SmtpReplyBuffer);
	to->q_status = smtptodsn(r);
	to->q_statmta = mci->mci_host;
d439 1
a439 1
		return EX_TEMPFAIL;
d441 5
a445 20
		return EX_OK;
	else if (r == 550)
	{
		to->q_status = "5.1.1";
		return EX_NOUSER;
	}
	else if (r == 551)
	{
		to->q_status = "5.1.6";
		return EX_NOUSER;
	}
	else if (r == 553)
	{
		to->q_status = "5.1.3";
		return EX_NOUSER;
	}
	else if (REPLYTYPE(r) == 5)
	{
		return EX_UNAVAILABLE;
	}
d447 1
d450 2
a451 4
		sm_syslog(LOG_CRIT, e->e_id,
			"%.100s: SMTP RCPT protocol error: %s",
			CurHostName,
			shortenstring(SmtpReplyBuffer, 403));
d453 1
d455 1
a455 2
	mci_setstat(mci, EX_PROTOCOL, "5.5.1", SmtpReplyBuffer);
	return EX_PROTOCOL;
a461 1
**		mci -- the mailer connection information.
d472 1
a472 1
static void	datatimeout __P((void));
a473 1
int
d475 1
a475 1
	MAILER *m;
a480 2
	int rstat;
	int xstat;
d499 1
a499 1
		return EX_TEMPFAIL;
d501 1
a501 1
	else if (REPLYTYPE(r) == 5)
d504 1
a504 1
		return EX_UNAVAILABLE;
d508 1
d511 2
a512 4
			sm_syslog(LOG_CRIT, e->e_id,
				"%.100s: SMTP DATA-1 protocol error: %s",
				CurHostName,
				shortenstring(SmtpReplyBuffer, 403));
d514 1
a515 1
		mci_setstat(mci, EX_PROTOCOL, "5.5.1", SmtpReplyBuffer);
d528 1
d530 1
a530 2
		mci_setstat(mci, EX_TEMPFAIL, "4.4.2", NULL);
		syserr("451 timeout writing message to %s", CurHostName);
d536 3
a538 3
	if (timeout < (time_t) 600)
		timeout = (time_t) 600;
	timeout += e->e_nrcpts * 300;
d541 3
a543 5
	/*
	**  Output the actual message.
	*/

	(*e->e_puthdr)(mci, e->e_header, e);
a545 4
	/*
	**  Cleanup after sending message.
	*/

d552 1
a553 1
		mci_setstat(mci, EX_IOERR, "4.4.2", NULL);
d561 1
a561 1
		fprintf(TrafficLogFile, "%05d >>> .\n", (int) getpid());
d566 1
a566 1
	SmtpPhase = mci->mci_phase = "client DATA status";
a567 2
	if (bitnset(M_LMTP, m->m_flags))
		return EX_OK;
d572 1
a572 1
		return EX_TEMPFAIL;
a574 16
	xstat = EX_NOTSTICKY;
	if (r == 452)
		rstat = EX_TEMPFAIL;
	else if (REPLYTYPE(r) == 4)
		rstat = xstat = EX_TEMPFAIL;
	else if (REPLYCLASS(r) != 5)
		rstat = xstat = EX_PROTOCOL;
	else if (REPLYTYPE(r) == 2)
		rstat = xstat = EX_OK;
	else if (REPLYTYPE(r) == 5)
		rstat = EX_UNAVAILABLE;
	else
		rstat = EX_PROTOCOL;
	mci_setstat(mci, xstat, smtptodsn(r), SmtpReplyBuffer);
	if (e->e_statmsg != NULL)
		free(e->e_statmsg);
d576 7
a582 2
	if (rstat != EX_PROTOCOL)
		return rstat;
d585 2
a586 4
		sm_syslog(LOG_CRIT, e->e_id,
			"%.100s: SMTP DATA-2 protocol error: %s",
			CurHostName,
			shortenstring(SmtpReplyBuffer, 403));
d588 2
a589 1
	return rstat;
d593 1
a593 1
static void
a598 51
**  SMTPGETSTAT -- get status code from DATA in LMTP
**
**	Parameters:
**		m -- the mailer to which we are sending the message.
**		mci -- the mailer connection structure.
**		e -- the current envelope.
**
**	Returns:
**		The exit status corresponding to the reply code.
*/

int
smtpgetstat(m, mci, e)
	MAILER *m;
	MCI *mci;
	ENVELOPE *e;
{
	int r;
	int stat;

	/* check for the results of the transaction */
	r = reply(m, mci, e, TimeOuts.to_datafinal, NULL);
	if (r < 0)
	{
		smtpquit(m, mci, e);
		return EX_TEMPFAIL;
	}
	if (e->e_statmsg != NULL)
		free(e->e_statmsg);
	e->e_statmsg = newstr(&SmtpReplyBuffer[4]);
	if (REPLYTYPE(r) == 4)
		stat = EX_TEMPFAIL;
	else if (REPLYCLASS(r) != 5)
		stat = EX_PROTOCOL;
	else if (REPLYTYPE(r) == 2)
		stat = EX_OK;
	else if (REPLYTYPE(r) == 5)
		stat = EX_UNAVAILABLE;
	else
		stat = EX_PROTOCOL;
	mci_setstat(mci, stat, smtptodsn(r), SmtpReplyBuffer);
	if (LogLevel > 1 && stat == EX_PROTOCOL)
	{
		sm_syslog(LOG_CRIT, e->e_id,
			"%.100s: SMTP DATA-3 protocol error: %s",
			CurHostName,
			shortenstring(SmtpReplyBuffer, 403));
	}
	return stat;
}
/*
a602 2
**		mci -- the mailer connection information.
**		e -- the current envelope.
a610 1
void
d635 2
d638 1
a649 1
void
a672 1
int
d696 3
a698 2
**		pfunc -- processing function called on each line of response.
**			If null, no special processing is done.
a706 1
int
d729 1
a729 2
	bufp = SmtpReplyBuffer;
	for (;;)
d732 1
a732 1
		extern time_t curtime __P((void));
d752 1
a752 1
			extern char MsgBuf[];
d763 1
d766 1
a766 2
			usrerr("451 reply: read error from %s", CurHostName);
			mci_setstat(mci, EX_TEMPFAIL, "4.4.2", MsgBuf);
d773 1
a773 1
#if XDEBUG
a776 2
				int wbufleft = sizeof wbuf;

d779 2
a780 7
					int plen;

					snprintf(p, wbufleft, "%s... ",
						shortenstring(e->e_to, MAXSHORTSTR));
					plen = strlen(p);
					p += plen;
					wbufleft -= plen;
d782 2
a783 2
				snprintf(p, wbufleft, "reply(%.100s) during %s",
					CurHostName, SmtpPhase);
a816 7
		/* ignore improperly formated input */
		if (!(isascii(bufp[0]) && isdigit(bufp[0])) ||
		    !(isascii(bufp[1]) && isdigit(bufp[1])) ||
		    !(isascii(bufp[2]) && isdigit(bufp[2])) ||
		    !(bufp[3] == ' ' || bufp[3] == '-' || bufp[3] == '\0'))
			continue;

d818 2
a819 2
		if (pfunc != NULL)
			(*pfunc)(bufp, firstline, m, mci, e);
d823 8
d835 1
a835 5
		if (r < 100)
			continue;

		/* if no continuation lines, return this line */
		if (bufp[3] != '-')
a836 3

		/* first line of real reply -- ignore rest */
		bufp = junkbuf;
d845 2
a846 3
	if (SmtpReplyBuffer[0] == '4' &&
	    (bitnset(M_LMTP, m->m_flags) || SmtpError[0] == '\0'))
		snprintf(SmtpError, sizeof SmtpError, "%s", SmtpReplyBuffer);
a873 1
void
d887 1
a887 1
	(void) vsnprintf(SmtpMsgBuffer, sizeof SmtpMsgBuffer, f, ap);
d893 1
a893 2
		fprintf(TrafficLogFile, "%05d >>> %s\n",
			(int) getpid(), SmtpMsgBuffer);
@

