head	1.10;
access;
symbols
	OPENBSD_2_6:1.9.0.4
	OPENBSD_2_6_BASE:1.9
	OPENBSD_2_5:1.9.0.2
	OPENBSD_2_5_BASE:1.9
	OPENBSD_2_4:1.8.0.2
	OPENBSD_2_4_BASE:1.8
	sendmail_8_9_1:1.1.1.2
	UCB:1.1.1
	OPENBSD_2_3:1.7.0.2
	OPENBSD_2_3_BASE:1.7
	OPENBSD_2_2:1.6.0.2
	OPENBSD_2_2_BASE:1.6
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.10
date	2000.04.18.04.57.27;	author millert;	state dead;
branches;
next	1.9;

1.9
date	99.01.01.20.34.02;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	98.07.12.19.45.17;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	97.11.09.04.05.46;	author gene;	state Exp;
branches;
next	1.6;

1.6
date	97.08.04.02.18.00;	author downsj;	state Exp;
branches;
next	1.5;

1.5
date	97.07.15.07.24.16;	author downsj;	state Exp;
branches;
next	1.4;

1.4
date	97.01.22.01.07.24;	author downsj;	state Exp;
branches;
next	1.3;

1.3
date	96.12.14.21.17.41;	author downsj;	state Exp;
branches;
next	1.2;

1.2
date	96.01.29.01.44.36;	author dm;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.48.20;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.48.20;	author deraadt;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	98.07.12.17.10.41;	author millert;	state Exp;
branches;
next	;


desc
@@


1.10
log
@remove sendmail 8.9.3
@
text
@/*
 * Copyright (c) 1998 Sendmail, Inc.  All rights reserved.
 * Copyright (c) 1983, 1995-1997 Eric P. Allman.  All rights reserved.
 * Copyright (c) 1988, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * By using this file, you agree to the terms and conditions set
 * forth in the LICENSE file which can be found at the top level of
 * the sendmail distribution.
 *
 */

# include "sendmail.h"

#ifndef lint
#if SMTP
static char sccsid[] = "@@(#)srvrsmtp.c	8.187 (Berkeley) 10/23/1998 (with SMTP)";
#else
static char sccsid[] = "@@(#)srvrsmtp.c	8.187 (Berkeley) 10/23/1998 (without SMTP)";
#endif
#endif /* not lint */

# include <errno.h>

# if SMTP

/*
**  SMTP -- run the SMTP protocol.
**
**	Parameters:
**		nullserver -- if non-NULL, rejection message for
**			all SMTP commands.
**		e -- the envelope.
**
**	Returns:
**		never.
**
**	Side Effects:
**		Reads commands from the input channel and processes
**			them.
*/

struct cmd
{
	char	*cmdname;	/* command name */
	int	cmdcode;	/* internal code, see below */
};

/* values for cmdcode */
# define CMDERROR	0	/* bad command */
# define CMDMAIL	1	/* mail -- designate sender */
# define CMDRCPT	2	/* rcpt -- designate recipient */
# define CMDDATA	3	/* data -- send message text */
# define CMDRSET	4	/* rset -- reset state */
# define CMDVRFY	5	/* vrfy -- verify address */
# define CMDEXPN	6	/* expn -- expand address */
# define CMDNOOP	7	/* noop -- do nothing */
# define CMDQUIT	8	/* quit -- close connection and die */
# define CMDHELO	9	/* helo -- be polite */
# define CMDHELP	10	/* help -- give usage info */
# define CMDEHLO	11	/* ehlo -- extended helo (RFC 1425) */
# define CMDETRN	12	/* etrn -- flush queue */
/* non-standard commands */
# define CMDONEX	16	/* onex -- sending one transaction only */
# define CMDVERB	17	/* verb -- go into verbose mode */
# define CMDXUSR	18	/* xusr -- initial (user) submission */
/* use this to catch and log "door handle" attempts on your system */
# define CMDLOGBOGUS	23	/* bogus command that should be logged */
/* debugging-only commands, only enabled if SMTPDEBUG is defined */
# define CMDDBGQSHOW	24	/* showq -- show send queue */
# define CMDDBGDEBUG	25	/* debug -- set debug mode */

static struct cmd	CmdTab[] =
{
	{ "mail",	CMDMAIL		},
	{ "rcpt",	CMDRCPT		},
	{ "data",	CMDDATA		},
	{ "rset",	CMDRSET		},
	{ "vrfy",	CMDVRFY		},
	{ "expn",	CMDEXPN		},
	{ "help",	CMDHELP		},
	{ "noop",	CMDNOOP		},
	{ "quit",	CMDQUIT		},
	{ "helo",	CMDHELO		},
	{ "ehlo",	CMDEHLO		},
	{ "etrn",	CMDETRN		},
	{ "verb",	CMDVERB		},
	{ "onex",	CMDONEX		},
	{ "xusr",	CMDXUSR		},
    /* remaining commands are here only to trap and log attempts to use them */
	{ "showq",	CMDDBGQSHOW	},
	{ "debug",	CMDDBGDEBUG	},
	{ "wiz",	CMDLOGBOGUS	},

	{ NULL,		CMDERROR	}
};

bool	OneXact = FALSE;		/* one xaction only this run */
char	*CurSmtpClient;			/* who's at the other end of channel */

static char	*skipword __P((char *volatile, char *));


#define MAXBADCOMMANDS	25	/* maximum number of bad commands */
#define MAXNOOPCOMMANDS	20	/* max "noise" commands before slowdown */
#define MAXHELOCOMMANDS	3	/* max HELO/EHLO commands before slowdown */
#define MAXVRFYCOMMANDS	6	/* max VRFY/EXPN commands before slowdown */
#define MAXETRNCOMMANDS	8	/* max ETRN commands before slowdown */

void
smtp(nullserver, e)
	char *nullserver;
	register ENVELOPE *volatile e;
{
	register char *volatile p;
	register struct cmd *c;
	char *cmd;
	auto ADDRESS *vrfyqueue;
	ADDRESS *a;
	volatile bool gotmail;		/* mail command received */
	volatile bool gothello;		/* helo command received */
	bool vrfy;			/* set if this is a vrfy command */
	char *volatile protocol;	/* sending protocol */
	char *volatile sendinghost;	/* sending hostname */
	char *volatile peerhostname;	/* name of SMTP peer or "localhost" */
	auto char *delimptr;
	char *id;
	volatile int nrcpts = 0;	/* number of RCPT commands */
	bool doublequeue;
	volatile bool discard;
	volatile int badcommands = 0;	/* count of bad commands */
	volatile int nverifies = 0;	/* count of VRFY/EXPN commands */
	volatile int n_etrn = 0;	/* count of ETRN commands */
	volatile int n_noop = 0;	/* count of NOOP/VERB/ONEX etc cmds */
	volatile int n_helo = 0;	/* count of HELO/EHLO commands */
	bool ok;
	volatile int lognullconnection = TRUE;
	register char *q;
	QUEUE_CHAR *new;
	char inp[MAXLINE];
	char cmdbuf[MAXLINE];
	extern ENVELOPE BlankEnvelope;
	extern void help __P((char *));
	extern void settime __P((ENVELOPE *));
	extern bool enoughdiskspace __P((long));
	extern int runinchild __P((char *, ENVELOPE *));
	extern void checksmtpattack __P((volatile int *, int, char *, ENVELOPE *));

	if (fileno(OutChannel) != fileno(stdout))
	{
		/* arrange for debugging output to go to remote host */
		(void) dup2(fileno(OutChannel), fileno(stdout));
	}
	settime(e);
	peerhostname = RealHostName;
	if (peerhostname == NULL)
		peerhostname = "localhost";
	CurHostName = peerhostname;
	CurSmtpClient = macvalue('_', e);
	if (CurSmtpClient == NULL)
		CurSmtpClient = CurHostName;

	/* check_relay may have set discard bit, save for later */
	discard = bitset(EF_DISCARD, e->e_flags);

	sm_setproctitle(TRUE, "server %s startup", CurSmtpClient);
#if DAEMON
	if (LogLevel > 11)
	{
		/* log connection information */
		sm_syslog(LOG_INFO, NOQID,
			"SMTP connect from %.100s (%.100s)",
			CurSmtpClient, anynet_ntoa(&RealHostAddr));
	}
#endif

	/* output the first line, inserting "ESMTP" as second word */
	expand(SmtpGreeting, inp, sizeof inp, e);
	p = strchr(inp, '\n');
	if (p != NULL)
		*p++ = '\0';
	id = strchr(inp, ' ');
	if (id == NULL)
		id = &inp[strlen(inp)];
	cmd = p == NULL ? "220 %.*s ESMTP%s" : "220-%.*s ESMTP%s";
	message(cmd, id - inp, inp, id);

	/* output remaining lines */
	while ((id = p) != NULL && (p = strchr(id, '\n')) != NULL)
	{
		*p++ = '\0';
		if (isascii(*id) && isspace(*id))
			id++;
		message("220-%s", id);
	}
	if (id != NULL)
	{
		if (isascii(*id) && isspace(*id))
			id++;
		message("220 %s", id);
	}

	protocol = NULL;
	sendinghost = macvalue('s', e);
	gothello = FALSE;
	gotmail = FALSE;
	for (;;)
	{
		/* arrange for backout */
		(void) setjmp(TopFrame);
		QuickAbort = FALSE;
		HoldErrs = FALSE;
		SuprErrs = FALSE;
		LogUsrErrs = FALSE;
		OnlyOneError = TRUE;
		e->e_flags &= ~(EF_VRFYONLY|EF_GLOBALERRS);

		/* setup for the read */
		e->e_to = NULL;
		Errors = 0;
		(void) fflush(stdout);

		/* read the input line */
		SmtpPhase = "server cmd read";
		sm_setproctitle(TRUE, "server %s cmd read", CurSmtpClient);
		p = sfgets(inp, sizeof inp, InChannel, TimeOuts.to_nextcommand,
				SmtpPhase);

		/* handle errors */
		if (p == NULL)
		{
			/* end of file, just die */
			disconnect(1, e);
			message("421 %s Lost input channel from %s",
				MyHostName, CurSmtpClient);
			if (LogLevel > (gotmail ? 1 : 19))
				sm_syslog(LOG_NOTICE, e->e_id,
					"lost input channel from %.100s",
					CurSmtpClient);
			if (lognullconnection && LogLevel > 5)
				sm_syslog(LOG_INFO, NULL,
				"Null connection from %.100s",
				CurSmtpClient);

			/*
			**  If have not accepted mail (DATA), do not bounce
			**  bad addresses back to sender.
			*/
			if (bitset(EF_CLRQUEUE, e->e_flags))
				e->e_sendqueue = NULL;

			if (InChild)
				ExitStat = EX_QUIT;
			finis(TRUE, ExitStat);
		}

		/* clean up end of line */
		fixcrlf(inp, TRUE);

		/* echo command to transcript */
		if (e->e_xfp != NULL)
			fprintf(e->e_xfp, "<<< %s\n", inp);

		if (LogLevel >= 15)
			sm_syslog(LOG_INFO, e->e_id,
				"<-- %s",
				inp);

		if (e->e_id == NULL)
			sm_setproctitle(TRUE, "%s: %.80s", CurSmtpClient, inp);
		else
			sm_setproctitle(TRUE, "%s %s: %.80s", e->e_id, CurSmtpClient, inp);

		/* break off command */
		for (p = inp; isascii(*p) && isspace(*p); p++)
			continue;
		cmd = cmdbuf;
		while (*p != '\0' &&
		       !(isascii(*p) && isspace(*p)) &&
		       cmd < &cmdbuf[sizeof cmdbuf - 2])
			*cmd++ = *p++;
		*cmd = '\0';

		/* throw away leading whitespace */
		while (isascii(*p) && isspace(*p))
			p++;

		/* decode command */
		for (c = CmdTab; c->cmdname != NULL; c++)
		{
			if (!strcasecmp(c->cmdname, cmdbuf))
				break;
		}

		/* reset errors */
		errno = 0;

		/*
		**  Process command.
		**
		**	If we are running as a null server, return 550
		**	to everything.
		*/

		if (nullserver != NULL)
		{
			switch (c->cmdcode)
			{
			  case CMDQUIT:
			  case CMDHELO:
			  case CMDEHLO:
			  case CMDNOOP:
				/* process normally */
				break;

			  default:
				if (++badcommands > MAXBADCOMMANDS)
					sleep(1);
				usrerr("550 %s", nullserver);
				continue;
			}
		}

		/* non-null server */
		switch (c->cmdcode)
		{
		  case CMDMAIL:
		  case CMDEXPN:
		  case CMDVRFY:
		  case CMDETRN:
			lognullconnection = FALSE;
		}

		switch (c->cmdcode)
		{
		  case CMDHELO:		/* hello -- introduce yourself */
		  case CMDEHLO:		/* extended hello */
			if (c->cmdcode == CMDEHLO)
			{
				protocol = "ESMTP";
				SmtpPhase = "server EHLO";
			}
			else
			{
				protocol = "SMTP";
				SmtpPhase = "server HELO";
			}

			/* avoid denial-of-service */
			checksmtpattack(&n_helo, MAXHELOCOMMANDS, "HELO/EHLO", e);

			/* check for duplicate HELO/EHLO per RFC 1651 4.2 */
			if (gothello)
			{
				usrerr("503 %s Duplicate HELO/EHLO",
					MyHostName);
				break;
			}

			/* check for valid domain name (re 1123 5.2.5) */
			if (*p == '\0' && !AllowBogusHELO)
			{
				usrerr("501 %s requires domain address",
					cmdbuf);
				break;
			}

			/* check for long domain name (hides Received: info) */
			if (strlen(p) > MAXNAME)
			{
				usrerr("501 Invalid domain name");
				break;
			}

			for (q = p; *q != '\0'; q++)
			{
				if (!isascii(*q))
					break;
				if (isalnum(*q))
					continue;
				if (isspace(*q))
				{
					*q = '\0';
					break;
				}
				if (strchr("[].-_#", *q) == NULL)
					break;
			}
			if (*q == '\0')
			{
				q = "pleased to meet you";
				sendinghost = newstr(p);
			}
			else if (!AllowBogusHELO)
			{
				usrerr("501 Invalid domain name");
				break;
			}
			else
			{
				q = "accepting invalid domain name";
			}

			gothello = TRUE;
			
			/* print HELO response message */
			if (c->cmdcode != CMDEHLO || nullserver != NULL)
			{
				message("250 %s Hello %s, %s",
					MyHostName, CurSmtpClient, q);
				break;
			}

			message("250-%s Hello %s, %s",
				MyHostName, CurSmtpClient, q);

			/* print EHLO features list */
			if (!bitset(PRIV_NOEXPN, PrivacyFlags))
			{
				message("250-EXPN");
				if (!bitset(PRIV_NOVERB, PrivacyFlags))
					message("250-VERB");
			}
#if MIME8TO7
			message("250-8BITMIME");
#endif
			if (MaxMessageSize > 0)
				message("250-SIZE %ld", MaxMessageSize);
			else
				message("250-SIZE");
#if DSN
			if (SendMIMEErrors)
				message("250-DSN");
#endif
			message("250-ONEX");
			if (!bitset(PRIV_NOETRN, PrivacyFlags))
				message("250-ETRN");
			message("250-XUSR");
			message("250 HELP");
			break;

		  case CMDMAIL:		/* mail -- designate sender */
			SmtpPhase = "server MAIL";

			/* check for validity of this command */
			if (!gothello && bitset(PRIV_NEEDMAILHELO, PrivacyFlags))
			{
				usrerr("503 Polite people say HELO first");
				break;
			}
			if (gotmail)
			{
				usrerr("503 Sender already specified");
				break;
			}
			if (InChild)
			{
				errno = 0;
				syserr("503 Nested MAIL command: MAIL %s", p);
				finis(TRUE, ExitStat);
			}

			/* make sure we know who the sending host is */
			if (sendinghost == NULL)
				sendinghost = peerhostname;

			p = skipword(p, "from");
			if (p == NULL)
				break;

			/* fork a subprocess to process this command */
			if (runinchild("SMTP-MAIL", e) > 0)
				break;
			if (Errors > 0)
				goto undo_subproc_no_pm;
			if (!gothello)
			{
				auth_warning(e,
					"%s didn't use HELO protocol",
					CurSmtpClient);
			}
#ifdef PICKY_HELO_CHECK
			if (strcasecmp(sendinghost, peerhostname) != 0 &&
			    (strcasecmp(peerhostname, "localhost") != 0 ||
			     strcasecmp(sendinghost, MyHostName) != 0))
			{
				auth_warning(e, "Host %s claimed to be %s",
					CurSmtpClient, sendinghost);
			}
#endif

			if (protocol == NULL)
				protocol = "SMTP";
			define('r', protocol, e);
			define('s', sendinghost, e);
			initsys(e);
			if (Errors > 0)
				goto undo_subproc_no_pm;
			nrcpts = 0;
			e->e_flags |= EF_LOGSENDER|EF_CLRQUEUE;
			sm_setproctitle(TRUE, "%s %s: %.80s", e->e_id, CurSmtpClient, inp);

			/* child -- go do the processing */
			if (setjmp(TopFrame) > 0)
			{
				/* this failed -- undo work */
 undo_subproc_no_pm:
				e->e_flags &= ~EF_PM_NOTIFY;
 undo_subproc:
				if (InChild)
				{
					QuickAbort = FALSE;
					SuprErrs = TRUE;
					e->e_flags &= ~EF_FATALERRS;
					finis(TRUE, ExitStat);
				}
				break;
			}
			QuickAbort = TRUE;

			/* must parse sender first */
			delimptr = NULL;
			setsender(p, e, &delimptr, ' ', FALSE);
			if (delimptr != NULL && *delimptr != '\0')
				*delimptr++ = '\0';
			if (Errors > 0)
				goto undo_subproc_no_pm;

			/* do config file checking of the sender */
			if (rscheck("check_mail", p, NULL, e) != EX_OK ||
			    Errors > 0)
				goto undo_subproc_no_pm;

			/* check for possible spoofing */
			if (RealUid != 0 && OpMode == MD_SMTP &&
			    !wordinclass(RealUserName, 't') &&
			    !bitnset(M_LOCALMAILER, e->e_from.q_mailer->m_flags) &&
			    strcmp(e->e_from.q_user, RealUserName) != 0)
			{
				auth_warning(e, "%s owned process doing -bs",
					RealUserName);
			}

			/* now parse ESMTP arguments */
			e->e_msgsize = 0;
			p = delimptr;
			while (p != NULL && *p != '\0')
			{
				char *kp;
				char *vp = NULL;
				extern void mail_esmtp_args __P((char *, char *, ENVELOPE *));

				/* locate the beginning of the keyword */
				while (isascii(*p) && isspace(*p))
					p++;
				if (*p == '\0')
					break;
				kp = p;

				/* skip to the value portion */
				while ((isascii(*p) && isalnum(*p)) || *p == '-')
					p++;
				if (*p == '=')
				{
					*p++ = '\0';
					vp = p;

					/* skip to the end of the value */
					while (*p != '\0' && *p != ' ' &&
					       !(isascii(*p) && iscntrl(*p)) &&
					       *p != '=')
						p++;
				}

				if (*p != '\0')
					*p++ = '\0';

				if (tTd(19, 1))
					printf("MAIL: got arg %s=\"%s\"\n", kp,
						vp == NULL ? "<null>" : vp);

				mail_esmtp_args(kp, vp, e);
				if (Errors > 0)
					goto undo_subproc_no_pm;
			}
			if (Errors > 0)
				goto undo_subproc_no_pm;

			if (MaxMessageSize > 0 && e->e_msgsize > MaxMessageSize)
			{
				usrerr("552 Message size exceeds fixed maximum message size (%ld)",
					MaxMessageSize);
				goto undo_subproc_no_pm;
			}
				
			if (!enoughdiskspace(e->e_msgsize))
			{
				usrerr("452 Insufficient disk space; try again later");
				goto undo_subproc_no_pm;
			}
			if (Errors > 0)
				goto undo_subproc_no_pm;
			message("250 Sender ok");
			gotmail = TRUE;
			break;

		  case CMDRCPT:		/* rcpt -- designate recipient */
			if (!gotmail)
			{
				usrerr("503 Need MAIL before RCPT");
				break;
			}
			SmtpPhase = "server RCPT";
			if (setjmp(TopFrame) > 0)
			{
				e->e_flags &= ~EF_FATALERRS;
				break;
			}
			QuickAbort = TRUE;
			LogUsrErrs = TRUE;

			/* limit flooding of our machine */
			if (MaxRcptPerMsg > 0 && nrcpts >= MaxRcptPerMsg)
			{
				usrerr("452 Too many recipients");
				break;
			}

			if (e->e_sendmode != SM_DELIVER)
				e->e_flags |= EF_VRFYONLY;

			p = skipword(p, "to");
			if (p == NULL)
				break;
			a = parseaddr(p, NULLADDR, RF_COPYALL, ' ', &delimptr, e);
			if (Errors > 0)
				break;
			if (a == NULL)
			{
				usrerr("501 Missing recipient");
				break;
			}

			if (delimptr != NULL && *delimptr != '\0')
				*delimptr++ = '\0';

			/* do config file checking of the recipient */
			if (rscheck("check_rcpt", p, NULL, e) != EX_OK ||
			    Errors > 0)
				break;

			/* now parse ESMTP arguments */
			p = delimptr;
			while (p != NULL && *p != '\0')
			{
				char *kp;
				char *vp = NULL;
				extern void rcpt_esmtp_args __P((ADDRESS *, char *, char *, ENVELOPE *));

				/* locate the beginning of the keyword */
				while (isascii(*p) && isspace(*p))
					p++;
				if (*p == '\0')
					break;
				kp = p;

				/* skip to the value portion */
				while ((isascii(*p) && isalnum(*p)) || *p == '-')
					p++;
				if (*p == '=')
				{
					*p++ = '\0';
					vp = p;

					/* skip to the end of the value */
					while (*p != '\0' && *p != ' ' &&
					       !(isascii(*p) && iscntrl(*p)) &&
					       *p != '=')
						p++;
				}

				if (*p != '\0')
					*p++ = '\0';

				if (tTd(19, 1))
					printf("RCPT: got arg %s=\"%s\"\n", kp,
						vp == NULL ? "<null>" : vp);

				rcpt_esmtp_args(a, kp, vp, e);
				if (Errors > 0)
					break;
			}
			if (Errors > 0)
				break;

			/* save in recipient list after ESMTP mods */
			a = recipient(a, &e->e_sendqueue, 0, e);
			if (Errors > 0)
				break;

			/* no errors during parsing, but might be a duplicate */
			e->e_to = a->q_paddr;
			if (!bitset(QBADADDR, a->q_flags))
			{
				message("250 Recipient ok%s",
					bitset(QQUEUEUP, a->q_flags) ?
						" (will queue)" : "");
				nrcpts++;
			}
			else
			{
				/* punt -- should keep message in ADDRESS.... */
				usrerr("550 Addressee unknown");
			}
			break;

		  case CMDDATA:		/* data -- text of mail */
			SmtpPhase = "server DATA";
			if (!gotmail)
			{
				usrerr("503 Need MAIL command");
				break;
			}
			else if (nrcpts <= 0)
			{
				usrerr("503 Need RCPT (recipient)");
				break;
			}

			/* put back discard bit */
			if (discard)
				e->e_flags |= EF_DISCARD;

			/* check to see if we need to re-expand aliases */
			/* also reset QBADADDR on already-diagnosted addrs */
			doublequeue = FALSE;
			for (a = e->e_sendqueue; a != NULL; a = a->q_next)
			{
				if (bitset(QVERIFIED, a->q_flags) &&
				    !bitset(EF_DISCARD, e->e_flags))
				{
					/* need to re-expand aliases */
					doublequeue = TRUE;
				}
				if (bitset(QBADADDR, a->q_flags))
				{
					/* make this "go away" */
					a->q_flags |= QDONTSEND;
					a->q_flags &= ~QBADADDR;
				}
			}

			/* collect the text of the message */
			SmtpPhase = "collect";
			buffer_errors();
			collect(InChannel, TRUE, NULL, e);
			if (Errors > 0)
			{
				flush_errors(TRUE);
				buffer_errors();
				goto abortmessage;
			}

			/* make sure we actually do delivery */
			e->e_flags &= ~EF_CLRQUEUE;

			/* from now on, we have to operate silently */
			buffer_errors();
			e->e_errormode = EM_MAIL;

			/*
			**  Arrange to send to everyone.
			**	If sending to multiple people, mail back
			**		errors rather than reporting directly.
			**	In any case, don't mail back errors for
			**		anything that has happened up to
			**		now (the other end will do this).
			**	Truncate our transcript -- the mail has gotten
			**		to us successfully, and if we have
			**		to mail this back, it will be easier
			**		on the reader.
			**	Then send to everyone.
			**	Finally give a reply code.  If an error has
			**		already been given, don't mail a
			**		message back.
			**	We goose error returns by clearing error bit.
			*/

			SmtpPhase = "delivery";
			e->e_xfp = freopen(queuename(e, 'x'), "w", e->e_xfp);
			id = e->e_id;

			if (doublequeue)
			{
				/* make sure it is in the queue */
				queueup(e, FALSE);
			}
			else
			{
				/* send to all recipients */
				sendall(e, SM_DEFAULT);
			}
			e->e_to = NULL;

			/* issue success message */
			message("250 %s Message accepted for delivery", id);

			/* if we just queued, poke it */
			if (doublequeue &&
			    e->e_sendmode != SM_QUEUE &&
			    e->e_sendmode != SM_DEFER)
			{
				CurrentLA = getla();

				if (!shouldqueue(e->e_msgpriority, e->e_ctime))
				{
					unlockqueue(e);
					(void) dowork(id, TRUE, TRUE, e);
				}
			}

  abortmessage:
			/* if in a child, pop back to our parent */
			if (InChild)
				finis(TRUE, ExitStat);

			/* clean up a bit */
			gotmail = FALSE;
			dropenvelope(e, TRUE);
			CurEnv = e = newenvelope(e, CurEnv);
			e->e_flags = BlankEnvelope.e_flags;
			break;

		  case CMDRSET:		/* rset -- reset state */
			if (tTd(94, 100))
				message("451 Test failure");
			else
				message("250 Reset state");

			/* arrange to ignore any current send list */
			e->e_sendqueue = NULL;
			e->e_flags |= EF_CLRQUEUE;
			if (InChild)
				finis(TRUE, ExitStat);

			/* clean up a bit */
			gotmail = FALSE;
			SuprErrs = TRUE;
			dropenvelope(e, TRUE);
			CurEnv = e = newenvelope(e, CurEnv);
			break;

		  case CMDVRFY:		/* vrfy -- verify address */
		  case CMDEXPN:		/* expn -- expand address */
			checksmtpattack(&nverifies, MAXVRFYCOMMANDS,
				c->cmdcode == CMDVRFY ? "VRFY" : "EXPN", e);
			vrfy = c->cmdcode == CMDVRFY;
			if (bitset(vrfy ? PRIV_NOVRFY : PRIV_NOEXPN,
						PrivacyFlags))
			{
				if (vrfy)
					message("252 Cannot VRFY user; try RCPT to attempt delivery (or try finger)");
				else
					message("502 Sorry, we do not allow this operation");
				if (LogLevel > 5)
					sm_syslog(LOG_INFO, e->e_id,
						"%.100s: %s [rejected]",
						CurSmtpClient,
						shortenstring(inp, MAXSHORTSTR));
				break;
			}
			else if (!gothello &&
				 bitset(vrfy ? PRIV_NEEDVRFYHELO : PRIV_NEEDEXPNHELO,
						PrivacyFlags))
			{
				usrerr("503 I demand that you introduce yourself first");
				break;
			}
			if (runinchild(vrfy ? "SMTP-VRFY" : "SMTP-EXPN", e) > 0)
				break;
			if (Errors > 0)
				goto undo_subproc;
			if (LogLevel > 5)
				sm_syslog(LOG_INFO, e->e_id,
					"%.100s: %s",
					CurSmtpClient,
					shortenstring(inp, MAXSHORTSTR));
			if (setjmp(TopFrame) > 0)
				goto undo_subproc;
			QuickAbort = TRUE;
			vrfyqueue = NULL;
			if (vrfy)
				e->e_flags |= EF_VRFYONLY;
			while (*p != '\0' && isascii(*p) && isspace(*p))
				p++;
			if (*p == '\0')
			{
				usrerr("501 Argument required");
			}
			else
			{
				(void) sendtolist(p, NULLADDR, &vrfyqueue, 0, e);
			}
			if (Errors > 0)
				goto undo_subproc;
			if (vrfyqueue == NULL)
			{
				usrerr("554 Nothing to %s", vrfy ? "VRFY" : "EXPN");
			}
			while (vrfyqueue != NULL)
			{
				extern void printvrfyaddr __P((ADDRESS *, bool, bool));

				a = vrfyqueue;
				while ((a = a->q_next) != NULL &&
				       bitset(QDONTSEND|QBADADDR, a->q_flags))
					continue;
				if (!bitset(QDONTSEND|QBADADDR, vrfyqueue->q_flags))
					printvrfyaddr(vrfyqueue, a == NULL, vrfy);
				vrfyqueue = vrfyqueue->q_next;
			}
			if (InChild)
				finis(TRUE, ExitStat);
			break;

		  case CMDETRN:		/* etrn -- force queue flush */
			if (bitset(PRIV_NOETRN, PrivacyFlags))
			{
				message("502 Sorry, we do not allow this operation");
				if (LogLevel > 5)
					sm_syslog(LOG_INFO, e->e_id,
						"%.100s: %s [rejected]",
						CurSmtpClient,
						shortenstring(inp, MAXSHORTSTR));
				break;
			}

			if (strlen(p) <= 0)
			{
				usrerr("500 Parameter required");
				break;
			}

			/* crude way to avoid denial-of-service attacks */
			checksmtpattack(&n_etrn, MAXETRNCOMMANDS, "ETRN", e);

			if (LogLevel > 5)
				sm_syslog(LOG_INFO, e->e_id,
					"%.100s: ETRN %s",
					CurSmtpClient,
					shortenstring(p, MAXSHORTSTR));

			id = p;
			if (*id == '@@')
				id++;
			else
				*--id = '@@';
				  
			if ((new = (QUEUE_CHAR *)malloc(sizeof(QUEUE_CHAR))) == NULL)
			{
				syserr("500 ETRN out of memory");
				break;
			}
			new->queue_match = id;
			new->queue_next = NULL;
			QueueLimitRecipient = new;
			ok = runqueue(TRUE, TRUE);
			free(QueueLimitRecipient);
			QueueLimitRecipient = NULL;
			if (ok && Errors == 0)
				message("250 Queuing for node %s started", p);
			break;

		  case CMDHELP:		/* help -- give user info */
			help(p);
			break;

		  case CMDNOOP:		/* noop -- do nothing */
			checksmtpattack(&n_noop, MAXNOOPCOMMANDS, "NOOP", e);
			message("250 OK");
			break;

		  case CMDQUIT:		/* quit -- leave mail */
			message("221 %s closing connection", MyHostName);

doquit:
			/* arrange to ignore any current send list */
			e->e_sendqueue = NULL;

			/* avoid future 050 messages */
			disconnect(1, e);

			if (InChild)
				ExitStat = EX_QUIT;
			if (lognullconnection && LogLevel > 5)
				sm_syslog(LOG_INFO, NULL,
					"Null connection from %.100s",
					CurSmtpClient);
			finis(TRUE, ExitStat);

		  case CMDVERB:		/* set verbose mode */
			if (bitset(PRIV_NOEXPN, PrivacyFlags) ||
			    bitset(PRIV_NOVERB, PrivacyFlags))
			{
				/* this would give out the same info */
				message("502 Verbose unavailable");
				break;
			}
			checksmtpattack(&n_noop, MAXNOOPCOMMANDS, "VERB", e);
			Verbose = 1;
			e->e_sendmode = SM_DELIVER;
			message("250 Verbose mode");
			break;

		  case CMDONEX:		/* doing one transaction only */
			checksmtpattack(&n_noop, MAXNOOPCOMMANDS, "ONEX", e);
			OneXact = TRUE;
			message("250 Only one transaction");
			break;

		  case CMDXUSR:		/* initial (user) submission */
			checksmtpattack(&n_noop, MAXNOOPCOMMANDS, "XUSR", e);
			UserSubmission = TRUE;
			message("250 Initial submission");
			break;

# if SMTPDEBUG
		  case CMDDBGQSHOW:	/* show queues */
			printf("Send Queue=");
			printaddr(e->e_sendqueue, TRUE);
			break;

		  case CMDDBGDEBUG:	/* set debug mode */
			tTsetup(tTdvect, sizeof tTdvect, "0-99.1");
			tTflag(p);
			message("200 Debug set");
			break;

# else /* not SMTPDEBUG */
		  case CMDDBGQSHOW:	/* show queues */
		  case CMDDBGDEBUG:	/* set debug mode */
# endif /* SMTPDEBUG */
		  case CMDLOGBOGUS:	/* bogus command */
			if (LogLevel > 0)
				sm_syslog(LOG_CRIT, e->e_id,
				    "\"%s\" command from %.100s (%.100s)",
				    c->cmdname, CurSmtpClient,
				    anynet_ntoa(&RealHostAddr));
			/* FALL THROUGH */

		  case CMDERROR:	/* unknown command */
			if (++badcommands > MAXBADCOMMANDS)
			{
				message("421 %s Too many bad commands; closing connection",
					MyHostName);
				goto doquit;
			}

			usrerr("500 Command unrecognized: \"%s\"",
				shortenstring(inp, MAXSHORTSTR));
			break;

		  default:
			errno = 0;
			syserr("500 smtp: unknown code %d", c->cmdcode);
			break;
		}
	}
}
/*
**  CHECKSMTPATTACK -- check for denial-of-service attack by repetition
**
**	Parameters:
**		pcounter -- pointer to a counter for this command.
**		maxcount -- maximum value for this counter before we
**			slow down.
**		cname -- command name for logging.
**		e -- the current envelope.
**
**	Returns:
**		none.
**
**	Side Effects:
**		Slows down if we seem to be under attack.
*/

void
checksmtpattack(pcounter, maxcount, cname, e)
	volatile int *pcounter;
	int maxcount;
	char *cname;
	ENVELOPE *e;
{
	if (++(*pcounter) >= maxcount)
	{
		if (*pcounter == maxcount && LogLevel > 5)
		{
			sm_syslog(LOG_INFO, e->e_id,
				"%.100s: %.40s attack?",
			       CurSmtpClient, cname);
		}
		sleep(*pcounter / maxcount);
	}
}
/*
**  SKIPWORD -- skip a fixed word.
**
**	Parameters:
**		p -- place to start looking.
**		w -- word to skip.
**
**	Returns:
**		p following w.
**		NULL on error.
**
**	Side Effects:
**		clobbers the p data area.
*/

static char *
skipword(p, w)
	register char *volatile p;
	char *w;
{
	register char *q;
	char *firstp = p;

	/* find beginning of word */
	while (isascii(*p) && isspace(*p))
		p++;
	q = p;

	/* find end of word */
	while (*p != '\0' && *p != ':' && !(isascii(*p) && isspace(*p)))
		p++;
	while (isascii(*p) && isspace(*p))
		*p++ = '\0';
	if (*p != ':')
	{
	  syntax:
		usrerr("501 Syntax error in parameters scanning \"%s\"",
			shortenstring(firstp, MAXSHORTSTR));
		return (NULL);
	}
	*p++ = '\0';
	while (isascii(*p) && isspace(*p))
		p++;

	if (*p == '\0')
		goto syntax;

	/* see if the input word matches desired word */
	if (strcasecmp(q, w))
		goto syntax;

	return (p);
}
/*
**  MAIL_ESMTP_ARGS -- process ESMTP arguments from MAIL line
**
**	Parameters:
**		kp -- the parameter key.
**		vp -- the value of that parameter.
**		e -- the envelope.
**
**	Returns:
**		none.
*/

void
mail_esmtp_args(kp, vp, e)
	char *kp;
	char *vp;
	ENVELOPE *e;
{
	if (strcasecmp(kp, "size") == 0)
	{
		if (vp == NULL)
		{
			usrerr("501 SIZE requires a value");
			/* NOTREACHED */
		}
# if defined(__STDC__) && !defined(BROKEN_ANSI_LIBRARY)
		e->e_msgsize = strtoul(vp, (char **) NULL, 10);
# else
		e->e_msgsize = strtol(vp, (char **) NULL, 10);
# endif
	}
	else if (strcasecmp(kp, "body") == 0)
	{
		if (vp == NULL)
		{
			usrerr("501 BODY requires a value");
			/* NOTREACHED */
		}
		else if (strcasecmp(vp, "8bitmime") == 0)
		{
			SevenBitInput = FALSE;
		}
		else if (strcasecmp(vp, "7bit") == 0)
		{
			SevenBitInput = TRUE;
		}
		else
		{
			usrerr("501 Unknown BODY type %s",
				vp);
			/* NOTREACHED */
		}
		e->e_bodytype = newstr(vp);
	}
	else if (strcasecmp(kp, "envid") == 0)
	{
		if (vp == NULL)
		{
			usrerr("501 ENVID requires a value");
			/* NOTREACHED */
		}
		if (!xtextok(vp))
		{
			usrerr("501 Syntax error in ENVID parameter value");
			/* NOTREACHED */
		}
		if (e->e_envid != NULL)
		{
			usrerr("501 Duplicate ENVID parameter");
			/* NOTREACHED */
		}
		e->e_envid = newstr(vp);
	}
	else if (strcasecmp(kp, "ret") == 0)
	{
		if (vp == NULL)
		{
			usrerr("501 RET requires a value");
			/* NOTREACHED */
		}
		if (bitset(EF_RET_PARAM, e->e_flags))
		{
			usrerr("501 Duplicate RET parameter");
			/* NOTREACHED */
		}
		e->e_flags |= EF_RET_PARAM;
		if (strcasecmp(vp, "hdrs") == 0)
			e->e_flags |= EF_NO_BODY_RETN;
		else if (strcasecmp(vp, "full") != 0)
		{
			usrerr("501 Bad argument \"%s\" to RET", vp);
			/* NOTREACHED */
		}
	}
	else
	{
		usrerr("501 %s parameter unrecognized", kp);
		/* NOTREACHED */
	}
}
/*
**  RCPT_ESMTP_ARGS -- process ESMTP arguments from RCPT line
**
**	Parameters:
**		a -- the address corresponding to the To: parameter.
**		kp -- the parameter key.
**		vp -- the value of that parameter.
**		e -- the envelope.
**
**	Returns:
**		none.
*/

void
rcpt_esmtp_args(a, kp, vp, e)
	ADDRESS *a;
	char *kp;
	char *vp;
	ENVELOPE *e;
{
	if (strcasecmp(kp, "notify") == 0)
	{
		char *p;

		if (vp == NULL)
		{
			usrerr("501 NOTIFY requires a value");
			/* NOTREACHED */
		}
		a->q_flags &= ~(QPINGONSUCCESS|QPINGONFAILURE|QPINGONDELAY);
		a->q_flags |= QHASNOTIFY;
		if (strcasecmp(vp, "never") == 0)
			return;
		for (p = vp; p != NULL; vp = p)
		{
			p = strchr(p, ',');
			if (p != NULL)
				*p++ = '\0';
			if (strcasecmp(vp, "success") == 0)
				a->q_flags |= QPINGONSUCCESS;
			else if (strcasecmp(vp, "failure") == 0)
				a->q_flags |= QPINGONFAILURE;
			else if (strcasecmp(vp, "delay") == 0)
				a->q_flags |= QPINGONDELAY;
			else
			{
				usrerr("501 Bad argument \"%s\"  to NOTIFY",
					vp);
				/* NOTREACHED */
			}
		}
	}
	else if (strcasecmp(kp, "orcpt") == 0)
	{
		if (vp == NULL)
		{
			usrerr("501 ORCPT requires a value");
			/* NOTREACHED */
		}
		if (strchr(vp, ';') == NULL || !xtextok(vp))
		{
			usrerr("501 Syntax error in ORCPT parameter value");
			/* NOTREACHED */
		}
		if (a->q_orcpt != NULL)
		{
			usrerr("501 Duplicate ORCPT parameter");
			/* NOTREACHED */
		}
		a->q_orcpt = newstr(vp);
	}
	else
	{
		usrerr("501 %s parameter unrecognized", kp);
		/* NOTREACHED */
	}
}
/*
**  PRINTVRFYADDR -- print an entry in the verify queue
**
**	Parameters:
**		a -- the address to print
**		last -- set if this is the last one.
**		vrfy -- set if this is a VRFY command.
**
**	Returns:
**		none.
**
**	Side Effects:
**		Prints the appropriate 250 codes.
*/

void
printvrfyaddr(a, last, vrfy)
	register ADDRESS *a;
	bool last;
	bool vrfy;
{
	char fmtbuf[20];

	if (vrfy && a->q_mailer != NULL &&
	    !bitnset(M_VRFY250, a->q_mailer->m_flags))
		strcpy(fmtbuf, "252");
	else
		strcpy(fmtbuf, "250");
	fmtbuf[3] = last ? ' ' : '-';

	if (a->q_fullname == NULL)
	{
		if (strchr(a->q_user, '@@') == NULL)
			strcpy(&fmtbuf[4], "<%s@@%s>");
		else
			strcpy(&fmtbuf[4], "<%s>");
		message(fmtbuf, a->q_user, MyHostName);
	}
	else
	{
		if (strchr(a->q_user, '@@') == NULL)
			strcpy(&fmtbuf[4], "%s <%s@@%s>");
		else
			strcpy(&fmtbuf[4], "%s <%s>");
		message(fmtbuf, a->q_fullname, a->q_user, MyHostName);
	}
}
/*
**  RUNINCHILD -- return twice -- once in the child, then in the parent again
**
**	Parameters:
**		label -- a string used in error messages
**
**	Returns:
**		zero in the child
**		one in the parent
**
**	Side Effects:
**		none.
*/

int
runinchild(label, e)
	char *label;
	register ENVELOPE *e;
{
	pid_t childpid;

	if (!OneXact)
	{
		/*
		**  Disable child process reaping, in case ETRN has preceeded
		**  MAIL command, and then fork.
		*/

		(void) blocksignal(SIGCHLD);

		childpid = dofork();
		if (childpid < 0)
		{
			syserr("451 %s: cannot fork", label);
			(void) releasesignal(SIGCHLD);
			return (1);
		}
		if (childpid > 0)
		{
			auto int st;

			/* parent -- wait for child to complete */
			sm_setproctitle(TRUE, "server %s child wait", CurSmtpClient);
			st = waitfor(childpid);
			if (st == -1)
				syserr("451 %s: lost child", label);
			else if (!WIFEXITED(st))
				syserr("451 %s: died on signal %d",
					label, st & 0177);

			/* if we exited on a QUIT command, complete the process */
			if (WEXITSTATUS(st) == EX_QUIT)
			{
				disconnect(1, e);
				finis(TRUE, ExitStat);
			}

			/* restore the child signal */
			(void) releasesignal(SIGCHLD);

			return (1);
		}
		else
		{
			/* child */
			InChild = TRUE;
			QuickAbort = FALSE;
			clearenvelope(e, FALSE);
			(void) setsignal(SIGCHLD, SIG_DFL);
			(void) releasesignal(SIGCHLD);
		}
	}
	return (0);
}

# endif /* SMTP */
/*
**  HELP -- implement the HELP command.
**
**	Parameters:
**		topic -- the topic we want help for.
**
**	Returns:
**		none.
**
**	Side Effects:
**		outputs the help file to message output.
*/

void
help(topic)
	char *topic;
{
	register FILE *hf;
	int len;
	bool noinfo;
	int sff = SFF_OPENASROOT|SFF_REGONLY;
	char buf[MAXLINE];
	extern char Version[];

	if (DontLockReadFiles)
		sff |= SFF_NOLOCK;
	if (!bitset(DBS_HELPFILEINUNSAFEDIRPATH, DontBlameSendmail))    
		sff |= SFF_SAFEDIRPATH;

	if (HelpFile == NULL ||
	    (hf = safefopen(HelpFile, O_RDONLY, 0444, sff)) == NULL)
	{
		/* no help */
		errno = 0;
		message("502 Sendmail %s -- HELP not implemented", Version);
		return;
	}

	if (topic == NULL || *topic == '\0')
	{
		topic = "smtp";
		message("214-This is Sendmail version %s", Version);
		noinfo = FALSE;
	}
	else
	{
		makelower(topic);
		noinfo = TRUE;
	}

	len = strlen(topic);

	while (fgets(buf, sizeof buf, hf) != NULL)
	{
		if (strncmp(buf, topic, len) == 0)
		{
			register char *p;

			p = strchr(buf, '\t');
			if (p == NULL)
				p = buf;
			else
				p++;
			fixcrlf(p, TRUE);
			message("214-%s", p);
			noinfo = FALSE;
		}
	}

	if (noinfo)
		message("504 HELP topic \"%.10s\" unknown", topic);
	else
		message("214 End of HELP info");
	(void) fclose(hf);
}
@


1.9
log
@sendmail 8.9.2
@
text
@@


1.8
log
@something hosed the sendmail import; fix up by hand
@
text
@d17 1
a17 1
static char sccsid[] = "@@(#)srvrsmtp.c	8.181 (Berkeley) 6/15/98 (with SMTP)";
d19 1
a19 1
static char sccsid[] = "@@(#)srvrsmtp.c	8.181 (Berkeley) 6/15/98 (without SMTP)";
d130 1
a130 1
	bool discard;
d166 1
a166 1
	setproctitle("server %s startup", CurSmtpClient);
d225 1
a225 1
		setproctitle("server %s cmd read", CurSmtpClient);
d246 2
a247 2
			** If have not accepted mail (DATA), do not bounce
			** bad addresses back to sender.
d254 1
a254 1
			finis();
d270 1
a270 1
			setproctitle("%s: %.80s", CurSmtpClient, inp);
d272 1
a272 1
			setproctitle("%s %s: %.80s", e->e_id, CurSmtpClient, inp);
d460 1
a460 1
				finis();
d501 1
a501 1
			setproctitle("%s %s: %.80s", e->e_id, CurSmtpClient, inp);
d515 1
a515 1
					finis();
d636 5
a640 1
			if (a == NULL || Errors > 0)
d642 2
a816 2
					extern pid_t dowork __P((char *, bool, bool, ENVELOPE *));

d825 1
a825 1
				finis();
d844 1
a844 1
				finis();
d923 1
a923 1
				finis();
d999 1
a999 1
			finis();
d1424 1
a1424 1
			setproctitle("server %s child wait", CurSmtpClient);
d1436 1
a1436 1
				finis();
a1453 4

	/* open alias database */
	initmaps(FALSE, e);

@


1.7
log
@Upgrade to sendmail 8.8.8
@
text
@d2 2
a3 1
 * Copyright (c) 1983, 1995-1997 Eric P. Allman
d7 3
a9 15
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
a10 11
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
d17 1
a17 1
static char sccsid[] = "@@(#)srvrsmtp.c	8.159 (Berkeley) 10/19/97 (with SMTP)";
d19 1
a19 1
static char sccsid[] = "@@(#)srvrsmtp.c	8.159 (Berkeley) 10/19/97 (without SMTP)";
d31 3
a33 1
**		none.
d101 1
a101 1
static char	*skipword();
d112 1
a112 1
	bool nullserver;
d130 1
d139 1
d163 3
d305 1
a305 1
		if (nullserver)
d319 1
a319 1
				usrerr("550 Access denied");
d368 7
d407 1
a407 1
			if (c->cmdcode != CMDEHLO)
d421 2
a422 1
				message("250-VERB");
d436 2
a437 1
			message("250-ETRN");
d724 4
d733 2
a734 1
				if (bitset(QVERIFIED, a->q_flags))
d811 1
a811 1
					extern pid_t dowork();
d865 1
a865 1
						shortenstring(inp, 203));
d883 1
a883 1
					shortenstring(inp, 203));
d923 11
d947 1
a947 1
					shortenstring(p, 203));
d954 9
a962 1
			QueueLimitRecipient = id;
d964 1
d998 2
a999 1
			if (bitset(PRIV_NOEXPN, PrivacyFlags))
d1056 1
a1056 1
				shortenstring(inp, 203));
d1118 1
a1118 1
	register char *p;
d1138 1
a1138 1
			shortenstring(firstp, 203));
d1484 2
@


1.6
log
@sendmail 8.8.7.
@
text
@d39 1
a39 1
static char sccsid[] = "@@(#)srvrsmtp.c	8.154 (Berkeley) 8/2/97 (with SMTP)";
d41 1
a41 1
static char sccsid[] = "@@(#)srvrsmtp.c	8.154 (Berkeley) 8/2/97 (without SMTP)";
d156 1
a156 1
	int lognullconnection = TRUE;
d255 12
d887 1
d933 6
a943 5
			if (LogLevel > 5)
				sm_syslog(LOG_INFO, e->e_id,
					"%.100s: ETRN %s",
					CurSmtpClient,
					shortenstring(id, 203));
@


1.5
log
@Sendmail 8.8.6.
@
text
@d39 1
a39 1
static char sccsid[] = "@@(#)srvrsmtp.c	8.146 (Berkeley) 6/11/97 (with SMTP)";
d41 1
a41 1
static char sccsid[] = "@@(#)srvrsmtp.c	8.146 (Berkeley) 6/11/97 (without SMTP)";
d157 1
d225 1
a225 10
		if (setjmp(TopFrame) > 0)
		{
			/* if() nesting is necessary for Cray UNICOS */
			if (InChild)
			{
				QuickAbort = FALSE;
				SuprErrs = TRUE;
				finis();
			}
		}
d370 2
a371 1
			else
d373 5
a377 3
				register char *q;

				for (q = p; *q != '\0'; q++)
d379 2
a380 11
					if (!isascii(*q))
						break;
					if (isalnum(*q))
						continue;
					if (isspace(*q))
					{
						*q = '\0';
						break;
					}
					if (strchr("[].-_#", *q) == NULL)
						break;
d382 1
a382 10
				if (*q != '\0')
				{
					if (!AllowBogusHELO)
						usrerr("501 Invalid domain name");
					else
					{
						message("250 %s Invalid domain name, accepting anyway",
							MyHostName);
						gothello = TRUE;
					}
d384 14
a397 1
				}
a399 1
			sendinghost = newstr(p);
d401 2
d405 2
a406 3
				/* print old message and be done with it */
				message("250 %s Hello %s, pleased to meet you",
					MyHostName, CurSmtpClient);
d409 5
a413 4
			
			/* print extended message and brag */
			message("250-%s Hello %s, pleased to meet you",
				MyHostName, CurSmtpClient);
d440 1
a440 1
			if (!gothello)
d442 2
a443 9
				/* set sending host to our known value */
				if (sendinghost == NULL)
					sendinghost = peerhostname;

				if (bitset(PRIV_NEEDMAILHELO, PrivacyFlags))
				{
					usrerr("503 Polite people say HELO first");
					break;
				}
a447 2
				if (InChild)
					finis();
d457 4
d468 2
d491 2
d501 2
d520 2
d524 3
a526 2
			if (rscheck("check_mail", p, NULL, e) != EX_OK)
				goto undo_subproc;
d577 2
d580 2
d587 1
a587 1
				/* NOTREACHED */
d593 1
a593 1
				break;
d595 2
d619 1
a619 1
				usrerr("450 Too many recipients");
d630 1
a630 1
			if (a == NULL)
d636 2
a637 1
			if (rscheck("check_rcpt", p, NULL, e) != EX_OK)
d678 2
d681 2
d686 1
a686 2

			if (Errors != 0)
d740 4
a743 2
			flush_errors(TRUE);
			if (Errors != 0)
d745 1
d792 2
a793 1
			if (doublequeue && e->e_sendmode != SM_QUEUE &&
d796 5
a800 1
				extern pid_t dowork();
d802 3
a804 2
				unlockqueue(e);
				(void) dowork(id, TRUE, TRUE, e);
d866 2
d873 2
d888 2
a889 6
			if (Errors != 0)
			{
				if (InChild)
					finis();
				break;
			}
d933 1
a933 1
			if (ok)
d1444 1
d1448 2
d1452 1
a1452 1
	    (hf = safefopen(HelpFile, O_RDONLY, 0444, SFF_OPENASROOT|SFF_REGONLY|SFF_NOLOCK)) == NULL)
@


1.4
log
@Sendmail 8.8.5.
@
text
@d2 1
a2 1
 * Copyright (c) 1983, 1995, 1996 Eric P. Allman
d39 1
a39 1
static char sccsid[] = "@@(#)srvrsmtp.c	8.136 (Berkeley) 1/17/97 (with SMTP)";
d41 1
a41 1
static char sccsid[] = "@@(#)srvrsmtp.c	8.136 (Berkeley) 1/17/97 (without SMTP)";
d156 1
d164 1
a164 1
	extern void checksmtpattack __P((volatile int *, int, char *));
d181 1
a181 1
#if defined(LOG) && DAEMON
d185 2
a186 1
		syslog(LOG_INFO, "SMTP connect from %.100s (%.100s)",
d236 1
d238 1
a258 1
#ifdef LOG
d260 2
a261 1
				syslog(LOG_NOTICE, "lost input channel from %.100s",
a262 1
#endif
a274 1
#ifdef LOG
d276 3
a278 2
			syslog(LOG_INFO, "<-- %s", inp);
#endif
d330 1
a330 1
				message("550 Access denied");
d338 9
d361 1
a361 1
			checksmtpattack(&n_helo, MAXHELOCOMMANDS, "HELO/EHLO");
d366 1
a366 1
				message("503 %s Duplicate HELO/EHLO",
d374 1
a374 1
				message("501 %s requires domain address",
d399 1
a399 1
						message("501 Invalid domain name");
d457 1
a457 1
					message("503 Polite people say HELO first");
d463 1
a463 1
				message("503 Sender already specified");
d593 1
a593 1
				message("452 Insufficient disk space; try again later");
d615 7
d696 1
a696 1
				message("550 Addressee unknown");
a697 1
			e->e_to = NULL;
d704 1
a704 1
				message("503 Need MAIL command");
d709 1
a709 1
				message("503 Need RCPT (recipient)");
d734 1
a734 1
			collect(InChannel, TRUE, doublequeue, NULL, e);
d806 4
a809 1
			message("250 Reset state");
d819 1
d827 1
a827 1
				c->cmdcode == CMDVRFY ? "VRFY" : "EXPN");
a835 1
#ifdef LOG
d837 2
a838 1
					syslog(LOG_INFO, "%.100s: %s [rejected]",
a840 1
#endif
d847 1
a847 1
				message("503 I demand that you introduce yourself first");
a851 1
#ifdef LOG
d853 2
a854 1
				syslog(LOG_INFO, "%.100s: %s",
a856 1
#endif
a857 1
			QuickAbort = TRUE;
d864 1
a864 2
				message("501 Argument required");
				Errors++;
d878 1
a878 1
				message("554 Nothing to %s", vrfy ? "VRFY" : "EXPN");
d899 1
a899 1
				message("500 Parameter required");
d904 1
a904 1
			checksmtpattack(&n_etrn, MAXETRNCOMMANDS, "ETRN");
a910 1
#ifdef LOG
d912 2
a913 1
				syslog(LOG_INFO, "%.100s: ETRN %s",
a915 1
#endif
d928 1
a928 1
			checksmtpattack(&n_noop, MAXNOOPCOMMANDS, "NOOP");
d944 4
d957 2
a958 2
			checksmtpattack(&n_noop, MAXNOOPCOMMANDS, "VERB");
			Verbose = TRUE;
d964 1
a964 1
			checksmtpattack(&n_noop, MAXNOOPCOMMANDS, "ONEX");
d970 1
a970 1
			checksmtpattack(&n_noop, MAXNOOPCOMMANDS, "XUSR");
a991 1
# ifdef LOG
d993 1
a993 1
				syslog(LOG_CRIT,
a996 1
# endif
d1007 2
a1008 1
			message("500 Command unrecognized");
d1026 1
d1036 1
a1036 1
checksmtpattack(pcounter, maxcount, cname)
d1040 1
a1043 1
#ifdef LOG
d1046 2
a1047 1
			syslog(LOG_INFO, "%.100s: %.40s attack?",
a1049 1
#endif
d1089 1
a1089 1
		message("501 Syntax error in parameters scanning \"%s\"",
a1090 1
		Errors++;
d1434 2
a1435 1
	if (HelpFile == NULL || (hf = fopen(HelpFile, "r")) == NULL)
@


1.3
log
@Update to Sendmail 8.8.4, plus recent patches, plus OpenBSD support.
Also include entire example configuration subset.
Includes smrsh (using /usr/libexec/sm.bin).

Of the top of my head, the only things I removed from the distribution were
contrib/mail.local.linux, src/Makefiles, all the *.0 and *.ps files.
Our praliases man page replaces the distributed one, ours is better.
@
text
@d39 1
a39 1
static char sccsid[] = "@@(#)srvrsmtp.c	8.131 (Berkeley) 12/1/96 (with SMTP)";
d41 1
a41 1
static char sccsid[] = "@@(#)srvrsmtp.c	8.131 (Berkeley) 12/1/96 (without SMTP)";
d124 5
a128 1
#define MAXBADCOMMANDS	25		/* maximum number of bad commands */
d153 2
d163 1
d313 1
a313 1
		if (nullserver && c->cmdcode != CMDQUIT)
d315 15
a329 2
			message("550 Access denied");
			continue;
d348 11
d389 1
d392 2
a397 8
			/* check for duplicate HELO/EHLO per RFC 1651 4.2 */
			if (gothello)
			{
				message("503 %s Duplicate HELO/EHLO",
					MyHostName);
				break;
			}

d513 1
a513 1
			setsender(p, e, &delimptr, FALSE);
d804 2
a805 12
			if (++nverifies >= MAXBADCOMMANDS)
			{
#ifdef LOG
				if (nverifies == MAXBADCOMMANDS &&
				    LogLevel > 5)
				{
					syslog(LOG_INFO, "%.100s: VRFY attack?",
					       CurSmtpClient);
				}
#endif
				sleep(1);
			}
d886 2
a887 2
			if (n_etrn++ >= 3)
				sleep(3);
d911 1
d936 1
d943 1
d949 1
d996 34
@


1.2
log
@Sendmail 8.7.3 from NetBSD
@
text
@d2 1
a2 1
 * Copyright (c) 1983, 1995 Eric P. Allman
d38 2
a39 2
#ifdef SMTP
static char sccsid[] = "@@(#)srvrsmtp.c	8.97 (Berkeley) 11/18/95 (with SMTP)";
d41 1
a41 1
static char sccsid[] = "@@(#)srvrsmtp.c	8.97 (Berkeley) 11/18/95 (without SMTP)";
d47 1
a47 1
# ifdef SMTP
d82 1
d86 1
d95 21
a115 21
	"mail",		CMDMAIL,
	"rcpt",		CMDRCPT,
	"data",		CMDDATA,
	"rset",		CMDRSET,
	"vrfy",		CMDVRFY,
	"expn",		CMDEXPN,
	"help",		CMDHELP,
	"noop",		CMDNOOP,
	"quit",		CMDQUIT,
	"helo",		CMDHELO,
	"ehlo",		CMDEHLO,
	"verb",		CMDVERB,
	"onex",		CMDONEX,
	/*
	 * remaining commands are here only
	 * to trap and log attempts to use them
	 */
	"showq",	CMDDBGQSHOW,
	"debug",	CMDDBGDEBUG,
	"wiz",		CMDLOGBOGUS,
	NULL,		CMDERROR,
d127 2
a128 1
smtp(e)
d131 1
a131 1
	register char *p;
d147 3
d154 3
d173 1
a173 1
#ifdef LOG
d265 5
d299 14
a312 1
		/* process command */
d329 1
a329 1
			if (*p == '\0')
d355 5
a359 1
					message("501 Invalid domain name");
d364 8
d386 1
d388 2
a400 1
			message("250-VERB");
d402 2
d437 4
d447 1
a447 1
					"Host %s didn't use HELO protocol",
a469 3
			p = skipword(p, "from");
			if (p == NULL)
				break;
d473 1
d488 6
a493 3
			p = delimptr;
			if (p != NULL && *p != '\0')
				*p++ = '\0';
d507 1
d522 1
a522 1
				while (isascii(*p) && isalnum(*p) || *p == '-')
d586 6
a591 1
			p = delimptr;
d594 1
d609 1
a609 1
				while (isascii(*p) && isalnum(*p) || *p == '-')
d640 1
a640 1
			e->e_to = p;
d756 1
a756 1
			dropenvelope(e);
d772 1
a772 1
			dropenvelope(e);
d778 12
d848 1
a848 1
				extern void printvrfyaddr __P((ADDRESS *, bool));
d855 1
a855 1
					printvrfyaddr(vrfyqueue, a == NULL);
d862 28
d929 6
a934 1
# ifdef SMTPDEBUG
d1215 1
d1225 1
a1225 1
printvrfyaddr(a, last)
d1228 1
d1232 5
a1236 1
	strcpy(fmtbuf, "250");
d1275 1
a1275 1
	int childpid;
d1279 7
d1290 1
d1313 3
d1324 2
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
 * Copyright (c) 1983 Eric P. Allman
d39 1
a39 1
static char sccsid[] = "@@(#)srvrsmtp.c	8.37 (Berkeley) 4/13/94 (with SMTP)";
d41 1
a41 1
static char sccsid[] = "@@(#)srvrsmtp.c	8.37 (Berkeley) 4/13/94 (without SMTP)";
a119 1
extern char	RealUserName[];
d124 1
d126 1
a126 1
	register ENVELOPE *e;
d133 2
a134 2
	bool gotmail;			/* mail command received */
	bool gothello;			/* helo command received */
d136 3
a138 4
	char *protocol;			/* sending protocol */
	char *sendinghost;		/* sending hostname */
	unsigned long msize;		/* approximate maximum message size */
	char *peerhostname;		/* name of SMTP peer or "localhost" */
d141 1
a141 1
	int nrcpts;			/* number of RCPT commands */
d143 1
a143 1
	int badcommands = 0;		/* count of bad commands */
a145 1
	extern char Version[];
d147 1
d164 22
a185 2
	expand("\201e", inp, &inp[sizeof inp], e);
	if (BrokenSmtpPeers)
d187 4
a190 4
		p = strchr(inp, '\n');
		if (p != NULL)
			*p = '\0';
		message("220 %s", inp);
d192 1
a192 1
	else
d194 4
a197 1
		char *q = inp;
a198 10
		while (q != NULL)
		{
			p = strchr(q, '\n');
			if (p != NULL)
				*p++ = '\0';
			message("220-%s", q);
			q = p;
		}
		message("220 ESMTP spoken here");
	}
d228 1
a228 1
		setproctitle("server %s cmd read", CurHostName);
d241 1
a241 1
				syslog(LOG_NOTICE, "lost input channel from %s",
d300 33
d348 3
d355 6
d401 1
a401 1
					peerhostname);
d409 1
a409 1
					peerhostname, sendinghost);
d419 1
a419 1
			e->e_flags |= EF_LOGSENDER;
d449 3
a451 2
			    (e->e_from.q_mailer != LocalMailer &&
			     strcmp(e->e_from.q_user, RealUserName) != 0))
d458 1
a458 1
			msize = 0;
d463 1
d494 1
a494 43
				if (strcasecmp(kp, "size") == 0)
				{
					if (vp == NULL)
					{
						usrerr("501 SIZE requires a value");
						/* NOTREACHED */
					}
# ifdef __STDC__
					msize = strtoul(vp, (char **) NULL, 10);
# else
					msize = strtol(vp, (char **) NULL, 10);
# endif
				}
				else if (strcasecmp(kp, "body") == 0)
				{
					if (vp == NULL)
					{
						usrerr("501 BODY requires a value");
						/* NOTREACHED */
					}
# ifdef MIME
					if (strcasecmp(vp, "8bitmime") == 0)
					{
						e->e_bodytype = "8BITMIME";
						SevenBit = FALSE;
					}
					else if (strcasecmp(vp, "7bit") == 0)
					{
						e->e_bodytype = "7BIT";
						SevenBit = TRUE;
					}
					else
					{
						usrerr("501 Unknown BODY type %s",
							vp);
					}
# endif
				}
				else
				{
					usrerr("501 %s parameter unrecognized", kp);
					/* NOTREACHED */
				}
d497 1
a497 1
			if (MaxMessageSize > 0 && msize > MaxMessageSize)
d504 1
a504 1
			if (!enoughspace(msize))
d534 1
a534 1
			a = parseaddr(p, NULLADDR, RF_COPYALL, ' ', NULL, e);
d537 44
a580 2
			a->q_flags |= QPRIMARY;
			a = recipient(a, &e->e_sendqueue, e);
d634 3
a636 1
			collect(TRUE, doublequeue, e);
d639 7
a645 1
			HoldErrs = TRUE;
a665 5
			if (nrcpts != 1 && !doublequeue)
			{
				HoldErrs = TRUE;
				e->e_errormode = EM_MAIL;
			}
d669 1
a669 9
			/* send to all recipients */
			sendall(e, doublequeue ? SM_QUEUE : SM_DEFAULT);
			e->e_to = NULL;

			/* issue success if appropriate and reset */
			if (Errors == 0 || HoldErrs)
				message("250 %s Message accepted for delivery", id);

			if (bitset(EF_FATALERRS, e->e_flags) && !HoldErrs)
d671 2
a672 3
				/* avoid sending back an extra message */
				e->e_flags &= ~EF_FATALERRS;
				e->e_flags |= EF_CLRQUEUE;
d676 7
a682 3
				/* from now on, we have to operate silently */
				HoldErrs = TRUE;
				e->e_errormode = EM_MAIL;
d684 5
a688 4
				/* if we just queued, poke it */
				if (doublequeue && e->e_sendmode != SM_QUEUE)
				{
					extern pid_t dowork();
d690 2
a691 3
					unlockqueue(e);
					(void) dowork(id, TRUE, TRUE, e);
				}
d708 3
d728 1
a728 1
					message("252 Who's to say?");
d733 3
a735 2
					syslog(LOG_INFO, "%s: %s [rejected]",
						CurSmtpClient, inp);
d750 3
a752 1
				syslog(LOG_INFO, "%s: %s", CurSmtpClient, inp);
d759 1
a759 1
				*p++;
d767 1
a767 1
				(void) sendtolist(p, NULLADDR, &vrfyqueue, e);
d781 2
d807 3
d854 2
a855 2
				    "\"%s\" command from %s (%s)",
				    c->cmdname, peerhostname,
d915 1
a915 1
			firstp);
d933 177
d1123 1
a1150 60
**  HELP -- implement the HELP command.
**
**	Parameters:
**		topic -- the topic we want help for.
**
**	Returns:
**		none.
**
**	Side Effects:
**		outputs the help file to message output.
*/

help(topic)
	char *topic;
{
	register FILE *hf;
	int len;
	char buf[MAXLINE];
	bool noinfo;

	if (HelpFile == NULL || (hf = fopen(HelpFile, "r")) == NULL)
	{
		/* no help */
		errno = 0;
		message("502 HELP not implemented");
		return;
	}

	if (topic == NULL || *topic == '\0')
		topic = "smtp";
	else
		makelower(topic);

	len = strlen(topic);
	noinfo = TRUE;

	while (fgets(buf, sizeof buf, hf) != NULL)
	{
		if (strncmp(buf, topic, len) == 0)
		{
			register char *p;

			p = strchr(buf, '\t');
			if (p == NULL)
				p = buf;
			else
				p++;
			fixcrlf(p, TRUE);
			message("214-%s", p);
			noinfo = FALSE;
		}
	}

	if (noinfo)
		message("504 HELP topic unknown");
	else
		message("214 End of HELP info");
	(void) fclose(hf);
}
/*
d1164 1
d1176 1
a1176 1
			syserr("%s: cannot fork", label);
d1184 1
a1184 1
			setproctitle("server %s child wait", CurHostName);
d1187 1
a1187 1
				syserr("%s: lost child", label);
d1189 1
a1189 1
				syserr("%s: died on signal %d",
d1217 69
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@


1.1.1.2
log
@sendmail 8.9.1
@
text
@d2 1
a2 2
 * Copyright (c) 1998 Sendmail, Inc.  All rights reserved.
 * Copyright (c) 1983, 1995-1997 Eric P. Allman.  All rights reserved.
d6 15
a20 3
 * By using this file, you agree to the terms and conditions set
 * forth in the LICENSE file which can be found at the top level of
 * the sendmail distribution.
d22 11
d38 2
a39 2
#if SMTP
static char sccsid[] = "@@(#)srvrsmtp.c	8.181 (Berkeley) 6/15/98 (with SMTP)";
d41 1
a41 1
static char sccsid[] = "@@(#)srvrsmtp.c	8.181 (Berkeley) 6/15/98 (without SMTP)";
d47 1
a47 1
# if SMTP
d53 1
a53 3
**		nullserver -- if non-NULL, rejection message for
**			all SMTP commands.
**		e -- the envelope.
a81 1
# define CMDETRN	12	/* etrn -- flush queue */
a84 1
# define CMDXUSR	18	/* xusr -- initial (user) submission */
d93 21
a113 21
	{ "mail",	CMDMAIL		},
	{ "rcpt",	CMDRCPT		},
	{ "data",	CMDDATA		},
	{ "rset",	CMDRSET		},
	{ "vrfy",	CMDVRFY		},
	{ "expn",	CMDEXPN		},
	{ "help",	CMDHELP		},
	{ "noop",	CMDNOOP		},
	{ "quit",	CMDQUIT		},
	{ "helo",	CMDHELO		},
	{ "ehlo",	CMDEHLO		},
	{ "etrn",	CMDETRN		},
	{ "verb",	CMDVERB		},
	{ "onex",	CMDONEX		},
	{ "xusr",	CMDXUSR		},
    /* remaining commands are here only to trap and log attempts to use them */
	{ "showq",	CMDDBGQSHOW	},
	{ "debug",	CMDDBGDEBUG	},
	{ "wiz",	CMDLOGBOGUS	},

	{ NULL,		CMDERROR	}
d119 2
a120 1
static char	*skipword __P((char *volatile, char *));
d123 4
a126 10
#define MAXBADCOMMANDS	25	/* maximum number of bad commands */
#define MAXNOOPCOMMANDS	20	/* max "noise" commands before slowdown */
#define MAXHELOCOMMANDS	3	/* max HELO/EHLO commands before slowdown */
#define MAXVRFYCOMMANDS	6	/* max VRFY/EXPN commands before slowdown */
#define MAXETRNCOMMANDS	8	/* max ETRN commands before slowdown */

void
smtp(nullserver, e)
	char *nullserver;
	register ENVELOPE *volatile e;
d128 1
a128 1
	register char *volatile p;
d133 2
a134 2
	volatile bool gotmail;		/* mail command received */
	volatile bool gothello;		/* helo command received */
d136 4
a139 3
	char *volatile protocol;	/* sending protocol */
	char *volatile sendinghost;	/* sending hostname */
	char *volatile peerhostname;	/* name of SMTP peer or "localhost" */
d142 1
a142 1
	volatile int nrcpts = 0;	/* number of RCPT commands */
d144 1
a144 10
	bool discard;
	volatile int badcommands = 0;	/* count of bad commands */
	volatile int nverifies = 0;	/* count of VRFY/EXPN commands */
	volatile int n_etrn = 0;	/* count of ETRN commands */
	volatile int n_noop = 0;	/* count of NOOP/VERB/ONEX etc cmds */
	volatile int n_helo = 0;	/* count of HELO/EHLO commands */
	bool ok;
	volatile int lognullconnection = TRUE;
	register char *q;
	QUEUE_CHAR *new;
d147 1
a148 5
	extern void help __P((char *));
	extern void settime __P((ENVELOPE *));
	extern bool enoughdiskspace __P((long));
	extern int runinchild __P((char *, ENVELOPE *));
	extern void checksmtpattack __P((volatile int *, int, char *, ENVELOPE *));
a163 3
	/* check_relay may have set discard bit, save for later */
	discard = bitset(EF_DISCARD, e->e_flags);

d165 2
a166 2
#if DAEMON
	if (LogLevel > 11)
d168 4
a171 4
		/* log connection information */
		sm_syslog(LOG_INFO, NOQID,
			"SMTP connect from %.100s (%.100s)",
			CurSmtpClient, anynet_ntoa(&RealHostAddr));
d173 3
a175 1
#endif
d177 9
a185 18
	/* output the first line, inserting "ESMTP" as second word */
	expand(SmtpGreeting, inp, sizeof inp, e);
	p = strchr(inp, '\n');
	if (p != NULL)
		*p++ = '\0';
	id = strchr(inp, ' ');
	if (id == NULL)
		id = &inp[strlen(inp)];
	cmd = p == NULL ? "220 %.*s ESMTP%s" : "220-%.*s ESMTP%s";
	message(cmd, id - inp, inp, id);

	/* output remaining lines */
	while ((id = p) != NULL && (p = strchr(id, '\n')) != NULL)
	{
		*p++ = '\0';
		if (isascii(*id) && isspace(*id))
			id++;
		message("220-%s", id);
a186 7
	if (id != NULL)
	{
		if (isascii(*id) && isspace(*id))
			id++;
		message("220 %s", id);
	}

d194 10
a203 1
		(void) setjmp(TopFrame);
a205 1
		SuprErrs = FALSE;
a206 1
		OnlyOneError = TRUE;
d216 1
a216 1
		setproctitle("server %s cmd read", CurSmtpClient);
d227 1
d229 1
a229 2
				sm_syslog(LOG_NOTICE, e->e_id,
					"lost input channel from %.100s",
d231 1
a231 12
			if (lognullconnection && LogLevel > 5)
				sm_syslog(LOG_INFO, NULL,
				"Null connection from %.100s",
				CurSmtpClient);

			/*
			** If have not accepted mail (DATA), do not bounce
			** bad addresses back to sender.
			*/
			if (bitset(EF_CLRQUEUE, e->e_flags))
				e->e_sendqueue = NULL;

a243 5
		if (LogLevel >= 15)
			sm_syslog(LOG_INFO, e->e_id,
				"<-- %s",
				inp);

d273 1
a273 36
		/*
		**  Process command.
		**
		**	If we are running as a null server, return 550
		**	to everything.
		*/

		if (nullserver != NULL)
		{
			switch (c->cmdcode)
			{
			  case CMDQUIT:
			  case CMDHELO:
			  case CMDEHLO:
			  case CMDNOOP:
				/* process normally */
				break;

			  default:
				if (++badcommands > MAXBADCOMMANDS)
					sleep(1);
				usrerr("550 %s", nullserver);
				continue;
			}
		}

		/* non-null server */
		switch (c->cmdcode)
		{
		  case CMDMAIL:
		  case CMDEXPN:
		  case CMDVRFY:
		  case CMDETRN:
			lognullconnection = FALSE;
		}

d288 3
a290 6

			/* avoid denial-of-service */
			checksmtpattack(&n_helo, MAXHELOCOMMANDS, "HELO/EHLO", e);

			/* check for duplicate HELO/EHLO per RFC 1651 4.2 */
			if (gothello)
d292 3
a294 2
				usrerr("503 %s Duplicate HELO/EHLO",
					MyHostName);
a296 46

			/* check for valid domain name (re 1123 5.2.5) */
			if (*p == '\0' && !AllowBogusHELO)
			{
				usrerr("501 %s requires domain address",
					cmdbuf);
				break;
			}

			/* check for long domain name (hides Received: info) */
			if (strlen(p) > MAXNAME)
			{
				usrerr("501 Invalid domain name");
				break;
			}

			for (q = p; *q != '\0'; q++)
			{
				if (!isascii(*q))
					break;
				if (isalnum(*q))
					continue;
				if (isspace(*q))
				{
					*q = '\0';
					break;
				}
				if (strchr("[].-_#", *q) == NULL)
					break;
			}
			if (*q == '\0')
			{
				q = "pleased to meet you";
				sendinghost = newstr(p);
			}
			else if (!AllowBogusHELO)
			{
				usrerr("501 Invalid domain name");
				break;
			}
			else
			{
				q = "accepting invalid domain name";
			}

			gothello = TRUE;
d298 3
a300 12
			/* print HELO response message */
			if (c->cmdcode != CMDEHLO || nullserver != NULL)
			{
				message("250 %s Hello %s, %s",
					MyHostName, CurSmtpClient, q);
				break;
			}

			message("250-%s Hello %s, %s",
				MyHostName, CurSmtpClient, q);

			/* print EHLO features list */
a301 1
			{
a302 6
				if (!bitset(PRIV_NOVERB, PrivacyFlags))
					message("250-VERB");
			}
#if MIME8TO7
			message("250-8BITMIME");
#endif
a306 8
#if DSN
			if (SendMIMEErrors)
				message("250-DSN");
#endif
			message("250-ONEX");
			if (!bitset(PRIV_NOETRN, PrivacyFlags))
				message("250-ETRN");
			message("250-XUSR");
d314 1
a314 1
			if (!gothello && bitset(PRIV_NEEDMAILHELO, PrivacyFlags))
d316 9
a324 2
				usrerr("503 Polite people say HELO first");
				break;
d328 3
a330 1
				usrerr("503 Sender already specified");
a339 8
			/* make sure we know who the sending host is */
			if (sendinghost == NULL)
				sendinghost = peerhostname;

			p = skipword(p, "from");
			if (p == NULL)
				break;

a342 2
			if (Errors > 0)
				goto undo_subproc_no_pm;
d346 2
a347 2
					"%s didn't use HELO protocol",
					CurSmtpClient);
d355 1
a355 1
					CurSmtpClient, sendinghost);
a363 2
			if (Errors > 0)
				goto undo_subproc_no_pm;
d365 1
a365 1
			e->e_flags |= EF_LOGSENDER|EF_CLRQUEUE;
d369 3
a374 3
 undo_subproc_no_pm:
				e->e_flags &= ~EF_PM_NOTIFY;
 undo_subproc:
d388 4
a391 10
			setsender(p, e, &delimptr, ' ', FALSE);
			if (delimptr != NULL && *delimptr != '\0')
				*delimptr++ = '\0';
			if (Errors > 0)
				goto undo_subproc_no_pm;

			/* do config file checking of the sender */
			if (rscheck("check_mail", p, NULL, e) != EX_OK ||
			    Errors > 0)
				goto undo_subproc_no_pm;
d395 2
a396 3
			    !wordinclass(RealUserName, 't') &&
			    !bitnset(M_LOCALMAILER, e->e_from.q_mailer->m_flags) &&
			    strcmp(e->e_from.q_user, RealUserName) != 0)
d403 1
a403 2
			e->e_msgsize = 0;
			p = delimptr;
a407 1
				extern void mail_esmtp_args __P((char *, char *, ENVELOPE *));
d417 1
a417 1
				while ((isascii(*p) && isalnum(*p)) || *p == '-')
d438 43
a480 3
				mail_esmtp_args(kp, vp, e);
				if (Errors > 0)
					goto undo_subproc_no_pm;
a481 2
			if (Errors > 0)
				goto undo_subproc_no_pm;
d483 1
a483 1
			if (MaxMessageSize > 0 && e->e_msgsize > MaxMessageSize)
d487 1
a487 1
				goto undo_subproc_no_pm;
d490 1
a490 1
			if (!enoughdiskspace(e->e_msgsize))
d492 2
a493 2
				usrerr("452 Insufficient disk space; try again later");
				goto undo_subproc_no_pm;
a494 2
			if (Errors > 0)
				goto undo_subproc_no_pm;
a513 7
			/* limit flooding of our machine */
			if (MaxRcptPerMsg > 0 && nrcpts >= MaxRcptPerMsg)
			{
				usrerr("452 Too many recipients");
				break;
			}

d520 2
a521 2
			a = parseaddr(p, NULLADDR, RF_COPYALL, ' ', &delimptr, e);
			if (a == NULL || Errors > 0)
d523 3
a525 55
			if (delimptr != NULL && *delimptr != '\0')
				*delimptr++ = '\0';

			/* do config file checking of the recipient */
			if (rscheck("check_rcpt", p, NULL, e) != EX_OK ||
			    Errors > 0)
				break;

			/* now parse ESMTP arguments */
			p = delimptr;
			while (p != NULL && *p != '\0')
			{
				char *kp;
				char *vp = NULL;
				extern void rcpt_esmtp_args __P((ADDRESS *, char *, char *, ENVELOPE *));

				/* locate the beginning of the keyword */
				while (isascii(*p) && isspace(*p))
					p++;
				if (*p == '\0')
					break;
				kp = p;

				/* skip to the value portion */
				while ((isascii(*p) && isalnum(*p)) || *p == '-')
					p++;
				if (*p == '=')
				{
					*p++ = '\0';
					vp = p;

					/* skip to the end of the value */
					while (*p != '\0' && *p != ' ' &&
					       !(isascii(*p) && iscntrl(*p)) &&
					       *p != '=')
						p++;
				}

				if (*p != '\0')
					*p++ = '\0';

				if (tTd(19, 1))
					printf("RCPT: got arg %s=\"%s\"\n", kp,
						vp == NULL ? "<null>" : vp);

				rcpt_esmtp_args(a, kp, vp, e);
				if (Errors > 0)
					break;
			}
			if (Errors > 0)
				break;

			/* save in recipient list after ESMTP mods */
			a = recipient(a, &e->e_sendqueue, 0, e);
			if (Errors > 0)
d529 1
a529 1
			e->e_to = a->q_paddr;
d540 1
a540 1
				usrerr("550 Addressee unknown");
d542 1
d549 1
a549 1
				usrerr("503 Need MAIL command");
d554 1
a554 1
				usrerr("503 Need RCPT (recipient)");
a557 4
			/* put back discard bit */
			if (discard)
				e->e_flags |= EF_DISCARD;

d563 1
a563 2
				if (bitset(QVERIFIED, a->q_flags) &&
				    !bitset(EF_DISCARD, e->e_flags))
d578 2
a579 6
			buffer_errors();
			collect(InChannel, TRUE, NULL, e);
			if (Errors > 0)
			{
				flush_errors(TRUE);
				buffer_errors();
d581 1
a581 8
			}

			/* make sure we actually do delivery */
			e->e_flags &= ~EF_CLRQUEUE;

			/* from now on, we have to operate silently */
			buffer_errors();
			e->e_errormode = EM_MAIL;
d602 5
d610 9
a618 1
			if (doublequeue)
d620 3
a622 2
				/* make sure it is in the queue */
				queueup(e, FALSE);
d626 3
a628 7
				/* send to all recipients */
				sendall(e, SM_DEFAULT);
			}
			e->e_to = NULL;

			/* issue success message */
			message("250 %s Message accepted for delivery", id);
d630 2
a631 8
			/* if we just queued, poke it */
			if (doublequeue &&
			    e->e_sendmode != SM_QUEUE &&
			    e->e_sendmode != SM_DEFER)
			{
				CurrentLA = getla();

				if (!shouldqueue(e->e_msgpriority, e->e_ctime))
d633 1
a633 1
					extern pid_t dowork __P((char *, bool, bool, ENVELOPE *));
d647 1
a647 1
			dropenvelope(e, TRUE);
d653 1
a653 7
			if (tTd(94, 100))
				message("451 Test failure");
			else
				message("250 Reset state");

			/* arrange to ignore any current send list */
			e->e_sendqueue = NULL;
d660 1
a660 2
			SuprErrs = TRUE;
			dropenvelope(e, TRUE);
a665 2
			checksmtpattack(&nverifies, MAXVRFYCOMMANDS,
				c->cmdcode == CMDVRFY ? "VRFY" : "EXPN", e);
d671 1
a671 1
					message("252 Cannot VRFY user; try RCPT to attempt delivery (or try finger)");
d674 1
d676 3
a678 4
					sm_syslog(LOG_INFO, e->e_id,
						"%.100s: %s [rejected]",
						CurSmtpClient,
						shortenstring(inp, MAXSHORTSTR));
d685 1
a685 1
				usrerr("503 I demand that you introduce yourself first");
d690 1
a690 2
			if (Errors > 0)
				goto undo_subproc;
d692 3
a694 6
				sm_syslog(LOG_INFO, e->e_id,
					"%.100s: %s",
					CurSmtpClient,
					shortenstring(inp, MAXSHORTSTR));
			if (setjmp(TopFrame) > 0)
				goto undo_subproc;
a695 1
			vrfyqueue = NULL;
d699 1
a699 1
				p++;
d702 2
a703 1
				usrerr("501 Argument required");
d707 7
a713 1
				(void) sendtolist(p, NULLADDR, &vrfyqueue, 0, e);
a714 2
			if (Errors > 0)
				goto undo_subproc;
d717 1
a717 1
				usrerr("554 Nothing to %s", vrfy ? "VRFY" : "EXPN");
a720 2
				extern void printvrfyaddr __P((ADDRESS *, bool, bool));

d726 1
a726 1
					printvrfyaddr(vrfyqueue, a == NULL, vrfy);
a732 48
		  case CMDETRN:		/* etrn -- force queue flush */
			if (bitset(PRIV_NOETRN, PrivacyFlags))
			{
				message("502 Sorry, we do not allow this operation");
				if (LogLevel > 5)
					sm_syslog(LOG_INFO, e->e_id,
						"%.100s: %s [rejected]",
						CurSmtpClient,
						shortenstring(inp, MAXSHORTSTR));
				break;
			}

			if (strlen(p) <= 0)
			{
				usrerr("500 Parameter required");
				break;
			}

			/* crude way to avoid denial-of-service attacks */
			checksmtpattack(&n_etrn, MAXETRNCOMMANDS, "ETRN", e);

			if (LogLevel > 5)
				sm_syslog(LOG_INFO, e->e_id,
					"%.100s: ETRN %s",
					CurSmtpClient,
					shortenstring(p, MAXSHORTSTR));

			id = p;
			if (*id == '@@')
				id++;
			else
				*--id = '@@';
				  
			if ((new = (QUEUE_CHAR *)malloc(sizeof(QUEUE_CHAR))) == NULL)
			{
				syserr("500 ETRN out of memory");
				break;
			}
			new->queue_match = id;
			new->queue_next = NULL;
			QueueLimitRecipient = new;
			ok = runqueue(TRUE, TRUE);
			free(QueueLimitRecipient);
			QueueLimitRecipient = NULL;
			if (ok && Errors == 0)
				message("250 Queuing for node %s started", p);
			break;

a737 1
			checksmtpattack(&n_noop, MAXNOOPCOMMANDS, "NOOP", e);
a744 3
			/* arrange to ignore any current send list */
			e->e_sendqueue = NULL;

a749 4
			if (lognullconnection && LogLevel > 5)
				sm_syslog(LOG_INFO, NULL,
					"Null connection from %.100s",
					CurSmtpClient);
d753 1
a753 2
			if (bitset(PRIV_NOEXPN, PrivacyFlags) ||
			    bitset(PRIV_NOVERB, PrivacyFlags))
d759 1
a759 2
			checksmtpattack(&n_noop, MAXNOOPCOMMANDS, "VERB", e);
			Verbose = 1;
a764 1
			checksmtpattack(&n_noop, MAXNOOPCOMMANDS, "ONEX", e);
d769 1
a769 7
		  case CMDXUSR:		/* initial (user) submission */
			checksmtpattack(&n_noop, MAXNOOPCOMMANDS, "XUSR", e);
			UserSubmission = TRUE;
			message("250 Initial submission");
			break;

# if SMTPDEBUG
d786 1
d788 3
a790 3
				sm_syslog(LOG_CRIT, e->e_id,
				    "\"%s\" command from %.100s (%.100s)",
				    c->cmdname, CurSmtpClient,
d792 1
d803 1
a803 2
			usrerr("500 Command unrecognized: \"%s\"",
				shortenstring(inp, MAXSHORTSTR));
a813 35
**  CHECKSMTPATTACK -- check for denial-of-service attack by repetition
**
**	Parameters:
**		pcounter -- pointer to a counter for this command.
**		maxcount -- maximum value for this counter before we
**			slow down.
**		cname -- command name for logging.
**		e -- the current envelope.
**
**	Returns:
**		none.
**
**	Side Effects:
**		Slows down if we seem to be under attack.
*/

void
checksmtpattack(pcounter, maxcount, cname, e)
	volatile int *pcounter;
	int maxcount;
	char *cname;
	ENVELOPE *e;
{
	if (++(*pcounter) >= maxcount)
	{
		if (*pcounter == maxcount && LogLevel > 5)
		{
			sm_syslog(LOG_INFO, e->e_id,
				"%.100s: %.40s attack?",
			       CurSmtpClient, cname);
		}
		sleep(*pcounter / maxcount);
	}
}
/*
d830 1
a830 1
	register char *volatile p;
d849 3
a851 2
		usrerr("501 Syntax error in parameters scanning \"%s\"",
			shortenstring(firstp, MAXSHORTSTR));
a867 177
**  MAIL_ESMTP_ARGS -- process ESMTP arguments from MAIL line
**
**	Parameters:
**		kp -- the parameter key.
**		vp -- the value of that parameter.
**		e -- the envelope.
**
**	Returns:
**		none.
*/

void
mail_esmtp_args(kp, vp, e)
	char *kp;
	char *vp;
	ENVELOPE *e;
{
	if (strcasecmp(kp, "size") == 0)
	{
		if (vp == NULL)
		{
			usrerr("501 SIZE requires a value");
			/* NOTREACHED */
		}
# if defined(__STDC__) && !defined(BROKEN_ANSI_LIBRARY)
		e->e_msgsize = strtoul(vp, (char **) NULL, 10);
# else
		e->e_msgsize = strtol(vp, (char **) NULL, 10);
# endif
	}
	else if (strcasecmp(kp, "body") == 0)
	{
		if (vp == NULL)
		{
			usrerr("501 BODY requires a value");
			/* NOTREACHED */
		}
		else if (strcasecmp(vp, "8bitmime") == 0)
		{
			SevenBitInput = FALSE;
		}
		else if (strcasecmp(vp, "7bit") == 0)
		{
			SevenBitInput = TRUE;
		}
		else
		{
			usrerr("501 Unknown BODY type %s",
				vp);
			/* NOTREACHED */
		}
		e->e_bodytype = newstr(vp);
	}
	else if (strcasecmp(kp, "envid") == 0)
	{
		if (vp == NULL)
		{
			usrerr("501 ENVID requires a value");
			/* NOTREACHED */
		}
		if (!xtextok(vp))
		{
			usrerr("501 Syntax error in ENVID parameter value");
			/* NOTREACHED */
		}
		if (e->e_envid != NULL)
		{
			usrerr("501 Duplicate ENVID parameter");
			/* NOTREACHED */
		}
		e->e_envid = newstr(vp);
	}
	else if (strcasecmp(kp, "ret") == 0)
	{
		if (vp == NULL)
		{
			usrerr("501 RET requires a value");
			/* NOTREACHED */
		}
		if (bitset(EF_RET_PARAM, e->e_flags))
		{
			usrerr("501 Duplicate RET parameter");
			/* NOTREACHED */
		}
		e->e_flags |= EF_RET_PARAM;
		if (strcasecmp(vp, "hdrs") == 0)
			e->e_flags |= EF_NO_BODY_RETN;
		else if (strcasecmp(vp, "full") != 0)
		{
			usrerr("501 Bad argument \"%s\" to RET", vp);
			/* NOTREACHED */
		}
	}
	else
	{
		usrerr("501 %s parameter unrecognized", kp);
		/* NOTREACHED */
	}
}
/*
**  RCPT_ESMTP_ARGS -- process ESMTP arguments from RCPT line
**
**	Parameters:
**		a -- the address corresponding to the To: parameter.
**		kp -- the parameter key.
**		vp -- the value of that parameter.
**		e -- the envelope.
**
**	Returns:
**		none.
*/

void
rcpt_esmtp_args(a, kp, vp, e)
	ADDRESS *a;
	char *kp;
	char *vp;
	ENVELOPE *e;
{
	if (strcasecmp(kp, "notify") == 0)
	{
		char *p;

		if (vp == NULL)
		{
			usrerr("501 NOTIFY requires a value");
			/* NOTREACHED */
		}
		a->q_flags &= ~(QPINGONSUCCESS|QPINGONFAILURE|QPINGONDELAY);
		a->q_flags |= QHASNOTIFY;
		if (strcasecmp(vp, "never") == 0)
			return;
		for (p = vp; p != NULL; vp = p)
		{
			p = strchr(p, ',');
			if (p != NULL)
				*p++ = '\0';
			if (strcasecmp(vp, "success") == 0)
				a->q_flags |= QPINGONSUCCESS;
			else if (strcasecmp(vp, "failure") == 0)
				a->q_flags |= QPINGONFAILURE;
			else if (strcasecmp(vp, "delay") == 0)
				a->q_flags |= QPINGONDELAY;
			else
			{
				usrerr("501 Bad argument \"%s\"  to NOTIFY",
					vp);
				/* NOTREACHED */
			}
		}
	}
	else if (strcasecmp(kp, "orcpt") == 0)
	{
		if (vp == NULL)
		{
			usrerr("501 ORCPT requires a value");
			/* NOTREACHED */
		}
		if (strchr(vp, ';') == NULL || !xtextok(vp))
		{
			usrerr("501 Syntax error in ORCPT parameter value");
			/* NOTREACHED */
		}
		if (a->q_orcpt != NULL)
		{
			usrerr("501 Duplicate ORCPT parameter");
			/* NOTREACHED */
		}
		a->q_orcpt = newstr(vp);
	}
	else
	{
		usrerr("501 %s parameter unrecognized", kp);
		/* NOTREACHED */
	}
}
/*
a872 1
**		vrfy -- set if this is a VRFY command.
d881 1
a881 2
void
printvrfyaddr(a, last, vrfy)
a883 1
	bool vrfy;
d887 1
a887 5
	if (vrfy && a->q_mailer != NULL &&
	    !bitnset(M_VRFY250, a->q_mailer->m_flags))
		strcpy(fmtbuf, "252");
	else
		strcpy(fmtbuf, "250");
d908 60
a980 1
int
d985 1
a985 1
	pid_t childpid;
a988 7
		/*
		**  Disable child process reaping, in case ETRN has preceeded
		**  MAIL command, and then fork.
		*/

		(void) blocksignal(SIGCHLD);

d992 1
a992 2
			syserr("451 %s: cannot fork", label);
			(void) releasesignal(SIGCHLD);
d1000 1
a1000 1
			setproctitle("server %s child wait", CurSmtpClient);
d1003 1
a1003 1
				syserr("451 %s: lost child", label);
d1005 1
a1005 1
				syserr("451 %s: died on signal %d",
a1014 3
			/* restore the child signal */
			(void) releasesignal(SIGCHLD);

a1022 2
			(void) setsignal(SIGCHLD, SIG_DFL);
			(void) releasesignal(SIGCHLD);
a1032 75
/*
**  HELP -- implement the HELP command.
**
**	Parameters:
**		topic -- the topic we want help for.
**
**	Returns:
**		none.
**
**	Side Effects:
**		outputs the help file to message output.
*/

void
help(topic)
	char *topic;
{
	register FILE *hf;
	int len;
	bool noinfo;
	int sff = SFF_OPENASROOT|SFF_REGONLY;
	char buf[MAXLINE];
	extern char Version[];

	if (DontLockReadFiles)
		sff |= SFF_NOLOCK;
	if (!bitset(DBS_HELPFILEINUNSAFEDIRPATH, DontBlameSendmail))    
		sff |= SFF_SAFEDIRPATH;

	if (HelpFile == NULL ||
	    (hf = safefopen(HelpFile, O_RDONLY, 0444, sff)) == NULL)
	{
		/* no help */
		errno = 0;
		message("502 Sendmail %s -- HELP not implemented", Version);
		return;
	}

	if (topic == NULL || *topic == '\0')
	{
		topic = "smtp";
		message("214-This is Sendmail version %s", Version);
		noinfo = FALSE;
	}
	else
	{
		makelower(topic);
		noinfo = TRUE;
	}

	len = strlen(topic);

	while (fgets(buf, sizeof buf, hf) != NULL)
	{
		if (strncmp(buf, topic, len) == 0)
		{
			register char *p;

			p = strchr(buf, '\t');
			if (p == NULL)
				p = buf;
			else
				p++;
			fixcrlf(p, TRUE);
			message("214-%s", p);
			noinfo = FALSE;
		}
	}

	if (noinfo)
		message("504 HELP topic \"%.10s\" unknown", topic);
	else
		message("214 End of HELP info");
	(void) fclose(hf);
}
@

