head	1.12;
access;
symbols
	OPENBSD_2_6:1.11.0.4
	OPENBSD_2_6_BASE:1.11
	OPENBSD_2_5:1.11.0.2
	OPENBSD_2_5_BASE:1.11
	OPENBSD_2_4:1.9.0.2
	OPENBSD_2_4_BASE:1.9
	sendmail_8_9_1:1.1.1.2
	UCB:1.1.1
	OPENBSD_2_3:1.8.0.4
	OPENBSD_2_3_BASE:1.8
	OPENBSD_2_2:1.8.0.2
	OPENBSD_2_2_BASE:1.8
	OPENBSD_2_1:1.6.0.2
	OPENBSD_2_1_BASE:1.6
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.12
date	2000.04.18.04.57.20;	author millert;	state dead;
branches;
next	1.11;

1.11
date	99.02.05.05.59.27;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	99.01.01.20.33.46;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	98.07.12.19.44.37;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	97.08.04.02.17.52;	author downsj;	state Exp;
branches;
next	1.7;

1.7
date	97.07.15.07.24.04;	author downsj;	state Exp;
branches;
next	1.6;

1.6
date	97.01.22.01.07.09;	author downsj;	state Exp;
branches;
next	1.5;

1.5
date	96.12.14.21.17.17;	author downsj;	state Exp;
branches;
next	1.4;

1.4
date	96.09.19.06.44.57;	author fn;	state Exp;
branches;
next	1.3;

1.3
date	96.09.12.19.25.42;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.01.29.01.43.51;	author dm;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.48.18;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.48.18;	author deraadt;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	98.07.12.17.10.06;	author millert;	state Exp;
branches;
next	;


desc
@@


1.12
log
@remove sendmail 8.9.3
@
text
@/*
 * Copyright (c) 1998 Sendmail, Inc.  All rights reserved.
 * Copyright (c) 1983, 1995-1997 Eric P. Allman.  All rights reserved.
 * Copyright (c) 1988, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * By using this file, you agree to the terms and conditions set
 * forth in the LICENSE file which can be found at the top level of
 * the sendmail distribution.
 *
 */

#ifndef lint
static char sccsid[] = "@@(#)envelope.c	8.122 (Berkeley) 1/25/1999";
#endif /* not lint */

#include "sendmail.h"

/*
**  NEWENVELOPE -- allocate a new envelope
**
**	Supports inheritance.
**
**	Parameters:
**		e -- the new envelope to fill in.
**		parent -- the envelope to be the parent of e.
**
**	Returns:
**		e.
**
**	Side Effects:
**		none.
*/

ENVELOPE *
newenvelope(e, parent)
	register ENVELOPE *e;
	register ENVELOPE *parent;
{
	if (e == parent && e->e_parent != NULL)
		parent = e->e_parent;
	clearenvelope(e, TRUE);
	if (e == CurEnv)
		bcopy((char *) &NullAddress, (char *) &e->e_from, sizeof e->e_from);
	else
		bcopy((char *) &CurEnv->e_from, (char *) &e->e_from, sizeof e->e_from);
	e->e_parent = parent;
	e->e_ctime = curtime();
	if (parent != NULL)
		e->e_msgpriority = parent->e_msgsize;
	e->e_puthdr = putheader;
	e->e_putbody = putbody;
	if (CurEnv->e_xfp != NULL)
		(void) fflush(CurEnv->e_xfp);

	return (e);
}
/*
**  DROPENVELOPE -- deallocate an envelope.
**
**	Parameters:
**		e -- the envelope to deallocate.
**		fulldrop -- if set, do return receipts.
**
**	Returns:
**		none.
**
**	Side Effects:
**		housekeeping necessary to dispose of an envelope.
**		Unlocks this queue file.
*/

void
dropenvelope(e, fulldrop)
	register ENVELOPE *e;
	bool fulldrop;
{
	bool queueit = FALSE;
	bool message_timeout = FALSE;
	bool failure_return = FALSE;
	bool delay_return = FALSE;
	bool success_return = FALSE;
	register ADDRESS *q;
	char *id = e->e_id;
	char buf[MAXLINE];

	if (tTd(50, 1))
	{
		extern void printenvflags __P((ENVELOPE *));

		printf("dropenvelope %lx: id=", (u_long) e);
		xputs(e->e_id);
		printf(", flags=");
		printenvflags(e);
		if (tTd(50, 10))
		{
			printf("sendq=");
			printaddr(e->e_sendqueue, TRUE);
		}
	}

	if (LogLevel > 84)
		sm_syslog(LOG_DEBUG, id,
			"dropenvelope, e_flags=0x%x, OpMode=%c, pid=%d",
			e->e_flags, OpMode, getpid());

	/* we must have an id to remove disk files */
	if (id == NULL)
		return;

	/* if verify-only mode, we can skip most of this */
	if (OpMode == MD_VERIFY)
		goto simpledrop;

	if (LogLevel > 4 && bitset(EF_LOGSENDER, e->e_flags))
		logsender(e, NULL);
	e->e_flags &= ~EF_LOGSENDER;

	/* post statistics */
	poststats(StatFile);

	/*
	**  Extract state information from dregs of send list.
	*/

	if (curtime() > e->e_ctime + TimeOuts.to_q_return[e->e_timeoutclass])
		message_timeout = TRUE;

	e->e_flags &= ~EF_QUEUERUN;
	for (q = e->e_sendqueue; q != NULL; q = q->q_next)
	{
		if (bitset(QQUEUEUP, q->q_flags) &&
		    bitset(QDONTSEND, q->q_flags))
		{
			/* I'm not sure how this happens..... */
			if (tTd(50, 2))
			{
				printf("Bogus flags: ");
				printaddr(q, FALSE);
			}
			q->q_flags &= ~QDONTSEND;
		}
		if (!bitset(QBADADDR|QDONTSEND|QSENT, q->q_flags))
			queueit = TRUE;
#if XDEBUG
		else if (bitset(QQUEUEUP, q->q_flags))
			sm_syslog(LOG_DEBUG, e->e_id,
				"dropenvelope: q_flags = %x, paddr = %s",
				q->q_flags, q->q_paddr);
#endif

		/* see if a notification is needed */
		if (bitset(QPINGONFAILURE, q->q_flags) &&
		    ((message_timeout && bitset(QQUEUEUP, q->q_flags)) ||
		     bitset(QBADADDR, q->q_flags)))
		{
			failure_return = TRUE;
			if (q->q_owner == NULL && !emptyaddr(&e->e_from))
				(void) sendtolist(e->e_from.q_paddr, NULLADDR,
						  &e->e_errorqueue, 0, e);
		}
		else if (bitset(QPINGONSUCCESS, q->q_flags) &&
			 ((bitset(QSENT, q->q_flags) &&
			   bitnset(M_LOCALMAILER, q->q_mailer->m_flags)) ||
			  bitset(QRELAYED|QEXPANDED|QDELIVERED, q->q_flags)))
		{
			success_return = TRUE;
		}
	}

	if (e->e_class < 0)
		e->e_flags |= EF_NO_BODY_RETN;

	/*
	**  See if the message timed out.
	*/

	if (!queueit)
		/* nothing to do */ ;
	else if (message_timeout)
	{
		if (failure_return)
		{
			(void) snprintf(buf, sizeof buf,
				"Cannot send message within %s",
				pintvl(TimeOuts.to_q_return[e->e_timeoutclass], FALSE));
			if (e->e_message != NULL)
				free(e->e_message);
			e->e_message = newstr(buf);
			message(buf);
			e->e_flags |= EF_CLRQUEUE;
		}
		fprintf(e->e_xfp, "Message could not be delivered for %s\n",
			pintvl(TimeOuts.to_q_return[e->e_timeoutclass], FALSE));
		fprintf(e->e_xfp, "Message will be deleted from queue\n");
		for (q = e->e_sendqueue; q != NULL; q = q->q_next)
		{
			if (!bitset(QBADADDR|QDONTSEND|QSENT, q->q_flags))
			{
				q->q_flags |= QBADADDR;
				q->q_status = "4.4.7";
			}
		}
	}
	else if (TimeOuts.to_q_warning[e->e_timeoutclass] > 0 &&
	    curtime() > e->e_ctime + TimeOuts.to_q_warning[e->e_timeoutclass])
	{
		if (!bitset(EF_WARNING|EF_RESPONSE, e->e_flags) &&
		    e->e_class >= 0 &&
		    e->e_from.q_paddr != NULL &&
		    strcmp(e->e_from.q_paddr, "<>") != 0 &&
		    strncasecmp(e->e_from.q_paddr, "owner-", 6) != 0 &&
		    (strlen(e->e_from.q_paddr) <= (SIZE_T) 8 ||
		     strcasecmp(&e->e_from.q_paddr[strlen(e->e_from.q_paddr) - 8], "-request") != 0))
		{
			for (q = e->e_sendqueue; q != NULL; q = q->q_next)
			{
				if (bitset(QQUEUEUP, q->q_flags) &&
				    bitset(QPINGONDELAY, q->q_flags))
				{
					q->q_flags |= QDELAYED;
					delay_return = TRUE;
				}
			}
		}
		if (delay_return)
		{
			(void) snprintf(buf, sizeof buf,
				"Warning: could not send message for past %s",
				pintvl(TimeOuts.to_q_warning[e->e_timeoutclass], FALSE));
			if (e->e_message != NULL)
				free(e->e_message);
			e->e_message = newstr(buf);
			message(buf);
			e->e_flags |= EF_WARNING;
		}
		fprintf(e->e_xfp,
			"Warning: message still undelivered after %s\n",
			pintvl(TimeOuts.to_q_warning[e->e_timeoutclass], FALSE));
		fprintf(e->e_xfp, "Will keep trying until message is %s old\n",
			pintvl(TimeOuts.to_q_return[e->e_timeoutclass], FALSE));
	}

	if (tTd(50, 2))
		printf("failure_return=%d delay_return=%d success_return=%d queueit=%d\n",
			failure_return, delay_return, success_return, queueit);

	/*
	**  If we had some fatal error, but no addresses are marked as
	**  bad, mark them _all_ as bad.
	*/

	if (bitset(EF_FATALERRS, e->e_flags) && !failure_return)
	{
		for (q = e->e_sendqueue; q != NULL; q = q->q_next)
		{
			if (!bitset(QDONTSEND, q->q_flags) &&
			    bitset(QPINGONFAILURE, q->q_flags))
			{
				failure_return = TRUE;
				q->q_flags |= QBADADDR;
			}
		}
	}

	/*
	**  Send back return receipts as requested.
	*/

	if (success_return && !failure_return && !delay_return && fulldrop &&
	    !bitset(PRIV_NORECEIPTS, PrivacyFlags) &&
	    strcmp(e->e_from.q_paddr, "<>") != 0)
	{
		auto ADDRESS *rlist = NULL;

		if (tTd(50, 8))
			printf("dropenvelope(%s): sending return receipt\n", id);
		e->e_flags |= EF_SENDRECEIPT;
		(void) sendtolist(e->e_from.q_paddr, NULLADDR, &rlist, 0, e);
		(void) returntosender("Return receipt", rlist, RTSF_NO_BODY, e);
	}
	e->e_flags &= ~EF_SENDRECEIPT;

	/*
	**  Arrange to send error messages if there are fatal errors.
	*/

	if ((failure_return || delay_return) && e->e_errormode != EM_QUIET)
	{
		extern void savemail __P((ENVELOPE *, bool));

		if (tTd(50, 8))
			printf("dropenvelope(%s): saving mail\n", id);
		savemail(e, !bitset(EF_NO_BODY_RETN, e->e_flags));
	}

	/*
	**  Arrange to send warning messages to postmaster as requested.
	*/

	if ((failure_return || bitset(EF_PM_NOTIFY, e->e_flags)) &&
	    PostMasterCopy != NULL &&
	    !bitset(EF_RESPONSE, e->e_flags) && e->e_class >= 0)
	{
		auto ADDRESS *rlist = NULL;

		if (tTd(50, 8))
			printf("dropenvelope(%s): sending postmaster copy\n", id);
		(void) sendtolist(PostMasterCopy, NULLADDR, &rlist, 0, e);
		(void) returntosender(e->e_message, rlist, RTSF_PM_BOUNCE, e);
	}

	/*
	**  Instantiate or deinstantiate the queue.
	*/

simpledrop:
	if (tTd(50, 8))
		printf("dropenvelope(%s): at simpledrop, queueit=%d\n",
			id, queueit);
	if (!queueit || bitset(EF_CLRQUEUE, e->e_flags))
	{
		if (tTd(50, 1))
		{
			extern void printenvflags __P((ENVELOPE *));

			printf("\n===== Dropping [dq]f%s... queueit=%d, e_flags=",
				e->e_id, queueit);
			printenvflags(e);
		}
		xunlink(queuename(e, 'd'));
		xunlink(queuename(e, 'q'));

		if (LogLevel > 10)
			sm_syslog(LOG_INFO, id, "done");
	}
	else if (queueit || !bitset(EF_INQUEUE, e->e_flags))
	{
#if QUEUE
		queueup(e, FALSE);
#else /* QUEUE */
		syserr("554 dropenvelope: queueup");
#endif /* QUEUE */
	}

	/* now unlock the job */
	if (tTd(50, 8))
		printf("dropenvelope(%s): unlocking job\n", id);
	closexscript(e);
	unlockqueue(e);

	/* make sure that this envelope is marked unused */
	if (e->e_dfp != NULL)
		(void) xfclose(e->e_dfp, "dropenvelope df", e->e_id);
	e->e_dfp = NULL;
	e->e_id = NULL;
	e->e_flags &= ~EF_HAS_DF;
}
/*
**  CLEARENVELOPE -- clear an envelope without unlocking
**
**	This is normally used by a child process to get a clean
**	envelope without disturbing the parent.
**
**	Parameters:
**		e -- the envelope to clear.
**		fullclear - if set, the current envelope is total
**			garbage and should be ignored; otherwise,
**			release any resources it may indicate.
**
**	Returns:
**		none.
**
**	Side Effects:
**		Closes files associated with the envelope.
**		Marks the envelope as unallocated.
*/

void
clearenvelope(e, fullclear)
	register ENVELOPE *e;
	bool fullclear;
{
	register HDR *bh;
	register HDR **nhp;
	extern ENVELOPE BlankEnvelope;

	if (!fullclear)
	{
		/* clear out any file information */
		if (e->e_xfp != NULL)
			(void) xfclose(e->e_xfp, "clearenvelope xfp", e->e_id);
		if (e->e_dfp != NULL)
			(void) xfclose(e->e_dfp, "clearenvelope dfp", e->e_id);
		e->e_xfp = e->e_dfp = NULL;
	}

	/* now clear out the data */
	STRUCTCOPY(BlankEnvelope, *e);
	e->e_message = NULL;
	if (Verbose)
		e->e_sendmode = SM_DELIVER;
	bh = BlankEnvelope.e_header;
	nhp = &e->e_header;
	while (bh != NULL)
	{
		*nhp = (HDR *) xalloc(sizeof *bh);
		bcopy((char *) bh, (char *) *nhp, sizeof *bh);
		bh = bh->h_link;
		nhp = &(*nhp)->h_link;
	}
}
/*
**  INITSYS -- initialize instantiation of system
**
**	In Daemon mode, this is done in the child.
**
**	Parameters:
**		none.
**
**	Returns:
**		none.
**
**	Side Effects:
**		Initializes the system macros, some global variables,
**		etc.  In particular, the current time in various
**		forms is set.
*/

void
initsys(e)
	register ENVELOPE *e;
{
	char cbuf[5];				/* holds hop count */
	char pbuf[10];				/* holds pid */
#ifdef TTYNAME
	static char ybuf[60];			/* holds tty id */
	register char *p;
	extern char *ttyname();
#endif /* TTYNAME */
	extern void settime __P((ENVELOPE *));

	/*
	**  Give this envelope a reality.
	**	I.e., an id, a transcript, and a creation time.
	*/

	openxscript(e);
	e->e_ctime = curtime();

	/*
	**  Set OutChannel to something useful if stdout isn't it.
	**	This arranges that any extra stuff the mailer produces
	**	gets sent back to the user on error (because it is
	**	tucked away in the transcript).
	*/

	if (OpMode == MD_DAEMON && bitset(EF_QUEUERUN, e->e_flags) &&
	    e->e_xfp != NULL)
		OutChannel = e->e_xfp;

	/*
	**  Set up some basic system macros.
	*/

	/* process id */
	(void) snprintf(pbuf, sizeof pbuf, "%d", getpid());
	define('p', newstr(pbuf), e);

	/* hop count */
	(void) snprintf(cbuf, sizeof cbuf, "%d", e->e_hopcount);
	define('c', newstr(cbuf), e);

	/* time as integer, unix time, arpa time */
	settime(e);

#ifdef TTYNAME
	/* tty name */
	if (macvalue('y', e) == NULL)
	{
		p = ttyname(2);
		if (p != NULL)
		{
			if (strrchr(p, '/') != NULL)
				p = strrchr(p, '/') + 1;
			snprintf(ybuf, sizeof ybuf, "%s", p);
			define('y', ybuf, e);
		}
	}
#endif /* TTYNAME */
}
/*
**  SETTIME -- set the current time.
**
**	Parameters:
**		none.
**
**	Returns:
**		none.
**
**	Side Effects:
**		Sets the various time macros -- $a, $b, $d, $t.
*/

void
settime(e)
	register ENVELOPE *e;
{
	register char *p;
	auto time_t now;
	char tbuf[20];				/* holds "current" time */
	char dbuf[30];				/* holds ctime(tbuf) */
	register struct tm *tm;
	extern struct tm *gmtime();

	now = curtime();
	tm = gmtime(&now);
	(void) snprintf(tbuf, sizeof tbuf, "%04d%02d%02d%02d%02d", tm->tm_year + 1900,
			tm->tm_mon+1, tm->tm_mday, tm->tm_hour, tm->tm_min);
	define('t', newstr(tbuf), e);
	(void) strcpy(dbuf, ctime(&now));
	p = strchr(dbuf, '\n');
	if (p != NULL)
		*p = '\0';
	define('d', newstr(dbuf), e);
	p = arpadate(dbuf);
	p = newstr(p);
	if (macvalue('a', e) == NULL)
		define('a', p, e);
	define('b', p, e);
}
/*
**  OPENXSCRIPT -- Open transcript file
**
**	Creates a transcript file for possible eventual mailing or
**	sending back.
**
**	Parameters:
**		e -- the envelope to create the transcript in/for.
**
**	Returns:
**		none
**
**	Side Effects:
**		Creates the transcript file.
*/

#ifndef O_APPEND
#define O_APPEND	0
#endif

void
openxscript(e)
	register ENVELOPE *e;
{
	register char *p;
	int fd;

	if (e->e_xfp != NULL)
		return;
	p = queuename(e, 'x');
	fd = open(p, O_WRONLY|O_CREAT|O_APPEND, FileMode);
	if (fd < 0)
	{
		syserr("Can't create transcript file %s", p);
		fd = open("/dev/null", O_WRONLY, 0644);
		if (fd < 0)
			syserr("!Can't open /dev/null");
	}
	e->e_xfp = fdopen(fd, "a");
	if (e->e_xfp == NULL)
		syserr("!Can't create transcript stream %s", p);
#ifdef HASSETVBUF
	setvbuf(e->e_xfp, NULL, _IOLBF, 0);
#else
	setlinebuf(e->e_xfp);
#endif
	if (tTd(46, 9))
	{
		printf("openxscript(%s):\n  ", p);
		dumpfd(fileno(e->e_xfp), TRUE, FALSE);
	}
}
/*
**  CLOSEXSCRIPT -- close the transcript file.
**
**	Parameters:
**		e -- the envelope containing the transcript to close.
**
**	Returns:
**		none.
**
**	Side Effects:
**		none.
*/

void
closexscript(e)
	register ENVELOPE *e;
{
	if (e->e_xfp == NULL)
		return;
	(void) xfclose(e->e_xfp, "closexscript", e->e_id);
	e->e_xfp = NULL;
}
/*
**  SETSENDER -- set the person who this message is from
**
**	Under certain circumstances allow the user to say who
**	s/he is (using -f or -r).  These are:
**	1.  The user's uid is zero (root).
**	2.  The user's login name is in an approved list (typically
**	    from a network server).
**	3.  The address the user is trying to claim has a
**	    "!" character in it (since #2 doesn't do it for
**	    us if we are dialing out for UUCP).
**	A better check to replace #3 would be if the
**	effective uid is "UUCP" -- this would require me
**	to rewrite getpwent to "grab" uucp as it went by,
**	make getname more nasty, do another passwd file
**	scan, or compile the UID of "UUCP" into the code,
**	all of which are reprehensible.
**
**	Assuming all of these fail, we figure out something
**	ourselves.
**
**	Parameters:
**		from -- the person we would like to believe this message
**			is from, as specified on the command line.
**		e -- the envelope in which we would like the sender set.
**		delimptr -- if non-NULL, set to the location of the
**			trailing delimiter.
**		delimchar -- the character that will delimit the sender
**			address.
**		internal -- set if this address is coming from an internal
**			source such as an owner alias.
**
**	Returns:
**		none.
**
**	Side Effects:
**		sets sendmail's notion of who the from person is.
*/

void
setsender(from, e, delimptr, delimchar, internal)
	char *from;
	register ENVELOPE *e;
	char **delimptr;
	int delimchar;
	bool internal;
{
	register char **pvp;
	char *realname = NULL;
	register struct passwd *pw;
	char *bp;
	char buf[MAXNAME + 2];
	char pvpbuf[PSBUFSIZE];
	extern char *FullName;

	if (tTd(45, 1))
		printf("setsender(%s)\n", from == NULL ? "" : from);

	/*
	**  Figure out the real user executing us.
	**	Username can return errno != 0 on non-errors.
	*/

	if (bitset(EF_QUEUERUN, e->e_flags) || OpMode == MD_SMTP ||
	    OpMode == MD_ARPAFTP || OpMode == MD_DAEMON)
		realname = from;
	if (realname == NULL || realname[0] == '\0')
		realname = username();

	if (ConfigLevel < 2)
		SuprErrs = TRUE;

	e->e_from.q_flags = QBADADDR;
	if (from == NULL ||
	    parseaddr(from, &e->e_from, RF_COPYALL|RF_SENDERADDR,
		      delimchar, delimptr, e) == NULL ||
	    bitset(QBADADDR, e->e_from.q_flags) ||
	    e->e_from.q_mailer == ProgMailer ||
	    e->e_from.q_mailer == FileMailer ||
	    e->e_from.q_mailer == InclMailer)
	{
		/* log garbage addresses for traceback */
		if (from != NULL && LogLevel > 2)
		{
			char *p;
			char ebuf[MAXNAME * 2 + 2];

			p = macvalue('_', e);
			if (p == NULL)
			{
				char *host = RealHostName;

				if (host == NULL)
					host = MyHostName;
				(void) snprintf(ebuf, sizeof ebuf, "%.*s@@%.*s",
					MAXNAME, realname,
					MAXNAME, host);
				p = ebuf;
			}
			sm_syslog(LOG_NOTICE, e->e_id,
				"setsender: %s: invalid or unparseable, received from %s",
				shortenstring(from, 83), p);
		}
		if (from != NULL)
		{
			if (!bitset(QBADADDR, e->e_from.q_flags))
			{
				/* it was a bogus mailer in the from addr */
				e->e_status = "5.1.7";
				usrerr("553 Invalid sender address");
			}
			SuprErrs = TRUE;
		}
		if (from == realname ||
		    parseaddr(from = newstr(realname), &e->e_from,
			      RF_COPYALL|RF_SENDERADDR, ' ', NULL, e) == NULL)
		{
			char nbuf[100];

			SuprErrs = TRUE;
			expand("\201n", nbuf, sizeof nbuf, e);
			if (parseaddr(from = newstr(nbuf), &e->e_from,
				      RF_COPYALL, ' ', NULL, e) == NULL &&
			    parseaddr(from = "postmaster", &e->e_from,
			    	      RF_COPYALL, ' ', NULL, e) == NULL)
				syserr("553 setsender: can't even parse postmaster!");
		}
	}
	else
		FromFlag = TRUE;
	e->e_from.q_flags |= QDONTSEND;
	if (tTd(45, 5))
	{
		printf("setsender: QDONTSEND ");
		printaddr(&e->e_from, FALSE);
	}
	SuprErrs = FALSE;

# if USERDB
	if (bitnset(M_CHECKUDB, e->e_from.q_mailer->m_flags))
	{
		register char *p;
		extern char *udbsender __P((char *));

		p = udbsender(e->e_from.q_user);
		if (p != NULL)
			from = p;
	}
# endif /* USERDB */

	if (bitnset(M_HASPWENT, e->e_from.q_mailer->m_flags))
	{
		if (!internal)
		{
			/* if the user already given fullname don't redefine */
			if (FullName == NULL)
				FullName = macvalue('x', e);
			if (FullName != NULL && FullName[0] == '\0')
				FullName = NULL;
		}

		if (e->e_from.q_user[0] != '\0' &&
		    (pw = sm_getpwnam(e->e_from.q_user)) != NULL)
		{
			/*
			**  Process passwd file entry.
			*/

			/* extract home directory */
			if (strcmp(pw->pw_dir, "/") == 0)
				e->e_from.q_home = newstr("");
			else
				e->e_from.q_home = newstr(pw->pw_dir);
			define('z', e->e_from.q_home, e);

			/* extract user and group id */
			e->e_from.q_uid = pw->pw_uid;
			e->e_from.q_gid = pw->pw_gid;
			e->e_from.q_flags |= QGOODUID;

			/* extract full name from passwd file */
			if (FullName == NULL && pw->pw_gecos != NULL &&
			    strcmp(pw->pw_name, e->e_from.q_user) == 0 &&
			    !internal)
			{
				buildfname(pw->pw_gecos, e->e_from.q_user, buf, sizeof buf);
				if (buf[0] != '\0')
					FullName = newstr(buf);
			}
		}
		else
		{
			e->e_from.q_home = "/no/such/directory";
		}
		if (FullName != NULL && !internal)
			define('x', FullName, e);
	}
	else if (!internal && OpMode != MD_DAEMON && OpMode != MD_SMTP)
	{
		if (e->e_from.q_home == NULL)
		{
			e->e_from.q_home = getenv("HOME");
			if (e->e_from.q_home != NULL &&
			    strcmp(e->e_from.q_home, "/") == 0)
				e->e_from.q_home++;
		}
		e->e_from.q_uid = RealUid;
		e->e_from.q_gid = RealGid;
		e->e_from.q_flags |= QGOODUID;
	}

	/*
	**  Rewrite the from person to dispose of possible implicit
	**	links in the net.
	*/

	pvp = prescan(from, delimchar, pvpbuf, sizeof pvpbuf, NULL, NULL);
	if (pvp == NULL)
	{
		/* don't need to give error -- prescan did that already */
		if (LogLevel > 2)
			sm_syslog(LOG_NOTICE, e->e_id,
				"cannot prescan from (%s)",
				shortenstring(from, MAXSHORTSTR));
		finis(TRUE, ExitStat);
	}
	(void) rewrite(pvp, 3, 0, e);
	(void) rewrite(pvp, 1, 0, e);
	(void) rewrite(pvp, 4, 0, e);
	bp = buf + 1;
	cataddr(pvp, NULL, bp, sizeof buf - 2, '\0');
	if (*bp == '@@' && !bitnset(M_NOBRACKET, e->e_from.q_mailer->m_flags))
	{
		/* heuristic: route-addr: add angle brackets */
		strcat(bp, ">");
		*--bp = '<';
	}
	e->e_sender = newstr(bp);
	define('f', e->e_sender, e);

	/* save the domain spec if this mailer wants it */
	if (e->e_from.q_mailer != NULL &&
	    bitnset(M_CANONICAL, e->e_from.q_mailer->m_flags))
	{
		char **lastat;
		extern char **copyplist __P((char **, bool));

		/* get rid of any pesky angle brackets */
		(void) rewrite(pvp, 3, 0, e);
		(void) rewrite(pvp, 1, 0, e);
		(void) rewrite(pvp, 4, 0, e);

		/* strip off to the last "@@" sign */
		for (lastat = NULL; *pvp != NULL; pvp++)
			if (strcmp(*pvp, "@@") == 0)
				lastat = pvp;
		if (lastat != NULL)
		{
			e->e_fromdomain = copyplist(lastat, TRUE);
			if (tTd(45, 3))
			{
				printf("Saving from domain: ");
				printav(e->e_fromdomain);
			}
		}
	}
}
/*
**  PRINTENVFLAGS -- print envelope flags for debugging
**
**	Parameters:
**		e -- the envelope with the flags to be printed.
**
**	Returns:
**		none.
*/

struct eflags
{
	char	*ef_name;
	u_long	ef_bit;
};

struct eflags	EnvelopeFlags[] =
{
	{ "OLDSTYLE",		EF_OLDSTYLE	},
	{ "INQUEUE",		EF_INQUEUE	},
	{ "NO_BODY_RETN",	EF_NO_BODY_RETN	},
	{ "CLRQUEUE",		EF_CLRQUEUE	},
	{ "SENDRECEIPT",	EF_SENDRECEIPT	},
	{ "FATALERRS",		EF_FATALERRS	},
	{ "DELETE_BCC",		EF_DELETE_BCC	},
	{ "RESPONSE",		EF_RESPONSE	},
	{ "RESENT",		EF_RESENT	},
	{ "VRFYONLY",		EF_VRFYONLY	},
	{ "WARNING",		EF_WARNING	},
	{ "QUEUERUN",		EF_QUEUERUN	},
	{ "GLOBALERRS",		EF_GLOBALERRS	},
	{ "PM_NOTIFY",		EF_PM_NOTIFY	},
	{ "METOO",		EF_METOO	},
	{ "LOGSENDER",		EF_LOGSENDER	},
	{ "NORECEIPT",		EF_NORECEIPT	},
	{ "HAS8BIT",		EF_HAS8BIT	},
	{ "NL_NOT_EOL",		EF_NL_NOT_EOL	},
	{ "CRLF_NOT_EOL",	EF_CRLF_NOT_EOL	},
	{ "RET_PARAM",		EF_RET_PARAM	},
	{ "HAS_DF",		EF_HAS_DF	},
	{ "IS_MIME",		EF_IS_MIME	},
	{ "DONT_MIME",		EF_DONT_MIME	},
	{ NULL }
};

void
printenvflags(e)
	register ENVELOPE *e;
{
	register struct eflags *ef;
	bool first = TRUE;

	printf("%lx", e->e_flags);
	for (ef = EnvelopeFlags; ef->ef_name != NULL; ef++)
	{
		if (!bitset(ef->ef_bit, e->e_flags))
			continue;
		if (first)
			printf("<%s", ef->ef_name);
		else
			printf(",%s", ef->ef_name);
		first = FALSE;
	}
	if (!first)
		printf(">\n");
}
@


1.11
log
@sendmail 8.9.3
@
text
@@


1.10
log
@sendmail 8.9.2
@
text
@d14 1
a14 1
static char sccsid[] = "@@(#)envelope.c	8.121 (Berkeley) 12/18/1998";
d803 1
a803 1
	else if (!internal && OpMode != MD_DAEMON)
@


1.9
log
@something hosed the sendmail import; fix up by hand
@
text
@d14 1
a14 1
static char sccsid[] = "@@(#)envelope.c	8.117 (Berkeley) 6/4/98";
d830 1
a830 1
		finis();
@


1.8
log
@sendmail 8.8.7.
@
text
@d2 2
a3 1
 * Copyright (c) 1983, 1995-1997 Eric P. Allman
d7 3
a9 15
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
a10 11
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
d14 1
a14 1
static char sccsid[] = "@@(#)envelope.c	8.105 (Berkeley) 6/24/97";
d89 1
a89 1
		extern void printenvflags();
d325 1
a325 1
			extern void printenvflags();
d400 1
d439 1
d441 1
a441 2
	extern char *ttyname();
	extern void settime();
d748 1
a748 1
		extern char *udbsender();
d829 1
a829 1
				shortenstring(from, 203));
d851 1
a851 1
		extern char **copyplist();
@


1.7
log
@Sendmail 8.8.6.
@
text
@d36 1
a36 1
static char sccsid[] = "@@(#)envelope.c	8.104 (Berkeley) 6/3/97";
d181 1
a181 1
				(void) sendtolist(e->e_from.q_paddr, NULL,
@


1.6
log
@Sendmail 8.8.5.
@
text
@d2 1
a2 1
 * Copyright (c) 1983, 1995, 1996 Eric P. Allman
d36 1
a36 1
static char sccsid[] = "@@(#)envelope.c	8.101 (Berkeley) 12/16/96";
a123 1
#ifdef LOG
d125 2
a126 2
		syslog(LOG_DEBUG, "%s: dropenvelope, e_flags=0x%x, OpMode=%c, pid=%d",
			id == NULL ? "[NOQUEUE]" : id,
a127 1
#endif
d169 3
a171 2
			syslog(LOG_DEBUG, "dropenvelope: %s: q_flags = %x, paddr = %s",
				e->e_id, q->q_flags, q->q_paddr);
d298 2
d314 2
d329 2
d340 3
a355 1
#ifdef LOG
d357 1
a357 2
			syslog(LOG_INFO, "%s: done", id);
#endif
d369 2
a708 1
# ifdef LOG
d726 1
a726 1
			syslog(LOG_NOTICE,
a729 1
# endif /* LOG */
a846 1
# ifdef LOG
d848 2
a849 1
			syslog(LOG_NOTICE, "cannot prescan from (%s)",
a850 1
# endif
@


1.5
log
@Update to Sendmail 8.8.4, plus recent patches, plus OpenBSD support.
Also include entire example configuration subset.
Includes smrsh (using /usr/libexec/sm.bin).

Of the top of my head, the only things I removed from the distribution were
contrib/mail.local.linux, src/Makefiles, all the *.0 and *.ps files.
Our praliases man page replaces the distributed one, ours is better.
@
text
@d36 1
a36 1
static char sccsid[] = "@@(#)envelope.c	8.99 (Berkeley) 12/1/96";
a277 1
		failure_return = TRUE;
d280 4
a283 1
			if (!bitset(QDONTSEND, q->q_flags))
d285 1
d646 2
d659 1
a659 1
setsender(from, e, delimptr, internal)
d663 1
a668 1
	char delimchar;
a690 1
	delimchar = internal ? '\0' : ' ';
@


1.4
log
@bring up to 8.7.6
@
text
@d2 1
a2 1
 * Copyright (c) 1983, 1995 Eric P. Allman
d36 1
a36 1
static char sccsid[] = "@@(#)envelope.c	8.76.1.2 (Berkeley) 9/16/96";
d85 1
d96 1
a96 1
dropenvelope(e)
d98 1
d101 1
d103 1
d113 1
a113 1
		printf("dropenvelope %x: id=", e);
d150 3
d156 12
a167 2
		if (!bitset(QBADADDR|QDONTSEND|QSENT, q->q_flags) ||
		    bitset(QQUEUEUP, q->q_flags))
d169 5
d176 3
a178 2
		if (bitset(QBADADDR, q->q_flags) &&
		    bitset(QPINGONFAILURE, q->q_flags))
d203 1
a203 1
	else if (curtime() > e->e_ctime + TimeOuts.to_q_return[e->e_timeoutclass])
d205 11
a215 8
		(void) snprintf(buf, sizeof buf, "Cannot send message for %s",
			pintvl(TimeOuts.to_q_return[e->e_timeoutclass], FALSE));
		if (e->e_message != NULL)
			free(e->e_message);
		e->e_message = newstr(buf);
		message(buf);
		e->e_flags |= EF_CLRQUEUE;
		failure_return = TRUE;
d221 1
a221 2
			if (bitset(QQUEUEUP, q->q_flags) ||
			    !bitset(QBADADDR|QDONTSEND|QSENT, q->q_flags))
d231 1
a231 13
		bool delay_return = FALSE;

		for (q = e->e_sendqueue; q != NULL; q = q->q_next)
		{
			if (bitset(QQUEUEUP, q->q_flags) &&
			    bitset(QPINGONDELAY, q->q_flags))
			{
				q->q_flags |= QDELAYED;
				delay_return = TRUE;
			}
		}
		if (delay_return &&
		    !bitset(EF_WARNING|EF_RESPONSE, e->e_flags) &&
d239 12
a258 1
			failure_return = TRUE;
d268 2
a269 2
		printf("failure_return=%d success_return=%d queueit=%d\n",
			failure_return, success_return, queueit);
d290 1
a290 7
/*
	if (e->e_receiptto != NULL && bitset(EF_SENDRECEIPT, e->e_flags)
	    && !bitset(PRIV_NORECEIPTS, PrivacyFlags))
*/
	if (e->e_receiptto == NULL)
		e->e_receiptto = e->e_from.q_paddr;
	if (success_return && !failure_return &&
d292 1
a292 1
	    strcmp(e->e_receiptto, "<>") != 0)
d297 2
a298 2
		(void) sendtolist(e->e_receiptto, NULLADDR, &rlist, 0, e);
		(void) returntosender("Return receipt", rlist, FALSE, e);
d306 4
a309 1
	if (failure_return && e->e_errormode != EM_QUIET)
d311 1
d324 1
a324 1
		(void) returntosender(e->e_message, rlist, FALSE, e);
d352 1
a352 1
#ifdef QUEUE
a523 1
	extern char *arpadate();
d572 1
a572 1
	fd = open(p, O_WRONLY|O_CREAT|O_APPEND, 0644);
d778 2
a779 1
		if ((pw = sm_getpwnam(e->e_from.q_user)) != NULL)
d807 4
d903 25
a927 25
	"OLDSTYLE",	EF_OLDSTYLE,
	"INQUEUE",	EF_INQUEUE,
	"NO_BODY_RETN",	EF_NO_BODY_RETN,
	"CLRQUEUE",	EF_CLRQUEUE,
	"SENDRECEIPT",	EF_SENDRECEIPT,
	"FATALERRS",	EF_FATALERRS,
	"DELETE_BCC",	EF_DELETE_BCC,
	"RESPONSE",	EF_RESPONSE,
	"RESENT",	EF_RESENT,
	"VRFYONLY",	EF_VRFYONLY,
	"WARNING",	EF_WARNING,
	"QUEUERUN",	EF_QUEUERUN,
	"GLOBALERRS",	EF_GLOBALERRS,
	"PM_NOTIFY",	EF_PM_NOTIFY,
	"METOO",	EF_METOO,
	"LOGSENDER",	EF_LOGSENDER,
	"NORECEIPT",	EF_NORECEIPT,
	"HAS8BIT",	EF_HAS8BIT,
	"NL_NOT_EOL",	EF_NL_NOT_EOL,
	"CRLF_NOT_EOL",	EF_CRLF_NOT_EOL,
	"RET_PARAM",	EF_RET_PARAM,
	"HAS_DF",	EF_HAS_DF,
	"IS_MIME",	EF_IS_MIME,
	"DONT_MIME",	EF_DONT_MIME,
	NULL
@


1.3
log
@sendmail gecos oflow -- found by mudge, this fix by downsj.  I knew about this
hole a month ago. OpenBSD is not vulnerable because you cannot set a gecos that
long -- bitblt and I fixed chfn & the other tools when we became aware of the
hole; we did not fix sendmail to avoid bringing attention to the sendmail hole
@
text
@d36 1
a36 1
static char sccsid[] = "@@(#)envelope.c	8.76 (Berkeley) 11/11/95";
d182 1
a182 1
		(void) sprintf(buf, "Cannot send message for %s",
d226 1
a226 1
			(void) sprintf(buf,
d455 1
a455 1
	(void) sprintf(pbuf, "%d", getpid());
d459 1
a459 1
	(void) sprintf(cbuf, "%d", e->e_hopcount);
d474 1
a474 1
			(void) strcpy(ybuf, p);
d507 1
a507 1
	(void) sprintf(tbuf, "%04d%02d%02d%02d%02d", tm->tm_year + 1900,
d689 1
a689 1
				(void) sprintf(ebuf, "%.*s@@%.*s",
d780 1
a780 2
				buildfname(pw->pw_gecos, e->e_from.q_user,
				    buf, sizeof buf);
@


1.2
log
@Sendmail 8.7.3 from NetBSD
@
text
@d780 2
a781 1
				buildfname(pw->pw_gecos, e->e_from.q_user, buf);
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
 * Copyright (c) 1983 Eric P. Allman
d36 1
a36 1
static char sccsid[] = "@@(#)envelope.c	8.34.1.1 (Berkeley) 2/28/95";
a39 1
#include <pwd.h>
a61 3
	extern putheader(), putbody();
	extern ENVELOPE BlankEnvelope;

d99 2
a100 1
	bool saveit = bitset(EF_FATALERRS, e->e_flags);
d107 2
d111 2
a112 1
		printf(", flags=0x%x\n", e->e_flags);
d120 7
d131 4
a134 1
#ifdef LOG
a136 4
	if (LogLevel > 84)
		syslog(LOG_DEBUG, "dropenvelope, id=%s, flags=0x%x, pid=%d",
				  id, e->e_flags, getpid());
#endif /* LOG */
d149 2
a150 1
		if (bitset(QQUEUEUP, q->q_flags))
d152 4
a155 2
		if (!bitset(QDONTSEND, q->q_flags) &&
		    bitset(QBADADDR, q->q_flags))
d157 2
a158 2
			if (q->q_owner == NULL &&
			    strcmp(e->e_from.q_paddr, "<>") != 0)
d160 8
a167 1
						  &e->e_errorqueue, e);
d171 3
d180 1
a180 1
	else if (curtime() > e->e_ctime + TimeOuts.to_q_return)
d183 1
a183 1
			pintvl(TimeOuts.to_q_return, FALSE));
d189 1
a189 1
		saveit = TRUE;
d191 1
a191 1
			pintvl(TimeOuts.to_q_return, FALSE));
d195 3
a197 1
			if (bitset(QQUEUEUP, q->q_flags))
d199 2
d203 2
a204 2
	else if (TimeOuts.to_q_warning > 0 &&
	    curtime() > e->e_ctime + TimeOuts.to_q_warning)
d206 13
a218 1
		if (!bitset(EF_WARNING|EF_RESPONSE, e->e_flags) &&
d220 5
a224 1
		    strcmp(e->e_from.q_paddr, "<>") != 0)
d227 2
a228 2
				"warning: cannot send message for %s",
				pintvl(TimeOuts.to_q_warning, FALSE));
d234 1
a234 1
			saveit = TRUE;
d238 1
a238 1
			pintvl(TimeOuts.to_q_warning, FALSE));
d240 15
a254 1
			pintvl(TimeOuts.to_q_return, FALSE));
d257 2
a258 2
			if (bitset(QQUEUEUP, q->q_flags))
				q->q_flags |= QREPORT;
d266 1
d269 6
d278 2
a279 1
		(void) sendtolist(e->e_receiptto, NULLADDR, &rlist, e);
a280 1
		e->e_flags &= ~EF_SENDRECEIPT;
d282 1
d288 2
a289 2
	if (saveit && e->e_errormode != EM_QUIET)
		savemail(e);
d295 2
a296 1
	if (bitset(EF_PM_NOTIFY, e->e_flags) && PostMasterCopy != NULL &&
d301 1
a301 1
		(void) sendtolist(PostMasterCopy, NULLADDR, &rlist, e);
d309 2
a310 2
	if ((!queueit && !bitset(EF_KEEPQUEUE, e->e_flags)) ||
	    bitset(EF_CLRQUEUE, e->e_flags))
d313 8
a320 3
			printf("\n===== Dropping [dq]f%s =====\n\n", e->e_id);
		if (e->e_df != NULL)
			xunlink(e->e_df);
d331 1
a331 1
		queueup(e, bitset(EF_KEEPQUEUE, e->e_flags), FALSE);
d343 1
a343 1
		(void) xfclose(e->e_dfp, "dropenvelope", e->e_df);
d345 2
a346 1
	e->e_id = e->e_df = NULL;
d383 1
a383 1
			(void) xfclose(e->e_dfp, "clearenvelope dfp", e->e_df);
a429 1
	extern char Version[];
a560 1
	{
d562 5
a566 1
	}
a645 1
	extern struct passwd *getpwnam();
d686 1
d689 3
a691 1
				(void) sprintf(ebuf, "%s@@%s", realname, host);
d704 1
d716 1
a716 1
			expand("\201n", nbuf, &nbuf[sizeof nbuf], e);
d734 2
a735 2
	pvp = NULL;
	if (e->e_from.q_mailer == LocalMailer)
a736 1
# ifdef USERDB
a738 1
# endif
d740 8
d750 1
a750 1
			/* if the user has given fullname already, don't redefine */
a754 13

# ifdef USERDB
			p = udbsender(e->e_from.q_user);

			if (p != NULL)
			{
				/*
				**  We have an alternate address for the sender
				*/

				pvp = prescan(p, '\0', pvpbuf, sizeof pvpbuf, NULL);
			}
# endif /* USERDB */
d757 1
a757 1
		if ((pw = getpwnam(e->e_from.q_user)) != NULL)
d807 1
a807 2
	if (pvp == NULL)
		pvp = prescan(from, delimchar, pvpbuf, sizeof pvpbuf, NULL);
d813 2
a814 1
			syslog(LOG_NOTICE, "cannot prescan from (%s)", from);
d823 1
a823 1
	if (*bp == '@@')
d836 1
d839 82
a920 4
		while (*pvp != NULL && strcmp(*pvp, "@@") != 0)
			pvp++;
		if (*pvp != NULL)
			e->e_fromdomain = copyplist(pvp, TRUE);
d922 2
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@


1.1.1.2
log
@sendmail 8.9.1
@
text
@d2 1
a2 2
 * Copyright (c) 1998 Sendmail, Inc.  All rights reserved.
 * Copyright (c) 1983, 1995-1997 Eric P. Allman.  All rights reserved.
d6 15
a20 3
 * By using this file, you agree to the terms and conditions set
 * forth in the LICENSE file which can be found at the top level of
 * the sendmail distribution.
d22 11
d36 1
a36 1
static char sccsid[] = "@@(#)envelope.c	8.117 (Berkeley) 6/4/98";
d40 1
d63 3
a88 1
**		fulldrop -- if set, do return receipts.
d99 1
a99 1
dropenvelope(e, fulldrop)
a100 1
	bool fulldrop;
d103 1
a103 4
	bool message_timeout = FALSE;
	bool failure_return = FALSE;
	bool delay_return = FALSE;
	bool success_return = FALSE;
d110 1
a110 3
		extern void printenvflags __P((ENVELOPE *));

		printf("dropenvelope %lx: id=", (u_long) e);
d112 1
a112 2
		printf(", flags=");
		printenvflags(e);
a119 5
	if (LogLevel > 84)
		sm_syslog(LOG_DEBUG, id,
			"dropenvelope, e_flags=0x%x, OpMode=%c, pid=%d",
			e->e_flags, OpMode, getpid());

d124 1
a124 4
	/* if verify-only mode, we can skip most of this */
	if (OpMode == MD_VERIFY)
		goto simpledrop;

d127 4
a139 3
	if (curtime() > e->e_ctime + TimeOuts.to_q_return[e->e_timeoutclass])
		message_timeout = TRUE;

d143 1
a143 12
		if (bitset(QQUEUEUP, q->q_flags) &&
		    bitset(QDONTSEND, q->q_flags))
		{
			/* I'm not sure how this happens..... */
			if (tTd(50, 2))
			{
				printf("Bogus flags: ");
				printaddr(q, FALSE);
			}
			q->q_flags &= ~QDONTSEND;
		}
		if (!bitset(QBADADDR|QDONTSEND|QSENT, q->q_flags))
d145 2
a146 21
#if XDEBUG
		else if (bitset(QQUEUEUP, q->q_flags))
			sm_syslog(LOG_DEBUG, e->e_id,
				"dropenvelope: q_flags = %x, paddr = %s",
				q->q_flags, q->q_paddr);
#endif

		/* see if a notification is needed */
		if (bitset(QPINGONFAILURE, q->q_flags) &&
		    ((message_timeout && bitset(QQUEUEUP, q->q_flags)) ||
		     bitset(QBADADDR, q->q_flags)))
		{
			failure_return = TRUE;
			if (q->q_owner == NULL && !emptyaddr(&e->e_from))
				(void) sendtolist(e->e_from.q_paddr, NULLADDR,
						  &e->e_errorqueue, 0, e);
		}
		else if (bitset(QPINGONSUCCESS, q->q_flags) &&
			 ((bitset(QSENT, q->q_flags) &&
			   bitnset(M_LOCALMAILER, q->q_mailer->m_flags)) ||
			  bitset(QRELAYED|QEXPANDED|QDELIVERED, q->q_flags)))
d148 4
a151 1
			success_return = TRUE;
a154 3
	if (e->e_class < 0)
		e->e_flags |= EF_NO_BODY_RETN;

d161 1
a161 1
	else if (message_timeout)
d163 8
a170 11
		if (failure_return)
		{
			(void) snprintf(buf, sizeof buf,
				"Cannot send message within %s",
				pintvl(TimeOuts.to_q_return[e->e_timeoutclass], FALSE));
			if (e->e_message != NULL)
				free(e->e_message);
			e->e_message = newstr(buf);
			message(buf);
			e->e_flags |= EF_CLRQUEUE;
		}
d172 1
a172 1
			pintvl(TimeOuts.to_q_return[e->e_timeoutclass], FALSE));
d176 1
a176 2
			if (!bitset(QBADADDR|QDONTSEND|QSENT, q->q_flags))
			{
a177 2
				q->q_status = "4.4.7";
			}
d180 2
a181 2
	else if (TimeOuts.to_q_warning[e->e_timeoutclass] > 0 &&
	    curtime() > e->e_ctime + TimeOuts.to_q_warning[e->e_timeoutclass])
d185 1
a185 17
		    e->e_from.q_paddr != NULL &&
		    strcmp(e->e_from.q_paddr, "<>") != 0 &&
		    strncasecmp(e->e_from.q_paddr, "owner-", 6) != 0 &&
		    (strlen(e->e_from.q_paddr) <= (SIZE_T) 8 ||
		     strcasecmp(&e->e_from.q_paddr[strlen(e->e_from.q_paddr) - 8], "-request") != 0))
		{
			for (q = e->e_sendqueue; q != NULL; q = q->q_next)
			{
				if (bitset(QQUEUEUP, q->q_flags) &&
				    bitset(QPINGONDELAY, q->q_flags))
				{
					q->q_flags |= QDELAYED;
					delay_return = TRUE;
				}
			}
		}
		if (delay_return)
d187 3
a189 3
			(void) snprintf(buf, sizeof buf,
				"Warning: could not send message for past %s",
				pintvl(TimeOuts.to_q_warning[e->e_timeoutclass], FALSE));
d195 1
d199 1
a199 1
			pintvl(TimeOuts.to_q_warning[e->e_timeoutclass], FALSE));
d201 1
a201 14
			pintvl(TimeOuts.to_q_return[e->e_timeoutclass], FALSE));
	}

	if (tTd(50, 2))
		printf("failure_return=%d delay_return=%d success_return=%d queueit=%d\n",
			failure_return, delay_return, success_return, queueit);

	/*
	**  If we had some fatal error, but no addresses are marked as
	**  bad, mark them _all_ as bad.
	*/

	if (bitset(EF_FATALERRS, e->e_flags) && !failure_return)
	{
d204 2
a205 6
			if (!bitset(QDONTSEND, q->q_flags) &&
			    bitset(QPINGONFAILURE, q->q_flags))
			{
				failure_return = TRUE;
				q->q_flags |= QBADADDR;
			}
d213 2
a214 3
	if (success_return && !failure_return && !delay_return && fulldrop &&
	    !bitset(PRIV_NORECEIPTS, PrivacyFlags) &&
	    strcmp(e->e_from.q_paddr, "<>") != 0)
d218 3
a220 5
		if (tTd(50, 8))
			printf("dropenvelope(%s): sending return receipt\n", id);
		e->e_flags |= EF_SENDRECEIPT;
		(void) sendtolist(e->e_from.q_paddr, NULLADDR, &rlist, 0, e);
		(void) returntosender("Return receipt", rlist, RTSF_NO_BODY, e);
a221 1
	e->e_flags &= ~EF_SENDRECEIPT;
d227 2
a228 8
	if ((failure_return || delay_return) && e->e_errormode != EM_QUIET)
	{
		extern void savemail __P((ENVELOPE *, bool));

		if (tTd(50, 8))
			printf("dropenvelope(%s): saving mail\n", id);
		savemail(e, !bitset(EF_NO_BODY_RETN, e->e_flags));
	}
d234 1
a234 2
	if ((failure_return || bitset(EF_PM_NOTIFY, e->e_flags)) &&
	    PostMasterCopy != NULL &&
d239 2
a240 4
		if (tTd(50, 8))
			printf("dropenvelope(%s): sending postmaster copy\n", id);
		(void) sendtolist(PostMasterCopy, NULLADDR, &rlist, 0, e);
		(void) returntosender(e->e_message, rlist, RTSF_PM_BOUNCE, e);
d247 2
a248 5
simpledrop:
	if (tTd(50, 8))
		printf("dropenvelope(%s): at simpledrop, queueit=%d\n",
			id, queueit);
	if (!queueit || bitset(EF_CLRQUEUE, e->e_flags))
d251 3
a253 8
		{
			extern void printenvflags __P((ENVELOPE *));

			printf("\n===== Dropping [dq]f%s... queueit=%d, e_flags=",
				e->e_id, queueit);
			printenvflags(e);
		}
		xunlink(queuename(e, 'd'));
d256 1
d258 2
a259 1
			sm_syslog(LOG_INFO, id, "done");
d263 2
a264 2
#if QUEUE
		queueup(e, FALSE);
a270 2
	if (tTd(50, 8))
		printf("dropenvelope(%s): unlocking job\n", id);
d276 1
a276 1
		(void) xfclose(e->e_dfp, "dropenvelope df", e->e_id);
d278 1
a278 2
	e->e_id = NULL;
	e->e_flags &= ~EF_HAS_DF;
d315 1
a315 1
			(void) xfclose(e->e_dfp, "clearenvelope dfp", e->e_id);
a320 1
	e->e_message = NULL;
d359 1
d361 2
a362 2
#endif /* TTYNAME */
	extern void settime __P((ENVELOPE *));
d388 1
a388 1
	(void) snprintf(pbuf, sizeof pbuf, "%d", getpid());
d392 1
a392 1
	(void) snprintf(cbuf, sizeof cbuf, "%d", e->e_hopcount);
d407 1
a407 1
			snprintf(ybuf, sizeof ybuf, "%s", p);
d435 1
d440 1
a440 1
	(void) snprintf(tbuf, sizeof tbuf, "%04d%02d%02d%02d%02d", tm->tm_year + 1900,
d484 1
a484 1
	fd = open(p, O_WRONLY|O_CREAT|O_APPEND, FileMode);
d494 1
d496 1
a496 5
#ifdef HASSETVBUF
	setvbuf(e->e_xfp, NULL, _IOLBF, 0);
#else
	setlinebuf(e->e_xfp);
#endif
a551 2
**		delimchar -- the character that will delimit the sender
**			address.
d563 1
a563 1
setsender(from, e, delimptr, delimchar, internal)
a566 1
	int delimchar;
d572 1
d576 1
d596 1
d607 1
a616 1

d619 1
a619 3
				(void) snprintf(ebuf, sizeof ebuf, "%.*s@@%.*s",
					MAXNAME, realname,
					MAXNAME, host);
d622 1
a622 1
			sm_syslog(LOG_NOTICE, e->e_id,
d626 1
a631 1
				e->e_status = "5.1.7";
d643 1
a643 1
			expand("\201n", nbuf, sizeof nbuf, e);
d661 2
a662 2
# if USERDB
	if (bitnset(M_CHECKUDB, e->e_from.q_mailer->m_flags))
d664 1
d666 2
a667 7
		extern char *udbsender __P((char *));

		p = udbsender(e->e_from.q_user);
		if (p != NULL)
			from = p;
	}
# endif /* USERDB */
a668 2
	if (bitnset(M_HASPWENT, e->e_from.q_mailer->m_flags))
	{
d671 1
a671 1
			/* if the user already given fullname don't redefine */
d676 13
d691 1
a691 2
		if (e->e_from.q_user[0] != '\0' &&
		    (pw = sm_getpwnam(e->e_from.q_user)) != NULL)
d714 1
a714 1
				buildfname(pw->pw_gecos, e->e_from.q_user, buf, sizeof buf);
a718 4
		else
		{
			e->e_from.q_home = "/no/such/directory";
		}
d741 2
a742 1
	pvp = prescan(from, delimchar, pvpbuf, sizeof pvpbuf, NULL, NULL);
d746 1
d748 2
a749 3
			sm_syslog(LOG_NOTICE, e->e_id,
				"cannot prescan from (%s)",
				shortenstring(from, MAXSHORTSTR));
d757 1
a757 1
	if (*bp == '@@' && !bitnset(M_NOBRACKET, e->e_from.q_mailer->m_flags))
d770 1
a770 67
		char **lastat;
		extern char **copyplist __P((char **, bool));

		/* get rid of any pesky angle brackets */
		(void) rewrite(pvp, 3, 0, e);
		(void) rewrite(pvp, 1, 0, e);
		(void) rewrite(pvp, 4, 0, e);

		/* strip off to the last "@@" sign */
		for (lastat = NULL; *pvp != NULL; pvp++)
			if (strcmp(*pvp, "@@") == 0)
				lastat = pvp;
		if (lastat != NULL)
		{
			e->e_fromdomain = copyplist(lastat, TRUE);
			if (tTd(45, 3))
			{
				printf("Saving from domain: ");
				printav(e->e_fromdomain);
			}
		}
	}
}
/*
**  PRINTENVFLAGS -- print envelope flags for debugging
**
**	Parameters:
**		e -- the envelope with the flags to be printed.
**
**	Returns:
**		none.
*/

struct eflags
{
	char	*ef_name;
	u_long	ef_bit;
};

struct eflags	EnvelopeFlags[] =
{
	{ "OLDSTYLE",		EF_OLDSTYLE	},
	{ "INQUEUE",		EF_INQUEUE	},
	{ "NO_BODY_RETN",	EF_NO_BODY_RETN	},
	{ "CLRQUEUE",		EF_CLRQUEUE	},
	{ "SENDRECEIPT",	EF_SENDRECEIPT	},
	{ "FATALERRS",		EF_FATALERRS	},
	{ "DELETE_BCC",		EF_DELETE_BCC	},
	{ "RESPONSE",		EF_RESPONSE	},
	{ "RESENT",		EF_RESENT	},
	{ "VRFYONLY",		EF_VRFYONLY	},
	{ "WARNING",		EF_WARNING	},
	{ "QUEUERUN",		EF_QUEUERUN	},
	{ "GLOBALERRS",		EF_GLOBALERRS	},
	{ "PM_NOTIFY",		EF_PM_NOTIFY	},
	{ "METOO",		EF_METOO	},
	{ "LOGSENDER",		EF_LOGSENDER	},
	{ "NORECEIPT",		EF_NORECEIPT	},
	{ "HAS8BIT",		EF_HAS8BIT	},
	{ "NL_NOT_EOL",		EF_NL_NOT_EOL	},
	{ "CRLF_NOT_EOL",	EF_CRLF_NOT_EOL	},
	{ "RET_PARAM",		EF_RET_PARAM	},
	{ "HAS_DF",		EF_HAS_DF	},
	{ "IS_MIME",		EF_IS_MIME	},
	{ "DONT_MIME",		EF_DONT_MIME	},
	{ NULL }
};
d772 4
a775 17
void
printenvflags(e)
	register ENVELOPE *e;
{
	register struct eflags *ef;
	bool first = TRUE;

	printf("%lx", e->e_flags);
	for (ef = EnvelopeFlags; ef->ef_name != NULL; ef++)
	{
		if (!bitset(ef->ef_bit, e->e_flags))
			continue;
		if (first)
			printf("<%s", ef->ef_name);
		else
			printf(",%s", ef->ef_name);
		first = FALSE;
a776 2
	if (!first)
		printf(">\n");
@

