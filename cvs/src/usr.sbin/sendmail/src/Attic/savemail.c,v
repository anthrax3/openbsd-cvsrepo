head	1.12;
access;
symbols
	OPENBSD_2_6:1.11.0.4
	OPENBSD_2_6_BASE:1.11
	OPENBSD_2_5:1.11.0.2
	OPENBSD_2_5_BASE:1.11
	OPENBSD_2_4:1.9.0.2
	OPENBSD_2_4_BASE:1.9
	sendmail_8_9_1:1.1.1.2
	UCB:1.1.1
	OPENBSD_2_3:1.8.0.2
	OPENBSD_2_3_BASE:1.8
	OPENBSD_2_2:1.7.0.2
	OPENBSD_2_2_BASE:1.7
	OPENBSD_2_1:1.5.0.2
	OPENBSD_2_1_BASE:1.5
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.12
date	2000.04.18.04.57.25;	author millert;	state dead;
branches;
next	1.11;

1.11
date	99.02.05.05.59.34;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	99.01.01.20.33.58;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	98.07.12.19.45.08;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	97.11.09.04.05.45;	author gene;	state Exp;
branches;
next	1.7;

1.7
date	97.08.04.02.17.58;	author downsj;	state Exp;
branches;
next	1.6;

1.6
date	97.07.15.07.24.14;	author downsj;	state Exp;
branches;
next	1.5;

1.5
date	97.01.22.01.07.20;	author downsj;	state Exp;
branches;
next	1.4;

1.4
date	96.12.14.21.17.36;	author downsj;	state Exp;
branches;
next	1.3;

1.3
date	96.09.19.06.45.04;	author fn;	state Exp;
branches;
next	1.2;

1.2
date	96.01.29.01.44.27;	author dm;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.48.19;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.48.19;	author deraadt;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	98.07.12.17.10.35;	author millert;	state Exp;
branches;
next	;


desc
@@


1.12
log
@remove sendmail 8.9.3
@
text
@/*
 * Copyright (c) 1998 Sendmail, Inc.  All rights reserved.
 * Copyright (c) 1983, 1995-1997 Eric P. Allman.  All rights reserved.
 * Copyright (c) 1988, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * By using this file, you agree to the terms and conditions set
 * forth in the LICENSE file which can be found at the top level of
 * the sendmail distribution.
 *
 */

#ifndef lint
static char sccsid[] = "@@(#)savemail.c	8.140 (Berkeley) 1/18/1999";
#endif /* not lint */

# include "sendmail.h"

/*
**  SAVEMAIL -- Save mail on error
**
**	If mailing back errors, mail it back to the originator
**	together with an error message; otherwise, just put it in
**	dead.letter in the user's home directory (if he exists on
**	this machine).
**
**	Parameters:
**		e -- the envelope containing the message in error.
**		sendbody -- if TRUE, also send back the body of the
**			message; otherwise just send the header.
**
**	Returns:
**		none
**
**	Side Effects:
**		Saves the letter, by writing or mailing it back to the
**		sender, or by putting it in dead.letter in her home
**		directory.
*/

/* defines for state machine */
# define ESM_REPORT	0	/* report to sender's terminal */
# define ESM_MAIL	1	/* mail back to sender */
# define ESM_QUIET	2	/* messages have already been returned */
# define ESM_DEADLETTER	3	/* save in ~/dead.letter */
# define ESM_POSTMASTER	4	/* return to postmaster */
# define ESM_USRTMP	5	/* save in /usr/tmp/dead.letter */
# define ESM_PANIC	6	/* leave the locked queue/transcript files */
# define ESM_DONE	7	/* the message is successfully delivered */


void
savemail(e, sendbody)
	register ENVELOPE *e;
	bool sendbody;
{
	register struct passwd *pw;
	register FILE *fp;
	int state;
	auto ADDRESS *q = NULL;
	register char *p;
	MCI mcibuf;
	int flags;
	char buf[MAXLINE+1];
	extern char *ttypath __P((void));
	extern bool writable __P((char *, ADDRESS *, int));

	if (tTd(6, 1))
	{
		printf("\nsavemail, errormode = %c, id = %s, ExitStat = %d\n  e_from=",
			e->e_errormode, e->e_id == NULL ? "NONE" : e->e_id,
			ExitStat);
		printaddr(&e->e_from, FALSE);
	}

	if (e->e_id == NULL)
	{
		/* can't return a message with no id */
		return;
	}

	/*
	**  In the unhappy event we don't know who to return the mail
	**  to, make someone up.
	*/

	if (e->e_from.q_paddr == NULL)
	{
		e->e_sender = "Postmaster";
		if (parseaddr(e->e_sender, &e->e_from,
			      RF_COPYPARSE|RF_SENDERADDR, '\0', NULL, e) == NULL)
		{
			syserr("553 Cannot parse Postmaster!");
			finis(TRUE, EX_SOFTWARE);
		}
	}
	e->e_to = NULL;

	/*
	**  Basic state machine.
	**
	**	This machine runs through the following states:
	**
	**	ESM_QUIET	Errors have already been printed iff the
	**			sender is local.
	**	ESM_REPORT	Report directly to the sender's terminal.
	**	ESM_MAIL	Mail response to the sender.
	**	ESM_DEADLETTER	Save response in ~/dead.letter.
	**	ESM_POSTMASTER	Mail response to the postmaster.
	**	ESM_PANIC	Save response anywhere possible.
	*/

	/* determine starting state */
	switch (e->e_errormode)
	{
	  case EM_WRITE:
		state = ESM_REPORT;
		break;

	  case EM_BERKNET:
	  case EM_MAIL:
		state = ESM_MAIL;
		break;

	  case EM_PRINT:
	  case '\0':
		state = ESM_QUIET;
		break;

	  case EM_QUIET:
		/* no need to return anything at all */
		return;

	  default:
		syserr("554 savemail: bogus errormode x%x\n", e->e_errormode);
		state = ESM_MAIL;
		break;
	}

	/* if this is already an error response, send to postmaster */
	if (bitset(EF_RESPONSE, e->e_flags))
	{
		if (e->e_parent != NULL &&
		    bitset(EF_RESPONSE, e->e_parent->e_flags))
		{
			/* got an error sending a response -- can it */
			return;
		}
		state = ESM_POSTMASTER;
	}

	while (state != ESM_DONE)
	{
		if (tTd(6, 5))
			printf("  state %d\n", state);

		switch (state)
		{
		  case ESM_QUIET:
			if (bitnset(M_LOCALMAILER, e->e_from.q_mailer->m_flags))
				state = ESM_DEADLETTER;
			else
				state = ESM_MAIL;
			break;

		  case ESM_REPORT:

			/*
			**  If the user is still logged in on the same terminal,
			**  then write the error messages back to hir (sic).
			*/

			p = ttypath();
			if (p == NULL || freopen(p, "w", stdout) == NULL)
			{
				state = ESM_MAIL;
				break;
			}

			expand("\201n", buf, sizeof buf, e);
			printf("\r\nMessage from %s...\r\n", buf);
			printf("Errors occurred while sending mail.\r\n");
			if (e->e_xfp != NULL)
			{
				(void) fflush(e->e_xfp);
				fp = fopen(queuename(e, 'x'), "r");
			}
			else
				fp = NULL;
			if (fp == NULL)
			{
				syserr("Cannot open %s", queuename(e, 'x'));
				printf("Transcript of session is unavailable.\r\n");
			}
			else
			{
				printf("Transcript follows:\r\n");
				while (fgets(buf, sizeof buf, fp) != NULL &&
				       !ferror(stdout))
					fputs(buf, stdout);
				(void) xfclose(fp, "savemail transcript", e->e_id);
			}
			printf("Original message will be saved in dead.letter.\r\n");
			state = ESM_DEADLETTER;
			break;

		  case ESM_MAIL:
			/*
			**  If mailing back, do it.
			**	Throw away all further output.  Don't alias,
			**	since this could cause loops, e.g., if joe
			**	mails to joe@@x, and for some reason the network
			**	for @@x is down, then the response gets sent to
			**	joe@@x, which gives a response, etc.  Also force
			**	the mail to be delivered even if a version of
			**	it has already been sent to the sender.
			**
			**  If this is a configuration or local software
			**	error, send to the local postmaster as well,
			**	since the originator can't do anything
			**	about it anyway.  Note that this is a full
			**	copy of the message (intentionally) so that
			**	the Postmaster can forward things along.
			*/

			if (ExitStat == EX_CONFIG || ExitStat == EX_SOFTWARE)
			{
				(void) sendtolist("postmaster",
					  NULLADDR, &e->e_errorqueue, 0, e);
			}
			if (!emptyaddr(&e->e_from))
			{
				char from[TOBUFSIZE];
				extern bool pruneroute __P((char *));

				if (strlen(e->e_from.q_paddr) + 1 > sizeof from)
				{
					state = ESM_POSTMASTER;
					break;
				}
				strcpy(from, e->e_from.q_paddr);

				if (!DontPruneRoutes && pruneroute(from))
				{
					ADDRESS *a;

					for (a = e->e_errorqueue; a != NULL;
					     a = a->q_next)
					{
						if (sameaddr(a, &e->e_from))
							a->q_flags |= QDONTSEND;
					}
				}
				(void) sendtolist(from, NULLADDR,
						  &e->e_errorqueue, 0, e);
			}

			/*
			**  Deliver a non-delivery report to the
			**  Postmaster-designate (not necessarily
			**  Postmaster).  This does not include the
			**  body of the message, for privacy reasons.
			**  You really shouldn't need this.
			*/

			e->e_flags |= EF_PM_NOTIFY;

			/* check to see if there are any good addresses */
			for (q = e->e_errorqueue; q != NULL; q = q->q_next)
				if (!bitset(QBADADDR|QDONTSEND, q->q_flags))
					break;
			if (q == NULL)
			{
				/* this is an error-error */
				state = ESM_POSTMASTER;
				break;
			}
			if (returntosender(e->e_message, e->e_errorqueue,
					   sendbody ? RTSF_SEND_BODY
						    : RTSF_NO_BODY,
					   e) == 0)
			{
				state = ESM_DONE;
				break;
			}

			/* didn't work -- return to postmaster */
			state = ESM_POSTMASTER;
			break;

		  case ESM_POSTMASTER:
			/*
			**  Similar to previous case, but to system postmaster.
			*/

			q = NULL;
			if (sendtolist(DoubleBounceAddr,
				NULLADDR, &q, 0, e) <= 0)
			{
				syserr("553 cannot parse %s!", DoubleBounceAddr);
				ExitStat = EX_SOFTWARE;
				state = ESM_USRTMP;
				break;
			}
			flags = RTSF_PM_BOUNCE;
			if (sendbody)
				flags |= RTSF_SEND_BODY;
			if (returntosender(e->e_message, q, flags, e) == 0)
			{
				state = ESM_DONE;
				break;
			}

			/* didn't work -- last resort */
			state = ESM_USRTMP;
			break;

		  case ESM_DEADLETTER:
			/*
			**  Save the message in dead.letter.
			**	If we weren't mailing back, and the user is
			**	local, we should save the message in
			**	~/dead.letter so that the poor person doesn't
			**	have to type it over again -- and we all know
			**	what poor typists UNIX users are.
			*/

			p = NULL;
			if (bitnset(M_HASPWENT, e->e_from.q_mailer->m_flags))
			{
				if (e->e_from.q_home != NULL)
					p = e->e_from.q_home;
				else if ((pw = sm_getpwnam(e->e_from.q_user)) != NULL)
					p = pw->pw_dir;
			}
			if (p == NULL || e->e_dfp == NULL)
			{
				/* no local directory or no data file */
				state = ESM_MAIL;
				break;
			}

			/* we have a home directory; write dead.letter */
			define('z', p, e);
			expand("\201z/dead.letter", buf, sizeof buf, e);
			flags = SFF_CREAT|SFF_REGONLY|SFF_RUNASREALUID;
			if (RealUid == 0)
				flags |= SFF_ROOTOK;
			e->e_to = buf;
			if (mailfile(buf, FileMailer, NULL, flags, e) == EX_OK)
			{
				int oldverb = Verbose;

				Verbose = 1;
				message("Saved message in %s", buf);
				Verbose = oldverb;
				state = ESM_DONE;
				break;
			}
			state = ESM_MAIL;
			break;

		  case ESM_USRTMP:
			/*
			**  Log the mail in /usr/tmp/dead.letter.
			*/

			if (e->e_class < 0)
			{
				state = ESM_DONE;
				break;
			}

			if ((SafeFileEnv != NULL && SafeFileEnv[0] != '\0') ||
			    DeadLetterDrop == NULL || DeadLetterDrop[0] == '\0')
			{
				state = ESM_PANIC;
				break;
			}

			flags = SFF_CREAT|SFF_REGONLY|SFF_ROOTOK|SFF_OPENASROOT|SFF_MUSTOWN;
			if (!writable(DeadLetterDrop, NULL, flags) ||
			    (fp = safefopen(DeadLetterDrop, O_WRONLY|O_APPEND,
					    FileMode, flags)) == NULL)
			{
				state = ESM_PANIC;
				break;
			}

			bzero(&mcibuf, sizeof mcibuf);
			mcibuf.mci_out = fp;
			mcibuf.mci_mailer = FileMailer;
			if (bitnset(M_7BITS, FileMailer->m_flags))
				mcibuf.mci_flags |= MCIF_7BIT;
			mcibuf.mci_contentlen = 0;

			putfromline(&mcibuf, e);
			(*e->e_puthdr)(&mcibuf, e->e_header, e, M87F_OUTER);
			(*e->e_putbody)(&mcibuf, e, NULL);
			putline("\n", &mcibuf);
			(void) fflush(fp);
			if (ferror(fp))
				state = ESM_PANIC;
			else
			{
				int oldverb = Verbose;

				Verbose = 1;
				message("Saved message in %s", DeadLetterDrop);
				Verbose = oldverb;
				if (LogLevel > 3)
					sm_syslog(LOG_NOTICE, e->e_id,
						"Saved message in %s",
						DeadLetterDrop);
				state = ESM_DONE;
			}
			(void) xfclose(fp, "savemail", DeadLetterDrop);
			break;

		  default:
			syserr("554 savemail: unknown state %d", state);

			/* fall through ... */

		  case ESM_PANIC:
			/* leave the locked queue & transcript files around */
			loseqfile(e, "savemail panic");
			syserr("!554 savemail: cannot save rejected email anywhere");
		}
	}
}
/*
**  RETURNTOSENDER -- return a message to the sender with an error.
**
**	Parameters:
**		msg -- the explanatory message.
**		returnq -- the queue of people to send the message to.
**		flags -- flags tweaking the operation:
**			RTSF_SENDBODY -- include body of message (otherwise
**				just send the header).
**			RTSF_PMBOUNCE -- this is a postmaster bounce.
**		e -- the current envelope.
**
**	Returns:
**		zero -- if everything went ok.
**		else -- some error.
**
**	Side Effects:
**		Returns the current message to the sender via
**		mail.
*/

#define MAXRETURNS	6	/* max depth of returning messages */
#define ERRORFUDGE	100	/* nominal size of error message text */

int
returntosender(msg, returnq, flags, e)
	char *msg;
	ADDRESS *returnq;
	int flags;
	register ENVELOPE *e;
{
	register ENVELOPE *ee;
	ENVELOPE *oldcur = CurEnv;
	ENVELOPE errenvelope;
	static int returndepth = 0;
	register ADDRESS *q;
	char *p;
	char buf[MAXNAME + 1];
	extern void errbody __P((MCI *, ENVELOPE *, char *));

	if (returnq == NULL)
		return (-1);

	if (msg == NULL)
		msg = "Unable to deliver mail";

	if (tTd(6, 1))
	{
		printf("\n*** Return To Sender: msg=\"%s\", depth=%d, e=%lx, returnq=",
		       msg, returndepth, (u_long) e);
		printaddr(returnq, TRUE);
		if (tTd(6, 20))
		{
			printf("Sendq=");
			printaddr(e->e_sendqueue, TRUE);
		}
	}

	if (++returndepth >= MAXRETURNS)
	{
		if (returndepth != MAXRETURNS)
			syserr("554 returntosender: infinite recursion on %s", returnq->q_paddr);
		/* don't "unrecurse" and fake a clean exit */
		/* returndepth--; */
		return (0);
	}

	define('g', e->e_from.q_paddr, e);
	define('u', NULL, e);

	/* initialize error envelope */
	ee = newenvelope(&errenvelope, e);
	define('a', "\201b", ee);
	define('r', "internal", ee);
	define('s', "localhost", ee);
	define('_', "localhost", ee);
	ee->e_puthdr = putheader;
	ee->e_putbody = errbody;
	ee->e_flags |= EF_RESPONSE|EF_METOO;
	if (!bitset(EF_OLDSTYLE, e->e_flags))
		ee->e_flags &= ~EF_OLDSTYLE;
	ee->e_sendqueue = returnq;
	ee->e_msgsize = ERRORFUDGE;
	if (bitset(RTSF_SEND_BODY, flags))
		ee->e_msgsize += e->e_msgsize;
	else
		ee->e_flags |= EF_NO_BODY_RETN;
	initsys(ee);
	for (q = returnq; q != NULL; q = q->q_next)
	{
		if (bitset(QBADADDR, q->q_flags))
			continue;

		q->q_flags &= ~(QHASNOTIFY|Q_PINGFLAGS);
		q->q_flags |= QPINGONFAILURE;

		if (!bitset(QDONTSEND, q->q_flags))
			ee->e_nrcpts++;

		if (q->q_alias == NULL)
			addheader("To", q->q_paddr, &ee->e_header);
	}

	if (LogLevel > 5)
	{
		if (bitset(EF_RESPONSE|EF_WARNING, e->e_flags))
			p = "return to sender";
		else if (bitset(RTSF_PM_BOUNCE, flags))
			p = "postmaster notify";
		else
			p = "DSN";
		sm_syslog(LOG_INFO, e->e_id,
			"%s: %s: %s",
			ee->e_id, p, shortenstring(msg, MAXSHORTSTR));
	}

	if (SendMIMEErrors)
	{
		addheader("MIME-Version", "1.0", &ee->e_header);

		(void) snprintf(buf, sizeof buf, "%s.%ld/%.100s",
			ee->e_id, curtime(), MyHostName);
		ee->e_msgboundary = newstr(buf);
		(void) snprintf(buf, sizeof buf,
#if DSN
			"multipart/report; report-type=delivery-status;\n\tboundary=\"%s\"",
#else
			"multipart/mixed; boundary=\"%s\"",
#endif
			ee->e_msgboundary);
		addheader("Content-Type", buf, &ee->e_header);

		p = hvalue("Content-Transfer-Encoding", e->e_header);
		if (p != NULL && strcasecmp(p, "binary") != 0)
			p = NULL;
		if (p == NULL && bitset(EF_HAS8BIT, e->e_flags))
			p = "8bit";
		if (p != NULL)
			addheader("Content-Transfer-Encoding", p, &ee->e_header);
	}
	if (strncmp(msg, "Warning:", 8) == 0)
	{
		addheader("Subject", msg, &ee->e_header);
		p = "warning-timeout";
	}
	else if (strncmp(msg, "Postmaster warning:", 19) == 0)
	{
		addheader("Subject", msg, &ee->e_header);
		p = "postmaster-warning";
	}
	else if (strcmp(msg, "Return receipt") == 0)
	{
		addheader("Subject", msg, &ee->e_header);
		p = "return-receipt";
	}
	else if (bitset(RTSF_PM_BOUNCE, flags))
	{
		snprintf(buf, sizeof buf, "Postmaster notify: %.*s",
			sizeof buf - 20, msg);
		addheader("Subject", buf, &ee->e_header);
		p = "postmaster-notification";
	}
	else
	{
		snprintf(buf, sizeof buf, "Returned mail: %.*s",
			sizeof buf - 20, msg);
		addheader("Subject", buf, &ee->e_header);
		p = "failure";
	}
	(void) snprintf(buf, sizeof buf, "auto-generated (%s)", p);
	addheader("Auto-Submitted", buf, &ee->e_header);

	/* fake up an address header for the from person */
	expand("\201n", buf, sizeof buf, e);
	if (parseaddr(buf, &ee->e_from, RF_COPYALL|RF_SENDERADDR, '\0', NULL, e) == NULL)
	{
		syserr("553 Can't parse myself!");
		ExitStat = EX_SOFTWARE;
		returndepth--;
		return (-1);
	}
	ee->e_from.q_flags &= ~(QHASNOTIFY|Q_PINGFLAGS);
	ee->e_from.q_flags |= QPINGONFAILURE;
	ee->e_sender = ee->e_from.q_paddr;

	/* push state into submessage */
	CurEnv = ee;
	define('f', "\201n", ee);
	define('x', "Mail Delivery Subsystem", ee);
	eatheader(ee, TRUE);

	/* mark statistics */
	markstats(ee, NULLADDR, FALSE);

	/* actually deliver the error message */
	sendall(ee, SM_DELIVER);

	/* restore state */
	dropenvelope(ee, TRUE);
	CurEnv = oldcur;
	returndepth--;

	/* check for delivery errors */
	if (ee->e_parent == NULL || !bitset(EF_RESPONSE, ee->e_parent->e_flags))
		return 0;
	for (q = ee->e_sendqueue; q != NULL; q = q->q_next)
	{
		if (bitset(QQUEUEUP|QSENT, q->q_flags))
			return 0;
	}
	return -1;
}
/*
**  ERRBODY -- output the body of an error message.
**
**	Typically this is a copy of the transcript plus a copy of the
**	original offending message.
**
**	Parameters:
**		mci -- the mailer connection information.
**		e -- the envelope we are working in.
**		separator -- any possible MIME separator.
**
**	Returns:
**		none
**
**	Side Effects:
**		Outputs the body of an error message.
*/

void
errbody(mci, e, separator)
	register MCI *mci;
	register ENVELOPE *e;
	char *separator;
{
	register FILE *xfile;
	char *p;
	register ADDRESS *q = NULL;
	bool printheader;
	bool sendbody;
	bool pm_notify;
	char buf[MAXLINE];

	if (bitset(MCIF_INHEADER, mci->mci_flags))
	{
		putline("", mci);
		mci->mci_flags &= ~MCIF_INHEADER;
	}
	if (e->e_parent == NULL)
	{
		syserr("errbody: null parent");
		putline("   ----- Original message lost -----\n", mci);
		return;
	}

	/*
	**  Output MIME header.
	*/

	if (e->e_msgboundary != NULL)
	{
		putline("This is a MIME-encapsulated message", mci);
		putline("", mci);
		(void) snprintf(buf, sizeof buf, "--%s", e->e_msgboundary);
		putline(buf, mci);
		putline("", mci);
	}

	/*
	**  Output introductory information.
	*/

	pm_notify = FALSE;
	p = hvalue("subject", e->e_header);
	if (p != NULL && strncmp(p, "Postmaster ", 11) == 0)
		pm_notify = TRUE;
	else
	{
		for (q = e->e_parent->e_sendqueue; q != NULL; q = q->q_next)
			if (bitset(QBADADDR, q->q_flags))
				break;
	}
	if (!pm_notify && q == NULL &&
	    !bitset(EF_FATALERRS|EF_SENDRECEIPT, e->e_parent->e_flags))
	{
		putline("    **********************************************",
			mci);
		putline("    **      THIS IS A WARNING MESSAGE ONLY      **",
			mci);
		putline("    **  YOU DO NOT NEED TO RESEND YOUR MESSAGE  **",
			mci);
		putline("    **********************************************",
			mci);
		putline("", mci);
	}
	snprintf(buf, sizeof buf, "The original message was received at %s",
		arpadate(ctime(&e->e_parent->e_ctime)));
	putline(buf, mci);
	expand("from \201_", buf, sizeof buf, e->e_parent);
	putline(buf, mci);
	putline("", mci);

	/*
	**  Output error message header (if specified and available).
	*/

	if (ErrMsgFile != NULL && !bitset(EF_SENDRECEIPT, e->e_parent->e_flags))
	{
		if (*ErrMsgFile == '/')
		{
			int sff = SFF_ROOTOK|SFF_REGONLY;

			if (DontLockReadFiles)
				sff |= SFF_NOLOCK;
			if (!bitset(DBS_ERRORHEADERINUNSAFEDIRPATH, DontBlameSendmail))
				sff |= SFF_SAFEDIRPATH;
			xfile = safefopen(ErrMsgFile, O_RDONLY, 0444, sff);
			if (xfile != NULL)
			{
				while (fgets(buf, sizeof buf, xfile) != NULL)
				{
					extern void translate_dollars __P((char *));

					translate_dollars(buf);
					expand(buf, buf, sizeof buf, e);
					putline(buf, mci);
				}
				(void) fclose(xfile);
				putline("\n", mci);
			}
		}
		else
		{
			expand(ErrMsgFile, buf, sizeof buf, e);
			putline(buf, mci);
			putline("", mci);
		}
	}

	/*
	**  Output message introduction
	*/

	printheader = TRUE;
	for (q = e->e_parent->e_sendqueue; q != NULL; q = q->q_next)
	{
		if (!bitset(QBADADDR, q->q_flags) ||
		    !bitset(QPINGONFAILURE, q->q_flags))
			continue;

		if (printheader)
		{
			putline("   ----- The following addresses had permanent fatal errors -----",
				mci);
			printheader = FALSE;
		}

		snprintf(buf, sizeof buf, "%s",
			 shortenstring(q->q_paddr, MAXSHORTSTR));
		putline(buf, mci);
		if (q->q_alias != NULL)
		{
			snprintf(buf, sizeof buf, "    (expanded from: %s)",
				shortenstring(q->q_alias->q_paddr, MAXSHORTSTR));
			putline(buf, mci);
		}
	}
	if (!printheader)
		putline("", mci);

	printheader = TRUE;
	for (q = e->e_parent->e_sendqueue; q != NULL; q = q->q_next)
	{
		if (bitset(QBADADDR, q->q_flags) ||
		    !bitset(QPRIMARY, q->q_flags) ||
		    !bitset(QDELAYED, q->q_flags))
			continue;

		if (printheader)
		{
			putline("   ----- The following addresses had transient non-fatal errors -----",
				mci);
			printheader = FALSE;
		}

		snprintf(buf, sizeof buf, "%s",
			 shortenstring(q->q_paddr, MAXSHORTSTR));
		putline(buf, mci);
		if (q->q_alias != NULL)
		{
			snprintf(buf, sizeof buf, "    (expanded from: %s)",
				shortenstring(q->q_alias->q_paddr, MAXSHORTSTR));
			putline(buf, mci);
		}
	}
	if (!printheader)
		putline("", mci);

	printheader = TRUE;
	for (q = e->e_parent->e_sendqueue; q != NULL; q = q->q_next)
	{
		if (bitset(QBADADDR, q->q_flags) ||
		    !bitset(QPRIMARY, q->q_flags) ||
		    bitset(QDELAYED, q->q_flags))
			continue;
		else if (!bitset(QPINGONSUCCESS, q->q_flags))
			continue;
		else if (bitset(QRELAYED, q->q_flags))
			p = "relayed to non-DSN-aware mailer";
		else if (bitset(QDELIVERED, q->q_flags))
		{
			if (bitset(QEXPANDED, q->q_flags))
				p = "successfully delivered to mailing list";
			else
				p = "successfully delivered to mailbox";
		}
		else if (bitset(QEXPANDED, q->q_flags))
			p = "expanded by alias";
		else
			continue;

		if (printheader)
		{
			putline("   ----- The following addresses had successful delivery notifications -----",
				mci);
			printheader = FALSE;
		}

		snprintf(buf, sizeof buf, "%s  (%s)",
			shortenstring(q->q_paddr, MAXSHORTSTR), p);
		putline(buf, mci);
		if (q->q_alias != NULL)
		{
			snprintf(buf, sizeof buf, "    (expanded from: %s)",
				shortenstring(q->q_alias->q_paddr, MAXSHORTSTR));
			putline(buf, mci);
		}
	}
	if (!printheader)
		putline("", mci);

	/*
	**  Output transcript of errors
	*/

	(void) fflush(stdout);
	p = queuename(e->e_parent, 'x');
	if ((xfile = fopen(p, "r")) == NULL)
	{
		syserr("Cannot open %s", p);
		putline("   ----- Transcript of session is unavailable -----\n", mci);
	}
	else
	{
		printheader = TRUE;
		if (e->e_xfp != NULL)
			(void) fflush(e->e_xfp);
		while (fgets(buf, sizeof buf, xfile) != NULL)
		{
			if (printheader)
				putline("   ----- Transcript of session follows -----\n", mci);
			printheader = FALSE;
			putline(buf, mci);
		}
		(void) xfclose(xfile, "errbody xscript", p);
	}
	errno = 0;

#if DSN
	/*
	**  Output machine-readable version.
	*/

	if (e->e_msgboundary != NULL)
	{
		putline("", mci);
		(void) snprintf(buf, sizeof buf, "--%s", e->e_msgboundary);
		putline(buf, mci);
		putline("Content-Type: message/delivery-status", mci);
		putline("", mci);

		/*
		**  Output per-message information.
		*/

		/* original envelope id from MAIL FROM: line */
		if (e->e_parent->e_envid != NULL)
		{
			(void) snprintf(buf, sizeof buf, "Original-Envelope-Id: %.800s",
				xuntextify(e->e_parent->e_envid));
			putline(buf, mci);
		}

		/* Reporting-MTA: is us (required) */
		(void) snprintf(buf, sizeof buf, "Reporting-MTA: dns; %.800s", MyHostName);
		putline(buf, mci);

		/* DSN-Gateway: not relevant since we are not translating */

		/* Received-From-MTA: shows where we got this message from */
		if (RealHostName != NULL)
		{
			/* XXX use $s for type? */
			if (e->e_parent->e_from.q_mailer == NULL ||
			    (p = e->e_parent->e_from.q_mailer->m_mtatype) == NULL)
				p = "dns";
			(void) snprintf(buf, sizeof buf, "Received-From-MTA: %s; %.800s",
				p, RealHostName);
			putline(buf, mci);
		}

		/* Arrival-Date: -- when it arrived here */
		(void) snprintf(buf, sizeof buf, "Arrival-Date: %s",
			arpadate(ctime(&e->e_parent->e_ctime)));
		putline(buf, mci);

		/*
		**  Output per-address information.
		*/

		for (q = e->e_parent->e_sendqueue; q != NULL; q = q->q_next)
		{
			register ADDRESS *r;
			char *action;

			if (bitset(QBADADDR, q->q_flags))
				action = "failed";
			else if (!bitset(QPRIMARY, q->q_flags))
				continue;
			else if (bitset(QDELIVERED, q->q_flags))
			{
				if (bitset(QEXPANDED, q->q_flags))
					action = "delivered (to mailing list)";
				else
					action = "delivered (to mailbox)";
			}
			else if (bitset(QRELAYED, q->q_flags))
				action = "relayed (to non-DSN-aware mailer)";
			else if (bitset(QEXPANDED, q->q_flags))
				action = "expanded (to multi-recipient alias)";
			else if (bitset(QDELAYED, q->q_flags))
				action = "delayed";
			else
				continue;

			putline("", mci);

			/* Original-Recipient: -- passed from on high */
			if (q->q_orcpt != NULL)
			{
				(void) snprintf(buf, sizeof buf, "Original-Recipient: %.800s",
					q->q_orcpt);
				putline(buf, mci);
			}

			/* Final-Recipient: -- the name from the RCPT command */
			p = e->e_parent->e_from.q_mailer->m_addrtype;
			if (p == NULL)
				p = "rfc822";
			for (r = q; r->q_alias != NULL; r = r->q_alias)
				continue;
			if (strchr(r->q_user, '@@') != NULL)
			{
				(void) snprintf(buf, sizeof buf,
					"Final-Recipient: %s; %.800s",
					p, r->q_user);
			}
			else if (strchr(r->q_paddr, '@@') != NULL)
			{
				(void) snprintf(buf, sizeof buf,
					"Final-Recipient: %s; %.800s",
					p, r->q_paddr);
			}
			else
			{
				(void) snprintf(buf, sizeof buf,
					"Final-Recipient: %s; %.700s@@%.100s",
					p, r->q_user, MyHostName);
			}
			putline(buf, mci);

			/* X-Actual-Recipient: -- the real problem address */
			if (r != q && q->q_user[0] != '\0')
			{
				if (strchr(q->q_user, '@@') == NULL)
				{
					(void) snprintf(buf, sizeof buf,
						"X-Actual-Recipient: %s; %.700s@@%.100s",
						p, q->q_user, MyHostName);
				}
				else
				{
					(void) snprintf(buf, sizeof buf,
						"X-Actual-Recipient: %s; %.800s",
						p, q->q_user);
				}
				putline(buf, mci);
			}

			/* Action: -- what happened? */
			snprintf(buf, sizeof buf, "Action: %s", action);
			putline(buf, mci);

			/* Status: -- what _really_ happened? */
			if (q->q_status != NULL)
				p = q->q_status;
			else if (bitset(QBADADDR, q->q_flags))
				p = "5.0.0";
			else if (bitset(QQUEUEUP, q->q_flags))
				p = "4.0.0";
			else
				p = "2.0.0";
			snprintf(buf, sizeof buf, "Status: %s", p);
			putline(buf, mci);

			/* Remote-MTA: -- who was I talking to? */
			if (q->q_statmta != NULL)
			{
				if (q->q_mailer == NULL ||
				    (p = q->q_mailer->m_mtatype) == NULL)
					p = "dns";
				(void) snprintf(buf, sizeof buf,
					"Remote-MTA: %s; %.800s",
					p, q->q_statmta);
				p = &buf[strlen(buf) - 1];
				if (*p == '.')
					*p = '\0';
				putline(buf, mci);
			}

			/* Diagnostic-Code: -- actual result from other end */
			if (q->q_rstatus != NULL)
			{
				p = q->q_mailer->m_diagtype;
				if (p == NULL)
					p = "smtp";
				(void) snprintf(buf, sizeof buf,
					"Diagnostic-Code: %s; %.800s",
					p, q->q_rstatus);
				putline(buf, mci);
			}

			/* Last-Attempt-Date: -- fine granularity */
			if (q->q_statdate == (time_t) 0L)
				q->q_statdate = curtime();
			(void) snprintf(buf, sizeof buf,
				"Last-Attempt-Date: %s",
				arpadate(ctime(&q->q_statdate)));
			putline(buf, mci);

			/* Will-Retry-Until: -- for delayed messages only */
			if (bitset(QQUEUEUP, q->q_flags) &&
			    !bitset(QBADADDR, q->q_flags))
			{
				time_t xdate;

				xdate = e->e_parent->e_ctime +
					TimeOuts.to_q_return[e->e_parent->e_timeoutclass];
				snprintf(buf, sizeof buf,
					"Will-Retry-Until: %s",
					arpadate(ctime(&xdate)));
				putline(buf, mci);
			}
		}
	}
#endif

	/*
	**  Output text of original message
	*/

	putline("", mci);
	if (bitset(EF_HAS_DF, e->e_parent->e_flags))
	{
		sendbody = !bitset(EF_NO_BODY_RETN, e->e_parent->e_flags) &&
			   !bitset(EF_NO_BODY_RETN, e->e_flags);

		if (e->e_msgboundary == NULL)
		{
			if (sendbody)
				putline("   ----- Original message follows -----\n", mci);
			else
				putline("   ----- Message header follows -----\n", mci);
			(void) fflush(mci->mci_out);
		}
		else
		{
			(void) snprintf(buf, sizeof buf, "--%s",
				e->e_msgboundary);

			putline(buf, mci);
			(void) snprintf(buf, sizeof buf, "Content-Type: %s",
				sendbody ? "message/rfc822"
					 : "text/rfc822-headers");
			putline(buf, mci);

			p = hvalue("Content-Transfer-Encoding", e->e_parent->e_header);
			if (p != NULL && strcasecmp(p, "binary") != 0)
				p = NULL;
			if (p == NULL && bitset(EF_HAS8BIT, e->e_parent->e_flags))
				p = "8bit";
			if (p != NULL)
			{
				(void) snprintf(buf, sizeof buf, "Content-Transfer-Encoding: %s",
					p);
				putline(buf, mci);
			}
		}
		putline("", mci);
		putheader(mci, e->e_parent->e_header, e->e_parent, M87F_OUTER);
		if (sendbody)
			putbody(mci, e->e_parent, e->e_msgboundary);
		else if (e->e_msgboundary == NULL)
		{
			putline("", mci);
			putline("   ----- Message body suppressed -----", mci);
		}
	}
	else if (e->e_msgboundary == NULL)
	{
		putline("  ----- No message was collected -----\n", mci);
	}

	if (e->e_msgboundary != NULL)
	{
		putline("", mci);
		(void) snprintf(buf, sizeof buf, "--%s--", e->e_msgboundary);
		putline(buf, mci);
	}
	putline("", mci);

	/*
	**  Cleanup and exit
	*/

	if (errno != 0)
		syserr("errbody: I/O error");
}
/*
**  SMTPTODSN -- convert SMTP to DSN status code
**
**	Parameters:
**		smtpstat -- the smtp status code (e.g., 550).
**
**	Returns:
**		The DSN version of the status code.
*/

char *
smtptodsn(smtpstat)
	int smtpstat;
{
	if (smtpstat < 0)
		return "4.4.2";

	switch (smtpstat)
	{
	  case 450:	/* Req mail action not taken: mailbox unavailable */
		return "4.2.0";

	  case 451:	/* Req action aborted: local error in processing */
		return "4.3.0";

	  case 452:	/* Req action not taken: insufficient sys storage */
		return "4.3.1";

	  case 500:	/* Syntax error, command unrecognized */
		return "5.5.2";

	  case 501:	/* Syntax error in parameters or arguments */
		return "5.5.4";

	  case 502:	/* Command not implemented */
		return "5.5.1";

	  case 503:	/* Bad sequence of commands */
		return "5.5.1";

	  case 504:	/* Command parameter not implemented */
		return "5.5.4";

	  case 550:	/* Req mail action not taken: mailbox unavailable */
		return "5.2.0";

	  case 551:	/* User not local; please try <...> */
		return "5.1.6";

	  case 552:	/* Req mail action aborted: exceeded storage alloc */
		return "5.2.2";

	  case 553:	/* Req action not taken: mailbox name not allowed */
		return "5.1.0";

	  case 554:	/* Transaction failed */
		return "5.0.0";
	}

	if ((smtpstat / 100) == 2)
		return "2.0.0";
	if ((smtpstat / 100) == 4)
		return "4.0.0";
	return "5.0.0";
}
/*
**  XTEXTIFY -- take regular text and turn it into DSN-style xtext
**
**	Parameters:
**		t -- the text to convert.
**		taboo -- additional characters that must be encoded.
**
**	Returns:
**		The xtext-ified version of the same string.
*/

char *
xtextify(t, taboo)
	register char *t;
	char *taboo;
{
	register char *p;
	int l;
	int nbogus;
	static char *bp = NULL;
	static int bplen = 0;

	if (taboo == NULL)
		taboo = "";

	/* figure out how long this xtext will have to be */
	nbogus = l = 0;
	for (p = t; *p != '\0'; p++)
	{
		register int c = (*p & 0xff);

		/* ASCII dependence here -- this is the way the spec words it */
		if (c < '!' || c > '~' || c == '+' || c == '\\' || c == '(' ||
		    strchr(taboo, c) != NULL)
			nbogus++;
		l++;
	}
	if (nbogus == 0)
		return t;
	l += nbogus * 2 + 1;

	/* now allocate space if necessary for the new string */
	if (l > bplen)
	{
		if (bp != NULL)
			free(bp);
		bp = xalloc(l);
		bplen = l;
	}

	/* ok, copy the text with byte expansion */
	for (p = bp; *t != '\0'; )
	{
		register int c = (*t++ & 0xff);

		/* ASCII dependence here -- this is the way the spec words it */
		if (c < '!' || c > '~' || c == '+' || c == '\\' || c == '(' ||
		    strchr(taboo, c) != NULL)
		{
			*p++ = '+';
			*p++ = "0123456789abcdef"[c >> 4];
			*p++ = "0123456789abcdef"[c & 0xf];
		}
		else
			*p++ = c;
	}
	*p = '\0';
	return bp;
}
/*
**  XUNTEXTIFY -- take xtext and turn it into plain text
**
**	Parameters:
**		t -- the xtextified text.
**
**	Returns:
**		The decoded text.  No attempt is made to deal with
**		null strings in the resulting text.
*/

char *
xuntextify(t)
	register char *t;
{
	register char *p;
	int l;
	static char *bp = NULL;
	static int bplen = 0;

	/* heuristic -- if no plus sign, just return the input */
	if (strchr(t, '+') == NULL)
		return t;

	/* xtext is always longer than decoded text */
	l = strlen(t);
	if (l > bplen)
	{
		if (bp != NULL)
			free(bp);
		bp = xalloc(l);
		bplen = l;
	}

	/* ok, copy the text with byte compression */
	for (p = bp; *t != '\0'; t++)
	{
		register int c = *t & 0xff;

		if (c != '+')
		{
			*p++ = c;
			continue;
		}

		c = *++t & 0xff;
		if (!isascii(c) || !isxdigit(c))
		{
			/* error -- first digit is not hex */
			usrerr("bogus xtext: +%c", c);
			t--;
			continue;
		}
		if (isdigit(c))
			c -= '0';
		else if (isupper(c))
			c -= 'A' - 10;
		else
			c -= 'a' - 10;
		*p = c << 4;

		c = *++t & 0xff;
		if (!isascii(c) || !isxdigit(c))
		{
			/* error -- second digit is not hex */
			usrerr("bogus xtext: +%x%c", *p >> 4, c);
			t--;
			continue;
		}
		if (isdigit(c))
			c -= '0';
		else if (isupper(c))
			c -= 'A' - 10;
		else
			c -= 'a' - 10;
		*p++ |= c;
	}
	*p = '\0';
	return bp;
}
/*
**  XTEXTOK -- check if a string is legal xtext
**
**	Xtext is used in Delivery Status Notifications.  The spec was
**	taken from RFC 1891, ``SMTP Service Extension for Delivery
**	Status Notifications''.
**
**	Parameters:
**		s -- the string to check.
**
**	Returns:
**		TRUE -- if 's' is legal xtext.
**		FALSE -- if it has any illegal characters in it.
*/

bool
xtextok(s)
	char *s;
{
	int c;

	while ((c = *s++) != '\0')
	{
		if (c == '+')
		{
			c = *s++;
			if (!isascii(c) || !isxdigit(c))
				return FALSE;
			c = *s++;
			if (!isascii(c) || !isxdigit(c))
				return FALSE;
		}
		else if (c < '!' || c > '~' || c == '=')
			return FALSE;
	}
	return TRUE;
}
/*
**  PRUNEROUTE -- prune an RFC-822 source route
** 
**	Trims down a source route to the last internet-registered hop.
**	This is encouraged by RFC 1123 section 5.3.3.
** 
**	Parameters:
**		addr -- the address
** 
**	Returns:
**		TRUE -- address was modified
**		FALSE -- address could not be pruned
** 
**	Side Effects:
**		modifies addr in-place
*/

bool
pruneroute(addr)
	char *addr;
{
#if NAMED_BIND
	char *start, *at, *comma;
	char c;
	int rcode;
	int i;
	char hostbuf[BUFSIZ];
	char *mxhosts[MAXMXHOSTS + 1];

	/* check to see if this is really a route-addr */
	if (*addr != '<' || addr[1] != '@@' || addr[strlen(addr) - 1] != '>')
		return FALSE;
	start = strchr(addr, ':');
	at = strrchr(addr, '@@');
	if (start == NULL || at == NULL || at < start)
		return FALSE;

	/* slice off the angle brackets */
	i = strlen(at + 1);
	if (i >= (SIZE_T) sizeof hostbuf)
		return FALSE;
	strcpy(hostbuf, at + 1);
	hostbuf[i - 1] = '\0';

	while (start)
	{
		if (getmxrr(hostbuf, mxhosts, FALSE, &rcode) > 0)
		{
			strcpy(addr + 1, start + 1);
			return TRUE;
		}
		c = *start;
		*start = '\0';
		comma = strrchr(addr, ',');
		if (comma != NULL && comma[1] == '@@' &&
		    strlen(comma + 2) < (SIZE_T) sizeof hostbuf)
			strcpy(hostbuf, comma + 2);
		else
			comma = NULL;
		*start = c;
		start = comma;
	}
#endif
	return FALSE;
}
@


1.11
log
@sendmail 8.9.3
@
text
@@


1.10
log
@sendmail 8.9.2
@
text
@d14 1
a14 1
static char sccsid[] = "@@(#)savemail.c	8.139 (Berkeley) 8/5/1998";
d398 1
a398 1
			(*e->e_puthdr)(&mcibuf, e->e_header, e);
d1142 1
a1142 1
		putheader(mci, e->e_parent->e_header, e->e_parent);
@


1.9
log
@something hosed the sendmail import; fix up by hand
@
text
@d14 1
a14 1
static char sccsid[] = "@@(#)savemail.c	8.138 (Berkeley) 6/17/98";
d94 1
a94 2
			ExitStat = EX_SOFTWARE;
			finis();
@


1.8
log
@Upgrade to sendmail 8.8.8
@
text
@d2 2
a3 1
 * Copyright (c) 1983, 1995-1997 Eric P. Allman
d7 3
a9 15
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
a10 11
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
d14 1
a14 1
static char sccsid[] = "@@(#)savemail.c	8.121 (Berkeley) 10/22/97";
d65 2
a66 2
	extern char *ttypath();
	extern bool writable();
d347 3
a349 1
			flags = SFF_NOLINK|SFF_CREAT|SFF_REGONLY|SFF_RUNASREALUID;
d351 1
a351 1
			if (mailfile(buf, NULL, flags, e) == EX_OK)
d382 1
a382 1
			flags = SFF_NOLINK|SFF_CREAT|SFF_REGONLY|SFF_ROOTOK|SFF_OPENASROOT|SFF_MUSTOWN;
d396 1
d467 1
a467 1
	static int returndepth;
d546 1
a546 1
			ee->e_id, p, shortenstring(msg, 203));
d625 1
a625 1
	markstats(ee, NULLADDR);
d748 2
d755 2
a756 1
#if _FFR_BUG_FIX
a757 1
#endif
d791 2
a792 1
		snprintf(buf, sizeof buf, "%s", shortenstring(q->q_paddr, 203));
d797 1
a797 1
				shortenstring(q->q_alias->q_paddr, 203));
d819 2
a820 1
		snprintf(buf, sizeof buf, "%s", shortenstring(q->q_paddr, 203));
d825 1
a825 1
				shortenstring(q->q_alias->q_paddr, 203));
d863 1
a863 1
			shortenstring(q->q_paddr, 203), p);
d868 1
a868 1
				shortenstring(q->q_alias->q_paddr, 203));
@


1.7
log
@sendmail 8.8.7.
@
text
@d36 1
a36 1
static char sccsid[] = "@@(#)savemail.c	8.114 (Berkeley) 8/2/97";
a87 1
	typedef int (*fnptr)();
d256 23
a278 2
				(void) sendtolist(e->e_from.q_paddr,
					  NULLADDR, &e->e_errorqueue, 0, e);
d402 1
a402 1
			flags = SFF_NOLINK|SFF_CREAT|SFF_REGONLY|SFF_OPENASROOT|SFF_MUSTOWN;
a541 2
		extern bool pruneroute __P((char *));

a547 12
		if (!DontPruneRoutes && pruneroute(q->q_paddr))
		{
			register ADDRESS *p;

			parseaddr(q->q_paddr, q, RF_COPYPARSE, '\0', NULL, e);
			for (p = returnq; p != NULL; p = p->q_next)
			{
				if (p != q && sameaddr(p, q))
					q->q_flags |= QDONTSEND;
			}
		}

d659 1
a659 1
		if (bitset(QSENT, q->q_flags))
d690 1
a690 1
	register ADDRESS *q;
d1010 7
a1016 1
			if (strchr(r->q_user, '@@') == NULL)
d1019 2
a1020 2
					"Final-Recipient: %s; %.700s@@%.100s",
					p, r->q_user, MyHostName);
d1025 2
a1026 2
					"Final-Recipient: %s; %.800s",
					p, r->q_user);
@


1.6
log
@Sendmail 8.8.6.
@
text
@d36 1
a36 1
static char sccsid[] = "@@(#)savemail.c	8.110 (Berkeley) 4/7/97";
a72 4
# ifndef _PATH_VARTMP
#  define _PATH_VARTMP	"/usr/tmp/"
# endif

d300 2
a301 1
			if (sendtolist(DoubleBounceAddr, NULL, &q, 0, e) <= 0)
d375 2
a376 1
			if (SafeFileEnv != NULL && SafeFileEnv[0] != '\0')
a381 2
			snprintf(buf, sizeof buf, "%sdead.letter", _PATH_VARTMP);

d383 2
a384 2
			if (!writable(buf, NULL, flags) ||
			    (fp = safefopen(buf, O_WRONLY|O_CREAT|O_APPEND,
d409 1
a409 1
				message("Saved message in %s", buf);
d414 1
a414 1
						buf);
d417 1
a417 1
			(void) xfclose(fp, "savemail", buf);
d757 5
a761 2
			xfile = safefopen(ErrMsgFile, O_RDONLY, 0444,
					  SFF_ROOTOK|SFF_REGONLY);
@


1.5
log
@Sendmail 8.8.5.
@
text
@d2 1
a2 1
 * Copyright (c) 1983, 1995, 1996 Eric P. Allman
d36 1
a36 1
static char sccsid[] = "@@(#)savemail.c	8.103 (Berkeley) 1/18/97";
d352 1
a352 1
			flags = SFF_NOSLINK|SFF_CREAT|SFF_REGONLY|SFF_RUNASREALUID;
d356 1
a356 1
				bool oldverb = Verbose;
d358 1
a358 1
				Verbose = TRUE;
d386 1
a386 1
			flags = SFF_NOSLINK|SFF_CREAT|SFF_REGONLY|SFF_ROOTOK|SFF_OPENASROOT;
d410 1
a410 1
				bool oldverb = Verbose;
d412 1
a412 1
				Verbose = TRUE;
a414 1
#ifdef LOG
d416 3
a418 2
					syslog(LOG_NOTICE, "Saved message in %s", buf);
#endif
a552 1
# ifdef LOG
d561 3
a563 2
		syslog(LOG_INFO, "%s: %s: %s: %s",
			e->e_id, ee->e_id, p, shortenstring(msg, 203));
a564 1
# endif
d761 2
a762 1
			xfile = fopen(ErrMsgFile, "r");
d767 3
d1229 1
a1229 1
		return "5.1.3";
@


1.4
log
@Update to Sendmail 8.8.4, plus recent patches, plus OpenBSD support.
Also include entire example configuration subset.
Includes smrsh (using /usr/libexec/sm.bin).

Of the top of my head, the only things I removed from the distribution were
contrib/mail.local.linux, src/Makefiles, all the *.0 and *.ps files.
Our praliases man page replaces the distributed one, ours is better.
@
text
@d36 1
a36 1
static char sccsid[] = "@@(#)savemail.c	8.101 (Berkeley) 11/24/96";
d646 1
a646 1
	sendall(ee, SM_DEFAULT);
d1391 2
a1392 1
**	taken from draft-ietf-notary-mime-delivery-04.txt.
@


1.3
log
@bring up to 8.7.6
@
text
@d2 1
a2 1
 * Copyright (c) 1983, 1995 Eric P. Allman
d36 1
a36 1
static char sccsid[] = "@@(#)savemail.c	8.87.1.2 (Berkeley) 9/16/96";
d89 1
a89 1
	int sfflags;
d286 3
a288 1
					   sendbody, e) == 0)
d304 1
a304 1
			if (sendtolist("postmaster", NULL, &q, 0, e) <= 0)
d306 1
a306 1
				syserr("553 cannot parse postmaster!");
d311 4
a314 1
			if (returntosender(e->e_message, q, sendbody, e) == 0)
d352 1
a352 1
			sfflags = SFF_NOSLINK|SFF_CREAT|SFF_REGONLY|SFF_RUNASREALUID;
d354 1
a354 1
			if (mailfile(buf, NULL, sfflags, e) == EX_OK)
d386 2
a387 2
			sfflags = SFF_NOSLINK|SFF_CREAT|SFF_REGONLY|SFF_ROOTOK|SFF_OPENASROOT;
			if (!writable(buf, NULL, sfflags) ||
d389 1
a389 1
					    FileMode, sfflags)) == NULL)
d406 3
a408 1
			if (!ferror(fp))
a419 1
				break;
a420 1
			state = ESM_PANIC;
d442 4
a445 2
**		sendbody -- if TRUE, also send back the body of the
**			message; otherwise just send the header.
d461 1
a461 1
returntosender(msg, returnq, sendbody, e)
d464 1
a464 1
	bool sendbody;
d484 2
a485 2
		printf("\n*** Return To Sender: msg=\"%s\", depth=%d, e=%x, returnq=",
		       msg, returndepth, e);
d519 1
a519 1
	if (sendbody)
d526 2
d531 3
d558 2
d561 1
a561 1
			p = "postmaster notify";
d606 7
d632 2
d649 1
a649 1
	dropenvelope(ee);
a672 1
**		flags -- to modify the behaviour.
d692 1
a693 1
	extern char *xuntextify();
d724 11
a734 4
	for (q = e->e_parent->e_sendqueue; q != NULL; q = q->q_next)
		if (bitset(QBADADDR, q->q_flags))
			break;
	if (q == NULL &&
d789 41
a829 1
		if (bitset(QBADADDR, q->q_flags))
d831 3
a833 3
			if (!bitset(QPINGONFAILURE, q->q_flags))
				continue;
			p = "unrecoverable error";
d835 10
a844 1
		else if (!bitset(QPRIMARY, q->q_flags))
a845 2
		else if (bitset(QDELAYED, q->q_flags))
			p = "transient failure";
d864 1
a864 1
			putline("   ----- The following addresses have delivery notifications -----",
d880 1
a880 1
		putline("\n", mci);
d1243 1
d1250 1
a1250 1
xtextify(t)
d1252 1
d1260 3
d1270 2
a1271 1
		if (c < '!' || c > '~' || c == '+' || c == '\\' || c == '(')
d1294 2
a1295 1
		if (c < '!' || c > '~' || c == '+' || c == '\\' || c == '(')
d1384 1
@


1.2
log
@Sendmail 8.7.3 from NetBSD
@
text
@d36 1
a36 1
static char sccsid[] = "@@(#)savemail.c	8.87 (Berkeley) 10/28/95";
d379 1
a379 2
			strcpy(buf, _PATH_VARTMP);
			strcat(buf, "dead.letter");
d557 1
a557 1
		(void) sprintf(buf, "%s.%ld/%.100s",
d560 1
a560 1
		(void) sprintf(buf,
d594 2
a595 1
		sprintf(buf, "Returned mail: %.*s", sizeof buf - 20, msg);
d599 1
a599 1
	(void) sprintf(buf, "auto-generated (%s)", p);
d693 1
a693 1
		(void) sprintf(buf, "--%s", e->e_msgboundary);
d718 1
a718 1
	sprintf(buf, "The original message was received at %s",
d793 2
a794 1
		sprintf(buf, "%s  (%s)", shortenstring(q->q_paddr, 203), p);
d798 1
a798 1
			sprintf(buf, "    (expanded from: %s)",
d841 1
a841 1
		(void) sprintf(buf, "--%s", e->e_msgboundary);
d853 1
a853 1
			(void) sprintf(buf, "Original-Envelope-Id: %.800s",
d859 1
a859 1
		(void) sprintf(buf, "Reporting-MTA: dns; %.800s", MyHostName);
d871 1
a871 1
			(void) sprintf(buf, "Received-From-MTA: %s; %.800s",
d877 1
a877 1
		(void) sprintf(buf, "Arrival-Date: %s",
d915 1
a915 1
				(void) sprintf(buf, "Original-Recipient: %.800s",
d928 2
a929 1
				(void) sprintf(buf, "Final-Recipient: %s; %.700s@@%.100s",
d934 2
a935 1
				(void) sprintf(buf, "Final-Recipient: %s; %.800s",
d945 2
a946 1
					(void) sprintf(buf, "X-Actual-Recipient: %s; %.700s@@%.100s",
d951 2
a952 1
					(void) sprintf(buf, "X-Actual-Recipient: %s; %.800s",
d959 1
a959 1
			sprintf(buf, "Action: %s", action);
a962 1
			strcpy(buf, "Status: ");
d964 1
a964 1
				strcat(buf, q->q_status);
d966 1
a966 1
				strcat(buf, "5.0.0");
d968 1
a968 1
				strcat(buf, "4.0.0");
d970 2
a971 1
				strcat(buf, "2.0.0");
d980 2
a981 1
				(void) sprintf(buf, "Remote-MTA: %s; %.800s",
d995 2
a996 1
				(void) sprintf(buf, "Diagnostic-Code: %s; %.800s",
d1004 2
a1005 1
			(void) sprintf(buf, "Last-Attempt-Date: %s",
d1017 2
a1018 1
				sprintf(buf, "Will-Retry-Until: %s",
d1046 2
a1047 1
			(void) sprintf(buf, "--%s", e->e_msgboundary);
d1050 1
a1050 1
			(void) sprintf(buf, "Content-Type: %s",
d1062 1
a1062 1
				(void) sprintf(buf, "Content-Transfer-Encoding: %s",
d1085 1
a1085 1
		(void) sprintf(buf, "--%s--", e->e_msgboundary);
d1364 1
d1377 3
d1381 1
a1381 1
	hostbuf[strlen(hostbuf) - 1] = '\0';
d1393 2
a1394 1
		if (comma && comma[1] == '@@')
d1397 1
a1397 1
			comma = 0;
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
 * Copyright (c) 1983 Eric P. Allman
d36 1
a36 1
static char sccsid[] = "@@(#)savemail.c	8.29 (Berkeley) 5/10/94";
a39 1
# include <pwd.h>
d51 2
d78 2
a79 1
savemail(e)
d81 1
d89 1
a90 1
	extern struct passwd *getpwnam();
a148 5
		/* mail back, but return o.k. exit status */
		ExitStat = EX_OK;

		/* fall through.... */

d188 1
a188 1
			if (e->e_from.q_mailer == LocalMailer)
d208 1
a208 1
			expand("\201n", buf, &buf[sizeof buf - 1], e);
d257 1
a257 1
					  NULLADDR, &e->e_errorqueue, e);
d259 1
a259 1
			if (strcmp(e->e_from.q_paddr, "<>") != 0)
d262 1
a262 1
					  NULLADDR, &e->e_errorqueue, e);
d286 1
a286 1
					   (e->e_class >= 0), e) == 0)
d302 1
a302 1
			if (sendtolist("postmaster", NULL, &q, e) <= 0)
d309 1
a309 2
			if (returntosender(e->e_message,
					   q, (e->e_class >= 0), e) == 0)
d330 1
a330 1
			if (e->e_from.q_mailer == LocalMailer)
d334 1
a334 1
				else if ((pw = getpwnam(e->e_from.q_user)) != NULL)
d337 1
a337 1
			if (p == NULL)
d339 1
a339 1
				/* no local directory */
d343 7
a349 1
			if (e->e_dfp != NULL)
a352 3
				/* we have a home directory; open dead.letter */
				define('z', p, e);
				expand("\201z/dead.letter", buf, &buf[sizeof buf - 1], e);
d354 1
a354 1
				message("Saving message in %s", buf);
d356 2
a357 14
				e->e_to = buf;
				q = NULL;
				(void) sendtolist(buf, &e->e_from, &q, e);
				if (q != NULL &&
				    !bitset(QBADADDR, q->q_flags) &&
				    deliver(e, q) == 0)
					state = ESM_DONE;
				else
					state = ESM_MAIL;
			}
			else
			{
				/* no data file -- try mailing back */
				state = ESM_MAIL;
d359 1
d373 1
a373 3
			strcpy(buf, _PATH_VARTMP);
			strcat(buf, "dead.letter");
			if (!writable(buf, NULLADDR, SFF_NOSLINK))
d378 8
a385 2
			fp = dfopen(buf, O_WRONLY|O_CREAT|O_APPEND, FileMode);
			if (fp == NULL)
d398 1
a398 2
			(*e->e_puthdr)(&mcibuf, e);
			putline("\n", &mcibuf);
d402 16
a417 2
			state = ferror(fp) ? ESM_PANIC : ESM_DONE;
			(void) xfclose(fp, "savemail", "/usr/tmp/dead.letter");
d427 1
a450 2
static bool	SendBody;

d454 1
a460 2
	char buf[MAXNAME];
	extern putheader(), errbody();
d466 3
d478 1
a478 1
		printf("Return To Sender: msg=\"%s\", depth=%d, e=%x, returnq=",
d481 5
a496 1
	SendBody = sendbody;
d499 2
d513 1
a513 1
	if (!NoReturn)
d515 2
d523 12
a537 3
		if (!DontPruneRoutes && pruneroute(q->q_paddr))
			parseaddr(q->q_paddr, q, RF_COPYPARSE, '\0', NULL, e);

d539 1
a539 1
			addheader("To", q->q_paddr, ee);
d544 8
a551 2
		syslog(LOG_INFO, "%s: %s: return to sender: %s",
			e->e_id, ee->e_id, msg);
a553 2
	(void) sprintf(buf, "Returned mail: %.*s", sizeof buf - 20, msg);
	addheader("Subject", buf, ee);
d556 3
a558 2
		addheader("MIME-Version", "1.0", ee);
		(void) sprintf(buf, "%s.%ld/%s",
d561 16
a576 3
		(void) sprintf(buf, "multipart/mixed; boundary=\"%s\"",
					ee->e_msgboundary);
		addheader("Content-Type", buf, ee);
d578 23
d603 1
a603 1
	expand("\201n", buf, &buf[sizeof buf - 1], e);
d630 9
a638 2
	/* should check for delivery errors here */
	return (0);
d649 2
d659 2
a660 1
errbody(mci, e)
d663 1
d669 1
d671 1
d673 5
d721 1
a721 1
	expand("from \201_", buf, &buf[sizeof buf - 1], e->e_parent);
d729 1
a729 1
	if (ErrMsgFile != NULL)
d738 1
a738 1
					expand(buf, buf, &buf[sizeof buf - 1], e);
d747 1
a747 1
			expand(ErrMsgFile, buf, &buf[sizeof buf - 1], e);
d760 15
a774 1
		if (bitset(QBADADDR|QREPORT, q->q_flags))
d776 2
a777 9
			if (printheader)
			{
				putline("   ----- The following addresses had delivery problems -----",
					mci);
				printheader = FALSE;
			}
			strcpy(buf, q->q_paddr);
			if (bitset(QBADADDR, q->q_flags))
				strcat(buf, "  (unrecoverable error)");
d779 20
a798 1
				strcat(buf, "  (transient failure)");
a799 7
			if (q->q_alias != NULL)
			{
				strcpy(buf, "    (expanded from: ");
				strcat(buf, q->q_alias->q_paddr);
				strcat(buf, ")");
				putline(buf, mci);
			}
d818 1
a818 1
		putline("   ----- Transcript of session follows -----\n", mci);
d822 4
d827 1
d832 185
a1020 2
	if (NoReturn)
		SendBody = FALSE;
d1022 1
a1022 1
	if (e->e_parent->e_df != NULL)
d1024 11
a1034 2
		if (SendBody)
			putline("   ----- Original message follows -----\n", mci);
a1035 4
			putline("   ----- Message header follows -----\n", mci);
		(void) fflush(mci->mci_out);

		if (e->e_msgboundary != NULL)
a1036 1
			putline("", mci);
d1038 5
d1044 12
a1055 2
			putline("Content-Type: message/rfc822", mci);
			putline("", mci);
a1056 1
		putheader(mci, e->e_parent);
d1058 2
a1059 1
		if (SendBody)
d1061 3
a1063 1
		else
d1065 1
d1067 1
a1067 1
	else
d1088 242
d1346 1
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@


1.1.1.2
log
@sendmail 8.9.1
@
text
@d2 1
a2 2
 * Copyright (c) 1998 Sendmail, Inc.  All rights reserved.
 * Copyright (c) 1983, 1995-1997 Eric P. Allman.  All rights reserved.
d6 15
a20 3
 * By using this file, you agree to the terms and conditions set
 * forth in the LICENSE file which can be found at the top level of
 * the sendmail distribution.
d22 11
d36 1
a36 1
static char sccsid[] = "@@(#)savemail.c	8.138 (Berkeley) 6/17/98";
d40 1
a51 2
**		sendbody -- if TRUE, also send back the body of the
**			message; otherwise just send the header.
d72 4
d77 1
a77 2
void
savemail(e, sendbody)
a78 1
	bool sendbody;
a85 1
	int flags;
d87 4
a90 2
	extern char *ttypath __P((void));
	extern bool writable __P((char *, ADDRESS *, int));
d146 5
d190 1
a190 1
			if (bitnset(M_LOCALMAILER, e->e_from.q_mailer->m_flags))
d210 1
a210 1
			expand("\201n", buf, sizeof buf, e);
d259 1
a259 1
					  NULLADDR, &e->e_errorqueue, 0, e);
d261 1
a261 1
			if (!emptyaddr(&e->e_from))
d263 2
a264 23
				char from[TOBUFSIZE];
				extern bool pruneroute __P((char *));

				if (strlen(e->e_from.q_paddr) + 1 > sizeof from)
				{
					state = ESM_POSTMASTER;
					break;
				}
				strcpy(from, e->e_from.q_paddr);

				if (!DontPruneRoutes && pruneroute(from))
				{
					ADDRESS *a;

					for (a = e->e_errorqueue; a != NULL;
					     a = a->q_next)
					{
						if (sameaddr(a, &e->e_from))
							a->q_flags |= QDONTSEND;
					}
				}
				(void) sendtolist(from, NULLADDR,
						  &e->e_errorqueue, 0, e);
d288 1
a288 3
					   sendbody ? RTSF_SEND_BODY
						    : RTSF_NO_BODY,
					   e) == 0)
d304 1
a304 2
			if (sendtolist(DoubleBounceAddr,
				NULLADDR, &q, 0, e) <= 0)
d306 1
a306 1
				syserr("553 cannot parse %s!", DoubleBounceAddr);
d311 2
a312 4
			flags = RTSF_PM_BOUNCE;
			if (sendbody)
				flags |= RTSF_SEND_BODY;
			if (returntosender(e->e_message, q, flags, e) == 0)
d333 1
a333 1
			if (bitnset(M_HASPWENT, e->e_from.q_mailer->m_flags))
d337 1
a337 1
				else if ((pw = sm_getpwnam(e->e_from.q_user)) != NULL)
d340 1
a340 1
			if (p == NULL || e->e_dfp == NULL)
d342 1
a342 1
				/* no local directory or no data file */
d346 1
a346 9

			/* we have a home directory; write dead.letter */
			define('z', p, e);
			expand("\201z/dead.letter", buf, sizeof buf, e);
			flags = SFF_CREAT|SFF_REGONLY|SFF_RUNASREALUID;
			if (RealUid == 0)
				flags |= SFF_ROOTOK;
			e->e_to = buf;
			if (mailfile(buf, FileMailer, NULL, flags, e) == EX_OK)
d348 1
a348 1
				int oldverb = Verbose;
d350 5
a354 2
				Verbose = 1;
				message("Saved message in %s", buf);
d356 14
a369 2
				state = ESM_DONE;
				break;
a370 1
			state = ESM_MAIL;
d384 3
a386 2
			if ((SafeFileEnv != NULL && SafeFileEnv[0] != '\0') ||
			    DeadLetterDrop == NULL || DeadLetterDrop[0] == '\0')
d391 2
a392 5

			flags = SFF_CREAT|SFF_REGONLY|SFF_ROOTOK|SFF_OPENASROOT|SFF_MUSTOWN;
			if (!writable(DeadLetterDrop, NULL, flags) ||
			    (fp = safefopen(DeadLetterDrop, O_WRONLY|O_APPEND,
					    FileMode, flags)) == NULL)
a402 1
			mcibuf.mci_contentlen = 0;
d405 2
a406 1
			(*e->e_puthdr)(&mcibuf, e->e_header, e);
d410 2
a411 16
			if (ferror(fp))
				state = ESM_PANIC;
			else
			{
				int oldverb = Verbose;

				Verbose = 1;
				message("Saved message in %s", DeadLetterDrop);
				Verbose = oldverb;
				if (LogLevel > 3)
					sm_syslog(LOG_NOTICE, e->e_id,
						"Saved message in %s",
						DeadLetterDrop);
				state = ESM_DONE;
			}
			(void) xfclose(fp, "savemail", DeadLetterDrop);
a420 1
			loseqfile(e, "savemail panic");
d431 2
a432 4
**		flags -- flags tweaking the operation:
**			RTSF_SENDBODY -- include body of message (otherwise
**				just send the header).
**			RTSF_PMBOUNCE -- this is a postmaster bounce.
d444 2
d449 1
a449 2
int
returntosender(msg, returnq, flags, e)
d452 1
a452 1
	int flags;
d455 2
d460 1
a460 1
	static int returndepth = 0;
a461 3
	char *p;
	char buf[MAXNAME + 1];
	extern void errbody __P((MCI *, ENVELOPE *, char *));
d471 2
a472 2
		printf("\n*** Return To Sender: msg=\"%s\", depth=%d, e=%lx, returnq=",
		       msg, returndepth, (u_long) e);
a473 5
		if (tTd(6, 20))
		{
			printf("Sendq=");
			printaddr(e->e_sendqueue, TRUE);
		}
d485 1
a487 2

	/* initialize error envelope */
d500 1
a500 1
	if (bitset(RTSF_SEND_BODY, flags))
a501 2
	else
		ee->e_flags |= EF_NO_BODY_RETN;
a507 3
		q->q_flags &= ~(QHASNOTIFY|Q_PINGFLAGS);
		q->q_flags |= QPINGONFAILURE;

d511 3
d515 1
a515 1
			addheader("To", q->q_paddr, &ee->e_header);
d518 1
d520 3
a522 11
	{
		if (bitset(EF_RESPONSE|EF_WARNING, e->e_flags))
			p = "return to sender";
		else if (bitset(RTSF_PM_BOUNCE, flags))
			p = "postmaster notify";
		else
			p = "DSN";
		sm_syslog(LOG_INFO, e->e_id,
			"%s: %s: %s",
			ee->e_id, p, shortenstring(msg, MAXSHORTSTR));
	}
d524 2
d528 2
a529 3
		addheader("MIME-Version", "1.0", &ee->e_header);

		(void) snprintf(buf, sizeof buf, "%s.%ld/%.100s",
d532 3
a534 21
		(void) snprintf(buf, sizeof buf,
#if DSN
			"multipart/report; report-type=delivery-status;\n\tboundary=\"%s\"",
#else
			"multipart/mixed; boundary=\"%s\"",
#endif
			ee->e_msgboundary);
		addheader("Content-Type", buf, &ee->e_header);

		p = hvalue("Content-Transfer-Encoding", e->e_header);
		if (p != NULL && strcasecmp(p, "binary") != 0)
			p = NULL;
		if (p == NULL && bitset(EF_HAS8BIT, e->e_flags))
			p = "8bit";
		if (p != NULL)
			addheader("Content-Transfer-Encoding", p, &ee->e_header);
	}
	if (strncmp(msg, "Warning:", 8) == 0)
	{
		addheader("Subject", msg, &ee->e_header);
		p = "warning-timeout";
a535 26
	else if (strncmp(msg, "Postmaster warning:", 19) == 0)
	{
		addheader("Subject", msg, &ee->e_header);
		p = "postmaster-warning";
	}
	else if (strcmp(msg, "Return receipt") == 0)
	{
		addheader("Subject", msg, &ee->e_header);
		p = "return-receipt";
	}
	else if (bitset(RTSF_PM_BOUNCE, flags))
	{
		snprintf(buf, sizeof buf, "Postmaster notify: %.*s",
			sizeof buf - 20, msg);
		addheader("Subject", buf, &ee->e_header);
		p = "postmaster-notification";
	}
	else
	{
		snprintf(buf, sizeof buf, "Returned mail: %.*s",
			sizeof buf - 20, msg);
		addheader("Subject", buf, &ee->e_header);
		p = "failure";
	}
	(void) snprintf(buf, sizeof buf, "auto-generated (%s)", p);
	addheader("Auto-Submitted", buf, &ee->e_header);
d538 1
a538 1
	expand("\201n", buf, sizeof buf, e);
a545 2
	ee->e_from.q_flags &= ~(QHASNOTIFY|Q_PINGFLAGS);
	ee->e_from.q_flags |= QPINGONFAILURE;
d555 1
a555 1
	markstats(ee, NULLADDR, FALSE);
d558 1
a558 1
	sendall(ee, SM_DELIVER);
d561 1
a561 1
	dropenvelope(ee, TRUE);
d565 2
a566 9
	/* check for delivery errors */
	if (ee->e_parent == NULL || !bitset(EF_RESPONSE, ee->e_parent->e_flags))
		return 0;
	for (q = ee->e_sendqueue; q != NULL; q = q->q_next)
	{
		if (bitset(QQUEUEUP|QSENT, q->q_flags))
			return 0;
	}
	return -1;
a576 1
**		separator -- any possible MIME separator.
d585 1
a585 2
void
errbody(mci, e, separator)
a587 1
	char *separator;
d591 1
a591 1
	register ADDRESS *q = NULL;
a592 2
	bool sendbody;
	bool pm_notify;
a594 5
	if (bitset(MCIF_INHEADER, mci->mci_flags))
	{
		putline("", mci);
		mci->mci_flags &= ~MCIF_INHEADER;
	}
d610 1
a610 1
		(void) snprintf(buf, sizeof buf, "--%s", e->e_msgboundary);
d619 4
a622 11
	pm_notify = FALSE;
	p = hvalue("subject", e->e_header);
	if (p != NULL && strncmp(p, "Postmaster ", 11) == 0)
		pm_notify = TRUE;
	else
	{
		for (q = e->e_parent->e_sendqueue; q != NULL; q = q->q_next)
			if (bitset(QBADADDR, q->q_flags))
				break;
	}
	if (!pm_notify && q == NULL &&
d635 1
a635 1
	snprintf(buf, sizeof buf, "The original message was received at %s",
d638 1
a638 1
	expand("from \201_", buf, sizeof buf, e->e_parent);
d646 1
a646 1
	if (ErrMsgFile != NULL && !bitset(EF_SENDRECEIPT, e->e_parent->e_flags))
d650 1
a650 7
			int sff = SFF_ROOTOK|SFF_REGONLY;

			if (DontLockReadFiles)
				sff |= SFF_NOLOCK;
			if (!bitset(DBS_ERRORHEADERINUNSAFEDIRPATH, DontBlameSendmail))
				sff |= SFF_SAFEDIRPATH;
			xfile = safefopen(ErrMsgFile, O_RDONLY, 0444, sff);
d655 1
a655 4
					extern void translate_dollars __P((char *));

					translate_dollars(buf);
					expand(buf, buf, sizeof buf, e);
d664 1
a664 1
			expand(ErrMsgFile, buf, sizeof buf, e);
d677 1
a677 5
		if (!bitset(QBADADDR, q->q_flags) ||
		    !bitset(QPINGONFAILURE, q->q_flags))
			continue;

		if (printheader)
d679 9
a687 61
			putline("   ----- The following addresses had permanent fatal errors -----",
				mci);
			printheader = FALSE;
		}

		snprintf(buf, sizeof buf, "%s",
			 shortenstring(q->q_paddr, MAXSHORTSTR));
		putline(buf, mci);
		if (q->q_alias != NULL)
		{
			snprintf(buf, sizeof buf, "    (expanded from: %s)",
				shortenstring(q->q_alias->q_paddr, MAXSHORTSTR));
			putline(buf, mci);
		}
	}
	if (!printheader)
		putline("", mci);

	printheader = TRUE;
	for (q = e->e_parent->e_sendqueue; q != NULL; q = q->q_next)
	{
		if (bitset(QBADADDR, q->q_flags) ||
		    !bitset(QPRIMARY, q->q_flags) ||
		    !bitset(QDELAYED, q->q_flags))
			continue;

		if (printheader)
		{
			putline("   ----- The following addresses had transient non-fatal errors -----",
				mci);
			printheader = FALSE;
		}

		snprintf(buf, sizeof buf, "%s",
			 shortenstring(q->q_paddr, MAXSHORTSTR));
		putline(buf, mci);
		if (q->q_alias != NULL)
		{
			snprintf(buf, sizeof buf, "    (expanded from: %s)",
				shortenstring(q->q_alias->q_paddr, MAXSHORTSTR));
			putline(buf, mci);
		}
	}
	if (!printheader)
		putline("", mci);

	printheader = TRUE;
	for (q = e->e_parent->e_sendqueue; q != NULL; q = q->q_next)
	{
		if (bitset(QBADADDR, q->q_flags) ||
		    !bitset(QPRIMARY, q->q_flags) ||
		    bitset(QDELAYED, q->q_flags))
			continue;
		else if (!bitset(QPINGONSUCCESS, q->q_flags))
			continue;
		else if (bitset(QRELAYED, q->q_flags))
			p = "relayed to non-DSN-aware mailer";
		else if (bitset(QDELIVERED, q->q_flags))
		{
			if (bitset(QEXPANDED, q->q_flags))
				p = "successfully delivered to mailing list";
d689 1
a689 21
				p = "successfully delivered to mailbox";
		}
		else if (bitset(QEXPANDED, q->q_flags))
			p = "expanded by alias";
		else
			continue;

		if (printheader)
		{
			putline("   ----- The following addresses had successful delivery notifications -----",
				mci);
			printheader = FALSE;
		}

		snprintf(buf, sizeof buf, "%s  (%s)",
			shortenstring(q->q_paddr, MAXSHORTSTR), p);
		putline(buf, mci);
		if (q->q_alias != NULL)
		{
			snprintf(buf, sizeof buf, "    (expanded from: %s)",
				shortenstring(q->q_alias->q_paddr, MAXSHORTSTR));
d691 7
d701 1
a701 1
		putline("", mci);
d716 1
a716 1
		printheader = TRUE;
a719 4
		{
			if (printheader)
				putline("   ----- Transcript of session follows -----\n", mci);
			printheader = FALSE;
a720 1
		}
a724 199
#if DSN
	/*
	**  Output machine-readable version.
	*/

	if (e->e_msgboundary != NULL)
	{
		putline("", mci);
		(void) snprintf(buf, sizeof buf, "--%s", e->e_msgboundary);
		putline(buf, mci);
		putline("Content-Type: message/delivery-status", mci);
		putline("", mci);

		/*
		**  Output per-message information.
		*/

		/* original envelope id from MAIL FROM: line */
		if (e->e_parent->e_envid != NULL)
		{
			(void) snprintf(buf, sizeof buf, "Original-Envelope-Id: %.800s",
				xuntextify(e->e_parent->e_envid));
			putline(buf, mci);
		}

		/* Reporting-MTA: is us (required) */
		(void) snprintf(buf, sizeof buf, "Reporting-MTA: dns; %.800s", MyHostName);
		putline(buf, mci);

		/* DSN-Gateway: not relevant since we are not translating */

		/* Received-From-MTA: shows where we got this message from */
		if (RealHostName != NULL)
		{
			/* XXX use $s for type? */
			if (e->e_parent->e_from.q_mailer == NULL ||
			    (p = e->e_parent->e_from.q_mailer->m_mtatype) == NULL)
				p = "dns";
			(void) snprintf(buf, sizeof buf, "Received-From-MTA: %s; %.800s",
				p, RealHostName);
			putline(buf, mci);
		}

		/* Arrival-Date: -- when it arrived here */
		(void) snprintf(buf, sizeof buf, "Arrival-Date: %s",
			arpadate(ctime(&e->e_parent->e_ctime)));
		putline(buf, mci);

		/*
		**  Output per-address information.
		*/

		for (q = e->e_parent->e_sendqueue; q != NULL; q = q->q_next)
		{
			register ADDRESS *r;
			char *action;

			if (bitset(QBADADDR, q->q_flags))
				action = "failed";
			else if (!bitset(QPRIMARY, q->q_flags))
				continue;
			else if (bitset(QDELIVERED, q->q_flags))
			{
				if (bitset(QEXPANDED, q->q_flags))
					action = "delivered (to mailing list)";
				else
					action = "delivered (to mailbox)";
			}
			else if (bitset(QRELAYED, q->q_flags))
				action = "relayed (to non-DSN-aware mailer)";
			else if (bitset(QEXPANDED, q->q_flags))
				action = "expanded (to multi-recipient alias)";
			else if (bitset(QDELAYED, q->q_flags))
				action = "delayed";
			else
				continue;

			putline("", mci);

			/* Original-Recipient: -- passed from on high */
			if (q->q_orcpt != NULL)
			{
				(void) snprintf(buf, sizeof buf, "Original-Recipient: %.800s",
					q->q_orcpt);
				putline(buf, mci);
			}

			/* Final-Recipient: -- the name from the RCPT command */
			p = e->e_parent->e_from.q_mailer->m_addrtype;
			if (p == NULL)
				p = "rfc822";
			for (r = q; r->q_alias != NULL; r = r->q_alias)
				continue;
			if (strchr(r->q_user, '@@') != NULL)
			{
				(void) snprintf(buf, sizeof buf,
					"Final-Recipient: %s; %.800s",
					p, r->q_user);
			}
			else if (strchr(r->q_paddr, '@@') != NULL)
			{
				(void) snprintf(buf, sizeof buf,
					"Final-Recipient: %s; %.800s",
					p, r->q_paddr);
			}
			else
			{
				(void) snprintf(buf, sizeof buf,
					"Final-Recipient: %s; %.700s@@%.100s",
					p, r->q_user, MyHostName);
			}
			putline(buf, mci);

			/* X-Actual-Recipient: -- the real problem address */
			if (r != q && q->q_user[0] != '\0')
			{
				if (strchr(q->q_user, '@@') == NULL)
				{
					(void) snprintf(buf, sizeof buf,
						"X-Actual-Recipient: %s; %.700s@@%.100s",
						p, q->q_user, MyHostName);
				}
				else
				{
					(void) snprintf(buf, sizeof buf,
						"X-Actual-Recipient: %s; %.800s",
						p, q->q_user);
				}
				putline(buf, mci);
			}

			/* Action: -- what happened? */
			snprintf(buf, sizeof buf, "Action: %s", action);
			putline(buf, mci);

			/* Status: -- what _really_ happened? */
			if (q->q_status != NULL)
				p = q->q_status;
			else if (bitset(QBADADDR, q->q_flags))
				p = "5.0.0";
			else if (bitset(QQUEUEUP, q->q_flags))
				p = "4.0.0";
			else
				p = "2.0.0";
			snprintf(buf, sizeof buf, "Status: %s", p);
			putline(buf, mci);

			/* Remote-MTA: -- who was I talking to? */
			if (q->q_statmta != NULL)
			{
				if (q->q_mailer == NULL ||
				    (p = q->q_mailer->m_mtatype) == NULL)
					p = "dns";
				(void) snprintf(buf, sizeof buf,
					"Remote-MTA: %s; %.800s",
					p, q->q_statmta);
				p = &buf[strlen(buf) - 1];
				if (*p == '.')
					*p = '\0';
				putline(buf, mci);
			}

			/* Diagnostic-Code: -- actual result from other end */
			if (q->q_rstatus != NULL)
			{
				p = q->q_mailer->m_diagtype;
				if (p == NULL)
					p = "smtp";
				(void) snprintf(buf, sizeof buf,
					"Diagnostic-Code: %s; %.800s",
					p, q->q_rstatus);
				putline(buf, mci);
			}

			/* Last-Attempt-Date: -- fine granularity */
			if (q->q_statdate == (time_t) 0L)
				q->q_statdate = curtime();
			(void) snprintf(buf, sizeof buf,
				"Last-Attempt-Date: %s",
				arpadate(ctime(&q->q_statdate)));
			putline(buf, mci);

			/* Will-Retry-Until: -- for delayed messages only */
			if (bitset(QQUEUEUP, q->q_flags) &&
			    !bitset(QBADADDR, q->q_flags))
			{
				time_t xdate;

				xdate = e->e_parent->e_ctime +
					TimeOuts.to_q_return[e->e_parent->e_timeoutclass];
				snprintf(buf, sizeof buf,
					"Will-Retry-Until: %s",
					arpadate(ctime(&xdate)));
				putline(buf, mci);
			}
		}
	}
#endif

d729 2
d732 1
a732 1
	if (bitset(EF_HAS_DF, e->e_parent->e_flags))
d734 5
a738 2
		sendbody = !bitset(EF_NO_BODY_RETN, e->e_parent->e_flags) &&
			   !bitset(EF_NO_BODY_RETN, e->e_flags);
d740 1
a740 1
		if (e->e_msgboundary == NULL)
d742 2
a743 11
			if (sendbody)
				putline("   ----- Original message follows -----\n", mci);
			else
				putline("   ----- Message header follows -----\n", mci);
			(void) fflush(mci->mci_out);
		}
		else
		{
			(void) snprintf(buf, sizeof buf, "--%s",
				e->e_msgboundary);

d745 2
a746 16
			(void) snprintf(buf, sizeof buf, "Content-Type: %s",
				sendbody ? "message/rfc822"
					 : "text/rfc822-headers");
			putline(buf, mci);

			p = hvalue("Content-Transfer-Encoding", e->e_parent->e_header);
			if (p != NULL && strcasecmp(p, "binary") != 0)
				p = NULL;
			if (p == NULL && bitset(EF_HAS8BIT, e->e_parent->e_flags))
				p = "8bit";
			if (p != NULL)
			{
				(void) snprintf(buf, sizeof buf, "Content-Transfer-Encoding: %s",
					p);
				putline(buf, mci);
			}
d748 1
d750 1
a750 2
		putheader(mci, e->e_parent->e_header, e->e_parent);
		if (sendbody)
d752 1
a752 3
		else if (e->e_msgboundary == NULL)
		{
			putline("", mci);
a753 1
		}
d755 1
a755 1
	else if (e->e_msgboundary == NULL)
d763 1
a763 1
		(void) snprintf(buf, sizeof buf, "--%s--", e->e_msgboundary);
a775 251
**  SMTPTODSN -- convert SMTP to DSN status code
**
**	Parameters:
**		smtpstat -- the smtp status code (e.g., 550).
**
**	Returns:
**		The DSN version of the status code.
*/

char *
smtptodsn(smtpstat)
	int smtpstat;
{
	if (smtpstat < 0)
		return "4.4.2";

	switch (smtpstat)
	{
	  case 450:	/* Req mail action not taken: mailbox unavailable */
		return "4.2.0";

	  case 451:	/* Req action aborted: local error in processing */
		return "4.3.0";

	  case 452:	/* Req action not taken: insufficient sys storage */
		return "4.3.1";

	  case 500:	/* Syntax error, command unrecognized */
		return "5.5.2";

	  case 501:	/* Syntax error in parameters or arguments */
		return "5.5.4";

	  case 502:	/* Command not implemented */
		return "5.5.1";

	  case 503:	/* Bad sequence of commands */
		return "5.5.1";

	  case 504:	/* Command parameter not implemented */
		return "5.5.4";

	  case 550:	/* Req mail action not taken: mailbox unavailable */
		return "5.2.0";

	  case 551:	/* User not local; please try <...> */
		return "5.1.6";

	  case 552:	/* Req mail action aborted: exceeded storage alloc */
		return "5.2.2";

	  case 553:	/* Req action not taken: mailbox name not allowed */
		return "5.1.0";

	  case 554:	/* Transaction failed */
		return "5.0.0";
	}

	if ((smtpstat / 100) == 2)
		return "2.0.0";
	if ((smtpstat / 100) == 4)
		return "4.0.0";
	return "5.0.0";
}
/*
**  XTEXTIFY -- take regular text and turn it into DSN-style xtext
**
**	Parameters:
**		t -- the text to convert.
**		taboo -- additional characters that must be encoded.
**
**	Returns:
**		The xtext-ified version of the same string.
*/

char *
xtextify(t, taboo)
	register char *t;
	char *taboo;
{
	register char *p;
	int l;
	int nbogus;
	static char *bp = NULL;
	static int bplen = 0;

	if (taboo == NULL)
		taboo = "";

	/* figure out how long this xtext will have to be */
	nbogus = l = 0;
	for (p = t; *p != '\0'; p++)
	{
		register int c = (*p & 0xff);

		/* ASCII dependence here -- this is the way the spec words it */
		if (c < '!' || c > '~' || c == '+' || c == '\\' || c == '(' ||
		    strchr(taboo, c) != NULL)
			nbogus++;
		l++;
	}
	if (nbogus == 0)
		return t;
	l += nbogus * 2 + 1;

	/* now allocate space if necessary for the new string */
	if (l > bplen)
	{
		if (bp != NULL)
			free(bp);
		bp = xalloc(l);
		bplen = l;
	}

	/* ok, copy the text with byte expansion */
	for (p = bp; *t != '\0'; )
	{
		register int c = (*t++ & 0xff);

		/* ASCII dependence here -- this is the way the spec words it */
		if (c < '!' || c > '~' || c == '+' || c == '\\' || c == '(' ||
		    strchr(taboo, c) != NULL)
		{
			*p++ = '+';
			*p++ = "0123456789abcdef"[c >> 4];
			*p++ = "0123456789abcdef"[c & 0xf];
		}
		else
			*p++ = c;
	}
	*p = '\0';
	return bp;
}
/*
**  XUNTEXTIFY -- take xtext and turn it into plain text
**
**	Parameters:
**		t -- the xtextified text.
**
**	Returns:
**		The decoded text.  No attempt is made to deal with
**		null strings in the resulting text.
*/

char *
xuntextify(t)
	register char *t;
{
	register char *p;
	int l;
	static char *bp = NULL;
	static int bplen = 0;

	/* heuristic -- if no plus sign, just return the input */
	if (strchr(t, '+') == NULL)
		return t;

	/* xtext is always longer than decoded text */
	l = strlen(t);
	if (l > bplen)
	{
		if (bp != NULL)
			free(bp);
		bp = xalloc(l);
		bplen = l;
	}

	/* ok, copy the text with byte compression */
	for (p = bp; *t != '\0'; t++)
	{
		register int c = *t & 0xff;

		if (c != '+')
		{
			*p++ = c;
			continue;
		}

		c = *++t & 0xff;
		if (!isascii(c) || !isxdigit(c))
		{
			/* error -- first digit is not hex */
			usrerr("bogus xtext: +%c", c);
			t--;
			continue;
		}
		if (isdigit(c))
			c -= '0';
		else if (isupper(c))
			c -= 'A' - 10;
		else
			c -= 'a' - 10;
		*p = c << 4;

		c = *++t & 0xff;
		if (!isascii(c) || !isxdigit(c))
		{
			/* error -- second digit is not hex */
			usrerr("bogus xtext: +%x%c", *p >> 4, c);
			t--;
			continue;
		}
		if (isdigit(c))
			c -= '0';
		else if (isupper(c))
			c -= 'A' - 10;
		else
			c -= 'a' - 10;
		*p++ |= c;
	}
	*p = '\0';
	return bp;
}
/*
**  XTEXTOK -- check if a string is legal xtext
**
**	Xtext is used in Delivery Status Notifications.  The spec was
**	taken from RFC 1891, ``SMTP Service Extension for Delivery
**	Status Notifications''.
**
**	Parameters:
**		s -- the string to check.
**
**	Returns:
**		TRUE -- if 's' is legal xtext.
**		FALSE -- if it has any illegal characters in it.
*/

bool
xtextok(s)
	char *s;
{
	int c;

	while ((c = *s++) != '\0')
	{
		if (c == '+')
		{
			c = *s++;
			if (!isascii(c) || !isxdigit(c))
				return FALSE;
			c = *s++;
			if (!isascii(c) || !isxdigit(c))
				return FALSE;
		}
		else if (c < '!' || c > '~' || c == '=')
			return FALSE;
	}
	return TRUE;
}
/*
a791 1
bool
a798 1
	int i;
a810 3
	i = strlen(at + 1);
	if (i >= (SIZE_T) sizeof hostbuf)
		return FALSE;
d812 1
a812 1
	hostbuf[i - 1] = '\0';
d824 1
a824 2
		if (comma != NULL && comma[1] == '@@' &&
		    strlen(comma + 2) < (SIZE_T) sizeof hostbuf)
d827 1
a827 1
			comma = NULL;
@

