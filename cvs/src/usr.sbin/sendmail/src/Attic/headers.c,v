head	1.14;
access;
symbols
	OPENBSD_2_6:1.13.0.4
	OPENBSD_2_6_BASE:1.13
	OPENBSD_2_5:1.13.0.2
	OPENBSD_2_5_BASE:1.13
	OPENBSD_2_4:1.11.0.2
	OPENBSD_2_4_BASE:1.11
	sendmail_8_9_1:1.1.1.2
	UCB:1.1.1
	OPENBSD_2_3:1.9.0.2
	OPENBSD_2_3_BASE:1.9
	OPENBSD_2_2:1.8.0.2
	OPENBSD_2_2_BASE:1.8
	OPENBSD_2_1:1.6.0.2
	OPENBSD_2_1_BASE:1.6
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.14
date	2000.04.18.04.57.20;	author millert;	state dead;
branches;
next	1.13;

1.13
date	99.02.05.05.59.28;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	99.01.01.20.33.47;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	98.08.14.00.55.55;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	98.07.12.19.44.40;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	97.11.09.04.05.40;	author gene;	state Exp;
branches;
next	1.8;

1.8
date	97.08.04.02.17.53;	author downsj;	state Exp;
branches;
next	1.7;

1.7
date	97.07.15.07.24.05;	author downsj;	state Exp;
branches;
next	1.6;

1.6
date	97.01.22.01.07.10;	author downsj;	state Exp;
branches;
next	1.5;

1.5
date	96.12.14.21.17.19;	author downsj;	state Exp;
branches;
next	1.4;

1.4
date	96.09.19.06.44.58;	author fn;	state Exp;
branches;
next	1.3;

1.3
date	96.02.23.17.45.30;	author dm;	state Exp;
branches;
next	1.2;

1.2
date	96.01.29.01.43.56;	author dm;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.48.18;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.48.18;	author deraadt;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	98.07.12.17.10.09;	author millert;	state Exp;
branches;
next	;


desc
@@


1.14
log
@remove sendmail 8.9.3
@
text
@/*
 * Copyright (c) 1998 Sendmail, Inc.  All rights reserved.
 * Copyright (c) 1983, 1995-1997 Eric P. Allman.  All rights reserved.
 * Copyright (c) 1988, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * By using this file, you agree to the terms and conditions set
 * forth in the LICENSE file which can be found at the top level of
 * the sendmail distribution.
 *
 */

#ifndef lint
static char sccsid[] = "@@(#)headers.c	8.136 (Berkeley) 1/26/1999";
#endif /* not lint */

# include <errno.h>
# include "sendmail.h"

/*
**  SETUPHEADERS -- initialize headers in symbol table
**
**	Parameters:
**		none
**
**	Returns:
**		none
*/

void
setupheaders()
{
	struct hdrinfo *hi;
	STAB *s;

	for (hi = HdrInfo; hi->hi_field != NULL; hi++)
	{
		s = stab(hi->hi_field, ST_HEADER, ST_ENTER);
		s->s_header.hi_flags = hi->hi_flags;
		s->s_header.hi_ruleset = NULL;
	}
}
/*
**  CHOMPHEADER -- process and save a header line.
**
**	Called by collect and by readcf to deal with header lines.
**
**	Parameters:
**		line -- header as a text line.
**		def -- if set, this is a default value.
**		hdrp -- a pointer to the place to save the header.
**		e -- the envelope including this header.
**
**	Returns:
**		flags for this header.
**
**	Side Effects:
**		The header is saved on the header list.
**		Contents of 'line' are destroyed.
*/

struct hdrinfo	NormalHeader =	{ NULL, 0, NULL };

int
chompheader(line, def, hdrp, e)
	char *line;
	bool def;
	HDR **hdrp;
	register ENVELOPE *e;
{
	register char *p;
	register HDR *h;
	HDR **hp;
	char *fname;
	char *fvalue;
	bool cond = FALSE;
	bool headeronly;
	STAB *s;
	struct hdrinfo *hi;
	bool nullheader = FALSE;
	BITMAP mopts;

	if (tTd(31, 6))
	{
		printf("chompheader: ");
		xputs(line);
		printf("\n");
	}

	headeronly = hdrp != NULL;
	if (!headeronly)
		hdrp = &e->e_header;

	/* strip off options */
	clrbitmap(mopts);
	p = line;
	if (*p == '?')
	{
		/* have some */
		register char *q = strchr(p + 1, *p);
		
		if (q != NULL)
		{
			*q++ = '\0';
			while (*++p != '\0')
				setbitn(*p, mopts);
			p = q;
		}
		else
			syserr("553 header syntax error, line \"%s\"", line);
		cond = TRUE;
	}

	/* find canonical name */
	fname = p;
	while (isascii(*p) && isgraph(*p) && *p != ':')
		p++;
	fvalue = p;
	while (isascii(*p) && isspace(*p))
		p++;
	if (*p++ != ':' || fname == fvalue)
	{
		syserr("553 header syntax error, line \"%s\"", line);
		return 0;
	}
	*fvalue = '\0';

	/* strip field value on front */
	if (*p == ' ')
		p++;
	fvalue = p;

	/* if the field is null, go ahead and use the default */
	while (isascii(*p) && isspace(*p))
		p++;
	if (*p == '\0')
		nullheader = TRUE;

	/* security scan: long field names are end-of-header */
	if (strlen(fname) > 100)
		return H_EOH;

	/* check to see if it represents a ruleset call */
	if (def)
	{
		char hbuf[50];

		(void) expand(fvalue, hbuf, sizeof hbuf, e);
		for (p = hbuf; isascii(*p) && isspace(*p); )
			p++;
		if ((*p++ & 0377) == CALLSUBR)
		{
			auto char *endp;

			if (strtorwset(p, &endp, ST_ENTER) > 0)
			{
				*endp = '\0';
				s = stab(fname, ST_HEADER, ST_ENTER);
				s->s_header.hi_ruleset = newstr(p);
			}
			return 0;
		}
	}

	/* see if it is a known type */
	s = stab(fname, ST_HEADER, ST_FIND);
	if (s != NULL)
		hi = &s->s_header;
	else
		hi = &NormalHeader;

	if (tTd(31, 9))
	{
		if (s == NULL)
			printf("no header flags match\n");
		else
			printf("header match, flags=%x, ruleset=%s\n", 
				hi->hi_flags,
				hi->hi_ruleset == NULL ? "<NULL>" : hi->hi_ruleset);
	}

	/* see if this is a resent message */
	if (!def && !headeronly && bitset(H_RESENT, hi->hi_flags))
		e->e_flags |= EF_RESENT;

	/* if this is an Errors-To: header keep track of it now */
	if (UseErrorsTo && !def && !headeronly &&
	    bitset(H_ERRORSTO, hi->hi_flags))
		(void) sendtolist(fvalue, NULLADDR, &e->e_errorqueue, 0, e);

	/* if this means "end of header" quit now */
	if (!headeronly && bitset(H_EOH, hi->hi_flags))
		return hi->hi_flags;

	/*
	**  Horrible hack to work around problem with Lotus Notes SMTP
	**  mail gateway, which generates From: headers with newlines in
	**  them and the <address> on the second line.  Although this is
	**  legal RFC 822, many MUAs don't handle this properly and thus
	**  never find the actual address.
	*/

	if (bitset(H_FROM, hi->hi_flags) && SingleLineFromHeader)
	{
		while ((p = strchr(fvalue, '\n')) != NULL)
			*p = ' ';
	}

	/*
	**  If there is a check ruleset, verify it against the header.
	*/

	if (!def && hi->hi_ruleset != NULL)
		(void) rscheck(hi->hi_ruleset, fvalue, NULL, e);

	/*
	**  Drop explicit From: if same as what we would generate.
	**  This is to make MH (which doesn't always give a full name)
	**  insert the full name information in all circumstances.
	*/

	p = "resent-from";
	if (!bitset(EF_RESENT, e->e_flags))
		p += 7;
	if (!def && !headeronly && !bitset(EF_QUEUERUN, e->e_flags) &&
	    strcasecmp(fname, p) == 0)
	{
		if (tTd(31, 2))
		{
			printf("comparing header from (%s) against default (%s or %s)\n",
				fvalue, e->e_from.q_paddr, e->e_from.q_user);
		}
		if (e->e_from.q_paddr != NULL &&
		    (strcmp(fvalue, e->e_from.q_paddr) == 0 ||
		     strcmp(fvalue, e->e_from.q_user) == 0))
			return hi->hi_flags;
	}

	/* delete default value for this header */
	for (hp = hdrp; (h = *hp) != NULL; hp = &h->h_link)
	{
		if (strcasecmp(fname, h->h_field) == 0 &&
		    bitset(H_DEFAULT, h->h_flags) &&
		    !bitset(H_FORCE, h->h_flags))
		{
			if (nullheader)
			{
				/* user-supplied value was null */
				return 0;
			}
			h->h_value = NULL;
			if (!cond)
			{
				/* copy conditions from default case */
				bcopy((char *)h->h_mflags, (char *)mopts,
						sizeof mopts);
			}
		}
	}

	/* create a new node */
	h = (HDR *) xalloc(sizeof *h);
	h->h_field = newstr(fname);
	h->h_value = newstr(fvalue);
	h->h_link = NULL;
	bcopy((char *) mopts, (char *) h->h_mflags, sizeof mopts);
	*hp = h;
	h->h_flags = hi->hi_flags;

	/* strip EOH flag if parsing MIME headers */
	if (headeronly)
		h->h_flags &= ~H_EOH;
	if (def)
		h->h_flags |= H_DEFAULT;
	if (cond)
		h->h_flags |= H_CHECK;

	/* hack to see if this is a new format message */
	if (!def && !headeronly && bitset(H_RCPT|H_FROM, h->h_flags) &&
	    (strchr(fvalue, ',') != NULL || strchr(fvalue, '(') != NULL ||
	     strchr(fvalue, '<') != NULL || strchr(fvalue, ';') != NULL))
	{
		e->e_flags &= ~EF_OLDSTYLE;
	}

	return h->h_flags;
}
/*
**  ADDHEADER -- add a header entry to the end of the queue.
**
**	This bypasses the special checking of chompheader.
**
**	Parameters:
**		field -- the name of the header field.
**		value -- the value of the field.
**		hp -- an indirect pointer to the header structure list.
**
**	Returns:
**		none.
**
**	Side Effects:
**		adds the field on the list of headers for this envelope.
*/

void
addheader(field, value, hdrlist)
	char *field;
	char *value;
	HDR **hdrlist;
{
	register HDR *h;
	STAB *s;
	HDR **hp;

	/* find info struct */
	s = stab(field, ST_HEADER, ST_FIND);

	/* find current place in list -- keep back pointer? */
	for (hp = hdrlist; (h = *hp) != NULL; hp = &h->h_link)
	{
		if (strcasecmp(field, h->h_field) == 0)
			break;
	}

	/* allocate space for new header */
	h = (HDR *) xalloc(sizeof *h);
	h->h_field = field;
	h->h_value = newstr(value);
	h->h_link = *hp;
	h->h_flags = H_DEFAULT;
	if (s != NULL)
		h->h_flags |= s->s_header.hi_flags;
	clrbitmap(h->h_mflags);
	*hp = h;
}
/*
**  HVALUE -- return value of a header.
**
**	Only "real" fields (i.e., ones that have not been supplied
**	as a default) are used.
**
**	Parameters:
**		field -- the field name.
**		header -- the header list.
**
**	Returns:
**		pointer to the value part.
**		NULL if not found.
**
**	Side Effects:
**		none.
*/

char *
hvalue(field, header)
	char *field;
	HDR *header;
{
	register HDR *h;

	for (h = header; h != NULL; h = h->h_link)
	{
		if (!bitset(H_DEFAULT, h->h_flags) &&
		    strcasecmp(h->h_field, field) == 0)
			return (h->h_value);
	}
	return (NULL);
}
/*
**  ISHEADER -- predicate telling if argument is a header.
**
**	A line is a header if it has a single word followed by
**	optional white space followed by a colon.
**
**	Header fields beginning with two dashes, although technically
**	permitted by RFC822, are automatically rejected in order
**	to make MIME work out.  Without this we could have a technically
**	legal header such as ``--"foo:bar"'' that would also be a legal
**	MIME separator.
**
**	Parameters:
**		h -- string to check for possible headerness.
**
**	Returns:
**		TRUE if h is a header.
**		FALSE otherwise.
**
**	Side Effects:
**		none.
*/

bool
isheader(h)
	char *h;
{
	register char *s = h;

	if (s[0] == '-' && s[1] == '-')
		return FALSE;

	while (*s > ' ' && *s != ':' && *s != '\0')
		s++;

	if (h == s)
		return FALSE;

	/* following technically violates RFC822 */
	while (isascii(*s) && isspace(*s))
		s++;

	return (*s == ':');
}
/*
**  EATHEADER -- run through the stored header and extract info.
**
**	Parameters:
**		e -- the envelope to process.
**		full -- if set, do full processing (e.g., compute
**			message priority).  This should not be set
**			when reading a queue file because some info
**			needed to compute the priority is wrong.
**
**	Returns:
**		none.
**
**	Side Effects:
**		Sets a bunch of global variables from information
**			in the collected header.
**		Aborts the message if the hop count is exceeded.
*/

void
eatheader(e, full)
	register ENVELOPE *e;
	bool full;
{
	register HDR *h;
	register char *p;
	int hopcnt = 0;
	char *msgid;
	char buf[MAXLINE];
	extern int priencode __P((char *));

	/*
	**  Set up macros for possible expansion in headers.
	*/

	define('f', e->e_sender, e);
	define('g', e->e_sender, e);
	if (e->e_origrcpt != NULL && *e->e_origrcpt != '\0')
		define('u', e->e_origrcpt, e);
	else
		define('u', NULL, e);

	/* full name of from person */
	p = hvalue("full-name", e->e_header);
	if (p != NULL)
	{
		extern bool rfc822_string __P((char *));

		if (!rfc822_string(p))
		{
			extern char *addquotes __P((char *));

			/*
			**  Quote a full name with special characters
			**  as a comment so crackaddr() doesn't destroy
			**  the name portion of the address.
			*/
			p = addquotes(p);
		}
		define('x', p, e);
	}

	if (tTd(32, 1))
		printf("----- collected header -----\n");
	msgid = NULL;
	for (h = e->e_header; h != NULL; h = h->h_link)
	{
		if (tTd(32, 1))
			printf("%s: ", h->h_field);
		if (h->h_value == NULL)
		{
			if (tTd(32, 1))
				printf("<NULL>\n");
			continue;
		}

		/* do early binding */
		if (bitset(H_DEFAULT, h->h_flags))
		{
			if (tTd(32, 1))
			{
				printf("(");
				xputs(h->h_value);
				printf(") ");
			}
			expand(h->h_value, buf, sizeof buf, e);
			if (buf[0] != '\0')
			{
				if (bitset(H_FROM, h->h_flags))
				{
					extern char *crackaddr __P((char *));

					expand(crackaddr(buf), buf, sizeof buf, e);
				}
				h->h_value = newstr(buf);
				h->h_flags &= ~H_DEFAULT;
			}
		}

		if (tTd(32, 1))
		{
			xputs(h->h_value);
			printf("\n");
		}

		/* count the number of times it has been processed */
		if (bitset(H_TRACE, h->h_flags))
			hopcnt++;

		/* send to this person if we so desire */
		if (GrabTo && bitset(H_RCPT, h->h_flags) &&
		    !bitset(H_DEFAULT, h->h_flags) &&
		    (!bitset(EF_RESENT, e->e_flags) || bitset(H_RESENT, h->h_flags)))
		{
#if 0
			int saveflags = e->e_flags;
#endif

			(void) sendtolist(h->h_value, NULLADDR,
					  &e->e_sendqueue, 0, e);

#if 0
			/*
			**  Change functionality so a fatal error on an
			**  address doesn't affect the entire envelope.
			*/
			 
			/* delete fatal errors generated by this address */
			if (!bitset(EF_FATALERRS, saveflags))
				e->e_flags &= ~EF_FATALERRS;
#endif
		}

		/* save the message-id for logging */
		p = "resent-message-id";
		if (!bitset(EF_RESENT, e->e_flags))
			p += 7;
		if (strcasecmp(h->h_field, p) == 0)
		{
			msgid = h->h_value;
			while (isascii(*msgid) && isspace(*msgid))
				msgid++;
		}
	}
	if (tTd(32, 1))
		printf("----------------------------\n");

	/* if we are just verifying (that is, sendmail -t -bv), drop out now */
	if (OpMode == MD_VERIFY)
		return;

	/* store hop count */
	if (hopcnt > e->e_hopcount)
		e->e_hopcount = hopcnt;

	/* message priority */
	p = hvalue("precedence", e->e_header);
	if (p != NULL)
		e->e_class = priencode(p);
	if (e->e_class < 0)
		e->e_timeoutclass = TOC_NONURGENT;
	else if (e->e_class > 0)
		e->e_timeoutclass = TOC_URGENT;
	if (full)
	{
		e->e_msgpriority = e->e_msgsize
				 - e->e_class * WkClassFact
				 + e->e_nrcpts * WkRecipFact;
	}

	/* message timeout priority */
	p = hvalue("priority", e->e_header);
	if (p != NULL)
	{
		/* (this should be in the configuration file) */
		if (strcasecmp(p, "urgent") == 0)
			e->e_timeoutclass = TOC_URGENT;
		else if (strcasecmp(p, "normal") == 0)
			e->e_timeoutclass = TOC_NORMAL;
		else if (strcasecmp(p, "non-urgent") == 0)
			e->e_timeoutclass = TOC_NONURGENT;
	}

	/* date message originated */
	p = hvalue("posted-date", e->e_header);
	if (p == NULL)
		p = hvalue("date", e->e_header);
	if (p != NULL)
		define('a', p, e);

	/* check to see if this is a MIME message */
	if ((e->e_bodytype != NULL &&
	     strcasecmp(e->e_bodytype, "8BITMIME") == 0) ||
	    hvalue("MIME-Version", e->e_header) != NULL)
	{
		e->e_flags |= EF_IS_MIME;
		if (HasEightBits)
			e->e_bodytype = "8BITMIME";
	}
	else if ((p = hvalue("Content-Type", e->e_header)) != NULL)
	{
		/* this may be an RFC 1049 message */
		p = strpbrk(p, ";/");
		if (p == NULL || *p == ';')
		{
			/* yep, it is */
			e->e_flags |= EF_DONT_MIME;
		}
	}

	/*
	**  From person in antiquated ARPANET mode
	**	required by UK Grey Book e-mail gateways (sigh)
	*/

	if (OpMode == MD_ARPAFTP)
	{
		register struct hdrinfo *hi;

		for (hi = HdrInfo; hi->hi_field != NULL; hi++)
		{
			if (bitset(H_FROM, hi->hi_flags) &&
			    (!bitset(H_RESENT, hi->hi_flags) ||
			     bitset(EF_RESENT, e->e_flags)) &&
			    (p = hvalue(hi->hi_field, e->e_header)) != NULL)
				break;
		}
		if (hi->hi_field != NULL)
		{
			if (tTd(32, 2))
				printf("eatheader: setsender(*%s == %s)\n",
					hi->hi_field, p);
			setsender(p, e, NULL, '\0', TRUE);
		}
	}

	/*
	**  Log collection information.
	*/

	if (bitset(EF_LOGSENDER, e->e_flags) && LogLevel > 4)
		logsender(e, msgid);
	e->e_flags &= ~EF_LOGSENDER;
}
/*
**  LOGSENDER -- log sender information
**
**	Parameters:
**		e -- the envelope to log
**		msgid -- the message id
**
**	Returns:
**		none
*/

void
logsender(e, msgid)
	register ENVELOPE *e;
	char *msgid;
{
	char *name;
	register char *sbp;
	register char *p;
	int l;
	char hbuf[MAXNAME + 1];
	char sbuf[MAXLINE + 1];
	char mbuf[MAXNAME + 1];

	/* don't allow newlines in the message-id */
	if (msgid != NULL)
	{
		l = strlen(msgid);
		if (l > sizeof mbuf - 1)
			l = sizeof mbuf - 1;
		bcopy(msgid, mbuf, l);
		mbuf[l] = '\0';
		p = mbuf;
		while ((p = strchr(p, '\n')) != NULL)
			*p++ = ' ';
	}

	if (bitset(EF_RESPONSE, e->e_flags))
		name = "[RESPONSE]";
	else if ((name = macvalue('_', e)) != NULL)
		;
	else if (RealHostName == NULL)
		name = "localhost";
	else if (RealHostName[0] == '[')
		name = RealHostName;
	else
	{
		name = hbuf;
		(void) snprintf(hbuf, sizeof hbuf, "%.80s", RealHostName);
		if (RealHostAddr.sa.sa_family != 0)
		{
			p = &hbuf[strlen(hbuf)];
			(void) snprintf(p, SPACELEFT(hbuf, p), " (%.100s)",
				anynet_ntoa(&RealHostAddr));
		}
	}

	/* some versions of syslog only take 5 printf args */
#  if (SYSLOG_BUFSIZE) >= 256
	sbp = sbuf;
	snprintf(sbp, SPACELEFT(sbuf, sbp),
	    "from=%.200s, size=%ld, class=%d, pri=%ld, nrcpts=%d",
	    e->e_from.q_paddr == NULL ? "<NONE>" : e->e_from.q_paddr,
	    e->e_msgsize, e->e_class, e->e_msgpriority, e->e_nrcpts);
	sbp += strlen(sbp);
	if (msgid != NULL)
	{
		snprintf(sbp, SPACELEFT(sbuf, sbp), ", msgid=%.100s", mbuf);
		sbp += strlen(sbp);
	}
	if (e->e_bodytype != NULL)
	{
		(void) snprintf(sbp, SPACELEFT(sbuf, sbp), ", bodytype=%.20s",
			e->e_bodytype);
		sbp += strlen(sbp);
	}
	p = macvalue('r', e);
	if (p != NULL)
		(void) snprintf(sbp, SPACELEFT(sbuf, sbp), ", proto=%.20s", p);
	sm_syslog(LOG_INFO, e->e_id,
		"%.850s, relay=%.100s",
		sbuf, name);

#  else			/* short syslog buffer */

	sm_syslog(LOG_INFO, e->e_id,
		"from=%s",
		e->e_from.q_paddr == NULL ? "<NONE>"
					  : shortenstring(e->e_from.q_paddr, 83));
	sm_syslog(LOG_INFO, e->e_id,
		"size=%ld, class=%ld, pri=%ld, nrcpts=%d",
		e->e_msgsize, e->e_class, e->e_msgpriority, e->e_nrcpts);
	if (msgid != NULL)
		sm_syslog(LOG_INFO, e->e_id,
			"msgid=%s",
			shortenstring(mbuf, 83));
	sbp = sbuf;
	*sbp = '\0';
	if (e->e_bodytype != NULL)
	{
		snprintf(sbp, SPACELEFT(sbuf, sbp), "bodytype=%.20s, ", e->e_bodytype);
		sbp += strlen(sbp);
	}
	p = macvalue('r', e);
	if (p != NULL)
	{
		snprintf(sbp, SPACELEFT(sbuf, sbp), "proto=%.20s, ", p);
		sbp += strlen(sbp);
	}
	sm_syslog(LOG_INFO, e->e_id,
		"%.400srelay=%.100s", sbuf, name);
#  endif
}
/*
**  PRIENCODE -- encode external priority names into internal values.
**
**	Parameters:
**		p -- priority in ascii.
**
**	Returns:
**		priority as a numeric level.
**
**	Side Effects:
**		none.
*/

int
priencode(p)
	char *p;
{
	register int i;

	for (i = 0; i < NumPriorities; i++)
	{
		if (!strcasecmp(p, Priorities[i].pri_name))
			return (Priorities[i].pri_val);
	}

	/* unknown priority */
	return (0);
}
/*
**  CRACKADDR -- parse an address and turn it into a macro
**
**	This doesn't actually parse the address -- it just extracts
**	it and replaces it with "$g".  The parse is totally ad hoc
**	and isn't even guaranteed to leave something syntactically
**	identical to what it started with.  However, it does leave
**	something semantically identical.
**
**	This algorithm has been cleaned up to handle a wider range
**	of cases -- notably quoted and backslash escaped strings.
**	This modification makes it substantially better at preserving
**	the original syntax.
**
**	Parameters:
**		addr -- the address to be cracked.
**
**	Returns:
**		a pointer to the new version.
**
**	Side Effects:
**		none.
**
**	Warning:
**		The return value is saved in local storage and should
**		be copied if it is to be reused.
*/

char *
crackaddr(addr)
	register char *addr;
{
	register char *p;
	register char c;
	int cmtlev;
	int realcmtlev;
	int anglelev, realanglelev;
	int copylev;
	int bracklev;
	bool qmode;
	bool realqmode;
	bool skipping;
	bool putgmac = FALSE;
	bool quoteit = FALSE;
	bool gotangle = FALSE;
	bool gotcolon = FALSE;
	register char *bp;
	char *buflim;
	char *bufhead;
	char *addrhead;
	static char buf[MAXNAME + 1];

	if (tTd(33, 1))
		printf("crackaddr(%s)\n", addr);

	/* strip leading spaces */
	while (*addr != '\0' && isascii(*addr) && isspace(*addr))
		addr++;

	/*
	**  Start by assuming we have no angle brackets.  This will be
	**  adjusted later if we find them.
	*/

	bp = bufhead = buf;
	buflim = &buf[sizeof buf - 7];
	p = addrhead = addr;
	copylev = anglelev = realanglelev = cmtlev = realcmtlev = 0;
	bracklev = 0;
	qmode = realqmode = FALSE;

	while ((c = *p++) != '\0')
	{
		/*
		**  If the buffer is overful, go into a special "skipping"
		**  mode that tries to keep legal syntax but doesn't actually
		**  output things.
		*/

		skipping = bp >= buflim;

		if (copylev > 0 && !skipping)
			*bp++ = c;

		/* check for backslash escapes */
		if (c == '\\')
		{
			/* arrange to quote the address */
			if (cmtlev <= 0 && !qmode)
				quoteit = TRUE;

			if ((c = *p++) == '\0')
			{
				/* too far */
				p--;
				goto putg;
			}
			if (copylev > 0 && !skipping)
				*bp++ = c;
			goto putg;
		}

		/* check for quoted strings */
		if (c == '"' && cmtlev <= 0)
		{
			qmode = !qmode;
			if (copylev > 0 && !skipping)
				realqmode = !realqmode;
			continue;
		}
		if (qmode)
			goto putg;

		/* check for comments */
		if (c == '(')
		{
			cmtlev++;

			/* allow space for closing paren */
			if (!skipping)
			{
				buflim--;
				realcmtlev++;
				if (copylev++ <= 0)
				{
					if (bp != bufhead)
						*bp++ = ' ';
					*bp++ = c;
				}
			}
		}
		if (cmtlev > 0)
		{
			if (c == ')')
			{
				cmtlev--;
				copylev--;
				if (!skipping)
				{
					realcmtlev--;
					buflim++;
				}
			}
			continue;
		}
		else if (c == ')')
		{
			/* syntax error: unmatched ) */
			if (copylev > 0 && !skipping)
				bp--;
		}

		/* count nesting on [ ... ] (for IPv6 domain literals) */
		if (c == '[')
			bracklev++;
		else if (c == ']')
			bracklev--;

		/* check for group: list; syntax */
		if (c == ':' && anglelev <= 0 && bracklev <= 0 &&
		    !gotcolon && !ColonOkInAddr)
		{
			register char *q;

			/*
			**  Check for DECnet phase IV ``::'' (host::user)
			**  or **  DECnet phase V ``:.'' syntaxes.  The latter
			**  covers ``user@@DEC:.tay.myhost'' and
			**  ``DEC:.tay.myhost::user'' syntaxes (bletch).
			*/

			if (*p == ':' || *p == '.')
			{
				if (cmtlev <= 0 && !qmode)
					quoteit = TRUE;
				if (copylev > 0 && !skipping)
				{
					*bp++ = c;
					*bp++ = *p;
				}
				p++;
				goto putg;
			}

			gotcolon = TRUE;

			bp = bufhead;
			if (quoteit)
			{
				*bp++ = '"';

				/* back up over the ':' and any spaces */
				--p;
				while (isascii(*--p) && isspace(*p))
					continue;
				p++;
			}
			for (q = addrhead; q < p; )
			{
				c = *q++;
				if (bp < buflim)
				{
					if (quoteit && c == '"')
						*bp++ = '\\';
					*bp++ = c;
				}
			}
			if (quoteit)
			{
				if (bp == &bufhead[1])
					bp--;
				else
					*bp++ = '"';
				while ((c = *p++) != ':')
				{
					if (bp < buflim)
						*bp++ = c;
				}
				*bp++ = c;
			}

			/* any trailing white space is part of group: */
			while (isascii(*p) && isspace(*p) && bp < buflim)
				*bp++ = *p++;
			copylev = 0;
			putgmac = quoteit = FALSE;
			bufhead = bp;
			addrhead = p;
			continue;
		}

		if (c == ';' && copylev <= 0 && !ColonOkInAddr)
		{
			if (bp < buflim)
				*bp++ = c;
		}

		/* check for characters that may have to be quoted */
		if (strchr(MustQuoteChars, c) != NULL)
		{
			/*
			**  If these occur as the phrase part of a <>
			**  construct, but are not inside of () or already
			**  quoted, they will have to be quoted.  Note that
			**  now (but don't actually do the quoting).
			*/

			if (cmtlev <= 0 && !qmode)
				quoteit = TRUE;
		}

		/* check for angle brackets */
		if (c == '<')
		{
			register char *q;

			/* assume first of two angles is bogus */
			if (gotangle)
				quoteit = TRUE;
			gotangle = TRUE;

			/* oops -- have to change our mind */
			anglelev = 1;
			if (!skipping)
				realanglelev = 1;

			bp = bufhead;
			if (quoteit)
			{
				*bp++ = '"';

				/* back up over the '<' and any spaces */
				--p;
				while (isascii(*--p) && isspace(*p))
					continue;
				p++;
			}
			for (q = addrhead; q < p; )
			{
				c = *q++;
				if (bp < buflim)
				{
					if (quoteit && c == '"')
						*bp++ = '\\';
					*bp++ = c;
				}
			}
			if (quoteit)
			{
				if (bp == &buf[1])
					bp--;
				else
					*bp++ = '"';
				while ((c = *p++) != '<')
				{
					if (bp < buflim)
						*bp++ = c;
				}
				*bp++ = c;
			}
			copylev = 0;
			putgmac = quoteit = FALSE;
			continue;
		}

		if (c == '>')
		{
			if (anglelev > 0)
			{
				anglelev--;
				if (!skipping)
				{
					realanglelev--;
					buflim++;
				}
			}
			else if (!skipping)
			{
				/* syntax error: unmatched > */
				if (copylev > 0)
					bp--;
				quoteit = TRUE;
				continue;
			}
			if (copylev++ <= 0)
				*bp++ = c;
			continue;
		}

		/* must be a real address character */
	putg:
		if (copylev <= 0 && !putgmac)
		{
			if (bp > bufhead && bp[-1] == ')')
				*bp++ = ' ';
			*bp++ = MACROEXPAND;
			*bp++ = 'g';
			putgmac = TRUE;
		}
	}

	/* repair any syntactic damage */
	if (realqmode)
		*bp++ = '"';
	while (realcmtlev-- > 0)
		*bp++ = ')';
	while (realanglelev-- > 0)
		*bp++ = '>';
	*bp++ = '\0';

	if (tTd(33, 1))
	{
		printf("crackaddr=>`");
		xputs(buf);
		printf("'\n");
	}

	return (buf);
}
/*
**  PUTHEADER -- put the header part of a message from the in-core copy
**
**	Parameters:
**		mci -- the connection information.
**		h -- the header to put.
**		e -- envelope to use.
**		flags -- MIME conversion flags.
**
**	Returns:
**		none.
**
**	Side Effects:
**		none.
*/

/*
 * Macro for fast max (not available in e.g. DG/UX, 386/ix).
 */
#ifndef MAX
# define MAX(a,b) (((a)>(b))?(a):(b))
#endif

void
putheader(mci, hdr, e, flags)
	register MCI *mci;
	HDR *hdr;
	register ENVELOPE *e;
	int flags;
{
	register HDR *h;
	char buf[MAX(MAXLINE,BUFSIZ)];
	char obuf[MAXLINE];

	if (tTd(34, 1))
		printf("--- putheader, mailer = %s ---\n",
			mci->mci_mailer->m_name);

	/*
	**  If we're in MIME mode, we're not really in the header of the
	**  message, just the header of one of the parts of the body of
	**  the message.  Therefore MCIF_INHEADER should not be turned on.
	*/

	if (!bitset(MCIF_INMIME, mci->mci_flags))
		mci->mci_flags |= MCIF_INHEADER;

	for (h = hdr; h != NULL; h = h->h_link)
	{
		register char *p = h->h_value;
		extern bool bitintersect __P((BITMAP, BITMAP));

		if (tTd(34, 11))
		{
			printf("  %s: ", h->h_field);
			xputs(p);
		}

#if _FFR_MAX_MIME_HEADER_LENGTH
		/* heuristic shortening of MIME fields to avoid MUA overflows */
		if (MaxMimeFieldLength > 0 &&
		    wordinclass(h->h_field,
				macid("{checkMIMEFieldHeaders}", NULL)))
		{
			extern bool fix_mime_header __P((char *));

			if (fix_mime_header(h->h_value))
			{
				sm_syslog(LOG_ALERT, e->e_id,
				  	"Truncated MIME %s header due to field size (possible attack)",
				  	h->h_field);
				if (tTd(34, 11))
				  	printf("  truncated MIME %s header due to field size (possible attack)\n",
					  	h->h_field);
			}
		}

		if (MaxMimeHeaderLength > 0 &&
		    wordinclass(h->h_field,
				macid("{checkMIMETextHeaders}", NULL)))
		{
			if (strlen(h->h_value) > MaxMimeHeaderLength)
			{
				h->h_value[MaxMimeHeaderLength - 1] = '\0';
				sm_syslog(LOG_ALERT, e->e_id,
				  	"Truncated long MIME %s header (possible attack)",
				  	h->h_field);
				if (tTd(34, 11))
				  	printf("  truncated long MIME %s header (possible attack)\n",
					  	h->h_field);
			}
		}

		if (MaxMimeHeaderLength > 0 &&
		    wordinclass(h->h_field,
				macid("{checkMIMEHeaders}", NULL)))
		{
			extern bool shorten_rfc822_string __P((char *, int));

			if (shorten_rfc822_string(h->h_value, MaxMimeHeaderLength))
			{
				sm_syslog(LOG_ALERT, e->e_id,
				  	"Truncated long MIME %s header (possible attack)",
				  	h->h_field);
				if (tTd(34, 11))
				  	printf("  truncated long MIME %s header (possible attack)\n",
					  	h->h_field);
			}
		}
#endif

		/*
		**  Suppress Content-Transfer-Encoding: if we are MIMEing
		**  and we are potentially converting from 8 bit to 7 bit
		**  MIME.  If converting, add a new CTE header in
		**  mime8to7().
		*/
		if (bitset(H_CTE, h->h_flags) &&
		    bitset(MCIF_CVT8TO7|MCIF_CVT7TO8|MCIF_INMIME,
			   mci->mci_flags) &&
		    !bitset(M87F_NO8TO7, flags))
		{
			if (tTd(34, 11))
				printf(" (skipped (content-transfer-encoding))\n");
			continue;
		}

		if (bitset(MCIF_INMIME, mci->mci_flags))
		{
			if (tTd(34, 11))
				printf("\n");
			put_vanilla_header(h, p, mci);
			continue;
		}

		if (bitset(H_CHECK|H_ACHECK, h->h_flags) &&
		    !bitintersect(h->h_mflags, mci->mci_mailer->m_flags))
		{
			if (tTd(34, 11))
				printf(" (skipped)\n");
			continue;
		}

		/* handle Resent-... headers specially */
		if (bitset(H_RESENT, h->h_flags) && !bitset(EF_RESENT, e->e_flags))
		{
			if (tTd(34, 11))
				printf(" (skipped (resent))\n");
			continue;
		}

		/* suppress return receipts if requested */
		if (bitset(H_RECEIPTTO, h->h_flags) &&
#if _FFR_DSN_RRT_OPTION
		    (RrtImpliesDsn || bitset(EF_NORECEIPT, e->e_flags)))
#else
		    bitset(EF_NORECEIPT, e->e_flags))
#endif
		{
			if (tTd(34, 11))
				printf(" (skipped (receipt))\n");
			continue;
		}

		/* macro expand value if generated internally */
		if (bitset(H_DEFAULT, h->h_flags))
		{
			expand(p, buf, sizeof buf, e);
			p = buf;
			if (*p == '\0')
			{
				if (tTd(34, 11))
					printf(" (skipped -- null value)\n");
				continue;
			}
		}

		if (bitset(H_BCC, h->h_flags))
		{
			/* Bcc: field -- either truncate or delete */
			if (bitset(EF_DELETE_BCC, e->e_flags))
			{
				if (tTd(34, 11))
					printf(" (skipped -- bcc)\n");
			}
			else
			{
				/* no other recipient headers: truncate value */
				(void) snprintf(obuf, sizeof obuf, "%s:",
					h->h_field);
				putline(obuf, mci);
			}
			continue;
		}

		if (tTd(34, 11))
			printf("\n");

		if (bitset(H_FROM|H_RCPT, h->h_flags))
		{
			/* address field */
			bool oldstyle = bitset(EF_OLDSTYLE, e->e_flags);

			if (bitset(H_FROM, h->h_flags))
				oldstyle = FALSE;
			commaize(h, p, oldstyle, mci, e);
		}
		else
		{
			put_vanilla_header(h, p, mci);
		}
	}

	/*
	**  If we are converting this to a MIME message, add the
	**  MIME headers.
	*/

#if MIME8TO7
	if (bitset(MM_MIME8BIT, MimeMode) &&
	    bitset(EF_HAS8BIT, e->e_flags) &&
	    !bitset(EF_DONT_MIME, e->e_flags) &&
	    !bitnset(M_8BITS, mci->mci_mailer->m_flags) &&
	    !bitset(MCIF_CVT8TO7|MCIF_CVT7TO8, mci->mci_flags))
	{
		if (hvalue("MIME-Version", e->e_header) == NULL)
			putline("MIME-Version: 1.0", mci);
		if (hvalue("Content-Type", e->e_header) == NULL)
		{
			snprintf(obuf, sizeof obuf,
				"Content-Type: text/plain; charset=%s",
				defcharset(e));
			putline(obuf, mci);
		}
		if (hvalue("Content-Transfer-Encoding", e->e_header) == NULL)
			putline("Content-Transfer-Encoding: 8bit", mci);
	}
#endif
}
/*
**  PUT_VANILLA_HEADER -- output a fairly ordinary header
**
**	Parameters:
**		h -- the structure describing this header
**		v -- the value of this header
**		mci -- the connection info for output
**
**	Returns:
**		none.
*/

void
put_vanilla_header(h, v, mci)
	HDR *h;
	char *v;
	MCI *mci;
{
	register char *nlp;
	register char *obp;
	int putflags;
	char obuf[MAXLINE];

	putflags = PXLF_HEADER;
#if _FFR_7BITHDRS
	if (bitnset(M_7BITHDRS, mci->mci_mailer->m_flags))
		putflags |= PXLF_STRIP8BIT;
#endif
	(void) snprintf(obuf, sizeof obuf, "%.200s: ", h->h_field);
	obp = obuf + strlen(obuf);
	while ((nlp = strchr(v, '\n')) != NULL)
	{
		int l;

		l = nlp - v;
		if (SPACELEFT(obuf, obp) - 1 < l)
			l = SPACELEFT(obuf, obp) - 1;

		snprintf(obp, SPACELEFT(obuf, obp), "%.*s", l, v);
		putxline(obuf, strlen(obuf), mci, putflags);
		v += l + 1;
		obp = obuf;
		if (*v != ' ' && *v != '\t')
			*obp++ = ' ';
	}
	snprintf(obp, SPACELEFT(obuf, obp), "%.*s",
		sizeof obuf - (obp - obuf) - 1, v);
	putxline(obuf, strlen(obuf), mci, putflags);
}
/*
**  COMMAIZE -- output a header field, making a comma-translated list.
**
**	Parameters:
**		h -- the header field to output.
**		p -- the value to put in it.
**		oldstyle -- TRUE if this is an old style header.
**		mci -- the connection information.
**		e -- the envelope containing the message.
**
**	Returns:
**		none.
**
**	Side Effects:
**		outputs "p" to file "fp".
*/

void
commaize(h, p, oldstyle, mci, e)
	register HDR *h;
	register char *p;
	bool oldstyle;
	register MCI *mci;
	register ENVELOPE *e;
{
	register char *obp;
	int opos;
	int omax;
	bool firstone = TRUE;
	int putflags = PXLF_HEADER;
	char obuf[MAXLINE + 3];

	/*
	**  Output the address list translated by the
	**  mailer and with commas.
	*/

	if (tTd(14, 2))
		printf("commaize(%s: %s)\n", h->h_field, p);

#if _FFR_7BITHDRS
	if (bitnset(M_7BITHDRS, mci->mci_mailer->m_flags))
		putflags |= PXLF_STRIP8BIT;
#endif

	obp = obuf;
	(void) snprintf(obp, SPACELEFT(obuf, obp), "%.200s: ", h->h_field);
	opos = strlen(h->h_field) + 2;
	if (opos > 202)
		opos = 202;
	obp += opos;
	omax = mci->mci_mailer->m_linelimit - 2;
	if (omax < 0 || omax > 78)
		omax = 78;

	/*
	**  Run through the list of values.
	*/

	while (*p != '\0')
	{
		register char *name;
		register int c;
		char savechar;
		int flags;
		auto int stat;

		/*
		**  Find the end of the name.  New style names
		**  end with a comma, old style names end with
		**  a space character.  However, spaces do not
		**  necessarily delimit an old-style name -- at
		**  signs mean keep going.
		*/

		/* find end of name */
		while ((isascii(*p) && isspace(*p)) || *p == ',')
			p++;
		name = p;
		for (;;)
		{
			auto char *oldp;
			char pvpbuf[PSBUFSIZE];

			(void) prescan(p, oldstyle ? ' ' : ',', pvpbuf,
				       sizeof pvpbuf, &oldp, NULL);
			p = oldp;

			/* look to see if we have an at sign */
			while (*p != '\0' && isascii(*p) && isspace(*p))
				p++;

			if (*p != '@@')
			{
				p = oldp;
				break;
			}
			p += *p == '@@' ? 1 : 2;
			while (*p != '\0' && isascii(*p) && isspace(*p))
				p++;
		}
		/* at the end of one complete name */

		/* strip off trailing white space */
		while (p >= name &&
		       ((isascii(*p) && isspace(*p)) || *p == ',' || *p == '\0'))
			p--;
		if (++p == name)
			continue;
		savechar = *p;
		*p = '\0';

		/* translate the name to be relative */
		flags = RF_HEADERADDR|RF_ADDDOMAIN;
		if (bitset(H_FROM, h->h_flags))
			flags |= RF_SENDERADDR;
#if USERDB
		else if (e->e_from.q_mailer != NULL &&
			 bitnset(M_UDBRECIPIENT, e->e_from.q_mailer->m_flags))
		{
			extern char *udbsender __P((char *));
			char *q;

			q = udbsender(name);
			if (q != NULL)
				name = q;
		}
#endif
		stat = EX_OK;
		name = remotename(name, mci->mci_mailer, flags, &stat, e);
		if (*name == '\0')
		{
			*p = savechar;
			continue;
		}
		name = denlstring(name, FALSE, TRUE);

		/* output the name with nice formatting */
		opos += strlen(name);
		if (!firstone)
			opos += 2;
		if (opos > omax && !firstone)
		{
			snprintf(obp, SPACELEFT(obuf, obp), ",\n");
			putxline(obuf, strlen(obuf), mci, putflags);
			obp = obuf;
			(void) strcpy(obp, "        ");
			opos = strlen(obp);
			obp += opos;
			opos += strlen(name);
		}
		else if (!firstone)
		{
			snprintf(obp, SPACELEFT(obuf, obp), ", ");
			obp += 2;
		}

		while ((c = *name++) != '\0' && obp < &obuf[MAXLINE])
			*obp++ = c;
		firstone = FALSE;
		*p = savechar;
	}
	*obp = '\0';
	putxline(obuf, strlen(obuf), mci, putflags);
}
/*
**  COPYHEADER -- copy header list
**
**	This routine is the equivalent of newstr for header lists
**
**	Parameters:
**		header -- list of header structures to copy.
**
**	Returns:
**		a copy of 'header'.
**
**	Side Effects:
**		none.
*/

HDR *
copyheader(header)
	register HDR *header;
{
	register HDR *newhdr;
	HDR *ret;
	register HDR **tail = &ret;

	while (header != NULL)
	{
		newhdr = (HDR *) xalloc(sizeof(HDR));
		STRUCTCOPY(*header, *newhdr);
		*tail = newhdr;
		tail = &newhdr->h_link;
		header = header->h_link;
	}
	*tail = NULL;
	
	return ret;
}
/*
**  FIX_MIME_HEADER -- possibly truncate/rebalance parameters in a MIME header
**
**	Run through all of the parameters of a MIME header and
**	possibly truncate and rebalance the parameter according
**	to MaxMimeFieldLength.
**
**	Parameters:
**		string -- the full header
**
**	Returns:
**		TRUE if the header was modified, FALSE otherwise
**
**	Side Effects:
**		string modified in place
*/

bool
fix_mime_header(string)
	char *string;
{
	bool modified = FALSE;
	char *begin = string;
	char *end;
	extern char *find_character __P((char *, char));
	extern bool shorten_rfc822_string __P((char *, int));
	
	if (string == NULL || *string == '\0')
		return FALSE;
	
	/* Split on each ';' */
	while ((end = find_character(begin, ';')) != NULL)
	{
		char save = *end;
		char *bp;
		
		*end = '\0';
		
		/* Shorten individual parameter */
		if (shorten_rfc822_string(begin, MaxMimeFieldLength))
			modified = TRUE;
		
		/* Collapse the possibly shortened string with rest */
		bp = begin + strlen(begin);
		if (bp != end)
		{
			char *ep = end;
			
			*end = save;
			end = bp;
			
			/* copy character by character due to overlap */
			while (*ep != '\0')
				*bp++ = *ep++;
			*bp = '\0';
		}
		else
			*end = save;
		if (*end == '\0')
			break;
		
		/* Move past ';' */
		begin = end + 1;
	}
	return modified;
}
@


1.13
log
@sendmail 8.9.3
@
text
@@


1.12
log
@sendmail 8.9.2
@
text
@d14 1
a14 1
static char sccsid[] = "@@(#)headers.c	8.134 (Berkeley) 11/29/1998";
d80 1
d127 4
d133 5
a137 3
	/* strip field value on front */
	if (*fvalue == ' ')
		fvalue++;
d246 5
d1164 1
d1181 1
a1181 1
putheader(mci, hdr, e)
d1185 1
d1268 6
a1273 1
		/* suppress Content-Transfer-Encoding: if we are MIMEing */
d1275 3
a1277 1
		    bitset(MCIF_CVT8TO7|MCIF_CVT7TO8|MCIF_INMIME, mci->mci_flags))
@


1.11
log
@Update to sendmail.8.9.1a which adds support for MaxMimeHeaderLength option, to help avoid buffer oflows in stupid clients (only if enabled in .cf file)
@
text
@d14 1
a14 1
static char sccsid[] = "@@(#)headers.c	8.127 (Berkeley) 6/4/98";
d524 2
a525 2
			** Change functionality so a fatal error on an
			** address doesn't affect the entire envelope.
d1203 3
a1205 1
		if (wordinclass(h->h_field, macid("{checkMIMEFieldHeaders}", NULL)))
d1220 19
a1238 1
		if (wordinclass(h->h_field, macid("{checkMIMEHeaders}", NULL)))
@


1.10
log
@something hosed the sendmail import; fix up by hand
@
text
@d1201 33
d1603 66
@


1.9
log
@Upgrade to sendmail 8.8.8
@
text
@d2 2
a3 1
 * Copyright (c) 1983, 1995-1997 Eric P. Allman
d7 3
a9 15
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
a10 11
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
d14 1
a14 1
static char sccsid[] = "@@(#)headers.c	8.115 (Berkeley) 10/22/97";
a135 1
#if _FFR_HEADER_RSCHECK
a156 1
#endif
d185 1
a185 1
	if (bitset(H_EOH, hi->hi_flags))
d257 4
d446 14
d461 1
d491 1
a491 1
					extern char *crackaddr();
d515 1
d517 1
d1181 9
a1189 1
	mci->mci_flags |= MCIF_INHEADER;
d1193 1
a1193 1
		extern bool bitintersect();
d1491 1
a1491 1
			extern char *udbsender();
@


1.8
log
@sendmail 8.8.7.
@
text
@d36 1
a36 1
static char sccsid[] = "@@(#)headers.c	8.111 (Berkeley) 7/9/97";
d525 6
d532 1
a532 1
			if (!GrabTo && !bitset(EF_FATALERRS, saveflags))
d534 1
d1340 1
a1340 1
	putflags = 0;
d1352 2
a1353 2
		if (sizeof obuf - (obp - obuf) < l)
			l = sizeof obuf - (obp - obuf);
d1395 1
a1395 1
	int putflags = 0;
d1501 1
@


1.7
log
@Sendmail 8.8.6.
@
text
@d36 1
a36 1
static char sccsid[] = "@@(#)headers.c	8.110 (Berkeley) 6/14/97";
d195 2
a196 1
				hi->hi_flags, hi->hi_ruleset);
@


1.6
log
@Sendmail 8.8.5.
@
text
@d2 1
a2 1
 * Copyright (c) 1983, 1995, 1996 Eric P. Allman
d36 1
a36 1
static char sccsid[] = "@@(#)headers.c	8.103 (Berkeley) 12/11/96";
d43 23
d84 2
a97 1
	struct hdrinfo *hi;
d100 2
d145 1
a145 1
		return (0);
d158 3
a160 2
	/* see if it is a known type */
	for (hi = HdrInfo; hi->hi_field != NULL; hi++)
d162 17
a178 2
		if (strcasecmp(hi->hi_field, fname) == 0)
			break;
d180 8
d191 2
a192 2
		if (hi->hi_field == NULL)
			printf("no header match\n");
d194 2
a195 1
			printf("header match, hi_flags=%x\n", hi->hi_flags);
d209 1
a209 1
		return (hi->hi_flags);
d226 7
d252 1
a252 1
			return (hi->hi_flags);
d293 1
a293 1
	return (h->h_flags);
d319 1
a319 1
	register struct hdrinfo *hi;
d323 1
a323 5
	for (hi = HdrInfo; hi->hi_field != NULL; hi++)
	{
		if (strcasecmp(field, hi->hi_field) == 0)
			break;
	}
d337 3
a339 1
	h->h_flags = hi->hi_flags | H_DEFAULT;
a635 1
# ifdef LOG
a637 1
# endif /* LOG */
a655 1
# ifdef LOG
d719 3
a721 2
	syslog(LOG_INFO, "%s: %.850s, relay=%.100s",
	    e->e_id, sbuf, name);
d725 7
a731 6
	syslog(LOG_INFO, "%s: from=%s",
		e->e_id, e->e_from.q_paddr == NULL ? "<NONE>" :
				shortenstring(e->e_from.q_paddr, 83));
	syslog(LOG_INFO, "%s: size=%ld, class=%ld, pri=%ld, nrcpts=%d",
		e->e_id, e->e_msgsize, e->e_class,
		e->e_msgpriority, e->e_nrcpts);
d733 3
a735 2
		syslog(LOG_INFO, "%s: msgid=%s",
			e->e_id, shortenstring(mbuf, 83));
d737 1
a737 2
	snprintf(sbp, SPACELEFT(sbuf, sbp), "%s:", e->e_id);
	sbp += strlen(sbp);
d740 1
a740 1
		snprintf(sbp, SPACELEFT(sbuf, sbp), " bodytype=%.20s,", e->e_bodytype);
d746 1
a746 1
		snprintf(sbp, SPACELEFT(sbuf, sbp), " proto=%.20s,", p);
d749 2
a750 1
	syslog(LOG_INFO, "%.400s relay=%.100s", sbuf, name);
a751 1
# endif
d846 1
a846 1
	buflim = &buf[sizeof buf - 6];
d1223 1
a1223 1
#if _FFR_DSN_RRT
d1239 1
a1239 1
			if (p == NULL || *p == '\0')
d1333 1
a1333 1
#ifdef _FFR_7BITHDRS
d1348 1
a1348 1
		putxline(obuf, mci, putflags);
d1356 1
a1356 1
	putxline(obuf, mci, putflags);
d1398 1
a1398 1
#ifdef _FFR_7BITHDRS
d1406 2
d1501 1
a1501 1
			putxline(obuf, mci, putflags);
d1520 1
a1520 1
	putxline(obuf, mci, putflags);
@


1.5
log
@Update to Sendmail 8.8.4, plus recent patches, plus OpenBSD support.
Also include entire example configuration subset.
Includes smrsh (using /usr/libexec/sm.bin).

Of the top of my head, the only things I removed from the distribution were
contrib/mail.local.linux, src/Makefiles, all the *.0 and *.ps files.
Our praliases man page replaces the distributed one, ours is better.
@
text
@d36 1
a36 1
static char sccsid[] = "@@(#)headers.c	8.101 (Berkeley) 11/23/96";
d572 1
a572 1
			setsender(p, e, NULL, TRUE);
d1168 3
d1172 1
@


1.4
log
@bring up to 8.7.6
@
text
@d2 1
a2 1
 * Copyright (c) 1983, 1995 Eric P. Allman
d36 1
a36 1
static char sccsid[] = "@@(#)headers.c	8.82.1.2 (Berkeley) 9/16/96";
a76 1
	char buf[MAXNAME + 1];
a159 1
#ifdef LOTUS_NOTES_HACK
a172 1
#endif
a194 40
#ifdef MAYBENEXTRELEASE		/* XXX UNTESTED XXX UNTESTED XXX UNTESTED XXX */
#if USERDB
		else
		{
			auto ADDRESS a;
			char *fancy;
			bool oldSuprErrs = SuprErrs;
			extern char *crackaddr();
			extern char *udbsender();

			/*
			**  Try doing USERDB rewriting even on fully commented
			**  names; this saves the "comment" information (such
			**  as full name) and rewrites the electronic part.
			**
			** XXX	This code doesn't belong here -- parsing should
			** XXX	not be done during collect() phase because
			** XXX	error messages can confuse the SMTP phase.
			** XXX	Setting SuprErrs is a crude hack around this
			** XXX	problem.
			*/

			if (OpMode == MD_SMTP || OpMode == MD_ARPAFTP)
				SuprErrs = TRUE;
			fancy = crackaddr(fvalue);
			if (parseaddr(fvalue, &a, RF_COPYNONE, '\0', NULL, e) != NULL &&
			    bitnset(M_CHECKUDB, a.q_mailer->m_flags) &&
			    (p = udbsender(a.q_user)) != NULL)
			{
				char *oldg = macvalue('g', e);

				define('g', p, e);
				expand(fancy, buf, sizeof buf, e);
				define('g', oldg, e);
				fvalue = buf;
			}
			SuprErrs = oldSuprErrs;
		}
#endif
#endif
d393 1
a482 4

		/* see if this is a return-receipt header */
		if (bitset(H_RECEIPTTO, h->h_flags))
			e->e_receiptto = h->h_value;
d515 1
a515 1
		if (strcasecmp(p, "urgent"))
d517 1
a517 1
		else if (strcasecmp(p, "normal"))
d519 1
a519 1
		else if (strcasecmp(p, "non-urgent"))
d764 1
d791 1
a791 1
	buflim = &buf[sizeof buf - 5];
d794 1
d851 2
a852 1
					*bp++ = ' ';
d878 6
d885 2
a886 1
		if (c == ':' && anglelev <= 0 && !gotcolon && !ColonOkInAddr)
d890 8
a897 1
			if (*p == ':')
a898 1
				/* special case -- :: syntax */
d904 1
a904 1
					*bp++ = c;
d1059 2
d1077 5
a1081 1
		printf("crackaddr=>`%s'\n", buf);
d1108 1
a1108 1
putheader(mci, h, e)
d1110 1
a1110 1
	register HDR *h;
d1113 1
d1122 1
a1122 1
	for (; h != NULL; h = h->h_link)
d1135 1
a1135 1
		    bitset(MCIF_CVT8TO7|MCIF_INMIME, mci->mci_flags))
d1146 2
a1147 1
			goto vanilla;
d1220 1
a1220 25
			/* vanilla header line */
			register char *nlp;
			register char *obp;

vanilla:
			obp = obuf;
			(void) snprintf(obp, SPACELEFT(obuf, obp), "%.200s: ",
				h->h_field);
			obp = obuf + strlen(obuf);
			while ((nlp = strchr(p, '\n')) != NULL)
			{

				*nlp = '\0';
				snprintf(obp, SPACELEFT(obuf, obp), "%.*s",
					sizeof obuf - (obp - obuf) - 1, p);
				*nlp = '\n';
				putline(obuf, mci);
				p = ++nlp;
				obp = obuf;
				if (*p != ' ' && *p != '\t')
					*obp++ = ' ';
			}
			snprintf(obp, SPACELEFT(obuf, obp), "%.*s",
				sizeof obuf - (obp - obuf) - 1, p);
			putline(obuf, mci);
d1234 1
a1234 1
	    !bitset(MCIF_CVT8TO7, mci->mci_flags))
d1251 49
d1328 1
d1339 5
d1440 1
a1440 1
			putline(obuf, mci);
d1459 1
a1459 1
	putline(obuf, mci);
@


1.3
log
@sendmail 8.7.4
@
text
@d36 1
a36 1
static char sccsid[] = "@@(#)headers.c	8.82.1.1 (Berkeley) 2/18/96";
d681 1
a681 1
		(void) sprintf(hbuf, "%.80s", RealHostName);
d685 1
a685 1
			(void) sprintf(p, " (%.100s)",
d693 2
a694 1
	sprintf(sbp, "from=%.200s, size=%ld, class=%d, pri=%ld, nrcpts=%d",
d700 1
a700 1
		sprintf(sbp, ", msgid=%.100s", mbuf);
d705 2
a706 1
		(void) sprintf(sbp, ", bodytype=%.20s", e->e_bodytype);
d711 1
a711 1
		(void) sprintf(sbp, ", proto=%.20s", p);
d727 1
a727 1
	sprintf(sbp, "%s:", e->e_id);
d731 1
a731 1
		sprintf(sbp, " bodytype=%.20s,", e->e_bodytype);
d737 1
a737 1
		sprintf(sbp, " proto=%.20s,", p);
d1221 2
a1222 1
				(void) sprintf(obuf, "%s:", h->h_field);
d1247 3
a1249 1
			(void) sprintf(obuf, "%.200s: ", h->h_field);
d1255 1
a1255 1
				sprintf(obp, "%.*s",
d1264 2
a1265 1
			sprintf(obp, "%.*s", sizeof obuf - (obp - obuf) - 1, p);
d1286 2
a1287 1
			sprintf(obuf, "Content-Type: text/plain; charset=%s",
d1336 1
a1336 1
	(void) sprintf(obp, "%.200s: ", h->h_field);
d1430 1
a1430 1
			(void) strcpy(obp, ",\n");
d1440 1
a1440 1
			(void) strcpy(obp, ", ");
@


1.2
log
@Sendmail 8.7.3 from NetBSD
@
text
@d36 1
a36 1
static char sccsid[] = "@@(#)headers.c	8.82 (Berkeley) 10/28/95";
d1256 2
d1442 1
a1442 1
	(void) strcpy(obp, "\n");
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
 * Copyright (c) 1983 Eric P. Allman
d36 1
a36 1
static char sccsid[] = "@@(#)headers.c	8.32 (Berkeley) 4/14/94";
d50 1
d61 2
a62 1
chompheader(line, def, e)
d65 1
d75 1
d77 1
a77 1
	char buf[MAXNAME];
d80 9
a88 1
		printf("chompheader: %s\n", line);
d106 1
a106 1
			usrerr("553 header syntax error, line \"%s\"", line);
d129 4
d145 1
a145 1
			printf("header match, hi_flags=%o\n", hi->hi_flags);
d149 1
a149 1
	if (!def && bitset(H_RESENT, hi->hi_flags))
d152 5
d161 16
d186 2
a187 1
	if (!def && !bitset(EF_QUEUERUN, e->e_flags) && strcasecmp(fname, p) == 0)
d199 1
a199 1
#ifdef USERDB
d224 1
a224 1
			    a.q_mailer == LocalMailer &&
d230 1
a230 1
				expand(fancy, buf, &buf[sizeof buf], e);
d241 1
a241 1
	for (hp = &e->e_header; (h = *hp) != NULL; hp = &h->h_link)
d246 1
d248 7
d271 1
a271 1
	if (!def && bitset(H_RCPT|H_FROM, h->h_flags) &&
d288 1
a288 1
**		e -- the envelope to add them to.
d297 2
a298 1
addheader(field, value, e)
d301 1
a301 1
	ENVELOPE *e;
d315 1
a315 1
	for (hp = &e->e_header; (h = *hp) != NULL; hp = &h->h_link)
d338 1
a338 1
**		e -- the envelope containing the header.
d349 1
a349 1
hvalue(field, e)
d351 1
a351 1
	register ENVELOPE *e;
d355 1
a355 1
	for (h = e->e_header; h != NULL; h = h->h_link)
d369 6
d376 1
a376 1
**		s -- string to check for possible headerness.
d379 1
a379 1
**		TRUE if s is a header.
d387 2
a388 2
isheader(s)
	register char *s;
d390 5
d398 3
d413 3
a415 1
**			message priority).
d426 1
d449 1
a449 1
	p = hvalue("full-name", e);
d455 1
a455 1
	msgid = "<none>";
d458 2
d463 1
a463 1
				printf("%s: <NULL>\n", h->h_field);
d470 7
a476 1
			expand(h->h_value, buf, &buf[sizeof buf], e);
d479 6
a491 1
			printf("%s: ", h->h_field);
d508 1
a508 1
					  &e->e_sendqueue, e);
d516 4
a519 1
		if (full && strcasecmp(h->h_field, "message-id") == 0)
a528 5

		/* see if this is an errors-to header */
		if (UseErrorsTo && bitset(H_ERRORSTO, h->h_flags))
			(void) sendtolist(h->h_value, NULLADDR,
					  &e->e_errorqueue, e);
d542 1
a542 1
	p = hvalue("precedence", e);
d545 4
d550 1
d554 14
d570 1
a570 1
	p = hvalue("posted-date", e);
d572 1
a572 1
		p = hvalue("date", e);
d576 20
d610 1
a610 1
			    (p = hvalue(hi->hi_field, e)) != NULL)
d627 1
a627 1
	if (full && LogLevel > 4)
d643 1
d652 17
a668 2
	char hbuf[MAXNAME];
	char sbuf[MAXLINE];
d685 1
a685 1
			(void) sprintf(p, " (%s)",
d694 2
a695 2
	    e->e_from.q_paddr, e->e_msgsize, e->e_class,
	    e->e_msgpriority, e->e_nrcpts);
d699 1
a699 1
		sprintf(sbp, ", msgid=%.100s", msgid);
d710 1
a710 1
	syslog(LOG_INFO, "%s: %s, relay=%s",
d716 2
a717 1
		e->e_id, shortenstring(e->e_from.q_paddr, 83));
d722 2
a723 1
		syslog(LOG_INFO, "%s: msgid=%s", e->e_id, msgid);
d729 1
a729 1
		sprintf(sbp, " bodytype=%s,", e->e_bodytype);
d735 1
a735 1
		sprintf(sbp, " proto=%s,", p);
d738 1
a738 1
	syslog(LOG_INFO, "%s relay=%s", sbuf, name);
d755 1
d814 1
d817 3
a819 1
	static char buf[MAXNAME];
d833 1
a833 1
	bp = buf;
d835 1
a835 1
	p = addr;
d919 72
d992 1
a992 1
		if (strchr(".'@@,;:\\()[]", c) != NULL)
d1020 1
a1020 1
			bp = buf;
d1031 1
a1031 1
			for (q = addr; q < p; )
d1112 1
d1129 2
a1130 1
putheader(mci, e)
d1132 1
a1135 1
	register HDR *h;
d1142 2
a1143 1
	for (h = e->e_header; h != NULL; h = h->h_link)
d1145 1
a1145 1
		register char *p;
d1151 17
a1167 1
			xputs(h->h_value);
a1195 1
		p = h->h_value;
d1198 1
a1198 1
			expand(p, buf, &buf[sizeof buf], e);
d1208 17
d1241 1
d1243 3
a1245 1
			(void) sprintf(obuf, "%s: ", h->h_field);
d1248 1
d1250 2
a1251 1
				(void) strcat(obuf, p);
d1255 1
a1255 1
				obuf[0] = '\0';
d1257 1
a1257 1
			(void) strcat(obuf, p);
d1261 25
d1327 1
a1327 1
	(void) sprintf(obp, "%s: ", h->h_field);
d1364 1
a1364 1
				       sizeof pvpbuf, &oldp);
d1395 12
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@


1.1.1.2
log
@sendmail 8.9.1
@
text
@d2 1
a2 2
 * Copyright (c) 1998 Sendmail, Inc.  All rights reserved.
 * Copyright (c) 1983, 1995-1997 Eric P. Allman.  All rights reserved.
d6 15
a20 3
 * By using this file, you agree to the terms and conditions set
 * forth in the LICENSE file which can be found at the top level of
 * the sendmail distribution.
d22 11
d36 1
a36 1
static char sccsid[] = "@@(#)headers.c	8.127 (Berkeley) 6/4/98";
a42 23
**  SETUPHEADERS -- initialize headers in symbol table
**
**	Parameters:
**		none
**
**	Returns:
**		none
*/

void
setupheaders()
{
	struct hdrinfo *hi;
	STAB *s;

	for (hi = HdrInfo; hi->hi_field != NULL; hi++)
	{
		s = stab(hi->hi_field, ST_HEADER, ST_ENTER);
		s->s_header.hi_flags = hi->hi_flags;
		s->s_header.hi_ruleset = NULL;
	}
}
/*
a49 1
**		hdrp -- a pointer to the place to save the header.
d60 1
a60 4
struct hdrinfo	NormalHeader =	{ NULL, 0, NULL };

int
chompheader(line, def, hdrp, e)
a62 1
	HDR **hdrp;
d70 1
a71 3
	bool headeronly;
	STAB *s;
	struct hdrinfo *hi;
d73 1
d76 1
a76 9
	{
		printf("chompheader: ");
		xputs(line);
		printf("\n");
	}

	headeronly = hdrp != NULL;
	if (!headeronly)
		hdrp = &e->e_header;
d94 1
a94 1
			syserr("553 header syntax error, line \"%s\"", line);
d108 1
a108 1
		return 0;
d117 2
a118 6
	/* security scan: long field names are end-of-header */
	if (strlen(fname) > 100)
		return H_EOH;

	/* check to see if it represents a ruleset call */
	if (def)
d120 2
a121 17
		char hbuf[50];

		(void) expand(fvalue, hbuf, sizeof hbuf, e);
		for (p = hbuf; isascii(*p) && isspace(*p); )
			p++;
		if ((*p++ & 0377) == CALLSUBR)
		{
			auto char *endp;

			if (strtorwset(p, &endp, ST_ENTER) > 0)
			{
				*endp = '\0';
				s = stab(fname, ST_HEADER, ST_ENTER);
				s->s_header.hi_ruleset = newstr(p);
			}
			return 0;
		}
a123 7
	/* see if it is a known type */
	s = stab(fname, ST_HEADER, ST_FIND);
	if (s != NULL)
		hi = &s->s_header;
	else
		hi = &NormalHeader;

d126 2
a127 2
		if (s == NULL)
			printf("no header flags match\n");
d129 1
a129 3
			printf("header match, flags=%x, ruleset=%s\n", 
				hi->hi_flags,
				hi->hi_ruleset == NULL ? "<NULL>" : hi->hi_ruleset);
d133 1
a133 1
	if (!def && !headeronly && bitset(H_RESENT, hi->hi_flags))
a135 5
	/* if this is an Errors-To: header keep track of it now */
	if (UseErrorsTo && !def && !headeronly &&
	    bitset(H_ERRORSTO, hi->hi_flags))
		(void) sendtolist(fvalue, NULLADDR, &e->e_errorqueue, 0, e);

d137 2
a138 23
	if (!headeronly && bitset(H_EOH, hi->hi_flags))
		return hi->hi_flags;

	/*
	**  Horrible hack to work around problem with Lotus Notes SMTP
	**  mail gateway, which generates From: headers with newlines in
	**  them and the <address> on the second line.  Although this is
	**  legal RFC 822, many MUAs don't handle this properly and thus
	**  never find the actual address.
	*/

	if (bitset(H_FROM, hi->hi_flags) && SingleLineFromHeader)
	{
		while ((p = strchr(fvalue, '\n')) != NULL)
			*p = ' ';
	}

	/*
	**  If there is a check ruleset, verify it against the header.
	*/

	if (!def && hi->hi_ruleset != NULL)
		(void) rscheck(hi->hi_ruleset, fvalue, NULL, e);
d149 1
a149 2
	if (!def && !headeronly && !bitset(EF_QUEUERUN, e->e_flags) &&
	    strcasecmp(fname, p) == 0)
d159 41
a199 1
			return hi->hi_flags;
d203 1
a203 1
	for (hp = hdrp; (h = *hp) != NULL; hp = &h->h_link)
a207 1
		{
a208 7
			if (!cond)
			{
				/* copy conditions from default case */
				bcopy((char *)h->h_mflags, (char *)mopts,
						sizeof mopts);
			}
		}
a218 4

	/* strip EOH flag if parsing MIME headers */
	if (headeronly)
		h->h_flags &= ~H_EOH;
d225 1
a225 1
	if (!def && !headeronly && bitset(H_RCPT|H_FROM, h->h_flags) &&
d232 1
a232 1
	return h->h_flags;
d242 1
a242 1
**		hp -- an indirect pointer to the header structure list.
d251 1
a251 2
void
addheader(field, value, hdrlist)
d254 1
a254 1
	HDR **hdrlist;
d257 1
a257 1
	STAB *s;
d261 5
a265 1
	s = stab(field, ST_HEADER, ST_FIND);
d268 1
a268 1
	for (hp = hdrlist; (h = *hp) != NULL; hp = &h->h_link)
d279 1
a279 3
	h->h_flags = H_DEFAULT;
	if (s != NULL)
		h->h_flags |= s->s_header.hi_flags;
d291 1
a291 1
**		header -- the header list.
d302 1
a302 1
hvalue(field, header)
d304 1
a304 1
	HDR *header;
d308 1
a308 1
	for (h = header; h != NULL; h = h->h_link)
a321 6
**	Header fields beginning with two dashes, although technically
**	permitted by RFC822, are automatically rejected in order
**	to make MIME work out.  Without this we could have a technically
**	legal header such as ``--"foo:bar"'' that would also be a legal
**	MIME separator.
**
d323 1
a323 1
**		h -- string to check for possible headerness.
d326 1
a326 1
**		TRUE if h is a header.
d334 2
a335 2
isheader(h)
	char *h;
a336 5
	register char *s = h;

	if (s[0] == '-' && s[1] == '-')
		return FALSE;

a339 3
	if (h == s)
		return FALSE;

d352 1
a352 3
**			message priority).  This should not be set
**			when reading a queue file because some info
**			needed to compute the priority is wrong.
a362 1
void
a371 1
	extern int priencode __P((char *));
d385 1
a385 1
	p = hvalue("full-name", e->e_header);
a386 14
	{
		extern bool rfc822_string __P((char *));

		if (!rfc822_string(p))
		{
			extern char *addquotes __P((char *));

			/*
			**  Quote a full name with special characters
			**  as a comment so crackaddr() doesn't destroy
			**  the name portion of the address.
			*/
			p = addquotes(p);
		}
a387 1
	}
d391 1
a391 1
	msgid = NULL;
a393 2
		if (tTd(32, 1))
			printf("%s: ", h->h_field);
d397 1
a397 1
				printf("<NULL>\n");
d404 1
a404 7
			if (tTd(32, 1))
			{
				printf("(");
				xputs(h->h_value);
				printf(") ");
			}
			expand(h->h_value, buf, sizeof buf, e);
a406 6
				if (bitset(H_FROM, h->h_flags))
				{
					extern char *crackaddr __P((char *));

					expand(crackaddr(buf), buf, sizeof buf, e);
				}
d414 1
a427 1
#if 0
a428 1
#endif
d431 1
a431 1
					  &e->e_sendqueue, 0, e);
a432 6
#if 0
			/*
			** Change functionality so a fatal error on an
			** address doesn't affect the entire envelope.
			*/
			 
d434 1
a434 1
			if (!bitset(EF_FATALERRS, saveflags))
a435 1
#endif
d439 1
a439 4
		p = "resent-message-id";
		if (!bitset(EF_RESENT, e->e_flags))
			p += 7;
		if (strcasecmp(h->h_field, p) == 0)
d445 9
d467 1
a467 1
	p = hvalue("precedence", e->e_header);
a469 4
	if (e->e_class < 0)
		e->e_timeoutclass = TOC_NONURGENT;
	else if (e->e_class > 0)
		e->e_timeoutclass = TOC_URGENT;
a470 1
	{
a473 14
	}

	/* message timeout priority */
	p = hvalue("priority", e->e_header);
	if (p != NULL)
	{
		/* (this should be in the configuration file) */
		if (strcasecmp(p, "urgent") == 0)
			e->e_timeoutclass = TOC_URGENT;
		else if (strcasecmp(p, "normal") == 0)
			e->e_timeoutclass = TOC_NORMAL;
		else if (strcasecmp(p, "non-urgent") == 0)
			e->e_timeoutclass = TOC_NONURGENT;
	}
d476 1
a476 1
	p = hvalue("posted-date", e->e_header);
d478 1
a478 1
		p = hvalue("date", e->e_header);
a481 20
	/* check to see if this is a MIME message */
	if ((e->e_bodytype != NULL &&
	     strcasecmp(e->e_bodytype, "8BITMIME") == 0) ||
	    hvalue("MIME-Version", e->e_header) != NULL)
	{
		e->e_flags |= EF_IS_MIME;
		if (HasEightBits)
			e->e_bodytype = "8BITMIME";
	}
	else if ((p = hvalue("Content-Type", e->e_header)) != NULL)
	{
		/* this may be an RFC 1049 message */
		p = strpbrk(p, ";/");
		if (p == NULL || *p == ';')
		{
			/* yep, it is */
			e->e_flags |= EF_DONT_MIME;
		}
	}

d496 1
a496 1
			    (p = hvalue(hi->hi_field, e->e_header)) != NULL)
d504 1
a504 1
			setsender(p, e, NULL, '\0', TRUE);
d512 2
a513 1
	if (bitset(EF_LOGSENDER, e->e_flags) && LogLevel > 4)
d515 1
a528 1
void
d533 1
d537 2
a538 17
	int l;
	char hbuf[MAXNAME + 1];
	char sbuf[MAXLINE + 1];
	char mbuf[MAXNAME + 1];

	/* don't allow newlines in the message-id */
	if (msgid != NULL)
	{
		l = strlen(msgid);
		if (l > sizeof mbuf - 1)
			l = sizeof mbuf - 1;
		bcopy(msgid, mbuf, l);
		mbuf[l] = '\0';
		p = mbuf;
		while ((p = strchr(p, '\n')) != NULL)
			*p++ = ' ';
	}
d551 1
a551 1
		(void) snprintf(hbuf, sizeof hbuf, "%.80s", RealHostName);
d555 1
a555 1
			(void) snprintf(p, SPACELEFT(hbuf, p), " (%.100s)",
d563 3
a565 4
	snprintf(sbp, SPACELEFT(sbuf, sbp),
	    "from=%.200s, size=%ld, class=%d, pri=%ld, nrcpts=%d",
	    e->e_from.q_paddr == NULL ? "<NONE>" : e->e_from.q_paddr,
	    e->e_msgsize, e->e_class, e->e_msgpriority, e->e_nrcpts);
d569 1
a569 1
		snprintf(sbp, SPACELEFT(sbuf, sbp), ", msgid=%.100s", mbuf);
d574 1
a574 2
		(void) snprintf(sbp, SPACELEFT(sbuf, sbp), ", bodytype=%.20s",
			e->e_bodytype);
d579 3
a581 4
		(void) snprintf(sbp, SPACELEFT(sbuf, sbp), ", proto=%.20s", p);
	sm_syslog(LOG_INFO, e->e_id,
		"%.850s, relay=%.100s",
		sbuf, name);
d585 5
a589 7
	sm_syslog(LOG_INFO, e->e_id,
		"from=%s",
		e->e_from.q_paddr == NULL ? "<NONE>"
					  : shortenstring(e->e_from.q_paddr, 83));
	sm_syslog(LOG_INFO, e->e_id,
		"size=%ld, class=%ld, pri=%ld, nrcpts=%d",
		e->e_msgsize, e->e_class, e->e_msgpriority, e->e_nrcpts);
d591 1
a591 3
		sm_syslog(LOG_INFO, e->e_id,
			"msgid=%s",
			shortenstring(mbuf, 83));
d593 2
a594 1
	*sbp = '\0';
d597 1
a597 1
		snprintf(sbp, SPACELEFT(sbuf, sbp), "bodytype=%.20s, ", e->e_bodytype);
d603 1
a603 1
		snprintf(sbp, SPACELEFT(sbuf, sbp), "proto=%.20s, ", p);
d606 1
a606 2
	sm_syslog(LOG_INFO, e->e_id,
		"%.400srelay=%.100s", sbuf, name);
d608 1
a622 1
int
a674 1
	int bracklev;
a680 1
	bool gotcolon = FALSE;
d683 1
a683 3
	char *bufhead;
	char *addrhead;
	static char buf[MAXNAME + 1];
d697 3
a699 3
	bp = bufhead = buf;
	buflim = &buf[sizeof buf - 7];
	p = addrhead = addr;
a700 1
	bracklev = 0;
d757 1
a757 2
					if (bp != bufhead)
						*bp++ = ' ';
a782 85
		/* count nesting on [ ... ] (for IPv6 domain literals) */
		if (c == '[')
			bracklev++;
		else if (c == ']')
			bracklev--;

		/* check for group: list; syntax */
		if (c == ':' && anglelev <= 0 && bracklev <= 0 &&
		    !gotcolon && !ColonOkInAddr)
		{
			register char *q;

			/*
			**  Check for DECnet phase IV ``::'' (host::user)
			**  or **  DECnet phase V ``:.'' syntaxes.  The latter
			**  covers ``user@@DEC:.tay.myhost'' and
			**  ``DEC:.tay.myhost::user'' syntaxes (bletch).
			*/

			if (*p == ':' || *p == '.')
			{
				if (cmtlev <= 0 && !qmode)
					quoteit = TRUE;
				if (copylev > 0 && !skipping)
				{
					*bp++ = c;
					*bp++ = *p;
				}
				p++;
				goto putg;
			}

			gotcolon = TRUE;

			bp = bufhead;
			if (quoteit)
			{
				*bp++ = '"';

				/* back up over the ':' and any spaces */
				--p;
				while (isascii(*--p) && isspace(*p))
					continue;
				p++;
			}
			for (q = addrhead; q < p; )
			{
				c = *q++;
				if (bp < buflim)
				{
					if (quoteit && c == '"')
						*bp++ = '\\';
					*bp++ = c;
				}
			}
			if (quoteit)
			{
				if (bp == &bufhead[1])
					bp--;
				else
					*bp++ = '"';
				while ((c = *p++) != ':')
				{
					if (bp < buflim)
						*bp++ = c;
				}
				*bp++ = c;
			}

			/* any trailing white space is part of group: */
			while (isascii(*p) && isspace(*p) && bp < buflim)
				*bp++ = *p++;
			copylev = 0;
			putgmac = quoteit = FALSE;
			bufhead = bp;
			addrhead = p;
			continue;
		}

		if (c == ';' && copylev <= 0 && !ColonOkInAddr)
		{
			if (bp < buflim)
				*bp++ = c;
		}

d784 1
a784 1
		if (strchr(MustQuoteChars, c) != NULL)
d812 1
a812 1
			bp = bufhead;
d823 1
a823 1
			for (q = addrhead; q < p; )
a878 2
			if (bp > bufhead && bp[-1] == ')')
				*bp++ = ' ';
d895 1
a895 5
	{
		printf("crackaddr=>`");
		xputs(buf);
		printf("'\n");
	}
a903 1
**		h -- the header to put.
d920 1
a920 2
void
putheader(mci, hdr, e)
a921 1
	HDR *hdr;
d924 1
a925 1
	char buf[MAX(MAXLINE,BUFSIZ)];
d932 1
a932 10
	/*
	**  If we're in MIME mode, we're not really in the header of the
	**  message, just the header of one of the parts of the body of
	**  the message.  Therefore MCIF_INHEADER should not be turned on.
	*/

	if (!bitset(MCIF_INMIME, mci->mci_flags))
		mci->mci_flags |= MCIF_INHEADER;

	for (h = hdr; h != NULL; h = h->h_link)
d934 2
a935 2
		register char *p = h->h_value;
		extern bool bitintersect __P((BITMAP, BITMAP));
d940 1
a940 18
			xputs(p);
		}

		/* suppress Content-Transfer-Encoding: if we are MIMEing */
		if (bitset(H_CTE, h->h_flags) &&
		    bitset(MCIF_CVT8TO7|MCIF_CVT7TO8|MCIF_INMIME, mci->mci_flags))
		{
			if (tTd(34, 11))
				printf(" (skipped (content-transfer-encoding))\n");
			continue;
		}

		if (bitset(MCIF_INMIME, mci->mci_flags))
		{
			if (tTd(34, 11))
				printf("\n");
			put_vanilla_header(h, p, mci);
			continue;
a960 3
#if _FFR_DSN_RRT_OPTION
		    (RrtImpliesDsn || bitset(EF_NORECEIPT, e->e_flags)))
#else
a961 1
#endif
d969 1
d972 1
a972 1
			expand(p, buf, sizeof buf, e);
d974 1
a974 1
			if (*p == '\0')
a981 18
		if (bitset(H_BCC, h->h_flags))
		{
			/* Bcc: field -- either truncate or delete */
			if (bitset(EF_DELETE_BCC, e->e_flags))
			{
				if (tTd(34, 11))
					printf(" (skipped -- bcc)\n");
			}
			else
			{
				/* no other recipient headers: truncate value */
				(void) snprintf(obuf, sizeof obuf, "%s:",
					h->h_field);
				putline(obuf, mci);
			}
			continue;
		}

d996 2
a997 3
			put_vanilla_header(h, p, mci);
		}
	}
d999 11
a1009 19
	/*
	**  If we are converting this to a MIME message, add the
	**  MIME headers.
	*/

#if MIME8TO7
	if (bitset(MM_MIME8BIT, MimeMode) &&
	    bitset(EF_HAS8BIT, e->e_flags) &&
	    !bitset(EF_DONT_MIME, e->e_flags) &&
	    !bitnset(M_8BITS, mci->mci_mailer->m_flags) &&
	    !bitset(MCIF_CVT8TO7|MCIF_CVT7TO8, mci->mci_flags))
	{
		if (hvalue("MIME-Version", e->e_header) == NULL)
			putline("MIME-Version: 1.0", mci);
		if (hvalue("Content-Type", e->e_header) == NULL)
		{
			snprintf(obuf, sizeof obuf,
				"Content-Type: text/plain; charset=%s",
				defcharset(e));
a1011 2
		if (hvalue("Content-Transfer-Encoding", e->e_header) == NULL)
			putline("Content-Transfer-Encoding: 8bit", mci);
a1012 50
#endif
}
/*
**  PUT_VANILLA_HEADER -- output a fairly ordinary header
**
**	Parameters:
**		h -- the structure describing this header
**		v -- the value of this header
**		mci -- the connection info for output
**
**	Returns:
**		none.
*/

void
put_vanilla_header(h, v, mci)
	HDR *h;
	char *v;
	MCI *mci;
{
	register char *nlp;
	register char *obp;
	int putflags;
	char obuf[MAXLINE];

	putflags = PXLF_HEADER;
#if _FFR_7BITHDRS
	if (bitnset(M_7BITHDRS, mci->mci_mailer->m_flags))
		putflags |= PXLF_STRIP8BIT;
#endif
	(void) snprintf(obuf, sizeof obuf, "%.200s: ", h->h_field);
	obp = obuf + strlen(obuf);
	while ((nlp = strchr(v, '\n')) != NULL)
	{
		int l;

		l = nlp - v;
		if (SPACELEFT(obuf, obp) - 1 < l)
			l = SPACELEFT(obuf, obp) - 1;

		snprintf(obp, SPACELEFT(obuf, obp), "%.*s", l, v);
		putxline(obuf, strlen(obuf), mci, putflags);
		v += l + 1;
		obp = obuf;
		if (*v != ' ' && *v != '\t')
			*obp++ = ' ';
	}
	snprintf(obp, SPACELEFT(obuf, obp), "%.*s",
		sizeof obuf - (obp - obuf) - 1, v);
	putxline(obuf, strlen(obuf), mci, putflags);
a1042 1
	int putflags = PXLF_HEADER;
a1052 5
#if _FFR_7BITHDRS
	if (bitnset(M_7BITHDRS, mci->mci_mailer->m_flags))
		putflags |= PXLF_STRIP8BIT;
#endif

d1054 1
a1054 1
	(void) snprintf(obp, SPACELEFT(obuf, obp), "%.200s: ", h->h_field);
a1055 2
	if (opos > 202)
		opos = 202;
d1091 1
a1091 1
				       sizeof pvpbuf, &oldp, NULL);
a1121 12
#if USERDB
		else if (e->e_from.q_mailer != NULL &&
			 bitnset(M_UDBRECIPIENT, e->e_from.q_mailer->m_flags))
		{
			extern char *udbsender __P((char *));
			char *q;

			q = udbsender(name);
			if (q != NULL)
				name = q;
		}
#endif
a1128 1
		name = denlstring(name, FALSE, TRUE);
d1136 2
a1137 2
			snprintf(obp, SPACELEFT(obuf, obp), ",\n");
			putxline(obuf, strlen(obuf), mci, putflags);
d1146 1
a1146 1
			snprintf(obp, SPACELEFT(obuf, obp), ", ");
d1155 2
a1156 2
	*obp = '\0';
	putxline(obuf, strlen(obuf), mci, putflags);
@

