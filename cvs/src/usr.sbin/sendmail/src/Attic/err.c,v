head	1.10;
access;
symbols
	OPENBSD_2_6:1.9.0.4
	OPENBSD_2_6_BASE:1.9
	OPENBSD_2_5:1.9.0.2
	OPENBSD_2_5_BASE:1.9
	OPENBSD_2_4:1.8.0.2
	OPENBSD_2_4_BASE:1.8
	sendmail_8_9_1:1.1.1.2
	UCB:1.1.1
	OPENBSD_2_3:1.7.0.2
	OPENBSD_2_3_BASE:1.7
	OPENBSD_2_2:1.6.0.2
	OPENBSD_2_2_BASE:1.6
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.10
date	2000.04.18.04.57.20;	author millert;	state dead;
branches;
next	1.9;

1.9
date	99.01.01.20.33.47;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	98.07.12.19.44.39;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	97.11.09.04.05.39;	author gene;	state Exp;
branches;
next	1.6;

1.6
date	97.08.04.02.17.52;	author downsj;	state Exp;
branches;
next	1.5;

1.5
date	97.07.15.07.24.05;	author downsj;	state Exp;
branches;
next	1.4;

1.4
date	96.12.14.21.17.18;	author downsj;	state Exp;
branches;
next	1.3;

1.3
date	96.09.19.06.44.57;	author fn;	state Exp;
branches;
next	1.2;

1.2
date	96.01.29.01.43.53;	author dm;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.48.18;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.48.18;	author deraadt;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	98.07.12.17.10.07;	author millert;	state Exp;
branches;
next	;


desc
@@


1.10
log
@remove sendmail 8.9.3
@
text
@/*
 * Copyright (c) 1998 Sendmail, Inc.  All rights reserved.
 * Copyright (c) 1983, 1995-1997 Eric P. Allman.  All rights reserved.
 * Copyright (c) 1988, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * By using this file, you agree to the terms and conditions set
 * forth in the LICENSE file which can be found at the top level of
 * the sendmail distribution.
 *
 */

#ifndef lint
static char sccsid[] = "@@(#)err.c	8.74 (Berkeley) 6/4/1998";
#endif /* not lint */

# include "sendmail.h"
# include <errno.h>

/*
**  SYSERR -- Print error message.
**
**	Prints an error message via printf to the diagnostic output.
**
**	If the first character of the syserr message is `!' it will
**	log this as an ALERT message and exit immediately.  This can
**	leave queue files in an indeterminate state, so it should not
**	be used lightly.
**
**	Parameters:
**		fmt -- the format string.  If it does not begin with
**			a three-digit SMTP reply code, either 554 or
**			451 is assumed depending on whether errno
**			is set.
**		(others) -- parameters
**
**	Returns:
**		none
**		Through TopFrame if QuickAbort is set.
**
**	Side Effects:
**		increments Errors.
**		sets ExitStat.
*/

char	MsgBuf[BUFSIZ*2];		/* text of most recent message */
char	HeldMessageBuf[sizeof MsgBuf];	/* for held messages */

extern void	putoutmsg __P((char *, bool, bool));
extern void	puterrmsg __P((char *));
static void	fmtmsg __P((char *, const char *, const char *, int, const char *, va_list));

#if NAMED_BIND && !defined(NO_DATA)
# define NO_DATA	NO_ADDRESS
#endif

void
/*VARARGS1*/
#ifdef __STDC__
syserr(const char *fmt, ...)
#else
syserr(fmt, va_alist)
	const char *fmt;
	va_dcl
#endif
{
	register char *p;
	int olderrno = errno;
	bool panic;
	char *uname;
	struct passwd *pw;
	char ubuf[80];
	VA_LOCAL_DECL

	panic = *fmt == '!';
	if (panic)
	{
		fmt++;
		HoldErrs = FALSE;
	}

	/* format and output the error message */
	if (olderrno == 0)
		p = "554";
	else
		p = "451";
	VA_START(fmt);
	fmtmsg(MsgBuf, (char *) NULL, p, olderrno, fmt, ap);
	VA_END;
	puterrmsg(MsgBuf);

	/* save this message for mailq printing */
	if (!panic && CurEnv != NULL)
	{
		if (CurEnv->e_message != NULL)
			free(CurEnv->e_message);
		CurEnv->e_message = newstr(MsgBuf + 4);
	}

	/* determine exit status if not already set */
	if (ExitStat == EX_OK)
	{
		if (olderrno == 0)
			ExitStat = EX_SOFTWARE;
		else
			ExitStat = EX_OSERR;
		if (tTd(54, 1))
			printf("syserr: ExitStat = %d\n", ExitStat);
	}

	pw = sm_getpwuid(getuid());
	if (pw != NULL)
		uname = pw->pw_name;
	else
	{
		uname = ubuf;
		snprintf(ubuf, sizeof ubuf, "UID%d", getuid());
	}

	if (LogLevel > 0)
		sm_syslog(panic ? LOG_ALERT : LOG_CRIT,
			  CurEnv == NULL ? NOQID : CurEnv->e_id,
			  "SYSERR(%s): %.900s",
			  uname, &MsgBuf[4]);
	switch (olderrno)
	{
	  case EBADF:
	  case ENFILE:
	  case EMFILE:
	  case ENOTTY:
#ifdef EFBIG
	  case EFBIG:
#endif
#ifdef ESPIPE
	  case ESPIPE:
#endif
#ifdef EPIPE
	  case EPIPE:
#endif
#ifdef ENOBUFS
	  case ENOBUFS:
#endif
#ifdef ESTALE
	  case ESTALE:
#endif
		printopenfds(TRUE);
		mci_dump_all(TRUE);
		break;
	}
	if (panic)
	{
#ifdef XLA
		xla_all_end();
#endif
		if (tTd(0, 1))
			abort();
		exit(EX_OSERR);
	}
	errno = 0;
	if (QuickAbort)
		longjmp(TopFrame, 2);
}
/*
**  USRERR -- Signal user error.
**
**	This is much like syserr except it is for user errors.
**
**	Parameters:
**		fmt -- the format string.  If it does not begin with
**			a three-digit SMTP reply code, 501 is assumed.
**		(others) -- printf strings
**
**	Returns:
**		none
**		Through TopFrame if QuickAbort is set.
**
**	Side Effects:
**		increments Errors.
*/

/*VARARGS1*/
void
#ifdef __STDC__
usrerr(const char *fmt, ...)
#else
usrerr(fmt, va_alist)
	const char *fmt;
	va_dcl
#endif
{
	VA_LOCAL_DECL

	if (SuprErrs)
		return;

	VA_START(fmt);
	fmtmsg(MsgBuf, CurEnv->e_to, "501", 0, fmt, ap);
	VA_END;

	/* save this message for mailq printing */
	switch (MsgBuf[0])
	{
	  case '4':
	  case '8':
		if (CurEnv->e_message != NULL)
			break;

		/* fall through.... */

	  case '5':
	  case '6':
		if (CurEnv->e_message != NULL)
			free(CurEnv->e_message);
		if (MsgBuf[0] == '6')
		{
			char buf[MAXLINE];

			snprintf(buf, sizeof buf, "Postmaster warning: %.*s",
				sizeof buf - 22, MsgBuf + 4);
			CurEnv->e_message = newstr(buf);
		}
		else
		{
			CurEnv->e_message = newstr(MsgBuf + 4);
		}
		break;
	}

	puterrmsg(MsgBuf);

	if (LogLevel > 3 && LogUsrErrs)
		sm_syslog(LOG_NOTICE, CurEnv->e_id,
			"%.900s",
			&MsgBuf[4]);

	if (QuickAbort)
		longjmp(TopFrame, 1);
}
/*
**  MESSAGE -- print message (not necessarily an error)
**
**	Parameters:
**		msg -- the message (printf fmt) -- it can begin with
**			an SMTP reply code.  If not, 050 is assumed.
**		(others) -- printf arguments
**
**	Returns:
**		none
**
**	Side Effects:
**		none.
*/

/*VARARGS1*/
void
#ifdef __STDC__
message(const char *msg, ...)
#else
message(msg, va_alist)
	const char *msg;
	va_dcl
#endif
{
	VA_LOCAL_DECL

	errno = 0;
	VA_START(msg);
	fmtmsg(MsgBuf, CurEnv->e_to, "050", 0, msg, ap);
	VA_END;
	putoutmsg(MsgBuf, FALSE, FALSE);

	/* save this message for mailq printing */
	switch (MsgBuf[0])
	{
	  case '4':
	  case '8':
		if (CurEnv->e_message != NULL)
			break;
		/* fall through.... */

	  case '5':
		if (CurEnv->e_message != NULL)
			free(CurEnv->e_message);
		CurEnv->e_message = newstr(MsgBuf + 4);
		break;
	}
}
/*
**  NMESSAGE -- print message (not necessarily an error)
**
**	Just like "message" except it never puts the to... tag on.
**
**	Parameters:
**		msg -- the message (printf fmt) -- if it begins
**			with a three digit SMTP reply code, that is used,
**			otherwise 050 is assumed.
**		(others) -- printf arguments
**
**	Returns:
**		none
**
**	Side Effects:
**		none.
*/

/*VARARGS1*/
void
#ifdef __STDC__
nmessage(const char *msg, ...)
#else
nmessage(msg, va_alist)
	const char *msg;
	va_dcl
#endif
{
	VA_LOCAL_DECL

	errno = 0;
	VA_START(msg);
	fmtmsg(MsgBuf, (char *) NULL, "050", 0, msg, ap);
	VA_END;
	putoutmsg(MsgBuf, FALSE, FALSE);

	/* save this message for mailq printing */
	switch (MsgBuf[0])
	{
	  case '4':
	  case '8':
		if (CurEnv->e_message != NULL)
			break;
		/* fall through.... */

	  case '5':
		if (CurEnv->e_message != NULL)
			free(CurEnv->e_message);
		CurEnv->e_message = newstr(MsgBuf + 4);
		break;
	}
}
/*
**  PUTOUTMSG -- output error message to transcript and channel
**
**	Parameters:
**		msg -- message to output (in SMTP format).
**		holdmsg -- if TRUE, don't output a copy of the message to
**			our output channel.
**		heldmsg -- if TRUE, this is a previously held message;
**			don't log it to the transcript file.
**
**	Returns:
**		none.
**
**	Side Effects:
**		Outputs msg to the transcript.
**		If appropriate, outputs it to the channel.
**		Deletes SMTP reply code number as appropriate.
*/

void
putoutmsg(msg, holdmsg, heldmsg)
	char *msg;
	bool holdmsg;
	bool heldmsg;
{
	char msgcode = msg[0];

	/* display for debugging */
	if (tTd(54, 8))
		printf("--- %s%s%s\n", msg, holdmsg ? " (hold)" : "",
			heldmsg ? " (held)" : "");

	/* map warnings to something SMTP can handle */
	if (msgcode == '6')
		msg[0] = '5';
	else if (msgcode == '8')
		msg[0] = '4';

	/* output to transcript if serious */
	if (!heldmsg && CurEnv != NULL && CurEnv->e_xfp != NULL &&
	    strchr("45", msg[0]) != NULL)
		fprintf(CurEnv->e_xfp, "%s\n", msg);

	if (LogLevel >= 15 && (OpMode == MD_SMTP || OpMode == MD_DAEMON))
		sm_syslog(LOG_INFO, CurEnv->e_id,
			"--> %s%s",
			msg, holdmsg ? " (held)" : "");

	if (msgcode == '8')
		msg[0] = '0';

	/* output to channel if appropriate */
	if (!Verbose && msg[0] == '0')
		return;
	if (holdmsg)
	{
		/* save for possible future display */
		msg[0] = msgcode;
		snprintf(HeldMessageBuf, sizeof HeldMessageBuf, "%s", msg);
		return;
	}

	(void) fflush(stdout);

	if (OutChannel == NULL)
		return;
	
	/* if DisConnected, OutChannel now points to the transcript */
	if (!DisConnected &&
	    (OpMode == MD_SMTP || OpMode == MD_DAEMON || OpMode == MD_ARPAFTP))
		fprintf(OutChannel, "%s\r\n", msg);
	else
		fprintf(OutChannel, "%s\n", &msg[4]);
	if (TrafficLogFile != NULL)
		fprintf(TrafficLogFile, "%05d >>> %s\n", (int) getpid(),
			(OpMode == MD_SMTP || OpMode == MD_DAEMON) ? msg : &msg[4]);
	if (msg[3] == ' ')
		(void) fflush(OutChannel);
	if (!ferror(OutChannel) || DisConnected)
		return;

	/*
	**  Error on output -- if reporting lost channel, just ignore it.
	**  Also, ignore errors from QUIT response (221 message) -- some
	**	rude servers don't read result.
	*/

	if (InChannel == NULL || feof(InChannel) || ferror(InChannel) ||
	    strncmp(msg, "221", 3) == 0)
		return;

	/* can't call syserr, 'cause we are using MsgBuf */
	HoldErrs = TRUE;
	if (LogLevel > 0)
		sm_syslog(LOG_CRIT, CurEnv->e_id,
			"SYSERR: putoutmsg (%s): error on output channel sending \"%s\": %s",
			CurHostName == NULL ? "NO-HOST" : CurHostName,
			shortenstring(msg, MAXSHORTSTR), errstring(errno));
}
/*
**  PUTERRMSG -- like putoutmsg, but does special processing for error messages
**
**	Parameters:
**		msg -- the message to output.
**
**	Returns:
**		none.
**
**	Side Effects:
**		Sets the fatal error bit in the envelope as appropriate.
*/

void
puterrmsg(msg)
	char *msg;
{
	char msgcode = msg[0];

	/* output the message as usual */
	putoutmsg(msg, HoldErrs, FALSE);

	/* be careful about multiple error messages */
	if (OnlyOneError)
		HoldErrs = TRUE;

	/* signal the error */
	Errors++;

	if (CurEnv == NULL)
		return;
	
	if (msgcode == '6')
	{
		/* notify the postmaster */
		CurEnv->e_flags |= EF_PM_NOTIFY;
	}
	else if (msgcode == '5' && bitset(EF_GLOBALERRS, CurEnv->e_flags))
	{
		/* mark long-term fatal errors */
		CurEnv->e_flags |= EF_FATALERRS;
	}
}
/*
**  FMTMSG -- format a message into buffer.
**
**	Parameters:
**		eb -- error buffer to get result.
**		to -- the recipient tag for this message.
**		num -- arpanet error number.
**		en -- the error number to display.
**		fmt -- format of string.
**		a, b, c, d, e -- arguments.
**
**	Returns:
**		none.
**
**	Side Effects:
**		none.
*/

static void
fmtmsg(eb, to, num, eno, fmt, ap)
	register char *eb;
	const char *to;
	const char *num;
	int eno;
	const char *fmt;
	va_list ap;
{
	char del;
	int l;
	int spaceleft = sizeof MsgBuf;

	/* output the reply code */
	if (isascii(fmt[0]) && isdigit(fmt[0]) &&
	    isascii(fmt[1]) && isdigit(fmt[1]) &&
	    isascii(fmt[2]) && isdigit(fmt[2]))
	{
		num = fmt;
		fmt += 4;
	}
	if (num[3] == '-')
		del = '-';
	else
		del = ' ';
	(void) snprintf(eb, spaceleft, "%3.3s%c", num, del);
	eb += 4;
	spaceleft -= 4;

	/* output the file name and line number */
	if (FileName != NULL)
	{
		(void) snprintf(eb, spaceleft, "%s: line %d: ",
			shortenstring(FileName, 83), LineNumber);
		eb += (l = strlen(eb));
		spaceleft -= l;
	}

	/* output the "to" person */
	if (to != NULL && to[0] != '\0' &&
	    strncmp(num, "551", 3) != 0 &&
	    strncmp(num, "251", 3) != 0)
	{
		(void) snprintf(eb, spaceleft, "%s... ",
			shortenstring(to, MAXSHORTSTR));
		spaceleft -= strlen(eb);
		while (*eb != '\0')
			*eb++ &= 0177;
	}

	/* output the message */
	(void) vsnprintf(eb, spaceleft, fmt, ap);
	spaceleft -= strlen(eb);
	while (*eb != '\0')
		*eb++ &= 0177;

	/* output the error code, if any */
	if (eno != 0)
		(void) snprintf(eb, spaceleft, ": %s", errstring(eno));
}
/*
**  BUFFER_ERRORS -- arrange to buffer future error messages
**
**	Parameters:
**		none
**
**	Returns:
**		none.
*/

void
buffer_errors()
{
	HeldMessageBuf[0] = '\0';
	HoldErrs = TRUE;
}
/*
**  FLUSH_ERRORS -- flush the held error message buffer
**
**	Parameters:
**		print -- if set, print the message, otherwise just
**			delete it.
**
**	Returns:
**		none.
*/

void
flush_errors(print)
	bool print;
{
	if (print && HeldMessageBuf[0] != '\0')
		putoutmsg(HeldMessageBuf, FALSE, TRUE);
	HeldMessageBuf[0] = '\0';
	HoldErrs = FALSE;
}
/*
**  ERRSTRING -- return string description of error code
**
**	Parameters:
**		errnum -- the error number to translate
**
**	Returns:
**		A string description of errnum.
**
**	Side Effects:
**		none.
*/

const char *
errstring(errnum)
	int errnum;
{
	char *dnsmsg;
	char *bp;
	static char buf[MAXLINE];
# if !HASSTRERROR && !defined(ERRLIST_PREDEFINED)
	extern char *sys_errlist[];
	extern int sys_nerr;
# endif
# if SMTP
	extern char *SmtpPhase;
# endif /* SMTP */

	/*
	**  Handle special network error codes.
	**
	**	These are 4.2/4.3bsd specific; they should be in daemon.c.
	*/

	dnsmsg = NULL;
	switch (errnum)
	{
# if defined(DAEMON) && defined(ETIMEDOUT)
	  case ETIMEDOUT:
	  case ECONNRESET:
		bp = buf;
#if HASSTRERROR
		snprintf(bp, SPACELEFT(buf, bp), "%s", strerror(errnum));
#else
		if (errnum >= 0 && errnum < sys_nerr)
			snprintf(bp, SPACELEFT(buf, bp), "%s", sys_errlist[errnum]);
		else
			snprintf(bp, SPACELEFT(buf, bp), "Error %d", errnum);
#endif
		bp += strlen(bp);
		if (CurHostName != NULL)
		{
			if (errnum == ETIMEDOUT)
			{
				snprintf(bp, SPACELEFT(buf, bp), " with ");
				bp += strlen(bp);
			}
			else
			{
				bp = buf;
				snprintf(bp, SPACELEFT(buf, bp),
					"Connection reset by ");
				bp += strlen(bp);
			}
			snprintf(bp, SPACELEFT(buf, bp), "%s",
				shortenstring(CurHostName, MAXSHORTSTR));
			bp += strlen(buf);
		}
		if (SmtpPhase != NULL)
		{
			snprintf(bp, SPACELEFT(buf, bp), " during %s",
				SmtpPhase);
		}
		return (buf);

	  case EHOSTDOWN:
		if (CurHostName == NULL)
			break;
		(void) snprintf(buf, sizeof buf, "Host %s is down",
			shortenstring(CurHostName, MAXSHORTSTR));
		return (buf);

	  case ECONNREFUSED:
		if (CurHostName == NULL)
			break;
		(void) snprintf(buf, sizeof buf, "Connection refused by %s",
			shortenstring(CurHostName, MAXSHORTSTR));
		return (buf);
# endif

# if NAMED_BIND
	  case HOST_NOT_FOUND + E_DNSBASE:
		dnsmsg = "host not found";
		break;

	  case TRY_AGAIN + E_DNSBASE:
		dnsmsg = "host name lookup failure";
		break;

	  case NO_RECOVERY + E_DNSBASE:
		dnsmsg = "non-recoverable error";
		break;

	  case NO_DATA + E_DNSBASE:
		dnsmsg = "no data known";
		break;
# endif

	  case EPERM:
		/* SunOS gives "Not owner" -- this is the POSIX message */
		return "Operation not permitted";

	/*
	**  Error messages used internally in sendmail.
	*/

	  case E_SM_OPENTIMEOUT:
		return "Timeout on file open";

	  case E_SM_NOSLINK:
		return "Symbolic links not allowed";

	  case E_SM_NOHLINK:
		return "Hard links not allowed";

	  case E_SM_REGONLY:
		return "Regular files only";

	  case E_SM_ISEXEC:
		return "Executable files not allowed";

	  case E_SM_WWDIR:
		return "World writable directory";

	  case E_SM_GWDIR:
		return "Group writable directory";

	  case E_SM_FILECHANGE:
		return "File changed after open";

	  case E_SM_WWFILE:
		return "World writable file";

	  case E_SM_GWFILE:
		return "Group writable file";
	}

	if (dnsmsg != NULL)
	{
		bp = buf;
		strcpy(bp, "Name server: ");
		bp += strlen(bp);
		if (CurHostName != NULL)
		{
			snprintf(bp, SPACELEFT(buf, bp), "%s: ",
				shortenstring(CurHostName, MAXSHORTSTR));
			bp += strlen(bp);
		}
		snprintf(bp, SPACELEFT(buf, bp), "%s", dnsmsg);
		return buf;
	}

#if HASSTRERROR
	return strerror(errnum);
#else
	if (errnum > 0 && errnum < sys_nerr)
		return (sys_errlist[errnum]);

	(void) snprintf(buf, sizeof buf, "Error %d", errnum);
	return (buf);
#endif
}
@


1.9
log
@sendmail 8.9.2
@
text
@@


1.8
log
@something hosed the sendmail import; fix up by hand
@
text
@d14 1
a14 1
static char sccsid[] = "@@(#)err.c	8.74 (Berkeley) 6/4/98";
@


1.7
log
@Upgrade to sendmail 8.8.8
@
text
@d2 2
a3 1
 * Copyright (c) 1983, 1995-1997 Eric P. Allman
d7 3
a9 15
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
a10 11
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
d14 1
a14 1
static char sccsid[] = "@@(#)err.c	8.65 (Berkeley) 10/18/97";
d254 1
a254 1
/*VARARGS2*/
d306 1
a306 1
/*VARARGS2*/
d437 1
a437 1
			shortenstring(msg, 203), errstring(errno));
d514 3
a516 1
	if (isdigit(fmt[0]) && isdigit(fmt[1]) && isdigit(fmt[2]))
d544 1
a544 1
			shortenstring(to, 203));
d640 4
a643 1
		snprintf(bp, SPACELEFT(buf, bp), "%s", sys_errlist[errnum]);
d661 1
a661 1
				shortenstring(CurHostName, 203));
d675 1
a675 1
			shortenstring(CurHostName, 203));
d682 1
a682 1
			shortenstring(CurHostName, 203));
d751 1
a751 1
				shortenstring(CurHostName, 203));
@


1.6
log
@sendmail 8.8.7.
@
text
@d36 1
a36 1
static char sccsid[] = "@@(#)err.c	8.64 (Berkeley) 7/25/97";
d559 3
a561 1
	if (to != NULL && to[0] != '\0')
@


1.5
log
@Sendmail 8.8.6.
@
text
@d36 1
a36 1
static char sccsid[] = "@@(#)err.c	8.62 (Berkeley) 6/5/97";
d115 1
a115 1
	if (!panic)
d143 4
a146 3
		sm_syslog(panic ? LOG_ALERT : LOG_CRIT, CurEnv->e_id,
			"SYSERR(%s): %.900s",
			uname, &MsgBuf[4]);
d182 1
a182 1
	if (QuickAbort || (OnlyOneError && !HoldErrs))
d258 1
a258 1
	if (QuickAbort || (OnlyOneError && !HoldErrs))
d401 2
a402 1
	if (!heldmsg && CurEnv->e_xfp != NULL && strchr("45", msg[0]) != NULL)
d426 3
d449 2
a450 1
	if (feof(InChannel) || ferror(InChannel) || strncmp(msg, "221", 3) == 0)
d483 4
d489 4
@


1.4
log
@Update to Sendmail 8.8.4, plus recent patches, plus OpenBSD support.
Also include entire example configuration subset.
Includes smrsh (using /usr/libexec/sm.bin).

Of the top of my head, the only things I removed from the distribution were
contrib/mail.local.linux, src/Makefiles, all the *.0 and *.ps files.
Our praliases man page replaces the distributed one, ours is better.
@
text
@d2 1
a2 1
 * Copyright (c) 1983, 1995, 1996 Eric P. Allman
d36 1
a36 1
static char sccsid[] = "@@(#)err.c	8.52 (Berkeley) 12/1/96";
d45 1
a45 2
**	Prints an error message via printf to the diagnostic
**	output.  If LOG is defined, it logs it also.
a91 1
#ifdef LOG
a94 1
#endif
d99 1
d101 2
a132 1
# ifdef LOG
d143 2
a144 2
		syslog(panic ? LOG_ALERT : LOG_CRIT, "%s: SYSERR(%s): %.900s",
			CurEnv->e_id == NULL ? "NOQUEUE" : CurEnv->e_id,
a145 1
# endif /* LOG */
d181 1
a181 1
	if (QuickAbort)
a251 1
# ifdef LOG
d253 2
a254 2
		syslog(LOG_NOTICE, "%s: %.900s",
			CurEnv->e_id == NULL ? "NOQUEUE" : CurEnv->e_id,
a255 1
# endif /* LOG */
d257 1
a257 1
	if (QuickAbort)
a402 1
#ifdef LOG
d404 3
a406 2
		syslog(LOG_INFO, "--> %s%s", msg, holdmsg ? " (held)" : "");
#endif
a448 1
#ifdef LOG
d450 2
a451 3
		syslog(LOG_CRIT,
			"%s: SYSERR: putoutmsg (%s): error on output channel sending \"%s\": %s",
			CurEnv->e_id == NULL ? "NOQUEUE" : CurEnv->e_id,
a453 1
#endif
a517 1
	char *meb;
a553 2
	meb = eb;

d620 1
a620 1
# ifndef ERRLIST_PREDEFINED
d641 3
d645 1
a686 3
	  case EOPENTIMEOUT:
		return "Timeout on file open";

d708 34
d759 3
d767 1
@


1.3
log
@bring up to 8.7.6
@
text
@d2 1
a2 1
 * Copyright (c) 1983, 1995 Eric P. Allman
d36 1
a36 1
static char sccsid[] = "@@(#)err.c	8.42.1.2 (Berkeley) 9/16/96";
d148 1
a148 1
	if (olderrno == EMFILE)
d150 19
d171 1
d407 5
d435 1
a435 1
		fprintf(TrafficLogFile, "%05d >>> %s\n", getpid(),
d634 1
a634 1
# ifdef SMTP
d652 19
a670 1
		bp += strlen(buf);
a674 6
			bp += strlen(bp);
		}
		if (CurHostName != NULL)
		{
			snprintf(bp, SPACELEFT(buf, bp), " with %s",
				shortenstring(CurHostName, 203));
@


1.2
log
@Sendmail 8.7.3 from NetBSD
@
text
@d36 1
a36 1
static char sccsid[] = "@@(#)err.c	8.42 (Berkeley) 11/29/95";
d140 1
a140 1
		sprintf(ubuf, "UID%d", getuid());
d221 1
a221 1
			sprintf(buf, "Postmaster warning: %.*s",
d397 1
a397 1
		strcpy(HeldMessageBuf, msg);
d514 1
a514 1
	(void) sprintf(eb, "%3.3s%c", num, del);
d603 1
d625 3
a627 1
		(void) strcpy(buf, sys_errlist[errnum]);
d630 3
a632 2
			(void) strcat(buf, " during ");
			(void) strcat(buf, SmtpPhase);
d636 2
a637 2
			(void) strcat(buf, " with ");
			(void) strcat(buf, CurHostName);
d644 1
a644 1
		(void) sprintf(buf, "Host %s is down",
d651 1
a651 1
		(void) sprintf(buf, "Connection refused by %s",
d684 3
a686 1
		(void) strcpy(buf, "Name server: ");
d689 3
a691 2
			(void) strcat(buf, CurHostName);
			(void) strcat(buf, ": ");
d693 1
a693 1
		(void) strcat(buf, dnsmsg);
d700 1
a700 1
	(void) sprintf(buf, "Error %d", errnum);
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
 * Copyright (c) 1983 Eric P. Allman
d36 1
a36 1
static char sccsid[] = "@@(#)err.c	8.27 (Berkeley) 4/18/94";
a40 2
# include <netdb.h>
# include <pwd.h>
d54 5
a58 2
**		f -- the format string
**		a, b, c, d, e -- parameters
d69 2
a70 1
char	MsgBuf[BUFSIZ*2];	/* text of most recent message */
d72 3
a74 1
static void	fmtmsg();
d114 8
d134 1
a134 1
	pw = getpwuid(getuid());
d144 1
a144 1
		syslog(panic ? LOG_ALERT : LOG_CRIT, "%s: SYSERR(%s): %s",
d158 2
d172 3
a174 1
**		fmt, a, b, c, d -- printf strings
d202 30
d236 1
a236 1
		syslog(LOG_NOTICE, "%s: %s",
d250 1
a250 1
**		a, b, c, d, e -- printf arguments
d275 17
a291 1
	putoutmsg(MsgBuf, FALSE);
a298 1
**		num -- the default ARPANET error number (in ascii)
d300 3
a302 2
**			with three digits, this number overrides num.
**		a, b, c, d, e -- printf arguments
d327 17
a343 1
	putoutmsg(MsgBuf, FALSE);
d352 2
d364 2
a365 1
putoutmsg(msg, holdmsg)
d368 1
d370 2
d374 8
a381 1
		printf("--- %s%s\n", msg, holdmsg ? " (held)" : "");
d384 1
a384 1
	if (CurEnv->e_xfp != NULL && strchr("456", msg[0]) != NULL)
d387 3
d391 7
a397 1
	if (holdmsg || (!Verbose && msg[0] == '0'))
d399 1
a399 4

	/* map warnings to something SMTP can handle */
	if (msg[0] == '6')
		msg[0] = '5';
d434 1
a434 1
			msg, errstring(errno));
d450 1
d457 1
a457 1
	putoutmsg(msg, HoldErrs);
d493 2
a494 2
	char *to;
	char *num;
d496 1
a496 1
	char *fmt;
d501 2
d516 1
d521 4
a524 2
		(void) sprintf(eb, "%s: line %d: ", FileName, LineNumber);
		eb += strlen(eb);
d530 3
a532 1
		(void) sprintf(eb, "%s... ", shortenstring(to, 203));
d540 2
a541 1
	(void) vsprintf(eb, fmt, ap);
d547 28
a574 4
	{
		(void) sprintf(eb, ": %s", errstring(eno));
		eb += strlen(eb);
	}
d576 8
a583 6
	if (num[0] == '5' || (CurEnv->e_message == NULL && num[0] == '4'))
	{
		if (CurEnv->e_message != NULL)
			free(CurEnv->e_message);
		CurEnv->e_message = newstr(meb);
	}
d640 2
a641 1
		(void) sprintf(buf, "Host %s is down", CurHostName);
d647 2
a648 1
		(void) sprintf(buf, "Connection refused by %s", CurHostName);
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@


1.1.1.2
log
@sendmail 8.9.1
@
text
@d2 1
a2 2
 * Copyright (c) 1998 Sendmail, Inc.  All rights reserved.
 * Copyright (c) 1983, 1995-1997 Eric P. Allman.  All rights reserved.
d6 15
a20 3
 * By using this file, you agree to the terms and conditions set
 * forth in the LICENSE file which can be found at the top level of
 * the sendmail distribution.
d22 11
d36 1
a36 1
static char sccsid[] = "@@(#)err.c	8.74 (Berkeley) 6/4/98";
d41 2
d47 2
a48 1
**	Prints an error message via printf to the diagnostic output.
d56 2
a57 5
**		fmt -- the format string.  If it does not begin with
**			a three-digit SMTP reply code, either 554 or
**			451 is assumed depending on whether errno
**			is set.
**		(others) -- parameters
d68 1
a68 2
char	MsgBuf[BUFSIZ*2];		/* text of most recent message */
char	HeldMessageBuf[sizeof MsgBuf];	/* for held messages */
d70 1
a70 3
extern void	putoutmsg __P((char *, bool, bool));
extern void	puterrmsg __P((char *));
static void	fmtmsg __P((char *, const char *, const char *, int, const char *, va_list));
d89 1
d93 1
a97 1
	{
a98 2
		HoldErrs = FALSE;
	}
a109 8
	/* save this message for mailq printing */
	if (!panic && CurEnv != NULL)
	{
		if (CurEnv->e_message != NULL)
			free(CurEnv->e_message);
		CurEnv->e_message = newstr(MsgBuf + 4);
	}

d121 2
a122 1
	pw = sm_getpwuid(getuid());
d128 1
a128 1
		snprintf(ubuf, sizeof ubuf, "UID%d", getuid());
d132 6
a137 25
		sm_syslog(panic ? LOG_ALERT : LOG_CRIT,
			  CurEnv == NULL ? NOQID : CurEnv->e_id,
			  "SYSERR(%s): %.900s",
			  uname, &MsgBuf[4]);
	switch (olderrno)
	{
	  case EBADF:
	  case ENFILE:
	  case EMFILE:
	  case ENOTTY:
#ifdef EFBIG
	  case EFBIG:
#endif
#ifdef ESPIPE
	  case ESPIPE:
#endif
#ifdef EPIPE
	  case EPIPE:
#endif
#ifdef ENOBUFS
	  case ENOBUFS:
#endif
#ifdef ESTALE
	  case ESTALE:
#endif
a139 1
		break;
a145 2
		if (tTd(0, 1))
			abort();
d158 1
a158 3
**		fmt -- the format string.  If it does not begin with
**			a three-digit SMTP reply code, 501 is assumed.
**		(others) -- printf strings
a185 30

	/* save this message for mailq printing */
	switch (MsgBuf[0])
	{
	  case '4':
	  case '8':
		if (CurEnv->e_message != NULL)
			break;

		/* fall through.... */

	  case '5':
	  case '6':
		if (CurEnv->e_message != NULL)
			free(CurEnv->e_message);
		if (MsgBuf[0] == '6')
		{
			char buf[MAXLINE];

			snprintf(buf, sizeof buf, "Postmaster warning: %.*s",
				sizeof buf - 22, MsgBuf + 4);
			CurEnv->e_message = newstr(buf);
		}
		else
		{
			CurEnv->e_message = newstr(MsgBuf + 4);
		}
		break;
	}

d188 1
d190 2
a191 2
		sm_syslog(LOG_NOTICE, CurEnv->e_id,
			"%.900s",
d193 1
d204 1
a204 1
**		(others) -- printf arguments
d213 1
a213 1
/*VARARGS1*/
d229 1
a229 17
	putoutmsg(MsgBuf, FALSE, FALSE);

	/* save this message for mailq printing */
	switch (MsgBuf[0])
	{
	  case '4':
	  case '8':
		if (CurEnv->e_message != NULL)
			break;
		/* fall through.... */

	  case '5':
		if (CurEnv->e_message != NULL)
			free(CurEnv->e_message);
		CurEnv->e_message = newstr(MsgBuf + 4);
		break;
	}
d237 1
d239 2
a240 3
**			with a three digit SMTP reply code, that is used,
**			otherwise 050 is assumed.
**		(others) -- printf arguments
d249 1
a249 1
/*VARARGS1*/
d265 1
a265 17
	putoutmsg(MsgBuf, FALSE, FALSE);

	/* save this message for mailq printing */
	switch (MsgBuf[0])
	{
	  case '4':
	  case '8':
		if (CurEnv->e_message != NULL)
			break;
		/* fall through.... */

	  case '5':
		if (CurEnv->e_message != NULL)
			free(CurEnv->e_message);
		CurEnv->e_message = newstr(MsgBuf + 4);
		break;
	}
a273 2
**		heldmsg -- if TRUE, this is a previously held message;
**			don't log it to the transcript file.
d284 1
a284 2
void
putoutmsg(msg, holdmsg, heldmsg)
a286 1
	bool heldmsg;
a287 2
	char msgcode = msg[0];

d290 1
a290 8
		printf("--- %s%s%s\n", msg, holdmsg ? " (hold)" : "",
			heldmsg ? " (held)" : "");

	/* map warnings to something SMTP can handle */
	if (msgcode == '6')
		msg[0] = '5';
	else if (msgcode == '8')
		msg[0] = '4';
d293 1
a293 2
	if (!heldmsg && CurEnv != NULL && CurEnv->e_xfp != NULL &&
	    strchr("45", msg[0]) != NULL)
a295 8
	if (LogLevel >= 15 && (OpMode == MD_SMTP || OpMode == MD_DAEMON))
		sm_syslog(LOG_INFO, CurEnv->e_id,
			"--> %s%s",
			msg, holdmsg ? " (held)" : "");

	if (msgcode == '8')
		msg[0] = '0';

d297 1
a297 1
	if (!Verbose && msg[0] == '0')
d299 4
a302 7
	if (holdmsg)
	{
		/* save for possible future display */
		msg[0] = msgcode;
		snprintf(HeldMessageBuf, sizeof HeldMessageBuf, "%s", msg);
		return;
	}
a305 3
	if (OutChannel == NULL)
		return;
	
d313 1
a313 1
		fprintf(TrafficLogFile, "%05d >>> %s\n", (int) getpid(),
d326 1
a326 2
	if (InChannel == NULL || feof(InChannel) || ferror(InChannel) ||
	    strncmp(msg, "221", 3) == 0)
d331 1
d333 3
a335 2
		sm_syslog(LOG_CRIT, CurEnv->e_id,
			"SYSERR: putoutmsg (%s): error on output channel sending \"%s\": %s",
d337 2
a338 1
			shortenstring(msg, MAXSHORTSTR), errstring(errno));
a352 1
void
d359 1
a359 5
	putoutmsg(msg, HoldErrs, FALSE);

	/* be careful about multiple error messages */
	if (OnlyOneError)
		HoldErrs = TRUE;
a362 4

	if (CurEnv == NULL)
		return;
	
d395 2
a396 2
	const char *to;
	const char *num;
d398 1
a398 1
	const char *fmt;
d402 1
a402 2
	int l;
	int spaceleft = sizeof MsgBuf;
d405 1
a405 3
	if (isascii(fmt[0]) && isdigit(fmt[0]) &&
	    isascii(fmt[1]) && isdigit(fmt[1]) &&
	    isascii(fmt[2]) && isdigit(fmt[2]))
d414 1
a414 1
	(void) snprintf(eb, spaceleft, "%3.3s%c", num, del);
a415 1
	spaceleft -= 4;
d420 2
a421 4
		(void) snprintf(eb, spaceleft, "%s: line %d: ",
			shortenstring(FileName, 83), LineNumber);
		eb += (l = strlen(eb));
		spaceleft -= l;
d425 3
a427 7
	if (to != NULL && to[0] != '\0' &&
	    strncmp(num, "551", 3) != 0 &&
	    strncmp(num, "251", 3) != 0)
	{
		(void) snprintf(eb, spaceleft, "%s... ",
			shortenstring(to, MAXSHORTSTR));
		spaceleft -= strlen(eb);
d432 2
d435 1
a435 2
	(void) vsnprintf(eb, spaceleft, fmt, ap);
	spaceleft -= strlen(eb);
d441 4
a444 11
		(void) snprintf(eb, spaceleft, ": %s", errstring(eno));
}
/*
**  BUFFER_ERRORS -- arrange to buffer future error messages
**
**	Parameters:
**		none
**
**	Returns:
**		none.
*/
d446 6
a451 25
void
buffer_errors()
{
	HeldMessageBuf[0] = '\0';
	HoldErrs = TRUE;
}
/*
**  FLUSH_ERRORS -- flush the held error message buffer
**
**	Parameters:
**		print -- if set, print the message, otherwise just
**			delete it.
**
**	Returns:
**		none.
*/

void
flush_errors(print)
	bool print;
{
	if (print && HeldMessageBuf[0] != '\0')
		putoutmsg(HeldMessageBuf, FALSE, TRUE);
	HeldMessageBuf[0] = '\0';
	HoldErrs = FALSE;
a470 1
	char *bp;
d472 1
a472 1
# if !HASSTRERROR && !defined(ERRLIST_PREDEFINED)
d476 1
a476 1
# if SMTP
d492 2
a493 11
		bp = buf;
#if HASSTRERROR
		snprintf(bp, SPACELEFT(buf, bp), "%s", strerror(errnum));
#else
		if (errnum >= 0 && errnum < sys_nerr)
			snprintf(bp, SPACELEFT(buf, bp), "%s", sys_errlist[errnum]);
		else
			snprintf(bp, SPACELEFT(buf, bp), "Error %d", errnum);
#endif
		bp += strlen(bp);
		if (CurHostName != NULL)
d495 2
a496 15
			if (errnum == ETIMEDOUT)
			{
				snprintf(bp, SPACELEFT(buf, bp), " with ");
				bp += strlen(bp);
			}
			else
			{
				bp = buf;
				snprintf(bp, SPACELEFT(buf, bp),
					"Connection reset by ");
				bp += strlen(bp);
			}
			snprintf(bp, SPACELEFT(buf, bp), "%s",
				shortenstring(CurHostName, MAXSHORTSTR));
			bp += strlen(buf);
d498 1
a498 1
		if (SmtpPhase != NULL)
d500 2
a501 2
			snprintf(bp, SPACELEFT(buf, bp), " during %s",
				SmtpPhase);
d508 1
a508 2
		(void) snprintf(buf, sizeof buf, "Host %s is down",
			shortenstring(CurHostName, MAXSHORTSTR));
d514 1
a514 2
		(void) snprintf(buf, sizeof buf, "Connection refused by %s",
			shortenstring(CurHostName, MAXSHORTSTR));
d518 3
a541 34

	/*
	**  Error messages used internally in sendmail.
	*/

	  case E_SM_OPENTIMEOUT:
		return "Timeout on file open";

	  case E_SM_NOSLINK:
		return "Symbolic links not allowed";

	  case E_SM_NOHLINK:
		return "Hard links not allowed";

	  case E_SM_REGONLY:
		return "Regular files only";

	  case E_SM_ISEXEC:
		return "Executable files not allowed";

	  case E_SM_WWDIR:
		return "World writable directory";

	  case E_SM_GWDIR:
		return "Group writable directory";

	  case E_SM_FILECHANGE:
		return "File changed after open";

	  case E_SM_WWFILE:
		return "World writable file";

	  case E_SM_GWFILE:
		return "Group writable file";
d546 1
a546 3
		bp = buf;
		strcpy(bp, "Name server: ");
		bp += strlen(bp);
d549 2
a550 3
			snprintf(bp, SPACELEFT(buf, bp), "%s: ",
				shortenstring(CurHostName, MAXSHORTSTR));
			bp += strlen(bp);
d552 1
a552 1
		snprintf(bp, SPACELEFT(buf, bp), "%s", dnsmsg);
a555 3
#if HASSTRERROR
	return strerror(errnum);
#else
d559 1
a559 1
	(void) snprintf(buf, sizeof buf, "Error %d", errnum);
a560 1
#endif
@

