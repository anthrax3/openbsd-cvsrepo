head	1.10;
access;
symbols
	OPENBSD_2_6:1.9.0.4
	OPENBSD_2_6_BASE:1.9
	OPENBSD_2_5:1.9.0.2
	OPENBSD_2_5_BASE:1.9
	OPENBSD_2_4:1.7.0.2
	OPENBSD_2_4_BASE:1.7
	sendmail_8_9_1:1.1.1.2
	UCB:1.1.1
	OPENBSD_2_3:1.6.0.4
	OPENBSD_2_3_BASE:1.6
	OPENBSD_2_2:1.6.0.2
	OPENBSD_2_2_BASE:1.6
	OPENBSD_2_1:1.5.0.2
	OPENBSD_2_1_BASE:1.5
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.10
date	2000.04.18.04.57.28;	author millert;	state dead;
branches;
next	1.9;

1.9
date	99.02.05.05.59.36;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	99.01.01.20.34.05;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	98.07.12.19.45.24;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	97.07.15.07.24.18;	author downsj;	state Exp;
branches;
next	1.5;

1.5
date	97.01.22.01.07.25;	author downsj;	state Exp;
branches;
next	1.4;

1.4
date	96.12.14.21.17.45;	author downsj;	state Exp;
branches;
next	1.3;

1.3
date	96.09.19.06.45.06;	author fn;	state Exp;
branches;
next	1.2;

1.2
date	96.01.29.01.44.47;	author dm;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.48.20;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.48.20;	author deraadt;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	98.07.12.17.10.48;	author millert;	state Exp;
branches;
next	;


desc
@@


1.10
log
@remove sendmail 8.9.3
@
text
@/*
 * Copyright (c) 1998 Sendmail, Inc.  All rights reserved.
 * Copyright (c) 1983, 1995-1997 Eric P. Allman.  All rights reserved.
 * Copyright (c) 1988, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * By using this file, you agree to the terms and conditions set
 * forth in the LICENSE file which can be found at the top level of
 * the sendmail distribution.
 *
 */

#include "sendmail.h"

#ifndef lint
#if USERDB
static char sccsid [] = "@@(#)udb.c	8.71 (Berkeley) 1/17/1999 (with USERDB)";
#else
static char sccsid [] = "@@(#)udb.c	8.71 (Berkeley) 1/17/1999 (without USERDB)";
#endif
#endif

#if USERDB

#include <errno.h>

#ifdef NEWDB
# include <db.h>
# ifndef DB_VERSION_MAJOR
#  define DB_VERSION_MAJOR 1
# endif
#else
# define DBT	struct _data_base_thang_
DBT
{
	void	*data;		/* pointer to data */
	size_t	size;		/* length of data */
};
#endif

/*
**  UDB.C -- interface between sendmail and Berkeley User Data Base.
**
**	This depends on the 4.4BSD db package.
*/


struct udbent
{
	char	*udb_spec;		/* string version of spec */
	int	udb_type;		/* type of entry */
	pid_t	udb_pid;		/* PID of process which opened db */
	char	*udb_default;		/* default host for outgoing mail */
	union
	{
		/* type UE_REMOTE -- do remote call for lookup */
		struct
		{
			struct sockaddr_in _udb_addr;	/* address */
			int		_udb_timeout;	/* timeout */
		} udb_remote;
#define udb_addr	udb_u.udb_remote._udb_addr
#define udb_timeout	udb_u.udb_remote._udb_timeout

		/* type UE_FORWARD -- forward message to remote */
		struct
		{
			char	*_udb_fwdhost;	/* name of forward host */
		} udb_forward;
#define udb_fwdhost	udb_u.udb_forward._udb_fwdhost

#ifdef NEWDB
		/* type UE_FETCH -- lookup in local database */
		struct
		{
			char	*_udb_dbname;	/* pathname of database */
			DB	*_udb_dbp;	/* open database ptr */
		} udb_lookup;
#define udb_dbname	udb_u.udb_lookup._udb_dbname
#define udb_dbp		udb_u.udb_lookup._udb_dbp
#endif
	} udb_u;
};

#define UDB_EOLIST	0	/* end of list */
#define UDB_SKIP	1	/* skip this entry */
#define UDB_REMOTE	2	/* look up in remote database */
#define UDB_DBFETCH	3	/* look up in local database */
#define UDB_FORWARD	4	/* forward to remote host */
#define UDB_HESIOD	5	/* look up via hesiod */

#define MAXUDBENT	10	/* maximum number of UDB entries */


struct udb_option
{
	char	*name;
	char	*val;
};

#ifdef HESIOD
extern int hes_udb_get __P((DBT *, DBT *));
#endif
extern int _udbx_init __P((ENVELOPE *));
/*
**  UDBEXPAND -- look up user in database and expand
**
**	Parameters:
**		a -- address to expand.
**		sendq -- pointer to head of sendq to put the expansions in.
**		aliaslevel -- the current alias nesting depth.
**		e -- the current envelope.
**
**	Returns:
**		EX_TEMPFAIL -- if something "odd" happened -- probably due
**			to accessing a file on an NFS server that is down.
**		EX_OK -- otherwise.
**
**	Side Effects:
**		Modifies sendq.
*/

int	UdbPort = 1616;
int	UdbTimeout = 10;

struct udbent	UdbEnts[MAXUDBENT + 1];
int		UdbSock = -1;
bool		UdbInitialized = FALSE;

int
udbexpand(a, sendq, aliaslevel, e)
	register ADDRESS *a;
	ADDRESS **sendq;
	int aliaslevel;
	register ENVELOPE *e;
{
	int i;
	DBT key;
	DBT info;
	bool breakout;
	register struct udbent *up;
	int keylen;
	int naddrs;
	char *user;
	char keybuf[MAXKEY];

	bzero(&key, sizeof key);
	bzero(&info, sizeof info);

	if (tTd(28, 1))
		printf("udbexpand(%s)\n", a->q_paddr);

	/* make certain we are supposed to send to this address */
	if (bitset(QDONTSEND|QVERIFIED, a->q_flags))
		return EX_OK;
	e->e_to = a->q_paddr;

	/* on first call, locate the database */
	if (!UdbInitialized)
	{
		if (_udbx_init(e) == EX_TEMPFAIL)
			return EX_TEMPFAIL;
	}

	/* short circuit the process if no chance of a match */
	if (UdbSpec == NULL || UdbSpec[0] == '\0')
		return EX_OK;

	/* extract user to do userdb matching on */
	user = a->q_user;

	/* short circuit name begins with '\\' since it can't possibly match */
	/* (might want to treat this as unquoted instead) */
	if (user[0] == '\\')
		return EX_OK;

	/* if name is too long, assume it won't match */
	if (strlen(user) > (SIZE_T) sizeof keybuf - 12)
		return EX_OK;

	/* if name begins with a colon, it indicates our metadata */
	if (user[0] == ':')
		return EX_OK;

	/* build actual database key */
	(void) strcpy(keybuf, user);
	(void) strcat(keybuf, ":maildrop");
	keylen = strlen(keybuf);

	breakout = FALSE;
	for (up = UdbEnts; !breakout; up++)
	{
		char *user;
		int usersize;
		int userleft;
		char userbuf[MEMCHUNKSIZE];
#if defined(HESIOD) && defined(HES_GETMAILHOST)
		char pobuf[MAXNAME];
#endif
#if defined(NEWDB) && DB_VERSION_MAJOR > 1
		DBC *dbc = NULL;
#endif

		user = userbuf;
		userbuf[0] = '\0';
		usersize = sizeof userbuf;
		userleft = sizeof userbuf - 1;

		/*
		**  Select action based on entry type.
		**
		**	On dropping out of this switch, "class" should
		**	explain the type of the data, and "user" should
		**	contain the user information.
		*/

		switch (up->udb_type)
		{
#ifdef NEWDB
		  case UDB_DBFETCH:
			key.data = keybuf;
			key.size = keylen;
			if (tTd(28, 80))
				printf("udbexpand: trying %s (%d) via db\n",
					keybuf, keylen);
#if DB_VERSION_MAJOR < 2
			i = (*up->udb_dbp->seq)(up->udb_dbp, &key, &info, R_CURSOR);
#else
			i = 0;
			if (dbc == NULL &&
# if DB_VERSION_MAJOR > 2 || DB_VERSION_MINOR >=6
			    (errno = (*up->udb_dbp->cursor)(up->udb_dbp,
							    NULL, &dbc, 0)) != 0)
# else
			    (errno = (*up->udb_dbp->cursor)(up->udb_dbp,
							    NULL, &dbc)) != 0)
# endif
				i = -1;
			if (i != 0 || dbc == NULL ||
			    (errno = dbc->c_get(dbc, &key,
						&info, DB_SET)) != 0)
				i = 1;
#endif
			if (i > 0 || info.size <= 0)
			{
				if (tTd(28, 2))
					printf("udbexpand: no match on %s (%d)\n",
						keybuf, keylen);
#if DB_VERSION_MAJOR > 1
				if (dbc != NULL) 
				{
					(void) dbc->c_close(dbc);
					dbc = NULL;
				}
#endif
				break;
			}
			if (tTd(28, 80))
				printf("udbexpand: match %.*s: %.*s\n",
					(int) key.size, (char *) key.data,
					(int) info.size, (char *) info.data);

			a->q_flags &= ~QSELFREF;
			while (i == 0 && key.size == keylen &&
					bcmp(key.data, keybuf, keylen) == 0)
			{
				char *p;

				if (bitset(EF_VRFYONLY, e->e_flags))
				{
					a->q_flags |= QVERIFIED;
#if DB_VERSION_MAJOR > 1
					if (dbc != NULL)
					{
						(void) dbc->c_close(dbc);
						dbc = NULL;
					}
#endif
					return EX_OK;
				}

				breakout = TRUE;
				if (info.size >= userleft - 1)
				{
					char *nuser;
					int size = MEMCHUNKSIZE;

					if (info.size > MEMCHUNKSIZE)
						size = info.size;
					nuser = xalloc(usersize + size);

					bcopy(user, nuser, usersize);
					if (user != userbuf)
						free(user);
					user = nuser;
					usersize += size;
					userleft += size;
				}
				p = &user[strlen(user)];
				if (p != user)
				{
					*p++ = ',';
					userleft--;
				}
				bcopy(info.data, p, info.size);
				p[info.size] = '\0';
				userleft -= info.size;

				/* get the next record */
#if DB_VERSION_MAJOR < 2
				i = (*up->udb_dbp->seq)(up->udb_dbp, &key, &info, R_NEXT);
#else
				i = 0;
				if ((errno = dbc->c_get(dbc, &key,
							&info, DB_NEXT)) != 0)
					i = 1;
#endif
			}

#if DB_VERSION_MAJOR > 1
			if (dbc != NULL)
			{
				(void) dbc->c_close(dbc);
				dbc = NULL;
			}
#endif

			/* if nothing ever matched, try next database */
			if (!breakout)
				break;

			message("expanded to %s", user);
			if (LogLevel >= 10)
				sm_syslog(LOG_INFO, e->e_id,
					"expand %.100s => %s",
					e->e_to,
					shortenstring(user, MAXSHORTSTR));
			naddrs = sendtolist(user, a, sendq, aliaslevel + 1, e);
			if (naddrs > 0 && !bitset(QSELFREF, a->q_flags))
			{
				if (tTd(28, 5))
				{
					printf("udbexpand: QDONTSEND ");
					printaddr(a, FALSE);
				}
				a->q_flags |= QDONTSEND;
			}
			if (i < 0)
			{
				syserr("udbexpand: db-get %.*s stat %d",
					(int) key.size, (char *) key.data, i);
				return EX_TEMPFAIL;
			}

			/*
			**  If this address has a -request address, reflect
			**  it into the envelope.
			*/

			bzero(&key, sizeof key);
			bzero(&info, sizeof info);
			(void) strcpy(keybuf, a->q_user);
			(void) strcat(keybuf, ":mailsender");
			keylen = strlen(keybuf);
			key.data = keybuf;
			key.size = keylen;

#if DB_VERSION_MAJOR < 2
			i = (*up->udb_dbp->get)(up->udb_dbp, &key, &info, 0);
#else
			i = errno = (*up->udb_dbp->get)(up->udb_dbp, NULL,
							&key, &info, 0);
#endif
			if (i != 0 || info.size <= 0)
				break;
			a->q_owner = xalloc(info.size + 1);
			bcopy(info.data, a->q_owner, info.size);
			a->q_owner[info.size] = '\0';

			/* announce delivery; NORECEIPT bit set later */
			if (e->e_xfp != NULL)
			{
				fprintf(e->e_xfp,
					"Message delivered to mailing list %s\n",
					a->q_paddr);
			}
			e->e_flags |= EF_SENDRECEIPT;
			a->q_flags |= QDELIVERED|QEXPANDED;
			break;
#endif

#ifdef HESIOD
		  case UDB_HESIOD:
			key.data = keybuf;
			key.size = keylen;
			if (tTd(28, 80))
				printf("udbexpand: trying %s (%d) via hesiod\n",
					keybuf, keylen);
			/* look up the key via hesiod */
			i = hes_udb_get(&key, &info);
			if (i < 0)
			{
				syserr("udbexpand: hesiod-get %.*s stat %d",
					(int) key.size, (char *) key.data, i);
				return EX_TEMPFAIL;
			}
			else if (i > 0 || info.size <= 0)
			{
#if HES_GETMAILHOST
				struct hes_postoffice *hp;
#endif

				if (tTd(28, 2))
					printf("udbexpand: no match on %s (%d)\n",
						(char *) keybuf, (int) keylen);
#if HES_GETMAILHOST
				if (tTd(28, 8))
					printf("  ... trying hes_getmailhost(%s)\n",
						a->q_user);
				hp = hes_getmailhost(a->q_user);
				if (hp == NULL)
				{
					if (hes_error() == HES_ER_NET)
					{
						syserr("udbexpand: hesiod-getmail %s stat %d",
							a->q_user, hes_error());
						return EX_TEMPFAIL;
					}
					if (tTd(28, 2))
						printf("hes_getmailhost(%s): %d\n",
							a->q_user, hes_error());
					break;
				}
				if (strlen(hp->po_name) + strlen(hp->po_host) >
				    sizeof pobuf - 2)
				{
					if (tTd(28, 2))
						printf("hes_getmailhost(%s): expansion too long: %.30s@@%.30s\n",
							a->q_user,
							hp->po_name,
							hp->po_host);
					break;
				}
				info.data = pobuf;
				snprintf(pobuf, sizeof pobuf, "%s@@%s",
					hp->po_name, hp->po_host);
				info.size = strlen(info.data);
#else
				break;
#endif
			}
			if (tTd(28, 80))
				printf("udbexpand: match %.*s: %.*s\n",
					(int) key.size, (char *) key.data,
					(int) info.size, (char *) info.data);
			a->q_flags &= ~QSELFREF;

			if (bitset(EF_VRFYONLY, e->e_flags))
			{
				a->q_flags |= QVERIFIED;
				return EX_OK;
			}

			breakout = TRUE;
			if (info.size >= usersize)
				user = xalloc(info.size + 1);
			bcopy(info.data, user, info.size);
			user[info.size] = '\0';

			message("hesioded to %s", user);
			if (LogLevel >= 10)
				sm_syslog(LOG_INFO, e->e_id,
					"hesiod %.100s => %s",
					e->e_to,
					shortenstring(user, MAXSHORTSTR));
			naddrs = sendtolist(user, a, sendq, aliaslevel + 1, e);

			if (naddrs > 0 && !bitset(QSELFREF, a->q_flags))
			{
				if (tTd(28, 5))
				{
					printf("udbexpand: QDONTSEND ");
					printaddr(a, FALSE);
				}
				a->q_flags |= QDONTSEND;
			}

			/*
			**  If this address has a -request address, reflect
			**  it into the envelope.
			*/

			(void) strcpy(keybuf, a->q_user);
			(void) strcat(keybuf, ":mailsender");
			keylen = strlen(keybuf);
			key.data = keybuf;
			key.size = keylen;
			i = hes_udb_get(&key, &info);
			if (i != 0 || info.size <= 0)
				break;
			a->q_owner = xalloc(info.size + 1);
			bcopy(info.data, a->q_owner, info.size);
			a->q_owner[info.size] = '\0';
			break;
#endif /* HESIOD */

		  case UDB_REMOTE:
			/* not yet implemented */
			break;

		  case UDB_FORWARD:
			if (bitset(EF_VRFYONLY, e->e_flags))
				return EX_OK;
			i = strlen(up->udb_fwdhost) + strlen(a->q_user) + 1;
			if (i >= usersize)
			{
				usersize = i + 1;
				user = xalloc(usersize);
			}
			(void) snprintf(user, usersize, "%s@@%s",
				a->q_user, up->udb_fwdhost);
			message("expanded to %s", user);
			a->q_flags &= ~QSELFREF;
			naddrs = sendtolist(user, a, sendq, aliaslevel + 1, e);
			if (naddrs > 0 && !bitset(QSELFREF, a->q_flags))
			{
				if (tTd(28, 5))
				{
					printf("udbexpand: QDONTSEND ");
					printaddr(a, FALSE);
				}
				a->q_flags |= QDONTSEND;
			}
			breakout = TRUE;
			break;

		  case UDB_EOLIST:
			breakout = TRUE;
			break;

		  default:
			/* unknown entry type */
			break;
		}
		if (user != userbuf)
			free(user);
	}
	return EX_OK;
}
/*
**  UDBSENDER -- return canonical external name of sender, given local name
**
**	Parameters:
**		sender -- the name of the sender on the local machine.
**
**	Returns:
**		The external name for this sender, if derivable from the
**			database.
**		NULL -- if nothing is changed from the database.
**
**	Side Effects:
**		none.
*/

char *
udbsender(sender)
	char *sender;
{
	extern char *udbmatch __P((char *, char *));

	return udbmatch(sender, "mailname");
}


char *
udbmatch(user, field)
	char *user;
	char *field;
{
	register char *p;
	register struct udbent *up;
	int i;
	int keylen;
	DBT key, info;
	char keybuf[MAXKEY];

	if (tTd(28, 1))
		printf("udbmatch(%s, %s)\n", user, field);

	if (!UdbInitialized)
	{
		if (_udbx_init(CurEnv) == EX_TEMPFAIL)
			return NULL;
	}

	/* short circuit if no spec */
	if (UdbSpec == NULL || UdbSpec[0] == '\0')
		return NULL;

	/* short circuit name begins with '\\' since it can't possibly match */
	if (user[0] == '\\')
		return NULL;

	/* long names can never match and are a pain to deal with */
	i = strlen(field);
	if (i < sizeof "maildrop")
		i = sizeof "maildrop";
	if ((strlen(user) + i) > sizeof keybuf - 4)
		return NULL;

	/* names beginning with colons indicate metadata */
	if (user[0] == ':')
		return NULL;

	/* build database key */
	(void) strcpy(keybuf, user);
	(void) strcat(keybuf, ":");
	(void) strcat(keybuf, field);
	keylen = strlen(keybuf);

	for (up = UdbEnts; up->udb_type != UDB_EOLIST; up++)
	{
		/*
		**  Select action based on entry type.
		*/

		switch (up->udb_type)
		{
#ifdef NEWDB
		  case UDB_DBFETCH:
			bzero(&key, sizeof key);
			bzero(&info, sizeof info);
			key.data = keybuf;
			key.size = keylen;
#if DB_VERSION_MAJOR < 2
			i = (*up->udb_dbp->get)(up->udb_dbp, &key, &info, 0);
#else
			i = errno = (*up->udb_dbp->get)(up->udb_dbp, NULL,
							&key, &info, 0);
#endif
			if (i != 0 || info.size <= 0)
			{
				if (tTd(28, 2))
					printf("udbmatch: no match on %s (%d) via db\n",
							keybuf, keylen);
				continue;
			}

			p = xalloc(info.size + 1);
			bcopy(info.data, p, info.size);
			p[info.size] = '\0';
			if (tTd(28, 1))
				printf("udbmatch ==> %s\n", p);
			return p;
#endif

#ifdef HESIOD
		  case UDB_HESIOD:
			key.data = keybuf;
			key.size = keylen;
			i = hes_udb_get(&key, &info); 
			if (i != 0 || info.size <= 0)
			{
				if (tTd(28, 2))
					printf("udbmatch: no match on %s (%d) via hesiod\n",
							keybuf, keylen);
				continue;
			}

			p = xalloc(info.size + 1);
			bcopy(info.data, p, info.size);
			p[info.size] = '\0';
			if (tTd(28, 1))
				printf("udbmatch ==> %s\n", p);
			return p;
#endif /* HESIOD */
		}
	}

	if (strcmp(field, "mailname") != 0)
		return NULL;

	/*
	**  Nothing yet.  Search again for a default case.  But only
	**  use it if we also have a forward (:maildrop) pointer already
	**  in the database.
	*/

	/* build database key */
	(void) strcpy(keybuf, user);
	(void) strcat(keybuf, ":maildrop");
	keylen = strlen(keybuf);

	for (up = UdbEnts; up->udb_type != UDB_EOLIST; up++)
	{
		switch (up->udb_type)
		{
#ifdef NEWDB
		  case UDB_DBFETCH:
			/* get the default case for this database */
			if (up->udb_default == NULL)
			{
				bzero(&key, sizeof key);
				bzero(&info, sizeof info);
				key.data = ":default:mailname";
				key.size = strlen(key.data);
#if DB_VERSION_MAJOR < 2
				i = (*up->udb_dbp->get)(up->udb_dbp,
							&key, &info, 0);
#else
				i = errno = (*up->udb_dbp->get)(up->udb_dbp,
								NULL, &key,
								&info, 0);
#endif
				if (i != 0 || info.size <= 0)
				{
					/* no default case */
					up->udb_default = "";
					continue;
				}

				/* save the default case */
				up->udb_default = xalloc(info.size + 1);
				bcopy(info.data, up->udb_default, info.size);
				up->udb_default[info.size] = '\0';
			}
			else if (up->udb_default[0] == '\0')
				continue;

			/* we have a default case -- verify user:maildrop */
			bzero(&key, sizeof key);
			bzero(&info, sizeof info);
			key.data = keybuf;
			key.size = keylen;
#if DB_VERSION_MAJOR < 2
			i = (*up->udb_dbp->get)(up->udb_dbp, &key, &info, 0);
#else
			i = errno = (*up->udb_dbp->get)(up->udb_dbp, NULL,
							&key, &info, 0);
#endif
			if (i != 0 || info.size <= 0)
			{
				/* nope -- no aliasing for this user */
				continue;
			}

			/* they exist -- build the actual address */
			p = xalloc(strlen(user) + strlen(up->udb_default) + 2);
			(void) strcpy(p, user);
			(void) strcat(p, "@@");
			(void) strcat(p, up->udb_default);
			if (tTd(28, 1))
				printf("udbmatch ==> %s\n", p);
			return p;
#endif

#ifdef HESIOD
		  case UDB_HESIOD:
			/* get the default case for this database */
			if (up->udb_default == NULL)
			{
				key.data = ":default:mailname";
				key.size = strlen(key.data);
				i = hes_udb_get(&key, &info); 

				if (i != 0 || info.size <= 0)
				{
					/* no default case */
					up->udb_default = "";
					continue;
				}

				/* save the default case */
				up->udb_default = xalloc(info.size + 1);
				bcopy(info.data, up->udb_default, info.size);
				up->udb_default[info.size] = '\0';
			}
			else if (up->udb_default[0] == '\0')
				continue;

			/* we have a default case -- verify user:maildrop */
			key.data = keybuf;
			key.size = keylen;
			i = hes_udb_get(&key, &info);
			if (i != 0 || info.size <= 0)
			{
				/* nope -- no aliasing for this user */
				continue;
			}

			/* they exist -- build the actual address */
			p = xalloc(strlen(user) + strlen(up->udb_default) + 2);
			(void) strcpy(p, user);
			(void) strcat(p, "@@");
			(void) strcat(p, up->udb_default);
			if (tTd(28, 1))
				printf("udbmatch ==> %s\n", p);
			return p;
			break;
#endif /* HESIOD */
		}
	}

	/* still nothing....  too bad */
	return NULL;
}
/*
**  UDB_MAP_LOOKUP -- look up arbitrary entry in user database map
**
**	Parameters:
**		map -- the map being queried.
**		name -- the name to look up.
**		av -- arguments to the map lookup.
**		statp -- to get any error status.
**
**	Returns:
**		NULL if name not found in map.
**		The rewritten name otherwise.
*/

/* ARGSUSED3 */
char *
udb_map_lookup(map, name, av, statp)
	MAP *map;
	char *name;
	char **av;
	int *statp;
{
	char *val;
	char *key;
	char keybuf[MAXNAME + 1];

	if (tTd(28, 20) || tTd(38, 20))
		printf("udb_map_lookup(%s, %s)\n", map->map_mname, name);

	if (bitset(MF_NOFOLDCASE, map->map_mflags))
	{
		key = name;
	}
	else
	{
		int keysize = strlen(name);

		if (keysize > sizeof keybuf - 1)
			keysize = sizeof keybuf - 1;
		bcopy(name, keybuf, keysize);
		keybuf[keysize] = '\0';
		makelower(keybuf);
		key = keybuf;
	}
	val = udbmatch(key, map->map_file);
	if (val == NULL)
		return NULL;
	if (bitset(MF_MATCHONLY, map->map_mflags))
		return map_rewrite(map, name, strlen(name), NULL);
	else
		return map_rewrite(map, val, strlen(val), av);
}
/*
**  _UDBX_INIT -- parse the UDB specification, opening any valid entries.
**
**	Parameters:
**		e -- the current envelope.
**
**	Returns:
**		EX_TEMPFAIL -- if it appeared it couldn't get hold of a
**			database due to a host being down or some similar
**			(recoverable) situation.
**		EX_OK -- otherwise.
**
**	Side Effects:
**		Fills in the UdbEnts structure from UdbSpec.
*/

#define MAXUDBOPTS	27

int
_udbx_init(e)
	ENVELOPE *e;
{
	int ents = 0;
	register char *p;
	register struct udbent *up;

	if (UdbInitialized)
		return EX_OK;

# ifdef UDB_DEFAULT_SPEC
	if (UdbSpec == NULL)
		UdbSpec = UDB_DEFAULT_SPEC;
# endif

	p = UdbSpec;
	up = UdbEnts;
	while (p != NULL)
	{
		char *spec;
		int l;
# if 0
		auto int rcode;
		int nmx;
		int i;
		register struct hostent *h;
		char *mxhosts[MAXMXHOSTS + 1];
# endif
		struct udb_option opts[MAXUDBOPTS + 1];
		extern int _udb_parsespec __P((char *, struct udb_option [], int));

		while (*p == ' ' || *p == '\t' || *p == ',')
			p++;
		if (*p == '\0')
			break;
		spec = p;
		p = strchr(p, ',');
		if (p != NULL)
			*p++ = '\0';

		if (ents >= MAXUDBENT)
		{
			syserr("Maximum number of UDB entries exceeded");
			break;
		}

		/* extract options */
		(void) _udb_parsespec(spec, opts, MAXUDBOPTS);

		/*
		**  Decode database specification.
		**
		**	In the sendmail tradition, the leading character
		**	defines the semantics of the rest of the entry.
		**
		**	+hostname --	send a datagram to the udb server
		**			on host "hostname" asking for the
		**			home mail server for this user.
		**	*hostname --	similar to +hostname, except that the
		**			hostname is searched as an MX record;
		**			resulting hosts are searched as for
		**			+mxhostname.  If no MX host is found,
		**			this is the same as +hostname.
		**	@@hostname --	forward email to the indicated host.
		**			This should be the last in the list,
		**			since it always matches the input.
		**	/dbname	 --	search the named database on the local
		**			host using the Berkeley db package.
		**	Hesiod --	search the named database with BIND
		**			using the MIT Hesiod package.
		*/

		switch (*spec)
		{
#if 0
		  case '+':	/* search remote database */
		  case '*':	/* search remote database (expand MX) */
			if (*spec == '*')
			{
#if NAMED_BIND
				nmx = getmxrr(spec + 1, mxhosts, FALSE, &rcode);
#else
				mxhosts[0] = spec + 1;
				nmx = 1;
				rcode = 0;
#endif
				if (tTd(28, 16))
				{
					int i;

					printf("getmxrr(%s): %d", spec + 1, nmx);
					for (i = 0; i <= nmx; i++)
						printf(" %s", mxhosts[i]);
					printf("\n");
				}
			}
			else
			{
				nmx = 1;
				mxhosts[0] = spec + 1;
			}

			for (i = 0; i < nmx; i++)
			{
				h = sm_gethostbyname(mxhosts[i]);
				if (h == NULL)
					continue;
				up->udb_type = UDB_REMOTE;
				up->udb_pid = getpid();
				up->udb_addr.sin_family = h->h_addrtype;
				bcopy(h->h_addr_list[0],
				      (char *) &up->udb_addr.sin_addr,
				      INADDRSZ);
				up->udb_addr.sin_port = UdbPort;
				up->udb_timeout = UdbTimeout;
				ents++;
				up++;
			}

			/* set up a datagram socket */
			if (UdbSock < 0)
			{
				UdbSock = socket(AF_INET, SOCK_DGRAM, 0);
				(void) fcntl(UdbSock, F_SETFD, 1);
			}
			break;
#endif

		  case '@@':	/* forward to remote host */
			up->udb_type = UDB_FORWARD;
			up->udb_pid = getpid();
			up->udb_fwdhost = spec + 1;
			ents++;
			up++;
			break;

#ifdef HESIOD
		  case 'h':	/* use hesiod */
		  case 'H':
			if (strcasecmp(spec, "hesiod") != 0)
				goto badspec;
			up->udb_type = UDB_HESIOD;
			up->udb_pid = getpid();
			ents++;
			up++;
			break;
#endif /* HESIOD */

#ifdef NEWDB
		  case '/':	/* look up remote name */
			l = strlen(spec);
			if (l > 3 && strcmp(&spec[l - 3], ".db") == 0)
			{
				up->udb_dbname = spec;
			}
			else
			{
				up->udb_dbname = xalloc(l + 4);
				strcpy(up->udb_dbname, spec);
				strcat(up->udb_dbname, ".db");
			}
			errno = 0;
#if DB_VERSION_MAJOR < 2
			up->udb_dbp = dbopen(up->udb_dbname, O_RDONLY,
					     0644, DB_BTREE, NULL);
#else
			up->udb_dbp = NULL;
			errno = db_open(up->udb_dbname, DB_BTREE, DB_RDONLY,
					0644, NULL, NULL, &up->udb_dbp);
#endif
			if (up->udb_dbp == NULL)
			{
				if (tTd(28, 1))
				{
					int saveerrno = errno;

#if DB_VERSION_MAJOR < 2
					printf("dbopen(%s): %s\n",
#else
					printf("db_open(%s): %s\n",
#endif
						up->udb_dbname,
						errstring(errno));
					errno = saveerrno;
				}
				if (errno != ENOENT && errno != EACCES)
				{
					if (LogLevel > 2)
						sm_syslog(LOG_ERR, e->e_id,
#if DB_VERSION_MAJOR < 2
							"dbopen(%s): %s",
#else
							"db_open(%s): %s",
#endif
							up->udb_dbname,
							errstring(errno));
					up->udb_type = UDB_EOLIST;
					if (up->udb_dbname != spec)
						free(up->udb_dbname);
					goto tempfail;
				}
				if (up->udb_dbname != spec)
					free(up->udb_dbname);
				break;
			}
			if (tTd(28, 1))
			{
#if DB_VERSION_MAJOR < 2
				printf("_udbx_init: dbopen(%s)\n",
#else
				printf("_udbx_init: db_open(%s)\n",
#endif
					up->udb_dbname);
			}
			up->udb_type = UDB_DBFETCH;
			up->udb_pid = getpid();
			ents++;
			up++;
			break;
#endif

		  default:
badspec:
			syserr("Unknown UDB spec %s", spec);
			break;
		}
	}
	up->udb_type = UDB_EOLIST;

	if (tTd(28, 4))
	{
		for (up = UdbEnts; up->udb_type != UDB_EOLIST; up++)
		{
			switch (up->udb_type)
			{
#if DAEMON
			  case UDB_REMOTE:
				printf("REMOTE: addr %s, timeo %d\n",
					anynet_ntoa((SOCKADDR *) &up->udb_addr),
					up->udb_timeout);
				break;
#endif

			  case UDB_DBFETCH:
#ifdef NEWDB
				printf("FETCH: file %s\n",
					up->udb_dbname);
#else
				printf("FETCH\n");
#endif
				break;

			  case UDB_FORWARD:
				printf("FORWARD: host %s\n",
					up->udb_fwdhost);
				break;

			  case UDB_HESIOD:
				printf("HESIOD\n");
				break;

			  default:
				printf("UNKNOWN\n");
				break;
			}
		}
	}

	UdbInitialized = TRUE;
	errno = 0;
	return EX_OK;

	/*
	**  On temporary failure, back out anything we've already done
	*/

  tempfail:
#ifdef NEWDB
	for (up = UdbEnts; up->udb_type != UDB_EOLIST; up++)
	{
		if (up->udb_type == UDB_DBFETCH)
		{
#if DB_VERSION_MAJOR < 2
			(*up->udb_dbp->close)(up->udb_dbp);
#else
			errno = (*up->udb_dbp->close)(up->udb_dbp, 0);
#endif
			if (tTd(28, 1))
			{
				printf("_udbx_init: db->close(%s)\n",
					up->udb_dbname);
			}
		}
	}
#endif
	return EX_TEMPFAIL;
}

int
_udb_parsespec(udbspec, opt, maxopts)
	char *udbspec;
	struct udb_option opt[];
	int maxopts;
{
	register char *spec;
	register char *spec_end;
	register int optnum;

	spec_end = strchr(udbspec, ':');
	for (optnum = 0; optnum < maxopts && (spec = spec_end) != NULL; optnum++)
	{
		register char *p;

		while (isascii(*spec) && isspace(*spec))
			spec++;
		spec_end = strchr(spec, ':');
		if (spec_end != NULL)
			*spec_end++ = '\0';

		opt[optnum].name = spec;
		opt[optnum].val = NULL;
		p = strchr(spec, '=');
		if (p != NULL)
			opt[optnum].val = ++p;
	}
	return optnum;
}
/*
**  _UDBX_CLOSE -- close all file based UDB entries.
**
**	Parameters:
**		none
**
**	Returns:
**		none
*/
void
_udbx_close()
{
	pid_t pid;
	struct udbent *up;

	if (!UdbInitialized)
		return;

	pid = getpid();

	for (up = UdbEnts; up->udb_type != UDB_EOLIST; up++)
	{
		if (up->udb_pid != pid)
			continue;
		
#ifdef NEWDB
		if (up->udb_type == UDB_DBFETCH)
		{
#if DB_VERSION_MAJOR < 2
			(*up->udb_dbp->close)(up->udb_dbp);
#else
			errno = (*up->udb_dbp->close)(up->udb_dbp, 0);
#endif
		}
		if (tTd(28, 1))
		{
			printf("_udbx_init: db->close(%s)\n",
				up->udb_dbname);
		}
#endif
	}
}

#ifdef HESIOD

int
hes_udb_get(key, info)
	DBT *key;
	DBT *info;
{
	char *name, *type;
	char **hp;
	char kbuf[MAXKEY + 1];

	if (strlen(key->data) >= (SIZE_T) sizeof kbuf)
		return 0;
	strcpy(kbuf, key->data);
	name = kbuf;
	type = strrchr(name, ':');
	if (type == NULL)
		return 1;
	*type++ = '\0';
	if (strchr(name, '@@') != NULL)
		return 1;

	if (tTd(28, 1))
		printf("hes_udb_get(%s, %s)\n", name, type);

	/* make the hesiod query */
#ifdef HESIOD_INIT
	if (HesiodContext == NULL && hesiod_init(&HesiodContext) != 0)
		return -1;
	hp = hesiod_resolve(HesiodContext, name, type);
#else
	hp = hes_resolve(name, type);
#endif /* HESIOD_INIT */
	*--type = ':';
#ifdef HESIOD_INIT
	if (hp == NULL)
		return 1;
	if (*hp == NULL)
	{
		hesiod_free_list(HesiodContext, hp);
		if (errno == ECONNREFUSED || errno == EMSGSIZE)
			return -1;
		return 1;
	}
#else
	if (hp == NULL || hp[0] == NULL)
	{
		/* network problem or timeout */
		if (hes_error() == HES_ER_NET)
			return -1;

		return 1;
	}
#endif /* HESIOD_INIT */
	else
	{
		/*
		**  If there are multiple matches, just return the
		**  first one.
		**
		**  XXX These should really be returned; for example,
		**  XXX it is legal for :maildrop to be multi-valued.
		*/

		info->data = hp[0];
		info->size = (size_t) strlen(info->data);
	}

	if (tTd(28, 80))
		printf("hes_udb_get => %s\n", *hp);

	return 0;
}
#endif /* HESIOD */

#else /* not USERDB */

int
udbexpand(a, sendq, aliaslevel, e)
	ADDRESS *a;
	ADDRESS **sendq;
	int aliaslevel;
	ENVELOPE *e;
{
	return EX_OK;
}

#endif /* USERDB */
@


1.9
log
@sendmail 8.9.3
@
text
@@


1.8
log
@sendmail 8.9.2
@
text
@d17 1
a17 1
static char sccsid [] = "@@(#)udb.c	8.70 (Berkeley) 12/21/1998 (with USERDB)";
d19 1
a19 1
static char sccsid [] = "@@(#)udb.c	8.70 (Berkeley) 12/21/1998 (without USERDB)";
a1166 3
#if DB_VERSION_MAJOR < 2
				printf("_udbx_init: db->close(%s)\n",
#else
a1167 1
#endif
a1240 3
#if DB_VERSION_MAJOR < 2
			printf("_udbx_init: db->close(%s)\n",
#else
a1241 1
#endif
@


1.7
log
@something hosed the sendmail import; fix up by hand
@
text
@d17 1
a17 1
static char sccsid [] = "@@(#)udb.c	8.66 (Berkeley) 6/18/98 (with USERDB)";
d19 1
a19 1
static char sccsid [] = "@@(#)udb.c	8.66 (Berkeley) 6/18/98 (without USERDB)";
d52 1
d95 1
a95 1
struct option
d144 1
d169 3
d173 2
a174 1
	if (a->q_user[0] == '\\')
d178 1
a178 1
	if (strlen(a->q_user) > (SIZE_T) sizeof keybuf - 12)
d182 1
a182 1
	if (a->q_user[0] == ':')
d186 1
a186 1
	(void) strcpy(keybuf, a->q_user);
d231 4
d237 1
d906 2
a907 2
		struct option opts[MAXUDBOPTS + 1];
		extern int _udb_parsespec __P((char *, struct option [], int));
d986 1
d1008 1
d1020 1
d1083 9
d1093 1
d1165 9
d1183 1
a1183 1
	struct option opt[];
d1208 46
@


1.6
log
@Sendmail 8.8.6.
@
text
@d2 2
a3 1
 * Copyright (c) 1983, 1995-1997 Eric P. Allman
d7 3
a9 15
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
a10 11
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
d17 1
a17 1
static char sccsid [] = "@@(#)udb.c	8.51 (Berkeley) 5/29/97 (with USERDB)";
d19 1
a19 1
static char sccsid [] = "@@(#)udb.c	8.51 (Berkeley) 5/29/97 (without USERDB)";
d29 3
a40 4
#ifdef HESIOD
# include <hesiod.h>
#endif /* HESIOD */

d100 3
d145 3
d194 3
d220 1
d222 11
d238 7
d261 7
d299 1
d301 13
d315 1
d326 1
a326 1
					shortenstring(user, 203));
d340 1
a340 1
					key.size, key.data, i);
d349 2
d356 2
d359 4
d393 1
a393 1
					key.size, key.data, i);
d404 1
a404 1
						keybuf, keylen);
d443 2
a444 1
					key.size, key.data, info.size, info.data);
d464 1
a464 1
					shortenstring(user, 203));
d558 1
a558 1
	extern char *udbmatch();
d620 2
d624 1
d626 4
a643 1
			break;
d692 2
d696 8
a703 1
				i = (*up->udb_dbp->get)(up->udb_dbp, &key, &info, 0);
d720 2
d724 1
d726 4
a743 1
			break;
d810 1
d870 1
a886 1
		int nopts;
d907 6
d914 1
a914 1
		nopts = _udb_parsespec(spec, opts, MAXUDBOPTS);
d981 1
d997 1
d1007 1
d1026 1
d1029 5
d1040 1
d1042 3
d1053 1
d1055 3
d1070 1
d1136 1
d1138 3
d1185 1
a1185 1
	char *p, **hp;
d1203 5
d1209 1
d1211 11
d1230 1
@


1.5
log
@Sendmail 8.8.5.
@
text
@d2 1
a2 1
 * Copyright (c) 1983, 1995, 1996 Eric P. Allman
d39 1
a39 1
static char sccsid [] = "@@(#)udb.c	8.47 (Berkeley) 12/6/96 (with USERDB)";
d41 1
a41 1
static char sccsid [] = "@@(#)udb.c	8.47 (Berkeley) 12/6/96 (without USERDB)";
d123 1
a123 1
extern int _udbx_init __P((void));
d176 1
a176 1
		if (_udbx_init() == EX_TEMPFAIL)
d262 6
a267 1
					char *nuser = xalloc(usersize + MEMCHUNKSIZE);
d273 2
a274 2
					usersize += MEMCHUNKSIZE;
					userleft += MEMCHUNKSIZE;
a294 1
#ifdef LOG
d296 3
a298 2
				syslog(LOG_INFO, "%s: expand %.100s => %s",
					e->e_id, e->e_to,
a299 1
#endif
a423 1
#ifdef LOG
d425 3
a427 2
				syslog(LOG_INFO, "%s: hesiod %.100s => %s",
					e->e_id, e->e_to,
a428 1
#endif
d545 1
a545 1
		if (_udbx_init() == EX_TEMPFAIL)
d558 4
a561 1
	if ((strlen(user) + strlen(field)) > sizeof keybuf - 4)
d794 1
a794 1
**		none.
d809 2
a810 1
_udbx_init()
d967 1
a967 1
					printf("dbopen(%s): %s",
a973 1
#ifdef LOG
d975 2
a976 1
						syslog(LOG_ERR, "dbopen(%s): %s",
a978 1
#endif
@


1.4
log
@Update to Sendmail 8.8.4, plus recent patches, plus OpenBSD support.
Also include entire example configuration subset.
Includes smrsh (using /usr/libexec/sm.bin).

Of the top of my head, the only things I removed from the distribution were
contrib/mail.local.linux, src/Makefiles, all the *.0 and *.ps files.
Our praliases man page replaces the distributed one, ours is better.
@
text
@d39 1
a39 1
static char sccsid [] = "@@(#)udb.c	8.46 (Berkeley) 12/1/96 (with USERDB)";
d41 1
a41 1
static char sccsid [] = "@@(#)udb.c	8.46 (Berkeley) 12/1/96 (without USERDB)";
d278 1
a278 1
				user[info.size] = '\0';
@


1.3
log
@bring up to 8.7.6
@
text
@d2 1
a2 1
 * Copyright (c) 1983, 1995 Eric P. Allman
d39 1
a39 1
static char sccsid [] = "@@(#)udb.c	8.33.1.2 (Berkeley) 9/16/96 (with USERDB)";
d41 1
a41 1
static char sccsid [] = "@@(#)udb.c	8.33.1.2 (Berkeley) 9/16/96 (without USERDB)";
d122 2
a163 1
	char buf[BUFSIZ];
a175 2
		extern int _udbx_init();

d189 1
a189 1
	if (strlen(a->q_user) > sizeof keybuf - 12)
d205 11
d240 1
a240 1
				continue;
d244 2
a245 1
					key.size, key.data, info.size, info.data);
a246 1
			naddrs = 0;
d251 2
d260 18
a277 5
				if (info.size < sizeof buf)
					user = buf;
				else
					user = xalloc(info.size + 1);
				bcopy(info.data, user, info.size);
d279 1
a279 12

				message("expanded to %s", user);
#ifdef LOG
				if (LogLevel >= 10)
					syslog(LOG_INFO, "%s: expand %.100s => %s",
						e->e_id, e->e_to,
						shortenstring(user, 203));
#endif
				naddrs += sendtolist(user, a, sendq, aliaslevel + 1, e);

				if (user != buf)
					free(user);
d287 1
a287 1
				continue;
d289 8
d382 11
a392 1
					continue;
d394 1
d399 1
a399 1
				continue;
d414 1
a414 3
			if (info.size < sizeof buf)
				user = buf;
			else
a427 3
			if (user != buf)
				free(user);

d459 1
a459 1
			continue;
d465 6
a470 5
			if (i < sizeof buf)
				user = buf;
			else
				user = xalloc(i + 1);
			(void) snprintf(user, i, "%s@@%s",
a483 2
			if (user != buf)
				free(user);
d489 1
a489 1
			continue;
d493 1
a493 1
			continue;
d495 2
d822 1
d831 1
d940 11
a950 1
			up->udb_dbname = spec;
d952 2
a953 1
			up->udb_dbp = dbopen(spec, O_RDONLY, 0644, DB_BTREE, NULL);
d961 2
a962 1
						spec, errstring(errno));
d970 2
a971 1
							spec, errstring(errno));
d974 2
d978 2
d1001 1
a1001 1
#ifdef DAEMON
@


1.2
log
@Sendmail 8.7.3 from NetBSD
@
text
@d39 1
a39 1
static char sccsid [] = "@@(#)udb.c	8.33 (Berkeley) 11/29/95 (with USERDB)";
d41 1
a41 1
static char sccsid [] = "@@(#)udb.c	8.33 (Berkeley) 11/29/95 (without USERDB)";
d362 1
a362 1
				sprintf(info.data, "%s@@%s",
d441 2
a442 1
			(void) sprintf(user, "%s@@%s", a->q_user, up->udb_fwdhost);
d1048 2
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
 * Copyright (c) 1983 Eric P. Allman
d38 2
a39 2
#ifdef USERDB
static char sccsid [] = "@@(#)udb.c	8.8 (Berkeley) 4/14/94 (with USERDB)";
d41 1
a41 1
static char sccsid [] = "@@(#)udb.c	8.8 (Berkeley) 4/14/94 (without USERDB)";
d45 1
a45 1
#ifdef USERDB
d48 11
a58 2
#include <netdb.h>
#include <db.h>
d61 1
a61 1
#include <hesiod.h>
d94 1
d103 1
d128 2
d148 1
a148 1
udbexpand(a, sendq, e)
d151 1
a154 1
	register char *p;
d217 1
a243 1
					e->e_nrcpts++;
d258 3
a260 2
					syslog(LOG_INFO, "%s: expand %s => %s",
						e->e_id, e->e_to, user);
d262 1
a262 3
				AliasLevel++;
				naddrs += sendtolist(user, a, sendq, e);
				AliasLevel--;
a313 1
				e->e_flags |= EF_SENDRECEIPT;
d315 2
d318 1
d329 7
a335 1
			if (i > 0 || info.size <= 0)
d337 4
d342 24
a365 2
				printf("udbexpand: no match on %s (%d)\n",
					keybuf, keylen);
d367 1
a376 2
				e->e_nrcpts++;
				free(info.data);
a386 1
			free(info.data);
d391 3
a393 2
				syslog(LOG_INFO, "%s: hesiod %s => %s",
					e->e_id, e->e_to, user);
d395 1
a395 3
			AliasLevel++;
			naddrs = sendtolist(user, a, sendq, e);
			AliasLevel--;
a408 6
			if (i < 0)
			{
				syserr("udbexpand: hesiod-get %.*s stat %d",
					key.size, key.data, i);
				return EX_TEMPFAIL;
			}
a425 1
			free(info.data);
d444 1
a444 3
			AliasLevel++;
			naddrs = sendtolist(user, a, sendq, e);
			AliasLevel--;
d546 1
d566 1
a583 1
			free(info.data);
a586 1
			break;
d609 1
d651 1
a672 1
				free(info.data);
a686 1
			free(info.data);
d704 51
a775 1
	int i;
a776 1
	char buf[BUFSIZ];
d791 2
a793 1
		int nopts;
d795 1
d798 1
d832 2
d838 1
d868 1
a868 1
				h = gethostbyname(mxhosts[i]);
d875 1
a875 1
				      sizeof up->udb_addr.sin_addr);
d888 1
d896 1
a898 1
#ifdef HESIOD
d900 1
a900 1
				break;
d903 1
a904 1
			break;
d906 1
d913 8
d936 6
d952 1
d958 1
d961 1
d964 3
d994 1
d1002 1
d1045 1
d1047 3
a1049 2
	name = key->data;
	type = strchr(name, ':');
a1051 1

d1053 2
d1061 2
a1062 1
	if (hp == NULL)
d1074 1
a1074 1
		**  first one and free the others.
a1079 3
		for (p = hp[1]; p; p++)
			free(p);

d1084 3
d1094 1
a1094 1
udbexpand(a, sendq, e)
d1097 1
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@


1.1.1.2
log
@sendmail 8.9.1
@
text
@d2 1
a2 2
 * Copyright (c) 1998 Sendmail, Inc.  All rights reserved.
 * Copyright (c) 1983, 1995-1997 Eric P. Allman.  All rights reserved.
d6 15
a20 3
 * By using this file, you agree to the terms and conditions set
 * forth in the LICENSE file which can be found at the top level of
 * the sendmail distribution.
d22 11
d38 2
a39 2
#if USERDB
static char sccsid [] = "@@(#)udb.c	8.66 (Berkeley) 6/18/98 (with USERDB)";
d41 1
a41 1
static char sccsid [] = "@@(#)udb.c	8.66 (Berkeley) 6/18/98 (without USERDB)";
d45 1
a45 1
#if USERDB
d48 2
d51 3
a53 13
#ifdef NEWDB
# include <db.h>
# ifndef DB_VERSION_MAJOR
#  define DB_VERSION_MAJOR 1
# endif
#else
# define DBT	struct _data_base_thang_
DBT
{
	void	*data;		/* pointer to data */
	size_t	size;		/* length of data */
};
#endif
a84 1
#ifdef NEWDB
a92 1
#endif
a110 5

#ifdef HESIOD
extern int hes_udb_get __P((DBT *, DBT *));
#endif
extern int _udbx_init __P((ENVELOPE *));
a116 2
**		aliaslevel -- the current alias nesting depth.
**		e -- the current envelope.
d135 1
a135 1
udbexpand(a, sendq, aliaslevel, e)
a137 1
	int aliaslevel;
d141 1
d149 1
a149 3

	bzero(&key, sizeof key);
	bzero(&info, sizeof info);
d162 3
a164 1
		if (_udbx_init(e) == EX_TEMPFAIL)
d177 1
a177 1
	if (strlen(a->q_user) > (SIZE_T) sizeof keybuf - 12)
a192 14
		int usersize;
		int userleft;
		char userbuf[MEMCHUNKSIZE];
#if defined(HESIOD) && defined(HES_GETMAILHOST)
		char pobuf[MAXNAME];
#endif
#if defined(NEWDB) && DB_VERSION_MAJOR > 1
		DBC *dbc = NULL;
#endif

		user = userbuf;
		userbuf[0] = '\0';
		usersize = sizeof userbuf;
		userleft = sizeof userbuf - 1;
a203 1
#ifdef NEWDB
a209 1
#if DB_VERSION_MAJOR < 2
a210 11
#else
			i = 0;
			if (dbc == NULL &&
			    (errno = (*up->udb_dbp->cursor)(up->udb_dbp,
							    NULL, &dbc)) != 0)
				i = -1;
			if (i != 0 || dbc == NULL ||
			    (errno = dbc->c_get(dbc, &key,
						&info, DB_SET)) != 0)
				i = 1;
#endif
d216 1
a216 8
#if DB_VERSION_MAJOR > 1
				if (dbc != NULL) 
				{
					(void) dbc->c_close(dbc);
					dbc = NULL;
				}
#endif
				break;
d220 1
a220 2
					(int) key.size, (char *) key.data,
					(int) info.size, (char *) info.data);
d222 1
a226 2
				char *p;

d230 1
a230 7
#if DB_VERSION_MAJOR > 1
					if (dbc != NULL)
					{
						(void) dbc->c_close(dbc);
						dbc = NULL;
					}
#endif
d235 16
a250 4
				if (info.size >= userleft - 1)
				{
					char *nuser;
					int size = MEMCHUNKSIZE;
d252 2
a253 20
					if (info.size > MEMCHUNKSIZE)
						size = info.size;
					nuser = xalloc(usersize + size);

					bcopy(user, nuser, usersize);
					if (user != userbuf)
						free(user);
					user = nuser;
					usersize += size;
					userleft += size;
				}
				p = &user[strlen(user)];
				if (p != user)
				{
					*p++ = ',';
					userleft--;
				}
				bcopy(info.data, p, info.size);
				p[info.size] = '\0';
				userleft -= info.size;
a255 1
#if DB_VERSION_MAJOR < 2
a256 6
#else
				i = 0;
				if ((errno = dbc->c_get(dbc, &key,
							&info, DB_NEXT)) != 0)
					i = 1;
#endif
a258 8
#if DB_VERSION_MAJOR > 1
			if (dbc != NULL)
			{
				(void) dbc->c_close(dbc);
				dbc = NULL;
			}
#endif

d261 1
a261 1
				break;
a262 7
			message("expanded to %s", user);
			if (LogLevel >= 10)
				sm_syslog(LOG_INFO, e->e_id,
					"expand %.100s => %s",
					e->e_to,
					shortenstring(user, MAXSHORTSTR));
			naddrs = sendtolist(user, a, sendq, aliaslevel + 1, e);
d275 1
a275 1
					(int) key.size, (char *) key.data, i);
a283 2
			bzero(&key, sizeof key);
			bzero(&info, sizeof info);
a288 2

#if DB_VERSION_MAJOR < 2
a289 4
#else
			i = errno = (*up->udb_dbp->get)(up->udb_dbp, NULL,
							&key, &info, 0);
#endif
d302 1
a303 2
			e->e_flags |= EF_SENDRECEIPT;
			a->q_flags |= QDELIVERED|QEXPANDED;
a304 1
#endif
d315 1
a315 1
			if (i < 0)
a316 10
				syserr("udbexpand: hesiod-get %.*s stat %d",
					(int) key.size, (char *) key.data, i);
				return EX_TEMPFAIL;
			}
			else if (i > 0 || info.size <= 0)
			{
#if HES_GETMAILHOST
				struct hes_postoffice *hp;
#endif

d318 3
a320 37
					printf("udbexpand: no match on %s (%d)\n",
						(char *) keybuf, (int) keylen);
#if HES_GETMAILHOST
				if (tTd(28, 8))
					printf("  ... trying hes_getmailhost(%s)\n",
						a->q_user);
				hp = hes_getmailhost(a->q_user);
				if (hp == NULL)
				{
					if (hes_error() == HES_ER_NET)
					{
						syserr("udbexpand: hesiod-getmail %s stat %d",
							a->q_user, hes_error());
						return EX_TEMPFAIL;
					}
					if (tTd(28, 2))
						printf("hes_getmailhost(%s): %d\n",
							a->q_user, hes_error());
					break;
				}
				if (strlen(hp->po_name) + strlen(hp->po_host) >
				    sizeof pobuf - 2)
				{
					if (tTd(28, 2))
						printf("hes_getmailhost(%s): expansion too long: %.30s@@%.30s\n",
							a->q_user,
							hp->po_name,
							hp->po_host);
					break;
				}
				info.data = pobuf;
				snprintf(pobuf, sizeof pobuf, "%s@@%s",
					hp->po_name, hp->po_host);
				info.size = strlen(info.data);
#else
				break;
#endif
d324 1
a324 2
					(int) key.size, (char *) key.data,
					(int) info.size, (char *) info.data);
d330 2
d336 3
a338 1
			if (info.size >= usersize)
d342 1
d345 1
d347 9
a355 5
				sm_syslog(LOG_INFO, e->e_id,
					"hesiod %.100s => %s",
					e->e_to,
					shortenstring(user, MAXSHORTSTR));
			naddrs = sendtolist(user, a, sendq, aliaslevel + 1, e);
d366 6
d389 1
d395 1
a395 1
			break;
d401 5
a405 7
			if (i >= usersize)
			{
				usersize = i + 1;
				user = xalloc(usersize);
			}
			(void) snprintf(user, usersize, "%s@@%s",
				a->q_user, up->udb_fwdhost);
d408 3
a410 1
			naddrs = sendtolist(user, a, sendq, aliaslevel + 1, e);
d420 2
d427 1
a427 1
			break;
d431 1
a431 1
			break;
a432 2
		if (user != userbuf)
			free(user);
d455 1
a455 1
	extern char *udbmatch __P((char *, char *));
d478 1
a478 1
		if (_udbx_init(CurEnv) == EX_TEMPFAIL)
d491 1
a491 4
	i = strlen(field);
	if (i < sizeof "maildrop")
		i = sizeof "maildrop";
	if ((strlen(user) + i) > sizeof keybuf - 4)
a511 1
#ifdef NEWDB
a512 2
			bzero(&key, sizeof key);
			bzero(&info, sizeof info);
a514 1
#if DB_VERSION_MAJOR < 2
a515 4
#else
			i = errno = (*up->udb_dbp->get)(up->udb_dbp, NULL,
							&key, &info, 0);
#endif
d530 1
a530 1
#endif
d548 1
d552 1
a574 1
#ifdef NEWDB
a578 2
				bzero(&key, sizeof key);
				bzero(&info, sizeof info);
d581 1
a581 8
#if DB_VERSION_MAJOR < 2
				i = (*up->udb_dbp->get)(up->udb_dbp,
							&key, &info, 0);
#else
				i = errno = (*up->udb_dbp->get)(up->udb_dbp,
								NULL, &key,
								&info, 0);
#endif
a597 2
			bzero(&key, sizeof key);
			bzero(&info, sizeof info);
a599 1
#if DB_VERSION_MAJOR < 2
a600 4
#else
			i = errno = (*up->udb_dbp->get)(up->udb_dbp, NULL,
							&key, &info, 0);
#endif
d615 1
a615 1
#endif
d637 1
d652 1
a669 52
**  UDB_MAP_LOOKUP -- look up arbitrary entry in user database map
**
**	Parameters:
**		map -- the map being queried.
**		name -- the name to look up.
**		av -- arguments to the map lookup.
**		statp -- to get any error status.
**
**	Returns:
**		NULL if name not found in map.
**		The rewritten name otherwise.
*/

/* ARGSUSED3 */
char *
udb_map_lookup(map, name, av, statp)
	MAP *map;
	char *name;
	char **av;
	int *statp;
{
	char *val;
	char *key;
	char keybuf[MAXNAME + 1];

	if (tTd(28, 20) || tTd(38, 20))
		printf("udb_map_lookup(%s, %s)\n", map->map_mname, name);

	if (bitset(MF_NOFOLDCASE, map->map_mflags))
	{
		key = name;
	}
	else
	{
		int keysize = strlen(name);

		if (keysize > sizeof keybuf - 1)
			keysize = sizeof keybuf - 1;
		bcopy(name, keybuf, keysize);
		keybuf[keysize] = '\0';
		makelower(keybuf);
		key = keybuf;
	}
	val = udbmatch(key, map->map_file);
	if (val == NULL)
		return NULL;
	if (bitset(MF_MATCHONLY, map->map_mflags))
		return map_rewrite(map, name, strlen(name), NULL);
	else
		return map_rewrite(map, val, strlen(val), av);
}
/*
d673 1
a673 1
**		e -- the current envelope.
d688 1
a688 2
_udbx_init(e)
	ENVELOPE *e;
a689 1
	int ents = 0;
d691 1
d693 1
a707 2
		int l;
# if 0
d709 1
a710 1
		int i;
a712 1
# endif
a713 1
		extern int _udb_parsespec __P((char *, struct option [], int));
a723 6
		if (ents >= MAXUDBENT)
		{
			syserr("Maximum number of UDB entries exceeded");
			break;
		}

d725 1
a725 1
		(void) _udb_parsespec(spec, opts, MAXUDBOPTS);
a745 2
		**	Hesiod --	search the named database with BIND
		**			using the MIT Hesiod package.
a749 1
#if 0
d779 1
a779 1
				h = sm_gethostbyname(mxhosts[i]);
d786 1
a786 1
				      INADDRSZ);
a788 1
				ents++;
a798 1
#endif
a802 1
			ents++;
a805 1
#ifdef HESIOD
d808 1
d810 1
a810 1
				goto badspec;
a811 1
			ents++;
d813 1
a814 1
#endif /* HESIOD */
a815 1
#ifdef NEWDB
d817 1
a817 11
			l = strlen(spec);
			if (l > 3 && strcmp(&spec[l - 3], ".db") == 0)
			{
				up->udb_dbname = spec;
			}
			else
			{
				up->udb_dbname = xalloc(l + 4);
				strcpy(up->udb_dbname, spec);
				strcat(up->udb_dbname, ".db");
			}
d819 1
a819 8
#if DB_VERSION_MAJOR < 2
			up->udb_dbp = dbopen(up->udb_dbname, O_RDONLY,
					     0644, DB_BTREE, NULL);
#else
			up->udb_dbp = NULL;
			errno = db_open(up->udb_dbname, DB_BTREE, DB_RDONLY,
					0644, NULL, NULL, &up->udb_dbp);
#endif
a821 13
				if (tTd(28, 1))
				{
					int saveerrno = errno;

#if DB_VERSION_MAJOR < 2
					printf("dbopen(%s): %s\n",
#else
					printf("db_open(%s): %s\n",
#endif
						up->udb_dbname,
						errstring(errno));
					errno = saveerrno;
				}
d824 1
d826 2
a827 5
						sm_syslog(LOG_ERR, e->e_id,
#if DB_VERSION_MAJOR < 2
							"dbopen(%s): %s",
#else
							"db_open(%s): %s",
a828 2
							up->udb_dbname,
							errstring(errno));
a829 2
					if (up->udb_dbname != spec)
						free(up->udb_dbname);
a831 2
				if (up->udb_dbname != spec)
					free(up->udb_dbname);
a834 1
			ents++;
a836 6
#endif

		  default:
badspec:
			syserr("Unknown UDB spec %s", spec);
			break;
a846 1
#if DAEMON
a851 1
#endif
a853 1
#ifdef NEWDB
a855 3
#else
				printf("FETCH\n");
#endif
a882 1
#ifdef NEWDB
a886 1
#if DB_VERSION_MAJOR < 2
a887 3
#else
			errno = (*up->udb_dbp->close)(up->udb_dbp, 0);
#endif
a889 1
#endif
d931 1
a931 2
	char **hp;
	char kbuf[MAXKEY + 1];
d933 2
a934 5
	if (strlen(key->data) >= (SIZE_T) sizeof kbuf)
		return 0;
	strcpy(kbuf, key->data);
	name = kbuf;
	type = strrchr(name, ':');
d937 1
a938 2
	if (strchr(name, '@@') != NULL)
		return 1;
a943 5
#ifdef HESIOD_INIT
	if (HesiodContext == NULL && hesiod_init(&HesiodContext) != 0)
		return -1;
	hp = hesiod_resolve(HesiodContext, name, type);
#else
a944 3
#endif /* HESIOD_INIT */
	*--type = ':';
#ifdef HESIOD_INIT
a945 10
		return 1;
	if (*hp == NULL)
	{
		hesiod_free_list(HesiodContext, hp);
		if (errno == ECONNREFUSED || errno == EMSGSIZE)
			return -1;
		return 1;
	}
#else
	if (hp == NULL || hp[0] == NULL)
a952 1
#endif /* HESIOD_INIT */
d957 1
a957 1
		**  first one.
d963 3
a969 3
	if (tTd(28, 80))
		printf("hes_udb_get => %s\n", *hp);

d977 1
a977 1
udbexpand(a, sendq, aliaslevel, e)
a979 1
	int aliaslevel;
@

