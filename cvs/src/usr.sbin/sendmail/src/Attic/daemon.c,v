head	1.15;
access;
symbols
	OPENBSD_2_6:1.14.0.4
	OPENBSD_2_6_BASE:1.14
	OPENBSD_2_5:1.14.0.2
	OPENBSD_2_5_BASE:1.14
	OPENBSD_2_4:1.10.0.2
	OPENBSD_2_4_BASE:1.10
	sendmail_8_9_1:1.1.1.2
	UCB:1.1.1
	OPENBSD_2_3:1.9.0.2
	OPENBSD_2_3_BASE:1.9
	OPENBSD_2_2:1.8.0.2
	OPENBSD_2_2_BASE:1.8
	OPENBSD_2_1:1.6.0.2
	OPENBSD_2_1_BASE:1.6
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.15
date	2000.04.18.04.57.19;	author millert;	state dead;
branches;
next	1.14;

1.14
date	99.02.05.05.59.26;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	99.01.01.20.33.43;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	98.11.03.20.16.00;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	98.10.31.06.36.50;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	98.07.12.19.44.33;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	97.11.09.04.05.38;	author gene;	state Exp;
branches;
next	1.8;

1.8
date	97.08.04.02.17.49;	author downsj;	state Exp;
branches;
next	1.7;

1.7
date	97.07.15.07.24.02;	author downsj;	state Exp;
branches;
next	1.6;

1.6
date	97.02.05.20.57.39;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	97.01.22.01.07.06;	author downsj;	state Exp;
branches;
next	1.4;

1.4
date	96.12.14.21.17.12;	author downsj;	state Exp;
branches;
next	1.3;

1.3
date	96.09.19.06.44.54;	author fn;	state Exp;
branches;
next	1.2;

1.2
date	96.01.29.01.43.42;	author dm;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.48.17;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.48.17;	author deraadt;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	98.07.12.17.10.00;	author millert;	state Exp;
branches;
next	;


desc
@@


1.15
log
@remove sendmail 8.9.3
@
text
@/*
 * Copyright (c) 1998 Sendmail, Inc.  All rights reserved.
 * Copyright (c) 1983, 1995-1997 Eric P. Allman.  All rights reserved.
 * Copyright (c) 1988, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * By using this file, you agree to the terms and conditions set
 * forth in the LICENSE file which can be found at the top level of
 * the sendmail distribution.
 *
 */

#include <errno.h>
#include "sendmail.h"

#ifndef lint
#ifdef DAEMON
static char sccsid[] = "@@(#)daemon.c	8.236 (Berkeley) 1/25/1999 (with daemon mode)";
#else
static char sccsid[] = "@@(#)daemon.c	8.236 (Berkeley) 1/25/1999 (without daemon mode)";
#endif
#endif /* not lint */

#if defined(SOCK_STREAM) || defined(__GNU_LIBRARY__)
# define USE_SOCK_STREAM	1
#endif

#if DAEMON || defined(USE_SOCK_STREAM)
# include <arpa/inet.h>
# if NAMED_BIND
#  include <resolv.h>
#  ifndef NO_DATA
#   define NO_DATA	NO_ADDRESS
#  endif
# endif
#endif

#if DAEMON

# include <sys/time.h>

# if IP_SRCROUTE
#  include <netinet/in_systm.h>
#  include <netinet/ip.h>
#  include <netinet/ip_var.h>
# endif

/*
**  DAEMON.C -- routines to use when running as a daemon.
**
**	This entire file is highly dependent on the 4.2 BSD
**	interprocess communication primitives.  No attempt has
**	been made to make this file portable to Version 7,
**	Version 6, MPX files, etc.  If you should try such a
**	thing yourself, I recommend chucking the entire file
**	and starting from scratch.  Basic semantics are:
**
**	getrequests(e)
**		Opens a port and initiates a connection.
**		Returns in a child.  Must set InChannel and
**		OutChannel appropriately.
**	clrdaemon()
**		Close any open files associated with getting
**		the connection; this is used when running the queue,
**		etc., to avoid having extra file descriptors during
**		the queue run and to avoid confusing the network
**		code (if it cares).
**	makeconnection(host, port, outfile, infile, e)
**		Make a connection to the named host on the given
**		port.  Set *outfile and *infile to the files
**		appropriate for communication.  Returns zero on
**		success, else an exit status describing the
**		error.
**	host_map_lookup(map, hbuf, avp, pstat)
**		Convert the entry in hbuf into a canonical form.
*/
/*
**  GETREQUESTS -- open mail IPC port and get requests.
**
**	Parameters:
**		e -- the current envelope.
**
**	Returns:
**		none.
**
**	Side Effects:
**		Waits until some interesting activity occurs.  When
**		it does, a child is created to process it, and the
**		parent waits for completion.  Return from this
**		routine is always in the child.  The file pointers
**		"InChannel" and "OutChannel" should be set to point
**		to the communication channel.
*/

int		DaemonSocket	= -1;		/* fd describing socket */
SOCKADDR	DaemonAddr;			/* socket for incoming */
int		ListenQueueSize = 10;		/* size of listen queue */
int		TcpRcvBufferSize = 0;		/* size of TCP receive buffer */
int		TcpSndBufferSize = 0;		/* size of TCP send buffer */

void
getrequests(e)
	ENVELOPE *e;
{
	int t;
	time_t refuse_connections_until = 0;
	bool firsttime = TRUE;
	FILE *pidf;
	int sff;
	int socksize;
	u_short port;
#if XDEBUG
	bool j_has_dot;
#endif
	char status[MAXLINE];
	extern void reapchild __P((int));
#ifdef NETUNIX
	extern int ControlSocket;
#endif
	extern int opendaemonsocket __P((bool));
	extern int opencontrolsocket __P((void));

	/*
	**  Set up the address for the mailer.
	*/

	switch (DaemonAddr.sa.sa_family)
	{
	  case AF_UNSPEC:
		DaemonAddr.sa.sa_family = AF_INET;
		/* fall through ... */

	  case AF_INET:
		if (DaemonAddr.sin.sin_addr.s_addr == 0)
			DaemonAddr.sin.sin_addr.s_addr = INADDR_ANY;
		port = DaemonAddr.sin.sin_port;
		break;

	  default:
		/* unknown protocol */
		port = 0;
		break;
	}
	if (port == 0)
	{
		register struct servent *sp;

		sp = getservbyname("smtp", "tcp");
		if (sp == NULL)
		{
			syserr("554 service \"smtp\" unknown");
			port = htons(25);
		}
		else
			port = sp->s_port;
	}

	switch (DaemonAddr.sa.sa_family)
	{
	  case AF_INET:
		DaemonAddr.sin.sin_port = port;
		break;

	  default:
		/* unknown protocol */
		break;
	}

	/*
	**  Try to actually open the connection.
	*/

	if (tTd(15, 1))
		printf("getrequests: port 0x%x\n", port);

	/* get a socket for the SMTP connection */
	socksize = opendaemonsocket(TRUE);

	if (opencontrolsocket() < 0)
		sm_syslog(LOG_WARNING, NOQID,
			  "daemon could not open control socket %s: %s",
			  ControlSocketName, errstring(errno));

	(void) setsignal(SIGCHLD, reapchild);

	/* write the pid to the log file for posterity */
	sff = SFF_NOLINK|SFF_ROOTOK|SFF_REGONLY|SFF_CREAT;
	if (TrustedUid != 0 && RealUid == TrustedUid)
		sff |= SFF_OPENASROOT;
	pidf = safefopen(PidFile, O_WRONLY|O_TRUNC, 0644, sff);
	if (pidf == NULL)
	{
		sm_syslog(LOG_ERR, NOQID, "unable to write %s", PidFile);
	}
	else
	{
		extern char *CommandLineArgs;

		/* write the process id on line 1 */
		fprintf(pidf, "%ld\n", (long) getpid());

		/* line 2 contains all command line flags */
		fprintf(pidf, "%s\n", CommandLineArgs);

		/* flush and close */
		fclose(pidf);
	}

#if XDEBUG
	{
		char jbuf[MAXHOSTNAMELEN];

		expand("\201j", jbuf, sizeof jbuf, e);
		j_has_dot = strchr(jbuf, '.') != NULL;
	}
#endif

	/* Add parent process as first item */
	proc_list_add(getpid(), "Sendmail daemon");

	if (tTd(15, 1))
		printf("getrequests: %d\n", DaemonSocket);

	for (;;)
	{
		register pid_t pid;
		auto SOCKADDR_LEN_T lotherend;
		bool timedout = FALSE;
		bool control = FALSE;
		int savederrno;
		int pipefd[2];
		extern bool refuseconnections __P((int));

		/* see if we are rejecting connections */
		(void) blocksignal(SIGALRM);
		if (curtime() >= refuse_connections_until)
		{
			if (refuseconnections(ntohs(port)))
			{
				if (DaemonSocket >= 0)
				{
				       /* close socket so peer fails quickly */
				       (void) close(DaemonSocket);
				       DaemonSocket = -1;
				}

				/* refuse connections for next 15 seconds */
				refuse_connections_until = curtime() + 15;
			}
			else if (DaemonSocket < 0 || firsttime)
			{
			      /* arrange to (re)open the socket if needed */
			      (void) opendaemonsocket(FALSE);
			      firsttime = FALSE;
			}
		}

#if XDEBUG
		/* check for disaster */
		{
			char jbuf[MAXHOSTNAMELEN];
			extern void dumpstate __P((char *));

			expand("\201j", jbuf, sizeof jbuf, e);
			if (!wordinclass(jbuf, 'w'))
			{
				dumpstate("daemon lost $j");
				sm_syslog(LOG_ALERT, NOQID,
					"daemon process doesn't have $j in $=w; see syslog");
				abort();
			}
			else if (j_has_dot && strchr(jbuf, '.') == NULL)
			{
				dumpstate("daemon $j lost dot");
				sm_syslog(LOG_ALERT, NOQID,
					"daemon process $j lost dot; see syslog");
				abort();
			}
		}
#endif

#if 0
		/*
		**  Andrew Sun <asun@@ieps-sun.ml.com> claims that this will
		**  fix the SVr4 problem.  But it seems to have gone away,
		**  so is it worth doing this?
		*/

		if (DaemonSocket >= 0 &&
		    SetNonBlocking(DaemonSocket, FALSE) < 0)
			log an error here;
#endif
		(void) releasesignal(SIGALRM);
		for (;;)
		{
			int highest = -1;
			fd_set readfds;
			struct timeval timeout;

			FD_ZERO(&readfds);

			/* wait for a connection */
			if (DaemonSocket >= 0)
			{
				sm_setproctitle(TRUE,
						"accepting connections on port %d",
						ntohs(port));
				if (DaemonSocket > highest)
					highest = DaemonSocket;
				FD_SET(DaemonSocket, &readfds);
			}
#ifdef NETUNIX
			if (ControlSocket >= 0)
			{
				if (ControlSocket > highest)
					highest = ControlSocket;
				FD_SET(ControlSocket, &readfds);
			}
#endif
			if (DaemonSocket >= 0)
				timeout.tv_sec = 60;
			else
				timeout.tv_sec = 5;
			timeout.tv_usec = 0;

			t = select(highest + 1, FDSET_CAST &readfds,
			   	   NULL, NULL, &timeout);

			if (DoQueueRun)
				(void) runqueue(TRUE, FALSE);
			if (t <= 0)
			{
				timedout = TRUE;
				break;
			}

			control = FALSE;
			errno = 0;
			if (DaemonSocket >= 0 &&
			    FD_ISSET(DaemonSocket, &readfds))
			{
				lotherend = socksize;
				t = accept(DaemonSocket,
					   (struct sockaddr *)&RealHostAddr,
					   &lotherend);
			}
#ifdef NETUNIX
			else if (ControlSocket >= 0 &&
				 FD_ISSET(ControlSocket, &readfds))
			{
				struct sockaddr_un sa_un;

				lotherend = sizeof sa_un;
				t = accept(ControlSocket,
					   (struct sockaddr *)&sa_un,
					   &lotherend);
				control = TRUE;
			}
#endif
			if (t >= 0 || errno != EINTR)
				break;
		}
		if (timedout)
		{
			timedout = FALSE;
			continue;
		}
		if (control)
		{
			if (t >= 0)
			{
				extern void control_command __P((int, ENVELOPE *));

				control_command(t, e);
			}
			else
				syserr("getrequests: control accept");
			continue;
		}
		savederrno = errno;
		(void) blocksignal(SIGALRM);
		if (t < 0)
		{
			errno = savederrno;
			syserr("getrequests: accept");

			/* arrange to re-open the socket next time around */
			(void) close(DaemonSocket);
			DaemonSocket = -1;
			continue;
		}

		/*
		**  Create a subprocess to process the mail.
		*/

		if (tTd(15, 2))
			printf("getrequests: forking (fd = %d)\n", t);

		/*
		**  Create a pipe to keep the child from writing to the
		**  socket until after the parent has closed it.  Otherwise
		**  the parent may hang if the child has closed it first.
		*/

		if (pipe(pipefd) < 0)
			pipefd[0] = pipefd[1] = -1;

		blocksignal(SIGCHLD);
		pid = fork();
		if (pid < 0)
		{
			syserr("daemon: cannot fork");
			if (pipefd[0] != -1)
			{
				(void) close(pipefd[0]);
				(void) close(pipefd[1]);
			}
			(void) releasesignal(SIGCHLD);
			sleep(10);
			(void) close(t);
			continue;
		}

		if (pid == 0)
		{
			char *p;
			extern SIGFUNC_DECL intsig __P((int));
			FILE *inchannel, *outchannel;

			/*
			**  CHILD -- return to caller.
			**	Collect verified idea of sending host.
			**	Verify calling user id if possible here.
			*/

			(void) releasesignal(SIGALRM);
			(void) releasesignal(SIGCHLD);
			(void) setsignal(SIGCHLD, SIG_DFL);
			(void) setsignal(SIGHUP, intsig);
			(void) close(DaemonSocket);
			clrcontrol();
			proc_list_clear();

			/* Add parent process as first child item */
			proc_list_add(getpid(), "daemon child");

			/* don't schedule queue runs if we are told to ETRN */
			QueueIntvl = 0;

			sm_setproctitle(TRUE, "startup with %s",
				anynet_ntoa(&RealHostAddr));

			if (pipefd[0] != -1)
			{
				auto char c;

				/*
				**  Wait for the parent to close the write end
				**  of the pipe, which we will see as an EOF.
				**  This guarantees that we won't write to the
				**  socket until after the parent has closed
				**  the pipe.
				*/

				/* close the write end of the pipe */
				(void) close(pipefd[1]);

				/* we shouldn't be interrupted, but ... */
				while (read(pipefd[0], &c, 1) < 0 &&
				       errno == EINTR)
					continue;
				(void) close(pipefd[0]);
			}

			/* determine host name */
			p = hostnamebyanyaddr(&RealHostAddr);
			if (strlen(p) > (SIZE_T) MAXNAME)
				p[MAXNAME] = '\0';
			RealHostName = newstr(p);
			sm_setproctitle(TRUE, "startup with %s", p);

			if ((inchannel = fdopen(t, "r")) == NULL ||
			    (t = dup(t)) < 0 ||
			    (outchannel = fdopen(t, "w")) == NULL)
			{
				syserr("cannot open SMTP server channel, fd=%d", t);
				finis(FALSE, EX_OK);
			}

			InChannel = inchannel;
			OutChannel = outchannel;
			DisConnected = FALSE;

#ifdef XLA
			if (!xla_host_ok(RealHostName))
			{
				message("421 Too many SMTP sessions for this host");
				finis(FALSE, EX_OK);
			}
#endif
			break;
		}

		/* parent -- keep track of children */
		snprintf(status, sizeof status, "SMTP server child for %s",
			 anynet_ntoa(&RealHostAddr));
		proc_list_add(pid, status);
		(void) releasesignal(SIGCHLD);

		/* close the read end of the synchronization pipe */
		if (pipefd[0] != -1)
			(void) close(pipefd[0]);

		/* close the port so that others will hang (for a while) */
		(void) close(t);

		/* release the child by closing the read end of the sync pipe */
		if (pipefd[1] != -1)
			(void) close(pipefd[1]);
	}
	if (tTd(15, 2))
		printf("getreq: returning\n");
	return;
}
/*
**  OPENDAEMONSOCKET -- open the SMTP socket
**
**	Deals with setting all appropriate options.  DaemonAddr must
**	be set up in advance.
**
**	Parameters:
**		firsttime -- set if this is the initial open.
**
**	Returns:
**		Size in bytes of the daemon socket addr.
**
**	Side Effects:
**		Leaves DaemonSocket set to the open socket.
**		Exits if the socket cannot be created.
*/

#define MAXOPENTRIES	10	/* maximum number of tries to open connection */

int
opendaemonsocket(firsttime)
	bool firsttime;
{
	int on = 1;
	int socksize = 0;
	int ntries = 0;
	int saveerrno;

	if (tTd(15, 2))
		printf("opendaemonsocket()\n");

	do
	{
		if (ntries > 0)
			sleep(5);
		if (firsttime || DaemonSocket < 0)
		{
			DaemonSocket = socket(DaemonAddr.sa.sa_family, SOCK_STREAM, 0);
			if (DaemonSocket < 0)
			{
				saveerrno = errno;
				syserr("opendaemonsocket: can't create server SMTP socket");
			  severe:
				if (LogLevel > 0)
					sm_syslog(LOG_ALERT, NOQID,
						"problem creating SMTP socket");
				DaemonSocket = -1;
				continue;
			}

			/* turn on network debugging? */
			if (tTd(15, 101))
				(void) setsockopt(DaemonSocket, SOL_SOCKET,
						  SO_DEBUG, (char *)&on,
						  sizeof on);

			(void) setsockopt(DaemonSocket, SOL_SOCKET,
					  SO_REUSEADDR, (char *)&on, sizeof on);
			(void) setsockopt(DaemonSocket, SOL_SOCKET,
					  SO_KEEPALIVE, (char *)&on, sizeof on);

#ifdef SO_RCVBUF
			if (TcpRcvBufferSize > 0)
			{
				if (setsockopt(DaemonSocket, SOL_SOCKET,
					       SO_RCVBUF,
					       (char *) &TcpRcvBufferSize,
					       sizeof(TcpRcvBufferSize)) < 0)
					syserr("opendaemonsocket: setsockopt(SO_RCVBUF)");
			}
#endif

			switch (DaemonAddr.sa.sa_family)
			{
# if NETINET
			  case AF_INET:
				socksize = sizeof DaemonAddr.sin;
				break;
# endif

# if NETISO
			  case AF_ISO:
				socksize = sizeof DaemonAddr.siso;
				break;
# endif

			  default:
				socksize = sizeof DaemonAddr;
				break;
			}

			if (bind(DaemonSocket, &DaemonAddr.sa, socksize) < 0)
			{
				/* probably another daemon already */
				saveerrno = errno;
				syserr("opendaemonsocket: cannot bind");
				(void) close(DaemonSocket);
				goto severe;
			}
		}
		if (!firsttime && listen(DaemonSocket, ListenQueueSize) < 0)
		{
			saveerrno = errno;
			syserr("opendaemonsocket: cannot listen");
			(void) close(DaemonSocket);
			goto severe;
		}
		return socksize;
	} while (ntries++ < MAXOPENTRIES && transienterror(saveerrno));
	syserr("!opendaemonsocket: server SMTP socket wedged: exiting");
	/*NOTREACHED*/
	return -1;  /* avoid compiler warning on IRIX */
}
/*
**  CLRDAEMON -- reset the daemon connection
**
**	Parameters:
**		none.
**
**	Returns:
**		none.
**
**	Side Effects:
**		releases any resources used by the passive daemon.
*/

void
clrdaemon()
{
	if (DaemonSocket >= 0)
		(void) close(DaemonSocket);
	DaemonSocket = -1;
}
/*
**  SETDAEMONOPTIONS -- set options for running the daemon
**
**	Parameters:
**		p -- the options line.
**
**	Returns:
**		none.
*/

void
setdaemonoptions(p)
	register char *p;
{
	if (DaemonAddr.sa.sa_family == AF_UNSPEC)
		DaemonAddr.sa.sa_family = AF_INET;

	while (p != NULL)
	{
		register char *f;
		register char *v;

		while (isascii(*p) && isspace(*p))
			p++;
		if (*p == '\0')
			break;
		f = p;
		p = strchr(p, ',');
		if (p != NULL)
			*p++ = '\0';
		v = strchr(f, '=');
		if (v == NULL)
			continue;
		while (isascii(*++v) && isspace(*v))
			continue;
		if (isascii(*f) && islower(*f))
			*f = toupper(*f);

		switch (*f)
		{
		  case 'F':		/* address family */
			if (isascii(*v) && isdigit(*v))
				DaemonAddr.sa.sa_family = atoi(v);
#if NETINET
			else if (strcasecmp(v, "inet") == 0)
				DaemonAddr.sa.sa_family = AF_INET;
#endif
#if NETISO
			else if (strcasecmp(v, "iso") == 0)
				DaemonAddr.sa.sa_family = AF_ISO;
#endif
#if NETNS
			else if (strcasecmp(v, "ns") == 0)
				DaemonAddr.sa.sa_family = AF_NS;
#endif
#if NETX25
			else if (strcasecmp(v, "x.25") == 0)
				DaemonAddr.sa.sa_family = AF_CCITT;
#endif
			else
				syserr("554 Unknown address family %s in Family=option", v);
			break;

		  case 'A':		/* address */
			switch (DaemonAddr.sa.sa_family)
			{
#if NETINET
			  case AF_INET:
				if (isascii(*v) && isdigit(*v))
					DaemonAddr.sin.sin_addr.s_addr = inet_addr(v);
				else
				{
					register struct hostent *hp;

					hp = sm_gethostbyname(v);
					if (hp == NULL)
						syserr("554 host \"%s\" unknown", v);
					else
						bcopy(hp->h_addr, &DaemonAddr.sin.sin_addr, INADDRSZ);
				}
				break;
#endif

			  default:
				syserr("554 Address= option unsupported for family %d",
					DaemonAddr.sa.sa_family);
				break;
			}
			break;

		  case 'P':		/* port */
			switch (DaemonAddr.sa.sa_family)
			{
#if NETISO
				short port;
#endif

#if NETINET
			  case AF_INET:
				if (isascii(*v) && isdigit(*v))
					DaemonAddr.sin.sin_port = htons(atoi(v));
				else
				{
					register struct servent *sp;

					sp = getservbyname(v, "tcp");
					if (sp == NULL)
						syserr("554 service \"%s\" unknown", v);
					else
						DaemonAddr.sin.sin_port = sp->s_port;
				}
				break;
#endif

#if NETISO
			  case AF_ISO:
				/* assume two byte transport selector */
				if (isascii(*v) && isdigit(*v))
					port = htons(atoi(v));
				else
				{
					register struct servent *sp;

					sp = getservbyname(v, "tcp");
					if (sp == NULL)
						syserr("554 service \"%s\" unknown", v);
					else
						port = sp->s_port;
				}
				bcopy((char *) &port, TSEL(&DaemonAddr.siso), 2);
				break;
#endif

			  default:
				syserr("554 Port= option unsupported for family %d",
					DaemonAddr.sa.sa_family);
				break;
			}
			break;

		  case 'L':		/* listen queue size */
			ListenQueueSize = atoi(v);
			break;

		  case 'S':		/* send buffer size */
			TcpSndBufferSize = atoi(v);
			break;

		  case 'R':		/* receive buffer size */
			TcpRcvBufferSize = atoi(v);
			break;

		  default:
			syserr("554 DaemonPortOptions parameter \"%s\" unknown", f);
		}
	}
}
/*
**  MAKECONNECTION -- make a connection to an SMTP socket on another machine.
**
**	Parameters:
**		host -- the name of the host.
**		port -- the port number to connect to.
**		mci -- a pointer to the mail connection information
**			structure to be filled in.
**		e -- the current envelope.
**
**	Returns:
**		An exit code telling whether the connection could be
**			made and if not why not.
**
**	Side Effects:
**		none.
*/

static jmp_buf	CtxConnectTimeout;

static void
connecttimeout()
{
	errno = ETIMEDOUT;
	longjmp(CtxConnectTimeout, 1);
}

SOCKADDR	CurHostAddr;		/* address of current host */

int
makeconnection(host, port, mci, e)
	char *host;
	u_short port;
	register MCI *mci;
	ENVELOPE *e;
{
	register volatile int addrno = 0;
	register volatile int s;
	register struct hostent *volatile hp = (struct hostent *)NULL;
	SOCKADDR addr;
	int sav_errno;
	volatile int addrlen;
	volatile bool firstconnect;
	EVENT *volatile ev = NULL;

	/*
	**  Set up the address for the mailer.
	**	Accept "[a.b.c.d]" syntax for host name.
	*/

#if NAMED_BIND
	h_errno = 0;
#endif
	errno = 0;
	bzero(&CurHostAddr, sizeof CurHostAddr);
	SmtpPhase = mci->mci_phase = "initial connection";
	CurHostName = host;

	if (host[0] == '[')
	{
#if NETINET
		unsigned long hid = INADDR_NONE;
#endif
		register char *p = strchr(host, ']');

		if (p != NULL)
		{
			*p = '\0';
#if NETINET
			hid = inet_addr(&host[1]);
			if (hid == INADDR_NONE)
#endif
			{
				/* try it as a host name (avoid MX lookup) */
				hp = sm_gethostbyname(&host[1]);
				if (hp == NULL && p[-1] == '.')
				{
#if NAMED_BIND
					int oldopts = _res.options;

					_res.options &= ~(RES_DEFNAMES|RES_DNSRCH);
#endif
					p[-1] = '\0';
					hp = sm_gethostbyname(&host[1]);
					p[-1] = '.';
#if NAMED_BIND
					_res.options = oldopts;
#endif
				}
				*p = ']';
				goto gothostent;
			}
			*p = ']';
		}
		if (p == NULL)
		{
			extern char MsgBuf[];

			usrerr("553 Invalid numeric domain spec \"%s\"", host);
			mci_setstat(mci, EX_NOHOST, "5.1.2", MsgBuf);
			return EX_NOHOST;
		}
#if NETINET
		addr.sin.sin_family = AF_INET;		/*XXX*/
		addr.sin.sin_addr.s_addr = hid;
#endif
	}
	else
	{
		/* contortion to get around SGI cc complaints */
		{
			register char *p = &host[strlen(host) - 1];

			hp = sm_gethostbyname(host);
			if (hp == NULL && *p == '.')
			{
#if NAMED_BIND
				int oldopts = _res.options;

				_res.options &= ~(RES_DEFNAMES|RES_DNSRCH);
#endif
				*p = '\0';
				hp = sm_gethostbyname(host);
				*p = '.';
#if NAMED_BIND
				_res.options = oldopts;
#endif
			}
		}
gothostent:
		if (hp == NULL)
		{
#if NAMED_BIND
			/* check for name server timeouts */
			if (errno == ETIMEDOUT || h_errno == TRY_AGAIN ||
			    (errno == ECONNREFUSED && UseNameServer))
			{
				mci_setstat(mci, EX_TEMPFAIL, "4.4.3", NULL);
				return EX_TEMPFAIL;
			}
#endif
			mci_setstat(mci, EX_NOHOST, "5.1.2", NULL);
			return (EX_NOHOST);
		}
		addr.sa.sa_family = hp->h_addrtype;
		switch (hp->h_addrtype)
		{
#if NETINET
		  case AF_INET:
			bcopy(hp->h_addr,
				&addr.sin.sin_addr,
				INADDRSZ);
			break;
#endif

		  default:
			if (hp->h_length > sizeof addr.sa.sa_data)
			{
				syserr("makeconnection: long sa_data: family %d len %d",
					hp->h_addrtype, hp->h_length);
				mci_setstat(mci, EX_NOHOST, "5.1.2", NULL);
				return EX_NOHOST;
			}
			bcopy(hp->h_addr,
				addr.sa.sa_data,
				hp->h_length);
			break;
		}
		addrno = 1;
	}

	/*
	**  Determine the port number.
	*/

	if (port == 0)
	{
		register struct servent *sp = getservbyname("smtp", "tcp");

		if (sp == NULL)
		{
			if (LogLevel > 2)
				sm_syslog(LOG_ERR, NOQID,
					"makeconnection: service \"smtp\" unknown");
			port = htons(25);
		}
		else
			port = sp->s_port;
	}

	switch (addr.sa.sa_family)
	{
#if NETINET
	  case AF_INET:
		addr.sin.sin_port = port;
		addrlen = sizeof (struct sockaddr_in);
		break;
#endif

#if NETISO
	  case AF_ISO:
		/* assume two byte transport selector */
		bcopy((char *) &port, TSEL((struct sockaddr_iso *) &addr), 2);
		addrlen = sizeof (struct sockaddr_iso);
		break;
#endif

	  default:
		syserr("Can't connect to address family %d", addr.sa.sa_family);
		mci_setstat(mci, EX_NOHOST, "5.1.2", NULL);
		return (EX_NOHOST);
	}

	/*
	**  Try to actually open the connection.
	*/

#ifdef XLA
	/* if too many connections, don't bother trying */
	if (!xla_noqueue_ok(host))
		return EX_TEMPFAIL;
#endif

	firstconnect = TRUE;
	for (;;)
	{
		if (tTd(16, 1))
			printf("makeconnection (%s [%s])\n",
				host, anynet_ntoa(&addr));

		/* save for logging */
		CurHostAddr = addr;

		if (bitnset(M_SECURE_PORT, mci->mci_mailer->m_flags))
		{
			int rport = IPPORT_RESERVED - 1;

			s = rresvport(&rport);
		}
		else
		{
			s = socket(addr.sa.sa_family, SOCK_STREAM, 0);
		}
		if (s < 0)
		{
			sav_errno = errno;
			syserr("makeconnection: cannot create socket");
#ifdef XLA
			xla_host_end(host);
#endif
			mci_setstat(mci, EX_TEMPFAIL, "4.4.5", NULL);
			return EX_TEMPFAIL;
		}

#ifdef SO_SNDBUF
		if (TcpSndBufferSize > 0)
		{
			if (setsockopt(s, SOL_SOCKET, SO_SNDBUF,
				       (char *) &TcpSndBufferSize,
				       sizeof(TcpSndBufferSize)) < 0)
				syserr("makeconnection: setsockopt(SO_SNDBUF)");
		}
#endif

		if (tTd(16, 1))
			printf("makeconnection: fd=%d\n", s);

		/* turn on network debugging? */
		if (tTd(16, 101))
		{
			int on = 1;
			(void) setsockopt(s, SOL_SOCKET, SO_DEBUG,
					  (char *)&on, sizeof on);
		}
		if (e->e_xfp != NULL)
			(void) fflush(e->e_xfp);		/* for debugging */
		errno = 0;					/* for debugging */

		/*
		**  Linux seems to hang in connect for 90 minutes (!!!).
		**  Time out the connect to avoid this problem.
		*/

		if (setjmp(CtxConnectTimeout) == 0)
		{
			int i;

			if (e->e_ntries <= 0 && TimeOuts.to_iconnect != 0)
				ev = setevent(TimeOuts.to_iconnect, connecttimeout, 0);
			else if (TimeOuts.to_connect != 0)
				ev = setevent(TimeOuts.to_connect, connecttimeout, 0);
			else
				ev = NULL;

#if _FFR_CONNECTONLYTO_OPTION
			/* for testing */
			if (ConnectOnlyTo != 0)
				addr.sin.sin_addr.s_addr = ConnectOnlyTo;
#endif
			i = connect(s, (struct sockaddr *) &addr, addrlen);
			sav_errno = errno;
			if (ev != NULL)
				clrevent(ev);
			if (i >= 0)
				break;
		}
		else
			sav_errno = errno;

		/* if running demand-dialed connection, try again */
		if (DialDelay > 0 && firstconnect)
		{
			if (tTd(16, 1))
				printf("Connect failed (%s); trying again...\n",
					errstring(sav_errno));
			firstconnect = FALSE;
			sleep(DialDelay);
			continue;
		}

		/* couldn't connect.... figure out why */
		(void) close(s);

		if (LogLevel >= 14)
			sm_syslog(LOG_INFO, e->e_id,
				  "makeconnection (%s [%s]) failed: %s",
				  host, anynet_ntoa(&addr),
				  errstring(sav_errno));

		if (hp != NULL && hp->h_addr_list[addrno] != NULL)
		{
			if (tTd(16, 1))
				printf("Connect failed (%s); trying new address....\n",
					errstring(sav_errno));
			switch (addr.sa.sa_family)
			{
#if NETINET
			  case AF_INET:
				bcopy(hp->h_addr_list[addrno++],
				      &addr.sin.sin_addr,
				      INADDRSZ);
				break;
#endif

			  default:
				bcopy(hp->h_addr_list[addrno++],
					addr.sa.sa_data,
					hp->h_length);
				break;
			}
			continue;
		}

		/* couldn't open connection */
#ifdef XLA
		xla_host_end(host);
#endif
		mci_setstat(mci, EX_TEMPFAIL, "4.4.1", NULL);
		return EX_TEMPFAIL;
	}

	/* connection ok, put it into canonical form */
	if ((mci->mci_out = fdopen(s, "w")) == NULL ||
	    (s = dup(s)) < 0 ||
	    (mci->mci_in = fdopen(s, "r")) == NULL)
	{
		syserr("cannot open SMTP client channel, fd=%d", s);
		mci_setstat(mci, EX_TEMPFAIL, "4.4.5", NULL);
		return EX_TEMPFAIL;
	}

	mci_setstat(mci, EX_OK, NULL, NULL);
	return (EX_OK);
}
/*
**  MYHOSTNAME -- return the name of this host.
**
**	Parameters:
**		hostbuf -- a place to return the name of this host.
**		size -- the size of hostbuf.
**
**	Returns:
**		A list of aliases for this host.
**
**	Side Effects:
**		Adds numeric codes to $=w.
*/

struct hostent *
myhostname(hostbuf, size)
	char hostbuf[];
	int size;
{
	register struct hostent *hp;

	if (gethostname(hostbuf, size) < 0)
	{
		(void) strcpy(hostbuf, "localhost");
	}
	hp = sm_gethostbyname(hostbuf);
	if (hp == NULL)
		return NULL;
	if (strchr(hp->h_name, '.') != NULL || strchr(hostbuf, '.') == NULL)
	{
		(void) strncpy(hostbuf, hp->h_name, size - 1);
		hostbuf[size - 1] = '\0';
	}

	/*
	**  If there is still no dot in the name, try looking for a
	**  dotted alias.
	*/

	if (strchr(hostbuf, '.') == NULL)
	{
		char **ha;

		for (ha = hp->h_aliases; *ha != NULL; ha++)
		{
			if (strchr(*ha, '.') != NULL)
			{
				(void) strncpy(hostbuf, *ha, size - 1);
				hostbuf[size - 1] = '\0';
				break;
			}
		}
	}

	/*
	**  If _still_ no dot, wait for a while and try again -- it is
	**  possible that some service is starting up.  This can result
	**  in excessive delays if the system is badly configured, but
	**  there really isn't a way around that, particularly given that
	**  the config file hasn't been read at this point.
	**  All in all, a bit of a mess.
	*/

	if (strchr(hostbuf, '.') == NULL &&
	    !getcanonname(hostbuf, size, TRUE))
	{
		sm_syslog(LOG_CRIT, NOQID,
			"My unqualified host name (%s) unknown; sleeping for retry",
			hostbuf);
		message("My unqualified host name (%s) unknown; sleeping for retry",
			hostbuf);
		sleep(60);
		if (!getcanonname(hostbuf, size, TRUE))
		{
			sm_syslog(LOG_ALERT, NOQID,
				"unable to qualify my own domain name (%s) -- using short name",
				hostbuf);
			message("WARNING: unable to qualify my own domain name (%s) -- using short name",
				hostbuf);
		}
	}
	return (hp);
}
/*
**  ADDRCMP -- compare two host addresses
**
**	Parameters:
**		hp -- hostent structure for the first address
**		ha -- actual first address
**		sa -- second address
**
**	Returns:
**		0 -- if ha and sa match
**		else -- they don't match
*/

int
addrcmp(hp, ha, sa)
	struct hostent *hp;
	char *ha;
	SOCKADDR *sa;
{
	switch (sa->sa.sa_family)
	{
	  case AF_INET:
		if (hp->h_addrtype == AF_INET)
			return bcmp(ha, (char *) &sa->sin.sin_addr, hp->h_length);
		break;

	}
	return -1;
}
/*
**  GETAUTHINFO -- get the real host name asociated with a file descriptor
**
**	Uses RFC1413 protocol to try to get info from the other end.
**
**	Parameters:
**		fd -- the descriptor
**		may_be_forged -- an outage that is set to TRUE if the
**			forward lookup of RealHostName does not match
**			RealHostAddr; set to FALSE if they do match.
**
**	Returns:
**		The user@@host information associated with this descriptor.
*/

static jmp_buf	CtxAuthTimeout;

static void
authtimeout()
{
	longjmp(CtxAuthTimeout, 1);
}

char *
getauthinfo(fd, may_be_forged)
	int fd;
	bool *may_be_forged;
{
	SOCKADDR_LEN_T falen;
	register char *volatile p = NULL;
	SOCKADDR la;
	SOCKADDR_LEN_T lalen;
	register struct servent *sp;
	volatile int s;
	int i = 0;
	EVENT *ev;
	int nleft;
	struct hostent *hp;
	char *ostype = NULL;
	char **ha;
	char ibuf[MAXNAME + 1];
	static char hbuf[MAXNAME * 2 + 11];

	*may_be_forged = FALSE;
	falen = sizeof RealHostAddr;
	if (isatty(fd) || (i = getpeername(fd, &RealHostAddr.sa, &falen)) < 0 ||
	    falen <= 0 || RealHostAddr.sa.sa_family == 0)
	{
		if (i < 0 && errno != ENOTSOCK)
			return NULL;
		(void) snprintf(hbuf, sizeof hbuf, "%s@@localhost",
			RealUserName);
		if (tTd(9, 1))
			printf("getauthinfo: %s\n", hbuf);
		return hbuf;
	}

	if (RealHostName == NULL)
	{
		/* translate that to a host name */
		RealHostName = newstr(hostnamebyanyaddr(&RealHostAddr));
		if (strlen(RealHostName) > MAXNAME)
			RealHostName[MAXNAME] = '\0';
	}

	/* cross check RealHostName with forward DNS lookup */
	if (anynet_ntoa(&RealHostAddr)[0] == '[' ||
	    RealHostName[0] == '[')
	{
		/*
		**  address is not a socket or have an
		**  IP address with no forward lookup
		*/
		*may_be_forged = FALSE;
	}
	else
	{
		/* try to match the reverse against the forward lookup */
		hp = sm_gethostbyname(RealHostName);

		if (hp == NULL)
			*may_be_forged = TRUE;
		else
		{
			for (ha = hp->h_addr_list; *ha != NULL; ha++)
				if (addrcmp(hp, *ha, &RealHostAddr) == 0)
					break;
			*may_be_forged = *ha == NULL;
		}
	}

	if (TimeOuts.to_ident == 0)
		goto noident;

	lalen = sizeof la;
	if (RealHostAddr.sa.sa_family != AF_INET ||
	    getsockname(fd, &la.sa, &lalen) < 0 || lalen <= 0 ||
	    la.sa.sa_family != AF_INET)
	{
		/* no ident info */
		goto noident;
	}

	/* create ident query */
	(void) snprintf(ibuf, sizeof ibuf, "%d,%d\r\n",
		ntohs(RealHostAddr.sin.sin_port), ntohs(la.sin.sin_port));

	/* create local address */
	la.sin.sin_port = 0;

	/* create foreign address */
	sp = getservbyname("auth", "tcp");
	if (sp != NULL)
		RealHostAddr.sin.sin_port = sp->s_port;
	else
		RealHostAddr.sin.sin_port = htons(113);

	s = -1;
	if (setjmp(CtxAuthTimeout) != 0)
	{
		if (s >= 0)
			(void) close(s);
		goto noident;
	}

	/* put a timeout around the whole thing */
	ev = setevent(TimeOuts.to_ident, authtimeout, 0);

	/* connect to foreign IDENT server using same address as SMTP socket */
	s = socket(AF_INET, SOCK_STREAM, 0);
	if (s < 0)
	{
		clrevent(ev);
		goto noident;
	}
	if (bind(s, &la.sa, sizeof la.sin) < 0 ||
	    connect(s, &RealHostAddr.sa, sizeof RealHostAddr.sin) < 0)
	{
		goto closeident;
	}

	if (tTd(9, 10))
		printf("getauthinfo: sent %s", ibuf);

	/* send query */
	if (write(s, ibuf, strlen(ibuf)) < 0)
		goto closeident;

	/* get result */
	p = &ibuf[0];
	nleft = sizeof ibuf - 1;
	while ((i = read(s, p, nleft)) > 0)
	{
		p += i;
		nleft -= i;
		*p = '\0';
		if (strchr(ibuf, '\n') != NULL)
			break;
	}
	(void) close(s);
	clrevent(ev);
	if (i < 0 || p == &ibuf[0])
		goto noident;

	if (*--p == '\n' && *--p == '\r')
		p--;
	*++p = '\0';

	if (tTd(9, 3))
		printf("getauthinfo:  got %s\n", ibuf);

	/* parse result */
	p = strchr(ibuf, ':');
	if (p == NULL)
	{
		/* malformed response */
		goto noident;
	}
	while (isascii(*++p) && isspace(*p))
		continue;
	if (strncasecmp(p, "userid", 6) != 0)
	{
		/* presumably an error string */
		goto noident;
	}
	p += 6;
	while (isascii(*p) && isspace(*p))
		p++;
	if (*p++ != ':')
	{
		/* either useridxx or malformed response */
		goto noident;
	}

	/* p now points to the OSTYPE field */
	while (isascii(*p) && isspace(*p))
		p++;
	ostype = p;
	p = strchr(p, ':');
	if (p == NULL)
	{
		/* malformed response */
		goto noident;
	}
	else
	{
		char *charset;

		*p = '\0';
		charset = strchr(ostype, ',');
		if (charset != NULL)
			*charset = '\0';
	}

	/* 1413 says don't do this -- but it's broken otherwise */
	while (isascii(*++p) && isspace(*p))
		continue;

	/* p now points to the authenticated name -- copy carefully */
	if (strncasecmp(ostype, "other", 5) == 0 &&
	    (ostype[5] == ' ' || ostype[5] == '\0'))
	{
		snprintf(hbuf, sizeof hbuf, "IDENT:");
		cleanstrcpy(&hbuf[6], p, MAXNAME);
	}
	else
		cleanstrcpy(hbuf, p, MAXNAME);
	i = strlen(hbuf);
	snprintf(&hbuf[i], sizeof hbuf - i, "@@%s",
		 RealHostName == NULL ? "localhost" : RealHostName);
	goto postident;

closeident:
	(void) close(s);
	clrevent(ev);

noident:
	if (RealHostName == NULL)
	{
		if (tTd(9, 1))
			printf("getauthinfo: NULL\n");
		return NULL;
	}
	snprintf(hbuf, sizeof hbuf, "%s", RealHostName);

postident:
#if IP_SRCROUTE
# ifndef GET_IPOPT_DST
#  define GET_IPOPT_DST(dst)	(dst)
# endif
	/*
	**  Extract IP source routing information.
	**
	**	Format of output for a connection from site a through b
	**	through c to d:
	**		loose:      @@site-c@@site-b:site-a
	**		strict:	   !@@site-c@@site-b:site-a
	**
	**	o - pointer within ipopt_list structure.
	**	q - pointer within ls/ss rr route data
	**	p - pointer to hbuf
	*/

	if (RealHostAddr.sa.sa_family == AF_INET)
	{
		SOCKOPT_LEN_T ipoptlen;
		int j;
		u_char *q;
		u_char *o;
		int l;
		struct in_addr addr;
		struct ipoption ipopt;

		ipoptlen = sizeof ipopt;
		if (getsockopt(fd, IPPROTO_IP, IP_OPTIONS,
			       (char *) &ipopt, &ipoptlen) < 0)
			goto noipsr;
		if (ipoptlen == 0)
			goto noipsr;
		o = (u_char *) ipopt.ipopt_list;
		while (o != NULL && o < (u_char *) &ipopt + ipoptlen)
		{
			switch (*o)
			{
			  case IPOPT_EOL: 
				o = NULL;
				break;

			  case IPOPT_NOP:
				o++;
				break;

			  case IPOPT_SSRR:
			  case IPOPT_LSRR:
				/*
				**  Source routing.
				**	o[0] is the option type (loose/strict).
				**	o[1] is the length of this option,
				**		including option type and
				**		length.
				**	o[2] is the pointer into the route
				**		data.
				**	o[3] begins the route data.
				*/

				p = &hbuf[strlen(hbuf)];
				l = sizeof hbuf - (hbuf - p) - 6;
				snprintf(p, SPACELEFT(hbuf, p), " [%s@@%.*s",
				    *o == IPOPT_SSRR ? "!" : "",
				    l > 240 ? 120 : l / 2,
				    inet_ntoa(GET_IPOPT_DST(ipopt.ipopt_dst)));
				i = strlen(p);
				p += i;
				l -= strlen(p);

				j = o[1] / sizeof(struct in_addr) - 1;

				/* q skips length and router pointer to data */
				q = &o[3];
				for ( ; j >= 0; j--)
				{
					memcpy(&addr, q, sizeof(addr));
					snprintf(p, SPACELEFT(hbuf, p),
						"%c%.*s",
						j != 0 ? '@@' : ':',
						l > 240 ? 120 :
						    j == 0 ? l : l / 2,
						inet_ntoa(addr));
					i = strlen(p);
					p += i;
					l -= i + 1;
					q += sizeof(struct in_addr); 
				}
				o += o[1];
				break;

			  default:
				/* Skip over option */
				o += o[1];
				break;
			}
		}
		snprintf(p, SPACELEFT(hbuf, p), "]");
		goto postipsr;
	}

noipsr:
#endif
	if (RealHostName != NULL && RealHostName[0] != '[')
	{
		p = &hbuf[strlen(hbuf)];
		(void) snprintf(p, SPACELEFT(hbuf, p), " [%.100s]",
			anynet_ntoa(&RealHostAddr));
	}
	if (*may_be_forged)
	{
		p = &hbuf[strlen(hbuf)];
		(void) snprintf(p, SPACELEFT(hbuf, p), " (may be forged)");
	}

#if IP_SRCROUTE
postipsr:
#endif
	if (tTd(9, 1))
		printf("getauthinfo: %s\n", hbuf);
	return hbuf;
}
/*
**  HOST_MAP_LOOKUP -- turn a hostname into canonical form
**
**	Parameters:
**		map -- a pointer to this map.
**		name -- the (presumably unqualified) hostname.
**		av -- unused -- for compatibility with other mapping
**			functions.
**		statp -- an exit status (out parameter) -- set to
**			EX_TEMPFAIL if the name server is unavailable.
**
**	Returns:
**		The mapping, if found.
**		NULL if no mapping found.
**
**	Side Effects:
**		Looks up the host specified in hbuf.  If it is not
**		the canonical name for that host, return the canonical
**		name (unless MF_MATCHONLY is set, which will cause the
**		status only to be returned).
*/

char *
host_map_lookup(map, name, av, statp)
	MAP *map;
	char *name;
	char **av;
	int *statp;
{
	register struct hostent *hp;
	struct in_addr in_addr;
	char *cp;
	register STAB *s;
	char hbuf[MAXNAME + 1];

	/*
	**  See if we have already looked up this name.  If so, just
	**  return it.
	*/

	s = stab(name, ST_NAMECANON, ST_ENTER);
	if (bitset(NCF_VALID, s->s_namecanon.nc_flags))
	{
		if (tTd(9, 1))
			printf("host_map_lookup(%s) => CACHE %s\n",
			       name,
			       s->s_namecanon.nc_cname == NULL
					? "NULL"
					: s->s_namecanon.nc_cname);
		errno = s->s_namecanon.nc_errno;
#if NAMED_BIND
		h_errno = s->s_namecanon.nc_herrno;
#endif
		*statp = s->s_namecanon.nc_stat;
		if (*statp == EX_TEMPFAIL)
		{
			CurEnv->e_status = "4.4.3";
			message("851 %s: Name server timeout",
				shortenstring(name, 33));
		}
		if (*statp != EX_OK)
			return NULL;
		if (s->s_namecanon.nc_cname == NULL)
		{
			syserr("host_map_lookup(%s): bogus NULL cache entry, errno = %d, h_errno = %d",
				name,
				s->s_namecanon.nc_errno,
				s->s_namecanon.nc_herrno);
			return NULL;
		}
		if (bitset(MF_MATCHONLY, map->map_mflags))
			cp = map_rewrite(map, name, strlen(name), NULL);
		else
			cp = map_rewrite(map,
					 s->s_namecanon.nc_cname,
					 strlen(s->s_namecanon.nc_cname),
					 av);
		return cp;
	}

	/*
	**  If we are running without a regular network connection (usually
	**  dial-on-demand) and we are just queueing, we want to avoid DNS
	**  lookups because those could try to connect to a server.
	*/

	if (CurEnv->e_sendmode == SM_DEFER)
	{
		if (tTd(9, 1))
			printf("host_map_lookup(%s) => DEFERRED\n", name);
		*statp = EX_TEMPFAIL;
		return NULL;
	}

	/*
	**  If first character is a bracket, then it is an address
	**  lookup.  Address is copied into a temporary buffer to
	**  strip the brackets and to preserve name if address is
	**  unknown.
	*/

	if (*name != '[')
	{
		if (tTd(9, 1))
			printf("host_map_lookup(%s) => ", name);
		s->s_namecanon.nc_flags |= NCF_VALID;		/* will be soon */
		snprintf(hbuf, sizeof hbuf, "%s", name);
		if (getcanonname(hbuf, sizeof hbuf - 1, !HasWildcardMX))
		{
			if (tTd(9, 1))
				printf("%s\n", hbuf);
			s->s_namecanon.nc_stat = EX_OK;
			s->s_namecanon.nc_cname = newstr(hbuf);
			if (bitset(MF_MATCHONLY, map->map_mflags))
				cp = map_rewrite(map, name, strlen(name), NULL);
			else
				cp = map_rewrite(map, hbuf, strlen(hbuf), av);
			return cp;
		}
		else
		{
			s->s_namecanon.nc_errno = errno;
#if NAMED_BIND
			s->s_namecanon.nc_herrno = h_errno;
			if (tTd(9, 1))
				printf("FAIL (%d)\n", h_errno);
			switch (h_errno)
			{
			  case TRY_AGAIN:
				if (UseNameServer)
				{
					CurEnv->e_status = "4.4.3";
					message("851 %s: Name server timeout",
						shortenstring(name, 33));
				}
				*statp = EX_TEMPFAIL;
				break;

			  case HOST_NOT_FOUND:
			  case NO_DATA:
				*statp = EX_NOHOST;
				break;

			  case NO_RECOVERY:
				*statp = EX_SOFTWARE;
				break;

			  default:
				*statp = EX_UNAVAILABLE;
				break;
			}
#else
			if (tTd(9, 1))
				printf("FAIL\n");
			*statp = EX_NOHOST;
#endif
			s->s_namecanon.nc_stat = *statp;
			return NULL;
		}
	}
	if ((cp = strchr(name, ']')) == NULL)
		return (NULL);
	*cp = '\0';
	in_addr.s_addr = inet_addr(&name[1]);
	*cp = ']';

	/* nope -- ask the name server */
	hp = sm_gethostbyaddr((char *)&in_addr, INADDRSZ, AF_INET);
	s->s_namecanon.nc_errno = errno;
#if NAMED_BIND
	s->s_namecanon.nc_herrno = h_errno;
#endif
	s->s_namecanon.nc_flags |= NCF_VALID;		/* will be soon */
	if (hp == NULL)
	{
		s->s_namecanon.nc_stat = *statp = EX_NOHOST;
		return (NULL);
	}

	/* found a match -- copy out */
	hp->h_name = denlstring((char *) hp->h_name, TRUE, TRUE);
	s->s_namecanon.nc_stat = *statp = EX_OK;
	s->s_namecanon.nc_cname = newstr(hp->h_name);
	if (bitset(MF_MATCHONLY, map->map_mflags))
		cp = map_rewrite(map, name, strlen(name), NULL);
	else
		cp = map_rewrite(map, hp->h_name, strlen(hp->h_name), av);
	return cp;
}

# else /* DAEMON */
/* code for systems without sophisticated networking */

/*
**  MYHOSTNAME -- stub version for case of no daemon code.
**
**	Can't convert to upper case here because might be a UUCP name.
**
**	Mark, you can change this to be anything you want......
*/

char **
myhostname(hostbuf, size)
	char hostbuf[];
	int size;
{
	register FILE *f;

	hostbuf[0] = '\0';
	f = fopen("/usr/include/whoami", "r");
	if (f != NULL)
	{
		(void) fgets(hostbuf, size, f);
		fixcrlf(hostbuf, TRUE);
		(void) fclose(f);
	}
	return (NULL);
}
/*
**  GETAUTHINFO -- get the real host name asociated with a file descriptor
**
**	Parameters:
**		fd -- the descriptor
**		may_be_forged -- an outage that is set to TRUE if the
**			forward lookup of RealHostName does not match
**			RealHostAddr; set to FALSE if they do match.
**
**	Returns:
**		The host name associated with this descriptor, if it can
**			be determined.
**		NULL otherwise.
**
**	Side Effects:
**		none
*/

char *
getauthinfo(fd, may_be_forged)
	int fd;
	bool *may_be_forged;
{
	*may_be_forged = FALSE;
	return NULL;
}
/*
**  MAPHOSTNAME -- turn a hostname into canonical form
**
**	Parameters:
**		map -- a pointer to the database map.
**		name -- a buffer containing a hostname.
**		avp -- a pointer to a (cf file defined) argument vector.
**		statp -- an exit status (out parameter).
**
**	Returns:
**		mapped host name
**		FALSE otherwise.
**
**	Side Effects:
**		Looks up the host specified in name.  If it is not
**		the canonical name for that host, replace it with
**		the canonical name.  If the name is unknown, or it
**		is already the canonical name, leave it unchanged.
*/

/*ARGSUSED*/
char *
host_map_lookup(map, name, avp, statp)
	MAP *map;
	char *name;
	char **avp;
	char *statp;
{
	register struct hostent *hp;
	char *cp;

	hp = sm_gethostbyname(name);
	if (hp == NULL)
	{
		*statp = EX_NOHOST;
		return NULL;
	}
	if (bitset(MF_MATCHONLY, map->map_mflags))
		cp = map_rewrite(map, name, strlen(name), NULL);
	else
		cp = map_rewrite(map, hp->h_name, strlen(hp->h_name), avp);
	return cp;
}

#endif /* DAEMON */
/*
**  HOST_MAP_INIT -- initialize host class structures
*/

bool
host_map_init(map, args)
	MAP *map;
	char *args;
{
	register char *p = args;

	for (;;)
	{
		while (isascii(*p) && isspace(*p))
			p++;
		if (*p != '-')
			break;
		switch (*++p)
		{
		  case 'a':
			map->map_app = ++p;
			break;

		  case 'T':
			map->map_tapp = ++p;
			break;

		  case 'm':
			map->map_mflags |= MF_MATCHONLY;
			break;

		  case 't':
			map->map_mflags |= MF_NODEFER;
			break;
		}
		while (*p != '\0' && !(isascii(*p) && isspace(*p)))
			p++;
		if (*p != '\0')
			*p++ = '\0';
	}
	if (map->map_app != NULL)
		map->map_app = newstr(map->map_app);
	if (map->map_tapp != NULL)
		map->map_tapp = newstr(map->map_tapp);
	return TRUE;
}
/*
**  ANYNET_NTOA -- convert a network address to printable form.
**
**	Parameters:
**		sap -- a pointer to a sockaddr structure.
**
**	Returns:
**		A printable version of that sockaddr.
*/

#ifdef USE_SOCK_STREAM

#if NETLINK
# include <net/if_dl.h>
#endif

char *
anynet_ntoa(sap)
	register SOCKADDR *sap;
{
	register char *bp;
	register char *ap;
	int l;
	static char buf[100];

	/* check for null/zero family */
	if (sap == NULL)
		return "NULLADDR";
	if (sap->sa.sa_family == 0)
		return "0";

	switch (sap->sa.sa_family)
	{
#if NETUNIX
	  case AF_UNIX:
	  	if (sap->sunix.sun_path[0] != '\0')
	  		snprintf(buf, sizeof buf, "[UNIX: %.64s]",
				sap->sunix.sun_path);
	  	else
	  		snprintf(buf, sizeof buf, "[UNIX: localhost]");
		return buf;
#endif

#if NETINET
	  case AF_INET:
		return inet_ntoa(sap->sin.sin_addr);
#endif

#if NETLINK
	  case AF_LINK:
		snprintf(buf, sizeof buf, "[LINK: %s]",
			link_ntoa((struct sockaddr_dl *) &sap->sa));
		return buf;
#endif
	  default:
		/* this case is needed when nothing is #defined */
		/* in order to keep the switch syntactically correct */
		break;
	}

	/* unknown family -- just dump bytes */
	(void) snprintf(buf, sizeof buf, "Family %d: ", sap->sa.sa_family);
	bp = &buf[strlen(buf)];
	ap = sap->sa.sa_data;
	for (l = sizeof sap->sa.sa_data; --l >= 0; )
	{
		(void) snprintf(bp, SPACELEFT(buf, bp), "%02x:", *ap++ & 0377);
		bp += 3;
	}
	*--bp = '\0';
	return buf;
}
/*
**  HOSTNAMEBYANYADDR -- return name of host based on address
**
**	Parameters:
**		sap -- SOCKADDR pointer
**
**	Returns:
**		text representation of host name.
**
**	Side Effects:
**		none.
*/

char *
hostnamebyanyaddr(sap)
	register SOCKADDR *sap;
{
	register struct hostent *hp;
	int saveretry;

#if NAMED_BIND
	/* shorten name server timeout to avoid higher level timeouts */
	saveretry = _res.retry;
	_res.retry = 3;
#endif /* NAMED_BIND */

	switch (sap->sa.sa_family)
	{
#if NETINET
	  case AF_INET:
		hp = sm_gethostbyaddr((char *) &sap->sin.sin_addr,
			INADDRSZ,
			AF_INET);
		break;
#endif

#if NETISO
	  case AF_ISO:
		hp = sm_gethostbyaddr((char *) &sap->siso.siso_addr,
			sizeof sap->siso.siso_addr,
			AF_ISO);
		break;
#endif

#if NETUNIX
	  case AF_UNIX:
		hp = NULL;
		break;
#endif

	  default:
		hp = sm_gethostbyaddr(sap->sa.sa_data,
			   sizeof sap->sa.sa_data,
			   sap->sa.sa_family);
		break;
	}

#if NAMED_BIND
	_res.retry = saveretry;
#endif /* NAMED_BIND */

	if (hp != NULL && hp->h_name[0] != '[' &&
	    inet_addr(hp->h_name) == INADDR_NONE)
		return denlstring((char *) hp->h_name, TRUE, TRUE);
#if NETUNIX
	else if (sap->sa.sa_family == AF_UNIX && sap->sunix.sun_path[0] == '\0')
		return "localhost";
#endif
	else
	{
		/* produce a dotted quad */
		static char buf[203];

		(void) snprintf(buf, sizeof buf, "[%.200s]", anynet_ntoa(sap));
		return buf;
	}
}

#endif /* SOCK_STREAM */
@


1.14
log
@sendmail 8.9.3
@
text
@@


1.13
log
@sendmail 8.9.2
@
text
@d18 1
a18 1
static char sccsid[] = "@@(#)daemon.c	8.234 (Berkeley) 12/17/1998 (with daemon mode)";
d20 1
a20 1
static char sccsid[] = "@@(#)daemon.c	8.234 (Berkeley) 12/17/1998 (without daemon mode)";
d181 2
a182 2
			  "daemon could not open control socket: %s",
			  errstring(errno));
d506 1
a506 1
		snprintf(status, MAXLINE, "SMTP server child for %s",
@


1.12
log
@Back out previous change, the problem is Linux-specific.  To quote Wietse 'On UNIX systems with a BSD TCP/IP protocol stack, the accept() call does not return until the three-way handshake completes.'
@
text
@d18 1
a18 1
static char sccsid[] = "@@(#)daemon.c	8.220 (Berkeley) 6/24/98 (with daemon mode)";
d20 1
a20 1
static char sccsid[] = "@@(#)daemon.c	8.220 (Berkeley) 6/24/98 (without daemon mode)";
d106 2
a107 1
	bool refusingconnections = TRUE;
d109 1
d115 1
d117 3
d121 1
d179 5
d187 4
a190 2
	pidf = safefopen(PidFile, O_WRONLY|O_TRUNC, 0644,
			 SFF_NOLINK|SFF_ROOTOK|SFF_REGONLY|SFF_CREAT);
d218 3
d228 2
d236 1
a236 1
		if (refuseconnections(ntohs(port)))
d238 13
a250 1
			if (DaemonSocket >= 0)
d252 3
a254 3
				/* close socket so peer will fail quickly */
				(void) close(DaemonSocket);
				DaemonSocket = -1;
a255 10
			refusingconnections = TRUE;
			sleep(15);
			continue;
		}

		/* arrange to (re)open the socket if necessary */
		if (refusingconnections)
		{
			(void) opendaemonsocket(FALSE);
			refusingconnections = FALSE;
a281 3
		/* wait for a connection */
		setproctitle("accepting connections on port %d",
			     ntohs(port));
d289 2
a290 1
		if (SetNonBlocking(DaemonSocket, FALSE) < 0)
d296 1
d301 23
a323 2
			FD_SET(DaemonSocket, &readfds);
			timeout.tv_sec = 60;
d326 3
a328 2
			t = select(DaemonSocket + 1, FDSET_CAST &readfds,
				   NULL, NULL, &timeout);
d331 5
a335 2
			if (t <= 0 || !FD_ISSET(DaemonSocket, &readfds))
				continue;
d337 1
d339 21
a359 3
			lotherend = socksize;
			t = accept(DaemonSocket,
			    (struct sockaddr *)&RealHostAddr, &lotherend);
d363 17
a389 2
			refusingconnections = TRUE;
			sleep(5);
d442 1
d445 3
d451 1
a451 1
			setproctitle("startup with %s",
d481 1
a481 1
			setproctitle("startup with %s", p);
d488 1
a488 1
				exit(EX_OK);
a494 3
			/* open maps for check_relay ruleset */
			initmaps(FALSE, e);

d499 1
a499 1
				exit(EX_OK);
a501 1

d506 3
a508 1
		proc_list_add(pid);
d636 1
a636 1
	finis();
d1364 1
a1364 1
			RealHostName[MAXNAME - 1] = '\0';
d1372 2
a1373 2
		** address is not a socket or have an
		** IP address with no forward lookup
@


1.11
log
@Catch other cases where the accept(2) can fail.
Works around a DOS attack noted by Michal Zalewski <lcamtuf@@IDS.PL>.
Patch by Nick Andrew <nick@@ZETA.ORG.AU>.
@
text
@d296 1
a296 2
			if (t >= 0 || (errno != EINTR && errno != ENETUNREACH
			    && errno != EHOSTUNREACH))
@


1.10
log
@something hosed the sendmail import; fix up by hand
@
text
@d296 2
a297 1
			if (t >= 0 || errno != EINTR)
@


1.9
log
@Upgrade to sendmail 8.8.8
@
text
@d2 2
a3 1
 * Copyright (c) 1983, 1995-1997 Eric P. Allman
d7 3
a9 15
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
a10 11
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
d18 1
a18 1
static char sccsid[] = "@@(#)daemon.c	8.195 (Berkeley) 10/23/97 (with daemon mode)";
d20 1
a20 1
static char sccsid[] = "@@(#)daemon.c	8.195 (Berkeley) 10/23/97 (without daemon mode)";
d113 1
a113 1
	extern void reapchild();
d213 1
a213 1
		extern bool refuseconnections();
d405 1
a405 1
				exit(0);
d419 1
a419 1
				exit(0);
d795 3
a797 1
		long hid;
d891 7
d1028 6
d1057 8
a1064 1
		if (hp != NULL && hp->h_addr_list[addrno])
d1228 3
d1245 1
a1245 1
getauthinfo(fd)
d1247 1
d1255 1
a1255 1
	int i;
d1259 1
a1260 1
	volatile bool may_be_forged;
d1262 1
a1262 1
	static char hbuf[MAXNAME * 2 + 2];
d1264 1
d1266 1
a1266 1
	if (isatty(fd) || getpeername(fd, &RealHostAddr.sa, &falen) < 0 ||
d1269 2
d1287 2
a1288 1
	if (anynet_ntoa(&RealHostAddr)[0] == '[')
d1290 5
a1294 7
		/* address is not a socket */
		may_be_forged = FALSE;
	}
	else if (RealHostName[0] == '[')
	{
		/* have IP address with no forward lookup */
		may_be_forged = FALSE;
d1302 1
a1302 1
			may_be_forged = TRUE;
d1308 1
a1308 1
			may_be_forged = *ha == NULL;
d1416 3
d1425 9
d1440 8
a1447 1
	cleanstrcpy(hbuf, p, MAXNAME);
d1450 1
a1450 1
		RealHostName == NULL ? "localhost" : RealHostName);
a1565 1
#endif
d1568 1
d1575 1
a1575 1
	if (may_be_forged)
d1581 1
d1583 1
d1811 3
d1825 1
a1825 1
getauthinfo(fd)
d1827 1
d1829 1
d1872 1
a1872 1
		cp = map_rewrite(map, hp->h_name, strlen(hp->h_name), av);
d1900 4
d1919 2
d2056 2
a2057 1
	if (hp != NULL && hp->h_name[0] != '[')
d2059 1
d2062 1
@


1.8
log
@sendmail 8.8.7.
@
text
@d40 1
a40 1
static char sccsid[] = "@@(#)daemon.c	8.186 (Berkeley) 8/2/97 (with daemon mode)";
d42 1
a42 1
static char sccsid[] = "@@(#)daemon.c	8.186 (Berkeley) 8/2/97 (without daemon mode)";
d106 1
a106 3
**		TRUE -- if a "null server" should be used -- that is, one
**			that rejects all commands.
**		FALSE -- to use a normal server.
d123 1
a123 1
bool
d189 1
a189 1
		printf("getrequests: port 0x%x\n", DaemonAddr.sin.sin_port);
d239 1
a239 1
		if (refuseconnections(ntohs(DaemonAddr.sin.sin_port)))
d285 1
a285 1
			     ntohs(DaemonAddr.sin.sin_port));
a372 1
			bool nullconn;
a436 7
			/* validate the connection */
			HoldErrs = TRUE;
			nullconn = !validate_connection(&RealHostAddr, RealHostName, e);
			HoldErrs = FALSE;
			if (nullconn)
				break;

d445 1
a445 3
			if (tTd(15, 2))
				printf("getreq: returning (normal server)\n");
			return FALSE;
d464 2
a465 2
		printf("getreq: returning (null server)\n");
	return TRUE;
d1256 1
a1256 1
	bool may_be_forged;
d1741 1
d2019 3
a2021 1
		return (char *) hp->h_name;
@


1.7
log
@Sendmail 8.8.6.
@
text
@d40 1
a40 1
static char sccsid[] = "@@(#)daemon.c	8.175 (Berkeley) 6/1/97 (with daemon mode)";
d42 1
a42 1
static char sccsid[] = "@@(#)daemon.c	8.175 (Berkeley) 6/1/97 (without daemon mode)";
d133 1
d144 18
a161 5
	if (DaemonAddr.sin.sin_family == 0)
		DaemonAddr.sin.sin_family = AF_INET;
	if (DaemonAddr.sin.sin_addr.s_addr == 0)
		DaemonAddr.sin.sin_addr.s_addr = INADDR_ANY;
	if (DaemonAddr.sin.sin_port == 0)
d169 1
a169 1
			DaemonAddr.sin.sin_port = htons(25);
d172 12
a183 1
			DaemonAddr.sin.sin_port = sp->s_port;
d199 1
a199 1
	pidf = safefopen(PidFile, O_WRONLY|O_CREAT|O_TRUNC, 0644,
d234 1
a234 1
		auto int lotherend;
d309 2
a310 1
			t = select(DaemonSocket + 1, &readfds, NULL, NULL, &timeout);
d1001 1
a1001 1
			s = socket(AF_INET, SOCK_STREAM, 0);
d1205 29
d1257 1
a1257 1
	int falen;
d1260 1
a1260 1
	int lalen;
d1297 5
d1305 1
a1305 1
		hp = gethostbyname(RealHostName);
d1312 1
a1312 3
				if (bcmp(*ha,
					 (char *) &RealHostAddr.sin.sin_addr,
					 hp->h_length) == 0)
d1473 2
a1474 1
		int ipoptlen, j;
d1635 8
d2029 1
a2029 1
	if (hp != NULL)
@


1.6
log
@repair incorrect IP_OPTIONS parsing
@
text
@d2 1
a2 1
 * Copyright (c) 1983, 1995, 1996 Eric P. Allman
d40 1
a40 1
static char sccsid[] = "@@(#)daemon.c	8.159 (Berkeley) 1/14/97 (with daemon mode)";
d42 1
a42 1
static char sccsid[] = "@@(#)daemon.c	8.159 (Berkeley) 1/14/97 (without daemon mode)";
d46 5
a50 1
#if DAEMON || defined(SOCK_STREAM)
d62 2
d175 6
a180 2
			 SFF_NOSLINK|SFF_ROOTOK|SFF_REGONLY|SFF_CREAT);
	if (pidf != NULL)
a212 1
		extern int getla();
d246 2
a247 1
				syslog(LOG_ALERT, "daemon process doesn't have $j in $=w; see syslog");
d253 2
a254 1
				syslog(LOG_ALERT, "daemon process $j lost dot; see syslog");
d274 1
a274 1
		do
d276 14
d294 3
a296 1
		} while (t < 0 && errno == EINTR);
d411 3
a495 1
# ifdef LOG
d497 2
a498 2
					syslog(LOG_ALERT, "problem creating SMTP socket");
# endif /* LOG */
d779 1
a779 1
	register volatile int i = 0;
d902 1
a902 1
		i = 1;
a914 1
#ifdef LOG
d916 2
a917 2
				syslog(LOG_ERR, "makeconnection: service \"smtp\" unknown");
#endif
d1019 2
d1027 5
a1031 4
			if (connect(s, (struct sockaddr *) &addr, addrlen) >= 0)
			{
				if (ev != NULL)
					clrevent(ev);
a1032 1
			}
d1034 2
a1035 3
		sav_errno = errno;
		if (ev != NULL)
			clrevent(ev);
d1050 1
a1050 1
		if (hp != NULL && hp->h_addr_list[i])
d1059 1
a1059 1
				bcopy(hp->h_addr_list[i++],
d1066 1
a1066 1
				bcopy(hp->h_addr_list[i++],
d1161 2
a1162 2
#ifdef LOG
		syslog(LOG_CRIT, "My unqualified host name (%s) unknown; sleeping for retry",
a1163 1
#endif
d1169 2
a1170 2
#ifdef LOG
			syslog(LOG_ALERT, "unable to qualify my own domain name (%s) -- using short name",
a1171 1
#endif
d1211 3
d1236 24
d1397 3
d1443 11
d1459 1
a1459 1
				    inet_ntoa(ipopt.ipopt_dst));
a1463 1
				/* o[1] is option length */
d1467 1
a1467 1
				q = o + 1 + 2;
d1503 5
d1518 1
a1518 1
**		map -- a pointer to this map (unused).
d1532 2
a1533 1
**		name.
d1574 10
a1583 1
		return s->s_namecanon.nc_cname;
d1617 2
d1620 1
a1620 4
			{
				cp = map_rewrite(map, name, strlen(name), av);
				s->s_namecanon.nc_cname = newstr(hbuf);
			}
a1621 1
			{
a1622 2
				s->s_namecanon.nc_cname = newstr(cp);
			}
d1670 1
a1685 1
	cp = map_rewrite(map, (char *) hp->h_name, strlen(hp->h_name), av);
d1687 5
a1691 1
	s->s_namecanon.nc_cname = newstr(cp);
d1773 1
d1776 10
a1785 4
	if (hp != NULL)
		return hp->h_name;
	*statp = EX_NOHOST;
	return NULL;
d1790 40
d1839 1
a1839 1
#ifdef SOCK_STREAM
@


1.5
log
@Sendmail 8.8.5.
@
text
@d1397 1
a1397 1
				j = *++o / sizeof(struct in_addr) - 1;
d1400 1
a1400 1
				q = o + 2;
d1415 1
a1415 1
				o += *o;
@


1.4
log
@Update to Sendmail 8.8.4, plus recent patches, plus OpenBSD support.
Also include entire example configuration subset.
Includes smrsh (using /usr/libexec/sm.bin).

Of the top of my head, the only things I removed from the distribution were
contrib/mail.local.linux, src/Makefiles, all the *.0 and *.ps files.
Our praliases man page replaces the distributed one, ours is better.
@
text
@d40 1
a40 1
static char sccsid[] = "@@(#)daemon.c	8.156 (Berkeley) 12/1/96 (with daemon mode)";
d42 1
a42 1
static char sccsid[] = "@@(#)daemon.c	8.156 (Berkeley) 12/1/96 (without daemon mode)";
d168 2
a169 1
	pidf = fopen(PidFile, "w");
d320 1
a320 1
			extern void intsig();
@


1.3
log
@bring up to 8.7.6
@
text
@d2 1
a2 1
 * Copyright (c) 1983, 1995 Eric P. Allman
d40 1
a40 1
static char sccsid[] = "@@(#)daemon.c	8.119.1.2 (Berkeley) 9/16/96 (with daemon mode)";
d42 1
a42 1
static char sccsid[] = "@@(#)daemon.c	8.119.1.2 (Berkeley) 9/16/96 (without daemon mode)";
d46 1
a46 2
#ifdef DAEMON

d48 5
a52 5

#if NAMED_BIND
# include <resolv.h>
# ifndef NO_DATA
#  define NO_DATA	NO_ADDRESS
d56 7
a62 5
#if IP_SRCROUTE
# include <netinet/in_systm.h>
# include <netinet/ip.h>
# include <netinet/ip_var.h>
#endif
d74 1
a74 1
**	getrequests()
d84 1
a84 1
**	makeconnection(host, port, outfile, infile, usesecureport)
d97 1
a97 1
**		none.
d100 3
a102 1
**		none.
d119 3
a121 2
void
getrequests()
d131 1
d174 1
a174 1
		fprintf(pidf, "%d\n", getpid());
d187 1
a187 1
		expand("\201j", jbuf, sizeof jbuf, CurEnv);
d197 1
a197 1
		register int pid;
d199 2
d205 2
a206 2
		CurrentLA = getla();
		if (refuseconnections())
d230 1
d232 1
a232 1
			expand("\201j", jbuf, sizeof jbuf, CurEnv);
d249 13
a261 1
		setproctitle("accepting connections");
d269 2
d273 1
d291 10
d305 6
a318 1
			extern char *hostnamebyanyaddr();
d321 1
d329 2
d334 4
d342 22
d366 1
a366 1
			if (strlen(p) > MAXNAME)
d383 7
a389 1
			/* should we check for illegal connection here? XXX */
d399 2
a400 2
				printf("getreq: returning\n");
			return;
d403 7
a409 1
		CurChildren++;
d413 4
d418 3
a420 1
	/*NOTREACHED*/
d534 1
d625 1
a625 1
					DaemonAddr.sin.sin_addr.s_addr = htonl(inet_network(v));
d628 1
a628 1
					register struct netent *np;
d630 3
a632 3
					np = getnetbyname(v);
					if (np == NULL)
						syserr("554 network \"%s\" unknown", v);
d634 1
a634 1
						DaemonAddr.sin.sin_addr.s_addr = np->n_net;
d649 1
d651 1
d721 1
a721 2
**		usesecureport -- if set, use a low numbered (reserved)
**			port to provide some rudimentary authentication.
d743 1
a743 1
makeconnection(host, port, mci, usesecureport)
d747 1
a747 1
	bool usesecureport;
d749 3
a751 3
	register int i = 0;
	register int s;
	register struct hostent *hp = (struct hostent *)NULL;
d754 3
a756 3
	int addrlen;
	bool firstconnect;
	EVENT *ev;
d773 1
d780 2
a781 1
			if (inet_aton(&host[1], &addr.sin.sin_addr) == 0)
d807 2
d810 2
a811 2
			mci->mci_status = "5.1.2";
			return (EX_NOHOST);
d815 1
d820 3
a822 1
		register char *p = &host[strlen(host) - 1];
d824 3
a826 3
		hp = sm_gethostbyname(host);
		if (hp == NULL && *p == '.')
		{
d828 1
a828 1
			int oldopts = _res.options;
d830 1
a830 1
			_res.options &= ~(RES_DEFNAMES|RES_DNSRCH);
d832 3
a834 3
			*p = '\0';
			hp = sm_gethostbyname(host);
			*p = '.';
d836 1
a836 1
			_res.options = oldopts;
d838 1
d848 2
a849 2
				mci->mci_status = "4.4.3";
				return (EX_TEMPFAIL);
d852 1
d914 1
d938 1
a938 1
		if (usesecureport)
d952 5
a956 1
			goto failure;
d979 2
a980 2
		if (CurEnv->e_xfp != NULL)
			(void) fflush(CurEnv->e_xfp);		/* for debugging */
d990 5
a994 1
			if (TimeOuts.to_connect == 0)
a995 2
			else
				ev = setevent(TimeOuts.to_connect, connecttimeout, 0);
d1044 1
a1044 2
		/* failure, decide if temporary or not */
	failure:
d1048 2
a1049 7
		if (transienterror(sav_errno))
			return EX_TEMPFAIL;
		else
		{
			message("%s", errstring(sav_errno));
			return (EX_UNAVAILABLE);
		}
d1058 1
d1062 1
a1084 1
	extern bool getcanonname();
d1175 1
a1175 1
	register char *p;
a1184 1
	extern char *hostnamebyanyaddr();
d1201 2
d1269 3
a1308 8
	while (isascii(*p) && isspace(*p))
		p++;
	if (strncasecmp(p, "other", 5) == 0 &&
	    (p[5] == ':' || p[5] == ' ' || p[5] == ',' || p[5] == '\0'))
	{
		/* not useful information */
		goto noident;
	}
a1525 2
		extern bool getcanonname();

a1528 1
		if (strlen(name) < sizeof hbuf)
d1534 10
a1543 2
			cp = map_rewrite(map, hbuf, strlen(hbuf), av);
			s->s_namecanon.nc_cname = newstr(cp);
a1547 2
			register struct hostent *hp;

d1590 4
a1593 4
	(void) inet_aton(&name[1], &in_addr);
  
  	/* nope -- ask the name server */
	hp = gethostbyaddr((char *)&in_addr, sizeof(in_addr), AF_INET);
d1611 88
d1709 2
d1815 1
d1819 1
d1844 1
a1844 87
# else /* DAEMON */
/* code for systems without sophisticated networking */

/*
**  MYHOSTNAME -- stub version for case of no daemon code.
**
**	Can't convert to upper case here because might be a UUCP name.
**
**	Mark, you can change this to be anything you want......
*/

char **
myhostname(hostbuf, size)
	char hostbuf[];
	int size;
{
	register FILE *f;

	hostbuf[0] = '\0';
	f = fopen("/usr/include/whoami", "r");
	if (f != NULL)
	{
		(void) fgets(hostbuf, size, f);
		fixcrlf(hostbuf, TRUE);
		(void) fclose(f);
	}
	return (NULL);
}
/*
**  GETAUTHINFO -- get the real host name asociated with a file descriptor
**
**	Parameters:
**		fd -- the descriptor
**
**	Returns:
**		The host name associated with this descriptor, if it can
**			be determined.
**		NULL otherwise.
**
**	Side Effects:
**		none
*/

char *
getauthinfo(fd)
	int fd;
{
	return NULL;
}
/*
**  MAPHOSTNAME -- turn a hostname into canonical form
**
**	Parameters:
**		map -- a pointer to the database map.
**		name -- a buffer containing a hostname.
**		avp -- a pointer to a (cf file defined) argument vector.
**		statp -- an exit status (out parameter).
**
**	Returns:
**		mapped host name
**		FALSE otherwise.
**
**	Side Effects:
**		Looks up the host specified in name.  If it is not
**		the canonical name for that host, replace it with
**		the canonical name.  If the name is unknown, or it
**		is already the canonical name, leave it unchanged.
*/

/*ARGSUSED*/
char *
host_map_lookup(map, name, avp, statp)
	MAP *map;
	char *name;
	char **avp;
	char *statp;
{
	register struct hostent *hp;

	hp = sm_gethostbyname(name);
	if (hp != NULL)
		return hp->h_name;
	*statp = EX_NOHOST;
	return NULL;
}

#endif /* DAEMON */
@


1.2
log
@Sendmail 8.7.3 from NetBSD
@
text
@d40 1
a40 1
static char sccsid[] = "@@(#)daemon.c	8.119 (Berkeley) 11/29/95 (with daemon mode)";
d42 1
a42 1
static char sccsid[] = "@@(#)daemon.c	8.119 (Berkeley) 11/29/95 (without daemon mode)";
d1093 2
a1094 1
		(void) sprintf(hbuf, "%s@@localhost", RealUserName);
d1119 1
a1119 1
	(void) sprintf(ibuf, "%d,%d\r\n",
d1229 2
a1230 2
	hbuf[i++] = '@@';
	strcpy(&hbuf[i], RealHostName == NULL ? "localhost" : RealHostName);
d1244 1
a1244 1
	(void) strcpy(hbuf, RealHostName);
d1266 1
d1292 2
a1293 1
				sprintf(p, " [%s@@%.120s",
d1295 1
d1297 3
a1299 1
				p += strlen(p);
d1309 9
a1317 4
					sprintf(p, "%c%.120s",
						     j ? '@@' : ':',
						     inet_ntoa(addr));
					p += strlen(p);
d1329 1
a1329 1
		strcat(hbuf,"]");
d1338 2
a1339 1
		(void) sprintf(p, " [%.100s]", anynet_ntoa(&RealHostAddr));
d1438 1
a1438 6
			(void) strcpy(hbuf, name);
		else
		{
			bcopy(name, hbuf, sizeof hbuf - 1);
			hbuf[sizeof hbuf - 1] = '\0';
		}
d1548 2
a1549 1
	  		sprintf(buf, "[UNIX: %.64s]", sap->sunix.sun_path);
d1551 1
a1551 1
	  		sprintf(buf, "[UNIX: localhost]");
d1562 1
a1562 1
		sprintf(buf, "[LINK: %s]",
d1573 1
a1573 1
	(void) sprintf(buf, "Family %d: ", sap->sa.sa_family);
d1578 1
a1578 1
		(void) sprintf(bp, "%02x:", *ap++ & 0377);
d1650 1
a1650 1
		(void) sprintf(buf, "[%.200s]", anynet_ntoa(sap));
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
 * Copyright (c) 1983 Eric P. Allman
d40 1
a40 1
static char sccsid[] = "@@(#)daemon.c	8.48.1.5 (Berkeley) 3/28/95 (with daemon mode)";
d42 1
a42 1
static char sccsid[] = "@@(#)daemon.c	8.48.1.5 (Berkeley) 3/28/95 (without daemon mode)";
a47 1
# include <netdb.h>
a50 1
# include <arpa/nameser.h>
d52 9
d116 1
d123 1
a123 1
#ifdef XDEBUG
d178 1
a178 1
#ifdef XDEBUG
d182 1
a182 1
		expand("\201j", jbuf, &jbuf[sizeof jbuf - 1], CurEnv);
d195 1
a207 2
			setproctitle("rejecting connections: load average: %d",
				CurrentLA);
d212 1
a214 1
			/* start listening again */
a215 1
			setproctitle("accepting connections");
d219 1
a219 1
#ifdef XDEBUG
a221 1
			register STAB *s;
d224 2
a225 3
			expand("\201j", jbuf, &jbuf[sizeof jbuf - 1], CurEnv);
			if ((s = stab(jbuf, ST_CLASS, ST_FIND)) == NULL ||
			    !bitnset('w', s->s_class))
d241 1
d252 5
d281 2
d291 2
a292 1
			DisConnected = FALSE;
d299 2
d304 1
a304 11
#ifdef LOG
			if (LogLevel > 11)
			{
				/* log connection information */
				syslog(LOG_INFO, "connect from %s (%s)",
					RealHostName, anynet_ntoa(&RealHostAddr));
			}
#endif

			(void) close(DaemonSocket);
			if ((InChannel = fdopen(t, "r")) == NULL ||
d306 1
a306 1
			    (OutChannel = fdopen(t, "w")) == NULL)
d312 4
d330 2
d361 1
a361 1
	int socksize;
a376 1
				/* probably another daemon already */
d406 1
a406 1
					syserr("getrequests: setsockopt(SO_RCVBUF)");
d412 1
a412 1
# ifdef NETINET
d418 1
a418 1
# ifdef NETISO
d431 1
d433 1
a433 1
				syserr("getrequests: cannot bind");
d441 1
a441 1
			syserr("getrequests: cannot listen");
d447 1
d463 1
d480 1
d505 2
d513 1
a513 1
#ifdef NETINET
d517 1
a517 1
#ifdef NETISO
d521 1
a521 1
#ifdef NETNS
d525 1
a525 1
#ifdef NETX25
d536 1
a536 1
#ifdef NETINET
d539 1
a539 1
					DaemonAddr.sin.sin_addr.s_addr = inet_network(v);
d565 1
a565 1
#ifdef NETINET
d582 1
a582 1
#ifdef NETISO
d619 3
d644 9
d662 2
a663 1
	register int i, s;
d668 2
a669 3
#if NAMED_BIND
	extern int h_errno;
#endif
d691 1
a691 1
#ifdef NETINET
d696 1
a696 1
				hp = gethostbyname(&host[1]);
d699 5
d705 1
a705 1
					hp = gethostbyname(&host[1]);
d707 3
d719 1
d722 1
a722 1
#ifdef NETINET
d730 1
a730 1
		hp = gethostbyname(host);
d733 5
d739 1
a739 1
			hp = gethostbyname(host);
d741 3
d749 5
a753 5
			if (errno == ETIMEDOUT || h_errno == TRY_AGAIN)
				return (EX_TEMPFAIL);

			/* if name server is specified, assume temp fail */
			if (errno == ECONNREFUSED && UseNameServer)
d755 1
d762 1
a762 1
#ifdef NETINET
d766 1
a766 1
				sizeof addr.sin.sin_addr);
d783 1
a783 3
	if (port != 0)
		port = htons(port);
	else
d789 4
a792 1
			syserr("554 makeconnection: service \"smtp\" unknown");
d801 1
a801 1
#ifdef NETINET
d808 1
a808 1
#ifdef NETISO
d831 1
d854 1
a854 1
			syserr("makeconnection: no socket");
d881 33
a913 2
		if (connect(s, (struct sockaddr *) &addr, addrlen) >= 0)
			break;
a915 1
		sav_errno = errno;
d917 1
a917 1
		if (hp && hp->h_addr_list[i])
d924 1
a924 1
#ifdef NETINET
d928 1
a928 1
				      sizeof addr.sin.sin_addr);
d980 1
a980 1
char **
d986 1
a986 1
	extern struct hostent *gethostbyname();
d992 1
a992 1
	hp = gethostbyname(hostbuf);
d994 2
d997 2
a998 1
		syserr("!My host name (%s) does not seem to exist!", hostbuf);
a999 2
	(void) strncpy(hostbuf, hp->h_name, size - 1);
	hostbuf[size - 1] = '\0';
d1001 5
a1005 2
#if NAMED_BIND
	/* if still no dot, try DNS directly (i.e., avoid NIS problems) */
d1008 1
a1008 2
		extern bool getcanonname();
		extern int h_errno;
d1010 1
a1010 5
		/* try twice in case name server not yet started up */
		if (!getcanonname(hostbuf, size, TRUE) &&
		    UseNameServer &&
		    (h_errno != TRY_AGAIN ||
		     (sleep(30), !getcanonname(hostbuf, size, TRUE))))
d1012 6
a1017 3
			errno = h_errno + E_DNSBASE;
			syserr("!My host name (%s) not known to DNS",
				hostbuf);
a1019 1
#endif
d1021 11
a1031 1
	if (hp->h_addrtype == AF_INET && hp->h_length == 4)
d1033 8
a1040 3
		register int i;

		for (i = 0; hp->h_addr_list[i] != NULL; i++)
d1042 6
a1047 5
			char ipbuf[100];

			sprintf(ipbuf, "[%s]",
				inet_ntoa(*((struct in_addr *) hp->h_addr_list[i])));
			setclass('w', ipbuf);
d1050 1
a1050 2

	return (hp->h_aliases);
a1063 2
#if IDENTPROTO

d1066 1
a1066 1
static
a1071 2
#endif

a1077 1
#if IDENTPROTO
d1081 1
a1081 1
	int s;
a1085 1
#endif
a1087 1
	extern char RealUserName[];			/* main.c */
d1090 2
a1091 2
	if (getpeername(fd, &RealHostAddr.sa, &falen) < 0 || falen <= 0 ||
	    RealHostAddr.sa.sa_family == 0)
a1104 1
#if IDENTPROTO
d1206 8
d1230 1
a1230 1
	goto finish;
a1235 2
#endif /* IDENTPROTO */

d1245 79
a1323 1
finish:
d1327 1
a1327 1
		(void) sprintf(p, " [%s]", anynet_ntoa(&RealHostAddr));
d1329 2
a1365 1
	int i;
d1367 1
a1367 5
	char hbuf[MAXNAME];
	extern struct hostent *gethostbyaddr();
#if NAMED_BIND
	extern int h_errno;
#endif
d1379 4
a1382 1
				name, s->s_namecanon.nc_cname);
d1388 1
a1388 1
		if (CurEnv->e_message == NULL && *statp == EX_TEMPFAIL)
d1390 2
a1391 1
			sprintf(hbuf, "%s: Name server timeout",
a1392 1
			CurEnv->e_message = newstr(hbuf);
d1398 14
d1425 8
a1432 2
		(void) strcpy(hbuf, name);
		if (getcanonname(hbuf, sizeof hbuf - 1, TRUE))
d1454 2
a1455 1
					sprintf(hbuf, "%s: Name server timeout",
a1456 3
					message("%s", hbuf);
					if (CurEnv->e_message == NULL)
						CurEnv->e_message = newstr(hbuf);
d1462 1
d1480 1
a1480 19
			if (*statp != EX_TEMPFAIL || UseNameServer)
				return NULL;

			/*
			**  Try to look it up in /etc/hosts
			*/

			hp = gethostbyname(name);
			if (hp == NULL)
			{
				/* no dice there either */
				s->s_namecanon.nc_stat = *statp = EX_NOHOST;
				return NULL;
			}

			s->s_namecanon.nc_stat = *statp = EX_OK;
			cp = map_rewrite(map, hp->h_name, strlen(hp->h_name), av);
			s->s_namecanon.nc_cname = newstr(cp);
			return cp;
d1487 2
a1488 2

	/* nope -- ask the name server */
d1502 1
a1502 1
	cp = map_rewrite(map, hp->h_name, strlen(hp->h_name), av);
d1517 4
d1538 1
a1538 2
#ifdef MAYBENEXTRELEASE		/*** UNTESTED *** UNTESTED *** UNTESTED ***/
#ifdef NETUNIX
a1545 1
#endif
d1547 1
a1547 1
#ifdef NETINET
d1549 1
a1549 1
		return inet_ntoa(((struct sockaddr_in *) sap)->sin_addr);
d1552 6
d1559 3
a1561 2
	  	/* this case is only to ensure syntactic correctness */
	  	break;
d1604 1
a1604 1
#ifdef NETINET
d1606 2
a1607 2
		hp = gethostbyaddr((char *) &sap->sin.sin_addr,
			sizeof sap->sin.sin_addr,
d1612 1
a1612 1
#ifdef NETISO
d1614 1
a1614 1
		hp = gethostbyaddr((char *) &sap->siso.siso_addr,
a1619 1
#ifdef MAYBENEXTRELEASE		/*** UNTESTED *** UNTESTED *** UNTESTED ***/
a1622 1
#endif
d1625 1
a1625 1
		hp = gethostbyaddr(sap->sa.sa_data,
d1636 1
a1636 1
		return hp->h_name;
d1640 1
a1640 1
		static char buf[512];
d1642 1
a1642 1
		(void) sprintf(buf, "[%s]", anynet_ntoa(sap));
d1726 1
a1726 1
	hp = gethostbyname(name);
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@


1.1.1.2
log
@sendmail 8.9.1
@
text
@d2 1
a2 2
 * Copyright (c) 1998 Sendmail, Inc.  All rights reserved.
 * Copyright (c) 1983, 1995-1997 Eric P. Allman.  All rights reserved.
d6 15
a20 3
 * By using this file, you agree to the terms and conditions set
 * forth in the LICENSE file which can be found at the top level of
 * the sendmail distribution.
d22 11
d40 1
a40 1
static char sccsid[] = "@@(#)daemon.c	8.220 (Berkeley) 6/24/98 (with daemon mode)";
d42 1
a42 1
static char sccsid[] = "@@(#)daemon.c	8.220 (Berkeley) 6/24/98 (without daemon mode)";
d46 1
a46 3
#if defined(SOCK_STREAM) || defined(__GNU_LIBRARY__)
# define USE_SOCK_STREAM	1
#endif
d48 1
a48 1
#if DAEMON || defined(USE_SOCK_STREAM)
d50 4
a53 6
# if NAMED_BIND
#  include <resolv.h>
#  ifndef NO_DATA
#   define NO_DATA	NO_ADDRESS
#  endif
# endif
a55 10
#if DAEMON

# include <sys/time.h>

# if IP_SRCROUTE
#  include <netinet/in_systm.h>
#  include <netinet/ip.h>
#  include <netinet/ip_var.h>
# endif

d66 1
a66 1
**	getrequests(e)
d76 1
a76 1
**	makeconnection(host, port, outfile, infile, e)
d89 1
a89 1
**		e -- the current envelope.
d109 1
a109 3
void
getrequests(e)
	ENVELOPE *e;
d115 1
a115 2
	u_short port;
#if XDEBUG
d118 1
a118 2
	extern void reapchild __P((int));
	extern int opendaemonsocket __P((bool));
d124 5
a128 18
	switch (DaemonAddr.sa.sa_family)
	{
	  case AF_UNSPEC:
		DaemonAddr.sa.sa_family = AF_INET;
		/* fall through ... */

	  case AF_INET:
		if (DaemonAddr.sin.sin_addr.s_addr == 0)
			DaemonAddr.sin.sin_addr.s_addr = INADDR_ANY;
		port = DaemonAddr.sin.sin_port;
		break;

	  default:
		/* unknown protocol */
		port = 0;
		break;
	}
	if (port == 0)
d136 1
a136 1
			port = htons(25);
d139 1
a139 12
			port = sp->s_port;
	}

	switch (DaemonAddr.sa.sa_family)
	{
	  case AF_INET:
		DaemonAddr.sin.sin_port = port;
		break;

	  default:
		/* unknown protocol */
		break;
d147 1
a147 1
		printf("getrequests: port 0x%x\n", port);
d155 2
a156 7
	pidf = safefopen(PidFile, O_WRONLY|O_TRUNC, 0644,
			 SFF_NOLINK|SFF_ROOTOK|SFF_REGONLY|SFF_CREAT);
	if (pidf == NULL)
	{
		sm_syslog(LOG_ERR, NOQID, "unable to write %s", PidFile);
	}
	else
d161 1
a161 1
		fprintf(pidf, "%ld\n", (long) getpid());
d170 1
a170 1
#if XDEBUG
d174 1
a174 1
		expand("\201j", jbuf, sizeof jbuf, e);
d184 3
a186 5
		register pid_t pid;
		auto SOCKADDR_LEN_T lotherend;
		int savederrno;
		int pipefd[2];
		extern bool refuseconnections __P((int));
d189 2
a190 2
		(void) blocksignal(SIGALRM);
		if (refuseconnections(ntohs(port)))
d199 2
a204 1
		/* arrange to (re)open the socket if necessary */
d207 1
d209 1
d213 1
a213 1
#if XDEBUG
d216 1
a217 1
			extern void dumpstate __P((char *));
d219 3
a221 2
			expand("\201j", jbuf, sizeof jbuf, e);
			if (!wordinclass(jbuf, 'w'))
d224 1
a224 2
				sm_syslog(LOG_ALERT, NOQID,
					"daemon process doesn't have $j in $=w; see syslog");
d230 1
a230 2
				sm_syslog(LOG_ALERT, NOQID,
					"daemon process $j lost dot; see syslog");
d237 1
a237 14
		setproctitle("accepting connections on port %d",
			     ntohs(port));
#if 0
		/*
		**  Andrew Sun <asun@@ieps-sun.ml.com> claims that this will
		**  fix the SVr4 problem.  But it seems to have gone away,
		**  so is it worth doing this?
		*/

		if (SetNonBlocking(DaemonSocket, FALSE) < 0)
			log an error here;
#endif
		(void) releasesignal(SIGALRM);
		for (;;)
a238 15
			fd_set readfds;
			struct timeval timeout;

			FD_ZERO(&readfds);
			FD_SET(DaemonSocket, &readfds);
			timeout.tv_sec = 60;
			timeout.tv_usec = 0;

			t = select(DaemonSocket + 1, FDSET_CAST &readfds,
				   NULL, NULL, &timeout);
			if (DoQueueRun)
				(void) runqueue(TRUE, FALSE);
			if (t <= 0 || !FD_ISSET(DaemonSocket, &readfds))
				continue;

d243 1
a243 5
			if (t >= 0 || errno != EINTR)
				break;
		}
		savederrno = errno;
		(void) blocksignal(SIGALRM);
a245 1
			errno = savederrno;
a246 5

			/* arrange to re-open the socket next time around */
			(void) close(DaemonSocket);
			DaemonSocket = -1;
			refusingconnections = TRUE;
a257 10
		/*
		**  Create a pipe to keep the child from writing to the
		**  socket until after the parent has closed it.  Otherwise
		**  the parent may hang if the child has closed it first.
		*/

		if (pipe(pipefd) < 0)
			pipefd[0] = pipefd[1] = -1;

		blocksignal(SIGCHLD);
a261 6
			if (pipefd[0] != -1)
			{
				(void) close(pipefd[0]);
				(void) close(pipefd[1]);
			}
			(void) releasesignal(SIGCHLD);
d270 1
a270 2
			extern SIGFUNC_DECL intsig __P((int));
			FILE *inchannel, *outchannel;
a277 2
			(void) releasesignal(SIGALRM);
			(void) releasesignal(SIGCHLD);
d279 1
a279 6
			(void) setsignal(SIGHUP, intsig);
			(void) close(DaemonSocket);
			proc_list_clear();

			/* don't schedule queue runs if we are told to ETRN */
			QueueIntvl = 0;
a283 22
			if (pipefd[0] != -1)
			{
				auto char c;

				/*
				**  Wait for the parent to close the write end
				**  of the pipe, which we will see as an EOF.
				**  This guarantees that we won't write to the
				**  socket until after the parent has closed
				**  the pipe.
				*/

				/* close the write end of the pipe */
				(void) close(pipefd[1]);

				/* we shouldn't be interrupted, but ... */
				while (read(pipefd[0], &c, 1) < 0 &&
				       errno == EINTR)
					continue;
				(void) close(pipefd[0]);
			}

a285 2
			if (strlen(p) > (SIZE_T) MAXNAME)
				p[MAXNAME] = '\0';
d289 11
a299 1
			if ((inchannel = fdopen(t, "r")) == NULL ||
d301 1
a301 1
			    (outchannel = fdopen(t, "w")) == NULL)
d304 1
a304 1
				exit(EX_OK);
d307 1
a307 7
			InChannel = inchannel;
			OutChannel = outchannel;
			DisConnected = FALSE;

			/* open maps for check_relay ruleset */
			initmaps(FALSE, e);

d312 1
a312 1
				exit(EX_OK);
d316 3
a318 1
			break;
a320 8
		/* parent -- keep track of children */
		proc_list_add(pid);
		(void) releasesignal(SIGCHLD);

		/* close the read end of the synchronization pipe */
		if (pipefd[0] != -1)
			(void) close(pipefd[0]);

a322 4

		/* release the child by closing the read end of the sync pipe */
		if (pipefd[1] != -1)
			(void) close(pipefd[1]);
d324 1
a324 3
	if (tTd(15, 2))
		printf("getreq: returning\n");
	return;
d350 1
a350 1
	int socksize = 0;
d366 1
d370 1
d372 2
a373 2
					sm_syslog(LOG_ALERT, NOQID,
						"problem creating SMTP socket");
d396 1
a396 1
					syserr("opendaemonsocket: setsockopt(SO_RCVBUF)");
d402 1
a402 1
# if NETINET
d408 1
a408 1
# if NETISO
a420 1
				/* probably another daemon already */
d422 1
a422 1
				syserr("opendaemonsocket: cannot bind");
d430 1
a430 1
			syserr("opendaemonsocket: cannot listen");
a435 1
	syserr("!opendaemonsocket: server SMTP socket wedged: exiting");
a436 1
	return -1;  /* avoid compiler warning on IRIX */
a450 1
void
a466 1
void
a490 2
		if (isascii(*f) && islower(*f))
			*f = toupper(*f);
d497 1
a497 1
#if NETINET
d501 1
a501 1
#if NETISO
d505 1
a505 1
#if NETNS
d509 1
a509 1
#if NETX25
d520 1
a520 1
#if NETINET
d523 1
a523 1
					DaemonAddr.sin.sin_addr.s_addr = inet_addr(v);
d526 1
a526 1
					register struct hostent *hp;
d528 3
a530 3
					hp = sm_gethostbyname(v);
					if (hp == NULL)
						syserr("554 host \"%s\" unknown", v);
d532 1
a532 1
						bcopy(hp->h_addr, &DaemonAddr.sin.sin_addr, INADDRSZ);
a546 1
#if NETISO
a547 1
#endif
d549 1
a549 1
#if NETINET
d566 1
a566 1
#if NETISO
a602 3

		  default:
			syserr("554 DaemonPortOptions parameter \"%s\" unknown", f);
d614 2
a615 1
**		e -- the current envelope.
a624 9
static jmp_buf	CtxConnectTimeout;

static void
connecttimeout()
{
	errno = ETIMEDOUT;
	longjmp(CtxConnectTimeout, 1);
}

d628 1
a628 1
makeconnection(host, port, mci, e)
d632 1
a632 1
	ENVELOPE *e;
d634 2
a635 3
	register volatile int addrno = 0;
	register volatile int s;
	register struct hostent *volatile hp = (struct hostent *)NULL;
d638 4
a641 3
	volatile int addrlen;
	volatile bool firstconnect;
	EVENT *volatile ev = NULL;
a657 3
#if NETINET
		unsigned long hid = INADDR_NONE;
#endif
d663 2
a664 3
#if NETINET
			hid = inet_addr(&host[1]);
			if (hid == INADDR_NONE)
d668 1
a668 1
				hp = sm_gethostbyname(&host[1]);
a670 5
#if NAMED_BIND
					int oldopts = _res.options;

					_res.options &= ~(RES_DEFNAMES|RES_DNSRCH);
#endif
d672 1
a672 1
					hp = sm_gethostbyname(&host[1]);
a673 3
#if NAMED_BIND
					_res.options = oldopts;
#endif
a681 2
			extern char MsgBuf[];

d683 1
a683 2
			mci_setstat(mci, EX_NOHOST, "5.1.2", MsgBuf);
			return EX_NOHOST;
d685 1
a685 1
#if NETINET
a686 1
		addr.sin.sin_addr.s_addr = hid;
d691 4
a694 1
		/* contortion to get around SGI cc complaints */
d696 3
a698 17
			register char *p = &host[strlen(host) - 1];

			hp = sm_gethostbyname(host);
			if (hp == NULL && *p == '.')
			{
#if NAMED_BIND
				int oldopts = _res.options;

				_res.options &= ~(RES_DEFNAMES|RES_DNSRCH);
#endif
				*p = '\0';
				hp = sm_gethostbyname(host);
				*p = '.';
#if NAMED_BIND
				_res.options = oldopts;
#endif
			}
d704 6
a709 7
			/* check for name server timeouts */
			if (errno == ETIMEDOUT || h_errno == TRY_AGAIN ||
			    (errno == ECONNREFUSED && UseNameServer))
			{
				mci_setstat(mci, EX_TEMPFAIL, "4.4.3", NULL);
				return EX_TEMPFAIL;
			}
a710 1
			mci_setstat(mci, EX_NOHOST, "5.1.2", NULL);
d716 1
a716 1
#if NETINET
d720 1
a720 1
				INADDRSZ);
a724 7
			if (hp->h_length > sizeof addr.sa.sa_data)
			{
				syserr("makeconnection: long sa_data: family %d len %d",
					hp->h_addrtype, hp->h_length);
				mci_setstat(mci, EX_NOHOST, "5.1.2", NULL);
				return EX_NOHOST;
			}
d730 1
a730 1
		addrno = 1;
d737 3
a739 1
	if (port == 0)
d745 1
a745 3
			if (LogLevel > 2)
				sm_syslog(LOG_ERR, NOQID,
					"makeconnection: service \"smtp\" unknown");
d754 1
a754 1
#if NETINET
d761 1
a761 1
#if NETISO
a770 1
		mci_setstat(mci, EX_NOHOST, "5.1.2", NULL);
a783 1
	firstconnect = TRUE;
d793 1
a793 1
		if (bitnset(M_SECURE_PORT, mci->mci_mailer->m_flags))
d801 1
a801 1
			s = socket(addr.sa.sa_family, SOCK_STREAM, 0);
d806 2
a807 6
			syserr("makeconnection: cannot create socket");
#ifdef XLA
			xla_host_end(host);
#endif
			mci_setstat(mci, EX_TEMPFAIL, "4.4.5", NULL);
			return EX_TEMPFAIL;
d830 2
a831 2
		if (e->e_xfp != NULL)
			(void) fflush(e->e_xfp);		/* for debugging */
d833 2
a834 42

		/*
		**  Linux seems to hang in connect for 90 minutes (!!!).
		**  Time out the connect to avoid this problem.
		*/

		if (setjmp(CtxConnectTimeout) == 0)
		{
			int i;

			if (e->e_ntries <= 0 && TimeOuts.to_iconnect != 0)
				ev = setevent(TimeOuts.to_iconnect, connecttimeout, 0);
			else if (TimeOuts.to_connect != 0)
				ev = setevent(TimeOuts.to_connect, connecttimeout, 0);
			else
				ev = NULL;

#if _FFR_CONNECTONLYTO_OPTION
			/* for testing */
			if (ConnectOnlyTo != 0)
				addr.sin.sin_addr.s_addr = ConnectOnlyTo;
#endif
			i = connect(s, (struct sockaddr *) &addr, addrlen);
			sav_errno = errno;
			if (ev != NULL)
				clrevent(ev);
			if (i >= 0)
				break;
		}
		else
			sav_errno = errno;

		/* if running demand-dialed connection, try again */
		if (DialDelay > 0 && firstconnect)
		{
			if (tTd(16, 1))
				printf("Connect failed (%s); trying again...\n",
					errstring(sav_errno));
			firstconnect = FALSE;
			sleep(DialDelay);
			continue;
		}
d837 1
d839 1
a839 8

		if (LogLevel >= 14)
			sm_syslog(LOG_INFO, e->e_id,
				  "makeconnection (%s [%s]) failed: %s",
				  host, anynet_ntoa(&addr),
				  errstring(sav_errno));

		if (hp != NULL && hp->h_addr_list[addrno] != NULL)
d846 1
a846 1
#if NETINET
d848 1
a848 1
				bcopy(hp->h_addr_list[addrno++],
d850 1
a850 1
				      INADDRSZ);
d855 1
a855 1
				bcopy(hp->h_addr_list[addrno++],
d863 2
a864 1
		/* couldn't open connection */
d868 7
a874 2
		mci_setstat(mci, EX_TEMPFAIL, "4.4.1", NULL);
		return EX_TEMPFAIL;
a882 1
		mci_setstat(mci, EX_TEMPFAIL, "4.4.5", NULL);
a885 1
	mci_setstat(mci, EX_OK, NULL, NULL);
d902 1
a902 1
struct hostent *
d908 1
d914 1
a914 1
	hp = sm_gethostbyname(hostbuf);
a915 2
		return NULL;
	if (strchr(hp->h_name, '.') != NULL || strchr(hostbuf, '.') == NULL)
d917 1
a917 2
		(void) strncpy(hostbuf, hp->h_name, size - 1);
		hostbuf[size - 1] = '\0';
d919 2
d922 2
a923 5
	/*
	**  If there is still no dot in the name, try looking for a
	**  dotted alias.
	*/

d926 2
a927 1
		char **ha;
d929 5
a933 1
		for (ha = hp->h_aliases; *ha != NULL; ha++)
d935 3
a937 6
			if (strchr(*ha, '.') != NULL)
			{
				(void) strncpy(hostbuf, *ha, size - 1);
				hostbuf[size - 1] = '\0';
				break;
			}
d940 1
d942 3
a944 8
	/*
	**  If _still_ no dot, wait for a while and try again -- it is
	**  possible that some service is starting up.  This can result
	**  in excessive delays if the system is badly configured, but
	**  there really isn't a way around that, particularly given that
	**  the config file hasn't been read at this point.
	**  All in all, a bit of a mess.
	*/
d946 1
a946 10
	if (strchr(hostbuf, '.') == NULL &&
	    !getcanonname(hostbuf, size, TRUE))
	{
		sm_syslog(LOG_CRIT, NOQID,
			"My unqualified host name (%s) unknown; sleeping for retry",
			hostbuf);
		message("My unqualified host name (%s) unknown; sleeping for retry",
			hostbuf);
		sleep(60);
		if (!getcanonname(hostbuf, size, TRUE))
d948 5
a952 5
			sm_syslog(LOG_ALERT, NOQID,
				"unable to qualify my own domain name (%s) -- using short name",
				hostbuf);
			message("WARNING: unable to qualify my own domain name (%s) -- using short name",
				hostbuf);
a954 27
	return (hp);
}
/*
**  ADDRCMP -- compare two host addresses
**
**	Parameters:
**		hp -- hostent structure for the first address
**		ha -- actual first address
**		sa -- second address
**
**	Returns:
**		0 -- if ha and sa match
**		else -- they don't match
*/

int
addrcmp(hp, ha, sa)
	struct hostent *hp;
	char *ha;
	SOCKADDR *sa;
{
	switch (sa->sa.sa_family)
	{
	  case AF_INET:
		if (hp->h_addrtype == AF_INET)
			return bcmp(ha, (char *) &sa->sin.sin_addr, hp->h_length);
		break;
d956 1
a956 2
	}
	return -1;
a964 3
**		may_be_forged -- an outage that is set to TRUE if the
**			forward lookup of RealHostName does not match
**			RealHostAddr; set to FALSE if they do match.
d970 2
d974 1
a974 1
static void
d980 2
d983 1
a983 1
getauthinfo(fd, may_be_forged)
a984 1
	bool *may_be_forged;
d986 3
a988 2
	SOCKADDR_LEN_T falen;
	register char *volatile p = NULL;
d990 1
a990 1
	SOCKADDR_LEN_T lalen;
d992 2
a993 2
	volatile int s;
	int i = 0;
a995 3
	struct hostent *hp;
	char *ostype = NULL;
	char **ha;
d997 4
a1000 1
	static char hbuf[MAXNAME * 2 + 11];
a1001 1
	*may_be_forged = FALSE;
d1003 2
a1004 2
	if (isatty(fd) || (i = getpeername(fd, &RealHostAddr.sa, &falen)) < 0 ||
	    falen <= 0 || RealHostAddr.sa.sa_family == 0)
d1006 1
a1006 4
		if (i < 0 && errno != ENOTSOCK)
			return NULL;
		(void) snprintf(hbuf, sizeof hbuf, "%s@@localhost",
			RealUserName);
a1015 28
		if (strlen(RealHostName) > MAXNAME)
			RealHostName[MAXNAME - 1] = '\0';
	}

	/* cross check RealHostName with forward DNS lookup */
	if (anynet_ntoa(&RealHostAddr)[0] == '[' ||
	    RealHostName[0] == '[')
	{
		/*
		** address is not a socket or have an
		** IP address with no forward lookup
		*/
		*may_be_forged = FALSE;
	}
	else
	{
		/* try to match the reverse against the forward lookup */
		hp = sm_gethostbyname(RealHostName);

		if (hp == NULL)
			*may_be_forged = TRUE;
		else
		{
			for (ha = hp->h_addr_list; *ha != NULL; ha++)
				if (addrcmp(hp, *ha, &RealHostAddr) == 0)
					break;
			*may_be_forged = *ha == NULL;
		}
d1018 1
d1032 1
a1032 1
	(void) snprintf(ibuf, sizeof ibuf, "%d,%d\r\n",
a1082 3
		*p = '\0';
		if (strchr(ibuf, '\n') != NULL)
			break;
a1119 3
	while (isascii(*p) && isspace(*p))
		p++;
	ostype = p;
a1125 9
	else
	{
		char *charset;

		*p = '\0';
		charset = strchr(ostype, ',');
		if (charset != NULL)
			*charset = '\0';
	}
d1132 1
a1132 8
	if (strncasecmp(ostype, "other", 5) == 0 &&
	    (ostype[5] == ' ' || ostype[5] == '\0'))
	{
		snprintf(hbuf, sizeof hbuf, "IDENT:");
		cleanstrcpy(&hbuf[6], p, MAXNAME);
	}
	else
		cleanstrcpy(hbuf, p, MAXNAME);
d1134 3
a1136 3
	snprintf(&hbuf[i], sizeof hbuf - i, "@@%s",
		 RealHostName == NULL ? "localhost" : RealHostName);
	goto postident;
d1142 2
d1151 1
a1151 1
	snprintf(hbuf, sizeof hbuf, "%s", RealHostName);
d1153 1
a1153 103
postident:
#if IP_SRCROUTE
# ifndef GET_IPOPT_DST
#  define GET_IPOPT_DST(dst)	(dst)
# endif
	/*
	**  Extract IP source routing information.
	**
	**	Format of output for a connection from site a through b
	**	through c to d:
	**		loose:      @@site-c@@site-b:site-a
	**		strict:	   !@@site-c@@site-b:site-a
	**
	**	o - pointer within ipopt_list structure.
	**	q - pointer within ls/ss rr route data
	**	p - pointer to hbuf
	*/

	if (RealHostAddr.sa.sa_family == AF_INET)
	{
		SOCKOPT_LEN_T ipoptlen;
		int j;
		u_char *q;
		u_char *o;
		int l;
		struct in_addr addr;
		struct ipoption ipopt;

		ipoptlen = sizeof ipopt;
		if (getsockopt(fd, IPPROTO_IP, IP_OPTIONS,
			       (char *) &ipopt, &ipoptlen) < 0)
			goto noipsr;
		if (ipoptlen == 0)
			goto noipsr;
		o = (u_char *) ipopt.ipopt_list;
		while (o != NULL && o < (u_char *) &ipopt + ipoptlen)
		{
			switch (*o)
			{
			  case IPOPT_EOL: 
				o = NULL;
				break;

			  case IPOPT_NOP:
				o++;
				break;

			  case IPOPT_SSRR:
			  case IPOPT_LSRR:
				/*
				**  Source routing.
				**	o[0] is the option type (loose/strict).
				**	o[1] is the length of this option,
				**		including option type and
				**		length.
				**	o[2] is the pointer into the route
				**		data.
				**	o[3] begins the route data.
				*/

				p = &hbuf[strlen(hbuf)];
				l = sizeof hbuf - (hbuf - p) - 6;
				snprintf(p, SPACELEFT(hbuf, p), " [%s@@%.*s",
				    *o == IPOPT_SSRR ? "!" : "",
				    l > 240 ? 120 : l / 2,
				    inet_ntoa(GET_IPOPT_DST(ipopt.ipopt_dst)));
				i = strlen(p);
				p += i;
				l -= strlen(p);

				j = o[1] / sizeof(struct in_addr) - 1;

				/* q skips length and router pointer to data */
				q = &o[3];
				for ( ; j >= 0; j--)
				{
					memcpy(&addr, q, sizeof(addr));
					snprintf(p, SPACELEFT(hbuf, p),
						"%c%.*s",
						j != 0 ? '@@' : ':',
						l > 240 ? 120 :
						    j == 0 ? l : l / 2,
						inet_ntoa(addr));
					i = strlen(p);
					p += i;
					l -= i + 1;
					q += sizeof(struct in_addr); 
				}
				o += o[1];
				break;

			  default:
				/* Skip over option */
				o += o[1];
				break;
			}
		}
		snprintf(p, SPACELEFT(hbuf, p), "]");
		goto postipsr;
	}

noipsr:
#endif
d1157 1
a1157 7
		(void) snprintf(p, SPACELEFT(hbuf, p), " [%.100s]",
			anynet_ntoa(&RealHostAddr));
	}
	if (*may_be_forged)
	{
		p = &hbuf[strlen(hbuf)];
		(void) snprintf(p, SPACELEFT(hbuf, p), " (may be forged)");
a1158 4

#if IP_SRCROUTE
postipsr:
#endif
d1167 1
a1167 1
**		map -- a pointer to this map.
d1181 1
a1181 2
**		name (unless MF_MATCHONLY is set, which will cause the
**		status only to be returned).
d1194 1
d1196 5
a1200 1
	char hbuf[MAXNAME + 1];
d1212 1
a1212 4
			       name,
			       s->s_namecanon.nc_cname == NULL
					? "NULL"
					: s->s_namecanon.nc_cname);
d1218 1
a1218 1
		if (*statp == EX_TEMPFAIL)
d1220 1
a1220 2
			CurEnv->e_status = "4.4.3";
			message("851 %s: Name server timeout",
d1222 1
d1224 1
a1224 32
		if (*statp != EX_OK)
			return NULL;
		if (s->s_namecanon.nc_cname == NULL)
		{
			syserr("host_map_lookup(%s): bogus NULL cache entry, errno = %d, h_errno = %d",
				name,
				s->s_namecanon.nc_errno,
				s->s_namecanon.nc_herrno);
			return NULL;
		}
		if (bitset(MF_MATCHONLY, map->map_mflags))
			cp = map_rewrite(map, name, strlen(name), NULL);
		else
			cp = map_rewrite(map,
					 s->s_namecanon.nc_cname,
					 strlen(s->s_namecanon.nc_cname),
					 av);
		return cp;
	}

	/*
	**  If we are running without a regular network connection (usually
	**  dial-on-demand) and we are just queueing, we want to avoid DNS
	**  lookups because those could try to connect to a server.
	*/

	if (CurEnv->e_sendmode == SM_DEFER)
	{
		if (tTd(9, 1))
			printf("host_map_lookup(%s) => DEFERRED\n", name);
		*statp = EX_TEMPFAIL;
		return NULL;
d1236 2
d1241 2
a1242 2
		snprintf(hbuf, sizeof hbuf, "%s", name);
		if (getcanonname(hbuf, sizeof hbuf - 1, !HasWildcardMX))
d1246 2
a1247 6
			s->s_namecanon.nc_stat = EX_OK;
			s->s_namecanon.nc_cname = newstr(hbuf);
			if (bitset(MF_MATCHONLY, map->map_mflags))
				cp = map_rewrite(map, name, strlen(name), NULL);
			else
				cp = map_rewrite(map, hbuf, strlen(hbuf), av);
d1252 2
d1264 1
a1264 2
					CurEnv->e_status = "4.4.3";
					message("851 %s: Name server timeout",
d1266 3
a1273 1
			  case NO_DATA:
d1291 19
a1309 1
			return NULL;
d1315 1
a1315 2
	in_addr.s_addr = inet_addr(&name[1]);
	*cp = ']';
d1318 1
a1318 1
	hp = sm_gethostbyaddr((char *)&in_addr, INADDRSZ, AF_INET);
d1331 1
a1331 1
	hp->h_name = denlstring((char *) hp->h_name, TRUE, TRUE);
d1333 1
a1333 5
	s->s_namecanon.nc_cname = newstr(hp->h_name);
	if (bitset(MF_MATCHONLY, map->map_mflags))
		cp = map_rewrite(map, name, strlen(name), NULL);
	else
		cp = map_rewrite(map, hp->h_name, strlen(hp->h_name), av);
a1335 146

# else /* DAEMON */
/* code for systems without sophisticated networking */

/*
**  MYHOSTNAME -- stub version for case of no daemon code.
**
**	Can't convert to upper case here because might be a UUCP name.
**
**	Mark, you can change this to be anything you want......
*/

char **
myhostname(hostbuf, size)
	char hostbuf[];
	int size;
{
	register FILE *f;

	hostbuf[0] = '\0';
	f = fopen("/usr/include/whoami", "r");
	if (f != NULL)
	{
		(void) fgets(hostbuf, size, f);
		fixcrlf(hostbuf, TRUE);
		(void) fclose(f);
	}
	return (NULL);
}
/*
**  GETAUTHINFO -- get the real host name asociated with a file descriptor
**
**	Parameters:
**		fd -- the descriptor
**		may_be_forged -- an outage that is set to TRUE if the
**			forward lookup of RealHostName does not match
**			RealHostAddr; set to FALSE if they do match.
**
**	Returns:
**		The host name associated with this descriptor, if it can
**			be determined.
**		NULL otherwise.
**
**	Side Effects:
**		none
*/

char *
getauthinfo(fd, may_be_forged)
	int fd;
	bool *may_be_forged;
{
	*may_be_forged = FALSE;
	return NULL;
}
/*
**  MAPHOSTNAME -- turn a hostname into canonical form
**
**	Parameters:
**		map -- a pointer to the database map.
**		name -- a buffer containing a hostname.
**		avp -- a pointer to a (cf file defined) argument vector.
**		statp -- an exit status (out parameter).
**
**	Returns:
**		mapped host name
**		FALSE otherwise.
**
**	Side Effects:
**		Looks up the host specified in name.  If it is not
**		the canonical name for that host, replace it with
**		the canonical name.  If the name is unknown, or it
**		is already the canonical name, leave it unchanged.
*/

/*ARGSUSED*/
char *
host_map_lookup(map, name, avp, statp)
	MAP *map;
	char *name;
	char **avp;
	char *statp;
{
	register struct hostent *hp;
	char *cp;

	hp = sm_gethostbyname(name);
	if (hp == NULL)
	{
		*statp = EX_NOHOST;
		return NULL;
	}
	if (bitset(MF_MATCHONLY, map->map_mflags))
		cp = map_rewrite(map, name, strlen(name), NULL);
	else
		cp = map_rewrite(map, hp->h_name, strlen(hp->h_name), avp);
	return cp;
}

#endif /* DAEMON */
/*
**  HOST_MAP_INIT -- initialize host class structures
*/

bool
host_map_init(map, args)
	MAP *map;
	char *args;
{
	register char *p = args;

	for (;;)
	{
		while (isascii(*p) && isspace(*p))
			p++;
		if (*p != '-')
			break;
		switch (*++p)
		{
		  case 'a':
			map->map_app = ++p;
			break;

		  case 'T':
			map->map_tapp = ++p;
			break;

		  case 'm':
			map->map_mflags |= MF_MATCHONLY;
			break;

		  case 't':
			map->map_mflags |= MF_NODEFER;
			break;
		}
		while (*p != '\0' && !(isascii(*p) && isspace(*p)))
			p++;
		if (*p != '\0')
			*p++ = '\0';
	}
	if (map->map_app != NULL)
		map->map_app = newstr(map->map_app);
	if (map->map_tapp != NULL)
		map->map_tapp = newstr(map->map_tapp);
	return TRUE;
}
a1345 6
#ifdef USE_SOCK_STREAM

#if NETLINK
# include <net/if_dl.h>
#endif

d1363 2
a1364 1
#if NETUNIX
d1367 1
a1367 2
	  		snprintf(buf, sizeof buf, "[UNIX: %.64s]",
				sap->sunix.sun_path);
d1369 1
a1369 1
	  		snprintf(buf, sizeof buf, "[UNIX: localhost]");
d1372 1
d1374 1
a1374 1
#if NETINET
d1376 1
a1376 1
		return inet_ntoa(sap->sin.sin_addr);
a1378 6
#if NETLINK
	  case AF_LINK:
		snprintf(buf, sizeof buf, "[LINK: %s]",
			link_ntoa((struct sockaddr_dl *) &sap->sa));
		return buf;
#endif
d1380 2
a1381 3
		/* this case is needed when nothing is #defined */
		/* in order to keep the switch syntactically correct */
		break;
d1385 1
a1385 1
	(void) snprintf(buf, sizeof buf, "Family %d: ", sap->sa.sa_family);
d1390 1
a1390 1
		(void) snprintf(bp, SPACELEFT(buf, bp), "%02x:", *ap++ & 0377);
d1424 1
a1424 1
#if NETINET
d1426 2
a1427 2
		hp = sm_gethostbyaddr((char *) &sap->sin.sin_addr,
			INADDRSZ,
d1432 1
a1432 1
#if NETISO
d1434 1
a1434 1
		hp = sm_gethostbyaddr((char *) &sap->siso.siso_addr,
d1440 1
a1440 1
#if NETUNIX
d1447 1
a1447 1
		hp = sm_gethostbyaddr(sap->sa.sa_data,
d1457 2
a1458 7
	if (hp != NULL && hp->h_name[0] != '[' &&
	    inet_addr(hp->h_name) == INADDR_NONE)
		return denlstring((char *) hp->h_name, TRUE, TRUE);
#if NETUNIX
	else if (sap->sa.sa_family == AF_UNIX && sap->sunix.sun_path[0] == '\0')
		return "localhost";
#endif
d1462 1
a1462 1
		static char buf[203];
d1464 1
a1464 1
		(void) snprintf(buf, sizeof buf, "[%.200s]", anynet_ntoa(sap));
d1469 87
a1555 1
#endif /* SOCK_STREAM */
@

