head	1.18;
access;
symbols
	OPENBSD_2_6:1.17.0.4
	OPENBSD_2_6_BASE:1.17
	OPENBSD_2_5:1.17.0.2
	OPENBSD_2_5_BASE:1.17
	OPENBSD_2_4:1.15.0.2
	OPENBSD_2_4_BASE:1.15
	sendmail_8_9_1:1.1.1.2
	UCB:1.1.1
	OPENBSD_2_3:1.13.0.2
	OPENBSD_2_3_BASE:1.13
	OPENBSD_2_2:1.12.0.2
	OPENBSD_2_2_BASE:1.12
	OPENBSD_2_1:1.10.0.2
	OPENBSD_2_1_BASE:1.10
	OPENBSD_2_0:1.8.0.2
	OPENBSD_2_0_BASE:1.8
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.18
date	2000.04.18.04.57.28;	author millert;	state dead;
branches;
next	1.17;

1.17
date	99.02.05.05.59.37;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	99.01.01.20.34.06;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	98.08.14.00.56.02;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	98.07.12.19.45.28;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	97.11.09.04.05.47;	author gene;	state Exp;
branches;
next	1.12;

1.12
date	97.08.04.02.18.01;	author downsj;	state Exp;
branches;
next	1.11;

1.11
date	97.07.15.07.24.20;	author downsj;	state Exp;
branches;
next	1.10;

1.10
date	97.01.22.01.07.28;	author downsj;	state Exp;
branches;
next	1.9;

1.9
date	96.12.14.21.17.48;	author downsj;	state Exp;
branches;
next	1.8;

1.8
date	96.09.22.19.50.28;	author downsj;	state Exp;
branches;
next	1.7;

1.7
date	96.09.19.06.45.07;	author fn;	state Exp;
branches;
next	1.6;

1.6
date	96.09.13.05.20.06;	author downsj;	state Exp;
branches;
next	1.5;

1.5
date	96.09.12.19.25.44;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.03.09.22.08.33;	author dm;	state Exp;
branches;
next	1.3;

1.3
date	96.02.23.17.45.32;	author dm;	state Exp;
branches;
next	1.2;

1.2
date	96.01.29.01.44.54;	author dm;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.48.20;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.48.20;	author deraadt;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	98.07.12.17.10.53;	author millert;	state Exp;
branches;
next	;


desc
@@


1.18
log
@remove sendmail 8.9.3
@
text
@/*
 * Copyright (c) 1998 Sendmail, Inc.  All rights reserved.
 * Copyright (c) 1983, 1995-1997 Eric P. Allman.  All rights reserved.
 * Copyright (c) 1988, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * By using this file, you agree to the terms and conditions set
 * forth in the LICENSE file which can be found at the top level of
 * the sendmail distribution.
 *
 */

#ifndef lint
static char sccsid[] = "@@(#)util.c	8.168 (Berkeley) 1/21/1999";
#endif /* not lint */

# include "sendmail.h"
# include <sysexits.h>
/*
**  STRIPQUOTES -- Strip quotes & quote bits from a string.
**
**	Runs through a string and strips off unquoted quote
**	characters and quote bits.  This is done in place.
**
**	Parameters:
**		s -- the string to strip.
**
**	Returns:
**		none.
**
**	Side Effects:
**		none.
**
**	Called By:
**		deliver
*/

void
stripquotes(s)
	char *s;
{
	register char *p;
	register char *q;
	register char c;

	if (s == NULL)
		return;

	p = q = s;
	do
	{
		c = *p++;
		if (c == '\\')
			c = *p++;
		else if (c == '"')
			continue;
		*q++ = c;
	} while (c != '\0');
}
/*
**  ADDQUOTES -- Adds quotes & quote bits to a string.
**
**	Runs through a string and adds characters and quote bits.
**
**	Parameters:
**		s -- the string to modify.
**
**	Returns:
**		pointer to quoted string.
**
**	Side Effects:
**		none.
**
*/

char *
addquotes(s)
	char *s;
{
	int len = 0;
	char c;
	char *p = s, *q, *r;

	if (s == NULL)
		return NULL;

	/* Find length of quoted string */
	while ((c = *p++) != '\0')
	{
		len++;
		if (c == '\\' || c == '"')
			len++;
	}
	
	q = r = xalloc(len + 3);
	p = s;

	/* add leading quote */
	*q++ = '"';
	while ((c = *p++) != '\0')
	{
		/* quote \ or " */
		if (c == '\\' || c == '"')
			*q++ = '\\';
		*q++ = c;
	}
	*q++ = '"';
	*q = '\0';
	return r;
}
/*
**  RFC822_STRING -- Checks string for proper RFC822 string quoting.
**
**	Runs through a string and verifies RFC822 special characters
**	are only found inside comments, quoted strings, or backslash
**	escaped.  Also verified balanced quotes and parenthesis.
**
**	Parameters:
**		s -- the string to modify.
**
**	Returns:
**		TRUE -- if the string is RFC822 compliant.
**		FALSE -- if the string is not RFC822 compliant.
**
**	Side Effects:
**		none.
**
*/

bool
rfc822_string(s)
	char *s;
{
	bool quoted = FALSE;
	int commentlev = 0;
	char *c = s;

	if (s == NULL)
		return FALSE;

	while (*c != '\0')
	{
		/* escaped character */
		if (*c == '\\')
		{
			c++;
			if (*c == '\0')
				return FALSE;
		}
		else if (commentlev == 0 && *c == '"')
			quoted = !quoted;
		else if (!quoted)
		{
			if (*c == ')')
			{
				/* unbalanced ')' */
				if (commentlev == 0)
					return FALSE;
				else
					commentlev--;
			}
			else if (*c == '(')
				commentlev++;
			else if (commentlev == 0 &&
				 strchr(MustQuoteChars, *c) != NULL)
				return FALSE;
		}
		c++;
	}
	/* unbalanced '"' or '(' */
	if (quoted || commentlev != 0)
		return FALSE;
	else
		return TRUE;
}
/*
**  SHORTEN_RFC822_STRING -- Truncate and rebalance an RFC822 string
**
**	Arbitratily shorten (in place) an RFC822 string and rebalance
**	comments and quotes.
**
**	Parameters:
**		string -- the string to shorten
**		length -- the maximum size, 0 if no maximum
**
**	Returns:
**		TRUE if string is changed, FALSE otherwise
**
**	Side Effects:
**		Changes string in place, possibly resulting
**		in a shorter string.
*/

bool
shorten_rfc822_string(string, length)
	char *string;
	size_t length;
{
	bool backslash = FALSE;
	bool modified = FALSE;
	bool quoted = FALSE;
	size_t slen;
	int parencount = 0;
	char *ptr = string;
	
	/*
	**  If have to rebalance an already short enough string,
	**  need to do it within allocated space.
	*/
	slen = strlen(string);
	if (length == 0 || slen < length)
		length = slen;

	while (*ptr != '\0')
	{
		if (backslash)
		{
			backslash = FALSE;
			goto increment;
		}

		if (*ptr == '\\')
			backslash = TRUE;
		else if (*ptr == '(')
		{
			if (!quoted)
				parencount++;
		}
		else if (*ptr == ')')
		{
			if (--parencount < 0)
				parencount = 0;
		}
		
		/* Inside a comment, quotes don't matter */
		if (parencount <= 0 && *ptr == '"')
			quoted = !quoted;

increment:
		/* Check for sufficient space for next character */
		if (length - (ptr - string) <= ((backslash ? 1 : 0) +
						parencount +
						(quoted ? 1 : 0)))
		{
			/* Not enough, backtrack */
			if (*ptr == '\\')
				backslash = FALSE;
			else if (*ptr == '(' && !quoted)
				parencount--;
			else if (*ptr == '"' && parencount == 0)
				quoted = FALSE;
			break;
		}
		ptr++;
	}

	/* Rebalance */
	while (parencount-- > 0)
	{
		if (*ptr != ')')
		{
			modified = TRUE;
			*ptr = ')';
		}
		ptr++;
	}
	if (quoted)
	{
		if (*ptr != '"')
		{
			modified = TRUE;
			*ptr = '"';
		}
		ptr++;
	}
	if (*ptr != '\0')
	{
		modified = TRUE;
		*ptr = '\0';
	}
	return modified;
}
/*
**  FIND_CHARACTER -- find an unquoted character in an RFC822 string
**
**	Find an unquoted, non-commented character in an RFC822
**	string and return a pointer to its location in the
**	string.
**
**	Parameters:
**		string -- the string to search
**		character -- the character to find
**
**	Returns:
**		pointer to the character, or
**		a pointer to the end of the line if character is not found
*/

char *
find_character(string, character)
	char *string;
	char character;
{
	bool backslash = FALSE;
	bool quoted = FALSE;
	int parencount = 0;
		
	while (string != NULL && *string != '\0')
	{
		if (backslash)
		{
			backslash = FALSE;
			if (!quoted && character == '\\' && *string == '\\')
				break;
			string++;
			continue;
		}
		switch (*string)
		{
		  case '\\':
			backslash = TRUE;
			break;
			
		  case '(':
			if (!quoted)
				parencount++;
			break;
			
		  case ')':
			if (--parencount < 0)
				parencount = 0;
			break;
		}
		
		/* Inside a comment, nothing matters */
		if (parencount > 0)
		{
			string++;
			continue;
		}
		
		if (*string == '"')
			quoted = !quoted;
		else if (*string == character && !quoted)
			break;
		string++;
	}

	/* Return pointer to the character */
	return string;
}
/*
**  XALLOC -- Allocate memory and bitch wildly on failure.
**
**	THIS IS A CLUDGE.  This should be made to give a proper
**	error -- but after all, what can we do?
**
**	Parameters:
**		sz -- size of area to allocate.
**
**	Returns:
**		pointer to data region.
**
**	Side Effects:
**		Memory is allocated.
*/

char *
xalloc(sz)
	register int sz;
{
	register char *p;

	/* some systems can't handle size zero mallocs */
	if (sz <= 0)
		sz = 1;

	p = malloc((unsigned) sz);
	if (p == NULL)
	{
		syserr("!Out of memory!!");
		/* exit(EX_UNAVAILABLE); */
	}
	return (p);
}
/*
**  COPYPLIST -- copy list of pointers.
**
**	This routine is the equivalent of newstr for lists of
**	pointers.
**
**	Parameters:
**		list -- list of pointers to copy.
**			Must be NULL terminated.
**		copycont -- if TRUE, copy the contents of the vector
**			(which must be a string) also.
**
**	Returns:
**		a copy of 'list'.
**
**	Side Effects:
**		none.
*/

char **
copyplist(list, copycont)
	char **list;
	bool copycont;
{
	register char **vp;
	register char **newvp;

	for (vp = list; *vp != NULL; vp++)
		continue;

	vp++;

	newvp = (char **) xalloc((int) (vp - list) * sizeof *vp);
	bcopy((char *) list, (char *) newvp, (int) (vp - list) * sizeof *vp);

	if (copycont)
	{
		for (vp = newvp; *vp != NULL; vp++)
			*vp = newstr(*vp);
	}

	return (newvp);
}
/*
**  COPYQUEUE -- copy address queue.
**
**	This routine is the equivalent of newstr for address queues
**	addresses marked with QDONTSEND aren't copied
**
**	Parameters:
**		addr -- list of address structures to copy.
**
**	Returns:
**		a copy of 'addr'.
**
**	Side Effects:
**		none.
*/

ADDRESS *
copyqueue(addr)
	ADDRESS *addr;
{
	register ADDRESS *newaddr;
	ADDRESS *ret;
	register ADDRESS **tail = &ret;

	while (addr != NULL)
	{
		if (!bitset(QDONTSEND, addr->q_flags))
		{
			newaddr = (ADDRESS *) xalloc(sizeof(ADDRESS));
			STRUCTCOPY(*addr, *newaddr);
			*tail = newaddr;
			tail = &newaddr->q_next;
		}
		addr = addr->q_next;
	}
	*tail = NULL;
	
	return ret;
}
/*
**  PRINTAV -- print argument vector.
**
**	Parameters:
**		av -- argument vector.
**
**	Returns:
**		none.
**
**	Side Effects:
**		prints av.
*/

void
printav(av)
	register char **av;
{
	while (*av != NULL)
	{
		if (tTd(0, 44))
			printf("\n\t%08lx=", (u_long) *av);
		else
			(void) putchar(' ');
		xputs(*av++);
	}
	(void) putchar('\n');
}
/*
**  LOWER -- turn letter into lower case.
**
**	Parameters:
**		c -- character to turn into lower case.
**
**	Returns:
**		c, in lower case.
**
**	Side Effects:
**		none.
*/

char
lower(c)
	register char c;
{
	return((isascii(c) && isupper(c)) ? tolower(c) : c);
}
/*
**  XPUTS -- put string doing control escapes.
**
**	Parameters:
**		s -- string to put.
**
**	Returns:
**		none.
**
**	Side Effects:
**		output to stdout
*/

void
xputs(s)
	register const char *s;
{
	register int c;
	register struct metamac *mp;
	bool shiftout = FALSE;
	extern struct metamac MetaMacros[];

	if (s == NULL)
	{
		printf("%s<null>%s", TermEscape.te_rv_on, TermEscape.te_rv_off);
		return;
	}
	while ((c = (*s++ & 0377)) != '\0')
	{
		if (shiftout)
		{
			printf("%s", TermEscape.te_rv_off);
			shiftout = FALSE;
		}
		if (!isascii(c))
		{
			if (c == MATCHREPL)
			{
				printf("%s$", TermEscape.te_rv_on);
				shiftout = TRUE;
				if (*s == '\0')
					continue;
				c = *s++ & 0377;
				goto printchar;
			}
			if (c == MACROEXPAND || c == MACRODEXPAND)
			{
				printf("%s$", TermEscape.te_rv_on);
				if (c == MACRODEXPAND)
					putchar('&');
				shiftout = TRUE;
				if (*s == '\0')
					continue;
				if (strchr("=~&?", *s) != NULL)
					putchar(*s++);
				if (bitset(0200, *s))
					printf("{%s}", macname(*s++ & 0377));
				else
					printf("%c", *s++);
				continue;
			}
			for (mp = MetaMacros; mp->metaname != '\0'; mp++)
			{
				if ((mp->metaval & 0377) == c)
				{
					printf("%s$%c",
						TermEscape.te_rv_on,
						mp->metaname);
					shiftout = TRUE;
					break;
				}
			}
			if (c == MATCHCLASS || c == MATCHNCLASS)
			{
				if (bitset(0200, *s))
					printf("{%s}", macname(*s++ & 0377));
				else if (*s != '\0')
					printf("%c", *s++);
			}
			if (mp->metaname != '\0')
				continue;

			/* unrecognized meta character */
			printf("%sM-", TermEscape.te_rv_on);
			shiftout = TRUE;
			c &= 0177;
		}
  printchar:
		if (isprint(c))
		{
			putchar(c);
			continue;
		}

		/* wasn't a meta-macro -- find another way to print it */
		switch (c)
		{
		  case '\n':
			c = 'n';
			break;

		  case '\r':
			c = 'r';
			break;

		  case '\t':
			c = 't';
			break;
		}
		if (!shiftout)
		{
			printf("%s", TermEscape.te_rv_on);
			shiftout = TRUE;
		}
		if (isprint(c))
		{
			(void) putchar('\\');
			(void) putchar(c);
		}
		else
		{
			(void) putchar('^');
			(void) putchar(c ^ 0100);
		}
	}
	if (shiftout)
		printf("%s", TermEscape.te_rv_off);
	(void) fflush(stdout);
}
/*
**  MAKELOWER -- Translate a line into lower case
**
**	Parameters:
**		p -- the string to translate.  If NULL, return is
**			immediate.
**
**	Returns:
**		none.
**
**	Side Effects:
**		String pointed to by p is translated to lower case.
**
**	Called By:
**		parse
*/

void
makelower(p)
	register char *p;
{
	register char c;

	if (p == NULL)
		return;
	for (; (c = *p) != '\0'; p++)
		if (isascii(c) && isupper(c))
			*p = tolower(c);
}
/*
**  BUILDFNAME -- build full name from gecos style entry.
**
**	This routine interprets the strange entry that would appear
**	in the GECOS field of the password file.
**
**	Parameters:
**		p -- name to build.
**		login -- the login name of this user (for &).
**		buf -- place to put the result.
**		buflen -- length of buf.
**
**	Returns:
**		none.
**
**	Side Effects:
**		none.
*/

void
buildfname(gecos, login, buf, buflen)
	register char *gecos;
	char *login;
	char *buf;
	int buflen;
{
	register char *p;
	register char *bp = buf;

	if (*gecos == '*')
		gecos++;

	/* copy gecos, interpolating & to be full name */
	for (p = gecos; *p != '\0' && *p != ',' && *p != ';' && *p != '%'; p++)
	{
		if (bp >= &buf[buflen - 1])
		{
			/* buffer overflow -- just use login name */
			snprintf(buf, buflen, "%s", login);
			return;
		}
		if (*p == '&')
		{
			/* interpolate full name */
			snprintf(bp, buflen - (bp - buf), "%s", login);
			*bp = toupper(*bp);
			bp += strlen(bp);
		}
		else
			*bp++ = *p;
	}
	*bp = '\0';
}
/*
**  FIXCRLF -- fix <CR><LF> in line.
**
**	Looks for the <CR><LF> combination and turns it into the
**	UNIX canonical <NL> character.  It only takes one line,
**	i.e., it is assumed that the first <NL> found is the end
**	of the line.
**
**	Parameters:
**		line -- the line to fix.
**		stripnl -- if true, strip the newline also.
**
**	Returns:
**		none.
**
**	Side Effects:
**		line is changed in place.
*/

void
fixcrlf(line, stripnl)
	char *line;
	bool stripnl;
{
	register char *p;

	p = strchr(line, '\n');
	if (p == NULL)
		return;
	if (p > line && p[-1] == '\r')
		p--;
	if (!stripnl)
		*p++ = '\n';
	*p = '\0';
}
/*
**  PUTLINE -- put a line like fputs obeying SMTP conventions
**
**	This routine always guarantees outputing a newline (or CRLF,
**	as appropriate) at the end of the string.
**
**	Parameters:
**		l -- line to put.
**		mci -- the mailer connection information.
**
**	Returns:
**		none
**
**	Side Effects:
**		output of l to fp.
*/

void
putline(l, mci)
	register char *l;
	register MCI *mci;
{
	putxline(l, strlen(l), mci, PXLF_MAPFROM);
}
/*
**  PUTXLINE -- putline with flags bits.
**
**	This routine always guarantees outputing a newline (or CRLF,
**	as appropriate) at the end of the string.
**
**	Parameters:
**		l -- line to put.
**		len -- the length of the line.
**		mci -- the mailer connection information.
**		pxflags -- flag bits:
**		    PXLF_MAPFROM -- map From_ to >From_.
**		    PXLF_STRIP8BIT -- strip 8th bit.
**		    PXLF_HEADER -- map bare newline in header to newline space.
**
**	Returns:
**		none
**
**	Side Effects:
**		output of l to fp.
*/

void
putxline(l, len, mci, pxflags)
	register char *l;
	size_t len;
	register MCI *mci;
	int pxflags;
{
	register char *p, *end;
	int slop = 0;
	size_t eol_len = strlen(mci->mci_mailer->m_eol);

	/* strip out 0200 bits -- these can look like TELNET protocol */
	if (bitset(MCIF_7BIT, mci->mci_flags) ||
	    bitset(PXLF_STRIP8BIT, pxflags))
	{
		register char svchar;

		for (p = l; (svchar = *p) != '\0'; ++p)
			if (bitset(0200, svchar))
				*p = svchar &~ 0200;
	}

	end = l + len;
	do
	{
		/* find the end of the line */
		p = memchr(l, '\n', end - l);
		if (p == NULL)
			p = end;

		if (TrafficLogFile != NULL)
			fprintf(TrafficLogFile, "%05d >>> ", (int) getpid());

		/* check for line overflow */
		while (mci->mci_mailer->m_linelimit > 0 &&
		       (p - l + slop) > mci->mci_mailer->m_linelimit)
		{
			char *l_base = l;
			register char *q = &l[mci->mci_mailer->m_linelimit - slop - 1];

			if (l[0] == '.' && slop == 0 &&
			    bitnset(M_XDOT, mci->mci_mailer->m_flags))
			{
				(void) putc('.', mci->mci_out);
				if (!bitset(MCIF_INHEADER, mci->mci_flags))
					mci->mci_contentlen++;
				if (TrafficLogFile != NULL)
					(void) putc('.', TrafficLogFile);
			}
			else if (l[0] == 'F' && slop == 0 &&
				 bitset(PXLF_MAPFROM, pxflags) &&
				 strncmp(l, "From ", 5) == 0 &&
				 bitnset(M_ESCFROM, mci->mci_mailer->m_flags))
			{
				(void) putc('>', mci->mci_out);
				if (!bitset(MCIF_INHEADER, mci->mci_flags))
					mci->mci_contentlen++;
				if (TrafficLogFile != NULL)
					(void) putc('>', TrafficLogFile);
			}
			while (l < q)
			{
				(void) putc(*l++, mci->mci_out);
				if (!bitset(MCIF_INHEADER, mci->mci_flags))
					mci->mci_contentlen++;
			}
			(void) putc('!', mci->mci_out);
			if (!bitset(MCIF_INHEADER, mci->mci_flags))
				mci->mci_contentlen++;
			fputs(mci->mci_mailer->m_eol, mci->mci_out);
			if (!bitset(MCIF_INHEADER, mci->mci_flags))
				mci->mci_contentlen += eol_len;
			(void) putc(' ', mci->mci_out);
			if (!bitset(MCIF_INHEADER, mci->mci_flags))
				mci->mci_contentlen++;
			if (TrafficLogFile != NULL)
			{
				for (l = l_base; l < q; l++)
					(void) putc(*l, TrafficLogFile);
				fprintf(TrafficLogFile, "!\n%05d >>>  ",
					(int) getpid());
			}
			slop = 1;
		}

		/* output last part */
		if (l[0] == '.' && slop == 0 &&
		    bitnset(M_XDOT, mci->mci_mailer->m_flags))
		{
			(void) putc('.', mci->mci_out);
			if (!bitset(MCIF_INHEADER, mci->mci_flags))
				mci->mci_contentlen++;
			if (TrafficLogFile != NULL)
				(void) putc('.', TrafficLogFile);
		}
		else if (l[0] == 'F' && slop == 0 &&
			 bitset(PXLF_MAPFROM, pxflags) &&
			 strncmp(l, "From ", 5) == 0 &&
			 bitnset(M_ESCFROM, mci->mci_mailer->m_flags))
		{
			(void) putc('>', mci->mci_out);
			if (!bitset(MCIF_INHEADER, mci->mci_flags))
				mci->mci_contentlen++;
			if (TrafficLogFile != NULL)
				(void) putc('>', TrafficLogFile);
		}
		for ( ; l < p; ++l)
		{
			if (TrafficLogFile != NULL)
				(void) putc(*l, TrafficLogFile);
			(void) putc(*l, mci->mci_out);
			if (!bitset(MCIF_INHEADER, mci->mci_flags))
				mci->mci_contentlen++;
		}
		if (TrafficLogFile != NULL)
			(void) putc('\n', TrafficLogFile);
		fputs(mci->mci_mailer->m_eol, mci->mci_out);
		if (!bitset(MCIF_INHEADER, mci->mci_flags))
			mci->mci_contentlen += eol_len;
		if (l < end && *l == '\n')
		{
			if (*++l != ' ' && *l != '\t' && *l != '\0' &&
			    bitset(PXLF_HEADER, pxflags))
			{
				(void) putc(' ', mci->mci_out);
				if (!bitset(MCIF_INHEADER, mci->mci_flags))
					mci->mci_contentlen++;
				if (TrafficLogFile != NULL)
					(void) putc(' ', TrafficLogFile);
			}
		}
	} while (l < end);
}
/*
**  XUNLINK -- unlink a file, doing logging as appropriate.
**
**	Parameters:
**		f -- name of file to unlink.
**
**	Returns:
**		none.
**
**	Side Effects:
**		f is unlinked.
*/

void
xunlink(f)
	char *f;
{
	register int i;

	if (LogLevel > 98)
		sm_syslog(LOG_DEBUG, CurEnv->e_id,
			"unlink %s",
			f);

	i = unlink(f);
	if (i < 0 && LogLevel > 97)
		sm_syslog(LOG_DEBUG, CurEnv->e_id,
			"%s: unlink-fail %d",
			f, errno);
}
/*
**  XFCLOSE -- close a file, doing logging as appropriate.
**
**	Parameters:
**		fp -- file pointer for the file to close
**		a, b -- miscellaneous crud to print for debugging
**
**	Returns:
**		none.
**
**	Side Effects:
**		fp is closed.
*/

void
xfclose(fp, a, b)
	FILE *fp;
	char *a, *b;
{
	if (tTd(53, 99))
		printf("xfclose(%lx) %s %s\n", (u_long) fp, a, b);
#if XDEBUG
	if (fileno(fp) == 1)
		syserr("xfclose(%s %s): fd = 1", a, b);
#endif
	if (fclose(fp) < 0 && tTd(53, 99))
		printf("xfclose FAILURE: %s\n", errstring(errno));
}
/*
**  SFGETS -- "safe" fgets -- times out and ignores random interrupts.
**
**	Parameters:
**		buf -- place to put the input line.
**		siz -- size of buf.
**		fp -- file to read from.
**		timeout -- the timeout before error occurs.
**		during -- what we are trying to read (for error messages).
**
**	Returns:
**		NULL on error (including timeout).  This will also leave
**			buf containing a null string.
**		buf otherwise.
**
**	Side Effects:
**		none.
*/

static jmp_buf	CtxReadTimeout;
static void	readtimeout __P((time_t));

char *
sfgets(buf, siz, fp, timeout, during)
	char *buf;
	int siz;
	FILE *fp;
	time_t timeout;
	char *during;
{
	register EVENT *ev = NULL;
	register char *p;
	int save_errno;

	if (fp == NULL)
	{
		buf[0] = '\0';
		return NULL;
	}

	/* set the timeout */
	if (timeout != 0)
	{
		if (setjmp(CtxReadTimeout) != 0)
		{
			if (LogLevel > 1)
				sm_syslog(LOG_NOTICE, CurEnv->e_id,
				       "timeout waiting for input from %.100s during %s",
				       CurHostName ? CurHostName : "local",
				       during);
			buf[0] = '\0';
#if XDEBUG
			checkfd012(during);
#endif
			if (TrafficLogFile != NULL)
				fprintf(TrafficLogFile, "%05d <<< [TIMEOUT]\n",
					(int) getpid());
			errno = 0;
			return (NULL);
		}
		ev = setevent(timeout, readtimeout, 0);
	}

	/* try to read */
	p = NULL;
	errno = 0;
	while (!feof(fp) && !ferror(fp))
	{
		errno = 0;
		p = fgets(buf, siz, fp);
		if (p != NULL || errno != EINTR)
			break;
		clearerr(fp);
	}
	save_errno = errno;

	/* clear the event if it has not sprung */
	clrevent(ev);

	/* clean up the books and exit */
	LineNumber++;
	if (p == NULL)
	{
		buf[0] = '\0';
		if (TrafficLogFile != NULL)
			fprintf(TrafficLogFile, "%05d <<< [EOF]\n", (int) getpid());
		errno = save_errno;
		return (NULL);
	}
	if (TrafficLogFile != NULL)
		fprintf(TrafficLogFile, "%05d <<< %s", (int) getpid(), buf);
	if (SevenBitInput)
	{
		for (p = buf; *p != '\0'; p++)
			*p &= ~0200;
	}
	else if (!HasEightBits)
	{
		for (p = buf; *p != '\0'; p++)
		{
			if (bitset(0200, *p))
			{
				HasEightBits = TRUE;
				break;
			}
		}
	}
	return (buf);
}

/* ARGSUSED */
static void
readtimeout(timeout)
	time_t timeout;
{
	longjmp(CtxReadTimeout, 1);
}
/*
**  FGETFOLDED -- like fgets, but know about folded lines.
**
**	Parameters:
**		buf -- place to put result.
**		n -- bytes available.
**		f -- file to read from.
**
**	Returns:
**		input line(s) on success, NULL on error or EOF.
**		This will normally be buf -- unless the line is too
**			long, when it will be xalloc()ed.
**
**	Side Effects:
**		buf gets lines from f, with continuation lines (lines
**		with leading white space) appended.  CRLF's are mapped
**		into single newlines.  Any trailing NL is stripped.
*/

char *
fgetfolded(buf, n, f)
	char *buf;
	register int n;
	FILE *f;
{
	register char *p = buf;
	char *bp = buf;
	register int i;

	n--;
	while ((i = getc(f)) != EOF)
	{
		if (i == '\r')
		{
			i = getc(f);
			if (i != '\n')
			{
				if (i != EOF)
					(void) ungetc(i, f);
				i = '\r';
			}
		}
		if (--n <= 0)
		{
			/* allocate new space */
			char *nbp;
			int nn;

			nn = (p - bp);
			if (nn < MEMCHUNKSIZE)
				nn *= 2;
			else
				nn += MEMCHUNKSIZE;
			nbp = xalloc(nn);
			bcopy(bp, nbp, p - bp);
			p = &nbp[p - bp];
			if (bp != buf)
				free(bp);
			bp = nbp;
			n = nn - (p - bp);
		}
		*p++ = i;
		if (i == '\n')
		{
			LineNumber++;
			i = getc(f);
			if (i != EOF)
				(void) ungetc(i, f);
			if (i != ' ' && i != '\t')
				break;
		}
	}
	if (p == bp)
		return (NULL);
	if (p[-1] == '\n')
		p--;
	*p = '\0';
	return (bp);
}
/*
**  CURTIME -- return current time.
**
**	Parameters:
**		none.
**
**	Returns:
**		the current time.
**
**	Side Effects:
**		none.
*/

time_t
curtime()
{
	auto time_t t;

	(void) time(&t);
	return (t);
}
/*
**  ATOBOOL -- convert a string representation to boolean.
**
**	Defaults to "TRUE"
**
**	Parameters:
**		s -- string to convert.  Takes "tTyY" as true,
**			others as false.
**
**	Returns:
**		A boolean representation of the string.
**
**	Side Effects:
**		none.
*/

bool
atobool(s)
	register char *s;
{
	if (s == NULL || *s == '\0' || strchr("tTyY", *s) != NULL)
		return (TRUE);
	return (FALSE);
}
/*
**  ATOOCT -- convert a string representation to octal.
**
**	Parameters:
**		s -- string to convert.
**
**	Returns:
**		An integer representing the string interpreted as an
**		octal number.
**
**	Side Effects:
**		none.
*/

int
atooct(s)
	register char *s;
{
	register int i = 0;

	while (*s >= '0' && *s <= '7')
		i = (i << 3) | (*s++ - '0');
	return (i);
}
/*
**  BITINTERSECT -- tell if two bitmaps intersect
**
**	Parameters:
**		a, b -- the bitmaps in question
**
**	Returns:
**		TRUE if they have a non-null intersection
**		FALSE otherwise
**
**	Side Effects:
**		none.
*/

bool
bitintersect(a, b)
	BITMAP a;
	BITMAP b;
{
	int i;

	for (i = BITMAPBYTES / sizeof (int); --i >= 0; )
		if ((a[i] & b[i]) != 0)
			return (TRUE);
	return (FALSE);
}
/*
**  BITZEROP -- tell if a bitmap is all zero
**
**	Parameters:
**		map -- the bit map to check
**
**	Returns:
**		TRUE if map is all zero.
**		FALSE if there are any bits set in map.
**
**	Side Effects:
**		none.
*/

bool
bitzerop(map)
	BITMAP map;
{
	int i;

	for (i = BITMAPBYTES / sizeof (int); --i >= 0; )
		if (map[i] != 0)
			return (FALSE);
	return (TRUE);
}
/*
**  STRCONTAINEDIN -- tell if one string is contained in another
**
**	Parameters:
**		a -- possible substring.
**		b -- possible superstring.
**
**	Returns:
**		TRUE if a is contained in b.
**		FALSE otherwise.
*/

bool
strcontainedin(a, b)
	register char *a;
	register char *b;
{
	int la;
	int lb;
	int c;

	la = strlen(a);
	lb = strlen(b);
	c = *a;
	if (isascii(c) && isupper(c))
		c = tolower(c);
	for (; lb-- >= la; b++)
	{
		if (*b != c && isascii(*b) && isupper(*b) && tolower(*b) != c)
			continue;
		if (strncasecmp(a, b, la) == 0)
			return TRUE;
	}
	return FALSE;
}
/*
**  CHECKFD012 -- check low numbered file descriptors
**
**	File descriptors 0, 1, and 2 should be open at all times.
**	This routine verifies that, and fixes it if not true.
**
**	Parameters:
**		where -- a tag printed if the assertion failed
**
**	Returns:
**		none
*/

void
checkfd012(where)
	char *where;
{
#if XDEBUG
	register int i;

	for (i = 0; i < 3; i++)
		fill_fd(i, where);
#endif /* XDEBUG */
}
/*
**  CHECKFDOPEN -- make sure file descriptor is open -- for extended debugging
**
**	Parameters:
**		fd -- file descriptor to check.
**		where -- tag to print on failure.
**
**	Returns:
**		none.
*/

void
checkfdopen(fd, where)
	int fd;
	char *where;
{
#if XDEBUG
	struct stat st;

	if (fstat(fd, &st) < 0 && errno == EBADF)
	{
		syserr("checkfdopen(%d): %s not open as expected!", fd, where);
		printopenfds(TRUE);
	}
#endif
}
/*
**  CHECKFDS -- check for new or missing file descriptors
**
**	Parameters:
**		where -- tag for printing.  If null, take a base line.
**
**	Returns:
**		none
**
**	Side Effects:
**		If where is set, shows changes since the last call.
*/

void
checkfds(where)
	char *where;
{
	int maxfd;
	register int fd;
	bool printhdr = TRUE;
	int save_errno = errno;
	static BITMAP baseline;
	extern int DtableSize;

	if (DtableSize > 256)
		maxfd = 256;
	else
		maxfd = DtableSize;
	if (where == NULL)
		clrbitmap(baseline);

	for (fd = 0; fd < maxfd; fd++)
	{
		struct stat stbuf;

		if (fstat(fd, &stbuf) < 0 && errno != EOPNOTSUPP)
		{
			if (!bitnset(fd, baseline))
				continue;
			clrbitn(fd, baseline);
		}
		else if (!bitnset(fd, baseline))
			setbitn(fd, baseline);
		else
			continue;

		/* file state has changed */
		if (where == NULL)
			continue;
		if (printhdr)
		{
			sm_syslog(LOG_DEBUG, CurEnv->e_id,
				"%s: changed fds:",
				where);
			printhdr = FALSE;
		}
		dumpfd(fd, TRUE, TRUE);
	}
	errno = save_errno;
}
/*
**  PRINTOPENFDS -- print the open file descriptors (for debugging)
**
**	Parameters:
**		logit -- if set, send output to syslog; otherwise
**			print for debugging.
**
**	Returns:
**		none.
*/

#include <arpa/inet.h>

void
printopenfds(logit)
	bool logit;
{
	register int fd;
	extern int DtableSize;

	for (fd = 0; fd < DtableSize; fd++)
		dumpfd(fd, FALSE, logit);
}
/*
**  DUMPFD -- dump a file descriptor
**
**	Parameters:
**		fd -- the file descriptor to dump.
**		printclosed -- if set, print a notification even if
**			it is closed; otherwise print nothing.
**		logit -- if set, send output to syslog instead of stdout.
*/

void
dumpfd(fd, printclosed, logit)
	int fd;
	bool printclosed;
	bool logit;
{
	register char *p;
	char *hp;
#ifdef S_IFSOCK
	SOCKADDR sa;
#endif
	auto SOCKADDR_LEN_T slen;
	int i;
#if STAT64 > 0
	struct stat64 st;
#else
	struct stat st;
#endif
	char buf[200];

	p = buf;
	snprintf(p, SPACELEFT(buf, p), "%3d: ", fd);
	p += strlen(p);

	if (
#if STAT64 > 0
	    fstat64(fd, &st)
#else
	    fstat(fd, &st)
#endif
	    < 0)
	{
		if (errno != EBADF)
		{
			snprintf(p, SPACELEFT(buf, p), "CANNOT STAT (%s)",
				errstring(errno));
			goto printit;
		}
		else if (printclosed)
		{
			snprintf(p, SPACELEFT(buf, p), "CLOSED");
			goto printit;
		}
		return;
	}

	i = fcntl(fd, F_GETFL, NULL);
	if (i != -1)
	{
		snprintf(p, SPACELEFT(buf, p), "fl=0x%x, ", i);
		p += strlen(p);
	}

	snprintf(p, SPACELEFT(buf, p), "mode=%o: ", st.st_mode);
	p += strlen(p);
	switch (st.st_mode & S_IFMT)
	{
#ifdef S_IFSOCK
	  case S_IFSOCK:
		snprintf(p, SPACELEFT(buf, p), "SOCK ");
		p += strlen(p);
		slen = sizeof sa;
		if (getsockname(fd, &sa.sa, &slen) < 0)
			snprintf(p, SPACELEFT(buf, p), "(%s)", errstring(errno));
		else
		{
			hp = hostnamebyanyaddr(&sa);
			if (sa.sa.sa_family == AF_INET)
				snprintf(p, SPACELEFT(buf, p), "%s/%d",
					hp, ntohs(sa.sin.sin_port));
			else
				snprintf(p, SPACELEFT(buf, p), "%s", hp);
		}
		p += strlen(p);
		snprintf(p, SPACELEFT(buf, p), "->");
		p += strlen(p);
		slen = sizeof sa;
		if (getpeername(fd, &sa.sa, &slen) < 0)
			snprintf(p, SPACELEFT(buf, p), "(%s)", errstring(errno));
		else
		{
			hp = hostnamebyanyaddr(&sa);
			if (sa.sa.sa_family == AF_INET)
				snprintf(p, SPACELEFT(buf, p), "%s/%d",
					hp, ntohs(sa.sin.sin_port));
			else
				snprintf(p, SPACELEFT(buf, p), "%s", hp);
		}
		break;
#endif

	  case S_IFCHR:
		snprintf(p, SPACELEFT(buf, p), "CHR: ");
		p += strlen(p);
		goto defprint;

	  case S_IFBLK:
		snprintf(p, SPACELEFT(buf, p), "BLK: ");
		p += strlen(p);
		goto defprint;

#if defined(S_IFIFO) && (!defined(S_IFSOCK) || S_IFIFO != S_IFSOCK)
	  case S_IFIFO:
		snprintf(p, SPACELEFT(buf, p), "FIFO: ");
		p += strlen(p);
		goto defprint;
#endif

#ifdef S_IFDIR
	  case S_IFDIR:
		snprintf(p, SPACELEFT(buf, p), "DIR: ");
		p += strlen(p);
		goto defprint;
#endif

#ifdef S_IFLNK
	  case S_IFLNK:
		snprintf(p, SPACELEFT(buf, p), "LNK: ");
		p += strlen(p);
		goto defprint;
#endif

	  default:
defprint:
		if (sizeof st.st_ino > sizeof (long))
			snprintf(p, SPACELEFT(buf, p),
				 "dev=%d/%d, ino=%s, nlink=%d, u/gid=%d/%d, ",
				 major(st.st_dev), minor(st.st_dev),
				 quad_to_string(st.st_ino),
				 st.st_nlink, st.st_uid, st.st_gid);
		else
			snprintf(p, SPACELEFT(buf, p),
				"dev=%d/%d, ino=%lu, nlink=%d, u/gid=%d/%d, ",
				major(st.st_dev), minor(st.st_dev),
				(unsigned long) st.st_ino,
				st.st_nlink, st.st_uid, st.st_gid);
		if (sizeof st.st_size > sizeof (long))
			snprintf(p, SPACELEFT(buf, p), "size=%s",
				 quad_to_string(st.st_size));
		else
			snprintf(p, SPACELEFT(buf, p), "size=%lu",
				 (unsigned long) st.st_size);
		break;
	}

printit:
	if (logit)
		sm_syslog(LOG_DEBUG, CurEnv ? CurEnv->e_id : NULL,
			"%.800s", buf);
	else
		printf("%s\n", buf);
}
/*
**  SHORTEN_HOSTNAME -- strip local domain information off of hostname.
**
**	Parameters:
**		host -- the host to shorten (stripped in place).
**
**	Returns:
**		none.
*/

void
shorten_hostname(host)
	char host[];
{
	register char *p;
	char *mydom;
	int i;
	bool canon = FALSE;

	/* strip off final dot */
	p = &host[strlen(host) - 1];
	if (*p == '.')
	{
		*p = '\0';
		canon = TRUE;
	}

	/* see if there is any domain at all -- if not, we are done */
	p = strchr(host, '.');
	if (p == NULL)
		return;

	/* yes, we have a domain -- see if it looks like us */
	mydom = macvalue('m', CurEnv);
	if (mydom == NULL)
		mydom = "";
	i = strlen(++p);
	if ((canon ? strcasecmp(p, mydom) : strncasecmp(p, mydom, i)) == 0 &&
	    (mydom[i] == '.' || mydom[i] == '\0'))
		*--p = '\0';
}
/*
**  PROG_OPEN -- open a program for reading
**
**	Parameters:
**		argv -- the argument list.
**		pfd -- pointer to a place to store the file descriptor.
**		e -- the current envelope.
**
**	Returns:
**		pid of the process -- -1 if it failed.
*/

int
prog_open(argv, pfd, e)
	char **argv;
	int *pfd;
	ENVELOPE *e;
{
	int pid;
	int i;
	int saveerrno;
	int fdv[2];
	char *p, *q;
	char buf[MAXLINE + 1];
	extern int DtableSize;

	if (pipe(fdv) < 0)
	{
		syserr("%s: cannot create pipe for stdout", argv[0]);
		return -1;
	}
	pid = fork();
	if (pid < 0)
	{
		syserr("%s: cannot fork", argv[0]);
		close(fdv[0]);
		close(fdv[1]);
		return -1;
	}
	if (pid > 0)
	{
		/* parent */
		close(fdv[1]);
		*pfd = fdv[0];
		return pid;
	}

	/* child -- close stdin */
	close(0);

	/* stdout goes back to parent */
	close(fdv[0]);
	if (dup2(fdv[1], 1) < 0)
	{
		syserr("%s: cannot dup2 for stdout", argv[0]);
		_exit(EX_OSERR);
	}
	close(fdv[1]);

	/* stderr goes to transcript if available */
	if (e->e_xfp != NULL)
	{
		if (dup2(fileno(e->e_xfp), 2) < 0)
		{
			syserr("%s: cannot dup2 for stderr", argv[0]);
			_exit(EX_OSERR);
		}
	}

	/* this process has no right to the queue file */
	if (e->e_lockfp != NULL)
		close(fileno(e->e_lockfp));

	/* run as default user */
	endpwent();
	if (setgid(DefGid) < 0 && geteuid() == 0)
		syserr("prog_open: setgid(%ld) failed", (long) DefGid);
	if (setuid(DefUid) < 0 && geteuid() == 0)
		syserr("prog_open: setuid(%ld) failed", (long) DefUid);

	/* run in some directory */
	if (ProgMailer != NULL)
		p = ProgMailer->m_execdir;
	else
		p = NULL;
	for (; p != NULL; p = q)
	{
		q = strchr(p, ':');
		if (q != NULL)
			*q = '\0';
		expand(p, buf, sizeof buf, e);
		if (q != NULL)
			*q++ = ':';
		if (buf[0] != '\0' && chdir(buf) >= 0)
			break;
	}
	if (p == NULL)
	{
		/* backup directories */
		if (chdir("/tmp") < 0)
			(void) chdir("/");
	}

	/* arrange for all the files to be closed */
	for (i = 3; i < DtableSize; i++)
	{
		register int j;

		if ((j = fcntl(i, F_GETFD, 0)) != -1)
			(void) fcntl(i, F_SETFD, j | 1);
	}

	/* now exec the process */
	execve(argv[0], (ARGV_T) argv, (ARGV_T) UserEnviron);

	/* woops!  failed */
	saveerrno = errno;
	syserr("%s: cannot exec", argv[0]);
	if (transienterror(saveerrno))
		_exit(EX_OSERR);
	_exit(EX_CONFIG);
	return -1;	/* avoid compiler warning on IRIX */
}
/*
**  GET_COLUMN  -- look up a Column in a line buffer
**
**	Parameters:
**		line -- the raw text line to search.
**		col -- the column number to fetch.
**		delim -- the delimiter between columns.  If null,
**			use white space.
**		buf -- the output buffer.
**		buflen -- the length of buf.
**
**	Returns:
**		buf if successful.
**		NULL otherwise.
*/

char *
get_column(line, col, delim, buf, buflen)
	char line[];
	int col;
	char delim;
	char buf[];
	int buflen;
{
	char *p;
	char *begin, *end;
	int i;
	char delimbuf[4];
	
	if (delim == '\0')
		strcpy(delimbuf, "\n\t ");
	else
	{
		delimbuf[0] = delim;
		delimbuf[1] = '\0';
	}

	p = line;
	if (*p == '\0')
		return NULL;			/* line empty */
	if (*p == delim && col == 0)
		return NULL;			/* first column empty */

	begin = line;

	if (col == 0 && delim == '\0')
	{
		while (*begin != '\0' && isascii(*begin) && isspace(*begin))
			begin++;
	}

	for (i = 0; i < col; i++)
	{
		if ((begin = strpbrk(begin, delimbuf)) == NULL)
			return NULL;		/* no such column */
		begin++;
		if (delim == '\0')
		{
			while (*begin != '\0' && isascii(*begin) && isspace(*begin))
				begin++;
		}
	}
	
	end = strpbrk(begin, delimbuf);
	if (end == NULL)
		i = strlen(begin);
	else
		i = end - begin;
	if (i >= buflen)
		i = buflen - 1;
	strncpy(buf, begin, i);
	buf[i] = '\0';
	return buf;
}
/*
**  CLEANSTRCPY -- copy string keeping out bogus characters
**
**	Parameters:
**		t -- "to" string.
**		f -- "from" string.
**		l -- length of space available in "to" string.
**
**	Returns:
**		none.
*/

void
cleanstrcpy(t, f, l)
	register char *t;
	register char *f;
	int l;
{
	/* check for newlines and log if necessary */
	(void) denlstring(f, TRUE, TRUE);

	l--;
	while (l > 0 && *f != '\0')
	{
		if (isascii(*f) &&
		    (isalnum(*f) || strchr("!#$%&'*+-./^_`{|}~", *f) != NULL))
		{
			l--;
			*t++ = *f;
		}
		f++;
	}
	*t = '\0';
}
/*
**  DENLSTRING -- convert newlines in a string to spaces
**
**	Parameters:
**		s -- the input string
**		strict -- if set, don't permit continuation lines.
**		logattacks -- if set, log attempted attacks.
**
**	Returns:
**		A pointer to a version of the string with newlines
**		mapped to spaces.  This should be copied.
*/

char *
denlstring(s, strict, logattacks)
	char *s;
	bool strict;
	bool logattacks;
{
	register char *p;
	int l;
	static char *bp = NULL;
	static int bl = 0;

	p = s;
	while ((p = strchr(p, '\n')) != NULL)
		if (strict || (*++p != ' ' && *p != '\t'))
			break;
	if (p == NULL)
		return s;

	l = strlen(s) + 1;
	if (bl < l)
	{
		/* allocate more space */
		if (bp != NULL)
			free(bp);
		bp = xalloc(l);
		bl = l;
	}
	strcpy(bp, s);
	for (p = bp; (p = strchr(p, '\n')) != NULL; )
		*p++ = ' ';

	if (logattacks)
	{
		sm_syslog(LOG_NOTICE, CurEnv->e_id,
			"POSSIBLE ATTACK from %.100s: newline in string \"%s\"",
			RealHostName == NULL ? "[UNKNOWN]" : RealHostName,
			shortenstring(bp, MAXSHORTSTR));
	}

	return bp;
}
/*
**  PATH_IS_DIR -- check to see if file exists and is a directory.
**
**	There are some additional checks for security violations in
**	here.  This routine is intended to be used for the host status
**	support.
**
**	Parameters:
**		pathname -- pathname to check for directory-ness.
**		createflag -- if set, create directory if needed.
**
**	Returns:
**		TRUE -- if the indicated pathname is a directory
**		FALSE -- otherwise
*/

int
path_is_dir(pathname, createflag)
	char *pathname;
	bool createflag;
{
	struct stat statbuf;

#if HASLSTAT
	if (lstat(pathname, &statbuf) < 0)
#else
	if (stat(pathname, &statbuf) < 0)
#endif
	{
		if (errno != ENOENT || !createflag)
			return FALSE;
		if (mkdir(pathname, 0755) < 0)
			return FALSE;
		return TRUE;
	}
	if (!S_ISDIR(statbuf.st_mode))
	{
		errno = ENOTDIR;
		return FALSE;
	}

	/* security: don't allow writable directories */
	if (bitset(S_IWGRP|S_IWOTH, statbuf.st_mode))
	{
		errno = EACCES;
		return FALSE;
	}

	return TRUE;
}
/*
**  PROC_LIST_ADD -- add process id to list of our children
**
**	Parameters:
**		pid -- pid to add to list.
**
**	Returns:
**		none
*/

struct procs
{
	pid_t	proc_pid;
	char 	*proc_task;
};

static struct procs	*ProcListVec	= NULL;
static int	ProcListSize	= 0;

#define NO_PID		((pid_t) 0)
#ifndef PROC_LIST_SEG
# define PROC_LIST_SEG	32		/* number of pids to alloc at a time */
#endif

void
proc_list_add(pid, task)
	pid_t pid;
	char *task;
{
	int i;

	for (i = 0; i < ProcListSize; i++)
	{
		if (ProcListVec[i].proc_pid == NO_PID)
			break;
	}
	if (i >= ProcListSize)
	{
		/* probe the existing vector to avoid growing infinitely */
		proc_list_probe();

		/* now scan again */
		for (i = 0; i < ProcListSize; i++)
		{
			if (ProcListVec[i].proc_pid == NO_PID)
				break;
		}
	}
	if (i >= ProcListSize)
	{
		/* grow process list */
		struct procs *npv;

		npv = (struct procs *) xalloc(sizeof (struct procs) * (ProcListSize + PROC_LIST_SEG));
		if (ProcListSize > 0)
		{
			bcopy(ProcListVec, npv, ProcListSize *
						sizeof (struct procs));
			free(ProcListVec);
		}
		for (i = ProcListSize; i < ProcListSize + PROC_LIST_SEG; i++)
		{
			npv[i].proc_pid = NO_PID;
			npv[i].proc_task = NULL;
		}
		i = ProcListSize;
		ProcListSize += PROC_LIST_SEG;
		ProcListVec = npv;
	}
	ProcListVec[i].proc_pid = pid;
	ProcListVec[i].proc_task = newstr(task);

	/* if process adding itself, it's not a child */
	if (pid != getpid())
		CurChildren++;
}
/*
**  PROC_LIST_SET -- set pid task in process list
**
**	Parameters:
**		pid -- pid to set
**		task -- task of pid
**
**	Returns:
**		none.
*/

void
proc_list_set(pid, task)
	pid_t pid;
	char *task;
{
	int i;

	for (i = 0; i < ProcListSize; i++)
	{
		if (ProcListVec[i].proc_pid == pid)
		{
			if (ProcListVec[i].proc_task != NULL)
				free(ProcListVec[i].proc_task);
			ProcListVec[i].proc_task = newstr(task);
			break;
		}
	}
}
/*
**  PROC_LIST_DROP -- drop pid from process list
**
**	Parameters:
**		pid -- pid to drop
**
**	Returns:
**		none.
*/

void
proc_list_drop(pid)
	pid_t pid;
{
	int i;

	for (i = 0; i < ProcListSize; i++)
	{
		if (ProcListVec[i].proc_pid == pid)
		{
			ProcListVec[i].proc_pid = NO_PID;
			if (ProcListVec[i].proc_task != NULL)
			{
				free(ProcListVec[i].proc_task);
				ProcListVec[i].proc_task = NULL;
			}
			break;
		}
	}
	if (CurChildren > 0)
		CurChildren--;
}
/*
**  PROC_LIST_CLEAR -- clear the process list
**
**	Parameters:
**		none.
**
**	Returns:
**		none.
*/

void
proc_list_clear()
{
	int i;

	/* start from 1 since 0 is the daemon itself */
	for (i = 1; i < ProcListSize; i++)
	{
		ProcListVec[i].proc_pid = NO_PID;
		if (ProcListVec[i].proc_task != NULL)
		{
			free(ProcListVec[i].proc_task);
			ProcListVec[i].proc_task = NULL;
		}
	}
	CurChildren = 0;
}
/*
**  PROC_LIST_PROBE -- probe processes in the list to see if they still exist
**
**	Parameters:
**		none
**
**	Returns:
**		none
*/

void
proc_list_probe()
{
	int i;

	/* start from 1 since 0 is the daemon itself */
	for (i = 1; i < ProcListSize; i++)
	{
		if (ProcListVec[i].proc_pid == NO_PID)
			continue;
		if (kill(ProcListVec[i].proc_pid, 0) < 0)
		{
			if (LogLevel > 3)
				sm_syslog(LOG_DEBUG, CurEnv->e_id,
					"proc_list_probe: lost pid %d",
					(int) ProcListVec[i].proc_pid);
			ProcListVec[i].proc_pid = NO_PID;
			if (ProcListVec[i].proc_task != NULL)
			{
				free(ProcListVec[i].proc_task);
				ProcListVec[i].proc_task = NULL;
			}
			CurChildren--;
		}
	}
	if (CurChildren < 0)
		CurChildren = 0;
}
/*
**  PROC_LIST_DISPLAY -- display the process list
**
**	Parameters:
**		out -- output file pointer
**
**	Returns:
**		none.
*/

void
proc_list_display(out)
	FILE *out;
{
	int i;

	for (i = 0; i < ProcListSize; i++)
	{
		if (ProcListVec[i].proc_pid == NO_PID)
			continue;

		fprintf(out, "%d %s%s\n", (int) ProcListVec[i].proc_pid,
			ProcListVec[i].proc_task != NULL ?
			ProcListVec[i].proc_task : "(unknown)",
			(OpMode == MD_SMTP ||
			 OpMode == MD_DAEMON ||
			 OpMode == MD_ARPAFTP) ? "\r" : "");
	}
}
/*
**  SM_STRCASECMP -- 8-bit clean version of strcasecmp
**
**	Thank you, vendors, for making this all necessary.
*/

/*
 * Copyright (c) 1987, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#if defined(LIBC_SCCS) && !defined(lint)
static char sccsid[] = "@@(#)strcasecmp.c	8.1 (Berkeley) 6/4/93";
#endif /* LIBC_SCCS and not lint */

/*
 * This array is designed for mapping upper and lower case letter
 * together for a case independent comparison.  The mappings are
 * based upon ascii character sequences.
 */
static const u_char charmap[] = {
	0000, 0001, 0002, 0003, 0004, 0005, 0006, 0007,
	0010, 0011, 0012, 0013, 0014, 0015, 0016, 0017,
	0020, 0021, 0022, 0023, 0024, 0025, 0026, 0027,
	0030, 0031, 0032, 0033, 0034, 0035, 0036, 0037,
	0040, 0041, 0042, 0043, 0044, 0045, 0046, 0047,
	0050, 0051, 0052, 0053, 0054, 0055, 0056, 0057,
	0060, 0061, 0062, 0063, 0064, 0065, 0066, 0067,
	0070, 0071, 0072, 0073, 0074, 0075, 0076, 0077,
	0100, 0141, 0142, 0143, 0144, 0145, 0146, 0147,
	0150, 0151, 0152, 0153, 0154, 0155, 0156, 0157,
	0160, 0161, 0162, 0163, 0164, 0165, 0166, 0167,
	0170, 0171, 0172, 0133, 0134, 0135, 0136, 0137,
	0140, 0141, 0142, 0143, 0144, 0145, 0146, 0147,
	0150, 0151, 0152, 0153, 0154, 0155, 0156, 0157,
	0160, 0161, 0162, 0163, 0164, 0165, 0166, 0167,
	0170, 0171, 0172, 0173, 0174, 0175, 0176, 0177,
	0200, 0201, 0202, 0203, 0204, 0205, 0206, 0207,
	0210, 0211, 0212, 0213, 0214, 0215, 0216, 0217,
	0220, 0221, 0222, 0223, 0224, 0225, 0226, 0227,
	0230, 0231, 0232, 0233, 0234, 0235, 0236, 0237,
	0240, 0241, 0242, 0243, 0244, 0245, 0246, 0247,
	0250, 0251, 0252, 0253, 0254, 0255, 0256, 0257,
	0260, 0261, 0262, 0263, 0264, 0265, 0266, 0267,
	0270, 0271, 0272, 0273, 0274, 0275, 0276, 0277,
	0300, 0301, 0302, 0303, 0304, 0305, 0306, 0307,
	0310, 0311, 0312, 0313, 0314, 0315, 0316, 0317,
	0320, 0321, 0322, 0323, 0324, 0325, 0326, 0327,
	0330, 0331, 0332, 0333, 0334, 0335, 0336, 0337,
	0340, 0341, 0342, 0343, 0344, 0345, 0346, 0347,
	0350, 0351, 0352, 0353, 0354, 0355, 0356, 0357,
	0360, 0361, 0362, 0363, 0364, 0365, 0366, 0367,
	0370, 0371, 0372, 0373, 0374, 0375, 0376, 0377,
};

int
sm_strcasecmp(s1, s2)
	const char *s1, *s2;
{
	register const u_char *cm = charmap,
			*us1 = (const u_char *)s1,
			*us2 = (const u_char *)s2;

	while (cm[*us1] == cm[*us2++])
		if (*us1++ == '\0')
			return (0);
	return (cm[*us1] - cm[*--us2]);
}

int
sm_strncasecmp(s1, s2, n)
	const char *s1, *s2;
	register size_t n;
{
	if (n != 0) {
		register const u_char *cm = charmap,
				*us1 = (const u_char *)s1,
				*us2 = (const u_char *)s2;

		do {
			if (cm[*us1] != cm[*us2++])
				return (cm[*us1] - cm[*--us2]);
			if (*us1++ == '\0')
				break;
		} while (--n != 0);
	}
	return (0);
}
@


1.17
log
@sendmail 8.9.3
@
text
@@


1.16
log
@sendmail 8.9.2
@
text
@d14 1
a14 1
static char sccsid[] = "@@(#)util.c	8.167 (Berkeley) 12/1/1998";
d1029 1
a1046 1
			errno = 0;
d1054 1
d1062 1
d1071 1
d1083 1
@


1.15
log
@Update to sendmail.8.9.1a which adds support for MaxMimeHeaderLength option, to help avoid buffer oflows in stupid clients (only if enabled in .cf file)
@
text
@d14 1
a14 1
static char sccsid[] = "@@(#)util.c	8.159 (Berkeley) 7/1/98";
d207 2
a208 2
	** If have to rebalance an already short enough string,
	** need to do it within allocated space.
d250 1
a250 1
			else if (*ptr == '"' && !backslash && parencount == 0)
d2025 7
a2031 1
static pid_t	*ProcListVec	= NULL;
d2040 1
a2040 1
proc_list_add(pid)
d2042 1
a2044 1
	extern void proc_list_probe __P((void));
d2048 1
a2048 1
		if (ProcListVec[i] == NO_PID)
d2059 1
a2059 1
			if (ProcListVec[i] == NO_PID)
d2066 1
a2066 1
		pid_t *npv;
d2068 1
a2068 1
		npv = (pid_t *) xalloc(sizeof (pid_t) * (ProcListSize + PROC_LIST_SEG));
d2071 2
a2072 1
			bcopy(ProcListVec, npv, ProcListSize * sizeof (pid_t));
d2076 4
a2079 1
			npv[i] = NO_PID;
d2084 35
a2118 2
	ProcListVec[i] = pid;
	CurChildren++;
d2138 1
a2138 1
		if (ProcListVec[i] == pid)
d2140 6
a2145 1
			ProcListVec[i] = NO_PID;
d2167 10
a2176 2
	for (i = 0; i < ProcListSize; i++)
		ProcListVec[i] = NO_PID;
d2194 2
a2195 1
	for (i = 0; i < ProcListSize; i++)
d2197 1
a2197 1
		if (ProcListVec[i] == NO_PID)
d2199 1
a2199 1
		if (kill(ProcListVec[i], 0) < 0)
d2204 7
a2210 2
					ProcListVec[i]);
			ProcListVec[i] = NO_PID;
d2216 29
@


1.14
log
@something hosed the sendmail import; fix up by hand
@
text
@d177 176
@


1.13
log
@Upgrade to sendmail 8.8.8
@
text
@d2 2
a3 1
 * Copyright (c) 1983, 1995-1997 Eric P. Allman
d7 3
a9 15
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
a10 11
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
d14 1
a14 1
static char sccsid[] = "@@(#)util.c	8.137 (Berkeley) 10/22/97";
d61 116
d383 1
a383 1
			if (c == MACROEXPAND)
d386 2
d389 2
d639 1
d674 2
d685 2
d691 1
d693 3
d697 2
d700 2
d703 2
d720 2
d731 2
d741 2
d747 2
d755 2
d841 1
a841 1
static void	readtimeout();
d927 1
a1318 1
	char *fmtstr;
d1324 3
d1328 1
d1335 7
a1341 1
	if (fstat(fd, &st) < 0)
d1435 12
d1448 2
a1449 1
			fmtstr = "dev=%d/%d, ino=%d, nlink=%d, u/gid=%d/%d, size=%qd";
d1451 2
a1452 4
			fmtstr = "dev=%d/%d, ino=%d, nlink=%d, u/gid=%d/%d, size=%ld";
		snprintf(p, SPACELEFT(buf, p), fmtstr,
			major(st.st_dev), minor(st.st_dev), st.st_ino,
			st.st_nlink, st.st_uid, st.st_gid, st.st_size);
a1463 49
**  SHORTENSTRING -- return short version of a string
**
**	If the string is already short, just return it.  If it is too
**	long, return the head and tail of the string.
**
**	Parameters:
**		s -- the string to shorten.
**		m -- the max length of the string.
**
**	Returns:
**		Either s or a short version of s.
*/

#ifndef MAXSHORTSTR
# define MAXSHORTSTR	203
#endif

char *
shortenstring(s, m)
	register const char *s;
	int m;
{
	int l;
	static char buf[MAXSHORTSTR + 1];

	l = strlen(s);
	if (l < m)
		return (char *) s;
	if (m > MAXSHORTSTR)
		m = MAXSHORTSTR;
	else if (m < 10)
	{
		if (m < 5)
		{
			strncpy(buf, s, m);
			buf[m] = '\0';
			return buf;
		}
		strncpy(buf, s, m - 3);
		strcpy(buf + m - 3, "...");
		return buf;
	}
	m = (m - 3) / 2;
	strncpy(buf, s, m);
	strcpy(buf + m, "...");
	strcpy(buf + m + 3, s + l - m);
	return buf;
}
/*
d1579 1
a1579 1
	if (setgid(DefGid) < 0)
d1581 1
a1581 1
	if (setuid(DefUid) < 0)
d1784 1
a1784 1
			shortenstring(bp, 203));
@


1.12
log
@sendmail 8.8.7.
@
text
@d36 1
a36 1
static char sccsid[] = "@@(#)util.c	8.133 (Berkeley) 8/1/97";
d523 1
d630 2
a631 1
			if (*++l != ' ' && *l != '\t' && *l != '\0')
a1062 1
	struct stat stbuf;
a1202 1
	extern char *hostnamebyanyaddr();
d1314 1
a1314 1
		sm_syslog(LOG_DEBUG, CurEnv->e_id,
@


1.11
log
@Sendmail 8.8.6.
@
text
@d36 1
a36 1
static char sccsid[] = "@@(#)util.c	8.129 (Berkeley) 6/11/97";
a538 1
	register char svchar;
d545 2
d567 1
a569 2
			svchar = *q;
			*q = '\0';
d586 2
a587 1
			fputs(l, mci->mci_out);
d593 1
a593 1
				for ( ; l < q; ++l)	
a597 2
			*q = svchar;
			l = q;
d627 1
a627 1
		if (*l == '\n')
d1064 1
a1064 15
	{
		if (fstat(i, &stbuf) < 0 && errno == EBADF)
		{
			/* oops.... */
			int fd;

			syserr("%s: fd %d not open", where, i);
			fd = open("/dev/null", i == 0 ? O_RDONLY : O_WRONLY, 0666);
			if (fd != i)
			{
				(void) dup2(fd, i);
				(void) close(fd);
			}
		}
	}
d1198 2
a1199 1
	auto int slen;
d1224 2
a1225 2
	slen = fcntl(fd, F_GETFL, NULL);
	if (slen != -1)
d1227 1
a1227 1
		snprintf(p, SPACELEFT(buf, p), "fl=0x%x, ", slen);
@


1.10
log
@Sendmail 8.8.5.
@
text
@d2 1
a2 1
 * Copyright (c) 1983, 1995, 1996 Eric P. Allman
d36 1
a36 1
static char sccsid[] = "@@(#)util.c	8.115 (Berkeley) 1/5/97";
a451 346
**  SAFEFILE -- return true if a file exists and is safe for a user.
**
**	Parameters:
**		fn -- filename to check.
**		uid -- user id to compare against.
**		gid -- group id to compare against.
**		uname -- user name to compare against (used for group
**			sets).
**		flags -- modifiers:
**			SFF_MUSTOWN -- "uid" must own this file.
**			SFF_NOSLINK -- file cannot be a symbolic link.
**		mode -- mode bits that must match.
**		st -- if set, points to a stat structure that will
**			get the stat info for the file.
**
**	Returns:
**		0 if fn exists, is owned by uid, and matches mode.
**		An errno otherwise.  The actual errno is cleared.
**
**	Side Effects:
**		none.
*/

#include <grp.h>

#ifndef S_IXOTH
# define S_IXOTH	(S_IEXEC >> 6)
#endif

#ifndef S_IXGRP
# define S_IXGRP	(S_IEXEC >> 3)
#endif

#ifndef S_IXUSR
# define S_IXUSR	(S_IEXEC)
#endif

#define ST_MODE_NOFILE	0171147		/* unlikely to occur */

int
safefile(fn, uid, gid, uname, flags, mode, st)
	char *fn;
	UID_T uid;
	GID_T gid;
	char *uname;
	int flags;
	int mode;
	struct stat *st;
{
	register char *p;
	register struct group *gr = NULL;
	int file_errno = 0;
	struct stat stbuf;
	struct stat fstbuf;

	if (tTd(44, 4))
		printf("safefile(%s, uid=%d, gid=%d, flags=%x, mode=%o):\n",
			fn, (int) uid, (int) gid, flags, mode);
	errno = 0;
	if (st == NULL)
		st = &fstbuf;

	/* first check to see if the file exists at all */
#ifdef HASLSTAT
	if ((bitset(SFF_NOSLINK, flags) ? lstat(fn, st)
					: stat(fn, st)) < 0)
#else
	if (stat(fn, st) < 0)
#endif
	{
		file_errno = errno;
	}
	else if (bitset(SFF_SETUIDOK, flags) &&
		 !bitset(S_IXUSR|S_IXGRP|S_IXOTH, st->st_mode) &&
		 S_ISREG(st->st_mode))
	{
		/*
		**  If final file is setuid, run as the owner of that
		**  file.  Gotta be careful not to reveal anything too
		**  soon here!
		*/

#ifdef SUID_ROOT_FILES_OK
		if (bitset(S_ISUID, st->st_mode))
#else
		if (bitset(S_ISUID, st->st_mode) && st->st_uid != 0)
#endif
		{
			uid = st->st_uid;
			uname = NULL;
		}
#ifdef SUID_ROOT_FILES_OK
		if (bitset(S_ISGID, st->st_mode))
#else
		if (bitset(S_ISGID, st->st_mode) && st->st_gid != 0)
#endif
			gid = st->st_gid;
	}

	if (!bitset(SFF_NOPATHCHECK, flags) ||
	    (uid == 0 && !bitset(SFF_ROOTOK, flags)))
	{
		/* check the path to the file for acceptability */
		for (p = fn; (p = strchr(++p, '/')) != NULL; *p = '/')
		{
			*p = '\0';
			if (stat(fn, &stbuf) < 0)
				break;
			if (uid == 0 && bitset(S_IWGRP|S_IWOTH, stbuf.st_mode))
				message("051 WARNING: writable directory %s",
					fn);
			if (uid == 0 && !bitset(SFF_ROOTOK, flags))
			{
				if (bitset(S_IXOTH, stbuf.st_mode))
					continue;
				break;
			}
			if (stbuf.st_uid == uid &&
			    bitset(S_IXUSR, stbuf.st_mode))
				continue;
			if (stbuf.st_gid == gid &&
			    bitset(S_IXGRP, stbuf.st_mode))
				continue;
#ifndef NO_GROUP_SET
			if (uname != NULL && !DontInitGroups &&
			    ((gr != NULL && gr->gr_gid == stbuf.st_gid) ||
			     (gr = getgrgid(stbuf.st_gid)) != NULL))
			{
				register char **gp;

				for (gp = gr->gr_mem; gp != NULL && *gp != NULL; gp++)
					if (strcmp(*gp, uname) == 0)
						break;
				if (gp != NULL && *gp != NULL &&
				    bitset(S_IXGRP, stbuf.st_mode))
					continue;
			}
#endif
			if (!bitset(S_IXOTH, stbuf.st_mode))
				break;
		}
		if (p != NULL)
		{
			int ret = errno;

			if (ret == 0)
				ret = EACCES;
			if (tTd(44, 4))
				printf("\t[dir %s] %s\n", fn, errstring(ret));
			*p = '/';
			return ret;
		}
	}

	/*
	**  If the target file doesn't exist, check the directory to
	**  ensure that it is writable by this user.
	*/

	if (file_errno != 0)
	{
		int ret = file_errno;

		if (tTd(44, 4))
			printf("\t%s\n", errstring(ret));

		errno = 0;
		if (!bitset(SFF_CREAT, flags))
			return ret;

		/* check to see if legal to create the file */
		p = strrchr(fn, '/');
		if (p == NULL)
			return ENOTDIR;
		*p = '\0';
		if (stat(fn, &stbuf) >= 0)
		{
			int md = S_IWRITE|S_IEXEC;
			if (stbuf.st_uid != uid)
				md >>= 6;
			if ((stbuf.st_mode & md) != md)
				errno = EACCES;
		}
		ret = errno;
		if (tTd(44, 4))
			printf("\t[final dir %s uid %d mode %lo] %s\n",
				fn, (int) stbuf.st_uid, (u_long) stbuf.st_mode,
				errstring(ret));
		*p = '/';
		st->st_mode = ST_MODE_NOFILE;
		return ret;
	}

#ifdef S_ISLNK
	if (bitset(SFF_NOSLINK, flags) && S_ISLNK(st->st_mode))
	{
		if (tTd(44, 4))
			printf("\t[slink mode %o]\tEPERM\n", st->st_mode);
		return EPERM;
	}
#endif
	if (bitset(SFF_REGONLY, flags) && !S_ISREG(st->st_mode))
	{
		if (tTd(44, 4))
			printf("\t[non-reg mode %o]\tEPERM\n", st->st_mode);
		return EPERM;
	}
	if (bitset(S_IWUSR|S_IWGRP|S_IWOTH, mode) &&
	    bitset(S_IXUSR|S_IXGRP|S_IXOTH, st->st_mode))
	{
		if (tTd(44, 4))
			printf("\t[exec bits %o]\tEPERM]\n", st->st_mode);
		return EPERM;
	}
	if (st->st_nlink > 1)
	{
		if (tTd(44, 4))
			printf("\t[link count %d]\tEPERM\n", st->st_nlink);
		return EPERM;
	}

	if (uid == 0 && bitset(SFF_OPENASROOT, flags))
		;
	else if (uid == 0 && !bitset(SFF_ROOTOK, flags))
		mode >>= 6;
	else if (st->st_uid != uid)
	{
		mode >>= 3;
		if (st->st_gid == gid)
			;
#ifndef NO_GROUP_SET
		else if (uname != NULL && !DontInitGroups &&
			 ((gr != NULL && gr->gr_gid == st->st_gid) ||
			  (gr = getgrgid(st->st_gid)) != NULL))
		{
			register char **gp;

			for (gp = gr->gr_mem; *gp != NULL; gp++)
				if (strcmp(*gp, uname) == 0)
					break;
			if (*gp == NULL)
				mode >>= 3;
		}
#endif
		else
			mode >>= 3;
	}
	if (tTd(44, 4))
		printf("\t[uid %d, nlink %d, stat %lo, mode %lo] ",
			(int) st->st_uid, (int) st->st_nlink,
			(u_long) st->st_mode, (u_long) mode);
	if ((st->st_uid == uid || st->st_uid == 0 ||
	     !bitset(SFF_MUSTOWN, flags)) &&
	    (st->st_mode & mode) == mode)
	{
		if (tTd(44, 4))
			printf("\tOK\n");
		return 0;
	}
	if (tTd(44, 4))
		printf("\tEACCES\n");
	return EACCES;
}
/*
**  SAFEFOPEN -- do a file open with extra checking
**
**	Parameters:
**		fn -- the file name to open.
**		omode -- the open-style mode flags.
**		cmode -- the create-style mode flags.
**		sff -- safefile flags.
**
**	Returns:
**		Same as fopen.
*/

#ifndef O_ACCMODE
# define O_ACCMODE	(O_RDONLY|O_WRONLY|O_RDWR)
#endif

FILE *
safefopen(fn, omode, cmode, sff)
	char *fn;
	int omode;
	int cmode;
	int sff;
{
	int rval;
	FILE *fp;
	int smode;
	struct stat stb, sta;

	if (bitset(O_CREAT, omode))
		sff |= SFF_CREAT;
	smode = 0;
	switch (omode & O_ACCMODE)
	{
	  case O_RDONLY:
		smode = S_IREAD;
		break;

	  case O_WRONLY:
		smode = S_IWRITE;
		break;

	  case O_RDWR:
		smode = S_IREAD|S_IWRITE;
		break;

	  default:
		smode = 0;
		break;
	}
	if (bitset(SFF_OPENASROOT, sff))
		rval = safefile(fn, 0, 0, NULL, sff, smode, &stb);
	else
		rval = safefile(fn, RealUid, RealGid, RealUserName,
				sff, smode, &stb);
	if (rval != 0)
	{
		errno = rval;
		return NULL;
	}
	if (stb.st_mode == ST_MODE_NOFILE)
		omode |= O_EXCL;

	fp = dfopen(fn, omode, cmode);
	if (fp == NULL)
		return NULL;
	if (bitset(O_EXCL, omode))
		return fp;
	if (fstat(fileno(fp), &sta) < 0 ||
	    sta.st_nlink != stb.st_nlink ||
	    sta.st_dev != stb.st_dev ||
	    sta.st_ino != stb.st_ino ||
	    sta.st_uid != stb.st_uid ||
	    sta.st_gid != stb.st_gid)
	{
		syserr("554 cannot open: file %s changed after open", fn);
		fclose(fp);
		errno = EPERM;
		return NULL;
	}
	return fp;
}
/*
a486 74
**  DFOPEN -- determined file open
**
**	This routine has the semantics of fopen, except that it will
**	keep trying a few times to make this happen.  The idea is that
**	on very loaded systems, we may run out of resources (inodes,
**	whatever), so this tries to get around it.
*/

struct omodes
{
	int	mask;
	int	mode;
	char	*farg;
} OpenModes[] =
{
	{ O_ACCMODE,		O_RDONLY,		"r"	},
	{ O_ACCMODE|O_APPEND,	O_WRONLY,		"w"	},
	{ O_ACCMODE|O_APPEND,	O_WRONLY|O_APPEND,	"a"	},
	{ O_TRUNC,		0,			"w+"	},
	{ O_APPEND,		O_APPEND,		"a+"	},
	{ 0,			0,			"r+"	},
};

FILE *
dfopen(filename, omode, cmode)
	char *filename;
	int omode;
	int cmode;
{
	register int tries;
	int fd;
	register struct omodes *om;
	struct stat st;

	for (om = OpenModes; om->mask != 0; om++)
		if ((omode & om->mask) == om->mode)
			break;

	for (tries = 0; tries < 10; tries++)
	{
		sleep((unsigned) (10 * tries));
		errno = 0;
		fd = open(filename, omode, cmode);
		if (fd >= 0)
			break;
		switch (errno)
		{
		  case ENFILE:		/* system file table full */
		  case EINTR:		/* interrupted syscall */
#ifdef ETXTBSY
		  case ETXTBSY:		/* Apollo: net file locked */
#endif
			continue;
		}
		break;
	}
	if (fd >= 0 && fstat(fd, &st) >= 0 && S_ISREG(st.st_mode))
	{
		int locktype;

		/* lock the file to avoid accidental conflicts */
		if ((omode & O_ACCMODE) != O_RDONLY)
			locktype = LOCK_EX;
		else
			locktype = LOCK_SH;
		(void) lockfile(fd, filename, NULL, locktype);
		errno = 0;
	}
	if (fd < 0)
		return NULL;
	else
		return fdopen(fd, om->farg);
}
/*
d508 1
a508 1
	putxline(l, mci, PXLF_MAPFROM);
d518 1
d532 1
a532 1
putxline(l, mci, pxflags)
d534 1
d538 1
a538 1
	register char *p;
d551 1
d555 1
a555 1
		p = strchr(l, '\n');
d557 1
a557 1
			p = &l[strlen(l)];
d591 6
a596 2
				fprintf(TrafficLogFile, "%s!\n%05d >>>  ",
					l, (int) getpid());
a618 2
		if (TrafficLogFile != NULL)
			fprintf(TrafficLogFile, "%.*s\n", p - l, l);
d620 3
d624 3
d637 1
a637 1
	} while (l[0] != '\0');
a657 1
# ifdef LOG
d659 3
a661 2
		syslog(LOG_DEBUG, "%s: unlink %s", CurEnv->e_id, f);
# endif /* LOG */
a663 1
# ifdef LOG
d665 3
a667 2
		syslog(LOG_DEBUG, "%s: unlink-fail %d", f, errno);
# endif /* LOG */
a740 1
# ifdef LOG
d742 1
a742 1
				syslog(LOG_NOTICE,
a745 1
# endif
a746 2
			usrerr("451 timeout waiting for input during %s",
				during);
d751 3
a957 40
**  WAITFOR -- wait for a particular process id.
**
**	Parameters:
**		pid -- process id to wait for.
**
**	Returns:
**		status of pid.
**		-1 if pid never shows up.
**
**	Side Effects:
**		none.
*/

int
waitfor(pid)
	pid_t pid;
{
#ifdef WAITUNION
	union wait st;
#else
	auto int st;
#endif
	pid_t i;

	do
	{
		errno = 0;
		i = wait(&st);
		if (i > 0)
			proc_list_drop(i);
	} while ((i >= 0 || errno == EINTR) && i != pid);
	if (i < 0)
		return -1;
#ifdef WAITUNION
	return st.w_status;
#else
	return st;
#endif
}
/*
d1159 3
a1161 1
			syslog(LOG_DEBUG, "%s: changed fds:", where);
a1326 1
#ifdef LOG
d1328 2
a1329 1
		syslog(LOG_DEBUG, "%.800s", buf);
a1330 1
#endif
a1637 1
#ifdef LOG
a1639 1
#endif
a1697 1
#ifdef LOG
d1700 2
a1701 1
		syslog(LOG_NOTICE, "POSSIBLE ATTACK from %.100s: newline in string \"%s\"",
a1704 1
#endif
d1711 4
d1731 3
d1735 1
d1748 8
a1886 1
#ifdef LOG
d1888 2
a1889 1
				syslog(LOG_DEBUG, "proc_list_probe: lost pid %d",
a1890 1
#endif
d1897 116
@


1.9
log
@Update to Sendmail 8.8.4, plus recent patches, plus OpenBSD support.
Also include entire example configuration subset.
Includes smrsh (using /usr/libexec/sm.bin).

Of the top of my head, the only things I removed from the distribution were
contrib/mail.local.linux, src/Makefiles, all the *.0 and *.ps files.
Our praliases man page replaces the distributed one, ours is better.
@
text
@d36 1
a36 1
static char sccsid[] = "@@(#)util.c	8.113 (Berkeley) 11/24/96";
d316 1
a316 1
				else
d673 3
a675 1
	if (uid == 0 && !bitset(SFF_ROOTOK, flags))
@


1.8
log
@Revert to my version of buildfname().  Allman's didn't work, ya know?
Also fix a slight buffer overflow in get_column(), pointed out by Allman.
@
text
@d2 1
a2 1
 * Copyright (c) 1983, 1995 Eric P. Allman
d36 1
a36 1
static char sccsid[] = "@@(#)util.c	8.84.1.4 (Berkeley) 9/16/96";
d218 1
a218 1
			printf("\n\t%08x=", *av);
d263 1
d268 1
a268 1
		printf("<null>");
d273 5
d282 6
a287 2
				putchar('$');
				continue;
d291 2
a292 1
				putchar('$');
d297 2
d305 4
a308 1
					printf("$%c", mp->metaname);
d314 4
a317 3
				if (!bitset(0200, *s))
					continue;
				printf("{%s}", macname(*s++ & 0377));
d321 4
a324 1
			(void) putchar('\\');
d327 1
d348 13
a360 2

		  default:
a362 1
			continue;
a363 2
		(void) putchar('\\');
		(void) putchar(c);
d365 2
d418 1
a418 1
buildfname(gecos, login, buf, bufsiz)
d422 1
a422 1
	int bufsiz;
d430 2
a431 2
	for (p = gecos; *p != '\0' && *p != ',' && *p != ';' && *p != '%'
		&& ((bp - buf) <= (bufsiz - 1)); p++)
d433 6
d441 2
a442 2
			(void) strncpy(bp, login, (bufsiz - (bp - buf) - 1));
			buf[bufsiz - 1] = '\0';
d444 1
a444 2
			while (*bp != '\0')
				bp++;
d494 2
a495 2
	uid_t uid;
	gid_t gid;
d509 1
a509 1
			fn, uid, gid, flags, mode);
d576 1
a576 1
			if (uname != NULL &&
d637 2
a638 2
			printf("\t[final dir %s uid %d mode %o] %s\n",
				fn, stbuf.st_uid, stbuf.st_mode,
d666 6
d681 1
a681 1
		else if (uname != NULL &&
d698 3
a700 2
		printf("\t[uid %d, stat %o, mode %o] ",
			st->st_uid, st->st_mode, mode);
d846 6
a851 6
	O_ACCMODE,		O_RDONLY,		"r",
	O_ACCMODE|O_APPEND,	O_WRONLY,		"w",
	O_ACCMODE|O_APPEND,	O_WRONLY|O_APPEND,	"a",
	O_TRUNC,		0,			"w+",
	O_APPEND,		O_APPEND,		"a+",
	0,			0,			"r+",
d975 1
a975 1
			fprintf(TrafficLogFile, "%05d >>> ", getpid());
d1007 1
a1007 1
					l, getpid());
d1021 9
d1096 1
a1096 1
		printf("xfclose(%x) %s %s\n", fp, a, b);
d1149 5
a1153 3
			syslog(LOG_NOTICE,
			    "timeout waiting for input from %.100s during %s",
			    CurHostName? CurHostName: "local", during);
d1187 1
a1187 1
			fprintf(TrafficLogFile, "%05d <<< [EOF]\n", getpid());
d1191 1
a1191 1
		fprintf(TrafficLogFile, "%05d <<< %s", getpid(), buf);
d1381 1
a1381 1
	int pid;
d1388 1
a1388 1
	int i;
d1394 2
d1514 1
a1514 1
		if (fstat(i, &stbuf) < 0 && errno != EOPNOTSUPP)
d1531 84
d1670 1
a1670 1
		if (printclosed || errno != EBADF)
d1676 5
d1945 4
a1948 2
	setgid(DefGid);
	setuid(DefUid);
d1991 1
d2040 1
a2040 1
		while (*begin && isspace(*begin))
d2051 1
a2051 1
			while (*begin && isspace(*begin))
d2058 1
a2058 1
		i = strlen(buf);
d2157 175
@


1.7
log
@bring up to 8.7.6
@
text
@d387 1
a387 1
buildfname(gecos, login, buf, buflen)
d391 1
a391 1
	int buflen;
d400 1
a400 1
		&& ((bp - buf) <= (buflen - 1)); p++)
d404 2
a405 1
			snprintf(bp, SPACELEFT(buf, bp), "%s",  login);
a406 1
			bp += strlen(bp);
d1872 1
a1872 1
	char delimbuf[3];
@


1.6
log
@kill unused var
@
text
@d36 1
a36 1
static char sccsid[] = "@@(#)util.c	8.84.1.2 (Berkeley) 3/4/96";
d377 1
d387 1
a387 1
buildfname(gecos, login, buf, bufsiz)
d391 1
a391 1
	int bufsiz;
d400 1
a400 1
		&& ((bp - buf) <= (bufsiz - 1)); p++)
d404 1
a404 2
			(void) strncpy(bp, login, (bufsiz - (bp - buf) - 1));
			buf[bufsiz - 1] = '\0';
d406 1
d1525 1
a1525 1
	sprintf(p, "%3d: ", fd);
d1532 2
a1533 1
			sprintf(p, "CANNOT STAT (%s)", errstring(errno));
d1542 1
a1542 1
		sprintf(p, "fl=0x%x, ", slen);
d1546 1
a1546 1
	sprintf(p, "mode=%o: ", st.st_mode);
d1552 1
a1552 1
		sprintf(p, "SOCK ");
d1556 1
a1556 1
			sprintf(p, "(%s)", errstring(errno));
d1561 2
a1562 1
				sprintf(p, "%s/%d", hp, ntohs(sa.sin.sin_port));
d1564 1
a1564 1
				sprintf(p, "%s", hp);
d1567 1
a1567 1
		sprintf(p, "->");
d1571 1
a1571 1
			sprintf(p, "(%s)", errstring(errno));
d1576 2
a1577 1
				sprintf(p, "%s/%d", hp, ntohs(sa.sin.sin_port));
d1579 1
a1579 1
				sprintf(p, "%s", hp);
d1585 1
a1585 1
		sprintf(p, "CHR: ");
d1590 1
a1590 1
		sprintf(p, "BLK: ");
d1596 1
a1596 1
		sprintf(p, "FIFO: ");
d1603 1
a1603 1
		sprintf(p, "DIR: ");
d1610 1
a1610 1
		sprintf(p, "LNK: ");
d1621 1
a1621 1
		sprintf(p, fmtstr,
d1854 1
d1862 1
a1862 1
get_column(line, col, delim, buf)
d1867 1
d1910 1
a1910 3
	{
		strcpy(buf, begin);
	}
d1912 5
a1916 4
	{
		strncpy(buf, begin, end - begin);
		buf[end - begin] = '\0';
	}
@


1.5
log
@sendmail gecos oflow -- found by mudge, this fix by downsj.  I knew about this
hole a month ago. OpenBSD is not vulnerable because you cannot set a gecos that
long -- bitblt and I fixed chfn & the other tools when we became aware of the
hole; we did not fix sendmail to avoid bringing attention to the sendmail hole
@
text
@a393 1
	int l;
@


1.4
log
@sendmail 8.7.5
@
text
@d386 1
a386 1
buildfname(gecos, login, buf)
d390 1
d399 2
a400 12
	/* find length of final string */
	l = 0;
	for (p = gecos; *p != '\0' && *p != ',' && *p != ';' && *p != '%'; p++)
	{
		if (*p == '&')
			l += strlen(login);
		else
			l++;
	}

	/* now fill in buf */
	for (p = gecos; *p != '\0' && *p != ',' && *p != ';' && *p != '%'; p++)
d404 2
a405 1
			(void) strcpy(bp, login);
@


1.3
log
@sendmail 8.7.4
@
text
@d36 1
a36 1
static char sccsid[] = "@@(#)util.c	8.84.1.1 (Berkeley) 2/18/96";
d993 1
a993 1
			if (*++l != ' ' && *l != '\t' && l[1] != '\0')
@


1.2
log
@Sendmail 8.7.3 from NetBSD
@
text
@d36 1
a36 1
static char sccsid[] = "@@(#)util.c	8.84 (Berkeley) 11/18/95";
d992 8
a999 1
			++l;
a2002 1
/*
a2010 1
*/
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
 * Copyright (c) 1983 Eric P. Allman
d36 1
a36 1
static char sccsid[] = "@@(#)util.c	8.39.1.5 (Berkeley) 3/5/95";
d60 1
d111 1
a111 2
		syserr("Out of memory!!");
		abort();
d211 1
d257 1
d259 1
a259 1
	register char *s;
d274 1
a274 1
			if (c == MATCHREPL || c == MACROEXPAND)
d279 9
d296 6
a315 3
		  case '\0':
			continue;

d333 2
d355 1
d385 1
d436 2
d461 2
d464 1
a464 1
safefile(fn, uid, gid, uname, flags, mode)
d471 1
d475 1
d477 1
d479 1
a479 1
	if (tTd(54, 4))
d483 2
d486 7
a492 1
	for (p = fn; (p = strchr(++p, '/')) != NULL; *p = '/')
d494 34
a527 4
		*p = '\0';
		if (stat(fn, &stbuf) < 0)
			break;
		if (uid == 0 && !bitset(SFF_ROOTOK, flags))
d529 17
a545 1
			if (bitset(S_IXOTH, stbuf.st_mode))
d547 17
a563 1
			break;
d565 1
a565 8
		if (stbuf.st_uid == uid && bitset(S_IXUSR, stbuf.st_mode))
			continue;
		if (stbuf.st_gid == gid && bitset(S_IXGRP, stbuf.st_mode))
			continue;
#ifndef NO_GROUP_SET
		if (uname != NULL &&
		    ((gr != NULL && gr->gr_gid == stbuf.st_gid) ||
		     (gr = getgrgid(stbuf.st_gid)) != NULL))
d567 1
a567 1
			register char **gp;
d569 6
a574 5
			for (gp = gr->gr_mem; *gp != NULL; gp++)
				if (strcmp(*gp, uname) == 0)
					break;
			if (*gp != NULL && bitset(S_IXGRP, stbuf.st_mode))
				continue;
a575 3
#endif
		if (!bitset(S_IXOTH, stbuf.st_mode))
			break;
a576 3
	if (p != NULL)
	{
		int ret = errno;
d578 4
a581 7
		if (ret == 0)
			ret = EACCES;
		if (tTd(54, 4))
			printf("\t[dir %s] %s\n", fn, errstring(ret));
		*p = '/';
		return ret;
	}
d583 1
a583 6
#ifdef HASLSTAT
	if ((bitset(SFF_NOSLINK, flags) ? lstat(fn, &stbuf)
					: stat(fn, &stbuf)) < 0)
#else
	if (stat(fn, &stbuf) < 0)
#endif
d585 1
a585 1
		int ret = errno;
d587 1
a587 1
		if (tTd(54, 4))
d591 23
d618 1
a618 1
	if (bitset(SFF_NOSLINK, flags) && S_ISLNK(stbuf.st_mode))
d620 2
a621 2
		if (tTd(54, 4))
			printf("\t[slink mode %o]\tEPERM\n", stbuf.st_mode);
d625 13
d641 1
a641 1
	else if (stbuf.st_uid != uid)
d644 1
a644 1
		if (stbuf.st_gid == gid)
d648 2
a649 2
			 ((gr != NULL && gr->gr_gid == stbuf.st_gid) ||
			  (gr = getgrgid(stbuf.st_gid)) != NULL))
d663 1
a663 1
	if (tTd(54, 4))
d665 2
a666 2
			stbuf.st_uid, stbuf.st_mode, mode);
	if ((stbuf.st_uid == uid || stbuf.st_uid == 0 ||
d668 1
a668 1
	    (stbuf.st_mode & mode) == mode)
d670 1
a670 1
		if (tTd(54, 4))
d674 1
a674 1
	if (tTd(54, 4))
d679 82
d779 1
a803 4
#ifndef O_ACCMODE
# define O_ACCMODE	(O_RDONLY|O_WRONLY|O_RDWR)
#endif

d886 1
d891 28
d924 2
a925 1
	if (bitset(MCIF_7BIT, mci->mci_flags))
d957 9
d1008 1
d1039 1
d1046 1
a1046 1
#ifdef XDEBUG
d1073 1
a1073 4
static int	readtimeout();
static EVENT	*GlobalTimeout = NULL;
static bool	EnableTimeout = FALSE;
static int	ReadProgress;
d1099 1
a1099 1
			    "timeout waiting for input from %s during %s\n",
d1106 1
a1106 1
#ifdef XDEBUG
d1111 1
a1111 4
		if (GlobalTimeout == NULL)
			ev = setevent(timeout, readtimeout, 0);
		else
			EnableTimeout = TRUE;
d1126 1
a1126 4
	if (GlobalTimeout == NULL)
		clrevent(ev);
	else
		EnableTimeout = FALSE;
d1139 2
a1140 1
	if (SevenBit)
a1142 12
	return (buf);
}

void
sfgetset(timeout)
	time_t timeout;
{
	/* cancel pending timer */
	if (GlobalTimeout != NULL)
	{
		clrevent(GlobalTimeout);
		GlobalTimeout = NULL;
d1144 1
a1144 3

	/* schedule fresh one if so requested */
	if (timeout != 0)
d1146 8
a1153 2
		ReadProgress = LineNumber;
		GlobalTimeout = setevent(timeout, readtimeout, timeout);
d1155 1
d1158 1
a1158 1
static
d1162 1
a1162 15
	/* terminate if ordinary timeout */
	if (GlobalTimeout == NULL)
		longjmp(CtxReadTimeout, 1);

	/* terminate if no progress was made -- reset state */
	if (EnableTimeout && (LineNumber <= ReadProgress))
	{
		EnableTimeout = FALSE;
		GlobalTimeout = NULL;
		longjmp(CtxReadTimeout, 2);
	}

	/* schedule a new timeout */
	GlobalTimeout = NULL;
	sfgetset(timeout);
d1238 3
a1240 1
	*--p = '\0';
d1302 1
d1449 1
d1453 1
a1453 1
#ifdef XDEBUG
a1485 1
#include <netdb.h>
d1488 1
d1508 1
a1513 1
	register struct hostent *hp;
d1515 1
d1517 3
a1519 1
	struct sockaddr_in sin;
d1523 1
d1554 3
a1556 3
		slen = sizeof sin;
		if (getsockname(fd, (struct sockaddr *) &sin, &slen) < 0)
			sprintf(p, "(badsock)");
d1559 5
a1563 3
			hp = gethostbyaddr((char *) &sin.sin_addr, slen, AF_INET);
			sprintf(p, "%s/%d", hp == NULL ? inet_ntoa(sin.sin_addr)
						   : hp->h_name, ntohs(sin.sin_port));
d1568 3
a1570 3
		slen = sizeof sin;
		if (getpeername(fd, (struct sockaddr *) &sin, &slen) < 0)
			sprintf(p, "(badsock)");
d1573 5
a1577 3
			hp = gethostbyaddr((char *) &sin.sin_addr, slen, AF_INET);
			sprintf(p, "%s/%d", hp == NULL ? inet_ntoa(sin.sin_addr)
						   : hp->h_name, ntohs(sin.sin_port));
d1628 1
a1628 1
		syslog(LOG_DEBUG, "%s", buf);
d1653 1
a1653 1
	register char *s;
d1661 1
a1661 1
		return s;
d1683 234
d1968 2
a1969 2
	int strict;
	int logattacks;
d1996 1
d2000 1
a2000 1
		syslog(LOG_NOTICE, "POSSIBLE ATTACK from %s: newline in string \"%s\"",
d2002 1
a2002 1
			shortenstring(bp, 80));
d2005 1
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@


1.1.1.2
log
@sendmail 8.9.1
@
text
@d2 1
a2 2
 * Copyright (c) 1998 Sendmail, Inc.  All rights reserved.
 * Copyright (c) 1983, 1995-1997 Eric P. Allman.  All rights reserved.
d6 15
a20 3
 * By using this file, you agree to the terms and conditions set
 * forth in the LICENSE file which can be found at the top level of
 * the sendmail distribution.
d22 11
d36 1
a36 1
static char sccsid[] = "@@(#)util.c	8.159 (Berkeley) 7/1/98";
a59 1
void
a81 116
**  ADDQUOTES -- Adds quotes & quote bits to a string.
**
**	Runs through a string and adds characters and quote bits.
**
**	Parameters:
**		s -- the string to modify.
**
**	Returns:
**		pointer to quoted string.
**
**	Side Effects:
**		none.
**
*/

char *
addquotes(s)
	char *s;
{
	int len = 0;
	char c;
	char *p = s, *q, *r;

	if (s == NULL)
		return NULL;

	/* Find length of quoted string */
	while ((c = *p++) != '\0')
	{
		len++;
		if (c == '\\' || c == '"')
			len++;
	}
	
	q = r = xalloc(len + 3);
	p = s;

	/* add leading quote */
	*q++ = '"';
	while ((c = *p++) != '\0')
	{
		/* quote \ or " */
		if (c == '\\' || c == '"')
			*q++ = '\\';
		*q++ = c;
	}
	*q++ = '"';
	*q = '\0';
	return r;
}
/*
**  RFC822_STRING -- Checks string for proper RFC822 string quoting.
**
**	Runs through a string and verifies RFC822 special characters
**	are only found inside comments, quoted strings, or backslash
**	escaped.  Also verified balanced quotes and parenthesis.
**
**	Parameters:
**		s -- the string to modify.
**
**	Returns:
**		TRUE -- if the string is RFC822 compliant.
**		FALSE -- if the string is not RFC822 compliant.
**
**	Side Effects:
**		none.
**
*/

bool
rfc822_string(s)
	char *s;
{
	bool quoted = FALSE;
	int commentlev = 0;
	char *c = s;

	if (s == NULL)
		return FALSE;

	while (*c != '\0')
	{
		/* escaped character */
		if (*c == '\\')
		{
			c++;
			if (*c == '\0')
				return FALSE;
		}
		else if (commentlev == 0 && *c == '"')
			quoted = !quoted;
		else if (!quoted)
		{
			if (*c == ')')
			{
				/* unbalanced ')' */
				if (commentlev == 0)
					return FALSE;
				else
					commentlev--;
			}
			else if (*c == '(')
				commentlev++;
			else if (commentlev == 0 &&
				 strchr(MustQuoteChars, *c) != NULL)
				return FALSE;
		}
		c++;
	}
	/* unbalanced '"' or '(' */
	if (quoted || commentlev != 0)
		return FALSE;
	else
		return TRUE;
}
/*
d110 2
a111 1
		syserr("!Out of memory!!");
a210 1
void
d217 1
a217 1
			printf("\n\t%08lx=", (u_long) *av);
a255 1
void
d257 1
a257 1
	register const char *s;
a260 1
	bool shiftout = FALSE;
d265 1
a265 1
		printf("%s<null>%s", TermEscape.te_rv_on, TermEscape.te_rv_off);
a269 5
		if (shiftout)
		{
			printf("%s", TermEscape.te_rv_off);
			shiftout = FALSE;
		}
d272 1
a272 10
			if (c == MATCHREPL)
			{
				printf("%s$", TermEscape.te_rv_on);
				shiftout = TRUE;
				if (*s == '\0')
					continue;
				c = *s++ & 0377;
				goto printchar;
			}
			if (c == MACROEXPAND || c == MACRODEXPAND)
d274 1
a274 12
				printf("%s$", TermEscape.te_rv_on);
				if (c == MACRODEXPAND)
					putchar('&');
				shiftout = TRUE;
				if (*s == '\0')
					continue;
				if (strchr("=~&?", *s) != NULL)
					putchar(*s++);
				if (bitset(0200, *s))
					printf("{%s}", macname(*s++ & 0377));
				else
					printf("%c", *s++);
d281 1
a281 4
					printf("%s$%c",
						TermEscape.te_rv_on,
						mp->metaname);
					shiftout = TRUE;
a284 7
			if (c == MATCHCLASS || c == MATCHNCLASS)
			{
				if (bitset(0200, *s))
					printf("{%s}", macname(*s++ & 0377));
				else if (*s != '\0')
					printf("%c", *s++);
			}
d287 1
a287 4

			/* unrecognized meta character */
			printf("%sM-", TermEscape.te_rv_on);
			shiftout = TRUE;
a289 1
  printchar:
d299 3
d313 2
a314 13
		}
		if (!shiftout)
		{
			printf("%s", TermEscape.te_rv_on);
			shiftout = TRUE;
		}
		if (isprint(c))
		{
			(void) putchar('\\');
			(void) putchar(c);
		}
		else
		{
d317 1
a319 2
	if (shiftout)
		printf("%s", TermEscape.te_rv_off);
a338 1
void
a359 1
**		buflen -- length of buf.
d368 1
a368 2
void
buildfname(gecos, login, buf, buflen)
a371 1
	int buflen;
d375 1
d380 11
a390 1
	/* copy gecos, interpolating & to be full name */
a392 6
		if (bp >= &buf[buflen - 1])
		{
			/* buffer overflow -- just use login name */
			snprintf(buf, buflen, "%s", login);
			return;
		}
d395 1
a395 2
			/* interpolate full name */
			snprintf(bp, buflen - (bp - buf), "%s", login);
d397 2
a398 1
			bp += strlen(bp);
d406 162
a585 1
void
d602 1
a602 11
**  PUTLINE -- put a line like fputs obeying SMTP conventions
**
**	This routine always guarantees outputing a newline (or CRLF,
**	as appropriate) at the end of the string.
**
**	Parameters:
**		l -- line to put.
**		mci -- the mailer connection information.
**
**	Returns:
**		none
d604 4
a607 2
**	Side Effects:
**		output of l to fp.
d610 24
a633 4
void
putline(l, mci)
	register char *l;
	register MCI *mci;
d635 43
a677 1
	putxline(l, strlen(l), mci, PXLF_MAPFROM);
d680 1
a680 1
**  PUTXLINE -- putline with flags bits.
a686 1
**		len -- the length of the line.
a687 4
**		pxflags -- flag bits:
**		    PXLF_MAPFROM -- map From_ to >From_.
**		    PXLF_STRIP8BIT -- strip 8th bit.
**		    PXLF_HEADER -- map bare newline in header to newline space.
d696 1
a696 2
void
putxline(l, len, mci, pxflags)
a697 1
	size_t len;
a698 1
	int pxflags;
d700 2
a701 1
	register char *p, *end;
a702 1
	size_t eol_len = strlen(mci->mci_mailer->m_eol);
d705 1
a705 2
	if (bitset(MCIF_7BIT, mci->mci_flags) ||
	    bitset(PXLF_STRIP8BIT, pxflags))
a706 2
		register char svchar;

a711 1
	end = l + len;
d715 1
a715 1
		p = memchr(l, '\n', end - l);
d717 1
a717 1
			p = end;
d720 1
a720 1
			fprintf(TrafficLogFile, "%05d >>> ", (int) getpid());
a725 1
			char *l_base = l;
d728 2
a733 2
				if (!bitset(MCIF_INHEADER, mci->mci_flags))
					mci->mci_contentlen++;
d737 1
a737 17
			else if (l[0] == 'F' && slop == 0 &&
				 bitset(PXLF_MAPFROM, pxflags) &&
				 strncmp(l, "From ", 5) == 0 &&
				 bitnset(M_ESCFROM, mci->mci_mailer->m_flags))
			{
				(void) putc('>', mci->mci_out);
				if (!bitset(MCIF_INHEADER, mci->mci_flags))
					mci->mci_contentlen++;
				if (TrafficLogFile != NULL)
					(void) putc('>', TrafficLogFile);
			}
			while (l < q)
			{
				(void) putc(*l++, mci->mci_out);
				if (!bitset(MCIF_INHEADER, mci->mci_flags))
					mci->mci_contentlen++;
			}
a738 2
			if (!bitset(MCIF_INHEADER, mci->mci_flags))
				mci->mci_contentlen++;
a739 2
			if (!bitset(MCIF_INHEADER, mci->mci_flags))
				mci->mci_contentlen += eol_len;
a740 2
			if (!bitset(MCIF_INHEADER, mci->mci_flags))
				mci->mci_contentlen++;
d742 4
a745 6
			{
				for (l = l_base; l < q; l++)
					(void) putc(*l, TrafficLogFile);
				fprintf(TrafficLogFile, "!\n%05d >>>  ",
					(int) getpid());
			}
a753 2
			if (!bitset(MCIF_INHEADER, mci->mci_flags))
				mci->mci_contentlen++;
d757 2
a758 11
		else if (l[0] == 'F' && slop == 0 &&
			 bitset(PXLF_MAPFROM, pxflags) &&
			 strncmp(l, "From ", 5) == 0 &&
			 bitnset(M_ESCFROM, mci->mci_mailer->m_flags))
		{
			(void) putc('>', mci->mci_out);
			if (!bitset(MCIF_INHEADER, mci->mci_flags))
				mci->mci_contentlen++;
			if (TrafficLogFile != NULL)
				(void) putc('>', TrafficLogFile);
		}
a759 3
		{
			if (TrafficLogFile != NULL)
				(void) putc(*l, TrafficLogFile);
a760 5
			if (!bitset(MCIF_INHEADER, mci->mci_flags))
				mci->mci_contentlen++;
		}
		if (TrafficLogFile != NULL)
			(void) putc('\n', TrafficLogFile);
d762 3
a764 15
		if (!bitset(MCIF_INHEADER, mci->mci_flags))
			mci->mci_contentlen += eol_len;
		if (l < end && *l == '\n')
		{
			if (*++l != ' ' && *l != '\t' && *l != '\0' &&
			    bitset(PXLF_HEADER, pxflags))
			{
				(void) putc(' ', mci->mci_out);
				if (!bitset(MCIF_INHEADER, mci->mci_flags))
					mci->mci_contentlen++;
				if (TrafficLogFile != NULL)
					(void) putc(' ', TrafficLogFile);
			}
		}
	} while (l < end);
a778 1
void
d784 1
d786 2
a787 3
		sm_syslog(LOG_DEBUG, CurEnv->e_id,
			"unlink %s",
			f);
d790 1
d792 2
a793 3
		sm_syslog(LOG_DEBUG, CurEnv->e_id,
			"%s: unlink-fail %d",
			f, errno);
a808 1
void
d814 2
a815 2
		printf("xfclose(%lx) %s %s\n", (u_long) fp, a, b);
#if XDEBUG
d842 4
a845 1
static void	readtimeout __P((time_t));
d869 5
a873 5
			if (LogLevel > 1)
				sm_syslog(LOG_NOTICE, CurEnv->e_id,
				       "timeout waiting for input from %.100s during %s",
				       CurHostName ? CurHostName : "local",
				       during);
d875 2
d878 1
a878 1
#if XDEBUG
a880 3
			if (TrafficLogFile != NULL)
				fprintf(TrafficLogFile, "%05d <<< [TIMEOUT]\n",
					(int) getpid());
d883 4
a886 1
		ev = setevent(timeout, readtimeout, 0);
d901 4
a904 1
	clrevent(ev);
d912 1
a912 1
			fprintf(TrafficLogFile, "%05d <<< [EOF]\n", (int) getpid());
d916 2
a917 3
		fprintf(TrafficLogFile, "%05d <<< %s", (int) getpid(), buf);
	if (SevenBitInput)
	{
d920 12
d933 3
a935 1
	else if (!HasEightBits)
d937 2
a938 8
		for (p = buf; *p != '\0'; p++)
		{
			if (bitset(0200, *p))
			{
				HasEightBits = TRUE;
				break;
			}
		}
a939 1
	return (buf);
d942 1
a942 2
/* ARGSUSED */
static void
d946 15
a960 1
	longjmp(CtxReadTimeout, 1);
d1036 1
a1036 3
	if (p[-1] == '\n')
		p--;
	*p = '\0';
a1097 1
int
d1108 38
a1243 1
void
d1247 1
a1247 1
#if XDEBUG
d1249 1
a1251 23
		fill_fd(i, where);
#endif /* XDEBUG */
}
/*
**  CHECKFDOPEN -- make sure file descriptor is open -- for extended debugging
**
**	Parameters:
**		fd -- file descriptor to check.
**		where -- tag to print on failure.
**
**	Returns:
**		none.
*/

void
checkfdopen(fd, where)
	int fd;
	char *where;
{
#if XDEBUG
	struct stat st;

	if (fstat(fd, &st) < 0 && errno == EBADF)
d1253 1
a1253 41
		syserr("checkfdopen(%d): %s not open as expected!", fd, where);
		printopenfds(TRUE);
	}
#endif
}
/*
**  CHECKFDS -- check for new or missing file descriptors
**
**	Parameters:
**		where -- tag for printing.  If null, take a base line.
**
**	Returns:
**		none
**
**	Side Effects:
**		If where is set, shows changes since the last call.
*/

void
checkfds(where)
	char *where;
{
	int maxfd;
	register int fd;
	bool printhdr = TRUE;
	int save_errno = errno;
	static BITMAP baseline;
	extern int DtableSize;

	if (DtableSize > 256)
		maxfd = 256;
	else
		maxfd = DtableSize;
	if (where == NULL)
		clrbitmap(baseline);

	for (fd = 0; fd < maxfd; fd++)
	{
		struct stat stbuf;

		if (fstat(fd, &stbuf) < 0 && errno != EOPNOTSUPP)
d1255 2
a1256 8
			if (!bitnset(fd, baseline))
				continue;
			clrbitn(fd, baseline);
		}
		else if (!bitnset(fd, baseline))
			setbitn(fd, baseline);
		else
			continue;
d1258 7
a1264 9
		/* file state has changed */
		if (where == NULL)
			continue;
		if (printhdr)
		{
			sm_syslog(LOG_DEBUG, CurEnv->e_id,
				"%s: changed fds:",
				where);
			printhdr = FALSE;
a1265 1
		dumpfd(fd, TRUE, TRUE);
d1267 1
a1267 1
	errno = save_errno;
d1280 1
a1282 1
void
a1301 1
void
d1307 1
d1309 3
a1311 9
	char *hp;
#ifdef S_IFSOCK
	SOCKADDR sa;
#endif
	auto SOCKADDR_LEN_T slen;
	int i;
#if STAT64 > 0
	struct stat64 st;
#else
a1312 1
#endif
d1316 1
a1316 1
	snprintf(p, SPACELEFT(buf, p), "%3d: ", fd);
d1319 1
a1319 7
	if (
#if STAT64 > 0
	    fstat64(fd, &st)
#else
	    fstat(fd, &st)
#endif
	    < 0)
d1321 1
a1321 1
		if (errno != EBADF)
d1323 1
a1323 7
			snprintf(p, SPACELEFT(buf, p), "CANNOT STAT (%s)",
				errstring(errno));
			goto printit;
		}
		else if (printclosed)
		{
			snprintf(p, SPACELEFT(buf, p), "CLOSED");
d1329 2
a1330 2
	i = fcntl(fd, F_GETFL, NULL);
	if (i != -1)
d1332 1
a1332 1
		snprintf(p, SPACELEFT(buf, p), "fl=0x%x, ", i);
d1336 1
a1336 1
	snprintf(p, SPACELEFT(buf, p), "mode=%o: ", st.st_mode);
d1342 1
a1342 1
		snprintf(p, SPACELEFT(buf, p), "SOCK ");
d1344 3
a1346 3
		slen = sizeof sa;
		if (getsockname(fd, &sa.sa, &slen) < 0)
			snprintf(p, SPACELEFT(buf, p), "(%s)", errstring(errno));
d1349 3
a1351 6
			hp = hostnamebyanyaddr(&sa);
			if (sa.sa.sa_family == AF_INET)
				snprintf(p, SPACELEFT(buf, p), "%s/%d",
					hp, ntohs(sa.sin.sin_port));
			else
				snprintf(p, SPACELEFT(buf, p), "%s", hp);
d1354 1
a1354 1
		snprintf(p, SPACELEFT(buf, p), "->");
d1356 3
a1358 3
		slen = sizeof sa;
		if (getpeername(fd, &sa.sa, &slen) < 0)
			snprintf(p, SPACELEFT(buf, p), "(%s)", errstring(errno));
d1361 3
a1363 6
			hp = hostnamebyanyaddr(&sa);
			if (sa.sa.sa_family == AF_INET)
				snprintf(p, SPACELEFT(buf, p), "%s/%d",
					hp, ntohs(sa.sin.sin_port));
			else
				snprintf(p, SPACELEFT(buf, p), "%s", hp);
d1369 1
a1369 1
		snprintf(p, SPACELEFT(buf, p), "CHR: ");
d1374 1
a1374 1
		snprintf(p, SPACELEFT(buf, p), "BLK: ");
d1380 1
a1380 1
		snprintf(p, SPACELEFT(buf, p), "FIFO: ");
d1387 1
a1387 1
		snprintf(p, SPACELEFT(buf, p), "DIR: ");
d1394 1
a1394 1
		snprintf(p, SPACELEFT(buf, p), "LNK: ");
a1400 12
		if (sizeof st.st_ino > sizeof (long))
			snprintf(p, SPACELEFT(buf, p),
				 "dev=%d/%d, ino=%s, nlink=%d, u/gid=%d/%d, ",
				 major(st.st_dev), minor(st.st_dev),
				 quad_to_string(st.st_ino),
				 st.st_nlink, st.st_uid, st.st_gid);
		else
			snprintf(p, SPACELEFT(buf, p),
				"dev=%d/%d, ino=%lu, nlink=%d, u/gid=%d/%d, ",
				major(st.st_dev), minor(st.st_dev),
				(unsigned long) st.st_ino,
				st.st_nlink, st.st_uid, st.st_gid);
d1402 1
a1402 2
			snprintf(p, SPACELEFT(buf, p), "size=%s",
				 quad_to_string(st.st_size));
d1404 4
a1407 2
			snprintf(p, SPACELEFT(buf, p), "size=%lu",
				 (unsigned long) st.st_size);
d1412 1
d1414 1
a1414 2
		sm_syslog(LOG_DEBUG, CurEnv ? CurEnv->e_id : NULL,
			"%.800s", buf);
d1416 1
d1420 1
a1420 1
**  SHORTEN_HOSTNAME -- strip local domain information off of hostname.
d1422 2
a1423 40
**	Parameters:
**		host -- the host to shorten (stripped in place).
**
**	Returns:
**		none.
*/

void
shorten_hostname(host)
	char host[];
{
	register char *p;
	char *mydom;
	int i;
	bool canon = FALSE;

	/* strip off final dot */
	p = &host[strlen(host) - 1];
	if (*p == '.')
	{
		*p = '\0';
		canon = TRUE;
	}

	/* see if there is any domain at all -- if not, we are done */
	p = strchr(host, '.');
	if (p == NULL)
		return;

	/* yes, we have a domain -- see if it looks like us */
	mydom = macvalue('m', CurEnv);
	if (mydom == NULL)
		mydom = "";
	i = strlen(++p);
	if ((canon ? strcasecmp(p, mydom) : strncasecmp(p, mydom, i)) == 0 &&
	    (mydom[i] == '.' || mydom[i] == '\0'))
		*--p = '\0';
}
/*
**  PROG_OPEN -- open a program for reading
d1426 2
a1427 3
**		argv -- the argument list.
**		pfd -- pointer to a place to store the file descriptor.
**		e -- the current envelope.
d1430 1
a1430 1
**		pid of the process -- -1 if it failed.
d1433 3
a1435 126
int
prog_open(argv, pfd, e)
	char **argv;
	int *pfd;
	ENVELOPE *e;
{
	int pid;
	int i;
	int saveerrno;
	int fdv[2];
	char *p, *q;
	char buf[MAXLINE + 1];
	extern int DtableSize;

	if (pipe(fdv) < 0)
	{
		syserr("%s: cannot create pipe for stdout", argv[0]);
		return -1;
	}
	pid = fork();
	if (pid < 0)
	{
		syserr("%s: cannot fork", argv[0]);
		close(fdv[0]);
		close(fdv[1]);
		return -1;
	}
	if (pid > 0)
	{
		/* parent */
		close(fdv[1]);
		*pfd = fdv[0];
		return pid;
	}

	/* child -- close stdin */
	close(0);

	/* stdout goes back to parent */
	close(fdv[0]);
	if (dup2(fdv[1], 1) < 0)
	{
		syserr("%s: cannot dup2 for stdout", argv[0]);
		_exit(EX_OSERR);
	}
	close(fdv[1]);

	/* stderr goes to transcript if available */
	if (e->e_xfp != NULL)
	{
		if (dup2(fileno(e->e_xfp), 2) < 0)
		{
			syserr("%s: cannot dup2 for stderr", argv[0]);
			_exit(EX_OSERR);
		}
	}

	/* this process has no right to the queue file */
	if (e->e_lockfp != NULL)
		close(fileno(e->e_lockfp));

	/* run as default user */
	endpwent();
	if (setgid(DefGid) < 0 && geteuid() == 0)
		syserr("prog_open: setgid(%ld) failed", (long) DefGid);
	if (setuid(DefUid) < 0 && geteuid() == 0)
		syserr("prog_open: setuid(%ld) failed", (long) DefUid);

	/* run in some directory */
	if (ProgMailer != NULL)
		p = ProgMailer->m_execdir;
	else
		p = NULL;
	for (; p != NULL; p = q)
	{
		q = strchr(p, ':');
		if (q != NULL)
			*q = '\0';
		expand(p, buf, sizeof buf, e);
		if (q != NULL)
			*q++ = ':';
		if (buf[0] != '\0' && chdir(buf) >= 0)
			break;
	}
	if (p == NULL)
	{
		/* backup directories */
		if (chdir("/tmp") < 0)
			(void) chdir("/");
	}

	/* arrange for all the files to be closed */
	for (i = 3; i < DtableSize; i++)
	{
		register int j;

		if ((j = fcntl(i, F_GETFD, 0)) != -1)
			(void) fcntl(i, F_SETFD, j | 1);
	}

	/* now exec the process */
	execve(argv[0], (ARGV_T) argv, (ARGV_T) UserEnviron);

	/* woops!  failed */
	saveerrno = errno;
	syserr("%s: cannot exec", argv[0]);
	if (transienterror(saveerrno))
		_exit(EX_OSERR);
	_exit(EX_CONFIG);
	return -1;	/* avoid compiler warning on IRIX */
}
/*
**  GET_COLUMN  -- look up a Column in a line buffer
**
**	Parameters:
**		line -- the raw text line to search.
**		col -- the column number to fetch.
**		delim -- the delimiter between columns.  If null,
**			use white space.
**		buf -- the output buffer.
**		buflen -- the length of buf.
**
**	Returns:
**		buf if successful.
**		NULL otherwise.
*/
d1438 3
a1440 6
get_column(line, col, delim, buf, buflen)
	char line[];
	int col;
	char delim;
	char buf[];
	int buflen;
d1442 2
a1443 12
	char *p;
	char *begin, *end;
	int i;
	char delimbuf[4];
	
	if (delim == '\0')
		strcpy(delimbuf, "\n\t ");
	else
	{
		delimbuf[0] = delim;
		delimbuf[1] = '\0';
	}
d1445 21
a1465 35
	p = line;
	if (*p == '\0')
		return NULL;			/* line empty */
	if (*p == delim && col == 0)
		return NULL;			/* first column empty */

	begin = line;

	if (col == 0 && delim == '\0')
	{
		while (*begin != '\0' && isascii(*begin) && isspace(*begin))
			begin++;
	}

	for (i = 0; i < col; i++)
	{
		if ((begin = strpbrk(begin, delimbuf)) == NULL)
			return NULL;		/* no such column */
		begin++;
		if (delim == '\0')
		{
			while (*begin != '\0' && isascii(*begin) && isspace(*begin))
				begin++;
		}
	}
	
	end = strpbrk(begin, delimbuf);
	if (end == NULL)
		i = strlen(begin);
	else
		i = end - begin;
	if (i >= buflen)
		i = buflen - 1;
	strncpy(buf, begin, i);
	buf[i] = '\0';
d1486 1
d1489 1
d1520 2
a1521 2
	bool strict;
	bool logattacks;
d1548 1
d1551 1
a1551 2
		sm_syslog(LOG_NOTICE, CurEnv->e_id,
			"POSSIBLE ATTACK from %.100s: newline in string \"%s\"",
d1553 1
a1553 1
			shortenstring(bp, MAXSHORTSTR));
d1555 1
a1557 306
}
/*
**  PATH_IS_DIR -- check to see if file exists and is a directory.
**
**	There are some additional checks for security violations in
**	here.  This routine is intended to be used for the host status
**	support.
**
**	Parameters:
**		pathname -- pathname to check for directory-ness.
**		createflag -- if set, create directory if needed.
**
**	Returns:
**		TRUE -- if the indicated pathname is a directory
**		FALSE -- otherwise
*/

int
path_is_dir(pathname, createflag)
	char *pathname;
	bool createflag;
{
	struct stat statbuf;

#if HASLSTAT
	if (lstat(pathname, &statbuf) < 0)
#else
	if (stat(pathname, &statbuf) < 0)
#endif
	{
		if (errno != ENOENT || !createflag)
			return FALSE;
		if (mkdir(pathname, 0755) < 0)
			return FALSE;
		return TRUE;
	}
	if (!S_ISDIR(statbuf.st_mode))
	{
		errno = ENOTDIR;
		return FALSE;
	}

	/* security: don't allow writable directories */
	if (bitset(S_IWGRP|S_IWOTH, statbuf.st_mode))
	{
		errno = EACCES;
		return FALSE;
	}

	return TRUE;
}
/*
**  PROC_LIST_ADD -- add process id to list of our children
**
**	Parameters:
**		pid -- pid to add to list.
**
**	Returns:
**		none
*/

static pid_t	*ProcListVec	= NULL;
static int	ProcListSize	= 0;

#define NO_PID		((pid_t) 0)
#ifndef PROC_LIST_SEG
# define PROC_LIST_SEG	32		/* number of pids to alloc at a time */
#endif

void
proc_list_add(pid)
	pid_t pid;
{
	int i;
	extern void proc_list_probe __P((void));

	for (i = 0; i < ProcListSize; i++)
	{
		if (ProcListVec[i] == NO_PID)
			break;
	}
	if (i >= ProcListSize)
	{
		/* probe the existing vector to avoid growing infinitely */
		proc_list_probe();

		/* now scan again */
		for (i = 0; i < ProcListSize; i++)
		{
			if (ProcListVec[i] == NO_PID)
				break;
		}
	}
	if (i >= ProcListSize)
	{
		/* grow process list */
		pid_t *npv;

		npv = (pid_t *) xalloc(sizeof (pid_t) * (ProcListSize + PROC_LIST_SEG));
		if (ProcListSize > 0)
		{
			bcopy(ProcListVec, npv, ProcListSize * sizeof (pid_t));
			free(ProcListVec);
		}
		for (i = ProcListSize; i < ProcListSize + PROC_LIST_SEG; i++)
			npv[i] = NO_PID;
		i = ProcListSize;
		ProcListSize += PROC_LIST_SEG;
		ProcListVec = npv;
	}
	ProcListVec[i] = pid;
	CurChildren++;
}
/*
**  PROC_LIST_DROP -- drop pid from process list
**
**	Parameters:
**		pid -- pid to drop
**
**	Returns:
**		none.
*/

void
proc_list_drop(pid)
	pid_t pid;
{
	int i;

	for (i = 0; i < ProcListSize; i++)
	{
		if (ProcListVec[i] == pid)
		{
			ProcListVec[i] = NO_PID;
			break;
		}
	}
	if (CurChildren > 0)
		CurChildren--;
}
/*
**  PROC_LIST_CLEAR -- clear the process list
**
**	Parameters:
**		none.
**
**	Returns:
**		none.
*/

void
proc_list_clear()
{
	int i;

	for (i = 0; i < ProcListSize; i++)
		ProcListVec[i] = NO_PID;
	CurChildren = 0;
}
/*
**  PROC_LIST_PROBE -- probe processes in the list to see if they still exist
**
**	Parameters:
**		none
**
**	Returns:
**		none
*/

void
proc_list_probe()
{
	int i;

	for (i = 0; i < ProcListSize; i++)
	{
		if (ProcListVec[i] == NO_PID)
			continue;
		if (kill(ProcListVec[i], 0) < 0)
		{
			if (LogLevel > 3)
				sm_syslog(LOG_DEBUG, CurEnv->e_id,
					"proc_list_probe: lost pid %d",
					ProcListVec[i]);
			ProcListVec[i] = NO_PID;
			CurChildren--;
		}
	}
	if (CurChildren < 0)
		CurChildren = 0;
}
/*
**  SM_STRCASECMP -- 8-bit clean version of strcasecmp
**
**	Thank you, vendors, for making this all necessary.
*/

/*
 * Copyright (c) 1987, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#if defined(LIBC_SCCS) && !defined(lint)
static char sccsid[] = "@@(#)strcasecmp.c	8.1 (Berkeley) 6/4/93";
#endif /* LIBC_SCCS and not lint */

/*
 * This array is designed for mapping upper and lower case letter
 * together for a case independent comparison.  The mappings are
 * based upon ascii character sequences.
 */
static const u_char charmap[] = {
	0000, 0001, 0002, 0003, 0004, 0005, 0006, 0007,
	0010, 0011, 0012, 0013, 0014, 0015, 0016, 0017,
	0020, 0021, 0022, 0023, 0024, 0025, 0026, 0027,
	0030, 0031, 0032, 0033, 0034, 0035, 0036, 0037,
	0040, 0041, 0042, 0043, 0044, 0045, 0046, 0047,
	0050, 0051, 0052, 0053, 0054, 0055, 0056, 0057,
	0060, 0061, 0062, 0063, 0064, 0065, 0066, 0067,
	0070, 0071, 0072, 0073, 0074, 0075, 0076, 0077,
	0100, 0141, 0142, 0143, 0144, 0145, 0146, 0147,
	0150, 0151, 0152, 0153, 0154, 0155, 0156, 0157,
	0160, 0161, 0162, 0163, 0164, 0165, 0166, 0167,
	0170, 0171, 0172, 0133, 0134, 0135, 0136, 0137,
	0140, 0141, 0142, 0143, 0144, 0145, 0146, 0147,
	0150, 0151, 0152, 0153, 0154, 0155, 0156, 0157,
	0160, 0161, 0162, 0163, 0164, 0165, 0166, 0167,
	0170, 0171, 0172, 0173, 0174, 0175, 0176, 0177,
	0200, 0201, 0202, 0203, 0204, 0205, 0206, 0207,
	0210, 0211, 0212, 0213, 0214, 0215, 0216, 0217,
	0220, 0221, 0222, 0223, 0224, 0225, 0226, 0227,
	0230, 0231, 0232, 0233, 0234, 0235, 0236, 0237,
	0240, 0241, 0242, 0243, 0244, 0245, 0246, 0247,
	0250, 0251, 0252, 0253, 0254, 0255, 0256, 0257,
	0260, 0261, 0262, 0263, 0264, 0265, 0266, 0267,
	0270, 0271, 0272, 0273, 0274, 0275, 0276, 0277,
	0300, 0301, 0302, 0303, 0304, 0305, 0306, 0307,
	0310, 0311, 0312, 0313, 0314, 0315, 0316, 0317,
	0320, 0321, 0322, 0323, 0324, 0325, 0326, 0327,
	0330, 0331, 0332, 0333, 0334, 0335, 0336, 0337,
	0340, 0341, 0342, 0343, 0344, 0345, 0346, 0347,
	0350, 0351, 0352, 0353, 0354, 0355, 0356, 0357,
	0360, 0361, 0362, 0363, 0364, 0365, 0366, 0367,
	0370, 0371, 0372, 0373, 0374, 0375, 0376, 0377,
};

int
sm_strcasecmp(s1, s2)
	const char *s1, *s2;
{
	register const u_char *cm = charmap,
			*us1 = (const u_char *)s1,
			*us2 = (const u_char *)s2;

	while (cm[*us1] == cm[*us2++])
		if (*us1++ == '\0')
			return (0);
	return (cm[*us1] - cm[*--us2]);
}

int
sm_strncasecmp(s1, s2, n)
	const char *s1, *s2;
	register size_t n;
{
	if (n != 0) {
		register const u_char *cm = charmap,
				*us1 = (const u_char *)s1,
				*us2 = (const u_char *)s2;

		do {
			if (cm[*us1] != cm[*us2++])
				return (cm[*us1] - cm[*--us2]);
			if (*us1++ == '\0')
				break;
		} while (--n != 0);
	}
	return (0);
@

