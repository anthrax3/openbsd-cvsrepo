head	1.13;
access;
symbols
	OPENBSD_2_6:1.12.0.4
	OPENBSD_2_6_BASE:1.12
	OPENBSD_2_5:1.12.0.2
	OPENBSD_2_5_BASE:1.12
	OPENBSD_2_4:1.10.0.2
	OPENBSD_2_4_BASE:1.10
	sendmail_8_9_1:1.1.1.2
	UCB:1.1.1
	OPENBSD_2_3:1.9.0.2
	OPENBSD_2_3_BASE:1.9
	OPENBSD_2_2:1.8.0.2
	OPENBSD_2_2_BASE:1.8
	OPENBSD_2_1:1.6.0.2
	OPENBSD_2_1_BASE:1.6
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.13
date	2000.04.18.04.57.24;	author millert;	state dead;
branches;
next	1.12;

1.12
date	99.02.05.05.59.30;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	99.01.01.20.33.55;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	98.07.12.19.45.01;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	97.11.09.04.05.43;	author gene;	state Exp;
branches;
next	1.8;

1.8
date	97.08.04.02.17.56;	author downsj;	state Exp;
branches;
next	1.7;

1.7
date	97.07.15.07.24.12;	author downsj;	state Exp;
branches;
next	1.6;

1.6
date	97.01.22.01.07.17;	author downsj;	state Exp;
branches;
next	1.5;

1.5
date	96.12.14.21.17.31;	author downsj;	state Exp;
branches;
next	1.4;

1.4
date	96.09.19.06.45.03;	author fn;	state Exp;
branches;
next	1.3;

1.3
date	96.02.23.17.45.31;	author dm;	state Exp;
branches;
next	1.2;

1.2
date	96.01.29.01.44.18;	author dm;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.48.19;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.48.19;	author deraadt;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	98.07.12.17.10.28;	author millert;	state Exp;
branches;
next	;


desc
@@


1.13
log
@remove sendmail 8.9.3
@
text
@/*
 * Copyright (c) 1998 Sendmail, Inc.  All rights reserved.
 * Copyright (c) 1983, 1995-1997 Eric P. Allman.  All rights reserved.
 * Copyright (c) 1988, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * By using this file, you agree to the terms and conditions set
 * forth in the LICENSE file which can be found at the top level of
 * the sendmail distribution.
 *
 */

# include "sendmail.h"

#ifndef lint
#if QUEUE
static char sccsid[] = "@@(#)queue.c	8.211 (Berkeley) 1/25/1999 (with queueing)";
#else
static char sccsid[] = "@@(#)queue.c	8.211 (Berkeley) 1/25/1999 (without queueing)";
#endif
#endif /* not lint */

# include <errno.h>
# include <dirent.h>

# if QUEUE

/*
**  Work queue.
*/

struct work
{
	char		*w_name;	/* name of control file */
	char		*w_host;	/* name of recipient host */
	bool		w_lock;		/* is message locked? */
	bool		w_tooyoung;	/* is it too young to run? */
	long		w_pri;		/* priority of message, see below */
	time_t		w_ctime;	/* creation time of message */
	struct work	*w_next;	/* next in queue */
};

typedef struct work	WORK;

WORK	*WorkQ;			/* queue of things to be done */

#define QF_VERSION	2	/* version number of this queue format */

extern int orderq __P((bool));
/*
**  QUEUEUP -- queue a message up for future transmission.
**
**	Parameters:
**		e -- the envelope to queue up.
**		announce -- if TRUE, tell when you are queueing up.
**
**	Returns:
**		none.
**
**	Side Effects:
**		The current request are saved in a control file.
**		The queue file is left locked.
*/

void
queueup(e, announce)
	register ENVELOPE *e;
	bool announce;
{
	char *qf;
	register FILE *tfp;
	register HDR *h;
	register ADDRESS *q;
	int fd;
	int i;
	bool newid;
	register char *p;
	MAILER nullmailer;
	MCI mcibuf;
	char tf[MAXQFNAME];
	char buf[MAXLINE];
	extern void printctladdr __P((ADDRESS *, FILE *));

	/*
	**  Create control file.
	*/

	newid = (e->e_id == NULL) || !bitset(EF_INQUEUE, e->e_flags);

	/* if newid, queuename will create a locked qf file in e->lockfp */
	strcpy(tf, queuename(e, 't'));
	tfp = e->e_lockfp;
	if (tfp == NULL)
		newid = FALSE;

	/* if newid, just write the qf file directly (instead of tf file) */
	if (!newid)
	{
		/* get a locked tf file */
		for (i = 0; i < 128; i++)
		{
			fd = open(tf, O_CREAT|O_WRONLY|O_EXCL, FileMode);
			if (fd < 0)
			{
				if (errno != EEXIST)
					break;
				if (LogLevel > 0 && (i % 32) == 0)
					sm_syslog(LOG_ALERT, e->e_id,
						"queueup: cannot create %s, uid=%d: %s",
						tf, geteuid(), errstring(errno));
			}
			else
			{
				if (lockfile(fd, tf, NULL, LOCK_EX|LOCK_NB))
					break;
				else if (LogLevel > 0 && (i % 32) == 0)
					sm_syslog(LOG_ALERT, e->e_id,
						"queueup: cannot lock %s: %s",
						tf, errstring(errno));
				close(fd);
			}

			if ((i % 32) == 31)
			{
				/* save the old temp file away */
				(void) rename(tf, queuename(e, 'T'));
			}
			else
				sleep(i % 32);
		}
		if (fd < 0 || (tfp = fdopen(fd, "w")) == NULL)
		{
			printopenfds(TRUE);
			syserr("!queueup: cannot create queue temp file %s, uid=%d",
				tf, geteuid());
		}
	}

	if (tTd(40, 1))
		printf("\n>>>>> queueing %s%s >>>>>\n", e->e_id,
			newid ? " (new id)" : "");
	if (tTd(40, 3))
	{
		extern void printenvflags __P((ENVELOPE *));

		printf("  e_flags=");
		printenvflags(e);
	}
	if (tTd(40, 32))
	{
		printf("  sendq=");
		printaddr(e->e_sendqueue, TRUE);
	}
	if (tTd(40, 9))
	{
		printf("  tfp=");
		dumpfd(fileno(tfp), TRUE, FALSE);
		printf("  lockfp=");
		if (e->e_lockfp == NULL)
			printf("NULL\n");
		else
			dumpfd(fileno(e->e_lockfp), TRUE, FALSE);
	}

	/*
	**  If there is no data file yet, create one.
	*/

	if (!bitset(EF_HAS_DF, e->e_flags))
	{
		register FILE *dfp = NULL;
		char dfname[MAXQFNAME];
		struct stat stbuf;

		strcpy(dfname, queuename(e, 'd'));
		fd = open(dfname, O_WRONLY|O_CREAT|O_TRUNC, FileMode);
		if (fd < 0 || (dfp = fdopen(fd, "w")) == NULL)
			syserr("!queueup: cannot create data temp file %s, uid=%d",
				dfname, geteuid());
		if (fstat(fd, &stbuf) < 0)
			e->e_dfino = -1;
		else
		{
			e->e_dfdev = stbuf.st_dev;
			e->e_dfino = stbuf.st_ino;
		}
		e->e_flags |= EF_HAS_DF;
		bzero(&mcibuf, sizeof mcibuf);
		mcibuf.mci_out = dfp;
		mcibuf.mci_mailer = FileMailer;
		(*e->e_putbody)(&mcibuf, e, NULL);
		(void) xfclose(dfp, "queueup dfp", e->e_id);
		e->e_putbody = putbody;
	}

	/*
	**  Output future work requests.
	**	Priority and creation time should be first, since
	**	they are required by orderq.
	*/

	/* output queue version number (must be first!) */
	fprintf(tfp, "V%d\n", QF_VERSION);

	/* output creation time */
	fprintf(tfp, "T%ld\n", (long) e->e_ctime);

	/* output last delivery time */
	fprintf(tfp, "K%ld\n", (long) e->e_dtime);

	/* output number of delivery attempts */
	fprintf(tfp, "N%d\n", e->e_ntries);

	/* output message priority */
	fprintf(tfp, "P%ld\n", e->e_msgpriority);

	/* output inode number of data file */
	/* XXX should probably include device major/minor too */
	if (e->e_dfino != -1)
	{
		if (sizeof e->e_dfino > sizeof(long))
			fprintf(tfp, "I%d/%d/%s\n",
				major(e->e_dfdev), minor(e->e_dfdev),
				quad_to_string(e->e_dfino));
		else
			fprintf(tfp, "I%d/%d/%lu\n",
				major(e->e_dfdev), minor(e->e_dfdev),
				(unsigned long) e->e_dfino);
	}

	/* output body type */
	if (e->e_bodytype != NULL)
		fprintf(tfp, "B%s\n", denlstring(e->e_bodytype, TRUE, FALSE));

#if _FFR_SAVE_CHARSET
	if (e->e_charset != NULL)
		fprintf(tfp, "X%s\n", denlstring(e->e_charset, TRUE, FALSE));
#endif

	/* message from envelope, if it exists */
	if (e->e_message != NULL)
		fprintf(tfp, "M%s\n", denlstring(e->e_message, TRUE, FALSE));

	/* send various flag bits through */
	p = buf;
	if (bitset(EF_WARNING, e->e_flags))
		*p++ = 'w';
	if (bitset(EF_RESPONSE, e->e_flags))
		*p++ = 'r';
	if (bitset(EF_HAS8BIT, e->e_flags))
		*p++ = '8';
	if (bitset(EF_DELETE_BCC, e->e_flags))
		*p++ = 'b';
	if (bitset(EF_RET_PARAM, e->e_flags))
		*p++ = 'd';
	if (bitset(EF_NO_BODY_RETN, e->e_flags))
		*p++ = 'n';
	*p++ = '\0';
	if (buf[0] != '\0')
		fprintf(tfp, "F%s\n", buf);

	/* $r and $s and $_ macro values */
	if ((p = macvalue('r', e)) != NULL)
		fprintf(tfp, "$r%s\n", denlstring(p, TRUE, FALSE));
	if ((p = macvalue('s', e)) != NULL)
		fprintf(tfp, "$s%s\n", denlstring(p, TRUE, FALSE));
	if ((p = macvalue('_', e)) != NULL)
		fprintf(tfp, "$_%s\n", denlstring(p, TRUE, FALSE));

	/* output name of sender */
	if (bitnset(M_UDBENVELOPE, e->e_from.q_mailer->m_flags))
		p = e->e_sender;
	else
		p = e->e_from.q_paddr;
	fprintf(tfp, "S%s\n", denlstring(p, TRUE, FALSE));

	/* output ESMTP-supplied "original" information */
	if (e->e_envid != NULL)
		fprintf(tfp, "Z%s\n", denlstring(e->e_envid, TRUE, FALSE));

	/* output list of recipient addresses */
	printctladdr(NULL, NULL);
	for (q = e->e_sendqueue; q != NULL; q = q->q_next)
	{
		if (bitset(QDONTSEND|QBADADDR|QSENT, q->q_flags))
		{
#if XDEBUG
			if (bitset(QQUEUEUP, q->q_flags))
				sm_syslog(LOG_DEBUG, e->e_id,
					"dropenvelope: q_flags = %x, paddr = %s",
					q->q_flags, q->q_paddr);
#endif
			continue;
		}
		printctladdr(q, tfp);
		if (q->q_orcpt != NULL)
			fprintf(tfp, "Q%s\n",
				denlstring(q->q_orcpt, TRUE, FALSE));
		putc('R', tfp);
		if (bitset(QPRIMARY, q->q_flags))
			putc('P', tfp);
		if (bitset(QHASNOTIFY, q->q_flags))
			putc('N', tfp);
		if (bitset(QPINGONSUCCESS, q->q_flags))
			putc('S', tfp);
		if (bitset(QPINGONFAILURE, q->q_flags))
			putc('F', tfp);
		if (bitset(QPINGONDELAY, q->q_flags))
			putc('D', tfp);
		putc(':', tfp);
		fprintf(tfp, "%s\n", denlstring(q->q_paddr, TRUE, FALSE));
		if (announce)
		{
			e->e_to = q->q_paddr;
			message("queued");
			if (LogLevel > 8)
				logdelivery(q->q_mailer, NULL, "queued",
					    NULL, (time_t) 0, e);
			e->e_to = NULL;
		}
		if (tTd(40, 1))
		{
			printf("queueing ");
			printaddr(q, FALSE);
		}
	}

	/*
	**  Output headers for this message.
	**	Expand macros completely here.  Queue run will deal with
	**	everything as absolute headers.
	**		All headers that must be relative to the recipient
	**		can be cracked later.
	**	We set up a "null mailer" -- i.e., a mailer that will have
	**	no effect on the addresses as they are output.
	*/

	bzero((char *) &nullmailer, sizeof nullmailer);
	nullmailer.m_re_rwset = nullmailer.m_rh_rwset =
			nullmailer.m_se_rwset = nullmailer.m_sh_rwset = -1;
	nullmailer.m_eol = "\n";
	bzero(&mcibuf, sizeof mcibuf);
	mcibuf.mci_mailer = &nullmailer;
	mcibuf.mci_out = tfp;

	define('g', "\201f", e);
	for (h = e->e_header; h != NULL; h = h->h_link)
	{
		extern bool bitzerop __P((BITMAP));

		if (h->h_value == NULL)
			continue;

		/* don't output resent headers on non-resent messages */
		if (bitset(H_RESENT, h->h_flags) && !bitset(EF_RESENT, e->e_flags))
			continue;

		/* expand macros; if null, don't output header at all */
		if (bitset(H_DEFAULT, h->h_flags))
		{
			(void) expand(h->h_value, buf, sizeof buf, e);
			if (buf[0] == '\0')
				continue;
		}

		/* output this header */
		fprintf(tfp, "H");

		/* if conditional, output the set of conditions */
		if (!bitzerop(h->h_mflags) && bitset(H_CHECK|H_ACHECK, h->h_flags))
		{
			int j;

			(void) putc('?', tfp);
			for (j = '\0'; j <= '\177'; j++)
				if (bitnset(j, h->h_mflags))
					(void) putc(j, tfp);
			(void) putc('?', tfp);
		}

		/* output the header: expand macros, convert addresses */
		if (bitset(H_DEFAULT, h->h_flags))
		{
			fprintf(tfp, "%s: %s\n",
				h->h_field,
				denlstring(buf, FALSE, TRUE));
		}
		else if (bitset(H_FROM|H_RCPT, h->h_flags))
		{
			bool oldstyle = bitset(EF_OLDSTYLE, e->e_flags);
			FILE *savetrace = TrafficLogFile;

			TrafficLogFile = NULL;

			if (bitset(H_FROM, h->h_flags))
				oldstyle = FALSE;

			commaize(h, h->h_value, oldstyle, &mcibuf, e);

			TrafficLogFile = savetrace;
		}
		else
		{
			fprintf(tfp, "%s: %s\n",
				h->h_field,
				denlstring(h->h_value, FALSE, TRUE));
		}
	}

	/*
	**  Clean up.
	**
	**	Write a terminator record -- this is to prevent
	**	scurrilous crackers from appending any data.
	*/

	fprintf(tfp, ".\n");

	if (fflush(tfp) < 0 ||
	    (SuperSafe && fsync(fileno(tfp)) < 0) ||
	    ferror(tfp))
	{
		if (newid)
			syserr("!552 Error writing control file %s", tf);
		else
			syserr("!452 Error writing control file %s", tf);
	}

	if (!newid)
	{
		/* rename (locked) tf to be (locked) qf */
		qf = queuename(e, 'q');
		if (rename(tf, qf) < 0)
			syserr("cannot rename(%s, %s), uid=%d",
				tf, qf, geteuid());

		/* close and unlock old (locked) qf */
		if (e->e_lockfp != NULL)
			(void) xfclose(e->e_lockfp, "queueup lockfp", e->e_id);
		e->e_lockfp = tfp;
	}
	else
		qf = tf;
	errno = 0;
	e->e_flags |= EF_INQUEUE;

	/* save log info */
	if (LogLevel > 79)
		sm_syslog(LOG_DEBUG, e->e_id, "queueup, qf=%s", qf);

	if (tTd(40, 1))
		printf("<<<<< done queueing %s <<<<<\n\n", e->e_id);
	return;
}

void
printctladdr(a, tfp)
	register ADDRESS *a;
	FILE *tfp;
{
	char *uname;
	register ADDRESS *q;
	uid_t uid;
	gid_t gid;
	static ADDRESS *lastctladdr = NULL;
	static uid_t lastuid;

	/* initialization */
	if (a == NULL || a->q_alias == NULL || tfp == NULL)
	{
		if (lastctladdr != NULL && tfp != NULL)
			fprintf(tfp, "C\n");
		lastctladdr = NULL;
		lastuid = 0;
		return;
	}

	/* find the active uid */
	q = getctladdr(a);
	if (q == NULL)
	{
		uname = NULL;
		uid = 0;
		gid = 0;
	}
	else
	{
		uname = q->q_ruser != NULL ? q->q_ruser : q->q_user;
		uid = q->q_uid;
		gid = q->q_gid;
	}
	a = a->q_alias;

	/* check to see if this is the same as last time */
	if (lastctladdr != NULL && uid == lastuid &&
	    strcmp(lastctladdr->q_paddr, a->q_paddr) == 0)
		return;
	lastuid = uid;
	lastctladdr = a;

	if (uid == 0 || uname == NULL || uname[0] == '\0')
		fprintf(tfp, "C");
	else
		fprintf(tfp, "C%s:%ld:%ld",
			denlstring(uname, TRUE, FALSE), (long) uid, (long) gid);
	fprintf(tfp, ":%s\n", denlstring(a->q_paddr, TRUE, FALSE));
}
/*
**  RUNQUEUE -- run the jobs in the queue.
**
**	Gets the stuff out of the queue in some presumably logical
**	order and processes them.
**
**	Parameters:
**		forkflag -- TRUE if the queue scanning should be done in
**			a child process.  We double-fork so it is not our
**			child and we don't have to clean up after it.
**		verbose -- if TRUE, print out status information.
**
**	Returns:
**		TRUE if the queue run successfully began.
**
**	Side Effects:
**		runs things in the mail queue.
*/

ENVELOPE	QueueEnvelope;		/* the queue run envelope */
extern int	get_num_procs_online __P((void));

bool
runqueue(forkflag, verbose)
	bool forkflag;
	bool verbose;
{
	register ENVELOPE *e;
	int njobs;
	int sequenceno = 0;
	time_t current_la_time;
	extern ENVELOPE BlankEnvelope;
	extern void clrdaemon __P((void));
	extern void runqueueevent __P((void));

	DoQueueRun = FALSE;

	/*
	**  If no work will ever be selected, don't even bother reading
	**  the queue.
	*/

	CurrentLA = getla();	/* get load average */
	current_la_time = curtime();

	if (shouldqueue(WkRecipFact, current_la_time))
	{
		char *msg = "Skipping queue run -- load average too high";

		if (verbose)
			message("458 %s\n", msg);
		if (LogLevel > 8)
			sm_syslog(LOG_INFO, NOQID,
				"runqueue: %s",
				msg);
		if (forkflag && QueueIntvl != 0)
			(void) setevent(QueueIntvl, runqueueevent, 0);
		return FALSE;
	}

	/*
	**  See if we already have too many children.
	*/

	if (forkflag && QueueIntvl != 0 &&
	    MaxChildren > 0 && CurChildren >= MaxChildren)
	{
		(void) setevent(QueueIntvl, runqueueevent, 0);
		return FALSE;
	}

	/*
	**  See if we want to go off and do other useful work.
	*/

	if (forkflag)
	{
		pid_t pid;
		extern SIGFUNC_DECL intsig __P((int));
		extern SIGFUNC_DECL reapchild __P((int));

		blocksignal(SIGCHLD);
		(void) setsignal(SIGCHLD, reapchild);

		pid = dofork();
		if (pid == -1)
		{
			const char *msg = "Skipping queue run -- fork() failed";
			const char *err = errstring(errno);

			if (verbose)
				message("458 %s: %s\n", msg, err);
			if (LogLevel > 8)
				sm_syslog(LOG_INFO, NOQID,
					"runqueue: %s: %s",
					msg, err);
			if (QueueIntvl != 0)
				(void) setevent(QueueIntvl, runqueueevent, 0);
			(void) releasesignal(SIGCHLD);
			return FALSE;
		}
		if (pid != 0)
		{
			/* parent -- pick up intermediate zombie */
			(void) blocksignal(SIGALRM);
			proc_list_add(pid, "Queue runner");
			(void) releasesignal(SIGALRM);
			releasesignal(SIGCHLD);
			if (QueueIntvl != 0)
				(void) setevent(QueueIntvl, runqueueevent, 0);
			return TRUE;
		}
		/* child -- double fork and clean up signals */
		clrcontrol();
		proc_list_clear();

		/* Add parent process as first child item */
		proc_list_add(getpid(), "Queue runner child process");
		releasesignal(SIGCHLD);
		(void) setsignal(SIGCHLD, SIG_DFL);
		(void) setsignal(SIGHUP, intsig);
	}

	sm_setproctitle(TRUE, "running queue: %s", QueueDir);

	if (LogLevel > 69)
		sm_syslog(LOG_DEBUG, NOQID,
			"runqueue %s, pid=%d, forkflag=%d",
			QueueDir, getpid(), forkflag);

	/*
	**  Release any resources used by the daemon code.
	*/

# if DAEMON
	clrdaemon();
# endif /* DAEMON */

	/* force it to run expensive jobs */
	NoConnect = FALSE;

	/* drop privileges */
	if (geteuid() == (uid_t) 0)
		(void) drop_privileges(FALSE);

	/*
	**  Create ourselves an envelope
	*/

	CurEnv = &QueueEnvelope;
	e = newenvelope(&QueueEnvelope, CurEnv);
	e->e_flags = BlankEnvelope.e_flags;

	/* make sure we have disconnected from parent */
	if (forkflag)
	{
		disconnect(1, e);
		QuickAbort = FALSE;
	}

	/*
	**  Make sure the alias database is open.
	*/

	initmaps(FALSE, e);

	/*
	**  If we are running part of the queue, always ignore stored
	**  host status.
	*/

	if (QueueLimitId != NULL || QueueLimitSender != NULL ||
	    QueueLimitRecipient != NULL)
	{
		IgnoreHostStatus = TRUE;
		MinQueueAge = 0;
	}

	/*
	**  Start making passes through the queue.
	**	First, read and sort the entire queue.
	**	Then, process the work in that order.
	**		But if you take too long, start over.
	*/

	/* order the existing work requests */
	njobs = orderq(FALSE);

	/* process them once at a time */
	while (WorkQ != NULL)
	{
		WORK *w = WorkQ;

		WorkQ = WorkQ->w_next;
		e->e_to = NULL;

		/*
		**  Ignore jobs that are too expensive for the moment.
		**
		**	Get new load average every 30 seconds.
		*/

		if (current_la_time < curtime() - 30)
		{
			CurrentLA = getla();
			current_la_time = curtime();
		}
		if (shouldqueue(WkRecipFact, current_la_time))
		{
			char *msg = "Aborting queue run: load average too high";

			if (Verbose)
				message("%s", msg);
			if (LogLevel > 8)
				sm_syslog(LOG_INFO, NOQID,
					"runqueue: %s",
					msg);
			break;
		}
		sequenceno++;
		if (shouldqueue(w->w_pri, w->w_ctime))
		{
			if (Verbose)
				message("");
			if (QueueSortOrder == QS_BYPRIORITY)
			{
				if (Verbose)
					message("Skipping %s (sequence %d of %d) and flushing rest of queue",
						w->w_name + 2,
						sequenceno,
						njobs);
				if (LogLevel > 8)
					sm_syslog(LOG_INFO, NOQID,
						"runqueue: Flushing queue from %s (pri %ld, LA %d, %d of %d)",
						w->w_name + 2,
						w->w_pri,
						CurrentLA,
						sequenceno,
						njobs);
				break;
			}
			else if (Verbose)
				message("Skipping %s (sequence %d of %d)",
					w->w_name + 2, sequenceno, njobs);
		}
		else
		{
			pid_t pid;

			if (Verbose)
			{
				message("");
				message("Running %s (sequence %d of %d)",
					w->w_name + 2, sequenceno, njobs);
			}
			pid = dowork(w->w_name + 2, ForkQueueRuns, FALSE, e);
			errno = 0;
			if (pid != 0)
				(void) waitfor(pid);
		}
		free(w->w_name);
		if (w->w_host)
			free(w->w_host);
		free((char *) w);
	}

	/* exit without the usual cleanup */
	e->e_id = NULL;
	finis(TRUE, ExitStat);
	/*NOTREACHED*/
	return TRUE;
}


/*
**  RUNQUEUEEVENT -- stub for use in setevent
*/

void
runqueueevent()
{
	DoQueueRun = TRUE;
}
/*
**  ORDERQ -- order the work queue.
**
**	Parameters:
**		doall -- if set, include everything in the queue (even
**			the jobs that cannot be run because the load
**			average is too high).  Otherwise, exclude those
**			jobs.
**
**	Returns:
**		The number of request in the queue (not necessarily
**		the number of requests in WorkQ however).
**
**	Side Effects:
**		Sets WorkQ to the queue of available work, in order.
*/

# define NEED_P		001
# define NEED_T		002
# define NEED_R		004
# define NEED_S		010

static WORK	*WorkList = NULL;
static int	WorkListSize = 0;

int
orderq(doall)
	bool doall;
{
	register struct dirent *d;
	register WORK *w;
	register char *p;
	DIR *f;
	register int i;
	int wn = -1;
	int wc;
	QUEUE_CHAR *check;
	
	if (tTd(41, 1))
	{
		printf("orderq:\n");

		check = QueueLimitId;
		while (check != NULL)
		{
			printf("\tQueueLimitId = %s\n",
			       check->queue_match);
			check = check->queue_next;
		}

		check = QueueLimitSender;
		while (check != NULL)
		{
			printf("\tQueueLimitSender = %s\n",
			       check->queue_match);
			check = check->queue_next;
		}

		check = QueueLimitRecipient;
		while (check != NULL)
		{
			printf("\tQueueLimitRecipient = %s\n",
			       check->queue_match);
			check = check->queue_next;
		}
	}

	/* clear out old WorkQ */
	for (w = WorkQ; w != NULL; )
	{
		register WORK *nw = w->w_next;

		WorkQ = nw;
		free(w->w_name);
		if (w->w_host)
			free(w->w_host);
		free((char *) w);
		w = nw;
	}

	/* open the queue directory */
	f = opendir(".");
	if (f == NULL)
	{
		syserr("orderq: cannot open \"%s\" as \".\"", QueueDir);
		return (0);
	}

	/*
	**  Read the work directory.
	*/

	while ((d = readdir(f)) != NULL)
	{
		FILE *cf;
		int qfver = 0;
		char lbuf[MAXNAME + 1];
		extern bool strcontainedin __P((char *, char *));

		if (tTd(41, 50))
			printf("orderq: checking %s\n", d->d_name);

		/* is this an interesting entry? */
		if (d->d_name[0] != 'q' || d->d_name[1] != 'f')
			continue;

		if (strlen(d->d_name) > MAXQFNAME)
		{
			if (Verbose)
				printf("orderq: %s too long, %d max characters\n",
					d->d_name, MAXQFNAME);
			if (LogLevel > 0)
				sm_syslog(LOG_ALERT, NOQID,
					"orderq: %s too long, %d max characters",
					d->d_name, MAXQFNAME);
			continue;
		}

		check = QueueLimitId;
		while (check != NULL)
		{
			if (strcontainedin(check->queue_match, d->d_name))
				break;
			else
				check = check->queue_next;
		}
		if (QueueLimitId != NULL && check == NULL)
			continue;

#ifdef PICKY_QF_NAME_CHECK
		/*
		**  Check queue name for plausibility.  This handles
		**  both old and new type ids.
		*/

		p = d->d_name + 2;
		if (isupper(p[0]) && isupper(p[2]))
			p += 3;
		else if (isupper(p[1]))
			p += 2;
		else
			p = d->d_name;
		for (i = 0; isdigit(*p); p++)
			i++;
		if (i < 5 || *p != '\0')
		{
			if (Verbose)
				printf("orderq: bogus qf name %s\n", d->d_name);
			if (LogLevel > 0)
				sm_syslog(LOG_ALERT, NOQID,
					"orderq: bogus qf name %s",
					d->d_name);
			if (strlen(d->d_name) > (SIZE_T) MAXNAME)
				d->d_name[MAXNAME] = '\0';
			strcpy(lbuf, d->d_name);
			lbuf[0] = 'Q';
			(void) rename(d->d_name, lbuf);
			continue;
		}
#endif

		/* open control file (if not too many files) */
		if (++wn >= MaxQueueRun && MaxQueueRun > 0)
		{
			if (wn == MaxQueueRun && LogLevel > 0)
				sm_syslog(LOG_ALERT, NOQID,
					"WorkList for %s maxed out at %d",
					QueueDir, MaxQueueRun);
			continue;
		}
		if (wn >= WorkListSize)
		{
			extern void grow_wlist __P((void));

			grow_wlist();
			if (wn >= WorkListSize)
				continue;
		}

		cf = fopen(d->d_name, "r");
		if (cf == NULL)
		{
			/* this may be some random person sending hir msgs */
			/* syserr("orderq: cannot open %s", cbuf); */
			if (tTd(41, 2))
				printf("orderq: cannot open %s: %s\n",
					d->d_name, errstring(errno));
			errno = 0;
			wn--;
			continue;
		}
		w = &WorkList[wn];
		w->w_name = newstr(d->d_name);
		w->w_host = NULL;
		w->w_lock = !lockfile(fileno(cf), w->w_name, NULL, LOCK_SH|LOCK_NB);
		w->w_tooyoung = FALSE;

		/* make sure jobs in creation don't clog queue */
		w->w_pri = 0x7fffffff;
		w->w_ctime = 0;

		/* extract useful information */
		i = NEED_P | NEED_T;
		if (QueueLimitSender != NULL)
			i |= NEED_S;
		if (QueueSortOrder == QS_BYHOST || QueueLimitRecipient != NULL)
			i |= NEED_R;
		while (i != 0 && fgets(lbuf, sizeof lbuf, cf) != NULL)
		{
			int c;
			time_t age;
			extern bool strcontainedin __P((char *, char *));

			p = strchr(lbuf, '\n');
			if (p != NULL)
				*p = '\0';
			else
			{
				/* flush rest of overly long line */
				while ((c = getc(cf)) != EOF && c != '\n')
					continue;
			}

			switch (lbuf[0])
			{
			  case 'V':
				qfver = atoi(&lbuf[1]);
				break;

			  case 'P':
				w->w_pri = atol(&lbuf[1]);
				i &= ~NEED_P;
				break;

			  case 'T':
				w->w_ctime = atol(&lbuf[1]);
				i &= ~NEED_T;
				break;

			  case 'R':
				if (w->w_host == NULL &&
				    (p = strrchr(&lbuf[1], '@@')) != NULL)
					w->w_host = newstr(&p[1]);
				if (QueueLimitRecipient == NULL)
				{
					i &= ~NEED_R;
					break;
				}
				if (qfver > 0)
				{
					p = strchr(&lbuf[1], ':');
					if (p == NULL)
						p = &lbuf[1];
				}
				else
					p = &lbuf[1];
				check = QueueLimitRecipient;
				while (check != NULL)
				{
					if (strcontainedin(check->queue_match,
							   p))
						break;
					else
						check = check->queue_next;
				}
				if (check != NULL)
					i &= ~NEED_R;
				break;

			  case 'S':
				  check = QueueLimitSender;
				  while (check != NULL)
				  {
					  if (strcontainedin(check->queue_match,
							     &lbuf[1]))
						  break;
					  else
						  check = check->queue_next;
				  }
				  if (check != NULL)
					  i &= ~NEED_S;
				break;

			  case 'K':
				age = curtime() - (time_t) atol(&lbuf[1]);
				if (age >= 0 && MinQueueAge > 0 &&
				    age < MinQueueAge)
					w->w_tooyoung = TRUE;
				break;

			  case 'N':
				if (atol(&lbuf[1]) == 0)
					w->w_tooyoung = FALSE;
				break;
			}
		}
		(void) fclose(cf);

		if ((!doall && shouldqueue(w->w_pri, w->w_ctime)) ||
		    bitset(NEED_R|NEED_S, i))
		{
			/* don't even bother sorting this job in */
			if (tTd(41, 49))
				printf("skipping %s (%x)\n", w->w_name, i);
			free(w->w_name);
			if (w->w_host)
				free(w->w_host);
			wn--;
		}
	}
	(void) closedir(f);
	wn++;

	wc = min(wn, WorkListSize);
	if (wc > MaxQueueRun && MaxQueueRun > 0)
		wc = MaxQueueRun;

	if (QueueSortOrder == QS_BYHOST)
	{
		extern int workcmpf1();
		extern int workcmpf2();

		/*
		**  Sort the work directory for the first time,
		**  based on host name, lock status, and priority.
		*/

		qsort((char *) WorkList, wc, sizeof *WorkList, workcmpf1);

		/*
		**  If one message to host is locked, "lock" all messages
		**  to that host.
		*/

		i = 0;
		while (i < wc)
		{
			if (!WorkList[i].w_lock)
			{
				i++;
				continue;
			}
			w = &WorkList[i];
			while (++i < wc)
			{
				extern int sm_strcasecmp __P((char *, char *));

				if (WorkList[i].w_host == NULL &&
				    w->w_host == NULL)
					WorkList[i].w_lock = TRUE;
				else if (WorkList[i].w_host != NULL &&
					 w->w_host != NULL &&
					 sm_strcasecmp(WorkList[i].w_host, w->w_host) == 0)
					WorkList[i].w_lock = TRUE;
				else
					break;
			}
		}

		/*
		**  Sort the work directory for the second time,
		**  based on lock status, host name, and priority.
		*/

		qsort((char *) WorkList, wc, sizeof *WorkList, workcmpf2);
	}
	else if (QueueSortOrder == QS_BYTIME)
	{
		extern int workcmpf3();

		/*
		**  Simple sort based on submission time only.
		*/

		qsort((char *) WorkList, wc, sizeof *WorkList, workcmpf3);
	}
	else
	{
		extern int workcmpf0();

		/*
		**  Simple sort based on queue priority only.
		*/

		qsort((char *) WorkList, wc, sizeof *WorkList, workcmpf0);
	}

	/*
	**  Convert the work list into canonical form.
	**	Should be turning it into a list of envelopes here perhaps.
	*/

	WorkQ = NULL;
	for (i = wc; --i >= 0; )
	{
		w = (WORK *) xalloc(sizeof *w);
		w->w_name = WorkList[i].w_name;
		w->w_host = WorkList[i].w_host;
		w->w_lock = WorkList[i].w_lock;
		w->w_tooyoung = WorkList[i].w_tooyoung;
		w->w_pri = WorkList[i].w_pri;
		w->w_ctime = WorkList[i].w_ctime;
		w->w_next = WorkQ;
		WorkQ = w;
	}
	if (WorkList != NULL)
		free(WorkList);
	WorkList = NULL;
	WorkListSize = 0;

	if (tTd(40, 1))
	{
		for (w = WorkQ; w != NULL; w = w->w_next)
			printf("%32s: pri=%ld\n", w->w_name, w->w_pri);
	}

	return (wn);
}
/*
**  GROW_WLIST -- make the work list larger
**
**	Parameters:
**		none.
**
**	Returns:
**		none.
**
**	Side Effects:
**		Adds another QUEUESEGSIZE entries to WorkList if possible.
**		It can fail if there isn't enough memory, so WorkListSize
**		should be checked again upon return.
*/

void
grow_wlist()
{
	if (tTd(41, 1))
		printf("grow_wlist: WorkListSize=%d\n", WorkListSize);
	if (WorkList == NULL)
	{
		WorkList = (WORK *) xalloc(sizeof(WORK) * (QUEUESEGSIZE + 1));
		WorkListSize = QUEUESEGSIZE;
	}
	else
	{
		int newsize = WorkListSize + QUEUESEGSIZE;
		WORK *newlist = (WORK *) realloc((char *)WorkList,
					  (unsigned)sizeof(WORK) * (newsize + 1));

		if (newlist != NULL)
		{
			WorkListSize = newsize;
			WorkList = newlist;
			if (LogLevel > 1)
			{
				sm_syslog(LOG_NOTICE, NOQID,
					"grew WorkList for %s to %d",
					QueueDir, WorkListSize);
			}
		}
		else if (LogLevel > 0)
		{
			sm_syslog(LOG_ALERT, NOQID,
				"FAILED to grow WorkList for %s to %d",
				QueueDir, newsize);
		}
	}
	if (tTd(41, 1))
		printf("grow_wlist: WorkListSize now %d\n", WorkListSize);
}
/*
**  WORKCMPF0 -- simple priority-only compare function.
**
**	Parameters:
**		a -- the first argument.
**		b -- the second argument.
**
**	Returns:
**		-1 if a < b
**		 0 if a == b
**		+1 if a > b
**
**	Side Effects:
**		none.
*/

int
workcmpf0(a, b)
	register WORK *a;
	register WORK *b;
{
	long pa = a->w_pri;
	long pb = b->w_pri;

	if (pa == pb)
		return 0;
	else if (pa > pb)
		return 1;
	else
		return -1;
}
/*
**  WORKCMPF1 -- first compare function for ordering work based on host name.
**
**	Sorts on host name, lock status, and priority in that order.
**
**	Parameters:
**		a -- the first argument.
**		b -- the second argument.
**
**	Returns:
**		<0 if a < b
**		 0 if a == b
**		>0 if a > b
**
**	Side Effects:
**		none.
*/

int
workcmpf1(a, b)
	register WORK *a;
	register WORK *b;
{
	int i;
	extern int sm_strcasecmp __P((char *, char *));

	/* host name */
	if (a->w_host != NULL && b->w_host == NULL)
		return 1;
	else if (a->w_host == NULL && b->w_host != NULL)
		return -1;
	if (a->w_host != NULL && b->w_host != NULL &&
	    (i = sm_strcasecmp(a->w_host, b->w_host)) != 0)
		return i;

	/* lock status */
	if (a->w_lock != b->w_lock)
		return b->w_lock - a->w_lock;

	/* job priority */
	return a->w_pri - b->w_pri;
}
/*
**  WORKCMPF2 -- second compare function for ordering work based on host name.
**
**	Sorts on lock status, host name, and priority in that order.
**
**	Parameters:
**		a -- the first argument.
**		b -- the second argument.
**
**	Returns:
**		<0 if a < b
**		 0 if a == b
**		>0 if a > b
**
**	Side Effects:
**		none.
*/

int
workcmpf2(a, b)
	register WORK *a;
	register WORK *b;
{
	int i;
	extern int sm_strcasecmp __P((char *, char *));

	/* lock status */
	if (a->w_lock != b->w_lock)
		return a->w_lock - b->w_lock;

	/* host name */
	if (a->w_host != NULL && b->w_host == NULL)
		return 1;
	else if (a->w_host == NULL && b->w_host != NULL)
		return -1;
	if (a->w_host != NULL && b->w_host != NULL &&
	    (i = sm_strcasecmp(a->w_host, b->w_host)) != 0)
		return i;

	/* job priority */
	return a->w_pri - b->w_pri;
}
/*
**  WORKCMPF3 -- simple submission-time-only compare function.
**
**	Parameters:
**		a -- the first argument.
**		b -- the second argument.
**
**	Returns:
**		-1 if a < b
**		 0 if a == b
**		+1 if a > b
**
**	Side Effects:
**		none.
*/

int
workcmpf3(a, b)
	register WORK *a;
	register WORK *b;
{
	if (a->w_ctime > b->w_ctime)
		return 1;
	else if (a->w_ctime < b->w_ctime)
		return -1;
	else
		return 0;
}
/*
**  DOWORK -- do a work request.
**
**	Parameters:
**		id -- the ID of the job to run.
**		forkflag -- if set, run this in background.
**		requeueflag -- if set, reinstantiate the queue quickly.
**			This is used when expanding aliases in the queue.
**			If forkflag is also set, it doesn't wait for the
**			child.
**		e - the envelope in which to run it.
**
**	Returns:
**		process id of process that is running the queue job.
**
**	Side Effects:
**		The work request is satisfied if possible.
*/

pid_t
dowork(id, forkflag, requeueflag, e)
	char *id;
	bool forkflag;
	bool requeueflag;
	register ENVELOPE *e;
{
	register pid_t pid;
	extern bool readqf __P((ENVELOPE *));

	if (tTd(40, 1))
		printf("dowork(%s)\n", id);

	/*
	**  Fork for work.
	*/

	if (forkflag)
	{
		pid = fork();
		if (pid < 0)
		{
			syserr("dowork: cannot fork");
			return 0;
		}
		else if (pid > 0)
		{
			/* parent -- clean out connection cache */
			mci_flush(FALSE, NULL);
		}
		else
		{
			/* child -- error messages to the transcript */
			QuickAbort = OnlyOneError = FALSE;

			/*
			**  Since the delivery may happen in a child and the
			**  parent does not wait, the parent may close the
			**  maps thereby removing any shared memory used by
			**  the map.  Therefore, open a copy of the maps for
			**  the delivery process.
			*/
		
			initmaps(FALSE, e);
		}
	}
	else
	{
		pid = 0;
	}

	if (pid == 0)
	{
		/*
		**  CHILD
		**	Lock the control file to avoid duplicate deliveries.
		**		Then run the file as though we had just read it.
		**	We save an idea of the temporary name so we
		**		can recover on interrupt.
		*/

		/* set basic modes, etc. */
		(void) alarm(0);
		clearenvelope(e, FALSE);
		e->e_flags |= EF_QUEUERUN|EF_GLOBALERRS;
		e->e_sendmode = SM_DELIVER;
		e->e_errormode = EM_MAIL;
		e->e_id = id;
		GrabTo = UseErrorsTo = FALSE;
		ExitStat = EX_OK;
		if (forkflag)
		{
			disconnect(1, e);
			OpMode = MD_DELIVER;
		}
		sm_setproctitle(TRUE, "%s: from queue", id);
		if (LogLevel > 76)
			sm_syslog(LOG_DEBUG, e->e_id,
				"dowork, pid=%d",
				getpid());

		/* don't use the headers from sendmail.cf... */
		e->e_header = NULL;

		/* read the queue control file -- return if locked */
		if (!readqf(e))
		{
			if (tTd(40, 4) && e->e_id != NULL)
				printf("readqf(%s) failed\n", e->e_id);
			e->e_id = NULL;
			if (forkflag)
				finis(FALSE, EX_OK);
			else
				return 0;
		}

		e->e_flags |= EF_INQUEUE;
		eatheader(e, requeueflag);

		if (requeueflag)
			queueup(e, FALSE);

		/* do the delivery */
		sendall(e, SM_DELIVER);

		/* finish up and exit */
		if (forkflag)
			finis(TRUE, ExitStat);
		else
			dropenvelope(e, TRUE);
	}
	e->e_id = NULL;
	return pid;
}
/*
**  READQF -- read queue file and set up environment.
**
**	Parameters:
**		e -- the envelope of the job to run.
**
**	Returns:
**		TRUE if it successfully read the queue file.
**		FALSE otherwise.
**
**	Side Effects:
**		The queue file is returned locked.
*/

bool
readqf(e)
	register ENVELOPE *e;
{
	register FILE *qfp;
	ADDRESS *ctladdr;
	struct stat st;
	char *bp;
	int qfver = 0;
	long hdrsize = 0;
	register char *p;
	char *orcpt = NULL;
	bool nomore = FALSE;
	char qf[MAXQFNAME];
	char buf[MAXLINE];
	extern ADDRESS *setctluser __P((char *, int));

	/*
	**  Read and process the file.
	*/

	strcpy(qf, queuename(e, 'q'));
	qfp = fopen(qf, "r+");
	if (qfp == NULL)
	{
		if (tTd(40, 8))
			printf("readqf(%s): fopen failure (%s)\n",
				qf, errstring(errno));
		if (errno != ENOENT)
			syserr("readqf: no control file %s", qf);
		return FALSE;
	}

	if (!lockfile(fileno(qfp), qf, NULL, LOCK_EX|LOCK_NB))
	{
		/* being processed by another queuer */
		if (Verbose || tTd(40, 8))
			printf("%s: locked\n", e->e_id);
		if (LogLevel > 19)
			sm_syslog(LOG_DEBUG, e->e_id, "locked");
		(void) fclose(qfp);
		return FALSE;
	}

	/*
	**  Check the queue file for plausibility to avoid attacks.
	*/

	if (fstat(fileno(qfp), &st) < 0)
	{
		/* must have been being processed by someone else */
		if (tTd(40, 8))
			printf("readqf(%s): fstat failure (%s)\n",
				qf, errstring(errno));
		fclose(qfp);
		return FALSE;
	}

	if ((st.st_uid != geteuid() && geteuid() != RealUid) ||
	    bitset(S_IWOTH|S_IWGRP, st.st_mode))
	{
		if (LogLevel > 0)
		{
			sm_syslog(LOG_ALERT, e->e_id,
				"bogus queue file, uid=%d, mode=%o",
				st.st_uid, st.st_mode);
		}
		if (tTd(40, 8))
			printf("readqf(%s): bogus file\n", qf);
		loseqfile(e, "bogus file uid in mqueue");
		fclose(qfp);
		return FALSE;
	}

	if (st.st_size == 0)
	{
		/* must be a bogus file -- if also old, just remove it */
		if (st.st_ctime + 10 * 60 < curtime())
		{
			qf[0] = 'd';
			(void) unlink(qf);
			qf[0] = 'q';
			(void) unlink(qf);
		}
		fclose(qfp);
		return FALSE;
	}

	if (st.st_nlink == 0)
	{
		/*
		**  Race condition -- we got a file just as it was being
		**  unlinked.  Just assume it is zero length.
		*/

		fclose(qfp);
		return FALSE;
	}

	/* good file -- save this lock */
	e->e_lockfp = qfp;

	/* do basic system initialization */
	initsys(e);
	define('i', e->e_id, e);

	LineNumber = 0;
	e->e_flags |= EF_GLOBALERRS;
	OpMode = MD_DELIVER;
	ctladdr = NULL;
	e->e_dfino = -1;
	e->e_msgsize = -1;
	while ((bp = fgetfolded(buf, sizeof buf, qfp)) != NULL)
	{
		register char *p;
		u_long qflags;
		ADDRESS *q;
		int mid;
		auto char *ep;

		if (tTd(40, 4))
			printf("+++++ %s\n", bp);
		if (nomore)
		{
			/* hack attack */
			syserr("SECURITY ALERT: extra data in qf: %s", bp);
			fclose(qfp);
			loseqfile(e, "bogus queue line");
			return FALSE;
		}
		switch (bp[0])
		{
		  case 'V':		/* queue file version number */
			qfver = atoi(&bp[1]);
			if (qfver <= QF_VERSION)
				break;
			syserr("Version number in qf (%d) greater than max (%d)",
				qfver, QF_VERSION);
			fclose(qfp);
			loseqfile(e, "unsupported qf file version");
			return FALSE;

		  case 'C':		/* specify controlling user */
			ctladdr = setctluser(&bp[1], qfver);
			break;

		  case 'Q':		/* original recipient */
			orcpt = newstr(&bp[1]);
			break;

		  case 'R':		/* specify recipient */
			p = bp;
			qflags = 0;
			if (qfver >= 1)
			{
				/* get flag bits */
				while (*++p != '\0' && *p != ':')
				{
					switch (*p)
					{
					  case 'N':
						qflags |= QHASNOTIFY;
						break;

					  case 'S':
						qflags |= QPINGONSUCCESS;
						break;

					  case 'F':
						qflags |= QPINGONFAILURE;
						break;

					  case 'D':
						qflags |= QPINGONDELAY;
						break;

					  case 'P':
						qflags |= QPRIMARY;
						break;
					}
				}
			}
			else
				qflags |= QPRIMARY;
			q = parseaddr(++p, NULLADDR, RF_COPYALL, '\0', NULL, e);
			if (q != NULL)
			{
				q->q_alias = ctladdr;
				if (qfver >= 1)
					q->q_flags &= ~Q_PINGFLAGS;
				q->q_flags |= qflags;
				q->q_orcpt = orcpt;
				(void) recipient(q, &e->e_sendqueue, 0, e);
			}
			orcpt = NULL;
			break;

		  case 'E':		/* specify error recipient */
			/* no longer used */
			break;

		  case 'H':		/* header */
			(void) chompheader(&bp[1], FALSE, NULL, e);
			hdrsize += strlen(&bp[1]);
			break;

		  case 'L':		/* Solaris Content-Length: */
		  case 'M':		/* message */
			/* ignore this; we want a new message next time */
			break;

		  case 'S':		/* sender */
			setsender(newstr(&bp[1]), e, NULL, '\0', TRUE);
			break;

		  case 'B':		/* body type */
			e->e_bodytype = newstr(&bp[1]);
			break;

#if _FFR_SAVE_CHARSET
		  case 'X':		/* character set */
			e->e_charset = newstr(&bp[1]);
			break;
#endif

		  case 'D':		/* data file name */
			/* obsolete -- ignore */
			break;

		  case 'T':		/* init time */
			e->e_ctime = atol(&bp[1]);
			break;

		  case 'I':		/* data file's inode number */
			/* regenerated below */
			break;

		  case 'K':		/* time of last deliver attempt */
			e->e_dtime = atol(&buf[1]);
			break;

		  case 'N':		/* number of delivery attempts */
			e->e_ntries = atoi(&buf[1]);

			/* if this has been tried recently, let it be */
			if (e->e_ntries > 0 &&
			    MinQueueAge > 0 && e->e_dtime <= curtime() &&
			    curtime() < e->e_dtime + MinQueueAge)
			{
				char *howlong = pintvl(curtime() - e->e_dtime, TRUE);

				if (Verbose || tTd(40, 8))
					printf("%s: too young (%s)\n",
						e->e_id, howlong);
				if (LogLevel > 19)
					sm_syslog(LOG_DEBUG, e->e_id,
						"too young (%s)",
						howlong);
				e->e_id = NULL;
				unlockqueue(e);
				return FALSE;
			}
			break;

		  case 'P':		/* message priority */
			e->e_msgpriority = atol(&bp[1]) + WkTimeFact;
			break;

		  case 'F':		/* flag bits */
			if (strncmp(bp, "From ", 5) == 0)
			{
				/* we are being spoofed! */
				syserr("SECURITY ALERT: bogus qf line %s", bp);
				fclose(qfp);
				loseqfile(e, "bogus queue line");
				return FALSE;
			}
			for (p = &bp[1]; *p != '\0'; p++)
			{
				switch (*p)
				{
				  case 'w':	/* warning sent */
					e->e_flags |= EF_WARNING;
					break;

				  case 'r':	/* response */
					e->e_flags |= EF_RESPONSE;
					break;

				  case '8':	/* has 8 bit data */
					e->e_flags |= EF_HAS8BIT;
					break;

				  case 'b':	/* delete Bcc: header */
					e->e_flags |= EF_DELETE_BCC;
					break;

				  case 'd':	/* envelope has DSN RET= */
					e->e_flags |= EF_RET_PARAM;
					break;

				  case 'n':	/* don't return body */
					e->e_flags |= EF_NO_BODY_RETN;
					break;
				}
			}
			break;

		  case 'Z':		/* original envelope id from ESMTP */
			e->e_envid = newstr(&bp[1]);
			break;

		  case '$':		/* define macro */
			mid = macid(&bp[1], &ep);
			define(mid, newstr(ep), e);
			break;

		  case '.':		/* terminate file */
			nomore = TRUE;
			break;

		  default:
			syserr("readqf: %s: line %d: bad line \"%s\"",
				qf, LineNumber, shortenstring(bp, MAXSHORTSTR));
			fclose(qfp);
			loseqfile(e, "unrecognized line");
			return FALSE;
		}

		if (bp != buf)
			free(bp);
	}

	/*
	**  If we haven't read any lines, this queue file is empty.
	**  Arrange to remove it without referencing any null pointers.
	*/

	if (LineNumber == 0)
	{
		errno = 0;
		e->e_flags |= EF_CLRQUEUE | EF_FATALERRS | EF_RESPONSE;
		return TRUE;
	}

	/*
	**  Arrange to read the data file.
	*/

	p = queuename(e, 'd');
	e->e_dfp = fopen(p, "r");
	if (e->e_dfp == NULL)
	{
		syserr("readqf: cannot open %s", p);
	}
	else
	{
		e->e_flags |= EF_HAS_DF;
		if (fstat(fileno(e->e_dfp), &st) >= 0)
		{
			e->e_msgsize = st.st_size + hdrsize;
			e->e_dfdev = st.st_dev;
			e->e_dfino = st.st_ino;
		}
	}

	return TRUE;
}
/*
**  PRINTQUEUE -- print out a representation of the mail queue
**
**	Parameters:
**		none.
**
**	Returns:
**		none.
**
**	Side Effects:
**		Prints a listing of the mail queue on the standard output.
*/

void
printqueue()
{
	register WORK *w;
	FILE *f;
	int nrequests;
	char buf[MAXLINE];

	/*
	**  Check for permission to print the queue
	*/

	if (bitset(PRIV_RESTRICTMAILQ, PrivacyFlags) && RealUid != 0)
	{
		struct stat st;
# ifdef NGROUPS_MAX
		int n;
		extern GIDSET_T InitialGidSet[NGROUPS_MAX];
# endif

		if (stat(QueueDir, &st) < 0)
		{
			syserr("Cannot stat %s", QueueDir);
			return;
		}
# ifdef NGROUPS_MAX
		n = NGROUPS_MAX;
		while (--n >= 0)
		{
			if (InitialGidSet[n] == st.st_gid)
				break;
		}
		if (n < 0 && RealGid != st.st_gid)
# else
		if (RealGid != st.st_gid)
# endif
		{
			usrerr("510 You are not permitted to see the queue");
			setstat(EX_NOPERM);
			return;
		}
	}

	/*
	**  Read and order the queue.
	*/

	nrequests = orderq(TRUE);

	/*
	**  Print the work list that we have read.
	*/

	/* first see if there is anything */
	if (nrequests <= 0)
	{
		printf("Mail queue is empty\n");
		return;
	}

	CurrentLA = getla();	/* get load average */

	printf("\t\tMail Queue (%d request%s", nrequests, nrequests == 1 ? "" : "s");
	if (MaxQueueRun > 0 && nrequests > MaxQueueRun)
		printf(", only %d printed", MaxQueueRun);
	if (Verbose)
		printf(")\n--Q-ID-- --Size-- -Priority- ---Q-Time--- -----------Sender/Recipient-----------\n");
	else
		printf(")\n--Q-ID-- --Size-- -----Q-Time----- ------------Sender/Recipient------------\n");
	for (w = WorkQ; w != NULL; w = w->w_next)
	{
		struct stat st;
		auto time_t submittime = 0;
		long dfsize;
		int flags = 0;
		int qfver;
		char statmsg[MAXLINE];
		char bodytype[MAXNAME + 1];

		printf("%8s", w->w_name + 2);
		f = fopen(w->w_name, "r");
		if (f == NULL)
		{
			printf(" (job completed)\n");
			errno = 0;
			continue;
		}
		w->w_name[0] = 'd';
		if (stat(w->w_name, &st) >= 0)
			dfsize = st.st_size;
		else
			dfsize = -1;
		if (w->w_lock)
			printf("*");
		else if (w->w_tooyoung)
			printf("-");
		else if (shouldqueue(w->w_pri, w->w_ctime))
			printf("X");
		else
			printf(" ");
		errno = 0;

		statmsg[0] = bodytype[0] = '\0';
		qfver = 0;
		while (fgets(buf, sizeof buf, f) != NULL)
		{
			register int i;
			register char *p;

			fixcrlf(buf, TRUE);
			switch (buf[0])
			{
			  case 'V':	/* queue file version */
				qfver = atoi(&buf[1]);
				break;

			  case 'M':	/* error message */
				if ((i = strlen(&buf[1])) >= sizeof statmsg)
					i = sizeof statmsg - 1;
				bcopy(&buf[1], statmsg, i);
				statmsg[i] = '\0';
				break;

			  case 'B':	/* body type */
				if ((i = strlen(&buf[1])) >= sizeof bodytype)
					i = sizeof bodytype - 1;
				bcopy(&buf[1], bodytype, i);
				bodytype[i] = '\0';
				break;

			  case 'S':	/* sender name */
				if (Verbose)
					printf("%8ld %10ld%c%.12s %.78s",
					    dfsize,
					    w->w_pri,
					    bitset(EF_WARNING, flags) ? '+' : ' ',
					    ctime(&submittime) + 4,
					    &buf[1]);
				else
					printf("%8ld %.16s %.45s", dfsize,
					    ctime(&submittime), &buf[1]);
				if (statmsg[0] != '\0' || bodytype[0] != '\0')
				{
					printf("\n    %10.10s", bodytype);
					if (statmsg[0] != '\0')
						printf("   (%.*s)",
							Verbose ? 100 : 60,
							statmsg);
				}
				break;

			  case 'C':	/* controlling user */
				if (Verbose)
					printf("\n\t\t\t\t      (---%.74s---)",
						&buf[1]);
				break;

			  case 'R':	/* recipient name */
				p = &buf[1];
				if (qfver >= 1)
				{
					p = strchr(p, ':');
					if (p == NULL)
						break;
					p++;
				}
				if (Verbose)
					printf("\n\t\t\t\t\t  %.78s", p);
				else
					printf("\n\t\t\t\t   %.45s", p);
				break;

			  case 'T':	/* creation time */
				submittime = atol(&buf[1]);
				break;

			  case 'F':	/* flag bits */
				for (p = &buf[1]; *p != '\0'; p++)
				{
					switch (*p)
					{
					  case 'w':
						flags |= EF_WARNING;
						break;
					}
				}
			}
		}
		if (submittime == (time_t) 0)
			printf(" (no control file)");
		printf("\n");
		(void) fclose(f);
	}
}

# endif /* QUEUE */
/*
**  QUEUENAME -- build a file name in the queue directory for this envelope.
**
**	Assigns an id code if one does not already exist.
**	This code is very careful to avoid trashing existing files
**	under any circumstances.
**
**	Parameters:
**		e -- envelope to build it in/from.
**		type -- the file type, used as the first character
**			of the file name.
**
**	Returns:
**		a pointer to the new file name (in a static buffer).
**
**	Side Effects:
**		If no id code is already assigned, queuename will
**		assign an id code, create a qf file, and leave a
**		locked, open-for-write file pointer in the envelope.
*/

#ifndef ENOLCK
# define ENOLCK		-1
#endif
#ifndef ENOSPC
# define ENOSPC		-1
#endif

char *
queuename(e, type)
	register ENVELOPE *e;
	int type;
{
	static pid_t pid = -1;
	static char c0;
	static char c1;
	static char c2;
	time_t now;
	struct tm *tm;
	static char buf[MAXNAME + 1];

	if (e->e_id == NULL)
	{
		char qf[MAXQFNAME];

		/* find a unique id */
		if (pid != getpid())
		{
			/* new process -- start back at "AA" */
			pid = getpid();
			now = curtime();
			tm = localtime(&now);
			c0 = 'A' + tm->tm_hour;
			c1 = 'A';
			c2 = 'A' - 1;
		}
		(void) snprintf(qf, sizeof qf, "qf%cAA%05d", c0, pid);

		while (c1 < '~' || c2 < 'Z')
		{
			int i;
			int attempts = 0;

			if (c2 >= 'Z')
			{
				c1++;
				c2 = 'A' - 1;
			}
			qf[3] = c1;
			qf[4] = ++c2;
			if (tTd(7, 20))
				printf("queuename: trying \"%s\"\n", qf);

			i = open(qf, O_WRONLY|O_CREAT|O_EXCL, FileMode);
			if (i < 0)
			{
				if (errno == EEXIST)
					continue;
				syserr("queuename: Cannot create \"%s\" in \"%s\" (euid=%d)",
					qf, QueueDir, geteuid());
				finis(FALSE, EX_UNAVAILABLE);
			}
			do
			{
				if (attempts > 0)
					sleep(attempts);
				e->e_lockfp = 0;
				if (lockfile(i, qf, NULL, LOCK_EX|LOCK_NB))
				{
					e->e_lockfp = fdopen(i, "w");
					break;
				}
			} while ((errno == ENOLCK || errno == ENOSPC) &&
				 attempts++ < 4);

			/* Successful lock */
			if (e->e_lockfp != 0)
				break;

#if !HASFLOCK
			if (errno != EAGAIN && errno != EACCES)
#else
			if (errno != EWOULDBLOCK)
#endif
			{
				syserr("queuename: Cannot lock \"%s\" in \"%s\" (euid=%d)",
					qf, QueueDir, geteuid());
				finis(FALSE, EX_OSERR);
			}

			/* a reader got the file; abandon it and try again */
			(void) close(i);
		}
		if (c1 >= '~' && c2 >= 'Z')
		{
			syserr("queuename: Cannot create \"%s\" in \"%s\" (euid=%d)",
				qf, QueueDir, geteuid());
			finis(FALSE, EX_OSERR);
		}
		e->e_id = newstr(&qf[2]);
		define('i', e->e_id, e);
		if (tTd(7, 1))
			printf("queuename: assigned id %s, env=%lx\n",
			       e->e_id, (u_long) e);
		if (tTd(7, 9))
		{
			printf("  lockfd=");
			dumpfd(fileno(e->e_lockfp), TRUE, FALSE);
		}
		if (LogLevel > 93)
			sm_syslog(LOG_DEBUG, e->e_id, "assigned id");
	}

	if (type == '\0')
		return (NULL);
	(void) snprintf(buf, sizeof buf, "%cf%s", type, e->e_id);
	if (tTd(7, 2))
		printf("queuename: %s\n", buf);
	return (buf);
}
/*
**  UNLOCKQUEUE -- unlock the queue entry for a specified envelope
**
**	Parameters:
**		e -- the envelope to unlock.
**
**	Returns:
**		none
**
**	Side Effects:
**		unlocks the queue for `e'.
*/

void
unlockqueue(e)
	ENVELOPE *e;
{
	if (tTd(51, 4))
		printf("unlockqueue(%s)\n",
			e->e_id == NULL ? "NOQUEUE" : e->e_id);

	/* if there is a lock file in the envelope, close it */
	if (e->e_lockfp != NULL)
		xfclose(e->e_lockfp, "unlockqueue", e->e_id);
	e->e_lockfp = NULL;

	/* don't create a queue id if we don't already have one */
	if (e->e_id == NULL)
		return;

	/* remove the transcript */
	if (LogLevel > 87)
		sm_syslog(LOG_DEBUG, e->e_id, "unlock");
	if (!tTd(51, 104))
		xunlink(queuename(e, 'x'));

}
/*
**  SETCTLUSER -- create a controlling address
**
**	Create a fake "address" given only a local login name; this is
**	used as a "controlling user" for future recipient addresses.
**
**	Parameters:
**		user -- the user name of the controlling user.
**		qfver -- the version stamp of this qf file.
**
**	Returns:
**		An address descriptor for the controlling user.
**
**	Side Effects:
**		none.
*/

ADDRESS *
setctluser(user, qfver)
	char *user;
	int qfver;
{
	register ADDRESS *a;
	struct passwd *pw;
	char *p;

	/*
	**  See if this clears our concept of controlling user.
	*/

	if (user == NULL || *user == '\0')
		return NULL;

	/*
	**  Set up addr fields for controlling user.
	*/

	a = (ADDRESS *) xalloc(sizeof *a);
	bzero((char *) a, sizeof *a);

	if (*user == '\0')
	{
		p = NULL;
		a->q_user = newstr(DefUser);
	}
	else if (*user == ':')
	{
		p = &user[1];
		a->q_user = newstr(p);
	}
	else
	{
		p = strtok(user, ":");
		a->q_user = newstr(user);
		if (qfver >= 2)
		{
			if ((p = strtok(NULL, ":")) != NULL)
				a->q_uid = atoi(p);
			if ((p = strtok(NULL, ":")) != NULL)
				a->q_gid = atoi(p);
			if ((p = strtok(NULL, ":")) != NULL)
				a->q_flags |= QGOODUID;
		}
		else if ((pw = sm_getpwnam(user)) != NULL)
		{
			if (strcmp(pw->pw_dir, "/") == 0)
				a->q_home = "";
			else
				a->q_home = newstr(pw->pw_dir);
			a->q_uid = pw->pw_uid;
			a->q_gid = pw->pw_gid;
			a->q_flags |= QGOODUID;
		}
	}

	a->q_flags |= QPRIMARY;		/* flag as a "ctladdr"  */
	a->q_mailer = LocalMailer;
	if (p == NULL)
		a->q_paddr = a->q_user;
	else
		a->q_paddr = newstr(p);
	return a;
}
/*
**  LOSEQFILE -- save the qf as Qf and try to let someone know
**
**	Parameters:
**		e -- the envelope (e->e_id will be used).
**		why -- reported to whomever can hear.
**
**	Returns:
**		none.
*/

void
loseqfile(e, why)
	register ENVELOPE *e;
	char *why;
{
	char *p;
	char buf[MAXQFNAME + 1];

	if (e == NULL || e->e_id == NULL)
		return;
	p = queuename(e, 'q');
	if (strlen(p) > MAXQFNAME)
	{
		syserr("loseqfile: queuename (%s) too long", p);
		return;
	}
	strcpy(buf, p);
	p = queuename(e, 'Q');
	if (rename(buf, p) < 0)
		syserr("cannot rename(%s, %s), uid=%d", buf, p, geteuid());
	else if (LogLevel > 0)
		sm_syslog(LOG_ALERT, e->e_id,
			"Losing %s: %s", buf, why);
}
@


1.12
log
@sendmail 8.9.3
@
text
@@


1.11
log
@sendmail 8.9.2
@
text
@d17 1
a17 1
static char sccsid[] = "@@(#)queue.c	8.210 (Berkeley) 10/15/1998 (with queueing)";
d19 1
a19 1
static char sccsid[] = "@@(#)queue.c	8.210 (Berkeley) 10/15/1998 (without queueing)";
d351 1
a351 2
		/* don't output null headers */
		if (h->h_value == NULL || h->h_value[0] == '\0')
@


1.10
log
@something hosed the sendmail import; fix up by hand
@
text
@d17 1
a17 1
static char sccsid[] = "@@(#)queue.c	8.202 (Berkeley) 6/15/98 (with queueing)";
d19 1
a19 1
static char sccsid[] = "@@(#)queue.c	8.202 (Berkeley) 6/15/98 (without queueing)";
d614 1
a614 1
			proc_list_add(pid);
d622 1
d624 3
d632 1
a632 1
	setproctitle("running queue: %s", QueueDir);
a756 1
			extern pid_t dowork __P((char *, bool, bool, ENVELOPE *));
d777 1
a777 1
	finis();
d899 8
d908 1
d1458 10
d1499 1
a1499 1
		setproctitle("%s: from queue", id);
d1515 1
a1515 1
				exit(EX_OK);
d1531 1
a1531 1
			finis();
a1801 1
				extern void unlockqueue __P((ENVELOPE *));
d2209 1
a2209 1
				exit(EX_UNAVAILABLE);
d2236 1
a2236 1
				exit(EX_OSERR);
d2246 1
a2246 1
			exit(EX_OSERR);
@


1.9
log
@Upgrade to sendmail 8.8.8
@
text
@d2 2
a3 1
 * Copyright (c) 1983, 1995-1997 Eric P. Allman
d7 3
a9 15
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
a10 11
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
d17 1
a17 1
static char sccsid[] = "@@(#)queue.c	8.175 (Berkeley) 10/4/97 (with queueing)";
d19 1
a19 1
static char sccsid[] = "@@(#)queue.c	8.175 (Berkeley) 10/4/97 (without queueing)";
d144 1
a144 1
		extern void printenvflags();
d206 1
a206 1
	fprintf(tfp, "T%ld\n", e->e_ctime);
d209 1
a209 1
	fprintf(tfp, "K%ld\n", e->e_dtime);
d220 10
a229 2
		fprintf(tfp, "I%d/%d/%ld\n",
			major(e->e_dfdev), minor(e->e_dfdev), e->e_dfino);
d349 1
a349 1
		extern bool bitzerop();
d466 1
a466 1
	static ADDRESS *lastctladdr;
a587 1
#ifdef SIGCHLD
a591 1
#endif
a612 3
#ifndef SIGCHLD
			(void) waitfor(pid);
#else
a616 1
#endif /* SIGCHLD */
a622 4
#ifndef SIGCHLD
		if (fork() != 0)
			exit(EX_OK);
#else /* SIGCHLD */
a624 1
#endif /* SIGCHLD */
d753 1
a753 1
			extern pid_t dowork();
d820 1
d825 2
a826 1

d830 24
a853 6
		if (QueueLimitId != NULL)
			printf("\tQueueLimitId = %s\n", QueueLimitId);
		if (QueueLimitSender != NULL)
			printf("\tQueueLimitSender = %s\n", QueueLimitSender);
		if (QueueLimitRecipient != NULL)
			printf("\tQueueLimitRecipient = %s\n", QueueLimitRecipient);
d884 1
a884 1
		register char *p;
d886 1
a886 1
		extern bool strcontainedin();
d898 9
a906 2
		if (QueueLimitId != NULL &&
		    !strcontainedin(QueueLimitId, d->d_name))
a988 2
			int qfver = 0;
			char *p;
d990 2
a991 1
			extern bool strcontainedin();
d1036 10
a1045 1
				if (strcontainedin(QueueLimitRecipient, p))
d1050 11
a1060 3
				if (QueueLimitSender != NULL &&
				    strcontainedin(QueueLimitSender, &lbuf[1]))
					i &= ~NEED_S;
d1064 3
a1066 1
				if ((curtime() - (time_t) atol(&lbuf[1])) < MinQueueAge)
d1099 2
a1100 2
		extern workcmpf1();
		extern workcmpf2();
d1125 2
d1132 1
a1132 1
					 strcmp(WorkList[i].w_host, w->w_host) == 0)
d1148 1
a1148 1
		extern workcmpf3();
d1158 1
a1158 1
		extern workcmpf0();
d1188 1
d1305 1
d1313 1
a1313 1
	    (i = strcmp(a->w_host, b->w_host)))
d1347 1
d1359 1
a1359 1
	    (i = strcmp(a->w_host, b->w_host)))
d1420 1
a1420 1
	extern bool readqf();
d1489 1
a1489 1
			if (tTd(40, 4))
d1776 1
d1780 1
a1780 1
				extern void unlockqueue();
d1854 1
a1854 1
				qf, LineNumber, shortenstring(bp, 203));
d2129 7
d2169 1
d2190 1
a2190 1
			if (lockfile(i, qf, NULL, LOCK_EX|LOCK_NB))
d2192 13
a2204 1
				e->e_lockfp = fdopen(i, "w");
d2206 10
@


1.8
log
@sendmail 8.8.7.
@
text
@d39 1
a39 1
static char sccsid[] = "@@(#)queue.c	8.174 (Berkeley) 7/23/97 (with queueing)";
d41 1
a41 1
static char sccsid[] = "@@(#)queue.c	8.174 (Berkeley) 7/23/97 (without queueing)";
a476 1
	char *paddr;
a515 1
	paddr = denlstring(a->q_paddr, TRUE, FALSE);
d517 1
a517 1
		fprintf(tfp, "C:%s\n", paddr);
d519 3
a521 2
		fprintf(tfp, "C%s:%ld:%ld:%s\n",
			uname, (long) uid, (long) gid, paddr);
@


1.7
log
@Sendmail 8.8.6.
@
text
@d39 1
a39 1
static char sccsid[] = "@@(#)queue.c	8.169 (Berkeley) 6/14/97 (with queueing)";
d41 1
a41 1
static char sccsid[] = "@@(#)queue.c	8.169 (Berkeley) 6/14/97 (without queueing)";
d434 3
a436 1
	if (fflush(tfp) < 0 || fsync(fileno(tfp)) < 0 || ferror(tfp))
a557 1
	extern void drop_privileges __P((void));
d674 1
a674 1
		drop_privileges();
d688 1
a688 1
		OnlyOneError = QuickAbort = FALSE;
d1467 1
d2330 1
a2330 1
	char buf[MAXQFNAME];
d2334 4
a2337 1
	if (strlen(e->e_id) > (SIZE_T) sizeof buf - 4)
d2339 2
a2340 1
	strcpy(buf, queuename(e, 'q'));
@


1.6
log
@Sendmail 8.8.5.
@
text
@d2 1
a2 1
 * Copyright (c) 1983, 1995, 1996 Eric P. Allman
d39 1
a39 1
static char sccsid[] = "@@(#)queue.c	8.153 (Berkeley) 1/14/97 (with queueing)";
d41 1
a41 1
static char sccsid[] = "@@(#)queue.c	8.153 (Berkeley) 1/14/97 (without queueing)";
d102 2
a103 1
	char buf[MAXLINE], tf[MAXLINE];
a128 1
#ifdef LOG
d130 2
a131 1
					syslog(LOG_ALERT, "queueup: cannot create %s, uid=%d: %s",
a132 1
#endif
a137 1
#ifdef LOG
d139 2
a140 1
					syslog(LOG_ALERT, "queueup: cannot lock %s: %s",
a141 1
#endif
d194 1
a194 1
		char dfname[20];
d249 5
d303 3
a305 3
				syslog(LOG_DEBUG,
					"dropenvelope: %s: q_flags = %x, paddr = %s",
					e->e_id, q->q_flags, q->q_paddr);
a459 1
# ifdef LOG
d462 1
a462 2
		syslog(LOG_DEBUG, "%s: queueup, qf=%s", e->e_id, qf);
# endif /* LOG */
d542 1
d552 1
d555 1
a555 1
	extern void runqueueevent __P((bool));
d558 2
d566 1
d568 1
a568 1
	if (CurrentLA >= QueueLA)
a573 1
#ifdef LOG
d575 3
a577 2
			syslog(LOG_INFO, "runqueue: %s", msg);
#endif
d579 12
a590 1
			(void) setevent(QueueIntvl, runqueueevent, TRUE);
a616 1
#ifdef LOG
d618 3
a620 2
				syslog(LOG_INFO, "runqueue: %s: %s", msg, err);
#endif
d622 1
a622 1
				(void) setevent(QueueIntvl, runqueueevent, TRUE);
d638 1
a638 1
				(void) setevent(QueueIntvl, runqueueevent, TRUE);
a654 1
# ifdef LOG
d656 2
a657 1
		syslog(LOG_DEBUG, "runqueue %s, pid=%d, forkflag=%d",
a658 1
# endif /* LOG */
d685 1
d687 2
d728 2
d732 17
d753 2
d756 16
a771 1
				message("");
a773 1
			}
d810 1
a810 2
runqueueevent(forkflag)
	bool forkflag;
d812 1
a812 1
	(void) runqueue(forkflag, FALSE);
d900 3
a925 1
# ifdef LOG
d927 2
a928 1
				syslog(LOG_ALERT, "orderq: bogus qf name %s",
a929 1
# endif
a941 1
# ifdef LOG
d943 3
a945 3
				syslog(LOG_ALERT, "WorkList for %s maxed out at %d",
						QueueDir, MaxQueueRun);
# endif
d988 2
d992 10
a1209 1
# ifdef LOG
d1212 3
a1214 2
				syslog(LOG_NOTICE, "grew WorkList for %s to %d",
						QueueDir, WorkListSize);
d1219 3
a1221 3
			syslog(LOG_ALERT, "FAILED to grow WorkList for %s to %d",
					QueueDir, newsize);
# endif
d1417 5
a1452 1
# ifdef LOG
d1454 3
a1456 3
			syslog(LOG_DEBUG, "%s: dowork, pid=%d", e->e_id,
			       getpid());
# endif /* LOG */
d1517 1
a1517 1
	char qf[20];
a1541 1
# ifdef LOG
d1543 1
a1543 2
			syslog(LOG_DEBUG, "%s: locked", e->e_id);
# endif /* LOG */
a1564 1
# ifdef LOG
d1567 3
a1569 2
			syslog(LOG_ALERT, "%s: bogus queue file, uid=%d, mode=%o",
				e->e_id, st.st_uid, st.st_mode);
a1570 1
# endif /* LOG */
d1580 8
a1587 5
		/* must be a bogus file -- just remove it */
		qf[0] = 'd';
		(void) unlink(qf);
		qf[0] = 'q';
		(void) unlink(qf);
d1710 1
d1723 6
d1750 1
a1750 1
			    (curtime() - e->e_dtime) < MinQueueAge)
a1757 1
#ifdef LOG
d1759 3
a1761 3
					syslog(LOG_DEBUG, "%s: too young (%s)",
						e->e_id, howlong);
#endif
d1902 1
a1902 1
		GIDSET_T gidset[NGROUPS_MAX];
d1911 1
a1911 1
		n = getgroups(NGROUPS_MAX, gidset);
d1914 1
a1914 1
			if (gidset[n] == st.st_gid)
d2117 1
a2117 1
		char qf[20];
a2179 1
# ifdef LOG
d2181 1
a2181 2
			syslog(LOG_DEBUG, "%s: assigned id", e->e_id);
# endif /* LOG */
a2221 1
# ifdef LOG
d2223 1
a2223 2
		syslog(LOG_DEBUG, "%s: unlock", e->e_id);
# endif /* LOG */
d2328 1
a2328 1
	char buf[40];
a2337 1
#ifdef LOG
d2339 2
a2340 2
		syslog(LOG_ALERT, "Losing %s: %s", buf, why);
#endif
@


1.5
log
@Update to Sendmail 8.8.4, plus recent patches, plus OpenBSD support.
Also include entire example configuration subset.
Includes smrsh (using /usr/libexec/sm.bin).

Of the top of my head, the only things I removed from the distribution were
contrib/mail.local.linux, src/Makefiles, all the *.0 and *.ps files.
Our praliases man page replaces the distributed one, ours is better.
@
text
@d39 1
a39 1
static char sccsid[] = "@@(#)queue.c	8.145 (Berkeley) 12/2/96 (with queueing)";
d41 1
a41 1
static char sccsid[] = "@@(#)queue.c	8.145 (Berkeley) 12/2/96 (without queueing)";
a70 4
#if !defined(NGROUPS_MAX) && defined(NGROUPS)
# define NGROUPS_MAX	NGROUPS	/* POSIX naming convention */
#endif

d561 1
a561 1
	if (shouldqueue(0L, curtime()))
d583 1
a583 1
		extern void intsig();
d585 1
a585 1
		extern void reapchild();
a632 1
		Verbose = FALSE;
d666 4
d1567 7
a1573 6
			if (qfver > QF_VERSION)
			{
				syserr("Version number in qf (%d) greater than max (%d)",
					qfver, QF_VERSION);
			}
			break;
d1644 1
a1644 1
			setsender(newstr(&bp[1]), e, NULL, TRUE);
@


1.4
log
@bring up to 8.7.6
@
text
@d2 1
a2 1
 * Copyright (c) 1983, 1995 Eric P. Allman
d38 2
a39 2
#ifdef QUEUE
static char sccsid[] = "@@(#)queue.c	8.98.1.3 (Berkeley) 9/16/96 (with queueing)";
d41 1
a41 1
static char sccsid[] = "@@(#)queue.c	8.98.1.3 (Berkeley) 9/16/96 (without queueing)";
d48 1
a48 1
# ifdef QUEUE
d74 2
d198 1
a198 1
		register FILE *dfp;
d266 6
d299 1
a299 2
		if (bitset(QQUEUEUP, q->q_flags) ||
		    !bitset(QDONTSEND|QBADADDR|QSENT, q->q_flags))
d301 38
a338 29
			printctladdr(q, tfp);
			if (q->q_orcpt != NULL)
				fprintf(tfp, "Q%s\n",
					denlstring(q->q_orcpt, TRUE, FALSE));
			putc('R', tfp);
			if (bitset(QPRIMARY, q->q_flags))
				putc('P', tfp);
			if (bitset(QPINGONSUCCESS, q->q_flags))
				putc('S', tfp);
			if (bitset(QPINGONFAILURE, q->q_flags))
				putc('F', tfp);
			if (bitset(QPINGONDELAY, q->q_flags))
				putc('D', tfp);
			putc(':', tfp);
			fprintf(tfp, "%s\n", denlstring(q->q_paddr, TRUE, FALSE));
			if (announce)
			{
				e->e_to = q->q_paddr;
				message("queued");
				if (LogLevel > 8)
					logdelivery(q->q_mailer, NULL, "queued",
						    NULL, (time_t) 0, e);
				e->e_to = NULL;
			}
			if (tTd(40, 1))
			{
				printf("queueing ");
				printaddr(q, FALSE);
			}
a477 1
	register struct passwd *pw;
d534 1
d537 1
a537 1
**		none.
d545 2
a546 2
void
runqueue(forkflag)
d548 1
d554 3
d569 2
a570 2
		if (Verbose)
			printf("%s\n", msg);
d576 2
a577 2
			(void) setevent(QueueIntvl, runqueue, TRUE);
		return;
d586 1
a586 1
		int pid;
d591 1
d596 16
d618 4
a621 1
			CurChildren++;
d624 2
a625 2
				(void) setevent(QueueIntvl, runqueue, TRUE);
			return;
d628 1
d633 1
d637 1
d652 1
a652 1
# ifdef DAEMON
d659 4
d678 12
d705 1
d715 3
a717 1
				printf("\nSkipping %s (sequence %d of %d)\n",
d719 1
d727 3
a729 1
				printf("\nRunning %s (sequence %d of %d)\n",
d731 1
d746 14
d933 1
d938 4
d956 14
a969 2
				if (QueueLimitRecipient == NULL ||
				    strcontainedin(QueueLimitRecipient, &lbuf[1]))
d1058 10
d1275 28
d1381 1
d1415 1
a1415 1
			dropenvelope(e);
d1443 1
a1449 1
	extern void loseqfile();
d1494 2
a1495 1
	if (st.st_uid != geteuid() || bitset(S_IWOTH|S_IWGRP, st.st_mode))
d1514 3
d1551 2
d1593 4
d1621 2
d1636 1
d1660 1
a1660 2
			if (e->e_dfino == -1)
				e->e_dfino = atol(&buf[1]);
d1669 20
d1719 12
d1740 2
a1741 1
			define(bp[1], newstr(&bp[2]), e);
d1750 1
a1750 1
				qf, LineNumber, bp);
a1771 19
	/* if this has been tried recently, let it be */
	if (e->e_ntries > 0 && (curtime() - e->e_dtime) < MinQueueAge)
	{
		char *howlong = pintvl(curtime() - e->e_dtime, TRUE);
		extern void unlockqueue();

		if (Verbose || tTd(40, 8))
			printf("%s: too young (%s)\n",
				e->e_id, howlong);
#ifdef LOG
		if (LogLevel > 19)
			syslog(LOG_DEBUG, "%s: too young (%s)",
				e->e_id, howlong);
#endif
		e->e_id = NULL;
		unlockqueue(e);
		return FALSE;
	}

d1787 1
a1787 1
			e->e_msgsize = st.st_size;
d1871 2
a1872 2
	if (nrequests > WorkListSize)
		printf(", only %d printed", WorkListSize);
d1940 1
a1940 1
					printf("%8ld %10ld%c%.12s %.38s",
d1953 3
a1955 1
						printf("   (%.60s)", statmsg);
d1961 1
a1961 1
					printf("\n\t\t\t\t      (---%.34s---)",
d1975 1
a1975 1
					printf("\n\t\t\t\t\t  %.38s", p);
d2030 1
a2030 1
	static int pid = -1;
d2096 2
a2097 1
			printf("queuename: assigned id %s, env=%x\n", e->e_id, e);
d2134 2
a2135 1
		printf("unlockqueue(%s)\n", e->e_id);
d2259 1
a2259 1
	if (strlen(e->e_id) > sizeof buf - 4)
@


1.3
log
@sendmail 8.7.4
@
text
@d39 1
a39 1
static char sccsid[] = "@@(#)queue.c	8.98.1.1 (Berkeley) 2/18/96 (with queueing)";
d41 1
a41 1
static char sccsid[] = "@@(#)queue.c	8.98.1.1 (Berkeley) 2/18/96 (without queueing)";
d69 1
a69 1
#define QF_VERSION	1	/* version number of this queue format */
d461 1
d465 1
d482 2
d485 2
d488 2
d491 2
d502 3
a504 2
	if (uid == 0 || (pw = sm_getpwuid(uid)) == NULL)
		uname = "";
d506 2
a507 3
		uname = pw->pw_name;

	fprintf(tfp, "C%s:%s\n", uname, denlstring(a->q_paddr, TRUE, FALSE));
d1312 1
a1312 1
	extern ADDRESS *setctluser();
d1434 1
a1434 1
			ctladdr = setctluser(&bp[1]);
d1889 1
a1889 1
		(void) sprintf(qf, "qf%cAA%05d", c0, pid);
d1946 1
a1946 1
	(void) sprintf(buf, "%cf%s", type, e->e_id);
d1997 1
d2007 1
a2007 1
setctluser(user)
d2009 1
d2029 1
a2029 4
	p = strchr(user, ':');
	if (p != NULL)
		*p++ = '\0';
	if (*user != '\0' && (pw = sm_getpwnam(user)) != NULL)
d2031 2
a2032 7
		if (strcmp(pw->pw_dir, "/") == 0)
			a->q_home = "";
		else
			a->q_home = newstr(pw->pw_dir);
		a->q_uid = pw->pw_uid;
		a->q_gid = pw->pw_gid;
		a->q_flags |= QGOODUID;
d2034 3
a2036 4

	if (*user != '\0')
		a->q_user = newstr(user);
	else if (p != NULL)
d2038 1
d2040 23
a2062 1
		a->q_user = newstr(DefUser);
@


1.2
log
@Sendmail 8.7.3 from NetBSD
@
text
@d39 1
a39 1
static char sccsid[] = "@@(#)queue.c	8.98 (Berkeley) 11/11/95 (with queueing)";
d41 1
a41 1
static char sccsid[] = "@@(#)queue.c	8.98 (Berkeley) 11/11/95 (without queueing)";
d250 1
a250 1
		fprintf(tfp, "B%s\n", e->e_bodytype);
d383 3
a385 1
			fprintf(tfp, "%s: %s\n", h->h_field, buf);
d402 5
a406 1
			fprintf(tfp, "%s: %s\n", h->h_field, h->h_value);
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
 * Copyright (c) 1983 Eric P. Allman
d39 1
a39 1
static char sccsid[] = "@@(#)queue.c	8.41.1.3 (Berkeley) 3/5/95 (with queueing)";
d41 1
a41 1
static char sccsid[] = "@@(#)queue.c	8.41.1.3 (Berkeley) 3/5/95 (without queueing)";
a45 1
# include <pwd.h>
d57 3
d68 6
a78 2
**		queueall -- if TRUE, queue all addresses, rather than
**			just those with the QQUEUEUP flag set.
d89 2
a90 1
queueup(e, queueall, announce)
a91 1
	bool queueall;
d105 1
d167 12
d194 1
a194 1
	if (e->e_df == NULL)
d197 2
a198 1
		extern putbody();
d200 2
a201 3
		e->e_df = queuename(e, 'd');
		e->e_df = newstr(e->e_df);
		fd = open(e->e_df, O_WRONLY|O_CREAT|O_TRUNC, FileMode);
d204 9
a212 1
				e->e_df, geteuid());
d227 12
d242 5
a246 2
	/* output creation time */
	fprintf(tfp, "T%ld\n", e->e_ctime);
d248 1
a248 1
	/* output type and name of data file */
a250 1
	fprintf(tfp, "D%s\n", e->e_df);
d262 2
d277 5
a281 1
	fprintf(tfp, "S%s\n", denlstring(e->e_from.q_paddr, TRUE, FALSE));
d283 3
a285 10
	/* output list of error recipients */
	printctladdr(NULL, NULL);
	for (q = e->e_errorqueue; q != NULL; q = q->q_next)
	{
		if (!bitset(QDONTSEND|QBADADDR, q->q_flags))
		{
			printctladdr(q, tfp);
			fprintf(tfp, "E%s\n", denlstring(q->q_paddr, TRUE, FALSE));
		}
	}
d288 1
d292 1
a292 1
		    (queueall && !bitset(QDONTSEND|QBADADDR|QSENT, q->q_flags)))
d295 14
a308 1
			fprintf(tfp, "R%s\n", denlstring(q->q_paddr, TRUE, FALSE));
d314 2
a315 1
					logdelivery(NULL, NULL, "queued", NULL, e);
d360 1
a360 1
			(void) expand(h->h_value, buf, &buf[sizeof buf], e);
d405 3
d410 2
d425 2
a426 2
			syserr("cannot rename(%s, %s), df=%s, uid=%d",
				tf, qf, e->e_df, geteuid());
d441 1
a441 1
		syslog(LOG_DEBUG, "%s: queueup, qf=%s, df=%s\n", e->e_id, qf, e->e_df);
d449 1
d486 1
a486 1
	if (uid == 0 || (pw = getpwuid(uid)) == NULL)
a492 1

d513 1
d518 2
d531 2
d534 5
a538 1
			printf("Skipping queue run -- load average too high\n");
d551 1
d564 2
d571 1
a571 1
		/* child -- double fork */
d578 1
d622 1
a622 1
	(void) orderq(FALSE);
d635 1
d639 2
a640 1
				printf("\nSkipping %s\n", w->w_name + 2);
d647 3
d656 2
d687 4
a697 1
	WORK wlist[QUEUESIZE+1];
d699 1
a699 1
	extern workcmpf();
d719 2
d741 1
a741 1
		char lbuf[MAXNAME];
d744 3
d755 1
d774 3
a776 3
#ifdef LOG
			if (LogLevel > 3)
				syslog(LOG_CRIT, "orderq: bogus qf name %s",
d778 3
a780 3
#endif
			if (strlen(d->d_name) >= MAXNAME)
				d->d_name[MAXNAME - 1] = '\0';
d786 1
d788 8
a795 2
		/* yes -- open control file (if not too many files) */
		if (++wn >= QUEUESIZE)
d797 9
d813 2
a814 2
				printf("orderq: cannot open %s (%d)\n",
					d->d_name, errno);
d819 1
a819 1
		w = &wlist[wn];
d821 3
d833 1
a833 1
		if (QueueLimitRecipient != NULL)
a836 1
			extern long atol();
d852 4
a855 1
				if (QueueLimitRecipient != NULL &&
d865 10
d883 5
d894 58
a951 3
	/*
	**  Sort the work directory.
	*/
d953 2
a954 1
	qsort((char *) wlist, min(wn, QUEUESIZE), sizeof *wlist, workcmpf);
d962 1
a962 1
	for (i = min(wn, QUEUESIZE); --i >= 0; )
d965 6
a970 3
		w->w_name = wlist[i].w_name;
		w->w_pri = wlist[i].w_pri;
		w->w_ctime = wlist[i].w_ctime;
d974 3
d987 53
a1039 1
**  WORKCMPF -- compare function for ordering work.
d1054 2
a1055 1
workcmpf(a, b)
d1063 1
a1063 1
		return (0);
d1065 1
a1065 1
		return (1);
d1067 83
a1149 1
		return (-1);
d1220 1
d1254 1
a1254 1
			queueup(e, TRUE, FALSE);
d1290 4
a1295 1
	extern long atol();
d1297 1
d1318 1
a1318 3
		if (tTd(40, 8))
			printf("readqf(%s): locked\n", qf);
		if (Verbose)
d1342 1
a1342 1
	if (st.st_uid != geteuid())
d1353 1
a1353 1
		rename(qf, queuename(e, 'Q'));
a1386 2
	if (Verbose)
		printf("\nRunning %s\n", e->e_id);
d1388 2
d1393 2
a1394 1
		struct stat st;
d1398 8
d1408 9
d1421 4
d1426 38
a1463 1
			(void) sendtolist(&bp[1], ctladdr, &e->e_sendqueue, e);
d1467 1
a1467 1
			(void) sendtolist(&bp[1], ctladdr, &e->e_errorqueue, e);
d1471 1
a1471 1
			(void) chompheader(&bp[1], FALSE, e);
d1487 1
a1487 9
			e->e_df = newstr(&bp[1]);
			e->e_dfp = fopen(e->e_df, "r");
			if (e->e_dfp == NULL)
			{
				syserr("readqf: cannot open %s", e->e_df);
				e->e_msgsize = -1;
			}
			else if (fstat(fileno(e->e_dfp), &st) >= 0)
				e->e_msgsize = st.st_size;
d1494 13
d1512 8
d1531 4
d1539 4
d1547 2
a1548 1
		  case '\0':		/* blank line; ignore */
d1555 1
a1555 1
			rename(qf, queuename(e, 'Q'));
d1572 41
d1614 1
d1630 1
d1645 1
a1645 1
# ifdef NGROUPS
d1647 1
a1647 1
		GIDSET_T gidset[NGROUPS];
d1655 2
a1656 2
# ifdef NGROUPS
		n = getgroups(NGROUPS, gidset);
d1693 2
a1694 2
	if (nrequests > QUEUESIZE)
		printf(", only %d printed", QUEUESIZE);
d1703 1
a1703 1
		long dfsize = -1;
d1705 3
a1707 2
		char message[MAXLINE];
		char bodytype[MAXNAME];
d1717 6
a1722 1
		if (!lockfile(fileno(f), w->w_name, NULL, LOCK_SH|LOCK_NB))
d1724 2
d1732 2
a1733 1
		message[0] = bodytype[0] = '\0';
d1742 4
d1747 4
a1750 4
				if ((i = strlen(&buf[1])) >= sizeof message)
					i = sizeof message - 1;
				bcopy(&buf[1], message, i);
				message[i] = '\0';
d1771 1
a1771 1
				if (message[0] != '\0' || bodytype[0] != '\0')
d1774 2
a1775 2
					if (message[0] != '\0')
						printf("   (%.60s)", message);
d1786 8
d1795 1
a1795 1
					printf("\n\t\t\t\t\t  %.38s", &buf[1]);
d1797 1
a1797 1
					printf("\n\t\t\t\t   %.45s", &buf[1]);
a1803 5
			  case 'D':	/* data file name */
				if (stat(&buf[1], &st) >= 0)
					dfsize = st.st_size;
				break;

d1856 1
a1856 1
	static char buf[MAXNAME];
d1948 1
d2014 1
a2014 1
	if (*user != '\0' && (pw = getpwnam(user)) != NULL)
a2021 1
		a->q_user = newstr(user);
d2024 5
a2029 1
	{
a2030 1
	}
d2039 32
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@


1.1.1.2
log
@sendmail 8.9.1
@
text
@d2 1
a2 2
 * Copyright (c) 1998 Sendmail, Inc.  All rights reserved.
 * Copyright (c) 1983, 1995-1997 Eric P. Allman.  All rights reserved.
d6 15
a20 3
 * By using this file, you agree to the terms and conditions set
 * forth in the LICENSE file which can be found at the top level of
 * the sendmail distribution.
d22 11
d38 2
a39 2
#if QUEUE
static char sccsid[] = "@@(#)queue.c	8.202 (Berkeley) 6/15/98 (with queueing)";
d41 1
a41 1
static char sccsid[] = "@@(#)queue.c	8.202 (Berkeley) 6/15/98 (without queueing)";
d46 1
d49 1
a49 1
# if QUEUE
a57 3
	char		*w_host;	/* name of recipient host */
	bool		w_lock;		/* is message locked? */
	bool		w_tooyoung;	/* is it too young to run? */
a65 4

#define QF_VERSION	2	/* version number of this queue format */

extern int orderq __P((bool));
d71 2
d83 1
a83 2
void
queueup(e, announce)
d85 1
d98 1
a98 3
	char tf[MAXQFNAME];
	char buf[MAXLINE];
	extern void printctladdr __P((ADDRESS *, FILE *));
d123 1
d125 1
a125 2
					sm_syslog(LOG_ALERT, e->e_id,
						"queueup: cannot create %s, uid=%d: %s",
d127 1
d133 1
d135 1
a135 2
					sm_syslog(LOG_ALERT, e->e_id,
						"queueup: cannot lock %s: %s",
d137 1
a159 12
	if (tTd(40, 3))
	{
		extern void printenvflags __P((ENVELOPE *));

		printf("  e_flags=");
		printenvflags(e);
	}
	if (tTd(40, 32))
	{
		printf("  sendq=");
		printaddr(e->e_sendqueue, TRUE);
	}
d175 1
a175 1
	if (!bitset(EF_HAS_DF, e->e_flags))
d177 2
a178 3
		register FILE *dfp = NULL;
		char dfname[MAXQFNAME];
		struct stat stbuf;
d180 3
a182 2
		strcpy(dfname, queuename(e, 'd'));
		fd = open(dfname, O_WRONLY|O_CREAT|O_TRUNC, FileMode);
d185 1
a185 9
				dfname, geteuid());
		if (fstat(fd, &stbuf) < 0)
			e->e_dfino = -1;
		else
		{
			e->e_dfdev = stbuf.st_dev;
			e->e_dfino = stbuf.st_ino;
		}
		e->e_flags |= EF_HAS_DF;
a199 12
	/* output queue version number (must be first!) */
	fprintf(tfp, "V%d\n", QF_VERSION);

	/* output creation time */
	fprintf(tfp, "T%ld\n", (long) e->e_ctime);

	/* output last delivery time */
	fprintf(tfp, "K%ld\n", (long) e->e_dtime);

	/* output number of delivery attempts */
	fprintf(tfp, "N%d\n", e->e_ntries);

d203 2
a204 13
	/* output inode number of data file */
	/* XXX should probably include device major/minor too */
	if (e->e_dfino != -1)
	{
		if (sizeof e->e_dfino > sizeof(long))
			fprintf(tfp, "I%d/%d/%s\n",
				major(e->e_dfdev), minor(e->e_dfdev),
				quad_to_string(e->e_dfino));
		else
			fprintf(tfp, "I%d/%d/%lu\n",
				major(e->e_dfdev), minor(e->e_dfdev),
				(unsigned long) e->e_dfino);
	}
d206 1
a206 1
	/* output body type */
d208 2
a209 6
		fprintf(tfp, "B%s\n", denlstring(e->e_bodytype, TRUE, FALSE));

#if _FFR_SAVE_CHARSET
	if (e->e_charset != NULL)
		fprintf(tfp, "X%s\n", denlstring(e->e_charset, TRUE, FALSE));
#endif
a220 8
	if (bitset(EF_HAS8BIT, e->e_flags))
		*p++ = '8';
	if (bitset(EF_DELETE_BCC, e->e_flags))
		*p++ = 'b';
	if (bitset(EF_RET_PARAM, e->e_flags))
		*p++ = 'd';
	if (bitset(EF_NO_BODY_RETN, e->e_flags))
		*p++ = 'n';
d234 1
a234 5
	if (bitnset(M_UDBENVELOPE, e->e_from.q_mailer->m_flags))
		p = e->e_sender;
	else
		p = e->e_from.q_paddr;
	fprintf(tfp, "S%s\n", denlstring(p, TRUE, FALSE));
d236 10
a245 3
	/* output ESMTP-supplied "original" information */
	if (e->e_envid != NULL)
		fprintf(tfp, "Z%s\n", denlstring(e->e_envid, TRUE, FALSE));
a247 1
	printctladdr(NULL, NULL);
d250 2
a251 1
		if (bitset(QDONTSEND|QBADADDR|QSENT, q->q_flags))
d253 15
a267 38
#if XDEBUG
			if (bitset(QQUEUEUP, q->q_flags))
				sm_syslog(LOG_DEBUG, e->e_id,
					"dropenvelope: q_flags = %x, paddr = %s",
					q->q_flags, q->q_paddr);
#endif
			continue;
		}
		printctladdr(q, tfp);
		if (q->q_orcpt != NULL)
			fprintf(tfp, "Q%s\n",
				denlstring(q->q_orcpt, TRUE, FALSE));
		putc('R', tfp);
		if (bitset(QPRIMARY, q->q_flags))
			putc('P', tfp);
		if (bitset(QHASNOTIFY, q->q_flags))
			putc('N', tfp);
		if (bitset(QPINGONSUCCESS, q->q_flags))
			putc('S', tfp);
		if (bitset(QPINGONFAILURE, q->q_flags))
			putc('F', tfp);
		if (bitset(QPINGONDELAY, q->q_flags))
			putc('D', tfp);
		putc(':', tfp);
		fprintf(tfp, "%s\n", denlstring(q->q_paddr, TRUE, FALSE));
		if (announce)
		{
			e->e_to = q->q_paddr;
			message("queued");
			if (LogLevel > 8)
				logdelivery(q->q_mailer, NULL, "queued",
					    NULL, (time_t) 0, e);
			e->e_to = NULL;
		}
		if (tTd(40, 1))
		{
			printf("queueing ");
			printaddr(q, FALSE);
d292 1
a292 1
		extern bool bitzerop __P((BITMAP));
d305 1
a305 1
			(void) expand(h->h_value, buf, sizeof buf, e);
d328 1
a328 3
			fprintf(tfp, "%s: %s\n",
				h->h_field,
				denlstring(buf, FALSE, TRUE));
d345 1
a345 5
		{
			fprintf(tfp, "%s: %s\n",
				h->h_field,
				denlstring(h->h_value, FALSE, TRUE));
		}
a349 3
	**
	**	Write a terminator record -- this is to prevent
	**	scurrilous crackers from appending any data.
d352 1
a352 5
	fprintf(tfp, ".\n");

	if (fflush(tfp) < 0 ||
	    (SuperSafe && fsync(fileno(tfp)) < 0) ||
	    ferror(tfp))
d365 2
a366 2
			syserr("cannot rename(%s, %s), uid=%d",
				tf, qf, geteuid());
d378 1
d381 2
a382 1
		sm_syslog(LOG_DEBUG, e->e_id, "queueup, qf=%s", qf);
a388 1
void
d394 1
d397 1
a397 2
	gid_t gid;
	static ADDRESS *lastctladdr = NULL;
a412 2
	{
		uname = NULL;
a413 2
		gid = 0;
	}
a414 2
	{
		uname = q->q_ruser != NULL ? q->q_ruser : q->q_user;
a415 2
		gid = q->q_gid;
	}
d425 2
a426 2
	if (uid == 0 || uname == NULL || uname[0] == '\0')
		fprintf(tfp, "C");
d428 3
a430 3
		fprintf(tfp, "C%s:%ld:%ld",
			denlstring(uname, TRUE, FALSE), (long) uid, (long) gid);
	fprintf(tfp, ":%s\n", denlstring(a->q_paddr, TRUE, FALSE));
d432 1
a442 1
**		verbose -- if TRUE, print out status information.
d445 1
a445 1
**		TRUE if the queue run successfully began.
a451 1
extern int	get_num_procs_online __P((void));
d453 1
a453 2
bool
runqueue(forkflag, verbose)
a454 1
	bool verbose;
a456 3
	int njobs;
	int sequenceno = 0;
	time_t current_la_time;
a457 4
	extern void clrdaemon __P((void));
	extern void runqueueevent __P((void));

	DoQueueRun = FALSE;
a464 1
	current_la_time = curtime();
d466 1
a466 1
	if (shouldqueue(WkRecipFact, current_la_time))
d468 2
a469 8
		char *msg = "Skipping queue run -- load average too high";

		if (verbose)
			message("458 %s\n", msg);
		if (LogLevel > 8)
			sm_syslog(LOG_INFO, NOQID,
				"runqueue: %s",
				msg);
d471 2
a472 13
			(void) setevent(QueueIntvl, runqueueevent, 0);
		return FALSE;
	}

	/*
	**  See if we already have too many children.
	*/

	if (forkflag && QueueIntvl != 0 &&
	    MaxChildren > 0 && CurChildren >= MaxChildren)
	{
		(void) setevent(QueueIntvl, runqueueevent, 0);
		return FALSE;
d481 3
a483 3
		pid_t pid;
		extern SIGFUNC_DECL intsig __P((int));
		extern SIGFUNC_DECL reapchild __P((int));
a484 1
		blocksignal(SIGCHLD);
d486 1
a488 16
		if (pid == -1)
		{
			const char *msg = "Skipping queue run -- fork() failed";
			const char *err = errstring(errno);

			if (verbose)
				message("458 %s: %s\n", msg, err);
			if (LogLevel > 8)
				sm_syslog(LOG_INFO, NOQID,
					"runqueue: %s: %s",
					msg, err);
			if (QueueIntvl != 0)
				(void) setevent(QueueIntvl, runqueueevent, 0);
			(void) releasesignal(SIGCHLD);
			return FALSE;
		}
d492 3
a494 4
			(void) blocksignal(SIGALRM);
			proc_list_add(pid);
			(void) releasesignal(SIGALRM);
			releasesignal(SIGCHLD);
d496 2
a497 2
				(void) setevent(QueueIntvl, runqueueevent, 0);
			return TRUE;
d499 5
a503 3
		/* child -- double fork and clean up signals */
		proc_list_clear();
		releasesignal(SIGCHLD);
d505 1
a505 1
		(void) setsignal(SIGHUP, intsig);
d510 1
d512 1
a512 2
		sm_syslog(LOG_DEBUG, NOQID,
			"runqueue %s, pid=%d, forkflag=%d",
d514 1
d520 1
a520 1
# if DAEMON
a526 4
	/* drop privileges */
	if (geteuid() == (uid_t) 0)
		(void) drop_privileges(FALSE);

a534 7
	/* make sure we have disconnected from parent */
	if (forkflag)
	{
		disconnect(1, e);
		QuickAbort = FALSE;
	}

a541 12
	**  If we are running part of the queue, always ignore stored
	**  host status.
	*/

	if (QueueLimitId != NULL || QueueLimitSender != NULL ||
	    QueueLimitRecipient != NULL)
	{
		IgnoreHostStatus = TRUE;
		MinQueueAge = 0;
	}

	/*
d549 1
a549 1
	njobs = orderq(FALSE);
a556 1
		e->e_to = NULL;
a559 2
		**
		**	Get new load average every 30 seconds.
a561 18
		if (current_la_time < curtime() - 30)
		{
			CurrentLA = getla();
			current_la_time = curtime();
		}
		if (shouldqueue(WkRecipFact, current_la_time))
		{
			char *msg = "Aborting queue run: load average too high";

			if (Verbose)
				message("%s", msg);
			if (LogLevel > 8)
				sm_syslog(LOG_INFO, NOQID,
					"runqueue: %s",
					msg);
			break;
		}
		sequenceno++;
d565 1
a565 21
				message("");
			if (QueueSortOrder == QS_BYPRIORITY)
			{
				if (Verbose)
					message("Skipping %s (sequence %d of %d) and flushing rest of queue",
						w->w_name + 2,
						sequenceno,
						njobs);
				if (LogLevel > 8)
					sm_syslog(LOG_INFO, NOQID,
						"runqueue: Flushing queue from %s (pri %ld, LA %d, %d of %d)",
						w->w_name + 2,
						w->w_pri,
						CurrentLA,
						sequenceno,
						njobs);
				break;
			}
			else if (Verbose)
				message("Skipping %s (sequence %d of %d)",
					w->w_name + 2, sequenceno, njobs);
d570 1
a570 1
			extern pid_t dowork __P((char *, bool, bool, ENVELOPE *));
a571 6
			if (Verbose)
			{
				message("");
				message("Running %s (sequence %d of %d)",
					w->w_name + 2, sequenceno, njobs);
			}
a577 2
		if (w->w_host)
			free(w->w_host);
a583 13
	/*NOTREACHED*/
	return TRUE;
}


/*
**  RUNQUEUEEVENT -- stub for use in setevent
*/

void
runqueueevent()
{
	DoQueueRun = TRUE;
a606 4
static WORK	*WorkList = NULL;
static int	WorkListSize = 0;

int
a611 1
	register char *p;
d614 1
d616 2
a617 3
	int wc;
	QUEUE_CHAR *check;
	
d621 6
a626 24

		check = QueueLimitId;
		while (check != NULL)
		{
			printf("\tQueueLimitId = %s\n",
			       check->queue_match);
			check = check->queue_next;
		}

		check = QueueLimitSender;
		while (check != NULL)
		{
			printf("\tQueueLimitSender = %s\n",
			       check->queue_match);
			check = check->queue_next;
		}

		check = QueueLimitRecipient;
		while (check != NULL)
		{
			printf("\tQueueLimitRecipient = %s\n",
			       check->queue_match);
			check = check->queue_next;
		}
a635 2
		if (w->w_host)
			free(w->w_host);
d655 3
a657 6
		int qfver = 0;
		char lbuf[MAXNAME + 1];
		extern bool strcontainedin __P((char *, char *));

		if (tTd(41, 50))
			printf("orderq: checking %s\n", d->d_name);
d663 2
a664 1
		if (strlen(d->d_name) > MAXQFNAME)
a666 12
		check = QueueLimitId;
		while (check != NULL)
		{
			if (strcontainedin(check->queue_match, d->d_name))
				break;
			else
				check = check->queue_next;
		}
		if (QueueLimitId != NULL && check == NULL)
			continue;

#ifdef PICKY_QF_NAME_CHECK
d685 3
a687 3
			if (LogLevel > 0)
				sm_syslog(LOG_ALERT, NOQID,
					"orderq: bogus qf name %s",
d689 3
a691 2
			if (strlen(d->d_name) > (SIZE_T) MAXNAME)
				d->d_name[MAXNAME] = '\0';
a696 1
#endif
d698 2
a699 7
		/* open control file (if not too many files) */
		if (++wn >= MaxQueueRun && MaxQueueRun > 0)
		{
			if (wn == MaxQueueRun && LogLevel > 0)
				sm_syslog(LOG_ALERT, NOQID,
					"WorkList for %s maxed out at %d",
					QueueDir, MaxQueueRun);
a700 9
		}
		if (wn >= WorkListSize)
		{
			extern void grow_wlist __P((void));

			grow_wlist();
			if (wn >= WorkListSize)
				continue;
		}
d708 2
a709 2
				printf("orderq: cannot open %s: %s\n",
					d->d_name, errstring(errno));
d714 1
a714 1
		w = &WorkList[wn];
a715 3
		w->w_host = NULL;
		w->w_lock = !lockfile(fileno(cf), w->w_name, NULL, LOCK_SH|LOCK_NB);
		w->w_tooyoung = FALSE;
d725 1
a725 1
		if (QueueSortOrder == QS_BYHOST || QueueLimitRecipient != NULL)
d729 2
a730 13
			int c;
			time_t age;
			extern bool strcontainedin __P((char *, char *));

			p = strchr(lbuf, '\n');
			if (p != NULL)
				*p = '\0';
			else
			{
				/* flush rest of overly long line */
				while ((c = getc(cf)) != EOF && c != '\n')
					continue;
			}
a733 4
			  case 'V':
				qfver = atoi(&lbuf[1]);
				break;

d745 2
a746 26
				if (w->w_host == NULL &&
				    (p = strrchr(&lbuf[1], '@@')) != NULL)
					w->w_host = newstr(&p[1]);
				if (QueueLimitRecipient == NULL)
				{
					i &= ~NEED_R;
					break;
				}
				if (qfver > 0)
				{
					p = strchr(&lbuf[1], ':');
					if (p == NULL)
						p = &lbuf[1];
				}
				else
					p = &lbuf[1];
				check = QueueLimitRecipient;
				while (check != NULL)
				{
					if (strcontainedin(check->queue_match,
							   p))
						break;
					else
						check = check->queue_next;
				}
				if (check != NULL)
d751 3
a753 23
				  check = QueueLimitSender;
				  while (check != NULL)
				  {
					  if (strcontainedin(check->queue_match,
							     &lbuf[1]))
						  break;
					  else
						  check = check->queue_next;
				  }
				  if (check != NULL)
					  i &= ~NEED_S;
				break;

			  case 'K':
				age = curtime() - (time_t) atol(&lbuf[1]);
				if (age >= 0 && MinQueueAge > 0 &&
				    age < MinQueueAge)
					w->w_tooyoung = TRUE;
				break;

			  case 'N':
				if (atol(&lbuf[1]) == 0)
					w->w_tooyoung = FALSE;
a762 5
			if (tTd(41, 49))
				printf("skipping %s (%x)\n", w->w_name, i);
			free(w->w_name);
			if (w->w_host)
				free(w->w_host);
d769 3
a771 56
	wc = min(wn, WorkListSize);
	if (wc > MaxQueueRun && MaxQueueRun > 0)
		wc = MaxQueueRun;

	if (QueueSortOrder == QS_BYHOST)
	{
		extern int workcmpf1();
		extern int workcmpf2();

		/*
		**  Sort the work directory for the first time,
		**  based on host name, lock status, and priority.
		*/

		qsort((char *) WorkList, wc, sizeof *WorkList, workcmpf1);

		/*
		**  If one message to host is locked, "lock" all messages
		**  to that host.
		*/

		i = 0;
		while (i < wc)
		{
			if (!WorkList[i].w_lock)
			{
				i++;
				continue;
			}
			w = &WorkList[i];
			while (++i < wc)
			{
				extern int sm_strcasecmp __P((char *, char *));

				if (WorkList[i].w_host == NULL &&
				    w->w_host == NULL)
					WorkList[i].w_lock = TRUE;
				else if (WorkList[i].w_host != NULL &&
					 w->w_host != NULL &&
					 sm_strcasecmp(WorkList[i].w_host, w->w_host) == 0)
					WorkList[i].w_lock = TRUE;
				else
					break;
			}
		}

		/*
		**  Sort the work directory for the second time,
		**  based on lock status, host name, and priority.
		*/

		qsort((char *) WorkList, wc, sizeof *WorkList, workcmpf2);
	}
	else if (QueueSortOrder == QS_BYTIME)
	{
		extern int workcmpf3();
d773 1
a773 16
		/*
		**  Simple sort based on submission time only.
		*/

		qsort((char *) WorkList, wc, sizeof *WorkList, workcmpf3);
	}
	else
	{
		extern int workcmpf0();

		/*
		**  Simple sort based on queue priority only.
		*/

		qsort((char *) WorkList, wc, sizeof *WorkList, workcmpf0);
	}
d781 1
a781 1
	for (i = wc; --i >= 0; )
d784 3
a786 6
		w->w_name = WorkList[i].w_name;
		w->w_host = WorkList[i].w_host;
		w->w_lock = WorkList[i].w_lock;
		w->w_tooyoung = WorkList[i].w_tooyoung;
		w->w_pri = WorkList[i].w_pri;
		w->w_ctime = WorkList[i].w_ctime;
a789 4
	if (WorkList != NULL)
		free(WorkList);
	WorkList = NULL;
	WorkListSize = 0;
d800 1
a800 53
**  GROW_WLIST -- make the work list larger
**
**	Parameters:
**		none.
**
**	Returns:
**		none.
**
**	Side Effects:
**		Adds another QUEUESEGSIZE entries to WorkList if possible.
**		It can fail if there isn't enough memory, so WorkListSize
**		should be checked again upon return.
*/

void
grow_wlist()
{
	if (tTd(41, 1))
		printf("grow_wlist: WorkListSize=%d\n", WorkListSize);
	if (WorkList == NULL)
	{
		WorkList = (WORK *) xalloc(sizeof(WORK) * (QUEUESEGSIZE + 1));
		WorkListSize = QUEUESEGSIZE;
	}
	else
	{
		int newsize = WorkListSize + QUEUESEGSIZE;
		WORK *newlist = (WORK *) realloc((char *)WorkList,
					  (unsigned)sizeof(WORK) * (newsize + 1));

		if (newlist != NULL)
		{
			WorkListSize = newsize;
			WorkList = newlist;
			if (LogLevel > 1)
			{
				sm_syslog(LOG_NOTICE, NOQID,
					"grew WorkList for %s to %d",
					QueueDir, WorkListSize);
			}
		}
		else if (LogLevel > 0)
		{
			sm_syslog(LOG_ALERT, NOQID,
				"FAILED to grow WorkList for %s to %d",
				QueueDir, newsize);
		}
	}
	if (tTd(41, 1))
		printf("grow_wlist: WorkListSize now %d\n", WorkListSize);
}
/*
**  WORKCMPF0 -- simple priority-only compare function.
d815 1
a815 2
int
workcmpf0(a, b)
d823 1
a823 1
		return 0;
d825 1
a825 1
		return 1;
d827 1
a827 113
		return -1;
}
/*
**  WORKCMPF1 -- first compare function for ordering work based on host name.
**
**	Sorts on host name, lock status, and priority in that order.
**
**	Parameters:
**		a -- the first argument.
**		b -- the second argument.
**
**	Returns:
**		<0 if a < b
**		 0 if a == b
**		>0 if a > b
**
**	Side Effects:
**		none.
*/

int
workcmpf1(a, b)
	register WORK *a;
	register WORK *b;
{
	int i;
	extern int sm_strcasecmp __P((char *, char *));

	/* host name */
	if (a->w_host != NULL && b->w_host == NULL)
		return 1;
	else if (a->w_host == NULL && b->w_host != NULL)
		return -1;
	if (a->w_host != NULL && b->w_host != NULL &&
	    (i = sm_strcasecmp(a->w_host, b->w_host)) != 0)
		return i;

	/* lock status */
	if (a->w_lock != b->w_lock)
		return b->w_lock - a->w_lock;

	/* job priority */
	return a->w_pri - b->w_pri;
}
/*
**  WORKCMPF2 -- second compare function for ordering work based on host name.
**
**	Sorts on lock status, host name, and priority in that order.
**
**	Parameters:
**		a -- the first argument.
**		b -- the second argument.
**
**	Returns:
**		<0 if a < b
**		 0 if a == b
**		>0 if a > b
**
**	Side Effects:
**		none.
*/

int
workcmpf2(a, b)
	register WORK *a;
	register WORK *b;
{
	int i;
	extern int sm_strcasecmp __P((char *, char *));

	/* lock status */
	if (a->w_lock != b->w_lock)
		return a->w_lock - b->w_lock;

	/* host name */
	if (a->w_host != NULL && b->w_host == NULL)
		return 1;
	else if (a->w_host == NULL && b->w_host != NULL)
		return -1;
	if (a->w_host != NULL && b->w_host != NULL &&
	    (i = sm_strcasecmp(a->w_host, b->w_host)) != 0)
		return i;

	/* job priority */
	return a->w_pri - b->w_pri;
}
/*
**  WORKCMPF3 -- simple submission-time-only compare function.
**
**	Parameters:
**		a -- the first argument.
**		b -- the second argument.
**
**	Returns:
**		-1 if a < b
**		 0 if a == b
**		+1 if a > b
**
**	Side Effects:
**		none.
*/

int
workcmpf3(a, b)
	register WORK *a;
	register WORK *b;
{
	if (a->w_ctime > b->w_ctime)
		return 1;
	else if (a->w_ctime < b->w_ctime)
		return -1;
	else
		return 0;
d856 1
a856 1
	extern bool readqf __P((ENVELOPE *));
a877 5
		else
		{
			/* child -- error messages to the transcript */
			QuickAbort = OnlyOneError = FALSE;
		}
a897 1
		e->e_sendmode = SM_DELIVER;
d907 1
a907 1
		setproctitle("%s: from queue", id);
d909 3
a911 3
			sm_syslog(LOG_DEBUG, e->e_id,
				"dowork, pid=%d",
				getpid());
d919 1
a919 1
			if (tTd(40, 4) && e->e_id != NULL)
a920 1
			e->e_id = NULL;
d931 1
a931 1
			queueup(e, FALSE);
d940 1
a940 1
			dropenvelope(e, TRUE);
d967 1
a967 6
	int qfver = 0;
	long hdrsize = 0;
	register char *p;
	char *orcpt = NULL;
	bool nomore = FALSE;
	char qf[MAXQFNAME];
d969 2
a970 1
	extern ADDRESS *setctluser __P((char *, int));
d991 3
a993 1
		if (Verbose || tTd(40, 8))
d995 1
d997 2
a998 1
			sm_syslog(LOG_DEBUG, e->e_id, "locked");
d1017 1
a1017 2
	if ((st.st_uid != geteuid() && geteuid() != RealUid) ||
	    bitset(S_IWOTH|S_IWGRP, st.st_mode))
d1019 1
d1022 2
a1023 3
			sm_syslog(LOG_ALERT, e->e_id,
				"bogus queue file, uid=%d, mode=%o",
				st.st_uid, st.st_mode);
d1025 1
d1028 1
a1028 1
		loseqfile(e, "bogus file uid in mqueue");
d1035 2
a1036 8
		/* must be a bogus file -- if also old, just remove it */
		if (st.st_ctime + 10 * 60 < curtime())
		{
			qf[0] = 'd';
			(void) unlink(qf);
			qf[0] = 'q';
			(void) unlink(qf);
		}
d1062 2
a1064 2
	e->e_dfino = -1;
	e->e_msgsize = -1;
d1068 1
a1068 4
		u_long qflags;
		ADDRESS *q;
		int mid;
		auto char *ep;
a1071 8
		if (nomore)
		{
			/* hack attack */
			syserr("SECURITY ALERT: extra data in qf: %s", bp);
			fclose(qfp);
			loseqfile(e, "bogus queue line");
			return FALSE;
		}
a1073 10
		  case 'V':		/* queue file version number */
			qfver = atoi(&bp[1]);
			if (qfver <= QF_VERSION)
				break;
			syserr("Version number in qf (%d) greater than max (%d)",
				qfver, QF_VERSION);
			fclose(qfp);
			loseqfile(e, "unsupported qf file version");
			return FALSE;

d1075 1
a1075 5
			ctladdr = setctluser(&bp[1], qfver);
			break;

		  case 'Q':		/* original recipient */
			orcpt = newstr(&bp[1]);
d1079 1
a1079 44
			p = bp;
			qflags = 0;
			if (qfver >= 1)
			{
				/* get flag bits */
				while (*++p != '\0' && *p != ':')
				{
					switch (*p)
					{
					  case 'N':
						qflags |= QHASNOTIFY;
						break;

					  case 'S':
						qflags |= QPINGONSUCCESS;
						break;

					  case 'F':
						qflags |= QPINGONFAILURE;
						break;

					  case 'D':
						qflags |= QPINGONDELAY;
						break;

					  case 'P':
						qflags |= QPRIMARY;
						break;
					}
				}
			}
			else
				qflags |= QPRIMARY;
			q = parseaddr(++p, NULLADDR, RF_COPYALL, '\0', NULL, e);
			if (q != NULL)
			{
				q->q_alias = ctladdr;
				if (qfver >= 1)
					q->q_flags &= ~Q_PINGFLAGS;
				q->q_flags |= qflags;
				q->q_orcpt = orcpt;
				(void) recipient(q, &e->e_sendqueue, 0, e);
			}
			orcpt = NULL;
d1083 1
a1083 1
			/* no longer used */
d1087 1
a1087 2
			(void) chompheader(&bp[1], FALSE, NULL, e);
			hdrsize += strlen(&bp[1]);
a1089 1
		  case 'L':		/* Solaris Content-Length: */
d1095 1
a1095 1
			setsender(newstr(&bp[1]), e, NULL, '\0', TRUE);
a1101 6
#if _FFR_SAVE_CHARSET
		  case 'X':		/* character set */
			e->e_charset = newstr(&bp[1]);
			break;
#endif

d1103 9
a1111 1
			/* obsolete -- ignore */
a1117 32
		  case 'I':		/* data file's inode number */
			/* regenerated below */
			break;

		  case 'K':		/* time of last deliver attempt */
			e->e_dtime = atol(&buf[1]);
			break;

		  case 'N':		/* number of delivery attempts */
			e->e_ntries = atoi(&buf[1]);

			/* if this has been tried recently, let it be */
			if (e->e_ntries > 0 &&
			    MinQueueAge > 0 && e->e_dtime <= curtime() &&
			    curtime() < e->e_dtime + MinQueueAge)
			{
				char *howlong = pintvl(curtime() - e->e_dtime, TRUE);
				extern void unlockqueue __P((ENVELOPE *));

				if (Verbose || tTd(40, 8))
					printf("%s: too young (%s)\n",
						e->e_id, howlong);
				if (LogLevel > 19)
					sm_syslog(LOG_DEBUG, e->e_id,
						"too young (%s)",
						howlong);
				e->e_id = NULL;
				unlockqueue(e);
				return FALSE;
			}
			break;

a1122 8
			if (strncmp(bp, "From ", 5) == 0)
			{
				/* we are being spoofed! */
				syserr("SECURITY ALERT: bogus qf line %s", bp);
				fclose(qfp);
				loseqfile(e, "bogus queue line");
				return FALSE;
			}
a1133 16

				  case '8':	/* has 8 bit data */
					e->e_flags |= EF_HAS8BIT;
					break;

				  case 'b':	/* delete Bcc: header */
					e->e_flags |= EF_DELETE_BCC;
					break;

				  case 'd':	/* envelope has DSN RET= */
					e->e_flags |= EF_RET_PARAM;
					break;

				  case 'n':	/* don't return body */
					e->e_flags |= EF_NO_BODY_RETN;
					break;
a1137 4
		  case 'Z':		/* original envelope id from ESMTP */
			e->e_envid = newstr(&bp[1]);
			break;

d1139 1
a1139 2
			mid = macid(&bp[1], &ep);
			define(mid, newstr(ep), e);
d1142 1
a1142 2
		  case '.':		/* terminate file */
			nomore = TRUE;
d1147 1
a1147 1
				qf, LineNumber, shortenstring(bp, MAXSHORTSTR));
d1149 1
a1149 1
			loseqfile(e, "unrecognized line");
a1165 22
		return TRUE;
	}

	/*
	**  Arrange to read the data file.
	*/

	p = queuename(e, 'd');
	e->e_dfp = fopen(p, "r");
	if (e->e_dfp == NULL)
	{
		syserr("readqf: cannot open %s", p);
	}
	else
	{
		e->e_flags |= EF_HAS_DF;
		if (fstat(fileno(e->e_dfp), &st) >= 0)
		{
			e->e_msgsize = st.st_size + hdrsize;
			e->e_dfdev = st.st_dev;
			e->e_dfino = st.st_ino;
		}
a1166 1

a1181 1
void
d1196 1
a1196 1
# ifdef NGROUPS_MAX
d1198 1
a1198 1
		extern GIDSET_T InitialGidSet[NGROUPS_MAX];
d1206 2
a1207 2
# ifdef NGROUPS_MAX
		n = NGROUPS_MAX;
d1210 1
a1210 1
			if (InitialGidSet[n] == st.st_gid)
d1244 2
a1245 2
	if (MaxQueueRun > 0 && nrequests > MaxQueueRun)
		printf(", only %d printed", MaxQueueRun);
d1254 1
a1254 1
		long dfsize;
d1256 2
a1257 3
		int qfver;
		char statmsg[MAXLINE];
		char bodytype[MAXNAME + 1];
d1267 1
a1267 6
		w->w_name[0] = 'd';
		if (stat(w->w_name, &st) >= 0)
			dfsize = st.st_size;
		else
			dfsize = -1;
		if (w->w_lock)
a1268 2
		else if (w->w_tooyoung)
			printf("-");
d1275 1
a1275 2
		statmsg[0] = bodytype[0] = '\0';
		qfver = 0;
a1283 4
			  case 'V':	/* queue file version */
				qfver = atoi(&buf[1]);
				break;

d1285 4
a1288 4
				if ((i = strlen(&buf[1])) >= sizeof statmsg)
					i = sizeof statmsg - 1;
				bcopy(&buf[1], statmsg, i);
				statmsg[i] = '\0';
d1300 1
a1300 1
					printf("%8ld %10ld%c%.12s %.78s",
d1309 1
a1309 1
				if (statmsg[0] != '\0' || bodytype[0] != '\0')
d1312 2
a1313 4
					if (statmsg[0] != '\0')
						printf("   (%.*s)",
							Verbose ? 100 : 60,
							statmsg);
d1319 1
a1319 1
					printf("\n\t\t\t\t      (---%.74s---)",
a1323 8
				p = &buf[1];
				if (qfver >= 1)
				{
					p = strchr(p, ':');
					if (p == NULL)
						break;
					p++;
				}
d1325 1
a1325 1
					printf("\n\t\t\t\t\t  %.78s", p);
d1327 1
a1327 1
					printf("\n\t\t\t\t   %.45s", p);
d1334 5
a1379 7
#ifndef ENOLCK
# define ENOLCK		-1
#endif
#ifndef ENOSPC
# define ENOSPC		-1
#endif

d1385 1
a1385 1
	static pid_t pid = -1;
d1391 1
a1391 1
	static char buf[MAXNAME + 1];
d1395 1
a1395 1
		char qf[MAXQFNAME];
d1408 1
a1408 1
		(void) snprintf(qf, sizeof qf, "qf%cAA%05d", c0, pid);
a1412 1
			int attempts = 0;
d1433 1
a1433 1
			do
d1435 1
a1435 13
				if (attempts > 0)
					sleep(attempts);
				e->e_lockfp = 0;
				if (lockfile(i, qf, NULL, LOCK_EX|LOCK_NB))
				{
					e->e_lockfp = fdopen(i, "w");
					break;
				}
			} while ((errno == ENOLCK || errno == ENOSPC) &&
				 attempts++ < 4);

			/* Successful lock */
			if (e->e_lockfp != 0)
a1436 10

#if !HASFLOCK
			if (errno != EAGAIN && errno != EACCES)
#else
			if (errno != EWOULDBLOCK)
#endif
			{
				syserr("queuename: Cannot lock \"%s\" in \"%s\" (euid=%d)",
					qf, QueueDir, geteuid());
				exit(EX_OSERR);
d1451 1
a1451 2
			printf("queuename: assigned id %s, env=%lx\n",
			       e->e_id, (u_long) e);
d1457 1
d1459 2
a1460 1
			sm_syslog(LOG_DEBUG, e->e_id, "assigned id");
d1465 1
a1465 1
	(void) snprintf(buf, sizeof buf, "%cf%s", type, e->e_id);
a1482 1
void
d1487 1
a1487 2
		printf("unlockqueue(%s)\n",
			e->e_id == NULL ? "NOQUEUE" : e->e_id);
d1499 1
d1501 2
a1502 1
		sm_syslog(LOG_DEBUG, e->e_id, "unlock");
a1514 1
**		qfver -- the version stamp of this qf file.
d1524 1
a1524 1
setctluser(user, qfver)
a1525 1
	int qfver;
d1545 4
a1548 1
	if (*user == '\0')
d1550 8
a1557 7
		p = NULL;
		a->q_user = newstr(DefUser);
	}
	else if (*user == ':')
	{
		p = &user[1];
		a->q_user = newstr(p);
d1561 1
a1561 21
		p = strtok(user, ":");
		a->q_user = newstr(user);
		if (qfver >= 2)
		{
			if ((p = strtok(NULL, ":")) != NULL)
				a->q_uid = atoi(p);
			if ((p = strtok(NULL, ":")) != NULL)
				a->q_gid = atoi(p);
			if ((p = strtok(NULL, ":")) != NULL)
				a->q_flags |= QGOODUID;
		}
		else if ((pw = sm_getpwnam(user)) != NULL)
		{
			if (strcmp(pw->pw_dir, "/") == 0)
				a->q_home = "";
			else
				a->q_home = newstr(pw->pw_dir);
			a->q_uid = pw->pw_uid;
			a->q_gid = pw->pw_gid;
			a->q_flags |= QGOODUID;
		}
a1570 35
}
/*
**  LOSEQFILE -- save the qf as Qf and try to let someone know
**
**	Parameters:
**		e -- the envelope (e->e_id will be used).
**		why -- reported to whomever can hear.
**
**	Returns:
**		none.
*/

void
loseqfile(e, why)
	register ENVELOPE *e;
	char *why;
{
	char *p;
	char buf[MAXQFNAME + 1];

	if (e == NULL || e->e_id == NULL)
		return;
	p = queuename(e, 'q');
	if (strlen(p) > MAXQFNAME)
	{
		syserr("loseqfile: queuename (%s) too long", p);
		return;
	}
	strcpy(buf, p);
	p = queuename(e, 'Q');
	if (rename(buf, p) < 0)
		syserr("cannot rename(%s, %s), uid=%d", buf, p, geteuid());
	else if (LogLevel > 0)
		sm_syslog(LOG_ALERT, e->e_id,
			"Losing %s: %s", buf, why);
@

