head	1.11;
access;
symbols
	OPENBSD_2_6:1.10.0.4
	OPENBSD_2_6_BASE:1.10
	OPENBSD_2_5:1.10.0.2
	OPENBSD_2_5_BASE:1.10
	OPENBSD_2_4:1.8.0.2
	OPENBSD_2_4_BASE:1.8
	sendmail_8_9_1:1.1.1.2
	UCB:1.1.1
	OPENBSD_2_3:1.7.0.2
	OPENBSD_2_3_BASE:1.7
	OPENBSD_2_2:1.6.0.2
	OPENBSD_2_2_BASE:1.6
	OPENBSD_2_1:1.5.0.2
	OPENBSD_2_1_BASE:1.5
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.11
date	2000.04.18.04.57.25;	author millert;	state dead;
branches;
next	1.10;

1.10
date	99.02.05.05.59.32;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	99.01.01.20.33.57;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	98.07.12.19.45.05;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	97.11.09.04.05.44;	author gene;	state Exp;
branches;
next	1.6;

1.6
date	97.07.15.07.24.13;	author downsj;	state Exp;
branches;
next	1.5;

1.5
date	96.12.14.21.17.35;	author downsj;	state Exp;
branches;
next	1.4;

1.4
date	96.09.19.06.45.03;	author fn;	state Exp;
branches;
next	1.3;

1.3
date	96.09.12.19.25.43;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.01.29.01.44.24;	author dm;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.48.19;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.48.19;	author deraadt;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	98.07.12.17.10.32;	author millert;	state Exp;
branches;
next	;


desc
@@


1.11
log
@remove sendmail 8.9.3
@
text
@/*
 * Copyright (c) 1998 Sendmail, Inc.  All rights reserved.
 * Copyright (c) 1983, 1995-1997 Eric P. Allman.  All rights reserved.
 * Copyright (c) 1988, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * By using this file, you agree to the terms and conditions set
 * forth in the LICENSE file which can be found at the top level of
 * the sendmail distribution.
 *
 */

#ifndef lint
static char sccsid[] = "@@(#)recipient.c	8.163 (Berkeley) 1/23/1999";
#endif /* not lint */

# include "sendmail.h"
# include <grp.h>

/*
**  SENDTOLIST -- Designate a send list.
**
**	The parameter is a comma-separated list of people to send to.
**	This routine arranges to send to all of them.
**
**	Parameters:
**		list -- the send list.
**		ctladdr -- the address template for the person to
**			send to -- effective uid/gid are important.
**			This is typically the alias that caused this
**			expansion.
**		sendq -- a pointer to the head of a queue to put
**			these people into.
**		aliaslevel -- the current alias nesting depth -- to
**			diagnose loops.
**		e -- the envelope in which to add these recipients.
**
**	Returns:
**		The number of addresses actually on the list.
**
**	Side Effects:
**		none.
*/

/* q_flags bits inherited from ctladdr */
#define QINHERITEDBITS	(QPINGONSUCCESS|QPINGONFAILURE|QPINGONDELAY|QHASNOTIFY)

int
sendtolist(list, ctladdr, sendq, aliaslevel, e)
	char *list;
	ADDRESS *ctladdr;
	ADDRESS **sendq;
	int aliaslevel;
	register ENVELOPE *e;
{
	register char *p;
	register ADDRESS *al;	/* list of addresses to send to */
	char delimiter;		/* the address delimiter */
	int naddrs;
	int i;
	char *oldto = e->e_to;
	char *bufp;
	char buf[MAXNAME + 1];

	if (list == NULL)
	{
		syserr("sendtolist: null list");
		return 0;
	}

	if (tTd(25, 1))
	{
		printf("sendto: %s\n   ctladdr=", list);
		printaddr(ctladdr, FALSE);
	}

	/* heuristic to determine old versus new style addresses */
	if (ctladdr == NULL &&
	    (strchr(list, ',') != NULL || strchr(list, ';') != NULL ||
	     strchr(list, '<') != NULL || strchr(list, '(') != NULL))
		e->e_flags &= ~EF_OLDSTYLE;
	delimiter = ' ';
	if (!bitset(EF_OLDSTYLE, e->e_flags) || ctladdr != NULL)
		delimiter = ',';

	al = NULL;
	naddrs = 0;

	/* make sure we have enough space to copy the string */
	i = strlen(list) + 1;
	if (i <= sizeof buf)
		bufp = buf;
	else
		bufp = xalloc(i);
	strcpy(bufp, denlstring(list, FALSE, TRUE));

	for (p = bufp; *p != '\0'; )
	{
		auto char *delimptr;
		register ADDRESS *a;

		/* parse the address */
		while ((isascii(*p) && isspace(*p)) || *p == ',')
			p++;
		a = parseaddr(p, NULLADDR, RF_COPYALL, delimiter, &delimptr, e);
		p = delimptr;
		if (a == NULL)
			continue;
		a->q_next = al;
		a->q_alias = ctladdr;

		/* arrange to inherit attributes from parent */
		if (ctladdr != NULL)
		{
			ADDRESS *b;
			extern ADDRESS *self_reference __P((ADDRESS *, ENVELOPE *));

			/* self reference test */
			if (sameaddr(ctladdr, a))
			{
				if (tTd(27, 5))
				{
					printf("sendtolist: QSELFREF ");
					printaddr(ctladdr, FALSE);
				}
				ctladdr->q_flags |= QSELFREF;
			}

			/* check for address loops */
			b = self_reference(a, e);
			if (b != NULL)
			{
				b->q_flags |= QSELFREF;
				if (tTd(27, 5))
				{
					printf("sendtolist: QSELFREF ");
					printaddr(b, FALSE);
				}
				if (a != b)
				{
					if (tTd(27, 5))
					{
						printf("sendtolist: QDONTSEND ");
						printaddr(a, FALSE);
					}
					a->q_flags |= QDONTSEND;
					b->q_flags |= a->q_flags & QNOTREMOTE;
					continue;
				}
			}

			/* full name */
			if (a->q_fullname == NULL)
				a->q_fullname = ctladdr->q_fullname;

			/* various flag bits */
			a->q_flags &= ~QINHERITEDBITS;
			a->q_flags |= ctladdr->q_flags & QINHERITEDBITS;

			/* original recipient information */
			a->q_orcpt = ctladdr->q_orcpt;
		}

		al = a;
	}

	/* arrange to send to everyone on the local send list */
	while (al != NULL)
	{
		register ADDRESS *a = al;

		al = a->q_next;
		a = recipient(a, sendq, aliaslevel, e);
		naddrs++;
	}

	e->e_to = oldto;
	if (bufp != buf)
		free(bufp);
	return (naddrs);
}
/*
**  RECIPIENT -- Designate a message recipient
**
**	Saves the named person for future mailing.
**
**	Parameters:
**		a -- the (preparsed) address header for the recipient.
**		sendq -- a pointer to the head of a queue to put the
**			recipient in.  Duplicate supression is done
**			in this queue.
**		aliaslevel -- the current alias nesting depth.
**		e -- the current envelope.
**
**	Returns:
**		The actual address in the queue.  This will be "a" if
**		the address is not a duplicate, else the original address.
**
**	Side Effects:
**		none.
*/

ADDRESS *
recipient(a, sendq, aliaslevel, e)
	register ADDRESS *a;
	register ADDRESS **sendq;
	int aliaslevel;
	register ENVELOPE *e;
{
	register ADDRESS *q;
	ADDRESS **pq;
	register struct mailer *m;
	register char *p;
	bool quoted = FALSE;		/* set if the addr has a quote bit */
	int findusercount = 0;
	bool initialdontsend = bitset(QDONTSEND, a->q_flags);
	int i;
	char *buf;
	char buf0[MAXNAME + 1];		/* unquoted image of the user name */
	extern void alias __P((ADDRESS *, ADDRESS **, int, ENVELOPE *));

	e->e_to = a->q_paddr;
	m = a->q_mailer;
	errno = 0;
	if (aliaslevel == 0)
		a->q_flags |= QPRIMARY;
	if (tTd(26, 1))
	{
		printf("\nrecipient (%d): ", aliaslevel);
		printaddr(a, FALSE);
	}

	/* if this is primary, add it to the original recipient list */
	if (a->q_alias == NULL)
	{
		if (e->e_origrcpt == NULL)
			e->e_origrcpt = a->q_paddr;
		else if (e->e_origrcpt != a->q_paddr)
			e->e_origrcpt = "";
	}

	/* break aliasing loops */
	if (aliaslevel > MaxAliasRecursion)
	{
		a->q_flags |= QBADADDR;
		a->q_status = "5.4.6";
		usrerr("554 aliasing/forwarding loop broken (%d aliases deep; %d max)",
			aliaslevel, MaxAliasRecursion);
		return (a);
	}

	/*
	**  Finish setting up address structure.
	*/

	/* get unquoted user for file, program or user.name check */
	i = strlen(a->q_user);
	if (i >= sizeof buf0)
		buf = xalloc(i + 1);
	else
		buf = buf0;
	(void) strcpy(buf, a->q_user);
	for (p = buf; *p != '\0' && !quoted; p++)
	{
		if (*p == '\\')
			quoted = TRUE;
	}
	stripquotes(buf);

	/* check for direct mailing to restricted mailers */
	if (m == ProgMailer)
	{
		if (a->q_alias == NULL)
		{
			a->q_flags |= QBADADDR;
			a->q_status = "5.7.1";
			usrerr("550 Cannot mail directly to programs");
		}
		else if (bitset(QBOGUSSHELL, a->q_alias->q_flags))
		{
			a->q_flags |= QBADADDR;
			a->q_status = "5.7.1";
			if (a->q_alias->q_ruser == NULL)
				usrerr("550 UID %d is an unknown user: cannot mail to programs",
					a->q_alias->q_uid);
			else
				usrerr("550 User %s@@%s doesn't have a valid shell for mailing to programs",
					a->q_alias->q_ruser, MyHostName);
		}
		else if (bitset(QUNSAFEADDR, a->q_alias->q_flags))
		{
			a->q_flags |= QBADADDR;
			a->q_status = "5.7.1";
			a->q_rstatus = newstr("Unsafe for mailing to programs");
			usrerr("550 Address %s is unsafe for mailing to programs",
				a->q_alias->q_paddr);
		}
	}

	/*
	**  Look up this person in the recipient list.
	**	If they are there already, return, otherwise continue.
	**	If the list is empty, just add it.  Notice the cute
	**	hack to make from addresses suppress things correctly:
	**	the QDONTSEND bit will be set in the send list.
	**	[Please note: the emphasis is on "hack."]
	*/

	for (pq = sendq; (q = *pq) != NULL; pq = &q->q_next)
	{
		if (sameaddr(q, a) &&
		    (bitset(QRCPTOK, q->q_flags) ||
		     !bitset(QPRIMARY, q->q_flags)))
		{
			if (tTd(26, 1))
			{
				printf("%s in sendq: ", a->q_paddr);
				printaddr(q, FALSE);
			}
			if (!bitset(QPRIMARY, q->q_flags))
			{
				if (!bitset(QDONTSEND, a->q_flags))
					message("duplicate suppressed");
				q->q_flags |= a->q_flags;
			}
			else if (bitset(QSELFREF, q->q_flags))
				q->q_flags |= a->q_flags & ~QDONTSEND;
			a = q;
			goto done;
		}
	}

	/* add address on list */
	if (pq != NULL)
	{
		*pq = a;
		a->q_next = NULL;
	}

	/*
	**  Alias the name and handle special mailer types.
	*/

  trylocaluser:
	if (tTd(29, 7))
	{
		printf("at trylocaluser: ");
		printaddr(a, FALSE);
	}

	if (bitset(QDONTSEND|QBADADDR|QVERIFIED, a->q_flags))
		goto testselfdestruct;

	if (m == InclMailer)
	{
		a->q_flags |= QDONTSEND;
		if (a->q_alias == NULL)
		{
			a->q_flags |= QBADADDR;
			a->q_status = "5.7.1";
			usrerr("550 Cannot mail directly to :include:s");
		}
		else
		{
			int ret;

			message("including file %s", a->q_user);
			ret = include(a->q_user, FALSE, a, sendq, aliaslevel, e);
			if (transienterror(ret))
			{
				if (LogLevel > 2)
					sm_syslog(LOG_ERR, e->e_id,
						"include %s: transient error: %s",
						shortenstring(a->q_user, MAXSHORTSTR),
						errstring(ret));
				a->q_flags |= QQUEUEUP;
				a->q_flags &= ~QDONTSEND;
				usrerr("451 Cannot open %s: %s",
					shortenstring(a->q_user, MAXSHORTSTR),
					errstring(ret));
			}
			else if (ret != 0)
			{
				a->q_flags |= QBADADDR;
				a->q_status = "5.2.4";
				usrerr("550 Cannot open %s: %s",
					shortenstring(a->q_user, MAXSHORTSTR),
					errstring(ret));
			}
		}
	}
	else if (m == FileMailer)
	{
		extern bool writable __P((char *, ADDRESS *, int));

		/* check if writable or creatable */
		if (a->q_alias == NULL)
		{
			a->q_flags |= QBADADDR;
			a->q_status = "5.7.1";
			usrerr("550 Cannot mail directly to files");
		}
		else if (bitset(QBOGUSSHELL, a->q_alias->q_flags))
		{
			a->q_flags |= QBADADDR;
			a->q_status = "5.7.1";
			if (a->q_alias->q_ruser == NULL)
				usrerr("550 UID %d is an unknown user: cannot mail to files",
					a->q_alias->q_uid);
			else
				usrerr("550 User %s@@%s doesn't have a valid shell for mailing to files",
					a->q_alias->q_ruser, MyHostName);
		}
		else if (bitset(QUNSAFEADDR, a->q_alias->q_flags))
		{
			a->q_flags |= QBADADDR;
			a->q_status = "5.7.1";
			a->q_rstatus = newstr("Unsafe for mailing to files");
			usrerr("550 Address %s is unsafe for mailing to files",
				a->q_alias->q_paddr);
		}
		else if (strcmp(buf, "/dev/null") == 0)
		{
			/* /dev/null is always accepted */
		}
		else if (!writable(buf, a->q_alias, SFF_CREAT))
		{
			a->q_flags |= QBADADDR;
			giveresponse(EX_CANTCREAT, m, NULL, a->q_alias,
				     (time_t) 0, e);
		}
	}

	/* try aliasing */
	if (!quoted && !bitset(QDONTSEND, a->q_flags) &&
	    bitnset(M_ALIASABLE, m->m_flags))
		alias(a, sendq, aliaslevel, e);

# if USERDB
	/* if not aliased, look it up in the user database */
	if (!bitset(QDONTSEND|QNOTREMOTE|QVERIFIED, a->q_flags) &&
	    bitnset(M_CHECKUDB, m->m_flags))
	{
		extern int udbexpand __P((ADDRESS *, ADDRESS **, int, ENVELOPE *));

		if (udbexpand(a, sendq, aliaslevel, e) == EX_TEMPFAIL)
		{
			a->q_flags |= QQUEUEUP;
			if (e->e_message == NULL)
				e->e_message = newstr("Deferred: user database error");
			if (LogLevel > 8)
				sm_syslog(LOG_INFO, e->e_id,
					"deferred: udbexpand: %s",
					errstring(errno));
			message("queued (user database error): %s",
				errstring(errno));
			e->e_nrcpts++;
			goto testselfdestruct;
		}
	}
# endif

	/*
	**  If we have a level two config file, then pass the name through
	**  Ruleset 5 before sending it off.  Ruleset 5 has the right
	**  to send rewrite it to another mailer.  This gives us a hook
	**  after local aliasing has been done.
	*/

	if (tTd(29, 5))
	{
		printf("recipient: testing local?  cl=%d, rr5=%lx\n\t",
			ConfigLevel, (u_long) RewriteRules[5]);
		printaddr(a, FALSE);
	}
	if (!bitset(QNOTREMOTE|QDONTSEND|QQUEUEUP|QVERIFIED, a->q_flags) &&
	    ConfigLevel >= 2 && RewriteRules[5] != NULL &&
	    bitnset(M_TRYRULESET5, m->m_flags))
	{
		extern void maplocaluser __P((ADDRESS *, ADDRESS **, int, ENVELOPE *));

		maplocaluser(a, sendq, aliaslevel + 1, e);
	}

	/*
	**  If it didn't get rewritten to another mailer, go ahead
	**  and deliver it.
	*/

	if (!bitset(QDONTSEND|QQUEUEUP|QVERIFIED, a->q_flags) &&
	    bitnset(M_HASPWENT, m->m_flags))
	{
		auto bool fuzzy;
		register struct passwd *pw;
		extern void forward __P((ADDRESS *, ADDRESS **, int, ENVELOPE *));

		/* warning -- finduser may trash buf */
		pw = finduser(buf, &fuzzy);
		if (pw == NULL || strlen(pw->pw_name) > MAXNAME)
		{
			a->q_flags |= QBADADDR;
			a->q_status = "5.1.1";
			giveresponse(EX_NOUSER, m, NULL, a->q_alias,
				     (time_t) 0, e);
		}
		else
		{
			char nbuf[MAXNAME + 1];

			if (fuzzy)
			{
				/* name was a fuzzy match */
				a->q_user = newstr(pw->pw_name);
				if (findusercount++ > 3)
				{
					a->q_flags |= QBADADDR;
					a->q_status = "5.4.6";
					usrerr("554 aliasing/forwarding loop for %s broken",
						pw->pw_name);
					goto done;
				}

				/* see if it aliases */
				(void) strcpy(buf, pw->pw_name);
				goto trylocaluser;
			}
			if (strcmp(pw->pw_dir, "/") == 0)
				a->q_home = "";
			else
				a->q_home = newstr(pw->pw_dir);
			a->q_uid = pw->pw_uid;
			a->q_gid = pw->pw_gid;
			a->q_ruser = newstr(pw->pw_name);
			a->q_flags |= QGOODUID;
			buildfname(pw->pw_gecos, pw->pw_name, nbuf, sizeof nbuf);
			if (nbuf[0] != '\0')
				a->q_fullname = newstr(nbuf);
			if (!usershellok(pw->pw_name, pw->pw_shell))
			{
				a->q_flags |= QBOGUSSHELL;
			}
			if (bitset(EF_VRFYONLY, e->e_flags))
			{
				/* don't do any more now */
				a->q_flags |= QVERIFIED;
			}
			else if (!quoted)
				forward(a, sendq, aliaslevel, e);
		}
	}
	if (!bitset(QDONTSEND, a->q_flags))
		e->e_nrcpts++;

  testselfdestruct:
	a->q_flags |= QTHISPASS;
	if (tTd(26, 8))
	{
		printf("testselfdestruct: ");
		printaddr(a, FALSE);
		if (tTd(26, 10))
		{
			printf("SENDQ:\n");
			printaddr(*sendq, TRUE);
			printf("----\n");
		}
	}
	if (a->q_alias == NULL && a != &e->e_from &&
	    bitset(QDONTSEND, a->q_flags))
	{
		for (q = *sendq; q != NULL; q = q->q_next)
		{
			if (!bitset(QDONTSEND, q->q_flags))
				break;
		}
		if (q == NULL)
		{
			a->q_flags |= QBADADDR;
			a->q_status = "5.4.6";
			usrerr("554 aliasing/forwarding loop broken");
		}
	}

  done:
	a->q_flags |= QTHISPASS;
	if (buf != buf0)
		free(buf);

	/*
	**  If we are at the top level, check to see if this has
	**  expanded to exactly one address.  If so, it can inherit
	**  the primaryness of the address.
	**
	**  While we're at it, clear the QTHISPASS bits.
	*/

	if (aliaslevel == 0)
	{
		int nrcpts = 0;
		ADDRESS *only = NULL;

		for (q = *sendq; q != NULL; q = q->q_next)
		{
			if (bitset(QTHISPASS, q->q_flags) &&
			    !bitset(QDONTSEND|QBADADDR, q->q_flags))
			{
				nrcpts++;
				only = q;
			}
			q->q_flags &= ~QTHISPASS;
		}
		if (nrcpts == 1)
		{
			/* check to see if this actually got a new owner */
			q = only;
			while ((q = q->q_alias) != NULL)
			{
				if (q->q_owner != NULL)
					break;
			}
			if (q == NULL)
				only->q_flags |= QPRIMARY;
		}
		else if (!initialdontsend && nrcpts > 0)
		{
			/* arrange for return receipt */
			e->e_flags |= EF_SENDRECEIPT;
			a->q_flags |= QEXPANDED;
			if (e->e_xfp != NULL && bitset(QPINGONSUCCESS, a->q_flags))
				fprintf(e->e_xfp,
					"%s... expanded to multiple addresses\n",
					a->q_paddr);
		}
	}
	a->q_flags |= QRCPTOK;
	return (a);
}
/*
**  FINDUSER -- find the password entry for a user.
**
**	This looks a lot like getpwnam, except that it may want to
**	do some fancier pattern matching in /etc/passwd.
**
**	This routine contains most of the time of many sendmail runs.
**	It deserves to be optimized.
**
**	Parameters:
**		name -- the name to match against.
**		fuzzyp -- an outarg that is set to TRUE if this entry
**			was found using the fuzzy matching algorithm;
**			set to FALSE otherwise.
**
**	Returns:
**		A pointer to a pw struct.
**		NULL if name is unknown or ambiguous.
**
**	Side Effects:
**		may modify name.
*/

struct passwd *
finduser(name, fuzzyp)
	char *name;
	bool *fuzzyp;
{
	register struct passwd *pw;
	register char *p;
	bool tryagain;

	if (tTd(29, 4))
		printf("finduser(%s): ", name);

	*fuzzyp = FALSE;

#ifdef HESIOD
	/* DEC Hesiod getpwnam accepts numeric strings -- short circuit it */
	for (p = name; *p != '\0'; p++)
		if (!isascii(*p) || !isdigit(*p))
			break;
	if (*p == '\0')
	{
		if (tTd(29, 4))
			printf("failed (numeric input)\n");
		return NULL;
	}
#endif

	/* look up this login name using fast path */
	if ((pw = sm_getpwnam(name)) != NULL)
	{
		if (tTd(29, 4))
			printf("found (non-fuzzy)\n");
		return (pw);
	}

	/* try mapping it to lower case */
	tryagain = FALSE;
	for (p = name; *p != '\0'; p++)
	{
		if (isascii(*p) && isupper(*p))
		{
			*p = tolower(*p);
			tryagain = TRUE;
		}
	}
	if (tryagain && (pw = sm_getpwnam(name)) != NULL)
	{
		if (tTd(29, 4))
			printf("found (lower case)\n");
		*fuzzyp = TRUE;
		return pw;
	}

#if MATCHGECOS
	/* see if fuzzy matching allowed */
	if (!MatchGecos)
	{
		if (tTd(29, 4))
			printf("not found (fuzzy disabled)\n");
		return NULL;
	}

	/* search for a matching full name instead */
	for (p = name; *p != '\0'; p++)
	{
		if (*p == (SpaceSub & 0177) || *p == '_')
			*p = ' ';
	}
	(void) setpwent();
	while ((pw = getpwent()) != NULL)
	{
		char buf[MAXNAME + 1];

# if 0
		if (strcasecmp(pw->pw_name, name) == 0)
		{
			if (tTd(29, 4))
				printf("found (case wrapped)\n");
			break;
		}
# endif

		buildfname(pw->pw_gecos, pw->pw_name, buf, sizeof buf);
		if (strchr(buf, ' ') != NULL && !strcasecmp(buf, name))
		{
			if (tTd(29, 4))
				printf("fuzzy matches %s\n", pw->pw_name);
			message("sending to login name %s", pw->pw_name);
			break;
		}
	}
	if (pw != NULL)
		*fuzzyp = TRUE;
	else if (tTd(29, 4))
		printf("no fuzzy match found\n");
# if DEC_OSF_BROKEN_GETPWENT	/* DEC OSF/1 3.2 or earlier */
	endpwent();
# endif
	return pw;
#else
	if (tTd(29, 4))
		printf("not found (fuzzy disabled)\n");
	return NULL;
#endif
}
/*
**  WRITABLE -- predicate returning if the file is writable.
**
**	This routine must duplicate the algorithm in sys/fio.c.
**	Unfortunately, we cannot use the access call since we
**	won't necessarily be the real uid when we try to
**	actually open the file.
**
**	Notice that ANY file with ANY execute bit is automatically
**	not writable.  This is also enforced by mailfile.
**
**	Parameters:
**		filename -- the file name to check.
**		ctladdr -- the controlling address for this file.
**		flags -- SFF_* flags to control the function.
**
**	Returns:
**		TRUE -- if we will be able to write this file.
**		FALSE -- if we cannot write this file.
**
**	Side Effects:
**		none.
*/

bool
writable(filename, ctladdr, flags)
	char *filename;
	ADDRESS *ctladdr;
	int flags;
{
	uid_t euid;
	gid_t egid;
	char *uname;

	if (tTd(44, 5))
		printf("writable(%s, 0x%x)\n", filename, flags);

	/*
	**  File does exist -- check that it is writable.
	*/

	if (geteuid() != 0)
	{
		euid = geteuid();
		egid = getegid();
		uname = NULL;
	}
	else if (ctladdr != NULL)
	{
		euid = ctladdr->q_uid;
		egid = ctladdr->q_gid;
		uname = ctladdr->q_user;
	}
	else if (bitset(SFF_RUNASREALUID, flags))
	{
		euid = RealUid;
		egid = RealGid;
		uname = RealUserName;
	}
	else if (FileMailer != NULL && !bitset(SFF_ROOTOK, flags))
	{
		euid = FileMailer->m_uid;
		egid = FileMailer->m_gid;
		uname = NULL;
	}
	else
	{
		euid = egid = 0;
		uname = NULL;
	}
	if (!bitset(SFF_ROOTOK, flags))
	{
		if (euid == 0)
		{
			euid = DefUid;
			uname = DefUser;
		}
		if (egid == 0)
			egid = DefGid;
	}
	if (geteuid() == 0 &&
	    (ctladdr == NULL || !bitset(QGOODUID, ctladdr->q_flags)))
		flags |= SFF_SETUIDOK;

	if (!bitset(DBS_FILEDELIVERYTOSYMLINK, DontBlameSendmail))
		flags |= SFF_NOSLINK;
	if (!bitset(DBS_FILEDELIVERYTOHARDLINK, DontBlameSendmail))
		flags |= SFF_NOHLINK;

	errno = safefile(filename, euid, egid, uname, flags, S_IWRITE, NULL);
	return errno == 0;
}
/*
**  INCLUDE -- handle :include: specification.
**
**	Parameters:
**		fname -- filename to include.
**		forwarding -- if TRUE, we are reading a .forward file.
**			if FALSE, it's a :include: file.
**		ctladdr -- address template to use to fill in these
**			addresses -- effective user/group id are
**			the important things.
**		sendq -- a pointer to the head of the send queue
**			to put these addresses in.
**		aliaslevel -- the alias nesting depth.
**		e -- the current envelope.
**
**	Returns:
**		open error status
**
**	Side Effects:
**		reads the :include: file and sends to everyone
**		listed in that file.
**
**	Security Note:
**		If you have restricted chown (that is, you can't
**		give a file away), it is reasonable to allow programs
**		and files called from this :include: file to be to be
**		run as the owner of the :include: file.  This is bogus
**		if there is any chance of someone giving away a file.
**		We assume that pre-POSIX systems can give away files.
**
**		There is an additional restriction that if you
**		forward to a :include: file, it will not take on
**		the ownership of the :include: file.  This may not
**		be necessary, but shouldn't hurt.
*/

static jmp_buf	CtxIncludeTimeout;
static void	includetimeout __P((void));

int
include(fname, forwarding, ctladdr, sendq, aliaslevel, e)
	char *fname;
	bool forwarding;
	ADDRESS *ctladdr;
	ADDRESS **sendq;
	int aliaslevel;
	ENVELOPE *e;
{
	FILE *volatile fp = NULL;
	char *oldto = e->e_to;
	char *oldfilename = FileName;
	int oldlinenumber = LineNumber;
	register EVENT *ev = NULL;
	int nincludes;
	int mode;
	register ADDRESS *ca;
	volatile uid_t saveduid, uid;
	volatile gid_t savedgid, gid;
	char *volatile uname;
	int rval = 0;
	volatile int sfflags = SFF_REGONLY;
	register char *p;
	bool safechown = FALSE;
	volatile bool safedir = FALSE;
	struct stat st;
	char buf[MAXLINE];
	extern bool chownsafe __P((int, bool));

	if (tTd(27, 2))
		printf("include(%s)\n", fname);
	if (tTd(27, 4))
		printf("   ruid=%d euid=%d\n", (int) getuid(), (int) geteuid());
	if (tTd(27, 14))
	{
		printf("ctladdr ");
		printaddr(ctladdr, FALSE);
	}

	if (tTd(27, 9))
		printf("include: old uid = %d/%d\n",
		       (int) getuid(), (int) geteuid());

	if (forwarding)
		sfflags |= SFF_MUSTOWN|SFF_ROOTOK|SFF_NOWLINK;

	ca = getctladdr(ctladdr);
	if (ca == NULL)
	{
		uid = DefUid;
		gid = DefGid;
		uname = DefUser;
	}
	else
	{
		uid = ca->q_uid;
		gid = ca->q_gid;
		uname = ca->q_user;
	}
#if HASSETREUID || USESETEUID
	saveduid = geteuid();
	savedgid = getegid();
	if (saveduid == 0)
	{
		if (!DontInitGroups)
		{
			if (initgroups(uname, gid) == -1)
				syserr("include: initgroups(%s, %d) failed",
					uname, gid);
		}
		else
		{
			GIDSET_T gidset[1];

			gidset[0] = gid;
			if (setgroups(1, gidset) == -1)
				syserr("include: setgroups() failed");
		}

		if (gid != 0 && setgid(gid) < -1)
			syserr("setgid(%d) failure", gid);
		if (uid != 0)
		{
# if USESETEUID
			if (seteuid(uid) < 0)
				syserr("seteuid(%d) failure (real=%d, eff=%d)",
					uid, getuid(), geteuid());
# else
			if (setreuid(0, uid) < 0)
				syserr("setreuid(0, %d) failure (real=%d, eff=%d)",
					uid, getuid(), geteuid());
# endif
		}
	}
#endif

	if (tTd(27, 9))
		printf("include: new uid = %d/%d\n",
		       (int) getuid(), (int) geteuid());

	/*
	**  If home directory is remote mounted but server is down,
	**  this can hang or give errors; use a timeout to avoid this
	*/

	if (setjmp(CtxIncludeTimeout) != 0)
	{
		ctladdr->q_flags |= QQUEUEUP;
		errno = 0;

		/* return pseudo-error code */
		rval = E_SM_OPENTIMEOUT;
		goto resetuid;
	}
	if (TimeOuts.to_fileopen > 0)
		ev = setevent(TimeOuts.to_fileopen, includetimeout, 0);
	else
		ev = NULL;

	/* check for writable parent directory */
	p = strrchr(fname, '/');
	if (p != NULL)
	{
		int ret;

		*p = '\0';
		ret = safedirpath(fname, uid, gid, uname, sfflags|SFF_SAFEDIRPATH);
		if (ret == 0)
		{
			/* in safe directory: relax chown & link rules */
			safedir = TRUE;
			sfflags |= SFF_NOPATHCHECK;
		}
		else
		{
			if (bitset((forwarding ?
				    DBS_FORWARDFILEINUNSAFEDIRPATH :
				    DBS_INCLUDEFILEINUNSAFEDIRPATH),
				   DontBlameSendmail))
				sfflags |= SFF_NOPATHCHECK;
			else if (bitset((forwarding ?
					 DBS_FORWARDFILEINGROUPWRITABLEDIRPATH :
					 DBS_INCLUDEFILEINGROUPWRITABLEDIRPATH),
					DontBlameSendmail) &&
				 ret == E_SM_GWDIR)
			{
				DontBlameSendmail |= DBS_GROUPWRITABLEDIRPATHSAFE;
				ret = safedirpath(fname, uid,
						  gid, uname,
						  sfflags|SFF_SAFEDIRPATH);
				DontBlameSendmail &= ~DBS_GROUPWRITABLEDIRPATHSAFE;
				if (ret == 0)
					sfflags |= SFF_NOPATHCHECK;
				else
					sfflags |= SFF_SAFEDIRPATH;
			}
			else
				sfflags |= SFF_SAFEDIRPATH;
			if (ret > E_PSEUDOBASE &&
			    !bitset((forwarding ?
				     DBS_FORWARDFILEINUNSAFEDIRPATHSAFE :
				     DBS_INCLUDEFILEINUNSAFEDIRPATHSAFE),
				    DontBlameSendmail))
			{
				if (LogLevel >= 12)
					sm_syslog(LOG_INFO, e->e_id,
						  "%s: unsafe directory path, marked unsafe",
						  shortenstring(fname, MAXSHORTSTR));
				ctladdr->q_flags |= QUNSAFEADDR;
			}
		}
		*p = '/';
	}

	/* allow links only in unwritable directories */
	if (!safedir &&
	    !bitset((forwarding ?
		     DBS_LINKEDFORWARDFILEINWRITABLEDIR :
		     DBS_LINKEDINCLUDEFILEINWRITABLEDIR),
		    DontBlameSendmail))
		sfflags |= SFF_NOLINK;

	rval = safefile(fname, uid, gid, uname, sfflags, S_IREAD, &st);
	if (rval != 0)
	{
		/* don't use this :include: file */
		if (tTd(27, 4))
			printf("include: not safe (uid=%d): %s\n",
				(int) uid, errstring(rval));
	}
	else if ((fp = fopen(fname, "r")) == NULL)
	{
		rval = errno;
		if (tTd(27, 4))
			printf("include: open: %s\n", errstring(rval));
	}
	else if (filechanged(fname, fileno(fp), &st))
	{
		rval = E_SM_FILECHANGE;
		if (tTd(27, 4))
			printf("include: file changed after open\n");
	}
	if (ev != NULL)
		clrevent(ev);

resetuid:

#if HASSETREUID || USESETEUID
	if (saveduid == 0)
	{
		if (uid != 0)
		{
# if USESETEUID
			if (seteuid(0) < 0)
				syserr("seteuid(0) failure (real=%d, eff=%d)",
					getuid(), geteuid());
# else
			if (setreuid(-1, 0) < 0)
				syserr("setreuid(-1, 0) failure (real=%d, eff=%d)",
					getuid(), geteuid());
			if (setreuid(RealUid, 0) < 0)
				syserr("setreuid(%d, 0) failure (real=%d, eff=%d)",
					RealUid, getuid(), geteuid());
# endif
		}
		setgid(savedgid);
	}
#endif

	if (tTd(27, 9))
		printf("include: reset uid = %d/%d\n",
		       (int) getuid(), (int) geteuid());

	if (rval == E_SM_OPENTIMEOUT)
		usrerr("451 open timeout on %s", fname);

	if (fp == NULL)
		return rval;

	if (fstat(fileno(fp), &st) < 0)
	{
		rval = errno;
		syserr("Cannot fstat %s!", fname);
		return rval;
	}

	/* if path was writable, check to avoid file giveaway tricks */
	safechown = chownsafe(fileno(fp), safedir);
	if (tTd(27, 6))
		printf("include: parent of %s is %s, chown is %ssafe\n",
			fname,
			safedir ? "safe" : "dangerous",
			safechown ? "" : "un");

	if (ca == NULL && safechown)
	{
		ctladdr->q_uid = st.st_uid;
		ctladdr->q_gid = st.st_gid;
		ctladdr->q_flags |= QGOODUID;
	}
	if (ca != NULL && ca->q_uid == st.st_uid)
	{
		/* optimization -- avoid getpwuid if we already have info */
		ctladdr->q_flags |= ca->q_flags & QBOGUSSHELL;
		ctladdr->q_ruser = ca->q_ruser;
	}
	else if (!forwarding)
	{
		register struct passwd *pw;

		pw = sm_getpwuid(st.st_uid);
		if (pw == NULL)
			ctladdr->q_flags |= QBOGUSSHELL;
		else
		{
			char *sh;

			ctladdr->q_ruser = newstr(pw->pw_name);
			if (safechown)
				sh = pw->pw_shell;
			else
				sh = "/SENDMAIL/ANY/SHELL/";
			if (!usershellok(pw->pw_name, sh))
			{
				if (LogLevel >= 12)
					sm_syslog(LOG_INFO, e->e_id,
						"%s: user %s has bad shell %s, marked %s",
						shortenstring(fname, MAXSHORTSTR),
						pw->pw_name, sh,
						safechown ? "bogus" : "unsafe");
				if (safechown)
					ctladdr->q_flags |= QBOGUSSHELL;
				else
					ctladdr->q_flags |= QUNSAFEADDR;
			}
		}
	}

	if (bitset(EF_VRFYONLY, e->e_flags))
	{
		/* don't do any more now */
		ctladdr->q_flags |= QVERIFIED;
		ctladdr->q_flags &= ~QDONTSEND;
		e->e_nrcpts++;
		xfclose(fp, "include", fname);
		return rval;
	}

	/*
	**  Check to see if some bad guy can write this file
	**
	**	Group write checking could be more clever, e.g.,
	**	guessing as to which groups are actually safe ("sys"
	**	may be; "user" probably is not).
	*/

	mode = S_IWOTH;
	if (!bitset((forwarding ?
		     DBS_GROUPWRITABLEFORWARDFILESAFE :
		     DBS_GROUPWRITABLEINCLUDEFILESAFE),
		    DontBlameSendmail))
		mode |= S_IWGRP;

	if (bitset(mode, st.st_mode))
	{
		if (tTd(27, 6))
			printf("include: %s is %s writable, marked unsafe\n",
				shortenstring(fname, MAXSHORTSTR),
				bitset(S_IWOTH, st.st_mode) ? "world" : "group");
		if (LogLevel >= 12)
			sm_syslog(LOG_INFO, e->e_id,
				"%s: %s writable %s file, marked unsafe",
				shortenstring(fname, MAXSHORTSTR),
				bitset(S_IWOTH, st.st_mode) ? "world" : "group",
				forwarding ? "forward" : ":include:");
		ctladdr->q_flags |= QUNSAFEADDR;
	}

	/* read the file -- each line is a comma-separated list. */
	FileName = fname;
	LineNumber = 0;
	ctladdr->q_flags &= ~QSELFREF;
	nincludes = 0;
	while (fgets(buf, sizeof buf, fp) != NULL)
	{
		register char *p = strchr(buf, '\n');

		LineNumber++;
		if (p != NULL)
			*p = '\0';
		if (buf[0] == '#' || buf[0] == '\0')
			continue;

		/* <sp>#@@# introduces a comment anywhere */
		/* for Japanese character sets */
		for (p = buf; (p = strchr(++p, '#')) != NULL; )
		{
			if (p[1] == '@@' && p[2] == '#' &&
			    isascii(p[-1]) && isspace(p[-1]) &&
			    (p[3] == '\0' || (isascii(p[3]) && isspace(p[3]))))
			{
				p[-1] = '\0';
				break;
			}
		}
		if (buf[0] == '\0')
			continue;

		e->e_to = NULL;
		message("%s to %s",
			forwarding ? "forwarding" : "sending", buf);
		if (forwarding && LogLevel > 9)
			sm_syslog(LOG_INFO, e->e_id,
				"forward %.200s => %s",
				oldto, shortenstring(buf, MAXSHORTSTR));

		nincludes += sendtolist(buf, ctladdr, sendq, aliaslevel + 1, e);
	}

	if (ferror(fp) && tTd(27, 3))
		printf("include: read error: %s\n", errstring(errno));
	if (nincludes > 0 && !bitset(QSELFREF, ctladdr->q_flags))
	{
		if (tTd(27, 5))
		{
			printf("include: QDONTSEND ");
			printaddr(ctladdr, FALSE);
		}
		ctladdr->q_flags |= QDONTSEND;
	}

	(void) xfclose(fp, "include", fname);
	FileName = oldfilename;
	LineNumber = oldlinenumber;
	e->e_to = oldto;
	return rval;
}

static void
includetimeout()
{
	longjmp(CtxIncludeTimeout, 1);
}
/*
**  SENDTOARGV -- send to an argument vector.
**
**	Parameters:
**		argv -- argument vector to send to.
**		e -- the current envelope.
**
**	Returns:
**		none.
**
**	Side Effects:
**		puts all addresses on the argument vector onto the
**			send queue.
*/

void
sendtoargv(argv, e)
	register char **argv;
	register ENVELOPE *e;
{
	register char *p;

	while ((p = *argv++) != NULL)
	{
		(void) sendtolist(p, NULLADDR, &e->e_sendqueue, 0, e);
	}
}
/*
**  GETCTLADDR -- get controlling address from an address header.
**
**	If none, get one corresponding to the effective userid.
**
**	Parameters:
**		a -- the address to find the controller of.
**
**	Returns:
**		the controlling address.
**
**	Side Effects:
**		none.
*/

ADDRESS *
getctladdr(a)
	register ADDRESS *a;
{
	while (a != NULL && !bitset(QGOODUID, a->q_flags))
		a = a->q_alias;
	return (a);
}
/*
**  SELF_REFERENCE -- check to see if an address references itself
**
**	The check is done through a chain of aliases.  If it is part of
**	a loop, break the loop at the "best" address, that is, the one
**	that exists as a real user.
**
**	This is to handle the case of:
**		awc:		Andrew.Chang
**		Andrew.Chang:	awc@@mail.server
**	which is a problem only on mail.server.
**
**	Parameters:
**		a -- the address to check.
**		e -- the current envelope.
**
**	Returns:
**		The address that should be retained.
*/

ADDRESS *
self_reference(a, e)
	ADDRESS *a;
	ENVELOPE *e;
{
	ADDRESS *b;		/* top entry in self ref loop */
	ADDRESS *c;		/* entry that point to a real mail box */

	if (tTd(27, 1))
		printf("self_reference(%s)\n", a->q_paddr);

	for (b = a->q_alias; b != NULL; b = b->q_alias)
	{
		if (sameaddr(a, b))
			break;
	}

	if (b == NULL)
	{
		if (tTd(27, 1))
			printf("\t... no self ref\n");
		return NULL;
	}

	/*
	**  Pick the first address that resolved to a real mail box
	**  i.e has a pw entry.  The returned value will be marked
	**  QSELFREF in recipient(), which in turn will disable alias()
	**  from marking it QDONTSEND, which mean it will be used
	**  as a deliverable address.
	**
	**  The 2 key thing to note here are:
	**	1) we are in a recursive call sequence:
	**		alias->sentolist->recipient->alias
	**	2) normally, when we return back to alias(), the address
	**	   will be marked QDONTSEND, since alias() assumes the
	**	   expanded form will be used instead of the current address.
	**	   This behaviour is turned off if the address is marked
	**	   QSELFREF We set QSELFREF when we return to recipient().
	*/

	c = a;
	while (c != NULL)
	{
		if (tTd(27, 10))
			printf("  %s", c->q_user);
		if (bitnset(M_HASPWENT, c->q_mailer->m_flags))
		{
			if (tTd(27, 2))
				printf("\t... getpwnam(%s)... ", c->q_user);
			if (sm_getpwnam(c->q_user) != NULL)
			{
				if (tTd(27, 2))
					printf("found\n");

				/* ought to cache results here */
				if (sameaddr(b, c))
					return b;
				else
					return c;
			}
			if (tTd(27, 2))
				printf("failed\n");
		}
		else
		{
			/* if local delivery, compare usernames */
			if (bitnset(M_LOCALMAILER, c->q_mailer->m_flags) &&
			    b->q_mailer == c->q_mailer)
			{
				if (tTd(27, 2))
					printf("\t... local match (%s)\n", c->q_user);
				if (sameaddr(b, c))
					return b;
				else
					return c;
			}
		}
		if (tTd(27, 10))
			printf("\n");
		c = c->q_alias;
	}

	if (tTd(27, 1))
		printf("\t... cannot break loop for \"%s\"\n", a->q_paddr);

	return NULL;
}
@


1.10
log
@sendmail 8.9.3
@
text
@@


1.9
log
@sendmail 8.9.2
@
text
@d14 1
a14 1
static char sccsid[] = "@@(#)recipient.c	8.161 (Berkeley) 12/18/1998";
d1198 1
d1413 2
d1433 16
@


1.8
log
@something hosed the sendmail import; fix up by hand
@
text
@d14 1
a14 1
static char sccsid[] = "@@(#)recipient.c	8.154 (Berkeley) 6/24/98";
d334 5
a338 2
	*pq = a;
	a->q_next = NULL;
d346 4
a349 1
		printf("at trylocaluser %s\n", a->q_user);
d940 1
a940 1
		sfflags |= SFF_MUSTOWN|SFF_ROOTOK|SFF_NOSLINK;
d1204 1
a1204 1
	** Check to see if some bad guy can write this file
@


1.7
log
@Upgrade to sendmail 8.8.8
@
text
@d2 2
a3 1
 * Copyright (c) 1983, 1995-1997 Eric P. Allman
d7 3
a9 15
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
a10 11
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
d14 1
a14 1
static char sccsid[] = "@@(#)recipient.c	8.133 (Berkeley) 10/19/97";
d18 1
d116 1
a116 1
			extern ADDRESS *self_reference();
d294 1
d311 3
a313 1
		if (sameaddr(q, a) && bitset(QRCPTOK, q->q_flags))
d368 1
a368 1
						shortenstring(a->q_user, 203),
d373 1
a373 1
					shortenstring(a->q_user, 203),
d381 1
a381 1
					shortenstring(a->q_user, 203),
d388 1
a388 1
		extern bool writable();
d412 1
d438 1
a438 1
		extern int udbexpand();
d842 5
a846 1
	flags |= SFF_NOLINK;
d888 1
a888 1
static void	includetimeout();
d905 1
d917 1
a917 1
	extern bool chownsafe();
d955 16
a970 3
			initgroups(uname, gid);
		if (gid != 0)
			(void) setgid(gid);
a981 2
			else
				sfflags |= SFF_NOPATHCHECK;
d1013 2
d1016 2
a1017 1
		if (safedirpath(fname, uid, gid, uname, sfflags|SFF_SAFEDIRPATH) == 0)
d1023 38
d1065 5
a1069 1
	if (!safedir)
d1086 1
a1086 1
	else if (filechanged(fname, fileno(fp), &st, sfflags))
d1177 1
a1177 1
						shortenstring(fname, 203),
a1202 3
	**	Also, we don't check for writable
	**	directories in the path.  We've got to leave
	**	something for the local sysad to do.
d1205 13
a1217 2
	if (bitset(S_IWOTH | (UnsafeGroupWrites ? S_IWGRP : 0), st.st_mode))
	{
d1221 1
a1221 1
				shortenstring(fname, 203),
d1263 1
a1263 1
				oldto, shortenstring(buf, 203));
@


1.6
log
@Sendmail 8.8.6.
@
text
@d36 1
a36 1
static char sccsid[] = "@@(#)recipient.c	8.130 (Berkeley) 5/29/97";
d266 1
d331 1
a331 1
		if (sameaddr(q, a))
d645 1
a645 1

d926 1
a926 1
	bool safedir = FALSE;
@


1.5
log
@Update to Sendmail 8.8.4, plus recent patches, plus OpenBSD support.
Also include entire example configuration subset.
Includes smrsh (using /usr/libexec/sm.bin).

Of the top of my head, the only things I removed from the distribution were
contrib/mail.local.linux, src/Makefiles, all the *.0 and *.ps files.
Our praliases man page replaces the distributed one, ours is better.
@
text
@d2 1
a2 1
 * Copyright (c) 1983, 1995, 1996 Eric P. Allman
d36 1
a36 1
static char sccsid[] = "@@(#)recipient.c	8.118 (Berkeley) 12/1/96";
a78 1
	bool firstone;		/* set on first address sent */
a106 1
	firstone = TRUE;
a185 1
		firstone = FALSE;
d303 6
a308 2
			usrerr("550 User %s@@%s doesn't have a valid shell for mailing to programs",
				a->q_alias->q_ruser, MyHostName);
a381 1
#ifdef LOG
d383 2
a384 2
					syslog(LOG_ERR, "%s: include %s: transient error: %s",
						e->e_id == NULL ? "NOQUEUE" : e->e_id,
a386 1
#endif
d418 6
a423 2
			usrerr("550 User %s@@%s doesn't have a valid shell for mailing to files",
				a->q_alias->q_ruser, MyHostName);
d432 4
a460 1
# ifdef LOG
d462 2
a463 2
				syslog(LOG_INFO, "%s: deferred: udbexpand: %s",
					e->e_id == NULL ? "NOQUEUE" : e->e_id,
a464 1
# endif
d816 7
a822 1
	if (ctladdr != NULL && geteuid() == 0)
d858 1
d923 3
a927 17
#ifdef _POSIX_CHOWN_RESTRICTED
# if _POSIX_CHOWN_RESTRICTED == -1
#  define safechown	FALSE
# else
#  define safechown	TRUE
# endif
#else
# ifdef _PC_CHOWN_RESTRICTED
	bool safechown;
# else
#  ifdef BSD
#   define safechown	TRUE
#  else
#   define safechown	FALSE
#  endif
# endif
#endif
d1001 1
a1001 1
		rval = EOPENTIMEOUT;
d1009 19
a1027 2
	/* the input file must be marked safe */
	rval = safefile(fname, uid, gid, uname, sfflags, S_IREAD, NULL);
d1035 7
a1041 1
	else
d1043 3
a1045 7
		fp = fopen(fname, "r");
		if (fp == NULL)
		{
			rval = errno;
			if (tTd(27, 4))
				printf("include: open: %s\n", errstring(rval));
		}
d1078 1
a1078 1
	if (rval == EOPENTIMEOUT)
d1091 8
a1098 3
#ifndef safechown
	safechown = chownsafe(fileno(fp));
#endif
a1128 1
#ifdef LOG
d1130 2
a1131 1
					syslog(LOG_INFO, "%s: user %s has bad shell %s, marked %s",
a1134 1
#endif
a1164 1
#ifdef LOG
d1166 2
a1167 1
			syslog(LOG_INFO, "%s: %s writable %s file, marked unsafe",
a1170 1
#endif
a1206 1
#ifdef LOG
d1208 2
a1209 2
			syslog(LOG_INFO, "%s: forward %.200s => %s",
				e->e_id == NULL ? "NOQUEUE" : e->e_id,
a1210 1
#endif
@


1.4
log
@bring up to 8.7.6
@
text
@d2 1
a2 1
 * Copyright (c) 1983, 1995 Eric P. Allman
d36 1
a36 1
static char sccsid[] = "@@(#)recipient.c	8.108.1.1 (Berkeley) 9/12/96";
d244 1
a244 1
	extern int safefile();
d270 1
a270 1
		usrerr("554 aliasing/forwarding loop broken (%d aliases deep; %d max",
d477 2
a478 2
		printf("recipient: testing local?  cl=%d, rr5=%x\n\t",
			ConfigLevel, RewriteRules[5]);
d485 2
d500 1
a500 1
		extern struct passwd *finduser();
d604 1
a604 1
		ADDRESS *only;
d743 1
a743 2
			*fuzzyp = TRUE;
			return pw;
d753 1
a753 2
			*fuzzyp = TRUE;
			return (pw);
d756 3
a758 1
	if (tTd(29, 4))
d760 4
d767 1
a768 1
	return (NULL);
d910 1
a910 1
	int sfflags = SFF_REGONLY;
d935 1
a935 1
		printf("   ruid=%d euid=%d\n", getuid(), geteuid());
d943 2
a944 1
		printf("include: old uid = %d/%d\n", getuid(), geteuid());
d989 2
a990 1
		printf("include: new uid = %d/%d\n", getuid(), geteuid());
d1018 1
a1018 1
				uid, errstring(rval));
d1058 2
a1059 1
		printf("include: reset uid = %d/%d\n", getuid(), geteuid());
d1089 1
a1089 1
	else
d1134 4
a1137 3
	**	This should really do something clever with group
	**	permissions; currently we just view world writable
	**	as unsafe.  Also, we don't check for writable
d1142 1
a1142 1
	if (bitset(S_IWOTH, st.st_mode))
d1146 1
a1146 1
			syslog(LOG_INFO, "%s: world writable %s file, marked unsafe",
d1148 1
@


1.3
log
@sendmail gecos oflow -- found by mudge, this fix by downsj.  I knew about this
hole a month ago. OpenBSD is not vulnerable because you cannot set a gecos that
long -- bitblt and I fixed chfn & the other tools when we became aware of the
hole; we did not fix sendmail to avoid bringing attention to the sendmail hole
@
text
@d36 1
a36 1
static char sccsid[] = "@@(#)recipient.c	8.108 (Berkeley) 10/30/95";
d502 1
a502 1
		if (pw == NULL)
@


1.2
log
@Sendmail 8.7.3 from NetBSD
@
text
@d538 1
a538 1
			buildfname(pw->pw_gecos, pw->pw_name, nbuf);
d746 1
a746 1
		buildfname(pw->pw_gecos, pw->pw_name, buf);
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
 * Copyright (c) 1983 Eric P. Allman
d36 1
a36 1
static char sccsid[] = "@@(#)recipient.c	8.44.1.6 (Berkeley) 3/5/95";
a39 1
# include <pwd.h>
d55 2
d66 2
a67 1
# define MAXRCRSN	10
d69 2
a70 1
sendtolist(list, ctladdr, sendq, e)
d74 1
d135 51
a185 4
		/* see if this should be marked as a primary address */
		if (ctladdr == NULL ||
		    (firstone && *p == '\0' && bitset(QPRIMARY, ctladdr->q_flags)))
			a->q_flags |= QPRIMARY;
a186 2
		if (ctladdr != NULL && sameaddr(ctladdr, a))
			ctladdr->q_flags |= QSELFREF;
d197 1
a197 5
		a = recipient(a, sendq, e);

		/* arrange to inherit full name */
		if (a->q_fullname == NULL && ctladdr != NULL)
			a->q_fullname = ctladdr->q_fullname;
d216 1
d228 1
a228 1
recipient(a, sendq, e)
d231 1
d240 4
a243 1
	char buf[MAXNAME];		/* unquoted image of the user name */
d249 2
d253 1
a253 1
		printf("\nrecipient: ");
d267 1
a267 1
	if (AliasLevel > MAXRCRSN)
d269 3
a271 1
		usrerr("554 aliasing/forwarding loop broken");
a278 3
	/* set the queue timeout */
	a->q_timeout = TimeOuts.to_q_return;

d280 5
d299 1
d305 1
d312 1
d345 1
a345 1
			goto testselfdestruct;
d370 1
d378 1
a378 1
			ret = include(a->q_user, FALSE, a, sendq, e);
d385 2
a386 1
						a->q_user, errstring(ret));
d391 2
a392 1
					a->q_user, errstring(ret));
d397 1
d399 2
a400 1
					a->q_user, errstring(ret));
d412 1
d418 1
d425 1
d429 1
a429 1
		else if (!writable(buf, getctladdr(a), SFF_ANYFILE))
d432 2
a433 1
			giveresponse(EX_CANTCREAT, m, NULL, a->q_alias, e);
a436 7
	if (m != LocalMailer)
	{
		if (!bitset(QDONTSEND, a->q_flags))
			e->e_nrcpts++;
		goto testselfdestruct;
	}

d438 3
a440 1
	alias(a, sendq, e);
d442 1
a442 1
# ifdef USERDB
d444 2
a445 1
	if (!bitset(QDONTSEND|QNOTREMOTE|QVERIFIED, a->q_flags))
d449 1
a449 1
		if (udbexpand(a, sendq, e) == EX_TEMPFAIL)
a467 4
	/* if it was an alias or a UDB expansion, just return now */
	if (bitset(QDONTSEND|QQUEUEUP|QVERIFIED, a->q_flags))
		goto testselfdestruct;

d481 3
a483 2
	if (!bitset(QNOTREMOTE, a->q_flags) && ConfigLevel >= 2 &&
	    RewriteRules[5] != NULL)
d485 1
a485 1
		maplocaluser(a, sendq, e);
d493 2
a494 1
	if (!bitset(QDONTSEND|QQUEUEUP, a->q_flags))
d505 3
a507 1
			giveresponse(EX_NOUSER, m, NULL, a->q_alias, e);
d511 1
a511 1
			char nbuf[MAXNAME];
d520 1
d523 1
a523 1
					return (a);
d541 1
a541 2
			if (pw->pw_shell != NULL && pw->pw_shell[0] != '\0' &&
			    !usershellok(pw->pw_shell))
d545 7
a551 2
			if (!quoted)
				forward(a, sendq, e);
d558 1
d562 7
a568 1
		printaddr(a, TRUE);
d573 5
a577 3
		q = *sendq;
		while (q != NULL && bitset(QDONTSEND, q->q_flags))
			q = q->q_next;
d581 1
d585 53
d670 1
a670 2
	extern struct passwd *getpwent();
	extern struct passwd *getpwnam();
d677 1
d688 1
d691 1
a691 1
	if ((pw = getpwnam(name)) != NULL)
d698 19
a716 1
#ifdef MATCHGECOS
d734 11
a744 1
		char buf[MAXNAME];
a795 2
	int bits;
	register char *p;
a796 2
	struct stat stb;
	extern char RealUserName[];
d798 2
a799 28
	if (tTd(29, 5))
		printf("writable(%s, %x)\n", filename, flags);

#ifdef HASLSTAT
	if ((bitset(SFF_NOSLINK, flags) ? lstat(filename, &stb)
					: stat(filename, &stb)) < 0)
#else
	if (stat(filename, &stb) < 0)
#endif
	{
		/* file does not exist -- see if directory is safe */
		p = strrchr(filename, '/');
		if (p == NULL)
		{
			errno = ENOTDIR;
			return FALSE;
		}
		*p = '\0';
		errno = safefile(filename, RealUid, RealGid, RealUserName,
				 SFF_MUSTOWN, S_IWRITE|S_IEXEC);
		*p = '/';
		return errno == 0;
	}

#ifdef SUID_ROOT_FILES_OK
	/* really ought to be passed down -- and not a good idea */
	flags |= SFF_ROOTOK;
#endif
a804 8
	if (bitset(0111, stb.st_mode))
	{
		if (tTd(29, 5))
			printf("failed (mode %o: x bits)\n", stb.st_mode);
		errno = EPERM;
		return (FALSE);
	}

d811 1
a811 1
	else
d817 7
a823 1
	if (euid == 0)
d825 2
a826 2
		euid = DefUid;
		uname = DefUser;
d828 9
a836 13
	if (egid == 0)
		egid = DefGid;
	if (geteuid() == 0)
	{
		if (bitset(S_ISUID, stb.st_mode) &&
		    (stb.st_uid != 0 || bitset(SFF_ROOTOK, flags)))
		{
			euid = stb.st_uid;
			uname = NULL;
		}
		if (bitset(S_ISGID, stb.st_mode) &&
		    (stb.st_gid != 0 || bitset(SFF_ROOTOK, flags)))
			egid = stb.st_gid;
d838 3
d842 1
a842 5
	if (tTd(29, 5))
		printf("\teu/gid=%d/%d, st_u/gid=%d/%d\n",
			euid, egid, stb.st_uid, stb.st_gid);

	errno = safefile(filename, euid, egid, uname, flags, S_IWRITE);
d857 2
d882 1
a882 5
static int	includetimeout();

#ifndef S_IWOTH
# define S_IWOTH	(S_IWRITE >> 6)
#endif
d885 1
a885 1
include(fname, forwarding, ctladdr, sendq, e)
d890 1
d893 1
a893 1
	register FILE *fp = NULL;
d900 3
a902 3
	uid_t saveduid, uid;
	gid_t savedgid, gid;
	char *uname;
d904 1
a904 1
	int sfflags = forwarding ? SFF_MUSTOWN : SFF_ANYFILE;
d939 3
a947 1
		saveduid = -1;
d954 11
a964 4
#ifdef HASSETREUID
		saveduid = geteuid();
		savedgid = getegid();
		if (saveduid == 0)
d966 11
a976 3
			initgroups(uname, gid);
			if (uid != 0)
				(void) setreuid(0, uid);
a977 1
#endif                   
d979 1
d998 4
a1001 1
	ev = setevent((time_t) 60, includetimeout, 0);
d1004 1
a1004 1
	rval = safefile(fname, uid, gid, uname, sfflags, S_IREAD);
d1022 2
a1023 1
	clrevent(ev);
d1027 1
a1027 1
#ifdef HASSETREUID
d1031 10
a1040 1
			if (setreuid(-1, 0) < 0 || setreuid(RealUid, 0) < 0)
d1043 2
a1081 1
		char *sh;
d1084 4
a1087 3
		sh = "/SENDMAIL/ANY/SHELL/";
		pw = getpwuid(st.st_uid);
		if (pw != NULL)
d1089 2
a1093 7
		}
		if (pw == NULL)
			ctladdr->q_flags |= QBOGUSSHELL;
		else if(!usershellok(sh))
		{
			if (safechown)
				ctladdr->q_flags |= QBOGUSSHELL;
d1095 15
a1109 1
				ctladdr->q_flags |= QUNSAFEADDR;
d1133 7
d1141 1
d1157 16
d1178 1
a1178 1
			syslog(LOG_INFO, "%s: forward %s => %s",
d1180 1
a1180 1
				oldto, buf);
d1183 1
a1183 3
		AliasLevel++;
		nincludes += sendtolist(buf, ctladdr, sendq, e);
		AliasLevel--;
d1205 1
a1205 1
static
d1225 1
d1234 1
a1234 1
		(void) sendtolist(p, NULLADDR, &e->e_sendqueue, e);
d1259 90
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@


1.1.1.2
log
@sendmail 8.9.1
@
text
@d2 1
a2 2
 * Copyright (c) 1998 Sendmail, Inc.  All rights reserved.
 * Copyright (c) 1983, 1995-1997 Eric P. Allman.  All rights reserved.
d6 15
a20 3
 * By using this file, you agree to the terms and conditions set
 * forth in the LICENSE file which can be found at the top level of
 * the sendmail distribution.
d22 11
d36 1
a36 1
static char sccsid[] = "@@(#)recipient.c	8.154 (Berkeley) 6/24/98";
d40 1
a40 1
# include <grp.h>
a55 2
**		aliaslevel -- the current alias nesting depth -- to
**			diagnose loops.
d65 1
a65 2
/* q_flags bits inherited from ctladdr */
#define QINHERITEDBITS	(QPINGONSUCCESS|QPINGONFAILURE|QPINGONDELAY|QHASNOTIFY)
d67 1
a67 2
int
sendtolist(list, ctladdr, sendq, aliaslevel, e)
a70 1
	int aliaslevel;
d75 1
d104 1
d131 4
a134 51
		/* arrange to inherit attributes from parent */
		if (ctladdr != NULL)
		{
			ADDRESS *b;
			extern ADDRESS *self_reference __P((ADDRESS *, ENVELOPE *));

			/* self reference test */
			if (sameaddr(ctladdr, a))
			{
				if (tTd(27, 5))
				{
					printf("sendtolist: QSELFREF ");
					printaddr(ctladdr, FALSE);
				}
				ctladdr->q_flags |= QSELFREF;
			}

			/* check for address loops */
			b = self_reference(a, e);
			if (b != NULL)
			{
				b->q_flags |= QSELFREF;
				if (tTd(27, 5))
				{
					printf("sendtolist: QSELFREF ");
					printaddr(b, FALSE);
				}
				if (a != b)
				{
					if (tTd(27, 5))
					{
						printf("sendtolist: QDONTSEND ");
						printaddr(a, FALSE);
					}
					a->q_flags |= QDONTSEND;
					b->q_flags |= a->q_flags & QNOTREMOTE;
					continue;
				}
			}

			/* full name */
			if (a->q_fullname == NULL)
				a->q_fullname = ctladdr->q_fullname;

			/* various flag bits */
			a->q_flags &= ~QINHERITEDBITS;
			a->q_flags |= ctladdr->q_flags & QINHERITEDBITS;

			/* original recipient information */
			a->q_orcpt = ctladdr->q_orcpt;
		}
d136 2
d139 1
d148 5
a152 1
		a = recipient(a, sendq, aliaslevel, e);
a170 1
**		aliaslevel -- the current alias nesting depth.
d182 1
a182 1
recipient(a, sendq, aliaslevel, e)
a184 1
	int aliaslevel;
d193 2
a194 5
	bool initialdontsend = bitset(QDONTSEND, a->q_flags);
	int i;
	char *buf;
	char buf0[MAXNAME + 1];		/* unquoted image of the user name */
	extern void alias __P((ADDRESS *, ADDRESS **, int, ENVELOPE *));
a198 2
	if (aliaslevel == 0)
		a->q_flags |= QPRIMARY;
d201 1
a201 1
		printf("\nrecipient (%d): ", aliaslevel);
d215 1
a215 1
	if (aliaslevel > MaxAliasRecursion)
d217 1
a217 4
		a->q_flags |= QBADADDR;
		a->q_status = "5.4.6";
		usrerr("554 aliasing/forwarding loop broken (%d aliases deep; %d max)",
			aliaslevel, MaxAliasRecursion);
d225 3
a228 5
	i = strlen(a->q_user);
	if (i >= sizeof buf0)
		buf = xalloc(i + 1);
	else
		buf = buf0;
a242 1
			a->q_status = "5.7.1";
d248 2
a249 7
			a->q_status = "5.7.1";
			if (a->q_alias->q_ruser == NULL)
				usrerr("550 UID %d is an unknown user: cannot mail to programs",
					a->q_alias->q_uid);
			else
				usrerr("550 User %s@@%s doesn't have a valid shell for mailing to programs",
					a->q_alias->q_ruser, MyHostName);
a253 2
			a->q_status = "5.7.1";
			a->q_rstatus = newstr("Unsafe for mailing to programs");
d270 1
a270 3
		if (sameaddr(q, a) &&
		    (bitset(QRCPTOK, q->q_flags) ||
		     !bitset(QPRIMARY, q->q_flags)))
d286 1
a286 1
			goto done;
a310 1
			a->q_status = "5.7.1";
d318 1
a318 1
			ret = include(a->q_user, FALSE, a, sendq, aliaslevel, e);
d321 1
d323 4
a326 4
					sm_syslog(LOG_ERR, e->e_id,
						"include %s: transient error: %s",
						shortenstring(a->q_user, MAXSHORTSTR),
						errstring(ret));
d330 1
a330 2
					shortenstring(a->q_user, MAXSHORTSTR),
					errstring(ret));
a334 1
				a->q_status = "5.2.4";
d336 1
a336 2
					shortenstring(a->q_user, MAXSHORTSTR),
					errstring(ret));
d342 1
a342 1
		extern bool writable __P((char *, ADDRESS *, int));
a347 1
			a->q_status = "5.7.1";
d353 2
a354 7
			a->q_status = "5.7.1";
			if (a->q_alias->q_ruser == NULL)
				usrerr("550 UID %d is an unknown user: cannot mail to files",
					a->q_alias->q_uid);
			else
				usrerr("550 User %s@@%s doesn't have a valid shell for mailing to files",
					a->q_alias->q_ruser, MyHostName);
a358 2
			a->q_status = "5.7.1";
			a->q_rstatus = newstr("Unsafe for mailing to files");
d362 1
a362 5
		else if (strcmp(buf, "/dev/null") == 0)
		{
			/* /dev/null is always accepted */
		}
		else if (!writable(buf, a->q_alias, SFF_CREAT))
d365 1
a365 2
			giveresponse(EX_CANTCREAT, m, NULL, a->q_alias,
				     (time_t) 0, e);
d369 7
d377 1
a377 3
	if (!quoted && !bitset(QDONTSEND, a->q_flags) &&
	    bitnset(M_ALIASABLE, m->m_flags))
		alias(a, sendq, aliaslevel, e);
d379 1
a379 1
# if USERDB
d381 1
a381 2
	if (!bitset(QDONTSEND|QNOTREMOTE|QVERIFIED, a->q_flags) &&
	    bitnset(M_CHECKUDB, m->m_flags))
d383 1
a383 1
		extern int udbexpand __P((ADDRESS *, ADDRESS **, int, ENVELOPE *));
d385 1
a385 1
		if (udbexpand(a, sendq, aliaslevel, e) == EX_TEMPFAIL)
d390 1
d392 2
a393 2
				sm_syslog(LOG_INFO, e->e_id,
					"deferred: udbexpand: %s",
d395 1
d404 4
d417 2
a418 2
		printf("recipient: testing local?  cl=%d, rr5=%lx\n\t",
			ConfigLevel, (u_long) RewriteRules[5]);
d421 2
a422 3
	if (!bitset(QNOTREMOTE|QDONTSEND|QQUEUEUP|QVERIFIED, a->q_flags) &&
	    ConfigLevel >= 2 && RewriteRules[5] != NULL &&
	    bitnset(M_TRYRULESET5, m->m_flags))
d424 1
a424 3
		extern void maplocaluser __P((ADDRESS *, ADDRESS **, int, ENVELOPE *));

		maplocaluser(a, sendq, aliaslevel + 1, e);
d432 1
a432 2
	if (!bitset(QDONTSEND|QQUEUEUP|QVERIFIED, a->q_flags) &&
	    bitnset(M_HASPWENT, m->m_flags))
d436 1
a436 1
		extern void forward __P((ADDRESS *, ADDRESS **, int, ENVELOPE *));
d440 1
a440 1
		if (pw == NULL || strlen(pw->pw_name) > MAXNAME)
d443 1
a443 3
			a->q_status = "5.1.1";
			giveresponse(EX_NOUSER, m, NULL, a->q_alias,
				     (time_t) 0, e);
d447 1
a447 1
			char nbuf[MAXNAME + 1];
a455 1
					a->q_status = "5.4.6";
d458 1
a458 1
					goto done;
d473 1
a473 1
			buildfname(pw->pw_gecos, pw->pw_name, nbuf, sizeof nbuf);
d476 2
a477 1
			if (!usershellok(pw->pw_name, pw->pw_shell))
d481 2
a482 7
			if (bitset(EF_VRFYONLY, e->e_flags))
			{
				/* don't do any more now */
				a->q_flags |= QVERIFIED;
			}
			else if (!quoted)
				forward(a, sendq, aliaslevel, e);
a488 1
	a->q_flags |= QTHISPASS;
d492 1
a492 7
		printaddr(a, FALSE);
		if (tTd(26, 10))
		{
			printf("SENDQ:\n");
			printaddr(*sendq, TRUE);
			printf("----\n");
		}
d497 3
a499 5
		for (q = *sendq; q != NULL; q = q->q_next)
		{
			if (!bitset(QDONTSEND, q->q_flags))
				break;
		}
a502 1
			a->q_status = "5.4.6";
a505 53

  done:
	a->q_flags |= QTHISPASS;
	if (buf != buf0)
		free(buf);

	/*
	**  If we are at the top level, check to see if this has
	**  expanded to exactly one address.  If so, it can inherit
	**  the primaryness of the address.
	**
	**  While we're at it, clear the QTHISPASS bits.
	*/

	if (aliaslevel == 0)
	{
		int nrcpts = 0;
		ADDRESS *only = NULL;

		for (q = *sendq; q != NULL; q = q->q_next)
		{
			if (bitset(QTHISPASS, q->q_flags) &&
			    !bitset(QDONTSEND|QBADADDR, q->q_flags))
			{
				nrcpts++;
				only = q;
			}
			q->q_flags &= ~QTHISPASS;
		}
		if (nrcpts == 1)
		{
			/* check to see if this actually got a new owner */
			q = only;
			while ((q = q->q_alias) != NULL)
			{
				if (q->q_owner != NULL)
					break;
			}
			if (q == NULL)
				only->q_flags |= QPRIMARY;
		}
		else if (!initialdontsend && nrcpts > 0)
		{
			/* arrange for return receipt */
			e->e_flags |= EF_SENDRECEIPT;
			a->q_flags |= QEXPANDED;
			if (e->e_xfp != NULL && bitset(QPINGONSUCCESS, a->q_flags))
				fprintf(e->e_xfp,
					"%s... expanded to multiple addresses\n",
					a->q_paddr);
		}
	}
	a->q_flags |= QRCPTOK;
d538 2
a539 1
	bool tryagain;
a545 1
#ifdef HESIOD
a555 1
#endif
d558 1
a558 1
	if ((pw = sm_getpwnam(name)) != NULL)
d565 1
a565 19
	/* try mapping it to lower case */
	tryagain = FALSE;
	for (p = name; *p != '\0'; p++)
	{
		if (isascii(*p) && isupper(*p))
		{
			*p = tolower(*p);
			tryagain = TRUE;
		}
	}
	if (tryagain && (pw = sm_getpwnam(name)) != NULL)
	{
		if (tTd(29, 4))
			printf("found (lower case)\n");
		*fuzzyp = TRUE;
		return pw;
	}

#if MATCHGECOS
d583 1
a583 10
		char buf[MAXNAME + 1];

# if 0
		if (strcasecmp(pw->pw_name, name) == 0)
		{
			if (tTd(29, 4))
				printf("found (case wrapped)\n");
			break;
		}
# endif
d585 1
a585 1
		buildfname(pw->pw_gecos, pw->pw_name, buf, sizeof buf);
d591 2
a592 1
			break;
d595 1
a595 3
	if (pw != NULL)
		*fuzzyp = TRUE;
	else if (tTd(29, 4))
a596 4
# if DEC_OSF_BROKEN_GETPWENT	/* DEC OSF/1 3.2 or earlier */
	endpwent();
# endif
	return pw;
a599 1
	return NULL;
d601 1
d635 2
d638 2
d641 28
a668 2
	if (tTd(44, 5))
		printf("writable(%s, 0x%x)\n", filename, flags);
d674 1
a674 1
	if (geteuid() != 0)
d676 4
a679 3
		euid = geteuid();
		egid = getegid();
		uname = NULL;
d681 2
a682 1
	else if (ctladdr != NULL)
d688 1
a688 1
	else if (bitset(SFF_RUNASREALUID, flags))
d694 1
a694 1
	else if (FileMailer != NULL && !bitset(SFF_ROOTOK, flags))
d696 2
a697 3
		euid = FileMailer->m_uid;
		egid = FileMailer->m_gid;
		uname = NULL;
d699 13
a711 4
	else
	{
		euid = egid = 0;
		uname = NULL;
a712 13
	if (!bitset(SFF_ROOTOK, flags))
	{
		if (euid == 0)
		{
			euid = DefUid;
			uname = DefUser;
		}
		if (egid == 0)
			egid = DefGid;
	}
	if (geteuid() == 0 &&
	    (ctladdr == NULL || !bitset(QGOODUID, ctladdr->q_flags)))
		flags |= SFF_SETUIDOK;
d714 3
a716 4
	if (!bitset(DBS_FILEDELIVERYTOSYMLINK, DontBlameSendmail))
		flags |= SFF_NOSLINK;
	if (!bitset(DBS_FILEDELIVERYTOHARDLINK, DontBlameSendmail))
		flags |= SFF_NOHLINK;
d718 1
a718 1
	errno = safefile(filename, euid, egid, uname, flags, S_IWRITE, NULL);
a732 2
**		aliaslevel -- the alias nesting depth.
**		e -- the current envelope.
d756 5
a760 1
static void	includetimeout __P((void));
d763 1
a763 1
include(fname, forwarding, ctladdr, sendq, aliaslevel, e)
a767 1
	int aliaslevel;
d770 1
a770 1
	FILE *volatile fp = NULL;
a775 1
	int mode;
d777 3
a779 3
	volatile uid_t saveduid, uid;
	volatile gid_t savedgid, gid;
	char *volatile uname;
d781 1
a781 4
	volatile int sfflags = SFF_REGONLY;
	register char *p;
	bool safechown = FALSE;
	volatile bool safedir = FALSE;
d784 18
a801 1
	extern bool chownsafe __P((int, bool));
d806 1
a806 1
		printf("   ruid=%d euid=%d\n", (int) getuid(), (int) geteuid());
d814 1
a814 5
		printf("include: old uid = %d/%d\n",
		       (int) getuid(), (int) geteuid());

	if (forwarding)
		sfflags |= SFF_MUSTOWN|SFF_ROOTOK|SFF_NOSLINK;
d822 1
d829 8
a836 34
	}
#if HASSETREUID || USESETEUID
	saveduid = geteuid();
	savedgid = getegid();
	if (saveduid == 0)
	{
		if (!DontInitGroups)
		{
			if (initgroups(uname, gid) == -1)
				syserr("include: initgroups(%s, %d) failed",
					uname, gid);
		}
		else
		{
			GIDSET_T gidset[1];

			gidset[0] = gid;
			if (setgroups(1, gidset) == -1)
				syserr("include: setgroups() failed");
		}

		if (gid != 0 && setgid(gid) < -1)
			syserr("setgid(%d) failure", gid);
		if (uid != 0)
		{
# if USESETEUID
			if (seteuid(uid) < 0)
				syserr("seteuid(%d) failure (real=%d, eff=%d)",
					uid, getuid(), geteuid());
# else
			if (setreuid(0, uid) < 0)
				syserr("setreuid(0, %d) failure (real=%d, eff=%d)",
					uid, getuid(), geteuid());
# endif
d838 1
a839 1
#endif
d842 1
a842 2
		printf("include: new uid = %d/%d\n",
		       (int) getuid(), (int) geteuid());
d855 1
a855 1
		rval = E_SM_OPENTIMEOUT;
d858 1
a858 59
	if (TimeOuts.to_fileopen > 0)
		ev = setevent(TimeOuts.to_fileopen, includetimeout, 0);
	else
		ev = NULL;

	/* check for writable parent directory */
	p = strrchr(fname, '/');
	if (p != NULL)
	{
		int ret;

		*p = '\0';
		ret = safedirpath(fname, uid, gid, uname, sfflags|SFF_SAFEDIRPATH);
		if (ret == 0)
		{
			/* in safe directory: relax chown & link rules */
			safedir = TRUE;
			sfflags |= SFF_NOPATHCHECK;
		}
		else
		{
			if (bitset((forwarding ?
				    DBS_FORWARDFILEINUNSAFEDIRPATH :
				    DBS_INCLUDEFILEINUNSAFEDIRPATH),
				   DontBlameSendmail))
				sfflags |= SFF_NOPATHCHECK;
			else if (bitset((forwarding ?
					 DBS_FORWARDFILEINGROUPWRITABLEDIRPATH :
					 DBS_INCLUDEFILEINGROUPWRITABLEDIRPATH),
					DontBlameSendmail) &&
				 ret == E_SM_GWDIR)
			{
				DontBlameSendmail |= DBS_GROUPWRITABLEDIRPATHSAFE;
				ret = safedirpath(fname, uid,
						  gid, uname,
						  sfflags|SFF_SAFEDIRPATH);
				DontBlameSendmail &= ~DBS_GROUPWRITABLEDIRPATHSAFE;
				if (ret == 0)
					sfflags |= SFF_NOPATHCHECK;
				else
					sfflags |= SFF_SAFEDIRPATH;
			}
			else
				sfflags |= SFF_SAFEDIRPATH;
			if (ret > E_PSEUDOBASE &&
			    !bitset((forwarding ?
				     DBS_FORWARDFILEINUNSAFEDIRPATHSAFE :
				     DBS_INCLUDEFILEINUNSAFEDIRPATHSAFE),
				    DontBlameSendmail))
			{
				if (LogLevel >= 12)
					sm_syslog(LOG_INFO, e->e_id,
						  "%s: unsafe directory path, marked unsafe",
						  shortenstring(fname, MAXSHORTSTR));
				ctladdr->q_flags |= QUNSAFEADDR;
			}
		}
		*p = '/';
	}
d860 2
a861 9
	/* allow links only in unwritable directories */
	if (!safedir &&
	    !bitset((forwarding ?
		     DBS_LINKEDFORWARDFILEINWRITABLEDIR :
		     DBS_LINKEDINCLUDEFILEINWRITABLEDIR),
		    DontBlameSendmail))
		sfflags |= SFF_NOLINK;

	rval = safefile(fname, uid, gid, uname, sfflags, S_IREAD, &st);
d867 1
a867 1
				(int) uid, errstring(rval));
d869 1
a869 1
	else if ((fp = fopen(fname, "r")) == NULL)
d871 7
a877 3
		rval = errno;
		if (tTd(27, 4))
			printf("include: open: %s\n", errstring(rval));
d879 1
a879 8
	else if (filechanged(fname, fileno(fp), &st))
	{
		rval = E_SM_FILECHANGE;
		if (tTd(27, 4))
			printf("include: file changed after open\n");
	}
	if (ev != NULL)
		clrevent(ev);
d883 1
a883 1
#if HASSETREUID || USESETEUID
d887 1
a887 10
		{
# if USESETEUID
			if (seteuid(0) < 0)
				syserr("seteuid(0) failure (real=%d, eff=%d)",
					getuid(), geteuid());
# else
			if (setreuid(-1, 0) < 0)
				syserr("setreuid(-1, 0) failure (real=%d, eff=%d)",
					getuid(), geteuid());
			if (setreuid(RealUid, 0) < 0)
a889 2
# endif
		}
d895 1
a895 2
		printf("include: reset uid = %d/%d\n",
		       (int) getuid(), (int) geteuid());
d897 1
a897 1
	if (rval == E_SM_OPENTIMEOUT)
d910 3
a912 8
	/* if path was writable, check to avoid file giveaway tricks */
	safechown = chownsafe(fileno(fp), safedir);
	if (tTd(27, 6))
		printf("include: parent of %s is %s, chown is %ssafe\n",
			fname,
			safedir ? "safe" : "dangerous",
			safechown ? "" : "un");

d925 1
a925 1
	else if (!forwarding)
d927 1
d930 8
a937 1
		pw = sm_getpwuid(st.st_uid);
d940 1
a940 1
		else
a941 3
			char *sh;

			ctladdr->q_ruser = newstr(pw->pw_name);
d943 1
a943 1
				sh = pw->pw_shell;
d945 1
a945 14
				sh = "/SENDMAIL/ANY/SHELL/";
			if (!usershellok(pw->pw_name, sh))
			{
				if (LogLevel >= 12)
					sm_syslog(LOG_INFO, e->e_id,
						"%s: user %s has bad shell %s, marked %s",
						shortenstring(fname, MAXSHORTSTR),
						pw->pw_name, sh,
						safechown ? "bogus" : "unsafe");
				if (safechown)
					ctladdr->q_flags |= QBOGUSSHELL;
				else
					ctladdr->q_flags |= QUNSAFEADDR;
			}
d961 5
a965 3
	**	Group write checking could be more clever, e.g.,
	**	guessing as to which groups are actually safe ("sys"
	**	may be; "user" probably is not).
d968 1
a968 19
	mode = S_IWOTH;
	if (!bitset((forwarding ?
		     DBS_GROUPWRITABLEFORWARDFILESAFE :
		     DBS_GROUPWRITABLEINCLUDEFILESAFE),
		    DontBlameSendmail))
		mode |= S_IWGRP;

	if (bitset(mode, st.st_mode))
	{
		if (tTd(27, 6))
			printf("include: %s is %s writable, marked unsafe\n",
				shortenstring(fname, MAXSHORTSTR),
				bitset(S_IWOTH, st.st_mode) ? "world" : "group");
		if (LogLevel >= 12)
			sm_syslog(LOG_INFO, e->e_id,
				"%s: %s writable %s file, marked unsafe",
				shortenstring(fname, MAXSHORTSTR),
				bitset(S_IWOTH, st.st_mode) ? "world" : "group",
				forwarding ? "forward" : ":include:");
a969 1
	}
a984 16

		/* <sp>#@@# introduces a comment anywhere */
		/* for Japanese character sets */
		for (p = buf; (p = strchr(++p, '#')) != NULL; )
		{
			if (p[1] == '@@' && p[2] == '#' &&
			    isascii(p[-1]) && isspace(p[-1]) &&
			    (p[3] == '\0' || (isascii(p[3]) && isspace(p[3]))))
			{
				p[-1] = '\0';
				break;
			}
		}
		if (buf[0] == '\0')
			continue;

d988 1
d990 4
a993 3
			sm_syslog(LOG_INFO, e->e_id,
				"forward %.200s => %s",
				oldto, shortenstring(buf, MAXSHORTSTR));
d995 3
a997 1
		nincludes += sendtolist(buf, ctladdr, sendq, aliaslevel + 1, e);
d1019 1
a1019 1
static void
a1038 1
void
d1047 1
a1047 1
		(void) sendtolist(p, NULLADDR, &e->e_sendqueue, 0, e);
a1071 90
}
/*
**  SELF_REFERENCE -- check to see if an address references itself
**
**	The check is done through a chain of aliases.  If it is part of
**	a loop, break the loop at the "best" address, that is, the one
**	that exists as a real user.
**
**	This is to handle the case of:
**		awc:		Andrew.Chang
**		Andrew.Chang:	awc@@mail.server
**	which is a problem only on mail.server.
**
**	Parameters:
**		a -- the address to check.
**		e -- the current envelope.
**
**	Returns:
**		The address that should be retained.
*/

ADDRESS *
self_reference(a, e)
	ADDRESS *a;
	ENVELOPE *e;
{
	ADDRESS *b;		/* top entry in self ref loop */
	ADDRESS *c;		/* entry that point to a real mail box */

	if (tTd(27, 1))
		printf("self_reference(%s)\n", a->q_paddr);

	for (b = a->q_alias; b != NULL; b = b->q_alias)
	{
		if (sameaddr(a, b))
			break;
	}

	if (b == NULL)
	{
		if (tTd(27, 1))
			printf("\t... no self ref\n");
		return NULL;
	}

	/*
	**  Pick the first address that resolved to a real mail box
	**  i.e has a pw entry.  The returned value will be marked
	**  QSELFREF in recipient(), which in turn will disable alias()
	**  from marking it QDONTSEND, which mean it will be used
	**  as a deliverable address.
	**
	**  The 2 key thing to note here are:
	**	1) we are in a recursive call sequence:
	**		alias->sentolist->recipient->alias
	**	2) normally, when we return back to alias(), the address
	**	   will be marked QDONTSEND, since alias() assumes the
	**	   expanded form will be used instead of the current address.
	**	   This behaviour is turned off if the address is marked
	**	   QSELFREF We set QSELFREF when we return to recipient().
	*/

	c = a;
	while (c != NULL)
	{
		if (bitnset(M_HASPWENT, c->q_mailer->m_flags))
		{
			if (tTd(27, 2))
				printf("\t... getpwnam(%s)... ", c->q_user);
			if (sm_getpwnam(c->q_user) != NULL)
			{
				if (tTd(27, 2))
					printf("found\n");

				/* ought to cache results here */
				if (sameaddr(b, c))
					return b;
				else
					return c;
			}
			if (tTd(27, 2))
				printf("failed\n");
		}
		c = c->q_alias;
	}

	if (tTd(27, 1))
		printf("\t... cannot break loop for \"%s\"\n", a->q_paddr);

	return NULL;
@

