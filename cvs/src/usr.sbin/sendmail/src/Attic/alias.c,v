head	1.9;
access;
symbols
	OPENBSD_2_6:1.8.0.4
	OPENBSD_2_6_BASE:1.8
	OPENBSD_2_5:1.8.0.2
	OPENBSD_2_5_BASE:1.8
	OPENBSD_2_4:1.7.0.2
	OPENBSD_2_4_BASE:1.7
	sendmail_8_9_1:1.1.1.2
	UCB:1.1.1
	OPENBSD_2_3:1.6.0.4
	OPENBSD_2_3_BASE:1.6
	OPENBSD_2_2:1.6.0.2
	OPENBSD_2_2_BASE:1.6
	OPENBSD_2_1:1.5.0.2
	OPENBSD_2_1_BASE:1.5
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.9
date	2000.04.18.04.57.16;	author millert;	state dead;
branches;
next	1.8;

1.8
date	99.01.01.20.33.37;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	98.07.12.19.44.18;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	97.07.15.07.23.57;	author downsj;	state Exp;
branches;
next	1.5;

1.5
date	97.01.22.01.07.00;	author downsj;	state Exp;
branches;
next	1.4;

1.4
date	96.12.14.21.17.02;	author downsj;	state Exp;
branches;
next	1.3;

1.3
date	96.09.19.06.44.51;	author fn;	state Exp;
branches;
next	1.2;

1.2
date	96.01.29.01.43.24;	author dm;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.48.17;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.48.17;	author deraadt;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	98.07.12.17.09.46;	author millert;	state Exp;
branches;
next	;


desc
@@


1.9
log
@remove sendmail 8.9.3
@
text
@/*
 * Copyright (c) 1998 Sendmail, Inc.  All rights reserved.
 * Copyright (c) 1983, 1995-1997 Eric P. Allman.  All rights reserved.
 *
 * By using this file, you agree to the terms and conditions set
 * forth in the LICENSE file which can be found at the top level of
 * the sendmail distribution.
 *
 * Copyright (c) 1988, 1993
 *	The Regents of the University of California.  All rights reserved.
 */

# include "sendmail.h"

#ifndef lint
static char sccsid[] = "@@(#)alias.c	8.96 (Berkeley) 12/18/1998";
#endif /* not lint */


MAP	*AliasFileMap = NULL;	/* the actual aliases.files map */
int	NAliasFileMaps;		/* the number of entries in AliasFileMap */
/*
**  ALIAS -- Compute aliases.
**
**	Scans the alias file for an alias for the given address.
**	If found, it arranges to deliver to the alias list instead.
**	Uses libdbm database if -DDBM.
**
**	Parameters:
**		a -- address to alias.
**		sendq -- a pointer to the head of the send queue
**			to put the aliases in.
**		aliaslevel -- the current alias nesting depth.
**		e -- the current envelope.
**
**	Returns:
**		none
**
**	Side Effects:
**		Aliases found are expanded.
**
**	Deficiencies:
**		It should complain about names that are aliased to
**			nothing.
*/

void
alias(a, sendq, aliaslevel, e)
	register ADDRESS *a;
	ADDRESS **sendq;
	int aliaslevel;
	register ENVELOPE *e;
{
	register char *p;
	char *owner;
	auto int stat = EX_OK;
	char obuf[MAXNAME + 7];
	extern char *aliaslookup __P((char *, int *, ENVELOPE *));

	if (tTd(27, 1))
		printf("alias(%s)\n", a->q_user);

	/* don't realias already aliased names */
	if (bitset(QDONTSEND|QBADADDR|QVERIFIED, a->q_flags))
		return;

	if (NoAlias)
		return;

	e->e_to = a->q_paddr;

	/*
	**  Look up this name.
	**
	**	If the map was unavailable, we will queue this message
	**	until the map becomes available; otherwise, we could
	**	bounce messages inappropriately.
	*/

	p = aliaslookup(a->q_user, &stat, e);
	if (stat == EX_TEMPFAIL || stat == EX_UNAVAILABLE)
	{
		a->q_flags |= QQUEUEUP;
		if (e->e_message == NULL)
			e->e_message = newstr("alias database unavailable");
		return;
	}
	if (p == NULL)
		return;

	/*
	**  Match on Alias.
	**	Deliver to the target list.
	*/

	if (tTd(27, 1))
		printf("%s (%s, %s) aliased to %s\n",
		    a->q_paddr, a->q_host, a->q_user, p);
	if (bitset(EF_VRFYONLY, e->e_flags))
	{
		a->q_flags |= QVERIFIED;
		return;
	}
	message("aliased to %s", shortenstring(p, MAXSHORTSTR));
	if (LogLevel > 9)
		sm_syslog(LOG_INFO, e->e_id,
			"alias %.100s => %s",
			a->q_paddr, shortenstring(p, MAXSHORTSTR));
	a->q_flags &= ~QSELFREF;
	if (tTd(27, 5))
	{
		printf("alias: QDONTSEND ");
		printaddr(a, FALSE);
	}
	a->q_flags |= QDONTSEND;
	(void) sendtolist(p, a, sendq, aliaslevel + 1, e);
	if (bitset(QSELFREF, a->q_flags))
		a->q_flags &= ~QDONTSEND;

	/*
	**  Look for owner of alias
	*/

	(void) strcpy(obuf, "owner-");
	if (strncmp(a->q_user, "owner-", 6) == 0 ||
	    strlen(a->q_user) > (SIZE_T) sizeof obuf - 7)
		(void) strcat(obuf, "owner");
	else
		(void) strcat(obuf, a->q_user);
	owner = aliaslookup(obuf, &stat, e);
	if (owner == NULL)
		return;

	/* reflect owner into envelope sender */
	if (strpbrk(owner, ",:/|\"") != NULL)
		owner = obuf;
	a->q_owner = newstr(owner);

	/* announce delivery to this alias; NORECEIPT bit set later */
	if (e->e_xfp != NULL)
		fprintf(e->e_xfp, "Message delivered to mailing list %s\n",
			a->q_paddr);
	e->e_flags |= EF_SENDRECEIPT;
	a->q_flags |= QDELIVERED|QEXPANDED;
}
/*
**  ALIASLOOKUP -- look up a name in the alias file.
**
**	Parameters:
**		name -- the name to look up.
**		pstat -- a pointer to a place to put the status.
**		e -- the current envelope.
**
**	Returns:
**		the value of name.
**		NULL if unknown.
**
**	Side Effects:
**		none.
**
**	Warnings:
**		The return value will be trashed across calls.
*/

char *
aliaslookup(name, pstat, e)
	char *name;
	int *pstat;
	ENVELOPE *e;
{
	static MAP *map = NULL;

	if (map == NULL)
	{
		STAB *s = stab("aliases", ST_MAP, ST_FIND);

		if (s == NULL)
			return NULL;
		map = &s->s_map;
	}
	if (!bitset(MF_OPEN, map->map_mflags))
		return NULL;

	/* special case POstMastER -- always use lower case */
	if (strcasecmp(name, "postmaster") == 0)
		name = "postmaster";

	return (*map->map_class->map_lookup)(map, name, NULL, pstat);
}
/*
**  SETALIAS -- set up an alias map
**
**	Called when reading configuration file.
**
**	Parameters:
**		spec -- the alias specification
**
**	Returns:
**		none.
*/

void
setalias(spec)
	char *spec;
{
	register char *p;
	register MAP *map;
	char *class;
	STAB *s;

	if (tTd(27, 8))
		printf("setalias(%s)\n", spec);

	for (p = spec; p != NULL; )
	{
		char buf[50];

		while (isascii(*p) && isspace(*p))
			p++;
		if (*p == '\0')
			break;
		spec = p;

		if (NAliasFileMaps >= MAXMAPSTACK)
		{
			syserr("Too many alias databases defined, %d max",
				MAXMAPSTACK);
			return;
		}
		if (AliasFileMap == NULL)
		{
			strcpy(buf, "aliases.files sequence");
			AliasFileMap = makemapentry(buf);
			if (AliasFileMap == NULL)
			{
				syserr("setalias: cannot create aliases.files map");
				return;
			}
		}
		(void) snprintf(buf, sizeof buf, "Alias%d", NAliasFileMaps);
		s = stab(buf, ST_MAP, ST_ENTER);
		map = &s->s_map;
		bzero(map, sizeof *map);
		map->map_mname = s->s_name;

		p = strpbrk(p, " ,/:");
		if (p != NULL && *p == ':')
		{
			/* map name */
			*p++ = '\0';
			class = spec;
			spec = p;
		}
		else
		{
			class = "implicit";
			map->map_mflags = MF_INCLNULL;
		}

		/* find end of spec */
		if (p != NULL)
			p = strchr(p, ',');
		if (p != NULL)
			*p++ = '\0';

		if (tTd(27, 20))
			printf("  map %s:%s %s\n", class, s->s_name, spec);

		/* look up class */
		s = stab(class, ST_MAPCLASS, ST_FIND);
		if (s == NULL)
		{
			syserr("setalias: unknown alias class %s", class);
		}
		else if (!bitset(MCF_ALIASOK, s->s_mapclass.map_cflags))
		{
			syserr("setalias: map class %s can't handle aliases",
				class);
		}
		else
		{
			map->map_class = &s->s_mapclass;
			if (map->map_class->map_parse(map, spec))
			{
				map->map_mflags |= MF_VALID|MF_ALIAS;
				AliasFileMap->map_stack[NAliasFileMaps++] = map;
			}
		}
	}
}
/*
**  ALIASWAIT -- wait for distinguished @@:@@ token to appear.
**
**	This can decide to reopen or rebuild the alias file
**
**	Parameters:
**		map -- a pointer to the map descriptor for this alias file.
**		ext -- the filename extension (e.g., ".db") for the
**			database file.
**		isopen -- if set, the database is already open, and we
**			should check for validity; otherwise, we are
**			just checking to see if it should be created.
**
**	Returns:
**		TRUE -- if the database is open when we return.
**		FALSE -- if the database is closed when we return.
*/

bool
aliaswait(map, ext, isopen)
	MAP *map;
	char *ext;
	int isopen;
{
	bool attimeout = FALSE;
	time_t mtime;
	struct stat stb;
	char buf[MAXNAME + 1];

	if (tTd(27, 3))
		printf("aliaswait(%s:%s)\n",
			map->map_class->map_cname, map->map_file);
	if (bitset(MF_ALIASWAIT, map->map_mflags))
		return isopen;
	map->map_mflags |= MF_ALIASWAIT;

	if (SafeAlias > 0)
	{
		auto int st;
		time_t toolong = curtime() + SafeAlias;
		unsigned int sleeptime = 2;

		while (isopen &&
		       map->map_class->map_lookup(map, "@@", NULL, &st) == NULL)
		{
			if (curtime() > toolong)
			{
				/* we timed out */
				attimeout = TRUE;
				break;
			}

			/*
			**  Close and re-open the alias database in case
			**  the one is mv'ed instead of cp'ed in.
			*/

			if (tTd(27, 2))
				printf("aliaswait: sleeping for %d seconds\n",
					sleeptime);

			map->map_class->map_close(map);
			map->map_mflags &= ~(MF_OPEN|MF_WRITABLE);
			sleep(sleeptime);
			sleeptime *= 2;
			if (sleeptime > 60)
				sleeptime = 60;
			isopen = map->map_class->map_open(map, O_RDONLY);
		}
	}

	/* see if we need to go into auto-rebuild mode */
	if (!bitset(MCF_REBUILDABLE, map->map_class->map_cflags))
	{
		if (tTd(27, 3))
			printf("aliaswait: not rebuildable\n");
		map->map_mflags &= ~MF_ALIASWAIT;
		return isopen;
	}
	if (stat(map->map_file, &stb) < 0)
	{
		if (tTd(27, 3))
			printf("aliaswait: no source file\n");
		map->map_mflags &= ~MF_ALIASWAIT;
		return isopen;
	}
	mtime = stb.st_mtime;
	snprintf(buf, sizeof buf, "%s%s",
		map->map_file, ext == NULL ? "" : ext);
	if (stat(buf, &stb) < 0 || stb.st_mtime < mtime || attimeout)
	{
		/* database is out of date */
		if (AutoRebuild && stb.st_ino != 0 &&
		    (stb.st_uid == geteuid() ||
		     (geteuid() == 0 && stb.st_uid == TrustedUid)))
		{
			bool oldSuprErrs;

			message("auto-rebuilding alias database %s", buf);
			oldSuprErrs = SuprErrs;
			SuprErrs = TRUE;
			if (isopen)
			{
				map->map_class->map_close(map);
				map->map_mflags &= ~(MF_OPEN|MF_WRITABLE);
			}
			(void) rebuildaliases(map, TRUE);
			isopen = map->map_class->map_open(map, O_RDONLY);
			SuprErrs = oldSuprErrs;
		}
		else
		{
			if (LogLevel > 3)
				sm_syslog(LOG_INFO, NOQID,
					"alias database %s out of date",
					buf);
			message("Warning: alias database %s out of date", buf);
		}
	}
	map->map_mflags &= ~MF_ALIASWAIT;
	return isopen;
}
/*
**  REBUILDALIASES -- rebuild the alias database.
**
**	Parameters:
**		map -- the database to rebuild.
**		automatic -- set if this was automatically generated.
**
**	Returns:
**		TRUE if successful; FALSE otherwise.
**
**	Side Effects:
**		Reads the text version of the database, builds the
**		DBM or DB version.
*/

bool
rebuildaliases(map, automatic)
	register MAP *map;
	bool automatic;
{
	FILE *af;
	bool nolock = FALSE;
	bool success = FALSE;
	int sff = SFF_OPENASROOT|SFF_REGONLY|SFF_NOLOCK;	
	sigfunc_t oldsigint, oldsigquit;
#ifdef SIGTSTP
	sigfunc_t oldsigtstp;
#endif

	if (!bitset(MCF_REBUILDABLE, map->map_class->map_cflags))
		return FALSE;

	if (!bitset(DBS_LINKEDALIASFILEINWRITABLEDIR, DontBlameSendmail))
		sff |= SFF_NOWLINK;
	if (!bitset(DBS_GROUPWRITABLEALIASFILE, DontBlameSendmail))
		sff |= SFF_NOGWFILES;
	if (!bitset(DBS_WORLDWRITABLEALIASFILE, DontBlameSendmail))
		sff |= SFF_NOWWFILES;

	/* try to lock the source file */
	if ((af = safefopen(map->map_file, O_RDWR, 0, sff)) == NULL)
	{
		struct stat stb;

		if ((errno != EACCES && errno != EROFS) || automatic ||
		    (af = safefopen(map->map_file, O_RDONLY, 0, sff)) == NULL)
		{
			int saveerr = errno;

			if (tTd(27, 1))
				printf("Can't open %s: %s\n",
					map->map_file, errstring(saveerr));
			if (!automatic && !bitset(MF_OPTIONAL, map->map_mflags))
				message("newaliases: cannot open %s: %s",
					map->map_file, errstring(saveerr));
			errno = 0;
			return FALSE;
		}
		nolock = TRUE;
		if (tTd(27, 1) ||
		    fstat(fileno(af), &stb) < 0 ||
		    bitset(S_IWUSR|S_IWGRP|S_IWOTH, stb.st_mode))
			message("warning: cannot lock %s: %s",
				map->map_file, errstring(errno));
	}

	/* see if someone else is rebuilding the alias file */
	if (!nolock &&
	    !lockfile(fileno(af), map->map_file, NULL, LOCK_EX|LOCK_NB))
	{
		/* yes, they are -- wait until done */
		message("Alias file %s is locked (maybe being rebuilt)",
			map->map_file);
		if (OpMode != MD_INITALIAS)
		{
			/* wait for other rebuild to complete */
			(void) lockfile(fileno(af), map->map_file, NULL,
					LOCK_EX);
		}
		(void) xfclose(af, "rebuildaliases1", map->map_file);
		errno = 0;
		return FALSE;
	}

	oldsigint = setsignal(SIGINT, SIG_IGN);
	oldsigquit = setsignal(SIGQUIT, SIG_IGN);
#ifdef SIGTSTP
	oldsigtstp = setsignal(SIGTSTP, SIG_IGN);
#endif

	if (map->map_class->map_open(map, O_RDWR))
	{
		if (LogLevel > 7)
		{
			sm_syslog(LOG_NOTICE, NOQID,
				"alias database %s %srebuilt by %s",
				map->map_file, automatic ? "auto" : "",
				username());
		}
		map->map_mflags |= MF_OPEN|MF_WRITABLE;
		map->map_pid = getpid();
		readaliases(map, af, !automatic, TRUE);
		success = TRUE;
	}
	else
	{
		if (tTd(27, 1))
			printf("Can't create database for %s: %s\n",
				map->map_file, errstring(errno));
		if (!automatic)
			syserr("Cannot create database for alias file %s",
				map->map_file);
	}

	/* close the file, thus releasing locks */
	xfclose(af, "rebuildaliases2", map->map_file);

	/* add distinguished entries and close the database */
	if (bitset(MF_OPEN, map->map_mflags))
	{
		map->map_class->map_close(map);
		map->map_mflags &= ~(MF_OPEN|MF_WRITABLE);
	}

	/* restore the old signals */
	(void) setsignal(SIGINT, oldsigint);
	(void) setsignal(SIGQUIT, oldsigquit);
#ifdef SIGTSTP
	(void) setsignal(SIGTSTP, oldsigtstp);
#endif
	return success;
}
/*
**  READALIASES -- read and process the alias file.
**
**	This routine implements the part of initaliases that occurs
**	when we are not going to use the DBM stuff.
**
**	Parameters:
**		map -- the alias database descriptor.
**		af -- file to read the aliases from.
**		announcestats -- anounce statistics regarding number of
**			aliases, longest alias, etc.
**		logstats -- lot the same info.
**
**	Returns:
**		none.
**
**	Side Effects:
**		Reads aliasfile into the symbol table.
**		Optionally, builds the .dir & .pag files.
*/

void
readaliases(map, af, announcestats, logstats)
	register MAP *map;
	FILE *af;
	bool announcestats;
	bool logstats;
{
	register char *p;
	char *rhs;
	bool skipping;
	long naliases, bytes, longest;
	ADDRESS al, bl;
	char line[BUFSIZ];

	/*
	**  Read and interpret lines
	*/

	FileName = map->map_file;
	LineNumber = 0;
	naliases = bytes = longest = 0;
	skipping = FALSE;
	while (fgets(line, sizeof (line), af) != NULL)
	{
		int lhssize, rhssize;
		int c;

		LineNumber++;
		p = strchr(line, '\n');
#if _FFR_BACKSLASH_IN_ALIASES
		while (p != NULL && p > line && p[-1] == '\\')
		{
			p--;
			if (fgets(p, SPACELEFT(line, p), af) == NULL)
				break;
			LineNumber++;
			p = strchr(p, '\n');
		}
#endif
		if (p != NULL)
			*p = '\0';
		else if (!feof(af))
		{
			syserr("554 alias line too long");

			/* flush to end of line */
			while ((c = getc(af)) != EOF && c != '\n')
				continue;

			/* skip any continuation lines */
			skipping = TRUE;
			continue;
		}
		switch (line[0])
		{
		  case '#':
		  case '\0':
			skipping = FALSE;
			continue;

		  case ' ':
		  case '\t':
			if (!skipping)
				syserr("554 Non-continuation line starts with space");
			skipping = TRUE;
			continue;
		}
		skipping = FALSE;

		/*
		**  Process the LHS
		**	Find the colon separator, and parse the address.
		**	It should resolve to a local name -- this will
		**	be checked later (we want to optionally do
		**	parsing of the RHS first to maximize error
		**	detection).
		*/

		for (p = line; *p != '\0' && *p != ':' && *p != '\n'; p++)
			continue;
		if (*p++ != ':')
		{
			syserr("554 missing colon");
			continue;
		}
		if (parseaddr(line, &al, RF_COPYALL, ':', NULL, CurEnv) == NULL)
		{
			syserr("554 %.40s... illegal alias name", line);
			continue;
		}

		/*
		**  Process the RHS.
		**	'al' is the internal form of the LHS address.
		**	'p' points to the text of the RHS.
		*/

		while (isascii(*p) && isspace(*p))
			p++;
		rhs = p;
		for (;;)
		{
			register char *nlp;

			nlp = &p[strlen(p)];
			if (nlp[-1] == '\n')
				*--nlp = '\0';

			if (CheckAliases)
			{
				/* do parsing & compression of addresses */
				while (*p != '\0')
				{
					auto char *delimptr;

					while ((isascii(*p) && isspace(*p)) ||
								*p == ',')
						p++;
					if (*p == '\0')
						break;
					if (parseaddr(p, &bl, RF_COPYNONE, ',',
						      &delimptr, CurEnv) == NULL)
						usrerr("553 %s... bad address", p);
					p = delimptr;
				}
			}
			else
			{
				p = nlp;
			}

			/* see if there should be a continuation line */
			c = getc(af);
			if (!feof(af))
				(void) ungetc(c, af);
			if (c != ' ' && c != '\t')
				break;

			/* read continuation line */
			if (fgets(p, sizeof line - (p - line), af) == NULL)
				break;
			LineNumber++;

			/* check for line overflow */
			if (strchr(p, '\n') == NULL && !feof(af))
			{
				usrerr("554 alias too long");
				while ((c = fgetc(af)) != EOF && c != '\n')
					continue;
				skipping = TRUE;
				break;
			}
		}

		if (skipping)
			continue;

		if (!bitnset(M_ALIASABLE, al.q_mailer->m_flags))
		{
			syserr("554 %s... cannot alias non-local names",
				al.q_paddr);
			continue;
		}

		/*
		**  Insert alias into symbol table or database file.
		**
		**	Special case pOStmaStER -- always make it lower case.
		*/

		if (strcasecmp(al.q_user, "postmaster") == 0)
			makelower(al.q_user);

		lhssize = strlen(al.q_user);
		rhssize = strlen(rhs);
		map->map_class->map_store(map, al.q_user, rhs);

		if (al.q_paddr != NULL)
			free(al.q_paddr);
		if (al.q_host != NULL)
			free(al.q_host);
		if (al.q_user != NULL)
			free(al.q_user);

		/* statistics */
		naliases++;
		bytes += lhssize + rhssize;
		if (rhssize > longest)
			longest = rhssize;
	}

	CurEnv->e_to = NULL;
	FileName = NULL;
	if (Verbose || announcestats)
		message("%s: %d aliases, longest %d bytes, %d bytes total",
			map->map_file, naliases, longest, bytes);
	if (LogLevel > 7 && logstats)
		sm_syslog(LOG_INFO, NOQID,
			"%s: %d aliases, longest %d bytes, %d bytes total",
			map->map_file, naliases, longest, bytes);
}
/*
**  FORWARD -- Try to forward mail
**
**	This is similar but not identical to aliasing.
**
**	Parameters:
**		user -- the name of the user who's mail we would like
**			to forward to.  It must have been verified --
**			i.e., the q_home field must have been filled
**			in.
**		sendq -- a pointer to the head of the send queue to
**			put this user's aliases in.
**		aliaslevel -- the current alias nesting depth.
**		e -- the current envelope.
**
**	Returns:
**		none.
**
**	Side Effects:
**		New names are added to send queues.
*/

void
forward(user, sendq, aliaslevel, e)
	ADDRESS *user;
	ADDRESS **sendq;
	int aliaslevel;
	register ENVELOPE *e;
{
	char *pp;
	char *ep;
	bool got_transient;

	if (tTd(27, 1))
		printf("forward(%s)\n", user->q_paddr);

	if (!bitnset(M_HASPWENT, user->q_mailer->m_flags) ||
	    bitset(QBADADDR, user->q_flags))
		return;
	if (user->q_home == NULL)
	{
		syserr("554 forward: no home");
		user->q_home = "/no/such/directory";
	}

	/* good address -- look for .forward file in home */
	define('z', user->q_home, e);
	define('u', user->q_user, e);
	define('h', user->q_host, e);
	if (ForwardPath == NULL)
		ForwardPath = newstr("\201z/.forward");

	got_transient = FALSE;
	for (pp = ForwardPath; pp != NULL; pp = ep)
	{
		int err;
		char buf[MAXPATHLEN+1];

		ep = strchr(pp, ':');
		if (ep != NULL)
			*ep = '\0';
		expand(pp, buf, sizeof buf, e);
		if (ep != NULL)
			*ep++ = ':';
		if (buf[0] == '\0')
			continue;
		if (tTd(27, 3))
			printf("forward: trying %s\n", buf);

		err = include(buf, TRUE, user, sendq, aliaslevel, e);
		if (err == 0)
			break;
		else if (transienterror(err))
		{
			/* we may have to suspend this message */
			got_transient = TRUE;
			if (tTd(27, 2))
				printf("forward: transient error on %s\n", buf);
			if (LogLevel > 2)
				sm_syslog(LOG_ERR, e->e_id,
					"forward %s: transient error: %s",
					buf, errstring(err));
		}
		else
		{
			switch (err)
			{
			  case ENOENT:
				break;

#if _FFR_FORWARD_SYSERR
			  case E_SM_NOSLINK:
			  case E_SM_NOHLINK:
			  case E_SM_REGONLY:
			  case E_SM_ISEXEC:
			  case E_SM_WWDIR:
			  case E_SM_GWDIR:
			  case E_SM_WWFILE:
			  case E_SM_GWFILE:
				syserr("forward: %s: %s", buf, errstring(err));
				break;
#endif

			  default:
				if (LogLevel > (RunAsUid == 0 ? 2 : 10))
					sm_syslog(LOG_WARNING, e->e_id,
						"forward %s: %s", buf,
						errstring(err));
				if (Verbose)
					message("forward: %s: %s",
						buf,
						errstring(err));
				break;
			}
		}
	}
	if (pp == NULL && got_transient)
	{
		/*
		**  There was no successful .forward open and at least one
		**  transient open.  We have to defer this address for
		**  further delivery.
		*/

		message("transient .forward open error: message queued");
		user->q_flags |= QQUEUEUP;
		return;
	}
}
@


1.8
log
@sendmail 8.9.2
@
text
@@


1.7
log
@something hosed the sendmail import; fix up by hand
@
text
@d16 1
a16 1
static char sccsid[] = "@@(#)alias.c	8.92 (Berkeley) 6/5/98";
d385 1
a385 1
		     (geteuid() == 0 && stb.st_uid == TrustedFileUid)))
d513 1
@


1.6
log
@Sendmail 8.8.6.
@
text
@d2 7
a8 1
 * Copyright (c) 1983, 1995-1997 Eric P. Allman
a10 28
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
d16 1
a16 1
static char sccsid[] = "@@(#)alias.c	8.73 (Berkeley) 5/8/97";
d58 1
a58 1
	extern char *aliaslookup();
d85 1
a85 1
			e->e_message = "alias database unavailable";
d104 1
a104 1
	message("aliased to %s", shortenstring(p, 203));
d108 1
a108 1
			a->q_paddr, shortenstring(p, 203));
d218 1
a218 1
		while (isspace(*p))
d383 3
a385 1
		if (AutoRebuild && stb.st_ino != 0 && stb.st_uid == geteuid())
d397 1
a397 1
			rebuildaliases(map, TRUE);
d421 1
a421 1
**		none.
d428 1
a428 1
void
d435 2
a436 1
	int sff = SFF_OPENASROOT|SFF_REGONLY|SFF_NOLOCK|SFF_NOWLINK|SFF_NOWFILES;
d443 8
a450 1
		return;
d469 1
a469 1
			return;
d494 1
a494 1
		return;
d514 1
d542 1
d600 1
d848 32
@


1.5
log
@Sendmail 8.8.5.
@
text
@d2 1
a2 1
 * Copyright (c) 1983, 1995, 1996 Eric P. Allman
d38 1
a38 1
static char sccsid[] = "@@(#)alias.c	8.67 (Berkeley) 1/18/97";
a76 1
	int naliases;
a126 1
#ifdef LOG
d128 2
a129 2
		syslog(LOG_INFO, "%s: alias %.100s => %s",
			e->e_id == NULL ? "NOQUEUE" : e->e_id,
a130 1
#endif
d138 1
a138 1
	naliases = sendtolist(p, a, sendq, aliaslevel + 1, e);
d279 1
a279 1
			map->map_mflags = MF_OPTIONAL|MF_INCLNULL;
a422 1
#ifdef LOG
d424 2
a425 1
				syslog(LOG_INFO, "alias database %s out of date",
a426 1
#endif /* LOG */
d455 1
d465 1
a465 1
	if ((af = fopen(map->map_file, "r+")) == NULL)
d470 1
a470 1
		    (af = fopen(map->map_file, "r")) == NULL)
a516 1
#ifdef LOG
d519 2
a520 1
			syslog(LOG_NOTICE, "alias database %s %srebuilt by %s",
a523 1
#endif /* LOG */
d604 9
a769 1
# ifdef LOG
d771 2
a772 1
		syslog(LOG_INFO, "%s: %d aliases, longest %d bytes, %d bytes total",
a773 1
# endif /* LOG */
a852 1
#ifdef LOG
d854 2
a855 2
				syslog(LOG_ERR, "%s: forward %s: transient error: %s",
					e->e_id == NULL ? "NOQUEUE" : e->e_id,
a856 1
#endif
@


1.4
log
@Update to Sendmail 8.8.4, plus recent patches, plus OpenBSD support.
Also include entire example configuration subset.
Includes smrsh (using /usr/libexec/sm.bin).

Of the top of my head, the only things I removed from the distribution were
contrib/mail.local.linux, src/Makefiles, all the *.0 and *.ps files.
Our praliases man page replaces the distributed one, ours is better.
@
text
@d38 1
a38 1
static char sccsid[] = "@@(#)alias.c	8.66 (Berkeley) 9/20/96";
d604 1
d610 12
a670 1
			register char c;
d713 1
a713 1
			if (strchr(p, '\n') == NULL)
d716 3
d722 4
@


1.3
log
@bring up to 8.7.6
@
text
@d2 1
a2 1
 * Copyright (c) 1983, 1995 Eric P. Allman
d38 1
a38 1
static char sccsid[] = "@@(#)alias.c	8.52.1.3 (Berkeley) 9/16/96";
a154 2
	if (!bitnset(M_USR_UPPER, a->q_mailer->m_flags))
		makelower(obuf);
d208 5
d298 1
a298 2
			if (tTd(27, 1))
				printf("Unknown alias class %s\n", class);
d499 1
a499 1
		message("Alias file %s is already being rebuilt",
d715 3
a717 1
		**  Insert alias into symbol table or DBM file
d720 1
a720 1
		if (!bitnset(M_USR_UPPER, al.q_mailer->m_flags))
d783 1
d794 1
a794 1
		user->q_home = "/nosuchdirectory";
d804 1
a808 1
		extern int include();
d816 2
d826 2
a827 1
			/* we have to suspend this message */
a835 3
			message("%s: %s: message queued", buf, errstring(err));
			user->q_flags |= QQUEUEUP;
			return;
d837 12
@


1.2
log
@Sendmail 8.7.3 from NetBSD
@
text
@d38 1
a38 1
static char sccsid[] = "@@(#)alias.c	8.52 (Berkeley) 10/28/95";
d80 1
a80 1
	char obuf[MAXNAME + 6];
d150 2
a151 1
	if (strncmp(a->q_user, "owner-", 6) == 0)
d262 1
a262 1
		(void) sprintf(buf, "Alias%d", NAliasFileMaps);
d401 2
a402 3
	(void) strcpy(buf, map->map_file);
	if (ext != NULL)
		(void) strcat(buf, ext);
a509 2
	/* avoid denial-of-service attacks */
	resetlimits();
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
 * Copyright (c) 1983 Eric P. Allman
a35 1
# include <pwd.h>
d38 1
a38 1
static char sccsid[] = "@@(#)alias.c	8.25 (Berkeley) 4/14/94";
d42 2
a43 2
MAP	*AliasDB[MAXALIASDB + 1];	/* actual database list */
int	NAliasDBs;			/* number of alias databases */
d55 1
d69 2
a70 1
alias(a, sendq, e)
d73 1
d79 1
d84 1
a84 1
		printf("alias(%s)\n", a->q_paddr);
d96 5
a100 1
	**  Look up this name
d103 8
a110 1
	p = aliaslookup(a->q_user, e);
a124 1
		e->e_nrcpts++;
d127 1
a127 1
	message("aliased to %s", p);
d130 1
a130 1
		syslog(LOG_INFO, "%s: alias %s => %s",
d132 1
a132 1
			a->q_paddr, p);
d135 1
a135 4
	AliasLevel++;
	naliases = sendtolist(p, a, sendq, e);
	AliasLevel--;
	if (!bitset(QSELFREF, a->q_flags))
d137 2
a138 6
		if (tTd(27, 5))
		{
			printf("alias: QDONTSEND ");
			printaddr(a, FALSE);
		}
		a->q_flags |= QDONTSEND;
d140 4
d156 1
a156 1
	owner = aliaslookup(obuf, e);
a166 1
	{
d169 2
a170 2
		e->e_flags |= EF_SENDRECEIPT;
	}
d177 2
d192 1
a192 1
aliaslookup(name, e)
d194 1
d197 1
a197 3
	register int dbno;
	register MAP *map;
	register char *p;
d199 1
a199 1
	for (dbno = 0; dbno < NAliasDBs; dbno++)
d201 1
a201 1
		auto int stat;
d203 3
a205 6
		map = AliasDB[dbno];
		if (!bitset(MF_OPEN, map->map_mflags))
			continue;
		p = (*map->map_class->map_lookup)(map, name, NULL, &stat);
		if (p != NULL)
			return p;
d207 3
a209 1
	return NULL;
d223 1
d237 1
a237 1
		char aname[50];
d245 1
a245 1
		if (NAliasDBs >= MAXALIASDB)
d247 2
a248 1
			syserr("Too many alias databases defined, %d max", MAXALIASDB);
d251 12
a262 2
		(void) sprintf(aname, "Alias%d", NAliasDBs);
		s = stab(aname, ST_MAP, ST_ENTER);
a263 1
		AliasDB[NAliasDBs] = map;
d265 1
d287 3
d308 1
a308 1
				NAliasDBs++;
d340 1
a340 1
	char buf[MAXNAME];
d375 1
d408 2
d411 2
d414 1
d416 2
d420 1
d450 1
d457 4
a460 1
	sigfunc_t oldsigint;
d468 2
d478 1
a478 1
			if (!automatic)
d485 5
a489 2
		message("warning: cannot lock %s: %s",
			map->map_file, errstring(errno));
d510 2
d513 4
d529 1
a529 1
		readaliases(map, af, automatic);
d546 1
d548 2
d551 1
a551 1
	/* restore the old signal */
d553 4
d567 3
a569 1
**		automatic -- set if this was an automatic rebuild.
d579 2
a580 1
readaliases(map, af, automatic)
d583 2
a584 1
	int automatic;
d689 1
a689 1
			c = fgetc(af);
d707 1
a707 1
		if (al.q_mailer != LocalMailer)
d741 1
a741 1
	if (Verbose || !automatic)
d745 1
a745 1
	if (LogLevel > 7)
d762 2
d772 2
a773 1
forward(user, sendq, e)
d776 1
d785 2
a786 1
	if (user->q_mailer != LocalMailer || bitset(QBADADDR, user->q_flags))
d805 1
d810 1
a810 1
		expand(pp, buf, &buf[sizeof buf - 1], e);
d816 1
a816 1
		err = include(buf, TRUE, user, sendq, e);
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@


1.1.1.2
log
@sendmail 8.9.1
@
text
@d2 3
a4 2
 * Copyright (c) 1998 Sendmail, Inc.  All rights reserved.
 * Copyright (c) 1983, 1995-1997 Eric P. Allman.  All rights reserved.
d6 15
a20 3
 * By using this file, you agree to the terms and conditions set
 * forth in the LICENSE file which can be found at the top level of
 * the sendmail distribution.
d22 11
a32 2
 * Copyright (c) 1988, 1993
 *	The Regents of the University of California.  All rights reserved.
d36 1
d39 1
a39 1
static char sccsid[] = "@@(#)alias.c	8.92 (Berkeley) 6/5/98";
d43 2
a44 2
MAP	*AliasFileMap = NULL;	/* the actual aliases.files map */
int	NAliasFileMaps;		/* the number of entries in AliasFileMap */
a55 1
**		aliaslevel -- the current alias nesting depth.
d69 1
a69 2
void
alias(a, sendq, aliaslevel, e)
a71 1
	int aliaslevel;
d75 1
d77 2
a78 3
	auto int stat = EX_OK;
	char obuf[MAXNAME + 7];
	extern char *aliaslookup __P((char *, int *, ENVELOPE *));
d81 1
a81 1
		printf("alias(%s)\n", a->q_user);
d93 1
a93 5
	**  Look up this name.
	**
	**	If the map was unavailable, we will queue this message
	**	until the map becomes available; otherwise, we could
	**	bounce messages inappropriately.
d96 1
a96 8
	p = aliaslookup(a->q_user, &stat, e);
	if (stat == EX_TEMPFAIL || stat == EX_UNAVAILABLE)
	{
		a->q_flags |= QQUEUEUP;
		if (e->e_message == NULL)
			e->e_message = newstr("alias database unavailable");
		return;
	}
d111 1
d114 2
a115 1
	message("aliased to %s", shortenstring(p, MAXSHORTSTR));
d117 4
a120 3
		sm_syslog(LOG_INFO, e->e_id,
			"alias %.100s => %s",
			a->q_paddr, shortenstring(p, MAXSHORTSTR));
d122 4
a125 1
	if (tTd(27, 5))
d127 6
a132 2
		printf("alias: QDONTSEND ");
		printaddr(a, FALSE);
a133 4
	a->q_flags |= QDONTSEND;
	(void) sendtolist(p, a, sendq, aliaslevel + 1, e);
	if (bitset(QSELFREF, a->q_flags))
		a->q_flags &= ~QDONTSEND;
d140 1
a140 2
	if (strncmp(a->q_user, "owner-", 6) == 0 ||
	    strlen(a->q_user) > (SIZE_T) sizeof obuf - 7)
d144 3
a146 1
	owner = aliaslookup(obuf, &stat, e);
d157 1
d160 2
a161 2
	e->e_flags |= EF_SENDRECEIPT;
	a->q_flags |= QDELIVERED|QEXPANDED;
a167 2
**		pstat -- a pointer to a place to put the status.
**		e -- the current envelope.
d181 1
a181 1
aliaslookup(name, pstat, e)
a182 1
	int *pstat;
d185 3
a187 1
	static MAP *map = NULL;
d189 1
a189 1
	if (map == NULL)
d191 1
a191 1
		STAB *s = stab("aliases", ST_MAP, ST_FIND);
d193 6
a198 3
		if (s == NULL)
			return NULL;
		map = &s->s_map;
d200 1
a200 8
	if (!bitset(MF_OPEN, map->map_mflags))
		return NULL;

	/* special case POstMastER -- always use lower case */
	if (strcasecmp(name, "postmaster") == 0)
		name = "postmaster";

	return (*map->map_class->map_lookup)(map, name, NULL, pstat);
a213 1
void
d227 1
a227 1
		char buf[50];
d229 1
a229 1
		while (isascii(*p) && isspace(*p))
d235 1
a235 1
		if (NAliasFileMaps >= MAXMAPSTACK)
d237 1
a237 2
			syserr("Too many alias databases defined, %d max",
				MAXMAPSTACK);
d240 2
a241 12
		if (AliasFileMap == NULL)
		{
			strcpy(buf, "aliases.files sequence");
			AliasFileMap = makemapentry(buf);
			if (AliasFileMap == NULL)
			{
				syserr("setalias: cannot create aliases.files map");
				return;
			}
		}
		(void) snprintf(buf, sizeof buf, "Alias%d", NAliasFileMaps);
		s = stab(buf, ST_MAP, ST_ENTER);
d243 1
a244 1
		map->map_mname = s->s_name;
d257 1
a257 1
			map->map_mflags = MF_INCLNULL;
a265 3
		if (tTd(27, 20))
			printf("  map %s:%s %s\n", class, s->s_name, spec);

d270 2
a271 1
			syserr("setalias: unknown alias class %s", class);
d284 1
a284 1
				AliasFileMap->map_stack[NAliasFileMaps++] = map;
d316 1
a316 1
	char buf[MAXNAME + 1];
a350 1
			map->map_mflags &= ~(MF_OPEN|MF_WRITABLE);
d375 3
a377 2
	snprintf(buf, sizeof buf, "%s%s",
		map->map_file, ext == NULL ? "" : ext);
d381 1
a381 3
		if (AutoRebuild && stb.st_ino != 0 &&
		    (stb.st_uid == geteuid() ||
		     (geteuid() == 0 && stb.st_uid == TrustedFileUid)))
a382 2
			bool oldSuprErrs;

a383 2
			oldSuprErrs = SuprErrs;
			SuprErrs = TRUE;
a384 1
			{
d386 1
a386 3
				map->map_mflags &= ~(MF_OPEN|MF_WRITABLE);
			}
			(void) rebuildaliases(map, TRUE);
a387 1
			SuprErrs = oldSuprErrs;
d391 1
d393 1
a393 2
				sm_syslog(LOG_INFO, NOQID,
					"alias database %s out of date",
d395 1
d410 1
a410 1
**		TRUE if successful; FALSE otherwise.
a416 1
bool
d423 1
a423 6
	bool success = FALSE;
	int sff = SFF_OPENASROOT|SFF_REGONLY|SFF_NOLOCK;	
	sigfunc_t oldsigint, oldsigquit;
#ifdef SIGTSTP
	sigfunc_t oldsigtstp;
#endif
d426 1
a426 8
		return FALSE;

	if (!bitset(DBS_LINKEDALIASFILEINWRITABLEDIR, DontBlameSendmail))
		sff |= SFF_NOWLINK;
	if (!bitset(DBS_GROUPWRITABLEALIASFILE, DontBlameSendmail))
		sff |= SFF_NOGWFILES;
	if (!bitset(DBS_WORLDWRITABLEALIASFILE, DontBlameSendmail))
		sff |= SFF_NOWWFILES;
d429 1
a429 1
	if ((af = safefopen(map->map_file, O_RDWR, 0, sff)) == NULL)
a430 2
		struct stat stb;

d432 1
a432 1
		    (af = safefopen(map->map_file, O_RDONLY, 0, sff)) == NULL)
d439 1
a439 1
			if (!automatic && !bitset(MF_OPTIONAL, map->map_mflags))
d443 1
a443 1
			return FALSE;
d446 2
a447 5
		if (tTd(27, 1) ||
		    fstat(fileno(af), &stb) < 0 ||
		    bitset(S_IWUSR|S_IWGRP|S_IWOTH, stb.st_mode))
			message("warning: cannot lock %s: %s",
				map->map_file, errstring(errno));
d455 1
a455 1
		message("Alias file %s is locked (maybe being rebuilt)",
d465 1
a465 1
		return FALSE;
a468 4
	oldsigquit = setsignal(SIGQUIT, SIG_IGN);
#ifdef SIGTSTP
	oldsigtstp = setsignal(SIGTSTP, SIG_IGN);
#endif
d472 1
d475 1
a475 2
			sm_syslog(LOG_NOTICE, NOQID,
				"alias database %s %srebuilt by %s",
d479 1
d481 1
a481 2
		readaliases(map, af, !automatic, TRUE);
		success = TRUE;
a497 1
	{
a498 2
		map->map_mflags &= ~(MF_OPEN|MF_WRITABLE);
	}
d500 1
a500 1
	/* restore the old signals */
a501 5
	(void) setsignal(SIGQUIT, oldsigquit);
#ifdef SIGTSTP
	(void) setsignal(SIGTSTP, oldsigtstp);
#endif
	return success;
d512 1
a512 3
**		announcestats -- anounce statistics regarding number of
**			aliases, longest alias, etc.
**		logstats -- lot the same info.
d522 1
a522 2
void
readaliases(map, af, announcestats, logstats)
d525 1
a525 2
	bool announcestats;
	bool logstats;
a544 1
		int c;
a547 10
#if _FFR_BACKSLASH_IN_ALIASES
		while (p != NULL && p > line && p[-1] == '\\')
		{
			p--;
			if (fgets(p, SPACELEFT(line, p), af) == NULL)
				break;
			LineNumber++;
			p = strchr(p, '\n');
		}
#endif
a549 12
		else if (!feof(af))
		{
			syserr("554 alias line too long");

			/* flush to end of line */
			while ((c = getc(af)) != EOF && c != '\n')
				continue;

			/* skip any continuation lines */
			skipping = TRUE;
			continue;
		}
d599 1
d630 1
a630 1
			c = getc(af);
d642 1
a642 1
			if (strchr(p, '\n') == NULL && !feof(af))
a644 3
				while ((c = fgetc(af)) != EOF && c != '\n')
					continue;
				skipping = TRUE;
d648 1
a648 5

		if (skipping)
			continue;

		if (!bitnset(M_ALIASABLE, al.q_mailer->m_flags))
d656 1
a656 3
		**  Insert alias into symbol table or database file.
		**
		**	Special case pOStmaStER -- always make it lower case.
d659 1
a659 1
		if (strcasecmp(al.q_user, "postmaster") == 0)
d682 1
a682 1
	if (Verbose || announcestats)
d685 3
a687 3
	if (LogLevel > 7 && logstats)
		sm_syslog(LOG_INFO, NOQID,
			"%s: %d aliases, longest %d bytes, %d bytes total",
d689 1
a702 2
**		aliaslevel -- the current alias nesting depth.
**		e -- the current envelope.
d711 1
a711 2
void
forward(user, sendq, aliaslevel, e)
a713 1
	int aliaslevel;
a717 1
	bool got_transient;
d722 1
a722 2
	if (!bitnset(M_HASPWENT, user->q_mailer->m_flags) ||
	    bitset(QBADADDR, user->q_flags))
d727 1
a727 1
		user->q_home = "/no/such/directory";
a736 1
	got_transient = FALSE;
d745 1
a745 1
		expand(pp, buf, sizeof buf, e);
a747 2
		if (buf[0] == '\0')
			continue;
d751 1
a751 1
		err = include(buf, TRUE, user, sendq, aliaslevel, e);
d756 1
a756 2
			/* we may have to suspend this message */
			got_transient = TRUE;
d759 1
d761 2
a762 2
				sm_syslog(LOG_ERR, e->e_id,
					"forward %s: transient error: %s",
a763 19
		}
		else
		{
			switch (err)
			{
			  case ENOENT:
				break;

#if _FFR_FORWARD_SYSERR
			  case E_SM_NOSLINK:
			  case E_SM_NOHLINK:
			  case E_SM_REGONLY:
			  case E_SM_ISEXEC:
			  case E_SM_WWDIR:
			  case E_SM_GWDIR:
			  case E_SM_WWFILE:
			  case E_SM_GWFILE:
				syserr("forward: %s: %s", buf, errstring(err));
				break;
d765 3
a767 12

			  default:
				if (LogLevel > (RunAsUid == 0 ? 2 : 10))
					sm_syslog(LOG_WARNING, e->e_id,
						"forward %s: %s", buf,
						errstring(err));
				if (Verbose)
					message("forward: %s: %s",
						buf,
						errstring(err));
				break;
			}
a768 12
	}
	if (pp == NULL && got_transient)
	{
		/*
		**  There was no successful .forward open and at least one
		**  transient open.  We have to defer this address for
		**  further delivery.
		*/

		message("transient .forward open error: message queued");
		user->q_flags |= QQUEUEUP;
		return;
@

