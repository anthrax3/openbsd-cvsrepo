head	1.28;
access;
symbols
	OPENBSD_2_9_BASE:1.27
	OPENBSD_2_9:1.27.0.2
	OPENBSD_2_8:1.24.0.2
	OPENBSD_2_8_BASE:1.24
	OPENBSD_2_7:1.23.0.2
	OPENBSD_2_7_BASE:1.23
	OPENBSD_2_6:1.18.0.4
	OPENBSD_2_6_BASE:1.18
	OPENBSD_2_5:1.18.0.2
	OPENBSD_2_5_BASE:1.18
	OPENBSD_2_4:1.14.0.2
	OPENBSD_2_4_BASE:1.14
	OPENBSD_2_3:1.12.0.2
	OPENBSD_2_3_BASE:1.12
	OPENBSD_2_2:1.10.0.2
	OPENBSD_2_2_BASE:1.10
	OPENBSD_2_1:1.7.0.2
	OPENBSD_2_1_BASE:1.7
	OPENBSD_2_0:1.6.0.2
	OPENBSD_2_0_BASE:1.6;
locks; strict;
comment	@ * @;


1.28
date	2001.05.30.02.14.07;	author deraadt;	state dead;
branches;
next	1.27;

1.27
date	2001.01.30.04.29.53;	author kjell;	state Exp;
branches;
next	1.26;

1.26
date	2001.01.17.07.26.59;	author fgsch;	state Exp;
branches;
next	1.25;

1.25
date	2001.01.17.05.01.02;	author fgsch;	state Exp;
branches;
next	1.24;

1.24
date	2000.08.10.05.50.27;	author kjell;	state Exp;
branches;
next	1.23;

1.23
date	2000.03.13.23.40.20;	author kjell;	state Exp;
branches;
next	1.22;

1.22
date	2000.02.16.22.34.23;	author kjell;	state Exp;
branches;
next	1.21;

1.21
date	2000.02.01.19.30.01;	author kjell;	state Exp;
branches;
next	1.20;

1.20
date	99.12.15.05.20.25;	author kjell;	state Exp;
branches;
next	1.19;

1.19
date	99.11.25.23.16.20;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	99.02.05.05.58.48;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	98.11.13.00.04.01;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	98.11.10.22.04.11;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	98.10.29.02.15.21;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	98.09.17.03.43.45;	author pattonme;	state Exp;
branches;
next	1.13;

1.13
date	98.09.15.10.01.39;	author pattonme;	state Exp;
branches;
next	1.12;

1.12
date	98.03.30.06.59.49;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	98.01.26.04.16.47;	author dgregor;	state Exp;
branches;
next	1.10;

1.10
date	97.07.22.17.00.05;	author kstailey;	state Exp;
branches;
next	1.9;

1.9
date	97.06.23.16.53.59;	author kstailey;	state Exp;
branches;
next	1.8;

1.8
date	97.06.09.09.52.33;	author niklas;	state Exp;
branches;
next	1.7;

1.7
date	97.02.11.22.24.10;	author kstailey;	state Exp;
branches;
next	1.6;

1.6
date	96.10.08.07.33.38;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	96.09.30.17.52.41;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.07.18.04.58.47;	author dm;	state Exp;
branches;
next	1.3;

1.3
date	96.05.10.21.40.00;	author dm;	state Exp;
branches;
next	1.2;

1.2
date	96.01.25.05.41.38;	author dm;	state Exp;
branches;
next	1.1;

1.1
date	96.01.07.02.34.32;	author dm;	state Exp;
branches;
next	;


desc
@@


1.28
log
@Remove ipf.  Darren Reed has interpreted his (old, new, whichever)
licence in a way that makes ipf not free according to the rules we
established over 5 years ago, at www.openbsd.org/goals.html (and those
same basic rules govern the other *BSD projects too).  Specifically,
Darren says that modified versions are not permitted.  But software
which OpenBSD uses and redistributes must be free to all (be they
people or companies), for any purpose they wish to use it, including
modification, use, peeing on, or even integration into baby mulching
machines or atomic bombs to be dropped on Australia.  Furthermore, we
know of a number of companies using ipf with modification like us, who
are now in the same situation, and we hope that some of them will work
with us to fill this gap that now exists in OpenBSD (temporarily, we
hope).
@
text
@/*	$OpenBSD: ipmon.c,v 1.27 2001/01/30 04:29:53 kjell Exp $	*/

/*
 * Copyright (C) 1993-2000 by Darren Reed.
 *
 * Redistribution and use in source and binary forms are permitted
 * provided that this notice is preserved and due credit is given
 * to the original author and the contributors.
 */
#if !defined(lint)
static const char sccsid[] = "@@(#)ipmon.c	1.21 6/5/96 (C)1993-2000 Darren Reed";
static const char rcsid[] = "@@(#)$IPFilter: ipmon.c,v 2.12.2.8 2001/01/10 06:18:08 darrenr Exp $";
#endif

#ifndef SOLARIS
#define SOLARIS (defined(__SVR4) || defined(__svr4__)) && defined(sun)
#endif

#include <sys/types.h>
#include <sys/stat.h>
#include <sys/param.h>
#include <sys/file.h>
#include <sys/time.h>
#include <sys/socket.h>
#include <sys/ioctl.h>

#include <stdio.h>
#include <unistd.h>
#include <string.h>
#include <fcntl.h>
#include <errno.h>
#if !defined(__SVR4) && !defined(__svr4__)
# if (__FreeBSD_version >= 300000)
#  include <sys/dirent.h>
# else
#  include <sys/dir.h>
# endif
#else
# include <sys/filio.h>
# include <sys/byteorder.h>
#endif
#include <strings.h>
#include <signal.h>
#include <stdlib.h>
#include <stddef.h>
#include <netinet/in.h>
#include <netinet/in_systm.h>
#include <net/if.h>
#include <netinet/ip.h>
#include <netinet/tcp_fsm.h>
#include <netdb.h>
#include <arpa/inet.h>
#include <arpa/nameser.h>
#include <resolv.h>

#include <sys/uio.h>
#ifndef linux
# include <sys/protosw.h>
# include <netinet/ip_var.h>
#endif

#include <netinet/tcp.h>
#include <netinet/ip_icmp.h>

#include <ctype.h>
#include <syslog.h>

#include <netinet/ip_fil_compat.h>
#include <netinet/tcpip.h>
#include <netinet/ip_fil.h>
#include <netinet/ip_proxy.h>
#include <netinet/ip_nat.h>
#include <netinet/ip_state.h>


#if	defined(sun) && !defined(SOLARIS2)
#define	STRERROR(x)	sys_errlist[x]
extern	char	*sys_errlist[];
#else
#define	STRERROR(x)	strerror(x)
#endif


struct	flags {
	int	value;
	char	flag;
};

struct	flags	tcpfl[] = {
	{ TH_ACK, 'A' },
	{ TH_RST, 'R' },
	{ TH_SYN, 'S' },
	{ TH_FIN, 'F' },
	{ TH_URG, 'U' },
	{ TH_PUSH,'P' },
	{ TH_ECN, 'E' },
	{ TH_CWR, 'C' },
	{ 0, '\0' }
};

#if SOLARIS
static	char	*pidfile = "/etc/opt/ipf/ipmon.pid";
#else
# if BSD >= 199306
static	char	*pidfile = "/var/run/ipmon.pid";
# else
static	char	*pidfile = "/etc/ipmon.pid";
# endif
#endif

static	char	line[2048];
static	int	opts = 0;
static	FILE	*newlog = NULL;
static	char	*logfile = NULL;
static	int	donehup = 0;
static	void	usage __P((char *));
static	void	handlehup __P((int));
static	void	flushlogs __P((char *, FILE *));
static	void	print_log __P((int, FILE *, char *, int));
static	void	print_ipflog __P((FILE *, char *, int));
static	void	print_natlog __P((FILE *, char *, int));
static	void	print_statelog __P((FILE *, char *, int));
static	void	dumphex __P((FILE *, u_char *, int));
static	int	read_log __P((int, int *, char *, int));
static	void	write_pid __P((char *));

char	*hostname __P((int, int, u_32_t *));
char	*portname __P((int, char *, u_int));
int	main __P((int, char *[]));

static	void	logopts __P((int, char *));
static	void	init_tabs __P((void));
static	char	*getproto __P((u_int));

static	char	**protocols = NULL;
static	char	**udp_ports = NULL;
static	char	**tcp_ports = NULL;


#define	OPT_SYSLOG	0x001
#define	OPT_RESOLVE	0x002
#define	OPT_HEXBODY	0x004
#define	OPT_VERBOSE	0x008
#define	OPT_HEXHDR	0x010
#define	OPT_TAIL	0x020
#define	OPT_NAT		0x080
#define	OPT_STATE	0x100
#define	OPT_FILTER	0x200
#define	OPT_PORTNUM	0x400
#define	OPT_LOGALL	(OPT_NAT|OPT_STATE|OPT_FILTER)
#define	OPT_LOGBODY	0x800

#define	HOSTNAME_V4(a,b)	hostname((a), 4, (u_32_t *)&(b))

#ifndef	LOGFAC
#define	LOGFAC	LOG_LOCAL0
#endif


void handlehup(sig)
int sig;
{
	FILE	*fp;

	signal(SIGHUP, handlehup);
	if (logfile && (fp = fopen(logfile, "a")))
		newlog = fp;
	init_tabs();
	donehup = 1;
}


static void init_tabs()
{
	struct	protoent	*p;
	struct	servent	*s;
	char	*name, **tab;
	int	port;

	if (protocols != NULL) {
		free(protocols);
		protocols = NULL;
	}
	protocols = (char **)malloc(256 * sizeof(*protocols));
	if (protocols != NULL) {
		bzero((char *)protocols, 256 * sizeof(*protocols));

		setprotoent(1);
		while ((p = getprotoent()) != NULL)
			if (p->p_proto >= 0 && p->p_proto <= 255 &&
			    p->p_name != NULL)
				protocols[p->p_proto] = strdup(p->p_name);
		endprotoent();
	}

	if (udp_ports != NULL) {
		free(udp_ports);
		udp_ports = NULL;
	}
	udp_ports = (char **)malloc(65536 * sizeof(*udp_ports));
	if (udp_ports != NULL)
		bzero((char *)udp_ports, 65536 * sizeof(*udp_ports));

	if (tcp_ports != NULL) {
		free(tcp_ports);
		tcp_ports = NULL;
	}
	tcp_ports = (char **)malloc(65536 * sizeof(*tcp_ports));
	if (tcp_ports != NULL)
		bzero((char *)tcp_ports, 65536 * sizeof(*tcp_ports));

	setservent(1);
	while ((s = getservent()) != NULL) {
		if (s->s_proto == NULL)
			continue;
		else if (!strcmp(s->s_proto, "tcp")) {
			port = ntohs(s->s_port);
			name = s->s_name;
			tab = tcp_ports;
		} else if (!strcmp(s->s_proto, "udp")) {
			port = ntohs(s->s_port);
			name = s->s_name;
			tab = udp_ports;
		} else
			continue;
		if ((port < 0 || port > 65535) || (name == NULL))
			continue;
		tab[port] = strdup(name);
	}
	endservent();
}


static char *getproto(p)
u_int p;
{
	static char pnum[4];
	char *s;

	p &= 0xff;
	s = protocols ? protocols[p] : NULL;
	if (s == NULL) {
		sprintf(pnum, "%u", p);
		s = pnum;
	}
	return s;
}


static int read_log(fd, lenp, buf, bufsize)
int fd, bufsize, *lenp;
char *buf;
{
	int	nr;

	nr = read(fd, buf, bufsize);
	if (!nr)
		return 2;
	if ((nr < 0) && (errno != EINTR))
		return -1;
	*lenp = nr;
	return 0;
}


char	*hostname(res, v, ip)
int	res, v;
u_32_t	*ip;
{
#ifdef	USE_INET6
	static char hostbuf[MAXHOSTNAMELEN+1];
#endif
	struct hostent *hp;
	struct in_addr ipa;

	if (v == 4) {
		ipa.s_addr = *ip;
		if (!res)
			return inet_ntoa(ipa);
		hp = gethostbyaddr((char *)ip, sizeof(ip), AF_INET);
		if (!hp)
			return inet_ntoa(ipa);
		return hp->h_name;

	}
#ifdef	USE_INET6
	(void) inet_ntop(AF_INET6, ip, hostbuf, sizeof(hostbuf) - 1);
	hostbuf[MAXHOSTNAMELEN] = '\0';
	return hostbuf;
#else
	return "IPv6";
#endif
}


char	*portname(res, proto, port)
int	res;
char	*proto;
u_int	port;
{
	static	char	pname[8];
	char	*s;

	port = ntohs(port);
	port &= 0xffff;
	(void) sprintf(pname, "%u", port);
	if (!res || (opts & OPT_PORTNUM))
		return pname;
	s = NULL;
	if (!strcmp(proto, "tcp"))
		s = tcp_ports[port];
	else if (!strcmp(proto, "udp"))
		s = udp_ports[port];
	if (s == NULL)
		s = pname;
	return s;
}


static	void	dumphex(log, buf, len)
FILE	*log;
u_char	*buf;
int	len;
{
	char	line[80];
	int	i, j, k;
	u_char	*s = buf, *t = (u_char *)line;

	for (i = len, j = 0; i; i--, j++, s++) {
		if (j && !(j & 0xf)) {
			*t++ = '\n';
			*t = '\0';
			if (!(opts & OPT_SYSLOG))
				fputs(line, log);
			else
				syslog(LOG_INFO, "%s", line);
			t = (u_char *)line;
			*t = '\0';
		}
		sprintf((char *)t, "%02x", *s & 0xff);
		t += 2;
		if (!((j + 1) & 0xf)) {
			s -= 15;
			sprintf((char *)t, "	");
			t += 8;
			for (k = 16; k; k--, s++)
				*t++ = (isprint(*s) ? *s : '.');
			s--;
		}
			
		if ((j + 1) & 0xf)
			*t++ = ' ';;
	}

	if (j & 0xf) {
		for (k = 16 - (j & 0xf); k; k--) {
			*t++ = ' ';
			*t++ = ' ';
			*t++ = ' ';
		}
		sprintf((char *)t, "       ");
		t += 7;
		s -= j & 0xf;
		for (k = j & 0xf; k; k--, s++)
			*t++ = (isprint(*s) ? *s : '.');
		*t++ = '\n';
		*t = '\0';
	}
	if (!(opts & OPT_SYSLOG)) {
		fputs(line, log);
		fflush(log);
	} else
		syslog(LOG_INFO, "%s", line);
}

static	void	print_natlog(log, buf, blen)
FILE	*log;
char	*buf;
int	blen;
{
	struct	natlog	*nl;
	iplog_t	*ipl = (iplog_t *)buf;
	char	*t = line;
	struct	tm	*tm;
	int	res, i, len;
	char	*proto;

	nl = (struct natlog *)((char *)ipl + sizeof(*ipl));
	res = (opts & OPT_RESOLVE) ? 1 : 0;
	tm = localtime((time_t *)&ipl->ipl_sec);
	len = sizeof(line);
	if (!(opts & OPT_SYSLOG)) {
		(void) strftime(t, len, "%d/%m/%Y ", tm);
		i = strlen(t);
		len -= i;
		t += i;
	}
	(void) strftime(t, len, "%T", tm);
	t += strlen(t);
	(void) sprintf(t, ".%-.6ld @@%hd ", ipl->ipl_usec, nl->nl_rule + 1);
	t += strlen(t);

	if (nl->nl_type == NL_NEWMAP)
		strcpy(t, "NAT:MAP ");
	else if (nl->nl_type == NL_NEWRDR)
		strcpy(t, "NAT:RDR ");
	else if (nl->nl_type == NL_EXPIRE)
		strcpy(t, "NAT:EXPIRE ");
	else if (nl->nl_type == NL_FLUSH)
		strcpy(t, "NAT:FLUSH ");
	else if (nl->nl_type == NL_NEWBIMAP)
		strcpy(t, "NAT:BIMAP ");
	else if (nl->nl_type == NL_NEWBLOCK)
		strcpy(t, "NAT:MAPBLOCK ");
	else
		sprintf(t, "Type: %d ", nl->nl_type);
	t += strlen(t);

	proto = getproto(nl->nl_p);

	(void) sprintf(t, "%s,%s <- -> ", HOSTNAME_V4(res, nl->nl_inip),
		portname(res, proto, (u_int)nl->nl_inport));
	t += strlen(t);
	(void) sprintf(t, "%s,%s ", HOSTNAME_V4(res, nl->nl_outip),
		portname(res, proto, (u_int)nl->nl_outport));
	t += strlen(t);
	(void) sprintf(t, "[%s,%s]", HOSTNAME_V4(res, nl->nl_origip),
		portname(res, proto, (u_int)nl->nl_origport));
	t += strlen(t);
	if (nl->nl_type == NL_EXPIRE) {
#ifdef	USE_QUAD_T
		(void) sprintf(t, " Pkts %qd Bytes %qd",
				(long long)nl->nl_pkts,
				(long long)nl->nl_bytes);
#else
		(void) sprintf(t, " Pkts %ld Bytes %ld",
				nl->nl_pkts, nl->nl_bytes);
#endif
		t += strlen(t);
	}

	*t++ = '\n';
	*t++ = '\0';
	if (opts & OPT_SYSLOG)
		syslog(LOG_INFO, "%s", line);
	else
		(void) fprintf(log, "%s", line);
}


static	void	print_statelog(log, buf, blen)
FILE	*log;
char	*buf;
int	blen;
{
	struct	ipslog *sl;
	iplog_t	*ipl = (iplog_t *)buf;
	char	*t = line, *proto;
	struct	tm	*tm;
	int	res, i, len;

	sl = (struct ipslog *)((char *)ipl + sizeof(*ipl));
	res = (opts & OPT_RESOLVE) ? 1 : 0;
	tm = localtime((time_t *)&ipl->ipl_sec);
	len = sizeof(line);
	if (!(opts & OPT_SYSLOG)) {
		(void) strftime(t, len, "%d/%m/%Y ", tm);
		i = strlen(t);
		len -= i;
		t += i;
	}
	(void) strftime(t, len, "%T", tm);
	t += strlen(t);
	(void) sprintf(t, ".%-.6ld ", ipl->ipl_usec);
	t += strlen(t);

	if (sl->isl_type == ISL_NEW)
		strcpy(t, "STATE:NEW ");
	else if (sl->isl_type == ISL_EXPIRE) {
		if ((sl->isl_p == IPPROTO_TCP) &&
		    (sl->isl_state[0] > TCPS_ESTABLISHED ||
		     sl->isl_state[1] > TCPS_ESTABLISHED))
			strcpy(t, "STATE:CLOSE ");
		else
			strcpy(t, "STATE:EXPIRE ");
	} else if (sl->isl_type == ISL_FLUSH)
		strcpy(t, "STATE:FLUSH ");
	else if (sl->isl_type == ISL_REMOVE)
		strcpy(t, "STATE:REMOVE ");
	else
		sprintf(t, "Type: %d ", sl->isl_type);
	t += strlen(t);

	proto = getproto(sl->isl_p);

	if (sl->isl_p == IPPROTO_TCP || sl->isl_p == IPPROTO_UDP) {
		(void) sprintf(t, "%s,%s -> ",
			hostname(res, sl->isl_v, (u_32_t *)&sl->isl_src),
			portname(res, proto, (u_int)sl->isl_sport));
		t += strlen(t);
		(void) sprintf(t, "%s,%s PR %s",
			hostname(res, sl->isl_v, (u_32_t *)&sl->isl_dst),
			portname(res, proto, (u_int)sl->isl_dport), proto);
	} else if (sl->isl_p == IPPROTO_ICMP) {
		(void) sprintf(t, "%s -> ", hostname(res, sl->isl_v,
						     (u_32_t *)&sl->isl_src));
		t += strlen(t);
		(void) sprintf(t, "%s PR icmp %d",
			hostname(res, sl->isl_v, (u_32_t *)&sl->isl_dst),
			sl->isl_itype);
	}
	t += strlen(t);
	if (sl->isl_type != ISL_NEW) {
#ifdef	USE_QUAD_T
		(void) sprintf(t, " Pkts %qd Bytes %qd",
				(long long)sl->isl_pkts,
				(long long)sl->isl_bytes);
#else
		(void) sprintf(t, " Pkts %ld Bytes %ld",
				sl->isl_pkts, sl->isl_bytes);
#endif
		t += strlen(t);
	}

	*t++ = '\n';
	*t++ = '\0';
	if (opts & OPT_SYSLOG)
		syslog(LOG_INFO, "%s", line);
	else
		(void) fprintf(log, "%s", line);
}


static	void	print_log(logtype, log, buf, blen)
FILE	*log;
char	*buf;
int	logtype, blen;
{
	iplog_t	*ipl;
	char *bp = NULL, *bpo = NULL;
	int psize;

	while (blen > 0) {
		ipl = (iplog_t *)buf;
		if ((u_long)ipl & (sizeof(long)-1)) {
			if (bp)
				bpo = bp;
			bp = (char *)malloc(blen);
			bcopy((char *)ipl, bp, blen);
			if (bpo) {
				free(bpo);
				bpo = NULL;
			}
			buf = bp;
			continue;
		}
		if (ipl->ipl_magic != IPL_MAGIC) {
			/* invalid data or out of sync */
			break;
		}
		psize = ipl->ipl_dsize;
		switch (logtype)
		{
		case IPL_LOGIPF :
			print_ipflog(log, buf, psize);
			break;
		case IPL_LOGNAT :
			print_natlog(log, buf, psize);
			break;
		case IPL_LOGSTATE :
			print_statelog(log, buf, psize);
			break;
		}

		blen -= psize;
		buf += psize;
	}
	if (bp)
		free(bp);
	return;
}


static	void	print_ipflog(log, buf, blen)
FILE	*log;
char	*buf;
int	blen;
{
	tcphdr_t	*tp;
	struct	icmp	*ic;
	struct	icmp	*icmp;
	struct	tm	*tm;
	char	*t, *proto;
	int	i, v, lvl, res, len, off, plen, ipoff;
	ip_t	*ipc, *ip;
	u_short	hl, p;
	ipflog_t *ipf;
	iplog_t	*ipl;
	u_32_t	*s, *d;
#ifdef	USE_INET6
	ip6_t *ip6;
#endif

	ipl = (iplog_t *)buf;
	ipf = (ipflog_t *)((char *)buf + sizeof(*ipl));
	ip = (ip_t *)((char *)ipf + sizeof(*ipf));
	v = ip->ip_v;
	res = (opts & OPT_RESOLVE) ? 1 : 0;
	t = line;
	*t = '\0';
	tm = localtime((time_t *)&ipl->ipl_sec);
#ifdef	linux
	if (v == 4)
		ip->ip_len = ntohs(ip->ip_len);
#endif

	len = sizeof(line);
	if (!(opts & OPT_SYSLOG)) {
		(void) strftime(t, len, "%d/%m/%Y ", tm);
		i = strlen(t);
		len -= i;
		t += i;
	}
	(void) strftime(t, len, "%T", tm);
	t += strlen(t);
	(void) sprintf(t, ".%-.6ld ", ipl->ipl_usec);
	t += strlen(t);
	if (ipl->ipl_count > 1) {
		(void) sprintf(t, "%dx ", ipl->ipl_count);
		t += strlen(t);
	}
#if (SOLARIS || \
	(defined(NetBSD) && (NetBSD <= 1991011) && (NetBSD >= 199603)) || \
	(defined(OpenBSD) && (OpenBSD >= 199603))) || defined(linux)
	len = (int)sizeof(ipf->fl_ifname);
	(void) sprintf(t, "%*.*s", len, len, ipf->fl_ifname);
	t += strlen(t);
# if SOLARIS
	if (isalpha(*(t - 1)))
		*t++ = '0' + ipf->fl_unit;
# endif
#else
	for (len = 0; len < 3; len++)
		if (ipf->fl_ifname[len] == '\0')
			break;
	if (ipf->fl_ifname[len])
		len++;
	(void) sprintf(t, "%*.*s%u", len, len, ipf->fl_ifname, ipf->fl_unit);
	t += strlen(t);
#endif
	(void) sprintf(t, " @@%hu:%hu ", ipf->fl_group, ipf->fl_rule + 1);
	t += strlen(t);

 	if (ipf->fl_flags & FF_SHORT) {
		*t++ = 'S';
		lvl = LOG_ERR;
	} else if (ipf->fl_flags & FR_PASS) {
		if (ipf->fl_flags & FR_LOGP)
			*t++ = 'p';
		else
			*t++ = 'P';
		lvl = LOG_NOTICE;
	} else if (ipf->fl_flags & FR_BLOCK) {
		if (ipf->fl_flags & FR_LOGB)
			*t++ = 'b';
		else
			*t++ = 'B';
		lvl = LOG_WARNING;
	} else if (ipf->fl_flags & FF_LOGNOMATCH) {
		*t++ = 'n';
		lvl = LOG_NOTICE;
	} else {
		*t++ = 'L';
		lvl = LOG_INFO;
	}
	if (ipf->fl_loglevel != 0xffff)
		lvl = ipf->fl_loglevel;
	*t++ = ' ';
	*t = '\0';

	if (v == 6) {
#ifdef	USE_INET6
		off = 0;
		ipoff = 0;
		hl = sizeof(ip6_t);
		ip6 = (ip6_t *)ip;
		p = (u_short)ip6->ip6_nxt;
		s = (u_32_t *)&ip6->ip6_src;
		d = (u_32_t *)&ip6->ip6_dst;
		plen = ntohs(ip6->ip6_plen);
#else
		sprintf(t, "ipv6");
		goto printipflog;
#endif
	} else if (v == 4) {
		hl = (ip->ip_hl << 2);
		ipoff = ip->ip_off;
		off = ipoff & IP_OFFMASK;
		p = (u_short)ip->ip_p;
		s = (u_32_t *)&ip->ip_src;
		d = (u_32_t *)&ip->ip_dst;
		plen = ip->ip_len;
	} else {
		goto printipflog;
	}
	proto = getproto(p);

	if ((p == IPPROTO_TCP || p == IPPROTO_UDP) && !off) {
		tp = (tcphdr_t *)((char *)ip + hl);
		if (!(ipf->fl_flags & (FI_SHORT << 16))) {
			(void) sprintf(t, "%s,%s -> ", hostname(res, v, s),
				portname(res, proto, (u_int)tp->th_sport));
			t += strlen(t);
			(void) sprintf(t, "%s,%s PR %s len %hu %hu ",
				hostname(res, v, d),
				portname(res, proto, (u_int)tp->th_dport),
				proto, hl, plen);
			t += strlen(t);

			if (p == IPPROTO_TCP) {
				*t++ = '-';
				for (i = 0; tcpfl[i].value; i++)
					if (tp->th_flags & tcpfl[i].value)
						*t++ = tcpfl[i].flag;
				if (opts & OPT_VERBOSE) {
					(void) sprintf(t, " %lu %lu %hu",
						(u_long)(ntohl(tp->th_seq)),
						(u_long)(ntohl(tp->th_ack)),
						ntohs(tp->th_win));
					t += strlen(t);
				}
			}
			*t = '\0';
		} else {
			(void) sprintf(t, "%s -> ", hostname(res, v, s));
			t += strlen(t);
			(void) sprintf(t, "%s PR %s len %hu %hu",
				hostname(res, v, d), proto, hl, plen);
		}
	} else if ((p == IPPROTO_ICMP) && !off && (v == 4)) {
		ic = (struct icmp *)((char *)ip + hl);
		(void) sprintf(t, "%s -> ", hostname(res, v, s));
		t += strlen(t);
		(void) sprintf(t, "%s PR icmp len %hu %hu icmp %d/%d",
			hostname(res, v, d), hl, plen,
			ic->icmp_type, ic->icmp_code);
		if (ic->icmp_type == ICMP_UNREACH ||
		    ic->icmp_type == ICMP_SOURCEQUENCH ||
		    ic->icmp_type == ICMP_PARAMPROB ||
		    ic->icmp_type == ICMP_REDIRECT ||
		    ic->icmp_type == ICMP_TIMXCEED) {
			ipc = &ic->icmp_ip;
			i = ntohs(ipc->ip_len);
			ipoff = ntohs(ipc->ip_off);
			proto = getproto(ipc->ip_p);

			if (!(ipoff & IP_OFFMASK) &&
			    ((ipc->ip_p == IPPROTO_TCP) ||
			     (ipc->ip_p == IPPROTO_UDP))) {
				tp = (tcphdr_t *)((char *)ipc + hl);
				t += strlen(t);
				(void) sprintf(t, " for %s,%s -",
					HOSTNAME_V4(res, ipc->ip_src),
					portname(res, proto,
						 (u_int)tp->th_sport));
				t += strlen(t);
				(void) sprintf(t, " %s,%s PR %s len %hu %hu",
					HOSTNAME_V4(res, ipc->ip_dst),
					portname(res, proto,
						 (u_int)tp->th_dport),
					proto, ipc->ip_hl << 2, i);
			} else if (!(ipoff & IP_OFFMASK) &&
				   (ipc->ip_p == IPPROTO_ICMP)) {
				icmp = (icmphdr_t *)((char *)ipc + hl);

				t += strlen(t);
				(void) sprintf(t, " for %s -",
					HOSTNAME_V4(res, ipc->ip_src));
				t += strlen(t);
				(void) sprintf(t,
					" %s PR icmp len %hu %hu icmp %d/%d",
					HOSTNAME_V4(res, ipc->ip_dst),
					ipc->ip_hl << 2, i,
					icmp->icmp_type, icmp->icmp_code);

			} else {
				t += strlen(t);
				(void) sprintf(t, " for %s -",
						HOSTNAME_V4(res, ipc->ip_src));
				t += strlen(t);
				(void) sprintf(t, " %s PR %s len %hu (%hu)",
					HOSTNAME_V4(res, ipc->ip_dst), proto,
					ipc->ip_hl << 2, i);
				t += strlen(t);
				if (ipoff & IP_OFFMASK) {
					(void) sprintf(t, " frag %s%s%hu@@%hu",
						ipoff & IP_MF ? "+" : "",
						ipoff & IP_DF ? "-" : "",
						i - (ipc->ip_hl<<2),
						(ipoff & IP_OFFMASK) << 3);
				}
			}
		}
	} else {
		(void) sprintf(t, "%s -> ", hostname(res, v, s));
		t += strlen(t);
		(void) sprintf(t, "%s PR %s len %hu (%hu)",
			hostname(res, v, d), proto, hl, plen);
		t += strlen(t);
		if (off & IP_OFFMASK)
			(void) sprintf(t, " frag %s%s%hu@@%hu",
				ipoff & IP_MF ? "+" : "",
				ipoff & IP_DF ? "-" : "",
				plen - hl, (off & IP_OFFMASK) << 3);
	}
	t += strlen(t);

	if (ipf->fl_flags & FR_KEEPSTATE) {
		(void) strcpy(t, " K-S");
		t += strlen(t);
	}

	if (ipf->fl_flags & FR_KEEPFRAG) {
		(void) strcpy(t, " K-F");
		t += strlen(t);
	}

	if (ipf->fl_flags & FR_INQUE)
		strcpy(t, " IN");
	else if (ipf->fl_flags & FR_OUTQUE)
		strcpy(t, " OUT");
	t += strlen(t);
printipflog:
	*t++ = '\n';
	*t++ = '\0';
	if (opts & OPT_SYSLOG)
		syslog(lvl, "%s", line);
	else
		(void) fprintf(log, "%s", line);
	if (opts & OPT_HEXHDR)
		dumphex(log, (u_char *)buf, sizeof(iplog_t) + sizeof(*ipf));
	if (opts & OPT_HEXBODY)
		dumphex(log, (u_char *)ip, ipf->fl_plen + ipf->fl_hlen);
	else if ((opts & OPT_LOGBODY) && (ipf->fl_flags & FR_LOGBODY))
		dumphex(log, (u_char *)ip + ipf->fl_hlen, ipf->fl_plen);
}


static void usage(prog)
char *prog;
{
	fprintf(stderr, "%s: [-NFhstvxX] [-f <logfile>]\n", prog);
	exit(1);
}


static void write_pid(file)
char *file;
{
	FILE *fp = NULL;
	int fd;

	if ((fd = open(file, O_CREAT|O_TRUNC|O_WRONLY, 0644)) >= 0)
		fp = fdopen(fd, "w");
	if (!fp) {
		close(fd);
		fprintf(stderr, "unable to open/create pid file: %s\n", file);
		return;
	}
	fprintf(fp, "%d", getpid());
	fclose(fp);
	close(fd);
}


static void flushlogs(file, log)
char *file;
FILE *log;
{
	int	fd, flushed = 0;

	if ((fd = open(file, O_RDWR)) == -1) {
		(void) fprintf(stderr, "%s: open: %s\n", file,STRERROR(errno));
		exit(-1);
	}

	if (ioctl(fd, SIOCIPFFB, &flushed) == 0) {
		printf("%d bytes flushed from log buffer\n",
			flushed);
		fflush(stdout);
	} else
		perror("SIOCIPFFB");
	(void) close(fd);

	if (flushed) {
		if (opts & OPT_SYSLOG)
			syslog(LOG_INFO, "%d bytes flushed from log\n",
				flushed);
		else if (log != stdout)
			fprintf(log, "%d bytes flushed from log\n", flushed);
	}
}


static void logopts(turnon, options)
int turnon;
char *options;
{
	int flags = 0;
	char *s;

	for (s = options; *s; s++)
	{
		switch (*s)
		{
		case 'N' :
			flags |= OPT_NAT;
			break;
		case 'S' :
			flags |= OPT_STATE;
			break;
		case 'I' :
			flags |= OPT_FILTER;
			break;
		default :
			fprintf(stderr, "Unknown log option %c\n", *s);
			exit(1);
		}
	}

	if (turnon)
		opts |= flags;
	else
		opts &= ~(flags);
}


int main(argc, argv)
int argc;
char *argv[];
{
	struct	stat	sb;
	FILE	*log = stdout;
	int	fd[3], doread, n, i;
	int	tr, nr, regular[3], c;
	int	fdt[3], devices = 0, make_daemon = 0;
	char	buf[512], *iplfile[3], *s;
	extern	int	optind;
	extern	char	*optarg;

	fd[0] = fd[1] = fd[2] = -1;
	fdt[0] = fdt[1] = fdt[2] = -1;
	iplfile[0] = IPL_NAME;
	iplfile[1] = IPNAT_NAME;
	iplfile[2] = IPSTATE_NAME;

	while ((c = getopt(argc, argv, "?abDf:FhnN:o:O:pP:sS:tvxX")) != -1)
		switch (c)
		{
		case 'a' :
			opts |= OPT_LOGALL;
			fdt[0] = IPL_LOGIPF;
			fdt[1] = IPL_LOGNAT;
			fdt[2] = IPL_LOGSTATE;
			break;
		case 'b' :
			opts |= OPT_LOGBODY;
			break;
		case 'D' :
			make_daemon = 1;
			break;
		case 'f' : case 'I' :
			opts |= OPT_FILTER;
			fdt[0] = IPL_LOGIPF;
			iplfile[0] = optarg;
			break;
		case 'F' :
			flushlogs(iplfile[0], log);
			flushlogs(iplfile[1], log);
			flushlogs(iplfile[2], log);
			break;
		case 'n' :
			opts |= OPT_RESOLVE;
			break;
		case 'N' :
			opts |= OPT_NAT;
			fdt[1] = IPL_LOGNAT;
			iplfile[1] = optarg;
			break;
		case 'o' : case 'O' :
			logopts(c == 'o', optarg);
			fdt[0] = fdt[1] = fdt[2] = -1;
			if (opts & OPT_FILTER)
				fdt[0] = IPL_LOGIPF;
			if (opts & OPT_NAT)
				fdt[1] = IPL_LOGNAT;
			if (opts & OPT_STATE)
				fdt[2] = IPL_LOGSTATE;
			break;
		case 'p' :
			opts |= OPT_PORTNUM;
			break;
		case 'P' :
			pidfile = optarg;
			break;
		case 's' :
			s = strrchr(argv[0], '/');
			if (s == NULL)
				s = argv[0];
			else
				s++;
			openlog(s, LOG_NDELAY|LOG_PID, LOGFAC);
			s = NULL;
			opts |= OPT_SYSLOG;
			log = NULL;
			break;
		case 'S' :
			opts |= OPT_STATE;
			fdt[2] = IPL_LOGSTATE;
			iplfile[2] = optarg;
			break;
		case 't' :
			opts |= OPT_TAIL;
			break;
		case 'v' :
			opts |= OPT_VERBOSE;
			break;
		case 'x' :
			opts |= OPT_HEXBODY;
			break;
		case 'X' :
			opts |= OPT_HEXHDR;
			break;
		default :
		case 'h' :
		case '?' :
			usage(argv[0]);
		}

	init_tabs();

	/*
	 * Default action is to only open the filter log file.
	 */
	if ((fdt[0] == -1) && (fdt[1] == -1) && (fdt[2] == -1))
		fdt[0] = IPL_LOGIPF;

	for (i = 0; i < 3; i++) {
		if (fdt[i] == -1)
			continue;
		if (!strcmp(iplfile[i], "-"))
			fd[i] = 0;
		else {
			if ((fd[i] = open(iplfile[i], O_RDONLY)) == -1) {
				(void) fprintf(stderr,
					       "%s: open: %s\n", iplfile[i],
					       STRERROR(errno));
				exit(-1);
			}

			if (fstat(fd[i], &sb) == -1) {
				(void) fprintf(stderr, "%d: fstat: %s\n",fd[i],
					       STRERROR(errno));
				exit(-1);
			}
			if (!(regular[i] = !S_ISCHR(sb.st_mode)))
				devices++;
		}
	}

	if (!(opts & OPT_SYSLOG)) {
		logfile = argv[optind];
		log = logfile ? fopen(logfile, "a") : stdout;
		if (log == NULL) {
			
			(void) fprintf(stderr, "%s: fopen: %s\n", argv[optind],
				STRERROR(errno));
			exit(-1);
		}
		setvbuf(log, NULL, _IONBF, 0);
	} else
		log = NULL;

	if (make_daemon && ((log != stdout) || (opts & OPT_SYSLOG))) {
		if (fork() > 0)
			exit(0);
		write_pid(pidfile);
		close(0);
		close(1);
		close(2);
		setsid();
	} else
		write_pid(pidfile);

	signal(SIGHUP, handlehup);

	for (doread = 1; doread; ) {
		nr = 0;

		for (i = 0; i < 3; i++) {
			tr = 0;
			if (fdt[i] == -1)
				continue;
			if (!regular[i]) {
				if (ioctl(fd[i], FIONREAD, &tr) == -1) {
					perror("ioctl(FIONREAD)");
					exit(-1);
				}
			} else {
				tr = (lseek(fd[i], 0, SEEK_CUR) < sb.st_size);
				if (!tr && !(opts & OPT_TAIL))
					doread = 0;
			}
			if (!tr)
				continue;
			nr += tr;

			tr = read_log(fd[i], &n, buf, sizeof(buf));
			if (donehup) {
				donehup = 0;
				if (newlog) {
					fclose(log);
					log = newlog;
					newlog = NULL;
				}
			}

			switch (tr)
			{
			case -1 :
				if (opts & OPT_SYSLOG)
					syslog(LOG_ERR, "read: %m\n");
				else
					perror("read");
				doread = 0;
				break;
			case 1 :
				if (opts & OPT_SYSLOG)
					syslog(LOG_ERR, "aborting logging\n");
				else
					fprintf(log, "aborting logging\n");
				doread = 0;
				break;
			case 2 :
				break;
			case 0 :
				if (n > 0) {
					print_log(fdt[i], log, buf, n);
					if (!(opts & OPT_SYSLOG))
						fflush(log);
				}
				break;
			}
		}
		if (!nr && ((opts & OPT_TAIL) || devices))
			sleep(1);
	}
	exit(0);
	/* NOTREACHED */
}
@


1.27
log
@reimplement whacked ipmon change
@
text
@d1 1
a1 1
/*	$OpenBSD: ipmon.c,v 1.26 2001/01/17 07:26:59 fgsch Exp $	*/
@


1.26
log
@IPF 3.4.16 userland.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipmon.c,v 1.25 2001/01/17 05:01:02 fgsch Exp $	*/
d68 1
a68 1
#include <netinet/ip_compat.h>
d1015 1
@


1.25
log
@1st part of ipf userland code.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d12 1
a12 1
static const char rcsid[] = "@@(#)$IPFilter: ipmon.c,v 2.12.2.6 2000/10/31 22:17:41 darrenr Exp $";
d96 2
d151 1
d844 2
d957 1
a957 1
	while ((c = getopt(argc, argv, "?aDf:FhnN:o:O:pP:sS:tvxX")) != -1)
d965 3
@


1.24
log
@Import ipf 3.3.18. Fixes more problems with the in-kernel FTP proxy,
some nat state bugs, and ups the default state table size.
See sbin/ipf/HISTORY for details.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipmon.c,v 1.23 2000/03/13 23:40:20 kjell Exp $	*/
d4 1
a4 1
 * Copyright (C) 1993-1998 by Darren Reed.
d11 2
a12 2
static const char sccsid[] = "@@(#)ipmon.c	1.21 6/5/96 (C)1993-1998 Darren Reed";
static const char rcsid[] = "@@(#)$IPFilter: ipmon.c,v 2.3.2.6 2000/08/07 13:04:51 darrenr Exp $";
d68 1
a68 1
#include <netinet/ip_fil_compat.h>
a108 8
struct hlist {
	struct hlist *next;
	struct in_addr addr;
	char name[MAXHOSTNAMELEN];
};
#define PRIME 367
static  struct	hlist htable[PRIME];

d125 1
a125 1
char	*hostname __P((int, struct in_addr));
d150 2
d214 1
a214 1
			port = s->s_port;
d218 1
a218 1
			port = s->s_port;
d263 3
a265 3
char	*hostname(res, ip)
int	res;
struct	in_addr	ip;
d267 3
d271 1
a271 1
	struct hlist *hl;
d273 17
a289 22
	if (!res)
		return inet_ntoa(ip);

	hl = &htable[ip.s_addr % PRIME];
	for ( ; hl->next != NULL; hl = hl->next) 
		if (hl->addr.s_addr == ip.s_addr)
			return hl->name;

	hl->addr.s_addr = ip.s_addr;
	hl->next = (struct hlist *)calloc(1, sizeof(*hl));
	if (hl->next == NULL) {
		perror("calloc");
		exit(1);
	}
		
	hp = gethostbyaddr((char *)&ip, sizeof(ip), AF_INET);
	if (!hp)
		strlcpy(hl->name, inet_ntoa(ip), sizeof hl->name);
	else
		strlcpy(hl->name, hp->h_name, sizeof hl->name);

	return hl->name;
d341 1
a341 1
			sprintf((char *)t, "        ");
d406 6
d418 1
a418 1
	(void) sprintf(t, "%s,%s <- -> ", hostname(res, nl->nl_inip),
d421 1
a421 1
	(void) sprintf(t, "%s,%s ", hostname(res, nl->nl_outip),
d424 1
a424 1
	(void) sprintf(t, "[%s,%s]", hostname(res, nl->nl_origip),
d430 2
d434 1
a435 1
				nl->nl_pkts, nl->nl_bytes);
d485 2
d495 1
a495 1
			hostname(res, sl->isl_src),
d499 1
a499 1
			hostname(res, sl->isl_dst),
d502 2
a503 1
		(void) sprintf(t, "%s -> ", hostname(res, sl->isl_src));
d506 2
a507 1
			hostname(res, sl->isl_dst), sl->isl_itype);
d513 2
d517 1
a518 1
				sl->isl_pkts, sl->isl_bytes);
d588 1
a588 1
	struct	icmp	*icmphdr;
d591 2
d594 1
a594 2
	int	i, lvl, res, len, ipoff;
	ip_t	*ipc, *ip;
d596 4
a599 1
	ipflog_t *ipf;
d604 1
a607 2
	hl = (ip->ip_hl << 2);
	p = (u_short)ip->ip_p;
d610 2
a611 1
	ip->ip_len = ntohs(ip->ip_len);
a649 1
	proto = getproto(p);
d678 28
a705 2
	if ((p == IPPROTO_TCP || p == IPPROTO_UDP) &&
	    !(ip->ip_off & IP_OFFMASK)) {
d708 1
a708 2
			(void) sprintf(t, "%s,%s -> ",
				hostname(res, ip->ip_src),
d712 1
a712 1
				hostname(res, ip->ip_dst),
d714 1
a714 1
				proto, hl, ip->ip_len);
d732 1
a732 1
			(void) sprintf(t, "%s -> ", hostname(res, ip->ip_src));
d735 1
a735 2
				hostname(res, ip->ip_dst), proto,
				hl, ip->ip_len);
d737 1
a737 1
	} else if ((p == IPPROTO_ICMP) && !(ip->ip_off & IP_OFFMASK)) {
d739 1
a739 1
		(void) sprintf(t, "%s -> ", hostname(res, ip->ip_src));
d742 1
a742 1
			hostname(res, ip->ip_dst), hl, ip->ip_len,
a757 1

d760 1
a760 1
					hostname(res, ipc->ip_src),
d765 1
a765 1
					hostname(res, ipc->ip_dst),
d768 4
a771 4
					proto, ipc->ip_hl << 2, ipc->ip_len);
			} else 	if ((ipc->ip_p == IPPROTO_ICMP) &&
				    !(ipoff & IP_OFFMASK)) {
				icmphdr = (icmphdr_t *)((char *)ipc + hl);
d775 1
a775 1
					hostname(res, ipc->ip_src));
d779 1
a779 1
					hostname(res, ipc->ip_dst),
d781 2
a782 1
					icmphdr->icmp_type, icmphdr->icmp_code);
a783 1

d786 1
a786 1
					hostname(res, ipc->ip_src));
d789 2
a790 2
					hostname(res, ipc->ip_dst),
					proto, ipc->ip_hl << 2, ipc->ip_len);
d792 1
a792 1
				if (ipc->ip_off & IP_OFFMASK) {
d796 1
a796 1
						i -  (ipc->ip_hl << 2),
d802 1
a802 1
		(void) sprintf(t, "%s -> ", hostname(res, ip->ip_src));
d805 1
a805 1
			hostname(res, ip->ip_dst), proto, hl, ip->ip_len);
d807 1
a807 1
		if (ip->ip_off & IP_OFFMASK)
d809 3
a811 4
				ip->ip_off & IP_MF ? "+" : "",
				ip->ip_off & IP_DF ? "-" : "",
				ip->ip_len - hl,
				(ip->ip_off & IP_OFFMASK) << 3);
d830 1
a1006 1
			log = NULL;
@


1.23
log
@Import of Darren Reed's IPFilter 3.3.11. See sbin/ipf/HISTORY for detailed
changelog. Documentation changes are now way behind. Volunteers?
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d12 1
a12 1
static const char rcsid[] = "@@(#)$IPFilter: ipmon.c,v 2.3.2.5 2000/02/16 14:40:39 darrenr Exp $";
d582 1
d586 1
a586 1
	int	i, lvl, res, len;
d717 2
a718 2
			tp = (tcphdr_t *)((char *)ipc + hl);

d721 47
a767 9
			t += strlen(t);
			(void) sprintf(t, " for %s,%s -",
				hostname(res, ipc->ip_src),
				portname(res, proto, (u_int)tp->th_sport));
			t += strlen(t);
			(void) sprintf(t, " %s,%s PR %s len %hu %hu",
				hostname(res, ipc->ip_dst),
				portname(res, proto, (u_int)tp->th_dport),
				proto, ipc->ip_hl << 2, ipc->ip_len);
@


1.22
log
@Import IPFilter 3.3.9. Primarily, bugfixes since 3.3.8. See sbin/ipf/HISTORY
for details.
@
text
@d12 1
a12 1
static const char rcsid[] = "@@(#)$IPFilter: ipmon.c,v 2.3.2.4 2000/01/24 12:45:25 darrenr Exp $";
d181 1
a181 1
	u_int	port;
d220 1
a220 1
			port = (u_int)s->s_port;
d224 1
a224 1
			port = (u_int)s->s_port;
@


1.21
log
@Update to IPFilter 3.3.8. Man pages still to go. See sbin/ipf/HISTORY
for details.
@
text
@@


1.20
log
@Import of Darren Reed's IPFilter 3.3.4, including OpenBSD patches.

Many, many enhancements and improvements, including new in-kernel
proxies, enhancements to logging, and many bugfixes.

Note: Man pages have not yet been re-converted to mdoc.
@
text
@d1 2
a2 1
/* $OpenBSD$ */
d12 1
a12 1
static const char rcsid[] = "@@(#)$Id: ipmon.c,v 2.3.2.3 1999/11/28 04:05:28 darrenr Exp $";
d391 1
d418 2
d421 1
a421 1
		portname(res, NULL, (u_int)nl->nl_inport));
d424 1
a424 1
		portname(res, NULL, (u_int)nl->nl_outport));
d427 1
a427 1
		portname(res, NULL, (u_int)nl->nl_origport));
@


1.19
log
@incorrect icmp packet length printf; gluk@@ptci.ru
@
text
@d1 2
a2 1
/*	$OpenBSD: ipmon.c,v 1.18 1999/02/05 05:58:48 deraadt Exp $
d10 2
a11 2
static const char sccsid[] = "@@(#)ipmon.c	1.21 6/5/96 (C)1993-1997 Darren Reed";
static const char rcsid[] = "@@(#)$Id: ipmon.c,v 1.18 1999/02/05 05:58:48 deraadt Exp $";
a30 1
#include <sys/types.h>
d32 9
a42 5
#include <sys/dir.h>
#else
#include <sys/filio.h>
#include <sys/byteorder.h>
#endif
a57 1
# include <sys/user.h>
d66 2
a67 5
#if defined(__OpenBSD__)
# include <netinet/ip_fil_compat.h>
#else
# include <netinet/ip_compat.h>
#endif
a122 1
static	void	write_pid __P((char *));
d129 3
a131 1
static	int	read_log __P((int, int *, char *, int, FILE *));
d133 1
a133 1
char	*portname __P((int, char *, u_short));
d137 6
d155 1
a155 1
#define	OPT_ALL		(OPT_NAT|OPT_STATE|OPT_FILTER)
d167 1
d170 1
d175 78
a252 1
static int read_log(fd, lenp, buf, bufsize, log)
a254 1
FILE *log;
d303 1
a303 1
u_short	port;
d306 1
a306 1
	struct	servent	*serv;
d308 3
a310 1
	(void) sprintf(pname, "%hu", htons(port));
d313 8
a320 4
	serv = getservbyport((int)port, proto);
	if (!serv)
		return pname;
	return serv->s_name;
d417 1
a417 1
		portname(res, NULL, nl->nl_inport));
d420 1
a420 1
		portname(res, NULL, nl->nl_outport));
d423 1
a423 1
		portname(res, NULL, nl->nl_origport));
d451 1
a451 2
	struct	protoent *pr;
	char	*t = line, *proto, pname[6];
d473 3
a475 2
		if (sl->isl_state[0] > TCPS_ESTABLISHED ||
		    sl->isl_state[1] > TCPS_ESTABLISHED)
d485 1
a485 6
	pr = getprotobynumber((int)sl->isl_p);
	if (!pr) {
		proto = pname;
		sprintf(proto, "%d", (u_int)sl->isl_p);
	} else
		proto = pr->p_name;
d490 1
a490 1
			portname(res, proto, sl->isl_sport));
d494 1
a494 1
			portname(res, proto, sl->isl_dport), proto);
a575 1
	struct	protoent *pr;
d579 1
a579 1
	char	c[3], pname[8], *t, *proto;
d619 5
d626 1
a626 1
		if (!ipf->fl_ifname[len])
d631 1
d633 1
d635 1
a635 7
	(void) sprintf(t, " @@%hu:%hu ", ipf->fl_group, ipf->fl_rule + 1);
	pr = getprotobynumber((int)p);
	if (!pr) {
		proto = pname;
		sprintf(proto, "%d", (u_int)p);
	} else
		proto = pr->p_name;
d638 1
a638 1
		c[0] = 'S';
d642 1
a642 1
			c[0] = 'p';
d644 1
a644 1
			c[0] = 'P';
d648 1
a648 1
			c[0] = 'b';
d650 1
a650 1
			c[0] = 'B';
d653 1
a653 1
		c[0] = 'n';
d656 1
a656 1
		c[0] = 'L';
d659 4
a662 4
	c[1] = ' ';
	c[2] = '\0';
	(void) strcat(line, c);
	t = line + strlen(line);
d670 1
a670 1
				portname(res, proto, tp->th_sport));
d674 1
a674 1
				portname(res, proto, tp->th_dport),
d685 3
a687 3
						(u_long)tp->th_seq,
						(u_long)tp->th_ack,
						tp->th_win);
d699 1
a699 1
	} else if (p == IPPROTO_ICMP) {
d714 1
a714 7
			p = (u_short)ipc->ip_p;
			pr = getprotobynumber((int)p);
			if (!pr) {
				proto = pname;
				(void) sprintf(proto, "%d", (int)p);
			} else
				proto = pr->p_name;
d719 1
a719 1
				portname(res, proto, tp->th_sport));
d723 1
a723 1
				portname(res, proto, tp->th_dport),
d751 5
d763 1
a763 1
		dumphex(log, (u_char *)buf, sizeof(iplog_t));
d800 1
a800 1
	int	fd, cmd, flushed = 0;
d807 1
a807 1
	if (ioctl(fd, cmd, &flushed) == 0) {
d881 1
a881 1
			opts |= OPT_ALL;
d927 2
d930 1
d957 2
d998 2
a999 1
	}
d1001 1
a1001 1
	if (make_daemon && (log != stdout)) {
d1035 1
a1035 1
			tr = read_log(fd[i], &n, buf, sizeof(buf), log);
@


1.18
log
@ipf 3.2.10; work by kjell
@
text
@d1 1
a1 1
/*	$OpenBSD: ipmon.c,v 1.17 1998/11/13 00:04:01 deraadt Exp $
d10 1
a10 1
static const char rcsid[] = "@@(#)$Id: ipmon.c,v 1.17 1998/11/13 00:04:01 deraadt Exp $";
d618 1
a618 1
			hostname(res, ip->ip_dst), hl, ntohs(ip->ip_len),
@


1.17
log
@put p option in getopt(); garath@@code.ridgefield.org
@
text
@d1 2
a2 2
/*	$OpenBSD: ipmon.c,v 1.16 1998/11/10 22:04:11 deraadt Exp $
 * Copyright (C) 1993-1997 by Darren Reed.
d10 1
a10 1
static const char rcsid[] = "@@(#)$Id: ipmon.c,v 1.16 1998/11/10 22:04:11 deraadt Exp $";
d13 12
a38 4
#include <sys/stat.h>
#include <sys/param.h>
#include <sys/file.h>
#include <sys/time.h>
a40 2
#include <sys/socket.h>
#include <sys/ioctl.h>
d45 1
d98 10
d123 1
d155 2
a156 2
static void handlehup(signal)
int signal;
d319 1
a319 1
	else if (nl->nl_type == ISL_EXPIRE)
d382 8
a389 2
	else if (sl->isl_type == ISL_EXPIRE)
		strcpy(t, "STATE:EXPIRE ");
d491 1
a491 1
	struct	tcphdr	*tp;
d578 3
a580 2
	if ((p == IPPROTO_TCP || p == IPPROTO_UDP) && !(ip->ip_off & 0x1fff)) {
		tp = (struct tcphdr *)((char *)ip + hl);
d597 7
a603 6
			}
			if (opts & OPT_VERBOSE) {
				(void) sprintf(t, " %lu %lu %hu",
					(u_long)tp->th_seq,
					(u_long)tp->th_ack, tp->th_win);
				t += strlen(t);
d626 1
a626 1
			tp = (struct tcphdr *)((char *)ipc + hl);
d652 1
a652 1
		if (ip->ip_off & 0x1fff)
d656 2
a657 1
				ip->ip_len - hl, (ip->ip_off & 0x1fff) << 3);
d692 19
a716 5
	if (strcmp(file, "/dev/ipstate") == 0)
		cmd = SIOCIPFFL;
	else
		cmd = SIOCIPFFB;

d782 1
a782 1
	char	buf[512], *iplfile[3];
d792 1
a792 1
	while ((c = getopt(argc, argv, "?aDf:FhI:nN:o:O:psS:tvxX")) != -1)
d797 3
d835 3
d839 4
a842 1
			openlog(argv[0], LOG_NDELAY|LOG_PID, LOGFAC);
d913 1
d918 2
a919 1
	}
@


1.16
log
@hash & cache hostnames; garath@@code.ridgefield.org
@
text
@d1 1
a1 1
/*	$OpenBSD: ipmon.c,v 1.15 1998/10/29 02:15:21 deraadt Exp $
d10 1
a10 1
static const char rcsid[] = "@@(#)$Id: ipmon.c,v 1.15 1998/10/29 02:15:21 deraadt Exp $";
d751 1
a751 1
	while ((c = getopt(argc, argv, "?aDf:FhI:nN:o:O:sS:tvxX")) != -1)
@


1.15
log
@use correct ioctl for flushing; garath@@code.ridgefield.org
@
text
@d1 1
a1 1
/*	$OpenBSD: ipmon.c,v 1.14 1998/09/17 03:43:45 pattonme Exp $
d10 1
a10 1
static const char rcsid[] = "@@(#)$Id: ipmon.c,v 1.14 1998/09/17 03:43:45 pattonme Exp $";
d91 7
d170 1
d174 13
d189 5
a193 2
		return inet_ntoa(ip);
	return hp->h_name;
@


1.14
log
@reset variable "log" so that it would properly detach from controlling terminal.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipmon.c,v 1.13 1998/09/15 10:01:39 pattonme Exp $
d10 1
a10 1
static const char rcsid[] = "@@(#)$Id: ipmon.c,v 1.13 1998/09/15 10:01:39 pattonme Exp $";
d645 6
a650 1
	int	fd, flushed = 0;
d657 1
a657 1
	if (ioctl(fd, SIOCIPFFB, &flushed) == 0) {
@


1.13
log
@updated to v3.2.9 of Darren's codebase. His code reimplements variable
locking, replaces u_long's with u_32_t to properly handle 64bit archs.
Wrapped OpenBSD specific preprocessor logic.
@
text
@d1 1
a1 1
/*	$OpenBSD$
d10 1
a10 1
static const char rcsid[] = "@@(#)$Id$";
d765 1
@


1.12
log
@Y2K fixes from Andreas.Gunnarsson@@emw.ericsson.se; culled from various places
@
text
@d1 1
a1 2
/*     $OpenBSD: ipmon.c,v 1.11 1998/01/26 04:16:47 dgregor Exp $      */
/*
d10 1
a10 1
static const char rcsid[] = "@@(#)$Id: ipmon.c,v 1.11 1998/01/26 04:16:47 dgregor Exp $";
d21 1
d56 5
a60 2

#include "ip_fil_compat.h"
d62 4
a65 4
#include "ip_fil.h"
#include "ip_proxy.h"
#include "ip_nat.h"
#include "ip_state.h"
d94 3
d98 1
d110 2
d130 11
d205 1
a205 1
				fputs(line, stdout);
d241 2
a242 2
		fputs(line, stdout);
		fflush(stdout);
d256 1
a256 1
	int	res;
d261 1
d263 4
a266 2
		(void) strftime(t, sizeof(line) - (t - line), "%d/%m/%Y ", tm);
		t += strlen(t);
d268 1
a268 1
	(void) strftime(t, sizeof(line) - (t - line), "%T", tm);
d321 1
a321 1
	int	res;
d326 1
d328 4
a331 2
		(void) strftime(t, sizeof(line) - (t - line), "%d/%m/%Y ", tm);
		t += strlen(t);
d333 1
a333 1
	(void) strftime(t, sizeof(line) - (t - line), "%T", tm);
d393 1
d398 12
d412 1
a412 1
			return;
d431 3
d466 1
d468 4
a471 2
		(void) strftime(t, sizeof(line) - (t - line), "%d/%m/%Y", tm);
		t += strlen(t);
d473 1
a473 1
	(void) strftime(t, sizeof(line) - (t - line), "%T", tm);
d567 3
a569 3
		(void) sprintf(t, "%s PR icmp len %hu (%hu) icmp %d/%d",
			hostname(res, ip->ip_dst), hl,
			ntohs(ip->ip_len), ic->icmp_type, ic->icmp_code);
d711 1
a711 1
	int	fdt[3], devices = 0;
d722 1
a722 1
	while ((c = getopt(argc, argv, "?af:FhI:nN:o:O:sS:tvxX")) != -1)
d728 3
d819 2
a820 1
		log = argv[optind] ? fopen(argv[optind], "a") : stdout;
a827 2
	} else {
		daemon(0, 0);
d830 11
d863 9
@


1.11
log
@IPF 3.2.3
@
text
@d1 1
a1 1
/*     $OpenBSD$      */
d11 1
a11 1
static const char rcsid[] = "@@(#)$Id: ipmon.c,v 2.0.2.29.2.4 1997/11/28 06:14:46 darrenr Exp $";
d242 1
a242 2
		(void) sprintf(t, "%2d/%02d/%4d ",
			tm->tm_mday, tm->tm_mon + 1, tm->tm_year + 1900);
d245 3
a247 3
	(void) sprintf(t, "%02d:%02d:%02d.%-.6ld @@%hd ",
		tm->tm_hour, tm->tm_min, tm->tm_sec, ipl->ipl_usec,
		nl->nl_rule+1);
d304 1
a304 2
		(void) sprintf(t, "%2d/%02d/%4d ",
			tm->tm_mday, tm->tm_mon + 1, tm->tm_year + 1900);
d307 3
a309 2
	(void) sprintf(t, "%02d:%02d:%02d.%-.6ld ",
		tm->tm_hour, tm->tm_min, tm->tm_sec, ipl->ipl_usec);
d425 1
a425 2
		(void) sprintf(t, "%2d/%02d/%4d ",
			tm->tm_mday, tm->tm_mon + 1, tm->tm_year + 1900);
d428 3
a430 2
	(void) sprintf(t, "%02d:%02d:%02d.%-.6ld ", tm->tm_hour, tm->tm_min,
		tm->tm_sec, ipl->ipl_usec);
@


1.10
log
@daemonize if using syslog(3)
@
text
@d1 1
d3 1
a3 1
 * (C)opyright 1993-1996 by Darren Reed.
d9 4
a14 1
#include <assert.h>
d16 1
d18 2
a19 8
#include <string.h>
#include <stdlib.h>
#include <syslog.h>
#include <sys/errno.h>
#include <sys/file.h>
#include <sys/ioctl.h>
#include <sys/param.h>
#include <sys/uio.h>
d21 1
a22 1
#include <sys/mbuf.h>
d24 1
d27 6
a32 1
#include <sys/protosw.h>
d34 1
a34 3
#include <sys/user.h>

#include <net/if.h>
d37 1
a38 4
#include <netinet/ip_var.h>
#include <netinet/tcp.h>
#include <netinet/tcpip.h>
#include <netinet/ip_icmp.h>
d41 2
a42 1
#include <ctype.h>
d44 5
a48 2
#if !defined(lint) && defined(LIBC_SCCS)
static	char	rcsid[] = "$Id: ipmon.c,v 1.9 1997/06/23 16:53:59 kstailey Exp $";
d51 6
d58 1
d60 11
a89 1
static	void	printpacket(), dumphex();
d91 24
a114 6

#define	OPT_SYSLOG	0x01
#define	OPT_RESOLVE	0x02
#define	OPT_HEXBODY	0x04
#define	OPT_VERBOSE	0x08
#define	OPT_HEXHDR	0x10
a119 67
void printiplci(icp)
struct ipl_ci *icp;
{
	printf("sec %ld usec %ld hlen %d plen %d\n", icp->sec, icp->usec,
		icp->hlen, icp->plen);
}


void resynclog(fd, iplcp, log)
int fd;
struct ipl_ci *iplcp;
FILE *log;
{
	time_t	now;
	char	*s = NULL;
	int	len, nr = 0;

	do {
		if (s) {
			s = (char *)&iplcp->sec;
			if (opts & OPT_SYSLOG) {
				syslog(LOG_INFO, "Sync bytes:");
				syslog(LOG_INFO, " %02x %02x %02x %02x",
					*s, *(s+1), *(s+2), *(s+3));
				syslog(LOG_INFO, " %02x %02x %02x %02x\n",
					*(s+4), *(s+5), *(s+6), *(s+7));
			} else {
				fprintf(log, "Sync bytes:");
				fprintf(log, " %02x %02x %02x %02x",
					*s, *(s+1), *(s+2), *(s+3));
				fprintf(log, " %02x %02x %02x %02x\n",
					*(s+4), *(s+5), *(s+6), *(s+7));
			}
		}
		do {
			s = (char *)&iplcp->sec;
			len = sizeof(iplcp->sec);
			while (len) {
				switch ((nr = read(fd, s, len)))
				{
				case -1:
				case 0:
					return;
				default :
					s += nr;
					len -= nr;
					now = time(NULL);
					break;
				}
			}
		} while ((now < iplcp->sec) ||
			 ((iplcp->sec - now) > (86400*5)));

		len = sizeof(iplcp->usec);
		while (len) {
			switch ((nr = read(fd, s, len)))
			{
			case -1:
			case 0:
				return;
			default :
				s += nr;
				len -= nr;
				break;
			}
		}
	} while (iplcp->usec > 1000000);
d121 1
a121 17
	len = sizeof(*iplcp) - sizeof(iplcp->sec) - sizeof(iplcp->usec);
	while (len) {
		switch ((nr = read(fd, s, len)))
		{
		case -1:
		case 0:
			return;
		default :
			s += nr;
			len -= nr;
			break;
		}
	}
}


int readlogentry(fd, lenp, buf, bufsize, log)
d126 1
a126 26
	struct	ipl_ci	*icp = (struct ipl_ci *)buf;
	time_t	now;
	char	*s;
	int	len, n = bufsize, tr = sizeof(struct ipl_ci), nr;

	if (bufsize < tr)
		return 1;
	for (s = buf; (n > 0) && (tr > 0); s += nr, n -= nr) {
		nr = read(fd, s, tr);
		if (nr > 0)
			tr -= nr;
		else
			return -1;
	}

	now = time(NULL);
	if ((icp->hlen > 92) || (now < icp->sec) ||
	    ((now - icp->sec) > (86400*5))) {
		if (opts & OPT_SYSLOG)
			syslog(LOG_INFO, "Out of sync! (1,%x)\n", now);
		else
			fprintf(log, "Out of sync! (1,%x)\n", now);
		dumphex(log, buf, sizeof(struct ipl_ci));
		resynclog(fd, icp, log);
	}

d128 6
a133 23
	len = (int)((u_int)icp->plen);
	if (len > 128 || len < 0) {
		if (opts & OPT_SYSLOG)
			syslog(LOG_INFO, "Out of sync! (2,%d)\n", len);
		else
			fprintf(log, "Out of sync! (2,%d)\n", len);
		dumphex(log, buf, sizeof(struct ipl_ci));
		resynclog(fd, icp, log);
	}


	tr = icp->hlen + icp->plen;
	if (n < tr)
		return 1;

	for (; (n > 0) && (tr > 0); s += nr, n-= nr) {
		nr = read(fd, s, tr);
		if (nr > 0)
			tr -= nr;
		else
			return -1;
	}
	*lenp = s - buf;
d162 1
a162 1
	if (!res)
d184 4
a187 1
			fputs(line, log);
d191 1
a191 1
		sprintf(t, "%02x", *s & 0xff);
d195 1
a195 1
			sprintf(t, "        ");
d212 1
a212 1
		sprintf(t, "       ");
d220 66
a285 2
	fputs(line, log);
	fflush(log);
d289 108
a396 1
static	void	printpacket(log, buf, blen)
a403 1
	struct	ip	*ipc;
d407 8
a414 10
	int	i, lvl, res;
#if !SOLARIS && !(defined(NetBSD) && (NetBSD <= 1991011) && (NetBSD >= 199603))\
	&& !(defined(OpenBSD) && (OpenBSD <= 1991011) && (OpenBSD >= 199603))
	int	len;
#endif
	struct	ip	*ip;
	struct	ipl_ci	*lp;

	lp = (struct ipl_ci *)buf;
	ip = (struct ip *)(buf + sizeof(*lp));
d420 5
a424 1
	tm = localtime((time_t *)&lp->sec);
d430 12
a441 5
#if SOLARIS || (defined(NetBSD) && (NetBSD <= 1991011) && (NetBSD >= 199603)) \
	|| (defined(OpenBSD) && (OpenBSD <= 1991011) && (OpenBSD >= 199603))
	(void) sprintf(t, "%02d:%02d:%02d.%-.6ld %.*s @@%hd ",
		tm->tm_hour, tm->tm_min, tm->tm_sec, lp->usec,
		(int)sizeof(lp->ifname), lp->ifname, lp->rule);
d444 1
a444 1
		if (!lp->ifname[len])
d446 1
a446 1
	if (lp->ifname[len])
d448 1
a448 3
	(void) sprintf(t, "%02d:%02d:%02d.%-.6ld %*.*s%ld @@%hd ",
		tm->tm_hour, tm->tm_min, tm->tm_sec, lp->usec,
		len, len, lp->ifname, lp->unit, lp->rule);
d450 2
d459 1
a459 1
 	if (lp->flags & (FI_SHORT << 20)) {
d462 2
a463 2
	} else if (lp->flags & FR_PASS) {
		if (lp->flags & FR_LOGP)
d468 2
a469 2
	} else if (lp->flags & FR_BLOCK) {
		if (lp->flags & FR_LOGB)
d474 1
a474 1
	} else if (lp->flags & FF_LOGNOMATCH) {
d488 1
a488 1
		if (!(lp->flags & (FI_SHORT << 16))) {
d525 1
a525 1
			ip->ip_len, ic->icmp_type, ic->icmp_code);
d566 1
a566 1
	if (lp->flags & FR_KEEPSTATE) {
d571 1
a571 1
	if (lp->flags & FR_KEEPFRAG) {
d583 1
a583 1
		dumphex(log, buf, sizeof(struct ipl_ci));
d585 71
a655 3
		dumphex(log, ip, lp->plen + lp->hlen);
	if (!(opts & OPT_SYSLOG))
		fflush(log);
d658 1
d663 6
a668 3
	FILE	*log = NULL;
	int	fd = -1, flushed = 0, doread, n;
	char	buf[512], c, *iplfile = IPL_NAME;
d672 7
a678 1
	while ((c = getopt(argc, argv, "Nf:FsvxX")) != -1)
d681 7
a687 2
		case 'f' :
			iplfile = optarg;
d690 6
a695 12
			if ((fd == -1) &&
			    (fd = open(iplfile, O_RDWR)) == -1) {
				(void) fprintf(stderr, "%s: ", IPL_NAME);
				perror("open");
				exit(-1);
			}
			if (ioctl(fd, SIOCIPFFB, &flushed) == 0) {
				printf("%d bytes flushed from log buffer\n",
					flushed);
				fflush(stdout);
			} else
				perror("SIOCIPFFB");
d698 16
a713 1
			opts |= OPT_RESOLVE;
d719 8
d736 4
d742 27
a768 4
	if ((fd == -1) && (fd = open(iplfile, O_RDONLY)) == -1) {
		(void) fprintf(stderr, "%s: ", IPL_NAME);
		perror("open");
		exit(-1);
d773 6
d784 20
a803 7
	if (flushed) {
		if (opts & OPT_SYSLOG)
			syslog(LOG_INFO, "%d bytes flushed from log\n",
				flushed);
		else
			fprintf(log, "%d bytes flushed from log\n", flushed);
	}
d805 27
a831 22
	for (doread = 1; doread; )
		switch (readlogentry(fd, &n, buf, sizeof(buf), log))
		{
		case -1 :
			if (opts & OPT_SYSLOG)
				syslog(LOG_ERR, "read: %m\n");
			else
				perror("read");
			doread = 0;
			break;
		case 1 :
			if (opts & OPT_SYSLOG)
				syslog(LOG_ERR, "aborting logging\n");
			else
				fprintf(log, "aborting logging\n");
			doread = 0;
			break;
		case 2 :
			break;
		case 0 :
			printpacket(log, buf, n, opts);
			break;
d833 3
@


1.9
log
@only flush log if not using syslog
@
text
@d44 1
a44 1
static	char	rcsid[] = "$Id: ipmon.c,v 1.8 1997/06/09 09:52:33 niklas Exp $";
d551 2
@


1.8
log
@Log packet contents to the specified logfile,
if they are wanted
@
text
@d44 1
a44 1
static	char	rcsid[] = "$Id: ipmon.c,v 1.7 1997/02/11 22:24:10 kstailey Exp $";
d490 2
a491 1
	fflush(log);
@


1.7
log
@IPF 1.3.7
@
text
@d44 1
a44 1
static	char	rcsid[] = "$Id: ipmon.c,v 2.0.1.2 1997/02/04 14:49:19 darrenr Exp $";
d270 1
a270 1
			fputs(line, stdout);
d303 2
a304 2
	fputs(line, stdout);
	fflush(stdout);
@


1.6
log
@Prototype & Stylistic fixes for high -W gcc levels
@
text
@d14 2
a15 1
#include <sys/syslog.h>
d41 1
d43 2
a44 3
#ifndef	lint
static	char	sccsid[] = "@@(#)ipmon.c	1.21 6/5/96 (C)1993-1996 Darren Reed";
static	char	rcsid[] = "$Id: ipmon.c,v 1.5 1996/09/30 17:52:41 deraadt Exp $";
d50 1
d66 1
d68 154
a221 1
static	void	printpacket();
d257 1
a257 1
static	void	dumphex(log, ip, lp)
d259 2
a260 2
struct	ip	*ip;
struct	ipl_ci	*lp;
d262 1
d264 1
a264 1
	u_char	*s = (u_char *)ip;
d266 10
a275 4
	for (i = lp->plen + lp->hlen, j = 0; i; i--, j++, s++) {
		if (j && !(j & 0xf))
			putchar('\n');
		printf("%02x", *s);
d277 3
a279 2
			s -= 16;
			printf("        ");
d281 2
a282 1
				putchar(isprint(*s) ? *s : '.');
d286 1
a286 1
			putchar(' ');
d289 16
a304 2
	if ((j - 1) & 0xf)
		putchar('\n');
d308 1
a308 1
static	void	printpacket(log, ip, lp, opts)
d310 2
a311 3
struct	ip	*ip;
struct	ipl_ci	*lp;
int	opts;
d320 7
a326 1
	int	i, lvl, res, len;
d328 3
a330 1
	res = (opts & 2) ? 1 : 0;
d336 1
a336 1
	if (!(opts & 1)) {
d341 3
a343 3
#if (defined(NetBSD) && (NetBSD <= 1991011) && (NetBSD >= 199606)) || \
    (defined(OpenBSD) && (OpenBSD >= 199606))
	(void) sprintf(t, "%02d:%02d:%02d.%-.6ld %s @@%hd ",
d345 1
a345 1
		lp->ifname, lp->rule);
d409 6
d482 1
a482 1
	if (opts & 1)
d486 4
a490 2
	if (opts & 4)
		dumphex(log, ip, lp);
d497 3
a499 5
	FILE		*log;
	int		fd, flushed = 0, opts = 0;
	u_int		len;
	char		buf[512], c;
	struct ipl_ci 	iplci;
d501 1
d503 1
a503 7
	if ((fd = open(IPL_NAME, O_RDONLY)) == -1) {
		(void) fprintf(stderr, "%s: ", IPL_NAME);
		perror("open");
		exit(-1);
	}

	while ((c = getopt(argc, argv, "Nfsx")) != -1)
d507 9
d520 2
a521 1
			}
d524 8
a531 1
			opts |= 2;
d534 1
a534 1
			opts |= 4;
d536 2
a537 3
		case 's' :
			openlog(argv[0], LOG_NDELAY|LOG_PID, LOGFAC);
			opts |= 1;
d541 9
a549 14
	log = argv[optind] ? fopen(argv[1], "a") : stdout;
	setvbuf(log, NULL, _IONBF, 0);
	if (flushed)
		fprintf(log, "%d bytes flushed from log\n", flushed);

	while (1) {
		assert(read(fd, &iplci, sizeof(struct ipl_ci)) ==
			sizeof(struct ipl_ci));
		assert(iplci.hlen > 0 && iplci.hlen <= 92);
		len = (u_int)iplci.plen;
		assert(len <= 128);
		assert(read(fd, buf, iplci.hlen + iplci.plen) ==
			(iplci.hlen + iplci.plen));
		printpacket(log, buf, &iplci, opts);
d551 32
a582 1
	/* NOTREACHED */
@


1.5
log
@OpenBSD
@
text
@d43 1
a43 1
static	char	rcsid[] = "$Id: ipmon.c,v 1.4 1996/07/18 04:58:47 dm Exp $";
d46 1
@


1.4
log
@ipfilter 3.1.0
@
text
@d43 1
a43 1
static	char	rcsid[] = "$Id: ipmon.c,v 1.1.1.1 1996/06/23 07:27:15 darrenr Exp $";
d154 2
a155 1
#if (defined(NetBSD) && (NetBSD <= 1991011) && (NetBSD >= 199606))
@


1.3
log
@ipfilter 3.0.4
@
text
@d42 2
a43 1
static	char	sccsid[] = "@@(#)ipmon.c	1.20 3/24/96 (C)1993-1996 Darren Reed";
d141 1
a141 1
	int	i, lvl, res;
d154 1
a154 5
#if !defined (__OpenBSD__) && !defined (__NetBSD__)
	(void) sprintf(t, "%02d:%02d:%02d.%-.6ld %c%c%ld @@%hd ",
		tm->tm_hour, tm->tm_min, tm->tm_sec, lp->usec,
		lp->ifname[0], lp->ifname[1], lp->unit, lp->rule);
#else /* OpenBSD or NetBSD */
d158 10
a167 1
#endif /* OpenBSD or NetBSD */
d351 3
a353 1
	return 0;
@


1.2
log
@IP filter 3.0.1
@
text
@d2 1
a2 1
 * (C)opyright 1993,1994,1995 by Darren Reed.
d42 1
a42 1
static	char	sccsid[] = "@@(#)ipmon.c	1.16 1/12/96 (C)1995 Darren Reed";
d99 28
d153 1
d157 5
a194 4
#if	SOLARIS
	ip->ip_off = ntohs(ip->ip_off);
	ip->ip_len = ntohs(ip->ip_len);
#endif
d269 11
d287 2
d291 1
a291 1
main(argc, argv)
d297 1
d308 1
a308 1
	while ((c = getopt(argc, argv, "Nfs")) != -1)
d321 3
d339 2
a340 1
		assert((u_char)iplci.plen <= 128);
@


1.1
log
@from beurton@@fnet.fr:  Darren Reed's IP filter
@
text
@d42 1
a42 1
static	char	sccsid[] = "@@(#)ipmon.c	1.13 11/11/95 (C)1995 Darren Reed";
d45 1
a45 1
#include <netinet/ip_fil.h>
d125 1
a125 1
	(void) sprintf(t, "%02d:%02d:%02d.%-.6d %c%c%d @@%d ",
d135 1
a135 1
 	if (lp->flags & (FI_SHORT << 16)) {
d150 3
d161 4
d173 1
a173 1
			(void) sprintf(t, "%s,%s PR %s len %hu (%hu) ",
d179 2
a180 1
			if (p == IPPROTO_TCP)
d184 1
d189 1
a189 1
			(void) sprintf(t, "%s PR %s len %hu (%hu)",
d221 1
a221 1
			(void) sprintf(t, " %s,%s PR %s len %hu (%hu)",
d233 1
a233 1
			(void) sprintf(t, " frag %s%hu@@%hu",
d235 1
d268 5
a272 1
			(void) ioctl(fd, SIOCIPFFB, &flushed);
@
