head	1.21;
access;
symbols
	OPENBSD_5_5:1.20.0.4
	OPENBSD_5_5_BASE:1.20
	OPENBSD_5_4:1.19.0.8
	OPENBSD_5_4_BASE:1.19
	OPENBSD_5_3:1.19.0.6
	OPENBSD_5_3_BASE:1.19
	OPENBSD_5_2:1.19.0.4
	OPENBSD_5_2_BASE:1.19
	OPENBSD_5_1_BASE:1.19
	OPENBSD_5_1:1.19.0.2
	OPENBSD_5_0:1.18.0.2
	OPENBSD_5_0_BASE:1.18
	OPENBSD_4_9:1.17.0.12
	OPENBSD_4_9_BASE:1.17
	OPENBSD_4_8:1.17.0.10
	OPENBSD_4_8_BASE:1.17
	OPENBSD_4_7:1.17.0.6
	OPENBSD_4_7_BASE:1.17
	OPENBSD_4_6:1.17.0.8
	OPENBSD_4_6_BASE:1.17
	OPENBSD_4_5:1.17.0.4
	OPENBSD_4_5_BASE:1.17
	OPENBSD_4_4:1.17.0.2
	OPENBSD_4_4_BASE:1.17
	OPENBSD_4_3:1.16.0.12
	OPENBSD_4_3_BASE:1.16
	OPENBSD_4_2:1.16.0.10
	OPENBSD_4_2_BASE:1.16
	OPENBSD_4_1:1.16.0.8
	OPENBSD_4_1_BASE:1.16
	OPENBSD_4_0:1.16.0.6
	OPENBSD_4_0_BASE:1.16
	OPENBSD_3_9:1.16.0.4
	OPENBSD_3_9_BASE:1.16
	OPENBSD_3_8:1.16.0.2
	OPENBSD_3_8_BASE:1.16
	OPENBSD_3_7:1.15.0.2
	OPENBSD_3_7_BASE:1.15
	OPENBSD_3_6:1.14.0.2
	OPENBSD_3_6_BASE:1.14
	OPENBSD_3_5:1.11.0.4
	OPENBSD_3_5_BASE:1.11
	OPENBSD_3_4:1.11.0.2
	OPENBSD_3_4_BASE:1.11
	OPENBSD_3_3:1.8.0.4
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.8.0.2
	OPENBSD_3_2_BASE:1.8
	OPENBSD_3_1:1.7.0.2
	OPENBSD_3_1_BASE:1.7
	OPENBSD_3_0:1.4.0.4
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_9:1.4.0.2
	OPENBSD_2_8:1.1.1.1.0.2
	OPENBSD_2_8_BASE:1.1.1.1
	PPPOE_USER:1.1.1.1
	PPPOE:1.1.1;
locks; strict;
comment	@ * @;


1.21
date	2014.03.17.18.42.41;	author deraadt;	state dead;
branches;
next	1.20;

1.20
date	2013.11.19.15.12.23;	author mikeb;	state Exp;
branches;
next	1.19;

1.19
date	2011.11.05.09.20.36;	author yasuoka;	state Exp;
branches;
next	1.18;

1.18
date	2011.04.30.18.47.48;	author nicm;	state Exp;
branches;
next	1.17;

1.17
date	2008.06.24.08.21.46;	author sobrado;	state Exp;
branches;
next	1.16;

1.16
date	2005.05.03.05.44.35;	author djm;	state Exp;
branches;
next	1.15;

1.15
date	2004.09.20.17.51.07;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2004.05.14.17.53.51;	author canacar;	state Exp;
branches;
next	1.13;

1.13
date	2004.05.06.20.29.04;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2004.05.06.17.49.08;	author canacar;	state Exp;
branches;
next	1.11;

1.11
date	2003.08.19.22.19.07;	author itojun;	state Exp;
branches;
next	1.10;

1.10
date	2003.06.28.20.37.29;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2003.06.04.04.46.13;	author jason;	state Exp;
branches;
next	1.8;

1.8
date	2002.09.08.04.33.46;	author jason;	state Exp;
branches;
next	1.7;

1.7
date	2002.02.16.21.28.07;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.01.10.18.21.38;	author jason;	state Exp;
branches;
next	1.5;

1.5
date	2001.11.29.16.49.09;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2001.04.15.20.41.46;	author jason;	state Exp;
branches;
next	1.3;

1.3
date	2001.02.18.22.52.53;	author miod;	state Exp;
branches;
next	1.2;

1.2
date	2001.01.16.09.26.08;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	2000.06.18.07.30.41;	author jason;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.06.18.07.30.41;	author jason;	state Exp;
branches;
next	;


desc
@@


1.21
log
@to the great bit bucket in the sky...
@
text
@/*	$OpenBSD: pppoe.c,v 1.20 2013/11/19 15:12:23 mikeb Exp $	*/

/*
 * Copyright (c) 2000 Network Security Technologies, Inc. http://www.netsec.net
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include <stdio.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/ioctl.h>
#include <sys/wait.h>
#include <sys/queue.h>
#include <net/if.h>
#include <net/if_dl.h>
#include <net/if_types.h>
#include <netinet/in.h>
#include <netinet/if_ether.h>
#include <net/bpf.h>
#include <errno.h>
#include <string.h>
#include <err.h>
#include <fcntl.h>
#include <grp.h>
#include <pwd.h>
#include <unistd.h>
#include <sysexits.h>
#include <signal.h>
#include <ifaddrs.h>

#include "pppoe.h"

int option_verbose = 0;
u_char etherbroadcastaddr[6] = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };

int main(int, char **);
void usage(void);
int getifhwaddr(char *, char *, struct ether_addr *);
int setupfilter(char *, struct ether_addr *, int);
int setup_rfilter(struct bpf_insn *, struct ether_addr *, int);
int setup_wfilter(struct bpf_insn *, int);
void child_handler(int);
int signal_init(void);
void drop_privs(struct passwd *, int);

int
main(int argc, char **argv)
{
	char *ifname = NULL;
	u_int8_t *sysname = NULL, *srvname = NULL;
	char ifnambuf[IFNAMSIZ];
	struct ether_addr ea;
	int bpffd, smode = 0, c;
	struct passwd *pw;

	if ((pw = getpwnam("_ppp")) == NULL)
		err(EX_CONFIG, "getpwnam(\"_ppp\")");

	while ((c = getopt(argc, argv, "svi:n:p:")) != -1) {
		switch (c) {
		case 'i':
			if (ifname != NULL) {
				usage();
				return (EX_USAGE);
			}
			ifname = optarg;
			break;
		case 'n':
			if (srvname != NULL) {
				usage();
				return (EX_USAGE);
			}
			srvname = (u_int8_t *)optarg;
			break;
		case 'p':
			if (sysname != NULL) {
				usage();
				return (EX_USAGE);
			}
			sysname = (u_int8_t *)optarg;
			break;
		case 's':
			if (smode) {
				usage();
				return (EX_USAGE);
			}
			smode = 1;
			break;
		case 'v':
			option_verbose++;
			break;
		default:
			usage();
			return (EX_USAGE);
		}
	}

	argc -= optind;
	if (argc != 0) {
		usage();
		return (EX_USAGE);
	}

	if (getifhwaddr(ifname, ifnambuf, &ea) < 0)
		return (EX_IOERR);

	bpffd = setupfilter(ifnambuf, &ea, smode);
	if (bpffd < 0)
		return (EX_IOERR);

	drop_privs(pw, smode);

	signal_init();

	if (smode)
		server_mode(bpffd, sysname, srvname, &ea);
	else
		client_mode(bpffd, sysname, srvname, &ea);

	return (0);
}

#define MAX_INSNS	20

/* bpf read filter */
int
setup_rfilter(struct bpf_insn *insns, struct ether_addr *ea, int server_mode)
{
	u_int8_t *ep = (u_int8_t *)ea;
	int idx = 0;

	/* allow session or discovery packets */
	insns[idx].code = BPF_LD | BPF_H | BPF_ABS;
	insns[idx].k = 12;
	insns[idx].jt = insns[idx].jf = 0;
	idx++;

	insns[idx].code = BPF_JMP | BPF_JEQ | BPF_K;
	insns[idx].k = ETHERTYPE_PPPOE;
	insns[idx].jt = 1;
	insns[idx].jf = 0;
	idx++;

	insns[idx].code = BPF_JMP | BPF_JEQ | BPF_K;
	insns[idx].k = ETHERTYPE_PPPOEDISC;
	insns[idx].jt = 0;
	insns[idx].jf = 4;
	idx++;

	/* reject packets containing our address as source */
	insns[idx].code = BPF_LD | BPF_W | BPF_ABS;
	insns[idx].k = 6;
	insns[idx].jt = insns[idx].jf = 0;
	idx++;

	insns[idx].code = BPF_JMP | BPF_JEQ | BPF_K;
	insns[idx].k =
	    (ep[0] << 24) | (ep[1] << 16) | (ep[2] << 8) | (ep[3] << 0);
	insns[idx].jt = 0;
	insns[idx].jf = 3;
	idx++;

	insns[idx].code = BPF_LD | BPF_H | BPF_ABS;
	insns[idx].k = 10;
	insns[idx].jt = insns[idx].jf = 0;
	idx++;

	insns[idx].code = BPF_JMP | BPF_JEQ | BPF_K;
	insns[idx].k = (ep[4] << 8) | (ep[5] << 0);
	insns[idx].jt = 0;
	insns[idx].jf = 1;
	idx++;

	insns[idx].code = BPF_RET | BPF_K;
	insns[idx].k = insns[idx].jt = insns[idx].jf = 0;
	idx++;

	if (server_mode) {
		/* if server mode, allow broadcast as destination */
		insns[idx].code = BPF_LD | BPF_W | BPF_ABS;
		insns[idx].k = insns[idx].jt = insns[idx].jf = 0;
		idx++;

		insns[idx].code = BPF_JMP | BPF_JEQ | BPF_K;
		insns[idx].k = 0xffffffff;
		insns[idx].jt = 0;
		insns[idx].jf = 3;
		idx++;

		insns[idx].code = BPF_LD | BPF_H | BPF_ABS;
		insns[idx].k = 4;
		insns[idx].jt = insns[idx].jf = 0;
		idx++;

		insns[idx].code = BPF_JMP | BPF_JEQ | BPF_K;
		insns[idx].k = 0xffff;
		insns[idx].jt = 4;
		insns[idx].jf = 0;
		idx++;
	}

	/* make sure packet is destined to our address */
	insns[idx].code = BPF_LD | BPF_W | BPF_ABS;
	insns[idx].k = insns[idx].jt = insns[idx].jf = 0;
	idx++;

	insns[idx].code = BPF_JMP | BPF_JEQ | BPF_K;
	insns[idx].k =
	    (ep[0] << 24) | (ep[1] << 16) | (ep[2] << 8) | (ep[3] << 0);
	insns[idx].jt = 0;
	insns[idx].jf = 3;
	idx++;

	insns[idx].code = BPF_LD | BPF_H | BPF_ABS;
	insns[idx].k = 4;
	insns[idx].jt = insns[idx].jf = 0;
	idx++;

	insns[idx].code = BPF_JMP | BPF_JEQ | BPF_K;
	insns[idx].k = (ep[4] << 8) | (ep[5] << 0);
	insns[idx].jt = 0;
	insns[idx].jf = 1;
	idx++;

	insns[idx].code = BPF_RET | BPF_K;
	insns[idx].k = (u_int)-1;
	insns[idx].jt = insns[idx].jf = 0;
	idx++;

	insns[idx].code = BPF_RET | BPF_K;
	insns[idx].k = insns[idx].jt = insns[idx].jf = 0;
	idx++;

	return idx;
}

/* bpf write filter */
int
setup_wfilter(struct bpf_insn *insns, int server_mode)
{
	int idx = 0;

	/* check if dest is broadcast */
	insns[idx].code = BPF_LD | BPF_W | BPF_ABS;
	insns[idx].k = insns[idx].jt = insns[idx].jf = 0;
	idx++;

	insns[idx].code = BPF_JMP | BPF_JEQ | BPF_K;
	insns[idx].k = 0xffffffff;
	insns[idx].jt = 0;
	insns[idx].jf = 2;
	idx++;

	insns[idx].code = BPF_LD | BPF_H | BPF_ABS;
	insns[idx].k = 4;
	insns[idx].jt = insns[idx].jf = 0;
	idx++;

	insns[idx].code = BPF_JMP | BPF_JEQ | BPF_K;
	insns[idx].k = 0xffff;
	insns[idx].jt = 4;
	insns[idx].jf = 0;
	idx++;

	/* dest not broadcast, check type for session or discovery */
	insns[idx].code = BPF_LD | BPF_H | BPF_ABS;
	insns[idx].k = 12;
	insns[idx].jt = insns[idx].jf = 0;
	idx++;

	insns[idx].code = BPF_JMP | BPF_JEQ | BPF_K;
	insns[idx].k = ETHERTYPE_PPPOE;
	insns[idx].jt = 1;
	insns[idx].jf = 0;
	idx++;

	insns[idx].code = BPF_JMP | BPF_JEQ | BPF_K;
	insns[idx].k = ETHERTYPE_PPPOEDISC;
	insns[idx].jt = 0;
	insns[idx].jf = (server_mode) ? 1 : 4;
	idx++;

	insns[idx].code = BPF_RET | BPF_K;
	insns[idx].k = (u_int)-1;
	insns[idx].jt = insns[idx].jf = 0;
	idx++;

	/* packet is broadcast */
	if (! server_mode) {
		/* only allowed for discovery in client mode */
		insns[idx].code = BPF_LD | BPF_H | BPF_ABS;
		insns[idx].k = 12;
		insns[idx].jt = insns[idx].jf = 0;
		idx++;

		insns[idx].code = BPF_JMP | BPF_JEQ | BPF_K;
		insns[idx].k = ETHERTYPE_PPPOEDISC;
		insns[idx].jt = 0;
		insns[idx].jf = 1;
		idx++;

		insns[idx].code = BPF_RET | BPF_K;
		insns[idx].k = (u_int)-1;
		insns[idx].jt = insns[idx].jf = 0;
		idx++;
	}

	insns[idx].code = BPF_RET | BPF_K;
	insns[idx].k = insns[idx].jt = insns[idx].jf = 0;
	idx++;

	return idx;
}

int
setupfilter(char *ifn, struct ether_addr *ea, int server_mode)
{
	char device[sizeof "/dev/bpf0000000000"];
	int fd, idx = 0;
	u_int u, i;
	struct ifreq ifr;
	struct bpf_insn insns[MAX_INSNS];
	struct bpf_program filter;

	for (i = 0; ; i++) {
		snprintf(device, sizeof(device), "/dev/bpf%d", i);
		fd = open(device, O_RDWR);
		if (fd < 0) {
			if (errno != EBUSY)
				err(EX_IOERR, "%s", device);
		}
		else
			break;
	}

	u = PPPOE_BPF_BUFSIZ;
	if (ioctl(fd, BIOCSBLEN, &u) < 0) {
		close(fd);
		err(EX_IOERR, "set snaplength");
	}

	u = 1;
	if (ioctl(fd, BIOCIMMEDIATE, &u) < 0) {
		close(fd);
		err(EX_IOERR, "set immediate");
	}

	strlcpy(ifr.ifr_name, ifn, IFNAMSIZ);
	if (ioctl(fd, BIOCSETIF, &ifr) < 0) {
		close(fd);
		err(EX_IOERR, "set interface");
	}

	if (ioctl(fd, BIOCGDLT, &u) < 0) {
		close(fd);
		err(EX_IOERR, "get interface type");
	}
	if (u != DLT_EN10MB)
		err(EX_IOERR, "%s is not ethernet", ifn);


	idx = setup_rfilter(insns, ea, server_mode);

	filter.bf_len = idx;
	filter.bf_insns = insns;

	if (ioctl(fd, BIOCSETF, &filter) < 0) {
		close(fd);
		err(EX_IOERR, "BIOCSETF");
	}

	idx = setup_wfilter(insns, server_mode);

	filter.bf_len = idx;
	filter.bf_insns = insns;

	if (ioctl(fd, BIOCSETWF, &filter) < 0) {
		close(fd);
		err(EX_IOERR, "BIOCSETWF");
	}

	/* lock the descriptor against changes */
	if (ioctl(fd, BIOCLOCK) < 0) {
		close(fd);
		err(EX_IOERR, "BIOCLOCK");
	}

	return (fd);
}

int
getifhwaddr(char *ifnhint, char *ifnambuf, struct ether_addr *ea)
{
	struct sockaddr_dl *dl;
	struct ifaddrs *ifap, *ifa;

	if (getifaddrs(&ifap) != 0) {
		perror("getifaddrs");
		return (-1);
	}

	for (ifa = ifap; ifa; ifa = ifa->ifa_next) {
		if (ifa->ifa_addr->sa_family != AF_LINK)
			continue;
		if (ifnhint != NULL && strcmp(ifnhint, ifa->ifa_name))
			continue;
		if (ifnhint == NULL) {
			if ((ifa->ifa_flags & IFF_UP) == 0)
				continue;
		}
		dl = (struct sockaddr_dl *)ifa->ifa_addr;
		if (dl->sdl_type != IFT_ETHER) {
			if (ifnhint == NULL)
				continue;
			fprintf(stderr, "not ethernet interface: %s\n",
				ifnhint);
			freeifaddrs(ifap);
			return (-1);
		}
		if (dl->sdl_alen != ETHER_ADDR_LEN) {
			fprintf(stderr, "invalid hwaddr len: %u\n",
				dl->sdl_alen);
			freeifaddrs(ifap);
			return (-1);
		}
		bcopy(dl->sdl_data + dl->sdl_nlen, ea, sizeof(*ea));
		strlcpy(ifnambuf, ifa->ifa_name, IFNAMSIZ);
		freeifaddrs(ifap);
		return (0);
	}
	freeifaddrs(ifap);
	if (ifnhint == NULL)
		fprintf(stderr, "no running ethernet found\n");
	else
		fprintf(stderr, "no such interface: %s\n", ifnhint);
	return (-1);
}

void
usage(void)
{
	extern char *__progname;

	fprintf(stderr,
	    "usage: %s [-sv] [-i interface] [-n service] [-p system]\n",
	    __progname);
}

void
child_handler(int sig)
{
	int save_errno = errno;
	int status;

	while (wait3(&status, WNOHANG, NULL) > 0)
		;
	errno = save_errno;
}

int
signal_init(void)
{
	struct sigaction act;

	if (sigemptyset(&act.sa_mask) < 0)
		return (-1);
	act.sa_flags = SA_RESTART;
	act.sa_handler = child_handler;
	if (sigaction(SIGCHLD, &act, NULL) < 0)
		return (-1);

	if (sigemptyset(&act.sa_mask) < 0)
		return (-1);
	act.sa_flags = 0;
	act.sa_handler = SIG_IGN;
	if (sigaction(SIGPIPE, &act, NULL) < 0)
		return (-1);

	return (0);
}

void
drop_privs(struct passwd *pw, int server_mode)
{
	int ng = 1;
	gid_t groups[2];
	struct group *gr;

	groups[0] = pw->pw_gid;

	if (server_mode) {
		if ((gr = getgrnam("network")) == NULL)
			err(EX_CONFIG, "getgrnam(\"network\")");
		groups[ng++] = gr->gr_gid;
	} else {
		if (chroot(pw->pw_dir) == -1)
			err(EX_OSERR, "chroot: %s", pw->pw_dir);
		if (chdir("/") == -1)
			err(EX_OSERR, "chdir");
	}

	if (setgroups(ng, groups))
		err(EX_OSERR, "setgroups");
	if (setresgid(pw->pw_gid, pw->pw_gid, pw->pw_gid))
		err(EX_OSERR, "setresgid");
	if (setresuid(pw->pw_uid, pw->pw_uid, pw->pw_uid))
		err(EX_OSERR, "setresuid");

	endpwent();
}
@


1.20
log
@include queue.h directly instead of relying on if.h to provide it;
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: pppoe.c,v 1.19 2011/11/05 09:20:36 yasuoka Exp $	*/
@


1.19
log
@Remove unnecessary #include's.  From Michael W. Bombardieri.

No binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: pppoe.c,v 1.18 2011/04/30 18:47:48 nicm Exp $	*/
d33 1
@


1.18
log
@Use gid_t for setgroups(), from Michael W Bombardieri. ok yasuoka
@
text
@d1 1
a1 1
/*	$OpenBSD: pppoe.c,v 1.17 2008/06/24 08:21:46 sobrado Exp $	*/
a29 2
#include <sys/uio.h>
#include <sys/time.h>
a46 1
#include <stdlib.h>
@


1.17
log
@missing "usage:"
@
text
@d1 1
a1 1
/*	$OpenBSD: pppoe.c,v 1.16 2005/05/03 05:44:35 djm Exp $	*/
d507 2
a508 1
	int groups[2], ng = 1;
@


1.16
log
@setres[ug]id; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pppoe.c,v 1.15 2004/09/20 17:51:07 miod Exp $	*/
d466 2
a467 1
	fprintf(stderr,"%s [-sv] [-i interface] [-n service] [-p system]\n",
@


1.15
log
@addres -> address
@
text
@d1 1
a1 1
/*	$OpenBSD: pppoe.c,v 1.14 2004/05/14 17:53:51 canacar Exp $	*/
d524 4
a527 12

	if (setegid(pw->pw_gid))
		err(EX_OSERR, "setegid");

	if (setgid(pw->pw_gid))
		err(EX_OSERR, "setgid");

	if (seteuid(pw->pw_uid))
		err(EX_OSERR, "seteuid");

	if (setuid(pw->pw_uid))
		err(EX_OSERR, "setuid");
@


1.14
log
@Fix pppoe server mode. pppoe no longer chroots in server mode.
the command 'allow users _ppp' must be added to the relevant section in
ppp.conf. Found, tested and help claudio@@ put that pppoe in deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pppoe.c,v 1.13 2004/05/06 20:29:04 deraadt Exp $	*/
d224 1
a224 1
	/* make sure packet is destined to our addres */
@


1.13
log
@knf and other cleanups
@
text
@d1 1
a1 1
/*	$OpenBSD: pppoe.c,v 1.12 2004/05/06 17:49:08 canacar Exp $	*/
d45 1
d66 1
a66 1
void drop_privs(struct passwd *pw);
d133 1
a133 1
	drop_privs(pw);
d504 1
a504 1
drop_privs(struct passwd *pw)
d506 2
a507 3
	
	if (chroot(pw->pw_dir) == -1)
		err(EX_OSERR, "chroot: %s", pw->pw_dir);
d509 1
a509 2
	if (chdir("/") == -1)
		err(EX_OSERR, "chdir");
d511 12
a522 1
	if (setgroups(1, &pw->pw_gid))
@


1.12
log
@pppoe now drops privileges to user _ppp and chroots after setting
write filters and locking its bpf descriptor. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pppoe.c,v 1.11 2003/08/19 22:19:07 itojun Exp $	*/
d68 2
a69 1
main(int argc, char **argv) {
d148 1
a148 4
setup_rfilter(insns, ea, server_mode)
	struct bpf_insn *insns;
	struct ether_addr *ea;
	int server_mode;
d260 1
a260 3
setup_wfilter(insns, server_mode)
	struct bpf_insn *insns;
	int server_mode;
d337 1
a337 4
setupfilter(ifn, ea, server_mode)
	char *ifn;
	struct ether_addr *ea;
	int server_mode;
d413 1
a413 3
getifhwaddr(ifnhint, ifnambuf, ea)
	char *ifnhint, *ifnambuf;
	struct ether_addr *ea;
d470 1
a470 2
child_handler(sig)
	int sig;
@


1.11
log
@rewrite SIOCGIFCONF into getifaddrs.  deraadt ok
@
text
@d1 1
a1 1
/*	$OpenBSD: pppoe.c,v 1.10 2003/06/28 20:37:29 deraadt Exp $	*/
d45 1
d61 2
d65 1
d74 4
d131 2
d143 3
d147 2
a148 2
setupfilter(ifn, ea, server_mode)
	char *ifn;
a151 1
	char device[sizeof "/dev/bpf0000000000"];
d153 1
a153 7
	int fd, idx = 0;
	u_int u, i;
	struct ifreq ifr;
	struct bpf_insn insns[20];
	struct bpf_program filter;

	idx = 0;
d155 1
d173 1
d202 1
d225 1
d257 95
a351 2
	filter.bf_len = idx;
	filter.bf_insns = insns;
d389 6
d400 16
d510 28
@


1.10
log
@() to (void)
@
text
@d1 1
a1 1
/*	$OpenBSD: pppoe.c,v 1.9 2003/06/04 04:46:13 jason Exp $	*/
d49 1
a298 4
	int s;
	char *inbuf = NULL;
	struct ifconf ifc;
	struct ifreq *ifrp, ifreq, req;
d300 1
a300 1
	int len = 8192, i;
d302 2
a303 3
	s = socket(AF_INET, SOCK_DGRAM, 0);
	if (s < 0) {
		perror("socket");
d307 2
a308 20
	while (1) {
		ifc.ifc_len= len;
		ifc.ifc_buf = inbuf = realloc(inbuf, len);
		if (inbuf == NULL)
			err(1, "malloc");
		if (ioctl(s, SIOCGIFCONF, &ifc) < 0)
			err(1, "gifconf");
		if (ifc.ifc_len + sizeof(struct ifreq) < len)
			break;
		len *= 2;
	}

	ifrp = ifc.ifc_req;
	ifreq.ifr_name[0] = '\0';
	for (i = 0; i < ifc.ifc_len; ) {
		ifrp = (struct ifreq *)((caddr_t)ifc.ifc_req + i);
		i += sizeof(ifrp->ifr_name) +
		    (ifrp->ifr_addr.sa_len > sizeof(struct sockaddr) ?
		    ifrp->ifr_addr.sa_len : sizeof(struct sockaddr));
		if (ifrp->ifr_addr.sa_family != AF_LINK)
d310 1
a310 2
		if (ifnhint != NULL && strncmp(ifnhint, ifrp->ifr_name,
		    sizeof(ifrp->ifr_name)))
d313 1
a313 4
			strlcpy(req.ifr_name, ifrp->ifr_name, IFNAMSIZ);
			if (ioctl(s, SIOCGIFFLAGS, &req) < 0)
				err(EX_IOERR, "get flags");
			if ((req.ifr_flags & IFF_UP) == 0)
d316 1
a316 1
		dl = (struct sockaddr_dl *)&ifrp->ifr_addr;
d322 1
a322 2
			free(inbuf);
			close(s);
d328 1
a328 2
			free(inbuf);
			close(s);
d332 2
a333 3
		strlcpy(ifnambuf, ifrp->ifr_name, IFNAMSIZ);
		free(inbuf);
		close(s);
d336 1
a336 1
	free(inbuf);
a340 1
	close(s);
@


1.9
log
@kill terms 3 & 4
@
text
@d1 1
a1 1
/*	$OpenBSD: pppoe.c,v 1.8 2002/09/08 04:33:46 jason Exp $	*/
d375 1
a375 1
usage()
d396 1
a396 1
signal_init()
@


1.8
log
@Fix a bunch of -pedantic errors
@
text
@d1 1
a1 1
/*	$OpenBSD: pppoe.c,v 1.7 2002/02/16 21:28:07 millert Exp $	*/
a4 1
 * All rights reserved.
a13 6
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Network Security
 *	Technologies, Inc.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.7
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: pppoe.c,v 1.6 2002/01/10 18:21:38 jason Exp $	*/
d71 2
a72 1
	char *ifname = NULL, *sysname = NULL, *srvname = NULL;
d91 1
a91 1
			srvname = optarg;
d98 1
a98 1
			sysname = optarg;
@


1.6
log
@Use IFNAMSIZ for strlcpy() and also pretty the man page
(from PR2315; Jason Ackley <jason@@ackley.net>)
@
text
@d1 1
a1 1
/*	$OpenBSD: pppoe.c,v 1.5 2001/11/29 16:49:09 miod Exp $	*/
d62 6
a67 6
int main __P((int, char **));
void usage __P((void));
int getifhwaddr __P((char *, char *, struct ether_addr *));
int setupfilter __P((char *, struct ether_addr *, int));
void child_handler __P((int));
int signal_init __P((void));
@


1.5
log
@Replace strncpy() calls with adequate strlcpy() ones, and fix a cosmeto.
jason@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: pppoe.c,v 1.4 2001/04/15 20:41:46 jason Exp $	*/
d63 1
a63 1
void usage __P((char *));
d80 1
a80 1
				usage(argv[0]);
d87 1
a87 1
				usage(argv[0]);
d94 1
a94 1
				usage(argv[0]);
d101 1
a101 1
				usage(argv[0]);
d110 1
a110 1
			usage(argv[0]);
d117 1
a117 1
		usage(argv[0]);
d278 1
a278 1
	strlcpy(ifr.ifr_name, ifn, sizeof(ifr.ifr_name));
d342 1
a342 1
			strlcpy(req.ifr_name, ifrp->ifr_name, sizeof(req.ifr_name));
d366 1
a366 1
		strlcpy(ifnambuf, ifrp->ifr_name, sizeof(ifnambuf));
d381 1
a381 2
usage(progname)
	char *progname;
d383 4
a386 1
	fprintf(stderr, "%s [-s] [-v] [-p system] [-i interface]\n", progname);
@


1.4
log
@Fix several errors in the bpf program; bugs reported by
Russell T Hunt <alaric@@MIT.EDU>.
@
text
@d1 1
a1 1
/*	$OpenBSD: pppoe.c,v 1.3 2001/02/18 22:52:53 miod Exp $	*/
d278 1
a278 2
	strncpy(ifr.ifr_name, ifn, sizeof(ifr.ifr_name));
	ifr.ifr_name[sizeof(ifr.ifr_name)-1] = '\0';
d342 1
a342 2
			strncpy(req.ifr_name, ifrp->ifr_name, IFNAMSIZ);
			req.ifr_name[IFNAMSIZ-1] = '\0';
d366 1
a366 2
		strncpy(ifnambuf, ifrp->ifr_name, IFNAMSIZ);
		ifnambuf[IFNAMSIZ-1] = '\0';
@


1.3
log
@Try every bpf device, not only the even-numbered ones; jason@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: pppoe.c,v 1.2 2001/01/16 09:26:08 deraadt Exp $	*/
d189 1
a189 1
	insns[idx].k = ep[4] << 8 | ep[5];
d226 2
a227 1
	insns[idx].k = (ep[0]) | (ep[1] << 8) | (ep[3] << 16) | (ep[3] << 24);
d238 1
a238 1
	insns[idx].k = (ep[4]) | (ep[5] << 8);
d249 1
a249 3
	insns[idx].k = (u_int)-1;
	insns[idx].jt = 0;
	insns[idx].jf = 0;
@


1.2
log
@do not trash errno in signal handler
@
text
@d1 1
a1 1
/*	$OpenBSD: pppoe.c,v 1.1.1.1 2000/06/18 07:30:41 jason Exp $	*/
d256 2
a257 2
	for (i = 0; 1; i++) {
		snprintf(device, sizeof(device), "/dev/bpf%d", i++);
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d395 1
d398 3
a400 1
	while (wait3(&status, WNOHANG, NULL) > 0);
@


1.1.1.1
log
@import my pppoe code
@
text
@@
