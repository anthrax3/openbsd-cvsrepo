head	1.26;
access;
symbols
	OPENBSD_5_5:1.25.0.4
	OPENBSD_5_5_BASE:1.25
	OPENBSD_5_4:1.24.0.8
	OPENBSD_5_4_BASE:1.24
	OPENBSD_5_3:1.24.0.6
	OPENBSD_5_3_BASE:1.24
	OPENBSD_5_2:1.24.0.4
	OPENBSD_5_2_BASE:1.24
	OPENBSD_5_1_BASE:1.24
	OPENBSD_5_1:1.24.0.2
	OPENBSD_5_0:1.23.0.2
	OPENBSD_5_0_BASE:1.23
	OPENBSD_4_9:1.21.0.14
	OPENBSD_4_9_BASE:1.21
	OPENBSD_4_8:1.21.0.12
	OPENBSD_4_8_BASE:1.21
	OPENBSD_4_7:1.21.0.8
	OPENBSD_4_7_BASE:1.21
	OPENBSD_4_6:1.21.0.10
	OPENBSD_4_6_BASE:1.21
	OPENBSD_4_5:1.21.0.6
	OPENBSD_4_5_BASE:1.21
	OPENBSD_4_4:1.21.0.4
	OPENBSD_4_4_BASE:1.21
	OPENBSD_4_3:1.21.0.2
	OPENBSD_4_3_BASE:1.21
	OPENBSD_4_2:1.20.0.14
	OPENBSD_4_2_BASE:1.20
	OPENBSD_4_1:1.20.0.12
	OPENBSD_4_1_BASE:1.20
	OPENBSD_4_0:1.20.0.10
	OPENBSD_4_0_BASE:1.20
	OPENBSD_3_9:1.20.0.8
	OPENBSD_3_9_BASE:1.20
	OPENBSD_3_8:1.20.0.6
	OPENBSD_3_8_BASE:1.20
	OPENBSD_3_7:1.20.0.4
	OPENBSD_3_7_BASE:1.20
	OPENBSD_3_6:1.20.0.2
	OPENBSD_3_6_BASE:1.20
	OPENBSD_3_5:1.17.0.4
	OPENBSD_3_5_BASE:1.17
	OPENBSD_3_4:1.17.0.2
	OPENBSD_3_4_BASE:1.17
	OPENBSD_3_3:1.16.0.4
	OPENBSD_3_3_BASE:1.16
	OPENBSD_3_2:1.16.0.2
	OPENBSD_3_2_BASE:1.16
	OPENBSD_3_1:1.14.0.2
	OPENBSD_3_1_BASE:1.14
	OPENBSD_3_0:1.11.0.4
	OPENBSD_3_0_BASE:1.11
	OPENBSD_2_9_BASE:1.11
	OPENBSD_2_9:1.11.0.2
	OPENBSD_2_8:1.5.0.2
	OPENBSD_2_8_BASE:1.5
	PPPOE_USER:1.1.1.1
	PPPOE:1.1.1;
locks; strict;
comment	@ * @;


1.26
date	2014.03.17.18.42.41;	author deraadt;	state dead;
branches;
next	1.25;

1.25
date	2013.11.19.15.12.23;	author mikeb;	state Exp;
branches;
next	1.24;

1.24
date	2011.11.05.09.20.36;	author yasuoka;	state Exp;
branches;
next	1.23;

1.23
date	2011.07.04.16.29.35;	author sthen;	state Exp;
branches;
next	1.22;

1.22
date	2011.03.31.09.19.35;	author sobrado;	state Exp;
branches;
next	1.21;

1.21
date	2007.09.03.14.26.54;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2004.09.03.06.37.14;	author tedu;	state Exp;
branches;
next	1.19;

1.19
date	2004.06.14.19.22.39;	author canacar;	state Exp;
branches;
next	1.18;

1.18
date	2004.05.06.20.29.03;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2003.06.04.04.46.13;	author jason;	state Exp;
branches;
next	1.16;

1.16
date	2002.09.08.05.10.56;	author jason;	state Exp;
branches;
next	1.15;

1.15
date	2002.09.08.04.33.46;	author jason;	state Exp;
branches;
next	1.14;

1.14
date	2002.02.17.19.42.39;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2002.02.16.21.28.07;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2001.11.17.19.54.57;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2001.04.24.05.09.23;	author jason;	state Exp;
branches;
next	1.10;

1.10
date	2001.02.04.21.25.34;	author jason;	state Exp;
branches;
next	1.9;

1.9
date	2001.01.19.17.53.17;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2001.01.16.05.34.15;	author jason;	state Exp;
branches;
next	1.7;

1.7
date	2001.01.16.05.01.39;	author jason;	state Exp;
branches;
next	1.6;

1.6
date	2001.01.12.06.12.54;	author jason;	state Exp;
branches;
next	1.5;

1.5
date	2000.10.09.22.52.18;	author brian;	state Exp;
branches;
next	1.4;

1.4
date	2000.08.03.20.21.35;	author jason;	state Exp;
branches;
next	1.3;

1.3
date	2000.06.20.04.57.47;	author jason;	state Exp;
branches;
next	1.2;

1.2
date	2000.06.20.04.55.25;	author jason;	state Exp;
branches;
next	1.1;

1.1
date	2000.06.18.07.30.41;	author jason;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.06.18.07.30.41;	author jason;	state Exp;
branches;
next	;


desc
@@


1.26
log
@to the great bit bucket in the sky...
@
text
@/*	$OpenBSD: client.c,v 1.25 2013/11/19 15:12:23 mikeb Exp $	*/

/*
 * Copyright (c) 2000 Network Security Technologies, Inc. http://www.netsec.net
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include <stdio.h>
#include <sys/types.h>
#include <sys/uio.h>
#include <sys/socket.h>
#include <sys/queue.h>
#include <net/if.h>
#include <net/if_dl.h>
#include <net/if_types.h>
#include <netinet/in.h>
#include <netinet/if_ether.h>
#include <net/bpf.h>
#include <net/ppp_defs.h>
#include <errno.h>
#include <string.h>
#include <unistd.h>
#include <stdlib.h>
#include <signal.h>

#include "pppoe.h"

#define	STATE_EXPECT_PADO	1
#define	STATE_EXPECT_PADS	2
#define	STATE_EXPECT_SESSION	3

u_int32_t client_cookie;
u_int16_t client_sessionid;
int pppfd, client_state;

static int getpackets(int, u_int8_t *, u_int8_t *, struct ether_addr *,
    struct ether_addr *);
static int send_padi(int, struct ether_addr *, u_int8_t *);
static int send_padr(int, u_int8_t *, struct ether_addr *, struct ether_addr *,
    struct ether_header *, struct pppoe_header *, struct tag_list *);
static int recv_pado(int, u_int8_t *, struct ether_addr *, struct ether_addr *,
    struct ether_header *, struct pppoe_header *, u_long, u_int8_t *);
static int recv_pads(int, u_int8_t *, u_int8_t *, struct ether_addr *,
    struct ether_addr *, struct ether_header *, struct pppoe_header *,
    u_long, u_int8_t *);
static int recv_padt(int, struct ether_addr *, struct ether_addr *,
    struct ether_header *, struct pppoe_header *, u_long, u_int8_t *);

void timer_handler(int);
int timer_set(u_int);
int timer_clr(void);
int timer_hit(void);

int
client_mode(int bfd, u_int8_t *sysname, u_int8_t *srvname, struct ether_addr *myea)
{
	struct ether_addr rmea;
	fd_set *fdsp = NULL;
	int r = 0, max, oldmax = 0;

	pppfd = -1;
	client_sessionid = 0xffff;
	client_state = -1;

	r = send_padi(bfd, myea, srvname);
	if (r <= 0)
		return (r);

	for (;;) {
		max = bfd;
		if (pppfd >= 0 && pppfd >= max)
			max = pppfd;
		max++;

		if (max > oldmax) {
			if (fdsp != NULL)
				free(fdsp);
			fdsp = (fd_set *)calloc(howmany(max, NFDBITS),
			    sizeof(fd_mask));
			if (fdsp == NULL) {
				r = -1;
				break;
			}
			oldmax = max;
		}
		bzero(fdsp, howmany(max, NFDBITS) * sizeof(fd_mask));

		if (pppfd >= 0)
			FD_SET(pppfd, fdsp);
		FD_SET(bfd, fdsp);

		r = select(max, fdsp, NULL, NULL, NULL);
		if (r < 0) {
			if (errno == EINTR) {
				if (timer_hit())
					timer_clr();
				break;
			}
			break;
		}
		if (FD_ISSET(bfd, fdsp)) {
			r = getpackets(bfd, srvname, sysname, myea, &rmea);
			if (r <= 0)
				break;
		}
		if (pppfd >= 0 && FD_ISSET(pppfd, fdsp)) {
			r = ppp_to_bpf(bfd, pppfd, myea, &rmea,
			    client_sessionid);
			if (r < 0)
				break;
		}
	}

	if (pppfd >= 0) {
		send_padt(bfd, myea, &rmea, client_sessionid);
		pppfd = -1;
	}

	if (fdsp != NULL)
		free(fdsp);

	return (r);
}

static int
send_padi(int fd, struct ether_addr *ea, u_int8_t *srv)
{
	struct iovec iov[10];
	struct pppoe_header ph = {
		PPPOE_VERTYPE(1, 1),
		PPPOE_CODE_PADI, 0, 0
	};
	struct pppoe_tag thost, tserv;
	u_int16_t etype = htons(ETHERTYPE_PPPOEDISC);
	int i = 0;

	/* ether_header */
	iov[0].iov_base = etherbroadcastaddr;
	iov[0].iov_len = ETHER_ADDR_LEN;
	iov[1].iov_base = ea;
	iov[1].iov_len = ETHER_ADDR_LEN;
	iov[2].iov_base = &etype;
	iov[2].iov_len = sizeof(etype);

	/* pppoe_header */
	iov[3].iov_base = &ph;
	iov[3].iov_len = sizeof(ph);

	/* host-uniq tag */
	client_cookie = cookie_bake();
	thost.type = htons(PPPOE_TAG_HOST_UNIQ);
	thost.len = htons(sizeof(client_cookie));
	ph.len += sizeof(thost.type)+sizeof(thost.len)+sizeof(client_cookie);
	iov[4].iov_base = &thost;
	iov[4].iov_len = sizeof(thost.len) + sizeof(thost.type) ;
	iov[5].iov_base = &client_cookie;
	iov[5].iov_len = sizeof(client_cookie);

	/* service-name tag */
	tserv.type = htons(PPPOE_TAG_SERVICE_NAME);
	tserv.len = (srv == NULL) ? 0 : strlen((char *)srv);
	tserv.val = srv;
	ph.len += tserv.len + sizeof(tserv.type) + sizeof(tserv.len);
	iov[6].iov_base = &tserv;
	iov[6].iov_len = sizeof(tserv.len) + sizeof(tserv.type);
	i = 7;
	if (tserv.len) {
		iov[7].iov_base = tserv.val;
		iov[7].iov_len = tserv.len;
		i = 8;
	}
	tserv.len = htons(tserv.len);

	ph.len = htons(ph.len);

	client_state = STATE_EXPECT_PADO;
	timer_set(10);
	return (writev(fd, iov, i));
}

static int
send_padr(int bfd, u_int8_t *srv, struct ether_addr *myea,
    struct ether_addr *rmea, struct ether_header *eh,
    struct pppoe_header *ph, struct tag_list *tl)
{
	struct iovec iov[12];
	u_int16_t etype = htons(ETHERTYPE_PPPOEDISC);
	struct pppoe_tag hutag, svtag;
	struct tag_node *n;
	int idx = 0, slen;

	timer_set(5);

	iov[idx].iov_base = rmea;
	iov[idx++].iov_len = ETHER_ADDR_LEN;
	iov[idx].iov_base = myea;
	iov[idx++].iov_len = ETHER_ADDR_LEN;
	iov[idx].iov_base = &etype;
	iov[idx++].iov_len = sizeof(etype);

	ph->vertype = PPPOE_VERTYPE(1, 1);
	ph->code = PPPOE_CODE_PADR;
	ph->len = 0;
	ph->sessionid = 0;
	iov[idx].iov_base = ph;
	iov[idx++].iov_len = sizeof(struct pppoe_header);

	/* Host-Uniq */
	hutag.type = htons(PPPOE_TAG_HOST_UNIQ);
	hutag.len = htons(sizeof(client_cookie));
	iov[idx].iov_base = &hutag;
	iov[idx++].iov_len = sizeof(hutag.type) + sizeof(hutag.len);
	ph->len += sizeof(hutag.type)+sizeof(hutag.len)+sizeof(client_cookie);
	iov[idx].iov_base = &client_cookie;
	iov[idx++].iov_len = sizeof(client_cookie);

	/* Service-Name */
	slen = (srv == NULL) ? 0 : strlen((char *)srv);
	svtag.type = htons(PPPOE_TAG_SERVICE_NAME);
	svtag.len = htons(slen);
	iov[idx].iov_base = &svtag;
	iov[idx++].iov_len = sizeof(hutag.type) + sizeof(hutag.len);
	ph->len += slen + sizeof(hutag.type) + sizeof(hutag.len);
	if (slen) {
		iov[idx].iov_base = srv;
		iov[idx++].iov_len = slen;
	}

	n = tag_lookup(tl, PPPOE_TAG_RELAY_SESSION, 0);
	if (n != NULL) {
		iov[idx].iov_base = &n->type;
		iov[idx++].iov_len = sizeof(n->type) + sizeof(n->len);
		if (n->len) {
			iov[idx].iov_base = n->val;
			iov[idx++].iov_len = n->len;
		}
		ph->len += sizeof(n->type) + sizeof(n->len) + n->len;
	}

	n = tag_lookup(tl, PPPOE_TAG_AC_COOKIE, 0);
	if (n != NULL) {
		iov[idx].iov_base = &n->type;
		iov[idx++].iov_len = sizeof(n->type) + sizeof(n->len);
		if (n->len) {
			iov[idx].iov_base = n->val;
			iov[idx++].iov_len = n->len;
		}
		ph->len += sizeof(n->type) + sizeof(n->len) + n->len;
	}

	ph->len = htons(ph->len);
	tag_hton(tl);

	client_state = STATE_EXPECT_PADS;
	return (writev(bfd, iov, idx));
}

static int
getpackets(int bfd, u_int8_t *srv, u_int8_t *sysname,
    struct ether_addr *myea, struct ether_addr *rmea)
{
	static u_int8_t *pktbuf;
	u_int8_t *mpkt, *pkt, *epkt;
	struct ether_header eh;
	struct pppoe_header ph;
	struct bpf_hdr *bh;
	int rlen, r;
	u_long len;

	if (pktbuf == NULL) {
		pktbuf = (u_int8_t *)malloc(PPPOE_BPF_BUFSIZ);
		if (pktbuf == NULL)
			return (-1);
	}

	rlen = read(bfd, pktbuf, PPPOE_BPF_BUFSIZ);
	if (rlen < 0) {
		if (errno == EINTR)
			return (0);
		return (-1);
	}

	pkt = pktbuf;
	epkt = pkt + rlen;
	while (pkt < epkt) {
		bh = (struct bpf_hdr *)pkt;
		len = bh->bh_caplen;
		mpkt = pkt + bh->bh_hdrlen;

		/* Pull out ethernet header */
		if (len < sizeof(struct ether_header))
			goto next;
		bcopy(mpkt, &eh, sizeof(struct ether_header));
		eh.ether_type = ntohs(eh.ether_type);
		len -= sizeof(struct ether_header);
		mpkt += sizeof(struct ether_header);

		/* Pull out pppoe header */
		if (len < sizeof(struct pppoe_header))
			goto next;
		bcopy(mpkt, &ph, sizeof(struct pppoe_header));
		len -= sizeof(struct pppoe_header);
		mpkt += sizeof(struct pppoe_header);
		ph.len = ntohs(ph.len);
		ph.sessionid = ntohs(ph.sessionid);

		if (PPPOE_VER(ph.vertype) != 1 ||
		    PPPOE_TYPE(ph.vertype) != 1)
			goto next;

		if (len > ph.len)
			len = ph.len;

		if (eh.ether_type == ETHERTYPE_PPPOEDISC) {
			/* Discovery Stage */
			switch (ph.code) {
			case PPPOE_CODE_PADO:
				r = recv_pado(bfd, srv, myea, rmea, &eh,
				    &ph, len, mpkt);
				break;
			case PPPOE_CODE_PADS:
				r = recv_pads(bfd, srv, sysname, myea, rmea,
				    &eh, &ph, len, mpkt);
				break;
			case PPPOE_CODE_PADT:
				r = recv_padt(bfd, myea, rmea, &eh, &ph,
				    len, mpkt);
				break;
			default:
				r = 0;
			}
			if (r < 0)
				return (r);
		}
		else if (eh.ether_type == ETHERTYPE_PPPOE) {
			if (client_state != STATE_EXPECT_SESSION)
				goto next;
			if (bcmp(rmea, &eh.ether_shost[0], ETHER_ADDR_LEN))
				goto next;
			if (pppfd < 0)
				goto next;
			if (client_sessionid != ph.sessionid)
				goto next;
			if ((r = bpf_to_ppp(pppfd, len, mpkt)) < 0)
				return (-1);
			if (r == 0) {
				usleep(100000);
				continue;
			}
		}
next:
		pkt += BPF_WORDALIGN(bh->bh_hdrlen + bh->bh_caplen);
	}
	return (1);
}


static int
recv_pado(int bfd, u_int8_t *srv, struct ether_addr *myea,
    struct ether_addr *rmea, struct ether_header *eh,
    struct pppoe_header *ph, u_long len, u_int8_t *pkt)
{
	struct tag_list tl;
	struct tag_node *n;
	int r, slen;

	if (timer_hit()) {
		timer_clr();
		return (0);
	}

	if (client_state != STATE_EXPECT_PADO)
		return (0);

	tag_init(&tl);
	if (tag_pkt(&tl, len, pkt) < 0)
		goto out;

	if (ph->sessionid != 0)
		goto out;

	if (tag_lookup(&tl, PPPOE_TAG_AC_NAME, 0) == NULL)
		goto out;

	n = tag_lookup(&tl, PPPOE_TAG_HOST_UNIQ, 0);
	if (n == NULL || n->len != sizeof(client_cookie))
		goto out;
	if (bcmp(n->val, &client_cookie, sizeof(client_cookie)))
		goto out;

	r = 0;
	slen = (srv == NULL) ? 0 : strlen((char *)srv);
	while ((n = tag_lookup(&tl, PPPOE_TAG_SERVICE_NAME, r)) != NULL) {
		if (slen == 0 || n->len == 0)
			break;
		if (n->len == slen && !strncmp((char *)srv,
		    (char *)n->val, slen))
			break;
		r++;
	}

	if (n == NULL)
		goto out;

	bcopy(&eh->ether_shost[0], rmea, ETHER_ADDR_LEN);

	timer_clr();
	r = send_padr(bfd, srv, myea, rmea, eh, ph, &tl);
	tag_destroy(&tl);
	return (r);

out:
	tag_destroy(&tl);
	return (0);
}

static int
recv_pads(int bfd, u_int8_t *srv, u_int8_t *sysname,
    struct ether_addr *myea, struct ether_addr *rmea,
    struct ether_header *eh, struct pppoe_header *ph,
    u_long len, u_int8_t *pkt)
{
	struct tag_node *n;
	struct tag_list tl;

	if (timer_hit()) {
		timer_clr();
		return (0);
	}

	if (bcmp(rmea, &eh->ether_shost[0], ETHER_ADDR_LEN))
		return (0);

	if (client_state != STATE_EXPECT_PADS)
		return (0);

	tag_init(&tl);
	if (tag_pkt(&tl, len, pkt) < 0)
		goto out;

	n = tag_lookup(&tl, PPPOE_TAG_HOST_UNIQ, 0);
	if (n == NULL || n->len != sizeof(client_cookie))
		goto out;
	if (bcmp(n->val, &client_cookie, sizeof(client_cookie)))
		goto out;

	if (ph->sessionid == 0) {
		timer_clr();
		return (-1);
	}

	timer_clr();

	pppfd = fileno(stdin);
	if (pppfd < 0) {
		send_padt(bfd, myea, rmea, ph->sessionid);
		return (-1);
	}

	client_state = STATE_EXPECT_SESSION;
	client_sessionid = ph->sessionid;

out:
	tag_destroy(&tl);
	return (0);
}

static int
recv_padt(int bfd, struct ether_addr *myea, struct ether_addr *rmea,
    struct ether_header *eh, struct pppoe_header *ph,
    u_long len, u_int8_t *pkt)
{
	if (bcmp(&eh->ether_shost[0], rmea, ETHER_ADDR_LEN))
		return (0);

	if (client_sessionid != 0xffff && ph->sessionid == client_sessionid)
		return (-1);

	return (0);
}

volatile sig_atomic_t timer_alarm;
static struct sigaction timer_oact;

void
timer_handler(int sig)
{
	timer_alarm = 1;
}

int
timer_set(u_int sec)
{
	struct sigaction act;
	struct itimerval it;

	timer_alarm = 0;
	if (sigemptyset(&act.sa_mask) < 0)
		return (-1);
	act.sa_flags = 0;
	act.sa_handler = timer_handler;
	if (sigaction(SIGALRM, &act, &timer_oact) < 0)
		return (-1);

	timerclear(&it.it_interval);
	timerclear(&it.it_value);
	it.it_value.tv_sec = sec;
	if (setitimer(ITIMER_REAL, &it, NULL) == -1) {
		sigaction(SIGALRM, &timer_oact, NULL);
		return (-1);
	}

	return (0);
}

int
timer_clr(void)
{
	struct itimerval it;
	int r1, r2;

	timerclear(&it.it_interval);
	timerclear(&it.it_value);
	r1 = setitimer(ITIMER_REAL, &it, NULL);
	r2 = sigaction(SIGALRM, &timer_oact, NULL);
	timer_alarm = 0;

	if (r1 || r2)
		return (-1);
	return (0);
}

int
timer_hit(void)
{
	return (timer_alarm);
}
@


1.25
log
@include queue.h directly instead of relying on if.h to provide it;
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.24 2011/11/05 09:20:36 yasuoka Exp $	*/
@


1.24
log
@Remove unnecessary #include's.  From Michael W. Bombardieri.

No binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.23 2011/07/04 16:29:35 sthen Exp $	*/
d32 1
@


1.23
log
@Bring back byte-order conversion that was inadvertently removed in previous
commit. Problem reported by Scott McEachern, ok yasuoka@@
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.22 2011/03/31 09:19:35 sobrado Exp $	*/
a30 1
#include <sys/time.h>
a31 2
#include <sys/ioctl.h>
#include <sys/param.h>
a40 2
#include <err.h>
#include <fcntl.h>
a41 1
#include <sysexits.h>
@


1.22
log
@remove dead code from pppoe(8).

found by Michael W. Bombardieri for tag_ntoh() and tag_show(),
improved later by yasuoka@@ to include tag_hton() which is called
one time but never used.

ok yasuoka@@
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.21 2007/09/03 14:26:54 deraadt Exp $	*/
d277 1
@


1.21
log
@malloc(n * m) -> calloc(n, m); ok espie
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.20 2004/09/03 06:37:14 tedu Exp $	*/
a276 1
	tag_hton(tl);
@


1.20
log
@sleep instead of busy waiting on ENOBUFS.  reduces cpu time.
pr3900.  ok canacar@@ deraadt@@ matthieu@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.19 2004/06/14 19:22:39 canacar Exp $	*/
d103 1
a103 1
			fdsp = (fd_set *)malloc(howmany(max, NFDBITS) *
@


1.19
log
@Set relay session id in outgoing packets properly. Report with patch
from Girish Venkatachalam. ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.18 2004/05/06 20:29:03 deraadt Exp $	*/
d371 2
a372 1
			if (r == 0)
d374 1
@


1.18
log
@knf and other cleanups
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.17 2003/06/04 04:46:13 jason Exp $	*/
d259 1
a259 1
			iov[idx].iov_base = &n->val;
@


1.17
log
@kill terms 3 & 4
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.16 2002/09/08 05:10:56 jason Exp $	*/
d80 1
a80 4
client_mode(bfd, sysname, srvname, myea)
	int bfd;
	u_int8_t *sysname, *srvname;
	struct ether_addr *myea;
d151 1
a151 4
send_padi(fd, ea, srv)
	int fd;
	struct ether_addr *ea;
	u_int8_t *srv;
d207 3
a209 7
send_padr(bfd, srv, myea, rmea, eh, ph, tl)
	int bfd;
	u_int8_t *srv;
	struct ether_addr *myea, *rmea;
	struct ether_header *eh;
	struct pppoe_header *ph;
	struct tag_list *tl;
d284 2
a285 4
getpackets(bfd, srv, sysname, myea, rmea)
	int bfd;
	u_int8_t *srv, *sysname;
	struct ether_addr *myea, *rmea;
d382 3
a384 8
recv_pado(bfd, srv, myea, rmea, eh, ph, len, pkt)
	int bfd;
	u_int8_t *srv;
	struct ether_addr *myea, *rmea;
	struct ether_header *eh;
	struct pppoe_header *ph;
	u_long len;
	u_int8_t *pkt;
d441 4
a444 8
recv_pads(bfd, srv, sysname, myea, rmea, eh, ph, len, pkt)
	int bfd;
	u_int8_t *srv, *sysname;
	struct ether_addr *myea, *rmea;
	struct ether_header *eh;
	struct pppoe_header *ph;
	u_long len;
	u_int8_t *pkt;
d492 3
a494 7
recv_padt(bfd, myea, rmea, eh, ph, len, pkt)
	int bfd;
	struct ether_addr *myea, *rmea;
	struct ether_header *eh;
	struct pppoe_header *ph;
	u_long len;
	u_int8_t *pkt;
d509 1
a509 2
timer_handler(sig)
	int sig;
d515 1
a515 2
timer_set(sec)
	u_int sec;
@


1.16
log
@more cleaning
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.15 2002/09/08 04:33:46 jason Exp $	*/
a4 1
 * All rights reserved.
a13 6
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Network Security
 *	Technologies, Inc.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.15
log
@Fix a bunch of -pedantic errors
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.14 2002/02/17 19:42:39 millert Exp $	*/
a55 1
#include <syslog.h>
@


1.14
log
@Manual cleanup of remaining userland __P use (excluding packages maintained outside the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.13 2002/02/16 21:28:07 millert Exp $	*/
d69 1
a69 1
static int getpackets(int, char *, char *, struct ether_addr *,
d72 1
a72 1
static int send_padr(int, char *, struct ether_addr *, struct ether_addr *,
d74 1
a74 1
static int recv_pado(int, char *, struct ether_addr *, struct ether_addr *,
d76 1
a76 1
static int recv_pads(int, char *, char *, struct ether_addr *,
d90 1
a90 1
	char *sysname, *srvname;
d200 1
a200 1
	tserv.len = (srv == NULL) ? 0 : strlen(srv);
d223 1
a223 1
	char *srv;
d261 1
a261 1
	slen = (srv == NULL) ? 0 : strlen(srv);
d304 1
a304 1
	char *srv, *sysname;
d404 1
a404 1
	char *srv;
d440 1
a440 1
	slen = (srv == NULL) ? 0 : strlen(srv);
d444 2
a445 1
		if (n->len == slen && !strncmp(srv, n->val, slen))
d468 1
a468 1
	char *srv, *sysname;
@


1.13
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.12 2001/11/17 19:54:57 deraadt Exp $	*/
d69 2
a70 2
static int getpackets __P((int, char *, char *, struct ether_addr *,
    struct ether_addr *));
d72 5
a76 1
static int send_padr __P((int, char *, struct ether_addr *,
d78 3
a80 9
    struct tag_list *));
static int recv_pado __P((int, char *, struct ether_addr *,
    struct ether_addr *, struct ether_header *, struct pppoe_header *,
    u_long, u_int8_t *));
static int recv_pads __P((int, char *, char *, struct ether_addr *,
    struct ether_addr *, struct ether_header *, struct pppoe_header *,
    u_long, u_int8_t *));
static int recv_padt __P((int, struct ether_addr *, struct ether_addr *,
    struct ether_header *, struct pppoe_header *, u_long, u_int8_t *));
@


1.12
log
@volatile sig_atomic_t
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.11 2001/04/24 05:09:23 jason Exp $	*/
d71 1
a71 1
static int send_padi __P((int, struct ether_addr *, u_int8_t *));
d84 4
a87 4
void timer_handler __P((int));
int timer_set __P((u_int));
int timer_clr __P((void));
int timer_hit __P((void));
@


1.11
log
@remove unecessary code and data
initialize more of the client state in client_mode()
add sessionid check on incoming packets.  Non-matching packets are just
ignored (this allows multiple pppoe's to run on the same interface without
freaking out).
Thanks again to Russell T Hunt <alaric@@MIT.EDU>.
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.10 2001/02/04 21:25:34 jason Exp $	*/
d539 1
a539 1
sig_atomic_t timer_alarm;
@


1.10
log
@setting of maximum fd was wrong; patch from pr 1670: "Evgeni Belin" <ebelin@@sauron.dnsalias.net>.
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.9 2001/01/19 17:53:17 deraadt Exp $	*/
a60 2
#define	PPP_PROG	"/usr/sbin/ppp"

d65 3
a67 5
u_int32_t client_cookie = 0;
u_int16_t client_sessionid = 0xffff;
int pppfd = -1;
int client_state = -1;
u_int8_t etherremoteaddr[6], etherlocaladdr[6];
d101 1
a237 1
	client_state = STATE_EXPECT_PADS;
d299 1
a336 2
		debug_packet(mpkt, len);

d389 2
a443 2
		if (slen == 0)
			break;
@


1.9
log
@mark remaining signal races which are difficult to fix
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.8 2001/01/16 05:34:15 jason Exp $	*/
d125 1
a125 1
			max = oldmax;
@


1.8
log
@bzero the sets before FD_SET'n them
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.7 2001/01/16 05:01:39 jason Exp $	*/
d544 1
a544 1
static volatile int timer_alarm;
@


1.7
log
@fix fd_set overflows
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.6 2001/01/12 06:12:54 jason Exp $	*/
d119 1
a119 1
			fdsp = (fd_set *)calloc(howmany(max, NFDBITS),
d127 1
@


1.6
log
@use setitimer instead of alarm
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.5 2000/10/09 22:52:18 brian Exp $	*/
d100 2
a101 2
	fd_set fds;
	int r = 0, max;
a109 1
	FD_ZERO(&fds);
d111 15
a125 6
		FD_SET(bfd, &fds);
		max = bfd + 1;
		if (pppfd >= 0) {
			if (pppfd >= max)
				max = pppfd + 1;
			FD_SET(pppfd, &fds);
d128 5
a132 1
		r = select(max, &fds, NULL, NULL, NULL);
d141 1
a141 1
		if (FD_ISSET(bfd, &fds)) {
d146 1
a146 1
		if (pppfd >= 0 && FD_ISSET(pppfd, &fds)) {
d158 4
@


1.5
log
@Don't exit when we get ENOBUFS from writev(), drop the packet instead.
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.4 2000/08/03 20:21:35 jason Exp $	*/
d542 1
d551 9
a559 1
	alarm(sec);
d566 10
a575 2
	alarm(0);
	if (sigaction(SIGALRM, &timer_oact, NULL) < 0)
a576 1
	timer_alarm = 0;
@


1.4
log
@fd == 0 is perfectly valid (and likely); spotted by Steve Williams <steve@@genie96.com>
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.3 2000/06/20 04:57:47 jason Exp $	*/
d377 1
a377 1
			if (bpf_to_ppp(pppfd, len, mpkt) <= 0)
d379 2
@


1.3
log
@use stdin instead of exec'n ppp(8).  It's expected that ppp will give us
a AF_LOCAL,SOCK_DGRAM socket as stdin
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.2 2000/06/20 04:55:25 jason Exp $	*/
d375 1
a375 1
			if (pppfd <= 0)
@


1.2
log
@Remove some debugging code, and prepare to become an 'exec' client of ppp(8)
@
text
@d1 1
a1 1
/*	$OpenBSD: client.c,v 1.1.1.1 2000/06/18 07:30:41 jason Exp $	*/
d493 1
a493 1
	pppfd = runppp(bfd, sysname);
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a143 1
		close(pppfd);
a364 1
				recv_debug(bfd, myea, &eh, &ph, len, mpkt);
d428 2
@


1.1.1.1
log
@import my pppoe code
@
text
@@
