head	1.20;
access;
symbols
	OPENBSD_6_1_BASE:1.20
	OPENBSD_6_0:1.20.0.8
	OPENBSD_6_0_BASE:1.20
	OPENBSD_5_9:1.20.0.4
	OPENBSD_5_9_BASE:1.20
	OPENBSD_5_8:1.20.0.6
	OPENBSD_5_8_BASE:1.20
	OPENBSD_5_7:1.20.0.2
	OPENBSD_5_7_BASE:1.20
	OPENBSD_5_6:1.19.0.10
	OPENBSD_5_6_BASE:1.19
	OPENBSD_5_5:1.19.0.8
	OPENBSD_5_5_BASE:1.19
	OPENBSD_5_4:1.19.0.4
	OPENBSD_5_4_BASE:1.19
	OPENBSD_5_3:1.19.0.2
	OPENBSD_5_3_BASE:1.19;
locks; strict;
comment	@ * @;


1.20
date	2014.10.09.02.44.55;	author deraadt;	state Exp;
branches;
next	1.19;
commitid	IEObofuPAZ51oe5u;

1.19
date	2012.12.09.20.24.53;	author kettenis;	state Exp;
branches;
next	1.18;

1.18
date	2012.11.28.11.17.23;	author kettenis;	state Exp;
branches;
next	1.17;

1.17
date	2012.11.24.17.04.03;	author kettenis;	state Exp;
branches;
next	1.16;

1.16
date	2012.11.24.11.50.45;	author kettenis;	state Exp;
branches;
next	1.15;

1.15
date	2012.11.05.19.50.54;	author kettenis;	state Exp;
branches;
next	1.14;

1.14
date	2012.11.04.23.30.38;	author kettenis;	state Exp;
branches;
next	1.13;

1.13
date	2012.11.04.21.44.20;	author kettenis;	state Exp;
branches;
next	1.12;

1.12
date	2012.11.04.20.09.02;	author kettenis;	state Exp;
branches;
next	1.11;

1.11
date	2012.11.04.18.59.02;	author kettenis;	state Exp;
branches;
next	1.10;

1.10
date	2012.11.04.18.14.09;	author kettenis;	state Exp;
branches;
next	1.9;

1.9
date	2012.10.27.18.21.00;	author kettenis;	state Exp;
branches;
next	1.8;

1.8
date	2012.10.21.12.56.45;	author kettenis;	state Exp;
branches;
next	1.7;

1.7
date	2012.10.21.12.47.58;	author kettenis;	state Exp;
branches;
next	1.6;

1.6
date	2012.10.20.16.44.16;	author kettenis;	state Exp;
branches;
next	1.5;

1.5
date	2012.10.20.13.05.54;	author kettenis;	state Exp;
branches;
next	1.4;

1.4
date	2012.10.16.19.57.23;	author kettenis;	state Exp;
branches;
next	1.3;

1.3
date	2012.10.15.20.28.50;	author kettenis;	state Exp;
branches;
next	1.2;

1.2
date	2012.10.14.16.11.45;	author kettenis;	state Exp;
branches;
next	1.1;

1.1
date	2012.10.14.15.38.06;	author kettenis;	state Exp;
branches;
next	;


desc
@@


1.20
log
@indent
@
text
@/*	$OpenBSD: ldomctl.c,v 1.19 2012/12/09 20:24:53 kettenis Exp $	*/

/*
 * Copyright (c) 2012 Mark Kettenis
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/ioctl.h>
#include <err.h>
#include <fcntl.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>

#include "ds.h"
#include "hvctl.h"
#include "mdstore.h"
#include "mdesc.h"
#include "util.h"
#include "ldomctl.h"

extern struct ds_service pri_service;

struct command {
	const char *cmd_name;
	void (*cmd_func)(int, char **);
};

__dead void usage(void);

struct guest_head guest_list;

uint64_t find_guest(const char *);

void fetch_pri(void);

void download(int argc, char **argv);
void dump(int argc, char **argv);
void list(int argc, char **argv);
void xselect(int argc, char **argv);
void delete(int argc, char **argv);
void guest_start(int argc, char **argv);
void guest_stop(int argc, char **argv);
void guest_panic(int argc, char **argv);
void guest_status(int argc, char **argv);
void init_system(int argc, char **argv);

struct command commands[] = {
	{ "download",	download },
	{ "dump",	dump },
	{ "list",	list },
	{ "select",	xselect },
	{ "delete",	delete },
	{ "start",	guest_start },
	{ "stop",	guest_stop },
	{ "panic",	guest_panic },
	{ "status",	guest_status },
	{ "init-system", init_system },
	{ NULL,		NULL }
};

void hv_open(void);
void hv_close(void);
void hv_read(uint64_t, void *, size_t);
void hv_write(uint64_t, void *, size_t);

int hvctl_seq = 1;
int hvctl_fd;

void *hvmd_buf;
size_t hvmd_len;
struct md *hvmd;
uint64_t hv_mdpa;
uint64_t hv_membase;
uint64_t hv_memsize;

extern void *pri_buf;
extern size_t pri_len;

int
main(int argc, char **argv)
{
	struct command *cmdp;
	struct hvctl_msg msg;
	ssize_t nbytes;
	struct md_header hdr;
	struct md_node *node;
	struct md_prop *prop;

	if (argc < 2)
		usage();

	/* Skip program name. */
	argv++;
	argc--;

	for (cmdp = commands; cmdp->cmd_name != NULL; cmdp++)
		if (strcmp(argv[0], cmdp->cmd_name) == 0)
			break;
	if (cmdp->cmd_name == NULL)
		usage();

	hv_open();

	/*
	 * Request config.
	 */
	bzero(&msg, sizeof(msg));
	msg.hdr.op = HVCTL_OP_GET_HVCONFIG;
	msg.hdr.seq = hvctl_seq++;
	nbytes = write(hvctl_fd, &msg, sizeof(msg));
	if (nbytes != sizeof(msg))
		err(1, "write");

	bzero(&msg, sizeof(msg));
	nbytes = read(hvctl_fd, &msg, sizeof(msg));
	if (nbytes != sizeof(msg))
		err(1, "read");

	hv_membase = msg.msg.hvcnf.hv_membase;
	hv_memsize = msg.msg.hvcnf.hv_memsize;

	hv_mdpa = msg.msg.hvcnf.hvmdp;
	hv_read(hv_mdpa, &hdr, sizeof(hdr));
	hvmd_len = sizeof(hdr) + hdr.node_blk_sz + hdr.name_blk_sz +
	    hdr.data_blk_sz;
	hvmd_buf = xmalloc(hvmd_len);
	hv_read(hv_mdpa, hvmd_buf, hvmd_len);

	hvmd = md_ingest(hvmd_buf, hvmd_len);
	node = md_find_node(hvmd, "guests");
	TAILQ_INIT(&guest_list);
	TAILQ_FOREACH(prop, &node->prop_list, link) {
		if (prop->tag == MD_PROP_ARC &&
		    strcmp(prop->name->str, "fwd") == 0)
			add_guest(prop->d.arc.node);
	}

	(cmdp->cmd_func)(argc, argv);

	exit(EXIT_SUCCESS);
}

void
usage(void)
{
	extern char *__progname;

	fprintf(stderr, "usage: %s start|stop|panic domain\n", __progname);
	fprintf(stderr, "       %s status [domain]\n", __progname);
	exit(EXIT_FAILURE);
}

void
add_guest(struct md_node *node)
{
	struct guest *guest;
	struct md_prop *prop;

	guest = xmalloc(sizeof(*guest));

	if (!md_get_prop_str(hvmd, node, "name", &guest->name))
		goto free;
	if (!md_get_prop_val(hvmd, node, "gid", &guest->gid))
		goto free;
	if (!md_get_prop_val(hvmd, node, "mdpa", &guest->mdpa))
		goto free;

	guest->num_cpus = 0;
	TAILQ_FOREACH(prop, &node->prop_list, link) {
		if (prop->tag == MD_PROP_ARC &&
		    strcmp(prop->name->str, "fwd") == 0) {
			if (strcmp(prop->d.arc.node->name->str, "cpu") == 0)
				guest->num_cpus++;
		}
	}

	TAILQ_INSERT_TAIL(&guest_list, guest, link);
	return;

free:
	free(guest);
}

uint64_t
find_guest(const char *name)
{
	struct guest *guest;

	TAILQ_FOREACH(guest, &guest_list, link) {
		if (strcmp(guest->name, name) == 0)
			return guest->gid;
	}

	errx(EXIT_FAILURE, "unknown guest '%s'", name);
}

void
fetch_pri(void)
{
	struct ds_conn *dc;

	dc = ds_conn_open("/dev/spds", NULL);
	ds_conn_register_service(dc, &pri_service);
	while (pri_buf == NULL)
		ds_conn_handle(dc);
}

void
dump(int argc, char **argv)
{
	struct guest *guest;
	struct md_header hdr;
	void *md_buf;
	size_t md_len;
	char *name;
	FILE *fp;

	if (argc != 1)
		usage();

	fp = fopen("hv.md", "w");
	if (fp == NULL)
		err(1, "fopen");
	fwrite(hvmd_buf, hvmd_len, 1, fp);
	fclose(fp);

	fetch_pri();

	fp = fopen("pri", "w");
	if (fp == NULL)
		err(1, "fopen");
	fwrite(pri_buf, pri_len, 1, fp);
	fclose(fp);

	TAILQ_FOREACH(guest, &guest_list, link) {
		hv_read(guest->mdpa, &hdr, sizeof(hdr));
		md_len = sizeof(hdr) + hdr.node_blk_sz + hdr.name_blk_sz +
		    hdr.data_blk_sz;
		md_buf = xmalloc(md_len);
		hv_read(guest->mdpa, md_buf, md_len);

		if (asprintf(&name, "%s.md", guest->name) == -1)
			err(1, "asprintf");

		fp = fopen(name, "w");
		if (fp == NULL)
			err(1, "fopen");
		fwrite(md_buf, md_len, 1, fp);
		fclose(fp);

		free(name);
		free(md_buf);
	}
}

void
init_system(int argc, char **argv)
{
	if (argc != 2)
		usage();

	build_config(argv[1]);
}

void
list(int argc, char **argv)
{
	struct ds_conn *dc;
	struct mdstore_set *set;

	dc = ds_conn_open("/dev/spds", NULL);
	ds_conn_register_service(dc, &mdstore_service);
	while (TAILQ_EMPTY(&mdstore_sets))
		ds_conn_handle(dc);

	TAILQ_FOREACH(set, &mdstore_sets, link) {
		printf("%s", set->name);
		if (set->booted_set)
			printf(" [current]");
		else if (set->boot_set)
			printf(" [next]");
		printf("\n");
	}
}

void
xselect(int argc, char **argv)
{
	struct ds_conn *dc;

	if (argc < 2)
		usage();

	dc = ds_conn_open("/dev/spds", NULL);
	ds_conn_register_service(dc, &mdstore_service);
	while (TAILQ_EMPTY(&mdstore_sets))
		ds_conn_handle(dc);

	mdstore_select(dc, argv[1]);
}

void
delete(int argc, char **argv)
{
	struct ds_conn *dc;

	if (argc < 2)
		usage();

	if (strcmp(argv[1], "factory-default") == 0)
		errx(1, "\"%s\" should not be deleted", argv[1]);

	dc = ds_conn_open("/dev/spds", NULL);
	ds_conn_register_service(dc, &mdstore_service);
	while (TAILQ_EMPTY(&mdstore_sets))
		ds_conn_handle(dc);

	mdstore_delete(dc, argv[1]);
}

void
download(int argc, char **argv)
{
	struct ds_conn *dc;

	if (argc < 2)
		usage();

	dc = ds_conn_open("/dev/spds", NULL);
	ds_conn_register_service(dc, &mdstore_service);
	while (TAILQ_EMPTY(&mdstore_sets))
		ds_conn_handle(dc);

	mdstore_download(dc, argv[1]);
}

void
guest_start(int argc, char **argv)
{
	struct hvctl_msg msg;
	ssize_t nbytes;

	if (argc < 2)
		usage();

	/*
	 * Start guest domain.
	 */
	bzero(&msg, sizeof(msg));
	msg.hdr.op = HVCTL_OP_GUEST_START;
	msg.hdr.seq = hvctl_seq++;
	msg.msg.guestop.guestid = find_guest(argv[1]);
	nbytes = write(hvctl_fd, &msg, sizeof(msg));
	if (nbytes != sizeof(msg))
		err(1, "write");

	bzero(&msg, sizeof(msg));
	nbytes = read(hvctl_fd, &msg, sizeof(msg));
	if (nbytes != sizeof(msg))
		err(1, "read");
}

void
guest_stop(int argc, char **argv)
{
	struct hvctl_msg msg;
	ssize_t nbytes;

	if (argc < 2)
		usage();

	/*
	 * Stop guest domain.
	 */
	bzero(&msg, sizeof(msg));
	msg.hdr.op = HVCTL_OP_GUEST_STOP;
	msg.hdr.seq = hvctl_seq++;
	msg.msg.guestop.guestid = find_guest(argv[1]);
	nbytes = write(hvctl_fd, &msg, sizeof(msg));
	if (nbytes != sizeof(msg))
		err(1, "write");

	bzero(&msg, sizeof(msg));
	nbytes = read(hvctl_fd, &msg, sizeof(msg));
	if (nbytes != sizeof(msg))
		err(1, "read");
}

void
guest_panic(int argc, char **argv)
{
	struct hvctl_msg msg;
	ssize_t nbytes;

	if (argc < 2)
		usage();

	/*
	 * Stop guest domain.
	 */
	bzero(&msg, sizeof(msg));
	msg.hdr.op = HVCTL_OP_GUEST_PANIC;
	msg.hdr.seq = hvctl_seq++;
	msg.msg.guestop.guestid = find_guest(argv[1]);
	nbytes = write(hvctl_fd, &msg, sizeof(msg));
	if (nbytes != sizeof(msg))
		err(1, "write");

	bzero(&msg, sizeof(msg));
	nbytes = read(hvctl_fd, &msg, sizeof(msg));
	if (nbytes != sizeof(msg))
		err(1, "read");
}

void
guest_status(int argc, char **argv)
{
	struct hvctl_msg msg;
	ssize_t nbytes;
	struct hvctl_rs_guest_state state;
	struct hvctl_rs_guest_softstate softstate;
	struct hvctl_rs_guest_util util;
	struct guest *guest;
	uint64_t gid = -1;
	uint64_t total_cycles, yielded_cycles;
	double utilisation = 0.0;
	const char *state_str;
	char buf[64];

	if (argc < 1 || argc > 2)
		usage();
	if (argc == 2)
		gid = find_guest(argv[1]);

	TAILQ_FOREACH(guest, &guest_list, link) {
		if (gid != -1 && guest->gid != gid)
			continue;

		/*
		 * Request status.
		 */
		bzero(&msg, sizeof(msg));
		msg.hdr.op = HVCTL_OP_GET_RES_STAT;
		msg.hdr.seq = hvctl_seq++;
		msg.msg.resstat.res = HVCTL_RES_GUEST;
		msg.msg.resstat.resid = guest->gid;
		msg.msg.resstat.infoid = HVCTL_INFO_GUEST_STATE;
		nbytes = write(hvctl_fd, &msg, sizeof(msg));
		if (nbytes != sizeof(msg))
			err(1, "write");

		bzero(&msg, sizeof(msg));
		nbytes = read(hvctl_fd, &msg, sizeof(msg));
		if (nbytes != sizeof(msg))
			err(1, "read");

		memcpy(&state, msg.msg.resstat.data, sizeof(state));
		switch (state.state) {
		case GUEST_STATE_STOPPED:
			state_str = "stopped";
			break;
		case GUEST_STATE_RESETTING:
			state_str = "resetting";
			break;
		case GUEST_STATE_NORMAL:
			state_str = "running";

			bzero(&msg, sizeof(msg));
			msg.hdr.op = HVCTL_OP_GET_RES_STAT;
			msg.hdr.seq = hvctl_seq++;
			msg.msg.resstat.res = HVCTL_RES_GUEST;
			msg.msg.resstat.resid = guest->gid;
			msg.msg.resstat.infoid = HVCTL_INFO_GUEST_SOFT_STATE;
			nbytes = write(hvctl_fd, &msg, sizeof(msg));
			if (nbytes != sizeof(msg))
				err(1, "write");

			bzero(&msg, sizeof(msg));
			nbytes = read(hvctl_fd, &msg, sizeof(msg));
			if (nbytes != sizeof(msg))
				err(1, "read");

			memcpy(&softstate, msg.msg.resstat.data,
			   sizeof(softstate));

			bzero(&msg, sizeof(msg));
			msg.hdr.op = HVCTL_OP_GET_RES_STAT;
			msg.hdr.seq = hvctl_seq++;
			msg.msg.resstat.res = HVCTL_RES_GUEST;
			msg.msg.resstat.resid = guest->gid;
			msg.msg.resstat.infoid = HVCTL_INFO_GUEST_UTILISATION;
			nbytes = write(hvctl_fd, &msg, sizeof(msg));
			if (nbytes != sizeof(msg))
				err(1, "write");

			bzero(&msg, sizeof(msg));
			nbytes = read(hvctl_fd, &msg, sizeof(msg));
			if (nbytes != sizeof(msg))
				err(1, "read");

			memcpy(&util, msg.msg.resstat.data, sizeof(util));

			total_cycles = util.active_delta * guest->num_cpus
			    - util.stopped_cycles;
			yielded_cycles = util.yielded_cycles;
			if (yielded_cycles <= total_cycles)
				utilisation = (100.0 * (total_cycles
				    - yielded_cycles)) / total_cycles;
			else
				utilisation = 0.0;

			break;
		case GUEST_STATE_SUSPENDED:
			state_str = "suspended";
			break;
		case GUEST_STATE_EXITING:
			state_str = "exiting";
			break;
		case GUEST_STATE_UNCONFIGURED:
			state_str = "unconfigured";
			break;
		default:
			snprintf(buf, sizeof(buf), "unknown (%lld)",
			    state.state);
			state_str = buf;
			break;
		}

		if (state.state != GUEST_STATE_NORMAL)
			printf("%-16s  %-16s\n", guest->name, state_str);
		else
			printf("%-16s  %-16s  %-32s  %3.0f%%\n", guest->name,
			       state_str, softstate.soft_state_str,
			       utilisation);
	}
}

void
hv_open(void)
{
	struct hvctl_msg msg;
	ssize_t nbytes;
	uint64_t code;

	hvctl_fd = open("/dev/hvctl", O_RDWR, 0);
	if (hvctl_fd == -1)
		err(1, "cannot open /dev/hvctl");

	/*
	 * Say "Hello".
	 */
	bzero(&msg, sizeof(msg));
	msg.hdr.op = HVCTL_OP_HELLO;
	msg.hdr.seq = hvctl_seq++;
	msg.msg.hello.major = 1;
	nbytes = write(hvctl_fd, &msg, sizeof(msg));
	if (nbytes != sizeof(msg))
		err(1, "write");

	bzero(&msg, sizeof(msg));
	nbytes = read(hvctl_fd, &msg, sizeof(msg));
	if (nbytes != sizeof(msg))
		err(1, "read");

	code = msg.msg.clnge.code ^ 0xbadbeef20;

	/*
	 * Respond to challenge.
	 */
	bzero(&msg, sizeof(msg));
	msg.hdr.op = HVCTL_OP_RESPONSE;
	msg.hdr.seq = hvctl_seq++;
	msg.msg.clnge.code = code ^ 0x12cafe42a;
	nbytes = write(hvctl_fd, &msg, sizeof(msg));
	if (nbytes != sizeof(msg))
		err(1, "write");

	bzero(&msg, sizeof(msg));
	nbytes = read(hvctl_fd, &msg, sizeof(msg));
	if (nbytes != sizeof(msg))
		err(1, "read");
}

void
hv_close(void)
{
	close(hvctl_fd);
	hvctl_fd = -1;
}

void
hv_read(uint64_t addr, void *buf, size_t len)
{
	struct hv_io hi;

	hi.hi_cookie = addr;
	hi.hi_addr = buf;
	hi.hi_len = len;

	if (ioctl(hvctl_fd, HVIOCREAD, &hi) == -1)
		err(1, "ioctl");
}

void
hv_write(uint64_t addr, void *buf, size_t len)
{
	struct hv_io hi;

	hi.hi_cookie = addr;
	hi.hi_addr = buf;
	hi.hi_len = len;

	if (ioctl(hvctl_fd, HVIOCWRITE, &hi) == -1)
		err(1, "ioctl");
}
@


1.19
log
@Implement panic command.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldomctl.c,v 1.18 2012/11/28 11:17:23 kettenis Exp $	*/
d173 1
a173 1
	guest = xmalloc (sizeof(*guest));
@


1.18
log
@Prevent people from shooting themselves in the foot by not allowing them to
delete the factory-default configuration.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldomctl.c,v 1.17 2012/11/24 17:04:03 kettenis Exp $	*/
d57 1
d69 1
d162 1
a162 1
	fprintf(stderr, "usage: %s start|stop domain\n", __progname);
d391 26
@


1.17
log
@Get rid of some hard-coded constants.  Improve memory allocation code.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldomctl.c,v 1.16 2012/11/24 11:50:45 kettenis Exp $	*/
d321 3
@


1.16
log
@Add code to create new system configuration.  Work in progress, but there's
enough functionality to create a configuration for a t1k or t2k running
System Firmware 6.7.x.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldomctl.c,v 1.15 2012/11/05 19:50:54 kettenis Exp $	*/
d85 2
d130 3
@


1.15
log
@Better code to download configurations onto the SP.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldomctl.c,v 1.14 2012/11/04 23:30:38 kettenis Exp $	*/
d44 1
a44 1
struct guest_head guests;
d58 1
d69 1
d138 1
a138 1
	TAILQ_INIT(&guests);
d184 1
a184 1
	TAILQ_INSERT_TAIL(&guests, guest, link);
d196 1
a196 1
	TAILQ_FOREACH(guest, &guests, link) {
d242 1
a242 1
	TAILQ_FOREACH(guest, &guests, link) {
d264 9
d413 1
a413 1
	TAILQ_FOREACH(guest, &guests, link) {
@


1.14
log
@A bit more SP configuration code.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldomctl.c,v 1.13 2012/11/04 21:44:20 kettenis Exp $	*/
d33 1
d44 1
a44 4
struct guest {
	const char *name;
	uint64_t gid;
	uint64_t mdpa;
a45 8
	int num_cpus;

	TAILQ_ENTRY(guest) link;
};

TAILQ_HEAD(guest_head, guest) guests;

void add_guest(struct md_node *);
a317 2

	debug = 1;
@


1.13
log
@Add support for selecting a configuration stored on the SP.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldomctl.c,v 1.12 2012/11/04 20:09:02 kettenis Exp $	*/
d60 1
d64 1
d70 1
d74 1
d306 34
@


1.12
log
@Support for listing configurations store on the SP.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldomctl.c,v 1.11 2012/11/04 18:59:02 kettenis Exp $	*/
d62 1
d70 1
d286 16
@


1.11
log
@Switch over to using the ds.[ch] from ldomd(8).
@
text
@d1 1
a1 1
/*	$OpenBSD: ldomctl.c,v 1.10 2012/11/04 18:14:09 kettenis Exp $	*/
d30 1
d61 1
d68 1
d262 21
@


1.10
log
@Factor out some code.  Use the "hvctl.h" header from ldomd.  Add man page.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldomctl.c,v 1.9 2012/10/27 18:21:00 kettenis Exp $	*/
d33 2
d206 1
a206 44
	struct ldc_conn lc;
	ssize_t nbytes;
	int fd;

	fd = open("/dev/spds", O_RDWR, 0);
	if (fd == -1)
		err(1, "open");

	memset(&lc, 0, sizeof(lc));
	lc.lc_fd = fd;
	lc.lc_rx_data = ds_rx_msg;

	while (pri_buf == NULL) {
		struct ldc_pkt lp;

		bzero(&lp, sizeof(lp));
		nbytes = read(fd, &lp, sizeof(lp));
		if (nbytes != sizeof(lp))
			err(1, "read");

#if 0
	{
		uint64_t *msg = (uint64_t *)&lp;
		int i;

		for (i = 0; i < 8; i++)
			printf("%02x: %016llx\n", i, msg[i]);
	}
#endif

		switch (lp.type) {
		case LDC_CTRL:
			ldc_rx_ctrl(&lc, &lp);
			break;
		case LDC_DATA:
			ldc_rx_data(&lc, &lp);
			break;
		default:
			DPRINTF(("%0x02/%0x02/%0x02\n", lp.type, lp.stype,
			    lp.ctrl));
			ldc_reset(&lc);
			break;
		}
	}
d208 4
a211 1
	close(fd);
@


1.9
log
@Don't accidentally free memory that we plan to use later!
@
text
@d1 1
a1 1
/*	$OpenBSD: ldomctl.c,v 1.8 2012/10/21 12:56:45 kettenis Exp $	*/
d29 1
a32 97
struct hv_io {
	uint64_t	hi_cookie;
	void		*hi_addr;
	size_t		hi_len;
};

#define HVIOCREAD	_IOW('h', 0, struct hv_io)

#define SIS_NORMAL		0x1
#define SIS_TRANSITION		0x2
#define SOFT_STATE_SIZE		32

#define GUEST_STATE_STOPPED		0x0
#define GUEST_STATE_RESETTING		0x1
#define GUEST_STATE_NORMAL		0x2
#define GUEST_STATE_SUSPENDED		0x3
#define GUEST_STATE_EXITING		0x4
#define GUEST_STATE_UNCONFIGURED	0xff

#define HVCTL_RES_STATUS_DATA_SIZE	40

struct hvctl_header {
	uint16_t	op;
	uint16_t	seq;
	uint16_t	chksum;
	uint16_t	status;
};

struct hvctl_hello {
	uint16_t	major;
	uint16_t	minor;
};

struct hvctl_challenge {
	uint64_t	code;
};

struct hvctl_hvconfig {
	uint64_t	hv_membase;
	uint64_t	hv_memsize;
	uint64_t	hvmdp;
	uint64_t	del_reconf_hvmdp;
	uint32_t	del_reconf_gid;
};

struct hvctl_guest_op {
	uint32_t	guestid;
	uint32_t	code;
};

struct hvctl_res_status {
	uint32_t	res;
	uint32_t	resid;
	uint32_t	infoid;
	uint32_t	code;
	uint8_t         data[HVCTL_RES_STATUS_DATA_SIZE];
};

struct hvctl_rs_guest_state {
	uint64_t	state;
};

struct hvctl_rs_guest_softstate {
	uint8_t		soft_state;
	char		soft_state_str[SOFT_STATE_SIZE];
};

struct hvctl_rs_guest_util {
	uint64_t	lifespan;
	uint64_t	wallclock_delta;
	uint64_t	active_delta;
	uint64_t	stopped_cycles;
	uint64_t	yielded_cycles;
};

struct hvctl_msg {
	struct hvctl_header	hdr;
	union {
		struct hvctl_hello	hello;
		struct hvctl_challenge	clnge;
		struct hvctl_hvconfig	hvcnf;
		struct hvctl_guest_op	guestop;
		struct hvctl_res_status	resstat;
	} msg;
};

#define HVCTL_OP_GET_HVCONFIG	3
#define HVCTL_OP_GUEST_START	5
#define HVCTL_OP_GUEST_STOP	6
#define HVCTL_OP_GET_RES_STAT	11

#define HVCTL_RES_GUEST		0

#define HVCTL_INFO_GUEST_STATE		0
#define HVCTL_INFO_GUEST_SOFT_STATE	1
#define HVCTL_INFO_GUEST_UTILISATION	3

d70 5
d81 1
a90 1
	struct hv_io hi;
a91 1
	uint64_t code;
d109 1
a109 36
	hvctl_fd = open("/dev/hvctl", O_RDWR, 0);
	if (hvctl_fd == -1)
		err(1, "open");

	/*
	 * Say "Hello".
	 */
	bzero(&msg, sizeof(msg));
	msg.hdr.seq = hvctl_seq++;
	msg.msg.hello.major = 1;
	nbytes = write(hvctl_fd, &msg, sizeof(msg));
	if (nbytes != sizeof(msg))
		err(1, "write");

	bzero(&msg, sizeof(msg));
	nbytes = read(hvctl_fd, &msg, sizeof(msg));
	if (nbytes != sizeof(msg))
		err(1, "read");

	code = msg.msg.clnge.code ^ 0xbadbeef20;

	/*
	 * Respond to challenge.
	 */
	bzero(&msg, sizeof(msg));
	msg.hdr.op = 2;
	msg.hdr.seq = hvctl_seq++;
	msg.msg.clnge.code = code ^ 0x12cafe42a;
	nbytes = write(hvctl_fd, &msg, sizeof(msg));
	if (nbytes != sizeof(msg))
		err(1, "write");

	bzero(&msg, sizeof(msg));
	nbytes = read(hvctl_fd, &msg, sizeof(msg));
	if (nbytes != sizeof(msg))
		err(1, "read");
d126 2
a127 7
	hi.hi_cookie = msg.msg.hvcnf.hvmdp;
	hi.hi_addr = &hdr;
	hi.hi_len = sizeof(hdr);

	if (ioctl(hvctl_fd, HVIOCREAD, &hi) == -1)
		err(1, "ioctl");

d131 1
a131 7

	hi.hi_cookie = msg.msg.hvcnf.hvmdp;
	hi.hi_addr = hvmd_buf;
	hi.hi_len = hvmd_len;

	if (ioctl(hvctl_fd, HVIOCREAD, &hi) == -1)
		err(1, "ioctl");
a255 1
	struct hv_io hi;
d280 1
a280 7
		hi.hi_cookie = guest->mdpa;
		hi.hi_addr = &hdr;
		hi.hi_len = sizeof(hdr);

		if (ioctl(hvctl_fd, HVIOCREAD, &hi) == -1)
			err(1, "ioctl");

d284 1
a284 7

		hi.hi_cookie = guest->mdpa;
		hi.hi_addr = md_buf;
		hi.hi_len = md_len;

		if (ioctl(hvctl_fd, HVIOCREAD, &hi) == -1)
			err(1, "ioctl");
d473 79
@


1.8
log
@Split out some general-purpose functions and macros into their own file.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldomctl.c,v 1.7 2012/10/21 12:47:58 kettenis Exp $	*/
d320 2
@


1.7
log
@Add domain services support code and use it to fetch the PRI
(Physical Resource Inventory) from the service processor.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldomctl.c,v 1.6 2012/10/20 16:44:16 kettenis Exp $	*/
d30 1
a30 2

#define DPRINTF(x)	printf x
@


1.6
log
@Fix previous.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldomctl.c,v 1.5 2012/10/20 13:05:54 kettenis Exp $	*/
d28 1
d31 2
d152 2
d167 2
a168 2
int seq = 1;
int fd;
d174 3
d202 2
a203 2
	fd = open("/dev/hvctl", O_RDWR, 0);
	if (fd == -1)
d210 1
a210 1
	msg.hdr.seq = seq++;
d212 1
a212 1
	nbytes = write(fd, &msg, sizeof(msg));
d217 1
a217 1
	nbytes = read(fd, &msg, sizeof(msg));
d228 1
a228 1
	msg.hdr.seq = seq++;
d230 1
a230 1
	nbytes = write(fd, &msg, sizeof(msg));
d235 1
a235 1
	nbytes = read(fd, &msg, sizeof(msg));
d244 2
a245 2
	msg.hdr.seq = seq++;
	nbytes = write(fd, &msg, sizeof(msg));
d250 1
a250 1
	nbytes = read(fd, &msg, sizeof(msg));
d258 1
a258 1
	if (ioctl(fd, HVIOCREAD, &hi) == -1)
d269 1
a269 1
	if (ioctl(fd, HVIOCREAD, &hi) == -1)
d339 51
d409 8
d422 1
a422 1
		if (ioctl(fd, HVIOCREAD, &hi) == -1)
d433 1
a433 1
		if (ioctl(fd, HVIOCREAD, &hi) == -1)
d464 1
a464 1
	msg.hdr.seq = seq++;
d466 1
a466 1
	nbytes = write(fd, &msg, sizeof(msg));
d471 1
a471 1
	nbytes = read(fd, &msg, sizeof(msg));
d490 1
a490 1
	msg.hdr.seq = seq++;
d492 1
a492 1
	nbytes = write(fd, &msg, sizeof(msg));
d497 1
a497 1
	nbytes = read(fd, &msg, sizeof(msg));
d531 1
a531 1
		msg.hdr.seq = seq++;
d535 1
a535 1
		nbytes = write(fd, &msg, sizeof(msg));
d540 1
a540 1
		nbytes = read(fd, &msg, sizeof(msg));
d557 1
a557 1
			msg.hdr.seq = seq++;
d561 1
a561 1
			nbytes = write(fd, &msg, sizeof(msg));
d566 1
a566 1
			nbytes = read(fd, &msg, sizeof(msg));
d575 1
a575 1
			msg.hdr.seq = seq++;
d579 1
a579 1
			nbytes = write(fd, &msg, sizeof(msg));
d584 1
a584 1
			nbytes = read(fd, &msg, sizeof(msg));
@


1.5
log
@Add code to dump the current hypervisor configuration.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldomctl.c,v 1.4 2012/10/16 19:57:23 kettenis Exp $	*/
d360 1
a360 1
		md_buf = xmalloc(hvmd_len);
@


1.4
log
@Add domain utilisation to status display.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldomctl.c,v 1.3 2012/10/15 20:28:50 kettenis Exp $	*/
d137 1
d149 1
d155 1
d165 2
d178 2
a179 1
	size_t len;
d253 4
a256 1
	len = sizeof(hdr) + hdr.node_blk_sz + hdr.name_blk_sz + hdr.data_blk_sz;
d258 2
a259 2
	hi.hi_addr = malloc(len);
	hi.hi_len = len;
d264 1
a264 4
	hvmd = md_ingest(hi.hi_addr, len);

	struct md_node *node;
	struct md_prop *prop;
d300 2
d328 53
@


1.3
log
@Specify domains by name instead of by number.
Provide status of all domains if none specified.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldomctl.c,v 1.2 2012/10/14 16:11:45 kettenis Exp $	*/
d97 8
d125 1
d138 2
d286 1
d295 9
d379 3
a381 2
	struct hvctl_rs_guest_state *state;
	struct hvctl_rs_guest_softstate *softstate;
d384 2
a386 1
	const char *soft_state_str;
d416 2
a417 2
		state = (void *)msg.msg.resstat.data;
		switch (state->state) {
d420 3
a422 1
			soft_state_str = "";
d442 35
a476 2
			softstate = (void *)msg.msg.resstat.data;
			soft_state_str = softstate->soft_state_str;
a479 1
			soft_state_str = "";
d483 1
a483 1
			    state->state);
a484 1
			soft_state_str = "";
d488 6
a493 2
		printf("%-16s  %-16s  %-32s\n", guest->name, state_str,
		    soft_state_str);
@


1.2
log
@Add status command.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldomctl.c,v 1.1 2012/10/14 15:38:06 kettenis Exp $	*/
d20 1
d28 10
d108 1
d125 12
d151 2
d158 1
d161 2
d164 1
a164 1
	if (argc != 3)
d214 42
d266 2
a267 1
	fprintf(stderr, "usage: %s start|stop|status domain\n", __progname);
d272 30
d307 3
d316 1
a316 1
	msg.msg.guestop.guestid = atoi(argv[1]);
d333 3
d342 1
a342 1
	msg.msg.guestop.guestid = atoi(argv[1]);
d360 5
d366 4
a369 12
	/*
	 * Request status.
	 */
	bzero(&msg, sizeof(msg));
	msg.hdr.op = HVCTL_OP_GET_RES_STAT;
	msg.hdr.seq = seq++;
	msg.msg.resstat.res = HVCTL_RES_GUEST;
	msg.msg.resstat.resid = atoi(argv[1]);
	msg.msg.resstat.infoid = HVCTL_INFO_GUEST_STATE;
	nbytes = write(fd, &msg, sizeof(msg));
	if (nbytes != sizeof(msg))
		err(1, "write");
d371 30
a400 4
	bzero(&msg, sizeof(msg));
	nbytes = read(fd, &msg, sizeof(msg));
	if (nbytes != sizeof(msg))
		err(1, "read");
d402 14
a415 14
	state = (void *)msg.msg.resstat.data;
	switch (state->state) {
	case GUEST_STATE_STOPPED:
		printf("Stopped\n");
		return;
	case GUEST_STATE_NORMAL:
		break;
	case GUEST_STATE_UNCONFIGURED:
		printf("Unconfigured\n");
		return;
	default:
		printf("Unknown (%lld)\n", state->state);
		return;
	}
d417 14
a430 9
	bzero(&msg, sizeof(msg));
	msg.hdr.op = HVCTL_OP_GET_RES_STAT;
	msg.hdr.seq = seq++;
	msg.msg.resstat.res = HVCTL_RES_GUEST;
	msg.msg.resstat.resid = atoi(argv[1]);
	msg.msg.resstat.infoid = HVCTL_INFO_GUEST_SOFT_STATE;
	nbytes = write(fd, &msg, sizeof(msg));
	if (nbytes != sizeof(msg))
		err(1, "write");
d432 3
a434 7
	bzero(&msg, sizeof(msg));
	nbytes = read(fd, &msg, sizeof(msg));
	if (nbytes != sizeof(msg))
		err(1, "read");

	softstate = (void *)msg.msg.resstat.data;
	printf("%s\n", softstate->soft_state_str);
@


1.1
log
@Beginning of a tool to control sun4v logical domains.  For now this can start
and stop domains.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d27 11
d77 9
d99 6
d115 1
d120 1
d195 1
a195 1
	fprintf(stderr, "usage: %s start|stop domain\n", __progname);
d243 60
@

