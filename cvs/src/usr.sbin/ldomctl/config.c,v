head	1.22;
access;
symbols
	OPENBSD_6_1:1.22.0.4
	OPENBSD_6_1_BASE:1.22
	OPENBSD_6_0:1.21.0.8
	OPENBSD_6_0_BASE:1.21
	OPENBSD_5_9:1.21.0.4
	OPENBSD_5_9_BASE:1.21
	OPENBSD_5_8:1.21.0.6
	OPENBSD_5_8_BASE:1.21
	OPENBSD_5_7:1.21.0.2
	OPENBSD_5_7_BASE:1.21
	OPENBSD_5_6:1.19.0.8
	OPENBSD_5_6_BASE:1.19
	OPENBSD_5_5:1.19.0.6
	OPENBSD_5_5_BASE:1.19
	OPENBSD_5_4:1.19.0.2
	OPENBSD_5_4_BASE:1.19
	OPENBSD_5_3:1.15.0.2
	OPENBSD_5_3_BASE:1.15;
locks; strict;
comment	@ * @;


1.22
date	2017.01.17.22.10.55;	author krw;	state Exp;
branches;
next	1.21;
commitid	nf3UdaW8au6U0a03;

1.21
date	2014.09.28.18.42.50;	author kettenis;	state Exp;
branches;
next	1.20;
commitid	TQR504YifC48vsJ0;

1.20
date	2014.09.13.16.06.37;	author doug;	state Exp;
branches;
next	1.19;
commitid	jdBY2kKXhfcoQitp;

1.19
date	2013.05.08.00.15.03;	author gsoares;	state Exp;
branches;
next	1.18;

1.18
date	2013.04.03.15.38.48;	author kettenis;	state Exp;
branches;
next	1.17;

1.17
date	2013.04.01.17.51.56;	author kettenis;	state Exp;
branches;
next	1.16;

1.16
date	2013.03.04.11.54.13;	author otto;	state Exp;
branches;
next	1.15;

1.15
date	2013.02.26.23.03.39;	author kettenis;	state Exp;
branches;
next	1.14;

1.14
date	2012.12.08.18.45.26;	author kettenis;	state Exp;
branches;
next	1.13;

1.13
date	2012.12.08.15.11.40;	author kettenis;	state Exp;
branches;
next	1.12;

1.12
date	2012.12.01.14.35.41;	author kettenis;	state Exp;
branches;
next	1.11;

1.11
date	2012.12.01.10.39.38;	author kettenis;	state Exp;
branches;
next	1.10;

1.10
date	2012.11.26.21.01.43;	author kettenis;	state Exp;
branches;
next	1.9;

1.9
date	2012.11.26.20.37.20;	author kettenis;	state Exp;
branches;
next	1.8;

1.8
date	2012.11.26.20.08.15;	author kettenis;	state Exp;
branches;
next	1.7;

1.7
date	2012.11.25.21.45.37;	author kettenis;	state Exp;
branches;
next	1.6;

1.6
date	2012.11.25.18.23.02;	author kettenis;	state Exp;
branches;
next	1.5;

1.5
date	2012.11.25.16.18.04;	author kettenis;	state Exp;
branches;
next	1.4;

1.4
date	2012.11.25.14.01.58;	author kettenis;	state Exp;
branches;
next	1.3;

1.3
date	2012.11.24.22.54.02;	author kettenis;	state Exp;
branches;
next	1.2;

1.2
date	2012.11.24.17.04.03;	author kettenis;	state Exp;
branches;
next	1.1;

1.1
date	2012.11.24.11.50.45;	author kettenis;	state Exp;
branches;
next	;


desc
@@


1.22
log
@Nuke some whitespace that keeps poking me in the eye as I try to
steal code.
@
text
@/*	$OpenBSD: config.c,v 1.21 2014/09/28 18:42:50 kettenis Exp $	*/

/*
 * Copyright (c) 2012 Mark Kettenis
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/queue.h>
#include <assert.h>
#include <err.h>
#include <stdarg.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "mdesc.h"
#include "ldomctl.h"
#include "util.h"

#define LDC_GUEST	0
#define LDC_HV		1
#define LDC_SP		2

#define LDC_HVCTL_SVC	1
#define LDC_CONSOLE_SVC	2

#define MAX_STRANDS_PER_CORE	16

struct core {
	struct guest *guests[MAX_STRANDS_PER_CORE];
	TAILQ_ENTRY(core) link;
};

TAILQ_HEAD(, core) cores;

struct frag {
	TAILQ_ENTRY(frag) link;
	uint64_t base;
};

struct guest **guests;
struct console **consoles;
struct cpu **cpus;
struct device **pcie_busses;
struct device **network_devices;
struct mblock **mblocks;
struct ldc_endpoint **ldc_endpoints;

uint64_t max_cpus;
bool have_cwqs;
bool have_rngs;

uint64_t max_guests;
uint64_t max_hv_ldcs;
uint64_t max_guest_ldcs;
uint64_t md_maxsize;
uint64_t md_elbow_room;
uint64_t max_mblocks;

uint64_t max_devices = 16;

uint64_t rombase;
uint64_t romsize;

uint64_t max_page_size;

uint64_t content_version;
uint64_t stick_frequency;
uint64_t tod_frequency;
uint64_t tod;
uint64_t erpt_pa;
uint64_t erpt_size;

struct md *pri;
struct md *hvmd;
struct md *protomd;

struct guest *guest_lookup(const char *);

TAILQ_HEAD(, frag) free_frags = TAILQ_HEAD_INITIALIZER(free_frags);
TAILQ_HEAD(, cpu) free_cpus = TAILQ_HEAD_INITIALIZER(free_cpus);
int total_cpus;
TAILQ_HEAD(, mblock) free_memory = TAILQ_HEAD_INITIALIZER(free_memory);
uint64_t total_memory;

struct cpu *
pri_find_cpu(uint64_t pid)
{
	struct cpu *cpu = NULL;

	TAILQ_FOREACH(cpu, &free_cpus, link) {
		if (cpu->pid == pid)
			break;
	}

	return cpu;
}

void
pri_link_core(struct md *md, struct md_node *node, struct core *core)
{
	struct md_node *node2;
	struct md_prop *prop;
	struct cpu *cpu;
	uint64_t pid;

	TAILQ_FOREACH(prop, &node->prop_list, link) {
		if (prop->tag == MD_PROP_ARC &&
		    strcmp(prop->name->str, "back") == 0) {
			node2 = prop->d.arc.node;
			if (strcmp(node2->name->str, "cpu") != 0) {
				pri_link_core(md, node2, core);
				continue;
			}

			pid = -1;
			if (!md_get_prop_val(md, node2, "pid", &pid))
				md_get_prop_val(md, node2, "id", &pid);

			cpu = pri_find_cpu(pid);
			if (cpu == NULL)
				errx(1, "couldn't determine core for VCPU %lld\n", pid);
			cpu->core = core;
		}
	}
}

void
pri_add_core(struct md *md, struct md_node *node)
{
	struct core *core;

	core = xzalloc(sizeof(*core));
	TAILQ_INSERT_TAIL(&cores, core, link);

	pri_link_core(md, node, core);
}

void
pri_init_cores(struct md *md)
{
	struct md_node *node;
	const void *type;
	size_t len;

	TAILQ_INIT(&cores);

	TAILQ_FOREACH(node, &md->node_list, link) {
		if (strcmp(node->name->str, "tlb") == 0 &&
		    md_get_prop_data(md, node, "type", &type, &len) &&
		    strcmp(type, "data") == 0) {
			pri_add_core(md, node);
		}
	}
}

void
pri_add_cpu(struct md *md, struct md_node *node)
{
	struct cpu *cpu;
	uint64_t mmu_page_size_list;
	uint64_t page_size;

	cpu = xzalloc(sizeof(*cpu));
	/*
	 * Only UltraSPARC T1 CPUs have a "pid" property.  All other
	 * just have a "id" property that can be used as the physical ID.
	 */
	if (!md_get_prop_val(md, node, "pid", &cpu->pid))
		md_get_prop_val(md, node, "id", &cpu->pid);
	cpu->vid = -1;
	cpu->gid = -1;
	cpu->partid = -1;
	cpu->resource_id = -1;
	TAILQ_INSERT_TAIL(&free_cpus, cpu, link);
	total_cpus++;

	mmu_page_size_list = 0x9;
	md_get_prop_val(md, node, "mmu-page-size-list", &mmu_page_size_list);

	page_size = 1024;
	while (mmu_page_size_list) {
		page_size *= 8;
		mmu_page_size_list >>= 1;
	}

	if (page_size > max_page_size)
		max_page_size = page_size;
}

struct cpu *
pri_alloc_cpu(uint64_t pid)
{
	struct cpu *cpu;

	if (pid == -1 && !TAILQ_EMPTY(&free_cpus)) {
		cpu = TAILQ_FIRST(&free_cpus);
		TAILQ_REMOVE(&free_cpus, cpu, link);
		return cpu;
	}

	TAILQ_FOREACH(cpu, &free_cpus, link) {
		if (cpu->pid == pid) {
			TAILQ_REMOVE(&free_cpus, cpu, link);
			return cpu;
		}
	}

	return NULL;
}

void
pri_free_cpu(struct cpu *cpu)
{
	TAILQ_INSERT_TAIL(&free_cpus, cpu, link);
}

void
pri_add_mblock(struct md *md, struct md_node *node)
{
	struct mblock *mblock;

	mblock = xzalloc(sizeof(*mblock));
	md_get_prop_val(md, node, "base", &mblock->membase);
	md_get_prop_val(md, node, "size", &mblock->memsize);
	mblock->resource_id = -1;
	TAILQ_INSERT_TAIL(&free_memory, mblock, link);
	total_memory += mblock->memsize;
}

struct mblock *
pri_alloc_memory(uint64_t base, uint64_t size)
{
	struct mblock *mblock, *new_mblock;
	uint64_t memend;

	if (base == -1 && !TAILQ_EMPTY(&free_memory)) {
		mblock = TAILQ_FIRST(&free_memory);
		base = mblock->membase;
	}

	TAILQ_FOREACH(mblock, &free_memory, link) {
		if (base >= mblock->membase &&
		    base < mblock->membase + mblock->memsize) {
			if (base > mblock->membase) {
				new_mblock = xzalloc(sizeof(*new_mblock));
				new_mblock->membase = mblock->membase;
				new_mblock->memsize = base - mblock->membase;
				new_mblock->resource_id = -1;
				TAILQ_INSERT_BEFORE(mblock, new_mblock, link);
			}

			memend = mblock->membase + mblock->memsize;
			mblock->membase = base + size;
			mblock->memsize = memend - mblock->membase;
			if (mblock->memsize == 0) {
				TAILQ_REMOVE(&free_memory, mblock, link);
				free(mblock);
			}

			total_memory -= size;

			new_mblock = xzalloc(sizeof(*new_mblock));
			new_mblock->membase = base;
			new_mblock->memsize = size;
			new_mblock->resource_id = -1;
			return new_mblock;;
		}
	}

	return NULL;
}

void
pri_init(struct md *md)
{
	struct md_node *node, *node2;
	struct md_prop *prop;
	uint64_t base, size;
	uint64_t offset, guest_use;

	node = md_find_node(pri, "platform");
	if (node == NULL)
		errx(1, "platform node not found");

	md_get_prop_val(md, node, "max-cpus", &max_cpus);

	node = md_find_node(pri, "firmware");
	if (node == NULL)
		errx(1, "firmware node not found");

	md_get_prop_val(md, node, "max_guests", &max_guests);
	md_get_prop_val(md, node, "max_hv_ldcs", &max_hv_ldcs);
	md_get_prop_val(md, node, "max_guest_ldcs", &max_guest_ldcs);
	md_get_prop_val(md, node, "md_elbow_room", &md_elbow_room);
	md_get_prop_val(md, node, "max_mblocks", &max_mblocks);

	node = md_find_node(md, "read_only_memory");
	if (node == NULL)
		errx(1, "read_only_memory node not found");
	if (!md_get_prop_val(md, node, "base", &base))
		errx(1, "missing base property in read_only_memory node");
	if (!md_get_prop_val(md, node, "size", &size))
		errx(1, "missing size property in read_only_memory node");
	TAILQ_FOREACH(prop, &node->prop_list, link) {
		if (prop->tag == MD_PROP_ARC &&
		    strcmp(prop->name->str, "fwd") == 0) {
			node2 = prop->d.arc.node;
			if (!md_get_prop_val(md, node2, "guest_use",
			    &guest_use) || guest_use == 0)
				continue;
			if (!md_get_prop_val(md, node2, "offset", &offset) ||
			    !md_get_prop_val(md, node2, "size", &size))
					continue;
			rombase = base + offset;
			romsize = size;
		}
	}
	if (romsize == 0)
		errx(1, "no suitable firmware image found");

	node = md_find_node(md, "platform");
	assert(node);
	md_set_prop_val(md, node, "domaining-enabled", 0x1);

	md_write(md, "pri");

	protomd = md_copy(md);
	md_find_delete_node(protomd, "components");
	md_find_delete_node(protomd, "devalias");
	md_find_delete_node(protomd, "domain-services");
	md_find_delete_node(protomd, "channel-devices");
	md_find_delete_node(protomd, "channel-endpoints");
	md_find_delete_node(protomd, "firmware");
	md_find_delete_node(protomd, "ldc_endpoints");
	md_find_delete_node(protomd, "memory-segments");
	md_collect_garbage(protomd);
	md_write(protomd, "protomd");

	guests = xzalloc(max_guests * sizeof(*guests));
	consoles = xzalloc(max_guests * sizeof(*consoles));
	cpus = xzalloc(max_cpus * sizeof(*cpus));
	pcie_busses = xzalloc(max_devices * sizeof(*pcie_busses));
	network_devices = xzalloc(max_devices * sizeof(*network_devices));
	mblocks = xzalloc(max_mblocks * sizeof(*mblocks));
	ldc_endpoints = xzalloc(max_guest_ldcs * sizeof(*ldc_endpoints));

	node = md_find_node(md, "cpus");
	TAILQ_FOREACH(prop, &node->prop_list, link) {
		if (prop->tag == MD_PROP_ARC &&
		    strcmp(prop->name->str, "fwd") == 0)
			pri_add_cpu(md, prop->d.arc.node);
	}

	node = md_find_node(md, "memory");
	TAILQ_FOREACH(prop, &node->prop_list, link) {
		if (prop->tag == MD_PROP_ARC &&
		    strcmp(prop->name->str, "fwd") == 0)
			pri_add_mblock(md, prop->d.arc.node);
	}

	pri_init_cores(md);
}

void
hvmd_fixup_guest(struct md *md, struct md_node *guest, struct md_node *node)
{
	struct md_prop *prop;

	TAILQ_FOREACH(prop, &guest->prop_list, link) {
		if (prop->tag == MD_PROP_ARC &&
		    strcmp(prop->name->str, "fwd") == 0) {
			if (prop->d.arc.node == node)
				return;
		}
	}

	md_add_prop_arc(md, guest, "fwd", node);
}

uint64_t fragsize;
TAILQ_HEAD(, mblock) frag_mblocks;
struct mblock *hvmd_mblock;

void
hvmd_init_frag(struct md *md, struct md_node *node)
{
	struct frag *frag;
	struct mblock *mblock;
	uint64_t base, size;

	md_get_prop_val(md, node, "base", &base);
	md_get_prop_val(md, node, "size", &size);

	pri_alloc_memory(base, size);

	mblock = xzalloc(sizeof(*mblock));
	mblock->membase = base;
	mblock->memsize = size;
	TAILQ_INSERT_TAIL(&frag_mblocks, mblock, link);

	while (size > fragsize) {
		frag = xmalloc(sizeof(*frag));
		frag->base = base;
		TAILQ_INSERT_TAIL(&free_frags, frag, link);
		base += fragsize;
		size -= fragsize;
	}
}

uint64_t
hvmd_alloc_frag(uint64_t base)
{
	struct frag *frag = TAILQ_FIRST(&free_frags);

	if (base != -1) {
		TAILQ_FOREACH(frag, &free_frags, link) {
			if (frag->base == base)
				break;
		}
	}

	if (frag == NULL)
		return -1;

	TAILQ_REMOVE(&free_frags, frag, link);
	base = frag->base;
	free(frag);

	return base;
}

void
hvmd_free_frag(uint64_t base)
{
	struct frag *frag;

	frag = xmalloc(sizeof(*frag));
	frag->base = base;
	TAILQ_INSERT_TAIL(&free_frags, frag, link);
}

void
hvmd_init_mblock(struct md *md, struct md_node *node)
{
	struct mblock *mblock;
	uint64_t resource_id;
	struct md_node *node2;
	struct md_prop *prop;

	if (!md_get_prop_val(md, node, "resource_id", &resource_id))
		errx(1, "missing resource_id property in mblock node");

	if (resource_id >= max_mblocks)
		errx(1, "resource_id larger than max_mblocks");

	mblock = xzalloc(sizeof(*mblock));
	md_get_prop_val(md, node, "membase", &mblock->membase);
	md_get_prop_val(md, node, "memsize", &mblock->memsize);
	md_get_prop_val(md, node, "realbase", &mblock->realbase);
	mblock->resource_id = resource_id;
	mblocks[resource_id] = mblock;
	mblock->hv_node = node;

	/* Fixup missing links. */
	TAILQ_FOREACH(prop, &node->prop_list, link) {
		if (prop->tag == MD_PROP_ARC &&
		    strcmp(prop->name->str, "back") == 0) {
			node2 = prop->d.arc.node;
			if (strcmp(node2->name->str, "guest") == 0)
				hvmd_fixup_guest(md, node2, node);
		}
	}
}

void
hvmd_init_console(struct md *md, struct md_node *node)
{
	struct console *console;
	uint64_t resource_id;

	if (!md_get_prop_val(md, node, "resource_id", &resource_id))
		errx(1, "missing resource_id property in console node");

	if (resource_id >= max_guests)
		errx(1, "resource_id larger than max_guests");

	console = xmalloc(sizeof(*console));
	md_get_prop_val(md, node, "ino", &console->ino);
	console->resource_id = resource_id;
	consoles[resource_id] = console;
	console->hv_node = node;
}

void
hvmd_init_cpu(struct md *md, struct md_node *node)
{
	struct cpu *cpu;
	uint64_t pid;
	uint64_t resource_id;
	struct md_node *node2;
	struct md_prop *prop;

	if (!md_get_prop_val(md, node, "resource_id", &resource_id))
		errx(1, "missing resource_id property in cpu node");

	if (resource_id >= max_cpus)
		errx(1, "resource_id larger than max-cpus");

	if (!md_get_prop_val(md, node, "pid", &pid))
		errx(1, "missing pid property in cpu node");

	cpu = pri_alloc_cpu(pid);
	md_get_prop_val(md, node, "vid", &cpu->vid);
	if (!md_get_prop_val(md, node, "gid", &cpu->gid))
		cpu->gid = 0;
	md_get_prop_val(md, node, "partid", &cpu->partid);
	cpu->resource_id = resource_id;
	cpus[resource_id] = cpu;
	cpu->hv_node = node;

	/* Fixup missing links. */
	TAILQ_FOREACH(prop, &node->prop_list, link) {
		if (prop->tag == MD_PROP_ARC &&
		    strcmp(prop->name->str, "back") == 0) {
			node2 = prop->d.arc.node;
			if (strcmp(node2->name->str, "guest") == 0)
				hvmd_fixup_guest(md, node2, node);
		}
	}
}

void
hvmd_init_device(struct md *md, struct md_node *node)
{
	struct device *device;
	uint64_t resource_id;
	struct md_node *node2;
	struct md_prop *prop;

	if (strcmp(node->name->str, "pcie_bus") != 0 &&
	    strcmp(node->name->str, "network_device") != 0)
		return;

	if (!md_get_prop_val(md, node, "resource_id", &resource_id))
		errx(1, "missing resource_id property in ldc_endpoint node");

	if (resource_id >= max_devices)
		errx(1, "resource_id larger than max_devices");

	device = xzalloc(sizeof(*device));
	md_get_prop_val(md, node, "gid", &device->gid);
	md_get_prop_val(md, node, "cfghandle", &device->cfghandle);
	device->resource_id = resource_id;
	if (strcmp(node->name->str, "pcie_bus") == 0)
		pcie_busses[resource_id] = device;
	else
		network_devices[resource_id] = device;
	device->hv_node = node;

	/* Fixup missing links. */
	TAILQ_FOREACH(prop, &node->prop_list, link) {
		if (prop->tag == MD_PROP_ARC &&
		    strcmp(prop->name->str, "back") == 0) {
			node2 = prop->d.arc.node;
			if (strcmp(node2->name->str, "guest") == 0)
				hvmd_fixup_guest(md, node2, node);
		}
	}
}

void
hvmd_init_endpoint(struct md *md, struct md_node *node)
{
	struct ldc_endpoint *endpoint;
	uint64_t resource_id;

	if (!md_get_prop_val(md, node, "resource_id", &resource_id))
		errx(1, "missing resource_id property in ldc_endpoint node");

	if (resource_id >= max_guest_ldcs)
		errx(1, "resource_id larger than max_guest_ldcs");

	if (ldc_endpoints[resource_id]) {
		/*
		 * Some machine descriptions seem to have duplicate
		 * arcs.  Fortunately, these can be easily detected
		 * and ignored.
		 */
		if (ldc_endpoints[resource_id]->hv_node == node)
			return;
		errx(1, "duplicate resource_id");
	}

	endpoint = xzalloc(sizeof(*endpoint));
	endpoint->target_guest = -1;
	endpoint->tx_ino = -1;
	endpoint->rx_ino = -1;
	endpoint->private_svc = -1;
	endpoint->svc_id = -1;
	md_get_prop_val(md, node, "target_type", &endpoint->target_type);
	md_get_prop_val(md, node, "target_guest", &endpoint->target_guest);
	md_get_prop_val(md, node, "channel", &endpoint->channel);
	md_get_prop_val(md, node, "target_channel", &endpoint->target_channel);
	md_get_prop_val(md, node, "tx-ino", &endpoint->tx_ino);
	md_get_prop_val(md, node, "rx-ino", &endpoint->rx_ino);
	md_get_prop_val(md, node, "private_svc", &endpoint->private_svc);
	md_get_prop_val(md, node, "svc_id", &endpoint->svc_id);
	endpoint->resource_id = resource_id;
	ldc_endpoints[resource_id] = endpoint;
	endpoint->hv_node = node;
}

void
hvmd_init_guest(struct md *md, struct md_node *node)
{
	struct guest *guest;
	struct md_node *node2;
	struct md_prop *prop;
	uint64_t resource_id;
	struct ldc_endpoint *endpoint;
	char *path;

	if (!md_get_prop_val(md, node, "resource_id", &resource_id))
		errx(1, "missing resource_id property in guest node");

	if (resource_id >= max_guests)
		errx(1, "resource_id larger than max_guests");

	guest = xzalloc(sizeof(*guest));
	TAILQ_INIT(&guest->cpu_list);
	TAILQ_INIT(&guest->device_list);
	TAILQ_INIT(&guest->mblock_list);
	TAILQ_INIT(&guest->endpoint_list);
	md_get_prop_str(md, node, "name", &guest->name);
	md_get_prop_val(md, node, "gid", &guest->gid);
	md_get_prop_val(md, node, "pid", &guest->pid);
	md_get_prop_val(md, node, "tod-offset", &guest->tod_offset);
	md_get_prop_val(md, node, "perfctraccess", &guest->perfctraccess);
	md_get_prop_val(md, node, "perfctrhtaccess", &guest->perfctrhtaccess);
	md_get_prop_val(md, node, "rngctlaccessible", &guest->rngctlaccessible);
	md_get_prop_val(md, node, "mdpa", &guest->mdpa);
	guest->resource_id = resource_id;
	guests[resource_id] = guest;
	guest->hv_node = node;

	if (strcmp(guest->name, "primary") == 0 && guest->gid != 0)
		errx(1, "gid of primary domain isn't 0");

	hvmd_alloc_frag(guest->mdpa);

	TAILQ_FOREACH(prop, &node->prop_list, link) {
		if (prop->tag == MD_PROP_ARC &&
		    strcmp(prop->name->str, "fwd") == 0) {
			node2 = prop->d.arc.node;
			if (strcmp(node2->name->str, "console") == 0) {
				md_get_prop_val(md, node2, "resource_id",
				    &resource_id);
				guest->console = consoles[resource_id];
				consoles[resource_id]->guest = guest;
			}
			if (strcmp(node2->name->str, "cpu") == 0) {
				md_get_prop_val(md, node2, "resource_id",
				    &resource_id);
				TAILQ_INSERT_TAIL(&guest->cpu_list,
				    cpus[resource_id], link);
				cpus[resource_id]->guest = guest;
			}
			if (strcmp(node2->name->str, "pcie_bus") == 0) {
				md_get_prop_val(md, node2, "resource_id",
				    &resource_id);
				TAILQ_INSERT_TAIL(&guest->device_list,
				    pcie_busses[resource_id], link);
				pcie_busses[resource_id]->guest = guest;
			}
			if (strcmp(node2->name->str, "network_device") == 0) {
				md_get_prop_val(md, node2, "resource_id",
				    &resource_id);
				TAILQ_INSERT_TAIL(&guest->device_list,
				    network_devices[resource_id], link);
				network_devices[resource_id]->guest = guest;
			}
			if (strcmp(node2->name->str, "mblock") == 0) {
				md_get_prop_val(md, node2, "resource_id",
				    &resource_id);
				TAILQ_INSERT_TAIL(&guest->mblock_list,
				    mblocks[resource_id], link);
				mblocks[resource_id]->guest = guest;
			}
			if (strcmp(node2->name->str, "ldc_endpoint") == 0) {
				md_get_prop_val(md, node2, "resource_id",
				    &resource_id);
				TAILQ_INSERT_TAIL(&guest->endpoint_list,
				    ldc_endpoints[resource_id], link);
				ldc_endpoints[resource_id]->guest = guest;
			}
		}
	}

	TAILQ_FOREACH(endpoint, &guest->endpoint_list, link) {
		if (endpoint->channel >= guest->endpoint_id)
			guest->endpoint_id = endpoint->channel + 1;
	}

	xasprintf(&path, "%s.md", guest->name);
	guest->md = md_read(path);

	if (guest->md == NULL)
		err(1, "unable to get guest MD");

	free(path);
}

void
hvmd_init(struct md *md)
{
	struct md_node *node;
	struct md_prop *prop;

	node = md_find_node(md, "root");
	md_get_prop_val(md, node, "content-version", &content_version);
	md_get_prop_val(md, node, "stick-frequency", &stick_frequency);
	md_get_prop_val(md, node, "tod-frequency", &tod_frequency);
	md_get_prop_val(md, node, "tod", &tod);
	md_get_prop_val(md, node, "erpt-pa", &erpt_pa);
	md_get_prop_val(md, node, "erpt-size", &erpt_size);

	node = md_find_node(md, "frag_space");
	md_get_prop_val(md, node, "fragsize", &fragsize);
	TAILQ_INIT(&frag_mblocks);
	TAILQ_FOREACH(prop, &node->prop_list, link) {
		if (prop->tag == MD_PROP_ARC &&
		    strcmp(prop->name->str, "fwd") == 0)
			hvmd_init_frag(md, prop->d.arc.node);
	}
	pri_alloc_memory(0, fragsize);

	node = md_find_node(md, "hvmd_mblock");
	if (node) {
		hvmd_mblock = xzalloc(sizeof(*hvmd_mblock));
		md_get_prop_val(md, node, "base", &hvmd_mblock->membase);
		md_get_prop_val(md, node, "size", &hvmd_mblock->memsize);
		md_get_prop_val(md, node, "md_maxsize", &md_maxsize);
		pri_alloc_memory(hvmd_mblock->membase, hvmd_mblock->memsize);
	}

	node = md_find_node(md, "consoles");
	TAILQ_FOREACH(prop, &node->prop_list, link) {
		if (prop->tag == MD_PROP_ARC &&
		    strcmp(prop->name->str, "fwd") == 0)
			hvmd_init_console(md, prop->d.arc.node);
	}

	node = md_find_node(md, "cpus");
	TAILQ_FOREACH(prop, &node->prop_list, link) {
		if (prop->tag == MD_PROP_ARC &&
		    strcmp(prop->name->str, "fwd") == 0)
			hvmd_init_cpu(md, prop->d.arc.node);
	}

	have_cwqs = (md_find_node(md, "cwqs") != NULL);
	have_rngs = (md_find_node(md, "rngs") != NULL);

	node = md_find_node(md, "devices");
	TAILQ_FOREACH(prop, &node->prop_list, link) {
		if (prop->tag == MD_PROP_ARC &&
		    strcmp(prop->name->str, "fwd") == 0)
			hvmd_init_device(md, prop->d.arc.node);
	}

	node = md_find_node(md, "memory");
	TAILQ_FOREACH(prop, &node->prop_list, link) {
		if (prop->tag == MD_PROP_ARC &&
		    strcmp(prop->name->str, "fwd") == 0)
			hvmd_init_mblock(md, prop->d.arc.node);
	}

	node = md_find_node(md, "ldc_endpoints");
	TAILQ_FOREACH(prop, &node->prop_list, link) {
		if (prop->tag == MD_PROP_ARC &&
		    strcmp(prop->name->str, "fwd") == 0)
			hvmd_init_endpoint(md, prop->d.arc.node);
	}

	node = md_find_node(md, "guests");
	TAILQ_FOREACH(prop, &node->prop_list, link) {
		if (prop->tag == MD_PROP_ARC &&
		    strcmp(prop->name->str, "fwd") == 0)
			hvmd_init_guest(md, prop->d.arc.node);
	}

	hvmd_alloc_frag(-1);
}

void
hvmd_finalize_cpu(struct md *md, struct cpu *cpu)
{
	struct md_node *parent;
	struct md_node *node;
	int i;

	for (i = 0; i < MAX_STRANDS_PER_CORE; i++) {
		if (cpu->core->guests[i] == cpu->guest) {
			cpu->partid = i + 1;
			break;
		}
		if (cpu->core->guests[i] == NULL) {
			cpu->core->guests[i] = cpu->guest;
			cpu->partid = i + 1;
			break;
		}
	}

	parent = md_find_node(md, "cpus");
	assert(parent);

	node = md_add_node(md, "cpu");
	md_link_node(md, parent, node);
	md_add_prop_val(md, node, "pid", cpu->pid);
	md_add_prop_val(md, node, "vid", cpu->vid);
	md_add_prop_val(md, node, "gid", cpu->gid);
	md_add_prop_val(md, node, "partid", cpu->partid);
	md_add_prop_val(md, node, "resource_id", cpu->resource_id);
	cpu->hv_node = node;
}

void
hvmd_finalize_cpus(struct md *md)
{
	struct md_node *parent;
	struct md_node *node;
	uint64_t resource_id;

	parent = md_find_node(md, "root");
	assert(parent);

	node = md_add_node(md, "cpus");
	md_link_node(md, parent, node);

	for (resource_id = 0; resource_id < max_cpus; resource_id++) {
		if (cpus[resource_id])
			hvmd_finalize_cpu(md, cpus[resource_id]);
	}
}

void
hvmd_finalize_maus(struct md *md)
{
	struct md_node *parent;
	struct md_node *node;
	struct md_node *child;
	int i;

	parent = md_find_node(md, "root");
	assert(parent);

	node = md_add_node(md, "maus");
	md_link_node(md, parent, node);

	if (have_cwqs) {
		node = md_add_node(md, "cwqs");
		md_link_node(md, parent, node);
	}

	if (have_rngs) {
		node = md_add_node(md, "rngs");
		md_link_node(md, parent, node);
		child = md_add_node(md, "rng");
		md_link_node(md, node, child);
		for (i = 0; i < max_cpus; i++) {
			if (cpus[i])
				md_link_node(md, cpus[i]->hv_node, child);
		}
	}
}

void
hvmd_finalize_device(struct md *md, struct device *device, const char *name)
{
	struct md_node *parent;
	struct md_node *node;

	parent = md_find_node(md, "devices");
	assert(parent);

	node = md_add_node(md, name);
	md_link_node(md, parent, node);
	md_add_prop_val(md, node, "resource_id", device->resource_id);
	md_add_prop_val(md, node, "cfghandle", device->cfghandle);
	md_add_prop_val(md, node, "gid", device->gid);
	device->hv_node = node;
}

void
hvmd_finalize_devices(struct md *md)
{
	struct md_node *parent;
	struct md_node *node;
	uint64_t resource_id;

	parent = md_find_node(md, "root");
	assert(parent);

	node = md_add_node(md, "devices");
	md_link_node(md, parent, node);

	for (resource_id = 0; resource_id < max_devices; resource_id++) {
		if (pcie_busses[resource_id])
			hvmd_finalize_device(md, pcie_busses[resource_id],
			    "pcie_bus");
	}
	for (resource_id = 0; resource_id < max_devices; resource_id++) {
		if (network_devices[resource_id])
			hvmd_finalize_device(md, network_devices[resource_id],
			    "network_device");
	}
}

void
hvmd_finalize_mblock(struct md *md, struct mblock *mblock)
{
	struct md_node *parent;
	struct md_node *node;

	parent = md_find_node(md, "memory");
	assert(parent);

	node = md_add_node(md, "mblock");
	md_link_node(md, parent, node);
	md_add_prop_val(md, node, "membase", mblock->membase);
	md_add_prop_val(md, node, "memsize", mblock->memsize);
	md_add_prop_val(md, node, "realbase", mblock->realbase);
	md_add_prop_val(md, node, "resource_id", mblock->resource_id);
	mblock->hv_node = node;
}

void
hvmd_finalize_memory(struct md *md)
{
	struct md_node *parent;
	struct md_node *node;
	uint64_t resource_id;

	parent = md_find_node(md, "root");
	assert(parent);

	node = md_add_node(md, "memory");
	md_link_node(md, parent, node);

	for (resource_id = 0; resource_id < max_mblocks; resource_id++) {
		if (mblocks[resource_id])
			hvmd_finalize_mblock(md, mblocks[resource_id]);
	}
}

void
hvmd_finalize_endpoint(struct md *md, struct ldc_endpoint *endpoint)
{
	struct md_node *parent;
	struct md_node *node;

	parent = md_find_node(md, "ldc_endpoints");
	assert(parent);

	node = md_add_node(md, "ldc_endpoint");
	md_link_node(md, parent, node);
	md_add_prop_val(md, node, "resource_id", endpoint->resource_id);
	md_add_prop_val(md, node, "target_type", endpoint->target_type);
	md_add_prop_val(md, node, "channel", endpoint->channel);
	if (endpoint->target_guest != -1)
		md_add_prop_val(md, node, "target_guest",
		    endpoint->target_guest);
	md_add_prop_val(md, node, "target_channel", endpoint->target_channel);
	if (endpoint->tx_ino != -1)
		md_add_prop_val(md, node, "tx-ino", endpoint->tx_ino);
	if (endpoint->rx_ino != -1)
		md_add_prop_val(md, node, "rx-ino", endpoint->rx_ino);
	if (endpoint->private_svc != -1)
		md_add_prop_val(md, node, "private_svc",
		    endpoint->private_svc);
	if (endpoint->svc_id != -1)
		md_add_prop_val(md, node, "svc_id", endpoint->svc_id);
	endpoint->hv_node = node;
}

void
hvmd_finalize_endpoints(struct md *md)
{
	struct md_node *parent;
	struct md_node *node;
	uint64_t resource_id;

	parent = md_find_node(md, "root");
	assert(parent);

	node = md_add_node(md, "ldc_endpoints");
	md_link_node(md, parent, node);

	for (resource_id = 0; resource_id < max_guest_ldcs; resource_id++) {
		if (ldc_endpoints[resource_id])
			hvmd_finalize_endpoint(md, ldc_endpoints[resource_id]);
	}
}

void
hvmd_finalize_console(struct md *md, struct console *console)
{
	struct md_node *parent;
	struct md_node *node;
	struct ldc_endpoint *endpoint;

	parent = md_find_node(md, "consoles");
	assert(parent);

	node = md_add_node(md, "console");
	md_link_node(md, parent, node);
	md_add_prop_val(md, node, "resource_id", console->resource_id);
	md_add_prop_val(md, node, "ino", console->ino);
	console->hv_node = node;

	TAILQ_FOREACH(endpoint, &console->guest->endpoint_list, link) {
		if (endpoint->rx_ino == console->ino) {
			md_link_node(md, node, endpoint->hv_node);
			break;
		}
	}
}

void
hvmd_finalize_consoles(struct md *md)
{
	struct md_node *parent;
	struct md_node *node;
	uint64_t resource_id;

	parent = md_find_node(md, "root");
	assert(parent);

	node = md_add_node(md, "consoles");
	md_link_node(md, parent, node);

	for (resource_id = 0; resource_id < max_guests; resource_id++) {
		if (consoles[resource_id])
			hvmd_finalize_console(md, consoles[resource_id]);
	}
}

void
hvmd_finalize_guest(struct md *md, struct guest *guest)
{
	struct md_node *node;
	struct md_node *parent;
	struct cpu *cpu;
	struct device *device;
	struct mblock *mblock;
	struct ldc_endpoint *endpoint;

	parent = md_find_node(md, "guests");
	assert(parent);

	node = md_add_node(md, "guest");
	md_link_node(md, parent, node);
	md_add_prop_str(md, node, "name", guest->name);
	md_add_prop_val(md, node, "gid", guest->gid);
	md_add_prop_val(md, node, "pid", guest->pid);
	md_add_prop_val(md, node, "resource_id", guest->resource_id);
	md_add_prop_val(md, node, "tod-offset", guest->tod_offset);
	md_add_prop_val(md, node, "reset-reason", 0);
	md_add_prop_val(md, node, "perfctraccess", guest->perfctraccess);
	md_add_prop_val(md, node, "perfctrhtaccess", guest->perfctrhtaccess);
	md_add_prop_val(md, node, "rngctlaccessible", guest->rngctlaccessible);
	md_add_prop_val(md, node, "diagpriv", 0);
	md_add_prop_val(md, node, "mdpa", guest->mdpa);
	md_add_prop_val(md, node, "rombase", rombase);
	md_add_prop_val(md, node, "romsize", romsize);
	guest->hv_node = node;

	node = md_add_node(md, "virtual_devices");
	md_link_node(md, guest->hv_node, node);
	md_add_prop_val(md, node, "cfghandle", 0x100);

	node = md_add_node(md, "channel_devices");
	md_link_node(md, guest->hv_node, node);
	md_add_prop_val(md, node, "cfghandle", 0x200);

	if (guest->console)
		md_link_node(md, guest->hv_node, guest->console->hv_node);
	TAILQ_FOREACH(cpu, &guest->cpu_list, link)
		md_link_node(md, guest->hv_node, cpu->hv_node);
	TAILQ_FOREACH(device, &guest->device_list, link)
		md_link_node(md, guest->hv_node, device->hv_node);
	TAILQ_FOREACH(mblock, &guest->mblock_list, link)
		md_link_node(md, guest->hv_node, mblock->hv_node);
	TAILQ_FOREACH(endpoint, &guest->endpoint_list, link)
		md_link_node(md, guest->hv_node, endpoint->hv_node);
}

void
hvmd_finalize_guests(struct md *md)
{
	struct md_node *parent;
	struct md_node *node;
	uint64_t resource_id;

	parent = md_find_node(md, "root");
	assert(parent);

	node = md_add_node(md, "guests");
	md_link_node(md, parent, node);

	for (resource_id = 0; resource_id < max_guests; resource_id++) {
		if (guests[resource_id])
			hvmd_finalize_guest(md, guests[resource_id]);
	}
}

void
hvmd_finalize(void)
{
	struct md *md;
	struct md_node *node;
	struct md_node *parent;
	struct mblock *mblock;

	md = md_alloc();
	node = md_add_node(md, "root");
	md_add_prop_val(md, node, "content-version", content_version);
	if (content_version <= 0x100000000) {
		md_add_prop_val(md, node, "stick-frequency", stick_frequency);
		if (tod_frequency != 0)
			md_add_prop_val(md, node, "tod-frequency",
			    tod_frequency);
		if (tod != 0)
			md_add_prop_val(md, node, "tod", tod);
		if (erpt_pa != 0)
			md_add_prop_val(md, node, "erpt-pa", erpt_pa);
		if (erpt_size != 0)
			md_add_prop_val(md, node, "erpt-size", erpt_size);

		parent = node;
		node = md_add_node(md, "platform");
		md_link_node(md, parent, node);
		md_add_prop_val(md, node, "stick-frequency", stick_frequency);
	}

	parent = md_find_node(md, "root");
	assert(parent);

	node = md_add_node(md, "frag_space");
	md_link_node(md, parent, node);
	md_add_prop_val(md, node, "fragsize", fragsize);

	parent = md_find_node(md, "frag_space");
	TAILQ_FOREACH(mblock, &frag_mblocks, link) {
		node = md_add_node(md, "frag_mblock");
		md_link_node(md, parent, node);
		md_add_prop_val(md, node, "base", mblock->membase);
		md_add_prop_val(md, node, "size", mblock->memsize);
	}

	if (hvmd_mblock) {
		parent = md_find_node(md, "root");
		assert(parent);

		node = md_add_node(md, "hvmd_mblock");
		md_link_node(md, parent, node);
		md_add_prop_val(md, node, "base", hvmd_mblock->membase);
		md_add_prop_val(md, node, "size", hvmd_mblock->memsize);
		md_add_prop_val(md, node, "md_maxsize", md_maxsize);
	}

	hvmd_finalize_cpus(md);
	hvmd_finalize_maus(md);
	hvmd_finalize_devices(md);
	hvmd_finalize_memory(md);
	hvmd_finalize_endpoints(md);
	hvmd_finalize_consoles(md);
	hvmd_finalize_guests(md);

	md_write(md, "hv.md");
}

struct ldc_endpoint *
hvmd_add_endpoint(struct guest *guest)
{
	struct ldc_endpoint *endpoint;
	uint64_t resource_id;

	for (resource_id = 0; resource_id < max_guest_ldcs; resource_id++)
		if (ldc_endpoints[resource_id] == NULL)
			break;
	assert(resource_id < max_guest_ldcs);

	endpoint = xzalloc(sizeof(*endpoint));
	endpoint->target_guest = -1;
	endpoint->tx_ino = -1;
	endpoint->rx_ino = -1;
	endpoint->private_svc = -1;
	endpoint->svc_id = -1;
	endpoint->resource_id = resource_id;
	ldc_endpoints[resource_id] = endpoint;

	TAILQ_INSERT_TAIL(&guest->endpoint_list, endpoint, link);
	endpoint->guest = guest;

	return endpoint;
}

struct console *
hvmd_add_console(struct guest *guest)
{
	struct guest *primary;
	struct console *console;
	uint64_t resource_id;
	uint64_t client_channel, server_channel;

	primary = guest_lookup("primary");
	client_channel = guest->endpoint_id++;
	server_channel = primary->endpoint_id++;

	for (resource_id = 0; resource_id < max_guests; resource_id++)
		if (consoles[resource_id] == NULL)
			break;
	assert(resource_id < max_guests);

	console = xzalloc(sizeof(*console));
	console->ino = 0x11;
	console->resource_id = resource_id;
	consoles[resource_id] = console;

	console->client_endpoint = hvmd_add_endpoint(guest);
	console->client_endpoint->tx_ino = 0x11;
	console->client_endpoint->rx_ino = 0x11;
	console->client_endpoint->target_type = LDC_GUEST;
	console->client_endpoint->target_guest = primary->gid;
	console->client_endpoint->target_channel = server_channel;
	console->client_endpoint->channel = client_channel;
	console->client_endpoint->private_svc = LDC_CONSOLE_SVC;

	console->server_endpoint = hvmd_add_endpoint(primary);
	console->server_endpoint->tx_ino = 2 * server_channel;
	console->server_endpoint->rx_ino = 2 * server_channel + 1;
	console->server_endpoint->target_type = LDC_GUEST;
	console->server_endpoint->target_guest = guest->gid;
	console->server_endpoint->channel = server_channel;
	console->server_endpoint->target_channel = client_channel;

	guest->console = console;
	console->guest = guest;

	return console;
}

void
hvmd_add_domain_services(struct guest *guest)
{
	struct guest *primary;
	struct ldc_channel *ds = &guest->domain_services;
	uint64_t client_channel, server_channel;

	primary = guest_lookup("primary");
	client_channel = guest->endpoint_id++;
	server_channel = primary->endpoint_id++;

	ds->client_endpoint = hvmd_add_endpoint(guest);
	ds->client_endpoint->tx_ino = 2 * client_channel;
	ds->client_endpoint->rx_ino = 2 * client_channel + 1;
	ds->client_endpoint->target_type = LDC_GUEST;
	ds->client_endpoint->target_guest = primary->gid;
	ds->client_endpoint->target_channel = server_channel;
	ds->client_endpoint->channel = client_channel;

	ds->server_endpoint = hvmd_add_endpoint(primary);
	ds->server_endpoint->tx_ino = 2 * server_channel;
	ds->server_endpoint->rx_ino = 2 * server_channel + 1;
	ds->server_endpoint->target_type = LDC_GUEST;
	ds->server_endpoint->target_guest = guest->gid;
	ds->server_endpoint->channel = server_channel;
	ds->server_endpoint->target_channel = client_channel;
}

struct ldc_channel *
hvmd_add_vio(struct guest *guest)
{
	struct guest *primary;
	struct ldc_channel *lc = &guest->vio[guest->num_vios++];
	uint64_t client_channel, server_channel;

	primary = guest_lookup("primary");
	client_channel = guest->endpoint_id++;
	server_channel = primary->endpoint_id++;

	lc->client_endpoint = hvmd_add_endpoint(guest);
	lc->client_endpoint->tx_ino = 2 * client_channel;
	lc->client_endpoint->rx_ino = 2 * client_channel + 1;
	lc->client_endpoint->target_type = LDC_GUEST;
	lc->client_endpoint->target_guest = primary->gid;
	lc->client_endpoint->target_channel = server_channel;
	lc->client_endpoint->channel = client_channel;

	lc->server_endpoint = hvmd_add_endpoint(primary);
	lc->server_endpoint->tx_ino = 2 * server_channel;
	lc->server_endpoint->rx_ino = 2 * server_channel + 1;
	lc->server_endpoint->target_type = LDC_GUEST;
	lc->server_endpoint->target_guest = guest->gid;
	lc->server_endpoint->channel = server_channel;
	lc->server_endpoint->target_channel = client_channel;

	return lc;
}

struct guest *
hvmd_add_guest(const char *name)
{
	struct guest *guest;
	uint64_t resource_id;

	for (resource_id = 0; resource_id < max_guests; resource_id++)
		if (guests[resource_id] == NULL)
			break;
	assert(resource_id < max_guests);

	guest = xzalloc(sizeof(*guest));
	TAILQ_INIT(&guest->cpu_list);
	TAILQ_INIT(&guest->device_list);
	TAILQ_INIT(&guest->mblock_list);
	TAILQ_INIT(&guest->endpoint_list);
	guests[resource_id] = guest;
	guest->name = name;
	guest->gid = resource_id;
	guest->pid = resource_id + 1;
	guest->resource_id = resource_id;
	guest->mdpa = hvmd_alloc_frag(-1);

	hvmd_add_console(guest);
	hvmd_add_domain_services(guest);

	return guest;
}

struct md_node *
guest_add_channel_endpoints(struct guest *guest)
{
	struct md *md = guest->md;
	struct md_node *parent;
	struct md_node *node;

	parent = md_find_node(md, "root");
	assert(parent);

	node = md_add_node(md, "channel-endpoints");
	md_link_node(md, parent, node);

	return node;
}

struct md_node *
guest_add_endpoint(struct guest *guest, uint64_t id)
{
	struct md *md = guest->md;
	struct md_node *parent;
	struct md_node *node;

	parent = md_find_node(md, "channel-endpoints");
	if (parent == NULL)
		parent = guest_add_channel_endpoints(guest);

	node = md_add_node(md, "channel-endpoint");
	md_link_node(md, parent, node);
	md_add_prop_val(md, node, "id", id);
	md_add_prop_val(md, node, "tx-ino", 2 * id);
	md_add_prop_val(md, node, "rx-ino", 2 * id + 1);

	return node;
}

struct md_node *
guest_add_vcc(struct guest *guest)
{
	const char compatible[] = "SUNW,sun4v-virtual-console-concentrator";
	struct md *md = guest->md;
	struct md_node *parent;
	struct md_node *node;

	parent = md_find_node(md, "channel-devices");
	assert(parent != NULL);

	node = md_add_node(md, "virtual-device");
	md_link_node(md, parent, node);
	md_add_prop_str(md, node, "name", "virtual-console-concentrator");
	md_add_prop_data(md, node, "compatible", compatible,
	    sizeof(compatible));
	md_add_prop_str(md, node, "device_type", "vcc");
	md_add_prop_val(md, node, "cfg-handle", 0x0);
	md_add_prop_str(md, node, "svc-name", "primary-vcc0");

	return node;
}

struct md_node *
guest_find_vcc(struct guest *guest)
{
	struct md *md = guest->md;
	struct md_node *node, *node2;
	struct md_prop *prop;
	const char *name;

	node = md_find_node(md, "channel-devices");
	assert(node != NULL);

	TAILQ_FOREACH(prop, &node->prop_list, link) {
		if (prop->tag == MD_PROP_ARC &&
		    strcmp(prop->name->str, "fwd") == 0) {
			node2 = prop->d.arc.node;
			if (!md_get_prop_str(md, node2, "name", &name))
				continue;
			if (strcmp(name, "virtual-console-concentrator") == 0)
				return node2;
		}
	}

	return NULL;
}

struct md_node *
guest_add_vcc_port(struct guest *guest, struct md_node *vcc,
    const char *domain, uint64_t id, uint64_t channel)
{
	struct md *md = guest->md;
	struct md_node *node;
	struct md_node *child;

	if (vcc == NULL)
		vcc = guest_find_vcc(guest);
	if (vcc == NULL)
		vcc = guest_add_vcc(guest);

	node = md_add_node(md, "virtual-device-port");
	md_link_node(md, vcc, node);
	md_add_prop_str(md, node, "name", "vcc-port");
	md_add_prop_val(md, node, "id", id);
	md_add_prop_str(md, node, "vcc-domain-name", domain);
	md_add_prop_str(md, node, "vcc-group-name", domain);
	/* OpenBSD doesn't care about this, but Solaris might. */
	md_add_prop_val(md, node, "vcc-tcp-port", 5000 + id);

	child = guest_add_endpoint(guest, channel);
	md_link_node(md, node, child);

	return node;
}

struct md_node *
guest_add_vds(struct guest *guest)
{
	const char compatible[] = "SUNW,sun4v-disk-server";
	struct md *md = guest->md;
	struct md_node *parent;
	struct md_node *node;

	parent = md_find_node(md, "channel-devices");
	assert(parent != NULL);

	node = md_add_node(md, "virtual-device");
	md_link_node(md, parent, node);
	md_add_prop_str(md, node, "name", "virtual-disk-server");
	md_add_prop_data(md, node, "compatible", compatible,
	    sizeof(compatible));
	md_add_prop_str(md, node, "device_type", "vds");
	md_add_prop_val(md, node, "cfg-handle", 0x0);
	md_add_prop_str(md, node, "svc-name", "primary-vds0");

	return node;
}

struct md_node *
guest_find_vds(struct guest *guest)
{
	struct md *md = guest->md;
	struct md_node *node, *node2;
	struct md_prop *prop;
	const char *name;

	node = md_find_node(md, "channel-devices");
	assert(node != NULL);

	TAILQ_FOREACH(prop, &node->prop_list, link) {
		if (prop->tag == MD_PROP_ARC &&
		    strcmp(prop->name->str, "fwd") == 0) {
			node2 = prop->d.arc.node;
			if (!md_get_prop_str(md, node2, "name", &name))
				continue;
			if (strcmp(name, "virtual-disk-server") == 0)
				return node2;
		}
	}

	return NULL;
}

struct md_node *
guest_add_vds_port(struct guest *guest, struct md_node *vds,
    const char *path, uint64_t id, uint64_t channel)
{
	struct md *md = guest->md;
	struct md_node *node;
	struct md_node *child;

	if (vds == NULL)
		vds = guest_find_vds(guest);
	if (vds == NULL)
		vds = guest_add_vds(guest);

	node = md_add_node(md, "virtual-device-port");
	md_link_node(md, vds, node);
	md_add_prop_str(md, node, "name", "vds-port");
	md_add_prop_val(md, node, "id", id);
	md_add_prop_str(md, node, "vds-block-device", path);

	child = guest_add_endpoint(guest, channel);
	md_link_node(md, node, child);

	return node;
}

struct md_node *
guest_add_vsw(struct guest *guest)
{
	const char compatible[] = "SUNW,sun4v-network-switch";
	struct md *md = guest->md;
	struct md_node *parent;
	struct md_node *node;

	parent = md_find_node(md, "channel-devices");
	assert(parent != NULL);

	node = md_add_node(md, "virtual-device");
	md_link_node(md, parent, node);
	md_add_prop_str(md, node, "name", "virtual-network-switch");
	md_add_prop_data(md, node, "compatible", compatible,
	    sizeof(compatible));
	md_add_prop_str(md, node, "device_type", "vsw");
	md_add_prop_val(md, node, "cfg-handle", 0x0);
	md_add_prop_str(md, node, "svc-name", "primary-vsw0");

	return node;
}

struct md_node *
guest_find_vsw(struct guest *guest)
{
	struct md *md = guest->md;
	struct md_node *node, *node2;
	struct md_prop *prop;
	const char *name;

	node = md_find_node(md, "channel-devices");
	assert(node != NULL);

	TAILQ_FOREACH(prop, &node->prop_list, link) {
		if (prop->tag == MD_PROP_ARC &&
		    strcmp(prop->name->str, "fwd") == 0) {
			node2 = prop->d.arc.node;
			if (!md_get_prop_str(md, node2, "name", &name))
				continue;
			if (strcmp(name, "virtual-network-switch") == 0)
				return node2;
		}
	}

	return NULL;
}

struct md_node *
guest_add_vsw_port(struct guest *guest, struct md_node *vds,
    uint64_t id, uint64_t channel)
{
	struct md *md = guest->md;
	struct md_node *node;
	struct md_node *child;
	uint64_t mac_addr;

	if (vds == NULL)
		vds = guest_find_vsw(guest);
	if (vds == NULL)
		vds = guest_add_vsw(guest);
	if (!md_get_prop_val(md, vds, "local-mac-address", &mac_addr)) {
		mac_addr = 0x00144ff80000 + (arc4random() & 0x3ffff);
		md_add_prop_val(md, vds, "local-mac-address", mac_addr);
	}

	node = md_add_node(md, "virtual-device-port");
	md_link_node(md, vds, node);
	md_add_prop_str(md, node, "name", "vsw-port");
	md_add_prop_val(md, node, "id", id);

	child = guest_add_endpoint(guest, channel);
	md_link_node(md, node, child);

	return node;
}

struct md_node *
guest_add_console_device(struct guest *guest)
{
	const char compatible[] = "SUNW,sun4v-console";
	struct md *md = guest->md;
	struct md_node *parent;
	struct md_node *node;

	parent = md_find_node(md, "virtual-devices");
	assert(parent);

	node = md_add_node(md, "virtual-device");
	md_link_node(md, parent, node);
	md_add_prop_str(md, node, "name", "console");
	md_add_prop_str(md, node, "device-type", "serial");
	md_add_prop_val(md, node, "intr", 0x1);
	md_add_prop_val(md, node, "ino", 0x11);
	md_add_prop_val(md, node, "channel#", 0);
	md_add_prop_val(md, node, "cfg-handle", 0x1);
	md_add_prop_data(md, node, "compatible", compatible,
	    sizeof(compatible));

	return node;
}

struct md_node *
guest_add_vdc(struct guest *guest, uint64_t cfghandle)
{
	const char compatible[] = "SUNW,sun4v-disk";
	struct md *md = guest->md;
	struct md_node *parent;
	struct md_node *node;

	parent = md_find_node(md, "channel-devices");
	assert(parent);

	node = md_add_node(md, "virtual-device");
	md_link_node(md, parent, node);
	md_add_prop_str(md, node, "name", "disk");
	md_add_prop_str(md, node, "device-type", "block");
	md_add_prop_val(md, node, "cfg-handle", cfghandle);
	md_add_prop_data(md, node, "compatible", compatible,
	    sizeof(compatible));

	return node;
}

struct md_node *
guest_add_vdc_port(struct guest *guest, struct md_node *vdc,
    uint64_t cfghandle, uint64_t id, uint64_t channel)
{
	struct md *md = guest->md;
	struct md_node *node;
	struct md_node *child;

	if (vdc == NULL)
		vdc = guest_add_vdc(guest, cfghandle);

	node = md_add_node(md, "virtual-device-port");
	md_link_node(md, vdc, node);
	md_add_prop_str(md, node, "name", "vdc-port");
	md_add_prop_val(md, node, "id", id);

	child = guest_add_endpoint(guest, channel);
	md_link_node(md, node, child);

	return node;
}

struct md_node *
guest_add_vnet(struct guest *guest, uint64_t mac_addr, uint64_t mtu,
    uint64_t cfghandle)
{
	const char compatible[] = "SUNW,sun4v-network";
	struct md *md = guest->md;
	struct md_node *parent;
	struct md_node *node;

	parent = md_find_node(md, "channel-devices");
	assert(parent);

	node = md_add_node(md, "virtual-device");
	md_link_node(md, parent, node);
	md_add_prop_str(md, node, "name", "network");
	md_add_prop_str(md, node, "device-type", "network");
	md_add_prop_val(md, node, "cfg-handle", cfghandle);
	md_add_prop_data(md, node, "compatible", compatible,
	    sizeof(compatible));
	if (mac_addr == -1)
		mac_addr = 0x00144ff80000 + (arc4random() & 0x3ffff);
	md_add_prop_val(md, node, "local-mac-address", mac_addr);
	md_add_prop_val(md, node, "mtu", mtu);

	return node;
}

struct md_node *
guest_add_vnet_port(struct guest *guest, struct md_node *vdc,
    uint64_t mac_addr, uint64_t remote_mac_addr, uint64_t mtu, uint64_t cfghandle,
    uint64_t id, uint64_t channel)
{
	struct md *md = guest->md;
	struct md_node *node;
	struct md_node *child;

	if (vdc == NULL)
		vdc = guest_add_vnet(guest, mac_addr, mtu, cfghandle);

	node = md_add_node(md, "virtual-device-port");
	md_link_node(md, vdc, node);
	md_add_prop_str(md, node, "name", "vnet-port");
	md_add_prop_val(md, node, "id", id);
	md_add_prop_val(md, node, "switch-port", 0);
	md_add_prop_data(md, node, "remote-mac-address",
	    (uint8_t *)&remote_mac_addr, sizeof(remote_mac_addr));

	child = guest_add_endpoint(guest, channel);
	md_link_node(md, node, child);

	return node;
}

struct md_node *
guest_add_channel_devices(struct guest *guest)
{
	const char compatible[] = "SUNW,sun4v-channel-devices";
	struct md *md = guest->md;
	struct md_node *parent;
	struct md_node *node;

	parent = md_find_node(md, "virtual-devices");
	assert(parent);

	node = md_add_node(md, "channel-devices");
	md_link_node(md, parent, node);
	md_add_prop_str(md, node, "name", "channel-devices");
	md_add_prop_str(md, node, "device-type", "channel-devices");
	md_add_prop_data(md, node, "compatible", compatible,
	    sizeof(compatible));
	md_add_prop_val(md, node, "cfg-handle", 0x200);

	return node;
}

struct md_node *
guest_add_domain_services(struct guest *guest)
{
	struct md *md = guest->md;
	struct md_node *parent;
	struct md_node *node;

	parent = md_find_node(md, "root");
	assert(parent);

	node = md_add_node(md, "domain-services");
	md_link_node(md, parent, node);

	return node;
}

struct md_node *
guest_add_domain_services_port(struct guest *guest, uint64_t id)
{
	struct md *md = guest->md;
	struct md_node *parent;
	struct md_node *node;
	struct md_node *child;

	parent = md_find_node(md, "domain-services");
	if (parent == NULL)
		parent = guest_add_domain_services(guest);

	node = md_add_node(md, "domain-services-port");
	md_link_node(md, parent, node);
	md_add_prop_val(md, node, "id", id);

	child = guest_add_endpoint(guest,
	    guest->domain_services.client_endpoint->channel);
	md_link_node(md, node, child);

	return node;
}

void
guest_add_devalias(struct guest *guest, const char *name, const char *path)
{
	struct md *md = guest->md;
	struct md_node *parent;
	struct md_node *node;

	node = md_find_node(md, "devalias");
	if (node == NULL) {
		parent = md_find_node(md, "openboot");
		assert(parent);

		node = md_add_node(md, "devalias");
		md_link_node(md, parent, node);
	}

	md_add_prop_str(md, node, name, path);
}

void
guest_set_domaining_enabled(struct guest *guest)
{
	struct md *md = guest->md;
	struct md_node *node;

	node = md_find_node(md, "platform");
	assert(node);

	md_set_prop_val(md, node, "domaining-enabled", 0x1);
}

void
guest_set_mac_address(struct guest *guest)
{
	struct md *md = guest->md;
	struct md_node *node;
	uint64_t mac_address;
	uint64_t hostid;

	node = md_find_node(md, "platform");
	assert(node);

	mac_address = 0x00144ff80000 + (arc4random() & 0x3ffff);
	md_set_prop_val(md, node, "mac-address", mac_address);

	hostid = 0x84000000 | (mac_address & 0x00ffffff);
	md_set_prop_val(md, node, "hostid", hostid);
}

struct md_node *
guest_find_vc(struct guest *guest)
{
	struct md *md = guest->md;
	struct md_node *node, *node2;
	struct md_node *vc = NULL;
	struct md_prop *prop;
	const char *name;

	node = md_find_node(md, "channel-devices");
	assert(node != NULL);

	TAILQ_FOREACH(prop, &node->prop_list, link) {
		if (prop->tag == MD_PROP_ARC &&
		    strcmp(prop->name->str, "fwd") == 0) {
			node2 = prop->d.arc.node;
			if (!md_get_prop_str(md, node2, "name", &name))
				continue;
			if (strcmp(name, "virtual-channel") == 0)
				vc = node2;
		}
	}

	return vc;
}

struct md_node *
guest_add_vc_port(struct guest *guest, struct md_node *vc,
    const char *domain, uint64_t id, uint64_t channel)
{
	struct md *md = guest->md;
	struct md_node *node;
	struct md_node *child;
	char *str;

	if (vc == NULL)
		vc = guest_find_vc(guest);
	assert(vc);

	node = md_add_node(md, "virtual-device-port");
	md_link_node(md, vc, node);
	md_add_prop_str(md, node, "name", "vldc-port");
	md_add_prop_val(md, node, "id", id);
	xasprintf(&str, "ldom-%s", domain);
	md_add_prop_str(md, node, "vldc-svc-name", str);
	free(str);

	child = guest_add_endpoint(guest, channel);
	md_link_node(md, node, child);

	return node;
}

struct guest *
guest_create(const char *name)
{
	struct guest *guest;
	struct guest *primary;
	struct md_node *node;

	primary = guest_lookup("primary");

	guest = hvmd_add_guest(name);
	guest->md = md_copy(protomd);

	md_find_delete_node(guest->md, "dimm_configuration");
	md_find_delete_node(guest->md, "platform_services");
	md_find_delete_node(guest->md, "phys_io");
	md_collect_garbage(guest->md);

	guest_set_domaining_enabled(guest);
	guest_set_mac_address(guest);
	guest_add_channel_devices(guest);
	guest_add_domain_services_port(guest, 0);
	guest_add_console_device(guest);
	guest_add_devalias(guest, "virtual-console",
	    "/virtual-devices/console@@1");

	guest_add_vcc_port(primary, NULL, guest->name, guest->gid - 1,
	    guest->console->server_endpoint->channel);

	guest_add_vc_port(primary, NULL, guest->name, guest->gid + 2,
	    guest->domain_services.server_endpoint->channel);

	node = md_find_node(guest->md, "root");
	md_add_prop_val(guest->md, node, "reset-reason", 0);

	return guest;
}

struct guest *
guest_lookup(const char *name)
{
	uint64_t resource_id;

	for (resource_id = 0; resource_id < max_guests; resource_id++) {
		if (guests[resource_id] &&
		    strcmp(guests[resource_id]->name, name) == 0)
			return guests[resource_id];
	}

	return NULL;
}

void
guest_delete_virtual_device_port(struct guest *guest, struct md_node *port)
{
	struct md *md = guest->md;
	struct md_node *node;
	struct md_prop *prop;

	TAILQ_FOREACH(node, &md->node_list, link) {
		if (strcmp(node->name->str, "virtual-device-port") != 0)
			continue;
		TAILQ_FOREACH(prop, &node->prop_list, link) {
			if (prop->tag == MD_PROP_ARC &&
			    prop->d.arc.node == port) {
				md_delete_node(md, node);
				return;
			}
		}
	}
}

void
guest_delete_endpoint(struct guest *guest, struct ldc_endpoint *endpoint)
{
	struct md *md = guest->md;
	struct md_node *node, *node2;
	struct md_prop *prop;
	uint64_t id, resource_id;

	node = md_find_node(md, "channel-endpoints");
	TAILQ_FOREACH(prop, &node->prop_list, link) {
		if (prop->tag == MD_PROP_ARC &&
		    strcmp(prop->name->str, "fwd") == 0) {
			node2 = prop->d.arc.node;
			if (!md_get_prop_val(hvmd, node2, "id", &id))
				continue;
			if (id == endpoint->channel) {
				guest_delete_virtual_device_port(guest, node2);
				md_delete_node(md, node2);
				break;
			}
		}
	}

	TAILQ_REMOVE(&guest->endpoint_list, endpoint, link);
	ldc_endpoints[endpoint->resource_id] = NULL;

	/* Delete peer as well. */
	for (resource_id = 0; resource_id < max_guest_ldcs; resource_id++) {
		struct ldc_endpoint *peer = ldc_endpoints[resource_id];

		if (peer && peer->target_type == LDC_GUEST &&
		    peer->target_channel == endpoint->channel &&
		    peer->channel == endpoint->target_channel &&
		    peer->target_guest == guest->gid)
			guest_delete_endpoint(peer->guest, peer);
	}

	free(endpoint);
}

void
guest_delete(struct guest *guest)
{
	struct cpu *cpu, *cpu2;
	struct mblock *mblock, *mblock2;
	struct ldc_endpoint *endpoint, *endpoint2;

	consoles[guest->console->resource_id] = NULL;
	free(guest->console);

	TAILQ_FOREACH_SAFE(cpu, &guest->cpu_list, link, cpu2) {
		TAILQ_REMOVE(&guest->cpu_list, cpu, link);
		cpus[cpu->resource_id] = NULL;
		pri_free_cpu(cpu);
	}

	TAILQ_FOREACH_SAFE(mblock, &guest->mblock_list, link, mblock2) {
		TAILQ_REMOVE(&guest->mblock_list, mblock, link);
		mblocks[mblock->resource_id] = NULL;
		free(mblock);
	}

	TAILQ_FOREACH_SAFE(endpoint, &guest->endpoint_list, link, endpoint2)
		guest_delete_endpoint(guest, endpoint);

	hvmd_free_frag(guest->mdpa);

	guests[guest->resource_id] = NULL;
	free(guest);
}

void
guest_delete_cpu(struct guest *guest, uint64_t vid)
{
	struct cpu *cpu;

	TAILQ_FOREACH(cpu, &guest->cpu_list, link) {
		if (cpu->vid == vid) {
			TAILQ_REMOVE(&guest->cpu_list, cpu, link);
			cpus[cpu->resource_id] = NULL;
			pri_free_cpu(cpu);
			return;
		}
	}
}

void
guest_add_cpu(struct guest *guest)
{
	struct cpu *cpu;

	cpu = pri_alloc_cpu(-1);

	if (cpu->resource_id == -1) {
		uint64_t resource_id;

		for (resource_id = 0; resource_id < max_cpus; resource_id++)
			if (cpus[resource_id] == NULL)
				break;
		assert(resource_id < max_cpus);
		cpu->resource_id = resource_id;
	}
	cpus[cpu->resource_id] = cpu;

	cpu->vid = guest->cpu_vid++;
	cpu->gid = guest->gid;
	cpu->partid = 1;

	TAILQ_INSERT_TAIL(&guest->cpu_list, cpu, link);
	cpu->guest = guest;
}

void
guest_delete_memory(struct guest *guest)
{
	struct mblock *mblock, *tmp;

	TAILQ_FOREACH_SAFE(mblock, &guest->mblock_list, link, tmp) {
		if (mblock->resource_id != -1)
			mblocks[mblock->resource_id] = NULL;
		TAILQ_REMOVE(&guest->mblock_list, mblock, link);
		free(mblock);
	}
}

void
guest_add_memory(struct guest *guest, uint64_t base, uint64_t size)
{
	struct mblock *mblock;
	uint64_t resource_id;

	mblock = pri_alloc_memory(base, size);
	if (mblock == NULL)
		errx(1, "unable to allocate guest memory");
	for (resource_id = 0; resource_id < max_cpus; resource_id++)
		if (mblocks[resource_id] == NULL)
			break;
	assert(resource_id < max_mblocks);
	mblock->resource_id = resource_id;
	mblocks[resource_id] = mblock;

	mblock->realbase = mblock->membase & (max_page_size - 1);
	if (mblock->realbase == 0)
		mblock->realbase = max_page_size;

	TAILQ_INSERT_TAIL(&guest->mblock_list, mblock, link);
	mblock->guest = guest;
}

void
guest_add_vdisk(struct guest *guest, uint64_t id, const char *path)
{
	struct guest *primary;
	struct ldc_channel *lc;
	char *devalias;
	char *devpath;

	primary = guest_lookup("primary");

	lc = hvmd_add_vio(guest);
	guest_add_vds_port(primary, NULL, path, id,
	    lc->server_endpoint->channel);
	guest_add_vdc_port(guest, NULL, id, 0, lc->client_endpoint->channel);

	xasprintf(&devalias, "disk%d", id);
	xasprintf(&devpath,
	    "/virtual-devices@@100/channel-devices@@200/disk@@%d", id);
	if (id == 0)
		guest_add_devalias(guest, "disk", devpath);
	guest_add_devalias(guest, devalias, devpath);
	free(devalias);
	free(devpath);
}

void
guest_add_vnetwork(struct guest *guest, uint64_t id, uint64_t mac_addr,
    uint64_t mtu)
{
	struct guest *primary;
	struct ldc_channel *lc;
	char *devalias;
	char *devpath;
	struct md_node *node;
	uint64_t remote_mac_addr = -1;

	primary = guest_lookup("primary");

	lc = hvmd_add_vio(guest);
	guest_add_vsw_port(primary, NULL, id, lc->server_endpoint->channel);
	node = guest_find_vsw(primary);
	md_get_prop_val(primary->md, node, "local-mac-address", &remote_mac_addr);
	guest_add_vnet_port(guest, NULL, mac_addr, remote_mac_addr, mtu, id, 0,
	    lc->client_endpoint->channel);

	xasprintf(&devalias, "net%d", id);
	xasprintf(&devpath,
	    "/virtual-devices@@100/channel-devices@@200/network@@%d", id);
	if (id == 0)
		guest_add_devalias(guest, "net", devpath);
	guest_add_devalias(guest, devalias, devpath);
	free(devalias);
	free(devpath);
}

struct cpu *
guest_find_cpu(struct guest *guest, uint64_t pid)
{
	struct cpu *cpu;

	TAILQ_FOREACH(cpu, &guest->cpu_list, link)
		if (cpu->pid == pid)
			return cpu;

	return NULL;
}

void
guest_finalize(struct guest *guest)
{
	struct md *md = guest->md;
	struct md_node *node, *node2;
	struct md_prop *prop, *prop2;
	struct mblock *mblock;
	struct md_node *parent;
	struct md_node *child;
	struct cpu *cpu;
	uint64_t pid;
	uint64_t id;
	const char *name;
	char *path;

	node = md_find_node(md, "cpus");
	TAILQ_FOREACH_SAFE(prop, &node->prop_list, link, prop2) {
		if (prop->tag == MD_PROP_ARC &&
		    strcmp(prop->name->str, "fwd") == 0) {
			node2 = prop->d.arc.node;
			if (!md_get_prop_val(md, node2, "pid", &pid))
				if (!md_get_prop_val(md, node2, "id", &pid))
					continue;
			cpu = guest_find_cpu(guest, pid);
			if (cpu == NULL) {
				md_delete_node(md, node2);
				continue;
			}
			md_set_prop_val(md, node2, "id", cpu->vid);
		}
	}

	/*
	 * We don't support crypto units yet, so delete any "ncp" and
	 * "n2cp" nodes.  If we don't, Solaris whines about not being
	 * able to configure crypto work queues.
	 */
	node = md_find_node(md, "virtual-devices");
	TAILQ_FOREACH_SAFE(prop, &node->prop_list, link, prop2) {
		if (prop->tag == MD_PROP_ARC &&
		    strcmp(prop->name->str, "fwd") == 0) {
			node2 = prop->d.arc.node;
			if (!md_get_prop_str(md, node2, "name", &name))
				continue;
			if (strcmp(name, "ncp") == 0)
				md_delete_node(md, node2);
			if (strcmp(name, "n2cp") == 0)
				md_delete_node(md, node2);
		}
	}

	md_collect_garbage(md);

	node = md_find_node(md, "memory");
	md_get_prop_val(md, node, "memory-generation-id#", &id);
	md_delete_node(md, node);
	md_collect_garbage(md);

	parent = md_find_node(md, "root");
	assert(parent);

	node = md_add_node(md, "memory");
	md_add_prop_val(md, node, "memory-generation-id#", id);
	md_link_node(md, parent, node);

	TAILQ_FOREACH(mblock, &guest->mblock_list, link) {
		child = md_add_node(md, "mblock");
		md_add_prop_val(md, child, "base", mblock->realbase);
		md_add_prop_val(md, child, "size", mblock->memsize);
		md_link_node(md, node, child);
	}

	xasprintf(&path, "%s.md", guest->name);
	md_write(guest->md, path);
	free(path);
}

struct guest *
primary_init(void)
{
	struct guest *guest;

	guest = guest_lookup("primary");
	assert(guest);

	guest_set_domaining_enabled(guest);

	return guest;
}

void
build_config(const char *filename)
{
	struct guest *primary;
	struct guest *guest;
	struct ldc_endpoint *endpoint;
	uint64_t resource_id;
	int i;

	struct ldom_config conf;
	struct domain *domain;
	struct vdisk *vdisk;
	struct vnet *vnet;
	uint64_t num_cpus, primary_num_cpus;
	uint64_t memory, primary_memory;

	SIMPLEQ_INIT(&conf.domain_list);
	if (parse_config(filename, &conf) < 0)
		exit(1);

	pri = md_read("pri");
	if (pri == NULL)
		err(1, "unable to get PRI");
	hvmd = md_read("hv.md");
	if (hvmd == NULL)
		err(1, "unable to get Hypervisor MD");

	pri_init(pri);
	pri_alloc_memory(hv_membase, hv_memsize);

	num_cpus = primary_num_cpus = 0;
	memory = primary_memory = 0;
	SIMPLEQ_FOREACH(domain, &conf.domain_list, entry) {
		if (strcmp(domain->name, "primary") == 0) {
			primary_num_cpus = domain->vcpu;
			primary_memory = domain->memory;
		}
		num_cpus += domain->vcpu;
		memory += domain->memory;
	}
	if (primary_num_cpus == 0 && total_cpus > num_cpus)
		primary_num_cpus = total_cpus - num_cpus;
	if (primary_memory == 0 && total_memory > memory)
		primary_memory = total_memory - memory;
	if (num_cpus > total_cpus || primary_num_cpus == 0)
		errx(1, "not enough VCPU resources available");
	if (memory > total_memory || primary_memory == 0)
		errx(1, "not enough memory available");

	hvmd_init(hvmd);
	primary = primary_init();

	for (resource_id = 0; resource_id <max_guests; resource_id++)
		if (guests[resource_id] &&
		    strcmp(guests[resource_id]->name, "primary") != 0)
			guest_delete(guests[resource_id]);

	primary->endpoint_id = 0;
	TAILQ_FOREACH(endpoint, &primary->endpoint_list, link) {
		if (endpoint->channel >= primary->endpoint_id)
			primary->endpoint_id = endpoint->channel + 1;
	}

	for (i = primary_num_cpus; i < max_cpus; i++)
		guest_delete_cpu(primary, i);
	guest_delete_memory(primary);
	guest_add_memory(primary, -1, primary_memory);

	SIMPLEQ_FOREACH(domain, &conf.domain_list, entry) {
		if (strcmp(domain->name, "primary") == 0)
			continue;
		guest = guest_create(domain->name);
		for (i = 0; i < domain->vcpu; i++)
			guest_add_cpu(guest);
		guest_add_memory(guest, -1, domain->memory);
		i = 0;
		SIMPLEQ_FOREACH(vdisk, &domain->vdisk_list, entry)
			guest_add_vdisk(guest, i++, vdisk->path);
		i = 0;
		SIMPLEQ_FOREACH(vnet, &domain->vnet_list, entry)
			guest_add_vnetwork(guest, i++, vnet->mac_addr,
			    vnet->mtu);

		guest_finalize(guest);
	}

	guest_finalize(primary);
	hvmd_finalize();
}
@


1.21
log
@Use TAILQ_FOREACH_SAFE when we might delete entries for the list.
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.20 2014/09/13 16:06:37 doug Exp $	*/
d872 1
a872 1
	
d2309 1
a2309 1
	memory = primary_memory = 0; 
@


1.20
log
@Replace all queue *_END macro calls except CIRCLEQ_END with NULL.

CIRCLEQ_* is deprecated and not called in the tree.  The other queue types
have *_END macros which were added for symmetry with CIRCLEQ_END.  They are
defined as NULL.  There's no reason to keep the other *_END macro calls.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.19 2013/05/08 00:15:03 gsoares Exp $	*/
d2193 1
a2193 1
	struct md_prop *prop;
d2204 1
a2204 1
	TAILQ_FOREACH(prop, &node->prop_list, link) {
d2226 1
a2226 1
	TAILQ_FOREACH(prop, &node->prop_list, link) {
@


1.19
log
@tweak hvmd_init_guest() to check if everything was OK in md_read(),
otherwise print out an error string and exit.

OK jasper@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.18 2013/04/03 15:38:48 kettenis Exp $	*/
d436 1
a436 1
	if (frag == TAILQ_END(&free_frags))
@


1.18
log
@Make it possible to explicitly specify the number of vcpus and the amount
of memory for the primary domain.  As a bonus this prevents people from
shooting themselves in the foot by creating two domains names "primary".
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.17 2013/04/01 17:51:56 kettenis Exp $	*/
d720 4
@


1.17
log
@Some firmware revisions on UltraSPARC T2 machines apparently insist on having
"rngs" and "rng" nodes in the Hypervisor machine description.
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.16 2013/03/04 11:54:13 otto Exp $	*/
d2287 2
a2288 2
	uint64_t num_cpus;
	uint64_t memory;
d2304 2
a2305 2
	num_cpus = 0;
	memory = 0; 
d2307 4
d2314 5
a2318 1
	if (num_cpus >= total_cpus)
d2320 1
a2320 1
	if (memory >= total_memory)
d2337 1
a2337 1
	for (i = total_cpus - num_cpus; i < max_cpus; i++)
d2340 1
a2340 1
	guest_add_memory(primary, -1, total_memory - memory);
d2343 2
@


1.16
log
@- check parser's return value and exit if parsing failed
- a duplicate domain name is a syntax error
tweaked diff from @@jasper; ok kettenis@@ jasper@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.15 2013/02/26 23:03:39 kettenis Exp $	*/
d63 2
d770 3
d860 2
d868 16
a883 2
	node = md_add_node(md, "cwqs");
	md_link_node(md, parent, node);
@


1.15
log
@Some firmware revisions provide a factory-default configuration that contains
duplication arcs in the hvmd.  Add a workaround for this problem.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.14 2012/12/08 18:45:26 kettenis Exp $	*/
d2270 2
a2271 1
	parse_config(filename, &conf);
@


1.14
log
@Fix previous.
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.13 2012/12/08 15:11:40 kettenis Exp $	*/
d595 8
a602 1
	if (ldc_endpoints[resource_id])
d604 1
@


1.13
log
@Add a few missing properties to vnet-port devices to make Linux happy.
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.12 2012/12/01 14:35:41 kettenis Exp $	*/
d2122 1
a2122 1
	uint64_t remote_mac_addr;
d2129 1
a2129 1
	md_get_prop_val(primary->md, node, "local-mac-addr", &remote_mac_addr);
@


1.12
log
@Add support for older firmware on UltraSPARC T1 machines.
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.11 2012/12/01 10:39:38 kettenis Exp $	*/
d1561 1
d1567 4
d1681 2
a1682 2
    uint64_t mac_addr, uint64_t mtu, uint64_t cfghandle, uint64_t id,
    uint64_t channel)
d1695 3
d2121 2
d2128 3
a2130 1
	guest_add_vnet_port(guest, NULL, mac_addr, mtu, id, 0,
@


1.11
log
@Make it possible to share cores between domains.
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.10 2012/11/26 21:01:43 kettenis Exp $	*/
d80 4
d552 4
d722 4
d1108 1
a1108 1
	if (stick_frequency != 0)
d1110 15
d2063 2
@


1.10
log
@We don't really need a "rngs" node in the Hypervisor MD.
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.9 2012/11/26 20:37:20 kettenis Exp $	*/
d40 1
a40 4
struct pri_cpu {
	uint64_t pid;
	TAILQ_ENTRY(pri_cpu) link;
};
d42 3
a44 3
struct pri_core {
	TAILQ_HEAD(pri_cpu_head, pri_cpu) cpu_list;
	TAILQ_ENTRY(pri_core) link;
d47 1
a47 1
TAILQ_HEAD(pri_core_head, pri_core) pri_core_list;
d93 12
a104 1
struct pri_core *pri_cores;
d107 1
a107 1
pri_add_core(struct md *md, struct md_node *node, struct pri_core *core)
a108 1
	struct pri_cpu *cpu;
d111 2
d118 3
a120 6
			if (strcmp(node2->name->str, "cpu") == 0) {
				cpu = xmalloc(sizeof(*cpu));
				md_get_prop_val(md, node2, "pid", &cpu->pid);
				TAILQ_INSERT_TAIL(&core->cpu_list, cpu, link);
			} else {
				pri_add_core(md, node2, core);
d122 9
d136 11
a148 1
	struct pri_core *core;
d153 1
a153 1
	TAILQ_INIT(&pri_core_list);
d159 1
a159 3
			core = xmalloc(sizeof(*core));
			TAILQ_INIT(&core->cpu_list);
			pri_add_core(md, node, core);
a368 1
#if 0
a369 1
#endif
d784 13
@


1.9
log
@Fix generation of "hvmd_mblock" node.  Only add the "stick-frequency"
property to the root node if the original Hypervisor MD had one to start with.
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.8 2012/11/26 20:08:15 kettenis Exp $	*/
a807 2
	md_link_node(md, parent, node);
	node = md_add_node(md, "rngs");
@


1.8
log
@Regeerate Hypervisor MD from scratch instead of modifying the existing one.
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.7 2012/11/25 21:45:37 kettenis Exp $	*/
d1064 2
a1065 1
	md_add_prop_val(md, node, "stick-frequency", stick_frequency);
d1088 2
a1089 2
		md_add_prop_val(md, node, "base", mblock->membase);
		md_add_prop_val(md, node, "size", mblock->memsize);
@


1.7
log
@More changes to make this work on UltraSPARC T2 systems.  Now there's
enough functionality to create a configuration for a t5120 running System
Firmware 7.1.x.
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.6 2012/11/25 18:23:02 kettenis Exp $	*/
d60 2
d70 1
d74 2
d81 3
d162 2
a163 3
	if (!md_get_prop_val(md, node,
	    "mmu-page-size-list", &mmu_page_size_list))
		mmu_page_size_list = 0x9;
d327 2
d368 1
d375 1
d380 1
d382 6
d443 1
a443 1
	mblock = xmalloc(sizeof(*mblock));
d520 35
d570 5
d606 1
d612 4
d643 14
d690 4
d696 1
d709 1
d727 7
a783 3
	md_find_delete_node(md, "cpus");
	md_collect_garbage(md);

a801 5
	md_find_delete_node(md, "maus");
	md_find_delete_node(md, "cwqs");
	md_find_delete_node(md, "rngs");
	md_collect_garbage(md);

d814 42
a879 3
	md_find_delete_node(md, "memory");
	md_collect_garbage(md);

d886 1
a886 1
	for (resource_id = 0; resource_id < max_cpus; resource_id++) {
a928 3
	md_find_delete_node(md, "ldc_endpoints");
	md_collect_garbage(md);

a971 3
	md_find_delete_node(md, "consoles");
	md_collect_garbage(md);

d987 2
a988 3
	struct md_node *node = guest->hv_node;
	struct md_node *node2;
	struct md_prop *prop, *tmp;
d990 1
d994 27
a1020 12
	TAILQ_FOREACH_SAFE(prop, &node->prop_list, link, tmp) {
		if (prop->tag == MD_PROP_ARC &&
		    strcmp(prop->name->str, "fwd") == 0) {
			node2 = prop->d.arc.node;
			if (strcmp(node2->name->str, "console") == 0 ||
			    strcmp(node2->name->str, "cpu") == 0 ||
			    strcmp(node2->name->str, "mblock") == 0 ||
			    strcmp(node2->name->str, "ldc_endpoint") == 0)
				md_delete_prop(md, node, prop);
		}
	}
	md_collect_garbage(md);
d1026 2
d1037 2
d1041 6
d1054 1
a1054 1
hvmd_finalize(struct md *md)
d1056 36
d1094 1
d1100 1
a1100 1
	md_write(hvmd, "hv.md");
d1104 1
a1104 1
hvmd_add_endpoint(struct md *md, struct guest *guest)
d1130 1
a1130 1
hvmd_add_console(struct md *md, struct guest *guest)
d1151 1
a1151 1
	console->client_endpoint = hvmd_add_endpoint(md, guest);
d1160 1
a1160 1
	console->server_endpoint = hvmd_add_endpoint(md, primary);
d1175 1
a1175 1
hvmd_add_domain_services(struct md *md, struct guest *guest)
d1185 1
a1185 1
	ds->client_endpoint = hvmd_add_endpoint(md, guest);
d1193 1
a1193 1
	ds->server_endpoint = hvmd_add_endpoint(md, primary);
d1203 1
a1203 1
hvmd_add_vio(struct md *md, struct guest *guest)
d1213 1
a1213 1
	lc->client_endpoint = hvmd_add_endpoint(md, guest);
d1221 1
a1221 1
	lc->server_endpoint = hvmd_add_endpoint(md, primary);
d1233 1
a1233 1
hvmd_add_guest(struct md *md, const char *name)
a1235 2
	struct md_node *parent;
	struct md_node *node;
d1245 1
d1255 2
a1256 28
	parent = md_find_node(md, "guests");
	assert(parent);

	node = md_add_node(md, "guest");
	md_link_node(md, parent, node);
	md_add_prop_str(md, node, "name", name);
	md_add_prop_val(md, node, "gid", guest->gid);
	md_add_prop_val(md, node, "pid", guest->pid);
	md_add_prop_val(md, node, "resource_id", resource_id);
	md_add_prop_val(md, node, "tod-offset", 0);
	md_add_prop_val(md, node, "rombase", rombase);
	md_add_prop_val(md, node, "romsize", romsize);
	md_add_prop_val(md, node, "perfctraccess", 0);
	md_add_prop_val(md, node, "reset-reason", 0);
	md_add_prop_val(md, node, "diagpriv", 0);
	md_add_prop_val(md, node, "mdpa", guest->mdpa);
	guest->hv_node = node;

	node = md_add_node(md, "virtual_devices");
	md_link_node(md, guest->hv_node, node);
	md_add_prop_val(md, node, "cfghandle", 0x100);

	node = md_add_node(md, "channel_devices");
	md_link_node(md, guest->hv_node, node);
	md_add_prop_val(md, node, "cfghandle", 0x200);

	hvmd_add_console(md, guest);
	hvmd_add_domain_services(md, guest);
d1809 1
a1809 1
	guest = hvmd_add_guest(hvmd, name);
a1916 3
	struct md_node *node, *node2;
	struct md_prop *prop;
	const char *name;
a1937 13
	node = md_find_node(hvmd, "guests");
	TAILQ_FOREACH(prop, &node->prop_list, link) {
		if (prop->tag == MD_PROP_ARC &&
		    strcmp(prop->name->str, "fwd") == 0) {
			node2 = prop->d.arc.node;
			if (!md_get_prop_str(hvmd, node2, "name", &name))
				continue;
			if (strcmp(name, guest->name) == 0) {
				md_delete_node(hvmd, node2);
				break;
			}
		}
	}
d2028 1
a2028 1
	lc = hvmd_add_vio(hvmd, guest);
d2054 1
a2054 1
	lc = hvmd_add_vio(hvmd, guest);
d2247 1
a2247 1
	hvmd_finalize(hvmd);
@


1.6
log
@Use "id" property as physical ID for CPUs on UltraSPARC T2 and later.
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.5 2012/11/25 16:18:04 kettenis Exp $	*/
d359 1
d622 8
d716 2
d725 4
d1968 2
a1969 1
				continue;
@


1.5
log
@Properly remove virtual device ports if we remove the associated channels.
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.4 2012/11/25 14:01:58 kettenis Exp $	*/
d141 6
a146 1
	md_get_prop_val(md, node, "pid", &cpu->pid);
@


1.4
log
@Add support for building a new configuration based on a configuration that
already has guest domains configured.
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.3 2012/11/24 22:54:02 kettenis Exp $	*/
d1682 60
d1766 2
a1767 25
	TAILQ_FOREACH_SAFE(endpoint, &guest->endpoint_list, link, endpoint2) {
		uint64_t resource_id;

		TAILQ_REMOVE(&guest->endpoint_list, endpoint, link);
		ldc_endpoints[endpoint->resource_id] = NULL;

		/* Delete peer as well. */
		for (resource_id = 0;
		     resource_id < max_guest_ldcs; resource_id++) {
			struct ldc_endpoint *peer = ldc_endpoints[resource_id];

			if (peer && peer->target_type == LDC_GUEST &&
			    peer->target_channel == endpoint->channel &&
			    peer->channel == endpoint->target_channel &&
			    peer->target_guest == guest->gid) {
				TAILQ_REMOVE(&peer->guest->endpoint_list,
				    peer, link);
				ldc_endpoints[peer->resource_id] = NULL;
				free(peer);
				break;
			}
		}

		free(endpoint);
	}
a2006 1
	struct md_node *vcc;
a2011 1
	vcc = guest_add_vcc(guest);
@


1.3
log
@Delete "ncp" and "n2cp" virtual devices.  Makes Solaris stop whining about
not being able to configure crypto work queues.
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.2 2012/11/24 17:04:03 kettenis Exp $	*/
d396 10
d1682 70
d1986 2
d2023 11
@


1.2
log
@Get rid of some hard-coded constants.  Improve memory allocation code.
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.1 2012/11/24 11:50:45 kettenis Exp $	*/
d686 16
a885 12
	struct md_node *parent;
	struct md_node *node;

	md_find_delete_node(md, "maus");
	md_collect_garbage(md);

	parent = md_find_node(md, "root");
	assert(parent);

	node = md_add_node(md, "maus");
	md_link_node(md, parent, node);

d887 1
d1822 1
d1840 20
@


1.1
log
@Add code to create new system configuration.  Work in progress, but there's
enough functionality to create a configuration for a t1k or t2k running
System Firmware 6.7.x.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d74 2
d84 3
d137 2
d140 1
a140 1
	cpu = xmalloc(sizeof(*cpu));
d147 14
d191 56
d325 7
d337 16
d363 1
d400 2
d416 10
a447 16
hvmd_fixup_guest(struct md *md, struct md_node *guest, struct md_node *node)
{
	struct md_prop *prop;

	TAILQ_FOREACH(prop, &guest->prop_list, link) {
		if (prop->tag == MD_PROP_ARC &&
		    strcmp(prop->name->str, "fwd") == 0) {
			if (prop->d.arc.node == node)
				return;
		}
	}

	md_add_prop_arc(md, guest, "fwd", node);
}

void
d604 1
d887 2
d1708 1
a1708 1
guest_delete_memory(struct guest *guest, uint64_t base, uint64_t size)
d1710 1
a1710 1
	struct mblock *mblock;
d1712 5
a1716 5
	TAILQ_FOREACH(mblock, &guest->mblock_list, link) {
		if (base >= mblock->membase &&
		    base < mblock->membase + mblock->memsize) {
			mblock->memsize = base - mblock->membase;
		}
d1726 1
a1726 1
	mblock = xzalloc(sizeof(*mblock));
d1734 1
a1734 3
	mblock->membase = base;
	mblock->memsize = size;
	mblock->realbase = base & 0x7fffffff;
d1736 1
a1736 1
		mblock->realbase = 0x80000000;
a1854 3
	if (strcmp(guest->name, "primary") == 0)
		return;

d1886 2
a1887 1
	uint64_t membase = 0x40000000;
d1900 13
d1914 1
d1916 1
a1916 2
	primary = primary_init();
	for (i = 8; i < max_cpus; i++)
d1918 3
a1920 1
	guest_delete_memory(primary, 0x40000000,  0x1c0000000);
d1925 1
a1925 2
		guest_add_memory(guest, membase, domain->memory);
		membase += domain->memory;
d1937 1
a1938 4
	guest_finalize(primary);

	md_write(hvmd, "hv.md");
	md_write(primary->md, "primary.md");
@

