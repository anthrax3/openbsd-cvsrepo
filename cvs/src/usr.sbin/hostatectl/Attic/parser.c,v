head	1.5;
access;
symbols;
locks; strict;
comment	@ * @;


1.5
date	2007.01.09.00.44.36;	author deraadt;	state dead;
branches;
next	1.4;

1.4
date	2006.12.16.18.50.33;	author reyk;	state Exp;
branches;
next	1.3;

1.3
date	2006.12.16.17.53.03;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2006.12.16.12.47.18;	author reyk;	state Exp;
branches;
next	1.1;

1.1
date	2006.12.16.11.45.07;	author reyk;	state Exp;
branches;
next	;


desc
@@


1.5
log
@rename to hoststate{d,ctl}, using a repository copy
as discussed with reyk
@
text
@/*	$OpenBSD: parser.c,v 1.4 2006/12/16 18:50:33 reyk Exp $	*/

/*
 * Copyright (c) 2006 Pierre-Yves Ritschard <pyr@@spootnik.org>
 * Copyright (c) 2004 Esben Norby <norby@@openbsd.org>
 * Copyright (c) 2003, 2004 Henning Brauer <henning@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/socket.h>
#include <sys/queue.h>
#include <netinet/in.h>
#include <net/if.h>
#include <arpa/inet.h>
#include <err.h>
#include <errno.h>
#include <limits.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <event.h>

#include "hostated.h"

#include "parser.h"

enum token_type {
	NOTOKEN,
	ENDTOKEN,
	HOSTID,
	TABLEID,
	SERVICEID,
	KEYWORD
};

struct token {
	enum token_type		 type;
	const char		*keyword;
	int			 value;
	const struct token	*next;
};

static const struct token t_main[];
static const struct token t_service[];
static const struct token t_table[];
static const struct token t_host[];
static const struct token t_service_id[];
static const struct token t_table_id[];
static const struct token t_host_id[];

static const struct token t_main[] = {
	{KEYWORD,	"show",		SHOW_SUM,	NULL},
	{KEYWORD,	"stop",		SHUTDOWN,	NULL},
	{KEYWORD,	"service",	NULL,		t_service},
	{KEYWORD,	"table",	NULL,		t_table},
	{KEYWORD,	"host",		NULL,		t_host},
	{ENDTOKEN,	"",		NONE,		NULL}
};

static const struct token t_service[] = {
	{NOTOKEN,	"",		NONE,		NULL},
	{KEYWORD,	"disable",	SERV_DISABLE,	t_service_id},
	{KEYWORD,	"enable",	SERV_ENABLE,	t_service_id},
	{ENDTOKEN,	"",		NONE,		NULL}
};

static const struct token t_table[] = {
	{NOTOKEN,	"",		NONE,		NULL},
	{KEYWORD,	"disable",	TABLE_DISABLE,	t_table_id},
	{KEYWORD,	"enable",	TABLE_ENABLE,	t_table_id},
	{ENDTOKEN,	"",		NONE,		NULL}
};

static const struct token t_host[] = {
	{NOTOKEN,	"",		NONE,		NULL},
	{KEYWORD,	"disable",	HOST_DISABLE,	t_host_id},
	{KEYWORD,	"enable",	HOST_ENABLE,	t_host_id},
	{ENDTOKEN,	"",		NONE,		NULL}
};

static const struct token t_service_id[] = {
	{SERVICEID,	"",		NONE,		NULL},
	{ENDTOKEN,	"",		NONE,		NULL}
};

static const struct token t_table_id[] = {
	{TABLEID,	"",		NONE,		NULL},
	{ENDTOKEN,	"",		NONE,		NULL}
};

static const struct token t_host_id[] = {
	{HOSTID,	"",		NONE,		NULL},
	{ENDTOKEN,	"",		NONE,		NULL}
};

static struct parse_result	res;

struct parse_result *
parse(int argc, char *argv[])
{
	const struct token	*table = t_main;
	const struct token	*match;

	bzero(&res, sizeof(res));

	while (argc > 0) {
		if ((match = match_token(argv[0], table)) == NULL) {
			fprintf(stderr, "valid commands/args:\n");
			show_valid_args(table);
			return (NULL);
		}

		argc--;
		argv++;

		if (match->type == NOTOKEN || match->next == NULL)
			break;

		table = match->next;
	}

	if (argc > 0) {
		fprintf(stderr, "superfluous argument: %s\n", argv[0]);
		return (NULL);
	}

	return (&res);
}

const struct token *
match_token(const char *word, const struct token table[])
{
	u_int			 i, match;
	const struct token	*t = NULL;
	const char		*errstr;

	match = 0;

	for (i = 0; table[i].type != ENDTOKEN; i++) {
		switch (table[i].type) {
		case NOTOKEN:
			if (word == NULL || strlen(word) == 0) {
				match++;
				t = &table[i];
			}
			break;
		case KEYWORD:
			if (word != NULL && strncmp(word, table[i].keyword,
			    strlen(word)) == 0) {
				match++;
				t = &table[i];
				if (t->value)
					res.action = t->value;
			}
			break;
		case HOSTID:
			res.id.id = strtonum(word, 0, UINT_MAX, &errstr);
			if (errstr) {
				strlcpy(res.id.name, word, sizeof(res.id.name));
				res.id.id = EMPTY_ID;
			}
			t = &table[i];
			match++;
			break;
		case TABLEID:
			res.id.id = strtonum(word, 0, UINT_MAX, &errstr);
			if (errstr) {
				strlcpy(res.id.name, word, sizeof(res.id.name));
				res.id.id = EMPTY_ID;
			}
			t = &table[i];
			match++;
			break;
		case SERVICEID:
			res.id.id = strtonum(word, 0, UINT_MAX, &errstr);
			if (errstr) {
				strlcpy(res.id.name, word, sizeof(res.id.name));
				res.id.id = EMPTY_ID;
			}
			t = &table[i];
			match++;
			break;
		case ENDTOKEN:
			break;
		}
	}

	if (match != 1) {
		if (match > 1)
			fprintf(stderr, "ambiguous argument: %s\n", word);
		if (match < 1)
			fprintf(stderr, "unknown argument: %s\n", word);
		return (NULL);
	}

	return (t);
}

void
show_valid_args(const struct token table[])
{
	int	i;

	for (i = 0; table[i].type != ENDTOKEN; i++) {
		switch (table[i].type) {
		case NOTOKEN:
			fprintf(stderr, "  <cr>\n");
			break;
		case KEYWORD:
			fprintf(stderr, "  %s\n", table[i].keyword);
			break;
		case SERVICEID:
			fprintf(stderr, "  <serviceid>\n");
			break;
		case TABLEID:
			fprintf(stderr, "  <tableid>\n");
			break;
		case HOSTID:
			fprintf(stderr, "  <hostid>\n");
			break;
		case ENDTOKEN:
			break;
		}
	}
}
@


1.4
log
@- allow to use host/service/table names instead of Ids in hostatectl.
- minor change of the "hostatectl show" command output
- increase the max service and tag names (max pf tag name size is 64 now!)

thanks to pyr who found a bug in my initial diff
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.3 2006/12/16 17:53:03 deraadt Exp $	*/
@


1.3
log
@unused variable
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.2 2006/12/16 12:47:18 reyk Exp $	*/
d169 5
a173 3
			res.id = strtonum(word, 0, UINT_MAX, &errstr);
			if (errstr)
				errx(1, "host id %s is %s", word, errstr);
d178 5
a182 3
			res.id = strtonum(word, 0, UINT_MAX, &errstr);
			if (errstr)
				errx(1, "table id %s is %s", word, errstr);
d187 5
a191 3
			res.id = strtonum(word, 0, UINT_MAX, &errstr);
			if (errstr)
				errx(1, "service id %s is %s", word, errstr);
@


1.2
log
@knf, spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.1 2006/12/16 11:45:07 reyk Exp $	*/
a55 1
static const struct token t_show[];
@


1.1
log
@Import hostated, the host status daemon.  This daemon will monitor
remote hosts and dynamically alter pf(4) tables and redirection rules
for active server load balancing.  The daemon has been written by
Pierre-Yves Ritschard (pyr at spootnik.org) and was formerly known as
"slbd".

The daemon is fully functional but it still needs some work and
cleanup so we don't link it to the build yet.  Some TODOs are a
partial rewrite of the check_* routines (use libevent whenever we
can), improvement of the manpages, and general knf and cleanup.

ok deraadt@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d75 2
a76 2
	{KEYWORD,	"disable",	SERV_DISABLE, 	t_service_id},
	{KEYWORD,	"enable",	SERV_ENABLE, 	t_service_id},
d82 1
a82 1
	{KEYWORD,	"disable",	TABLE_DISABLE, 	t_table_id},
d89 1
a89 1
	{KEYWORD,	"disable",	HOST_DISABLE, 	t_host_id},
@

