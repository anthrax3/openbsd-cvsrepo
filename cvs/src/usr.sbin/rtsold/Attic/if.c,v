head	1.29;
access;
symbols
	OPENBSD_5_6:1.27.0.4
	OPENBSD_5_6_BASE:1.27
	OPENBSD_5_5:1.26.0.4
	OPENBSD_5_5_BASE:1.26
	OPENBSD_5_4:1.25.0.10
	OPENBSD_5_4_BASE:1.25
	OPENBSD_5_3:1.25.0.8
	OPENBSD_5_3_BASE:1.25
	OPENBSD_5_2:1.25.0.6
	OPENBSD_5_2_BASE:1.25
	OPENBSD_5_1_BASE:1.25
	OPENBSD_5_1:1.25.0.4
	OPENBSD_5_0:1.25.0.2
	OPENBSD_5_0_BASE:1.25
	OPENBSD_4_9:1.24.0.8
	OPENBSD_4_9_BASE:1.24
	OPENBSD_4_8:1.24.0.6
	OPENBSD_4_8_BASE:1.24
	OPENBSD_4_7:1.24.0.2
	OPENBSD_4_7_BASE:1.24
	OPENBSD_4_6:1.24.0.4
	OPENBSD_4_6_BASE:1.24
	OPENBSD_4_5:1.22.0.2
	OPENBSD_4_5_BASE:1.22
	OPENBSD_4_4:1.20.0.2
	OPENBSD_4_4_BASE:1.20
	OPENBSD_4_3:1.19.0.8
	OPENBSD_4_3_BASE:1.19
	OPENBSD_4_2:1.19.0.6
	OPENBSD_4_2_BASE:1.19
	OPENBSD_4_1:1.19.0.4
	OPENBSD_4_1_BASE:1.19
	OPENBSD_4_0:1.19.0.2
	OPENBSD_4_0_BASE:1.19
	OPENBSD_3_9:1.18.0.10
	OPENBSD_3_9_BASE:1.18
	OPENBSD_3_8:1.18.0.8
	OPENBSD_3_8_BASE:1.18
	OPENBSD_3_7:1.18.0.6
	OPENBSD_3_7_BASE:1.18
	OPENBSD_3_6:1.18.0.4
	OPENBSD_3_6_BASE:1.18
	OPENBSD_3_5:1.18.0.2
	OPENBSD_3_5_BASE:1.18
	OPENBSD_3_4:1.16.0.2
	OPENBSD_3_4_BASE:1.16
	OPENBSD_3_3:1.14.0.2
	OPENBSD_3_3_BASE:1.14
	OPENBSD_3_2:1.13.0.2
	OPENBSD_3_2_BASE:1.13
	OPENBSD_3_1:1.10.0.2
	OPENBSD_3_1_BASE:1.10
	OPENBSD_3_0:1.7.0.2
	OPENBSD_3_0_BASE:1.7
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_9:1.6.0.4
	OPENBSD_2_8:1.6.0.2
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.5.0.2
	OPENBSD_2_7_BASE:1.5
	kame_19991209:1.1.1.1
	KAME:1.1.1;
locks; strict;
comment	@ * @;


1.29
date	2014.12.22.09.13.35;	author florian;	state dead;
branches;
next	1.28;
commitid	QHLwHNotIjbdLNCu;

1.28
date	2014.11.18.20.54.29;	author krw;	state Exp;
branches;
next	1.27;
commitid	yCis8OrOsfixbKpI;

1.27
date	2014.07.11.16.44.13;	author henning;	state Exp;
branches;
next	1.26;
commitid	Dbz5uaYBCugHHJye;

1.26
date	2013.10.21.08.46.07;	author phessler;	state Exp;
branches;
next	1.25;

1.25
date	2011.03.23.00.59.49;	author bluhm;	state Exp;
branches;
next	1.24;

1.24
date	2009.06.12.09.50.16;	author chl;	state Exp;
branches;
next	1.23;

1.23
date	2009.06.04.22.45.32;	author henning;	state Exp;
branches;
next	1.22;

1.22
date	2009.02.02.22.06.00;	author chl;	state Exp;
branches;
next	1.21;

1.21
date	2009.01.30.16.21.58;	author rainer;	state Exp;
branches;
next	1.20;

1.20
date	2008.06.09.21.53.57;	author reyk;	state Exp;
branches;
next	1.19;

1.19
date	2006.03.24.22.27.07;	author otto;	state Exp;
branches;
next	1.18;

1.18
date	2004.01.05.20.32.50;	author itojun;	state Exp;
branches;
next	1.17;

1.17
date	2003.10.05.15.29.28;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2003.05.15.14.40.53;	author itojun;	state Exp;
branches;
next	1.15;

1.15
date	2003.04.02.23.39.20;	author jason;	state Exp;
branches;
next	1.14;

1.14
date	2002.10.26.20.20.22;	author itojun;	state Exp;
branches;
next	1.13;

1.13
date	2002.06.10.19.57.35;	author espie;	state Exp;
branches;
next	1.12;

1.12
date	2002.05.31.21.24.28;	author itojun;	state Exp;
branches;
next	1.11;

1.11
date	2002.05.31.09.53.26;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2002.02.17.19.42.39;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2002.02.16.21.28.09;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2001.11.14.01.59.36;	author itojun;	state Exp;
branches;
next	1.7;

1.7
date	2001.07.09.22.37.33;	author itojun;	state Exp;
branches;
next	1.6;

1.6
date	2000.08.13.18.24.00;	author itojun;	state Exp;
branches;
next	1.5;

1.5
date	2000.02.25.10.32.21;	author itojun;	state Exp;
branches;
next	1.4;

1.4
date	2000.01.17.16.33.49;	author itojun;	state Exp;
branches;
next	1.3;

1.3
date	2000.01.05.01.54.50;	author itojun;	state Exp;
branches;
next	1.2;

1.2
date	99.12.09.15.10.49;	author itojun;	state Exp;
branches;
next	1.1;

1.1
date	99.12.09.14.56.01;	author itojun;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.12.09.14.56.01;	author itojun;	state Exp;
branches;
next	;


desc
@@


1.29
log
@Out out you evil network daemon.
OK deraadt@@ some time ago
@
text
@/*	$OpenBSD: if.c,v 1.28 2014/11/18 20:54:29 krw Exp $	*/
/*	$KAME: if.c,v 1.18 2002/05/31 10:10:03 itojun Exp $	*/

/*
 * Copyright (C) 1995, 1996, 1997, and 1998 WIDE Project.
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the project nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/socket.h>
#include <sys/sysctl.h>
#include <sys/ioctl.h>
#include <sys/queue.h>

#include <net/if.h>
#include <net/if_types.h>
#include <net/route.h>
#include <net/if_dl.h>
#include <net/if_media.h>
#include <netinet/in.h>
#include <netinet/if_ether.h>
#include <netinet/icmp6.h>

#include <netinet6/in6_var.h>

#include <err.h>
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <syslog.h>
#include <string.h>
#include <fcntl.h>
#include <errno.h>
#include <limits.h>
#include <ifaddrs.h>
#include <netdb.h>

#include "rtsold.h"

extern int rssock;
static int ifsock;

static int get_llflag(const char *);

int
ifinit(void)
{
	ifsock = rssock;

	return(0);
}

int
get_rdomain(char *name)
{
	int rv = 0, s;
	struct ifreq ifr;

	if ((s = socket(AF_INET6, SOCK_DGRAM, 0)) == -1)
		warnmsg(LOG_ERR, __func__,
		    "get_rdomain socket: %s", strerror(errno));

	memset(&ifr, 0, sizeof(ifr));
	strlcpy(ifr.ifr_name, name, sizeof(ifr.ifr_name));
	if (ioctl(s, SIOCGIFRDOMAIN, (caddr_t)&ifr) != -1)
	    rv = ifr.ifr_rdomainid;

	close(s);
	return rv;
}


int
interface_up(char *name)
{
	struct ifreq ifr;
	int llflag;

	strlcpy(ifr.ifr_name, name, sizeof(ifr.ifr_name));
	if (ioctl(ifsock, SIOCGIFXFLAGS, (caddr_t)&ifr) < 0)
		warn("SIOCGIFXFLAGS");
	ifr.ifr_flags &= ~IFXF_NOINET6;
	ifr.ifr_flags |= IFXF_AUTOCONF6;
	if (ioctl(ifsock, SIOCSIFXFLAGS, (caddr_t)&ifr) < 0)
		warn("SIOCSIFXFLAGS");

	strlcpy(ifr.ifr_name, name, sizeof(ifr.ifr_name));
	if (ioctl(ifsock, SIOCGIFFLAGS, (caddr_t)&ifr) < 0) {
		warnmsg(LOG_WARNING, __func__, "ioctl(SIOCGIFFLAGS): %s",
		    strerror(errno));
		return(-1);
	}
	if (!(ifr.ifr_flags & IFF_UP)) {
		ifr.ifr_flags |= IFF_UP;
		if (ioctl(ifsock, SIOCSIFFLAGS, (caddr_t)&ifr) < 0)
			warnmsg(LOG_ERR, __func__,
			    "ioctl(SIOCSIFFLAGS): %s", strerror(errno));
		return(-1);
	}

	warnmsg(LOG_DEBUG, __func__, "checking if %s is ready...", name);

	llflag = get_llflag(name);
	if (llflag < 0) {
		warnmsg(LOG_WARNING, __func__,
		    "get_llflag() failed, anyway I'll try");
		return 0;
	}

	if (!(llflag & IN6_IFF_NOTREADY)) {
		warnmsg(LOG_DEBUG, __func__, "%s is ready", name);
		return(0);
	} else {
		if (llflag & IN6_IFF_TENTATIVE) {
			warnmsg(LOG_DEBUG, __func__, "%s is tentative",
			    name);
			return IFS_TENTATIVE;
		}
		if (llflag & IN6_IFF_DUPLICATED)
			warnmsg(LOG_DEBUG, __func__, "%s is duplicated",
			    name);
		return -1;
	}
}

int
interface_status(struct ifinfo *ifinfo)
{
	char *ifname = ifinfo->ifname;
	struct ifreq ifr;
	struct ifmediareq ifmr;

	/* get interface flags */
	memset(&ifr, 0, sizeof(ifr));
	strncpy(ifr.ifr_name, ifname, sizeof(ifr.ifr_name));
	if (ioctl(ifsock, SIOCGIFFLAGS, &ifr) < 0) {
		warnmsg(LOG_ERR, __func__, "ioctl(SIOCGIFFLAGS) on %s: %s",
		    ifname, strerror(errno));
		return(-1);
	}
	/*
	 * if one of UP and RUNNING flags is dropped,
	 * the interface is not active.
	 */
	if ((ifr.ifr_flags & (IFF_UP|IFF_RUNNING)) != (IFF_UP|IFF_RUNNING)) {
		goto inactive;
	}

	/* Next, check carrier on the interface, if possible */
	if (!ifinfo->mediareqok)
		goto active;
	memset(&ifmr, 0, sizeof(ifmr));
	strncpy(ifmr.ifm_name, ifname, sizeof(ifmr.ifm_name));

	if (ioctl(ifsock, SIOCGIFMEDIA, (caddr_t)&ifmr) < 0) {
		if (errno != EINVAL) {
			warnmsg(LOG_DEBUG, __func__,
			    "ioctl(SIOCGIFMEDIA) on %s: %s",
			    ifname, strerror(errno));
			return(-1);
		}
		/*
		 * EINVAL simply means that the interface does not support
		 * the SIOCGIFMEDIA ioctl. We regard it alive.
		 */
		ifinfo->mediareqok = 0;
		goto active;
	}

	if (ifmr.ifm_status & IFM_AVALID) {
		switch (ifmr.ifm_active & IFM_NMASK) {
		case IFM_ETHER:
		case IFM_IEEE80211:
			if (ifmr.ifm_status & IFM_ACTIVE)
				goto active;
			else
				goto inactive;
			break;
		default:
			goto inactive;
		}
	}

  inactive:
	return(0);

  active:
	return(1);
}

#define ROUNDUP8(a) (1 + (((a) - 1) | 7))

int
lladdropt_length(struct sockaddr_dl *sdl)
{
	switch (sdl->sdl_type) {
	case IFT_ETHER:
#ifdef IFT_IEEE80211
	case IFT_IEEE80211:
#endif
		return(ROUNDUP8(ETHER_ADDR_LEN + 2));
	default:
		return(0);
	}
}

void
lladdropt_fill(struct sockaddr_dl *sdl, struct nd_opt_hdr *ndopt)
{
	char *addr;

	ndopt->nd_opt_type = ND_OPT_SOURCE_LINKADDR; /* fixed */

	switch (sdl->sdl_type) {
	case IFT_ETHER:
#ifdef IFT_IEEE80211
	case IFT_IEEE80211:
#endif
		ndopt->nd_opt_len = (ROUNDUP8(ETHER_ADDR_LEN + 2)) >> 3;
		addr = (char *)(ndopt + 1);
		memcpy(addr, LLADDR(sdl), ETHER_ADDR_LEN);
		break;
	default:
		warnmsg(LOG_ERR, __func__,
		    "unsupported link type(%d)", sdl->sdl_type);
		exit(1);
	}

	return;
}

struct sockaddr_dl *
if_nametosdl(char *name)
{
	struct ifaddrs *ifap, *ifa;
	struct sockaddr_dl *sdl;

	if (getifaddrs(&ifap) != 0)
		return (NULL);

	for (ifa = ifap; ifa; ifa = ifa->ifa_next) {
		if (strcmp(ifa->ifa_name, name) != 0)
			continue;
		if (ifa->ifa_addr->sa_family != AF_LINK)
			continue;

		sdl = malloc(ifa->ifa_addr->sa_len);
		if (!sdl)
			continue;	/*XXX*/

		memcpy(sdl, ifa->ifa_addr, ifa->ifa_addr->sa_len);
		freeifaddrs(ifap);
		return (sdl);
	}

	freeifaddrs(ifap);
	return (NULL);
}

int
getinet6sysctl(int proto, int code)
{
	int mib[] = { CTL_NET, PF_INET6, proto, 0 };
	int value;
	size_t size;

	mib[3] = code;
	size = sizeof(value);
	if (sysctl(mib, sizeof(mib)/sizeof(mib[0]), &value, &size, NULL, 0) < 0)
		return -1;
	else
		return value;
}

int
setinet6sysctl(int proto, int code, int newval)
{
	int mib[] = { CTL_NET, PF_INET6, proto, 0 };
	int value;
	size_t size;

	mib[3] = code;
	size = sizeof(value);
	if (sysctl(mib, sizeof(mib)/sizeof(mib[0]), &value, &size,
	    &newval, sizeof(newval)) < 0)
		return -1;
	else
		return value;
}

/* get ia6_flags for link-local addr on if.  returns -1 on error. */
static int
get_llflag(const char *name)
{
	struct ifaddrs *ifap, *ifa;
	struct in6_ifreq ifr6;
	struct sockaddr_in6 *sin6;
	int s;

	if ((s = socket(PF_INET6, SOCK_DGRAM, 0)) < 0) {
		warnmsg(LOG_ERR, __func__, "socket(SOCK_DGRAM): %s",
		    strerror(errno));
		exit(1);
	}
	if (getifaddrs(&ifap) != 0) {
		warnmsg(LOG_ERR, __func__, "getifaddrs: %s",
		    strerror(errno));
		exit(1);
	}

	for (ifa = ifap; ifa; ifa = ifa->ifa_next) {
		if (strlen(ifa->ifa_name) != strlen(name) ||
		    strncmp(ifa->ifa_name, name, strlen(name)) != 0)
			continue;
		if (ifa->ifa_addr->sa_family != AF_INET6)
			continue;
		sin6 = (struct sockaddr_in6 *)ifa->ifa_addr;
		if (!IN6_IS_ADDR_LINKLOCAL(&sin6->sin6_addr))
			continue;

		memset(&ifr6, 0, sizeof(ifr6));
		strncpy(ifr6.ifr_name, name, sizeof(ifr6.ifr_name));
		memcpy(&ifr6.ifr_ifru.ifru_addr, sin6, sin6->sin6_len);
		if (ioctl(s, SIOCGIFAFLAG_IN6, &ifr6) < 0) {
			warnmsg(LOG_ERR, __func__,
			    "ioctl(SIOCGIFAFLAG_IN6): %s", strerror(errno));
			exit(1);
		}

		freeifaddrs(ifap);
		close(s);
		return ifr6.ifr_ifru.ifru_flags6;
	}

	freeifaddrs(ifap);
	close(s);
	return -1;
}
@


1.28
log
@Nuke more obvious #include duplications.

ok deraadt@@ millert@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.27 2014/07/11 16:44:13 henning Exp $	*/
@


1.27
log
@some say it is kinda likely you want autoconf if you run rtsol/rtsold on
a given interface, so turn AFXF_AUTOCONF6 on on it
ok bluhm stsp benno florian
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.25 2011/03/23 00:59:49 bluhm Exp $	*/
a45 1
#include <netinet/in.h>
@


1.26
log
@Add rdomain support to IPv6 configuration tools

OK claudio@@ and bluhm@@
@
text
@d108 1
@


1.25
log
@Print a warning when rtsol or rtsold are used to do IPv6 autoconfiguration
but accepting redirects is turned off.  If the -F switch is given,
set sysctl net.inet6.icmp6.rediraccept to 1 instead.
ok claudio@@ deraadt@@ sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.24 2009/06/12 09:50:16 chl Exp $	*/
d77 20
@


1.24
log
@add missing header needed by warn()

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.23 2009/06/04 22:45:32 henning Exp $	*/
d265 1
a265 1
getinet6sysctl(int code)
d267 1
a267 1
	int mib[] = { CTL_NET, PF_INET6, IPPROTO_IPV6, 0 };
d280 1
a280 1
setinet6sysctl(int code, int newval)
d282 1
a282 1
	int mib[] = { CTL_NET, PF_INET6, IPPROTO_IPV6, 0 };
@


1.23
log
@turn ipvcrap on on the interface in question. sake bottle pushed by theo,
tested by naddy
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.22 2009/02/02 22:06:00 chl Exp $	*/
d51 1
@


1.22
log
@remove unused function and macros, due to the lastest commit

ok rainer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.21 2009/01/30 16:21:58 rainer Exp $	*/
d83 6
a88 1
	strncpy(ifr.ifr_name, name, sizeof(ifr.ifr_name));
d90 1
@


1.21
log
@Use if_nametosdl implementation from rtadvd, which is much nicer.
From Mischa Diehm.

"looks fine to me" pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.20 2008/06/09 21:53:57 reyk Exp $	*/
a67 1
static void get_rtaddrs(int, struct sockaddr *, struct sockaddr **);
a187 6
#define ROUNDUP(a, size) \
	(((a) & ((size)-1)) ? (1 + ((a) | ((size)-1))) : (a))

#define NEXT_SA(ap) (ap) = (struct sockaddr *) \
	((caddr_t)(ap) + ((ap)->sa_len ? ROUNDUP((ap)->sa_len,\
	sizeof(u_long)) : sizeof(u_long)))
a287 2
/*------------------------------------------------------------*/

a334 15
}


static void
get_rtaddrs(int addrs, struct sockaddr *sa, struct sockaddr **rti_info)
{
	int i;

	for (i = 0; i < RTAX_MAX; i++) {
		if (addrs & (1 << i)) {
			rti_info[i] = sa;
			NEXT_SA(sa);
		} else
			rti_info[i] = NULL;
	}
@


1.20
log
@also handle wireless interfaces (IFM_IEEE80211 in addition to IFM_ETHER)

From kame
ok rainer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.19 2006/03/24 22:27:07 otto Exp $	*/
d60 1
d239 15
a253 41
	int mib[6] = {CTL_NET, AF_ROUTE, 0, 0, NET_RT_IFLIST, 0};
	char *buf, *next, *lim;
	size_t len;
	struct if_msghdr *ifm;
	struct sockaddr *sa, *rti_info[RTAX_MAX];
	struct sockaddr_dl *sdl = NULL, *ret_sdl;

	if (sysctl(mib, 6, NULL, &len, NULL, 0) < 0)
		return(NULL);
	if ((buf = malloc(len)) == NULL)
		return(NULL);
	if (sysctl(mib, 6, buf, &len, NULL, 0) < 0) {
		free(buf);
		return(NULL);
	}

	lim = buf + len;
	for (next = buf; next < lim; next += ifm->ifm_msglen) {
		ifm = (struct if_msghdr *)next;
		if (ifm->ifm_type == RTM_IFINFO) {
			sa = (struct sockaddr *)(ifm + 1);
			get_rtaddrs(ifm->ifm_addrs, sa, rti_info);
			if ((sa = rti_info[RTAX_IFP]) != NULL) {
				if (sa->sa_family == AF_LINK) {
					sdl = (struct sockaddr_dl *)sa;
					if (strlen(name) != sdl->sdl_nlen)
						continue; /* not same len */
					if (strncmp(&sdl->sdl_data[0],
						    name,
						    sdl->sdl_nlen) == 0) {
						break;
					}
				}
			}
		}
	}
	if (next == lim) {
		/* search failed */
		free(buf);
		return(NULL);
	}
d255 3
a257 3
	if ((ret_sdl = malloc(sdl->sdl_len)) == NULL) {
		free(buf);
		return(NULL);
a258 1
	memcpy((caddr_t)ret_sdl, (caddr_t)sdl, sdl->sdl_len);
d260 2
a261 2
	free(buf);
	return(ret_sdl);
@


1.19
log
@Plug leak in error path; from Alexey Dobriyan; ok ray@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.18 2004/01/05 20:32:50 itojun Exp $	*/
d170 1
@


1.18
log
@add -F option, which sets sysctl(8) variables rather than warn(3) about the
current setting.  basically for boot floppy.  req'ed by fries@@. deraadt@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.17 2003/10/05 15:29:28 deraadt Exp $	*/
d279 2
a280 1
	if ((ret_sdl = malloc(sdl->sdl_len)) == NULL)
d282 1
@


1.17
log
@ansi
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.16 2003/05/15 14:40:53 itojun Exp $	*/
d297 16
@


1.16
log
@make getifaddrs(3) a default, as all BSD has it by now
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.15 2003/04/02 23:39:20 jason Exp $	*/
d70 1
a70 1
ifinit()
@


1.15
log
@typo; ok itojun
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.14 2002/10/26 20:20:22 itojun Exp $	*/
a58 1
#ifdef HAVE_GETIFADDRS
a59 1
#endif
a66 3
#ifndef HAVE_GETIFADDRS
static unsigned int if_maxindex(void);
#endif
a307 1
#ifdef HAVE_GETIFADDRS
a350 62
#else
	int s;
	unsigned int maxif;
	struct ifreq *iflist;
	struct ifconf ifconf;
	struct ifreq *ifr, *ifr_end;
	struct sockaddr_in6 *sin6;
	struct in6_ifreq ifr6;

	maxif = if_maxindex() + 1;
	iflist = (struct ifreq *)malloc(maxif * BUFSIZ);	/* XXX */
	if (iflist == NULL) {
		warnmsg(LOG_ERR, __func__, "not enough core");
		exit(1);
	}

	if ((s = socket(PF_INET6, SOCK_DGRAM, 0)) < 0) {
		warnmsg(LOG_ERR, __func__, "socket(SOCK_DGRAM): %s",
		    strerror(errno));
		exit(1);
	}
	memset(&ifconf, 0, sizeof(ifconf));
	ifconf.ifc_req = iflist;
	ifconf.ifc_len = maxif * BUFSIZ;	/* XXX */
	if (ioctl(s, SIOCGIFCONF, &ifconf) < 0) {
		warnmsg(LOG_ERR, __func__, "ioctl(SIOCGIFCONF): %s",
		    strerror(errno));
		exit(1);
	}

	/* Look for this interface in the list */
	ifr_end = (struct ifreq *) (ifconf.ifc_buf + ifconf.ifc_len);
	for (ifr = ifconf.ifc_req; ifr < ifr_end;
	    ifr = (struct ifreq *) ((char *) &ifr->ifr_addr
				    + ifr->ifr_addr.sa_len)) {
		if (strlen(ifr->ifr_name) != strlen(name) ||
		    strncmp(ifr->ifr_name, name, strlen(name)) != 0)
			continue;
		if (ifr->ifr_addr.sa_family != AF_INET6)
			continue;
		sin6 = (struct sockaddr_in6 *)&ifr->ifr_addr;
		if (!IN6_IS_ADDR_LINKLOCAL(&sin6->sin6_addr))
			continue;

		memset(&ifr6, 0, sizeof(ifr6));
		strncpy(ifr6.ifr_name, name, sizeof(ifr6.ifr_name));
		memcpy(&ifr6.ifr_ifru.ifru_addr, sin6, sin6->sin6_len);
		if (ioctl(s, SIOCGIFAFLAG_IN6, &ifr6) < 0) {
			warnmsg(LOG_ERR, __func__,
			    "ioctl(SIOCGIFAFLAG_IN6): %s", strerror(errno));
			exit(1);
		}

		free(iflist);
		close(s);
		return ifr6.ifr_ifru.ifru_flags6;
	}

	free(iflist);
	close(s);
	return -1;
#endif
a352 16
#ifndef HAVE_GETIFADDRS
static unsigned int
if_maxindex()
{
	struct if_nameindex *p, *p0;
	unsigned int max = 0;

	p0 = if_nameindex();
	for (p = p0; p && p->if_index && p->if_name; p++) {
		if (max < p->if_index)
			max = p->if_index;
	}
	if_freenameindex(p0);
	return max;
}
#endif
@


1.14
log
@prototype shouldn't carry variable name
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.13 2002/06/10 19:57:35 espie Exp $	*/
d325 1
a325 1
		warnmsg(LOG_ERR, __func__, "etifaddrs: %s",
@


1.13
log
@Kill __FUNCTION__.
ok itojun@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.12 2002/05/31 21:24:28 itojun Exp $	*/
d68 1
a68 1
static int get_llflag(const char *name);
d72 1
a72 2
static void get_rtaddrs(int addrs, struct sockaddr *sa,
    struct sockaddr **rti_info);
@


1.12
log
@sync w/ latest kame.  link id handling.
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.11 2002/05/31 09:53:26 deraadt Exp $	*/
d92 1
a92 1
		warnmsg(LOG_WARNING, __FUNCTION__, "ioctl(SIOCGIFFLAGS): %s",
d99 1
a99 1
			warnmsg(LOG_ERR, __FUNCTION__,
d104 1
a104 1
	warnmsg(LOG_DEBUG, __FUNCTION__, "checking if %s is ready...", name);
d108 1
a108 1
		warnmsg(LOG_WARNING, __FUNCTION__,
d114 1
a114 1
		warnmsg(LOG_DEBUG, __FUNCTION__, "%s is ready", name);
d118 1
a118 1
			warnmsg(LOG_DEBUG, __FUNCTION__, "%s is tentative",
d123 1
a123 1
			warnmsg(LOG_DEBUG, __FUNCTION__, "%s is duplicated",
d140 1
a140 1
		warnmsg(LOG_ERR, __FUNCTION__, "ioctl(SIOCGIFFLAGS) on %s: %s",
d160 1
a160 1
			warnmsg(LOG_DEBUG, __FUNCTION__,
d232 1
a232 1
		warnmsg(LOG_ERR, __FUNCTION__,
d321 1
a321 1
		warnmsg(LOG_ERR, __FUNCTION__, "socket(SOCK_DGRAM): %s",
d326 1
a326 1
		warnmsg(LOG_ERR, __FUNCTION__, "etifaddrs: %s",
d345 1
a345 1
			warnmsg(LOG_ERR, __FUNCTION__,
d370 1
a370 1
		warnmsg(LOG_ERR, __FUNCTION__, "not enough core");
d375 1
a375 1
		warnmsg(LOG_ERR, __FUNCTION__, "socket(SOCK_DGRAM): %s",
d383 1
a383 1
		warnmsg(LOG_ERR, __FUNCTION__, "ioctl(SIOCGIFCONF): %s",
d406 1
a406 1
			warnmsg(LOG_ERR, __FUNCTION__,
@


1.11
log
@KNF; itojun ok
@
text
@d1 2
a2 2
/*	$OpenBSD: if.c,v 1.10 2002/02/17 19:42:39 millert Exp $	*/
/*	$KAME: if.c,v 1.15 2001/05/22 06:04:17 jinmei Exp $	*/
a39 3
#if defined(__FreeBSD__) && __FreeBSD__ >= 3
#include <net/if_var.h>
#endif /* __FreeBSD__ >= 3 */
d44 2
a45 10
#ifdef __FreeBSD__
# include <net/ethernet.h>
#endif
#ifdef __NetBSD__
#include <net/if_ether.h>
#endif
#if defined(__bsdi__) || defined(__OpenBSD__)
# include <netinet/in.h>
# include <netinet/if_ether.h>
#endif
@


1.10
log
@Manual cleanup of remaining userland __P use (excluding packages maintained outside the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.9 2002/02/16 21:28:09 millert Exp $	*/
d104 1
a104 1
		       strerror(errno));
d109 1
a109 1
		if (ioctl(ifsock, SIOCSIFFLAGS, (caddr_t)&ifr) < 0) {
d111 1
a111 2
				"ioctl(SIOCSIFFLAGS): %s", strerror(errno));
		}
d120 1
a120 1
			"get_llflag() failed, anyway I'll try");
d125 1
a125 2
		warnmsg(LOG_DEBUG, __FUNCTION__,
			"%s is ready", name);
d130 1
a130 1
			       name);
d135 1
a135 1
			       name);
d146 1
a146 1
	
d152 1
a152 1
		       ifname, strerror(errno));
d172 2
a173 2
				"ioctl(SIOCGIFMEDIA) on %s: %s",
			       ifname, strerror(errno));
d185 9
a193 9
		switch(ifmr.ifm_active & IFM_NMASK) {
		 case IFM_ETHER:
			 if (ifmr.ifm_status & IFM_ACTIVE)
				 goto active;
			 else
				 goto inactive;
			 break;
		 default:
			 goto inactive;
d209 1
a209 2
						 sizeof(u_long)) :\
			  			 sizeof(u_long)))
d215 2
a216 2
	switch(sdl->sdl_type) {
	 case IFT_ETHER:
d220 3
a222 3
		 return(ROUNDUP8(ETHER_ADDR_LEN + 2));
	 default:
		 return(0);
d233 2
a234 2
	switch(sdl->sdl_type) {
	 case IFT_ETHER:
d238 8
a245 8
		 ndopt->nd_opt_len = (ROUNDUP8(ETHER_ADDR_LEN + 2)) >> 3;
		 addr = (char *)(ndopt + 1);
		 memcpy(addr, LLADDR(sdl), ETHER_ADDR_LEN);
		 break;
	 default:
		 warnmsg(LOG_ERR, __FUNCTION__,
			 "unsupported link type(%d)", sdl->sdl_type);
		 exit(1);
d343 2
a344 2
		if (strlen(ifa->ifa_name) != strlen(name)
		 || strncmp(ifa->ifa_name, name, strlen(name)) != 0)
d401 2
a402 3
	for (ifr = ifconf.ifc_req;
	     ifr < ifr_end;
	     ifr = (struct ifreq *) ((char *) &ifr->ifr_addr
d404 2
a405 2
		if (strlen(ifr->ifr_name) != strlen(name)
		 || strncmp(ifr->ifr_name, name, strlen(name)) != 0)
d454 1
a454 1
	
d459 1
a459 2
		}
		else
@


1.9
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.8 2001/11/14 01:59:36 itojun Exp $	*/
d83 2
a84 2
static void get_rtaddrs __P((int addrs, struct sockaddr *sa,
			     struct sockaddr **rti_info));
@


1.8
log
@use strncpy instead of strcpy, just in case
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.7 2001/07/09 22:37:33 itojun Exp $	*/
d79 1
a79 1
static int get_llflag __P((const char *name));
d81 1
a81 1
static unsigned int if_maxindex __P((void));
@


1.7
log
@sync with latest kame.
- a memory leak
- correct timer value
- wording fixes in manpage
rtsock.c is omitted for simplicity, as it is not meaningful on openbsd.
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.6 2000/08/13 18:24:00 itojun Exp $	*/
d356 1
a356 1
		strcpy(ifr6.ifr_name, name);
d418 1
a418 1
		strcpy(ifr6.ifr_name, name);
@


1.6
log
@add "rtsol -a" (automatically lookup outgoign interface).
warn if net.inet6.ip6.forwarding == 1.
improve manpage.
use $KAME$ for KAME tags.

sync with kame.
@
text
@d1 2
a2 2
/*	$OpenBSD: if.c,v 1.5 2000/02/25 10:32:21 itojun Exp $	*/
/*	$KAME: if.c,v 1.13 2000/08/13 06:14:59 itojun Exp $	*/
d220 3
d238 3
d303 1
@


1.5
log
@use getifaddrs, not SIOCGIFCONF for LP64 align issue. (sync with kame).
@
text
@d1 2
a2 1
/*	$OpenBSD: if.c,v 1.4 2000/01/17 16:33:49 itojun Exp $	*/
d37 1
@


1.4
log
@sync with latest kame.  previous version leaves an udp socket opened
(for use with ioctls) and it was not a pleasant thing.
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.3 2000/01/05 01:54:50 itojun Exp $	*/
d68 3
d78 1
d80 1
d319 45
d425 1
d428 1
d443 1
@


1.3
log
@avoid use of kvm (sync with latest kame)
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.2 1999/12/09 15:10:49 itojun Exp $	*/
d71 1
d82 1
a82 4
	if ((ifsock = socket(AF_INET6, SOCK_DGRAM, 0)) < 0) {
		warnmsg(LOG_ERR, __FUNCTION__, "socket: %s", strerror(errno));
		return(-1);
	}
@


1.2
log
@rtsold(8); router solicitation daemon.
rtsol(8); router solicitation program, for use in bootstrap process
(statically linked)

rcsid police.  add missing prototypes.
(sync with KAME)
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a66 2
#include <kvm.h>
#include <nlist.h>
d73 2
a74 1
static int getifa __P((char *name, struct in6_ifaddr *ifap));
d93 1
a93 1
	struct in6_ifaddr ifa;
d113 2
a114 1
	if (getifa(name, &ifa) < 0) {
d116 1
a116 1
			"getifa() failed, anyway I'll try");
d120 1
a120 1
	if (!(ifa.ia6_flags & IN6_IFF_NOTREADY)) {
d124 2
a125 3
	}
	else {
		if (ifa.ia6_flags & IN6_IFF_TENTATIVE) {
d130 1
a130 1
		if (ifa.ia6_flags & IN6_IFF_DUPLICATED)
d312 1
a312 13
static struct nlist nl[] = {
#define N_IFNET	0
	{ "_ifnet" },
	{ "" },
};

#define KREAD(x, y, z) { \
	if (kvm_read(kvmd, (u_long)x, (void *)y, sizeof(z)) != sizeof(z)) { \
		warnmsg(LOG_ERR, __FUNCTION__, "kvm_read failed");	\
		goto bad;						\
	}								\
   }

d314 1
a314 1
getifa(char *name, struct in6_ifaddr *ifap)
d316 14
a329 6
	u_short index;
	kvm_t *kvmd = NULL;
	char buf[_POSIX2_LINE_MAX];
	struct ifnet *ifp;
	struct ifnet ifnet;
	struct in6_ifaddr *ifa;
d331 3
a333 1
	if (!ifap)
a334 33

	index = (u_short)if_nametoindex(name);
	if (index == 0) {
		warnmsg(LOG_ERR, __FUNCTION__, "if_nametoindex failed for %s",
		       name);
		goto bad;
	}
	if ((kvmd = kvm_openfiles(NULL, NULL, NULL, O_RDONLY, buf)) == NULL) {
		warnmsg(LOG_ERR, __FUNCTION__, "kvm_openfiles failed");
		goto bad;
	}
	if (kvm_nlist(kvmd, nl) < 0) {
		warnmsg(LOG_ERR, __FUNCTION__, "kvm_nlist failed");
		goto bad;
	}
	if (nl[N_IFNET].n_value == 0) {
		warnmsg(LOG_ERR, __FUNCTION__, "symbol \"%s\" not found",
		       nl[N_IFNET].n_name);
		goto bad;
	}

	KREAD(nl[N_IFNET].n_value, &ifp, struct ifnet *);
	while (ifp) {
		KREAD(ifp, &ifnet, struct ifnet);
		if (ifnet.if_index == index)
			break;
#if defined(__NetBSD__) || defined(__OpenBSD__)
		ifp = TAILQ_NEXT(&ifnet, if_list);
#elif defined(__FreeBSD__) && __FreeBSD__ >= 3
		ifp = TAILQ_NEXT(&ifnet, if_link);
#else
		ifp = ifnet.if_next;
#endif
d336 7
a342 4
	if (!ifp) {
		warnmsg(LOG_ERR, __FUNCTION__, "interface \"%s\" not found",
		       name);
		goto bad;
d345 22
a366 13
#if defined(__NetBSD__) || defined(__OpenBSD__)
	ifa = (struct in6_ifaddr *)TAILQ_FIRST(&ifnet.if_addrlist);
#elif defined(__FreeBSD__) && __FreeBSD__ >= 3
	ifa = (struct in6_ifaddr *)TAILQ_FIRST(&ifnet.if_addrhead);
#else
	ifa = (struct in6_ifaddr *)ifnet.if_addrlist;
#endif
	while (ifa) {
		KREAD(ifa, ifap, *ifap);
		if (ifap->ia_addr.sin6_family == AF_INET6
		 && IN6_IS_ADDR_LINKLOCAL(&ifap->ia_addr.sin6_addr)) {
			kvm_close(kvmd);
			return 0;
d369 3
a371 9
#if defined(__NetBSD__) || defined(__OpenBSD__)
		ifa = (struct in6_ifaddr *)
			TAILQ_NEXT((struct ifaddr *)ifap, ifa_list);
#elif defined(__FreeBSD__) && __FreeBSD__ >= 3
		ifa = (struct in6_ifaddr *)
			TAILQ_NEXT((struct ifaddr *)ifap, ifa_link);
#else
		ifa = (struct in6_ifaddr *)(((struct ifaddr *)ifap)->ifa_next);
#endif
a372 2
	warnmsg(LOG_ERR, __FUNCTION__, "no IPv6 link-local address for %s",
	       name);
d374 2
a375 3
  bad:
	if (kvmd)
		kvm_close(kvmd);
d377 15
@


1.1
log
@Initial revision
@
text
@d1 2
@


1.1.1.1
log
@initial import from KAME tree
@
text
@@
