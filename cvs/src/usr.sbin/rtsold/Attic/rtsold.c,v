head	1.55;
access;
symbols
	OPENBSD_5_6:1.52.0.4
	OPENBSD_5_6_BASE:1.52
	OPENBSD_5_5:1.50.0.4
	OPENBSD_5_5_BASE:1.50
	OPENBSD_5_4:1.49.0.2
	OPENBSD_5_4_BASE:1.49
	OPENBSD_5_3:1.47.0.8
	OPENBSD_5_3_BASE:1.47
	OPENBSD_5_2:1.47.0.6
	OPENBSD_5_2_BASE:1.47
	OPENBSD_5_1_BASE:1.47
	OPENBSD_5_1:1.47.0.4
	OPENBSD_5_0:1.47.0.2
	OPENBSD_5_0_BASE:1.47
	OPENBSD_4_9:1.45.0.10
	OPENBSD_4_9_BASE:1.45
	OPENBSD_4_8:1.45.0.8
	OPENBSD_4_8_BASE:1.45
	OPENBSD_4_7:1.45.0.4
	OPENBSD_4_7_BASE:1.45
	OPENBSD_4_6:1.45.0.6
	OPENBSD_4_6_BASE:1.45
	OPENBSD_4_5:1.45.0.2
	OPENBSD_4_5_BASE:1.45
	OPENBSD_4_4:1.43.0.2
	OPENBSD_4_4_BASE:1.43
	OPENBSD_4_3:1.40.0.2
	OPENBSD_4_3_BASE:1.40
	OPENBSD_4_2:1.39.0.4
	OPENBSD_4_2_BASE:1.39
	OPENBSD_4_1:1.39.0.2
	OPENBSD_4_1_BASE:1.39
	OPENBSD_4_0:1.38.0.4
	OPENBSD_4_0_BASE:1.38
	OPENBSD_3_9:1.38.0.2
	OPENBSD_3_9_BASE:1.38
	OPENBSD_3_8:1.37.0.2
	OPENBSD_3_8_BASE:1.37
	OPENBSD_3_7:1.36.0.6
	OPENBSD_3_7_BASE:1.36
	OPENBSD_3_6:1.36.0.4
	OPENBSD_3_6_BASE:1.36
	OPENBSD_3_5:1.36.0.2
	OPENBSD_3_5_BASE:1.36
	OPENBSD_3_4:1.31.0.2
	OPENBSD_3_4_BASE:1.31
	OPENBSD_3_3:1.28.0.2
	OPENBSD_3_3_BASE:1.28
	OPENBSD_3_2:1.25.0.2
	OPENBSD_3_2_BASE:1.25
	OPENBSD_3_1:1.18.0.2
	OPENBSD_3_1_BASE:1.18
	OPENBSD_3_0:1.10.0.2
	OPENBSD_3_0_BASE:1.10
	OPENBSD_2_9_BASE:1.9
	OPENBSD_2_9:1.9.0.4
	OPENBSD_2_8:1.9.0.2
	OPENBSD_2_8_BASE:1.9
	OPENBSD_2_7:1.7.0.2
	OPENBSD_2_7_BASE:1.7
	kame_19991209:1.1.1.1
	KAME:1.1.1;
locks; strict;
comment	@ * @;


1.55
date	2014.12.22.09.13.35;	author florian;	state dead;
branches;
next	1.54;
commitid	QHLwHNotIjbdLNCu;

1.54
date	2014.10.08.04.55.27;	author deraadt;	state Exp;
branches;
next	1.53;
commitid	rBRzlEUhcQGafgbz;

1.53
date	2014.08.27.14.04.16;	author florian;	state Exp;
branches;
next	1.52;
commitid	JNq3mHDvq54quWei;

1.52
date	2014.07.11.16.44.13;	author henning;	state Exp;
branches;
next	1.51;
commitid	Dbz5uaYBCugHHJye;

1.51
date	2014.07.04.22.33.43;	author guenther;	state Exp;
branches;
next	1.50;
commitid	VnCsTyTeTV7e1l2z;

1.50
date	2013.10.21.08.46.07;	author phessler;	state Exp;
branches;
next	1.49;

1.49
date	2013.04.21.19.42.32;	author florian;	state Exp;
branches;
next	1.48;

1.48
date	2013.04.19.05.06.52;	author deraadt;	state Exp;
branches;
next	1.47;

1.47
date	2011.03.23.00.59.49;	author bluhm;	state Exp;
branches;
next	1.46;

1.46
date	2011.03.22.10.16.23;	author okan;	state Exp;
branches;
next	1.45;

1.45
date	2009.01.30.17.25.51;	author rainer;	state Exp;
branches;
next	1.44;

1.44
date	2008.08.13.17.24.54;	author sobrado;	state Exp;
branches;
next	1.43;

1.43
date	2008.06.12.16.12.31;	author jmc;	state Exp;
branches;
next	1.42;

1.42
date	2008.06.10.04.49.11;	author reyk;	state Exp;
branches;
next	1.41;

1.41
date	2008.04.13.00.22.17;	author djm;	state Exp;
branches;
next	1.40;

1.40
date	2008.01.05.17.03.09;	author chl;	state Exp;
branches;
next	1.39;

1.39
date	2006.11.07.07.20.16;	author ray;	state Exp;
branches;
next	1.38;

1.38
date	2005.10.28.08.06.39;	author jmc;	state Exp;
branches;
next	1.37;

1.37
date	2005.06.09.00.27.12;	author deraadt;	state Exp;
branches;
next	1.36;

1.36
date	2004.01.05.20.35.52;	author itojun;	state Exp;
branches;
next	1.35;

1.35
date	2004.01.05.20.32.50;	author itojun;	state Exp;
branches;
next	1.34;

1.34
date	2004.01.03.06.20.17;	author itojun;	state Exp;
branches;
next	1.33;

1.33
date	2004.01.02.23.52.17;	author itojun;	state Exp;
branches;
next	1.32;

1.32
date	2004.01.02.23.46.04;	author itojun;	state Exp;
branches;
next	1.31;

1.31
date	2003.07.07.00.18.30;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2003.06.25.21.10.33;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	2003.05.15.14.40.53;	author itojun;	state Exp;
branches;
next	1.28;

1.28
date	2003.03.13.22.26.52;	author millert;	state Exp;
branches;
next	1.27;

1.27
date	2003.03.13.09.09.50;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2002.10.26.20.23.20;	author itojun;	state Exp;
branches;
next	1.25;

1.25
date	2002.09.08.01.33.35;	author itojun;	state Exp;
branches;
next	1.24;

1.24
date	2002.06.10.19.57.35;	author espie;	state Exp;
branches;
next	1.23;

1.23
date	2002.05.31.22.09.14;	author itojun;	state Exp;
branches;
next	1.22;

1.22
date	2002.05.31.22.05.16;	author itojun;	state Exp;
branches;
next	1.21;

1.21
date	2002.05.31.21.24.28;	author itojun;	state Exp;
branches;
next	1.20;

1.20
date	2002.05.31.10.11.14;	author itojun;	state Exp;
branches;
next	1.19;

1.19
date	2002.05.31.09.53.26;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2002.03.25.20.46.49;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2002.02.19.19.39.40;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2002.02.17.19.42.39;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2002.02.16.21.28.09;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2002.01.11.03.51.08;	author itojun;	state Exp;
branches;
next	1.13;

1.13
date	2001.12.01.23.27.24;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2001.12.01.19.27.28;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2001.11.17.19.49.40;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2001.07.09.22.37.33;	author itojun;	state Exp;
branches;
next	1.9;

1.9
date	2000.10.06.02.46.58;	author itojun;	state Exp;
branches;
next	1.8;

1.8
date	2000.08.13.18.24.00;	author itojun;	state Exp;
branches;
next	1.7;

1.7
date	2000.02.25.10.32.21;	author itojun;	state Exp;
branches;
next	1.6;

1.6
date	2000.02.01.03.24.11;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2000.01.17.16.33.49;	author itojun;	state Exp;
branches;
next	1.4;

1.4
date	99.12.16.03.13.46;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	99.12.16.03.13.24;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	99.12.09.15.10.49;	author itojun;	state Exp;
branches;
next	1.1;

1.1
date	99.12.09.14.56.02;	author itojun;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.12.09.14.56.02;	author itojun;	state Exp;
branches;
next	;


desc
@@


1.55
log
@Out out you evil network daemon.
OK deraadt@@ some time ago
@
text
@/*	$OpenBSD: rtsold.c,v 1.54 2014/10/08 04:55:27 deraadt Exp $	*/
/*	$KAME: rtsold.c,v 1.75 2004/01/03 00:00:07 itojun Exp $	*/

/*
 * Copyright (C) 1995, 1996, 1997, and 1998 WIDE Project.
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the project nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/time.h>
#include <sys/socket.h>
#include <sys/param.h>

#include <net/if.h>
#include <net/if_dl.h>

#include <netinet/in.h>
#include <netinet/icmp6.h>

#include <signal.h>
#include <unistd.h>
#include <syslog.h>
#include <string.h>
#include <stdlib.h>
#include <stdio.h>
#include <errno.h>
#include <err.h>
#include <stdarg.h>
#include <ifaddrs.h>
#include <util.h>
#include <poll.h>

#include "rtsold.h"

struct ifinfo *iflist;
static int log_upto = 999;
static int fflag = 0;
static int Fflag = 0;	/* force setting sysctl parameters */

int aflag = 0;
int dflag = 0;

char *otherconf_script;

/* protocol constants */
#define MAX_RTR_SOLICITATION_DELAY	1 /* second */
#define RTR_SOLICITATION_INTERVAL	4 /* seconds */
#define MAX_RTR_SOLICITATIONS		3 /* times */

/* 
 * implementation dependent constants in seconds
 * XXX: should be configurable 
 */
#define PROBE_INTERVAL 60

int main(int, char **);

/* static variables and functions */
static int mobile_node = 0;
#ifndef SMALL
volatile sig_atomic_t do_dump;
static char *dumpfilename = "/var/run/rtsold.dump"; /* XXX: should be configurable */
#endif

#if 0
static int ifreconfig(char *);
#endif
int ifconfig(char *ifname);
static int make_packet(struct ifinfo *);
static struct timeval *rtsol_check_timer(void);

#ifndef SMALL
static void rtsold_set_dump_file(int);
#endif
static void usage(char *);

int
main(int argc, char *argv[])
{
	int s, ch, once = 0;
	u_int rdomain;
	struct timeval *timeout;
	char *argv0, *opts;
	struct pollfd set[2];

	/*
	 * Initialization
	 */
	argv0 = argv[0];

	/* get option */
	if (argv0 && argv0[0] != '\0' && argv0[strlen(argv0) - 1] != 'd') {
		fflag = 1;
		once = 1;
		opts = "adDFO:";
	} else
		opts = "adDfFm1O:";

	while ((ch = getopt(argc, argv, opts)) != -1) {
		switch (ch) {
		case 'a':
			aflag = 1;
			break;
		case 'd':
			dflag = 1;
			break;
		case 'D':
			dflag = 2;
			break;
		case 'f':
			fflag = 1;
			break;
		case 'F':
			Fflag = 1;
			break;
		case 'm':
			mobile_node = 1;
			break;
		case '1':
			once = 1;
			break;
#ifndef SMALL
		case 'O':
			otherconf_script = optarg;
			break;
#endif
		default:
			usage(argv0);
			/*NOTREACHED*/
		}
	}
	argc -= optind;
	argv += optind;

	if ((!aflag && argc == 0) || (aflag && argc != 0)) {
		usage(argv0);
		/*NOTREACHED*/
	}

	/* set log level */
	if (dflag == 0)
		log_upto = LOG_NOTICE;
	if (!fflag) {
		char *ident;

		ident = strrchr(argv0, '/');
		if (!ident)
			ident = argv0;
		else
			ident++;
		openlog(ident, LOG_NDELAY|LOG_PID, LOG_DAEMON);
		if (log_upto >= 0)
			setlogmask(LOG_UPTO(log_upto));
	}

#ifndef SMALL
	if (otherconf_script && *otherconf_script != '/') {
		errx(1, "configuration script (%s) must be an absolute path",
		    otherconf_script);
	}
#endif

	if (Fflag)
		setinet6sysctl(IPPROTO_IPV6, IPV6CTL_FORWARDING, 0);
	else {
		/* warn if forwarding is up */
		if (getinet6sysctl(IPPROTO_IPV6, IPV6CTL_FORWARDING))
			warnx("kernel is configured as a router, not a host");
	}

#ifndef SMALL
	/* initialization to dump internal status to a file */
	signal(SIGUSR1, rtsold_set_dump_file);
#endif

	if (!fflag)
		daemon(0, 0);		/* act as a daemon */

	if (aflag)
		rdomain = getrtable();
	else
		rdomain = get_rdomain(*argv);

	/*
	 * Open a socket for sending RS and receiving RA.
	 * This should be done before calling ifinit(), since the function
	 * uses the socket.
	 */
	if ((s = sockopen(rdomain)) < 0) {
		warnmsg(LOG_ERR, __func__, "failed to open a socket");
		exit(1);
		/*NOTREACHED*/
	}
	set[0].fd = s;
	set[0].events = POLLIN;

	set[1].fd = -1;

	/* configuration per interface */
	if (ifinit()) {
		warnmsg(LOG_ERR, __func__,
		    "failed to initialize interfaces");
		exit(1);
		/*NOTREACHED*/
	}
	if (aflag) {
		argv = autoifprobe(rdomain);
	} else {
		warnmsg(LOG_DEBUG, __func__, "setting rdomain %u", rdomain);
		setrtable(rdomain);
	}
	while (argv && *argv) {
		if (ifconfig(*argv)) {
			warnmsg(LOG_ERR, __func__,
			    "failed to initialize %s", *argv);
			exit(1);
			/*NOTREACHED*/
		}
		argv++;
	}

	/* setup for probing default routers */
	if (probe_init()) {
		warnmsg(LOG_ERR, __func__,
		    "failed to setup for probing routers");
		exit(1);
		/*NOTREACHED*/
	}

	while (1) {		/* main loop */
		int e;


#ifndef SMALL
		if (do_dump) {	/* SIGUSR1 */
			do_dump = 0;
			rtsold_dump_file(dumpfilename);
		}
#endif

		timeout = rtsol_check_timer();

		if (once) {
			struct ifinfo *ifi;

			/* if we have no timeout, we are done (or failed) */
			if (timeout == NULL)
				break;

			/* if all interfaces have got RA packet, we are done */
			for (ifi = iflist; ifi; ifi = ifi->next) {
				if (ifi->state != IFS_DOWN && ifi->racnt == 0)
					break;
			}
			if (ifi == NULL)
				break;
		}
		e = poll(set, 2, timeout ? (timeout->tv_sec * 1000 + timeout->tv_usec / 1000) : INFTIM);
		if (e < 1) {
			if (e < 0 && errno != EINTR) {
				warnmsg(LOG_ERR, __func__, "select: %s",
				    strerror(errno));
			}
			continue;
		}

		/* packet reception */
		if (set[0].revents & POLLIN)
			rtsol_input(s);
	}
	/* NOTREACHED */

	return 0;
}

int
ifconfig(char *ifname)
{
	struct ifinfo *ifinfo;
	struct sockaddr_dl *sdl;
	int flags;

	if ((sdl = if_nametosdl(ifname)) == NULL) {
		warnmsg(LOG_ERR, __func__,
		    "failed to get link layer information for %s", ifname);
		return(-1);
	}
	if (find_ifinfo(sdl->sdl_index)) {
		warnmsg(LOG_ERR, __func__,
		    "interface %s was already configured", ifname);
		free(sdl);
		return(-1);
	}

	if ((ifinfo = calloc(1, sizeof(*ifinfo))) == NULL) {
		warnmsg(LOG_ERR, __func__, "memory allocation failed");
		free(sdl);
		return(-1);
	}
	ifinfo->sdl = sdl;

	strncpy(ifinfo->ifname, ifname, sizeof(ifinfo->ifname));

	/* construct a router solicitation message */
	if (make_packet(ifinfo))
		goto bad;

	/* set link ID of this interface. */
#ifdef HAVE_SCOPELIB
	if (inet_zoneid(AF_INET6, 2, ifname, &ifinfo->linkid))
		goto bad;
#else
	/* XXX: assume interface IDs as link IDs */
	ifinfo->linkid = ifinfo->sdl->sdl_index;
#endif

	/*
	 * check if the interface is available.
	 * also check if SIOCGIFMEDIA ioctl is OK on the interface.
	 */
	ifinfo->mediareqok = 1;
	ifinfo->active = interface_status(ifinfo);
	if (!ifinfo->mediareqok) {
		/*
		 * probe routers periodically even if the link status
		 * does not change.
		 */
		ifinfo->probeinterval = PROBE_INTERVAL;
	}

	/* activate interface: interface_up returns 0 on success */
	flags = interface_up(ifinfo->ifname);
	if (flags == 0)
		ifinfo->state = IFS_DELAY;
	else if (flags == IFS_TENTATIVE)
		ifinfo->state = IFS_TENTATIVE;
	else
		ifinfo->state = IFS_DOWN;

	rtsol_timer_update(ifinfo);

	/* link into chain */
	if (iflist)
		ifinfo->next = iflist;
	iflist = ifinfo;

	return(0);

bad:
	free(ifinfo->sdl);
	free(ifinfo);
	return(-1);
}

#if 0
static int
ifreconfig(char *ifname)
{
	struct ifinfo *ifi, *prev;
	int rv;

	prev = NULL;
	for (ifi = iflist; ifi; ifi = ifi->next) {
		if (strncmp(ifi->ifname, ifname, sizeof(ifi->ifname)) == 0)
			break;
		prev = ifi;
	}
	prev->next = ifi->next;

	rv = ifconfig(ifname);

	/* reclaim it after ifconfig() in case ifname is pointer inside ifi */
	if (ifi->rs_data)
		free(ifi->rs_data);
	free(ifi->sdl);
	free(ifi);
	return rv;
}
#endif

struct ifinfo *
find_ifinfo(int ifindex)
{
	struct ifinfo *ifi;

	for (ifi = iflist; ifi; ifi = ifi->next)
		if (ifi->sdl->sdl_index == ifindex)
			return(ifi);
	return(NULL);
}

static int
make_packet(struct ifinfo *ifinfo)
{
	size_t packlen = sizeof(struct nd_router_solicit), lladdroptlen = 0;
	struct nd_router_solicit *rs;
	char *buf;

	if ((lladdroptlen = lladdropt_length(ifinfo->sdl)) == 0) {
		warnmsg(LOG_INFO, __func__,
		    "link-layer address option has null length"
		    " on %s. Treat as not included.", ifinfo->ifname);
	}
	packlen += lladdroptlen;
	ifinfo->rs_datalen = packlen;

	/* allocate buffer */
	if ((buf = malloc(packlen)) == NULL) {
		warnmsg(LOG_ERR, __func__,
		    "memory allocation failed for %s", ifinfo->ifname);
		return(-1);
	}
	ifinfo->rs_data = buf;

	/* fill in the message */
	rs = (struct nd_router_solicit *)buf;
	rs->nd_rs_type = ND_ROUTER_SOLICIT;
	rs->nd_rs_code = 0;
	rs->nd_rs_cksum = 0;
	rs->nd_rs_reserved = 0;
	buf += sizeof(*rs);

	/* fill in source link-layer address option */
	if (lladdroptlen)
		lladdropt_fill(ifinfo->sdl, (struct nd_opt_hdr *)buf);

	return(0);
}

static struct timeval *
rtsol_check_timer(void)
{
	static struct timeval returnval;
	struct timeval now, rtsol_timer;
	struct ifinfo *ifinfo;
	int flags, timers;

	gettimeofday(&now, NULL);

	timers = 0;

	for (ifinfo = iflist; ifinfo; ifinfo = ifinfo->next) {
		if (!ifinfo->stoptimer && timercmp(&ifinfo->expire, &now, <=)) {
			if (dflag > 1)
				warnmsg(LOG_DEBUG, __func__,
				    "timer expiration on %s, "
				    "state = %d", ifinfo->ifname,
				    ifinfo->state);

			switch (ifinfo->state) {
			case IFS_DOWN:
			case IFS_TENTATIVE:
				/* interface_up returns 0 on success */
				flags = interface_up(ifinfo->ifname);
				if (flags == 0)
					ifinfo->state = IFS_DELAY;
				else if (flags == IFS_TENTATIVE)
					ifinfo->state = IFS_TENTATIVE;
				else
					ifinfo->state = IFS_DOWN;
				break;
			case IFS_IDLE:
			{
				int oldstatus = ifinfo->active;
				int probe = 0;

				ifinfo->active = interface_status(ifinfo);

				if (oldstatus != ifinfo->active) {
					warnmsg(LOG_DEBUG, __func__,
					    "%s status is changed"
					    " from %d to %d",
					    ifinfo->ifname,
					    oldstatus, ifinfo->active);
					probe = 1;
					ifinfo->state = IFS_DELAY;
				} else if (ifinfo->probeinterval &&
				    (ifinfo->probetimer -=
				    ifinfo->timer.tv_sec) <= 0) {
					/* probe timer expired */
					ifinfo->probetimer =
					    ifinfo->probeinterval;
					probe = 1;
					ifinfo->state = IFS_PROBE;
				}

#ifndef SMALL
				/*
				 * If we need a probe, clear the previous
				 * status wrt the "other" configuration.
				 */
				if (probe)
					ifinfo->otherconfig = 0;
#endif

				if (probe && mobile_node)
					defrouter_probe(ifinfo);
				break;
			}
			case IFS_DELAY:
				ifinfo->state = IFS_PROBE;
				sendpacket(ifinfo);
				break;
			case IFS_PROBE:
				if (ifinfo->probes < MAX_RTR_SOLICITATIONS)
					sendpacket(ifinfo);
				else {
					warnmsg(LOG_INFO, __func__,
					    "No answer after sending %d RSs",
					    ifinfo->probes);
					ifinfo->probes = 0;
					ifinfo->state = IFS_IDLE;
				}
				break;
			}
			rtsol_timer_update(ifinfo);
		}
		if (!ifinfo->stoptimer) {
			if (timers == 0)
				rtsol_timer = ifinfo->expire;
			else if (timercmp(&ifinfo->expire, &rtsol_timer, <))
				rtsol_timer = ifinfo->expire;
			timers++;
		}
	}

	if (timers == 0) {
		warnmsg(LOG_DEBUG, __func__, "there is no timer");
		return(NULL);
	} else if (timercmp(&rtsol_timer, &now, <))
		/* this may occur when the interval is too small */
		timerclear(&returnval);
	else
		timersub(&rtsol_timer, &now, &returnval);

	if (dflag > 1)
		warnmsg(LOG_DEBUG, __func__, "New timer is %lld:%08ld",
		    (long long)returnval.tv_sec, returnval.tv_usec);

	return(&returnval);
}

void
rtsol_timer_update(struct ifinfo *ifinfo)
{
#define MILLION 1000000
#define DADRETRY 10		/* XXX: adhoc */
	long interval;
	struct timeval now;

	bzero(&ifinfo->timer, sizeof(ifinfo->timer));
	ifinfo->stoptimer = 0;

	switch (ifinfo->state) {
	case IFS_DOWN:
	case IFS_TENTATIVE:
		if (++ifinfo->dadcount > DADRETRY) {
			ifinfo->dadcount = 0;
			ifinfo->timer.tv_sec = PROBE_INTERVAL;
		} else
			ifinfo->timer.tv_sec = 1;
		break;
	case IFS_IDLE:
		if (mobile_node) {
			/* XXX should be configurable */
			ifinfo->timer.tv_sec = 3;
		} else
			ifinfo->stoptimer = 1;
		break;
	case IFS_DELAY:
		interval = arc4random_uniform(MAX_RTR_SOLICITATION_DELAY *
		    MILLION);
		ifinfo->timer.tv_sec = interval / MILLION;
		ifinfo->timer.tv_usec = interval % MILLION;
		break;
	case IFS_PROBE:
		if (ifinfo->probes < MAX_RTR_SOLICITATIONS)
			ifinfo->timer.tv_sec = RTR_SOLICITATION_INTERVAL;
		else {
			/*
			 * After sending MAX_RTR_SOLICITATIONS solicitations,
			 * we're just waiting for possible replies; there
			 * will be no more solicitation.  Thus, we change
			 * the timer value to MAX_RTR_SOLICITATION_DELAY based
			 * on RFC 2461, Section 6.3.7.
			 */
			ifinfo->timer.tv_sec = MAX_RTR_SOLICITATION_DELAY;
		}
		break;
	default:
		warnmsg(LOG_ERR, __func__,
		    "illegal interface state(%d) on %s",
		    ifinfo->state, ifinfo->ifname);
		return;
	}

	/* reset the timer */
	if (ifinfo->stoptimer) {
		warnmsg(LOG_DEBUG, __func__,
		    "stop timer for %s", ifinfo->ifname);
	} else {
		gettimeofday(&now, NULL);
		timeradd(&now, &ifinfo->timer, &ifinfo->expire);

		if (dflag > 1)
			warnmsg(LOG_DEBUG, __func__,
			    "set timer for %s to %lld:%ld", ifinfo->ifname,
			    (long long)ifinfo->timer.tv_sec,
			    ifinfo->timer.tv_usec);
	}

#undef MILLION
}

/* timer related utility functions */
#define MILLION 1000000

#ifndef SMALL
static void
rtsold_set_dump_file(int sig)
{
	do_dump = 1;
}
#endif

static void
usage(char *progname)
{
	if (progname && progname[0] != '\0' && progname[strlen(progname) - 1] != 'd') {
		fprintf(stderr,
		    "usage: rtsol [-DdF] [-O script-name] interface ...\n"
		    "       rtsol [-DdF] -a\n");
	} else {
		fprintf(stderr,
		    "usage: rtsold [-1DdFfm] [-O script-name] interface ...\n"
		    "       rtsold [-1DdFfm] -a\n");
	}
	exit(1);
}

void
warnmsg(int priority, const char *func, const char *msg, ...)
{
	va_list ap;
	char buf[BUFSIZ];

	va_start(ap, msg);
	if (fflag) {
		if (priority <= log_upto) {
			(void)vfprintf(stderr, msg, ap);
			(void)fprintf(stderr, "\n");
		}
	} else {
		snprintf(buf, sizeof(buf), "<%s> %s", func, msg);
		msg = buf;
		vsyslog(priority, msg, ap);
	}
	va_end(ap);
}

/*
 * return a list of interfaces which is suitable to sending an RS.
 */
char **
autoifprobe(u_int rdomain)
{
	static char **argv = NULL;
	static int n = 0;
	char **a;
	int i, found;
	struct ifaddrs *ifap, *ifa, *target;

	/* initialize */
	while (n--)
		free(argv[n]);
	if (argv) {
		free(argv);
		argv = NULL;
	}
	n = 0;

	if (getifaddrs(&ifap) != 0)
		return NULL;

	target = NULL;
	/* find an ethernet */
	for (ifa = ifap; ifa; ifa = ifa->ifa_next) {
		if ((ifa->ifa_flags & IFF_UP) == 0)
			continue;
		if ((ifa->ifa_flags & IFF_POINTOPOINT) != 0)
			continue;
		if ((ifa->ifa_flags & IFF_LOOPBACK) != 0)
			continue;
		if ((ifa->ifa_flags & IFF_MULTICAST) == 0)
			continue;

		if (ifa->ifa_addr->sa_family != AF_INET6)
			continue;
		if (get_rdomain(ifa->ifa_name) != rdomain)
			continue;

		found = 0;
		for (i = 0; i < n; i++) {
			if (strcmp(argv[i], ifa->ifa_name) == 0) {
				found++;
				break;
			}
		}
		if (found)
			continue;

		/* if we find multiple candidates, just warn. */
		if (n != 0 && dflag > 1)
			warnx("multiple interfaces found");

		a = reallocarray(argv, n + 1, sizeof(char **));
		if (a == NULL)
			err(1, "realloc");
		argv = a;
		if ((argv[n] = strdup(ifa->ifa_name)) == NULL)
			err(1, "strdup");
		n++;
	}

	if (n) {
		a = reallocarray(argv, n + 1, sizeof(char **));
		if (a == NULL)
			err(1, "realloc");
		argv = a;
		argv[n] = NULL;

		if (dflag > 0) {
			for (i = 0; i < n; i++)
				warnx("probing %s", argv[i]);
		}
	}
	freeifaddrs(ifap);
	return argv;
}
@


1.54
log
@obvious realloc() -> reallocarray() conversions
ok doug
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsold.c,v 1.53 2014/08/27 14:04:16 florian Exp $	*/
@


1.53
log
@Nuke net.inet6.icmp6.rediraccept and allow redirects on interfaces
with autoconf enabled.
If one is doing SLAAC one does already trust link local icmp6 so the
policy for icmp6 redirects should be the same.
pointed out by & OK bluhm@@; OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsold.c,v 1.52 2014/07/11 16:44:13 henning Exp $	*/
d740 1
a740 1
		a = (char **)realloc(argv, (n + 1) * sizeof(char **));
d750 1
a750 1
		a = (char **)realloc(argv, (n + 1) * sizeof(char **));
@


1.52
log
@some say it is kinda likely you want autoconf if you run rtsol/rtsold on
a given interface, so turn AFXF_AUTOCONF6 on on it
ok bluhm stsp benno florian
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsold.c,v 1.50 2013/10/21 08:46:07 phessler Exp $	*/
d187 1
a187 2
	if (Fflag) {
		setinet6sysctl(IPPROTO_ICMPV6, ICMPV6CTL_REDIRACCEPT, 1);
d189 1
a189 4
	} else {
		/* warn if accepting redirects is off */
		if (!getinet6sysctl(IPPROTO_ICMPV6, ICMPV6CTL_REDIRACCEPT))
			warnx("kernel is configured not to accept redirects");
@


1.51
log
@malloc+memset -> calloc

from Benjamin Baier (programmer (at) netzbasis.de)
@
text
@a187 1
		setinet6sysctl(IPPROTO_IPV6, IPV6CTL_ACCEPT_RTADV, 1);
a190 3
		/* warn if accept_rtadv is down */
		if (!getinet6sysctl(IPPROTO_IPV6, IPV6CTL_ACCEPT_RTADV))
			warnx("kernel is configured not to accept RAs");
@


1.50
log
@Add rdomain support to IPv6 configuration tools

OK claudio@@ and bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsold.c,v 1.49 2013/04/21 19:42:32 florian Exp $	*/
d327 1
a327 1
	if ((ifinfo = malloc(sizeof(*ifinfo))) == NULL) {
a331 1
	memset(ifinfo, 0, sizeof(*ifinfo));
@


1.49
log
@IPv6 might still be around in 2038, replace magic timeval
{0x7fffffff, 0x7fffffff} with an explicit flag that timers should
be stopped.
input deraadt@@, kettenis@@
"Looks like a nice solution." deraadt@@
OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsold.c,v 1.48 2013/04/19 05:06:52 deraadt Exp $	*/
d105 1
d211 5
d221 1
a221 1
	if ((s = sockopen()) < 0) {
d238 6
a243 2
	if (aflag)
		argv = autoifprobe();
d698 1
a698 1
autoifprobe(void)
d731 2
@


1.48
log
@print tv_sec properly
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsold.c,v 1.47 2011/03/23 00:59:49 bluhm Exp $	*/
a59 1
struct timeval tm_max =	{0x7fffffff, 0x7fffffff};
d459 1
a459 1
	int flags;
d463 1
a463 1
	rtsol_timer = tm_max;
d466 1
a466 1
		if (timercmp(&ifinfo->expire, &now, <=)) {
d541 7
a547 3

		if (timercmp(&ifinfo->expire, &rtsol_timer, <))
			rtsol_timer = ifinfo->expire;
d550 1
a550 1
	if (timercmp(&rtsol_timer, &tm_max, ==)) {
d575 1
d591 1
a591 1
			ifinfo->timer = tm_max;	/* stop timer(valid?) */
d621 1
a621 2
	if (timercmp(&ifinfo->timer, &tm_max, ==)) {
		ifinfo->expire = tm_max;
@


1.47
log
@Print a warning when rtsol or rtsold are used to do IPv6 autoconfiguration
but accepting redirects is turned off.  If the -F switch is given,
set sysctl net.inet6.icmp6.rediraccept to 1 instead.
ok claudio@@ deraadt@@ sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsold.c,v 1.46 2011/03/22 10:16:23 okan Exp $	*/
d557 2
a558 2
		warnmsg(LOG_DEBUG, __func__, "New timer is %ld:%08ld",
		    (long)returnval.tv_sec, (long)returnval.tv_usec);
d627 3
a629 3
			    "set timer for %s to %d:%d", ifinfo->ifname,
			    (int)ifinfo->timer.tv_sec,
			    (int)ifinfo->timer.tv_usec);
@


1.46
log
@use timerclear macro

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsold.c,v 1.45 2009/01/30 17:25:51 rainer Exp $	*/
d188 3
a190 2
		setinet6sysctl(IPV6CTL_ACCEPT_RTADV, 1);
		setinet6sysctl(IPV6CTL_FORWARDING, 0);
d193 1
a193 1
		if (!getinet6sysctl(IPV6CTL_ACCEPT_RTADV))
d195 3
d199 1
a199 1
		if (getinet6sysctl(IPV6CTL_FORWARDING))
@


1.45
log
@Delete code which was never used (rtsock.c is even not there).

old commit message from itojun:
"rtsock.c is omitted for simplicity, as it is not meaningful on openbsd."

Ok grunk@@, naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsold.c,v 1.44 2008/08/13 17:24:54 sobrado Exp $	*/
d548 1
a548 1
		returnval.tv_sec = returnval.tv_usec = 0;
@


1.44
log
@sync synopsis/usage; fix double "usage:"; KNF.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsold.c,v 1.43 2008/06/12 16:12:31 jmc Exp $	*/
a108 3
#ifdef USE_RTSOCK
	int rtsock;
#endif
a221 10
#ifdef USE_RTSOCK
	if ((rtsock = rtsock_open()) < 0) {
		warnmsg(LOG_ERR, __func__, "failed to open a socket");
		exit(1);
		/*NOTREACHED*/
	}
	set[1].fd = rtsock;
	set[1].events = POLLIN;
#endif

a286 4
#ifdef USE_RTSOCK
		if (set[1].revents & POLLIN)
			rtsock_input(rtsock);
#endif
@


1.43
log
@let usage() match SYNOPSIS;
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsold.c,v 1.42 2008/06/10 04:49:11 reyk Exp $	*/
d663 3
a665 3
		fprintf(stderr, "usage: rtsol [-DdF] [-O script] "
		    "interface ...\n");
		fprintf(stderr, "usage: rtsol [-DdF] -a\n");
d667 3
a669 3
		fprintf(stderr, "usage: rtsold [-1DdFfm] [-O script] "
		    "interface ...\n");
		fprintf(stderr, "usage: rtsold [-1DdFfm] -a\n");
@


1.42
log
@add the -O option to run an external script when the "other
configuration" flag is found in the RA message. it basically means
"here is your IPv6 address, but run something like DHCPv6 to get more
information".  so the main purpose is to run a dhcpv6 client to get
DNS etc.

Merged from KAME

ok rainer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsold.c,v 1.41 2008/04/13 00:22:17 djm Exp $	*/
d665 1
a665 1
		fprintf(stderr, "usage: rtsol [-DdF] [-O script] -a\n");
d669 1
a669 1
		fprintf(stderr, "usage: rtsold [-1DdFfm] [-O script] -a\n");
@


1.41
log
@Use arc4random_buf() when requesting more than a single word of output

Use arc4random_uniform() when the desired random number upper bound
is not a power of two

ok deraadt@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsold.c,v 1.40 2008/01/05 17:03:09 chl Exp $	*/
d68 2
d122 1
a122 1
		opts = "adDF";
d124 1
a124 1
		opts = "adDfFm1";
d149 5
d183 7
d524 9
d663 3
a665 2
		fprintf(stderr, "usage: rtsol [-DdF] interface ...\n");
		fprintf(stderr, "usage: rtsol [-DdF] -a\n");
d667 3
a669 2
		fprintf(stderr, "usage: rtsold [-1DdFfm] interface ...\n");
		fprintf(stderr, "usage: rtsold [-1DdFfm] -a\n");
@


1.40
log
@remove unused function

initially from tobias@@, removed some unused prototypes too

"looks good to me" jaredy@@ ok tobias@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsold.c,v 1.39 2006/11/07 07:20:16 ray Exp $	*/
d580 2
a581 1
		interval = arc4random() % (MAX_RTR_SOLICITATION_DELAY * MILLION);
@


1.39
log
@Don't check buf[strlen(buf) - 1] for zero length strings.

OK jaredy@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsold.c,v 1.38 2005/10/28 08:06:39 jmc Exp $	*/
a91 1
void iflist_init(void);
a93 2
static void TIMEVAL_ADD(struct timeval *, struct timeval *, struct timeval *);
static void TIMEVAL_SUB(struct timeval *, struct timeval *, struct timeval *);
a375 16
}

void
iflist_init(void)
{
	struct ifinfo *ifi, *next;

	for (ifi = iflist; ifi; ifi = next) {
		next = ifi->next;
		if (ifi->sdl)
			free(ifi->sdl);
		if (ifi->rs_data)
			free(ifi->rs_data);
		free(ifi);
		iflist = NULL;
	}
@


1.38
log
@sync usage() with man page synopsis;
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsold.c,v 1.37 2005/06/09 00:27:12 deraadt Exp $	*/
d120 1
a120 1
	if (argv0 && argv0[strlen(argv0) - 1] != 'd') {
d657 1
a657 1
	if (progname && progname[strlen(progname) - 1] != 'd') {
@


1.37
log
@spelling
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsold.c,v 1.36 2004/01/05 20:35:52 itojun Exp $	*/
d658 2
a659 2
		fprintf(stderr, "usage: rtsol [-dDF] interfaces...\n");
		fprintf(stderr, "usage: rtsol [-dDF] -a\n");
d661 2
a662 2
		fprintf(stderr, "usage: rtsold [-adDfFm1] interfaces...\n");
		fprintf(stderr, "usage: rtsold [-dDfFm1] -a\n");
@


1.36
log
@add -F to usage()
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsold.c,v 1.35 2004/01/05 20:32:50 itojun Exp $	*/
d68 1
a68 1
/* protocol constatns */
d227 1
a227 1
		    "failed to initilizatoin interfaces");
d610 1
a610 1
			 * will be no more solicatation.  Thus, we change
@


1.35
log
@add -F option, which sets sysctl(8) variables rather than warn(3) about the
current setting.  basically for boot floppy.  req'ed by fries@@. deraadt@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsold.c,v 1.34 2004/01/03 06:20:17 itojun Exp $	*/
d658 2
a659 2
		fprintf(stderr, "usage: rtsol [-dD] interfaces...\n");
		fprintf(stderr, "usage: rtsol [-dD] -a\n");
d661 2
a662 2
		fprintf(stderr, "usage: rtsold [-adDfm1] interfaces...\n");
		fprintf(stderr, "usage: rtsold [-dDfm1] -a\n");
@


1.34
log
@do not create pid file.  it was just for debugging and there was no proper
cleanup code.  from kame
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsold.c,v 1.33 2004/01/02 23:52:17 itojun Exp $	*/
d63 1
d123 1
a123 1
		opts = "adD";
d125 1
a125 1
		opts = "adDfm1";
d141 3
d179 11
a189 6
	/* warn if accept_rtadv is down */
	if (!getinet6sysctl(IPV6CTL_ACCEPT_RTADV))
		warnx("kernel is configured not to accept RAs");
	/* warn if forwarding is up */
	if (getinet6sysctl(IPV6CTL_FORWARDING))
		warnx("kernel is configured as a router, not a host");
@


1.33
log
@factor out dump.c from rtsol by -DSMALL
@
text
@d1 2
a2 2
/*	$OpenBSD: rtsold.c,v 1.32 2004/01/02 23:46:04 itojun Exp $	*/
/*	$KAME: rtsold.c,v 1.57 2002/09/20 21:59:55 itojun Exp $	*/
d61 3
a65 2
static int log_upto = 999;
static int fflag = 0;
d72 5
a76 13
/* implementation dependent constants */
#define PROBE_INTERVAL 60	/* secondes XXX: should be configurable */

/* utility macros */
/* a < b */
#define TIMEVAL_LT(a, b) (((a).tv_sec < (b).tv_sec) ||\
			  (((a).tv_sec == (b).tv_sec) && \
			    ((a).tv_usec < (b).tv_usec)))

/* a <= b */
#define TIMEVAL_LEQ(a, b) (((a).tv_sec < (b).tv_sec) ||\
			   (((a).tv_sec == (b).tv_sec) &&\
			    ((a).tv_usec <= (b).tv_usec)))
d78 1
a78 2
/* a == b */
#define TIMEVAL_EQ(a, b) (((a).tv_sec==(b).tv_sec) && ((a).tv_usec==(b).tv_usec))
a241 9
	/* dump the current pid */
	if (!once) {
		if (pidfile(NULL) < 0) {
			warnmsg(LOG_ERR, __func__,
			    "failed to open a pid log file: %s",
			    strerror(errno));
		}
	}

d476 1
a476 1
		if (TIMEVAL_LEQ(ifinfo->expire, now)) {
d543 1
a543 1
		if (TIMEVAL_LT(ifinfo->expire, rtsol_timer))
d547 1
a547 1
	if (TIMEVAL_EQ(rtsol_timer, tm_max)) {
d550 1
a550 1
	} else if (TIMEVAL_LT(rtsol_timer, now))
d554 1
a554 1
		TIMEVAL_SUB(&rtsol_timer, &now, &returnval);
d616 1
a616 1
	if (TIMEVAL_EQ(ifinfo->timer, tm_max)) {
d622 1
a622 1
		TIMEVAL_ADD(&now, &ifinfo->timer, &ifinfo->expire);
a635 33

/* result = a + b */
static void
TIMEVAL_ADD(struct timeval *a, struct timeval *b, struct timeval *result)
{
	long l;

	if ((l = a->tv_usec + b->tv_usec) < MILLION) {
		result->tv_usec = l;
		result->tv_sec = a->tv_sec + b->tv_sec;
	} else {
		result->tv_usec = l - MILLION;
		result->tv_sec = a->tv_sec + b->tv_sec + 1;
	}
}

/*
 * result = a - b
 * XXX: this function assumes that a >= b.
 */
void
TIMEVAL_SUB(struct timeval *a, struct timeval *b, struct timeval *result)
{
	long l;

	if ((l = a->tv_usec - b->tv_usec) >= 0) {
		result->tv_usec = l;
		result->tv_sec = a->tv_sec - b->tv_sec;
	} else {
		result->tv_usec = MILLION + l;
		result->tv_sec = a->tv_sec - b->tv_sec - 1;
	}
}
@


1.32
log
@unifdef for readability.  req'ed by deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsold.c,v 1.31 2003/07/07 00:18:30 deraadt Exp $	*/
d90 1
d93 1
d105 1
d107 1
d190 1
d193 1
d263 1
d268 1
d687 1
d693 1
@


1.31
log
@protos
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsold.c,v 1.30 2003/06/25 21:10:33 deraadt Exp $	*/
a54 1
#ifdef HAVE_POLL_H
a55 1
#endif
a111 1
#ifdef HAVE_POLL_H
a112 5
#else
	fd_set *fdsetp, *selectfdp;
	int fdmasks;
	int maxfd;
#endif
a178 5
#ifndef HAVE_ARC4RANDOM
	/* random value initilization */
	srandom((u_long)time(NULL));
#endif

a201 1
#ifdef HAVE_POLL_H
a203 3
#else
	maxfd = s;
#endif
a204 1
#ifdef HAVE_POLL_H
a205 1
#endif
a212 1
#ifdef HAVE_POLL_H
a214 16
#else
	if (rtsock > maxfd)
		maxfd = rtsock;
#endif
#endif

#ifndef HAVE_POLL_H
	fdmasks = howmany(maxfd + 1, NFDBITS) * sizeof(fd_mask);
	if ((fdsetp = malloc(fdmasks)) == NULL) {
		err(1, "malloc");
		/*NOTREACHED*/
	}
	if ((selectfdp = malloc(fdmasks)) == NULL) {
		err(1, "malloc");
		/*NOTREACHED*/
	}
a252 7
#ifndef HAVE_POLL_H
	memset(fdsetp, 0, fdmasks);
	FD_SET(s, fdsetp);
#ifdef USE_RTSOCK
	FD_SET(rtsock, fdsetp);
#endif
#endif
a255 3
#ifndef HAVE_POLL_H
		memcpy(selectfdp, fdsetp, fdmasks);
#endif
a278 1
#ifdef HAVE_POLL_H
a279 3
#else
		e = select(maxfd + 1, selectfdp, NULL, NULL, timeout);
#endif
a289 1
#ifdef HAVE_POLL_H
a290 3
#else
		if (FD_ISSET(rtsock, selectfdp))
#endif
a292 1
#ifdef HAVE_POLL_H
a293 3
#else
		if (FD_ISSET(s, selectfdp))
#endif
a598 3
#ifndef HAVE_ARC4RANDOM
		interval = random() % (MAX_RTR_SOLICITATION_DELAY * MILLION);
#else
a599 1
#endif
@


1.30
log
@protos
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsold.c,v 1.29 2003/05/15 14:40:53 itojun Exp $	*/
d98 2
@


1.29
log
@make getifaddrs(3) a default, as all BSD has it by now
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsold.c,v 1.28 2003/03/13 22:26:52 millert Exp $	*/
d107 1
a107 3
main(argc, argv)
	int argc;
	char **argv;
d438 1
a438 1
iflist_init()
d529 1
a529 1
rtsol_check_timer()
d782 1
a782 1
autoifprobe()
@


1.28
log
@Use strdup() instead of doing it by hand; deraadt@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsold.c,v 1.27 2003/03/13 09:09:50 deraadt Exp $	*/
a785 3
#ifndef HAVE_GETIFADDRS
	errx(1, "-a is not available with the configuration");
#else
a855 1
#endif
@


1.27
log
@lots of sprintf -> snprintf and strcpy -> strlcpy; checked by tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsold.c,v 1.26 2002/10/26 20:23:20 itojun Exp $	*/
d792 1
a792 1
	int i, found, len;
d840 2
a841 5
		len = 1 + strlen(ifa->ifa_name);
		argv[n] = (char *)malloc(len);
		if (!argv[n])
			err(1, "malloc");
		strlcpy(argv[n], ifa->ifa_name, len);
@


1.26
log
@use poll(2).  sync w/kame
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsold.c,v 1.25 2002/09/08 01:33:35 itojun Exp $	*/
d792 1
a792 1
	int i, found;
d840 2
a841 1
		argv[n] = (char *)malloc(1 + strlen(ifa->ifa_name));
d844 1
a844 1
		strcpy(argv[n], ifa->ifa_name);
@


1.25
log
@signal handler must take "int" arg.  from deraadt.  sync w/kame
@
text
@d1 2
a2 2
/*	$OpenBSD: rtsold.c,v 1.24 2002/06/10 19:57:35 espie Exp $	*/
/*	$KAME: rtsold.c,v 1.55 2002/09/08 01:26:03 itojun Exp $	*/
d55 3
d111 1
a111 1
	int s, maxfd, ch, once = 0;
d114 3
d119 2
d215 4
d220 6
d232 4
d239 1
d241 1
d251 1
d289 1
d295 1
d299 1
d301 1
d325 3
d329 1
d340 3
d344 1
d347 3
d351 1
@


1.24
log
@Kill __FUNCTION__.
ok itojun@@
@
text
@d1 2
a2 2
/*	$OpenBSD: rtsold.c,v 1.23 2002/05/31 22:09:14 itojun Exp $	*/
/*	$KAME: rtsold.c,v 1.51 2002/05/31 22:00:11 itojun Exp $	*/
d100 1
a100 1
static void rtsold_set_dump_file(void);
d192 1
a192 4
	if (signal(SIGUSR1, (void *)rtsold_set_dump_file) < 0) {
		errx(1, "failed to set signal for dump status");
		/*NOTREACHED*/
	}
d701 1
a701 1
rtsold_set_dump_file()
@


1.23
log
@remove unused portion of code (pidfile(3) alternative)
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsold.c,v 1.22 2002/05/31 22:05:16 itojun Exp $	*/
d206 1
a206 1
		warnmsg(LOG_ERR, __FUNCTION__, "failed to open a socket");
d213 1
a213 1
		warnmsg(LOG_ERR, __FUNCTION__, "failed to open a socket");
d233 1
a233 1
		warnmsg(LOG_ERR, __FUNCTION__,
d242 1
a242 1
			warnmsg(LOG_ERR, __FUNCTION__,
d252 1
a252 1
		warnmsg(LOG_ERR, __FUNCTION__,
d261 1
a261 1
			warnmsg(LOG_ERR, __FUNCTION__,
d302 1
a302 1
				warnmsg(LOG_ERR, __FUNCTION__, "select: %s",
d329 1
a329 1
		warnmsg(LOG_ERR, __FUNCTION__,
d334 1
a334 1
		warnmsg(LOG_ERR, __FUNCTION__,
d341 1
a341 1
		warnmsg(LOG_ERR, __FUNCTION__, "memory allocation failed");
d462 1
a462 1
		warnmsg(LOG_INFO, __FUNCTION__,
d471 1
a471 1
		warnmsg(LOG_ERR, __FUNCTION__,
d507 1
a507 1
				warnmsg(LOG_DEBUG, __FUNCTION__,
d532 1
a532 1
					warnmsg(LOG_DEBUG, __FUNCTION__,
d561 1
a561 1
					warnmsg(LOG_INFO, __FUNCTION__,
d577 1
a577 1
		warnmsg(LOG_DEBUG, __FUNCTION__, "there is no timer");
d586 1
a586 1
		warnmsg(LOG_DEBUG, __FUNCTION__, "New timer is %ld:%08ld",
d642 1
a642 1
		warnmsg(LOG_ERR, __FUNCTION__,
d651 1
a651 1
		warnmsg(LOG_DEBUG, __FUNCTION__,
d658 1
a658 1
			warnmsg(LOG_DEBUG, __FUNCTION__,
@


1.22
log
@plug fd_set overrun
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsold.c,v 1.21 2002/05/31 21:24:28 itojun Exp $	*/
a259 1
#if (defined(__NetBSD__) && __NetBSD_Version__ >= 106010000) || defined(__OpenBSD__)
a264 13
#else
		pid_t pid = getpid();
		FILE *fp;

		if ((fp = fopen(pidfilename, "w")) == NULL)
			warnmsg(LOG_ERR, __FUNCTION__,
			    "failed to open a pid log file(%s): %s",
			    pidfilename, strerror(errno));
		else {
			fprintf(fp, "%d\n", pid);
			fclose(fp);
		}
#endif
@


1.21
log
@sync w/ latest kame.  link id handling.
@
text
@d1 2
a2 2
/*	$OpenBSD: rtsold.c,v 1.20 2002/05/31 10:11:14 itojun Exp $	*/
/*	$KAME: rtsold.c,v 1.49 2002/05/31 10:19:46 itojun Exp $	*/
d111 3
a113 2
	fd_set fdset;
#if 0
d211 1
a211 1
#if 0
d221 10
d260 1
d266 13
d281 4
a284 4
	FD_ZERO(&fdset);
	FD_SET(s, &fdset);
#if 0
	FD_SET(rtsock, &fdset);
a286 1
		fd_set select_fd = fdset;
d289 2
d313 1
a313 1
		e = select(maxfd + 1, &select_fd, NULL, NULL, timeout);
d323 2
a324 2
#if 0
		if (FD_ISSET(rtsock, &select_fd))
d327 1
a327 1
		if (FD_ISSET(s, &select_fd))
@


1.20
log
@function prototypes shoulnd't carry variable name
@
text
@d1 2
a2 2
/*	$OpenBSD: rtsold.c,v 1.19 2002/05/31 09:53:26 deraadt Exp $	*/
/*	$KAME: rtsold.c,v 1.32 2001/07/09 22:34:07 itojun Exp $	*/
d36 1
a91 1
static int ifconfig(char *);
a101 1
static char **autoifprobe(void);
d106 1
a106 1
	char *argv[];
d108 1
a108 1
	int s, maxfd, ch, once = 0, i;
d157 1
a157 17
	if (aflag) {
		if (argc != 0) {
			usage(argv0);
			/*NOTREACHED*/
		}

		argv = autoifprobe();
		if (!argv) {
			errx(1, "could not autoprobe interface");
			/*NOTREACHED*/
		}

		for (i = 0; argv[i]; i++)
			;
		argc = i;
	}
	if (argc == 0) {
d227 3
a229 1
	while (argc--) {
d309 1
a309 1
static int
d342 9
d389 16
d538 1
a538 1
					defrouter_probe(ifinfo->sdl->sdl_index);
d730 4
a733 1
static char **
d739 4
a742 2
	static char ifname[IFNAMSIZ + 1];
	static char *argv[2];
d745 9
d772 8
a779 1
		if (target && strcmp(target->ifa_name, ifa->ifa_name) == 0)
d782 25
a806 8
		if (!target)
			target = ifa;
		else {
			/* if we find multiple candidates, failure. */
			if (dflag > 1)
				warnx("multiple interfaces found");
			target = NULL;
			break;
a808 10

	if (target) {
		strncpy(ifname, target->ifa_name, sizeof(ifname) - 1);
		ifname[sizeof(ifname) - 1] = '\0';
		argv[0] = ifname;
		argv[1] = NULL;

		if (dflag > 0)
			warnx("probing %s", argv[0]);
	}
d810 1
a810 4
	if (target)
		return argv;
	else
		return (char **)NULL;
@


1.19
log
@KNF; itojun ok
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsold.c,v 1.18 2002/03/25 20:46:49 deraadt Exp $	*/
d91 1
a91 1
static int ifconfig(char *ifname);
d93 1
a93 1
static int ifreconfig(char *ifname);
d95 1
a95 1
static int make_packet(struct ifinfo *ifinfo);
d97 2
a98 4
static void TIMEVAL_ADD(struct timeval *a, struct timeval *b,
    struct timeval *result);
static void TIMEVAL_SUB(struct timeval *a, struct timeval *b,
    struct timeval *result);
d101 1
a101 1
static void usage(char *progname);
@


1.18
log
@spelling
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsold.c,v 1.17 2002/02/19 19:39:40 millert Exp $	*/
d81 1
a81 1
 			    ((a).tv_usec <= (b).tv_usec)))
a85 2
int main(int argc, char *argv[]);

d111 4
a114 1
	int s, maxfd, ch;
a117 5
	int once = 0;
	struct timeval *timeout;
	fd_set fdset;
	char *argv0;
	char *opts;
a160 2
		int i;

d186 1
d268 2
a269 2
				"failed to open a pid log file: %s",
				strerror(errno));
d279 1
a280 1
		fd_set select_fd = fdset;
d286 1
a286 1
			
d308 1
a308 1
				       strerror(errno));
d335 1
a335 1
		       "failed to get link layer information for %s", ifname);
d340 1
a340 1
			"interface %s was already configured", ifname);
d391 1
a391 1
  bad:
a418 1

a430 1

d437 2
a439 2
	struct nd_router_solicit *rs;
	size_t packlen = sizeof(struct nd_router_solicit), lladdroptlen = 0;
d443 2
a444 2
			"link-layer address option has null length"
		       " on %s. Treat as not included.", ifinfo->ifname);
d452 1
a452 1
			"memory allocation failed for %s", ifinfo->ifname);
d488 3
a490 3
					"timer expiration on %s, "
				       "state = %d", ifinfo->ifname,
				       ifinfo->state);
d509 1
a509 2
				ifinfo->active =
					interface_status(ifinfo);
d513 4
a516 4
						"%s status is changed"
						" from %d to %d",
						ifinfo->ifname,
						oldstatus, ifinfo->active);
d519 3
a521 4
				}
				else if (ifinfo->probeinterval &&
					 (ifinfo->probetimer -=
					  ifinfo->timer.tv_sec) <= 0) {
d524 1
a524 1
						ifinfo->probeinterval;
d542 2
a543 3
						"No answer "
						"after sending %d RSs",
						ifinfo->probes);
d559 1
a559 2
	}
	else if (TIMEVAL_LT(rtsol_timer, now))
d567 1
a567 1
			(long)returnval.tv_sec, (long)returnval.tv_usec);
d588 1
a588 2
		}
		else
d593 1
a593 1
			/* XXX should be configurable */ 
d595 1
a595 2
		}
		else
d623 2
a624 2
			"illegal interface state(%d) on %s",
			ifinfo->state, ifinfo->ifname);
d632 2
a633 3
			"stop timer for %s", ifinfo->ifname);
	}
	else {
d639 3
a641 3
				"set timer for %s to %d:%d", ifinfo->ifname,
			       (int)ifinfo->timer.tv_sec,
			       (int)ifinfo->timer.tv_usec);
d659 1
a659 2
	}
	else {
d677 1
a677 2
	}
	else {
@


1.17
log
@We live in an ANSI C world.  Remove lots of gratuitous #ifdef __STDC__ cruft.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsold.c,v 1.16 2002/02/17 19:42:39 millert Exp $	*/
d345 1
a345 1
			"interface %s was already cofigured", ifname);
@


1.16
log
@Manual cleanup of remaining userland __P use (excluding packages maintained outside the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsold.c,v 1.15 2002/02/16 21:28:09 millert Exp $	*/
a718 1
#if __STDC__
a719 7
#else
warnmsg(priority, func, msg, va_alist)
	int priority;
	const char *func;
	const char *msg;
	va_dcl
#endif
@


1.15
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsold.c,v 1.14 2002/01/11 03:51:08 itojun Exp $	*/
d99 4
a102 4
static void TIMEVAL_ADD __P((struct timeval *a, struct timeval *b,
			     struct timeval *result));
static void TIMEVAL_SUB __P((struct timeval *a, struct timeval *b,
			     struct timeval *result));
@


1.14
log
@call daemon(3) prior to socket setups to avoid file descriptor close mistakes.
noted by markus, sync with kame
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsold.c,v 1.13 2001/12/01 23:27:24 miod Exp $	*/
d86 1
a86 1
int main __P((int argc, char *argv[]));
d93 1
a93 1
static int ifconfig __P((char *ifname));
d95 1
a95 1
static int ifreconfig __P((char *ifname));
d97 2
a98 2
static int make_packet __P((struct ifinfo *ifinfo));
static struct timeval *rtsol_check_timer __P((void));
d104 3
a106 3
static void rtsold_set_dump_file __P((void));
static void usage __P((char *progname));
static char **autoifprobe __P((void));
@


1.13
log
@Use pidfile() instead of doing the equivalent thing by hand, and sometimes
forgetting to unlink the pid file at exit.
ok millert@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsold.c,v 1.12 2001/12/01 19:27:28 deraadt Exp $	*/
d220 3
d229 2
a230 1
		errx(1, "failed to open a socket");
d236 2
a237 1
		errx(1, "failed to open a socket");
d246 3
a248 1
		errx(1, "failed to initilizatoin interfaces");
d253 3
a255 1
			errx(1, "failed to initialize %s", *argv);
d263 3
a265 1
		errx(1, "failed to setup for probing routers");
a267 3

	if (!fflag)
		daemon(0, 0);		/* act as a daemon */
@


1.12
log
@fd_set, not struct fd_set
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsold.c,v 1.11 2001/11/17 19:49:40 deraadt Exp $	*/
d53 2
a91 1
static char *pidfilename = "/var/run/rtsold.pid"; /* should be configurable */
d263 1
a263 4
		pid_t pid = getpid();
		FILE *fp;

		if ((fp = fopen(pidfilename, "w")) == NULL)
d265 2
a266 5
				"failed to open a log file(%s): %s",
				pidfilename, strerror(errno));
		else {
			fprintf(fp, "%d\n", pid);
			fclose(fp);
@


1.11
log
@use volatile sig_atomic_t where possible; simply volatile i other places
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsold.c,v 1.10 2001/07/09 22:37:33 itojun Exp $	*/
d118 1
a118 1
	struct fd_set fdset;
d282 1
a282 1
		struct fd_set select_fd = fdset;
@


1.10
log
@sync with latest kame.
- a memory leak
- correct timer value
- wording fixes in manpage
rtsock.c is omitted for simplicity, as it is not meaningful on openbsd.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsold.c,v 1.9 2000/10/06 02:46:58 itojun Exp $	*/
d88 1
a88 1
static int do_dump;
@


1.9
log
@printf string format audit.  from: sommerfeld@@netbsd.org
@
text
@d1 2
a2 2
/*	$OpenBSD: rtsold.c,v 1.8 2000/08/13 18:24:00 itojun Exp $	*/
/*	$KAME: rtsold.c,v 1.27 2000/10/05 22:20:39 itojun Exp $	*/
d112 4
a115 1
	int s, ch;
d228 9
d277 3
d306 2
a307 2

		if ((e = select(s + 1, &select_fd, NULL, NULL, timeout)) < 1) {
d316 5
a320 1
		if (FD_ISSET(s, &fdset))
d618 12
a629 1
		ifinfo->timer.tv_sec = RTR_SOLICITATION_INTERVAL;
@


1.8
log
@add "rtsol -a" (automatically lookup outgoign interface).
warn if net.inet6.ip6.forwarding == 1.
improve manpage.
use $KAME$ for KAME tags.

sync with kame.
@
text
@d1 2
a2 2
/*	$OpenBSD: rtsold.c,v 1.7 2000/02/25 10:32:21 itojun Exp $	*/
/*	$KAME: rtsold.c,v 1.26 2000/08/13 18:17:15 itojun Exp $	*/
d255 1
a255 1
				"failed to open a log file(%s)",
d555 2
a556 2
		warnmsg(LOG_DEBUG, __FUNCTION__, "New timer is %d:%08d",
		       returnval.tv_sec, returnval.tv_usec);
d707 2
a708 1
		vsyslog(priority, buf, ap);
@


1.7
log
@use getifaddrs, not SIOCGIFCONF for LP64 align issue. (sync with kame).
@
text
@d1 2
a2 1
/*	$OpenBSD: rtsold.c,v 1.6 2000/02/01 03:24:11 deraadt Exp $	*/
d52 1
d57 2
a58 1
int dflag;
d105 1
d128 1
a128 1
		opts = "dD";
d130 1
a130 1
		opts = "dDfm1";
d133 22
a154 18
		switch(ch) {
		 case 'd':
			 dflag = 1;
			 break;
		 case 'D':
			 dflag = 2;
			 break;
		 case 'f':
			 fflag = 1;
			 break;
		 case 'm':
			 mobile_node = 1;
			 break;
		 case '1':
			 once = 1;
			 break;
		 default:
			 usage(argv0);
d159 20
a178 1
	if (argc == 0)
d180 2
d206 3
d211 1
a211 1
	if (signal(SIGUSR1, (void *)rtsold_set_dump_file) < 0)
d213 2
d221 1
a221 1
	if ((s = sockopen()) < 0)
d223 2
d227 1
a227 1
	if (ifinit())
d229 2
d232 1
a232 1
		if (ifconfig(*argv))
d234 2
d240 1
a240 1
	if (probe_init())
d242 2
d477 1
a477 1
			switch(ifinfo->state) {
d675 7
a681 4
	if (progname && progname[strlen(progname) - 1] != 'd')
		fprintf(stderr, "usage: rtsol [-dD] interfaces\n");
	else
		fprintf(stderr, "usage: rtsold [-dDfm1] interfaces\n");
d710 59
@


1.6
log
@no need to extern int errno if errno.h is included
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsold.c,v 1.5 2000/01/17 16:33:49 itojun Exp $	*/
d34 1
d36 1
d90 3
d169 5
d282 1
d288 1
d333 1
a334 1
	free(ifinfo->sdl);
d338 27
d548 3
d552 1
@


1.5
log
@sync with latest kame.  previous version leaves an udp socket opened
(for use with ioctls) and it was not a pleasant thing.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsold.c,v 1.4 1999/12/16 03:13:46 deraadt Exp $	*/
a213 1
		extern int errno;
@


1.4
log
@deposit dump file in /var/run; markus
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsold.c,v 1.2 1999/12/09 15:10:49 itojun Exp $	*/
d172 8
d185 1
a185 1
			errx(1, "failed to initilize %s", *argv);
a187 4

	/* open a socket for sending RS and receiving RA */
	if ((s = sockopen()) < 0)
		errx(1, "failed to open a socket");
@


1.3
log
@use arc4random()
@
text
@d84 1
a84 1
static char *dumpfilename = "/var/tmp/rtsold.dump"; /* XXX: should be configurable */
@


1.2
log
@rtsold(8); router solicitation daemon.
rtsol(8); router solicitation program, for use in bootstrap process
(statically linked)

rcsid police.  add missing prototypes.
(sync with KAME)
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a163 3
	/* random value initilization */
	srandom((u_long)time(NULL));

d506 1
a506 1
		interval = random() % (MAX_RTR_SOLICITATION_DELAY * MILLION);
@


1.1
log
@Initial revision
@
text
@d1 2
d95 1
a95 1
static void rtsold_set_dump_file __P(());
@


1.1.1.1
log
@initial import from KAME tree
@
text
@@
