head	1.20;
access;
symbols
	OPENBSD_5_6:1.19.0.6
	OPENBSD_5_6_BASE:1.19
	OPENBSD_5_5:1.19.0.4
	OPENBSD_5_5_BASE:1.19
	OPENBSD_5_4:1.17.0.20
	OPENBSD_5_4_BASE:1.17
	OPENBSD_5_3:1.17.0.18
	OPENBSD_5_3_BASE:1.17
	OPENBSD_5_2:1.17.0.16
	OPENBSD_5_2_BASE:1.17
	OPENBSD_5_1_BASE:1.17
	OPENBSD_5_1:1.17.0.14
	OPENBSD_5_0:1.17.0.12
	OPENBSD_5_0_BASE:1.17
	OPENBSD_4_9:1.17.0.10
	OPENBSD_4_9_BASE:1.17
	OPENBSD_4_8:1.17.0.8
	OPENBSD_4_8_BASE:1.17
	OPENBSD_4_7:1.17.0.4
	OPENBSD_4_7_BASE:1.17
	OPENBSD_4_6:1.17.0.6
	OPENBSD_4_6_BASE:1.17
	OPENBSD_4_5:1.17.0.2
	OPENBSD_4_5_BASE:1.17
	OPENBSD_4_4:1.15.0.2
	OPENBSD_4_4_BASE:1.15
	OPENBSD_4_3:1.12.0.2
	OPENBSD_4_3_BASE:1.12
	OPENBSD_4_2:1.11.0.4
	OPENBSD_4_2_BASE:1.11
	OPENBSD_4_1:1.11.0.2
	OPENBSD_4_1_BASE:1.11
	OPENBSD_4_0:1.10.0.12
	OPENBSD_4_0_BASE:1.10
	OPENBSD_3_9:1.10.0.10
	OPENBSD_3_9_BASE:1.10
	OPENBSD_3_8:1.10.0.8
	OPENBSD_3_8_BASE:1.10
	OPENBSD_3_7:1.10.0.6
	OPENBSD_3_7_BASE:1.10
	OPENBSD_3_6:1.10.0.4
	OPENBSD_3_6_BASE:1.10
	OPENBSD_3_5:1.10.0.2
	OPENBSD_3_5_BASE:1.10
	OPENBSD_3_4:1.9.0.6
	OPENBSD_3_4_BASE:1.9
	OPENBSD_3_3:1.9.0.4
	OPENBSD_3_3_BASE:1.9
	OPENBSD_3_2:1.9.0.2
	OPENBSD_3_2_BASE:1.9
	OPENBSD_3_1:1.6.0.2
	OPENBSD_3_1_BASE:1.6
	OPENBSD_3_0:1.5.0.6
	OPENBSD_3_0_BASE:1.5
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_9:1.5.0.4
	OPENBSD_2_8:1.5.0.2
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	kame_19991209:1.1.1.1
	KAME:1.1.1;
locks; strict;
comment	@ * @;


1.20
date	2014.12.22.09.13.35;	author florian;	state dead;
branches;
next	1.19;
commitid	QHLwHNotIjbdLNCu;

1.19
date	2013.10.21.09.58.14;	author phessler;	state Exp;
branches;
next	1.18;

1.18
date	2013.10.21.08.46.07;	author phessler;	state Exp;
branches;
next	1.17;

1.17
date	2009.02.05.09.57.12;	author chl;	state Exp;
branches;
next	1.16;

1.16
date	2009.02.03.19.00.48;	author chl;	state Exp;
branches;
next	1.15;

1.15
date	2008.06.10.04.49.11;	author reyk;	state Exp;
branches;
next	1.14;

1.14
date	2008.03.24.16.11.05;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2008.03.18.19.32.19;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2007.09.07.14.24.02;	author jmc;	state Exp;
branches;
next	1.11;

1.11
date	2006.12.15.06.12.03;	author itojun;	state Exp;
branches;
next	1.10;

1.10
date	2003.10.05.15.29.28;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2002.06.10.19.57.35;	author espie;	state Exp;
branches;
next	1.8;

1.8
date	2002.05.31.21.24.28;	author itojun;	state Exp;
branches;
next	1.7;

1.7
date	2002.05.31.09.53.26;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2001.11.14.01.59.47;	author itojun;	state Exp;
branches;
next	1.5;

1.5
date	2000.08.13.18.24.00;	author itojun;	state Exp;
branches;
next	1.4;

1.4
date	2000.01.17.16.33.49;	author itojun;	state Exp;
branches;
next	1.3;

1.3
date	2000.01.05.01.54.50;	author itojun;	state Exp;
branches;
next	1.2;

1.2
date	99.12.09.15.10.49;	author itojun;	state Exp;
branches;
next	1.1;

1.1
date	99.12.09.14.56.02;	author itojun;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.12.09.14.56.02;	author itojun;	state Exp;
branches;
next	;


desc
@@


1.20
log
@Out out you evil network daemon.
OK deraadt@@ some time ago
@
text
@/*	$OpenBSD: rtsol.c,v 1.19 2013/10/21 09:58:14 phessler Exp $	*/
/*	$KAME: rtsol.c,v 1.15 2002/05/31 10:10:03 itojun Exp $	*/

/*
 * Copyright (C) 1995, 1996, 1997, and 1998 WIDE Project.
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the project nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/socket.h>
#include <sys/uio.h>
#include <sys/time.h>
#include <sys/queue.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <sys/wait.h>

#include <net/if.h>
#include <net/route.h>
#include <net/if_dl.h>

#include <netinet/in.h>
#include <netinet/ip6.h>
#include <netinet6/ip6_var.h>
#include <netinet/icmp6.h>

#include <arpa/inet.h>

#include <time.h>
#include <unistd.h>
#include <stdio.h>
#include <err.h>
#include <errno.h>
#include <string.h>
#include <stdlib.h>
#include <syslog.h>
#include <fcntl.h>

#include "rtsold.h"

#define ALLROUTER "ff02::2"

static struct msghdr rcvmhdr;
static struct msghdr sndmhdr;
static struct iovec rcviov[2];
static struct iovec sndiov[2];
static struct sockaddr_in6 from;

int rssock;

static struct sockaddr_in6 sin6_allrouters = {sizeof(sin6_allrouters), AF_INET6};

#ifndef SMALL
void	 call_script(char *, char *);
int	 safefile(const char *);
#endif

int
sockopen(u_int rdomain)
{
	static u_char *rcvcmsgbuf = NULL, *sndcmsgbuf = NULL;
	int rcvcmsglen, sndcmsglen, on;
	static u_char answer[1500];
	struct icmp6_filter filt;

	sndcmsglen = rcvcmsglen = CMSG_SPACE(sizeof(struct in6_pktinfo)) +
	    CMSG_SPACE(sizeof(int));
	if (rcvcmsgbuf == NULL && (rcvcmsgbuf = malloc(rcvcmsglen)) == NULL) {
		warnmsg(LOG_ERR, __func__,
		    "malloc for receive msghdr failed");
		return(-1);
	}
	if (sndcmsgbuf == NULL && (sndcmsgbuf = malloc(sndcmsglen)) == NULL) {
		warnmsg(LOG_ERR, __func__,
		    "malloc for send msghdr failed");
		return(-1);
	}
	memset(&sin6_allrouters, 0, sizeof(struct sockaddr_in6));
	sin6_allrouters.sin6_family = AF_INET6;
	sin6_allrouters.sin6_len = sizeof(sin6_allrouters);
	if (inet_pton(AF_INET6, ALLROUTER,
	    &sin6_allrouters.sin6_addr.s6_addr) != 1) {
		warnmsg(LOG_ERR, __func__, "inet_pton failed for %s",
		    ALLROUTER);
		return(-1);
	}

	if ((rssock = socket(AF_INET6, SOCK_RAW, IPPROTO_ICMPV6)) < 0) {
		warnmsg(LOG_ERR, __func__, "socket: %s", strerror(errno));
		return(-1);
	}

	/* Set our preferred routing table */
	if (setsockopt(rssock, SOL_SOCKET, SO_RTABLE,
	    &rdomain, sizeof(rdomain)) < 0) {
		warnmsg(LOG_ERR, __func__, "IPV6_RECVPKTINFO: %s",
		    strerror(errno));
		exit(1);
	}

	/* specify to tell receiving interface */
	on = 1;
	if (setsockopt(rssock, IPPROTO_IPV6, IPV6_RECVPKTINFO, &on,
	    sizeof(on)) < 0) {
		warnmsg(LOG_ERR, __func__, "IPV6_RECVPKTINFO: %s",
		    strerror(errno));
		exit(1);
	}

	on = 1;
	/* specify to tell value of hoplimit field of received IP6 hdr */
	if (setsockopt(rssock, IPPROTO_IPV6, IPV6_RECVHOPLIMIT, &on,
	    sizeof(on)) < 0) {
		warnmsg(LOG_ERR, __func__, "IPV6_RECVHOPLIMIT: %s",
		    strerror(errno));
		exit(1);
	}

	/* specfiy to accept only router advertisements on the socket */
	ICMP6_FILTER_SETBLOCKALL(&filt);
	ICMP6_FILTER_SETPASS(ND_ROUTER_ADVERT, &filt);
	if (setsockopt(rssock, IPPROTO_ICMPV6, ICMP6_FILTER, &filt,
	    sizeof(filt)) == -1) {
		warnmsg(LOG_ERR, __func__, "setsockopt(ICMP6_FILTER): %s",
		    strerror(errno));
		return(-1);
	}

	/* initialize msghdr for receiving packets */
	rcviov[0].iov_base = (caddr_t)answer;
	rcviov[0].iov_len = sizeof(answer);
	rcvmhdr.msg_name = (caddr_t)&from;
	rcvmhdr.msg_namelen = sizeof(from);
	rcvmhdr.msg_iov = rcviov;
	rcvmhdr.msg_iovlen = 1;
	rcvmhdr.msg_control = (caddr_t) rcvcmsgbuf;
	rcvmhdr.msg_controllen = rcvcmsglen;

	/* initialize msghdr for sending packets */
	sndmhdr.msg_namelen = sizeof(struct sockaddr_in6);
	sndmhdr.msg_iov = sndiov;
	sndmhdr.msg_iovlen = 1;
	sndmhdr.msg_control = (caddr_t)sndcmsgbuf;
	sndmhdr.msg_controllen = sndcmsglen;

	return(rssock);
}

void
sendpacket(struct ifinfo *ifinfo)
{
	struct in6_pktinfo *pi;
	struct cmsghdr *cm;
	int hoplimit = 255;
	struct sockaddr_in6 dst;
	ssize_t i;

	dst = sin6_allrouters;
	dst.sin6_scope_id = ifinfo->linkid;

	sndmhdr.msg_name = (caddr_t)&dst;
	sndmhdr.msg_iov[0].iov_base = (caddr_t)ifinfo->rs_data;
	sndmhdr.msg_iov[0].iov_len = ifinfo->rs_datalen;

	cm = CMSG_FIRSTHDR(&sndmhdr);
	/* specify the outgoing interface */
	cm->cmsg_level = IPPROTO_IPV6;
	cm->cmsg_type = IPV6_PKTINFO;
	cm->cmsg_len = CMSG_LEN(sizeof(struct in6_pktinfo));
	pi = (struct in6_pktinfo *)CMSG_DATA(cm);
	memset(&pi->ipi6_addr, 0, sizeof(pi->ipi6_addr));	/*XXX*/
	pi->ipi6_ifindex = ifinfo->sdl->sdl_index;

	/* specify the hop limit of the packet */
	cm = CMSG_NXTHDR(&sndmhdr, cm);
	cm->cmsg_level = IPPROTO_IPV6;
	cm->cmsg_type = IPV6_HOPLIMIT;
	cm->cmsg_len = CMSG_LEN(sizeof(int));
	memcpy(CMSG_DATA(cm), &hoplimit, sizeof(int));

	warnmsg(LOG_DEBUG, __func__,
	    "send RS on %s, whose state is %d",
	    ifinfo->ifname, ifinfo->state);

	i = sendmsg(rssock, &sndmhdr, 0);

	if (i < 0 || i != ifinfo->rs_datalen) {
		/*
		 * ENETDOWN is not so serious, especially when using several
		 * network cards on a mobile node. We ignore it.
		 */
		if (errno != ENETDOWN || dflag > 0)
			warnmsg(LOG_ERR, __func__, "sendmsg on %s: %s",
			    ifinfo->ifname, strerror(errno));
	}

	/* update counter */
	ifinfo->probes++;
}

void
rtsol_input(int s)
{
	u_char ntopbuf[INET6_ADDRSTRLEN], ifnamebuf[IFNAMSIZ];
	int ifindex = 0, *hlimp = NULL;
	struct in6_pktinfo *pi = NULL;
	struct ifinfo *ifi = NULL;
	struct icmp6_hdr *icp;
	struct cmsghdr *cm;
	ssize_t i;
#ifndef SMALL
	struct nd_router_advert *nd_ra;
#endif

	/* get message */
	if ((i = recvmsg(s, &rcvmhdr, 0)) < 0) {
		warnmsg(LOG_ERR, __func__, "recvmsg: %s", strerror(errno));
		return;
	}

	/* extract optional information via Advanced API */
	for (cm = (struct cmsghdr *)CMSG_FIRSTHDR(&rcvmhdr); cm;
	    cm = (struct cmsghdr *)CMSG_NXTHDR(&rcvmhdr, cm)) {
		if (cm->cmsg_level == IPPROTO_IPV6 &&
		    cm->cmsg_type == IPV6_PKTINFO &&
		    cm->cmsg_len == CMSG_LEN(sizeof(struct in6_pktinfo))) {
			pi = (struct in6_pktinfo *)(CMSG_DATA(cm));
			ifindex = pi->ipi6_ifindex;
		}
		if (cm->cmsg_level == IPPROTO_IPV6 &&
		    cm->cmsg_type == IPV6_HOPLIMIT &&
		    cm->cmsg_len == CMSG_LEN(sizeof(int)))
			hlimp = (int *)CMSG_DATA(cm);
	}

	if (ifindex == 0) {
		warnmsg(LOG_ERR, __func__,
		    "failed to get receiving interface");
		return;
	}
	if (hlimp == NULL) {
		warnmsg(LOG_ERR, __func__,
		    "failed to get receiving hop limit");
		return;
	}

	if (i < sizeof(struct nd_router_advert)) {
		warnmsg(LOG_ERR, __func__,
		    "packet size(%zd) is too short", i);
		return;
	}

	icp = (struct icmp6_hdr *)rcvmhdr.msg_iov[0].iov_base;

	if (icp->icmp6_type != ND_ROUTER_ADVERT) {
		warnmsg(LOG_ERR, __func__,
		    "invalid icmp type(%d) from %s on %s", icp->icmp6_type,
		    inet_ntop(AF_INET6, &from.sin6_addr, ntopbuf,
		    INET6_ADDRSTRLEN),
		    if_indextoname(pi->ipi6_ifindex, ifnamebuf));
		return;
	}

	if (icp->icmp6_code != 0) {
		warnmsg(LOG_ERR, __func__,
		    "invalid icmp code(%d) from %s on %s", icp->icmp6_code,
		    inet_ntop(AF_INET6, &from.sin6_addr, ntopbuf,
		    INET6_ADDRSTRLEN),
		    if_indextoname(pi->ipi6_ifindex, ifnamebuf));
		return;
	}

	if (*hlimp != 255) {
		warnmsg(LOG_NOTICE, __func__,
		    "invalid RA with hop limit(%d) from %s on %s",
		    *hlimp,
		    inet_ntop(AF_INET6, &from.sin6_addr, ntopbuf,
		    INET6_ADDRSTRLEN),
		    if_indextoname(pi->ipi6_ifindex, ifnamebuf));
		return;
	}

	if (pi && !IN6_IS_ADDR_LINKLOCAL(&from.sin6_addr)) {
		warnmsg(LOG_NOTICE, __func__,
		    "invalid RA with non link-local source from %s on %s",
		    inet_ntop(AF_INET6, &from.sin6_addr, ntopbuf,
		    INET6_ADDRSTRLEN),
		    if_indextoname(pi->ipi6_ifindex, ifnamebuf));
		return;
	}

	/* xxx: more validation? */

	if ((ifi = find_ifinfo(pi->ipi6_ifindex)) == NULL) {
		warnmsg(LOG_NOTICE, __func__,
		    "received RA from %s on an unexpected IF(%s)",
		    inet_ntop(AF_INET6, &from.sin6_addr, ntopbuf,
		    INET6_ADDRSTRLEN),
		    if_indextoname(pi->ipi6_ifindex, ifnamebuf));
		return;
	}

	warnmsg(LOG_DEBUG, __func__,
	    "received RA from %s on %s, state is %d",
	    inet_ntop(AF_INET6, &from.sin6_addr, ntopbuf, INET6_ADDRSTRLEN),
	    ifi->ifname, ifi->state);

#ifndef SMALL
	nd_ra = (struct nd_router_advert *)icp;

	/*
	 * Process the "O bit."
	 * If the value of OtherConfigFlag changes from FALSE to TRUE, the
	 * host should invoke the stateful autoconfiguration protocol,
	 * requesting information.
	 * [RFC 2462 Section 5.5.3]
	 */
	if (((nd_ra->nd_ra_flags_reserved) & ND_RA_FLAG_OTHER) &&
	    !ifi->otherconfig) {
		warnmsg(LOG_DEBUG, __func__,
		    "OtherConfigFlag on %s is turned on", ifi->ifname);
		ifi->otherconfig = 1;
		call_script(otherconf_script, ifi->ifname);
	}
#endif

	ifi->racnt++;

	switch (ifi->state) {
	case IFS_IDLE:		/* should be ignored */
	case IFS_DELAY:		/* right? */
		break;
	case IFS_PROBE:
		ifi->state = IFS_IDLE;
		ifi->probes = 0;
		rtsol_timer_update(ifi);
		break;
	}
}

#ifndef SMALL
void
call_script(char *scriptpath, char *ifname)
{
	pid_t pid, wpid;

	if (scriptpath == NULL)
		return;

	/* launch the script */
	pid = fork();
	if (pid < 0) {
		warnmsg(LOG_ERR, __func__,
		    "failed to fork: %s", strerror(errno));
		return;
	} else if (pid) {
		int wstatus;

		do {
			wpid = wait(&wstatus);
		} while (wpid != pid && wpid > 0);

		if (wpid < 0)
			warnmsg(LOG_ERR, __func__,
			    "wait: %s", strerror(errno));
		else {
			warnmsg(LOG_DEBUG, __func__,
			    "script \"%s\" terminated", scriptpath);
		}
	} else {
		char *argv[3];
		int fd;

		argv[0] = scriptpath;
		argv[1] = ifname;
		argv[2] = NULL;

		if (safefile(scriptpath) != 0) {
			warnmsg(LOG_ERR, __func__,
			    "script \"%s\" cannot be executed safely",
			    scriptpath);
			exit(1);
		}

		if ((fd = open("/dev/null", O_RDWR)) != -1) {
			dup2(fd, STDIN_FILENO);
			dup2(fd, STDOUT_FILENO);
			dup2(fd, STDERR_FILENO);
			if (fd > STDERR_FILENO)
				close(fd);
		}

		execv(scriptpath, argv);

		warnmsg(LOG_ERR, __func__, "child: exec failed: %s",
		    strerror(errno));
		exit(1);
	}

	return;
}

int
safefile(const char *path)
{
	struct stat s;
	uid_t myuid;

	/* no setuid */
	if (getuid() != geteuid()) {
		warnmsg(LOG_NOTICE, __func__,
		    "setuid'ed execution not allowed\n");
		return (-1);
	}

	if (lstat(path, &s) != 0) {
		warnmsg(LOG_NOTICE, __func__, "lstat failed: %s",
		    strerror(errno));
		return (-1);
	}

	/* the file must be owned by the running uid */
	myuid = getuid();
	if (s.st_uid != myuid) {
		warnmsg(LOG_NOTICE, __func__,
		    "%s has invalid owner uid\n", path);
		return (-1);
	}

	switch (s.st_mode & S_IFMT) {
	case S_IFREG:
		break;
	default:
		warnmsg(LOG_NOTICE, __func__,
		    "%s is an invalid file type 0x%o\n",
		    path, (s.st_mode & S_IFMT));
		return (-1);
	}

	return (0);
}
#endif
@


1.19
log
@we are passing the variable, not using a global any more.

pointed out by bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsol.c,v 1.18 2013/10/21 08:46:07 phessler Exp $	*/
@


1.18
log
@Add rdomain support to IPv6 configuration tools

OK claudio@@ and bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsol.c,v 1.17 2009/02/05 09:57:12 chl Exp $	*/
a73 1
extern u_int rdomain;
@


1.17
log
@fix format string

ok naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsol.c,v 1.16 2009/02/03 19:00:48 chl Exp $	*/
d74 1
d84 1
a84 1
sockopen(void)
d116 8
@


1.16
log
@add missing headers needed by wait()

ok rainer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsol.c,v 1.15 2008/06/10 04:49:11 reyk Exp $	*/
d265 1
a265 1
		    "packet size(%d) is too short", i);
@


1.15
log
@add the -O option to run an external script when the "other
configuration" flag is found in the RA message. it basically means
"here is your IPv6 address, but run something like DHCPv6 to get more
information".  so the main purpose is to run a dhcpv6 client to get
DNS etc.

Merged from KAME

ok rainer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsol.c,v 1.14 2008/03/24 16:11:05 deraadt Exp $	*/
d39 2
@


1.14
log
@msg_controllen has to be CMSG_SPACE so that the kernel can account for
each cmsg_len (ie. msg_controllen = sum of CMSG_ALIGN(cmsg_len).  This
works now that kernel fd passing has been fixed to accept a bit of
sloppiness because of this ABI repair.
lots of discussion with kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsol.c,v 1.13 2008/03/18 19:32:19 deraadt Exp $	*/
d38 1
d59 2
d75 5
d225 3
d322 19
d354 103
@


1.13
log
@correct CMSG_SPACE and CMSG_LEN handling as done in other places.  These
are the complicated cases where multiple messages are sent.  discussed
with kettenis, hshoexer, and rtsol tested by jmc - thanks
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsol.c,v 1.12 2007/09/07 14:24:02 jmc Exp $	*/
d76 1
a76 1
	int rcvcmsgspace, sndcmsgspace, rcvcmsglen, sndcmsglen, on;
a80 2
	    CMSG_LEN(sizeof(int));
	sndcmsgspace = rcvcmsgspace = CMSG_SPACE(sizeof(struct in6_pktinfo)) +
d82 1
a82 1
	if (rcvcmsgbuf == NULL && (rcvcmsgbuf = malloc(rcvcmsgspace)) == NULL) {
d87 1
a87 1
	if (sndcmsgbuf == NULL && (sndcmsgbuf = malloc(sndcmsgspace)) == NULL) {
@


1.12
log
@unexpeced -> unexpected;
from Wouter Schoot, netbsd-bugs #36931
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsol.c,v 1.11 2006/12/15 06:12:03 itojun Exp $	*/
d76 1
a76 1
	int rcvcmsglen, sndcmsglen, on;
d81 2
d84 1
a84 1
	if (rcvcmsgbuf == NULL && (rcvcmsgbuf = malloc(rcvcmsglen)) == NULL) {
d89 1
a89 1
	if (sndcmsgbuf == NULL && (sndcmsgbuf = malloc(sndcmsglen)) == NULL) {
@


1.11
log
@cleanup RFC2292/3542 #ifdef.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsol.c,v 1.10 2003/10/05 15:29:28 deraadt Exp $	*/
d299 1
a299 1
		    "received RA from %s on an unexpeced IF(%s)",
@


1.10
log
@ansi
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsol.c,v 1.9 2002/06/10 19:57:35 espie Exp $	*/
a108 1
#ifdef IPV6_RECVPKTINFO
a114 8
#else  /* old adv. API */
	if (setsockopt(rssock, IPPROTO_IPV6, IPV6_PKTINFO, &on,
	    sizeof(on)) < 0) {
		warnmsg(LOG_ERR, __func__, "IPV6_PKTINFO: %s",
		    strerror(errno));
		exit(1);
	}
#endif
a117 1
#ifdef IPV6_RECVHOPLIMIT
a123 8
#else  /* old adv. API */
	if (setsockopt(rssock, IPPROTO_IPV6, IPV6_HOPLIMIT, &on,
	    sizeof(on)) < 0) {
		warnmsg(LOG_ERR, __func__, "IPV6_HOPLIMIT: %s",
		    strerror(errno));
		exit(1);
	}
#endif
@


1.9
log
@Kill __FUNCTION__.
ok itojun@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsol.c,v 1.8 2002/05/31 21:24:28 itojun Exp $	*/
d73 1
a73 1
sockopen()
a178 1
	int i;
d180 1
d229 1
a229 1
	int ifindex = 0, i, *hlimp = NULL;
d234 1
@


1.8
log
@sync w/ latest kame.  link id handling.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsol.c,v 1.7 2002/05/31 09:53:26 deraadt Exp $	*/
d83 1
a83 1
		warnmsg(LOG_ERR, __FUNCTION__,
d88 1
a88 1
		warnmsg(LOG_ERR, __FUNCTION__,
d97 1
a97 1
		warnmsg(LOG_ERR, __FUNCTION__, "inet_pton failed for %s",
d103 1
a103 1
		warnmsg(LOG_ERR, __FUNCTION__, "socket: %s", strerror(errno));
d112 1
a112 1
		warnmsg(LOG_ERR, __FUNCTION__, "IPV6_RECVPKTINFO: %s",
d119 1
a119 1
		warnmsg(LOG_ERR, __FUNCTION__, "IPV6_PKTINFO: %s",
d130 1
a130 1
		warnmsg(LOG_ERR, __FUNCTION__, "IPV6_RECVHOPLIMIT: %s",
d137 1
a137 1
		warnmsg(LOG_ERR, __FUNCTION__, "IPV6_HOPLIMIT: %s",
d148 1
a148 1
		warnmsg(LOG_ERR, __FUNCTION__, "setsockopt(ICMP6_FILTER): %s",
d205 1
a205 1
	warnmsg(LOG_DEBUG, __FUNCTION__,
d217 1
a217 1
			warnmsg(LOG_ERR, __FUNCTION__, "sendmsg on %s: %s",
d237 1
a237 1
		warnmsg(LOG_ERR, __FUNCTION__, "recvmsg: %s", strerror(errno));
d257 1
a257 1
		warnmsg(LOG_ERR, __FUNCTION__,
d262 1
a262 1
		warnmsg(LOG_ERR, __FUNCTION__,
d268 1
a268 1
		warnmsg(LOG_ERR, __FUNCTION__,
d276 1
a276 1
		warnmsg(LOG_ERR, __FUNCTION__,
d285 1
a285 1
		warnmsg(LOG_ERR, __FUNCTION__,
d294 1
a294 1
		warnmsg(LOG_NOTICE, __FUNCTION__,
d304 1
a304 1
		warnmsg(LOG_NOTICE, __FUNCTION__,
d315 1
a315 1
		warnmsg(LOG_NOTICE, __FUNCTION__,
d323 1
a323 1
	warnmsg(LOG_DEBUG, __FUNCTION__,
@


1.7
log
@KNF; itojun ok
@
text
@d1 2
a2 2
/*	$OpenBSD: rtsol.c,v 1.6 2001/11/14 01:59:47 itojun Exp $	*/
/*	$KAME: rtsol.c,v 1.14 2001/11/13 10:31:23 jinmei Exp $	*/
d180 1
d182 4
a185 1
	sndmhdr.msg_name = (caddr_t)&sin6_allrouters;
@


1.6
log
@initialize sockaddr_in6 correctly
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsol.c,v 1.5 2000/08/13 18:24:00 itojun Exp $	*/
d75 3
a77 1
	int on;
a78 3
	static u_char answer[1500];
	int rcvcmsglen, sndcmsglen;
	static u_char *rcvcmsgbuf = NULL, *sndcmsgbuf = NULL;
d81 1
a81 1
		CMSG_SPACE(sizeof(int));
d84 1
a84 1
			"malloc for receive msghdr failed");
d87 1
a87 1
	if (sndcmsgbuf == NULL && (sndcmsgbuf = malloc(sndcmsglen)) == NULL) { 
d89 1
a89 1
			"malloc for send msghdr failed");
d96 1
a96 1
		      &sin6_allrouters.sin6_addr.s6_addr) != 1) {
d98 1
a98 1
		       ALLROUTER);
d111 1
a111 1
		       sizeof(on)) < 0) {
d113 1
a113 1
		       strerror(errno));
d118 1
a118 1
		       sizeof(on)) < 0) {
d120 1
a120 1
		       strerror(errno));
d123 1
a123 1
#endif 
d129 1
a129 1
		       sizeof(on)) < 0) {
d131 1
a131 1
		       strerror(errno));
d136 1
a136 1
		       sizeof(on)) < 0) {
d138 1
a138 1
		       strerror(errno));
d141 1
a141 1
#endif 
d147 1
a147 1
		       sizeof(filt)) == -1) {
d149 1
a149 1
		       strerror(errno));
d176 3
a179 2
	struct cmsghdr *cm;
	struct in6_pktinfo *pi;
d195 5
a199 2
	{
		int hoplimit = 255;
d201 3
a203 10
		cm = CMSG_NXTHDR(&sndmhdr, cm);
		cm->cmsg_level = IPPROTO_IPV6;
		cm->cmsg_type = IPV6_HOPLIMIT;
		cm->cmsg_len = CMSG_LEN(sizeof(int));
		memcpy(CMSG_DATA(cm), &hoplimit, sizeof(int));
	}

	warnmsg(LOG_DEBUG,
	       __FUNCTION__, "send RS on %s, whose state is %d",
	       ifinfo->ifname, ifinfo->state);
d214 1
a214 1
				ifinfo->ifname, strerror(errno));
d224 4
a227 2
	int i;
	int *hlimp = NULL;
a228 1
	int ifindex = 0;
a229 3
	struct in6_pktinfo *pi = NULL;
	struct ifinfo *ifi = NULL;
	u_char ntopbuf[INET6_ADDRSTRLEN], ifnamebuf[IFNAMSIZ];
d238 2
a239 3
	for (cm = (struct cmsghdr *)CMSG_FIRSTHDR(&rcvmhdr);
	     cm;
	     cm = (struct cmsghdr *)CMSG_NXTHDR(&rcvmhdr, cm)) {
d253 2
a254 2
		warnmsg(LOG_ERR,
		       __FUNCTION__, "failed to get receiving interface");
d258 2
a259 2
		warnmsg(LOG_ERR,
		       __FUNCTION__, "failed to get receiving hop limit");
d264 2
a265 2
		warnmsg(LOG_ERR,
		       __FUNCTION__, "packet size(%d) is too short", i);
d273 4
a276 4
			"invalid icmp type(%d) from %s on %s", icp->icmp6_type,
		       inet_ntop(AF_INET6, &from.sin6_addr, ntopbuf,
				 INET6_ADDRSTRLEN),
		       if_indextoname(pi->ipi6_ifindex, ifnamebuf));
d282 4
a285 4
			"invalid icmp code(%d) from %s on %s", icp->icmp6_code,
		       inet_ntop(AF_INET6, &from.sin6_addr, ntopbuf,
				 INET6_ADDRSTRLEN),
		       if_indextoname(pi->ipi6_ifindex, ifnamebuf));
d291 5
a295 5
			"invalid RA with hop limit(%d) from %s on %s",
		       *hlimp,
		       inet_ntop(AF_INET6, &from.sin6_addr, ntopbuf,
				 INET6_ADDRSTRLEN),
		       if_indextoname(pi->ipi6_ifindex, ifnamebuf));
d301 4
a304 4
			"invalid RA with non link-local source from %s on %s",
		       inet_ntop(AF_INET6, &from.sin6_addr, ntopbuf,
				 INET6_ADDRSTRLEN),
		       if_indextoname(pi->ipi6_ifindex, ifnamebuf));
d312 4
a315 4
			"received RA from %s on an unexpeced IF(%s)",
		       inet_ntop(AF_INET6, &from.sin6_addr, ntopbuf,
				 INET6_ADDRSTRLEN),
		       if_indextoname(pi->ipi6_ifindex, ifnamebuf));
d320 3
a322 4
		"received RA from %s on %s, state is %d",
	       inet_ntop(AF_INET6, &from.sin6_addr, ntopbuf,
			 INET6_ADDRSTRLEN),
	       ifi->ifname, ifi->state);
d326 9
a334 9
	switch(ifi->state) {
	 case IFS_IDLE:		/* should be ignored */
	 case IFS_DELAY:		/* right? */
		 break;
	 case IFS_PROBE:
		 ifi->state = IFS_IDLE;
		 ifi->probes = 0;
		 rtsol_timer_update(ifi);
		 break;
@


1.5
log
@add "rtsol -a" (automatically lookup outgoign interface).
warn if net.inet6.ip6.forwarding == 1.
improve manpage.
use $KAME$ for KAME tags.

sync with kame.
@
text
@d1 2
a2 2
/*	$OpenBSD: rtsol.c,v 1.4 2000/01/17 16:33:49 itojun Exp $	*/
/*	$KAME: rtsol.c,v 1.11 2000/08/13 06:14:59 itojun Exp $	*/
d94 2
@


1.4
log
@sync with latest kame.  previous version leaves an udp socket opened
(for use with ioctls) and it was not a pleasant thing.
@
text
@d1 2
a2 1
/*	$OpenBSD: rtsol.c,v 1.3 2000/01/05 01:54:50 itojun Exp $	*/
d37 1
d78 2
a79 4
	static u_char rcvcmsgbuf[CMSG_SPACE(sizeof(struct in6_pktinfo)) +
				CMSG_SPACE(sizeof(int))];
	static u_char sndcmsgbuf[CMSG_SPACE(sizeof(struct in6_pktinfo)) + 
				CMSG_SPACE(sizeof(int))];
d81 12
d160 1
a160 1
	rcvmhdr.msg_controllen = sizeof(rcvcmsgbuf);
d167 1
a167 1
	sndmhdr.msg_controllen = sizeof(sndcmsgbuf);
@


1.3
log
@avoid use of kvm (sync with latest kame)
@
text
@d1 1
a1 1
/*	$OpenBSD: rtsol.c,v 1.2 1999/12/09 15:10:49 itojun Exp $	*/
d66 1
a66 1
static int rssock;
@


1.2
log
@rtsold(8); router solicitation daemon.
rtsol(8); router solicitation program, for use in bootstrap process
(statically linked)

rcsid police.  add missing prototypes.
(sync with KAME)
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d96 8
d110 1
d114 8
d128 1
@


1.1
log
@Initial revision
@
text
@d1 2
@


1.1.1.1
log
@initial import from KAME tree
@
text
@@
