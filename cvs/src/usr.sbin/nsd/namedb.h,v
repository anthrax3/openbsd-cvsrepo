head	1.8;
access;
symbols
	OPENBSD_6_0:1.5.0.2
	OPENBSD_6_0_BASE:1.5
	OPENBSD_5_9:1.4.0.2
	OPENBSD_5_9_BASE:1.4
	NSD_4_1_6:1.1.1.12
	OPENBSD_5_8:1.4.0.4
	OPENBSD_5_8_BASE:1.4
	NSD_4_1_3:1.1.1.12
	OPENBSD_5_7:1.3.0.2
	OPENBSD_5_7_BASE:1.3
	NSD_4_1_1:1.1.1.11
	NSD_4_1_0:1.1.1.10
	OPENBSD_5_6:1.1.1.9.0.4
	OPENBSD_5_6_BASE:1.1.1.9
	NSD_4_0_3:1.1.1.9
	NSD_4_0_2:1.1.1.9
	OPENBSD_5_5:1.1.1.8.0.4
	OPENBSD_5_5_BASE:1.1.1.8
	NSD_4_0_1:1.1.1.8
	NSD_4_0_0:1.1.1.7
	NSD_3_2_16:1.1.1.6
	OPENBSD_5_4:1.1.1.6.0.6
	OPENBSD_5_4_BASE:1.1.1.6
	OPENBSD_5_3:1.1.1.6.0.4
	OPENBSD_5_3_BASE:1.1.1.6
	NSD_3_2_15:1.1.1.6
	NSD_3_2_14:1.1.1.6
	NSD_3_2_13:1.1.1.6
	OPENBSD_5_2:1.1.1.6.0.2
	OPENBSD_5_2_BASE:1.1.1.6
	NSD_3_2_11:1.1.1.6
	NSD_3_2_10:1.1.1.5
	OPENBSD_5_1_BASE:1.1.1.4
	OPENBSD_5_1:1.1.1.4.0.2
	NSD_3_2_9:1.1.1.4
	OPENBSD_5_0:1.1.1.3.0.2
	OPENBSD_5_0_BASE:1.1.1.3
	NSD_3_2_8:1.1.1.3
	OPENBSD_4_9:1.1.1.2.0.4
	OPENBSD_4_9_BASE:1.1.1.2
	NSD_3_2_6:1.1.1.2
	OPENBSD_4_8:1.1.1.2.0.2
	OPENBSD_4_8_BASE:1.1.1.2
	NSD_3_2_5:1.1.1.2
	OPENBSD_4_7:1.1.1.1.0.2
	OPENBSD_4_7_BASE:1.1.1.1
	NSD_3_2_4:1.1.1.1
	NLNETLABS:1.1.1;
locks; strict;
comment	@ * @;


1.8
date	2017.02.17.20.04.45;	author florian;	state Exp;
branches;
next	1.7;
commitid	WmSuN5M3Jbe54113;

1.7
date	2016.10.24.09.44.43;	author florian;	state Exp;
branches;
next	1.6;
commitid	g3wASIhTcujU0LFi;

1.6
date	2016.08.31.07.31.20;	author florian;	state Exp;
branches;
next	1.5;
commitid	1gMwFuybgH2l617m;

1.5
date	2016.06.24.08.34.03;	author florian;	state Exp;
branches;
next	1.4;
commitid	Z9jVKJJMPmC3zw2t;

1.4
date	2015.07.17.17.36.33;	author sthen;	state Exp;
branches;
next	1.3;
commitid	2WtkENMkCz3GhSbE;

1.3
date	2015.02.03.10.40.02;	author brad;	state Exp;
branches;
next	1.2;
commitid	MI9j0d0LR8Dk9lnd;

1.2
date	2014.12.18.23.26.13;	author brad;	state Exp;
branches;
next	1.1;
commitid	rBaz3dZHAQwIDT3j;

1.1
date	2010.01.15.19.24.54;	author jakob;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2010.01.15.19.24.54;	author jakob;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2010.04.15.20.57.10;	author jakob;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2011.05.21.18.17.23;	author jakob;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2012.01.29.11.15.40;	author jakob;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2012.03.02.08.38.55;	author sthen;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2012.07.09.21.55.07;	author sthen;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2013.11.26.12.50.19;	author sthen;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2014.02.04.01.54.06;	author brad;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2014.03.13.02.00.27;	author brad;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2014.09.16.16.54.03;	author brad;	state Exp;
branches;
next	1.1.1.11;
commitid	BWSdZeElrpYSRdME;

1.1.1.11
date	2015.02.03.10.24.32;	author brad;	state Exp;
branches;
next	1.1.1.12;
commitid	yn8l9RVkmdMVYIfl;

1.1.1.12
date	2015.07.17.17.36.01;	author sthen;	state Exp;
branches;
next	;
commitid	Jeq5uGP63ff7nS9K;


desc
@@


1.8
log
@Update to 4.1.15.
This contains a local patch to query.c (missed _t conversion) that has
been submitted upstream.
OK sthen
@
text
@/*
 * namedb.h -- nsd(8) internal namespace database definitions
 *
 * Copyright (c) 2001-2006, NLnet Labs. All rights reserved.
 *
 * See LICENSE for the license.
 *
 */

#ifndef _NAMEDB_H_
#define	_NAMEDB_H_

#include <stdio.h>

#include "dname.h"
#include "dns.h"
#include "radtree.h"
#include "rbtree.h"
struct zone_options;
struct nsd_options;
struct udb_base;
struct udb_ptr;
struct nsd;

typedef union rdata_atom rdata_atom_type;
typedef struct rrset rrset_type;
typedef struct rr rr_type;

/*
 * A domain name table supporting fast insert and search operations.
 */
typedef struct domain_table domain_table_type;
typedef struct domain domain_type;
typedef struct zone zone_type;
typedef struct namedb namedb_type;

struct domain_table
{
	region_type* region;
#ifdef USE_RADIX_TREE
	struct radtree *nametree;
#else
	rbtree_type      *names_to_domains;
#endif
	domain_type* root;
	/* ptr to biggest domain.number and last in list.
	 * the root is the lowest and first in the list. */
	domain_type *numlist_last;
#ifdef NSEC3
	/* the prehash list, start of the list */
	domain_type* prehash_list;
#endif /* NSEC3 */
};

#ifdef NSEC3
struct nsec3_domain_data {
	/* (if nsec3 chain complete) always the covering nsec3 record */
	domain_type* nsec3_cover;
	/* the nsec3 that covers the wildcard child of this domain. */
	domain_type* nsec3_wcard_child_cover;
	/* for the DS case we must answer on the parent side of zone cut */
	domain_type* nsec3_ds_parent_cover;
	/* NSEC3 domains to prehash, prev and next on the list or cleared */
	domain_type* prehash_prev, *prehash_next;
	/* entry in the nsec3tree (for NSEC3s in the chain in use) */
	rbnode_type nsec3_node;
	/* entry in the hashtree (for precompiled domains) */
	rbnode_type hash_node;
	/* entry in the wchashtree (the wildcard precompile) */
	rbnode_type wchash_node;
	/* entry in the dshashtree (the parent ds precompile) */
	rbnode_type dshash_node;

	/* nsec3 hash */
	uint8_t nsec3_hash[NSEC3_HASH_LEN];
	/* nsec3 hash of wildcard before this name */
	uint8_t nsec3_wc_hash[NSEC3_HASH_LEN];
	/* parent-side DS hash */
	uint8_t nsec3_ds_parent_hash[NSEC3_HASH_LEN];
	/* if the nsec3 has is available */
	unsigned  have_nsec3_hash : 1;
	unsigned  have_nsec3_wc_hash : 1;
	unsigned  have_nsec3_ds_parent_hash : 1;
	/* if the domain has an NSEC3 for it, use cover ptr to get it. */
	unsigned     nsec3_is_exact : 1;
	/* same but on parent side */
	unsigned     nsec3_ds_parent_is_exact : 1;
};
#endif /* NSEC3 */

struct domain
{
#ifdef USE_RADIX_TREE
	struct radnode* rnode;
	const dname_type* dname;
#else
	rbnode_type     node;
#endif
	domain_type* parent;
	domain_type* wildcard_child_closest_match;
	rrset_type* rrsets;
#ifdef NSEC3
	struct nsec3_domain_data* nsec3;
#endif
	/* double-linked list sorted by domain.number */
	domain_type* numlist_prev, *numlist_next;
	size_t     number; /* Unique domain name number.  */
	size_t     usage; /* number of ptrs to this from RRs(in rdata) and
			     from zone-apex pointers, also the root has one
			     more to make sure it cannot be deleted. */

	/*
	 * This domain name exists (see wildcard clarification draft).
	 */
	unsigned     is_existing : 1;
	unsigned     is_apex : 1;
};

struct zone
{
	struct radnode *node; /* this entry in zonetree */
	domain_type* apex;
	rrset_type*  soa_rrset;
	rrset_type*  soa_nx_rrset; /* see bug #103 */
	rrset_type*  ns_rrset;
#ifdef NSEC3
	rr_type* nsec3_param; /* NSEC3PARAM RR of chain in use or NULL */
	domain_type* nsec3_last; /* last domain with nsec3, wraps */
	/* in these trees, the root contains an elem ptr to the radtree* */
	rbtree_type* nsec3tree; /* tree with relevant NSEC3 domains */
	rbtree_type* hashtree; /* tree, hashed NSEC3precompiled domains */
	rbtree_type* wchashtree; /* tree, wildcard hashed domains */
	rbtree_type* dshashtree; /* tree, ds-parent-hash domains */
#endif
	struct zone_options* opts;
	char*        filename; /* set if read from file, which file */
	char*        logstr; /* set for zone xfer, the log string */
	struct timespec mtime; /* time of last modification */
	unsigned     zonestatid; /* array index for zone stats */
	unsigned     is_secure : 1; /* zone uses DNSSEC */
	unsigned     is_ok : 1; /* zone has not expired. */
	unsigned     is_changed : 1; /* zone was changed by AXFR */
};

/* a RR in DNS */
struct rr {
	domain_type*     owner;
	rdata_atom_type* rdatas;
	uint32_t         ttl;
	uint16_t         type;
	uint16_t         klass;
	uint16_t         rdata_count;
};

/*
 * An RRset consists of at least one RR.  All RRs are from the same
 * zone.
 */
struct rrset
{
	rrset_type* next;
	zone_type*  zone;
	rr_type*    rrs;
	uint16_t    rr_count;
};

/*
 * The field used is based on the wireformat the atom is stored in.
 * The allowed wireformats are defined by the rdata_wireformat_type
 * enumeration.
 */
union rdata_atom
{
	/* RDATA_WF_COMPRESSED_DNAME, RDATA_WF_UNCOMPRESSED_DNAME */
	domain_type* domain;

	/* Default. */
	uint16_t*    data;
};

/*
 * Create a new domain_table containing only the root domain.
 */
domain_table_type *domain_table_create(region_type *region);

/*
 * Search the domain table for a match and the closest encloser.
 */
int domain_table_search(domain_table_type* table,
			const dname_type* dname,
			domain_type      **closest_match,
			domain_type      **closest_encloser);

/*
 * The number of domains stored in the table (minimum is one for the
 * root domain).
 */
static inline uint32_t
domain_table_count(domain_table_type* table)
{
#ifdef USE_RADIX_TREE
	return table->nametree->count;
#else
	return table->names_to_domains->count;
#endif
}

/*
 * Find the specified dname in the domain_table.  NULL is returned if
 * there is no exact match.
 */
domain_type* domain_table_find(domain_table_type* table,
			       const dname_type* dname);

/*
 * Insert a domain name in the domain table.  If the domain name is
 * not yet present in the table it is copied and a new dname_info node
 * is created (as well as for the missing parent domain names, if
 * any).  Otherwise the domain_type that is already in the
 * domain_table is returned.
 */
domain_type *domain_table_insert(domain_table_type *table,
				 const dname_type  *dname);

/* put domain into nsec3 hash space tree */
void zone_add_domain_in_hash_tree(region_type* region, rbtree_type** tree,
	int (*cmpf)(const void*, const void*), domain_type* domain,
	rbnode_type* node);
void zone_del_domain_in_hash_tree(rbtree_type* tree, rbnode_type* node);
void hash_tree_clear(rbtree_type* tree);
void hash_tree_delete(region_type* region, rbtree_type* tree);
void prehash_clear(domain_table_type* table);
void prehash_add(domain_table_type* table, domain_type* domain);
void prehash_del(domain_table_type* table, domain_type* domain);
int domain_is_prehash(domain_table_type* table, domain_type* domain);

/*
 * Add an RRset to the specified domain.  Updates the is_existing flag
 * as required.
 */
void domain_add_rrset(domain_type* domain, rrset_type* rrset);

rrset_type* domain_find_rrset(domain_type* domain, zone_type* zone, uint16_t type);
rrset_type* domain_find_any_rrset(domain_type* domain, zone_type* zone);

zone_type* domain_find_zone(namedb_type* db, domain_type* domain);
zone_type* domain_find_parent_zone(namedb_type* db, zone_type* zone);

domain_type* domain_find_ns_rrsets(domain_type* domain, zone_type* zone, rrset_type **ns);
/* find DNAME rrset in domain->parent or higher and return that domain */
domain_type * find_dname_above(domain_type* domain, zone_type* zone);

int domain_is_glue(domain_type* domain, zone_type* zone);

rrset_type* domain_find_non_cname_rrset(domain_type* domain, zone_type* zone);

domain_type* domain_wildcard_child(domain_type* domain);
domain_type *domain_previous_existing_child(domain_type* domain);

int zone_is_secure(zone_type* zone);

static inline dname_type *
domain_dname(domain_type* domain)
{
#ifdef USE_RADIX_TREE
	return (dname_type *) domain->dname;
#else
	return (dname_type *) domain->node.key;
#endif
}

static inline const dname_type *
domain_dname_const(const domain_type* domain)
{
#ifdef USE_RADIX_TREE
	return domain->dname;
#else
	return (const dname_type *) domain->node.key;
#endif
}

static inline domain_type *
domain_previous(domain_type* domain)
{
#ifdef USE_RADIX_TREE
	struct radnode* prev = radix_prev(domain->rnode);
	return prev == NULL ? NULL : (domain_type*)prev->elem;
#else
	rbnode_type *prev = rbtree_previous((rbnode_type *) domain);
	return prev == RBTREE_NULL ? NULL : (domain_type *) prev;
#endif
}

static inline domain_type *
domain_next(domain_type* domain)
{
#ifdef USE_RADIX_TREE
	struct radnode* next = radix_next(domain->rnode);
	return next == NULL ? NULL : (domain_type*)next->elem;
#else
	rbnode_type *next = rbtree_next((rbnode_type *) domain);
	return next == RBTREE_NULL ? NULL : (domain_type *) next;
#endif
}

/* easy comparison for subdomain, true if d1 is subdomain of d2. */
static inline int domain_is_subdomain(domain_type* d1, domain_type* d2)
{ return dname_is_subdomain(domain_dname(d1), domain_dname(d2)); }
/* easy printout, to static buffer of dname_to_string, fqdn. */
static inline const char* domain_to_string(domain_type* domain)
{ return dname_to_string(domain_dname(domain), NULL); }

/*
 * The type covered by the signature in the specified RRSIG RR.
 */
uint16_t rr_rrsig_type_covered(rr_type* rr);

struct namedb
{
	region_type*       region;
	domain_table_type* domains;
	struct radtree*    zonetree;
	struct udb_base*   udb;
	/* the timestamp on the ixfr.db file */
	struct timeval	  diff_timestamp;
	/* if diff_skip=1, diff_pos contains the nsd.diff place to continue */
	uint8_t		  diff_skip;
	off_t		  diff_pos;
};

static inline int rdata_atom_is_domain(uint16_t type, size_t index);
static inline int rdata_atom_is_literal_domain(uint16_t type, size_t index);

static inline domain_type *
rdata_atom_domain(rdata_atom_type atom)
{
	return atom.domain;
}

static inline uint16_t
rdata_atom_size(rdata_atom_type atom)
{
	return *atom.data;
}

static inline uint8_t *
rdata_atom_data(rdata_atom_type atom)
{
	return (uint8_t *) (atom.data + 1);
}


/* Find the zone for the specified dname in DB. */
zone_type *namedb_find_zone(namedb_type *db, const dname_type *dname);
/*
 * Delete a domain name from the domain table.  Removes dname_info node.
 * Only deletes if usage is 0, has no rrsets and no children.  Checks parents
 * for deletion as well.  Adjusts numberlist(domain.number), and 
 * wcard_child closest match.
 */
void domain_table_deldomain(namedb_type* db, domain_type* domain);


/** dbcreate.c */
int udb_write_rr(struct udb_base* udb, struct udb_ptr* z, rr_type* rr);
void udb_del_rr(struct udb_base* udb, struct udb_ptr* z, rr_type* rr);
int write_zone_to_udb(struct udb_base* udb, zone_type* zone,
	struct timespec* mtime, const char* file_str);
/** marshal rdata into buffer, must be MAX_RDLENGTH in size */
size_t rr_marshal_rdata(rr_type* rr, uint8_t* rdata, size_t sz);
/* dbaccess.c */
int namedb_lookup (struct namedb* db,
		   const dname_type* dname,
		   domain_type     **closest_match,
		   domain_type     **closest_encloser);
/* pass number of children (to alloc in dirty array */
struct namedb *namedb_open(const char *filename, struct nsd_options* opt);
void namedb_close_udb(struct namedb* db);
void namedb_close(struct namedb* db);
void namedb_check_zonefiles(struct nsd* nsd, struct nsd_options* opt,
	struct udb_base* taskudb, struct udb_ptr* last_task);
void namedb_check_zonefile(struct nsd* nsd, struct udb_base* taskudb,
	struct udb_ptr* last_task, struct zone_options* zo);
/** zone one zonefile into memory and revert on parse error, write to udb */
void namedb_read_zonefile(struct nsd* nsd, struct zone* zone,
	struct udb_base* taskudb, struct udb_ptr* last_task);
void apex_rrset_checks(struct namedb* db, rrset_type* rrset,
	domain_type* domain);
zone_type* namedb_zone_create(namedb_type* db, const dname_type* dname,
        struct zone_options* zopt);
void namedb_zone_delete(namedb_type* db, zone_type* zone);
void namedb_write_zonefile(struct nsd* nsd, struct zone_options* zopt);
void namedb_write_zonefiles(struct nsd* nsd, struct nsd_options* options);
int create_dirs(const char* path);
int file_get_mtime(const char* file, struct timespec* mtime, int* nonexist);
void allocate_domain_nsec3(domain_table_type *table, domain_type *result);

static inline int
rdata_atom_is_domain(uint16_t type, size_t index)
{
	const rrtype_descriptor_type *descriptor
		= rrtype_descriptor_by_type(type);
	return (index < descriptor->maximum
		&& (descriptor->wireformat[index] == RDATA_WF_COMPRESSED_DNAME
		    || descriptor->wireformat[index] == RDATA_WF_UNCOMPRESSED_DNAME));
}

static inline int
rdata_atom_is_literal_domain(uint16_t type, size_t index)
{
	const rrtype_descriptor_type *descriptor
		= rrtype_descriptor_by_type(type);
	return (index < descriptor->maximum
		&& (descriptor->wireformat[index] == RDATA_WF_LITERAL_DNAME));
}

static inline rdata_wireformat_type
rdata_atom_wireformat_type(uint16_t type, size_t index)
{
	const rrtype_descriptor_type *descriptor
		= rrtype_descriptor_by_type(type);
	assert(index < descriptor->maximum);
	return (rdata_wireformat_type) descriptor->wireformat[index];
}

static inline uint16_t
rrset_rrtype(rrset_type* rrset)
{
	assert(rrset);
	assert(rrset->rr_count > 0);
	return rrset->rrs[0].type;
}

static inline uint16_t
rrset_rrclass(rrset_type* rrset)
{
	assert(rrset);
	assert(rrset->rr_count > 0);
	return rrset->rrs[0].klass;
}

#endif
@


1.7
log
@Update to 4.1.13
Testing millert, brad and myself.
OK millert@@
@
text
@d43 1
a43 1
	rbtree_t      *names_to_domains;
d66 1
a66 1
	rbnode_t nsec3_node;
d68 1
a68 1
	rbnode_t hash_node;
d70 1
a70 1
	rbnode_t wchash_node;
d72 1
a72 1
	rbnode_t dshash_node;
d97 1
a97 1
	rbnode_t     node;
d130 4
a133 4
	rbtree_t* nsec3tree; /* tree with relevant NSEC3 domains */
	rbtree_t* hashtree; /* tree, hashed NSEC3precompiled domains */
	rbtree_t* wchashtree; /* tree, wildcard hashed domains */
	rbtree_t* dshashtree; /* tree, ds-parent-hash domains */
d226 1
a226 1
void zone_add_domain_in_hash_tree(region_type* region, rbtree_t** tree,
d228 4
a231 4
	rbnode_t* node);
void zone_del_domain_in_hash_tree(rbtree_t* tree, rbnode_t* node);
void hash_tree_clear(rbtree_t* tree);
void hash_tree_delete(region_type* region, rbtree_t* tree);
d289 1
a289 1
	rbnode_t *prev = rbtree_previous((rbnode_t *) domain);
d301 1
a301 1
	rbnode_t *next = rbtree_next((rbnode_t *) domain);
@


1.6
log
@update to 4.1.11
"Working fine here." millert@@
OK dlg, sthen
@
text
@d40 1
d42 3
d93 1
d96 3
d201 1
d203 3
d262 10
d273 1
a273 1
domain_dname(domain_type* domain)
d275 1
d277 3
d285 1
d288 4
d297 1
d300 4
@


1.5
log
@Update to 4.1.10
Testing by millert@@, sthen@@ and me.
came up with the same diff & OK sthen@@
@
text
@d235 1
a235 1
zone_type* domain_find_parent_zone(zone_type* zone);
@


1.4
log
@merge conflicts
@
text
@d130 1
a130 1
	time_t       mtime; /* time of last modification */
d238 2
d331 2
a332 2
int write_zone_to_udb(struct udb_base* udb, zone_type* zone, time_t mtime,
	const char* file_str);
d359 1
@


1.3
log
@merge conflicts
@
text
@a225 10
 * Iterate over all the domain names in the domain tree.
 */
typedef int (*domain_table_iterator_type)(domain_type *node,
					   void *user_data);

int domain_table_iterate(domain_table_type* table,
			  domain_table_iterator_type iterator,
			  void* user_data);

/*
@


1.2
log
@Merge in some commits from upstream..

- Fix that failure to add tcp to tcp base does not leak the socket.
- Fixes for wildcard addition and deletion, speedup for some cases.
- Fix that queries for noname CH TXT are REFUSED instead of nodata.
- Fix #616: retry xfer for zones with no content after command.
- Fix that expired zones stay expired after a server restart.
- RFC 7344: CDS and CDNSKEY (read in).

ok sthen@@
@
text
@d131 1
@


1.1
log
@Initial revision
@
text
@d17 1
d21 3
a23 3

#define	NAMEDB_MAGIC		"NSDdbV07"
#define	NAMEDB_MAGIC_SIZE	8
d35 1
d39 10
a48 3
	region_type *region;
	rbtree_t      *names_to_domains;
	domain_type *root;
a50 6
struct domain
{
	rbnode_t     node;
	domain_type *parent;
	domain_type *wildcard_child_closest_match;
	rrset_type  *rrsets;
d52 1
d54 1
a54 1
	domain_type *nsec3_cover;
d56 1
a56 1
	domain_type *nsec3_wcard_child_cover;
d58 38
a95 10
	domain_type *nsec3_ds_parent_cover;
	/* the NSEC3 domain that has a hash-base32 <= than this dname. */
	/* or NULL (no smaller one within this zone)
	 * this variable is used to look up the NSEC3 record that matches
	 * or covers a given b64-encoded-hash-string domain name.
	 * The result of the lookup is stored in the *_cover variables.
	 * The variable makes it possible to perform a rbtree lookup for
	 * a name, then take this 'jump' to the previous element that contains
	 * an NSEC3 record, with hopefully the correct parameters. */
	domain_type *nsec3_lookup;
d97 6
a102 1
	uint32_t     number; /* Unique domain name number.  */
a108 6
#ifdef NSEC3
	/* if the domain has an NSEC3 for it, use cover ptr to get it. */
	unsigned     nsec3_is_exact : 1;
	/* same but on parent side */
	unsigned     nsec3_ds_parent_is_exact : 1;
#endif
d113 5
a117 5
	zone_type   *next;
	domain_type *apex;
	rrset_type  *soa_rrset;
	rrset_type  *soa_nx_rrset; /* see bug #103 */
	rrset_type  *ns_rrset;
d119 7
a125 2
	rr_type	    *nsec3_soa_rr; /* rrset with SOA bit set */
	domain_type *nsec3_last; /* last domain with nsec3, wraps */
d127 4
a130 3
	struct zone_options *opts;
	uint32_t     number;
	uint8_t*     dirty; /* array of dirty-flags, per child */
a131 1
	unsigned     updated : 1; /* zone SOA was updated */
d133 1
d138 2
a139 2
	domain_type     *owner;
	rdata_atom_type *rdatas;
d152 3
a154 3
	rrset_type *next;
	zone_type  *zone;
	rr_type    *rrs;
d166 1
a166 1
	domain_type *domain;
d169 1
a169 1
	uint16_t    *data;
d180 2
a181 2
int domain_table_search(domain_table_type *table,
			const dname_type  *dname,
d190 1
a190 1
domain_table_count(domain_table_type *table)
d192 1
a192 1
	return table->names_to_domains->count;
d199 2
a200 2
domain_type *domain_table_find(domain_table_type *table,
			       const dname_type  *dname);
d212 11
d230 1
a230 1
int domain_table_iterate(domain_table_type *table,
d232 1
a232 1
			  void *user_data);
d238 1
a238 1
void domain_add_rrset(domain_type *domain, rrset_type *rrset);
d240 2
a241 2
rrset_type *domain_find_rrset(domain_type *domain, zone_type *zone, uint16_t type);
rrset_type *domain_find_any_rrset(domain_type *domain, zone_type *zone);
d243 2
a244 2
zone_type *domain_find_zone(domain_type *domain);
zone_type *domain_find_parent_zone(zone_type *zone);
d246 1
a246 1
domain_type *domain_find_ns_rrsets(domain_type *domain, zone_type *zone, rrset_type **ns);
d248 1
a248 1
int domain_is_glue(domain_type *domain, zone_type *zone);
d250 1
a250 1
rrset_type *domain_find_non_cname_rrset(domain_type *domain, zone_type *zone);
d252 2
a253 1
domain_type *domain_wildcard_child(domain_type *domain);
d255 1
a255 1
int zone_is_secure(zone_type *zone);
d258 1
a258 1
domain_dname(domain_type *domain)
d260 1
a260 1
	return (const dname_type *) domain->node.key;
d264 1
a264 1
domain_previous(domain_type *domain)
d266 2
a267 2
	rbnode_t *prev = rbtree_previous((rbnode_t *) domain);
	return prev == RBTREE_NULL ? NULL : (domain_type *) prev;
d271 1
a271 1
domain_next(domain_type *domain)
d273 2
a274 2
	rbnode_t *next = rbtree_next((rbnode_t *) domain);
	return next == RBTREE_NULL ? NULL : (domain_type *) next;
d277 7
d287 1
a287 1
uint16_t rr_rrsig_type_covered(rr_type *rr);
a288 1
typedef struct namedb namedb_type;
d291 4
a294 6
	region_type       *region;
	domain_table_type *domains;
	zone_type         *zones;
	size_t	  	  zone_count;
	char              *filename;
	FILE              *fd;
a296 3
	/* the CRC on the nsd.db file and position of CRC in the db file */
	uint32_t	  crc;
	off_t		  crc_pos;
d303 1
d324 2
d327 15
a341 10
 * Find the zone for the specified DOMAIN in DB.
 */
zone_type *namedb_find_zone(namedb_type *db, domain_type *domain);

/* dbcreate.c */
struct namedb *namedb_new(const char *filename);
int namedb_save(struct namedb *db);
void namedb_discard(struct namedb *db);


d343 2
a344 2
int namedb_lookup (struct namedb    *db,
		   const dname_type *dname,
d348 19
a366 3
struct namedb *namedb_open(const char *filename, struct nsd_options* opt,
	size_t num_children);
void namedb_close(struct namedb *db);
d378 9
d397 1
a397 1
rrset_rrtype(rrset_type *rrset)
d405 1
a405 1
rrset_rrclass(rrset_type *rrset)
a410 1

@


1.1.1.1
log
@NSD v3.2.4
@
text
@@


1.1.1.2
log
@NSD v3.2.5
@
text
@a291 1
void namedb_fd_close(struct namedb *db);
@


1.1.1.3
log
@NSD v3.2.8
@
text
@d4 1
a4 1
 * Copyright (c) 2001-2011, NLnet Labs. All rights reserved.
@


1.1.1.4
log
@NSD v3.2.9
@
text
@d21 1
a21 1
#define	NAMEDB_MAGIC		"NSDdbV08"
d49 2
a50 4
	domain_type *nsec3_cover; /* != NULL is exact cover */
#ifdef FULL_PREHASH
	/* (if nsec3 chain complete) nsec_cover is always the covering nsec3
       record */
d64 1
a64 2
#endif /* FULL_PREHASH */
#endif /* NSEC3 */
a71 1
	unsigned     has_SOA : 1;
a72 1
#ifdef FULL_PREHASH
d77 1
a77 2
#endif /* FULL_PREHASH */
#endif /* NSEC3 */
d90 1
a90 4
#ifndef FULL_PREHASH
	rbtree_t    *nsec3_domains;
#endif /* !FULL_PREHASH */
#endif /* NSEC3 */
a98 15
#ifdef NSEC3
#ifndef FULL_PREHASH
struct nsec3_domain {
	rbnode_t node;
	struct domain *nsec3_domain;
	struct domain *covers;
};

struct nsec3_mod_domain {
	rbnode_t node;
	struct domain *domain;
};
#endif /* !FULL_PREHASH */
#endif /* NSEC3 */

a197 3
#ifndef FULL_PREHASH
domain_type *domain_find_zone_apex(domain_type *domain);
#endif /* !FULL_PREHASH */
a236 7
#ifdef NSEC3
#ifndef FULL_PREHASH
	region_type       *nsec3_region;
	region_type       *nsec3_mod_region;
	rbtree_t          *nsec3_mod_domains;
#endif /* !FULL_PREHASH */
#endif /* NSEC3 */
a329 23
/**
 * Allocate and initialize a struct namedb.
 * Returns a pointer to a valid struct namedb or NULL on failure.
 */
struct namedb * namedb_create(void);

/**
 * Destroy a struct namedb created using the namedb_create function.
 * Frees all regions associated with the namedb structure.
 */
void namedb_destroy(struct namedb *db);

#ifdef NSEC3
#ifndef FULL_PREHASH
int zone_nsec3_domains_create(struct namedb *db, struct zone *zone);
int zone_nsec3_domains_destroy(struct namedb *db, struct zone *zone);
int namedb_add_nsec3_domain(struct namedb *db, struct domain *domain, struct zone *zone);
int namedb_del_nsec3_domain(struct namedb *db, struct domain *domain, struct zone *zone);
int namedb_nsec3_mod_domains_create(struct namedb *db);
int namedb_nsec3_mod_domains_destroy(struct namedb *db);
int namedb_add_nsec3_mod_domain(struct namedb *db, struct domain *domain);
#endif /* !FULL_PREHASH */
#endif /* NSEC3 */
@


1.1.1.5
log
@import nsd 3.2.10, "cool" jakob@@, also looked over by Brad
@
text
@a45 1
	domain_type *nextdiff;
@


1.1.1.6
log
@NSD v3.2.11, ok phessler@@
@
text
@a17 1
#include "util.h"
a100 5

#if defined(BIND8_STATS) && defined(USE_ZONE_STATS)
	struct nsdst st;
#endif /* defined(BIND8_STATS) && defined(USE_ZONE_STATS) */

@


1.1.1.7
log
@import NSD 4.0.0, tests from Dorian Büttner, Patrik Lundin, requested by brad@@
@
text
@d4 1
a4 1
 * Copyright (c) 2001-2006, NLnet Labs. All rights reserved.
a16 1
#include "radtree.h"
d18 1
d21 3
a23 2
struct udb_base;
struct udb_ptr;
d38 3
a40 10
	region_type* region;
	struct radtree *nametree;
	domain_type* root;
	/* ptr to biggest domain.number and last in list.
	 * the root is the lowest and first in the list. */
	domain_type *numlist_last;
#ifdef NSEC3
	/* the prehash list, start of the list */
	domain_type* prehash_list;
#endif /* NSEC3 */
d43 7
d51 4
a54 3
struct nsec3_domain_data {
	/* (if nsec3 chain complete) always the covering nsec3 record */
	domain_type* nsec3_cover;
d56 1
a56 1
	domain_type* nsec3_wcard_child_cover;
d58 11
a68 27
	domain_type* nsec3_ds_parent_cover;
	/* NSEC3 domains to prehash, prev and next on the list or cleared */
	domain_type* prehash_prev, *prehash_next;
	/* entry in the nsec3tree (for NSEC3s in the chain in use) */
	rbnode_t nsec3_node;
	/* entry in the hashtree (for precompiled domains) */
	rbnode_t hash_node;
	/* entry in the wchashtree (the wildcard precompile) */
	rbnode_t wchash_node;
	/* entry in the dshashtree (the parent ds precompile) */
	rbnode_t dshash_node;

	/* nsec3 hash */
	uint8_t nsec3_hash[NSEC3_HASH_LEN];
	/* nsec3 hash of wildcard before this name */
	uint8_t nsec3_wc_hash[NSEC3_HASH_LEN];
	/* parent-side DS hash */
	uint8_t nsec3_ds_parent_hash[NSEC3_HASH_LEN];
	/* if the nsec3 has is available */
	unsigned  have_nsec3_hash : 1;
	unsigned  have_nsec3_wc_hash : 1;
	unsigned  have_nsec3_ds_parent_hash : 1;
	/* if the domain has an NSEC3 for it, use cover ptr to get it. */
	unsigned     nsec3_is_exact : 1;
	/* same but on parent side */
	unsigned     nsec3_ds_parent_is_exact : 1;
};
d70 1
a70 17

struct domain
{
	struct radnode* rnode;
	const dname_type* dname;
	domain_type* parent;
	domain_type* wildcard_child_closest_match;
	rrset_type* rrsets;
#ifdef NSEC3
	struct nsec3_domain_data* nsec3;
#endif
	/* double-linked list sorted by domain.number */
	domain_type* numlist_prev, *numlist_next;
	size_t     number; /* Unique domain name number.  */
	size_t     usage; /* number of ptrs to this from RRs(in rdata) and
			     from zone-apex pointers, also the root has one
			     more to make sure it cannot be deleted. */
d77 9
d90 5
a94 5
	struct radnode *node; /* this entry in zonetree */
	domain_type* apex;
	rrset_type*  soa_rrset;
	rrset_type*  soa_nx_rrset; /* see bug #103 */
	rrset_type*  ns_rrset;
d96 14
a109 9
	rr_type* nsec3_param; /* NSEC3PARAM RR of chain in use or NULL */
	domain_type* nsec3_last; /* last domain with nsec3, wraps */
	/* in these trees, the root contains an elem ptr to the radtree* */
	rbtree_t* nsec3tree; /* tree with relevant NSEC3 domains */
	rbtree_t* hashtree; /* tree, hashed NSEC3precompiled domains */
	rbtree_t* wchashtree; /* tree, wildcard hashed domains */
	rbtree_t* dshashtree; /* tree, ds-parent-hash domains */
#endif
	struct zone_options* opts;
d111 1
a112 1
	unsigned     is_changed : 1; /* zone was changed by AXFR */
d115 15
d132 2
a133 2
	domain_type*     owner;
	rdata_atom_type* rdatas;
d146 3
a148 3
	rrset_type* next;
	zone_type*  zone;
	rr_type*    rrs;
d160 1
a160 1
	domain_type* domain;
d163 1
a163 1
	uint16_t*    data;
d174 2
a175 2
int domain_table_search(domain_table_type* table,
			const dname_type* dname,
d184 1
a184 1
domain_table_count(domain_table_type* table)
d186 1
a186 1
	return table->nametree->count;
d193 2
a194 2
domain_type* domain_table_find(domain_table_type* table,
			       const dname_type* dname);
a205 11
/* put domain into nsec3 hash space tree */
void zone_add_domain_in_hash_tree(region_type* region, rbtree_t** tree,
	int (*cmpf)(const void*, const void*), domain_type* domain,
	rbnode_t* node);
void zone_del_domain_in_hash_tree(rbtree_t* tree, rbnode_t* node);
void hash_tree_clear(rbtree_t* tree);
void hash_tree_delete(region_type* region, rbtree_t* tree);
void prehash_clear(domain_table_type* table);
void prehash_add(domain_table_type* table, domain_type* domain);
void prehash_del(domain_table_type* table, domain_type* domain);
int domain_is_prehash(domain_table_type* table, domain_type* domain);
d213 1
a213 1
int domain_table_iterate(domain_table_type* table,
d215 1
a215 1
			  void* user_data);
d221 1
a221 1
void domain_add_rrset(domain_type* domain, rrset_type* rrset);
d223 2
a224 2
rrset_type* domain_find_rrset(domain_type* domain, zone_type* zone, uint16_t type);
rrset_type* domain_find_any_rrset(domain_type* domain, zone_type* zone);
d226 2
a227 2
zone_type* domain_find_zone(domain_type* domain);
zone_type* domain_find_parent_zone(zone_type* zone);
d229 4
a232 1
domain_type* domain_find_ns_rrsets(domain_type* domain, zone_type* zone, rrset_type **ns);
d234 1
a234 1
int domain_is_glue(domain_type* domain, zone_type* zone);
d236 1
a236 1
rrset_type* domain_find_non_cname_rrset(domain_type* domain, zone_type* zone);
d238 1
a238 1
domain_type* domain_wildcard_child(domain_type* domain);
d240 1
a240 1
int zone_is_secure(zone_type* zone);
d243 1
a243 1
domain_dname(domain_type* domain)
d245 1
a245 1
	return domain->dname;
d249 1
a249 1
domain_previous(domain_type* domain)
d251 2
a252 2
	struct radnode* prev = radix_prev(domain->rnode);
	return prev == NULL ? NULL : (domain_type*)prev->elem;
d256 1
a256 1
domain_next(domain_type* domain)
d258 2
a259 2
	struct radnode* next = radix_next(domain->rnode);
	return next == NULL ? NULL : (domain_type*)next->elem;
a261 7
/* easy comparison for subdomain, true if d1 is subdomain of d2. */
static inline int domain_is_subdomain(domain_type* d1, domain_type* d2)
{ return dname_is_subdomain(domain_dname(d1), domain_dname(d2)); }
/* easy printout, to static buffer of dname_to_string, fqdn. */
static inline const char* domain_to_string(domain_type* domain)
{ return dname_to_string(domain_dname(domain), NULL); }

d265 1
a265 1
uint16_t rr_rrsig_type_covered(rr_type* rr);
d270 13
a282 4
	region_type*       region;
	domain_table_type* domains;
	struct radtree*    zonetree;
	struct udb_base*   udb;
d285 3
a293 1
static inline int rdata_atom_is_literal_domain(uint16_t type, size_t index);
a313 2
/* Find the zone for the specified dname in DB. */
zone_type *namedb_find_zone(namedb_type *db, const dname_type *dname);
d315 10
a324 14
 * Delete a domain name from the domain table.  Removes dname_info node.
 * Only deletes if usage is 0, has no rrsets and no children.  Checks parents
 * for deletion as well.  Adjusts numberlist(domain.number), and 
 * wcard_child closest match.
 */
void domain_table_deldomain(namedb_type* db, domain_type* domain);


/** dbcreate.c */
int udb_write_rr(struct udb_base* udb, struct udb_ptr* z, rr_type* rr);
void udb_del_rr(struct udb_base* udb, struct udb_ptr* z, rr_type* rr);
int write_zone_to_udb(struct udb_base* udb, zone_type* zone, time_t mtime);
/** marshal rdata into buffer, must be MAX_RDLENGTH in size */
size_t rr_marshal_rdata(rr_type* rr, uint8_t* rdata, size_t sz);
d326 2
a327 2
int namedb_lookup (struct namedb* db,
		   const dname_type* dname,
d331 4
a334 19
struct namedb *namedb_open(const char *filename, struct nsd_options* opt);
void namedb_close_udb(struct namedb* db);
void namedb_close(struct namedb* db);
void namedb_check_zonefiles(struct namedb* db, struct nsd_options* opt,
	struct udb_base* taskudb, struct udb_ptr* last_task);
void namedb_check_zonefile(struct namedb* db, struct udb_base* taskudb,
	struct udb_ptr* last_task, struct zone_options* zo);
/** zone one zonefile into memory and revert on parse error, write to udb */
void namedb_read_zonefile(struct namedb* db, struct zone* zone,
	struct udb_base* taskudb, struct udb_ptr* last_task);
void apex_rrset_checks(struct namedb* db, rrset_type* rrset,
	domain_type* domain);
zone_type* namedb_zone_create(namedb_type* db, const dname_type* dname,
        struct zone_options* zopt);
void namedb_zone_delete(namedb_type* db, zone_type* zone);
void namedb_write_zonefile(namedb_type* db, struct zone_options* zopt);
void namedb_write_zonefiles(namedb_type* db, struct nsd_options* options);
int create_dirs(const char* path);
void allocate_domain_nsec3(domain_table_type *table, domain_type *result);
a345 9
static inline int
rdata_atom_is_literal_domain(uint16_t type, size_t index)
{
	const rrtype_descriptor_type *descriptor
		= rrtype_descriptor_by_type(type);
	return (index < descriptor->maximum
		&& (descriptor->wireformat[index] == RDATA_WF_LITERAL_DNAME));
}

d356 1
a356 1
rrset_rrtype(rrset_type* rrset)
d364 1
a364 1
rrset_rrclass(rrset_type* rrset)
d370 24
@


1.1.1.8
log
@update to NSD 4.0.1, ok sthen@@
@
text
@a22 1
struct nsd;
d345 1
a345 1
void namedb_check_zonefiles(struct nsd* nsd, struct nsd_options* opt,
d347 1
a347 1
void namedb_check_zonefile(struct nsd* nsd, struct udb_base* taskudb,
d350 1
a350 1
void namedb_read_zonefile(struct nsd* nsd, struct zone* zone,
d357 2
a358 2
void namedb_write_zonefile(struct nsd* nsd, struct zone_options* zopt);
void namedb_write_zonefiles(struct nsd* nsd, struct nsd_options* options);
@


1.1.1.9
log
@update to NSD 4.0.2, ok sthen@@
@
text
@a34 1
typedef struct namedb namedb_type;
d239 1
a239 1
zone_type* domain_find_zone(namedb_type* db, domain_type* domain);
d284 1
d334 1
a334 2
int write_zone_to_udb(struct udb_base* udb, zone_type* zone, time_t mtime,
	const char* file_str);
@


1.1.1.10
log
@update to NSD 4.1.0, ok sthen@@
@
text
@a127 3
	char*        filename; /* set if read from file, which file */
	char*        logstr; /* set for zone xfer, the log string */
	time_t       mtime; /* time of last modification */
@


1.1.1.11
log
@update to NSD 4.1.1, ok sthen@@
@
text
@a130 1
	unsigned     zonestatid; /* array index for zone stats */
a252 1
domain_type *domain_previous_existing_child(domain_type* domain);
@


1.1.1.12
log
@update to NSD 4.1.3, ok florian@@, also tested by brad
@
text
@d226 10
@


