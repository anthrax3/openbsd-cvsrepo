head	1.2;
access;
symbols
	OPENBSD_6_1:1.2.0.4
	OPENBSD_6_1_BASE:1.2
	OPENBSD_6_0:1.1.1.8.0.4
	OPENBSD_6_0_BASE:1.1.1.8
	OPENBSD_5_9:1.1.1.8.0.2
	OPENBSD_5_9_BASE:1.1.1.8
	NSD_4_1_6:1.1.1.8
	OPENBSD_5_8:1.1.1.7.0.8
	OPENBSD_5_8_BASE:1.1.1.7
	NSD_4_1_3:1.1.1.7
	OPENBSD_5_7:1.1.1.7.0.2
	OPENBSD_5_7_BASE:1.1.1.7
	NSD_4_1_1:1.1.1.7
	NSD_4_1_0:1.1.1.7
	OPENBSD_5_6:1.1.1.7.0.4
	OPENBSD_5_6_BASE:1.1.1.7
	NSD_4_0_3:1.1.1.7
	NSD_4_0_2:1.1.1.7
	OPENBSD_5_5:1.1.1.6.0.4
	OPENBSD_5_5_BASE:1.1.1.6
	NSD_4_0_1:1.1.1.6
	NSD_4_0_0:1.1.1.6
	NSD_3_2_16:1.1.1.5
	OPENBSD_5_4:1.1.1.5.0.6
	OPENBSD_5_4_BASE:1.1.1.5
	OPENBSD_5_3:1.1.1.5.0.4
	OPENBSD_5_3_BASE:1.1.1.5
	NSD_3_2_15:1.1.1.5
	NSD_3_2_14:1.1.1.5
	NSD_3_2_13:1.1.1.5
	OPENBSD_5_2:1.1.1.5.0.2
	OPENBSD_5_2_BASE:1.1.1.5
	NSD_3_2_11:1.1.1.5
	NSD_3_2_10:1.1.1.4
	OPENBSD_5_1_BASE:1.1.1.4
	OPENBSD_5_1:1.1.1.4.0.2
	NSD_3_2_9:1.1.1.4
	OPENBSD_5_0:1.1.1.3.0.2
	OPENBSD_5_0_BASE:1.1.1.3
	NSD_3_2_8:1.1.1.3
	OPENBSD_4_9:1.1.1.2.0.2
	OPENBSD_4_9_BASE:1.1.1.2
	NSD_3_2_6:1.1.1.2
	OPENBSD_4_8:1.1.1.1.0.4
	OPENBSD_4_8_BASE:1.1.1.1
	NSD_3_2_5:1.1.1.1
	OPENBSD_4_7:1.1.1.1.0.2
	OPENBSD_4_7_BASE:1.1.1.1
	NSD_3_2_4:1.1.1.1
	NLNETLABS:1.1.1;
locks; strict;
comment	@ * @;


1.2
date	2017.02.17.20.04.45;	author florian;	state Exp;
branches;
next	1.1;
commitid	WmSuN5M3Jbe54113;

1.1
date	2010.01.15.19.24.57;	author jakob;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2010.01.15.19.24.57;	author jakob;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2010.08.22.09.21.37;	author jakob;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2011.05.21.18.17.18;	author jakob;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2012.01.29.11.15.36;	author jakob;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2012.07.09.21.55.07;	author sthen;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2013.11.26.12.50.19;	author sthen;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2014.03.13.02.00.28;	author brad;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2015.11.05.21.21.05;	author sthen;	state Exp;
branches;
next	;
commitid	RXfGmPAh2IZTjnIf;


desc
@@


1.2
log
@Update to 4.1.15.
This contains a local patch to query.c (missed _t conversion) that has
been submitted upstream.
OK sthen
@
text
@/*
 * xfrd-notify.h - notify sending routines.
 *
 * Copyright (c) 2006, NLnet Labs. All rights reserved.
 *
 * See LICENSE for the license.
 *
 */

#ifndef XFRD_NOTIFY_H
#define XFRD_NOTIFY_H

#ifndef USE_MINI_EVENT
#  ifdef HAVE_EVENT_H
#    include <event.h>
#  else
#    include <event2/event.h>
#    include "event2/event_struct.h"
#    include "event2/event_compat.h"
#  endif
#else
#  include "mini_event.h"
#endif
#include "tsig.h"
#include "rbtree.h"

struct nsd;
struct region;
struct xfrd_zone;
struct zone_options;
struct zone;
struct xfrd_soa;
struct acl_options;
struct xfrd_state;

/**
 * This struct keeps track of outbound notifies for a zone.
 */
struct notify_zone {
	rbnode_type node;
	/* name of the zone */
	const dname_type* apex;
	const char* apex_str;

	tsig_record_type notify_tsig; /* tsig state for notify */
	struct zone_options* options;
	struct xfrd_soa *current_soa; /* current SOA in NSD */

	/* notify sending handler */
	/* Not saved on disk (i.e. kill of daemon stops notifies) */
	int notify_send_enable;
	struct event notify_send_handler;
	struct timeval notify_timeout;
	struct acl_options* notify_current; /* current slave to notify */
	uint8_t notify_restart; /* restart notify after repattern */
	uint8_t notify_retry; /* how manieth retry in sending to current */
	uint16_t notify_query_id;

	/* is this notify waiting for a socket? */
	uint8_t is_waiting;
	/* the double linked waiting list for the udp sockets */
	struct notify_zone* waiting_next;
	struct notify_zone* waiting_prev;
};

/* initialise outgoing notifies */
void init_notify_send(rbtree_type* tree, region_type* region,
	struct zone_options* options);
/* delete notify zone */
void xfrd_del_notify(struct xfrd_state* xfrd, const dname_type* dname);

/* send notifications to all in the notify list */
void xfrd_send_notify(rbtree_type* tree, const struct dname* apex,
	struct xfrd_soa* new_soa);
/* start notifications, if not started already (does not clobber SOA) */
void xfrd_notify_start(struct notify_zone* zone, struct xfrd_state* xfrd);

/* handle soa update notify for a master zone. newsoa can be NULL.
   Makes sure that the soa (serial) has changed. Or drops notify. */
void notify_handle_master_zone_soainfo(rbtree_type* tree,
	const dname_type* apex, struct xfrd_soa* new_soa);

/* close fds in use for notification sending */
void close_notify_fds(rbtree_type* tree);
/* stop send of notify */
void notify_disable(struct notify_zone* zone);

#endif /* XFRD_NOTIFY_H */
@


1.1
log
@Initial revision
@
text
@d13 11
a23 1
#include <config.h>
a24 1
#include "netio.h"
d34 1
d39 2
a40 2
struct notify_zone_t {
	rbnode_t node;
d45 1
a45 3
#ifdef TSIG
        tsig_record_type notify_tsig; /* tsig state for notify */
#endif
d51 3
a53 2
	netio_handler_type notify_send_handler;
	struct timespec notify_timeout;
d55 1
d61 3
a63 2
	/* next in the waiting list for the udp sockets */
	struct notify_zone_t* waiting_next;
d67 4
a70 3
void init_notify_send(rbtree_t* tree, netio_type* netio, region_type* region,
        const dname_type* apex, struct zone_options* options,
	struct zone* dbzone);
d73 1
a73 1
void xfrd_send_notify(rbtree_t* tree, const struct dname* apex,
d75 2
d80 1
a80 1
void notify_handle_master_zone_soainfo(rbtree_t* tree,
d84 3
a86 1
void close_notify_fds(rbtree_t* tree);
@


1.1.1.1
log
@NSD v3.2.4
@
text
@@


1.1.1.2
log
@NSD v3.2.6
@
text
@d35 1
d37 1
@


1.1.1.3
log
@NSD v3.2.8
@
text
@d4 1
a4 1
 * Copyright (c) 2006-2011, NLnet Labs. All rights reserved.
@


1.1.1.4
log
@NSD v3.2.9
@
text
@d4 1
a4 1
 * Copyright (c) 2001-2011, NLnet Labs. All rights reserved.
d35 1
a35 1
	tsig_record_type notify_tsig; /* tsig state for notify */
@


1.1.1.5
log
@NSD v3.2.11, ok phessler@@
@
text
@d13 1
a13 1
#include "config.h"
@


1.1.1.6
log
@import NSD 4.0.0, tests from Dorian BÃ¼ttner, Patrik Lundin, requested by brad@@
@
text
@d4 1
a4 1
 * Copyright (c) 2006, NLnet Labs. All rights reserved.
d13 1
a13 5
#ifndef USE_MINI_EVENT
#include <event.h>
#else
#include "mini_event.h"
#endif
d15 1
a24 1
struct xfrd_state;
d41 2
a42 3
	int notify_send_enable;
	struct event notify_send_handler;
	struct timeval notify_timeout;
a43 1
	uint8_t notify_restart; /* restart notify after repattern */
d49 1
a49 1
	/* the double linked waiting list for the udp sockets */
a50 1
	struct notify_zone_t* waiting_prev;
d54 3
a56 4
void init_notify_send(rbtree_t* tree, region_type* region,
	struct zone_options* options);
/* delete notify zone */
void xfrd_del_notify(struct xfrd_state* xfrd, const dname_type* dname);
a60 2
/* start notifications, if not started already (does not clobber SOA) */
void xfrd_notify_start(struct notify_zone_t* zone);
a68 2
/* stop send of notify */
void notify_disable(struct notify_zone_t* zone);
@


1.1.1.7
log
@update to NSD 4.0.2, ok sthen@@
@
text
@d14 1
a14 7
#  ifdef HAVE_EVENT_H
#    include <event.h>
#  else
#    include <event2/event.h>
#    include "event2/event_struct.h"
#    include "event2/event_compat.h"
#  endif
d16 1
a16 1
#  include "mini_event.h"
@


1.1.1.8
log
@update to NSD 4.1.6, ok millert@@ florian@@
@
text
@d76 1
a76 1
void xfrd_notify_start(struct notify_zone_t* zone, struct xfrd_state* xfrd);
@


