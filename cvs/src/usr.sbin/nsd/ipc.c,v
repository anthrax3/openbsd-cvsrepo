head	1.3;
access;
symbols
	OPENBSD_6_2:1.3.0.2
	OPENBSD_6_2_BASE:1.3
	OPENBSD_6_1:1.3.0.4
	OPENBSD_6_1_BASE:1.3
	OPENBSD_6_0:1.1.1.9.0.8
	OPENBSD_6_0_BASE:1.1.1.9
	OPENBSD_5_9:1.1.1.9.0.4
	OPENBSD_5_9_BASE:1.1.1.9
	NSD_4_1_6:1.1.1.9
	OPENBSD_5_8:1.1.1.9.0.6
	OPENBSD_5_8_BASE:1.1.1.9
	NSD_4_1_3:1.1.1.9
	OPENBSD_5_7:1.1.1.9.0.2
	OPENBSD_5_7_BASE:1.1.1.9
	NSD_4_1_1:1.1.1.9
	NSD_4_1_0:1.1.1.8
	OPENBSD_5_6:1.1.1.7.0.6
	OPENBSD_5_6_BASE:1.1.1.7
	NSD_4_0_3:1.1.1.7
	NSD_4_0_2:1.1.1.7
	OPENBSD_5_5:1.1.1.7.0.4
	OPENBSD_5_5_BASE:1.1.1.7
	NSD_4_0_1:1.1.1.7
	NSD_4_0_0:1.1.1.7
	NSD_3_2_16:1.1.1.6
	OPENBSD_5_4:1.1.1.5.0.4
	OPENBSD_5_4_BASE:1.1.1.5
	OPENBSD_5_3:1.1.1.5.0.2
	OPENBSD_5_3_BASE:1.1.1.5
	NSD_3_2_15:1.1.1.5
	NSD_3_2_14:1.1.1.4
	NSD_3_2_13:1.1.1.3
	OPENBSD_5_2:1.1.1.3.0.2
	OPENBSD_5_2_BASE:1.1.1.3
	NSD_3_2_11:1.1.1.3
	NSD_3_2_10:1.1.1.2
	OPENBSD_5_1_BASE:1.1.1.2
	OPENBSD_5_1:1.1.1.2.0.4
	NSD_3_2_9:1.1.1.2
	OPENBSD_5_0:1.1.1.2.0.2
	OPENBSD_5_0_BASE:1.1.1.2
	NSD_3_2_8:1.1.1.2
	OPENBSD_4_9:1.1.1.1.0.6
	OPENBSD_4_9_BASE:1.1.1.1
	NSD_3_2_6:1.1.1.1
	OPENBSD_4_8:1.1.1.1.0.4
	OPENBSD_4_8_BASE:1.1.1.1
	NSD_3_2_5:1.1.1.1
	OPENBSD_4_7:1.1.1.1.0.2
	OPENBSD_4_7_BASE:1.1.1.1
	NSD_3_2_4:1.1.1.1
	NLNETLABS:1.1.1;
locks; strict;
comment	@ * @;


1.3
date	2017.02.17.20.04.45;	author florian;	state Exp;
branches;
next	1.2;
commitid	WmSuN5M3Jbe54113;

1.2
date	2016.08.31.07.31.20;	author florian;	state Exp;
branches;
next	1.1;
commitid	1gMwFuybgH2l617m;

1.1
date	2010.01.15.19.24.58;	author jakob;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2010.01.15.19.24.58;	author jakob;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2011.05.21.18.17.25;	author jakob;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2012.07.09.21.55.08;	author sthen;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2012.11.23.20.29.15;	author sthen;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2013.02.18.10.17.43;	author sthen;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2013.09.03.09.21.36;	author sthen;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2013.11.26.12.50.23;	author sthen;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2014.09.16.16.54.04;	author brad;	state Exp;
branches;
next	1.1.1.9;
commitid	BWSdZeElrpYSRdME;

1.1.1.9
date	2015.02.03.10.24.33;	author brad;	state Exp;
branches;
next	;
commitid	yn8l9RVkmdMVYIfl;


desc
@@


1.3
log
@Update to 4.1.15.
This contains a local patch to query.c (missed _t conversion) that has
been submitted upstream.
OK sthen
@
text
@/*
 * ipc.c - Interprocess communication routines. Handlers read and write.
 *
 * Copyright (c) 2001-2006, NLnet Labs. All rights reserved.
 *
 * See LICENSE for the license.
 *
 */

#include "config.h"
#include <errno.h>
#include <unistd.h>
#include <stdlib.h>
#include <fcntl.h>
#include "ipc.h"
#include "buffer.h"
#include "xfrd-tcp.h"
#include "nsd.h"
#include "namedb.h"
#include "xfrd.h"
#include "xfrd-notify.h"
#include "difffile.h"

/* attempt to send NSD_STATS command to child fd */
static void send_stat_to_child(struct main_ipc_handler_data* data, int fd);
/* send reload request over the IPC channel */
static void xfrd_send_reload_req(xfrd_state_type* xfrd);
/* send quit request over the IPC channel */
static void xfrd_send_quit_req(xfrd_state_type* xfrd);
/* perform read part of handle ipc for xfrd */
static void xfrd_handle_ipc_read(struct event* handler, xfrd_state_type* xfrd);

static void
ipc_child_quit(struct nsd* nsd)
{
	/* call shutdown and quit routines */
	nsd->mode = NSD_QUIT;
#ifdef	BIND8_STATS
	bind8_stats(nsd);
#endif /* BIND8_STATS */

#if 0 /* OS collects memory pages */
	event_base_free(event_base);
	region_destroy(server_region);
#endif
	server_shutdown(nsd);
	exit(0);
}

void
child_handle_parent_command(int fd, short event, void* arg)
{
	sig_atomic_t mode;
	int len;
	struct ipc_handler_conn_data *data =
		(struct ipc_handler_conn_data *) arg;
	if (!(event & EV_READ)) {
		return;
	}

	if ((len = read(fd, &mode, sizeof(mode))) == -1) {
		log_msg(LOG_ERR, "handle_parent_command: read: %s",
			strerror(errno));
		return;
	}
	if (len == 0)
	{
		/* parent closed the connection. Quit */
		ipc_child_quit(data->nsd);
		return;
	}

	switch (mode) {
	case NSD_STATS:
		data->nsd->mode = mode;
		break;
	case NSD_QUIT:
		ipc_child_quit(data->nsd);
		break;
	case NSD_QUIT_CHILD:
		/* close our listening sockets and ack */
		server_close_all_sockets(data->nsd->udp, data->nsd->ifs);
		server_close_all_sockets(data->nsd->tcp, data->nsd->ifs);
		/* mode == NSD_QUIT_CHILD */
		if(write(fd, &mode, sizeof(mode)) == -1) {
			VERBOSITY(3, (LOG_INFO, "quit child write: %s",
				strerror(errno)));
		}
		ipc_child_quit(data->nsd);
		break;
	case NSD_QUIT_WITH_STATS:
#ifdef BIND8_STATS
		DEBUG(DEBUG_IPC, 2, (LOG_INFO, "quit QUIT_WITH_STATS"));
		/* reply with ack and stats and then quit */
		if(!write_socket(fd, &mode, sizeof(mode))) {
			log_msg(LOG_ERR, "cannot write quitwst to parent");
		}
		if(!write_socket(fd, &data->nsd->st, sizeof(data->nsd->st))) {
			log_msg(LOG_ERR, "cannot write stats to parent");
		}
		fsync(fd);
#endif /* BIND8_STATS */
		ipc_child_quit(data->nsd);
		break;
	default:
		log_msg(LOG_ERR, "handle_parent_command: bad mode %d",
			(int) mode);
		break;
	}
}

void
parent_handle_xfrd_command(netio_type *ATTR_UNUSED(netio),
		      netio_handler_type *handler,
		      netio_event_types_type event_types)
{
	sig_atomic_t mode;
	int len;
	struct ipc_handler_conn_data *data =
		(struct ipc_handler_conn_data *) handler->user_data;
	if (!(event_types & NETIO_EVENT_READ)) {
		return;
	}

	if ((len = read(handler->fd, &mode, sizeof(mode))) == -1) {
		log_msg(LOG_ERR, "handle_xfrd_command: read: %s",
			strerror(errno));
		return;
	}
	if (len == 0)
	{
		/* xfrd closed, we must quit */
		DEBUG(DEBUG_IPC,1, (LOG_INFO, "handle_xfrd_command: xfrd closed channel."));
		close(handler->fd);
		handler->fd = -1;
		data->nsd->mode = NSD_SHUTDOWN;
		return;
	}

	switch (mode) {
	case NSD_RELOAD:
		DEBUG(DEBUG_IPC,1, (LOG_INFO, "parent handle xfrd command RELOAD"));
		data->nsd->signal_hint_reload = 1;
		break;
	case NSD_QUIT:
	case NSD_SHUTDOWN:
		data->nsd->mode = mode;
		break;
	case NSD_STATS:
		data->nsd->signal_hint_stats = 1;
		break;
	case NSD_REAP_CHILDREN:
		data->nsd->signal_hint_child = 1;
		break;
	default:
		log_msg(LOG_ERR, "handle_xfrd_command: bad mode %d",
			(int) mode);
		break;
	}
}

static void
send_stat_to_child(struct main_ipc_handler_data* data, int fd)
{
	sig_atomic_t cmd = NSD_STATS;
	if(write(fd, &cmd, sizeof(cmd)) == -1) {
		if(errno == EAGAIN || errno == EINTR)
			return; /* try again later */
		log_msg(LOG_ERR, "svrmain: problems sending stats to child %d command: %s",
			(int)data->child->pid, strerror(errno));
		return;
	}
	data->child->need_to_send_STATS = 0;
}

#ifndef NDEBUG
int packet_read_query_section(buffer_type *packet, uint8_t* dest, uint16_t* qtype, uint16_t* qclass);
static void
debug_print_fwd_name(int ATTR_UNUSED(len), buffer_type* packet, int acl_num)
{
	uint8_t qnamebuf[MAXDOMAINLEN];
	uint16_t qtype, qclass;
	const dname_type* dname;
	region_type* tempregion = region_create(xalloc, free);

	size_t bufpos = buffer_position(packet);
	buffer_rewind(packet);
	buffer_skip(packet, 12);
	if(packet_read_query_section(packet, qnamebuf, &qtype, &qclass)) {
		dname = dname_make(tempregion, qnamebuf, 1);
		log_msg(LOG_INFO, "main: fwd packet for %s, acl %d",
			dname_to_string(dname,0), acl_num);
	} else {
		log_msg(LOG_INFO, "main: fwd packet badqname, acl %d", acl_num);
	}
	buffer_set_position(packet, bufpos);
	region_destroy(tempregion);
}
#endif

static void
send_quit_to_child(struct main_ipc_handler_data* data, int fd)
{
#ifdef BIND8_STATS
	sig_atomic_t cmd = NSD_QUIT_WITH_STATS;
#else
	sig_atomic_t cmd = NSD_QUIT;
#endif
	if(write(fd, &cmd, sizeof(cmd)) == -1) {
		if(errno == EAGAIN || errno == EINTR)
			return; /* try again later */
		log_msg(LOG_ERR, "svrmain: problems sending quit to child %d command: %s",
			(int)data->child->pid, strerror(errno));
		return;
	}
	data->child->need_to_send_QUIT = 0;
	DEBUG(DEBUG_IPC,2, (LOG_INFO, "main: sent quit to child %d",
		(int)data->child->pid));
}

/** the child is done, mark it as exited */
static void
child_is_done(struct nsd* nsd, int fd)
{
	size_t i;
	if(fd != -1) close(fd);
	for(i=0; i<nsd->child_count; ++i)
		if(nsd->children[i].child_fd == fd) {
			nsd->children[i].child_fd = -1;
			nsd->children[i].handler->fd = -1;
			if(nsd->children[i].need_to_exit) {
				DEBUG(DEBUG_IPC,1, (LOG_INFO, "server %d is done",
					(int)nsd->children[i].pid));
				nsd->children[i].has_exited = 1;
			} else {
				log_msg(LOG_WARNING,
				       "server %d died unexpectedly, restarting",
				       (int)nsd->children[i].pid);
				/* this child is now going to be re-forked as
				 * a subprocess of this server-main, and if a
				 * reload is in progress the other children
				 * are subprocesses of reload.  Until the
				 * reload is done and they are all reforked. */
				nsd->children[i].pid = -1;
				nsd->restart_children = 1;
			}
		}
	parent_check_all_children_exited(nsd);
}

#ifdef BIND8_STATS
/** add stats to total */
void
stats_add(struct nsdst* total, struct nsdst* s)
{
	unsigned i;
	for(i=0; i<sizeof(total->qtype)/sizeof(stc_type); i++)
		total->qtype[i] += s->qtype[i];
	for(i=0; i<sizeof(total->qclass)/sizeof(stc_type); i++)
		total->qclass[i] += s->qclass[i];
	total->qudp += s->qudp;
	total->qudp6 += s->qudp6;
	total->ctcp += s->ctcp;
	total->ctcp6 += s->ctcp6;
	for(i=0; i<sizeof(total->rcode)/sizeof(stc_type); i++)
		total->rcode[i] += s->rcode[i];
	for(i=0; i<sizeof(total->opcode)/sizeof(stc_type); i++)
		total->opcode[i] += s->opcode[i];
	total->dropped += s->dropped;
	total->truncated += s->truncated;
	total->wrongzone += s->wrongzone;
	total->txerr += s->txerr;
	total->rxerr += s->rxerr;
	total->edns += s->edns;
	total->ednserr += s->ednserr;
	total->raxfr += s->raxfr;
	total->nona += s->nona;

	total->db_disk = s->db_disk;
	total->db_mem = s->db_mem;
}

/** subtract stats from total */
void
stats_subtract(struct nsdst* total, struct nsdst* s)
{
	unsigned i;
	for(i=0; i<sizeof(total->qtype)/sizeof(stc_type); i++)
		total->qtype[i] -= s->qtype[i];
	for(i=0; i<sizeof(total->qclass)/sizeof(stc_type); i++)
		total->qclass[i] -= s->qclass[i];
	total->qudp -= s->qudp;
	total->qudp6 -= s->qudp6;
	total->ctcp -= s->ctcp;
	total->ctcp6 -= s->ctcp6;
	for(i=0; i<sizeof(total->rcode)/sizeof(stc_type); i++)
		total->rcode[i] -= s->rcode[i];
	for(i=0; i<sizeof(total->opcode)/sizeof(stc_type); i++)
		total->opcode[i] -= s->opcode[i];
	total->dropped -= s->dropped;
	total->truncated -= s->truncated;
	total->wrongzone -= s->wrongzone;
	total->txerr -= s->txerr;
	total->rxerr -= s->rxerr;
	total->edns -= s->edns;
	total->ednserr -= s->ednserr;
	total->raxfr -= s->raxfr;
	total->nona -= s->nona;
}

#define FINAL_STATS_TIMEOUT 10 /* seconds */
static void
read_child_stats(struct nsd* nsd, struct nsd_child* child, int fd)
{
	struct nsdst s;
	errno=0;
	if(block_read(nsd, fd, &s, sizeof(s), FINAL_STATS_TIMEOUT)!=sizeof(s)) {
		log_msg(LOG_ERR, "problems reading finalstats from server "
			"%d: %s", (int)child->pid, strerror(errno));
	} else {
		stats_add(&nsd->st, &s);
		child->query_count = s.qudp + s.qudp6 + s.ctcp + s.ctcp6;
		/* we know that the child is going to close the connection
		 * now (this is an ACK of the QUIT_W_STATS so we know the
		 * child is done, no longer sending e.g. NOTIFY contents) */
		child_is_done(nsd, fd);
	}
}
#endif /* BIND8_STATS */

void
parent_handle_child_command(netio_type *ATTR_UNUSED(netio),
		      netio_handler_type *handler,
		      netio_event_types_type event_types)
{
	sig_atomic_t mode;
	int len;
	struct main_ipc_handler_data *data =
		(struct main_ipc_handler_data*)handler->user_data;

	/* do a nonblocking write to the child if it is ready. */
	if (event_types & NETIO_EVENT_WRITE) {
		if(data->child->need_to_send_STATS &&
			!data->child->need_to_exit) {
			send_stat_to_child(data, handler->fd);
		} else if(data->child->need_to_send_QUIT) {
			send_quit_to_child(data, handler->fd);
			if(!data->child->need_to_send_QUIT)
				handler->event_types = NETIO_EVENT_READ;
		} else {
			handler->event_types = NETIO_EVENT_READ;
		}
	}

	if (!(event_types & NETIO_EVENT_READ)) {
		return;
	}

	if (data->forward_mode) {
		int got_acl;
		/* forward the data to xfrd */
		DEBUG(DEBUG_IPC,2, (LOG_INFO,
			"main passed packet readup %d", (int)data->got_bytes));
		if(data->got_bytes < sizeof(data->total_bytes))
		{
			if ((len = read(handler->fd,
				(char*)&data->total_bytes+data->got_bytes,
				sizeof(data->total_bytes)-data->got_bytes)) == -1) {
				log_msg(LOG_ERR, "handle_child_command: read: %s",
					strerror(errno));
				return;
			}
			if(len == 0) {
				/* EOF */
				data->forward_mode = 0;
				return;
			}
			data->got_bytes += len;
			if(data->got_bytes < sizeof(data->total_bytes))
				return;
			data->total_bytes = ntohs(data->total_bytes);
			buffer_clear(data->packet);
			if(data->total_bytes > buffer_capacity(data->packet)) {
				log_msg(LOG_ERR, "internal error: ipc too large");
				exit(1);
			}
			return;
		}
		/* read the packet */
		if(data->got_bytes-sizeof(data->total_bytes) < data->total_bytes) {
			if((len = read(handler->fd, buffer_current(data->packet),
				data->total_bytes - (data->got_bytes-sizeof(data->total_bytes))
				)) == -1 ) {
				log_msg(LOG_ERR, "handle_child_command: read: %s",
					strerror(errno));
				return;
			}
			if(len == 0) {
				/* EOF */
				data->forward_mode = 0;
				return;
			}
			data->got_bytes += len;
			buffer_skip(data->packet, len);
			/* read rest later */
			return;
		}
		/* read the acl numbers */
		got_acl = data->got_bytes - sizeof(data->total_bytes) - data->total_bytes;
		if((len = read(handler->fd, (char*)&data->acl_num+got_acl,
			sizeof(data->acl_num)+sizeof(data->acl_xfr)-got_acl)) == -1 ) {
			log_msg(LOG_ERR, "handle_child_command: read: %s",
				strerror(errno));
			return;
		}
		if(len == 0) {
			/* EOF */
			data->forward_mode = 0;
			return;
		}
		got_acl += len;
		data->got_bytes += len;
		if(got_acl >= (int)(sizeof(data->acl_num)+sizeof(data->acl_xfr))) {
			uint16_t len = htons(data->total_bytes);
			DEBUG(DEBUG_IPC,2, (LOG_INFO,
				"main fwd passed packet write %d", (int)data->got_bytes));
#ifndef NDEBUG
			if(nsd_debug_level >= 2)
				debug_print_fwd_name(len, data->packet, data->acl_num);
#endif
			data->forward_mode = 0;
			mode = NSD_PASS_TO_XFRD;
			if(!write_socket(*data->xfrd_sock, &mode, sizeof(mode)) ||
			   !write_socket(*data->xfrd_sock, &len, sizeof(len)) ||
			   !write_socket(*data->xfrd_sock, buffer_begin(data->packet),
				data->total_bytes) ||
			   !write_socket(*data->xfrd_sock, &data->acl_num,
			   	sizeof(data->acl_num)) ||
			   !write_socket(*data->xfrd_sock, &data->acl_xfr,
			   	sizeof(data->acl_xfr))) {
				log_msg(LOG_ERR, "error in ipc fwd main2xfrd: %s",
					strerror(errno));
			}
		}
		return;
	}

	/* read command from ipc */
	if ((len = read(handler->fd, &mode, sizeof(mode))) == -1) {
		log_msg(LOG_ERR, "handle_child_command: read: %s",
			strerror(errno));
		return;
	}
	if (len == 0)
	{
		child_is_done(data->nsd, handler->fd);
		return;
	}

	switch (mode) {
	case NSD_QUIT:
		data->nsd->mode = mode;
		break;
#ifdef BIND8_STATS
	case NSD_QUIT_WITH_STATS:
		read_child_stats(data->nsd, data->child, handler->fd);
		break;
#endif /* BIND8_STATS */
	case NSD_STATS:
		data->nsd->signal_hint_stats = 1;
		break;
	case NSD_REAP_CHILDREN:
		data->nsd->signal_hint_child = 1;
		break;
	case NSD_PASS_TO_XFRD:
		/* set mode for handle_child_command; echo to xfrd. */
		data->forward_mode = 1;
		data->got_bytes = 0;
		data->total_bytes = 0;
		break;
	default:
		log_msg(LOG_ERR, "handle_child_command: bad mode %d",
			(int) mode);
		break;
	}
}

void
parent_check_all_children_exited(struct nsd* nsd)
{
	size_t i;
	for(i=0; i < nsd->child_count; i++) {
		if(!nsd->children[i].need_to_exit)
		      return;
		if(!nsd->children[i].has_exited)
		      return;
	}
	nsd->mode = NSD_QUIT_SYNC;
	DEBUG(DEBUG_IPC,2, (LOG_INFO, "main: all children exited. quit sync."));
}

void
parent_handle_reload_command(netio_type *ATTR_UNUSED(netio),
		      netio_handler_type *handler,
		      netio_event_types_type event_types)
{
	sig_atomic_t mode;
	int len;
	size_t i;
	struct nsd *nsd = (struct nsd*) handler->user_data;
	if (!(event_types & NETIO_EVENT_READ)) {
		return;
	}
	/* read command from ipc */
	if ((len = read(handler->fd, &mode, sizeof(mode))) == -1) {
		log_msg(LOG_ERR, "handle_reload_command: read: %s",
			strerror(errno));
		return;
	}
	if (len == 0)
	{
		if(handler->fd != -1) {
			close(handler->fd);
			handler->fd = -1;
		}
		log_msg(LOG_ERR, "handle_reload_cmd: reload closed cmd channel");
		nsd->reload_failed = 1;
		return;
	}
	switch (mode) {
	case NSD_QUIT_SYNC:
		/* set all children to exit, only then notify xfrd. */
		/* so that buffered packets to pass to xfrd can arrive. */
		for(i=0; i < nsd->child_count; i++) {
			nsd->children[i].need_to_exit = 1;
			if(nsd->children[i].pid > 0 &&
			   nsd->children[i].child_fd != -1) {
				nsd->children[i].need_to_send_QUIT = 1;
				nsd->children[i].handler->event_types
					|= NETIO_EVENT_WRITE;
			} else {
				if(nsd->children[i].child_fd == -1)
					nsd->children[i].has_exited = 1;
			}
		}
		parent_check_all_children_exited(nsd);
		break;
	default:
		log_msg(LOG_ERR, "handle_reload_command: bad mode %d",
			(int) mode);
		break;
	}
}

static void
xfrd_send_reload_req(xfrd_state_type* xfrd)
{
	sig_atomic_t req = NSD_RELOAD;
	uint64_t p = xfrd->last_task->data;
	udb_ptr_unlink(xfrd->last_task, xfrd->nsd->task[xfrd->nsd->mytask]);
	task_process_sync(xfrd->nsd->task[xfrd->nsd->mytask]);
	/* ask server_main for a reload */
	if(write(xfrd->ipc_handler.ev_fd, &req, sizeof(req)) == -1) {
		udb_ptr_init(xfrd->last_task, xfrd->nsd->task[xfrd->nsd->mytask]);
		udb_ptr_set(xfrd->last_task, xfrd->nsd->task[xfrd->nsd->mytask], p);
		if(errno == EAGAIN || errno == EINTR)
			return; /* try again later */
		log_msg(LOG_ERR, "xfrd: problems sending reload command: %s",
			strerror(errno));
		return;
	}
	DEBUG(DEBUG_IPC,1, (LOG_INFO, "xfrd: asked nsd to reload new updates"));
	/* swapped task to other side, start to use other task udb. */
	xfrd->nsd->mytask = 1 - xfrd->nsd->mytask;
	task_remap(xfrd->nsd->task[xfrd->nsd->mytask]);
	udb_ptr_init(xfrd->last_task, xfrd->nsd->task[xfrd->nsd->mytask]);
	assert(udb_base_get_userdata(xfrd->nsd->task[xfrd->nsd->mytask])->data == 0);

	xfrd_prepare_zones_for_reload();
	xfrd->reload_cmd_last_sent = xfrd_time();
	xfrd->need_to_send_reload = 0;
	xfrd->can_send_reload = 0;
}

void
ipc_xfrd_set_listening(struct xfrd_state* xfrd, short mode)
{
	int fd = xfrd->ipc_handler.ev_fd;
	struct event_base* base = xfrd->event_base;
	event_del(&xfrd->ipc_handler);
	event_set(&xfrd->ipc_handler, fd, mode, xfrd_handle_ipc, xfrd);
	if(event_base_set(base, &xfrd->ipc_handler) != 0)
		log_msg(LOG_ERR, "ipc: cannot set event_base");
	/* no timeout for IPC events */
	if(event_add(&xfrd->ipc_handler, NULL) != 0)
		log_msg(LOG_ERR, "ipc: cannot add event");
	xfrd->ipc_handler_flags = mode;
}

static void
xfrd_send_shutdown_req(xfrd_state_type* xfrd)
{
	sig_atomic_t cmd = NSD_SHUTDOWN;
	xfrd->ipc_send_blocked = 1;
	ipc_xfrd_set_listening(xfrd, EV_PERSIST|EV_READ);
	DEBUG(DEBUG_IPC,1, (LOG_INFO, "xfrd: ipc send shutdown"));
	if(!write_socket(xfrd->ipc_handler.ev_fd, &cmd, sizeof(cmd))) {
		log_msg(LOG_ERR, "xfrd: error writing shutdown to main: %s",
			strerror(errno));
	}
	xfrd->need_to_send_shutdown = 0;
}

static void
xfrd_send_quit_req(xfrd_state_type* xfrd)
{
	sig_atomic_t cmd = NSD_QUIT;
	xfrd->ipc_send_blocked = 1;
	ipc_xfrd_set_listening(xfrd, EV_PERSIST|EV_READ);
	DEBUG(DEBUG_IPC,1, (LOG_INFO, "xfrd: ipc send ackreload(quit)"));
	if(!write_socket(xfrd->ipc_handler.ev_fd, &cmd, sizeof(cmd))) {
		log_msg(LOG_ERR, "xfrd: error writing ack to main: %s",
			strerror(errno));
	}
	xfrd->need_to_send_quit = 0;
}

static void
xfrd_send_stats(xfrd_state_type* xfrd)
{
	sig_atomic_t cmd = NSD_STATS;
	DEBUG(DEBUG_IPC,1, (LOG_INFO, "xfrd: ipc send stats"));
	if(!write_socket(xfrd->ipc_handler.ev_fd, &cmd, sizeof(cmd))) {
		log_msg(LOG_ERR, "xfrd: error writing stats to main: %s",
			strerror(errno));
	}
	xfrd->need_to_send_stats = 0;
}

void
xfrd_handle_ipc(int ATTR_UNUSED(fd), short event, void* arg)
{
	xfrd_state_type* xfrd = (xfrd_state_type*)arg;
        if ((event & EV_READ))
	{
		/* first attempt to read as a signal from main
		 * could block further send operations */
		xfrd_handle_ipc_read(&xfrd->ipc_handler, xfrd);
	}
        if ((event & EV_WRITE))
	{
		if(xfrd->ipc_send_blocked) { /* wait for RELOAD_DONE */
			ipc_xfrd_set_listening(xfrd, EV_PERSIST|EV_READ);
			return;
		}
		if(xfrd->need_to_send_shutdown) {
			xfrd_send_shutdown_req(xfrd);
		} else if(xfrd->need_to_send_quit) {
			xfrd_send_quit_req(xfrd);
		} else if(xfrd->can_send_reload && xfrd->need_to_send_reload) {
			xfrd_send_reload_req(xfrd);
		} else if(xfrd->need_to_send_stats) {
			xfrd_send_stats(xfrd);
		}
		if(!(xfrd->can_send_reload && xfrd->need_to_send_reload) &&
			!xfrd->need_to_send_shutdown &&
			!xfrd->need_to_send_quit &&
			!xfrd->need_to_send_stats) {
			/* disable writing for now */
			ipc_xfrd_set_listening(xfrd, EV_PERSIST|EV_READ);
		}
	}

}

static void
xfrd_handle_ipc_read(struct event* handler, xfrd_state_type* xfrd)
{
        sig_atomic_t cmd;
        int len;

	if(xfrd->ipc_conn->is_reading==2) {
		buffer_type* tmp = xfrd->ipc_pass;
		uint32_t acl_num;
		int32_t acl_xfr;
		/* read acl_num */
		int ret = conn_read(xfrd->ipc_conn);
		if(ret == -1) {
			log_msg(LOG_ERR, "xfrd: error in read ipc: %s", strerror(errno));
			xfrd->ipc_conn->is_reading = 0;
			return;
		}
		if(ret == 0)
			return;
		buffer_flip(xfrd->ipc_conn->packet);
		xfrd->ipc_pass = xfrd->ipc_conn->packet;
		xfrd->ipc_conn->packet = tmp;
		xfrd->ipc_conn->is_reading = 0;
		acl_num = buffer_read_u32(xfrd->ipc_pass);
		acl_xfr = (int32_t)buffer_read_u32(xfrd->ipc_pass);
		xfrd_handle_passed_packet(xfrd->ipc_conn->packet, acl_num, acl_xfr);
		return;
	}
	if(xfrd->ipc_conn->is_reading) {
		/* reading an IPC message */
		buffer_type* tmp;
		int ret = conn_read(xfrd->ipc_conn);
		if(ret == -1) {
			log_msg(LOG_ERR, "xfrd: error in read ipc: %s", strerror(errno));
			xfrd->ipc_conn->is_reading = 0;
			return;
		}
		if(ret == 0)
			return;
		buffer_flip(xfrd->ipc_conn->packet);
		/* use ipc_conn to read remaining data as well */
		tmp = xfrd->ipc_pass;
		xfrd->ipc_conn->is_reading=2;
		xfrd->ipc_pass = xfrd->ipc_conn->packet;
		xfrd->ipc_conn->packet = tmp;
		xfrd->ipc_conn->total_bytes = sizeof(xfrd->ipc_conn->msglen);
		xfrd->ipc_conn->msglen = 2*sizeof(uint32_t);
		buffer_clear(xfrd->ipc_conn->packet);
		buffer_set_limit(xfrd->ipc_conn->packet, xfrd->ipc_conn->msglen);
		return;
	}

        if((len = read(handler->ev_fd, &cmd, sizeof(cmd))) == -1) {
		if(errno != EINTR && errno != EAGAIN)
                	log_msg(LOG_ERR, "xfrd_handle_ipc: read: %s",
                        	strerror(errno));
                return;
        }
        if(len == 0)
        {
		/* parent closed the connection. Quit */
		DEBUG(DEBUG_IPC,1, (LOG_INFO, "xfrd: main closed connection."));
		xfrd->shutdown = 1;
		return;
        }

        switch(cmd) {
        case NSD_QUIT:
        case NSD_SHUTDOWN:
		DEBUG(DEBUG_IPC,1, (LOG_INFO, "xfrd: main sent shutdown cmd."));
                xfrd->shutdown = 1;
                break;
	case NSD_RELOAD_DONE:
		/* reload has finished */
		DEBUG(DEBUG_IPC,1, (LOG_INFO, "xfrd: ipc recv RELOAD_DONE"));
		if(block_read(NULL, handler->ev_fd, &xfrd->reload_pid,
			sizeof(pid_t), -1) != sizeof(pid_t)) {
			log_msg(LOG_ERR, "xfrd cannot get reload_pid");
		}
		/* read the not-mytask for the results and soainfo */
		xfrd_process_task_result(xfrd,
			xfrd->nsd->task[1-xfrd->nsd->mytask]);
		/* reset the IPC, (and the nonblocking ipc write;
		   the new parent does not want half a packet) */
		xfrd->can_send_reload = 1;
		xfrd->ipc_send_blocked = 0;
		ipc_xfrd_set_listening(xfrd, EV_PERSIST|EV_READ|EV_WRITE);
		xfrd_reopen_logfile();
		xfrd_check_failed_updates();
		break;
	case NSD_PASS_TO_XFRD:
		DEBUG(DEBUG_IPC,1, (LOG_INFO, "xfrd: ipc recv PASS_TO_XFRD"));
		xfrd->ipc_conn->is_reading = 1;
		break;
	case NSD_RELOAD_REQ:
		DEBUG(DEBUG_IPC,1, (LOG_INFO, "xfrd: ipc recv RELOAD_REQ"));
		/* make reload happen, right away, and schedule file check */
		task_new_check_zonefiles(xfrd->nsd->task[xfrd->nsd->mytask],
			xfrd->last_task, NULL);
		xfrd_set_reload_now(xfrd);
		break;
	case NSD_RELOAD:
		/* main tells us that reload is done, stop ipc send to main */
		DEBUG(DEBUG_IPC,1, (LOG_INFO, "xfrd: ipc recv RELOAD"));
		ipc_xfrd_set_listening(xfrd, EV_PERSIST|EV_READ|EV_WRITE);
		xfrd->need_to_send_quit = 1;
		break;
        default:
                log_msg(LOG_ERR, "xfrd_handle_ipc: bad mode %d (%d)", (int)cmd,
			(int)ntohl(cmd));
                break;
        }

	if(xfrd->ipc_conn->is_reading) {
		/* setup read of info */
		xfrd->ipc_conn->total_bytes = 0;
		xfrd->ipc_conn->msglen = 0;
		buffer_clear(xfrd->ipc_conn->packet);
	}
}
@


1.2
log
@update to 4.1.11
"Working fine here." millert@@
OK dlg, sthen
@
text
@d27 1
a27 1
static void xfrd_send_reload_req(xfrd_state_t* xfrd);
d29 1
a29 1
static void xfrd_send_quit_req(xfrd_state_t* xfrd);
d31 1
a31 1
static void xfrd_handle_ipc_read(struct event* handler, xfrd_state_t* xfrd);
d257 1
a257 1
	for(i=0; i<sizeof(total->qtype)/sizeof(stc_t); i++)
d259 1
a259 1
	for(i=0; i<sizeof(total->qclass)/sizeof(stc_t); i++)
d265 1
a265 1
	for(i=0; i<sizeof(total->rcode)/sizeof(stc_t); i++)
d267 1
a267 1
	for(i=0; i<sizeof(total->opcode)/sizeof(stc_t); i++)
d288 1
a288 1
	for(i=0; i<sizeof(total->qtype)/sizeof(stc_t); i++)
d290 1
a290 1
	for(i=0; i<sizeof(total->qclass)/sizeof(stc_t); i++)
d296 1
a296 1
	for(i=0; i<sizeof(total->rcode)/sizeof(stc_t); i++)
d298 1
a298 1
	for(i=0; i<sizeof(total->opcode)/sizeof(stc_t); i++)
d556 1
a556 1
xfrd_send_reload_req(xfrd_state_t* xfrd)
d601 1
a601 1
xfrd_send_shutdown_req(xfrd_state_t* xfrd)
d615 1
a615 1
xfrd_send_quit_req(xfrd_state_t* xfrd)
d629 1
a629 1
xfrd_send_stats(xfrd_state_t* xfrd)
d643 1
a643 1
	xfrd_state_t* xfrd = (xfrd_state_t*)arg;
d677 1
a677 1
xfrd_handle_ipc_read(struct event* handler, xfrd_state_t* xfrd)
@


1.1
log
@Initial revision
@
text
@d10 1
a10 1
#include <config.h>
d14 1
d22 1
a23 4
/* set is_ok for the zone according to the zone message */
static zone_type* handle_xfrd_zone_state(struct nsd* nsd, buffer_type* packet);
/* write ipc ZONE_STATE message into the buffer */
static void write_zone_state_packet(buffer_type* packet, zone_type* zone);
a25 2
/* write IPC expire notification msg to a buffer */
static void xfrd_write_expire_notification(buffer_type* buffer, xfrd_zone_t* zone);
a29 2
/* get SOA INFO out of IPC packet buffer */
static void xfrd_handle_ipc_SOAINFO(xfrd_state_t* xfrd, buffer_type* packet);
d31 1
a31 1
static void xfrd_handle_ipc_read(netio_handler_type *handler, xfrd_state_t* xfrd);
d33 2
a34 2
static zone_type*
handle_xfrd_zone_state(struct nsd* nsd, buffer_type* packet)
d36 12
a47 31
	uint8_t ok;
	const dname_type *dname;
	domain_type *domain;
	zone_type *zone;

	ok = buffer_read_u8(packet);
	dname = (dname_type*)buffer_current(packet);
	DEBUG(DEBUG_IPC,1, (LOG_INFO, "handler zone state %s is %s",
		dname_to_string(dname, NULL), ok?"ok":"expired"));
	/* find in zone_types, if does not exist, we cannot serve anyway */
	/* find zone in config, since that one always exists */
	domain = domain_table_find(nsd->db->domains, dname);
	if(!domain) {
		DEBUG(DEBUG_IPC,1, (LOG_INFO, "zone state msg, empty zone (domain %s)",
			dname_to_string(dname, NULL)));
		return NULL;
	}
	zone = domain_find_zone(domain);
	if(!zone || dname_compare(domain_dname(zone->apex), dname) != 0) {
		DEBUG(DEBUG_IPC,1, (LOG_INFO, "zone state msg, empty zone (zone %s)",
			dname_to_string(dname, NULL)));
		return NULL;
	}
	assert(zone);
	/* only update zone->is_ok if needed to minimize copy-on-write
	   of memory pages shared after fork() */
	if(ok && !zone->is_ok)
		zone->is_ok = 1;
	if(!ok && zone->is_ok)
		zone->is_ok = 0;
	return zone;
d51 1
a51 3
child_handle_parent_command(netio_type *ATTR_UNUSED(netio),
		      netio_handler_type *handler,
		      netio_event_types_type event_types)
d56 2
a57 20
		(struct ipc_handler_conn_data *) handler->user_data;
	if (!(event_types & NETIO_EVENT_READ)) {
		return;
	}

	if(data->conn->is_reading) {
		int ret = conn_read(data->conn);
		if(ret == -1) {
			log_msg(LOG_ERR, "handle_parent_command: error in conn_read: %s",
				strerror(errno));
			data->conn->is_reading = 0;
			return;
		}
		if(ret == 0) {
			return; /* continue later */
		}
		/* completed */
		data->conn->is_reading = 0;
		buffer_flip(data->conn->packet);
		(void)handle_xfrd_zone_state(data->nsd, data->conn->packet);
d61 1
a61 1
	if ((len = read(handler->fd, &mode, sizeof(mode))) == -1) {
d69 1
a69 1
		data->nsd->mode = NSD_QUIT;
d75 2
d78 1
a78 1
		data->nsd->mode = mode;
d80 24
a103 6
	case NSD_ZONE_STATE:
		data->conn->is_reading = 1;
		data->conn->total_bytes = 0;
		data->conn->msglen = 0;
		data->conn->fd = handler->fd;
		buffer_clear(data->conn->packet);
a124 32
	if(data->conn->is_reading) {
		/* handle ZONE_STATE forward to children */
		int ret = conn_read(data->conn);
		size_t i;
		zone_type* zone;
		if(ret == -1) {
			log_msg(LOG_ERR, "main xfrd listener: error in conn_read: %s",
				strerror(errno));
			data->conn->is_reading = 0;
			return;
		}
		if(ret == 0) {
			return; /* continue later */
		}
		/* completed */
		data->conn->is_reading = 0;
		buffer_flip(data->conn->packet);
		zone = handle_xfrd_zone_state(data->nsd, data->conn->packet);
		if(!zone)
			return;
		/* forward to all children */
		for (i = 0; i < data->nsd->child_count; ++i) {
			if(!zone->dirty[i]) {
				zone->dirty[i] = 1;
				stack_push(data->nsd->children[i].dirty_zones, zone);
				data->nsd->children[i].handler->event_types |=
					NETIO_EVENT_WRITE;
			}
		}
		return;
	}

d132 2
a133 1
		DEBUG(DEBUG_IPC,1, (LOG_ERR, "handle_xfrd_command: xfrd closed channel."));
d136 1
d142 1
d146 1
d149 3
a154 7
	case NSD_ZONE_STATE:
		data->conn->is_reading = 1;
		data->conn->total_bytes = 0;
		data->conn->msglen = 0;
		data->conn->fd = handler->fd;
		buffer_clear(data->conn->packet);
		break;
a162 21
write_zone_state_packet(buffer_type* packet, zone_type* zone)
{
	sig_atomic_t cmd = NSD_ZONE_STATE;
	uint8_t ok = zone->is_ok;
	uint16_t sz;
	if(!zone->apex) {
		return;
	}
	sz = dname_total_size(domain_dname(zone->apex)) + 1;
	sz = htons(sz);

	buffer_clear(packet);
	buffer_write(packet, &cmd, sizeof(cmd));
	buffer_write(packet, &sz, sizeof(sz));
	buffer_write(packet, &ok, sizeof(ok));
	buffer_write(packet, domain_dname(zone->apex),
		dname_total_size(domain_dname(zone->apex)));
	buffer_flip(packet);
}

static void
d176 1
d199 1
d204 3
d208 1
d221 110
d343 2
a344 27
		if(!data->busy_writing_zone_state &&
			!data->child->need_to_send_STATS &&
			!data->child->need_to_send_QUIT &&
			!data->child->need_to_exit &&
			data->child->dirty_zones->num > 0) {
			/* create packet from next dirty zone */
			zone_type* zone = (zone_type*)stack_pop(data->child->dirty_zones);
			assert(zone);
			zone->dirty[data->child_num] = 0;
			data->busy_writing_zone_state = 1;
			write_zone_state_packet(data->write_conn->packet, zone);
			data->write_conn->msglen = buffer_limit(data->write_conn->packet);
			data->write_conn->total_bytes = sizeof(uint16_t); /* len bytes already in packet */
			data->write_conn->fd = handler->fd;
		}
		if(data->busy_writing_zone_state) {
			/* write more of packet */
			int ret = conn_write(data->write_conn);
			if(ret == -1) {
				log_msg(LOG_ERR, "handle_child_cmd %d: could not write: %s",
					(int)data->child->pid, strerror(errno));
				data->busy_writing_zone_state = 0;
			} else if(ret == 1) {
				data->busy_writing_zone_state = 0; /* completed */
			}
		} else if(data->child->need_to_send_STATS &&
			  !data->child->need_to_exit) {
d350 1
a350 5
		}
		if(!data->busy_writing_zone_state &&
			!data->child->need_to_send_STATS &&
			!data->child->need_to_send_QUIT &&
			data->child->dirty_zones->num == 0) {
d408 1
a408 1
		/* read the acl number */
d411 1
a411 1
			sizeof(data->acl_num)-got_acl)) == -1 ) {
d423 1
a423 1
		if(got_acl >= (int)sizeof(data->acl_num)) {
d438 3
a440 1
			   	sizeof(data->acl_num))) {
d456 1
a456 12
		size_t i;
		if(handler->fd > 0) close(handler->fd);
		for(i=0; i<data->nsd->child_count; ++i)
			if(data->nsd->children[i].child_fd == handler->fd) {
				data->nsd->children[i].child_fd = -1;
				data->nsd->children[i].has_exited = 1;
				DEBUG(DEBUG_IPC,1, (LOG_INFO,
					"server %d closed cmd channel",
					(int) data->nsd->children[i].pid));
			}
		handler->fd = -1;
		parent_check_all_children_exited(data->nsd);
d464 5
d522 1
a522 1
		if(handler->fd > 0) {
d527 1
d537 1
a537 1
			   nsd->children[i].child_fd > 0) {
a555 22
xfrd_write_expire_notification(buffer_type* buffer, xfrd_zone_t* zone)
{
	sig_atomic_t cmd = NSD_ZONE_STATE;
	uint8_t ok = 1;
	uint16_t sz = dname_total_size(zone->apex) + 1;
	sz = htons(sz);
	if(zone->state == xfrd_zone_expired)
		ok = 0;

	DEBUG(DEBUG_IPC,1, (LOG_INFO,
		"xfrd encoding ipc zone state msg for zone %s state %d.",
		zone->apex_str, (int)zone->state));

	buffer_clear(buffer);
	buffer_write(buffer, &cmd, sizeof(cmd));
	buffer_write(buffer, &sz, sizeof(sz));
	buffer_write(buffer, &ok, sizeof(ok));
	buffer_write(buffer, zone->apex, dname_total_size(zone->apex));
	buffer_flip(buffer);
}

static void
d559 3
d563 3
a565 1
	if(write(xfrd->ipc_handler.fd, &req, sizeof(req)) == -1) {
d573 6
d585 29
d619 1
a619 2
	xfrd->ipc_handler.event_types &= (~NETIO_EVENT_WRITE);
	xfrd->sending_zone_state = 0;
d621 1
a621 1
	if(write_socket(xfrd->ipc_handler.fd, &cmd, sizeof(cmd)) == -1) {
d629 1
a629 1
xfrd_handle_ipc_SOAINFO(xfrd_state_t* xfrd, buffer_type* packet)
d631 5
a635 47
	xfrd_soa_t soa;
	xfrd_soa_t* soa_ptr = &soa;
	xfrd_zone_t* zone;
	/* dname is sent in memory format */
	const dname_type* dname = (const dname_type*)buffer_begin(packet);

	/* find zone and decode SOA */
	zone = (xfrd_zone_t*)rbtree_search(xfrd->zones, dname);
	buffer_skip(packet, dname_total_size(dname));

	if(!buffer_available(packet, sizeof(uint32_t)*6 + sizeof(uint8_t)*2)) {
		/* NSD has zone without any info */
		DEBUG(DEBUG_IPC,1, (LOG_INFO, "SOAINFO for %s lost zone",
			dname_to_string(dname,0)));
		soa_ptr = NULL;
	} else {
		/* read soa info */
		memset(&soa, 0, sizeof(soa));
		/* left out type, klass, count for speed */
		soa.type = htons(TYPE_SOA);
		soa.klass = htons(CLASS_IN);
		soa.ttl = htonl(buffer_read_u32(packet));
		soa.rdata_count = htons(7);
		soa.prim_ns[0] = buffer_read_u8(packet);
		if(!buffer_available(packet, soa.prim_ns[0]))
			return;
		buffer_read(packet, soa.prim_ns+1, soa.prim_ns[0]);
		soa.email[0] = buffer_read_u8(packet);
		if(!buffer_available(packet, soa.email[0]))
			return;
		buffer_read(packet, soa.email+1, soa.email[0]);

		soa.serial = htonl(buffer_read_u32(packet));
		soa.refresh = htonl(buffer_read_u32(packet));
		soa.retry = htonl(buffer_read_u32(packet));
		soa.expire = htonl(buffer_read_u32(packet));
		soa.minimum = htonl(buffer_read_u32(packet));
		DEBUG(DEBUG_IPC,1, (LOG_INFO, "SOAINFO for %s %u",
			dname_to_string(dname,0), ntohl(soa.serial)));
	}

	if(!zone) {
		DEBUG(DEBUG_IPC,1, (LOG_INFO, "xfrd: zone %s master zone updated",
			dname_to_string(dname,0)));
		notify_handle_master_zone_soainfo(xfrd->notify_zones,
			dname, soa_ptr);
		return;
d637 1
a637 1
	xfrd_handle_incoming_soa(zone, soa_ptr, xfrd_time());
d641 1
a641 3
xfrd_handle_ipc(netio_type* ATTR_UNUSED(netio),
	netio_handler_type *handler,
	netio_event_types_type event_types)
d643 2
a644 2
	xfrd_state_t* xfrd = (xfrd_state_t*)handler->user_data;
        if ((event_types & NETIO_EVENT_READ))
d648 1
a648 1
		xfrd_handle_ipc_read(handler, xfrd);
d650 1
a650 1
        if ((event_types & NETIO_EVENT_WRITE))
d652 2
a653 2
		if(xfrd->ipc_send_blocked) { /* wait for SOA_END */
			handler->event_types = NETIO_EVENT_READ;
d656 2
a657 25
		/* if necessary prepare a packet */
		if(!(xfrd->can_send_reload && xfrd->need_to_send_reload) &&
			!xfrd->need_to_send_quit &&
			!xfrd->sending_zone_state &&
			xfrd->dirty_zones->num > 0) {
			xfrd_zone_t* zone = (xfrd_zone_t*)stack_pop(xfrd->dirty_zones);
			assert(zone);
			zone->dirty = 0;
			xfrd->sending_zone_state = 1;
			xfrd_write_expire_notification(xfrd->ipc_conn_write->packet, zone);
			xfrd->ipc_conn_write->msglen = buffer_limit(xfrd->ipc_conn_write->packet);
			/* skip length bytes; they are encoded in the packet, after cmd */
			xfrd->ipc_conn_write->total_bytes = sizeof(uint16_t);
		}
		/* write a bit */
		if(xfrd->sending_zone_state) {
			/* call conn_write */
			int ret = conn_write(xfrd->ipc_conn_write);
			if(ret == -1) {
				log_msg(LOG_ERR, "xfrd: error in write ipc: %s", strerror(errno));
				xfrd->sending_zone_state = 0;
			}
			else if(ret == 1) { /* done */
				xfrd->sending_zone_state = 0;
			}
d662 2
d666 1
d668 3
a670 3
			!xfrd->sending_zone_state &&
			xfrd->dirty_zones->num == 0) {
			handler->event_types = NETIO_EVENT_READ; /* disable writing for now */
d677 1
a677 1
xfrd_handle_ipc_read(netio_handler_type *handler, xfrd_state_t* xfrd)
d685 1
d700 2
a701 1
		xfrd_handle_passed_packet(xfrd->ipc_conn->packet, acl_num);
d706 1
d716 9
a724 14
		if(xfrd->ipc_is_soa) {
			xfrd->ipc_conn->is_reading = 0;
			xfrd_handle_ipc_SOAINFO(xfrd, xfrd->ipc_conn->packet);
		} else 	{
			/* use ipc_conn to read remaining data as well */
			buffer_type* tmp = xfrd->ipc_pass;
			xfrd->ipc_conn->is_reading=2;
			xfrd->ipc_pass = xfrd->ipc_conn->packet;
			xfrd->ipc_conn->packet = tmp;
			xfrd->ipc_conn->total_bytes = sizeof(xfrd->ipc_conn->msglen);
			xfrd->ipc_conn->msglen = sizeof(uint32_t);
			buffer_clear(xfrd->ipc_conn->packet);
			buffer_set_limit(xfrd->ipc_conn->packet, xfrd->ipc_conn->msglen);
		}
d728 4
a731 3
        if((len = read(handler->fd, &cmd, sizeof(cmd))) == -1) {
                log_msg(LOG_ERR, "xfrd_handle_ipc: read: %s",
                        strerror(errno));
d745 1
a745 1
		DEBUG(DEBUG_IPC,1, (LOG_INFO, "xfrd: main send shutdown cmd."));
d748 1
a748 15
	case NSD_SOA_BEGIN:
		DEBUG(DEBUG_IPC,1, (LOG_INFO, "xfrd: ipc recv SOA_BEGIN"));
		/* reload starts sending SOA INFOs; don't block */
		xfrd->parent_soa_info_pass = 1;
		/* reset the nonblocking ipc write;
		   the new parent does not want half a packet */
		xfrd->sending_zone_state = 0;
		break;
	case NSD_SOA_INFO:
		DEBUG(DEBUG_IPC,1, (LOG_INFO, "xfrd: ipc recv SOA_INFO"));
		assert(xfrd->parent_soa_info_pass);
		xfrd->ipc_is_soa = 1;
		xfrd->ipc_conn->is_reading = 1;
                break;
	case NSD_SOA_END:
d750 10
a759 1
		DEBUG(DEBUG_IPC,1, (LOG_INFO, "xfrd: ipc recv SOA_END"));
a760 1
		xfrd->parent_soa_info_pass = 0;
d762 1
a762 1
		handler->event_types |= NETIO_EVENT_WRITE;
a764 1
		xfrd_send_expy_all_zones();
a767 1
		xfrd->ipc_is_soa = 0;
d770 7
d780 1
a780 1
		handler->event_types |= NETIO_EVENT_WRITE;
d785 1
a785 1
			ntohl(cmd));
a795 1

@


1.1.1.1
log
@NSD v3.2.4
@
text
@@


1.1.1.2
log
@NSD v3.2.8
@
text
@d4 1
a4 1
 * Copyright (c) 2001-2011, NLnet Labs. All rights reserved.
@


1.1.1.3
log
@NSD v3.2.11, ok phessler@@
@
text
@d10 1
a10 1
#include "config.h"
d446 1
a446 1
		if(handler->fd != -1) close(handler->fd);
d517 1
a517 1
		if(handler->fd != -1) {
d531 1
a531 1
			   nsd->children[i].child_fd != -1) {
@


1.1.1.4
log
@update to NSD 3.2.14, requested by/ok brad@@
@
text
@d399 1
a399 1
		/* read the acl numbers */
d402 1
a402 1
			sizeof(data->acl_num)+sizeof(data->acl_xfr)-got_acl)) == -1 ) {
d414 1
a414 1
		if(got_acl >= (int)(sizeof(data->acl_num)+sizeof(data->acl_xfr))) {
d429 1
a429 3
			   	sizeof(data->acl_num)) ||
			   !write_socket(*data->xfrd_sock, &data->acl_xfr,
			   	sizeof(data->acl_xfr))) {
d598 1
a598 1
	if(!write_socket(xfrd->ipc_handler.fd, &cmd, sizeof(cmd))) {
a725 1
		int32_t acl_xfr;
d740 1
a740 2
		acl_xfr = (int32_t)buffer_read_u32(xfrd->ipc_pass);
		xfrd_handle_passed_packet(xfrd->ipc_conn->packet, acl_num, acl_xfr);
d764 1
a764 1
			xfrd->ipc_conn->msglen = 2*sizeof(uint32_t);
@


1.1.1.5
log
@Update to NSD 3.2.15, ok brad@@ phessler@@ deraadt@@ also tested by okan@@
@
text
@a74 12
static void
ipc_child_quit(struct nsd* nsd)
{
	/* call shutdown and quit routines */
	nsd->mode = NSD_QUIT;
#ifdef	BIND8_STATS
	bind8_stats(nsd);
#endif /* BIND8_STATS */
	server_shutdown(nsd);
	exit(0);
}

d120 1
a121 3
		break;
	case NSD_QUIT:
		ipc_child_quit(data->nsd);
@


1.1.1.6
log
@update to NSD 3.2.16, ok deraadt@@ brad@@
@
text
@a136 8
	case NSD_QUIT_CHILD:
		/* close our listening sockets and ack */
		server_close_all_sockets(data->nsd->udp, data->nsd->ifs);
		server_close_all_sockets(data->nsd->tcp, data->nsd->ifs);
		/* mode == NSD_QUIT_CHILD */
		(void)write(handler->fd, &mode, sizeof(mode));
		ipc_child_quit(data->nsd);
		break;
d203 1
a203 2
		/* xfrd closed, we must quit */
		DEBUG(DEBUG_IPC,1, (LOG_INFO, "handle_xfrd_command: xfrd closed channel."));
a210 1
		DEBUG(DEBUG_IPC,1, (LOG_INFO, "parent handle xfrd command RELOAD"));
@


1.1.1.7
log
@import NSD 4.0.0, tests from Dorian Büttner, Patrik Lundin, requested by brad@@
@
text
@d4 1
a4 1
 * Copyright (c) 2001-2006, NLnet Labs. All rights reserved.
a13 1
#include <fcntl.h>
a20 1
#include "difffile.h"
d22 4
d28 2
d34 2
d37 37
a73 1
static void xfrd_handle_ipc_read(struct event* handler, xfrd_state_t* xfrd);
a82 5

#if 0 /* OS collects memory pages */
	event_base_free(event_base);
	region_destroy(server_region);
#endif
d88 3
a90 1
child_handle_parent_command(int fd, short event, void* arg)
d95 20
a114 2
		(struct ipc_handler_conn_data *) arg;
	if (!(event & EV_READ)) {
d118 1
a118 1
	if ((len = read(fd, &mode, sizeof(mode))) == -1) {
d126 1
a126 1
		ipc_child_quit(data->nsd);
d142 1
a142 1
		(void)write(fd, &mode, sizeof(mode));
d145 6
a150 13
	case NSD_QUIT_WITH_STATS:
#ifdef BIND8_STATS
		DEBUG(DEBUG_IPC, 2, (LOG_INFO, "quit QUIT_WITH_STATS"));
		/* reply with ack and stats and then quit */
		if(!write_socket(fd, &mode, sizeof(mode))) {
			log_msg(LOG_ERR, "cannot write quitwst to parent");
		}
		if(!write_socket(fd, &data->nsd->st, sizeof(data->nsd->st))) {
			log_msg(LOG_ERR, "cannot write stats to parent");
		}
		fsync(fd);
#endif /* BIND8_STATS */
		ipc_child_quit(data->nsd);
d172 32
a214 1
		data->nsd->mode = NSD_SHUTDOWN;
a223 1
	case NSD_SHUTDOWN:
a225 3
	case NSD_STATS:
		data->nsd->signal_hint_stats = 1;
		break;
d229 7
d244 21
a277 1
#ifndef NDEBUG
a299 1
#endif
a303 3
#ifdef BIND8_STATS
	sig_atomic_t cmd = NSD_QUIT_WITH_STATS;
#else
a304 1
#endif
a316 69
/** the child is done, mark it as exited */
static void
child_is_done(struct nsd* nsd, int fd)
{
	size_t i;
	if(fd != -1) close(fd);
	for(i=0; i<nsd->child_count; ++i)
		if(nsd->children[i].child_fd == fd) {
			nsd->children[i].child_fd = -1;
			nsd->children[i].has_exited = 1;
			nsd->children[i].handler->fd = -1;
			DEBUG(DEBUG_IPC,1, (LOG_INFO, "server %d is done",
				(int)nsd->children[i].pid));
		}
	parent_check_all_children_exited(nsd);
}

#ifdef BIND8_STATS
/** add stats to total */
void
stats_add(struct nsdst* total, struct nsdst* s)
{
	unsigned i;
	for(i=0; i<sizeof(total->qtype)/sizeof(stc_t); i++)
		total->qtype[i] += s->qtype[i];
	for(i=0; i<sizeof(total->qclass)/sizeof(stc_t); i++)
		total->qclass[i] += s->qclass[i];
	total->qudp += s->qudp;
	total->qudp6 += s->qudp6;
	total->ctcp += s->ctcp;
	total->ctcp6 += s->ctcp6;
	for(i=0; i<sizeof(total->rcode)/sizeof(stc_t); i++)
		total->rcode[i] += s->rcode[i];
	for(i=0; i<sizeof(total->opcode)/sizeof(stc_t); i++)
		total->opcode[i] += s->opcode[i];
	total->dropped += s->dropped;
	total->truncated += s->truncated;
	total->wrongzone += s->wrongzone;
	total->txerr += s->txerr;
	total->rxerr += s->rxerr;
	total->edns += s->edns;
	total->ednserr += s->ednserr;
	total->raxfr += s->raxfr;
	total->nona += s->nona;

	total->db_disk = s->db_disk;
	total->db_mem = s->db_mem;
}

#define FINAL_STATS_TIMEOUT 10 /* seconds */
static void
read_child_stats(struct nsd* nsd, struct nsd_child* child, int fd)
{
	struct nsdst s;
	errno=0;
	if(block_read(nsd, fd, &s, sizeof(s), FINAL_STATS_TIMEOUT)!=sizeof(s)) {
		log_msg(LOG_ERR, "problems reading finalstats from server "
			"%d: %s", (int)child->pid, strerror(errno));
	} else {
		stats_add(&nsd->st, &s);
		child->query_count = s.qudp + s.qudp6 + s.ctcp + s.ctcp6;
		/* we know that the child is going to close the connection
		 * now (this is an ACK of the QUIT_W_STATS so we know the
		 * child is done, no longer sending e.g. NOTIFY contents) */
		child_is_done(nsd, fd);
	}
}
#endif /* BIND8_STATS */

d329 27
a355 2
		if(data->child->need_to_send_STATS &&
			!data->child->need_to_exit) {
d361 5
a365 1
		} else {
d471 12
a482 1
		child_is_done(data->nsd, handler->fd);
a489 5
#ifdef BIND8_STATS
	case NSD_QUIT_WITH_STATS:
		read_child_stats(data->nsd, data->child, handler->fd);
		break;
#endif /* BIND8_STATS */
d576 22
a600 3
	uint64_t p = xfrd->last_task->data;
	udb_ptr_unlink(xfrd->last_task, xfrd->nsd->task[xfrd->nsd->mytask]);
	task_process_sync(xfrd->nsd->task[xfrd->nsd->mytask]);
d602 1
a602 3
	if(write(xfrd->ipc_handler.ev_fd, &req, sizeof(req)) == -1) {
		udb_ptr_init(xfrd->last_task, xfrd->nsd->task[xfrd->nsd->mytask]);
		udb_ptr_set(xfrd->last_task, xfrd->nsd->task[xfrd->nsd->mytask], p);
a609 6
	/* swapped task to other side, start to use other task udb. */
	xfrd->nsd->mytask = 1 - xfrd->nsd->mytask;
	task_remap(xfrd->nsd->task[xfrd->nsd->mytask]);
	udb_ptr_init(xfrd->last_task, xfrd->nsd->task[xfrd->nsd->mytask]);
	assert(udb_base_get_userdata(xfrd->nsd->task[xfrd->nsd->mytask])->data == 0);

a615 29
void
ipc_xfrd_set_listening(struct xfrd_state* xfrd, short mode)
{
	int fd = xfrd->ipc_handler.ev_fd;
	struct event_base* base = xfrd->event_base;
	event_del(&xfrd->ipc_handler);
	event_set(&xfrd->ipc_handler, fd, mode, xfrd_handle_ipc, xfrd);
	if(event_base_set(base, &xfrd->ipc_handler) != 0)
		log_msg(LOG_ERR, "ipc: cannot set event_base");
	/* no timeout for IPC events */
	if(event_add(&xfrd->ipc_handler, NULL) != 0)
		log_msg(LOG_ERR, "ipc: cannot add event");
	xfrd->ipc_handler_flags = mode;
}

static void
xfrd_send_shutdown_req(xfrd_state_t* xfrd)
{
	sig_atomic_t cmd = NSD_SHUTDOWN;
	xfrd->ipc_send_blocked = 1;
	ipc_xfrd_set_listening(xfrd, EV_PERSIST|EV_READ);
	DEBUG(DEBUG_IPC,1, (LOG_INFO, "xfrd: ipc send shutdown"));
	if(!write_socket(xfrd->ipc_handler.ev_fd, &cmd, sizeof(cmd))) {
		log_msg(LOG_ERR, "xfrd: error writing shutdown to main: %s",
			strerror(errno));
	}
	xfrd->need_to_send_shutdown = 0;
}

d621 2
a622 1
	ipc_xfrd_set_listening(xfrd, EV_PERSIST|EV_READ);
d624 1
a624 1
	if(!write_socket(xfrd->ipc_handler.ev_fd, &cmd, sizeof(cmd))) {
d632 1
a632 1
xfrd_send_stats(xfrd_state_t* xfrd)
d634 47
a680 5
	sig_atomic_t cmd = NSD_STATS;
	DEBUG(DEBUG_IPC,1, (LOG_INFO, "xfrd: ipc send stats"));
	if(!write_socket(xfrd->ipc_handler.ev_fd, &cmd, sizeof(cmd))) {
		log_msg(LOG_ERR, "xfrd: error writing stats to main: %s",
			strerror(errno));
d682 1
a682 1
	xfrd->need_to_send_stats = 0;
d686 3
a688 1
xfrd_handle_ipc(int ATTR_UNUSED(fd), short event, void* arg)
d690 2
a691 2
	xfrd_state_t* xfrd = (xfrd_state_t*)arg;
        if ((event & EV_READ))
d695 1
a695 1
		xfrd_handle_ipc_read(&xfrd->ipc_handler, xfrd);
d697 1
a697 1
        if ((event & EV_WRITE))
d699 2
a700 2
		if(xfrd->ipc_send_blocked) { /* wait for RELOAD_DONE */
			ipc_xfrd_set_listening(xfrd, EV_PERSIST|EV_READ);
d703 25
a727 2
		if(xfrd->need_to_send_shutdown) {
			xfrd_send_shutdown_req(xfrd);
a731 2
		} else if(xfrd->need_to_send_stats) {
			xfrd_send_stats(xfrd);
a733 1
			!xfrd->need_to_send_shutdown &&
d735 3
a737 3
			!xfrd->need_to_send_stats) {
			/* disable writing for now */
			ipc_xfrd_set_listening(xfrd, EV_PERSIST|EV_READ);
d744 1
a744 1
xfrd_handle_ipc_read(struct event* handler, xfrd_state_t* xfrd)
a772 1
		buffer_type* tmp;
d782 14
a795 9
		/* use ipc_conn to read remaining data as well */
		tmp = xfrd->ipc_pass;
		xfrd->ipc_conn->is_reading=2;
		xfrd->ipc_pass = xfrd->ipc_conn->packet;
		xfrd->ipc_conn->packet = tmp;
		xfrd->ipc_conn->total_bytes = sizeof(xfrd->ipc_conn->msglen);
		xfrd->ipc_conn->msglen = 2*sizeof(uint32_t);
		buffer_clear(xfrd->ipc_conn->packet);
		buffer_set_limit(xfrd->ipc_conn->packet, xfrd->ipc_conn->msglen);
d799 3
a801 4
        if((len = read(handler->ev_fd, &cmd, sizeof(cmd))) == -1) {
		if(errno != EINTR && errno != EAGAIN)
                	log_msg(LOG_ERR, "xfrd_handle_ipc: read: %s",
                        	strerror(errno));
d815 1
a815 1
		DEBUG(DEBUG_IPC,1, (LOG_INFO, "xfrd: main sent shutdown cmd."));
d818 15
a832 1
	case NSD_RELOAD_DONE:
d834 1
a834 12
		DEBUG(DEBUG_IPC,1, (LOG_INFO, "xfrd: ipc recv RELOAD_DONE"));
#ifdef BIND8_STATS
		if(block_read(NULL, handler->ev_fd, &xfrd->reload_pid,
			sizeof(pid_t), -1) != sizeof(pid_t)) {
			log_msg(LOG_ERR, "xfrd cannot get reload_pid");
		}
#endif /* BIND8_STATS */
		/* read the not-mytask for the results and soainfo */
		xfrd_process_task_result(xfrd,
			xfrd->nsd->task[1-xfrd->nsd->mytask]);
		/* reset the IPC, (and the nonblocking ipc write;
		   the new parent does not want half a packet) */
d836 1
d838 1
a838 1
		ipc_xfrd_set_listening(xfrd, EV_PERSIST|EV_READ|EV_WRITE);
d841 1
d845 1
a847 7
	case NSD_RELOAD_REQ:
		DEBUG(DEBUG_IPC,1, (LOG_INFO, "xfrd: ipc recv RELOAD_REQ"));
		/* make reload happen, right away, and schedule file check */
		task_new_check_zonefiles(xfrd->nsd->task[xfrd->nsd->mytask],
			xfrd->last_task, NULL);
		xfrd_set_reload_now(xfrd);
		break;
d851 1
a851 1
		ipc_xfrd_set_listening(xfrd, EV_PERSIST|EV_READ|EV_WRITE);
d856 1
a856 1
			(int)ntohl(cmd));
d867 1
@


1.1.1.8
log
@update to NSD 4.1.0, ok sthen@@
@
text
@d227 1
d229 2
a230 16
			if(nsd->children[i].need_to_exit) {
				DEBUG(DEBUG_IPC,1, (LOG_INFO, "server %d is done",
					(int)nsd->children[i].pid));
				nsd->children[i].has_exited = 1;
			} else {
				log_msg(LOG_WARNING,
				       "server %d died unexpectedly, restarting",
				       (int)nsd->children[i].pid);
				/* this child is now going to be re-forked as
				 * a subprocess of this server-main, and if a
				 * reload is in progress the other children
				 * are subprocesses of reload.  Until the
				 * reload is done and they are all reforked. */
				nsd->children[i].pid = -1;
				nsd->restart_children = 1;
			}
a482 1
		nsd->reload_failed = 1;
@


1.1.1.9
log
@update to NSD 4.1.1, ok sthen@@
@
text
@a279 28
/** subtract stats from total */
void
stats_subtract(struct nsdst* total, struct nsdst* s)
{
	unsigned i;
	for(i=0; i<sizeof(total->qtype)/sizeof(stc_t); i++)
		total->qtype[i] -= s->qtype[i];
	for(i=0; i<sizeof(total->qclass)/sizeof(stc_t); i++)
		total->qclass[i] -= s->qclass[i];
	total->qudp -= s->qudp;
	total->qudp6 -= s->qudp6;
	total->ctcp -= s->ctcp;
	total->ctcp6 -= s->ctcp6;
	for(i=0; i<sizeof(total->rcode)/sizeof(stc_t); i++)
		total->rcode[i] -= s->rcode[i];
	for(i=0; i<sizeof(total->opcode)/sizeof(stc_t); i++)
		total->opcode[i] -= s->opcode[i];
	total->dropped -= s->dropped;
	total->truncated -= s->truncated;
	total->wrongzone -= s->wrongzone;
	total->txerr -= s->txerr;
	total->rxerr -= s->rxerr;
	total->edns -= s->edns;
	total->ednserr -= s->ednserr;
	total->raxfr -= s->raxfr;
	total->nona -= s->nona;
}

d720 1
d725 1
@


