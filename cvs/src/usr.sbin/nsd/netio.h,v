head	1.2;
access;
symbols
	OPENBSD_6_1:1.2.0.8
	OPENBSD_6_1_BASE:1.2
	OPENBSD_6_0:1.2.0.4
	OPENBSD_6_0_BASE:1.2
	OPENBSD_5_9:1.2.0.2
	OPENBSD_5_9_BASE:1.2
	NSD_4_1_6:1.1.1.5
	OPENBSD_5_8:1.1.1.5.0.10
	OPENBSD_5_8_BASE:1.1.1.5
	NSD_4_1_3:1.1.1.5
	OPENBSD_5_7:1.1.1.5.0.2
	OPENBSD_5_7_BASE:1.1.1.5
	NSD_4_1_1:1.1.1.5
	NSD_4_1_0:1.1.1.5
	OPENBSD_5_6:1.1.1.5.0.6
	OPENBSD_5_6_BASE:1.1.1.5
	NSD_4_0_3:1.1.1.5
	NSD_4_0_2:1.1.1.5
	OPENBSD_5_5:1.1.1.5.0.4
	OPENBSD_5_5_BASE:1.1.1.5
	NSD_4_0_1:1.1.1.5
	NSD_4_0_0:1.1.1.5
	NSD_3_2_16:1.1.1.4
	OPENBSD_5_4:1.1.1.3.0.6
	OPENBSD_5_4_BASE:1.1.1.3
	OPENBSD_5_3:1.1.1.3.0.4
	OPENBSD_5_3_BASE:1.1.1.3
	NSD_3_2_15:1.1.1.3
	NSD_3_2_14:1.1.1.3
	NSD_3_2_13:1.1.1.3
	OPENBSD_5_2:1.1.1.3.0.2
	OPENBSD_5_2_BASE:1.1.1.3
	NSD_3_2_11:1.1.1.3
	NSD_3_2_10:1.1.1.2
	OPENBSD_5_1_BASE:1.1.1.2
	OPENBSD_5_1:1.1.1.2.0.4
	NSD_3_2_9:1.1.1.2
	OPENBSD_5_0:1.1.1.2.0.2
	OPENBSD_5_0_BASE:1.1.1.2
	NSD_3_2_8:1.1.1.2
	OPENBSD_4_9:1.1.1.1.0.6
	OPENBSD_4_9_BASE:1.1.1.1
	NSD_3_2_6:1.1.1.1
	OPENBSD_4_8:1.1.1.1.0.4
	OPENBSD_4_8_BASE:1.1.1.1
	NSD_3_2_5:1.1.1.1
	OPENBSD_4_7:1.1.1.1.0.2
	OPENBSD_4_7_BASE:1.1.1.1
	NSD_3_2_4:1.1.1.1
	NLNETLABS:1.1.1;
locks; strict;
comment	@ * @;


1.2
date	2015.12.11.12.28.49;	author sthen;	state Exp;
branches;
next	1.1;
commitid	e67Hx722TeF4XpDl;

1.1
date	2010.01.15.19.24.51;	author jakob;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2010.01.15.19.24.51;	author jakob;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2011.05.21.18.17.23;	author jakob;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2012.07.09.21.55.07;	author sthen;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2013.09.03.09.21.36;	author sthen;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2013.11.26.12.50.18;	author sthen;	state Exp;
branches;
next	;


desc
@@


1.2
log
@update to NSD 4.1.7, ok florian@@
@
text
@/*
 * netio.h -- network I/O support.
 *
 * Copyright (c) 2001-2006, NLnet Labs. All rights reserved.
 *
 * See LICENSE for the license.
 *
 *
 * The netio module implements event based I/O handling using
 * pselect(2).  Multiple event handlers can wait for a certain event
 * to occur simultaneously.  Each event handler is called when an
 * event occurs that the event handler has indicated that it is
 * willing to handle.
 *
 * There are four types of events that can be handled:
 *
 *   NETIO_EVENT_READ: reading will not block.
 *   NETIO_EVENT_WRITE: writing will not block.
 *   NETIO_EVENT_TIMEOUT: the timeout expired.
 *
 * A file descriptor must be specified if the handler is interested in
 * the first three event types.  A timeout must be specified if the
 * event handler is interested in timeouts.  These event types can be
 * OR'ed together if the handler is willing to handle multiple types
 * of events.
 *
 * The special event type NETIO_EVENT_NONE is available if you wish to
 * temporarily disable the event handler without removing and adding
 * the handler to the netio structure.
 *
 * The event callbacks are free to modify the netio_handler_type
 * structure to change the file descriptor, timeout, event types, user
 * data, or handler functions.
 *
 * The main loop of the program must call netio_dispatch to check for
 * events and dispatch them to the handlers.  An additional timeout
 * can be specified as well as the signal mask to install while
 * blocked in pselect(2).
 */

#ifndef _NETIO_H_
#define _NETIO_H_

#ifdef	HAVE_SYS_SELECT_H
#include <sys/select.h>
#endif

#include <signal.h>

#include "region-allocator.h"

/*
 * The type of events a handler is interested in.  These can be OR'ed
 * together to specify multiple event types.
 */
enum netio_event_types {
	NETIO_EVENT_NONE    = 0,
	NETIO_EVENT_READ    = 1,
	NETIO_EVENT_WRITE   = 2,
	NETIO_EVENT_TIMEOUT = 4,
};
typedef enum netio_event_types netio_event_types_type;

typedef struct netio netio_type;
typedef struct netio_handler netio_handler_type;
typedef struct netio_handler_list netio_handler_list_type;

struct netio
{
	region_type             *region;
	netio_handler_list_type *handlers;
	netio_handler_list_type *deallocated;

	/*
	 * Cached value of the current time.  The cached value is
	 * cleared at the start of netio_dispatch to calculate the
	 * relative timeouts of the event handlers and after calling
	 * pselect(2) so handlers can use it to calculate a new
	 * absolute timeout.
	 *
	 * Use netio_current_time() to read the current time.
	 */
	int have_current_time;
	struct timespec cached_current_time;

	/*
	 * Next handler in the dispatch. Only valid during callbacks.
	 * To make sure that deletes respect the state of the iterator.
	 */
	netio_handler_list_type *dispatch_next;
};

typedef void (*netio_event_handler_type)(netio_type *netio,
					 netio_handler_type *handler,
					 netio_event_types_type event_types);

struct netio_handler
{
	/*
	 * The file descriptor that should be checked for events.  If
	 * the file descriptor is negative only timeout events are
	 * checked for.
	 */
	int fd;

	/** index of the pollfd array for this handler */
	int pfd;

	/*
	 * The time when no events should be checked for and the
	 * handler should be called with the NETIO_EVENT_TIMEOUT
	 * event type.  Unlike most timeout parameters the time should
	 * be absolute, not relative!
	 */
	struct timespec *timeout;

	/*
	 * Additional user data.
	 */
	void *user_data;

	/*
	 * The type of events that should be checked for.  These types
	 * can be OR'ed together to wait for multiple types of events.
	 */
	netio_event_types_type event_types;

	/*
	 * The event handler.  The event_types parameter contains the
	 * OR'ed set of event types that actually triggered.  The
	 * event handler is allowed to modify this handler object.
	 * The event handler SHOULD NOT block.
	 */
	netio_event_handler_type event_handler;
};


struct netio_handler_list
{
	netio_handler_list_type *next;
	netio_handler_type      *handler;
};


/*
 * Create a new netio instance using the specified REGION.  The netio
 * instance is cleaned up when the REGION is deallocated.
 */
netio_type *netio_create(region_type *region);

/*
 * Add a new HANDLER to NETIO.
 */
void netio_add_handler(netio_type *netio, netio_handler_type *handler);

/*
 * Remove the HANDLER from NETIO.
 */
void netio_remove_handler(netio_type *netio, netio_handler_type *handler);

/*
 * Retrieve the current time (using gettimeofday(2).
 */
const struct timespec *netio_current_time(netio_type *netio);

/*
 * Check for events and dispatch them to the handlers.  If TIMEOUT is
 * specified it specifies the maximum time to wait for an event to
 * arrive.  SIGMASK is passed to the underlying pselect(2) call.
 * Returns the number of non-timeout events dispatched, 0 on timeout,
 * and -1 on error (with errno set appropriately).
 */
int netio_dispatch(netio_type *netio,
		   const struct timespec *timeout,
		   const sigset_t *sigmask);


#ifdef __cplusplus
inline netio_event_types_type
operator | (netio_event_types_type lhs, netio_event_types_type rhs) {
	return (netio_event_types_type) (lhs | rhs);
}
inline netio_event_types_type
operator |= (netio_event_types_type &lhs, netio_event_types_type rhs) {
	lhs = (netio_event_types_type) (lhs | rhs);
	return lhs;
}
#endif /* __cplusplus */

#endif /* _NETIO_H_ */
@


1.1
log
@Initial revision
@
text
@a18 1
 *   NETIO_EVENT_EXCEPT: an exception occurred.
d60 1
a60 2
	NETIO_EVENT_EXCEPT  = 4,
	NETIO_EVENT_TIMEOUT = 8
d106 3
d135 7
@


1.1.1.1
log
@NSD v3.2.4
@
text
@@


1.1.1.2
log
@NSD v3.2.8
@
text
@d4 1
a4 1
 * Copyright (c) 2001-2011, NLnet Labs. All rights reserved.
@


1.1.1.3
log
@NSD v3.2.11, ok phessler@@
@
text
@a52 2
#define NETIO_SLOW_ACCEPT_TIMEOUT 2 /* in seconds */

d62 1
a62 2
	NETIO_EVENT_TIMEOUT = 8,
	NETIO_EVENT_ACCEPT  = 16
@


1.1.1.4
log
@update to NSD 3.2.16, ok deraadt@@ brad@@
@
text
@a139 7
struct netio_handler_list
{
	netio_handler_list_type *next;
	netio_handler_type      *handler;
};


@


1.1.1.5
log
@import NSD 4.0.0, tests from Dorian BÃ¼ttner, Patrik Lundin, requested by brad@@
@
text
@d4 1
a4 1
 * Copyright (c) 2001-2006, NLnet Labs. All rights reserved.
d53 2
d65 1
@


