head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_1:1.1.1.6.0.12
	OPENBSD_6_1_BASE:1.1.1.6
	OPENBSD_6_0:1.1.1.6.0.8
	OPENBSD_6_0_BASE:1.1.1.6
	OPENBSD_5_9:1.1.1.6.0.4
	OPENBSD_5_9_BASE:1.1.1.6
	NSD_4_1_6:1.1.1.6
	OPENBSD_5_8:1.1.1.6.0.6
	OPENBSD_5_8_BASE:1.1.1.6
	NSD_4_1_3:1.1.1.6
	OPENBSD_5_7:1.1.1.6.0.2
	OPENBSD_5_7_BASE:1.1.1.6
	NSD_4_1_1:1.1.1.6
	NSD_4_1_0:1.1.1.6
	OPENBSD_5_6:1.1.1.5.0.6
	OPENBSD_5_6_BASE:1.1.1.5
	NSD_4_0_3:1.1.1.5
	NSD_4_0_2:1.1.1.5
	OPENBSD_5_5:1.1.1.5.0.4
	OPENBSD_5_5_BASE:1.1.1.5
	NSD_4_0_1:1.1.1.5
	NSD_4_0_0:1.1.1.5
	NSD_3_2_16:1.1.1.4
	OPENBSD_5_4:1.1.1.4.0.4
	OPENBSD_5_4_BASE:1.1.1.4
	OPENBSD_5_3:1.1.1.4.0.2
	OPENBSD_5_3_BASE:1.1.1.4
	NSD_3_2_15:1.1.1.4
	NSD_3_2_14:1.1.1.3
	NSD_3_2_13:1.1.1.3
	OPENBSD_5_2:1.1.1.3.0.4
	OPENBSD_5_2_BASE:1.1.1.3
	NSD_3_2_11:1.1.1.3
	NSD_3_2_10:1.1.1.3
	OPENBSD_5_1_BASE:1.1.1.3
	OPENBSD_5_1:1.1.1.3.0.2
	NSD_3_2_9:1.1.1.3
	OPENBSD_5_0:1.1.1.2.0.2
	OPENBSD_5_0_BASE:1.1.1.2
	NSD_3_2_8:1.1.1.2
	OPENBSD_4_9:1.1.1.1.0.6
	OPENBSD_4_9_BASE:1.1.1.1
	NSD_3_2_6:1.1.1.1
	OPENBSD_4_8:1.1.1.1.0.4
	OPENBSD_4_8_BASE:1.1.1.1
	NSD_3_2_5:1.1.1.1
	OPENBSD_4_7:1.1.1.1.0.2
	OPENBSD_4_7_BASE:1.1.1.1
	NSD_3_2_4:1.1.1.1
	NLNETLABS:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	2010.01.15.19.24.55;	author jakob;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2010.01.15.19.24.55;	author jakob;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2011.05.21.18.17.18;	author jakob;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2012.01.29.11.15.36;	author jakob;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2013.02.18.10.17.40;	author sthen;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2013.11.26.12.50.10;	author sthen;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2014.09.16.16.53.58;	author brad;	state Exp;
branches;
next	;
commitid	BWSdZeElrpYSRdME;


desc
@@


1.1
log
@Initial revision
@
text
@/*
 * nsec3.h -- nsec3 handling.
 *
 * Copyright (c) 2001-2006, NLnet Labs. All rights reserved.
 *
 * See LICENSE for the license.
 *
 */
#ifndef NSEC3_H
#define NSEC3_H

#include <config.h>
#ifdef NSEC3

struct domain;
struct dname;
struct region;
struct zone;
struct namedb;
struct query;
struct answer;

/*
 * Create the hashed name of the nsec3 record
 * for the given dname.
 */
const struct dname *nsec3_hash_dname(struct region *region,
	struct zone *zone, const struct dname *dname);

/*
 * calculate prehash information for all zones,
 * selects only updated=1 zones if bool set.
 */
void prehash(struct namedb* db, int updated_only);

/*
 * finds nsec3 that covers the given domain dname.
 * returns true if the find is exact.
 * hashname is the already hashed dname for the NSEC3.
 */
int nsec3_find_cover(struct namedb* db, struct zone* zone,
	const struct dname* hashname, struct domain** result);

/*
 * _answer_ Routines used to add the correct nsec3 record to a query answer.
 * cnames etc may have been followed, hence original name.
 */
/*
 * add proof for wildcards that the name below the wildcard.parent
 * does not exist
 */
void nsec3_answer_wildcard(struct query *query, struct answer *answer,
        struct domain *wildcard, struct namedb* db,
	const struct dname *qname);

/*
 * add NSEC3 to provide domain name but not rrset exists,
 * this could be a query for a DS or NSEC3 type
 */
void nsec3_answer_nodata(struct query *query, struct answer *answer,
	struct domain *original);

/*
 * add NSEC3 for a delegation (optout stuff)
 */
void nsec3_answer_delegation(struct query *query, struct answer *answer);

/*
 * add NSEC3 for authoritative answers.
 * match==0 is an nxdomain.
 */
void nsec3_answer_authoritative(struct domain** match, struct query *query,
	struct answer *answer, struct domain* closest_encloser,
	struct namedb* db, const struct dname* qname);

/*
 * True if domain is a NSEC3 (+RRSIG) data only variety.
 * pass nonNULL zone to filter for particular zone.
 */
int domain_has_only_NSEC3(struct domain* domain, struct zone* zone);

#endif /* NSEC3 */
#endif /* NSEC3_H*/
@


1.1.1.1
log
@NSD v3.2.4
@
text
@@


1.1.1.2
log
@NSD v3.2.8
@
text
@d4 1
a4 1
 * Copyright (c) 2001-2011, NLnet Labs. All rights reserved.
@


1.1.1.3
log
@NSD v3.2.9
@
text
@a21 4
#ifndef FULL_PREHASH
struct rr;
struct nsec3_domain;
#endif
a34 4
#ifndef FULL_PREHASH
void prehash_zone(struct namedb *db, struct zone *zone);
void prehash_zone_incremental(struct namedb *db, struct zone *zone);
#endif
a40 1
#ifdef FULL_PREHASH
a42 4
#else
int nsec3_find_cover(struct namedb* ATTR_UNUSED(db), struct zone* zone,
	const struct dname* hashname, struct nsec3_domain** result);
#endif
@


1.1.1.4
log
@Update to NSD 3.2.15, ok brad@@ phessler@@ deraadt@@ also tested by okan@@
@
text
@d12 1
a12 1
#include "config.h"
@


1.1.1.5
log
@import NSD 4.0.0, tests from Dorian BÃ¼ttner, Patrik Lundin, requested by brad@@
@
text
@d4 1
a4 1
 * Copyright (c) 2001-2006, NLnet Labs. All rights reserved.
d12 1
d14 1
a14 1
struct udb_ptr;
d22 1
d24 2
d28 2
a29 1
 * calculate prehash information for zone.
d31 3
a33 1
void prehash_zone(struct namedb* db, struct zone* zone);
d35 2
a36 1
 * calculate prehash for zone, assumes no partial precompile or prehashlist
d38 5
a42 1
void prehash_zone_complete(struct namedb* db, struct zone* zone);
d45 1
a45 1
 * finds nsec3 that covers the given domain hash.
d47 1
d49 7
a55 2
int nsec3_find_cover(struct zone* zone, uint8_t* hash, size_t hashlen,
	struct domain** result);
d65 3
a67 2
void nsec3_answer_wildcard(struct query* query, struct answer* answer,
        struct domain* wildcard, const struct dname* qname);
d87 1
a87 1
	const struct dname* qname);
a93 43

/* get hashed bytes */
void nsec3_hash_and_store(struct zone* zone, const struct dname* dname,
	uint8_t* store);
/* see if NSEC3 record uses the params in use for the zone */
int nsec3_rr_uses_params(struct rr* rr, struct zone* zone);
/* number of NSEC3s that are in the zone chain */
int nsec3_in_chain_count(struct domain* domain, struct zone* zone);
/* find previous NSEC3, or, lastinzone, or, NULL */
struct domain* nsec3_chain_find_prev(struct zone* zone, struct domain* domain);
/* clear nsec3 precompile for the zone */
void nsec3_clear_precompile(struct namedb* db, struct zone* zone);
/* if domain is part of nsec3hashed domains of a zone */
int nsec3_domain_part_of_zone(struct domain* d, struct zone* z);
/* condition when a domain is precompiled */
int nsec3_condition_hash(struct domain* d, struct zone* z);
/* condition when a domain is ds precompiled */
int nsec3_condition_dshash(struct domain* d, struct zone* z);
/* set nsec3param for this zone or NULL if no NSEC3 available */
void nsec3_find_zone_param(struct namedb* db, struct zone* zone,
	struct udb_ptr* z);
/* hash domain and wcchild, and lookup nsec3 in tree, and precompile */
void nsec3_precompile_domain(struct namedb* db, struct domain* domain,
	struct zone* zone, struct region* tmpregion);
/* hash ds_parent_cover, and lookup nsec3 and precompile */
void nsec3_precompile_domain_ds(struct namedb* db, struct domain* domain,
	struct zone* zone);
/* put nsec3 into nsec3tree and adjust zonelast */
void nsec3_precompile_nsec3rr(struct namedb* db, struct domain* domain,
	struct zone* zone);
/* precompile entire zone, assumes all is null at start */
void nsec3_precompile_newparam(struct namedb* db, struct zone* zone);
/* create b32.zone for a hash, allocated in the region */
const struct dname* nsec3_b32_create(struct region* region, struct zone* zone,
	unsigned char* hash);
/* create trees for nsec3 updates and lookups in zone */
void nsec3_zone_trees_create(struct region* region, struct zone* zone);
/* clear trees for nsec3 in zone */
void nsec3_hash_tree_clear(struct zone* zone);
/* lookup zone that contains domain's nsec3 trees */
struct zone* nsec3_tree_zone(struct namedb* db, struct domain* domain);
/* lookup zone that contains domain's ds tree */
struct zone* nsec3_tree_dszone(struct namedb* db, struct domain* domain);
@


1.1.1.6
log
@update to NSD 4.1.0, ok sthen@@
@
text
@d95 1
a95 1
	struct udb_ptr* z, struct rr* avoid_rr);
@


