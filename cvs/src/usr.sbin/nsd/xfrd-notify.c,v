head	1.2;
access;
symbols
	OPENBSD_6_1:1.2.0.4
	OPENBSD_6_1_BASE:1.2
	OPENBSD_6_0:1.1.1.8.0.4
	OPENBSD_6_0_BASE:1.1.1.8
	OPENBSD_5_9:1.1.1.8.0.2
	OPENBSD_5_9_BASE:1.1.1.8
	NSD_4_1_6:1.1.1.8
	OPENBSD_5_8:1.1.1.7.0.10
	OPENBSD_5_8_BASE:1.1.1.7
	NSD_4_1_3:1.1.1.7
	OPENBSD_5_7:1.1.1.7.0.2
	OPENBSD_5_7_BASE:1.1.1.7
	NSD_4_1_1:1.1.1.7
	NSD_4_1_0:1.1.1.7
	OPENBSD_5_6:1.1.1.7.0.6
	OPENBSD_5_6_BASE:1.1.1.7
	NSD_4_0_3:1.1.1.7
	NSD_4_0_2:1.1.1.7
	OPENBSD_5_5:1.1.1.7.0.4
	OPENBSD_5_5_BASE:1.1.1.7
	NSD_4_0_1:1.1.1.7
	NSD_4_0_0:1.1.1.7
	NSD_3_2_16:1.1.1.6
	OPENBSD_5_4:1.1.1.6.0.4
	OPENBSD_5_4_BASE:1.1.1.6
	OPENBSD_5_3:1.1.1.6.0.2
	OPENBSD_5_3_BASE:1.1.1.6
	NSD_3_2_15:1.1.1.6
	NSD_3_2_14:1.1.1.6
	NSD_3_2_13:1.1.1.5
	OPENBSD_5_2:1.1.1.5.0.2
	OPENBSD_5_2_BASE:1.1.1.5
	NSD_3_2_11:1.1.1.5
	NSD_3_2_10:1.1.1.4
	OPENBSD_5_1_BASE:1.1.1.4
	OPENBSD_5_1:1.1.1.4.0.2
	NSD_3_2_9:1.1.1.4
	OPENBSD_5_0:1.1.1.3.0.2
	OPENBSD_5_0_BASE:1.1.1.3
	NSD_3_2_8:1.1.1.3
	OPENBSD_4_9:1.1.1.2.0.2
	OPENBSD_4_9_BASE:1.1.1.2
	NSD_3_2_6:1.1.1.2
	OPENBSD_4_8:1.1.1.1.0.4
	OPENBSD_4_8_BASE:1.1.1.1
	NSD_3_2_5:1.1.1.1
	OPENBSD_4_7:1.1.1.1.0.2
	OPENBSD_4_7_BASE:1.1.1.1
	NSD_3_2_4:1.1.1.1
	NLNETLABS:1.1.1;
locks; strict;
comment	@ * @;


1.2
date	2017.02.17.20.04.45;	author florian;	state Exp;
branches;
next	1.1;
commitid	WmSuN5M3Jbe54113;

1.1
date	2010.01.15.19.25.00;	author jakob;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2010.01.15.19.25.00;	author jakob;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2010.08.22.09.21.37;	author jakob;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2011.05.21.18.17.10;	author jakob;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2012.01.29.11.15.31;	author jakob;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2012.07.09.21.55.06;	author sthen;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2012.11.23.20.29.13;	author sthen;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2013.11.26.12.50.15;	author sthen;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2015.11.05.21.21.04;	author sthen;	state Exp;
branches;
next	;
commitid	RXfGmPAh2IZTjnIf;


desc
@@


1.2
log
@Update to 4.1.15.
This contains a local patch to query.c (missed _t conversion) that has
been submitted upstream.
OK sthen
@
text
@/*
 * xfrd-notify.c - notify sending routines
 *
 * Copyright (c) 2006, NLnet Labs. All rights reserved.
 *
 * See LICENSE for the license.
 *
 */

#include "config.h"
#include <assert.h>
#include <string.h>
#include <unistd.h>
#include <errno.h>
#include "xfrd-notify.h"
#include "xfrd.h"
#include "xfrd-tcp.h"
#include "packet.h"

#define XFRD_NOTIFY_RETRY_TIMOUT 15 /* seconds between retries sending NOTIFY */

/* start sending notifies */
static void notify_enable(struct notify_zone* zone,
	struct xfrd_soa* new_soa);
/* setup the notify active state */
static void setup_notify_active(struct notify_zone* zone);

/* returns if the notify send is done for the notify_current acl */
static int xfrd_handle_notify_reply(struct notify_zone* zone, buffer_type* packet);

/* handle zone notify send */
static void xfrd_handle_notify_send(int fd, short event, void* arg);

static void xfrd_notify_next(struct notify_zone* zone);

static void xfrd_notify_send_udp(struct notify_zone* zone, buffer_type* packet);

static void
notify_send_disable(struct notify_zone* zone)
{
	zone->notify_send_enable = 0;
	event_del(&zone->notify_send_handler);
	if(zone->notify_send_handler.ev_fd != -1) {
		close(zone->notify_send_handler.ev_fd);
	}
}

void
notify_disable(struct notify_zone* zone)
{
	zone->notify_current = 0;
	/* if added, then remove */
	if(zone->notify_send_enable) {
		notify_send_disable(zone);
	}

	if(xfrd->notify_udp_num == XFRD_MAX_UDP_NOTIFY) {
		/* find next waiting and needy zone */
		while(xfrd->notify_waiting_first) {
			/* snip off */
			struct notify_zone* wz = xfrd->notify_waiting_first;
			assert(wz->is_waiting);
			wz->is_waiting = 0;
			xfrd->notify_waiting_first = wz->waiting_next;
			if(wz->waiting_next)
				wz->waiting_next->waiting_prev = NULL;
			if(xfrd->notify_waiting_last == wz)
				xfrd->notify_waiting_last = NULL;
			/* see if this zone needs notify sending */
			if(wz->notify_current) {
				DEBUG(DEBUG_XFRD,1, (LOG_INFO,
					"xfrd: zone %s: notify off waiting list.",
					zone->apex_str)	);
				setup_notify_active(wz);
				return;
			}
		}
	}
	xfrd->notify_udp_num--;
}

void
init_notify_send(rbtree_type* tree, region_type* region,
	struct zone_options* options)
{
	struct notify_zone* not = (struct notify_zone*)
		region_alloc(region, sizeof(struct notify_zone));
	memset(not, 0, sizeof(struct notify_zone));
	not->apex = options->node.key;
	not->apex_str = options->name;
	not->node.key = not->apex;
	not->options = options;

	/* if master zone and have a SOA */
	not->current_soa = (struct xfrd_soa*)region_alloc(region,
		sizeof(struct xfrd_soa));
	memset(not->current_soa, 0, sizeof(struct xfrd_soa));

	not->is_waiting = 0;

	not->notify_send_enable = 0;
	tsig_create_record_custom(&not->notify_tsig, NULL, 0, 0, 4);
	not->notify_current = 0;
	rbtree_insert(tree, (rbnode_type*)not);
}

void
xfrd_del_notify(xfrd_state_type* xfrd, const dname_type* dname)
{
	/* find it */
	struct notify_zone* not = (struct notify_zone*)rbtree_delete(
		xfrd->notify_zones, dname);
	if(!not)
		return;

	/* waiting list */
	if(not->is_waiting) {
		if(not->waiting_prev)
			not->waiting_prev->waiting_next = not->waiting_next;
		else	xfrd->notify_waiting_first = not->waiting_next;
		if(not->waiting_next)
			not->waiting_next->waiting_prev = not->waiting_prev;
		else	xfrd->notify_waiting_last = not->waiting_prev;
		not->is_waiting = 0;
	}

	/* event */
	if(not->notify_send_enable) {
		notify_disable(not);
	}

	/* del tsig */
	tsig_delete_record(&not->notify_tsig, NULL);

	/* free it */
	region_recycle(xfrd->region, not->current_soa, sizeof(xfrd_soa_type));
	/* the apex is recycled when the zone_options.node.key is removed */
	region_recycle(xfrd->region, not, sizeof(*not));
}

static int
xfrd_handle_notify_reply(struct notify_zone* zone, buffer_type* packet)
{
	if((OPCODE(packet) != OPCODE_NOTIFY) ||
		(QR(packet) == 0)) {
		log_msg(LOG_ERR, "xfrd: zone %s: received bad notify reply opcode/flags",
			zone->apex_str);
		return 0;
	}
	/* we know it is OPCODE NOTIFY, QUERY_REPLY and for this zone */
	if(ID(packet) != zone->notify_query_id) {
		log_msg(LOG_ERR, "xfrd: zone %s: received notify-ack with bad ID",
			zone->apex_str);
		return 0;
	}
	/* could check tsig, but why. The reply does not cause processing. */
	if(RCODE(packet) != RCODE_OK) {
		log_msg(LOG_ERR, "xfrd: zone %s: received notify response error %s from %s",
			zone->apex_str, rcode2str(RCODE(packet)),
			zone->notify_current->ip_address_spec);
		if(RCODE(packet) == RCODE_IMPL)
			return 1; /* rfc1996: notimpl notify reply: consider retries done */
		return 0;
	}
	DEBUG(DEBUG_XFRD,1, (LOG_INFO, "xfrd: zone %s: host %s acknowledges notify",
		zone->apex_str, zone->notify_current->ip_address_spec));
	return 1;
}

static void
xfrd_notify_next(struct notify_zone* zone)
{
	/* advance to next in acl */
	zone->notify_current = zone->notify_current->next;
	zone->notify_retry = 0;
	if(zone->notify_current == 0) {
		DEBUG(DEBUG_XFRD,1, (LOG_INFO,
			"xfrd: zone %s: no more notify-send acls. stop notify.",
			zone->apex_str));
		notify_disable(zone);
		return;
	}
}

static void
xfrd_notify_send_udp(struct notify_zone* zone, buffer_type* packet)
{
	int fd;
	if(zone->notify_send_enable) {
		notify_send_disable(zone);
	}
	/* Set timeout for next reply */
	zone->notify_timeout.tv_sec = XFRD_NOTIFY_RETRY_TIMOUT;
	/* send NOTIFY to secondary. */
	xfrd_setup_packet(packet, TYPE_SOA, CLASS_IN, zone->apex,
		qid_generate());
	zone->notify_query_id = ID(packet);
	OPCODE_SET(packet, OPCODE_NOTIFY);
	AA_SET(packet);
	if(zone->current_soa->serial != 0) {
		/* add current SOA to answer section */
		ANCOUNT_SET(packet, 1);
		xfrd_write_soa_buffer(packet, zone->apex, zone->current_soa);
	}
	if(zone->notify_current->key_options) {
		xfrd_tsig_sign_request(packet, &zone->notify_tsig, zone->notify_current);
	}
	buffer_flip(packet);
	fd = xfrd_send_udp(zone->notify_current, packet,
		zone->options->pattern->outgoing_interface);
	if(fd == -1) {
		log_msg(LOG_ERR, "xfrd: zone %s: could not send notify #%d to %s",
			zone->apex_str, zone->notify_retry,
			zone->notify_current->ip_address_spec);
		event_set(&zone->notify_send_handler, -1, EV_TIMEOUT,
			xfrd_handle_notify_send, zone);
		if(event_base_set(xfrd->event_base, &zone->notify_send_handler) != 0)
			log_msg(LOG_ERR, "notify_send: event_base_set failed");
		if(evtimer_add(&zone->notify_send_handler, &zone->notify_timeout) != 0)
			log_msg(LOG_ERR, "notify_send: evtimer_add failed");
		zone->notify_send_enable = 1;
		return;
	}
	event_set(&zone->notify_send_handler, fd, EV_READ | EV_TIMEOUT,
		xfrd_handle_notify_send, zone);
	if(event_base_set(xfrd->event_base, &zone->notify_send_handler) != 0)
		log_msg(LOG_ERR, "notify_send: event_base_set failed");
	if(event_add(&zone->notify_send_handler, &zone->notify_timeout) != 0)
		log_msg(LOG_ERR, "notify_send: evtimer_add failed");
	zone->notify_send_enable = 1;
	DEBUG(DEBUG_XFRD,1, (LOG_INFO, "xfrd: zone %s: sent notify #%d to %s",
		zone->apex_str, zone->notify_retry,
		zone->notify_current->ip_address_spec));
}

static void
xfrd_handle_notify_send(int fd, short event, void* arg)
{
	struct notify_zone* zone = (struct notify_zone*)arg;
	buffer_type* packet = xfrd_get_temp_buffer();
	assert(zone->notify_current);
	if(zone->is_waiting) {
		DEBUG(DEBUG_XFRD,1, (LOG_INFO,
			"xfrd: notify waiting, skipped, %s", zone->apex_str));
		return;
	}
	if((event & EV_READ)) {
		DEBUG(DEBUG_XFRD,1, (LOG_INFO,
			"xfrd: zone %s: read notify ACK", zone->apex_str));
		assert(fd != -1);
		if(xfrd_udp_read_packet(packet, fd)) {
			if(xfrd_handle_notify_reply(zone, packet))
				xfrd_notify_next(zone);
		}
	} else if((event & EV_TIMEOUT)) {
		DEBUG(DEBUG_XFRD,1, (LOG_INFO, "xfrd: zone %s: notify timeout",
			zone->apex_str));
		/* timeout, try again */
	}
	/* see if notify is still enabled */
	if(zone->notify_current) {
		zone->notify_retry++;
		if(zone->notify_retry > zone->options->pattern->notify_retry) {
			log_msg(LOG_ERR, "xfrd: zone %s: max notify send count reached, %s unreachable",
				zone->apex_str, zone->notify_current->ip_address_spec);
			xfrd_notify_next(zone);
		}
	}
	if(zone->notify_current) {
		/* try again */
		xfrd_notify_send_udp(zone, packet);
	}
}

static void
setup_notify_active(struct notify_zone* zone)
{
	zone->notify_retry = 0;
	zone->notify_current = zone->options->pattern->notify;
	zone->notify_timeout.tv_sec = 0;
	zone->notify_timeout.tv_usec = 0;

	if(zone->notify_send_enable)
		notify_send_disable(zone);
	event_set(&zone->notify_send_handler, -1, EV_TIMEOUT,
		xfrd_handle_notify_send, zone);
	if(event_base_set(xfrd->event_base, &zone->notify_send_handler) != 0)
		log_msg(LOG_ERR, "notifysend: event_base_set failed");
	if(evtimer_add(&zone->notify_send_handler, &zone->notify_timeout) != 0)
		log_msg(LOG_ERR, "notifysend: evtimer_add failed");
	zone->notify_send_enable = 1;
}

static void
notify_enable(struct notify_zone* zone, struct xfrd_soa* new_soa)
{
	if(!zone->options->pattern->notify) {
		return; /* no notify acl, nothing to do */
	}

	if(new_soa == NULL)
		memset(zone->current_soa, 0, sizeof(xfrd_soa_type));
	else
		memcpy(zone->current_soa, new_soa, sizeof(xfrd_soa_type));
	if(zone->is_waiting)
		return;

	if(xfrd->notify_udp_num < XFRD_MAX_UDP_NOTIFY) {
		setup_notify_active(zone);
		xfrd->notify_udp_num++;
		return;
	}
	/* put it in waiting list */
	zone->notify_current = zone->options->pattern->notify;
	zone->is_waiting = 1;
	zone->waiting_next = NULL;
	zone->waiting_prev = xfrd->notify_waiting_last;
	if(xfrd->notify_waiting_last) {
		xfrd->notify_waiting_last->waiting_next = zone;
	} else {
		xfrd->notify_waiting_first = zone;
	}
	xfrd->notify_waiting_last = zone;
	DEBUG(DEBUG_XFRD,1, (LOG_INFO, "xfrd: zone %s: notify on waiting list.",
		zone->apex_str));
}

void
xfrd_notify_start(struct notify_zone* zone, struct xfrd_state* xfrd)
{
	xfrd_zone_type* xz;
	if(zone->is_waiting || zone->notify_send_enable)
		return;
	xz = (xfrd_zone_type*)rbtree_search(xfrd->zones, zone->apex);
	if(xz && xz->soa_nsd_acquired)
		notify_enable(zone, &xz->soa_nsd);
	else	notify_enable(zone, NULL);
}

void
xfrd_send_notify(rbtree_type* tree, const dname_type* apex, struct xfrd_soa* new_soa)
{
	/* lookup the zone */
	struct notify_zone* zone = (struct notify_zone*)
		rbtree_search(tree, apex);
	assert(zone);
	if(zone->notify_send_enable)
		notify_disable(zone);

	notify_enable(zone, new_soa);
}

void
notify_handle_master_zone_soainfo(rbtree_type* tree,
	const dname_type* apex, struct xfrd_soa* new_soa)
{
	/* lookup the zone */
	struct notify_zone* zone = (struct notify_zone*)
		rbtree_search(tree, apex);
	if(!zone) return; /* got SOAINFO but zone was deleted meanwhile */

	/* check if SOA changed */
	if( (new_soa == NULL && zone->current_soa->serial == 0) ||
		(new_soa && new_soa->serial == zone->current_soa->serial))
		return;
	if(zone->notify_send_enable)
		notify_disable(zone);
	notify_enable(zone, new_soa);
}

void
close_notify_fds(rbtree_type* tree)
{
	struct notify_zone* zone;
	RBTREE_FOR(zone, struct notify_zone*, tree)
	{
		if(zone->notify_send_enable)
			notify_send_disable(zone);
	}
}
@


1.1
log
@Initial revision
@
text
@d10 1
a10 1
#include <config.h>
d23 1
a23 1
static void notify_enable(struct notify_zone_t* zone,
a24 2
/* stop sending notifies */
static void notify_disable(struct notify_zone_t* zone);
d26 1
a26 1
static void setup_notify_active(struct notify_zone_t* zone);
d29 1
a29 1
static int xfrd_handle_notify_reply(struct notify_zone_t* zone, buffer_type* packet);
d32 1
a32 2
static void xfrd_handle_notify_send(netio_type *netio,
        netio_handler_type *handler, netio_event_types_type event_types);
d34 1
a34 1
static void xfrd_notify_next(struct notify_zone_t* zone);
d36 1
a36 1
static void xfrd_notify_send_udp(struct notify_zone_t* zone, buffer_type* packet);
d39 11
a49 1
notify_disable(struct notify_zone_t* zone)
d52 3
a54 4
	zone->notify_send_handler.timeout = NULL;
	if(zone->notify_send_handler.fd != -1) {
		close(zone->notify_send_handler.fd);
		zone->notify_send_handler.fd = -1;
d61 1
a61 1
			struct notify_zone_t* wz = xfrd->notify_waiting_first;
d65 2
d83 2
a84 2
init_notify_send(rbtree_t* tree, netio_type* netio, region_type* region,
	const dname_type* apex, zone_options_t* options, zone_type* dbzone)
d86 4
a89 4
	struct notify_zone_t* not = (struct notify_zone_t*)
		region_alloc(region, sizeof(struct notify_zone_t));
	memset(not, 0, sizeof(struct notify_zone_t));
	not->apex = apex;
a97 3
	if(dbzone && dbzone->soa_rrset && dbzone->soa_rrset->rrs) {
		xfrd_copy_soa(not->current_soa,	dbzone->soa_rrset->rrs);
	}
a99 12
	not->notify_send_handler.fd = -1;
	not->notify_send_handler.timeout = 0;
	not->notify_send_handler.user_data = not;
	not->notify_send_handler.event_types = 
		NETIO_EVENT_READ|NETIO_EVENT_TIMEOUT;
	not->notify_send_handler.event_handler = xfrd_handle_notify_send;
		netio_add_handler(netio, &not->notify_send_handler);

#ifdef TSIG
		tsig_create_record_custom(&not->notify_tsig, region, 0, 0, 4);
#endif /* TSIG */
		not->notify_current = 0;
d101 38
a138 1
		rbtree_insert(tree, (rbnode_t*)not);
d142 1
a142 1
xfrd_handle_notify_reply(struct notify_zone_t* zone, buffer_type* packet)
d171 1
a171 1
xfrd_notify_next(struct notify_zone_t* zone)
d186 1
a186 1
xfrd_notify_send_udp(struct notify_zone_t* zone, buffer_type* packet)
d188 4
a191 3
	if(zone->notify_send_handler.fd != -1)
		close(zone->notify_send_handler.fd);
	zone->notify_send_handler.fd = -1;
d193 1
a193 1
	zone->notify_timeout.tv_sec = xfrd_time() + XFRD_NOTIFY_RETRY_TIMOUT;
d195 2
a196 1
	xfrd_setup_packet(packet, TYPE_SOA, CLASS_IN, zone->apex);
a204 1
#ifdef TSIG
a207 1
#endif /* TSIG */
d209 3
a211 3
	zone->notify_send_handler.fd = xfrd_send_udp(zone->notify_current,
		packet, zone->options->outgoing_interface);
	if(zone->notify_send_handler.fd == -1) {
d215 7
d224 7
d237 1
a237 2
xfrd_handle_notify_send(netio_type* ATTR_UNUSED(netio),
	netio_handler_type *handler, netio_event_types_type event_types)
d239 1
a239 1
	struct notify_zone_t* zone = (struct notify_zone_t*)handler->user_data;
a244 1
		assert(zone->notify_send_handler.fd == -1);
d247 1
a247 1
	if(event_types & NETIO_EVENT_READ) {
d250 2
a251 2
		assert(handler->fd != -1);
		if(xfrd_udp_read_packet(packet, zone->notify_send_handler.fd)) {
d255 1
a255 1
	} else if(event_types & NETIO_EVENT_TIMEOUT) {
d263 1
a263 1
		if(zone->notify_retry > zone->options->notify_retry) {
d276 1
a276 1
setup_notify_active(struct notify_zone_t* zone)
d279 13
a291 4
	zone->notify_current = zone->options->notify;
	zone->notify_send_handler.timeout = &zone->notify_timeout;
	zone->notify_timeout.tv_sec = xfrd_time();
	zone->notify_timeout.tv_nsec = 0;
d295 1
a295 1
notify_enable(struct notify_zone_t* zone, struct xfrd_soa* new_soa)
d297 1
a297 1
	if(!zone->options->notify) {
d302 1
a302 1
		memset(zone->current_soa, 0, sizeof(xfrd_soa_t));
d304 1
a304 1
		memcpy(zone->current_soa, new_soa, sizeof(xfrd_soa_t));
d314 1
a314 1
	zone->notify_current = zone->options->notify;
d317 1
a323 1
	zone->notify_send_handler.timeout = NULL;
d329 13
a341 1
xfrd_send_notify(rbtree_t* tree, const dname_type* apex, struct xfrd_soa* new_soa)
d344 1
a344 1
	struct notify_zone_t* zone = (struct notify_zone_t*)
d347 2
d354 1
a354 1
notify_handle_master_zone_soainfo(rbtree_t* tree,
d358 1
a358 1
	struct notify_zone_t* zone = (struct notify_zone_t*)
d360 1
a360 1
	assert(zone);
d366 2
a367 1

d371 2
a372 1
void close_notify_fds(rbtree_t* tree)
d374 2
a375 2
	struct notify_zone_t* zone;
	RBTREE_FOR(zone, struct notify_zone_t*, tree)
d377 2
a378 4
		if(zone->notify_send_handler.fd != -1) {
			close(zone->notify_send_handler.fd);
			zone->notify_send_handler.fd = -1;
		}
@


1.1.1.1
log
@NSD v3.2.4
@
text
@@


1.1.1.2
log
@NSD v3.2.6
@
text
@d98 1
a98 1
	not->notify_send_handler.event_types =
d101 8
a108 4
	netio_add_handler(netio, &not->notify_send_handler);
	tsig_create_record_custom(&not->notify_tsig, region, 0, 0, 4);
	not->notify_current = 0;
	rbtree_insert(tree, (rbnode_t*)not);
d173 1
d177 1
@


1.1.1.3
log
@NSD v3.2.8
@
text
@d4 1
a4 1
 * Copyright (c) 2006-2011, NLnet Labs. All rights reserved.
@


1.1.1.4
log
@NSD v3.2.9
@
text
@d4 1
a4 1
 * Copyright (c) 2001-2011, NLnet Labs. All rights reserved.
@


1.1.1.5
log
@NSD v3.2.11, ok phessler@@
@
text
@d10 1
a10 1
#include "config.h"
@


1.1.1.6
log
@update to NSD 3.2.14, requested by/ok brad@@
@
text
@d14 1
a14 1

@


1.1.1.7
log
@import NSD 4.0.0, tests from Dorian Büttner, Patrik Lundin, requested by brad@@
@
text
@d4 1
a4 1
 * Copyright (c) 2006, NLnet Labs. All rights reserved.
d14 1
a14 1
#include <errno.h>
d25 2
d34 2
a35 1
static void xfrd_handle_notify_send(int fd, short event, void* arg);
a41 10
notify_send_disable(struct notify_zone_t* zone)
{
	zone->notify_send_enable = 0;
	event_del(&zone->notify_send_handler);
	if(zone->notify_send_handler.ev_fd != -1) {
		close(zone->notify_send_handler.ev_fd);
	}
}

void
d45 4
a48 3
	/* if added, then remove */
	if(zone->notify_send_enable) {
		notify_send_disable(zone);
a58 2
			if(wz->waiting_next)
				wz->waiting_next->waiting_prev = NULL;
d75 2
a76 1
init_notify_send(rbtree_t* tree, region_type* region, zone_options_t* options)
d81 1
a81 1
	not->apex = options->node.key;
d90 3
d95 8
a102 3

	not->notify_send_enable = 0;
	tsig_create_record_custom(&not->notify_tsig, NULL, 0, 0, 4);
a106 34
void
xfrd_del_notify(xfrd_state_t* xfrd, const dname_type* dname)
{
	/* find it */
	struct notify_zone_t* not = (struct notify_zone_t*)rbtree_delete(
		xfrd->notify_zones, dname);
	if(!not)
		return;

	/* waiting list */
	if(not->is_waiting) {
		if(not->waiting_prev)
			not->waiting_prev->waiting_next = not->waiting_next;
		else	xfrd->notify_waiting_first = not->waiting_next;
		if(not->waiting_next)
			not->waiting_next->waiting_prev = not->waiting_prev;
		else	xfrd->notify_waiting_last = not->waiting_prev;
		not->is_waiting = 0;
	}

	/* event */
	if(not->notify_send_enable) {
		notify_disable(not);
	}

	/* del tsig */
	tsig_delete_record(&not->notify_tsig, NULL);

	/* free it */
	region_recycle(xfrd->region, not->current_soa, sizeof(xfrd_soa_t));
	/* the apex is recycled when the zone_options.node.key is removed */
	region_recycle(xfrd->region, not, sizeof(*not));
}

d154 3
a156 4
	int fd;
	if(zone->notify_send_enable) {
		notify_send_disable(zone);
	}
d158 1
a158 1
	zone->notify_timeout.tv_sec = XFRD_NOTIFY_RETRY_TIMOUT;
d160 1
a160 2
	xfrd_setup_packet(packet, TYPE_SOA, CLASS_IN, zone->apex,
		qid_generate());
d173 3
a175 3
	fd = xfrd_send_udp(zone->notify_current, packet,
		zone->options->pattern->outgoing_interface);
	if(fd == -1) {
a178 7
		event_set(&zone->notify_send_handler, -1, EV_TIMEOUT,
			xfrd_handle_notify_send, zone);
		if(event_base_set(xfrd->event_base, &zone->notify_send_handler) != 0)
			log_msg(LOG_ERR, "notify_send: event_base_set failed");
		if(evtimer_add(&zone->notify_send_handler, &zone->notify_timeout) != 0)
			log_msg(LOG_ERR, "notify_send: evtimer_add failed");
		zone->notify_send_enable = 1;
a180 7
	event_set(&zone->notify_send_handler, fd, EV_READ | EV_TIMEOUT,
		xfrd_handle_notify_send, zone);
	if(event_base_set(xfrd->event_base, &zone->notify_send_handler) != 0)
		log_msg(LOG_ERR, "notify_send: event_base_set failed");
	if(event_add(&zone->notify_send_handler, &zone->notify_timeout) != 0)
		log_msg(LOG_ERR, "notify_send: evtimer_add failed");
	zone->notify_send_enable = 1;
d187 2
a188 1
xfrd_handle_notify_send(int fd, short event, void* arg)
d190 1
a190 1
	struct notify_zone_t* zone = (struct notify_zone_t*)arg;
d196 1
d199 1
a199 1
	if((event & EV_READ)) {
d202 2
a203 2
		assert(fd != -1);
		if(xfrd_udp_read_packet(packet, fd)) {
d207 1
a207 1
	} else if((event & EV_TIMEOUT)) {
d215 1
a215 1
		if(zone->notify_retry > zone->options->pattern->notify_retry) {
d231 4
a234 13
	zone->notify_current = zone->options->pattern->notify;
	zone->notify_timeout.tv_sec = 0;
	zone->notify_timeout.tv_usec = 0;

	if(zone->notify_send_enable)
		notify_send_disable(zone);
	event_set(&zone->notify_send_handler, -1, EV_TIMEOUT,
		xfrd_handle_notify_send, zone);
	if(event_base_set(xfrd->event_base, &zone->notify_send_handler) != 0)
		log_msg(LOG_ERR, "notifysend: event_base_set failed");
	if(evtimer_add(&zone->notify_send_handler, &zone->notify_timeout) != 0)
		log_msg(LOG_ERR, "notifysend: evtimer_add failed");
	zone->notify_send_enable = 1;
d240 1
a240 1
	if(!zone->options->pattern->notify) {
d257 1
a257 1
	zone->notify_current = zone->options->pattern->notify;
a259 1
	zone->waiting_prev = xfrd->notify_waiting_last;
d266 1
a271 8
xfrd_notify_start(struct notify_zone_t* zone)
{
	if(zone->is_waiting || zone->notify_send_enable)
		return;
	notify_enable(zone, NULL);
}

void
a277 2
	if(zone->notify_send_enable)
		notify_disable(zone);
d289 1
a289 1
	if(!zone) return; /* got SOAINFO but zone was deleted meanwhile */
d295 1
a295 2
	if(zone->notify_send_enable)
		notify_disable(zone);
d299 1
a299 2
void
close_notify_fds(rbtree_t* tree)
d304 4
a307 2
		if(zone->notify_send_enable)
			notify_send_disable(zone);
@


1.1.1.8
log
@update to NSD 4.1.6, ok millert@@ florian@@
@
text
@d328 1
a328 1
xfrd_notify_start(struct notify_zone_t* zone, struct xfrd_state* xfrd)
a329 1
	xfrd_zone_t* xz;
d332 1
a332 4
	xz = (xfrd_zone_t*)rbtree_search(xfrd->zones, zone->apex);
	if(xz && xz->soa_nsd_acquired)
		notify_enable(zone, &xz->soa_nsd);
	else	notify_enable(zone, NULL);
@


