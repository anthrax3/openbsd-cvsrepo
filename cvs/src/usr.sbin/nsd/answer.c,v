head	1.2;
access;
symbols
	OPENBSD_6_0:1.2.0.2
	OPENBSD_6_0_BASE:1.2
	OPENBSD_5_9:1.1.1.6.0.8
	OPENBSD_5_9_BASE:1.1.1.6
	NSD_4_1_6:1.1.1.6
	OPENBSD_5_8:1.1.1.6.0.10
	OPENBSD_5_8_BASE:1.1.1.6
	NSD_4_1_3:1.1.1.6
	OPENBSD_5_7:1.1.1.6.0.2
	OPENBSD_5_7_BASE:1.1.1.6
	NSD_4_1_1:1.1.1.6
	NSD_4_1_0:1.1.1.6
	OPENBSD_5_6:1.1.1.6.0.6
	OPENBSD_5_6_BASE:1.1.1.6
	NSD_4_0_3:1.1.1.6
	NSD_4_0_2:1.1.1.6
	OPENBSD_5_5:1.1.1.6.0.4
	OPENBSD_5_5_BASE:1.1.1.6
	NSD_4_0_1:1.1.1.6
	NSD_4_0_0:1.1.1.5
	NSD_3_2_16:1.1.1.4
	OPENBSD_5_4:1.1.1.4.0.6
	OPENBSD_5_4_BASE:1.1.1.4
	OPENBSD_5_3:1.1.1.4.0.4
	OPENBSD_5_3_BASE:1.1.1.4
	NSD_3_2_15:1.1.1.4
	NSD_3_2_14:1.1.1.4
	NSD_3_2_13:1.1.1.4
	OPENBSD_5_2:1.1.1.4.0.2
	OPENBSD_5_2_BASE:1.1.1.4
	NSD_3_2_11:1.1.1.4
	NSD_3_2_10:1.1.1.3
	OPENBSD_5_1_BASE:1.1.1.3
	OPENBSD_5_1:1.1.1.3.0.2
	NSD_3_2_9:1.1.1.3
	OPENBSD_5_0:1.1.1.2.0.2
	OPENBSD_5_0_BASE:1.1.1.2
	NSD_3_2_8:1.1.1.2
	OPENBSD_4_9:1.1.1.1.0.6
	OPENBSD_4_9_BASE:1.1.1.1
	NSD_3_2_6:1.1.1.1
	OPENBSD_4_8:1.1.1.1.0.4
	OPENBSD_4_8_BASE:1.1.1.1
	NSD_3_2_5:1.1.1.1
	OPENBSD_4_7:1.1.1.1.0.2
	OPENBSD_4_7_BASE:1.1.1.1
	NSD_3_2_4:1.1.1.1
	NLNETLABS:1.1.1;
locks; strict;
comment	@ * @;


1.2
date	2016.06.24.08.34.03;	author florian;	state Exp;
branches;
next	1.1;
commitid	Z9jVKJJMPmC3zw2t;

1.1
date	2010.01.15.19.24.52;	author jakob;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2010.01.15.19.24.52;	author jakob;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2011.05.21.18.17.25;	author jakob;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2012.01.29.11.15.41;	author jakob;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2012.07.09.21.55.08;	author sthen;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2013.11.26.12.50.15;	author sthen;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2014.02.04.01.54.03;	author brad;	state Exp;
branches;
next	;


desc
@@


1.2
log
@Update to 4.1.10
Testing by millert@@, sthen@@ and me.
came up with the same diff & OK sthen@@
@
text
@/*
 * answer.c -- manipulating query answers and encoding them.
 *
 * Copyright (c) 2001-2006, NLnet Labs. All rights reserved.
 *
 * See LICENSE for the license.
 *
 */

#include "config.h"

#include <string.h>

#include "answer.h"
#include "packet.h"
#include "query.h"

void
answer_init(answer_type *answer)
{
	answer->rrset_count = 0;
}

int
answer_add_rrset(answer_type *answer, rr_section_type section,
		 domain_type *domain, rrset_type *rrset)
{
	size_t i;

	assert(section >= ANSWER_SECTION && section < RR_SECTION_COUNT);
	assert(domain);
	assert(rrset);

	/* Don't add an RRset multiple times.  */
	for (i = 0; i < answer->rrset_count; ++i) {
		if (answer->rrsets[i] == rrset &&
			answer->domains[i]->number == domain->number) {
			if (section < answer->section[i]) {
				answer->section[i] = section;
				return 1;
			} else {
				return 0;
			}
		}
	}

	if (answer->rrset_count >= MAXRRSPP) {
		/* XXX: Generate warning/error? */
		return 0;
	}

	answer->section[answer->rrset_count] = section;
	answer->domains[answer->rrset_count] = domain;
	answer->rrsets[answer->rrset_count] = rrset;
	++answer->rrset_count;

	return 1;
}

void
encode_answer(query_type *q, const answer_type *answer)
{
	uint16_t counts[RR_SECTION_COUNT];
	rr_section_type section;
	size_t i;
	int minimal_respsize = IPV4_MINIMAL_RESPONSE_SIZE;
	int done = 0;

#if defined(INET6) && defined(MINIMAL_RESPONSES)
	if (q->addr.ss_family == AF_INET6)
		minimal_respsize = IPV6_MINIMAL_RESPONSE_SIZE;
#endif

	for (section = ANSWER_SECTION; section < RR_SECTION_COUNT; ++section) {
		counts[section] = 0;
	}

	for (section = ANSWER_SECTION;
	     !TC(q->packet) && section < RR_SECTION_COUNT;
	     ++section) {

		for (i = 0; !TC(q->packet) && i < answer->rrset_count; ++i) {
			if (answer->section[i] == section) {
				counts[section] += packet_encode_rrset(
					q,
					answer->domains[i],
					answer->rrsets[i],
					section, minimal_respsize, &done);
			}
		}
#ifdef MINIMAL_RESPONSES
		/**
		 * done is set prematurely, because the minimal response size
		 * has been reached. No need to try adding RRsets in following
		 * sections.
		 */
		if (done) {
			/* delegations should have a usable address in it */
			if(section == ADDITIONAL_A_SECTION &&
				counts[ADDITIONAL_A_SECTION] == 0 &&
				q->delegation_domain)
				TC_SET(q->packet);
			break;
		}
#endif
	}

	ANCOUNT_SET(q->packet, counts[ANSWER_SECTION]);
	NSCOUNT_SET(q->packet,
		    counts[AUTHORITY_SECTION]
		    + counts[OPTIONAL_AUTHORITY_SECTION]);
	ARCOUNT_SET(q->packet,
		    counts[ADDITIONAL_A_SECTION]
		    + counts[ADDITIONAL_AAAA_SECTION]
		    + counts[ADDITIONAL_OTHER_SECTION]);
}
@


1.1
log
@Initial revision
@
text
@d10 1
a10 1
#include <config.h>
d36 2
a37 1
		if (answer->rrsets[i] == rrset) {
d66 7
d80 2
a81 2
	     ++section)
	{
d88 1
a88 1
					section);
d91 15
d109 3
a111 1
	NSCOUNT_SET(q->packet, counts[AUTHORITY_SECTION]);
@


1.1.1.1
log
@NSD v3.2.4
@
text
@@


1.1.1.2
log
@NSD v3.2.8
@
text
@d4 1
a4 1
 * Copyright (c) 2001-2011, NLnet Labs. All rights reserved.
@


1.1.1.3
log
@NSD v3.2.9
@
text
@a64 7
	int minimal_respsize = IPV4_MINIMAL_RESPONSE_SIZE;
	int done = 0;

#if defined(INET6) && defined(MINIMAL_RESPONSES)
	if (q->addr.ss_family == AF_INET6)
		minimal_respsize = IPV6_MINIMAL_RESPONSE_SIZE;
#endif
d72 2
a73 2
	     ++section) {

d80 1
a80 1
					section, minimal_respsize, &done);
a82 10
#ifdef MINIMAL_RESPONSES
		/**
		 * done is set prematurely, because the minimal response size
		 * has been reached. No need to try adding RRsets in following
		 * sections.
		 */
		if (done) {
			break;
		}
#endif
d86 1
a86 3
	NSCOUNT_SET(q->packet,
		    counts[AUTHORITY_SECTION]
		    + counts[OPTIONAL_AUTHORITY_SECTION]);
@


1.1.1.4
log
@NSD v3.2.11, ok phessler@@
@
text
@d10 1
a10 1
#include "config.h"
d36 1
a36 2
		if (answer->rrsets[i] == rrset &&
			answer->domains[i] == domain) {
@


1.1.1.5
log
@import NSD 4.0.0, tests from Dorian BÃ¼ttner, Patrik Lundin, requested by brad@@
@
text
@d4 1
a4 1
 * Copyright (c) 2001-2006, NLnet Labs. All rights reserved.
@


1.1.1.6
log
@update to NSD 4.0.1, ok sthen@@
@
text
@d37 1
a37 1
			answer->domains[i]->number == domain->number) {
@


