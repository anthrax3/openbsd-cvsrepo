head	1.2;
access;
symbols
	OPENBSD_6_1:1.2.0.2
	OPENBSD_6_1_BASE:1.2
	OPENBSD_6_0:1.1.1.6.0.8
	OPENBSD_6_0_BASE:1.1.1.6
	OPENBSD_5_9:1.1.1.6.0.4
	OPENBSD_5_9_BASE:1.1.1.6
	NSD_4_1_6:1.1.1.6
	OPENBSD_5_8:1.1.1.6.0.6
	OPENBSD_5_8_BASE:1.1.1.6
	NSD_4_1_3:1.1.1.6
	OPENBSD_5_7:1.1.1.6.0.2
	OPENBSD_5_7_BASE:1.1.1.6
	NSD_4_1_1:1.1.1.6
	NSD_4_1_0:1.1.1.5
	OPENBSD_5_6:1.1.1.5.0.6
	OPENBSD_5_6_BASE:1.1.1.5
	NSD_4_0_3:1.1.1.5
	NSD_4_0_2:1.1.1.5
	OPENBSD_5_5:1.1.1.5.0.4
	OPENBSD_5_5_BASE:1.1.1.5
	NSD_4_0_1:1.1.1.5
	NSD_4_0_0:1.1.1.4
	NSD_3_2_16:1.1.1.3
	OPENBSD_5_4:1.1.1.3.0.6
	OPENBSD_5_4_BASE:1.1.1.3
	OPENBSD_5_3:1.1.1.3.0.4
	OPENBSD_5_3_BASE:1.1.1.3
	NSD_3_2_15:1.1.1.3
	NSD_3_2_14:1.1.1.3
	NSD_3_2_13:1.1.1.3
	OPENBSD_5_2:1.1.1.3.0.2
	OPENBSD_5_2_BASE:1.1.1.3
	NSD_3_2_11:1.1.1.3
	NSD_3_2_10:1.1.1.2
	OPENBSD_5_1_BASE:1.1.1.2
	OPENBSD_5_1:1.1.1.2.0.4
	NSD_3_2_9:1.1.1.2
	OPENBSD_5_0:1.1.1.2.0.2
	OPENBSD_5_0_BASE:1.1.1.2
	NSD_3_2_8:1.1.1.2
	OPENBSD_4_9:1.1.1.1.0.6
	OPENBSD_4_9_BASE:1.1.1.1
	NSD_3_2_6:1.1.1.1
	OPENBSD_4_8:1.1.1.1.0.4
	OPENBSD_4_8_BASE:1.1.1.1
	NSD_3_2_5:1.1.1.1
	OPENBSD_4_7:1.1.1.1.0.2
	OPENBSD_4_7_BASE:1.1.1.1
	NSD_3_2_4:1.1.1.1
	NLNETLABS:1.1.1;
locks; strict;
comment	@ * @;


1.2
date	2017.02.17.20.04.45;	author florian;	state Exp;
branches;
next	1.1;
commitid	WmSuN5M3Jbe54113;

1.1
date	2010.01.15.19.24.49;	author jakob;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2010.01.15.19.24.49;	author jakob;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2011.05.21.18.17.19;	author jakob;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2012.07.09.21.55.07;	author sthen;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2013.11.26.12.50.19;	author sthen;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2014.02.04.01.54.07;	author brad;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2015.02.03.10.24.32;	author brad;	state Exp;
branches;
next	;
commitid	yn8l9RVkmdMVYIfl;


desc
@@


1.2
log
@Update to 4.1.15.
This contains a local patch to query.c (missed _t conversion) that has
been submitted upstream.
OK sthen
@
text
@/*
 * difffile.h - nsd.diff file handling header file. Read/write diff files.
 *
 * Copyright (c) 2001-2006, NLnet Labs. All rights reserved.
 *
 * See LICENSE for the license.
 *
 */
#ifndef DIFFFILE_H
#define DIFFFILE_H

#include "rbtree.h"
#include "namedb.h"
#include "options.h"
#include "udb.h"
struct nsd;
struct nsdst;

#define DIFF_PART_XXFR ('X'<<24 | 'X'<<16 | 'F'<<8 | 'R')
#define DIFF_PART_XFRF ('X'<<24 | 'F'<<16 | 'R'<<8 | 'F')

/* write an xfr packet data to the diff file, type=IXFR.
   The diff file is created if necessary, with initial header(notcommitted). */
void diff_write_packet(const char* zone, const char* pat, uint32_t old_serial,
	uint32_t new_serial, uint32_t seq_nr, uint8_t* data, size_t len,
	struct nsd* nsd, uint64_t filenumber);

/*
 * Overwrite header of diff file with committed vale and other data.
 * append log string.
 */
void diff_write_commit(const char* zone, uint32_t old_serial,
	uint32_t new_serial, uint32_t num_parts, uint8_t commit,
	const char* log_msg, struct nsd* nsd, uint64_t filenumber);

/*
 * These functions read parts of the diff file.
 */
int diff_read_32(FILE *in, uint32_t* result);
int diff_read_8(FILE *in, uint8_t* result);
int diff_read_str(FILE* in, char* buf, size_t len);

/* delete the RRs for a zone from memory */
void delete_zone_rrs(namedb_type* db, zone_type* zone);
/* delete an RR */
int delete_RR(namedb_type* db, const dname_type* dname,
	uint16_t type, uint16_t klass,
	buffer_type* packet, size_t rdatalen, zone_type *zone,
	region_type* temp_region, struct udb_ptr* udbz, int* softfail);
/* add an RR */
int add_RR(namedb_type* db, const dname_type* dname,
	uint16_t type, uint16_t klass, uint32_t ttl,
	buffer_type* packet, size_t rdatalen, zone_type *zone,
	struct udb_ptr* udbz, int* softfail);

/* task udb structure */
struct task_list_d {
	/** next task in list */
	udb_rel_ptr next;
	/** task type */
	enum {
		/** expire or un-expire a zone */
		task_expire,
		/** apply an ixfr or axfr to a zone */
		task_apply_xfr,
		/** soa info for zone */
		task_soa_info,
		/** check mtime of zonefiles and read them, done on SIGHUP */
		task_check_zonefiles,
		/** write zonefiles (if changed) */
		task_write_zonefiles,
		/** set verbosity */
		task_set_verbosity,
		/** statistic info */
		task_stat_info,
		/** add a zone */
		task_add_zone,
		/** delete zone */
		task_del_zone,
		/** add TSIG key */
		task_add_key,
		/** delete TSIG key */
		task_del_key,
		/** add pattern */
		task_add_pattern,
		/** delete pattern */
		task_del_pattern,
		/** options change */
		task_opt_change,
		/** zonestat increment */
		task_zonestat_inc
	} task_type;
	uint32_t size; /* size of this struct */

	/** soainfo: zonename dname, soaRR wireform */
	/** expire: zonename, boolyesno */
	/** apply_xfr: zonename, serials, yesno is filenamecounter */
	uint32_t oldserial, newserial;
	/** general variable.  for some used to see if zname is present. */
	uint64_t yesno;
	struct dname zname[0];
};
#define TASKLIST(ptr) ((struct task_list_d*)UDB_PTR(ptr))
/** create udb for tasks */
struct udb_base* task_file_create(const char* file);
void task_remap(udb_base* udb);
void task_process_sync(udb_base* udb);
void task_clear(udb_base* udb);
void task_new_soainfo(udb_base* udb, udb_ptr* last, struct zone* z, int gone);
void task_new_expire(udb_base* udb, udb_ptr* last,
	const struct dname* z, int expired);
void* task_new_stat_info(udb_base* udb, udb_ptr* last, struct nsdst* stat,
	size_t child_count);
void task_new_check_zonefiles(udb_base* udb, udb_ptr* last,
	const dname_type* zone);
void task_new_write_zonefiles(udb_base* udb, udb_ptr* last,
	const dname_type* zone);
void task_new_set_verbosity(udb_base* udb, udb_ptr* last, int v);
void task_new_add_zone(udb_base* udb, udb_ptr* last, const char* zone,
	const char* pattern, unsigned zonestatid);
void task_new_del_zone(udb_base* udb, udb_ptr* last, const dname_type* dname);
void task_new_add_key(udb_base* udb, udb_ptr* last, struct key_options* key);
void task_new_del_key(udb_base* udb, udb_ptr* last, const char* name);
void task_new_add_pattern(udb_base* udb, udb_ptr* last,
	struct pattern_options* p);
void task_new_del_pattern(udb_base* udb, udb_ptr* last, const char* name);
void task_new_opt_change(udb_base* udb, udb_ptr* last, struct nsd_options* opt);
void task_new_zonestat_inc(udb_base* udb, udb_ptr* last, unsigned sz);
int task_new_apply_xfr(udb_base* udb, udb_ptr* last, const dname_type* zone,
	uint32_t old_serial, uint32_t new_serial, uint64_t filenumber);
void task_process_in_reload(struct nsd* nsd, udb_base* udb, udb_ptr *last_task,
	udb_ptr* task);
void task_process_expire(namedb_type* db, struct task_list_d* task);

#endif /* DIFFFILE_H */
@


1.1
log
@Initial revision
@
text
@a11 1
#include <config.h>
d15 3
d19 2
a20 12
#define DIFF_PART_IXFR ('I'<<24 | 'X'<<16 | 'F'<<8 | 'R')
#define DIFF_PART_SURE ('S'<<24 | 'U'<<16 | 'R'<<8 | 'E')

/*
 * Used to pass commit logs
 */
struct diff_log {
	char* zone_name;
	char* error;
	char* comment;
	struct diff_log* next;
};
d23 4
a26 3
   The diff file is created if necessary. */
void diff_write_packet(const char* zone, uint32_t new_serial, uint16_t id,
	uint32_t seq_nr, uint8_t* data, size_t len, nsd_options_t* opt);
d29 2
a30 3
 * Write a commit packet to the diff file, type=SURE.
 * The zone data (preceding ixfr packets) are committed.
 * See NSD-DIFFFILE for meaning of the arguments.
d33 2
a34 20
	uint32_t new_serial, uint16_t id, uint32_t num_parts,
	uint8_t commit, const char* log_msg,
	nsd_options_t* opt);

/* check if the crc in the nsd.db is the same in memory as on disk.
   returns 1 if different. 0 if the same. returns -1 on error. */
int db_crc_different(namedb_type* db);

/* read the diff file and apply to the database in memory.
   It will attempt to skip bad data.
   If you pass a non-null value log, log comments are alloced in namedb.region
   then, *log must be 0 on start of call (entries are prepended).
   returns 0 on an unrecoverable error. */
int diff_read_file(namedb_type* db, nsd_options_t* opt, struct diff_log** log,
	size_t child_count);

/* check the diff file for garbage at the end (bad type, partial write)
 * and snip it off.
 */
void diff_snip_garbage(namedb_type* db, nsd_options_t* opt);
a39 1
int diff_read_16(FILE *in, uint16_t* result);
d42 92
@


1.1.1.1
log
@NSD v3.2.4
@
text
@@


1.1.1.2
log
@NSD v3.2.8
@
text
@d4 1
a4 1
 * Copyright (c) 2001-2011, NLnet Labs. All rights reserved.
@


1.1.1.3
log
@NSD v3.2.11, ok phessler@@
@
text
@d12 1
a12 1
#include "config.h"
@


1.1.1.4
log
@import NSD 4.0.0, tests from Dorian BÃ¼ttner, Patrik Lundin, requested by brad@@
@
text
@d4 1
a4 1
 * Copyright (c) 2001-2006, NLnet Labs. All rights reserved.
d12 1
a15 3
#include "udb.h"
struct nsd;
struct nsdst;
d17 12
a28 2
#define DIFF_PART_XXFR ('X'<<24 | 'X'<<16 | 'F'<<8 | 'R')
#define DIFF_PART_XFRF ('X'<<24 | 'F'<<16 | 'R'<<8 | 'F')
d31 3
a33 4
   The diff file is created if necessary, with initial header(notcommitted). */
void diff_write_packet(const char* zone, const char* pat, uint32_t old_serial,
	uint32_t new_serial, uint32_t seq_nr, uint8_t* data, size_t len,
	struct nsd* nsd, uint64_t filenumber);
d36 3
a38 2
 * Overwrite header of diff file with committed vale and other data.
 * append log string.
d41 20
a60 2
	uint32_t new_serial, uint32_t num_parts, uint8_t commit,
	const char* log_msg, struct nsd* nsd, uint64_t filenumber);
d66 1
a68 88

/* delete the RRs for a zone from memory */
void delete_zone_rrs(namedb_type* db, zone_type* zone);
/* delete an RR */
int delete_RR(namedb_type* db, const dname_type* dname,
	uint16_t type, uint16_t klass,
	buffer_type* packet, size_t rdatalen, zone_type *zone,
	region_type* temp_region, struct udb_ptr* udbz);
/* add an RR */
int add_RR(namedb_type* db, const dname_type* dname,
	uint16_t type, uint16_t klass, uint32_t ttl,
	buffer_type* packet, size_t rdatalen, zone_type *zone,
	struct udb_ptr* udbz);

/* task udb structure */
struct task_list_d {
	/** next task in list */
	udb_rel_ptr next;
	/** task type */
	enum {
		/** expire or un-expire a zone */
		task_expire,
		/** apply an ixfr or axfr to a zone */
		task_apply_xfr,
		/** soa info for zone */
		task_soa_info,
		/** check mtime of zonefiles and read them, done on SIGHUP */
		task_check_zonefiles,
		/** write zonefiles (if changed) */
		task_write_zonefiles,
		/** set verbosity */
		task_set_verbosity,
		/** statistic info */
		task_stat_info,
		/** add a zone */
		task_add_zone,
		/** delete zone */
		task_del_zone,
		/** add TSIG key */
		task_add_key,
		/** delete TSIG key */
		task_del_key,
		/** add pattern */
		task_add_pattern,
		/** delete pattern */
		task_del_pattern,
		/** options change */
		task_opt_change
	} task_type;
	uint32_t size; /* size of this struct */

	/** soainfo: zonename dname, soaRR wireform */
	/** expire: zonename, boolyesno */
	/** apply_xfr: zonename, serials, yesno is filenamecounter */
	uint32_t oldserial, newserial;
	/** general variable.  for some used to see if zname is present. */
	uint64_t yesno;
	struct dname zname[0];
};
#define TASKLIST(ptr) ((struct task_list_d*)UDB_PTR(ptr))
/** create udb for tasks */
struct udb_base* task_file_create(const char* file);
void task_remap(udb_base* udb);
void task_process_sync(udb_base* udb);
void task_clear(udb_base* udb);
void task_new_soainfo(udb_base* udb, udb_ptr* last, struct zone* z);
void task_new_expire(udb_base* udb, udb_ptr* last,
	const struct dname* z, int expired);
void* task_new_stat_info(udb_base* udb, udb_ptr* last, struct nsdst* stat,
	size_t child_count);
void task_new_check_zonefiles(udb_base* udb, udb_ptr* last,
	const dname_type* zone);
void task_new_write_zonefiles(udb_base* udb, udb_ptr* last,
	const dname_type* zone);
void task_new_set_verbosity(udb_base* udb, udb_ptr* last, int v);
void task_new_add_zone(udb_base* udb, udb_ptr* last, const char* zone,
	const char* pattern);
void task_new_del_zone(udb_base* udb, udb_ptr* last, const dname_type* dname);
void task_new_add_key(udb_base* udb, udb_ptr* last, key_options_t* key);
void task_new_del_key(udb_base* udb, udb_ptr* last, const char* name);
void task_new_add_pattern(udb_base* udb, udb_ptr* last, pattern_options_t* p);
void task_new_del_pattern(udb_base* udb, udb_ptr* last, const char* name);
void task_new_opt_change(udb_base* udb, udb_ptr* last, nsd_options_t* opt);
int task_new_apply_xfr(udb_base* udb, udb_ptr* last, const dname_type* zone,
	uint32_t old_serial, uint32_t new_serial, uint64_t filenumber);
void task_process_in_reload(struct nsd* nsd, udb_base* udb, udb_ptr *last_task,
	udb_ptr* task);
void task_process_expire(namedb_type* db, struct task_list_d* task);
@


1.1.1.5
log
@update to NSD 4.0.1, ok sthen@@
@
text
@d49 1
a49 1
	region_type* temp_region, struct udb_ptr* udbz, int* softfail);
d54 1
a54 1
	struct udb_ptr* udbz, int* softfail);
d107 1
a107 1
void task_new_soainfo(udb_base* udb, udb_ptr* last, struct zone* z, int gone);
@


1.1.1.6
log
@update to NSD 4.1.1, ok sthen@@
@
text
@d89 1
a89 3
		task_opt_change,
		/** zonestat increment */
		task_zonestat_inc
d118 1
a118 1
	const char* pattern, unsigned zonestatid);
a124 1
void task_new_zonestat_inc(udb_base* udb, udb_ptr* last, unsigned sz);
@


