head	1.11;
access;
symbols
	OPENBSD_6_2:1.11.0.2
	OPENBSD_6_2_BASE:1.11
	OPENBSD_6_1:1.11.0.4
	OPENBSD_6_1_BASE:1.11
	OPENBSD_6_0:1.7.0.8
	OPENBSD_6_0_BASE:1.7
	OPENBSD_5_9:1.7.0.4
	OPENBSD_5_9_BASE:1.7
	NSD_4_1_6:1.1.1.9
	OPENBSD_5_8:1.7.0.6
	OPENBSD_5_8_BASE:1.7
	NSD_4_1_3:1.1.1.9
	OPENBSD_5_7:1.7.0.2
	OPENBSD_5_7_BASE:1.7
	NSD_4_1_1:1.1.1.9
	NSD_4_1_0:1.1.1.8
	OPENBSD_5_6:1.4.0.6
	OPENBSD_5_6_BASE:1.4
	NSD_4_0_3:1.1.1.7
	NSD_4_0_2:1.1.1.7
	OPENBSD_5_5:1.4.0.4
	OPENBSD_5_5_BASE:1.4
	NSD_4_0_1:1.1.1.7
	NSD_4_0_0:1.1.1.6
	NSD_3_2_16:1.1.1.5
	OPENBSD_5_4:1.1.1.4.0.6
	OPENBSD_5_4_BASE:1.1.1.4
	OPENBSD_5_3:1.1.1.4.0.4
	OPENBSD_5_3_BASE:1.1.1.4
	NSD_3_2_15:1.1.1.4
	NSD_3_2_14:1.1.1.4
	NSD_3_2_13:1.1.1.4
	OPENBSD_5_2:1.1.1.4.0.2
	OPENBSD_5_2_BASE:1.1.1.4
	NSD_3_2_11:1.1.1.4
	NSD_3_2_10:1.1.1.3
	OPENBSD_5_1_BASE:1.1.1.3
	OPENBSD_5_1:1.1.1.3.0.2
	NSD_3_2_9:1.1.1.3
	OPENBSD_5_0:1.1.1.2.0.2
	OPENBSD_5_0_BASE:1.1.1.2
	NSD_3_2_8:1.1.1.2
	OPENBSD_4_9:1.1.1.1.0.6
	OPENBSD_4_9_BASE:1.1.1.1
	NSD_3_2_6:1.1.1.1
	OPENBSD_4_8:1.1.1.1.0.4
	OPENBSD_4_8_BASE:1.1.1.1
	NSD_3_2_5:1.1.1.1
	OPENBSD_4_7:1.1.1.1.0.2
	OPENBSD_4_7_BASE:1.1.1.1
	NSD_3_2_4:1.1.1.1
	NLNETLABS:1.1.1;
locks; strict;
comment	@ * @;


1.11
date	2017.02.17.20.04.45;	author florian;	state Exp;
branches;
next	1.10;
commitid	WmSuN5M3Jbe54113;

1.10
date	2017.01.17.06.21.41;	author florian;	state Exp;
branches;
next	1.9;
commitid	6d948iJ1oT7IPB23;

1.9
date	2016.10.24.09.44.43;	author florian;	state Exp;
branches;
next	1.8;
commitid	g3wASIhTcujU0LFi;

1.8
date	2016.08.31.07.31.20;	author florian;	state Exp;
branches;
next	1.7;
commitid	1gMwFuybgH2l617m;

1.7
date	2015.02.03.10.40.02;	author brad;	state Exp;
branches;
next	1.6;
commitid	MI9j0d0LR8Dk9lnd;

1.6
date	2014.12.18.23.26.13;	author brad;	state Exp;
branches;
next	1.5;
commitid	rBaz3dZHAQwIDT3j;

1.5
date	2014.09.16.17.01.38;	author brad;	state Exp;
branches;
next	1.4;
commitid	5uD1zN2z8VskC3BN;

1.4
date	2014.02.04.03.07.25;	author brad;	state Exp;
branches;
next	1.3;

1.3
date	2013.11.26.12.53.58;	author sthen;	state Exp;
branches;
next	1.2;

1.2
date	2013.09.04.12.24.35;	author sthen;	state Exp;
branches;
next	1.1;

1.1
date	2010.01.15.19.24.55;	author jakob;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2010.01.15.19.24.55;	author jakob;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2011.05.21.18.17.11;	author jakob;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2012.01.29.11.15.31;	author jakob;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2012.07.09.21.55.07;	author sthen;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2013.09.03.09.21.37;	author sthen;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2013.11.26.12.50.13;	author sthen;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2014.02.04.01.54.02;	author brad;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2014.09.16.16.54.00;	author brad;	state Exp;
branches;
next	1.1.1.9;
commitid	BWSdZeElrpYSRdME;

1.1.1.9
date	2015.02.03.10.24.28;	author brad;	state Exp;
branches;
next	;
commitid	yn8l9RVkmdMVYIfl;


desc
@@


1.11
log
@Update to 4.1.15.
This contains a local patch to query.c (missed _t conversion) that has
been submitted upstream.
OK sthen
@
text
@/*
 * xfrd-disk.c - XFR (transfer) Daemon TCP system source file. Read/Write state to disk.
 *
 * Copyright (c) 2001-2006, NLnet Labs. All rights reserved.
 *
 * See LICENSE for the license.
 *
 */

#include "config.h"
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <errno.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <unistd.h>
#include "xfrd-disk.h"
#include "xfrd.h"
#include "buffer.h"
#include "nsd.h"
#include "options.h"

/* quick tokenizer, reads words separated by whitespace.
   No quoted strings. Comments are skipped (#... eol). */
static char*
xfrd_read_token(FILE* in)
{
	static char buf[4000];
	buf[sizeof(buf)-1]=0;
	while(1) {
		if(fscanf(in, " %3990s", buf) != 1)
			return 0;

		if(buf[0] != '#')
			return buf;

		if(!fgets(buf, sizeof(buf), in))
			return 0;
	}
}

static int
xfrd_read_i16(FILE *in, uint16_t* v)
{
	char* p = xfrd_read_token(in);
	if(!p)
		return 0;

	*v=atoi(p);
	return 1;
}

static int
xfrd_read_i32(FILE *in, uint32_t* v)
{
	char* p = xfrd_read_token(in);
	if(!p)
		return 0;

	*v=atoi(p);
	return 1;
}

static int
xfrd_read_time_t(FILE *in, time_t* v)
{
	char* p = xfrd_read_token(in);
	if(!p)
		return 0;

	*v=atol(p);
	return 1;
}

static int
xfrd_read_check_str(FILE* in, const char* str)
{
	char *p = xfrd_read_token(in);
	if(!p)
		return 0;

	if(strcmp(p, str) != 0)
		return 0;

	return 1;
}

static int
xfrd_read_state_soa(FILE* in, const char* id_acquired,
	const char* id, xfrd_soa_type* soa, time_t* soatime)
{
	char *p;

	if(!xfrd_read_check_str(in, id_acquired) ||
	   !xfrd_read_time_t(in, soatime)) {
		return 0;
	}

	if(*soatime == 0)
		return 1;

	if(!xfrd_read_check_str(in, id) ||
	   !xfrd_read_i16(in, &soa->type) ||
	   !xfrd_read_i16(in, &soa->klass) ||
	   !xfrd_read_i32(in, &soa->ttl) ||
	   !xfrd_read_i16(in, &soa->rdata_count))
	{
		return 0;
	}

	soa->type = htons(soa->type);
	soa->klass = htons(soa->klass);
	soa->ttl = htonl(soa->ttl);
	soa->rdata_count = htons(soa->rdata_count);

	if(!(p=xfrd_read_token(in)) ||
	   !(soa->prim_ns[0] = dname_parse_wire(soa->prim_ns+1, p)))
		return 0;

	if(!(p=xfrd_read_token(in)) ||
	   !(soa->email[0] = dname_parse_wire(soa->email+1, p)))
		return 0;

	if(!xfrd_read_i32(in, &soa->serial) ||
	   !xfrd_read_i32(in, &soa->refresh) ||
	   !xfrd_read_i32(in, &soa->retry) ||
	   !xfrd_read_i32(in, &soa->expire) ||
	   !xfrd_read_i32(in, &soa->minimum))
	{
		return 0;
	}

	soa->serial = htonl(soa->serial);
	soa->refresh = htonl(soa->refresh);
	soa->retry = htonl(soa->retry);
	soa->expire = htonl(soa->expire);
	soa->minimum = htonl(soa->minimum);
	return 1;
}

void
xfrd_read_state(struct xfrd_state* xfrd)
{
	const char* statefile = xfrd->nsd->options->xfrdfile;
	FILE *in;
	uint32_t filetime = 0;
	uint32_t numzones, i;
	region_type *tempregion;
	time_t soa_refresh;

	tempregion = region_create(xalloc, free);
	if(!tempregion)
		return;

	in = fopen(statefile, "r");
	if(!in) {
		if(errno != ENOENT) {
			log_msg(LOG_ERR, "xfrd: Could not open file %s for reading: %s",
				statefile, strerror(errno));
		} else {
			DEBUG(DEBUG_XFRD,1, (LOG_INFO, "xfrd: no file %s. refreshing all zones.",
				statefile));
		}
		region_destroy(tempregion);
		return;
	}
	if(!xfrd_read_check_str(in, XFRD_FILE_MAGIC)) {
		/* older file version; reset everything */
		DEBUG(DEBUG_XFRD,1, (LOG_INFO, "xfrd: file %s is old version. refreshing all zones.",
			statefile));
		fclose(in);
		region_destroy(tempregion);
		return;
	}
	if(!xfrd_read_check_str(in, "filetime:") ||
	   !xfrd_read_i32(in, &filetime) ||
	   (time_t)filetime > xfrd_time()+15 ||
	   !xfrd_read_check_str(in, "numzones:") ||
	   !xfrd_read_i32(in, &numzones))
	{
		log_msg(LOG_ERR, "xfrd: corrupt state file %s dated %d (now=%lld)",
			statefile, (int)filetime, (long long)xfrd_time());
		fclose(in);
		region_destroy(tempregion);
		return;
	}

	for(i=0; i<numzones; i++) {
		char *p;
		xfrd_zone_type* zone;
		const dname_type* dname;
		uint32_t state, masnum, nextmas, round_num, timeout, backoff;
		xfrd_soa_type soa_nsd_read, soa_disk_read, soa_notified_read;
		time_t soa_nsd_acquired_read,
			soa_disk_acquired_read, soa_notified_acquired_read;
		xfrd_soa_type incoming_soa;
		time_t incoming_acquired;

		if(nsd.signal_hint_shutdown) {
			fclose(in);
			region_destroy(tempregion);
			return;
		}

		memset(&soa_nsd_read, 0, sizeof(soa_nsd_read));
		memset(&soa_disk_read, 0, sizeof(soa_disk_read));
		memset(&soa_notified_read, 0, sizeof(soa_notified_read));

		if(!xfrd_read_check_str(in, "zone:") ||
		   !xfrd_read_check_str(in, "name:")  ||
		   !(p=xfrd_read_token(in)) ||
		   !(dname = dname_parse(tempregion, p)) ||
		   !xfrd_read_check_str(in, "state:") ||
		   !xfrd_read_i32(in, &state) || (state>2) ||
		   !xfrd_read_check_str(in, "master:") ||
		   !xfrd_read_i32(in, &masnum) ||
		   !xfrd_read_check_str(in, "next_master:") ||
		   !xfrd_read_i32(in, &nextmas) ||
		   !xfrd_read_check_str(in, "round_num:") ||
		   !xfrd_read_i32(in, &round_num) ||
		   !xfrd_read_check_str(in, "next_timeout:") ||
		   !xfrd_read_i32(in, &timeout) ||
		   !xfrd_read_check_str(in, "backoff:") ||
		   !xfrd_read_i32(in, &backoff) ||
		   !xfrd_read_state_soa(in, "soa_nsd_acquired:", "soa_nsd:",
			&soa_nsd_read, &soa_nsd_acquired_read) ||
		   !xfrd_read_state_soa(in, "soa_disk_acquired:", "soa_disk:",
			&soa_disk_read, &soa_disk_acquired_read) ||
		   !xfrd_read_state_soa(in, "soa_notify_acquired:", "soa_notify:",
			&soa_notified_read, &soa_notified_acquired_read))
		{
			log_msg(LOG_ERR, "xfrd: corrupt state file %s dated %d (now=%lld)",
				statefile, (int)filetime, (long long)xfrd_time());
			fclose(in);
			region_destroy(tempregion);
			return;
		}

		zone = (xfrd_zone_type*)rbtree_search(xfrd->zones, dname);
		if(!zone) {
			DEBUG(DEBUG_XFRD,1, (LOG_INFO, "xfrd: state file has info for not configured zone %s", p));
			continue;
		}

		if(soa_nsd_acquired_read>xfrd_time()+15 ||
			soa_disk_acquired_read>xfrd_time()+15 ||
			soa_notified_acquired_read>xfrd_time()+15)
		{
			log_msg(LOG_ERR, "xfrd: statefile %s contains"
				" times in the future for zone %s. Ignoring.",
				statefile, zone->apex_str);
			continue;
		}
		zone->state = state;
		zone->master_num = masnum;
		zone->next_master = nextmas;
		zone->round_num = round_num;
		zone->timeout.tv_sec = timeout;
		zone->timeout.tv_usec = 0;
		zone->fresh_xfr_timeout = backoff*XFRD_TRANSFER_TIMEOUT_START;

		/* read the zone OK, now set the master properly */
		zone->master = acl_find_num(zone->zone_options->pattern->
			request_xfr, zone->master_num);
		if(!zone->master) {
			DEBUG(DEBUG_XFRD,1, (LOG_INFO, "xfrd: masters changed for zone %s",
				zone->apex_str));
			zone->master = zone->zone_options->pattern->request_xfr;
			zone->master_num = 0;
			zone->round_num = 0;
		}

		/*
		 * There is no timeout,
		 * or there is a notification,
		 * or there is a soa && current time is past refresh point
		 */
		soa_refresh = ntohl(soa_disk_read.refresh);
		if (soa_refresh > (time_t)zone->zone_options->pattern->max_refresh_time)
			soa_refresh = zone->zone_options->pattern->max_refresh_time;
		else if (soa_refresh < (time_t)zone->zone_options->pattern->min_refresh_time)
			soa_refresh = zone->zone_options->pattern->min_refresh_time;
		if(timeout == 0 || soa_notified_acquired_read != 0 ||
			(soa_disk_acquired_read != 0 &&
			(uint32_t)xfrd_time() - soa_disk_acquired_read
				> (uint32_t)soa_refresh))
		{
			zone->state = xfrd_zone_refreshing;
			xfrd_set_refresh_now(zone);
		}

		/* There is a soa && current time is past expiry point */
		if(soa_disk_acquired_read!=0 &&
			(uint32_t)xfrd_time() - soa_disk_acquired_read
				> ntohl(soa_disk_read.expire))
		{
			zone->state = xfrd_zone_expired;
			xfrd_set_refresh_now(zone);
		} 

		/* there is a zone read and it matches what we had before */
		if(zone->soa_nsd_acquired && zone->state != xfrd_zone_expired
			&& zone->soa_nsd.serial == soa_nsd_read.serial) {
			xfrd_deactivate_zone(zone);
			zone->state = state;
			xfrd_set_timer(zone, timeout);
		}	
		if((zone->soa_nsd_acquired == 0 && soa_nsd_acquired_read == 0 &&
			soa_disk_acquired_read == 0) ||
			(zone->state != xfrd_zone_ok && timeout != 0)) {
			/* but don't check now, because that would mean a
			 * storm of attempts on some master servers */
			xfrd_deactivate_zone(zone);
			zone->state = state;
			xfrd_set_timer(zone, timeout);
		}

		/* handle as an incoming SOA. */
		incoming_soa = zone->soa_nsd;
		incoming_acquired = zone->soa_nsd_acquired;
		zone->soa_nsd = soa_nsd_read;
		zone->soa_disk = soa_disk_read;
		zone->soa_notified = soa_notified_read;
		zone->soa_nsd_acquired = soa_nsd_acquired_read;
		/* we had better use what we got from starting NSD, not
		 * what we store in this file, because the actual zone
		 * contents trumps the contents of this cache */
		/* zone->soa_disk_acquired = soa_disk_acquired_read; */
		zone->soa_notified_acquired = soa_notified_acquired_read;
		if (zone->state == xfrd_zone_expired)
		{
			xfrd_send_expire_notification(zone);
		}
		if(incoming_acquired != 0)
			xfrd_handle_incoming_soa(zone, &incoming_soa, incoming_acquired);
	}

	if(!xfrd_read_check_str(in, XFRD_FILE_MAGIC)) {
		log_msg(LOG_ERR, "xfrd: corrupt state file %s dated %d (now=%lld)",
			statefile, (int)filetime, (long long)xfrd_time());
		region_destroy(tempregion);
		fclose(in);
		return;
	}

	DEBUG(DEBUG_XFRD,1, (LOG_INFO, "xfrd: read %d zones from state file", (int)numzones));
	fclose(in);
	region_destroy(tempregion);
}

/* prints neato days hours and minutes. */
static void
neato_timeout(FILE* out, const char* str, time_t secs)
{
	fprintf(out, "%s", str);
	if(secs <= 0) {
		fprintf(out, " %llds", (long long)secs);
		return;
	}
	if(secs >= 3600*24) {
		fprintf(out, " %lldd", (long long)(secs/(3600*24)));
		secs = secs % (3600*24);
	}
	if(secs >= 3600) {
		fprintf(out, " %lldh", (long long)(secs/3600));
		secs = secs%3600;
	}
	if(secs >= 60) {
		fprintf(out, " %lldm", (long long)(secs/60));
		secs = secs%60;
	}
	if(secs > 0) {
		fprintf(out, " %llds", (long long)secs);
	}
}

static void xfrd_write_dname(FILE* out, uint8_t* dname)
{
	uint8_t* d= dname+1;
	uint8_t len = *d++;
	uint8_t i;

	if(dname[0]<=1) {
		fprintf(out, ".");
		return;
	}

	while(len)
	{
		assert(d - (dname+1) <= dname[0]);
		for(i=0; i<len; i++)
		{
			uint8_t ch = *d++;
			if (isalnum((unsigned char)ch) || ch == '-' || ch == '_') {
				fprintf(out, "%c", ch);
			} else if (ch == '.' || ch == '\\') {
				fprintf(out, "\\%c", ch);
			} else {
				fprintf(out, "\\%03u", (unsigned int)ch);
			}
		}
		fprintf(out, ".");
		len = *d++;
	}
}

static void
xfrd_write_state_soa(FILE* out, const char* id,
	xfrd_soa_type* soa, time_t soatime, const dname_type* ATTR_UNUSED(apex))
{
	fprintf(out, "\t%s_acquired: %d", id, (int)soatime);
	if(!soatime) {
		fprintf(out, "\n");
		return;
	}
	neato_timeout(out, "\t# was", xfrd_time()-soatime);
	fprintf(out, " ago\n");

	fprintf(out, "\t%s: %u %u %u %u", id,
		(unsigned)ntohs(soa->type), (unsigned)ntohs(soa->klass),
		(unsigned)ntohl(soa->ttl), (unsigned)ntohs(soa->rdata_count));
	fprintf(out, " ");
	xfrd_write_dname(out, soa->prim_ns);
	fprintf(out, " ");
	xfrd_write_dname(out, soa->email);
	fprintf(out, " %u", (unsigned)ntohl(soa->serial));
	fprintf(out, " %u", (unsigned)ntohl(soa->refresh));
	fprintf(out, " %u", (unsigned)ntohl(soa->retry));
	fprintf(out, " %u", (unsigned)ntohl(soa->expire));
	fprintf(out, " %u\n", (unsigned)ntohl(soa->minimum));
	fprintf(out, "\t#");
	neato_timeout(out, " refresh =", ntohl(soa->refresh));
	neato_timeout(out, " retry =", ntohl(soa->retry));
	neato_timeout(out, " expire =", ntohl(soa->expire));
	neato_timeout(out, " minimum =", ntohl(soa->minimum));
	fprintf(out, "\n");
}

void
xfrd_write_state(struct xfrd_state* xfrd)
{
	rbnode_type* p;
	const char* statefile = xfrd->nsd->options->xfrdfile;
	FILE *out;
	time_t now = xfrd_time();

	DEBUG(DEBUG_XFRD,1, (LOG_INFO, "xfrd: write file %s", statefile));
	out = fopen(statefile, "w");
	if(!out) {
		log_msg(LOG_ERR, "xfrd: Could not open file %s for writing: %s",
				statefile, strerror(errno));
		return;
	}

	fprintf(out, "%s\n", XFRD_FILE_MAGIC);
	fprintf(out, "# This file is written on exit by nsd xfr daemon.\n");
	fprintf(out, "# This file contains slave zone information:\n");
	fprintf(out, "# 	* timeouts (when was zone data acquired)\n");
	fprintf(out, "# 	* state (OK, refreshing, expired)\n");
	fprintf(out, "# 	* which master transfer to attempt next\n");
	fprintf(out, "# The file is read on start (but not on reload) by nsd xfr daemon.\n");
	fprintf(out, "# You can edit; but do not change statement order\n");
	fprintf(out, "# and no fancy stuff (like quoted \"strings\").\n");
	fprintf(out, "#\n");
	fprintf(out, "# If you remove a zone entry, it will be refreshed.\n");
	fprintf(out, "# This can be useful for an expired zone; it revives\n");
	fprintf(out, "# the zone temporarily, from refresh-expiry time.\n");
	fprintf(out, "# If you delete the file all slave zones are updated.\n");
	fprintf(out, "#\n");
	fprintf(out, "# Note: if you edit this file while nsd is running,\n");
	fprintf(out, "#       it will be overwritten on exit by nsd.\n");
	fprintf(out, "\n");
	fprintf(out, "filetime: %lld\t# %s\n", (long long)now, ctime(&now));
	fprintf(out, "# The number of zone entries in this file\n");
	fprintf(out, "numzones: %d\n", (int)xfrd->zones->count);
	fprintf(out, "\n");
	for(p = rbtree_first(xfrd->zones); p && p!=RBTREE_NULL; p=rbtree_next(p))
	{
		xfrd_zone_type* zone = (xfrd_zone_type*)p;
		fprintf(out, "zone: \tname: %s\n", zone->apex_str);
		fprintf(out, "\tstate: %d", (int)zone->state);
		fprintf(out, " # %s", zone->state==xfrd_zone_ok?"OK":(
			zone->state==xfrd_zone_refreshing?"refreshing":"expired"));
		fprintf(out, "\n");
		fprintf(out, "\tmaster: %d\n", zone->master_num);
		fprintf(out, "\tnext_master: %d\n", zone->next_master);
		fprintf(out, "\tround_num: %d\n", zone->round_num);
		fprintf(out, "\tnext_timeout: %d",
			(zone->zone_handler_flags&EV_TIMEOUT)?(int)zone->timeout.tv_sec:0);
		if((zone->zone_handler_flags&EV_TIMEOUT)) {
			neato_timeout(out, "\t# =", zone->timeout.tv_sec);
		}
		fprintf(out, "\n");
		fprintf(out, "\tbackoff: %d\n", zone->fresh_xfr_timeout/XFRD_TRANSFER_TIMEOUT_START);
		xfrd_write_state_soa(out, "soa_nsd", &zone->soa_nsd,
			zone->soa_nsd_acquired, zone->apex);
		xfrd_write_state_soa(out, "soa_disk", &zone->soa_disk,
			zone->soa_disk_acquired, zone->apex);
		xfrd_write_state_soa(out, "soa_notify", &zone->soa_notified,
			zone->soa_notified_acquired, zone->apex);
		fprintf(out, "\n");
	}

	fprintf(out, "%s\n", XFRD_FILE_MAGIC);
	DEBUG(DEBUG_XFRD,1, (LOG_INFO, "xfrd: written %d zones to state file",
		(int)xfrd->zones->count));
	fclose(out);
}

/* return tempdirname */
static void
tempdirname(char* buf, size_t sz, struct nsd* nsd)
{
	snprintf(buf, sz, "%snsd-xfr-%d",
		nsd->options->xfrdir, (int)nsd->pid);
}

void
xfrd_make_tempdir(struct nsd* nsd)
{
	char tnm[1024];
	tempdirname(tnm, sizeof(tnm), nsd);
	/* create parent directories if needed (0750 permissions) */
	if(!create_dirs(tnm)) {
		log_msg(LOG_ERR, "parentdirs of %s failed", tnm);
	}
	/* restrictive permissions here, because this may be in /tmp */
	if(mkdir(tnm, 0700)==-1) {
		if(errno != EEXIST) {
			log_msg(LOG_ERR, "mkdir %s failed: %s",
				tnm, strerror(errno));
		}
	}
}

void
xfrd_del_tempdir(struct nsd* nsd)
{
	char tnm[1024];
	tempdirname(tnm, sizeof(tnm), nsd);
	/* ignore parent directories, they are likely /var/tmp, /tmp or
	 * /var/cache/nsd and do not have to be deleted */
	if(rmdir(tnm)==-1 && errno != ENOENT) {
		log_msg(LOG_WARNING, "rmdir %s failed: %s", tnm,
			strerror(errno));
	}
}

/* return name of xfrfile in tempdir */
static void
tempxfrname(char* buf, size_t sz, struct nsd* nsd, uint64_t number)
{
	char tnm[1024];
	tempdirname(tnm, sizeof(tnm), nsd);
	snprintf(buf, sz, "%s/xfr.%lld", tnm, (long long)number);
}

FILE*
xfrd_open_xfrfile(struct nsd* nsd, uint64_t number, char* mode)
{
	char fname[1024];
	FILE* xfr;
	tempxfrname(fname, sizeof(fname), nsd, number);
	xfr = fopen(fname, mode);
	if(!xfr && errno == ENOENT) {
		/* directory may not exist */
		xfrd_make_tempdir(nsd);
		xfr = fopen(fname, mode);
	}
	if(!xfr) {
		log_msg(LOG_ERR, "open %s for %s failed: %s", fname, mode,
			strerror(errno));
		return NULL;
	}
	return xfr;
}

void
xfrd_unlink_xfrfile(struct nsd* nsd, uint64_t number)
{
	char fname[1024];
	tempxfrname(fname, sizeof(fname), nsd, number);
	if(unlink(fname) == -1) {
		log_msg(LOG_WARNING, "could not unlink %s: %s", fname,
			strerror(errno));
	}
}

uint64_t
xfrd_get_xfrfile_size(struct nsd* nsd, uint64_t number )
{
	char fname[1024];
	struct stat tempxfr_stat;
	tempxfrname(fname, sizeof(fname), nsd, number);
	if( stat( fname, &tempxfr_stat ) < 0 ) {
	    log_msg(LOG_WARNING, "could not get file size %s: %s", fname,
		    strerror(errno));
	    return 0;
	}
	return (uint64_t)tempxfr_stat.st_size;
}
@


1.10
log
@Update to nsd 4.1.14
OK sthen@@
@
text
@d91 1
a91 1
	const char* id, xfrd_soa_t* soa, time_t* soatime)
d191 1
a191 1
		xfrd_zone_t* zone;
d194 1
a194 1
		xfrd_soa_t soa_nsd_read, soa_disk_read, soa_notified_read;
d197 1
a197 1
		xfrd_soa_t incoming_soa;
d240 1
a240 1
		zone = (xfrd_zone_t*)rbtree_search(xfrd->zones, dname);
d410 1
a410 1
	xfrd_soa_t* soa, time_t soatime, const dname_type* ATTR_UNUSED(apex))
d443 1
a443 1
	rbnode_t* p;
d480 1
a480 1
		xfrd_zone_t* zone = (xfrd_zone_t*)p;
@


1.9
log
@Update to 4.1.13
Testing millert, brad and myself.
OK millert@@
@
text
@d168 9
a176 2
	if(!xfrd_read_check_str(in, XFRD_FILE_MAGIC) ||
	   !xfrd_read_check_str(in, "filetime:") ||
d193 1
a193 1
		uint32_t state, masnum, nextmas, round_num, timeout;
d224 2
d261 1
d309 8
a316 4
		if(zone->soa_nsd_acquired == 0 && soa_nsd_acquired_read == 0 &&
			soa_disk_acquired_read == 0) {
			/* continue expon backoff where we were + check now */
			zone->fresh_xfr_timeout = timeout;
d335 2
a336 1
		xfrd_handle_incoming_soa(zone, &incoming_soa, incoming_acquired);
d495 1
@


1.8
log
@update to 4.1.11
"Working fine here." millert@@
OK dlg, sthen
@
text
@d270 1
a270 1
		if (soa_refresh > zone->zone_options->pattern->max_refresh_time)
d272 1
a272 1
		else if (soa_refresh < zone->zone_options->pattern->min_refresh_time)
d277 1
a277 1
				> soa_refresh))
@


1.7
log
@merge conflicts
@
text
@d150 1
d269 5
d277 1
a277 1
				> ntohl(soa_disk_read.refresh)))
d572 14
@


1.6
log
@Merge in some commits from upstream..

- Fix that failure to add tcp to tcp base does not leak the socket.
- Fixes for wildcard addition and deletion, speedup for some cases.
- Fix that queries for noname CH TXT are REFUSED instead of nodata.
- Fix #616: retry xfer for zones with no content after command.
- Fix that expired zones stay expired after a server restart.
- RFC 7344: CDS and CDNSKEY (read in).

ok sthen@@
@
text
@d374 1
a374 1
			if (isalnum(ch) || ch == '-' || ch == '_') {
@


1.5
log
@merge conflicts
@
text
@d311 4
@


1.4
log
@merge conflicts
@
text
@d192 6
d284 13
@


1.3
log
@merge conflicts
@
text
@d448 1
a448 1
			neato_timeout(out, "\t# =", zone->timeout.tv_sec - xfrd_time());
@


1.2
log
@time_t and random fixes from NSD upstream, ok deraadt@@
@
text
@d4 1
a4 1
 * Copyright (c) 2001-2011, NLnet Labs. All rights reserved.
d15 3
d244 1
a244 1
		zone->timeout.tv_nsec = 0;
d247 2
a248 2
		zone->master = acl_find_num(
			zone->zone_options->request_xfr, zone->master_num);
d252 1
a252 1
			zone->master = zone->zone_options->request_xfr;
d446 2
a447 2
			zone->zone_handler.timeout?(int)zone->timeout.tv_sec:0);
		if(zone->zone_handler.timeout) {
d464 79
@


1.1
log
@Initial revision
@
text
@d4 1
a4 1
 * Copyright (c) 2001-2006, NLnet Labs. All rights reserved.
d10 1
a10 1
#include <config.h>
d171 2
a172 2
		log_msg(LOG_ERR, "xfrd: corrupt state file %s dated %d (now=%d)",
			statefile, (int)filetime, (int)xfrd_time());
d214 2
a215 2
			log_msg(LOG_ERR, "xfrd: corrupt state file %s dated %d (now=%d)",
				statefile, (int)filetime, (int)xfrd_time());
d284 4
a287 1
		zone->soa_disk_acquired = soa_disk_acquired_read;
d293 2
a294 2
		log_msg(LOG_ERR, "xfrd: corrupt state file %s dated %d (now=%d)",
			statefile, (int)filetime, (int)xfrd_time());
d300 1
a300 1
	DEBUG(DEBUG_XFRD,1, (LOG_INFO, "xfrd: read %d zones from state file", numzones));
d307 1
a307 1
neato_timeout(FILE* out, const char* str, uint32_t secs)
d311 1
a311 1
		fprintf(out, " %ds", secs);
d315 1
a315 1
		fprintf(out, " %dd", secs/(3600*24));
d319 1
a319 1
		fprintf(out, " %dh", secs/3600);
d323 1
a323 1
		fprintf(out, " %dm", secs/60);
d327 1
a327 1
		fprintf(out, " %ds", secs);
d374 2
a375 2
		ntohs(soa->type), ntohs(soa->klass),
		ntohl(soa->ttl), ntohs(soa->rdata_count));
d380 5
a384 5
	fprintf(out, " %u", ntohl(soa->serial));
	fprintf(out, " %u", ntohl(soa->refresh));
	fprintf(out, " %u", ntohl(soa->retry));
	fprintf(out, " %u", ntohl(soa->expire));
	fprintf(out, " %u\n", ntohl(soa->minimum));
d427 1
a427 1
	fprintf(out, "filetime: %d\t# %s\n", (int)now, ctime(&now));
@


1.1.1.1
log
@NSD v3.2.4
@
text
@@


1.1.1.2
log
@NSD v3.2.8
@
text
@d4 1
a4 1
 * Copyright (c) 2001-2011, NLnet Labs. All rights reserved.
@


1.1.1.3
log
@NSD v3.2.9
@
text
@d284 1
a284 4
		/* we had better use what we got from starting NSD, not
		 * what we store in this file, because the actual zone
		 * contents trumps the contents of this cache */
		/* zone->soa_disk_acquired = soa_disk_acquired_read; */
@


1.1.1.4
log
@NSD v3.2.11, ok phessler@@
@
text
@d10 1
a10 1
#include "config.h"
@


1.1.1.5
log
@update to NSD 3.2.16, ok deraadt@@ brad@@
@
text
@d300 1
a300 1
	DEBUG(DEBUG_XFRD,1, (LOG_INFO, "xfrd: read %d zones from state file", (int)numzones));
d311 1
a311 1
		fprintf(out, " %ds", (int)secs);
d315 1
a315 1
		fprintf(out, " %dd", (int)secs/(3600*24));
d319 1
a319 1
		fprintf(out, " %dh", (int)secs/3600);
d323 1
a323 1
		fprintf(out, " %dm", (int)secs/60);
d327 1
a327 1
		fprintf(out, " %ds", (int)secs);
d374 2
a375 2
		(unsigned)ntohs(soa->type), (unsigned)ntohs(soa->klass),
		(unsigned)ntohl(soa->ttl), (unsigned)ntohs(soa->rdata_count));
d380 5
a384 5
	fprintf(out, " %u", (unsigned)ntohl(soa->serial));
	fprintf(out, " %u", (unsigned)ntohl(soa->refresh));
	fprintf(out, " %u", (unsigned)ntohl(soa->retry));
	fprintf(out, " %u", (unsigned)ntohl(soa->expire));
	fprintf(out, " %u\n", (unsigned)ntohl(soa->minimum));
@


1.1.1.6
log
@import NSD 4.0.0, tests from Dorian Büttner, Patrik Lundin, requested by brad@@
@
text
@d4 1
a4 1
 * Copyright (c) 2001-2006, NLnet Labs. All rights reserved.
a14 3
#include <sys/stat.h>
#include <sys/types.h>
#include <unistd.h>
d171 2
a172 2
		log_msg(LOG_ERR, "xfrd: corrupt state file %s dated %d (now=%lld)",
			statefile, (int)filetime, (long long)xfrd_time());
d214 2
a215 2
			log_msg(LOG_ERR, "xfrd: corrupt state file %s dated %d (now=%lld)",
				statefile, (int)filetime, (long long)xfrd_time());
d241 1
a241 1
		zone->timeout.tv_usec = 0;
d244 2
a245 2
		zone->master = acl_find_num(zone->zone_options->pattern->
			request_xfr, zone->master_num);
d249 1
a249 1
			zone->master = zone->zone_options->pattern->request_xfr;
d293 2
a294 2
		log_msg(LOG_ERR, "xfrd: corrupt state file %s dated %d (now=%lld)",
			statefile, (int)filetime, (long long)xfrd_time());
d307 1
a307 1
neato_timeout(FILE* out, const char* str, time_t secs)
d311 1
a311 1
		fprintf(out, " %llds", (long long)secs);
d315 1
a315 1
		fprintf(out, " %lldd", (long long)(secs/(3600*24)));
d319 1
a319 1
		fprintf(out, " %lldh", (long long)(secs/3600));
d323 1
a323 1
		fprintf(out, " %lldm", (long long)(secs/60));
d327 1
a327 1
		fprintf(out, " %llds", (long long)secs);
d427 1
a427 1
	fprintf(out, "filetime: %lld\t# %s\n", (long long)now, ctime(&now));
d443 2
a444 2
			(zone->zone_handler_flags&EV_TIMEOUT)?(int)zone->timeout.tv_sec:0);
		if((zone->zone_handler_flags&EV_TIMEOUT)) {
a460 79
}

/* return tempdirname */
static void
tempdirname(char* buf, size_t sz, struct nsd* nsd)
{
	snprintf(buf, sz, "%snsd-xfr-%d",
		nsd->options->xfrdir, (int)nsd->pid);
}

void
xfrd_make_tempdir(struct nsd* nsd)
{
	char tnm[1024];
	tempdirname(tnm, sizeof(tnm), nsd);
	/* create parent directories if needed (0750 permissions) */
	if(!create_dirs(tnm)) {
		log_msg(LOG_ERR, "parentdirs of %s failed", tnm);
	}
	/* restrictive permissions here, because this may be in /tmp */
	if(mkdir(tnm, 0700)==-1) {
		if(errno != EEXIST) {
			log_msg(LOG_ERR, "mkdir %s failed: %s",
				tnm, strerror(errno));
		}
	}
}

void
xfrd_del_tempdir(struct nsd* nsd)
{
	char tnm[1024];
	tempdirname(tnm, sizeof(tnm), nsd);
	/* ignore parent directories, they are likely /var/tmp, /tmp or
	 * /var/cache/nsd and do not have to be deleted */
	if(rmdir(tnm)==-1 && errno != ENOENT) {
		log_msg(LOG_WARNING, "rmdir %s failed: %s", tnm,
			strerror(errno));
	}
}

/* return name of xfrfile in tempdir */
static void
tempxfrname(char* buf, size_t sz, struct nsd* nsd, uint64_t number)
{
	char tnm[1024];
	tempdirname(tnm, sizeof(tnm), nsd);
	snprintf(buf, sz, "%s/xfr.%lld", tnm, (long long)number);
}

FILE*
xfrd_open_xfrfile(struct nsd* nsd, uint64_t number, char* mode)
{
	char fname[1024];
	FILE* xfr;
	tempxfrname(fname, sizeof(fname), nsd, number);
	xfr = fopen(fname, mode);
	if(!xfr && errno == ENOENT) {
		/* directory may not exist */
		xfrd_make_tempdir(nsd);
		xfr = fopen(fname, mode);
	}
	if(!xfr) {
		log_msg(LOG_ERR, "open %s for %s failed: %s", fname, mode,
			strerror(errno));
		return NULL;
	}
	return xfr;
}

void
xfrd_unlink_xfrfile(struct nsd* nsd, uint64_t number)
{
	char fname[1024];
	tempxfrname(fname, sizeof(fname), nsd, number);
	if(unlink(fname) == -1) {
		log_msg(LOG_WARNING, "could not unlink %s: %s", fname,
			strerror(errno));
	}
@


1.1.1.7
log
@update to NSD 4.0.1, ok sthen@@
@
text
@d448 1
a448 1
			neato_timeout(out, "\t# =", zone->timeout.tv_sec);
@


1.1.1.8
log
@update to NSD 4.1.0, ok sthen@@
@
text
@a191 6
		if(nsd.signal_hint_shutdown) {
			fclose(in);
			region_destroy(tempregion);
			return;
		}

a277 13
		} 

		/* there is a zone read and it matches what we had before */
		if(zone->soa_nsd_acquired && zone->state != xfrd_zone_expired
			&& zone->soa_nsd.serial == soa_nsd_read.serial) {
			xfrd_deactivate_zone(zone);
			zone->state = state;
			xfrd_set_timer(zone, timeout);
		}	
		if(zone->soa_nsd_acquired == 0 && soa_nsd_acquired_read == 0 &&
			soa_disk_acquired_read == 0) {
			/* continue expon backoff where we were + check now */
			zone->fresh_xfr_timeout = timeout;
@


1.1.1.9
log
@update to NSD 4.1.1, ok sthen@@
@
text
@a310 4
		if (zone->state == xfrd_zone_expired)
		{
			xfrd_send_expire_notification(zone);
		}
d370 1
a370 1
			if (isalnum((unsigned char)ch) || ch == '-' || ch == '_') {
@


