head	1.8;
access;
symbols
	OPENBSD_6_2_BASE:1.8
	OPENBSD_6_1:1.7.0.4
	OPENBSD_6_1_BASE:1.7
	OPENBSD_6_0:1.4.0.2
	OPENBSD_6_0_BASE:1.4
	OPENBSD_5_9:1.3.0.2
	OPENBSD_5_9_BASE:1.3
	NSD_4_1_6:1.1.1.10
	OPENBSD_5_8:1.3.0.4
	OPENBSD_5_8_BASE:1.3
	NSD_4_1_3:1.1.1.10
	OPENBSD_5_7:1.2.0.2
	OPENBSD_5_7_BASE:1.2
	NSD_4_1_1:1.1.1.9
	NSD_4_1_0:1.1.1.8
	OPENBSD_5_6:1.1.1.8.0.4
	OPENBSD_5_6_BASE:1.1.1.8
	NSD_4_0_3:1.1.1.8
	NSD_4_0_2:1.1.1.8
	OPENBSD_5_5:1.1.1.7.0.4
	OPENBSD_5_5_BASE:1.1.1.7
	NSD_4_0_1:1.1.1.7
	NSD_4_0_0:1.1.1.7
	NSD_3_2_16:1.1.1.6
	OPENBSD_5_4:1.1.1.5.0.6
	OPENBSD_5_4_BASE:1.1.1.5
	OPENBSD_5_3:1.1.1.5.0.4
	OPENBSD_5_3_BASE:1.1.1.5
	NSD_3_2_15:1.1.1.5
	NSD_3_2_14:1.1.1.5
	NSD_3_2_13:1.1.1.5
	OPENBSD_5_2:1.1.1.5.0.2
	OPENBSD_5_2_BASE:1.1.1.5
	NSD_3_2_11:1.1.1.5
	NSD_3_2_10:1.1.1.4
	OPENBSD_5_1_BASE:1.1.1.3
	OPENBSD_5_1:1.1.1.3.0.2
	NSD_3_2_9:1.1.1.3
	OPENBSD_5_0:1.1.1.2.0.2
	OPENBSD_5_0_BASE:1.1.1.2
	NSD_3_2_8:1.1.1.2
	OPENBSD_4_9:1.1.1.1.0.6
	OPENBSD_4_9_BASE:1.1.1.1
	NSD_3_2_6:1.1.1.1
	OPENBSD_4_8:1.1.1.1.0.4
	OPENBSD_4_8_BASE:1.1.1.1
	NSD_3_2_5:1.1.1.1
	OPENBSD_4_7:1.1.1.1.0.2
	OPENBSD_4_7_BASE:1.1.1.1
	NSD_3_2_4:1.1.1.1
	NLNETLABS:1.1.1;
locks; strict;
comment	@ * @;


1.8
date	2017.08.11.12.51.42;	author florian;	state Exp;
branches;
next	1.7;
commitid	eRypOacUvjLI7vWX;

1.7
date	2017.02.17.20.04.45;	author florian;	state Exp;
branches;
next	1.6;
commitid	WmSuN5M3Jbe54113;

1.6
date	2016.10.24.09.44.43;	author florian;	state Exp;
branches;
next	1.5;
commitid	g3wASIhTcujU0LFi;

1.5
date	2016.08.31.07.31.20;	author florian;	state Exp;
branches;
next	1.4;
commitid	1gMwFuybgH2l617m;

1.4
date	2016.06.24.08.34.03;	author florian;	state Exp;
branches;
next	1.3;
commitid	Z9jVKJJMPmC3zw2t;

1.3
date	2015.07.17.17.36.33;	author sthen;	state Exp;
branches;
next	1.2;
commitid	2WtkENMkCz3GhSbE;

1.2
date	2014.12.18.23.26.13;	author brad;	state Exp;
branches;
next	1.1;
commitid	rBaz3dZHAQwIDT3j;

1.1
date	2010.01.15.19.25.02;	author jakob;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2010.01.15.19.25.02;	author jakob;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2011.05.21.18.17.21;	author jakob;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2012.01.29.11.15.37;	author jakob;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2012.03.02.08.38.51;	author sthen;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2012.07.09.21.55.07;	author sthen;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2013.09.03.09.21.33;	author sthen;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2013.11.26.12.50.20;	author sthen;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2014.03.13.02.00.28;	author brad;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2015.02.03.10.24.32;	author brad;	state Exp;
branches;
next	1.1.1.10;
commitid	yn8l9RVkmdMVYIfl;

1.1.1.10
date	2015.07.17.17.36.01;	author sthen;	state Exp;
branches;
next	;
commitid	Jeq5uGP63ff7nS9K;


desc
@@


1.8
log
@update to 4.1.17
OK sthen
@
text
@/*
 * namedb.c -- common namedb operations.
 *
 * Copyright (c) 2001-2006, NLnet Labs. All rights reserved.
 *
 * See LICENSE for the license.
 *
 */

#include "config.h"

#include <sys/types.h>

#include <assert.h>
#include <ctype.h>
#include <limits.h>
#include <stdio.h>
#include <string.h>

#include "namedb.h"
#include "nsec3.h"

static domain_type *
allocate_domain_info(domain_table_type* table,
		     const dname_type* dname,
		     domain_type* parent)
{
	domain_type *result;

	assert(table);
	assert(dname);
	assert(parent);

	result = (domain_type *) region_alloc(table->region,
					      sizeof(domain_type));
#ifdef USE_RADIX_TREE
	result->dname 
#else
	result->node.key
#endif
		= dname_partial_copy(
		table->region, dname, domain_dname(parent)->label_count + 1);
	result->parent = parent;
	result->wildcard_child_closest_match = result;
	result->rrsets = NULL;
	result->usage = 0;
#ifdef NSEC3
	result->nsec3 = NULL;
#endif
	result->is_existing = 0;
	result->is_apex = 0;
	assert(table->numlist_last); /* it exists because root exists */
	/* push this domain at the end of the numlist */
	result->number = table->numlist_last->number+1;
	result->numlist_next = NULL;
	result->numlist_prev = table->numlist_last;
	table->numlist_last->numlist_next = result;
	table->numlist_last = result;

	return result;
}

#ifdef NSEC3
void
allocate_domain_nsec3(domain_table_type* table, domain_type* result)
{
	if(result->nsec3)
		return;
	result->nsec3 = (struct nsec3_domain_data*) region_alloc(table->region,
		sizeof(struct nsec3_domain_data));
	result->nsec3->nsec3_cover = NULL;
	result->nsec3->nsec3_wcard_child_cover = NULL;
	result->nsec3->nsec3_ds_parent_cover = NULL;
	result->nsec3->nsec3_is_exact = 0;
	result->nsec3->nsec3_ds_parent_is_exact = 0;
	result->nsec3->have_nsec3_hash = 0;
	result->nsec3->have_nsec3_wc_hash = 0;
	result->nsec3->have_nsec3_ds_parent_hash = 0;
	result->nsec3->prehash_prev = NULL;
	result->nsec3->prehash_next = NULL;
	result->nsec3->nsec3_node.key = NULL;
	result->nsec3->hash_node.key = NULL;
	result->nsec3->wchash_node.key = NULL;
	result->nsec3->dshash_node.key = NULL;
}
#endif /* NSEC3 */

/** make the domain last in the numlist, changes numbers of domains */
static void
numlist_make_last(domain_table_type* table, domain_type* domain)
{
	size_t sw;
	domain_type* last = table->numlist_last;
	if(domain == last)
		return;
	/* swap numbers with the last element */
	sw = domain->number;
	domain->number = last->number;
	last->number = sw;
	/* swap list position with the last element */
	assert(domain->numlist_next);
	assert(last->numlist_prev);
	if(domain->numlist_next != last) {
		/* case 1: there are nodes between domain .. last */
		domain_type* span_start = domain->numlist_next;
		domain_type* span_end = last->numlist_prev;
		/* these assignments walk the new list from start to end */
		if(domain->numlist_prev)
			domain->numlist_prev->numlist_next = last;
		last->numlist_prev = domain->numlist_prev;
		last->numlist_next = span_start;
		span_start->numlist_prev = last;
		span_end->numlist_next = domain;
		domain->numlist_prev = span_end;
		domain->numlist_next = NULL;
	} else {
		/* case 2: domain and last are neighbors */
		/* these assignments walk the new list from start to end */
		if(domain->numlist_prev)
			domain->numlist_prev->numlist_next = last;
		last->numlist_prev = domain->numlist_prev;
		last->numlist_next = domain;
		domain->numlist_prev = last;
		domain->numlist_next = NULL;
	}
	table->numlist_last = domain;
}

/** pop the biggest domain off the numlist */
static domain_type*
numlist_pop_last(domain_table_type* table)
{
	domain_type* d = table->numlist_last;
	table->numlist_last = table->numlist_last->numlist_prev;
	if(table->numlist_last)
		table->numlist_last->numlist_next = NULL;
	return d;
}

/** see if a domain is eligible to be deleted, and thus is not used */
static int
domain_can_be_deleted(domain_type* domain)
{
	domain_type* n;
	/* it has data or it has usage, do not delete it */
	if(domain->rrsets) return 0;
	if(domain->usage) return 0;
	n = domain_next(domain);
	/* it has children domains, do not delete it */
	if(n && domain_is_subdomain(n, domain))
		return 0;
	return 1;
}

#ifdef NSEC3
/** see if domain is on the prehash list */
int domain_is_prehash(domain_table_type* table, domain_type* domain)
{
	if(domain->nsec3
		&& (domain->nsec3->prehash_prev || domain->nsec3->prehash_next))
		return 1;
	return (table->prehash_list == domain);
}

/** remove domain node from NSEC3 tree in hash space */
void
zone_del_domain_in_hash_tree(rbtree_type* tree, rbnode_type* node)
{
	if(!node->key)
		return;
	rbtree_delete(tree, node->key);
	/* note that domain is no longer in the tree */
	node->key = NULL;
}

/** clear the prehash list */
void prehash_clear(domain_table_type* table)
{
	domain_type* d = table->prehash_list, *n;
	while(d) {
		n = d->nsec3->prehash_next;
		d->nsec3->prehash_prev = NULL;
		d->nsec3->prehash_next = NULL;
		d = n;
	}
	table->prehash_list = NULL;
}

/** add domain to prehash list */
void
prehash_add(domain_table_type* table, domain_type* domain)
{
	if(domain_is_prehash(table, domain))
		return;
	allocate_domain_nsec3(table, domain);
	domain->nsec3->prehash_next = table->prehash_list;
	if(table->prehash_list)
		table->prehash_list->nsec3->prehash_prev = domain;
	table->prehash_list = domain;
}

/** remove domain from prehash list */
void
prehash_del(domain_table_type* table, domain_type* domain)
{
	if(domain->nsec3->prehash_next)
		domain->nsec3->prehash_next->nsec3->prehash_prev =
			domain->nsec3->prehash_prev;
	if(domain->nsec3->prehash_prev)
		domain->nsec3->prehash_prev->nsec3->prehash_next =
			domain->nsec3->prehash_next;
	else	table->prehash_list = domain->nsec3->prehash_next;
	domain->nsec3->prehash_next = NULL;
	domain->nsec3->prehash_prev = NULL;
}
#endif /* NSEC3 */

/** perform domain name deletion */
static void
do_deldomain(namedb_type* db, domain_type* domain)
{
	assert(domain && domain->parent); /* exists and not root */
	/* first adjust the number list so that domain is the last one */
	numlist_make_last(db->domains, domain);
	/* pop off the domain from the number list */
	(void)numlist_pop_last(db->domains);

#ifdef NSEC3
	/* if on prehash list, remove from prehash */
	if(domain_is_prehash(db->domains, domain))
		prehash_del(db->domains, domain);

	/* see if nsec3-nodes are used */
	if(domain->nsec3) {
		if(domain->nsec3->nsec3_node.key)
			zone_del_domain_in_hash_tree(nsec3_tree_zone(db, domain)
				->nsec3tree, &domain->nsec3->nsec3_node);
		if(domain->nsec3->hash_node.key)
			zone_del_domain_in_hash_tree(nsec3_tree_zone(db, domain)
				->hashtree, &domain->nsec3->hash_node);
		if(domain->nsec3->wchash_node.key)
			zone_del_domain_in_hash_tree(nsec3_tree_zone(db, domain)
				->wchashtree, &domain->nsec3->wchash_node);
		if(domain->nsec3->dshash_node.key)
			zone_del_domain_in_hash_tree(nsec3_tree_dszone(db, domain)
				->dshashtree, &domain->nsec3->dshash_node);
		region_recycle(db->domains->region, domain->nsec3,
			sizeof(struct nsec3_domain_data));
	}
#endif /* NSEC3 */

	/* see if this domain is someones wildcard-child-closest-match,
	 * which can only be the parent, and then it should use the
	 * one-smaller than this domain as closest-match. */
	if(domain->parent->wildcard_child_closest_match == domain)
		domain->parent->wildcard_child_closest_match =
			domain_previous_existing_child(domain);

	/* actual removal */
#ifdef USE_RADIX_TREE
	radix_delete(db->domains->nametree, domain->rnode);
#else
	rbtree_delete(db->domains->names_to_domains, domain->node.key);
#endif
	region_recycle(db->domains->region, domain_dname(domain),
		dname_total_size(domain_dname(domain)));
	region_recycle(db->domains->region, domain, sizeof(domain_type));
}

void
domain_table_deldomain(namedb_type* db, domain_type* domain)
{
	while(domain_can_be_deleted(domain)) {
		/* delete it */
		do_deldomain(db, domain);
		/* test parent */
		domain = domain->parent;
	}
}

/** clear hash tree */
void
hash_tree_clear(rbtree_type* tree)
{
	rbnode_type* n;
	if(!tree) return;

	/* note that elements are no longer in the tree */
	for(n=rbtree_first(tree); n!=RBTREE_NULL; n=rbtree_next(n)) {
		n->key = NULL;
	}
	tree->count = 0;
	tree->root = RBTREE_NULL;
}

void hash_tree_delete(region_type* region, rbtree_type* tree)
{
	region_recycle(region, tree, sizeof(rbtree_type));
}

/** add domain nsec3 node to hashedspace tree */
void zone_add_domain_in_hash_tree(region_type* region, rbtree_type** tree,
	int (*cmpf)(const void*, const void*),
	domain_type* domain, rbnode_type* node)
{
	if(!*tree)
		*tree = rbtree_create(region, cmpf);
	if(node->key) return;
	memset(node, 0, sizeof(rbnode_type));
	node->key = domain;
	rbtree_insert(*tree, node);
}

domain_table_type *
domain_table_create(region_type* region)
{
	const dname_type* origin;
	domain_table_type* result;
	domain_type* root;

	assert(region);

	origin = dname_make(region, (uint8_t *) "", 0);

	root = (domain_type *) region_alloc(region, sizeof(domain_type));
#ifdef USE_RADIX_TREE
	root->dname
#else
	root->node.key
#endif
		= origin;
	root->parent = NULL;
	root->wildcard_child_closest_match = root;
	root->rrsets = NULL;
	root->number = 1; /* 0 is used for after header */
	root->usage = 1; /* do not delete root, ever */
	root->is_existing = 0;
	root->is_apex = 0;
	root->numlist_prev = NULL;
	root->numlist_next = NULL;
#ifdef NSEC3
	root->nsec3 = NULL;
#endif

	result = (domain_table_type *) region_alloc(region,
						    sizeof(domain_table_type));
	result->region = region;
#ifdef USE_RADIX_TREE
	result->nametree = radix_tree_create(region);
	root->rnode = radname_insert(result->nametree, dname_name(root->dname),
		root->dname->name_size, root);
#else
	result->names_to_domains = rbtree_create(
		region, (int (*)(const void *, const void *)) dname_compare);
	rbtree_insert(result->names_to_domains, (rbnode_type *) root);
#endif

	result->root = root;
	result->numlist_last = root;
#ifdef NSEC3
	result->prehash_list = NULL;
#endif

	return result;
}

int
domain_table_search(domain_table_type *table,
		   const dname_type   *dname,
		   domain_type       **closest_match,
		   domain_type       **closest_encloser)
{
	int exact;
	uint8_t label_match_count;

	assert(table);
	assert(dname);
	assert(closest_match);
	assert(closest_encloser);

#ifdef USE_RADIX_TREE
	exact = radname_find_less_equal(table->nametree, dname_name(dname),
		dname->name_size, (struct radnode**)closest_match);
	*closest_match = (domain_type*)((*(struct radnode**)closest_match)->elem);
#else
	exact = rbtree_find_less_equal(table->names_to_domains, dname, (rbnode_type **) closest_match);
#endif
	assert(*closest_match);

	*closest_encloser = *closest_match;

	if (!exact) {
		label_match_count = dname_label_match_count(
			domain_dname(*closest_encloser),
			dname);
		assert(label_match_count < dname->label_count);
		while (label_match_count < domain_dname(*closest_encloser)->label_count) {
			(*closest_encloser) = (*closest_encloser)->parent;
			assert(*closest_encloser);
		}
	}

	return exact;
}

domain_type *
domain_table_find(domain_table_type* table,
		  const dname_type* dname)
{
	domain_type* closest_match;
	domain_type* closest_encloser;
	int exact;

	exact = domain_table_search(
		table, dname, &closest_match, &closest_encloser);
	return exact ? closest_encloser : NULL;
}


domain_type *
domain_table_insert(domain_table_type* table,
		    const dname_type* dname)
{
	domain_type* closest_match;
	domain_type* closest_encloser;
	domain_type* result;
	int exact;

	assert(table);
	assert(dname);

	exact = domain_table_search(
		table, dname, &closest_match, &closest_encloser);
	if (exact) {
		result = closest_encloser;
	} else {
		assert(domain_dname(closest_encloser)->label_count < dname->label_count);

		/* Insert new node(s).  */
		do {
			result = allocate_domain_info(table,
						      dname,
						      closest_encloser);
#ifdef USE_RADIX_TREE
			result->rnode = radname_insert(table->nametree,
				dname_name(result->dname),
				result->dname->name_size, result);
#else
			rbtree_insert(table->names_to_domains, (rbnode_type *) result);
#endif

			/*
			 * If the newly added domain name is larger
			 * than the parent's current
			 * wildcard_child_closest_match but smaller or
			 * equal to the wildcard domain name, update
			 * the parent's wildcard_child_closest_match
			 * field.
			 */
			if (label_compare(dname_name(domain_dname(result)),
					  (const uint8_t *) "\001*") <= 0
			    && dname_compare(domain_dname(result),
					     domain_dname(closest_encloser->wildcard_child_closest_match)) > 0)
			{
				closest_encloser->wildcard_child_closest_match
					= result;
			}
			closest_encloser = result;
		} while (domain_dname(closest_encloser)->label_count < dname->label_count);
	}

	return result;
}

domain_type *domain_previous_existing_child(domain_type* domain)
{
	domain_type* parent = domain->parent;
	domain = domain_previous(domain);
	while(domain && !domain->is_existing) {
		if(domain == parent) /* do not walk back above parent */
			return parent;
		domain = domain_previous(domain);
	}
	return domain;
}

void
domain_add_rrset(domain_type* domain, rrset_type* rrset)
{
#if 0 	/* fast */
	rrset->next = domain->rrsets;
	domain->rrsets = rrset;
#else
	/* preserve ordering, add at end */
	rrset_type** p = &domain->rrsets;
	while(*p)
		p = &((*p)->next);
	*p = rrset;
	rrset->next = 0;
#endif

	while (domain && !domain->is_existing) {
		domain->is_existing = 1;
		/* does this name in existance update the parent's
		 * wildcard closest match? */
		if(domain->parent
		   && label_compare(dname_name(domain_dname(domain)),
			(const uint8_t *) "\001*") <= 0
		   && dname_compare(domain_dname(domain),
		   	domain_dname(domain->parent->wildcard_child_closest_match)) > 0) {
			domain->parent->wildcard_child_closest_match = domain;
		}
		domain = domain->parent;
	}
}


rrset_type *
domain_find_rrset(domain_type* domain, zone_type* zone, uint16_t type)
{
	rrset_type* result = domain->rrsets;

	while (result) {
		if (result->zone == zone && rrset_rrtype(result) == type) {
			return result;
		}
		result = result->next;
	}
	return NULL;
}

rrset_type *
domain_find_any_rrset(domain_type* domain, zone_type* zone)
{
	rrset_type* result = domain->rrsets;

	while (result) {
		if (result->zone == zone) {
			return result;
		}
		result = result->next;
	}
	return NULL;
}

zone_type *
domain_find_zone(namedb_type* db, domain_type* domain)
{
	rrset_type* rrset;
	while (domain) {
		if(domain->is_apex) {
			for (rrset = domain->rrsets; rrset; rrset = rrset->next) {
				if (rrset_rrtype(rrset) == TYPE_SOA) {
					return rrset->zone;
				}
			}
			return namedb_find_zone(db, domain_dname(domain));
		}
		domain = domain->parent;
	}
	return NULL;
}

zone_type *
domain_find_parent_zone(namedb_type* db, zone_type* zone)
{
	rrset_type* rrset;

	assert(zone);

	for (rrset = zone->apex->rrsets; rrset; rrset = rrset->next) {
		if (rrset->zone != zone && rrset_rrtype(rrset) == TYPE_NS) {
			return rrset->zone;
		}
	}
	/* the NS record in the parent zone above this zone is not present,
	 * workaround to find that parent zone anyway */
	if(zone->apex->parent)
		return domain_find_zone(db, zone->apex->parent);
	return NULL;
}

domain_type *
domain_find_ns_rrsets(domain_type* domain, zone_type* zone, rrset_type **ns)
{
	while (domain && domain != zone->apex) {
		*ns = domain_find_rrset(domain, zone, TYPE_NS);
		if (*ns)
			return domain;
		domain = domain->parent;
	}

	*ns = NULL;
	return NULL;
}

domain_type *
find_dname_above(domain_type* domain, zone_type* zone)
{
	domain_type* d = domain->parent;
	while(d && d != zone->apex) {
		if(domain_find_rrset(d, zone, TYPE_DNAME))
			return d;
		d = d->parent;
	}
	return NULL;
}

int
domain_is_glue(domain_type* domain, zone_type* zone)
{
	rrset_type* unused;
	domain_type* ns_domain = domain_find_ns_rrsets(domain, zone, &unused);
	return (ns_domain != NULL &&
		domain_find_rrset(ns_domain, zone, TYPE_SOA) == NULL);
}

domain_type *
domain_wildcard_child(domain_type* domain)
{
	domain_type* wildcard_child;

	assert(domain);
	assert(domain->wildcard_child_closest_match);

	wildcard_child = domain->wildcard_child_closest_match;
	if (wildcard_child != domain
	    && label_is_wildcard(dname_name(domain_dname(wildcard_child))))
	{
		return wildcard_child;
	} else {
		return NULL;
	}
}

int
zone_is_secure(zone_type* zone)
{
	assert(zone);
	return zone->is_secure;
}

uint16_t
rr_rrsig_type_covered(rr_type* rr)
{
	assert(rr->type == TYPE_RRSIG);
	assert(rr->rdata_count > 0);
	assert(rdata_atom_size(rr->rdatas[0]) == sizeof(uint16_t));

	return ntohs(* (uint16_t *) rdata_atom_data(rr->rdatas[0]));
}

zone_type *
namedb_find_zone(namedb_type* db, const dname_type* dname)
{
	struct radnode* n = radname_search(db->zonetree, dname_name(dname),
		dname->name_size);
	if(n) return (zone_type*)n->elem;
	return NULL;
}

rrset_type *
domain_find_non_cname_rrset(domain_type* domain, zone_type* zone)
{
	/* find any rrset type that is not allowed next to a CNAME */
	/* nothing is allowed next to a CNAME, except RRSIG, NSEC, NSEC3 */
	rrset_type *result = domain->rrsets;

	while (result) {
		if (result->zone == zone && /* here is the list of exceptions*/
			rrset_rrtype(result) != TYPE_CNAME &&
			rrset_rrtype(result) != TYPE_RRSIG &&
			rrset_rrtype(result) != TYPE_NXT &&
			rrset_rrtype(result) != TYPE_SIG &&
			rrset_rrtype(result) != TYPE_NSEC &&
			rrset_rrtype(result) != TYPE_NSEC3 ) {
			return result;
		}
		result = result->next;
	}
	return NULL;
}

int
namedb_lookup(struct namedb* db,
	      const dname_type* dname,
	      domain_type     **closest_match,
	      domain_type     **closest_encloser)
{
	return domain_table_search(
		db->domains, dname, closest_match, closest_encloser);
}
@


1.7
log
@Update to 4.1.15.
This contains a local patch to query.c (missed _t conversion) that has
been submitted upstream.
OK sthen
@
text
@d308 1
@


1.6
log
@Update to 4.1.13
Testing millert, brad and myself.
OK millert@@
@
text
@d167 1
a167 1
zone_del_domain_in_hash_tree(rbtree_t* tree, rbnode_t* node)
d283 1
a283 1
hash_tree_clear(rbtree_t* tree)
d285 1
a285 1
	rbnode_t* n;
d296 1
a296 1
void hash_tree_delete(region_type* region, rbtree_t* tree)
d298 1
a298 1
	region_recycle(region, tree, sizeof(rbtree_t));
d302 1
a302 1
void zone_add_domain_in_hash_tree(region_type* region, rbtree_t** tree,
d304 1
a304 1
	domain_type* domain, rbnode_t* node)
d308 1
a308 1
	memset(node, 0, sizeof(rbnode_t));
d354 1
a354 1
	rbtree_insert(result->names_to_domains, (rbnode_t *) root);
d385 1
a385 1
	exact = rbtree_find_less_equal(table->names_to_domains, dname, (rbnode_t **) closest_match);
d448 1
a448 1
			rbtree_insert(table->names_to_domains, (rbnode_t *) result);
@


1.5
log
@update to 4.1.11
"Working fine here." millert@@
OK dlg, sthen
@
text
@d36 6
a41 1
	result->dname = dname_partial_copy(
d260 1
d262 5
a266 2
	region_recycle(db->domains->region, (dname_type*)domain->dname,
		dname_total_size(domain->dname));
d325 6
a330 1
	root->dname = origin;
d347 1
d351 5
d380 1
d384 3
d443 1
d447 3
@


1.4
log
@Update to 4.1.10
Testing by millert@@, sthen@@ and me.
came up with the same diff & OK sthen@@
@
text
@d536 1
a536 1
domain_find_parent_zone(zone_type* zone)
d547 4
@


1.3
log
@merge conflicts
@
text
@d564 12
@


1.2
log
@Merge in some commits from upstream..

- Fix that failure to add tcp to tcp base does not leak the socket.
- Fixes for wildcard addition and deletion, speedup for some cases.
- Fix that queries for noname CH TXT are REFUSED instead of nodata.
- Fix #616: retry xfer for zones with no content after command.
- Fix that expired zones stay expired after a server restart.
- RFC 7344: CDS and CDNSKEY (read in).

ok sthen@@
@
text
@a445 13
int
domain_table_iterate(domain_table_type* table,
		    domain_table_iterator_type iterator,
		    void* user_data)
{
	int error = 0;
	struct radnode* n;
	for(n = radix_first(table->nametree); n; n = radix_next(n)) {
		error += iterator((domain_type*)n->elem, user_data);
	}
	return error;
}

@


1.1
log
@Initial revision
@
text
@d10 1
a10 1
#include <config.h>
d21 1
a21 1

d24 3
a26 3
allocate_domain_info(domain_table_type *table,
		     const dname_type *dname,
		     domain_type *parent)
d36 1
a36 1
	result->node.key = dname_partial_copy(
d41 1
a41 1
	result->number = 0;
d43 1
a43 6
	result->nsec3_cover = NULL;
	result->nsec3_wcard_child_cover = NULL;
	result->nsec3_ds_parent_cover = NULL;
	result->nsec3_lookup = NULL;
	result->nsec3_is_exact = 0;
	result->nsec3_ds_parent_is_exact = 0;
d47 7
d58 246
d305 1
a305 1
domain_table_create(region_type *region)
d307 3
a309 3
	const dname_type *origin;
	domain_table_type *result;
	domain_type *root;
d316 1
a316 1
	root->node.key = origin;
d321 1
d324 2
d327 1
a327 6
	root->nsec3_is_exact = 0;
	root->nsec3_ds_parent_is_exact = 0;
	root->nsec3_cover = NULL;
	root->nsec3_wcard_child_cover = NULL;
	root->nsec3_ds_parent_cover = NULL;
	root->nsec3_lookup = NULL;
d333 3
a335 3
	result->names_to_domains = rbtree_create(
		region, (int (*)(const void *, const void *)) dname_compare);
	rbtree_insert(result->names_to_domains, (rbnode_t *) root);
d338 4
d360 3
a362 1
	exact = rbtree_find_less_equal(table->names_to_domains, dname, (rbnode_t **) closest_match);
d382 2
a383 2
domain_table_find(domain_table_type *table,
		  const dname_type *dname)
d385 2
a386 2
	domain_type *closest_match;
	domain_type *closest_encloser;
d396 2
a397 2
domain_table_insert(domain_table_type *table,
		    const dname_type  *dname)
d399 3
a401 3
	domain_type *closest_match;
	domain_type *closest_encloser;
	domain_type *result;
d419 3
a421 2
			rbtree_insert(table->names_to_domains, (rbnode_t *) result);
			result->number = table->names_to_domains->count;
d447 1
a447 1
domain_table_iterate(domain_table_type *table,
d449 1
a449 1
		    void *user_data)
a450 2
	const void *dname;
	void *node;
d452 3
a454 5

	assert(table);

	RBTREE_WALK(table->names_to_domains, dname, node) {
		error += iterator((domain_type *) node, user_data);
a455 1

d459 11
d472 1
a472 1
domain_add_rrset(domain_type *domain, rrset_type *rrset)
d488 9
d503 1
a503 1
domain_find_rrset(domain_type *domain, zone_type *zone, uint16_t type)
d505 1
a505 1
	rrset_type *result = domain->rrsets;
d517 1
a517 1
domain_find_any_rrset(domain_type *domain, zone_type *zone)
d519 1
a519 1
	rrset_type *result = domain->rrsets;
d531 1
a531 1
domain_find_zone(domain_type *domain)
d533 1
a533 1
	rrset_type *rrset;
d535 5
a539 3
		for (rrset = domain->rrsets; rrset; rrset = rrset->next) {
			if (rrset_rrtype(rrset) == TYPE_SOA) {
				return rrset->zone;
d541 1
d549 1
a549 1
domain_find_parent_zone(zone_type *zone)
d551 1
a551 1
	rrset_type *rrset;
d564 1
a564 1
domain_find_ns_rrsets(domain_type *domain, zone_type *zone, rrset_type **ns)
d578 1
a578 1
domain_is_glue(domain_type *domain, zone_type *zone)
d580 2
a581 2
	rrset_type *unused;
	domain_type *ns_domain = domain_find_ns_rrsets(domain, zone, &unused);
d587 1
a587 1
domain_wildcard_child(domain_type *domain)
d589 1
a589 1
	domain_type *wildcard_child;
d605 1
a605 1
zone_is_secure(zone_type *zone)
d612 1
a612 1
rr_rrsig_type_covered(rr_type *rr)
d622 1
a622 1
namedb_find_zone(namedb_type *db, domain_type *domain)
d624 4
a627 8
	zone_type *zone;

	for (zone = db->zones; zone; zone = zone->next) {
		if (zone->apex == domain)
			break;
	}

	return zone;
d631 1
a631 1
domain_find_non_cname_rrset(domain_type *domain, zone_type *zone)
d650 10
@


1.1.1.1
log
@NSD v3.2.4
@
text
@@


1.1.1.2
log
@NSD v3.2.8
@
text
@d4 1
a4 1
 * Copyright (c) 2001-2011, NLnet Labs. All rights reserved.
@


1.1.1.3
log
@NSD v3.2.9
@
text
@a18 1
#include <errno.h>
a43 1
#ifdef FULL_PREHASH
d49 1
a49 2
#endif /* FULL_PREHASH */
#endif /* NSEC3 */
a51 1
	result->has_SOA = 0;
a74 1
	root->has_SOA = 0;
a75 2
	root->nsec3_cover = NULL;
#ifdef FULL_PREHASH
d78 1
d82 1
a82 2
#endif /* FULL_PREHASH */
#endif /* NSEC3 */
a276 12
#ifndef FULL_PREHASH
domain_type *
domain_find_zone_apex(domain_type *domain) {
	while (domain != NULL) {
		if (domain->has_SOA != 0)
			return domain;
		domain = domain->parent;
	}
	return NULL;
}
#endif /* !FULL_PREHASH */

a383 249

/**
 * Create namedb.
 *
 */
struct namedb *
namedb_create(void)
{
	struct namedb *db = NULL;
	region_type *region = NULL;
#ifdef NSEC3
#ifndef FULL_PREHASH
	region_type *nsec3_region = NULL;
	region_type *nsec3_mod_region = NULL;
#endif /* !FULL_PREHASH */
#endif /* NSEC3 */

#ifdef USE_MMAP_ALLOC
	region = region_create_custom(mmap_alloc, mmap_free,
		MMAP_ALLOC_CHUNK_SIZE, MMAP_ALLOC_LARGE_OBJECT_SIZE,
		MMAP_ALLOC_INITIAL_CLEANUP_SIZE, 1);
#else /* !USE_MMAP_ALLOC */
	region = region_create_custom(xalloc, free,
		DEFAULT_CHUNK_SIZE, DEFAULT_LARGE_OBJECT_SIZE,
		DEFAULT_INITIAL_CLEANUP_SIZE, 1);
#endif /* !USE_MMAP_ALLOC */
	if (region == NULL)
		return NULL;

#ifdef NSEC3
#ifndef FULL_PREHASH
#ifdef USE_MMAP_ALLOC
	nsec3_region = region_create_custom(mmap_alloc, mmap_free,
		MMAP_ALLOC_CHUNK_SIZE, MMAP_ALLOC_LARGE_OBJECT_SIZE,
		MMAP_ALLOC_INITIAL_CLEANUP_SIZE, 1);
#else /* !USE_MMAP_ALLOC */
	nsec3_region = region_create_custom(xalloc, free,
		DEFAULT_CHUNK_SIZE, DEFAULT_LARGE_OBJECT_SIZE,
		DEFAULT_INITIAL_CLEANUP_SIZE, 1);
#endif /* !USE_MMAP_ALLOC */
	if (nsec3_region == NULL) {
		region_destroy(region);
		return NULL;
	}
#ifdef USE_MMAP_ALLOC
	nsec3_mod_region = region_create_custom(mmap_alloc, mmap_free,
		MMAP_ALLOC_CHUNK_SIZE, MMAP_ALLOC_LARGE_OBJECT_SIZE,
		MMAP_ALLOC_INITIAL_CLEANUP_SIZE, 1);
#else /* !USE_MMAP_ALLOC */
	nsec3_mod_region = region_create_custom(xalloc, free,
		DEFAULT_CHUNK_SIZE, DEFAULT_LARGE_OBJECT_SIZE,
		DEFAULT_INITIAL_CLEANUP_SIZE, 1);
#endif /* !USE_MMAP_ALLOC */
	if (nsec3_mod_region == NULL) {
		region_destroy(region);
		region_destroy(nsec3_region);
		return NULL;
	}
#endif /* !FULL_PREHASH */
#endif /* NSEC3 */

	/* Make a new structure... */
	db = (namedb_type *) region_alloc(region, sizeof(namedb_type));
	db->region = region;
#ifdef NSEC3
#ifndef FULL_PREHASH
	db->nsec3_region = nsec3_region;
	db->nsec3_mod_region = nsec3_mod_region;
	db->nsec3_mod_domains = NULL;
#endif /* !FULL_PREHASH */
#endif /* NSEC3 */
	db->domains = domain_table_create(region);
	db->zones = NULL;
	db->zone_count = 0;
	db->filename = NULL;
	db->fd = NULL;
	db->crc = ~0;
	db->crc_pos = 0;
	db->diff_skip = 0;
	db->diff_pos = 0;
	return db;
}

/**
 * Destroy namedb.
 *
 */
void
namedb_destroy(struct namedb *db)
{
#ifdef NSEC3
#ifndef FULL_PREHASH
	region_destroy(db->nsec3_mod_region);
	db->nsec3_mod_region = NULL;
	db->nsec3_mod_domains = NULL;
	region_destroy(db->nsec3_region);
	db->nsec3_region = NULL;
#endif /* !FULL_PREHASH */
#endif /* NSEC3 */
	region_destroy(db->region);
}


#ifdef NSEC3
#ifndef FULL_PREHASH
int
zone_nsec3_domains_create(struct namedb *db, struct zone *zone)
{
	if ((db == NULL) || (zone == NULL))
		return EINVAL;
	if (zone->nsec3_domains != NULL)
		return 0;
	zone->nsec3_domains = rbtree_create(db->nsec3_region,
					    dname_compare);
	if (zone->nsec3_domains == NULL)
		return ENOMEM;
	return 0;
}

int
zone_nsec3_domains_destroy(struct namedb *db, struct zone *zone)
{
	rbnode_t *node;
	if ((db == NULL) || (zone == NULL))
		return EINVAL;
	if (zone->nsec3_domains == NULL)
		return 0;

	node = rbtree_postorder_first(zone->nsec3_domains->root);
	while (node != RBTREE_NULL) {
		struct nsec3_domain *nsec3_domain =
			(struct nsec3_domain *) node;
		node = rbtree_postorder_next(node);

		if (nsec3_domain->covers != NULL) {
			nsec3_domain->covers->nsec3_cover = NULL;
		}
		region_recycle(db->nsec3_region, nsec3_domain,
			sizeof(*nsec3_domain));
	}
	region_recycle(db->nsec3_region, zone->nsec3_domains,
		sizeof(*(zone->nsec3_domains)));
	zone->nsec3_domains = NULL;
	return 0;
}


int
namedb_add_nsec3_domain(struct namedb *db, struct domain *domain,
	struct zone *zone)
{
	struct nsec3_domain *nsec3_domain;
	if (zone->nsec3_domains == NULL)
		return 0;
	nsec3_domain = (struct nsec3_domain *) region_alloc(db->nsec3_region,
		sizeof(*nsec3_domain));
	if (nsec3_domain == NULL)
		return ENOMEM;
	nsec3_domain->node.key = domain_dname(domain);
	nsec3_domain->nsec3_domain = domain;
	nsec3_domain->covers = NULL;
	if (rbtree_insert(zone->nsec3_domains, (rbnode_t *) nsec3_domain) == NULL) {
		region_recycle(db->nsec3_region, nsec3_domain, sizeof(*nsec3_domain));
	}
	return 0;
}


int
namedb_del_nsec3_domain(struct namedb *db, struct domain *domain,
	struct zone *zone)
{
	rbnode_t *node;
	struct nsec3_domain *nsec3_domain;
	int error = 0;

	if (zone->nsec3_domains == NULL)
		return 0;

	node = rbtree_delete(zone->nsec3_domains, domain_dname(domain));
	if (node == NULL)
		return 0;

	nsec3_domain = (struct nsec3_domain *) node;
	if (nsec3_domain->covers != NULL) {
		/*
		 * It is possible that this NSEC3 domain was modified
		 * due to the addition/deletion of another NSEC3 domain.
		 * Make sure it gets added to the NSEC3 list later by
		 * making sure it's covered domain is added to the
		 * NSEC3 mod list. S64#3441
		 */
		error = namedb_add_nsec3_mod_domain(db, nsec3_domain->covers);
		nsec3_domain->covers->nsec3_cover = NULL;
		nsec3_domain->covers = NULL;
	}
	region_recycle(db->nsec3_region, nsec3_domain, sizeof(*nsec3_domain));
	return error;
}


int
namedb_nsec3_mod_domains_create(struct namedb *db)
{
	if (db == NULL)
		return EINVAL;
	namedb_nsec3_mod_domains_destroy(db);

	db->nsec3_mod_domains = rbtree_create(db->nsec3_mod_region, dname_compare);
	if (db->nsec3_mod_domains == NULL)
		return ENOMEM;
	return 0;
}


int
namedb_nsec3_mod_domains_destroy(struct namedb *db)
{
	if (db == NULL)
		return EINVAL;
	if (db->nsec3_mod_domains == NULL)
		return 0;
	region_free_all(db->nsec3_mod_region);
	db->nsec3_mod_domains = NULL;
	return 0;
}

int
namedb_add_nsec3_mod_domain(struct namedb *db, struct domain *domain)
{
	struct nsec3_mod_domain *nsec3_mod_domain;
	nsec3_mod_domain = (struct nsec3_mod_domain *)
		region_alloc(db->nsec3_mod_region, sizeof(*nsec3_mod_domain));
	if (nsec3_mod_domain == NULL) {
		log_msg(LOG_ERR,
			"memory allocation failure on modified domain");
		return ENOMEM;
	}
	nsec3_mod_domain->node.key = domain_dname(domain);
	nsec3_mod_domain->domain = domain;

	if (rbtree_insert(db->nsec3_mod_domains, (rbnode_t *) nsec3_mod_domain) == NULL) {
		region_recycle(db->nsec3_mod_region, nsec3_mod_domain,
			sizeof(*nsec3_mod_domain));
	}
	return 0;
}
#endif /* !FULL_PREHASH */
#endif /* NSEC3 */
@


1.1.1.4
log
@import nsd 3.2.10, "cool" jakob@@, also looked over by Brad
@
text
@a39 1
	result->nextdiff = NULL;
a73 1
	root->nextdiff = NULL;
@


1.1.1.5
log
@NSD v3.2.11, ok phessler@@
@
text
@d10 1
a10 1
#include "config.h"
@


1.1.1.6
log
@update to NSD 3.2.16, ok deraadt@@ brad@@
@
text
@d23 1
@


1.1.1.7
log
@import NSD 4.0.0, tests from Dorian Büttner, Patrik Lundin, requested by brad@@
@
text
@d4 1
a4 1
 * Copyright (c) 2001-2006, NLnet Labs. All rights reserved.
d19 1
a21 1
#include "nsec3.h"
d24 3
a26 3
allocate_domain_info(domain_table_type* table,
		     const dname_type* dname,
		     domain_type* parent)
d36 1
a36 1
	result->dname = dname_partial_copy(
d39 1
d42 1
a42 1
	result->usage = 0;
d44 9
a52 2
	result->nsec3 = NULL;
#endif
d55 1
a55 7
	assert(table->numlist_last); /* it exists because root exists */
	/* push this domain at the end of the numlist */
	result->number = table->numlist_last->number+1;
	result->numlist_next = NULL;
	result->numlist_prev = table->numlist_last;
	table->numlist_last->numlist_next = result;
	table->numlist_last = result;
a59 246
#ifdef NSEC3
void
allocate_domain_nsec3(domain_table_type* table, domain_type* result)
{
	if(result->nsec3)
		return;
	result->nsec3 = (struct nsec3_domain_data*) region_alloc(table->region,
		sizeof(struct nsec3_domain_data));
	result->nsec3->nsec3_cover = NULL;
	result->nsec3->nsec3_wcard_child_cover = NULL;
	result->nsec3->nsec3_ds_parent_cover = NULL;
	result->nsec3->nsec3_is_exact = 0;
	result->nsec3->nsec3_ds_parent_is_exact = 0;
	result->nsec3->have_nsec3_hash = 0;
	result->nsec3->have_nsec3_wc_hash = 0;
	result->nsec3->have_nsec3_ds_parent_hash = 0;
	result->nsec3->prehash_prev = NULL;
	result->nsec3->prehash_next = NULL;
	result->nsec3->nsec3_node.key = NULL;
	result->nsec3->hash_node.key = NULL;
	result->nsec3->wchash_node.key = NULL;
	result->nsec3->dshash_node.key = NULL;
}
#endif /* NSEC3 */

/** make the domain last in the numlist, changes numbers of domains */
static void
numlist_make_last(domain_table_type* table, domain_type* domain)
{
	size_t sw;
	domain_type* last = table->numlist_last;
	if(domain == last)
		return;
	/* swap numbers with the last element */
	sw = domain->number;
	domain->number = last->number;
	last->number = sw;
	/* swap list position with the last element */
	assert(domain->numlist_next);
	assert(last->numlist_prev);
	if(domain->numlist_next != last) {
		/* case 1: there are nodes between domain .. last */
		domain_type* span_start = domain->numlist_next;
		domain_type* span_end = last->numlist_prev;
		/* these assignments walk the new list from start to end */
		if(domain->numlist_prev)
			domain->numlist_prev->numlist_next = last;
		last->numlist_prev = domain->numlist_prev;
		last->numlist_next = span_start;
		span_start->numlist_prev = last;
		span_end->numlist_next = domain;
		domain->numlist_prev = span_end;
		domain->numlist_next = NULL;
	} else {
		/* case 2: domain and last are neighbors */
		/* these assignments walk the new list from start to end */
		if(domain->numlist_prev)
			domain->numlist_prev->numlist_next = last;
		last->numlist_prev = domain->numlist_prev;
		last->numlist_next = domain;
		domain->numlist_prev = last;
		domain->numlist_next = NULL;
	}
	table->numlist_last = domain;
}

/** pop the biggest domain off the numlist */
static domain_type*
numlist_pop_last(domain_table_type* table)
{
	domain_type* d = table->numlist_last;
	table->numlist_last = table->numlist_last->numlist_prev;
	if(table->numlist_last)
		table->numlist_last->numlist_next = NULL;
	return d;
}

/** see if a domain is eligible to be deleted, and thus is not used */
static int
domain_can_be_deleted(domain_type* domain)
{
	domain_type* n;
	/* it has data or it has usage, do not delete it */
	if(domain->rrsets) return 0;
	if(domain->usage) return 0;
	n = domain_next(domain);
	/* it has children domains, do not delete it */
	if(n && domain_is_subdomain(n, domain))
		return 0;
	return 1;
}

#ifdef NSEC3
/** see if domain is on the prehash list */
int domain_is_prehash(domain_table_type* table, domain_type* domain)
{
	if(domain->nsec3
		&& (domain->nsec3->prehash_prev || domain->nsec3->prehash_next))
		return 1;
	return (table->prehash_list == domain);
}

/** remove domain node from NSEC3 tree in hash space */
void
zone_del_domain_in_hash_tree(rbtree_t* tree, rbnode_t* node)
{
	if(!node->key)
		return;
	rbtree_delete(tree, node->key);
	/* note that domain is no longer in the tree */
	node->key = NULL;
}

/** clear the prehash list */
void prehash_clear(domain_table_type* table)
{
	domain_type* d = table->prehash_list, *n;
	while(d) {
		n = d->nsec3->prehash_next;
		d->nsec3->prehash_prev = NULL;
		d->nsec3->prehash_next = NULL;
		d = n;
	}
	table->prehash_list = NULL;
}

/** add domain to prehash list */
void
prehash_add(domain_table_type* table, domain_type* domain)
{
	if(domain_is_prehash(table, domain))
		return;
	allocate_domain_nsec3(table, domain);
	domain->nsec3->prehash_next = table->prehash_list;
	if(table->prehash_list)
		table->prehash_list->nsec3->prehash_prev = domain;
	table->prehash_list = domain;
}

/** remove domain from prehash list */
void
prehash_del(domain_table_type* table, domain_type* domain)
{
	if(domain->nsec3->prehash_next)
		domain->nsec3->prehash_next->nsec3->prehash_prev =
			domain->nsec3->prehash_prev;
	if(domain->nsec3->prehash_prev)
		domain->nsec3->prehash_prev->nsec3->prehash_next =
			domain->nsec3->prehash_next;
	else	table->prehash_list = domain->nsec3->prehash_next;
	domain->nsec3->prehash_next = NULL;
	domain->nsec3->prehash_prev = NULL;
}
#endif /* NSEC3 */

/** perform domain name deletion */
static void
do_deldomain(namedb_type* db, domain_type* domain)
{
	assert(domain && domain->parent); /* exists and not root */
	/* first adjust the number list so that domain is the last one */
	numlist_make_last(db->domains, domain);
	/* pop off the domain from the number list */
	(void)numlist_pop_last(db->domains);

#ifdef NSEC3
	/* if on prehash list, remove from prehash */
	if(domain_is_prehash(db->domains, domain))
		prehash_del(db->domains, domain);

	/* see if nsec3-nodes are used */
	if(domain->nsec3) {
		if(domain->nsec3->nsec3_node.key)
			zone_del_domain_in_hash_tree(nsec3_tree_zone(db, domain)
				->nsec3tree, &domain->nsec3->nsec3_node);
		if(domain->nsec3->hash_node.key)
			zone_del_domain_in_hash_tree(nsec3_tree_zone(db, domain)
				->hashtree, &domain->nsec3->hash_node);
		if(domain->nsec3->wchash_node.key)
			zone_del_domain_in_hash_tree(nsec3_tree_zone(db, domain)
				->wchashtree, &domain->nsec3->wchash_node);
		if(domain->nsec3->dshash_node.key)
			zone_del_domain_in_hash_tree(nsec3_tree_dszone(db, domain)
				->dshashtree, &domain->nsec3->dshash_node);
		region_recycle(db->domains->region, domain->nsec3,
			sizeof(struct nsec3_domain_data));
	}
#endif /* NSEC3 */

	/* see if this domain is someones wildcard-child-closest-match,
	 * which can only be the parent, and then it should use the
	 * one-smaller than this domain as closest-match. */
	if(domain->parent->wildcard_child_closest_match == domain)
		domain->parent->wildcard_child_closest_match =
			domain_previous(domain);

	/* actual removal */
	radix_delete(db->domains->nametree, domain->rnode);
	region_recycle(db->domains->region, (dname_type*)domain->dname,
		dname_total_size(domain->dname));
	region_recycle(db->domains->region, domain, sizeof(domain_type));
}

void
domain_table_deldomain(namedb_type* db, domain_type* domain)
{
	while(domain_can_be_deleted(domain)) {
		/* delete it */
		do_deldomain(db, domain);
		/* test parent */
		domain = domain->parent;
	}
}

/** clear hash tree */
void
hash_tree_clear(rbtree_t* tree)
{
	rbnode_t* n;
	if(!tree) return;

	/* note that elements are no longer in the tree */
	for(n=rbtree_first(tree); n!=RBTREE_NULL; n=rbtree_next(n)) {
		n->key = NULL;
	}
	tree->count = 0;
	tree->root = RBTREE_NULL;
}

void hash_tree_delete(region_type* region, rbtree_t* tree)
{
	region_recycle(region, tree, sizeof(rbtree_t));
}

/** add domain nsec3 node to hashedspace tree */
void zone_add_domain_in_hash_tree(region_type* region, rbtree_t** tree,
	int (*cmpf)(const void*, const void*),
	domain_type* domain, rbnode_t* node)
{
	if(!*tree)
		*tree = rbtree_create(region, cmpf);
	memset(node, 0, sizeof(rbnode_t));
	node->key = domain;
	rbtree_insert(*tree, node);
}

d61 1
a61 1
domain_table_create(region_type* region)
d63 3
a65 3
	const dname_type* origin;
	domain_table_type* result;
	domain_type* root;
d72 1
a72 1
	root->dname = origin;
d74 1
a77 1
	root->usage = 1; /* do not delete root, ever */
d80 1
a80 2
	root->numlist_prev = NULL;
	root->numlist_next = NULL;
d82 9
a90 2
	root->nsec3 = NULL;
#endif
d95 3
a97 3
	result->nametree = radix_tree_create(region);
	root->rnode = radname_insert(result->nametree, dname_name(root->dname),
		root->dname->name_size, root);
a99 4
	result->numlist_last = root;
#ifdef NSEC3
	result->prehash_list = NULL;
#endif
d118 1
a118 3
	exact = radname_find_less_equal(table->nametree, dname_name(dname),
		dname->name_size, (struct radnode**)closest_match);
	*closest_match = (domain_type*)((*(struct radnode**)closest_match)->elem);
d138 2
a139 2
domain_table_find(domain_table_type* table,
		  const dname_type* dname)
d141 2
a142 2
	domain_type* closest_match;
	domain_type* closest_encloser;
d152 2
a153 2
domain_table_insert(domain_table_type* table,
		    const dname_type* dname)
d155 3
a157 3
	domain_type* closest_match;
	domain_type* closest_encloser;
	domain_type* result;
d175 2
a176 3
			result->rnode = radname_insert(table->nametree,
				dname_name(result->dname),
				result->dname->name_size, result);
d202 1
a202 1
domain_table_iterate(domain_table_type* table,
d204 1
a204 1
		    void* user_data)
d206 2
d209 5
a213 3
	struct radnode* n;
	for(n = radix_first(table->nametree); n; n = radix_next(n)) {
		error += iterator((domain_type*)n->elem, user_data);
d215 1
d221 1
a221 1
domain_add_rrset(domain_type* domain, rrset_type* rrset)
d243 1
a243 1
domain_find_rrset(domain_type* domain, zone_type* zone, uint16_t type)
d245 1
a245 1
	rrset_type* result = domain->rrsets;
d257 1
a257 1
domain_find_any_rrset(domain_type* domain, zone_type* zone)
d259 1
a259 1
	rrset_type* result = domain->rrsets;
d271 1
a271 1
domain_find_zone(domain_type* domain)
d273 1
a273 1
	rrset_type* rrset;
d285 12
d298 1
a298 1
domain_find_parent_zone(zone_type* zone)
d300 1
a300 1
	rrset_type* rrset;
d313 1
a313 1
domain_find_ns_rrsets(domain_type* domain, zone_type* zone, rrset_type **ns)
d327 1
a327 1
domain_is_glue(domain_type* domain, zone_type* zone)
d329 2
a330 2
	rrset_type* unused;
	domain_type* ns_domain = domain_find_ns_rrsets(domain, zone, &unused);
d336 1
a336 1
domain_wildcard_child(domain_type* domain)
d338 1
a338 1
	domain_type* wildcard_child;
d354 1
a354 1
zone_is_secure(zone_type* zone)
d361 1
a361 1
rr_rrsig_type_covered(rr_type* rr)
d371 1
a371 1
namedb_find_zone(namedb_type* db, const dname_type* dname)
d373 8
a380 4
	struct radnode* n = radname_search(db->zonetree, dname_name(dname),
		dname->name_size);
	if(n) return (zone_type*)n->elem;
	return NULL;
d384 1
a384 1
domain_find_non_cname_rrset(domain_type* domain, zone_type* zone)
d405 146
d552 2
a553 4
namedb_lookup(struct namedb* db,
	      const dname_type* dname,
	      domain_type     **closest_match,
	      domain_type     **closest_encloser)
d555 14
a568 2
	return domain_table_search(
		db->domains, dname, closest_match, closest_encloser);
d570 83
@


1.1.1.8
log
@update to NSD 4.0.2, ok sthen@@
@
text
@d511 1
a511 1
domain_find_zone(namedb_type* db, domain_type* domain)
d515 3
a517 5
		if(domain->is_apex) {
			for (rrset = domain->rrsets; rrset; rrset = rrset->next) {
				if (rrset_rrtype(rrset) == TYPE_SOA) {
					return rrset->zone;
				}
a518 1
			return namedb_find_zone(db, domain_dname(domain));
@


1.1.1.9
log
@update to NSD 4.1.1, ok sthen@@
@
text
@d252 1
a252 1
			domain_previous_existing_child(domain);
a458 11
domain_type *domain_previous_existing_child(domain_type* domain)
{
	domain_type* parent = domain->parent;
	domain = domain_previous(domain);
	while(domain && !domain->is_existing) {
		if(domain == parent) /* do not walk back above parent */
			return parent;
		domain = domain_previous(domain);
	}
	return domain;
}
a476 9
		/* does this name in existance update the parent's
		 * wildcard closest match? */
		if(domain->parent
		   && label_compare(dname_name(domain_dname(domain)),
			(const uint8_t *) "\001*") <= 0
		   && dname_compare(domain_dname(domain),
		   	domain_dname(domain->parent->wildcard_child_closest_match)) > 0) {
			domain->parent->wildcard_child_closest_match = domain;
		}
@


1.1.1.10
log
@update to NSD 4.1.3, ok florian@@, also tested by brad
@
text
@d446 13
@


