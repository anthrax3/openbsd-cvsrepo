head	1.2;
access;
symbols
	OPENBSD_6_1_BASE:1.2
	OPENBSD_6_0:1.2.0.4
	OPENBSD_6_0_BASE:1.2
	OPENBSD_5_9:1.2.0.2
	OPENBSD_5_9_BASE:1.2
	NSD_4_1_6:1.1.1.5
	OPENBSD_5_8:1.1.1.5.0.10
	OPENBSD_5_8_BASE:1.1.1.5
	NSD_4_1_3:1.1.1.5
	OPENBSD_5_7:1.1.1.5.0.2
	OPENBSD_5_7_BASE:1.1.1.5
	NSD_4_1_1:1.1.1.5
	NSD_4_1_0:1.1.1.5
	OPENBSD_5_6:1.1.1.5.0.6
	OPENBSD_5_6_BASE:1.1.1.5
	NSD_4_0_3:1.1.1.5
	NSD_4_0_2:1.1.1.5
	OPENBSD_5_5:1.1.1.5.0.4
	OPENBSD_5_5_BASE:1.1.1.5
	NSD_4_0_1:1.1.1.5
	NSD_4_0_0:1.1.1.5
	NSD_3_2_16:1.1.1.4
	OPENBSD_5_4:1.1.1.3.0.6
	OPENBSD_5_4_BASE:1.1.1.3
	OPENBSD_5_3:1.1.1.3.0.4
	OPENBSD_5_3_BASE:1.1.1.3
	NSD_3_2_15:1.1.1.3
	NSD_3_2_14:1.1.1.3
	NSD_3_2_13:1.1.1.3
	OPENBSD_5_2:1.1.1.3.0.2
	OPENBSD_5_2_BASE:1.1.1.3
	NSD_3_2_11:1.1.1.3
	NSD_3_2_10:1.1.1.2
	OPENBSD_5_1_BASE:1.1.1.2
	OPENBSD_5_1:1.1.1.2.0.4
	NSD_3_2_9:1.1.1.2
	OPENBSD_5_0:1.1.1.2.0.2
	OPENBSD_5_0_BASE:1.1.1.2
	NSD_3_2_8:1.1.1.2
	OPENBSD_4_9:1.1.1.1.0.6
	OPENBSD_4_9_BASE:1.1.1.1
	NSD_3_2_6:1.1.1.1
	OPENBSD_4_8:1.1.1.1.0.4
	OPENBSD_4_8_BASE:1.1.1.1
	NSD_3_2_5:1.1.1.1
	OPENBSD_4_7:1.1.1.1.0.2
	OPENBSD_4_7_BASE:1.1.1.1
	NSD_3_2_4:1.1.1.1
	NLNETLABS:1.1.1;
locks; strict;
comment	@ * @;


1.2
date	2015.12.11.12.28.49;	author sthen;	state Exp;
branches;
next	1.1;
commitid	e67Hx722TeF4XpDl;

1.1
date	2010.01.15.19.25.00;	author jakob;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2010.01.15.19.25.00;	author jakob;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2011.05.21.18.17.18;	author jakob;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2012.07.09.21.55.07;	author sthen;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2013.09.03.09.21.35;	author sthen;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2013.11.26.12.50.14;	author sthen;	state Exp;
branches;
next	;


desc
@@


1.2
log
@update to NSD 4.1.7, ok florian@@
@
text
@/*
 * netio.c -- network I/O support.
 *
 * Copyright (c) 2001-2006, NLnet Labs. All rights reserved.
 *
 * See LICENSE for the license.
 *
 */
#include "config.h"

#include <assert.h>
#include <errno.h>
#include <sys/time.h>
#include <string.h>
#include <stdlib.h>
#include <poll.h>

#include "netio.h"
#include "util.h"

#define MAX_NETIO_FDS 1024

netio_type *
netio_create(region_type *region)
{
	netio_type *result;

	assert(region);

	result = (netio_type *) region_alloc(region, sizeof(netio_type));
	result->region = region;
	result->handlers = NULL;
	result->deallocated = NULL;
	result->dispatch_next = NULL;
	return result;
}

void
netio_add_handler(netio_type *netio, netio_handler_type *handler)
{
	netio_handler_list_type *elt;

	assert(netio);
	assert(handler);

	if (netio->deallocated) {
		/*
		 * If we have deallocated handler list elements, reuse
		 * the first one.
		 */
		elt = netio->deallocated;
		netio->deallocated = elt->next;
	} else {
		/*
		 * Allocate a new one.
		 */
		elt = (netio_handler_list_type *) region_alloc(
			netio->region, sizeof(netio_handler_list_type));
	}

	elt->next = netio->handlers;
	elt->handler = handler;
	elt->handler->pfd = -1;
	netio->handlers = elt;
}

void
netio_remove_handler(netio_type *netio, netio_handler_type *handler)
{
	netio_handler_list_type **elt_ptr;

	assert(netio);
	assert(handler);

	for (elt_ptr = &netio->handlers; *elt_ptr; elt_ptr = &(*elt_ptr)->next) {
		if ((*elt_ptr)->handler == handler) {
			netio_handler_list_type *next = (*elt_ptr)->next;
			if ((*elt_ptr) == netio->dispatch_next)
				netio->dispatch_next = next;
			(*elt_ptr)->handler = NULL;
			(*elt_ptr)->next = netio->deallocated;
			netio->deallocated = *elt_ptr;
			*elt_ptr = next;
			break;
		}
	}
}

const struct timespec *
netio_current_time(netio_type *netio)
{
	assert(netio);

	if (!netio->have_current_time) {
		struct timeval current_timeval;
		if (gettimeofday(&current_timeval, NULL) == -1) {
			log_msg(LOG_CRIT, "gettimeofday: %s, aborting.", strerror(errno));
			abort();
		}
		timeval_to_timespec(&netio->cached_current_time, &current_timeval);
		netio->have_current_time = 1;
	}

	return &netio->cached_current_time;
}

int
netio_dispatch(netio_type *netio, const struct timespec *timeout, const sigset_t *sigmask)
{
	/* static arrays to avoid allocation */
	static struct pollfd fds[MAX_NETIO_FDS];
	int numfd;
	int have_timeout = 0;
	struct timespec minimum_timeout;
	netio_handler_type *timeout_handler = NULL;
	netio_handler_list_type *elt;
	int rc;
	int result = 0;
#ifndef HAVE_PPOLL
	sigset_t origmask;
#endif

	assert(netio);

	/*
	 * Clear the cached current time.
	 */
	netio->have_current_time = 0;

	/*
	 * Initialize the minimum timeout with the timeout parameter.
	 */
	if (timeout) {
		have_timeout = 1;
		memcpy(&minimum_timeout, timeout, sizeof(struct timespec));
	}

	/*
	 * Initialize the fd_sets and timeout based on the handler
	 * information.
	 */
	numfd = 0;

	for (elt = netio->handlers; elt; elt = elt->next) {
		netio_handler_type *handler = elt->handler;
		if (handler->fd != -1 && numfd < MAX_NETIO_FDS) {
			fds[numfd].fd = handler->fd;
			fds[numfd].events = 0;
			fds[numfd].revents = 0;
			handler->pfd = numfd;
			if (handler->event_types & NETIO_EVENT_READ) {
				fds[numfd].events |= POLLIN;
			}
			if (handler->event_types & NETIO_EVENT_WRITE) {
				fds[numfd].events |= POLLOUT;
			}
			numfd++;
		} else {
			handler->pfd = -1;
		}
		if (handler->timeout && (handler->event_types & NETIO_EVENT_TIMEOUT)) {
			struct timespec relative;

			relative.tv_sec = handler->timeout->tv_sec;
			relative.tv_nsec = handler->timeout->tv_nsec;
			timespec_subtract(&relative, netio_current_time(netio));

			if (!have_timeout ||
			    timespec_compare(&relative, &minimum_timeout) < 0)
			{
				have_timeout = 1;
				minimum_timeout.tv_sec = relative.tv_sec;
				minimum_timeout.tv_nsec = relative.tv_nsec;
				timeout_handler = handler;
			}
		}
	}

	if (have_timeout && minimum_timeout.tv_sec < 0) {
		/*
		 * On negative timeout for a handler, immediately
		 * dispatch the timeout event without checking for
		 * other events.
		 */
		if (timeout_handler && (timeout_handler->event_types & NETIO_EVENT_TIMEOUT)) {
			timeout_handler->event_handler(netio, timeout_handler, NETIO_EVENT_TIMEOUT);
		}
		return result;
	}

	/* Check for events.  */
#ifdef HAVE_PPOLL
	rc = ppoll(fds, numfd, (have_timeout?&minimum_timeout:NULL), sigmask);
#else
	sigprocmask(SIG_SETMASK, sigmask, &origmask);
	rc = poll(fds, numfd, (have_timeout?minimum_timeout.tv_sec*1000+
		minimum_timeout.tv_nsec/1000000:-1));
	sigprocmask(SIG_SETMASK, &origmask, NULL);
#endif /* HAVE_PPOLL */
	if (rc == -1) {
		if(errno == EINVAL || errno == EACCES || errno == EBADF) {
			log_msg(LOG_ERR, "fatal error poll: %s.", 
				strerror(errno));
			exit(1);
		}
		return -1;
	}

	/*
	 * Clear the cached current_time (pselect(2) may block for
	 * some time so the cached value is likely to be old).
	 */
	netio->have_current_time = 0;

	if (rc == 0) {
		/*
		 * No events before the minimum timeout expired.
		 * Dispatch to handler if interested.
		 */
		if (timeout_handler && (timeout_handler->event_types & NETIO_EVENT_TIMEOUT)) {
			timeout_handler->event_handler(netio, timeout_handler, NETIO_EVENT_TIMEOUT);
		}
	} else {
		/*
		 * Dispatch all the events to interested handlers
		 * based on the fd_sets.  Note that a handler might
		 * deinstall itself, so store the next handler before
		 * calling the current handler!
		 */
		assert(netio->dispatch_next == NULL);

		for (elt = netio->handlers; elt && rc; ) {
			netio_handler_type *handler = elt->handler;
			netio->dispatch_next = elt->next;
			if (handler->fd != -1 && handler->pfd != -1) {
				netio_event_types_type event_types
					= NETIO_EVENT_NONE;
				if ((fds[handler->pfd].revents & POLLIN)) {
					event_types |= NETIO_EVENT_READ;
				}
				if ((fds[handler->pfd].revents & POLLOUT)) {
					event_types |= NETIO_EVENT_WRITE;
				}
				if ((fds[handler->pfd].revents &
					(POLLNVAL|POLLHUP|POLLERR))) {
					/* closed/error: give a read event,
					 * or otherwise, a write event */
					if((handler->event_types&NETIO_EVENT_READ))
						event_types |= NETIO_EVENT_READ;
					else if((handler->event_types&NETIO_EVENT_WRITE))
						event_types |= NETIO_EVENT_WRITE;
				}

				if (event_types & handler->event_types) {
					handler->event_handler(netio, handler, event_types & handler->event_types);
					++result;
				}
			}
			elt = netio->dispatch_next;
		}
		netio->dispatch_next = NULL;
	}

	return result;
}
@


1.1
log
@Initial revision
@
text
@d9 1
a9 1
#include <config.h>
d16 1
d21 1
a21 14

#ifndef HAVE_PSELECT
int pselect(int n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds,
	    const struct timespec *timeout, const sigset_t *sigmask);
#else
#include <sys/select.h>
#endif


struct netio_handler_list
{
	netio_handler_list_type *next;
	netio_handler_type      *handler;
};
d27 1
a27 1
	
d42 1
a42 1
	
d63 1
d71 1
a71 1
	
d110 3
a112 2
	fd_set readfds, writefds, exceptfds;
	int max_fd;
d119 4
a122 1
	
d129 1
a129 1
	
d142 1
a142 4
	max_fd = -1;
	FD_ZERO(&readfds);
	FD_ZERO(&writefds);
	FD_ZERO(&exceptfds);
d146 5
a150 4
		if (handler->fd >= 0 && handler->fd < (int)FD_SETSIZE) {
			if (handler->fd > max_fd) {
				max_fd = handler->fd;
			}
d152 1
a152 1
				FD_SET(handler->fd, &readfds);
d155 1
a155 4
				FD_SET(handler->fd, &writefds);
			}
			if (handler->event_types & NETIO_EVENT_EXCEPT) {
				FD_SET(handler->fd, &exceptfds);
d157 3
d181 1
a181 1
		 * On negative timeout for a handler, immediatly
d192 8
a199 3
	rc = pselect(max_fd + 1, &readfds, &writefds, &exceptfds,
		     have_timeout ? &minimum_timeout : NULL,
		     sigmask);
d202 1
a202 1
			log_msg(LOG_ERR, "fatal error pselect: %s.", 
d214 1
a214 1
	
d231 1
d235 1
a235 1
			if (handler->fd >= 0 && handler->fd < (int)FD_SETSIZE) {
d238 1
a238 1
				if (FD_ISSET(handler->fd, &readfds)) {
a239 2
					FD_CLR(handler->fd, &readfds);
					rc--;
d241 1
a241 1
				if (FD_ISSET(handler->fd, &writefds)) {
a242 2
					FD_CLR(handler->fd, &writefds);
					rc--;
d244 8
a251 4
				if (FD_ISSET(handler->fd, &exceptfds)) {
					event_types |= NETIO_EVENT_EXCEPT;
					FD_CLR(handler->fd, &exceptfds);
					rc--;
@


1.1.1.1
log
@NSD v3.2.4
@
text
@@


1.1.1.2
log
@NSD v3.2.8
@
text
@d4 1
a4 1
 * Copyright (c) 2001-2011, NLnet Labs. All rights reserved.
@


1.1.1.3
log
@NSD v3.2.11, ok phessler@@
@
text
@d9 1
a9 1
#include "config.h"
d39 1
a39 1

d54 1
a54 1

d82 1
a82 1

d129 1
a129 1

d136 1
a136 1

d156 1
a156 1
		if (handler->fd != -1 && handler->fd < (int)FD_SETSIZE) {
d161 1
a161 26
				extern int slowaccept;
				extern struct timespec slowaccept_timeout;

				if ((handler->event_types & NETIO_EVENT_ACCEPT) && slowaccept) {
					if (timespec_compare(&slowaccept_timeout, netio_current_time(netio)) < 0) {
						slowaccept = 0;
					}
					if (slowaccept) {
						/** Timeout after slowaccept timeout. */
						struct timespec relative;
						relative.tv_sec = slowaccept_timeout.tv_sec;
						relative.tv_nsec = slowaccept_timeout.tv_nsec;
						timespec_subtract(&relative, netio_current_time(netio));
						if (!have_timeout ||
							timespec_compare(&relative, &minimum_timeout) < 0) {
							have_timeout = 1;
							minimum_timeout.tv_sec = relative.tv_sec;
							minimum_timeout.tv_nsec = relative.tv_nsec;
						}
					} else {
						FD_SET(handler->fd, &readfds);
					}
				} else {
					/* Not accept event or not slow accept */
					FD_SET(handler->fd, &readfds);
				}
d218 1
a218 1

d238 1
a238 1
			if (handler->fd != -1 && handler->fd < (int)FD_SETSIZE) {
@


1.1.1.4
log
@update to NSD 3.2.16, ok deraadt@@ brad@@
@
text
@d28 7
@


1.1.1.5
log
@import NSD 4.0.0, tests from Dorian Büttner, Patrik Lundin, requested by brad@@
@
text
@d4 1
a4 1
 * Copyright (c) 2001-2006, NLnet Labs. All rights reserved.
d154 26
a179 1
				FD_SET(handler->fd, &readfds);
@


