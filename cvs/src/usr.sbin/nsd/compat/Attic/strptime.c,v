head	1.4;
access;
symbols
	NSD_4_1_3:1.1.1.4
	OPENBSD_5_7:1.3.0.2
	OPENBSD_5_7_BASE:1.3
	NSD_4_1_1:1.1.1.4
	NSD_4_1_0:1.1.1.3
	OPENBSD_5_6:1.1.1.3.0.6
	OPENBSD_5_6_BASE:1.1.1.3
	NSD_4_0_3:1.1.1.3
	NSD_4_0_2:1.1.1.3
	OPENBSD_5_5:1.1.1.3.0.4
	OPENBSD_5_5_BASE:1.1.1.3
	NSD_4_0_1:1.1.1.3
	NSD_4_0_0:1.1.1.3
	NSD_3_2_16:1.1.1.2
	OPENBSD_5_4:1.1.1.2.0.10
	OPENBSD_5_4_BASE:1.1.1.2
	OPENBSD_5_3:1.1.1.2.0.8
	OPENBSD_5_3_BASE:1.1.1.2
	NSD_3_2_15:1.1.1.2
	NSD_3_2_14:1.1.1.2
	NSD_3_2_13:1.1.1.2
	OPENBSD_5_2:1.1.1.2.0.6
	OPENBSD_5_2_BASE:1.1.1.2
	NSD_3_2_11:1.1.1.2
	NSD_3_2_10:1.1.1.2
	OPENBSD_5_1_BASE:1.1.1.2
	OPENBSD_5_1:1.1.1.2.0.4
	NSD_3_2_9:1.1.1.2
	OPENBSD_5_0:1.1.1.2.0.2
	OPENBSD_5_0_BASE:1.1.1.2
	NSD_3_2_8:1.1.1.2
	OPENBSD_4_9:1.1.1.1.0.6
	OPENBSD_4_9_BASE:1.1.1.1
	NSD_3_2_6:1.1.1.1
	OPENBSD_4_8:1.1.1.1.0.4
	OPENBSD_4_8_BASE:1.1.1.1
	NSD_3_2_5:1.1.1.1
	OPENBSD_4_7:1.1.1.1.0.2
	OPENBSD_4_7_BASE:1.1.1.1
	NSD_3_2_4:1.1.1.1
	NLNETLABS:1.1.1;
locks; strict;
comment	@ * @;


1.4
date	2015.07.19.17.52.28;	author sthen;	state dead;
branches;
next	1.3;
commitid	jt6H3wD8LZy1DQew;

1.3
date	2015.02.03.10.40.02;	author brad;	state Exp;
branches;
next	1.2;
commitid	MI9j0d0LR8Dk9lnd;

1.2
date	2015.01.12.14.36.48;	author millert;	state Exp;
branches;
next	1.1;
commitid	CE66UGc2yuwK21ce;

1.1
date	2010.01.15.19.25.08;	author jakob;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2010.01.15.19.25.08;	author jakob;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2011.05.21.18.17.25;	author jakob;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2013.11.26.12.50.30;	author sthen;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2015.02.03.10.24.35;	author brad;	state Exp;
branches;
next	;
commitid	yn8l9RVkmdMVYIfl;


desc
@@


1.4
log
@remove unused compat files, ok florian@@

b64_{ntop,pton} remain for now, they are in libc as __b64_{ntop,pton}
but to use this we either need to pull in resolv.h (which does "#define
b64_ntop __b64_ntop") or access the __ versions directly (as done in ssh).
@
text
@/** strptime workaround (for oa macos leopard)
  * This strptime follows the man strptime (2001-11-12)
  *		conforming to SUSv2, POSIX.1-2001
  *
  * This very simple version of strptime has no:
  * - E alternatives
  * - O alternatives
  * - Glibc additions
  * - Does not process week numbers
  * - Does not properly processes year day
  *
  * LICENSE
  * Copyright (c) 2008, NLnet Labs, Matthijs Mekking.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
  * * Redistributions of source code must retain the above copyright notice,
  *     this list of conditions and the following disclaimer.
  * * Redistributions in binary form must reproduce the above copyright
  *   notice, this list of conditions and the following disclaimer in the
  *   documentation and/or other materials provided with the distribution.
  * * Neither the name of NLnetLabs nor the names of its
  *   contributors may be used to endorse or promote products derived from this
  *   software without specific prior written permission.
  *
  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGE.
 **/

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#ifndef HAVE_CONFIG_H
#include <time.h>
#endif

#ifndef STRPTIME_WORKS

#define TM_YEAR_BASE 1900

#include <ctype.h>
#include <string.h>

static const char *abb_weekdays[] = {
	"Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat", NULL
};
static const char *full_weekdays[] = {
	"Sunday", "Monday", "Tuesday", "Wednesday",
	"Thursday", "Friday", "Saturday", NULL
};
static const char *abb_months[] = {
	"Jan", "Feb", "Mar", "Apr", "May", "Jun",
	"Jul", "Aug", "Sep", "Oct", "Nov", "Dec", NULL
};
static const char *full_months[] = {
	"January", "February", "March", "April", "May", "June",
	"July", "August", "September", "October", "November", "December", NULL
};
static const char *ampm[] = {
    "am", "pm", NULL
};

static int
match_string(const char **buf, const char **strs)
{
	int i = 0;

	for (i = 0; strs[i] != NULL; i++) {
		int len = strlen(strs[i]);
		if (strncasecmp (*buf, strs[i], len) == 0) {
			*buf += len;
			return i;
		}
	}
	return -1;
}

static int
str2int(const char **buf, int max)
{
	int ret=0, count=0;

	while (*buf[0] != '\0' && isdigit((unsigned char)*buf[0]) && count<max) {
		ret = ret*10 + (*buf[0] - '0');
		(*buf)++;
		count++;
	}

	if (!count)
		return -1;
	return ret;
}

/** Converts the character string s to values which are stored in tm
  * using the format specified by format
 **/
char *
nsd_strptime(const char *s, const char *format, struct tm *tm)
{
	int c, alt_format, ret;
	int split_year = 0;

	while ((c = *format) != '\0') {
		alt_format = 0;

		/* whitespace, literal or format */
		if (isspace((unsigned char)c)) { /* whitespace */
			/** whitespace matches zero or more whitespace characters in the
			  * input string.
			 **/
			while (isspace((unsigned char)*s))
				s++;
		}
		else if (c == '%') { /* format */
			format++;
			c = *format;
			switch (c) {
				case '%': /* %% is converted to % */
					if (*s != c) {
						return NULL;
					}
					s++;
					break;
				case 'a': /* weekday name, abbreviated or full */
				case 'A':
					ret = match_string(&s, full_weekdays);
					if (ret < 0)
						ret = match_string(&s, abb_weekdays);
					if (ret < 0) {
						return NULL;
					}
					tm->tm_wday = ret;
					break;
				case 'b': /* month name, abbreviated or full */
				case 'B':
				case 'h':
					ret = match_string(&s, full_months);
					if (ret < 0)
						ret = match_string(&s, abb_months);
					if (ret < 0) {
						return NULL;
					}
					tm->tm_mon = ret;
					break;
				case 'c': /* date and time representation */
					if (!(s = nsd_strptime(s, "%x %X", tm))) {
						return NULL;
					}
					break;
				case 'C': /* century number */
					ret = str2int(&s, 2);
					if (ret < 0 || ret > 99) { /* must be in [00,99] */
						return NULL;
					}

					if (split_year)	{
						tm->tm_year = ret*100 + (tm->tm_year%100);
					}
					else {
						tm->tm_year = ret*100 - TM_YEAR_BASE;
						split_year = 1;
					}
					break;
				case 'd': /* day of month */
				case 'e':
					ret = str2int(&s, 2);
					if (ret < 1 || ret > 31) { /* must be in [01,31] */
						return NULL;
					}
					tm->tm_mday = ret;
					break;
				case 'D': /* equivalent to %m/%d/%y */
					if (!(s = nsd_strptime(s, "%m/%d/%y", tm))) {
						return NULL;
					}
					break;
				case 'H': /* hour */
					ret = str2int(&s, 2);
					if (ret < 0 || ret > 23) { /* must be in [00,23] */
						return NULL;
					}
					tm->tm_hour = ret;
					break;
				case 'I': /* 12hr clock hour */
					ret = str2int(&s, 2);
					if (ret < 1 || ret > 12) { /* must be in [01,12] */
						return NULL;
					}
					if (ret == 12) /* actually [0,11] */
						ret = 0;
					tm->tm_hour = ret;
					break;
				case 'j': /* day of year */
					ret = str2int(&s, 2);
					if (ret < 1 || ret > 366) { /* must be in [001,366] */
						return NULL;
					}
					tm->tm_yday = ret;
					break;
				case 'm': /* month */
					ret = str2int(&s, 2);
					if (ret < 1 || ret > 12) { /* must be in [01,12] */
						return NULL;
					}
					/* months go from 0-11 */
					tm->tm_mon = (ret-1);
					break;
				case 'M': /* minute */
					ret = str2int(&s, 2);
					if (ret < 0 || ret > 59) { /* must be in [00,59] */
						return NULL;
					}
					tm->tm_min = ret;
					break;
				case 'n': /* arbitrary whitespace */
				case 't':
					while (isspace((unsigned char)*s))
						s++;
					break;
				case 'p': /* am pm */
					ret = match_string(&s, ampm);
					if (ret < 0) {
						return NULL;
					}
					if (tm->tm_hour < 0 || tm->tm_hour > 11) { /* %I */
						return NULL;
					}

					if (ret == 1) /* pm */
						tm->tm_hour += 12;
					break;
				case 'r': /* equivalent of %I:%M:%S %p */
					if (!(s = nsd_strptime(s, "%I:%M:%S %p", tm))) {
						return NULL;
					}
					break;
				case 'R': /* equivalent of %H:%M */
					if (!(s = nsd_strptime(s, "%H:%M", tm))) {
						return NULL;
					}
					break;
				case 'S': /* seconds */
					ret = str2int(&s, 2);
					/* 60 may occur for leap seconds */
					/* earlier 61 was also allowed */
					if (ret < 0 || ret > 60) { /* must be in [00,60] */
						return NULL;
					}
					tm->tm_sec = ret;
					break;
				case 'T': /* equivalent of %H:%M:%S */
					if (!(s = nsd_strptime(s, "%H:%M:%S", tm))) {
						return NULL;
					}
					break;
				case 'U': /* week number, with the first Sun of Jan being w1 */
					ret = str2int(&s, 2);
					if (ret < 0 || ret > 53) { /* must be in [00,53] */
						return NULL;
					}
					/** it is hard (and not necessary for nsd) to determine time
					  * data from week number.
					 **/
					break;
				case 'w': /* day of week */
					ret = str2int(&s, 1);
					if (ret < 0 || ret > 6) { /* must be in [0,6] */
						return NULL;
					}
					tm->tm_wday = ret;
					break;
				case 'W': /* week number, with the first Mon of Jan being w1 */
					ret = str2int(&s, 2);
					if (ret < 0 || ret > 53) { /* must be in [00,53] */
						return NULL;
					}
					/** it is hard (and not necessary for nsd) to determine time
					  * data from week number.
					 **/
					break;
				case 'x': /* date format */
					if (!(s = nsd_strptime(s, "%m/%d/%y", tm))) {
						return NULL;
					}
					break;
				case 'X': /* time format */
					if (!(s = nsd_strptime(s, "%H:%M:%S", tm))) {
						return NULL;
					}
					break;
				case 'y': /* last two digits of a year */
					ret = str2int(&s, 2);
					if (ret < 0 || ret > 99) { /* must be in [00,99] */
						return NULL;
					}
					if (split_year) {
						tm->tm_year = ((tm->tm_year/100) * 100) + ret;
					}
					else {
						split_year = 1;

						/** currently:
						  * if in [0,68] we are in 21th century,
						  * if in [69,99] we are in 20th century.
						 **/
						if (ret < 69) /* 2000 */
							ret += 100;
						tm->tm_year = ret;
					}
					break;
				case 'Y': /* year */
					ret = str2int(&s, 4);
					if (ret < 0 || ret > 9999) {
						return NULL;
					}
					tm->tm_year = ret - TM_YEAR_BASE;
					break;
				case '\0':
				default: /* unsupported, cannot match format */
					return NULL;
					break;
			}
		}
		else { /* literal */
			/* if input cannot match format, return NULL */
			if (*s != c)
				return NULL;
			s++;
		}

		format++;
	}

	/* return pointer to remainder of s */
	return (char*) s;
}

#endif /* STRPTIME_WORKS */
@


1.3
log
@merge conflicts
@
text
@@


1.2
log
@Use proper casts for ctype functions.  This is already fixed in nsd
trunk.  OK doug@@
@
text
@d114 1
a114 1
	while ((c = (unsigned char)*format) != '\0') {
d118 1
a118 1
		if (isspace(c)) { /* whitespace */
@


1.1
log
@Initial revision
@
text
@d13 1
a13 1
  * Copyright (c) 2008, NLnet Labs, Matthijs Mekking
d94 1
a94 1
	while (*buf[0] != '\0' && isdigit(*buf[0]) && count<max) {
d114 1
a114 1
	while ((c = *format) != '\0') {
d122 1
a122 1
			while (isspace(*s))
d228 1
a228 1
					while (isspace(*s))
@


1.1.1.1
log
@NSD v3.2.4
@
text
@@


1.1.1.2
log
@NSD v3.2.8
@
text
@d13 1
a13 1
  * Copyright (c) 2008-2011, NLnet Labs, Matthijs Mekking.
@


1.1.1.3
log
@import NSD 4.0.0, tests from Dorian Büttner, Patrik Lundin, requested by brad@@
@
text
@d13 1
a13 1
  * Copyright (c) 2008, NLnet Labs, Matthijs Mekking.
@


1.1.1.4
log
@update to NSD 4.1.1, ok sthen@@
@
text
@d94 1
a94 1
	while (*buf[0] != '\0' && isdigit((unsigned char)*buf[0]) && count<max) {
d118 1
a118 1
		if (isspace((unsigned char)c)) { /* whitespace */
d122 1
a122 1
			while (isspace((unsigned char)*s))
d228 1
a228 1
					while (isspace((unsigned char)*s))
@


