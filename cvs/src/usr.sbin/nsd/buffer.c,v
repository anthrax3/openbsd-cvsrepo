head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_2:1.1.1.5.0.18
	OPENBSD_6_2_BASE:1.1.1.5
	OPENBSD_6_1:1.1.1.5.0.16
	OPENBSD_6_1_BASE:1.1.1.5
	OPENBSD_6_0:1.1.1.5.0.12
	OPENBSD_6_0_BASE:1.1.1.5
	OPENBSD_5_9:1.1.1.5.0.8
	OPENBSD_5_9_BASE:1.1.1.5
	NSD_4_1_6:1.1.1.5
	OPENBSD_5_8:1.1.1.5.0.10
	OPENBSD_5_8_BASE:1.1.1.5
	NSD_4_1_3:1.1.1.5
	OPENBSD_5_7:1.1.1.5.0.2
	OPENBSD_5_7_BASE:1.1.1.5
	NSD_4_1_1:1.1.1.5
	NSD_4_1_0:1.1.1.5
	OPENBSD_5_6:1.1.1.5.0.6
	OPENBSD_5_6_BASE:1.1.1.5
	NSD_4_0_3:1.1.1.5
	NSD_4_0_2:1.1.1.5
	OPENBSD_5_5:1.1.1.5.0.4
	OPENBSD_5_5_BASE:1.1.1.5
	NSD_4_0_1:1.1.1.5
	NSD_4_0_0:1.1.1.5
	NSD_3_2_16:1.1.1.4
	OPENBSD_5_4:1.1.1.4.0.6
	OPENBSD_5_4_BASE:1.1.1.4
	OPENBSD_5_3:1.1.1.4.0.4
	OPENBSD_5_3_BASE:1.1.1.4
	NSD_3_2_15:1.1.1.4
	NSD_3_2_14:1.1.1.4
	NSD_3_2_13:1.1.1.4
	OPENBSD_5_2:1.1.1.4.0.2
	OPENBSD_5_2_BASE:1.1.1.4
	NSD_3_2_11:1.1.1.4
	NSD_3_2_10:1.1.1.3
	OPENBSD_5_1_BASE:1.1.1.3
	OPENBSD_5_1:1.1.1.3.0.4
	NSD_3_2_9:1.1.1.3
	OPENBSD_5_0:1.1.1.3.0.2
	OPENBSD_5_0_BASE:1.1.1.3
	NSD_3_2_8:1.1.1.3
	OPENBSD_4_9:1.1.1.2.0.2
	OPENBSD_4_9_BASE:1.1.1.2
	NSD_3_2_6:1.1.1.2
	OPENBSD_4_8:1.1.1.1.0.4
	OPENBSD_4_8_BASE:1.1.1.1
	NSD_3_2_5:1.1.1.1
	OPENBSD_4_7:1.1.1.1.0.2
	OPENBSD_4_7_BASE:1.1.1.1
	NSD_3_2_4:1.1.1.1
	NLNETLABS:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	2010.01.15.19.24.55;	author jakob;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2010.01.15.19.24.55;	author jakob;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2010.08.22.09.21.49;	author jakob;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2011.05.21.18.17.17;	author jakob;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2012.07.09.21.55.07;	author sthen;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2013.11.26.12.50.19;	author sthen;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@/*
 * buffer.c -- generic memory buffer .
 *
 * Copyright (c) 2001-2006, NLnet Labs. All rights reserved.
 *
 * See LICENSE for the license.
 *
 */

#include <config.h>
#include <stdlib.h>
#include <stdio.h>

#include "buffer.h"

static void
buffer_cleanup(void *arg)
{
	buffer_type *buffer = (buffer_type *) arg;
	assert(!buffer->_fixed);
	free(buffer->_data);
}

buffer_type *
buffer_create(region_type *region, size_t capacity)
{
	buffer_type *buffer
		= (buffer_type *) region_alloc(region, sizeof(buffer_type));
	if (!buffer)
		return NULL;
	
	buffer->_data = (uint8_t *) xalloc(capacity);
	buffer->_position = 0;
	buffer->_limit = buffer->_capacity = capacity;
	buffer->_fixed = 0;
	buffer_invariant(buffer);
	
	region_add_cleanup(region, buffer_cleanup, buffer);

	return buffer;
}

void
buffer_create_from(buffer_type *buffer, void *data, size_t size)
{
	assert(data);

	buffer->_position = 0;
	buffer->_limit = buffer->_capacity = size;
	buffer->_data = (uint8_t *) data;
	buffer->_fixed = 1;
	
	buffer_invariant(buffer);
}

void
buffer_clear(buffer_type *buffer)
{
	buffer_invariant(buffer);
	
	buffer->_position = 0;
	buffer->_limit = buffer->_capacity;
}

void
buffer_flip(buffer_type *buffer)
{
	buffer_invariant(buffer);
	
	buffer->_limit = buffer->_position;
	buffer->_position = 0;
}

void
buffer_rewind(buffer_type *buffer)
{
	buffer_invariant(buffer);
	
	buffer->_position = 0;
}

void
buffer_set_capacity(buffer_type *buffer, size_t capacity)
{
	buffer_invariant(buffer);
	assert(buffer->_position <= capacity);
	buffer->_data = (uint8_t *) xrealloc(buffer->_data, capacity);
	buffer->_limit = buffer->_capacity = capacity;
}

void
buffer_reserve(buffer_type *buffer, size_t amount)
{
	buffer_invariant(buffer);
	assert(!buffer->_fixed);
	if (buffer->_capacity < buffer->_position + amount) {
		size_t new_capacity = buffer->_capacity * 3 / 2;
		if (new_capacity < buffer->_position + amount) {
			new_capacity = buffer->_position + amount;
		}
		buffer_set_capacity(buffer, new_capacity);
	}
	buffer->_limit = buffer->_capacity;
}

int
buffer_printf(buffer_type *buffer, const char *format, ...)
{
	va_list args;
	int written;
	size_t remaining;
	
	buffer_invariant(buffer);
	assert(buffer->_limit == buffer->_capacity);

	remaining = buffer_remaining(buffer);
	va_start(args, format);
	written = vsnprintf((char *) buffer_current(buffer), remaining,
			    format, args);
	va_end(args);
	if (written >= 0 && (size_t) written >= remaining) {
		buffer_reserve(buffer, written + 1);
		va_start(args, format);
		written = vsnprintf((char *) buffer_current(buffer),
				    buffer_remaining(buffer),
				    format, args);
		va_end(args);
	}
	buffer->_position += written;
	return written;
}
@


1.1.1.1
log
@NSD v3.2.4
@
text
@@


1.1.1.2
log
@NSD v3.2.6
@
text
@d31 1
a31 1

@


1.1.1.3
log
@NSD v3.2.8
@
text
@d4 1
a4 1
 * Copyright (c) 2001-2011, NLnet Labs. All rights reserved.
@


1.1.1.4
log
@NSD v3.2.11, ok phessler@@
@
text
@d10 1
a10 1
#include "config.h"
@


1.1.1.5
log
@import NSD 4.0.0, tests from Dorian BÃ¼ttner, Patrik Lundin, requested by brad@@
@
text
@d4 1
a4 1
 * Copyright (c) 2001-2006, NLnet Labs. All rights reserved.
@


