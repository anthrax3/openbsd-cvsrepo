head	1.17;
access;
symbols
	OPENBSD_6_1:1.17.0.2
	OPENBSD_6_1_BASE:1.17
	OPENBSD_6_0:1.15.0.2
	OPENBSD_6_0_BASE:1.15
	OPENBSD_5_9:1.14.0.2
	OPENBSD_5_9_BASE:1.14
	NSD_4_1_6:1.1.1.14
	OPENBSD_5_8:1.13.0.4
	OPENBSD_5_8_BASE:1.13
	NSD_4_1_3:1.1.1.13
	OPENBSD_5_7:1.12.0.2
	OPENBSD_5_7_BASE:1.12
	NSD_4_1_1:1.1.1.12
	NSD_4_1_0:1.1.1.11
	OPENBSD_5_6:1.11.0.4
	OPENBSD_5_6_BASE:1.11
	NSD_4_0_3:1.1.1.11
	NSD_4_0_2:1.1.1.11
	OPENBSD_5_5:1.10.0.4
	OPENBSD_5_5_BASE:1.10
	NSD_4_0_1:1.1.1.10
	NSD_4_0_0:1.1.1.9
	NSD_3_2_16:1.1.1.8
	OPENBSD_5_4:1.8.0.4
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.8.0.2
	OPENBSD_5_3_BASE:1.8
	NSD_3_2_15:1.1.1.8
	NSD_3_2_14:1.1.1.7
	NSD_3_2_13:1.1.1.6
	OPENBSD_5_2:1.5.0.2
	OPENBSD_5_2_BASE:1.5
	NSD_3_2_11:1.1.1.5
	NSD_3_2_10:1.1.1.4
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.4
	NSD_3_2_9:1.1.1.4
	OPENBSD_5_0:1.4.0.2
	OPENBSD_5_0_BASE:1.4
	NSD_3_2_8:1.1.1.4
	OPENBSD_4_9:1.3.0.2
	OPENBSD_4_9_BASE:1.3
	NSD_3_2_6:1.1.1.3
	OPENBSD_4_8:1.2.0.4
	OPENBSD_4_8_BASE:1.2
	NSD_3_2_5:1.1.1.2
	OPENBSD_4_7:1.2.0.2
	OPENBSD_4_7_BASE:1.2
	NSD_3_2_4:1.1.1.1
	NLNETLABS:1.1.1;
locks; strict;
comment	@ * @;


1.17
date	2017.02.17.20.04.45;	author florian;	state Exp;
branches;
next	1.16;
commitid	WmSuN5M3Jbe54113;

1.16
date	2016.10.24.09.44.43;	author florian;	state Exp;
branches;
next	1.15;
commitid	g3wASIhTcujU0LFi;

1.15
date	2016.06.24.08.34.03;	author florian;	state Exp;
branches;
next	1.14;
commitid	Z9jVKJJMPmC3zw2t;

1.14
date	2015.11.05.21.21.58;	author sthen;	state Exp;
branches;
next	1.13;
commitid	EVDZ1z8bzmTorwSZ;

1.13
date	2015.07.17.17.36.33;	author sthen;	state Exp;
branches;
next	1.12;
commitid	2WtkENMkCz3GhSbE;

1.12
date	2015.02.03.10.40.01;	author brad;	state Exp;
branches;
next	1.11;
commitid	MI9j0d0LR8Dk9lnd;

1.11
date	2014.03.13.02.09.34;	author brad;	state Exp;
branches;
next	1.10;

1.10
date	2014.02.04.03.07.25;	author brad;	state Exp;
branches;
next	1.9;

1.9
date	2013.11.26.12.53.57;	author sthen;	state Exp;
branches;
next	1.8;

1.8
date	2013.02.18.10.18.39;	author sthen;	state Exp;
branches;
next	1.7;

1.7
date	2012.11.23.20.30.26;	author sthen;	state Exp;
branches;
next	1.6;

1.6
date	2012.08.28.15.15.02;	author sthen;	state Exp;
branches;
next	1.5;

1.5
date	2012.07.09.21.56.41;	author sthen;	state Exp;
branches;
next	1.4;

1.4
date	2011.05.21.18.29.56;	author jakob;	state Exp;
branches;
next	1.3;

1.3
date	2010.08.22.09.24.28;	author jakob;	state Exp;
branches;
next	1.2;

1.2
date	2010.01.17.20.44.59;	author chl;	state Exp;
branches;
next	1.1;

1.1
date	2010.01.15.19.24.50;	author jakob;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2010.01.15.19.24.50;	author jakob;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2010.04.15.20.57.08;	author jakob;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2010.08.22.09.21.47;	author jakob;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2011.05.21.18.17.22;	author jakob;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2012.07.09.21.55.07;	author sthen;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2012.08.28.15.11.41;	author sthen;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2012.11.23.20.29.18;	author sthen;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2013.02.18.10.17.41;	author sthen;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2013.11.26.12.50.10;	author sthen;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2014.02.04.01.54.00;	author brad;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2014.03.13.02.00.22;	author brad;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2015.02.03.10.24.27;	author brad;	state Exp;
branches;
next	1.1.1.13;
commitid	yn8l9RVkmdMVYIfl;

1.1.1.13
date	2015.07.17.17.36.01;	author sthen;	state Exp;
branches;
next	1.1.1.14;
commitid	Jeq5uGP63ff7nS9K;

1.1.1.14
date	2015.11.05.21.21.03;	author sthen;	state Exp;
branches;
next	;
commitid	RXfGmPAh2IZTjnIf;


desc
@@


1.17
log
@Update to 4.1.15.
This contains a local patch to query.c (missed _t conversion) that has
been submitted upstream.
OK sthen
@
text
@/*
 * axfr.c -- generating AXFR responses.
 *
 * Copyright (c) 2001-2006, NLnet Labs. All rights reserved.
 *
 * See LICENSE for the license.
 *
 */

#include "config.h"

#include "axfr.h"
#include "dns.h"
#include "packet.h"
#include "options.h"

#define AXFR_TSIG_SIGN_EVERY_NTH	96	/* tsig sign every N packets. */

query_state_type
query_axfr(struct nsd *nsd, struct query *query)
{
	domain_type *closest_match;
	domain_type *closest_encloser;
	int exact;
	int added;
	uint16_t total_added = 0;

	if (query->axfr_is_done)
		return QUERY_PROCESSED;

	if (query->maxlen > AXFR_MAX_MESSAGE_LEN)
		query->maxlen = AXFR_MAX_MESSAGE_LEN;

	assert(!query_overflow(query));
	/* only keep running values for most packets */
	query->tsig_prepare_it = 0;
	query->tsig_update_it = 1;
	if(query->tsig_sign_it) {
		/* prepare for next updates */
		query->tsig_prepare_it = 1;
		query->tsig_sign_it = 0;
	}

	if (query->axfr_zone == NULL) {
		domain_type* qdomain;
		/* Start AXFR.  */
		STATUP(nsd, raxfr);
		exact = namedb_lookup(nsd->db,
				      query->qname,
				      &closest_match,
				      &closest_encloser);

		qdomain = closest_encloser;
		query->axfr_zone = domain_find_zone(nsd->db, closest_encloser);

		if (!exact
		    || query->axfr_zone == NULL
		    || query->axfr_zone->apex != qdomain
		    || query->axfr_zone->soa_rrset == NULL)
		{
			/* No SOA no transfer */
			RCODE_SET(query->packet, RCODE_NOTAUTH);
			return QUERY_PROCESSED;
		}
		ZTATUP(nsd, query->axfr_zone, raxfr);

		query->axfr_current_domain = qdomain;
		query->axfr_current_rrset = NULL;
		query->axfr_current_rr = 0;
		if(query->tsig.status == TSIG_OK) {
			query->tsig_sign_it = 1; /* sign first packet in stream */
		}

		query_add_compression_domain(query, qdomain, QHEADERSZ);

		assert(query->axfr_zone->soa_rrset->rr_count == 1);
		added = packet_encode_rr(query,
					 query->axfr_zone->apex,
					 &query->axfr_zone->soa_rrset->rrs[0],
					 query->axfr_zone->soa_rrset->rrs[0].ttl);
		if (!added) {
			/* XXX: This should never happen... generate error code? */
			abort();
		}
		++total_added;
	} else {
		/*
		 * Query name and EDNS need not be repeated after the
		 * first response packet.
		 */
		query->edns.status = EDNS_NOT_PRESENT;
		buffer_set_limit(query->packet, QHEADERSZ);
		QDCOUNT_SET(query->packet, 0);
		query_prepare_response(query);
	}

	/* Add zone RRs until answer is full.  */
	while (query->axfr_current_domain != NULL &&
			domain_is_subdomain(query->axfr_current_domain,
					    query->axfr_zone->apex))
	{
		if (!query->axfr_current_rrset) {
			query->axfr_current_rrset = domain_find_any_rrset(
				query->axfr_current_domain,
				query->axfr_zone);
			query->axfr_current_rr = 0;
		}
		while (query->axfr_current_rrset) {
			if (query->axfr_current_rrset != query->axfr_zone->soa_rrset
			    && query->axfr_current_rrset->zone == query->axfr_zone)
			{
				while (query->axfr_current_rr < query->axfr_current_rrset->rr_count) {
					added = packet_encode_rr(
						query,
						query->axfr_current_domain,
						&query->axfr_current_rrset->rrs[query->axfr_current_rr],
						query->axfr_current_rrset->rrs[query->axfr_current_rr].ttl);
					if (!added)
						goto return_answer;
					++total_added;
					++query->axfr_current_rr;
				}
			}

			query->axfr_current_rrset = query->axfr_current_rrset->next;
			query->axfr_current_rr = 0;
		}
		assert(query->axfr_current_domain);
		query->axfr_current_domain
			= domain_next(query->axfr_current_domain);
	}

	/* Add terminating SOA RR.  */
	assert(query->axfr_zone->soa_rrset->rr_count == 1);
	added = packet_encode_rr(query,
				 query->axfr_zone->apex,
				 &query->axfr_zone->soa_rrset->rrs[0],
				 query->axfr_zone->soa_rrset->rrs[0].ttl);
	if (added) {
		++total_added;
		query->tsig_sign_it = 1; /* sign last packet */
		query->axfr_is_done = 1;
	}

return_answer:
	AA_SET(query->packet);
	ANCOUNT_SET(query->packet, total_added);
	NSCOUNT_SET(query->packet, 0);
	ARCOUNT_SET(query->packet, 0);

	/* check if it needs tsig signatures */
	if(query->tsig.status == TSIG_OK) {
		if(query->tsig.updates_since_last_prepare >= AXFR_TSIG_SIGN_EVERY_NTH) {
			query->tsig_sign_it = 1;
		}
	}
	query_clear_compression_tables(query);
	return QUERY_IN_AXFR;
}

/*
 * Answer if this is an AXFR or IXFR query.
 */
query_state_type
answer_axfr_ixfr(struct nsd *nsd, struct query *q)
{
	struct acl_options *acl = NULL;
	/* Is it AXFR? */
	switch (q->qtype) {
	case TYPE_AXFR:
		if (q->tcp) {
			struct zone_options* zone_opt;
			zone_opt = zone_options_find(nsd->options, q->qname);
			if(!zone_opt ||
			   acl_check_incoming(zone_opt->pattern->provide_xfr, q, &acl)==-1)
			{
				if (verbosity >= 2) {
					char a[128];
					addr2str(&q->addr, a, sizeof(a));
					VERBOSITY(2, (LOG_INFO, "axfr for %s from %s refused, %s",
						dname_to_string(q->qname, NULL), a, acl?"blocked":"no acl matches"));
				}
				DEBUG(DEBUG_XFRD,1, (LOG_INFO, "axfr refused, %s",
					acl?"blocked":"no acl matches"));
				if (!zone_opt) {
					RCODE_SET(q->packet, RCODE_NOTAUTH);
				} else {
					RCODE_SET(q->packet, RCODE_REFUSE);
				}
				return QUERY_PROCESSED;
			}
			DEBUG(DEBUG_XFRD,1, (LOG_INFO, "axfr admitted acl %s %s",
				acl->ip_address_spec, acl->key_name?acl->key_name:"NOKEY"));
			if (verbosity >= 1) {
				char a[128];
				addr2str(&q->addr, a, sizeof(a));
				VERBOSITY(1, (LOG_INFO, "%s for %s from %s",
					(q->qtype==TYPE_AXFR?"axfr":"ixfr"),
					dname_to_string(q->qname, NULL), a));
			}
			return query_axfr(nsd, q);
		}
		/** Fallthrough: AXFR over UDP queries are discarded. */
	case TYPE_IXFR:
		RCODE_SET(q->packet, RCODE_IMPL);
		return QUERY_PROCESSED;
	default:
		return QUERY_DISCARDED;
	}
}
@


1.16
log
@Update to 4.1.13
Testing millert, brad and myself.
OK millert@@
@
text
@d167 1
a167 1
	acl_options_t *acl = NULL;
d172 1
a172 1
			zone_options_t* zone_opt;
@


1.15
log
@Update to 4.1.10
Testing by millert@@, sthen@@ and me.
came up with the same diff & OK sthen@@
@
text
@d94 1
a94 1
		query_prepare_response(query, nsd);
@


1.14
log
@merge
@
text
@d98 4
a101 3
	assert(query->axfr_current_domain);

	do {
a131 3
	while (query->axfr_current_domain != NULL &&
			domain_is_subdomain(query->axfr_current_domain,
					    query->axfr_zone->apex));
@


1.13
log
@merge conflicts
@
text
@d94 1
a94 1
		query_prepare_response(query);
d196 7
@


1.12
log
@merge conflicts
@
text
@d179 1
a179 1
				if (verbosity > 0) {
d182 1
a182 1
					VERBOSITY(1, (LOG_INFO, "axfr for zone %s from client %s refused, %s",
@


1.11
log
@merge conflicts
@
text
@d65 1
@


1.10
log
@merge conflicts
@
text
@d54 1
a54 1
		query->axfr_zone = domain_find_zone(closest_encloser);
d58 2
a59 1
		    || query->axfr_zone->apex != qdomain)
@


1.9
log
@merge conflicts
@
text
@d77 2
a78 1
					 &query->axfr_zone->soa_rrset->rrs[0]);
d113 2
a114 1
						&query->axfr_current_rrset->rrs[query->axfr_current_rr]);
d137 2
a138 1
				 &query->axfr_zone->soa_rrset->rrs[0]);
@


1.8
log
@resolve conflicts
@
text
@d4 1
a4 1
 * Copyright (c) 2001-2011, NLnet Labs. All rights reserved.
d45 1
d47 1
d53 1
a53 1
		query->domain = closest_encloser;
d58 1
a58 1
		    || query->axfr_zone->apex != query->domain)
d65 1
a65 1
		query->axfr_current_domain = query->domain;
d72 1
a72 1
		query_add_compression_domain(query, query->domain, QHEADERSZ);
d125 1
a125 1
			= (domain_type *) rbtree_next((rbnode_t *) query->axfr_current_domain);
d127 3
a129 4
	while ((rbnode_t *) query->axfr_current_domain != RBTREE_NULL
			&& dname_is_subdomain(
				domain_dname(query->axfr_current_domain),
				domain_dname(query->axfr_zone->apex)));
d169 2
a170 1
			zone_options_t* zone_opt = zone_options_find(nsd->options, q->qname);
d172 1
a172 1
			   acl_check_incoming(zone_opt->provide_xfr, q, &acl)==-1)
d175 2
a176 6
					char address[128];
					if (addr2ip(q->addr, address, sizeof(address))) {
						DEBUG(DEBUG_XFRD,1, (LOG_INFO,
							"addr2ip failed"));
						strlcpy(address, "[unknown]", sizeof(address));
					}
d178 1
a178 1
						dname_to_string(q->qname, NULL), address, acl?"blocked":"no acl matches"));
@


1.7
log
@resolve conflicts
@
text
@d63 1
a63 2
		query->axfr_current_domain
			= (domain_type *) rbtree_first(nsd->db->domains->names_to_domains);
d95 1
a95 1
	while ((rbnode_t *) query->axfr_current_domain != RBTREE_NULL) {
d125 4
@


1.6
log
@resolve conflicts
@
text
@d192 1
@


1.5
log
@resolve conflicts
@
text
@d160 1
a160 1
	acl_options_t *acl;
d165 1
a165 2
			zone_options_t* zone_opt;
			zone_opt = zone_options_find(nsd->options, q->qname);
@


1.4
log
@resolve conflicts and regen configure using autoconf-2.65
@
text
@d10 1
a10 1
#include <config.h>
d59 1
a59 1
			RCODE_SET(query->packet, RCODE_REFUSE);
d139 1
d182 5
a186 1
				RCODE_SET(q->packet, RCODE_REFUSE);
@


1.3
log
@merge
@
text
@d4 1
a4 1
 * Copyright (c) 2001-2006, NLnet Labs. All rights reserved.
d169 9
a177 6
				char address[128];

				if (addr2ip(q->addr, address, 128)) {
					DEBUG(DEBUG_XFRD,1, (LOG_INFO,
						"addr2ip failed"));
					strlcpy(address, "[unknown]", sizeof(address));
a178 2

				VERBOSITY(1, (LOG_INFO, "axfr for zone %s from client %s refused, %s", dname_to_string(q->qname, NULL), address, acl?"blocked":"no acl matches"));
d180 1
a180 1
						acl?"blocked":"no acl matches"));
@


1.2
log
@strcpy/strncat/sprintf --> strlcpy/strlcat/snprintf

ok jakob@@
@
text
@a34 1
#ifdef TSIG
a42 1
#endif /* TSIG */
a66 1
#ifdef TSIG
a69 1
#endif /* TSIG */
a133 1
#ifdef TSIG
a134 1
#endif /* TSIG */
a142 1
#ifdef TSIG
a148 1
#endif /* TSIG */
@


1.1
log
@Initial revision
@
text
@d182 1
a182 1
					strcpy(address, "[unknown]");
@


1.1.1.1
log
@NSD v3.2.4
@
text
@@


1.1.1.2
log
@NSD v3.2.5
@
text
@d182 1
a182 1
					strlcpy(address, "[unknown]", sizeof(address));
@


1.1.1.3
log
@NSD v3.2.6
@
text
@d35 1
d44 1
d69 1
d73 1
d138 1
d140 1
d149 1
d156 1
@


1.1.1.4
log
@NSD v3.2.8
@
text
@d4 1
a4 1
 * Copyright (c) 2001-2011, NLnet Labs. All rights reserved.
d169 6
a174 9
				if (verbosity > 0) {
					char address[128];
					if (addr2ip(q->addr, address, sizeof(address))) {
						DEBUG(DEBUG_XFRD,1, (LOG_INFO,
							"addr2ip failed"));
						strlcpy(address, "[unknown]", sizeof(address));
					}
					VERBOSITY(1, (LOG_INFO, "axfr for zone %s from client %s refused, %s",
						dname_to_string(q->qname, NULL), address, acl?"blocked":"no acl matches"));
d176 2
d179 1
a179 1
					acl?"blocked":"no acl matches"));
@


1.1.1.5
log
@NSD v3.2.11, ok phessler@@
@
text
@d10 1
a10 1
#include "config.h"
d59 1
a59 1
			RCODE_SET(query->packet, RCODE_NOTAUTH);
a138 1
	AA_SET(query->packet);
d181 1
a181 5
				if (!zone_opt) {
					RCODE_SET(q->packet, RCODE_NOTAUTH);
				} else {
					RCODE_SET(q->packet, RCODE_REFUSE);
				}
@


1.1.1.6
log
@update to NSD 3.2.13

- fix crash in nsd-patch if a zone has been removed from nsd.conf. (difffile.c)

- CVE-2012-2979 DOS fix, this is in optional code which is *not* used with
a standard OpenBSD build. (query.c, server.c)
@
text
@d160 1
a160 1
	acl_options_t *acl = NULL;
d165 2
a166 1
			zone_options_t* zone_opt = zone_options_find(nsd->options, q->qname);
@


1.1.1.7
log
@update to NSD 3.2.14, requested by/ok brad@@
@
text
@a191 1
		/** Fallthrough: AXFR over UDP queries are discarded. */
@


1.1.1.8
log
@Update to NSD 3.2.15, ok brad@@ phessler@@ deraadt@@ also tested by okan@@
@
text
@d63 2
a64 1
		query->axfr_current_domain = query->domain;
d96 1
a96 1
	do {
a125 4
	while ((rbnode_t *) query->axfr_current_domain != RBTREE_NULL
			&& dname_is_subdomain(
				domain_dname(query->axfr_current_domain),
				domain_dname(query->axfr_zone->apex)));
@


1.1.1.9
log
@import NSD 4.0.0, tests from Dorian Büttner, Patrik Lundin, requested by brad@@
@
text
@d4 1
a4 1
 * Copyright (c) 2001-2006, NLnet Labs. All rights reserved.
a44 1
		domain_type* qdomain;
a45 1
		STATUP(nsd, raxfr);
d51 1
a51 1
		qdomain = closest_encloser;
d56 1
a56 1
		    || query->axfr_zone->apex != qdomain)
d63 1
a63 1
		query->axfr_current_domain = qdomain;
d70 1
a70 1
		query_add_compression_domain(query, qdomain, QHEADERSZ);
d123 1
a123 1
			= domain_next(query->axfr_current_domain);
d125 4
a128 3
	while (query->axfr_current_domain != NULL &&
			domain_is_subdomain(query->axfr_current_domain,
					    query->axfr_zone->apex));
d168 1
a168 2
			zone_options_t* zone_opt;
			zone_opt = zone_options_find(nsd->options, q->qname);
d170 1
a170 1
			   acl_check_incoming(zone_opt->pattern->provide_xfr, q, &acl)==-1)
d173 6
a178 2
					char a[128];
					addr2str(&q->addr, a, sizeof(a));
d180 1
a180 1
						dname_to_string(q->qname, NULL), a, acl?"blocked":"no acl matches"));
@


1.1.1.10
log
@update to NSD 4.0.1, ok sthen@@
@
text
@d77 1
a77 2
					 &query->axfr_zone->soa_rrset->rrs[0],
					 query->axfr_zone->soa_rrset->rrs[0].ttl);
d112 1
a112 2
						&query->axfr_current_rrset->rrs[query->axfr_current_rr],
						query->axfr_current_rrset->rrs[query->axfr_current_rr].ttl);
d135 1
a135 2
				 &query->axfr_zone->soa_rrset->rrs[0],
				 query->axfr_zone->soa_rrset->rrs[0].ttl);
@


1.1.1.11
log
@update to NSD 4.0.2, ok sthen@@
@
text
@d54 1
a54 1
		query->axfr_zone = domain_find_zone(nsd->db, closest_encloser);
d58 1
a58 2
		    || query->axfr_zone->apex != qdomain
		    || query->axfr_zone->soa_rrset == NULL)
@


1.1.1.12
log
@update to NSD 4.1.1, ok sthen@@
@
text
@a64 1
		ZTATUP(nsd, query->axfr_zone, raxfr);
@


1.1.1.13
log
@update to NSD 4.1.3, ok florian@@, also tested by brad
@
text
@d179 1
a179 1
				if (verbosity >= 2) {
d182 1
a182 1
					VERBOSITY(2, (LOG_INFO, "axfr for %s from %s refused, %s",
@


1.1.1.14
log
@update to NSD 4.1.6, ok millert@@ florian@@
@
text
@d94 1
a94 1
		query_prepare_response(query, nsd);
a195 7
			if (verbosity >= 1) {
				char a[128];
				addr2str(&q->addr, a, sizeof(a));
				VERBOSITY(1, (LOG_INFO, "%s for %s from %s",
					(q->qtype==TYPE_AXFR?"axfr":"ixfr"),
					dname_to_string(q->qname, NULL), a));
			}
@


