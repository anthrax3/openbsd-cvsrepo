head	1.14;
access;
symbols
	OPENBSD_6_2:1.14.0.6
	OPENBSD_6_2_BASE:1.14
	OPENBSD_6_1:1.14.0.4
	OPENBSD_6_1_BASE:1.14
	OPENBSD_6_0:1.11.0.2
	OPENBSD_6_0_BASE:1.11
	OPENBSD_5_9:1.10.0.4
	OPENBSD_5_9_BASE:1.10
	NSD_4_1_6:1.1.1.8
	OPENBSD_5_8:1.10.0.6
	OPENBSD_5_8_BASE:1.10
	NSD_4_1_3:1.1.1.8
	OPENBSD_5_7:1.10.0.2
	OPENBSD_5_7_BASE:1.10
	NSD_4_1_1:1.1.1.8
	NSD_4_1_0:1.1.1.8
	OPENBSD_5_6:1.9.0.6
	OPENBSD_5_6_BASE:1.9
	NSD_4_0_3:1.1.1.7
	NSD_4_0_2:1.1.1.7
	OPENBSD_5_5:1.9.0.4
	OPENBSD_5_5_BASE:1.9
	NSD_4_0_1:1.1.1.7
	NSD_4_0_0:1.1.1.7
	NSD_3_2_16:1.1.1.6
	OPENBSD_5_4:1.7.0.4
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.2
	OPENBSD_5_3_BASE:1.7
	NSD_3_2_15:1.1.1.6
	NSD_3_2_14:1.1.1.5
	NSD_3_2_13:1.1.1.4
	OPENBSD_5_2:1.5.0.2
	OPENBSD_5_2_BASE:1.5
	NSD_3_2_11:1.1.1.4
	NSD_3_2_10:1.1.1.4
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.2
	NSD_3_2_9:1.1.1.3
	OPENBSD_5_0:1.3.0.2
	OPENBSD_5_0_BASE:1.3
	NSD_3_2_8:1.1.1.2
	OPENBSD_4_9:1.2.0.2
	OPENBSD_4_9_BASE:1.2
	NSD_3_2_6:1.1.1.1
	OPENBSD_4_8:1.1.1.1.0.4
	OPENBSD_4_8_BASE:1.1.1.1
	NSD_3_2_5:1.1.1.1
	OPENBSD_4_7:1.1.1.1.0.2
	OPENBSD_4_7_BASE:1.1.1.1
	NSD_3_2_4:1.1.1.1
	NLNETLABS:1.1.1;
locks; strict;
comment	@ * @;


1.14
date	2017.02.17.20.04.45;	author florian;	state Exp;
branches;
next	1.13;
commitid	WmSuN5M3Jbe54113;

1.13
date	2016.10.24.09.44.43;	author florian;	state Exp;
branches;
next	1.12;
commitid	g3wASIhTcujU0LFi;

1.12
date	2016.08.31.07.31.20;	author florian;	state Exp;
branches;
next	1.11;
commitid	1gMwFuybgH2l617m;

1.11
date	2016.06.24.08.34.03;	author florian;	state Exp;
branches;
next	1.10;
commitid	Z9jVKJJMPmC3zw2t;

1.10
date	2014.09.16.17.01.38;	author brad;	state Exp;
branches;
next	1.9;
commitid	5uD1zN2z8VskC3BN;

1.9
date	2013.11.26.12.53.58;	author sthen;	state Exp;
branches;
next	1.8;

1.8
date	2013.09.04.12.24.35;	author sthen;	state Exp;
branches;
next	1.7;

1.7
date	2013.02.18.10.18.39;	author sthen;	state Exp;
branches;
next	1.6;

1.6
date	2012.11.23.20.30.26;	author sthen;	state Exp;
branches;
next	1.5;

1.5
date	2012.03.02.08.40.57;	author sthen;	state Exp;
branches;
next	1.4;

1.4
date	2012.01.29.11.23.24;	author jakob;	state Exp;
branches;
next	1.3;

1.3
date	2011.05.21.18.29.56;	author jakob;	state Exp;
branches;
next	1.2;

1.2
date	2011.01.27.12.29.14;	author jakob;	state Exp;
branches;
next	1.1;

1.1
date	2010.01.15.19.24.54;	author jakob;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2010.01.15.19.24.54;	author jakob;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2011.05.21.18.17.22;	author jakob;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2012.01.29.11.15.39;	author jakob;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2012.03.02.08.38.54;	author sthen;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2012.11.23.20.29.15;	author sthen;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2013.02.18.10.17.42;	author sthen;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2013.11.26.12.50.13;	author sthen;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2014.09.16.16.53.59;	author brad;	state Exp;
branches;
next	;
commitid	BWSdZeElrpYSRdME;


desc
@@


1.14
log
@Update to 4.1.15.
This contains a local patch to query.c (missed _t conversion) that has
been submitted upstream.
OK sthen
@
text
@/*
 * nsec3.c -- nsec3 handling.
 *
 * Copyright (c) 2001-2006, NLnet Labs. All rights reserved.
 *
 * See LICENSE for the license.
 *
 */
#include "config.h"
#ifdef NSEC3
#include <stdio.h>
#include <stdlib.h>

#include "nsec3.h"
#include "iterated_hash.h"
#include "namedb.h"
#include "nsd.h"
#include "answer.h"
#include "udbzone.h"
#include "options.h"

#define NSEC3_RDATA_BITMAP 5

/* compare nsec3 hashes in nsec3 tree */
static int
cmp_hash_tree(const void* x, const void* y)
{
	const domain_type* a = (const domain_type*)x;
	const domain_type* b = (const domain_type*)y;
	if(!a->nsec3) return (b->nsec3?-1:0);
	if(!b->nsec3) return 1;
	return memcmp(a->nsec3->nsec3_hash, b->nsec3->nsec3_hash,
		NSEC3_HASH_LEN);
}

/* compare nsec3 hashes in nsec3 wc tree */
static int
cmp_wchash_tree(const void* x, const void* y)
{
	const domain_type* a = (const domain_type*)x;
	const domain_type* b = (const domain_type*)y;
	if(!a->nsec3) return (b->nsec3?-1:0);
	if(!b->nsec3) return 1;
	return memcmp(a->nsec3->nsec3_wc_hash, b->nsec3->nsec3_wc_hash,
		NSEC3_HASH_LEN);
}

/* compare nsec3 hashes in nsec3 ds tree */
static int
cmp_dshash_tree(const void* x, const void* y)
{
	const domain_type* a = (const domain_type*)x;
	const domain_type* b = (const domain_type*)y;
	if(!a->nsec3) return (b->nsec3?-1:0);
	if(!b->nsec3) return 1;
	return memcmp(a->nsec3->nsec3_ds_parent_hash,
		b->nsec3->nsec3_ds_parent_hash, NSEC3_HASH_LEN);
}

/* compare base32-encoded nsec3 hashes in nsec3 rr tree, they are
 * stored in the domain name of the node */
static int
cmp_nsec3_tree(const void* x, const void* y)
{
	const domain_type* a = (const domain_type*)x;
	const domain_type* b = (const domain_type*)y;
	/* labelcount + 32long label */
	assert(dname_name(domain_dname_const(a))[0] == 32);
	assert(dname_name(domain_dname_const(b))[0] == 32);
	return memcmp(dname_name(domain_dname_const(a)), dname_name(domain_dname_const(b)), 33);
}

void nsec3_zone_trees_create(struct region* region, zone_type* zone)
{
	if(!zone->nsec3tree)
		zone->nsec3tree = rbtree_create(region, cmp_nsec3_tree);
	if(!zone->hashtree)
		zone->hashtree = rbtree_create(region, cmp_hash_tree);
	if(!zone->wchashtree)
		zone->wchashtree = rbtree_create(region, cmp_wchash_tree);
	if(!zone->dshashtree)
		zone->dshashtree = rbtree_create(region, cmp_dshash_tree);
}

void nsec3_hash_tree_clear(struct zone* zone)
{
	hash_tree_clear(zone->nsec3tree);
	hash_tree_clear(zone->hashtree);
	hash_tree_clear(zone->wchashtree);
	hash_tree_clear(zone->dshashtree);
}

static void
detect_nsec3_params(rr_type* nsec3_apex,
	const unsigned char** salt, int* salt_len, int* iter)
{
	assert(salt && salt_len && iter);
	assert(nsec3_apex);
	*salt_len = rdata_atom_data(nsec3_apex->rdatas[3])[0];
	*salt = (unsigned char*)(rdata_atom_data(nsec3_apex->rdatas[3])+1);
	*iter = read_uint16(rdata_atom_data(nsec3_apex->rdatas[2]));
}

const dname_type *
nsec3_b32_create(region_type* region, zone_type* zone, unsigned char* hash)
{
	const dname_type* dname;
	char b32[SHA_DIGEST_LENGTH*2+1];
	b32_ntop(hash, SHA_DIGEST_LENGTH, b32, sizeof(b32));
	dname=dname_parse(region, b32);
	dname=dname_concatenate(region, dname, domain_dname(zone->apex));
	return dname;
}

void
nsec3_hash_and_store(zone_type* zone, const dname_type* dname, uint8_t* store)
{
	const unsigned char* nsec3_salt = NULL;
	int nsec3_saltlength = 0;
	int nsec3_iterations = 0;

	detect_nsec3_params(zone->nsec3_param, &nsec3_salt,
		&nsec3_saltlength, &nsec3_iterations);
	iterated_hash((unsigned char*)store, nsec3_salt, nsec3_saltlength,
		dname_name(dname), dname->name_size, nsec3_iterations);
}

#define STORE_HASH(x,y) memmove(domain->nsec3->x,y,NSEC3_HASH_LEN); domain->nsec3->have_##x =1;

/** find hash or create it and store it */
static void
nsec3_lookup_hash_and_wc(zone_type* zone, const dname_type* dname,
	domain_type* domain, region_type* tmpregion)
{
	const dname_type* wcard;
	if(domain->nsec3->have_nsec3_hash && domain->nsec3->have_nsec3_wc_hash) {
		return;
	}
	/* lookup failed; disk failure or so */
	nsec3_hash_and_store(zone, dname, domain->nsec3->nsec3_hash);
	domain->nsec3->have_nsec3_hash = 1;
	wcard = dname_parse(tmpregion, "*");
	wcard = dname_concatenate(tmpregion, wcard, dname);
	nsec3_hash_and_store(zone, wcard, domain->nsec3->nsec3_wc_hash);
	domain->nsec3->have_nsec3_wc_hash = 1;
}

static void
nsec3_lookup_hash_ds(zone_type* zone, const dname_type* dname,
	domain_type* domain)
{
	if(domain->nsec3->have_nsec3_ds_parent_hash) {
		return;
	}
	/* lookup failed; disk failure or so */
	nsec3_hash_and_store(zone, dname, domain->nsec3->nsec3_ds_parent_hash);
	domain->nsec3->have_nsec3_ds_parent_hash = 1;
}

static int
nsec3_has_soa(rr_type* rr)
{
	if(rdata_atom_size(rr->rdatas[NSEC3_RDATA_BITMAP]) >= 3 && /* has types in bitmap */
		rdata_atom_data(rr->rdatas[NSEC3_RDATA_BITMAP])[0] == 0 && /* first window = 0, */
		/* [1]: bitmap length must be >= 1 */
		/* [2]: bit[6] = SOA, thus mask first bitmap octet with 0x02 */
		rdata_atom_data(rr->rdatas[NSEC3_RDATA_BITMAP])[2]&0x02) { /* SOA bit set */
		return 1;
	}
	return 0;
}

static rr_type*
check_apex_soa(namedb_type* namedb, zone_type *zone)
{
	uint8_t h[NSEC3_HASH_LEN];
	domain_type* domain;
	const dname_type* hashed_apex, *dname = domain_dname(zone->apex);
	unsigned j;
	rrset_type* nsec3_rrset;
	region_type* tmpregion;

	nsec3_hash_and_store(zone, dname, h);
	tmpregion = region_create(xalloc, free);
	hashed_apex = nsec3_b32_create(tmpregion, zone, h);
	domain = domain_table_find(namedb->domains, hashed_apex);
	if(!domain) {
		log_msg(LOG_ERR, "%s NSEC3PARAM entry has no hash(apex).",
			domain_to_string(zone->apex));
		log_msg(LOG_ERR, "hash(apex)= %s",
			dname_to_string(hashed_apex, NULL));
		region_destroy(tmpregion);
		return NULL;
	}
	nsec3_rrset = domain_find_rrset(domain, zone, TYPE_NSEC3);
	if(!nsec3_rrset) {
		log_msg(LOG_ERR, "%s NSEC3PARAM entry: hash(apex) has no NSEC3 RRset.",
			domain_to_string(zone->apex));
		log_msg(LOG_ERR, "hash(apex)= %s",
			dname_to_string(hashed_apex, NULL));
		region_destroy(tmpregion);
		return NULL;
	}
	for(j=0; j<nsec3_rrset->rr_count; j++) {
		if(nsec3_has_soa(&nsec3_rrset->rrs[j])) {
			region_destroy(tmpregion);
			return &nsec3_rrset->rrs[j];
		}
	}
	log_msg(LOG_ERR, "%s NSEC3PARAM entry: hash(apex) NSEC3 has no SOA flag.",
		domain_to_string(zone->apex));
	log_msg(LOG_ERR, "hash(apex)= %s",
		dname_to_string(hashed_apex, NULL));
	region_destroy(tmpregion);
	return NULL;
}

static struct rr*
udb_zone_find_nsec3param(udb_base* udb, udb_ptr* uz, struct zone* z)
{
	udb_ptr urr;
	unsigned i;
	rrset_type* rrset = domain_find_rrset(z->apex, z, TYPE_NSEC3PARAM);
	if(!rrset) /* no NSEC3PARAM in mem */
		return NULL;
	udb_ptr_new(&urr, udb, &ZONE(uz)->nsec3param);
	if(!urr.data || RR(&urr)->len < 5) {
		/* no NSEC3PARAM in udb */
		udb_ptr_unlink(&urr, udb);
		return NULL;
	}
	/* find matching NSEC3PARAM RR in memory */
	for(i=0; i<rrset->rr_count; i++) {
		/* if this RR matches the udb RR then we are done */
		rdata_atom_type* rd = rrset->rrs[i].rdatas;
		if(rrset->rrs[i].rdata_count < 4) continue;
		if(RR(&urr)->wire[0] == rdata_atom_data(rd[0])[0] && /*alg*/
		   RR(&urr)->wire[1] == rdata_atom_data(rd[1])[0] && /*flg*/
		   RR(&urr)->wire[2] == rdata_atom_data(rd[2])[0] && /*iter*/
		   RR(&urr)->wire[3] == rdata_atom_data(rd[2])[1] &&
		   RR(&urr)->wire[4] == rdata_atom_data(rd[3])[0] && /*slen*/
		   RR(&urr)->len >= 5 + RR(&urr)->wire[4] &&
		   memcmp(RR(&urr)->wire+5, rdata_atom_data(rd[3])+1,
			rdata_atom_data(rd[3])[0]) == 0) {
			udb_ptr_unlink(&urr, udb);
			return &rrset->rrs[i];
		}
	}
	udb_ptr_unlink(&urr, udb);
	return NULL;
}

static struct rr*
db_find_nsec3param(struct zone* z, struct rr* avoid_rr)
{
	unsigned i;
	rrset_type* rrset = domain_find_rrset(z->apex, z, TYPE_NSEC3PARAM);
	if(!rrset) /* no NSEC3PARAM in mem */
		return NULL;
	/* find first nsec3param we can support (SHA1, no flags) */
	for(i=0; i<rrset->rr_count; i++) {
		rdata_atom_type* rd = rrset->rrs[i].rdatas;
		/* do not use the RR that is going to be deleted (in IXFR) */
		if(&rrset->rrs[i] == avoid_rr) continue;
		if(rrset->rrs[i].rdata_count < 4) continue;
		if(rdata_atom_data(rd[0])[0] == NSEC3_SHA1_HASH &&
			rdata_atom_data(rd[1])[0] == 0) {
			if(2 <= verbosity) {
				char str[MAX_RDLENGTH*2+16];
				char* p;
				p = str+snprintf(str, sizeof(str), "%u %u %u ",
					(unsigned)rdata_atom_data(rd[0])[0],
					(unsigned)rdata_atom_data(rd[1])[0],
					(unsigned)read_uint16(rdata_atom_data(rd[2])));
				if(rdata_atom_data(rd[3])[0] == 0)
					*p++ = '-';
				else {
					p += hex_ntop(rdata_atom_data(rd[3])+1,
						rdata_atom_data(rd[3])[0], p,
						sizeof(str)-strlen(str)-1);
				}
				*p = 0;
				VERBOSITY(2, (LOG_INFO, "rehash of zone %s with parameters %s",
					domain_to_string(z->apex), str));
			}
			return &rrset->rrs[i];
		}
	}
	return NULL;
}

void
nsec3_find_zone_param(struct namedb* db, struct zone* zone, udb_ptr* z,
	struct rr* avoid_rr)
{
	/* get nsec3param RR from udb */
	if(db->udb)
		zone->nsec3_param = udb_zone_find_nsec3param(db->udb, z, zone);
	/* no db, get from memory, avoid using the rr that is going to be
	 * deleted, avoid_rr */
	else	zone->nsec3_param = db_find_nsec3param(zone, avoid_rr);
}

/* check params ok for one RR */
static int
nsec3_rdata_params_ok(rdata_atom_type* prd, rdata_atom_type* rd)
{
	return (rdata_atom_data(rd[0])[0] ==
		rdata_atom_data(prd[0])[0] && /* hash algo */
	   rdata_atom_data(rd[2])[0] ==
		rdata_atom_data(prd[2])[0] && /* iterations 0 */
	   rdata_atom_data(rd[2])[1] ==
		rdata_atom_data(prd[2])[1] && /* iterations 1 */
	   rdata_atom_data(rd[3])[0] ==
		rdata_atom_data(prd[3])[0] && /* salt length */
	   memcmp(rdata_atom_data(rd[3])+1,
		rdata_atom_data(prd[3])+1, rdata_atom_data(rd[3])[0])
		== 0 );
}

int
nsec3_rr_uses_params(rr_type* rr, zone_type* zone)
{
	if(!rr || rr->rdata_count < 4)
		return 0;
	return nsec3_rdata_params_ok(zone->nsec3_param->rdatas, rr->rdatas);
}

int
nsec3_in_chain_count(domain_type* domain, zone_type* zone)
{
	rrset_type* rrset = domain_find_rrset(domain, zone, TYPE_NSEC3);
	unsigned i;
	int count = 0;
	if(!rrset || !zone->nsec3_param)
		return 0; /* no NSEC3s, none in the chain */
	for(i=0; i<rrset->rr_count; i++) {
		if(nsec3_rr_uses_params(&rrset->rrs[i], zone))
			count++;
	}
	return count;
}

struct domain*
nsec3_chain_find_prev(struct zone* zone, struct domain* domain)
{
	if(domain->nsec3 && domain->nsec3->nsec3_node.key) {
		/* see if there is a prev */
		rbnode_type* r = rbtree_previous(&domain->nsec3->nsec3_node);
		if(r != RBTREE_NULL) {
			/* found a previous, which is not the root-node in
			 * the prehash tree (and thus points to the tree) */
			return (domain_type*)r->key;
		}
	}
	if(zone->nsec3_last)
		return zone->nsec3_last;
	return NULL;
}

void
nsec3_clear_precompile(struct namedb* db, zone_type* zone)
{
	domain_type* walk;
	/* clear prehash items (there must not be items for other zones) */
	prehash_clear(db->domains);
	/* clear trees */
	hash_tree_clear(zone->nsec3tree);
	hash_tree_clear(zone->hashtree);
	hash_tree_clear(zone->wchashtree);
	hash_tree_clear(zone->dshashtree);
	/* wipe hashes */

	/* wipe precompile */
	walk = zone->apex;
	while(walk && domain_is_subdomain(walk, zone->apex)) {
		if(walk->nsec3) {
			if(nsec3_domain_part_of_zone(walk, zone)) {
				walk->nsec3->nsec3_node.key = NULL;
				walk->nsec3->nsec3_cover = NULL;
				walk->nsec3->nsec3_wcard_child_cover = NULL;
				walk->nsec3->nsec3_is_exact = 0;
				walk->nsec3->have_nsec3_hash = 0;
				walk->nsec3->have_nsec3_wc_hash = 0;
				walk->nsec3->hash_node.key = NULL;
				walk->nsec3->wchash_node.key = NULL;
			}
			if(!walk->parent ||
				nsec3_domain_part_of_zone(walk->parent, zone)) {
				walk->nsec3->nsec3_ds_parent_cover = NULL;
				walk->nsec3->nsec3_ds_parent_is_exact = 0;
				walk->nsec3->have_nsec3_ds_parent_hash = 0;
				walk->nsec3->dshash_node.key = NULL;
			}
		}
		walk = domain_next(walk);
	}
	zone->nsec3_last = NULL;
}

/* see if domain name is part of (existing names in) the nsec3 zone */
int
nsec3_domain_part_of_zone(domain_type* d, zone_type* z)
{
	while(d) {
		if(d->is_apex)
			return (z->apex == d); /* zonecut, if right zone*/
		d = d->parent;
	}
	return 0;
}

/* condition when a domain is precompiled */
int
nsec3_condition_hash(domain_type* d, zone_type* z)
{
	return d->is_existing && !domain_has_only_NSEC3(d, z) &&
		nsec3_domain_part_of_zone(d, z) && !domain_is_glue(d, z);
}

/* condition when a domain is ds precompiled */
int
nsec3_condition_dshash(domain_type* d, zone_type* z)
{
	return d->is_existing && !domain_has_only_NSEC3(d, z) &&
		(domain_find_rrset(d, z, TYPE_DS) ||
		domain_find_rrset(d, z, TYPE_NS)) && d != z->apex;
}

zone_type*
nsec3_tree_zone(namedb_type* db, domain_type* d)
{
	/* see nsec3_domain_part_of_zone; domains part of zone that has
	 * apex above them */
	/* this does not use the rrset->zone pointer because there may be
	 * no rrsets left at apex (no SOA), e.g. during IXFR */
	while(d) {
		if(d->is_apex) {
			/* we can try a SOA if its present (faster than tree)*/
			/* DNSKEY and NSEC3PARAM are also good indicators */
			rrset_type *rrset;
			for (rrset = d->rrsets; rrset; rrset = rrset->next)
				if (rrset_rrtype(rrset) == TYPE_SOA ||
					rrset_rrtype(rrset) == TYPE_DNSKEY ||
					rrset_rrtype(rrset) == TYPE_NSEC3PARAM)
					return rrset->zone;
			return namedb_find_zone(db, domain_dname(d));
		}
		d = d->parent;
	}
	return NULL;
}

zone_type*
nsec3_tree_dszone(namedb_type* db, domain_type* d)
{
	/* the DStree does not contain nodes with d==z->apex */
	if(d->is_apex)
		d = d->parent;
	return nsec3_tree_zone(db, d);
}

int
nsec3_find_cover(zone_type* zone, uint8_t* hash, size_t hashlen,
	domain_type** result)
{
	rbnode_type* r = NULL;
	int exact;
	domain_type d;
	uint8_t n[48];

	/* nsec3tree is sorted by b32 encoded domain name of the NSEC3 */
	b32_ntop(hash, hashlen, (char*)(n+5), sizeof(n)-5);
#ifdef USE_RADIX_TREE
	d.dname = (dname_type*)n;
#else
	d.node.key = n;
#endif
	n[0] = 34; /* name_size */
	n[1] = 2; /* label_count */
	n[2] = 0; /* label_offset[0] */
	n[3] = 0; /* label_offset[1] */
	n[4] = 32; /* label-size[0] */

	assert(result);
	assert(zone->nsec3_param && zone->nsec3tree);

	exact = rbtree_find_less_equal(zone->nsec3tree, &d, &r);
	if(r) {
		*result = (domain_type*)r->key;
	} else {
		*result = zone->nsec3_last;
	}
	return exact;
}

void
nsec3_precompile_domain(struct namedb* db, struct domain* domain,
	struct zone* zone, region_type* tmpregion)
{
	domain_type* result = 0;
	int exact;
	allocate_domain_nsec3(db->domains, domain);

	/* hash it */
	nsec3_lookup_hash_and_wc(zone, domain_dname(domain), domain, tmpregion);

	/* add into tree */
	zone_add_domain_in_hash_tree(db->region, &zone->hashtree,
		cmp_hash_tree, domain, &domain->nsec3->hash_node);
	zone_add_domain_in_hash_tree(db->region, &zone->wchashtree,
		cmp_wchash_tree, domain, &domain->nsec3->wchash_node);

	/* lookup in tree cover ptr (or exact) */
	exact = nsec3_find_cover(zone, domain->nsec3->nsec3_hash,
		sizeof(domain->nsec3->nsec3_hash), &result);
	domain->nsec3->nsec3_cover = result;
	if(exact)
		domain->nsec3->nsec3_is_exact = 1;
	else	domain->nsec3->nsec3_is_exact = 0;

	/* find cover for *.domain for wildcard denial */
	exact = nsec3_find_cover(zone, domain->nsec3->nsec3_wc_hash,
		sizeof(domain->nsec3->nsec3_wc_hash), &result);
	domain->nsec3->nsec3_wcard_child_cover = result;
}

void
nsec3_precompile_domain_ds(struct namedb* db, struct domain* domain,
	struct zone* zone)
{
	domain_type* result = 0;
	int exact;
	allocate_domain_nsec3(db->domains, domain);

	/* hash it : it could have different hash parameters then the
	   other hash for this domain name */
	nsec3_lookup_hash_ds(zone, domain_dname(domain), domain);
	/* lookup in tree cover ptr (or exact) */
	exact = nsec3_find_cover(zone, domain->nsec3->nsec3_ds_parent_hash,
		sizeof(domain->nsec3->nsec3_ds_parent_hash), &result);
	if(exact)
		domain->nsec3->nsec3_ds_parent_is_exact = 1;
	else 	domain->nsec3->nsec3_ds_parent_is_exact = 0;
	domain->nsec3->nsec3_ds_parent_cover = result;
	/* add into tree */
	zone_add_domain_in_hash_tree(db->region, &zone->dshashtree,
		cmp_dshash_tree, domain, &domain->nsec3->dshash_node);
}

static void
parse_nsec3_name(const dname_type* dname, uint8_t* hash, size_t buflen)
{
	/* first label must be the match, */
	size_t lablen = (buflen-1) * 8 / 5;
	const uint8_t* wire = dname_name(dname);
	assert(lablen == 32 && buflen == NSEC3_HASH_LEN+1);
	/* labels of length 32 for SHA1, and must have space+1 for convert */
	if(wire[0] != lablen) {
		/* not NSEC3 */
		memset(hash, 0, buflen);
		return;
	}
	(void)b32_pton((char*)wire+1, hash, buflen);
}

void
nsec3_precompile_nsec3rr(namedb_type* db, struct domain* domain,
	struct zone* zone)
{
	allocate_domain_nsec3(db->domains, domain);
	/* add into nsec3tree */
	zone_add_domain_in_hash_tree(db->region, &zone->nsec3tree,
		cmp_nsec3_tree, domain, &domain->nsec3->nsec3_node);
	/* fixup the last in the zone */
	if(rbtree_last(zone->nsec3tree)->key == domain) {
		zone->nsec3_last = domain;
	}
}

void
nsec3_precompile_newparam(namedb_type* db, zone_type* zone)
{
	region_type* tmpregion = region_create(xalloc, free);
	domain_type* walk;
	time_t s = time(NULL);
	unsigned long n = 0, c = 0;

	/* add nsec3s of chain to nsec3tree */
	for(walk=zone->apex; walk && domain_is_subdomain(walk, zone->apex);
		walk = domain_next(walk)) {
		n++;
		if(nsec3_in_chain_count(walk, zone) != 0) {
			nsec3_precompile_nsec3rr(db, walk, zone);
		}
	}
	/* hash and precompile zone */
	for(walk=zone->apex; walk && domain_is_subdomain(walk, zone->apex);
		walk = domain_next(walk)) {
		if(nsec3_condition_hash(walk, zone)) {
			nsec3_precompile_domain(db, walk, zone, tmpregion);
			region_free_all(tmpregion);
		}
		if(nsec3_condition_dshash(walk, zone))
			nsec3_precompile_domain_ds(db, walk, zone);
		if(++c % ZONEC_PCT_COUNT == 0 && time(NULL) > s + ZONEC_PCT_TIME) {
			s = time(NULL);
			VERBOSITY(1, (LOG_INFO, "nsec3 %s %d %%",
				zone->opts->name,
				(int)(c*((unsigned long)100)/n)));
		}
	}
	region_destroy(tmpregion);
}

void
prehash_zone_complete(struct namedb* db, struct zone* zone)
{
	udb_ptr udbz;

	/* robust clear it */
	nsec3_clear_precompile(db, zone);
	/* find zone settings */

	assert(db && zone);
	if(db->udb) {
		if(!udb_zone_search(db->udb, &udbz, dname_name(domain_dname(
			zone->apex)), domain_dname(zone->apex)->name_size)) {
			udb_ptr_init(&udbz, db->udb); /* zero the ptr */
		}
	}
	nsec3_find_zone_param(db, zone, &udbz, NULL);
	if(!zone->nsec3_param || !check_apex_soa(db, zone)) {
		zone->nsec3_param = NULL;
		zone->nsec3_last = NULL;
		if(db->udb)
			udb_ptr_unlink(&udbz, db->udb);
		return;
	}
	if(db->udb)
		udb_ptr_unlink(&udbz, db->udb);
	nsec3_precompile_newparam(db, zone);
}

static void
init_lookup_key_hash_tree(domain_type* d, uint8_t* hash)
{ memcpy(d->nsec3->nsec3_hash, hash, NSEC3_HASH_LEN); }

static void
init_lookup_key_wc_tree(domain_type* d, uint8_t* hash)
{ memcpy(d->nsec3->nsec3_wc_hash, hash, NSEC3_HASH_LEN); }

static void
init_lookup_key_ds_tree(domain_type* d, uint8_t* hash)
{ memcpy(d->nsec3->nsec3_ds_parent_hash, hash, NSEC3_HASH_LEN); }

/* find first in the tree and true if the first to process it */
static int
process_first(rbtree_type* tree, uint8_t* hash, rbnode_type** p,
	void (*init)(domain_type*, uint8_t*))
{
	domain_type d;
	struct nsec3_domain_data n;
	if(!tree) {
		*p = RBTREE_NULL;
		return 0;
	}
	d.nsec3 = &n;
	init(&d, hash);
	if(rbtree_find_less_equal(tree, &d, p)) {
		/* found an exact match */
		return 1;
	}
	if(!*p) /* before first, go from first */
		*p = rbtree_first(tree);
	/* the inexact, smaller, match we found, does not itself need to
	 * be edited */
	else
		*p = rbtree_next(*p); /* if this becomes NULL, nothing to do */
	return 0;
}

/* set end pointer if possible */
static void
process_end(rbtree_type* tree, uint8_t* hash, rbnode_type** p,
	void (*init)(domain_type*, uint8_t*))
{
	domain_type d;
	struct nsec3_domain_data n;
	if(!tree) {
		*p = RBTREE_NULL;
		return;
	}
	d.nsec3 = &n;
	init(&d, hash);
	if(rbtree_find_less_equal(tree, &d, p)) {
		/* an exact match, fine, because this one does not get
		 * processed */
		return;
	}
	/* inexact element, but if NULL, until first element in tree */
	if(!*p) {
		*p = rbtree_first(tree);
		return;
	}
	/* inexact match, use next element, if possible, the smaller
	 * element is part of the range */
	*p = rbtree_next(*p);
	/* if next returns null, we go until the end of the tree */
}

/* prehash domains in hash range start to end */
static void
process_range(zone_type* zone, domain_type* start,
	domain_type* end, domain_type* nsec3)
{
	/* start NULL means from first in tree */
	/* end NULL means to last in tree */
	rbnode_type *p = RBTREE_NULL, *pwc = RBTREE_NULL, *pds = RBTREE_NULL;
	rbnode_type *p_end = RBTREE_NULL, *pwc_end = RBTREE_NULL, *pds_end = RBTREE_NULL;
	/* because the nodes are on the prehashlist, the domain->nsec3 is
	 * already allocated, and we need not allocate it here */
	/* set start */
	if(start) {
		uint8_t hash[NSEC3_HASH_LEN+1];
		parse_nsec3_name(domain_dname(start), hash, sizeof(hash));
		/* if exact match on first, set is_exact */
		if(process_first(zone->hashtree, hash, &p, init_lookup_key_hash_tree)) {
			((domain_type*)(p->key))->nsec3->nsec3_cover = nsec3;
			((domain_type*)(p->key))->nsec3->nsec3_is_exact = 1;
			p = rbtree_next(p);
		}
		(void)process_first(zone->wchashtree, hash, &pwc, init_lookup_key_wc_tree);
		if(process_first(zone->dshashtree, hash, &pds, init_lookup_key_ds_tree)){
			((domain_type*)(pds->key))->nsec3->
				nsec3_ds_parent_cover = nsec3;
			((domain_type*)(pds->key))->nsec3->
				nsec3_ds_parent_is_exact = 1;
			pds = rbtree_next(pds);
		}
	} else {
		if(zone->hashtree)
			p = rbtree_first(zone->hashtree);
		if(zone->wchashtree)
			pwc = rbtree_first(zone->wchashtree);
		if(zone->dshashtree)
			pds = rbtree_first(zone->dshashtree);
	}
	/* set end */
	if(end) {
		uint8_t hash[NSEC3_HASH_LEN+1];
		parse_nsec3_name(domain_dname(end), hash, sizeof(hash));
		process_end(zone->hashtree, hash, &p_end, init_lookup_key_hash_tree);
		process_end(zone->wchashtree, hash, &pwc_end, init_lookup_key_wc_tree);
		process_end(zone->dshashtree, hash, &pds_end, init_lookup_key_ds_tree);
	}

	/* precompile */
	while(p != RBTREE_NULL && p != p_end) {
		((domain_type*)(p->key))->nsec3->nsec3_cover = nsec3;
		((domain_type*)(p->key))->nsec3->nsec3_is_exact = 0;
		p = rbtree_next(p);
	}
	while(pwc != RBTREE_NULL && pwc != pwc_end) {
		((domain_type*)(pwc->key))->nsec3->
			nsec3_wcard_child_cover = nsec3;
		pwc = rbtree_next(pwc);
	}
	while(pds != RBTREE_NULL && pds != pds_end) {
		((domain_type*)(pds->key))->nsec3->
			nsec3_ds_parent_cover = nsec3;
		((domain_type*)(pds->key))->nsec3->
			nsec3_ds_parent_is_exact = 0;
		pds = rbtree_next(pds);
	}
}

/* prehash a domain from the prehash list */
static void
process_prehash_domain(domain_type* domain, zone_type* zone)
{
	/* in the hashtree, wchashtree, dshashtree walk through to next NSEC3
	 * and set precompile pointers to point to this domain (or is_exact),
	 * the first domain can be is_exact. If it is the last NSEC3, also
	 * process the initial part (before the first) */
	rbnode_type* nx;

	/* this domain is part of the prehash list and therefore the
	 * domain->nsec3 is allocated and need not be allocated here */
	assert(domain->nsec3 && domain->nsec3->nsec3_node.key);
	nx = rbtree_next(&domain->nsec3->nsec3_node);
	if(nx != RBTREE_NULL) {
		/* process until next nsec3 */
		domain_type* end = (domain_type*)nx->key;
		process_range(zone, domain, end, domain);
	} else {
		/* first is root, but then comes the first nsec3 */
		domain_type* first = (domain_type*)(rbtree_first(
			zone->nsec3tree)->key);
		/* last in zone */
		process_range(zone, domain, NULL, domain);
		/* also process before first in zone */
		process_range(zone, NULL, first, domain);
	}
}

void prehash_zone(struct namedb* db, struct zone* zone)
{
	domain_type* d;
	if(!zone->nsec3_param) {
		prehash_clear(db->domains);
		return;
	}
	/* process prehash list */
	for(d = db->domains->prehash_list; d; d = d->nsec3->prehash_next) {
		process_prehash_domain(d, zone);
	}
	/* clear prehash list */
	prehash_clear(db->domains);

	if(!check_apex_soa(db, zone)) {
		zone->nsec3_param = NULL;
		zone->nsec3_last = NULL;
	}
}

/* add the NSEC3 rrset to the query answer at the given domain */
static void
nsec3_add_rrset(struct query* query, struct answer* answer,
	rr_section_type section, struct domain* domain)
{
	if(domain) {
		rrset_type* rrset = domain_find_rrset(domain, query->zone, TYPE_NSEC3);
		if(rrset)
			answer_add_rrset(answer, section, domain, rrset);
	}
}

/* this routine does hashing at query-time. slow. */
static void
nsec3_add_nonexist_proof(struct query* query, struct answer* answer,
        struct domain* encloser, const dname_type* qname)
{
	uint8_t hash[NSEC3_HASH_LEN];
	const dname_type* to_prove;
	domain_type* cover=0;
	assert(encloser);
	/* if query=a.b.c.d encloser=c.d. then proof needed for b.c.d. */
	/* if query=a.b.c.d encloser=*.c.d. then proof needed for b.c.d. */
	to_prove = dname_partial_copy(query->region, qname,
		dname_label_match_count(qname, domain_dname(encloser))+1);
	/* generate proof that one label below closest encloser does not exist */
	nsec3_hash_and_store(query->zone, to_prove, hash);
	if(nsec3_find_cover(query->zone, hash, sizeof(hash), &cover))
	{
		/* exact match, hash collision */
		/* the hashed name of the query corresponds to an existing name. */
		VERBOSITY(3, (LOG_ERR, "nsec3 hash collision for name=%s",
			dname_to_string(to_prove, NULL)));
		RCODE_SET(query->packet, RCODE_SERVFAIL);
		return;
	}
	else
	{
		/* cover proves the qname does not exist */
		nsec3_add_rrset(query, answer, AUTHORITY_SECTION, cover);
	}
}

static void
nsec3_add_closest_encloser_proof(
	struct query* query, struct answer* answer,
	struct domain* closest_encloser, const dname_type* qname)
{
	if(!closest_encloser)
		return;
	/* prove that below closest encloser nothing exists */
	nsec3_add_nonexist_proof(query, answer, closest_encloser, qname);
	/* proof that closest encloser exists */
	if(closest_encloser->nsec3 && closest_encloser->nsec3->nsec3_is_exact)
		nsec3_add_rrset(query, answer, AUTHORITY_SECTION,
			closest_encloser->nsec3->nsec3_cover);
}

void
nsec3_answer_wildcard(struct query *query, struct answer *answer,
        struct domain *wildcard, const dname_type* qname)
{
	if(!wildcard)
		return;
	if(!query->zone->nsec3_param)
		return;
	nsec3_add_nonexist_proof(query, answer, wildcard, qname);
}

static void
nsec3_add_ds_proof(struct query *query, struct answer *answer,
	struct domain *domain, int delegpt)
{
	/* assert we are above the zone cut */
	assert(domain != query->zone->apex);
	if(domain->nsec3 && domain->nsec3->nsec3_ds_parent_is_exact) {
		/* use NSEC3 record from above the zone cut. */
		nsec3_add_rrset(query, answer, AUTHORITY_SECTION,
			domain->nsec3->nsec3_ds_parent_cover);
	} else if (!delegpt && domain->nsec3 && domain->nsec3->nsec3_is_exact
		&& nsec3_domain_part_of_zone(domain->nsec3->nsec3_cover,
		query->zone)) {
		nsec3_add_rrset(query, answer, AUTHORITY_SECTION,
			domain->nsec3->nsec3_cover);
	} else {
		/* prove closest provable encloser */
		domain_type* par = domain->parent;
		domain_type* prev_par = 0;

		while(par && (!par->nsec3 || !par->nsec3->nsec3_is_exact))
		{
			prev_par = par;
			par = par->parent;
		}
		assert(par); /* parent zone apex must be provable, thus this ends */
		if(!par->nsec3) return;
		nsec3_add_rrset(query, answer, AUTHORITY_SECTION,
			par->nsec3->nsec3_cover);
		/* we took several steps to go to the provable parent, so
		   the one below it has no exact nsec3, disprove it.
		   disprove is easy, it has a prehashed cover ptr. */
		if(prev_par && prev_par->nsec3) {
			assert(prev_par != domain &&
				!prev_par->nsec3->nsec3_is_exact);
			nsec3_add_rrset(query, answer, AUTHORITY_SECTION,
				prev_par->nsec3->nsec3_cover);
		}
		/* add optout range from parent zone */
		/* note: no check of optout bit, resolver checks it */
		if(domain->nsec3)
			nsec3_add_rrset(query, answer, AUTHORITY_SECTION,
				domain->nsec3->nsec3_ds_parent_cover);
	}
}

void
nsec3_answer_nodata(struct query* query, struct answer* answer,
	struct domain* original)
{
	if(!query->zone->nsec3_param)
		return;
	/* nodata when asking for secure delegation */
	if(query->qtype == TYPE_DS)
	{
		if(original == query->zone->apex) {
			/* DS at zone apex, but server not authoritative for parent zone */
			/* so answer at the child zone level */
			if(original->nsec3 && original->nsec3->nsec3_is_exact)
				nsec3_add_rrset(query, answer, AUTHORITY_SECTION,
					original->nsec3->nsec3_cover);
			return;
		}
		/* query->zone must be the parent zone */
		nsec3_add_ds_proof(query, answer, original, 0);
	}
	/* the nodata is result from a wildcard match */
	else if (original==original->wildcard_child_closest_match
		&& label_is_wildcard(dname_name(domain_dname(original)))) {
		/* denial for wildcard is already there */

		/* add parent proof to have a closest encloser proof for wildcard parent */
		/* in other words: nsec3 matching closest encloser */
		if(original->parent && original->parent->nsec3 &&
			original->parent->nsec3->nsec3_is_exact)
			nsec3_add_rrset(query, answer, AUTHORITY_SECTION,
				original->parent->nsec3->nsec3_cover);
		/* proof for wildcard itself */
		/* in other words: nsec3 matching source of synthesis */
		if(original->nsec3)
			nsec3_add_rrset(query, answer, AUTHORITY_SECTION,
				original->nsec3->nsec3_cover);
	}
	else {	/* add nsec3 to prove rrset does not exist */
		if(original->nsec3) {
			if(!original->nsec3->nsec3_is_exact) {
				/* go up to an existing parent */
				while(original->parent && original->parent->nsec3 && !original->parent->nsec3->nsec3_is_exact)
					original = original->parent;
			}
			nsec3_add_rrset(query, answer, AUTHORITY_SECTION,
				original->nsec3->nsec3_cover);
			if(!original->nsec3->nsec3_is_exact) {
				if(original->parent && original->parent->nsec3 && original->parent->nsec3->nsec3_is_exact)
				    nsec3_add_rrset(query, answer, AUTHORITY_SECTION,
					original->parent->nsec3->nsec3_cover);

			}
		}
	}
}

void
nsec3_answer_delegation(struct query *query, struct answer *answer)
{
	if(!query->zone->nsec3_param)
		return;
	nsec3_add_ds_proof(query, answer, query->delegation_domain, 1);
}

int
domain_has_only_NSEC3(struct domain* domain, struct zone* zone)
{
	/* check for only NSEC3/RRSIG */
	rrset_type* rrset = domain->rrsets;
	int nsec3_seen = 0;
	while(rrset)
	{
		if(!zone || rrset->zone == zone)
		{
			if(rrset->rrs[0].type == TYPE_NSEC3)
				nsec3_seen = 1;
			else if(rrset->rrs[0].type != TYPE_RRSIG)
				return 0;
		}
		rrset = rrset->next;
	}
	return nsec3_seen;
}

void
nsec3_answer_authoritative(struct domain** match, struct query *query,
	struct answer *answer, struct domain* closest_encloser,
	const dname_type* qname)
{
	if(!query->zone->nsec3_param)
		return;
	assert(match);
	/* there is a match, this has 1 RRset, which is NSEC3, but qtype is not. */
        /* !is_existing: no RR types exist at the QNAME, nor at any descendant of QNAME */
	if(*match && !(*match)->is_existing &&
#if 0
		query->qtype != TYPE_NSEC3 &&
#endif
		domain_has_only_NSEC3(*match, query->zone))
	{
		/* act as if the NSEC3 domain did not exist, name error */
		*match = 0;
		/* all nsec3s are directly below the apex, that is closest encloser */
		if(query->zone->apex->nsec3 &&
			query->zone->apex->nsec3->nsec3_is_exact)
			nsec3_add_rrset(query, answer, AUTHORITY_SECTION,
				query->zone->apex->nsec3->nsec3_cover);
		/* disprove the nsec3 record. */
		if(closest_encloser->nsec3)
			nsec3_add_rrset(query, answer, AUTHORITY_SECTION, closest_encloser->nsec3->nsec3_cover);
		/* disprove a wildcard */
		if(query->zone->apex->nsec3)
			nsec3_add_rrset(query, answer, AUTHORITY_SECTION,
				query->zone->apex->nsec3->nsec3_wcard_child_cover);
		if (domain_wildcard_child(query->zone->apex)) {
			/* wildcard exists below the domain */
			/* wildcard and nsec3 domain clash. server failure. */
			RCODE_SET(query->packet, RCODE_SERVFAIL);
		}
		return;
	}
	else if(*match && (*match)->is_existing &&
#if 0
		query->qtype != TYPE_NSEC3 &&
#endif
		(domain_has_only_NSEC3(*match, query->zone) ||
		!domain_find_any_rrset(*match, query->zone)))
	{
		/* this looks like a NSEC3 domain, but is actually an empty non-terminal. */
		nsec3_answer_nodata(query, answer, *match);
		return;
	}
	if(!*match) {
		/* name error, domain does not exist */
		nsec3_add_closest_encloser_proof(query, answer, closest_encloser,
			qname);
		if(closest_encloser->nsec3)
			nsec3_add_rrset(query, answer, AUTHORITY_SECTION,
				closest_encloser->nsec3->nsec3_wcard_child_cover);
	}
}

#endif /* NSEC3 */
@


1.13
log
@Update to 4.1.13
Testing millert, brad and myself.
OK millert@@
@
text
@d349 1
a349 1
		rbnode_t* r = rbtree_previous(&domain->nsec3->nsec3_node);
d467 1
a467 1
	rbnode_t* r = NULL;
d659 1
a659 1
process_first(rbtree_t* tree, uint8_t* hash, rbnode_t** p,
d685 1
a685 1
process_end(rbtree_t* tree, uint8_t* hash, rbnode_t** p,
d719 2
a720 2
	rbnode_t *p = RBTREE_NULL, *pwc = RBTREE_NULL, *pds = RBTREE_NULL;
	rbnode_t *p_end = RBTREE_NULL, *pwc_end = RBTREE_NULL, *pds_end = RBTREE_NULL;
d786 1
a786 1
	rbnode_t* nx;
d858 2
a859 2
		log_msg(LOG_ERR, "nsec3 hash collision for name=%s",
			dname_to_string(to_prove, NULL));
@


1.12
log
@update to 4.1.11
"Working fine here." millert@@
OK dlg, sthen
@
text
@d30 2
d42 2
d54 2
d68 3
a70 3
	assert(dname_name(a->dname)[0] == 32);
	assert(dname_name(b->dname)[0] == 32);
	return memcmp(dname_name(a->dname), dname_name(b->dname), 33);
d447 1
a447 1
			return namedb_find_zone(db, d->dname);
d474 1
d476 3
@


1.11
log
@Update to 4.1.10
Testing by millert@@, sthen@@ and me.
came up with the same diff & OK sthen@@
@
text
@d896 3
a898 1
	} else if (!delegpt && domain->nsec3 && domain->nsec3->nsec3_is_exact) {
@


1.10
log
@merge conflicts
@
text
@d968 6
a973 1
		if(original->nsec3 && original->nsec3->nsec3_is_exact) {
d976 6
d1055 2
a1056 1
		domain_has_only_NSEC3(*match, query->zone))
@


1.9
log
@merge conflicts
@
text
@d230 1
d247 39
d287 2
a288 1
nsec3_find_zone_param(struct namedb* db, struct zone* zone, udb_ptr* z)
d291 5
a295 1
	zone->nsec3_param = udb_zone_find_nsec3param(db->udb, z, zone);
d577 1
a577 1
	unsigned n = 0, c = 0;
d599 2
a600 1
				zone->opts->name, c*100/n));
d616 5
a620 3
	if(!udb_zone_search(db->udb, &udbz, dname_name(domain_dname(
		zone->apex)), domain_dname(zone->apex)->name_size)) {
		udb_ptr_init(&udbz, db->udb); /* zero the ptr */
d622 1
a622 1
	nsec3_find_zone_param(db, zone, &udbz);
d626 2
a627 1
		udb_ptr_unlink(&udbz, db->udb);
d630 2
a631 1
	udb_ptr_unlink(&udbz, db->udb);
@


1.8
log
@time_t and random fixes from NSD upstream, ok deraadt@@
@
text
@d4 1
a4 1
 * Copyright (c) 2001-2011, NLnet Labs. All rights reserved.
d9 1
a9 1
#include <config.h>
a12 1
#include <errno.h>
d19 2
d22 1
a22 1
#define NSEC3_SHA1_HASH 1 /* same type code as DS hash */
d24 62
a90 1
	/* always uses first NSEC3 record with SOA bit set */
d98 2
a99 3
static const dname_type *
nsec3_hash_dname_param(region_type *region, zone_type *zone,
	const dname_type *dname, rr_type* param_rr)
d101 1
a101 1
	unsigned char hash[SHA_DIGEST_LENGTH];
d103 9
d116 1
a116 1
	detect_nsec3_params(param_rr, &nsec3_salt,
d118 22
a139 6
	iterated_hash(hash, nsec3_salt, nsec3_saltlength, dname_name(dname),
		dname->name_size, nsec3_iterations);
	b32_ntop(hash, sizeof(hash), b32, sizeof(b32));
	dname=dname_parse(region, b32);
	dname=dname_concatenate(region, dname, domain_dname(zone->apex));
	return dname;
d142 3
a144 3
const dname_type *
nsec3_hash_dname(region_type *region, zone_type *zone,
	const dname_type *dname)
d146 6
a151 2
	return nsec3_hash_dname_param(region, zone,
		dname, zone->nsec3_soa_rr);
d157 5
a161 4
	if(rdata_atom_size(rr->rdatas[5]) >= 3 && /* has types in bitmap */
		rdata_atom_data(rr->rdatas[5])[0] == 0 && /* first window = 0, */
						/* [1]: windowlen must be >= 1 */
		rdata_atom_data(rr->rdatas[5])[2]&0x02)  /* SOA bit set */
d163 1
d168 1
a168 1
find_zone_nsec3(namedb_type* namedb, zone_type *zone)
d170 1
a170 1
	size_t i;
d172 3
d176 20
a195 5
	/* Check settings in NSEC3PARAM.
	   Hash algorithm must be OK. And a NSEC3 with soa bit
	   must map to the zone apex.  */
	rrset_type* paramset = domain_find_rrset(zone->apex, zone, TYPE_NSEC3PARAM);
	if(!paramset || !paramset->rrs || !paramset->rr_count)
d197 5
a201 59
	tmpregion = region_create(xalloc, free);
	for(i=0; i < paramset->rr_count; i++) {
		rr_type* rr = &paramset->rrs[i];
		const dname_type* hashed_apex;
		rrset_type* nsec3_rrset;
		size_t j;
		const unsigned char *salt1;
		int saltlen1, iter1;

		if(rdata_atom_data(rr->rdatas[0])[0] != NSEC3_SHA1_HASH) {
			log_msg(LOG_ERR, "%s NSEC3PARAM entry %d has unknown hash algo %d",
				dname_to_string(domain_dname(zone->apex), NULL), (int)i,
				rdata_atom_data(rr->rdatas[0])[0]);
			continue;
		}
		if(rdata_atom_data(rr->rdatas[1])[0] != 0) {
			/* draft-nsec3-09: NSEC3PARAM records with flags
			   field value other than zero MUST be ignored. */
			continue;
		}
		/* check hash of apex -> NSEC3 with soa bit on */
		hashed_apex = nsec3_hash_dname_param(tmpregion,
			zone, domain_dname(zone->apex), &paramset->rrs[i]);
		domain = domain_table_find(namedb->domains, hashed_apex);
		if(!domain) {
			log_msg(LOG_ERR, "%s NSEC3PARAM entry %d has no hash(apex).",
				dname_to_string(domain_dname(zone->apex), NULL), (int)i);
			log_msg(LOG_ERR, "hash(apex)= %s",
				dname_to_string(hashed_apex, NULL));
			continue;
		}
		nsec3_rrset = domain_find_rrset(domain, zone, TYPE_NSEC3);
		if(!nsec3_rrset) {
			log_msg(LOG_ERR, "%s NSEC3PARAM entry %d: hash(apex) has no NSEC3 RRset",
				dname_to_string(domain_dname(zone->apex), NULL), (int)i);
			continue;
		}
		detect_nsec3_params(rr, &salt1, &saltlen1, &iter1);
		/* find SOA bit enabled nsec3, with the same settings */
		for(j=0; j < nsec3_rrset->rr_count; j++) {
			const unsigned char *salt2;
			int saltlen2, iter2;
			if(!nsec3_has_soa(&nsec3_rrset->rrs[j]))
				continue;
			/* check params OK. Ignores the optout bit. */
			detect_nsec3_params(&nsec3_rrset->rrs[j],
				&salt2, &saltlen2, &iter2);
			if(saltlen1 == saltlen2 && iter1 == iter2 &&
				rdata_atom_data(rr->rdatas[0])[0] == /* algo */
				rdata_atom_data(nsec3_rrset->rrs[j].rdatas[0])[0]
				&& memcmp(salt1, salt2, saltlen1) == 0) {
				/* found it */
				DEBUG(DEBUG_QUERY, 1, (LOG_INFO,
					"detected NSEC3 for zone %s saltlen=%d iter=%d",
					dname_to_string(domain_dname(
					zone->apex),0), saltlen2, iter2));
				region_destroy(tmpregion);
				return &nsec3_rrset->rrs[j];
			}
a202 2
		log_msg(LOG_ERR, "%s NSEC3PARAM entry %d: hash(apex) no NSEC3 with SOAbit",
			dname_to_string(domain_dname(zone->apex), NULL), (int)i);
d204 4
d212 2
a213 5
/* check that the rrset has an NSEC3 that uses the same parameters as the
   zone is using. Pass NSEC3 rrset, and zone must have nsec3_rrset set.
   if you pass NULL then 0 is returned. */
static int
nsec3_rrset_params_ok(rr_type* base, rrset_type* rrset)
d215 14
a228 9
	rdata_atom_type* prd;
	size_t i;
	if(!rrset)
		return 0; /* without rrset, no matching params either */
	assert(rrset && rrset->zone && (base || rrset->zone->nsec3_soa_rr));
	if(!base)
		base = rrset->zone->nsec3_soa_rr;
	prd = base->rdatas;
	for(i=0; i < rrset->rr_count; ++i) {
d230 10
a239 15
		assert(rrset->rrs[i].type == TYPE_NSEC3);
		if(rdata_atom_data(rd[0])[0] ==
			rdata_atom_data(prd[0])[0] && /* hash algo */
		   rdata_atom_data(rd[2])[0] ==
			rdata_atom_data(prd[2])[0] && /* iterations 0 */
		   rdata_atom_data(rd[2])[1] ==
			rdata_atom_data(prd[2])[1] && /* iterations 1 */
		   rdata_atom_data(rd[3])[0] ==
			rdata_atom_data(prd[3])[0] && /* salt length */
		   memcmp(rdata_atom_data(rd[3])+1,
			rdata_atom_data(prd[3])+1, rdata_atom_data(rd[3])[0])
			== 0 )
		{
			/* this NSEC3 matches nsec3 parameters from zone */
			return 1;
d242 9
a250 1
	return 0;
d253 16
a268 1
#ifdef FULL_PREHASH
d271 1
a271 2
nsec3_find_cover(namedb_type* db, zone_type* zone,
	const dname_type* hashname, domain_type** result)
d273 4
a276 5
	rrset_type *rrset;
	domain_type *walk;
	domain_type *closest_match;
	domain_type *closest_encloser;
	int exact;
d278 14
a291 2
	assert(result);
	assert(zone->nsec3_soa_rr);
d293 11
a303 9
	exact = domain_table_search(
		db->domains, hashname, &closest_match, &closest_encloser);
	/* exact match of hashed domain name + it has an NSEC3? */
	if(exact &&
	   nsec3_rrset_params_ok(NULL,
	   	domain_find_rrset(closest_encloser, zone, TYPE_NSEC3))) {
		*result = closest_encloser;
		assert(*result != 0);
		return 1;
d305 17
d323 21
a343 11
	/* find covering NSEC3 record, lexicographically before the closest match */
	/* use nsec3_lookup to jumpstart the search */
	walk = closest_match->nsec3_lookup;
	rrset = 0;
	while(walk && dname_is_subdomain(domain_dname(walk), domain_dname(zone->apex)))
	{
		if(nsec3_rrset_params_ok(NULL,
			domain_find_rrset(walk, zone, TYPE_NSEC3))) {
			/* this rrset is OK NSEC3, exit while */
			rrset = domain_find_rrset(walk, zone, TYPE_NSEC3);
			break;
d345 1
a345 1
		walk = domain_previous(walk);
d347 11
a357 12
	if(rrset)
		*result = walk;
	else 	{
		/*
		 * There are no NSEC3s before the closest match.
		 * so the hash name is before the first NSEC3 record in the zone.
		 * use last NSEC3, which covers the wraparound in hash space
		 *
		 * Since the zone has an NSEC3 with the SOA bit set for NSEC3 to turn on,
		 * there is also a last nsec3, so find_cover always assigns *result!=0.
		 */
		*result = zone->nsec3_last;
a358 1
	assert(*result != 0);
d362 7
a368 1
#else
d370 1
d372 1
a372 2
nsec3_find_cover(namedb_type* ATTR_UNUSED(db), zone_type* zone,
	const dname_type* hashname, struct nsec3_domain **result)
d374 43
a416 1
	rbnode_t *node;
d418 11
d431 1
a431 2
	if (!zone->nsec3_domains)
		return 0;
d433 6
a438 31
	exact = rbtree_find_less_equal(zone->nsec3_domains, hashname, &node);
	if (!node) {
		exact = 0;
		node = rbtree_last(zone->nsec3_domains);
	}

	while (node != RBTREE_NULL) {
		struct rrset *nsec3_rrset;
		struct nsec3_domain *nsec3_domain =
			(struct nsec3_domain *) node;
		nsec3_rrset = domain_find_rrset(nsec3_domain->nsec3_domain,
			zone, TYPE_NSEC3);
		if (!nsec3_rrset) {
			/*
			 * RRset in zone->nsec3_domains whose type != NSEC3
			 * If we get here, something is seriously wrong!
			 */
			return 0;
		}
		if (nsec3_rrset_params_ok(NULL, nsec3_rrset) != 0) {
			*result = nsec3_domain;
			return exact;
                }
		exact = 0; /* No match, so we're looking for closest match */
		node = rbtree_previous(node);
	}
	/*
	 * If we reach this point, *result == NULL.  This should
	 * never happen since the zone should have one NSEC3 record with
	 * the SOA bit set, which matches a NSEC3PARAM RR in the zone.
	 */
a440 1
#endif
d442 3
a444 4
#ifdef FULL_PREHASH
static void
prehash_domain_r(namedb_type* db, zone_type* zone,
	domain_type* domain, region_type* region)
d446 1
d448 4
a451 10
	const dname_type *wcard, *wcard_child, *hashname;
	domain_type* result = 0;
	if(!zone->nsec3_soa_rr)
	{
		/* set to 0 (in case NSEC3 removed after an update) */
		domain->nsec3_is_exact = 0;
		domain->nsec3_cover = NULL;
		domain->nsec3_wcard_child_cover = NULL;
		return;
	}
d453 10
a462 3
	hashname = nsec3_hash_dname(region, zone, domain_dname(domain));
	exact = nsec3_find_cover(db, zone, hashname, &result);
	domain->nsec3_cover = result;
d464 2
a465 2
		domain->nsec3_is_exact = 1;
	else	domain->nsec3_is_exact = 0;
d468 3
a470 18
	wcard = dname_parse(region, "*");
	wcard_child = dname_concatenate(region, wcard, domain_dname(domain));
	hashname = nsec3_hash_dname(region, zone, wcard_child);
	exact = nsec3_find_cover(db, zone, hashname, &result);
	domain->nsec3_wcard_child_cover = result;

	if(exact && !domain_wildcard_child(domain))
	{
		/* We found an exact match for the *.domain NSEC3 hash,
		 * but the domain wildcard child (*.domain) does not exist.
		 * Thus there is a hash collision. It will cause servfail
		 * for NXdomain queries below this domain.
		 */
		log_msg(LOG_WARNING, "prehash: collision of wildcard "
			"denial for %s. Sign zone with different salt "
			"to remove collision.",
			dname_to_string(domain_dname(domain),0));
	}
d473 3
a475 5
#else

static void
prehash_domain_r(namedb_type* db, zone_type* zone,
	domain_type* domain, region_type* region)
d477 1
d479 1
a479 2
	const dname_type *hashname;
	struct nsec3_domain* result = NULL;
d481 13
a493 9
	domain->nsec3_cover = NULL;
	hashname = nsec3_hash_dname(region, zone, domain_dname(domain));
	exact = nsec3_find_cover(db, zone, hashname, &result);
	if (result && exact)
    {
		result->covers = domain;
		domain->nsec3_cover = result->nsec3_domain;
	}
	return;
a494 1
#endif
d497 1
a497 2
prehash_domain(namedb_type* db, zone_type* zone,
	domain_type* domain, region_type* region)
d499 8
a506 15
    prehash_domain_r(db, zone, domain, region);
}

#ifdef FULL_PREHASH
static void
prehash_ds(namedb_type* db, zone_type* zone,
	domain_type* domain, region_type* region)
{
	domain_type* result = 0;
	const dname_type* hashname;
	int exact;

	if(!zone->nsec3_soa_rr) {
		domain->nsec3_ds_parent_is_exact = 0;
		domain->nsec3_ds_parent_cover = NULL;
d509 1
a509 8

	/* hash again, other zone could have different hash parameters */
	hashname = nsec3_hash_dname(region, zone, domain_dname(domain));
	exact = nsec3_find_cover(db, zone, hashname, &result);
	if(exact)
		domain->nsec3_ds_parent_is_exact = 1;
	else 	domain->nsec3_ds_parent_is_exact = 0;
	domain->nsec3_ds_parent_cover = result;
a510 1
#endif
d512 3
a514 3
#ifndef FULL_PREHASH
struct domain *
find_last_nsec3_domain(struct zone *zone)
d516 7
a522 3
	rbnode_t *node;
	if (zone->nsec3_domains == NULL) {
		return NULL;
a523 5
	node = rbtree_last(zone->nsec3_domains);
        if (node == RBTREE_NULL) {
                return NULL;
        }
	return ((struct nsec3_domain *) node)->nsec3_domain;
d527 1
a527 1
prehash_zone_incremental(struct namedb *db, struct zone *zone)
d529 26
a554 52
	region_type *temp_region;
	rbnode_t *node;
	/* find zone NSEC3PARAM settings */
	zone->nsec3_soa_rr = find_zone_nsec3(db, zone);
        if (zone->nsec3_soa_rr == NULL) {
                zone->nsec3_last = NULL;
                return;
        }
        if (db->nsec3_mod_domains == NULL) {
                return;
        }
	zone->nsec3_last = find_last_nsec3_domain(zone);
        temp_region = region_create(xalloc, free);
	node = rbtree_first(db->nsec3_mod_domains);
	while (node != RBTREE_NULL) {
		struct nsec3_mod_domain *nsec3_mod_domain =
			(struct nsec3_mod_domain *) node;
		struct domain *walk = nsec3_mod_domain->domain;
		struct domain *domain_zone_apex;

		if (!walk ||
			(dname_is_subdomain(domain_dname(walk),
				domain_dname(zone->apex)) == 0)) {
			node = rbtree_next(node);
			continue;
		}
		if (walk->nsec3_cover != NULL) {
			node = rbtree_next(node);
			continue;
		}
		/* Empty Terminal */
		if (!walk->is_existing) {
			walk->nsec3_cover = NULL;
			node = rbtree_next(node);
			continue;
		}

		/*
		 * Don't hash NSEC3 only nodes, unless possibly
		 * part of a weird case where node is empty nonterminal
		 * requiring NSEC3 but node name also is the hashed
		 * node name of another node requiring NSEC3.
		 * NSEC3 Empty Nonterminal with NSEC3 RRset present.
		 */
		if (domain_has_only_NSEC3(walk, zone) != 0) {
			struct domain *next_domain = domain_next(walk);
			if ((next_domain == NULL) ||
			    (next_domain->parent != walk)) {
				walk->nsec3_cover = NULL;
				node = rbtree_next(node);
				continue;
			}
a555 20

		/*
		 * Identify domain nodes that belong to the zone
		 * which are not glue records.  What if you hit a
		 * record that's in two zones but which has no
		 * cut point between the zones. Not valid but
		 * someone is gonna try it sometime.
		 * This implementation doesn't link an NSEC3
		 * record to the domain.
		 */
		domain_zone_apex = domain_find_zone_apex(walk);
		if ((domain_zone_apex != NULL) &&
		    (domain_zone_apex == zone->apex) &&
		    (domain_is_glue(walk, zone) == 0)) {

                        prehash_domain(db, zone, walk, temp_region);
			region_free_all(temp_region);
		}

		node = rbtree_next(node);
d557 1
a557 2
	namedb_nsec3_mod_domains_destroy(db);
	region_destroy(temp_region);
d561 1
a561 1
prehash_zone(struct namedb* db, struct zone* zone)
d563 1
a563 4
	domain_type *walk;
	domain_type *last_nsec3_node;
	region_type *temp_region;
	assert(db && zone);
d565 2
d568 9
a576 2
	zone->nsec3_soa_rr = find_zone_nsec3(db, zone);
	if(!zone->nsec3_soa_rr) {
d578 1
d581 3
a583 1
	temp_region = region_create(xalloc, free);
d585 3
a587 9
	/* go through entire zone and setup nsec3_lookup speedup */
	walk = zone->apex;
	last_nsec3_node = NULL;
	/* since we walk in sorted order, we pass all NSEC3s in sorted
	   order and we can set the lookup ptrs */
	while(walk && dname_is_subdomain(
		domain_dname(walk), domain_dname(zone->apex)))
	{
		struct domain *domain_zone_apex;
d589 3
a591 10
		if (walk->nsec3_cover != NULL) {
			walk = domain_next(walk);
			continue;
		}
		/* Empty Terminal */
		if (walk->is_existing == 0) {
			walk->nsec3_cover = NULL;
			walk = domain_next(walk);
			continue;
		}
d593 3
a595 16
		/*
		 * Don't hash NSEC3 only nodes, unless possibly
		 * part of a weird case where node is empty nonterminal
		 * requiring NSEC3 but node name also is the hashed
		 * node name of another node requiring NSEC3.
		 * NSEC3 Empty Nonterminal with NSEC3 RRset present.
		 */
		if (domain_has_only_NSEC3(walk, zone)) {
			struct domain *next_domain = domain_next(walk);
			if ((next_domain == NULL) ||
			    (next_domain->parent != walk)) {
				walk->nsec3_cover = NULL;
				walk = domain_next(walk);
				continue;
			}
		}
d597 16
a612 18
		/*
		 * Identify domain nodes that belong to the zone
		 * which are not glue records.  What if you hit a
		 * record that's in two zones but which has no
		 * cut point between the zones. Not valid but
		 * someone is gonna try it sometime.
		 * This implementation doesn't link an NSEC3
		 * record to the domain.
		 */
		domain_zone_apex = domain_find_zone_apex(walk);
		if ((domain_zone_apex != NULL) &&
		    (domain_zone_apex == zone->apex) &&
		    (domain_is_glue(walk, zone) == 0))
		{
			prehash_domain(db, zone, walk, temp_region);
			region_free_all(temp_region);
		}
		walk = domain_next(walk);
d614 7
a620 1
	region_destroy(temp_region);
d623 1
a623 2
#else

d625 2
a626 1
prehash_zone(struct namedb* db, struct zone* zone)
d628 52
a679 27
	domain_type *walk;
	domain_type *last_nsec3_node;
	region_type *temp_region;
	assert(db && zone);

	/* find zone settings */
	zone->nsec3_soa_rr = find_zone_nsec3(db, zone);
	if(!zone->nsec3_soa_rr) {
		zone->nsec3_last = NULL;
		return;
	}
	temp_region = region_create(xalloc, free);

	/* go through entire zone and setup nsec3_lookup speedup */
	walk = zone->apex;
	last_nsec3_node = NULL;
	/* since we walk in sorted order, we pass all NSEC3s in sorted
	   order and we can set the lookup ptrs */
	while(walk && dname_is_subdomain(
		domain_dname(walk), domain_dname(zone->apex)))
	{
		zone_type* z = domain_find_zone(walk);
		if(z && z==zone)
		{
			if(domain_find_rrset(walk, zone, TYPE_NSEC3))
				last_nsec3_node = walk;
			walk->nsec3_lookup = last_nsec3_node;
d681 34
a714 1
		walk = domain_next(walk);
d716 1
a716 1
	zone->nsec3_last = last_nsec3_node;
d718 26
a743 28
	/* go through entire zone */
	walk = zone->apex;
	while(walk && dname_is_subdomain(
		domain_dname(walk), domain_dname(zone->apex)))
	{
		zone_type* z;
		if(!walk->is_existing && domain_has_only_NSEC3(walk, zone)) {
			walk->nsec3_cover = NULL;
			walk->nsec3_wcard_child_cover = NULL;
			walk = domain_next(walk);
			continue;
		}
		z = domain_find_zone(walk);
		if(z && z==zone && !domain_is_glue(walk, zone))
		{
			prehash_domain(db, zone, walk, temp_region);
			region_free_all(temp_region);
		}
		/* prehash the DS (parent zone) */
		if(domain_find_rrset(walk, zone, TYPE_DS) ||
			(domain_find_rrset(walk, zone, TYPE_NS) &&
			 walk != zone->apex))
		{
			assert(walk != zone->apex /* DS must be above zone cut */);
			prehash_ds(db, zone, walk, temp_region);
			region_free_all(temp_region);
		}
		walk = domain_next(walk);
a744 1
	region_destroy(temp_region);
a745 1
#endif
d747 1
a747 2
void
prehash(struct namedb* db, int updated_only)
d749 8
a756 10
	zone_type *z;
	time_t end, start = time(NULL);
	int count = 0;
	for(z = db->zones; z; z = z->next)
	{
		if(!updated_only || z->updated) {
			prehash_zone(db, z);
			if(z->nsec3_soa_rr)
				count++;
		}
d758 2
a759 5
	end = time(NULL);
	if(count > 0)
		VERBOSITY(1, (LOG_INFO, "nsec3-prepare took %lld "
		"seconds for %d zones.", (long long)(end-start), count));
}
d761 3
a763 42

#ifndef FULL_PREHASH
static void
nsec3_hash_and_find_cover(struct region *region,
	struct namedb *db, const struct dname *domain_dname,
	struct zone *zone, int *exact, struct domain **result)
{
	dname_type const *hash_dname;
	struct nsec3_domain *nsec3_domain;

	*result = NULL;
	*exact = 0;
	hash_dname = nsec3_hash_dname(region, zone, domain_dname);
	*exact = nsec3_find_cover(db, zone, hash_dname, &nsec3_domain);
        if (nsec3_domain != NULL) {
                *result = nsec3_domain->nsec3_domain;
        }
        return;
}

static void
nsec3_hash_and_find_wild_cover(struct region *region,
	struct namedb *db, struct domain *domain,
	struct zone *zone, int *exact, struct domain **result)
{
	struct dname const *wcard_child;
	/* find cover for *.domain for wildcard denial */
	(void) dname_make_wildcard(region, domain_dname(domain),
		&wcard_child);
        nsec3_hash_and_find_cover(region, db, wcard_child, zone, exact,
		result);
	if ((*exact != 0) &&
		(domain_wildcard_child(domain) == NULL)) {
		/* We found an exact match for the *.domain NSEC3 hash,
		 * but the domain wildcard child (*.domain) does not exist.
		 * Thus there is a hash collision. It will cause servfail
		 * for NXdomain queries below this domain.
		 */
		log_msg(LOG_WARNING,
			"collision of wildcard denial for %s. "
			"Sign zone with different salt to remove collision.",
			dname_to_string(domain_dname(domain), NULL));
a765 2
#endif

d769 1
a769 1
nsec3_add_rrset(struct query *query, struct answer *answer,
d781 2
a782 2
nsec3_add_nonexist_proof(struct query *query, struct answer *answer,
        struct domain *encloser, struct namedb* db, const dname_type* qname)
d784 3
a786 7
	const dname_type *to_prove;
#ifdef FULL_PREHASH
	const dname_type *hashed;
#else
	int exact = 0;
#endif
	domain_type *cover = NULL;
d793 2
a794 8
#ifdef FULL_PREHASH
	hashed = nsec3_hash_dname(query->region, query->zone, to_prove);
	if(nsec3_find_cover(db, query->zone, hashed, &cover))
#else
	nsec3_hash_and_find_cover(query->region, db, to_prove, query->zone,
		&exact, &cover);
	if (exact)
#endif
d803 2
a804 1
	else if (cover) {
d812 2
a813 3
	struct query *query, struct answer *answer,
	struct domain *closest_encloser, struct namedb* db,
	const dname_type* qname)
d818 1
a818 1
	nsec3_add_nonexist_proof(query, answer, closest_encloser, db, qname);
d820 1
a820 5
#ifdef FULL_PREHASH
	if(closest_encloser->nsec3_is_exact)
#else
	if(closest_encloser->nsec3_cover)
#endif
d822 1
a822 1
			closest_encloser->nsec3_cover);
a824 1

d827 1
a827 1
        struct domain *wildcard, struct namedb* db, const dname_type* qname)
d831 1
a831 1
	if(!query->zone->nsec3_soa_rr)
d833 1
a833 1
	nsec3_add_nonexist_proof(query, answer, wildcard, db, qname);
a835 1

a839 4
#ifndef FULL_PREHASH
	struct domain * ds_parent_cover = NULL;
	int exact = 0;
#endif
d842 1
a842 3

#ifdef FULL_PREHASH
	if(domain->nsec3_ds_parent_is_exact) {
d845 2
a846 13
			domain->nsec3_ds_parent_cover);
	} else if (!delegpt && domain->nsec3_is_exact) {
#else
	nsec3_hash_and_find_cover(query->region, NULL, domain_dname(domain),
		query->zone, &exact, &ds_parent_cover);
	if (exact) {
		/* use NSEC3 record from above the zone cut. */
		if (ds_parent_cover) {
			nsec3_add_rrset(query, answer, AUTHORITY_SECTION,
				ds_parent_cover);
		}
	} else if (!delegpt && domain->nsec3_cover) {
#endif
d848 1
a848 1
			domain->nsec3_cover);
d852 1
a852 2
		domain_type* prev_par = NULL;
		assert(par); /* must be provable, thus there must be a parent */
d854 1
a854 5
#ifdef FULL_PREHASH
		while(!par->nsec3_is_exact)
#else
		while(!par->nsec3_cover)
#endif
a857 1
			assert(par); /* parent zone apex must be provable, thus this ends */
d859 2
d862 1
a862 1
			par->nsec3_cover);
d866 3
a868 3
		if(prev_par) {
#ifdef FULL_PREHASH
			assert(prev_par != domain && !prev_par->nsec3_is_exact);
d870 1
a870 11
				prev_par->nsec3_cover);
#else
			struct domain *prev_parent_cover = NULL;
			nsec3_hash_and_find_cover(query->region, NULL,
				domain_dname(prev_par), query->zone,
				&exact, &prev_parent_cover);
			if (prev_parent_cover) {
				nsec3_add_rrset(query, answer,
					AUTHORITY_SECTION, prev_parent_cover);
			}
#endif
a871 2

		/* use NSEC3 record from above the zone cut. */
d874 3
a876 7
#ifdef FULL_PREHASH
		nsec3_add_rrset(query, answer, AUTHORITY_SECTION,
			domain->nsec3_ds_parent_cover);
#else
		nsec3_add_rrset(query, answer, AUTHORITY_SECTION,
			ds_parent_cover);
#endif
a879 1

d881 2
a882 2
nsec3_answer_nodata(struct query *query, struct answer *answer,
	struct domain *original)
d884 1
a884 1
	if(!query->zone->nsec3_soa_rr)
a885 1

d892 1
a892 5
#ifdef FULL_PREHASH
			if(original->nsec3_is_exact)
#else
			if(original->nsec3_cover)
#endif
d894 1
a894 1
					original->nsec3_cover);
a902 4
#ifndef FULL_PREHASH
		struct domain* original_cover;
		int exact;
#endif
d907 2
a908 5
#ifdef FULL_PREHASH
		if(original->parent && original->parent->nsec3_is_exact)
#else
		if(original->parent && original->parent->nsec3_cover)
#endif
d910 1
a910 2
				original->parent->nsec3_cover);

d913 3
a915 16
#ifdef FULL_PREHASH
		nsec3_add_rrset(query, answer, AUTHORITY_SECTION,
			original->nsec3_cover);
#else
		original_cover = original->nsec3_cover;
		if (!original_cover) { /* not exact */
			nsec3_hash_and_find_cover(query->region, NULL,
				domain_dname(original), query->zone,
				&exact, &original_cover);
                }
		if (original_cover) {
	                nsec3_add_rrset(query, answer, AUTHORITY_SECTION,
				original_cover);
		}
#endif

d917 2
a918 6
	else { /* add nsec3 to prove rrset does not exist */
#ifdef FULL_PREHASH
		if(original->nsec3_is_exact)
#else
		if (original->nsec3_cover != NULL)
#endif
d920 2
a921 1
				original->nsec3_cover);
d928 1
a928 1
	if(!query->zone->nsec3_soa_rr)
d956 1
a956 1
	struct namedb* db, const dname_type* qname)
d958 1
a958 6
#ifndef FULL_PREHASH
	struct domain *cover_domain = NULL;
	int exact = 0;
#endif

	if(!query->zone->nsec3_soa_rr)
d972 2
a973 5
#ifdef FULL_PREHASH
		if(query->zone->apex->nsec3_is_exact)
#else
		if(query->zone->apex->nsec3_cover)
#endif
d975 1
a975 2
				query->zone->apex->nsec3_cover);

d977 2
a978 2
		nsec3_add_rrset(query, answer, AUTHORITY_SECTION,
			closest_encloser->nsec3_cover);
d980 3
a982 12
#ifdef FULL_PREHASH
		nsec3_add_rrset(query, answer, AUTHORITY_SECTION,
            query->zone->apex->nsec3_wcard_child_cover);
#else
		cover_domain = NULL;
		nsec3_hash_and_find_cover(query->region, db,
			domain_dname(closest_encloser),
			query->zone, &exact, &cover_domain);
		if (cover_domain)
	                nsec3_add_rrset(query, answer, AUTHORITY_SECTION,
				cover_domain);
#endif
d1002 3
a1004 10
		nsec3_add_closest_encloser_proof(query, answer,
			closest_encloser, db, qname);
#ifdef FULL_PREHASH
		nsec3_add_rrset(query, answer, AUTHORITY_SECTION,
			closest_encloser->nsec3_wcard_child_cover);
#else
		cover_domain = NULL;
		nsec3_hash_and_find_wild_cover(query->region, db,
			closest_encloser, query->zone, &exact, &cover_domain);
		if (cover_domain)
d1006 1
a1006 2
				cover_domain);
#endif
@


1.7
log
@resolve conflicts
@
text
@d652 2
a653 2
		VERBOSITY(1, (LOG_INFO, "nsec3-prepare took %d "
		"seconds for %d zones.", (int)(end-start), count));
@


1.6
log
@resolve conflicts
@
text
@d438 1
a438 1
		if (!walk->nsec3_cover) {
@


1.5
log
@resolve conflicts
@
text
@d822 1
d825 1
a825 1
		while(par && !par->nsec3_is_exact)
d827 1
a827 1
		while(par && !par->nsec3_cover)
d832 1
a833 1
		assert(par); /* parent zone apex must be provable, thus this ends */
@


1.4
log
@resolve conflicts
@
text
@d956 1
a956 1
	int nsec3_seen = 0, rrsig_seen = 0;
d963 1
a963 3
			else if(rrset->rrs[0].type == TYPE_RRSIG)
				rrsig_seen = 1;
			else
@


1.3
log
@resolve conflicts and regen configure using autoconf-2.65
@
text
@d13 1
a22 4
/* detect is the latter rrset has the same hashalgo, iterations and salt
   as the base. Does not compare optout bit, or other rdata.
   base=NULL uses the zone soa_rr. */
static int nsec3_rrset_params_ok(rr_type* base, rrset_type* rrset);
d86 1
a86 1
		return 0;
d88 1
a88 2
	for(i=0; i<paramset->rr_count; i++)
	{
d93 2
d124 1
d126 3
a128 4
		for(j=0; j<nsec3_rrset->rr_count; j++)
		{
			const unsigned char *salt1, *salt2;
			int saltlen1, saltlen2, iter1, iter2;
a131 1
			detect_nsec3_params(rr, &salt1, &saltlen1, &iter1);
d136 1
a136 1
					rdata_atom_data(nsec3_rrset->rrs[j].rdatas[0])[0]
d151 1
a151 1
	return 0;
a160 1
	rdata_atom_type* rd;
d168 2
a169 3
	for(i=0; i<rrset->rr_count; ++i)
	{
		rd = rrset->rrs[i].rdatas;
d190 2
d247 49
d297 1
a297 1
prehash_domain(namedb_type* db, zone_type* zone,
d300 2
a301 1
	/* find it */
a302 3
	const dname_type *wcard, *wcard_child, *hashname;
	int exact;

d340 30
d392 175
d579 1
a579 1
		zone->nsec3_last = 0;
a581 1

d609 1
a609 1
		if(!walk->is_existing || domain_has_only_NSEC3(walk, zone)) {
d634 1
d656 47
d720 7
a726 2
	const dname_type *to_prove, *hashed;
	domain_type *cover=0;
d733 1
d736 5
d749 1
a749 2
	else
	{
d766 1
d768 3
d775 1
d787 1
d792 4
d798 2
d805 11
d821 1
a821 1
		domain_type* prev_par = 0;
d823 1
d825 3
d839 1
d843 10
d854 2
d858 1
d861 4
d868 1
d875 1
d882 1
d884 3
d897 4
d902 1
d904 2
d907 3
d912 1
d914 2
d918 13
d932 2
a933 1
	else {	/* add nsec3 to prove rrset does not exist */
d935 3
d978 5
d987 2
a988 1
	if(*match &&
d997 1
d999 3
d1004 1
d1006 2
a1007 1
		nsec3_add_rrset(query, answer, AUTHORITY_SECTION, closest_encloser->nsec3_cover);
d1009 12
a1020 2
		nsec3_add_rrset(query, answer, AUTHORITY_SECTION, query->zone->apex->
			nsec3_wcard_child_cover);
d1028 10
d1040 3
a1042 2
		nsec3_add_closest_encloser_proof(query, answer, closest_encloser,
			db, qname);
d1045 8
@


1.2
log
@upgrade to NSD 3.2.7; ok sthen@@, tested by multiple people
@
text
@d4 1
a4 1
 * Copyright (c) 2001-2006, NLnet Labs. All rights reserved.
@


1.1
log
@Initial revision
@
text
@d478 1
a478 1
	struct domain *domain)
d486 3
d493 1
d535 1
a535 1
		nsec3_add_ds_proof(query, answer, original);
d561 1
a561 1
	nsec3_add_ds_proof(query, answer, query->delegation_domain);
@


1.1.1.1
log
@NSD v3.2.4
@
text
@@


1.1.1.2
log
@NSD v3.2.8
@
text
@d4 1
a4 1
 * Copyright (c) 2001-2011, NLnet Labs. All rights reserved.
d478 1
a478 1
	struct domain *domain, int delegpt)
a485 3
	} else if (!delegpt && domain->nsec3_is_exact) {
		nsec3_add_rrset(query, answer, AUTHORITY_SECTION,
			domain->nsec3_cover);
a489 1

d531 1
a531 1
		nsec3_add_ds_proof(query, answer, original, 0);
d557 1
a557 1
	nsec3_add_ds_proof(query, answer, query->delegation_domain, 1);
@


1.1.1.3
log
@NSD v3.2.9
@
text
@a12 1
#include <errno.h>
d22 4
d89 1
a89 1
		return NULL;
d91 2
a92 1
	for(i=0; i < paramset->rr_count; i++) {
a96 2
		const unsigned char *salt1;
		int saltlen1, iter1;
a125 1
		detect_nsec3_params(rr, &salt1, &saltlen1, &iter1);
d127 4
a130 3
		for(j=0; j < nsec3_rrset->rr_count; j++) {
			const unsigned char *salt2;
			int saltlen2, iter2;
d134 1
d139 1
a139 1
				rdata_atom_data(nsec3_rrset->rrs[j].rdatas[0])[0]
d154 1
a154 1
	return NULL;
d164 1
d172 3
a174 2
	for(i=0; i < rrset->rr_count; ++i) {
		rdata_atom_type* rd = rrset->rrs[i].rdatas;
a194 2
#ifdef FULL_PREHASH

a249 49
#else

int
nsec3_find_cover(namedb_type* ATTR_UNUSED(db), zone_type* zone,
	const dname_type* hashname, struct nsec3_domain **result)
{
	rbnode_t *node;
	int exact;

	assert(result);
	if (!zone->nsec3_domains)
		return 0;

	exact = rbtree_find_less_equal(zone->nsec3_domains, hashname, &node);
	if (!node) {
		exact = 0;
		node = rbtree_last(zone->nsec3_domains);
	}

	while (node != RBTREE_NULL) {
		struct rrset *nsec3_rrset;
		struct nsec3_domain *nsec3_domain =
			(struct nsec3_domain *) node;
		nsec3_rrset = domain_find_rrset(nsec3_domain->nsec3_domain,
			zone, TYPE_NSEC3);
		if (!nsec3_rrset) {
			/*
			 * RRset in zone->nsec3_domains whose type != NSEC3
			 * If we get here, something is seriously wrong!
			 */
			return 0;
		}
		if (nsec3_rrset_params_ok(NULL, nsec3_rrset) != 0) {
			*result = nsec3_domain;
			return exact;
                }
		exact = 0; /* No match, so we're looking for closest match */
		node = rbtree_previous(node);
	}
	/*
	 * If we reach this point, *result == NULL.  This should
	 * never happen since the zone should have one NSEC3 record with
	 * the SOA bit set, which matches a NSEC3PARAM RR in the zone.
	 */
	return exact;
}
#endif

#ifdef FULL_PREHASH
d251 1
a251 1
prehash_domain_r(namedb_type* db, zone_type* zone,
d254 3
d258 1
a258 2
	const dname_type *wcard, *wcard_child, *hashname;
	domain_type* result = 0;
a295 30
#else

static void
prehash_domain_r(namedb_type* db, zone_type* zone,
	domain_type* domain, region_type* region)
{
	int exact;
	const dname_type *hashname;
	struct nsec3_domain* result = NULL;

	domain->nsec3_cover = NULL;
	hashname = nsec3_hash_dname(region, zone, domain_dname(domain));
	exact = nsec3_find_cover(db, zone, hashname, &result);
	if (result && exact)
    {
		result->covers = domain;
		domain->nsec3_cover = result->nsec3_domain;
	}
	return;
}
#endif

static void
prehash_domain(namedb_type* db, zone_type* zone,
	domain_type* domain, region_type* region)
{
    prehash_domain_r(db, zone, domain, region);
}

#ifdef FULL_PREHASH
a317 1
#endif
d319 1
a319 97
#ifndef FULL_PREHASH
struct domain *
find_last_nsec3_domain(struct zone *zone)
{
	rbnode_t *node;
	if (zone->nsec3_domains == NULL) {
		return NULL;
	}
	node = rbtree_last(zone->nsec3_domains);
        if (node == RBTREE_NULL) {
                return NULL;
        }
	return ((struct nsec3_domain *) node)->nsec3_domain;
}

void
prehash_zone_incremental(struct namedb *db, struct zone *zone)
{
	region_type *temp_region;
	rbnode_t *node;
	/* find zone NSEC3PARAM settings */
	zone->nsec3_soa_rr = find_zone_nsec3(db, zone);
        if (zone->nsec3_soa_rr == NULL) {
                zone->nsec3_last = NULL;
                return;
        }
        if (db->nsec3_mod_domains == NULL) {
                return;
        }
	zone->nsec3_last = find_last_nsec3_domain(zone);
        temp_region = region_create(xalloc, free);
	node = rbtree_first(db->nsec3_mod_domains);
	while (node != RBTREE_NULL) {
		struct nsec3_mod_domain *nsec3_mod_domain =
			(struct nsec3_mod_domain *) node;
		struct domain *walk = nsec3_mod_domain->domain;
		struct domain *domain_zone_apex;

		if (!walk ||
			(dname_is_subdomain(domain_dname(walk),
				domain_dname(zone->apex)) == 0)) {
			node = rbtree_next(node);
			continue;
		}
		if (!walk->nsec3_cover) {
			node = rbtree_next(node);
			continue;
		}
		/* Empty Terminal */
		if (!walk->is_existing) {
			walk->nsec3_cover = NULL;
			node = rbtree_next(node);
			continue;
		}

		/*
		 * Don't hash NSEC3 only nodes, unless possibly
		 * part of a weird case where node is empty nonterminal
		 * requiring NSEC3 but node name also is the hashed
		 * node name of another node requiring NSEC3.
		 * NSEC3 Empty Nonterminal with NSEC3 RRset present.
		 */
		if (domain_has_only_NSEC3(walk, zone) != 0) {
			struct domain *next_domain = domain_next(walk);
			if ((next_domain == NULL) ||
			    (next_domain->parent != walk)) {
				walk->nsec3_cover = NULL;
				node = rbtree_next(node);
				continue;
			}
		}

		/*
		 * Identify domain nodes that belong to the zone
		 * which are not glue records.  What if you hit a
		 * record that's in two zones but which has no
		 * cut point between the zones. Not valid but
		 * someone is gonna try it sometime.
		 * This implementation doesn't link an NSEC3
		 * record to the domain.
		 */
		domain_zone_apex = domain_find_zone_apex(walk);
		if ((domain_zone_apex != NULL) &&
		    (domain_zone_apex == zone->apex) &&
		    (domain_is_glue(walk, zone) == 0)) {

                        prehash_domain(db, zone, walk, temp_region);
			region_free_all(temp_region);
		}

		node = rbtree_next(node);
	}
	namedb_nsec3_mod_domains_destroy(db);
	region_destroy(temp_region);
}

void
d330 1
a330 1
		zone->nsec3_last = NULL;
a332 71
	temp_region = region_create(xalloc, free);

	/* go through entire zone and setup nsec3_lookup speedup */
	walk = zone->apex;
	last_nsec3_node = NULL;
	/* since we walk in sorted order, we pass all NSEC3s in sorted
	   order and we can set the lookup ptrs */
	while(walk && dname_is_subdomain(
		domain_dname(walk), domain_dname(zone->apex)))
	{
		struct domain *domain_zone_apex;

		if (walk->nsec3_cover != NULL) {
			walk = domain_next(walk);
			continue;
		}
		/* Empty Terminal */
		if (walk->is_existing == 0) {
			walk->nsec3_cover = NULL;
			walk = domain_next(walk);
			continue;
		}

		/*
		 * Don't hash NSEC3 only nodes, unless possibly
		 * part of a weird case where node is empty nonterminal
		 * requiring NSEC3 but node name also is the hashed
		 * node name of another node requiring NSEC3.
		 * NSEC3 Empty Nonterminal with NSEC3 RRset present.
		 */
		if (domain_has_only_NSEC3(walk, zone)) {
			struct domain *next_domain = domain_next(walk);
			if ((next_domain == NULL) ||
			    (next_domain->parent != walk)) {
				walk->nsec3_cover = NULL;
				walk = domain_next(walk);
				continue;
			}
		}

		/*
		 * Identify domain nodes that belong to the zone
		 * which are not glue records.  What if you hit a
		 * record that's in two zones but which has no
		 * cut point between the zones. Not valid but
		 * someone is gonna try it sometime.
		 * This implementation doesn't link an NSEC3
		 * record to the domain.
		 */
		domain_zone_apex = domain_find_zone_apex(walk);
		if ((domain_zone_apex != NULL) &&
		    (domain_zone_apex == zone->apex) &&
		    (domain_is_glue(walk, zone) == 0))
		{
			prehash_domain(db, zone, walk, temp_region);
			region_free_all(temp_region);
		}
		walk = domain_next(walk);
	}
	region_destroy(temp_region);
}

#else

static void
prehash_zone(struct namedb* db, struct zone* zone)
{
	domain_type *walk;
	domain_type *last_nsec3_node;
	region_type *temp_region;
	assert(db && zone);
a333 6
	/* find zone settings */
	zone->nsec3_soa_rr = find_zone_nsec3(db, zone);
	if(!zone->nsec3_soa_rr) {
		zone->nsec3_last = NULL;
		return;
	}
d361 1
a361 1
		if(!walk->is_existing && domain_has_only_NSEC3(walk, zone)) {
a385 1
#endif
a406 47

#ifndef FULL_PREHASH
static void
nsec3_hash_and_find_cover(struct region *region,
	struct namedb *db, const struct dname *domain_dname,
	struct zone *zone, int *exact, struct domain **result)
{
	dname_type const *hash_dname;
	struct nsec3_domain *nsec3_domain;

	*result = NULL;
	*exact = 0;
	hash_dname = nsec3_hash_dname(region, zone, domain_dname);
	*exact = nsec3_find_cover(db, zone, hash_dname, &nsec3_domain);
        if (nsec3_domain != NULL) {
                *result = nsec3_domain->nsec3_domain;
        }
        return;
}

static void
nsec3_hash_and_find_wild_cover(struct region *region,
	struct namedb *db, struct domain *domain,
	struct zone *zone, int *exact, struct domain **result)
{
	struct dname const *wcard_child;
	/* find cover for *.domain for wildcard denial */
	(void) dname_make_wildcard(region, domain_dname(domain),
		&wcard_child);
        nsec3_hash_and_find_cover(region, db, wcard_child, zone, exact,
		result);
	if ((*exact != 0) &&
		(domain_wildcard_child(domain) == NULL)) {
		/* We found an exact match for the *.domain NSEC3 hash,
		 * but the domain wildcard child (*.domain) does not exist.
		 * Thus there is a hash collision. It will cause servfail
		 * for NXdomain queries below this domain.
		 */
		log_msg(LOG_WARNING,
			"collision of wildcard denial for %s. "
			"Sign zone with different salt to remove collision.",
			dname_to_string(domain_dname(domain), NULL));
	}
}
#endif


d424 2
a425 7
	const dname_type *to_prove;
#ifdef FULL_PREHASH
	const dname_type *hashed;
#else
	int exact = 0;
#endif
	domain_type *cover = NULL;
a431 1
#ifdef FULL_PREHASH
a433 5
#else
	nsec3_hash_and_find_cover(query->region, db, to_prove, query->zone,
		&exact, &cover);
	if (exact)
#endif
d442 2
a443 1
	else if (cover) {
a459 1
#ifdef FULL_PREHASH
a460 3
#else
	if(closest_encloser->nsec3_cover)
#endif
a464 1

a475 1

a479 4
#ifndef FULL_PREHASH
	struct domain * ds_parent_cover = NULL;
	int exact = 0;
#endif
a481 2

#ifdef FULL_PREHASH
a486 11
#else
	nsec3_hash_and_find_cover(query->region, NULL, domain_dname(domain),
		query->zone, &exact, &ds_parent_cover);
	if (exact) {
		/* use NSEC3 record from above the zone cut. */
		if (ds_parent_cover) {
			nsec3_add_rrset(query, answer, AUTHORITY_SECTION,
				ds_parent_cover);
		}
	} else if (!delegpt && domain->nsec3_cover) {
#endif
d492 1
a492 1
		domain_type* prev_par = NULL;
a493 1
#ifdef FULL_PREHASH
a494 3
#else
		while(par && !par->nsec3_cover)
#endif
a505 1
#ifdef FULL_PREHASH
a508 10
#else
			struct domain *prev_parent_cover = NULL;
			nsec3_hash_and_find_cover(query->region, NULL,
				domain_dname(prev_par), query->zone,
				&exact, &prev_parent_cover);
			if (prev_parent_cover) {
				nsec3_add_rrset(query, answer,
					AUTHORITY_SECTION, prev_parent_cover);
			}
#endif
a509 2

		/* use NSEC3 record from above the zone cut. */
a511 1
#ifdef FULL_PREHASH
a513 4
#else
		nsec3_add_rrset(query, answer, AUTHORITY_SECTION,
			ds_parent_cover);
#endif
a516 1

a522 1

a528 1
#ifdef FULL_PREHASH
a529 3
#else
			if(original->nsec3_cover)
#endif
a539 4
#ifndef FULL_PREHASH
		struct domain* original_cover;
		int exact;
#endif
a540 1

a541 2
		/* in other words: nsec3 matching closest encloser */
#ifdef FULL_PREHASH
a542 3
#else
		if(original->parent && original->parent->nsec3_cover)
#endif
a544 1

a545 2
		/* in other words: nsec3 matching source of synthesis */
#ifdef FULL_PREHASH
a547 13
#else
		original_cover = original->nsec3_cover;
		if (!original_cover) { /* not exact */
			nsec3_hash_and_find_cover(query->region, NULL,
				domain_dname(original), query->zone,
				&exact, &original_cover);
                }
		if (original_cover) {
	                nsec3_add_rrset(query, answer, AUTHORITY_SECTION,
				original_cover);
		}
#endif

d549 1
a549 2
	else { /* add nsec3 to prove rrset does not exist */
#ifdef FULL_PREHASH
a550 3
#else
		if (original->nsec3_cover != NULL)
#endif
a590 5
#ifndef FULL_PREHASH
	struct domain *cover_domain = NULL;
	int exact = 0;
#endif

d595 1
a595 2
        /* !is_existing: no RR types exist at the QNAME, nor at any descendant of QNAME */
	if(*match && !(*match)->is_existing &&
a603 1
#ifdef FULL_PREHASH
a604 3
#else
		if(query->zone->apex->nsec3_cover)
#endif
a606 1

d608 1
a608 2
		nsec3_add_rrset(query, answer, AUTHORITY_SECTION,
			closest_encloser->nsec3_cover);
d610 2
a611 12
#ifdef FULL_PREHASH
		nsec3_add_rrset(query, answer, AUTHORITY_SECTION,
            query->zone->apex->nsec3_wcard_child_cover);
#else
		cover_domain = NULL;
		nsec3_hash_and_find_cover(query->region, db,
			domain_dname(closest_encloser),
			query->zone, &exact, &cover_domain);
		if (cover_domain)
	                nsec3_add_rrset(query, answer, AUTHORITY_SECTION,
				cover_domain);
#endif
a618 10
	else if(*match && (*match)->is_existing &&
#if 0
		query->qtype != TYPE_NSEC3 &&
#endif
		domain_has_only_NSEC3(*match, query->zone))
	{
		/* this looks like a NSEC3 domain, but is actually an empty non-terminal. */
		nsec3_answer_nodata(query, answer, *match);
		return;
	}
d621 2
a622 3
		nsec3_add_closest_encloser_proof(query, answer,
			closest_encloser, db, qname);
#ifdef FULL_PREHASH
a624 8
#else
		cover_domain = NULL;
		nsec3_hash_and_find_wild_cover(query->region, db,
			closest_encloser, query->zone, &exact, &cover_domain);
		if (cover_domain)
			nsec3_add_rrset(query, answer, AUTHORITY_SECTION,
				cover_domain);
#endif
@


1.1.1.4
log
@import nsd 3.2.10, "cool" jakob@@, also looked over by Brad
@
text
@d956 1
a956 1
	int nsec3_seen = 0;
d963 3
a965 1
			else if(rrset->rrs[0].type != TYPE_RRSIG)
@


1.1.1.5
log
@update to NSD 3.2.14, requested by/ok brad@@
@
text
@a821 1
		assert(par); /* must be provable, thus there must be a parent */
d824 1
a824 1
		while(!par->nsec3_is_exact)
d826 1
a826 1
		while(!par->nsec3_cover)
a830 1
			assert(par); /* parent zone apex must be provable, thus this ends */
d832 1
@


1.1.1.6
log
@Update to NSD 3.2.15, ok brad@@ phessler@@ deraadt@@ also tested by okan@@
@
text
@d438 1
a438 1
		if (walk->nsec3_cover != NULL) {
@


1.1.1.7
log
@import NSD 4.0.0, tests from Dorian Büttner, Patrik Lundin, requested by brad@@
@
text
@d4 1
a4 1
 * Copyright (c) 2001-2006, NLnet Labs. All rights reserved.
d9 1
a9 1
#include "config.h"
d13 1
a19 2
#include "udbzone.h"
#include "options.h"
d21 1
a21 1
#define NSEC3_RDATA_BITMAP 5
a22 62
/* compare nsec3 hashes in nsec3 tree */
static int
cmp_hash_tree(const void* x, const void* y)
{
	const domain_type* a = (const domain_type*)x;
	const domain_type* b = (const domain_type*)y;
	return memcmp(a->nsec3->nsec3_hash, b->nsec3->nsec3_hash,
		NSEC3_HASH_LEN);
}

/* compare nsec3 hashes in nsec3 wc tree */
static int
cmp_wchash_tree(const void* x, const void* y)
{
	const domain_type* a = (const domain_type*)x;
	const domain_type* b = (const domain_type*)y;
	return memcmp(a->nsec3->nsec3_wc_hash, b->nsec3->nsec3_wc_hash,
		NSEC3_HASH_LEN);
}

/* compare nsec3 hashes in nsec3 ds tree */
static int
cmp_dshash_tree(const void* x, const void* y)
{
	const domain_type* a = (const domain_type*)x;
	const domain_type* b = (const domain_type*)y;
	return memcmp(a->nsec3->nsec3_ds_parent_hash,
		b->nsec3->nsec3_ds_parent_hash, NSEC3_HASH_LEN);
}

/* compare base32-encoded nsec3 hashes in nsec3 rr tree, they are
 * stored in the domain name of the node */
static int
cmp_nsec3_tree(const void* x, const void* y)
{
	const domain_type* a = (const domain_type*)x;
	const domain_type* b = (const domain_type*)y;
	/* labelcount + 32long label */
	assert(dname_name(a->dname)[0] == 32);
	assert(dname_name(b->dname)[0] == 32);
	return memcmp(dname_name(a->dname), dname_name(b->dname), 33);
}

void nsec3_zone_trees_create(struct region* region, zone_type* zone)
{
	if(!zone->nsec3tree)
		zone->nsec3tree = rbtree_create(region, cmp_nsec3_tree);
	if(!zone->hashtree)
		zone->hashtree = rbtree_create(region, cmp_hash_tree);
	if(!zone->wchashtree)
		zone->wchashtree = rbtree_create(region, cmp_wchash_tree);
	if(!zone->dshashtree)
		zone->dshashtree = rbtree_create(region, cmp_dshash_tree);
}

void nsec3_hash_tree_clear(struct zone* zone)
{
	hash_tree_clear(zone->nsec3tree);
	hash_tree_clear(zone->hashtree);
	hash_tree_clear(zone->wchashtree);
	hash_tree_clear(zone->dshashtree);
}
d28 1
d36 3
a38 2
const dname_type *
nsec3_b32_create(region_type* region, zone_type* zone, unsigned char* hash)
d40 1
a40 1
	const dname_type* dname;
a41 9
	b32_ntop(hash, SHA_DIGEST_LENGTH, b32, sizeof(b32));
	dname=dname_parse(region, b32);
	dname=dname_concatenate(region, dname, domain_dname(zone->apex));
	return dname;
}

void
nsec3_hash_and_store(zone_type* zone, const dname_type* dname, uint8_t* store)
{
d46 1
a46 1
	detect_nsec3_params(zone->nsec3_param, &nsec3_salt,
d48 6
a53 2
	iterated_hash((unsigned char*)store, nsec3_salt, nsec3_saltlength,
		dname_name(dname), dname->name_size, nsec3_iterations);
d56 3
a58 6
#define STORE_HASH(x,y) memmove(domain->nsec3->x,y,NSEC3_HASH_LEN); domain->nsec3->have_##x =1;

/** find hash or create it and store it */
static void
nsec3_lookup_hash_and_wc(zone_type* zone, const dname_type* dname,
	domain_type* domain, region_type* tmpregion)
d60 2
a61 23
	const dname_type* wcard;
	if(domain->nsec3->have_nsec3_hash && domain->nsec3->have_nsec3_wc_hash) {
		return;
	}
	/* lookup failed; disk failure or so */
	nsec3_hash_and_store(zone, dname, domain->nsec3->nsec3_hash);
	domain->nsec3->have_nsec3_hash = 1;
	wcard = dname_parse(tmpregion, "*");
	wcard = dname_concatenate(tmpregion, wcard, dname);
	nsec3_hash_and_store(zone, wcard, domain->nsec3->nsec3_wc_hash);
	domain->nsec3->have_nsec3_wc_hash = 1;
}

static void
nsec3_lookup_hash_ds(zone_type* zone, const dname_type* dname,
	domain_type* domain)
{
	if(domain->nsec3->have_nsec3_ds_parent_hash) {
		return;
	}
	/* lookup failed; disk failure or so */
	nsec3_hash_and_store(zone, dname, domain->nsec3->nsec3_ds_parent_hash);
	domain->nsec3->have_nsec3_ds_parent_hash = 1;
d67 4
a70 5
	if(rdata_atom_size(rr->rdatas[NSEC3_RDATA_BITMAP]) >= 3 && /* has types in bitmap */
		rdata_atom_data(rr->rdatas[NSEC3_RDATA_BITMAP])[0] == 0 && /* first window = 0, */
		/* [1]: bitmap length must be >= 1 */
		/* [2]: bit[6] = SOA, thus mask first bitmap octet with 0x02 */
		rdata_atom_data(rr->rdatas[NSEC3_RDATA_BITMAP])[2]&0x02) { /* SOA bit set */
a71 1
	}
d76 1
a76 1
check_apex_soa(namedb_type* namedb, zone_type *zone)
d78 1
a78 1
	uint8_t h[NSEC3_HASH_LEN];
a79 3
	const dname_type* hashed_apex, *dname = domain_dname(zone->apex);
	unsigned j;
	rrset_type* nsec3_rrset;
d81 6
a86 2

	nsec3_hash_and_store(zone, dname, h);
d88 58
a145 23
	hashed_apex = nsec3_b32_create(tmpregion, zone, h);
	domain = domain_table_find(namedb->domains, hashed_apex);
	if(!domain) {
		log_msg(LOG_ERR, "%s NSEC3PARAM entry has no hash(apex).",
			domain_to_string(zone->apex));
		log_msg(LOG_ERR, "hash(apex)= %s",
			dname_to_string(hashed_apex, NULL));
		region_destroy(tmpregion);
		return NULL;
	}
	nsec3_rrset = domain_find_rrset(domain, zone, TYPE_NSEC3);
	if(!nsec3_rrset) {
		log_msg(LOG_ERR, "%s NSEC3PARAM entry: hash(apex) has no NSEC3 RRset.",
			domain_to_string(zone->apex));
		log_msg(LOG_ERR, "hash(apex)= %s",
			dname_to_string(hashed_apex, NULL));
		region_destroy(tmpregion);
		return NULL;
	}
	for(j=0; j<nsec3_rrset->rr_count; j++) {
		if(nsec3_has_soa(&nsec3_rrset->rrs[j])) {
			region_destroy(tmpregion);
			return &nsec3_rrset->rrs[j];
d147 2
a149 4
	log_msg(LOG_ERR, "%s NSEC3PARAM entry: hash(apex) NSEC3 has no SOA flag.",
		domain_to_string(zone->apex));
	log_msg(LOG_ERR, "hash(apex)= %s",
		dname_to_string(hashed_apex, NULL));
d154 5
a158 2
static struct rr*
udb_zone_find_nsec3param(udb_base* udb, udb_ptr* uz, struct zone* z)
d160 9
a168 14
	udb_ptr urr;
	unsigned i;
	rrset_type* rrset = domain_find_rrset(z->apex, z, TYPE_NSEC3PARAM);
	if(!rrset) /* no NSEC3PARAM in mem */
		return NULL;
	udb_ptr_new(&urr, udb, &ZONE(uz)->nsec3param);
	if(!urr.data || RR(&urr)->len < 5) {
		/* no NSEC3PARAM in udb */
		udb_ptr_unlink(&urr, udb);
		return NULL;
	}
	/* find matching NSEC3PARAM RR in memory */
	for(i=0; i<rrset->rr_count; i++) {
		/* if this RR matches the udb RR then we are done */
d170 15
a184 10
		if(RR(&urr)->wire[0] == rdata_atom_data(rd[0])[0] && /*alg*/
		   RR(&urr)->wire[1] == rdata_atom_data(rd[1])[0] && /*flg*/
		   RR(&urr)->wire[2] == rdata_atom_data(rd[2])[0] && /*iter*/
		   RR(&urr)->wire[3] == rdata_atom_data(rd[2])[1] &&
		   RR(&urr)->wire[4] == rdata_atom_data(rd[3])[0] && /*slen*/
		   RR(&urr)->len >= 5 + RR(&urr)->wire[4] &&
		   memcmp(RR(&urr)->wire+5, rdata_atom_data(rd[3])+1,
			rdata_atom_data(rd[3])[0]) == 0) {
			udb_ptr_unlink(&urr, udb);
			return &rrset->rrs[i];
d187 1
a187 9
	udb_ptr_unlink(&urr, udb);
	return NULL;
}

void
nsec3_find_zone_param(struct namedb* db, struct zone* zone, udb_ptr* z)
{
	/* get nsec3param RR from udb */
	zone->nsec3_param = udb_zone_find_nsec3param(db->udb, z, zone);
d190 1
a190 16
/* check params ok for one RR */
static int
nsec3_rdata_params_ok(rdata_atom_type* prd, rdata_atom_type* rd)
{
	return (rdata_atom_data(rd[0])[0] ==
		rdata_atom_data(prd[0])[0] && /* hash algo */
	   rdata_atom_data(rd[2])[0] ==
		rdata_atom_data(prd[2])[0] && /* iterations 0 */
	   rdata_atom_data(rd[2])[1] ==
		rdata_atom_data(prd[2])[1] && /* iterations 1 */
	   rdata_atom_data(rd[3])[0] ==
		rdata_atom_data(prd[3])[0] && /* salt length */
	   memcmp(rdata_atom_data(rd[3])+1,
		rdata_atom_data(prd[3])+1, rdata_atom_data(rd[3])[0])
		== 0 );
}
d193 2
a194 1
nsec3_rr_uses_params(rr_type* rr, zone_type* zone)
d196 5
a200 4
	if(!rr || rr->rdata_count < 4)
		return 0;
	return nsec3_rdata_params_ok(zone->nsec3_param->rdatas, rr->rdatas);
}
d202 2
a203 14
int
nsec3_in_chain_count(domain_type* domain, zone_type* zone)
{
	rrset_type* rrset = domain_find_rrset(domain, zone, TYPE_NSEC3);
	unsigned i;
	int count = 0;
	if(!rrset || !zone->nsec3_param)
		return 0; /* no NSEC3s, none in the chain */
	for(i=0; i<rrset->rr_count; i++) {
		if(nsec3_rr_uses_params(&rrset->rrs[i], zone))
			count++;
	}
	return count;
}
d205 9
a213 11
struct domain*
nsec3_chain_find_prev(struct zone* zone, struct domain* domain)
{
	if(domain->nsec3 && domain->nsec3->nsec3_node.key) {
		/* see if there is a prev */
		rbnode_t* r = rbtree_previous(&domain->nsec3->nsec3_node);
		if(r != RBTREE_NULL) {
			/* found a previous, which is not the root-node in
			 * the prehash tree (and thus points to the tree) */
			return (domain_type*)r->key;
		}
a214 4
	if(zone->nsec3_last)
		return zone->nsec3_last;
	return NULL;
}
d216 11
a226 34
void
nsec3_clear_precompile(struct namedb* db, zone_type* zone)
{
	domain_type* walk;
	/* clear prehash items (there must not be items for other zones) */
	prehash_clear(db->domains);
	/* clear trees */
	hash_tree_clear(zone->nsec3tree);
	hash_tree_clear(zone->hashtree);
	hash_tree_clear(zone->wchashtree);
	hash_tree_clear(zone->dshashtree);
	/* wipe hashes */

	/* wipe precompile */
	walk = zone->apex;
	while(walk && domain_is_subdomain(walk, zone->apex)) {
		if(walk->nsec3) {
			if(nsec3_domain_part_of_zone(walk, zone)) {
				walk->nsec3->nsec3_node.key = NULL;
				walk->nsec3->nsec3_cover = NULL;
				walk->nsec3->nsec3_wcard_child_cover = NULL;
				walk->nsec3->nsec3_is_exact = 0;
				walk->nsec3->have_nsec3_hash = 0;
				walk->nsec3->have_nsec3_wc_hash = 0;
				walk->nsec3->hash_node.key = NULL;
				walk->nsec3->wchash_node.key = NULL;
			}
			if(!walk->parent ||
				nsec3_domain_part_of_zone(walk->parent, zone)) {
				walk->nsec3->nsec3_ds_parent_cover = NULL;
				walk->nsec3->nsec3_ds_parent_is_exact = 0;
				walk->nsec3->have_nsec3_ds_parent_hash = 0;
				walk->nsec3->dshash_node.key = NULL;
			}
d228 1
a228 1
		walk = domain_next(walk);
d230 12
a241 11
	zone->nsec3_last = NULL;
}

/* see if domain name is part of (existing names in) the nsec3 zone */
int
nsec3_domain_part_of_zone(domain_type* d, zone_type* z)
{
	while(d) {
		if(d->is_apex)
			return (z->apex == d); /* zonecut, if right zone*/
		d = d->parent;
d243 1
d247 1
a247 7
/* condition when a domain is precompiled */
int
nsec3_condition_hash(domain_type* d, zone_type* z)
{
	return d->is_existing && !domain_has_only_NSEC3(d, z) &&
		nsec3_domain_part_of_zone(d, z) && !domain_is_glue(d, z);
}
a248 1
/* condition when a domain is ds precompiled */
d250 2
a251 1
nsec3_condition_dshash(domain_type* d, zone_type* z)
d253 1
a253 43
	return d->is_existing && !domain_has_only_NSEC3(d, z) &&
		(domain_find_rrset(d, z, TYPE_DS) ||
		domain_find_rrset(d, z, TYPE_NS)) && d != z->apex;
}

zone_type*
nsec3_tree_zone(namedb_type* db, domain_type* d)
{
	/* see nsec3_domain_part_of_zone; domains part of zone that has
	 * apex above them */
	/* this does not use the rrset->zone pointer because there may be
	 * no rrsets left at apex (no SOA), e.g. during IXFR */
	while(d) {
		if(d->is_apex) {
			/* we can try a SOA if its present (faster than tree)*/
			/* DNSKEY and NSEC3PARAM are also good indicators */
			rrset_type *rrset;
			for (rrset = d->rrsets; rrset; rrset = rrset->next)
				if (rrset_rrtype(rrset) == TYPE_SOA ||
					rrset_rrtype(rrset) == TYPE_DNSKEY ||
					rrset_rrtype(rrset) == TYPE_NSEC3PARAM)
					return rrset->zone;
			return namedb_find_zone(db, d->dname);
		}
		d = d->parent;
	}
	return NULL;
}

zone_type*
nsec3_tree_dszone(namedb_type* db, domain_type* d)
{
	/* the DStree does not contain nodes with d==z->apex */
	if(d->is_apex)
		d = d->parent;
	return nsec3_tree_zone(db, d);
}

int
nsec3_find_cover(zone_type* zone, uint8_t* hash, size_t hashlen,
	domain_type** result)
{
	rbnode_t* r = NULL;
a254 11
	domain_type d;
	uint8_t n[48];

	/* nsec3tree is sorted by b32 encoded domain name of the NSEC3 */
	b32_ntop(hash, hashlen, (char*)(n+5), sizeof(n)-5);
	d.dname = (dname_type*)n;
	n[0] = 34; /* name_size */
	n[1] = 2; /* label_count */
	n[2] = 0; /* label_offset[0] */
	n[3] = 0; /* label_offset[1] */
	n[4] = 32; /* label-size[0] */
d257 2
a258 1
	assert(zone->nsec3_param && zone->nsec3tree);
d260 31
a290 6
	exact = rbtree_find_less_equal(zone->nsec3tree, &d, &r);
	if(r) {
		*result = (domain_type*)r->key;
	} else {
		*result = zone->nsec3_last;
	}
d293 1
d295 4
a298 3
void
nsec3_precompile_domain(struct namedb* db, struct domain* domain,
	struct zone* zone, region_type* tmpregion)
d300 2
d303 8
a310 5
	int exact;
	allocate_domain_nsec3(db->domains, domain);

	/* hash it */
	nsec3_lookup_hash_and_wc(zone, domain_dname(domain), domain, tmpregion);
d312 3
a314 10
	/* add into tree */
	zone_add_domain_in_hash_tree(db->region, &zone->hashtree,
		cmp_hash_tree, domain, &domain->nsec3->hash_node);
	zone_add_domain_in_hash_tree(db->region, &zone->wchashtree,
		cmp_wchash_tree, domain, &domain->nsec3->wchash_node);

	/* lookup in tree cover ptr (or exact) */
	exact = nsec3_find_cover(zone, domain->nsec3->nsec3_hash,
		sizeof(domain->nsec3->nsec3_hash), &result);
	domain->nsec3->nsec3_cover = result;
d316 2
a317 2
		domain->nsec3->nsec3_is_exact = 1;
	else	domain->nsec3->nsec3_is_exact = 0;
d320 18
a337 3
	exact = nsec3_find_cover(zone, domain->nsec3->nsec3_wc_hash,
		sizeof(domain->nsec3->nsec3_wc_hash), &result);
	domain->nsec3->nsec3_wcard_child_cover = result;
d340 5
a344 3
void
nsec3_precompile_domain_ds(struct namedb* db, struct domain* domain,
	struct zone* zone)
a345 1
	domain_type* result = 0;
d347 14
a360 1
	allocate_domain_nsec3(db->domains, domain);
d362 5
a366 13
	/* hash it : it could have different hash parameters then the
	   other hash for this domain name */
	nsec3_lookup_hash_ds(zone, domain_dname(domain), domain);
	/* lookup in tree cover ptr (or exact) */
	exact = nsec3_find_cover(zone, domain->nsec3->nsec3_ds_parent_hash,
		sizeof(domain->nsec3->nsec3_ds_parent_hash), &result);
	if(exact)
		domain->nsec3->nsec3_ds_parent_is_exact = 1;
	else 	domain->nsec3->nsec3_ds_parent_is_exact = 0;
	domain->nsec3->nsec3_ds_parent_cover = result;
	/* add into tree */
	zone_add_domain_in_hash_tree(db->region, &zone->dshashtree,
		cmp_dshash_tree, domain, &domain->nsec3->dshash_node);
d369 1
d371 2
a372 1
parse_nsec3_name(const dname_type* dname, uint8_t* hash, size_t buflen)
d374 7
a380 8
	/* first label must be the match, */
	size_t lablen = (buflen-1) * 8 / 5;
	const uint8_t* wire = dname_name(dname);
	assert(lablen == 32 && buflen == NSEC3_HASH_LEN+1);
	/* labels of length 32 for SHA1, and must have space+1 for convert */
	if(wire[0] != lablen) {
		/* not NSEC3 */
		memset(hash, 0, buflen);
d383 8
a390 1
	(void)b32_pton((char*)wire+1, hash, buflen);
d392 1
d394 3
a396 3
void
nsec3_precompile_nsec3rr(namedb_type* db, struct domain* domain,
	struct zone* zone)
d398 3
a400 7
	allocate_domain_nsec3(db->domains, domain);
	/* add into nsec3tree */
	zone_add_domain_in_hash_tree(db->region, &zone->nsec3tree,
		cmp_nsec3_tree, domain, &domain->nsec3->nsec3_node);
	/* fixup the last in the zone */
	if(rbtree_last(zone->nsec3tree)->key == domain) {
		zone->nsec3_last = domain;
d402 5
d410 1
a410 1
nsec3_precompile_newparam(namedb_type* db, zone_type* zone)
d412 52
a463 26
	region_type* tmpregion = region_create(xalloc, free);
	domain_type* walk;
	time_t s = time(NULL);
	unsigned n = 0, c = 0;

	/* add nsec3s of chain to nsec3tree */
	for(walk=zone->apex; walk && domain_is_subdomain(walk, zone->apex);
		walk = domain_next(walk)) {
		n++;
		if(nsec3_in_chain_count(walk, zone) != 0) {
			nsec3_precompile_nsec3rr(db, walk, zone);
		}
	}
	/* hash and precompile zone */
	for(walk=zone->apex; walk && domain_is_subdomain(walk, zone->apex);
		walk = domain_next(walk)) {
		if(nsec3_condition_hash(walk, zone)) {
			nsec3_precompile_domain(db, walk, zone, tmpregion);
			region_free_all(tmpregion);
		}
		if(nsec3_condition_dshash(walk, zone))
			nsec3_precompile_domain_ds(db, walk, zone);
		if(++c % ZONEC_PCT_COUNT == 0 && time(NULL) > s + ZONEC_PCT_TIME) {
			s = time(NULL);
			VERBOSITY(1, (LOG_INFO, "nsec3 %s %d %%",
				zone->opts->name, c*100/n));
d465 20
d486 2
a487 1
	region_destroy(tmpregion);
d491 1
a491 1
prehash_zone_complete(struct namedb* db, struct zone* zone)
d493 4
a496 1
	udb_ptr udbz;
a497 2
	/* robust clear it */
	nsec3_clear_precompile(db, zone);
d499 2
a500 9

	assert(db && zone);
	if(!udb_zone_search(db->udb, &udbz, dname_name(domain_dname(
		zone->apex)), domain_dname(zone->apex)->name_size)) {
		udb_ptr_init(&udbz, db->udb); /* zero the ptr */
	}
	nsec3_find_zone_param(db, zone, &udbz);
	if(!zone->nsec3_param || !check_apex_soa(db, zone)) {
		zone->nsec3_param = NULL;
a501 1
		udb_ptr_unlink(&udbz, db->udb);
d504 60
a563 2
	udb_ptr_unlink(&udbz, db->udb);
	nsec3_precompile_newparam(db, zone);
d566 1
a566 3
static void
init_lookup_key_hash_tree(domain_type* d, uint8_t* hash)
{ memcpy(d->nsec3->nsec3_hash, hash, NSEC3_HASH_LEN); }
d569 6
a574 2
init_lookup_key_wc_tree(domain_type* d, uint8_t* hash)
{ memcpy(d->nsec3->nsec3_wc_hash, hash, NSEC3_HASH_LEN); }
d576 7
a582 3
static void
init_lookup_key_ds_tree(domain_type* d, uint8_t* hash)
{ memcpy(d->nsec3->nsec3_ds_parent_hash, hash, NSEC3_HASH_LEN); }
d584 16
a599 10
/* find first in the tree and true if the first to process it */
static int
process_first(rbtree_t* tree, uint8_t* hash, rbnode_t** p,
	void (*init)(domain_type*, uint8_t*))
{
	domain_type d;
	struct nsec3_domain_data n;
	if(!tree) {
		*p = RBTREE_NULL;
		return 0;
d601 30
a630 5
	d.nsec3 = &n;
	init(&d, hash);
	if(rbtree_find_less_equal(tree, &d, p)) {
		/* found an exact match */
		return 1;
d632 1
a632 7
	if(!*p) /* before first, go from first */
		*p = rbtree_first(tree);
	/* the inexact, smaller, match we found, does not itself need to
	 * be edited */
	else
		*p = rbtree_next(*p); /* if this becomes NULL, nothing to do */
	return 0;
d634 1
d636 2
a637 4
/* set end pointer if possible */
static void
process_end(rbtree_t* tree, uint8_t* hash, rbnode_t** p,
	void (*init)(domain_type*, uint8_t*))
d639 9
a647 52
	domain_type d;
	struct nsec3_domain_data n;
	if(!tree) {
		*p = RBTREE_NULL;
		return;
	}
	d.nsec3 = &n;
	init(&d, hash);
	if(rbtree_find_less_equal(tree, &d, p)) {
		/* an exact match, fine, because this one does not get
		 * processed */
		return;
	}
	/* inexact element, but if NULL, until first element in tree */
	if(!*p) {
		*p = rbtree_first(tree);
		return;
	}
	/* inexact match, use next element, if possible, the smaller
	 * element is part of the range */
	*p = rbtree_next(*p);
	/* if next returns null, we go until the end of the tree */
}

/* prehash domains in hash range start to end */
static void
process_range(zone_type* zone, domain_type* start,
	domain_type* end, domain_type* nsec3)
{
	/* start NULL means from first in tree */
	/* end NULL means to last in tree */
	rbnode_t *p = RBTREE_NULL, *pwc = RBTREE_NULL, *pds = RBTREE_NULL;
	rbnode_t *p_end = RBTREE_NULL, *pwc_end = RBTREE_NULL, *pds_end = RBTREE_NULL;
	/* because the nodes are on the prehashlist, the domain->nsec3 is
	 * already allocated, and we need not allocate it here */
	/* set start */
	if(start) {
		uint8_t hash[NSEC3_HASH_LEN+1];
		parse_nsec3_name(domain_dname(start), hash, sizeof(hash));
		/* if exact match on first, set is_exact */
		if(process_first(zone->hashtree, hash, &p, init_lookup_key_hash_tree)) {
			((domain_type*)(p->key))->nsec3->nsec3_cover = nsec3;
			((domain_type*)(p->key))->nsec3->nsec3_is_exact = 1;
			p = rbtree_next(p);
		}
		(void)process_first(zone->wchashtree, hash, &pwc, init_lookup_key_wc_tree);
		if(process_first(zone->dshashtree, hash, &pds, init_lookup_key_ds_tree)){
			((domain_type*)(pds->key))->nsec3->
				nsec3_ds_parent_cover = nsec3;
			((domain_type*)(pds->key))->nsec3->
				nsec3_ds_parent_is_exact = 1;
			pds = rbtree_next(pds);
a648 34
	} else {
		if(zone->hashtree)
			p = rbtree_first(zone->hashtree);
		if(zone->wchashtree)
			pwc = rbtree_first(zone->wchashtree);
		if(zone->dshashtree)
			pds = rbtree_first(zone->dshashtree);
	}
	/* set end */
	if(end) {
		uint8_t hash[NSEC3_HASH_LEN+1];
		parse_nsec3_name(domain_dname(end), hash, sizeof(hash));
		process_end(zone->hashtree, hash, &p_end, init_lookup_key_hash_tree);
		process_end(zone->wchashtree, hash, &pwc_end, init_lookup_key_wc_tree);
		process_end(zone->dshashtree, hash, &pds_end, init_lookup_key_ds_tree);
	}

	/* precompile */
	while(p != RBTREE_NULL && p != p_end) {
		((domain_type*)(p->key))->nsec3->nsec3_cover = nsec3;
		((domain_type*)(p->key))->nsec3->nsec3_is_exact = 0;
		p = rbtree_next(p);
	}
	while(pwc != RBTREE_NULL && pwc != pwc_end) {
		((domain_type*)(pwc->key))->nsec3->
			nsec3_wcard_child_cover = nsec3;
		pwc = rbtree_next(pwc);
	}
	while(pds != RBTREE_NULL && pds != pds_end) {
		((domain_type*)(pds->key))->nsec3->
			nsec3_ds_parent_cover = nsec3;
		((domain_type*)(pds->key))->nsec3->
			nsec3_ds_parent_is_exact = 0;
		pds = rbtree_next(pds);
d650 4
d656 18
a673 27
/* prehash a domain from the prehash list */
static void
process_prehash_domain(domain_type* domain, zone_type* zone)
{
	/* in the hashtree, wchashtree, dshashtree walk through to next NSEC3
	 * and set precompile pointers to point to this domain (or is_exact),
	 * the first domain can be is_exact. If it is the last NSEC3, also
	 * process the initial part (before the first) */
	rbnode_t* nx;

	/* this domain is part of the prehash list and therefore the
	 * domain->nsec3 is allocated and need not be allocated here */
	assert(domain->nsec3 && domain->nsec3->nsec3_node.key);
	nx = rbtree_next(&domain->nsec3->nsec3_node);
	if(nx != RBTREE_NULL) {
		/* process until next nsec3 */
		domain_type* end = (domain_type*)nx->key;
		process_range(zone, domain, end, domain);
	} else {
		/* first is root, but then comes the first nsec3 */
		domain_type* first = (domain_type*)(rbtree_first(
			zone->nsec3tree)->key);
		/* last in zone */
		process_range(zone, domain, NULL, domain);
		/* also process before first in zone */
		process_range(zone, NULL, first, domain);
	}
d676 4
a679 1
void prehash_zone(struct namedb* db, struct zone* zone)
d681 17
a697 4
	domain_type* d;
	if(!zone->nsec3_param) {
		prehash_clear(db->domains);
		return;
d699 2
a700 6
	/* process prehash list */
	for(d = db->domains->prehash_list; d; d = d->nsec3->prehash_next) {
		process_prehash_domain(d, zone);
	}
	/* clear prehash list */
	prehash_clear(db->domains);
a701 5
	if(!check_apex_soa(db, zone)) {
		zone->nsec3_param = NULL;
		zone->nsec3_last = NULL;
	}
}
d705 1
a705 1
nsec3_add_rrset(struct query* query, struct answer* answer,
d717 2
a718 2
nsec3_add_nonexist_proof(struct query* query, struct answer* answer,
        struct domain* encloser, const dname_type* qname)
d720 7
a726 3
	uint8_t hash[NSEC3_HASH_LEN];
	const dname_type* to_prove;
	domain_type* cover=0;
d733 8
a740 2
	nsec3_hash_and_store(query->zone, to_prove, hash);
	if(nsec3_find_cover(query->zone, hash, sizeof(hash), &cover))
d749 1
a749 2
	else
	{
d757 3
a759 2
	struct query* query, struct answer* answer,
	struct domain* closest_encloser, const dname_type* qname)
d764 1
a764 1
	nsec3_add_nonexist_proof(query, answer, closest_encloser, qname);
d766 5
a770 1
	if(closest_encloser->nsec3 && closest_encloser->nsec3->nsec3_is_exact)
d772 1
a772 1
			closest_encloser->nsec3->nsec3_cover);
d775 1
d778 1
a778 1
        struct domain *wildcard, const dname_type* qname)
d782 1
a782 1
	if(!query->zone->nsec3_param)
d784 1
a784 1
	nsec3_add_nonexist_proof(query, answer, wildcard, qname);
d787 1
d792 4
d798 3
a800 1
	if(domain->nsec3 && domain->nsec3->nsec3_ds_parent_is_exact) {
d803 13
a815 2
			domain->nsec3->nsec3_ds_parent_cover);
	} else if (!delegpt && domain->nsec3 && domain->nsec3->nsec3_is_exact) {
d817 1
a817 1
			domain->nsec3->nsec3_cover);
d821 2
a822 1
		domain_type* prev_par = 0;
d824 5
a828 1
		while(par && (!par->nsec3 || !par->nsec3->nsec3_is_exact))
d832 1
a833 2
		assert(par); /* parent zone apex must be provable, thus this ends */
		if(!par->nsec3) return;
d835 1
a835 1
			par->nsec3->nsec3_cover);
d839 3
a841 3
		if(prev_par && prev_par->nsec3) {
			assert(prev_par != domain &&
				!prev_par->nsec3->nsec3_is_exact);
d843 11
a853 1
				prev_par->nsec3->nsec3_cover);
d855 2
d859 7
a865 3
		if(domain->nsec3)
			nsec3_add_rrset(query, answer, AUTHORITY_SECTION,
				domain->nsec3->nsec3_ds_parent_cover);
d869 1
d871 2
a872 2
nsec3_answer_nodata(struct query* query, struct answer* answer,
	struct domain* original)
d874 1
a874 1
	if(!query->zone->nsec3_param)
d876 1
d883 5
a887 1
			if(original->nsec3 && original->nsec3->nsec3_is_exact)
d889 1
a889 1
					original->nsec3->nsec3_cover);
d898 4
d906 5
a910 2
		if(original->parent && original->parent->nsec3 &&
			original->parent->nsec3->nsec3_is_exact)
d912 2
a913 1
				original->parent->nsec3->nsec3_cover);
d916 16
a931 3
		if(original->nsec3)
			nsec3_add_rrset(query, answer, AUTHORITY_SECTION,
				original->nsec3->nsec3_cover);
d933 6
a938 2
	else {	/* add nsec3 to prove rrset does not exist */
		if(original->nsec3 && original->nsec3->nsec3_is_exact) {
d940 1
a940 2
				original->nsec3->nsec3_cover);
		}
d947 1
a947 1
	if(!query->zone->nsec3_param)
d975 1
a975 1
	const dname_type* qname)
d977 6
a982 1
	if(!query->zone->nsec3_param)
d996 5
a1000 2
		if(query->zone->apex->nsec3 &&
			query->zone->apex->nsec3->nsec3_is_exact)
d1002 2
a1003 1
				query->zone->apex->nsec3->nsec3_cover);
d1005 2
a1006 2
		if(closest_encloser->nsec3)
			nsec3_add_rrset(query, answer, AUTHORITY_SECTION, closest_encloser->nsec3->nsec3_cover);
d1008 12
a1019 3
		if(query->zone->apex->nsec3)
			nsec3_add_rrset(query, answer, AUTHORITY_SECTION,
				query->zone->apex->nsec3->nsec3_wcard_child_cover);
d1039 10
a1048 3
		nsec3_add_closest_encloser_proof(query, answer, closest_encloser,
			qname);
		if(closest_encloser->nsec3)
d1050 2
a1051 1
				closest_encloser->nsec3->nsec3_wcard_child_cover);
@


1.1.1.8
log
@update to NSD 4.1.0, ok sthen@@
@
text
@a229 1
		if(rrset->rrs[i].rdata_count < 4) continue;
a245 39
static struct rr*
db_find_nsec3param(struct zone* z, struct rr* avoid_rr)
{
	unsigned i;
	rrset_type* rrset = domain_find_rrset(z->apex, z, TYPE_NSEC3PARAM);
	if(!rrset) /* no NSEC3PARAM in mem */
		return NULL;
	/* find first nsec3param we can support (SHA1, no flags) */
	for(i=0; i<rrset->rr_count; i++) {
		rdata_atom_type* rd = rrset->rrs[i].rdatas;
		/* do not use the RR that is going to be deleted (in IXFR) */
		if(&rrset->rrs[i] == avoid_rr) continue;
		if(rrset->rrs[i].rdata_count < 4) continue;
		if(rdata_atom_data(rd[0])[0] == NSEC3_SHA1_HASH &&
			rdata_atom_data(rd[1])[0] == 0) {
			if(2 <= verbosity) {
				char str[MAX_RDLENGTH*2+16];
				char* p;
				p = str+snprintf(str, sizeof(str), "%u %u %u ",
					(unsigned)rdata_atom_data(rd[0])[0],
					(unsigned)rdata_atom_data(rd[1])[0],
					(unsigned)read_uint16(rdata_atom_data(rd[2])));
				if(rdata_atom_data(rd[3])[0] == 0)
					*p++ = '-';
				else {
					p += hex_ntop(rdata_atom_data(rd[3])+1,
						rdata_atom_data(rd[3])[0], p,
						sizeof(str)-strlen(str)-1);
				}
				*p = 0;
				VERBOSITY(2, (LOG_INFO, "rehash of zone %s with parameters %s",
					domain_to_string(z->apex), str));
			}
			return &rrset->rrs[i];
		}
	}
	return NULL;
}

d247 1
a247 2
nsec3_find_zone_param(struct namedb* db, struct zone* zone, udb_ptr* z,
	struct rr* avoid_rr)
d250 1
a250 5
	if(db->udb)
		zone->nsec3_param = udb_zone_find_nsec3param(db->udb, z, zone);
	/* no db, get from memory, avoid using the rr that is going to be
	 * deleted, avoid_rr */
	else	zone->nsec3_param = db_find_nsec3param(zone, avoid_rr);
d532 1
a532 1
	unsigned long n = 0, c = 0;
d554 1
a554 2
				zone->opts->name,
				(int)(c*((unsigned long)100)/n)));
d570 3
a572 5
	if(db->udb) {
		if(!udb_zone_search(db->udb, &udbz, dname_name(domain_dname(
			zone->apex)), domain_dname(zone->apex)->name_size)) {
			udb_ptr_init(&udbz, db->udb); /* zero the ptr */
		}
d574 1
a574 1
	nsec3_find_zone_param(db, zone, &udbz, NULL);
d578 1
a578 2
		if(db->udb)
			udb_ptr_unlink(&udbz, db->udb);
d581 1
a581 2
	if(db->udb)
		udb_ptr_unlink(&udbz, db->udb);
@


