head	1.34;
access;
symbols
	OPENBSD_6_1:1.34.0.2
	OPENBSD_6_1_BASE:1.34
	OPENBSD_6_0:1.33.0.4
	OPENBSD_6_0_BASE:1.33
	OPENBSD_5_9:1.33.0.2
	OPENBSD_5_9_BASE:1.33
	OPENBSD_5_8:1.29.0.4
	OPENBSD_5_8_BASE:1.29
	OPENBSD_5_4:1.20.0.2
	OPENBSD_5_4_BASE:1.20
	OPENBSD_5_5:1.24.0.4
	OPENBSD_5_5_BASE:1.24
	OPENBSD_5_6:1.26.0.4
	OPENBSD_5_6_BASE:1.26
	OPENBSD_5_7:1.27.0.2
	OPENBSD_5_7_BASE:1.27;
locks; strict;
comment	@ * @;


1.34
date	2016.09.04.14.39.32;	author florian;	state Exp;
branches;
next	1.33;
commitid	bLoZxZ4C72nCvJ45;

1.33
date	2015.10.24.15.31.00;	author jca;	state Exp;
branches;
next	1.32;
commitid	51gbctmQWKCS0D3G;

1.32
date	2015.10.16.05.55.23;	author doug;	state Exp;
branches;
next	1.31;
commitid	TNwKBESZJIutpg4X;

1.31
date	2015.08.20.11.06.35;	author dlg;	state Exp;
branches;
next	1.30;
commitid	Sep37qREHgrussyX;

1.30
date	2015.08.20.10.54.35;	author dlg;	state Exp;
branches;
next	1.29;
commitid	UKprtNmYHQLKdTZ3;

1.29
date	2015.08.04.11.05.18;	author dlg;	state Exp;
branches;
next	1.28;
commitid	CkJxQgMEVWamKoeK;

1.28
date	2015.03.27.07.16.38;	author dlg;	state Exp;
branches;
next	1.27;
commitid	Zebxef4QblDrR4Wy;

1.27
date	2015.01.16.06.40.17;	author deraadt;	state Exp;
branches;
next	1.26;
commitid	Uu5nFG3wCl0LACBb;

1.26
date	2014.07.13.17.53.41;	author claudio;	state Exp;
branches;
next	1.25;
commitid	rEoFYb2vIxMe1XD6;

1.25
date	2014.07.08.17.12.37;	author tobias;	state Exp;
branches;
next	1.24;
commitid	dnP5xSiQWKi48HJU;

1.24
date	2014.01.07.00.11.11;	author dlg;	state Exp;
branches;
next	1.23;

1.23
date	2013.11.21.03.09.07;	author dlg;	state Exp;
branches;
next	1.22;

1.22
date	2013.11.12.19.47.52;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2013.10.24.02.55.50;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2013.07.17.15.38.48;	author okan;	state Exp;
branches;
next	1.19;

1.19
date	2013.04.29.06.32.11;	author jmc;	state Exp;
branches;
next	1.18;

1.18
date	2013.04.29.04.17.58;	author dlg;	state Exp;
branches;
next	1.17;

1.17
date	2013.04.23.21.18.57;	author sthen;	state Exp;
branches;
next	1.16;

1.16
date	2013.04.23.10.33.06;	author dlg;	state Exp;
branches;
next	1.15;

1.15
date	2013.04.23.06.17.07;	author dlg;	state Exp;
branches;
next	1.14;

1.14
date	2013.04.23.05.39.32;	author dlg;	state Exp;
branches;
next	1.13;

1.13
date	2013.04.23.05.37.35;	author dlg;	state Exp;
branches;
next	1.12;

1.12
date	2013.04.23.01.55.45;	author dlg;	state Exp;
branches;
next	1.11;

1.11
date	2013.04.23.01.46.39;	author dlg;	state Exp;
branches;
next	1.10;

1.10
date	2013.04.22.05.08.46;	author dlg;	state Exp;
branches;
next	1.9;

1.9
date	2013.04.05.23.16.41;	author florian;	state Exp;
branches;
next	1.8;

1.8
date	2013.03.20.03.58.09;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2013.03.20.00.23.53;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2013.03.19.00.44.03;	author dlg;	state Exp;
branches;
next	1.5;

1.5
date	2013.03.18.04.53.23;	author dlg;	state Exp;
branches;
next	1.4;

1.4
date	2013.03.18.04.50.01;	author dlg;	state Exp;
branches;
next	1.3;

1.3
date	2013.03.18.04.43.55;	author dlg;	state Exp;
branches;
next	1.2;

1.2
date	2013.03.18.01.20.46;	author dlg;	state Exp;
branches;
next	1.1;

1.1
date	2013.03.18.00.34.48;	author dlg;	state Exp;
branches;
next	;


desc
@@


1.34
log
@Add format attribute to logger functions.
Input & OK benno@@
@
text
@/*	$OpenBSD: identd.c,v 1.33 2015/10/24 15:31:00 jca Exp $ */

/*
 * Copyright (c) 2013 David Gwynne <dlg@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/ioctl.h>
#include <sys/socket.h>
#include <sys/socketvar.h>
#include <sys/stat.h>
#include <sys/sysctl.h>
#include <sys/uio.h>

#include <netinet/in.h>
#include <netinet/tcp.h>
#include <netinet/tcp_timer.h>
#include <netinet/tcp_var.h>

#include <netdb.h>

#include <err.h>
#include <ctype.h>
#include <errno.h>
#include <event.h>
#include <fcntl.h>
#include <pwd.h>
#include <stdio.h>
#include <limits.h>
#include <stdlib.h>
#include <string.h>
#include <signal.h>
#include <syslog.h>
#include <unistd.h>

#define IDENTD_USER "_identd"

#define DOTNOIDENT ".noident"

#define TIMEOUT_MIN 4
#define TIMEOUT_MAX 240
#define TIMEOUT_DEFAULT 120
#define INPUT_MAX 256

enum ident_client_state {
	S_BEGINNING = 0,
	S_SERVER_PORT,
	S_PRE_COMMA,
	S_POST_COMMA,
	S_CLIENT_PORT,
	S_PRE_EOL,
	S_EOL,

	S_DEAD,
	S_QUEUED
};

#define E_NONE		0
#define E_NOUSER	1
#define E_UNKNOWN	2
#define E_HIDDEN	3

struct ident_client {
	struct {
		/* from the socket */
		struct sockaddr_storage ss;
		socklen_t len;

		/* from the request */
		u_int port;
	} client, server;
	SIMPLEQ_ENTRY(ident_client) entry;
	enum ident_client_state state;
	struct event ev;
	struct event tmo;
	size_t rxbytes;

	char *buf;
	size_t buflen;
	size_t bufoff;
	uid_t uid;
};

struct ident_resolver {
	SIMPLEQ_ENTRY(ident_resolver) entry;
	char *buf;
	size_t buflen;
	u_int error;
};

struct identd_listener {
	struct event ev, pause;
};

void	parent_rd(int, short, void *);
void	parent_wr(int, short, void *);
int	parent_username(struct ident_resolver *, struct passwd *);
int	parent_uid(struct ident_resolver *, struct passwd *);
int	parent_token(struct ident_resolver *, struct passwd *);
void	parent_noident(struct ident_resolver *, struct passwd *);

void	child_rd(int, short, void *);
void	child_wr(int, short, void *);

void	identd_listen(const char *, const char *, int);
void	identd_paused(int, short, void *);
void	identd_accept(int, short, void *);
int	identd_error(struct ident_client *, const char *);
void	identd_close(struct ident_client *);
void	identd_timeout(int, short, void *);
void	identd_request(int, short, void *);
enum ident_client_state
	identd_parse(struct ident_client *, int);
void	identd_resolving(int, short, void *);
void	identd_response(int, short, void *);
int	fetchuid(struct ident_client *);

const char *gethost(struct sockaddr_storage *);
const char *getport(struct sockaddr_storage *);
const char *gentoken(void);

struct loggers {
	__dead void (*err)(int, const char *, ...)
	    __attribute__((__format__ (printf, 2, 3)));
	__dead void (*errx)(int, const char *, ...)
	    __attribute__((__format__ (printf, 2, 3)));
	void (*warn)(const char *, ...)
	    __attribute__((__format__ (printf, 1, 2)));
	void (*warnx)(const char *, ...)
	    __attribute__((__format__ (printf, 1, 2)));
	void (*notice)(const char *, ...)
	    __attribute__((__format__ (printf, 1, 2)));
	void (*debug)(const char *, ...)
	    __attribute__((__format__ (printf, 1, 2)));
};

const struct loggers conslogger = {
	err,
	errx,
	warn,
	warnx,
	warnx, /* notice */
	warnx /* debug */
};

__dead void	syslog_err(int, const char *, ...)
		    __attribute__((__format__ (printf, 2, 3)));
__dead void	syslog_errx(int, const char *, ...)
		    __attribute__((__format__ (printf, 2, 3)));
void		syslog_warn(const char *, ...)
		    __attribute__((__format__ (printf, 1, 2)));
void		syslog_warnx(const char *, ...)
		    __attribute__((__format__ (printf, 1, 2)));
void		syslog_notice(const char *, ...)
		    __attribute__((__format__ (printf, 1, 2)));
void		syslog_debug(const char *, ...)
		    __attribute__((__format__ (printf, 1, 2)));
void		syslog_vstrerror(int, int, const char *, va_list)
		    __attribute__((__format__ (printf, 3, 0)));

const struct loggers syslogger = {
	syslog_err,
	syslog_errx,
	syslog_warn,
	syslog_warnx,
	syslog_notice,
	syslog_debug
};

const struct loggers *logger = &conslogger;

#define lerr(_e, _f...) logger->err((_e), _f)
#define lerrx(_e, _f...) logger->errx((_e), _f)
#define lwarn(_f...) logger->warn(_f)
#define lwarnx(_f...) logger->warnx(_f)
#define lnotice(_f...) logger->notice(_f)
#define ldebug(_f...) logger->debug(_f)

#define sa(_ss) ((struct sockaddr *)(_ss))

static __dead void
usage(void)
{
	extern char *__progname;
	fprintf(stderr, "usage: %s [-46deHhNn] [-l address] [-t timeout]\n",
	    __progname);
	exit(1);
}

struct timeval timeout = { TIMEOUT_DEFAULT, 0 };
int debug = 0;
int noident = 0;
int unknown_err = 0;
int hideall = 0;

int (*parent_uprintf)(struct ident_resolver *, struct passwd *) =
    parent_username;

struct event proc_rd, proc_wr;
union {
	struct {
		SIMPLEQ_HEAD(, ident_resolver) replies;
	} parent;
	struct {
		SIMPLEQ_HEAD(, ident_client) pushing, popping;
	} child;
} sc;

int
main(int argc, char *argv[])
{
	extern char *__progname;
	const char *errstr = NULL;

	int		 c;
	struct passwd	*pw;

	char *addr = NULL;
	int family = AF_UNSPEC;

	int pair[2];
	pid_t parent;
	int sibling;

	while ((c = getopt(argc, argv, "46deHhl:Nnt:")) != -1) {
		switch (c) {
		case '4':
			family = AF_INET;
			break;
		case '6':
			family = AF_INET6;
			break;
		case 'd':
			debug = 1;
			break;
		case 'e':
			unknown_err = 1;
			break;
		case 'H':
			hideall = 1;
			/* FALLTHROUGH */
		case 'h':
			parent_uprintf = parent_token;
			break;
		case 'l':
			addr = optarg;
			break;
		case 'N':
			noident = 1;
			break;
		case 'n':
			parent_uprintf = parent_uid;
			break;
		case 't':
			timeout.tv_sec = strtonum(optarg,
			    TIMEOUT_MIN, TIMEOUT_MAX, &errstr);
			if (errstr != NULL)
				errx(1, "timeout %s is %s", optarg, errstr);
			break;
		default:
			usage();
			/* NOTREACHED */
		}
	}

	argc -= optind;
	argv += optind;

	if (argc != 0)
		usage();

	if (geteuid() != 0)
		errx(1, "need root privileges");

	if (socketpair(AF_UNIX, SOCK_SEQPACKET | SOCK_NONBLOCK,
	    PF_UNSPEC, pair) == -1)
		err(1, "socketpair");

	pw = getpwnam(IDENTD_USER);
	if (pw == NULL)
		errx(1, "no %s user", IDENTD_USER);

	if (!debug && daemon(1, 0) == -1)
		err(1, "daemon");

	parent = fork();
	switch (parent) {
	case -1:
		lerr(1, "fork");

	case 0:
		/* child */
		setproctitle("listener");
		close(pair[1]);
		sibling = pair[0];
		break;

	default:
		/* parent */
		setproctitle("resolver");
		close(pair[0]);
		sibling = pair[1];
		break;
	}

	if (!debug) {
		openlog(__progname, LOG_PID|LOG_NDELAY, LOG_DAEMON);
		tzset();
		logger = &syslogger;
	}

	event_init();

	if (signal(SIGPIPE, SIG_IGN) == SIG_ERR)
		lerr(1, "signal(SIGPIPE)");

	if (parent) {
		if (pledge("stdio getpw rpath id", NULL) == -1)
			err(1, "pledge");

		SIMPLEQ_INIT(&sc.parent.replies);

		event_set(&proc_rd, sibling, EV_READ | EV_PERSIST,
		    parent_rd, NULL);
		event_set(&proc_wr, sibling, EV_WRITE,
		    parent_wr, NULL);
	} else {
		SIMPLEQ_INIT(&sc.child.pushing);
		SIMPLEQ_INIT(&sc.child.popping);

		identd_listen(addr, "auth", family);

		if (chroot(pw->pw_dir) == -1)
			lerr(1, "chroot(%s)", pw->pw_dir);

		if (chdir("/") == -1)
			lerr(1, "chdir(%s)", pw->pw_dir);

		event_set(&proc_rd, sibling, EV_READ | EV_PERSIST,
		    child_rd, NULL);
		event_set(&proc_wr, sibling, EV_WRITE,
		    child_wr, NULL);
	}

	if (setgroups(1, &pw->pw_gid) ||
	    setresgid(pw->pw_gid, pw->pw_gid, pw->pw_gid) ||
	    setresuid(pw->pw_uid, pw->pw_uid, pw->pw_uid))
		lerr(1, "unable to revoke privs");

	if (parent) {
		if (noident) {
			if (pledge("stdio getpw rpath", NULL) == -1)
				err(1, "pledge");
		} else {
			if (pledge("stdio getpw", NULL) == -1)
				err(1, "pledge");
		}
	}

	event_add(&proc_rd, NULL);
	event_dispatch();
	return (0);
}

void
parent_rd(int fd, short events, void *arg)
{
	struct ident_resolver *r;
	struct passwd *pw;
	ssize_t n;
	uid_t uid;

	n = read(fd, &uid, sizeof(uid));
	switch (n) {
	case -1:
		switch (errno) {
		case EAGAIN:
		case EINTR:
			return;
		default:
			lerr(1, "parent read");
		}
		break;
	case 0:
		lerrx(1, "child has gone");
	case sizeof(uid):
		break;
	default:
		lerrx(1, "unexpected %zd data from child", n);
	}

	r = calloc(1, sizeof(*r));
	if (r == NULL)
		lerr(1, "resolver alloc");

	pw = getpwuid(uid);
	if (pw == NULL && !hideall) {
		r->error = E_NOUSER;
		goto done;
	}

	if (noident && !hideall) {
		parent_noident(r, pw);
		if (r->error != E_NONE)
			goto done;
	}

	n = (*parent_uprintf)(r, pw);
	if (n == -1) {
		r->error = E_UNKNOWN;
		goto done;
	}

	r->buflen = n + 1;

done:
	SIMPLEQ_INSERT_TAIL(&sc.parent.replies, r, entry);
	event_add(&proc_wr, NULL);
}

int
parent_username(struct ident_resolver *r, struct passwd *pw)
{
	return (asprintf(&r->buf, "%s", pw->pw_name));
}

int
parent_uid(struct ident_resolver *r, struct passwd *pw)
{
	return (asprintf(&r->buf, "%u", (u_int)pw->pw_uid));
}

int
parent_token(struct ident_resolver *r, struct passwd *pw)
{
	const char *token;
	int rv;

	token = gentoken();
	rv = asprintf(&r->buf, "%s", token);
	if (rv != -1) {
		if (pw)
			lnotice("token %s == uid %u (%s)", token,
			    (u_int)pw->pw_uid, pw->pw_name);
		else
			lnotice("token %s == NO USER", token);
	}

	return (rv);
}

void
parent_noident(struct ident_resolver *r, struct passwd *pw)
{
	char path[PATH_MAX];
	struct stat st;
	int rv;

	rv = snprintf(path, sizeof(path), "%s/%s", pw->pw_dir, DOTNOIDENT);
	if (rv == -1 || rv >= sizeof(path)) {
		r->error = E_UNKNOWN;
		return;
	}

	if (stat(path, &st) == -1)
		return;

	r->error = E_HIDDEN;
}

void
parent_wr(int fd, short events, void *arg)
{
	struct ident_resolver *r = SIMPLEQ_FIRST(&sc.parent.replies);
	struct iovec iov[2];
	int iovcnt = 0;
	ssize_t n;

	iov[iovcnt].iov_base = &r->error;
	iov[iovcnt].iov_len = sizeof(r->error);
	iovcnt++;

	if (r->buflen > 0) {
		iov[iovcnt].iov_base = r->buf;
		iov[iovcnt].iov_len = r->buflen;
		iovcnt++;
	}

	n = writev(fd, iov, iovcnt);
	if (n == -1) {
		switch (errno) {
		case EINTR:
		case EAGAIN:
			event_add(&proc_wr, NULL);
			return;
		default:
			lerr(1, "parent write");
		}
	}

	if (n != sizeof(r->error) + r->buflen)
		lerrx(1, "unexpected parent write length %zd", n);

	SIMPLEQ_REMOVE_HEAD(&sc.parent.replies, entry);

	if (r->buflen > 0)
		free(r->buf);

	free(r);

	if (!SIMPLEQ_EMPTY(&sc.parent.replies))
		event_add(&proc_wr, NULL);
}

void
child_rd(int fd, short events, void *arg)
{
	struct ident_client *c;
	struct {
		u_int error;
		char buf[512];
	} reply;
	ssize_t n;

	n = read(fd, &reply, sizeof(reply));
	switch (n) {
	case -1:
		switch (errno) {
		case EAGAIN:
		case EINTR:
			return;
		default:
			lerr(1, "child read");
		}
		break;
	case 0:
		lerrx(1, "parent has gone");
	default:
		break;
	}

	c = SIMPLEQ_FIRST(&sc.child.popping);
	if (c == NULL)
		lerrx(1, "unsolicited data from parent");

	SIMPLEQ_REMOVE_HEAD(&sc.child.popping, entry);

	if (n < sizeof(reply.error))
		lerrx(1, "short data from parent");

	/* check if something went wrong while the parent was working */
	if (c->state == S_DEAD) {
		free(c);
		return;
	}
	c->state = S_DEAD;

	switch (reply.error) {
	case E_NONE:
		n = asprintf(&c->buf, "%u , %u : USERID : UNIX : %s\r\n",
		    c->server.port, c->client.port, reply.buf);
		break;
	case E_NOUSER:
		n = asprintf(&c->buf, "%u , %u : ERROR : %s\r\n",
		    c->server.port, c->client.port,
		    unknown_err ? "UNKNOWN-ERROR" : "NO-USER");
		break;
	case E_UNKNOWN:
		n = asprintf(&c->buf, "%u , %u : ERROR : UNKNOWN-ERROR\r\n",
		    c->server.port, c->client.port);
		break;
	case E_HIDDEN:
		n = asprintf(&c->buf, "%u , %u : ERROR : HIDDEN-USER\r\n",
		    c->server.port, c->client.port);
		break;
	default:
		lerrx(1, "unexpected error from parent %u", reply.error);
	}
	if (n == -1)
		goto fail;

	c->buflen = n;

	fd = EVENT_FD(&c->ev);
	event_del(&c->ev);
	event_set(&c->ev, fd, EV_READ | EV_WRITE | EV_PERSIST,
	    identd_response, c);
	event_add(&c->ev, NULL);
	return;

fail:
	identd_close(c);
}

void
child_wr(int fd, short events, void *arg)
{
	struct ident_client *c = SIMPLEQ_FIRST(&sc.child.pushing);
	const char *errstr = NULL;
	ssize_t n;

	n = write(fd, &c->uid, sizeof(c->uid));
	switch (n) {
	case -1:
		switch (errno) {
		case EINTR:
		case EAGAIN:
			event_add(&proc_wr, NULL);
			return;
		case ENOBUFS: /* parent has a backlog of requests */
			errstr = "UNKNOWN-ERROR";
			break;
		default:
			lerr(1, "child write");
		}
		break;
	case sizeof(c->uid):
		break;
	default:
		lerrx(1, "unexpected child write length %zd", n);
	}

	SIMPLEQ_REMOVE_HEAD(&sc.child.pushing, entry);
	if (errstr == NULL)
		SIMPLEQ_INSERT_TAIL(&sc.child.popping, c, entry);
	else if (identd_error(c, errstr) == -1)
		identd_close(c);

	if (!SIMPLEQ_EMPTY(&sc.child.pushing))
		event_add(&proc_wr, NULL);
}

void
identd_listen(const char *addr, const char *port, int family)
{
	struct identd_listener *l = NULL;

	struct addrinfo hints, *res, *res0;
	int error, s;
	const char *cause = NULL;
	int on = 1;

	memset(&hints, 0, sizeof(hints));
	hints.ai_family = family;
	hints.ai_socktype = SOCK_STREAM;
	hints.ai_flags = AI_PASSIVE;

	error = getaddrinfo(addr, port, &hints, &res0);
	if (error)
		lerrx(1, "%s/%s: %s", addr, port, gai_strerror(error));

	for (res = res0; res != NULL; res = res->ai_next) {
		s = socket(res->ai_family, res->ai_socktype | SOCK_NONBLOCK,
		    res->ai_protocol);
		if (s == -1) {
			cause = "socket";
			continue;
		}

		if (setsockopt(s, SOL_SOCKET, SO_REUSEADDR,
		    &on, sizeof(on)) == -1)
			err(1, "listener setsockopt(SO_REUSEADDR)");

		if (bind(s, res->ai_addr, res->ai_addrlen) == -1) {
			int serrno = errno;

			cause = "bind";
			close(s);
			errno = serrno;
			continue;
		}

		if (listen(s, 5) == -1)
			err(1, "listen");

		l = calloc(1, sizeof(*l));
		if (l == NULL)
			err(1, "listener ev alloc");

		event_set(&l->ev, s, EV_READ | EV_PERSIST, identd_accept, l);
		event_add(&l->ev, NULL);
		evtimer_set(&l->pause, identd_paused, l);
	}
	if (l == NULL)
		err(1, "%s", cause);

	freeaddrinfo(res0);
}

void
identd_paused(int fd, short events, void *arg)
{
	struct identd_listener *l = arg;
	event_add(&l->ev, NULL);
}

void
identd_accept(int fd, short events, void *arg)
{
	struct identd_listener *l = arg;
	struct sockaddr_storage ss;
	struct timeval pause = { 1, 0 };
	struct ident_client *c = NULL;
	socklen_t len;
	int s;

	len = sizeof(ss);
	s = accept4(fd, sa(&ss), &len, SOCK_NONBLOCK);
	if (s == -1) {
		switch (errno) {
		case EINTR:
		case EWOULDBLOCK:
		case ECONNABORTED:
			return;
		case EMFILE:
		case ENFILE:
			event_del(&l->ev);
			evtimer_add(&l->pause, &pause);
			return;
		default:
			lerr(1, "accept");
		}
	}

	c = calloc(1, sizeof(*c));
	if (c == NULL) {
		lwarn("client alloc");
		close(fd);
		return;
	}

	memcpy(&c->client.ss, &ss, len);
	c->client.len = len;
	ldebug("client: %s", gethost(&ss));

	/* lookup the local ip it connected to */
	c->server.len = sizeof(c->server.ss);
	if (getsockname(s, sa(&c->server.ss), &c->server.len) == -1)
		lerr(1, "getsockname");

	event_set(&c->ev, s, EV_READ | EV_PERSIST, identd_request, c);
	event_add(&c->ev, NULL);

	event_set(&c->tmo, s, 0, identd_timeout, c);
	event_add(&c->tmo, &timeout);
}

void
identd_timeout(int fd, short events, void *arg)
{
	struct ident_client *c = arg;

	event_del(&c->ev);
	close(fd);
	free(c->buf);

	if (c->state == S_QUEUED) /* it is queued for resolving */
		c->state = S_DEAD;
	else
		free(c);
}

void
identd_request(int fd, short events, void *arg)
{
	struct ident_client *c = arg;
	unsigned char buf[64];
	ssize_t n, i;
	char *errstr = unknown_err ? "UNKNOWN-ERROR" : "INVALID-PORT";

	n = read(fd, buf, sizeof(buf));
	switch (n) {
	case -1:
		switch (errno) {
		case EINTR:
		case EAGAIN:
			return;
		default:
			lwarn("%s read", gethost(&c->client.ss));
			goto fail;
		}
		break;

	case 0:
		ldebug("%s closed connection", gethost(&c->client.ss));
		goto fail;
	default:
		break;
	}

	c->rxbytes += n;
	if (c->rxbytes >= INPUT_MAX)
		goto fail;

	for (i = 0; c->state < S_EOL && i < n; i++)
		c->state = identd_parse(c, buf[i]);

	if (c->state == S_DEAD)
		goto error;
	if (c->state != S_EOL)
		return;

	if (c->server.port < 1 || c->client.port < 1)
		goto error;

	if (fetchuid(c) == -1) {
		errstr = unknown_err ? "UNKNOWN-ERROR" : "NO-USER";
		goto error;
	}

	SIMPLEQ_INSERT_TAIL(&sc.child.pushing, c, entry);
	c->state = S_QUEUED;

	event_del(&c->ev);
	event_set(&c->ev, fd, EV_READ | EV_PERSIST, identd_resolving, c);
	event_add(&c->ev, NULL);

	event_add(&proc_wr, NULL);
	return;

error:
	if (identd_error(c, errstr) == -1)
		goto fail;

	return;

fail:
	identd_close(c);
}

int
identd_error(struct ident_client *c, const char *errstr)
{
	int fd = EVENT_FD(&c->ev);
	ssize_t n;

	n = asprintf(&c->buf, "%u , %u : ERROR : %s\r\n",
	    c->server.port, c->client.port, errstr);
	if (n == -1)
		return (-1);

	c->buflen = n;

	event_del(&c->ev);
	event_set(&c->ev, fd, EV_READ | EV_WRITE | EV_PERSIST,
	    identd_response, c);
	event_add(&c->ev, NULL);

	return (0);
}

void
identd_close(struct ident_client *c)
{
	int fd = EVENT_FD(&c->ev);

	evtimer_del(&c->tmo);
	event_del(&c->ev);
	close(fd);
	free(c->buf);
	free(c);
}

void
identd_resolving(int fd, short events, void *arg)
{
	struct ident_client *c = arg;
	char buf[64];
	ssize_t n;

	/*
	 * something happened while we're waiting for the parent to lookup
	 * the user.
	 */

	n = read(fd, buf, sizeof(buf));
	switch (n) {
	case -1:
		switch (errno) {
		case EINTR:
		case EAGAIN:
			return;
		default:
			lwarn("resolving read");
			break;
		}
		break;
	case 0:
		ldebug("%s closed connection during resolving",
		    gethost(&c->client.ss));
		break;
	default:
		c->rxbytes += n;
		if (c->rxbytes >= INPUT_MAX)
			break;

		/* ignore extra input */
		return;
	}

	evtimer_del(&c->tmo);
	event_del(&c->ev);
	close(fd);
	c->state = S_DEAD; /* on the resolving queue */
}

enum ident_client_state
identd_parse(struct ident_client *c, int ch)
{
	enum ident_client_state s = c->state;

	switch (s) {
	case S_BEGINNING:
		/* ignore leading space */
		if (ch == '\t' || ch == ' ')
			return (s);

		if (ch == '0' || !isdigit(ch))
			return (S_DEAD);

		c->server.port = ch - '0';
		return (S_SERVER_PORT);

	case S_SERVER_PORT:
		if (ch == '\t' || ch == ' ')
			return (S_PRE_COMMA);
		if (ch == ',')
			return (S_POST_COMMA);

		if (!isdigit(ch))
			return (S_DEAD);

		c->server.port *= 10;
		c->server.port += ch - '0';
		if (c->server.port > 65535)
			return (S_DEAD);

		return (s);

	case S_PRE_COMMA:
		if (ch == '\t' || ch == ' ')
			return (s);
		if (ch == ',')
			return (S_POST_COMMA);

		return (S_DEAD);

	case S_POST_COMMA:
		if (ch == '\t' || ch == ' ')
			return (s);

		if (ch == '0' || !isdigit(ch))
			return (S_DEAD);

		c->client.port = ch - '0';
		return (S_CLIENT_PORT);

	case S_CLIENT_PORT:
		if (ch == '\t' || ch == ' ')
			return (S_PRE_EOL);
		if (ch == '\r' || ch == '\n')
			return (S_EOL);

		if (!isdigit(ch))
			return (S_DEAD);

		c->client.port *= 10;
		c->client.port += ch - '0';
		if (c->client.port > 65535)
			return (S_DEAD);

		return (s);

	case S_PRE_EOL:
		if (ch == '\t' || ch == ' ')
			return (s);
		if (ch == '\r' || ch == '\n')
			return (S_EOL);

		return (S_DEAD);

	case S_EOL:
		/* ignore trailing garbage */
		return (s);

	default:
		return (S_DEAD);
	}
}

void
identd_response(int fd, short events, void *arg)
{
	struct ident_client *c = arg;
	char buf[64];
	ssize_t n;

	if (events & EV_READ) {
		n = read(fd, buf, sizeof(buf));
		switch (n) {
		case -1:
			switch (errno) {
			case EINTR:
			case EAGAIN:
				/* meh, try a write */
				break;
			default:
				lwarn("response read");
				goto done;
			}
			break;
		case 0:
			ldebug("%s closed connection during response",
			    gethost(&c->client.ss));
			goto done;
		default:
			c->rxbytes += n;
			if (c->rxbytes >= INPUT_MAX)
				goto done;

			/* ignore extra input */
			break;
		}
	}

	if (!(events & EV_WRITE))
		return; /* try again later */

	n = write(fd, c->buf + c->bufoff, c->buflen - c->bufoff);
	if (n == -1) {
		switch (errno) {
		case EINTR:
		case EAGAIN:
			return; /* try again later */
		case EPIPE:
			goto done;
		default:
			lwarn("response write");
			goto done;
		}
	}

	c->bufoff += n;
	if (c->bufoff != c->buflen)
		return; /* try again later */

done:
	identd_close(c);
}

void
syslog_vstrerror(int e, int priority, const char *fmt, va_list ap)
{
	char *s;

	if (vasprintf(&s, fmt, ap) == -1) {
		syslog(LOG_EMERG, "unable to alloc in syslog_vstrerror");
		exit(1);
	}
	syslog(priority, "%s: %s", s, strerror(e));
	free(s);
}

void
syslog_err(int ecode, const char *fmt, ...)
{
	va_list ap;

	va_start(ap, fmt);
	syslog_vstrerror(errno, LOG_EMERG, fmt, ap);
	va_end(ap);
	exit(ecode);
}

void
syslog_errx(int ecode, const char *fmt, ...)
{
	va_list ap;

	va_start(ap, fmt);
	vsyslog(LOG_WARNING, fmt, ap);
	va_end(ap);
	exit(ecode);
}

void
syslog_warn(const char *fmt, ...)
{
	va_list ap;

	va_start(ap, fmt);
	syslog_vstrerror(errno, LOG_WARNING, fmt, ap);
	va_end(ap);
}

void
syslog_warnx(const char *fmt, ...)
{
	va_list ap;

	va_start(ap, fmt);
	vsyslog(LOG_WARNING, fmt, ap);
	va_end(ap);
}

void
syslog_notice(const char *fmt, ...)
{
	va_list ap;

	va_start(ap, fmt);
	vsyslog(LOG_NOTICE, fmt, ap);
	va_end(ap);
}

void
syslog_debug(const char *fmt, ...)
{
	va_list ap;

	if (!debug)
		return;

	va_start(ap, fmt);
	vsyslog(LOG_DEBUG, fmt, ap);
	va_end(ap);
}

const char *
gethost(struct sockaddr_storage *ss)
{
	struct sockaddr *sa = (struct sockaddr *)ss;
	static char buf[NI_MAXHOST];

	if (getnameinfo(sa, sa->sa_len, buf, sizeof(buf),
	    NULL, 0, NI_NUMERICHOST) != 0)
		return ("(unknown)");

	return (buf);
}

const char *
getport(struct sockaddr_storage *ss)
{
	struct sockaddr *sa = (struct sockaddr *)ss;
	static char buf[NI_MAXSERV];

	if (getnameinfo(sa, sa->sa_len, NULL, 0, buf, sizeof(buf),
	    NI_NUMERICSERV) != 0)
		return ("(unknown)");

	return (buf);
}

const char *
gentoken(void)
{
	static char buf[21];
	u_int32_t r;
	int i;

	buf[0] = 'a' + arc4random_uniform(26);
	for (i = 1; i < sizeof(buf) - 1; i++) {
		r = arc4random_uniform(36);
		buf[i] = (r < 26 ? 'a' : '0' - 26) + r;
	}
	buf[i] = '\0';

	return (buf);
}

int
fetchuid(struct ident_client *c)
{
	struct tcp_ident_mapping tir;
	int mib[] = { CTL_NET, PF_INET, IPPROTO_TCP, TCPCTL_IDENT };
	struct sockaddr_in *s4;
	struct sockaddr_in6 *s6;
	int err = 0;
	size_t len;

	memset(&tir, 0, sizeof(tir));
	memcpy(&tir.faddr, &c->client.ss, sizeof(tir.faddr));
	memcpy(&tir.laddr, &c->server.ss, sizeof(tir.laddr));

	switch (c->server.ss.ss_family) {
	case AF_INET:
		s4 = (struct sockaddr_in *)&tir.faddr;
		s4->sin_port = htons(c->client.port);

		s4 = (struct sockaddr_in *)&tir.laddr;
		s4->sin_port = htons(c->server.port);
		break;
	case AF_INET6:
		s6 = (struct sockaddr_in6 *)&tir.faddr;
		s6->sin6_port = htons(c->client.port);

		s6 = (struct sockaddr_in6 *)&tir.laddr;
		s6->sin6_port = htons(c->server.port);
		break;
	default:
		lerrx(1, "unexpected family %d", c->server.ss.ss_family);
	}

	len = sizeof(tir);
	err = sysctl(mib, sizeof(mib) / sizeof(mib[0]), &tir, &len, NULL, 0);
	if (err == -1)
		lerr(1, "sysctl");

	if (tir.ruid == -1)
		return (-1);

	c->uid = tir.ruid;
	return (0);
}
@


1.33
log
@Fix pledge request to allow for setgroups.

setgroups needed "proc" before the introduction of "id" on 2015/10/17.
Initial patch from Gregor Best, from which I further removed "proc".
@
text
@d1 1
a1 1
/*	$OpenBSD: identd.c,v 1.32 2015/10/16 05:55:23 doug Exp $ */
d135 12
a146 6
	void (*err)(int, const char *, ...);
	void (*errx)(int, const char *, ...);
	void (*warn)(const char *, ...);
	void (*warnx)(const char *, ...);
	void (*notice)(const char *, ...);
	void (*debug)(const char *, ...);
d158 14
a171 7
void	syslog_err(int, const char *, ...);
void	syslog_errx(int, const char *, ...);
void	syslog_warn(const char *, ...);
void	syslog_warnx(const char *, ...);
void	syslog_notice(const char *, ...);
void	syslog_debug(const char *, ...);
void	syslog_vstrerror(int, int, const char *, va_list);
@


1.32
log
@Pledge support for the parent/resolver in identd(8).

This limits the resolver to just "stdio getpw" or "stdio getpw rpath"
depending on whether ~/.noident files are checked.

The child/listener cannot use pledge yet because it calls a sysctl that
hasn't been whitelisted.

"commit" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: identd.c,v 1.31 2015/08/20 11:06:35 dlg Exp $ */
d317 1
a317 1
		if (pledge("stdio proc getpw rpath", NULL) == -1)
@


1.31
log
@avoid ioctl FIONBIO by passing SOCK_NONBLOCK to the things we get
sockets out of.

for guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: identd.c,v 1.29 2015/08/04 11:05:18 dlg Exp $ */
d317 3
d348 10
@


1.30
log
@ignore SIGPIPE so we can handle the write(2) failures.

instead of exiting on an unknown write failure, close the client
connection on EPIPE from write and warn and close the connection
on any other failure.

ok jmatthew@@
@
text
@a191 1
int on = 1;
d274 2
a275 1
	if (socketpair(AF_UNIX, SOCK_SEQPACKET, PF_UNSPEC, pair) == -1)
a315 3
	if (ioctl(sibling, FIONBIO, &on) == -1)
		lerr(1, "sibling ioctl(FIONBIO)");

d627 1
d639 2
a640 1
		s = socket(res->ai_family, res->ai_socktype, res->ai_protocol);
a658 3
		if (ioctl(s, FIONBIO, &on) == -1)
			err(1, "listener ioctl(FIONBIO)");

d694 1
a694 1
	s = accept(fd, sa(&ss), &len);
a709 3

	if (ioctl(s, FIONBIO, &on) == -1)
		lerr(1, "client ioctl(FIONBIO)");
@


1.29
log
@consider the default failure handling for errors on socket operations to
close the socket rather than kill the program.

tested for a few days on the student shell box at work.

based on discussion with guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: identd.c,v 1.28 2015/03/27 07:16:38 dlg Exp $ */
d44 1
d313 3
d1028 2
d1031 2
a1032 1
			lerr(1, "response write");
@


1.28
log
@f the parent builts up a list of replies for the child, it helps
to readd the write event if there's still items on the list.

this lets things that do a lot of requests in parallel (like npm)
work betterer through a squid proxy using ident for auth.

ok jmatthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: identd.c,v 1.27 2015/01/16 06:40:17 deraadt Exp $ */
d476 3
a478 1
		if (errno == EAGAIN) {
d481 2
a483 1
		lerr(1, "parent write");
d591 1
d873 2
a874 1
			lerrx(1, "resolving read");
d876 1
a876 1
		/* NOTREACHED */
d997 2
a998 1
				lerrx(1, "response read");
d1021 1
@


1.27
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: identd.c,v 1.26 2014/07/13 17:53:41 claudio Exp $ */
d492 3
@


1.26
log
@Use errx() after getpwnam() failure since errno may not be set.
All other privsep / privdrop daemons do this the same way.
OK florian@@ some time ago
@
text
@d1 1
a1 1
/*	$OpenBSD: identd.c,v 1.25 2014/07/08 17:12:37 tobias Exp $ */
d41 1
d440 1
a440 1
	char path[MAXPATHLEN];
@


1.25
log
@Cleanup of getopt argument: -p is not supported anymore.

ok deraadt@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: identd.c,v 1.24 2014/01/07 00:11:11 dlg Exp $ */
d278 1
a278 1
		err(1, "no %s user", IDENTD_USER);
@


1.24
log
@the return from asprintf does NOT include the space used by the
terminating \0 character. if i want to use it as a c string i have
to take that into account.

found by simon kuhnle who supplied a good bug report. prodded by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: identd.c,v 1.23 2013/11/21 03:09:07 dlg Exp $ */
d223 1
a223 1
	while ((c = getopt(argc, argv, "46deHhl:Nnp:t:")) != -1) {
@


1.23
log
@get bytes off the wire as unsigned char so we can pass them to
identd_parse() and then isspace()/isdigit() as appropriately promoted
values.

based on discussion with deraadt@@ and guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: identd.c,v 1.22 2013/11/12 19:47:52 deraadt Exp $ */
d398 1
a398 1
	r->buflen = n;
@


1.22
log
@handle lack of prototype
@
text
@d1 1
a1 1
/*	$OpenBSD: identd.c,v 1.21 2013/10/24 02:55:50 deraadt Exp $ */
d748 1
a748 1
	char buf[64];
@


1.21
log
@no need for netinet/ip_var.h (and friends)
@
text
@d1 1
a1 1
/*	$OpenBSD: identd.c,v 1.20 2013/07/17 15:38:48 okan Exp $ */
d178 1
a178 1
__dead void
@


1.20
log
@implement -H, which hides existing and non-existent users, as well as
implying -h.

feedback and ok from jmc@@ and dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: identd.c,v 1.19 2013/04/29 06:32:11 jmc Exp $ */
a27 1
#include <netinet/ip_var.h>
@


1.19
log
@add -h to usage();
@
text
@d1 1
a1 1
/*	$OpenBSD: identd.c,v 1.18 2013/04/29 04:17:58 dlg Exp $ */
d183 1
a183 1
	fprintf(stderr, "usage: %s [-46dehNn] [-l address] [-t timeout]\n",
d193 1
d224 1
a224 1
	while ((c = getopt(argc, argv, "46dehl:Nnp:t:")) != -1) {
d238 3
d382 1
a382 1
	if (pw == NULL) {
d387 1
a387 1
	if (noident) {
d427 5
a431 2
		lnotice("token %s == uid %u (%s)", token,
		    (u_int)pw->pw_uid, pw->pw_name);
@


1.18
log
@implement -h from libexec/identd, which hides usernames/uids.
@
text
@d1 1
a1 1
/*	$OpenBSD: identd.c,v 1.17 2013/04/23 21:18:57 sthen Exp $ */
d183 1
a183 1
	fprintf(stderr, "usage: %s [-46deNn] [-l address] [-t timeout]\n",
@


1.17
log
@support src/libexec/identd's -e option in src/usr.sbin/identd, ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: identd.c,v 1.16 2013/04/23 10:33:06 dlg Exp $ */
d110 1
d131 1
d138 1
a138 1
	void (*info)(const char *, ...);
d147 1
a147 1
	warnx, /* info */
d155 1
a155 1
void	syslog_info(const char *, ...);
d164 1
a164 1
	syslog_info,
d174 1
a174 1
#define linfo(_f...) logger->info(_f)
d223 1
a223 1
	while ((c = getopt(argc, argv, "46del:Nnp:t:")) != -1) {
d237 3
d414 16
d1076 1
a1076 1
syslog_info(const char *fmt, ...)
d1081 1
a1081 1
	vsyslog(LOG_INFO, fmt, ap);
d1120 17
@


1.16
log
@sizeof(&foo) isnt as good as sizeof(foo).

found by sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: identd.c,v 1.15 2013/04/23 06:17:07 dlg Exp $ */
d181 1
a181 1
	fprintf(stderr, "usage: %s [-46dNn] [-l address] [-t timeout]\n",
d190 1
d221 1
a221 1
	while ((c = getopt(argc, argv, "46dl:Nnp:t:")) != -1) {
d232 3
d515 3
a517 2
		n = asprintf(&c->buf, "%u , %u : ERROR : NO-USER\r\n",
		    c->server.port, c->client.port);
d723 1
a723 1
	char *errstr = "INVALID-PORT";
d761 1
a761 1
		errstr = "NO-USER";
@


1.15
log
@use stat to see if ~/.noident is there to avoid reimplementing a security
issue from 1988 when using open.

pointed out by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: identd.c,v 1.14 2013/04/23 05:39:32 dlg Exp $ */
d1109 2
a1110 2
	memcpy(&tir.faddr, &c->client.ss, sizeof(&tir.faddr));
	memcpy(&tir.laddr, &c->server.ss, sizeof(&tir.laddr));
@


1.14
log
@fix usage to reflect the currently accepted getopt things.
@
text
@d1 1
a1 1
/*	$OpenBSD: identd.c,v 1.13 2013/04/23 05:37:35 dlg Exp $ */
d23 1
d409 1
a409 1
	int fd;
d418 2
a419 13
	fd = open(path, O_RDONLY, 0);
	if (fd == -1) {
		switch (errno) {
		case ENOENT:
		case EACCES:
			return; /* not an error */
		default:
			r->error = E_UNKNOWN;
			return;
		}
	}

	close(fd);
@


1.13
log
@remove support for specifying which port you want to run on. there's no
point.

well argued by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: identd.c,v 1.12 2013/04/23 01:55:45 dlg Exp $ */
d180 2
a181 2
	fprintf(stderr, "usage: %s [-46d] [-l address] [-p port] "
	    "[-t timeout]\n", __progname);
@


1.12
log
@add support for returning uids instead of usernames via -n, like libexec
identd.
@
text
@d1 1
a1 1
/*	$OpenBSD: identd.c,v 1.11 2013/04/23 01:46:39 dlg Exp $ */
a212 1
	char *port = "auth";
a238 3
		case 'p':
			port = optarg;
			break;
d312 1
a312 1
		identd_listen(addr, port, family);
@


1.11
log
@add support for -N as per libexec/identd. this lets users put
.noident in their homedir to have this identd return HIDDEN-USER
instead of their username.
@
text
@d1 1
a1 1
/*	$OpenBSD: identd.c,v 1.10 2013/04/22 05:08:46 dlg Exp $ */
d107 2
d190 3
d220 1
a220 1
	while ((c = getopt(argc, argv, "46dl:Np:t:")) != -1) {
d237 3
d383 1
a383 1
	n = asprintf(&r->buf, "%s", pw->pw_name);
d394 12
@


1.10
log
@handle ENOBUFS on the SEQPACKET socketpair between the child and the parent
procs. if this happens it would mean the parent has a backlog of work cos
of slow username resolutions. in that situation the child should tell the
client theres an error, but not die.

this factors out a bit of code to handle generating errors for the client
and closing the socket.

reviewed by jmatthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: identd.c,v 1.9 2013/04/05 23:16:41 florian Exp $ */
d38 1
d48 2
d107 1
d185 1
d215 1
a215 1
	while ((c = getopt(argc, argv, "46dl:p:t:")) != -1) {
d229 3
d366 42
a407 3
	} else {
		n = asprintf(&r->buf, "%s", pw->pw_name);
		if (n == -1)
d409 1
a409 3
		else {
			r->error = E_NONE;
			r->buflen = n;
d413 3
a415 2
	SIMPLEQ_INSERT_TAIL(&sc.parent.replies, r, entry);
	event_add(&proc_wr, NULL);
@


1.9
log
@kill redundant prototype
OK dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: identd.c,v 1.8 2013/03/20 03:58:09 deraadt Exp $ */
d111 2
d486 1
a486 4
	evtimer_del(&c->tmo);
	event_del(&c->ev);
	close(fd);
	free(c);
d493 1
d499 2
a500 1
		if (errno == EAGAIN) {
d503 5
d509 1
a509 1
		lerr(1, "child write");
d517 4
a520 1
	SIMPLEQ_INSERT_TAIL(&sc.child.popping, c, entry);
d652 1
a652 2
	if (c->buf != NULL)
		free(c->buf);
d719 15
d737 1
a737 1
		goto fail;
a744 1
	return;
d746 8
a753 1
fail:
d757 1
d939 1
a939 5
	evtimer_del(&c->tmo);
	event_del(&c->ev);
	close(fd);
	free(c->buf);
	free(c);
@


1.8
log
@7 #include which are not needed
@
text
@d1 1
a1 1
/*	$OpenBSD: identd.c,v 1.7 2013/03/20 00:23:53 deraadt Exp $ */
a165 1
const char *gethost(struct sockaddr_storage *);
@


1.7
log
@a tiny bit of knf; mostly whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: identd.c,v 1.6 2013/03/19 00:44:03 dlg Exp $ */
d19 1
a20 3
#include <sys/param.h>
#include <sys/types.h>
#include <sys/queue.h>
a26 1
#include <netinet/in_systm.h>
a31 1
#include <arpa/inet.h>
a37 1
#include <fcntl.h>
a41 1
#include <stdarg.h>
@


1.6
log
@dont need to event_add the parent to child writing events twice. especially
if something stops you from having something to write after the first
event_add but before the second one.

thank you to Henri Kemppainen for the find.
@
text
@d1 1
a1 1
/*	$OpenBSD: identd.c,v 1.5 2013/03/18 04:53:23 dlg Exp $ */
a324 1

a325 1

d530 1
a530 3
	int error;
	int s;
	int serrno;
d554 2
a556 1
			serrno = errno;
a611 1

d927 1
a927 1
  
a931 1
 
a932 1
 
d935 1
a935 1
 
d940 1
a940 1
 
a943 1
 
d946 1
a946 1
 
d951 1
a951 1
 
d955 1
a955 2

	exit(ecode);  
d965 1
a965 1
	va_end(ap);   
@


1.5
log
@whitespace fixes. no functional change
@
text
@d1 1
a1 1
/*	$OpenBSD: identd.c,v 1.4 2013/03/18 04:50:01 dlg Exp $ */
a356 2

	event_add(&proc_wr, NULL);
@


1.4
log
@limit the client to 256 bytes of input. if they send too much we just close
the connection.

requested by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: identd.c,v 1.2 2013/03/18 01:20:46 dlg Exp $ */
d579 1
a579 1
	        evtimer_set(&l->pause, identd_paused, l);
d1040 1
a1040 1
        struct tcp_ident_mapping tir;
d1043 3
a1045 3
        struct sockaddr_in6 *s6;
        int err = 0;
        size_t len;
d1047 1
a1047 1
        memset(&tir, 0, sizeof(tir));
d1071 1
a1071 1
        err = sysctl(mib, sizeof(mib) / sizeof(mib[0]), &tir, &len, NULL, 0);
@


1.3
log
@switch from having a timeout after every read/write for the client
connection to a timeout for the whole session. means a client cant sit
there feeding us a byte at a time for long periods, consuming fds on the
server.

it seems to simplify the code a bit too.

requested by deraadt@@
@
text
@d56 1
d89 1
d693 4
d772 4
d895 4
@


1.2
log
@handle EMFILE/ENFILE from accept by disabling handling of events on the
listeners for a second. modelled on how this has been solved in other
network daemons.
@
text
@d1 1
a1 1
/*	$OpenBSD: identd.c,v 1.1 2013/03/18 00:34:48 dlg Exp $ */
d67 1
a67 1
	S_DYING
d87 1
d115 1
d454 1
a454 5
	switch (c->state) {
	case S_DYING: /* we're sending an error to the client */
		c->state = S_DEAD;
		return;
	case S_DEAD: /* we finished sending an error to the client */
a456 2
	default:
		break;
d458 1
d489 1
a489 1
	event_add(&c->ev, &timeout);
d493 1
d641 20
a660 1
	event_add(&c->ev, &timeout);
a670 5
	if (events & EV_TIMEOUT) {
		ldebug("%s request timeout", gethost(&c->client.ss));
		goto fail;
	}

a701 2
	event_del(&c->ev);

d708 1
d710 1
d712 1
a712 1
	event_add(&c->ev, &timeout);
a725 1

d728 1
a728 1
	event_add(&c->ev, &timeout);
d732 1
a749 6
	if (events & EV_TIMEOUT) {
		ldebug("%s timeout during resolving",
		    gethost(&c->client.ss));
		goto error;
	}

d760 1
a760 1
		break;
d764 1
a764 1
		goto fail;
d766 2
a767 1
		break;
d770 1
a770 19
	/* throw it away */
	return;

error:
	n = asprintf(&c->buf, "%u , %u : ERROR : UNKNOWN-ERROR\r\n",
	    c->server.port, c->client.port);
	if (n == -1)
		goto fail;

	c->buflen = n;

	event_del(&c->ev);
	event_set(&c->ev, fd, EV_READ | EV_WRITE | EV_PERSIST,
	    identd_response, c);
	event_add(&c->ev, &timeout);
	c->state = S_DYING;
	return;

fail:
d773 1
a773 1
	c->state = S_DEAD;
a866 5
	if (events & EV_TIMEOUT) {
		ldebug("%s timeout during response", gethost(&c->client.ss));
		goto done;
	}

d885 1
a885 1
			/* flushed socket */
d899 1
a899 1
			goto done;
d908 1
d912 1
a912 4
	if (c->state == S_DYING) /* it was queued for resolving */
		c->state = S_DEAD;
	else
		free(c);
@


1.1
log
@this is a new identd daemon to replace the libexec one that can be run
from inetd. it is an event driven non-blocking implemention using libevent.

it features support for privilege separation and revocation. network
connections are handled by a chrooted and unprivileged process, while the
username lookups are handled by an unprivileged process. the lookups can
block while the network handling can continue.

it also features support for handling concurrent client connections.

its currently lacking support for handling dotfiles in homedirs like the
libexec one, and some error handling on accept. its going into the tree
so it can be worked on with a history of changes.
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d101 4
d112 1
d531 1
a531 1
	struct event *ev = NULL;
d573 2
a574 2
		ev = calloc(1, sizeof(*ev));
		if (ev == NULL)
d577 3
a579 2
		event_set(ev, s, EV_READ | EV_PERSIST, identd_accept, NULL);
		event_add(ev, NULL);
d581 1
a581 1
	if (ev == NULL)
d588 7
d597 1
d599 1
d612 6
@
