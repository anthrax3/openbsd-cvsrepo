head	1.47;
access;
symbols
	OPENBSD_6_2_BASE:1.47
	OPENBSD_6_1:1.44.0.4
	OPENBSD_6_1_BASE:1.44
	OPENBSD_6_0:1.43.0.4
	OPENBSD_6_0_BASE:1.43
	OPENBSD_5_9:1.43.0.2
	OPENBSD_5_9_BASE:1.43
	OPENBSD_5_8:1.40.0.6
	OPENBSD_5_8_BASE:1.40
	OPENBSD_5_7:1.40.0.2
	OPENBSD_5_7_BASE:1.40
	OPENBSD_5_6:1.36.0.8
	OPENBSD_5_6_BASE:1.36
	OPENBSD_5_5:1.36.0.6
	OPENBSD_5_5_BASE:1.36
	OPENBSD_5_4:1.36.0.2
	OPENBSD_5_4_BASE:1.36
	OPENBSD_5_3:1.35.0.2
	OPENBSD_5_3_BASE:1.35
	OPENBSD_5_2:1.31.0.6
	OPENBSD_5_2_BASE:1.31
	OPENBSD_5_1_BASE:1.31
	OPENBSD_5_1:1.31.0.4
	OPENBSD_5_0:1.31.0.2
	OPENBSD_5_0_BASE:1.31
	OPENBSD_4_9:1.29.0.6
	OPENBSD_4_9_BASE:1.29
	OPENBSD_4_8:1.29.0.4
	OPENBSD_4_8_BASE:1.29
	OPENBSD_4_7:1.29.0.2
	OPENBSD_4_7_BASE:1.29
	OPENBSD_4_6:1.26.0.6
	OPENBSD_4_6_BASE:1.26
	OPENBSD_4_5:1.26.0.2
	OPENBSD_4_5_BASE:1.26
	OPENBSD_4_4:1.24.0.2
	OPENBSD_4_4_BASE:1.24
	OPENBSD_4_3:1.23.0.2
	OPENBSD_4_3_BASE:1.23;
locks; strict;
comment	@ * @;


1.47
date	2017.07.12.22.57.40;	author jca;	state Exp;
branches;
next	1.46;
commitid	mvSLu9lSFklpNVY7;

1.46
date	2017.07.11.19.41.30;	author florian;	state Exp;
branches;
next	1.45;
commitid	RjEgH2MULEMvYyuu;

1.45
date	2017.05.28.10.39.15;	author benno;	state Exp;
branches;
next	1.44;
commitid	IW4LnWyG3CPq6c3r;

1.44
date	2016.09.02.14.45.51;	author reyk;	state Exp;
branches;
next	1.43;
commitid	vcV98N2DyJGMwDyQ;

1.43
date	2015.11.28.09.52.07;	author reyk;	state Exp;
branches;
next	1.42;
commitid	Xo3TbDi9hUaP9ip0;

1.42
date	2015.10.23.12.22.02;	author benno;	state Exp;
branches;
next	1.41;
commitid	d9YyoEHNu6pPPApW;

1.41
date	2015.08.21.08.45.51;	author yasuoka;	state Exp;
branches;
next	1.40;
commitid	6XMVUYi6SZ55Zx0G;

1.40
date	2015.01.22.17.42.09;	author reyk;	state Exp;
branches;
next	1.39;
commitid	puppem00jmzmdm4f;

1.39
date	2015.01.16.15.06.40;	author deraadt;	state Exp;
branches;
next	1.38;
commitid	tOv8XK6tLyhEfayc;

1.38
date	2014.12.21.00.54.49;	author guenther;	state Exp;
branches;
next	1.37;
commitid	XnjIOhurXdX5o1V9;

1.37
date	2014.10.25.03.23.49;	author lteo;	state Exp;
branches;
next	1.36;
commitid	2uw1UTO4k6erpWzK;

1.36
date	2013.03.10.23.32.53;	author reyk;	state Exp;
branches;
next	1.35;

1.35
date	2013.01.29.15.04.42;	author sthen;	state Exp;
branches;
next	1.34;

1.34
date	2013.01.17.20.34.18;	author bluhm;	state Exp;
branches;
next	1.33;

1.33
date	2012.09.19.09.49.24;	author reyk;	state Exp;
branches;
next	1.32;

1.32
date	2012.09.19.09.47.00;	author reyk;	state Exp;
branches;
next	1.31;

1.31
date	2011.05.09.12.08.47;	author reyk;	state Exp;
branches
	1.31.6.1;
next	1.30;

1.30
date	2011.05.05.12.01.43;	author reyk;	state Exp;
branches;
next	1.29;

1.29
date	2009.08.14.15.31.23;	author reyk;	state Exp;
branches;
next	1.28;

1.28
date	2009.08.07.11.32.54;	author reyk;	state Exp;
branches;
next	1.27;

1.27
date	2009.08.07.11.10.23;	author reyk;	state Exp;
branches;
next	1.26;

1.26
date	2008.12.05.16.37.55;	author reyk;	state Exp;
branches;
next	1.25;

1.25
date	2008.08.08.08.51.21;	author thib;	state Exp;
branches;
next	1.24;

1.24
date	2008.07.19.10.52.32;	author reyk;	state Exp;
branches;
next	1.23;

1.23
date	2008.01.31.09.33.39;	author reyk;	state Exp;
branches;
next	1.22;

1.22
date	2007.12.07.17.17.00;	author reyk;	state Exp;
branches;
next	1.21;

1.21
date	2007.11.24.17.07.28;	author reyk;	state Exp;
branches;
next	1.20;

1.20
date	2007.10.09.05.38.58;	author pyr;	state Exp;
branches;
next	1.19;

1.19
date	2007.09.28.13.29.56;	author pyr;	state Exp;
branches;
next	1.18;

1.18
date	2007.07.16.21.15.36;	author pyr;	state Exp;
branches;
next	1.17;

1.17
date	2007.07.16.21.14.58;	author pyr;	state Exp;
branches;
next	1.16;

1.16
date	2007.05.31.03.24.05;	author pyr;	state Exp;
branches;
next	1.15;

1.15
date	2007.05.27.20.53.10;	author pyr;	state Exp;
branches;
next	1.14;

1.14
date	2007.02.23.00.28.06;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2007.02.12.10.39.48;	author pyr;	state Exp;
branches;
next	1.12;

1.12
date	2007.01.29.14.23.31;	author pyr;	state Exp;
branches;
next	1.11;

1.11
date	2007.01.12.17.12.58;	author pyr;	state Exp;
branches;
next	1.10;

1.10
date	2007.01.11.18.05.08;	author reyk;	state Exp;
branches;
next	1.9;

1.9
date	2007.01.09.03.32.56;	author reyk;	state Exp;
branches;
next	1.8;

1.8
date	2007.01.09.00.45.32;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2007.01.08.20.46.18;	author reyk;	state Exp;
branches;
next	1.6;

1.6
date	2007.01.08.13.37.26;	author reyk;	state Exp;
branches;
next	1.5;

1.5
date	2007.01.03.09.45.29;	author reyk;	state Exp;
branches;
next	1.4;

1.4
date	2006.12.25.19.05.41;	author reyk;	state Exp;
branches;
next	1.3;

1.3
date	2006.12.25.18.12.14;	author reyk;	state Exp;
branches;
next	1.2;

1.2
date	2006.12.16.11.59.12;	author reyk;	state Exp;
branches;
next	1.1;

1.1
date	2006.12.16.11.45.07;	author reyk;	state Exp;
branches;
next	;

1.31.6.1
date	2012.11.05.23.10.37;	author sthen;	state Exp;
branches;
next	;


desc
@@


1.47
log
@Consistently use the variable "ttl" for get/setsockopt

ok benno@@ on an earlier version, input from Kapetanakis Giannis
@
text
@/*	$OpenBSD: check_icmp.c,v 1.46 2017/07/11 19:41:30 florian Exp $	*/

/*
 * Copyright (c) 2006 Pierre-Yves Ritschard <pyr@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/queue.h>
#include <sys/socket.h>
#include <sys/sysctl.h>
#include <sys/time.h>

#include <netinet/in.h>
#include <netinet/ip.h>
#include <netinet/ip_icmp.h>
#include <netinet/icmp6.h>
#include <arpa/inet.h>

#include <event.h>
#include <errno.h>
#include <unistd.h>
#include <string.h>
#include <stdlib.h>

#include "relayd.h"

void	icmp_setup(struct relayd *, struct ctl_icmp_event *, int);
void	check_icmp_add(struct ctl_icmp_event *, int, struct timeval *,
	    void (*)(int, short, void *));
int	icmp_checks_done(struct ctl_icmp_event *);
void	icmp_checks_timeout(struct ctl_icmp_event *, enum host_error);
void	send_icmp(int, short, void *);
void	recv_icmp(int, short, void *);
int	in_cksum(u_short *, int);

void
icmp_setup(struct relayd *env, struct ctl_icmp_event *cie, int af)
{
	int proto = IPPROTO_ICMP, val;

	if (af == AF_INET6)
		proto = IPPROTO_ICMPV6;
	if ((cie->s = socket(af, SOCK_RAW | SOCK_NONBLOCK, proto)) < 0)
		fatal("%s: socket", __func__);
	val = ICMP_RCVBUF_SIZE;
	if (setsockopt(cie->s, SOL_SOCKET, SO_RCVBUF, &val, sizeof(val)) == -1)
		fatal("%s: setsockopt", __func__);
	cie->env = env;
	cie->af = af;
}

void
icmp_init(struct relayd *env)
{
	icmp_setup(env, &env->sc_icmp_send, AF_INET);
	icmp_setup(env, &env->sc_icmp_recv, AF_INET);
	icmp_setup(env, &env->sc_icmp6_send, AF_INET6);
	icmp_setup(env, &env->sc_icmp6_recv, AF_INET6);
	env->sc_id = getpid() & 0xffff;
}

void
schedule_icmp(struct relayd *env, struct host *host)
{
	host->last_up = host->up;
	host->flags &= ~(F_CHECK_SENT|F_CHECK_DONE);

	if (((struct sockaddr *)&host->conf.ss)->sa_family == AF_INET)
		env->sc_has_icmp = 1;
	else
		env->sc_has_icmp6 = 1;
}

void
check_icmp_add(struct ctl_icmp_event *cie, int flags, struct timeval *start,
    void (*fn)(int, short, void *))
{
	struct timeval	 tv;

	if (start != NULL)
		bcopy(start, &cie->tv_start, sizeof(cie->tv_start));
	bcopy(&cie->env->sc_conf.timeout, &tv, sizeof(tv));
	getmonotime(&cie->tv_start);
	event_del(&cie->ev);
	event_set(&cie->ev, cie->s, EV_TIMEOUT|flags, fn, cie);
	event_add(&cie->ev, &tv);
}

void
check_icmp(struct relayd *env, struct timeval *tv)
{
	if (env->sc_has_icmp) {
		check_icmp_add(&env->sc_icmp_recv, EV_READ, tv, recv_icmp);
		check_icmp_add(&env->sc_icmp_send, EV_WRITE, tv, send_icmp);
	}
	if (env->sc_has_icmp6) {
		check_icmp_add(&env->sc_icmp6_recv, EV_READ, tv, recv_icmp);
		check_icmp_add(&env->sc_icmp6_send, EV_WRITE, tv, send_icmp);
	}
}

int
icmp_checks_done(struct ctl_icmp_event *cie)
{
	struct table	*table;
	struct host	*host;

	TAILQ_FOREACH(table, cie->env->sc_tables, entry) {
		if (table->conf.flags & F_DISABLE ||
		    table->conf.check != CHECK_ICMP)
			continue;
		TAILQ_FOREACH(host, &table->hosts, entry) {
			if (((struct sockaddr *)&host->conf.ss)->sa_family !=
			    cie->af)
				continue;
			if (!(host->flags & F_CHECK_DONE))
				return (0);
		}
	}
	return (1);
}

void
icmp_checks_timeout(struct ctl_icmp_event *cie, enum host_error he)
{
	struct table	*table;
	struct host	*host;

	TAILQ_FOREACH(table, cie->env->sc_tables, entry) {
		if (table->conf.flags & F_DISABLE ||
		    table->conf.check != CHECK_ICMP)
			continue;
		TAILQ_FOREACH(host, &table->hosts, entry) {
			if (((struct sockaddr *)&host->conf.ss)->sa_family !=
			    cie->af)
				continue;
			if (!(host->flags & (F_CHECK_DONE|F_DISABLE))) {
				host->up = HOST_DOWN;
				hce_notify_done(host, he);
			}
		}
	}
}

void
send_icmp(int s, short event, void *arg)
{
	struct ctl_icmp_event	*cie = arg;
	struct table		*table;
	struct host		*host;
	struct sockaddr		*to;
	struct icmp		*icp;
	struct icmp6_hdr	*icp6;
	ssize_t			 r;
	u_char			 packet[ICMP_BUF_SIZE];
	socklen_t		 slen, len;
	int			 i = 0, ttl;
	u_int32_t		 id;

	if (event == EV_TIMEOUT) {
		icmp_checks_timeout(cie, HCE_ICMP_WRITE_TIMEOUT);
		return;
	}

	bzero(&packet, sizeof(packet));
	icp = (struct icmp *)packet;
	icp6 = (struct icmp6_hdr *)packet;
	if (cie->af == AF_INET) {
		icp->icmp_type = ICMP_ECHO;
		icp->icmp_code = 0;
		icp->icmp_id = htons(cie->env->sc_id);
		icp->icmp_cksum = 0;
		slen = sizeof(struct sockaddr_in);
	} else {
		icp6->icmp6_type = ICMP6_ECHO_REQUEST;
		icp6->icmp6_code = 0;
		icp6->icmp6_cksum = 0;
		icp6->icmp6_id = htons(cie->env->sc_id);
		slen = sizeof(struct sockaddr_in6);
	}

	TAILQ_FOREACH(table, cie->env->sc_tables, entry) {
		if (table->conf.check != CHECK_ICMP ||
		    table->conf.flags & F_DISABLE)
			continue;
		TAILQ_FOREACH(host, &table->hosts, entry) {
			if (host->flags & (F_DISABLE | F_CHECK_SENT) ||
			    host->conf.parentid)
				continue;
			if (((struct sockaddr *)&host->conf.ss)->sa_family !=
			    cie->af)
				continue;
			i++;
			to = (struct sockaddr *)&host->conf.ss;
			id = htonl(host->conf.id);

			if (cie->af == AF_INET) {
				icp->icmp_seq = htons(i);
				icp->icmp_cksum = 0;
				icp->icmp_mask = id;
				icp->icmp_cksum = in_cksum((u_short *)icp,
				    sizeof(packet));
			} else {
				icp6->icmp6_seq = htons(i);
				icp6->icmp6_cksum = 0;
				memcpy(packet + sizeof(*icp6), &id, sizeof(id));
				icp6->icmp6_cksum = in_cksum((u_short *)icp6,
				    sizeof(packet));
			}

			ttl = host->conf.ttl;
			switch(cie->af) {
			case AF_INET:
				if (ttl > 0) {
					if (setsockopt(s, IPPROTO_IP, IP_TTL,
					    &ttl, sizeof(ttl)) == -1)
						log_warn("%s: setsockopt",
						    __func__);
				} else {
					/* Revert to default TTL */
					len = sizeof(ttl);
					if (getsockopt(s, IPPROTO_IP,
					    IP_IPDEFTTL, &ttl, &len) == 0) {
						if (setsockopt(s, IPPROTO_IP,
						    IP_TTL, &ttl, len) == -1)
							log_warn(
							    "%s: setsockopt",
							    __func__);
					} else
						log_warn("%s: getsockopt",
						    __func__);
				}
				break;
			case AF_INET6:
				if (ttl > 0) {
					if (setsockopt(s, IPPROTO_IPV6,
					    IPV6_UNICAST_HOPS, &ttl,
					    sizeof(ttl)) == -1)
						log_warn("%s: setsockopt",
						    __func__);
				} else {
					/* Revert to default hop limit */
					ttl = -1;
					if (setsockopt(s, IPPROTO_IPV6,
					    IPV6_UNICAST_HOPS, &ttl,
					    sizeof(ttl)) == -1)
						log_warn("%s: setsockopt",
						    __func__);
				}
				break;
			}

			r = sendto(s, packet, sizeof(packet), 0, to, slen);
			if (r == -1) {
				if (errno == EAGAIN || errno == EINTR)
					goto retry;
				host->flags |= F_CHECK_SENT|F_CHECK_DONE;
				host->up = HOST_DOWN;
			} else if (r != sizeof(packet))
				goto retry;
			host->flags |= F_CHECK_SENT;
		}
	}

	return;

 retry:
	event_again(&cie->ev, s, EV_TIMEOUT|EV_WRITE, send_icmp,
	    &cie->tv_start, &cie->env->sc_conf.timeout, cie);
}

void
recv_icmp(int s, short event, void *arg)
{
	struct ctl_icmp_event	*cie = arg;
	u_char			 packet[ICMP_BUF_SIZE];
	socklen_t		 slen;
	struct sockaddr_storage	 ss;
	struct icmp		*icp;
	struct icmp6_hdr	*icp6;
	u_int16_t		 icpid;
	struct host		*host;
	ssize_t			 r;
	u_int32_t		 id;

	if (event == EV_TIMEOUT) {
		icmp_checks_timeout(cie, HCE_ICMP_READ_TIMEOUT);
		return;
	}

	bzero(&packet, sizeof(packet));
	bzero(&ss, sizeof(ss));
	slen = sizeof(ss);

	r = recvfrom(s, packet, sizeof(packet), 0,
	    (struct sockaddr *)&ss, &slen);
	if (r == -1 || r != ICMP_BUF_SIZE) {
		if (r == -1 && errno != EAGAIN && errno != EINTR)
			log_debug("%s: receive error", __func__);
		goto retry;
	}

	if (cie->af == AF_INET) {
		icp = (struct icmp *)(packet + sizeof(struct ip));
		icpid = ntohs(icp->icmp_id);
		id = icp->icmp_mask;
	} else {
		icp6 = (struct icmp6_hdr *)packet;
		icpid = ntohs(icp6->icmp6_id);
		memcpy(&id, packet + sizeof(*icp6), sizeof(id));
	}
	if (icpid != cie->env->sc_id)
		goto retry;
	id = ntohl(id);
	host = host_find(cie->env, id);
	if (host == NULL) {
		log_warn("%s: ping for unknown host received", __func__);
		goto retry;
	}
	if (bcmp(&ss, &host->conf.ss, slen)) {
		log_warnx("%s: forged icmp packet?", __func__);
		goto retry;
	}

	host->up = HOST_UP;
	host->flags |= F_CHECK_DONE;
	hce_notify_done(host, HCE_ICMP_OK);

	if (icmp_checks_done(cie))
		return;

 retry:
	event_again(&cie->ev, s, EV_TIMEOUT|EV_READ, recv_icmp,
	    &cie->tv_start, &cie->env->sc_conf.timeout, cie);
}

/* in_cksum from ping.c --
 *	Checksum routine for Internet Protocol family headers (C Version)
 *
 * Copyright (c) 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Mike Muuss.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
int
in_cksum(u_short *addr, int len)
{
	int nleft = len;
	u_short *w = addr;
	int sum = 0;
	u_short answer = 0;

	/*
	 * Our algorithm is simple, using a 32 bit accumulator (sum), we add
	 * sequential 16 bit words to it, and at the end, fold back all the
	 * carry bits from the top 16 bits into the lower 16 bits.
	 */
	while (nleft > 1)  {
		sum += *w++;
		nleft -= 2;
	}

	/* mop up an odd byte, if necessary */
	if (nleft == 1) {
		*(u_char *)(&answer) = *(u_char *)w ;
		sum += answer;
	}

	/* add back carry outs from top 16 bits to low 16 bits */
	sum = (sum >> 16) + (sum & 0xffff);	/* add hi 16 to low 16 */
	sum += (sum >> 16);			/* add carry */
	answer = ~sum;				/* truncate to 16 bits */

	return (answer);
}
@


1.46
log
@Correctly set ttl for IPv4 and IPv6.
Problem noted and fix from Kapetanakis Giannis, thanks!
Input & OK jca.
@
text
@d1 1
a1 1
/*	$OpenBSD: check_icmp.c,v 1.45 2017/05/28 10:39:15 benno Exp $	*/
d223 1
d226 1
a226 1
				if ((ttl = host->conf.ttl) > 0) {
d228 1
a228 1
					    &host->conf.ttl, sizeof(int)) == -1)
d247 1
a247 1
				if ((ttl = host->conf.ttl) > 0) {
d249 2
a250 2
					    IPV6_UNICAST_HOPS, &host->conf.ttl,
					    sizeof(int)) == -1)
d258 1
a258 1
					    sizeof(int)) == -1)
@


1.45
log
@use __func__ in log messages. fix some whitespace while here.
From Hiltjo Posthuma hiltjo -AT codemadness -DOT- org, thanks!
ok florian, claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: check_icmp.c,v 1.44 2016/09/02 14:45:51 reyk Exp $	*/
d223 39
a261 12
			if ((ttl = host->conf.ttl) > 0)
				(void)setsockopt(s, IPPROTO_IP, IP_TTL,
				    &host->conf.ttl, sizeof(int));
			else {
				/* Revert to default TTL */
				len = sizeof(ttl);
				if (getsockopt(s, IPPROTO_IP, IP_IPDEFTTL,
				    &ttl, &len) == 0)
					(void)setsockopt(s, IPPROTO_IP, IP_TTL,
					    &ttl, len);
				else
				    log_warn("%s: getsockopt",__func__);
@


1.44
log
@Split "struct relayd" into two structs: "struct relayd" and "struct
relayd_config".  This way we can send all the relevant global
configuration to the children, not just the flags and the opts.

With input from and
OK claudio@@ benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: check_icmp.c,v 1.43 2015/11/28 09:52:07 reyk Exp $	*/
d56 1
a56 1
		fatal("icmp_setup: socket");
d59 1
a59 1
		fatal("icmp_setup: setsockopt");
@


1.43
log
@Use SOCK_NONBLOCK in relayd as well.

OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: check_icmp.c,v 1.42 2015/10/23 12:22:02 benno Exp $	*/
d94 1
a94 1
	bcopy(&cie->env->sc_timeout, &tv, sizeof(tv));
d253 1
a253 1
	    &cie->tv_start, &cie->env->sc_timeout, cie);
d318 1
a318 1
	    &cie->tv_start, &cie->env->sc_timeout, cie);
@


1.42
log
@let the icmp check use getsockopt IP_IPDEFTTL to get the default ttl
instead of using sysctl. makes it possible to pledge hce.
@
text
@d1 1
a1 1
/*	$OpenBSD: check_icmp.c,v 1.41 2015/08/21 08:45:51 yasuoka Exp $	*/
d55 1
a55 1
	if ((cie->s = socket(af, SOCK_RAW, proto)) < 0)
a59 1
	socket_set_blockmode(cie->s, BM_NONBLOCK);
@


1.41
log
@Increase the input side socket buffer size for "check icmp" not to
drop the reply messages when "check icmp" is used with many hosts.

ok reyk benno
@
text
@d1 1
a1 1
/*	$OpenBSD: check_icmp.c,v 1.40 2015/01/22 17:42:09 reyk Exp $	*/
d169 2
a170 3
	socklen_t		 slen;
	int			 i = 0, ttl, mib[4];
	size_t			 len;
a228 4
				mib[0] = CTL_NET;
				mib[1] = cie->af;
				mib[2] = IPPROTO_IP;
				mib[3] = IPCTL_DEFTTL;
d230 2
a231 1
				if (sysctl(mib, 4, &ttl, &len, NULL, 0) == 0)
d233 3
a235 1
					    &ttl, sizeof(int));
@


1.40
log
@Clean up the relayd headers with help of include-what-you-use and some
manual review.  Based on common practice, relayd.h now includes the
necessary headers for itself.

OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: check_icmp.c,v 1.39 2015/01/16 15:06:40 deraadt Exp $	*/
d51 1
a51 1
	int proto = IPPROTO_ICMP;
d57 3
@


1.39
log
@Adapt to <limits.h> universe.
ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: check_icmp.c,v 1.38 2014/12/21 00:54:49 guenther Exp $	*/
d23 1
a24 1
#include <net/if.h>
d29 1
a30 1
#include <limits.h>
a35 2

#include <openssl/ssl.h>
@


1.38
log
@Stop pulling in <arpa/inet.h> or <arpa/nameser.h> when unnecessary.
*Do* pull it in when in_{port,addr}_h is needed and <netinet/in.h> isn't.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: check_icmp.c,v 1.37 2014/10/25 03:23:49 lteo Exp $	*/
a18 1
#include <sys/param.h>
@


1.37
log
@Remove unnecessary netinet/in_systm.h include.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: check_icmp.c,v 1.36 2013/03/10 23:32:53 reyk Exp $	*/
a29 1
#include <arpa/inet.h>
@


1.36
log
@This diff changes relayd to use the monotonic clock instead of
gettimeofday().  It was also bugging me for some time to have all
these checks of gettimeofday()'s return value: it should not fail.  So
this diff introduces a void getmonotime(struct timeval *tv) that calls
clock_gettime(CLOCK_MONOTONIC, &ts) and converts the output to a
struct timeval that can be used with the existing code and the
timeval-specific timer functions (timerclear, timersub, ...).  It does
not return a status but calls fatal() on error-that-should-not-happen.

ok sthen@@ chris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: check_icmp.c,v 1.35 2013/01/29 15:04:42 sthen Exp $	*/
a25 1
#include <netinet/in_systm.h>
@


1.35
log
@use correct function name in fatal error message
@
text
@d1 1
a1 1
/*	$OpenBSD: check_icmp.c,v 1.34 2013/01/17 20:34:18 bluhm Exp $	*/
d98 1
a98 2
	if (gettimeofday(&cie->tv_start, NULL) == -1)
		fatal("check_icmp_add: gettimeofday");
@


1.34
log
@Remove unnecessary pointer casts.  No binary diff.
OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: check_icmp.c,v 1.33 2012/09/19 09:49:24 reyk Exp $	*/
d61 1
a61 1
		fatal("icmp_init: socket");
@


1.33
log
@Copy the host id value to the ICMP echo payload in network byte order and
in a nicer way that silences the compiler.

ok benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: check_icmp.c,v 1.32 2012/09/19 09:47:00 reyk Exp $	*/
d164 1
a164 1
	struct ctl_icmp_event	*cie = (struct ctl_icmp_event *)arg;
d265 1
a265 1
	struct ctl_icmp_event	*cie = (struct ctl_icmp_event *)arg;
@


1.32
log
@Fix ICMP checks by setting the socklen correctly before calling recvfrom().

ok benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: check_icmp.c,v 1.31 2011/05/09 12:08:47 reyk Exp $	*/
d175 1
d212 2
d217 1
a217 2
				memcpy(icp->icmp_data, &host->conf.id,
				    sizeof(host->conf.id));
d223 1
a223 2
				memcpy(packet + sizeof(*icp6), &host->conf.id,
				    sizeof(host->conf.id));
d274 1
a274 1
	objid_t			 id;
d296 1
a296 1
		memcpy(&id, icp->icmp_data, sizeof(id));
d304 1
@


1.31
log
@Reorganize the relayd code to use the proc.c privsep API/commodity
functions that are based on work for iked and smtpd.  This simplifies
the setup of privsep processes and moves some redundant and repeated
code to a single place - which is always good from a quality and
security point of view.  The relayd version of proc.c is different to
the current version in iked because it uses 1:N communications between
processes, eg. a single parent process is talking to many forked relay
children while iked only needs 1:1 communications.

ok sthen@@ pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: check_icmp.c,v 1.30 2011/05/05 12:01:43 reyk Exp $	*/
d282 1
@


1.31.6.1
log
@MFC reyk's fix for relayd check icmp, ok benno@@.
Reported as affecting 5.2 and diff tested by Andrew Klettke, thanks.
@
text
@d1 1
a1 1
/*	$OpenBSD: check_icmp.c,v 1.33 2012/09/19 09:49:24 reyk Exp $	*/
a174 1
	u_int32_t		 id;
a210 2
			id = htonl(host->conf.id);

d214 2
a215 1
				icp->icmp_mask = id;
d221 2
a222 1
				memcpy(packet + sizeof(*icp6), &id, sizeof(id));
d273 1
a273 1
	u_int32_t		 id;
a281 1
	slen = sizeof(ss);
d294 1
a294 1
		id = icp->icmp_mask;
a301 1
	id = ntohl(id);
@


1.30
log
@Update all logging and debug functions to use the __func__ macro
instead of static function names.  __func__ is C99 and perfectly fine
to use. It also avoids printing errors; for example if a statement
log_debug("foo:"..) was moved or copied from function foo() to bar()
and the log message was not updated...
@
text
@d1 1
a1 1
/*	$OpenBSD: check_icmp.c,v 1.29 2009/08/14 15:31:23 reyk Exp $	*/
d62 1
a62 1
	session_socket_blockmode(cie->s, BM_NONBLOCK);
@


1.29
log
@do not timeout disabled hosts in the icmp checks

Thanks to Sebastian Benoit, closes pr6146
@
text
@d1 1
a1 1
/*	$OpenBSD: check_icmp.c,v 1.28 2009/08/07 11:32:54 reyk Exp $	*/
d287 1
a287 1
			log_debug("recv_icmp: receive error");
d304 1
a304 1
		log_warn("recv_icmp: ping for unknown host received");
d308 1
a308 1
		log_warnx("recv_icmp: forged icmp packet?");
@


1.28
log
@get the default ttl via sysctl instead of using IPDEFTTL
@
text
@d1 1
a1 1
/*	$OpenBSD: check_icmp.c,v 1.27 2009/08/07 11:10:23 reyk Exp $	*/
d153 1
a153 1
			if (!(host->flags & F_CHECK_DONE)) {
@


1.27
log
@allow to modify the IP TTL value for host checks.  this can be used to
check if the host is only n hops away and not re-routed over a longer
path.
@
text
@d1 1
a1 1
/*	$OpenBSD: check_icmp.c,v 1.26 2008/12/05 16:37:55 reyk Exp $	*/
d19 1
d23 1
d173 2
a174 1
	int			 i = 0, ttl;
d228 1
a228 1
				setsockopt(s, IPPROTO_IP, IP_TTL,
d232 8
a239 3
				ttl = IPDEFTTL;
				(void)setsockopt(s, IPPROTO_IP, IP_TTL,
				    &ttl, sizeof(int));
@


1.26
log
@change the way relayd reports check results: instead of logging an
arbitrary string in debugging mode, it will store an error code
(HCE_*) for each host.  the error code can be translated to a string
(in log.c) for debugging but it will also be passed to relayctl via
the control socket.

from a user point of view, this will print a human-readable error
message in the "relayctl show hosts" output if a host is down because
the check failed.  the relayctl(8) manpage includes detailed
explanations of the error messages including mitigations for the
most-common problems.

ok jmc@@ (manpages)
ok phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: check_icmp.c,v 1.25 2008/08/08 08:51:21 thib Exp $	*/
d171 1
a171 1
	int			 i = 0;
d222 10
@


1.25
log
@Check gettimeofday() against -1; Add a missing error check in one place.

OK reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: check_icmp.c,v 1.24 2008/07/19 10:52:32 reyk Exp $	*/
d46 1
a46 1
void	icmp_checks_timeout(struct ctl_icmp_event *, const char *);
d138 1
a138 1
icmp_checks_timeout(struct ctl_icmp_event *cie, const char *msg)
d153 1
a153 1
				hce_notify_done(host, msg);
d174 1
a174 1
		icmp_checks_timeout(cie, "send_icmp: timeout");
d258 1
a258 1
		icmp_checks_timeout(cie, NULL);
d296 1
a296 1
	hce_notify_done(host, "recv_icmp: done");
@


1.24
log
@If the new 'parent' keyword is specified for a host in a table,
inherit the state from another host with the specified Id; no
additional check will be for the inheriting host.  This helps in
scenarios with lots of IP aliases that all point to the same service
on the same host (like web hosting with many SSL domains).

discussed with pyr, tested in different setups
@
text
@d1 1
a1 1
/*	$OpenBSD: check_icmp.c,v 1.23 2008/01/31 09:33:39 reyk Exp $	*/
d96 1
a96 1
	if (gettimeofday(&cie->tv_start, NULL))
@


1.23
log
@add prefixes to names of structure elements to make it easier to grep
for code, start with struct relayd.  finally.

ok thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: check_icmp.c,v 1.22 2007/12/07 17:17:00 reyk Exp $	*/
d200 2
a201 1
			if (host->flags & (F_DISABLE | F_CHECK_SENT))
@


1.22
log
@hoststated gets renamed to relayd.  easier to type, and actually says
what the daemon does - it is a relayer that pays attention to the status
of pools of hosts; not a status checkers that happens to do some relaying
@
text
@d1 1
a1 1
/*	$OpenBSD: check_icmp.c,v 1.21 2007/11/24 17:07:28 reyk Exp $	*/
d68 5
a72 5
	icmp_setup(env, &env->icmp_send, AF_INET);
	icmp_setup(env, &env->icmp_recv, AF_INET);
	icmp_setup(env, &env->icmp6_send, AF_INET6);
	icmp_setup(env, &env->icmp6_recv, AF_INET6);
	env->id = getpid() & 0xffff;
d82 1
a82 1
		env->has_icmp = 1;
d84 1
a84 1
		env->has_icmp6 = 1;
d95 1
a95 1
	bcopy(&cie->env->timeout, &tv, sizeof(tv));
d106 7
a112 7
	if (env->has_icmp) {
		check_icmp_add(&env->icmp_recv, EV_READ, tv, recv_icmp);
		check_icmp_add(&env->icmp_send, EV_WRITE, tv, send_icmp);
	}
	if (env->has_icmp6) {
		check_icmp_add(&env->icmp6_recv, EV_READ, tv, recv_icmp);
		check_icmp_add(&env->icmp6_send, EV_WRITE, tv, send_icmp);
d122 1
a122 1
	TAILQ_FOREACH(table, cie->env->tables, entry) {
d143 1
a143 1
	TAILQ_FOREACH(table, cie->env->tables, entry) {
d184 1
a184 1
		icp->icmp_id = htons(cie->env->id);
d191 1
a191 1
		icp6->icmp6_id = htons(cie->env->id);
d195 1
a195 1
	TAILQ_FOREACH(table, cie->env->tables, entry) {
d239 1
a239 1
	    &cie->tv_start, &cie->env->timeout, cie);
d281 1
a281 1
	if (icpid != cie->env->id)
d302 1
a302 1
	    &cie->tv_start, &cie->env->timeout, cie);
@


1.21
log
@sort includes, adjust to style(9)
@
text
@d1 1
a1 1
/*	$OpenBSD: check_icmp.c,v 1.20 2007/10/09 05:38:58 pyr Exp $	*/
d40 1
a40 1
#include "hoststated.h"
d42 1
a42 1
void	icmp_setup(struct hoststated *, struct ctl_icmp_event *, int);
d52 1
a52 1
icmp_setup(struct hoststated *env, struct ctl_icmp_event *cie, int af)
d66 1
a66 1
icmp_init(struct hoststated *env)
d76 1
a76 1
schedule_icmp(struct hoststated *env, struct host *host)
d104 1
a104 1
check_icmp(struct hoststated *env, struct timeval *tv)
@


1.20
log
@Do not notify twice about the same timeout in check_icmp, this previously
corrupted statistics.
Found out by Piotr Sikora < piotr@@sikora.nu >.
@
text
@d1 1
a1 1
/*	$OpenBSD: check_icmp.c,v 1.19 2007/09/28 13:29:56 pyr Exp $	*/
d22 2
a23 1
#include <sys/param.h>
a28 1
#include <net/if.h>
d30 1
@


1.19
log
@Correct my mail address.
@
text
@d1 1
a1 1
/*	$OpenBSD: check_icmp.c,v 1.18 2007/07/16 21:15:36 pyr Exp $	*/
d150 1
a150 1
			if (!(host->flags & F_CHECK_DONE))
d152 2
a153 1
			hce_notify_done(host, msg);
@


1.18
log
@typo
also found by Kevin Steves
@
text
@d1 1
a1 1
/*	$OpenBSD: check_icmp.c,v 1.17 2007/07/16 21:14:58 pyr Exp $	*/
d4 1
a4 1
 * Copyright (c) 2006 Pierre-Yves Ritschard <pyr@@spootnik.org>
@


1.17
log
@use fatal and not err, the message would get lost.
found by Kevin Steves <stevesk (at) pobox dot com>
@
text
@d1 1
a1 1
/*	$OpenBSD: check_icmp.c,v 1.16 2007/05/31 03:24:05 pyr Exp $	*/
d223 1
a223 1
				if (errno == EAGAIN && errno == EINTR)
@


1.16
log
@allocate table lists and service lists instead of using static structs.
split the code to start the event loop in two functions.
introduce merge_config which will be used later on.
@
text
@d1 1
a1 1
/*	$OpenBSD: check_icmp.c,v 1.15 2007/05/27 20:53:10 pyr Exp $	*/
a35 1
#include <err.h>
d58 1
a58 1
		err(1, "icmp_init: socket");
@


1.15
log
@Second step towards hoststated reload:
First split out hosts, tables and services into to structs, one that
contains the runtime fields and one (inside the runtime) that contains
mostly static fields that will be sent over the socket during reload.

Also move the demoted field of tables inside the flags field as its
just a boolean.
ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: check_icmp.c,v 1.14 2007/02/23 00:28:06 deraadt Exp $	*/
d122 1
a122 1
	TAILQ_FOREACH(table, &cie->env->tables, entry) {
d143 1
a143 1
	TAILQ_FOREACH(table, &cie->env->tables, entry) {
d194 1
a194 1
	TAILQ_FOREACH(table, &cie->env->tables, entry) {
@


1.14
log
@knf
@
text
@d1 1
a1 1
/*	$OpenBSD: check_icmp.c,v 1.13 2007/02/12 10:39:48 pyr Exp $	*/
d81 1
a81 1
	if (((struct sockaddr *)&host->ss)->sa_family == AF_INET)
d123 2
a124 1
		if (table->flags & F_DISABLE || table->check != CHECK_ICMP)
d127 1
a127 1
			if (((struct sockaddr *)&host->ss)->sa_family !=
d144 2
a145 1
		if (table->flags & F_DISABLE || table->check != CHECK_ICMP)
d148 1
a148 1
			if (((struct sockaddr *)&host->ss)->sa_family !=
d195 2
a196 1
		if (table->check != CHECK_ICMP || table->flags & F_DISABLE)
d201 1
a201 1
			if (((struct sockaddr *)&host->ss)->sa_family !=
d205 1
a205 1
			to = (struct sockaddr *)&host->ss;
d209 2
a210 2
				memcpy(icp->icmp_data, &host->id,
				    sizeof(host->id));
d216 2
a217 2
				memcpy(packet + sizeof(*icp6), &host->id,
				    sizeof(host->id));
d287 1
a287 1
	if (bcmp(&ss, &host->ss, slen)) {
@


1.13
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: check_icmp.c,v 1.12 2007/01/29 14:23:31 pyr Exp $	*/
d359 1
a359 1
	sum = (sum >> 16) + (sum & 0xffff);     /* add hi 16 to low 16 */
@


1.12
log
@Add SSL support to hoststated.
with help and OK reyk@@
with help and advice by claudio@@ and Srebrenko Sehic
@
text
@d1 1
a1 1
/*	$OpenBSD: check_icmp.c,v 1.11 2007/01/12 17:12:58 pyr Exp $	*/
d126 2
a127 1
			if (((struct sockaddr *)&host->ss)->sa_family != cie->af)
d146 2
a147 1
			if (((struct sockaddr *)&host->ss)->sa_family != cie->af)
@


1.11
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: check_icmp.c,v 1.10 2007/01/11 18:05:08 reyk Exp $	*/
d37 2
@


1.10
log
@use real async events for checks and improve the non-blocking socket
usage. also modify the check_icmp code to use non-blocking raw sockets
and merge the icmp4 and icmp6 functions. some other minor changes
while i'm here.

as discussed with pyr@@ claudio@@ deraadt@@
ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: check_icmp.c,v 1.9 2007/01/09 03:32:56 reyk Exp $	*/
d194 2
a195 1
			if (((struct sockaddr *)&host->ss)->sa_family != cie->af)
d256 2
a257 1
	r = recvfrom(s, packet, sizeof(packet), 0, (struct sockaddr *)&ss, &slen);
@


1.9
log
@use the correct buffer sizes.

(this code needs some more work to implement a better icmp handling,
but this will fix a serious bug for now)
@
text
@d1 1
a1 1
/*	$OpenBSD: check_icmp.c,v 1.8 2007/01/09 00:45:32 deraadt Exp $	*/
d36 1
d40 7
a46 6
int	icmp6_checks_done(struct ctl_icmp_event *);
int	icmp4_checks_done(struct ctl_icmp_event *);
void	send_icmp6(struct ctl_icmp_event *, struct host *);
void	send_icmp4(struct ctl_icmp_event *, struct host *);
void	recv_icmp6(int, short, void *);
void	recv_icmp4(int, short, void *);
d50 1
a50 1
schedule_icmp(struct ctl_icmp_event *cie, struct table *table)
d52 26
a77 1
	struct host	*host;
d79 4
a82 11
	TAILQ_FOREACH(host, &table->hosts, entry) {
		if (host->flags & F_DISABLE)
			continue;
		host->last_up = host->up;
		host->flags &= ~F_CHECK_DONE;
		if (((struct sockaddr *)&host->ss)->sa_family == AF_INET) {
			send_icmp4(cie, host);
		} else {
			send_icmp6(cie, host);
		}
	}
d86 2
a87 1
check_icmp(struct ctl_icmp_event *cie)
d89 1
a89 1
	struct timeval	tv;
d91 3
d95 17
a111 8
		fatal("check_icmp: gettimeofday");
	bcopy(&cie->env->timeout, &tv, sizeof(tv));
	if (cie->has_icmp4)
		event_once(cie->icmp_sock, EV_READ|EV_TIMEOUT,
		    recv_icmp4, cie, &tv);
	if (cie->has_icmp6)
		event_once(cie->icmp6_sock, EV_READ|EV_TIMEOUT,
		    recv_icmp6, cie, &tv);
d115 1
a115 1
icmp6_checks_done(struct ctl_icmp_event *cie)
d124 1
a124 2
			if (((struct sockaddr *)&host->ss)->sa_family !=
			    AF_INET6)
d133 2
a134 2
int
icmp4_checks_done(struct ctl_icmp_event *cie)
d143 1
a143 2
			if (((struct sockaddr *)&host->ss)->sa_family !=
			    AF_INET)
d145 3
a147 3
			if (!(host->flags & F_CHECK_DONE)) {
				return (0);
			}
a149 1
	return (1);
d153 1
a153 1
send_icmp6(struct ctl_icmp_event *cie, struct host *host)
d155 3
d159 3
a161 2
	struct icmp6_hdr	*icp;
	ssize_t			 i;
d163 2
d166 2
a167 16
	cie->has_icmp6 = 1;
	to = (struct sockaddr *)&host->ss;
	bzero(&packet, sizeof(packet));
	icp = (struct icmp6_hdr *)packet;
	icp->icmp6_type = ICMP6_ECHO_REQUEST;
	icp->icmp6_code = 0;
	icp->icmp6_seq = 1;
	icp->icmp6_id = getpid() & 0xffff;

	memcpy((packet + sizeof(*icp)), &host->id, sizeof(host->id));

	i = sendto(cie->icmp6_sock, packet, sizeof(packet), 0, to,
	    sizeof(struct sockaddr_in6));
	if (i < 0 || i != sizeof(packet)) {
		host->up = HOST_DOWN;
		hce_notify_done(host, "send_icmp6: cannot send");
a169 9
}

void
send_icmp4(struct ctl_icmp_event *cie, struct host *host)
{
	struct sockaddr	*to;
	struct icmp	*icp;
	ssize_t		 i;
	u_char		 packet[ICMP_BUF_SIZE];
a170 2
	cie->has_icmp4 = 1;
	to = (struct sockaddr *)&host->ss;
d173 13
a185 14
	icp->icmp_type = ICMP_ECHO;
	icp->icmp_code = 0;
	icp->icmp_seq = htons(1);
	icp->icmp_id = htons(getpid() & 0xffff);
	icp->icmp_cksum = 0;

	memcpy(icp->icmp_data, &host->id, sizeof(host->id));
	icp->icmp_cksum = in_cksum((u_short *)icp, sizeof(packet));

	i = sendto(cie->icmp_sock, packet, sizeof(packet), 0, to,
	    sizeof(struct sockaddr_in));
	if (i < 0 || i != sizeof(packet)) {
		host->up = HOST_DOWN;
		hce_notify_done(host, "send_icmp4: cannot send");
a186 1
}
d188 7
a194 22
void
recv_icmp6(int s, short event, void *arg)
{
	struct ctl_icmp_event	*cie = arg;
	u_char			 packet[ICMP_BUF_SIZE];
	socklen_t		 len;
	struct sockaddr_storage	 ss;
	struct icmp6_hdr	*icp;
	struct host		*host;
	struct table		*table;
	ssize_t			 i;
	objid_t			 id;
	struct timeval		 tv;
	struct timeval		 tv_now;

	if (event == EV_TIMEOUT) {
		/*
		 * mark all hosts which have not responded yet as down.
		 */
		TAILQ_FOREACH(table, &cie->env->tables, entry) {
			if (table->check != CHECK_ICMP ||
			    table->flags & F_DISABLE)
d196 16
a211 9
			TAILQ_FOREACH(host, &table->hosts, entry) {
				if (host->flags & F_DISABLE)
					continue;
				if (((struct sockaddr *)&host->ss)->sa_family
				    != AF_INET6)
					continue;
				if (!(host->flags & F_CHECK_DONE)) {
					host->up = HOST_DOWN;
				}
d213 10
a223 1
		return;
d225 6
a230 31
	bzero(&packet, sizeof(packet));
	bzero(&ss, sizeof(ss));
	len = sizeof(struct sockaddr_in6);
	i = recvfrom(s, packet, sizeof(packet), 0, (struct sockaddr *)&ss, &len);
	if (i < 0 || i != sizeof(packet)) {
		log_warn("recv_icmp6: did not receive valid ping");
		return;
	}
	icp = (struct icmp6_hdr *)(packet);
	memcpy(&id, (packet + sizeof(*icp)), sizeof(id));
	host = host_find(cie->env, id);
	if (host == NULL)
		log_warn("recv_icmp6: ping for unknown host received");
	if (bcmp(&ss, &host->ss, len)) {
		log_warnx("recv_icmp6: forged icmp packet ?");
		return;
	}
	if (icp->icmp6_id != (getpid() & 0xffff)) {
		log_warnx("recv_icmp6: did not receive valid ident");
		host->up = HOST_DOWN;
	} else
		host->up = HOST_UP;
	hce_notify_done(host, "recv_icmp6: final");
	if (icmp6_checks_done(cie))
		return;
	if (gettimeofday(&tv_now, NULL))
		fatal("recv_icmp6: gettimeofday");
	bcopy(&cie->env->timeout, &tv, sizeof(tv));
	timersub(&tv_now, &cie->tv_start, &tv_now);
	timersub(&tv, &tv_now, &tv);
	event_once(cie->icmp6_sock, EV_READ|EV_TIMEOUT, recv_icmp6, cie, &tv);
d234 1
a234 1
recv_icmp4(int s, short event, void *arg)
d236 4
a239 1
	socklen_t		 len;
d241 2
a242 2
	struct ctl_icmp_event	*cie = arg;
	u_char			 packet[ICMP_BUF_SIZE];
d244 1
a244 2
	struct table		*table;
	ssize_t			 i;
a245 3
	struct timeval		 tv;
	struct timeval		 tv_now;
	struct sockaddr_storage	 ss;
d248 1
a248 18
		/*
		 * mark all hosts which have not responded yet as down.
		 */
		TAILQ_FOREACH(table, &cie->env->tables, entry) {
			if (table->check != CHECK_ICMP ||
			    table->flags & F_DISABLE)
				continue;
			TAILQ_FOREACH(host, &table->hosts, entry) {
				if (host->flags & F_DISABLE)
					continue;
				if (((struct sockaddr *)&host->ss)->sa_family
				    != AF_INET)
					continue;
				if (!(host->flags & F_CHECK_DONE)) {
					host->up = HOST_DOWN;
				}
			}
		}
a251 1
	len = sizeof(struct sockaddr_in);
d254 16
a269 4
	i = recvfrom(s, packet, sizeof(packet), 0, (struct sockaddr *)&ss, &len);
	if (i < 0 || i != sizeof(packet)) {
		log_warn("recv_icmp4: did not receive valid ping");
		return;
d271 2
a272 3

	icp = (struct icmp *)(packet + sizeof(struct ip));
	memcpy(&id, icp->icmp_data, sizeof(id));
d275 2
a276 2
		log_warnx("recv_icmp4: received ping for unknown host");
		return;
d278 3
a280 3
	if (bcmp(&ss, &host->ss, len)) {
		log_warnx("recv_icmp4: forged icmp packet ?");
		return;
a281 5
	if (ntohs(icp->icmp_id) != (getpid() & 0xffff)) {
		log_warnx("recv_icmp4: did not receive valid ident");
		host->up = HOST_DOWN;
	} else
		host->up = HOST_UP;
d283 1
d285 3
a287 2
	if (icmp4_checks_done(cie)) {
		hce_notify_done(host, "recv_icmp4: all done");
a288 2
	}
	hce_notify_done(host, "recv_icmp4: host");
d290 3
a292 7
	if (gettimeofday(&tv_now, NULL))
		fatal("recv_icmp4: gettimeofday");

	bcopy(&cie->env->timeout, &tv, sizeof(tv));
	timersub(&tv_now, &cie->tv_start, &tv_now);
	timersub(&tv, &tv_now, &tv);
	event_once(cie->icmp_sock, EV_READ|EV_TIMEOUT, recv_icmp4, cie, &tv);
@


1.8
log
@adapt to rename
@
text
@d1 1
a1 1
/*	$OpenBSD: check_icmp.c,v 1.7 2007/01/08 20:46:18 reyk Exp $	*/
d128 1
a128 2
	int			 datalen = (64 - 8);
	u_char			 packet[datalen];
d141 1
a141 1
	i = sendto(cie->icmp6_sock, packet, datalen + 8, 0, to,
d143 1
a143 1
	if (i < 0 || i != datalen + 8) {
d156 1
a156 2
	int		 datalen = (64 - 8);
	u_char		 packet[datalen];
d169 1
a169 1
	icp->icmp_cksum = in_cksum((u_short *)icp, datalen + 8);
d171 1
a171 1
	i = sendto(cie->icmp_sock, packet, datalen + 8, 0, to,
d173 1
a173 1
	if (i < 0 || i != datalen + 8) {
d183 1
a183 2
	int			 datalen = (64 - 8);
	u_char			 packet[datalen];
d218 2
a219 2
	i = recvfrom(s, packet, datalen + 8, 0, (struct sockaddr *)&ss, &len);
	if (i < 0 || i != datalen + 8) {
a250 1
	int			 datalen = (64 - 8);
d254 1
a254 1
	u_char			 packet[datalen];
d288 2
a289 2
	i = recvfrom(s, packet, datalen + 8, 0, (struct sockaddr *)&ss, &len);
	if (i < 0 || i != (datalen + 8)) {
@


1.7
log
@do NOT use the regexp interface. it is way to complicated, error-prone
and we don't know about all the possible security problems.

change the check send/expect code to use the fnmatch(3) interface
using shell globbing rules instead. this allows simple patterns like
"220 * ESMTP*" or "SSH-[12].??-*".

suggested by deraadt@@ and otto@@
ok Pierre-Yves Ritschard (pyr at spootnik dot org)
@
text
@d1 1
a1 1
/*	$OpenBSD: check_icmp.c,v 1.6 2007/01/08 13:37:26 reyk Exp $	*/
d37 1
a37 1
#include "hostated.h"
@


1.6
log
@add a generic send/expect check using regular expression (see
regex(3)).  this allows to define additional checks for other TCP
protocols.

From Pierre-Yves Ritschard (pyr at spootnik dot org)
@
text
@d1 1
a1 1
/*	$OpenBSD: check_icmp.c,v 1.5 2007/01/03 09:45:29 reyk Exp $	*/
a35 1
#include <regex.h>
@


1.5
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: check_icmp.c,v 1.4 2006/12/25 19:05:41 reyk Exp $	*/
d36 1
@


1.4
log
@fix the conversion from milliseconds to struct timeval, which uses
seconds (tv_sec) and microseconds (tv_usec), but the code assumed
seconds and milliseconds...
@
text
@d1 1
a1 1
/*	$OpenBSD: check_icmp.c,v 1.3 2006/12/25 18:12:14 reyk Exp $	*/
d258 1
a258 1
	u_char		 	 packet[datalen];
d288 1
a288 1
	
d318 1
a318 1
		return;	
d321 1
a321 1
	
@


1.3
log
@partial rewrite of the check_* routines to use libevent everywhere
instead of nested select() calls and to handle the non-blocking
sockets properly.

From Pierre-Yves Ritschard (pyr at spootnik dot org)
(with a little help by me)
@
text
@d1 1
a1 1
/*	$OpenBSD: check_icmp.c,v 1.2 2006/12/16 11:59:12 reyk Exp $	*/
d72 2
a73 3
	if (cie->has_icmp4) {
		tv.tv_sec = cie->env->timeout / 1000;
		tv.tv_usec = cie->env->timeout % 1000;
d76 1
a76 4
	}
	if (cie->has_icmp6) {
		tv.tv_sec = cie->env->timeout / 1000;
		tv.tv_usec = cie->env->timeout % 1000;
a78 1
	}
d245 1
a245 2
	tv.tv_sec = cie->env->timeout / 1000;
	tv.tv_usec = cie->env->timeout % 1000;
d324 2
a325 2
	tv.tv_sec = cie->env->timeout / 1000;
	tv.tv_usec = cie->env->timeout % 1000;
@


1.2
log
@knf, add copyright and license for in_cksum() from ping.c
@
text
@d1 1
a1 1
/*	$OpenBSD: check_icmp.c,v 1.1 2006/12/16 11:45:07 reyk Exp $	*/
d35 1
d39 7
a45 3
int check_icmp6(struct host *, int, int);
int check_icmp4(struct host *, int, int);
int in_cksum(u_short *, int);
d47 2
a48 1
int check_icmp(struct host *host, int s, int s6, int timeout)
d50 34
a83 4
	if (host->ss.ss_family == AF_INET)
		return (check_icmp4(host, s, timeout));
	else
		return (check_icmp6(host, s6, timeout));
d86 43
a128 1
int check_icmp6(struct host *host, int s, int timeout)
a131 1
	int			 ident;
a132 1
	int			 cc;
a134 3
	fd_set			 fdset;
	socklen_t		 len;
	struct timeval		 tv;
d136 1
a137 3
	ident = getpid() & 0xFFFF;
	len = sizeof(struct sockaddr_in6);

d143 1
a143 1
	icp->icmp6_id = ident;
d145 1
a145 2
	memset((packet + sizeof(*icp)), 'X', datalen);
	cc = datalen + 8;
d147 6
a152 34
	i = sendto(s, packet, cc, 0, to, len);

	if (i < 0 || i != cc) {
		log_warn("check_icmp6: cannot send ping");
		return (HOST_UNKNOWN);
	}

	tv.tv_sec = timeout / 1000;
	tv.tv_usec = timeout % 1000;
	FD_ZERO(&fdset);
	FD_SET(s, &fdset);
	switch (select(s + 1, &fdset, NULL, NULL, &tv)) {
	case -1:
		if (errno == EINTR) {
			log_warnx("check_icmp6: interrupted");
			return (HOST_UNKNOWN);
		} else
			fatal("check_icmp6: select");
	case 0:
		log_debug("check_icmp6: timeout");
		return (HOST_DOWN);
	default:
		bzero(&packet, sizeof(packet));
		i = recvfrom(s, packet, cc, 0, to, &len);
		if (i < 0 || i != cc) {
			log_warn("check_icmp6: did not receive valid ping");
			return (HOST_DOWN);
		}
		icp = (struct icmp6_hdr *)(packet);
		if (icp->icmp6_id != ident) {
			log_warnx("check_icmp6: did not receive valid ident");
			return (HOST_DOWN);
		}
		break;
a153 1
	return (HOST_UP);
d156 2
a157 1
int check_icmp4(struct host *host, int s, int timeout)
d159 5
a163 10
	struct sockaddr		*to;
	struct icmp		*icp;
	int			 ident;
	ssize_t			 i;
	int			 cc;
	int			 datalen = (64 - 8);
	u_char			 packet[datalen];
	fd_set			 fdset;
	socklen_t		 len;
	struct timeval		 tv;
d165 1
a166 3
	ident = getpid() & 0xFFFF;
	len = sizeof(struct sockaddr_in);

d169 1
a169 1
	icp->icmp_type = htons(ICMP_ECHO);
d172 1
a172 1
	icp->icmp_id = htons(ident);
d175 45
a219 31
	memset(icp->icmp_data, 'X', datalen);
	cc = datalen + 8;
	icp->icmp_cksum = in_cksum((u_short *)icp, cc);

	i = sendto(s, packet, cc, 0, to, len);

	if (i < 0 || i != cc) {
		log_warn("check_icmp4: cannot send ping");
		return (HOST_UNKNOWN);
	}

	tv.tv_sec = timeout / 1000;
	tv.tv_usec = timeout % 1000;
	FD_ZERO(&fdset);
	FD_SET(s, &fdset);
	switch (select(s + 1, &fdset, NULL, NULL, &tv)) {
	case -1:
		if (errno == EINTR) {
			log_warnx("check_icmp4: ping interrupted");
			return (HOST_UNKNOWN);
		} else
			fatal("check_icmp4: select");
	case 0:
		log_debug("check_icmp4: timeout");
		return (HOST_DOWN);
	default:
		bzero(&packet, sizeof(packet));
		i = recvfrom(s, packet, cc, 0, to, &len);
		if (i < 0 || i != cc) {
			log_warn("check_icmp4: did not receive valid ping");
			return (HOST_DOWN);
d221 70
a290 4
		icp = (struct icmp *)(packet + sizeof(struct ip));
		if (ntohs(icp->icmp_id) != ident) {
			log_warnx("check_icmp4: did not receive valid ident");
			return (HOST_DOWN);
d292 33
a324 1
		break;
d326 9
a334 1
	return (HOST_UP);
@


1.1
log
@Import hostated, the host status daemon.  This daemon will monitor
remote hosts and dynamically alter pf(4) tables and redirection rules
for active server load balancing.  The daemon has been written by
Pierre-Yves Ritschard (pyr at spootnik.org) and was formerly known as
"slbd".

The daemon is fully functional but it still needs some work and
cleanup so we don't link it to the build yet.  Some TODOs are a
partial rewrite of the check_* routines (use libevent whenever we
can), improvement of the manpages, and general knf and cleanup.

ok deraadt@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d52 10
a61 10
        struct sockaddr 	*to;
        struct icmp6_hdr	*icp;
        int            		 ident; 
        ssize_t         	 i;
        int             	 cc;
        int             	 datalen = (64 - 8);
        u_char          	 packet[datalen];
        fd_set          	 fdset;
        socklen_t       	 len;
        struct timeval  	 tv;
d84 7
a90 7
        tv.tv_sec = timeout / 1000;
        tv.tv_usec = timeout % 1000;
        FD_ZERO(&fdset);
        FD_SET(s, &fdset);
        switch (select(s + 1, &fdset, NULL, NULL, &tv)) {
        case -1:
                if (errno == EINTR) {
d95 18
a112 18
        case 0:
                log_debug("check_icmp6: timeout");
                return (HOST_DOWN);
        default:
                bzero(&packet, sizeof(packet));
                i = recvfrom(s, packet, cc, 0, to, &len);
                if (i < 0 || i != cc) {
                        log_warn("check_icmp6: did not receive valid ping");
                        return (HOST_DOWN);
                }
                icp = (struct icmp6_hdr *)(packet);
                if (icp->icmp6_id != ident) {
                        log_warnx("check_icmp6: did not receive valid ident");
                        return (HOST_DOWN);
                }
                break;
        }
        return (HOST_UP);
d182 33
a214 1
/* from ping.c */
d218 27
a244 26
        int nleft = len;
        u_short *w = addr;
        int sum = 0;
        u_short answer = 0;

        /*
         * Our algorithm is simple, using a 32 bit accumulator (sum), we add
         * sequential 16 bit words to it, and at the end, fold back all the
         * carry bits from the top 16 bits into the lower 16 bits.
         */
        while (nleft > 1)  {
                sum += *w++;
                nleft -= 2;
        }

        /* mop up an odd byte, if necessary */
        if (nleft == 1) {
                *(u_char *)(&answer) = *(u_char *)w ;
                sum += answer;
        }

        /* add back carry outs from top 16 bits to low 16 bits */
        sum = (sum >> 16) + (sum & 0xffff);     /* add hi 16 to low 16 */
        sum += (sum >> 16);                     /* add carry */
        answer = ~sum;                          /* truncate to 16 bits */
        return(answer);
@

