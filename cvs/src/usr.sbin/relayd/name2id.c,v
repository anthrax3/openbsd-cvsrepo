head	1.4;
access;
symbols
	OPENBSD_6_2:1.4.0.14
	OPENBSD_6_2_BASE:1.4
	OPENBSD_6_1:1.4.0.12
	OPENBSD_6_1_BASE:1.4
	OPENBSD_6_0:1.4.0.8
	OPENBSD_6_0_BASE:1.4
	OPENBSD_5_9:1.4.0.4
	OPENBSD_5_9_BASE:1.4
	OPENBSD_5_8:1.4.0.6
	OPENBSD_5_8_BASE:1.4
	OPENBSD_5_7:1.4.0.2
	OPENBSD_5_7_BASE:1.4
	OPENBSD_5_6:1.3.0.4
	OPENBSD_5_6_BASE:1.3
	OPENBSD_5_5:1.2.0.28
	OPENBSD_5_5_BASE:1.2
	OPENBSD_5_4:1.2.0.24
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.2.0.22
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.2.0.20
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.18
	OPENBSD_5_0:1.2.0.16
	OPENBSD_5_0_BASE:1.2
	OPENBSD_4_9:1.2.0.14
	OPENBSD_4_9_BASE:1.2
	OPENBSD_4_8:1.2.0.12
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.2.0.8
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.2.0.10
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.6
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.2.0.4
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3:1.2.0.2
	OPENBSD_4_3_BASE:1.2;
locks; strict;
comment	@ * @;


1.4
date	2015.01.22.17.42.09;	author reyk;	state Exp;
branches;
next	1.3;
commitid	puppem00jmzmdm4f;

1.3
date	2014.07.09.16.42.05;	author reyk;	state Exp;
branches;
next	1.2;
commitid	YhQvyAop4vC3AmzJ;

1.2
date	2007.12.07.17.17.00;	author reyk;	state Exp;
branches;
next	1.1;

1.1
date	2007.11.26.09.38.25;	author reyk;	state Exp;
branches;
next	;


desc
@@


1.4
log
@Clean up the relayd headers with help of include-what-you-use and some
manual review.  Based on common practice, relayd.h now includes the
necessary headers for itself.

OK benno@@
@
text
@/*	$OpenBSD: name2id.c,v 1.3 2014/07/09 16:42:05 reyk Exp $	*/

/*
 * Copyright (c) 2004, 2005 Henning Brauer <henning@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER IN
 * AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
 * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/queue.h>

#include <stdlib.h>
#include <string.h>
#include <errno.h>

#include "relayd.h"

#define	IDVAL_MAX	50000

struct n2id_label {
	TAILQ_ENTRY(n2id_label)	 entry;
	char			*name;
	u_int16_t		 id;
	int			 ref;
};

TAILQ_HEAD(n2id_labels, n2id_label);

u_int16_t	 _name2id(struct n2id_labels *, const char *);
const char	*_id2name(struct n2id_labels *, u_int16_t);
void		 _unref(struct n2id_labels *, u_int16_t);
void		 _ref(struct n2id_labels *, u_int16_t);

struct n2id_labels	relay_labels = TAILQ_HEAD_INITIALIZER(relay_labels);
struct n2id_labels	relay_tags = TAILQ_HEAD_INITIALIZER(relay_tags);

u_int16_t
tag_name2id(const char *name)
{
	return (_name2id(&relay_tags, name));
}

const char *
tag_id2name(u_int16_t id)
{
	return (_id2name(&relay_tags, id));
}

void
tag_unref(u_int16_t id)
{
	_unref(&relay_tags, id);
}

void
tag_ref(u_int16_t id)
{
	_ref(&relay_tags, id);
}

u_int16_t
label_name2id(const char *name)
{
	return (_name2id(&relay_labels, name));
}

const char *
label_id2name(u_int16_t id)
{
	return (_id2name(&relay_labels, id));
}

void
label_unref(u_int16_t id)
{
	_unref(&relay_labels, id);
}

void
label_ref(u_int16_t id)
{
	_ref(&relay_labels, id);
}

u_int16_t
_name2id(struct n2id_labels *head, const char *name)
{
	struct n2id_label	*label, *p = NULL;
	u_int16_t		 new_id = 1;

	if (!name[0]) {
		errno = EINVAL;
		return (0);
	}

	TAILQ_FOREACH(label, head, entry)
		if (strcmp(name, label->name) == 0) {
			label->ref++;
			return (label->id);
		}

	/*
	 * to avoid fragmentation, we do a linear search from the beginning
	 * and take the first free slot we find. if there is none or the list
	 * is empty, append a new entry at the end.
	 */

	if (!TAILQ_EMPTY(head))
		for (p = TAILQ_FIRST(head); p != NULL &&
		    p->id == new_id; p = TAILQ_NEXT(p, entry))
			new_id = p->id + 1;

	if (new_id > IDVAL_MAX) {
		errno = ERANGE;
		return (0);
	}

	if ((label = calloc(1, sizeof(struct n2id_label))) == NULL)
		return (0);
	if ((label->name = strdup(name)) == NULL) {
		free(label);
		return (0);
	}
	label->id = new_id;
	label->ref++;

	if (p != NULL)	/* insert new entry before p */
		TAILQ_INSERT_BEFORE(p, label, entry);
	else		/* either list empty or no free slot in between */
		TAILQ_INSERT_TAIL(head, label, entry);

	return (label->id);
}

const char *
_id2name(struct n2id_labels *head, u_int16_t id)
{
	struct n2id_label	*label;

	if (id == 0)
		return ("");

	TAILQ_FOREACH(label, head, entry)
		if (label->id == id)
			return (label->name);

	return ("");
}

void
_unref(struct n2id_labels *head, u_int16_t id)
{
	struct n2id_label	*p, *next;

	if (id == 0)
		return;

	for (p = TAILQ_FIRST(head); p != NULL; p = next) {
		next = TAILQ_NEXT(p, entry);
		if (id == p->id) {
			if (--p->ref == 0) {
				TAILQ_REMOVE(head, p, entry);
				free(p->name);
				free(p);
			}
			break;
		}
	}
}

void
_ref(struct n2id_labels *head, u_int16_t id)
{
	struct n2id_label	*label;

	if (id == 0)
		return;

	TAILQ_FOREACH(label, head, entry)
		if (label->id == id) {
			++label->ref;
			break;
		}
}
@


1.3
log
@Replace the protocol directives for HTTP with a new generic filtering
language.  The grammar is inspired by pf and allows to write versatile
last-matching filter rules in protocol sections starting with the
"pass", "block" or "match" keywords.  This work was started almost two
years ago and replaces large parts of relayd(8)'s HTTP and filtering
code.  The initial version reimplements and extends HTTP filtering,
but will be improved to support generic TCP and other protocols later.

With some testing, feedback, and help from benno@@ and andre@@.

OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: name2id.c,v 1.2 2007/12/07 17:17:00 reyk Exp $	*/
a19 1
#include <sys/socket.h>
a21 3
#include <net/if.h>

#include <errno.h>
d24 1
a24 3
#include <event.h>

#include <openssl/ssl.h>
@


1.2
log
@hoststated gets renamed to relayd.  easier to type, and actually says
what the daemon does - it is a relayer that pays attention to the status
of pools of hosts; not a status checkers that happens to do some relaying
@
text
@d1 1
a1 1
/*	$OpenBSD: name2id.c,v 1.1 2007/11/26 09:38:25 reyk Exp $	*/
d19 1
a19 1
#include <sys/param.h>
d25 1
a26 1
#include <stdio.h>
a27 1
#include <errno.h>
d50 26
a75 2
/* for protocolnode labels */
struct n2id_labels	pn_labels = TAILQ_HEAD_INITIALIZER(pn_labels);
d78 1
a78 1
pn_name2id(const char *name)
d80 1
a80 1
	return (_name2id(&pn_labels, name));
d84 1
a84 1
pn_id2name(u_int16_t id)
d86 1
a86 1
	return (_id2name(&pn_labels, id));
d90 1
a90 1
pn_unref(u_int16_t id)
d92 1
a92 1
	_unref(&pn_labels, id);
d96 1
a96 1
pn_ref(u_int16_t id)
d98 1
a98 1
	_ref(&pn_labels, id);
@


1.1
log
@allow to add labels to protocol actions, they will be printed in http
error pages and can be used to refer to additional information.

ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d33 1
a33 1
#include "hoststated.h"
@

