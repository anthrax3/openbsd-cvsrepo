head	1.29;
access;
symbols
	OPENBSD_6_1:1.28.0.4
	OPENBSD_6_1_BASE:1.28
	OPENBSD_6_0:1.26.0.4
	OPENBSD_6_0_BASE:1.26
	OPENBSD_5_9:1.26.0.2
	OPENBSD_5_9_BASE:1.26
	OPENBSD_5_8:1.23.0.6
	OPENBSD_5_8_BASE:1.23
	OPENBSD_5_7:1.23.0.2
	OPENBSD_5_7_BASE:1.23
	OPENBSD_5_6:1.17.0.4
	OPENBSD_5_6_BASE:1.17
	OPENBSD_5_5:1.13.0.8
	OPENBSD_5_5_BASE:1.13
	OPENBSD_5_4:1.13.0.4
	OPENBSD_5_4_BASE:1.13
	OPENBSD_5_3:1.13.0.2
	OPENBSD_5_3_BASE:1.13
	OPENBSD_5_2:1.12.0.4
	OPENBSD_5_2_BASE:1.12
	OPENBSD_5_1_BASE:1.12
	OPENBSD_5_1:1.12.0.2
	OPENBSD_5_0:1.11.0.2
	OPENBSD_5_0_BASE:1.11
	OPENBSD_4_9:1.8.0.8
	OPENBSD_4_9_BASE:1.8
	OPENBSD_4_8:1.8.0.6
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_7:1.8.0.2
	OPENBSD_4_7_BASE:1.8
	OPENBSD_4_6:1.8.0.4
	OPENBSD_4_6_BASE:1.8
	OPENBSD_4_5:1.2.0.4
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.2.0.2
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3:1.1.0.2
	OPENBSD_4_3_BASE:1.1;
locks; strict;
comment	@ * @;


1.29
date	2017.05.28.10.39.15;	author benno;	state Exp;
branches;
next	1.28;
commitid	IW4LnWyG3CPq6c3r;

1.28
date	2016.09.02.16.14.09;	author reyk;	state Exp;
branches;
next	1.27;
commitid	PZw2w24xmNM2vbc7;

1.27
date	2016.09.02.14.45.51;	author reyk;	state Exp;
branches;
next	1.26;
commitid	vcV98N2DyJGMwDyQ;

1.26
date	2015.12.05.10.59.03;	author blambert;	state Exp;
branches;
next	1.25;
commitid	rKjGft2V6I7xzGcW;

1.25
date	2015.12.02.13.41.27;	author reyk;	state Exp;
branches;
next	1.24;
commitid	vBNcEM4jmO1KceIa;

1.24
date	2015.11.28.09.52.07;	author reyk;	state Exp;
branches;
next	1.23;
commitid	Xo3TbDi9hUaP9ip0;

1.23
date	2015.01.22.17.42.09;	author reyk;	state Exp;
branches;
next	1.22;
commitid	puppem00jmzmdm4f;

1.22
date	2015.01.22.15.21.05;	author reyk;	state Exp;
branches;
next	1.21;
commitid	bmjxbUL9dIidDpZO;

1.21
date	2014.12.21.00.54.49;	author guenther;	state Exp;
branches;
next	1.20;
commitid	XnjIOhurXdX5o1V9;

1.20
date	2014.11.25.09.17.00;	author blambert;	state Exp;
branches;
next	1.19;
commitid	8OkF1XCl5SihBSbU;

1.19
date	2014.11.24.05.48.25;	author jsg;	state Exp;
branches;
next	1.18;
commitid	uYqZk94U5iqUQA7Q;

1.18
date	2014.11.19.10.24.40;	author blambert;	state Exp;
branches;
next	1.17;
commitid	EGrSQMGI27r3h8Vf;

1.17
date	2014.06.25.11.05.15;	author reyk;	state Exp;
branches;
next	1.16;
commitid	QSckC3KrSjGNpjr5;

1.16
date	2014.04.23.15.45.16;	author reyk;	state Exp;
branches;
next	1.15;

1.15
date	2014.04.20.16.23.33;	author reyk;	state Exp;
branches;
next	1.14;

1.14
date	2014.04.14.12.58.04;	author blambert;	state Exp;
branches;
next	1.13;

1.13
date	2013.01.17.20.34.18;	author bluhm;	state Exp;
branches;
next	1.12;

1.12
date	2012.02.01.19.24.46;	author camield;	state Exp;
branches;
next	1.11;

1.11
date	2011.05.19.08.56.49;	author reyk;	state Exp;
branches;
next	1.10;

1.10
date	2011.05.09.12.08.47;	author reyk;	state Exp;
branches;
next	1.9;

1.9
date	2011.05.05.12.01.44;	author reyk;	state Exp;
branches;
next	1.8;

1.8
date	2009.06.09.16.26.03;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2009.06.07.05.56.25;	author eric;	state Exp;
branches;
next	1.6;

1.6
date	2009.06.06.05.30.45;	author eric;	state Exp;
branches;
next	1.5;

1.5
date	2009.06.05.23.39.51;	author pyr;	state Exp;
branches;
next	1.4;

1.4
date	2009.06.05.00.04.01;	author pyr;	state Exp;
branches;
next	1.3;

1.3
date	2009.06.03.20.20.09;	author eric;	state Exp;
branches;
next	1.2;

1.2
date	2008.05.05.15.07.12;	author henning;	state Exp;
branches;
next	1.1;

1.1
date	2008.02.11.10.42.50;	author reyk;	state Exp;
branches;
next	;


desc
@@


1.29
log
@use __func__ in log messages. fix some whitespace while here.
From Hiltjo Posthuma hiltjo -AT codemadness -DOT- org, thanks!
ok florian, claudio
@
text
@/*	$OpenBSD: snmp.c,v 1.28 2016/09/02 16:14:09 reyk Exp $	*/

/*
 * Copyright (c) 2008 - 2014 Reyk Floeter <reyk@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/socket.h>
#include <sys/queue.h>
#include <sys/time.h>
#include <sys/un.h>

#include <netinet/in.h>

#include <limits.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <errno.h>
#include <string.h>
#include <unistd.h>
#include <event.h>
#include <imsg.h>

#include "relayd.h"
#include "snmp.h"

#define	HOST_MAX_SUBIDX		10
#define	TABLE_MAX_SUBIDX	3
#define	ROUTER_MAX_SUBIDX	6
#define	NETROUTE_MAX_SUBIDX	5
#define	RELAY_MAX_SUBIDX	10
#define	SESSION_MAX_SUBIDX	12
#define	RDR_MAX_SUBIDX		10

#define	OIDIDX_relaydInfo	9

#define RELAYD_MIB	"1.3.6.1.4.1.30155.3"
#define SNMP_ELEMENT(x...)	do {				\
	if (snmp_element(RELAYD_MIB x) == -1)			\
		goto done;					\
} while (0)

static struct snmp_oid	hosttrapoid = {
	{ 1, 3, 6, 1, 4, 1, 30155, 3, 1, 0 },
	10
};

static struct snmp_oid	relaydinfooid = {
	{ 1, 3, 6, 1, 4, 1, 30155, 3, 2 },
	9
};

static struct agentx_handle	*snmp_agentx = NULL;
enum privsep_procid		 snmp_procid;

void	 snmp_sock(int, short, void *);
int	 snmp_element(const char *, enum snmp_type, void *, int64_t,
	    struct agentx_pdu *);
int	 snmp_string2oid(const char *, struct snmp_oid *);
char	*snmp_oid2string(struct snmp_oid *, char *, size_t);
void	 snmp_event_add(struct relayd *, int);
void	 snmp_agentx_process(struct agentx_handle *, struct agentx_pdu *,
	    void *);
int	 snmp_register(struct relayd *);
int	 snmp_unregister(struct relayd *);

void	*sstodata(struct sockaddr_storage *);
size_t	 sstolen(struct sockaddr_storage *);

struct host *
	 snmp_host_byidx(struct relayd *, u_int *, u_int *, u_int, u_int);
struct table *
	 snmp_table_byidx(struct relayd *, u_int *, u_int *, u_int, u_int);
struct router *
	 snmp_router_byidx(struct relayd *, u_int *, u_int *, u_int, u_int);
struct relay *
	 snmp_relay_byidx(struct relayd *, u_int *, u_int *, u_int, u_int);
struct rsession *
	 snmp_session_byidx(struct relayd *, u_int *, u_int *, u_int, u_int);
struct rdr *
	 snmp_rdr_byidx(struct relayd *, u_int *, u_int *, u_int, u_int);
struct netroute *
	 snmp_netroute_byidx(struct relayd *, u_int *, u_int *, u_int, u_int);

int	 snmp_redirect(struct relayd *, struct snmp_oid *, struct agentx_pdu *,
	    int, uint32_t, uint32_t, u_int);
int	 snmp_relay(struct relayd *, struct snmp_oid *, struct agentx_pdu *,
	    int, uint32_t, uint32_t, u_int);
int	 snmp_router(struct relayd *, struct snmp_oid *, struct agentx_pdu *,
	    int, uint32_t, uint32_t, u_int);
int	 snmp_netroute(struct relayd *, struct snmp_oid *, struct agentx_pdu *,
	    int, uint32_t, uint32_t, u_int);
int	 snmp_host(struct relayd *, struct snmp_oid *, struct agentx_pdu *,
	    int, uint32_t, uint32_t, u_int);
int	 snmp_session(struct relayd *, struct snmp_oid *, struct agentx_pdu *,
	    int, uint32_t, uint32_t, u_int);
int	 snmp_table(struct relayd *, struct snmp_oid *, struct agentx_pdu *,
	    int, uint32_t, uint32_t, u_int);

void
snmp_init(struct relayd *env, enum privsep_procid id)
{
	if (event_initialized(&env->sc_snmpev))
		event_del(&env->sc_snmpev);
	if (event_initialized(&env->sc_snmpto))
		event_del(&env->sc_snmpto);
	if (env->sc_snmp != -1) {
		if (snmp_agentx) {
			snmp_unregister(env);
			snmp_agentx_close(snmp_agentx, AGENTX_CLOSE_OTHER);
			snmp_agentx = NULL;
		}
		close(env->sc_snmp);
		env->sc_snmp = -1;
	}

	if ((env->sc_conf.flags & F_SNMP) == 0)
		return;

	snmp_procid = id;

	proc_compose(env->sc_ps, snmp_procid, IMSG_SNMPSOCK, NULL, 0);
}

void
snmp_setsock(struct relayd *env, enum privsep_procid id)
{
	struct sockaddr_un	 sun;
	int			 s = -1;

	if ((s = socket(AF_UNIX, SOCK_STREAM | SOCK_NONBLOCK, 0)) == -1)
		goto done;

	bzero(&sun, sizeof(sun));
	sun.sun_family = AF_UNIX;
	if (strlcpy(sun.sun_path, env->sc_conf.snmp_path,
	    sizeof(sun.sun_path)) >= sizeof(sun.sun_path))
		fatalx("invalid socket path");

	if (connect(s, (struct sockaddr *)&sun, sizeof(sun)) == -1) {
		close(s);
		s = -1;
	}
 done:
	proc_compose_imsg(env->sc_ps, id, -1, IMSG_SNMPSOCK, -1, s, NULL, 0);
}

int
snmp_getsock(struct relayd *env, struct imsg *imsg)
{
	struct timeval		 tv = SNMP_RECONNECT_TIMEOUT;
	struct agentx_pdu	*pdu;

	if (imsg->fd == -1)
		goto retry;

	env->sc_snmp = imsg->fd;

	log_debug("%s: got new snmp socket %d", __func__, imsg->fd);

	if ((snmp_agentx = snmp_agentx_alloc(env->sc_snmp)) == NULL)
		fatal("%s: agentx alloc", __func__);
	if ((pdu = snmp_agentx_open_pdu(snmp_agentx, "relayd", NULL)) == NULL)
		fatal("%s: agentx pdu", __func__);
	(void)snmp_agentx_send(snmp_agentx, pdu);

	snmp_event_add(env, EV_WRITE);

	return (0);
 retry:
	evtimer_set(&env->sc_snmpto, snmp_sock, env);
	evtimer_add(&env->sc_snmpto, &tv);
	return (0);
}

void
snmp_event_add(struct relayd *env, int wflag)
{
	event_del(&env->sc_snmpev);
	event_set(&env->sc_snmpev, env->sc_snmp, EV_READ|wflag, snmp_sock, env);
	event_add(&env->sc_snmpev, NULL);
}

void
snmp_sock(int fd, short event, void *arg)
{
	struct relayd		*env = arg;
	struct agentx_pdu	*pdu;
	int			 evflags = 0;

	if (event & EV_TIMEOUT) {
		goto reopen;
	}
	if (event & EV_WRITE) {
		if (snmp_agentx_send(snmp_agentx, NULL) == -1) {
			if (errno != EAGAIN)
				goto close;

			/* short write */
			evflags |= EV_WRITE;
		}
	}
	if (event & EV_READ) {
		if ((pdu = snmp_agentx_recv(snmp_agentx)) == NULL) {
			if (snmp_agentx->error) {
				log_warnx("agentx protocol error '%i'",
				    snmp_agentx->error);
				goto close;
			}
			if (errno != EAGAIN) {
				log_warn("agentx socket error");
				goto close;
			}

			/* short read */
			goto out;
		}

		snmp_agentx_process(snmp_agentx, pdu, env);
	}
out:
	snmp_event_add(env, evflags);
	return;

 close:
	log_debug("%s: snmp socket closed %d", __func__, env->sc_snmp);
	snmp_agentx_free(snmp_agentx);
	env->sc_snmp = -1;
	snmp_agentx = NULL;
 reopen:
	proc_compose(env->sc_ps, snmp_procid, IMSG_SNMPSOCK, NULL, 0);
	return;
}

void
snmp_agentx_process(struct agentx_handle *h, struct agentx_pdu *pdu, void *arg)
{
	struct agentx_getbulk_repeaters		 repeaters;
	struct agentx_search_range		 sr;
	struct snmp_oid				 oid;
	struct agentx_close_request_data	 close_hdr;
	struct relayd				*env = arg;
	struct agentx_pdu			*resp;
	u_int					 erridx = 0;
	int					 getnext = 0, repetitions;
	int					 nonrepeaters, maxrepetitions;

	nonrepeaters = maxrepetitions = -1;

	switch (pdu->hdr->type) {
	case AGENTX_CLOSE:
		snmp_agentx_read_raw(pdu, &close_hdr, sizeof(close_hdr));
		log_info("snmp: agentx master has closed connection (%i)",
		    close_hdr.reason);

		snmp_agentx_free(snmp_agentx);
		env->sc_snmp = -1;
		snmp_agentx = NULL;
		proc_compose(env->sc_ps, snmp_procid, IMSG_SNMPSOCK, NULL, 0);
		break;

	case AGENTX_GET_BULK:
		if (snmp_agentx_read_raw(pdu,
		    &repeaters, sizeof(repeaters)) == -1)
			break;

		nonrepeaters = repeaters.nonrepeaters;
		maxrepetitions = repeaters.maxrepetitions;

		/* FALLTHROUGH */
	case AGENTX_GET:
	case AGENTX_GET_NEXT:
		if ((resp = snmp_agentx_response_pdu(0,
		    AGENTX_ERR_NONE, 0)) == NULL) {
			log_warn("%s unable to allocate response pdu",
			    __func__);
			break;
		}
		repetitions = 0;
 repeat:
		while (pdu->datalen > sizeof(struct agentx_hdr)) {
			uint32_t infoendidx, infoentryendidx,
			    infoentryidxendidx;

			erridx++;

			/* AgentX GETs are the OID followed by the null OID */
			if (snmp_agentx_read_searchrange(pdu, &sr) == -1) {
				snmp_agentx_pdu_free(resp);
				resp = NULL;
				break;
			}

			if (sr.end.o_n >= OIDIDX_relaydInfo + 1)
				infoendidx = sr.end.o_id[OIDIDX_relaydInfo];
			else
				infoendidx = UINT32_MAX;
			if (sr.end.o_n >= OIDIDX_relaydInfo + 1 + 1)
				infoentryendidx =
				    sr.end.o_id[OIDIDX_relaydInfo + 1];
			else
				infoentryendidx = UINT32_MAX;
			if (sr.end.o_n >= OIDIDX_relaydInfo + 2 + 1)
				infoentryidxendidx =
				    sr.end.o_id[OIDIDX_relaydInfo + 2];
			else
				infoentryidxendidx = UINT32_MAX;

			bcopy(&sr.start, &oid, sizeof(oid));

			/*
			 * If the requested OID is not part of the registered
			 * MIB, return "no such object", per RFC
			 */
			if (snmp_oid_cmp(&relaydinfooid, &oid) == -1) {
				if (snmp_agentx_varbind(resp, &sr.start,
				    AGENTX_NO_SUCH_OBJECT, NULL, 0) == -1) {
					log_warn("%s: unable to generate"
					    " response", __func__);
					snmp_agentx_pdu_free(resp);
					resp = NULL;
				}
				goto reply;
			}

			if (oid.o_n != OIDIDX_relaydInfo + 2 + 1) {
				/* GET requests require the exact OID */
				if (pdu->hdr->type == AGENTX_GET)
					goto nosuchinstance;

				if (oid.o_n == OIDIDX_relaydInfo + 1) {
					oid.o_id[OIDIDX_relaydInfo + 1] = 0;
					oid.o_n = OIDIDX_relaydInfo + 1 + 1;
				}
				if (oid.o_n == OIDIDX_relaydInfo + 1 + 1) {
					oid.o_id[OIDIDX_relaydInfo + 2] = 0;
					oid.o_n = OIDIDX_relaydInfo + 2 + 1;
				}
				if (oid.o_n > OIDIDX_relaydInfo + 2 + 1)
					oid.o_n = OIDIDX_relaydInfo + 2 + 1;
			}

			/*
			 * If not including the starting OID, increment
			 * here to go to the 'next' OID to allow the lookups
			 * to work correctly, as they do 'include' matching
			 */
			if (pdu->hdr->type == AGENTX_GET_NEXT)
				getnext = 1;

			switch (oid.o_id[OIDIDX_relaydInfo]) {
			case 1:
				log_warnx("%s: redirects", __func__);
				if (infoendidx < 1)
					break;
				if (snmp_redirect(env, &oid, resp, getnext,
				    infoentryendidx, infoentryidxendidx,
				    sr.include) == 0)
					break;
				if (!getnext)
					goto nosuchinstance;

				oid.o_id[OIDIDX_relaydInfo] = 2;
				oid.o_id[OIDIDX_relaydInfo + 1] = 0;
				oid.o_id[OIDIDX_relaydInfo + 2] = 0;
				/* FALLTHROUGH */
			case 2:
				log_warnx("%s: relays", __func__);
				if (infoendidx < 2)
					break;
				if (snmp_relay(env, &oid, resp, getnext,
				    infoentryendidx, infoentryidxendidx,
				    sr.include) == 0)
					break;
				if (!getnext)
					goto nosuchinstance;

				oid.o_id[OIDIDX_relaydInfo] = 3;
				oid.o_id[OIDIDX_relaydInfo + 1] = 0;
				oid.o_id[OIDIDX_relaydInfo + 2] = 0;
				/* FALLTHROUGH */
			case 3:
				log_warnx("%s: routers", __func__);
				if (infoendidx < 3)
					break;
				if (snmp_router(env, &oid, resp, getnext,
				    infoentryendidx, infoentryidxendidx,
				    sr.include) == 0)
					break;
				if (!getnext)
					goto nosuchinstance;

				oid.o_id[OIDIDX_relaydInfo] = 4;
				oid.o_id[OIDIDX_relaydInfo + 1] = 0;
				oid.o_id[OIDIDX_relaydInfo + 2] = 0;
				/* FALLTHROUGH */
			case 4:
				log_warnx("%s: relaydNetRoutes", __func__);
				if (infoendidx < 4)
					break;
				if (snmp_netroute(env, &oid, resp, getnext,
				    infoentryendidx, infoentryidxendidx,
				    sr.include) == 0)
					break;
				if (!getnext)
					goto nosuchinstance;

				oid.o_id[OIDIDX_relaydInfo] = 5;
				oid.o_id[OIDIDX_relaydInfo + 1] = 0;
				oid.o_id[OIDIDX_relaydInfo + 2] = 0;
				/* FALLTHROUGH */
			case 5:
				log_warnx("%s: hosts", __func__);
				if (infoendidx < 5)
					break;
				if (snmp_host(env, &oid, resp, getnext,
				    infoentryendidx, infoentryidxendidx,
				    sr.include) == 0)
					break;
				if (!getnext)
					goto nosuchinstance;

				oid.o_id[OIDIDX_relaydInfo] = 6;
				oid.o_id[OIDIDX_relaydInfo + 1] = 0;
				oid.o_id[OIDIDX_relaydInfo + 2] = 0;
				/* FALLTHROUGH */
			case 6:
				log_warnx("%s: sessions", __func__);
				if (infoendidx < 6)
					break;
				if (snmp_session(env, &oid, resp, getnext,
				    infoentryendidx, infoentryidxendidx,
				    sr.include) == 0)
					break;
				if (!getnext)
					goto nosuchinstance;

				oid.o_id[OIDIDX_relaydInfo] = 7;
				oid.o_id[OIDIDX_relaydInfo + 1] = 0;
				oid.o_id[OIDIDX_relaydInfo + 2] = 0;
				/* FALLTHROUGH */
			case 7:
				log_warnx("%s: tables", __func__);
				if (infoendidx < 7)
					break;
				if (snmp_table(env, &oid, resp, getnext,
				    infoentryendidx, infoentryidxendidx,
				    sr.include) == 0)
					break;
				if (!getnext)
					goto nosuchinstance;

				if (snmp_agentx_varbind(resp, &oid,
				    AGENTX_END_OF_MIB_VIEW, NULL, 0) == -1) {
					log_warn("%s: unable to generate"
					    " response", __func__);
					snmp_agentx_pdu_free(resp);
					resp = NULL;
				}
				goto reply;
			default:
 nosuchinstance:
				log_warnx("unknown index %i",
				    oid.o_id[OIDIDX_relaydInfo]);
				if (snmp_agentx_varbind(resp, &sr.start,
				    AGENTX_NO_SUCH_INSTANCE, NULL, 0) == -1) {
					log_warn("%s: unable to generate"
					    " response", __func__);
					snmp_agentx_pdu_free(resp);
					resp = NULL;
				}
				goto reply;
			}
		}

		if (pdu->hdr->type == AGENTX_GET_BULK) {
			if (nonrepeaters >= 0)
				nonrepeaters--;
			else if (repetitions < maxrepetitions) {
				repetitions++;
				goto repeat;
			}
		}
 reply:
		if (resp) {
			snmp_agentx_send(snmp_agentx, resp);
			snmp_event_add(env, EV_WRITE);
		}

		break;

	case AGENTX_TEST_SET:
	case AGENTX_COMMIT_SET:
	case AGENTX_UNDO_SET:
	case AGENTX_CLEANUP_SET:
		log_warnx("unimplemented request type '%s'",
		    snmp_agentx_type2name(pdu->hdr->type));
		break;

	case AGENTX_RESPONSE:
		switch (pdu->request->hdr->type) {
		case AGENTX_NOTIFY:
			if (snmp_agentx_response(h, pdu) == -1)
				break;
		break;

		case AGENTX_OPEN:
			if (snmp_agentx_open_response(h, pdu) == -1)
				break;
			/* Open AgentX socket; register MIB if not trap-only */
			if (!(env->sc_conf.flags & F_SNMP_TRAPONLY))
				if (snmp_register(env) == -1) {
					log_warn("failed to register MIB");
					break;
				}
			break;

		case AGENTX_CLOSE:
			if (snmp_agentx_response(h, pdu) == -1)
				break;
			break;

		case AGENTX_REGISTER:
			if (snmp_agentx_response(h, pdu) == -1)
				break;
			break;

		case AGENTX_UNREGISTER:
			if (snmp_agentx_response(h, pdu) == -1)
				break;
			break;

		default:
			if (snmp_agentx_response(h, pdu) == -1)
				break;
			break;
		}
		break;

	/* these are nonsensical for subagents to receive */
	case AGENTX_OPEN:
	case AGENTX_REGISTER:
	case AGENTX_UNREGISTER:
	case AGENTX_NOTIFY:
	case AGENTX_PING:
	case AGENTX_INDEX_ALLOCATE:
	case AGENTX_INDEX_DEALLOCATE:
	case AGENTX_ADD_AGENT_CAPS:
	case AGENTX_REMOVE_AGENT_CAPS:
		log_warnx("ignoring request type '%s'",
		    snmp_agentx_type2name(pdu->hdr->type));
		break;

	default:
		log_warnx("unknown request type '%i'", pdu->hdr->type);
		if (snmp_agentx_response(h, pdu) == -1)
			break;
		break;
	}

	snmp_agentx_pdu_free(pdu);
	return;
}

int
snmp_register(struct relayd *env)
{
	struct agentx_pdu	*pdu;

	if ((pdu = snmp_agentx_register_pdu(&relaydinfooid, 3, 0, 0)) == NULL)
		return (-1);

	if (snmp_agentx_send(snmp_agentx, pdu) == -1)
		return (-1);

	snmp_event_add(env, EV_WRITE);
	return (0);
}

int
snmp_unregister(struct relayd *env)
{
	struct agentx_pdu	*pdu;

	if ((pdu = snmp_agentx_unregister_pdu(&relaydinfooid, 0, 0)) == NULL)
		return (-1);

	if (snmp_agentx_send(snmp_agentx, pdu) == -1)
		return (-1);

	snmp_event_add(env, EV_WRITE);
	return (0);
}

int
snmp_element(const char *oidstr, enum snmp_type type, void *buf, int64_t val,
    struct agentx_pdu *pdu)
{
	u_int32_t		 d;
	u_int64_t		 l;
	struct snmp_oid		 oid;

	DPRINTF("%s: oid %s type %d buf %p val %lld", __func__,
	    oidstr, type, buf, val);

	if (snmp_string2oid(oidstr, &oid) == -1)
		return (-1);

	switch (type) {
	case SNMP_GAUGE32:
	case SNMP_NSAPADDR:
	case SNMP_INTEGER32:
	case SNMP_UINTEGER32:
		d = (u_int32_t)val;
		if (snmp_agentx_varbind(pdu, &oid, AGENTX_INTEGER,
		    &d, sizeof(d)) == -1)
			return (-1);
		break;

	case SNMP_COUNTER32:
		d = (u_int32_t)val;
		if (snmp_agentx_varbind(pdu, &oid, AGENTX_COUNTER32,
		    &d, sizeof(d)) == -1)
			return (-1);
		break;

	case SNMP_TIMETICKS:
		d = (u_int32_t)val;
		if (snmp_agentx_varbind(pdu, &oid, AGENTX_TIME_TICKS,
		    &d, sizeof(d)) == -1)
			return (-1);
		break;

	case SNMP_COUNTER64:
		l = (u_int64_t)val;
		if (snmp_agentx_varbind(pdu, &oid, AGENTX_COUNTER64,
		    &l, sizeof(l)) == -1)
			return (-1);
		break;

	case SNMP_IPADDR:
	case SNMP_OPAQUE:
		d = (u_int32_t)val;
		if (snmp_agentx_varbind(pdu, &oid, AGENTX_OPAQUE,
		    buf, strlen(buf)) == -1)
			return (-1);
		break;

	case SNMP_OBJECT: {
		struct snmp_oid		oid1;

		if (snmp_string2oid(buf, &oid1) == -1)
			return (-1);
		if (snmp_agentx_varbind(pdu, &oid, AGENTX_OBJECT_IDENTIFIER,
		    &oid1, sizeof(oid1)) == -1)
			return (-1);
	}

	case SNMP_BITSTRING:
	case SNMP_OCTETSTRING:
		if (snmp_agentx_varbind(pdu, &oid, AGENTX_OCTET_STRING,
		    buf, strlen(buf)) == -1)
			return (-1);
		break;

	case SNMP_NULL:
		/* no data beyond the OID itself */
		if (snmp_agentx_varbind(pdu, &oid, AGENTX_NULL,
		    NULL, 0) == -1)
			return (-1);
	}

	return (0);
}

/*
 * SNMP traps for relayd
 */

void
snmp_hosttrap(struct relayd *env, struct table *table, struct host *host)
{
	struct agentx_pdu *pdu;

	if (snmp_agentx == NULL || env->sc_snmp == -1)
		return;

	/*
	 * OPENBSD-RELAYD-MIB host status trap
	 * XXX The trap format needs some tweaks and other OIDs
	 */

	if ((pdu = snmp_agentx_notify_pdu(&hosttrapoid)) == NULL)
		return;

	SNMP_ELEMENT(".1.0", SNMP_NULL, NULL, 0, pdu);
	SNMP_ELEMENT(".1.1.0", SNMP_OCTETSTRING, host->conf.name, 0, pdu);
	SNMP_ELEMENT(".1.2.0", SNMP_INTEGER32, NULL, host->up, pdu);
	SNMP_ELEMENT(".1.3.0", SNMP_INTEGER32, NULL, host->last_up, pdu);
	SNMP_ELEMENT(".1.4.0", SNMP_INTEGER32, NULL, host->up_cnt, pdu);
	SNMP_ELEMENT(".1.5.0", SNMP_INTEGER32, NULL, host->check_cnt, pdu);
	SNMP_ELEMENT(".1.6.0", SNMP_OCTETSTRING, table->conf.name, 0, pdu);
	SNMP_ELEMENT(".1.7.0", SNMP_INTEGER32, NULL, table->up, pdu);
	if (!host->conf.retry)
		goto done;
	SNMP_ELEMENT(".1.8.0", SNMP_INTEGER32, NULL, host->conf.retry, pdu);
	SNMP_ELEMENT(".1.9.0", SNMP_INTEGER32, NULL, host->retry_cnt, pdu);

 done:
	snmp_agentx_send(snmp_agentx, pdu);
	snmp_event_add(env, EV_WRITE);
}

int
snmp_string2oid(const char *oidstr, struct snmp_oid *o)
{
	char			*sp, *p, str[BUFSIZ];
	const char		*errstr;

	if (strlcpy(str, oidstr, sizeof(str)) >= sizeof(str))
		return (-1);
	bzero(o, sizeof(*o));

	for (p = sp = str; p != NULL; sp = p) {
		if ((p = strpbrk(p, ".-")) != NULL)
			*p++ = '\0';
		o->o_id[o->o_n++] = strtonum(sp, 0, UINT_MAX, &errstr);
		if (errstr || o->o_n > SNMP_MAX_OID_LEN)
			return (-1);
	}

	return (0);
}

void *
sstodata(struct sockaddr_storage *ss)
{
	if (ss->ss_family == AF_INET)
		return (&((struct sockaddr_in *)ss)->sin_addr);
	if (ss->ss_family == AF_INET6)
		return (&((struct sockaddr_in6 *)ss)->sin6_addr);
	return (NULL);
}

size_t
sstolen(struct sockaddr_storage *ss)
{
	if (ss->ss_family == AF_INET)
		return (((struct sockaddr_in *)ss)->sin_len);
	if (ss->ss_family == AF_INET6)
		return (((struct sockaddr_in6 *)ss)->sin6_len);
	return (0);
}

struct rdr *
snmp_rdr_byidx(struct relayd *env, u_int *instanceidx, u_int *objectidx,
    u_int getnext, u_int include)
{
	struct rdr	*rdr;

	if (*objectidx > RDR_MAX_SUBIDX)
		return (NULL);
	if (*objectidx == 0) {
		if (!getnext)
			return (NULL);
		*objectidx = 1;
	}

 restart:
	TAILQ_FOREACH(rdr, env->sc_rdrs, entry) {
		if (rdr->conf.id >= *instanceidx) {
			if (getnext) {
				/*  Lexographical ordering */

				/* 1) try the next instance index */
				if (rdr->conf.id == *instanceidx && !include)
					rdr = TAILQ_NEXT(rdr, entry);
				if (rdr) {
					*instanceidx = rdr->conf.id;
					return (rdr);
				}

				/* 2) try the next object index */
				if (*objectidx < RDR_MAX_SUBIDX) {
					*objectidx += 1;
					*instanceidx = 1;
					include = 1;
					goto restart;
				}

				/* 3) no further OIDs under this prefix */
				return (NULL);
			}

			if (rdr->conf.id == *instanceidx)
				return (rdr);

			return (NULL);
		}
	}

	return (NULL);
}

struct relay *
snmp_relay_byidx(struct relayd *env, u_int *instanceidx, u_int *objectidx,
    u_int getnext, u_int include)
{
	struct relay	*rly;

	if (*objectidx > RELAY_MAX_SUBIDX)
		return (NULL);
	if (*objectidx == 0) {
		if (!getnext)
			return (NULL);
		*objectidx = 1;
	}

 restart:
	TAILQ_FOREACH(rly, env->sc_relays, rl_entry) {
		if (rly->rl_conf.id >= *instanceidx) {
			if (getnext) {
				/*  Lexographical ordering */

				/* 1) try the next instance index */
				if (rly->rl_conf.id == *instanceidx && !include)
					rly = TAILQ_NEXT(rly, rl_entry);
				if (rly) {
					*instanceidx = rly->rl_conf.id;
					return (rly);
				}

				/* 2) try the next object index */
				if (*objectidx < RELAY_MAX_SUBIDX) {
					*objectidx += 1;
					*instanceidx = 1;
					include = 1;
					goto restart;
				}

				/* 3) no further OIDs under this prefix */
				return (rly);
			}

			if (rly->rl_conf.id == *instanceidx)
				return (rly);

			return (NULL);
		}
	}

	return (NULL);
}

struct router *
snmp_router_byidx(struct relayd *env, u_int *instanceidx, u_int *objectidx,
    u_int getnext, u_int include)
{
	struct router	*router;

	if (*objectidx > ROUTER_MAX_SUBIDX)
		return (NULL);
	if (*objectidx == 0) {
		if (!getnext)
			return (NULL);
		*objectidx = 1;
	}

 restart:
	TAILQ_FOREACH(router, env->sc_rts, rt_entry) {
		if (router->rt_conf.id >= *instanceidx) {
			if (getnext) {
				/*  Lexographical ordering */

				/* 1) try the next instance index */
				if ((router->rt_conf.id == *instanceidx) &&
				    !include)
					router = TAILQ_NEXT(router, rt_entry);
				if (router) {
					*instanceidx = router->rt_conf.id;
					return (router);
				}

				/* 2) try the next object index */
				if (*objectidx < ROUTER_MAX_SUBIDX) {
					*objectidx += 1;
					*instanceidx = 1;
					include = 1;
					goto restart;
				}

				/* 3) no further OIDs under this prefix */
				return (NULL);
			}

			if (router->rt_conf.id == *instanceidx)
				return (router);

			return (NULL);
		}
	}

	return (NULL);
}

struct netroute *
snmp_netroute_byidx(struct relayd *env, u_int *instanceidx, u_int *objectidx,
    u_int getnext, u_int include)
{
	struct netroute		*nr;

	if (*objectidx > NETROUTE_MAX_SUBIDX)
		return (NULL);
	if (*objectidx == 0) {
		if (!getnext)
			return (NULL);
		*objectidx = 1;
	}

 restart:
	TAILQ_FOREACH(nr, env->sc_routes, nr_route) {
		if (nr->nr_conf.id >= *instanceidx) {
			if (getnext) {
				/*  Lexographical ordering */

				/* 1) try the next instance index */
				if (nr->nr_conf.id == *instanceidx && !include)
					nr = TAILQ_NEXT(nr, nr_route);
				if (nr) {
					*instanceidx = nr->nr_conf.id;
					return (nr);
				}

				/* 2) try the next object index */
				if (*objectidx < NETROUTE_MAX_SUBIDX) {
					*objectidx += 1;
					*instanceidx = 1;
					include = 1;
					goto restart;
				}

				/* 3) no further OIDs under this prefix */
				return (NULL);
			}

			if (nr->nr_conf.id == *instanceidx)
				return (nr);

			return (NULL);
		}
	}

	return (NULL);
}

struct host *
snmp_host_byidx(struct relayd *env, u_int *instanceidx, u_int *objectidx,
    u_int getnext, u_int include)
{
	struct host	*host;

	if (*objectidx > HOST_MAX_SUBIDX)
		return (NULL);
	if (*objectidx == 0) {
		if (!getnext)
			return (NULL);
		*objectidx = 1;
	}

 restart:
	TAILQ_FOREACH(host, &env->sc_hosts, globalentry) {
		if (host->conf.id >= *instanceidx) {
			if (getnext) {
				/*  Lexographical ordering */

				/* 1) try the next instance index */
				if (host->conf.id == *instanceidx && !include)
					host = TAILQ_NEXT(host, globalentry);
				if (host) {
					*instanceidx = host->conf.id;
					return (host);
				}

				/* 2) try the next object index */
				if (*objectidx < HOST_MAX_SUBIDX) {
					*objectidx += 1;
					*instanceidx = 1;
					include = 1;
					goto restart;
				}

				/* 3) no further OIDs under this prefix */
				return (NULL);
			}

			if (host->conf.id == *instanceidx)
				return (host);

			return (NULL);
		}
	}

	return (NULL);
}

struct rsession *
snmp_session_byidx(struct relayd *env, u_int *instanceidx, u_int *objectidx,
    u_int getnext, u_int include)
{
	struct rsession		*session;

	if (*objectidx > SESSION_MAX_SUBIDX)
		return (NULL);
	if (*objectidx == 0) {
		if (!getnext)
			return (NULL);
		*objectidx = 1;
	}

 restart:
	TAILQ_FOREACH(session, &env->sc_sessions, se_entry) {
		if (session->se_id >= *instanceidx) {
			if (getnext) {
				/*  Lexographical ordering */

				/* 1) try the next instance index */
				if (session->se_id == *instanceidx && !include)
					session = TAILQ_NEXT(session, se_entry);
				if (session) {
					*instanceidx = session->se_id;
					return (session);
				}

				/* 2) try the next object index */
				if (*objectidx < SESSION_MAX_SUBIDX) {
					*objectidx += 1;
					*instanceidx = 1;
					include = 1;
					goto restart;
				}

				/* 3) no further OIDs under this prefix */
				return (NULL);
			}

			if (session->se_id == *instanceidx)
				return (session);

			return (NULL);
		}
	}

	return (NULL);
}

struct table *
snmp_table_byidx(struct relayd *env, u_int *instanceidx, u_int *objectidx,
    u_int getnext, u_int include)
{
	struct table		*table;

	if (*objectidx > TABLE_MAX_SUBIDX)
		return (NULL);
	if (*objectidx == 0) {
		if (!getnext)
			return (NULL);
		*objectidx = 1;
	}

 restart:
	TAILQ_FOREACH(table, env->sc_tables, entry) {
		if (table->conf.id >= *instanceidx) {
			if (getnext) {
				/*  Lexographical ordering */

				/* 1) try the next instance index */
				if (table->conf.id == *instanceidx && !include)
					table = TAILQ_NEXT(table, entry);
				if (table) {
					*instanceidx = table->conf.id;
					return (table);
				}

				/* 2) try the next object index */
				if (*objectidx < TABLE_MAX_SUBIDX) {
					*objectidx += 1;
					*instanceidx = 1;
					include = 1;
					goto restart;
				}

				/* 3) no further OIDs under this prefix */
				return (NULL);
			}

			if (table->conf.id == *instanceidx)
				return (table);

			return (NULL);
		}
	}

	return (NULL);
}

int
snmp_redirect(struct relayd *env, struct snmp_oid *oid,
    struct agentx_pdu *resp, int getnext, uint32_t einstanceidx,
    uint32_t eobjectidx, u_int include)
{
	struct rdr	*rdr;
	u_int		 instanceidx, objectidx;
	u_int32_t	 status;

	instanceidx = oid->o_id[OIDIDX_relaydInfo + 2];
	objectidx = oid->o_id[OIDIDX_relaydInfo + 1];
	rdr = snmp_rdr_byidx(env, &instanceidx, &objectidx, getnext, include);
	if (rdr == NULL)
		return (-1);

	if (instanceidx >= einstanceidx || objectidx >= eobjectidx)
		return (0);

	oid->o_id[OIDIDX_relaydInfo + 1] = objectidx;
	oid->o_id[OIDIDX_relaydInfo + 2] = instanceidx;

	switch (objectidx) {
	case 1:		/* index */
		if (snmp_agentx_varbind(resp, oid,
		    AGENTX_INTEGER, &rdr->conf.id,
		    sizeof(rdr->conf.id)) == -1)
			return (-1);
		break;
	case 2:		/* status */
		if (rdr->conf.flags & F_DISABLE)
			status = 1;
		else if (rdr->conf.flags & F_DOWN)
			status = 2;
		else if (rdr->conf.flags & F_BACKUP)
			status = 3;
		else
			status = 0;
		if (snmp_agentx_varbind(resp, oid,
		    AGENTX_INTEGER, &status,
		    sizeof(status)) == -1)
			return (-1);
		break;
	case 3:		/* name */
		if (snmp_agentx_varbind(resp, oid,
		    AGENTX_OCTET_STRING, rdr->conf.name,
		    strlen(rdr->conf.name)) == -1)
			return (-1);
		break;
	case 4:		/* count */
		if (snmp_agentx_varbind(resp, oid,
		    AGENTX_COUNTER64, &rdr->stats.cnt,
		    sizeof(rdr->stats.cnt)) == -1)
			return (-1);
		break;
	case 5:		/* average */
		if (snmp_agentx_varbind(resp, oid,
		    AGENTX_INTEGER, &rdr->stats.avg,
		    sizeof(rdr->stats.avg)) == -1)
			return (-1);
		break;
	case 6:		/* last */
		if (snmp_agentx_varbind(resp, oid,
		    AGENTX_INTEGER, &rdr->stats.last,
		    sizeof(rdr->stats.last)) == -1)
			return (-1);
		break;
	case 7:		/* average hour */
		if (snmp_agentx_varbind(resp, oid,
		    AGENTX_INTEGER, &rdr->stats.avg_hour,
		    sizeof(rdr->stats.avg_hour)) == -1)
			return (-1);
		break;
	case 8:		/* last hour */
		if (snmp_agentx_varbind(resp, oid,
		    AGENTX_INTEGER, &rdr->stats.last_hour,
		    sizeof(rdr->stats.last_hour)) == -1)
			return (-1);
		break;
	case 9:		/* average day */
		if (snmp_agentx_varbind(resp, oid,
		    AGENTX_INTEGER, &rdr->stats.avg_day,
		    sizeof(rdr->stats.avg_day)) == -1)
			return (-1);
		break;
	case 10:	/* last day */
		if (snmp_agentx_varbind(resp, oid,
		    AGENTX_INTEGER, &rdr->stats.last_day,
		    sizeof(rdr->stats.last_day)) == -1)
			return (-1);
		break;
	default:
		fatalx("unhandled host element id");
	}

	return (0);
}

int
snmp_relay(struct relayd *env, struct snmp_oid *oid, struct agentx_pdu *resp,
    int getnext, uint32_t einstanceidx, uint32_t eobjectidx, u_int include)
{
	struct relay	*rly;
	u_int		 instanceidx, objectidx;
	u_int32_t	 status, value = 0;
	u_int64_t	 value64 = 0;
	int		 i, nrelay = env->sc_conf.prefork_relay;

	instanceidx = oid->o_id[OIDIDX_relaydInfo + 2];
	objectidx = oid->o_id[OIDIDX_relaydInfo + 1];
	rly = snmp_relay_byidx(env, &instanceidx, &objectidx, getnext,
	    include);
	if (rly == NULL)
		return (-1);

	if (instanceidx >= einstanceidx || objectidx >= eobjectidx)
		return (0);

	oid->o_id[OIDIDX_relaydInfo + 1] = objectidx;
	oid->o_id[OIDIDX_relaydInfo + 2] = instanceidx;

	switch (objectidx) {
	case 1:		/* index */
		if (snmp_agentx_varbind(resp, oid,
		    AGENTX_INTEGER, &rly->rl_conf.id,
		    sizeof(rly->rl_conf.id)) == -1)
			return (-1);
		break;
	case 2:		/* status */
		if (rly->rl_up == HOST_UP)
			status = 0;		/* active */
		else
			status = 1;		/* disabled */
		if (snmp_agentx_varbind(resp, oid,
		    AGENTX_INTEGER, &status,
		    sizeof(status)) == -1)
			return (-1);
		break;
	case 3:		/* name */
		if (snmp_agentx_varbind(resp, oid,
		    AGENTX_OCTET_STRING, &rly->rl_conf.name,
		    strlen(rly->rl_conf.name)) == -1)
			return (-1);
		break;
	case 4:		/* count */
		for (i = 0; i < nrelay; i++)
			value64 += rly->rl_stats[i].cnt;
		if (snmp_agentx_varbind(resp, oid,
		    AGENTX_COUNTER64, &value64,
		    sizeof(value64)) == -1)
			return (-1);
		break;
	case 5:		/* average */
		for (i = 0; i < nrelay; i++)
			value += rly->rl_stats[i].avg;
		if (snmp_agentx_varbind(resp, oid,
		    AGENTX_INTEGER, &value,
		    sizeof(value)) == -1)
			return (-1);
		break;
	case 6:		/* last */
		for (i = 0; i < nrelay; i++)
			value += rly->rl_stats[i].last;
		if (snmp_agentx_varbind(resp, oid,
		    AGENTX_INTEGER, &value,
		    sizeof(value)) == -1)
			return (-1);
		break;
	case 7:		/* average hour */
		for (i = 0; i < nrelay; i++)
			value += rly->rl_stats[i].avg_hour;
		if (snmp_agentx_varbind(resp, oid,
		    AGENTX_INTEGER, &value,
		    sizeof(value)) == -1)
			return (-1);
		break;
	case 8:		/* last hour */
		for (i = 0; i < nrelay; i++)
			value += rly->rl_stats[i].last_hour;
		if (snmp_agentx_varbind(resp, oid,
		    AGENTX_INTEGER, &value,
		    sizeof(value)) == -1)
			return (-1);
		break;
	case 9:		/* average day */
		for (i = 0; i < nrelay; i++)
			value += rly->rl_stats[i].avg_day;
		if (snmp_agentx_varbind(resp, oid,
		    AGENTX_INTEGER, &value,
		    sizeof(value)) == -1)
			return (-1);
		break;
	case 10:	/* last day */
		for (i = 0; i < nrelay; i++)
			value += rly->rl_stats[i].last_day;
		if (snmp_agentx_varbind(resp, oid,
		    AGENTX_INTEGER, &value,
		    sizeof(value)) == -1)
			return (-1);
		break;
	default:
		fatalx("unhandled host element id");
	}

	return (0);
}

int
snmp_router(struct relayd *env, struct snmp_oid *oid, struct agentx_pdu *resp,
    int getnext, uint32_t einstanceidx, uint32_t eobjectidx, u_int include)
{
	struct router	*router;
	u_int		 instanceidx, objectidx;
	u_int32_t	 status;

	instanceidx = oid->o_id[OIDIDX_relaydInfo + 2];
	objectidx = oid->o_id[OIDIDX_relaydInfo + 1];
	router = snmp_router_byidx(env, &instanceidx, &objectidx, getnext,
	    include);
	if (router == NULL)
		return (-1);

	if (instanceidx >= einstanceidx || objectidx >= eobjectidx)
		return (0);

	oid->o_id[OIDIDX_relaydInfo + 1] = objectidx;
	oid->o_id[OIDIDX_relaydInfo + 2] = instanceidx;

	switch (objectidx) {
	case 1:		/* index */
		if (snmp_agentx_varbind(resp, oid,
		    AGENTX_INTEGER, &router->rt_conf.id,
		    sizeof(router->rt_conf.id)) == -1)
			return (-1);
		break;
	case 2:		/* table index */
		if (snmp_agentx_varbind(resp, oid,
		    AGENTX_INTEGER, &router->rt_conf.gwtable,
		    sizeof(router->rt_conf.gwtable)) == -1)
			return (-1);
		break;
	case 3:		/* status */
		if (router->rt_conf.flags & F_DISABLE)
			status = 1;		/* disabled */
		else
			status = 0;		/* active */
		if (snmp_agentx_varbind(resp, oid,
		    AGENTX_INTEGER, &status,
		    sizeof(status)) == -1)
			return (-1);
		break;
	case 4:		/* name */
		if (snmp_agentx_varbind(resp, oid,
		    AGENTX_OCTET_STRING, router->rt_conf.name,
		    strlen(router->rt_conf.name)) == -1)
			return (-1);
		break;
	case 5:		/* pf label */
		if (snmp_agentx_varbind(resp, oid,
		    AGENTX_OCTET_STRING, router->rt_conf.label,
		    strlen(router->rt_conf.label)) == -1)
			return (-1);
		break;
	case 6:		/* rtable */
		if (snmp_agentx_varbind(resp, oid,
		    AGENTX_INTEGER, &router->rt_conf.rtable,
		    sizeof(router->rt_conf.rtable)) == -1)
			return (-1);
		break;
	default:
		fatalx("unhandled host element id");
	}

	return (0);
}

int
snmp_netroute(struct relayd *env, struct snmp_oid *oid,
    struct agentx_pdu *resp, int getnext, uint32_t einstanceidx,
    uint32_t eobjectidx, u_int include)
{
	struct netroute			*nr;
	u_int32_t			 addrtype;
	u_int				 instanceidx, objectidx;

	instanceidx = oid->o_id[OIDIDX_relaydInfo + 2];
	objectidx = oid->o_id[OIDIDX_relaydInfo + 1];
	nr = snmp_netroute_byidx(env, &instanceidx, &objectidx, getnext,
	    include);
	if (nr == NULL)
		return (-1);

	if (instanceidx >= einstanceidx || objectidx >= eobjectidx)
		return (0);

	oid->o_id[OIDIDX_relaydInfo + 1] = objectidx;
	oid->o_id[OIDIDX_relaydInfo + 2] = instanceidx;

	switch (objectidx) {
	case 1:		/* index */
		if (snmp_agentx_varbind(resp, oid,
		    AGENTX_INTEGER, &nr->nr_conf.id,
		    sizeof(nr->nr_conf.id)) == -1)
			return (-1);
		break;
	case 2:		/* address */
		if (snmp_agentx_varbind(resp, oid,
		    AGENTX_OCTET_STRING, sstodata(&nr->nr_conf.ss),
		    sstolen(&nr->nr_conf.ss)) == -1)
			return (-1);
		break;
	case 3:		/* address type */
		if (nr->nr_conf.ss.ss_family == AF_INET)
			addrtype = 1;
		else if (nr->nr_conf.ss.ss_family == AF_INET6)
			addrtype = 2;
		if (snmp_agentx_varbind(resp, oid,
		    AGENTX_INTEGER, &addrtype,
		    sizeof(addrtype)) == -1)
			return (-1);
		break;
	case 4:		/* prefix length */
		if (snmp_agentx_varbind(resp, oid,
		    AGENTX_INTEGER, &nr->nr_conf.prefixlen,
		    sizeof(nr->nr_conf.prefixlen)) == -1)
			return (-1);
		break;
	case 5:		/* router index */
		if (snmp_agentx_varbind(resp, oid,
		    AGENTX_INTEGER, &nr->nr_conf.routerid,
		    sizeof(nr->nr_conf.routerid)) == -1)
			return (-1);
		break;
	default:
		fatalx("unhandled host element id");
	}

	return (0);
}

int
snmp_host(struct relayd *env, struct snmp_oid *oid, struct agentx_pdu *resp,
    int getnext, uint32_t einstanceidx, uint32_t eobjectidx, u_int include)
{
	struct host			*host;
	u_int32_t			 addrtype, count, error, status;
	u_int				 instanceidx, objectidx;

	instanceidx = oid->o_id[OIDIDX_relaydInfo + 2];
	objectidx = oid->o_id[OIDIDX_relaydInfo + 1];
	host = snmp_host_byidx(env, &instanceidx, &objectidx, getnext,
	    include);
	if (host == NULL)
		return (-1);

	if (instanceidx >= einstanceidx || objectidx >= eobjectidx)
		return (0);

	oid->o_id[OIDIDX_relaydInfo + 1] = objectidx;
	oid->o_id[OIDIDX_relaydInfo + 2] = instanceidx;

	switch (objectidx) {
	case 1:		/* index */
		if (snmp_agentx_varbind(resp, oid,
		    AGENTX_INTEGER, &host->conf.id,
		    sizeof(host->conf.id)) == -1)
			return (-1);
		break;
	case 2:		/* parent index */
		if (snmp_agentx_varbind(resp, oid,
		    AGENTX_INTEGER, &host->conf.parentid,
		    sizeof(host->conf.parentid)) == -1)
			return (-1);
		break;
	case 3:		/* table index */
		if (snmp_agentx_varbind(resp, oid,
		    AGENTX_INTEGER, &host->conf.tableid,
		    sizeof(host->conf.tableid)) == -1)
			return (-1);
		break;
	case 4:		/* name */
		if (snmp_agentx_varbind(resp, oid,
		    AGENTX_OCTET_STRING, host->conf.name,
		    strlen(host->conf.name)) == -1)
			return (-1);
		break;
	case 5:		/* address */
		if (snmp_agentx_varbind(resp, oid,
		    AGENTX_OCTET_STRING, sstodata(&host->conf.ss),
		    sstolen(&host->conf.ss)) == -1)
			return (-1);
		break;
	case 6:		/* address type */
		if (host->conf.ss.ss_family == AF_INET)
			addrtype = 1;
		else if (host->conf.ss.ss_family == AF_INET6)
			addrtype = 2;
		if (snmp_agentx_varbind(resp, oid,
		    AGENTX_INTEGER, &addrtype,
		    sizeof(addrtype)) == -1)
			return (-1);
		break;
	case 7:		/* status */
		if (host->flags & F_DISABLE)
			status = 1;
		else if (host->up == HOST_UP)
			status = 0;
		else if (host->up == HOST_DOWN)
			status = 2;
		else
			status = 3;
		if (snmp_agentx_varbind(resp, oid,
		    AGENTX_INTEGER, &status,
		    sizeof(status)) == -1)
			return (-1);
		break;
	case 8:		/* check count */
		count = host->check_cnt;
		if (snmp_agentx_varbind(resp, oid,
		    AGENTX_INTEGER, &count,
		    sizeof(count)) == -1)
			return (-1);
		break;
	case 9:		/* up count */
		count = host->up_cnt;
		if (snmp_agentx_varbind(resp, oid,
		    AGENTX_INTEGER, &count,
		    sizeof(count)) == -1)
			return (-1);
		break;
	case 10:	/* errno */
		error = host->he;
		if (snmp_agentx_varbind(resp, oid,
		    AGENTX_INTEGER, &error,
		    sizeof(errno)) == -1)
			return (-1);
		break;
	default:
		fatalx("unhandled host element id");
	}

	return (0);
}

int
snmp_session(struct relayd *env, struct snmp_oid *oid, struct agentx_pdu *resp,
    int getnext, uint32_t einstanceidx, uint32_t eobjectidx, u_int include)
{
	struct timeval		 tv, now;
	time_t			 ticks;
	struct rsession		*session;
	u_int			 instanceidx, objectidx;
	u_int32_t		 status, pid, port, addrtype;

	instanceidx = oid->o_id[OIDIDX_relaydInfo + 2];
	objectidx = oid->o_id[OIDIDX_relaydInfo + 1];
	session = snmp_session_byidx(env, &instanceidx, &objectidx, getnext,
	    include);
	if (session == NULL)
		return (-1);

	if (instanceidx >= einstanceidx || objectidx >= eobjectidx)
		return (0);

	oid->o_id[OIDIDX_relaydInfo + 1] = objectidx;
	oid->o_id[OIDIDX_relaydInfo + 2] = instanceidx;

	switch (objectidx) {
	case 1:		/* index */
		if (snmp_agentx_varbind(resp, oid,
		    AGENTX_INTEGER, &session->se_id,
		    sizeof(session->se_id)) == -1)
			return (-1);
		break;
	case 2:		/* relay index */
		if (snmp_agentx_varbind(resp, oid,
		    AGENTX_INTEGER, &session->se_relayid,
		    sizeof(session->se_relayid)) == -1)
			return (-1);
		break;
	case 3:		/* in address */
		if (snmp_agentx_varbind(resp, oid,
		    AGENTX_OCTET_STRING, sstodata(&session->se_in.ss),
		    sstolen(&session->se_in.ss)) == -1)
			return (-1);
		break;
	case 4:		/* in address type */
		if (session->se_in.ss.ss_family == AF_INET)
			addrtype = 1;
		else if (session->se_in.ss.ss_family == AF_INET6)
			addrtype = 2;
		if (snmp_agentx_varbind(resp, oid,
		    AGENTX_INTEGER, &addrtype,
		    sizeof(addrtype)) == -1)
			return (-1);
		break;
	case 5:		/* out address */
		if (snmp_agentx_varbind(resp, oid,
		    AGENTX_OCTET_STRING, sstodata(&session->se_out.ss),
		    sstolen(&session->se_out.ss)) == -1)
			return (-1);
		break;
	case 6:		/* out address type */
		if (session->se_out.ss.ss_family == AF_INET)
			addrtype = 1;
		else if (session->se_out.ss.ss_family == AF_INET6)
			addrtype = 2;
		if (snmp_agentx_varbind(resp, oid,
		    AGENTX_INTEGER, &addrtype,
		    sizeof(addrtype)) == -1)
			return (-1);
		break;
	case 7:		/* port out */
		port = session->se_out.port;
		if (snmp_agentx_varbind(resp, oid,
		    AGENTX_INTEGER, &port,
		    sizeof(port)) == -1)
			return (-1);
		break;
	case 8:		/* port in */
		port = session->se_in.port;
		if (snmp_agentx_varbind(resp, oid,
		    AGENTX_INTEGER, &port,
		    sizeof(port)) == -1)
			return (-1);
		break;
	case 9:		/* age */
		getmonotime(&now);
		timerclear(&tv);
		timersub(&now, &session->se_tv_start, &tv);
		ticks = tv.tv_sec * 100 + tv.tv_usec / 10000;
		if (snmp_agentx_varbind(resp, oid,
		    AGENTX_INTEGER, &ticks,
		    sizeof(ticks)) == -1)
			return (-1);
		break;
	case 10:	/* idle time */
		getmonotime(&now);
		timerclear(&tv);
		timersub(&now, &session->se_tv_last, &tv);
		ticks = tv.tv_sec * 100 + tv.tv_usec / 10000;
		if (snmp_agentx_varbind(resp, oid,
		    AGENTX_INTEGER, &ticks,
		    sizeof(ticks)) == -1)
			return (-1);
		break;
	case 11:	/* status */
		if (session->se_done)
			status = 1;
		else
			status = 0;
		if (snmp_agentx_varbind(resp, oid,
		    AGENTX_INTEGER, &status,
		    sizeof(status)) == -1)
			return (-1);
		break;
	case 12:	/* session pid */
		pid = (u_int32_t)session->se_pid;
		if (snmp_agentx_varbind(resp, oid,
		    AGENTX_INTEGER, &pid,
		    sizeof(pid)) == -1)
			return (-1);
		break;
	default:
		fatalx("unhandled table element id");
	}

	return (0);
}

int
snmp_table(struct relayd *env, struct snmp_oid *oid, struct agentx_pdu *resp,
    int getnext, uint32_t einstanceidx, uint32_t eobjectidx, u_int include)
{
	struct table		*table;
	u_int			 instanceidx, objectidx;
	u_int32_t		 status;

	instanceidx = oid->o_id[OIDIDX_relaydInfo + 2];
	objectidx = oid->o_id[OIDIDX_relaydInfo + 1];
	table = snmp_table_byidx(env, &instanceidx, &objectidx, getnext,
	    include);
	if (table == NULL)
		return (-1);

	if (instanceidx >= einstanceidx || objectidx >= eobjectidx)
		return (0);

	oid->o_id[OIDIDX_relaydInfo + 1] = objectidx;
	oid->o_id[OIDIDX_relaydInfo + 2] = instanceidx;

	switch (objectidx) {
	case 1:		/* index */
		if (snmp_agentx_varbind(resp, oid,
		    AGENTX_INTEGER, &table->conf.id,
		    sizeof(table->conf.id)) == -1)
			return (-1);
		break;
	case 2:		/* name */
		if (snmp_agentx_varbind(resp, oid,
		    AGENTX_OCTET_STRING, &table->conf.name,
		    strlen(table->conf.name)) == -1)
			return (-1);
		break;
	case 3:		/* status */
		if (TAILQ_EMPTY(&table->hosts))
			status = 1;		/* empty */
		else if (table->conf.flags & F_DISABLE)
			status = 2;		/* disabled */
		else
			status = 0;		/* active */
		if (snmp_agentx_varbind(resp, oid,
		    AGENTX_INTEGER, &status,
		    sizeof(status)) == -1)
			return (-1);
		break;
	default:
		fatalx("unhandled table element id");
	}

	return (0);
}
@


1.28
log
@Move snmp options into struct relayd_config and delay start of the
snmp subsystem until the configuration is done.

OK benno@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: snmp.c,v 1.27 2016/09/02 14:45:51 reyk Exp $	*/
d175 1
a175 1
		fatal("snmp_getsock: agentx alloc");
d177 1
a177 1
		fatal("snmp_getsock: agentx pdu");
@


1.27
log
@Split "struct relayd" into two structs: "struct relayd" and "struct
relayd_config".  This way we can send all the relevant global
configuration to the children, not just the flags and the opts.

With input from and
OK claudio@@ benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: snmp.c,v 1.26 2015/12/05 10:59:03 blambert Exp $	*/
d149 1
a149 1
	if (strlcpy(sun.sun_path, env->sc_snmp_path,
d524 1
a524 1
			if (!(env->sc_snmp_flags & FSNMP_TRAPONLY))
@


1.26
log
@don't attempt to process AgentX packets when a short read is encountered

while here, remove a pair of duplicate function definitions

ok benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: snmp.c,v 1.25 2015/12/02 13:41:27 reyk Exp $	*/
d130 1
a130 1
	if ((env->sc_flags & F_SNMP) == 0)
d1224 1
a1224 1
	int		 i;
d1263 1
a1263 1
		for (i = 0; i < env->sc_prefork_relay; i++)
d1271 1
a1271 1
		for (i = 0; i < env->sc_prefork_relay; i++)
d1279 1
a1279 1
		for (i = 0; i < env->sc_prefork_relay; i++)
d1287 1
a1287 1
		for (i = 0; i < env->sc_prefork_relay; i++)
d1295 1
a1295 1
		for (i = 0; i < env->sc_prefork_relay; i++)
d1303 1
a1303 1
		for (i = 0; i < env->sc_prefork_relay; i++)
d1311 1
a1311 1
		for (i = 0; i < env->sc_prefork_relay; i++)
@


1.25
log
@In most cases we don't need all arguments of proc_compose*_imsg(),
so add a shortcut proc_compose*() that skips all of them.  Only use the
full argument list if needed.  The functions with full argument lists can
eventually be replaced with a nicer transaction-based approach later.

OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: snmp.c,v 1.24 2015/11/28 09:52:07 reyk Exp $	*/
a78 2
void	 snmp_event_add(struct relayd *, int);
void	 snmp_agentx_process(struct agentx_handle *, struct agentx_pdu *, void *);
d229 1
d234 1
a234 1

@


1.24
log
@Use SOCK_NONBLOCK in relayd as well.

OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: snmp.c,v 1.23 2015/01/22 17:42:09 reyk Exp $	*/
d137 1
a137 2
	proc_compose_imsg(env->sc_ps, snmp_procid, -1,
	    IMSG_SNMPSOCK, -1, NULL, 0);
d160 1
a160 1
	proc_compose_imsg(env->sc_ps, id, -1, IMSG_SNMPSOCK, s, NULL, 0);
d245 1
a245 2
	proc_compose_imsg(env->sc_ps, snmp_procid, -1,
	    IMSG_SNMPSOCK, -1, NULL, 0);
d273 1
a273 2
		proc_compose_imsg(env->sc_ps, snmp_procid, -1,
		    IMSG_SNMPSOCK, -1, NULL, 0);
@


1.23
log
@Clean up the relayd headers with help of include-what-you-use and some
manual review.  Based on common practice, relayd.h now includes the
necessary headers for itself.

OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: snmp.c,v 1.22 2015/01/22 15:21:05 reyk Exp $	*/
d147 1
a147 1
	if ((s = socket(AF_UNIX, SOCK_STREAM, 0)) == -1)
a154 2

	socket_set_blockmode(s, BM_NONBLOCK);
@


1.22
log
@wrap long lines; spacing.

Repeat after me: "Lines are not longer than 80 characters long" and
"mg(1) is the only true editor, I'll use ESC-q to wrap the lines".
@
text
@d1 1
a1 1
/*	$OpenBSD: snmp.c,v 1.21 2014/12/21 00:54:49 guenther Exp $	*/
d21 2
a23 1
#include <sys/uio.h>
a25 1
#include <net/if.h>
d27 4
a31 2
#include <fcntl.h>
#include <stdlib.h>
a33 2
#include <stdio.h>
#include <err.h>
d35 1
a35 2

#include <openssl/ssl.h>
@


1.21
log
@Stop pulling in <arpa/inet.h> or <arpa/nameser.h> when unnecessary.
*Do* pull it in when in_{port,addr}_h is needed and <netinet/in.h> isn't.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: snmp.c,v 1.20 2014/11/25 09:17:00 blambert Exp $	*/
d293 4
a296 2
		if ((resp = snmp_agentx_response_pdu(0, AGENTX_ERR_NONE, 0)) == NULL) {
			log_warn("%s unable to allocate response pdu", __func__);
d302 2
a303 1
			uint32_t infoendidx, infoentryendidx, infoentryidxendidx;
d319 2
a320 1
				infoentryendidx = sr.end.o_id[OIDIDX_relaydInfo + 1];
d324 2
a325 1
				infoentryidxendidx = sr.end.o_id[OIDIDX_relaydInfo + 2];
d332 2
a333 2
			 * If the requested OID is not part of the registered MIB,
			 * return "no such object", per RFC
d338 2
a339 2
					log_warn("%s: unable to generate response",
					    __func__);
d347 1
a347 1
				/* GET requests require the exact OID to exist */
d377 2
a378 1
				    infoentryendidx, infoentryidxendidx, sr.include) == 0)
d392 2
a393 1
				    infoentryendidx, infoentryidxendidx, sr.include) == 0)
d407 2
a408 1
				    infoentryendidx, infoentryidxendidx, sr.include) == 0)
d422 2
a423 1
				    infoentryendidx, infoentryidxendidx, sr.include) == 0)
d437 2
a438 1
				    infoentryendidx, infoentryidxendidx, sr.include) == 0)
d452 2
a453 1
				    infoentryendidx, infoentryidxendidx, sr.include) == 0)
d467 2
a468 1
				    infoentryendidx, infoentryidxendidx, sr.include) == 0)
d475 2
a476 2
					log_warn("%s: unable to generate response",
					    __func__);
d483 2
a484 1
				log_warnx("unknown index %i", oid.o_id[OIDIDX_relaydInfo]);
d487 2
a488 2
					log_warn("%s: unable to generate response",
					    __func__);
d896 2
a897 1
				if (router->rt_conf.id == *instanceidx && !include)
d1408 1
a1408 1
	u_int		 		 instanceidx, objectidx;
d1576 1
a1576 1
	u_int	 		 instanceidx, objectidx;
d1700 1
a1700 1
	u_int	 		 instanceidx, objectidx;
@


1.20
log
@use correct divisor when converting microseconds to 100ths of a second

found by yasuoka@@
@
text
@d1 1
a1 1
/*	$OpenBSD: snmp.c,v 1.19 2014/11/24 05:48:25 jsg Exp $	*/
a25 1
#include <arpa/inet.h>
@


1.19
log
@remove a surplus break statement
@
text
@d1 1
a1 1
/*	$OpenBSD: snmp.c,v 1.18 2014/11/19 10:24:40 blambert Exp $	*/
d1642 1
a1642 1
		ticks = tv.tv_sec * 100 + tv.tv_usec / 10;
d1652 1
a1652 1
		ticks = tv.tv_sec * 100 + tv.tv_usec / 10;
@


1.18
log
@Support exporting relayd statistics via AgentX/snmpd

This should be equivalent to the statistics available
via the various relaydctl show commands

okay benno@@ reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: snmp.c,v 1.17 2014/06/25 11:05:15 reyk Exp $	*/
a534 1
		break;
@


1.17
log
@sync copyright to reality according to my last changes
@
text
@d1 1
a1 1
/*	$OpenBSD: snmp.c,v 1.16 2014/04/23 15:45:16 reyk Exp $	*/
d42 10
d63 5
d75 1
d79 37
d126 1
a186 1
	snmp_agentx_set_callback(snmp_agentx, snmp_agentx_process, env);
d207 3
a209 2
	struct relayd	*env = arg;
	int		 evflags = 0;
d224 1
a224 1
		if (snmp_agentx_recv(snmp_agentx) == NULL) {
d238 1
a238 1
		/* PDU handled in the registered callback */
d258 3
d263 4
d268 1
a268 11
	switch (pdu->request->hdr->type) {

	case AGENTX_NOTIFY:
		if (snmp_agentx_response(h, pdu) == -1)
			break;
		break;

	case AGENTX_OPEN:
		if (snmp_agentx_open_response(h, pdu) == -1)
			break;
		break;
d270 1
d283 280
d564 1
d574 29
d739 992
@


1.16
log
@Fix format string in DEBUG message (not compiled by default).

ok blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: snmp.c,v 1.15 2014/04/20 16:23:33 reyk Exp $	*/
d4 1
a4 1
 * Copyright (c) 2008 Reyk Floeter <reyk@@openbsd.org>
@


1.15
log
@Check another strlcpy overflow that is very unlikely to happen.
@
text
@d1 1
a1 1
/*	$OpenBSD: snmp.c,v 1.14 2014/04/14 12:58:04 blambert Exp $	*/
d251 1
a251 1
	    oid, type, buf, val);
@


1.14
log
@Adapt relayd to use AgentX protocol to send traps

ok reyk@@ benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: snmp.c,v 1.13 2013/01/17 20:34:18 bluhm Exp $	*/
d100 3
a102 1
	strlcpy(sun.sun_path, env->sc_snmp_path, sizeof(sun.sun_path));
@


1.13
log
@Remove unnecessary pointer casts.  No binary diff.
OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: snmp.c,v 1.12 2012/02/01 19:24:46 camield Exp $	*/
d48 7
a54 2
static struct imsgev	*iev_snmp = NULL;
enum privsep_procid	 snmp_procid;
d57 6
a62 1
int	 snmp_element(const char *, enum snmp_type, void *, int64_t);
d72 4
d80 1
a80 1
	if ((env->sc_flags & F_TRAP) == 0)
d84 3
a86 1
	snmp_sock(-1, -1, env);
d89 1
a89 1
int
a91 1
	struct imsgev		 tmpiev;
d100 3
a102 1
	strlcpy(sun.sun_path, SNMP_SOCKET, sizeof(sun.sun_path));
a106 1
		goto done;
a107 6

	/* enable restricted snmp socket mode */
	bzero(&tmpiev, sizeof(tmpiev));
	imsg_init(&tmpiev.ibuf, s);
	imsg_compose_event(&tmpiev, IMSG_SNMP_LOCK, 0, 0, -1, NULL, 0);

a109 1
	return (-1);
d115 2
a116 1
	struct timeval	 tv = SNMP_RECONNECT_TIMEOUT;
a123 4
	if (iev_snmp == NULL &&
	    (iev_snmp = calloc(1, sizeof(*iev_snmp))) == NULL)
		fatal("snmp_getsock: calloc");
	imsg_init(&iev_snmp->ibuf, env->sc_snmp);
d125 9
a133 3
	event_set(&env->sc_snmpev, env->sc_snmp,
	    EV_READ|EV_TIMEOUT, snmp_sock, env);
	event_add(&env->sc_snmpev, NULL);
d142 8
d153 1
a153 1
	struct timeval	 tv = SNMP_RECONNECT_TIMEOUT;
d155 28
a182 8
	switch (event) {
	case -1:
		bzero(&tv, sizeof(tv));
		goto retry;
	case EV_READ:
		log_debug("%s: snmp socket closed %d", __func__, env->sc_snmp);
		(void)close(env->sc_snmp);
		break;
d185 9
a196 3
 retry:
	evtimer_set(&env->sc_snmpto, snmp_sock, arg);
	evtimer_add(&env->sc_snmpto, &tv);
d199 41
d241 2
a242 1
snmp_element(const char *oid, enum snmp_type type, void *buf, int64_t val)
a243 2
	struct iovec		 iov[2];
	int			 iovcnt = 2;
d246 1
a246 1
	struct snmp_imsg	 sm;
d251 2
a252 1
	bzero(&iov, sizeof(iov));
d255 10
d266 6
a271 1
	case SNMP_GAUGE32:
a272 3
	case SNMP_OPAQUE:
	case SNMP_UINTEGER32:
	case SNMP_INTEGER32:
d274 3
a276 2
		iov[1].iov_base = &d;
		iov[1].iov_len = sizeof(d);
d278 1
d281 3
a283 2
		iov[1].iov_base = &l;
		iov[1].iov_len = sizeof(l);
d285 19
a303 1
	case SNMP_NSAPADDR:
d306 3
a308 7
	case SNMP_IPADDR:
	case SNMP_OBJECT:
		iov[1].iov_base = buf;
		if (val == 0)
			iov[1].iov_len = strlen((char *)buf);
		else
			iov[1].iov_len = val;
d310 1
d312 4
a315 2
		iovcnt--;
		break;
a317 14
	bzero(&sm, sizeof(sm));
	if (strlcpy(sm.snmp_oid, oid, sizeof(sm.snmp_oid)) >=
	    sizeof(sm.snmp_oid))
		return (-1);
	sm.snmp_type = type;
	sm.snmp_len = iov[1].iov_len;
	iov[0].iov_base = &sm;
	iov[0].iov_len = sizeof(sm);

	if (imsg_composev(&iev_snmp->ibuf, IMSG_SNMP_ELEMENT, 0, 0, -1,
	    iov, iovcnt) == -1)
		return (-1);
	imsg_event_add(iev_snmp);

d328 3
a330 1
	if (iev_snmp == NULL || env->sc_snmp == -1)
d338 2
a339 1
	imsg_compose_event(iev_snmp, IMSG_SNMP_TRAP, 0, 0, -1, NULL, 0);
d341 8
a348 8
	SNMP_ELEMENT(".1.0", SNMP_NULL, NULL, 0);
	SNMP_ELEMENT(".1.1.0", SNMP_OCTETSTRING, host->conf.name, 0);
	SNMP_ELEMENT(".1.2.0", SNMP_INTEGER32, NULL, host->up);
	SNMP_ELEMENT(".1.3.0", SNMP_INTEGER32, NULL, host->last_up);
	SNMP_ELEMENT(".1.4.0", SNMP_INTEGER32, NULL, host->up_cnt);
	SNMP_ELEMENT(".1.5.0", SNMP_INTEGER32, NULL, host->check_cnt);
	SNMP_ELEMENT(".1.6.0", SNMP_OCTETSTRING, table->conf.name, 0);
	SNMP_ELEMENT(".1.7.0", SNMP_INTEGER32, NULL, table->up);
d351 2
a352 2
	SNMP_ELEMENT(".1.8.0", SNMP_INTEGER32, NULL, host->conf.retry);
	SNMP_ELEMENT(".1.9.0", SNMP_INTEGER32, NULL, host->retry_cnt);
d355 23
a377 1
	imsg_compose_event(iev_snmp, IMSG_SNMP_END, 0, 0, -1, NULL, 0);
@


1.12
log
@Append mandatory instance identifier (.0 for scalars), so other SNMP
implementations can grok it.

ok joel@@
@
text
@d1 1
a1 1
/*	$OpenBSD: snmp.c,v 1.11 2011/05/19 08:56:49 reyk Exp $	*/
d114 2
a115 2
	if (iev_snmp == NULL && (iev_snmp = (struct imsgev *)
	    calloc(1, sizeof(struct imsgev))) == NULL)
@


1.11
log
@Fix reload support in relayd(8) by reimplementing large parts of the
daemon infrastructure. The previous design made it fairly hard to
reload the complex data structures, especially relays and protocols.
One of the reasons was that the privsep'd relayd processes had two
ways of getting their configuration: 1) from memory after forking from
the parent process and 2) and (partially) via imsgs after reload.  The
new implementation first forks the privsep'd children before the
parents loads the configuration and sends it via imsgs to them; so it
is only like 2) before.  It is based on an approach that I first
implemented for iked(8) and I also fixed many bugs in the code.

Thanks to many testers including dlg@@ sthen@@ phessler@@
ok pyr@@ dlg@@ sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: snmp.c,v 1.10 2011/05/09 12:08:47 reyk Exp $	*/
d233 8
a240 8
	SNMP_ELEMENT(".1", SNMP_NULL, NULL, 0);
	SNMP_ELEMENT(".1.1", SNMP_OCTETSTRING, host->conf.name, 0);
	SNMP_ELEMENT(".1.2", SNMP_INTEGER32, NULL, host->up);
	SNMP_ELEMENT(".1.3", SNMP_INTEGER32, NULL, host->last_up);
	SNMP_ELEMENT(".1.4", SNMP_INTEGER32, NULL, host->up_cnt);
	SNMP_ELEMENT(".1.5", SNMP_INTEGER32, NULL, host->check_cnt);
	SNMP_ELEMENT(".1.6", SNMP_OCTETSTRING, table->conf.name, 0);
	SNMP_ELEMENT(".1.7", SNMP_INTEGER32, NULL, table->up);
d243 2
a244 2
	SNMP_ELEMENT(".1.8", SNMP_INTEGER32, NULL, host->conf.retry);
	SNMP_ELEMENT(".1.9", SNMP_INTEGER32, NULL, host->retry_cnt);
@


1.10
log
@Reorganize the relayd code to use the proc.c privsep API/commodity
functions that are based on work for iked and smtpd.  This simplifies
the setup of privsep processes and moves some redundant and repeated
code to a single place - which is always good from a quality and
security point of view.  The relayd version of proc.c is different to
the current version in iked because it uses 1:N communications between
processes, eg. a single parent process is talking to many forked relay
children while iked only needs 1:1 communications.

ok sthen@@ pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: snmp.c,v 1.9 2011/05/05 12:01:44 reyk Exp $	*/
a51 1
int	 snmp_getsock(struct relayd *, enum privsep_procid);
d74 1
a74 1
snmp_sendsock(struct relayd *env, enum privsep_procid id)
d81 1
a81 1
		goto fail;
d86 6
a91 2
	if (connect(s, (struct sockaddr *)&sun, sizeof(sun)) == -1)
		goto fail;
d98 1
a99 8
	proc_flush_imsg(env->sc_ps, id, -1); /* need to send the socket now */
	close(s);
	return (0);

 fail:
	if (s != -1)
		close(s);
	proc_compose_imsg(env->sc_ps, id, -1, IMSG_NONE, -1, NULL, 0);
d104 1
a104 1
snmp_getsock(struct relayd *env, enum privsep_procid id)
d106 6
a111 29
	struct imsg	 imsg;
	struct imsgbuf	*ibuf;
	int		 n, s = -1, done = 0;

	ibuf = proc_ibuf(env->sc_ps, id, -1);
	proc_compose_imsg(env->sc_ps, id, -1, IMSG_SNMPSOCK, -1, NULL, 0);
	proc_flush_imsg(env->sc_ps, id, -1);

	while (!done) {
		do {
			if ((n = imsg_read(ibuf)) == -1)
				fatalx("snmp_getsock: imsg_read error");
		} while (n == -2); /* handle non-blocking I/O */
		while (!done) {
			if ((n = imsg_get(ibuf, &imsg)) == -1)
				fatal("snmp_getsock: failed to get imsg");
			if (n == 0)
				break;
			done = 1;
			switch (imsg.hdr.type) {
			case IMSG_SNMPSOCK:
				s = imsg.fd;
				break;
			default:
				break;
			}
			imsg_free(&imsg);
		}
	}
d113 5
a117 7
	if (s != -1) {
		log_debug("%s: got new snmp socket %d", __func__, s);
		if (iev_snmp == NULL && (iev_snmp = (struct imsgev *)
		    calloc(1, sizeof(struct imsgev))) == NULL)
			fatal("snmp_getsock: calloc");
		imsg_init(&iev_snmp->ibuf, s);
	}
d119 8
a126 1
	return (s);
d145 2
a146 8
	if ((env->sc_snmp = snmp_getsock(env, snmp_procid)) == -1) {
		DPRINTF("%s: failed to open snmp socket", __func__);
		goto retry;
	}

	event_set(&env->sc_snmpev, env->sc_snmp,
	    EV_READ|EV_TIMEOUT, snmp_sock, arg);
	event_add(&env->sc_snmpev, NULL);
@


1.9
log
@Update all logging and debug functions to use the __func__ macro
instead of static function names.  __func__ is C99 and perfectly fine
to use. It also avoids printing errors; for example if a statement
log_debug("foo:"..) was moved or copied from function foo() to bar()
and the log message was not updated...
@
text
@d1 1
a1 1
/*	$OpenBSD: snmp.c,v 1.8 2009/06/09 16:26:03 deraadt Exp $	*/
d49 1
a49 2
static struct imsgev	*iev_main = NULL;
static struct relayd	*env = NULL;
d52 1
a52 1
int	 snmp_getsock(struct imsgev *);
d56 1
a56 1
snmp_init(struct relayd *x_env, struct imsgev *iev)
a57 3
	env = x_env;
	iev_main = iev;

d67 1
a67 2
	if ((env->sc_flags & F_TRAP) == 0) {
		iev_main = NULL;
a68 1
	}
d70 2
a71 1
	snmp_sock(-1, -1, iev);
d75 1
a75 1
snmp_sendsock(struct imsgev *iev)
d95 2
a96 2
	imsg_compose_event(iev, IMSG_SNMPSOCK, 0, 0, s, NULL, 0);
	imsg_flush(&iev->ibuf);	/* need to send the socket now */
d103 1
a103 1
	imsg_compose_event(iev, IMSG_NONE, 0, 0, -1, NULL, 0);
d108 1
a108 1
snmp_getsock(struct imsgev *iev)
d111 1
d114 3
a116 2
	imsg_compose_event(iev, IMSG_SNMPSOCK, 0, 0, -1, NULL, 0);
	imsg_flush(&iev->ibuf);
d119 4
a122 4
		if ((n = imsg_read(&iev->ibuf)) == -1)
			fatal("snmp_getsock: failed to read imsg");
		if (n == 0)
			fatal("snmp_getsock: pipe closed");
d124 1
a124 1
			if ((n = imsg_get(&iev->ibuf, &imsg)) == -1)
d154 2
a155 1
	struct timeval	tv = SNMP_RECONNECT_TIMEOUT;
d167 1
a167 1
	if ((env->sc_snmp = snmp_getsock(iev_main)) == -1) {
d177 1
a177 1
	evtimer_set(&env->sc_snmpto, snmp_sock, env);
d249 1
a249 1
snmp_hosttrap(struct table *table, struct host *host)
@


1.8
log
@missing header file; bring things into scope
@
text
@d1 1
a1 1
/*	$OpenBSD: snmp.c,v 1.7 2009/06/07 05:56:25 eric Exp $	*/
d144 1
a144 1
		log_debug("snmp_getsock: got new snmp socket %d", s);
d164 1
a164 1
		log_debug("snmp_sock: snmp socket closed %d", env->sc_snmp);
d170 1
a170 1
		DPRINTF("snmp_sock: failed to open snmp socket");
d192 1
a192 1
	DPRINTF("snmp_element: oid %s type %d buf %p val %lld",
@


1.7
log
@Change the way fds passed over a socket are retreived on the receiving side.

Currently the receiver fetches an imsg via imsg_get() and if he expects
an fd, he then calls imsg_get_fd() to fetch the next fd queued on the
imsgbuf from which the imsg came.

This changes hides the fd queueing mechanism to the API user.  When closing
an imsg with an fd, the message is flagged so that the receiving end knows
it must dequeue the fd in imsg_get() and return it with the imsg structure.
This way there is no (less) possible screw up from imsg_get_fd() not being
called directly after imsg_get() by the user. The retreived imsg is
self-contained.

ok pyr@@, "I like that" henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: snmp.c,v 1.6 2009/06/06 05:30:45 eric Exp $	*/
d24 1
@


1.6
log
@allocate the correct amount of memory

ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: snmp.c,v 1.5 2009/06/05 23:39:51 pyr Exp $	*/
d133 1
a133 1
				s = imsg_get_fd(&iev->ibuf);
@


1.5
log
@4 handed diff with eric:
Stop pushing event handling in the imsg framework.
Instead, provide a small glue layer on top of both imsg and libevent.
This finally clearly separates event handling and imsg construction.

Sidetrack bonus: remove the mega-ugly hack of having a dummy imsg_event_add
stub in relayctl.

This will make bgpd (and thus henning) happy. Next up are smtpd and ospfd.

ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: snmp.c,v 1.4 2009/06/05 00:04:01 pyr Exp $	*/
d145 1
a145 1
		    calloc(1, sizeof(struct imsgbuf))) == NULL)
@


1.4
log
@Make imsg completely async model agnostic by not requiring an
imsg_event_add function to be provided (which ended up being a named
callback).
Instead provide a wrapper in the daemon and call that everywhere.
Previsously discussed with the usual suspects,
ok eric@@ though not too happy about the function name
(imsg_compose_event).
@
text
@d1 1
a1 1
/*	$OpenBSD: snmp.c,v 1.3 2009/06/03 20:20:09 eric Exp $	*/
d47 2
a48 2
static struct imsgbuf	*ibuf_snmp = NULL;
static struct imsgbuf	*ibuf_main = NULL;
d52 1
a52 1
int	 snmp_getsock(struct imsgbuf *);
d56 1
a56 1
snmp_init(struct relayd *x_env, struct imsgbuf *ibuf)
d59 1
a59 1
	ibuf_main = ibuf;
d71 1
a71 1
		ibuf_main = NULL;
d75 1
a75 1
	snmp_sock(-1, -1, ibuf);
d79 1
a79 1
snmp_sendsock(struct imsgbuf *ibuf)
d81 1
a81 1
	struct imsgbuf		 tmpibuf;
d95 3
a97 3
	bzero(&tmpibuf, sizeof(tmpibuf));
	imsg_init(&tmpibuf, s, NULL);
	imsg_compose_event(&tmpibuf, IMSG_SNMP_LOCK, 0, 0, -1, NULL, 0);
d99 2
a100 2
	imsg_compose_event(ibuf, IMSG_SNMPSOCK, 0, 0, s, NULL, 0);
	imsg_flush(ibuf);	/* need to send the socket now */
d107 1
a107 1
	imsg_compose_event(ibuf, IMSG_NONE, 0, 0, -1, NULL, 0);
d112 1
a112 1
snmp_getsock(struct imsgbuf *ibuf)
d117 2
a118 2
	imsg_compose_event(ibuf, IMSG_SNMPSOCK, 0, 0, -1, NULL, 0);
	imsg_flush(ibuf);
d121 1
a121 1
		if ((n = imsg_read(ibuf)) == -1)
d126 1
a126 1
			if ((n = imsg_get(ibuf, &imsg)) == -1)
d133 1
a133 1
				s = imsg_get_fd(ibuf);
d144 1
a144 1
		if (ibuf_snmp == NULL && (ibuf_snmp = (struct imsgbuf *)
d147 1
a147 1
		imsg_init(ibuf_snmp, s, NULL);
d168 1
a168 1
	if ((env->sc_snmp = snmp_getsock(ibuf_main)) == -1) {
d237 1
a237 1
	if (imsg_composev(ibuf_snmp, IMSG_SNMP_ELEMENT, 0, 0, -1,
d240 1
a240 1
	imsg_event_add(ibuf_snmp);
d252 1
a252 1
	if (ibuf_snmp == NULL || env->sc_snmp == -1)
d260 1
a260 1
	imsg_compose_event(ibuf_snmp, IMSG_SNMP_TRAP, 0, 0, -1, NULL, 0);
d276 1
a276 1
	imsg_compose_event(ibuf_snmp, IMSG_SNMP_END, 0, 0, -1, NULL, 0);
@


1.3
log
@cleanup contorted and slightly broken call to imsg_get_fd

ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: snmp.c,v 1.2 2008/05/05 15:07:12 henning Exp $	*/
d97 1
a97 1
	imsg_compose(&tmpibuf, IMSG_SNMP_LOCK, 0, 0, -1, NULL, 0);
d99 1
a99 1
	imsg_compose(ibuf, IMSG_SNMPSOCK, 0, 0, s, NULL, 0);
d107 1
a107 1
	imsg_compose(ibuf, IMSG_NONE, 0, 0, -1, NULL, 0);
d117 1
a117 1
	imsg_compose(ibuf, IMSG_SNMPSOCK, 0, 0, -1, NULL, 0);
d240 1
d260 1
a260 1
	imsg_compose(ibuf_snmp, IMSG_SNMP_TRAP, 0, 0, -1, NULL, 0);
d276 1
a276 1
	imsg_compose(ibuf_snmp, IMSG_SNMP_END, 0, 0, -1, NULL, 0);
@


1.2
log
@clean up after reyk (tab at EOL)
@
text
@d1 1
a1 1
/*	$OpenBSD: snmp.c,v 1.1 2008/02/11 10:42:50 reyk Exp $	*/
d133 1
a133 2
				if ((s = imsg_get_fd(ibuf)) <= 0)
					s = -1;
@


1.1
log
@Marry relayd with snmpd using new "send trap" option: Request to send
a SNMP trap when the state of a host changes.  relayd(8) will try to
(re-)connect to snmpd(8) and request it to send a trap to the
registered trap receivers, see snmpd.conf(5) for more information
about the configuration.

ok pyr@@ thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d74 1
a74 1
	
d261 1
a261 1
	
d275 1
a275 1
 done:	
@

