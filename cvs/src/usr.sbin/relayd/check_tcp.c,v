head	1.52;
access;
symbols
	OPENBSD_6_1_BASE:1.52
	OPENBSD_6_0:1.51.0.4
	OPENBSD_6_0_BASE:1.51
	OPENBSD_5_9:1.51.0.2
	OPENBSD_5_9_BASE:1.51
	OPENBSD_5_8:1.46.0.6
	OPENBSD_5_8_BASE:1.46
	OPENBSD_5_7:1.46.0.2
	OPENBSD_5_7_BASE:1.46
	OPENBSD_5_6:1.43.0.4
	OPENBSD_5_6_BASE:1.43
	OPENBSD_5_5:1.42.0.14
	OPENBSD_5_5_BASE:1.42
	OPENBSD_5_4:1.42.0.10
	OPENBSD_5_4_BASE:1.42
	OPENBSD_5_3:1.42.0.8
	OPENBSD_5_3_BASE:1.42
	OPENBSD_5_2:1.42.0.6
	OPENBSD_5_2_BASE:1.42
	OPENBSD_5_1_BASE:1.42
	OPENBSD_5_1:1.42.0.4
	OPENBSD_5_0:1.42.0.2
	OPENBSD_5_0_BASE:1.42
	OPENBSD_4_9:1.39.0.2
	OPENBSD_4_9_BASE:1.39
	OPENBSD_4_8:1.37.0.2
	OPENBSD_4_8_BASE:1.37
	OPENBSD_4_7:1.36.0.2
	OPENBSD_4_7_BASE:1.36
	OPENBSD_4_6:1.34.0.4
	OPENBSD_4_6_BASE:1.34
	OPENBSD_4_5:1.33.0.2
	OPENBSD_4_5_BASE:1.33
	OPENBSD_4_4:1.32.0.4
	OPENBSD_4_4_BASE:1.32
	OPENBSD_4_3:1.32.0.2
	OPENBSD_4_3_BASE:1.32;
locks; strict;
comment	@ * @;


1.52
date	2017.02.09.11.16.22;	author reyk;	state Exp;
branches;
next	1.51;
commitid	UfczFihKqh7Choa6;

1.51
date	2016.01.11.21.31.42;	author benno;	state Exp;
branches;
next	1.50;
commitid	tlLuP4GlMjndgo3c;

1.50
date	2015.12.30.12.08.34;	author benno;	state Exp;
branches;
next	1.49;
commitid	v04SUqtFvii3BsSp;

1.49
date	2015.12.24.13.58.30;	author benno;	state Exp;
branches;
next	1.48;
commitid	euTaGfXU8KyPK0RQ;

1.48
date	2015.11.28.09.52.07;	author reyk;	state Exp;
branches;
next	1.47;
commitid	Xo3TbDi9hUaP9ip0;

1.47
date	2015.08.21.08.45.51;	author yasuoka;	state Exp;
branches;
next	1.46;
commitid	6XMVUYi6SZ55Zx0G;

1.46
date	2015.01.22.17.42.09;	author reyk;	state Exp;
branches;
next	1.45;
commitid	puppem00jmzmdm4f;

1.45
date	2015.01.16.15.06.40;	author deraadt;	state Exp;
branches;
next	1.44;
commitid	tOv8XK6tLyhEfayc;

1.44
date	2014.12.12.10.05.09;	author reyk;	state Exp;
branches;
next	1.43;
commitid	J8g0vRzthwLCqf68;

1.43
date	2014.05.15.07.56.26;	author reyk;	state Exp;
branches;
next	1.42;

1.42
date	2011.06.17.14.36.51;	author jsg;	state Exp;
branches;
next	1.41;

1.41
date	2011.05.19.08.56.49;	author reyk;	state Exp;
branches;
next	1.40;

1.40
date	2011.05.05.12.01.43;	author reyk;	state Exp;
branches;
next	1.39;

1.39
date	2010.12.20.12.38.06;	author dhill;	state Exp;
branches;
next	1.38;

1.38
date	2010.11.30.14.38.45;	author reyk;	state Exp;
branches;
next	1.37;

1.37
date	2010.05.26.13.56.08;	author nicm;	state Exp;
branches;
next	1.36;

1.36
date	2010.02.18.14.02.16;	author jsg;	state Exp;
branches;
next	1.35;

1.35
date	2009.08.07.11.10.23;	author reyk;	state Exp;
branches;
next	1.34;

1.34
date	2009.06.04.14.03.22;	author reyk;	state Exp;
branches;
next	1.33;

1.33
date	2008.12.05.16.37.55;	author reyk;	state Exp;
branches;
next	1.32;

1.32
date	2008.03.03.16.58.41;	author reyk;	state Exp;
branches;
next	1.31;

1.31
date	2007.12.07.17.17.00;	author reyk;	state Exp;
branches;
next	1.30;

1.30
date	2007.11.24.17.07.28;	author reyk;	state Exp;
branches;
next	1.29;

1.29
date	2007.11.21.20.13.20;	author reyk;	state Exp;
branches;
next	1.28;

1.28
date	2007.11.21.13.04.42;	author reyk;	state Exp;
branches;
next	1.27;

1.27
date	2007.11.19.15.20.18;	author reyk;	state Exp;
branches;
next	1.26;

1.26
date	2007.09.28.13.29.56;	author pyr;	state Exp;
branches;
next	1.25;

1.25
date	2007.06.07.14.17.33;	author pyr;	state Exp;
branches;
next	1.24;

1.24
date	2007.05.27.20.53.10;	author pyr;	state Exp;
branches;
next	1.23;

1.23
date	2007.02.22.05.58.06;	author reyk;	state Exp;
branches;
next	1.22;

1.22
date	2007.02.08.13.32.24;	author reyk;	state Exp;
branches;
next	1.21;

1.21
date	2007.02.07.15.13.00;	author reyk;	state Exp;
branches;
next	1.20;

1.20
date	2007.02.07.14.54.13;	author reyk;	state Exp;
branches;
next	1.19;

1.19
date	2007.02.07.14.45.12;	author reyk;	state Exp;
branches;
next	1.18;

1.18
date	2007.02.07.14.39.45;	author reyk;	state Exp;
branches;
next	1.17;

1.17
date	2007.02.06.10.27.33;	author reyk;	state Exp;
branches;
next	1.16;

1.16
date	2007.02.06.10.26.13;	author pyr;	state Exp;
branches;
next	1.15;

1.15
date	2007.02.03.20.24.21;	author reyk;	state Exp;
branches;
next	1.14;

1.14
date	2007.02.03.17.45.59;	author reyk;	state Exp;
branches;
next	1.13;

1.13
date	2007.01.30.10.09.02;	author pyr;	state Exp;
branches;
next	1.12;

1.12
date	2007.01.29.14.23.31;	author pyr;	state Exp;
branches;
next	1.11;

1.11
date	2007.01.20.16.32.10;	author pyr;	state Exp;
branches;
next	1.10;

1.10
date	2007.01.12.16.43.01;	author pyr;	state Exp;
branches;
next	1.9;

1.9
date	2007.01.11.18.05.08;	author reyk;	state Exp;
branches;
next	1.8;

1.8
date	2007.01.09.00.45.32;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2007.01.08.20.46.18;	author reyk;	state Exp;
branches;
next	1.6;

1.6
date	2007.01.08.17.10.23;	author reyk;	state Exp;
branches;
next	1.5;

1.5
date	2007.01.08.13.37.26;	author reyk;	state Exp;
branches;
next	1.4;

1.4
date	2006.12.25.19.05.41;	author reyk;	state Exp;
branches;
next	1.3;

1.3
date	2006.12.25.18.12.14;	author reyk;	state Exp;
branches;
next	1.2;

1.2
date	2006.12.16.12.42.14;	author reyk;	state Exp;
branches;
next	1.1;

1.1
date	2006.12.16.11.45.07;	author reyk;	state Exp;
branches;
next	;


desc
@@


1.52
log
@Do not loose the send/expect validation error on timeout.

When a read timeout is reached, the code also has to check if there is
already anything in the input buffer and verify it again.  This fixes
relayd and relayctl to show "send/expect failed" instead of "tcp read
timeout".

Found by Michael W. Lucas (while working on the Relayd Mastery book).
Thanks.

OK benno@@
@
text
@/*	$OpenBSD: check_tcp.c,v 1.51 2016/01/11 21:31:42 benno Exp $	*/

/*
 * Copyright (c) 2006 Pierre-Yves Ritschard <pyr@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/time.h>
#include <sys/socket.h>

#include <netinet/in.h>

#include <limits.h>
#include <event.h>
#include <fcntl.h>
#include <unistd.h>
#include <string.h>
#include <stdlib.h>
#include <errno.h>
#include <fnmatch.h>
#include <sha1.h>
#include <imsg.h>

#include "relayd.h"

void	tcp_write(int, short, void *);
void	tcp_host_up(struct ctl_tcp_event *);
void	tcp_close(struct ctl_tcp_event *, int);
void	tcp_send_req(int, short, void *);
void	tcp_read_buf(int, short, void *);

int	check_http_code(struct ctl_tcp_event *);
int	check_http_digest(struct ctl_tcp_event *);
int	check_send_expect(struct ctl_tcp_event *);

void
check_tcp(struct ctl_tcp_event *cte)
{
	int			 s;
	socklen_t		 len;
	struct timeval		 tv;
	struct linger		 lng;
	int			 he = HCE_TCP_SOCKET_OPTION;

	switch (cte->host->conf.ss.ss_family) {
	case AF_INET:
		((struct sockaddr_in *)&cte->host->conf.ss)->sin_port =
			cte->table->conf.port;
		break;
	case AF_INET6:
		((struct sockaddr_in6 *)&cte->host->conf.ss)->sin6_port =
			cte->table->conf.port;
		break;
	}

	len = ((struct sockaddr *)&cte->host->conf.ss)->sa_len;

	if ((s = socket(cte->host->conf.ss.ss_family,
	    SOCK_STREAM | SOCK_NONBLOCK, 0)) == -1) {
		if (errno == EMFILE || errno == ENFILE)
			he = HCE_TCP_SOCKET_LIMIT;
		else
			he = HCE_TCP_SOCKET_ERROR;
		goto bad;
	}

	cte->s = s;

	bzero(&lng, sizeof(lng));
	if (setsockopt(s, SOL_SOCKET, SO_LINGER, &lng, sizeof(lng)) == -1)
		goto bad;

	if (cte->host->conf.ttl > 0) {
		if (setsockopt(s, IPPROTO_IP, IP_TTL,
		    &cte->host->conf.ttl, sizeof(int)) == -1)
			goto bad;
	}

	bcopy(&cte->table->conf.timeout, &tv, sizeof(tv));
	if (connect(s, (struct sockaddr *)&cte->host->conf.ss, len) == -1) {
		if (errno != EINPROGRESS) {
			he = HCE_TCP_CONNECT_FAIL;
			goto bad;
		}
	}

	cte->buf = NULL;
	cte->host->up = HOST_UP;
	event_del(&cte->ev);
	event_set(&cte->ev, s, EV_TIMEOUT|EV_WRITE, tcp_write, cte);
	event_add(&cte->ev, &tv);
	return;

bad:
	tcp_close(cte, HOST_DOWN);
	hce_notify_done(cte->host, he);
}

void
tcp_write(int s, short event, void *arg)
{
	struct ctl_tcp_event	*cte = arg;
	int			 err;
	socklen_t		 len;

	if (event == EV_TIMEOUT) {
		tcp_close(cte, HOST_DOWN);
		hce_notify_done(cte->host, HCE_TCP_CONNECT_TIMEOUT);
		return;
	}

	len = sizeof(err);
	if (getsockopt(s, SOL_SOCKET, SO_ERROR, &err, &len))
		fatal("tcp_write: getsockopt");
	if (err != 0) {
		tcp_close(cte, HOST_DOWN);
		hce_notify_done(cte->host, HCE_TCP_CONNECT_FAIL);
		return;
	}

	cte->host->up = HOST_UP;
	tcp_host_up(cte);
}

void
tcp_close(struct ctl_tcp_event *cte, int status)
{
	close(cte->s);
	cte->s = -1;
	if (status != 0)
		cte->host->up = status;
	ibuf_free(cte->buf);
	cte->buf = NULL;
}

void
tcp_host_up(struct ctl_tcp_event *cte)
{
	switch (cte->table->conf.check) {
	case CHECK_TCP:
		if (cte->table->conf.flags & F_TLS)
			break;
		tcp_close(cte, 0);
		hce_notify_done(cte->host, HCE_TCP_CONNECT_OK);
		return;
	case CHECK_HTTP_CODE:
		cte->validate_read = NULL;
		cte->validate_close = check_http_code;
		break;
	case CHECK_HTTP_DIGEST:
		cte->validate_read = NULL;
		cte->validate_close = check_http_digest;
		break;
	case CHECK_SEND_EXPECT:
		cte->validate_read = check_send_expect;
		cte->validate_close = check_send_expect;
		break;
	}

	if (cte->table->conf.flags & F_TLS) {
		ssl_transaction(cte);
		return;
	}

	if (cte->table->sendbuf != NULL) {
		cte->req = cte->table->sendbuf;
		event_again(&cte->ev, cte->s, EV_TIMEOUT|EV_WRITE, tcp_send_req,
		    &cte->tv_start, &cte->table->conf.timeout, cte);
		return;
	}

	if ((cte->buf = ibuf_dynamic(SMALL_READ_BUF_SIZE, UINT_MAX)) == NULL)
		fatalx("tcp_host_up: cannot create dynamic buffer");
	event_again(&cte->ev, cte->s, EV_TIMEOUT|EV_READ, tcp_read_buf,
	    &cte->tv_start, &cte->table->conf.timeout, cte);
}

void
tcp_send_req(int s, short event, void *arg)
{
	struct ctl_tcp_event	*cte = arg;
	int			 bs;
	int			 len;

	if (event == EV_TIMEOUT) {
		tcp_close(cte, HOST_DOWN);
		hce_notify_done(cte->host, HCE_TCP_WRITE_TIMEOUT);
		return;
	}
	len = strlen(cte->req);
	do {
		bs = write(s, cte->req, len);
		if (bs == -1) {
			if (errno == EAGAIN || errno == EINTR)
				goto retry;
			log_warn("%s: cannot send request", __func__);
			tcp_close(cte, HOST_DOWN);
			hce_notify_done(cte->host, HCE_TCP_WRITE_FAIL);
			return;
		}
		cte->req += bs;
		len -= bs;
	} while (len > 0);

	if ((cte->buf = ibuf_dynamic(SMALL_READ_BUF_SIZE, UINT_MAX)) == NULL)
		fatalx("tcp_send_req: cannot create dynamic buffer");
	event_again(&cte->ev, s, EV_TIMEOUT|EV_READ, tcp_read_buf,
	    &cte->tv_start, &cte->table->conf.timeout, cte);
	return;

 retry:
	event_again(&cte->ev, s, EV_TIMEOUT|EV_WRITE, tcp_send_req,
	    &cte->tv_start, &cte->table->conf.timeout, cte);
}

void
tcp_read_buf(int s, short event, void *arg)
{
	ssize_t			 br;
	char			 rbuf[SMALL_READ_BUF_SIZE];
	struct ctl_tcp_event	*cte = arg;

	if (event == EV_TIMEOUT) {
		if (ibuf_size(cte->buf))
			(void)cte->validate_close(cte);
		else
			cte->host->he = HCE_TCP_READ_TIMEOUT;
		tcp_close(cte, cte->host->up == HOST_UP ? 0 : HOST_DOWN);
		hce_notify_done(cte->host, cte->host->he);
		return;
	}

	bzero(rbuf, sizeof(rbuf));
	br = read(s, rbuf, sizeof(rbuf) - 1);
	switch (br) {
	case -1:
		if (errno == EAGAIN || errno == EINTR)
			goto retry;
		tcp_close(cte, HOST_DOWN);
		hce_notify_done(cte->host, HCE_TCP_READ_FAIL);
		return;
	case 0:
		cte->host->up = HOST_DOWN;
		(void)cte->validate_close(cte);
		tcp_close(cte, 0);
		hce_notify_done(cte->host, cte->host->he);
		return;
	default:
		if (ibuf_add(cte->buf, rbuf, br) == -1)
			fatal("tcp_read_buf: buf_add error");
		if (cte->validate_read != NULL) {
			if (cte->validate_read(cte) != 0)
				goto retry;
			tcp_close(cte, 0);
			hce_notify_done(cte->host, cte->host->he);
			return;
		}
		break; /* retry */
	}
retry:
	event_again(&cte->ev, s, EV_TIMEOUT|EV_READ, tcp_read_buf,
	    &cte->tv_start, &cte->table->conf.timeout, cte);
}

int
check_send_expect(struct ctl_tcp_event *cte)
{
	u_char	*b;

	/*
	 * ensure string is nul-terminated.
	 */
	b = ibuf_reserve(cte->buf, 1);
	if (b == NULL)
		fatal("out of memory");
	*b = '\0';
	if (fnmatch(cte->table->conf.exbuf, cte->buf->buf, 0) == 0) {
		cte->host->he = HCE_SEND_EXPECT_OK;
		cte->host->up = HOST_UP;
		return (0);
	}
	cte->host->he = HCE_SEND_EXPECT_FAIL;
	cte->host->up = HOST_UNKNOWN;

	/*
	 * go back to original position.
	 */
	cte->buf->wpos--;
	return (1);
}

int
check_http_code(struct ctl_tcp_event *cte)
{
	char		*head;
	char		 scode[4];
	const char	*estr;
	u_char		*b;
	int		 code;
	struct host	*host;

	/*
	 * ensure string is nul-terminated.
	 */
	b = ibuf_reserve(cte->buf, 1);
	if (b == NULL)
		fatal("out of memory");
	*b = '\0';

	head = cte->buf->buf;
	host = cte->host;
	host->he = HCE_HTTP_CODE_ERROR;
	host->code = 0;

	if (strncmp(head, "HTTP/1.1 ", strlen("HTTP/1.1 ")) &&
	    strncmp(head, "HTTP/1.0 ", strlen("HTTP/1.0 "))) {
		log_debug("%s: %s failed (cannot parse HTTP version)",
		    __func__, host->conf.name);
		host->up = HOST_DOWN;
		return (1);
	}
	head += strlen("HTTP/1.1 ");
	if (strlen(head) < 5) /* code + \r\n */ {
		host->up = HOST_DOWN;
		return (1);
	}
	(void)strlcpy(scode, head, sizeof(scode));
	code = strtonum(scode, 100, 999, &estr);
	if (estr != NULL) {
		log_debug("%s: %s failed (cannot parse HTTP code)",
		    __func__, host->conf.name);
		host->up = HOST_DOWN;
		return (1);
	}
	if (code != cte->table->conf.retcode) {
		log_debug("%s: %s failed (invalid HTTP code %d returned)",
		    __func__, host->conf.name, code);
		host->he = HCE_HTTP_CODE_FAIL;
		host->up = HOST_DOWN;
		host->code = code;
	} else {
		host->he = HCE_HTTP_CODE_OK;
		host->up = HOST_UP;
	}
	return (!(host->up == HOST_UP));
}

int
check_http_digest(struct ctl_tcp_event *cte)
{
	char		*head;
	u_char		*b;
	char		 digest[SHA1_DIGEST_STRING_LENGTH];
	struct host	*host;

	/*
	 * ensure string is nul-terminated.
	 */
	b = ibuf_reserve(cte->buf, 1);
	if (b == NULL)
		fatal("out of memory");
	*b = '\0';

	head = cte->buf->buf;
	host = cte->host;
	host->he = HCE_HTTP_DIGEST_ERROR;

	if ((head = strstr(head, "\r\n\r\n")) == NULL) {
		log_debug("%s: %s failed (no end of headers)",
		    __func__, host->conf.name);
		host->up = HOST_DOWN;
		return (1);
	}
	head += strlen("\r\n\r\n");

	digeststr(cte->table->conf.digest_type, head, strlen(head), digest);

	if (strcmp(cte->table->conf.digest, digest)) {
		log_warnx("%s: %s failed (wrong digest)",
		    __func__, host->conf.name);
		host->he = HCE_HTTP_DIGEST_FAIL;
		host->up = HOST_DOWN;
	} else {
		host->he = HCE_HTTP_DIGEST_OK;
		host->up = HOST_UP;
	}
	return (!(host->up == HOST_UP));
}
@


1.51
log
@This adds the host_error output and the http code (when available) to the
host-check log.
ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: check_tcp.c,v 1.50 2015/12/30 12:08:34 benno Exp $	*/
d236 6
a241 2
		tcp_close(cte, HOST_DOWN);
		hce_notify_done(cte->host, HCE_TCP_READ_TIMEOUT);
@


1.50
log
@now that ibuf_free() checks for null, we can remove the check here.
ok mmcc@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: check_tcp.c,v 1.49 2015/12/24 13:58:30 benno Exp $	*/
d321 1
d344 2
a345 2
		log_debug("%s: %s failed (invalid HTTP code returned)",
		    __func__, host->conf.name);
d348 1
@


1.49
log
@revert check_tcp rev 1.41 by yasuoka@@
This part was not meant to be commited, only the bits in check_icmp.c
and relayd.h are ok.

ok yasuoka@@
@
text
@d1 1
a1 1
/*	$OpenBSD: check_tcp.c,v 1.46 2015/01/22 17:42:09 reyk Exp $	*/
d144 2
a145 4
	if (cte->buf) {
		ibuf_free(cte->buf);
		cte->buf = NULL;
	}
@


1.48
log
@Use SOCK_NONBLOCK in relayd as well.

OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: check_tcp.c,v 1.47 2015/08/21 08:45:51 yasuoka Exp $	*/
a43 1
int	check_http_resphead(struct ctl_tcp_event *);
d161 1
a161 1
		cte->validate_read = check_http_resphead;
a298 18
	return (1);
}

int
check_http_resphead(struct ctl_tcp_event *cte)
{
	int	 i, siz;

	/* checks whether the buffer contains the response header  */
	siz = ibuf_size(cte->buf);
	for (i = 0; i <= siz - 4; i++) {
		if (cte->buf->buf[i] == '\r' &&
		    cte->buf->buf[i + 1] == '\n' &&
		    cte->buf->buf[i + 2] == '\r' &&
		    cte->buf->buf[i + 3] == '\n')
			return (0);
	}

@


1.47
log
@Increase the input side socket buffer size for "check icmp" not to
drop the reply messages when "check icmp" is used with many hosts.

ok reyk benno
@
text
@d1 1
a1 1
/*	$OpenBSD: check_tcp.c,v 1.46 2015/01/22 17:42:09 reyk Exp $	*/
d71 2
a72 1
	if ((s = socket(cte->host->conf.ss.ss_family, SOCK_STREAM, 0)) == -1) {
a90 3

	if (fcntl(s, F_SETFL, O_NONBLOCK) == -1)
		goto bad;
@


1.46
log
@Clean up the relayd headers with help of include-what-you-use and some
manual review.  Based on common practice, relayd.h now includes the
necessary headers for itself.

OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: check_tcp.c,v 1.45 2015/01/16 15:06:40 deraadt Exp $	*/
d44 1
d164 1
a164 1
		cte->validate_read = NULL;
d302 18
@


1.45
log
@Adapt to <limits.h> universe.
ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: check_tcp.c,v 1.44 2014/12/12 10:05:09 reyk Exp $	*/
d19 2
a20 1
#include <sys/queue.h>
a22 1
#include <net/if.h>
d34 1
a34 2

#include <openssl/ssl.h>
@


1.44
log
@Change the keyword "ssl" to "tls" to reflect reality since we
effectively disabled support for the SSL protocols.  SSL remains a
common term describing SSL/TLS, there is some controvery about this
change, and the name really doesn't matter, but I feel confident about
it now.

(btw., sthen@@ pointed out some historical context:
http://tim.dierks.org/2014/05/security-standards-and-name-changes-in.html)

OK benno@@, with input from tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: check_tcp.c,v 1.43 2014/05/15 07:56:26 reyk Exp $	*/
a18 1
#include <sys/param.h>
@


1.43
log
@Use log_warn() to include errno if write() fails.

From thib
@
text
@d1 1
a1 1
/*	$OpenBSD: check_tcp.c,v 1.42 2011/06/17 14:36:51 jsg Exp $	*/
d159 1
a159 1
		if (cte->table->conf.flags & F_SSL)
d178 1
a178 1
	if (cte->table->conf.flags & F_SSL) {
@


1.42
log
@don't leak fds in failure path (ie when hosts are down)
from Martin Matuska in PR 6624

ok phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: check_tcp.c,v 1.41 2011/05/19 08:56:49 reyk Exp $	*/
d214 1
a214 1
			log_warnx("%s: cannot send request", __func__);
@


1.41
log
@Fix reload support in relayd(8) by reimplementing large parts of the
daemon infrastructure. The previous design made it fairly hard to
reload the complex data structures, especially relays and protocols.
One of the reasons was that the privsep'd relayd processes had two
ways of getting their configuration: 1) from memory after forking from
the parent process and 2) and (partially) via imsgs after reload.  The
new implementation first forks the privsep'd children before the
parents loads the configuration and sends it via imsgs to them; so it
is only like 2) before.  It is based on an approach that I first
implemented for iked(8) and I also fixed many bugs in the code.

Thanks to many testers including dlg@@ sthen@@ phessler@@
ok pyr@@ dlg@@ sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: check_tcp.c,v 1.40 2011/05/05 12:01:43 reyk Exp $	*/
d80 2
a104 1
	cte->s = s;
@


1.40
log
@Update all logging and debug functions to use the __func__ macro
instead of static function names.  __func__ is C99 and perfectly fine
to use. It also avoids printing errors; for example if a statement
log_debug("foo:"..) was moved or copied from function foo() to bar()
and the log message was not updated...
@
text
@d1 1
a1 1
/*	$OpenBSD: check_tcp.c,v 1.39 2010/12/20 12:38:06 dhill Exp $	*/
d41 2
a42 1
void	tcp_host_up(int, struct ctl_tcp_event *);
d103 1
d110 1
a110 2
	close(s);
	cte->host->up = HOST_DOWN;
d122 1
a122 2
		close(s);
		cte->host->up = HOST_DOWN;
d131 1
a131 2
		close(s);
		cte->host->up = HOST_DOWN;
d137 1
a137 1
	tcp_host_up(s, cte);
d141 1
a141 1
tcp_host_up(int s, struct ctl_tcp_event *cte)
d143 9
a151 1
	cte->s = s;
d153 3
d160 1
a160 1
		close(s);
d184 1
a184 1
		event_again(&cte->ev, s, EV_TIMEOUT|EV_WRITE, tcp_send_req,
d191 1
a191 1
	event_again(&cte->ev, s, EV_TIMEOUT|EV_READ, tcp_read_buf,
d203 1
a203 2
		cte->host->up = HOST_DOWN;
		close(cte->s);
d214 1
a214 2
			cte->host->up = HOST_DOWN;
			close(cte->s);
d241 1
a241 3
		cte->host->up = HOST_DOWN;
		ibuf_free(cte->buf);
		close(s);
d252 1
a252 3
		cte->host->up = HOST_DOWN;
		ibuf_free(cte->buf);
		close(cte->s);
d258 1
a258 2
		close(cte->s);
		ibuf_free(cte->buf);
d267 1
a267 3

			close(cte->s);
			ibuf_free(cte->buf);
@


1.39
log
@Only set SO_REUSEPORT for listening ports.

Fixes "Address already in use" errors seen on high load.

OK reyk@@ pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: check_tcp.c,v 1.38 2010/11/30 14:38:45 reyk Exp $	*/
d204 1
a204 1
			log_warnx("tcp_send_req: cannot send request");
d328 2
a329 2
		log_debug("check_http_code: %s failed "
		    "(cannot parse HTTP version)", host->conf.name);
d341 2
a342 2
		log_debug("check_http_code: %s failed "
		    "(cannot parse HTTP code)", host->conf.name);
d347 2
a348 2
		log_debug("check_http_code: %s failed "
		    "(invalid HTTP code returned)", host->conf.name);
d379 2
a380 2
		log_debug("check_http_digest: %s failed "
		    "(no end of headers)", host->conf.name);
d389 2
a390 2
		log_warnx("check_http_digest: %s failed "
		    "(wrong digest)", host->conf.name);
@


1.38
log
@The relayd processes did already bump up the socket file descriptor
resource limits to the maximum of the daemon class but the host check
process (hce/health checks) didn't and was limited to a fairly low
default of 128 open sockets (openfiles-cur=128 in login.conf). This
was reached fairly quickly with "check tcp" of many hosts. This diff
increases the maximum number of monitored hosts and concurrent health
checks in relayd in a significant way and may fix issues for people
that have around 100 or more hosts (or fewer hosts with multiple checked
ports).

tested by phessler@@
ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: check_tcp.c,v 1.37 2010/05/26 13:56:08 nicm Exp $	*/
a52 1
	int			 type;
a80 4
		goto bad;

	type = 1;
	if (setsockopt(s, SOL_SOCKET, SO_REUSEPORT, &type, sizeof(type)) == -1)
@


1.37
log
@Rename some imsg bits to make namespace collisions less likely buf to
ibuf, buf_read to ibuf_read, READ_BUF_SIZE to IBUF_READ_SIZE.

ok henning gilles claudio jacekm deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: check_tcp.c,v 1.36 2010/02/18 14:02:16 jsg Exp $	*/
d57 1
a57 1
	int			 he = HCE_TCP_CONNECT_ERROR;
d72 5
a76 1
	if ((s = socket(cte->host->conf.ss.ss_family, SOCK_STREAM, 0)) == -1)
d78 1
@


1.36
log
@Do an event_del before event_set/event_add in case we double add
something here as well.

ok claudio@@ phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: check_tcp.c,v 1.35 2009/08/07 11:10:23 reyk Exp $	*/
d179 1
a179 1
	if ((cte->buf = buf_dynamic(SMALL_READ_BUF_SIZE, UINT_MAX)) == NULL)
d214 1
a214 1
	if ((cte->buf = buf_dynamic(SMALL_READ_BUF_SIZE, UINT_MAX)) == NULL)
d234 1
a234 1
		buf_free(cte->buf);
d247 1
a247 1
		buf_free(cte->buf);
d255 1
a255 1
		buf_free(cte->buf);
d259 1
a259 1
		if (buf_add(cte->buf, rbuf, br) == -1)
d266 1
a266 1
			buf_free(cte->buf);
d285 1
a285 1
	b = buf_reserve(cte->buf, 1);
d317 1
a317 1
	b = buf_reserve(cte->buf, 1);
d369 1
a369 1
	b = buf_reserve(cte->buf, 1);
@


1.35
log
@allow to modify the IP TTL value for host checks.  this can be used to
check if the host is only n hops away and not re-routed over a longer
path.
@
text
@d1 1
a1 1
/*	$OpenBSD: check_tcp.c,v 1.34 2009/06/04 14:03:22 reyk Exp $	*/
d102 1
@


1.34
log
@tweak
@
text
@d1 1
a1 1
/*	$OpenBSD: check_tcp.c,v 1.33 2008/12/05 16:37:55 reyk Exp $	*/
d82 6
@


1.33
log
@change the way relayd reports check results: instead of logging an
arbitrary string in debugging mode, it will store an error code
(HCE_*) for each host.  the error code can be translated to a string
(in log.c) for debugging but it will also be passed to relayctl via
the control socket.

from a user point of view, this will print a human-readable error
message in the "relayctl show hosts" output if a host is down because
the check failed.  the relayctl(8) manpage includes detailed
explanations of the error messages including mitigations for the
most-common problems.

ok jmc@@ (manpages)
ok phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: check_tcp.c,v 1.32 2008/03/03 16:58:41 reyk Exp $	*/
d94 1
@


1.32
log
@log a different notification message when the tcp check times out.
also adjust the documentation a little bit to decrease confusion about
the check timeout.

From pyr@@
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: check_tcp.c,v 1.31 2007/12/07 17:17:00 reyk Exp $	*/
d57 1
d88 2
a89 1
		if (errno != EINPROGRESS)
d91 1
d102 1
a102 1
	hce_notify_done(cte->host, "check_tcp: cannot connect");
d115 1
a115 1
		hce_notify_done(cte->host, "tcp_write: connect timed out");
d125 1
a125 1
		hce_notify_done(cte->host, "tcp_write: connect failed");
d143 1
a143 1
		hce_notify_done(cte->host, "tcp_host_up: connect successful");
d187 1
a187 1
		hce_notify_done(cte->host, "tcp_send_req: timeout");
d199 1
a199 1
			hce_notify_done(cte->host, "tcp_send_req: write");
d228 1
a228 1
		hce_notify_done(cte->host, "tcp_read_buf: timeout");
d241 1
a241 1
		hce_notify_done(cte->host, "tcp_read_buf: read failed");
d248 1
a248 6
		if (cte->host->up == HOST_UP)
			hce_notify_done(cte->host,
			    "tcp_read_buf: check succeeded");
		else
			hce_notify_done(cte->host,
			    "tcp_read_buf: check failed");
d259 1
a259 6
			if (cte->host->up == HOST_UP)
				hce_notify_done(cte->host,
				    "tcp_read_buf: check succeeded");
			else
				hce_notify_done(cte->host,
				    "tcp_read_buf: check failed");
d282 1
d286 1
d316 2
d341 1
d343 2
a344 1
	} else
d346 1
d368 2
d383 1
d385 2
a386 1
	} else
d388 1
@


1.31
log
@hoststated gets renamed to relayd.  easier to type, and actually says
what the daemon does - it is a relayer that pays attention to the status
of pools of hosts; not a status checkers that happens to do some relaying
@
text
@d1 1
a1 1
/*	$OpenBSD: check_tcp.c,v 1.30 2007/11/24 17:07:28 reyk Exp $	*/
d110 1
a110 1
		log_debug("tcp_write: connect timed out");
d112 2
a113 8
	} else {
		len = sizeof(err);
		if (getsockopt(s, SOL_SOCKET, SO_ERROR, &err, &len))
			fatal("tcp_write: getsockopt");
		if (err != 0)
			cte->host->up = HOST_DOWN;
		else
			cte->host->up = HOST_UP;
d116 4
a119 3
	if (cte->host->up == HOST_UP)
		tcp_host_up(s, cte);
	else {
d121 1
d123 1
d125 3
@


1.30
log
@sort includes, adjust to style(9)
@
text
@d1 1
a1 1
/*	$OpenBSD: check_tcp.c,v 1.29 2007/11/21 20:13:20 reyk Exp $	*/
d38 1
a38 1
#include "hoststated.h"
@


1.29
log
@move digest string handling into an extra function.
@
text
@d1 1
a1 1
/*	$OpenBSD: check_tcp.c,v 1.28 2007/11/21 13:04:42 reyk Exp $	*/
d19 1
a19 1
#include <sys/types.h>
a21 1
#include <sys/param.h>
d23 1
a24 1
#include <net/if.h>
@


1.28
log
@allow the http digest type to be either SHA1 or MD5 determined by the
digest string length; it is compatible to any existing SHA1-only
configurations.

ok pyr@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: check_tcp.c,v 1.27 2007/11/19 15:20:18 reyk Exp $	*/
a35 1
#include <md5.h>
d377 1
a377 8
	switch (cte->table->conf.digest_type) {
	case DIGEST_SHA1:
		SHA1Data(head, strlen(head), digest);
		break;
	case DIGEST_MD5:
		MD5Data(head, strlen(head), digest);
		break;
	}
@


1.27
log
@knf (replace some ';;' with a single ';')
@
text
@d1 1
a1 1
/*	$OpenBSD: check_tcp.c,v 1.26 2007/09/28 13:29:56 pyr Exp $	*/
d36 1
d357 1
a357 1
	char		 digest[(SHA1_DIGEST_LENGTH*2)+1];
d377 9
a385 1
	SHA1Data(head, strlen(head), digest);
@


1.26
log
@Correct my mail address.
@
text
@d1 1
a1 1
/*	$OpenBSD: check_tcp.c,v 1.25 2007/06/07 14:17:33 pyr Exp $	*/
d148 1
a148 1
		cte->validate_read = NULL;;
d240 1
a240 1
		return;;
@


1.25
log
@always close sockets before calling hce_notify_done.
first spotted by Paulius Bulotas <paulius+openbsd-misc at devnull.lt>.
@
text
@d1 1
a1 1
/*	$OpenBSD: check_tcp.c,v 1.24 2007/05/27 20:53:10 pyr Exp $	*/
d4 1
a4 1
 * Copyright (c) 2006 Pierre-Yves Ritschard <pyr@@spootnik.org>
@


1.24
log
@Second step towards hoststated reload:
First split out hosts, tables and services into to structs, one that
contains the runtime fields and one (inside the runtime) that contains
mostly static fields that will be sent over the socket during reload.

Also move the demoted field of tables inside the flags field as its
just a boolean.
ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: check_tcp.c,v 1.23 2007/02/22 05:58:06 reyk Exp $	*/
d184 1
d196 1
d225 1
d238 1
@


1.23
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: check_tcp.c,v 1.22 2007/02/08 13:32:24 reyk Exp $	*/
d59 1
a59 1
	switch (cte->host->ss.ss_family) {
d61 2
a62 2
		((struct sockaddr_in *)&cte->host->ss)->sin_port =
			cte->table->port;
d65 2
a66 2
		((struct sockaddr_in6 *)&cte->host->ss)->sin6_port =
			cte->table->port;
d70 1
a70 1
	len = ((struct sockaddr *)&cte->host->ss)->sa_len;
d72 1
a72 1
	if ((s = socket(cte->host->ss.ss_family, SOCK_STREAM, 0)) == -1)
d86 2
a87 2
	bcopy(&cte->table->timeout, &tv, sizeof(tv));
	if (connect(s, (struct sockaddr *)&cte->host->ss, len) == -1) {
d136 1
a136 1
	switch (cte->table->check) {
d138 1
a138 1
		if (cte->table->flags & F_SSL)
d157 1
a157 1
	if (cte->table->flags & F_SSL) {
d165 1
a165 1
		    &cte->tv_start, &cte->table->timeout, cte);
d172 1
a172 1
	    &cte->tv_start, &cte->table->timeout, cte);
d205 1
a205 1
	    &cte->tv_start, &cte->table->timeout, cte);
d210 1
a210 1
	    &cte->tv_start, &cte->table->timeout, cte);
d270 1
a270 1
	    &cte->tv_start, &cte->table->timeout, cte);
d285 1
a285 1
	if (fnmatch(cte->table->exbuf, cte->buf->buf, 0) == 0) {
d321 1
a321 1
		    "(cannot parse HTTP version)", host->name);
d334 1
a334 1
		    "(cannot parse HTTP code)", host->name);
d338 1
a338 1
	if (code != cte->table->retcode) {
d340 1
a340 1
		    "(invalid HTTP code returned)", host->name);
d367 1
a367 1
		    "(no end of headers)", host->name);
d374 1
a374 1
	if (strcmp(cte->table->digest, digest)) {
d376 1
a376 1
		    "(wrong digest)", host->name);
@


1.22
log
@carefully check some return values and make lint happier.  never pass
any truncated strings (table names/anchors/tags/...) to pf and the
kernel.

ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: check_tcp.c,v 1.21 2007/02/07 15:13:00 reyk Exp $	*/
d179 2
a180 2
	int		 	 bs;
	int		 	 len;
d220 1
a220 1
        if (event == EV_TIMEOUT) {
@


1.21
log
@include the host name in log_debug() messages used by check_tcp read
callbacks.
@
text
@d1 1
a1 1
/*	$OpenBSD: check_tcp.c,v 1.20 2007/02/07 14:54:13 reyk Exp $	*/
d250 2
a251 1
		buf_add(cte->buf, rbuf, br);
d330 1
a330 1
	strlcpy(scode, head, sizeof(scode));
@


1.20
log
@another log_debug() removal ("nothing to write")
@
text
@d1 1
a1 1
/*	$OpenBSD: check_tcp.c,v 1.19 2007/02/07 14:45:12 reyk Exp $	*/
d305 1
d316 1
d319 3
a321 2
		log_debug("check_http_code: cannot parse HTTP version");
		cte->host->up = HOST_DOWN;
d326 1
a326 1
		cte->host->up = HOST_DOWN;
d332 3
a334 2
		log_debug("check_http_code: cannot parse HTTP code");
		cte->host->up = HOST_DOWN;
d338 3
a340 2
		log_debug("check_http_code: invalid HTTP code returned");
		cte->host->up = HOST_DOWN;
d342 2
a343 2
		cte->host->up = HOST_UP;
	return (!(cte->host->up == HOST_UP));
d349 4
a352 3
	char	*head;
	u_char	*b;
	char	 digest[(SHA1_DIGEST_LENGTH*2)+1];
d363 1
d365 3
a367 3
		log_debug("check_http_digest: host %u no end of headers",
		    cte->host->id);
		cte->host->up = HOST_DOWN;
d374 3
a376 3
		log_warnx("check_http_digest: wrong digest for host %u",
		    cte->host->id);
		cte->host->up = HOST_DOWN;
d378 2
a379 2
		cte->host->up = HOST_UP;
	return (!(cte->host->up == HOST_UP));
@


1.19
log
@more log_debug() cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: check_tcp.c,v 1.18 2007/02/07 14:39:45 reyk Exp $	*/
a168 1
	log_debug("tcp_host_up: nothing to write");
@


1.18
log
@remove superfluos log_debug() messages

ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: check_tcp.c,v 1.17 2007/02/06 10:27:33 reyk Exp $	*/
a252 1
			log_debug("calling check");
@


1.17
log
@update some more debug messages and fix typos. also remove some extra
debug noise from ssl.c.
@
text
@d1 1
a1 1
/*	$OpenBSD: check_tcp.c,v 1.16 2007/02/06 10:26:13 pyr Exp $	*/
a202 1
	log_debug("tcp_send_req: write done");
@


1.16
log
@now that check_http_code, check_http_digest and check_send_expect are
in check_tcp.c, prototype them in check_tcp.c
ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: check_tcp.c,v 1.15 2007/02/03 20:24:21 reyk Exp $	*/
d127 1
a127 1
		hce_notify_done(cte->host, "connect failed");
d141 1
a141 1
		hce_notify_done(cte->host, "tcp_host_up: connect successfull");
d245 2
a246 1
			hce_notify_done(cte->host, "check succeeded");
d248 2
a249 1
			hce_notify_done(cte->host, "check failed");
d261 2
a262 1
				hce_notify_done(cte->host, "check succeeded");
d264 2
a265 1
				hce_notify_done(cte->host, "check failed");
@


1.15
log
@merge tcp-based checks into one file, no functional changes

ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: check_tcp.c,v 1.14 2007/02/03 17:45:59 reyk Exp $	*/
d45 4
@


1.14
log
@remove debug message
@
text
@d1 1
a1 1
/*	$OpenBSD: check_tcp.c,v 1.13 2007/01/30 10:09:02 pyr Exp $	*/
d23 1
d26 1
d34 2
d265 103
@


1.13
log
@style changes.
ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: check_tcp.c,v 1.12 2007/01/29 14:23:31 pyr Exp $	*/
a220 1
	log_debug("reading");
@


1.12
log
@Add SSL support to hoststated.
with help and OK reyk@@
with help and advice by claudio@@ and Srebrenko Sehic
@
text
@d1 1
a1 1
/*	$OpenBSD: check_tcp.c,v 1.11 2007/01/20 16:32:10 pyr Exp $	*/
d82 3
a84 2
	} else
		cte->host->up = HOST_UP;
d224 2
a225 1
	if (br == -1) {
d231 2
a232 2
		return;
	} else if (br == 0) {
d242 6
a247 6
	}
	buf_add(cte->buf, rbuf, br);
	if (cte->validate_read != NULL) {
		log_debug("calling check");
		if (cte->validate_read(cte) != 0)
			goto retry;
d249 9
a257 7
		close(cte->s);
		buf_free(cte->buf);
		if (cte->host->up == HOST_UP)
			hce_notify_done(cte->host, "check succeeded");
		else
			hce_notify_done(cte->host, "check failed");
		return;
a261 1

@


1.11
log
@when retrying a write, the position was previously not updated.
ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: check_tcp.c,v 1.10 2007/01/12 16:43:01 pyr Exp $	*/
d33 2
d113 1
d129 2
d132 1
a132 1
		hce_notify_done(cte->host, "tcp_host_up: success");
d146 5
@


1.10
log
@eliminate duplicate tcp read/write code.
ok claudio@@, reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: check_tcp.c,v 1.9 2007/01/11 18:05:08 reyk Exp $	*/
a141 1
	cte->req = cte->table->sendbuf;
d144 1
a161 1
	int		 	 pos;
a168 1
	pos = 0;
d171 1
a171 1
		bs = write(s, cte->req + pos, len);
d180 1
a180 1
		pos += bs;
@


1.9
log
@use real async events for checks and improve the non-blocking socket
usage. also modify the check_icmp code to use non-blocking raw sockets
and merge the icmp4 and icmp6 functions. some other minor changes
while i'm here.

as discussed with pyr@@ claudio@@ deraadt@@
ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: check_tcp.c,v 1.8 2007/01/09 00:45:32 deraadt Exp $	*/
d36 3
a38 1
void	tcp_host_up(int s, struct ctl_tcp_event *);
d128 4
a132 1
	case CHECK_HTTP_CODE:
d134 2
a135 2
		event_again(&cte->ev, s, EV_TIMEOUT|EV_WRITE, send_http_request,
		    &cte->tv_start, &cte->table->timeout, cte);
d138 8
a145 1
		event_again(&cte->ev, s, EV_TIMEOUT|EV_WRITE, start_send_expect,
d147 99
a245 3
		break;
	default:
		fatalx("tcp_host_up: unhandled check type");
d247 4
@


1.8
log
@adapt to rename
@
text
@d1 1
a1 1
/*	$OpenBSD: check_tcp.c,v 1.7 2007/01/08 20:46:18 reyk Exp $	*/
d74 1
d78 1
a78 1
	} else {
d80 2
a81 5
		tcp_host_up(s, cte);
		return;
	}
	bcopy(&cte->table->timeout, &tv, sizeof(tv));
	event_once(s, EV_TIMEOUT|EV_WRITE, tcp_write, cte, &tv);
d83 1
d104 1
a104 1
		if (err)
d125 1
a125 1
		hce_notify_done(cte->host, "tcp_write: success");
d129 2
a130 1
		send_http_request(cte);
d133 2
a134 1
		start_send_expect(cte);
d137 1
a137 1
		fatalx("tcp_write: unhandled check type");
@


1.7
log
@do NOT use the regexp interface. it is way to complicated, error-prone
and we don't know about all the possible security problems.

change the check send/expect code to use the fnmatch(3) interface
using shell globbing rules instead. this allows simple patterns like
"220 * ESMTP*" or "SSH-[12].??-*".

suggested by deraadt@@ and otto@@
ok Pierre-Yves Ritschard (pyr at spootnik dot org)
@
text
@d1 1
a1 1
/*	$OpenBSD: check_tcp.c,v 1.6 2007/01/08 17:10:23 reyk Exp $	*/
d33 1
a33 1
#include "hostated.h"
@


1.6
log
@allow to use service names in addition to numerical port numbers in
the configuration file, eg. "real port http".

> From Pierre-Yves Ritschard (pyr at spootnik dot org)

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: check_tcp.c,v 1.5 2007/01/08 13:37:26 reyk Exp $	*/
a31 1
#include <regex.h>
@


1.5
log
@add a generic send/expect check using regular expression (see
regex(3)).  this allows to define additional checks for other TCP
protocols.

From Pierre-Yves Ritschard (pyr at spootnik dot org)
@
text
@d1 1
a1 1
/*	$OpenBSD: check_tcp.c,v 1.4 2006/12/25 19:05:41 reyk Exp $	*/
d51 1
a51 1
			htons(cte->table->port);
d55 1
a55 1
			htons(cte->table->port);
@


1.4
log
@fix the conversion from milliseconds to struct timeval, which uses
seconds (tv_sec) and microseconds (tv_usec), but the code assumed
seconds and milliseconds...
@
text
@d1 1
a1 1
/*	$OpenBSD: check_tcp.c,v 1.3 2006/12/25 18:12:14 reyk Exp $	*/
d32 1
d122 2
d132 3
@


1.3
log
@partial rewrite of the check_* routines to use libevent everywhere
instead of nested select() calls and to handle the non-blocking
sockets properly.

From Pierre-Yves Ritschard (pyr at spootnik dot org)
(with a little help by me)
@
text
@d1 1
a1 1
/*	$OpenBSD: check_tcp.c,v 1.2 2006/12/16 12:42:14 reyk Exp $	*/
d82 1
a82 2
	tv.tv_sec = cte->table->timeout / 1000;
	tv.tv_usec = cte->table->timeout % 1000;
@


1.2
log
@knf, spacing

please note that some editors will replace tabs with multiple spaces
if you cut & paste code from other sections.  please try to keep the
tabs ;).
@
text
@d1 1
a1 1
/*	$OpenBSD: check_tcp.c,v 1.1 2006/12/16 11:45:07 reyk Exp $	*/
d30 1
d35 2
a36 10
int
check_tcp(struct host *host, struct table *table)
{
	int	sock;

	if ((sock = tcp_connect(host, table)) <= 0)
		return (sock);
	close(sock);
	return (HOST_UP);
}
d38 2
a39 2
int
tcp_connect(struct host *host, struct table *table)
d41 5
a45 5
	int		s;
	socklen_t	len;
	struct timeval	tv;
	struct sockaddr	sa;
	fd_set		fdset;
d47 1
a47 1
	switch (host->ss.ss_family) {
d49 2
a50 2
		((struct sockaddr_in *)&host->ss)->sin_port =
			htons(table->port);
d53 2
a54 2
		((struct sockaddr_in6 *)&host->ss)->sin6_port =
			htons(table->port);
d58 4
a61 1
	len = ((struct sockaddr *)&host->ss)->sa_len;
d63 7
a69 2
	if ((s = socket(host->ss.ss_family, SOCK_STREAM, 0)) == -1)
		fatal("check_tcp: cannot create socket");
d72 1
a72 1
		fatal("check_tcp: cannot set non blocking socket");
d74 34
a107 18
	if (connect(s, (struct sockaddr *)&host->ss, len) == -1) {
		if (errno != EINPROGRESS && errno != EWOULDBLOCK) {
			close(s);
			return (HOST_DOWN);
		}
	} else
		return (s);

	tv.tv_sec = table->timeout / 1000;
	tv.tv_usec = table->timeout % 1000;
	FD_ZERO(&fdset);
	FD_SET(s, &fdset);

	/* XXX This needs to be rewritten */
	switch (select(s + 1, NULL, &fdset, NULL, &tv)) {
	case -1:
		if (errno != EINTR)
			fatal("check_tcp: select");
d109 15
a123 2
			return (HOST_UNKNOWN);
	case 0:
d125 6
a130 1
		return (HOST_DOWN);
d132 1
a132 11
		if (getpeername(s, &sa, &len) == -1) {
			if (errno == ENOTCONN) {
				close(s);
				return (HOST_DOWN);
			} else {
				log_debug("check_tcp: unknown peername");
				close(s);
				return (HOST_UNKNOWN);
			}
		} else
			return (s);
a133 1
	return (HOST_UNKNOWN);
@


1.1
log
@Import hostated, the host status daemon.  This daemon will monitor
remote hosts and dynamically alter pf(4) tables and redirection rules
for active server load balancing.  The daemon has been written by
Pierre-Yves Ritschard (pyr at spootnik.org) and was formerly known as
"slbd".

The daemon is fully functional but it still needs some work and
cleanup so we don't link it to the build yet.  Some TODOs are a
partial rewrite of the check_* routines (use libevent whenever we
can), improvement of the manpages, and general knf and cleanup.

ok deraadt@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d86 2
a87 1
	switch(select(s + 1, NULL, &fdset, NULL, &tv)) {
d92 1
a92 1
			return(HOST_UNKNOWN);
@

