head	1.33;
access;
symbols
	OPENBSD_6_2:1.33.0.4
	OPENBSD_6_2_BASE:1.33
	OPENBSD_6_1:1.31.0.4
	OPENBSD_6_1_BASE:1.31
	OPENBSD_6_0:1.27.0.4
	OPENBSD_6_0_BASE:1.27
	OPENBSD_5_9:1.27.0.2
	OPENBSD_5_9_BASE:1.27
	OPENBSD_5_8:1.25.0.4
	OPENBSD_5_8_BASE:1.25
	OPENBSD_5_7:1.24.0.2
	OPENBSD_5_7_BASE:1.24
	OPENBSD_5_6:1.18.0.4
	OPENBSD_5_6_BASE:1.18
	OPENBSD_5_5:1.11.0.4
	OPENBSD_5_5_BASE:1.11
	OPENBSD_5_4:1.9.0.2
	OPENBSD_5_4_BASE:1.9
	OPENBSD_5_3:1.8.0.2
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.3.0.2
	OPENBSD_5_2_BASE:1.3
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.4
	OPENBSD_5_0:1.2.0.2
	OPENBSD_5_0_BASE:1.2;
locks; strict;
comment	@ * @;


1.33
date	2017.09.14.08.59.54;	author jsg;	state Exp;
branches;
next	1.32;
commitid	9MPtBtAMCVKjqRu4;

1.32
date	2017.05.27.08.33.25;	author claudio;	state Exp;
branches;
next	1.31;
commitid	mLnU8nnW1ZLoAWRU;

1.31
date	2016.11.24.21.01.18;	author reyk;	state Exp;
branches;
next	1.30;
commitid	FkVuQgzULddApn9S;

1.30
date	2016.09.02.14.45.51;	author reyk;	state Exp;
branches;
next	1.29;
commitid	vcV98N2DyJGMwDyQ;

1.29
date	2016.09.02.13.09.21;	author reyk;	state Exp;
branches;
next	1.28;
commitid	9S8GybYLw7qfCiW0;

1.28
date	2016.09.01.10.49.48;	author claudio;	state Exp;
branches;
next	1.27;
commitid	kVeSpNYKmzM2uO33;

1.27
date	2015.12.07.04.03.27;	author mmcc;	state Exp;
branches;
next	1.26;
commitid	vlUffo7boyCTPJEr;

1.26
date	2015.12.02.13.41.27;	author reyk;	state Exp;
branches;
next	1.25;
commitid	vBNcEM4jmO1KceIa;

1.25
date	2015.05.02.13.15.24;	author claudio;	state Exp;
branches;
next	1.24;
commitid	KeIVSkhMPmj3B0K2;

1.24
date	2015.01.22.17.42.09;	author reyk;	state Exp;
branches
	1.24.2.1;
next	1.23;
commitid	puppem00jmzmdm4f;

1.23
date	2015.01.21.21.50.33;	author deraadt;	state Exp;
branches;
next	1.22;
commitid	3o2AkhiRPQXvG94X;

1.22
date	2014.12.21.00.54.49;	author guenther;	state Exp;
branches;
next	1.21;
commitid	XnjIOhurXdX5o1V9;

1.21
date	2014.12.12.10.05.09;	author reyk;	state Exp;
branches;
next	1.20;
commitid	J8g0vRzthwLCqf68;

1.20
date	2014.11.22.00.24.22;	author tedu;	state Exp;
branches;
next	1.19;
commitid	zQJPNUJ5J7GRL1zG;

1.19
date	2014.11.19.10.24.40;	author blambert;	state Exp;
branches;
next	1.18;
commitid	EGrSQMGI27r3h8Vf;

1.18
date	2014.07.11.16.59.38;	author reyk;	state Exp;
branches;
next	1.17;
commitid	For422J6VfsgvmL6;

1.17
date	2014.07.11.11.48.50;	author reyk;	state Exp;
branches;
next	1.16;
commitid	6F05OKHLwEQdKZuE;

1.16
date	2014.07.09.23.30.34;	author reyk;	state Exp;
branches;
next	1.15;
commitid	1JxsvIoa2CNRnoFA;

1.15
date	2014.07.09.16.42.05;	author reyk;	state Exp;
branches;
next	1.14;
commitid	YhQvyAop4vC3AmzJ;

1.14
date	2014.05.04.16.38.19;	author reyk;	state Exp;
branches;
next	1.13;

1.13
date	2014.04.22.08.04.23;	author reyk;	state Exp;
branches;
next	1.12;

1.12
date	2014.04.18.13.55.26;	author reyk;	state Exp;
branches;
next	1.11;

1.11
date	2014.02.24.06.55.11;	author jsg;	state Exp;
branches;
next	1.10;

1.10
date	2013.09.09.17.57.44;	author reyk;	state Exp;
branches;
next	1.9;

1.9
date	2013.05.30.20.17.12;	author reyk;	state Exp;
branches;
next	1.8;

1.8
date	2012.12.18.15.57.16;	author reyk;	state Exp;
branches;
next	1.7;

1.7
date	2012.11.27.05.00.28;	author guenther;	state Exp;
branches;
next	1.6;

1.6
date	2012.10.04.20.53.30;	author reyk;	state Exp;
branches;
next	1.5;

1.5
date	2012.10.03.08.40.40;	author reyk;	state Exp;
branches;
next	1.4;

1.4
date	2012.10.03.08.33.31;	author reyk;	state Exp;
branches;
next	1.3;

1.3
date	2012.05.08.15.10.15;	author benno;	state Exp;
branches;
next	1.2;

1.2
date	2011.05.19.09.13.07;	author reyk;	state Exp;
branches;
next	1.1;

1.1
date	2011.05.19.08.56.49;	author reyk;	state Exp;
branches;
next	;

1.24.2.1
date	2015.09.20.11.20.16;	author benno;	state Exp;
branches;
next	;
commitid	C9WQyjgbN7h0ioOp;


desc
@@


1.33
log
@Differentiate between a style string not being specified and an empty
style string by including NUL in imsg and set the pointer in the struct
passed over imsg to NULL in the receiving process to be sure nothing
tries to use it.

Avoids a crash when specifying an empty style string reported by
Karl-Andre' Skevik.  ok bluhm@@
@
text
@/*	$OpenBSD: config.c,v 1.32 2017/05/27 08:33:25 claudio Exp $	*/

/*
 * Copyright (c) 2011 - 2014 Reyk Floeter <reyk@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/queue.h>
#include <sys/time.h>
#include <sys/uio.h>

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <limits.h>
#include <string.h>
#include <imsg.h>

#include "relayd.h"

int
config_init(struct relayd *env)
{
	struct privsep	*ps = env->sc_ps;
	u_int		 what;

	/* Global configuration */
	if (privsep_process == PROC_PARENT) {
		env->sc_conf.timeout.tv_sec = CHECK_TIMEOUT / 1000;
		env->sc_conf.timeout.tv_usec = (CHECK_TIMEOUT % 1000) * 1000;
		env->sc_conf.interval.tv_sec = CHECK_INTERVAL;
		env->sc_conf.interval.tv_usec = 0;
		env->sc_conf.prefork_relay = RELAY_NUMPROC;
		env->sc_conf.statinterval.tv_sec = RELAY_STATINTERVAL;
	}

	ps->ps_what[PROC_PARENT] = CONFIG_ALL;
	ps->ps_what[PROC_PFE] = CONFIG_ALL & ~CONFIG_PROTOS;
	ps->ps_what[PROC_HCE] = CONFIG_TABLES;
	ps->ps_what[PROC_CA] = CONFIG_RELAYS;
	ps->ps_what[PROC_RELAY] = CONFIG_RELAYS|
	    CONFIG_TABLES|CONFIG_PROTOS|CONFIG_CA_ENGINE;

	/* Other configuration */
	what = ps->ps_what[privsep_process];
	if (what & CONFIG_TABLES) {
		if ((env->sc_tables =
		    calloc(1, sizeof(*env->sc_tables))) == NULL)
			return (-1);
		TAILQ_INIT(env->sc_tables);

		memset(&env->sc_empty_table, 0, sizeof(env->sc_empty_table));
		env->sc_empty_table.conf.id = EMPTY_TABLE;
		env->sc_empty_table.conf.flags |= F_DISABLE;
		(void)strlcpy(env->sc_empty_table.conf.name, "empty",
		    sizeof(env->sc_empty_table.conf.name));

	}
	if (what & CONFIG_RDRS) {
		if ((env->sc_rdrs =
		    calloc(1, sizeof(*env->sc_rdrs))) == NULL)
			return (-1);
		TAILQ_INIT(env->sc_rdrs);

	}
	if (what & CONFIG_RELAYS) {
		if ((env->sc_relays =
		    calloc(1, sizeof(*env->sc_relays))) == NULL)
			return (-1);
		TAILQ_INIT(env->sc_relays);
		if ((env->sc_pkeys =
		    calloc(1, sizeof(*env->sc_pkeys))) == NULL)
			return (-1);
		TAILQ_INIT(env->sc_pkeys);
	}
	if (what & CONFIG_PROTOS) {
		if ((env->sc_protos =
		    calloc(1, sizeof(*env->sc_protos))) == NULL)
			return (-1);
		TAILQ_INIT(env->sc_protos);

		bzero(&env->sc_proto_default, sizeof(env->sc_proto_default));
		env->sc_proto_default.id = EMPTY_ID;
		env->sc_proto_default.flags = F_USED;
		env->sc_proto_default.tcpflags = TCPFLAG_DEFAULT;
		env->sc_proto_default.tcpbacklog = RELAY_BACKLOG;
		env->sc_proto_default.tlsflags = TLSFLAG_DEFAULT;
		(void)strlcpy(env->sc_proto_default.tlsciphers,
		    TLSCIPHERS_DEFAULT,
		    sizeof(env->sc_proto_default.tlsciphers));
		(void)strlcpy(env->sc_proto_default.tlsecdhcurve,
		    TLSECDHCURVE_DEFAULT,
		    sizeof(env->sc_proto_default.tlsecdhcurve));
		(void)strlcpy(env->sc_proto_default.tlsdhparams,
		    TLSDHPARAM_DEFAULT,
		    sizeof(env->sc_proto_default.tlsdhparams));
		env->sc_proto_default.type = RELAY_PROTO_TCP;
		(void)strlcpy(env->sc_proto_default.name, "default",
		    sizeof(env->sc_proto_default.name));
	}
	if (what & CONFIG_RTS) {
		if ((env->sc_rts =
		    calloc(1, sizeof(*env->sc_rts))) == NULL)
			return (-1);
		TAILQ_INIT(env->sc_rts);
	}
	if (what & CONFIG_ROUTES) {
		if ((env->sc_routes =
		    calloc(1, sizeof(*env->sc_routes))) == NULL)
			return (-1);
		TAILQ_INIT(env->sc_routes);
	}

	return (0);
}

void
config_purge(struct relayd *env, u_int reset)
{
	struct privsep		*ps = env->sc_ps;
	struct table		*table;
	struct rdr		*rdr;
	struct address		*virt;
	struct protocol		*proto;
	struct relay_rule	*rule;
	struct relay		*rlay;
	struct netroute		*nr;
	struct router		*rt;
	struct ca_pkey		*pkey;
	u_int			 what;

	what = ps->ps_what[privsep_process] & reset;

	if (what & CONFIG_TABLES && env->sc_tables != NULL) {
		while ((table = TAILQ_FIRST(env->sc_tables)) != NULL)
			purge_table(env, env->sc_tables, table);
		env->sc_tablecount = 0;
	}
	if (what & CONFIG_RDRS && env->sc_rdrs != NULL) {
		while ((rdr = TAILQ_FIRST(env->sc_rdrs)) != NULL) {
			TAILQ_REMOVE(env->sc_rdrs, rdr, entry);
			while ((virt = TAILQ_FIRST(&rdr->virts)) != NULL) {
				TAILQ_REMOVE(&rdr->virts, virt, entry);
				free(virt);
			}
			free(rdr);
		}
		env->sc_rdrcount = 0;
	}
	if (what & CONFIG_RELAYS && env->sc_pkeys != NULL) {
		while ((pkey = TAILQ_FIRST(env->sc_pkeys)) != NULL) {
			TAILQ_REMOVE(env->sc_pkeys, pkey, pkey_entry);
			free(pkey);
		}
	}
	if (what & CONFIG_RELAYS && env->sc_relays != NULL) {
		while ((rlay = TAILQ_FIRST(env->sc_relays)) != NULL)
			purge_relay(env, rlay);
		env->sc_relaycount = 0;
	}
	if (what & CONFIG_PROTOS && env->sc_protos != NULL) {
		while ((proto = TAILQ_FIRST(env->sc_protos)) != NULL) {
			TAILQ_REMOVE(env->sc_protos, proto, entry);
			while ((rule = TAILQ_FIRST(&proto->rules)) != NULL)
				rule_delete(&proto->rules, rule);
			proto->rulecount = 0;
		}
	}
	if (what & CONFIG_PROTOS && env->sc_protos != NULL) {
		while ((proto = TAILQ_FIRST(env->sc_protos)) != NULL) {
			TAILQ_REMOVE(env->sc_protos, proto, entry);
			free(proto->style);
			free(proto->tlscapass);
			free(proto);
		}
		env->sc_protocount = 0;
	}
	if (what & CONFIG_RTS && env->sc_rts != NULL) {
		while ((rt = TAILQ_FIRST(env->sc_rts)) != NULL) {
			TAILQ_REMOVE(env->sc_rts, rt, rt_entry);
			while ((nr = TAILQ_FIRST(&rt->rt_netroutes)) != NULL) {
				TAILQ_REMOVE(&rt->rt_netroutes, nr, nr_entry);
				TAILQ_REMOVE(env->sc_routes, nr, nr_route);
				free(nr);
				env->sc_routecount--;
			}
			free(rt);
		}
		env->sc_routercount = 0;
	}
	if (what & CONFIG_ROUTES && env->sc_routes != NULL) {
		while ((nr = TAILQ_FIRST(env->sc_routes)) != NULL) {
			if ((rt = nr->nr_router) != NULL)
				TAILQ_REMOVE(&rt->rt_netroutes, nr, nr_entry);
			TAILQ_REMOVE(env->sc_routes, nr, nr_route);
			free(nr);
		}
		env->sc_routecount = 0;
	}
}

int
config_setreset(struct relayd *env, u_int reset)
{
	struct privsep	*ps = env->sc_ps;
	int		 id;

	for (id = 0; id < PROC_MAX; id++) {
		if ((reset & ps->ps_what[id]) == 0 ||
		    id == privsep_process)
			continue;
		proc_compose(ps, id, IMSG_CTL_RESET, &reset, sizeof(reset));
	}

	return (0);
}

int
config_getreset(struct relayd *env, struct imsg *imsg)
{
	u_int		 mode;

	IMSG_SIZE_CHECK(imsg, &mode);
	memcpy(&mode, imsg->data, sizeof(mode));

	config_purge(env, mode);

	return (0);
}

int
config_getcfg(struct relayd *env, struct imsg *imsg)
{
	struct privsep		*ps = env->sc_ps;
	struct table		*tb;
	struct host		*h, *ph;
	u_int			 what;

	if (IMSG_DATA_SIZE(imsg) != sizeof(struct relayd_config))
		return (0); /* ignore */

	/* Update runtime flags */
	memcpy(&env->sc_conf, imsg->data, sizeof(env->sc_conf));

	what = ps->ps_what[privsep_process];

	if (what & CONFIG_TABLES) {
		/* Update the tables */
		TAILQ_FOREACH(tb, env->sc_tables, entry) {
			TAILQ_FOREACH(h, &tb->hosts, entry) {
				if (h->conf.parentid && (ph = host_find(env,
				    h->conf.parentid)) != NULL) {
					SLIST_INSERT_HEAD(&ph->children,
					    h, child);
				}
			}
		}
	}

	if (env->sc_conf.flags & (F_TLS|F_TLSCLIENT)) {
		ssl_init(env);
		if (what & CONFIG_CA_ENGINE)
			ca_engine_init(env);
		if (tls_init() == -1)
			fatalx("unable to initialize TLS");
	}

	if (privsep_process != PROC_PARENT)
		proc_compose(env->sc_ps, PROC_PARENT, IMSG_CFG_DONE, NULL, 0);

	return (0);
}

int
config_settable(struct relayd *env, struct table *tb)
{
	struct privsep	*ps = env->sc_ps;
	struct host	*host;
	int		 id, c;
	struct iovec	 iov[2];

	for (id = 0; id < PROC_MAX; id++) {
		if ((ps->ps_what[id] & CONFIG_TABLES) == 0 ||
		    id == privsep_process)
			continue;

		/* XXX need to send table to pfe for control socket */
		if (id == PROC_HCE && tb->conf.check == CHECK_NOCHECK)
			continue;

		DPRINTF("%s: sending table %s %d to %s", __func__,
		    tb->conf.name, tb->conf.id, env->sc_ps->ps_title[id]);

		c = 0;
		iov[c].iov_base = &tb->conf;
		iov[c++].iov_len = sizeof(tb->conf);
		if (tb->sendbuf != NULL) {
			iov[c].iov_base = tb->sendbuf;
			iov[c++].iov_len = strlen(tb->sendbuf);
		}

		proc_composev(ps, id, IMSG_CFG_TABLE, iov, c);

		TAILQ_FOREACH(host, &tb->hosts, entry) {
			proc_compose(ps, id, IMSG_CFG_HOST,
			    &host->conf, sizeof(host->conf));
		}
	}

	return (0);
}

int
config_gettable(struct relayd *env, struct imsg *imsg)
{
	struct table		*tb;
	size_t			 sb;
	u_int8_t		*p = imsg->data;
	size_t			 s;

	if ((tb = calloc(1, sizeof(*tb))) == NULL)
		return (-1);

	IMSG_SIZE_CHECK(imsg, &tb->conf);
	memcpy(&tb->conf, p, sizeof(tb->conf));
	s = sizeof(tb->conf);

	sb = IMSG_DATA_SIZE(imsg) - s;
	if (sb > 0) {
		if ((tb->sendbuf = get_string(p + s, sb)) == NULL) {
			free(tb);
			return (-1);
		}
	}

	TAILQ_INIT(&tb->hosts);
	TAILQ_INSERT_TAIL(env->sc_tables, tb, entry);

	env->sc_tablecount++;

	DPRINTF("%s: %s %d received table %d (%s)", __func__,
	    env->sc_ps->ps_title[privsep_process], env->sc_ps->ps_instance,
	    tb->conf.id, tb->conf.name);

	return (0);
}

int
config_gethost(struct relayd *env, struct imsg *imsg)
{
	struct table		*tb;
	struct host		*host;

	if ((host = calloc(1, sizeof(*host))) == NULL)
		return (-1);

	IMSG_SIZE_CHECK(imsg, &host->conf);
	memcpy(&host->conf, imsg->data, sizeof(host->conf));

	if (host_find(env, host->conf.id) != NULL) {
		log_debug("%s: host %d already exists",
		    __func__, host->conf.id);
		free(host);
		return (-1);
	}

	if ((tb = table_find(env, host->conf.tableid)) == NULL) {
		log_debug("%s: "
		    "received host for unknown table %d", __func__,
		    host->conf.tableid);
		free(host);
		return (-1);
	}

	host->tablename = tb->conf.name;
	host->cte.s = -1;

	SLIST_INIT(&host->children);
	TAILQ_INSERT_TAIL(&tb->hosts, host, entry);
	TAILQ_INSERT_TAIL(&env->sc_hosts, host, globalentry);

	DPRINTF("%s: %s %d received host %s for table %s", __func__,
	    env->sc_ps->ps_title[privsep_process], env->sc_ps->ps_instance,
	    host->conf.name, tb->conf.name);

	return (0);
}

int
config_setrdr(struct relayd *env, struct rdr *rdr)
{
	struct privsep	*ps = env->sc_ps;
	struct address	*virt;
	int		 id;

	for (id = 0; id < PROC_MAX; id++) {
		if ((ps->ps_what[id] & CONFIG_RDRS) == 0 ||
		    id == privsep_process)
			continue;

		DPRINTF("%s: sending rdr %s to %s", __func__,
		    rdr->conf.name, ps->ps_title[id]);

		proc_compose(ps, id, IMSG_CFG_RDR,
		    &rdr->conf, sizeof(rdr->conf));

		TAILQ_FOREACH(virt, &rdr->virts, entry) {
			virt->rdrid = rdr->conf.id;
			proc_compose(ps, id, IMSG_CFG_VIRT,
			    virt, sizeof(*virt));
		}
	}

	return (0);
}

int
config_getrdr(struct relayd *env, struct imsg *imsg)
{
	struct rdr		*rdr;

	if ((rdr = calloc(1, sizeof(*rdr))) == NULL)
		return (-1);

	IMSG_SIZE_CHECK(imsg, &rdr->conf);
	memcpy(&rdr->conf, imsg->data, sizeof(rdr->conf));

	if ((rdr->table = table_find(env, rdr->conf.table_id)) == NULL) {
		log_debug("%s: table not found", __func__);
		free(rdr);
		return (-1);
	}
	if ((rdr->backup = table_find(env, rdr->conf.backup_id)) == NULL) {
		rdr->conf.backup_id = EMPTY_TABLE;
		rdr->backup = &env->sc_empty_table;
	}

	TAILQ_INIT(&rdr->virts);
	TAILQ_INSERT_TAIL(env->sc_rdrs, rdr, entry);

	env->sc_rdrcount++;

	DPRINTF("%s: %s %d received rdr %s", __func__,
	    env->sc_ps->ps_title[privsep_process], env->sc_ps->ps_instance,
	    rdr->conf.name);

	return (0);
}

int
config_getvirt(struct relayd *env, struct imsg *imsg)
{
	struct rdr	*rdr;
	struct address	*virt;

	IMSG_SIZE_CHECK(imsg, virt);

	if ((virt = calloc(1, sizeof(*virt))) == NULL)
		return (-1);
	memcpy(virt, imsg->data, sizeof(*virt));

	if ((rdr = rdr_find(env, virt->rdrid)) == NULL) {
		log_debug("%s: rdr not found", __func__);
		free(virt);
		return (-1);
	}

	TAILQ_INSERT_TAIL(&rdr->virts, virt, entry);

	DPRINTF("%s: %s %d received address for rdr %s", __func__,
	    env->sc_ps->ps_title[privsep_process], env->sc_ps->ps_instance,
	    rdr->conf.name);

	return (0);
}

int
config_setrt(struct relayd *env, struct router *rt)
{
	struct privsep	*ps = env->sc_ps;
	struct netroute	*nr;
	int		 id;

	for (id = 0; id < PROC_MAX; id++) {
		if ((ps->ps_what[id] & CONFIG_RTS) == 0 ||
		    id == privsep_process)
			continue;

		DPRINTF("%s: sending router %s to %s tbl %d", __func__,
		    rt->rt_conf.name, ps->ps_title[id], rt->rt_conf.gwtable);

		proc_compose(ps, id, IMSG_CFG_ROUTER,
		    &rt->rt_conf, sizeof(rt->rt_conf));

		TAILQ_FOREACH(nr, &rt->rt_netroutes, nr_entry) {
			proc_compose(ps, id, IMSG_CFG_ROUTE,
			    &nr->nr_conf, sizeof(nr->nr_conf));
		}
	}

	return (0);
}

int
config_getrt(struct relayd *env, struct imsg *imsg)
{
	struct router		*rt;

	if ((rt = calloc(1, sizeof(*rt))) == NULL)
		return (-1);

	IMSG_SIZE_CHECK(imsg, &rt->rt_conf);
	memcpy(&rt->rt_conf, imsg->data, sizeof(rt->rt_conf));

	if ((rt->rt_gwtable = table_find(env, rt->rt_conf.gwtable)) == NULL) {
		log_debug("%s: table not found", __func__);
		free(rt);
		return (-1);
	}

	TAILQ_INIT(&rt->rt_netroutes);
	TAILQ_INSERT_TAIL(env->sc_rts, rt, rt_entry);

	env->sc_routercount++;

	DPRINTF("%s: %s %d received router %s", __func__,
	    env->sc_ps->ps_title[privsep_process], env->sc_ps->ps_instance,
	    rt->rt_conf.name);

	return (0);
}

int
config_getroute(struct relayd *env, struct imsg *imsg)
{
	struct router		*rt;
	struct netroute		*nr;

	if ((nr = calloc(1, sizeof(*nr))) == NULL)
		return (-1);

	IMSG_SIZE_CHECK(imsg, &nr->nr_conf);
	memcpy(&nr->nr_conf, imsg->data, sizeof(nr->nr_conf));

	if (route_find(env, nr->nr_conf.id) != NULL) {
		log_debug("%s: route %d already exists",
		    __func__, nr->nr_conf.id);
		free(nr);
		return (-1);
	}

	if ((rt = router_find(env, nr->nr_conf.routerid)) == NULL) {
		log_debug("%s: received route for unknown router", __func__);
		free(nr);
		return (-1);
	}

	nr->nr_router = rt;

	TAILQ_INSERT_TAIL(env->sc_routes, nr, nr_route);
	TAILQ_INSERT_TAIL(&rt->rt_netroutes, nr, nr_entry);

	env->sc_routecount++;

	DPRINTF("%s: %s %d received route %d for router %s", __func__,
	    env->sc_ps->ps_title[privsep_process], env->sc_ps->ps_instance,
	    nr->nr_conf.id, rt->rt_conf.name);

	return (0);
}

int
config_setproto(struct relayd *env, struct protocol *proto)
{
	struct privsep		*ps = env->sc_ps;
	int			 id;
	struct iovec		 iov[IOV_MAX];
	size_t			 c;

	for (id = 0; id < PROC_MAX; id++) {
		if ((ps->ps_what[id] & CONFIG_PROTOS) == 0 ||
		    id == privsep_process)
			continue;

		DPRINTF("%s: sending protocol %s to %s", __func__,
		    proto->name, ps->ps_title[id]);

		c = 0;
		iov[c].iov_base = proto;
		iov[c++].iov_len = sizeof(*proto);

		if (proto->style != NULL) {
			iov[c].iov_base = proto->style;
			iov[c++].iov_len = strlen(proto->style) + 1;
		}

		proc_composev(ps, id, IMSG_CFG_PROTO, iov, c);
	}

	return (0);
}

int
config_setrule(struct relayd *env, struct protocol *proto)
{
	struct privsep		*ps = env->sc_ps;
	struct relay_rule	*rule;
	struct iovec		 iov[IOV_MAX];
	int			 id;
	size_t			 c, i;

	for (id = 0; id < PROC_MAX; id++) {
		if ((ps->ps_what[id] & CONFIG_PROTOS) == 0 ||
		    id == privsep_process)
			continue;

		DPRINTF("%s: sending rules %s to %s", __func__,
		    proto->name, ps->ps_title[id]);

		/* Now send all the rules */
		TAILQ_FOREACH(rule, &proto->rules, rule_entry) {
			rule->rule_protoid = proto->id;
			bzero(&rule->rule_ctl, sizeof(rule->rule_ctl));
			c = 0;
			iov[c].iov_base = rule;
			iov[c++].iov_len = sizeof(*rule);
			for (i = 1; i < KEY_TYPE_MAX; i++) {
				if (rule->rule_kv[i].kv_key != NULL) {
					rule->rule_ctl.kvlen[i].key =
					    strlen(rule->rule_kv[i].kv_key);
					iov[c].iov_base =
					    rule->rule_kv[i].kv_key;
					iov[c++].iov_len =
					    rule->rule_ctl.kvlen[i].key;
				} else
					rule->rule_ctl.kvlen[i].key = -1;
				if (rule->rule_kv[i].kv_value != NULL) {
					rule->rule_ctl.kvlen[i].value =
					    strlen(rule->rule_kv[i].kv_value);
					iov[c].iov_base =
					    rule->rule_kv[i].kv_value;
					iov[c++].iov_len =
					    rule->rule_ctl.kvlen[i].value;
				} else
					rule->rule_ctl.kvlen[i].value = -1;
			}

			proc_composev(ps, id, IMSG_CFG_RULE, iov, c);
		}
	}

	return (0);
}

int
config_getproto(struct relayd *env, struct imsg *imsg)
{
	struct protocol		*proto;
	size_t			 styl;
	size_t			 s;
	u_int8_t		*p = imsg->data;

	if ((proto = calloc(1, sizeof(*proto))) == NULL)
		return (-1);

	IMSG_SIZE_CHECK(imsg, proto);
	memcpy(proto, p, sizeof(*proto));
	s = sizeof(*proto);

	styl = IMSG_DATA_SIZE(imsg) - s;
	proto->style = NULL;
	if (styl > 0) {
		if ((proto->style = get_string(p + s, styl - 1)) == NULL) {
			free(proto);
			return (-1);
		}
	}

	TAILQ_INIT(&proto->rules);
	proto->tlscapass = NULL;

	TAILQ_INSERT_TAIL(env->sc_protos, proto, entry);

	env->sc_protocount++;

	DPRINTF("%s: %s %d received protocol %s", __func__,
	    env->sc_ps->ps_title[privsep_process], env->sc_ps->ps_instance,
	    proto->name);

	return (0);
}

int
config_getrule(struct relayd *env, struct imsg *imsg)
{
	struct protocol		*proto;
	struct relay_rule	*rule;
	size_t			 s, i;
	u_int8_t		*p = imsg->data;
	ssize_t			 len;

	if ((rule = calloc(1, sizeof(*rule))) == NULL)
		return (-1);

	IMSG_SIZE_CHECK(imsg, rule);
	memcpy(rule, p, sizeof(*rule));
	s = sizeof(*rule);
	len = IMSG_DATA_SIZE(imsg) - s;

	if ((proto = proto_find(env, rule->rule_protoid)) == NULL) {
		free(rule);
		return (-1);
	}

#define GETKV(_n, _f)	{						\
	if (rule->rule_ctl.kvlen[_n]._f >= 0) {				\
		/* Also accept "empty" 0-length strings */		\
		if ((len < rule->rule_ctl.kvlen[_n]._f) ||		\
		    (rule->rule_kv[_n].kv_##_f =			\
		    get_string(p + s,					\
		    rule->rule_ctl.kvlen[_n]._f)) == NULL) {		\
			free(rule);					\
			return (-1);					\
		}							\
		s += rule->rule_ctl.kvlen[_n]._f;			\
		len -= rule->rule_ctl.kvlen[_n]._f;			\
									\
		DPRINTF("%s: %s %s (len %ld, option %d): %s", __func__,	\
		    #_n, #_f, rule->rule_ctl.kvlen[_n]._f,		\
		    rule->rule_kv[_n].kv_option,			\
		    rule->rule_kv[_n].kv_##_f);				\
	}								\
}

	memset(&rule->rule_kv[0], 0, sizeof(struct kv));
	for (i = 1; i < KEY_TYPE_MAX; i++) {
		TAILQ_INIT(&rule->rule_kv[i].kv_children);
		GETKV(i, key);
		GETKV(i, value);
	}

	if (rule->rule_labelname[0])
		rule->rule_label = label_name2id(rule->rule_labelname);

	if (rule->rule_tagname[0])
		rule->rule_tag = tag_name2id(rule->rule_tagname);

	if (rule->rule_taggedname[0])
		rule->rule_tagged = tag_name2id(rule->rule_taggedname);

	rule->rule_id = proto->rulecount++;

	TAILQ_INSERT_TAIL(&proto->rules, rule, rule_entry);

	DPRINTF("%s: %s %d received rule %u for protocol %s", __func__,
	    env->sc_ps->ps_title[privsep_process], env->sc_ps->ps_instance,
	    rule->rule_id, proto->name);

	return (0);
}

int
config_setrelay(struct relayd *env, struct relay *rlay)
{
	struct privsep		*ps = env->sc_ps;
	struct ctl_relaytable	 crt;
	struct relay_table	*rlt;
	struct relay_config	 rl;
	int			 id;
	int			 fd, n, m;
	struct iovec		 iov[6];
	size_t			 c;
	u_int			 what;

	/* opens listening sockets etc. */
	if (relay_privinit(rlay) == -1)
		return (-1);

	for (id = 0; id < PROC_MAX; id++) {
		what = ps->ps_what[id];

		if ((what & CONFIG_RELAYS) == 0 || id == privsep_process)
			continue;

		DPRINTF("%s: sending relay %s to %s fd %d", __func__,
		    rlay->rl_conf.name, ps->ps_title[id], rlay->rl_s);

		memcpy(&rl, &rlay->rl_conf, sizeof(rl));

		c = 0;
		iov[c].iov_base = &rl;
		iov[c++].iov_len = sizeof(rl);
		if (rl.tls_cert_len) {
			iov[c].iov_base = rlay->rl_tls_cert;
			iov[c++].iov_len = rl.tls_cert_len;
		}
		if ((what & CONFIG_CA_ENGINE) == 0 &&
		    rl.tls_key_len) {
			iov[c].iov_base = rlay->rl_tls_key;
			iov[c++].iov_len = rl.tls_key_len;
		} else
			rl.tls_key_len = 0;
		if (rl.tls_ca_len) {
			iov[c].iov_base = rlay->rl_tls_ca;
			iov[c++].iov_len = rl.tls_ca_len;
		}
		if (rl.tls_cacert_len) {
			iov[c].iov_base = rlay->rl_tls_cacert;
			iov[c++].iov_len = rl.tls_cacert_len;
		}
		if ((what & CONFIG_CA_ENGINE) == 0 &&
		    rl.tls_cakey_len) {
			iov[c].iov_base = rlay->rl_tls_cakey;
			iov[c++].iov_len = rl.tls_cakey_len;
		} else
			rl.tls_cakey_len = 0;

		if (id == PROC_RELAY) {
			/* XXX imsg code will close the fd after 1st call */
			n = -1;
			proc_range(ps, id, &n, &m);
			for (n = 0; n < m; n++) {
				if ((fd = dup(rlay->rl_s)) == -1)
					return (-1);
				if (proc_composev_imsg(ps, id, n,
				    IMSG_CFG_RELAY, -1, fd, iov, c) != 0) {
					log_warn("%s: failed to compose "
					    "IMSG_CFG_RELAY imsg for `%s'",
					    __func__, rlay->rl_conf.name);
					return (-1);
				}

				/* Prevent fd exhaustion in the parent. */
				if (proc_flush_imsg(ps, id, n) == -1) {
					log_warn("%s: failed to flush "
					    "IMSG_CFG_RELAY imsg for `%s'",
					    __func__, rlay->rl_conf.name);
					return (-1);
				}
			}
		} else {
			if (proc_composev(ps, id,
			    IMSG_CFG_RELAY, iov, c) != 0) {
				log_warn("%s: failed to compose "
				    "IMSG_CFG_RELAY imsg for `%s'",
				    __func__, rlay->rl_conf.name);
				return (-1);
			}
		}

		if ((what & CONFIG_TABLES) == 0)
			continue;

		/* Now send the tables associated to this relay */
		TAILQ_FOREACH(rlt, &rlay->rl_tables, rlt_entry) {
			crt.id = rlt->rlt_table->conf.id;
			crt.relayid = rlay->rl_conf.id;
			crt.mode = rlt->rlt_mode;
			crt.flags = rlt->rlt_flags;

			c = 0;
			iov[c].iov_base = &crt;
			iov[c++].iov_len = sizeof(crt);

			proc_composev(ps, id, IMSG_CFG_RELAY_TABLE, iov, c);
		}
	}

	/* Close server socket early to prevent fd exhaustion in the parent. */
	if (rlay->rl_s != -1) {
		close(rlay->rl_s);
		rlay->rl_s = -1;
	}

	return (0);
}

int
config_getrelay(struct relayd *env, struct imsg *imsg)
{
	struct privsep		*ps = env->sc_ps;
	struct relay		*rlay;
	u_int8_t		*p = imsg->data;
	size_t			 s;

	if ((rlay = calloc(1, sizeof(*rlay))) == NULL)
		return (-1);

	IMSG_SIZE_CHECK(imsg, &rlay->rl_conf);
	memcpy(&rlay->rl_conf, p, sizeof(rlay->rl_conf));
	s = sizeof(rlay->rl_conf);

	rlay->rl_s = imsg->fd;

	if (ps->ps_what[privsep_process] & CONFIG_PROTOS) {
		if (rlay->rl_conf.proto == EMPTY_ID)
			rlay->rl_proto = &env->sc_proto_default;
		else if ((rlay->rl_proto =
		    proto_find(env, rlay->rl_conf.proto)) == NULL) {
			log_debug("%s: unknown protocol", __func__);
			goto fail;
		}
	}

	if ((off_t)(IMSG_DATA_SIZE(imsg) - s) <
	    (rlay->rl_conf.tls_cert_len +
	    rlay->rl_conf.tls_key_len +
	    rlay->rl_conf.tls_ca_len +
	    rlay->rl_conf.tls_cacert_len +
	    rlay->rl_conf.tls_cakey_len)) {
		log_debug("%s: invalid message length", __func__);
		goto fail;
	}

	if (rlay->rl_conf.tls_cert_len) {
		if ((rlay->rl_tls_cert = get_data(p + s,
		    rlay->rl_conf.tls_cert_len)) == NULL)
			goto fail;
		s += rlay->rl_conf.tls_cert_len;
	}
	if (rlay->rl_conf.tls_key_len) {
		if ((rlay->rl_tls_key = get_data(p + s,
		    rlay->rl_conf.tls_key_len)) == NULL)
			goto fail;
		s += rlay->rl_conf.tls_key_len;
	}
	if (rlay->rl_conf.tls_ca_len) {
		if ((rlay->rl_tls_ca = get_data(p + s,
		    rlay->rl_conf.tls_ca_len)) == NULL)
			goto fail;
		s += rlay->rl_conf.tls_ca_len;
	}
	if (rlay->rl_conf.tls_cacert_len) {
		if ((rlay->rl_tls_cacert = get_data(p + s,
		    rlay->rl_conf.tls_cacert_len)) == NULL)
			goto fail;
		s += rlay->rl_conf.tls_cacert_len;
	}
	if (rlay->rl_conf.tls_cakey_len) {
		if ((rlay->rl_tls_cakey = get_data(p + s,
		    rlay->rl_conf.tls_cakey_len)) == NULL)
			goto fail;
		s += rlay->rl_conf.tls_cakey_len;
	}

	TAILQ_INIT(&rlay->rl_tables);
	TAILQ_INSERT_TAIL(env->sc_relays, rlay, rl_entry);

	env->sc_relaycount++;

	DPRINTF("%s: %s %d received relay %s", __func__,
	    ps->ps_title[privsep_process], ps->ps_instance,
	    rlay->rl_conf.name);

	return (0);

 fail:
	free(rlay->rl_tls_cert);
	free(rlay->rl_tls_key);
	free(rlay->rl_tls_ca);
	close(rlay->rl_s);
	free(rlay);
	return (-1);
}

int
config_getrelaytable(struct relayd *env, struct imsg *imsg)
{
	struct relay_table	*rlt = NULL;
	struct ctl_relaytable	 crt;
	struct relay		*rlay;
	struct table		*table;
	u_int8_t		*p = imsg->data;

	IMSG_SIZE_CHECK(imsg, &crt);
	memcpy(&crt, p, sizeof(crt));

	if ((rlay = relay_find(env, crt.relayid)) == NULL) {
		log_debug("%s: unknown relay", __func__);
		goto fail;
	}

	if ((table = table_find(env, crt.id)) == NULL) {
		log_debug("%s: unknown table", __func__);
		goto fail;
	}

	if ((rlt = calloc(1, sizeof(*rlt))) == NULL)
		goto fail;

	rlt->rlt_table = table;
	rlt->rlt_mode = crt.mode;
	rlt->rlt_flags = crt.flags;

	TAILQ_INSERT_TAIL(&rlay->rl_tables, rlt, rlt_entry);

	DPRINTF("%s: %s %d received relay table %s for relay %s", __func__,
	    env->sc_ps->ps_title[privsep_process], env->sc_ps->ps_instance,
	    table->conf.name, rlay->rl_conf.name);

	return (0);

 fail:
	free(rlt);
	return (-1);
}
@


1.32
log
@Migrate relayd to use libtls for TLS. Still does the TLS privsep via the
engine but at least we can use a sane API for new features.
Going in now so it is possible to work with this in tree.
General agreement at d2k17.
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.31 2016/11/24 21:01:18 reyk Exp $	*/
d606 1
a606 1
			iov[c++].iov_len = strlen(proto->style);
d683 1
d685 1
a685 1
		if ((proto->style = get_string(p + s, styl)) == NULL) {
@


1.31
log
@The new fork+exec mode used too many fds in the parent process on
startup, for a short time, so we needed a rlimit hack in relayd.c.
Sync the fix from httpd: rzalamena@@ has fixed proc.c and I added the
proc_flush_imsg() mechanism that makes sure that each fd is
immediately closed after forwarding it to a child process instead of
queueing it up.

OK rzalamena@@ jca@@ benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.30 2016/09/02 14:45:51 reyk Exp $	*/
d103 6
a108 2
		env->sc_proto_default.tlsecdhcurve = TLSECDHCURVE_DEFAULT;
		env->sc_proto_default.tlsdhparams = TLSDHPARAMS_DEFAULT;
d276 2
@


1.30
log
@Split "struct relayd" into two structs: "struct relayd" and "struct
relayd_config".  This way we can send all the relevant global
configuration to the children, not just the flags and the opts.

With input from and
OK claudio@@ benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.29 2016/09/02 13:09:21 reyk Exp $	*/
d830 15
a844 2
				proc_composev_imsg(ps, id, n,
				    IMSG_CFG_RELAY, -1, fd, iov, c);
d847 7
a853 1
			proc_composev(ps, id, IMSG_CFG_RELAY, iov, c);
d874 5
a878 2
	close(rlay->rl_s);
	rlay->rl_s = -1;
@


1.29
log
@As done in httpd, (re-)initialize ps_what in all processes.  This is
no functional change at this point.
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.28 2016/09/01 10:49:48 claudio Exp $	*/
d41 6
a46 6
		env->sc_timeout.tv_sec = CHECK_TIMEOUT / 1000;
		env->sc_timeout.tv_usec = (CHECK_TIMEOUT % 1000) * 1000;
		env->sc_interval.tv_sec = CHECK_INTERVAL;
		env->sc_interval.tv_usec = 0;
		env->sc_prefork_relay = RELAY_NUMPROC;
		env->sc_statinterval.tv_sec = RELAY_STATINTERVAL;
a244 1
	struct ctl_flags	 cf;
d247 1
a247 1
	if (IMSG_DATA_SIZE(imsg) != sizeof(cf))
d251 1
a251 3
	memcpy(&cf, imsg->data, sizeof(cf));
	env->sc_opts = cf.cf_opts;
	env->sc_flags = cf.cf_flags;
d268 1
a268 1
	if (env->sc_flags & (F_TLS|F_TLSCLIENT)) {
@


1.28
log
@Switch from the not really working session cache (because of the multiprocess
nature of relayd) to tls session tickets to do TLS session resumption.
TLS session tickets do not need to store SSL session data in the server but
instead send an encrypted ticket to the clients that allows to resume the
session. This is mostly stateless (apart from the encryption keys).
relayd now ensures that all relay processes use the same key to encrypt
the tickets. Keys are rotated every 2h and there is a primary and backup key.
The tls session timeout is set to 2h to hint to the clients how long the
session tickets is supposed to be alive.
Input and OK benno@@, reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.27 2015/12/07 04:03:27 mmcc Exp $	*/
d47 1
d49 6
a54 7
		ps->ps_what[PROC_PARENT] = CONFIG_ALL;
		ps->ps_what[PROC_PFE] = CONFIG_ALL & ~CONFIG_PROTOS;
		ps->ps_what[PROC_HCE] = CONFIG_TABLES;
		ps->ps_what[PROC_CA] = CONFIG_RELAYS;
		ps->ps_what[PROC_RELAY] = CONFIG_RELAYS|
		    CONFIG_TABLES|CONFIG_PROTOS|CONFIG_CA_ENGINE;
	}
@


1.27
log
@Remove NULL-checks before free(). No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.26 2015/12/02 13:41:27 reyk Exp $	*/
a96 1
		env->sc_proto_default.cache = RELAY_CACHESIZE;
@


1.26
log
@In most cases we don't need all arguments of proc_compose*_imsg(),
so add a shortcut proc_compose*() that skips all of them.  Only use the
full argument list if needed.  The functions with full argument lists can
eventually be replaced with a nicer transaction-based approach later.

OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.25 2015/05/02 13:15:24 claudio Exp $	*/
d181 2
a182 4
			if (proto->style != NULL)
				free(proto->style);
			if (proto->tlscapass != NULL)
				free(proto->tlscapass);
d945 3
a947 6
	if (rlay->rl_tls_cert)
		free(rlay->rl_tls_cert);
	if (rlay->rl_tls_key)
		free(rlay->rl_tls_key);
	if (rlay->rl_tls_ca)
		free(rlay->rl_tls_ca);
d991 1
a991 2
	if (rlt != NULL)
		free(rlt);
@


1.25
log
@Fix obvious problems with relayd config reload.
- fix a TAILQ corruption because of a use after free
- do not reinit the SSL engine since that fails
OK sthen, benno
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.24 2015/01/22 17:42:09 reyk Exp $	*/
d223 1
a223 2
		proc_compose_imsg(ps, id, -1, IMSG_CTL_RESET, -1,
		    &reset, sizeof(reset));
d281 1
a281 2
		proc_compose_imsg(env->sc_ps, PROC_PARENT, -1,
		    IMSG_CFG_DONE, -1, NULL, 0);
d314 1
a314 1
		proc_composev_imsg(ps, id, -1, IMSG_CFG_TABLE, -1, iov, c);
d317 1
a317 1
			proc_compose_imsg(ps, id, -1, IMSG_CFG_HOST, -1,
d416 1
a416 1
		proc_compose_imsg(ps, id, -1, IMSG_CFG_RDR, -1,
d421 1
a421 1
			proc_compose_imsg(ps, id, -1, IMSG_CFG_VIRT, -1,
d504 1
a504 1
		proc_compose_imsg(ps, id, -1, IMSG_CFG_ROUTER, -1,
d508 1
a508 1
			proc_compose_imsg(ps, id, -1, IMSG_CFG_ROUTE, -1,
d609 1
a609 1
		proc_composev_imsg(ps, id, -1, IMSG_CFG_PROTO, -1, iov, c);
d660 1
a660 2
			proc_composev_imsg(ps, id, -1,
			    IMSG_CFG_RULE, -1, iov, c);
d837 1
a837 1
				    IMSG_CFG_RELAY, fd, iov, c);
d840 1
a840 2
			proc_composev_imsg(ps, id, -1, IMSG_CFG_RELAY, -1,
			    iov, c);
d857 1
a857 2
			proc_composev_imsg(ps, id, -1,
			    IMSG_CFG_RELAY_TABLE, -1, iov, c);
@


1.24
log
@Clean up the relayd headers with help of include-what-you-use and some
manual review.  Based on common practice, relayd.h now includes the
necessary headers for itself.

OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.23 2015/01/21 21:50:33 deraadt Exp $	*/
d145 1
a145 1
			purge_table(env->sc_tables, table);
@


1.24.2.1
log
@maintainance diff for relayd
MFC the following changes

- Missing free(3) in error path (ssl.c,v 1.29)
- fix a memory leak. (pfe.c,v 1.80)
- allocate se_log evbuffer before loging errors with relay_close()
  (relay.c,v 1.192)
- fix a file descriptor leak in http protocol handling
  (relay.c,v 1.193 and relay_http.c,v 1.44)
- Fix obvious problems with relayd config reload
  (ca.c,v 1.13; config.c,v 1.25; parse.y,v 1.204;
  relayd.c,v 1.139; relayd.h,v 1.209)
- http protocol: you cannot append to the previous key-value before
  line three of a request (relay_http.c,v 1.45)
- fix a crash / use after free (relay.c,v 1.194; relay_http.c,v 1.46)
- fix a non safe use of TAILQ_FOREACH with TAILQ_REMOVE
  (relay_http.c,v 1.47)
- Plug a memory leak by simplifying kv_free() (relayd.c,v 1.141)
- Fix memory leak in error case (relay_http.c,v 1.48)
- track the connection state of a session and stops doing double
  opens in certain situations (relay.c,v 1.195; relay_http.c,v 1.49; relayd.h,v 1.210)
- coding style (relay.c,v 1.196; relay_http.c,v 1.50; relayd.h,v 1.212)

ok claudio@@, sthen@@ and feedback tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.24 2015/01/22 17:42:09 reyk Exp $	*/
d145 1
a145 1
			purge_table(env, env->sc_tables, table);
@


1.23
log
@Include <netinet/in.h> before <net/pfvar.h>.  In a future change when
ports is ready, <net/pfvar.h> will stop including a pile of balony.
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.22 2014/12/21 00:54:49 guenther Exp $	*/
a19 2
#include <sys/socket.h>
#include <sys/stat.h>
d21 1
d24 2
a25 5
#include <netinet/in.h>
#include <net/if.h>
#include <net/pfvar.h>

#include <ctype.h>
a26 3
#include <err.h>
#include <errno.h>
#include <event.h>
a27 4
#include <stdint.h>
#include <stdarg.h>
#include <stdio.h>
#include <netdb.h>
d29 1
a29 3
#include <ifaddrs.h>

#include <openssl/ssl.h>
@


1.22
log
@Stop pulling in <arpa/inet.h> or <arpa/nameser.h> when unnecessary.
*Do* pull it in when in_{port,addr}_h is needed and <netinet/in.h> isn't.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.21 2014/12/12 10:05:09 reyk Exp $	*/
d25 1
a27 2
#include <netinet/in.h>
#include <net/route.h>
@


1.21
log
@Change the keyword "ssl" to "tls" to reflect reality since we
effectively disabled support for the SSL protocols.  SSL remains a
common term describing SSL/TLS, there is some controvery about this
change, and the name really doesn't matter, but I feel confident about
it now.

(btw., sthen@@ pointed out some historical context:
http://tim.dierks.org/2014/05/security-standards-and-name-changes-in.html)

OK benno@@, with input from tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.20 2014/11/22 00:24:22 tedu Exp $	*/
a27 2
#include <arpa/inet.h>
#include <arpa/nameser.h>
@


1.20
log
@use size_t where appropriate. ok deraadt reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.19 2014/11/19 10:24:40 blambert Exp $	*/
d116 6
a121 6
		env->sc_proto_default.sslflags = SSLFLAG_DEFAULT;
		(void)strlcpy(env->sc_proto_default.sslciphers,
		    SSLCIPHERS_DEFAULT,
		    sizeof(env->sc_proto_default.sslciphers));
		env->sc_proto_default.sslecdhcurve = SSLECDHCURVE_DEFAULT;
		env->sc_proto_default.ssldhparams = SSLDHPARAMS_DEFAULT;
d199 2
a200 2
			if (proto->sslcapass != NULL)
				free(proto->sslcapass);
d291 1
a291 1
	if (env->sc_flags & (F_SSL|F_SSLCLIENT)) {
d710 1
a710 1
	proto->sslcapass = NULL;
d823 3
a825 3
		if (rl.ssl_cert_len) {
			iov[c].iov_base = rlay->rl_ssl_cert;
			iov[c++].iov_len = rl.ssl_cert_len;
d828 3
a830 3
		    rl.ssl_key_len) {
			iov[c].iov_base = rlay->rl_ssl_key;
			iov[c++].iov_len = rl.ssl_key_len;
d832 8
a839 8
			rl.ssl_key_len = 0;
		if (rl.ssl_ca_len) {
			iov[c].iov_base = rlay->rl_ssl_ca;
			iov[c++].iov_len = rl.ssl_ca_len;
		}
		if (rl.ssl_cacert_len) {
			iov[c].iov_base = rlay->rl_ssl_cacert;
			iov[c++].iov_len = rl.ssl_cacert_len;
d842 3
a844 3
		    rl.ssl_cakey_len) {
			iov[c].iov_base = rlay->rl_ssl_cakey;
			iov[c++].iov_len = rl.ssl_cakey_len;
d846 1
a846 1
			rl.ssl_cakey_len = 0;
d916 5
a920 5
	    (rlay->rl_conf.ssl_cert_len +
	    rlay->rl_conf.ssl_key_len +
	    rlay->rl_conf.ssl_ca_len +
	    rlay->rl_conf.ssl_cacert_len +
	    rlay->rl_conf.ssl_cakey_len)) {
d925 3
a927 3
	if (rlay->rl_conf.ssl_cert_len) {
		if ((rlay->rl_ssl_cert = get_data(p + s,
		    rlay->rl_conf.ssl_cert_len)) == NULL)
d929 1
a929 1
		s += rlay->rl_conf.ssl_cert_len;
d931 3
a933 3
	if (rlay->rl_conf.ssl_key_len) {
		if ((rlay->rl_ssl_key = get_data(p + s,
		    rlay->rl_conf.ssl_key_len)) == NULL)
d935 1
a935 1
		s += rlay->rl_conf.ssl_key_len;
d937 3
a939 3
	if (rlay->rl_conf.ssl_ca_len) {
		if ((rlay->rl_ssl_ca = get_data(p + s,
		    rlay->rl_conf.ssl_ca_len)) == NULL)
d941 1
a941 1
		s += rlay->rl_conf.ssl_ca_len;
d943 3
a945 3
	if (rlay->rl_conf.ssl_cacert_len) {
		if ((rlay->rl_ssl_cacert = get_data(p + s,
		    rlay->rl_conf.ssl_cacert_len)) == NULL)
d947 1
a947 1
		s += rlay->rl_conf.ssl_cacert_len;
d949 3
a951 3
	if (rlay->rl_conf.ssl_cakey_len) {
		if ((rlay->rl_ssl_cakey = get_data(p + s,
		    rlay->rl_conf.ssl_cakey_len)) == NULL)
d953 1
a953 1
		s += rlay->rl_conf.ssl_cakey_len;
d968 6
a973 6
	if (rlay->rl_ssl_cert)
		free(rlay->rl_ssl_cert);
	if (rlay->rl_ssl_key)
		free(rlay->rl_ssl_key);
	if (rlay->rl_ssl_ca)
		free(rlay->rl_ssl_ca);
@


1.19
log
@Support exporting relayd statistics via AgentX/snmpd

This should be equivalent to the statistics available
via the various relaydctl show commands

okay benno@@ reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.18 2014/07/11 16:59:38 reyk Exp $	*/
d915 1
a915 1
	if ((u_int)(IMSG_DATA_SIZE(imsg) - s) <
@


1.18
log
@Add support for EDH to provide perfect forward secrecy for older SSL
clients.  Additionally, add options for disallowing client-initiated
renegotiations and to prefer the server's cipher list over the
client's preferences.

This work is based on a diff by Markus Gebert at hostpoint.ch, and was
discussed with jsing@@ resulting in a few different defaults.

ok benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.17 2014/07/11 11:48:50 reyk Exp $	*/
d410 1
@


1.17
log
@Simplify the code that handles the HTTP headers by using an RB tree
with associated lists instead of the complicated lookup table and
"others" list.  This might add a little malloc overhead for common
headers but also fixes some issues like the handling of repeated
headers -  for example, handling of multiple "Set-Cookie" headers.

ok bluhm@@ (regress part)
ok benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.16 2014/07/09 23:30:34 reyk Exp $	*/
d121 1
@


1.16
log
@When copying structures via imsg, the contents should not contain
bogus pointer values - make sure to zero the first rule_kv element.

awesome benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.15 2014/07/09 16:42:05 reyk Exp $	*/
d765 1
@


1.15
log
@Replace the protocol directives for HTTP with a new generic filtering
language.  The grammar is inspired by pf and allows to write versatile
last-matching filter rules in protocol sections starting with the
"pass", "block" or "match" keywords.  This work was started almost two
years ago and replaces large parts of relayd(8)'s HTTP and filtering
code.  The initial version reimplements and extends HTTP filtering,
but will be improved to support generic TCP and other protocols later.

With some testing, feedback, and help from benno@@ and andre@@.

OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.14 2014/05/04 16:38:19 reyk Exp $	*/
d763 1
@


1.14
log
@Create a new default RSA engine instead of patching the existing one
if none is available.  Fixes SSL/TLS and a possible fatalx() on
machines without a default RSA engine.

Thanks to Bjorn Ketelaars for reporting and testing.

ok gilles@@ (for the relayd part)
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.13 2014/04/22 08:04:23 reyk Exp $	*/
a123 2
		RB_INIT(&env->sc_proto_default.request_tree);
		RB_INIT(&env->sc_proto_default.response_tree);
d149 1
d188 8
a195 2
			purge_tree(&proto->request_tree);
			purge_tree(&proto->response_tree);
d605 1
a605 1
	struct iovec		 iov[2];
a624 1
		/* XXX struct protocol should be split */
d626 1
d628 51
a678 6
		/* Now send all the protocol key/value nodes */
		if (config_setprotonode(env, id, proto,
		    RELAY_DIR_REQUEST) == -1 ||
		    config_setprotonode(env, id, proto,
		    RELAY_DIR_RESPONSE) == -1)
			return (-1);
d707 1
a707 2
	proto->request_nodes = 0;
	proto->response_nodes = 0;
a708 2
	RB_INIT(&proto->request_tree);
	RB_INIT(&proto->response_tree);
d722 1
a722 2
config_setprotonode(struct relayd *env, enum privsep_procid id,
    struct protocol *proto, enum direction dir)
d724 13
a736 36
	struct privsep		*ps = env->sc_ps;
	struct iovec		 iov[IOV_MAX];
	size_t			 c, sz;
	struct protonode	*proot, *pn;
	struct proto_tree	*tree;

	if (dir == RELAY_DIR_RESPONSE)
		tree = &proto->response_tree;
	else
		tree = &proto->request_tree;

	sz = c = 0;
	RB_FOREACH(proot, proto_tree, tree) {
		PROTONODE_FOREACH(pn, proot, entry) {
			pn->conf.protoid = proto->id;
			pn->conf.dir = dir;
			pn->conf.keylen = pn->key ? strlen(pn->key) : 0;
			pn->conf.valuelen = pn->value ? strlen(pn->value) : 0;
			if (pn->label != 0 && pn->labelname == NULL)
				pn->labelname = strdup(pn_id2name(pn->label));
			pn->conf.labelnamelen = pn->labelname ?
			    strlen(pn->labelname) : 0;

			pn->conf.len = sizeof(*pn) +
			    pn->conf.keylen + pn->conf.valuelen +
			    pn->conf.labelnamelen;

			if (pn->conf.len > (MAX_IMSGSIZE - IMSG_HEADER_SIZE))
				return (-1);

			if (c && ((c + 3) >= IOV_MAX || (sz + pn->conf.len) >
			    (MAX_IMSGSIZE - IMSG_HEADER_SIZE))) {
				proc_composev_imsg(ps, id, -1,
				    IMSG_CFG_PROTONODE, -1, iov, c);
				c = sz = 0;
			}
d738 3
a740 16
			iov[c].iov_base = pn;
			iov[c++].iov_len = sizeof(*pn);
			if (pn->conf.keylen) {
				iov[c].iov_base = pn->key;
				iov[c++].iov_len = pn->conf.keylen;
			}
			if (pn->conf.valuelen) {
				iov[c].iov_base = pn->value;
				iov[c++].iov_len = pn->conf.valuelen;
			}
			if (pn->conf.labelnamelen) {
				iov[c].iov_base = pn->labelname;
				iov[c++].iov_len = pn->conf.labelnamelen;
			}
			sz += pn->conf.len;
		}
d743 18
a760 4
	if (c && sz)
		proc_composev_imsg(ps, id, -1, IMSG_CFG_PROTONODE, -1, iov, c);

	return (0);
d763 4
a766 7
int
config_getprotonode(struct relayd *env, struct imsg *imsg)
{
	struct protocol		*proto = NULL;
	struct protonode	 pn;
	size_t			 z, s, c = 0;
	u_int8_t		*p = imsg->data;
d768 2
a769 1
	bzero(&pn, sizeof(pn));
d771 2
a772 11
	IMSG_SIZE_CHECK(imsg, &pn);
	for (z = 0; z < (IMSG_DATA_SIZE(imsg) - sizeof(pn)); z += pn.conf.len) {
		s = z;
		memcpy(&pn, p + s, sizeof(pn));
		s += sizeof(pn);

		if ((proto = proto_find(env, pn.conf.protoid)) == NULL) {
			log_debug("%s: unknown protocol %d", __func__,
			    pn.conf.protoid);
			return (-1);
		}
d774 2
a775 32
		pn.key = pn.value = pn.labelname = NULL;
		bzero(&pn.entry, sizeof(pn.entry));
		bzero(&pn.nodes, sizeof(pn.nodes));
		bzero(&pn.head, sizeof(pn.head));

		if (pn.conf.keylen) {
			if ((pn.key = get_string(p + s,
			    pn.conf.keylen)) == NULL) {
				log_debug("%s: failed to get key", __func__);
				return (-1);
			}
			s += pn.conf.keylen;
		}
		if (pn.conf.valuelen) {
			if ((pn.value = get_string(p + s,
			    pn.conf.valuelen)) == NULL) {
				log_debug("%s: failed to get value", __func__);
				if (pn.key != NULL)
					free(pn.key);
				return (-1);
			}
			s += pn.conf.valuelen;
		}
		if (pn.conf.labelnamelen) {
			if ((pn.labelname = get_string(p + s,
			    pn.conf.labelnamelen)) == NULL) {
				log_debug("%s: failed to get labelname",
				    __func__);
				return (-1);
			}
			s += pn.conf.labelnamelen;
		}
d777 1
a777 12
		if (protonode_add(pn.conf.dir, proto, &pn) == -1) {
			if (pn.key != NULL)
				free(pn.key);
			if (pn.value != NULL)
				free(pn.value);
			if (pn.labelname != NULL)
				free(pn.labelname);
			log_debug("%s: failed to add protocol node", __func__);
			return (-1);
		}
		c++;
	}
d779 1
a779 2
	if (!c)
		return (0);
d781 1
a781 1
	DPRINTF("%s: %s %d received %lu nodes for protocol %s", __func__,
d783 1
a783 1
	    c, proto->name);
@


1.13
log
@Support the CA key for SSL inspection in the ca process.  Instead of
looking up the keys by relay id, add all keys to a list and look them
up by key id.

ok benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.12 2014/04/18 13:55:26 reyk Exp $	*/
d287 2
a288 3
		if ((what & CONFIG_CA_ENGINE) &&
		    (ca_engine_init(env)) == -1)
			fatal("CA engine failed");
@


1.12
log
@Introduce privsep for private keys:

- Move RSA private keys to a new separate process instead of copying
them to the relays.  A custom RSA engine is used by the SSL/TLS code
of the relay processes to send RSA private key encryption/decryption
(also used for sign/verify) requests to the new "ca" processes instead
of operating on the private key directly.

- Each relay process gets its own related ca process.  Setting
"prefork 5" in the config file will spawn 10 processes (5 relay, 5
ca).  This diff also reduces the default number of relay processes
from 5 to 3 which should be suitable in most installations without a
very heavy load.

- Don't keep text versions of the keys in memory, parse them once and
keep the binary representation.  This might still be the case in
OpenSSL's internals but will be fixed in the library.

This diff doesn't prevent something like "heartbleed" but adds an
additional mitigation to prevent leakage of the private keys from the
processes doing SSL/TLS.

With feedback from many
ok benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.11 2014/02/24 06:55:11 jsg Exp $	*/
d99 4
d154 1
d175 6
d867 2
a868 1
		if (rl.ssl_cakey_len) {
d871 2
a872 1
		}
@


1.11
log
@fix a buffer overflow of an array introduced with the ssl inspection commit
ok reyk@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.10 2013/09/09 17:57:44 reyk Exp $	*/
d4 1
a4 1
 * Copyright (c) 2011 Reyk Floeter <reyk@@openbsd.org>
d67 3
a69 2
		ps->ps_what[PROC_RELAY] =
		    CONFIG_TABLES|CONFIG_RELAYS|CONFIG_PROTOS;
d249 1
d259 3
a261 1
	if (ps->ps_what[privsep_process] & CONFIG_TABLES) {
d274 1
a274 1
	if (env->sc_flags & (F_SSL|F_SSLCLIENT))
d276 4
d813 1
d818 1
d825 3
a827 2
		if ((ps->ps_what[id] & CONFIG_RELAYS) == 0 ||
		    id == privsep_process)
d833 2
d836 3
a838 3
		iov[c].iov_base = &rlay->rl_conf;
		iov[c++].iov_len = sizeof(rlay->rl_conf);
		if (rlay->rl_conf.ssl_cert_len) {
d840 1
a840 1
			iov[c++].iov_len = rlay->rl_conf.ssl_cert_len;
d842 2
a843 1
		if (rlay->rl_conf.ssl_key_len) {
d845 4
a848 3
			iov[c++].iov_len = rlay->rl_conf.ssl_key_len;
		}
		if (rlay->rl_conf.ssl_ca_len) {
d850 1
a850 1
			iov[c++].iov_len = rlay->rl_conf.ssl_ca_len;
d852 1
a852 1
		if (rlay->rl_conf.ssl_cacert_len) {
d854 1
a854 1
			iov[c++].iov_len = rlay->rl_conf.ssl_cacert_len;
d856 1
a856 1
		if (rlay->rl_conf.ssl_cakey_len) {
d858 1
a858 1
			iov[c++].iov_len = rlay->rl_conf.ssl_cakey_len;
d875 3
@


1.10
log
@Add support for ECDHE (Elliptic curve Diffie-Hellman) to enable
TLS/SSL Perfect Forward Secrecy (PFS).

ok djm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.9 2013/05/30 20:17:12 reyk Exp $	*/
d807 1
a807 1
	struct iovec		 iov[4];
@


1.9
log
@Support SSL inspection, the ability to transparently filter in SSL/TLS
connections (eg. HTTPS) by using a local CA that is accepted by the
clients.  See the "SSL RELAYS" and "EXAMPLES" sections in the
relayd.conf(5) manpage for more details.

ok benno@@, manpage bits jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.8 2012/12/18 15:57:16 reyk Exp $	*/
d115 1
@


1.8
log
@remove unused variable
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.7 2012/11/27 05:00:28 guenther Exp $	*/
d180 2
d640 1
d836 8
d912 3
a914 1
	    rlay->rl_conf.ssl_ca_len)) {
d936 12
@


1.7
log
@Add format attributes to the proper functions and then fix the warnings
that gcc then reports when compiling with -DDEBUG=2

ok reyk@@ benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.6 2012/10/04 20:53:30 reyk Exp $	*/
a955 1
	size_t			 s;
a958 1
	s = sizeof(crt);
@


1.6
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.5 2012/10/03 08:40:40 reyk Exp $	*/
d788 1
a788 1
	DPRINTF("%s: %s %d received %d nodes for protocol %s", __func__,
@


1.5
log
@Inherit and pass the relay table flags correctly.
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.4 2012/10/03 08:33:31 reyk Exp $	*/
d676 2
a677 1
			pn->conf.labelnamelen = pn->labelname ? strlen(pn->labelname) : 0;
d680 2
a681 1
			    pn->conf.keylen + pn->conf.valuelen + pn->conf.labelnamelen;
d765 2
a766 1
				log_debug("%s: failed to get labelname", __func__);
@


1.4
log
@Support more than one relay backup table.  Instead of duplicating the
code for main and backup table all over the place, turn the relay
tables into a list attached to the relay.  This improves the code and
allows some other tricks with multiple tables later.
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.3 2012/05/08 15:10:15 benno Exp $	*/
d851 1
d974 1
@


1.3
log
@fix "label string" in http protocol. problem found by giovanni.
ok giovanni@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.2 2011/05/19 09:13:07 reyk Exp $	*/
d795 7
a801 5
	struct privsep	*ps = env->sc_ps;
	int		 id;
	int		 fd, n, m;
	struct iovec	 iov[4];
	size_t		 c;
d845 14
a893 15
	if (rlay->rl_conf.dsttable != EMPTY_ID &&
	    (rlay->rl_dsttable = table_find(env,
	    rlay->rl_conf.dsttable)) == NULL) {
		log_debug("%s: unknown table", __func__);
		goto fail;
	}

	rlay->rl_backuptable = &env->sc_empty_table;
	if (rlay->rl_conf.backuptable != EMPTY_ID &&
	    (rlay->rl_backuptable = table_find(env,
	    rlay->rl_conf.backuptable)) == NULL) {
		log_debug("%s: unknown backup table", __func__);
		goto fail;
	}

d921 1
d941 44
@


1.2
log
@Add a few missing checks of return values of memory allocations.
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.1 2011/05/19 08:56:49 reyk Exp $	*/
d674 4
d679 1
a679 1
			    pn->conf.keylen + pn->conf.valuelen;
d701 4
d737 1
a737 1
		pn.key = pn.value = NULL;
d760 8
d774 2
@


1.1
log
@Fix reload support in relayd(8) by reimplementing large parts of the
daemon infrastructure. The previous design made it fairly hard to
reload the complex data structures, especially relays and protocols.
One of the reasons was that the privsep'd relayd processes had two
ways of getting their configuration: 1) from memory after forking from
the parent process and 2) and (partially) via imsgs after reload.  The
new implementation first forks the privsep'd children before the
parents loads the configuration and sends it via imsgs to them; so it
is only like 2) before.  It is based on an approach that I first
implemented for iked(8) and I also fixed many bugs in the code.

Thanks to many testers including dlg@@ sthen@@ phessler@@
ok pyr@@ dlg@@ sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d332 6
a337 2
	if (sb > 0)
		tb->sendbuf = get_string(p + s, sb);
d618 2
d625 2
a626 1
	memcpy(proto, imsg->data, sizeof(*proto));
d628 7
a634 4
	styl = IMSG_DATA_SIZE(imsg) - sizeof(*proto);
	if (styl > 0)
		proto->style = get_string((char *)imsg->data +
		    sizeof(*proto), styl);
d735 5
a739 1
			pn.key = get_string(p + s, pn.conf.keylen);
d743 7
a749 1
			pn.value = get_string(p + s, pn.conf.valuelen);
d754 4
@

