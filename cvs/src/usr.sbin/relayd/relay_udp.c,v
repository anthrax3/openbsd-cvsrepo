head	1.47;
access;
symbols
	OPENBSD_6_2_BASE:1.47
	OPENBSD_6_1:1.45.0.4
	OPENBSD_6_1_BASE:1.45
	OPENBSD_6_0:1.42.0.4
	OPENBSD_6_0_BASE:1.42
	OPENBSD_5_9:1.42.0.2
	OPENBSD_5_9_BASE:1.42
	OPENBSD_5_8:1.39.0.6
	OPENBSD_5_8_BASE:1.39
	OPENBSD_5_7:1.39.0.2
	OPENBSD_5_7_BASE:1.39
	OPENBSD_5_6:1.31.0.4
	OPENBSD_5_6_BASE:1.31
	OPENBSD_5_5:1.28.0.6
	OPENBSD_5_5_BASE:1.28
	OPENBSD_5_4:1.28.0.2
	OPENBSD_5_4_BASE:1.28
	OPENBSD_5_3:1.27.0.2
	OPENBSD_5_3_BASE:1.27
	OPENBSD_5_2:1.24.0.6
	OPENBSD_5_2_BASE:1.24
	OPENBSD_5_1_BASE:1.24
	OPENBSD_5_1:1.24.0.4
	OPENBSD_5_0:1.24.0.2
	OPENBSD_5_0_BASE:1.24
	OPENBSD_4_9:1.22.0.4
	OPENBSD_4_9_BASE:1.22
	OPENBSD_4_8:1.22.0.2
	OPENBSD_4_8_BASE:1.22
	OPENBSD_4_7:1.21.0.2
	OPENBSD_4_7_BASE:1.21
	OPENBSD_4_6:1.20.0.4
	OPENBSD_4_6_BASE:1.20
	OPENBSD_4_5:1.18.0.2
	OPENBSD_4_5_BASE:1.18
	OPENBSD_4_4:1.16.0.2
	OPENBSD_4_4_BASE:1.16
	OPENBSD_4_3:1.10.0.2
	OPENBSD_4_3_BASE:1.10;
locks; strict;
comment	@ * @;


1.47
date	2017.07.04.19.59.51;	author benno;	state Exp;
branches;
next	1.46;
commitid	ShNRMJEraQPkzmLN;

1.46
date	2017.05.28.10.39.15;	author benno;	state Exp;
branches;
next	1.45;
commitid	IW4LnWyG3CPq6c3r;

1.45
date	2017.01.09.14.49.21;	author reyk;	state Exp;
branches;
next	1.44;
commitid	eA8b246voAapPTkX;

1.44
date	2016.11.10.13.21.58;	author jca;	state Exp;
branches;
next	1.43;
commitid	bzuS4pGsUAgOV3uT;

1.43
date	2016.09.02.14.31.47;	author reyk;	state Exp;
branches;
next	1.42;
commitid	5rsV42sOU0zqn3cJ;

1.42
date	2015.12.07.04.03.27;	author mmcc;	state Exp;
branches;
next	1.41;
commitid	vlUffo7boyCTPJEr;

1.41
date	2015.12.02.13.41.27;	author reyk;	state Exp;
branches;
next	1.40;
commitid	vBNcEM4jmO1KceIa;

1.40
date	2015.11.28.09.52.07;	author reyk;	state Exp;
branches;
next	1.39;
commitid	Xo3TbDi9hUaP9ip0;

1.39
date	2015.01.22.17.42.09;	author reyk;	state Exp;
branches;
next	1.38;
commitid	puppem00jmzmdm4f;

1.38
date	2015.01.16.15.06.40;	author deraadt;	state Exp;
branches;
next	1.37;
commitid	tOv8XK6tLyhEfayc;

1.37
date	2014.12.21.00.54.49;	author guenther;	state Exp;
branches;
next	1.36;
commitid	XnjIOhurXdX5o1V9;

1.36
date	2014.12.18.20.55.01;	author reyk;	state Exp;
branches;
next	1.35;
commitid	nThpdXmyvXqmRQ4C;

1.35
date	2014.12.12.10.05.09;	author reyk;	state Exp;
branches;
next	1.34;
commitid	J8g0vRzthwLCqf68;

1.34
date	2014.11.19.10.24.40;	author blambert;	state Exp;
branches;
next	1.33;
commitid	EGrSQMGI27r3h8Vf;

1.33
date	2014.10.25.03.23.49;	author lteo;	state Exp;
branches;
next	1.32;
commitid	2uw1UTO4k6erpWzK;

1.32
date	2014.08.08.18.26.50;	author reyk;	state Exp;
branches;
next	1.31;
commitid	TxQPD75G3ThvxDEG;

1.31
date	2014.07.13.00.32.08;	author benno;	state Exp;
branches;
next	1.30;
commitid	ri182Vf5Hw0I7rh1;

1.30
date	2014.07.09.16.42.05;	author reyk;	state Exp;
branches;
next	1.29;
commitid	YhQvyAop4vC3AmzJ;

1.29
date	2014.06.25.11.05.15;	author reyk;	state Exp;
branches;
next	1.28;
commitid	QSckC3KrSjGNpjr5;

1.28
date	2013.03.10.23.32.53;	author reyk;	state Exp;
branches;
next	1.27;

1.27
date	2013.01.17.20.34.18;	author bluhm;	state Exp;
branches;
next	1.26;

1.26
date	2012.12.18.15.36.43;	author reyk;	state Exp;
branches;
next	1.25;

1.25
date	2012.10.03.08.33.31;	author reyk;	state Exp;
branches;
next	1.24;

1.24
date	2011.05.09.12.08.47;	author reyk;	state Exp;
branches;
next	1.23;

1.23
date	2011.05.05.12.01.44;	author reyk;	state Exp;
branches;
next	1.22;

1.22
date	2010.05.26.13.56.08;	author nicm;	state Exp;
branches;
next	1.21;

1.21
date	2009.08.07.11.21.53;	author reyk;	state Exp;
branches;
next	1.20;

1.20
date	2009.06.05.23.39.51;	author pyr;	state Exp;
branches;
next	1.19;

1.19
date	2009.06.05.00.04.01;	author pyr;	state Exp;
branches;
next	1.18;

1.18
date	2008.09.29.15.12.22;	author reyk;	state Exp;
branches;
next	1.17;

1.17
date	2008.08.08.08.51.21;	author thib;	state Exp;
branches;
next	1.16;

1.16
date	2008.07.23.10.05.18;	author reyk;	state Exp;
branches;
next	1.15;

1.15
date	2008.07.09.17.24.14;	author reyk;	state Exp;
branches;
next	1.14;

1.14
date	2008.07.09.17.16.51;	author reyk;	state Exp;
branches;
next	1.13;

1.13
date	2008.07.09.14.57.01;	author reyk;	state Exp;
branches;
next	1.12;

1.12
date	2008.07.09.10.50.34;	author reyk;	state Exp;
branches;
next	1.11;

1.11
date	2008.05.08.02.27.58;	author reyk;	state Exp;
branches;
next	1.10;

1.10
date	2008.03.03.16.43.42;	author reyk;	state Exp;
branches;
next	1.9;

1.9
date	2008.02.13.11.32.59;	author reyk;	state Exp;
branches;
next	1.8;

1.8
date	2008.02.04.12.12.30;	author thib;	state Exp;
branches;
next	1.7;

1.7
date	2008.01.31.12.12.50;	author thib;	state Exp;
branches;
next	1.6;

1.6
date	2008.01.31.09.56.28;	author reyk;	state Exp;
branches;
next	1.5;

1.5
date	2008.01.31.09.33.39;	author reyk;	state Exp;
branches;
next	1.4;

1.4
date	2008.01.29.16.36.04;	author reyk;	state Exp;
branches;
next	1.3;

1.3
date	2007.12.07.17.17.01;	author reyk;	state Exp;
branches;
next	1.2;

1.2
date	2007.11.24.17.07.28;	author reyk;	state Exp;
branches;
next	1.1;

1.1
date	2007.09.10.11.59.22;	author reyk;	state Exp;
branches;
next	;


desc
@@


1.47
log
@make relayd not crash in relay_udp_server() when using a dns relay.
needs revisiting. From Rivo Nurges, thanks.
ok florian@@
@
text
@/*	$OpenBSD: relay_udp.c,v 1.46 2017/05/28 10:39:15 benno Exp $	*/

/*
 * Copyright (c) 2007 - 2013 Reyk Floeter <reyk@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/queue.h>
#include <sys/time.h>
#include <sys/socket.h>
#include <sys/tree.h>

#include <netinet/in.h>
#include <arpa/inet.h>

#include <signal.h>
#include <errno.h>
#include <fcntl.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <stdio.h>
#include <event.h>
#include <imsg.h>

#include "relayd.h"

extern volatile sig_atomic_t relay_sessions;
extern objid_t relay_conid;

static struct relayd *env = NULL;
struct shuffle relay_shuffle;

int		 relay_udp_socket(struct sockaddr_storage *, in_port_t,
		    struct protocol *);
void		 relay_udp_request(struct rsession *);
void		 relay_udp_timeout(int, short, void *);

void		 relay_dns_log(struct rsession *, u_int8_t *, size_t);
void		*relay_dns_validate(struct rsession *,
		    struct relay *, struct sockaddr_storage *,
		    u_int8_t *, size_t);
int		 relay_dns_request(struct rsession *);
void		 relay_udp_response(int, short, void *);
void		 relay_dns_result(struct rsession *, u_int8_t *, size_t);
int		 relay_dns_cmp(struct rsession *, struct rsession *);

void
relay_udp_privinit(struct relay *rlay)
{
	if (rlay->rl_conf.flags & F_TLS)
		fatalx("tls over udp is not supported");
	rlay->rl_conf.flags |= F_UDP;
}

void
relay_udp_init(struct relayd *x_env, struct relay *rlay)
{
	struct protocol		*proto = rlay->rl_proto;

	if (env == NULL)
		env = x_env;

	switch (proto->type) {
	case RELAY_PROTO_DNS:
		proto->validate = relay_dns_validate;
		proto->request = relay_dns_request;
		proto->cmp = relay_dns_cmp;
		shuffle_init(&relay_shuffle);
		break;
	default:
		fatalx("unsupported udp protocol");
		break;
	}
}

int
relay_udp_bind(struct sockaddr_storage *ss, in_port_t port,
    struct protocol *proto)
{
	int s;

	if ((s = relay_udp_socket(ss, port, proto)) == -1)
		return (-1);

	if (bind(s, (struct sockaddr *)ss, ss->ss_len) == -1)
		goto bad;

	return (s);

 bad:
	close(s);
	return (-1);
}

int
relay_udp_socket(struct sockaddr_storage *ss, in_port_t port,
    struct protocol *proto)
{
	int s = -1, val;

	if (relay_socket_af(ss, port) == -1)
		goto bad;

	if ((s = socket(ss->ss_family, SOCK_DGRAM | SOCK_NONBLOCK,
	    IPPROTO_UDP)) == -1)
		goto bad;

	/*
	 * Socket options
	 */
	if (proto->tcpflags & TCPFLAG_BUFSIZ) {
		val = proto->tcpbufsiz;
		if (setsockopt(s, SOL_SOCKET, SO_RCVBUF,
		    &val, sizeof(val)) == -1)
			goto bad;
		val = proto->tcpbufsiz;
		if (setsockopt(s, SOL_SOCKET, SO_SNDBUF,
		    &val, sizeof(val)) == -1)
			goto bad;
	}

	/*
	 * IP options
	 */
	if (proto->tcpflags & TCPFLAG_IPTTL) {
		val = (int)proto->tcpipttl;
		switch (ss->ss_family) {
		case AF_INET:
			if (setsockopt(s, IPPROTO_IP, IP_TTL,
			    &val, sizeof(val)) == -1)
				goto bad;
			break;
		case AF_INET6:
			if (setsockopt(s, IPPROTO_IPV6, IPV6_UNICAST_HOPS,
			    &val, sizeof(val)) == -1)
				goto bad;
			break;
		}
	}
	if (proto->tcpflags & TCPFLAG_IPMINTTL) {
		val = (int)proto->tcpipminttl;
		switch (ss->ss_family) {
		case AF_INET:
			if (setsockopt(s, IPPROTO_IP, IP_MINTTL,
			    &val, sizeof(val)) == -1)
				goto bad;
			break;
		case AF_INET6:
			if (setsockopt(s, IPPROTO_IPV6, IPV6_MINHOPCOUNT,
			    &val, sizeof(val)) == -1)
				goto bad;
			break;
		}
	}

	return (s);

 bad:
	if (s != -1)
		close(s);
	return (-1);
}

void
relay_udp_response(int fd, short sig, void *arg)
{
	struct rsession		*con = arg;
	struct relay		*rlay = con->se_relay;
	struct protocol		*proto = rlay->rl_proto;
	void			*priv = NULL;
	struct sockaddr_storage	 ss;
	u_int8_t		 buf[IBUF_READ_SIZE];
	ssize_t			 len;
	socklen_t		 slen;

	if (sig == EV_TIMEOUT) {
		relay_udp_timeout(fd, sig, arg);
		return;
	}

	if (relay_sessions >= RELAY_MAX_SESSIONS ||
	    rlay->rl_conf.flags & F_DISABLE)
		return;

	slen = sizeof(ss);
	if ((len = recvfrom(fd, buf, sizeof(buf), 0,
	    (struct sockaddr*)&ss, &slen)) < 1)
		return;

	/* Parse and validate the packet header */
	if (proto->validate != NULL &&
	    (priv = (*proto->validate)(con, rlay, &ss, buf, len)) == NULL)
		return;

	relay_close(con, "unknown response");
	free(priv);
}

void
relay_udp_server(int fd, short sig, void *arg)
{
	struct privsep *ps = env->sc_ps;
	struct relay *rlay = arg;
	struct protocol *proto = rlay->rl_proto;
	struct rsession *con = NULL;
	struct ctl_natlook *cnl = NULL;
	socklen_t slen;
	struct timeval tv;
	struct sockaddr_storage ss;
	u_int8_t buf[IBUF_READ_SIZE];
	void *priv = NULL;
	ssize_t len;

	event_add(&rlay->rl_ev, NULL);

	if (relay_sessions >= RELAY_MAX_SESSIONS ||
	    rlay->rl_conf.flags & F_DISABLE)
		return;

	slen = sizeof(ss);
	if ((len = recvfrom(fd, buf, sizeof(buf), 0,
	    (struct sockaddr*)&ss, &slen)) < 1)
		return;

	if (proto->validate != NULL &&
	    (priv = (*proto->validate)(NULL, rlay, &ss, buf, len)) == NULL)
		return;

	if ((con = calloc(1, sizeof(*con))) == NULL) {
		free(priv);
		return;
	}

	/*
	 * Replace the DNS request Id with a random Id.
	 */
	con->se_priv = priv;
	con->se_in.s = -1;
	con->se_out.s = -1;
	con->se_in.dst = &con->se_out;
	con->se_out.dst = &con->se_in;
	con->se_in.con = con;
	con->se_out.con = con;
	con->se_relay = rlay;
	con->se_id = ++relay_conid;
	con->se_in.dir = RELAY_DIR_REQUEST;
	con->se_out.dir = RELAY_DIR_RESPONSE;
	con->se_retry = rlay->rl_conf.dstretry;
	con->se_out.port = rlay->rl_conf.dstport;
	switch (ss.ss_family) {
	case AF_INET:
		con->se_in.port = ((struct sockaddr_in *)&ss)->sin_port;
		break;
	case AF_INET6:
		con->se_in.port = ((struct sockaddr_in6 *)&ss)->sin6_port;
		break;
	}
	bcopy(&ss, &con->se_in.ss, sizeof(con->se_in.ss));

	getmonotime(&con->se_tv_start);
	bcopy(&con->se_tv_start, &con->se_tv_last, sizeof(con->se_tv_last));

	relay_sessions++;
	SPLAY_INSERT(session_tree, &rlay->rl_sessions, con);
	relay_session_publish(con);

	/* Increment the per-relay session counter */
	rlay->rl_stats[ps->ps_instance].last++;

	/* Pre-allocate output buffer */
	con->se_out.output = evbuffer_new();
	if (con->se_out.output == NULL) {
		relay_close(con, "failed to allocate output buffer");
		return;
	}

	/* Pre-allocate log buffer */
	con->se_haslog = 0;
	con->se_log = evbuffer_new();
	if (con->se_log == NULL) {
		relay_close(con, "failed to allocate log buffer");
		return;
	}

	if (rlay->rl_conf.flags & F_NATLOOK) {
		if ((cnl = calloc(1, sizeof(*cnl))) == NULL) {
			relay_close(con, "failed to allocate natlookup");
			return;
		}
	}

	/* Save the received data */
	if (evbuffer_add(con->se_out.output, buf, len) == -1) {
		relay_close(con, "failed to store buffer");
		free(cnl);
		return;
	}

	if (cnl != NULL) {
		con->se_cnl = cnl;
		bzero(cnl, sizeof(*cnl));
		cnl->in = -1;
		cnl->id = con->se_id;
		cnl->proc = ps->ps_instance;
		cnl->proto = IPPROTO_UDP;
		bcopy(&con->se_in.ss, &cnl->src, sizeof(cnl->src));
		bcopy(&rlay->rl_conf.ss, &cnl->dst, sizeof(cnl->dst));
		proc_compose(env->sc_ps, PROC_PFE,
		    IMSG_NATLOOK, cnl, sizeof(*cnl));

		/* Schedule timeout */
		evtimer_set(&con->se_ev, relay_natlook, con);
		bcopy(&rlay->rl_conf.timeout, &tv, sizeof(tv));
		evtimer_add(&con->se_ev, &tv);
		return;
	}

	relay_session(con);
}

void
relay_udp_timeout(int fd, short sig, void *arg)
{
	struct rsession		*con = arg;

	if (sig != EV_TIMEOUT)
		fatalx("invalid timeout event");

	relay_close(con, "udp timeout");
}

/*
 * Domain Name System support
 */

struct relay_dns_priv {
	u_int16_t	dp_inkey;
	u_int16_t	dp_outkey;
};

struct relay_dnshdr {
	u_int16_t	dns_id;

	u_int8_t	dns_flags0;
#define  DNS_F0_QR	0x80		/* response flag */
#define  DNS_F0_OPCODE	0x78		/* message type */
#define  DNS_F0_AA	0x04		/* authorative answer */
#define  DNS_F0_TC	0x02		/* truncated message */
#define  DNS_F0_RD	0x01		/* recursion desired */

	u_int8_t	dns_flags1;
#define  DNS_F1_RA	0x80		/* recursion available */
#define  DNS_F1_RES	0x40		/* reserved */
#define  DNS_F1_AD	0x20		/* authentic data */
#define  DNS_F1_CD	0x10		/* checking disabled */
#define  DNS_F1_RCODE	0x0f		/* response code */

	u_int16_t	dns_qdcount;
	u_int16_t	dns_ancount;
	u_int16_t	dns_nscount;
	u_int16_t	dns_arcount;
} __packed;

void
relay_dns_log(struct rsession *con, u_int8_t *buf, size_t len)
{
	struct relay_dnshdr	*hdr = (struct relay_dnshdr *)buf;

	/* Validate the header length */
	if (len < sizeof(*hdr)) {
		log_debug("%s: session %d: short dns packet", __func__,
		    con->se_id);
		return;
	}

	log_debug("%s: session %d: %s id 0x%x "
	    "flags 0x%x:0x%x qd %u an %u ns %u ar %u", __func__,
	    con->se_id,
	    hdr->dns_flags0 & DNS_F0_QR ? "response" : "request",
	    ntohs(hdr->dns_id),
	    hdr->dns_flags0,
	    hdr->dns_flags1,
	    ntohs(hdr->dns_qdcount),
	    ntohs(hdr->dns_ancount),
	    ntohs(hdr->dns_nscount),
	    ntohs(hdr->dns_arcount));
}

void *
relay_dns_validate(struct rsession *con, struct relay *rlay,
    struct sockaddr_storage *ss, u_int8_t *buf, size_t len)
{
	struct relay_dnshdr	*hdr = (struct relay_dnshdr *)buf;
	struct rsession		 lookup;
	u_int16_t		 key;
	struct relay_dns_priv	*priv, lpriv;

	/* Validate the header length */
	if (len < sizeof(*hdr))
		return (NULL);

	key = ntohs(hdr->dns_id);

	/*
	 * Check if the header has the response flag set, otherwise
	 * return 0 to tell the UDP server to create a new session.
	 */
	if ((hdr->dns_flags0 & DNS_F0_QR) == 0) {
		priv = malloc(sizeof(struct relay_dns_priv));
		if (priv == NULL)
			return (NULL);
		priv->dp_inkey = shuffle_generate16(&relay_shuffle);
		priv->dp_outkey = key;
		return ((void *)priv);
	}

	/*
	 * Lookup if this response is for a known session and if the
	 * remote host matches the original destination of the request.
	 */
	if (con == NULL) {
		lpriv.dp_inkey = key;
		lookup.se_priv = &lpriv;
		if ((con = SPLAY_FIND(session_tree,
		    &rlay->rl_sessions, &lookup)) != NULL &&
		    con->se_priv != NULL &&
		    relay_cmp_af(ss, &con->se_out.ss) == 0)
			relay_dns_result(con, buf, len);
	} else {
		priv = con->se_priv;
		if (priv == NULL || key != priv->dp_inkey) {
			relay_close(con, "invalid response");
			return (NULL);
		}
		relay_dns_result(con, buf, len);
	}

	/*
	 * This is not a new session, ignore it in the UDP server.
	 */
	return (NULL);
}

int
relay_dns_request(struct rsession *con)
{
	struct relay		*rlay = con->se_relay;
	struct relay_dns_priv	*priv = con->se_priv;
	u_int8_t		*buf = EVBUFFER_DATA(con->se_out.output);
	size_t			 len = EVBUFFER_LENGTH(con->se_out.output);
	struct relay_dnshdr	*hdr;
	socklen_t		 slen;

	if (buf == NULL || priv == NULL || len < 1)
		return (-1);
	if (log_getverbose() > 1)
		relay_dns_log(con, buf, len);

	getmonotime(&con->se_tv_start);

	if (!TAILQ_EMPTY(&rlay->rl_tables)) {
		if (relay_from_table(con) != 0)
			return (-1);
	} else if (con->se_out.ss.ss_family == AF_UNSPEC) {
		bcopy(&rlay->rl_conf.dstss, &con->se_out.ss,
		    sizeof(con->se_out.ss));
		con->se_out.port = rlay->rl_conf.dstport;
	}

	if ((con->se_out.s = relay_udp_socket(&con->se_out.ss,
	    con->se_out.port, rlay->rl_proto)) == -1)
		return (-1);
	slen = con->se_out.ss.ss_len;

	hdr = (struct relay_dnshdr *)buf;
	hdr->dns_id = htons(priv->dp_inkey);

 retry:
	if (sendto(con->se_out.s, buf, len, 0,
	    (struct sockaddr *)&con->se_out.ss, slen) == -1) {
		if (con->se_retry) {
			con->se_retry--;
			log_debug("%s: session %d: "
			    "forward failed: %s, %s", __func__,
			    con->se_id, strerror(errno),
			    con->se_retry ? "next retry" : "last retry");
			goto retry;
		}
		log_debug("%s: session %d: forward failed: %s", __func__,
		    con->se_id, strerror(errno));
		return (-1);
	}

	event_again(&con->se_ev, con->se_out.s, EV_TIMEOUT|EV_READ,
	    relay_udp_response, &con->se_tv_start, &rlay->rl_conf.timeout, con);

	return (0);
}

void
relay_dns_result(struct rsession *con, u_int8_t *buf, size_t len)
{
	struct relay		*rlay = con->se_relay;
	struct relay_dns_priv	*priv = con->se_priv;
	struct relay_dnshdr	*hdr;
	socklen_t		 slen;

	if (priv == NULL)
		fatalx("%s: response to invalid session", __func__);

	if (log_getverbose() > 1)
		relay_dns_log(con, buf, len);

	/*
	 * Replace the random DNS request Id with the original Id
	 */
	hdr = (struct relay_dnshdr *)buf;
	hdr->dns_id = htons(priv->dp_outkey);

	slen = con->se_out.ss.ss_len;
	if (sendto(rlay->rl_s, buf, len, 0,
	    (struct sockaddr *)&con->se_in.ss, slen) == -1) {
		relay_close(con, "response failed");
		return;
	}

	relay_close(con, "session closed");
}

int
relay_dns_cmp(struct rsession *a, struct rsession *b)
{
	struct relay_dns_priv	*ap = a->se_priv;
	struct relay_dns_priv	*bp = b->se_priv;

	if (ap == NULL || bp == NULL)
		fatalx("%s: invalid session", __func__);

	return (memcmp(&ap->dp_inkey, &bp->dp_inkey, sizeof(u_int16_t)));
}
@


1.46
log
@use __func__ in log messages. fix some whitespace while here.
From Hiltjo Posthuma hiltjo -AT codemadness -DOT- org, thanks!
ok florian, claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: relay_udp.c,v 1.45 2017/01/09 14:49:21 reyk Exp $	*/
d61 1
a61 1
relay_udp_privinit(struct relayd *x_env, struct relay *rlay)
a62 3
	if (env == NULL)
		env = x_env;

d69 1
a69 1
relay_udp_init(struct relay *rlay)
d72 3
@


1.45
log
@Stop accessing verbose and debug variables from log.c directly.

This replaces log_verbose() and "extern int verbose" with the two functions
log_setverbose() and log_getverbose().

Pointed out by benno@@
OK krw@@ eric@@ gilles@@ (OK gilles@@ for the snmpd bits as well)
@
text
@d1 1
a1 1
/*	$OpenBSD: relay_udp.c,v 1.44 2016/11/10 13:21:58 jca Exp $	*/
d522 1
a522 1
		fatalx("relay_dns_result: response to invalid session");
d550 1
a550 1
		fatalx("relay_dns_cmp: invalid session");
@


1.44
log
@Fix tcp ip ttl / minttl on IPv6 sockets.

ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay_udp.c,v 1.43 2016/09/02 14:31:47 reyk Exp $	*/
a41 1
extern int debug;
d469 1
a469 1
	if (debug)
d524 1
a524 1
	if (debug)
@


1.43
log
@proc_id has been replaced by ps->ps_instance.

OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay_udp.c,v 1.42 2015/12/07 04:03:27 mmcc Exp $	*/
d141 12
a152 3
		if (setsockopt(s, IPPROTO_IP, IP_TTL,
		    &val, sizeof(val)) == -1)
			goto bad;
d156 12
a167 3
		if (setsockopt(s, IPPROTO_IP, IP_MINTTL,
		    &val, sizeof(val)) == -1)
			goto bad;
@


1.42
log
@Remove NULL-checks before free(). No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: relay_udp.c,v 1.41 2015/12/02 13:41:27 reyk Exp $	*/
a41 1
extern int proc_id;
d198 1
d264 1
a264 1
	rlay->rl_stats[proc_id].last++;
d300 1
a300 1
		cnl->proc = proc_id;
@


1.41
log
@In most cases we don't need all arguments of proc_compose*_imsg(),
so add a shortcut proc_compose*() that skips all of them.  Only use the
full argument list if needed.  The functions with full argument lists can
eventually be replaced with a nicer transaction-based approach later.

OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay_udp.c,v 1.40 2015/11/28 09:52:07 reyk Exp $	*/
d193 1
a193 2
	if (priv != NULL)
		free(priv);
d291 1
a291 2
		if (cnl != NULL)
			free(cnl);
@


1.40
log
@Use SOCK_NONBLOCK in relayd as well.

OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay_udp.c,v 1.39 2015/01/22 17:42:09 reyk Exp $	*/
d306 2
a307 2
		proc_compose_imsg(env->sc_ps, PROC_PFE, -1,
		    IMSG_NATLOOK, -1, cnl, sizeof(*cnl));
@


1.39
log
@Clean up the relayd headers with help of include-what-you-use and some
manual review.  Based on common practice, relayd.h now includes the
necessary headers for itself.

OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay_udp.c,v 1.38 2015/01/16 15:06:40 deraadt Exp $	*/
d119 2
a120 1
	if ((s = socket(ss->ss_family, SOCK_DGRAM, IPPROTO_UDP)) == -1)
a125 2
	if (fcntl(s, F_SETFL, O_NONBLOCK) == -1)
		goto bad;
@


1.38
log
@Adapt to <limits.h> universe.
ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: relay_udp.c,v 1.37 2014/12/21 00:54:49 guenther Exp $	*/
a21 1
#include <sys/stat.h>
a22 1
#include <sys/un.h>
a24 1
#include <net/if.h>
d26 1
a26 2
#include <netinet/ip.h>
#include <netinet/tcp.h>
a34 2
#include <err.h>
#include <pwd.h>
d36 1
a36 3
#include <fnmatch.h>

#include <openssl/ssl.h>
@


1.37
log
@Stop pulling in <arpa/inet.h> or <arpa/nameser.h> when unnecessary.
*Do* pull it in when in_{port,addr}_h is needed and <netinet/in.h> isn't.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay_udp.c,v 1.36 2014/12/18 20:55:01 reyk Exp $	*/
d32 1
@


1.36
log
@Update relayd to use siphash instead of sys/hash.  The source-hash,
loadbalance and hash modes use a random key by default that can be
forced to be a static key with a new configuration argument.

With input from Max Fillinger.

ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay_udp.c,v 1.35 2014/12/12 10:05:09 reyk Exp $	*/
a30 1
#include <arpa/inet.h>
@


1.35
log
@Change the keyword "ssl" to "tls" to reflect reality since we
effectively disabled support for the SSL protocols.  SSL remains a
common term describing SSL/TLS, there is some controvery about this
change, and the name really doesn't matter, but I feel confident about
it now.

(btw., sthen@@ pointed out some historical context:
http://tim.dierks.org/2014/05/security-standards-and-name-changes-in.html)

OK benno@@, with input from tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay_udp.c,v 1.34 2014/11/19 10:24:40 blambert Exp $	*/
a25 1
#include <sys/hash.h>
@


1.34
log
@Support exporting relayd statistics via AgentX/snmpd

This should be equivalent to the statistics available
via the various relaydctl show commands

okay benno@@ reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay_udp.c,v 1.33 2014/10/25 03:23:49 lteo Exp $	*/
d77 2
a78 2
	if (rlay->rl_conf.flags & F_SSL)
		fatalx("ssl over udp is not supported");
@


1.33
log
@Remove unnecessary netinet/in_systm.h include.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay_udp.c,v 1.32 2014/08/08 18:26:50 reyk Exp $	*/
d272 1
@


1.32
log
@No events were added for DNS UDP so it stopped working after the first
request.  Additionally, the DNS code tried to use an invalid timeout.

Fix from mm@@freebsd.org
Reported by Johan Schuijt
@
text
@d1 1
a1 1
/*	$OpenBSD: relay_udp.c,v 1.31 2014/07/13 00:32:08 benno Exp $	*/
a28 1
#include <netinet/in_systm.h>
@


1.31
log
@improve log output for relays. adjust regress tests
ok reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: relay_udp.c,v 1.30 2014/07/09 16:42:05 reyk Exp $	*/
d222 2
d503 1
a503 1
	    relay_udp_response, &con->se_tv_start, &env->sc_timeout, con);
@


1.30
log
@Replace the protocol directives for HTTP with a new generic filtering
language.  The grammar is inspired by pf and allows to write versatile
last-matching filter rules in protocol sections starting with the
"pass", "block" or "match" keywords.  This work was started almost two
years ago and replaces large parts of relayd(8)'s HTTP and filtering
code.  The initial version reimplements and extends HTTP filtering,
but will be improved to support generic TCP and other protocols later.

With some testing, feedback, and help from benno@@ and andre@@.

OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay_udp.c,v 1.29 2014/06/25 11:05:15 reyk Exp $	*/
d283 1
@


1.29
log
@sync copyright to reality according to my last changes
@
text
@d1 1
a1 1
/*	$OpenBSD: relay_udp.c,v 1.28 2013/03/10 23:32:53 reyk Exp $	*/
d55 1
a55 1
struct relayd *env = NULL;
a251 2
	con->se_in.tree = &proto->request_tree;
	con->se_out.tree = &proto->response_tree;
@


1.28
log
@This diff changes relayd to use the monotonic clock instead of
gettimeofday().  It was also bugging me for some time to have all
these checks of gettimeofday()'s return value: it should not fail.  So
this diff introduces a void getmonotime(struct timeval *tv) that calls
clock_gettime(CLOCK_MONOTONIC, &ts) and converts the output to a
struct timeval that can be used with the existing code and the
timeval-specific timer functions (timerclear, timersub, ...).  It does
not return a status but calls fatal() on error-that-should-not-happen.

ok sthen@@ chris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay_udp.c,v 1.27 2013/01/17 20:34:18 bluhm Exp $	*/
d4 1
a4 1
 * Copyright (c) 2007, 2008 Reyk Floeter <reyk@@openbsd.org>
@


1.27
log
@Remove unnecessary pointer casts.  No binary diff.
OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay_udp.c,v 1.26 2012/12/18 15:36:43 reyk Exp $	*/
a256 9

	if (gettimeofday(&con->se_tv_start, NULL) == -1) {
		free(con);
		free(priv);
		return;
	}

	bcopy(&con->se_tv_start, &con->se_tv_last, sizeof(con->se_tv_last));
	bcopy(&ss, &con->se_in.ss, sizeof(con->se_in.ss));
d266 4
d466 1
a466 2
	if (gettimeofday(&con->se_tv_start, NULL) == -1)
		return (-1);
@


1.26
log
@cnl is only allocated if F_NATLOOK was specified before, so skip the
extra check for F_NATLOOK and check if cnl is not NULL only.
no functional change, but this might make it clear that there is no and
was no memleak here.
@
text
@d1 1
a1 1
/*	$OpenBSD: relay_udp.c,v 1.25 2012/10/03 08:33:31 reyk Exp $	*/
d175 1
a175 1
	struct rsession		*con = (struct rsession *)arg;
d211 1
a211 1
	struct relay *rlay = (struct relay *)arg;
d235 1
a235 2
	if ((con = (struct rsession *)
	    calloc(1, sizeof(struct rsession))) == NULL) {
d297 1
a297 2
		if ((cnl = (struct ctl_natlook *)
		    calloc(1, sizeof(struct ctl_natlook))) == NULL) {
d336 1
a336 1
	struct rsession		*con = (struct rsession *)arg;
d442 1
a442 1
		priv = (struct relay_dns_priv *)con->se_priv;
d459 2
a460 2
	struct relay		*rlay = (struct relay *)con->se_relay;
	struct relay_dns_priv	*priv = (struct relay_dns_priv *)con->se_priv;
d516 2
a517 2
	struct relay		*rlay = (struct relay *)con->se_relay;
	struct relay_dns_priv	*priv = (struct relay_dns_priv *)con->se_priv;
d546 2
a547 2
	struct relay_dns_priv	*ap = (struct relay_dns_priv *)a->se_priv;
	struct relay_dns_priv	*bp = (struct relay_dns_priv *)b->se_priv;
@


1.25
log
@Support more than one relay backup table.  Instead of duplicating the
code for main and backup table all over the place, turn the relay
tables into a list attached to the relay.  This improves the code and
allows some other tricks with multiple tables later.
@
text
@d1 1
a1 1
/*	$OpenBSD: relay_udp.c,v 1.24 2011/05/09 12:08:47 reyk Exp $	*/
d313 1
a313 1
	if (rlay->rl_conf.flags & F_NATLOOK && cnl != NULL) {
@


1.24
log
@Reorganize the relayd code to use the proc.c privsep API/commodity
functions that are based on work for iked and smtpd.  This simplifies
the setup of privsep processes and moves some redundant and repeated
code to a single place - which is always good from a quality and
security point of view.  The relayd version of proc.c is different to
the current version in iked because it uses 1:N communications between
processes, eg. a single parent process is talking to many forked relay
children while iked only needs 1:1 communications.

ok sthen@@ pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay_udp.c,v 1.23 2011/05/05 12:01:44 reyk Exp $	*/
a251 1
	con->se_hashkey = rlay->rl_dstkey;
d476 1
a476 1
	if (rlay->rl_dsttable != NULL) {
@


1.23
log
@Update all logging and debug functions to use the __func__ macro
instead of static function names.  __func__ is C99 and perfectly fine
to use. It also avoids printing errors; for example if a statement
log_debug("foo:"..) was moved or copied from function foo() to bar()
and the log message was not updated...
@
text
@d1 1
a1 1
/*	$OpenBSD: relay_udp.c,v 1.22 2010/05/26 13:56:08 nicm Exp $	*/
a52 1
extern struct imsgev *iev_pfe;
d323 2
a324 2
		imsg_compose_event(iev_pfe, IMSG_NATLOOK, 0, 0, -1, cnl,
		    sizeof(*cnl));
@


1.22
log
@Rename some imsg bits to make namespace collisions less likely buf to
ibuf, buf_read to ibuf_read, READ_BUF_SIZE to IBUF_READ_SIZE.

ok henning gilles claudio jacekm deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: relay_udp.c,v 1.21 2009/08/07 11:21:53 reyk Exp $	*/
d387 1
a387 1
		log_debug("relay_dns_log: session %d: short dns packet",
d392 2
a393 2
	log_debug("relay_dns_log: session %d: %s id 0x%x "
	    "flags 0x%x:0x%x qd %u an %u ns %u ar %u",
d500 2
a501 2
			log_debug("relay_dns_request: session %d: "
			    "forward failed: %s, %s",
d506 1
a506 1
		log_debug("relay_dns_request: session %d: forward failed: %s",
@


1.21
log
@rename 'struct session' to 'struct rsession' because it conflicts with
another 'struct session' in sys/sysctl.h.
@
text
@d1 1
a1 1
/*	$OpenBSD: relay_udp.c,v 1.20 2009/06/05 23:39:51 pyr Exp $	*/
d181 1
a181 1
	u_int8_t		 buf[READ_BUF_SIZE];
d219 1
a219 1
	u_int8_t buf[READ_BUF_SIZE];
@


1.20
log
@4 handed diff with eric:
Stop pushing event handling in the imsg framework.
Instead, provide a small glue layer on top of both imsg and libevent.
This finally clearly separates event handling and imsg construction.

Sidetrack bonus: remove the mega-ugly hack of having a dummy imsg_event_add
stub in relayctl.

This will make bgpd (and thus henning) happy. Next up are smtpd and ospfd.

ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay_udp.c,v 1.19 2009/06/05 00:04:01 pyr Exp $	*/
d61 1
a61 1
void		 relay_udp_request(struct session *);
d64 2
a65 2
void		 relay_dns_log(struct session *, u_int8_t *, size_t);
void		*relay_dns_validate(struct session *,
d68 1
a68 1
int		 relay_dns_request(struct session *);
d70 2
a71 2
void		 relay_dns_result(struct session *, u_int8_t *, size_t);
int		 relay_dns_cmp(struct session *, struct session *);
d176 1
a176 1
	struct session		*con = (struct session *)arg;
d214 1
a214 1
	struct session *con = NULL;
d236 2
a237 2
	if ((con = (struct session *)
	    calloc(1, sizeof(struct session))) == NULL) {
d340 1
a340 1
	struct session		*con = (struct session *)arg;
d381 1
a381 1
relay_dns_log(struct session *con, u_int8_t *buf, size_t len)
d406 1
a406 1
relay_dns_validate(struct session *con, struct relay *rlay,
d410 1
a410 1
	struct session		 lookup;
d461 1
a461 1
relay_dns_request(struct session *con)
d518 1
a518 1
relay_dns_result(struct session *con, u_int8_t *buf, size_t len)
d548 1
a548 1
relay_dns_cmp(struct session *a, struct session *b)
@


1.19
log
@Make imsg completely async model agnostic by not requiring an
imsg_event_add function to be provided (which ended up being a named
callback).
Instead provide a wrapper in the daemon and call that everywhere.
Previsously discussed with the usual suspects,
ok eric@@ though not too happy about the function name
(imsg_compose_event).
@
text
@d1 1
a1 1
/*	$OpenBSD: relay_udp.c,v 1.18 2008/09/29 15:12:22 reyk Exp $	*/
d53 1
a53 1
extern struct imsgbuf *ibuf_pfe;
d324 1
a324 1
		imsg_compose_event(ibuf_pfe, IMSG_NATLOOK, 0, 0, -1, cnl,
@


1.18
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: relay_udp.c,v 1.17 2008/08/08 08:51:21 thib Exp $	*/
d324 1
a324 1
		imsg_compose(ibuf_pfe, IMSG_NATLOOK, 0, 0, -1, cnl,
@


1.17
log
@Check gettimeofday() against -1; Add a missing error check in one place.

OK reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay_udp.c,v 1.16 2008/07/23 10:05:18 reyk Exp $	*/
d482 2
a483 1
		bcopy(&rlay->rl_conf.dstss, &con->se_out.ss, sizeof(con->se_out.ss));
@


1.16
log
@validate packet length in debug dns packet logging before printing the header.
@
text
@d1 1
a1 1
/*	$OpenBSD: relay_udp.c,v 1.15 2008/07/09 17:24:14 reyk Exp $	*/
d260 7
a266 1
	gettimeofday(&con->se_tv_start, NULL);
d475 1
a475 1
	if (gettimeofday(&con->se_tv_start, NULL))
@


1.15
log
@always verify that the received dns response id matches our request.
@
text
@d1 1
a1 1
/*	$OpenBSD: relay_udp.c,v 1.14 2008/07/09 17:16:51 reyk Exp $	*/
d64 1
a64 1
void		 relay_dns_log(struct session *, u_int8_t *);
d375 1
a375 1
relay_dns_log(struct session *con, u_int8_t *buf)
d379 7
d467 1
a467 1
		relay_dns_log(con, buf);
d522 1
a522 1
		relay_dns_log(con, buf);
@


1.14
log
@Use OpenBSD's knuth shuffle algorithm of random values from bind to
produce the DNS request ids instead of a simple per-request
arc4random().  This ensure randomness but also satisfies the
non-repeating property we need.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay_udp.c,v 1.13 2008/07/09 14:57:01 reyk Exp $	*/
d179 1
d201 1
a201 1
	    (*proto->validate)(con, rlay, &ss, buf, len) == NULL)
d203 4
d432 6
a437 1
	} else
d439 1
@


1.13
log
@also set the protocol, either TCP or UDP, in the NAT lookup.  this
unbreaks NAT lookups with UDP; tested as a transparent DNS relay.
@
text
@d1 1
a1 1
/*	$OpenBSD: relay_udp.c,v 1.12 2008/07/09 10:50:34 reyk Exp $	*/
d57 1
a75 2
	struct protocol		*proto = rlay->rl_proto;

d82 6
d94 1
d410 1
a410 1
		priv->dp_inkey = arc4random() & 0xffff;
@


1.12
log
@update the relay dns code to open a new udp socket to send the
forwarded dns request to the server instead of sending from the server
socket.  this will fix the limitation the the dns relay had to listen
to the "0.0.0.0" address, and will also enable relayd to use the udp
source port randomization. relayd will know randomize the source port
(on OpenBSD) and DNS request identifier for the clients behind it.

ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay_udp.c,v 1.11 2008/05/08 02:27:58 reyk Exp $	*/
d304 1
@


1.11
log
@move the session keys used by dns in a protocol-specific private ptr.
@
text
@d1 1
a1 1
/*	$OpenBSD: relay_udp.c,v 1.10 2008/03/03 16:43:42 reyk Exp $	*/
d64 2
a65 1
void		*relay_dns_validate(struct relay *, struct sockaddr_storage *,
d68 2
a69 1
void		 relay_dns_response(struct session *, u_int8_t *, size_t);
d168 31
a220 1
	/* Parse and validate the packet header */
d222 1
a222 1
	    (priv = (*proto->validate)(rlay, &ss, buf, len)) == NULL)
d381 2
a382 2
relay_dns_validate(struct relay *rlay, struct sockaddr_storage *ss,
    u_int8_t *buf, size_t len)
d385 1
a385 1
	struct session		*con, lookup;
d412 10
a421 6
	lpriv.dp_inkey = key;
	lookup.se_priv = &lpriv;
	if ((con = SPLAY_FIND(session_tree,
	    &rlay->rl_sessions, &lookup)) != NULL && con->se_priv != NULL &&
	    relay_cmp_af(ss, &con->se_out.ss) == 0)
		relay_dns_response(con, buf, len);
d455 2
a456 1
	if (relay_socket_af(&con->se_out.ss, con->se_out.port) == -1)
d464 1
a464 1
	if (sendto(rlay->rl_s, buf, len, 0,
d479 2
a480 2
	event_again(&con->se_ev, con->se_out.s, EV_TIMEOUT,
	    relay_udp_timeout, &con->se_tv_start, &env->sc_timeout, con);
d486 1
a486 1
relay_dns_response(struct session *con, u_int8_t *buf, size_t len)
d494 1
a494 1
		fatalx("relay_dns_response: response to invalid session");
@


1.10
log
@The fix removes the replacement of se_key from relay_dns_request. se_key
is assigned a random value for and id in relay_udp_server before where
the SPLAY_INSERT is performed, se_outkey is set to the return id rather
than the rl_dskkey. The relay_dns_request which occurs after the
SPLAY_INSERT no longer updates se_outkey, or se_key. The request is sent
using the random value already placed into the se_key when the session
is created.

From Nigel Taylor

ok pyr@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay_udp.c,v 1.9 2008/02/13 11:32:59 reyk Exp $	*/
d64 2
a65 2
int		 relay_dns_validate(struct relay *, struct sockaddr_storage *,
		    u_int8_t *, size_t, u_int32_t *);
d176 1
a176 1
	u_int32_t key = 0;
d190 1
a190 1
	    (*proto->validate)(rlay, &ss, buf, len, &key) != 0)
d194 2
a195 1
	    calloc(1, sizeof(struct session))) == NULL)
d197 1
d202 1
a202 1
	con->se_key = arc4random() & 0xffff;
d210 1
a211 1
	con->se_outkey = key;
d302 5
d348 1
a348 1
int
d350 1
a350 1
    u_int8_t *buf, size_t len, u_int32_t *key)
d354 2
d359 1
a359 1
		return (-1);
d361 1
a361 1
	*key = ntohs(hdr->dns_id);
d367 8
a374 2
	if ((hdr->dns_flags0 & DNS_F0_QR) == 0)
		return (0);
d380 2
a381 1
	lookup.se_key = *key;
d383 1
a383 1
	    &rlay->rl_sessions, &lookup)) != NULL &&
d390 1
a390 1
	return (-1);
d397 1
d403 1
a403 1
	if (buf == NULL || len < 1)
d424 1
a424 1
	hdr->dns_id = htons(con->se_key);
d452 1
d456 3
d466 1
a466 1
	hdr->dns_id = htons(con->se_outkey);
d481 7
a487 1
	return (memcmp(&a->se_key, &b->se_key, sizeof(a->se_key)));
@


1.9
log
@bump copyright
@
text
@d1 1
a1 1
/*	$OpenBSD: relay_udp.c,v 1.8 2008/02/04 12:12:30 thib Exp $	*/
d197 4
a200 1
	con->se_key = key;
d209 1
a209 1
	con->se_outkey = rlay->rl_dstkey;
a405 3
	/*
	 * Replace the DNS request Id with a random Id.
	 */
a406 2
	con->se_outkey = con->se_key;
	con->se_key = arc4random() & 0xffff;
@


1.8
log
@Move some prototypes from relay.c to relayd.h and remove there externs
in other places;

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay_udp.c,v 1.7 2008/01/31 12:12:50 thib Exp $	*/
d4 1
a4 1
 * Copyright (c) 2007 Reyk Floeter <reyk@@openbsd.org>
@


1.7
log
@add prefixes to names of structure elements to make it easier to grep
for code, next struct session;

ok reyk@@;
@
text
@d1 1
a1 1
/*	$OpenBSD: relay_udp.c,v 1.6 2008/01/31 09:56:28 reyk Exp $	*/
a54 8

extern void	 relay_close(struct session *, const char *);
extern void	 relay_natlook(int, short, void *);
extern void	 relay_session(struct session *);
extern int	 relay_from_table(struct session *);
extern int	 relay_socket_af(struct sockaddr_storage *, in_port_t);
extern int	 relay_cmp_af(struct sockaddr_storage *,
		    struct sockaddr_storage *);
@


1.6
log
@add prefixes to names of structure elements to make it easier to grep
for code, next struct relay.  knf long line fixes will follow later.

ok thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay_udp.c,v 1.5 2008/01/31 09:33:39 reyk Exp $	*/
d205 19
a223 19
	con->key = key;
	con->in.s = -1;
	con->out.s = -1;
	con->in.dst = &con->out;
	con->out.dst = &con->in;
	con->in.con = con;
	con->out.con = con;
	con->relay = rlay;
	con->id = ++relay_conid;
	con->outkey = rlay->rl_dstkey;
	con->in.tree = &proto->request_tree;
	con->out.tree = &proto->response_tree;
	con->in.dir = RELAY_DIR_REQUEST;
	con->out.dir = RELAY_DIR_RESPONSE;
	con->retry = rlay->rl_conf.dstretry;
	gettimeofday(&con->tv_start, NULL);
	bcopy(&con->tv_start, &con->tv_last, sizeof(con->tv_last));
	bcopy(&ss, &con->in.ss, sizeof(con->in.ss));
	con->out.port = rlay->rl_conf.dstport;
d226 1
a226 1
		con->in.port = ((struct sockaddr_in *)&ss)->sin_port;
d229 1
a229 1
		con->in.port = ((struct sockaddr_in6 *)&ss)->sin6_port;
d240 2
a241 2
	con->out.output = evbuffer_new();
	if (con->out.output == NULL) {
d247 2
a248 2
	con->log = evbuffer_new();
	if (con->log == NULL) {
d262 1
a262 1
	if (evbuffer_add(con->out.output, buf, len) == -1) {
d270 1
a270 1
		con->cnl = cnl;;
d273 1
a273 1
		cnl->id = con->id;
d275 1
a275 1
		bcopy(&con->in.ss, &cnl->src, sizeof(cnl->src));
d281 1
a281 1
		evtimer_set(&con->ev, relay_natlook, con);
d283 1
a283 1
		evtimer_add(&con->ev, &tv);
d335 1
a335 1
	    con->id,
d370 1
a370 1
	lookup.key = *key;
d373 1
a373 1
	    relay_cmp_af(ss, &con->out.ss) == 0)
d385 3
a387 3
	struct relay		*rlay = (struct relay *)con->relay;
	u_int8_t		*buf = EVBUFFER_DATA(con->out.output);
	size_t			 len = EVBUFFER_LENGTH(con->out.output);
d396 1
a396 1
	if (gettimeofday(&con->tv_start, NULL))
d402 3
a404 3
	} else if (con->out.ss.ss_family == AF_UNSPEC) {
		bcopy(&rlay->rl_conf.dstss, &con->out.ss, sizeof(con->out.ss));
		con->out.port = rlay->rl_conf.dstport;
d407 1
a407 1
	if (relay_socket_af(&con->out.ss, con->out.port) == -1)
d409 1
a409 1
	slen = con->out.ss.ss_len;
d415 3
a417 3
	con->outkey = con->key;
	con->key = arc4random() & 0xffff;
	hdr->dns_id = htons(con->key);
d421 3
a423 3
	    (struct sockaddr *)&con->out.ss, slen) == -1) {
		if (con->retry) {
			con->retry--;
d426 2
a427 2
			    con->id, strerror(errno),
			    con->retry ? "next retry" : "last retry");
d431 1
a431 1
		    con->id, strerror(errno));
d435 2
a436 2
	event_again(&con->ev, con->out.s, EV_TIMEOUT,
	    relay_udp_timeout, &con->tv_start, &env->sc_timeout, con);
d444 1
a444 1
	struct relay		*rlay = (struct relay *)con->relay;
d455 1
a455 1
	hdr->dns_id = htons(con->outkey);
d457 1
a457 1
	slen = con->out.ss.ss_len;
d459 1
a459 1
	    (struct sockaddr *)&con->in.ss, slen) == -1) {
d470 1
a470 1
	return (memcmp(&a->key, &b->key, sizeof(a->key)));
@


1.5
log
@add prefixes to names of structure elements to make it easier to grep
for code, start with struct relayd.  finally.

ok thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay_udp.c,v 1.4 2008/01/29 16:36:04 reyk Exp $	*/
d81 1
a81 1
	struct protocol		*proto = rlay->proto;
d86 1
a86 1
	if (rlay->conf.flags & F_SSL)
d88 1
a88 1
	rlay->conf.flags |= F_UDP;
d177 1
a177 1
	struct protocol *proto = rlay->proto;
d188 1
a188 1
	    rlay->conf.flags & F_DISABLE)
d214 1
a214 1
	con->outkey = rlay->dstkey;
d219 1
a219 1
	con->retry = rlay->conf.dstretry;
d223 1
a223 1
	con->out.port = rlay->conf.dstport;
d234 1
a234 1
	SPLAY_INSERT(session_tree, &rlay->sessions, con);
d237 1
a237 1
	rlay->stats[proc_id].last++;
d253 1
a253 1
	if (rlay->conf.flags & F_NATLOOK) {
d269 1
a269 1
	if (rlay->conf.flags & F_NATLOOK && cnl != NULL) {
d276 1
a276 1
		bcopy(&rlay->conf.ss, &cnl->dst, sizeof(cnl->dst));
d282 1
a282 1
		bcopy(&rlay->conf.timeout, &tv, sizeof(tv));
d372 1
a372 1
	    &rlay->sessions, &lookup)) != NULL &&
d399 1
a399 1
	if (rlay->dsttable != NULL) {
d403 2
a404 2
		bcopy(&rlay->conf.dstss, &con->out.ss, sizeof(con->out.ss));
		con->out.port = rlay->conf.dstport;
d420 1
a420 1
	if (sendto(rlay->s, buf, len, 0,
d458 1
a458 1
	if (sendto(rlay->s, buf, len, 0,
@


1.4
log
@relayd(8) may lose memory allocate to varaible `cnl' (struct
ctl_natlook).  Free `cnl' allocated memory on failure.

From Igor Zinovik (zinovik at cs.karelia dot ru)
@
text
@d1 1
a1 1
/*	$OpenBSD: relay_udp.c,v 1.3 2007/12/07 17:17:01 reyk Exp $	*/
d436 1
a436 1
	    relay_udp_timeout, &con->tv_start, &env->timeout, con);
@


1.3
log
@hoststated gets renamed to relayd.  easier to type, and actually says
what the daemon does - it is a relayer that pays attention to the status
of pools of hosts; not a status checkers that happens to do some relaying
@
text
@d1 1
a1 1
/*	$OpenBSD: relay_udp.c,v 1.2 2007/11/24 17:07:28 reyk Exp $	*/
d264 2
@


1.2
log
@sort includes, adjust to style(9)
@
text
@d1 1
a1 1
/*	$OpenBSD: relay_udp.c,v 1.1 2007/09/10 11:59:22 reyk Exp $	*/
d48 1
a48 1
#include "hoststated.h"
d64 1
a64 1
struct hoststated *env = NULL;
d79 1
a79 1
relay_udp_privinit(struct hoststated *x_env, struct relay *rlay)
@


1.1
log
@add support for relaying DNS traffic (with a little bit of packet
header randomization). this adds an infrastructure to support
UDP-based protocols.

ok gilles@@, tested by some
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d19 1
a20 2
#include <sys/param.h>
#include <sys/types.h>
d28 1
a32 1
#include <net/if.h>
@

