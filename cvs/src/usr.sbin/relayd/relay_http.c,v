head	1.66;
access;
symbols
	OPENBSD_6_1:1.64.0.4
	OPENBSD_6_1_BASE:1.64
	OPENBSD_6_0:1.56.0.2
	OPENBSD_6_0_BASE:1.56
	OPENBSD_5_9:1.55.0.2
	OPENBSD_5_9_BASE:1.55
	OPENBSD_5_8:1.52.0.4
	OPENBSD_5_8_BASE:1.52
	OPENBSD_5_7:1.43.0.2
	OPENBSD_5_7_BASE:1.43
	OPENBSD_5_6:1.32.0.4
	OPENBSD_5_6_BASE:1.32
	OPENBSD_5_5:1.16.0.4
	OPENBSD_5_5_BASE:1.16
	OPENBSD_5_4:1.15.0.2
	OPENBSD_5_4_BASE:1.15
	OPENBSD_5_3:1.9.0.2
	OPENBSD_5_3_BASE:1.9;
locks; strict;
comment	@ * @;


1.66
date	2017.05.28.10.39.15;	author benno;	state Exp;
branches;
next	1.65;
commitid	IW4LnWyG3CPq6c3r;

1.65
date	2017.05.27.08.33.25;	author claudio;	state Exp;
branches;
next	1.64;
commitid	mLnU8nnW1ZLoAWRU;

1.64
date	2017.03.10.21.04.35;	author reyk;	state Exp;
branches;
next	1.63;
commitid	oP9RykeSEQ0x1sAU;

1.63
date	2016.09.26.16.25.16;	author reyk;	state Exp;
branches;
next	1.62;
commitid	VU3xx6ZIlSCM7y2e;

1.62
date	2016.08.01.21.25.53;	author benno;	state Exp;
branches;
next	1.61;
commitid	VrefoTHr5hxcCjov;

1.61
date	2016.08.01.21.14.45;	author benno;	state Exp;
branches;
next	1.60;
commitid	l4KqASYHmTegHhxt;

1.60
date	2016.07.29.10.09.26;	author reyk;	state Exp;
branches;
next	1.59;
commitid	cXyFVrZtyIYivR44;

1.59
date	2016.07.29.10.00.12;	author reyk;	state Exp;
branches;
next	1.58;
commitid	ns1VHKheNdQL2F8X;

1.58
date	2016.07.27.11.02.41;	author reyk;	state Exp;
branches;
next	1.57;
commitid	8vF1DH1UIEVFX3e5;

1.57
date	2016.07.27.06.55.44;	author reyk;	state Exp;
branches;
next	1.56;
commitid	7JdoxjTbye4XkUae;

1.56
date	2016.07.22.09.30.36;	author benno;	state Exp;
branches
	1.56.2.1;
next	1.55;
commitid	giZ5PqS1Bh7LYKMb;

1.55
date	2015.12.15.10.36.59;	author reyk;	state Exp;
branches
	1.55.2.1;
next	1.54;
commitid	jKnMpSEOCEdriGAy;

1.54
date	2015.12.07.04.03.27;	author mmcc;	state Exp;
branches;
next	1.53;
commitid	vlUffo7boyCTPJEr;

1.53
date	2015.09.27.20.21.04;	author deraadt;	state Exp;
branches;
next	1.52;
commitid	vnHl88VjkfgqD3Vo;

1.52
date	2015.07.28.10.24.26;	author reyk;	state Exp;
branches
	1.52.4.1;
next	1.51;
commitid	OS3OuQQ5xPSosr2v;

1.51
date	2015.07.18.16.01.28;	author benno;	state Exp;
branches;
next	1.50;
commitid	SsEehKey7cEgRJ3z;

1.50
date	2015.06.12.14.40.55;	author reyk;	state Exp;
branches;
next	1.49;
commitid	l9tjrfdeeLzMV6hw;

1.49
date	2015.06.08.15.47.51;	author claudio;	state Exp;
branches;
next	1.48;
commitid	qDFFH9Mi796T9cGu;

1.48
date	2015.06.01.09.54.16;	author claudio;	state Exp;
branches;
next	1.47;
commitid	tUyxHgfXXtHasRDs;

1.47
date	2015.05.22.01.34.13;	author jsg;	state Exp;
branches;
next	1.46;
commitid	Zb4IxEjkdG2Yk0IS;

1.46
date	2015.05.18.16.57.20;	author bluhm;	state Exp;
branches;
next	1.45;
commitid	rI96X4LxqTzkzCAH;

1.45
date	2015.05.18.16.45.16;	author bluhm;	state Exp;
branches;
next	1.44;
commitid	Wk8Xekj35LkJZeTt;

1.44
date	2015.04.29.08.41.24;	author bluhm;	state Exp;
branches;
next	1.43;
commitid	2jsvd8aoLwc5wzTA;

1.43
date	2015.01.22.17.42.09;	author reyk;	state Exp;
branches
	1.43.2.1;
next	1.42;
commitid	puppem00jmzmdm4f;

1.42
date	2015.01.22.15.21.28;	author reyk;	state Exp;
branches;
next	1.41;
commitid	4iTNJ5pZPl4b1HA5;

1.41
date	2015.01.16.15.06.40;	author deraadt;	state Exp;
branches;
next	1.40;
commitid	tOv8XK6tLyhEfayc;

1.40
date	2015.01.13.09.24.20;	author reyk;	state Exp;
branches;
next	1.39;
commitid	P0wyoMLA4lz5rdAI;

1.39
date	2015.01.01.14.54.06;	author reyk;	state Exp;
branches;
next	1.38;
commitid	B0Gf34206qlx2MJL;

1.38
date	2015.01.01.14.21.06;	author reyk;	state Exp;
branches;
next	1.37;
commitid	NQkinqAwrzQxij29;

1.37
date	2014.12.21.00.54.49;	author guenther;	state Exp;
branches;
next	1.36;
commitid	XnjIOhurXdX5o1V9;

1.36
date	2014.12.18.20.55.01;	author reyk;	state Exp;
branches;
next	1.35;
commitid	nThpdXmyvXqmRQ4C;

1.35
date	2014.10.25.03.23.49;	author lteo;	state Exp;
branches;
next	1.34;
commitid	2uw1UTO4k6erpWzK;

1.34
date	2014.09.15.08.06.11;	author reyk;	state Exp;
branches;
next	1.33;
commitid	pxJS6ypuYanpoCsY;

1.33
date	2014.08.10.21.55.17;	author bluhm;	state Exp;
branches;
next	1.32;
commitid	dWciZVv8mpM8egef;

1.32
date	2014.07.17.11.35.26;	author stsp;	state Exp;
branches
	1.32.4.1;
next	1.31;
commitid	TTduxpjvPpaxCdUl;

1.31
date	2014.07.14.00.11.12;	author bluhm;	state Exp;
branches;
next	1.30;
commitid	LPQMOcmMS8D0dRAQ;

1.30
date	2014.07.13.15.39.01;	author reyk;	state Exp;
branches;
next	1.29;
commitid	1lsVtvYmGmYZFvMJ;

1.29
date	2014.07.13.00.32.08;	author benno;	state Exp;
branches;
next	1.28;
commitid	ri182Vf5Hw0I7rh1;

1.28
date	2014.07.13.00.18.05;	author benno;	state Exp;
branches;
next	1.27;
commitid	IDCUWNzMOwuBiNzM;

1.27
date	2014.07.12.15.47.18;	author benno;	state Exp;
branches;
next	1.26;
commitid	CleGXex2HPb18DZG;

1.26
date	2014.07.12.14.34.13;	author reyk;	state Exp;
branches;
next	1.25;
commitid	Rqjr3ecSVr0G8d8h;

1.25
date	2014.07.11.23.11.54;	author benno;	state Exp;
branches;
next	1.24;
commitid	GqnpKkV89QYNaXnH;

1.24
date	2014.07.11.22.28.44;	author reyk;	state Exp;
branches;
next	1.23;
commitid	etE3yRsFWECDBHuh;

1.23
date	2014.07.11.11.48.50;	author reyk;	state Exp;
branches;
next	1.22;
commitid	6F05OKHLwEQdKZuE;

1.22
date	2014.07.10.20.02.32;	author bluhm;	state Exp;
branches;
next	1.21;
commitid	H83MrCtZN1xW2NwF;

1.21
date	2014.07.10.00.05.59;	author reyk;	state Exp;
branches;
next	1.20;
commitid	9WbuG1EnboLWC0cR;

1.20
date	2014.07.09.16.42.05;	author reyk;	state Exp;
branches;
next	1.19;
commitid	YhQvyAop4vC3AmzJ;

1.19
date	2014.06.25.11.05.15;	author reyk;	state Exp;
branches;
next	1.18;
commitid	QSckC3KrSjGNpjr5;

1.18
date	2014.04.20.16.18.32;	author reyk;	state Exp;
branches;
next	1.17;

1.17
date	2014.04.15.22.35.11;	author andre;	state Exp;
branches;
next	1.16;

1.16
date	2013.09.04.22.21.32;	author bluhm;	state Exp;
branches;
next	1.15;

1.15
date	2013.06.02.18.02.45;	author reyk;	state Exp;
branches;
next	1.14;

1.14
date	2013.05.30.19.45.20;	author reyk;	state Exp;
branches;
next	1.13;

1.13
date	2013.05.07.16.19.58;	author reyk;	state Exp;
branches;
next	1.12;

1.12
date	2013.04.20.17.41.33;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2013.03.10.23.32.53;	author reyk;	state Exp;
branches;
next	1.10;

1.10
date	2013.03.09.14.43.06;	author bluhm;	state Exp;
branches;
next	1.9;

1.9
date	2013.02.15.12.15.12;	author bluhm;	state Exp;
branches
	1.9.2.1;
next	1.8;

1.8
date	2013.02.05.21.36.33;	author bluhm;	state Exp;
branches;
next	1.7;

1.7
date	2013.01.22.08.26.34;	author reyk;	state Exp;
branches;
next	1.6;

1.6
date	2013.01.17.20.34.18;	author bluhm;	state Exp;
branches;
next	1.5;

1.5
date	2012.11.27.05.00.28;	author guenther;	state Exp;
branches;
next	1.4;

1.4
date	2012.11.21.22.14.24;	author benno;	state Exp;
branches;
next	1.3;

1.3
date	2012.10.10.14.27.46;	author reyk;	state Exp;
branches;
next	1.2;

1.2
date	2012.10.04.20.53.30;	author reyk;	state Exp;
branches;
next	1.1;

1.1
date	2012.09.20.12.30.20;	author reyk;	state Exp;
branches;
next	;

1.9.2.1
date	2013.06.04.00.54.30;	author sthen;	state Exp;
branches;
next	;

1.32.4.1
date	2014.11.17.16.53.24;	author tedu;	state Exp;
branches;
next	;
commitid	Qpvtkq5KfWBf36Vw;

1.43.2.1
date	2015.09.20.11.20.16;	author benno;	state Exp;
branches;
next	;
commitid	C9WQyjgbN7h0ioOp;

1.52.4.1
date	2016.07.23.20.56.02;	author benno;	state Exp;
branches;
next	1.52.4.2;
commitid	DFhmryrIb8G58WFk;

1.52.4.2
date	2016.08.07.07.54.42;	author benno;	state Exp;
branches;
next	;
commitid	GZ3yh3axbGcu2rco;

1.55.2.1
date	2016.07.23.21.01.33;	author benno;	state Exp;
branches;
next	1.55.2.2;
commitid	SSyx41hKvAvyRLVi;

1.55.2.2
date	2016.08.07.07.54.07;	author benno;	state Exp;
branches;
next	;
commitid	HdLzCX7WKhJK5mAs;

1.56.2.1
date	2016.08.07.07.53.45;	author benno;	state Exp;
branches;
next	;
commitid	uUOVRby9dw3PdeGk;


desc
@@


1.66
log
@use __func__ in log messages. fix some whitespace while here.
From Hiltjo Posthuma hiltjo -AT codemadness -DOT- org, thanks!
ok florian, claudio
@
text
@/*	$OpenBSD: relay_http.c,v 1.65 2017/05/27 08:33:25 claudio Exp $	*/

/*
 * Copyright (c) 2006 - 2016 Reyk Floeter <reyk@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/queue.h>
#include <sys/time.h>
#include <sys/socket.h>
#include <sys/tree.h>

#include <netinet/in.h>
#include <arpa/inet.h>

#include <limits.h>
#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <string.h>
#include <time.h>
#include <event.h>
#include <fnmatch.h>
#include <siphash.h>
#include <imsg.h>
#include <unistd.h>

#include "relayd.h"
#include "http.h"

static int	_relay_lookup_url(struct ctl_relay_event *, char *, char *,
		    char *, struct kv *);
int		 relay_lookup_url(struct ctl_relay_event *,
		    const char *, struct kv *);
int		 relay_lookup_query(struct ctl_relay_event *, struct kv *);
int		 relay_lookup_cookie(struct ctl_relay_event *, const char *,
		    struct kv *);
void		 relay_read_httpcontent(struct bufferevent *, void *);
void		 relay_read_httpchunks(struct bufferevent *, void *);
char		*relay_expand_http(struct ctl_relay_event *, char *,
		    char *, size_t);
int		 relay_writeheader_kv(struct ctl_relay_event *, struct kv *);
int		 relay_writeheader_http(struct ctl_relay_event *,
		    struct ctl_relay_event *);
int		 relay_writerequest_http(struct ctl_relay_event *,
		    struct ctl_relay_event *);
int		 relay_writeresponse_http(struct ctl_relay_event *,
		    struct ctl_relay_event *);
void		 relay_reset_http(struct ctl_relay_event *);
static int	 relay_httpmethod_cmp(const void *, const void *);
static int	 relay_httperror_cmp(const void *, const void *);
int		 relay_httpquery_test(struct ctl_relay_event *,
		    struct relay_rule *, struct kvlist *);
int		 relay_httpheader_test(struct ctl_relay_event *,
		    struct relay_rule *, struct kvlist *);
int		 relay_httppath_test(struct ctl_relay_event *,
		    struct relay_rule *, struct kvlist *);
int		 relay_httpurl_test(struct ctl_relay_event *,
		    struct relay_rule *, struct kvlist *);
int		 relay_httpcookie_test(struct ctl_relay_event *,
		    struct relay_rule *, struct kvlist *);
int		 relay_apply_actions(struct ctl_relay_event *, struct kvlist *);
int		 relay_match_actions(struct ctl_relay_event *,
		    struct relay_rule *, struct kvlist *, struct kvlist *);
void		 relay_httpdesc_free(struct http_descriptor *);

static struct relayd	*env = NULL;

static struct http_method	 http_methods[] = HTTP_METHODS;
static struct http_error	 http_errors[] = HTTP_ERRORS;

void
relay_http(struct relayd *x_env)
{
	if (x_env != NULL)
		env = x_env;

	DPRINTF("%s: sorting lookup tables, pid %d", __func__, getpid());

	/* Sort the HTTP lookup arrays */
	qsort(http_methods, sizeof(http_methods) /
	    sizeof(http_methods[0]) - 1,
	    sizeof(http_methods[0]), relay_httpmethod_cmp);
	qsort(http_errors, sizeof(http_errors) /
	    sizeof(http_errors[0]) - 1,
	    sizeof(http_errors[0]), relay_httperror_cmp);
}

void
relay_http_init(struct relay *rlay)
{
	rlay->rl_proto->close = relay_close_http;

	relay_http(NULL);

	/* Calculate skip step for the filter rules (may take a while) */
	relay_calc_skip_steps(&rlay->rl_proto->rules);
}

int
relay_httpdesc_init(struct ctl_relay_event *cre)
{
	struct http_descriptor	*desc;

	if ((desc = calloc(1, sizeof(*desc))) == NULL)
		return (-1);

	RB_INIT(&desc->http_headers);
	cre->desc = desc;

	return (0);
}

void
relay_httpdesc_free(struct http_descriptor *desc)
{
	free(desc->http_path);
	desc->http_path = NULL;
	free(desc->http_query);
	desc->http_query = NULL;
	free(desc->http_version);
	desc->http_version = NULL;
	free(desc->query_key);
	desc->query_key = NULL;
	free(desc->query_val);
	desc->query_val = NULL;
	kv_purge(&desc->http_headers);
	desc->http_lastheader = NULL;
}

void
relay_read_http(struct bufferevent *bev, void *arg)
{
	struct ctl_relay_event	*cre = arg;
	struct http_descriptor	*desc = cre->desc;
	struct rsession		*con = cre->con;
	struct relay		*rlay = con->se_relay;
	struct protocol		*proto = rlay->rl_proto;
	struct evbuffer		*src = EVBUFFER_INPUT(bev);
	char			*line = NULL, *key, *value;
	char			*urlproto, *host, *path;
	int			 action, unique, ret;
	const char		*errstr;
	size_t			 size, linelen;
	struct kv		*hdr = NULL;

	getmonotime(&con->se_tv_last);
	cre->timedout = 0;

	size = EVBUFFER_LENGTH(src);
	DPRINTF("%s: session %d: size %lu, to read %lld",
	    __func__, con->se_id, size, cre->toread);
	if (!size) {
		if (cre->dir == RELAY_DIR_RESPONSE)
			return;
		cre->toread = TOREAD_HTTP_HEADER;
		goto done;
	}

	while (!cre->done && (line = evbuffer_readline(src)) != NULL) {
		linelen = strlen(line);

		/*
		 * An empty line indicates the end of the request.
		 * libevent already stripped the \r\n for us.
		 */
		if (!linelen) {
			cre->done = 1;
			free(line);
			break;
		}
		key = line;

		/* Limit the total header length minus \r\n */
		cre->headerlen += linelen;
		if (cre->headerlen > RELAY_MAXHEADERLENGTH) {
			free(line);
			relay_abort_http(con, 413, "request too large", 0);
			return;
		}

		/*
		 * The first line is the GET/POST/PUT/... request,
		 * subsequent lines are HTTP headers.
		 */
		if (++cre->line == 1)
			value = strchr(key, ' ');
		else if (*key == ' ' || *key == '\t')
			/* Multiline headers wrap with a space or tab */
			value = NULL;
		else
			value = strchr(key, ':');
		if (value == NULL) {
			if (cre->line <= 2) {
				free(line);
				relay_abort_http(con, 400, "malformed", 0);
				return;
			}

			/* Append line to the last header, if present */
			if (kv_extend(&desc->http_headers,
			    desc->http_lastheader, line) == NULL) {
				free(line);
				goto fail;
			}

			free(line);
			continue;
		}
		if (*value == ':') {
			*value++ = '\0';
			value += strspn(value, " \t\r\n");
		} else {
			*value++ = '\0';
		}

		DPRINTF("%s: session %d: header '%s: %s'", __func__,
		    con->se_id, key, value);

		/*
		 * Identify and handle specific HTTP request methods
		 */
		if (cre->line == 1 && cre->dir == RELAY_DIR_RESPONSE) {
			desc->http_method = HTTP_METHOD_RESPONSE;
			/*
			 * Decode response path and query
			 */
			desc->http_version = strdup(line);
			if (desc->http_version == NULL) {
				free(line);
				goto fail;
			}
			desc->http_rescode = strdup(value);
			if (desc->http_rescode == NULL) {
				free(line);
				goto fail;
			}
			desc->http_resmesg = strchr(desc->http_rescode, ' ');
			if (desc->http_resmesg == NULL) {
				free(line);
				goto fail;
			}
			*desc->http_resmesg++ = '\0';
			if ((desc->http_resmesg = strdup(desc->http_resmesg))
			    == NULL) {
				free(line);
				goto fail;
			}
			desc->http_status = strtonum(desc->http_rescode, 100,
			    599, &errstr);
			if (errstr) {
				DPRINTF("%s: http_status %s: errno %d, %s",
				    __func__, desc->http_rescode, errno,
				    errstr);
				free(line);
				goto fail;
			}
			DPRINTF("http_version %s http_rescode %s "
			    "http_resmesg %s", desc->http_version,
			    desc->http_rescode, desc->http_resmesg);
			goto lookup;
		} else if (cre->line == 1 && cre->dir == RELAY_DIR_REQUEST) {
			if ((desc->http_method = relay_httpmethod_byname(key))
			    == HTTP_METHOD_NONE) {
				free(line);
				goto fail;
			}
			/*
			 * Decode request path and query
			 */
			desc->http_path = strdup(value);
			if (desc->http_path == NULL) {
				free(line);
				goto fail;
			}
			desc->http_version = strchr(desc->http_path, ' ');
			if (desc->http_version == NULL) {
				free(line);
				goto fail;
			}
			*desc->http_version++ = '\0';
			desc->http_query = strchr(desc->http_path, '?');
			if (desc->http_query != NULL)
				*desc->http_query++ = '\0';

			/*
			 * Have to allocate the strings because they could
			 * be changed independently by the filters later.
			 */
			if ((desc->http_version =
			    strdup(desc->http_version)) == NULL) {
				free(line);
				goto fail;
			}
			if (desc->http_query != NULL &&
			    (desc->http_query =
			    strdup(desc->http_query)) == NULL) {
				free(line);
				goto fail;
			}
		} else if (desc->http_method != HTTP_METHOD_NONE &&
		    strcasecmp("Content-Length", key) == 0) {
			/*
			 * These methods should not have a body
			 * and thus no Content-Length header.
			 */
			if (desc->http_method == HTTP_METHOD_TRACE ||
			    desc->http_method == HTTP_METHOD_CONNECT) {
				relay_abort_http(con, 400, "malformed", 0);
				goto abort;
			}
			/*
			 * response with a status code of 1xx
			 * (Informational) or 204 (No Content) MUST
			 * not have a Content-Length (rfc 7230 3.3.3)
			 */
			if (desc->http_method == HTTP_METHOD_RESPONSE && (
			    ((desc->http_status >= 100 &&
			    desc->http_status < 200) ||
			    desc->http_status == 204))) {
				relay_abort_http(con, 500,
				    "Internal Server Error", 0);
				goto abort;
			}
			/*
			 * Need to read data from the client after the
			 * HTTP header.
			 * XXX What about non-standard clients not using
			 * the carriage return? And some browsers seem to
			 * include the line length in the content-length.
			 */
			cre->toread = strtonum(value, 0, LLONG_MAX, &errstr);
			if (errstr) {
				relay_abort_http(con, 500, errstr, 0);
				goto abort;
			}
		}
 lookup:
		if (strcasecmp("Transfer-Encoding", key) == 0 &&
		    strcasecmp("chunked", value) == 0)
			desc->http_chunked = 1;

		/* The following header should only occur once */
		if (strcasecmp("Host", key) == 0) {
			unique = 1;

			/*
			 * The path may contain a URL.  The host in the
			 * URL has to match the Host: value.
			 */
			if (parse_url(desc->http_path,
			    &urlproto, &host, &path) == 0) {
				ret = strcasecmp(host, value);
				free(urlproto);
				free(host);
				free(path);
				if (ret != 0) {
					relay_abort_http(con, 400,
					    "malformed host", 0);
					goto abort;
				}
			}
		} else
			unique = 0;

		if (cre->line != 1) {
			if ((hdr = kv_add(&desc->http_headers, key,
			    value, unique)) == NULL) {
				relay_abort_http(con, 400,
				    "malformed header", 0);
				goto abort;
			}
			desc->http_lastheader = hdr;
		}

		free(line);
	}
	if (cre->done) {
		if (desc->http_method == HTTP_METHOD_NONE) {
			relay_abort_http(con, 406, "no method", 0);
			return;
		}

		action = relay_test(proto, cre);
		switch (action) {
		case RES_FAIL:
			relay_close(con, "filter rule failed");
			return;
		case RES_BAD:
			relay_abort_http(con, 400, "Bad Request",
			    con->se_label);
			return;
		case RES_INTERNAL:
			relay_abort_http(con, 500, "Internal Server Error",
			    con->se_label);
			return;
		}
		if (action != RES_PASS) {
			relay_abort_http(con, 403, "Forbidden", con->se_label);
			return;
		}

		switch (desc->http_method) {
		case HTTP_METHOD_CONNECT:
			/* Data stream */
			cre->toread = TOREAD_UNLIMITED;
			bev->readcb = relay_read;
			break;
		case HTTP_METHOD_GET:
		case HTTP_METHOD_HEAD:
		/* WebDAV methods */
		case HTTP_METHOD_COPY:
		case HTTP_METHOD_MOVE:
			cre->toread = 0;
			break;
		case HTTP_METHOD_DELETE:
		case HTTP_METHOD_OPTIONS:
		case HTTP_METHOD_POST:
		case HTTP_METHOD_PUT:
		case HTTP_METHOD_RESPONSE:
		/* WebDAV methods */
		case HTTP_METHOD_PROPFIND:
		case HTTP_METHOD_PROPPATCH:
		case HTTP_METHOD_MKCOL:
		case HTTP_METHOD_LOCK:
		case HTTP_METHOD_UNLOCK:
		case HTTP_METHOD_VERSION_CONTROL:
		case HTTP_METHOD_REPORT:
		case HTTP_METHOD_CHECKOUT:
		case HTTP_METHOD_CHECKIN:
		case HTTP_METHOD_UNCHECKOUT:
		case HTTP_METHOD_MKWORKSPACE:
		case HTTP_METHOD_UPDATE:
		case HTTP_METHOD_LABEL:
		case HTTP_METHOD_MERGE:
		case HTTP_METHOD_BASELINE_CONTROL:
		case HTTP_METHOD_MKACTIVITY:
		case HTTP_METHOD_ORDERPATCH:
		case HTTP_METHOD_ACL:
		case HTTP_METHOD_MKREDIRECTREF:
		case HTTP_METHOD_UPDATEREDIRECTREF:
		case HTTP_METHOD_SEARCH:
		case HTTP_METHOD_PATCH:
			/* HTTP request payload */
			if (cre->toread > 0)
				bev->readcb = relay_read_httpcontent;

			/* Single-pass HTTP body */
			if (cre->toread < 0) {
				cre->toread = TOREAD_UNLIMITED;
				bev->readcb = relay_read;
			}
			break;
		default:
			/* HTTP handler */
			cre->toread = TOREAD_HTTP_HEADER;
			bev->readcb = relay_read_http;
			break;
		}
		if (desc->http_chunked) {
			/* Chunked transfer encoding */
			cre->toread = TOREAD_HTTP_CHUNK_LENGTH;
			bev->readcb = relay_read_httpchunks;
		}

		if (cre->dir == RELAY_DIR_REQUEST) {
			if (relay_writerequest_http(cre->dst, cre) == -1)
			    goto fail;
		} else {
			if (relay_writeresponse_http(cre->dst, cre) == -1)
			    goto fail;
		}
		if (relay_bufferevent_print(cre->dst, "\r\n") == -1 ||
		    relay_writeheader_http(cre->dst, cre) == -1 ||
		    relay_bufferevent_print(cre->dst, "\r\n") == -1)
			goto fail;

		relay_reset_http(cre);
 done:
		if (cre->dir == RELAY_DIR_REQUEST && cre->toread <= 0 &&
		    cre->dst->state != STATE_CONNECTED) {
			if (rlay->rl_conf.fwdmode == FWD_TRANS) {
				relay_bindanyreq(con, 0, IPPROTO_TCP);
				return;
			}
			if (relay_connect(con) == -1) {
				relay_abort_http(con, 502, "session failed", 0);
				return;
			}
		}
	}
	if (con->se_done) {
		relay_close(con, "last http read (done)");
		return;
	}
	switch (relay_splice(cre)) {
	case -1:
		relay_close(con, strerror(errno));
	case 1:
		return;
	case 0:
		break;
	}
	bufferevent_enable(bev, EV_READ);
	if (EVBUFFER_LENGTH(src) && bev->readcb != relay_read_http)
		bev->readcb(bev, arg);
	/* The callback readcb() might have freed the session. */
	return;
 fail:
	relay_abort_http(con, 500, strerror(errno), 0);
	return;
 abort:
	free(line);
}

void
relay_read_httpcontent(struct bufferevent *bev, void *arg)
{
	struct ctl_relay_event	*cre = arg;
	struct rsession		*con = cre->con;
	struct protocol		*proto = con->se_relay->rl_proto;

	struct evbuffer		*src = EVBUFFER_INPUT(bev);
	size_t			 size;

	getmonotime(&con->se_tv_last);
	cre->timedout = 0;

	size = EVBUFFER_LENGTH(src);
	DPRINTF("%s: session %d: size %lu, to read %lld", __func__,
	    con->se_id, size, cre->toread);
	if (!size)
		return;
	if (relay_spliceadjust(cre) == -1)
		goto fail;

	if (cre->toread > 0) {
		/* Read content data */
		if ((off_t)size > cre->toread) {
			size = cre->toread;
			if (relay_bufferevent_write_chunk(cre->dst, src, size)
			    == -1)
				goto fail;
			cre->toread = 0;
		} else {
			if (relay_bufferevent_write_buffer(cre->dst, src) == -1)
				goto fail;
			cre->toread -= size;
		}
		DPRINTF("%s: done, size %lu, to read %lld", __func__,
		    size, cre->toread);
	}
	if (cre->toread == 0) {
		cre->toread = TOREAD_HTTP_HEADER;
		bev->readcb = relay_read_http;
	}
	if (con->se_done)
		goto done;
	bufferevent_enable(bev, EV_READ);

	if (cre->dst->bev && EVBUFFER_LENGTH(EVBUFFER_OUTPUT(cre->dst->bev)) >
	    (size_t)RELAY_MAX_PREFETCH * proto->tcpbufsiz)
		bufferevent_disable(cre->bev, EV_READ);

	if (bev->readcb != relay_read_httpcontent)
		bev->readcb(bev, arg);
	/* The callback readcb() might have freed the session. */
	return;
 done:
	relay_close(con, "last http content read");
	return;
 fail:
	relay_close(con, strerror(errno));
}

void
relay_read_httpchunks(struct bufferevent *bev, void *arg)
{
	struct ctl_relay_event	*cre = arg;
	struct rsession		*con = cre->con;
	struct protocol		*proto = con->se_relay->rl_proto;
	struct evbuffer		*src = EVBUFFER_INPUT(bev);
	char			*line;
	long long		 llval;
	size_t			 size;

	getmonotime(&con->se_tv_last);
	cre->timedout = 0;

	size = EVBUFFER_LENGTH(src);
	DPRINTF("%s: session %d: size %lu, to read %lld", __func__,
	    con->se_id, size, cre->toread);
	if (!size)
		return;
	if (relay_spliceadjust(cre) == -1)
		goto fail;

	if (cre->toread > 0) {
		/* Read chunk data */
		if ((off_t)size > cre->toread) {
			size = cre->toread;
			if (relay_bufferevent_write_chunk(cre->dst, src, size)
			    == -1)
				goto fail;
			cre->toread = 0;
		} else {
			if (relay_bufferevent_write_buffer(cre->dst, src) == -1)
				goto fail;
			cre->toread -= size;
		}
		DPRINTF("%s: done, size %lu, to read %lld", __func__,
		    size, cre->toread);
	}
	switch (cre->toread) {
	case TOREAD_HTTP_CHUNK_LENGTH:
		line = evbuffer_readline(src);
		if (line == NULL) {
			/* Ignore empty line, continue */
			bufferevent_enable(bev, EV_READ);
			return;
		}
		if (strlen(line) == 0) {
			free(line);
			goto next;
		}

		/*
		 * Read prepended chunk size in hex, ignore the trailer.
		 * The returned signed value must not be negative.
		 */
		if (sscanf(line, "%llx", &llval) != 1 || llval < 0) {
			free(line);
			relay_close(con, "invalid chunk size");
			return;
		}

		if (relay_bufferevent_print(cre->dst, line) == -1 ||
		    relay_bufferevent_print(cre->dst, "\r\n") == -1) {
			free(line);
			goto fail;
		}
		free(line);

		if ((cre->toread = llval) == 0) {
			DPRINTF("%s: last chunk", __func__);
			cre->toread = TOREAD_HTTP_CHUNK_TRAILER;
		}
		break;
	case TOREAD_HTTP_CHUNK_TRAILER:
		/* Last chunk is 0 bytes followed by trailer and empty line */
		line = evbuffer_readline(src);
		if (line == NULL) {
			/* Ignore empty line, continue */
			bufferevent_enable(bev, EV_READ);
			return;
		}
		if (relay_bufferevent_print(cre->dst, line) == -1 ||
		    relay_bufferevent_print(cre->dst, "\r\n") == -1) {
			free(line);
			goto fail;
		}
		if (strlen(line) == 0) {
			/* Switch to HTTP header mode */
			cre->toread = TOREAD_HTTP_HEADER;
			bev->readcb = relay_read_http;
		}
		free(line);
		break;
	case 0:
		/* Chunk is terminated by an empty newline */
		line = evbuffer_readline(src);
		free(line);
		if (relay_bufferevent_print(cre->dst, "\r\n") == -1)
			goto fail;
		cre->toread = TOREAD_HTTP_CHUNK_LENGTH;
		break;
	}

 next:
	if (con->se_done)
		goto done;
	bufferevent_enable(bev, EV_READ);

	if (cre->dst->bev && EVBUFFER_LENGTH(EVBUFFER_OUTPUT(cre->dst->bev)) >
	    (size_t)RELAY_MAX_PREFETCH * proto->tcpbufsiz)
		bufferevent_disable(cre->bev, EV_READ);

	if (EVBUFFER_LENGTH(src))
		bev->readcb(bev, arg);
	/* The callback readcb() might have freed the session. */
	return;

 done:
	relay_close(con, "last http chunk read (done)");
	return;
 fail:
	relay_close(con, strerror(errno));
}

void
relay_reset_http(struct ctl_relay_event *cre)
{
	struct http_descriptor	*desc = cre->desc;

	relay_httpdesc_free(desc);
	desc->http_method = 0;
	desc->http_chunked = 0;
	cre->headerlen = 0;
	cre->line = 0;
	cre->done = 0;
}

static int
_relay_lookup_url(struct ctl_relay_event *cre, char *host, char *path,
    char *query, struct kv *kv)
{
	struct rsession		*con = cre->con;
	char			*val, *md = NULL;
	int			 ret = RES_FAIL;
	const char		*str = NULL;

	if (asprintf(&val, "%s%s%s%s",
	    host, path,
	    query == NULL ? "" : "?",
	    query == NULL ? "" : query) == -1) {
		relay_abort_http(con, 500, "failed to allocate URL", 0);
		return (RES_FAIL);
	}

	switch (kv->kv_digest) {
	case DIGEST_SHA1:
	case DIGEST_MD5:
		if ((md = digeststr(kv->kv_digest,
		    val, strlen(val), NULL)) == NULL) {
			relay_abort_http(con, 500,
			    "failed to allocate digest", 0);
			goto fail;
		}
		str = md;
		break;
	case DIGEST_NONE:
		str = val;
		break;
	}

	DPRINTF("%s: session %d: %s, %s: %d", __func__, con->se_id,
	    str, kv->kv_key, strcasecmp(kv->kv_key, str));

	if (strcasecmp(kv->kv_key, str) == 0) {
		ret = RES_DROP;
		goto fail;
	}

	ret = RES_PASS;
 fail:
	free(md);
	free(val);
	return (ret);
}

int
relay_lookup_url(struct ctl_relay_event *cre, const char *host, struct kv *kv)
{
	struct http_descriptor	*desc = (struct http_descriptor *)cre->desc;
	int			 i, j, dots;
	char			*hi[RELAY_MAXLOOKUPLEVELS], *p, *pp, *c, ch;
	char			 ph[HOST_NAME_MAX+1];
	int			 ret;

	if (desc->http_path == NULL)
		return (RES_PASS);

	/*
	 * This is an URL lookup algorithm inspired by
	 * http://code.google.com/apis/safebrowsing/
	 *     developers_guide.html#PerformingLookups
	 */

	DPRINTF("%s: host '%s', path '%s', query '%s'",
	    __func__, host, desc->http_path,
	    desc->http_query == NULL ? "" : desc->http_query);

	if (canonicalize_host(host, ph, sizeof(ph)) == NULL) {
		return (RES_BAD);
	}

	bzero(hi, sizeof(hi));
	for (dots = -1, i = strlen(ph) - 1; i > 0; i--) {
		if (ph[i] == '.' && ++dots)
			hi[dots - 1] = &ph[i + 1];
		if (dots > (RELAY_MAXLOOKUPLEVELS - 2))
			break;
	}
	if (dots == -1)
		dots = 0;
	hi[dots] = ph;

	if ((pp = strdup(desc->http_path)) == NULL) {
		return (RES_INTERNAL);
	}
	for (i = (RELAY_MAXLOOKUPLEVELS - 1); i >= 0; i--) {
		if (hi[i] == NULL)
			continue;

		/* 1. complete path with query */
		if (desc->http_query != NULL)
			if ((ret = _relay_lookup_url(cre, hi[i],
			    pp, desc->http_query, kv)) != RES_PASS)
				goto done;

		/* 2. complete path without query */
		if ((ret = _relay_lookup_url(cre, hi[i],
		    pp, NULL, kv)) != RES_PASS)
			goto done;

		/* 3. traverse path */
		for (j = 0, p = strchr(pp, '/');
		    p != NULL; p = strchr(p, '/'), j++) {
			if (j > (RELAY_MAXLOOKUPLEVELS - 2) || *(++p) == '\0')
				break;
			c = &pp[p - pp];
			ch = *c;
			*c = '\0';
			if ((ret = _relay_lookup_url(cre, hi[i],
			    pp, NULL, kv)) != RES_PASS)
				goto done;
			*c = ch;
		}
	}

	ret = RES_PASS;
 done:
	free(pp);
	return (ret);
}

int
relay_lookup_cookie(struct ctl_relay_event *cre, const char *str,
    struct kv *kv)
{
	char			*val, *ptr, *key, *value;
	int			 ret;

	if ((val = strdup(str)) == NULL) {
		return (RES_INTERNAL);
	}

	for (ptr = val; ptr != NULL && strlen(ptr);) {
		if (*ptr == ' ')
			*ptr++ = '\0';
		key = ptr;
		if ((ptr = strchr(ptr, ';')) != NULL)
			*ptr++ = '\0';
		/*
		 * XXX We do not handle attributes
		 * ($Path, $Domain, or $Port)
		 */
		if (*key == '$')
			continue;

		if ((value =
		    strchr(key, '=')) == NULL ||
		    strlen(value) < 1)
			continue;
		*value++ = '\0';
		if (*value == '"')
			*value++ = '\0';
		if (value[strlen(value) - 1] == '"')
			value[strlen(value) - 1] = '\0';

		DPRINTF("%s: key %s = %s, %s = %s : %d",
		    __func__, key, value, kv->kv_key, kv->kv_value,
		    strcasecmp(kv->kv_key, key));

		if (strcasecmp(kv->kv_key, key) == 0 &&
		    ((kv->kv_value == NULL) ||
		    (fnmatch(kv->kv_value, value,
		    FNM_CASEFOLD) != FNM_NOMATCH))) {
			ret = RES_DROP;
			goto done;
		}
	}

	ret = RES_PASS;

 done:
	free(val);
	return (ret);
}

int
relay_lookup_query(struct ctl_relay_event *cre, struct kv *kv)
{
	struct http_descriptor	*desc = cre->desc;
	struct kv		*match = &desc->http_matchquery;
	char			*val, *ptr, *tmpkey = NULL, *tmpval = NULL;
	int			 ret = -1;

	if (desc->http_query == NULL)
		return (-1);
	if ((val = strdup(desc->http_query)) == NULL) {
		return (RES_INTERNAL);
	}

	ptr = val;
	while (ptr != NULL && strlen(ptr)) {
		tmpkey = ptr;
		if ((ptr = strchr(ptr, '&')) != NULL)
			*ptr++ = '\0';
		if ((tmpval = strchr(tmpkey, '=')) == NULL || strlen(tmpval)
		    < 1)
			continue;
		*tmpval++ = '\0';

		if (fnmatch(kv->kv_key, tmpkey, 0) != FNM_NOMATCH &&
		    (kv->kv_value == NULL || fnmatch(kv->kv_value, tmpval, 0)
		    != FNM_NOMATCH))
			break;
		else
			tmpkey = NULL;
	}

	if (tmpkey == NULL || tmpval == NULL)
		goto done;

	match->kv_key = strdup(tmpkey);
	if (match->kv_key == NULL)
		goto done;
	match->kv_value = strdup(tmpval);
	if (match->kv_key == NULL)
		goto done;
	ret = 0;

 done:
	free(val);
	return (ret);
}

ssize_t
relay_http_time(time_t t, char *tmbuf, size_t len)
{
	struct tm		 tm;

	/* New HTTP/1.1 RFC 7231 prefers IMF-fixdate from RFC 5322 */
	if (t == -1 || gmtime_r(&t, &tm) == NULL)
		return (-1);
	else
		return (strftime(tmbuf, len, "%a, %d %h %Y %T %Z", &tm));
}

void
relay_abort_http(struct rsession *con, u_int code, const char *msg,
    u_int16_t labelid)
{
	struct relay		*rlay = con->se_relay;
	struct bufferevent	*bev = con->se_in.bev;
	const char		*httperr = NULL, *text = "";
	char			*httpmsg, *body = NULL;
	char			 tmbuf[32], hbuf[128];
	const char		*style, *label = NULL;
	int			 bodylen;

	if ((httperr = relay_httperror_byid(code)) == NULL)
		httperr = "Unknown Error";

	if (labelid != 0)
		label = label_id2name(labelid);

	/* In some cases this function may be called from generic places */
	if (rlay->rl_proto->type != RELAY_PROTO_HTTP ||
	    (rlay->rl_proto->flags & F_RETURN) == 0) {
		relay_close(con, msg);
		return;
	}

	if (bev == NULL)
		goto done;

	/* Some system information */
	if (print_host(&rlay->rl_conf.ss, hbuf, sizeof(hbuf)) == NULL)
		goto done;

	if (relay_http_time(time(NULL), tmbuf, sizeof(tmbuf)) <= 0)
		goto done;

	/* Do not send details of the Internal Server Error */
	switch (code) {
	case 500:
		break;
	default:
		text = msg;
		break;
	}

	/* A CSS stylesheet allows minimal customization by the user */
	style = (rlay->rl_proto->style != NULL) ? rlay->rl_proto->style :
	    "body { background-color: #a00000; color: white; font-family: "
	    "'Comic Sans MS', 'Chalkboard SE', 'Comic Neue', sans-serif; }\n"
	    "hr { border: 0; border-bottom: 1px dashed; }\n";

	/* Generate simple HTTP+HTML error document */
	if ((bodylen = asprintf(&body,
	    "<!DOCTYPE html>\n"
	    "<html>\n"
	    "<head>\n"
	    "<title>%03d %s</title>\n"
	    "<style type=\"text/css\"><!--\n%s\n--></style>\n"
	    "</head>\n"
	    "<body>\n"
	    "<h1>%s</h1>\n"
	    "<div id='m'>%s</div>\n"
	    "<div id='l'>%s</div>\n"
	    "<hr><address>%s at %s port %d</address>\n"
	    "</body>\n"
	    "</html>\n",
	    code, httperr, style, httperr, text,
	    label == NULL ? "" : label,
	    RELAYD_SERVERNAME, hbuf, ntohs(rlay->rl_conf.port))) == -1)
		goto done;

	/* Generate simple HTTP+HTML error document */
	if (asprintf(&httpmsg,
	    "HTTP/1.0 %03d %s\r\n"
	    "Date: %s\r\n"
	    "Server: %s\r\n"
	    "Connection: close\r\n"
	    "Content-Type: text/html\r\n"
	    "Content-Length: %d\r\n"
	    "\r\n"
	    "%s",
	    code, httperr, tmbuf, RELAYD_SERVERNAME, bodylen, body) == -1)
		goto done;

	/* Dump the message without checking for success */
	relay_dump(&con->se_in, httpmsg, strlen(httpmsg));
	free(httpmsg);

 done:
	free(body);
	if (asprintf(&httpmsg, "%s (%03d %s)", msg, code, httperr) == -1)
		relay_close(con, msg);
	else {
		relay_close(con, httpmsg);
		free(httpmsg);
	}
}

void
relay_close_http(struct rsession *con)
{
	struct http_descriptor	*desc[2] = {
		con->se_in.desc, con->se_out.desc
	};
	int			 i;

	for (i = 0; i < 2; i++) {
		if (desc[i] == NULL)
			continue;
		relay_httpdesc_free(desc[i]);
		free(desc[i]);
	}
}

char *
relay_expand_http(struct ctl_relay_event *cre, char *val, char *buf,
    size_t len)
{
	struct rsession	*con = cre->con;
	struct relay	*rlay = con->se_relay;
	char		 ibuf[128];

	if (strlcpy(buf, val, len) >= len)
		return (NULL);

	if (strstr(val, "$REMOTE_") != NULL) {
		if (strstr(val, "$REMOTE_ADDR") != NULL) {
			if (print_host(&cre->ss, ibuf, sizeof(ibuf)) == NULL)
				return (NULL);
			if (expand_string(buf, len,
			    "$REMOTE_ADDR", ibuf) != 0)
				return (NULL);
		}
		if (strstr(val, "$REMOTE_PORT") != NULL) {
			snprintf(ibuf, sizeof(ibuf), "%u", ntohs(cre->port));
			if (expand_string(buf, len,
			    "$REMOTE_PORT", ibuf) != 0)
				return (NULL);
		}
	}
	if (strstr(val, "$SERVER_") != NULL) {
		if (strstr(val, "$SERVER_ADDR") != NULL) {
			if (print_host(&rlay->rl_conf.ss,
			    ibuf, sizeof(ibuf)) == NULL)
				return (NULL);
			if (expand_string(buf, len,
			    "$SERVER_ADDR", ibuf) != 0)
				return (NULL);
		}
		if (strstr(val, "$SERVER_PORT") != NULL) {
			snprintf(ibuf, sizeof(ibuf), "%u",
			    ntohs(rlay->rl_conf.port));
			if (expand_string(buf, len,
			    "$SERVER_PORT", ibuf) != 0)
				return (NULL);
		}
		if (strstr(val, "$SERVER_NAME") != NULL) {
			if (expand_string(buf, len,
			    "$SERVER_NAME", RELAYD_SERVERNAME) != 0)
				return (NULL);
		}
	}
	if (strstr(val, "$TIMEOUT") != NULL) {
		snprintf(ibuf, sizeof(ibuf), "%lld",
		    (long long)rlay->rl_conf.timeout.tv_sec);
		if (expand_string(buf, len, "$TIMEOUT", ibuf) != 0)
			return (NULL);
	}

	return (buf);
}

int
relay_writerequest_http(struct ctl_relay_event *dst,
    struct ctl_relay_event *cre)
{
	struct http_descriptor	*desc = (struct http_descriptor *)cre->desc;
	const char		*name = NULL;

	if ((name = relay_httpmethod_byid(desc->http_method)) == NULL)
		return (-1);

	if (relay_bufferevent_print(dst, name) == -1 ||
	    relay_bufferevent_print(dst, " ") == -1 ||
	    relay_bufferevent_print(dst, desc->http_path) == -1 ||
	    (desc->http_query != NULL &&
	    (relay_bufferevent_print(dst, "?") == -1 ||
	    relay_bufferevent_print(dst, desc->http_query) == -1)) ||
	    relay_bufferevent_print(dst, " ") == -1 ||
	    relay_bufferevent_print(dst, desc->http_version) == -1)
		return (-1);

	return (0);
}

int
relay_writeresponse_http(struct ctl_relay_event *dst,
    struct ctl_relay_event *cre)
{
	struct http_descriptor	*desc = (struct http_descriptor *)cre->desc;

	DPRINTF("version: %s rescode: %s resmsg: %s", desc->http_version,
	    desc->http_rescode, desc->http_resmesg);

	if (relay_bufferevent_print(dst, desc->http_version) == -1 ||
	    relay_bufferevent_print(dst, " ") == -1 ||
	    relay_bufferevent_print(dst, desc->http_rescode) == -1 ||
	    relay_bufferevent_print(dst, " ") == -1 ||
	    relay_bufferevent_print(dst, desc->http_resmesg) == -1)
		return (-1);

	return (0);
}

int
relay_writeheader_kv(struct ctl_relay_event *dst, struct kv *hdr)
{
	char			*ptr;
	const char		*key;

	if (hdr->kv_flags & KV_FLAG_INVALID)
		return (0);

	/* The key might have been updated in the parent */
	if (hdr->kv_parent != NULL && hdr->kv_parent->kv_key != NULL)
		key = hdr->kv_parent->kv_key;
	else
		key = hdr->kv_key;

	ptr = hdr->kv_value;
	if (relay_bufferevent_print(dst, key) == -1 ||
	    (ptr != NULL &&
	    (relay_bufferevent_print(dst, ": ") == -1 ||
	    relay_bufferevent_print(dst, ptr) == -1 ||
	    relay_bufferevent_print(dst, "\r\n") == -1)))
		return (-1);
	DPRINTF("%s: %s: %s", __func__, key,
	    hdr->kv_value == NULL ? "" : hdr->kv_value);

	return (0);
}

int
relay_writeheader_http(struct ctl_relay_event *dst, struct ctl_relay_event
    *cre)
{
	struct kv		*hdr, *kv;
	struct http_descriptor	*desc = (struct http_descriptor *)cre->desc;

	RB_FOREACH(hdr, kvtree, &desc->http_headers) {
		if (relay_writeheader_kv(dst, hdr) == -1)
			return (-1);
		TAILQ_FOREACH(kv, &hdr->kv_children, kv_entry) {
			if (relay_writeheader_kv(dst, kv) == -1)
				return (-1);
		}
	}

	return (0);
}

enum httpmethod
relay_httpmethod_byname(const char *name)
{
	enum httpmethod		 id = HTTP_METHOD_NONE;
	struct http_method	 method, *res = NULL;

	/* Set up key */
	method.method_name = name;

	if ((res = bsearch(&method, http_methods,
	    sizeof(http_methods) / sizeof(http_methods[0]) - 1,
	    sizeof(http_methods[0]), relay_httpmethod_cmp)) != NULL)
		id = res->method_id;

	return (id);
}

const char *
relay_httpmethod_byid(u_int id)
{
	const char	*name = NULL;
	int		 i;

	for (i = 0; http_methods[i].method_name != NULL; i++) {
		if (http_methods[i].method_id == id) {
			name = http_methods[i].method_name;
			break;
		}
	}

	return (name);
}

static int
relay_httpmethod_cmp(const void *a, const void *b)
{
	const struct http_method *ma = a;
	const struct http_method *mb = b;

	/*
	 * RFC 2616 section 5.1.1 says that the method is case
	 * sensitive so we don't do a strcasecmp here.
	 */
	return (strcmp(ma->method_name, mb->method_name));
}

const char *
relay_httperror_byid(u_int id)
{
	struct http_error	 error, *res = NULL;

	/* Set up key */
	error.error_code = (int)id;

	res = bsearch(&error, http_errors,
	    sizeof(http_errors) / sizeof(http_errors[0]) - 1,
	    sizeof(http_errors[0]), relay_httperror_cmp);

	return (res->error_name);
}

static int
relay_httperror_cmp(const void *a, const void *b)
{
	const struct http_error *ea = a;
	const struct http_error *eb = b;
	return (ea->error_code - eb->error_code);
}

int
relay_httpquery_test(struct ctl_relay_event *cre, struct relay_rule *rule,
    struct kvlist *actions)
{
	struct http_descriptor	*desc = cre->desc;
	struct kv		*match = &desc->http_matchquery;
	struct kv		*kv = &rule->rule_kv[KEY_TYPE_QUERY];
	int			 res = 0;

	if (cre->dir == RELAY_DIR_RESPONSE || kv->kv_type != KEY_TYPE_QUERY)
		return (0);
	else if (kv->kv_key == NULL)
		return (0);
	else if ((res = relay_lookup_query(cre, kv)) != 0)
		return (res);

	relay_match(actions, kv, match, NULL);

	return (0);
}

int
relay_httpheader_test(struct ctl_relay_event *cre, struct relay_rule *rule,
    struct kvlist *actions)
{
	struct http_descriptor	*desc = cre->desc;
	struct kv		*kv = &rule->rule_kv[KEY_TYPE_HEADER];
	struct kv		*match;

	if (kv->kv_type != KEY_TYPE_HEADER)
		return (0);

	match = kv_find(&desc->http_headers, kv);

	if (kv->kv_option == KEY_OPTION_APPEND ||
	    kv->kv_option == KEY_OPTION_SET) {
		/* header can be NULL and will be added later */
	} else if (match == NULL) {
		/* Fail if header doesn't exist */
		return (-1);
	} else {
		if (fnmatch(kv->kv_key, match->kv_key,
		    FNM_CASEFOLD) == FNM_NOMATCH)
			return (-1);
		if (kv->kv_value != NULL &&
		    match->kv_value != NULL &&
		    fnmatch(kv->kv_value, match->kv_value, 0) == FNM_NOMATCH)
			return (-1);
	}

	relay_match(actions, kv, match, &desc->http_headers);

	return (0);
}

int
relay_httppath_test(struct ctl_relay_event *cre, struct relay_rule *rule,
    struct kvlist *actions)
{
	struct http_descriptor	*desc = cre->desc;
	struct kv		*kv = &rule->rule_kv[KEY_TYPE_PATH];
	struct kv		*match = &desc->http_pathquery;
	const char		*query;

	if (cre->dir == RELAY_DIR_RESPONSE || kv->kv_type != KEY_TYPE_PATH)
		return (0);
	else if (kv->kv_key == NULL)
		return (0);
	else if (fnmatch(kv->kv_key, desc->http_path, 0) == FNM_NOMATCH)
		return (-1);
	else if (kv->kv_value != NULL && kv->kv_option == KEY_OPTION_NONE) {
		query = desc->http_query == NULL ? "" : desc->http_query;
		if (fnmatch(kv->kv_value, query, FNM_CASEFOLD) == FNM_NOMATCH)
			return (-1);
	}

	relay_match(actions, kv, match, NULL);

	return (0);
}

int
relay_httpurl_test(struct ctl_relay_event *cre, struct relay_rule *rule,
    struct kvlist *actions)
{
	struct http_descriptor	*desc = cre->desc;
	struct kv		*host, key;
	struct kv		*kv = &rule->rule_kv[KEY_TYPE_URL];
	struct kv		*match = &desc->http_pathquery;
	int			 res;

	if (cre->dir == RELAY_DIR_RESPONSE || kv->kv_type != KEY_TYPE_URL ||
	    kv->kv_key == NULL)
		return (0);

	key.kv_key = "Host";
	host = kv_find(&desc->http_headers, &key);

	if (host == NULL || host->kv_value == NULL)
		return (0);
	else if (rule->rule_action != RULE_ACTION_BLOCK &&
	    kv->kv_option == KEY_OPTION_LOG &&
	    fnmatch(kv->kv_key, match->kv_key, FNM_CASEFOLD) != FNM_NOMATCH) {
		/* fnmatch url only for logging */
	} else if ((res = relay_lookup_url(cre, host->kv_value, kv)) != 0)
		return (res);
	relay_match(actions, kv, match, NULL);

	return (0);
}

int
relay_httpcookie_test(struct ctl_relay_event *cre, struct relay_rule *rule,
    struct kvlist *actions)
{
	struct http_descriptor	*desc = cre->desc;
	struct kv		*kv = &rule->rule_kv[KEY_TYPE_COOKIE], key;
	struct kv		*match = NULL;
	int			 res;

	if (kv->kv_type != KEY_TYPE_COOKIE)
		return (0);

	switch (cre->dir) {
	case RELAY_DIR_REQUEST:
		key.kv_key = "Cookie";
		break;
	case RELAY_DIR_RESPONSE:
		key.kv_key = "Set-Cookie";
		break;
	default:
		return (0);
		/* NOTREACHED */
		break;
	}

	if (kv->kv_option == KEY_OPTION_APPEND ||
	    kv->kv_option == KEY_OPTION_SET) {
		/* no cookie, can be NULL and will be added later */
	} else {
		match = kv_find(&desc->http_headers, &key);
		if (match == NULL)
			return (-1);
		if (kv->kv_key == NULL || match->kv_value == NULL)
			return (0);
		else if ((res = relay_lookup_cookie(cre, match->kv_value,
		    kv)) != 0)
			return (res);
	}

	relay_match(actions, kv, match, &desc->http_headers);

	return (0);
}

int
relay_match_actions(struct ctl_relay_event *cre, struct relay_rule *rule,
    struct kvlist *matches, struct kvlist *actions)
{
	struct rsession		*con = cre->con;
	struct kv		*kv, *tmp;

	/*
	 * Apply the following options instantly (action per match).
	 */
	if (rule->rule_table != NULL)
		con->se_table = rule->rule_table;

	if (rule->rule_tag != 0)
		con->se_tag = rule->rule_tag == -1 ? 0 : rule->rule_tag;

	if (rule->rule_label != 0)
		con->se_label = rule->rule_label == -1 ? 0 : rule->rule_label;

	/*
	 * Apply the remaining options once after evaluation.
	 */
	if (matches == NULL) {
		/* 'pass' or 'block' rule */
		TAILQ_FOREACH_SAFE(kv, &rule->rule_kvlist, kv_rule_entry, tmp) {
			TAILQ_INSERT_TAIL(actions, kv, kv_action_entry);
			TAILQ_REMOVE(&rule->rule_kvlist, kv, kv_rule_entry);
		}
	} else {
		/* 'match' rule */
		TAILQ_FOREACH(kv, matches, kv_match_entry) {
			TAILQ_INSERT_TAIL(actions, kv, kv_action_entry);
		}
	}

	return (0);
}

int
relay_apply_actions(struct ctl_relay_event *cre, struct kvlist *actions)
{
	struct rsession		*con = cre->con;
	struct http_descriptor	*desc = cre->desc;
	struct kv		*host = NULL;
	const char		*value;
	struct kv		*kv, *match, *kp, *mp, kvcopy, matchcopy, key;
	int			 addkv, ret;
	char			 buf[IBUF_READ_SIZE], *ptr;
	char			*msg = NULL;
	const char		*meth = NULL;

	memset(&kvcopy, 0, sizeof(kvcopy));
	memset(&matchcopy, 0, sizeof(matchcopy));

	ret = -1;
	kp = mp = NULL;
	TAILQ_FOREACH(kv, actions, kv_action_entry) {
		kp = NULL;
		match = kv->kv_match;
		addkv = 0;

		/*
		 * Although marked as deleted, give a chance to non-critical
		 * actions, ie. log, to be performed
		 */
		if (match != NULL && (match->kv_flags & KV_FLAG_INVALID))
			goto matchdel;

		switch (kv->kv_option) {
		case KEY_OPTION_APPEND:
		case KEY_OPTION_SET:
			switch (kv->kv_type) {
			case KEY_TYPE_PATH:
				if (kv->kv_option == KEY_OPTION_APPEND) {
					if (kv_setkey(match, "%s%s",
					    match->kv_key, kv->kv_key) == -1)
						goto fail;
				} else {
					if (kv_setkey(match, "%s",
					    kv->kv_value) == -1)
						goto fail;
				}
				break;
			case KEY_TYPE_COOKIE:
				kp = &kvcopy;
				if (kv_inherit(kp, kv) == NULL)
					goto fail;
				if (kv_set(kp, "%s=%s;", kp->kv_key,
				    kp->kv_value) == -1)
					goto fail;
				if (kv_setkey(kp, "%s", cre->dir ==
				    RELAY_DIR_REQUEST ?
				    "Cookie" : "Set-Cookie") == -1)
					goto fail;
				/* FALLTHROUGH cookie is a header */
			case KEY_TYPE_HEADER:
				if (match == NULL) {
					addkv = 1;
					break;
				}
				if (match->kv_value == NULL ||
				    kv->kv_option == KEY_OPTION_SET) {
					if (kv_set(match, "%s",
					    kv->kv_value) == -1)
						goto fail;
				} else
					addkv = 1;
				break;
			default:
				/* query, url not supported */
				break;
			}
			break;
		case KEY_OPTION_REMOVE:
			switch (kv->kv_type) {
			case KEY_TYPE_PATH:
				if (kv_setkey(match, "/") == -1)
					goto fail;
				break;
			case KEY_TYPE_COOKIE:
			case KEY_TYPE_HEADER:
				if (kv->kv_matchtree != NULL)
					match->kv_flags |= KV_FLAG_INVALID;
				else
					kv_free(match);
				match = kv->kv_match = NULL;
				break;
			default:
				/* query and url not supported */
				break;
			}
			break;
		case KEY_OPTION_HASH:
			switch (kv->kv_type) {
			case KEY_TYPE_PATH:
				value = match->kv_key;
				break;
			default:
				value = match->kv_value;
				break;
			}
			SipHash24_Update(&con->se_siphashctx,
			    value, strlen(value));
			break;
		case KEY_OPTION_LOG:
			/* perform this later */
			break;
		default:
			fatalx("%s: invalid action", __func__);
			/* NOTREACHED */
		}

		/* from now on, reads from kp writes to kv */
		if (kp == NULL)
			kp = kv;
		if (addkv && kv->kv_matchtree != NULL) {
			/* Add new entry to the list (eg. new HTTP header) */
			if ((match = kv_add(kv->kv_matchtree, kp->kv_key,
			    kp->kv_value, 0)) == NULL)
				goto fail;
			match->kv_option = kp->kv_option;
			match->kv_type = kp->kv_type;
			kv->kv_match = match;
		}
		if (match != NULL && kp->kv_flags & KV_FLAG_MACRO) {
			bzero(buf, sizeof(buf));
			if ((ptr = relay_expand_http(cre, kp->kv_value, buf,
			    sizeof(buf))) == NULL)
				goto fail;
			if (kv_set(match, ptr) == -1)
				goto fail;
		}

 matchdel:
		switch (kv->kv_option) {
		case KEY_OPTION_LOG:
			if (match == NULL)
				break;
			mp = &matchcopy;
			if (kv_inherit(mp, match) == NULL)
				goto fail;
			if (mp->kv_flags & KV_FLAG_INVALID) {
				if (kv_set(mp, "%s (removed)",
				    mp->kv_value) == -1)
					goto fail;
			}
			switch (kv->kv_type) {
			case KEY_TYPE_URL:
				key.kv_key = "Host";
				host = kv_find(&desc->http_headers, &key);
				switch (kv->kv_digest) {
				case DIGEST_NONE:
					if (host == NULL ||
					    host->kv_value == NULL)
						break;
					if (kv_setkey(mp, "%s%s",
					    host->kv_value, mp->kv_key) ==
					    -1)
						goto fail;
					break;
				default:
					if (kv_setkey(mp, "%s", kv->kv_key)
					    == -1)
						goto fail;
					break;
				}
				break;
			default:
				break;
			}
			if (kv_log(con, mp, con->se_label, cre->dir)
			    == -1)
				goto fail;
			break;
		default:
			break;
		}

		/* actions applied, cleanup kv */
		kv->kv_match = NULL;
		kv->kv_matchtree = NULL;
		TAILQ_REMOVE(actions, kv, kv_match_entry);

		kv_free(&kvcopy);
		kv_free(&matchcopy);
	}

	/*
	 * log tag for request and response, request method
	 * and end of request marker ","
	 */
	if ((con->se_log != NULL) &&
	    ((meth = relay_httpmethod_byid(desc->http_method)) != NULL) &&
	    (asprintf(&msg, " %s",meth) >= 0))
		evbuffer_add(con->se_log, msg, strlen(msg));
	free(msg);
	relay_log(con, cre->dir == RELAY_DIR_REQUEST ? "" : ";");
	ret = 0;
 fail:
	kv_free(&kvcopy);
	kv_free(&matchcopy);

	return (ret);
}

#define	RELAY_GET_SKIP_STEP(i)						\
	do {								\
		r = r->rule_skip[i];					\
		DPRINTF("%s:%d: skip %d rules", __func__, __LINE__, i);	\
	} while (0)

#define	RELAY_GET_NEXT_STEP						\
	do {								\
		DPRINTF("%s:%d: next rule", __func__, __LINE__);	\
		goto nextrule;						\
	} while (0)

int
relay_test(struct protocol *proto, struct ctl_relay_event *cre)
{
	struct rsession		*con;
	struct http_descriptor	*desc = cre->desc;
	struct relay_rule	*r = NULL, *rule = NULL;
	u_int			 cnt = 0;
	u_int			 action = RES_PASS;
	struct kvlist		 actions, matches;
	struct kv		*kv;
	int			 res = 0;

	con = cre->con;
	TAILQ_INIT(&actions);

	r = TAILQ_FIRST(&proto->rules);
	while (r != NULL) {
		cnt++;

		TAILQ_INIT(&matches);
		TAILQ_INIT(&r->rule_kvlist);

		if (r->rule_dir && r->rule_dir != cre->dir)
			RELAY_GET_SKIP_STEP(RULE_SKIP_DIR);
		else if (proto->type != r->rule_proto)
			RELAY_GET_SKIP_STEP(RULE_SKIP_PROTO);
		else if (r->rule_af != AF_UNSPEC &&
		    (cre->ss.ss_family != r->rule_af ||
		     cre->dst->ss.ss_family != r->rule_af))
			RELAY_GET_SKIP_STEP(RULE_SKIP_AF);
		else if (RELAY_ADDR_CMP(&r->rule_src, &cre->ss) != 0)
			RELAY_GET_SKIP_STEP(RULE_SKIP_SRC);
		else if (RELAY_ADDR_CMP(&r->rule_dst, &cre->dst->ss) != 0)
			RELAY_GET_SKIP_STEP(RULE_SKIP_DST);
		else if (r->rule_method != HTTP_METHOD_NONE &&
		    (desc->http_method == HTTP_METHOD_RESPONSE ||
		     desc->http_method != r->rule_method))
			RELAY_GET_SKIP_STEP(RULE_SKIP_METHOD);
		else if (r->rule_tagged && con->se_tag != r->rule_tagged)
			RELAY_GET_NEXT_STEP;
		else if (relay_httpheader_test(cre, r, &matches) != 0)
			RELAY_GET_NEXT_STEP;
		else if ((res = relay_httpquery_test(cre, r, &matches)) != 0)
			RELAY_GET_NEXT_STEP;
		else if (relay_httppath_test(cre, r, &matches) != 0)
			RELAY_GET_NEXT_STEP;
		else if ((res = relay_httpurl_test(cre, r, &matches)) != 0)
			RELAY_GET_NEXT_STEP;
		else if ((res = relay_httpcookie_test(cre, r, &matches)) != 0)
			RELAY_GET_NEXT_STEP;
		else {
			DPRINTF("%s: session %d: matched rule %d",
			    __func__, con->se_id, r->rule_id);

			if (r->rule_action == RULE_ACTION_MATCH) {
				if (relay_match_actions(cre, r, &matches,
				    &actions) != 0) {
					/* Something bad happened, drop */
					action = RES_DROP;
					break;
				}
				RELAY_GET_NEXT_STEP;
			} else if (r->rule_action == RULE_ACTION_BLOCK)
				action = RES_DROP;
			else if (r->rule_action == RULE_ACTION_PASS)
				action = RES_PASS;

			/* Rule matched */
			rule = r;

			/* Temporarily save actions */
			TAILQ_FOREACH(kv, &matches, kv_match_entry) {
				TAILQ_INSERT_TAIL(&rule->rule_kvlist,
				    kv, kv_rule_entry);
			}

			if (rule->rule_flags & RULE_FLAG_QUICK)
				break;

 nextrule:
			/* Continue to find last matching policy */
			DPRINTF("%s: session %d, res %d", __func__,
			    con->se_id, res);
			if (res == RES_BAD || res == RES_INTERNAL)
				return (res);
			res = 0;
			r = TAILQ_NEXT(r, rule_entry);
		}
	}

	if (rule != NULL && relay_match_actions(cre, rule, NULL, &actions)
	    != 0) {
		/* Something bad happened, drop */
		action = RES_DROP;
	}

	if (relay_apply_actions(cre, &actions) != 0) {
		/* Something bad happened, drop */
		action = RES_DROP;
	}

	DPRINTF("%s: session %d: action %d", __func__,
	    con->se_id, action);

	return (action);
}

#define	RELAY_SET_SKIP_STEPS(i)						\
	do {								\
		while (head[i] != cur) {				\
			head[i]->rule_skip[i] = cur;			\
			head[i] = TAILQ_NEXT(head[i], rule_entry);	\
		}							\
	} while (0)

/* This code is derived from pf_calc_skip_steps() from pf.c */
void
relay_calc_skip_steps(struct relay_rules *rules)
{
	struct relay_rule	*head[RULE_SKIP_COUNT], *cur, *prev;
	int			 i;

	cur = TAILQ_FIRST(rules);
	prev = cur;
	for (i = 0; i < RULE_SKIP_COUNT; ++i)
		head[i] = cur;
	while (cur != NULL) {
		if (cur->rule_dir != prev->rule_dir)
			RELAY_SET_SKIP_STEPS(RULE_SKIP_DIR);
		else if (cur->rule_proto != prev->rule_proto)
			RELAY_SET_SKIP_STEPS(RULE_SKIP_PROTO);
		else if (cur->rule_af != prev->rule_af)
			RELAY_SET_SKIP_STEPS(RULE_SKIP_AF);
		else if (RELAY_ADDR_NEQ(&cur->rule_src, &prev->rule_src))
			RELAY_SET_SKIP_STEPS(RULE_SKIP_SRC);
		else if (RELAY_ADDR_NEQ(&cur->rule_dst, &prev->rule_dst))
			RELAY_SET_SKIP_STEPS(RULE_SKIP_DST);
		else if (cur->rule_method != prev->rule_method)
			RELAY_SET_SKIP_STEPS(RULE_SKIP_METHOD);

		prev = cur;
		cur = TAILQ_NEXT(cur, rule_entry);
	}
	for (i = 0; i < RULE_SKIP_COUNT; ++i)
		RELAY_SET_SKIP_STEPS(i);
}

void
relay_match(struct kvlist *actions, struct kv *kv, struct kv *match,
    struct kvtree *matchtree)
{
	if (kv->kv_option != KEY_OPTION_NONE) {
		kv->kv_match = match;
		kv->kv_matchtree = matchtree;
		TAILQ_INSERT_TAIL(actions, kv, kv_match_entry);
	}
}
@


1.65
log
@Migrate relayd to use libtls for TLS. Still does the TLS privsep via the
engine but at least we can use a sane API for new features.
Going in now so it is possible to work with this in tree.
General agreement at d2k17.
@
text
@d1 1
a1 1
/*	$OpenBSD: relay_http.c,v 1.64 2017/03/10 21:04:35 reyk Exp $	*/
d1595 1
a1595 1
			fatalx("relay_action: invalid action");
@


1.64
log
@DELETE can have a body.

Fix by Rivo Nurges, fixes a problem with Atlassian JIRA

OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay_http.c,v 1.63 2016/09/26 16:25:16 reyk Exp $	*/
a717 5
	if (cre->buf != NULL) {
		free(cre->buf);
		cre->buf = NULL;
		cre->buflen = 0;
	}
@


1.63
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: relay_http.c,v 1.62 2016/08/01 21:25:53 benno Exp $	*/
a420 1
		case HTTP_METHOD_DELETE:
d428 1
@


1.62
log
@whitespace and 80 columns, no binary change
@
text
@d1 1
a1 1
/*	$OpenBSD: relay_http.c,v 1.61 2016/08/01 21:14:45 benno Exp $	*/
d1793 1
a1793 1
				return(res);
@


1.61
log
@rfc 7230 3.3.3 says: response with a status code of 1xx
(Informational) or 204 (No Content) MUST not have a Content-Length.
Add a check for that.
ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay_http.c,v 1.60 2016/07/29 10:09:26 reyk Exp $	*/
d344 1
a344 2
			cre->toread = strtonum(value, 0, LLONG_MAX,
			    &errstr);
d1795 1
a1795 1
	       		r = TAILQ_NEXT(r, rule_entry);
d1799 2
a1800 1
	if (rule != NULL && relay_match_actions(cre, rule, NULL, &actions) != 0) {
@


1.60
log
@Bump copyright in files that I touched last.
(btw. hostated-hoststated-relayd's 10th birthday is on Dec 16.)
@
text
@d1 1
a1 1
/*	$OpenBSD: relay_http.c,v 1.59 2016/07/29 10:00:12 reyk Exp $	*/
d261 9
d315 4
a320 4
				/*
				 * These method should not have a body
				 * and thus no Content-Length header.
				 */
d324 13
a336 1

@


1.59
log
@Add support for common WebDAV methods;  from httpd.

Found and tested by Michael Lechtermann
OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay_http.c,v 1.58 2016/07/27 11:02:41 reyk Exp $	*/
d4 1
a4 1
 * Copyright (c) 2006 - 2015 Reyk Floeter <reyk@@openbsd.org>
@


1.58
log
@According to RFC 7231 4.3.7, OPTIONS may have body. "Although this
specification does not define any use for such a payload, future
extensions to HTTP might use the OPTIONS body to make more detailed
queries about the target resource." The future has arrived.

Found and tested by Michael Lechtermann
OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay_http.c,v 1.57 2016/07/27 06:55:44 reyk Exp $	*/
d404 3
a409 1
		case HTTP_METHOD_PATCH:
d413 23
@


1.57
log
@Improve parsing of the Host by following RFC 7230 Section 5.4 more strictly:

- Respond with a 400 (Bad Request) if there is more than one Host:
header to prevent ambiguities.

- Make sure that the host in the optional absolute form of
request-target (eg. GET http://www.target.com/ HTTP/1.1) matches the
Host: value.  Proxies are supposed to ignore the Host: value if the
request-target exists, but relayd used to ignore the absolute
request-target form instead.  In HTTP terminology, relayd is a gateway
and not a proxy, but it has to make sure that the host is validated
consistently.

OK benno@@ bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay_http.c,v 1.56 2016/07/22 09:30:36 benno Exp $	*/
a403 1
		case HTTP_METHOD_OPTIONS:
d406 1
@


1.56
log
@fix some cases where we relay_abort_http() the connection too soon.
instead, pass a more specific error back and handle the errors in
relay_test() instead.
reported by Arto Jonsson and Hiltjo Posthuma, thanks!
ok bluhm@@ reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay_http.c,v 1.55 2015/12/15 10:36:59 reyk Exp $	*/
d153 2
a154 1
	int			 action;
d335 23
d360 4
a363 3
			    value)) == NULL) {
				free(line);
				goto fail;
d1565 1
a1565 1
			    kp->kv_value)) == NULL)
@


1.56.2.1
log
@Improve parsing of the Host-header by following RFC 7230 Section 5.4 more
strictly. MFC relay_http.c v 1.57, relayd.c v 1.154, relayd.h v 1.224
@
text
@d1 1
a1 1
/*	$OpenBSD: relay_http.c,v 1.56 2016/07/22 09:30:36 benno Exp $	*/
d153 1
a153 2
	char			*urlproto, *host, *path;
	int			 action, unique, ret;
a333 23
		/* The following header should only occur once */
		if (strcasecmp("Host", key) == 0) {
			unique = 1;

			/*
			 * The path may contain a URL.  The host in the
			 * URL has to match the Host: value.
			 */
			if (parse_url(desc->http_path,
			    &urlproto, &host, &path) == 0) {
				ret = strcasecmp(host, value);
				free(urlproto);
				free(host);
				free(path);
				if (ret != 0) {
					relay_abort_http(con, 400,
					    "malformed host", 0);
					goto abort;
				}
			}
		} else
			unique = 0;

d336 3
a338 4
			    value, unique)) == NULL) {
				relay_abort_http(con, 400,
				    "malformed header", 0);
				goto abort;
d1540 1
a1540 1
			    kp->kv_value, 0)) == NULL)
@


1.55
log
@PATCH is like PUT, data is expected.

From mxb at alumni chalmers se
@
text
@d1 1
a1 1
/*	$OpenBSD: relay_http.c,v 1.54 2015/12/07 04:03:27 mmcc Exp $	*/
d352 2
a353 1
		if (action == RES_FAIL) {
d356 10
a365 1
		} else if (action != RES_PASS) {
a710 1
	struct rsession		*con = cre->con;
d726 2
a727 2
	DPRINTF("%s: session %d: host '%s', path '%s', query '%s'",
	    __func__, con->se_id, host, desc->http_path,
d731 1
a731 2
		relay_abort_http(con, 400, "invalid host name", 0);
		return (RES_FAIL);
d746 1
a746 2
		relay_abort_http(con, 500, "failed to allocate path", 0);
		return (RES_FAIL);
a787 1
	struct rsession		*con = cre->con;
d792 1
a792 2
		relay_abort_http(con, 500, "failed to allocate cookie", 0);
		return (RES_FAIL);
d818 2
a819 3
		DPRINTF("%s: session %d: %s = %s, %s = %s : %d",
		    __func__, con->se_id,
		    key, value, kv->kv_key, kv->kv_value,
d849 1
a849 2
		relay_abort_http(cre->con, 500, "failed to allocate query", 0);
		return (-1);
d1234 1
d1240 2
a1241 2
	else if (relay_lookup_query(cre, kv))
		return (-1);
d1316 1
d1331 2
a1332 3
	} else if (relay_lookup_url(cre, host->kv_value, kv) != 0)
		return (-1);

d1345 1
d1372 3
a1374 2
		else if (relay_lookup_cookie(cre, match->kv_value, kv) != 0)
			return (-1);
d1649 1
d1657 1
d1660 1
d1681 1
a1681 1
		else if (relay_httpquery_test(cre, r, &matches) != 0)
d1685 1
a1685 1
		else if (relay_httpurl_test(cre, r, &matches) != 0)
d1687 1
a1687 1
		else if (relay_httpcookie_test(cre, r, &matches) != 0)
d1720 6
a1725 1
			r = TAILQ_NEXT(r, rule_entry);
d1729 1
a1729 2
	if (rule != NULL &&
	    relay_match_actions(cre, rule, NULL, &actions) != 0) {
@


1.55.2.1
log
@reliability fix: When signaling an error to an HTTP relay client, the
connection can be terminated prematurely, leading to a crash.
@
text
@d1 1
a1 1
/*	$OpenBSD: relay_http.c,v 1.55 2015/12/15 10:36:59 reyk Exp $	*/
d352 1
a352 2
		switch (action) {
		case RES_FAIL:
d355 1
a355 10
		case RES_BAD:
			relay_abort_http(con, 400, "Bad Request",
			    con->se_label);
			return;
		case RES_INTERNAL:
			relay_abort_http(con, 500, "Internal Server Error",
			    con->se_label);
			return;
		}
		if (action != RES_PASS) {
d701 1
d717 2
a718 2
	DPRINTF("%s: host '%s', path '%s', query '%s'",
	    __func__, host, desc->http_path,
d722 2
a723 1
		return (RES_BAD);
d738 2
a739 1
		return (RES_INTERNAL);
d781 1
d786 2
a787 1
		return (RES_INTERNAL);
d813 3
a815 2
		DPRINTF("%s: key %s = %s, %s = %s : %d",
		    __func__, key, value, kv->kv_key, kv->kv_value,
d845 2
a846 1
		return (RES_INTERNAL);
a1230 1
	int			 res = 0;
d1236 2
a1237 2
	else if ((res = relay_lookup_query(cre, kv)) != 0)
		return (res);
a1311 1
	int			 res;
d1326 3
a1328 2
	} else if ((res = relay_lookup_url(cre, host->kv_value, kv)) != 0)
		return (res);
a1340 1
	int			 res;
d1367 2
a1368 3
		else if ((res = relay_lookup_cookie(cre, match->kv_value,
		    kv)) != 0)
			return (res);
a1642 1
	int			 res = 0;
a1649 1

a1651 1

d1672 1
a1672 1
		else if ((res = relay_httpquery_test(cre, r, &matches)) != 0)
d1676 1
a1676 1
		else if ((res = relay_httpurl_test(cre, r, &matches)) != 0)
d1678 1
a1678 1
		else if ((res = relay_httpcookie_test(cre, r, &matches)) != 0)
d1711 1
a1711 6
			DPRINTF("%s: session %d, res %d", __func__,
			    con->se_id, res);
			if (res == RES_BAD || res == RES_INTERNAL)
				return(res);
			res = 0;
	       		r = TAILQ_NEXT(r, rule_entry);
d1715 2
a1716 1
	if (rule != NULL && relay_match_actions(cre, rule, NULL, &actions) != 0) {
@


1.55.2.2
log
@Improve parsing of the Host-header by following RFC 7230 Section 5.4 more
strictly. MFC relay_http.c v 1.57, relayd.c v 1.154, relayd.h v 1.224
@
text
@d1 1
a1 1
/*	$OpenBSD: relay_http.c,v 1.55.2.1 2016/07/23 21:01:33 benno Exp $	*/
d153 1
a153 2
	char			*urlproto, *host, *path;
	int			 action, unique, ret;
a333 23
		/* The following header should only occur once */
		if (strcasecmp("Host", key) == 0) {
			unique = 1;

			/*
			 * The path may contain a URL.  The host in the
			 * URL has to match the Host: value.
			 */
			if (parse_url(desc->http_path,
			    &urlproto, &host, &path) == 0) {
				ret = strcasecmp(host, value);
				free(urlproto);
				free(host);
				free(path);
				if (ret != 0) {
					relay_abort_http(con, 400,
					    "malformed host", 0);
					goto abort;
				}
			}
		} else
			unique = 0;

d336 3
a338 4
			    value, unique)) == NULL) {
				relay_abort_http(con, 400,
				    "malformed header", 0);
				goto abort;
d1540 1
a1540 1
			    kp->kv_value, 0)) == NULL)
@


1.54
log
@Remove NULL-checks before free(). No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: relay_http.c,v 1.53 2015/09/27 20:21:04 deraadt Exp $	*/
d372 1
@


1.53
log
@include <unistd.h> unconditionally
ok benno
@
text
@d1 1
a1 1
/*	$OpenBSD: relay_http.c,v 1.52 2015/07/28 10:24:26 reyk Exp $	*/
d129 10
a138 20
	if (desc->http_path != NULL) {
		free(desc->http_path);
		desc->http_path = NULL;
	}
	if (desc->http_query != NULL) {
		free(desc->http_query);
		desc->http_query = NULL;
	}
	if (desc->http_version != NULL) {
		free(desc->http_version);
		desc->http_version = NULL;
	}
	if (desc->query_key != NULL) {
		free(desc->query_key);
		desc->query_key = NULL;
	}
	if (desc->query_val != NULL) {
		free(desc->query_val);
		desc->query_val = NULL;
	}
d603 1
a603 2
		if (line != NULL)
			free(line);
d692 1
a692 2
	if (md != NULL)
		free(md);
@


1.52
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: relay_http.c,v 1.51 2015/07/18 16:01:28 benno Exp $	*/
a37 1
#if DEBUG > 1
a38 1
#endif
@


1.52.4.1
log
@reliability fix: When signaling an error to an HTTP relay client, the
connection can be terminated prematurely, leading to a crash.
@
text
@d1 1
a1 1
/*	$OpenBSD: relay_http.c,v 1.52 2015/07/28 10:24:26 reyk Exp $	*/
d364 1
a364 2
		switch (action) {
		case RES_FAIL:
d367 1
a367 10
		case RES_BAD:
			relay_abort_http(con, 400, "Bad Request",
			    con->se_label);
			return;
		case RES_INTERNAL:
			relay_abort_http(con, 500, "Internal Server Error",
			    con->se_label);
			return;
		}
		if (action != RES_PASS) {
d714 1
d730 2
a731 2
	DPRINTF("%s: host '%s', path '%s', query '%s'",
	    __func__, host, desc->http_path,
d735 2
a736 1
		return (RES_BAD);
d751 2
a752 1
		return (RES_INTERNAL);
d794 1
d799 2
a800 1
		return (RES_INTERNAL);
d826 3
a828 2
		DPRINTF("%s: key %s = %s, %s = %s : %d",
		    __func__, key, value, kv->kv_key, kv->kv_value,
d858 2
a859 1
		return (RES_INTERNAL);
a1243 1
	int			 res = 0;
d1249 2
a1250 2
	else if ((res = relay_lookup_query(cre, kv)) != 0)
		return (res);
a1324 1
	int			 res;
d1339 3
a1341 2
	} else if ((res = relay_lookup_url(cre, host->kv_value, kv)) != 0)
		return (res);
a1353 1
	int			 res;
d1380 2
a1381 3
		else if ((res = relay_lookup_cookie(cre, match->kv_value,
		    kv)) != 0)
			return (res);
a1655 1
	int			 res = 0;
a1662 1

a1664 1

d1685 1
a1685 1
		else if ((res = relay_httpquery_test(cre, r, &matches)) != 0)
d1689 1
a1689 1
		else if ((res = relay_httpurl_test(cre, r, &matches)) != 0)
d1691 1
a1691 1
		else if ((res = relay_httpcookie_test(cre, r, &matches)) != 0)
d1724 1
a1724 6
			DPRINTF("%s: session %d, res %d", __func__,
			    con->se_id, res);
			if (res == RES_BAD || res == RES_INTERNAL)
				return(res);
			res = 0;
	       		r = TAILQ_NEXT(r, rule_entry);
d1728 2
a1729 1
	if (rule != NULL && relay_match_actions(cre, rule, NULL, &actions) != 0) {
@


1.52.4.2
log
@Improve parsing of the Host-header by following RFC 7230 Section 5.4 more
strictly. MFC relay_http.c v 1.57, relayd.c v 1.154, relayd.h v 1.224
@
text
@d1 1
a1 1
/*	$OpenBSD: relay_http.c,v 1.52.4.1 2016/07/23 20:56:02 benno Exp $	*/
d165 1
a165 2
	char			*urlproto, *host, *path;
	int			 action, unique, ret;
a345 23
		/* The following header should only occur once */
		if (strcasecmp("Host", key) == 0) {
			unique = 1;

			/*
			 * The path may contain a URL.  The host in the
			 * URL has to match the Host: value.
			 */
			if (parse_url(desc->http_path,
			    &urlproto, &host, &path) == 0) {
				ret = strcasecmp(host, value);
				free(urlproto);
				free(host);
				free(path);
				if (ret != 0) {
					relay_abort_http(con, 400,
					    "malformed host", 0);
					goto abort;
				}
			}
		} else
			unique = 0;

d348 3
a350 4
			    value, unique)) == NULL) {
				relay_abort_http(con, 400,
				    "malformed header", 0);
				goto abort;
d1553 1
a1553 1
			    kp->kv_value, 0)) == NULL)
@


1.51
log
@Fix unbounded buffer growth. In the case of a slow client reading large files,
we would consume large ammounts of memory.
Found by Matthew Martin <matt DOT a DOT martin AT gmail DOT com> in
httpd, fixed in httpd by florian@@
feedback from florian, reyk and bluhm, ok bluhm, reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: relay_http.c,v 1.50 2015/06/12 14:40:55 reyk Exp $	*/
d1352 1
a1352 1
	struct kv               *kv = &rule->rule_kv[KEY_TYPE_COOKIE], key;
@


1.50
log
@To match relayd's style, use an explicit enum with prefixed names for
the states that Claudio introduced.  No functional change.

OK claudio@@ benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay_http.c,v 1.49 2015/06/08 15:47:51 claudio Exp $	*/
d464 2
d503 5
d524 1
d627 5
@


1.49
log
@Introduce a state on the ctl_relay_event struct. This makes it possible
to better track the connection state of a session and stops doing double
opens in certain situations using http relays. Using a state field to
simplify the logic since relay_connect() is called multiple times.
OK benno@@, bluhm@@ and running in production for more than a week
@
text
@d1 1
a1 1
/*	$OpenBSD: relay_http.c,v 1.48 2015/06/01 09:54:16 claudio Exp $	*/
d424 1
a424 1
		    cre->dst->state != CONNECTED) {
@


1.48
log
@Fix memory leak in error case. OK bluhm@@ benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay_http.c,v 1.47 2015/05/22 01:34:13 jsg Exp $	*/
d424 1
a424 1
		    cre->dst->bev == NULL) {
@


1.47
log
@fix a non safe use of TAILQ_FOREACH with TAILQ_REMOVE
ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay_http.c,v 1.46 2015/05/18 16:57:20 bluhm Exp $	*/
d278 2
a279 1
			    == HTTP_METHOD_NONE)
d281 1
@


1.46
log
@Fix a crash reported and analyzed by Bertrand PROVOST.  When a HTTP
client or server writes multiple requests or chunks in a single
transfer, relayd invokes the libevent callback manually for the
next data.  If the callback closes the session, this resulted in
an use after free.
Instead of the more complicated fix suggested by Bertrand PROVOST,
just move the invocation of the callback to the end of the function.
So in case the callback frees any structures, they are not accessed.
OK benno@@ reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay_http.c,v 1.45 2015/05/18 16:45:16 bluhm Exp $	*/
d1379 1
a1379 1
	struct kv		*kv;
d1398 1
a1398 1
		TAILQ_FOREACH(kv, &rule->rule_kvlist, kv_rule_entry) {
@


1.45
log
@The first line of a HTTP request is the method-url-version.  The
second line is a key-value header.  So you cannot append to the
previous key-value before line three.  Also reset the last header
when all headers are purged to avoid a use after free.
OK benno@@ reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay_http.c,v 1.44 2015/04/29 08:41:24 bluhm Exp $	*/
d437 9
d448 1
a448 3
	bufferevent_enable(bev, EV_READ);
	if (relay_splice(cre) == -1)
		relay_close(con, strerror(errno));
d498 1
d501 1
a501 1
	bufferevent_enable(bev, EV_READ);
d616 1
d619 1
a619 1
	bufferevent_enable(bev, EV_READ);
@


1.44
log
@When the HTTP client did close the connection while relayd was still
parsig the HTTP header, the session was never destroyed.  This
resulted in a file descriptor leak.
Add a check wether the protocol knows how much data to expect.  If
relayd is reading unlimited data or is expecting nothing to read,
ignore the end-of-file.  Otherwise it is a protocol violation, so
close the session immediately.
While there, make relayd compile with DEBUG defined.
Based on a diff from claudio@@; tested by claudio@@; OK claudio@@ benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay_http.c,v 1.43 2015/01/22 17:42:09 reyk Exp $	*/
d152 1
d217 1
a217 1
			if (cre->line == 1) {
@


1.43
log
@Clean up the relayd headers with help of include-what-you-use and some
manual review.  Based on common practice, relayd.h now includes the
necessary headers for itself.

OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay_http.c,v 1.42 2015/01/22 15:21:28 reyk Exp $	*/
d38 3
@


1.43.2.1
log
@maintainance diff for relayd
MFC the following changes

- Missing free(3) in error path (ssl.c,v 1.29)
- fix a memory leak. (pfe.c,v 1.80)
- allocate se_log evbuffer before loging errors with relay_close()
  (relay.c,v 1.192)
- fix a file descriptor leak in http protocol handling
  (relay.c,v 1.193 and relay_http.c,v 1.44)
- Fix obvious problems with relayd config reload
  (ca.c,v 1.13; config.c,v 1.25; parse.y,v 1.204;
  relayd.c,v 1.139; relayd.h,v 1.209)
- http protocol: you cannot append to the previous key-value before
  line three of a request (relay_http.c,v 1.45)
- fix a crash / use after free (relay.c,v 1.194; relay_http.c,v 1.46)
- fix a non safe use of TAILQ_FOREACH with TAILQ_REMOVE
  (relay_http.c,v 1.47)
- Plug a memory leak by simplifying kv_free() (relayd.c,v 1.141)
- Fix memory leak in error case (relay_http.c,v 1.48)
- track the connection state of a session and stops doing double
  opens in certain situations (relay.c,v 1.195; relay_http.c,v 1.49; relayd.h,v 1.210)
- coding style (relay.c,v 1.196; relay_http.c,v 1.50; relayd.h,v 1.212)

ok claudio@@, sthen@@ and feedback tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay_http.c,v 1.43 2015/01/22 17:42:09 reyk Exp $	*/
a37 3
#if DEBUG > 1
#include <unistd.h>
#endif
a148 1
	desc->http_lastheader = NULL;
d213 1
a213 1
			if (cre->line <= 2) {
d274 1
a274 2
			    == HTTP_METHOD_NONE) {
				free(line);
a275 1
			}
d418 1
a418 1
		    cre->dst->state != STATE_CONNECTED) {
a432 9
	switch (relay_splice(cre)) {
	case -1:
		relay_close(con, strerror(errno));
	case 1:
		return;
	case 0:
		break;
	}
	bufferevent_enable(bev, EV_READ);
d435 3
a437 1
	/* The callback readcb() might have freed the session. */
a486 1
	bufferevent_enable(bev, EV_READ);
d489 1
a489 1
	/* The callback readcb() might have freed the session. */
a603 1
	bufferevent_enable(bev, EV_READ);
d606 1
a606 1
	/* The callback readcb() might have freed the session. */
d1366 1
a1366 1
	struct kv		*kv, *tmp;
d1385 1
a1385 1
		TAILQ_FOREACH_SAFE(kv, &rule->rule_kvlist, kv_rule_entry, tmp) {
@


1.42
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: relay_http.c,v 1.41 2015/01/16 15:06:40 deraadt Exp $	*/
a21 1
#include <sys/stat.h>
a22 1
#include <sys/un.h>
a24 1
#include <net/if.h>
d26 1
a26 2
#include <netinet/ip.h>
#include <netinet/tcp.h>
d28 3
a31 2
#include <fcntl.h>
#include <stdlib.h>
d33 1
a33 4
#include <unistd.h>
#include <stdio.h>
#include <err.h>
#include <pwd.h>
d36 2
a37 2

#include <openssl/ssl.h>
@


1.41
log
@Adapt to <limits.h> universe.
ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: relay_http.c,v 1.40 2015/01/13 09:24:20 reyk Exp $	*/
d1255 2
a1256 1
		if (fnmatch(kv->kv_key, match->kv_key, FNM_CASEFOLD) == FNM_NOMATCH)
d1541 1
a1541 1
		switch(kv->kv_option) {
d1550 1
a1550 1
				   mp->kv_value) == -1)
d1553 1
a1553 1
			switch(kv->kv_type) {
@


1.40
log
@bump copyright year
@
text
@d1 1
a1 1
/*	$OpenBSD: relay_http.c,v 1.39 2015/01/01 14:54:06 reyk Exp $	*/
d696 1
a696 1
	char			 ph[MAXHOSTNAMELEN];
@


1.39
log
@Merge error page changes from httpd: send Content-Length:, change
Date: from asctime to the preferred HTTP/1.1 format, and use the
popular "Comic Sans" style (can be changed in the configuration).
@
text
@d1 1
a1 1
/*	$OpenBSD: relay_http.c,v 1.38 2015/01/01 14:21:06 reyk Exp $	*/
d4 1
a4 1
 * Copyright (c) 2006 - 2014 Reyk Floeter <reyk@@openbsd.org>
@


1.38
log
@Use the recommended HTML5 doctype in error pages.

OK validator.w3.org (This document was successfully checked as HTML5!)
@
text
@d1 1
a1 1
/*	$OpenBSD: relay_http.c,v 1.37 2014/12/21 00:54:49 guenther Exp $	*/
d874 11
d893 1
a893 3
	char			*httpmsg;
	time_t			 t;
	struct tm		*lt;
d896 1
d918 2
a919 6
	/* RFC 2616 "tolerates" asctime() */
	time(&t);
	lt = localtime(&t);
	tmbuf[0] = '\0';
	if (asctime_r(lt, tmbuf) != NULL)
		tmbuf[strlen(tmbuf) - 1] = '\0';	/* skip final '\n' */
d922 4
a925 1
	if (code != 500)
d927 2
d931 4
a934 2
	if ((style = rlay->rl_proto->style) == NULL)
		style = "body { background-color: #a00000; color: white; }";
d937 1
a937 7
	if (asprintf(&httpmsg,
	    "HTTP/1.0 %03d %s\r\n"
	    "Date: %s\r\n"
	    "Server: %s\r\n"
	    "Connection: close\r\n"
	    "Content-Type: text/html\r\n"
	    "\r\n"
a950 1
	    code, httperr, tmbuf, RELAYD_SERVERNAME,
d953 14
a966 1
	    RELAYD_SERVERNAME, hbuf, ntohs(rlay->rl_conf.port)) == -1)
d974 1
@


1.37
log
@Stop pulling in <arpa/inet.h> or <arpa/nameser.h> when unnecessary.
*Do* pull it in when in_{port,addr}_h is needed and <netinet/in.h> isn't.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay_http.c,v 1.36 2014/12/18 20:55:01 reyk Exp $	*/
d931 1
a931 2
	    "<!DOCTYPE HTML PUBLIC "
	    "\"-//W3C//DTD HTML 4.01 Transitional//EN\">\n"
@


1.36
log
@Update relayd to use siphash instead of sys/hash.  The source-hash,
loadbalance and hash modes use a random key by default that can be
forced to be a static key with a new configuration argument.

With input from Max Fillinger.

ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay_http.c,v 1.35 2014/10/25 03:23:49 lteo Exp $	*/
a30 1
#include <arpa/inet.h>
@


1.35
log
@Remove unnecessary netinet/in_systm.h include.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay_http.c,v 1.34 2014/09/15 08:06:11 reyk Exp $	*/
a25 1
#include <sys/hash.h>
d1489 2
a1490 6
			if (!con->se_hashkeyset)
				con->se_hashkey = HASHINIT;
			con->se_hashkey = hash32_str(value, con->se_hashkey);
			con->se_hashkeyset = 1;
			log_debug("%s: hashkey 0x%04x", __func__,
			    con->se_hashkey);
@


1.34
log
@Make the HTTP version mandatory and abort if it is missing in the request.
@
text
@d1 1
a1 1
/*	$OpenBSD: relay_http.c,v 1.33 2014/08/10 21:55:17 bluhm Exp $	*/
a28 1
#include <netinet/in_systm.h>
@


1.33
log
@There was a race in relayd that caused connections to hang.  It
happend with non-persistent PUT connections that had a very short
body.  If the whole body was read from the client before the
connection to the server was set up, the event callback was not
called.  Do the regular checks after relay_connect() succeeded.
OK reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay_http.c,v 1.32 2014/07/17 11:35:26 stsp Exp $	*/
d294 5
a298 2
			if (desc->http_version != NULL)
				*desc->http_version++ = '\0';
d305 1
a305 1
			 * be changed independetly by the filters later.
d307 1
a307 2
			if (desc->http_version != NULL &&
			    (desc->http_version =
@


1.32
log
@Move comment about strcasecmp() to a more suitable spot.
ok reyk benno
@
text
@d1 1
a1 1
/*	$OpenBSD: relay_http.c,v 1.31 2014/07/14 00:11:12 bluhm Exp $	*/
d430 1
a430 1
			if (relay_connect(con) == -1)
d432 2
a433 1
			return;
@


1.32.4.1
log
@backport 1.34. Don't crash without HTTP version.
@
text
@d1 1
a1 1
/*	$OpenBSD: relay_http.c,v 1.32 2014/07/17 11:35:26 stsp Exp $	*/
d294 2
a295 5
			if (desc->http_version == NULL) {
				free(line);
				goto fail;
			}
			*desc->http_version++ = '\0';
d302 1
a302 1
			 * be changed independently by the filters later.
d304 2
a305 1
			if ((desc->http_version =
@


1.31
log
@When a connection was spliced in one direction and in copy mode in
the other direction, the timeouts did not work.  They were longer
than specified.  Link the splicing and non-splicing timeouts.
Found by make run-regress-args-timeout-http.pl
OK reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay_http.c,v 1.30 2014/07/13 15:39:01 reyk Exp $	*/
a1135 4
	/*
	 * RFC 2616 section 5.1.1 says that the method is case
	 * sensitive so we don't do a strcasecmp here.
	 */
d1165 5
@


1.30
log
@Remove a debug message
@
text
@d1 1
a1 1
/*	$OpenBSD: relay_http.c,v 1.29 2014/07/13 00:32:08 benno Exp $	*/
d176 1
d461 1
d515 1
@


1.29
log
@improve log output for relays. adjust regress tests
ok reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: relay_http.c,v 1.28 2014/07/13 00:18:05 benno Exp $	*/
a1092 1
	DPRINTF("%s: ptr %s", __func__, ptr);
@


1.28
log
@repair matching of headers, add regress test for this error
ok reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: relay_http.c,v 1.27 2014/07/12 15:47:18 benno Exp $	*/
d1392 2
d1558 2
a1559 1
			if (kv_log(con->se_log, mp, con->se_label) == -1)
d1575 10
@


1.27
log
@fix relay "append header" action, add regression test for append
ok reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: relay_http.c,v 1.26 2014/07/12 14:34:13 reyk Exp $	*/
d1232 7
@


1.26
log
@Move HTTP error codes into http.h.

ok benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay_http.c,v 1.25 2014/07/11 23:11:54 benno Exp $	*/
d1440 2
a1441 5
				} else {
					if (kv_setkey(match, "%s,%s",
					    match->kv_key, kv->kv_key) == -1)
						goto fail;
				}
@


1.25
log
@optimize a FALLTHROUGH
implicit ok reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: relay_http.c,v 1.24 2014/07/11 22:28:44 reyk Exp $	*/
d71 1
d90 1
d104 3
d878 1
a878 1
	const char		*httperr = print_httperror(code), *text = "";
d885 3
d1168 23
@


1.24
log
@Limit HTTP header length to about 8K (based on the default of 4-8K in
common web servers).  Add a related regress test.

OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay_http.c,v 1.23 2014/07/11 11:48:50 reyk Exp $	*/
d378 1
a378 1
			/* FALLTHROUGH */
@


1.23
log
@Simplify the code that handles the HTTP headers by using an RB tree
with associated lists instead of the complicated lookup table and
"others" list.  This might add a little malloc overhead for common
headers but also fixes some issues like the handling of repeated
headers -  for example, handling of multiple "Set-Cookie" headers.

ok bluhm@@ (regress part)
ok benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay_http.c,v 1.22 2014/07/10 20:02:32 bluhm Exp $	*/
d167 1
a167 1
	size_t			 size;
d183 2
d189 1
a189 1
		if (!strlen(line)) {
d196 8
d627 1
@


1.22
log
@Print "%s (removed)" into relayd log and test for that string.
suggested by reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay_http.c,v 1.21 2014/07/10 00:05:59 reyk Exp $	*/
d62 1
a70 1
static int	 relay_httpheader_cmp(const void *, const void *);
a88 1
static struct http_header	 http_headers[] = HTTP_HEADERS;
a101 3
	qsort(http_headers, sizeof(http_headers) /
	    sizeof(http_headers[0]) - 1,
	    sizeof(http_headers[0]), relay_httpheader_cmp);
d122 2
a123 1
	TAILQ_INIT(&desc->http_headers);
a131 2
	int	i;

a151 2
	for (i = HTTP_HEADER_NONE; i < HTTP_HEADER_MAX; i++)
		desc->http_header[i] = NULL;
a168 1
	enum httpheader		 hdrid;
d213 2
a214 1
			if (kv_extend(&desc->http_headers, line) == NULL) {
d337 1
a337 15
			/*
			 * Remember the header if it is known to us for a
			 * quicker lookup later.
			 */
			if ((hdrid = relay_httpheader_byname(key)) !=
			    HTTP_HEADER_OTHER) {
				if (desc->http_header[hdrid] != NULL) {
					kv_delete(&desc->http_headers, hdr);
					free(line);
					relay_abort_http(con, 400, "repeated "
					    "header line", 0);
					return;
				}
				desc->http_header[hdrid] = hdr;
			}
d1059 29
d1091 1
a1091 1
	struct kv		*hdr;
a1092 1
	char			*ptr;
d1094 2
a1095 10
	TAILQ_FOREACH(hdr, &desc->http_headers, kv_entry) {
		if (hdr->kv_flags & KV_FLAG_INVALID)
			continue;
		ptr = hdr->kv_value;
		DPRINTF("%s: ptr %s", __func__, ptr);
		if (relay_bufferevent_print(dst, hdr->kv_key) == -1 ||
		    (ptr != NULL &&
		    (relay_bufferevent_print(dst, ": ") == -1 ||
		    relay_bufferevent_print(dst, ptr) == -1 ||
		    relay_bufferevent_print(dst, "\r\n") == -1)))
d1097 4
a1100 2
		DPRINTF("%s: %s: %s", __func__, hdr->kv_key,
			hdr->kv_value == NULL ? "" : hdr->kv_value);
a1142 37
const char *
relay_httpheader_byid(u_int id)
{
	const char	*name = NULL;
	int		 i;

	for (i = 0; http_headers[i].header_name != NULL; i++) {
		if (http_headers[i].header_id == id) {
			name = http_headers[i].header_name;
			break;
		}
	}

	return (name);
}

u_int
relay_httpheader_byname(const char *name)
{
	enum httpheader		 id = HTTP_HEADER_OTHER;
	struct http_header	 header, *res = NULL;

	/* Set up key */
	header.header_name = name;

	/*
	 * In contrast to HTTP methods, HTTP header names are
	 * case-insensitive (see RFC 2616 section 2.4).
	 */
	if ((res = bsearch(&header, http_headers,
	    sizeof(http_headers) / sizeof(http_headers[0]) - 1,
	    sizeof(http_headers[0]), relay_httpheader_cmp)) != NULL)
		id = res->header_id;

	return (id);
}

a1150 8
static int
relay_httpheader_cmp(const void *a, const void *b)
{
	const struct http_header *ha = a;
	const struct http_header *hb = b;
	return (strcasecmp(ha->header_name, hb->header_name));
}

a1177 2
	u_int			 id = kv->kv_header_id;
	const char		*value;
d1179 2
a1180 1
	kv->kv_matchptr = NULL;
d1182 1
a1182 19
	if (id == HTTP_HEADER_NONE || kv->kv_type != KEY_TYPE_HEADER)
		return (0);
	else if (id < HTTP_HEADER_MAX) {
		match = desc->http_header[id];
		DPRINTF("%s: standard header %s: %p", __func__,
		    kv->kv_key, match);
		if (match != NULL)
			kv->kv_matchptr = &desc->http_header[id];
	} else {
		DPRINTF("%s: other header %s", __func__, kv->kv_key);
		TAILQ_FOREACH_REVERSE(match, &desc->http_headers,
		    kvlist, kv_entry) {
			if (strcasecmp(match->kv_key, kv->kv_key) == 0 ||
			    fnmatch(kv->kv_key, match->kv_key, FNM_CASEFOLD) !=
			    FNM_NOMATCH)
				goto done;
		}
		match = NULL;
	}
a1183 1
 done:
a1189 5
	} else if (kv->kv_value != NULL) {
		/* Test header value using shell globbing rules */
		value = match->kv_value == NULL ? "" : match->kv_value;
		if (fnmatch(kv->kv_value, value, FNM_CASEFOLD) == FNM_NOMATCH)
			return (-1);
d1228 1
a1228 1
	struct kv		*host = desc->http_header[HTTP_HEADER_HOST];
d1232 2
a1233 1
	if (cre->dir == RELAY_DIR_RESPONSE || kv->kv_type != KEY_TYPE_URL)
d1235 5
a1239 1
	else if (kv->kv_key == NULL || host == NULL || host->kv_value == NULL)
d1258 1
a1258 2
	struct kv		*kv = &rule->rule_kv[KEY_TYPE_COOKIE];
	u_int			 id = HTTP_HEADER_NONE;
d1266 1
a1266 1
		id = HTTP_HEADER_COOKIE;
d1269 1
a1269 1
		id = HTTP_HEADER_SET_COOKIE;
d1276 1
a1278 1
		kv->kv_header_id = id;
a1279 3
	} else if (id == HTTP_HEADER_NONE) {
		/* Fail if cookie doesn't exist */
		return (-1);
d1281 1
a1281 1
		match = desc->http_header[id];
a1283 1
		kv->kv_matchptr = &desc->http_header[id];
d1320 1
a1320 1
			TAILQ_INSERT_TAIL(actions, kv, kv_entry);
d1326 1
a1326 1
			TAILQ_INSERT_TAIL(actions, kv, kv_entry);
d1340 2
a1341 2
	struct kv		*kv, *match, *kp, *mp, kvcopy, matchcopy;
	int			 httpindex, addkv, ret;
a1342 1
	enum httpheader		 hdrid;
d1349 1
a1349 1
	TAILQ_FOREACH(kv, actions, kv_entry) {
d1352 1
a1352 1
		httpindex = addkv = 0;
d1383 3
a1385 6
				if (kv->kv_header_id >= HTTP_HEADER_MAX ||
				    kv->kv_header_id <= HTTP_HEADER_NONE)
					goto fail;
				if (kv_setkey(kp, "%s",
				    relay_httpheader_byid(kp->kv_header_id)) ==
				    -1)
a1388 1
				httpindex = 1;
d1417 1
a1417 1
				if (kv->kv_matchlist != NULL)
a1420 2
				if (kv->kv_matchptr)
					*kv->kv_matchptr = NULL;
d1455 1
a1455 1
		if (addkv && kv->kv_matchlist != NULL) {
d1457 1
a1457 1
			if ((match = kv_add(kv->kv_matchlist, kp->kv_key,
a1463 9
		if (httpindex && kv->kv_matchptr != NULL) {
			/* Re-index the fast lookup method */
			if ((hdrid = relay_httpheader_byname(kp->kv_key)) !=
			    HTTP_HEADER_OTHER) {
				desc->http_header[hdrid] = match;
				kv->kv_matchptr = &desc->http_header[hdrid];
			} else
				kv->kv_matchptr = NULL;
		}
d1472 1
d1488 2
a1489 1
				host = desc->http_header[HTTP_HEADER_HOST];
d1519 1
a1519 1
		kv->kv_matchlist = NULL;
d1687 1
a1687 1
    struct kvlist *matchlist)
d1691 1
a1691 1
		kv->kv_matchlist = matchlist;
@


1.21
log
@Fix another free error.

ok benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay_http.c,v 1.20 2014/07/09 16:42:05 reyk Exp $	*/
d1566 1
a1566 1
				if (kv_set(mp, "%s*removed*",
@


1.20
log
@Replace the protocol directives for HTTP with a new generic filtering
language.  The grammar is inspired by pf and allows to write versatile
last-matching filter rules in protocol sections starting with the
"pass", "block" or "match" keywords.  This work was started almost two
years ago and replaces large parts of relayd(8)'s HTTP and filtering
code.  The initial version reimplements and extends HTTP filtering,
but will be improved to support generic TCP and other protocols later.

With some testing, feedback, and help from benno@@ and andre@@.

OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay_http.c,v 1.19 2014/06/25 11:05:15 reyk Exp $	*/
d1414 3
d1606 1
a1606 4
		if (mp != NULL) {
			kv_free(mp);
			mp = NULL;
		}
@


1.19
log
@sync copyright to reality according to my last changes
@
text
@d1 1
a1 1
/*	$OpenBSD: relay_http.c,v 1.18 2014/04/20 16:18:32 reyk Exp $	*/
d49 1
a50 5
int		 relay_resolve(struct ctl_relay_event *,
		    struct protonode *, struct protonode *);
int		 relay_handle_http(struct ctl_relay_event *,
		    struct protonode *, struct protonode *,
		    struct protonode *, int);
d52 1
a52 1
		    char *, enum digest_type);
d54 4
a57 3
		    const char *, enum digest_type);
int		 relay_lookup_query(struct ctl_relay_event *);
int		 relay_lookup_cookie(struct ctl_relay_event *, const char *);
d62 99
a160 1
void		 relay_http_request_close(struct ctl_relay_event *);
d166 1
d171 2
a172 3
	struct protonode	*pn, pk, *proot, *pnv = NULL, pkv;
	char			*line;
	int			 header = 0, ret, pass = 0;
d175 2
d181 2
a182 1
	DPRINTF("%s: size %lu, to read %lld", __func__, size, cre->toread);
a189 2
	pk.type = NODE_TYPE_HEADER;

d200 1
a200 1
		pk.key = line;
d206 8
a213 5
		if (++cre->line == 1) {
			pk.value = strchr(pk.key, ' ');
		} else
			pk.value = strchr(pk.key, ':');
		if (pk.value == NULL || strlen(pk.value) < 3) {
d220 2
a221 4
			DPRINTF("%s: request '%s'", __func__, line);
			/* Append line to the output buffer */
			if (relay_bufferevent_print(cre->dst, line) == -1 ||
			    relay_bufferevent_print(cre->dst, "\r\n") == -1) {
d225 1
d229 3
a231 4
		if (*pk.value == ':') {
			*pk.value++ = '\0';
			pk.value += strspn(pk.value, " \t\r\n");
			header = 1;
d233 1
a233 2
			*pk.value++ = '\0';
			header = 0;
d236 2
a237 1
		DPRINTF("%s: header '%s: %s'", __func__, pk.key, pk.value);
d242 2
a243 23
		if (cre->line == 1) {
			if (cre->dir == RELAY_DIR_RESPONSE) {
				cre->method = HTTP_METHOD_RESPONSE;
				goto lookup;
			} else if (strcmp("HEAD", pk.key) == 0)
				cre->method = HTTP_METHOD_HEAD;
			else if (strcmp("POST", pk.key) == 0)
				cre->method = HTTP_METHOD_POST;
			else if (strcmp("PUT", pk.key) == 0)
				cre->method = HTTP_METHOD_PUT;
			else if (strcmp("DELETE", pk.key) == 0)
				cre->method = HTTP_METHOD_DELETE;
			else if (strcmp("OPTIONS", pk.key) == 0)
				cre->method = HTTP_METHOD_OPTIONS;
			else if (strcmp("TRACE", pk.key) == 0)
				cre->method = HTTP_METHOD_TRACE;
			else if (strcmp("CONNECT", pk.key) == 0)
				cre->method = HTTP_METHOD_CONNECT;
			else {
				/* Use GET method as the default */
				cre->method = HTTP_METHOD_GET;
			}

d245 1
a245 1
			 * Decode the path and query
d247 12
a258 2
			cre->path = strdup(pk.value);
			if (cre->path == NULL) {
d262 3
a264 11
			cre->version = strchr(cre->path, ' ');
			if (cre->version != NULL)
				*cre->version++ = '\0';
			cre->args = strchr(cre->path, '?');
			if (cre->args != NULL)
				*cre->args++ = '\0';
#ifdef DEBUG
			char	 buf[BUFSIZ];
			if (snprintf(buf, sizeof(buf), " \"%s\"",
			    cre->path) == -1 ||
			    evbuffer_add(con->se_log, buf, strlen(buf)) == -1) {
d268 22
a289 1
#endif
d292 2
a293 1
			 * Lookup protocol handlers in the URL path
d295 23
a317 2
			if ((proto->flags & F_LOOKUP_PATH) == 0)
				goto lookup;
a318 25
			pkv.key = cre->path;
			pkv.type = NODE_TYPE_PATH;
			pkv.value = cre->args == NULL ? "" : cre->args;

			DPRINTF("%s: lookup path '%s: %s'",
			    __func__, pkv.key, pkv.value);

			if ((proot = RB_FIND(proto_tree,
			    cre->tree, &pkv)) == NULL)
				goto lookup;

			PROTONODE_FOREACH(pnv, proot, entry) {
				ret = relay_handle_http(cre, proot,
				    pnv, &pkv, 0);
				if (ret == PN_FAIL)
					goto abort;
			}
		} else if ((cre->method == HTTP_METHOD_DELETE ||
		    cre->method == HTTP_METHOD_GET ||
		    cre->method == HTTP_METHOD_HEAD ||
		    cre->method == HTTP_METHOD_OPTIONS ||
		    cre->method == HTTP_METHOD_POST ||
		    cre->method == HTTP_METHOD_PUT ||
		    cre->method == HTTP_METHOD_RESPONSE) &&
		    strcasecmp("Content-Length", pk.key) == 0) {
d326 1
a326 1
			cre->toread = strtonum(pk.value, 0, LLONG_MAX,
a331 8
		} else if ((cre->method == HTTP_METHOD_TRACE) &&
		    strcasecmp("Content-Length", pk.key) == 0) {
			/*
			 * This method should not have a body and thus no
			 * Content-Length header.
			 */
			relay_abort_http(con, 400, "malformed", 0);
			goto abort;
d334 10
a343 12
		if (strcasecmp("Transfer-Encoding", pk.key) == 0 &&
		    strcasecmp("chunked", pk.value) == 0)
			cre->chunked = 1;

		/* Match the HTTP header */
		if ((pn = RB_FIND(proto_tree, cre->tree, &pk)) == NULL)
			goto next;

		if (cre->dir == RELAY_DIR_RESPONSE)
			goto handle;

		if (pn->flags & PNFLAG_LOOKUP_URL) {
d345 2
a346 2
			 * Lookup the URL of type example.com/path?args.
			 * Either as a plain string or SHA1/MD5 digest.
d348 11
a358 30
			if ((pn->flags & PNFLAG_LOOKUP_DIGEST(0)) &&
			    relay_lookup_url(cre, pk.value,
			    DIGEST_NONE) == PN_FAIL)
				goto abort;
			if ((pn->flags & PNFLAG_LOOKUP_DIGEST(DIGEST_SHA1)) &&
			    relay_lookup_url(cre, pk.value,
			    DIGEST_SHA1) == PN_FAIL)
				goto abort;
			if ((pn->flags & PNFLAG_LOOKUP_DIGEST(DIGEST_MD5)) &&
			    relay_lookup_url(cre, pk.value,
			    DIGEST_MD5) == PN_FAIL)
				goto abort;
		} else if (pn->flags & PNFLAG_LOOKUP_QUERY) {
			/* Lookup the HTTP query arguments */
			if (relay_lookup_query(cre) == PN_FAIL)
				goto abort;
		} else if (pn->flags & PNFLAG_LOOKUP_COOKIE) {
			/* Lookup the HTTP cookie */
			if (relay_lookup_cookie(cre, pk.value) == PN_FAIL)
				goto abort;
		}

 handle:
		pass = 0;
		PROTONODE_FOREACH(pnv, pn, entry) {
			ret = relay_handle_http(cre, pn, pnv, &pk, header);
			if (ret == PN_PASS)
				pass = 1;
			else if (ret == PN_FAIL)
				goto abort;
a360 11
		if (pass) {
 next:
			if (relay_bufferevent_print(cre->dst, pk.key) == -1 ||
			    relay_bufferevent_print(cre->dst,
			    header ? ": " : " ") == -1 ||
			    relay_bufferevent_print(cre->dst, pk.value) == -1 ||
			    relay_bufferevent_print(cre->dst, "\r\n") == -1) {
				free(line);
				goto fail;
			}
		}
d364 3
a366 4
		RB_FOREACH(proot, proto_tree, cre->tree) {
			PROTONODE_FOREACH(pn, proot, entry)
				if (relay_resolve(cre, proot, pn) != 0)
					return;
d369 6
a374 3
		switch (cre->method) {
		case HTTP_METHOD_NONE:
			relay_abort_http(con, 406, "no method", 0);
d376 3
d409 1
a409 1
		if (cre->chunked) {
d415 10
a424 2
		/* Write empty newline and switch to relay mode */
		if (relay_bufferevent_print(cre->dst, "\r\n") == -1)
d427 1
a427 2
		relay_http_request_close(cre);

d430 1
a430 1
		    proto->lateconnect && cre->dst->bev == NULL) {
d468 2
a469 2
	DPRINTF("%s: dir %d, size %lu, to read %lld",
	    __func__, cre->dir, size, cre->toread);
d521 2
a522 2
	DPRINTF("%s: dir %d, size %lu, to read %lld",
	    __func__, cre->dir, size, cre->toread);
a573 1
		/* Last chunk is 0 bytes followed by optional trailer */
d626 1
a626 1
relay_http_request_close(struct ctl_relay_event *cre)
d628 1
a628 7
	if (cre->path != NULL) {
		free(cre->path);
		cre->path = NULL;
	}

	cre->args = NULL;
	cre->version = NULL;
d630 1
d636 2
a637 1

a638 1
	cre->method = 0;
a639 1
	cre->chunked = 0;
d644 1
a644 1
    char *query, enum digest_type type)
a646 1
	struct protonode	*proot, *pnv, pkv;
d648 2
a649 1
	int			 ret = PN_FAIL;
d656 1
a656 1
		return (PN_FAIL);
d659 1
a659 3
	DPRINTF("%s: %s", __func__, val);

	switch (type) {
d662 2
a663 1
		if ((md = digeststr(type, val, strlen(val), NULL)) == NULL) {
d668 1
a668 1
		pkv.key = md;
d671 1
a671 1
		pkv.key = val;
a673 2
	pkv.type = NODE_TYPE_URL;
	pkv.value = "";
d675 2
a676 2
	if ((proot = RB_FIND(proto_tree, cre->tree, &pkv)) == NULL)
		goto done;
d678 3
a680 4
	PROTONODE_FOREACH(pnv, proot, entry) {
		ret = relay_handle_http(cre, proot, pnv, &pkv, 0);
		if (ret == PN_FAIL)
			goto fail;
d683 1
a683 2
 done:
	ret = PN_PASS;
d692 1
a692 2
relay_lookup_url(struct ctl_relay_event *cre, const char *str,
    enum digest_type type)
d694 6
a699 5
	struct rsession	*con = cre->con;
	int		 i, j, dots;
	char		*hi[RELAY_MAXLOOKUPLEVELS], *p, *pp, *c, ch;
	char		 ph[MAXHOSTNAMELEN];
	int		 ret;
d701 2
a702 2
	if (cre->path == NULL)
		return (PN_PASS);
d710 3
a712 2
	DPRINTF("%s: host: '%s', path: '%s', query: '%s'", __func__,
	    str, cre->path, cre->args == NULL ? "" : cre->args);
d714 1
a714 1
	if (canonicalize_host(str, ph, sizeof(ph)) == NULL) {
d716 1
a716 1
		return (PN_FAIL);
d730 1
a730 1
	if ((pp = strdup(cre->path)) == NULL) {
d732 1
a732 1
		return (PN_FAIL);
d739 1
a739 1
		if (cre->args != NULL)
d741 1
a741 1
			    pp, cre->args, type)) != PN_PASS)
d746 1
a746 1
		    pp, NULL, type)) != PN_PASS)
d752 1
a752 1
			if (j > (RELAY_MAXLOOKUPLEVELS - 2) || ++p == '\0')
d758 1
a758 1
			    pp, NULL, type)) != PN_PASS)
d764 1
a764 1
	ret = PN_PASS;
d771 2
a772 1
relay_lookup_query(struct ctl_relay_event *cre)
d775 1
a775 2
	struct protonode	*proot, *pnv, pkv;
	char			*val, *ptr;
d778 3
a780 5
	if (cre->path == NULL || cre->args == NULL || strlen(cre->args) < 2)
		return (PN_PASS);
	if ((val = strdup(cre->args)) == NULL) {
		relay_abort_http(con, 500, "failed to allocate query", 0);
		return (PN_FAIL);
d783 5
a787 5
	ptr = val;
	while (ptr != NULL && strlen(ptr)) {
		pkv.key = ptr;
		pkv.type = NODE_TYPE_QUERY;
		if ((ptr = strchr(ptr, '&')) != NULL)
d789 5
a793 3
		if ((pkv.value =
		    strchr(pkv.key, '=')) == NULL ||
		    strlen(pkv.value) < 1)
a794 1
		*pkv.value++ = '\0';
d796 3
a798 1
		if ((proot = RB_FIND(proto_tree, cre->tree, &pkv)) == NULL)
d800 17
a816 5
		PROTONODE_FOREACH(pnv, proot, entry) {
			ret = relay_handle_http(cre, proot,
			    pnv, &pkv, 0);
			if (ret == PN_FAIL)
				goto done;
d820 2
a821 1
	ret = PN_PASS;
d828 1
a828 1
relay_lookup_cookie(struct ctl_relay_event *cre, const char *str)
d830 4
a833 4
	struct rsession		*con = cre->con;
	struct protonode	*proot, *pnv, pkv;
	char			*val, *ptr;
	int			 ret;
d835 5
a839 3
	if ((val = strdup(str)) == NULL) {
		relay_abort_http(con, 500, "failed to allocate cookie", 0);
		return (PN_FAIL);
d842 4
a845 2
	for (ptr = val; ptr != NULL && strlen(ptr);) {
		if (*ptr == ' ')
d847 2
a848 9
		pkv.key = ptr;
		pkv.type = NODE_TYPE_COOKIE;
		if ((ptr = strchr(ptr, ';')) != NULL)
			*ptr++ = '\0';
		/*
		 * XXX We do not handle attributes
		 * ($Path, $Domain, or $Port)
		 */
		if (*pkv.key == '$')
d850 1
d852 6
a857 16
		if ((pkv.value =
		    strchr(pkv.key, '=')) == NULL ||
		    strlen(pkv.value) < 1)
			continue;
		*pkv.value++ = '\0';
		if (*pkv.value == '"')
			*pkv.value++ = '\0';
		if (pkv.value[strlen(pkv.value) - 1] == '"')
			pkv.value[strlen(pkv.value) - 1] = '\0';
		if ((proot = RB_FIND(proto_tree, cre->tree, &pkv)) == NULL)
			continue;
		PROTONODE_FOREACH(pnv, proot, entry) {
			ret = relay_handle_http(cre, proot, pnv, &pkv, 0);
			if (ret == PN_FAIL)
				goto done;
		}
d860 11
a870 1
	ret = PN_PASS;
d876 1
d890 3
a916 2
	if (labelid != 0)
		label = pn_id2name(labelid);
d963 16
d980 2
a981 1
relay_expand_http(struct ctl_relay_event *cre, char *val, char *buf, size_t len)
d1038 282
a1319 2
relay_resolve(struct ctl_relay_event *cre,
    struct protonode *proot, struct protonode *pn)
d1321 4
a1324 3
	struct rsession		*con = cre->con;
	char			 buf[IBUF_READ_SIZE], *ptr;
	int			 id;
d1326 1
a1326 1
	if (pn->mark && (pn->mark != con->se_mark))
d1329 3
a1331 7
	switch (pn->action) {
	case NODE_ACTION_FILTER:
		id = cre->nodes[proot->id];
		if (SIMPLEQ_NEXT(pn, entry) == NULL)
			cre->nodes[proot->id] = 0;
		if (id <= 1)
			return (0);
d1333 2
a1334 6
	case NODE_ACTION_EXPECT:
		id = cre->nodes[proot->id];
		if (SIMPLEQ_NEXT(pn, entry) == NULL)
			cre->nodes[proot->id] = 0;
		if (id > 1)
			return (0);
d1337 2
a1338 4
		if (cre->nodes[pn->id]) {
			cre->nodes[pn->id] = 0;
			return (0);
		}
d1341 15
a1355 14
	switch (pn->action) {
	case NODE_ACTION_APPEND:
	case NODE_ACTION_CHANGE:
		ptr = pn->value;
		if ((pn->flags & PNFLAG_MACRO) &&
		    (ptr = relay_expand_http(cre, pn->value,
		    buf, sizeof(buf))) == NULL)
			break;
		if (relay_bufferevent_print(cre->dst, pn->key) == -1 ||
		    relay_bufferevent_print(cre->dst, ": ") == -1 ||
		    relay_bufferevent_print(cre->dst, ptr) == -1 ||
		    relay_bufferevent_print(cre->dst, "\r\n") == -1) {
			relay_abort_http(con, 500,
			    "failed to modify header", 0);
d1357 39
a1396 12
		DPRINTF("%s: add '%s: %s'", __func__, pn->key, ptr);
		break;
	case NODE_ACTION_EXPECT:
		DPRINTF("%s: missing '%s: %s'", __func__, pn->key, pn->value);
		relay_abort_http(con, 403, "incomplete request", pn->label);
		return (-1);
	case NODE_ACTION_FILTER:
		DPRINTF("%s: filtered '%s: %s'", __func__, pn->key, pn->value);
		relay_abort_http(con, 403, "rejecting request", pn->label);
		return (-1);
	default:
		break;
d1398 1
d1403 1
a1403 2
relay_handle_http(struct ctl_relay_event *cre, struct protonode *proot,
    struct protonode *pn, struct protonode *pk, int header)
d1406 5
d1412 1
a1412 2
	int			 ret = PN_DROP, mark = 0;
	struct protonode	*next;
d1414 6
a1419 14
	/* Check if this action depends on a marked session */
	if (pn->mark != 0)
		mark = pn->mark == con->se_mark ? 1 : -1;

	switch (pn->action) {
	case NODE_ACTION_EXPECT:
	case NODE_ACTION_FILTER:
	case NODE_ACTION_MARK:
		break;
	default:
		if (mark == -1)
			return (PN_PASS);
		break;
	}
a1420 28
	switch (pn->action) {
	case NODE_ACTION_APPEND:
		if (!header)
			return (PN_PASS);
		ptr = pn->value;
		if ((pn->flags & PNFLAG_MACRO) &&
		    (ptr = relay_expand_http(cre, pn->value,
		    buf, sizeof(buf))) == NULL)
			break;
		if (relay_bufferevent_print(cre->dst, pn->key) == -1 ||
		    relay_bufferevent_print(cre->dst, ": ") == -1 ||
		    relay_bufferevent_print(cre->dst, pk->value) == -1 ||
		    relay_bufferevent_print(cre->dst, ", ") == -1 ||
		    relay_bufferevent_print(cre->dst, ptr) == -1 ||
		    relay_bufferevent_print(cre->dst, "\r\n") == -1)
			goto fail;
		cre->nodes[pn->id] = 1;
		DPRINTF("%s: append '%s: %s, %s'", __func__,
		    pk->key, pk->value, ptr);
		break;
	case NODE_ACTION_CHANGE:
	case NODE_ACTION_REMOVE:
		if (!header)
			return (PN_PASS);
		DPRINTF("%s: change/remove '%s: %s'", __func__,
		    pk->key, pk->value);
		break;
	case NODE_ACTION_EXPECT:
d1422 2
a1423 2
		 * A client may specify the header line for multiple times
		 * trying to circumvent the filter.
d1425 182
a1606 53
		if (cre->nodes[proot->id] > 1) {
			relay_abort_http(con, 400, "repeated header line", 0);
			return (PN_FAIL);
		}
		/* FALLTHROUGH */
	case NODE_ACTION_FILTER:
		DPRINTF("%s: %s '%s: %s'", __func__,
		    (pn->action == NODE_ACTION_EXPECT) ? "expect" : "filter",
		    pn->key, pn->value);

		/* Do not drop the entity */
		ret = PN_PASS;

		if (mark != -1 &&
		    fnmatch(pn->value, pk->value, FNM_CASEFOLD) == 0) {
			cre->nodes[proot->id] = 1;

			/* Fail instantly */
			if (pn->action == NODE_ACTION_FILTER) {
				(void)relay_lognode(con, pn, pk,
				    buf, sizeof(buf));
				relay_abort_http(con, 403,
				    "rejecting request", pn->label);
				return (PN_FAIL);
			}
		}
		next = SIMPLEQ_NEXT(pn, entry);
		if (next == NULL || next->action != pn->action)
			cre->nodes[proot->id]++;
		break;
	case NODE_ACTION_HASH:
		DPRINTF("%s: hash '%s: %s'", __func__,
		    pn->key, pk->value);
		if (!con->se_hashkeyset)
			con->se_hashkey = HASHINIT;
		con->se_hashkey = hash32_str(pk->value, con->se_hashkey);
		con->se_hashkeyset = 1;
		log_debug("%s: hash 0x%04x", __func__, con->se_hashkey);
		ret = PN_PASS;
		break;
	case NODE_ACTION_LOG:
		log_debug("%s: log '%s: %s'", __func__, pn->key, pk->value);
		ret = PN_PASS;
		break;
	case NODE_ACTION_MARK:
		DPRINTF("%s: mark '%s: %s'", __func__,
		    pn->key, pk->value);
		if (fnmatch(pn->value, pk->value, FNM_CASEFOLD) == 0)
			con->se_mark = pn->mark;
		ret = PN_PASS;
		break;
	case NODE_ACTION_NONE:
		return (PN_PASS);
d1608 5
a1612 2
	if (mark != -1 && relay_lognode(con, pn, pk, buf, sizeof(buf)) == -1)
		goto fail;
d1615 162
a1776 3
 fail:
	relay_abort_http(con, 500, strerror(errno), 0);
	return (PN_FAIL);
@


1.18
log
@Check for strlcpy overflow when expanding the HTTP input value.
@
text
@d1 1
a1 1
/*	$OpenBSD: relay_http.c,v 1.17 2014/04/15 22:35:11 andre Exp $	*/
d4 1
a4 1
 * Copyright (c) 2006 - 2012 Reyk Floeter <reyk@@openbsd.org>
@


1.17
log
@Print hashkey to debug output, this helps hash-action use cases to be tested.
Use log_debug() instead of log_info().

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay_http.c,v 1.16 2013/09/04 22:21:32 bluhm Exp $	*/
d899 2
a900 1
	(void)strlcpy(buf, val, len);
@


1.16
log
@Handling of HTTP requests with a body like POST were broken in
relayd.  Instead of checking for the direction RELAY_DIR_RESPONSE,
set toread to 0 if we don't expect a body.
OK reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay_http.c,v 1.15 2013/06/02 18:02:45 reyk Exp $	*/
d1106 1
d1110 1
a1110 1
		log_info("%s: log '%s: %s'", __func__, pn->key, pk->value);
@


1.15
log
@With HTTP keepalive, relayd only filtered the first request and
switched to pass-through mode for subsequent requests from the client.
Make sure to stay in HTTP header mode.

ok benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay_http.c,v 1.14 2013/05/30 19:45:20 reyk Exp $	*/
d327 2
d336 2
a337 3
			/* Single-pass HTTP response */
			if (cre->dir == RELAY_DIR_RESPONSE &&
			    cre->toread < 0) {
@


1.14
log
@Safari doesn't like HTTP/1.x in the generated error messages (return error),
so change it to HTTP/1.0.  This also makes it RFC-compliant which only allows
digits in the version number.

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay_http.c,v 1.13 2013/05/07 16:19:58 reyk Exp $	*/
d335 2
a336 1
			if (cre->toread < 0) {
a339 1

@


1.13
log
@- Add a simple check to prevent that the client-provided hex HTTP chunk size
turns our signed input variable into a negative number.  This prevents that
a chunked HTTP connection could break its own state machine and turn into
a stalled state.  The bug doesn't harm other connections or relayd itself.
- Use a 64bit variable to allow theoretical large chunks.
- Fix a comment.

ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay_http.c,v 1.12 2013/04/20 17:41:33 deraadt Exp $	*/
d852 1
a852 1
	    "HTTP/1.x %03d %s\r\n"
@


1.12
log
@print large time_t nicely; ok benno
@
text
@d1 1
a1 1
/*	$OpenBSD: relay_http.c,v 1.11 2013/03/10 23:32:53 reyk Exp $	*/
d446 1
a446 1
	long			 lval;
d488 5
a492 2
		/* Read prepended chunk size in hex, ingore the trailer */
		if (sscanf(line, "%lx", &lval) != 1) {
d506 1
a506 1
		if ((cre->toread = lval) == 0) {
@


1.11
log
@This diff changes relayd to use the monotonic clock instead of
gettimeofday().  It was also bugging me for some time to have all
these checks of gettimeofday()'s return value: it should not fail.  So
this diff introduces a void getmonotime(struct timeval *tv) that calls
clock_gettime(CLOCK_MONOTONIC, &ts) and converts the output to a
struct timeval that can be used with the existing code and the
timeval-specific timer functions (timerclear, timersub, ...).  It does
not return a status but calls fatal() on error-that-should-not-happen.

ok sthen@@ chris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay_http.c,v 1.10 2013/03/09 14:43:06 bluhm Exp $	*/
d935 2
a936 2
		snprintf(ibuf, sizeof(ibuf), "%lu",
		    rlay->rl_conf.timeout.tv_sec);
@


1.10
log
@Enable TCP socket splicing for HTTP persistent connection and chunked
transfer encoding.  This speeds up relayd for more protocol modes
by zero-copy TCP forwarding.
OK reyk@@ benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay_http.c,v 1.9 2013/02/15 12:15:12 bluhm Exp $	*/
d81 2
a82 2
	if (gettimeofday(&con->se_tv_last, NULL) == -1)
		goto fail;
d396 2
a397 2
	if (gettimeofday(&con->se_tv_last, NULL) == -1)
		goto fail;
d449 2
a450 2
	if (gettimeofday(&con->se_tv_last, NULL) == -1)
		goto fail;
@


1.9
log
@Fix the toread check in the lateconnect case.  This allows
Content-Length: 0 in HTTP GET request when a request filter is used.
This was broken by my previous commit.
OK reyk@@ benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay_http.c,v 1.8 2013/02/05 21:36:33 bluhm Exp $	*/
d378 2
d403 2
d456 2
@


1.9.2.1
log
@MFC revision 1.15, requested by reyk@@:

-/----
date: 2013/06/02 18:02:45;  author: reyk;  state: Exp;  lines: +3 -3
With HTTP keepalive, relayd only filtered the first request and
switched to pass-through mode for subsequent requests from the client.
Make sure to stay in HTTP header mode.

ok benno@@
-/----
@
text
@d1 1
a1 1
/*	$OpenBSD: relay_http.c,v 1.9 2013/02/15 12:15:12 bluhm Exp $	*/
d335 1
a335 2
			if (cre->dir == RELAY_DIR_RESPONSE &&
			    cre->toread < 0) {
d339 1
@


1.8
log
@Rework http content and chunk handling in relayd.  Use special
toread values to track the current http header or chunk state.  This
allows to handle an optional chunk trailer properly.  Tracking the
http state is also a prerequisite for splicing persistent http
connections.
OK and test reyk@@ benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay_http.c,v 1.7 2013/01/22 08:26:34 reyk Exp $	*/
d360 1
a360 1
		if (cre->dir == RELAY_DIR_REQUEST && cre->toread < 0 &&
@


1.7
log
@Only send a single CRLF between chunks.  A second CRLF seemed to be
optional, and it worked fine with Firefox, but it didn't work with
some browsers/clients like Chrome or CURL that implement the
specification strictly. See RFC 2616, Section 3.6.1, for more
information about Chunked Transfer Encoding.

ok bluhm@@ benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay_http.c,v 1.6 2013/01/17 20:34:18 bluhm Exp $	*/
d88 1
a88 1
		cre->toread = 0;
d320 1
d331 1
a331 1
			if (cre->toread) {
d333 5
a337 1
				break;
a339 2
			/* Single-pass HTTP response */
			bev->readcb = relay_read;
d343 1
d349 1
a349 1
			cre->toread = 0;
d360 1
a360 1
		if (cre->dir == RELAY_DIR_REQUEST && !cre->toread &&
d397 2
a398 2
	DPRINTF("%s: size %lu, to read %lld", __func__,
	    size, cre->toread);
d401 19
a419 3
	if (relay_bufferevent_write_buffer(cre->dst, src) == -1)
		goto fail;
	if ((off_t)size >= cre->toread)
d421 1
a421 3
	cre->toread -= size;
	DPRINTF("%s: done, size %lu, to read %lld", __func__,
	    size, cre->toread);
d448 2
a449 2
	DPRINTF("%s: size %lu, to read %lld", __func__,
	    size, cre->toread);
d453 18
a470 1
	if (!cre->toread) {
d477 1
a477 1
		if (!strlen(line)) {
d496 1
a496 1
		/* Last chunk is 0 bytes followed by an empty newline */
d499 13
a511 6

			line = evbuffer_readline(src);
			if (line == NULL) {
				relay_close(con, "invalid last chunk");
				return;
			}
d513 3
a515 3
			if (relay_bufferevent_print(cre->dst, "\r\n") == -1)
				goto fail;

d517 1
d520 8
a527 5
	} else {
		/* Read chunk data */
		if ((off_t)size > cre->toread)
			size = cre->toread;
		if (relay_bufferevent_write_chunk(cre->dst, src, size) == -1)
d529 2
a530 12
		cre->toread -= size;
		DPRINTF("%s: done, size %lu, to read %lld", __func__,
		    size, cre->toread);

		if (cre->toread == 0) {
			/* Chunk is terminated by an empty (empty) newline */
			line = evbuffer_readline(src);
			if (line != NULL)
				free(line);
			if (relay_bufferevent_print(cre->dst, "\r\n") == -1)
				goto fail;
		}
@


1.6
log
@Remove unnecessary pointer casts.  No binary diff.
OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay_http.c,v 1.5 2012/11/27 05:00:28 guenther Exp $	*/
d492 1
a492 1
			if (relay_bufferevent_print(cre->dst, "\r\n\r\n") == -1)
@


1.5
log
@Add format attributes to the proper functions and then fix the warnings
that gcc then reports when compiling with -DDEBUG=2

ok reyk@@ benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay_http.c,v 1.4 2012/11/21 22:14:24 benno Exp $	*/
d70 1
a70 1
	struct ctl_relay_event	*cre = (struct ctl_relay_event *)arg;
d72 1
a72 1
	struct relay		*rlay = (struct relay *)con->se_relay;
d385 1
a385 1
	struct ctl_relay_event	*cre = (struct ctl_relay_event *)arg;
d420 1
a420 1
	struct ctl_relay_event	*cre = (struct ctl_relay_event *)arg;
d765 1
a765 1
	struct relay		*rlay = (struct relay *)con->se_relay;
d850 1
a850 1
	struct relay	*rlay = (struct relay *)con->se_relay;
@


1.4
log
@strtonum() can only handle a maximum of LLONG_MAX
fixes bug reported by Bogdan Andu, thanks
ok reyk@@ deraadt@@ sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay_http.c,v 1.3 2012/10/10 14:27:46 reyk Exp $	*/
d84 1
a84 1
	DPRINTF("%s: size %lu, to read %ll", __func__, size, cre->toread);
d393 1
a393 1
	DPRINTF("%s: size %lu, to read %ll", __func__,
d402 1
a402 1
	DPRINTF("%s: done, size %lu, to read %ll", __func__,
d430 1
a430 1
	DPRINTF("%s: size %lu, to read %ll", __func__,
d484 1
a484 1
		DPRINTF("%s: done, size %lu, to read %ll", __func__,
@


1.3
log
@Fix the hash http filter action to initialize the hash key correctly after
the multiple relay tables commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: relay_http.c,v 1.2 2012/10/04 20:53:30 reyk Exp $	*/
d84 1
a84 1
	DPRINTF("%s: size %lu, to read %llu", __func__, size, cre->toread);
d230 1
a230 1
			cre->toread = strtonum(pk.value, 0, ULLONG_MAX,
d393 1
a393 1
	DPRINTF("%s: size %lu, to read %llu", __func__,
d402 1
a402 1
	DPRINTF("%s: done, size %lu, to read %llu", __func__,
d430 1
a430 1
	DPRINTF("%s: size %lu, to read %llu", __func__,
d484 1
a484 1
		DPRINTF("%s: done, size %lu, to read %llu", __func__,
@


1.2
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: relay_http.c,v 1.1 2012/09/20 12:30:20 reyk Exp $	*/
d1056 2
d1059 1
@


1.1
log
@Move the HTTP code into an extra file to make future changes easier to
follow.  No functional changes, only one function got renamed.

ok benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d230 2
a231 1
			cre->toread = strtonum(pk.value, 0, ULLONG_MAX, &errstr);
@

