head	1.34;
access;
symbols
	OPENBSD_6_2:1.34.0.2
	OPENBSD_6_2_BASE:1.34
	OPENBSD_6_1:1.31.0.4
	OPENBSD_6_1_BASE:1.31
	OPENBSD_6_0:1.30.0.4
	OPENBSD_6_0_BASE:1.30
	OPENBSD_5_9:1.30.0.2
	OPENBSD_5_9_BASE:1.30
	OPENBSD_5_8:1.29.0.4
	OPENBSD_5_8_BASE:1.29
	OPENBSD_5_7:1.28.0.2
	OPENBSD_5_7_BASE:1.28
	OPENBSD_5_6:1.25.0.4
	OPENBSD_5_6_BASE:1.25
	OPENBSD_5_5:1.19.0.6
	OPENBSD_5_5_BASE:1.19
	OPENBSD_5_4:1.19.0.2
	OPENBSD_5_4_BASE:1.19
	OPENBSD_5_3:1.17.0.2
	OPENBSD_5_3_BASE:1.17
	OPENBSD_5_2:1.16.0.10
	OPENBSD_5_2_BASE:1.16
	OPENBSD_5_1_BASE:1.16
	OPENBSD_5_1:1.16.0.8
	OPENBSD_5_0:1.16.0.6
	OPENBSD_5_0_BASE:1.16
	OPENBSD_4_9:1.16.0.4
	OPENBSD_4_9_BASE:1.16
	OPENBSD_4_8:1.16.0.2
	OPENBSD_4_8_BASE:1.16
	OPENBSD_4_7:1.15.0.2
	OPENBSD_4_7_BASE:1.15
	OPENBSD_4_6:1.15.0.4
	OPENBSD_4_6_BASE:1.15
	OPENBSD_4_5:1.14.0.2
	OPENBSD_4_5_BASE:1.14
	OPENBSD_4_4:1.13.0.4
	OPENBSD_4_4_BASE:1.13
	OPENBSD_4_3:1.13.0.2
	OPENBSD_4_3_BASE:1.13;
locks; strict;
comment	@ * @;


1.34
date	2017.07.28.13.58.52;	author bluhm;	state Exp;
branches;
next	1.33;
commitid	lLQ0xWUKem2peo94;

1.33
date	2017.05.28.10.39.15;	author benno;	state Exp;
branches;
next	1.32;
commitid	IW4LnWyG3CPq6c3r;

1.32
date	2017.05.27.08.33.25;	author claudio;	state Exp;
branches;
next	1.31;
commitid	mLnU8nnW1ZLoAWRU;

1.31
date	2017.01.09.14.49.21;	author reyk;	state Exp;
branches;
next	1.30;
commitid	eA8b246voAapPTkX;

1.30
date	2015.12.30.12.08.34;	author benno;	state Exp;
branches;
next	1.29;
commitid	v04SUqtFvii3BsSp;

1.29
date	2015.03.24.08.44.04;	author giovanni;	state Exp;
branches;
next	1.28;
commitid	lvI7elmr1DNXHruW;

1.28
date	2015.01.22.17.42.09;	author reyk;	state Exp;
branches
	1.28.2.1;
next	1.27;
commitid	puppem00jmzmdm4f;

1.27
date	2015.01.16.15.06.41;	author deraadt;	state Exp;
branches;
next	1.26;
commitid	tOv8XK6tLyhEfayc;

1.26
date	2014.12.12.10.05.09;	author reyk;	state Exp;
branches;
next	1.25;
commitid	J8g0vRzthwLCqf68;

1.25
date	2014.07.10.12.50.05;	author jsg;	state Exp;
branches;
next	1.24;
commitid	ER0OliUrARJBWane;

1.24
date	2014.05.20.17.33.36;	author reyk;	state Exp;
branches;
next	1.23;

1.23
date	2014.05.06.11.03.02;	author reyk;	state Exp;
branches;
next	1.22;

1.22
date	2014.04.22.08.04.23;	author reyk;	state Exp;
branches;
next	1.21;

1.21
date	2014.04.21.17.22.06;	author reyk;	state Exp;
branches;
next	1.20;

1.20
date	2014.04.18.13.55.26;	author reyk;	state Exp;
branches;
next	1.19;

1.19
date	2013.05.31.20.23.37;	author benno;	state Exp;
branches;
next	1.18;

1.18
date	2013.05.30.20.17.12;	author reyk;	state Exp;
branches;
next	1.17;

1.17
date	2012.12.18.15.34.07;	author reyk;	state Exp;
branches;
next	1.16;

1.16
date	2010.05.26.13.56.08;	author nicm;	state Exp;
branches;
next	1.15;

1.15
date	2009.06.04.13.46.07;	author reyk;	state Exp;
branches;
next	1.14;

1.14
date	2008.12.05.16.37.56;	author reyk;	state Exp;
branches;
next	1.13;

1.13
date	2007.12.07.17.17.01;	author reyk;	state Exp;
branches;
next	1.12;

1.12
date	2007.12.05.23.02.05;	author reyk;	state Exp;
branches;
next	1.11;

1.11
date	2007.11.24.17.07.28;	author reyk;	state Exp;
branches;
next	1.10;

1.10
date	2007.09.28.13.29.56;	author pyr;	state Exp;
branches;
next	1.9;

1.9
date	2007.05.27.20.53.10;	author pyr;	state Exp;
branches;
next	1.8;

1.8
date	2007.02.22.05.58.06;	author reyk;	state Exp;
branches;
next	1.7;

1.7
date	2007.02.22.03.32.40;	author reyk;	state Exp;
branches;
next	1.6;

1.6
date	2007.02.08.13.32.24;	author reyk;	state Exp;
branches;
next	1.5;

1.5
date	2007.02.07.14.39.45;	author reyk;	state Exp;
branches;
next	1.4;

1.4
date	2007.02.06.10.27.33;	author reyk;	state Exp;
branches;
next	1.3;

1.3
date	2007.02.06.10.06.55;	author reyk;	state Exp;
branches;
next	1.2;

1.2
date	2007.01.30.11.48.06;	author pyr;	state Exp;
branches;
next	1.1;

1.1
date	2007.01.29.14.23.31;	author pyr;	state Exp;
branches;
next	;

1.28.2.1
date	2015.09.20.11.20.16;	author benno;	state Exp;
branches;
next	;
commitid	C9WQyjgbN7h0ioOp;


desc
@@


1.34
log
@Always calculate the hash value of the x509 cert in ssl_load_pkey().
Check whether TLS server object is available before using it.  With
these fixes the ssl inspect regress test just fails and does not
crash relayd.
OK claudio@@
@
text
@/*	$OpenBSD: ssl.c,v 1.33 2017/05/28 10:39:15 benno Exp $	*/

/*
 * Copyright (c) 2007 - 2014 Reyk Floeter <reyk@@openbsd.org>
 * Copyright (c) 2006 Pierre-Yves Ritschard <pyr@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/queue.h>
#include <sys/uio.h>

#include <unistd.h>
#include <string.h>
#include <imsg.h>

#include <openssl/ssl.h>
#include <openssl/err.h>
#include <openssl/engine.h>

#include "relayd.h"
#include "boguskeys.h"

int	ssl_password_cb(char *, int, int, void *);

void
ssl_init(struct relayd *env)
{
	static int	 initialized = 0;

	if (initialized)
		return;

	SSL_library_init();
	SSL_load_error_strings();

	/* Init hardware crypto engines. */
	ENGINE_load_builtin_engines();
	ENGINE_register_all_complete();

	initialized = 1;
}

int
ssl_password_cb(char *buf, int size, int rwflag, void *u)
{
	size_t	len;
	if (u == NULL) {
		bzero(buf, size);
		return (0);
	}
	if ((len = strlcpy(buf, u, size)) >= (size_t)size)
		return (0);
	return (len);
}

char *
ssl_load_key(struct relayd *env, const char *name, off_t *len, char *pass)
{
	FILE		*fp;
	EVP_PKEY	*key = NULL;
	BIO		*bio = NULL;
	long		 size;
	char		*data, *buf = NULL;

	/* Initialize SSL library once */
	ssl_init(env);

	/*
	 * Read (possibly) encrypted key from file
	 */
	if ((fp = fopen(name, "r")) == NULL)
		return (NULL);

	key = PEM_read_PrivateKey(fp, NULL, ssl_password_cb, pass);
	fclose(fp);
	if (key == NULL)
		goto fail;

	/*
	 * Write unencrypted key to memory buffer
	 */
	if ((bio = BIO_new(BIO_s_mem())) == NULL)
		goto fail;
	if (!PEM_write_bio_PrivateKey(bio, key, NULL, NULL, 0, NULL, NULL))
		goto fail;
	if ((size = BIO_get_mem_data(bio, &data)) <= 0)
		goto fail;
	if ((buf = calloc(1, size)) == NULL)
		goto fail;
	memcpy(buf, data, size);

	BIO_free_all(bio);
	EVP_PKEY_free(key);

	*len = (off_t)size;
	return (buf);

 fail:
	free(buf);
	if (bio != NULL)
		BIO_free_all(bio);
	if (key != NULL)
		EVP_PKEY_free(key);
	return (NULL);
}

uint8_t *
ssl_update_certificate(const uint8_t *oldcert, size_t oldlen, EVP_PKEY *pkey,
    EVP_PKEY *capkey, X509 *cacert, size_t *newlen)
{
	char		 name[2][TLS_NAME_SIZE];
	BIO		*in, *out = NULL;
	BUF_MEM		*bptr = NULL;
	X509		*cert = NULL;
	uint8_t		*newcert = NULL, *foo = NULL;

	/* XXX BIO_new_mem_buf is not using const so work around this */
	if ((foo = malloc(oldlen)) == NULL) {
		log_warn("%s: malloc", __func__);
		return (NULL);
	}
	memcpy(foo, oldcert, oldlen);

	if ((in = BIO_new_mem_buf(foo, oldlen)) == NULL) {
		log_warnx("%s: BIO_new_mem_buf failed", __func__);
		goto done;
	}

	if ((cert = PEM_read_bio_X509(in, NULL,
	    ssl_password_cb, NULL)) == NULL) {
		log_warnx("%s: PEM_read_bio_X509 failed", __func__);
		goto done;
	}

	BIO_free(in);
	in = NULL;

	name[0][0] = name[1][0] = '\0';
	if (!X509_NAME_oneline(X509_get_subject_name(cert),
	    name[0], sizeof(name[0])) ||
	    !X509_NAME_oneline(X509_get_issuer_name(cert),
	    name[1], sizeof(name[1])))
		goto done;

	if ((cert = X509_dup(cert)) == NULL)
		goto done;

	/* Update certificate key and use our CA as the issuer */
	X509_set_pubkey(cert, pkey);
	X509_set_issuer_name(cert, X509_get_subject_name(cacert));

	/* Sign with our CA */
	if (!X509_sign(cert, capkey, EVP_sha256())) {
		log_warnx("%s: X509_sign failed", __func__);
		goto done;
	}

#if DEBUG_CERT
	log_debug("%s: subject %s", __func__, name[0]);
	log_debug("%s: issuer %s", __func__, name[1]);
#if DEBUG > 2
	X509_print_fp(stdout, cert);
#endif
#endif

	/* write cert as PEM file */
	out = BIO_new(BIO_s_mem());
	if (out == NULL) {
		log_warnx("%s: BIO_new failed", __func__);
		goto done;
	}
	if (!PEM_write_bio_X509(out, cert)) {
		log_warnx("%s: PEM_write_bio_X509 failed", __func__);
		goto done;
	}
	BIO_get_mem_ptr(out, &bptr);
	if ((newcert = malloc(bptr->length)) == NULL) {
		log_warn("%s: malloc", __func__);
		goto done;
	}
	memcpy(newcert, bptr->data, bptr->length);
	*newlen = bptr->length;

done:
	free(foo);
	if (in)
		BIO_free(in);
	if (out)
		BIO_free(out);
	if (cert)
		X509_free(cert);
	return (newcert);
}

int
ssl_load_pkey(char *buf, off_t len, X509 **x509ptr, EVP_PKEY **pkeyptr)
{
	BIO		*in;
	X509		*x509 = NULL;
	EVP_PKEY	*pkey = NULL;
	RSA		*rsa = NULL;
	char		*hash = NULL;

	if ((in = BIO_new_mem_buf(buf, len)) == NULL) {
		log_warnx("%s: BIO_new_mem_buf failed", __func__);
		return (0);
	}
	if ((x509 = PEM_read_bio_X509(in, NULL,
	    ssl_password_cb, NULL)) == NULL) {
		log_warnx("%s: PEM_read_bio_X509 failed", __func__);
		goto fail;
	}
	if ((pkey = X509_get_pubkey(x509)) == NULL) {
		log_warnx("%s: X509_get_pubkey failed", __func__);
		goto fail;
	}
	if ((rsa = EVP_PKEY_get1_RSA(pkey)) == NULL) {
		log_warnx("%s: failed to extract RSA", __func__);
		goto fail;
	}
	if ((hash = malloc(TLS_CERT_HASH_SIZE)) == NULL) {
		log_warn("%s: allocate hash failed", __func__);
		goto fail;
	}
	hash_x509(x509, hash, TLS_CERT_HASH_SIZE);
	if (RSA_set_ex_data(rsa, 0, hash) != 1) {
		log_warnx("%s: failed to set hash as exdata", __func__);
		goto fail;
	}

	RSA_free(rsa); /* dereference, will be cleaned up with pkey */
	*pkeyptr = pkey;
	if (x509ptr != NULL)
		*x509ptr = x509;
	else
		X509_free(x509);
	BIO_free(in);

	return (1);

 fail:
	free(hash);
	if (rsa != NULL)
		RSA_free(rsa);
	if (pkey != NULL)
		EVP_PKEY_free(pkey);
	if (x509 != NULL)
		X509_free(x509);
	BIO_free(in);

	return (0);
}

/*
 * This function is a horrible hack but for RSA privsep to work a private key
 * with correct size needs to be loaded into the tls config.
 */
int
ssl_ctx_fake_private_key(char *buf, off_t len, const char **fake_key)
{
	BIO		*in;
	EVP_PKEY	*pkey = NULL;
	X509		*x509 = NULL;
	int		 ret = -1, keylen;

	if ((in = BIO_new_mem_buf(buf, len)) == NULL) {
		log_warnx("%s: BIO_new_mem_buf failed", __func__);
		return (0);
	}

	if ((x509 = PEM_read_bio_X509(in, NULL, NULL, NULL)) == NULL) {
		log_warnx("%s: PEM_read_bio_X509 failed", __func__);
		goto fail;
	}

	if ((pkey = X509_get_pubkey(x509)) == NULL) {
		log_warnx("%s: X509_get_pubkey failed", __func__);
		goto fail;
	}

	keylen = EVP_PKEY_size(pkey) * 8;
	switch(keylen) {
	case 1024:
		*fake_key = bogus_1024;
		ret = sizeof(bogus_1024);
		break;
	case 2048:
		*fake_key = bogus_2048;
		ret = sizeof(bogus_2048);
		break;
	case 4096:
		*fake_key = bogus_4096;
		ret = sizeof(bogus_4096);
		break;
	case 8192:
		*fake_key = bogus_8192;
		ret = sizeof(bogus_8192);
		break;
	default:
		log_warnx("%s: key size %d not support", __func__, keylen);
		ret = -1;
		break;
	}
fail:
	BIO_free(in);

	if (pkey != NULL)
		EVP_PKEY_free(pkey);
	if (x509 != NULL)
		X509_free(x509);

	return (ret);
}
@


1.33
log
@use __func__ in log messages. fix some whitespace while here.
From Hiltjo Posthuma hiltjo -AT codemadness -DOT- org, thanks!
ok florian, claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: ssl.c,v 1.32 2017/05/27 08:33:25 claudio Exp $	*/
d208 1
a208 2
ssl_load_pkey(void *data, char *buf, off_t len,
    X509 **x509ptr, EVP_PKEY **pkeyptr)
d214 1
a214 1
	void		*exdata = NULL;
a219 1

a224 1

d229 12
a240 11

	BIO_free(in);

	if (data != NULL) {
		if ((rsa = EVP_PKEY_get1_RSA(pkey)) == NULL) {
			log_warnx("%s: failed to extract RSA", __func__);
			goto fail;
		}

		RSA_set_ex_data(rsa, 0, data);
		RSA_free(rsa); /* dereference, will be cleaned up with pkey */
d243 2
d249 1
a249 2

	*pkeyptr = pkey;
d254 1
a256 2
	if (in != NULL)
		BIO_free(in);
d261 1
a261 1
	free(exdata);
@


1.32
log
@Migrate relayd to use libtls for TLS. Still does the TLS privsep via the
engine but at least we can use a sane API for new features.
Going in now so it is possible to work with this in tree.
General agreement at d2k17.
@
text
@d1 1
a1 1
/*	$OpenBSD: ssl.c,v 1.31 2017/01/09 14:49:21 reyk Exp $	*/
d130 1
a130 1
	if ((foo = malloc(oldlen)) == NULL) {	
d325 1
a325 1
	
@


1.31
log
@Stop accessing verbose and debug variables from log.c directly.

This replaces log_verbose() and "extern int verbose" with the two functions
log_setverbose() and log_getverbose().

Pointed out by benno@@
OK krw@@ eric@@ gilles@@ (OK gilles@@ for the snmpd bits as well)
@
text
@d1 1
a1 1
/*	$OpenBSD: ssl.c,v 1.30 2015/12/30 12:08:34 benno Exp $	*/
d21 2
a22 1
#include <sys/socket.h>
a23 4
#include <limits.h>
#include <stdio.h>
#include <stdlib.h>
#include <event.h>
d33 1
a34 4
void	ssl_read(int, short, void *);
void	ssl_write(int, short, void *);
void	ssl_connect(int, short, void *);
void	ssl_cleanup(struct ctl_tcp_event *);
a37 194
ssl_read(int s, short event, void *arg)
{
	char			 rbuf[SMALL_READ_BUF_SIZE];
	struct ctl_tcp_event	*cte = arg;
	int			 retry_flag = EV_READ;
	int			 tls_err = 0;
	int			 ret;

	if (event == EV_TIMEOUT) {
		cte->host->up = HOST_DOWN;
		ssl_cleanup(cte);
		hce_notify_done(cte->host, HCE_TLS_READ_TIMEOUT);
		return;
	}

	bzero(rbuf, sizeof(rbuf));

	ret = SSL_read(cte->ssl, rbuf, sizeof(rbuf));
	if (ret <= 0) {
		tls_err = SSL_get_error(cte->ssl, ret);
		switch (tls_err) {
		case SSL_ERROR_WANT_READ:
			retry_flag = EV_READ;
			goto retry;
		case SSL_ERROR_WANT_WRITE:
			retry_flag = EV_WRITE;
			goto retry;
		case SSL_ERROR_ZERO_RETURN: /* FALLTHROUGH */
		case SSL_ERROR_SYSCALL:
			if (ret == 0) {
				cte->host->up = HOST_DOWN;
				(void)cte->validate_close(cte);
				ssl_cleanup(cte);
				hce_notify_done(cte->host, cte->host->he);
				return;
			}
			/* FALLTHROUGH */
		default:
			cte->host->up = HOST_DOWN;
			ssl_error(cte->host->conf.name, "cannot read");
			ssl_cleanup(cte);
			hce_notify_done(cte->host, HCE_TLS_READ_ERROR);
			break;
		}
		return;
	}
	if (ibuf_add(cte->buf, rbuf, ret) == -1)
		fatal("ssl_read: buf_add error");
	if (cte->validate_read != NULL) {
		if (cte->validate_read(cte) != 0)
			goto retry;

		ssl_cleanup(cte);
		hce_notify_done(cte->host, cte->host->he);
		return;
	}

retry:
	event_again(&cte->ev, s, EV_TIMEOUT|retry_flag, ssl_read,
	    &cte->tv_start, &cte->table->conf.timeout, cte);
	return;
}

void
ssl_write(int s, short event, void *arg)
{
	struct ctl_tcp_event	*cte = arg;
	int			 retry_flag = EV_WRITE;
	int			 tls_err = 0;
	int			 len;
	int			 ret;

	if (event == EV_TIMEOUT) {
		cte->host->up = HOST_DOWN;
		ssl_cleanup(cte);
		hce_notify_done(cte->host, HCE_TLS_WRITE_TIMEOUT);
		return;
	}

	len = strlen(cte->table->sendbuf);

	ret = SSL_write(cte->ssl, cte->table->sendbuf, len);
	if (ret <= 0) {
		tls_err = SSL_get_error(cte->ssl, ret);
		switch (tls_err) {
		case SSL_ERROR_WANT_READ:
			retry_flag = EV_READ;
			goto retry;
		case SSL_ERROR_WANT_WRITE:
			retry_flag = EV_WRITE;
			goto retry;
		default:
			cte->host->up = HOST_DOWN;
			ssl_error(cte->host->conf.name, "cannot write");
			ssl_cleanup(cte);
			hce_notify_done(cte->host, HCE_TLS_WRITE_ERROR);
			return;
		}
	}
	if ((cte->buf = ibuf_dynamic(SMALL_READ_BUF_SIZE, UINT_MAX)) == NULL)
		fatalx("ssl_write: cannot create dynamic buffer");

	event_again(&cte->ev, s, EV_TIMEOUT|EV_READ, ssl_read,
	    &cte->tv_start, &cte->table->conf.timeout, cte);
	return;
retry:
	event_again(&cte->ev, s, EV_TIMEOUT|retry_flag, ssl_write,
	    &cte->tv_start, &cte->table->conf.timeout, cte);
}

void
ssl_connect(int s, short event, void *arg)
{
	struct ctl_tcp_event	*cte = arg;
	int			 retry_flag = 0;
	int			 tls_err = 0;
	int			 ret;

	if (event == EV_TIMEOUT) {
		cte->host->up = HOST_DOWN;
		hce_notify_done(cte->host, HCE_TLS_CONNECT_TIMEOUT);
		ssl_cleanup(cte);
		return;
	}

	ret = SSL_connect(cte->ssl);
	if (ret <= 0) {
		tls_err = SSL_get_error(cte->ssl, ret);
		switch (tls_err) {
		case SSL_ERROR_WANT_READ:
			retry_flag = EV_READ;
			goto retry;
		case SSL_ERROR_WANT_WRITE:
			retry_flag = EV_WRITE;
			goto retry;
		default:
			cte->host->up = HOST_DOWN;
			ssl_error(cte->host->conf.name, "cannot connect");
			hce_notify_done(cte->host, HCE_TLS_CONNECT_FAIL);
			ssl_cleanup(cte);
			return;
		}
	}

	if (cte->table->conf.check == CHECK_TCP) {
		cte->host->up = HOST_UP;
		hce_notify_done(cte->host, HCE_TLS_CONNECT_OK);
		ssl_cleanup(cte);
		return;
	}
	if (cte->table->sendbuf != NULL) {
		event_again(&cte->ev, cte->s, EV_TIMEOUT|EV_WRITE, ssl_write,
		    &cte->tv_start, &cte->table->conf.timeout, cte);
		return;
	}

	if ((cte->buf = ibuf_dynamic(SMALL_READ_BUF_SIZE, UINT_MAX)) == NULL)
		fatalx("ssl_connect: cannot create dynamic buffer");
	event_again(&cte->ev, cte->s, EV_TIMEOUT|EV_READ, ssl_read,
	    &cte->tv_start, &cte->table->conf.timeout, cte);
	return;

retry:
	event_again(&cte->ev, s, EV_TIMEOUT|retry_flag, ssl_connect,
	    &cte->tv_start, &cte->table->conf.timeout, cte);
}

void
ssl_cleanup(struct ctl_tcp_event *cte)
{
	close(cte->s);
	if (cte->ssl != NULL) {
		SSL_shutdown(cte->ssl);
		SSL_clear(cte->ssl);
	}
	ibuf_free(cte->buf);
	cte->buf = NULL;
}

void
ssl_error(const char *where, const char *what)
{
	char		 errbuf[128];
	unsigned long	 code;

	if (log_getverbose() < 2)
		return;
	for (; (code = ERR_get_error()) != 0 ;) {
		ERR_error_string_n(code, errbuf, sizeof(errbuf));
		log_debug("SSL library error: %s: %s: %s", where, what, errbuf);
	}
}

void
a54 37
void
ssl_transaction(struct ctl_tcp_event *cte)
{
	if (cte->ssl == NULL) {
		cte->ssl = SSL_new(cte->table->ssl_ctx);
		if (cte->ssl == NULL) {
			ssl_error(cte->host->conf.name, "cannot create object");
			fatal("cannot create SSL object");
		}
	}

	if (SSL_set_fd(cte->ssl, cte->s) == 0) {
		cte->host->up = HOST_UNKNOWN;
		ssl_error(cte->host->conf.name, "cannot set fd");
		ssl_cleanup(cte);
		hce_notify_done(cte->host, HCE_TLS_CONNECT_ERROR);
		return;
	}
	SSL_set_connect_state(cte->ssl);

	event_again(&cte->ev, cte->s, EV_TIMEOUT|EV_WRITE, ssl_connect,
	    &cte->tv_start, &cte->table->conf.timeout, cte);
}

SSL_CTX *
ssl_ctx_create(struct relayd *env)
{
	SSL_CTX	*ctx;

	ctx = SSL_CTX_new(SSLv23_client_method());
	if (ctx == NULL) {
		ssl_error("ssl_ctx_create", "cannot create context");
		fatal("could not create SSL context");
	}
	return (ctx);
}

a110 2
	ssl_error(__func__, name);

d119 3
a121 3
X509 *
ssl_update_certificate(X509 *oldcert, EVP_PKEY *pkey, EVP_PKEY *capkey,
    X509 *cacert)
d124 2
d127 22
d151 1
a151 1
	if (!X509_NAME_oneline(X509_get_subject_name(oldcert),
d153 1
a153 1
	    !X509_NAME_oneline(X509_get_issuer_name(oldcert),
d157 1
a157 1
	if ((cert = X509_dup(oldcert)) == NULL)
d165 3
a167 3
	if (!X509_sign(cert, capkey, EVP_sha1())) {
		X509_free(cert);
		cert = NULL;
d178 17
a194 3
 done:
	if (cert == NULL)
		ssl_error(__func__, name[0]);
d196 9
a204 1
	return (cert);
d208 1
a208 1
ssl_load_pkey(const void *data, size_t datalen, char *buf, off_t len,
d218 1
a218 1
		SSLerr(SSL_F_SSL_CTX_USE_PRIVATEKEY, ERR_R_BUF_LIB);
d224 1
a224 1
		SSLerr(SSL_F_SSL_CTX_USE_PRIVATEKEY, ERR_R_PEM_LIB);
d229 1
a229 1
		SSLerr(SSL_F_SSL_CTX_USE_PRIVATEKEY, ERR_R_X509_LIB);
d235 3
a237 4
	if (data != NULL && datalen) {
		if ((rsa = EVP_PKEY_get1_RSA(pkey)) == NULL ||
		    (exdata = malloc(datalen)) == NULL) {
			SSLerr(SSL_F_SSL_CTX_USE_PRIVATEKEY, ERR_R_EVP_LIB);
d241 1
a241 2
		memcpy(exdata, data, datalen);
		RSA_set_ex_data(rsa, 0, exdata);
d245 5
a249 1
	*x509ptr = x509;
d268 4
d273 1
a273 2
ssl_ctx_fake_private_key(SSL_CTX *ctx, const void *data, size_t datalen,
    char *buf, off_t len, X509 **x509ptr, EVP_PKEY **pkeyptr)
d275 1
a275 1
	int		 ret = 0;
d278 1
d280 2
a281 1
	if (!ssl_load_pkey(data, datalen, buf, len, &x509, &pkey))
d283 1
d285 37
a321 13
	/*
	 * Use the public key as the "private" key - the secret key
	 * parameters are hidden in an extra process that will be
	 * contacted by the RSA engine.  The SSL/TLS library needs at
	 * least the public key parameters in the current process.
	 */
	ret = SSL_CTX_use_PrivateKey(ctx, pkey);
	if (!ret)
		SSLerr(SSL_F_SSL_CTX_USE_PRIVATEKEY, ERR_R_SSL_LIB);

	if (pkeyptr != NULL)
		*pkeyptr = pkey;
	else if (pkey != NULL)
d323 1
a323 4

	if (x509ptr != NULL)
		*x509ptr = x509;
	else if (x509 != NULL)
d325 1
a325 1

a327 1

@


1.30
log
@now that ibuf_free() checks for null, we can remove the check here.
ok mmcc@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ssl.c,v 1.29 2015/03/24 08:44:04 giovanni Exp $	*/
a227 1
	extern int	 debug;
d229 1
a229 1
	if (!debug)
@


1.29
log
@Missing free(3) in error path
ok benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ssl.c,v 1.28 2015/01/22 17:42:09 reyk Exp $	*/
d219 2
a220 4
	if (cte->buf != NULL) {
		ibuf_free(cte->buf);
		cte->buf = NULL;
	}
@


1.28
log
@Clean up the relayd headers with help of include-what-you-use and some
manual review.  Based on common practice, relayd.h now includes the
necessary headers for itself.

OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ssl.c,v 1.27 2015/01/16 15:06:41 deraadt Exp $	*/
d457 1
@


1.28.2.1
log
@maintainance diff for relayd
MFC the following changes

- Missing free(3) in error path (ssl.c,v 1.29)
- fix a memory leak. (pfe.c,v 1.80)
- allocate se_log evbuffer before loging errors with relay_close()
  (relay.c,v 1.192)
- fix a file descriptor leak in http protocol handling
  (relay.c,v 1.193 and relay_http.c,v 1.44)
- Fix obvious problems with relayd config reload
  (ca.c,v 1.13; config.c,v 1.25; parse.y,v 1.204;
  relayd.c,v 1.139; relayd.h,v 1.209)
- http protocol: you cannot append to the previous key-value before
  line three of a request (relay_http.c,v 1.45)
- fix a crash / use after free (relay.c,v 1.194; relay_http.c,v 1.46)
- fix a non safe use of TAILQ_FOREACH with TAILQ_REMOVE
  (relay_http.c,v 1.47)
- Plug a memory leak by simplifying kv_free() (relayd.c,v 1.141)
- Fix memory leak in error case (relay_http.c,v 1.48)
- track the connection state of a session and stops doing double
  opens in certain situations (relay.c,v 1.195; relay_http.c,v 1.49; relayd.h,v 1.210)
- coding style (relay.c,v 1.196; relay_http.c,v 1.50; relayd.h,v 1.212)

ok claudio@@, sthen@@ and feedback tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ssl.c,v 1.28 2015/01/22 17:42:09 reyk Exp $	*/
a456 1
	free(exdata);
@


1.27
log
@Adapt to <limits.h> universe.
ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: ssl.c,v 1.26 2014/12/12 10:05:09 reyk Exp $	*/
d20 1
a20 1
#include <sys/queue.h>
a22 3
#include <net/if.h>
#include <netinet/in.h>

d24 2
a26 1
#include <fcntl.h>
d29 1
a29 2
#include <stdlib.h>
#include <errno.h>
a33 1
#include <openssl/rsa.h>
@


1.26
log
@Change the keyword "ssl" to "tls" to reflect reality since we
effectively disabled support for the SSL protocols.  SSL remains a
common term describing SSL/TLS, there is some controvery about this
change, and the name really doesn't matter, but I feel confident about
it now.

(btw., sthen@@ pointed out some historical context:
http://tim.dierks.org/2014/05/security-standards-and-name-changes-in.html)

OK benno@@, with input from tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ssl.c,v 1.25 2014/07/10 12:50:05 jsg Exp $	*/
a19 1
#include <sys/param.h>
@


1.25
log
@add additional includes required to build with -DOPENSSL_NO_DEPRECATED
ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ssl.c,v 1.24 2014/05/20 17:33:36 reyk Exp $	*/
d54 1
a54 1
	int			 ssl_err = 0;
d60 1
a60 1
		hce_notify_done(cte->host, HCE_SSL_READ_TIMEOUT);
d68 2
a69 2
		ssl_err = SSL_get_error(cte->ssl, ret);
		switch (ssl_err) {
d90 1
a90 1
			hce_notify_done(cte->host, HCE_SSL_READ_ERROR);
d117 1
a117 1
	int			 ssl_err = 0;
d124 1
a124 1
		hce_notify_done(cte->host, HCE_SSL_WRITE_TIMEOUT);
d132 2
a133 2
		ssl_err = SSL_get_error(cte->ssl, ret);
		switch (ssl_err) {
d144 1
a144 1
			hce_notify_done(cte->host, HCE_SSL_WRITE_ERROR);
d164 1
a164 1
	int			 ssl_err = 0;
d169 1
a169 1
		hce_notify_done(cte->host, HCE_SSL_CONNECT_TIMEOUT);
d176 2
a177 2
		ssl_err = SSL_get_error(cte->ssl, ret);
		switch (ssl_err) {
d187 1
a187 1
			hce_notify_done(cte->host, HCE_SSL_CONNECT_FAIL);
d195 1
a195 1
		hce_notify_done(cte->host, HCE_SSL_CONNECT_OK);
d278 1
a278 1
		hce_notify_done(cte->host, HCE_SSL_CONNECT_ERROR);
d370 1
a370 1
	char		 name[2][SSL_NAME_SIZE];
@


1.24
log
@Unify the SSL privsep key loading functions.

ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ssl.c,v 1.23 2014/05/06 11:03:02 reyk Exp $	*/
d38 1
@


1.23
log
@Fix two memory leaks: EVP_PKEY_get1_RSA() returns a referenced key
that requires to call RSA_free() to dereference it after use.  Also
free a temporary key that was read by PEM_read_PrivateKey() and
immediately written into a bio.

ok markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ssl.c,v 1.22 2014/04/22 08:04:23 reyk Exp $	*/
d408 1
a408 1
ssl_ctx_load_pkey(SSL_CTX *ctx, void *data, char *buf, off_t len,
a410 1
	int		 ret = 0;
d415 1
d433 12
a444 3
	if ((rsa = EVP_PKEY_get1_RSA(pkey)) == NULL) {
		SSLerr(SSL_F_SSL_CTX_USE_PRIVATEKEY, ERR_R_EVP_LIB);
		goto fail;
a446 3
	RSA_set_ex_data(rsa, 0, data);
	RSA_free(rsa); /* dereference, will be cleaned up with pkey */

a448 1
	ret = 1;
d450 1
a450 1
	goto done;
d453 4
d462 1
a462 5
 done:
	if (in != NULL)
		BIO_free(in);

	return ret;
d466 2
a467 2
ssl_ctx_fake_private_key(SSL_CTX *ctx, void *data, char *buf, off_t len,
    X509 **x509ptr, EVP_PKEY **pkeyptr)
d469 3
a471 1
	int	 ret;
d473 2
a474 3
	if (!(ret = ssl_ctx_load_pkey(ctx, data, buf, len,
	    x509ptr, pkeyptr)))
		goto fail;
d482 2
a483 1
	if (!SSL_CTX_use_PrivateKey(ctx, *pkeyptr)) {
a484 2
		goto fail;
	}
d486 4
a489 1
	return (1);
d491 4
a494 7
 fail:
	if (*pkeyptr != NULL)
		EVP_PKEY_free(*pkeyptr);
	if (*x509ptr != NULL)
		X509_free(*x509ptr);
	*x509ptr = NULL;
	*pkeyptr = NULL;
d496 1
a496 1
	return (0);
d498 1
@


1.22
log
@Support the CA key for SSL inspection in the ca process.  Instead of
looking up the keys by relay id, add all keys to a list and look them
up by key id.

ok benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ssl.c,v 1.21 2014/04/21 17:22:06 reyk Exp $	*/
d349 2
d360 2
d439 1
@


1.21
log
@Use RSA_set_ex_data()/RSA_get_ex_data() directly instead of
the undocumented RSA_set_app_data()/RSA_get_app_data() wrappers.
@
text
@d1 1
a1 1
/*	$OpenBSD: ssl.c,v 1.20 2014/04/18 13:55:26 reyk Exp $	*/
d362 2
a363 2
ssl_update_certificate(X509 *oldcert, EVP_PKEY *pkey,
    char *cakeystr, off_t cakeylen, char *cacertstr, off_t cacertlen)
d366 1
a366 3
	X509		*cert = NULL, *cacert = NULL;
	EVP_PKEY	*cakey = NULL;
	BIO		*bio = NULL;
a374 16
	/* Get CA key */
	BIO_free_all(bio);
	if ((bio = BIO_new_mem_buf(cakeystr, cakeylen)) == NULL)
		goto done;
	if ((cakey = PEM_read_bio_PrivateKey(bio, &cakey,
	    ssl_password_cb, NULL)) == NULL)
		goto done;

	/* Get CA certificate */
	BIO_free_all(bio);
	if ((bio = BIO_new_mem_buf(cacertstr, cacertlen)) == NULL)
		goto done;
	if ((cacert = PEM_read_bio_X509(bio, &cacert,
	    ssl_password_cb, NULL)) == NULL)
		goto done;

d383 1
a383 1
	if (!X509_sign(cert, cakey, EVP_sha1())) {
a398 6
	if (bio != NULL)
		BIO_free_all(bio);
	if (cacert != NULL)
		X509_free(cacert);
	if (cakey != NULL)
		EVP_PKEY_free(cakey);
d404 1
a404 1
ssl_ctx_fake_private_key(SSL_CTX *ctx, void *data, char *buf, off_t len,
d419 1
a419 2
	    ctx->default_passwd_callback,
	    ctx->default_passwd_callback_userdata)) == NULL) {
a435 11
	/*
	 * Use the public key as the "private" key - the secret key
	 * parameters are hidden in an extra process that will be
	 * contacted by the RSA engine.  The SSL/TLS library needs at
	 * least the public key parameters in the current process.
	 */
	if (!SSL_CTX_use_PrivateKey(ctx, pkey)) {
		SSLerr(SSL_F_SSL_CTX_USE_PRIVATEKEY, ERR_R_SSL_LIB);
		goto fail;
	}

d453 34
@


1.20
log
@Introduce privsep for private keys:

- Move RSA private keys to a new separate process instead of copying
them to the relays.  A custom RSA engine is used by the SSL/TLS code
of the relay processes to send RSA private key encryption/decryption
(also used for sign/verify) requests to the new "ca" processes instead
of operating on the private key directly.

- Each relay process gets its own related ca process.  Setting
"prefork 5" in the config file will spawn 10 processes (5 relay, 5
ca).  This diff also reduces the default number of relay processes
from 5 to 3 which should be suitable in most installations without a
very heavy load.

- Don't keep text versions of the keys in memory, parse them once and
keep the binary representation.  This might still be the case in
OpenSSL's internals but will be fixed in the library.

This diff doesn't prevent something like "heartbleed" but adds an
additional mitigation to prevent leakage of the private keys from the
processes doing SSL/TLS.

With feedback from many
ok benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ssl.c,v 1.19 2013/05/31 20:23:37 benno Exp $	*/
d459 1
a459 1
	RSA_set_app_data(rsa, data);
@


1.19
log
@unset cte->buf after free, fix double free via tcp_close().
ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ssl.c,v 1.18 2013/05/30 20:17:12 reyk Exp $	*/
d4 1
a4 1
 * Copyright (c) 2007-2013 Reyk Floeter <reyk@@openbsd.org>
d362 1
a362 1
ssl_update_certificate(X509 *oldcert, char *keystr, off_t keylen,
d367 1
a367 1
	EVP_PKEY	*key = NULL, *cakey = NULL;
a376 7
	/* Get SSL key */
	if ((bio = BIO_new_mem_buf(keystr, keylen)) == NULL)
		goto done;
	if ((key = PEM_read_bio_PrivateKey(bio, &key,
	    ssl_password_cb, NULL)) == NULL)
		goto done;

d397 1
a397 1
	X509_set_pubkey(cert, key);
a418 2
	if (key != NULL)
		EVP_PKEY_free(key);
d425 64
@


1.18
log
@Support SSL inspection, the ability to transparently filter in SSL/TLS
connections (eg. HTTPS) by using a local CA that is accepted by the
clients.  See the "SSL RELAYS" and "EXAMPLES" sections in the
relayd.conf(5) manpage for more details.

ok benno@@, manpage bits jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ssl.c,v 1.17 2012/12/18 15:34:07 reyk Exp $	*/
d223 1
a223 1
	if (cte->buf != NULL)
d225 2
@


1.17
log
@reorder the variables a bit, no functionaly change.
@
text
@d1 1
a1 1
/*	$OpenBSD: ssl.c,v 1.16 2010/05/26 13:56:08 nicm Exp $	*/
d4 1
d45 1
d245 5
d256 2
d295 137
@


1.16
log
@Rename some imsg bits to make namespace collisions less likely buf to
ibuf, buf_read to ibuf_read, READ_BUF_SIZE to IBUF_READ_SIZE.

ok henning gilles claudio jacekm deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: ssl.c,v 1.15 2009/06/04 13:46:07 reyk Exp $	*/
d48 1
d50 2
a52 3
	int			 ssl_err;
	int			 retry_flag;
	char			 rbuf[SMALL_READ_BUF_SIZE];
a61 2
	ssl_err = 0;
	retry_flag = EV_READ;
d113 2
a116 2
	int			 ssl_err;
	int			 retry_flag;
a125 1
	retry_flag = EV_WRITE;
d160 2
a162 2
	int			 ssl_err;
	int			 retry_flag;
a170 2
	retry_flag = ssl_err = 0;

d228 1
a229 1
	char		 errbuf[128];
@


1.15
log
@Keep around the SSL session for each checked host. This way SSL
caching can kick in on subsequent checks, making them faster and
lighter on the server.

From camield, closes PR 6137 (modified diff)
@
text
@d1 1
a1 1
/*	$OpenBSD: ssl.c,v 1.14 2008/12/05 16:37:56 reyk Exp $	*/
d94 1
a94 1
	if (buf_add(cte->buf, rbuf, ret) == -1)
d148 1
a148 1
	if ((cte->buf = buf_dynamic(SMALL_READ_BUF_SIZE, UINT_MAX)) == NULL)
d207 1
a207 1
	if ((cte->buf = buf_dynamic(SMALL_READ_BUF_SIZE, UINT_MAX)) == NULL)
d227 1
a227 1
		buf_free(cte->buf);
@


1.14
log
@change the way relayd reports check results: instead of logging an
arbitrary string in debugging mode, it will store an error code
(HCE_*) for each host.  the error code can be translated to a string
(in log.c) for debugging but it will also be passed to relayctl via
the control socket.

from a user point of view, this will print a human-readable error
message in the "relayctl show hosts" output if a host is down because
the check failed.  the relayctl(8) manpage includes detailed
explanations of the error messages including mitigations for the
most-common problems.

ok jmc@@ (manpages)
ok phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ssl.c,v 1.13 2007/12/07 17:17:01 reyk Exp $	*/
d222 4
a225 2
	if (cte->ssl != NULL)
		SSL_free(cte->ssl);
a258 1
	cte->ssl = SSL_new(cte->table->ssl_ctx);
d260 5
a264 2
		ssl_error(cte->host->conf.name, "cannot create object");
		fatal("cannot create SSL object");
@


1.13
log
@hoststated gets renamed to relayd.  easier to type, and actually says
what the daemon does - it is a relayer that pays attention to the status
of pools of hosts; not a status checkers that happens to do some relaying
@
text
@d1 1
a1 1
/*	$OpenBSD: ssl.c,v 1.12 2007/12/05 23:02:05 reyk Exp $	*/
d57 1
a57 1
		hce_notify_done(cte->host, "ssl_read: timeout");
d81 1
a81 6
				if (cte->host->up == HOST_UP)
					hce_notify_done(cte->host,
					    "ssl_read: check succeeded");
				else
					hce_notify_done(cte->host,
					    "ssl_read: check failed");
d89 1
a89 1
			hce_notify_done(cte->host, "ssl_read: SSL error");
d101 1
a101 4
		if (cte->host->up == HOST_UP)
			hce_notify_done(cte->host, "ssl_read: check succeeded");
		else
			hce_notify_done(cte->host, "ssl_read: check failed");
d123 1
a123 1
		hce_notify_done(cte->host, "ssl_write: timeout");
d144 1
a144 1
			hce_notify_done(cte->host, "ssl_write: SSL error");
d169 1
a169 1
		hce_notify_done(cte->host, "ssl_connect: timeout");
d189 1
a189 1
			hce_notify_done(cte->host, "ssl_connect: SSL error");
d197 1
a197 1
		hce_notify_done(cte->host, "ssl_connect: connect successful");
d267 1
a267 2
		hce_notify_done(cte->host,
		    "ssl_transaction: cannot set SSL fd");
@


1.12
log
@fix fd/ssl leak in hoststated ssl checks

From Przemyslaw Frasunek, closes PR 5671
@
text
@d1 1
a1 1
/*	$OpenBSD: ssl.c,v 1.11 2007/11/24 17:07:28 reyk Exp $	*/
d38 1
a38 1
#include "hoststated.h"
d252 1
a252 1
ssl_init(struct hoststated *env)
d286 1
a286 1
ssl_ctx_create(struct hoststated *env)
@


1.11
log
@sort includes, adjust to style(9)
@
text
@d1 1
a1 1
/*	$OpenBSD: ssl.c,v 1.10 2007/09/28 13:29:56 pyr Exp $	*/
d178 1
@


1.10
log
@Correct my mail address.
@
text
@d1 1
a1 1
/*	$OpenBSD: ssl.c,v 1.9 2007/05/27 20:53:10 pyr Exp $	*/
d19 1
a19 1
#include <sys/types.h>
d22 2
a23 1
#include <sys/param.h>
d25 1
a25 1
#include <net/if.h>
@


1.9
log
@Second step towards hoststated reload:
First split out hosts, tables and services into to structs, one that
contains the runtime fields and one (inside the runtime) that contains
mostly static fields that will be sent over the socket during reload.

Also move the demoted field of tables inside the flags field as its
just a boolean.
ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ssl.c,v 1.8 2007/02/22 05:58:06 reyk Exp $	*/
d4 1
a4 1
 * Copyright (c) 2006 Pierre-Yves Ritschard <pyr@@spootnik.org>
@


1.8
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: ssl.c,v 1.7 2007/02/22 03:32:40 reyk Exp $	*/
d91 1
a91 1
			ssl_error(cte->host->name, "cannot read");
d114 1
a114 1
	    &cte->tv_start, &cte->table->timeout, cte);
d149 1
a149 1
			ssl_error(cte->host->name, "cannot write");
d159 1
a159 1
	    &cte->tv_start, &cte->table->timeout, cte);
d163 1
a163 1
	    &cte->tv_start, &cte->table->timeout, cte);
d194 1
a194 1
			ssl_error(cte->host->name, "cannot connect");
d201 1
a201 1
	if (cte->table->check == CHECK_TCP) {
d209 1
a209 1
		    &cte->tv_start, &cte->table->timeout, cte);
d216 1
a216 1
	    &cte->tv_start, &cte->table->timeout, cte);
d221 1
a221 1
	    &cte->tv_start, &cte->table->timeout, cte);
d265 1
a265 1
		ssl_error(cte->host->name, "cannot create object");
d271 1
a271 1
		ssl_error(cte->host->name, "cannot set fd");
d280 1
a280 1
	    &cte->tv_start, &cte->table->timeout, cte);
@


1.7
log
@Add layer 7 functionality to hoststated used for layer 7
loadbalancing, SSL acceleration, general-purpose TCP relaying, and
transparent proxying.

see hoststated.conf(5) and my upcoming article on undeadly.org for
details.

ok to commit deraadt@@ pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ssl.c,v 1.6 2007/02/08 13:32:24 reyk Exp $	*/
d97 1
a97 1
	} 
d123 1
a123 1
	int		 	 ret;
d137 1
a137 1
	ret = SSL_write(cte->ssl, cte->table->sendbuf, len); 
d170 1
a170 1
	int		 	 ret;
d182 1
a182 1
	ret = SSL_connect(cte->ssl); 
d271 1
a271 1
		ssl_error(cte->host->name, "cannot set fd"); 
@


1.6
log
@carefully check some return values and make lint happier.  never pass
any truncated strings (table names/anchors/tags/...) to pf and the
kernel.

ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ssl.c,v 1.5 2007/02/07 14:39:45 reyk Exp $	*/
d35 1
d254 4
@


1.5
log
@remove superfluos log_debug() messages

ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ssl.c,v 1.4 2007/02/06 10:27:33 reyk Exp $	*/
d97 2
a98 2
	buf_add(cte->buf, rbuf, ret);

@


1.4
log
@update some more debug messages and fix typos. also remove some extra
debug noise from ssl.c.
@
text
@d1 1
a1 1
/*	$OpenBSD: ssl.c,v 1.3 2007/02/06 10:06:55 reyk Exp $	*/
a111 2
	log_debug("ssl_read: scheduling ssl_read on %s",
	    (retry_flag == EV_READ) ? "EV_READ" : "EV_WRITE");
a156 1
	log_debug("ssl_write: scheduling ssl_read on EV_READ");
a160 2
	log_debug("ssl_write: scheduling ssl_write on %s",
	    (retry_flag == EV_READ) ? "EV_READ" : "EV_WRITE");
a205 1
	log_debug("ssl_connect: connect succeeded");
a206 1
		log_debug("ssl_connect: scheduling ssl_write on EV_WRITE");
a213 1
	log_debug("ssl_connect: scheduling ssl_read on EV_READ");
a218 2
	log_debug("ssl_write: scheduling ssl_write on %s",
	    (retry_flag == EV_READ) ? "EV_READ" : "EV_WRITE");
a225 1
	log_debug("ssl_cleanup: cleaning for %s", cte->host->name);
@


1.3
log
@declare the function ssl_error() globally
@
text
@d1 1
a1 1
/*	$OpenBSD: ssl.c,v 1.2 2007/01/30 11:48:06 pyr Exp $	*/
a57 1
	log_debug("ssl_read: event occurred");
a63 1

a67 1
			log_debug("ssl_read: want read");
a70 1
			log_debug("ssl_read: want read");
a134 1
	log_debug("ssl_write: event occurred");
a138 1

a142 1
			log_debug("ssl_write: want read");
a145 1
			log_debug("ssl_write: want write");
a186 1

a190 1
			log_debug("ssl_connect: want read");
a193 1
			log_debug("ssl_connect: want write");
d249 4
a252 1
	
d279 2
a280 1
		hce_notify_done(cte->host, "cannot set SSL fd");
@


1.2
log
@provide more accurate error messages.
ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ssl.c,v 1.1 2007/01/29 14:23:31 pyr Exp $	*/
a41 1
void	ssl_error(const char *, const char *);
@


1.1
log
@Add SSL support to hoststated.
with help and OK reyk@@
with help and advice by claudio@@ and Srebrenko Sehic
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d42 1
a42 1
void	ssl_error(const char *);
d95 1
a95 1
			ssl_error("cannot read");
d159 1
a159 1
			ssl_error("cannot write");
d210 1
a210 1
			ssl_error("ssl_connect: cannot connect");
d257 1
a257 1
ssl_error(const char *msg)
d259 2
a260 2
	unsigned long	code;
	char		errbuf[128];
a261 1

d264 1
a264 1
		log_debug("ssl_error: %s: %s", msg, errbuf);
d280 1
a280 1
		ssl_error("ssl_transaction: cannot create object");
d286 1
a286 1
		ssl_error("ssl_transaction: cannot set fd"); 
d304 1
a304 1
		ssl_error("ssl_ctx_create: cannot create context");
@

