head	1.75;
access;
symbols
	OPENBSD_6_1_BASE:1.75
	OPENBSD_6_0:1.72.0.4
	OPENBSD_6_0_BASE:1.72
	OPENBSD_5_9:1.72.0.2
	OPENBSD_5_9_BASE:1.72
	OPENBSD_5_8:1.69.0.6
	OPENBSD_5_8_BASE:1.69
	OPENBSD_5_7:1.69.0.2
	OPENBSD_5_7_BASE:1.69
	OPENBSD_5_6:1.64.0.8
	OPENBSD_5_6_BASE:1.64
	OPENBSD_5_5:1.64.0.6
	OPENBSD_5_5_BASE:1.64
	OPENBSD_5_4:1.64.0.2
	OPENBSD_5_4_BASE:1.64
	OPENBSD_5_3:1.63.0.4
	OPENBSD_5_3_BASE:1.63
	OPENBSD_5_2:1.63.0.2
	OPENBSD_5_2_BASE:1.63
	OPENBSD_5_1_BASE:1.62
	OPENBSD_5_1:1.62.0.2
	OPENBSD_5_0:1.60.0.2
	OPENBSD_5_0_BASE:1.60
	OPENBSD_4_9:1.57.0.2
	OPENBSD_4_9_BASE:1.57
	OPENBSD_4_8:1.55.0.2
	OPENBSD_4_8_BASE:1.55
	OPENBSD_4_7:1.54.0.2
	OPENBSD_4_7_BASE:1.54
	OPENBSD_4_6:1.53.0.4
	OPENBSD_4_6_BASE:1.53
	OPENBSD_4_5:1.46.0.2
	OPENBSD_4_5_BASE:1.46
	OPENBSD_4_4:1.43.0.2
	OPENBSD_4_4_BASE:1.43
	OPENBSD_4_3:1.40.0.2
	OPENBSD_4_3_BASE:1.40;
locks; strict;
comment	@ * @;


1.75
date	2016.09.03.14.09.04;	author reyk;	state Exp;
branches;
next	1.74;
commitid	0kWOwUNycE381inh;

1.74
date	2016.09.02.14.45.51;	author reyk;	state Exp;
branches;
next	1.73;
commitid	vcV98N2DyJGMwDyQ;

1.73
date	2016.09.02.11.51.49;	author reyk;	state Exp;
branches;
next	1.72;
commitid	Scmkna4JViHMcK3U;

1.72
date	2016.01.11.21.31.42;	author benno;	state Exp;
branches;
next	1.71;
commitid	tlLuP4GlMjndgo3c;

1.71
date	2015.12.02.13.41.27;	author reyk;	state Exp;
branches;
next	1.70;
commitid	vBNcEM4jmO1KceIa;

1.70
date	2015.11.28.18.10.12;	author benno;	state Exp;
branches;
next	1.69;
commitid	QkvnB3mbZvtyr79o;

1.69
date	2015.01.22.17.42.09;	author reyk;	state Exp;
branches;
next	1.68;
commitid	puppem00jmzmdm4f;

1.68
date	2015.01.16.15.06.40;	author deraadt;	state Exp;
branches;
next	1.67;
commitid	tOv8XK6tLyhEfayc;

1.67
date	2014.12.12.10.05.09;	author reyk;	state Exp;
branches;
next	1.66;
commitid	J8g0vRzthwLCqf68;

1.66
date	2014.11.19.10.24.40;	author blambert;	state Exp;
branches;
next	1.65;
commitid	EGrSQMGI27r3h8Vf;

1.65
date	2014.10.25.03.23.49;	author lteo;	state Exp;
branches;
next	1.64;
commitid	2uw1UTO4k6erpWzK;

1.64
date	2013.03.10.23.32.53;	author reyk;	state Exp;
branches;
next	1.63;

1.63
date	2012.05.09.12.54.13;	author giovanni;	state Exp;
branches;
next	1.62;

1.62
date	2012.01.21.13.40.48;	author camield;	state Exp;
branches;
next	1.61;

1.61
date	2011.11.12.19.36.17;	author camield;	state Exp;
branches;
next	1.60;

1.60
date	2011.05.19.08.56.49;	author reyk;	state Exp;
branches;
next	1.59;

1.59
date	2011.05.09.12.08.47;	author reyk;	state Exp;
branches;
next	1.58;

1.58
date	2011.05.05.12.01.43;	author reyk;	state Exp;
branches;
next	1.57;

1.57
date	2011.02.08.08.52.28;	author sthen;	state Exp;
branches;
next	1.56;

1.56
date	2010.11.30.14.38.45;	author reyk;	state Exp;
branches;
next	1.55;

1.55
date	2010.05.14.11.13.36;	author reyk;	state Exp;
branches;
next	1.54;

1.54
date	2010.01.11.06.40.14;	author jsg;	state Exp;
branches;
next	1.53;

1.53
date	2009.06.05.23.39.51;	author pyr;	state Exp;
branches;
next	1.52;

1.52
date	2009.06.05.00.20.50;	author pyr;	state Exp;
branches;
next	1.51;

1.51
date	2009.06.05.00.04.01;	author pyr;	state Exp;
branches;
next	1.50;

1.50
date	2009.06.04.13.46.07;	author reyk;	state Exp;
branches;
next	1.49;

1.49
date	2009.06.02.12.24.16;	author reyk;	state Exp;
branches;
next	1.48;

1.48
date	2009.06.02.11.33.06;	author reyk;	state Exp;
branches;
next	1.47;

1.47
date	2009.04.17.09.47.06;	author reyk;	state Exp;
branches;
next	1.46;

1.46
date	2008.12.05.16.37.55;	author reyk;	state Exp;
branches;
next	1.45;

1.45
date	2008.09.29.15.12.22;	author reyk;	state Exp;
branches;
next	1.44;

1.44
date	2008.08.08.08.51.21;	author thib;	state Exp;
branches;
next	1.43;

1.43
date	2008.07.19.11.38.54;	author reyk;	state Exp;
branches;
next	1.42;

1.42
date	2008.07.19.10.52.32;	author reyk;	state Exp;
branches;
next	1.41;

1.41
date	2008.03.12.10.50.44;	author pyr;	state Exp;
branches;
next	1.40;

1.40
date	2008.02.11.10.42.50;	author reyk;	state Exp;
branches;
next	1.39;

1.39
date	2008.01.31.09.33.39;	author reyk;	state Exp;
branches;
next	1.38;

1.38
date	2007.12.08.20.36.36;	author pyr;	state Exp;
branches;
next	1.37;

1.37
date	2007.12.07.17.17.00;	author reyk;	state Exp;
branches;
next	1.36;

1.36
date	2007.11.24.17.07.28;	author reyk;	state Exp;
branches;
next	1.35;

1.35
date	2007.11.21.09.54.39;	author pyr;	state Exp;
branches;
next	1.34;

1.34
date	2007.11.20.15.44.21;	author pyr;	state Exp;
branches;
next	1.33;

1.33
date	2007.11.19.15.31.36;	author reyk;	state Exp;
branches;
next	1.32;

1.32
date	2007.10.19.12.08.55;	author pyr;	state Exp;
branches;
next	1.31;

1.31
date	2007.10.12.12.50.59;	author blambert;	state Exp;
branches;
next	1.30;

1.30
date	2007.09.28.13.29.56;	author pyr;	state Exp;
branches;
next	1.29;

1.29
date	2007.06.19.13.06.00;	author pyr;	state Exp;
branches;
next	1.28;

1.28
date	2007.06.19.06.29.20;	author pyr;	state Exp;
branches;
next	1.27;

1.27
date	2007.06.12.15.16.10;	author msf;	state Exp;
branches;
next	1.26;

1.26
date	2007.06.07.07.19.50;	author pyr;	state Exp;
branches;
next	1.25;

1.25
date	2007.05.31.05.07.08;	author pyr;	state Exp;
branches;
next	1.24;

1.24
date	2007.05.31.03.26.36;	author pyr;	state Exp;
branches;
next	1.23;

1.23
date	2007.05.31.03.24.05;	author pyr;	state Exp;
branches;
next	1.22;

1.22
date	2007.05.29.17.12.04;	author reyk;	state Exp;
branches;
next	1.21;

1.21
date	2007.05.28.22.11.33;	author pyr;	state Exp;
branches;
next	1.20;

1.20
date	2007.05.27.20.53.10;	author pyr;	state Exp;
branches;
next	1.19;

1.19
date	2007.05.26.19.58.48;	author pyr;	state Exp;
branches;
next	1.18;

1.18
date	2007.03.07.17.40.32;	author reyk;	state Exp;
branches;
next	1.17;

1.17
date	2007.03.06.19.37.31;	author reyk;	state Exp;
branches;
next	1.16;

1.16
date	2007.02.22.03.32.39;	author reyk;	state Exp;
branches;
next	1.15;

1.15
date	2007.02.07.15.17.46;	author reyk;	state Exp;
branches;
next	1.14;

1.14
date	2007.02.07.14.39.45;	author reyk;	state Exp;
branches;
next	1.13;

1.13
date	2007.02.07.13.39.58;	author reyk;	state Exp;
branches;
next	1.12;

1.12
date	2007.01.29.14.23.31;	author pyr;	state Exp;
branches;
next	1.11;

1.11
date	2007.01.24.10.26.00;	author claudio;	state Exp;
branches;
next	1.10;

1.10
date	2007.01.11.18.05.08;	author reyk;	state Exp;
branches;
next	1.9;

1.9
date	2007.01.09.13.50.11;	author pyr;	state Exp;
branches;
next	1.8;

1.8
date	2007.01.09.00.45.32;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2007.01.08.20.46.18;	author reyk;	state Exp;
branches;
next	1.6;

1.6
date	2007.01.08.16.52.58;	author reyk;	state Exp;
branches;
next	1.5;

1.5
date	2007.01.08.13.37.26;	author reyk;	state Exp;
branches;
next	1.4;

1.4
date	2006.12.25.18.12.14;	author reyk;	state Exp;
branches;
next	1.3;

1.3
date	2006.12.16.17.48.27;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2006.12.16.12.42.14;	author reyk;	state Exp;
branches;
next	1.1;

1.1
date	2006.12.16.11.45.07;	author reyk;	state Exp;
branches;
next	;


desc
@@


1.75
log
@Use the fork+exec privsep model in relayd; based on rzalamena@@'s work
for httpd with some (current and previous) changes for relayd.  Once
again, both daemons now share the same proc.c where most of the
privsep "magic" happens.

OK benno@@ rzalamena@@
@
text
@/*	$OpenBSD: hce.c,v 1.74 2016/09/02 14:45:51 reyk Exp $	*/

/*
 * Copyright (c) 2006 Pierre-Yves Ritschard <pyr@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/queue.h>
#include <sys/time.h>
#include <sys/uio.h>

#include <event.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <imsg.h>

#include "relayd.h"

void	 hce_init(struct privsep *, struct privsep_proc *p, void *);
void	 hce_sig_handler(int sig, short, void *);
void	 hce_launch_checks(int, short, void *);
void	 hce_setup_events(void);
void	 hce_disable_events(void);

int	 hce_dispatch_parent(int, struct privsep_proc *, struct imsg *);
int	 hce_dispatch_pfe(int, struct privsep_proc *, struct imsg *);
int	 hce_dispatch_relay(int, struct privsep_proc *, struct imsg *);

static struct relayd *env = NULL;
int			 running = 0;

static struct privsep_proc procs[] = {
	{ "parent",	PROC_PARENT,	hce_dispatch_parent },
	{ "pfe",	PROC_PFE,	hce_dispatch_pfe },
	{ "relay",	PROC_RELAY,	hce_dispatch_relay },
};

void
hce(struct privsep *ps, struct privsep_proc *p)
{
	env = ps->ps_env;

	/* this is needed for icmp tests */
	icmp_init(env);

	proc_run(ps, p, procs, nitems(procs), hce_init, NULL);
}

void
hce_init(struct privsep *ps, struct privsep_proc *p, void *arg)
{
	if (config_init(ps->ps_env) == -1)
		fatal("failed to initialize configuration");

	env->sc_id = getpid() & 0xffff;

	/* Allow maximum available sockets for TCP checks */
	socket_rlimit(-1);

	if (pledge("stdio recvfd inet", NULL) == -1)
		fatal("hce: pledge");
}

void
hce_setup_events(void)
{
	struct timeval	 tv;
	struct table	*table;

	if (!(TAILQ_EMPTY(env->sc_tables) ||
	    event_initialized(&env->sc_ev))) {
		evtimer_set(&env->sc_ev, hce_launch_checks, env);
		bzero(&tv, sizeof(tv));
		evtimer_add(&env->sc_ev, &tv);
	}

	if (env->sc_conf.flags & F_TLS) {
		TAILQ_FOREACH(table, env->sc_tables, entry) {
			if (!(table->conf.flags & F_TLS) ||
			    table->ssl_ctx != NULL)
				continue;
			table->ssl_ctx = ssl_ctx_create(env);
		}
	}
}

void
hce_disable_events(void)
{
	struct table	*table;
	struct host	*host;

	evtimer_del(&env->sc_ev);
	TAILQ_FOREACH(table, env->sc_tables, entry) {
		TAILQ_FOREACH(host, &table->hosts, entry) {
			host->he = HCE_ABORT;
			if (event_initialized(&host->cte.ev)) {
				event_del(&host->cte.ev);
				close(host->cte.s);
			}
		}
	}
	if (env->sc_has_icmp) {
		event_del(&env->sc_icmp_send.ev);
		event_del(&env->sc_icmp_recv.ev);
	}
	if (env->sc_has_icmp6) {
		event_del(&env->sc_icmp6_send.ev);
		event_del(&env->sc_icmp6_recv.ev);
	}
}

void
hce_launch_checks(int fd, short event, void *arg)
{
	struct host		*host;
	struct table		*table;
	struct timeval		 tv;

	/*
	 * notify pfe checks are done and schedule next check
	 */
	proc_compose(env->sc_ps, PROC_PFE, IMSG_SYNC, NULL, 0);
	TAILQ_FOREACH(table, env->sc_tables, entry) {
		TAILQ_FOREACH(host, &table->hosts, entry) {
			if ((host->flags & F_CHECK_DONE) == 0)
				host->he = HCE_INTERVAL_TIMEOUT;
			host->flags &= ~(F_CHECK_SENT|F_CHECK_DONE);
			if (event_initialized(&host->cte.ev)) {
				event_del(&host->cte.ev);
				close(host->cte.s);
			}
			host->cte.s = -1;
		}
	}

	getmonotime(&tv);

	TAILQ_FOREACH(table, env->sc_tables, entry) {
		if (table->conf.flags & F_DISABLE)
			continue;
		if (table->conf.skip_cnt) {
			if (table->skipped++ > table->conf.skip_cnt)
				table->skipped = 0;
			if (table->skipped != 1)
				continue;
		}
		if (table->conf.check == CHECK_NOCHECK)
			fatalx("hce_launch_checks: unknown check type");

		TAILQ_FOREACH(host, &table->hosts, entry) {
			if (host->flags & F_DISABLE || host->conf.parentid)
				continue;
			bcopy(&tv, &host->cte.tv_start,
			    sizeof(host->cte.tv_start));
			switch (table->conf.check) {
			case CHECK_ICMP:
				schedule_icmp(env, host);
				break;
			case CHECK_SCRIPT:
				check_script(env, host);
				break;
			default:
				/* Any other TCP-style checks */
				host->last_up = host->up;
				host->cte.host = host;
				host->cte.table = table;
				check_tcp(&host->cte);
				break;
			}
		}
	}
	check_icmp(env, &tv);

	bcopy(&env->sc_conf.interval, &tv, sizeof(tv));
	evtimer_add(&env->sc_ev, &tv);
}

void
hce_notify_done(struct host *host, enum host_error he)
{
	struct table		*table;
	struct ctl_status	 st;
	struct timeval		 tv_now, tv_dur;
	u_long			 duration;
	u_int			 logopt;
	struct host		*h, *hostnst;
	int			 hostup;
	const char		*msg;
	char			*codemsg = NULL;

	if ((hostnst = host_find(env, host->conf.id)) == NULL)
		fatalx("hce_notify_done: desynchronized");

	if ((table = table_find(env, host->conf.tableid)) == NULL)
		fatalx("hce_notify_done: invalid table id");

	if (hostnst->flags & F_DISABLE) {
		if (env->sc_conf.opts & RELAYD_OPT_LOGUPDATE) {
			log_info("host %s, check %s%s (ignoring result, "
			    "host disabled)",
			    host->conf.name, table_check(table->conf.check),
			    (table->conf.flags & F_TLS) ? " use tls" : "");
		}
		host->flags |= (F_CHECK_SENT|F_CHECK_DONE);
		return;
	}

	hostup = host->up;
	host->he = he;

	if (host->up == HOST_DOWN && host->retry_cnt) {
		log_debug("%s: host %s retry %d", __func__,
		    host->conf.name, host->retry_cnt);
		host->up = host->last_up;
		host->retry_cnt--;
	} else
		host->retry_cnt = host->conf.retry;
	if (host->up != HOST_UNKNOWN) {
		host->check_cnt++;
		if (host->up == HOST_UP)
			host->up_cnt++;
	}
	st.id = host->conf.id;
	st.up = host->up;
	st.check_cnt = host->check_cnt;
	st.retry_cnt = host->retry_cnt;
	st.he = he;
	host->flags |= (F_CHECK_SENT|F_CHECK_DONE);
	msg = host_error(he);
	if (msg)
		log_debug("%s: %s (%s)", __func__, host->conf.name, msg);

	proc_compose(env->sc_ps, PROC_PFE, IMSG_HOST_STATUS, &st, sizeof(st));
	if (host->up != host->last_up)
		logopt = RELAYD_OPT_LOGUPDATE;
	else
		logopt = RELAYD_OPT_LOGNOTIFY;

	getmonotime(&tv_now);
	timersub(&tv_now, &host->cte.tv_start, &tv_dur);
	if (timercmp(&host->cte.tv_start, &tv_dur, >))
		duration = (tv_dur.tv_sec * 1000) + (tv_dur.tv_usec / 1000.0);
	else
		duration = 0;

	if (env->sc_conf.opts & logopt) {
		if (host->code > 0)
		    asprintf(&codemsg, ",%d", host->code);
		log_info("host %s, check %s%s (%lums,%s%s), state %s -> %s, "
		    "availability %s",
		    host->conf.name, table_check(table->conf.check),
		    (table->conf.flags & F_TLS) ? " use tls" : "", duration,
		    msg, (codemsg != NULL) ? codemsg : "",
		    host_status(host->last_up), host_status(host->up),
		    print_availability(host->check_cnt, host->up_cnt));
		free(codemsg);
	}

	host->last_up = host->up;

	if (SLIST_EMPTY(&host->children))
		return;

	/* Notify for all other hosts that inherit the state from this one */
	SLIST_FOREACH(h, &host->children, child) {
		h->up = hostup;
		hce_notify_done(h, he);
	}
}

int
hce_dispatch_pfe(int fd, struct privsep_proc *p, struct imsg *imsg)
{
	objid_t			 id;
	struct host		*host;
	struct table		*table;

	switch (imsg->hdr.type) {
	case IMSG_HOST_DISABLE:
		memcpy(&id, imsg->data, sizeof(id));
		if ((host = host_find(env, id)) == NULL)
			fatalx("hce_dispatch_pfe: desynchronized");
		host->flags |= F_DISABLE;
		host->up = HOST_UNKNOWN;
		host->check_cnt = 0;
		host->up_cnt = 0;
		host->he = HCE_NONE;
		break;
	case IMSG_HOST_ENABLE:
		memcpy(&id, imsg->data, sizeof(id));
		if ((host = host_find(env, id)) == NULL)
			fatalx("hce_dispatch_pfe: desynchronized");
		host->flags &= ~(F_DISABLE);
		host->up = HOST_UNKNOWN;
		host->he = HCE_NONE;
		break;
	case IMSG_TABLE_DISABLE:
		memcpy(&id, imsg->data, sizeof(id));
		if ((table = table_find(env, id)) == NULL)
			fatalx("hce_dispatch_pfe: desynchronized");
		table->conf.flags |= F_DISABLE;
		TAILQ_FOREACH(host, &table->hosts, entry)
			host->up = HOST_UNKNOWN;
		break;
	case IMSG_TABLE_ENABLE:
		memcpy(&id, imsg->data, sizeof(id));
		if ((table = table_find(env, id)) == NULL)
			fatalx("hce_dispatch_pfe: desynchronized");
		table->conf.flags &= ~(F_DISABLE);
		TAILQ_FOREACH(host, &table->hosts, entry)
			host->up = HOST_UNKNOWN;
		break;
	case IMSG_CTL_POLL:
		evtimer_del(&env->sc_ev);
		TAILQ_FOREACH(table, env->sc_tables, entry)
			table->skipped = 0;
		hce_launch_checks(-1, EV_TIMEOUT, env);
		break;
	default:
		return (-1);
	}

	return (0);
}

int
hce_dispatch_parent(int fd, struct privsep_proc *p, struct imsg *imsg)
{
	struct ctl_script	 scr;

	switch (imsg->hdr.type) {
	case IMSG_SCRIPT:
		IMSG_SIZE_CHECK(imsg, &scr);
		bcopy(imsg->data, &scr, sizeof(scr));
		script_done(env, &scr);
		break;
	case IMSG_CFG_TABLE:
		config_gettable(env, imsg);
		break;
	case IMSG_CFG_HOST:
		config_gethost(env, imsg);
		break;
	case IMSG_CFG_DONE:
		config_getcfg(env, imsg);
		break;
	case IMSG_CTL_START:
		hce_setup_events();
		break;
	case IMSG_CTL_RESET:
		config_getreset(env, imsg);
		break;
	default:
		return (-1);
	}

	return (0);
}

int
hce_dispatch_relay(int fd, struct privsep_proc *p, struct imsg *imsg)
{
	switch (imsg->hdr.type) {
	default:
		break;
	}

	return (-1);
}
@


1.74
log
@Split "struct relayd" into two structs: "struct relayd" and "struct
relayd_config".  This way we can send all the relevant global
configuration to the children, not just the flags and the opts.

With input from and
OK claudio@@ benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hce.c,v 1.73 2016/09/02 11:51:49 reyk Exp $	*/
d73 1
a73 1
	if (pledge("stdio inet", NULL) == -1)
@


1.73
log
@Terminate relayd using the socket status instead of watching SIGCHLD
or killing child processes. - Based on rzalamena@@'s diff for httpd.

OK deraadt@@ rzalamena@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hce.c,v 1.72 2016/01/11 21:31:42 benno Exp $	*/
d90 1
a90 1
	if (env->sc_flags & F_TLS) {
d188 1
a188 1
	bcopy(&env->sc_interval, &tv, sizeof(tv));
d212 1
a212 1
		if (env->sc_opts & RELAYD_OPT_LOGUPDATE) {
d260 1
a260 1
	if (env->sc_opts & logopt) {
@


1.72
log
@This adds the host_error output and the http code (when available) to the
host-check log.
ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hce.c,v 1.71 2015/12/02 13:41:27 reyk Exp $	*/
d51 1
a51 1
pid_t
d59 1
a59 1
	return (proc_run(ps, p, procs, nitems(procs), hce_init, NULL));
@


1.71
log
@In most cases we don't need all arguments of proc_compose*_imsg(),
so add a shortcut proc_compose*() that skips all of them.  Only use the
full argument list if needed.  The functions with full argument lists can
eventually be replaced with a nicer transaction-based approach later.

OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hce.c,v 1.70 2015/11/28 18:10:12 benno Exp $	*/
d203 1
d261 3
a263 1
		log_info("host %s, check %s%s (%lums), state %s -> %s, "
d267 1
d270 1
@


1.70
log
@pledge: allow getsockopt IP_IPDEFTTL with promise inet
then relayd's host check engine can be pledged.
ok reyk@@, approach suggested by deraadt@@ weeks ago.
@
text
@d1 1
a1 1
/*	$OpenBSD: hce.c,v 1.69 2015/01/22 17:42:09 reyk Exp $	*/
d136 1
a136 1
	proc_compose_imsg(env->sc_ps, PROC_PFE, -1, IMSG_SYNC, -1, NULL, 0);
d246 1
a246 2
	proc_compose_imsg(env->sc_ps, PROC_PFE, -1, IMSG_HOST_STATUS,
	    -1, &st, sizeof(st));
@


1.69
log
@Clean up the relayd headers with help of include-what-you-use and some
manual review.  Based on common practice, relayd.h now includes the
necessary headers for itself.

OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hce.c,v 1.68 2015/01/16 15:06:40 deraadt Exp $	*/
d72 3
@


1.68
log
@Adapt to <limits.h> universe.
ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: hce.c,v 1.67 2014/12/12 10:05:09 reyk Exp $	*/
d19 1
d22 1
a22 3
#include <sys/stat.h>
#include <sys/socket.h>
#include <sys/un.h>
a23 5
#include <net/if.h>
#include <netinet/in.h>
#include <netinet/ip.h>

#include <errno.h>
a24 1
#include <fcntl.h>
d28 1
a28 4
#include <err.h>
#include <pwd.h>

#include <openssl/ssl.h>
@


1.67
log
@Change the keyword "ssl" to "tls" to reflect reality since we
effectively disabled support for the SSL protocols.  SSL remains a
common term describing SSL/TLS, there is some controvery about this
change, and the name really doesn't matter, but I feel confident about
it now.

(btw., sthen@@ pointed out some historical context:
http://tim.dierks.org/2014/05/security-standards-and-name-changes-in.html)

OK benno@@, with input from tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hce.c,v 1.66 2014/11/19 10:24:40 blambert Exp $	*/
a18 1
#include <sys/param.h>
@


1.66
log
@Support exporting relayd statistics via AgentX/snmpd

This should be equivalent to the statistics available
via the various relaydctl show commands

okay benno@@ reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hce.c,v 1.65 2014/10/25 03:23:49 lteo Exp $	*/
d98 1
a98 1
	if (env->sc_flags & F_SSL) {
d100 1
a100 1
			if (!(table->conf.flags & F_SSL) ||
d223 1
a223 1
			    (table->conf.flags & F_SSL) ? " use ssl" : "");
d272 1
a272 1
		    (table->conf.flags & F_SSL) ? " use ssl" : "", duration,
@


1.65
log
@Remove unnecessary netinet/in_systm.h include.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hce.c,v 1.64 2013/03/10 23:32:53 reyk Exp $	*/
d51 1
d59 1
a82 2

	snmp_init(env, PROC_PARENT);
a276 3
	if (host->last_up != host->up)
		snmp_hosttrap(env, table, host);

a360 3
	case IMSG_SNMPSOCK:
		snmp_getsock(env, imsg);
		break;
d375 11
@


1.64
log
@This diff changes relayd to use the monotonic clock instead of
gettimeofday().  It was also bugging me for some time to have all
these checks of gettimeofday()'s return value: it should not fail.  So
this diff introduces a void getmonotime(struct timeval *tv) that calls
clock_gettime(CLOCK_MONOTONIC, &ts) and converts the output to a
struct timeval that can be used with the existing code and the
timeval-specific timer functions (timerclear, timersub, ...).  It does
not return a status but calls fatal() on error-that-should-not-happen.

ok sthen@@ chris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hce.c,v 1.63 2012/05/09 12:54:13 giovanni Exp $	*/
a26 1
#include <netinet/in_systm.h>
@


1.63
log
@
Fix a desynchronization on host change during a running check
closes pr system/6627
diff submitted by Martin Matuska, thanks
ok benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hce.c,v 1.62 2012/01/21 13:40:48 camield Exp $	*/
d159 1
a159 2
	if (gettimeofday(&tv, NULL) == -1)
		fatal("hce_launch_checks: gettimeofday");
d262 1
a262 2
	if (gettimeofday(&tv_now, NULL) == -1)
		fatal("hce_notify_done: gettimeofday");
@


1.62
log
@Only start the child processes after all of them reported to have loaded
the config.  Solves a race at startup time where processes can send status
messages about hosts that other processes don't know about yet.
(and have relayd abort with "desynchronized" or "invalid host id")

ok henning pyr deraadt
solves the problem ok from benno todd
@
text
@d1 1
a1 1
/*	$OpenBSD: hce.c,v 1.61 2011/11/12 19:36:17 camield Exp $	*/
d210 1
a210 1
	struct host		*h;
d214 17
a269 3

	if ((table = table_find(env, host->conf.tableid)) == NULL)
		fatalx("hce_notify_done: invalid table id");
@


1.61
log
@fix function names in fatalx() messages

ok mikeb
@
text
@d1 1
a1 1
/*	$OpenBSD: hce.c,v 1.60 2011/05/19 08:56:49 reyk Exp $	*/
d358 2
@


1.60
log
@Fix reload support in relayd(8) by reimplementing large parts of the
daemon infrastructure. The previous design made it fairly hard to
reload the complex data structures, especially relays and protocols.
One of the reasons was that the privsep'd relayd processes had two
ways of getting their configuration: 1) from memory after forking from
the parent process and 2) and (partially) via imsgs after reload.  The
new implementation first forks the privsep'd children before the
parents loads the configuration and sends it via imsgs to them; so it
is only like 2) before.  It is based on an approach that I first
implemented for iked(8) and I also fixed many bugs in the code.

Thanks to many testers including dlg@@ sthen@@ phessler@@
ok pyr@@ dlg@@ sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hce.c,v 1.59 2011/05/09 12:08:47 reyk Exp $	*/
d292 1
a292 1
			fatalx("hce_dispatch_imsg: desynchronized");
d302 1
a302 1
			fatalx("hce_dispatch_imsg: desynchronized");
d310 1
a310 1
			fatalx("hce_dispatch_imsg: desynchronized");
d318 1
a318 1
			fatalx("hce_dispatch_imsg: desynchronized");
@


1.59
log
@Reorganize the relayd code to use the proc.c privsep API/commodity
functions that are based on work for iked and smtpd.  This simplifies
the setup of privsep processes and moves some redundant and repeated
code to a single place - which is always good from a quality and
security point of view.  The relayd version of proc.c is different to
the current version in iked because it uses 1:N communications between
processes, eg. a single parent process is talking to many forked relay
children while iked only needs 1:1 communications.

ok sthen@@ pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hce.c,v 1.58 2011/05/05 12:01:43 reyk Exp $	*/
d75 2
a76 1
	purge_config(env, PURGE_RDRS|PURGE_RELAYS|PURGE_PROTOS);
d83 1
a83 1
	hce_setup_events();
d92 2
a93 3
	snmp_init(env, PROC_PARENT);

	if (!TAILQ_EMPTY(env->sc_tables)) {
a99 1
		ssl_init(env);
d101 2
a102 1
			if (!(table->conf.flags & F_SSL))
d119 4
a122 2
			event_del(&host->cte.ev);
			close(host->cte.s);
d151 5
a155 1
			event_del(&host->cte.ev);
a339 3
	size_t			 len;
	static struct table	*table = NULL;
	struct host		*host, *parent;
d347 2
a348 12
	case IMSG_RECONF:
		IMSG_SIZE_CHECK(imsg, env);
		log_debug("%s: reloading configuration", __func__);
		hce_disable_events();
		purge_config(env, PURGE_TABLES);
		merge_config(env, (struct relayd *)imsg->data);

		env->sc_tables = calloc(1, sizeof(*env->sc_tables));
		if (env->sc_tables == NULL)
			fatal(NULL);

		TAILQ_INIT(env->sc_tables);
d350 2
a351 6
	case IMSG_RECONF_TABLE:
		if ((table = calloc(1, sizeof(*table))) == NULL)
			fatal(NULL);
		memcpy(&table->conf, imsg->data, sizeof(table->conf));
		TAILQ_INIT(&table->hosts);
		TAILQ_INSERT_TAIL(env->sc_tables, table, entry);
d353 2
a354 4
	case IMSG_RECONF_SENDBUF:
		len = imsg->hdr.len - IMSG_HEADER_SIZE;
		table->sendbuf = calloc(1, len);
		(void)strlcpy(table->sendbuf, (char *)imsg->data, len);
d356 3
a358 11
	case IMSG_RECONF_HOST:
		if ((host = calloc(1, sizeof(*host))) == NULL)
			fatal(NULL);
		memcpy(&host->conf, imsg->data, sizeof(host->conf));
		host->tablename = table->conf.name;
		TAILQ_INSERT_TAIL(&table->hosts, host, entry);
		if (host->conf.parentid) {
			parent = host_find(env, host->conf.parentid);
			SLIST_INSERT_HEAD(&parent->children,
			    host, child);
		}
d360 2
a361 3
	case IMSG_RECONF_END:
		log_warnx("%s: configuration reloaded", __func__);
		hce_setup_events();
@


1.58
log
@Update all logging and debug functions to use the __func__ macro
instead of static function names.  __func__ is C99 and perfectly fine
to use. It also avoids printing errors; for example if a statement
log_debug("foo:"..) was moved or copied from function foo() to bar()
and the log message was not updated...
@
text
@d1 1
a1 1
/*	$OpenBSD: hce.c,v 1.57 2011/02/08 08:52:28 sthen Exp $	*/
d44 8
a51 7
__dead void hce_shutdown(void);
void	hce_sig_handler(int sig, short, void *);
void	hce_dispatch_imsg(int, short, void *);
void	hce_dispatch_parent(int, short, void *);
void	hce_launch_checks(int, short, void *);
void	hce_setup_events(void);
void	hce_disable_events(void);
a53 2
struct imsgev		*iev_pfe;
struct imsgev		*iev_main;
d56 4
a59 17
void
hce_sig_handler(int sig, short event, void *arg)
{
	switch (sig) {
	case SIGINT:
	case SIGTERM:
		hce_shutdown();
		break;
	case SIGCHLD:
	case SIGHUP:
	case SIGPIPE:
		/* ignore */
		break;
	default:
		fatalx("hce_sig_handler: unexpected signal");
	}
}
d62 1
a62 3
hce(struct relayd *x_env, int pipe_parent2pfe[2], int pipe_parent2hce[2],
    int pipe_parent2relay[RELAY_MAXPROC][2], int pipe_pfe2hce[2],
    int pipe_pfe2relay[RELAY_MAXPROC][2])
d64 1
a64 30
	pid_t		 pid;
	struct passwd	*pw;
	int		 i;

	switch (pid = fork()) {
	case -1:
		fatal("hce: cannot fork");
	case 0:
		break;
	default:
		return (pid);
	}

	env = x_env;
	purge_config(env, PURGE_RDRS|PURGE_RELAYS|PURGE_PROTOS);

	if ((pw = getpwnam(RELAYD_USER)) == NULL)
		fatal("hce: getpwnam");

#ifndef DEBUG
	if (chroot(pw->pw_dir) == -1)
		fatal("hce: chroot");
	if (chdir("/") == -1)
		fatal("hce: chdir(\"/\")");
#else
#warning disabling privilege revocation and chroot in DEBUG mode
#endif

	setproctitle("host check engine");
	relayd_process = PROC_HCE;
d69 2
a70 6
#ifndef DEBUG
	if (setgroups(1, &pw->pw_gid) ||
	    setresgid(pw->pw_gid, pw->pw_gid, pw->pw_gid) ||
	    setresuid(pw->pw_uid, pw->pw_uid, pw->pw_uid))
		fatal("hce: can't drop privileges");
#endif
d72 6
a77 1
	event_init();
a81 42
	if ((iev_pfe = calloc(1, sizeof(struct imsgev))) == NULL ||
	    (iev_main = calloc(1, sizeof(struct imsgev))) == NULL)
		fatal("hce");
	imsg_init(&iev_pfe->ibuf, pipe_pfe2hce[0]);
	iev_pfe->handler = hce_dispatch_imsg;
	imsg_init(&iev_main->ibuf, pipe_parent2hce[1]);
	iev_main->handler = hce_dispatch_parent;

	iev_pfe->events = EV_READ;
	event_set(&iev_pfe->ev, iev_pfe->ibuf.fd, iev_pfe->events,
	    iev_pfe->handler, iev_pfe);
	event_add(&iev_pfe->ev, NULL);

	iev_main->events = EV_READ;
	event_set(&iev_main->ev, iev_main->ibuf.fd, iev_main->events,
	    iev_main->handler, iev_main);
	event_add(&iev_main->ev, NULL);

	signal_set(&env->sc_evsigint, SIGINT, hce_sig_handler, env);
	signal_set(&env->sc_evsigterm, SIGTERM, hce_sig_handler, env);
	signal_set(&env->sc_evsigchld, SIGCHLD, hce_sig_handler, env);
	signal_set(&env->sc_evsighup, SIGHUP, hce_sig_handler, env);
	signal_set(&env->sc_evsigpipe, SIGPIPE, hce_sig_handler, env);

	signal_add(&env->sc_evsigint, NULL);
	signal_add(&env->sc_evsigterm, NULL);
	signal_add(&env->sc_evsigchld, NULL);
	signal_add(&env->sc_evsighup, NULL);
	signal_add(&env->sc_evsigpipe, NULL);

	/* setup pipes */
	close(pipe_pfe2hce[1]);
	close(pipe_parent2hce[0]);
	close(pipe_parent2pfe[0]);
	close(pipe_parent2pfe[1]);
	for (i = 0; i < env->sc_prefork_relay; i++) {
		close(pipe_parent2relay[i][0]);
		close(pipe_parent2relay[i][1]);
		close(pipe_pfe2relay[i][0]);
		close(pipe_pfe2relay[i][1]);
	}

a82 4
	event_dispatch();
	hce_shutdown();

	return (0);
d91 1
a91 1
	snmp_init(env, iev_main);
d143 1
a143 1
	imsg_compose_event(iev_pfe, IMSG_SYNC, 0, 0, -1, NULL, 0);
d178 1
a178 1
				check_script(host);
d233 2
a234 2
	imsg_compose_event(iev_pfe, IMSG_HOST_STATUS,
	    0, 0, -1, &st, sizeof(st));
d261 1
a261 1
		snmp_hosttrap(table, host);
d275 2
a276 2
void
hce_shutdown(void)
a277 11
	log_info("host check engine exiting");
	_exit(0);
}

void
hce_dispatch_imsg(int fd, short event, void *ptr)
{
	struct imsgev		*iev;
	struct imsgbuf		*ibuf;
	struct imsg		 imsg;
	ssize_t			 n;
a280 1
	int			 verbose;
d282 25
a306 31
	iev = ptr;
	ibuf = &iev->ibuf;

	if (event & EV_READ) {
		if ((n = imsg_read(ibuf)) == -1)
			fatal("hce_dispatch_imsg: imsg_read_error");
		if (n == 0) {
			/* this pipe is dead, so remove the event handler */
			event_del(&iev->ev);
			event_loopexit(NULL);
			return;
		}
	}

	if (event & EV_WRITE) {
		if (msgbuf_write(&ibuf->w) == -1)
			fatal("hce_dispatch_imsg: msgbuf_write");
	}

	for (;;) {
		if ((n = imsg_get(ibuf, &imsg)) == -1)
			fatal("hce_dispatch_imsg: imsg_read error");
		if (n == 0)
			break;

		switch (imsg.hdr.type) {
		case IMSG_HOST_DISABLE:
			memcpy(&id, imsg.data, sizeof(id));
			if ((host = host_find(env, id)) == NULL)
				fatalx("hce_dispatch_imsg: desynchronized");
			host->flags |= F_DISABLE;
d308 7
a314 9
			host->check_cnt = 0;
			host->up_cnt = 0;
			host->he = HCE_NONE;
			break;
		case IMSG_HOST_ENABLE:
			memcpy(&id, imsg.data, sizeof(id));
			if ((host = host_find(env, id)) == NULL)
				fatalx("hce_dispatch_imsg: desynchronized");
			host->flags &= ~(F_DISABLE);
d316 9
a324 34
			host->he = HCE_NONE;
			break;
		case IMSG_TABLE_DISABLE:
			memcpy(&id, imsg.data, sizeof(id));
			if ((table = table_find(env, id)) == NULL)
				fatalx("hce_dispatch_imsg: desynchronized");
			table->conf.flags |= F_DISABLE;
			TAILQ_FOREACH(host, &table->hosts, entry)
				host->up = HOST_UNKNOWN;
			break;
		case IMSG_TABLE_ENABLE:
			memcpy(&id, imsg.data, sizeof(id));
			if ((table = table_find(env, id)) == NULL)
				fatalx("hce_dispatch_imsg: desynchronized");
			table->conf.flags &= ~(F_DISABLE);
			TAILQ_FOREACH(host, &table->hosts, entry)
				host->up = HOST_UNKNOWN;
			break;
		case IMSG_CTL_POLL:
			evtimer_del(&env->sc_ev);
			TAILQ_FOREACH(table, env->sc_tables, entry)
				table->skipped = 0;
			hce_launch_checks(-1, EV_TIMEOUT, env);
			break;
		case IMSG_CTL_LOG_VERBOSE:
			memcpy(&verbose, imsg.data, sizeof(verbose));
			log_verbose(verbose);
			break;
		default:
			log_debug("%s: unexpected imsg %d", __func__,
			    imsg.hdr.type);
			break;
		}
		imsg_free(&imsg);
d326 2
a327 1
	imsg_event_add(iev);
d330 2
a331 2
void
hce_dispatch_parent(int fd, short event, void * ptr)
a332 3
	struct imsgev		*iev;
	struct imsgbuf		*ibuf;
	struct imsg		 imsg;
a333 1
	ssize_t			 n;
d338 16
a353 2
	iev = ptr;
	ibuf = &iev->ibuf;
d355 24
a378 8
	if (event & EV_READ) {
		if ((n = imsg_read(ibuf)) == -1)
			fatal("hce_dispatch_parent: imsg_read error");
		if (n == 0) {
			/* this pipe is dead, so remove the event handler */
			event_del(&iev->ev);
			event_loopexit(NULL);
			return;
d380 7
d389 1
a389 71
	if (event & EV_WRITE) {
		if (msgbuf_write(&ibuf->w) == -1)
			fatal("hce_dispatch_parent: msgbuf_write");
	}

	for (;;) {
		if ((n = imsg_get(ibuf, &imsg)) == -1)
			fatal("hce_dispatch_parent: imsg_read error");
		if (n == 0)
			break;

		switch (imsg.hdr.type) {
		case IMSG_SCRIPT:
			if (imsg.hdr.len - IMSG_HEADER_SIZE !=
			    sizeof(scr))
				fatalx("hce_dispatch_parent: "
				    "invalid size of script request");
			bcopy(imsg.data, &scr, sizeof(scr));
			script_done(env, &scr);
			break;
		case IMSG_RECONF:
			log_debug("%s: reloading configuration", __func__);
			if (imsg.hdr.len !=
			    sizeof(struct relayd) + IMSG_HEADER_SIZE)
				fatalx("corrupted reload data");
			hce_disable_events();
			purge_config(env, PURGE_TABLES);
			merge_config(env, (struct relayd *)imsg.data);

			env->sc_tables = calloc(1, sizeof(*env->sc_tables));
			if (env->sc_tables == NULL)
				fatal(NULL);

			TAILQ_INIT(env->sc_tables);
			break;
		case IMSG_RECONF_TABLE:
			if ((table = calloc(1, sizeof(*table))) == NULL)
				fatal(NULL);
			memcpy(&table->conf, imsg.data, sizeof(table->conf));
			TAILQ_INIT(&table->hosts);
			TAILQ_INSERT_TAIL(env->sc_tables, table, entry);
			break;
		case IMSG_RECONF_SENDBUF:
			len = imsg.hdr.len - IMSG_HEADER_SIZE;
			table->sendbuf = calloc(1, len);
			(void)strlcpy(table->sendbuf, (char *)imsg.data, len);
			break;
		case IMSG_RECONF_HOST:
			if ((host = calloc(1, sizeof(*host))) == NULL)
				fatal(NULL);
			memcpy(&host->conf, imsg.data, sizeof(host->conf));
			host->tablename = table->conf.name;
			TAILQ_INSERT_TAIL(&table->hosts, host, entry);
			if (host->conf.parentid) {
				parent = host_find(env, host->conf.parentid);
				SLIST_INSERT_HEAD(&parent->children,
				    host, child);
			}
			break;
		case IMSG_RECONF_END:
			log_warnx("%s: configuration reloaded", __func__);
			hce_setup_events();
			break;
		default:
			log_debug("%s: unexpected imsg %d", __func__,
			    imsg.hdr.type);
			break;
		}
		imsg_free(&imsg);
	}
	imsg_event_add(iev);
@


1.57
log
@Log the time taken for all types of check, not just tcp checks.
ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hce.c,v 1.56 2010/11/30 14:38:45 reyk Exp $	*/
d302 1
a302 1
		log_debug("hce_notify_done: host %s retry %d",
d321 1
a321 1
		log_debug("hce_notify_done: %s (%s)", host->conf.name, msg);
d455 1
a455 1
			log_debug("hce_dispatch_msg: unexpected imsg %d",
d511 1
a511 1
			log_debug("hce: reloading configuration");
d550 1
a550 1
			log_warnx("hce: configuration reloaded");
d554 1
a554 1
			log_debug("hce_dispatch_parent: unexpected imsg %d",
@


1.56
log
@The relayd processes did already bump up the socket file descriptor
resource limits to the maximum of the daemon class but the host check
process (hce/health checks) didn't and was limited to a fairly low
default of 128 open sockets (openfiles-cur=128 in login.conf). This
was reached fairly quickly with "check tcp" of many hosts. This diff
increases the maximum number of monitored hosts and concurrent health
checks in relayd in a significant way and may fix issues for people
that have around 100 or more hosts (or fewer hosts with multiple checked
ports).

tested by phessler@@
ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hce.c,v 1.55 2010/05/14 11:13:36 reyk Exp $	*/
d261 2
a274 2
				bcopy(&tv, &host->cte.tv_start,
				    sizeof(host->cte.tv_start));
@


1.55
log
@allocate all struct event's on the heap, it looks cleaner, feels better
and follows a suggestion in event.h.  also don't mix signal() and
signal_set()/signal_add().

ok jsg@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hce.c,v 1.54 2010/01/11 06:40:14 jsg Exp $	*/
d122 3
@


1.54
log
@add "log brief" and "log verbose" to change logging verbosity
like several other things in the tree.

ok reyk@@ looks fine claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hce.c,v 1.53 2009/06/05 23:39:51 pyr Exp $	*/
d65 5
a82 2
	struct event	 ev_sigint;
	struct event	 ev_sigterm;
d141 11
a151 6
	signal_set(&ev_sigint, SIGINT, hce_sig_handler, NULL);
	signal_set(&ev_sigterm, SIGTERM, hce_sig_handler, NULL);
	signal_add(&ev_sigint, NULL);
	signal_add(&ev_sigterm, NULL);
	signal(SIGPIPE, SIG_IGN);
	signal(SIGHUP, SIG_IGN);
@


1.53
log
@4 handed diff with eric:
Stop pushing event handling in the imsg framework.
Instead, provide a small glue layer on top of both imsg and libevent.
This finally clearly separates event handling and imsg construction.

Sidetrack bonus: remove the mega-ugly hack of having a dummy imsg_event_add
stub in relayctl.

This will make bgpd (and thus henning) happy. Next up are smtpd and ospfd.

ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hce.c,v 1.52 2009/06/05 00:20:50 pyr Exp $	*/
d371 1
d438 4
@


1.52
log
@some KNF cleanup following the last sed.
@
text
@d1 1
a1 1
/*	$OpenBSD: hce.c,v 1.51 2009/06/05 00:04:01 pyr Exp $	*/
d53 2
a54 2
struct imsgbuf		*ibuf_pfe;
struct imsgbuf		*ibuf_main;
d120 2
a121 2
	if ((ibuf_pfe = calloc(1, sizeof(struct imsgbuf))) == NULL ||
	    (ibuf_main = calloc(1, sizeof(struct imsgbuf))) == NULL)
d123 14
a136 12
	imsg_init(ibuf_pfe, pipe_pfe2hce[0], hce_dispatch_imsg);
	imsg_init(ibuf_main, pipe_parent2hce[1], hce_dispatch_parent);

	ibuf_pfe->events = EV_READ;
	event_set(&ibuf_pfe->ev, ibuf_pfe->fd, ibuf_pfe->events,
	    ibuf_pfe->handler, ibuf_pfe);
	event_add(&ibuf_pfe->ev, NULL);

	ibuf_main->events = EV_READ;
	event_set(&ibuf_main->ev, ibuf_main->fd, ibuf_main->events,
	    ibuf_main->handler, ibuf_main);
	event_add(&ibuf_main->ev, NULL);
d170 1
a170 1
	snmp_init(env, ibuf_main);
d222 1
a222 1
	imsg_compose_event(ibuf_pfe, IMSG_SYNC, 0, 0, -1, NULL, 0);
d312 1
a312 1
	imsg_compose_event(ibuf_pfe, IMSG_HOST_STATUS,
d364 1
d372 2
a373 1
	ibuf = ptr;
d380 1
a380 1
			event_del(&ibuf->ev);
d445 1
a445 1
	imsg_event_add(ibuf);
d451 1
d460 2
a461 1
	ibuf = ptr;
d468 1
a468 1
			event_del(&ibuf->ev);
d544 1
a544 1
	imsg_event_add(ibuf);
@


1.51
log
@Make imsg completely async model agnostic by not requiring an
imsg_event_add function to be provided (which ended up being a named
callback).
Instead provide a wrapper in the daemon and call that everywhere.
Previsously discussed with the usual suspects,
ok eric@@ though not too happy about the function name
(imsg_compose_event).
@
text
@d1 1
a1 1
/*	$OpenBSD: hce.c,v 1.50 2009/06/04 13:46:07 reyk Exp $	*/
d310 2
a311 1
	imsg_compose_event(ibuf_pfe, IMSG_HOST_STATUS, 0, 0, -1, &st, sizeof(st));
@


1.50
log
@Keep around the SSL session for each checked host. This way SSL
caching can kick in on subsequent checks, making them faster and
lighter on the server.

From camield, closes PR 6137 (modified diff)
@
text
@d1 1
a1 1
/*	$OpenBSD: hce.c,v 1.49 2009/06/02 12:24:16 reyk Exp $	*/
d220 1
a220 1
	imsg_compose(ibuf_pfe, IMSG_SYNC, 0, 0, -1, NULL, 0);
d310 1
a310 1
	imsg_compose(ibuf_pfe, IMSG_HOST_STATUS, 0, 0, -1, &st, sizeof(st));
@


1.49
log
@remove extra imsg_event_add() after EV_WRITE checks - this is not
required because it is called later and there is no return before.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hce.c,v 1.48 2009/06/02 11:33:06 reyk Exp $	*/
a256 1
				bzero(&host->cte, sizeof(host->cte));
@


1.48
log
@Libevent may do an upcall with both EV_READ and EV_WRITE set.
So change the code accordingly to allow that.

Found by claudio@@ in ospfd
@
text
@d1 1
a1 1
/*	$OpenBSD: hce.c,v 1.47 2009/04/17 09:47:06 reyk Exp $	*/
a384 2
		imsg_event_add(ibuf);
		return;
a470 2
		imsg_event_add(ibuf);
		return;
@


1.47
log
@keep the parent relations of hosts after reloading the configuration.

From Camiel Dobbelaar, closes PR 6066
@
text
@d1 1
a1 1
/*	$OpenBSD: hce.c,v 1.46 2008/12/05 16:37:55 reyk Exp $	*/
d370 2
a371 2
	switch (event) {
	case EV_READ:
d380 3
a382 2
		break;
	case EV_WRITE:
a386 2
	default:
		fatalx("hce_dispatch_imsg: unknown event");
d458 2
a459 2
	switch (event) {
	case EV_READ:
d468 3
a470 2
		break;
	case EV_WRITE:
a474 2
	default:
		fatalx("hce_dispatch_parent: unknown event");
@


1.46
log
@change the way relayd reports check results: instead of logging an
arbitrary string in debugging mode, it will store an error code
(HCE_*) for each host.  the error code can be translated to a string
(in log.c) for debugging but it will also be passed to relayctl via
the control socket.

from a user point of view, this will print a human-readable error
message in the "relayctl show hosts" output if a host is down because
the check failed.  the relayctl(8) manpage includes detailed
explanations of the error messages including mitigations for the
most-common problems.

ok jmc@@ (manpages)
ok phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hce.c,v 1.45 2008/09/29 15:12:22 reyk Exp $	*/
a454 1

d456 1
a456 1
	struct host		*host;
d527 5
@


1.45
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: hce.c,v 1.44 2008/08/08 08:51:21 thib Exp $	*/
d195 1
d223 2
d275 1
a275 1
hce_notify_done(struct host *host, const char *msg)
d284 1
d287 1
d305 1
d307 1
d348 1
a348 1
		hce_notify_done(h, msg);
d405 1
d413 1
@


1.44
log
@Check gettimeofday() against -1; Add a missing error check in one place.

OK reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hce.c,v 1.43 2008/07/19 11:38:54 reyk Exp $	*/
d340 1
a340 1
		h->up = hostup;		
@


1.43
log
@no need for using a TAILQ queue for the host children list, use a
singly-linked SLIST instead.  the only noticeable change is the
reversed order to notify the children but it does not really matter
here.  also only walk through the children host list if the host
itself is a potential parent.
@
text
@d1 1
a1 1
/*	$OpenBSD: hce.c,v 1.42 2008/07/19 10:52:32 reyk Exp $	*/
d227 1
a227 1
	if (gettimeofday(&tv, NULL))
d310 1
a310 1
	if (gettimeofday(&tv_now, NULL))
@


1.42
log
@If the new 'parent' keyword is specified for a host in a table,
inherit the state from another host with the specified Id; no
additional check will be for the inheriting host.  This helps in
scenarios with lots of IP aliases that all point to the same service
on the same host (like web hosting with many SSL domains).

discussed with pyr, tested in different setups
@
text
@d1 1
a1 1
/*	$OpenBSD: hce.c,v 1.41 2008/03/12 10:50:44 pyr Exp $	*/
d335 1
a335 1
	if (TAILQ_EMPTY(&host->children))
d339 1
a339 1
	TAILQ_FOREACH(h, &host->children, child) {
@


1.41
log
@nuke unused variable.
@
text
@d1 1
a1 1
/*	$OpenBSD: hce.c,v 1.40 2008/02/11 10:42:50 reyk Exp $	*/
d243 1
a243 1
			if (host->flags & F_DISABLE)
d279 4
d334 9
@


1.40
log
@Marry relayd with snmpd using new "send trap" option: Request to send
a SNMP trap when the state of a host changes.  relayd(8) will try to
(re-)connect to snmpd(8) and request it to send a trap to the
registered trap receivers, see snmpd.conf(5) for more information
about the configuration.

ok pyr@@ thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hce.c,v 1.39 2008/01/31 09:33:39 reyk Exp $	*/
a54 2
int			 pipe_pfe;
int			 pipe_parent;
@


1.39
log
@add prefixes to names of structure elements to make it easier to grep
for code, start with struct relayd.  finally.

ok thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hce.c,v 1.38 2007/12/08 20:36:36 pyr Exp $	*/
d170 2
d327 4
@


1.38
log
@Rename everything which reffered to services refer to rdr for internals
(for instance: rename struct service to struct rdr), refer to redirects
otherwise (hoststatectl output).
ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hce.c,v 1.37 2007/12/07 17:17:00 reyk Exp $	*/
d150 1
a150 1
	for (i = 0; i < env->prefork_relay; i++) {
d170 2
a171 2
	if (!TAILQ_EMPTY(env->tables)) {
		evtimer_set(&env->ev, hce_launch_checks, env);
d173 1
a173 1
		evtimer_add(&env->ev, &tv);
d176 1
a176 1
	if (env->flags & F_SSL) {
d178 1
a178 1
		TAILQ_FOREACH(table, env->tables, entry) {
d192 2
a193 2
	evtimer_del(&env->ev);
	TAILQ_FOREACH(table, env->tables, entry) {
d199 7
a205 7
	if (env->has_icmp) {
		event_del(&env->icmp_send.ev);
		event_del(&env->icmp_recv.ev);
	}
	if (env->has_icmp6) {
		event_del(&env->icmp6_send.ev);
		event_del(&env->icmp6_recv.ev);
d220 1
a220 1
	TAILQ_FOREACH(table, env->tables, entry) {
d230 1
a230 1
	TAILQ_FOREACH(table, env->tables, entry) {
d267 2
a268 2
	bcopy(&env->interval, &tv, sizeof(tv));
	evtimer_add(&env->ev, &tv);
d317 1
a317 1
	if (env->opts & logopt) {
d406 2
a407 2
			evtimer_del(&env->ev);
			TAILQ_FOREACH(table, env->tables, entry)
d478 2
a479 2
			env->tables = calloc(1, sizeof(*env->tables));
			if (env->tables == NULL)
d482 1
a482 1
			TAILQ_INIT(env->tables);
d489 1
a489 1
			TAILQ_INSERT_TAIL(env->tables, table, entry);
@


1.37
log
@hoststated gets renamed to relayd.  easier to type, and actually says
what the daemon does - it is a relayer that pays attention to the status
of pools of hosts; not a status checkers that happens to do some relaying
@
text
@d1 1
a1 1
/*	$OpenBSD: hce.c,v 1.36 2007/11/24 17:07:28 reyk Exp $	*/
d93 1
a93 1
	purge_config(env, PURGE_SERVICES|PURGE_RELAYS|PURGE_PROTOS);
@


1.36
log
@sort includes, adjust to style(9)
@
text
@d1 1
a1 1
/*	$OpenBSD: hce.c,v 1.35 2007/11/21 09:54:39 pyr Exp $	*/
d42 1
a42 1
#include "hoststated.h"
d52 1
a52 1
static struct hoststated *env = NULL;
d73 1
a73 1
hce(struct hoststated *x_env, int pipe_parent2pfe[2], int pipe_parent2hce[2],
d95 1
a95 1
	if ((pw = getpwnam(HOSTSTATED_USER)) == NULL)
d108 1
a108 1
	hoststated_process = PROC_HCE;
d302 1
a302 1
		logopt = HOSTSTATED_OPT_LOGUPDATE;
d304 1
a304 1
		logopt = HOSTSTATED_OPT_LOGNOTIFY;
d472 1
a472 1
			    sizeof(struct hoststated) + IMSG_HEADER_SIZE)
d476 1
a476 1
			merge_config(env, (struct hoststated *)imsg.data);
@


1.35
log
@make sure all hosts are checked when hoststatectl poll is issued, now
that check interval can differ from table to table.
ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hce.c,v 1.34 2007/11/20 15:44:21 pyr Exp $	*/
d19 1
a20 2
#include <sys/param.h>
#include <sys/types.h>
d25 2
d30 1
a30 1
#include <net/if.h>
@


1.34
log
@Allow overriding the global interval in a table.
Table specific intervals must be multiples of the global interval.
help and ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hce.c,v 1.33 2007/11/19 15:31:36 reyk Exp $	*/
d406 2
@


1.33
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: hce.c,v 1.32 2007/10/19 12:08:55 pyr Exp $	*/
d232 6
@


1.32
log
@Add the ability to schedule an immediate check through hoststatectl.
Especially useful when interval is rather long.
I was supposed to commit this before 4.2.
@
text
@d1 1
a1 1
/*	$OpenBSD: hce.c,v 1.31 2007/10/12 12:50:59 blambert Exp $	*/
d418 1
a418 1
	ssize_t		 	 n;
@


1.31
log
@Silence some lint(1) warnings

ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hce.c,v 1.30 2007/09/28 13:29:56 pyr Exp $	*/
d397 4
@


1.30
log
@Correct my mail address.
@
text
@d1 1
a1 1
/*	$OpenBSD: hce.c,v 1.29 2007/06/19 13:06:00 pyr Exp $	*/
d43 1
a44 1
void	hce_shutdown(void);
@


1.29
log
@don't go through the effort of creating a SIGHUP handler through
libevent just to ignore it, use SIG_IGN instead.
this syncs hoststated with bgpd and (soon) ospfd.
@
text
@d1 1
a1 1
/*	$OpenBSD: hce.c,v 1.28 2007/06/19 06:29:20 pyr Exp $	*/
d4 1
a4 1
 * Copyright (c) 2006 Pierre-Yves Ritschard <pyr@@spootnik.org>
@


1.28
log
@Do not fatal out with ``pipe closed'' when a short read occurs on one
of our socket pairs. Instead disable listening on the pipe, terminate the
event loop, and let the parent process's SIGCHLD handler do a clean
shutdown.

from an ospfd diff by claudio, ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hce.c,v 1.27 2007/06/12 15:16:10 msf Exp $	*/
a65 3
	case SIGHUP:
		/* nothing */
		break;
a80 1
	struct event	 ev_sighup;
a138 1
	signal_set(&ev_sighup, SIGHUP, hce_sig_handler, NULL);
a140 1
	signal_add(&ev_sighup, NULL);
d142 1
@


1.27
log
@put the fd passing from bgpd back in to hoststated's version of imsg,
needed for layer 7 reload support.

ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hce.c,v 1.26 2007/06/07 07:19:50 pyr Exp $	*/
d348 6
a353 2
		if (n == 0)
			fatalx("hce_dispatch_imsg: pipe closed");
d430 6
a435 2
		if (n == 0)
			fatalx("hce_dispatch_parent: pipe closed");
@


1.26
log
@(finally) Enable reload support for layer 3 configurations.
Hoststated can be reloaded either by sending SIGHUP to the parent process
or by using ``hoststatectl reload''
discussed and ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hce.c,v 1.25 2007/05/31 05:07:08 pyr Exp $	*/
d223 1
a223 1
	imsg_compose(ibuf_pfe, IMSG_SYNC, 0, 0, NULL, 0);
d298 1
a298 1
	imsg_compose(ibuf_pfe, IMSG_HOST_STATUS, 0, 0, &st, sizeof(st));
@


1.25
log
@split event registration between the ones that will be kept intact
at reconfiguration time.
@
text
@d1 1
a1 1
/*	$OpenBSD: hce.c,v 1.25 2007/05/31 05:04:27 pyr Exp $	*/
d67 1
d84 1
d101 1
d106 3
d116 1
d121 1
d143 1
d146 1
d416 4
d452 38
@


1.24
log
@some silly debug code snuck in.
@
text
@d1 1
a1 1
/*	$OpenBSD: hce.c,v 1.23 2007/05/31 03:24:05 pyr Exp $	*/
d48 2
a49 2
void	hce_setup_events(int);
void	hce_start(void);
d81 2
d115 17
a131 2
	pipe_pfe = pipe_pfe2hce[0];
	pipe_parent = pipe_parent2hce[1];
d133 5
a137 1
	hce_setup_events(0);
d151 2
a152 2
	hce_start();

d159 1
a159 43
hce_setup_events(int diefirst)
{
	struct event	 ev_sigint;
	struct event	 ev_sigterm;
	struct timeval	 tv;

	if (diefirst) {

		if (!TAILQ_EMPTY(env->tables)) {
			evtimer_set(&env->ev, hce_launch_checks, env);
			bzero(&tv, sizeof(tv));
			evtimer_add(&env->ev, &tv);
		}

		bzero(&tv, sizeof(tv));
		event_loopexit(&tv);
	}
	event_init();

	signal_set(&ev_sigint, SIGINT, hce_sig_handler, NULL);
	signal_set(&ev_sigterm, SIGTERM, hce_sig_handler, NULL);
	signal_add(&ev_sigint, NULL);
	signal_add(&ev_sigterm, NULL);
	signal(SIGPIPE, SIG_IGN);

	if ((ibuf_pfe = calloc(1, sizeof(struct imsgbuf))) == NULL ||
	    (ibuf_main = calloc(1, sizeof(struct imsgbuf))) == NULL)
		fatal("hce");
	imsg_init(ibuf_pfe, pipe_pfe, hce_dispatch_imsg);
	imsg_init(ibuf_main, pipe_parent, hce_dispatch_parent);
	ibuf_pfe->events = EV_READ;
	event_set(&ibuf_pfe->ev, ibuf_pfe->fd, ibuf_pfe->events,
	    ibuf_pfe->handler, ibuf_pfe);
	event_add(&ibuf_pfe->ev, NULL);

	ibuf_main->events = EV_READ;
	event_set(&ibuf_main->ev, ibuf_main->fd, ibuf_main->events,
	    ibuf_main->handler, ibuf_main);
	event_add(&ibuf_main->ev, NULL);
}

void
hce_start(void)
d178 23
a200 1
	event_dispatch();
@


1.23
log
@allocate table lists and service lists instead of using static structs.
split the code to start the event loop in two functions.
introduce merge_config which will be used later on.
@
text
@d1 1
a1 1
/*	$OpenBSD: hce.c,v 1.22 2007/05/29 17:12:04 reyk Exp $	*/
a208 1
	log_warnx("new check suite");
a222 2
	log_warnx("setting up checks");

a223 1
		log_warnx("setting up %s", table->conf.name);
a229 2
			log_warnx("setting up %s.%s", table->conf.name,
			    host->conf.name);
@


1.22
log
@add a new check method which allows to run external scripts/programs
for custom evaluations.

pyr agrees to put it in now but to do some improvements of the timeout
handling later.
@
text
@d1 1
a1 1
/*	$OpenBSD: hce.c,v 1.21 2007/05/28 22:11:33 pyr Exp $	*/
d48 2
d54 3
d65 3
a79 4
	struct timeval	 tv;
	struct event	 ev_sigint;
	struct event	 ev_sigterm;
	struct table	*table;
d113 2
a114 1
	event_init();
d116 1
a116 5
	signal_set(&ev_sigint, SIGINT, hce_sig_handler, NULL);
	signal_set(&ev_sigterm, SIGTERM, hce_sig_handler, NULL);
	signal_add(&ev_sigint, NULL);
	signal_add(&ev_sigterm, NULL);
	signal(SIGPIPE, SIG_IGN);
d130 33
d166 2
a167 3
	imsg_init(ibuf_pfe, pipe_pfe2hce[0], hce_dispatch_imsg);
	imsg_init(ibuf_main, pipe_parent2hce[1], hce_dispatch_parent);

d177 1
d179 7
a185 1
	if (!TAILQ_EMPTY(&env->tables)) {
d193 1
a193 1
		TAILQ_FOREACH(table, &env->tables, entry) {
a198 1

a199 4

	hce_shutdown();

	return (0);
d209 1
d214 1
a214 1
	TAILQ_FOREACH(table, &env->tables, entry) {
d224 4
a227 1
	TAILQ_FOREACH(table, &env->tables, entry) {
d234 2
a317 1

@


1.21
log
@another small step towards hoststated reloading.
allow purging of parts of the hoststated environment structure.
start using this function now to only keep vital information in
hoststated children processes.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hce.c,v 1.20 2007/05/27 20:53:10 pyr Exp $	*/
d49 1
a49 1
static struct hoststated	*env = NULL;
d197 2
a198 1
			if (table->conf.check == CHECK_ICMP) {
d200 14
a213 1
				continue;
a214 9

			/* Any other TCP-style checks */
			bzero(&host->cte, sizeof(host->cte));
			host->last_up = host->up;
			host->cte.host = host;
			host->cte.table = table;
			bcopy(&tv, &host->cte.tv_start,
			    sizeof(host->cte.tv_start));
			check_tcp(&host->cte);
d367 4
a370 3
	struct imsgbuf	*ibuf;
	struct imsg	 imsg;
	ssize_t		 n;
d396 8
d411 1
@


1.20
log
@Second step towards hoststated reload:
First split out hosts, tables and services into to structs, one that
contains the runtime fields and one (inside the runtime) that contains
mostly static fields that will be sent over the socket during reload.

Also move the demoted field of tables inside the flags field as its
just a boolean.
ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hce.c,v 1.19 2007/05/26 19:58:48 pyr Exp $	*/
d88 1
@


1.19
log
@first steps for implementing reload:
	* make parse_config allocate the hoststated function by itself
	* make as many sockets as necessary to talk to the relay children
	* add send_all for talking to all children
with advise and ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hce.c,v 1.18 2007/03/07 17:40:32 reyk Exp $	*/
d153 1
a153 1
			if (!(table->flags & F_SSL))
d188 1
a188 1
		if (table->flags & F_DISABLE)
d190 1
a190 1
		if (table->check == CHECK_NOCHECK)
d196 1
a196 1
			if (table->check == CHECK_ICMP) {
d228 1
a228 1
		    host->name, host->retry_cnt);
d232 1
a232 1
		host->retry_cnt = host->retry;
d238 1
a238 1
	st.id = host->id;
d244 1
a244 1
		log_debug("hce_notify_done: %s (%s)", host->name, msg);
d260 1
a260 1
	if ((table = table_find(env, host->tableid)) == NULL)
d266 2
a267 2
		    host->name, table_check(table->check),
		    (table->flags & F_SSL) ? " use ssl" : "", duration,
d336 1
a336 1
			table->flags |= F_DISABLE;
d344 1
a344 1
			table->flags &= ~(F_DISABLE);
@


1.18
log
@- fix the hoststatectl host disable/enable commands to work with relay
layer 7 loadbalancing.
- allow to run relays with tables without depending on services
- show hosts and tables assigned to relays in hoststatectl show commands

ok pyr@@ deraadt@@ with some input from mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hce.c,v 1.17 2007/03/06 19:37:31 reyk Exp $	*/
d67 1
a67 1
    int pipe_parent2relay[2], int pipe_pfe2hce[2],
a120 2
	close(pipe_parent2relay[0]);
	close(pipe_parent2relay[1]);
d122 2
@


1.17
log
@fix the health checks when using the retry option
@
text
@d1 1
a1 1
/*	$OpenBSD: hce.c,v 1.16 2007/02/22 03:32:39 reyk Exp $	*/
d144 1
a144 1
	if (!TAILQ_EMPTY(&env->services)) {
@


1.16
log
@Add layer 7 functionality to hoststated used for layer 7
loadbalancing, SSL acceleration, general-purpose TCP relaying, and
transparent proxying.

see hoststated.conf(5) and my upcoming article on undeadly.org for
details.

ok to commit deraadt@@ pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hce.c,v 1.15 2007/02/07 15:17:46 reyk Exp $	*/
a225 1

d229 1
a229 1
		host->up = HOST_UP;
@


1.15
log
@add new "log (updates|all)" configuration option to log state
notifications after completed host checks.  either only log the
"updates" to new states or log "all" state notifications, even if the
state didn't change. the log messages will be reported to syslog or to
stderr if the daemon is running in foreground mode.

ok claudio@@ pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hce.c,v 1.14 2007/02/07 14:39:45 reyk Exp $	*/
d67 2
a68 1
	int pipe_pfe2hce[2])
d76 1
d121 6
d144 5
a148 3
	evtimer_set(&env->ev, hce_launch_checks, env);
	bzero(&tv, sizeof(tv));
	evtimer_add(&env->ev, &tv);
d226 13
d241 2
d247 2
a248 1
	if (host->up != host->last_up) {
d250 1
a250 2
		imsg_compose(ibuf_pfe, IMSG_HOST_STATUS, 0, 0, &st, sizeof(st));
	} else
a252 3
	if ((table = table_find(env, host->tableid)) == NULL)
		fatalx("hce_notify_done: invalid table id");

d261 3
d265 2
a266 1
		log_info("host %s, check %s%s (%lums), state %s -> %s",
d269 2
a270 1
		    host_status(host->last_up), host_status(host->up));
d323 2
d371 1
a371 1
		if (n == 0)	/* connection closed */
@


1.14
log
@remove superfluos log_debug() messages

ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hce.c,v 1.13 2007/02/07 13:39:58 reyk Exp $	*/
d210 1
d212 3
d221 1
d223 1
d225 19
a243 1
		host->last_up = host->up;
d245 2
@


1.13
log
@remove unused functions and variables which have been copied from
ospfd(8) (can be re-imported later if required).
@
text
@d1 1
a1 1
/*	$OpenBSD: hce.c,v 1.12 2007/01/29 14:23:31 pyr Exp $	*/
a161 2

	log_debug("hce_launch_checks: scheduled");
@


1.12
log
@Add SSL support to hoststated.
with help and OK reyk@@
with help and advice by claudio@@ and Srebrenko Sehic
@
text
@d1 1
a1 1
/*	$OpenBSD: hce.c,v 1.11 2007/01/24 10:26:00 claudio Exp $	*/
a47 1
int	hce_checks_done(void);
a206 19
}

int
hce_checks_done()
{
	struct table		*table;
	struct host		*host;

	TAILQ_FOREACH(table, &env->tables, entry) {
		if (table->flags & F_DISABLE)
			continue;
		TAILQ_FOREACH(host, &table->hosts, entry) {
			if (host->flags & F_DISABLE)
				continue;
			if (!(host->flags & F_CHECK_DONE))
				return (0);
		}
	}
	return (1);
@


1.11
log
@Similar to ospfd and ripd ignore SIGPIPE in all processes to be able to do
a nice exit in case one of the processes dies. OK pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hce.c,v 1.10 2007/01/11 18:05:08 reyk Exp $	*/
d39 2
d75 1
d140 9
@


1.10
log
@use real async events for checks and improve the non-blocking socket
usage. also modify the check_icmp code to use non-blocking raw sockets
and merge the icmp4 and icmp6 functions. some other minor changes
while i'm here.

as discussed with pyr@@ claudio@@ deraadt@@
ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hce.c,v 1.9 2007/01/09 13:50:11 pyr Exp $	*/
d110 1
@


1.9
log
@Finish renaming hostated to hoststated.
Note to testers: the user the daemon changes its id to is now _hoststated,
don't forget to update master.passwd.
ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hce.c,v 1.8 2007/01/09 00:45:32 deraadt Exp $	*/
a84 6
	/* this is needed for icmp tests */
	if ((env->icmp_sock = socket(AF_INET, SOCK_RAW, IPPROTO_ICMP)) < 0)
		err(1, "socket");
	if ((env->icmp6_sock = socket(AF_INET6, SOCK_RAW, IPPROTO_ICMPV6)) < 0)
		err(1, "socket");

d96 3
a103 4
	env->cie.icmp_sock = env->icmp_sock;
	env->cie.icmp6_sock = env->icmp6_sock;
	env->cie.env = env;

d133 2
a134 2
	evtimer_set(&env->ev, hce_launch_checks, NULL);
	bcopy(&env->interval, &tv, sizeof(tv));
a136 1
	hce_launch_checks(0, 0, NULL);
d149 17
d172 1
a172 7
		if (table->check == CHECK_ICMP) {
			schedule_icmp(&env->cie, table);
			continue;
		}
		/*
		 * tcp type checks follow
		 */
d176 6
d186 2
a187 2
			if (gettimeofday(&host->cte.tv_start, NULL))
				fatal("hce_launch_checks: gettimeofday");
d191 4
a194 1
	check_icmp(&env->cie);
a219 2
	struct timeval		 tv;
	struct table		*table;
d223 1
a223 1
	host->flags |= F_CHECK_DONE;
d225 1
a225 1
		log_debug("hce_notify_done: %s", msg);
a228 17
	}
	/*
	 * check if everything is done, I see no other way than going
	 * through the tree for every host that calls this function.
	 */
	if (hce_checks_done()) {
		/*
		 * notify pfe checks are done and schedule next check
		 */
		imsg_compose(ibuf_pfe, IMSG_SYNC, 0, 0, NULL, 0);
		TAILQ_FOREACH(table, &env->tables, entry) {
			TAILQ_FOREACH(host, &table->hosts, entry)
				host->flags &= ~F_CHECK_DONE;
		}
		bcopy(&env->interval, &tv, sizeof(tv));
		evtimer_add(&env->ev, &tv);
		bzero(&st, sizeof(st));
@


1.8
log
@adapt to rename
@
text
@d1 1
a1 1
/*	$OpenBSD: hce.c,v 1.7 2007/01/08 20:46:18 reyk Exp $	*/
d48 1
a48 1
static struct hostated	*env = NULL;
d65 1
a65 1
hce(struct hostated *x_env, int pipe_parent2pfe[2], int pipe_parent2hce[2],
d91 1
a91 1
	if ((pw = getpwnam(HOSTATED_USER)) == NULL)
d100 1
a100 1
	hostated_process = PROC_HCE;
@


1.7
log
@do NOT use the regexp interface. it is way to complicated, error-prone
and we don't know about all the possible security problems.

change the check send/expect code to use the fnmatch(3) interface
using shell globbing rules instead. this allows simple patterns like
"220 * ESMTP*" or "SSH-[12].??-*".

suggested by deraadt@@ and otto@@
ok Pierre-Yves Ritschard (pyr at spootnik dot org)
@
text
@d1 1
a1 1
/*	$OpenBSD: hce.c,v 1.6 2007/01/08 16:52:58 reyk Exp $	*/
d39 1
a39 1
#include "hostated.h"
@


1.6
log
@the timeout values are not allowed to exceed the global interval (i
figured this out while testing hostated against a stottering spamd
where the send/expect timeout needs be > 10 seconds). also use another
struct timeval to store the interval for easier handling in the code.

ok Pierre-Yves Ritschard (pyr at spootnik dot org)
@
text
@d1 1
a1 1
/*	$OpenBSD: hce.c,v 1.5 2007/01/08 13:37:26 reyk Exp $	*/
a37 1
#include <regex.h>
@


1.5
log
@add a generic send/expect check using regular expression (see
regex(3)).  this allows to define additional checks for other TCP
protocols.

From Pierre-Yves Ritschard (pyr at spootnik dot org)
@
text
@d1 1
a1 1
/*	$OpenBSD: hce.c,v 1.4 2006/12/25 18:12:14 reyk Exp $	*/
d142 1
a142 2
	tv.tv_sec = env->interval;
	tv.tv_usec = 0;
d234 1
a234 2
		tv.tv_sec = env->interval;
		tv.tv_usec = 0;
@


1.4
log
@partial rewrite of the check_* routines to use libevent everywhere
instead of nested select() calls and to handle the non-blocking
sockets properly.

From Pierre-Yves Ritschard (pyr at spootnik dot org)
(with a little help by me)
@
text
@d1 1
a1 1
/*	$OpenBSD: hce.c,v 1.3 2006/12/16 17:48:27 deraadt Exp $	*/
d38 1
@


1.3
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: hce.c,v 1.2 2006/12/16 12:42:14 reyk Exp $	*/
d46 1
d48 1
a48 1
static struct hostated		*env = NULL;
d107 4
a155 1
	int			 previous_up;
a157 2
	struct ctl_status	 st;
	struct timeval		 tv;
d159 33
a191 4
	tv.tv_sec = env->interval;
	tv.tv_usec = 0;
	evtimer_add(&env->ev, &tv);
	bzero(&st, sizeof(st));
d198 35
a232 25
			previous_up = host->up;
			switch (table->check) {
			case CHECK_ICMP:
				host->up = check_icmp(host, env->icmp_sock,
				    env->icmp6_sock, table->timeout);
				break;
			case CHECK_TCP:
				host->up = check_tcp(host, table);
				break;
			case CHECK_HTTP_CODE:
				host->up = check_http_code(host, table);
				break;
			case CHECK_HTTP_DIGEST:
				host->up = check_http_digest(host, table);
				break;
			default:
				fatalx("hce_launch_checks: unknown check type");
				break;
			}
			if (host->up != previous_up) {
				st.id = host->id;
				st.up = host->up;
				imsg_compose(ibuf_pfe, IMSG_HOST_STATUS, 0, 0,
				    &st, sizeof(st));
			}
d234 4
a238 2
	/* tell pfe we're finished */
	imsg_compose(ibuf_pfe, IMSG_SYNC, 0, 0, NULL, 0);
@


1.2
log
@knf, spacing

please note that some editors will replace tabs with multiple spaces
if you cut & paste code from other sections.  please try to keep the
tabs ;).
@
text
@d1 1
a1 1
/*	$OpenBSD: hce.c,v 1.1 2006/12/16 11:45:07 reyk Exp $	*/
d271 1
a271 1
				imsg.hdr.type);
d291 1
a291 1
		if (n == 0)     /* connection closed */
@


1.1
log
@Import hostated, the host status daemon.  This daemon will monitor
remote hosts and dynamically alter pf(4) tables and redirection rules
for active server load balancing.  The daemon has been written by
Pierre-Yves Ritschard (pyr at spootnik.org) and was formerly known as
"slbd".

The daemon is fully functional but it still needs some work and
cleanup so we don't link it to the build yet.  Some TODOs are a
partial rewrite of the check_* routines (use libevent whenever we
can), improvement of the manpages, and general knf and cleanup.

ok deraadt@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d101 4
a104 4
        if (setgroups(1, &pw->pw_gid) ||
            setresgid(pw->pw_gid, pw->pw_gid, pw->pw_gid) ||
            setresuid(pw->pw_uid, pw->pw_uid, pw->pw_uid))
                fatal("hce: can't drop privileges");
d108 26
a133 26
        signal_set(&ev_sigint, SIGINT, hce_sig_handler, NULL);
        signal_set(&ev_sigterm, SIGTERM, hce_sig_handler, NULL);
        signal_add(&ev_sigint, NULL);                           
        signal_add(&ev_sigterm, NULL);

        /* setup pipes */
        close(pipe_pfe2hce[1]);
        close(pipe_parent2hce[0]);    
        close(pipe_parent2pfe[0]);
        close(pipe_parent2pfe[1]);

        if ((ibuf_pfe = calloc(1, sizeof(struct imsgbuf))) == NULL ||
            (ibuf_main = calloc(1, sizeof(struct imsgbuf))) == NULL)
                fatal("hce");
        imsg_init(ibuf_pfe, pipe_pfe2hce[0], hce_dispatch_imsg); 
        imsg_init(ibuf_main, pipe_parent2hce[1], hce_dispatch_parent);          
                                                                     
        ibuf_pfe->events = EV_READ;                                  
        event_set(&ibuf_pfe->ev, ibuf_pfe->fd, ibuf_pfe->events,
                ibuf_pfe->handler, ibuf_pfe);
        event_add(&ibuf_pfe->ev, NULL);

        ibuf_main->events = EV_READ;
        event_set(&ibuf_main->ev, ibuf_main->fd, ibuf_main->events,
                ibuf_main->handler, ibuf_main);
        event_add(&ibuf_main->ev, NULL);
d135 1
a135 1
        evtimer_set(&env->ev, hce_launch_checks, NULL);
d139 1
a139 1
                                                 
d152 2
a153 2
	struct host 		*host;
	struct table 		*table;
d171 1
a171 2
						      env->icmp6_sock,
						      table->timeout);
d190 1
a190 1
					     &st, sizeof(st));
d282 3
a284 3
	struct imsgbuf          *ibuf;
        struct imsg              imsg;
        ssize_t                  n;
d288 13
a300 13
        case EV_READ:
                if ((n = imsg_read(ibuf)) == -1)
                        fatal("hce_dispatch_parent: imsg_read error");
                if (n == 0)     /* connection closed */
                        fatalx("hce_dispatch_parent: pipe closed");
                break;
        case EV_WRITE:
                if (msgbuf_write(&ibuf->w) == -1)
                        fatal("hce_dispatch_parent: msgbuf_write");
                imsg_event_add(ibuf);
                return;
        default:
                fatalx("hce_dispatch_parent: unknown event");
d303 14
a316 14
        for (;;) {
                if ((n = imsg_get(ibuf, &imsg)) == -1)
                        fatal("hce_dispatch_parent: imsg_read error");
                if (n == 0)
                        break;

                switch (imsg.hdr.type) {
                default:
                        log_debug("hce_dispatch_parent: unexpected imsg %d", 
                                imsg.hdr.type);
                        break;
                }
                imsg_free(&imsg);
        }
@

