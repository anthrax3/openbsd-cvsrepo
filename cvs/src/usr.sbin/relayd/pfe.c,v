head	1.89;
access;
symbols
	OPENBSD_6_2_BASE:1.89
	OPENBSD_6_1:1.88.0.4
	OPENBSD_6_1_BASE:1.88
	OPENBSD_6_0:1.83.0.4
	OPENBSD_6_0_BASE:1.83
	OPENBSD_5_9:1.83.0.2
	OPENBSD_5_9_BASE:1.83
	OPENBSD_5_8:1.80.0.4
	OPENBSD_5_8_BASE:1.80
	OPENBSD_5_7:1.79.0.2
	OPENBSD_5_7_BASE:1.79
	OPENBSD_5_6:1.75.0.4
	OPENBSD_5_6_BASE:1.75
	OPENBSD_5_5:1.74.0.6
	OPENBSD_5_5_BASE:1.74
	OPENBSD_5_4:1.74.0.2
	OPENBSD_5_4_BASE:1.74
	OPENBSD_5_3:1.73.0.2
	OPENBSD_5_3_BASE:1.73
	OPENBSD_5_2:1.72.0.4
	OPENBSD_5_2_BASE:1.72
	OPENBSD_5_1_BASE:1.72
	OPENBSD_5_1:1.72.0.2
	OPENBSD_5_0:1.70.0.2
	OPENBSD_5_0_BASE:1.70
	OPENBSD_4_9:1.66.0.2
	OPENBSD_4_9_BASE:1.66
	OPENBSD_4_8:1.65.0.2
	OPENBSD_4_8_BASE:1.65
	OPENBSD_4_7:1.63.0.2
	OPENBSD_4_7_BASE:1.63
	OPENBSD_4_6:1.60.0.4
	OPENBSD_4_6_BASE:1.60
	OPENBSD_4_5:1.53.0.2
	OPENBSD_4_5_BASE:1.53
	OPENBSD_4_4:1.50.0.2
	OPENBSD_4_4_BASE:1.50
	OPENBSD_4_3:1.48.0.2
	OPENBSD_4_3_BASE:1.48;
locks; strict;
comment	@ * @;


1.89
date	2017.05.28.10.39.15;	author benno;	state Exp;
branches;
next	1.88;
commitid	IW4LnWyG3CPq6c3r;

1.88
date	2017.01.24.10.49.14;	author benno;	state Exp;
branches;
next	1.87;
commitid	OlGQrXFnE2t7dYTy;

1.87
date	2016.09.02.16.14.09;	author reyk;	state Exp;
branches;
next	1.86;
commitid	PZw2w24xmNM2vbc7;

1.86
date	2016.09.02.14.45.51;	author reyk;	state Exp;
branches;
next	1.85;
commitid	vcV98N2DyJGMwDyQ;

1.85
date	2016.09.02.12.12.51;	author reyk;	state Exp;
branches;
next	1.84;
commitid	tCJ77FP0n8bVYrYP;

1.84
date	2016.09.02.11.51.49;	author reyk;	state Exp;
branches;
next	1.83;
commitid	Scmkna4JViHMcK3U;

1.83
date	2015.12.03.16.12.16;	author benno;	state Exp;
branches;
next	1.82;
commitid	leBnL9FijNMS7Wks;

1.82
date	2015.12.02.13.41.27;	author reyk;	state Exp;
branches;
next	1.81;
commitid	vBNcEM4jmO1KceIa;

1.81
date	2015.11.29.01.20.33;	author benno;	state Exp;
branches;
next	1.80;
commitid	u0wLjk4LODsT22tz;

1.80
date	2015.04.21.01.46.57;	author jsg;	state Exp;
branches;
next	1.79;
commitid	o6PoiJpOC6YSUEMK;

1.79
date	2015.02.08.01.39.06;	author blambert;	state Exp;
branches
	1.79.2.1;
next	1.78;
commitid	sWbl2LMC3o62qjTw;

1.78
date	2015.01.22.17.42.09;	author reyk;	state Exp;
branches;
next	1.77;
commitid	puppem00jmzmdm4f;

1.77
date	2015.01.16.15.06.40;	author deraadt;	state Exp;
branches;
next	1.76;
commitid	tOv8XK6tLyhEfayc;

1.76
date	2014.11.19.10.24.40;	author blambert;	state Exp;
branches;
next	1.75;
commitid	EGrSQMGI27r3h8Vf;

1.75
date	2014.07.09.16.42.05;	author reyk;	state Exp;
branches;
next	1.74;
commitid	YhQvyAop4vC3AmzJ;

1.74
date	2013.03.10.23.32.53;	author reyk;	state Exp;
branches;
next	1.73;

1.73
date	2012.10.03.08.33.31;	author reyk;	state Exp;
branches;
next	1.72;

1.72
date	2012.01.21.13.40.48;	author camield;	state Exp;
branches;
next	1.71;

1.71
date	2011.11.12.19.36.17;	author camield;	state Exp;
branches;
next	1.70;

1.70
date	2011.05.20.09.43.53;	author reyk;	state Exp;
branches;
next	1.69;

1.69
date	2011.05.19.08.56.49;	author reyk;	state Exp;
branches;
next	1.68;

1.68
date	2011.05.09.12.08.47;	author reyk;	state Exp;
branches;
next	1.67;

1.67
date	2011.05.05.12.01.43;	author reyk;	state Exp;
branches;
next	1.66;

1.66
date	2010.11.16.15.31.01;	author jsg;	state Exp;
branches;
next	1.65;

1.65
date	2010.08.01.22.18.35;	author sthen;	state Exp;
branches;
next	1.64;

1.64
date	2010.05.14.11.13.36;	author reyk;	state Exp;
branches;
next	1.63;

1.63
date	2009.08.17.11.36.01;	author reyk;	state Exp;
branches;
next	1.62;

1.62
date	2009.08.13.13.51.21;	author reyk;	state Exp;
branches;
next	1.61;

1.61
date	2009.08.07.11.21.53;	author reyk;	state Exp;
branches;
next	1.60;

1.60
date	2009.06.05.23.39.51;	author pyr;	state Exp;
branches;
next	1.59;

1.59
date	2009.06.05.00.20.50;	author pyr;	state Exp;
branches;
next	1.58;

1.58
date	2009.06.05.00.04.01;	author pyr;	state Exp;
branches;
next	1.57;

1.57
date	2009.06.02.12.24.16;	author reyk;	state Exp;
branches;
next	1.56;

1.56
date	2009.06.02.11.33.06;	author reyk;	state Exp;
branches;
next	1.55;

1.55
date	2009.04.17.09.47.06;	author reyk;	state Exp;
branches;
next	1.54;

1.54
date	2009.04.01.15.05.06;	author reyk;	state Exp;
branches;
next	1.53;

1.53
date	2008.12.05.16.37.55;	author reyk;	state Exp;
branches;
next	1.52;

1.52
date	2008.09.03.13.41.49;	author jsg;	state Exp;
branches;
next	1.51;

1.51
date	2008.08.08.08.51.21;	author thib;	state Exp;
branches;
next	1.50;

1.50
date	2008.07.19.11.38.54;	author reyk;	state Exp;
branches;
next	1.49;

1.49
date	2008.07.19.10.52.32;	author reyk;	state Exp;
branches;
next	1.48;

1.48
date	2008.01.31.09.56.28;	author reyk;	state Exp;
branches;
next	1.47;

1.47
date	2008.01.31.09.33.39;	author reyk;	state Exp;
branches;
next	1.46;

1.46
date	2007.12.20.20.15.43;	author reyk;	state Exp;
branches;
next	1.45;

1.45
date	2007.12.08.20.36.36;	author pyr;	state Exp;
branches;
next	1.44;

1.44
date	2007.12.07.17.17.00;	author reyk;	state Exp;
branches;
next	1.43;

1.43
date	2007.11.24.17.07.28;	author reyk;	state Exp;
branches;
next	1.42;

1.42
date	2007.11.19.15.31.36;	author reyk;	state Exp;
branches;
next	1.41;

1.41
date	2007.11.15.17.02.01;	author pyr;	state Exp;
branches;
next	1.40;

1.40
date	2007.11.14.15.25.26;	author pyr;	state Exp;
branches;
next	1.39;

1.39
date	2007.10.30.21.04.45;	author reyk;	state Exp;
branches;
next	1.38;

1.38
date	2007.10.19.14.15.14;	author pyr;	state Exp;
branches;
next	1.37;

1.37
date	2007.10.19.12.08.55;	author pyr;	state Exp;
branches;
next	1.36;

1.36
date	2007.09.28.13.29.56;	author pyr;	state Exp;
branches;
next	1.35;

1.35
date	2007.09.27.07.32.50;	author pyr;	state Exp;
branches;
next	1.34;

1.34
date	2007.09.07.08.20.24;	author reyk;	state Exp;
branches;
next	1.33;

1.33
date	2007.06.19.13.06.00;	author pyr;	state Exp;
branches;
next	1.32;

1.32
date	2007.06.19.06.29.20;	author pyr;	state Exp;
branches;
next	1.31;

1.31
date	2007.06.12.15.16.10;	author msf;	state Exp;
branches;
next	1.30;

1.30
date	2007.06.07.07.19.50;	author pyr;	state Exp;
branches;
next	1.29;

1.29
date	2007.05.31.18.24.02;	author pyr;	state Exp;
branches;
next	1.28;

1.28
date	2007.05.31.15.49.26;	author pyr;	state Exp;
branches;
next	1.27;

1.27
date	2007.05.31.03.24.05;	author pyr;	state Exp;
branches;
next	1.26;

1.26
date	2007.05.29.23.42.15;	author pyr;	state Exp;
branches;
next	1.25;

1.25
date	2007.05.29.23.19.18;	author pyr;	state Exp;
branches;
next	1.24;

1.24
date	2007.05.28.22.11.33;	author pyr;	state Exp;
branches;
next	1.23;

1.23
date	2007.05.27.20.53.10;	author pyr;	state Exp;
branches;
next	1.22;

1.22
date	2007.05.26.19.58.49;	author pyr;	state Exp;
branches;
next	1.21;

1.21
date	2007.05.09.13.05.42;	author pyr;	state Exp;
branches;
next	1.20;

1.20
date	2007.03.17.22.46.41;	author reyk;	state Exp;
branches;
next	1.19;

1.19
date	2007.03.07.17.40.32;	author reyk;	state Exp;
branches;
next	1.18;

1.18
date	2007.02.26.16.10.24;	author reyk;	state Exp;
branches;
next	1.17;

1.17
date	2007.02.23.00.28.06;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2007.02.22.05.58.06;	author reyk;	state Exp;
branches;
next	1.15;

1.15
date	2007.02.22.03.32.39;	author reyk;	state Exp;
branches;
next	1.14;

1.14
date	2007.02.08.13.32.24;	author reyk;	state Exp;
branches;
next	1.13;

1.13
date	2007.02.06.11.21.35;	author pyr;	state Exp;
branches;
next	1.12;

1.12
date	2007.02.06.08.46.31;	author pyr;	state Exp;
branches;
next	1.11;

1.11
date	2007.02.06.08.45.46;	author pyr;	state Exp;
branches;
next	1.10;

1.10
date	2007.02.01.20.03.39;	author pyr;	state Exp;
branches;
next	1.9;

1.9
date	2007.01.29.14.23.31;	author pyr;	state Exp;
branches;
next	1.8;

1.8
date	2007.01.24.10.26.00;	author claudio;	state Exp;
branches;
next	1.7;

1.7
date	2007.01.09.13.50.11;	author pyr;	state Exp;
branches;
next	1.6;

1.6
date	2007.01.09.00.45.32;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2007.01.08.20.46.18;	author reyk;	state Exp;
branches;
next	1.4;

1.4
date	2007.01.08.13.37.26;	author reyk;	state Exp;
branches;
next	1.3;

1.3
date	2006.12.16.18.50.33;	author reyk;	state Exp;
branches;
next	1.2;

1.2
date	2006.12.16.12.42.14;	author reyk;	state Exp;
branches;
next	1.1;

1.1
date	2006.12.16.11.45.07;	author reyk;	state Exp;
branches;
next	;

1.79.2.1
date	2015.09.20.11.20.16;	author benno;	state Exp;
branches;
next	;
commitid	C9WQyjgbN7h0ioOp;


desc
@@


1.89
log
@use __func__ in log messages. fix some whitespace while here.
From Hiltjo Posthuma hiltjo -AT codemadness -DOT- org, thanks!
ok florian, claudio
@
text
@/*	$OpenBSD: pfe.c,v 1.88 2017/01/24 10:49:14 benno Exp $	*/

/*
 * Copyright (c) 2006 Pierre-Yves Ritschard <pyr@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/queue.h>
#include <sys/socket.h>
#include <sys/time.h>
#include <sys/uio.h>
#include <sys/ioctl.h>
#include <net/if.h>
#include <net/pfvar.h>

#include <event.h>
#include <fcntl.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <imsg.h>

#include "relayd.h"

void	 pfe_init(struct privsep *, struct privsep_proc *p, void *);
void	 pfe_shutdown(void);
void	 pfe_setup_events(void);
void	 pfe_disable_events(void);
void	 pfe_sync(void);
void	 pfe_statistics(int, short, void *);

int	 pfe_dispatch_parent(int, struct privsep_proc *, struct imsg *);
int	 pfe_dispatch_hce(int, struct privsep_proc *, struct imsg *);
int	 pfe_dispatch_relay(int, struct privsep_proc *, struct imsg *);

static struct relayd		*env = NULL;

static struct privsep_proc procs[] = {
	{ "parent",	PROC_PARENT,	pfe_dispatch_parent },
	{ "relay",	PROC_RELAY,	pfe_dispatch_relay },
	{ "hce",	PROC_HCE,	pfe_dispatch_hce }
};

void
pfe(struct privsep *ps, struct privsep_proc *p)
{
	int			s;
	struct pf_status	status;

	env = ps->ps_env;

	if ((s = open(PF_SOCKET, O_RDWR)) == -1) {
		fatal("%s: cannot open pf socket", __func__);
	}
	if (env->sc_pf == NULL) {
		if ((env->sc_pf = calloc(1, sizeof(*(env->sc_pf)))) == NULL)
			fatal("calloc");
		env->sc_pf->dev = s;
	}
	if (ioctl(env->sc_pf->dev, DIOCGETSTATUS, &status) == -1)
		fatal("%s: DIOCGETSTATUS", __func__);
	if (!status.running)
		fatalx("%s: pf is disabled", __func__);
	log_debug("%s: filter init done", __func__);

	proc_run(ps, p, procs, nitems(procs), pfe_init, NULL);
}

void
pfe_init(struct privsep *ps, struct privsep_proc *p, void *arg)
{
	if (config_init(ps->ps_env) == -1)
		fatal("failed to initialize configuration");

	if (pledge("stdio recvfd unix pf", NULL) == -1)
		fatal("pledge");

	p->p_shutdown = pfe_shutdown;
}

void
pfe_shutdown(void)
{
	flush_rulesets(env);
	config_purge(env, CONFIG_ALL);
}

void
pfe_setup_events(void)
{
	struct timeval	 tv;

	/* Schedule statistics timer */
	if (!event_initialized(&env->sc_statev)) {
		evtimer_set(&env->sc_statev, pfe_statistics, NULL);
		bcopy(&env->sc_conf.statinterval, &tv, sizeof(tv));
		evtimer_add(&env->sc_statev, &tv);
	}
}

void
pfe_disable_events(void)
{
	event_del(&env->sc_statev);
}

int
pfe_dispatch_hce(int fd, struct privsep_proc *p, struct imsg *imsg)
{
	struct host		*host;
	struct table		*table;
	struct ctl_status	 st;

	control_imsg_forward(p->p_ps, imsg);

	switch (imsg->hdr.type) {
	case IMSG_HOST_STATUS:
		IMSG_SIZE_CHECK(imsg, &st);
		memcpy(&st, imsg->data, sizeof(st));
		if ((host = host_find(env, st.id)) == NULL)
			fatalx("%s: invalid host id", __func__);
		host->he = st.he;
		if (host->flags & F_DISABLE)
			break;
		host->retry_cnt = st.retry_cnt;
		if (st.up != HOST_UNKNOWN) {
			host->check_cnt++;
			if (st.up == HOST_UP)
				host->up_cnt++;
		}
		if (host->check_cnt != st.check_cnt) {
			log_debug("%s: host %d => %d", __func__,
			    host->conf.id, host->up);
			fatalx("%s: desynchronized", __func__);
		}

		if (host->up == st.up)
			break;

		/* Forward to relay engine(s) */
		proc_compose(env->sc_ps, PROC_RELAY,
		    IMSG_HOST_STATUS, &st, sizeof(st));

		if ((table = table_find(env, host->conf.tableid))
		    == NULL)
			fatalx("%s: invalid table id", __func__);

		log_debug("%s: state %d for host %u %s", __func__,
		    st.up, host->conf.id, host->conf.name);

		snmp_hosttrap(env, table, host);

		/*
		 * Do not change the table state when the host
		 * state switches between UNKNOWN and DOWN.
		 */
		if (HOST_ISUP(st.up)) {
			table->conf.flags |= F_CHANGED;
			table->up++;
			host->flags |= F_ADD;
			host->flags &= ~(F_DEL);
		} else if (HOST_ISUP(host->up)) {
			table->up--;
			table->conf.flags |= F_CHANGED;
			host->flags |= F_DEL;
			host->flags &= ~(F_ADD);
			host->up = st.up;
			pfe_sync();
		}

		host->up = st.up;
		break;
	case IMSG_SYNC:
		pfe_sync();
		break;
	default:
		return (-1);
	}

	return (0);
}

int
pfe_dispatch_parent(int fd, struct privsep_proc *p, struct imsg *imsg)
{
	switch (imsg->hdr.type) {
	case IMSG_CFG_TABLE:
		config_gettable(env, imsg);
		break;
	case IMSG_CFG_HOST:
		config_gethost(env, imsg);
		break;
	case IMSG_CFG_RDR:
		config_getrdr(env, imsg);
		break;
	case IMSG_CFG_VIRT:
		config_getvirt(env, imsg);
		break;
	case IMSG_CFG_ROUTER:
		config_getrt(env, imsg);
		break;
	case IMSG_CFG_ROUTE:
		config_getroute(env, imsg);
		break;
	case IMSG_CFG_PROTO:
		config_getproto(env, imsg);
		break;
	case IMSG_CFG_RELAY:
		config_getrelay(env, imsg);
		break;
	case IMSG_CFG_RELAY_TABLE:
		config_getrelaytable(env, imsg);
		break;
	case IMSG_CFG_DONE:
		config_getcfg(env, imsg);
		init_tables(env);
		snmp_init(env, PROC_PARENT);
		break;
	case IMSG_CTL_START:
		pfe_setup_events();
		pfe_sync();
		break;
	case IMSG_CTL_RESET:
		config_getreset(env, imsg);
		break;
	case IMSG_SNMPSOCK:
		snmp_getsock(env, imsg);
		break;
	default:
		return (-1);
	}

	return (0);
}

int
pfe_dispatch_relay(int fd, struct privsep_proc *p, struct imsg *imsg)
{
	struct ctl_natlook	 cnl;
	struct ctl_stats	 crs;
	struct relay		*rlay;
	struct ctl_conn		*c;
	struct rsession		 con, *s, *t;
	int			 cid;
	objid_t			 sid;

	switch (imsg->hdr.type) {
	case IMSG_NATLOOK:
		IMSG_SIZE_CHECK(imsg, &cnl);
		bcopy(imsg->data, &cnl, sizeof(cnl));
		if (cnl.proc > env->sc_conf.prefork_relay)
			fatalx("%s: invalid relay proc", __func__);
		if (natlook(env, &cnl) != 0)
			cnl.in = -1;
		proc_compose_imsg(env->sc_ps, PROC_RELAY, cnl.proc,
		    IMSG_NATLOOK, -1, -1, &cnl, sizeof(cnl));
		break;
	case IMSG_STATISTICS:
		IMSG_SIZE_CHECK(imsg, &crs);
		bcopy(imsg->data, &crs, sizeof(crs));
		if (crs.proc > env->sc_conf.prefork_relay)
			fatalx("%s: invalid relay proc", __func__);
		if ((rlay = relay_find(env, crs.id)) == NULL)
			fatalx("%s: invalid relay id", __func__);
		bcopy(&crs, &rlay->rl_stats[crs.proc], sizeof(crs));
		rlay->rl_stats[crs.proc].interval =
		    env->sc_conf.statinterval.tv_sec;
		break;
	case IMSG_CTL_SESSION:
		IMSG_SIZE_CHECK(imsg, &con);
		memcpy(&con, imsg->data, sizeof(con));
		if ((c = control_connbyfd(con.se_cid)) == NULL) {
			log_debug("%s: control connection %d not found",
			    __func__, con.se_cid);
			return (0);
		}
		imsg_compose_event(&c->iev,
		    IMSG_CTL_SESSION, 0, 0, -1,
		    &con, sizeof(con));
		break;
	case IMSG_CTL_END:
		IMSG_SIZE_CHECK(imsg, &cid);
		memcpy(&cid, imsg->data, sizeof(cid));
		if ((c = control_connbyfd(cid)) == NULL) {
			log_debug("%s: control connection %d not found",
			    __func__, cid);
			return (0);
		}
		if (c->waiting == 0) {
			log_debug("%s: no pending control requests", __func__);
			return (0);
		} else if (--c->waiting == 0) {
			/* Last ack for a previous request */
			imsg_compose_event(&c->iev, IMSG_CTL_END,
			    0, 0, -1, NULL, 0);
		}
		break;
	case IMSG_SESS_PUBLISH:
		IMSG_SIZE_CHECK(imsg, s);
		if ((s = calloc(1, sizeof(*s))) == NULL)
			return (0);		/* XXX */
		memcpy(s, imsg->data, sizeof(*s));
		TAILQ_FOREACH(t, &env->sc_sessions, se_entry) {
			/* duplicate registration */
			if (t->se_id == s->se_id) {
				free(s);
				return (0);
			}
			if (t->se_id > s->se_id)
				break;
		}
		if (t)
			TAILQ_INSERT_BEFORE(t, s, se_entry);
		else
			TAILQ_INSERT_TAIL(&env->sc_sessions, s, se_entry);
		break;
	case IMSG_SESS_UNPUBLISH:
		IMSG_SIZE_CHECK(imsg, &sid);
		memcpy(&sid, imsg->data, sizeof(sid));
		TAILQ_FOREACH(s, &env->sc_sessions, se_entry)
			if (s->se_id == sid)
				break;
		if (s) {
			TAILQ_REMOVE(&env->sc_sessions, s, se_entry);
			free(s);
		} else {
			DPRINTF("removal of unpublished session %i", sid);
		}
		break;
	default:
		return (-1);
	}

	return (0);
}

void
show(struct ctl_conn *c)
{
	struct rdr		*rdr;
	struct host		*host;
	struct relay		*rlay;
	struct router		*rt;
	struct netroute		*nr;
	struct relay_table	*rlt;

	if (env->sc_rdrs == NULL)
		goto relays;
	TAILQ_FOREACH(rdr, env->sc_rdrs, entry) {
		imsg_compose_event(&c->iev, IMSG_CTL_RDR, 0, 0, -1,
		    rdr, sizeof(*rdr));
		if (rdr->conf.flags & F_DISABLE)
			continue;

		imsg_compose_event(&c->iev, IMSG_CTL_RDR_STATS, 0, 0, -1,
		    &rdr->stats, sizeof(rdr->stats));

		imsg_compose_event(&c->iev, IMSG_CTL_TABLE, 0, 0, -1,
		    rdr->table, sizeof(*rdr->table));
		if (!(rdr->table->conf.flags & F_DISABLE))
			TAILQ_FOREACH(host, &rdr->table->hosts, entry)
				imsg_compose_event(&c->iev, IMSG_CTL_HOST,
				    0, 0, -1, host, sizeof(*host));

		if (rdr->backup->conf.id == EMPTY_TABLE)
			continue;
		imsg_compose_event(&c->iev, IMSG_CTL_TABLE, 0, 0, -1,
		    rdr->backup, sizeof(*rdr->backup));
		if (!(rdr->backup->conf.flags & F_DISABLE))
			TAILQ_FOREACH(host, &rdr->backup->hosts, entry)
				imsg_compose_event(&c->iev, IMSG_CTL_HOST,
				    0, 0, -1, host, sizeof(*host));
	}
relays:
	if (env->sc_relays == NULL)
		goto routers;
	TAILQ_FOREACH(rlay, env->sc_relays, rl_entry) {
		rlay->rl_stats[env->sc_conf.prefork_relay].id = EMPTY_ID;
		imsg_compose_event(&c->iev, IMSG_CTL_RELAY, 0, 0, -1,
		    rlay, sizeof(*rlay));
		imsg_compose_event(&c->iev, IMSG_CTL_RELAY_STATS, 0, 0, -1,
		    &rlay->rl_stats, sizeof(rlay->rl_stats));

		TAILQ_FOREACH(rlt, &rlay->rl_tables, rlt_entry) {
			imsg_compose_event(&c->iev, IMSG_CTL_TABLE, 0, 0, -1,
			    rlt->rlt_table, sizeof(*rlt->rlt_table));
			if (!(rlt->rlt_table->conf.flags & F_DISABLE))
				TAILQ_FOREACH(host,
				    &rlt->rlt_table->hosts, entry)
					imsg_compose_event(&c->iev,
					    IMSG_CTL_HOST, 0, 0, -1,
					    host, sizeof(*host));
		}
	}

routers:
	if (env->sc_rts == NULL)
		goto end;
	TAILQ_FOREACH(rt, env->sc_rts, rt_entry) {
		imsg_compose_event(&c->iev, IMSG_CTL_ROUTER, 0, 0, -1,
		    rt, sizeof(*rt));
		if (rt->rt_conf.flags & F_DISABLE)
			continue;

		TAILQ_FOREACH(nr, &rt->rt_netroutes, nr_entry)
			imsg_compose_event(&c->iev, IMSG_CTL_NETROUTE,
			    0, 0, -1, nr, sizeof(*nr));
		imsg_compose_event(&c->iev, IMSG_CTL_TABLE, 0, 0, -1,
		    rt->rt_gwtable, sizeof(*rt->rt_gwtable));
		if (!(rt->rt_gwtable->conf.flags & F_DISABLE))
			TAILQ_FOREACH(host, &rt->rt_gwtable->hosts, entry)
				imsg_compose_event(&c->iev, IMSG_CTL_HOST,
				    0, 0, -1, host, sizeof(*host));
	}

end:
	imsg_compose_event(&c->iev, IMSG_CTL_END, 0, 0, -1, NULL, 0);
}

void
show_sessions(struct ctl_conn *c)
{
	int			 proc, cid;

	for (proc = 0; proc < env->sc_conf.prefork_relay; proc++) {
		cid = c->iev.ibuf.fd;

		/*
		 * Request all the running sessions from the process
		 */
		proc_compose_imsg(env->sc_ps, PROC_RELAY, proc,
		    IMSG_CTL_SESSION, -1, -1, &cid, sizeof(cid));
		c->waiting++;
	}
}

int
disable_rdr(struct ctl_conn *c, struct ctl_id *id)
{
	struct rdr	*rdr;

	if (id->id == EMPTY_ID)
		rdr = rdr_findbyname(env, id->name);
	else
		rdr = rdr_find(env, id->id);
	if (rdr == NULL)
		return (-1);
	id->id = rdr->conf.id;

	if (rdr->conf.flags & F_DISABLE)
		return (0);

	rdr->conf.flags |= F_DISABLE;
	rdr->conf.flags &= ~(F_ADD);
	rdr->conf.flags |= F_DEL;
	rdr->table->conf.flags |= F_DISABLE;
	log_debug("%s: redirect %d", __func__, rdr->conf.id);
	pfe_sync();
	return (0);
}

int
enable_rdr(struct ctl_conn *c, struct ctl_id *id)
{
	struct rdr	*rdr;
	struct ctl_id	 eid;

	if (id->id == EMPTY_ID)
		rdr = rdr_findbyname(env, id->name);
	else
		rdr = rdr_find(env, id->id);
	if (rdr == NULL)
		return (-1);
	id->id = rdr->conf.id;

	if (!(rdr->conf.flags & F_DISABLE))
		return (0);

	rdr->conf.flags &= ~(F_DISABLE);
	rdr->conf.flags &= ~(F_DEL);
	rdr->conf.flags |= F_ADD;
	log_debug("%s: redirect %d", __func__, rdr->conf.id);

	bzero(&eid, sizeof(eid));

	/* XXX: we're syncing twice */
	eid.id = rdr->table->conf.id;
	if (enable_table(c, &eid) == -1)
		return (-1);
	if (rdr->backup->conf.id == EMPTY_ID)
		return (0);
	eid.id = rdr->backup->conf.id;
	if (enable_table(c, &eid) == -1)
		return (-1);
	return (0);
}

int
disable_table(struct ctl_conn *c, struct ctl_id *id)
{
	struct table	*table;
	struct host	*host;

	if (id->id == EMPTY_ID)
		table = table_findbyname(env, id->name);
	else
		table = table_find(env, id->id);
	if (table == NULL)
		return (-1);
	id->id = table->conf.id;
	if (table->conf.rdrid > 0 && rdr_find(env, table->conf.rdrid) == NULL)
		fatalx("%s: desynchronised", __func__);

	if (table->conf.flags & F_DISABLE)
		return (0);
	table->conf.flags |= (F_DISABLE|F_CHANGED);
	table->up = 0;
	TAILQ_FOREACH(host, &table->hosts, entry)
		host->up = HOST_UNKNOWN;
	proc_compose(env->sc_ps, PROC_HCE, IMSG_TABLE_DISABLE,
	    &table->conf.id, sizeof(table->conf.id));

	/* Forward to relay engine(s) */
	proc_compose(env->sc_ps, PROC_RELAY, IMSG_TABLE_DISABLE,
	    &table->conf.id, sizeof(table->conf.id));

	log_debug("%s: table %d", __func__, table->conf.id);
	pfe_sync();
	return (0);
}

int
enable_table(struct ctl_conn *c, struct ctl_id *id)
{
	struct table	*table;
	struct host	*host;

	if (id->id == EMPTY_ID)
		table = table_findbyname(env, id->name);
	else
		table = table_find(env, id->id);
	if (table == NULL)
		return (-1);
	id->id = table->conf.id;

	if (table->conf.rdrid > 0 && rdr_find(env, table->conf.rdrid) == NULL)
		fatalx("%s: desynchronised", __func__);

	if (!(table->conf.flags & F_DISABLE))
		return (0);
	table->conf.flags &= ~(F_DISABLE);
	table->conf.flags |= F_CHANGED;
	table->up = 0;
	TAILQ_FOREACH(host, &table->hosts, entry)
		host->up = HOST_UNKNOWN;
	proc_compose(env->sc_ps, PROC_HCE, IMSG_TABLE_ENABLE,
	    &table->conf.id, sizeof(table->conf.id));

	/* Forward to relay engine(s) */
	proc_compose(env->sc_ps, PROC_RELAY, IMSG_TABLE_ENABLE,
	    &table->conf.id, sizeof(table->conf.id));

	log_debug("%s: table %d", __func__, table->conf.id);
	pfe_sync();
	return (0);
}

int
disable_host(struct ctl_conn *c, struct ctl_id *id, struct host *host)
{
	struct host	*h;
	struct table	*table;

	if (host == NULL) {
		if (id->id == EMPTY_ID)
			host = host_findbyname(env, id->name);
		else
			host = host_find(env, id->id);
		if (host == NULL || host->conf.parentid)
			return (-1);
	}
	id->id = host->conf.id;

	if (host->flags & F_DISABLE)
		return (0);

	if (host->up == HOST_UP) {
		if ((table = table_find(env, host->conf.tableid)) == NULL)
			fatalx("%s: invalid table id", __func__);
		table->up--;
		table->conf.flags |= F_CHANGED;
	}

	host->up = HOST_UNKNOWN;
	host->flags |= F_DISABLE;
	host->flags |= F_DEL;
	host->flags &= ~(F_ADD);
	host->check_cnt = 0;
	host->up_cnt = 0;

	proc_compose(env->sc_ps, PROC_HCE, IMSG_HOST_DISABLE,
	    &host->conf.id, sizeof(host->conf.id));

	/* Forward to relay engine(s) */
	proc_compose(env->sc_ps, PROC_RELAY, IMSG_HOST_DISABLE,
	    &host->conf.id, sizeof(host->conf.id));
	log_debug("%s: host %d", __func__, host->conf.id);

	if (!host->conf.parentid) {
		/* Disable all children */
		SLIST_FOREACH(h, &host->children, child)
			disable_host(c, id, h);
		pfe_sync();
	}
	return (0);
}

int
enable_host(struct ctl_conn *c, struct ctl_id *id, struct host *host)
{
	struct host	*h;

	if (host == NULL) {
		if (id->id == EMPTY_ID)
			host = host_findbyname(env, id->name);
		else
			host = host_find(env, id->id);
		if (host == NULL || host->conf.parentid)
			return (-1);
	}
	id->id = host->conf.id;

	if (!(host->flags & F_DISABLE))
		return (0);

	host->up = HOST_UNKNOWN;
	host->flags &= ~(F_DISABLE);
	host->flags &= ~(F_DEL);
	host->flags &= ~(F_ADD);

	proc_compose(env->sc_ps, PROC_HCE, IMSG_HOST_ENABLE,
	    &host->conf.id, sizeof (host->conf.id));

	/* Forward to relay engine(s) */
	proc_compose(env->sc_ps, PROC_RELAY, IMSG_HOST_ENABLE,
	    &host->conf.id, sizeof(host->conf.id));

	log_debug("%s: host %d", __func__, host->conf.id);

	if (!host->conf.parentid) {
		/* Enable all children */
		SLIST_FOREACH(h, &host->children, child)
			enable_host(c, id, h);
		pfe_sync();
	}
	return (0);
}

void
pfe_sync(void)
{
	struct rdr		*rdr;
	struct table		*active;
	struct table		*table;
	struct ctl_id		 id;
	struct imsg		 imsg;
	struct ctl_demote	 demote;
	struct router		*rt;

	bzero(&id, sizeof(id));
	bzero(&imsg, sizeof(imsg));
	TAILQ_FOREACH(rdr, env->sc_rdrs, entry) {
		rdr->conf.flags &= ~(F_BACKUP);
		rdr->conf.flags &= ~(F_DOWN);

		if (rdr->conf.flags & F_DISABLE ||
		    (rdr->table->up == 0 && rdr->backup->up == 0)) {
			rdr->conf.flags |= F_DOWN;
			active = NULL;
		} else if (rdr->table->up == 0 && rdr->backup->up > 0) {
			rdr->conf.flags |= F_BACKUP;
			active = rdr->backup;
			active->conf.flags |=
			    rdr->table->conf.flags & F_CHANGED;
			active->conf.flags |=
			    rdr->backup->conf.flags & F_CHANGED;
		} else
			active = rdr->table;

		if (active != NULL && active->conf.flags & F_CHANGED) {
			id.id = active->conf.id;
			imsg.hdr.type = IMSG_CTL_TABLE_CHANGED;
			imsg.hdr.len = sizeof(id) + IMSG_HEADER_SIZE;
			imsg.data = &id;
			sync_table(env, rdr, active);
			control_imsg_forward(env->sc_ps, &imsg);
		}

		if (rdr->conf.flags & F_DOWN) {
			if (rdr->conf.flags & F_ACTIVE_RULESET) {
				flush_table(env, rdr);
				log_debug("%s: disabling ruleset", __func__);
				rdr->conf.flags &= ~(F_ACTIVE_RULESET);
				id.id = rdr->conf.id;
				imsg.hdr.type = IMSG_CTL_PULL_RULESET;
				imsg.hdr.len = sizeof(id) + IMSG_HEADER_SIZE;
				imsg.data = &id;
				sync_ruleset(env, rdr, 0);
				control_imsg_forward(env->sc_ps, &imsg);
			}
		} else if (!(rdr->conf.flags & F_ACTIVE_RULESET)) {
			log_debug("%s: enabling ruleset", __func__);
			rdr->conf.flags |= F_ACTIVE_RULESET;
			id.id = rdr->conf.id;
			imsg.hdr.type = IMSG_CTL_PUSH_RULESET;
			imsg.hdr.len = sizeof(id) + IMSG_HEADER_SIZE;
			imsg.data = &id;
			sync_ruleset(env, rdr, 1);
			control_imsg_forward(env->sc_ps, &imsg);
		}
	}

	TAILQ_FOREACH(rt, env->sc_rts, rt_entry) {
		rt->rt_conf.flags &= ~(F_BACKUP);
		rt->rt_conf.flags &= ~(F_DOWN);

		if ((rt->rt_gwtable->conf.flags & F_CHANGED))
			sync_routes(env, rt);
	}

	TAILQ_FOREACH(table, env->sc_tables, entry) {
		if (table->conf.check == CHECK_NOCHECK)
			continue;

		/*
		 * clean up change flag.
		 */
		table->conf.flags &= ~(F_CHANGED);

		/*
		 * handle demotion.
		 */
		if ((table->conf.flags & F_DEMOTE) == 0)
			continue;
		demote.level = 0;
		if (table->up && table->conf.flags & F_DEMOTED) {
			demote.level = -1;
			table->conf.flags &= ~F_DEMOTED;
		}
		else if (!table->up && !(table->conf.flags & F_DEMOTED)) {
			demote.level = 1;
			table->conf.flags |= F_DEMOTED;
		}
		if (demote.level == 0)
			continue;
		log_debug("%s: demote %d table '%s' group '%s'", __func__,
		    demote.level, table->conf.name, table->conf.demote_group);
		(void)strlcpy(demote.group, table->conf.demote_group,
		    sizeof(demote.group));
		proc_compose(env->sc_ps, PROC_PARENT, IMSG_DEMOTE,
		    &demote, sizeof(demote));
	}
}

void
pfe_statistics(int fd, short events, void *arg)
{
	struct rdr		*rdr;
	struct ctl_stats	*cur;
	struct timeval		 tv, tv_now;
	int			 resethour, resetday;
	u_long			 cnt;

	timerclear(&tv);
	getmonotime(&tv_now);

	TAILQ_FOREACH(rdr, env->sc_rdrs, entry) {
		cnt = check_table(env, rdr, rdr->table);
		if (rdr->conf.backup_id != EMPTY_TABLE)
			cnt += check_table(env, rdr, rdr->backup);

		resethour = resetday = 0;

		cur = &rdr->stats;
		cur->last = cnt > cur->cnt ? cnt - cur->cnt : 0;

		cur->cnt = cnt;
		cur->tick++;
		cur->avg = (cur->last + cur->avg) / 2;
		cur->last_hour += cur->last;
		if ((cur->tick %
		    (3600 / env->sc_conf.statinterval.tv_sec)) == 0) {
			cur->avg_hour = (cur->last_hour + cur->avg_hour) / 2;
			resethour++;
		}
		cur->last_day += cur->last;
		if ((cur->tick %
		    (86400 / env->sc_conf.statinterval.tv_sec)) == 0) {
			cur->avg_day = (cur->last_day + cur->avg_day) / 2;
			resethour++;
		}
		if (resethour)
			cur->last_hour = 0;
		if (resetday)
			cur->last_day = 0;

		rdr->stats.interval = env->sc_conf.statinterval.tv_sec;
	}

	/* Schedule statistics timer */
	evtimer_set(&env->sc_statev, pfe_statistics, NULL);
	bcopy(&env->sc_conf.statinterval, &tv, sizeof(tv));
	evtimer_add(&env->sc_statev, &tv);
}
@


1.88
log
@move the opening of /dev/pf from the parent process to the pfe process
where it is used.
Currently pf is opened on every reload, that will no longer be
possible in the future with pledged programms that do ioctls.
This prepares relayd for that change.

ok deraadt@@, meinetwegen reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe.c,v 1.87 2016/09/02 16:14:09 reyk Exp $	*/
d59 1
a59 1
	int 			s;
d73 1
a73 1
		fatal("init_filter: DIOCGETSTATUS");
d75 1
a75 1
		fatalx("init_filter: pf is disabled");
d133 1
a133 1
			fatalx("pfe_dispatch_hce: invalid host id");
d146 1
a146 1
			fatalx("pfe_dispatch_hce: desynchronized");
d158 1
a158 1
			fatalx("pfe_dispatch_hce: invalid table id");
d264 1
a264 2
			fatalx("pfe_dispatch_relay: "
			    "invalid relay proc");
d274 1
a274 2
			fatalx("pfe_dispatch_relay: "
			    "invalid relay proc");
d276 1
a276 1
			fatalx("pfe_dispatch_relay: invalid relay id");
d524 1
a524 1
		fatalx("disable_table: desynchronised");
d559 1
a559 1
		fatalx("enable_table: desynchronised");
d601 1
a601 1
			fatalx("disable_host: invalid table id");
@


1.87
log
@Move snmp options into struct relayd_config and delay start of the
snmp subsystem until the configuration is done.

OK benno@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe.c,v 1.86 2016/09/02 14:45:51 reyk Exp $	*/
d21 1
d24 3
d29 1
d59 3
d64 14
a227 1
		init_filter(env, imsg->fd);
@


1.86
log
@Split "struct relayd" into two structs: "struct relayd" and "struct
relayd_config".  This way we can send all the relevant global
configuration to the children, not just the flags and the opts.

With input from and
OK claudio@@ benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe.c,v 1.85 2016/09/02 12:12:51 reyk Exp $	*/
a64 2
	snmp_init(env, PROC_PARENT);

d208 1
@


1.85
log
@As done in httpd, remove ps_ninstances and p_instance.

OK benno@@ rzalamena@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe.c,v 1.84 2016/09/02 11:51:49 reyk Exp $	*/
d88 1
a88 1
		bcopy(&env->sc_statinterval, &tv, sizeof(tv));
d243 1
a243 1
		if (cnl.proc > env->sc_prefork_relay)
d254 1
a254 1
		if (crs.proc > env->sc_prefork_relay)
d261 1
a261 1
		    env->sc_statinterval.tv_sec;
d372 1
a372 1
		rlay->rl_stats[env->sc_prefork_relay].id = EMPTY_ID;
d419 1
a419 1
	for (proc = 0; proc < env->sc_prefork_relay; proc++) {
d785 2
a786 1
		if ((cur->tick % (3600 / env->sc_statinterval.tv_sec)) == 0) {
d791 2
a792 1
		if ((cur->tick % (86400 / env->sc_statinterval.tv_sec)) == 0) {
d801 1
a801 1
		rdr->stats.interval = env->sc_statinterval.tv_sec;
d806 1
a806 1
	bcopy(&env->sc_statinterval, &tv, sizeof(tv));
@


1.84
log
@Terminate relayd using the socket status instead of watching SIGCHLD
or killing child processes. - Based on rzalamena@@'s diff for httpd.

OK deraadt@@ rzalamena@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe.c,v 1.83 2015/12/03 16:12:16 benno Exp $	*/
d106 1
a106 1
	control_imsg_forward(imsg);
d690 1
a690 1
			control_imsg_forward(&imsg);
d703 1
a703 1
				control_imsg_forward(&imsg);
d713 1
a713 1
			control_imsg_forward(&imsg);
@


1.83
log
@quick removal of all host-related entries in the related relayd anchor
if the host fails the SLA check. patch from Brian S. Vangsgaard.
ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe.c,v 1.82 2015/12/02 13:41:27 reyk Exp $	*/
d51 1
a51 1
pid_t
d56 1
a56 1
	return (proc_run(ps, p, procs, nitems(procs), pfe_init, NULL));
@


1.82
log
@In most cases we don't need all arguments of proc_compose*_imsg(),
so add a shortcut proc_compose*() that skips all of them.  Only use the
full argument list if needed.  The functions with full argument lists can
eventually be replaced with a nicer transaction-based approach later.

OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe.c,v 1.81 2015/11/29 01:20:33 benno Exp $	*/
d159 2
@


1.81
log
@Use pledge("pf") in pfe.c.
Move getrtable() from pfe to parent process, since its in the way of
pledge.

ok deraadt@@, feedback from reyk@@ on previous version.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe.c,v 1.80 2015/04/21 01:46:57 jsg Exp $	*/
d133 2
a134 2
		proc_compose_imsg(env->sc_ps, PROC_RELAY, -1,
		    IMSG_HOST_STATUS, -1, &st, sizeof(st));
d247 1
a247 1
		    IMSG_NATLOOK, -1, &cnl, sizeof(cnl));
d424 1
a424 1
		    IMSG_CTL_SESSION, -1, &cid, sizeof(cid));
d512 1
a512 1
	proc_compose_imsg(env->sc_ps, PROC_HCE, -1, IMSG_TABLE_DISABLE, -1,
d516 1
a516 1
	proc_compose_imsg(env->sc_ps, PROC_RELAY, -1, IMSG_TABLE_DISABLE, -1,
d548 1
a548 1
	proc_compose_imsg(env->sc_ps, PROC_HCE, -1, IMSG_TABLE_ENABLE, -1,
d552 1
a552 1
	proc_compose_imsg(env->sc_ps, PROC_RELAY, -1, IMSG_TABLE_ENABLE, -1,
d593 1
a593 1
	proc_compose_imsg(env->sc_ps, PROC_HCE, -1, IMSG_HOST_DISABLE, -1,
d597 1
a597 1
	proc_compose_imsg(env->sc_ps, PROC_RELAY, -1, IMSG_HOST_DISABLE, -1,
d633 1
a633 1
	proc_compose_imsg(env->sc_ps, PROC_HCE, -1, IMSG_HOST_ENABLE, -1,
d637 1
a637 1
	proc_compose_imsg(env->sc_ps, PROC_RELAY, -1, IMSG_HOST_ENABLE, -1,
d752 1
a752 1
		proc_compose_imsg(env->sc_ps, PROC_PARENT, -1, IMSG_DEMOTE, -1,
@


1.80
log
@fix a memory leak.  ok blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe.c,v 1.79 2015/02/08 01:39:06 blambert Exp $	*/
d27 1
d66 3
@


1.79
log
@move a log_warnx() to a DPRINTF, as it's information intended
for developers, not sysadmins

original diff from yasuoka@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe.c,v 1.78 2015/01/22 17:42:09 reyk Exp $	*/
d292 3
a294 1
			if (t->se_id == s->se_id)	/* duplicate registration */
d296 1
@


1.79.2.1
log
@maintainance diff for relayd
MFC the following changes

- Missing free(3) in error path (ssl.c,v 1.29)
- fix a memory leak. (pfe.c,v 1.80)
- allocate se_log evbuffer before loging errors with relay_close()
  (relay.c,v 1.192)
- fix a file descriptor leak in http protocol handling
  (relay.c,v 1.193 and relay_http.c,v 1.44)
- Fix obvious problems with relayd config reload
  (ca.c,v 1.13; config.c,v 1.25; parse.y,v 1.204;
  relayd.c,v 1.139; relayd.h,v 1.209)
- http protocol: you cannot append to the previous key-value before
  line three of a request (relay_http.c,v 1.45)
- fix a crash / use after free (relay.c,v 1.194; relay_http.c,v 1.46)
- fix a non safe use of TAILQ_FOREACH with TAILQ_REMOVE
  (relay_http.c,v 1.47)
- Plug a memory leak by simplifying kv_free() (relayd.c,v 1.141)
- Fix memory leak in error case (relay_http.c,v 1.48)
- track the connection state of a session and stops doing double
  opens in certain situations (relay.c,v 1.195; relay_http.c,v 1.49; relayd.h,v 1.210)
- coding style (relay.c,v 1.196; relay_http.c,v 1.50; relayd.h,v 1.212)

ok claudio@@, sthen@@ and feedback tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe.c,v 1.79 2015/02/08 01:39:06 blambert Exp $	*/
d292 1
a292 3
			/* duplicate registration */
			if (t->se_id == s->se_id) {
				free(s);
a293 1
			}
@


1.78
log
@Clean up the relayd headers with help of include-what-you-use and some
manual review.  Based on common practice, relayd.h now includes the
necessary headers for itself.

OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe.c,v 1.77 2015/01/16 15:06:40 deraadt Exp $	*/
d311 3
a313 2
		} else
			log_warnx("removal of unpublished session %i", sid);
@


1.77
log
@Adapt to <limits.h> universe.
ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe.c,v 1.76 2014/11/19 10:24:40 blambert Exp $	*/
d19 4
a22 3
#include <sys/stat.h>
#include <sys/socket.h>
#include <sys/un.h>
a23 3
#include <net/if.h>

#include <errno.h>
a24 1
#include <fcntl.h>
d27 1
a27 4
#include <unistd.h>
#include <pwd.h>

#include <openssl/ssl.h>
@


1.76
log
@Support exporting relayd statistics via AgentX/snmpd

This should be equivalent to the statistics available
via the various relaydctl show commands

okay benno@@ reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe.c,v 1.75 2014/07/09 16:42:05 reyk Exp $	*/
a18 1
#include <sys/param.h>
@


1.75
log
@Replace the protocol directives for HTTP with a new generic filtering
language.  The grammar is inspired by pf and allows to write versatile
last-matching filter rules in protocol sections starting with the
"pass", "block" or "match" keywords.  This work was started almost two
years ago and replaces large parts of relayd(8)'s HTTP and filtering
code.  The initial version reimplements and extends HTTP filtering,
but will be improved to support generic TCP and other protocols later.

With some testing, feedback, and help from benno@@ and andre@@.

OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe.c,v 1.74 2013/03/10 23:32:53 reyk Exp $	*/
d71 2
d146 2
d219 3
d236 1
a236 1
	struct rsession		 con;
d238 1
d292 28
@


1.74
log
@This diff changes relayd to use the monotonic clock instead of
gettimeofday().  It was also bugging me for some time to have all
these checks of gettimeofday()'s return value: it should not fail.  So
this diff introduces a void getmonotime(struct timeval *tv) that calls
clock_gettime(CLOCK_MONOTONIC, &ts) and converts the output to a
struct timeval that can be used with the existing code and the
timeval-specific timer functions (timerclear, timersub, ...).  It does
not return a status but calls fatal() on error-that-should-not-happen.

ok sthen@@ chris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe.c,v 1.73 2012/10/03 08:33:31 reyk Exp $	*/
a195 2
		break;
	case IMSG_CFG_PROTONODE:
@


1.73
log
@Support more than one relay backup table.  Instead of duplicating the
code for main and backup table all over the place, turn the relay
tables into a list attached to the relay.  This improves the code and
allows some other tricks with multiple tables later.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe.c,v 1.72 2012/01/21 13:40:48 camield Exp $	*/
d732 1
a732 2
	if (gettimeofday(&tv_now, NULL) == -1)
		fatal("pfe_statistics: gettimeofday");
@


1.72
log
@Only start the child processes after all of them reported to have loaded
the config.  Solves a race at startup time where processes can send status
messages about hosts that other processes don't know about yet.
(and have relayd abort with "desynchronized" or "invalid host id")

ok henning pyr deraadt
solves the problem ok from benno todd
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe.c,v 1.71 2011/11/12 19:36:17 camield Exp $	*/
d202 3
d297 6
a302 5
	struct rdr	*rdr;
	struct host	*host;
	struct relay	*rlay;
	struct router	*rt;
	struct netroute	*nr;
d341 10
a350 17
		if (rlay->rl_dsttable == NULL)
			continue;
		imsg_compose_event(&c->iev, IMSG_CTL_TABLE, 0, 0, -1,
		    rlay->rl_dsttable, sizeof(*rlay->rl_dsttable));
		if (!(rlay->rl_dsttable->conf.flags & F_DISABLE))
			TAILQ_FOREACH(host, &rlay->rl_dsttable->hosts, entry)
				imsg_compose_event(&c->iev, IMSG_CTL_HOST,
				    0, 0, -1, host, sizeof(*host));

		if (rlay->rl_conf.backuptable == EMPTY_TABLE)
			continue;
		imsg_compose_event(&c->iev, IMSG_CTL_TABLE, 0, 0, -1,
		    rlay->rl_backuptable, sizeof(*rlay->rl_backuptable));
		if (!(rlay->rl_backuptable->conf.flags & F_DISABLE))
			TAILQ_FOREACH(host, &rlay->rl_backuptable->hosts, entry)
				imsg_compose_event(&c->iev, IMSG_CTL_HOST,
				    0, 0, -1, host, sizeof(*host));
@


1.71
log
@fix function names in fatalx() messages

ok mikeb
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe.c,v 1.70 2011/05/20 09:43:53 reyk Exp $	*/
d206 2
@


1.70
log
@Concurrent calls of "relayctl show sessions" could crash relayd.  Fix
the show sessions handler by implementing it in an asynchronous way.

Closes PR 6509
ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe.c,v 1.69 2011/05/19 08:56:49 reyk Exp $	*/
d114 1
a114 1
			fatalx("pfe_dispatch_imsg: invalid host id");
d127 1
a127 1
			fatalx("pfe_dispatch_imsg: desynchronized");
d139 1
a139 1
			fatalx("pfe_dispatch_imsg: invalid table id");
@


1.69
log
@Fix reload support in relayd(8) by reimplementing large parts of the
daemon infrastructure. The previous design made it fairly hard to
reload the complex data structures, especially relays and protocols.
One of the reasons was that the privsep'd relayd processes had two
ways of getting their configuration: 1) from memory after forking from
the parent process and 2) and (partially) via imsgs after reload.  The
new implementation first forks the privsep'd children before the
parents loads the configuration and sends it via imsgs to them; so it
is only like 2) before.  It is based on an approach that I first
implemented for iked(8) and I also fixed many bugs in the code.

Thanks to many testers including dlg@@ sthen@@ phessler@@
ok pyr@@ dlg@@ sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe.c,v 1.68 2011/05/09 12:08:47 reyk Exp $	*/
d225 3
d253 29
d381 1
a381 4
	int			 n, proc, done;
	struct imsg		 imsg;
	struct imsgbuf		*ibuf;
	struct rsession		 con;
d384 1
a384 1
		ibuf = proc_ibuf(env->sc_ps, PROC_RELAY, proc);
d390 2
a391 38
		    IMSG_CTL_SESSION, -1, NULL, 0);
		proc_flush_imsg(env->sc_ps, PROC_RELAY, proc);
		
		/*
		 * Wait for the reply and forward the messages to the
		 * control connection.
		 */
		done = 0;
		while (!done) {
			do {
				if ((n = imsg_read(ibuf)) == -1)
					fatalx("imsg_read error");
			} while (n == -2); /* handle non-blocking I/O */
			while (!done) {
				if ((n = imsg_get(ibuf, &imsg)) == -1)
					fatalx("imsg_get error");
				if (n == 0)
					break;

				switch (imsg.hdr.type) {
				case IMSG_CTL_SESSION:
					IMSG_SIZE_CHECK(&imsg, &con);
					memcpy(&con, imsg.data, sizeof(con));

					imsg_compose_event(&c->iev,
					    IMSG_CTL_SESSION, 0, 0, -1,
					    &con, sizeof(con));
					break;
				case IMSG_CTL_END:
					done = 1;
					break;
				default:
					fatalx("wrong message for session");
					break;
				}
				imsg_free(&imsg);
			}
		}
a392 2

	imsg_compose_event(&c->iev, IMSG_CTL_END, 0, 0, -1, NULL, 0);
@


1.68
log
@Reorganize the relayd code to use the proc.c privsep API/commodity
functions that are based on work for iked and smtpd.  This simplifies
the setup of privsep processes and moves some redundant and repeated
code to a single place - which is always good from a quality and
security point of view.  The relayd version of proc.c is different to
the current version in iked because it uses 1:N communications between
processes, eg. a single parent process is talking to many forked relay
children while iked only needs 1:1 communications.

ok sthen@@ pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe.c,v 1.67 2011/05/05 12:01:43 reyk Exp $	*/
d49 1
a49 1
static struct relayd	*env = NULL;
a61 3
	init_filter(env);
	init_tables(env);

d68 3
a71 3
	purge_config(env, PURGE_PROTOS);
	pfe_setup_events();
	pfe_sync();
d78 1
d87 5
a91 3
	evtimer_set(&env->sc_statev, pfe_statistics, NULL);
	bcopy(&env->sc_statinterval, &tv, sizeof(tv));
	evtimer_add(&env->sc_statev, &tv);
a174 5
	static struct rdr	*rdr = NULL;
	static struct table	*table = NULL;
	struct host		*host, *parent;
	struct address		*virt;

d176 22
a197 41
	case IMSG_RECONF:
		IMSG_SIZE_CHECK(imsg, env);

		log_debug("%s: reloading configuration", __func__);

		pfe_disable_events();
		purge_config(env, PURGE_RDRS|PURGE_TABLES);
		merge_config(env, (struct relayd *)imsg->data);

		/*
		 * no relays when reconfiguring yet.
		 */
		env->sc_relays = NULL;
		env->sc_protos = NULL;

		env->sc_tables = calloc(1, sizeof(*env->sc_tables));
		env->sc_rdrs = calloc(1, sizeof(*env->sc_rdrs));
		if (env->sc_tables == NULL || env->sc_rdrs == NULL)
			fatal(NULL);

		TAILQ_INIT(env->sc_tables);
		TAILQ_INIT(env->sc_rdrs);
		break;
	case IMSG_RECONF_TABLE:
		if ((table = calloc(1, sizeof(*table))) == NULL)
			fatal(NULL);
		memcpy(&table->conf, imsg->data, sizeof(table->conf));
		TAILQ_INIT(&table->hosts);
		TAILQ_INSERT_TAIL(env->sc_tables, table, entry);
		break;
	case IMSG_RECONF_HOST:
		if ((host = calloc(1, sizeof(*host))) == NULL)
			fatal(NULL);
		memcpy(&host->conf, imsg->data, sizeof(host->conf));
		host->tablename = table->conf.name;
		TAILQ_INSERT_TAIL(&table->hosts, host, entry);
		if (host->conf.parentid) {
			parent = host_find(env, host->conf.parentid);
			SLIST_INSERT_HEAD(&parent->children,
			    host, child);
		}
d199 2
a200 27
	case IMSG_RECONF_RDR:
		if ((rdr = calloc(1, sizeof(*rdr))) == NULL)
			fatal(NULL);
		memcpy(&rdr->conf, imsg->data,
		    sizeof(rdr->conf));
		rdr->table = table_find(env,
		     rdr->conf.table_id);
		if (rdr->conf.backup_id == EMPTY_TABLE)
			rdr->backup = &env->sc_empty_table;
		else
			rdr->backup = table_find(env,
			    rdr->conf.backup_id);
		if (rdr->table == NULL || rdr->backup == NULL)
			fatal("pfe_dispatch_parent:"
			    " corrupted configuration");
		log_debug("%s: redirect table %s, backup %s",
		    __func__,
		    rdr->table->conf.name,
		    rdr->backup->conf.name);
		TAILQ_INIT(&rdr->virts);
		TAILQ_INSERT_TAIL(env->sc_rdrs, rdr, entry);
		break;
	case IMSG_RECONF_VIRT:
		if ((virt = calloc(1, sizeof(*virt))) == NULL)
			fatal(NULL);
		memcpy(virt, imsg->data, sizeof(*virt));
		TAILQ_INSERT_TAIL(&rdr->virts, virt, entry);
d202 3
a204 2
	case IMSG_RECONF_END:
		log_warnx("%s: configuration reloaded", __func__);
d209 3
d699 3
@


1.67
log
@Update all logging and debug functions to use the __func__ macro
instead of static function names.  __func__ is C99 and perfectly fine
to use. It also avoids printing errors; for example if a statement
log_debug("foo:"..) was moved or copied from function foo() to bar()
and the log message was not updated...
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe.c,v 1.66 2010/11/16 15:31:01 jsg Exp $	*/
d38 10
a47 9
void	pfe_sig_handler(int sig, short, void *);
void	pfe_shutdown(void);
void	pfe_setup_events(void);
void	pfe_disable_events(void);
void	pfe_dispatch_imsg(int, short, void *);
void	pfe_dispatch_parent(int, short, void *);
void	pfe_dispatch_relay(int, short, void *);
void	pfe_sync(void);
void	pfe_statistics(int, short, void *);
d51 5
a55 3
struct imsgev	*iev_main;
struct imsgev	*iev_hce;
struct imsgev	*iev_relay;
d57 2
a58 2
void
pfe_sig_handler(int sig, short event, void *arg)
d60 1
a60 39
	switch (sig) {
	case SIGINT:
	case SIGTERM:
		pfe_shutdown();
		break;
	case SIGCHLD:
	case SIGHUP:
	case SIGPIPE:
		/* ignore */
		break;
	default:
		fatalx("pfe_sig_handler: unexpected signal");
	}
}

pid_t
pfe(struct relayd *x_env, int pipe_parent2pfe[2], int pipe_parent2hce[2],
    int pipe_parent2relay[RELAY_MAXPROC][2], int pipe_pfe2hce[2],
    int pipe_pfe2relay[RELAY_MAXPROC][2])
{
	pid_t		 pid;
	struct passwd	*pw;
	int		 i;
	size_t		 size;

	switch (pid = fork()) {
	case -1:
		fatal("pfe: cannot fork");
	case 0:
		break;
	default:
		return (pid);
	}

	env = x_env;
	purge_config(env, PURGE_PROTOS);

	if (control_init() == -1)
		fatalx("pfe: control socket setup failed");
d65 2
a66 66
	if ((pw = getpwnam(RELAYD_USER)) == NULL)
		fatal("pfe: getpwnam");

#ifndef DEBUG
	if (chroot(pw->pw_dir) == -1)
		fatal("pfe: chroot");
	if (chdir("/") == -1)
		fatal("pfe: chdir(\"/\")");
#else
#warning disabling privilege revocation and chroot in DEBUG mode
#endif

	setproctitle("pf update engine");
	relayd_process = PROC_PFE;

#ifndef DEBUG
	if (setgroups(1, &pw->pw_gid) ||
	    setresgid(pw->pw_gid, pw->pw_gid, pw->pw_gid) ||
	    setresuid(pw->pw_uid, pw->pw_uid, pw->pw_uid))
		fatal("pfe: cannot drop privileges");
#endif

	event_init();

	signal_set(&env->sc_evsigint, SIGINT, pfe_sig_handler, env);
	signal_set(&env->sc_evsigterm, SIGTERM, pfe_sig_handler, env);
	signal_set(&env->sc_evsigchld, SIGCHLD, pfe_sig_handler, env);
	signal_set(&env->sc_evsighup, SIGHUP, pfe_sig_handler, env);
	signal_set(&env->sc_evsigpipe, SIGPIPE, pfe_sig_handler, env);

	signal_add(&env->sc_evsigint, NULL);
	signal_add(&env->sc_evsigterm, NULL);
	signal_add(&env->sc_evsigchld, NULL);
	signal_add(&env->sc_evsighup, NULL);
	signal_add(&env->sc_evsigpipe, NULL);

	/* setup pipes */
	close(pipe_pfe2hce[0]);
	close(pipe_parent2pfe[0]);
	close(pipe_parent2hce[0]);
	close(pipe_parent2hce[1]);
	for (i = 0; i < env->sc_prefork_relay; i++) {
		close(pipe_parent2relay[i][0]);
		close(pipe_parent2relay[i][1]);
		close(pipe_pfe2relay[i][0]);
	}

	size = sizeof(struct imsgev);
	if ((iev_hce = calloc(1, size)) == NULL ||
	    (iev_relay = calloc(env->sc_prefork_relay, size)) == NULL ||
	    (iev_main = calloc(1, size)) == NULL)
		fatal("pfe");

	imsg_init(&iev_hce->ibuf, pipe_pfe2hce[1]);
	iev_hce->handler = pfe_dispatch_imsg;
	imsg_init(&iev_main->ibuf, pipe_parent2pfe[1]);
	iev_main->handler = pfe_dispatch_parent;
	for (i = 0; i < env->sc_prefork_relay; i++) {
		imsg_init(&iev_relay[i].ibuf, pipe_pfe2relay[i][1]);
		iev_relay[i].handler = pfe_dispatch_relay;
	}

	iev_main->events = EV_READ;
	event_set(&iev_main->ev, iev_main->ibuf.fd, iev_main->events,
	    iev_main->handler, iev_main);
	event_add(&iev_main->ev, NULL);
d68 5
a73 7

	TAILQ_INIT(&ctl_conns);

	if (control_listen(env, iev_main, iev_hce) == -1)
		fatalx("pfe: control socket listen failed");

	/* Initial sync */
a74 5

	event_dispatch();
	pfe_shutdown();

	return (0);
a80 2
	log_info("pf update engine exiting");
	_exit(0);
a85 2
	int		 i;
	struct imsgev	*iev;
a87 14
	iev_hce->events = EV_READ;
	event_set(&iev_hce->ev, iev_hce->ibuf.fd, iev_hce->events,
	    iev_hce->handler, iev_hce);
	event_add(&iev_hce->ev, NULL);

	for (i = 0; i < env->sc_prefork_relay; i++) {
		iev = &iev_relay[i];

		iev->events = EV_READ;
		event_set(&iev->ev, iev->ibuf.fd, iev->events,
		    iev->handler, iev);
		event_add(&iev->ev, NULL);
	}

a96 7
	int	i;

	event_del(&iev_hce->ev);

	for (i = 0; i < env->sc_prefork_relay; i++)
		event_del(&iev_relay[i].ev);

d100 2
a101 2
void
pfe_dispatch_imsg(int fd, short event, void *ptr)
a102 5
	struct imsgev		*iev;
	struct imsgbuf		*ibuf;
	struct imsg		 imsg;
	ssize_t			 n;

d107 33
a139 2
	iev = ptr;
	ibuf = &iev->ibuf;
d141 17
a157 8
	if (event & EV_READ) {
		if ((n = imsg_read(ibuf)) == -1)
			fatal("pfe_dispatch_imsg: imsg_read_error");
		if (n == 0) {
			/* this pipe is dead, so remove the event handler */
			event_del(&iev->ev);
			event_loopexit(NULL);
			return;
a158 1
	}
d160 7
a166 3
	if (event & EV_WRITE) {
		if (msgbuf_write(&ibuf->w) == -1)
			fatal("pfe_dispatch_imsg: msgbuf_write");
d169 1
a169 74
	for (;;) {
		if ((n = imsg_get(ibuf, &imsg)) == -1)
			fatal("pfe_dispatch_imsg: imsg_read error");
		if (n == 0)
			break;

		control_imsg_forward(&imsg);
		switch (imsg.hdr.type) {
		case IMSG_HOST_STATUS:
			if (imsg.hdr.len - IMSG_HEADER_SIZE != sizeof(st))
				fatalx("pfe_dispatch_imsg: invalid request");
			memcpy(&st, imsg.data, sizeof(st));
			if ((host = host_find(env, st.id)) == NULL)
				fatalx("pfe_dispatch_imsg: invalid host id");
			host->he = st.he;
			if (host->flags & F_DISABLE)
				break;
			host->retry_cnt = st.retry_cnt;
			if (st.up != HOST_UNKNOWN) {
				host->check_cnt++;
				if (st.up == HOST_UP)
					host->up_cnt++;
			}
			if (host->check_cnt != st.check_cnt) {
				log_debug("%s: host %d => %d", __func__,
				    host->conf.id, host->up);
				fatalx("pfe_dispatch_imsg: desynchronized");
			}

			if (host->up == st.up)
				break;

			/* Forward to relay engine(s) */
			for (n = 0; n < env->sc_prefork_relay; n++)
				imsg_compose_event(&iev_relay[n],
				    IMSG_HOST_STATUS, 0, 0, -1, &st,
				    sizeof(st));

			if ((table = table_find(env, host->conf.tableid))
			    == NULL)
				fatalx("pfe_dispatch_imsg: invalid table id");

			log_debug("%s: state %d for host %u %s", __func__,
			    st.up, host->conf.id, host->conf.name);

			/*
			 * Do not change the table state when the host
			 * state switches between UNKNOWN and DOWN.
			 */
			if (HOST_ISUP(st.up)) {
				table->conf.flags |= F_CHANGED;
				table->up++;
				host->flags |= F_ADD;
				host->flags &= ~(F_DEL);
			} else if (HOST_ISUP(host->up)) {
				table->up--;
				table->conf.flags |= F_CHANGED;
				host->flags |= F_DEL;
				host->flags &= ~(F_ADD);
			}

			host->up = st.up;
			break;
		case IMSG_SYNC:
			pfe_sync();
			break;
		default:
			log_debug("%s: unexpected imsg %d", __func__,
			    imsg.hdr.type);
			break;
		}
		imsg_free(&imsg);
	}
	imsg_event_add(iev);
d172 2
a173 2
void
pfe_dispatch_parent(int fd, short event, void * ptr)
a174 5
	struct imsgev	*iev;
	struct imsgbuf	*ibuf;
	struct imsg	 imsg;
	ssize_t		 n;

d180 9
a188 2
	iev = ptr;
	ibuf = &iev->ibuf;
d190 5
a194 10
	if (event & EV_READ) {
		if ((n = imsg_read(ibuf)) == -1)
			fatal("imsg_read error");
		if (n == 0) {
			/* this pipe is dead, so remove the event handler */
			event_del(&iev->ev);
			event_loopexit(NULL);
			return;
		}
	}
d196 4
d201 58
a258 3
	if (event & EV_WRITE) {
		if (msgbuf_write(&ibuf->w) == -1)
			fatal("msgbuf_write");
d261 1
a261 90
	for (;;) {
		if ((n = imsg_get(ibuf, &imsg)) == -1)
			fatal("pfe_dispatch_parent: imsg_read error");
		if (n == 0)
			break;

		switch (imsg.hdr.type) {
		case IMSG_RECONF:
			log_debug("%s: reloading configuration", __func__);
			if (imsg.hdr.len !=
			    sizeof(struct relayd) + IMSG_HEADER_SIZE)
				fatalx("corrupted reload data");
			pfe_disable_events();
			purge_config(env, PURGE_RDRS|PURGE_TABLES);
			merge_config(env, (struct relayd *)imsg.data);
			/*
			 * no relays when reconfiguring yet.
			 */
			env->sc_relays = NULL;
			env->sc_protos = NULL;

			env->sc_tables = calloc(1, sizeof(*env->sc_tables));
			env->sc_rdrs = calloc(1, sizeof(*env->sc_rdrs));
			if (env->sc_tables == NULL || env->sc_rdrs == NULL)
				fatal(NULL);

			TAILQ_INIT(env->sc_tables);
			TAILQ_INIT(env->sc_rdrs);
			break;
		case IMSG_RECONF_TABLE:
			if ((table = calloc(1, sizeof(*table))) == NULL)
				fatal(NULL);
			memcpy(&table->conf, imsg.data, sizeof(table->conf));
			TAILQ_INIT(&table->hosts);
			TAILQ_INSERT_TAIL(env->sc_tables, table, entry);
			break;
		case IMSG_RECONF_HOST:
			if ((host = calloc(1, sizeof(*host))) == NULL)
				fatal(NULL);
			memcpy(&host->conf, imsg.data, sizeof(host->conf));
			host->tablename = table->conf.name;
			TAILQ_INSERT_TAIL(&table->hosts, host, entry);
			if (host->conf.parentid) {
				parent = host_find(env, host->conf.parentid);
				SLIST_INSERT_HEAD(&parent->children,
				    host, child);
			}
			break;
		case IMSG_RECONF_RDR:
			if ((rdr = calloc(1, sizeof(*rdr))) == NULL)
				fatal(NULL);
			memcpy(&rdr->conf, imsg.data,
			    sizeof(rdr->conf));
			rdr->table = table_find(env,
			     rdr->conf.table_id);
			if (rdr->conf.backup_id == EMPTY_TABLE)
				rdr->backup = &env->sc_empty_table;
			else
				rdr->backup = table_find(env,
				    rdr->conf.backup_id);
			if (rdr->table == NULL || rdr->backup == NULL)
				fatal("pfe_dispatch_parent:"
				    " corrupted configuration");
			log_debug("%s: redirect table %s, backup %s",
			    __func__,
			    rdr->table->conf.name,
			    rdr->backup->conf.name);
			TAILQ_INIT(&rdr->virts);
			TAILQ_INSERT_TAIL(env->sc_rdrs, rdr, entry);
			break;
		case IMSG_RECONF_VIRT:
			if ((virt = calloc(1, sizeof(*virt))) == NULL)
				fatal(NULL);
			memcpy(virt, imsg.data, sizeof(*virt));
			TAILQ_INSERT_TAIL(&rdr->virts, virt, entry);
			break;
		case IMSG_RECONF_END:
			log_warnx("%s: configuration reloaded", __func__);
			init_tables(env);
			pfe_setup_events();
			pfe_sync();
			break;
		default:
			log_debug("%s: unexpected imsg %d", __func__,
			    imsg.hdr.type);
			break;
		}
		imsg_free(&imsg);
	}
	imsg_event_add(iev);
d264 2
a265 2
void
pfe_dispatch_relay(int fd, short event, void * ptr)
a266 4
	struct imsgev		*iev;
	struct imsgbuf		*ibuf;
	struct imsg		 imsg;
	ssize_t			 n;
d271 26
a296 12
	iev = ptr;
	ibuf = &iev->ibuf;

	if (event & EV_READ) {
		if ((n = imsg_read(ibuf)) == -1)
			fatal("imsg_read error");
		if (n == 0) {
			/* this pipe is dead, so remove the event handler */
			event_del(&iev->ev);
			event_loopexit(NULL);
			return;
		}
d299 1
a299 45
	if (event & EV_WRITE) {
		if (msgbuf_write(&ibuf->w) == -1)
			fatal("msgbuf_write");
	}

	for (;;) {
		if ((n = imsg_get(ibuf, &imsg)) == -1)
			fatal("pfe_dispatch_relay: imsg_read error");
		if (n == 0)
			break;

		switch (imsg.hdr.type) {
		case IMSG_NATLOOK:
			if (imsg.hdr.len != IMSG_HEADER_SIZE + sizeof(cnl))
				fatalx("invalid imsg header len");
			bcopy(imsg.data, &cnl, sizeof(cnl));
			if (cnl.proc > env->sc_prefork_relay)
				fatalx("pfe_dispatch_relay: "
				    "invalid relay proc");
			if (natlook(env, &cnl) != 0)
				cnl.in = -1;
			imsg_compose_event(&iev_relay[cnl.proc], IMSG_NATLOOK,
			    0, 0, -1, &cnl, sizeof(cnl));
			break;
		case IMSG_STATISTICS:
			if (imsg.hdr.len != IMSG_HEADER_SIZE + sizeof(crs))
				fatalx("invalid imsg header len");
			bcopy(imsg.data, &crs, sizeof(crs));
			if (crs.proc > env->sc_prefork_relay)
				fatalx("pfe_dispatch_relay: "
				    "invalid relay proc");
			if ((rlay = relay_find(env, crs.id)) == NULL)
				fatalx("pfe_dispatch_relay: invalid relay id");
			bcopy(&crs, &rlay->rl_stats[crs.proc], sizeof(crs));
			rlay->rl_stats[crs.proc].interval =
			    env->sc_statinterval.tv_sec;
			break;
		default:
			log_debug("%s: unexpected imsg %d", __func__,
			    imsg.hdr.type);
			break;
		}
		imsg_free(&imsg);
	}
	imsg_event_add(iev);
d394 4
a397 2
	int		 n, proc, done;
	struct imsg	 imsg;
d400 2
d405 4
a408 6
		imsg_compose_event(&iev_relay[proc],
		    IMSG_CTL_SESSION, 0, 0, -1, NULL, 0);
		while (iev_relay[proc].ibuf.w.queued)
			if (msgbuf_write(&iev_relay[proc].ibuf.w) < 0)
				fatalx("write error");

d416 1
a416 1
				if ((n = imsg_read(&iev_relay[proc].ibuf)) == -1)
d420 1
a420 2
				if ((n = imsg_get(&iev_relay[proc].ibuf,
				    &imsg)) == -1)
d424 1
d427 3
d431 2
a432 2
					    IMSG_CTL_SESSION, proc, 0, -1,
					    imsg.data, sizeof(struct rsession));
a514 1
	int		 n;
d532 1
a532 1
	imsg_compose_event(iev_hce, IMSG_TABLE_DISABLE, 0, 0, -1,
d534 1
d536 3
a538 4
	for (n = 0; n < env->sc_prefork_relay; n++)
		imsg_compose_event(&iev_relay[n],
		    IMSG_TABLE_DISABLE, 0, 0, -1,
		    &table->conf.id, sizeof(table->conf.id));
a548 1
	int		 n;
d568 1
a568 1
	imsg_compose_event(iev_hce, IMSG_TABLE_ENABLE, 0, 0, -1,
d570 1
d572 3
a574 4
	for (n = 0; n < env->sc_prefork_relay; n++)
		imsg_compose_event(&iev_relay[n],
		    IMSG_TABLE_ENABLE, 0, 0, -1,
		    &table->conf.id, sizeof(table->conf.id));
a584 1
	int		 n;
d613 1
a613 1
	imsg_compose_event(iev_hce, IMSG_HOST_DISABLE, 0, 0, -1,
d615 1
d617 2
a618 4
	for (n = 0; n < env->sc_prefork_relay; n++)
		imsg_compose_event(&iev_relay[n],
		    IMSG_HOST_DISABLE, 0, 0, -1,
		    &host->conf.id, sizeof(host->conf.id));
a633 1
	int		 n;
d653 1
a653 1
	imsg_compose_event(iev_hce, IMSG_HOST_ENABLE, 0, 0, -1,
d655 1
d657 3
a659 4
	for (n = 0; n < env->sc_prefork_relay; n++)
		imsg_compose_event(&iev_relay[n],
		    IMSG_HOST_ENABLE, 0, 0, -1,
		    &host->conf.id, sizeof(host->conf.id));
d769 1
a769 1
		imsg_compose_event(iev_main, IMSG_DEMOTE, 0, 0, -1,
@


1.66
log
@Add support for enable/disable table when using relays instead of redirects.
From Patrik Lundin and Linus Widstromer.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe.c,v 1.65 2010/08/01 22:18:35 sthen Exp $	*/
d286 1
a286 1
				log_debug("pfe_dispatch_imsg: host %d => %d",
d304 1
a304 1
			log_debug("pfe_dispatch_imsg: state %d for host %u %s",
d329 1
a329 1
			log_debug("pfe_dispatch_imsg: unexpected imsg %d",
d379 1
a379 1
			log_debug("pfe: reloading configuration");
d434 3
a436 3
			log_debug("pfe_dispatch_parent: rdr->table: %s",
			    rdr->table->conf.name);
			log_debug("pfe_dispatch_parent: rdr->backup: %s",
d448 1
a448 1
			log_warnx("pfe: configuration reloaded");
d454 1
a454 1
			log_debug("pfe_dispatch_parent: unexpected imsg %d",
d526 1
a526 1
			log_debug("pfe_dispatch_relay: unexpected imsg %d",
d697 1
a697 1
	log_debug("disable_rdr: disabled rdr %d", rdr->conf.id);
d722 1
a722 1
	log_debug("enable_rdr: enabled rdr %d", rdr->conf.id);
d768 1
a768 1
	log_debug("disable_table: disabled table %d", table->conf.id);
d805 1
a805 1
	log_debug("enable_table: enabled table %d", table->conf.id);
d851 1
a851 1
	log_debug("disable_host: disabled host %d", host->conf.id);
d893 1
a893 1
	log_debug("enable_host: enabled host %d", host->conf.id);
d947 1
a947 1
				log_debug("pfe_sync: disabling ruleset");
d957 1
a957 1
			log_debug("pfe_sync: enabling ruleset");
d998 1
a998 1
		log_debug("pfe_sync: demote %d table '%s' group '%s'",
@


1.65
log
@Allow fallback tables for relays, not just redirections.
Seems reasonable to jsg, ok phessler, no response from reyk or pyr
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe.c,v 1.64 2010/05/14 11:13:36 reyk Exp $	*/
a741 1
	struct rdr	*rdr;
d743 1
d752 1
a752 1
	if ((rdr = rdr_find(env, table->conf.rdrid)) == NULL)
d763 5
a775 1
	struct rdr	*rdr;
d778 1
d788 1
a788 1
	if ((rdr = rdr_find(env, table->conf.rdrid)) == NULL)
d800 5
@


1.64
log
@allocate all struct event's on the heap, it looks cleaner, feels better
and follows a suggestion in event.h.  also don't mix signal() and
signal_set()/signal_add().

ok jsg@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe.c,v 1.63 2009/08/17 11:36:01 reyk Exp $	*/
d587 9
@


1.63
log
@also report routers and their host states in relayctl

ok pyr@@, jmc@@ for man bits
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe.c,v 1.62 2009/08/13 13:51:21 reyk Exp $	*/
d62 5
a78 2
	struct event	 ev_sigint;
	struct event	 ev_sigterm;
d124 11
a134 6
	signal_set(&ev_sigint, SIGINT, pfe_sig_handler, NULL);
	signal_set(&ev_sigterm, SIGTERM, pfe_sig_handler, NULL);
	signal_add(&ev_sigint, NULL);
	signal_add(&ev_sigterm, NULL);
	signal(SIGPIPE, SIG_IGN);
	signal(SIGHUP, SIG_IGN);
@


1.62
log
@add new 'router' functionality to dynamically add or remove routes
based on health check results, using the existing table syntax.  this
allows to maintain multiple (uplink) gateways to implement link
balancing or WAN link failover if no routing protocol or other
keepalive method is available.  works fine with or without
net.inet.ip.multipath enabled.

ok pyr@@, jmc@@ for manpages
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe.c,v 1.61 2009/08/07 11:21:53 reyk Exp $	*/
d533 2
d565 1
a565 1
		goto end;
d582 21
@


1.61
log
@rename 'struct session' to 'struct rsession' because it conflicts with
another 'struct session' in sys/sysctl.h.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe.c,v 1.60 2009/06/05 23:39:51 pyr Exp $	*/
d863 1
d916 8
@


1.60
log
@4 handed diff with eric:
Stop pushing event handling in the imsg framework.
Instead, provide a small glue layer on top of both imsg and libevent.
This finally clearly separates event handling and imsg construction.

Sidetrack bonus: remove the mega-ugly hack of having a dummy imsg_event_add
stub in relayctl.

This will make bgpd (and thus henning) happy. Next up are smtpd and ospfd.

ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe.c,v 1.59 2009/06/05 00:20:50 pyr Exp $	*/
d620 1
a620 1
					    imsg.data, sizeof(struct session));
@


1.59
log
@some KNF cleanup following the last sed.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe.c,v 1.58 2009/06/05 00:04:01 pyr Exp $	*/
d50 3
a52 3
struct imsgbuf	*ibuf_main;
struct imsgbuf	*ibuf_hce;
struct imsgbuf	*ibuf_relay;
d139 4
a142 4
	size = sizeof(struct imsgbuf);
	if ((ibuf_hce = calloc(1, size)) == NULL ||
	    (ibuf_relay = calloc(env->sc_prefork_relay, size)) == NULL ||
	    (ibuf_main = calloc(1, size)) == NULL)
d145 8
a152 5
	imsg_init(ibuf_hce, pipe_pfe2hce[1], pfe_dispatch_imsg);
	imsg_init(ibuf_main, pipe_parent2pfe[1], pfe_dispatch_parent);
	for (i = 0; i < env->sc_prefork_relay; i++)
		imsg_init(&ibuf_relay[i], pipe_pfe2relay[i][1],
		    pfe_dispatch_relay);
d154 4
a157 4
	ibuf_main->events = EV_READ;
	event_set(&ibuf_main->ev, ibuf_main->fd, ibuf_main->events,
	    ibuf_main->handler, ibuf_main);
	event_add(&ibuf_main->ev, NULL);
d163 1
a163 1
	if (control_listen(env, ibuf_main, ibuf_hce) == -1)
d187 1
a187 1
	struct imsgbuf	*ibuf;
d190 4
a193 4
	ibuf_hce->events = EV_READ;
	event_set(&ibuf_hce->ev, ibuf_hce->fd, ibuf_hce->events,
	    ibuf_hce->handler, ibuf_hce);
	event_add(&ibuf_hce->ev, NULL);
d196 1
a196 1
		ibuf = &ibuf_relay[i];
d198 4
a201 4
		ibuf->events = EV_READ;
		event_set(&ibuf->ev, ibuf->fd, ibuf->events,
		    ibuf->handler, ibuf);
		event_add(&ibuf->ev, NULL);
d215 1
a215 1
	event_del(&ibuf_hce->ev);
d218 1
a218 1
		event_del(&ibuf_relay[i].ev);
d226 1
d235 2
a236 1
	ibuf = ptr;
d243 1
a243 1
			event_del(&ibuf->ev);
d288 1
a288 1
				imsg_compose_event(&ibuf_relay[n],
d327 1
a327 1
	imsg_event_add(ibuf);
d333 1
d343 2
a344 1
	ibuf = ptr;
d351 1
a351 1
			event_del(&ibuf->ev);
d452 1
a452 1
	imsg_event_add(ibuf);
d458 1
d466 2
a467 1
	ibuf = ptr;
d474 1
a474 1
			event_del(&ibuf->ev);
d501 1
a501 1
			imsg_compose_event(&ibuf_relay[cnl.proc], IMSG_NATLOOK,
d524 1
a524 1
	imsg_event_add(ibuf);
d537 1
a537 1
		imsg_compose_event(&c->ibuf, IMSG_CTL_RDR, 0, 0, -1,
d542 1
a542 1
		imsg_compose_event(&c->ibuf, IMSG_CTL_RDR_STATS, 0, 0, -1,
d545 1
a545 1
		imsg_compose_event(&c->ibuf, IMSG_CTL_TABLE, 0, 0, -1,
d549 1
a549 1
				imsg_compose_event(&c->ibuf, IMSG_CTL_HOST,
d554 1
a554 1
		imsg_compose_event(&c->ibuf, IMSG_CTL_TABLE, 0, 0, -1,
d558 1
a558 1
				imsg_compose_event(&c->ibuf, IMSG_CTL_HOST,
d566 1
a566 1
		imsg_compose_event(&c->ibuf, IMSG_CTL_RELAY, 0, 0, -1,
d568 1
a568 1
		imsg_compose_event(&c->ibuf, IMSG_CTL_RELAY_STATS, 0, 0, -1,
d573 1
a573 1
		imsg_compose_event(&c->ibuf, IMSG_CTL_TABLE, 0, 0, -1,
d577 1
a577 1
				imsg_compose_event(&c->ibuf, IMSG_CTL_HOST,
d581 1
a581 1
	imsg_compose_event(&c->ibuf, IMSG_CTL_END, 0, 0, -1, NULL, 0);
d594 1
a594 1
		imsg_compose_event(&ibuf_relay[proc],
d596 2
a597 2
		while (ibuf_relay[proc].w.queued)
			if (msgbuf_write(&ibuf_relay[proc].w) < 0)
d607 1
a607 1
				if ((n = imsg_read(&ibuf_relay[proc])) == -1)
d611 1
a611 1
				if ((n = imsg_get(&ibuf_relay[proc],
d618 1
a618 1
					imsg_compose_event(&c->ibuf,
d634 1
a634 1
	imsg_compose_event(&c->ibuf, IMSG_CTL_END, 0, 0, -1, NULL, 0);
d721 1
a721 1
	imsg_compose_event(ibuf_hce, IMSG_TABLE_DISABLE, 0, 0, -1,
d753 1
a753 1
	imsg_compose_event(ibuf_hce, IMSG_TABLE_ENABLE, 0, 0, -1,
d794 1
a794 1
	imsg_compose_event(ibuf_hce, IMSG_HOST_DISABLE, 0, 0, -1,
d798 1
a798 1
		imsg_compose_event(&ibuf_relay[n],
d836 1
a836 1
	imsg_compose_event(ibuf_hce, IMSG_HOST_ENABLE, 0, 0, -1,
d840 1
a840 1
		imsg_compose_event(&ibuf_relay[n],
d943 1
a943 1
		imsg_compose_event(ibuf_main, IMSG_DEMOTE, 0, 0, -1,
@


1.58
log
@Make imsg completely async model agnostic by not requiring an
imsg_event_add function to be provided (which ended up being a named
callback).
Instead provide a wrapper in the daemon and call that everywhere.
Previsously discussed with the usual suspects,
ok eric@@ though not too happy about the function name
(imsg_compose_event).
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe.c,v 1.57 2009/06/02 12:24:16 reyk Exp $	*/
d492 2
a493 2
			imsg_compose_event(&ibuf_relay[cnl.proc], IMSG_NATLOOK, 0, 0,
			    -1, &cnl, sizeof(cnl));
d540 2
a541 2
				imsg_compose_event(&c->ibuf, IMSG_CTL_HOST, 0, 0, -1,
				    host, sizeof(*host));
d549 2
a550 2
				imsg_compose_event(&c->ibuf, IMSG_CTL_HOST, 0, 0, -1,
				    host, sizeof(*host));
d568 2
a569 2
				imsg_compose_event(&c->ibuf, IMSG_CTL_HOST, 0, 0, -1,
				    host, sizeof(*host));
@


1.57
log
@remove extra imsg_event_add() after EV_WRITE checks - this is not
required because it is called later and there is no return before.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe.c,v 1.56 2009/06/02 11:33:06 reyk Exp $	*/
d283 1
a283 1
				imsg_compose(&ibuf_relay[n],
d492 1
a492 1
			imsg_compose(&ibuf_relay[cnl.proc], IMSG_NATLOOK, 0, 0,
d528 1
a528 1
		imsg_compose(&c->ibuf, IMSG_CTL_RDR, 0, 0, -1,
d533 1
a533 1
		imsg_compose(&c->ibuf, IMSG_CTL_RDR_STATS, 0, 0, -1,
d536 1
a536 1
		imsg_compose(&c->ibuf, IMSG_CTL_TABLE, 0, 0, -1,
d540 1
a540 1
				imsg_compose(&c->ibuf, IMSG_CTL_HOST, 0, 0, -1,
d545 1
a545 1
		imsg_compose(&c->ibuf, IMSG_CTL_TABLE, 0, 0, -1,
d549 1
a549 1
				imsg_compose(&c->ibuf, IMSG_CTL_HOST, 0, 0, -1,
d557 1
a557 1
		imsg_compose(&c->ibuf, IMSG_CTL_RELAY, 0, 0, -1,
d559 1
a559 1
		imsg_compose(&c->ibuf, IMSG_CTL_RELAY_STATS, 0, 0, -1,
d564 1
a564 1
		imsg_compose(&c->ibuf, IMSG_CTL_TABLE, 0, 0, -1,
d568 1
a568 1
				imsg_compose(&c->ibuf, IMSG_CTL_HOST, 0, 0, -1,
d572 1
a572 1
	imsg_compose(&c->ibuf, IMSG_CTL_END, 0, 0, -1, NULL, 0);
d585 1
a585 1
		imsg_compose(&ibuf_relay[proc],
d609 1
a609 1
					imsg_compose(&c->ibuf,
d625 1
a625 1
	imsg_compose(&c->ibuf, IMSG_CTL_END, 0, 0, -1, NULL, 0);
d712 1
a712 1
	imsg_compose(ibuf_hce, IMSG_TABLE_DISABLE, 0, 0, -1,
d744 1
a744 1
	imsg_compose(ibuf_hce, IMSG_TABLE_ENABLE, 0, 0, -1,
d785 1
a785 1
	imsg_compose(ibuf_hce, IMSG_HOST_DISABLE, 0, 0, -1,
d789 1
a789 1
		imsg_compose(&ibuf_relay[n],
d827 1
a827 1
	imsg_compose(ibuf_hce, IMSG_HOST_ENABLE, 0, 0, -1,
d831 1
a831 1
		imsg_compose(&ibuf_relay[n],
d934 1
a934 1
		imsg_compose(ibuf_main, IMSG_DEMOTE, 0, 0, -1,
@


1.56
log
@Libevent may do an upcall with both EV_READ and EV_WRITE set.
So change the code accordingly to allow that.

Found by claudio@@ in ospfd
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe.c,v 1.55 2009/04/17 09:47:06 reyk Exp $	*/
a246 2
		imsg_event_add(ibuf);
		return;
a353 2
		imsg_event_add(ibuf);
		return;
a473 2
		imsg_event_add(ibuf);
		return;
@


1.55
log
@keep the parent relations of hosts after reloading the configuration.

From Camiel Dobbelaar, closes PR 6066
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe.c,v 1.54 2009/04/01 15:05:06 reyk Exp $	*/
d232 2
a233 2
	switch (event) {
	case EV_READ:
d242 3
a244 2
		break;
	case EV_WRITE:
a248 2
	default:
		fatalx("pfe_dispatch_imsg: unknown event");
d340 2
a341 2
	switch (event) {
	case EV_READ:
d350 4
a353 2
		break;
	case EV_WRITE:
a357 2
	default:
		fatalx("pfe_dispatch_parent: unknown event");
d463 2
a464 2
	switch (event) {
	case EV_READ:
d473 3
a475 2
		break;
	case EV_WRITE:
a479 2
	default:
		fatalx("unknown event");
@


1.54
log
@re-initialize tables after reload to handle new and changed tables.

From Pascal Lalonde, closes PR 6112
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe.c,v 1.53 2008/12/05 16:37:55 reyk Exp $	*/
d337 1
a337 1
	struct host		*host;
d403 5
@


1.53
log
@change the way relayd reports check results: instead of logging an
arbitrary string in debugging mode, it will store an error code
(HCE_*) for each host.  the error code can be translated to a string
(in log.c) for debugging but it will also be passed to relayctl via
the control socket.

from a user point of view, this will print a human-readable error
message in the "relayctl show hosts" output if a host is down because
the check failed.  the relayctl(8) manpage includes detailed
explanations of the error messages including mitigations for the
most-common problems.

ok jmc@@ (manpages)
ok phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe.c,v 1.52 2008/09/03 13:41:49 jsg Exp $	*/
d434 1
@


1.52
log
@Missing breaks.
ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe.c,v 1.51 2008/08/08 08:51:21 thib Exp $	*/
d266 1
@


1.51
log
@Check gettimeofday() against -1; Add a missing error check in one place.

OK reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe.c,v 1.50 2008/07/19 11:38:54 reyk Exp $	*/
d61 1
@


1.50
log
@no need for using a TAILQ queue for the host children list, use a
singly-linked SLIST instead.  the only noticeable change is the
reversed order to notify the children but it does not really matter
here.  also only walk through the children host list if the host
itself is a potential parent.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe.c,v 1.49 2008/07/19 10:52:32 reyk Exp $	*/
d949 1
a949 1
	if (gettimeofday(&tv_now, NULL))
@


1.49
log
@If the new 'parent' keyword is specified for a host in a table,
inherit the state from another host with the specified Id; no
additional check will be for the inheriting host.  This helps in
scenarios with lots of IP aliases that all point to the same service
on the same host (like web hosting with many SSL domains).

discussed with pyr, tested in different setups
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe.c,v 1.48 2008/01/31 09:56:28 reyk Exp $	*/
d794 4
a797 5
	/* Disable all children */
	TAILQ_FOREACH(h, &host->children, child)
		disable_host(c, id, h);

	if (!host->conf.parentid)
d799 1
d836 4
a839 5
	/* Enable all children */
	TAILQ_FOREACH(h, &host->children, child)
		enable_host(c, id, h);

	if (!host->conf.parentid)
d841 1
@


1.48
log
@add prefixes to names of structure elements to make it easier to grep
for code, next struct relay.  knf long line fixes will follow later.

ok thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe.c,v 1.47 2008/01/31 09:33:39 reyk Exp $	*/
d752 1
a752 1
disable_host(struct ctl_conn *c, struct ctl_id *id)
d754 1
a754 1
	struct host	*host;
d758 8
a765 6
	if (id->id == EMPTY_ID)
		host = host_findbyname(env, id->name);
	else
		host = host_find(env, id->id);
	if (host == NULL)
		return (-1);
d793 7
a799 1
	pfe_sync();
d804 1
a804 1
enable_host(struct ctl_conn *c, struct ctl_id *id)
d806 1
a806 1
	struct host	*host;
d809 8
a816 6
	if (id->id == EMPTY_ID)
		host = host_findbyname(env, id->name);
	else
		host = host_find(env, id->id);
	if (host == NULL)
		return (-1);
d835 7
a841 1
	pfe_sync();
@


1.47
log
@add prefixes to names of structure elements to make it easier to grep
for code, start with struct relayd.  finally.

ok thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe.c,v 1.46 2007/12/20 20:15:43 reyk Exp $	*/
d504 2
a505 2
			bcopy(&crs, &rlay->stats[crs.proc], sizeof(crs));
			rlay->stats[crs.proc].interval =
d555 2
a556 2
	TAILQ_FOREACH(rlay, env->sc_relays, entry) {
		rlay->stats[env->sc_prefork_relay].id = EMPTY_ID;
d560 1
a560 1
		    &rlay->stats, sizeof(rlay->stats));
d562 1
a562 1
		if (rlay->dsttable == NULL)
d565 3
a567 3
		    rlay->dsttable, sizeof(*rlay->dsttable));
		if (!(rlay->dsttable->conf.flags & F_DISABLE))
			TAILQ_FOREACH(host, &rlay->dsttable->hosts, entry)
@


1.46
log
@implement statistics for redirections, like the existing statistics
for relays.  they can be viewed with the new "relayctl show redirects"
command.

(uses the previous change to pf_table.c to get the statistics)

looks good pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe.c,v 1.45 2007/12/08 20:36:36 pyr Exp $	*/
d132 1
a132 1
	for (i = 0; i < env->prefork_relay; i++) {
d140 1
a140 1
	    (ibuf_relay = calloc(env->prefork_relay, size)) == NULL ||
d146 1
a146 1
	for (i = 0; i < env->prefork_relay; i++)
d191 1
a191 1
	for (i = 0; i < env->prefork_relay; i++) {
d201 3
a203 3
	evtimer_set(&env->statev, pfe_statistics, NULL);
	bcopy(&env->statinterval, &tv, sizeof(tv));
	evtimer_add(&env->statev, &tv);
d213 1
a213 1
	for (i = 0; i < env->prefork_relay; i++)
d216 1
a216 1
	event_del(&env->statev);
d283 1
a283 1
			for (n = 0; n < env->prefork_relay; n++)
d377 2
a378 2
			env->relays = NULL;
			env->protos = NULL;
d380 3
a382 3
			env->tables = calloc(1, sizeof(*env->tables));
			env->rdrs = calloc(1, sizeof(*env->rdrs));
			if (env->tables == NULL || env->rdrs == NULL)
d385 2
a386 2
			TAILQ_INIT(env->tables);
			TAILQ_INIT(env->rdrs);
d393 1
a393 1
			TAILQ_INSERT_TAIL(env->tables, table, entry);
d410 1
a410 1
				rdr->backup = &env->empty_table;
d422 1
a422 1
			TAILQ_INSERT_TAIL(env->rdrs, rdr, entry);
d487 1
a487 1
			if (cnl.proc > env->prefork_relay)
d499 1
a499 1
			if (crs.proc > env->prefork_relay)
d506 1
a506 1
			    env->statinterval.tv_sec;
d525 1
a525 1
	if (env->rdrs == NULL)
d527 1
a527 1
	TAILQ_FOREACH(rdr, env->rdrs, entry) {
d553 1
a553 1
	if (env->relays == NULL)
d555 2
a556 2
	TAILQ_FOREACH(rlay, env->relays, entry) {
		rlay->stats[env->prefork_relay].id = EMPTY_ID;
d581 1
a581 1
	for (proc = 0; proc < env->prefork_relay; proc++) {
d786 1
a786 1
	for (n = 0; n < env->prefork_relay; n++)
d820 1
a820 1
	for (n = 0; n < env->prefork_relay; n++)
d841 1
a841 1
	TAILQ_FOREACH(rdr, env->rdrs, entry) {
d892 1
a892 1
	TAILQ_FOREACH(table, env->tables, entry) {
d936 1
a936 1
	TAILQ_FOREACH(rdr, env->rdrs, entry) {
d950 1
a950 1
		if ((cur->tick % (3600 / env->statinterval.tv_sec)) == 0) {
d955 1
a955 1
		if ((cur->tick % (86400 / env->statinterval.tv_sec)) == 0) {
d964 1
a964 1
		rdr->stats.interval = env->statinterval.tv_sec;
d968 3
a970 3
	evtimer_set(&env->statev, pfe_statistics, NULL);
	bcopy(&env->statinterval, &tv, sizeof(tv));
	evtimer_add(&env->statev, &tv);
@


1.45
log
@Rename everything which reffered to services refer to rdr for internals
(for instance: rename struct service to struct rdr), refer to redirects
otherwise (hoststatectl output).
ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe.c,v 1.44 2007/12/07 17:17:00 reyk Exp $	*/
a44 1

d46 1
d184 1
d199 5
d215 2
d533 3
d559 1
a559 1
		imsg_compose(&c->ibuf, IMSG_CTL_STATISTICS, 0, 0, -1,
d921 50
@


1.44
log
@hoststated gets renamed to relayd.  easier to type, and actually says
what the daemon does - it is a relayer that pays attention to the status
of pools of hosts; not a status checkers that happens to do some relaying
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe.c,v 1.43 2007/11/24 17:07:28 reyk Exp $	*/
d325 1
a325 1
	static struct service	*service = NULL;
d364 1
a364 1
			purge_config(env, PURGE_SERVICES|PURGE_TABLES);
d373 2
a374 2
			env->services = calloc(1, sizeof(*env->services));
			if (env->tables == NULL || env->services == NULL)
d378 1
a378 1
			TAILQ_INIT(env->services);
d394 2
a395 2
		case IMSG_RECONF_SERVICE:
			if ((service = calloc(1, sizeof(*service))) == NULL)
d397 6
a402 6
			memcpy(&service->conf, imsg.data,
			    sizeof(service->conf));
			service->table = table_find(env,
			     service->conf.table_id);
			if (service->conf.backup_id == EMPTY_TABLE)
				service->backup = &env->empty_table;
d404 3
a406 3
				service->backup = table_find(env,
				    service->conf.backup_id);
			if (service->table == NULL || service->backup == NULL)
d409 6
a414 6
			log_debug("pfe_dispatch_parent: service->table: %s",
			    service->table->conf.name);
			log_debug("pfe_dispatch_parent: service->backup: %s",
			    service->backup->conf.name);
			TAILQ_INIT(&service->virts);
			TAILQ_INSERT_TAIL(env->services, service, entry);
d420 1
a420 1
			TAILQ_INSERT_TAIL(&service->virts, virt, entry);
d513 1
a513 1
	struct service	*service;
d517 1
a517 1
	if (env->services == NULL)
d519 4
a522 4
	TAILQ_FOREACH(service, env->services, entry) {
		imsg_compose(&c->ibuf, IMSG_CTL_SERVICE, 0, 0, -1,
		    service, sizeof(*service));
		if (service->conf.flags & F_DISABLE)
d526 3
a528 3
		    service->table, sizeof(*service->table));
		if (!(service->table->conf.flags & F_DISABLE))
			TAILQ_FOREACH(host, &service->table->hosts, entry)
d532 1
a532 1
		if (service->backup->conf.id == EMPTY_TABLE)
d535 3
a537 3
		    service->backup, sizeof(*service->backup));
		if (!(service->backup->conf.flags & F_DISABLE))
			TAILQ_FOREACH(host, &service->backup->hosts, entry)
d618 1
a618 1
disable_service(struct ctl_conn *c, struct ctl_id *id)
d620 1
a620 1
	struct service	*service;
d623 1
a623 1
		service = service_findbyname(env, id->name);
d625 2
a626 2
		service = service_find(env, id->id);
	if (service == NULL)
d628 1
a628 1
	id->id = service->conf.id;
d630 1
a630 1
	if (service->conf.flags & F_DISABLE)
d633 5
a637 5
	service->conf.flags |= F_DISABLE;
	service->conf.flags &= ~(F_ADD);
	service->conf.flags |= F_DEL;
	service->table->conf.flags |= F_DISABLE;
	log_debug("disable_service: disabled service %d", service->conf.id);
d643 1
a643 1
enable_service(struct ctl_conn *c, struct ctl_id *id)
d645 1
a645 1
	struct service	*service;
d649 1
a649 1
		service = service_findbyname(env, id->name);
d651 2
a652 2
		service = service_find(env, id->id);
	if (service == NULL)
d654 1
a654 1
	id->id = service->conf.id;
d656 1
a656 1
	if (!(service->conf.flags & F_DISABLE))
d659 4
a662 4
	service->conf.flags &= ~(F_DISABLE);
	service->conf.flags &= ~(F_DEL);
	service->conf.flags |= F_ADD;
	log_debug("enable_service: enabled service %d", service->conf.id);
d667 1
a667 1
	eid.id = service->table->conf.id;
d670 1
a670 1
	if (service->backup->conf.id == EMPTY_ID)
d672 1
a672 1
	eid.id = service->backup->conf.id;
d682 1
a682 1
	struct service	*service;
d692 1
a692 1
	if ((service = service_find(env, table->conf.serviceid)) == NULL)
d711 1
a711 1
	struct service	*service;
d723 1
a723 1
	if ((service = service_find(env, table->conf.serviceid)) == NULL)
d821 1
a821 1
	struct service		*service;
d830 7
a836 7
	TAILQ_FOREACH(service, env->services, entry) {
		service->conf.flags &= ~(F_BACKUP);
		service->conf.flags &= ~(F_DOWN);

		if (service->conf.flags & F_DISABLE ||
		    (service->table->up == 0 && service->backup->up == 0)) {
			service->conf.flags |= F_DOWN;
d838 3
a840 3
		} else if (service->table->up == 0 && service->backup->up > 0) {
			service->conf.flags |= F_BACKUP;
			active = service->backup;
d842 1
a842 1
			    service->table->conf.flags & F_CHANGED;
d844 1
a844 1
			    service->backup->conf.flags & F_CHANGED;
d846 1
a846 1
			active = service->table;
d853 1
a853 1
			sync_table(env, service, active);
d857 3
a859 3
		if (service->conf.flags & F_DOWN) {
			if (service->conf.flags & F_ACTIVE_RULESET) {
				flush_table(env, service);
d861 2
a862 2
				service->conf.flags &= ~(F_ACTIVE_RULESET);
				id.id = service->conf.id;
d866 1
a866 1
				sync_ruleset(env, service, 0);
d869 1
a869 1
		} else if (!(service->conf.flags & F_ACTIVE_RULESET)) {
d871 2
a872 2
			service->conf.flags |= F_ACTIVE_RULESET;
			id.id = service->conf.id;
d876 1
a876 1
			sync_ruleset(env, service, 1);
@


1.43
log
@sort includes, adjust to style(9)
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe.c,v 1.42 2007/11/19 15:31:36 reyk Exp $	*/
d36 1
a36 1
#include "hoststated.h"
d48 1
a48 1
static struct hoststated	*env = NULL;
d67 1
a67 1
pfe(struct hoststated *x_env, int pipe_parent2pfe[2], int pipe_parent2hce[2],
d96 1
a96 1
	if ((pw = getpwnam(HOSTSTATED_USER)) == NULL)
d109 1
a109 1
	hoststated_process = PROC_PFE;
d361 1
a361 1
			    sizeof(struct hoststated) + IMSG_HEADER_SIZE)
d365 1
a365 1
			merge_config(env, (struct hoststated *)imsg.data);
@


1.42
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe.c,v 1.41 2007/11/15 17:02:01 pyr Exp $	*/
a18 1
#include <sys/queue.h>
a19 1
#include <sys/types.h>
d23 1
d25 1
@


1.41
log
@Do not insert proto_default inside the dynamically alloced protocol queue.
Handle it as a special case in the one place where it actually matters
instead.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe.c,v 1.40 2007/11/14 15:25:26 pyr Exp $	*/
d278 1
a278 1
				        sizeof(st));
d806 1
a806 1
	imsg_compose(ibuf_hce, IMSG_HOST_ENABLE, 0, 0, -1, 
d886 1
a886 1
		
@


1.40
log
@do go through relays when none exist.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe.c,v 1.39 2007/10/30 21:04:45 reyk Exp $	*/
d364 1
a364 1
			purge_config(env, PURGE_EVERYTHING);
d366 5
@


1.39
log
@untangle a mess in the state update logic
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe.c,v 1.38 2007/10/19 14:15:14 pyr Exp $	*/
d512 2
d536 3
d555 1
a555 1

@


1.38
log
@Move relays from static TAILQs to allocated ones.
This syncs it with other hoststated entities and will make reload easier.
This is step 1 out of 7 for reload.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe.c,v 1.37 2007/10/19 12:08:55 pyr Exp $	*/
d287 5
a291 7
			if ((st.up == HOST_UNKNOWN && !HOST_ISUP(host->up)) ||
			    (!HOST_ISUP(st.up) && host->up == HOST_UNKNOWN)) {
				host->up = st.up;
				break;
			}

			if (st.up == HOST_UP) {
d296 1
a296 2
				host->up = HOST_UP;
			} else {
d302 1
@


1.37
log
@Add the ability to schedule an immediate check through hoststatectl.
Especially useful when interval is rather long.
I was supposed to commit this before 4.2.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe.c,v 1.36 2007/09/28 13:29:56 pyr Exp $	*/
d536 1
a536 1
	TAILQ_FOREACH(rlay, &env->relays, entry) {
@


1.36
log
@Correct my mail address.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe.c,v 1.35 2007/09/27 07:32:50 pyr Exp $	*/
d159 1
a159 1
	if (control_listen(env, ibuf_main) == -1)
@


1.35
log
@Do not clear the changed flag to early, which prevented a table
from being used by several services.
``looks fine'' reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe.c,v 1.34 2007/09/07 08:20:24 reyk Exp $	*/
d4 1
a4 1
 * Copyright (c) 2006 Pierre-Yves Ritschard <pyr@@spootnik.org>
@


1.34
log
@add an interface to dump running relay sessions to the control socket
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe.c,v 1.33 2007/06/19 13:06:00 pyr Exp $	*/
a848 3
		service->table->conf.flags &= ~(F_CHANGED);
		service->backup->conf.flags &= ~(F_CHANGED);

d874 8
@


1.33
log
@don't go through the effort of creating a SIGHUP handler through
libevent just to ignore it, use SIG_IGN instead.
this syncs hoststated with bgpd and (soon) ospfd.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe.c,v 1.32 2007/06/19 06:29:20 pyr Exp $	*/
d556 52
@


1.32
log
@Do not fatal out with ``pipe closed'' when a short read occurs on one
of our socket pairs. Instead disable listening on the pipe, terminate the
event loop, and let the parent process's SIGCHLD handler do a clean
shutdown.

from an ospfd diff by claudio, ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe.c,v 1.31 2007/06/12 15:16:10 msf Exp $	*/
a60 3
	case SIGHUP:
		/* nothing */
		break;
a74 1
	struct event	 ev_sighup;
a121 1
	signal_set(&ev_sighup, SIGHUP, pfe_sig_handler, NULL);
a123 1
	signal_add(&ev_sighup, NULL);
d125 1
@


1.31
log
@put the fd passing from bgpd back in to hoststated's version of imsg,
needed for layer 7 reload support.

ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe.c,v 1.30 2007/06/07 07:19:50 pyr Exp $	*/
d232 6
a237 2
		if (n == 0)
			fatalx("pfe_dispatch_imsg: pipe closed");
d342 6
a347 2
		if (n == 0)
			fatalx("pfe_dispatch_parent: pipe closed");
d454 6
a459 2
		if (n == 0)
			fatalx("pfe_dispatch_relay: pipe closed");
@


1.30
log
@(finally) Enable reload support for layer 3 configurations.
Hoststated can be reloaded either by sending SIGHUP to the parent process
or by using ``hoststatectl reload''
discussed and ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe.c,v 1.29 2007/05/31 18:24:02 pyr Exp $	*/
d278 2
a279 1
				    IMSG_HOST_STATUS, 0, 0, &st, sizeof(st));
d475 1
a475 1
			    &cnl, sizeof(cnl));
d508 1
a508 1
		imsg_compose(&c->ibuf, IMSG_CTL_SERVICE, 0, 0,
d513 1
a513 1
		imsg_compose(&c->ibuf, IMSG_CTL_TABLE, 0, 0,
d517 1
a517 1
				imsg_compose(&c->ibuf, IMSG_CTL_HOST, 0, 0,
d522 1
a522 1
		imsg_compose(&c->ibuf, IMSG_CTL_TABLE, 0, 0,
d526 1
a526 1
				imsg_compose(&c->ibuf, IMSG_CTL_HOST, 0, 0,
d531 1
a531 1
		imsg_compose(&c->ibuf, IMSG_CTL_RELAY, 0, 0,
d533 1
a533 1
		imsg_compose(&c->ibuf, IMSG_CTL_STATISTICS, 0, 0,
d538 1
a538 1
		imsg_compose(&c->ibuf, IMSG_CTL_TABLE, 0, 0,
d542 1
a542 1
				imsg_compose(&c->ibuf, IMSG_CTL_HOST, 0, 0,
d546 1
a546 1
	imsg_compose(&c->ibuf, IMSG_CTL_END, 0, 0, NULL, 0);
d634 1
a634 1
	imsg_compose(ibuf_hce, IMSG_TABLE_DISABLE, 0, 0,
d666 1
a666 1
	imsg_compose(ibuf_hce, IMSG_TABLE_ENABLE, 0, 0,
d705 1
a705 1
	imsg_compose(ibuf_hce, IMSG_HOST_DISABLE, 0, 0,
d710 1
a710 1
		    IMSG_HOST_DISABLE, 0, 0,
d739 1
a739 1
	imsg_compose(ibuf_hce, IMSG_HOST_ENABLE, 0, 0,
d744 1
a744 1
		    IMSG_HOST_ENABLE, 0, 0,
d835 1
a835 1
		imsg_compose(ibuf_main, IMSG_DEMOTE, 0, 0,
@


1.29
log
@simplify pfe_disable_events
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe.c,v 1.28 2007/05/31 15:49:26 pyr Exp $	*/
d61 3
d78 1
d108 2
d126 1
d129 1
d327 5
d356 64
@


1.28
log
@split pfe's event registration in separate functions (like for hce)
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe.c,v 1.27 2007/05/31 03:24:05 pyr Exp $	*/
d200 1
a200 2
	int		 i;
	struct imsgbuf	*ibuf;
d204 2
a205 4
	for (i = 0; i < env->prefork_relay; i++) {
		ibuf = &ibuf_relay[i];
		event_del(&ibuf->ev);
	}
@


1.27
log
@allocate table lists and service lists instead of using static structs.
split the code to start the event loop in two functions.
introduce merge_config which will be used later on.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe.c,v 1.26 2007/05/29 23:42:15 pyr Exp $	*/
d40 2
a75 1
	struct imsgbuf	*ibuf;
d99 1
d104 1
d109 1
d114 1
d140 1
d143 3
a145 5

	ibuf_hce->events = EV_READ;
	event_set(&ibuf_hce->ev, ibuf_hce->fd, ibuf_hce->events,
	    ibuf_hce->handler, ibuf_hce);
	event_add(&ibuf_hce->ev, NULL);
d152 1
a152 9
	for (i = 0; i < env->prefork_relay; i++) {
		ibuf = &ibuf_relay[i];
		imsg_init(ibuf, pipe_pfe2relay[i][1], pfe_dispatch_relay);

		ibuf->events = EV_READ;
		event_set(&ibuf->ev, ibuf->fd, ibuf->events,
		    ibuf->handler, ibuf);
		event_add(&ibuf->ev, NULL);
	}
d174 35
@


1.26
log
@when the time comes, let pfe_dispatch_parent be able to service more
than one message.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe.c,v 1.25 2007/05/29 23:19:18 pyr Exp $	*/
d401 1
a401 1
	TAILQ_FOREACH(service, &env->services, entry) {
d657 1
a657 1
	TAILQ_FOREACH(service, &env->services, entry) {
d711 1
a711 1
	TAILQ_FOREACH(table, &env->tables, entry) {
@


1.25
log
@allow the control handling code to send messages back to the parent.
forward IMSG_CTL_RELOAD which ends up not doing anything for now.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe.c,v 1.24 2007/05/28 22:11:33 pyr Exp $	*/
d322 1
@


1.24
log
@another small step towards hoststated reloading.
allow purging of parts of the hoststated environment structure.
start using this function now to only keep vital information in
hoststated children processes.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe.c,v 1.23 2007/05/27 20:53:10 pyr Exp $	*/
d160 1
a160 1
	if (control_listen() == -1)
@


1.23
log
@Second step towards hoststated reload:
First split out hosts, tables and services into to structs, one that
contains the runtime fields and one (inside the runtime) that contains
mostly static fields that will be sent over the socket during reload.

Also move the demoted field of tables inside the flags field as its
just a boolean.
ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe.c,v 1.22 2007/05/26 19:58:49 pyr Exp $	*/
d87 1
@


1.22
log
@first steps for implementing reload:
	* make parse_config allocate the hoststated function by itself
	* make as many sockets as necessary to talk to the relay children
	* add send_all for talking to all children
with advise and ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe.c,v 1.21 2007/05/09 13:05:42 pyr Exp $	*/
d231 1
a231 1
				    host->id, host->up);
d243 2
a244 1
			if ((table = table_find(env, host->tableid)) == NULL)
d248 1
a248 1
			    st.up, host->id, host->name);
d257 1
a257 1
				table->flags |= F_CHANGED;
d264 1
a264 1
				table->flags |= F_CHANGED;
d402 1
a402 1
		if (service->flags & F_DISABLE)
d407 1
a407 1
		if (!(service->table->flags & F_DISABLE))
d412 1
a412 1
		if (service->backup->id == EMPTY_TABLE)
d416 1
a416 1
		if (!(service->backup->flags & F_DISABLE))
d432 1
a432 1
		if (!(rlay->dsttable->flags & F_DISABLE))
d453 1
a453 1
	id->id = service->id;
d455 1
a455 1
	if (service->flags & F_DISABLE)
d458 5
a462 5
	service->flags |= F_DISABLE;
	service->flags &= ~(F_ADD);
	service->flags |= F_DEL;
	service->table->flags |= F_DISABLE;
	log_debug("disable_service: disabled service %d", service->id);
d479 1
a479 1
	id->id = service->id;
d481 1
a481 1
	if (!(service->flags & F_DISABLE))
d484 4
a487 4
	service->flags &= ~(F_DISABLE);
	service->flags &= ~(F_DEL);
	service->flags |= F_ADD;
	log_debug("enable_service: enabled service %d", service->id);
d492 1
a492 1
	eid.id = service->table->id;
d495 1
a495 1
	if (service->backup->id == EMPTY_ID)
d497 1
a497 1
	eid.id = service->backup->id;
d516 2
a517 2
	id->id = table->id;
	if ((service = service_find(env, table->serviceid)) == NULL)
d520 1
a520 1
	if (table->flags & F_DISABLE)
d522 1
a522 1
	table->flags |= (F_DISABLE|F_CHANGED);
d527 2
a528 2
	    &table->id, sizeof(table->id));
	log_debug("disable_table: disabled table %d", table->id);
d546 1
a546 1
	id->id = table->id;
d548 1
a548 1
	if ((service = service_find(env, table->serviceid)) == NULL)
d551 1
a551 1
	if (!(table->flags & F_DISABLE))
d553 2
a554 2
	table->flags &= ~(F_DISABLE);
	table->flags |= F_CHANGED;
d559 2
a560 2
	    &table->id, sizeof(table->id));
	log_debug("enable_table: enabled table %d", table->id);
d578 1
a578 1
	id->id = host->id;
d584 1
a584 1
		if ((table = table_find(env, host->tableid)) == NULL)
d587 1
a587 1
		table->flags |= F_CHANGED;
d598 1
a598 1
	    &host->id, sizeof(host->id));
d602 3
a604 2
		    IMSG_HOST_DISABLE, 0, 0, &host->id, sizeof(host->id));
	log_debug("disable_host: disabled host %d", host->id);
d621 1
a621 1
	id->id = host->id;
d632 1
a632 1
	    &host->id, sizeof (host->id));
d636 3
a638 2
		    IMSG_HOST_ENABLE, 0, 0, &host->id, sizeof(host->id));
	log_debug("enable_host: enabled host %d", host->id);
d656 2
a657 2
		service->flags &= ~(F_BACKUP);
		service->flags &= ~(F_DOWN);
d659 1
a659 1
		if (service->flags & F_DISABLE ||
d661 1
a661 1
			service->flags |= F_DOWN;
d664 1
a664 1
			service->flags |= F_BACKUP;
d666 4
a669 2
			active->flags |= service->table->flags & F_CHANGED;
			active->flags |= service->backup->flags & F_CHANGED;
d673 2
a674 2
		if (active != NULL && active->flags & F_CHANGED) {
			id.id = active->id;
d682 2
a683 2
		service->table->flags &= ~(F_CHANGED);
		service->backup->flags &= ~(F_CHANGED);
d685 2
a686 2
		if (service->flags & F_DOWN) {
			if (service->flags & F_ACTIVE_RULESET) {
d689 2
a690 2
				service->flags &= ~(F_ACTIVE_RULESET);
				id.id = service->id;
d697 1
a697 1
		} else if (!(service->flags & F_ACTIVE_RULESET)) {
d699 2
a700 2
			service->flags |= F_ACTIVE_RULESET;
			id.id = service->id;
d710 1
a710 1
		if ((table->flags & F_DEMOTE) == 0)
d713 1
a713 1
		if (table->up && table->demoted) {
d715 1
a715 1
			table->demoted = 0;
d717 1
a717 1
		else if (!table->up && !table->demoted) {
d719 1
a719 1
			table->demoted = 1;
d724 2
a725 2
		    demote.level, table->name, table->demote_group);
		(void)strlcpy(demote.group, table->demote_group,
@


1.21
log
@fix potential NULL deref.
spotted by Ching-Feng Wang <cfw at telepaq.com>.
ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe.c,v 1.20 2007/03/17 22:46:41 reyk Exp $	*/
d66 1
a66 1
    int pipe_parent2relay[2], int pipe_pfe2hce[2],
d123 3
a125 3
	close(pipe_parent2relay[0]);
	close(pipe_parent2relay[1]);
	for (i = 0; i < env->prefork_relay; i++)
d127 1
@


1.20
log
@fix a bug in the initial setup of the pfe2relay communication sockets
which prevented the pfe to accept statistics updates and natlookups
from any other process then the first one. in other words, this will
show you the total relay statistics off _all_ preforked processes
(hoststatectl show relays) and it will unbreak the natlookup mode with
more than one running relay process.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe.c,v 1.19 2007/03/07 17:40:32 reyk Exp $	*/
a448 1
	id->id = service->id;
d451 1
a474 1
	id->id = service->id;
d477 1
a511 1
	id->id = table->id;
d514 1
a541 1
	id->id = table->id;
d544 1
a573 1
	id->id = host->id;
d576 1
a615 1
	id->id = host->id;
d618 1
@


1.19
log
@- fix the hoststatectl host disable/enable commands to work with relay
layer 7 loadbalancing.
- allow to run relays with tables without depending on services
- show hosts and tables assigned to relays in hoststatectl show commands

ok pyr@@ deraadt@@ with some input from mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe.c,v 1.18 2007/02/26 16:10:24 reyk Exp $	*/
d75 1
d128 4
a131 3
	if ((ibuf_hce = calloc(1, sizeof(struct imsgbuf))) == NULL ||
	    (ibuf_relay = calloc(i, sizeof(struct imsgbuf))) == NULL ||
	    (ibuf_main = calloc(1, sizeof(struct imsgbuf))) == NULL)
d150 1
a150 1
		ibuf_relay->events = EV_READ;
d359 3
@


1.18
log
@handle strlcpy return values, make lint happy
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe.c,v 1.17 2007/02/23 00:28:06 deraadt Exp $	*/
d218 2
a219 1

d420 9
d563 1
d592 4
d605 1
d625 4
@


1.17
log
@knf
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe.c,v 1.16 2007/02/22 05:58:06 reyk Exp $	*/
d694 1
a694 1
		strlcpy(demote.group, table->demote_group,
@


1.16
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe.c,v 1.15 2007/02/22 03:32:39 reyk Exp $	*/
d321 1
a321 1
	struct imsgbuf          *ibuf;
@


1.15
log
@Add layer 7 functionality to hoststated used for layer 7
loadbalancing, SSL acceleration, general-purpose TCP relaying, and
transparent proxying.

see hoststated.conf(5) and my upcoming article on undeadly.org for
details.

ok to commit deraadt@@ pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe.c,v 1.14 2007/02/08 13:32:24 reyk Exp $	*/
d236 2
a237 2
				imsg_compose(&ibuf_relay[n], IMSG_HOST_STATUS, 0, 0,
				    &st, sizeof(st));
d366 2
a367 1
				fatalx("pfe_dispatch_relay: invalid relay proc");
d620 2
a621 2
	struct ctl_id	 	 id;
	struct imsg	 	 imsg;
@


1.14
log
@carefully check some return values and make lint happier.  never pass
any truncated strings (table names/anchors/tags/...) to pf and the
kernel.

ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe.c,v 1.13 2007/02/06 11:21:35 pyr Exp $	*/
d42 1
d50 1
d66 2
a67 1
	int pipe_pfe2hce[2])
d73 2
d122 4
d128 1
d144 10
d159 3
d218 8
a225 1
			if (host->up == st.up) {
d231 8
d245 2
a246 2
			if ((st.up == HOST_UNKNOWN && host->up == HOST_DOWN) ||
			    (st.up == HOST_DOWN && host->up == HOST_UNKNOWN)) {
d256 1
d290 1
a290 1
		if (n == 0)     /* connection closed */
d319 65
d388 1
d412 8
d575 2
d616 6
a621 4
	struct service	*service;
	struct table	*active;
	struct ctl_id	 id;
	struct imsg	 imsg;
d675 22
@


1.13
log
@fix a bug when enabling a service that has no backup table.
ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe.c,v 1.12 2007/02/06 08:46:31 pyr Exp $	*/
d135 3
a137 1
	control_listen();
@


1.12
log
@remove an unused variable.
ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe.c,v 1.11 2007/02/06 08:45:46 pyr Exp $	*/
d362 2
@


1.11
log
@inform hoststatectl monitor of ruleset changes and table syncs.
ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe.c,v 1.10 2007/02/01 20:03:39 pyr Exp $	*/
a498 1
	int		 backup;
a504 1
		backup = (service->flags & F_BACKUP);
@


1.10
log
@add a monitor mode to hoststatectl to continuously report changes in
hoststated.
ok reyk@@, "looks nice and clean" niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe.c,v 1.9 2007/01/29 14:23:31 pyr Exp $	*/
d500 2
d503 2
d522 5
a526 1
		if (active != NULL && active->flags & F_CHANGED)
d528 2
d539 4
d544 1
d549 4
d554 1
@


1.9
log
@Add SSL support to hoststated.
with help and OK reyk@@
with help and advice by claudio@@ and Srebrenko Sehic
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe.c,v 1.8 2007/01/24 10:26:00 claudio Exp $	*/
d185 1
d318 1
d344 1
d379 1
d409 1
d440 1
d475 1
@


1.8
log
@Similar to ospfd and ripd ignore SIGPIPE in all processes to be able to do
a nice exit in case one of the processes dies. OK pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe.c,v 1.7 2007/01/09 13:50:11 pyr Exp $	*/
d33 2
@


1.7
log
@Finish renaming hostated to hoststated.
Note to testers: the user the daemon changes its id to is now _hoststated,
don't forget to update master.passwd.
ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe.c,v 1.6 2007/01/09 00:45:32 deraadt Exp $	*/
d108 1
@


1.6
log
@adapt to rename
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe.c,v 1.5 2007/01/08 20:46:18 reyk Exp $	*/
d43 1
a43 1
static struct hostated	*env = NULL;
d61 1
a61 1
pfe(struct hostated *x_env, int pipe_parent2pfe[2], int pipe_parent2hce[2],
d86 1
a86 1
	if ((pw = getpwnam(HOSTATED_USER)) == NULL)
d95 1
a95 1
	hostated_process = PROC_PFE;
@


1.5
log
@do NOT use the regexp interface. it is way to complicated, error-prone
and we don't know about all the possible security problems.

change the check send/expect code to use the fnmatch(3) interface
using shell globbing rules instead. this allows simple patterns like
"220 * ESMTP*" or "SSH-[12].??-*".

suggested by deraadt@@ and otto@@
ok Pierre-Yves Ritschard (pyr at spootnik dot org)
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe.c,v 1.4 2007/01/08 13:37:26 reyk Exp $	*/
d34 1
a34 1
#include "hostated.h"
@


1.4
log
@add a generic send/expect check using regular expression (see
regex(3)).  this allows to define additional checks for other TCP
protocols.

From Pierre-Yves Ritschard (pyr at spootnik dot org)
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe.c,v 1.3 2006/12/16 18:50:33 reyk Exp $	*/
a32 1
#include <regex.h>
@


1.3
log
@- allow to use host/service/table names instead of Ids in hostatectl.
- minor change of the "hostatectl show" command output
- increase the max service and tag names (max pf tag name size is 64 now!)

thanks to pyr who found a bug in my initial diff
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe.c,v 1.2 2006/12/16 12:42:14 reyk Exp $	*/
d33 1
@


1.2
log
@knf, spacing

please note that some editors will replace tabs with multiple spaces
if you cut & paste code from other sections.  please try to keep the
tabs ;).
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe.c,v 1.1 2006/12/16 11:45:07 reyk Exp $	*/
d306 1
a306 1
disable_service(struct ctl_conn *c, objid_t id)
d310 5
a314 1
	if ((service = service_find(env, id)) == NULL)
d330 1
a330 1
enable_service(struct ctl_conn *c, objid_t id)
d333 1
d335 5
a339 1
	if ((service = service_find(env, id)) == NULL)
d350 2
d353 2
a354 1
	if (enable_table(c, service->table->id))
d356 2
a357 1
	if (enable_table(c, service->backup->id))
d363 1
a363 1
disable_table(struct ctl_conn *c, objid_t id)
d369 5
a373 3
	if (id == EMPTY_TABLE)
		return (-1);
	if ((table = table_find(env, id)) == NULL)
d384 2
a385 1
	imsg_compose(ibuf_hce, IMSG_TABLE_DISABLE, 0, 0, &id, sizeof(id));
d392 1
a392 1
enable_table(struct ctl_conn *c, objid_t id)
d398 5
a402 3
	if (id == EMPTY_TABLE)
		return (-1);
	if ((table = table_find(env, id)) == NULL)
d404 1
d415 2
a416 1
	imsg_compose(ibuf_hce, IMSG_TABLE_ENABLE, 0, 0, &id, sizeof(id));
d423 1
a423 1
disable_host(struct ctl_conn *c, objid_t id)
d428 5
a432 1
	if ((host = host_find(env, id)) == NULL)
d450 2
a451 1
	imsg_compose(ibuf_hce, IMSG_HOST_DISABLE, 0, 0, &id, sizeof (id));
d458 1
a458 1
enable_host(struct ctl_conn *c, objid_t id)
d462 5
a466 1
	if ((host = host_find(env, id)) == NULL)
d477 2
a478 1
	imsg_compose(ibuf_hce, IMSG_HOST_ENABLE, 0, 0, &id, sizeof (id));
@


1.1
log
@Import hostated, the host status daemon.  This daemon will monitor
remote hosts and dynamically alter pf(4) tables and redirection rules
for active server load balancing.  The daemon has been written by
Pierre-Yves Ritschard (pyr at spootnik.org) and was formerly known as
"slbd".

The daemon is fully functional but it still needs some work and
cleanup so we don't link it to the build yet.  Some TODOs are a
partial rewrite of the check_* routines (use libevent whenever we
can), improvement of the manpages, and general knf and cleanup.

ok deraadt@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d97 4
a100 4
        if (setgroups(1, &pw->pw_gid) ||
            setresgid(pw->pw_gid, pw->pw_gid, pw->pw_gid) ||
            setresuid(pw->pw_uid, pw->pw_uid, pw->pw_uid))
                fatal("pfe: cannot drop privileges");
d118 2
a119 2
	imsg_init(ibuf_hce, pipe_pfe2hce[1], pfe_dispatch_imsg); 
	imsg_init(ibuf_main, pipe_parent2pfe[1], pfe_dispatch_parent); 
d123 1
a123 1
		ibuf_hce->handler, ibuf_hce);
d128 1
a128 1
		ibuf_main->handler, ibuf_main);
d191 1
a191 1
					  host->id, host->up);
d199 1
a199 1
				  st.up, host->id, host->name);
d225 1
a225 1
				  imsg.hdr.type);
d237 2
a238 2
        struct imsg	 imsg;
        ssize_t		 n;
d242 13
a254 13
        case EV_READ:
                if ((n = imsg_read(ibuf)) == -1)
                        fatal("imsg_read error");
                if (n == 0)     /* connection closed */
                        fatalx("pfe_dispatch_parent: pipe closed");
                break;
        case EV_WRITE:
                if (msgbuf_write(&ibuf->w) == -1)
                        fatal("msgbuf_write");
                imsg_event_add(ibuf);
                return;
        default:
                fatalx("pfe_dispatch_parent: unknown event");
d257 14
a270 14
        for (;;) {
                if ((n = imsg_get(ibuf, &imsg)) == -1)
                        fatal("pfe_dispatch_parent: imsg_read error");
                if (n == 0)
                        break;

                switch (imsg.hdr.type) {
                default:
                        log_debug("pfe_dispatch_parent: unexpected imsg %d", 
                                imsg.hdr.type);
                        break;
                }
                imsg_free(&imsg);
        }
d281 1
a281 1
				service, sizeof(*service));
d286 1
a286 1
			     service->table, sizeof(*service->table)); 
d290 1
a290 1
					     host, sizeof(*host));
d295 1
a295 1
			     service->backup, sizeof(*service->backup)); 
d299 1
a299 1
					     host, sizeof(*host));
d483 1
a483 1
		
@

