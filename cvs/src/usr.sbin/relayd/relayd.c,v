head	1.168;
access;
symbols
	OPENBSD_6_1:1.165.0.4
	OPENBSD_6_1_BASE:1.165
	OPENBSD_6_0:1.153.0.4
	OPENBSD_6_0_BASE:1.153
	OPENBSD_5_9:1.153.0.2
	OPENBSD_5_9_BASE:1.153
	OPENBSD_5_8:1.143.0.4
	OPENBSD_5_8_BASE:1.143
	OPENBSD_5_7:1.138.0.2
	OPENBSD_5_7_BASE:1.138
	OPENBSD_5_6:1.130.0.4
	OPENBSD_5_6_BASE:1.130
	OPENBSD_5_5:1.118.0.4
	OPENBSD_5_5_BASE:1.118
	OPENBSD_5_4:1.117.0.2
	OPENBSD_5_4_BASE:1.117
	OPENBSD_5_3:1.115.0.2
	OPENBSD_5_3_BASE:1.115
	OPENBSD_5_2:1.108.0.2
	OPENBSD_5_2_BASE:1.108
	OPENBSD_5_1_BASE:1.106
	OPENBSD_5_1:1.106.0.2
	OPENBSD_5_0:1.103.0.2
	OPENBSD_5_0_BASE:1.103
	OPENBSD_4_9:1.100.0.2
	OPENBSD_4_9_BASE:1.100
	OPENBSD_4_8:1.97.0.2
	OPENBSD_4_8_BASE:1.97
	OPENBSD_4_7:1.96.0.2
	OPENBSD_4_7_BASE:1.96
	OPENBSD_4_6:1.89.0.4
	OPENBSD_4_6_BASE:1.89
	OPENBSD_4_5:1.83.0.2
	OPENBSD_4_5_BASE:1.83
	OPENBSD_4_4:1.79.0.2
	OPENBSD_4_4_BASE:1.79
	OPENBSD_4_3:1.73.0.2
	OPENBSD_4_3_BASE:1.73;
locks; strict;
comment	@ * @;


1.168
date	2017.05.28.10.39.15;	author benno;	state Exp;
branches;
next	1.167;
commitid	IW4LnWyG3CPq6c3r;

1.167
date	2017.05.27.08.33.25;	author claudio;	state Exp;
branches;
next	1.166;
commitid	mLnU8nnW1ZLoAWRU;

1.166
date	2017.05.06.19.44.53;	author fcambus;	state Exp;
branches;
next	1.165;
commitid	ouABqPzFZVKuskun;

1.165
date	2017.01.24.10.49.14;	author benno;	state Exp;
branches;
next	1.164;
commitid	OlGQrXFnE2t7dYTy;

1.164
date	2017.01.09.14.49.21;	author reyk;	state Exp;
branches;
next	1.163;
commitid	eA8b246voAapPTkX;

1.163
date	2016.11.24.21.01.18;	author reyk;	state Exp;
branches;
next	1.162;
commitid	FkVuQgzULddApn9S;

1.162
date	2016.09.28.12.16.44;	author reyk;	state Exp;
branches;
next	1.161;
commitid	9yLAl6KjHBmFKV9B;

1.161
date	2016.09.27.21.39.27;	author bluhm;	state Exp;
branches;
next	1.160;
commitid	sD7e4HuQpstOlX2x;

1.160
date	2016.09.03.14.09.04;	author reyk;	state Exp;
branches;
next	1.159;
commitid	0kWOwUNycE381inh;

1.159
date	2016.09.02.14.45.51;	author reyk;	state Exp;
branches;
next	1.158;
commitid	vcV98N2DyJGMwDyQ;

1.158
date	2016.09.02.12.12.51;	author reyk;	state Exp;
branches;
next	1.157;
commitid	tCJ77FP0n8bVYrYP;

1.157
date	2016.09.02.11.51.50;	author reyk;	state Exp;
branches;
next	1.156;
commitid	Scmkna4JViHMcK3U;

1.156
date	2016.09.01.10.49.48;	author claudio;	state Exp;
branches;
next	1.155;
commitid	kVeSpNYKmzM2uO33;

1.155
date	2016.07.29.10.09.26;	author reyk;	state Exp;
branches;
next	1.154;
commitid	cXyFVrZtyIYivR44;

1.154
date	2016.07.27.06.55.44;	author reyk;	state Exp;
branches;
next	1.153;
commitid	7JdoxjTbye4XkUae;

1.153
date	2016.02.02.17.51.11;	author sthen;	state Exp;
branches
	1.153.2.1
	1.153.4.1;
next	1.152;
commitid	LQHdRRMF0nq0fugE;

1.152
date	2015.12.30.16.00.57;	author benno;	state Exp;
branches;
next	1.151;
commitid	O60zRJngKRCToye8;

1.151
date	2015.12.30.12.08.34;	author benno;	state Exp;
branches;
next	1.150;
commitid	v04SUqtFvii3BsSp;

1.150
date	2015.12.07.04.03.27;	author mmcc;	state Exp;
branches;
next	1.149;
commitid	vlUffo7boyCTPJEr;

1.149
date	2015.12.02.13.41.27;	author reyk;	state Exp;
branches;
next	1.148;
commitid	vBNcEM4jmO1KceIa;

1.148
date	2015.11.29.01.20.33;	author benno;	state Exp;
branches;
next	1.147;
commitid	u0wLjk4LODsT22tz;

1.147
date	2015.11.28.09.52.07;	author reyk;	state Exp;
branches;
next	1.146;
commitid	Xo3TbDi9hUaP9ip0;

1.146
date	2015.11.22.13.27.13;	author reyk;	state Exp;
branches;
next	1.145;
commitid	T3JBYxNT0thPuavp;

1.145
date	2015.11.19.21.32.53;	author mmcc;	state Exp;
branches;
next	1.144;
commitid	5eZwzlxhGA7nTpwJ;

1.144
date	2015.10.14.07.58.14;	author reyk;	state Exp;
branches;
next	1.143;
commitid	Q1F3aiWlcbmMvxpF;

1.143
date	2015.07.29.20.55.43;	author benno;	state Exp;
branches
	1.143.4.1;
next	1.142;
commitid	OR3hKfYQdwjEKuGt;

1.142
date	2015.06.03.02.24.36;	author millert;	state Exp;
branches;
next	1.141;
commitid	GouatFiJVxwlAVIQ;

1.141
date	2015.05.30.09.47.25;	author claudio;	state Exp;
branches;
next	1.140;
commitid	KfncccVpzlYf6X7l;

1.140
date	2015.05.28.17.08.09;	author florian;	state Exp;
branches;
next	1.139;
commitid	CuYEPULhoEPTPxJv;

1.139
date	2015.05.02.13.15.24;	author claudio;	state Exp;
branches;
next	1.138;
commitid	KeIVSkhMPmj3B0K2;

1.138
date	2015.01.22.17.42.09;	author reyk;	state Exp;
branches
	1.138.2.1;
next	1.137;
commitid	puppem00jmzmdm4f;

1.137
date	2015.01.22.15.21.28;	author reyk;	state Exp;
branches;
next	1.136;
commitid	4iTNJ5pZPl4b1HA5;

1.136
date	2015.01.16.15.06.40;	author deraadt;	state Exp;
branches;
next	1.135;
commitid	tOv8XK6tLyhEfayc;

1.135
date	2014.12.18.20.55.01;	author reyk;	state Exp;
branches;
next	1.134;
commitid	nThpdXmyvXqmRQ4C;

1.134
date	2014.12.12.10.05.09;	author reyk;	state Exp;
branches;
next	1.133;
commitid	J8g0vRzthwLCqf68;

1.133
date	2014.11.22.00.24.22;	author tedu;	state Exp;
branches;
next	1.132;
commitid	zQJPNUJ5J7GRL1zG;

1.132
date	2014.11.19.10.24.40;	author blambert;	state Exp;
branches;
next	1.131;
commitid	EGrSQMGI27r3h8Vf;

1.131
date	2014.08.18.12.59.00;	author reyk;	state Exp;
branches;
next	1.130;
commitid	6CBP61dyg2cJV5hP;

1.130
date	2014.07.13.00.32.08;	author benno;	state Exp;
branches;
next	1.129;
commitid	ri182Vf5Hw0I7rh1;

1.129
date	2014.07.11.11.48.50;	author reyk;	state Exp;
branches;
next	1.128;
commitid	6F05OKHLwEQdKZuE;

1.128
date	2014.07.10.00.05.59;	author reyk;	state Exp;
branches;
next	1.127;
commitid	9WbuG1EnboLWC0cR;

1.127
date	2014.07.09.22.10.15;	author reyk;	state Exp;
branches;
next	1.126;
commitid	XPOsVopF6rcUkeod;

1.126
date	2014.07.09.16.42.05;	author reyk;	state Exp;
branches;
next	1.125;
commitid	YhQvyAop4vC3AmzJ;

1.125
date	2014.06.27.07.49.08;	author andre;	state Exp;
branches;
next	1.124;
commitid	pPMUb6sAQ5HcQv7b;

1.124
date	2014.05.08.15.28.57;	author blambert;	state Exp;
branches;
next	1.123;

1.123
date	2014.05.08.13.08.48;	author blambert;	state Exp;
branches;
next	1.122;

1.122
date	2014.04.22.08.04.23;	author reyk;	state Exp;
branches;
next	1.121;

1.121
date	2014.04.20.14.48.29;	author reyk;	state Exp;
branches;
next	1.120;

1.120
date	2014.04.18.13.55.26;	author reyk;	state Exp;
branches;
next	1.119;

1.119
date	2014.03.16.18.38.30;	author guenther;	state Exp;
branches;
next	1.118;

1.118
date	2013.11.26.13.27.20;	author deraadt;	state Exp;
branches;
next	1.117;

1.117
date	2013.05.30.20.17.12;	author reyk;	state Exp;
branches;
next	1.116;

1.116
date	2013.03.10.23.32.53;	author reyk;	state Exp;
branches;
next	1.115;

1.115
date	2013.01.17.20.34.18;	author bluhm;	state Exp;
branches;
next	1.114;

1.114
date	2012.12.18.15.41.44;	author reyk;	state Exp;
branches;
next	1.113;

1.113
date	2012.12.18.15.39.42;	author reyk;	state Exp;
branches;
next	1.112;

1.112
date	2012.11.27.05.00.28;	author guenther;	state Exp;
branches;
next	1.111;

1.111
date	2012.10.03.08.46.05;	author reyk;	state Exp;
branches;
next	1.110;

1.110
date	2012.10.03.08.33.31;	author reyk;	state Exp;
branches;
next	1.109;

1.109
date	2012.09.21.09.56.27;	author benno;	state Exp;
branches;
next	1.108;

1.108
date	2012.05.08.15.10.15;	author benno;	state Exp;
branches;
next	1.107;

1.107
date	2012.04.15.03.12.30;	author jsg;	state Exp;
branches;
next	1.106;

1.106
date	2012.01.21.13.40.48;	author camield;	state Exp;
branches;
next	1.105;

1.105
date	2012.01.20.12.16.41;	author camield;	state Exp;
branches;
next	1.104;

1.104
date	2011.09.04.20.26.58;	author bluhm;	state Exp;
branches;
next	1.103;

1.103
date	2011.05.19.08.56.49;	author reyk;	state Exp;
branches;
next	1.102;

1.102
date	2011.05.09.12.08.47;	author reyk;	state Exp;
branches;
next	1.101;

1.101
date	2011.05.05.12.01.44;	author reyk;	state Exp;
branches;
next	1.100;

1.100
date	2011.02.13.13.28.38;	author okan;	state Exp;
branches;
next	1.99;

1.99
date	2010.11.30.14.38.45;	author reyk;	state Exp;
branches;
next	1.98;

1.98
date	2010.09.02.14.03.22;	author sobrado;	state Exp;
branches;
next	1.97;

1.97
date	2010.05.14.11.13.36;	author reyk;	state Exp;
branches;
next	1.96;

1.96
date	2010.02.17.14.39.30;	author jsg;	state Exp;
branches;
next	1.95;

1.95
date	2010.02.04.13.00.20;	author jsg;	state Exp;
branches;
next	1.94;

1.94
date	2010.01.11.06.40.14;	author jsg;	state Exp;
branches;
next	1.93;

1.93
date	2009.11.11.13.09.39;	author jsg;	state Exp;
branches;
next	1.92;

1.92
date	2009.08.13.13.51.21;	author reyk;	state Exp;
branches;
next	1.91;

1.91
date	2009.08.07.11.21.53;	author reyk;	state Exp;
branches;
next	1.90;

1.90
date	2009.08.05.13.46.13;	author reyk;	state Exp;
branches;
next	1.89;

1.89
date	2009.06.05.23.39.51;	author pyr;	state Exp;
branches;
next	1.88;

1.88
date	2009.06.05.00.20.50;	author pyr;	state Exp;
branches;
next	1.87;

1.87
date	2009.06.05.00.04.01;	author pyr;	state Exp;
branches;
next	1.86;

1.86
date	2009.06.04.13.46.07;	author reyk;	state Exp;
branches;
next	1.85;

1.85
date	2009.06.02.12.24.16;	author reyk;	state Exp;
branches;
next	1.84;

1.84
date	2009.06.02.11.33.06;	author reyk;	state Exp;
branches;
next	1.83;

1.83
date	2008.09.29.15.12.22;	author reyk;	state Exp;
branches;
next	1.82;

1.82
date	2008.09.29.15.06.52;	author reyk;	state Exp;
branches;
next	1.81;

1.81
date	2008.09.29.14.53.35;	author reyk;	state Exp;
branches;
next	1.80;

1.80
date	2008.08.08.08.51.21;	author thib;	state Exp;
branches;
next	1.79;

1.79
date	2008.07.22.23.17.37;	author reyk;	state Exp;
branches;
next	1.78;

1.78
date	2008.07.09.14.06.44;	author reyk;	state Exp;
branches;
next	1.77;

1.77
date	2008.06.11.18.21.20;	author reyk;	state Exp;
branches;
next	1.76;

1.76
date	2008.05.17.23.31.52;	author sobrado;	state Exp;
branches;
next	1.75;

1.75
date	2008.05.12.19.15.02;	author pyr;	state Exp;
branches;
next	1.74;

1.74
date	2008.05.06.09.52.47;	author pyr;	state Exp;
branches;
next	1.73;

1.73
date	2008.02.13.11.32.59;	author reyk;	state Exp;
branches;
next	1.72;

1.72
date	2008.02.13.11.20.08;	author reyk;	state Exp;
branches;
next	1.71;

1.71
date	2008.02.13.11.02.37;	author reyk;	state Exp;
branches;
next	1.70;

1.70
date	2008.02.11.10.42.50;	author reyk;	state Exp;
branches;
next	1.69;

1.69
date	2008.01.31.12.12.50;	author thib;	state Exp;
branches;
next	1.68;

1.68
date	2008.01.31.09.56.28;	author reyk;	state Exp;
branches;
next	1.67;

1.67
date	2008.01.31.09.33.39;	author reyk;	state Exp;
branches;
next	1.66;

1.66
date	2008.01.29.17.36.08;	author thib;	state Exp;
branches;
next	1.65;

1.65
date	2007.12.10.20.31.56;	author pyr;	state Exp;
branches;
next	1.64;

1.64
date	2007.12.08.20.36.36;	author pyr;	state Exp;
branches;
next	1.63;

1.63
date	2007.12.08.17.07.09;	author reyk;	state Exp;
branches;
next	1.62;

1.62
date	2007.12.07.17.17.01;	author reyk;	state Exp;
branches;
next	1.61;

1.61
date	2007.11.28.11.37.59;	author reyk;	state Exp;
branches;
next	1.60;

1.60
date	2007.11.25.20.01.10;	author reyk;	state Exp;
branches;
next	1.59;

1.59
date	2007.11.24.17.07.28;	author reyk;	state Exp;
branches;
next	1.58;

1.58
date	2007.11.24.16.13.50;	author reyk;	state Exp;
branches;
next	1.57;

1.57
date	2007.11.23.09.22.18;	author sthen;	state Exp;
branches;
next	1.56;

1.56
date	2007.11.21.20.13.20;	author reyk;	state Exp;
branches;
next	1.55;

1.55
date	2007.11.20.15.54.55;	author reyk;	state Exp;
branches;
next	1.54;

1.54
date	2007.11.19.15.31.36;	author reyk;	state Exp;
branches;
next	1.53;

1.53
date	2007.11.19.14.48.19;	author reyk;	state Exp;
branches;
next	1.52;

1.52
date	2007.11.19.11.39.49;	author reyk;	state Exp;
branches;
next	1.51;

1.51
date	2007.11.15.17.02.01;	author pyr;	state Exp;
branches;
next	1.50;

1.50
date	2007.11.14.11.01.52;	author pyr;	state Exp;
branches;
next	1.49;

1.49
date	2007.11.14.10.59.01;	author pyr;	state Exp;
branches;
next	1.48;

1.48
date	2007.11.13.10.35.21;	author pyr;	state Exp;
branches;
next	1.47;

1.47
date	2007.11.04.22.09.02;	author reyk;	state Exp;
branches;
next	1.46;

1.46
date	2007.10.19.14.40.51;	author pyr;	state Exp;
branches;
next	1.45;

1.45
date	2007.10.19.14.15.14;	author pyr;	state Exp;
branches;
next	1.44;

1.44
date	2007.10.12.12.50.59;	author blambert;	state Exp;
branches;
next	1.43;

1.43
date	2007.10.05.17.32.13;	author reyk;	state Exp;
branches;
next	1.42;

1.42
date	2007.10.02.21.04.13;	author pyr;	state Exp;
branches;
next	1.41;

1.41
date	2007.09.28.20.23.38;	author pyr;	state Exp;
branches;
next	1.40;

1.40
date	2007.09.28.13.29.56;	author pyr;	state Exp;
branches;
next	1.39;

1.39
date	2007.09.05.08.48.42;	author reyk;	state Exp;
branches;
next	1.38;

1.38
date	2007.07.05.09.42.26;	author thib;	state Exp;
branches;
next	1.37;

1.37
date	2007.06.19.06.29.20;	author pyr;	state Exp;
branches;
next	1.36;

1.36
date	2007.06.12.15.16.10;	author msf;	state Exp;
branches;
next	1.35;

1.35
date	2007.06.07.07.19.50;	author pyr;	state Exp;
branches;
next	1.34;

1.34
date	2007.05.31.03.24.05;	author pyr;	state Exp;
branches;
next	1.33;

1.33
date	2007.05.30.00.51.21;	author pyr;	state Exp;
branches;
next	1.32;

1.32
date	2007.05.30.00.19.25;	author pyr;	state Exp;
branches;
next	1.31;

1.31
date	2007.05.30.00.12.21;	author pyr;	state Exp;
branches;
next	1.30;

1.30
date	2007.05.29.23.58.30;	author pyr;	state Exp;
branches;
next	1.29;

1.29
date	2007.05.29.23.19.18;	author pyr;	state Exp;
branches;
next	1.28;

1.28
date	2007.05.29.18.59.53;	author pyr;	state Exp;
branches;
next	1.27;

1.27
date	2007.05.29.17.12.04;	author reyk;	state Exp;
branches;
next	1.26;

1.26
date	2007.05.29.00.58.06;	author pyr;	state Exp;
branches;
next	1.25;

1.25
date	2007.05.29.00.21.10;	author pyr;	state Exp;
branches;
next	1.24;

1.24
date	2007.05.28.22.11.33;	author pyr;	state Exp;
branches;
next	1.23;

1.23
date	2007.05.27.20.53.10;	author pyr;	state Exp;
branches;
next	1.22;

1.22
date	2007.05.26.19.58.49;	author pyr;	state Exp;
branches;
next	1.21;

1.21
date	2007.03.17.22.54.49;	author reyk;	state Exp;
branches;
next	1.20;

1.20
date	2007.02.26.16.10.24;	author reyk;	state Exp;
branches;
next	1.19;

1.19
date	2007.02.23.00.28.06;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2007.02.22.05.58.06;	author reyk;	state Exp;
branches;
next	1.17;

1.17
date	2007.02.22.03.32.39;	author reyk;	state Exp;
branches;
next	1.16;

1.16
date	2007.02.08.13.32.24;	author reyk;	state Exp;
branches;
next	1.15;

1.15
date	2007.02.07.13.30.17;	author reyk;	state Exp;
branches;
next	1.14;

1.14
date	2007.02.06.10.03.08;	author reyk;	state Exp;
branches;
next	1.13;

1.13
date	2007.01.29.14.23.31;	author pyr;	state Exp;
branches;
next	1.12;

1.12
date	2007.01.24.10.26.00;	author claudio;	state Exp;
branches;
next	1.11;

1.11
date	2007.01.11.18.28.28;	author pyr;	state Exp;
branches;
next	1.10;

1.10
date	2007.01.11.18.05.08;	author reyk;	state Exp;
branches;
next	1.9;

1.9
date	2007.01.09.13.50.11;	author pyr;	state Exp;
branches;
next	1.8;

1.8
date	2007.01.09.02.32.58;	author reyk;	state Exp;
branches;
next	1.7;

1.7
date	2007.01.08.20.46.18;	author reyk;	state Exp;
branches;
next	1.6;

1.6
date	2007.01.08.13.37.26;	author reyk;	state Exp;
branches;
next	1.5;

1.5
date	2006.12.25.18.40.38;	author reyk;	state Exp;
branches;
next	1.4;

1.4
date	2006.12.16.18.50.33;	author reyk;	state Exp;
branches;
next	1.3;

1.3
date	2006.12.16.14.07.29;	author reyk;	state Exp;
branches;
next	1.2;

1.2
date	2006.12.16.12.42.14;	author reyk;	state Exp;
branches;
next	1.1;

1.1
date	2006.12.16.11.45.07;	author reyk;	state Exp;
branches;
next	;

1.138.2.1
date	2015.09.20.11.20.16;	author benno;	state Exp;
branches;
next	;
commitid	C9WQyjgbN7h0ioOp;

1.143.4.1
date	2016.08.07.07.54.42;	author benno;	state Exp;
branches;
next	;
commitid	GZ3yh3axbGcu2rco;

1.153.2.1
date	2016.08.07.07.54.07;	author benno;	state Exp;
branches;
next	;
commitid	HdLzCX7WKhJK5mAs;

1.153.4.1
date	2016.08.07.07.53.45;	author benno;	state Exp;
branches;
next	;
commitid	uUOVRby9dw3PdeGk;


desc
@@


1.168
log
@use __func__ in log messages. fix some whitespace while here.
From Hiltjo Posthuma hiltjo -AT codemadness -DOT- org, thanks!
ok florian, claudio
@
text
@/*	$OpenBSD: relayd.c,v 1.167 2017/05/27 08:33:25 claudio Exp $	*/

/*
 * Copyright (c) 2007 - 2016 Reyk Floeter <reyk@@openbsd.org>
 * Copyright (c) 2006 Pierre-Yves Ritschard <pyr@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/queue.h>
#include <sys/socket.h>
#include <sys/wait.h>
#include <sys/resource.h>

#include <netinet/in.h>
#include <arpa/inet.h>

#include <signal.h>
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <getopt.h>
#include <fnmatch.h>
#include <syslog.h>
#include <err.h>
#include <errno.h>
#include <event.h>
#include <unistd.h>
#include <ctype.h>
#include <pwd.h>
#include <sha1.h>
#include <md5.h>

#include <tls.h>

#include "relayd.h"

#define MAXIMUM(a, b)	(((a) > (b)) ? (a) : (b))

__dead void	 usage(void);

int		 parent_configure(struct relayd *);
void		 parent_configure_done(struct relayd *);
void		 parent_reload(struct relayd *, u_int, const char *);
void		 parent_sig_handler(int, short, void *);
void		 parent_shutdown(struct relayd *);
int		 parent_dispatch_pfe(int, struct privsep_proc *, struct imsg *);
int		 parent_dispatch_hce(int, struct privsep_proc *, struct imsg *);
int		 parent_dispatch_relay(int, struct privsep_proc *,
		    struct imsg *);
int		 parent_dispatch_ca(int, struct privsep_proc *,
		    struct imsg *);
int		 bindany(struct ctl_bindany *);
void		 parent_tls_ticket_rekey(int, short, void *);

struct relayd			*relayd_env;

static struct privsep_proc procs[] = {
	{ "pfe",	PROC_PFE, parent_dispatch_pfe, pfe },
	{ "hce",	PROC_HCE, parent_dispatch_hce, hce },
	{ "relay",	PROC_RELAY, parent_dispatch_relay, relay },
	{ "ca",		PROC_CA, parent_dispatch_ca, ca }
};

void
parent_sig_handler(int sig, short event, void *arg)
{
	struct privsep	*ps = arg;

	switch (sig) {
	case SIGTERM:
	case SIGINT:
		parent_shutdown(ps->ps_env);
		break;
	case SIGHUP:
		log_info("%s: reload requested with SIGHUP", __func__);

		/*
		 * This is safe because libevent uses async signal handlers
		 * that run in the event loop and not in signal context.
		 */
		parent_reload(ps->ps_env, CONFIG_RELOAD, NULL);
		break;
	case SIGPIPE:
	case SIGUSR1:
		/* ignore */
		break;
	default:
		fatalx("unexpected signal");
	}
}

__dead void
usage(void)
{
	extern char	*__progname;

	fprintf(stderr, "usage: %s [-dnv] [-D macro=value] [-f file]\n",
	    __progname);
	exit(1);
}

int
main(int argc, char *argv[])
{
	int			 c;
	int			 debug = 0, verbose = 0;
	u_int32_t		 opts = 0;
	struct relayd		*env;
	struct privsep		*ps;
	const char		*conffile = CONF_FILE;
	enum privsep_procid	 proc_id = PROC_PARENT;
	int			 proc_instance = 0;
	const char		*errp, *title = NULL;
	int			 argc0 = argc;

	while ((c = getopt(argc, argv, "dD:nI:P:f:v")) != -1) {
		switch (c) {
		case 'd':
			debug = 2;
			break;
		case 'D':
			if (cmdline_symset(optarg) < 0)
				log_warnx("could not parse macro definition %s",
				    optarg);
			break;
		case 'n':
			debug = 2;
			opts |= RELAYD_OPT_NOACTION;
			break;
		case 'f':
			conffile = optarg;
			break;
		case 'v':
			verbose++;
			opts |= RELAYD_OPT_VERBOSE;
			break;
		case 'P':
			title = optarg;
			proc_id = proc_getid(procs, nitems(procs), title);
			if (proc_id == PROC_MAX)
				fatalx("invalid process name");
			break;
		case 'I':
			proc_instance = strtonum(optarg, 0,
			    PROC_MAX_INSTANCES, &errp);
			if (errp)
				fatalx("invalid process instance");
			break;
		default:
			usage();
		}
	}

	/* log to stderr until daemonized */
	log_init(debug ? debug : 1, LOG_DAEMON);

	argc -= optind;
	if (argc > 0)
		usage();

	if ((env = calloc(1, sizeof(*env))) == NULL ||
	    (ps = calloc(1, sizeof(*ps))) == NULL)
		exit(1);

	relayd_env = env;
	env->sc_ps = ps;
	ps->ps_env = env;
	TAILQ_INIT(&ps->ps_rcsocks);
	env->sc_conffile = conffile;
	env->sc_conf.opts = opts;
	TAILQ_INIT(&env->sc_hosts);
	TAILQ_INIT(&env->sc_sessions);
	env->sc_rtable = getrtable();
	/* initialize the TLS session id to a random key for all relay procs */
	arc4random_buf(env->sc_conf.tls_sid, sizeof(env->sc_conf.tls_sid));

	if (parse_config(env->sc_conffile, env) == -1)
		exit(1);

	if (debug)
		env->sc_conf.opts |= RELAYD_OPT_LOGUPDATE;

	if (geteuid())
		errx(1, "need root privileges");

	if ((ps->ps_pw =  getpwnam(RELAYD_USER)) == NULL)
		errx(1, "unknown user %s", RELAYD_USER);

	/* Configure the control socket */
	ps->ps_csock.cs_name = RELAYD_SOCKET;

	log_init(debug, LOG_DAEMON);
	log_setverbose(verbose);

	if (env->sc_conf.opts & RELAYD_OPT_NOACTION)
		ps->ps_noaction = 1;

	ps->ps_instances[PROC_RELAY] = env->sc_conf.prefork_relay;
	ps->ps_instances[PROC_CA] = env->sc_conf.prefork_relay;
	ps->ps_instance = proc_instance;
	if (title != NULL)
		ps->ps_title[proc_id] = title;

	/* only the parent returns */
	proc_init(ps, procs, nitems(procs), argc0, argv, proc_id);

	log_procinit("parent");
	if (!debug && daemon(1, 0) == -1)
		err(1, "failed to daemonize");

	if (ps->ps_noaction == 0)
		log_info("startup");

	event_init();

	signal_set(&ps->ps_evsigint, SIGINT, parent_sig_handler, ps);
	signal_set(&ps->ps_evsigterm, SIGTERM, parent_sig_handler, ps);
	signal_set(&ps->ps_evsighup, SIGHUP, parent_sig_handler, ps);
	signal_set(&ps->ps_evsigpipe, SIGPIPE, parent_sig_handler, ps);
	signal_set(&ps->ps_evsigusr1, SIGUSR1, parent_sig_handler, ps);

	signal_add(&ps->ps_evsigint, NULL);
	signal_add(&ps->ps_evsigterm, NULL);
	signal_add(&ps->ps_evsighup, NULL);
	signal_add(&ps->ps_evsigpipe, NULL);
	signal_add(&ps->ps_evsigusr1, NULL);

	proc_connect(ps);

	relay_http(NULL);
	if (load_config(env->sc_conffile, env) == -1) {
		proc_kill(env->sc_ps);
		exit(1);
	}

	if (env->sc_conf.opts & RELAYD_OPT_NOACTION) {
		fprintf(stderr, "configuration OK\n");
		proc_kill(env->sc_ps);
		exit(0);
	}

	if (env->sc_conf.flags & (F_TLS|F_TLSCLIENT))
		ssl_init(env);

	/* rekey the TLS tickets before pushing the config */
	parent_tls_ticket_rekey(0, 0, env);
	if (parent_configure(env) == -1)
		fatalx("configuration failed");

	init_routes(env);

	event_dispatch();

	parent_shutdown(env);
	/* NOTREACHED */

	return (0);
}

int
parent_configure(struct relayd *env)
{
	struct table		*tb;
	struct rdr		*rdr;
	struct router		*rt;
	struct protocol		*proto;
	struct relay		*rlay;
	int			 id;
	int			 ret = -1;

	TAILQ_FOREACH(tb, env->sc_tables, entry)
		config_settable(env, tb);
	TAILQ_FOREACH(rdr, env->sc_rdrs, entry)
		config_setrdr(env, rdr);
	TAILQ_FOREACH(rt, env->sc_rts, rt_entry)
		config_setrt(env, rt);
	TAILQ_FOREACH(proto, env->sc_protos, entry)
		config_setproto(env, proto);
	TAILQ_FOREACH(proto, env->sc_protos, entry)
		config_setrule(env, proto);
	TAILQ_FOREACH(rlay, env->sc_relays, rl_entry) {
		/* Check for TLS Inspection */
		if ((rlay->rl_conf.flags & (F_TLS|F_TLSCLIENT)) ==
		    (F_TLS|F_TLSCLIENT) &&
		    rlay->rl_conf.tls_cacert_len &&
		    rlay->rl_conf.tls_cakey_len)
			rlay->rl_conf.flags |= F_TLSINSPECT;

		config_setrelay(env, rlay);
	}

	/* HCE, PFE, CA and the relays need to reload their config. */
	env->sc_reload = 2 + (2 * env->sc_conf.prefork_relay);

	for (id = 0; id < PROC_MAX; id++) {
		if (id == privsep_process)
			continue;
		proc_compose_imsg(env->sc_ps, id, -1, IMSG_CFG_DONE, -1,
		    -1, &env->sc_conf, sizeof(env->sc_conf));
	}

	ret = 0;

	config_purge(env, CONFIG_ALL & ~CONFIG_RELAYS);
	return (ret);
}

void
parent_reload(struct relayd *env, u_int reset, const char *filename)
{
	if (env->sc_reload) {
		log_debug("%s: already in progress: %d pending",
		    __func__, env->sc_reload);
		return;
	}

	/* Switch back to the default config file */
	if (filename == NULL || *filename == '\0')
		filename = env->sc_conffile;

	log_debug("%s: level %d config file %s", __func__, reset, filename);

	config_purge(env, CONFIG_ALL);

	if (reset == CONFIG_RELOAD) {
		if (load_config(filename, env) == -1) {
			log_debug("%s: failed to load config file %s",
			    __func__, filename);
		}

		config_setreset(env, CONFIG_ALL);

		if (parent_configure(env) == -1) {
			log_debug("%s: failed to commit config from %s",
			    __func__, filename);
		}
	} else
		config_setreset(env, reset);
}

void
parent_configure_done(struct relayd *env)
{
	int	 id;

	if (env->sc_reload == 0) {
		log_warnx("%s: configuration already finished", __func__);
		return;
	}

	env->sc_reload--;
	if (env->sc_reload == 0) {
		for (id = 0; id < PROC_MAX; id++) {
			if (id == privsep_process)
				continue;

			proc_compose(env->sc_ps, id, IMSG_CTL_START, NULL, 0);
		}
	}
}

void
parent_shutdown(struct relayd *env)
{
	config_purge(env, CONFIG_ALL);

	proc_kill(env->sc_ps);
	control_cleanup(&env->sc_ps->ps_csock);
	(void)unlink(env->sc_ps->ps_csock.cs_name);
	carp_demote_shutdown();

	free(env->sc_ps);
	free(env);

	log_info("parent terminating, pid %d", getpid());

	exit(0);
}

int
parent_dispatch_pfe(int fd, struct privsep_proc *p, struct imsg *imsg)
{
	struct privsep		*ps = p->p_ps;
	struct relayd		*env = ps->ps_env;
	struct ctl_demote	 demote;
	struct ctl_netroute	 crt;
	u_int			 v;
	char			*str = NULL;

	switch (imsg->hdr.type) {
	case IMSG_DEMOTE:
		IMSG_SIZE_CHECK(imsg, &demote);
		memcpy(&demote, imsg->data, sizeof(demote));
		carp_demote_set(demote.group, demote.level);
		break;
	case IMSG_RTMSG:
		IMSG_SIZE_CHECK(imsg, &crt);
		memcpy(&crt, imsg->data, sizeof(crt));
		pfe_route(env, &crt);
		break;
	case IMSG_CTL_RESET:
		IMSG_SIZE_CHECK(imsg, &v);
		memcpy(&v, imsg->data, sizeof(v));
		parent_reload(env, v, NULL);
		break;
	case IMSG_CTL_RELOAD:
		if (IMSG_DATA_SIZE(imsg) > 0)
			str = get_string(imsg->data, IMSG_DATA_SIZE(imsg));
		parent_reload(env, CONFIG_RELOAD, str);
		free(str);
		break;
	case IMSG_CTL_SHUTDOWN:
		parent_shutdown(env);
		break;
	case IMSG_CFG_DONE:
		parent_configure_done(env);
		break;
	case IMSG_SNMPSOCK:
		(void)snmp_setsock(env, p->p_id);
		break;
	default:
		return (-1);
	}

	return (0);
}

int
parent_dispatch_hce(int fd, struct privsep_proc *p, struct imsg *imsg)
{
	struct privsep		*ps = p->p_ps;
	struct relayd		*env = ps->ps_env;
	struct ctl_script	 scr;

	switch (imsg->hdr.type) {
	case IMSG_SCRIPT:
		IMSG_SIZE_CHECK(imsg, &scr);
		bcopy(imsg->data, &scr, sizeof(scr));
		scr.retval = script_exec(env, &scr);
		proc_compose(ps, PROC_HCE, IMSG_SCRIPT, &scr, sizeof(scr));
		break;
	case IMSG_CFG_DONE:
		parent_configure_done(env);
		break;
	default:
		return (-1);
	}

	return (0);
}

int
parent_dispatch_relay(int fd, struct privsep_proc *p, struct imsg *imsg)
{
	struct privsep		*ps = p->p_ps;
	struct relayd		*env = ps->ps_env;
	struct ctl_bindany	 bnd;
	int			 s;

	switch (imsg->hdr.type) {
	case IMSG_BINDANY:
		IMSG_SIZE_CHECK(imsg, &bnd);
		bcopy(imsg->data, &bnd, sizeof(bnd));
		if (bnd.bnd_proc > env->sc_conf.prefork_relay)
			fatalx("%s: invalid relay proc", __func__);
		switch (bnd.bnd_proto) {
		case IPPROTO_TCP:
		case IPPROTO_UDP:
			break;
		default:
			fatalx("%s: requested socket "
			    "for invalid protocol", __func__);
			/* NOTREACHED */
		}
		s = bindany(&bnd);
		proc_compose_imsg(ps, PROC_RELAY, bnd.bnd_proc,
		    IMSG_BINDANY, -1, s, &bnd.bnd_id, sizeof(bnd.bnd_id));
		break;
	case IMSG_CFG_DONE:
		parent_configure_done(env);
		break;
	default:
		return (-1);
	}

	return (0);
}

int
parent_dispatch_ca(int fd, struct privsep_proc *p, struct imsg *imsg)
{
	struct privsep		*ps = p->p_ps;
	struct relayd		*env = ps->ps_env;

	switch (imsg->hdr.type) {
	case IMSG_CFG_DONE:
		parent_configure_done(env);
		break;
	default:
		return (-1);
	}

	return (0);
}

void
purge_table(struct relayd *env, struct tablelist *head, struct table *table)
{
	struct host		*host;

	while ((host = TAILQ_FIRST(&table->hosts)) != NULL) {
		TAILQ_REMOVE(&table->hosts, host, entry);
		TAILQ_REMOVE(&env->sc_hosts, host, globalentry);
		if (event_initialized(&host->cte.ev)) {
			event_del(&host->cte.ev);
			close(host->cte.s);
		}
		ibuf_free(host->cte.buf);
		tls_free(host->cte.tls);
		free(host);
	}
	free(table->sendbuf);
	tls_config_free(table->tls_cfg);

	if (head != NULL)
		TAILQ_REMOVE(head, table, entry);
	free(table);
}

void
purge_key(char **key, off_t len)
{
	freezero(*key, len);

	*key = NULL;
}

void
purge_relay(struct relayd *env, struct relay *rlay)
{
	struct rsession		*con;
	struct relay_table	*rlt;

	/* shutdown and remove relay */
	if (event_initialized(&rlay->rl_ev))
		event_del(&rlay->rl_ev);
	close(rlay->rl_s);
	TAILQ_REMOVE(env->sc_relays, rlay, rl_entry);

	/* cleanup sessions */
	while ((con =
	    SPLAY_ROOT(&rlay->rl_sessions)) != NULL)
		relay_close(con, NULL);

	/* cleanup relay */
	if (rlay->rl_bev != NULL)
		bufferevent_free(rlay->rl_bev);
	if (rlay->rl_dstbev != NULL)
		bufferevent_free(rlay->rl_dstbev);

	purge_key(&rlay->rl_tls_cert, rlay->rl_conf.tls_cert_len);
	purge_key(&rlay->rl_tls_key, rlay->rl_conf.tls_key_len);
	purge_key(&rlay->rl_tls_ca, rlay->rl_conf.tls_ca_len);
	purge_key(&rlay->rl_tls_cakey, rlay->rl_conf.tls_cakey_len);

	if (rlay->rl_tls_pkey != NULL) {
		EVP_PKEY_free(rlay->rl_tls_pkey);
		rlay->rl_tls_pkey = NULL;
	}
	if (rlay->rl_tls_cacertx509 != NULL) {
		X509_free(rlay->rl_tls_cacertx509);
		rlay->rl_tls_cacertx509 = NULL;
	}
	if (rlay->rl_tls_capkey != NULL) {
		EVP_PKEY_free(rlay->rl_tls_capkey);
		rlay->rl_tls_capkey = NULL;
	}

	tls_free(rlay->rl_tls_ctx);
	tls_config_free(rlay->rl_tls_cfg);
	tls_config_free(rlay->rl_tls_client_cfg);

	while ((rlt = TAILQ_FIRST(&rlay->rl_tables))) {
		TAILQ_REMOVE(&rlay->rl_tables, rlt, rlt_entry);
		free(rlt);
	}

	free(rlay);
}

struct kv *
kv_add(struct kvtree *keys, char *key, char *value, int unique)
{
	struct kv	*kv, *oldkv;

	if (key == NULL)
		return (NULL);
	if ((kv = calloc(1, sizeof(*kv))) == NULL)
		return (NULL);
	if ((kv->kv_key = strdup(key)) == NULL)
		goto fail;
	if (value != NULL &&
	    (kv->kv_value = strdup(value)) == NULL)
		goto fail;
	TAILQ_INIT(&kv->kv_children);

	if ((oldkv = RB_INSERT(kvtree, keys, kv)) != NULL) {
		/*
		 * return error if the key should occur only once,
		 * or add it to a list attached to the key's node.
		 */
		if (unique)
			goto fail;
		TAILQ_INSERT_TAIL(&oldkv->kv_children, kv, kv_entry);
		kv->kv_parent = oldkv;
	}

	return (kv);
 fail:
	free(kv->kv_key);
	free(kv->kv_value);
	free(kv);
	return (NULL);
}

int
kv_set(struct kv *kv, char *fmt, ...)
{
	va_list		  ap;
	char		*value = NULL;
	struct kv	*ckv;

	va_start(ap, fmt);
	if (vasprintf(&value, fmt, ap) == -1)
		return (-1);
	va_end(ap);

	/* Remove all children */
	while ((ckv = TAILQ_FIRST(&kv->kv_children)) != NULL) {
		TAILQ_REMOVE(&kv->kv_children, ckv, kv_entry);
		kv_free(ckv);
		free(ckv);
	}

	/* Set the new value */
	free(kv->kv_value);
	kv->kv_value = value;

	return (0);
}

int
kv_setkey(struct kv *kv, char *fmt, ...)
{
	va_list  ap;
	char	*key = NULL;

	va_start(ap, fmt);
	if (vasprintf(&key, fmt, ap) == -1)
		return (-1);
	va_end(ap);

	free(kv->kv_key);
	kv->kv_key = key;

	return (0);
}

void
kv_delete(struct kvtree *keys, struct kv *kv)
{
	struct kv	*ckv;

	RB_REMOVE(kvtree, keys, kv);

	/* Remove all children */
	while ((ckv = TAILQ_FIRST(&kv->kv_children)) != NULL) {
		TAILQ_REMOVE(&kv->kv_children, ckv, kv_entry);
		kv_free(ckv);
		free(ckv);
	}

	kv_free(kv);
	free(kv);
}

struct kv *
kv_extend(struct kvtree *keys, struct kv *kv, char *value)
{
	char		*newvalue;

	if (kv == NULL) {
		return (NULL);
	} else if (kv->kv_value != NULL) {
		if (asprintf(&newvalue, "%s%s", kv->kv_value, value) == -1)
			return (NULL);

		free(kv->kv_value);
		kv->kv_value = newvalue;
	} else if ((kv->kv_value = strdup(value)) == NULL)
		return (NULL);

	return (kv);
}

void
kv_purge(struct kvtree *keys)
{
	struct kv	*kv;

	while ((kv = RB_MIN(kvtree, keys)) != NULL)
		kv_delete(keys, kv);
}

void
kv_free(struct kv *kv)
{
	/*
	 * This function does not clear memory referenced by
	 * kv_children or stuff on the tailqs. Use kv_delete() instead.
	 */

	free(kv->kv_key);
	free(kv->kv_value);
	memset(kv, 0, sizeof(*kv));
}

struct kv *
kv_inherit(struct kv *dst, struct kv *src)
{
	memset(dst, 0, sizeof(*dst));
	memcpy(dst, src, sizeof(*dst));
	TAILQ_INIT(&dst->kv_children);

	if (src->kv_key != NULL) {
		if ((dst->kv_key = strdup(src->kv_key)) == NULL) {
			kv_free(dst);
			return (NULL);
		}
	}
	if (src->kv_value != NULL) {
		if ((dst->kv_value = strdup(src->kv_value)) == NULL) {
			kv_free(dst);
			return (NULL);
		}
	}

	if (src->kv_match != NULL)
		dst->kv_match = src->kv_match;
	if (src->kv_matchtree != NULL)
		dst->kv_matchtree = src->kv_matchtree;

	return (dst);
}

int
kv_log(struct rsession *con, struct kv *kv, u_int16_t labelid,
    enum direction dir)
{
	char	*msg;

	if (con->se_log == NULL)
		return (0);
	if (asprintf(&msg, " %s%s%s%s%s%s%s",
	    dir == RELAY_DIR_REQUEST ? "[" : "{",
	    labelid == 0 ? "" : label_id2name(labelid),
	    labelid == 0 ? "" : ", ",
	    kv->kv_key == NULL ? "(unknown)" : kv->kv_key,
	    kv->kv_value == NULL ? "" : ": ",
	    kv->kv_value == NULL ? "" : kv->kv_value,
	    dir == RELAY_DIR_REQUEST ? "]" : "}") == -1)
		return (-1);
	if (evbuffer_add(con->se_log, msg, strlen(msg)) == -1) {
		free(msg);
		return (-1);
	}
	free(msg);
	con->se_haslog = 1;
	return (0);
}

struct kv *
kv_find(struct kvtree *keys, struct kv *kv)
{
	struct kv	*match;
	const char	*key;

	if (kv->kv_flags & KV_FLAG_GLOBBING) {
		/* Test header key using shell globbing rules */
		key = kv->kv_key == NULL ? "" : kv->kv_key;
		RB_FOREACH(match, kvtree, keys) {
			if (fnmatch(key, match->kv_key, FNM_CASEFOLD) == 0)
				break;
		}
	} else {
		/* Fast tree-based lookup only works without globbing */
		match = RB_FIND(kvtree, keys, kv);
	}

	return (match);
}

int
kv_cmp(struct kv *a, struct kv *b)
{
	return (strcasecmp(a->kv_key, b->kv_key));
}

RB_GENERATE(kvtree, kv, kv_node, kv_cmp);

int
rule_add(struct protocol *proto, struct relay_rule *rule, const char *rulefile)
{
	struct relay_rule	*r = NULL;
	struct kv		*kv = NULL;
	FILE			*fp = NULL;
	char			 buf[BUFSIZ];
	int			 ret = -1;
	u_int			 i;

	for (i = 0; i < KEY_TYPE_MAX; i++) {
		kv = &rule->rule_kv[i];
		if (kv->kv_type != i)
			continue;

		switch (kv->kv_option) {
		case KEY_OPTION_LOG:
			/* log action needs a key or a file to be specified */
			if (kv->kv_key == NULL && rulefile == NULL &&
			    (kv->kv_key = strdup("*")) == NULL)
				goto fail;
			break;
		default:
			break;
		}

		switch (kv->kv_type) {
		case KEY_TYPE_QUERY:
		case KEY_TYPE_PATH:
		case KEY_TYPE_URL:
			if (rule->rule_dir != RELAY_DIR_REQUEST)
				goto fail;
			break;
		default:
			break;
		}

		if (kv->kv_value != NULL && strchr(kv->kv_value, '$') != NULL)
			kv->kv_flags |= KV_FLAG_MACRO;
		if (kv->kv_key != NULL && strpbrk(kv->kv_key, "*?[") != NULL)
			kv->kv_flags |= KV_FLAG_GLOBBING;
	}

	if (rulefile == NULL) {
		TAILQ_INSERT_TAIL(&proto->rules, rule, rule_entry);
		return (0);
	}

	if ((fp = fopen(rulefile, "r")) == NULL)
		goto fail;

	while (fgets(buf, sizeof(buf), fp) != NULL) {
		/* strip whitespace and newline characters */
		buf[strcspn(buf, "\r\n\t ")] = '\0';
		if (!strlen(buf) || buf[0] == '#')
			continue;

		if ((r = rule_inherit(rule)) == NULL)
			goto fail;

		for (i = 0; i < KEY_TYPE_MAX; i++) {
			kv = &r->rule_kv[i];
			if (kv->kv_type != i)
				continue;
			free(kv->kv_key);
			if ((kv->kv_key = strdup(buf)) == NULL) {
				rule_free(r);
				free(r);
				goto fail;
			}
		}

		TAILQ_INSERT_TAIL(&proto->rules, r, rule_entry);
	}

	ret = 0;
	rule_free(rule);
	free(rule);

 fail:
	if (fp != NULL)
		fclose(fp);
	return (ret);
}

struct relay_rule *
rule_inherit(struct relay_rule *rule)
{
	struct relay_rule	*r;
	u_int			 i;
	struct kv		*kv;

	if ((r = calloc(1, sizeof(*r))) == NULL)
		return (NULL);
	memcpy(r, rule, sizeof(*r));

	for (i = 0; i < KEY_TYPE_MAX; i++) {
		kv = &rule->rule_kv[i];
		if (kv->kv_type != i)
			continue;
		if (kv_inherit(&r->rule_kv[i], kv) == NULL) {
			free(r);
			return (NULL);
		}
	}

	if (r->rule_label > 0)
		label_ref(r->rule_label);
	if (r->rule_tag > 0)
		tag_ref(r->rule_tag);
	if (r->rule_tagged > 0)
		tag_ref(r->rule_tagged);

	return (r);
}

void
rule_free(struct relay_rule *rule)
{
	u_int	i;

	for (i = 0; i < KEY_TYPE_MAX; i++)
		kv_free(&rule->rule_kv[i]);
	if (rule->rule_label > 0)
		label_unref(rule->rule_label);
	if (rule->rule_tag > 0)
		tag_unref(rule->rule_tag);
	if (rule->rule_tagged > 0)
		tag_unref(rule->rule_tagged);
}

void
rule_delete(struct relay_rules *rules, struct relay_rule *rule)
{
	TAILQ_REMOVE(rules, rule, rule_entry);
	rule_free(rule);
	free(rule);
}

void
rule_settable(struct relay_rules *rules, struct relay_table *rlt)
{
	struct relay_rule	*r;
	char			 pname[TABLE_NAME_SIZE];

	if (rlt->rlt_table == NULL || strlcpy(pname, rlt->rlt_table->conf.name,
	    sizeof(pname)) >= sizeof(pname))
		return;

	pname[strcspn(pname, ":")] = '\0';

	TAILQ_FOREACH(r, rules, rule_entry) {
		if (r->rule_tablename[0] &&
		    strcmp(pname, r->rule_tablename) == 0)
			r->rule_table = rlt;
	}
}

/*
 * Utility functions
 */

struct host *
host_find(struct relayd *env, objid_t id)
{
	struct table	*table;
	struct host	*host;

	TAILQ_FOREACH(table, env->sc_tables, entry)
		TAILQ_FOREACH(host, &table->hosts, entry)
			if (host->conf.id == id)
				return (host);
	return (NULL);
}

struct table *
table_find(struct relayd *env, objid_t id)
{
	struct table	*table;

	TAILQ_FOREACH(table, env->sc_tables, entry)
		if (table->conf.id == id)
			return (table);
	return (NULL);
}

struct rdr *
rdr_find(struct relayd *env, objid_t id)
{
	struct rdr	*rdr;

	TAILQ_FOREACH(rdr, env->sc_rdrs, entry)
		if (rdr->conf.id == id)
			return (rdr);
	return (NULL);
}

struct relay *
relay_find(struct relayd *env, objid_t id)
{
	struct relay	*rlay;

	TAILQ_FOREACH(rlay, env->sc_relays, rl_entry)
		if (rlay->rl_conf.id == id)
			return (rlay);
	return (NULL);
}

struct protocol *
proto_find(struct relayd *env, objid_t id)
{
	struct protocol	*p;

	TAILQ_FOREACH(p, env->sc_protos, entry)
		if (p->id == id)
			return (p);
	return (NULL);
}

struct rsession *
session_find(struct relayd *env, objid_t id)
{
	struct relay		*rlay;
	struct rsession		*con;

	TAILQ_FOREACH(rlay, env->sc_relays, rl_entry)
		SPLAY_FOREACH(con, session_tree, &rlay->rl_sessions)
			if (con->se_id == id)
				return (con);
	return (NULL);
}

struct netroute *
route_find(struct relayd *env, objid_t id)
{
	struct netroute	*nr;

	TAILQ_FOREACH(nr, env->sc_routes, nr_route)
		if (nr->nr_conf.id == id)
			return (nr);
	return (NULL);
}

struct router *
router_find(struct relayd *env, objid_t id)
{
	struct router	*rt;

	TAILQ_FOREACH(rt, env->sc_rts, rt_entry)
		if (rt->rt_conf.id == id)
			return (rt);
	return (NULL);
}

struct host *
host_findbyname(struct relayd *env, const char *name)
{
	struct table	*table;
	struct host	*host;

	TAILQ_FOREACH(table, env->sc_tables, entry)
		TAILQ_FOREACH(host, &table->hosts, entry)
			if (strcmp(host->conf.name, name) == 0)
				return (host);
	return (NULL);
}

struct table *
table_findbyname(struct relayd *env, const char *name)
{
	struct table	*table;

	TAILQ_FOREACH(table, env->sc_tables, entry)
		if (strcmp(table->conf.name, name) == 0)
			return (table);
	return (NULL);
}

struct table *
table_findbyconf(struct relayd *env, struct table *tb)
{
	struct table		*table;
	struct table_config	 a, b;

	bcopy(&tb->conf, &a, sizeof(a));
	a.id = a.rdrid = 0;
	a.flags &= ~(F_USED|F_BACKUP);

	TAILQ_FOREACH(table, env->sc_tables, entry) {
		bcopy(&table->conf, &b, sizeof(b));
		b.id = b.rdrid = 0;
		b.flags &= ~(F_USED|F_BACKUP);

		/*
		 * Compare two tables and return the existing table if
		 * the configuration seems to be the same.
		 */
		if (bcmp(&a, &b, sizeof(b)) == 0 &&
		    ((tb->sendbuf == NULL && table->sendbuf == NULL) ||
		    (tb->sendbuf != NULL && table->sendbuf != NULL &&
		    strcmp(tb->sendbuf, table->sendbuf) == 0)))
			return (table);
	}
	return (NULL);
}

struct rdr *
rdr_findbyname(struct relayd *env, const char *name)
{
	struct rdr	*rdr;

	TAILQ_FOREACH(rdr, env->sc_rdrs, entry)
		if (strcmp(rdr->conf.name, name) == 0)
			return (rdr);
	return (NULL);
}

struct relay *
relay_findbyname(struct relayd *env, const char *name)
{
	struct relay	*rlay;

	TAILQ_FOREACH(rlay, env->sc_relays, rl_entry)
		if (strcmp(rlay->rl_conf.name, name) == 0)
			return (rlay);
	return (NULL);
}

struct relay *
relay_findbyaddr(struct relayd *env, struct relay_config *rc)
{
	struct relay	*rlay;

	TAILQ_FOREACH(rlay, env->sc_relays, rl_entry)
		if (bcmp(&rlay->rl_conf.ss, &rc->ss, sizeof(rc->ss)) == 0 &&
		    rlay->rl_conf.port == rc->port)
			return (rlay);
	return (NULL);
}

EVP_PKEY *
pkey_find(struct relayd *env, char * hash)
{
	struct ca_pkey	*pkey;

	TAILQ_FOREACH(pkey, env->sc_pkeys, pkey_entry)
		if (strcmp(hash, pkey->pkey_hash) == 0)
			return (pkey->pkey);
	return (NULL);
}

struct ca_pkey *
pkey_add(struct relayd *env, EVP_PKEY *pkey, char *hash)
{
	struct ca_pkey	*ca_pkey;

	if (env->sc_pkeys == NULL)
		fatalx("pkeys");

	if ((ca_pkey = calloc(1, sizeof(*ca_pkey))) == NULL)
		return (NULL);

	ca_pkey->pkey = pkey;
	if (strlcpy(ca_pkey->pkey_hash, hash, sizeof(ca_pkey->pkey_hash)) >=
	    sizeof(ca_pkey->pkey_hash))
		return (NULL);

	TAILQ_INSERT_TAIL(env->sc_pkeys, ca_pkey, pkey_entry);

	return (ca_pkey);
}

void
event_again(struct event *ev, int fd, short event,
    void (*fn)(int, short, void *),
    struct timeval *start, struct timeval *end, void *arg)
{
	struct timeval tv_next, tv_now, tv;

	getmonotime(&tv_now);
	bcopy(end, &tv_next, sizeof(tv_next));
	timersub(&tv_now, start, &tv_now);
	timersub(&tv_next, &tv_now, &tv_next);

	bzero(&tv, sizeof(tv));
	if (timercmp(&tv_next, &tv, >))
		bcopy(&tv_next, &tv, sizeof(tv));

	event_del(ev);
	event_set(ev, fd, event, fn, arg);
	event_add(ev, &tv);
}

int
expand_string(char *label, size_t len, const char *srch, const char *repl)
{
	char *tmp;
	char *p, *q;

	if ((tmp = calloc(1, len)) == NULL) {
		log_debug("%s: calloc", __func__);
		return (-1);
	}
	p = q = label;
	while ((q = strstr(p, srch)) != NULL) {
		*q = '\0';
		if ((strlcat(tmp, p, len) >= len) ||
		    (strlcat(tmp, repl, len) >= len)) {
			log_debug("%s: string too long", __func__);
			free(tmp);
			return (-1);
		}
		q += strlen(srch);
		p = q;
	}
	if (strlcat(tmp, p, len) >= len) {
		log_debug("%s: string too long", __func__);
		free(tmp);
		return (-1);
	}
	(void)strlcpy(label, tmp, len);	/* always fits */
	free(tmp);

	return (0);
}

void
translate_string(char *str)
{
	char	*reader;
	char	*writer;

	reader = writer = str;

	while (*reader) {
		if (*reader == '\\') {
			reader++;
			switch (*reader) {
			case 'n':
				*writer++ = '\n';
				break;
			case 'r':
				*writer++ = '\r';
				break;
			default:
				*writer++ = *reader;
			}
		} else
			*writer++ = *reader;
		reader++;
	}
	*writer = '\0';
}

char *
digeststr(enum digest_type type, const u_int8_t *data, size_t len, char *buf)
{
	switch (type) {
	case DIGEST_SHA1:
		return (SHA1Data(data, len, buf));
		break;
	case DIGEST_MD5:
		return (MD5Data(data, len, buf));
		break;
	default:
		break;
	}
	return (NULL);
}

const char *
canonicalize_host(const char *host, char *name, size_t len)
{
	struct sockaddr_in	 sin4;
	struct sockaddr_in6	 sin6;
	size_t			 i, j;
	size_t			 plen;
	char			 c;

	if (len < 2)
		goto fail;

	/*
	 * Canonicalize an IPv4/6 address
	 */
	if (inet_pton(AF_INET, host, &sin4) == 1)
		return (inet_ntop(AF_INET, &sin4, name, len));
	if (inet_pton(AF_INET6, host, &sin6) == 1)
		return (inet_ntop(AF_INET6, &sin6, name, len));

	/*
	 * Canonicalize a hostname
	 */

	/* 1. remove repeated dots and convert upper case to lower case */
	plen = strlen(host);
	bzero(name, len);
	for (i = j = 0; i < plen; i++) {
		if (j >= (len - 1))
			goto fail;
		c = tolower((unsigned char)host[i]);
		if ((c == '.') && (j == 0 || name[j - 1] == '.'))
			continue;
		name[j++] = c;
	}

	/* 2. remove trailing dots */
	for (i = j; i > 0; i--) {
		if (name[i - 1] != '.')
			break;
		name[i - 1] = '\0';
		j--;
	}
	if (j <= 0)
		goto fail;

	return (name);

 fail:
	errno = EINVAL;
	return (NULL);
}

int
parse_url(const char *url, char **protoptr, char **hostptr, char **pathptr)
{
	char	*p, *proto = NULL, *host = NULL, *path = NULL;

	/* return error if it is not a URL */
	if ((p = strstr(url, ":/")) == NULL ||
	    (strcspn(url, ":/") != (size_t)(p - url)))
		return (-1);

	/* get protocol */
	if ((proto = strdup(url)) == NULL)
		goto fail;
	p = proto + (p - url);

	/* get host */
	p += strspn(p, ":/");
	if (*p == '\0' || (host = strdup(p)) == NULL)
		goto fail;
	*p = '\0';

	/* find and copy path or default to "/" */
	if ((p = strchr(host, '/')) == NULL)
		p = "/";
	if ((path = strdup(p)) == NULL)
		goto fail;

	/* strip path after host */
	host[strcspn(host, "/")] = '\0';

	DPRINTF("%s: %s proto %s, host %s, path %s", __func__,
	    url, proto, host, path);

	*protoptr = proto;
	*hostptr = host;
	*pathptr = path;

	return (0);

 fail:
	free(proto);
	free(host);
	free(path);
	return (-1);
}

int
bindany(struct ctl_bindany *bnd)
{
	int	s, v;

	s = -1;
	v = 1;

	if (relay_socket_af(&bnd->bnd_ss, bnd->bnd_port) == -1)
		goto fail;
	if ((s = socket(bnd->bnd_ss.ss_family,
	    bnd->bnd_proto == IPPROTO_TCP ? SOCK_STREAM : SOCK_DGRAM,
	    bnd->bnd_proto)) == -1)
		goto fail;
	if (setsockopt(s, SOL_SOCKET, SO_BINDANY,
	    &v, sizeof(v)) == -1)
		goto fail;
	if (bind(s, (struct sockaddr *)&bnd->bnd_ss,
	    bnd->bnd_ss.ss_len) == -1)
		goto fail;

	return (s);

 fail:
	if (s != -1)
		close(s);
	return (-1);
}

int
map6to4(struct sockaddr_storage *in6)
{
	struct sockaddr_storage	 out4;
	struct sockaddr_in	*sin4 = (struct sockaddr_in *)&out4;
	struct sockaddr_in6	*sin6 = (struct sockaddr_in6 *)in6;

	bzero(sin4, sizeof(*sin4));
	sin4->sin_len = sizeof(*sin4);
	sin4->sin_family = AF_INET;
	sin4->sin_port = sin6->sin6_port;

	bcopy(&sin6->sin6_addr.s6_addr[12], &sin4->sin_addr.s_addr,
	    sizeof(sin4->sin_addr));

	if (sin4->sin_addr.s_addr == INADDR_ANY ||
	    sin4->sin_addr.s_addr == INADDR_BROADCAST ||
	    IN_MULTICAST(ntohl(sin4->sin_addr.s_addr)))
		return (-1);

	bcopy(&out4, in6, sizeof(*in6));

	return (0);
}

int
map4to6(struct sockaddr_storage *in4, struct sockaddr_storage *map)
{
	struct sockaddr_storage	 out6;
	struct sockaddr_in	*sin4 = (struct sockaddr_in *)in4;
	struct sockaddr_in6	*sin6 = (struct sockaddr_in6 *)&out6;
	struct sockaddr_in6	*map6 = (struct sockaddr_in6 *)map;

	if (sin4->sin_addr.s_addr == INADDR_ANY ||
	    sin4->sin_addr.s_addr == INADDR_BROADCAST ||
	    IN_MULTICAST(ntohl(sin4->sin_addr.s_addr)))
		return (-1);

	bcopy(map6, sin6, sizeof(*sin6));
	sin6->sin6_len = sizeof(*sin6);
	sin6->sin6_family = AF_INET6;
	sin6->sin6_port = sin4->sin_port;

	bcopy(&sin4->sin_addr.s_addr, &sin6->sin6_addr.s6_addr[12],
	    sizeof(sin4->sin_addr));

	bcopy(&out6, in4, sizeof(*in4));

	return (0);
}

void
socket_rlimit(int maxfd)
{
	struct rlimit	 rl;

	if (getrlimit(RLIMIT_NOFILE, &rl) == -1)
		fatal("%s: failed to get resource limit", __func__);
	log_debug("%s: max open files %llu", __func__, rl.rlim_max);

	/*
	 * Allow the maximum number of open file descriptors for this
	 * login class (which should be the class "daemon" by default).
	 */
	if (maxfd == -1)
		rl.rlim_cur = rl.rlim_max;
	else
		rl.rlim_cur = MAXIMUM(rl.rlim_max, (rlim_t)maxfd);
	if (setrlimit(RLIMIT_NOFILE, &rl) == -1)
		fatal("%s: failed to set resource limit", __func__);
}

char *
get_string(u_int8_t *ptr, size_t len)
{
	size_t	 i;

	for (i = 0; i < len; i++)
		if (!(isprint((unsigned char)ptr[i]) ||
		    isspace((unsigned char)ptr[i])))
			break;

	return strndup(ptr, i);
}

void *
get_data(u_int8_t *ptr, size_t len)
{
	u_int8_t	*data;

	if ((data = malloc(len)) == NULL)
		return (NULL);
	memcpy(data, ptr, len);

	return (data);
}

int
sockaddr_cmp(struct sockaddr *a, struct sockaddr *b, int prefixlen)
{
	struct sockaddr_in	*a4, *b4;
	struct sockaddr_in6	*a6, *b6;
	u_int32_t		 av[4], bv[4], mv[4];

	if (a->sa_family == AF_UNSPEC || b->sa_family == AF_UNSPEC)
		return (0);
	else if (a->sa_family > b->sa_family)
		return (1);
	else if (a->sa_family < b->sa_family)
		return (-1);

	if (prefixlen == -1)
		memset(&mv, 0xff, sizeof(mv));

	switch (a->sa_family) {
	case AF_INET:
		a4 = (struct sockaddr_in *)a;
		b4 = (struct sockaddr_in *)b;

		av[0] = a4->sin_addr.s_addr;
		bv[0] = b4->sin_addr.s_addr;
		if (prefixlen != -1)
			mv[0] = prefixlen2mask(prefixlen);

		if ((av[0] & mv[0]) > (bv[0] & mv[0]))
			return (1);
		if ((av[0] & mv[0]) < (bv[0] & mv[0]))
			return (-1);
		break;
	case AF_INET6:
		a6 = (struct sockaddr_in6 *)a;
		b6 = (struct sockaddr_in6 *)b;

		memcpy(&av, &a6->sin6_addr.s6_addr, 16);
		memcpy(&bv, &b6->sin6_addr.s6_addr, 16);
		if (prefixlen != -1)
			prefixlen2mask6(prefixlen, mv);

		if ((av[3] & mv[3]) > (bv[3] & mv[3]))
			return (1);
		if ((av[3] & mv[3]) < (bv[3] & mv[3]))
			return (-1);
		if ((av[2] & mv[2]) > (bv[2] & mv[2]))
			return (1);
		if ((av[2] & mv[2]) < (bv[2] & mv[2]))
			return (-1);
		if ((av[1] & mv[1]) > (bv[1] & mv[1]))
			return (1);
		if ((av[1] & mv[1]) < (bv[1] & mv[1]))
			return (-1);
		if ((av[0] & mv[0]) > (bv[0] & mv[0]))
			return (1);
		if ((av[0] & mv[0]) < (bv[0] & mv[0]))
			return (-1);
		break;
	}

	return (0);
}

u_int32_t
prefixlen2mask(u_int8_t prefixlen)
{
	if (prefixlen == 0)
		return (0);

	if (prefixlen > 32)
		prefixlen = 32;

	return (htonl(0xffffffff << (32 - prefixlen)));
}

struct in6_addr *
prefixlen2mask6(u_int8_t prefixlen, u_int32_t *mask)
{
	static struct in6_addr  s6;
	int			i;

	if (prefixlen > 128)
		prefixlen = 128;

	bzero(&s6, sizeof(s6));
	for (i = 0; i < prefixlen / 8; i++)
		s6.s6_addr[i] = 0xff;
	i = prefixlen % 8;
	if (i)
		s6.s6_addr[prefixlen / 8] = 0xff00 >> i;

	memcpy(mask, &s6, sizeof(s6));

	return (&s6);
}

int
accept_reserve(int sockfd, struct sockaddr *addr, socklen_t *addrlen,
    int reserve, volatile int *counter)
{
	int ret;
	if (getdtablecount() + reserve +
	    *counter >= getdtablesize()) {
		errno = EMFILE;
		return (-1);
	}

	if ((ret = accept4(sockfd, addr, addrlen, SOCK_NONBLOCK)) > -1) {
		(*counter)++;
		DPRINTF("%s: inflight incremented, now %d",__func__, *counter);
	}
	return (ret);
}

void
parent_tls_ticket_rekey(int fd, short events, void *arg)
{
	static struct event	 rekeyev;
	struct relayd		*env = arg;
	struct timeval		 tv;
	struct relay_ticket_key	 key;

	log_debug("%s: rekeying tickets", __func__);

	key.tt_keyrev = arc4random();
	arc4random_buf(key.tt_key, sizeof(key.tt_key));

	proc_compose_imsg(env->sc_ps, PROC_RELAY, -1, IMSG_TLSTICKET_REKEY,
	    -1, -1, &key, sizeof(key));

	evtimer_set(&rekeyev, parent_tls_ticket_rekey, env);
	timerclear(&tv);
	tv.tv_sec = TLS_SESSION_LIFETIME / 4;
	evtimer_add(&rekeyev, &tv);
}
@


1.167
log
@Migrate relayd to use libtls for TLS. Still does the TLS privsep via the
engine but at least we can use a sane API for new features.
Going in now so it is possible to work with this in tree.
General agreement at d2k17.
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.c,v 1.166 2017/05/06 19:44:53 fcambus Exp $	*/
d478 1
a478 2
			fatalx("pfe_dispatch_relay: "
			    "invalid relay proc");
d484 2
a485 2
			fatalx("pfe_dispatch_relay: requested socket "
			    "for invalid protocol");
d1190 1
a1190 1
		
d1479 1
a1479 1
		fatal("socket_rlimit: failed to get resource limit");
d1491 1
a1491 1
		fatal("socket_rlimit: failed to set resource limit");
d1641 1
a1641 1
	log_debug("relayd_tls_ticket_rekey: rekeying tickets");
@


1.166
log
@Convert explicit_bzero() + free() to freezero().

OK reyk@@, deraadt@@ (previous version)
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.c,v 1.165 2017/01/24 10:49:14 benno Exp $	*/
d46 1
a46 1
#include <openssl/ssl.h>
d533 1
a533 1
		SSL_free(host->cte.ssl);
d537 1
a537 2
	if (table->conf.flags & F_TLS)
		SSL_CTX_free(table->ssl_ctx);
a579 4
	if (rlay->rl_tls_x509 != NULL) {
		X509_free(rlay->rl_tls_x509);
		rlay->rl_tls_x509 = NULL;
	}
d593 3
a595 1
	SSL_CTX_free(rlay->rl_ssl_ctx);
d1166 1
a1166 1
pkey_find(struct relayd *env, objid_t id)
d1171 1
a1171 1
		if (pkey->pkey_id == id)
d1177 1
a1177 1
pkey_add(struct relayd *env, EVP_PKEY *pkey, objid_t id)
d1188 4
a1191 2
	ca_pkey->pkey_id = id;

d1640 1
a1640 1
	struct tls_ticket	 key;
d1644 2
a1645 4
	arc4random_buf(key.tt_key_name, sizeof(key.tt_key_name));
	arc4random_buf(key.tt_hmac_key, sizeof(key.tt_hmac_key));
	arc4random_buf(key.tt_aes_key, sizeof(key.tt_aes_key));
	key.tt_backup = 0;
d1652 1
a1652 1
	tv.tv_sec = TLS_TICKET_REKEY_TIME;
@


1.165
log
@move the opening of /dev/pf from the parent process to the pfe process
where it is used.
Currently pf is opened on every reload, that will no longer be
possible in the future with pledged programms that do ioctls.
This prepares relayd for that change.

ok deraadt@@, meinetwegen reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.c,v 1.164 2017/01/09 14:49:21 reyk Exp $	*/
d546 1
a546 1
purge_key(char **ptr, off_t len)
d548 1
a548 1
	char	*key = *ptr;
d550 1
a550 7
	if (key == NULL || len == 0)
		return;

	explicit_bzero(key, len);
	free(key);

	*ptr = NULL;
@


1.164
log
@Stop accessing verbose and debug variables from log.c directly.

This replaces log_verbose() and "extern int verbose" with the two functions
log_setverbose() and log_getverbose().

Pointed out by benno@@
OK krw@@ eric@@ gilles@@ (OK gilles@@ for the snmpd bits as well)
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.c,v 1.163 2016/11/24 21:01:18 reyk Exp $	*/
d282 1
a282 1
	int			 s, ret = -1;
a310 11

		if ((env->sc_conf.flags & F_NEEDPF) && id == PROC_PFE) {
			/* Send pf socket to the pf engine */
			if ((s = open(PF_SOCKET, O_RDWR)) == -1) {
				log_debug("%s: cannot open pf socket",
				    __func__);
				goto done;
			}
		} else
			s = -1;

d312 1
a312 1
		    s, &env->sc_conf, sizeof(env->sc_conf));
a316 1
 done:
@


1.163
log
@The new fork+exec mode used too many fds in the parent process on
startup, for a short time, so we needed a rlimit hack in relayd.c.
Sync the fix from httpd: rzalamena@@ has fixed proc.c and I added the
proc_flush_imsg() mechanism that makes sure that each fd is
immediately closed after forwarding it to a child process instead of
queueing it up.

OK rzalamena@@ jca@@ benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.c,v 1.162 2016/09/28 12:16:44 reyk Exp $	*/
d206 1
a206 1
	log_verbose(verbose);
@


1.162
log
@sync proc.c incl. the p_env removal
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.c,v 1.161 2016/09/27 21:39:27 bluhm Exp $	*/
a215 5

	if (proc_id == PROC_PARENT) {
		/* XXX the parent opens too many fds in proc_open() */
		socket_rlimit(-1);
	}
@


1.161
log
@The fork+exec privsep commit broke the "block request method" http
config option.  Due to reordering of the code, the variable
http_methods was initialized to late.  Insert a relay_http() before
load_config().
Found by make run-regress-args-http-filter-method.pl; OK reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.c,v 1.160 2016/09/03 14:09:04 reyk Exp $	*/
d413 2
a414 1
	struct relayd		*env = p->p_env;
d461 2
a462 2
	struct relayd		*env = p->p_env;
	struct privsep		*ps = env->sc_ps;
d485 2
a486 2
	struct relayd		*env = p->p_env;
	struct privsep		*ps = env->sc_ps;
d523 2
a524 1
	struct relayd		*env = p->p_env;
@


1.160
log
@Use the fork+exec privsep model in relayd; based on rzalamena@@'s work
for httpd with some (current and previous) changes for relayd.  Once
again, both daemons now share the same proc.c where most of the
privsep "magic" happens.

OK benno@@ rzalamena@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.c,v 1.159 2016/09/02 14:45:51 reyk Exp $	*/
d248 1
@


1.159
log
@Split "struct relayd" into two structs: "struct relayd" and "struct
relayd_config".  This way we can send all the relevant global
configuration to the children, not just the flags and the opts.

With input from and
OK claudio@@ benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.c,v 1.158 2016/09/02 12:12:51 reyk Exp $	*/
d124 4
d129 1
a129 1
	while ((c = getopt(argc, argv, "dD:nf:v")) != -1) {
d150 12
a207 3
	if (!debug && daemon(1, 0) == -1)
		err(1, "failed to daemonize");

a209 2
	else
		log_info("startup");
d213 11
a224 1
	proc_init(ps, procs, nitems(procs));
d226 5
d246 1
a246 1
	proc_listen(ps, procs, nitems(procs));
@


1.158
log
@As done in httpd, remove ps_ninstances and p_instance.

OK benno@@ rzalamena@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.c,v 1.157 2016/09/02 11:51:50 reyk Exp $	*/
d167 1
a167 1
	env->sc_opts = opts;
d172 1
a172 1
	arc4random_buf(env->sc_tls_sid, sizeof(env->sc_tls_sid));
d178 1
a178 1
		env->sc_opts |= RELAYD_OPT_LOGUPDATE;
d195 1
a195 1
	if (env->sc_opts & RELAYD_OPT_NOACTION)
d200 2
a201 2
	ps->ps_instances[PROC_RELAY] = env->sc_prefork_relay;
	ps->ps_instances[PROC_CA] = env->sc_prefork_relay;
d227 1
a227 1
	if (env->sc_opts & RELAYD_OPT_NOACTION) {
d233 1
a233 1
	if (env->sc_flags & (F_TLS|F_TLSCLIENT))
a259 1
	struct ctl_flags	 cf;
d284 1
a284 1
	env->sc_reload = 2 + (2 * env->sc_prefork_relay);
a288 2
		cf.cf_opts = env->sc_opts;
		cf.cf_flags = env->sc_flags;
d290 1
a290 1
		if ((env->sc_flags & F_NEEDPF) && id == PROC_PFE) {
d301 1
a301 1
		    s, &cf, sizeof(cf));
d466 1
a466 1
		if (bnd.bnd_proc > env->sc_prefork_relay)
@


1.157
log
@Terminate relayd using the socket status instead of watching SIGCHLD
or killing child processes. - Based on rzalamena@@'s diff for httpd.

OK deraadt@@ rzalamena@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.c,v 1.156 2016/09/01 10:49:48 claudio Exp $	*/
a201 1
	ps->ps_ninstances = env->sc_prefork_relay;
@


1.156
log
@Switch from the not really working session cache (because of the multiprocess
nature of relayd) to tls session tickets to do TLS session resumption.
TLS session tickets do not need to store SSL session data in the server but
instead send an encrypted ticket to the clients that allows to resume the
session. This is mostly stateless (apart from the encryption keys).
relayd now ensures that all relay processes use the same key to encrypt
the tickets. Keys are rotated every 2h and there is a primary and backup key.
The tls session timeout is set to 2h to hint to the clients how long the
session tickets is supposed to be alive.
Input and OK benno@@, reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.c,v 1.155 2016/07/29 10:09:26 reyk Exp $	*/
a80 3
	int		 die = 0, status, fail, id;
	pid_t		 pid;
	char		*cause;
d85 1
a85 43
		die = 1;
		/* FALLTHROUGH */
	case SIGCHLD:
		do {
			int len;

			pid = waitpid(WAIT_ANY, &status, WNOHANG);
			if (pid <= 0)
				continue;

			fail = 0;
			if (WIFSIGNALED(status)) {
				fail = 1;
				len = asprintf(&cause, "terminated; signal %d",
				    WTERMSIG(status));
			} else if (WIFEXITED(status)) {
				if (WEXITSTATUS(status) != 0) {
					fail = 1;
					len = asprintf(&cause,
					    "exited abnormally");
				} else
					len = asprintf(&cause, "exited okay");
			} else
				fatalx("unexpected cause of SIGCHLD");

			if (len == -1)
				fatal("asprintf");

			die = 1;

			for (id = 0; id < PROC_MAX; id++)
				if (pid == ps->ps_pid[id]) {
					if (fail)
						log_warnx("lost child: %s %s",
						    ps->ps_title[id], cause);
					break;
				}

			free(cause);
		} while (pid > 0 || (pid == -1 && errno == EINTR));

		if (die)
			parent_shutdown(ps->ps_env);
a210 1
	signal_set(&ps->ps_evsigchld, SIGCHLD, parent_sig_handler, ps);
a216 1
	signal_add(&ps->ps_evsigchld, NULL);
@


1.155
log
@Bump copyright in files that I touched last.
(btw. hostated-hoststated-relayd's 10th birthday is on Dec 16.)
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.c,v 1.154 2016/07/27 06:55:44 reyk Exp $	*/
d66 1
d216 2
d284 2
d1678 24
@


1.154
log
@Improve parsing of the Host by following RFC 7230 Section 5.4 more strictly:

- Respond with a 400 (Bad Request) if there is more than one Host:
header to prevent ambiguities.

- Make sure that the host in the optional absolute form of
request-target (eg. GET http://www.target.com/ HTTP/1.1) matches the
Host: value.  Proxies are supposed to ignore the Host: value if the
request-target exists, but relayd used to ignore the absolute
request-target form instead.  In HTTP terminology, relayd is a gateway
and not a proxy, but it has to make sure that the host is validated
consistently.

OK benno@@ bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.c,v 1.153 2016/02/02 17:51:11 sthen Exp $	*/
d4 1
a4 1
 * Copyright (c) 2007 - 2014 Reyk Floeter <reyk@@openbsd.org>
@


1.153
log
@Remove setproctitle() for the parent process. Because rc.d(8) uses process
titles (including flags) to distinguish between daemons, this makes it
possible to manage multiple copies of a daemon using the normal infrastructure
by symlinking rc.d scripts to a new name. ok jung@@ ajacoutot@@, smtpd ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.c,v 1.152 2015/12/30 16:00:57 benno Exp $	*/
a647 1

d649 1
a649 1
kv_add(struct kvtree *keys, char *key, char *value)
d657 2
a658 4
	if ((kv->kv_key = strdup(key)) == NULL) {
		free(kv);
		return (NULL);
	}
d660 2
a661 5
	    (kv->kv_value = strdup(value)) == NULL) {
		free(kv->kv_key);
		free(kv);
		return (NULL);
	}
d665 6
d676 5
d1387 46
@


1.153.2.1
log
@Improve parsing of the Host-header by following RFC 7230 Section 5.4 more
strictly. MFC relay_http.c v 1.57, relayd.c v 1.154, relayd.h v 1.224
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.c,v 1.153 2016/02/02 17:51:11 sthen Exp $	*/
d648 1
d650 1
a650 1
kv_add(struct kvtree *keys, char *key, char *value, int unique)
d658 4
a661 2
	if ((kv->kv_key = strdup(key)) == NULL)
		goto fail;
d663 5
a667 2
	    (kv->kv_value = strdup(value)) == NULL)
		goto fail;
a670 6
		/*
		 * return error if the key should occur only once,
		 * or add it to a list attached to the key's node.
		 */
		if (unique)
			goto fail;
a675 5
 fail:
	free(kv->kv_key);
	free(kv->kv_value);
	free(kv);
	return (NULL);
a1381 46
}

int
parse_url(const char *url, char **protoptr, char **hostptr, char **pathptr)
{
	char	*p, *proto = NULL, *host = NULL, *path = NULL;

	/* return error if it is not a URL */
	if ((p = strstr(url, ":/")) == NULL ||
	    (strcspn(url, ":/") != (size_t)(p - url)))
		return (-1);

	/* get protocol */
	if ((proto = strdup(url)) == NULL)
		goto fail;
	p = proto + (p - url);

	/* get host */
	p += strspn(p, ":/");
	if (*p == '\0' || (host = strdup(p)) == NULL)
		goto fail;
	*p = '\0';

	/* find and copy path or default to "/" */
	if ((p = strchr(host, '/')) == NULL)
		p = "/";
	if ((path = strdup(p)) == NULL)
		goto fail;

	/* strip path after host */
	host[strcspn(host, "/")] = '\0';

	DPRINTF("%s: %s proto %s, host %s, path %s", __func__,
	    url, proto, host, path);

	*protoptr = proto;
	*hostptr = host;
	*pathptr = path;

	return (0);

 fail:
	free(proto);
	free(host);
	free(path);
	return (-1);
@


1.153.4.1
log
@Improve parsing of the Host-header by following RFC 7230 Section 5.4 more
strictly. MFC relay_http.c v 1.57, relayd.c v 1.154, relayd.h v 1.224
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.c,v 1.153 2016/02/02 17:51:11 sthen Exp $	*/
d648 1
d650 1
a650 1
kv_add(struct kvtree *keys, char *key, char *value, int unique)
d658 4
a661 2
	if ((kv->kv_key = strdup(key)) == NULL)
		goto fail;
d663 5
a667 2
	    (kv->kv_value = strdup(value)) == NULL)
		goto fail;
a670 6
		/*
		 * return error if the key should occur only once,
		 * or add it to a list attached to the key's node.
		 */
		if (unique)
			goto fail;
a675 5
 fail:
	free(kv->kv_key);
	free(kv->kv_value);
	free(kv);
	return (NULL);
a1381 46
}

int
parse_url(const char *url, char **protoptr, char **hostptr, char **pathptr)
{
	char	*p, *proto = NULL, *host = NULL, *path = NULL;

	/* return error if it is not a URL */
	if ((p = strstr(url, ":/")) == NULL ||
	    (strcspn(url, ":/") != (size_t)(p - url)))
		return (-1);

	/* get protocol */
	if ((proto = strdup(url)) == NULL)
		goto fail;
	p = proto + (p - url);

	/* get host */
	p += strspn(p, ":/");
	if (*p == '\0' || (host = strdup(p)) == NULL)
		goto fail;
	*p = '\0';

	/* find and copy path or default to "/" */
	if ((p = strchr(host, '/')) == NULL)
		p = "/";
	if ((path = strdup(p)) == NULL)
		goto fail;

	/* strip path after host */
	host[strcspn(host, "/")] = '\0';

	DPRINTF("%s: %s proto %s, host %s, path %s", __func__,
	    url, proto, host, path);

	*protoptr = proto;
	*hostptr = host;
	*pathptr = path;

	return (0);

 fail:
	free(proto);
	free(host);
	free(path);
	return (-1);
@


1.152
log
@SSL_CTX_free() and SSL_free() check for null so dont do it in relayd
ok jung@@ tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.c,v 1.151 2015/12/30 12:08:34 benno Exp $	*/
a246 2

	setproctitle("parent");
@


1.151
log
@now that ibuf_free() checks for null, we can remove the check here.
ok mmcc@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.c,v 1.150 2015/12/07 04:03:27 mmcc Exp $	*/
d569 1
a569 2
		if (host->cte.ssl != NULL)
			SSL_free(host->cte.ssl);
d640 1
a640 2
	if (rlay->rl_ssl_ctx != NULL)
		SSL_CTX_free(rlay->rl_ssl_ctx);
@


1.150
log
@Remove NULL-checks before free(). No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.c,v 1.149 2015/12/02 13:41:27 reyk Exp $	*/
d568 1
a568 2
		if (host->cte.buf != NULL)
			ibuf_free(host->cte.buf);
@


1.149
log
@In most cases we don't need all arguments of proc_compose*_imsg(),
so add a shortcut proc_compose*() that skips all of them.  Only use the
full argument list if needed.  The functions with full argument lists can
eventually be replaced with a nicer transaction-based approach later.

OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.c,v 1.148 2015/11/29 01:20:33 benno Exp $	*/
d460 1
a460 2
		if (str != NULL)
			free(str);
d574 1
a574 2
	if (table->sendbuf != NULL)
		free(table->sendbuf);
d703 1
a703 2
	if (kv->kv_value != NULL)
		free(kv->kv_value);
d720 1
a720 2
	if (kv->kv_key != NULL)
		free(kv->kv_key);
d932 1
a932 2
			if (kv->kv_key != NULL)
				free(kv->kv_key);
@


1.148
log
@Use pledge("pf") in pfe.c.
Move getrtable() from pfe to parent process, since its in the way of
pledge.

ok deraadt@@, feedback from reyk@@ on previous version.
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.c,v 1.147 2015/11/28 09:52:07 reyk Exp $	*/
d348 2
a349 2
		proc_compose_imsg(env->sc_ps, id, -1, IMSG_CFG_DONE, s,
		    &cf, sizeof(cf));
d408 1
a408 2
			proc_compose_imsg(env->sc_ps, id, -1, IMSG_CTL_START,
			    -1, NULL, 0);
d491 1
a491 2
		proc_compose_imsg(ps, PROC_HCE, -1, IMSG_SCRIPT,
		    -1, &scr, sizeof(scr));
d529 1
a529 1
		    IMSG_BINDANY, s, &bnd.bnd_id, sizeof(bnd.bnd_id));
@


1.147
log
@Use SOCK_NONBLOCK in relayd as well.

OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.c,v 1.146 2015/11/22 13:27:13 reyk Exp $	*/
d214 1
@


1.146
log
@Update log.c: change fatal() and fatalx() into variadic functions,
include the process name, and replace all calls of fatal*(NULL) with
fatal(__func__) for better debugging.

OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.c,v 1.145 2015/11/19 21:32:53 mmcc Exp $	*/
d1628 1
a1628 1
	if ((ret = accept(sockfd, addr, addrlen)) > -1) {
@


1.145
log
@Simplify all instances of get_string() and get_data() using malloc() and
strndup().

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.c,v 1.144 2015/10/14 07:58:14 reyk Exp $	*/
d36 1
d195 2
a196 1
	log_init(debug ? debug : 1);	/* log to stderr until daemonized */
d230 1
a230 1
	log_init(debug);
d248 1
@


1.144
log
@More (unsigned char) casts for ctype functions.

Pointed out by Michael McConville
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.c,v 1.143 2015/07/29 20:55:43 benno Exp $	*/
a1496 1
	char	*str;
d1503 1
a1503 5
	if ((str = calloc(1, i + 1)) == NULL)
		return (NULL);
	memcpy(str, ptr, i);

	return (str);
d1511 1
a1511 1
	if ((data = calloc(1, len)) == NULL)
@


1.143
log
@fix bug where other than the last of multiple forward rules in http
protocols would be ignored, reported and fixed by J. Fischer (lists
-AT- mistrust -DOT- net) and reminded by (trondd -AT- kagu-tsuchi -DOT-
com), thanks!
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.c,v 1.142 2015/06/03 02:24:36 millert Exp $	*/
d1369 1
a1369 1
		c = tolower(host[i]);
d1500 2
a1501 1
		if (!(isprint(ptr[i]) || isspace(ptr[i])))
@


1.143.4.1
log
@Improve parsing of the Host-header by following RFC 7230 Section 5.4 more
strictly. MFC relay_http.c v 1.57, relayd.c v 1.154, relayd.h v 1.224
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.c,v 1.143 2015/07/29 20:55:43 benno Exp $	*/
d653 1
d655 1
a655 1
kv_add(struct kvtree *keys, char *key, char *value, int unique)
d663 4
a666 2
	if ((kv->kv_key = strdup(key)) == NULL)
		goto fail;
d668 5
a672 2
	    (kv->kv_value = strdup(value)) == NULL)
		goto fail;
a675 6
		/*
		 * return error if the key should occur only once,
		 * or add it to a list attached to the key's node.
		 */
		if (unique)
			goto fail;
a680 5
 fail:
	free(kv->kv_key);
	free(kv->kv_value);
	free(kv);
	return (NULL);
a1389 46
}

int
parse_url(const char *url, char **protoptr, char **hostptr, char **pathptr)
{
	char	*p, *proto = NULL, *host = NULL, *path = NULL;

	/* return error if it is not a URL */
	if ((p = strstr(url, ":/")) == NULL ||
	    (strcspn(url, ":/") != (size_t)(p - url)))
		return (-1);

	/* get protocol */
	if ((proto = strdup(url)) == NULL)
		goto fail;
	p = proto + (p - url);

	/* get host */
	p += strspn(p, ":/");
	if (*p == '\0' || (host = strdup(p)) == NULL)
		goto fail;
	*p = '\0';

	/* find and copy path or default to "/" */
	if ((p = strchr(host, '/')) == NULL)
		p = "/";
	if ((path = strdup(p)) == NULL)
		goto fail;

	/* strip path after host */
	host[strcspn(host, "/")] = '\0';

	DPRINTF("%s: %s proto %s, host %s, path %s", __func__,
	    url, proto, host, path);

	*protoptr = proto;
	*hostptr = host;
	*pathptr = path;

	return (0);

 fail:
	free(proto);
	free(host);
	free(path);
	return (-1);
@


1.142
log
@Do not assume that asprintf() clears the pointer on failure, which
is non-portable.  Also add missing asprintf() return value checks.
OK deraadt@@ guenther@@ doug@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.c,v 1.141 2015/05/30 09:47:25 claudio Exp $	*/
d1024 1
a1024 1
		    strcmp(pname, r->rule_tablename) == 0) {
a1025 3
		} else {
			r->rule_table = NULL;
		}
@


1.141
log
@Plug a memory leak by simplifying kv_free(). By checking the type and
returning early the key and value memory got leaked on HTTP header kvs
since their type was never set.
OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.c,v 1.140 2015/05/28 17:08:09 florian Exp $	*/
d90 2
d99 1
a99 1
				asprintf(&cause, "terminated; signal %d",
d104 2
a105 1
					asprintf(&cause, "exited abnormally");
d107 1
a107 1
					asprintf(&cause, "exited okay");
d110 3
@


1.140
log
@Do not try to unlink the control socket in an unprivileged child
process on shutdown.
Found while working on tame(2).
OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.c,v 1.139 2015/05/02 13:15:24 claudio Exp $	*/
d771 7
a777 12
	if (kv->kv_type == KEY_TYPE_NONE)
		return;
	if (kv->kv_key != NULL) {
		free(kv->kv_key);
	}
	kv->kv_key = NULL;
	if (kv->kv_value != NULL) {
		free(kv->kv_value);
	}
	kv->kv_value = NULL;
	kv->kv_matchtree = NULL;
	kv->kv_match = NULL;
@


1.139
log
@Fix obvious problems with relayd config reload.
- fix a TAILQ corruption because of a use after free
- do not reinit the SSL engine since that fails
OK sthen, benno
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.c,v 1.138 2015/01/22 17:42:09 reyk Exp $	*/
d411 1
@


1.138
log
@Clean up the relayd headers with help of include-what-you-use and some
manual review.  Based on common practice, relayd.h now includes the
necessary headers for itself.

OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.c,v 1.137 2015/01/22 15:21:28 reyk Exp $	*/
d549 1
a549 1
purge_table(struct tablelist *head, struct table *table)
d555 1
@


1.138.2.1
log
@maintainance diff for relayd
MFC the following changes

- Missing free(3) in error path (ssl.c,v 1.29)
- fix a memory leak. (pfe.c,v 1.80)
- allocate se_log evbuffer before loging errors with relay_close()
  (relay.c,v 1.192)
- fix a file descriptor leak in http protocol handling
  (relay.c,v 1.193 and relay_http.c,v 1.44)
- Fix obvious problems with relayd config reload
  (ca.c,v 1.13; config.c,v 1.25; parse.y,v 1.204;
  relayd.c,v 1.139; relayd.h,v 1.209)
- http protocol: you cannot append to the previous key-value before
  line three of a request (relay_http.c,v 1.45)
- fix a crash / use after free (relay.c,v 1.194; relay_http.c,v 1.46)
- fix a non safe use of TAILQ_FOREACH with TAILQ_REMOVE
  (relay_http.c,v 1.47)
- Plug a memory leak by simplifying kv_free() (relayd.c,v 1.141)
- Fix memory leak in error case (relay_http.c,v 1.48)
- track the connection state of a session and stops doing double
  opens in certain situations (relay.c,v 1.195; relay_http.c,v 1.49; relayd.h,v 1.210)
- coding style (relay.c,v 1.196; relay_http.c,v 1.50; relayd.h,v 1.212)

ok claudio@@, sthen@@ and feedback tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.c,v 1.138 2015/01/22 17:42:09 reyk Exp $	*/
d549 1
a549 1
purge_table(struct relayd *env, struct tablelist *head, struct table *table)
a554 1
		TAILQ_REMOVE(&env->sc_hosts, host, globalentry);
d769 12
a780 7
	/*
	 * This function does not clear memory referenced by
	 * kv_children or stuff on the tailqs. Use kv_delete() instead.
	 */

	free(kv->kv_key);
	free(kv->kv_value);
@


1.137
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.c,v 1.136 2015/01/16 15:06:40 deraadt Exp $	*/
a25 1
#include <net/if.h>
@


1.136
log
@Adapt to <limits.h> universe.
ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.c,v 1.135 2014/12/18 20:55:01 reyk Exp $	*/
d971 1
a971 1
			return(NULL);
d1012 1
a1012 1
	char		 	 pname[TABLE_NAME_SIZE];
@


1.135
log
@Update relayd to use siphash instead of sys/hash.  The source-hash,
loadbalance and hash modes use a random key by default that can be
forced to be a static key with a new configuration argument.

With input from Max Fillinger.

ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.c,v 1.134 2014/12/12 10:05:09 reyk Exp $	*/
d30 1
d50 2
d1489 1
a1489 1
		rl.rlim_cur = MAX(rl.rlim_max, (rlim_t)maxfd);
@


1.134
log
@Change the keyword "ssl" to "tls" to reflect reality since we
effectively disabled support for the SSL protocols.  SSL remains a
common term describing SSL/TLS, there is some controvery about this
change, and the name really doesn't matter, but I feel confident about
it now.

(btw., sthen@@ pointed out some historical context:
http://tim.dierks.org/2014/05/security-standards-and-name-changes-in.html)

OK benno@@, with input from tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.c,v 1.133 2014/11/22 00:24:22 tedu Exp $	*/
a24 1
#include <sys/hash.h>
@


1.133
log
@use size_t where appropriate. ok deraadt reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.c,v 1.132 2014/11/19 10:24:40 blambert Exp $	*/
d269 1
a269 1
	if (env->sc_flags & (F_SSL|F_SSLCLIENT))
d308 6
a313 6
		/* Check for SSL Inspection */
		if ((rlay->rl_conf.flags & (F_SSL|F_SSLCLIENT)) ==
		    (F_SSL|F_SSLCLIENT) &&
		    rlay->rl_conf.ssl_cacert_len &&
		    rlay->rl_conf.ssl_cakey_len)
			rlay->rl_conf.flags |= F_SSLINSPECT;
d566 1
a566 1
	if (table->conf.flags & F_SSL)
d611 20
a630 20
	purge_key(&rlay->rl_ssl_cert, rlay->rl_conf.ssl_cert_len);
	purge_key(&rlay->rl_ssl_key, rlay->rl_conf.ssl_key_len);
	purge_key(&rlay->rl_ssl_ca, rlay->rl_conf.ssl_ca_len);
	purge_key(&rlay->rl_ssl_cakey, rlay->rl_conf.ssl_cakey_len);

	if (rlay->rl_ssl_x509 != NULL) {
		X509_free(rlay->rl_ssl_x509);
		rlay->rl_ssl_x509 = NULL;
	}
	if (rlay->rl_ssl_pkey != NULL) {
		EVP_PKEY_free(rlay->rl_ssl_pkey);
		rlay->rl_ssl_pkey = NULL;
	}
	if (rlay->rl_ssl_cacertx509 != NULL) {
		X509_free(rlay->rl_ssl_cacertx509);
		rlay->rl_ssl_cacertx509 = NULL;
	}
	if (rlay->rl_ssl_capkey != NULL) {
		EVP_PKEY_free(rlay->rl_ssl_capkey);
		rlay->rl_ssl_capkey = NULL;
@


1.132
log
@Support exporting relayd statistics via AgentX/snmpd

This should be equivalent to the statistics available
via the various relaydctl show commands

okay benno@@ reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.c,v 1.131 2014/08/18 12:59:00 reyk Exp $	*/
d1343 1
a1343 1
	u_int			 i, j;
@


1.131
log
@Sync proc.c with httpd.  httpd needs SIGUSR1 but relayd will ignore it
now instead of terminating the process.

ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.c,v 1.130 2014/07/13 00:32:08 benno Exp $	*/
d203 2
d458 3
a481 3
		break;
	case IMSG_SNMPSOCK:
		(void)snmp_setsock(env, p->p_id);
@


1.130
log
@improve log output for relays. adjust regress tests
ok reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.c,v 1.129 2014/07/11 11:48:50 reyk Exp $	*/
d133 1
d245 1
d252 1
@


1.129
log
@Simplify the code that handles the HTTP headers by using an RB tree
with associated lists instead of the complicated lookup table and
"others" list.  This might add a little malloc overhead for common
headers but also fixes some issues like the handling of repeated
headers -  for example, handling of multiple "Set-Cookie" headers.

ok bluhm@@ (regress part)
ok benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.c,v 1.128 2014/07/10 00:05:59 reyk Exp $	*/
d807 2
a808 1
kv_log(struct evbuffer *log, struct kv *kv, u_int16_t labelid)
d812 1
a812 1
	if (log == NULL)
d814 2
a815 1
	if (asprintf(&msg, " [%s%s%s%s%s]",
d820 2
a821 1
	    kv->kv_value == NULL ? "" : kv->kv_value) == -1)
d823 1
a823 1
	if (evbuffer_add(log, msg, strlen(msg)) == -1) {
d828 1
a828 1

@


1.128
log
@Fix another free error.

ok benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.c,v 1.127 2014/07/09 22:10:15 reyk Exp $	*/
d36 1
d641 1
a641 1
kv_add(struct kvlist *keys, char *key, char *value)
d643 1
a643 1
	struct kv	*kv;
d659 1
d661 4
a664 1
	TAILQ_INSERT_TAIL(keys, kv, kv_entry);
d672 3
a674 2
	va_list  ap;
	char	*value = NULL;
d681 8
d715 1
a715 1
kv_delete(struct kvlist *keys, struct kv *kv)
d717 11
a727 1
	TAILQ_REMOVE(keys, kv, kv_entry);
d733 1
a733 1
kv_extend(struct kvlist *keys, char *value)
a734 1
	struct kv	*kv;
d737 1
a737 1
	if ((kv = TAILQ_LAST(keys, kvlist)) == NULL)
d739 1
a739 2

	if (kv->kv_value != NULL) {
d752 1
a752 1
kv_purge(struct kvlist *keys)
d756 1
a756 1
	while ((kv = TAILQ_FIRST(keys)))
d773 1
a773 2
	kv->kv_matchlist = NULL;
	kv->kv_matchptr = NULL;
d783 1
d800 2
a801 4
	if (src->kv_matchptr != NULL)
		dst->kv_matchptr = src->kv_matchptr;
	if (src->kv_matchlist != NULL)
		dst->kv_matchlist = src->kv_matchlist;
d829 29
a872 3
		if (kv->kv_value != NULL && strchr(kv->kv_value, '$') != NULL)
			kv->kv_flags |= KV_FLAG_MACRO;

d894 5
@


1.127
log
@Don't assign garbage in kv_extend().
Found by clang.
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.c,v 1.126 2014/07/09 16:42:05 reyk Exp $	*/
d741 2
@


1.126
log
@Replace the protocol directives for HTTP with a new generic filtering
language.  The grammar is inspired by pf and allows to write versatile
last-matching filter rules in protocol sections starting with the
"pass", "block" or "match" keywords.  This work was started almost two
years ago and replaces large parts of relayd(8)'s HTTP and filtering
code.  The initial version reimplements and extends HTTP filtering,
but will be improved to support generic TCP and other protocols later.

With some testing, feedback, and help from benno@@ and andre@@.

OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.c,v 1.125 2014/06/27 07:49:08 andre Exp $	*/
d717 2
a718 2
	if (kv->kv_value == NULL) {
		if ((kv->kv_value = strdup(value)) == NULL)
d720 4
a723 1
	} else if (asprintf(&newvalue, "%s%s", kv->kv_value, value) == -1)
a724 3

	free(kv->kv_value);
	kv->kv_value = newvalue;
@


1.125
log
@knf, no functional change.
ok reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.c,v 1.124 2014/05/08 15:28:57 blambert Exp $	*/
d299 2
a541 27
purge_tree(struct proto_tree *tree)
{
	struct protonode	*proot, *pn;

	while ((proot = RB_ROOT(tree)) != NULL) {
		RB_REMOVE(proto_tree, tree, proot);
		if (proot->key != NULL)
			free(proot->key);
		if (proot->value != NULL)
			free(proot->value);
		while ((pn = SIMPLEQ_FIRST(&proot->head)) != NULL) {
			SIMPLEQ_REMOVE_HEAD(&proot->head, entry);
			if (pn->key != NULL)
				free(pn->key);
			if (pn->value != NULL)
				free(pn->value);
			if (pn->labelname != NULL)
				free(pn->labelname);
			if (pn->label != 0)
				pn_unref(pn->label);
			free(pn);
		}
		free(proot);
	}
}

void
d638 329
d1164 1
a1164 1
	
a1329 162
struct protonode *
protonode_header(enum direction dir, struct protocol *proto,
    struct protonode *pk)
{
	struct protonode	*pn;
	struct proto_tree	*tree;

	if (dir == RELAY_DIR_RESPONSE)
		tree = &proto->response_tree;
	else
		tree = &proto->request_tree;

	pn = RB_FIND(proto_tree, tree, pk);
	if (pn != NULL)
		return (pn);
	if ((pn = calloc(1, sizeof(*pn))) == NULL) {
		log_warn("%s: calloc", __func__);
		return (NULL);
	}
	pn->key = strdup(pk->key);
	if (pn->key == NULL) {
		free(pn);
		log_warn("%s: strdup", __func__);
		return (NULL);
	}
	pn->value = NULL;
	pn->action = NODE_ACTION_NONE;
	pn->type = pk->type;
	SIMPLEQ_INIT(&pn->head);
	if (dir == RELAY_DIR_RESPONSE)
		pn->id =
		    proto->response_nodes++;
	else
		pn->id = proto->request_nodes++;
	if (pn->id == INT_MAX) {
		log_warnx("%s: too many protocol "
		    "nodes defined", __func__);
		return (NULL);
	}
	RB_INSERT(proto_tree, tree, pn);
	return (pn);
}

int
protonode_add(enum direction dir, struct protocol *proto,
    struct protonode *node)
{
	struct protonode	*pn, *proot, pk;
	struct proto_tree	*tree;

	if (dir == RELAY_DIR_RESPONSE)
		tree = &proto->response_tree;
	else
		tree = &proto->request_tree;

	if ((pn = calloc(1, sizeof (*pn))) == NULL) {
		log_warn("%s: calloc", __func__);
		return (-1);
	}
	bcopy(node, pn, sizeof(*pn));
	pn->key = node->key;
	pn->value = node->value;
	pn->labelname = NULL;
	if (node->labelname != NULL)
		pn->label = pn_name2id(node->labelname);
	SIMPLEQ_INIT(&pn->head);
	if (dir == RELAY_DIR_RESPONSE)
		pn->id = proto->response_nodes++;
	else
		pn->id = proto->request_nodes++;
	if (pn->id == INT_MAX) {
		log_warnx("%s: too many protocol nodes defined", __func__);
		free(pn);
		return (-1);
	}
	if ((proot =
	    RB_INSERT(proto_tree, tree, pn)) != NULL) {
		/*
		 * A protocol node with the same key already
		 * exists, append it to a queue behind the
		 * existing node->
		 */
		if (SIMPLEQ_EMPTY(&proot->head))
			SIMPLEQ_NEXT(proot, entry) = pn;
		SIMPLEQ_INSERT_TAIL(&proot->head, pn, entry);
	}
	if (node->type == NODE_TYPE_COOKIE)
		pk.key = "Cookie";
	else if (node->type == NODE_TYPE_URL)
		pk.key = "Host";
	else
		pk.key = "GET";
	if (node->type != NODE_TYPE_HEADER) {
		pk.type = NODE_TYPE_HEADER;
		pn = protonode_header(dir, proto, &pk);
		if (pn == NULL)
			return (-1);
		switch (node->type) {
		case NODE_TYPE_QUERY:
			pn->flags |= PNFLAG_LOOKUP_QUERY;
			break;
		case NODE_TYPE_COOKIE:
			pn->flags |= PNFLAG_LOOKUP_COOKIE;
			break;
		case NODE_TYPE_URL:
			if (node->flags &
			    PNFLAG_LOOKUP_URL_DIGEST)
				pn->flags |= node->flags &
				    PNFLAG_LOOKUP_URL_DIGEST;
			else
				pn->flags |=
				    PNFLAG_LOOKUP_DIGEST(0);
			break;
		default:
			break;
		}
	}

	return (0);
}

int
protonode_load(enum direction dir, struct protocol *proto,
    struct protonode *node, const char *name)
{
	FILE			*fp;
	char			 buf[BUFSIZ];
	int			 ret = -1;
	struct protonode	 pn;

	bcopy(node, &pn, sizeof(pn));
	pn.key = pn.value = NULL;

	if ((fp = fopen(name, "r")) == NULL)
		return (-1);

	while (fgets(buf, sizeof(buf), fp) != NULL) {
		/* strip whitespace and newline characters */
		buf[strcspn(buf, "\r\n\t ")] = '\0';
		if (!strlen(buf) || buf[0] == '#')
			continue;
		pn.key = strdup(buf);
		if (node->value != NULL)
			pn.value = strdup(node->value);
		if (pn.key == NULL ||
		    (node->value != NULL && pn.value == NULL))
			goto fail;
		if (protonode_add(dir, proto, &pn) == -1)
			goto fail;
		pn.key = pn.value = NULL;
	}

	ret = 0;
 fail:
	if (pn.key != NULL)
		free(pn.key);
	if (pn.value != NULL)
		free(pn.value);
	fclose(fp);
	return (ret);
}

d1458 96
@


1.124
log
@remove debug prints that snuck in; found by reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.c,v 1.123 2014/05/08 13:08:48 blambert Exp $	*/
d1326 1
a1326 1
		return -1;
d1331 1
a1331 2
		DPRINTF("%s: inflight incremented, now %d",__func__,
		    *counter);
d1333 1
a1333 1
	return ret;
@


1.123
log
@match relayd proc.c infrastructure with snmpd

okay reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.c,v 1.122 2014/04/22 08:04:23 reyk Exp $	*/
a197 1
log_warnx("batman");
a198 1
log_warnx("robin");
@


1.122
log
@Support the CA key for SSL inspection in the ca process.  Instead of
looking up the keys by relay id, add all keys to a list and look them
up by key id.

ok benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.c,v 1.121 2014/04/20 14:48:29 reyk Exp $	*/
d198 3
@


1.121
log
@Reimplement the multi-dimensional arrays that are used to set up the
process to process imsg communication.  It became a maze after we
added support for multiple relay processes and even worse with the ca
processes.  This change makes it easier to understand.  Now it only
opens socketpairs that are needed - the code previously wasted lots of
fds.

ok blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.c,v 1.120 2014/04/18 13:55:26 reyk Exp $	*/
d642 8
d842 30
@


1.120
log
@Introduce privsep for private keys:

- Move RSA private keys to a new separate process instead of copying
them to the relays.  A custom RSA engine is used by the SSL/TLS code
of the relay processes to send RSA private key encryption/decryption
(also used for sign/verify) requests to the new "ca" processes instead
of operating on the private key directly.

- Each relay process gets its own related ca process.  Setting
"prefork 5" in the config file will spawn 10 processes (5 relay, 5
ca).  This diff also reduces the default number of relay processes
from 5 to 3 which should be suitable in most installations without a
very heavy load.

- Don't keep text versions of the keys in memory, parse them once and
keep the binary representation.  This might still be the case in
OpenSSL's internals but will be fixed in the library.

This diff doesn't prevent something like "heartbleed" but adds an
additional mitigation to prevent leakage of the private keys from the
processes doing SSL/TLS.

With feedback from many
ok benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.c,v 1.119 2014/03/16 18:38:30 guenther Exp $	*/
d229 2
d249 1
a249 1
	proc_config(ps, procs, nitems(procs));
@


1.119
log
@lint is dead (long live the lint!), so stop using it as a cpp conditional
(namespace pollution!) or talking about its opinion on code.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.c,v 1.118 2013/11/26 13:27:20 deraadt Exp $	*/
d4 1
a4 1
 * Copyright (c) 2007, 2008 Reyk Floeter <reyk@@openbsd.org>
d60 2
d69 2
a70 1
	{ "relay",	PROC_RELAY, parent_dispatch_relay, relay }
d228 1
d307 2
a308 2
	/* HCE, PFE and the preforked relays need to reload their config. */
	env->sc_reload = 2 + env->sc_prefork_relay;
d333 1
a333 1
	config_purge(env, CONFIG_ALL);
d520 16
d591 14
d627 14
a642 6
	if (rlay->rl_ssl_cert != NULL)
		free(rlay->rl_ssl_cert);
	if (rlay->rl_ssl_key != NULL)
		free(rlay->rl_ssl_key);
	if (rlay->rl_ssl_ca != NULL)
		free(rlay->rl_ssl_ca);
@


1.118
log
@don't intentionally cast the argument to isprint() to the wrong type...
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.c,v 1.117 2013/05/30 20:17:12 reyk Exp $	*/
a135 1
/* __dead is for lint */
@


1.117
log
@Support SSL inspection, the ability to transparently filter in SSL/TLS
connections (eg. HTTPS) by using a local CA that is accepted by the
clients.  See the "SSL RELAYS" and "EXAMPLES" sections in the
relayd.conf(5) manpage for more details.

ok benno@@, manpage bits jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.c,v 1.116 2013/03/10 23:32:53 reyk Exp $	*/
d1214 1
a1214 1
		if (!(isprint((char)ptr[i]) || isspace((char)ptr[i])))
@


1.116
log
@This diff changes relayd to use the monotonic clock instead of
gettimeofday().  It was also bugging me for some time to have all
these checks of gettimeofday()'s return value: it should not fail.  So
this diff introduces a void getmonotime(struct timeval *tv) that calls
clock_gettime(CLOCK_MONOTONIC, &ts) and converts the output to a
struct timeval that can be used with the existing code and the
timeval-specific timer functions (timerclear, timersub, ...).  It does
not return a status but calls fatal() on error-that-should-not-happen.

ok sthen@@ chris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.c,v 1.115 2013/01/17 20:34:18 bluhm Exp $	*/
d293 8
a300 1
	TAILQ_FOREACH(rlay, env->sc_relays, rl_entry)
d302 1
@


1.115
log
@Remove unnecessary pointer casts.  No binary diff.
OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.c,v 1.114 2012/12/18 15:41:44 reyk Exp $	*/
d792 1
a792 3
	if (gettimeofday(&tv_now, NULL) == -1)
		fatal("event_again: gettimeofday");

@


1.114
log
@no nead to touch argv later since we don't support non-getopt arguments.
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.c,v 1.113 2012/12/18 15:39:42 reyk Exp $	*/
d953 1
a953 1
	if ((pn = (struct protonode *)calloc(1, sizeof(*pn))) == NULL) {
@


1.113
log
@doin't complain if the child processes exited cleanly.
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.c,v 1.112 2012/11/27 05:00:28 guenther Exp $	*/
a185 1
	argv += optind;
@


1.112
log
@Add format attributes to the proper functions and then fix the warnings
that gcc then reports when compiling with -DDEBUG=2

ok reyk@@ benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.c,v 1.111 2012/10/03 08:46:05 reyk Exp $	*/
d107 3
a109 2
					log_warnx("lost child: %s %s",
					    ps->ps_title[id], cause);
@


1.111
log
@Only show "inflight" debugging message if compiled with DEBUG > 1.
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.c,v 1.110 2012/10/03 08:33:31 reyk Exp $	*/
d1187 1
a1187 1
	log_debug("%s: max open files %d", __func__, rl.rlim_max);
@


1.110
log
@Support more than one relay backup table.  Instead of duplicating the
code for main and backup table all over the place, turn the relay
tables into a list attached to the relay.  This improves the code and
allows some other tricks with multiple tables later.
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.c,v 1.109 2012/09/21 09:56:27 benno Exp $	*/
d1243 1
a1243 1
		log_debug("%s: inflight incremented, now %d",__func__,
@


1.109
log
@file descriptor accounting for relays: track how many connections to
backend servers are unopened and reserve fds for them.
ok reyk@@, "don't wait" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.c,v 1.108 2012/05/08 15:10:15 benno Exp $	*/
d567 1
d594 5
@


1.108
log
@fix "label string" in http protocol. problem found by giovanni.
ok giovanni@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.c,v 1.107 2012/04/15 03:12:30 jsg Exp $	*/
d1222 19
@


1.107
log
@fix some leaks
ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.c,v 1.106 2012/01/21 13:40:48 camield Exp $	*/
d526 2
d994 3
@


1.106
log
@Only start the child processes after all of them reported to have loaded
the config.  Solves a race at startup time where processes can send status
messages about hosts that other processes don't know about yet.
(and have relayd abort with "desynchronized" or "invalid host id")

ok henning pyr deraadt
solves the problem ok from benno todd
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.c,v 1.105 2012/01/20 12:16:41 camield Exp $	*/
d816 1
d824 1
@


1.105
log
@Remove global carp demote option.  It is currently broken, but also flawed
by design.

ok henning pyr
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.c,v 1.104 2011/09/04 20:26:58 bluhm Exp $	*/
d52 1
d296 3
a314 1
		env->sc_reload++;
d360 22
d434 1
a434 2
		if (env->sc_reload)
			env->sc_reload--;
d462 1
a462 2
		if (env->sc_reload)
			env->sc_reload--;
d500 1
a500 2
		if (env->sc_reload)
			env->sc_reload--;
@


1.104
log
@KNF, fix white spaces in relayd.  No binary change.
ok pyr@@ sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.c,v 1.103 2011/05/19 08:56:49 reyk Exp $	*/
a363 2
	if (env->sc_flags & F_DEMOTE)
		carp_demote_reset(env->sc_demote_group, 128);
@


1.103
log
@Fix reload support in relayd(8) by reimplementing large parts of the
daemon infrastructure. The previous design made it fairly hard to
reload the complex data structures, especially relays and protocols.
One of the reasons was that the privsep'd relayd processes had two
ways of getting their configuration: 1) from memory after forking from
the parent process and 2) and (partially) via imsgs after reload.  The
new implementation first forks the privsep'd children before the
parents loads the configuration and sends it via imsgs to them; so it
is only like 2) before.  It is based on an approach that I first
implemented for iked(8) and I also fixed many bugs in the code.

Thanks to many testers including dlg@@ sthen@@ phessler@@
ok pyr@@ dlg@@ sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.c,v 1.102 2011/05/09 12:08:47 reyk Exp $	*/
d57 2
a58 1
int		 parent_dispatch_relay(int, struct privsep_proc *, struct imsg *);
d381 1
a381 1
	u_int		 	 v;
@


1.102
log
@Reorganize the relayd code to use the proc.c privsep API/commodity
functions that are based on work for iked and smtpd.  This simplifies
the setup of privsep processes and moves some redundant and repeated
code to a single place - which is always good from a quality and
security point of view.  The relayd version of proc.c is different to
the current version in iked because it uses 1:N communications between
processes, eg. a single parent process is talking to many forked relay
children while iked only needs 1:1 communications.

ok sthen@@ pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.c,v 1.101 2011/05/05 12:01:44 reyk Exp $	*/
d25 1
d34 1
d51 2
a57 2
void		 reconfigure(void);
void		 purge_tree(struct proto_tree *);
d60 1
a60 1
struct relayd	*relayd_env;
d117 7
a123 1
		reconfigure();
d148 2
a149 2
	int			 debug;
	u_int32_t		 opts;
d152 1
a152 5
	const char		*conffile;

	opts = 0;
	debug = 0;
	conffile = CONF_FILE;
d172 1
d187 1
a187 1
	if ((env = parse_config(conffile, opts)) == NULL ||
d194 5
a199 4
	if (env->sc_opts & RELAYD_OPT_NOACTION) {
		fprintf(stderr, "configuration OK\n");
		exit(0);
	}
d212 5
a216 5
	if (!debug) {
		log_init(debug);
		if (daemon(1, 0) == -1)
			err(1, "failed to daemonize");
	}
d218 4
a221 1
	log_info("startup");
d243 18
d267 1
d271 2
a272 2
void
parent_shutdown(struct relayd *env)
d274 8
a281 5
	proc_kill(env->sc_ps);
	control_cleanup(&env->sc_ps->ps_csock);
	carp_demote_shutdown();
	if (env->sc_flags & F_DEMOTE)
		carp_demote_reset(env->sc_demote_group, 128);
d283 10
a292 2
	free(env->sc_ps);
	free(env);
d294 5
a298 1
	log_info("parent terminating, pid %d", getpid());
d300 9
a308 49
	exit(0);
}

void
merge_config(struct relayd *env, struct relayd *new_env)
{
	env->sc_opts = new_env->sc_opts;
	env->sc_flags = new_env->sc_flags;
	env->sc_confpath = new_env->sc_confpath;
	env->sc_tablecount = new_env->sc_tablecount;
	env->sc_rdrcount = new_env->sc_rdrcount;
	env->sc_protocount = new_env->sc_protocount;
	env->sc_relaycount = new_env->sc_relaycount;

	memcpy(&env->sc_interval, &new_env->sc_interval,
	    sizeof(env->sc_interval));
	memcpy(&env->sc_timeout, &new_env->sc_timeout,
	    sizeof(env->sc_timeout));
	memcpy(&env->sc_empty_table, &new_env->sc_empty_table,
	    sizeof(env->sc_empty_table));
	memcpy(&env->sc_proto_default, &new_env->sc_proto_default,
	    sizeof(env->sc_proto_default));
	env->sc_prefork_relay = new_env->sc_prefork_relay;
	(void)strlcpy(env->sc_demote_group, new_env->sc_demote_group,
	    sizeof(env->sc_demote_group));

	env->sc_tables = new_env->sc_tables;
	env->sc_rdrs = new_env->sc_rdrs;
	env->sc_relays = new_env->sc_relays;
	env->sc_protos = new_env->sc_protos;
}


void
reconfigure(void)
{
	struct relayd		*env = relayd_env;
	struct relayd		*new_env = NULL;
	struct privsep		*ps = env->sc_ps;
	struct rdr		*rdr;
	struct address		*virt;
	struct table            *table;
	struct host             *host;

	log_info("reloading configuration");
	if ((new_env = parse_config(env->sc_confpath, env->sc_opts)) == NULL) {
		log_warnx("configuration reloading FAILED");
		return;
	}
d310 3
a312 7
	if (!(env->sc_flags & F_NEEDPF) && (new_env->sc_flags & F_NEEDPF)) {
		log_warnx("new configuration requires pf while it "
		    "was previously disabled."
		    "configuration will not be reloaded");
		purge_config(new_env, PURGE_EVERYTHING);
		free(new_env);
		return;
d315 1
a315 4
	purge_config(env, PURGE_EVERYTHING);
	merge_config(env, new_env);
	free(new_env);
	log_info("configuration merge done");
d317 3
a319 37
	/*
	 * first reconfigure pfe
	 */
	proc_compose_imsg(ps, PROC_PFE, -1, IMSG_RECONF, -1, env, sizeof(*env));
	TAILQ_FOREACH(table, env->sc_tables, entry) {
		proc_compose_imsg(ps, PROC_PFE, -1, IMSG_RECONF_TABLE, -1,
		    &table->conf, sizeof(table->conf));
		TAILQ_FOREACH(host, &table->hosts, entry) {
			proc_compose_imsg(ps, PROC_PFE, -1, IMSG_RECONF_HOST,
			    -1, &host->conf, sizeof(host->conf));
		}
	}
	TAILQ_FOREACH(rdr, env->sc_rdrs, entry) {
		proc_compose_imsg(ps, PROC_PFE, -1, IMSG_RECONF_RDR, -1,
		    &rdr->conf, sizeof(rdr->conf));
		TAILQ_FOREACH(virt, &rdr->virts, entry)
			proc_compose_imsg(ps, PROC_PFE, -1, IMSG_RECONF_VIRT,
			    -1, virt, sizeof(*virt));
	}
	proc_compose_imsg(ps, PROC_PFE, -1, IMSG_RECONF_END, -1, NULL, 0);

	/*
	 * then reconfigure hce
	 */
	proc_compose_imsg(ps, PROC_HCE, -1, IMSG_RECONF, -1, env, sizeof(*env));
	TAILQ_FOREACH(table, env->sc_tables, entry) {
		proc_compose_imsg(ps, PROC_HCE, -1, IMSG_RECONF_TABLE, -1,
		    &table->conf, sizeof(table->conf));
		if (table->sendbuf != NULL)
			proc_compose_imsg(ps, PROC_HCE, -1, IMSG_RECONF_SENDBUF,
			    -1, table->sendbuf, strlen(table->sendbuf) + 1);
		TAILQ_FOREACH(host, &table->hosts, entry) {
			proc_compose_imsg(ps, PROC_HCE, -1, IMSG_RECONF_HOST,
			    -1, &host->conf, sizeof(host->conf));
		}
	}
	proc_compose_imsg(ps, PROC_HCE, -1, IMSG_RECONF_END, -1, NULL, 0);
d323 1
a323 1
purge_config(struct relayd *env, u_int8_t what)
d325 4
a328 12
	struct table		*table;
	struct rdr		*rdr;
	struct address		*virt;
	struct protocol		*proto;
	struct relay		*rlay;
	struct rsession		*sess;

	if (what & PURGE_TABLES && env->sc_tables != NULL) {
		while ((table = TAILQ_FIRST(env->sc_tables)) != NULL)
			purge_table(env->sc_tables, table);
		free(env->sc_tables);
		env->sc_tables = NULL;
d331 12
a342 8
	if (what & PURGE_RDRS && env->sc_rdrs != NULL) {
		while ((rdr = TAILQ_FIRST(env->sc_rdrs)) != NULL) {
			TAILQ_REMOVE(env->sc_rdrs, rdr, entry);
			while ((virt = TAILQ_FIRST(&rdr->virts)) != NULL) {
				TAILQ_REMOVE(&rdr->virts, virt, entry);
				free(virt);
			}
			free(rdr);
a343 3
		free(env->sc_rdrs);
		env->sc_rdrs = NULL;
	}
d345 1
a345 20
	if (what & PURGE_RELAYS && env->sc_relays != NULL) {
		while ((rlay = TAILQ_FIRST(env->sc_relays)) != NULL) {
			TAILQ_REMOVE(env->sc_relays, rlay, rl_entry);
			while ((sess =
			    SPLAY_ROOT(&rlay->rl_sessions)) != NULL) {
				SPLAY_REMOVE(session_tree,
				    &rlay->rl_sessions, sess);
				free(sess);
			}
			if (rlay->rl_bev != NULL)
				bufferevent_free(rlay->rl_bev);
			if (rlay->rl_dstbev != NULL)
				bufferevent_free(rlay->rl_dstbev);
			if (rlay->rl_ssl_ctx != NULL)
				SSL_CTX_free(rlay->rl_ssl_ctx);
			free(rlay);
		}
		free(env->sc_relays);
		env->sc_relays = NULL;
	}
d347 3
a349 8
	if (what & PURGE_PROTOS && env->sc_protos != NULL) {
		while ((proto = TAILQ_FIRST(env->sc_protos)) != NULL) {
			TAILQ_REMOVE(env->sc_protos, proto, entry);
			purge_tree(&proto->request_tree);
			purge_tree(&proto->response_tree);
			if (proto->style != NULL)
				free(proto->style);
			free(proto);
d351 2
a352 3
		free(env->sc_protos);
		env->sc_protos = NULL;
	}
d356 1
a356 1
purge_tree(struct proto_tree *tree)
d358 1
a358 1
	struct protonode	*proot, *pn;
d360 5
a364 19
	while ((proot = RB_ROOT(tree)) != NULL) {
		RB_REMOVE(proto_tree, tree, proot);
		if (proot->key != NULL)
			free(proot->key);
		if (proot->value != NULL)
			free(proot->value);
		while ((pn = SIMPLEQ_FIRST(&proot->head)) != NULL) {
			SIMPLEQ_REMOVE_HEAD(&proot->head, entry);
			if (pn->key != NULL)
				free(pn->key);
			if (pn->value != NULL)
				free(pn->value);
			if (pn->label != 0)
				pn_unref(pn->label);
			free(pn);
		}
		free(proot);
	}
}
d366 2
a367 4
void
purge_table(struct tablelist *head, struct table *table)
{
	struct host		*host;
d369 1
a369 10
	while ((host = TAILQ_FIRST(&table->hosts)) != NULL) {
		TAILQ_REMOVE(&table->hosts, host, entry);
		if (host->cte.ssl != NULL)
			SSL_free(host->cte.ssl);
		free(host);
	}
	if (table->sendbuf != NULL)
		free(table->sendbuf);
	if (table->conf.flags & F_SSL)
		SSL_CTX_free(table->ssl_ctx);
d371 1
a371 3
	if (head != NULL)
		TAILQ_REMOVE(head, table, entry);
	free(table);
d380 2
d394 5
d400 12
a411 4
		/*
		 * so far we only get here if no L7 (relay) is done.
		 */
		reconfigure();
d436 5
a440 1
		(void)snmp_sendsock(env, p->p_id);
d477 4
d488 90
d624 11
d659 11
a989 1

d1165 29
@


1.101
log
@Update all logging and debug functions to use the __func__ macro
instead of static function names.  __func__ is C99 and perfectly fine
to use. It also avoids printing errors; for example if a statement
log_debug("foo:"..) was moved or copied from function foo() to bar()
and the log message was not updated...
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.c,v 1.100 2011/02/13 13:28:38 okan Exp $	*/
a36 1
#include <signal.h>
d49 5
a53 8
void		 main_sig_handler(int, short, void *);
void		 main_shutdown(struct relayd *);
void		 main_dispatch_pfe(int, short, void *);
void		 main_dispatch_hce(int, short, void *);
void		 main_dispatch_relay(int, short, void *);
int		 check_child(pid_t, const char *);
int		 send_all(struct relayd *, enum imsg_type,
		    void *, u_int16_t);
a57 6
int		 pipe_parent2pfe[2];
int		 pipe_parent2hce[2];
int		 pipe_pfe2hce[2];
int		 pipe_parent2relay[RELAY_MAXPROC][2];
int		 pipe_pfe2relay[RELAY_MAXPROC][2];

d60 5
a64 7
struct imsgev	*iev_pfe;
struct imsgev	*iev_hce;
struct imsgev	*iev_relay;

pid_t		 pfe_pid = 0;
pid_t		 hce_pid = 0;
pid_t		 relay_pid = 0;
d67 6
a72 4
main_sig_handler(int sig, short event, void *arg)
{
	struct relayd		*env = arg;
	int			 die = 0;
d80 31
a110 12
		if (check_child(pfe_pid, "pf update engine")) {
			pfe_pid = 0;
			die  = 1;
		}
		if (check_child(hce_pid, "host check engine")) {
			hce_pid = 0;
			die  = 1;
		}
		if (check_child(relay_pid, "socket relay engine")) {
			relay_pid = 0;
			die  = 1;
		}
d112 1
a112 1
			main_shutdown(env);
d143 1
a144 1
	struct imsgev		*iev;
d182 2
a183 1
	if ((env = parse_config(conffile, opts)) == NULL)
d185 1
d187 2
d200 1
a200 1
	if (getpwnam(RELAYD_USER) == NULL)
d203 3
d214 2
a215 36
	if (socketpair(AF_UNIX, SOCK_STREAM, PF_UNSPEC,
	    pipe_parent2pfe) == -1)
		fatal("socketpair");
	if (socketpair(AF_UNIX, SOCK_STREAM, PF_UNSPEC,
	    pipe_parent2hce) == -1)
		fatal("socketpair");
	if (socketpair(AF_UNIX, SOCK_STREAM, PF_UNSPEC,
	    pipe_pfe2hce) == -1)
		fatal("socketpair");
	for (c = 0; c < env->sc_prefork_relay; c++) {
		if (socketpair(AF_UNIX, SOCK_STREAM, PF_UNSPEC,
		    pipe_parent2relay[c]) == -1)
			fatal("socketpair");
		if (socketpair(AF_UNIX, SOCK_STREAM, PF_UNSPEC,
		    pipe_pfe2relay[c]) == -1)
			fatal("socketpair");
		session_socket_blockmode(pipe_pfe2relay[c][0], BM_NONBLOCK);
		session_socket_blockmode(pipe_pfe2relay[c][1], BM_NONBLOCK);
		session_socket_blockmode(pipe_parent2relay[c][0], BM_NONBLOCK);
		session_socket_blockmode(pipe_parent2relay[c][1], BM_NONBLOCK);
	}

	session_socket_blockmode(pipe_parent2pfe[0], BM_NONBLOCK);
	session_socket_blockmode(pipe_parent2pfe[1], BM_NONBLOCK);
	session_socket_blockmode(pipe_parent2hce[0], BM_NONBLOCK);
	session_socket_blockmode(pipe_parent2hce[1], BM_NONBLOCK);
	session_socket_blockmode(pipe_pfe2hce[0], BM_NONBLOCK);
	session_socket_blockmode(pipe_pfe2hce[1], BM_NONBLOCK);

	pfe_pid = pfe(env, pipe_parent2pfe, pipe_parent2hce,
	    pipe_parent2relay, pipe_pfe2hce, pipe_pfe2relay);
	hce_pid = hce(env, pipe_parent2pfe, pipe_parent2hce,
	    pipe_parent2relay, pipe_pfe2hce, pipe_pfe2relay);
	if (env->sc_prefork_relay > 0)
		relay_pid = relay(env, pipe_parent2pfe, pipe_parent2hce,
		    pipe_parent2relay, pipe_pfe2hce, pipe_pfe2relay);
d221 11
a231 61
	signal_set(&env->sc_evsigint, SIGINT, main_sig_handler, env);
	signal_set(&env->sc_evsigterm, SIGTERM, main_sig_handler, env);
	signal_set(&env->sc_evsigchld, SIGCHLD, main_sig_handler, env);
	signal_set(&env->sc_evsighup, SIGHUP, main_sig_handler, env);
	signal_set(&env->sc_evsigpipe, SIGPIPE, main_sig_handler, env);

	signal_add(&env->sc_evsigint, NULL);
	signal_add(&env->sc_evsigterm, NULL);
	signal_add(&env->sc_evsigchld, NULL);
	signal_add(&env->sc_evsighup, NULL);
	signal_add(&env->sc_evsigpipe, NULL);

	close(pipe_parent2pfe[1]);
	close(pipe_parent2hce[1]);
	close(pipe_pfe2hce[0]);
	close(pipe_pfe2hce[1]);
	for (c = 0; c < env->sc_prefork_relay; c++) {
		close(pipe_pfe2relay[c][0]);
		close(pipe_pfe2relay[c][1]);
		close(pipe_parent2relay[c][0]);
	}

	if ((iev_pfe = calloc(1, sizeof(struct imsgev))) == NULL ||
	    (iev_hce = calloc(1, sizeof(struct imsgev))) == NULL)
		fatal(NULL);

	if (env->sc_prefork_relay > 0) {
		if ((iev_relay = calloc(env->sc_prefork_relay,
		    sizeof(struct imsgev))) == NULL)
			fatal(NULL);
	}

	imsg_init(&iev_pfe->ibuf, pipe_parent2pfe[0]);
	imsg_init(&iev_hce->ibuf, pipe_parent2hce[0]);
	iev_pfe->handler = main_dispatch_pfe;
	iev_pfe->data = env;
	iev_hce->handler = main_dispatch_hce;
	iev_hce->data = env;

	for (c = 0; c < env->sc_prefork_relay; c++) {
		iev = &iev_relay[c];
		imsg_init(&iev->ibuf, pipe_parent2relay[c][1]);
		iev->handler = main_dispatch_relay;
		iev->events = EV_READ;
		event_set(&iev->ev, iev->ibuf.fd, iev->events,
		    iev->handler, iev);
		event_add(&iev->ev, NULL);
	}

	iev_pfe->events = EV_READ;
	event_set(&iev_pfe->ev, iev_pfe->ibuf.fd, iev_pfe->events,
	    iev_pfe->handler, iev_pfe);
	event_add(&iev_pfe->ev, NULL);

	iev_hce->events = EV_READ;
	event_set(&iev_hce->ev, iev_hce->ibuf.fd, iev_hce->events,
	    iev_hce->handler, iev_hce);
	event_add(&iev_hce->ev, NULL);

	if (env->sc_flags & F_DEMOTE)
		carp_demote_reset(env->sc_demote_group, 0);
d233 1
d238 1
a238 1
	main_shutdown(env);
d244 1
a244 1
main_shutdown(struct relayd *env)
d246 2
a247 16
	pid_t	pid;

	if (pfe_pid)
		kill(pfe_pid, SIGTERM);
	if (hce_pid)
		kill(hce_pid, SIGTERM);
	if (relay_pid)
		kill(relay_pid, SIGTERM);

	do {
		if ((pid = wait(NULL)) == -1 &&
		    errno != EINTR && errno != ECHILD)
			fatal("wait");
	} while (pid != -1 || (pid == -1 && errno == EINTR));

	control_cleanup();
a250 3
	log_info("terminating");
	exit(0);
}
d252 2
a253 4
int
check_child(pid_t pid, const char *pname)
{
	int	status;
d255 1
a255 11
	if (waitpid(pid, &status, WNOHANG) > 0) {
		if (WIFEXITED(status)) {
			log_warnx("%s: lost child: %s exited", __func__, pname);
			return (1);
		}
		if (WIFSIGNALED(status)) {
			log_warnx("%s: lost child: %s terminated; "
			    "signal %d", __func__, pname, WTERMSIG(status));
			return (1);
		}
	}
d257 1
a257 18
	return (0);
}

int
send_all(struct relayd *env, enum imsg_type type, void *buf, u_int16_t len)
{
	int		 i;

	if (imsg_compose_event(iev_pfe, type, 0, 0, -1, buf, len) == -1)
		return (-1);
	if (imsg_compose_event(iev_hce, type, 0, 0, -1, buf, len) == -1)
		return (-1);
	for (i = 0; i < env->sc_prefork_relay; i++) {
		if (imsg_compose_event(&iev_relay[i], type, 0, 0, -1, buf, len)
		    == -1)
			return (-1);
	}
	return (0);
d295 1
d324 1
a324 1
	imsg_compose_event(iev_pfe, IMSG_RECONF, 0, 0, -1, env, sizeof(*env));
d326 1
a326 1
		imsg_compose_event(iev_pfe, IMSG_RECONF_TABLE, 0, 0, -1,
d329 2
a330 2
			imsg_compose_event(iev_pfe, IMSG_RECONF_HOST, 0, 0, -1,
			    &host->conf, sizeof(host->conf));
d334 1
a334 1
		imsg_compose_event(iev_pfe, IMSG_RECONF_RDR, 0, 0, -1,
d337 2
a338 2
			imsg_compose_event(iev_pfe, IMSG_RECONF_VIRT, 0, 0, -1,
				virt, sizeof(*virt));
d340 1
a340 1
	imsg_compose_event(iev_pfe, IMSG_RECONF_END, 0, 0, -1, NULL, 0);
d345 1
a345 1
	imsg_compose_event(iev_hce, IMSG_RECONF, 0, 0, -1, env, sizeof(*env));
d347 1
a347 1
		imsg_compose_event(iev_hce, IMSG_RECONF_TABLE, 0, 0, -1,
d350 2
a351 3
			imsg_compose_event(iev_hce, IMSG_RECONF_SENDBUF,
			    0, 0, -1, table->sendbuf,
			    strlen(table->sendbuf) + 1);
d353 2
a354 2
			imsg_compose_event(iev_hce, IMSG_RECONF_HOST, 0, 0, -1,
			    &host->conf, sizeof(host->conf));
d357 1
a357 1
	imsg_compose_event(iev_hce, IMSG_RECONF_END, 0, 0, -1, NULL, 0);
a470 17
void
imsg_event_add(struct imsgev *iev)
{
	if (iev->handler == NULL) {
		imsg_flush(&iev->ibuf);
		return;
	}

	iev->events = EV_READ;
	if (iev->ibuf.w.queued)
		iev->events |= EV_WRITE;

	event_del(&iev->ev);
	event_set(&iev->ev, iev->ibuf.fd, iev->events, iev->handler, iev);
	event_add(&iev->ev, NULL);
}

d472 1
a472 2
imsg_compose_event(struct imsgev *iev, u_int16_t type,
    u_int32_t peerid, pid_t pid, int fd, void *data, u_int16_t datalen)
d474 1
a474 15
	int	ret;

	if ((ret = imsg_compose(&iev->ibuf, type, peerid,
	    pid, fd, data, datalen)) != -1)
		imsg_event_add(iev);
	return (ret);
}

void
main_dispatch_pfe(int fd, short event, void *ptr)
{
	struct imsgev		*iev;
	struct imsgbuf		*ibuf;
	struct imsg		 imsg;
	ssize_t			 n;
a476 2
	struct relayd		*env;
	int			 verbose;
d478 19
a496 13
	iev = ptr;
	ibuf = &iev->ibuf;
	env = (struct relayd *)iev->data;

	if (event & EV_READ) {
		if ((n = imsg_read(ibuf)) == -1)
			fatal("imsg_read_error");
		if (n == 0) {
			/* this pipe is dead, so remove the event handler */
			event_del(&iev->ev);
			event_loopexit(NULL);
			return;
		}
d499 1
a499 46
	if (event & EV_WRITE) {
		if (msgbuf_write(&ibuf->w) == -1)
			fatal("msgbuf_write");
	}

	for (;;) {
		if ((n = imsg_get(ibuf, &imsg)) == -1)
			fatal("main_dispatch_pfe: imsg_read error");
		if (n == 0)
			break;

		switch (imsg.hdr.type) {
		case IMSG_DEMOTE:
			if (imsg.hdr.len - IMSG_HEADER_SIZE !=
			    sizeof(demote))
				fatalx("main_dispatch_pfe: "
				    "invalid size of demote request");
			memcpy(&demote, imsg.data, sizeof(demote));
			carp_demote_set(demote.group, demote.level);
			break;
		case IMSG_RTMSG:
			if (imsg.hdr.len - IMSG_HEADER_SIZE !=
			    sizeof(crt))
				fatalx("main_dispatch_pfe: "
				    "invalid size of rtmsg request");
			memcpy(&crt, imsg.data, sizeof(crt));
			pfe_route(env, &crt);
			break;
		case IMSG_CTL_RELOAD:
			/*
			 * so far we only get here if no L7 (relay) is done.
			 */
			reconfigure();
			break;
		case IMSG_CTL_LOG_VERBOSE:
			memcpy(&verbose, imsg.data, sizeof(verbose));
			log_verbose(verbose);
			break;
		default:
			log_debug("%s: unexpected imsg %d", __func__,
			    imsg.hdr.type);
			break;
		}
		imsg_free(&imsg);
	}
	imsg_event_add(iev);
d502 2
a503 2
void
main_dispatch_hce(int fd, short event, void * ptr)
d505 2
a506 4
	struct imsgev		*iev;
	struct imsgbuf		*ibuf;
	struct imsg		 imsg;
	ssize_t			 n;
a507 1
	struct relayd		*env;
d509 13
a521 13
	env = relayd_env;
	iev = ptr;
	ibuf = &iev->ibuf;

	if (event & EV_READ) {
		if ((n = imsg_read(ibuf)) == -1)
			fatal("imsg_read error");
		if (n == 0) {
			/* this pipe is dead, so remove the event handler */
			event_del(&iev->ev);
			event_loopexit(NULL);
			return;
		}
d524 1
a524 33
	if (event & EV_WRITE) {
		if (msgbuf_write(&ibuf->w) == -1)
			fatal("msgbuf_write");
	}

	for (;;) {
		if ((n = imsg_get(ibuf, &imsg)) == -1)
			fatal("main_dispatch_hce: imsg_read error");
		if (n == 0)
			break;

		switch (imsg.hdr.type) {
		case IMSG_SCRIPT:
			if (imsg.hdr.len - IMSG_HEADER_SIZE !=
			    sizeof(scr))
				fatalx("main_dispatch_hce: "
				    "invalid size of script request");
			bcopy(imsg.data, &scr, sizeof(scr));
			scr.retval = script_exec(env, &scr);
			imsg_compose_event(iev_hce, IMSG_SCRIPT,
			    0, 0, -1, &scr, sizeof(scr));
			break;
		case IMSG_SNMPSOCK:
			(void)snmp_sendsock(iev);
			break;
		default:
			log_debug("%s: unexpected imsg %d", __func__,
			    imsg.hdr.type);
			break;
		}
		imsg_free(&imsg);
	}
	imsg_event_add(iev);
d527 2
a528 2
void
main_dispatch_relay(int fd, short event, void * ptr)
d530 2
a531 5
	struct relayd		*env = relayd_env;
	struct imsgev		*iev;
	struct imsgbuf		*ibuf;
	struct imsg		 imsg;
	ssize_t			 n;
d535 10
a544 46
	iev = ptr;
	ibuf = &iev->ibuf;

	if (event & EV_READ) {
		if ((n = imsg_read(ibuf)) == -1)
			fatal("imsg_read error");
		if (n == 0) {
			/* this pipe is dead, so remove the event handler */
			event_del(&iev->ev);
			event_loopexit(NULL);
			return;
		}
	}

	if (event & EV_WRITE) {
		if (msgbuf_write(&ibuf->w) == -1)
			fatal("msgbuf_write");
	}

	for (;;) {
		if ((n = imsg_get(ibuf, &imsg)) == -1)
			fatal("main_dispatch_relay: imsg_read error");
		if (n == 0)
			break;

		switch (imsg.hdr.type) {
		case IMSG_BINDANY:
			if (imsg.hdr.len != IMSG_HEADER_SIZE + sizeof(bnd))
				fatalx("invalid imsg header len");
			bcopy(imsg.data, &bnd, sizeof(bnd));
			if (bnd.bnd_proc > env->sc_prefork_relay)
				fatalx("pfe_dispatch_relay: "
				    "invalid relay proc");
			switch (bnd.bnd_proto) {
			case IPPROTO_TCP:
			case IPPROTO_UDP:
				break;
			default:
				fatalx("pfe_dispatch_relay: requested socket "
				    "for invalid protocol");
				/* NOTREACHED */
			}
			s = bindany(&bnd);
			imsg_compose_event(&iev_relay[bnd.bnd_proc],
			    IMSG_BINDANY,
			    0, 0, s, &bnd.bnd_id, sizeof(bnd.bnd_id));
d547 10
a556 5
			log_debug("%s: unexpected imsg %d", __func__,
			    imsg.hdr.type);
			break;
		}
		imsg_free(&imsg);
d558 2
a559 1
	imsg_event_add(iev);
@


1.100
log
@fix from pr 6314: allow debug logging before daemonization to help
identify configuration issues.

ok sthen@@ pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.c,v 1.99 2010/11/30 14:38:45 reyk Exp $	*/
d343 1
a343 1
			log_warnx("check_child: lost child: %s exited", pname);
d347 2
a348 2
			log_warnx("check_child: lost child: %s terminated; "
			    "signal %d", pname, WTERMSIG(status));
d679 1
a679 1
			log_debug("main_dispatch_pfe: unexpected imsg %d",
d739 1
a739 1
			log_debug("main_dispatch_hce: unexpected imsg %d",
d807 1
a807 1
			log_debug("main_dispatch_relay: unexpected imsg %d",
d1002 1
a1002 1
		log_debug("expand_string: calloc");
d1010 1
a1010 1
			log_debug("expand_string: string too long");
d1017 1
a1017 1
		log_debug("expand_string: string too long");
d1139 1
a1139 1
		log_warn("out of memory");
d1145 1
a1145 1
		log_warn("out of memory");
d1158 2
a1159 2
		log_warnx("too many protocol "
		    "nodes defined");
d1179 1
a1179 1
		log_warn("out of memory");
d1191 1
a1191 1
		log_warnx("too many protocol nodes defined");
d1370 1
a1370 1
	log_debug("socket_rlimit: max open files %d", rl.rlim_max);
@


1.99
log
@The relayd processes did already bump up the socket file descriptor
resource limits to the maximum of the daemon class but the host check
process (hce/health checks) didn't and was limited to a fairly low
default of 128 open sockets (openfiles-cur=128 in login.conf). This
was reached fairly quickly with "check tcp" of many hosts. This diff
increases the maximum number of monitored hosts and concurrent health
checks in relayd in a significant way and may fix issues for people
that have around 100 or more hosts (or fewer hosts with multiple checked
ports).

tested by phessler@@
ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.c,v 1.98 2010/09/02 14:03:22 sobrado Exp $	*/
a140 2
	log_init(1);	/* log to stderr until daemonized */

d166 2
a189 2
	log_init(debug);

d191 1
@


1.98
log
@remove trailing spaces and tabs from source code; no binary changes
(verified by both sthen@@ and me).

ok sthen@@; "just commit it" claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.c,v 1.97 2010/05/14 11:13:36 reyk Exp $	*/
d24 1
d1362 21
@


1.97
log
@allocate all struct event's on the heap, it looks cleaner, feels better
and follows a suggestion in event.h.  also don't mix signal() and
signal_set()/signal_add().

ok jsg@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.c,v 1.96 2010/02/17 14:39:30 jsg Exp $	*/
d1094 1
a1094 1
	/* 1. remove repeated dots and convert upper case to lower case */	
@


1.96
log
@Always call the shutdown code after returning from event_dispatch().
As the child processes now call event_loopexit() and signal handling
is done through libevent if a child process died we wouldn't always
cleanup properly and wouldn't do carp demote to failover either.

This matches the way ospfd does things which is where the event_loopexit()
in child processes change came from originally.

ok claudio@@ pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.c,v 1.95 2010/02/04 13:00:20 jsg Exp $	*/
d107 3
a133 4
	struct event		 ev_sigint;
	struct event		 ev_sigterm;
	struct event		 ev_sigchld;
	struct event		 ev_sighup;
d239 11
a249 9
	signal_set(&ev_sigint, SIGINT, main_sig_handler, env);
	signal_set(&ev_sigterm, SIGTERM, main_sig_handler, env);
	signal_set(&ev_sigchld, SIGCHLD, main_sig_handler, env);
	signal_set(&ev_sighup, SIGHUP, main_sig_handler, env);
	signal_add(&ev_sigint, NULL);
	signal_add(&ev_sigterm, NULL);
	signal_add(&ev_sigchld, NULL);
	signal_add(&ev_sighup, NULL);
	signal(SIGPIPE, SIG_IGN);
@


1.95
log
@In event_again() call event_del() before calling event_set() so we
don't get into a situation where we are calling event_set() on an event
that was already added.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.c,v 1.94 2010/01/11 06:40:14 jsg Exp $	*/
d304 2
@


1.94
log
@add "log brief" and "log verbose" to change logging verbosity
like several other things in the tree.

ok reyk@@ looks fine claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.c,v 1.93 2009/11/11 13:09:39 jsg Exp $	*/
d987 1
@


1.93
log
@don't leak memory in an error case.
found by parfait.
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.c,v 1.92 2009/08/13 13:51:21 reyk Exp $	*/
d620 1
d670 4
@


1.92
log
@add new 'router' functionality to dynamically add or remove routes
based on health check results, using the existing table syntax.  this
allows to maintain multiple (uplink) gateways to implement link
balancing or WAN link failover if no routing protocol or other
keepalive method is available.  works fine with or without
net.inet.ip.multipath enabled.

ok pyr@@, jmc@@ for manpages
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.c,v 1.91 2009/08/07 11:21:53 reyk Exp $	*/
d1135 1
@


1.91
log
@rename 'struct session' to 'struct rsession' because it conflicts with
another 'struct session' in sys/sysctl.h.
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.c,v 1.90 2009/08/05 13:46:13 reyk Exp $	*/
d273 1
d275 1
d300 2
d618 2
d623 1
d656 8
d864 11
@


1.90
log
@prevent configuration of relays listening to a single addr:port tuple twice
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.c,v 1.88 2009/06/05 00:20:50 pyr Exp $	*/
d474 1
a474 1
	struct session		*sess;
d839 1
a839 1
struct session *
d843 1
a843 1
	struct session		*con;
@


1.89
log
@4 handed diff with eric:
Stop pushing event handling in the imsg framework.
Instead, provide a small glue layer on top of both imsg and libevent.
This finally clearly separates event handling and imsg construction.

Sidetrack bonus: remove the mega-ugly hack of having a dummy imsg_event_add
stub in relayctl.

This will make bgpd (and thus henning) happy. Next up are smtpd and ospfd.

ok eric@@
@
text
@d926 12
@


1.88
log
@some KNF cleanup following the last sed.
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.c,v 1.87 2009/06/05 00:04:01 pyr Exp $	*/
d69 3
a71 3
struct imsgbuf	*ibuf_pfe;
struct imsgbuf	*ibuf_hce;
struct imsgbuf	*ibuf_relay;
d135 1
a135 1
	struct imsgbuf		*ibuf;
d260 2
a261 2
	if ((ibuf_pfe = calloc(1, sizeof(struct imsgbuf))) == NULL ||
	    (ibuf_hce = calloc(1, sizeof(struct imsgbuf))) == NULL)
d265 2
a266 2
		if ((ibuf_relay = calloc(env->sc_prefork_relay,
		    sizeof(struct imsgbuf))) == NULL)
d270 5
a274 2
	imsg_init(ibuf_pfe, pipe_parent2pfe[0], main_dispatch_pfe);
	imsg_init(ibuf_hce, pipe_parent2hce[0], main_dispatch_hce);
d276 18
a293 17
		ibuf = &ibuf_relay[c];
		imsg_init(ibuf, pipe_parent2relay[c][1], main_dispatch_relay);
		ibuf->events = EV_READ;
		event_set(&ibuf->ev, ibuf->fd, ibuf->events,
		    ibuf->handler, ibuf);
		event_add(&ibuf->ev, NULL);
	}

	ibuf_pfe->events = EV_READ;
	event_set(&ibuf_pfe->ev, ibuf_pfe->fd, ibuf_pfe->events,
	    ibuf_pfe->handler, ibuf_pfe);
	event_add(&ibuf_pfe->ev, NULL);

	ibuf_hce->events = EV_READ;
	event_set(&ibuf_hce->ev, ibuf_hce->fd, ibuf_hce->events,
	    ibuf_hce->handler, ibuf_hce);
	event_add(&ibuf_hce->ev, NULL);
d354 1
a354 1
	if (imsg_compose_event(ibuf_pfe, type, 0, 0, -1, buf, len) == -1)
d356 1
a356 1
	if (imsg_compose_event(ibuf_hce, type, 0, 0, -1, buf, len) == -1)
d359 1
a359 1
		if (imsg_compose_event(&ibuf_relay[i], type, 0, 0, -1, buf, len)
d429 1
a429 1
	imsg_compose_event(ibuf_pfe, IMSG_RECONF, 0, 0, -1, env, sizeof(*env));
d431 1
a431 1
		imsg_compose_event(ibuf_pfe, IMSG_RECONF_TABLE, 0, 0, -1,
d434 1
a434 1
			imsg_compose_event(ibuf_pfe, IMSG_RECONF_HOST, 0, 0, -1,
d439 1
a439 1
		imsg_compose_event(ibuf_pfe, IMSG_RECONF_RDR, 0, 0, -1,
d442 1
a442 1
			imsg_compose_event(ibuf_pfe, IMSG_RECONF_VIRT, 0, 0, -1,
d445 1
a445 1
	imsg_compose_event(ibuf_pfe, IMSG_RECONF_END, 0, 0, -1, NULL, 0);
d450 1
a450 1
	imsg_compose_event(ibuf_hce, IMSG_RECONF, 0, 0, -1, env, sizeof(*env));
d452 1
a452 1
		imsg_compose_event(ibuf_hce, IMSG_RECONF_TABLE, 0, 0, -1,
d455 1
a455 1
			imsg_compose_event(ibuf_hce, IMSG_RECONF_SENDBUF,
d459 1
a459 1
			imsg_compose_event(ibuf_hce, IMSG_RECONF_HOST, 0, 0, -1,
d463 1
a463 1
	imsg_compose_event(ibuf_hce, IMSG_RECONF_END, 0, 0, -1, NULL, 0);
d578 1
a578 1
imsg_event_add(struct imsgbuf *ibuf)
d580 2
a581 2
	if (ibuf->handler == NULL) {
		imsg_flush(ibuf);
d585 7
a591 7
	ibuf->events = EV_READ;
	if (ibuf->w.queued)
		ibuf->events |= EV_WRITE;

	event_del(&ibuf->ev);
	event_set(&ibuf->ev, ibuf->fd, ibuf->events, ibuf->handler, ibuf);
	event_add(&ibuf->ev, NULL);
d595 2
a596 2
imsg_compose_event(struct imsgbuf *ibuf, u_int16_t type, u_int32_t peerid,
    pid_t pid, int fd, void *data, u_int16_t datalen)
d600 1
a600 1
	if ((ret = imsg_compose(ibuf, type, peerid,
d602 1
a602 1
		imsg_event_add(ibuf);
d609 1
d615 2
a616 1
	ibuf = ptr;
d623 1
a623 1
			event_del(&ibuf->ev);
d662 1
a662 1
	imsg_event_add(ibuf);
d668 1
d676 2
a677 1
	ibuf = ptr;
d684 1
a684 1
			event_del(&ibuf->ev);
d709 1
a709 1
			imsg_compose_event(ibuf_hce, IMSG_SCRIPT,
d713 1
a713 1
			(void)snmp_sendsock(ibuf);
d722 1
a722 1
	imsg_event_add(ibuf);
d729 1
d736 2
a737 1
	ibuf = ptr;
d744 1
a744 1
			event_del(&ibuf->ev);
d779 1
a779 1
			imsg_compose_event(&ibuf_relay[bnd.bnd_proc],
d790 1
a790 1
	imsg_event_add(ibuf);
@


1.87
log
@Make imsg completely async model agnostic by not requiring an
imsg_event_add function to be provided (which ended up being a named
callback).
Instead provide a wrapper in the daemon and call that everywhere.
Previsously discussed with the usual suspects,
ok eric@@ though not too happy about the function name
(imsg_compose_event).
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.c,v 1.86 2009/06/04 13:46:07 reyk Exp $	*/
d451 3
a453 2
			imsg_compose_event(ibuf_hce, IMSG_RECONF_SENDBUF, 0, 0, -1,
			    table->sendbuf, strlen(table->sendbuf) + 1);
d769 2
a770 1
			imsg_compose_event(&ibuf_relay[bnd.bnd_proc], IMSG_BINDANY,
@


1.86
log
@Keep around the SSL session for each checked host. This way SSL
caching can kick in on subsequent checks, making them faster and
lighter on the server.

From camield, closes PR 6137 (modified diff)
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.c,v 1.85 2009/06/02 12:24:16 reyk Exp $	*/
d350 1
a350 1
	if (imsg_compose(ibuf_pfe, type, 0, 0, -1, buf, len) == -1)
d352 1
a352 1
	if (imsg_compose(ibuf_hce, type, 0, 0, -1, buf, len) == -1)
d355 1
a355 1
		if (imsg_compose(&ibuf_relay[i], type, 0, 0, -1, buf, len)
d425 1
a425 1
	imsg_compose(ibuf_pfe, IMSG_RECONF, 0, 0, -1, env, sizeof(*env));
d427 1
a427 1
		imsg_compose(ibuf_pfe, IMSG_RECONF_TABLE, 0, 0, -1,
d430 1
a430 1
			imsg_compose(ibuf_pfe, IMSG_RECONF_HOST, 0, 0, -1,
d435 1
a435 1
		imsg_compose(ibuf_pfe, IMSG_RECONF_RDR, 0, 0, -1,
d438 1
a438 1
			imsg_compose(ibuf_pfe, IMSG_RECONF_VIRT, 0, 0, -1,
d441 1
a441 1
	imsg_compose(ibuf_pfe, IMSG_RECONF_END, 0, 0, -1, NULL, 0);
d446 1
a446 1
	imsg_compose(ibuf_hce, IMSG_RECONF, 0, 0, -1, env, sizeof(*env));
d448 1
a448 1
		imsg_compose(ibuf_hce, IMSG_RECONF_TABLE, 0, 0, -1,
d451 1
a451 1
			imsg_compose(ibuf_hce, IMSG_RECONF_SENDBUF, 0, 0, -1,
d454 1
a454 1
			imsg_compose(ibuf_hce, IMSG_RECONF_HOST, 0, 0, -1,
d458 1
a458 1
	imsg_compose(ibuf_hce, IMSG_RECONF_END, 0, 0, -1, NULL, 0);
d589 12
d700 1
a700 1
			imsg_compose(ibuf_hce, IMSG_SCRIPT,
d768 1
a768 1
			imsg_compose(&ibuf_relay[bnd.bnd_proc], IMSG_BINDANY,
@


1.85
log
@remove extra imsg_event_add() after EV_WRITE checks - this is not
required because it is called later and there is no return before.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.c,v 1.84 2009/06/02 11:33:06 reyk Exp $	*/
d558 2
@


1.84
log
@Libevent may do an upcall with both EV_READ and EV_WRITE set.
So change the code accordingly to allow that.

Found by claudio@@ in ospfd
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.c,v 1.83 2008/09/29 15:12:22 reyk Exp $	*/
a610 2
		imsg_event_add(ibuf);
		return;
a669 2
		imsg_event_add(ibuf);
		return;
a727 2
		imsg_event_add(ibuf);
		return;
@


1.83
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.c,v 1.82 2008/09/29 15:06:52 reyk Exp $	*/
d596 2
a597 2
	switch (event) {
	case EV_READ:
d606 3
a608 2
		break;
	case EV_WRITE:
a612 2
	default:
		fatalx("unknown event");
d657 2
a658 2
	switch (event) {
	case EV_READ:
d667 3
a669 2
		break;
	case EV_WRITE:
a673 2
	default:
		fatalx("unknown event");
d717 2
a718 2
	switch (event) {
	case EV_READ:
d727 3
a729 2
		break;
	case EV_WRITE:
a733 2
	default:
		fatalx("unknown event");
@


1.82
log
@Change parsing of comments in external rule files.  The hash mark may
appear in URLs (eg. /index.html#anchor), so only allow full-line
comments indicated by a hash mark # at the beginning of a line.
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.c,v 1.81 2008/09/29 14:53:35 reyk Exp $	*/
d373 4
a376 2
	memcpy(&env->sc_interval, &new_env->sc_interval, sizeof(env->sc_interval));
	memcpy(&env->sc_timeout, &new_env->sc_timeout, sizeof(env->sc_timeout));
d494 2
a495 1
			while ((sess = SPLAY_ROOT(&rlay->rl_sessions)) != NULL) {
@


1.81
log
@allow to load expect, filter, log, and remove keys from external files
just containing on key per line.  this allows easier use of URL
white/blacklists from external sources.
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.c,v 1.80 2008/08/08 08:51:21 thib Exp $	*/
d1190 3
a1192 3
		/* strip comment, whitespace, and newline characters */
		buf[strcspn(buf, "\r\n\t #")] = '\0';
		if (!strlen(buf))
@


1.80
log
@Check gettimeofday() against -1; Add a missing error check in one place.

OK reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.c,v 1.79 2008/07/22 23:17:37 reyk Exp $	*/
d1172 41
@


1.79
log
@Add dynamic IPv6-to-IPv4 and IPv4-to-IPv6 translation inspired by
faithd(8) by doing a similar mapping of IPv4/6 addresses with
relayd(8) and pf(4) redirections without the need of the faith(4)
interface.  The trick works in both directions, it can accept IPv6
connections and relay them to IPv4 hosts by extracting the last 4
octets from the IPv6 destination (like faithd(8)), and it can accept
IPv4 connections and relay them to IPv6 hosts by prepending the 4
octets of the original IPv4 destination to a configured IPv6 prefix.
An access list is not needed because the classification is done in
pf.conf(5).  It helps to get more faith in relayd.

manpage bits ok jmc@@
yes, sounds good todd@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.c,v 1.78 2008/07/09 14:06:44 reyk Exp $	*/
d913 1
a913 1
	if (gettimeofday(&tv_now, NULL))
@


1.78
log
@only use SOCK_STREAM for TCP in bindany(), otherwise SOCK_DGRAM for UDP.
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.c,v 1.77 2008/06/11 18:21:20 reyk Exp $	*/
d1201 51
@


1.77
log
@add support for "transparent" forwarding in relays: normally the l7
relay will connect to the target host with its own ip address, but
this mode will let it use the address of the client that is connecting
from the other side. for example, there is no need to add the
X-Forwarded-For HTTP headers for internal webservers in this mode
anymore since they magically see the remote client ip address in the
connection. it also allows to build fully-transparent ssl
encapsulation for tcp sessions and many other things...

based on an initial idea from dlg@@ and pascoe@@ (dlg's talk at opencon)
using the new BINDANY and divert-reply interfaces from markus@@ (since n2k8)

ok markus@@ pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.c,v 1.76 2008/05/17 23:31:52 sobrado Exp $	*/
d1184 2
a1185 1
	if ((s = socket(bnd->bnd_ss.ss_family, SOCK_STREAM,
@


1.76
log
@documentation tweaks.

ok (some time ago) jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.c,v 1.75 2008/05/12 19:15:02 pyr Exp $	*/
d59 1
d708 1
d712 2
d743 20
d1172 28
@


1.75
log
@Error out with usage line if additional arguments are given after the
option parsing. Found out the hard way by jdixon on ifstated.

ok sobrado@@, jdixon@@, millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.c,v 1.74 2008/05/06 09:52:47 pyr Exp $	*/
d117 2
a118 1
	fprintf(stderr, "%s [-dnv] [-D macro=value] [-f file]\n", __progname);
@


1.74
log
@do not attempt to reload a configuration if we come from a non pf
requiring configuration to a pf requiring one.
ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.c,v 1.73 2008/02/13 11:32:59 reyk Exp $	*/
d165 5
@


1.73
log
@bump copyright
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.c,v 1.72 2008/02/13 11:20:08 reyk Exp $	*/
d396 9
@


1.72
log
@no need to set values after bcopying the complete struct
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.c,v 1.71 2008/02/13 11:02:37 reyk Exp $	*/
d4 1
@


1.71
log
@stylistic change: move code to add protonodes from the BNF into
seperate functions in relayd.c (protonode_add/protonode_header).  this
code got to big to look nice in the BNF statements...
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.c,v 1.70 2008/02/11 10:42:50 reyk Exp $	*/
a1076 2
	pn->type = node->type;
	pn->label = node->label;
a1081 1
	pn->flags = node->flags;
@


1.70
log
@Marry relayd with snmpd using new "send trap" option: Request to send
a SNMP trap when the state of a host changes.  relayd(8) will try to
(re-)connect to snmpd(8) and request it to send a trap to the
registered trap receivers, see snmpd.conf(5) for more information
about the configuration.

ok pyr@@ thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.c,v 1.69 2008/01/31 12:12:50 thib Exp $	*/
d1014 121
@


1.69
log
@add prefixes to names of structure elements to make it easier to grep
for code, next struct session;

ok reyk@@;
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.c,v 1.68 2008/01/31 09:56:28 reyk Exp $	*/
d553 5
d674 3
@


1.68
log
@add prefixes to names of structure elements to make it easier to grep
for code, next struct relay.  knf long line fixes will follow later.

ok thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.c,v 1.67 2008/01/31 09:33:39 reyk Exp $	*/
d779 1
a779 1
			if (con->id == id)
@


1.67
log
@add prefixes to names of structure elements to make it easier to grep
for code, start with struct relayd.  finally.

ok thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.c,v 1.66 2008/01/29 17:36:08 thib Exp $	*/
d449 1
a449 1
	struct relay		*rly;
d473 3
a475 3
		while ((rly = TAILQ_FIRST(env->sc_relays)) != NULL) {
			TAILQ_REMOVE(env->sc_relays, rly, entry);
			while ((sess = SPLAY_ROOT(&rly->sessions)) != NULL) {
d477 1
a477 1
				    &rly->sessions, sess);
d480 7
a486 7
			if (rly->bev != NULL)
				bufferevent_free(rly->bev);
			if (rly->dstbev != NULL)
				bufferevent_free(rly->dstbev);
			if (rly->ssl_ctx != NULL)
				SSL_CTX_free(rly->ssl_ctx);
			free(rly);
d765 2
a766 2
	TAILQ_FOREACH(rlay, env->sc_relays, entry)
		if (rlay->conf.id == id)
d777 2
a778 2
	TAILQ_FOREACH(rlay, env->sc_relays, entry)
		SPLAY_FOREACH(con, session_tree, &rlay->sessions)
d852 2
a853 2
	TAILQ_FOREACH(rlay, env->sc_relays, entry)
		if (strcmp(rlay->conf.name, name) == 0)
@


1.66
log
@When doing reconfigure() dont run a purge_config() on the
new_env if parse_config() fails, it's NULL and parse_config()
already freed it; Prevents segfaults when relayctl issues a
reload and there's a syntax error in the configuration file.

OK reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.c,v 1.65 2007/12/10 20:31:56 pyr Exp $	*/
d169 1
a169 1
	if (env->opts & RELAYD_OPT_NOACTION) {
d174 1
a174 1
		env->opts |= RELAYD_OPT_LOGUPDATE;
d200 1
a200 1
	for (c = 0; c < env->prefork_relay; c++) {
d224 1
a224 1
	if (env->prefork_relay > 0)
d246 1
a246 1
	for (c = 0; c < env->prefork_relay; c++) {
d256 2
a257 2
	if (env->prefork_relay > 0) {
		if ((ibuf_relay = calloc(env->prefork_relay,
d264 1
a264 1
	for (c = 0; c < env->prefork_relay; c++) {
d283 2
a284 2
	if (env->flags & F_DEMOTE)
		carp_demote_reset(env->demote_group, 0);
d311 2
a312 2
	if (env->flags & F_DEMOTE)
		carp_demote_reset(env->demote_group, 128);
d346 1
a346 1
	for (i = 0; i < env->prefork_relay; i++) {
d357 22
a378 22
	env->opts = new_env->opts;
	env->flags = new_env->flags;
	env->confpath = new_env->confpath;
	env->tablecount = new_env->tablecount;
	env->rdrcount = new_env->rdrcount;
	env->protocount = new_env->protocount;
	env->relaycount = new_env->relaycount;

	memcpy(&env->interval, &new_env->interval, sizeof(env->interval));
	memcpy(&env->timeout, &new_env->timeout, sizeof(env->timeout));
	memcpy(&env->empty_table, &new_env->empty_table,
	    sizeof(env->empty_table));
	memcpy(&env->proto_default, &new_env->proto_default,
	    sizeof(env->proto_default));
	env->prefork_relay = new_env->prefork_relay;
	(void)strlcpy(env->demote_group, new_env->demote_group,
	    sizeof(env->demote_group));

	env->tables = new_env->tables;
	env->rdrs = new_env->rdrs;
	env->relays = new_env->relays;
	env->protos = new_env->protos;
d393 1
a393 1
	if ((new_env = parse_config(env->confpath, env->opts)) == NULL) {
d407 1
a407 1
	TAILQ_FOREACH(table, env->tables, entry) {
d415 1
a415 1
	TAILQ_FOREACH(rdr, env->rdrs, entry) {
d428 1
a428 1
	TAILQ_FOREACH(table, env->tables, entry) {
d452 5
a456 5
	if (what & PURGE_TABLES && env->tables != NULL) {
		while ((table = TAILQ_FIRST(env->tables)) != NULL)
			purge_table(env->tables, table);
		free(env->tables);
		env->tables = NULL;
d459 3
a461 3
	if (what & PURGE_RDRS && env->rdrs != NULL) {
		while ((rdr = TAILQ_FIRST(env->rdrs)) != NULL) {
			TAILQ_REMOVE(env->rdrs, rdr, entry);
d468 2
a469 2
		free(env->rdrs);
		env->rdrs = NULL;
d472 3
a474 3
	if (what & PURGE_RELAYS && env->relays != NULL) {
		while ((rly = TAILQ_FIRST(env->relays)) != NULL) {
			TAILQ_REMOVE(env->relays, rly, entry);
d488 2
a489 2
		free(env->relays);
		env->relays = NULL;
d492 3
a494 3
	if (what & PURGE_PROTOS && env->protos != NULL) {
		while ((proto = TAILQ_FIRST(env->protos)) != NULL) {
			TAILQ_REMOVE(env->protos, proto, entry);
d501 2
a502 2
		free(env->protos);
		env->protos = NULL;
d731 1
a731 1
	TAILQ_FOREACH(table, env->tables, entry)
d743 1
a743 1
	TAILQ_FOREACH(table, env->tables, entry)
d754 1
a754 1
	TAILQ_FOREACH(rdr, env->rdrs, entry)
d765 1
a765 1
	TAILQ_FOREACH(rlay, env->relays, entry)
d777 1
a777 1
	TAILQ_FOREACH(rlay, env->relays, entry)
d790 1
a790 1
	TAILQ_FOREACH(table, env->tables, entry)
d802 1
a802 1
	TAILQ_FOREACH(table, env->tables, entry)
d818 1
a818 1
	TAILQ_FOREACH(table, env->tables, entry) {
d841 1
a841 1
	TAILQ_FOREACH(rdr, env->rdrs, entry)
d852 1
a852 1
	TAILQ_FOREACH(rlay, env->relays, entry)
@


1.65
log
@Warn the user when reloading a new configuration fails instead of killing
the daemon.
ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.c,v 1.64 2007/12/08 20:36:36 pyr Exp $	*/
d386 1
a386 1
	struct relayd		*new_env;
a393 2
		purge_config(new_env, PURGE_EVERYTHING);
		free(new_env);
@


1.64
log
@Rename everything which reffered to services refer to rdr for internals
(for instance: rename struct service to struct rdr), refer to redirects
otherwise (hoststatectl output).
ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.c,v 1.63 2007/12/08 17:07:09 reyk Exp $	*/
d393 6
a398 2
	if ((new_env = parse_config(env->confpath, env->opts)) == NULL)
		exit(1);
@


1.63
log
@some changes to the relayd.conf configuration language and grammar.

the tables will look more like pf tables, it is easier to re-use
tables with different options, "services" will become "redirections"
(they refer to rdr pf rules), sync configuration directives of
redirect (l3, ex-service) relay (l7) sections (for example "virtual
host" will become "listen on"), all target definitions will start with
"forward to", etc. pp. (see relay.conf(5) and etc/relayd.conf)

discussed with pyr and deraadt
ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.c,v 1.62 2007/12/07 17:17:01 reyk Exp $	*/
d361 1
a361 1
	env->servicecount = new_env->servicecount;
d376 1
a376 1
	env->services = new_env->services;
d387 1
a387 1
	struct service		*service;
d413 4
a416 4
	TAILQ_FOREACH(service, env->services, entry) {
		imsg_compose(ibuf_pfe, IMSG_RECONF_SERVICE, 0, 0, -1,
		    &service->conf, sizeof(service->conf));
		TAILQ_FOREACH(virt, &service->virts, entry)
d444 1
a444 1
	struct service		*service;
d457 5
a461 5
	if (what & PURGE_SERVICES && env->services != NULL) {
		while ((service = TAILQ_FIRST(env->services)) != NULL) {
			TAILQ_REMOVE(env->services, service, entry);
			while ((virt = TAILQ_FIRST(&service->virts)) != NULL) {
				TAILQ_REMOVE(&service->virts, virt, entry);
d464 1
a464 1
			free(service);
d466 2
a467 2
		free(env->services);
		env->services = NULL;
d747 2
a748 2
struct service *
service_find(struct relayd *env, objid_t id)
d750 1
a750 1
	struct service	*service;
d752 3
a754 3
	TAILQ_FOREACH(service, env->services, entry)
		if (service->conf.id == id)
			return (service);
d813 1
a813 1
	a.id = a.serviceid = 0;
d818 1
a818 1
		b.id = b.serviceid = 0;
d834 2
a835 2
struct service *
service_findbyname(struct relayd *env, const char *name)
d837 1
a837 1
	struct service	*service;
d839 3
a841 3
	TAILQ_FOREACH(service, env->services, entry)
		if (strcmp(service->conf.name, name) == 0)
			return (service);
@


1.62
log
@hoststated gets renamed to relayd.  easier to type, and actually says
what the daemon does - it is a relayer that pays attention to the status
of pools of hosts; not a status checkers that happens to do some relaying
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.c,v 1.61 2007/11/28 11:37:59 reyk Exp $	*/
a443 1
	struct host		*host;
d451 2
a452 15
		while ((table = TAILQ_FIRST(env->tables)) != NULL) {

			while ((host = TAILQ_FIRST(&table->hosts)) != NULL) {
				TAILQ_REMOVE(&table->hosts, host, entry);
				free(host);
			}
			if (table->sendbuf != NULL)
				free(table->sendbuf);
			if (table->conf.flags & F_SSL)
				SSL_CTX_free(table->ssl_ctx);

			TAILQ_REMOVE(env->tables, table, entry);

			free(table);
		}
d530 19
d803 28
@


1.61
log
@unref the label when free'ing a protocol node
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.c,v 1.60 2007/11/25 20:01:10 reyk Exp $	*/
d44 1
a44 1
#include "hoststated.h"
d49 1
a49 1
void		 main_shutdown(struct hoststated *);
d54 1
a54 1
int		 send_all(struct hoststated *, enum imsg_type,
d65 1
a65 1
struct hoststated	*hoststated_env;
d78 1
a78 1
	struct hoststated	*env = arg;
d126 1
a126 1
	struct hoststated	*env;
d152 1
a152 1
			opts |= HOSTSTATED_OPT_NOACTION;
d158 1
a158 1
			opts |= HOSTSTATED_OPT_VERBOSE;
d167 1
a167 1
	hoststated_env = env;
d169 1
a169 1
	if (env->opts & HOSTSTATED_OPT_NOACTION) {
d174 1
a174 1
		env->opts |= HOSTSTATED_OPT_LOGUPDATE;
d179 2
a180 2
	if (getpwnam(HOSTSTATED_USER) == NULL)
		errx(1, "unknown user %s", HOSTSTATED_USER);
d292 1
a292 1
main_shutdown(struct hoststated *env)
d338 1
a338 1
send_all(struct hoststated *env, enum imsg_type type, void *buf, u_int16_t len)
d355 1
a355 1
merge_config(struct hoststated *env, struct hoststated *new_env)
d385 2
a386 2
	struct hoststated	*env = hoststated_env;
	struct hoststated	*new_env;
d441 1
a441 1
purge_config(struct hoststated *env, u_int8_t what)
d622 1
a622 1
	struct hoststated	*env;
d624 1
a624 1
	env = hoststated_env;
d719 1
a719 1
host_find(struct hoststated *env, objid_t id)
d732 1
a732 1
table_find(struct hoststated *env, objid_t id)
d743 1
a743 1
service_find(struct hoststated *env, objid_t id)
d754 1
a754 1
relay_find(struct hoststated *env, objid_t id)
d765 1
a765 1
session_find(struct hoststated *env, objid_t id)
d778 1
a778 1
host_findbyname(struct hoststated *env, const char *name)
d791 1
a791 1
table_findbyname(struct hoststated *env, const char *name)
d802 1
a802 1
service_findbyname(struct hoststated *env, const char *name)
d813 1
a813 1
relay_findbyname(struct hoststated *env, const char *name)
@


1.60
log
@in addition to IPv4/6 addresses, canonicalize the hostname for "url",
for example
".www...Example.com." will be translated to "www.example.com".

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.c,v 1.59 2007/11/24 17:07:28 reyk Exp $	*/
d535 2
@


1.59
log
@sort includes, adjust to style(9)
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.c,v 1.58 2007/11/24 16:13:50 reyk Exp $	*/
d37 1
d923 3
d927 6
d938 22
a959 4
	/* XXX canonicalize a FQDN... */
	if (strlcpy(name, host, len) >= len) {
		errno = EINVAL;
		return (NULL);
d961 2
d965 4
@


1.58
log
@extend the url lookup algorithm to match the full URL and different
possible suffix/prefix combinations by stripping subdomains, path
components, and the query args.

ok and tested by gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.c,v 1.57 2007/11/23 09:22:18 sthen Exp $	*/
a21 1
#include <sys/param.h>
d23 1
d27 1
@


1.57
log
@fix typo

ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.c,v 1.56 2007/11/21 20:13:20 reyk Exp $	*/
d25 2
d914 20
@


1.56
log
@move digest string handling into an extra function.
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.c,v 1.55 2007/11/20 15:54:55 reyk Exp $	*/
d83 1
a83 1
		if (check_child(pfe_pid, "pf udpate engine")) {
@


1.55
log
@it may be desirable to send a HTTP error page with error code and a
meaningful message if a HTTP/HTTPS relay closes the connection for
some reason. for example, a "403 Forbidden" if the request was
rejected by a filter. this will be enabled with the "return error"
option and is disabled by default, the standard behaviour is to
silently drop the connection; the browser may display an empty page in
this case. the look+feel of the HTTP error page can be customized with
a CSS style sheet, but we do not intend to allow customization of the
error page contents (hoststated is not a webserver!).

ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.c,v 1.54 2007/11/19 15:31:36 reyk Exp $	*/
d35 2
d896 16
@


1.54
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.c,v 1.53 2007/11/19 14:48:19 reyk Exp $	*/
d503 2
@


1.53
log
@rework the internal handling of protocol actions a little bit:

- allow to use a key for multiple times by appending a queue of
additional matches to the tree node. for example, this allows to
specify multiple "expect" or "filter" actions to white-/black-list
a list of HTTP-headers, URLs, ..

- prevent specifing an HTTP header for multiple times when using the
expect action.

- minor code shuffling
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.c,v 1.51 2007/11/15 17:02:01 pyr Exp $	*/
d247 1
a247 1
	    (ibuf_hce = calloc(1, sizeof(struct imsgbuf))) == NULL) 
d252 1
a252 1
		    sizeof(struct imsgbuf))) == NULL) 
d341 1
a341 1
		if (imsg_compose(&ibuf_relay[i], type, 0, 0, -1, buf, len) 
d427 1
a427 1
			imsg_compose(ibuf_hce, IMSG_RECONF_HOST, 0, 0, -1, 
@


1.52
log
@move repeated code to cleanup a protocol tree into a function.
@
text
@d513 1
a513 1
	struct protonode	*proot;
d521 8
@


1.51
log
@Do not insert proto_default inside the dynamically alloced protocol queue.
Handle it as a special case in the one place where it actually matters
instead.
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.c,v 1.50 2007/11/14 11:01:52 pyr Exp $	*/
d51 1
a441 1
	struct protonode	*pnode;
d501 2
a502 20
			while ((pnode = RB_ROOT(&proto->request_tree))
			    != NULL) {
				RB_REMOVE(proto_tree, &proto->request_tree,
				    pnode);
				if (pnode->key != NULL)
					free(pnode->key);
				if (pnode->value != NULL)
					free(pnode->value);
				free(pnode);
			}
			while ((pnode = RB_ROOT(&proto->response_tree))
			    != NULL) {
				RB_REMOVE(proto_tree, &proto->response_tree,
				    pnode);
				if (pnode->key != NULL)
					free(pnode->key);
				if (pnode->value != NULL)
					free(pnode->value);
				free(pnode);
			}
d507 15
@


1.50
log
@add some sanity, that will be useful later on.
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.c,v 1.49 2007/11/14 10:59:01 pyr Exp $	*/
a500 2
			if (strcmp(proto->name, "default") == 0)
				continue;
@


1.49
log
@make protos dynamic too
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.c,v 1.48 2007/11/13 10:35:21 pyr Exp $	*/
d370 2
d495 1
d501 1
a501 1
			if (proto == &env->proto_default)
d526 1
@


1.48
log
@relays are dynamic now.
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.c,v 1.47 2007/11/04 22:09:02 reyk Exp $	*/
d495 3
a497 3
	if (what & PURGE_PROTOS) {
		while ((proto = TAILQ_FIRST(&env->protos)) != NULL) {
			TAILQ_REMOVE(&env->protos, proto, entry);
d522 1
@


1.47
log
@the last change to enable logging to stderr on startup also enabled
annoying debugging messages on the console by default.  since we do
not want to see debugging messages unless specified by the "-d" flag,
add an extra debugging level "debug > 1" to be checked in log_debug().
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.c,v 1.46 2007/10/19 14:40:51 pyr Exp $	*/
d476 1
a476 1
	if (what & PURGE_RELAYS) {
@


1.46
log
@Do log initialisation correctly, like bgpd does.
This removes the double warn/log_warn madness i introduced yesterday.
This also keeps messages on stderr at startup and when running with -n.
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.c,v 1.45 2007/10/19 14:15:14 pyr Exp $	*/
d136 1
a136 1
			debug = 1;
d144 1
a144 1
			debug = 1;
@


1.45
log
@Move relays from static TAILQs to allocated ones.
This syncs it with other hoststated entities and will make reload easier.
This is step 1 out of 7 for reload.
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.c,v 1.44 2007/10/12 12:50:59 blambert Exp $	*/
d131 2
d144 1
a157 2
	log_init(debug);

d174 2
@


1.44
log
@Silence some lint(1) warnings

ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.c,v 1.43 2007/10/05 17:32:13 reyk Exp $	*/
d474 2
a475 2
		while ((rly = TAILQ_FIRST(&env->relays)) != NULL) {
			TAILQ_REMOVE(&env->relays, rly, entry);
d489 1
d737 1
a737 1
	TAILQ_FOREACH(rlay, &env->relays, entry)
d749 1
a749 1
	TAILQ_FOREACH(rlay, &env->relays, entry)
d796 1
a796 1
	TAILQ_FOREACH(rlay, &env->relays, entry)
@


1.43
log
@stylistic changes in the relay/relay_config structure.
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.c,v 1.42 2007/10/02 21:04:13 pyr Exp $	*/
d78 1
@


1.42
log
@stop messing with lgetc to please hoststated's check/expect.
instead move some of the logic in yylex and do hoststated specific
translations into hoststated.c
ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.c,v 1.41 2007/09/28 20:23:38 pyr Exp $	*/
d484 2
a485 2
			if (rly->ctx != NULL)
				SSL_CTX_free(rly->ctx);
@


1.41
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.c,v 1.40 2007/09/28 13:29:56 pyr Exp $	*/
d851 28
@


1.40
log
@Correct my mail address.
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.c,v 1.39 2007/09/05 08:48:42 reyk Exp $	*/
d476 2
a477 1
				SPLAY_REMOVE(session_tree, &rly->sessions, sess);
@


1.39
log
@store relay sessions in SPLAY trees instead of TAILQ lists. this will
be used for faster lookups of sessions based on different criteria.

ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.c,v 1.38 2007/07/05 09:42:26 thib Exp $	*/
d4 1
a4 1
 * Copyright (c) 2006 Pierre-Yves Ritschard <pyr@@spootnik.org>
@


1.38
log
@use a more traditional while() instead of for() for getopt().
sync usage() to the man page.
format string fixes.
complain about failed calloc()'s instead of exiting silently.

ok pry@@,reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.c,v 1.37 2007/06/19 06:29:20 pyr Exp $	*/
d475 2
a476 2
			while ((sess = TAILQ_FIRST(&rly->sessions)) != NULL) {
				TAILQ_REMOVE(&rly->sessions, sess, entry);
d747 1
a747 1
		TAILQ_FOREACH(con, &rlay->sessions, entry)
@


1.37
log
@Do not fatal out with ``pipe closed'' when a short read occurs on one
of our socket pairs. Instead disable listening on the pipe, terminate the
event loop, and let the parent process's SIGCHLD handler do a clean
shutdown.

from an ospfd diff by claudio, ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.c,v 1.36 2007/06/12 15:16:10 msf Exp $	*/
d108 1
a108 1
	fprintf(stderr, "%s [-dnv] [-f file]\n", __progname);
d130 1
a130 1
	for (;(c = getopt(argc, argv, "dD:nf:v")) != -1;) {
@


1.36
log
@put the fd passing from bgpd back in to hoststated's version of imsg,
needed for layer 7 reload support.

ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.c,v 1.35 2007/06/07 07:19:50 pyr Exp $	*/
d544 6
a549 2
		if (n == 0)
			fatalx("main_dispatch_pfe: pipe closed");
d606 6
a611 2
		if (n == 0)
			fatalx("main_dispatch_hce: pipe closed");
d661 6
a666 2
		if (n == 0)
			fatalx("main_dispatch_relay: pipe closed");
@


1.35
log
@(finally) Enable reload support for layer 3 configurations.
Hoststated can be reloaded either by sending SIGHUP to the parent process
or by using ``hoststatectl reload''
discussed and ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.c,v 1.34 2007/05/31 03:24:05 pyr Exp $	*/
d331 1
a331 1
	if (imsg_compose(ibuf_pfe, type, 0, 0, buf, len) == -1)
d333 1
a333 1
	if (imsg_compose(ibuf_hce, type, 0, 0, buf, len) == -1)
d336 2
a337 1
		if (imsg_compose(&ibuf_relay[i], type, 0, 0, buf, len) == -1)
d391 1
a391 1
	imsg_compose(ibuf_pfe, IMSG_RECONF, 0, 0, env, sizeof(*env));
d393 1
a393 1
		imsg_compose(ibuf_pfe, IMSG_RECONF_TABLE, 0, 0,
d396 1
a396 1
			imsg_compose(ibuf_pfe, IMSG_RECONF_HOST, 0, 0,
d401 1
a401 1
		imsg_compose(ibuf_pfe, IMSG_RECONF_SERVICE, 0, 0,
d404 1
a404 1
			imsg_compose(ibuf_pfe, IMSG_RECONF_VIRT, 0, 0,
d407 1
a407 1
	imsg_compose(ibuf_pfe, IMSG_RECONF_END, 0, 0, NULL, 0);
d412 1
a412 1
	imsg_compose(ibuf_hce, IMSG_RECONF, 0, 0, env, sizeof(*env));
d414 1
a414 1
		imsg_compose(ibuf_hce, IMSG_RECONF_TABLE, 0, 0,
d417 1
a417 1
			imsg_compose(ibuf_hce, IMSG_RECONF_SENDBUF, 0, 0,
d420 1
a420 1
			imsg_compose(ibuf_hce, IMSG_RECONF_HOST, 0, 0,
d424 1
a424 1
	imsg_compose(ibuf_hce, IMSG_RECONF_END, 0, 0, NULL, 0);
d629 1
a629 1
			    0, 0, &scr, sizeof(scr));
@


1.34
log
@allocate table lists and service lists instead of using static structs.
split the code to start the event loop in two functions.
introduce merge_config which will be used later on.
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.c,v 1.33 2007/05/30 00:51:21 pyr Exp $	*/
d50 1
d95 1
a95 1
		/* reconfigure */
d367 59
d438 1
a438 1
	if (what & PURGE_TABLES) {
d455 1
d458 1
a458 1
	if (what & PURGE_SERVICES) {
d468 1
a515 1

d574 1
@


1.33
log
@give ibuf to event_set
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.c,v 1.32 2007/05/30 00:19:25 pyr Exp $	*/
d342 25
d378 19
d398 2
a399 2
		while ((service = TAILQ_FIRST(&env->services)) != NULL) {
			TAILQ_REMOVE(&env->services, service, entry);
d406 1
a454 14
	if (what & PURGE_TABLES) {
		while ((table = TAILQ_FIRST(&env->tables)) != NULL) {
			TAILQ_REMOVE(&env->tables, table, entry);
			while ((host = TAILQ_FIRST(&table->hosts)) != NULL) {
				TAILQ_REMOVE(&table->hosts, host, entry);
				free(host);
			}
			if (table->sendbuf != NULL)
				free(table->sendbuf);
			if (table->ssl_ctx != NULL)
				SSL_CTX_free(table->ssl_ctx);
			free(table);
		}
	}
d625 1
a625 1
	TAILQ_FOREACH(table, &env->tables, entry)
d637 1
a637 1
	TAILQ_FOREACH(table, &env->tables, entry)
d648 1
a648 1
	TAILQ_FOREACH(service, &env->services, entry)
d684 1
a684 1
	TAILQ_FOREACH(table, &env->tables, entry)
d696 1
a696 1
	TAILQ_FOREACH(table, &env->tables, entry)
d707 1
a707 1
	TAILQ_FOREACH(service, &env->services, entry)
@


1.32
log
@backout more code that shouldn't have gone in.
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.c,v 1.31 2007/05/30 00:12:21 pyr Exp $	*/
d257 1
a257 1
		    ibuf->handler, env);
d263 1
a263 1
	    ibuf_pfe->handler, env);
d268 1
a268 1
	    ibuf_hce->handler, env);
@


1.31
log
@backout last diff which introduces problems and use the global
environment instead.
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.c,v 1.30 2007/05/29 23:58:30 pyr Exp $	*/
a49 1
void		 reconfigure(struct hoststated *);
a341 38
reconfigure(struct hoststated *env)
{
	struct hoststated	*new_env;
	struct table            *table;
	struct host             *host;
	struct service          *service;
	struct address          *virt;

	if ((new_env = parse_config(env->confpath, env->opts)) == NULL)
		fatalx("reconfigure: could not parse configuration");
	log_warnx("PURGING CONF");
	purge_config(env, PURGE_EVERYTHING);
	log_warnx("MEMCPY ENV");
	memcpy(env, new_env, sizeof(*env));
	/*
	 * XXX free(new_env)
	 */
	TAILQ_FOREACH(table, &env->tables, entry) {
		send_all(env, IMSG_RECONF_TABLE,
		    &table->conf, sizeof(table->conf));
		imsg_compose(ibuf_hce, IMSG_RECONF_SENDBUF, 0, 0,
		    table->sendbuf, strlen(table->sendbuf)); 
		TAILQ_FOREACH(host, &table->hosts, entry)
			send_all(env, IMSG_RECONF_HOST,
			    &host->conf, sizeof(host->conf));
	}
	TAILQ_FOREACH(service, &env->services, entry) {
		imsg_compose(ibuf_pfe, IMSG_RECONF_SERVICE, 0, 0,
		    &service->conf, sizeof(service->conf));
		TAILQ_FOREACH(virt, &service->virts, entry)
			imsg_compose(ibuf_pfe, IMSG_RECONF_VIRT, 0, 0,
			    virt, sizeof(*virt));
	}

	send_all(env, IMSG_RECONF_END, NULL, 0);
}

void
a481 1
			reconfigure(env);
@


1.30
log
@make sure every dispatch function is fed the environment structure.
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.c,v 1.29 2007/05/29 23:19:18 pyr Exp $	*/
d50 1
d343 38
a483 1
	struct hoststated	*env = ptr;
d521 1
d540 1
a540 1
	struct hoststated	*env = ptr;
a592 1
	struct hoststated	*env = ptr;
@


1.29
log
@allow the control handling code to send messages back to the parent.
forward IMSG_CTL_RELOAD which ends up not doing anything for now.
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.c,v 1.28 2007/05/29 18:59:53 pyr Exp $	*/
d257 1
a257 1
		    ibuf->handler, ibuf);
d263 1
a263 1
	    ibuf_pfe->handler, ibuf_pfe);
d268 1
a268 1
	    ibuf_hce->handler, ibuf_hce);
d445 1
d501 1
a501 1
	struct hoststated	*env;
d554 1
@


1.28
log
@do not start relay processes when no L7 load balancing is needed.
ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.c,v 1.27 2007/05/29 17:12:04 reyk Exp $	*/
d244 5
a248 4
	if (env->prefork_relay > 0 &&
	    (ibuf_relay = calloc(env->prefork_relay,
	    sizeof(struct imsgbuf)) == NULL))
		fatal(NULL);
d477 5
@


1.27
log
@add a new check method which allows to run external scripts/programs
for custom evaluations.

pyr agrees to put it in now but to do some improvements of the timeout
handling later.
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.c,v 1.26 2007/05/29 00:58:06 pyr Exp $	*/
d212 3
a214 2
	relay_pid = relay(env, pipe_parent2pfe, pipe_parent2hce,
	    pipe_parent2relay, pipe_pfe2hce, pipe_pfe2relay);
d241 4
a244 1
	    (ibuf_hce = calloc(1, sizeof(struct imsgbuf))) == NULL ||
d246 1
a246 1
	    sizeof(struct imsgbuf))) == NULL)
@


1.26
log
@when purging relays, purge sessions as well.
not needed for the initial purge since no sessions exist but will
be necessary when reloading the relay process.
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.c,v 1.25 2007/05/29 00:21:10 pyr Exp $	*/
d57 2
a72 2
	log_debug("signal %d", sig);

d157 1
d489 2
d492 1
d517 10
d534 1
@


1.25
log
@move struct relay to the runtime + config scheme.
this time around, include hoststatectl changes too.
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.c,v 1.24 2007/05/28 22:11:33 pyr Exp $	*/
d345 1
d361 4
@


1.24
log
@another small step towards hoststated reloading.
allow purging of parts of the hoststated environment structure.
start using this function now to only keep vital information in
hoststated children processes.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.c,v 1.23 2007/05/27 20:53:10 pyr Exp $	*/
d599 1
a599 1
		if (rlay->id == id)
d658 1
a658 1
		if (strcmp(rlay->name, name) == 0)
@


1.23
log
@Second step towards hoststated reload:
First split out hosts, tables and services into to structs, one that
contains the runtime fields and one (inside the runtime) that contains
mostly static fields that will be sent over the socket during reload.

Also move the demoted field of tables inside the flags field as its
just a boolean.
ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.c,v 1.22 2007/05/26 19:58:49 pyr Exp $	*/
d333 80
@


1.22
log
@first steps for implementing reload:
	* make parse_config allocate the hoststated function by itself
	* make as many sockets as necessary to talk to the relay children
	* add send_all for talking to all children
with advise and ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.c,v 1.21 2007/03/17 22:54:49 reyk Exp $	*/
d486 1
a486 1
			if (host->id == id)
d497 1
a497 1
		if (table->id == id)
d508 1
a508 1
		if (service->id == id)
d545 1
a545 1
			if (strcmp(host->name, name) == 0)
d556 1
a556 1
		if (strcmp(table->name, name) == 0)
d567 1
a567 1
		if (strcmp(service->name, name) == 0)
@


1.21
log
@remove a debug message
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.c,v 1.20 2007/02/26 16:10:24 reyk Exp $	*/
d48 2
a52 1
int		 pipe_parent2relay[2];
d54 1
d114 10
a123 9
	int		 c;
	int		 debug;
	u_int32_t	 opts;
	struct hoststated	 env;
	const char	*conffile;
	struct event	 ev_sigint;
	struct event	 ev_sigterm;
	struct event	 ev_sigchld;
	struct event	 ev_sighup;
a127 1
	bzero(&env, sizeof (env));
d155 1
a155 1
	if (parse_config(&env, conffile, opts))
d158 1
a158 1
	if (env.opts & HOSTSTATED_OPT_NOACTION) {
d163 1
a163 1
		env.opts |= HOSTSTATED_OPT_LOGUPDATE;
a184 3
	    pipe_parent2relay) == -1)
		fatal("socketpair");
	if (socketpair(AF_UNIX, SOCK_STREAM, PF_UNSPEC,
d187 4
a190 1
	for (c = 0; c < env.prefork_relay; c++) {
d196 2
a203 2
	session_socket_blockmode(pipe_parent2relay[0], BM_NONBLOCK);
	session_socket_blockmode(pipe_parent2relay[1], BM_NONBLOCK);
d207 1
a207 1
	pfe_pid = pfe(&env, pipe_parent2pfe, pipe_parent2hce,
d209 1
a209 1
	hce_pid = hce(&env, pipe_parent2pfe, pipe_parent2hce,
d211 1
a211 1
	relay_pid = relay(&env, pipe_parent2pfe, pipe_parent2hce,
d218 4
a221 4
	signal_set(&ev_sigint, SIGINT, main_sig_handler, &env);
	signal_set(&ev_sigterm, SIGTERM, main_sig_handler, &env);
	signal_set(&ev_sigchld, SIGCHLD, main_sig_handler, &env);
	signal_set(&ev_sighup, SIGHUP, main_sig_handler, &env);
a229 1
	close(pipe_parent2relay[1]);
d232 1
a232 1
	for (c = 0; c < env.prefork_relay; c++) {
d235 1
d240 2
a241 1
	    (ibuf_relay = calloc(1, sizeof(struct imsgbuf))) == NULL)
d246 8
a253 1
	imsg_init(ibuf_relay, pipe_parent2relay[0], main_dispatch_relay);
d265 2
a266 7
	ibuf_relay->events = EV_READ;
	event_set(&ibuf_relay->ev, ibuf_relay->fd, ibuf_relay->events,
	    ibuf_relay->handler, ibuf_relay);
	event_add(&ibuf_relay->ev, NULL);

	if (env.flags & F_DEMOTE)
		carp_demote_reset(env.demote_group, 0);
d319 16
d475 1
@


1.20
log
@handle strlcpy return values, make lint happy
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.c,v 1.19 2007/02/23 00:28:06 deraadt Exp $	*/
d509 1
a509 2
		TAILQ_FOREACH(con, &rlay->sessions, entry) {
			log_debug("session_find: %d : %d", id, con->id);
a511 1
		}
@


1.19
log
@knf
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.c,v 1.18 2007/02/22 05:58:06 reyk Exp $	*/
d610 1
a610 1
	strlcpy(label, tmp, len);	/* always fits */
@


1.18
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.c,v 1.17 2007/02/22 03:32:39 reyk Exp $	*/
d379 1
a379 1
	struct imsgbuf          *ibuf;
d419 1
a419 1
	struct imsgbuf          *ibuf;
d610 1
a610 1
	strlcpy(label, tmp, len);       /* always fits */
@


1.17
log
@Add layer 7 functionality to hoststated used for layer 7
loadbalancing, SSL acceleration, general-purpose TCP relaying, and
transparent proxying.

see hoststated.conf(5) and my upcoming article on undeadly.org for
details.

ok to commit deraadt@@ pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.c,v 1.16 2007/02/08 13:32:24 reyk Exp $	*/
d67 1
a67 1
	int		 	 die = 0;
d176 2
a177 1
	if (socketpair(AF_UNIX, SOCK_STREAM, PF_UNSPEC, pipe_parent2pfe) == -1)
d179 2
a180 1
	if (socketpair(AF_UNIX, SOCK_STREAM, PF_UNSPEC, pipe_parent2hce) == -1)
d182 2
a183 1
	if (socketpair(AF_UNIX, SOCK_STREAM, PF_UNSPEC, pipe_parent2relay) == -1)
d185 2
a186 1
	if (socketpair(AF_UNIX, SOCK_STREAM, PF_UNSPEC, pipe_pfe2hce) == -1)
d596 1
a596 1
	while ((q = strstr(p, srch)) != NULL) {   
@


1.16
log
@carefully check some return values and make lint happier.  never pass
any truncated strings (table names/anchors/tags/...) to pf and the
kernel.

ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.c,v 1.15 2007/02/07 13:30:17 reyk Exp $	*/
d43 1
a43 1
void		 main_shutdown(void);
d46 1
d51 1
d53 1
d57 1
d61 1
d66 4
a69 1
	int		 die = 0;
d84 4
d89 1
a89 1
			main_shutdown();
d160 2
d180 2
d184 7
d196 2
d201 6
a206 2
	pfe_pid = pfe(&env, pipe_parent2pfe, pipe_parent2hce, pipe_pfe2hce);
	hce_pid = hce(&env, pipe_parent2pfe, pipe_parent2hce, pipe_pfe2hce);
d212 4
a215 4
	signal_set(&ev_sigint, SIGINT, main_sig_handler, NULL);
	signal_set(&ev_sigterm, SIGTERM, main_sig_handler, NULL);
	signal_set(&ev_sigchld, SIGCHLD, main_sig_handler, NULL);
	signal_set(&ev_sighup, SIGHUP, main_sig_handler, NULL);
d224 1
d227 4
d233 2
a234 1
	    (ibuf_hce = calloc(1, sizeof(struct imsgbuf))) == NULL)
d239 1
d251 8
d265 1
a265 1
main_shutdown(void)
d273 2
d283 3
d328 1
d354 8
d412 40
d487 26
d548 11
d579 31
@


1.15
log
@add the -D option to define macros on the command line (as found in
bgpd(8), hostapd(8), ipsecctl(8), pfctl(8), ...).
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.c,v 1.14 2007/02/06 10:03:08 reyk Exp $	*/
d155 4
a158 2
	if (!debug)
		daemon(1, 0);
@


1.14
log
@change fatal message to know where it happened
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.c,v 1.13 2007/01/29 14:23:31 pyr Exp $	*/
d115 1
a115 1
	for (;(c = getopt(argc, argv, "dnf:v")) != -1;) {
d119 5
@


1.13
log
@Add SSL support to hoststated.
with help and OK reyk@@
with help and advice by claudio@@ and Srebrenko Sehic
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.c,v 1.12 2007/01/24 10:26:00 claudio Exp $	*/
d279 1
a279 1
			fatalx("parent: pipe closed");
d319 2
a320 2
		if (n == 0)     /* connection closed */
			fatalx("parent: pipe closed");
@


1.12
log
@Similar to ospfd and ripd ignore SIGPIPE in all processes to be able to do
a nice exit in case one of the processes dies. OK pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.c,v 1.11 2007/01/11 18:28:28 pyr Exp $	*/
d35 2
@


1.11
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.c,v 1.10 2007/01/11 18:05:08 reyk Exp $	*/
d182 1
@


1.10
log
@use real async events for checks and improve the non-blocking socket
usage. also modify the check_icmp code to use non-blocking raw sockets
and merge the icmp4 and icmp6 functions. some other minor changes
while i'm here.

as discussed with pyr@@ claudio@@ deraadt@@
ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.c,v 1.9 2007/01/09 13:50:11 pyr Exp $	*/
d415 2
a416 1
event_again(struct event *ev, int fd, short event, void (*fn)(int, short, void *),
@


1.9
log
@Finish renaming hostated to hoststated.
Note to testers: the user the daemon changes its id to is now _hoststated,
don't forget to update master.passwd.
ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.c,v 1.8 2007/01/09 02:32:58 reyk Exp $	*/
d412 21
@


1.8
log
@unbreak
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.c,v 1.7 2007/01/08 20:46:18 reyk Exp $	*/
d101 1
a101 1
	struct hostated	 env;
d119 1
a119 1
			opts |= HOSTATED_OPT_NOACTION;
d125 1
a125 1
			opts |= HOSTATED_OPT_VERBOSE;
d137 1
a137 1
	if (env.opts & HOSTATED_OPT_NOACTION) {
d145 2
a146 2
	if (getpwnam(HOSTATED_USER) == NULL)
		errx(1, "unknown user %s", HOSTATED_USER);
d345 1
a345 1
host_find(struct hostated *env, objid_t id)
d358 1
a358 1
table_find(struct hostated *env, objid_t id)
d369 1
a369 1
service_find(struct hostated *env, objid_t id)
d380 1
a380 1
host_findbyname(struct hostated *env, const char *name)
d393 1
a393 1
table_findbyname(struct hostated *env, const char *name)
d404 1
a404 1
service_findbyname(struct hostated *env, const char *name)
@


1.7
log
@do NOT use the regexp interface. it is way to complicated, error-prone
and we don't know about all the possible security problems.

change the check send/expect code to use the fnmatch(3) interface
using shell globbing rules instead. this allows simple patterns like
"220 * ESMTP*" or "SSH-[12].??-*".

suggested by deraadt@@ and otto@@
ok Pierre-Yves Ritschard (pyr at spootnik dot org)
@
text
@d1 1
a1 1
/*	$OpenBSD: hostated.c,v 1.6 2007/01/08 13:37:26 reyk Exp $	*/
d36 1
a36 1
#include "hostated.h"
@


1.6
log
@add a generic send/expect check using regular expression (see
regex(3)).  this allows to define additional checks for other TCP
protocols.

From Pierre-Yves Ritschard (pyr at spootnik dot org)
@
text
@d1 1
a1 1
/*	$OpenBSD: hostated.c,v 1.5 2006/12/25 18:40:38 reyk Exp $	*/
a34 1
#include <regex.h>
@


1.5
log
@knf
@
text
@d1 1
a1 1
/*	$OpenBSD: hostated.c,v 1.4 2006/12/16 18:50:33 reyk Exp $	*/
d35 1
@


1.4
log
@- allow to use host/service/table names instead of Ids in hostatectl.
- minor change of the "hostatectl show" command output
- increase the max service and tag names (max pf tag name size is 64 now!)

thanks to pyr who found a bug in my initial diff
@
text
@d1 1
a1 1
/*	$OpenBSD: hostated.c,v 1.3 2006/12/16 14:07:29 reyk Exp $	*/
d95 2
a96 1
int main(int argc, char *argv[])
@


1.3
log
@knf (second level indents are four spaces)
@
text
@d1 1
a1 1
/*	$OpenBSD: hostated.c,v 1.2 2006/12/16 12:42:14 reyk Exp $	*/
d374 35
@


1.2
log
@knf, spacing

please note that some editors will replace tabs with multiple spaces
if you cut & paste code from other sections.  please try to keep the
tabs ;).
@
text
@d1 1
a1 1
/*	$OpenBSD: hostated.c,v 1.1 2006/12/16 11:45:07 reyk Exp $	*/
d295 1
a295 1
				imsg.hdr.type);
d336 1
a336 1
				imsg.hdr.type);
@


1.1
log
@Import hostated, the host status daemon.  This daemon will monitor
remote hosts and dynamically alter pf(4) tables and redirection rules
for active server load balancing.  The daemon has been written by
Pierre-Yves Ritschard (pyr at spootnik.org) and was formerly known as
"slbd".

The daemon is fully functional but it still needs some work and
cleanup so we don't link it to the build yet.  Some TODOs are a
partial rewrite of the check_* routines (use libevent whenever we
can), improvement of the manpages, and general knf and cleanup.

ok deraadt@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d92 1
a92 1
	exit (1);
d101 1
a101 1
	const char	*conffile; 
a128 1
			
d168 1
a168 1
	
d181 1
a181 1
	
d194 9
a202 9
        ibuf_pfe->events = EV_READ;
        event_set(&ibuf_pfe->ev, ibuf_pfe->fd, ibuf_pfe->events,
            ibuf_pfe->handler, ibuf_pfe);
        event_add(&ibuf_pfe->ev, NULL);

        ibuf_hce->events = EV_READ;
        event_set(&ibuf_hce->ev, ibuf_hce->fd, ibuf_hce->events,
            ibuf_hce->handler, ibuf_hce);
        event_add(&ibuf_hce->ev, NULL);
d219 5
a223 5
        do {
                if ((pid = wait(NULL)) == -1 &&
                    errno != EINTR && errno != ECHILD)
                        fatal("wait");
        } while (pid != -1 || (pid == -1 && errno == EINTR));
d233 1
a233 1
        int     status;
d235 11
a245 11
        if (waitpid(pid, &status, WNOHANG) > 0) {
                if (WIFEXITED(status)) {
                        log_warnx("check_child: lost child: %s exited", pname);
                        return (1);
                }
                if (WIFSIGNALED(status)) {
                        log_warnx("check_child: lost child: %s terminated; signal %d",
                            pname, WTERMSIG(status));
                        return (1);
                }
        }
d247 1
a247 1
        return (0);
d258 2
a259 2
        event_set(&ibuf->ev, ibuf->fd, ibuf->events, ibuf->handler, ibuf);
        event_add(&ibuf->ev, NULL);
d307 2
a308 2
        struct imsg              imsg;
        ssize_t                  n;
d312 13
a324 13
        case EV_READ:
                if ((n = imsg_read(ibuf)) == -1)
                        fatal("imsg_read error");
                if (n == 0)     /* connection closed */
                        fatalx("parent: pipe closed");
                break;
        case EV_WRITE:
                if (msgbuf_write(&ibuf->w) == -1)
                        fatal("msgbuf_write");
                imsg_event_add(ibuf);
                return;
        default:
                fatalx("unknown event");
d327 14
a340 14
        for (;;) {
                if ((n = imsg_get(ibuf, &imsg)) == -1)
                        fatal("main_dispatch_hce: imsg_read error");
                if (n == 0)
                        break;

                switch (imsg.hdr.type) {
                default:
                        log_debug("main_dispatch_hce: unexpected imsg %d", 
                                imsg.hdr.type);
                        break;
                }
                imsg_free(&imsg);
        }
@

