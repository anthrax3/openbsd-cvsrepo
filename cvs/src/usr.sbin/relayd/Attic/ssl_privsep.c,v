head	1.12;
access;
symbols
	OPENBSD_5_6:1.10.0.4
	OPENBSD_5_6_BASE:1.10
	OPENBSD_5_5:1.9.0.8
	OPENBSD_5_5_BASE:1.9
	OPENBSD_5_4:1.9.0.4
	OPENBSD_5_4_BASE:1.9
	OPENBSD_5_3:1.9.0.2
	OPENBSD_5_3_BASE:1.9
	OPENBSD_5_2:1.8.0.8
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.8
	OPENBSD_5_1:1.8.0.6
	OPENBSD_5_0:1.8.0.4
	OPENBSD_5_0_BASE:1.8
	OPENBSD_4_9:1.8.0.2
	OPENBSD_4_9_BASE:1.8
	OPENBSD_4_8:1.7.0.6
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.7.0.2
	OPENBSD_4_7_BASE:1.7
	OPENBSD_4_6:1.7.0.4
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.6.0.6
	OPENBSD_4_5_BASE:1.6
	OPENBSD_4_4:1.6.0.4
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3:1.6.0.2
	OPENBSD_4_3_BASE:1.6;
locks; strict;
comment	@ * @;


1.12
date	2015.01.22.09.26.05;	author reyk;	state dead;
branches;
next	1.11;
commitid	o3hdD3oPPo4ygHrW;

1.11
date	2015.01.16.15.08.52;	author reyk;	state Exp;
branches;
next	1.10;
commitid	cBAkhi7b4UQjJ650;

1.10
date	2014.04.18.13.55.26;	author reyk;	state Exp;
branches;
next	1.9;

1.9
date	2012.10.04.20.53.30;	author reyk;	state Exp;
branches;
next	1.8;

1.8
date	2010.08.26.13.00.19;	author marco;	state Exp;
branches;
next	1.7;

1.7
date	2009.04.02.14.30.51;	author reyk;	state Exp;
branches;
next	1.6;

1.6
date	2007.11.24.17.07.28;	author reyk;	state Exp;
branches;
next	1.5;

1.5
date	2007.11.23.09.22.40;	author sthen;	state Exp;
branches;
next	1.4;

1.4
date	2007.11.19.15.31.36;	author reyk;	state Exp;
branches;
next	1.3;

1.3
date	2007.09.28.13.05.28;	author pyr;	state Exp;
branches;
next	1.2;

1.2
date	2007.09.27.13.34.21;	author pyr;	state Exp;
branches;
next	1.1;

1.1
date	2007.09.25.08.24.26;	author pyr;	state Exp;
branches;
next	;


desc
@@


1.12
log
@LibreSSL now supports loading of CA certificates from memory, replace
the internal and long-serving ssl_ctx_load_verify_memory() function
with a call to the SSL_CTX_load_verify_mem() API function.  The
ssl_privsep.c file with hacks for using OpenSSL in privsep'ed
processes can now go away; portable versions of smtpd and relayd
should start depending on LibreSSL or they have to carry ssl_privsep.c
in openbsd-compat to work with legacy OpenSSL.  No functional change.

Based on previous discussions with gilles@@ bluhm@@ and many others
OK bluhm@@ (as part of the libcrypto/libssl/libtls diff)
@
text
@/*      $OpenBSD: ssl_privsep.c,v 1.11 2015/01/16 15:08:52 reyk Exp $    */

/* Copyright (C) 1995-1998 Eric Young (eay@@cryptsoft.com)
 * All rights reserved.
 *
 * This package is an SSL implementation written
 * by Eric Young (eay@@cryptsoft.com).
 * The implementation was written so as to conform with Netscapes SSL.
 *
 * This library is free for commercial and non-commercial use as long as
 * the following conditions are aheared to.  The following conditions
 * apply to all code found in this distribution, be it the RC4, RSA,
 * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
 * included with this distribution is covered by the same copyright terms
 * except that the holder is Tim Hudson (tjh@@cryptsoft.com).
 *
 * Copyright remains Eric Young's, and as such any Copyright notices in
 * the code are not to be removed.
 * If this package is used in a product, Eric Young should be given attribution
 * as the author of the parts of the library used.
 * This can be in the form of a textual message at program startup or
 * in documentation (online or textual) provided with the package.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *    "This product includes cryptographic software written by
 *     Eric Young (eay@@cryptsoft.com)"
 *    The word 'cryptographic' can be left out if the rouines from the library
 *    being used are not cryptographic related :-).
 * 4. If you include any Windows specific code (or a derivative thereof) from
 *    the apps directory (application code) you must include an acknowledgement:
 *    "This product includes software written by Tim Hudson (tjh@@cryptsoft.com)"
 *
 * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * The licence and distribution terms for any publically available version or
 * derivative of this code cannot be changed.  i.e. this code cannot simply be
 * copied and put under another distribution licence
 * [including the GNU Public Licence.]
 */

/*
 * SSL operations needed when running in a privilege separated environment.
 * Adapted from openssl's ssl_rsa.c by Pierre-Yves Ritschard .
 */

#include <sys/types.h>
#include <sys/uio.h>

#include <unistd.h>
#include <stdio.h>

#include <openssl/err.h>
#include <openssl/bio.h>
#include <openssl/objects.h>
#include <openssl/evp.h>
#include <openssl/x509.h>
#include <openssl/pem.h>
#include <openssl/ssl.h>

int	 ssl_ctx_load_verify_memory(SSL_CTX *, char *, off_t);
int	 ssl_by_mem_ctrl(X509_LOOKUP *, int, const char *, long, char **);

X509_LOOKUP_METHOD x509_mem_lookup = {
	"Load cert from memory",
	NULL,			/* new */
	NULL,			/* free */
	NULL,			/* init */
	NULL,			/* shutdown */
	ssl_by_mem_ctrl,	/* ctrl */
	NULL,			/* get_by_subject */
	NULL,			/* get_by_issuer_serial */
	NULL,			/* get_by_fingerprint */
	NULL,			/* get_by_alias */
};

#define X509_L_ADD_MEM	3

int
ssl_ctx_load_verify_memory(SSL_CTX *ctx, char *buf, off_t len)
{
	X509_LOOKUP		*lu;
	struct iovec		 iov;

	if ((lu = X509_STORE_add_lookup(ctx->cert_store,
	    &x509_mem_lookup)) == NULL)
		return (0);

	iov.iov_base = buf;
	iov.iov_len = len;

	if (!ssl_by_mem_ctrl(lu, X509_L_ADD_MEM,
	    (const char *)&iov, X509_FILETYPE_PEM, NULL))
		return (0);

	return (1);
}

int
ssl_by_mem_ctrl(X509_LOOKUP *lu, int cmd, const char *buf,
    long type, char **ret)
{
	STACK_OF(X509_INFO)	*inf;
	const struct iovec	*iov;
	X509_INFO		*itmp;
	BIO			*in = NULL;
	int			 i, count = 0;

	iov = (const struct iovec *)buf;

	if (type != X509_FILETYPE_PEM)
		goto done;

	if ((in = BIO_new_mem_buf(iov->iov_base, iov->iov_len)) == NULL)
		goto done;

	if ((inf = PEM_X509_INFO_read_bio(in, NULL, NULL, NULL)) == NULL)
		goto done;

	for (i = 0; i < sk_X509_INFO_num(inf); i++) {
		itmp = sk_X509_INFO_value(inf, i);
		if (itmp->x509) {
			X509_STORE_add_cert(lu->store_ctx, itmp->x509);
			count++;
		}
		if (itmp->crl) {
			X509_STORE_add_crl(lu->store_ctx, itmp->crl);
			count++;
		}
	}
	sk_X509_INFO_pop_free(inf, X509_INFO_free);

 done:
	if (!count)
		X509err(X509_F_X509_LOAD_CERT_CRL_FILE,ERR_R_PEM_LIB);

	if (in != NULL)
		BIO_free(in);
	return (count);
}
@


1.11
log
@SSL_CTX_use_certificate_chain() has been added to LibreSSL and there
is no need to keep a local copy in ssl_privsep.c.  This adds a little
burden on OpenSMTPD-portable because it will have to put it in
openbsd-compat for compatibility with legacy OpenSSL.

OK gilles@@
@
text
@d1 1
a1 1
/*      $OpenBSD: ssl_privsep.c,v 1.10 2014/04/18 13:55:26 reyk Exp $    */
@


1.10
log
@Introduce privsep for private keys:

- Move RSA private keys to a new separate process instead of copying
them to the relays.  A custom RSA engine is used by the SSL/TLS code
of the relay processes to send RSA private key encryption/decryption
(also used for sign/verify) requests to the new "ca" processes instead
of operating on the private key directly.

- Each relay process gets its own related ca process.  Setting
"prefork 5" in the config file will spawn 10 processes (5 relay, 5
ca).  This diff also reduces the default number of relay processes
from 5 to 3 which should be suitable in most installations without a
very heavy load.

- Don't keep text versions of the keys in memory, parse them once and
keep the binary representation.  This might still be the case in
OpenSSL's internals but will be fixed in the library.

This diff doesn't prevent something like "heartbleed" but adds an
additional mitigation to prevent leakage of the private keys from the
processes doing SSL/TLS.

With feedback from many
ok benno@@
@
text
@d1 1
a1 1
/*      $OpenBSD: ssl_privsep.c,v 1.9 2012/10/04 20:53:30 reyk Exp $    */
a78 1
int	 ssl_ctx_use_certificate_chain(SSL_CTX *, char *, off_t);
a95 62

int
ssl_ctx_use_certificate_chain(SSL_CTX *ctx, char *buf, off_t len)
{
	int		 ret;
	BIO		*in;
	X509		*x;
	X509		*ca;
	unsigned long	 err;

	ret = 0;
	x = ca = NULL;

	if ((in = BIO_new_mem_buf(buf, len)) == NULL) {
		SSLerr(SSL_F_SSL_CTX_USE_CERTIFICATE_CHAIN_FILE, ERR_R_BUF_LIB);
		goto end;
	}

	if ((x = PEM_read_bio_X509(in, NULL,
	    ctx->default_passwd_callback,
	    ctx->default_passwd_callback_userdata)) == NULL) {
		SSLerr(SSL_F_SSL_CTX_USE_CERTIFICATE_CHAIN_FILE, ERR_R_PEM_LIB);
		goto end;
	}

	if (!SSL_CTX_use_certificate(ctx, x) || ERR_peek_error() != 0)
		goto end;

	/* If we could set up our certificate, now proceed to
	 * the CA certificates.
	 */

	if (ctx->extra_certs != NULL) {
		sk_X509_pop_free(ctx->extra_certs, X509_free);
		ctx->extra_certs = NULL;
	}

	while ((ca = PEM_read_bio_X509(in, NULL,
	    ctx->default_passwd_callback,
	    ctx->default_passwd_callback_userdata)) != NULL) {

		if (!SSL_CTX_add_extra_chain_cert(ctx, ca))
			goto end;
	}

	err = ERR_peek_last_error();
	if (ERR_GET_LIB(err) == ERR_LIB_PEM &&
	    ERR_GET_REASON(err) == PEM_R_NO_START_LINE)
		ERR_clear_error();
	else
		goto end;

	ret = 1;
end:
	if (ca != NULL)
		X509_free(ca);
	if (x != NULL)
		X509_free(x);
	if (in != NULL)
		BIO_free(in);
	return (ret);
}
@


1.9
log
@spacing
@
text
@d1 1
a1 1
/*      $OpenBSD: ssl_privsep.c,v 1.8 2010/08/26 13:00:19 marco Exp $    */
a78 1
int	 ssl_ctx_use_private_key(SSL_CTX *, char *, off_t);
a96 31

int
ssl_ctx_use_private_key(SSL_CTX *ctx, char *buf, off_t len)
{
	int		 ret;
	BIO		*in;
	EVP_PKEY	*pkey;

	ret = 0;

	if ((in = BIO_new_mem_buf(buf, len)) == NULL) {
		SSLerr(SSL_F_SSL_CTX_USE_PRIVATEKEY_FILE, ERR_R_BUF_LIB);
		return 0;
	}

	pkey = PEM_read_bio_PrivateKey(in, NULL,
	    ctx->default_passwd_callback,
	    ctx->default_passwd_callback_userdata);

	if (pkey == NULL) {
		SSLerr(SSL_F_SSL_CTX_USE_PRIVATEKEY_FILE, ERR_R_PEM_LIB);
		goto end;
	}
	ret = SSL_CTX_use_PrivateKey(ctx, pkey);
	EVP_PKEY_free(pkey);
end:
	if (in != NULL)
		BIO_free(in);
	return ret;
}

@


1.8
log
@stray spaces, no binary change
@
text
@d1 1
a1 1
/*      $OpenBSD: ssl_privsep.c,v 1.7 2009/04/02 14:30:51 reyk Exp $    */
d233 1
a233 1
	for(i = 0; i < sk_X509_INFO_num(inf); i++) {
d235 1
a235 1
		if(itmp->x509) {
d239 1
a239 1
		if(itmp->crl) {
@


1.7
log
@add support to specify a ca file (eg. /etc/ssl/cert.pem) to verify ssl
server certificates when connecting as an SSL client from relays.  it
works so far, but needs more testing and is currently lacking support
for certificate revocation (like CRL or OCSP).  the file ssl_privsep.c
is extended to implement more code that should be in openssl to allow
loading the ca from chroot...
@
text
@d1 1
a1 1
/*      $OpenBSD: ssl_privsep.c,v 1.6 2007/11/24 17:07:28 reyk Exp $    */
d9 1
a9 1
 * 
d16 1
a16 1
 * 
d23 1
a23 1
 * 
d38 1
a38 1
 * 4. If you include any Windows specific code (or a derivative thereof) from 
d41 1
a41 1
 * 
d53 1
a53 1
 * 
d88 1
a88 1
	NULL, 			/* init */
d196 1
a196 1
	struct iovec	 	 iov;
@


1.6
log
@sort includes, adjust to style(9)
@
text
@d1 1
a1 1
/*      $OpenBSD: ssl_privsep.c,v 1.5 2007/11/23 09:22:40 sthen Exp $    */
d65 3
d81 17
d190 63
@


1.5
log
@add cvs id

ok pyr@@
@
text
@d1 1
a1 1
/*      $OpenBSD$    */
d67 1
@


1.4
log
@spacing
@
text
@d1 2
@


1.3
log
@Change the ssl_privsep code to work on char buffers.
The fd based code introduced weirdness since all children were accessing
the same fd at once. This will also greatly facilitate reloading, no
fd-passing will be involved between the parent and relay children.

While there, cleanup the code diverting from the original ssl_rsa.c code
a bit more.

Weird behavior discovery by pascoe@@.
@
text
@d137 1
a137 1
		
@


1.2
log
@Simplify ssl_privsep.c, since it won't need to remain synced with the
equivalent openssl functions.
@
text
@d73 2
a74 2
int	 ssl_ctx_use_private_key(SSL_CTX *, int);
int	 ssl_ctx_use_certificate_chain(SSL_CTX *, int);
d77 1
a77 1
ssl_ctx_use_private_key(SSL_CTX *ctx, int fd)
a79 1
	FILE		*fp;
d84 2
a85 9
	pkey = NULL;
	if (lseek(fd, 0, SEEK_SET) == -1)
		return (ret);

	if ((fp = fdopen(fd, "r")) == NULL) {
		SSLerr(SSL_F_SSL_CTX_USE_PRIVATEKEY_FILE, ERR_R_SYS_LIB);
		return (ret);
	}
	if ((in = BIO_new_fp(fp, BIO_NOCLOSE)) == NULL) {
d87 1
a87 1
		goto end;
d95 1
a95 2
		SSLerr(SSL_F_SSL_CTX_USE_PRIVATEKEY_FILE,
		     ERR_R_PEM_LIB);
d103 1
a103 1
	return(ret);
d108 1
a108 1
ssl_ctx_use_certificate_chain(SSL_CTX *ctx, int fd)
d110 5
a114 4
	int	 ret;
	BIO	*in;
	X509	*x;
	FILE	*fp;
d117 3
a119 9
	x = NULL;
	if (lseek(fd, 0, SEEK_SET) == -1)
		return (ret);

	if ((fp = fdopen(fd, "r")) == NULL) {
		SSLerr(SSL_F_SSL_CTX_USE_CERTIFICATE_CHAIN_FILE, ERR_R_SYS_LIB);
		return (ret);
	}
	if ((in = BIO_new_fp(fp, BIO_NOCLOSE)) == NULL) {
d124 1
a124 1
	x = PEM_read_bio_X509(in, NULL,
d126 1
a126 2
	    ctx->default_passwd_callback_userdata);
	if (x == NULL) {
d131 6
a136 10
	ret = SSL_CTX_use_certificate(ctx, x);
	if (ERR_peek_error() != 0)
		ret = 0;
	if (ret) {
		/* If we could set up our certificate, now proceed to
		 * the CA certificates.
		 */
		X509		*ca;
		int		 r;
		unsigned long	 err;
d138 11
a148 21
		if (ctx->extra_certs != NULL) {
			sk_X509_pop_free(ctx->extra_certs, X509_free);
			ctx->extra_certs = NULL;
		}

		while ((ca = PEM_read_bio_X509(in, NULL,
		    ctx->default_passwd_callback,
		    ctx->default_passwd_callback_userdata)) != NULL) {
			r = SSL_CTX_add_extra_chain_cert(ctx, ca);
			if (!r) {
				X509_free(ca);
				ret = 0;
				goto end;
			}
		}
		err = ERR_peek_last_error();
		if (ERR_GET_LIB(err) == ERR_LIB_PEM &&
		    ERR_GET_REASON(err) == PEM_R_NO_START_LINE)
			ERR_clear_error();
		else 
			ret = 0;
d151 8
d160 2
@


1.1
log
@Introduce two new functions to be able to load certificates while
already chrooted and with privileges dropped.
This is the very first step in being able to reload a
layer 7 configuration.

not ok reyk who's away but should be glad to see this in.
@
text
@d63 1
d73 1
a73 1
int	 ssl_ctx_use_private_key(SSL_CTX *, int, int);
d77 1
a77 1
ssl_ctx_use_private_key(SSL_CTX *ctx, int fd, int type)
a78 1
	int 		 j;
d86 3
d98 5
a102 6
	if (type == SSL_FILETYPE_PEM) {
		j = ERR_R_PEM_LIB;
		pkey = PEM_read_bio_PrivateKey(in, NULL,
		    ctx->default_passwd_callback,
		    ctx->default_passwd_callback_userdata);
	} else {
d104 1
a104 5
		    SSL_R_BAD_SSL_FILETYPE);
		goto end;
	}
	if (pkey == NULL) {
		SSLerr(SSL_F_SSL_CTX_USE_PRIVATEKEY_FILE, j);
d126 3
@

