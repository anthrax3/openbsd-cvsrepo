head	1.24;
access;
symbols
	OPENBSD_4_7:1.22.0.2
	OPENBSD_4_7_BASE:1.22
	OPENBSD_4_6:1.20.0.4
	OPENBSD_4_6_BASE:1.20
	OPENBSD_4_5:1.14.0.2
	OPENBSD_4_5_BASE:1.14
	OPENBSD_4_4:1.13.0.2
	OPENBSD_4_4_BASE:1.13
	OPENBSD_4_3:1.9.0.2
	OPENBSD_4_3_BASE:1.9;
locks; strict;
comment	@ * @;


1.24
date	2010.05.26.16.44.32;	author nicm;	state dead;
branches;
next	1.23;

1.23
date	2010.05.26.13.56.08;	author nicm;	state Exp;
branches;
next	1.22;

1.22
date	2009.09.15.10.54.59;	author jacekm;	state Exp;
branches;
next	1.21;

1.21
date	2009.07.23.18.58.42;	author eric;	state Exp;
branches;
next	1.20;

1.20
date	2009.06.05.21.15.47;	author pyr;	state Exp;
branches;
next	1.19;

1.19
date	2009.06.05.07.14.31;	author pyr;	state Exp;
branches;
next	1.18;

1.18
date	2009.06.04.07.16.38;	author eric;	state Exp;
branches;
next	1.17;

1.17
date	2009.06.03.05.35.06;	author eric;	state Exp;
branches;
next	1.16;

1.16
date	2009.06.02.22.02.01;	author eric;	state Exp;
branches;
next	1.15;

1.15
date	2009.06.02.21.44.22;	author eric;	state Exp;
branches;
next	1.14;

1.14
date	2008.10.03.15.20.29;	author eric;	state Exp;
branches;
next	1.13;

1.13
date	2008.05.22.08.35.08;	author gilles;	state Exp;
branches;
next	1.12;

1.12
date	2008.03.24.16.11.05;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2008.03.15.16.19.02;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2008.03.13.01.49.53;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2007.12.07.17.17.00;	author reyk;	state Exp;
branches;
next	1.8;

1.8
date	2007.11.24.17.07.28;	author reyk;	state Exp;
branches;
next	1.7;

1.7
date	2007.06.12.15.16.10;	author msf;	state Exp;
branches;
next	1.6;

1.6
date	2007.02.07.13.39.58;	author reyk;	state Exp;
branches;
next	1.5;

1.5
date	2007.01.29.14.23.31;	author pyr;	state Exp;
branches;
next	1.4;

1.4
date	2007.01.09.00.45.32;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2007.01.08.20.46.18;	author reyk;	state Exp;
branches;
next	1.2;

1.2
date	2007.01.08.13.37.26;	author reyk;	state Exp;
branches;
next	1.1;

1.1
date	2006.12.16.11.45.07;	author reyk;	state Exp;
branches;
next	;


desc
@@


1.24
log
@Move imsg into libutil and add a man page.

Minor bump for libutil.

Previous versions of this diff and man page looked at by various people.

"you should just commit" deraadt
@
text
@/*	$OpenBSD: buffer.c,v 1.23 2010/05/26 13:56:08 nicm Exp $	*/

/*
 * Copyright (c) 2003, 2004 Henning Brauer <henning@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/param.h>
#include <sys/queue.h>
#include <sys/socket.h>
#include <sys/uio.h>

#include <errno.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "imsg.h"

int	ibuf_realloc(struct ibuf *, size_t);
void	ibuf_enqueue(struct msgbuf *, struct ibuf *);
void	ibuf_dequeue(struct msgbuf *, struct ibuf *);

struct ibuf *
ibuf_open(size_t len)
{
	struct ibuf	*buf;

	if ((buf = calloc(1, sizeof(struct ibuf))) == NULL)
		return (NULL);
	if ((buf->buf = malloc(len)) == NULL) {
		free(buf);
		return (NULL);
	}
	buf->size = buf->max = len;
	buf->fd = -1;

	return (buf);
}

struct ibuf *
ibuf_dynamic(size_t len, size_t max)
{
	struct ibuf	*buf;

	if (max < len)
		return (NULL);

	if ((buf = ibuf_open(len)) == NULL)
		return (NULL);

	if (max > 0)
		buf->max = max;

	return (buf);
}

int
ibuf_realloc(struct ibuf *buf, size_t len)
{
	u_char	*b;

	/* on static buffers max is eq size and so the following fails */
	if (buf->wpos + len > buf->max) {
		errno = ENOMEM;
		return (-1);
	}

	b = realloc(buf->buf, buf->wpos + len);
	if (b == NULL)
		return (-1);
	buf->buf = b;
	buf->size = buf->wpos + len;

	return (0);
}

int
ibuf_add(struct ibuf *buf, const void *data, size_t len)
{
	if (buf->wpos + len > buf->size)
		if (ibuf_realloc(buf, len) == -1)
			return (-1);

	memcpy(buf->buf + buf->wpos, data, len);
	buf->wpos += len;
	return (0);
}

void *
ibuf_reserve(struct ibuf *buf, size_t len)
{
	void	*b;

	if (buf->wpos + len > buf->size)
		if (ibuf_realloc(buf, len) == -1)
			return (NULL);

	b = buf->buf + buf->wpos;
	buf->wpos += len;
	return (b);
}

void *
ibuf_seek(struct ibuf *buf, size_t pos, size_t len)
{
	/* only allowed to seek in already written parts */
	if (pos + len > buf->wpos)
		return (NULL);

	return (buf->buf + pos);
}

size_t
ibuf_size(struct ibuf *buf)
{
	return (buf->wpos);
}

size_t
ibuf_left(struct ibuf *buf)
{
	return (buf->max - buf->wpos);
}

void
ibuf_close(struct msgbuf *msgbuf, struct ibuf *buf)
{
	ibuf_enqueue(msgbuf, buf);
}

int
ibuf_write(struct msgbuf *msgbuf)
{
	struct iovec	 iov[IOV_MAX];
	struct ibuf	*buf;
	unsigned int	 i = 0;
	ssize_t	n;

	bzero(&iov, sizeof(iov));
	TAILQ_FOREACH(buf, &msgbuf->bufs, entry) {
		if (i >= IOV_MAX)
			break;
		iov[i].iov_base = buf->buf + buf->rpos;
		iov[i].iov_len = buf->wpos - buf->rpos;
		i++;
	}

	if ((n = writev(msgbuf->fd, iov, i)) == -1) {
		if (errno == EAGAIN || errno == ENOBUFS ||
		    errno == EINTR)	/* try later */
			return (0);
		else
			return (-1);
	}

	if (n == 0) {			/* connection closed */
		errno = 0;
		return (-2);
	}

	msgbuf_drain(msgbuf, n);

	return (0);
}

void
ibuf_free(struct ibuf *buf)
{
	free(buf->buf);
	free(buf);
}

void
msgbuf_init(struct msgbuf *msgbuf)
{
	msgbuf->queued = 0;
	msgbuf->fd = -1;
	TAILQ_INIT(&msgbuf->bufs);
}

void
msgbuf_drain(struct msgbuf *msgbuf, size_t n)
{
	struct ibuf	*buf, *next;

	for (buf = TAILQ_FIRST(&msgbuf->bufs); buf != NULL && n > 0;
	    buf = next) {
		next = TAILQ_NEXT(buf, entry);
		if (buf->rpos + n >= buf->wpos) {
			n -= buf->wpos - buf->rpos;
			ibuf_dequeue(msgbuf, buf);
		} else {
			buf->rpos += n;
			n = 0;
		}
	}
}

void
msgbuf_clear(struct msgbuf *msgbuf)
{
	struct ibuf	*buf;

	while ((buf = TAILQ_FIRST(&msgbuf->bufs)) != NULL)
		ibuf_dequeue(msgbuf, buf);
}

int
msgbuf_write(struct msgbuf *msgbuf)
{
	struct iovec	 iov[IOV_MAX];
	struct ibuf	*buf;
	unsigned int	 i = 0;
	ssize_t		 n;
	struct msghdr	 msg;
	struct cmsghdr	*cmsg;
	union {
		struct cmsghdr	hdr;
		char		buf[CMSG_SPACE(sizeof(int))];
	} cmsgbuf;

	bzero(&iov, sizeof(iov));
	bzero(&msg, sizeof(msg));
	TAILQ_FOREACH(buf, &msgbuf->bufs, entry) {
		if (i >= IOV_MAX)
			break;
		iov[i].iov_base = buf->buf + buf->rpos;
		iov[i].iov_len = buf->wpos - buf->rpos;
		i++;
		if (buf->fd != -1)
			break;
	}

	msg.msg_iov = iov;
	msg.msg_iovlen = i;

	if (buf != NULL && buf->fd != -1) {
		msg.msg_control = (caddr_t)&cmsgbuf.buf;
		msg.msg_controllen = sizeof(cmsgbuf.buf);
		cmsg = CMSG_FIRSTHDR(&msg);
		cmsg->cmsg_len = CMSG_LEN(sizeof(int));
		cmsg->cmsg_level = SOL_SOCKET;
		cmsg->cmsg_type = SCM_RIGHTS;
		*(int *)CMSG_DATA(cmsg) = buf->fd;
	}

	if ((n = sendmsg(msgbuf->fd, &msg, 0)) == -1) {
		if (errno == EAGAIN || errno == ENOBUFS ||
		    errno == EINTR)	/* try later */
			return (0);
		else
			return (-1);
	}

	if (n == 0) {			/* connection closed */
		errno = 0;
		return (-2);
	}

	/*
	 * assumption: fd got sent if sendmsg sent anything
	 * this works because fds are passed one at a time
	 */
	if (buf != NULL && buf->fd != -1) {
		close(buf->fd);
		buf->fd = -1;
	}

	msgbuf_drain(msgbuf, n);

	return (0);
}

void
ibuf_enqueue(struct msgbuf *msgbuf, struct ibuf *buf)
{
	TAILQ_INSERT_TAIL(&msgbuf->bufs, buf, entry);
	msgbuf->queued++;
}

void
ibuf_dequeue(struct msgbuf *msgbuf, struct ibuf *buf)
{
	TAILQ_REMOVE(&msgbuf->bufs, buf, entry);

	if (buf->fd != -1)
		close(buf->fd);

	msgbuf->queued--;
	ibuf_free(buf);
}
@


1.23
log
@Rename some imsg bits to make namespace collisions less likely buf to
ibuf, buf_read to ibuf_read, READ_BUF_SIZE to IBUF_READ_SIZE.

ok henning gilles claudio jacekm deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.12 2009/09/15 10:54:59 jacekm Exp $	*/
@


1.22
log
@Enclose repeated buffer draining code in a new msgbuf_drain()
function, which is additionally exported for use by others.

It will be needed by smtpd's SSL module when the SMTP client code
is changed to replace libevent's evbuffers with our msgbuf_* API.

ok gilles@@ henning@@ guenther@@ eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.44 2009/07/23 18:58:42 eric Exp $	*/
d31 3
a33 3
int	buf_realloc(struct buf *, size_t);
void	buf_enqueue(struct msgbuf *, struct buf *);
void	buf_dequeue(struct msgbuf *, struct buf *);
d35 2
a36 2
struct buf *
buf_open(size_t len)
d38 1
a38 1
	struct buf	*buf;
d40 1
a40 1
	if ((buf = calloc(1, sizeof(struct buf))) == NULL)
d52 2
a53 2
struct buf *
buf_dynamic(size_t len, size_t max)
d55 1
a55 1
	struct buf	*buf;
d60 1
a60 1
	if ((buf = buf_open(len)) == NULL)
d70 1
a70 1
buf_realloc(struct buf *buf, size_t len)
d90 1
a90 1
buf_add(struct buf *buf, const void *data, size_t len)
d93 1
a93 1
		if (buf_realloc(buf, len) == -1)
d102 1
a102 1
buf_reserve(struct buf *buf, size_t len)
d107 1
a107 1
		if (buf_realloc(buf, len) == -1)
d116 1
a116 1
buf_seek(struct buf *buf, size_t pos, size_t len)
d126 1
a126 1
buf_size(struct buf *buf)
d132 1
a132 1
buf_left(struct buf *buf)
d138 1
a138 1
buf_close(struct msgbuf *msgbuf, struct buf *buf)
d140 1
a140 1
	buf_enqueue(msgbuf, buf);
d144 1
a144 1
buf_write(struct msgbuf *msgbuf)
d147 1
a147 1
	struct buf	*buf;
d179 1
a179 1
buf_free(struct buf *buf)
d196 1
a196 1
	struct buf	*buf, *next;
d203 1
a203 1
			buf_dequeue(msgbuf, buf);
d214 1
a214 1
	struct buf	*buf;
d217 1
a217 1
		buf_dequeue(msgbuf, buf);
d224 1
a224 1
	struct buf	*buf;
d287 1
a287 1
buf_enqueue(struct msgbuf *msgbuf, struct buf *buf)
d294 1
a294 1
buf_dequeue(struct msgbuf *msgbuf, struct buf *buf)
d302 1
a302 1
	buf_free(buf);
@


1.21
log
@make buf_write() behave like msgbuf_write(): send out only the
bytes that were filled, not the whole buffer.

ok pyr@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.20 2009/06/05 21:15:47 pyr Exp $	*/
d147 1
a147 1
	struct buf	*buf, *next;
d173 1
a173 11
	for (buf = TAILQ_FIRST(&msgbuf->bufs); buf != NULL && n > 0;
	    buf = next) {
		next = TAILQ_NEXT(buf, entry);
		if (buf->rpos + n >= buf->wpos) {
			n -= buf->wpos - buf->rpos;
			buf_dequeue(msgbuf, buf);
		} else {
			buf->rpos += n;
			n = 0;
		}
	}
d194 18
d224 1
a224 1
	struct buf	*buf, *next;
d281 1
a281 11
	for (buf = TAILQ_FIRST(&msgbuf->bufs); buf != NULL && n > 0;
	    buf = next) {
		next = TAILQ_NEXT(buf, entry);
		if (buf->rpos + n >= buf->wpos) {
			n -= buf->wpos - buf->rpos;
			buf_dequeue(msgbuf, buf);
		} else {
			buf->rpos += n;
			n = 0;
		}
	}
@


1.20
log
@bring buf_write here as well.
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.19 2009/06/05 07:14:31 pyr Exp $	*/
d156 1
a156 1
		iov[i].iov_len = buf->size - buf->rpos;
d176 2
a177 2
		if (buf->rpos + n >= buf->size) {
			n -= buf->size - buf->rpos;
@


1.19
log
@sync buffer.c with ospfd, send out buf->wpos and not buf->size.
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.18 2009/06/04 07:16:38 eric Exp $	*/
d141 45
@


1.18
log
@Make imsg.c and buffer.c more generic by introducing
imsg.h and a daemon-specific imsg_types.h

discussed with and "yes, please" pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.17 2009/06/03 05:35:06 eric Exp $	*/
d187 1
a187 1
		iov[i].iov_len = buf->size - buf->rpos;
d231 2
a232 2
		if (buf->rpos + n >= buf->size) {
			n -= buf->size - buf->rpos;
@


1.17
log
@change buf_close return type to void.
that function is not supposed to report anything remotely useful,
or fail in any meaningful way.

ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.16 2009/06/02 22:02:01 eric Exp $	*/
a23 2
#include <net/if.h>

a24 3
#include <event.h>
#include <limits.h>
#include <stdio.h>
d29 1
a29 3
#include <openssl/ssl.h>

#include "relayd.h"
@


1.16
log
@bring in buf_seek, buf_size and buf_left from bgpd

ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.15 2009/06/02 21:44:22 eric Exp $	*/
d144 1
a144 1
int
a147 1
	return (1);
@


1.15
log
@constify argument to buf_add

ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.14 2008/10/03 15:20:29 eric Exp $	*/
d120 22
@


1.14
log
@Unify code between the various flavors of imsg buffer.c.
Use unsigned int for msg_iovlen.

ok henning@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.13 2008/05/22 08:35:08 gilles Exp $	*/
d97 1
a97 1
buf_add(struct buf *buf, void *data, size_t len)
@


1.13
log
@- fix a bug in msgbuf_write() that caused a descriptor to stay in the fd
	list even after being sent successfully. this has imsg_get_fd()
	keep returning the first fd. no impact in relayd.

"go for it" pyr@@, "yeah someone screwed up in the copy" henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.12 2008/03/24 16:11:05 deraadt Exp $	*/
d158 1
a158 1
	int		 i = 0;
d163 2
a164 2
		struct cmsghdr hdr;
		char	buf[CMSG_SPACE(sizeof(int))];
d205 4
@


1.12
log
@msg_controllen has to be CMSG_SPACE so that the kernel can account for
each cmsg_len (ie. msg_controllen = sum of CMSG_ALIGN(cmsg_len).  This
works now that kernel fd passing has been fixed to accept a bit of
sloppiness because of this ABI repair.
lots of discussion with kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.11 2008/03/15 16:19:02 deraadt Exp $	*/
d206 2
a207 7
		msg.msg_control = (caddr_t)&cmsgbuf.buf;
		msg.msg_controllen = sizeof(cmsgbuf.buf);
		cmsg = CMSG_FIRSTHDR(&msg);
		cmsg->cmsg_len = CMSG_LEN(sizeof(int));
		cmsg->cmsg_level = SOL_SOCKET;
		cmsg->cmsg_type = SCM_RIGHTS;
		*(int *)CMSG_DATA(cmsg) = buf->fd;
@


1.11
log
@Repair the simple cases for msg_controllen where it should just be
CMSG_SIZE(sizeof(int)), not sizeof(buffer) which may be larger because
of alignment; ok kettenis hshoexer
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.10 2008/03/13 01:49:53 deraadt Exp $	*/
d184 1
a184 1
		msg.msg_controllen = CMSG_LEN(sizeof(int));
d207 1
a207 1
		msg.msg_controllen = CMSG_LEN(sizeof(int));
@


1.10
log
@Correct CMSG_SPACE and CMSG_LEN usage everywhere in the tree. Due to
an extensive discussion with otto, kettenis, millert, and hshoexer
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.9 2007/12/07 17:17:00 reyk Exp $	*/
d184 1
a184 1
		msg.msg_controllen = sizeof(cmsgbuf.buf);
d207 1
a207 1
		msg.msg_controllen = sizeof(cmsgbuf.buf);
@


1.9
log
@hoststated gets renamed to relayd.  easier to type, and actually says
what the daemon does - it is a relayer that pays attention to the status
of pools of hosts; not a status checkers that happens to do some relaying
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.8 2007/11/24 17:07:28 reyk Exp $	*/
d162 4
a165 1
	char		 cmsgbuf[CMSG_SPACE(sizeof(int))];
d183 2
a184 2
		msg.msg_control = (caddr_t)cmsgbuf;
		msg.msg_controllen = CMSG_LEN(sizeof(int));
d206 2
a207 2
		msg.msg_control = (caddr_t)cmsgbuf;
		msg.msg_controllen = CMSG_LEN(sizeof(int));
@


1.8
log
@sort includes, adjust to style(9)
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.7 2007/06/12 15:16:10 msf Exp $	*/
d36 1
a36 1
#include "hoststated.h"
@


1.7
log
@put the fd passing from bgpd back in to hoststated's version of imsg,
needed for layer 7 reload support.

ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.6 2007/02/07 13:39:58 reyk Exp $	*/
d19 1
a19 1
#include <sys/types.h>
d23 1
a23 1
#include <sys/param.h>
d25 1
@


1.6
log
@remove unused functions and variables which have been copied from
ospfd(8) (can be re-imported later if required).
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.5 2007/01/29 14:23:31 pyr Exp $	*/
d53 1
d160 2
d171 2
d178 10
d201 10
d237 4
@


1.5
log
@Add SSL support to hoststated.
with help and OK reyk@@
with help and advice by claudio@@ and Srebrenko Sehic
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.4 2007/01/09 00:45:32 deraadt Exp $	*/
a117 10
}

void *
buf_seek(struct buf *buf, size_t pos, size_t len)
{
	/* only allowed to seek in already written parts */
	if (pos + len > buf->wpos)
		return (NULL);

	return (buf->buf + pos);
@


1.4
log
@adapt to rename
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.3 2007/01/08 20:46:18 reyk Exp $	*/
d32 2
@


1.3
log
@do NOT use the regexp interface. it is way to complicated, error-prone
and we don't know about all the possible security problems.

change the check send/expect code to use the fnmatch(3) interface
using shell globbing rules instead. this allows simple patterns like
"220 * ESMTP*" or "SSH-[12].??-*".

suggested by deraadt@@ and otto@@
ok Pierre-Yves Ritschard (pyr at spootnik dot org)
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.2 2007/01/08 13:37:26 reyk Exp $	*/
d33 1
a33 1
#include "hostated.h"
@


1.2
log
@add a generic send/expect check using regular expression (see
regex(3)).  this allows to define additional checks for other TCP
protocols.

From Pierre-Yves Ritschard (pyr at spootnik dot org)
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.1 2006/12/16 11:45:07 reyk Exp $	*/
a31 1
#include <regex.h>
@


1.1
log
@Import hostated, the host status daemon.  This daemon will monitor
remote hosts and dynamically alter pf(4) tables and redirection rules
for active server load balancing.  The daemon has been written by
Pierre-Yves Ritschard (pyr at spootnik.org) and was formerly known as
"slbd".

The daemon is fully functional but it still needs some work and
cleanup so we don't link it to the build yet.  Some TODOs are a
partial rewrite of the check_* routines (use libevent whenever we
can), improvement of the manpages, and general knf and cleanup.

ok deraadt@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d32 1
@

